head	11.8;
access;
symbols
	ansi-20040405-merged:11.4.2.2
	postmerge-20040405-ansi:11.6
	premerge-20040404-ansi:11.5
	postmerge-autoconf:11.5
	autoconf-freeze:11.4.10.2
	premerge-autoconf:11.5
	ansi-20040316-freeze:11.4.2.1
	postmerge-20040315-windows:11.5
	premerge-20040315-windows:11.5
	windows-20040315-freeze:11.4.4.1
	autoconf-20031203:11.4
	autoconf-20031202:11.4
	autoconf-branch:11.4.0.10
	phong-branch:11.4.0.8
	photonmap-branch:11.4.0.6
	rel-6-1-DP:11.4
	windows-branch:11.4.0.4
	rel-6-0-2:11.2
	ansi-branch:11.4.0.2
	rel-6-0-1-branch:11.2.0.4
	hartley-6-0-post:11.3
	hartley-6-0-pre:11.2
	rel-6-0-1:11.2
	rel-6-0:11.2
	rel-5-4:11.2
	offsite-5-3-pre:11.2
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.8
date	2004.05.21.18.07.25;	author morrison;	state dead;
branches;
next	11.7;

11.7
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	11.6;

11.6
date	2004.04.05.07.44.42;	author morrison;	state Exp;
branches;
next	11.5;

11.5
date	2004.02.02.17.39.12;	author morrison;	state Exp;
branches;
next	11.4;

11.4
date	2002.08.20.17.07.46;	author jra;	state Exp;
branches
	11.4.2.1
	11.4.4.1
	11.4.10.1;
next	11.3;

11.3
date	2002.08.15.20.55.00;	author hartley;	state Exp;
branches;
next	11.2;

11.2
date	98.06.27.04.29.15;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.52.49;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.08.12.20.24.40;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.08.09.12.57.55;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.37.22;	author mike;	state Rel4_0;
branches;
next	9.4;

9.4
date	91.07.26.22.40.59;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.12.11.22.51.43;	author phil;	state Exp;
branches;
next	9.2;

9.2
date	89.09.01.01.38.51;	author phil;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.47.49;	author mike;	state Rel3_5;
branches;
next	8.4;

8.4
date	89.03.06.23.31.59;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.03.03.05.54.24;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	89.01.06.20.53.56;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.27.28;	author mike;	state Rel3_0;
branches;
next	7.4;

7.4
date	88.09.09.23.38.12;	author phil;	state Exp;
branches;
next	7.3;

7.3
date	88.01.06.06.56.02;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.01.05.22.15.41;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.26.20;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.07.51.18;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.21.51.17;	author mike;	state Rel;
branches;
next	4.4;

4.4
date	87.06.23.02.56.12;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.06.22.23.35.31;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.12.22.06.23;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.42.34;	author mike;	state Rel1;
branches;
next	1.20;

1.20
date	86.11.14.06.08.10;	author phil;	state Exp;
branches;
next	1.19;

1.19
date	86.11.14.04.38.12;	author phil;	state Exp;
branches;
next	1.18;

1.18
date	86.11.13.21.19.26;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	86.11.06.02.35.16;	author phil;	state Exp;
branches;
next	1.16;

1.16
date	86.11.05.06.24.48;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	86.11.05.04.28.11;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	86.11.04.23.48.50;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	86.10.30.18.46.52;	author phil;	state Exp;
branches;
next	1.12;

1.12
date	86.10.29.21.08.44;	author phil;	state Exp;
branches;
next	1.11;

1.11
date	86.10.29.01.36.15;	author phil;	state Exp;
branches;
next	1.10;

1.10
date	86.10.28.17.55.34;	author phil;	state Exp;
branches;
next	1.9;

1.9
date	86.10.27.04.33.34;	author phil;	state Exp;
branches;
next	1.8;

1.8
date	86.10.25.10.50.03;	author phil;	state Exp;
branches;
next	1.7;

1.7
date	86.10.24.09.45.09;	author phil;	state Exp;
branches;
next	1.6;

1.6
date	86.10.24.04.06.09;	author phil;	state Exp;
branches;
next	1.5;

1.5
date	86.10.14.23.09.08;	author phil;	state Exp;
branches;
next	1.4;

1.4
date	86.10.06.21.27.00;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	86.10.03.19.44.05;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.10.03.06.34.25;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.10.02.02.17.35;	author mike;	state Exp;
branches;
next	;

11.4.2.1
date	2002.09.19.18.01.18;	author morrison;	state Exp;
branches;
next	11.4.2.2;

11.4.2.2
date	2004.03.17.21.17.00;	author morrison;	state Exp;
branches;
next	;

11.4.4.1
date	2004.03.11.23.42.07;	author morrison;	state Exp;
branches;
next	;

11.4.10.1
date	2004.02.12.19.48.12;	author erikg;	state Exp;
branches;
next	11.4.10.2;

11.4.10.2
date	2004.03.15.14.06.19;	author erikg;	state Exp;
branches;
next	;


desc
@Adage RDS-3000 interface
@


11.8
log
@moved to src/
@
text
@/*
 *			I F _ A D A G E . C
 *
 *  Authors -
 *	Phil Dykstra
 *	Gary S. Moss
 *	Mike J. Muuss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *
 * Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libfb/if_adage.c,v 11.7 2004/05/10 15:30:45 erikg Exp $ (BRL)";
#endif

/*
 * This module is used when pre-setting the Ikonas FBC
 * (Frame Buffer Controller) to a known state.
 * The values for this table are derived from the
 * Ikonas-supplied program FBI, for compatability.
 * At present, these modes can be set:
 *	0 - LORES, 30 hz, interlaced
 *	1 - LORES, 60 hz, non-interlaced
 *	2 - HIRES, 30 hz, interlaced
 *	3 - LORES, 30 hz, interlaced, with NTSC timing
 *	4 - LORES, 30 hz, interlaced, with external sync and NTSC timing
 *
 * All that is provided is a prototype for the FBC registers;
 * the user is responsible for changing them (zooming, etc),
 * and writing them to the FBC.
 */
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <sys/types.h>
#include <fcntl.h>
#include <ctype.h>
#if defined( VLDSYSV )
#	include	<sys/_ioctl.h> /* GSM : _ needed for Sys V emulation */
#else
#	include	<sys/ioctl.h>
#endif

#include "machine.h"
#include "externs.h"
#include "fb.h"
#include "./fblocal.h"
#include "./adage.h"

_LOCAL_ int	adage_open(FBIO *ifp, char *file, int width, int height),
		adage_close(FBIO *ifp),
		adage_clear(FBIO *ifp, RGBpixel (*bgpp)),
		adage_read(FBIO *ifp, int x, int y, RGBpixel (*pixelp), long int count),
		adage_write(FBIO *ifp, int x, int y, RGBpixel (*pixelp), long int count),
		adage_rmap(FBIO *ifp, register ColorMap *cp),
		adage_wmap(FBIO *ifp, register ColorMap *cp),
		adage_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
		adage_window_set(register FBIO *ifp, int x, int y),	/* OLD */
		adage_zoom_set(FBIO *ifp, register int x, register int y),	/* OLD */
		adage_setcursor(FBIO *ifp, unsigned char *bits, int xbits, int ybits, int xorig, int yorig),
		adage_cursor(FBIO *ifp, int mode, int x, int y),
		adage_help(FBIO *ifp);

FBIO adage_interface = {
		0,
		adage_open,
		adage_close,
		adage_clear,
		adage_read,
		adage_write,
		adage_rmap,
		adage_wmap,
		adage_view,
		fb_sim_getview,
		adage_setcursor,
		adage_cursor,
		fb_sim_getcursor,
		fb_sim_readrect,
		fb_sim_writerect,
		fb_sim_bwreadrect,
		fb_sim_bwwriterect,
		fb_null,		/* poll */
		fb_null,		/* flush */
		adage_close,		/* free */
		adage_help,
		"Adage RDS3000",
		1024,
		1024,
		"/dev/ik",
		512,
		512,
		-1,
		-1,
		1, 1,			/* zoom */
		256, 256,		/* window */
		0, 0, 0,		/* cursor */
		PIXEL_NULL,
		PIXEL_NULL,
		PIXEL_NULL,
		-1,
		0,
		0L,
		0L,
		0
};

static struct ik_fbc ikfbc_setup[5] = {
    {
	/* 0 - LORES, 30 hz, interlaced */
	0,	32,		/* x, y, viewport */
	511,	511,		/* x, y, sizeview */
	0,	4067,		/* x, y, window */
	0,	0,		/* x, y, zoom */
	300,	560,		/* horiztime, nlines */
	0,	FBCH_PIXELCLOCK(45) | FBCH_DRIVEBPCK, /* Lcontrol, Hcontrol */
	0,	32		/* x, y, cursor */
    }, {
	/* 1 - LORES, 60 hz, non-interlaced */
	0,	68,		/* viewport */
	511,	1023,		/* sizeview */
	0,	4063,		/* window, -33 */
	0,	0,		/* zoom */
	144,	1143,		/* horiztime, nlines (was 144, 1167) */
	FBC_RS343 | FBC_NOINTERLACE, FBCH_PIXELCLOCK(18) | FBCH_DRIVEBPCK,
	0,	32		/* cursor */
    }, {
	/* 2 - HIRES, 30 hz, interlaced */
	0,	64,
	1023,	1023,
	0,	4033,		/* -63 */
	0,	0,
	144,	1144,		/* was 144, 1166 */
	FBC_HIRES | FBC_RS343, FBCH_PIXELCLOCK(19) | FBCH_DRIVEBPCK,
	0,	64
    }, {
	/* 3 - LORES, 30 hz, interlaced, *NTSC*, internal sync */
	0,	32,		/* x, y, viewport */
	511,	511,		/* x, y, sizeview */
	0,	4067,		/* x, y, window */
	0,	0,		/* x, y, zoom */
	300,	560,		/* horiztime, nlines [no effect] */
	0,	FBCH_PIXELCLOCK(47) | FBCH_DRIVEBPCK,
				/* Lcontrol, Hcontrol */
	0,	32		/* x, y, cursor */
    }, {
	/* 4 - LORES, 30 hz, interlaced, *NTSC*, external sync */
	0,	32,		/* x, y, viewport */
	511,	511,		/* x, y, sizeview */
	0,	4067,		/* x, y, window */
	0,	0,		/* x, y, zoom */
	300,	560,		/* horiztime, nlines [no effect] */
	FBC_EXTERNSYNC,	FBCH_PIXELCLOCK(47) | FBCH_DRIVEBPCK,
				/* Lcontrol, Hcontrol */
	0,	32		/* x, y, cursor */
    }
};

/*
 * Per adage state information.
 */
struct	ikinfo {
	struct	ik_fbc	ikfbcmem;	/* Current FBC state */
	short	*_ikUBaddr;		/* Mapped-in Ikonas address */
	/* Current values initialized in adage_init() */
	int	mode;			/* 0,1,2 */
	int	x_window, y_window;	/* Ikonas, upper left of window */
	int	y_winoff;		/* y window correction factor */
	int	x_corig, y_corig;	/* cursor origin offsets */
};
#define	IKI(ptr) ((struct ikinfo *)((ptr)->u1.p))
#define	IKIL(ptr) ((ptr)->u1.p)		/* left hand side version */

struct	adage_cursor {
	int	xbits, ybits;
	int	xorig, yorig;
	unsigned char bits[32*4];
};

static struct adage_cursor default_cursor = {
/*#include "./adageframe.h"*/
#include "./adagecursor.h"
};

/*
 * RGBpixel -> Ikonas pixel buffer
 * Used by both buffer_read & write, AND adage_color_clear
 * so be sure it holds ADAGE_DMA_BYTES.
 */
static char *_pixbuf = NULL;
typedef unsigned char IKONASpixel[4];

#define	ADAGE_DMA_BYTES	(63*1024)
#define	ADAGE_DMA_PIXELS (ADAGE_DMA_BYTES/sizeof(IKONASpixel))

/*
 *			A D A G E _ D E V I C E _ O P E N
 *
 *  Compute a fairly interesting mapping.  We are handed a string in
 *  one of these forms:
 *	/dev/ik		for ik0 (implicit number)
 *	/dev/ik3	for ik3
 *	/dev/ik4n	for ik4, no init
 *	/dev/ik5v	for ik5, NTSC Video
 *	/dev/i65e	for ik6, NTSC Video, external sync
 *
 *  Using the BRL-enhanced "lseek interface", we have to open a
 *  device node using a file name of the form:
 *	/dev/ik3l	for low-res, or
 *	/dev/ik4h	for high-res
 *
 * The device name MUST BEGIN with a string which matches
 * the generic name of the device as defined in the FBIO
 * structure.
 */
_LOCAL_ int
adage_open(FBIO *ifp, char *file, int width, int height)
{
	register int	i;
	register char	*cp;
	char	ourfile[32];
	long	xbsval[34];
	int	unit = 0;
	int	noinit = 0;
	int	ntsc = 0;
	int	ext_sync = 0;

	FB_CK_FBIO(ifp);

	/* Only 512 and 1024 opens are available */
	if( width > 512 || height > 512 )
		width = height = 1024;
	else
		width = height = 512;

	/* "/dev/ik###" gives unit */
	for( cp = file; *cp != '\0' && !isdigit(*cp); cp++ ) ;
	unit = 0;
	if( *cp && isdigit(*cp) )
		(void)sscanf( cp, "%d", &unit );
	while( *cp != '\0' && isdigit(*cp) )  cp++;	/* skip number */
	if( *cp != '\0' )  switch( *cp )  {
		case 'n':
			noinit = 1;
			break;
		case 'e':
			ext_sync = 1;
			ntsc = 1;
			width = height = 512;
			break;
		case 'v':
			ntsc = 1;
			width = height = 512;
			break;
		case 'l':
		case 'h':
			break;		/* Discard, for compatability */
		default:
			fb_log( "adage_open: Bad unit suffix %s\n", cp );
			return(-1);
	}

	(void)sprintf( ourfile, "/dev/ik%d%c", unit, width>512 ? 'h' : 'l');

	if( (ifp->if_fd = open( ourfile, O_RDWR, 0 )) == -1 )
		return	-1;

	/* create a clean ikinfo struct */
	if( (IKIL(ifp) = (char *)calloc( 1, sizeof(struct ikinfo) )) == NULL ) {
		fb_log( "adage_open: ikinfo malloc failed\n" );
		return	-1;
	}
#if defined( vax )
	if( ioctl( ifp->if_fd, IKIOGETADDR, &(IKI(ifp)->_ikUBaddr) ) < 0 )
		fb_log( "adage_open : ioctl(IKIOGETADDR) failed.\n" );
#endif
	ifp->if_width = width;
	ifp->if_height = height;
	if( ntsc )  {
		if( ext_sync )
			IKI(ifp)->mode = 4;
		else
			IKI(ifp)->mode = 3;
	} else switch( ifp->if_width ) {
	case 512:
		IKI(ifp)->mode = 1;
		break;
	case 1024:
		IKI(ifp)->mode = 2;
		break;
	default:
		fb_log( "Bad fbsize %d.\n", ifp->if_width );
		return	-1;
	}


	/* Don't initialize the Ikonas if opening the 'noinit' device,
	 * which is needed for the Lyon-Lamb video-tape controller,
	 * which is unhappy if the frame clock is shut off.
	 */
	if( !noinit )  {
		if( lseek( ifp->if_fd, (off_t)FBC*4L, 0 ) == -1 ) {
			fb_log( "adage_open : lseek failed.\n" );
			return	-1;
		}
		if( write( ifp->if_fd, (char *)&ikfbc_setup[IKI(ifp)->mode],
		    sizeof(struct ik_fbc) ) != sizeof(struct ik_fbc) ) {
			fb_log( "adage_open : write failed.\n" );
			return	-1;
		}
		IKI(ifp)->ikfbcmem = ikfbc_setup[IKI(ifp)->mode];/* struct copy */

		/* Build an identity for the crossbar switch */
		for( i=0; i < 34; i++ )
			xbsval[i] = (long)i;
		if( lseek( ifp->if_fd, (off_t)XBS*4L, 0 ) == -1 ) {
			fb_log( "adage_open : lseek failed.\n" );
			return	-1;
		}
		if( write( ifp->if_fd, (char *) xbsval, sizeof(xbsval) )
		    != sizeof(xbsval) ) {
			fb_log( "adage_open : write failed.\n" );
			return	-1;
		}

		/* Initialize the LUVO crossbar switch, too */
		xbsval[0] = 0x24L;		/* 1:1 mapping, magic number */
		if( lseek( ifp->if_fd, (off_t)LUVOXBS*4L, 0 ) == -1 ) {
			fb_log( "adage_open : lseek failed.\n" );
			return	-1;
		}
		if( write( ifp->if_fd, (char *) xbsval, sizeof(long) )
		    != sizeof(long) ) {
			fb_log( "adage_open : write failed.\n" );
			return	-1;
		}

		/* Dump in default cursor. */
		if( adage_setcursor( ifp, default_cursor.bits,
		    default_cursor.xbits, default_cursor.ybits,
		    default_cursor.xorig, default_cursor.yorig ) == -1 )
			return	-1;
	}

	/* seek to start of pixels */
	if( lseek( ifp->if_fd, (off_t)0L, 0 ) == -1 ) {
		fb_log( "adage_open : lseek failed.\n" );
		return	-1;
	}
	/* Create pixel buffer */
	if( _pixbuf == NULL ) {
		if( (_pixbuf = malloc( ADAGE_DMA_BYTES )) == NULL ) {
			fb_log( "adage_open : pixbuf malloc failed.\n" );
			return	-1;
		}
	}
	ifp->if_xzoom = 1;
	ifp->if_yzoom = 1;
	IKI(ifp)->x_window = 0;
	IKI(ifp)->y_window = 0;
	/* 12bit 2's complement window setting */
	i = ikfbc_setup[IKI(ifp)->mode].fbc_ywindow;
	if( i >= 2048 )
		i = - (4096 - i);
	IKI(ifp)->y_winoff = i;
	return	ifp->if_fd;
}

_LOCAL_ int
adage_close(FBIO *ifp)
{
	/* free ikinfo struct */
	if( IKIL(ifp) != NULL )
		(void) free( IKIL(ifp) );

	return	close( ifp->if_fd );
}

_LOCAL_ int
adage_clear(FBIO *ifp, RGBpixel (*bgpp))
{

	/* If adage_clear() was called with non-black color, must
	 *  use DMAs to fill the frame buffer since there is no
	 *  hardware support for this.
	 */
	if( bgpp != NULL && ((*bgpp)[RED] != 0 || (*bgpp)[GRN] != 0 || (*bgpp)[BLU] != 0) )
		return	adage_color_clear( ifp, bgpp );

	IKI(ifp)->ikfbcmem.fbc_Lcontrol |= FBC_AUTOCLEAR;

	if( lseek( ifp->if_fd, (off_t)FBC*4L, 0 ) == -1 ) {
		fb_log( "adage_clear : lseek failed.\n" );
		return	-1;
	}
	if( write( ifp->if_fd, &(IKI(ifp)->ikfbcmem), sizeof(struct ik_fbc) )
	    != sizeof(struct ik_fbc) ) {
		fb_log( "adage_clear : write failed.\n" );
		return	-1;
	}

	sleep( 1 );	/* Give the FBC a chance to act */
	IKI(ifp)->ikfbcmem.fbc_Lcontrol &= ~FBC_AUTOCLEAR;
	if( lseek( ifp->if_fd, (off_t)FBC*4L, 0 ) == -1 ) {
		fb_log( "adage_clear : lseek failed.\n" );
		return	-1;
	}
	if( write( ifp->if_fd, &(IKI(ifp)->ikfbcmem), sizeof(struct ik_fbc) )
	    !=	sizeof(struct ik_fbc) ) {
		fb_log( "adage_clear : write failed.\n" );
		return	-1;
	}
	return	0;
}

/*
 *  Buffered Reads and Writes:
 *  We divide the users pixel buffer into three parts, as up to
 *  three seeks and DMA's are necessary to read or write this 1st
 *  quadrant buffer in Ikonas order.
 *
 *	[....................]			tailfrag
 *	[...............................]	fullscans
 *	[...............................]
 *	             [0.................]	headfrag
 *		      ^
 *		      + start of pixelp buffer.
 */

#define	IKSEEK(x,y)	if(lseek(ifp->if_fd,(off_t)((y)*ifp->if_width+(x))\
	    		*sizeof(IKONASpixel),0) == -1) return -1;

_LOCAL_ int
adage_read(FBIO *ifp, int x, int y, RGBpixel (*pixelp), long int count)
{
	register int i;
	register char *out, *in;
	int	headfrag, tailfrag, fullscans;
	int	scan, doscans;
	int	maxikscans;
	int	width, pixels, topiky;

	if( count == 1 )
		return adage_read_pio_pixel( ifp, x, y, pixelp );

	width = ifp->if_width;
	pixels = count;

	topiky = ifp->if_height - 1 - y;	/* 1st quadrant */
	topiky -= ( x + count - 1 ) / width;	/* first y on screen */
	if( x + count <= width ) {
		/* all on one line */
		headfrag = count;
		goto headin;
	}
	if( x != 0 ) {
		/* doesn't start of beginning of line => headfrag */
		headfrag = width - x;
		pixels -= headfrag;
	} else
		headfrag = 0;

	fullscans = pixels / width;
	tailfrag = pixels - fullscans * width;	/* remainder */

	if( tailfrag != 0 ) {
		IKSEEK( 0, topiky );
		topiky++;
		if( read( ifp->if_fd, _pixbuf, tailfrag*sizeof(IKONASpixel) )
		    != tailfrag*sizeof(IKONASpixel) )
			return	-1;
		out = (char *) &(pixelp[count-tailfrag][RED]);
		in = _pixbuf;
		for( i = tailfrag; i > 0; i-- ) {
			/* VAX subscripting faster than ++ */
			*out++ = *in;
			*out++ = in[1];
			*out++ = in[2];
			in += sizeof(IKONASpixel);
		}
	}
	/* Do the full scanlines */
	if( fullscans > 0 ) {
#ifndef GM256
		maxikscans =  ADAGE_DMA_BYTES / (ifp->if_width*sizeof(IKONASpixel));
		out = (char *) &(pixelp[count-tailfrag-width][RED]);
		IKSEEK( 0, topiky );
		topiky += fullscans;
		while( fullscans > 0 ) {
			in = _pixbuf;
			doscans = fullscans > maxikscans ? maxikscans : fullscans;
			if( read( ifp->if_fd, _pixbuf, doscans*width*sizeof(IKONASpixel) )
			    != doscans*width*sizeof(IKONASpixel) )
				return	-1;
			for( scan = doscans; scan > 0; scan-- ) {
				for( i = width; i > 0; i-- ) {
					/* VAX subscripting faster than ++ */
					*out++ = *in;
					*out++ = in[1];
					*out++ = in[2];
					in += sizeof(IKONASpixel);
				}
				out -= (width << 1) * sizeof(RGBpixel);
			}
			fullscans -= doscans;
		}
#else
		out = (char *) &(pixelp[count-tailfrag-width][RED]);
		IKSEEK( 0, topiky );
		topiky += fullscans;
		while( fullscans > 0 ) {
			in = _pixbuf;
			/* Read a single scan line */
			if( read( ifp->if_fd, _pixbuf, width*sizeof(IKONASpixel) )
			    != width*sizeof(IKONASpixel) )
				return	-1;
			for( i = width; i > 0; i-- ) {
				/* VAX subscripting faster than ++ */
				*out++ = *in;
				*out++ = in[1];
				*out++ = in[2];
				in += sizeof(IKONASpixel);
			}
			out -= (width << 1) * sizeof(RGBpixel);
			fullscans--;
		}
#endif
	}
headin:
	if( headfrag != 0 ) {
		IKSEEK( x, topiky );
		out = (char *) pixelp;
		in = _pixbuf;
		if( read( ifp->if_fd, _pixbuf, headfrag*sizeof(IKONASpixel) )
		    != headfrag*sizeof(IKONASpixel) )
			return	-1;
		for( i = headfrag; i > 0; i-- ) {
			/* VAX subscripting faster than ++ */
			*out++ = *in;
			*out++ = in[1];
			*out++ = in[2];
			in += sizeof(IKONASpixel);
		}
	}
	return	count;
}

_LOCAL_ int
adage_write(FBIO *ifp, int x, int y, RGBpixel (*pixelp), long int count)
{
	register int i;
	register char *out, *in;
	int	headfrag, tailfrag, fullscans;
	int	scan, doscans;
	int	maxikscans;
	int	width, pixels, topiky;

	if( count == 1 )
		return adage_write_pio_pixel( ifp, x, y, pixelp );

	width = ifp->if_width;
	pixels = count;

	topiky = ifp->if_height - 1 - y;	/* 1st quadrant */
	topiky -= ( x + count - 1 ) / width;	/* first y on screen */
	if( x + count <= width ) {
		/* all on one line */
		headfrag = count;
		goto headout;
	}
	if( x != 0 ) {
		/* doesn't start of beginning of line => headfrag */
		headfrag = width - x;
		pixels -= headfrag;
	} else
		headfrag = 0;

	fullscans = pixels / width;
	tailfrag = pixels - fullscans * width;	/* remainder */

	if( tailfrag != 0 ) {
		IKSEEK( 0, topiky );
		topiky++;
		in = (char *) &(pixelp[count-tailfrag][RED]);
		out = _pixbuf;
		for( i = tailfrag; i > 0; i-- ) {
			/* VAX subscripting faster than ++ */
			*out = *in++;
			out[1] = *in++;
			out[2] = *in++;
			out += sizeof(IKONASpixel);
		}
		if( write( ifp->if_fd, _pixbuf, tailfrag*sizeof(IKONASpixel) )
		    != tailfrag*sizeof(IKONASpixel) )
			return	-1;
	}
	/* Do the full scanlines */
	if( fullscans > 0 ) {
#ifndef GM256
		maxikscans =  ADAGE_DMA_BYTES / (ifp->if_width*sizeof(IKONASpixel));
		in = (char *) &(pixelp[count-tailfrag-width][RED]);
		IKSEEK( 0, topiky );
		topiky += fullscans;
		while( fullscans > 0 ) {
			out = _pixbuf;
			doscans = fullscans > maxikscans ? maxikscans : fullscans;
			for( scan = doscans; scan > 0; scan-- ) {
				for( i = width; i > 0; i-- ) {
					/* VAX subscripting faster than ++ */
					*out = *in++;
					out[1] = *in++;
					out[2] = *in++;
					out += sizeof(IKONASpixel);
				}
				in -= (width << 1) * sizeof(RGBpixel);
			}
			if( write( ifp->if_fd, _pixbuf, doscans*width*sizeof(IKONASpixel) )
			    != doscans*width*sizeof(IKONASpixel) )
				return	-1;
			fullscans -= doscans;
		}
#else
		in = (char *) &(pixelp[count-tailfrag-width][RED]);
		IKSEEK( 0, topiky );
		topiky += fullscans;
		while( fullscans > 0 ) {
			out = _pixbuf;
			/* Read a single scan line */
			for( i = width; i > 0; i-- ) {
				/* VAX subscripting faster than ++ */
				*out = *in++;
				out[1] = *in++;
				out[2] = *in++;
				out += sizeof(IKONASpixel);
			}
			in -= (width << 1) * sizeof(RGBpixel);
			if( write( ifp->if_fd, _pixbuf, width*sizeof(IKONASpixel) )
			    != width*sizeof(IKONASpixel) )
				return	-1;
			fullscans--;
		}
#endif
	}
headout:
	if( headfrag != 0 ) {
		IKSEEK( x, topiky );
		in = (char *) pixelp;
		out = _pixbuf;
		for( i = headfrag; i > 0; i-- ) {
			/* VAX subscripting faster than ++ */
			*out = *in++;
			out[1] = *in++;
			out[2] = *in++;
			out += sizeof(IKONASpixel);
		}
		if( write( ifp->if_fd, _pixbuf, headfrag*sizeof(IKONASpixel) )
		    != headfrag*sizeof(IKONASpixel) )
			return	-1;
	}
	return	count;
}

/* Write 1 Ikonas pixel using PIO rather than DMA */
_LOCAL_ int
adage_write_pio_pixel(FBIO *ifp, int x, int y, RGBpixel (*datap))
{
	register int i;
	register struct ikdevice *ikp = (struct ikdevice *)(IKI(ifp)->_ikUBaddr);
	long data = 0;

	((unsigned char *)&data)[RED] = (*datap)[RED];
	((unsigned char *)&data)[GRN] = (*datap)[GRN];
	((unsigned char *)&data)[BLU] = (*datap)[BLU];

	y = ifp->if_width-1-y;		/* 1st quadrant */
	i = 10000;
	while( i-- && !(ikp->ubcomreg & IKREADY) )  /* NULL */ 	;
	if( i == 0 ) {
		fb_log( "IK READY stayed low.\n" );
		return	-1;
	}

	if( ifp->if_width == 1024 ) {
		ikp->ikcomreg = IKPIX | IKWRITE | IKINCR | IKHIRES;
		ikp->ikloaddr = x;
		ikp->ikhiaddr = y;
	} else {
		ikp->ikcomreg = IKPIX | IKWRITE | IKINCR;
		ikp->ikloaddr = x<<1;
		ikp->ikhiaddr = y<<1;
	}
	ikp->ubcomreg = 1;			/* GO */
	ikp->datareg = (u_short)data;
	ikp->datareg = (u_short)(data>>16);
	if( ikp->ubcomreg & IKERROR ) {
		fb_log( "IK ERROR bit on PIO.\n" );
		return	-1;
	}
	return	1;
}

/* Read 1 Ikonas pixel using PIO rather than DMA */
_LOCAL_ int
adage_read_pio_pixel(FBIO *ifp, int x, int y, RGBpixel (*datap))
{
	register int i;
	register struct ikdevice *ikp = (struct ikdevice *)(IKI(ifp)->_ikUBaddr);
	long data;

	y = ifp->if_width-1-y;		/* 1st quadrant */
	i = 10000;
	while( i-- && !(ikp->ubcomreg & IKREADY) )  /* NULL */ 	;
	if( i == 0 ) {
		fb_log( "IK READY stayed low (setup).\n" );
		return	-1;
	}

	if( ifp->if_width == 1024 ) {
		ikp->ikcomreg = IKPIX | IKINCR | IKHIRES;
		ikp->ikloaddr = x;
		ikp->ikhiaddr = y;
	} else {
		ikp->ikcomreg = IKPIX | IKINCR;
		ikp->ikloaddr = x<<1;
		ikp->ikhiaddr = y<<1;
	}
	ikp->ubcomreg = 1;			/* GO */

	i = 10000;
	while( i-- && !(ikp->ubcomreg & IKREADY) )  /* NULL */ 	;
	if( i == 0 ) {
		fb_log( "IK READY stayed low (after).\n" );
		return	-1;
	}
	data = ikp->datareg;			/* low */
	data |= (((long)ikp->datareg)<<16);	/* high */
	if( ikp->ubcomreg & IKERROR ) {
		fb_log( "IK ERROR bit on PIO.\n" );
		return	-1;
	}
	(*datap)[RED] = ((unsigned char *)&data)[RED];
	(*datap)[GRN] = ((unsigned char *)&data)[GRN];
	(*datap)[BLU] = ((unsigned char *)&data)[BLU];
	return	1;
}

_LOCAL_ int
adage_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
{
	adage_window_set(ifp, xcenter, ycenter);
	adage_zoom_set(ifp, xzoom, yzoom);
	fb_sim_view(ifp, xcenter, ycenter, xzoom, yzoom);
	return	0;
}

/*	a d a g e _ z o o m _ s e t ( )
	Update fbc_[xy]zoom registers in FBC
 */
_LOCAL_ int
adage_zoom_set(FBIO *ifp, register int x, register int y)
{

	/*
	 *  While page 5-6 claims that the zoom range is 1..256:1,
	 *  testing demonstrates that the actual range is 1..16:1.
	 */
	if( x < 1 )  x=1;
	if( y < 1 )  y=1;
	if( x > 16 )  x=16;
	if( y > 16 )  y=16;

	ifp->if_xzoom = x;
	ifp->if_yzoom = y;

	/*
	 * From RDS 3000 Programming Reference Manual, June 1982, section
	 * 5.3 Notes, page 5-12.
	 * In HIRES mode, horizontal zoom must be accomplished as follows:
	 * 1.   To go from a ratio of 1:1 to 2:1 you must double the
	 * 	pixel clock rate, rather than use the zoom register.
	 * 2.   Thereafter you can increment the zoom register, while
	 * 	leaving the pixel clock rate doubled.
	 */
	if( IKI(ifp)->mode == 2 )  {
		if( x > 1 )  {
			/* PIXELCLOCK rate experimentally determined as 41 */
			IKI(ifp)->ikfbcmem.fbc_Hcontrol =
				FBCH_PIXELCLOCK(41) | FBCH_DRIVEBPCK;
			if( x >= 4 )
				IKI(ifp)->ikfbcmem.fbc_xzoom = (x>>1)-1;
			else
				IKI(ifp)->ikfbcmem.fbc_xzoom = 0;
			if( x & 1 )  fb_log("Unable to do odd X zooms properly in HIRES\n");
			IKI(ifp)->ikfbcmem.fbc_xsizeview = 511;
		} else {
			IKI(ifp)->ikfbcmem.fbc_Hcontrol =
				ikfbc_setup[2].fbc_Hcontrol;
			IKI(ifp)->ikfbcmem.fbc_xzoom = 0;
			IKI(ifp)->ikfbcmem.fbc_xsizeview =
				ikfbc_setup[2].fbc_xsizeview;
		}
		/* set pixel clock */
		if( lseek( ifp->if_fd, (off_t)FBCVC*4L, 0 ) == -1 ||
		    write( ifp->if_fd, &(IKI(ifp)->ikfbcmem.fbc_Lcontrol), 4 ) != 4 ) {
			fb_log( "adage_zoom_set : FBCVC write failed.\n" );
			return	-1;
		}
		/* set x viewport size */
		if( lseek( ifp->if_fd, (off_t)FBCVPS*4L, 0 ) == -1 ||
		    write( ifp->if_fd, &(IKI(ifp)->ikfbcmem.fbc_xsizeview), 4 ) != 4 ) {
			fb_log( "adage_zoom_set : FBCVPS write failed.\n" );
			return	-1;
		}
		
	} else {
		IKI(ifp)->ikfbcmem.fbc_xzoom = x-1;
	}
	IKI(ifp)->ikfbcmem.fbc_yzoom = y-1;	/* replication count */

	if( lseek( ifp->if_fd, (off_t)FBCZOOM*4L, 0 ) == -1 ) {
		fb_log( "adage_zoom_set : lseek failed.\n" );
		return	-1;
	}
	if( write( ifp->if_fd, &(IKI(ifp)->ikfbcmem.fbc_xzoom), 4 ) != 4 ) {
		fb_log( "adage_zoom_set : FBCZOOM write failed.\n" );
		return	-1;
	}
	return	0;
}

static int
imax(int a, int b)
{
	if( a > b )
		return(a);
	return(b);
}

/*			a d a g e _ w i n d o w _ s e t ( )
 *
 *	Set FBC window location to specified values so that <x,y> are
 *	at screen center given current zoom.
 */
_LOCAL_ int
adage_window_set(register FBIO *ifp, int x, int y)
{
	int ikx, iky;		/* upper left corner of view rectangle */
	int y_viewport;
	int y_window;
	int first_line;
	int top_margin;

	ifp->if_xcenter = x;
	ifp->if_ycenter = y;

	/*
	 *  To start with, we are given the 1st quadrant coordinates
	 *  of the CENTER of the region we wish to view.  Since the
	 *  Ikonas window is specified in terms of the upper left
	 *  corner, first find the upper left corner of the rectangle
	 *  to window in on, accounting for the zoom factor too.
	 *  Then convert from first to fourth for the Ikonas.
	 *  The order of these conversions is significant.
	 */
	ikx = x - (ifp->if_width / ifp->if_xzoom)/2;
	iky = y + (ifp->if_height / ifp->if_yzoom)/2 - 1;
	iky = ifp->if_height-1-iky;		/* q1 -> q4 */

	/* for the cursor routines, save q4 upper left */
	IKI(ifp)->x_window = ikx;
	IKI(ifp)->y_window = iky;

	/*
 	 *  These formulas are taken from section 5.2.3.2.4 (page 5-5)
	 *  of the Adage RDS-3000 programming reference manual, June 1982.
	 *  Note that the published magic numbers are off by one.
	 */
	first_line = 0;
	y_viewport = IKI(ifp)->ikfbcmem.fbc_yviewport;

	switch( IKI(ifp)->mode )  {
	case 0:
	case 3:
		top_margin = imax( 35, y_viewport+4 );
		y_window = first_line - top_margin + 7;
		break;
	case 1:
		top_margin = imax( 34, (y_viewport+4)/2 );
		y_window = first_line - top_margin + 3;		/* was 4 */
		break;
	case 2:
		top_margin = imax( 69, y_viewport+4 );
		y_window = first_line - top_margin + 6;		/* was 9 */
		break;
	}
	IKI(ifp)->y_winoff = y_window;	/* save for cursor routines */
	y_window /= ifp->if_yzoom;

	/* HACK - XXX */
	if( ifp->if_xzoom > 1 )
		ikx--;
	if( IKI(ifp)->mode == 2 && ifp->if_yzoom > 1 )
		iky--;	/* hires zoom */

	if( IKI(ifp)->mode != 2 )
		IKI(ifp)->ikfbcmem.fbc_xwindow = ikx << 2;	/* lores */
	else
		IKI(ifp)->ikfbcmem.fbc_xwindow = ikx;		/* hires */

	IKI(ifp)->ikfbcmem.fbc_ywindow = iky + y_window;

	if( lseek( ifp->if_fd, (off_t)FBCWL*4L, 0 ) == -1 ) {
		fb_log( "adage_window_set : lseek failed.\n" );
		return	-1;
	}

	if( write( ifp->if_fd, &(IKI(ifp)->ikfbcmem.fbc_xwindow), 4 ) != 4 ) {
		fb_log( "adage_window_set : write failed.\n" );
		return	-1;
	}
	return	0;
}

/*	a d a g e _ c u r s o r _ m o v e _ m e m o r y _ a d d r ( )
 *
 *	Place cursor at image (pixel) coordinates x and y.
 *	IMPORTANT : Adage cursor addressing is in screen space,
 *	so backwards correction must be applied.
 */
_LOCAL_ int
adage_cursor(FBIO *ifp, int mode, int x, int y)
{
	fb_sim_cursor( ifp, mode, x, y );

	y = ifp->if_height-1-y;		/* q1 -> q4 */
	y = y - IKI(ifp)->y_window;
	x = x - IKI(ifp)->x_window;
/*
	if( y < 0 )  y = 0;
	if( x < 0 )  x = 0;
*/
	y *= ifp->if_yzoom;
	/* HACK - XXX */
	if( ifp->if_xzoom > 1 )
		x++;
	if( IKI(ifp)->mode == 2 && ifp->if_xzoom > 1 )
		x *= (ifp->if_xzoom / 2);
	else
		x *= ifp->if_xzoom;
	y -= IKI(ifp)->y_winoff;
	x -= IKI(ifp)->x_corig;
	y -= IKI(ifp)->y_corig;

	if( mode )
		IKI(ifp)->ikfbcmem.fbc_Lcontrol |= FBC_CURSOR;
	else
		IKI(ifp)->ikfbcmem.fbc_Lcontrol &= ~FBC_CURSOR;
	IKI(ifp)->ikfbcmem.fbc_xcursor = x&01777;
	IKI(ifp)->ikfbcmem.fbc_ycursor = y&01777;

	if( lseek( ifp->if_fd, (off_t)FBCVC*4L, 0 ) == -1 ) {
		fb_log( "adage_cursor : lseek failed.\n" );
		return	-1;
	}
	if( write( ifp->if_fd, &(IKI(ifp)->ikfbcmem.fbc_Lcontrol), 8 ) != 8 ) {
		fb_log( "adage_cursor : write failed.\n" );
		return	-1;
	}
	return	0;
}

/*	a d a g e _ c u r s o r _ m o v e _ s c r e e n _ a d d r ( )
	Place cursor at SCREEN coordinates x and y.
 */
_LOCAL_ int
adage_cscreen_addr(FBIO *ifp, int mode, int x, int y)
{
	y = ifp->if_width-1-y;		/* 1st quadrant */
	if( ifp->if_width == 1024 && ifp->if_yzoom == 1 )
		y += 30;
	if (mode)
		IKI(ifp)->ikfbcmem.fbc_Lcontrol |= FBC_CURSOR;
	else
		IKI(ifp)->ikfbcmem.fbc_Lcontrol &= ~FBC_CURSOR;
	IKI(ifp)->ikfbcmem.fbc_xcursor = x&01777;
	IKI(ifp)->ikfbcmem.fbc_ycursor = y&01777;

	if( lseek( ifp->if_fd, (off_t)FBCVC*4L, 0 ) == -1 ) {
		fb_log( "adage_cscreen_addr : lseek failed.\n" );
		return	-1;
	}
	if( write( ifp->if_fd, &(IKI(ifp)->ikfbcmem.fbc_Lcontrol), 8 ) != 8 ) {
		fb_log( "adage_cscreen_addr : write failed.\n" );
		return	-1;
	}
	return	0;
}

_LOCAL_ int
adage_setcursor(FBIO *ifp, unsigned char *bits, int xbits, int ybits, int xorig, int yorig)
{
	int	x, y, xbytes;
	unsigned long cursor[256];
	unsigned char *ip, imask;
	unsigned long *op, omask;

	/* Determine bytes per cursor "scanline" */
	xbytes = xbits / 8;
	if( xbytes * 8 != xbits ) xbytes++;

	/* check size of cursor */
	if( ybits > 32 ) ybits = 32;
	if( ybits < 0 ) return -1;
	if( xbits > 32 ) xbits = 32;
	if( xbits < 0 ) return -1;

	/* Clear it out first */
	for( x = 0; x < 256; x++ )
		cursor[x] = 0;

	for( y = 0; y < ybits; y++ ) {
		ip = &bits[ y * xbytes ];
		op = &cursor[ (31-y) * 8 ];
		imask = 0x80;
		omask = 1;
		for( x = 0; x < xbits; x++ ) {
			if( *ip & imask )
				*op |= omask;
			/*
			 * update bit masks and pointers
			 */
			imask >>= 1;
			if( imask == 0 ) {
				imask = 0x80;
				ip++;
			}
			omask <<= 1;
			if( omask == 0x10 ) {
				omask = 1;
				op++;
			}
		}
	}

	if( lseek( ifp->if_fd, (off_t)FBCCD*4L, 0 ) == -1 ) {
		fb_log( "adage_setcursor : lseek failed.\n" );
		return	-1;
	}
	if( write( ifp->if_fd, cursor, 1024 ) != 1024 ) {
		fb_log( "adage_setcursor : write failed.\n" );
		return	-1;
	}

	/* Set the cursor origin offsets */
	IKI(ifp)->x_corig = xorig;
	IKI(ifp)->y_corig = 32 - yorig;

	return	0;
}

#ifdef never
/*	Write one color map entry.
	Page selects the color map; 0, 1, 2, or  3.
	Offset indexes into the map.
 */
_LOCAL_ int
adage_wmap_entry( ifp, cp, page, offset )
FBIO	*ifp;
register RGBpixel	*cp;
long	page, offset;
{
	long	lp;

	lp = RGB10( (*cp)[RED]>>6, (*cp)[GRN]>>6, (*cp)[BLU]>>6 );
	lseek( ifp->if_fd, (off_t)(LUVO + page*256 + offset)*4L, 0);
	if( write( ifp->if_fd, (char *) &lp, 4 ) != 4 ) {
		fb_log( "adage_wmap_entry : write failed.\n" );
		return	-1;
	}
	return	0;
}
#endif

_LOCAL_ int
adage_wmap(FBIO *ifp, register ColorMap *cp)
{
	long cmap[1024];
	register int i, j;

	/* Note that RGB10(r,g,b) flips to cmap order (b,g,r). */
	if( cp == (ColorMap *) NULL )  {
		for( i=0; i < 256; i++ )  {
			j = i<<2;
			cmap[i] = RGB10( j, j, j );
			j = ((i+128)%255)<<2;
			cmap[i+256] = RGB10( j, j, j );
		}
	}  else  {
		for( i=0; i < 256; i++ )  {
			cmap[i] = RGB10( cp->cm_red[i]>>6,
				       cp->cm_green[i]>>6,
				       cp->cm_blue[i]>>6 );
			cmap[i+256] = RGB10( ((cp->cm_red[i]>>6)+512)%1023,
				       ((cp->cm_green[i]>>6)+512)%1023,
				       ((cp->cm_blue[i]>>6)+512)%1023 );
		}
	}

	/*
	 * Replicate first copy of color map onto second copy,
	 * and also do the "overlay" portion too.
	 */
	for( i=0; i < 256*2; i++ ) {
		cmap[i+512] = cmap[i];
	}
	if( lseek( ifp->if_fd, (off_t)LUVO*4L, 0) == -1 ) {
		fb_log( "adage_wmap : lseek failed.\n" );
		return	-1;
	}
	if( write( ifp->if_fd, cmap, 1024*4 ) != 1024*4 ) {
		fb_log( "adage_wmap : write failed.\n" );
		return	-1;
	}
	return	0;
}

_LOCAL_ int
adage_rmap(FBIO *ifp, register ColorMap *cp)
{
	register int i;
	long cmap[1024];

	if( lseek( ifp->if_fd, (off_t)LUVO*4L, 0) == -1 ) {
		fb_log( "adage_rmap : lseek failed.\n" );
		return	-1;
	}
	if( read( ifp->if_fd, cmap, 1024*4 ) != 1024*4 ) {
		fb_log( "adage_rmap : read failed.\n" );
		return	-1;
	}
	for( i=0; i < 256; i++ ) {
		cp->cm_red[i] = (cmap[i]<<(6+0))  & 0xFFC0;
		cp->cm_green[i] = (cmap[i]>>(10-6))  & 0xFFC0;
		cp->cm_blue[i] = (cmap[i]>>(20-6)) & 0xFFC0;
	}
	return	0;
}

/*
 *		A D A G E _ C O L O R _ C L E A R
 *
 *  Clear the frame buffer to the given color.  There is no hardware
 *  Support for this so we do it via large DMA's.
 */
_LOCAL_ int
adage_color_clear(register FBIO *ifp, register RGBpixel (*bpp))
{
	register IKONASpixel *pix_to;
	register long	i;
	long	pixelstodo;
	int	fd;

	/* Fill buffer with background color. */
	for( i = ADAGE_DMA_PIXELS, pix_to = (IKONASpixel *)_pixbuf; i > 0; i-- ) {
		COPYRGB( *pix_to, *bpp );
		pix_to++;
	}

	/* Set start of framebuffer */
	fd = ifp->if_fd;
	if( lseek( fd, (off_t)0L, 0 ) == -1 ) {
		fb_log( "adage_color_clear : seek failed.\n" );
		return	-1;
	}

	/* Send until frame buffer is full. */
	pixelstodo = ifp->if_height * ifp->if_width;
	while( pixelstodo > 0 ) {
		i = pixelstodo > ADAGE_DMA_PIXELS ? ADAGE_DMA_PIXELS : pixelstodo;
		if( write( fd, _pixbuf, i*sizeof(IKONASpixel) ) == -1 )
			return	-1;
		pixelstodo -= i;
	}

	return	0;
}

_LOCAL_ int
adage_help(FBIO *ifp)
{
	fb_log( "Description: %s\n", adage_interface.if_type );
	fb_log( "Device: %s\n", ifp->if_name );
	fb_log( "Max width/height: %d %d\n",
		adage_interface.if_max_width,
		adage_interface.if_max_height );
	fb_log( "Default width/height: %d %d\n",
		adage_interface.if_width,
		adage_interface.if_height );
	fb_log( "Usage: /dev/ik[#][flag]\n" );
	fb_log( "  Where # is a unit number\n" );
	fb_log( "  flag is optionally ONE of\n" );
	fb_log( "     n      no init (don't change device state)\n" );
	fb_log( "     v      NTSC Video (interlaced, external sync)\n" );

	return(0);
}
@


11.7
log
@change conf.h to a wrapped config.h
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/libfb/if_adage.c,v 11.6 2004/04/05 07:44:42 morrison Exp $ (BRL)";
@


11.6
log
@merge of ansi-6-0-branch into HEAD
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d38 5
a42 1
#include "conf.h"
@


11.5
log
@update copyright to include span through 2003
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_adage.c,v 11.4 2002/08/20 17:07:46 jra Exp $ (BRL)";
d56 13
a68 13
_LOCAL_ int	adage_open(),
		adage_close(),
		adage_clear(),
		adage_read(),
		adage_write(),
		adage_rmap(),
		adage_wmap(),
		adage_view(),
		adage_window_set(),	/* OLD */
		adage_zoom_set(),	/* OLD */
		adage_setcursor(),
		adage_cursor(),
		adage_help();
d222 1
a222 4
adage_open( ifp, file, width, height )
FBIO	*ifp;
char	*file;
int	width, height;
d375 1
a375 2
adage_close( ifp )
FBIO	*ifp;
d385 1
a385 3
adage_clear( ifp, bgpp )
FBIO	*ifp;
RGBpixel	*bgpp;
d439 1
a439 5
adage_read( ifp, x, y, pixelp, count )
FBIO	*ifp;
int	x, y;
RGBpixel *pixelp;
long	count;
d554 1
a554 5
adage_write( ifp, x, y, pixelp, count )
FBIO	*ifp;
int	x, y;
RGBpixel *pixelp;
long	count;
d670 1
a670 4
adage_write_pio_pixel( ifp, x, y, datap )
FBIO	*ifp;
int	x, y;
RGBpixel	*datap;
d709 1
a709 4
adage_read_pio_pixel( ifp, x, y, datap )
FBIO	*ifp;
int	x, y;
RGBpixel	*datap;
d753 1
a753 4
adage_view( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	xcenter, ycenter;
int	xzoom, yzoom;
d765 1
a765 3
adage_zoom_set( ifp, x, y )
FBIO	*ifp;
register int	x, y;
d837 1
a837 1
imax( a, b )
d850 1
a850 3
adage_window_set( ifp, x, y )
register FBIO	*ifp;
int	x, y;
d936 1
a936 4
adage_cursor( ifp, mode, x, y )
FBIO	*ifp;
int	mode;
int	x, y;
d981 1
a981 4
adage_cscreen_addr( ifp, mode, x, y )
FBIO	*ifp;
int	mode;
int	x, y;
d1005 1
a1005 5
adage_setcursor( ifp, bits, xbits, ybits, xorig, yorig )
FBIO	*ifp;
unsigned char	*bits;
int	xbits, ybits;
int	xorig, yorig;
d1090 1
a1090 3
adage_wmap( ifp, cp )
FBIO	*ifp;
register ColorMap	*cp;
d1133 1
a1133 3
adage_rmap( ifp, cp )
FBIO	*ifp;
register ColorMap	*cp;
d1161 1
a1161 3
adage_color_clear( ifp, bpp )
register FBIO	*ifp;
register RGBpixel	*bpp;
d1194 1
a1194 2
adage_help( ifp )
FBIO	*ifp;
@


11.4
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986 by the United States Army.
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_adage.c,v 11.2 1998/06/27 04:29:15 mike Exp $ (BRL)";
@


11.4.4.1
log
@sync to HEAD...
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libfb/if_adage.c,v 11.5 2004/02/02 17:39:12 morrison Exp $ (BRL)";
@


11.4.10.1
log
@merge from HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_adage.c,v 11.5 2004/02/02 17:39:12 morrison Exp $ (BRL)";
@


11.4.10.2
log
@merge from head
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_adage.c,v 11.4.10.1 2004/02/12 19:48:12 erikg Exp $ (BRL)";
@


11.4.2.1
log
@Initial ANSIfication
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_adage.c,v 11.4 2002/08/20 17:07:46 jra Exp $ (BRL)";
d56 13
a68 13
_LOCAL_ int	adage_open(FBIO *ifp, char *file, int width, int height),
		adage_close(FBIO *ifp),
		adage_clear(FBIO *ifp, RGBpixel (*bgpp)),
		adage_read(FBIO *ifp, int x, int y, RGBpixel (*pixelp), long int count),
		adage_write(FBIO *ifp, int x, int y, RGBpixel (*pixelp), long int count),
		adage_rmap(FBIO *ifp, register ColorMap *cp),
		adage_wmap(FBIO *ifp, register ColorMap *cp),
		adage_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
		adage_window_set(register FBIO *ifp, int x, int y),	/* OLD */
		adage_zoom_set(FBIO *ifp, register int x, register int y),	/* OLD */
		adage_setcursor(FBIO *ifp, unsigned char *bits, int xbits, int ybits, int xorig, int yorig),
		adage_cursor(FBIO *ifp, int mode, int x, int y),
		adage_help(FBIO *ifp);
d222 4
a225 1
adage_open(FBIO *ifp, char *file, int width, int height)
d378 2
a379 1
adage_close(FBIO *ifp)
d389 3
a391 1
adage_clear(FBIO *ifp, RGBpixel (*bgpp))
d445 5
a449 1
adage_read(FBIO *ifp, int x, int y, RGBpixel (*pixelp), long int count)
d564 5
a568 1
adage_write(FBIO *ifp, int x, int y, RGBpixel (*pixelp), long int count)
d684 4
a687 1
adage_write_pio_pixel(FBIO *ifp, int x, int y, RGBpixel (*datap))
d726 4
a729 1
adage_read_pio_pixel(FBIO *ifp, int x, int y, RGBpixel (*datap))
d773 4
a776 1
adage_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
d788 3
a790 1
adage_zoom_set(FBIO *ifp, register int x, register int y)
d862 1
a862 1
imax(int a, int b)
d875 3
a877 1
adage_window_set(register FBIO *ifp, int x, int y)
d963 4
a966 1
adage_cursor(FBIO *ifp, int mode, int x, int y)
d1011 4
a1014 1
adage_cscreen_addr(FBIO *ifp, int mode, int x, int y)
d1038 5
a1042 1
adage_setcursor(FBIO *ifp, unsigned char *bits, int xbits, int ybits, int xorig, int yorig)
d1127 3
a1129 1
adage_wmap(FBIO *ifp, register ColorMap *cp)
d1172 3
a1174 1
adage_rmap(FBIO *ifp, register ColorMap *cp)
d1202 3
a1204 1
adage_color_clear(register FBIO *ifp, register RGBpixel (*bpp))
d1237 2
a1238 1
adage_help(FBIO *ifp)
@


11.4.2.2
log
@sync branch with HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d19 1
a19 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.3
log
@Converted from K&R to ANSI C - RFH
@
text
@d56 13
a68 13
_LOCAL_ int	adage_open(FBIO *ifp, char *file, int width, int height),
		adage_close(FBIO *ifp),
		adage_clear(FBIO *ifp, RGBpixel (*bgpp)),
		adage_read(FBIO *ifp, int x, int y, RGBpixel (*pixelp), long int count),
		adage_write(FBIO *ifp, int x, int y, RGBpixel (*pixelp), long int count),
		adage_rmap(FBIO *ifp, register ColorMap *cp),
		adage_wmap(FBIO *ifp, register ColorMap *cp),
		adage_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
		adage_window_set(register FBIO *ifp, int x, int y),	/* OLD */
		adage_zoom_set(FBIO *ifp, register int x, register int y),	/* OLD */
		adage_setcursor(FBIO *ifp, unsigned char *bits, int xbits, int ybits, int xorig, int yorig),
		adage_cursor(FBIO *ifp, int mode, int x, int y),
		adage_help(FBIO *ifp);
d222 4
a225 1
adage_open(FBIO *ifp, char *file, int width, int height)
d378 2
a379 1
adage_close(FBIO *ifp)
d389 3
a391 1
adage_clear(FBIO *ifp, RGBpixel (*bgpp))
d445 5
a449 1
adage_read(FBIO *ifp, int x, int y, RGBpixel (*pixelp), long int count)
d564 5
a568 1
adage_write(FBIO *ifp, int x, int y, RGBpixel (*pixelp), long int count)
d684 4
a687 1
adage_write_pio_pixel(FBIO *ifp, int x, int y, RGBpixel (*datap))
d726 4
a729 1
adage_read_pio_pixel(FBIO *ifp, int x, int y, RGBpixel (*datap))
d773 4
a776 1
adage_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
d788 3
a790 1
adage_zoom_set(FBIO *ifp, register int x, register int y)
d862 1
a862 1
imax(int a, int b)
d875 3
a877 1
adage_window_set(register FBIO *ifp, int x, int y)
d963 4
a966 1
adage_cursor(FBIO *ifp, int mode, int x, int y)
d1011 4
a1014 1
adage_cscreen_addr(FBIO *ifp, int mode, int x, int y)
d1038 5
a1042 1
adage_setcursor(FBIO *ifp, unsigned char *bits, int xbits, int ybits, int xorig, int yorig)
d1127 3
a1129 1
adage_wmap(FBIO *ifp, register ColorMap *cp)
d1172 3
a1174 1
adage_rmap(FBIO *ifp, register ColorMap *cp)
d1202 3
a1204 1
adage_color_clear(register FBIO *ifp, register RGBpixel (*bpp))
d1237 2
a1238 1
adage_help(FBIO *ifp)
@


11.2
log
@Additions to LIBFB interface and remote framebuffer protocol to
read and write monochrome rectangles.
Particularly important for sending thermal images at high speed.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_adage.c,v 11.1 1995/01/04 09:52:49 mike Rel4_4 $ (BRL)";
d56 13
a68 13
_LOCAL_ int	adage_open(),
		adage_close(),
		adage_clear(),
		adage_read(),
		adage_write(),
		adage_rmap(),
		adage_wmap(),
		adage_view(),
		adage_window_set(),	/* OLD */
		adage_zoom_set(),	/* OLD */
		adage_setcursor(),
		adage_cursor(),
		adage_help();
d222 1
a222 4
adage_open( ifp, file, width, height )
FBIO	*ifp;
char	*file;
int	width, height;
d375 1
a375 2
adage_close( ifp )
FBIO	*ifp;
d385 1
a385 3
adage_clear( ifp, bgpp )
FBIO	*ifp;
RGBpixel	*bgpp;
d439 1
a439 5
adage_read( ifp, x, y, pixelp, count )
FBIO	*ifp;
int	x, y;
RGBpixel *pixelp;
long	count;
d554 1
a554 5
adage_write( ifp, x, y, pixelp, count )
FBIO	*ifp;
int	x, y;
RGBpixel *pixelp;
long	count;
d670 1
a670 4
adage_write_pio_pixel( ifp, x, y, datap )
FBIO	*ifp;
int	x, y;
RGBpixel	*datap;
d709 1
a709 4
adage_read_pio_pixel( ifp, x, y, datap )
FBIO	*ifp;
int	x, y;
RGBpixel	*datap;
d753 1
a753 4
adage_view( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	xcenter, ycenter;
int	xzoom, yzoom;
d765 1
a765 3
adage_zoom_set( ifp, x, y )
FBIO	*ifp;
register int	x, y;
d837 1
a837 1
imax( a, b )
d850 1
a850 3
adage_window_set( ifp, x, y )
register FBIO	*ifp;
int	x, y;
d936 1
a936 4
adage_cursor( ifp, mode, x, y )
FBIO	*ifp;
int	mode;
int	x, y;
d981 1
a981 4
adage_cscreen_addr( ifp, mode, x, y )
FBIO	*ifp;
int	mode;
int	x, y;
d1005 1
a1005 5
adage_setcursor( ifp, bits, xbits, ybits, xorig, yorig )
FBIO	*ifp;
unsigned char	*bits;
int	xbits, ybits;
int	xorig, yorig;
d1090 1
a1090 3
adage_wmap( ifp, cp )
FBIO	*ifp;
register ColorMap	*cp;
d1133 1
a1133 3
adage_rmap( ifp, cp )
FBIO	*ifp;
register ColorMap	*cp;
d1161 1
a1161 3
adage_color_clear( ifp, bpp )
register FBIO	*ifp;
register RGBpixel	*bpp;
d1194 1
a1194 2
adage_help( ifp )
FBIO	*ifp;
@


11.1
log
@Release_4.4
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_adage.c,v 10.3 94/08/12 20:24:40 gdurf Exp $ (BRL)";
d86 2
@


10.3
log
@Added includes
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_adage.c,v 10.2 1994/08/09 12:57:55 gdurf Exp gdurf $ (BRL)";
@


10.2
log
@Factored ifdefs
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_adage.c,v 10.1 1991/10/12 06:37:22 mike Rel4_0 gdurf $ (BRL)";
d50 2
@


10.1
log
@Release_4.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_adage.c,v 9.4 91/07/26 22:40:59 mike Exp $ (BRL)";
d38 2
d43 1
a43 9
#include "fb.h"
#include "./fblocal.h"
#include "./adage.h"

#if defined( BSD )
#include	<sys/ioctl.h>
#endif

#if defined( SYSV )
d45 1
a45 1
#include	<sys/_ioctl.h> /* GSM : _ needed for Sys V emulation */
d47 1
a47 2
#include	<sys/ioctl.h>
#endif
d50 3
a52 1
#include <ctype.h>
d306 1
a306 1
		if( lseek( ifp->if_fd, FBC*4L, 0 ) == -1 ) {
d320 1
a320 1
		if( lseek( ifp->if_fd, XBS*4L, 0 ) == -1 ) {
d332 1
a332 1
		if( lseek( ifp->if_fd, LUVOXBS*4L, 0 ) == -1 ) {
d350 1
a350 1
	if( lseek( ifp->if_fd, 0L, 0 ) == -1 ) {
d399 1
a399 1
	if( lseek( ifp->if_fd, FBC*4L, 0 ) == -1 ) {
d411 1
a411 1
	if( lseek( ifp->if_fd, FBC*4L, 0 ) == -1 ) {
d437 1
a437 1
#define	IKSEEK(x,y)	if(lseek(ifp->if_fd,((y)*ifp->if_width+(x))\
d829 1
a829 1
		if( lseek( ifp->if_fd, FBCVC*4L, 0 ) == -1 ||
d835 1
a835 1
		if( lseek( ifp->if_fd, FBCVPS*4L, 0 ) == -1 ||
d846 1
a846 1
	if( lseek( ifp->if_fd, FBCZOOM*4L, 0 ) == -1 ) {
d940 1
a940 1
	if( lseek( ifp->if_fd, FBCWL*4L, 0 ) == -1 ) {
d992 1
a992 1
	if( lseek( ifp->if_fd, FBCVC*4L, 0 ) == -1 ) {
d1022 1
a1022 1
	if( lseek( ifp->if_fd, FBCVC*4L, 0 ) == -1 ) {
d1083 1
a1083 1
	if( lseek( ifp->if_fd, FBCCD*4L, 0 ) == -1 ) {
d1113 1
a1113 1
	lseek( ifp->if_fd, (LUVO + page*256 + offset)*4L, 0);
d1156 1
a1156 1
	if( lseek( ifp->if_fd, LUVO*4L, 0) == -1 ) {
d1175 1
a1175 1
	if( lseek( ifp->if_fd, LUVO*4L, 0) == -1 ) {
d1215 1
a1215 1
	if( lseek( fd, 0L, 0 ) == -1 ) {
@


9.4
log
@Added if_magic field, and FB_CK_FBIO() macro, to allow checking
FBIO pointers
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_adage.c,v 9.3 90/12/11 22:51:43 phil Exp $ (BRL)";
@


9.3
log
@if_ struct changes.  See fb.h.  Function name cleanup.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_adage.c,v 9.2 89/09/01 01:38:51 phil Exp $ (BRL)";
d74 1
d236 2
@


9.2
log
@fb_flush and fb_free hooks.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 9.1 89/05/19 05:47:49 phil Locked $ (BRL)";
d59 12
a70 14
extern int	fb_sim_readrect(), fb_sim_writerect();

_LOCAL_ int	adage_device_open(),
		adage_device_close(),
		adage_device_clear(),
		adage_buffer_read(),
		adage_buffer_write(),
		adage_colormap_read(),
		adage_colormap_write(),
		adage_window_set(),
		adage_zoom_set(),
		adage_curs_set(),
		adage_cmemory_addr(),
		adage_cscreen_addr(),
d73 13
a85 16
FBIO adage_interface =
		{
		adage_device_open,
		adage_device_close,
		fb_null,
		adage_device_clear,
		adage_buffer_read,
		adage_buffer_write,
		adage_colormap_read,
		adage_colormap_write,
		fb_null,
		adage_window_set,
		adage_zoom_set,
		adage_curs_set,
		adage_cmemory_addr,
		adage_cscreen_addr,
d88 1
d90 1
a90 1
		adage_device_close,	/* free */
d99 4
d111 1
a111 1
		};
a171 1
	int	x_zoom, y_zoom;
d222 1
a222 1
adage_device_open( ifp, file, width, height )
d265 1
a265 1
			fb_log( "adage_device_open: Bad unit suffix %s\n", cp );
d276 1
a276 1
		fb_log( "adage_device_open: ikinfo malloc failed\n" );
d281 1
a281 1
		fb_log( "adage_device_open : ioctl(IKIOGETADDR) failed.\n" );
d309 1
a309 1
			fb_log( "adage_device_open : lseek failed.\n" );
d314 1
a314 1
			fb_log( "adage_device_open : write failed.\n" );
d323 1
a323 1
			fb_log( "adage_device_open : lseek failed.\n" );
d328 1
a328 1
			fb_log( "adage_device_open : write failed.\n" );
d335 1
a335 1
			fb_log( "adage_device_open : lseek failed.\n" );
d340 1
a340 1
			fb_log( "adage_device_open : write failed.\n" );
d345 1
a345 1
		if( adage_curs_set( ifp, default_cursor.bits,
d353 1
a353 1
		fb_log( "adage_device_open : lseek failed.\n" );
d359 1
a359 1
			fb_log( "adage_device_open : pixbuf malloc failed.\n" );
d363 2
a364 2
	IKI(ifp)->x_zoom = 1;
	IKI(ifp)->y_zoom = 1;
d376 1
a376 1
adage_device_close( ifp )
d387 1
a387 1
adage_device_clear( ifp, bgpp )
d392 1
a392 1
	/* If adage_device_clear() was called with non-black color, must
d402 1
a402 1
		fb_log( "adage_device_clear : lseek failed.\n" );
d407 1
a407 1
		fb_log( "adage_device_clear : write failed.\n" );
d414 1
a414 1
		fb_log( "adage_device_clear : lseek failed.\n" );
d419 1
a419 1
		fb_log( "adage_device_clear : write failed.\n" );
d443 1
a443 1
adage_buffer_read( ifp, x, y, pixelp, count )
d562 1
a562 1
adage_buffer_write( ifp, x, y, pixelp, count )
d770 12
d800 2
a801 2
	IKI(ifp)->x_zoom = x;
	IKI(ifp)->y_zoom = y;
d883 3
d895 2
a896 2
	ikx = x - (ifp->if_width / IKI(ifp)->x_zoom)/2;
	iky = y + (ifp->if_height / IKI(ifp)->y_zoom)/2 - 1;
d927 1
a927 1
	y_window /= IKI(ifp)->y_zoom;
d930 1
a930 1
	if( IKI(ifp)->x_zoom > 1 )
d932 1
a932 1
	if( IKI(ifp)->mode == 2 && IKI(ifp)->y_zoom > 1 )
d961 1
a961 1
adage_cmemory_addr( ifp, mode, x, y )
d966 2
d975 1
a975 1
	y *= IKI(ifp)->y_zoom;
d977 1
a977 1
	if( IKI(ifp)->x_zoom > 1 )
d979 2
a980 2
	if( IKI(ifp)->mode == 2 && IKI(ifp)->x_zoom > 1 )
		x *= (IKI(ifp)->x_zoom / 2);
d982 1
a982 1
		x *= IKI(ifp)->x_zoom;
d995 1
a995 1
		fb_log( "adage_cmemory_addr : lseek failed.\n" );
d999 1
a999 1
		fb_log( "adage_cmemory_addr : write failed.\n" );
d1015 1
a1015 1
	if( ifp->if_width == 1024 && IKI(ifp)->y_zoom == 1 )
d1036 1
a1036 1
adage_curs_set( ifp, bits, xbits, ybits, xorig, yorig )
d1086 1
a1086 1
		fb_log( "adage_curs_set : lseek failed.\n" );
d1090 1
a1090 1
		fb_log( "adage_curs_set : write failed.\n" );
d1107 1
a1107 1
adage_colormap_write_entry( ifp, cp, page, offset )
d1117 1
a1117 1
		fb_log( "adage_colormap_write_entry : write failed.\n" );
d1125 1
a1125 1
adage_colormap_write( ifp, cp )
d1159 1
a1159 1
		fb_log( "adage_colormap_write : lseek failed.\n" );
d1163 1
a1163 1
		fb_log( "adage_colormap_write : write failed.\n" );
d1170 1
a1170 1
adage_colormap_read( ifp, cp )
d1178 1
a1178 1
		fb_log( "adage_colormap_read : lseek failed.\n" );
d1182 1
a1182 1
		fb_log( "adage_colormap_read : read failed.\n" );
@


9.1
log
@Release_3.5
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 8.4 89/03/06 23:31:59 mike Exp $ (BRL)";
d93 2
@


8.4
log
@ansii
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 8.3 89/03/03 05:54:24 mike Locked $ (BRL)";
@


8.3
log
@Added support for fb_readrect() and fb_writerect().
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 8.2 89/01/06 20:53:56 mike Locked $ (BRL)";
d1104 1
a1104 1
#endif never
@


8.2
log
@ik2v used for NTSC video, with internal sync
ik2e used for NTSC video, with external sync
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 8.1 88/10/05 00:27:28 mike Locked $ (BRL)";
d59 2
d91 2
@


8.1
log
@Release_3.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 7.4 88/09/09 23:38:12 phil Exp $ (BRL)";
d31 2
a32 1
 *	3 - LORES, 30 hz, interlaced, with external sync and NTSC timing
d107 1
a107 1
static struct ik_fbc ikfbc_setup[4] = {
d136 1
a136 1
	/* 3 - LORES, 30 hz, interlaced, *NTSC*, external sync */
d139 1
a139 1
	0,	4080,		/* x, y, window */
d142 10
d205 1
d229 1
d247 5
d281 4
a284 1
		IKI(ifp)->mode = 3;
@


7.4
log
@fbhelp function
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 7.3 88/01/06 06:56:02 phil Locked $ (BRL)";
@


7.3
log
@Minor tweak to NTSC y window for better centering.
Fixed bug that would complain about "ik0l" -- not a modern
form, but quite common usage.  Make it a no-op.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 7.2 88/01/05 22:15:41 mike Locked $ (BRL)";
d69 2
a70 1
		adage_cscreen_addr();
d88 1
d1189 21
@


7.2
log
@Added "ik0v" capability, for NTSC video with external sync.
Generally much better than the "ik0n" noinit capability.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 7.1 87/11/02 23:26:20 mike Locked $ (BRL)";
d136 1
a136 1
	0,	4067,		/* x, y, window */
d236 3
d240 1
a240 1
			fb_log( "adage_device_open: Bad unit suffix\n" );
@


7.1
log
@Release 2.3
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 6.1 87/07/11 07:51:18 mike Rel $ (BRL)";
d27 1
a27 1
 * At present, three modes can be set:
d31 1
d104 1
a104 1
static struct ik_fbc ikfbc_setup[3] = {
d132 10
d191 1
d214 1
d228 12
a239 2
	if( *cp != '\0' && *cp == 'n' )
		noinit = 1;
d257 3
a259 1
	switch( ifp->if_width ) {
d867 1
@


6.1
log
@Release 2.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 5.1 87/06/24 21:51:17 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 4.4 87/06/23 02:56:12 mike Exp $ (BRL)";
@


4.4
log
@Signficantly clarified handling of FB_FILE strings -vs- /dev
node names, and permitted the bare "/dev/ik" to work again.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 4.3 87/06/22 23:35:31 mike Locked $ (BRL)";
@


4.3
log
@Revisions from Terry Slattery at USNA for GMR256 boards.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 4.1 86/12/29 03:42:34 mike Rel1 $ (BRL)";
d172 18
d197 2
a198 1
	char	ourfile[20], *cp;
d200 2
a201 1
	int	oflen;
d209 8
a216 30
	/*
	 * Determine the device name to open:
	 *   /dev/ik0l		(name)
	 *   /dev/ik0noinitl	(name for no-init device)
	 *   01234567890123456	(character offset)
	 *
	 * The device name MUST begin with a string which matches
	 * the generic name of the device as defined in the FBIO
	 * structure, followed by the unit number of the desired
	 * interface, followed by other sub-designations.  In this
	 * case, "/dev/ik" as the generic name, "0" as the unit,
	 * then "h", "l", "noinith" or "noinitl" as appropriate
	 * for high or low resolution - with or without device
	 * initialization.
	 */
	(void)strncpy(ourfile,file,20);
	if((oflen = strlen(ourfile)) > 15)
		return -1;
	oflen--;
	if( width > 512 || height > 512 ){
		if(ourfile[oflen] != 'h'){
			ourfile[oflen++] = 'h';
			ourfile[oflen] = '\0';
		}
	}else{
		if(ourfile[oflen] != 'l'){
			ourfile[oflen++] = 'l';
			ourfile[oflen] = '\0';
		}
	}
d218 2
d247 15
a261 6
	/* Don't initialize the Ikonas if opening the 'noinit' device */
	for(cp=ourfile; !isdigit(*cp); cp++)
		;
	cp++;
	if(strncmp(cp,"noinit",6) != 0){
		/* No indent to simplify the diff with old driver */
d263 12
a274 10
	if( lseek( ifp->if_fd, FBC*4L, 0 ) == -1 ) {
		fb_log( "adage_device_open : lseek failed.\n" );
		return	-1;
	}
	if( write( ifp->if_fd, (char *)&ikfbc_setup[IKI(ifp)->mode],
	    sizeof(struct ik_fbc) ) != sizeof(struct ik_fbc) ) {
		fb_log( "adage_device_open : write failed.\n" );
		return	-1;
	}
	IKI(ifp)->ikfbcmem = ikfbc_setup[IKI(ifp)->mode];/* struct copy */
d276 11
a286 12
	/* Build an identity for the crossbar switch */
	for( i=0; i < 34; i++ )
		xbsval[i] = (long)i;
	if( lseek( ifp->if_fd, XBS*4L, 0 ) == -1 ) {
		fb_log( "adage_device_open : lseek failed.\n" );
		return	-1;
	}
	if( write( ifp->if_fd, (char *) xbsval, sizeof(xbsval) )
	    != sizeof(xbsval) ) {
		fb_log( "adage_device_open : write failed.\n" );
		return	-1;
	}
d288 5
a292 5
	/* Initialize the LUVO crossbar switch, too */
	xbsval[0] = 0x24L;		/* 1:1 mapping, magic number */
	if( lseek( ifp->if_fd, LUVOXBS*4L, 0 ) == -1 ) {
		fb_log( "adage_device_open : lseek failed.\n" );
		return	-1;
a293 13
	if( write( ifp->if_fd, (char *) xbsval, sizeof(long) )
	    != sizeof(long) ) {
		fb_log( "adage_device_open : write failed.\n" );
		return	-1;
	}

	/* Dump in default cursor. */
	if( adage_curs_set( ifp, default_cursor.bits,
	    default_cursor.xbits, default_cursor.ybits,
	    default_cursor.xorig, default_cursor.yorig ) == -1 )
		return	-1;

	}	/* End of initialization */
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d55 2
d179 1
a179 1
	char	ourfile[16];
d181 1
d191 12
a202 2
	 *   /dev/ik0l
	 *   012345678
d204 2
a205 1
	if( strlen( file ) > 12 )
d207 12
a218 6
	(void)sprintf( ourfile, "%s0l", file );
	if( width > 512 || height > 512 )
		ourfile[8] = 'h';
	else
		ourfile[8] = 'l';
	ourfile[9] = '\0';
d245 9
d295 3
d444 1
d467 21
d563 1
d586 21
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 1.20 86/11/14 06:08:10 phil Exp $ (BRL)";
@


1.20
log
@finally got the window and cursor sets to work fairly well!
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 1.19 86/11/14 04:38:12 phil Locked $ (BRL)";
@


1.19
log
@New setcursor routine.
removed pdp11 code, misc parameter fixing.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 1.18 86/11/13 21:19:26 phil Locked $ (BRL)";
d781 1
a781 1
	IKI(ifp)->y_winoff = y_window;
d784 6
a820 40
#ifdef never
	register int	x_cursor_offset, y_cursor_offset;
	int x_origin = ifp->if_width / 2;	/* Odd formulas */
	int y_origin = ifp->if_height / 2;

	y = ifp->if_width-1-y;		/* 1st quadrant */
	/* Map image coordinates to screen space.			*/
	if( ifp->if_width == 1024 ) {
		switch( IKI(ifp)->x_zoom ) {
		case 16 :
			x_cursor_offset = 9;
			y_cursor_offset = 39;
			break;
		case 8 :
			x_cursor_offset = -4;
			y_cursor_offset = 43;
			break;
		case 4 :
			x_cursor_offset = -10;
			y_cursor_offset = 44;
			break;
		case 2 :
			x_cursor_offset = -17;
			y_cursor_offset = 45;
			break;
		case 1 :
			x_cursor_offset = -16;
			y_cursor_offset = 46;
			break;
		}
	} else {
		x_cursor_offset = X_CURSOR_OFFSET;
		y_cursor_offset = Y_CURSOR_OFFSET;
	}
	x = x_origin + ((x - x_origin)
		- IKI(ifp)->x_window)*IKI(ifp)->x_zoom + x_cursor_offset;
	y = y_origin + ((y - y_origin)
		- IKI(ifp)->y_window)*IKI(ifp)->y_zoom + y_cursor_offset;
#endif

d829 3
@


1.18
log
@New method of computing color maps,
fixes to cursor routines for use when zoomed-in.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 1.17 86/11/06 02:35:16 mike Locked $ (BRL)";
d64 1
a64 1
		adage_cinit_bitmap(),
d81 1
a81 1
		adage_cinit_bitmap,
d139 1
a141 1
	int	mode;			/* 0,1,2 */
d143 1
d148 8
a155 2
static long cursor[32] =
	{
d157 1
a157 1
	};
a237 1
#ifndef pdp11
a238 3
#else
		xbsval[i] = (((long)i)<<16);	/* word swap.. */
#endif
a249 1
#ifndef pdp11
a250 3
#else
	xbsval[0] = (0x24L<<16);
#endif
d262 3
a264 1
	if( adage_cinit_bitmap( ifp, cursor ) == -1 )
d282 5
d681 1
d686 2
d689 1
d695 6
d856 3
a858 3
	y -= IKI(ifp)->y_window;
	x -= IKI(ifp)->x_window;

d861 1
a861 7
#ifdef never
	if( x >= ifp->if_width/IKI(ifp)->x_zoom-1 )
		x = ifp->if_width/IKI(ifp)->x_zoom-1;
	if( y >= ifp->if_height/IKI(ifp)->y_zoom-1 )
		y = ifp->if_height/IKI(ifp)->y_zoom-1;
	y -= IKI(ifp)->y_winoff;
#else
d863 4
a866 1
	x *= IKI(ifp)->x_zoom;
d868 2
a869 2
	y += (IKI(ifp)->y_zoom-1)*2;	/* HACK to correct drift */
#endif
d920 1
a920 1
adage_cinit_bitmap( ifp, bitmap )
d922 3
a924 1
long	*bitmap;
d926 4
a929 2
	register int i;
	long	cursorarray[256];
d931 38
a968 7
#ifdef pdp11
	for(i = 0; i < 256; i++)
		cursorarray[i] = ((bitmap[i/8]>>((i%8)*4))&017L)<<16;
#else
	for (i = 0; i < 256; i++)
		cursorarray[i] = (bitmap[i/8]>>((i%8)*4))&017L;
#endif
d970 1
a970 1
		fb_log( "adage_cinit_bitmap : lseek failed.\n" );
d973 2
a974 2
	if( write( ifp->if_fd, cursorarray, 1024 ) != 1024 ) {
		fb_log( "adage_cinit_bitmap : write failed.\n" );
d977 5
a1034 13
#ifdef pdp11
	/* 16-bit-word-in-long flipping for PDP's */
	for( i=0; i < 512; i++ ) {
		register struct twiddle {
			short rhs;
			short lhs;
		}  *cmp = &cmap[i];
		register short temp;
		temp = cmp->rhs;
		cmp->rhs = cmp->lhs;
		cmp->lhs = temp;
	}
#endif
a1068 1
#ifndef pdp11
a1073 11
#else
	for( i=0; i < 256; i++ ) {
		register struct twiddle {
			short rhs;
			short lhs;
		}  *cmp = &cmap[i];
		cp->cm_red[i] = (cmp->rhs & 0x3FF) << 6;
		cp->cm_green[i] = (((cmp->lhs<<6)&0x3C0) | ((cmp->rhs>>10)&0x3F)) << 6;
		cp->cm_blue[i] = ((cmp->lhs>>4) & 0x3FF) << 6;
	}
#endif
@


1.17
log
@new versions of buffer_read and buffer_write.  Fixes 1st quadrant
buffer fragmentation problems.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 1.16 86/11/05 06:24:48 phil Locked $ (BRL)";
d140 1
a140 1
	int	x_window, y_window;
d142 1
d279 2
a280 1
	IKI(ifp)->x_window = IKI(ifp)->y_window = 0;
a725 4
	/* for the cursor routines, save q4 window parameters (??) */
	IKI(ifp)->x_window = x;
	IKI(ifp)->y_window = ifp->if_height-1-y;	/* q1 -> q4 */

d739 4
d765 1
d788 4
a791 2
	Place cursor at image coordinates x and y.
	IMPORTANT : Adage cursor addressing is in screen space.
d799 1
d837 1
d839 19
d961 1
a961 2
	register long *lp = cmap;
	register int i;
d964 10
a973 6
	if( cp == (ColorMap *) NULL )
		for( i=0; i < 256; i++ )
			*lp++ = RGB10( i<<2, i<<2, i<<2 );
	else
		for( i=0; i < 256; i++ )
			*lp++ = RGB10( cp->cm_red[i]>>6,
d976 5
d984 1
a984 1
	for( i=0; i < 256; i++ ) {
a997 2
	 * TODO:  Load inverse map into "overlay" (for cursor),
	 * and load standard film map into second map.
d999 1
a999 1
	for( i=0; i < 256; i++ ) {
a1000 1
		cmap[i+512+256] = cmap[i+256] = ~cmap[i];
@


1.16
log
@Fixed windowing to work using formulas from the manuals,
rather than the home-brew offset values.
Also fixed HIRES zooming for newer (broken) FBC boards
which need to use pixel clock for first 2X of zoom.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 1.15 86/11/05 04:28:11 mike Locked $ (BRL)";
d332 17
d352 3
a354 3
int	x,  y;
RGBpixel	*pixelp;
int	count;
d356 1
d358 4
a361 7
	register int i;
	long ikbytes = count * (long) sizeof(IKONASpixel);
	long todo;
	int toread;
	int width;
	int scanlines;
	int maxikdma;
d366 2
a367 2
	scanlines = (count+ifp->if_width-1) / ifp->if_width;	/* ceil */
	width = count - (scanlines-1) * ifp->if_width;	/* residue on last line */
d369 6
a374 11
	y = ifp->if_width-y-scanlines;		/* 1st quadrant */
	if( lseek(	ifp->if_fd,
			(((long) y * (long) ifp->if_width) + (long) x)
			* (long) sizeof(IKONASpixel),
			0
			)
	    == -1L ) {
		fb_log( "adage_buffer_read : seek to %ld failed.\n",
			(((long) y * (long) ifp->if_width) + (long) x)
			* (long) sizeof(IKONASpixel) );
		return	-1;
d376 15
a390 11
	out = (char *)&(pixelp[(scanlines-1) * ifp->if_width][RED]);
	maxikdma =  ADAGE_DMA_BYTES /
		(ifp->if_width*sizeof(IKONASpixel)) *
		(ifp->if_width*sizeof(IKONASpixel)); /* even # of scanlines */
	while( ikbytes > 0 ) {
		if( ikbytes > maxikdma )
			todo = maxikdma;
		else
			todo = ikbytes;
		toread = todo;
		if( read( ifp->if_fd, _pixbuf, toread ) != toread )
d392 1
a392 1

d394 29
a422 6
		do {
			for( i = width; i > 0; i-- ) {
				*out++ = *in;
				*out++ = in[1];
				*out++ = in[2];
				in += sizeof(IKONASpixel);
d424 2
a425 5
			todo -= width * sizeof(IKONASpixel);
			out -= (width + ifp->if_width) * sizeof(RGBpixel);
			width = ifp->if_width;
		} while( todo > 0 );
		ikbytes -= toread;
d427 16
d450 1
a450 1
RGBpixel	*pixelp;
d453 1
d455 4
a458 7
	register int i;
	register long	ikbytes = count * (long) sizeof(IKONASpixel);
	register int	todo;
	int towrite;
	int width;
	int scanlines;
	int maxikdma;
d463 2
a464 2
	scanlines = (count+ifp->if_width-1) / ifp->if_width;	/* ceil */
	width = count - (scanlines-1) * ifp->if_width;	/* residue on last line */
d466 6
a471 11
	y = ifp->if_height-y-scanlines;	/* 1st quadrant */
	if( lseek(	ifp->if_fd,
			((long) y * (long) ifp->if_width + (long) x)
			* (long) sizeof(IKONASpixel),
			0
			)
	    == -1L ) {
		fb_log( "adage_buffer_write : seek to %ld failed.\n",
			(((long) y * (long) ifp->if_width) + (long) x)
			* (long) sizeof(IKONASpixel) );
		return	-1;
d473 14
a486 10
	in = (char *)&(pixelp[(scanlines-1) * ifp->if_width][RED]);
	maxikdma =  ADAGE_DMA_BYTES /
		(ifp->if_width*sizeof(IKONASpixel)) *
		(ifp->if_width*sizeof(IKONASpixel)); /* even # of scanlines */
	while( ikbytes > 0 ) {
		if( ikbytes > maxikdma )
			todo = maxikdma;
		else
			todo = ikbytes;
		towrite = todo;
d488 29
a516 7
		do {
			for( i = width; i > 0; i-- ) {
				/* VAX subscripting faster than ++ */
				*out = *in++;
				out[1] = *in++;
				out[2] = *in++;
				out += sizeof(IKONASpixel);
d518 20
a537 5
			todo -= width * sizeof(IKONASpixel);
			in -= (width + ifp->if_width) * sizeof(RGBpixel);
			width = ifp->if_width;
		} while( todo > 0 );
		if( write( ifp->if_fd, _pixbuf, towrite ) != towrite )
a538 1
		ikbytes -= towrite;
@


1.15
log
@Revised to use formulas in Programming Reference Manual
to compute proper window values in fbzoom/fbwindow.
@
text
@d5 2
a7 1
 *	Gary S. Moss
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 1.14 86/11/04 23:48:50 mike Locked $ (BRL)";
a557 10
	/* From RDS 3000 Programming Reference Manual, June 1982, section
	 * 5.3 Notes, page 5-12.
	 * In HIRES mode, horizontal zoom must be accomplished as follows:
	 * 1.   To go from a ratio of 1:1 to 2:1 you must double the
	 * 	pixel clock rate, rather than use the zoom register.
	 * 2.   Thereafter you can increment the zoom register, while
	 * 	leaving the pixel clock rate doubled.
	  ----------
	  Actually, life is not that simple..., and this doesn't work.
	 */
d571 35
a605 3
	/* Ikonas zoom factor is actually a replication count */
	IKI(ifp)->ikfbcmem.fbc_xzoom = x-1;
	IKI(ifp)->ikfbcmem.fbc_yzoom = y-1;
d611 1
a611 1
		fb_log( "adage_zoom_set : write failed.\n" );
a656 1
fprintf(stderr,"window(%d,%d), ikx,y=%d,%d\n", x, y, ikx, iky);
a680 1
fprintf(stderr,"y_viewport=%d, top_margin=%d, y_window=%d+%d\n", y_viewport, top_margin, y_window, iky);
@


1.14
log
@For zooming, converted switch() statements to table-driven formulas.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 1.13 86/10/30 18:46:52 mike Locked $ (BRL)";
d114 1
a114 1
	0,	4063,		/* window */
d123 1
a123 1
	0,	4033,
a137 1
	int	x_origin, y_origin;
d140 1
a167 1
	int	dev_mode;
d207 1
a207 1
		dev_mode = 1;
d210 1
a210 1
		dev_mode = 2;
d220 1
a220 1
	if( write( ifp->if_fd, (char *)&ikfbc_setup[dev_mode],
d225 1
a225 1
	IKI(ifp)->ikfbcmem = ikfbc_setup[dev_mode];
a276 2
	IKI(ifp)->x_origin = ifp->if_width / 2;
	IKI(ifp)->y_origin = ifp->if_height / 2;
a296 1
	int dev_mode = 1;
d305 1
a305 3
	if( ifp->if_width == 1024 )
		dev_mode = 2;
	ikfbc_setup[dev_mode].fbc_Lcontrol |= FBC_AUTOCLEAR;
d311 1
a311 1
	if( write( ifp->if_fd, &ikfbc_setup[dev_mode], sizeof(struct ik_fbc) )
d318 1
a318 1
	ikfbc_setup[dev_mode].fbc_Lcontrol &= ~FBC_AUTOCLEAR;
d323 1
a323 1
	if( write( ifp->if_fd, &ikfbc_setup[dev_mode], sizeof(struct ik_fbc) )
d556 1
a556 1
	{
d558 6
a563 6
		5.3 Notes, page 5-12.
		In HIRES mode, horizontal zoom must be accomplished as follows:
		1.   To go from a ratio of 1:1 to 2:1 you must double the
			pixel clock rate, rather than use the zoom register.
		2.   Thereafter you can increment the zoom register, whicle
			leaving the pixel clock rate doubled.
d566 1
a566 1
	*/
d568 4
d580 1
a580 1
	/* Ikonas zoom factor is actually (factor - 1)! (replication count) */
d594 7
a600 76
static short ikXwinLo[17] = {
	0,	/* [0] */
	0,
	511,	/* [2] */
	511,
	768,	/* 4 */
	768,
	768,
	768,
	896,	/* 8 */
	900,
	904,
	910,
	920,
	930,
	940,
	950,
	960	/* 16 */
};
static short ikXwinHi[17] = {
	0,	/* [0] */
	256,
	256,	/* 2 */
	382,
	382,	/* 4 */
	382,
	382,
	382,
	446,	/* 8 */
	478,
	478,
	478,
	478,
	478,
	478,
	478,
	478	/* 16 */
};
static short ikYwinLo[17] = {
	4064,	/* [0] */
	4064,
	4208,	/* 2 */
	4208,
	4280,	/* 4 */
	4280,
	4280,
	4280,
	4316,	/* 8 */
	4316,
	4316,
	4316,
	4316,
	4316,
	4316,
	4316,
	4434	/* 16 */
};
static short ikYwinHi[17] = {
	4033,	/* [0] */
	4033,
	4321,	/* 2 */
	4321,
	4465,	/* 4 */
	4465,
	4465,
	4465,
	4537,	/* 8 */
	4537,
	4537,
	4537,
	4537,
	4537,
	4537,
	4537,
	4573	/* 16 */
};
d605 1
a605 1
 *	at screen center.
d610 1
a610 1
register int	x, y;
d612 5
a616 4
	y = ifp->if_width-1-y;		/* 1st quadrant */
	/* Window relative to image center. */
	IKI(ifp)->x_window = x -= IKI(ifp)->x_origin;
	IKI(ifp)->y_window = y -= IKI(ifp)->y_origin;
d618 3
a620 5
	if( ifp->if_width != 1024 )
		x *= 4;			/* Lores */
	IKI(ifp)->ikfbcmem.fbc_xwindow = x + ((ifp->if_width == 1024) ?
		ikXwinHi[IKI(ifp)->x_zoom] :
		ikXwinLo[IKI(ifp)->x_zoom] );
d622 13
a634 3
	IKI(ifp)->ikfbcmem.fbc_ywindow = y + ((ifp->if_width == 1024) ?
		ikYwinHi[IKI(ifp)->y_zoom] :
		ikYwinLo[IKI(ifp)->y_zoom] );
d636 32
d691 3
d723 1
a723 1
	x = IKI(ifp)->x_origin + ((x - IKI(ifp)->x_origin)
d725 1
a725 1
	y = IKI(ifp)->y_origin + ((y - IKI(ifp)->y_origin)
@


1.13
log
@check for pre-allocated _pixbuf on open.
scrapped pix_buf in clear routine, now use _pixbuf.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 1.12 86/10/29 21:08:44 phil Locked $ (BRL)";
d27 3
a29 3
 *	0 - LORES, 30 hz, non-interlaced
 *	1 - LORES, 60 hz, interlaced
 *	2 - HIRES, 30 hz, non-interlaced
d102 1
a102 1
	/* 0 - LORES, 30 hz, non-interlaced */
d111 1
a111 1
	/* 1 - LORES, 60 hz, interlaced */
d120 1
a120 1
	/* 2 - HIRES, 30 hz, non-interlaced */
d563 11
a573 30
#ifdef never
	/* Ikonas can only zoom to 1, 2, 4, 8 or 16 times actual size.	*/
	/* AHEM!!  Ikonas can pixel replicate from 0 to 15 times */
	if( x < 2 )
		x = 1;
	else
	if( x < 4 )
		x = 2;
	else
	if( x < 8 )
		x = 4;
	else
	if( x < 16 )
		x = 8;
	else
		x = 16;
	if( y < 2 )
		y = 1;
	else
	if( y < 4 )
		y = 2;
	else
	if( y < 8 )
		y = 4;
	else
	if( y < 16 )
		y = 8;
	else
		y = 16;
#else
d578 1
a578 1
#endif
d582 3
a584 5
	/* Ikonas zoom factor is actually (factor - 1)! */
	x--;
	y--;
	IKI(ifp)->ikfbcmem.fbc_xzoom = x;
	IKI(ifp)->ikfbcmem.fbc_yzoom = y;
d596 81
a676 3
/*	a d a g e _ w i n d o w _ s e t ( )
	Set FBC window location to specified values so that <x,y> are
	at screen center.
d680 1
a680 1
FBIO	*ifp;
d689 4
a692 9
		x *= 4;
	switch( IKI(ifp)->x_zoom ) {
	case 16 :
		if( ifp->if_width == 1024 )
			IKI(ifp)->ikfbcmem.fbc_xwindow = 478 + x;	/* was 480 */
		else
			IKI(ifp)->ikfbcmem.fbc_xwindow = 960 + x;
		break;
	case 8 :
d694 4
a697 53
		if( ifp->if_width == 1024 )
			IKI(ifp)->ikfbcmem.fbc_xwindow = 446 + x;	/* was 447 */
		else
			IKI(ifp)->ikfbcmem.fbc_xwindow = 896 + x;
		break;
	case 4 :
		if( ifp->if_width == 1024 )
			IKI(ifp)->ikfbcmem.fbc_xwindow = 382 + x;	/* was 383 */
		else
			IKI(ifp)->ikfbcmem.fbc_xwindow = 768 + x;
		break;
	case 2 :
		if( ifp->if_width == 1024 )
			IKI(ifp)->ikfbcmem.fbc_xwindow = 256 + x;	/* was 254 */
		else
			IKI(ifp)->ikfbcmem.fbc_xwindow = 511 + x;
		break;
	default :
		IKI(ifp)->ikfbcmem.fbc_xwindow = x;
		break;
	}
	switch( IKI(ifp)->y_zoom ) {
	case 16 :
		if( ifp->if_width == 1024 )
			IKI(ifp)->ikfbcmem.fbc_ywindow = 4573 + y; /* was 4574 */
		else
			IKI(ifp)->ikfbcmem.fbc_ywindow = 4334 + y;
		break;
	case 8 :
		if( ifp->if_width == 1024 )
			IKI(ifp)->ikfbcmem.fbc_ywindow = 4537 + y; /* was 4540 */
		else
			IKI(ifp)->ikfbcmem.fbc_ywindow = 4316 + y;
		break;
	case 4 :
		if( ifp->if_width == 1024 )
			IKI(ifp)->ikfbcmem.fbc_ywindow = 4465 + y; /* was 4472 */
		else
			IKI(ifp)->ikfbcmem.fbc_ywindow = 4280 + y;
		break;
	case 2 :
		if( ifp->if_width == 1024 )
			IKI(ifp)->ikfbcmem.fbc_ywindow = 4321 + y; /* was 4331 */
		else
			IKI(ifp)->ikfbcmem.fbc_ywindow = 4208 + y;
		break;
	default :
		if( ifp->if_width == 1024 )
			IKI(ifp)->ikfbcmem.fbc_ywindow = 4033 + y;
		else
			IKI(ifp)->ikfbcmem.fbc_ywindow = 4064 + y;
		break;
	}
@


1.12
log
@packaged static state information into malloc'd ikinfo struct.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 1.11 86/10/29 01:36:15 phil Locked $ (BRL)";
d150 6
a155 1
static char *_pixbuf;		/* RGBpixel -> Ikonas pixel buffer */
d270 5
a274 3
	if( (_pixbuf = malloc( ADAGE_DMA_BYTES )) == NULL ) {
		fb_log( "adage_device_open : pixbuf malloc failed.\n" );
		return	-1;
a948 1
	static RGBpixel	*pix_buf = NULL;
a953 6
	if( pix_buf == NULL )
		if( (pix_buf = (IKONASpixel *) malloc(ADAGE_DMA_BYTES)) == PIXEL_NULL ) {
			Malloc_Bomb(ADAGE_DMA_BYTES);
			return	-1;
		}

d955 1
a955 1
	for( i = ADAGE_DMA_PIXELS, pix_to = pix_buf; i > 0; i-- ) {
d971 1
a971 1
		if( write( fd, pix_buf, i*sizeof(IKONASpixel) ) == -1 )
@


1.11
log
@removed pbytes
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 1.10 86/10/28 17:55:34 phil Locked $ (BRL)";
d48 1
a48 1
#include	<sys/_ioctl.h> /* GSM : _ needed for Sys V emulation.		*/
d102 8
a109 7
	0,	32,
	511,	511,
	0,	4067,
	0,	0,
	300,	560,
	0,	FBCH_PIXELCLOCK(45) | FBCH_DRIVEBPCK,
	0,	32
d111 6
a116 5
	0,	68,
	511,	1023,
	0,	4063,
	0,	0,
	144,	1143,		/* was 144, 1167 */
d118 1
a118 1
	0,	32
d120 1
d131 13
a143 1
struct	ik_fbc	ikfbcmem;	/* Global memory of current FBC state	*/
a144 5
/* Current values initialized in adage_init().				*/
static int	x_origin, y_origin;
static int	x_zoom, y_zoom;
static int	x_window, y_window;

a149 3
/* Global Flags */
short	*_ikUBaddr;		/* Mapped-in Ikonas address */

d159 7
a165 6
char		*file;
int		width, height;
	{	register int	i;
		long	xbsval[34];
		int	dev_mode;
		char	ourfile[16];
d173 5
a177 2
	/* /dev/ik0l */
	/* 012345678 */
d180 1
a180 1
	sprintf( ourfile, "%s0l", file );
d189 6
d196 1
a196 1
	if( ioctl( ifp->if_fd, IKIOGETADDR, &_ikUBaddr ) < 0 )
d201 1
a201 2
	switch( ifp->if_width )
		{
d211 2
a212 3
		}
	if( lseek( ifp->if_fd, FBC*4L, 0 ) == -1 )
		{
d215 3
a217 8
		}
	if(	write(	ifp->if_fd,
			(char *)&ikfbc_setup[dev_mode],
			sizeof(struct ik_fbc)
			)
		  !=	sizeof(struct ik_fbc)
		)
		{
d220 2
a221 2
		}
	ikfbcmem = ikfbc_setup[dev_mode];
d230 1
a230 2
	if( lseek( ifp->if_fd, XBS*4L, 0 ) == -1 )
		{
d233 1
a233 1
		}
d235 1
a235 3
		!= sizeof(xbsval)
		)
		{
d238 1
a238 1
		}
d246 1
a246 2
	if( lseek( ifp->if_fd, LUVOXBS*4L, 0 ) == -1 )
		{
d249 1
a249 1
		}
d251 1
a251 3
		!= sizeof(long)
		)
		{
d254 1
a254 1
		}
d256 1
a256 1
	/* Dump in default cursor.					*/
d259 2
a260 2
	if( lseek( ifp->if_fd, 0L, 0 ) == -1 )	/* To start of pixels */
		{
d263 1
a263 1
		}
d269 5
a273 5
	x_zoom = 1;
	y_zoom = 1;
	x_origin = ifp->if_width / 2;
	y_origin = ifp->if_height / 2;
	x_window = y_window = 0;
d275 1
a275 1
	}
d280 5
a284 1
	{
d286 1
a286 1
	}
d292 3
a294 1
	{	int dev_mode = 1;
d296 2
a297 2
		use DMAs to fill the frame buffer since there is no
		hardware support for this.
d306 1
a306 2
	if( lseek( ifp->if_fd, FBC*4L, 0 ) == -1 )
		{
d309 3
a311 5
		}
	if(	write( ifp->if_fd, &ikfbc_setup[dev_mode], sizeof(struct ik_fbc) )
	     != sizeof(struct ik_fbc)
		)
		{
d314 1
a314 1
		}
d318 1
a318 2
	if( lseek( ifp->if_fd, FBC*4L, 0 ) == -1 )
		{
d321 3
a323 5
		}
	if(	write( ifp->if_fd, &ikfbc_setup[dev_mode], sizeof(struct ik_fbc) )
	    !=	sizeof(struct ik_fbc)
		)
		{
d326 1
a326 1
		}
d328 1
a328 1
	}
d464 1
a464 1
	{
d466 1
a466 1
	register struct ikdevice *ikp = (struct ikdevice *)_ikUBaddr;
d476 1
a476 2
	if( i == 0 )
		{
d479 1
a479 1
		}
d481 1
a481 2
	if( ifp->if_width == 1024 )
		{
d485 1
a485 3
		}
	else
		{
d489 1
a489 1
		}
d493 1
a493 2
	if( ikp->ubcomreg & IKERROR )
		{
d496 1
a496 1
		}
d498 1
a498 1
	}
d501 1
a501 1
_LOCAL_ long
d506 1
a506 1
	{
d508 1
a508 1
	register struct ikdevice *ikp = (struct ikdevice *)_ikUBaddr;
d514 1
a514 2
	if( i == 0 )
		{
d517 1
a517 1
		}
d519 1
a519 2
	if( ifp->if_width == 1024 )
		{
d523 1
a523 3
		}
	else
		{
d527 1
a527 1
		}
d532 1
a532 2
	if( i == 0 )
		{
d535 1
a535 1
		}
d538 1
a538 2
	if( ikp->ubcomreg & IKERROR )
		{
d541 1
a541 1
		}
d546 1
a546 1
	}
d591 2
a592 2
	x_zoom = x;
	y_zoom = y;
d594 1
a594 1
	/* Ikonas zoom factor is actually (factor - 1)!			*/
d597 3
a599 4
	ikfbcmem.fbc_xzoom = x;
	ikfbcmem.fbc_yzoom = y;
	if( lseek( ifp->if_fd, FBCZOOM*4L, 0 ) == -1 )
		{
d602 2
a603 3
		}
	if( write( ifp->if_fd, &ikfbcmem.fbc_xzoom, 4 ) != 4 )
		{
d606 1
a606 1
		}
d608 1
a608 1
	}
d618 1
a618 1
	{
d620 3
a622 3
	/* Window relative to image center.				*/
	x_window = x -= x_origin;
	y_window = y -= y_origin;
d626 1
a626 2
	switch( x_zoom )
		{
d629 1
a629 1
			ikfbcmem.fbc_xwindow = 478 + x;	/* was 480 */
d631 1
a631 1
			ikfbcmem.fbc_xwindow = 960 + x;
d634 1
d636 1
a636 1
			ikfbcmem.fbc_xwindow = 446 + x;	/* was 447 */
d638 1
a638 1
			ikfbcmem.fbc_xwindow = 896 + x;
d642 1
a642 1
			ikfbcmem.fbc_xwindow = 382 + x;	/* was 383 */
d644 1
a644 1
			ikfbcmem.fbc_xwindow = 768 + x;
d648 1
a648 1
			ikfbcmem.fbc_xwindow = 256 + x;	/* was 254 */
d650 1
a650 1
			ikfbcmem.fbc_xwindow = 511 + x;
d653 1
a653 1
		ikfbcmem.fbc_xwindow = x;
d655 2
a656 3
		}
	switch( y_zoom )
		{
d659 1
a659 1
			ikfbcmem.fbc_ywindow = 4573 + y; /* was 4574 */
d661 1
a661 1
			ikfbcmem.fbc_ywindow = 4334 + y;
d665 1
a665 1
			ikfbcmem.fbc_ywindow = 4537 + y; /* was 4540 */
d667 1
a667 1
			ikfbcmem.fbc_ywindow = 4316 + y;
d671 1
a671 1
			ikfbcmem.fbc_ywindow = 4465 + y; /* was 4472 */
d673 1
a673 1
			ikfbcmem.fbc_ywindow = 4280 + y;
d677 1
a677 1
			ikfbcmem.fbc_ywindow = 4321 + y; /* was 4331 */
d679 1
a679 1
			ikfbcmem.fbc_ywindow = 4208 + y;
d683 1
a683 1
			ikfbcmem.fbc_ywindow = 4033 + y;
d685 1
a685 1
			ikfbcmem.fbc_ywindow = 4064 + y;
d687 2
a688 3
		}
	if( lseek( ifp->if_fd, FBCWL*4L, 0 ) == -1 )
		{
d691 1
a691 1
		}
d693 1
a693 2
	if( write( ifp->if_fd, &ikfbcmem.fbc_xwindow, 4 ) != 4 )
		{
d696 1
a696 1
		}
d698 1
a698 1
	}
d707 4
a710 3
int		mode;
int		x, y;
	{	register int	x_cursor_offset, y_cursor_offset;
d713 2
a714 4
	if( ifp->if_width == 1024 )
		{
		switch( x_zoom )
			{
a734 1
			}
d736 1
a736 2
	else
		{
d739 5
a743 3
		}
	x = x_origin + ((x - x_origin) - x_window)*x_zoom + x_cursor_offset;
	y = y_origin + ((y - y_origin) - y_window)*y_zoom + y_cursor_offset;
d746 1
a746 1
		ikfbcmem.fbc_Lcontrol |= FBC_CURSOR;
d748 3
a750 3
		ikfbcmem.fbc_Lcontrol &= ~FBC_CURSOR;
	ikfbcmem.fbc_xcursor = x&01777;
	ikfbcmem.fbc_ycursor = y&01777;
d752 1
a752 2
	if( lseek( ifp->if_fd, FBCVC*4L, 0 ) == -1 )
		{
d755 2
a756 3
		}
	if( write( ifp->if_fd, &ikfbcmem.fbc_Lcontrol, 8 ) != 8 )
		{
d759 1
a759 1
		}
d761 1
a761 1
	}
d769 3
a771 3
int		mode;
int		x, y;
	{
d773 1
a773 1
	if( ifp->if_width == 1024 && y_zoom == 1 )
d776 1
a776 1
		ikfbcmem.fbc_Lcontrol |= FBC_CURSOR;
d778 3
a780 3
		ikfbcmem.fbc_Lcontrol &= ~FBC_CURSOR;
	ikfbcmem.fbc_xcursor = x&01777;
	ikfbcmem.fbc_ycursor = y&01777;
d782 1
a782 2
	if( lseek( ifp->if_fd, FBCVC*4L, 0 ) == -1 )
		{
d785 2
a786 3
		}
	if( write( ifp->if_fd, &ikfbcmem.fbc_Lcontrol, 8 ) != 8 )
		{
d789 1
a789 1
		}
d791 1
a791 1
	}
d796 5
a800 3
long		*bitmap;
	{	register int i;
		long	cursorarray[256];
d808 1
a808 2
	if( lseek( ifp->if_fd, FBCCD*4L, 0 ) == -1 )
		{
d811 2
a812 3
		}
	if( write( ifp->if_fd, cursorarray, 1024 ) != 1024 )
		{
d815 1
a815 1
		}
d817 1
a817 1
	}
d819 1
d829 2
a830 1
	{	long	lp;
d834 1
a834 2
	if( write( ifp->if_fd, (char *) &lp, 4 ) != 4 )
		{
d837 1
a837 1
		}
d839 2
a840 1
	}
d844 1
a844 1
FBIO		*ifp;
d851 1
a851 1
	/* Note that RGB10(r,g,b) flips to cmap order (b,g,r).		*/
d863 2
a864 4
	for( i=0; i < 256; i++ )
		{
		register struct twiddle
			{
d867 1
a867 1
			}  *cmp = &cmap[i];
d872 1
a872 1
		}
d880 1
a880 2
	for( i=0; i < 256; i++ )
		{
d883 2
a884 3
		}
	if( lseek( ifp->if_fd, LUVO*4L, 0) == -1 )
		{
d887 2
a888 3
		}
	if( write( ifp->if_fd, cmap, 1024*4 ) != 1024*4 )
		{
d891 1
a891 1
		}
d893 1
a893 1
	}
d903 1
a903 2
	if( lseek( ifp->if_fd, LUVO*4L, 0) == -1 )
		{
d906 2
a907 3
		}
	if( read( ifp->if_fd, cmap, 1024*4 ) != 1024*4 )
		{
d910 1
a910 1
		}
d912 1
a912 2
	for( i=0; i < 256; i++ )
		{
d916 1
a916 1
		}
d918 2
a919 4
	for( i=0; i < 256; i++ )
		{
		register struct twiddle
			{
d922 1
a922 1
			}  *cmp = &cmap[i];
d926 1
a926 1
		}
@


1.10
log
@added if_debug
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 1.9 86/10/27 04:33:34 phil Locked $ (BRL)";
a94 1
		0L,
@


1.9
log
@Added much more flexible buffering.
While input buffers are organized in increasing y (bottom-up),
we arrange for the DMA buffers to be organized in a top-down
manner, even if the pixel buffer will require several DMAs.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 1.8 86/10/25 10:50:03 phil Locked $ (BRL)";
d97 2
a98 1
		0L
@


1.8
log
@RGBpixel conversion
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 1.7 86/10/24 09:45:09 phil Locked $ (BRL)";
d160 4
a163 8
	if( width > 512 )
		width = 1024;
	else if( width < 512 )
		width = 512;
	if( height > 512 )
		height = 1024;
	else if( height < 512 )
		height = 512;
d170 1
a170 1
	if( width > 512 )
d335 1
a335 1
	long bytes = count * (long) sizeof(IKONASpixel);
d337 4
d345 4
a348 1
	y = ifp->if_width-1-y;		/* 1st quadrant */
d360 11
a370 3
	while( bytes > 0 ) {
		todo = (bytes > ADAGE_DMA_BYTES ? ADAGE_DMA_BYTES : bytes);
		if( read( ifp->if_fd, _pixbuf, todo ) != todo )
d374 12
a385 9
		out = (char *)pixelp;
		for( i = todo/sizeof(IKONASpixel); i > 0; i-- ) {
			*out++ = *in;
			*out++ = in[1];
			*out++ = in[2];
			in += sizeof(IKONASpixel);
		}
		bytes -= todo;
		pixelp += todo / sizeof(IKONASpixel);
d399 1
a399 1
	register long	bytes = count * (long) sizeof(IKONASpixel);
d401 4
d409 4
a412 1
	y = ifp->if_width-1-y;		/* 1st quadrant */
d424 10
a433 3
	while( bytes > 0 ) {
		todo = (bytes > ADAGE_DMA_BYTES ? ADAGE_DMA_BYTES : bytes);
		in = (char *)pixelp;
d435 13
a447 8
		for( i = todo/sizeof(IKONASpixel); i > 0; i-- ) {
			/* VAX subscripting faster than ++ */
			*out = *in++;
			out[1] = *in++;
			out[2] = *in++;
			out += sizeof(IKONASpixel);
		}
		if( write( ifp->if_fd, _pixbuf, todo ) != todo )
d449 1
a449 2
		bytes -= todo;
		pixelp += todo / sizeof(IKONASpixel);
@


1.7
log
@put in single pixel io.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 1.6 86/10/24 04:06:09 phil Locked $ (BRL)";
d143 6
d264 5
d287 1
a287 1
Pixel	*bgpp;
d289 1
a289 1
	/* If adage_setbackground() was called with non-black color, must
d293 2
a294 2
	if( bgpp != NULL && (bgpp->red != 0 || bgpp->green != 0 || bgpp->blue != 0) )
		return	fb_fast_dma_bg( ifp, bgpp );
d333 8
a340 5
int		x,  y;
Pixel		*pixelp;
int		count;
	{	register long bytes = count * (long) sizeof(Pixel);
		register long todo;
d348 1
a348 1
			* (long) sizeof(Pixel),
d351 1
a351 3
	    == -1L
		)
		{
d354 1
a354 2
			* (long) sizeof(Pixel)
			);
d356 13
a369 5
	while( bytes > 0 )
		{
		todo = (bytes > MAX_BYTES_DMA ? MAX_BYTES_DMA : bytes);
		if( read( ifp->if_fd, (char *) pixelp, todo ) != todo )
			return	-1;
d371 2
a372 2
		pixelp += todo / sizeof(Pixel);
		}
d374 1
a374 1
	}
d380 1
a380 1
Pixel	*pixelp;
d382 5
a386 2
	{	register long	bytes = count * (long) sizeof(Pixel);
		register int	todo;
d394 1
a394 1
			* (long) sizeof(Pixel),
d397 1
a397 3
	    == -1L
		)
		{
d400 1
a400 2
			* (long) sizeof(Pixel)
			);
d402 11
d414 1
a414 4
	while( bytes > 0 )
		{
		todo = (bytes > MAX_BYTES_DMA ? MAX_BYTES_DMA : bytes);
		if( write( ifp->if_fd, (char *) pixelp, todo ) != todo )
d417 2
a418 2
		pixelp += todo / sizeof(Pixel);
		}
d420 1
a420 1
	}
d424 1
a424 1
adage_write_pio_pixel( ifp, x, y, data )
d426 11
a436 4
int		x, y;
long		*data;
	{	register int i;
		register struct ikdevice *ikp = (struct ikdevice *)_ikUBaddr;
d459 2
a460 2
	ikp->datareg = (u_short)*data;
	ikp->datareg = (u_short)(*data>>16);
d473 7
a479 5
int		x, y;
long		*datap;
	{	register int i;
		register struct ikdevice *ikp = (struct ikdevice *)_ikUBaddr;
		register long data;
d517 3
a519 1
	*datap = data;
d811 1
a811 1
register Pixel	*cp;
d815 1
a815 1
	lp = RGB10( cp->red>>6, cp->green>>6, cp->blue>>6 );
d829 5
a833 3
	{	long cmap[1024];
		register long *lp = cmap;
		register int i;
d885 1
a885 1
FBIO		*ifp;
d887 4
a890 2
	{	register int i;
		long cmap[1024];
d922 29
d952 19
@


1.6
log
@read and write return number of pixels.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 1.5 86/10/14 23:09:08 phil Locked $ (BRL)";
d327 4
d365 4
d397 1
a397 1
adage_pio_pixel_write( ifp, x, y, data )
d432 1
a432 1
	return	0;
d437 1
a437 1
adage_pio_pixel_read( ifp, x, y, datap )
d482 1
a482 1
	return	0;
@


1.5
log
@Changed open behavior (/dev and res selection)
Fixed clear bug.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 1.4 86/10/06 21:27:00 phil Locked $ (BRL)";
d350 1
a350 1
	return	0;
d384 1
a384 1
	return	0;
@


1.4
log
@Hires fix
Converted to 1st Quadrant semantics
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 1.3 86/10/03 19:44:05 mike Exp $ (BRL)";
d86 1
a86 1
		"ik",
d151 1
d153 10
d165 3
d169 6
a174 2
		file[8] = 'h';
	if( (ifp->if_fd = open( file, O_RDWR, 0 )) == -1 )
d283 1
a283 1
		return	fb_fast_dma_bg( ifp );
@


1.3
log
@Working version
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 1.2 86/10/03 06:34:25 mike Exp $ (BRL)";
d152 4
d309 1
d343 1
d377 1
d418 1
d467 1
d496 6
d532 1
d626 1
d691 1
@


1.2
log
@Working version
@
text
@d2 14
a15 14
  Authors -
	Mike J. Muuss
	Gary S. Moss

  Source -
	SECAD/VLD Computing Consortium, Bldg 394
	The U. S. Army Ballistic Research Laboratory
	Aberdeen Proving Ground, Maryland  21005-5066
  
  Copyright Notice -
	This software is Copyright (C) 1986 by the United States Army.
	All rights reserved.

	$Header: if_adage.c,v 1.1 86/10/02 02:17:35 mike Locked $ (BRL)
d18 1
a18 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 1.1 86/10/02 02:17:35 mike Locked $ (BRL)";
d20 1
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
	$Header$ (BRL)
d18 1
a18 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d36 4
a50 16
#endif

#include "fb.h"
#include "./fblocal.h"
#include "./adage.h"

#ifndef O_CREAT
#ifdef O_RDONLY
#undef O_RDONLY
#undef O_WRONLY
#undef O_RDWR
#undef O_NDELAY
#undef O_APPEND
#endif
#include <sys/types.h>
#include <sys/file.h>
@
