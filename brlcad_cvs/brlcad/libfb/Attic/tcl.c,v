head	1.25;
access;
symbols
	ansi-20040405-merged:1.13.2.2
	postmerge-20040405-ansi:1.18
	premerge-20040404-ansi:1.17
	postmerge-autoconf:1.17
	autoconf-freeze:1.14.6.2
	premerge-autoconf:1.17
	ansi-20040316-freeze:1.13.2.1
	postmerge-20040315-windows:1.17
	premerge-20040315-windows:1.15
	windows-20040315-freeze:1.13.4.4
	autoconf-20031203:1.14
	autoconf-20031202:1.14
	autoconf-branch:1.14.0.6
	phong-branch:1.14.0.4
	photonmap-branch:1.14.0.2
	rel-6-1-DP:1.13
	windows-branch:1.13.0.4
	rel-6-0-2:1.11
	ansi-branch:1.13.0.2
	rel-6-0-1-branch:1.11.0.2
	hartley-6-0-post:1.12
	hartley-6-0-pre:1.11
	rel-6-0-1:1.11
	rel-6-0:1.11
	rel-5-4:1.8
	offsite-5-3-pre:1.9
	rel-5-3:1.8
	rel-5-2:1.8
	rel-5-1-branch:1.8.0.2
	rel-5-1:1.8
	rel-5-0:1.3
	rel-5-0-beta:1.3
	rel-4-5:1.2;
locks; strict;
comment	@ * @;


1.25
date	2004.05.21.18.07.26;	author morrison;	state dead;
branches;
next	1.24;

1.24
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	1.23;

1.23
date	2004.04.08.01.47.28;	author jra;	state Exp;
branches;
next	1.22;

1.22
date	2004.04.07.20.48.33;	author morrison;	state Exp;
branches;
next	1.21;

1.21
date	2004.04.07.20.46.26;	author morrison;	state Exp;
branches;
next	1.20;

1.20
date	2004.04.07.20.02.55;	author morrison;	state Exp;
branches;
next	1.19;

1.19
date	2004.04.07.19.57.46;	author morrison;	state Exp;
branches;
next	1.18;

1.18
date	2004.04.05.07.44.42;	author morrison;	state Exp;
branches;
next	1.17;

1.17
date	2004.03.16.23.36.36;	author morrison;	state Exp;
branches;
next	1.16;

1.16
date	2004.03.16.19.59.35;	author morrison;	state Exp;
branches;
next	1.15;

1.15
date	2004.02.02.17.39.13;	author morrison;	state Exp;
branches;
next	1.14;

1.14
date	2003.04.01.19.10.25;	author jra;	state Exp;
branches
	1.14.6.1;
next	1.13;

1.13
date	2002.08.20.17.07.47;	author jra;	state Exp;
branches
	1.13.2.1
	1.13.4.1;
next	1.12;

1.12
date	2002.08.15.20.55.01;	author hartley;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.05.12.52.55;	author bparker;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.02.21.20.40;	author bparker;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.12.03.26.49;	author cjohnson;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.20.21.24.25;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.28.15.46.53;	author bparker;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.14.23.52.39;	author bparker;	state Exp;
branches;
next	1.5;

1.5
date	99.12.29.20.32.02;	author jra;	state Exp;
branches;
next	1.4;

1.4
date	99.10.22.21.35.31;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	98.02.25.22.02.47;	author bparker;	state Exp;
branches;
next	1.2;

1.2
date	98.01.20.20.05.33;	author bparker;	state Exp;
branches;
next	1.1;

1.1
date	98.01.07.03.13.46;	author mike;	state Exp;
branches;
next	;

1.13.2.1
date	2002.09.19.18.01.20;	author morrison;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2004.03.17.21.17.03;	author morrison;	state Exp;
branches;
next	;

1.13.4.1
date	2002.09.26.23.03.56;	author morrison;	state Exp;
branches;
next	1.13.4.2;

1.13.4.2
date	2003.08.14.08.07.25;	author morrison;	state Exp;
branches;
next	1.13.4.3;

1.13.4.3
date	2004.03.11.23.42.08;	author morrison;	state Exp;
branches;
next	1.13.4.4;

1.13.4.4
date	2004.03.12.17.26.12;	author morrison;	state Exp;
branches;
next	1.13.4.5;

1.13.4.5
date	2004.03.17.04.11.17;	author morrison;	state Exp;
branches;
next	;

1.14.6.1
date	2004.02.12.19.48.13;	author erikg;	state Exp;
branches;
next	1.14.6.2;

1.14.6.2
date	2004.03.18.18.10.28;	author erikg;	state Exp;
branches;
next	;


desc
@Tcl interface to LIBFB.
@


1.25
log
@moved to src/
@
text
@/*
 *                      T C L . C
 *
 *  LIBFB's Tcl interface.
 *
 *  Authors -
 *	Robert G. Parker
 *
 *	Source -
 *		The U. S. Army Research Laboratory
 *		Aberdeen Proving Ground, Maryland  21005-5068  USA
 *
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1997-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <ctype.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "tcl.h"
#include "machine.h"
#include "externs.h"
#include "cmd.h"                  /* includes bu.h */
#include "fb.h"

#define FB_TCL_CKMAG(_ptr, _magic, _str){ \
	struct bu_vls _fb_vls; \
\
	if(!(_ptr)){ \
		bu_vls_init(&_fb_vls); \
		bu_vls_printf(&_fb_vls, "ERROR: null %s ptr, file %s, line %d\n", \
			_str, __FILE__, __LINE__ ); \
		Tcl_AppendResult(interp, bu_vls_addr(&_fb_vls), (char *)NULL); \
		bu_vls_free(&_fb_vls); \
\
		return TCL_ERROR; \
	}else if(*((long *)(_ptr)) != (_magic)){ \
		bu_vls_init(&_fb_vls); \
		bu_vls_printf(&_fb_vls, "ERROR: bad %s ptr x%x, s/b x%x, was x%x, file %s, line %d\n", \
		_str, _ptr, _magic, *((long *)(_ptr)), __FILE__, __LINE__); \
		Tcl_AppendResult(interp, bu_vls_addr(&_fb_vls), (char *)NULL); \
		bu_vls_free(&_fb_vls); \
\
		return TCL_ERROR; \
	} \
}

#define FB_TCL_CK_FBIO(_p) FB_TCL_CKMAG(_p, FB_MAGIC, "FBIO")

/* from libfb/fb_obj.c */
extern int Fbo_Init(Tcl_Interp *interp);

/* XXX -- At some point these routines should be moved to FBIO */
#ifdef IF_OGL
extern int ogl_open_existing();
extern int ogl_close_existing();
extern FBIO ogl_interface;
extern void ogl_configureWindow();
extern int ogl_refresh();
#endif

#if defined(IF_X) && !defined(WIN32)
extern void X24_configureWindow();
extern int X24_refresh();
extern int X24_open_existing();
extern int X24_close_existing();
extern FBIO X24_interface;
#endif

int fb_tcl_open_existing(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int fb_tcl_close_existing(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);

static struct bu_cmdtab cmdtab[] = {
	{"fb_open_existing",	 fb_tcl_open_existing},
	{"fb_close_existing",	 fb_tcl_close_existing},
	{(char *)0, (int (*)())0}
};

/* XXX this device list shouldn't be in here */
static const char *X_device_name = "/dev/X";
static const char *ogl_device_name = "/dev/ogl";


int
Fb_Init(Tcl_Interp *interp)
{
	const char *version_number;

	/* register commands */
	bu_register_cmds(interp, cmdtab);

	/* initialize framebuffer object code */
	Fbo_Init(interp);

	Tcl_SetVar(interp, "fb_version", (char *)fb_version+5, TCL_GLOBAL_ONLY);
	Tcl_Eval(interp, "lindex $fb_version 2");
	version_number = Tcl_GetStringResult(interp);
	Tcl_PkgProvide(interp,  "Fb", version_number);

	return TCL_OK;
}

int
fb_tcl_open_existing(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
#ifdef IF_X
  register FBIO *ifp;
  struct bu_vls vls;

  if(argc < 2){
    Tcl_AppendResult(interp, "XXXfb_open_existing: wrong number of args\n", (char *)NULL);
    return TCL_ERROR;
  }

  if((ifp = (FBIO *)calloc(sizeof(FBIO), 1)) == FBIO_NULL){
    Tcl_AppendResult(interp, "fb_open_existing: failed to allocate ifp memory\n", (char *)NULL);
    return TCL_ERROR;
  }

#  ifndef WIN32
  if(strcasecmp(argv[1], X_device_name) == 0) {
    *ifp = X24_interface; /* struct copy */

    ifp->if_name = malloc((unsigned)strlen(X_device_name) + 1);
    (void)strcpy(ifp->if_name, X_device_name);

    /* Mark OK by filling in magic number */
    ifp->if_magic = FB_MAGIC;

    if((X24_open_existing(ifp, argc - 1, argv + 1)) <= -1){
      ifp->if_magic = 0; /* sanity */
      free((void *) ifp->if_name);
      free((void *) ifp);
      Tcl_AppendResult(interp, "fb_open_existing: failed to open X framebuffer\n", (char *)NULL);
      return TCL_ERROR;
    }
  }
  
#  endif  /* WIN32 */

#  ifdef IF_OGL
    if(strcasecmp(argv[1], ogl_device_name) == 0) {
      *ifp = ogl_interface; /* struct copy */

      ifp->if_name = malloc((unsigned)strlen(ogl_device_name) + 1);
      (void)strcpy(ifp->if_name, ogl_device_name);

      /* Mark OK by filling in magic number */
      ifp->if_magic = FB_MAGIC;

      if((ogl_open_existing(ifp, argc - 1, argv + 1)) <= -1){
	ifp->if_magic = 0; /* sanity */
	free((void *) ifp->if_name);
	free((void *) ifp);
	Tcl_AppendResult(interp, "fb_open_existing: failed to open ogl framebuffer\n", (char *)NULL);
	return TCL_ERROR;
      }
    }
#  endif  /* IF_OGL */

      ifp->if_magic = 0; /* sanity */
      free((void *) ifp->if_name);
      free((void *) ifp);

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "fb_open_existing: supports only the following device types\n");
#  if defined(IF_X) && !defined(WIN32)
      bu_vls_strcat(&vls, X_device_name);
      bu_vls_strcat( &vls, "\n" );
#  endif  /* IF_X && !WIN32 */
#  ifdef IF_OGL
      bu_vls_strcat(&vls, ogl_device_name);
      bu_vls_strcat( &vls, "\n" );
#  endif  /* IF_OGL */
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_ERROR;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "%lu", (unsigned long)ifp);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);
#endif  /* IF_X */

    return TCL_OK;
}

int
fb_tcl_close_existing(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
#ifdef IF_X
	FBIO *ifp;
	struct bu_vls vls;
	int status;

	if(argc != 2){
		/*XXX need help message */
		return TCL_ERROR;
	}

	if(sscanf(argv[1], "%lu", (unsigned long *)&ifp) != 1){
		Tcl_AppendResult(interp, "fb_close_existing: failed to provide ifp\n", (char *)NULL);
		return TCL_ERROR;
	}

	FB_TCL_CK_FBIO(ifp);
	_fb_pgflush(ifp);
#  ifndef WIN32
	if(strcasecmp(ifp->if_name, X_device_name) == 0) {
		if((status = X24_close_existing(ifp)) <= -1){
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "fb_close_existing: can not close device \"%s\", ret=%d.\n",
				      ifp->if_name, status);
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);

			return TCL_ERROR;
		}
		if(ifp->if_pbase != PIXEL_NULL)
			free((void *)ifp->if_pbase);
		free((void *)ifp->if_name);
		free((void *)ifp);
		return TCL_OK;
	}
#  endif  /* WIN32 */

#  ifdef IF_OGL
	if(strcasecmp(ifp->if_name, ogl_device_name) == 0) {
		if((status = ogl_close_existing(ifp)) <= -1){
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "fb_close_existing: can not close device \"%s\", ret=%d.\n",
				      ifp->if_name, status);
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);

			return TCL_ERROR;
		}
		if(ifp->if_pbase != PIXEL_NULL)
			free((void *)ifp->if_pbase);
		free((void *)ifp->if_name);
		free((void *)ifp);
		return TCL_OK;
	}
#  endif  /* IF_OGL */
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "fb_close_existing: can not close device\nifp: %s    device name: %s\n",
			      argv[1], ifp->if_name);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

	return TCL_ERROR;

#endif  /* IF_X */

}

void
fb_configureWindow(FBIO *ifp, int width, int height)
{
#ifdef IF_X

#  ifndef WIN32
	if (!strncmp(ifp->if_name, X_device_name, strlen(X_device_name)))
		X24_configureWindow(ifp, width, height);
#  endif
#  ifdef IF_OGL
#    ifdef WIN32	
	if (!strnicmp(ifp->if_name, ogl_device_name, strlen(ogl_device_name)))
		ogl_configureWindow(ifp, width, height);
#    else
	if (!strncmp(ifp->if_name, ogl_device_name, strlen(ogl_device_name)))
		ogl_configureWindow(ifp, width, height);
#    endif /* WIN32 */
#  endif  /* IF_OGL */
#endif  /* IF_X */
}

int
fb_refresh(FBIO *ifp, int x, int y, int w, int h)
{
#ifdef IF_X
	int status=-1;
#  ifndef WIN32
	if(!strncmp(ifp->if_name, X_device_name, strlen( X_device_name))) {
		status = X24_refresh(ifp, x, y, w, h);
	}
#  endif
#  ifdef IF_OGL
#    ifdef WIN32	
	if(!strnicmp(ifp->if_name, ogl_device_name, strlen( ogl_device_name))) {
		status = ogl_refresh(ifp, x, y, w, h);
	}
#    else
	if(!strncmp(ifp->if_name, ogl_device_name, strlen( ogl_device_name))) {
		status = ogl_refresh(ifp, x, y, w, h);
	}
#    endif  /* WIN32 */
#  endif  /* IF_OGL */

	if(status < 0)
		return TCL_ERROR;

#endif  /* IF_X */

	return TCL_OK;
}
@


1.24
log
@change conf.h to a wrapped config.h
@
text
@@


1.23
log
@Mods to define strategy
@
text
@d23 5
a27 1
#include "conf.h"
@


1.22
log
@commentification
@
text
@d93 2
a94 7
#ifdef IF_OGL
static const char *device_name = "/dev/ogl";
#elif defined(IF_X)
#	ifndef WIN32
static const char *device_name = "/dev/X";
#	endif
#endif
d134 1
a134 1
  if(strcasecmp(argv[1], device_name) == 0) {
d137 2
a138 2
    ifp->if_name = malloc((unsigned)strlen(device_name) + 1);
    (void)strcpy(ifp->if_name, device_name);
d150 1
a150 1
  } else {
d155 1
a155 1
    if(strcasecmp(argv[1], device_name) == 0) {
d158 2
a159 2
      ifp->if_name = malloc((unsigned)strlen(device_name) + 1);
      (void)strcpy(ifp->if_name, device_name);
d171 1
a171 1
    } else {
d181 2
a182 1
      bu_vls_printf(&vls, "%s", device_name);
d185 2
a186 1
      bu_vls_printf(&vls, ", %s", device_name);
a187 1
      bu_vls_printf(&vls, "\n");
a191 1
    }
d223 1
a223 1
	if(strcasecmp(ifp->if_name, device_name) == 0) {
d233 6
a238 1
	} else
d242 1
a242 1
	if(strcasecmp(ifp->if_name, device_name) == 0) {
d252 6
a257 1
	} else
d259 2
a260 3
        {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "fb_close_existing: can not close device\nifp: %s    device name: %s\n",
d262 2
a263 2
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);
d265 1
a265 2
		return TCL_ERROR;
	}
a266 4
	if(ifp->if_pbase != PIXEL_NULL)
		free((void *)ifp->if_pbase);
	free((void *)ifp->if_name);
	free((void *)ifp);
a268 1
	return TCL_OK;
d277 1
a277 1
	if (!strncmp(ifp->if_name, device_name, strlen(device_name)))
d281 5
a285 4
#    ifndef WIN32	
	else 
#    endif  /* WIN32 */
		if (!strnicmp(ifp->if_name, device_name, strlen(device_name)))
d287 1
d296 1
a296 1
	int status;
d298 1
a298 1
	if(!strcmp(ifp->if_name, device_name)){
d303 6
a308 4
#    ifndef WIN32	
	else 
#    endif  /* WIN32 */
		if(!strcmp(ifp->if_name, device_name)){
d311 1
a312 3
	else{
		return TCL_ERROR;
	}
d316 1
@


1.21
log
@simplify the nastiness a little, fix a win32/x/ogl define bug
@
text
@d239 1
a239 1
#  endif
d253 1
a253 1
#  endif
d268 1
a268 1
#endif /* IF_X */
d285 1
a285 1
#    endif
d288 2
a289 2
#  endif /* IF_OGL */
#endif /* IF_X */
d297 1
a297 1
#ifndef WIN32
d301 3
a303 3
#endif
#ifdef IF_OGL
#ifndef WIN32	
d305 1
a305 1
#endif		
d309 1
a309 1
#endif
d316 1
a316 1
#endif /* IF_X */
@


1.20
log
@const
@
text
@d227 1
a227 1
#ifndef WIN32
d238 4
a241 8
#endif
#ifdef IF_OGL
#ifndef WIN32
	}
#endif
#ifndef WIN32
	else
#endif
d252 3
a254 2
#endif
	}else{
d278 1
a278 1
#ifndef _WIN32
d281 3
a283 3
#endif
#ifdef IF_OGL
#ifndef _WIN32	
d285 1
a285 1
#endif
d288 1
a288 1
#endif
@


1.19
log
@simplify .. device name created static in one place, make stricmp go away (should use define in config.h)
@
text
@d92 1
d94 1
a94 1
	static const char *device_name = "/dev/ogl";
d97 1
a97 1
	char *device_name = "/dev/X";
@


1.18
log
@merge of ansi-6-0-branch into HEAD
@
text
@d66 1
a66 1
/*XXX At some point these routines should be moved to FBIO */
d92 9
a124 6
#  ifndef WIN32
  char *X_name = "/dev/X";
#  endif
#  ifdef IF_OGL
  char *ogl_name = "/dev/ogl";
#  endif
d138 1
a138 5
#    if defined(HAVE_STRCASECMP)
  if(strcasecmp(argv[1], X_name) == 0) {
#    else
  if(stricmp(argv[1], X_name) == 0) {
#    endif
d141 2
a142 2
    ifp->if_name = malloc((unsigned)strlen(X_name) + 1);
    (void)strcpy(ifp->if_name, X_name);
d159 1
a159 5
#    if defined(HAVE_STRCASECMP)
    if(strcasecmp(argv[1], ogl_name) == 0) {
#    else
    if(stricmp(argv[1], ogl_name) == 0) {
#    endif
d162 2
a163 2
      ifp->if_name = malloc((unsigned)strlen(ogl_name) + 1);
      (void)strcpy(ifp->if_name, ogl_name);
d185 1
a185 1
      bu_vls_printf(&vls, "%s", X_name);
d188 1
a188 1
      bu_vls_printf(&vls, ", %s", ogl_name);
a210 6
#ifdef IF_OGL
	char *ogl_name = "/dev/ogl";
#endif
#ifndef WIN32
	char *X_name = "/dev/X";
#endif
d227 1
a227 6
#if defined(HAVE_STRCASECMP)
	if(strcasecmp(ifp->if_name, X_name) == 0)
#else
	if(stricmp(ifp->if_name, X_name) == 0)
#endif
	  {
d245 1
a245 6
#if defined(HAVE_STRCASECMP)
		if(strcasecmp(ifp->if_name, ogl_name) == 0)
#else
		if(stricmp(ifp->if_name, ogl_name) == 0)
#endif
		  {
a278 6
#ifndef _WIN32
	const char *X_name = "/dev/X";
#endif
#ifdef IF_OGL
	const char *ogl_name = "/dev/ogl";
#endif
d281 1
a281 1
	if (!strncmp(ifp->if_name, X_name, strlen(X_name)))
d288 1
a288 1
		if (!strnicmp(ifp->if_name, ogl_name, strlen(ogl_name)))
a297 6
#ifndef WIN32
	char *X_name = "/dev/X";
#endif
#ifdef IF_OGL
	char *ogl_name = "/dev/ogl";
#endif
d300 1
a300 1
	if(!strcmp(ifp->if_name, X_name)){
d308 1
a308 1
		if(!strcmp(ifp->if_name, ogl_name)){
@


1.17
log
@whitespace and paren/define alignment
@
text
@d64 1
a64 1
extern int Fbo_Init();
d83 2
a84 2
int fb_tcl_open_existing();
int fb_tcl_close_existing();
d93 1
a93 2
Fb_Init(interp)
     Tcl_Interp *interp;
d112 1
a112 5
fb_tcl_open_existing(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int argc;
     char **argv;
d212 1
a212 5
fb_tcl_close_existing(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int argc;
     char **argv;
d297 1
a297 3
fb_configureWindow(ifp, width, height)
     FBIO *ifp;
     int width, height;
d322 1
a322 4
fb_refresh(ifp, x, y, w, h)
     FBIO *ifp;
     int x, y;
     int w, h;
@


1.16
log
@merge of windows-6-0-branch into head
@
text
@d120 1
a120 1
	register FBIO *ifp;
d122 1
a122 1
	char *X_name = "/dev/X";
d125 1
a125 1
	char *ogl_name = "/dev/ogl";
d127 1
a127 1
	struct bu_vls vls;
d129 9
a137 10
	if(argc < 2){
		Tcl_AppendResult(interp, "XXXfb_open_existing: wrong number of args\n", (char *)NULL);
		return TCL_ERROR;
	}

	if((ifp = (FBIO *)calloc(sizeof(FBIO), 1)) == FBIO_NULL){
		Tcl_AppendResult(interp, "fb_open_existing: failed to allocate ifp memory\n",
				 (char *)NULL);
		return TCL_ERROR;
	}
d141 1
a141 1
	if(strcasecmp(argv[1], X_name) == 0)
d143 1
a143 1
	if(stricmp(argv[1], X_name) == 0)
d145 1
a145 2
	  {
		*ifp = X24_interface; /* struct copy */
d147 2
a148 2
		ifp->if_name = malloc((unsigned)strlen(X_name) + 1);
		(void)strcpy(ifp->if_name, X_name);
d150 2
a151 2
		/* Mark OK by filling in magic number */
		ifp->if_magic = FB_MAGIC;
d153 9
a161 9
		if((X24_open_existing(ifp, argc - 1, argv + 1)) <= -1){
			ifp->if_magic = 0; /* sanity */
			free((void *) ifp->if_name);
			free((void *) ifp);
			Tcl_AppendResult(interp, "fb_open_existing: failed to open X framebuffer\n",
					 (char *)NULL);
			return TCL_ERROR;
		}
	  } else {
d166 1
a166 1
		if(strcasecmp(argv[1], ogl_name) == 0)
d168 1
a168 1
		if(stricmp(argv[1], ogl_name) == 0)
d170 1
a170 2
		  {
		*ifp = ogl_interface; /* struct copy */
d172 2
a173 2
		ifp->if_name = malloc((unsigned)strlen(ogl_name) + 1);
		(void)strcpy(ifp->if_name, ogl_name);
d175 2
a176 2
		/* Mark OK by filling in magic number */
		ifp->if_magic = FB_MAGIC;
d178 9
a186 13
		if((ogl_open_existing(ifp, argc - 1, argv + 1)) <= -1){
			ifp->if_magic = 0; /* sanity */
			free((void *) ifp->if_name);
			free((void *) ifp);
			Tcl_AppendResult(interp, "fb_open_existing: failed to open ogl framebuffer\n",
					 (char *)NULL);
			return TCL_ERROR;
		}
#  endif /* IF_OGL */
	} else {
		ifp->if_magic = 0; /* sanity */
		free((void *) ifp->if_name);
		free((void *) ifp);
d188 9
a196 5
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "fb_open_existing: supports only the following device types\n");
#  ifndef WIN32
		bu_vls_printf(&vls, "%s", X_name);
#  endif  /* WIN32 */
d198 1
a198 1
		bu_vls_printf(&vls, ", %s", ogl_name);
d200 11
a210 11
		bu_vls_printf(&vls, "\n");
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		return TCL_ERROR;
	}

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "%lu", (unsigned long)ifp);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);
d213 1
a213 1
	return TCL_OK;
@


1.15
log
@update copyright to include span through 2003
@
text
@d75 1
a75 1
#ifdef IF_X
d121 1
d123 2
a124 1
#ifdef IF_OGL
d126 1
a126 1
#endif
d140 7
a146 1
	if(strcmp(argv[1], X_name) == 0){
d163 10
a172 2
#ifdef IF_OGL
	}else if(strcmp(argv[1], ogl_name) == 0){
d189 2
a190 2
#endif
	}else{
d197 1
d199 2
a200 1
#ifdef IF_OGL
d202 1
a202 1
#endif
d214 1
a214 1
#endif /* IF_X */
d231 1
d233 1
d249 7
a255 2

	if(strcmp(ifp->if_name, X_name) == 0){
d265 1
d267 12
a278 1
	}else if(strcmp(ifp->if_name, ogl_name) == 0){
d314 1
d316 1
d321 1
d324 1
d326 4
a329 1
	else if (!strncmp(ifp->if_name, ogl_name, strlen(ogl_name)))
d342 1
d344 1
d349 1
a349 1

d353 1
d355 4
a358 1
	else if(!strcmp(ifp->if_name, ogl_name)){
@


1.14
log
@Added a "const" to quiet the compiler
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1997 by the United States Army
@


1.14.6.1
log
@merge from HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1997-2004 by the United States Army
@


1.14.6.2
log
@merge from head
@
text
@d75 1
a75 1
#if defined(IF_X) && !defined(WIN32)
d120 58
a177 92
  register FBIO *ifp;
#  ifndef WIN32
  char *X_name = "/dev/X";
#  endif
#  ifdef IF_OGL
  char *ogl_name = "/dev/ogl";
#  endif
  struct bu_vls vls;

  if(argc < 2){
    Tcl_AppendResult(interp, "XXXfb_open_existing: wrong number of args\n", (char *)NULL);
    return TCL_ERROR;
  }

  if((ifp = (FBIO *)calloc(sizeof(FBIO), 1)) == FBIO_NULL){
    Tcl_AppendResult(interp, "fb_open_existing: failed to allocate ifp memory\n", (char *)NULL);
    return TCL_ERROR;
  }

#  ifndef WIN32
#    if defined(HAVE_STRCASECMP)
  if(strcasecmp(argv[1], X_name) == 0) {
#    else
  if(stricmp(argv[1], X_name) == 0) {
#    endif
    *ifp = X24_interface; /* struct copy */

    ifp->if_name = malloc((unsigned)strlen(X_name) + 1);
    (void)strcpy(ifp->if_name, X_name);

    /* Mark OK by filling in magic number */
    ifp->if_magic = FB_MAGIC;

    if((X24_open_existing(ifp, argc - 1, argv + 1)) <= -1){
      ifp->if_magic = 0; /* sanity */
      free((void *) ifp->if_name);
      free((void *) ifp);
      Tcl_AppendResult(interp, "fb_open_existing: failed to open X framebuffer\n", (char *)NULL);
      return TCL_ERROR;
    }
  } else {
  
#  endif  /* WIN32 */

#  ifdef IF_OGL
#    if defined(HAVE_STRCASECMP)
    if(strcasecmp(argv[1], ogl_name) == 0) {
#    else
    if(stricmp(argv[1], ogl_name) == 0) {
#    endif
      *ifp = ogl_interface; /* struct copy */

      ifp->if_name = malloc((unsigned)strlen(ogl_name) + 1);
      (void)strcpy(ifp->if_name, ogl_name);

      /* Mark OK by filling in magic number */
      ifp->if_magic = FB_MAGIC;

      if((ogl_open_existing(ifp, argc - 1, argv + 1)) <= -1){
	ifp->if_magic = 0; /* sanity */
	free((void *) ifp->if_name);
	free((void *) ifp);
	Tcl_AppendResult(interp, "fb_open_existing: failed to open ogl framebuffer\n", (char *)NULL);
	return TCL_ERROR;
      }
    } else {
#  endif  /* IF_OGL */

      ifp->if_magic = 0; /* sanity */
      free((void *) ifp->if_name);
      free((void *) ifp);

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "fb_open_existing: supports only the following device types\n");
#  if defined(IF_X) && !defined(WIN32)
      bu_vls_printf(&vls, "%s", X_name);
#  endif  /* IF_X && !WIN32 */
#  ifdef IF_OGL
      bu_vls_printf(&vls, ", %s", ogl_name);
#  endif  /* IF_OGL */
      bu_vls_printf(&vls, "\n");
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_ERROR;
    }

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "%lu", (unsigned long)ifp);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);
#endif  /* IF_X */
d179 20
a198 1
    return TCL_OK;
a212 1
#ifndef WIN32
a213 1
#endif
d229 2
a230 7
#ifndef WIN32
#if defined(HAVE_STRCASECMP)
	if(strcasecmp(ifp->if_name, X_name) == 0)
#else
	if(stricmp(ifp->if_name, X_name) == 0)
#endif
	  {
a239 1
#endif
d241 1
a241 12
#ifndef WIN32
	}
#endif
#ifndef WIN32
	else
#endif
#if defined(HAVE_STRCASECMP)
		if(strcasecmp(ifp->if_name, ogl_name) == 0)
#else
		if(stricmp(ifp->if_name, ogl_name) == 0)
#endif
		  {
a276 1
#ifndef _WIN32
a277 1
#endif
a281 1
#ifndef _WIN32
a283 1
#endif
d285 1
a285 4
#ifndef _WIN32	
	else 
#endif
		if (!strnicmp(ifp->if_name, ogl_name, strlen(ogl_name)))
a297 1
#ifndef WIN32
a298 1
#endif
d303 1
a303 1
#ifndef WIN32
a306 1
#endif
d308 1
a308 4
#ifndef WIN32	
	else 
#endif		
		if(!strcmp(ifp->if_name, ogl_name)){
@


1.13
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d96 1
a96 1
	char *version_number;
@


1.13.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@a75 1
#ifndef WIN32
a81 1
#endif
a120 1
#ifndef WIN32
a121 1
#endif
a137 1
#ifndef WIN32
a154 1
#endif
d156 1
a156 7
#ifndef WIN32
	}
#endif
#ifndef WIN32
	else 
#endif
		if(strcmp(argv[1], ogl_name) == 0){
a180 1
#ifndef WIN32
a181 1
#endif
a212 1
#ifndef WIN32
a213 1
#endif
d229 1
a229 1
#ifndef WIN32
a239 1
#endif
d241 1
a241 7
#ifndef WIN32
	}
#endif
#ifndef WIN32
	else
#endif
		if(strcmp(ifp->if_name, ogl_name) == 0){
a276 1
#ifndef WIN32
a277 1
#endif
a281 1
#ifndef WIN32
a283 1
#endif
d285 1
a285 4
#ifndef WIN32	
	else 
#endif
		if (!strncmp(ifp->if_name, ogl_name, strlen(ogl_name)))
a297 1
#ifndef WIN32
a298 1
#endif
d303 1
a303 1
#ifndef WIN32
a306 1
#endif
d308 1
a308 4
#ifndef WIN32	
	else 
#endif		
		if(!strcmp(ifp->if_name, ogl_name)){
@


1.13.4.2
log
@Survice Engineering patch to clean up the build environment and several runtime issues
@
text
@d143 1
a143 1
	if(stricmp(argv[1], X_name) == 0){
d168 1
a168 1
		if(stricmp(argv[1], ogl_name) == 0){
d246 1
a246 1
	if(stricmp(ifp->if_name, X_name) == 0){
d264 1
a264 1
		if(stricmp(ifp->if_name, ogl_name) == 0){
d300 1
a300 1
#ifndef _WIN32
d307 1
a307 1
#ifndef _WIN32
d312 1
a312 1
#ifndef _WIN32	
d315 1
a315 1
		if (!strnicmp(ifp->if_name, ogl_name, strlen(ogl_name)))
@


1.13.4.3
log
@sync to HEAD...
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1997-2004 by the United States Army
d98 1
a98 1
	const char *version_number;
@


1.13.4.4
log
@use strcasecmp instead of stricmp if it is available, strcasecmp is bsd 4.4 stricmp is not
@
text
@d75 2
a76 1
#if defined(IF_X) && !defined(WIN32)
d83 1
d143 1
a143 6
#  if defined(HAVE_STRCASECMP)
	if(strcasecmp(argv[1], X_name) == 0)
#  else
	if(stricmp(argv[1], X_name) == 0)
#  endif
	  {
d168 1
a168 6
#if defined(HAVE_STRCASECMP)
		if(strcasecmp(argv[1], ogl_name) == 0)
#else
		if(stricmp(argv[1], ogl_name) == 0)
#endif
		  {
d246 1
a246 6
#if defined(HAVE_STRCASECMP)
	if(strcasecmp(ifp->if_name, X_name) == 0)
#else
	if(stricmp(ifp->if_name, X_name) == 0)
#endif
	  {
d264 1
a264 6
#if defined(HAVE_STRCASECMP)
		if(strcasecmp(ifp->if_name, ogl_name) == 0)
#else
		if(stricmp(ifp->if_name, ogl_name) == 0)
#endif
		  {
@


1.13.4.5
log
@remerge head into branch just in case someone checks out this branch later
@
text
@d120 25
a144 3
  register FBIO *ifp;
#  ifndef WIN32
  char *X_name = "/dev/X";
d146 8
a153 4
#  ifdef IF_OGL
  char *ogl_name = "/dev/ogl";
#  endif
  struct bu_vls vls;
d155 64
a218 83
  if(argc < 2){
    Tcl_AppendResult(interp, "XXXfb_open_existing: wrong number of args\n", (char *)NULL);
    return TCL_ERROR;
  }

  if((ifp = (FBIO *)calloc(sizeof(FBIO), 1)) == FBIO_NULL){
    Tcl_AppendResult(interp, "fb_open_existing: failed to allocate ifp memory\n", (char *)NULL);
    return TCL_ERROR;
  }

#  ifndef WIN32
#    if defined(HAVE_STRCASECMP)
  if(strcasecmp(argv[1], X_name) == 0) {
#    else
  if(stricmp(argv[1], X_name) == 0) {
#    endif
    *ifp = X24_interface; /* struct copy */

    ifp->if_name = malloc((unsigned)strlen(X_name) + 1);
    (void)strcpy(ifp->if_name, X_name);

    /* Mark OK by filling in magic number */
    ifp->if_magic = FB_MAGIC;

    if((X24_open_existing(ifp, argc - 1, argv + 1)) <= -1){
      ifp->if_magic = 0; /* sanity */
      free((void *) ifp->if_name);
      free((void *) ifp);
      Tcl_AppendResult(interp, "fb_open_existing: failed to open X framebuffer\n", (char *)NULL);
      return TCL_ERROR;
    }
  } else {
  
#  endif  /* WIN32 */

#  ifdef IF_OGL
#    if defined(HAVE_STRCASECMP)
    if(strcasecmp(argv[1], ogl_name) == 0) {
#    else
    if(stricmp(argv[1], ogl_name) == 0) {
#    endif
      *ifp = ogl_interface; /* struct copy */

      ifp->if_name = malloc((unsigned)strlen(ogl_name) + 1);
      (void)strcpy(ifp->if_name, ogl_name);

      /* Mark OK by filling in magic number */
      ifp->if_magic = FB_MAGIC;

      if((ogl_open_existing(ifp, argc - 1, argv + 1)) <= -1){
	ifp->if_magic = 0; /* sanity */
	free((void *) ifp->if_name);
	free((void *) ifp);
	Tcl_AppendResult(interp, "fb_open_existing: failed to open ogl framebuffer\n", (char *)NULL);
	return TCL_ERROR;
      }
    } else {
#  endif  /* IF_OGL */

      ifp->if_magic = 0; /* sanity */
      free((void *) ifp->if_name);
      free((void *) ifp);

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "fb_open_existing: supports only the following device types\n");
#  if defined(IF_X) && !defined(WIN32)
      bu_vls_printf(&vls, "%s", X_name);
#  endif  /* IF_X && !WIN32 */
#  ifdef IF_OGL
      bu_vls_printf(&vls, ", %s", ogl_name);
#  endif  /* IF_OGL */
      bu_vls_printf(&vls, "\n");
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_ERROR;
    }

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "%lu", (unsigned long)ifp);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);
#endif  /* IF_X */
d220 1
a220 1
    return TCL_OK;
@


1.13.2.1
log
@Initial ANSIfication
@
text
@d64 1
a64 1
extern int Fbo_Init(Tcl_Interp *interp);
d83 2
a84 2
int fb_tcl_open_existing(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int fb_tcl_close_existing(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d93 2
a94 1
Fb_Init(Tcl_Interp *interp)
d113 5
a117 1
fb_tcl_open_existing(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d202 5
a206 1
fb_tcl_close_existing(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d272 3
a274 1
fb_configureWindow(FBIO *ifp, int width, int height)
d292 4
a295 1
fb_refresh(FBIO *ifp, int x, int y, int w, int h)
@


1.13.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1997-2004 by the United States Army
d75 1
a75 1
#if defined(IF_X) && !defined(WIN32)
d95 1
a95 1
	const char *version_number;
d115 77
a191 92
  register FBIO *ifp;
#  ifndef WIN32
  char *X_name = "/dev/X";
#  endif
#  ifdef IF_OGL
  char *ogl_name = "/dev/ogl";
#  endif
  struct bu_vls vls;

  if(argc < 2){
    Tcl_AppendResult(interp, "XXXfb_open_existing: wrong number of args\n", (char *)NULL);
    return TCL_ERROR;
  }

  if((ifp = (FBIO *)calloc(sizeof(FBIO), 1)) == FBIO_NULL){
    Tcl_AppendResult(interp, "fb_open_existing: failed to allocate ifp memory\n", (char *)NULL);
    return TCL_ERROR;
  }

#  ifndef WIN32
#    if defined(HAVE_STRCASECMP)
  if(strcasecmp(argv[1], X_name) == 0) {
#    else
  if(stricmp(argv[1], X_name) == 0) {
#    endif
    *ifp = X24_interface; /* struct copy */

    ifp->if_name = malloc((unsigned)strlen(X_name) + 1);
    (void)strcpy(ifp->if_name, X_name);

    /* Mark OK by filling in magic number */
    ifp->if_magic = FB_MAGIC;

    if((X24_open_existing(ifp, argc - 1, argv + 1)) <= -1){
      ifp->if_magic = 0; /* sanity */
      free((void *) ifp->if_name);
      free((void *) ifp);
      Tcl_AppendResult(interp, "fb_open_existing: failed to open X framebuffer\n", (char *)NULL);
      return TCL_ERROR;
    }
  } else {
  
#  endif  /* WIN32 */

#  ifdef IF_OGL
#    if defined(HAVE_STRCASECMP)
    if(strcasecmp(argv[1], ogl_name) == 0) {
#    else
    if(stricmp(argv[1], ogl_name) == 0) {
#    endif
      *ifp = ogl_interface; /* struct copy */

      ifp->if_name = malloc((unsigned)strlen(ogl_name) + 1);
      (void)strcpy(ifp->if_name, ogl_name);

      /* Mark OK by filling in magic number */
      ifp->if_magic = FB_MAGIC;

      if((ogl_open_existing(ifp, argc - 1, argv + 1)) <= -1){
	ifp->if_magic = 0; /* sanity */
	free((void *) ifp->if_name);
	free((void *) ifp);
	Tcl_AppendResult(interp, "fb_open_existing: failed to open ogl framebuffer\n", (char *)NULL);
	return TCL_ERROR;
      }
    } else {
#  endif  /* IF_OGL */

      ifp->if_magic = 0; /* sanity */
      free((void *) ifp->if_name);
      free((void *) ifp);

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "fb_open_existing: supports only the following device types\n");
#  if defined(IF_X) && !defined(WIN32)
      bu_vls_printf(&vls, "%s", X_name);
#  endif  /* IF_X && !WIN32 */
#  ifdef IF_OGL
      bu_vls_printf(&vls, ", %s", ogl_name);
#  endif  /* IF_OGL */
      bu_vls_printf(&vls, "\n");
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_ERROR;
    }

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "%lu", (unsigned long)ifp);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);
#endif  /* IF_X */
d193 1
a193 1
    return TCL_OK;
a203 1
#ifndef WIN32
a204 1
#endif
d220 2
a221 7
#ifndef WIN32
#if defined(HAVE_STRCASECMP)
	if(strcasecmp(ifp->if_name, X_name) == 0)
#else
	if(stricmp(ifp->if_name, X_name) == 0)
#endif
	  {
a230 1
#endif
d232 1
a232 12
#ifndef WIN32
	}
#endif
#ifndef WIN32
	else
#endif
#if defined(HAVE_STRCASECMP)
		if(strcasecmp(ifp->if_name, ogl_name) == 0)
#else
		if(stricmp(ifp->if_name, ogl_name) == 0)
#endif
		  {
a265 1
#ifndef _WIN32
a266 1
#endif
a270 1
#ifndef _WIN32
a272 1
#endif
d274 1
a274 4
#ifndef _WIN32	
	else 
#endif
		if (!strnicmp(ifp->if_name, ogl_name, strlen(ogl_name)))
a283 1
#ifndef WIN32
a284 1
#endif
d289 1
a289 1
#ifndef WIN32
a292 1
#endif
d294 1
a294 4
#ifndef WIN32	
	else 
#endif		
		if(!strcmp(ifp->if_name, ogl_name)){
@


1.12
log
@Converted from K&R to ANSI C - RFH
@
text
@d64 1
a64 1
extern int Fbo_Init(Tcl_Interp *interp);
d83 2
a84 2
int fb_tcl_open_existing(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int fb_tcl_close_existing(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d93 2
a94 1
Fb_Init(Tcl_Interp *interp)
d113 5
a117 1
fb_tcl_open_existing(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d202 5
a206 1
fb_tcl_close_existing(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d272 3
a274 1
fb_configureWindow(FBIO *ifp, int width, int height)
d292 4
a295 1
fb_refresh(FBIO *ifp, int x, int y, int w, int h)
@


1.11
log
@*- get rid of warnings
@
text
@d64 1
a64 1
extern int Fbo_Init();
d83 2
a84 2
int fb_tcl_open_existing();
int fb_tcl_close_existing();
d93 1
a93 2
Fb_Init(interp)
     Tcl_Interp *interp;
d112 1
a112 5
fb_tcl_open_existing(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int argc;
     char **argv;
d197 1
a197 5
fb_tcl_close_existing(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int argc;
     char **argv;
d263 1
a263 3
fb_configureWindow(ifp, width, height)
     FBIO *ifp;
     int width, height;
d281 1
a281 4
fb_refresh(ifp, x, y, w, h)
     FBIO *ifp;
     int x, y;
     int w, h;
@


1.10
log
@*- remove Tk dependencies
@
text
@d71 2
@


1.9
log
@LINT from gcc -Wall.  These mods are to support libdm.  General via moving
declerations to fb.h
@
text
@d73 1
d79 1
d117 1
d194 1
d206 1
d264 1
d274 1
d286 1
d295 1
d316 1
@


1.8
log
@*- set fb_version and call Tcl_PkgProvide
@
text
@d73 2
d83 3
a85 3
	"fb_open_existing",	 fb_tcl_open_existing,
	"fb_close_existing",	 fb_tcl_close_existing,
	(char *)0, (int (*)())0
d203 1
d205 1
@


1.7
log
@*- mods to fb_tcl_open_existing
@
text
@d90 2
d97 5
@


1.6
log
@*- move some routines to fb_obj.c
*- initialize the framebuffer object
@
text
@d257 1
a257 1
	char *X_name = "/dev/X";
d259 1
a259 1
	char *ogl_name = "/dev/ogl";
d262 1
a262 1
	if(!strcmp(ifp->if_name, X_name))
d265 1
a265 1
	else if(!strcmp(ifp->if_name, ogl_name))
@


1.5
log
@Eliminated some unused variables
@
text
@d4 1
a4 1
 *  Tcl interface to LIBFB routines.
d36 1
a37 1
#include "bu.h"
d63 3
a67 1
extern int ogl_refresh();
a72 1
extern int X24_refresh();
a76 2
int fb_tcl_open();
int fb_tcl_close();
d79 5
a83 21
int fb_tcl_clear();
int fb_tcl_cursor();
int fb_tcl_getcursor();
int fb_tcl_writerect();
int fb_tcl_refresh();
int fb_refresh();

static struct fbcmd{
  char *cmdName;
  int (*cmdFunc)();
}fb_cmds[] = {
  "fb_open", fb_tcl_open,
  "fb_close", fb_tcl_close,
  "fb_open_existing", fb_tcl_open_existing,
  "fb_close_existing", fb_tcl_close_existing,
  "fb_clear", fb_tcl_clear,
  "fb_cursor", fb_tcl_cursor,
  "fb_getcursor", fb_tcl_getcursor,
  "fb_writerect", fb_tcl_writerect,
  "fb_refresh", fb_tcl_refresh,
  (char *)0, (int (*)())0
d88 1
a88 247
Tcl_Interp *interp;
{
  struct fbcmd *fbp;

  for(fbp = fb_cmds; fbp->cmdName != (char *)0; ++fbp){
    (void)Tcl_CreateCommand(interp, fbp->cmdName, fbp->cmdFunc,
			    (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
  }

  return TCL_OK;
}

int
fb_tcl_open(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
  FBIO *ifp;
  int width, height;
  struct bu_vls vls;

  if(argc != 4){
    /*XXX put error message here */
    return TCL_ERROR;
  }

  if(sscanf(argv[2], "%d", &width) != 1)
    return TCL_ERROR;

  if(sscanf(argv[3], "%d", &height) != 1)
    return TCL_ERROR;
  
  ifp = fb_open(argv[1], width, height);
  bu_vls_init(&vls);
  bu_vls_printf(&vls, "%lu", (unsigned long)ifp);
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  bu_vls_free(&vls);

  return TCL_OK;
}

int
fb_tcl_clear(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
  int status;
  FBIO *ifp;
  unsigned char pp[4];
  unsigned char *ms;
  int r, g, b;

  if(argc < 2){
    /*XXX put usage message here */
    return TCL_ERROR;
  }

  if(sscanf(argv[1], "%lu", (unsigned long *)&ifp) != 1){
    /*XXX put usage message here */
    return TCL_ERROR;
  }

  FB_TCL_CK_FBIO(ifp);

  if(argc == 5){
    if(sscanf(argv[2], "%d", &r) == 1 &&
       sscanf(argv[3], "%d", &g) == 1 &&
	 sscanf(argv[4], "%d", &b) == 1){
      ms = pp;
      pp[0] = (unsigned char)r;
      pp[1] = (unsigned char)g;
      pp[2] = (unsigned char)b;
      pp[3] = (unsigned char)0;
    }else
      ms = RGBPIXEL_NULL;
  }else
    ms = RGBPIXEL_NULL;

  status = fb_clear(ifp, ms);

  if(status < 0)
    return TCL_ERROR;

  return TCL_OK;
}

int
fb_tcl_cursor(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
  FBIO *ifp;
  int mode;
  int x, y;
  int status;

  if(argc != 5){
    /*XXX put usage message here */
    return TCL_ERROR;
  }

  if(sscanf(argv[1], "%lu", (unsigned long *)&ifp) != 1){
    /*XXX put usage message here */
    return TCL_ERROR;
  }
  FB_TCL_CK_FBIO(ifp);

  if(sscanf(argv[2], "%d", &mode) != 1){
    /*XXX put usage message here */
    return TCL_ERROR;
  }

  if(sscanf(argv[3], "%d", &x) != 1){
    /*XXX put usage message here */
    return TCL_ERROR;
  }

  if(sscanf(argv[4], "%d", &y) != 1){
    /*XXX put usage message here */
    return TCL_ERROR;
  }

  status = fb_cursor(ifp, mode, x, y);
  if(status == 0)
    return TCL_OK;

  return TCL_ERROR;
}

int
fb_tcl_getcursor(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
  FBIO *ifp;
  int status;
  int mode;
  int x, y;

  if(argc != 2){
    /*XXX put usage message here */
    return TCL_ERROR;
  }

  if(sscanf(argv[1], "%lu", (unsigned long *)&ifp) != 1){
    /*XXX put usage message here */
    return TCL_ERROR;
  }

  FB_TCL_CK_FBIO(ifp);

  status = fb_getcursor(ifp, &mode, &x, &y);
  if(status == 0){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "%d %d %d", mode, x, y);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);

    return TCL_OK;
  }

  return TCL_ERROR;
}

#if 0
int
fb_tcl_(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
  FBIO *ifp;
  int status;

  if(argc != ){
    /*XXX put usage message here */
    return TCL_ERROR;
  }

  if(sscanf(argv[1], "%lu", (unsigned long *)&ifp) != 1){
    /*XXX put usage message here */
    return TCL_ERROR;
  }

  FB_TCL_CK_FBIO(ifp);
}
int
fb_tcl_(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
  FBIO *ifp;
  int status;

  if(argc != ){
    /*XXX put usage message here */
    return TCL_ERROR;
  }

  if(sscanf(argv[1], "%lu", (unsigned long *)&ifp) != 1){
    /*XXX put usage message here */
    return TCL_ERROR;
  }

  FB_TCL_CK_FBIO(ifp);
}
int
fb_tcl_(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
  FBIO *ifp;
  int status;

  if(argc != ){
    /*XXX put usage message here */
    return TCL_ERROR;
  }

  if(sscanf(argv[1], "%lu", (unsigned long *)&ifp) != 1){
    /*XXX put usage message here */
    return TCL_ERROR;
  }

  FB_TCL_CK_FBIO(ifp);
}
int
fb_tcl_(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d90 2
a91 2
  FBIO *ifp;
  int status;
d93 2
a94 9
  if(argc != ){
    /*XXX put usage message here */
    return TCL_ERROR;
  }

  if(sscanf(argv[1], "%lu", (unsigned long *)&ifp) != 1){
    /*XXX put usage message here */
    return TCL_ERROR;
  }
d96 1
a96 1
  FB_TCL_CK_FBIO(ifp);
a97 23
int
fb_tcl_(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
  FBIO *ifp;
  int status;

  if(argc != ){
    /*XXX put usage message here */
    return TCL_ERROR;
  }

  if(sscanf(argv[1], "%lu", (unsigned long *)&ifp) != 1){
    /*XXX put usage message here */
    return TCL_ERROR;
  }

  FB_TCL_CK_FBIO(ifp);
}
#endif
a99 36
fb_tcl_close(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
  FBIO *ifp;
  int status;

  if(argc != 2){
    /*XXX put usage message here */
    return TCL_ERROR;
  }

  if(sscanf(argv[1], "%lu", (unsigned long *)&ifp) != 1){
    /*XXX put usage message here */
    return TCL_ERROR;
  }

  FB_TCL_CK_FBIO(ifp);
  status = fb_close(ifp);

  if(status < 0)
    return TCL_ERROR;

#if 0
  for(fbp = fb_cmds; fbp->cmdName != (char *)0; ++fbp){
    Tcl_DeleteCommand(interp, fbp->cmdName);
  }
#endif

  return TCL_OK;
}

/*XXX Experimenting */
int
d101 4
a104 4
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d106 2
a107 2
  register FBIO *ifp;
  char *X_name = "/dev/X";
d109 1
a109 1
  char *ogl_name = "/dev/ogl";
d111 1
a111 1
  struct bu_vls vls;
d113 28
a140 28
  if(argc < 2){
    Tcl_AppendResult(interp, "XXXfb_open_existing: wrong number of args\n", (char *)NULL);
    return TCL_ERROR;
  }

  if((ifp = (FBIO *)calloc(sizeof(FBIO), 1)) == FBIO_NULL){
    Tcl_AppendResult(interp, "fb_open_existing: failed to allocate ifp memory\n",
		     (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(argv[1], X_name) == 0){
    *ifp = X24_interface; /* struct copy */

    ifp->if_name = malloc((unsigned)strlen(X_name) + 1);
    (void)strcpy(ifp->if_name, X_name);

    /* Mark OK by filling in magic number */
    ifp->if_magic = FB_MAGIC;

    if((X24_open_existing(ifp, argc - 1, argv + 1)) <= -1){
      ifp->if_magic = 0; /* sanity */
      free((void *) ifp->if_name);
      free((void *) ifp);
      Tcl_AppendResult(interp, "fb_open_existing: failed to open X framebuffer\n",
		       (char *)NULL);
      return TCL_ERROR;
    }
d142 2
a143 2
  }else if(strcmp(argv[1], ogl_name) == 0){
    *ifp = ogl_interface; /* struct copy */
d145 2
a146 2
    ifp->if_name = malloc((unsigned)strlen(ogl_name) + 1);
    (void)strcpy(ifp->if_name, ogl_name);
d148 2
a149 2
    /* Mark OK by filling in magic number */
    ifp->if_magic = FB_MAGIC;
d151 17
a167 17
    if((ogl_open_existing(ifp, argc - 1, argv + 1)) <= -1){
      ifp->if_magic = 0; /* sanity */
      free((void *) ifp->if_name);
      free((void *) ifp);
      Tcl_AppendResult(interp, "fb_open_existing: failed to open ogl framebuffer\n",
		       (char *)NULL);
      return TCL_ERROR;
    }
#endif
  }else{
    ifp->if_magic = 0; /* sanity */
    free((void *) ifp->if_name);
    free((void *) ifp);

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "fb_open_existing: supports only the following device types\n");
    bu_vls_printf(&vls, "%s", X_name);
d169 1
a169 1
    bu_vls_printf(&vls, ", %s", ogl_name);
d171 6
a176 11
    bu_vls_printf(&vls, "\n");
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);

    return TCL_ERROR;
  }

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "%lu", (unsigned long)ifp);
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  bu_vls_free(&vls);
d178 6
a183 1
  return TCL_OK;
d188 31
a218 31
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
  FBIO *ifp;
  char *ogl_name = "/dev/ogl";
  char *X_name = "/dev/X";
  struct bu_vls vls;
  int status;

  if(argc != 2){
    /*XXX need help message */
    return TCL_ERROR;
  }

  if(sscanf(argv[1], "%lu", (unsigned long *)&ifp) != 1){
    Tcl_AppendResult(interp, "fb_close_existing: failed to provide ifp\n", (char *)NULL);
    return TCL_ERROR;
  }

  FB_TCL_CK_FBIO(ifp);
  _fb_pgflush(ifp);

  if(strcmp(ifp->if_name, X_name) == 0){
    if((status = X24_close_existing(ifp)) <= -1){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "fb_close_existing: can not close device \"%s\", ret=%d.\n",
		    ifp->if_name, status);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);
d220 2
a221 2
      return TCL_ERROR;
    }
d223 25
a247 7
  }else if(strcmp(ifp->if_name, ogl_name) == 0){
    if((status = ogl_close_existing(ifp)) <= -1){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "fb_close_existing: can not close device \"%s\", ret=%d.\n",
		    ifp->if_name, status);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);
d249 1
a249 19
      return TCL_ERROR;
    }
#endif
  }else{
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "fb_close_existing: can not close device\n   ifp: %s    device name: %s\n",
		  argv[1], ifp->if_name);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);

    return TCL_ERROR;
  }

  if(ifp->if_pbase != PIXEL_NULL)
    free((void *)ifp->if_pbase);
  free((void *)ifp->if_name);
  free((void *)ifp);

  return TCL_OK;
d252 4
a255 6
int
fb_tcl_writerect(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d257 4
a260 41
  FBIO *ifp;
  int x, y, w, h;
  unsigned char *pp;
  int status;

  if(argc != 7){
    /*XXX put usage message here */
    return TCL_ERROR;
  }

  if(sscanf(argv[1], "%lu", (unsigned long *)&ifp) != 1){
    /*XXX put usage message here */
    return TCL_ERROR;
  }

  FB_TCL_CK_FBIO(ifp);

  if(sscanf(argv[2], "%d", &x) != 1){
    /*XXX put usage message here */
    return TCL_ERROR;
  }

  if(sscanf(argv[3], "%d", &y) != 1){
    /*XXX put usage message here */
    return TCL_ERROR;
  }

  if(sscanf(argv[4], "%d", &w) != 1){
    /*XXX put usage message here */
    return TCL_ERROR;
  }

  if(sscanf(argv[5], "%d", &h) != 1){
    /*XXX put usage message here */
    return TCL_ERROR;
  }

  if(sscanf(argv[6], "%lu", (unsigned long *)&pp) != 1){
    /*XXX put usage message here */
    return TCL_ERROR;
  }
d262 6
a267 57
  status = fb_writerect(ifp, x, y, w, h, pp);

  if(status < 0)
    return TCL_ERROR;

  return TCL_OK;
}

int
fb_tcl_refresh(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
  FBIO *ifp;
  int x, y, w, h; /* rectangle to be refreshed */

  if(argc != 2 && argc != 6){
    /*XXX put usage message here */
    return TCL_ERROR;
  }

  if(sscanf(argv[1], "%lu", (unsigned long *)&ifp) != 1){
    /*XXX put usage message here */
    return TCL_ERROR;
  }

  FB_TCL_CK_FBIO(ifp);

  if(argc == 2){  /* refresh the whole display */
    x = y = 0;
    w = ifp->if_width;
    h = ifp->if_height;
  }else{  /* refresh only the given rectangle of the display */
    if(sscanf(argv[2], "%d", &x) != 1){
      /*XXX put usage message here */
      return TCL_ERROR;
    }

    if(sscanf(argv[3], "%d", &y) != 1){
      /*XXX put usage message here */
      return TCL_ERROR;
    }

    if(sscanf(argv[4], "%d", &w) != 1){
      /*XXX put usage message here */
      return TCL_ERROR;
    }

    if(sscanf(argv[5], "%d", &h) != 1){
      /*XXX put usage message here */
      return TCL_ERROR;
    }
  }

  return fb_refresh(ifp, x, y, w, h);
d272 3
a274 3
FBIO *ifp;
int x, y;
int w, h;
d276 1
a276 1
  char *X_name = "/dev/X";
d278 1
a278 1
  char *ogl_name = "/dev/ogl";
d280 1
a280 1
  int status;
d282 3
a284 3
  if(!strcmp(ifp->if_name, X_name)){
    status = X24_refresh(ifp, x, y, w, h);
  }
d286 7
a292 7
  else if(!strcmp(ifp->if_name, ogl_name)){
    status = ogl_refresh(ifp, x, y, w, h);
  }
#endif
  else{
    return TCL_ERROR;
  }
d294 2
a295 2
  if(status < 0)
    return TCL_ERROR;
d297 1
a297 1
  return TCL_OK;
a298 19

void
fb_configureWindow(ifp, width, height)
FBIO *ifp;
int width, height;
{
  char *X_name = "/dev/X";
#ifdef IF_OGL
  char *ogl_name = "/dev/ogl";
#endif

  if(!strcmp(ifp->if_name, X_name))
    X24_configureWindow(ifp, width, height);
#ifdef IF_OGL
  else if(!strcmp(ifp->if_name, ogl_name))
    ogl_configureWindow(ifp, width, height);
#endif
}

@


1.4
log
@*- change fb_tclInit to Fb_Init
@
text
@a398 1
  struct fbcmd *fbp;
a440 1
  int status;
d462 1
a462 1
    if((status = X24_open_existing(ifp, argc - 1, argv + 1)) <= -1){
d480 1
a480 1
    if((status = ogl_open_existing(ifp, argc - 1, argv + 1)) <= -1){
@


1.3
log
@*- added fb_configureWindow()
@
text
@d103 2
a104 2
void
fb_tclInit(interp)
d113 2
@


1.2
log
@tcl'ed a few more libfb routines
@
text
@d718 19
@


1.1
log
@Initial revision
@
text
@d63 1
d65 1
d71 1
d77 3
d83 3
a85 3
int fb_tcl_close();
int fb_tcl_open_existing();
int fb_tcl_close_existing();
d92 3
d98 2
a99 1
  "fb_close", fb_tcl_close,
d103 12
a387 22
int
fb_tcl_(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
  FBIO *ifp;
  int status;

  if(argc != ){
    /*XXX put usage message here */
    return TCL_ERROR;
  }

  if(sscanf(argv[1], "%lu", (unsigned long *)&ifp) != 1){
    /*XXX put usage message here */
    return TCL_ERROR;
  }

  FB_TCL_CK_FBIO(ifp);
}
a425 18
void
fb_tclInit(interp)
Tcl_Interp *interp;
{
  struct fbcmd *fbp;

  for(fbp = fb_cmds; fbp->cmdName != (char *)0; ++fbp){
    (void)Tcl_CreateCommand(interp, fbp->cmdName, fbp->cmdFunc,
			    (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
  }

/*XXX Experimenting */
  (void)Tcl_CreateCommand(interp, "fb_open_existing", fb_tcl_open_existing,
			  (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
  (void)Tcl_CreateCommand(interp, "fb_close_existing", fb_tcl_close_existing,
			  (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
}

d577 138
@
