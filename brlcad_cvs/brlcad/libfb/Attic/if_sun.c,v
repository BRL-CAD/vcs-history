head	11.4;
access;
symbols
	ansi-20040405-merged:11.2
	postmerge-20040405-ansi:11.2
	premerge-20040404-ansi:11.2
	postmerge-autoconf:11.2
	autoconf-freeze:11.2
	premerge-autoconf:11.2
	ansi-20040316-freeze:11.2
	postmerge-20040315-windows:11.2
	premerge-20040315-windows:11.2
	windows-20040315-freeze:11.2
	autoconf-20031203:11.2
	autoconf-20031202:11.2
	autoconf-branch:11.2.0.14
	phong-branch:11.2.0.12
	photonmap-branch:11.2.0.10
	rel-6-1-DP:11.2
	windows-branch:11.2.0.8
	rel-6-0-2:11.2
	ansi-branch:11.2.0.6
	rel-6-0-1-branch:11.2.0.4
	hartley-6-0-post:11.2
	hartley-6-0-pre:11.2
	rel-6-0-1:11.2
	rel-6-0:11.2
	rel-5-4:11.2
	offsite-5-3-pre:11.2
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1;
locks; strict;
comment	@ * @;


11.4
date	2004.05.21.18.07.25;	author morrison;	state dead;
branches;
next	11.3;

11.3
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	11.2;

11.2
date	98.06.27.04.29.17;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.53.05;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.08.24.19.11.15;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.08.12.20.25.49;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.37.31;	author mike;	state Rel4_0;
branches;
next	9.4;

9.4
date	91.07.26.22.41.14;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.12.11.22.49.32;	author phil;	state Exp;
branches;
next	9.2;

9.2
date	89.09.01.02.56.00;	author phil;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.48.13;	author mike;	state Rel3_5;
branches;
next	8.18;

8.18
date	89.05.15.23.46.37;	author phil;	state Exp;
branches;
next	8.17;

8.17
date	89.05.11.00.33.43;	author phil;	state Exp;
branches;
next	8.16;

8.16
date	89.05.04.03.56.39;	author phil;	state Exp;
branches;
next	8.15;

8.15
date	89.04.29.05.59.34;	author phil;	state Exp;
branches;
next	8.14;

8.14
date	89.04.24.17.22.34;	author butler;	state Exp;
branches;
next	8.13;

8.13
date	89.04.03.19.46.32;	author phil;	state Exp;
branches;
next	8.12;

8.12
date	89.03.09.01.31.26;	author mike;	state Exp;
branches;
next	8.11;

8.11
date	89.03.09.01.19.59;	author mike;	state Exp;
branches;
next	8.10;

8.10
date	89.03.06.21.46.40;	author mike;	state Exp;
branches;
next	8.9;

8.9
date	89.03.03.06.15.03;	author mike;	state Exp;
branches;
next	8.8;

8.8
date	89.03.03.06.05.19;	author mike;	state Exp;
branches;
next	8.7;

8.7
date	89.03.03.05.54.49;	author mike;	state Exp;
branches;
next	8.6;

8.6
date	88.12.09.00.00.08;	author phil;	state Exp;
branches;
next	8.5;

8.5
date	88.12.04.15.09.33;	author phil;	state Exp;
branches;
next	8.4;

8.4
date	88.12.01.17.29.04;	author phil;	state Exp;
branches;
next	8.3;

8.3
date	88.10.23.05.05.12;	author phil;	state Exp;
branches;
next	8.2;

8.2
date	88.10.06.03.33.21;	author phil;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.27.47;	author mike;	state Rel3_0;
branches;
next	7.5;

7.5
date	88.09.15.21.48.40;	author phil;	state Exp;
branches;
next	7.4;

7.4
date	88.09.09.23.36.27;	author phil;	state Exp;
branches;
next	7.3;

7.3
date	88.05.17.12.05.23;	author moss;	state Exp;
branches;
next	7.2;

7.2
date	88.03.22.14.22.44;	author moss;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.27.03;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.07.51.48;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.21.51.57;	author mike;	state Rel;
branches;
next	1.4;

1.4
date	87.04.30.05.56.31;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	87.04.22.06.21.13;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	87.04.21.03.48.15;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	87.04.20.19.08.25;	author mike;	state Exp;
branches;
next	;


desc
@BRL Libfb interface for Sun workstations.
@


11.4
log
@moved to src/
@
text
@/*
 *			I F _ S U N . C 
 *
 *  SUN display interface.  In order to simulate the behavior of a real
 *  framebuffer, an entire image worth of memory is saved using SysV
 *  shared memory.  This image exists across invocations of frame buffer
 *  utilities, and allows the full resolution of an image to be retained,
 *  and captured, even with the 1-bit deep 3/50 displays.
 *
 *  In order to use this large a chunk of memory with the shared memory
 *  system, it is necessary to reconfigure your kernel to authorize this.
 *  If you have already reconfigured your kernel and your hostname is
 *  "PICKLE", you should have a "/sys/conf/PICKLE" file, otherwise you should
 *  read up on kernel reconfiguration in your owners manual, and then
 *  copy /sys/conf/GENERIC to /sys/conf/PICKLE and make the necessary
 *  deletions.  Then add the following line to the other "options" lines
 *  near the top of "PICKLE".
 *
 *  options	SHMPOOL=1024	# Increase for BRL CAD libfb
 *
 *  Once you have modified "PICKLE" finish the procedure by typing:
 *
 *  # /etc/config PICKLE
 *  # cd ../PICKLE
 *  # make && mv /vmunix /vmunix.bak && mv vmunix /vmunix
 *
 *  Then reboot your system and you should be all set.
 *
 *  Note that this has been tested on release 3.2 of the 3/50 kernel.
 *  If you have more than 4 Megs of memory on your system, you may want
 *  to increase [XY]MAXWINDOW to be as big as [XY]MAXSCREEN (see CON-
 *  FIGURATION NOTES below) and increase SHMPOOL appropriately.  If you
 *  do not reconfigure your kernel, the attempt to acquire shared memory
 *  will fail, and the image will be stored in the process's address space
 *  instead, with the only penalty being lack of persistance of the image
 *  across processes.
 *
 *  Authors -
 *	Bill Lindemann
 *	Michael John Muuss
 *	Phil Dykstra
 *	Gary S. Moss
 *	Lee A. Butler
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libfb/if_sun.c,v 11.3 2004/05/10 15:30:45 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <ctype.h>
#include <errno.h>
#include <signal.h>
#include <sys/file.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <suntool/sunview.h>
#include <suntool/canvas.h>

#include "machine.h"
#include "externs.h"
#include "fb.h"
#include "./fblocal.h"

extern char *shmat();

static int	linger();

/* CONFIGURATION NOTES:

	If you have 4 Megabytes of memory, best limit the window sizes
	to 512-by-512 (whether or not your using shared memory) because a
	24-bit image is stored in memory and we don't want our systems to
	thrash do we).
 */
#define XMAXSCREEN	1152	/* Physical screen width in pixels. */
#define YMAXSCREEN	896	/* Physical screen height in pixels. */
#define XMAXWINDOW	640	/* Max. width of frame buffer in pixels. */
#define YMAXWINDOW	512	/* Max. height of frame buffer in pixels. */
#define BANNER		18	/* Height of title bar at top of window. */
#define BORDER		2	/* Border thickness of window. */
#define PARENTBORDER	4	/* Border thickness of parent window. */
#define TITLEXOFFSET	20	/* Indentation for text within title bar. */
#define TITLEYOFFSET	4	/* Vertical padding of text within title bar. */
#define TIMEOUT		15	/* Seconds between check for window repaint. */
#define MAXDITHERSZ	8	/* Dimensions of dithering threshold matrix. */
#define DITHERSZ	8	/* Size of dither pattern used. */
#define DITHMASK(ii) ((ii)&07)	/* Masks of DITHERSZ bits. */

#define EQUALRGB(aa,bb) \
	((aa)[RED]==(bb)[RED]&&(aa)[GRN]==(bb)[GRN]&&(aa)[BLU]==(bb)[BLU])
#define XIMAGE2SCR( x ) \
 ((x)*ifp->if_xzoom-(ifp->if_xcenter*ifp->if_xzoom-ifp->if_width/2))
#define YIMAGE2SCR( y ) \
 ((ifp->if_height-1)-((y)*ifp->if_yzoom-(ifp->if_ycenter*ifp->if_yzoom - ifp->if_height/2)))
_LOCAL_ int	sun_open(),
		sun_close(),
		sun_clear(),
		sun_read(),
		sun_write(),
		sun_rmap(),
		sun_wmap(),
		sun_view(),
		sun_setcursor(),
		sun_cursor(),
		sun_getcursor(),
		sun_poll(),
		sun_free(),
		sun_help();

/* This is the ONLY thing that we "export" */
FBIO sun_interface = {
		0,
		sun_open,
		sun_close,
		sun_clear,
		sun_read,
		sun_write,
		sun_rmap,
		sun_wmap,
		sun_view,
		fb_sim_getview,
		sun_setcursor,
		sun_cursor,
		sun_getcursor,
		fb_sim_readrect,
		fb_sim_writerect,
		fb_sim_bwreadrect,
		fb_sim_bwwriterect,
		sun_poll,
		fb_null,		/* flush */
		sun_free,		/* free */
		sun_help,
		"SUN SunView or raw Pixwin",
		XMAXWINDOW,	/* max width */
		YMAXWINDOW,	/* max height */
		"/dev/sun",
		512,		/* current/default width  */
		512,		/* current/default height */
		-1,		/* select fd */
		-1,		/* file descriptor */
		1, 1,		/* zoom */
		256, 256,	/* window center */
		0, 0, 0,	/* cursor */
		PIXEL_NULL,	/* page_base */
		PIXEL_NULL,	/* page_curp */
		PIXEL_NULL,	/* page_endp */
		-1,		/* page_no */
		0,		/* page_ref */
		0L,		/* page_curpos */
		0L,		/* page_pixels */
		0		/* debug */
};

static int	is_linear_cmap();

/*
 * Our image (window) pixwin
 * XXX WARNING: this should be in suninfo but isn't there yet
 * because of signal routines that need to find it.
 */
static Pixwin	*imagepw;

/*
 *  Per SUN (window or device) state information
 *  Too much for just the if_u[1-6] area now.
 */
struct suninfo
	{
	Window	frame;
	Window	canvas;
	short	su_curs_on;
	short	su_cmap_flag;
	short	su_xcursor;
	short	su_ycursor;
	short	su_depth;
	int	su_shmid;	/* shared memory ID */
	int	su_mode;
	};
#define if_mem		u2.p	/* shared memory pointer */
#define if_cmap		u3.p	/* color map in shared memory */
#define if_windowfd	u4.l	/* f. b. window file descriptor under SUNTOOLS */
#define sunrop(dx,dy,w,h,op,pix,sx,sy) \
		if( sun_pixwin ) \
			pw_rop(SUNPW(ifp),dx,dy,w,h,op,pix,sx,sy); \
		else \
			pr_rop(SUNPR(ifp),dx,dy,w,h,PIX_DONTCLIP|op,pix,sx,sy)

#define sunput(dx,dy,v) \
		if( sun_pixwin ) \
			pw_put(SUNPW(ifp),dx,dy,v); \
		else \
			pr_put(SUNPR(ifp),dx,dy,v);

#define sunreplrop(dx,dy,dw,dh,op,spr,sx,sy) \
		if( sun_pixwin ) \
			pw_replrop(SUNPW(ifp),dx,dy,dw,dh,op,spr,sx,sy); \
		else \
			pr_replrop(SUNPR(ifp),dx,dy,dw,dh,op,spr,sx,sy);

#define SUNPW(ptr)	((Pixwin *)((ptr)->u5.p))
#define SUNPWL(ptr)	((ptr)->u5.p)	/* left hand side version. */
#define SUNPR(ptr)	((Pixrect *)((ptr)->u5.p))
#define SUNPRL(ptr)	((ptr)->u5.p)	/* left hand side version. */
#define	SUN(ptr)	((struct suninfo *)((ptr)->u1.p))
#define SUNL(ptr)	((ptr)->u1.p)	/* left hand side version. */
#define CMR(x)		((struct sun_cmap *)((x)->if_cmap))->cmr
#define CMG(x)		((struct sun_cmap *)((x)->if_cmap))->cmg
#define CMB(x)		((struct sun_cmap *)((x)->if_cmap))->cmb

static int	sun_damaged = FALSE; /* SIGWINCH fired, need to repair damage. */
static int	sun_pixwin = FALSE;  /* Running under SUNTOOLS. */
static RGBpixel black = { 0, 0, 0 };
struct sun_cmap {
	unsigned char	cmr[256];
	unsigned char	cmg[256];
	unsigned char	cmb[256];
};

/* dither pattern (threshold level) for Black & white dithering */
static short	dither[MAXDITHERSZ][MAXDITHERSZ] = {
	  6,  51,  14,  78,   8,  57,  16,  86,
	118,  22, 178,  34, 130,  25, 197,  37,
	 18,  96,  10,  63,  20, 106,  12,  70,
	219,  42, 145,  27, 243,  46, 160,  30,
	  9,  60,  17,  91,   7,  54,  15,  82,
	137,  26, 208,  40, 124,  23, 187,  36,
	 21, 112,  13,  74,  19, 101,  11,  66,
	254,  49, 169,  32, 230,  44, 152,  29
};

/*
 *	Sun Hardware colormap support
 *
 *	The color map is organized as a 6x6x6 colorcube, with 10 extra  
 *	entries each for the primary colors and grey values.
 *
 *	entries 0 -> 215 are the color cube
 *	entries 216 -> 225 are extra "red" values
 *	entries 226 -> 235 are extra "green" values
 *	entries 236 -> 245 are extra "blue" values
 *	entries 246 -> 255 are extra "grey" values
 *
 */
/* Our copy of the *hardware* colormap */
static unsigned char redmap[256], grnmap[256], blumap[256];

/* values for color cube entries */
static unsigned char cubevec[6] = { 0, 51, 102, 153, 204, 255 };

/* additional values for primaries */
static unsigned char primary[10] = {
	17, 34, 68, 85, 119, 136, 170, 187, 221, 238
};

/* Arrays containing the indicies of the primary colors and grey values
 * in the color map
 */
static unsigned char redvec[16] = {
0,  216, 217, 1, 218, 219, 2, 220, 221, 3, 222, 223, 4, 224, 225, 5
};
static unsigned char grnvec[16] = {
0, 226, 227, 6, 228, 229, 12, 230, 231, 18, 232, 233, 24, 234, 235, 30
};
static unsigned char bluvec[16] = {
0, 236, 237, 36, 238, 239, 72, 240, 241, 108, 242, 243, 144, 244, 245, 180
};
static unsigned char greyvec[16] = {
0, 246, 247, 43, 248, 249, 86, 250, 251, 129, 252, 253, 172, 254, 255, 215
};

static 
double table[10] = {0.0, 0.1, -0.4, 0.2, -0.3, 0.3, -0.2, 0.4, -0.1, 0.5};
static double *noise_ptr = table, *end_table = &table[10];
#define NOISE() (noise_ptr < end_table ? *noise_ptr++ : *(noise_ptr=table) )
#define MAG1 51.0
#define MAG2 17.0
#define DITHER(d, v, noise, mag) { \
	if ( (d = v + noise * mag) > 255 ) d = 255; \
	else if (d < 0) d = 0; }

/*	c o n v D I T H E R G B
 *
 *	Convert a single RGBpixel to its corresponding entry in the Sun
 *	colormap, dithering as we go.
 */
_LOCAL_ unsigned char convDITHERGB(v)
register RGBpixel *v;
{
	register int r, g, b;
	double dr, dg, db;
	dr = NOISE(); DITHER(r, (*v)[RED], dr, MAG1); r = (r+26) / 51;
	dg = NOISE(); DITHER(g, (*v)[GRN], dg, MAG1); g = (g+26) / 51;
	db = NOISE(); DITHER(b, (*v)[BLU], db, MAG1); b = (b+26) / 51;
	if (r == g) {
		if (r == b) {
			DITHER(r, (*v)[RED], dr, MAG2);
			DITHER(g, (*v)[GRN], dg, MAG2);
			DITHER(b, (*v)[BLU], db, MAG2);
			return (greyvec[ ( (r + g + b)/3) >> 4]);
		}else if (r == 0) {
			DITHER(r, (*v)[RED], dr, MAG2);
			DITHER(g, (*v)[GRN], dg, MAG2);
			DITHER(b, (*v)[BLU], db, MAG2);
			return (bluvec[ b >> 4]);
		}else return ( r + g * 6 + b * 36 );
	}else if (g == b && g == 0) {
		DITHER(r, (*v)[RED], dr, MAG2);
		DITHER(g, (*v)[GRN], dg, MAG2);
		DITHER(b, (*v)[BLU], db, MAG2);
		return (redvec [ r >> 4]);
	}else if (r == b && r == 0) {
		DITHER(r, (*v)[RED], dr, MAG2);
		DITHER(g, (*v)[GRN], dg, MAG2);
		DITHER(b, (*v)[BLU], db, MAG2);
		return (grnvec[ g >> 4]);
	}else return ( r + g * 6 + b * 36 );
}
/*
 *	c o n v R G B
 *
 *	convert a single RGBpixel to its corresponding entry in the Sun
 *	colormap.
 */
unsigned char convRGB(v)
register RGBpixel *v;
{
	register int r, g, b;

	r = ( (*v)[RED]+26 ) / 51;
	g = ( (*v)[GRN]+26 ) / 51;
	b = ( (*v)[BLU]+26 ) / 51;

	if ( r == g )  {
		if( r == b )  {
			/* all grey, take average */
			return greyvec[( ((*v)[RED]+(*v)[GRN]+(*v)[BLU]) / 3 ) /16];
		}
		else if (r == 0)  {
			/* r=g=0, all blue */
			return bluvec[((*v)[BLU])/16];
		}
		else	return r + g * 6 + b * 36;
	}
	else if (g == b && g == 0)  {
		/* all red */
		return redvec[((*v)[RED])/16];
	}
	else if (r == b && r == 0)  {
		/* all green */
		return grnvec[((*v)[GRN])/16];
	}
	else	return r + g * 6 + b * 36;
}


/*
 *	G E N M A P
 *
 *	initialize the Sun harware colormap
 */
void genmap(rmap, gmap, bmap)
unsigned char rmap[], gmap[], bmap[];
{
	register r, g, b;

	/* build the basic color cube */
	for (r=0 ; r < 6 ; r++)
		for (g=0 ; g < 6 ; g ++)
			for (b=0 ; b < 6 ; b++) {
				rmap[r + g * 6 + b * 36] = cubevec[r];
				gmap[r + g * 6 + b * 36] = cubevec[g];
				bmap[r + g * 6 + b * 36] = cubevec[b];
			}

	/* put in the linear sections */
	for (r=216 ; r < 226 ; ++r) {
		rmap[r] = primary[r-216];	/* red */
		gmap[r] = bmap[r] = 0;
	}

	for (g=226 ; g < 236 ; ++g) {
		gmap[g] = primary[g-226];	/* green */
		rmap[g] = bmap[g] = 0;
	}
	
	for (b=236 ; b < 246 ; ++b) {
		bmap[b] = primary[b-236];	/* blue */
		rmap[b] = gmap[b] = 0;
	}

	for (r=246 ; r < 256 ; ++r) {		/* grey */
		rmap[r] = gmap[r] = 
		bmap[r] = primary[r-246];
	}
}




#define SUN_CMAPVAL( p, o )\
	if( SUN(ifp)->su_cmap_flag )\
		{\
		(o)[RED] = CMR(ifp)[(*p)[RED]];\
		(o)[GRN] = CMG(ifp)[(*p)[GRN]];\
		(o)[BLU] = CMB(ifp)[(*p)[BLU]];\
		}\
	else	COPYRGB( o, *p );

/*
 *  The mode has several independent bits:
 *	SHARED -vs- MALLOC'ed memory for the image
 *	TRANSIENT -vs- LINGERING windows
 *	DitheredColor -vs- UnDitheredColor
 */
#define MODE_1MASK	(1<<0)
#define MODE_1SHARED	(0<<0)		/* Use Shared memory */
#define MODE_1MALLOC	(1<<0)		/* Use malloc memory */

#define MODE_2MASK	(1<<1)
#define MODE_2TRANSIENT	(0<<1)
#define MODE_2LINGERING (1<<1)

#define MODE_3MASK	(1<<2)
#define MODE_3UNDITHERGB (0<<2)
#define MODE_3DITHERGB	(1<<2)		/* dithered colors on color display */

#define MODE_15MASK	(1<<14)
#define MODE_15NORMAL	(0<<14)
#define MODE_15ZAP	(1<<14)

static struct modeflags {
	char	c;
	long	mask;
	long	value;
	char	*help;
} modeflags[] = {
	{ 'p',	MODE_1MASK, MODE_1MALLOC,
		"Private memory - else shared" },
	{ 'l',	MODE_2MASK, MODE_2LINGERING,
		"Lingering window - else transient" },
	{ 'd',  MODE_3MASK, MODE_3DITHERGB,
		"Color dithering - else undithered colors" },
	{ 'z',	MODE_15MASK, MODE_15ZAP,
		"Zap (free) shared memory" },
	{ '\0', 0, 0, "" }
};

_LOCAL_ int
sun_sigwinch( sig )
{
	sun_damaged = TRUE;
	return	sig;
}

_LOCAL_ int
sun_sigalarm( sig )
{
	if( imagepw == (Pixwin *) NULL )
		return	sig;
	(void) signal( SIGALRM, sun_sigalarm );
	if( sun_damaged ) {
		pw_damaged( imagepw );
		pw_repairretained( imagepw );
		pw_donedamaged( imagepw );
		sun_damaged = FALSE;
	}
	alarm( TIMEOUT );
	return	sig;
}

#ifdef INEFFICIENT
_LOCAL_ void
sun_storepixel( ifp, x, y, p, count )
FBIO			*ifp;
int			x, y;
register RGBpixel	*p;
register int		count;
{
	register RGBpixel	*memp;
	for(	memp =	(RGBpixel *)
			(&ifp->if_mem[(y*ifp->if_width+x)*sizeof(RGBpixel)]);
		count > 0;
		memp++, p++, count--
		)
		{
			COPYRGB( *memp, *p );
		}
	return;
}
#endif

_LOCAL_ void
sun_storebackground( ifp, x, y, p, count )
FBIO			*ifp;
int			x, y;
register RGBpixel	*p;
register int		count;
{
	register RGBpixel	*memp;

	memp = (RGBpixel *)
		(&ifp->if_mem[(y*ifp->if_width+x)*sizeof(RGBpixel)]);

	if( (p == (RGBpixel *)0) ||
	    ((*p)[RED] == 0 && (*p)[GRN] == 0 && (*p)[BLU] == 0) ) {
	    	/* black */
	    	bzero( memp, count*sizeof(RGBpixel) );
	} else if( ((*p)[RED] == (*p)[GRN]) && ((*p)[GRN] == (*p)[BLU]) ) {
		/* R, G, and B are equal */
		memset( memp, (*p)[RED] );
	} else {
		while( count-- > 0 ) {
			COPYRGB( *memp, *p );
			memp++;
		}
	}
	return;
}

/* These lock routines are unused.  They do not seem to provide any
speedup when bracketing raster op routines.  This may pan out
differently when other processes are actively competing for raster ops. 
*/
_LOCAL_ void sun_lock( ifp ) FBIO *ifp;
{
	if( sun_pixwin ) {
		 /* Lock the display and get the cursor out of the way. */
		pw_lock( SUNPW(ifp), SUNPW(ifp)->pw_pixrect );
	}
	return;
}

_LOCAL_ void
sun_unlock( ifp )
FBIO	*ifp;
{
	if( sun_pixwin ) {
		/* Release display lock and restore cursor. */
		pw_unlock( SUNPW(ifp) );
	}
	return;
}

/* Dither pattern pixrect for fast raster ops.  (1bit displays) */
static char	dither_mpr_buf[8];
mpr_static( dither_mpr, DITHERSZ, DITHERSZ, 1, (short *)dither_mpr_buf );

/* Straight pixrect for grey-scale and color devices. (8bit) */
static char	pixel_mpr_buf[1];
mpr_static( pixel_mpr, 1, 1, 8, (short *)pixel_mpr_buf );

_LOCAL_ void
sun_rectclear( ifp, xlft, ytop, width, height, pp )
FBIO		*ifp;
int		xlft, ytop, width, height;
RGBpixel	*pp;
{
	static int		lastvalue = 0;
	register int		value;
	RGBpixel		v;

	/*fb_log( "sun_rectclear(%d,%d,%d,%d)\n", xlft, ytop, width, height ); /* XXX-debug */
	/* Get color map value for pixel. */
	SUN_CMAPVAL( pp, v );

 	if( SUN(ifp)->su_depth == 1 ) {
		/* Construct dither pattern in memory pixrect. */
		value = (v[RED] + v[GRN] + v[BLU]);
		if( value == 0 ) {
			sunrop( xlft, ytop, width, height,
				PIX_SET, (Pixrect *) 0, 0, 0
				);
			return;
		}
		if( value != lastvalue ) {
			register int	i, j;
			for( i = 0; i < DITHERSZ; i++ )
				for( j = 0; j < DITHERSZ; j++ )
					{	register int	op;
					op = (value < dither[j][i]*3) ?
						PIX_SET : PIX_CLR;
					pr_rop( &dither_mpr, j, i, 1, 1, op,
						(Pixrect *) NULL, 0, 0 );
					}
			lastvalue = value;
		}
		/* Blat out dither pattern. */
		sunreplrop( xlft, ytop, width, height,
			PIX_SRC, &dither_mpr, DITHMASK(xlft), DITHMASK(ytop) );
	}
	else {
		/* Grey-scale or color image. */
		pixel_mpr_buf[0] = convRGB(v);

		sunreplrop(xlft, ytop, width, height,
			PIX_SRC, &pixel_mpr, 0, 0);
	}
	return;
}

/*
 * Scanline dither pattern pixrect.  One each for 1bit, and 8bit
 * deep displays.  If DITHERSZ or BITSDEEP > sizeof(char) you must
 * extend the length of scan_mpr_buf accordingly.
 */
static char	scan_mpr_buf[XMAXWINDOW];
mpr_static( scan1_mpr, XMAXWINDOW, DITHERSZ, 1, (short *)scan_mpr_buf );
mpr_static( scan8_mpr, XMAXWINDOW, DITHERSZ, 8, (short *)scan_mpr_buf );

/*
 * XXX - 512 calls to scanwrite consumed 10.8 seconds or 78% of
 * the runtime of pix-fb dragon.pix on a monochrome Sun.
 */
_LOCAL_ void
sun_scanwrite( ifp, xlft, ybtm, xrgt, pp )
FBIO		*ifp;
int		xlft;
int		ybtm;
register int	xrgt;
RGBpixel	*pp;
{
	register int	sy = YIMAGE2SCR( ybtm+1 ) + 1;
	register int	xzoom = ifp->if_xzoom;
	int		xl = XIMAGE2SCR( xlft );

	/*fb_log( "sun_scanwrite(%d,%d,%d,0x%x)\n", xlft, ybtm, xrgt, pp );
		/* XXX-debug */

 	if( SUN(ifp)->su_depth == 1 ) {
		register int	x;
		register int	sx = xl;
		int		yzoom = ifp->if_yzoom;

		/* Clear buffer to black. */
		(void) memset( scan_mpr_buf, 0xff, XMAXWINDOW );

		for( x = xlft; x <= xrgt; x++, sx += xzoom, pp++ ) {
			register int	value;
			RGBpixel	v;

			/* Get color map value for pixel. */
			SUN_CMAPVAL( pp, v );
			value = v[RED] + v[GRN] + v[BLU];

			if( value ) {
				register int	maxdy = yzoom < DITHERSZ ?
							yzoom : DITHERSZ;
				register int	dy;
				register int	yoffset = sx;

				/* Construct dither pattern. */
				value /= 3;
				for( dy = 0; dy < maxdy; dy++, yoffset += XMAXWINDOW ) {
					register int dx;
					register int ydit = DITHMASK(sy+dy);
					for( dx = 0; dx < xzoom; dx++ ) {
						register int xdit =
							DITHMASK(sx+dx);
						if( value >= dither[xdit][ydit] )
							scan_mpr_buf[(yoffset+dx)>>3] &= ~(0x80>>xdit);
					}
				}
			}
		}
		sunreplrop( xl, sy,
			(xrgt-xlft+1)*xzoom, yzoom,
			PIX_SRC, &scan1_mpr,
			xl, 0 );
	}
	else {
		/* Grey-scale or color image. */
		register int	x;
		register int	sx = xl;
		unsigned char	(*convf)();
		if( (SUN(ifp)->su_mode & MODE_3MASK) == MODE_3DITHERGB )
			convf = convDITHERGB;
		else
			convf = convRGB;
		
		for( x = xlft; x <= xrgt; x++, pp++, sx += xzoom ) {
			register int	dx, value, r, g, b;
			RGBpixel	v;


			/* Get Software color map value for pixel. */
			SUN_CMAPVAL( pp, v );
			/* Convert RGBpixel to 8 bit Sun pixel */
			value = (*convf)(v);

			for( dx = 0; dx < xzoom; dx++ )
				scan_mpr_buf[sx+dx] = value; 
		}
		sunreplrop( xl, sy,
			(xrgt-xlft+1)*xzoom, ifp->if_yzoom,
			PIX_SRC, &scan8_mpr,
			xl, 0 );
	}
	return;
}

_LOCAL_ void
sun_rectwrite( ifp, xmin, ymin, xmax, ymax, buf, offset )
register FBIO		*ifp;
int			xmin, ymin;
int			xmax;
register int		ymax;
RGBpixel		*buf;
register int		offset;
{
	register int		y;
	register RGBpixel	*p;
	/*fb_log( "sun_rectwrite(xmin=%d,ymin=%d,xmax=%d,ymax=%d,buf=0x%x,offset=%d)\n",
		xmin, ymin, xmax, ymax, buf, offset ); /* XXX--debug */
	p = buf-offset+ymin*ifp->if_width+xmin;
	for( y = ymin; y <= ymax; y++, p += ifp->if_width )
		sun_scanwrite(	ifp, xmin, y, xmax, p );
	return;
}

_LOCAL_ void
sun_repaint( ifp )
register FBIO	*ifp;
{
	register int	i;
	register int	ymin, ymax;
	int		xmin, xmax;
	int		xwidth;
	int		xscroff, yscroff;
	int		xscrpad, yscrpad;
	/*fb_log( "sun_repaint: xzoom=%d yzoom=%d xcenter=%d ycenter=%d\n",
		ifp->if_xzoom, ifp->if_yzoom,
		ifp->if_xcenter, ifp->if_ycenter ); /* XXX-debug */
	xscroff = yscroff = 0;
	xscrpad = yscrpad = 0;
	xwidth = ifp->if_width/ifp->if_xzoom;
	i = xwidth/2;
	xmin = ifp->if_xcenter - i;
	xmax = ifp->if_xcenter + i - 1;
	i = (ifp->if_height/2)/ifp->if_yzoom;
	ymin = ifp->if_ycenter - i;
	ymax = ifp->if_ycenter + i - 1;
	if( xmin < 0 ) {
		xscroff = -xmin * ifp->if_xzoom;
		xmin = 0;
	}
	if( ymin < 0 ) {
		yscroff = -ymin * ifp->if_yzoom;
		ymin = 0;
	}
	if( xmax > ifp->if_width-1 ) {
		xscrpad = (xmax-(ifp->if_width-1))*ifp->if_xzoom;
		xmax = ifp->if_width-1;
	}
	if( ymax > ifp->if_height-1 ) {
		yscrpad = (ymax-(ifp->if_height-1))*ifp->if_yzoom;
		ymax = ifp->if_height-1;
	}
	/* Blank out area left of image.			*/
	if( xscroff > 0 )
		sun_rectclear(	ifp, 0, 0, xscroff, ifp->if_height,
				(RGBpixel *) black );
	/* Blank out area below image.			*/
	if( yscroff > 0 )
		sun_rectclear(	ifp, 0, ifp->if_height-yscroff,
				ifp->if_width, yscroff,
				(RGBpixel *) black );
	/* Blank out area right of image.			*/
	if( xscrpad > 0 )
		sun_rectclear(	ifp, ifp->if_width-xscrpad, 0,
				xscrpad, ifp->if_height,
				(RGBpixel *) black );
	/* Blank out area above image.			*/
	if( yscrpad > 0 )
		sun_rectclear(	ifp, 0, 0,
				ifp->if_width, yscrpad,
				(RGBpixel *) black );
	sun_rectwrite( ifp, xmin, ymin, xmax, ymax, (RGBpixel *)ifp->if_mem, 0 );
	return;
}

/*
 *			S U N _ G E T M E M
 *
 *  Because there is no hardware zoom or pan, we need to repaint the
 *  screen (with big pixels) to implement these operations.
 *  This means that the actual "contents" of the frame buffer need
 *  to be stored somewhere else.  If possible, we allocate a shared
 *  memory segment to contain that image.  This has several advantages,
 *  the most important being that although output mode requires monochrome,
 *  dithering, or up to 8-bit color on the Suns, pixel-readbacks still
 *  give the full 24-bits of color.  System V shared memory persists
 *  until explicitly killed, so this also means that under SUNTOOLS, the
 *  previous contents of the frame buffer still exist, and can be again
 *  accessed, even though the windows are transient, per-process.
 */
_LOCAL_ int
sun_getmem( ifp )
FBIO	*ifp;
{
	int	pixsize;
	int	size;
	int	new = 0;
	static char	*sp = NULL;
	extern caddr_t	sbrk();

	errno = 0;
	pixsize = ifp->if_max_height * ifp->if_max_width * sizeof(RGBpixel);
	size = pixsize + sizeof(struct sun_cmap);
	size = (size + 4096-1) & ~(4096-1);
#define SHMEM_KEY	42
	/* Do once per process. */
	if( sp == (char *) NULL ) {
		if( (SUN(ifp)->su_mode & MODE_1MASK) == MODE_1MALLOC )
			goto localmem;

		/* First try to attach to an existing shared memory */
		if( (SUN(ifp)->su_shmid = shmget(SHMEM_KEY, size, 0)) < 0 ) {
			/* No existing one, create a new one */
			SUN(ifp)->su_shmid =
				shmget( SHMEM_KEY, size, IPC_CREAT|0666 );
			if( SUN(ifp)->su_shmid < 0 )
				goto fail;
			new = 1;
		}
		/* Open the segment Read/Write, near the current break */
		if( (sp = shmat( SUN(ifp)->su_shmid, 0, 0 )) < 0 ) {
			fb_log("shmat returned x%x, errno=%d\n", sp, errno );
			goto fail;
		}
		goto	common;
fail:
		fb_log("sun_getmem:  Unable to attach to shared memory, using private.\n");
		fb_log("Consult comment in cad/libfb/if_sun.c for details.\n");
		/* Change it to local */
		SUN(ifp)->su_mode = (SUN(ifp)->su_mode & ~MODE_1MASK)
			| MODE_1MALLOC;
localmem:
		if( (sp = malloc( size )) == NULL ) {
			fb_log( "sun_getmem:  malloc failure, couldn't allocate %d bytes\n", size );
			return	-1;
		}
		new = 1;
	}
common:
	ifp->if_mem = sp;
	ifp->if_cmap = sp + pixsize;	/* Color map at end of area */
	
	/* Initialize the colormap and clear memory frame buffer to black */
	if( new ) {
		sun_wmap( ifp, COLORMAP_NULL );
		sun_storebackground( ifp, 0, 0, black, ifp->if_max_width*ifp->if_max_height );
	}
	return	0;
}

/*
 *			S U N _ Z A P M E M
 */
_LOCAL_ void
sun_zapmem()
{
 	int	shmid;
	int	i;
	if( (shmid = shmget( SHMEM_KEY, 0, 0 )) < 0 ) {
		fb_log( "sun_zapmem shmget failed, errno=%d\n", errno );
		return;
	}

	i = shmctl( shmid, IPC_RMID, 0 );
	if( i < 0 ) {
		fb_log( "sun_zapmem shmctl failed, errno=%d\n", errno );
		return;
	}
	fb_log( "if_sun: shared memory released\n" );
	return;
}

/*
 *			S U N _ O P E N 
 */
_LOCAL_ int
sun_open(ifp, file, width, height)
FBIO	*ifp;
char	*file;
int	width, height;
{
	char		sun_parentwinname[WIN_NAMESIZE];
	Rect		winrect;
	int		x;
	struct pr_prpos	where;
	struct pixfont	*myfont;
	int	mode;

	FB_CK_FBIO(ifp);

	/*
	 *  First, attempt to determine operating mode for this open,
	 *  based upon the "unit number" or flags.
	 *  file = "/dev/sun###"
	 *  The default mode is zero.
	 */
	mode = 0;

	if( file != NULL )  {
		register char *cp;
		struct	modeflags *mfp;

		if( strncmp(file, "/dev/sun", 8) ) {
			/* How did this happen?? */
			mode = 0;
		}
		else {
			/* Parse the options as either ascii mnemonics or
			 * as decimal bit representation
			 */
			if ( isdigit(*(cp= &file[8])) || *cp == '-') mode = atoi(cp);
			else {
				for ( ;*cp != '\0' && !isspace(*cp) ; ++cp) {
					/* look for character in mode list */
					for( mfp = modeflags; mfp->c != '\0'; mfp++ )
						if( mfp->c == *cp ) {
							mode = (mode&~mfp->mask)|mfp->value;
							break;
						}
					if( mfp->c == '\0' && *cp != '-' )
						fb_log( "if_sun: unknown option '%c' ignored\n", *cp );
				}
			}
		}

		if( (mode & MODE_15MASK) == MODE_15ZAP ) {
			/* Only task: Attempt to release shared memory segment */
			sun_zapmem();
			return(-1);
		}

		/* Pick off just the mode bits of interest here */
		mode &= (MODE_1MASK | MODE_2MASK | MODE_3MASK);
	}

	if( width <= 0 )
		width = ifp->if_width;
	if( height <= 0 )
		height = ifp->if_height;
	if ( width > ifp->if_max_width) 
		width = ifp->if_max_width;
	if ( height > ifp->if_max_height) 
		height = ifp->if_max_height;

	if( SUN(ifp) != (struct suninfo *) NULL ) {
		fb_log( "sun_open, already open\n" );
		return	-1;	/* FAIL */
	}
	if( (SUNL(ifp) = calloc( 1, sizeof(struct suninfo) )) == NULL ) {
		fb_log( "sun_open:  suninfo calloc failed\n" );
		return	-1;
	}
	SUN(ifp)->su_mode = mode;
	SUN(ifp)->su_shmid = -1;
#define WHICH_FONT	"/usr/lib/fonts/fixedwidthfonts/screen.b.14"
	myfont = pf_open( WHICH_FONT );
	if( myfont == 0 )  {
		fb_log("sun_open: pf_open %s failure\n", WHICH_FONT);
		return(-1);
	}

	/*
	 * Initialize what we want an 8bit *hardware* colormap to
	 * look like.  Note that our software colormap is totally
	 * separate from this.
	 */

	genmap(redmap, grnmap, blumap);
	
	/* Create window. */
        if( sun_pixwin = (we_getgfxwindow(sun_parentwinname) == 0) ) {
        	/************** SunView Open **************/
		Window	frame;
		Canvas	canvas;

		/* Make a frame and a canvas to go in it */
		frame = window_create(NULL, FRAME,
			      FRAME_LABEL, "Frame Buffer", 0);
		if( frame == 0 )  {
			fb_log("sun_open: window_create frame failure\n");
			return(-1);
		}
		/* XXX - "command line" args? pg.51 */
		canvas = window_create(frame, CANVAS,
			      WIN_WIDTH, width,
			      WIN_HEIGHT, height, 0);
		if( canvas == 0 )  {
			fb_log("sun_open: window_create canvas failure\n");
			return(-1);
		}
		/* Fit window to canvas (width+10, height+20) */
		window_fit(frame);

		/* get the canvas pixwin to draw in */
		imagepw = canvas_pixwin(canvas);
		SUNPWL(ifp) = (char *) imagepw;

		winrect = *((Rect *)window_get(canvas, WIN_RECT));
		if( width > winrect.r_width )
			width = winrect.r_width;
		if( height > winrect.r_height )
			height = winrect.r_height;

		ifp->if_windowfd = imagepw->pw_clipdata->pwcd_windowfd;
		SUN(ifp)->su_depth = SUNPW(ifp)->pw_pixrect->pr_depth;
		SUN(ifp)->frame = frame;
		SUN(ifp)->canvas = canvas;

		/* set up window input */
		/*window_set(canvas, WIN_EVENT_PROC, input_eater, 0);*/

		window_set(frame, WIN_SHOW, TRUE, 0);	/* display it! */
		(void) notify_dispatch();		/* process event */

		if( SUN(ifp)->su_depth == 8 ) {
			/* set a new cms name; initialize it */
			x = pw_setcmsname(imagepw, "libfb");
			x = pw_putcolormap(imagepw, 0, 256, 
					redmap, grnmap, blumap);
		}
	}
	else {
        	/************ Raw Screen Open ************/
		Pixrect	*screenpr;
		Pixrect	*windowpr;

		screenpr = pr_open( "/dev/fb" );
		if( screenpr == (Pixrect *) NULL ) {
			fb_log("sun_open: pr_open /dev/fb failure\n");
			return(-1);
		}
		windowpr = pr_region(	screenpr,
			XMAXSCREEN-width-BORDER*2,
			YMAXSCREEN-(height+BANNER+BORDER*3),
			width+BORDER*2, height+BANNER+BORDER*3
			);
		if( windowpr == 0 )  {
			fb_log("sun_open: pr_region failure\n");
			return(-1);
		}

		SUNPRL(ifp) = (char *)
			pr_region(	windowpr,
					BORDER, BANNER+BORDER*2,
					width, height
					);
		/* Outer border is black. */
		pr_rop( windowpr, 0, 0,
			width+BORDER*2, height+BANNER+BORDER*3,
			PIX_DONTCLIP | PIX_SET,
			(Pixrect *) NULL, 0, 0 );
		/* Inner border is white. */
		pr_rop( windowpr, 1, 1,
			width+2, height+BANNER+BORDER*2,
			PIX_DONTCLIP | PIX_CLR,
			(Pixrect *) NULL, 0, 0 );
		/* Black out title bar. */
		pr_rop( windowpr, BORDER, BORDER,
			width, BANNER,
			PIX_DONTCLIP | PIX_SET,
			(Pixrect *) NULL, 0, 0 );
		/* Draw title in title bar (banner). */
		where.pr = windowpr;
		where.pos.x = TITLEXOFFSET;
		where.pos.y = BANNER - TITLEYOFFSET;
		pf_ttext(	where,
				PIX_CLR,
				myfont, "BRL libfb Frame Buffer" );
		SUN(ifp)->su_depth = SUNPR(ifp)->pr_depth;
		if( SUN(ifp)->su_depth == 8 ) {
			pr_putcolormap(windowpr, 0, 256,
				redmap, grnmap, blumap );
		}
	}
	pf_close( myfont );

	if( (SUN(ifp)->su_depth != 1) && (SUN(ifp)->su_depth != 8) ) {
		fb_log( "if_sun: Can only handle 1bit and 8bit deep displays (not %d)\n",
			SUN(ifp)->su_depth );
		return	-1;
	}

	ifp->if_width = width;
	ifp->if_height = height;
	ifp->if_xzoom = 1;
	ifp->if_yzoom = 1;
	ifp->if_xcenter = width/2;
	ifp->if_ycenter = height/2;
	sun_getmem( ifp );

	/* Must call "is_linear_cmap" AFTER "sun_getmem" which allocates
		space for the color map.				*/
	SUN(ifp)->su_cmap_flag = !is_linear_cmap(ifp);

	if( (SUN(ifp)->su_mode & MODE_1MASK) == MODE_1SHARED ) {
		/* Redraw 24-bit image from shared memory */
		sun_repaint( ifp );
	}

	return	0;		/* "Success" */
}

/*
 *			S U N _ C L O S E 
 */
_LOCAL_ int
sun_close(ifp)
FBIO	*ifp;
{
	register Pixrect *p;
	register int i;

	if( SUNL(ifp) == (char *) NULL ) {
		fb_log( "sun_close: frame buffer not open.\n" );
		return	-1;
	}
	if( sun_pixwin ) {
		if( (SUN(ifp)->su_mode & MODE_2MASK) == MODE_2LINGERING ) {
			if( linger(ifp) )
				return	0;  /* parent leaves the display */
		}
		/* child or single process */
		alarm( 0 ); /* Turn off window redraw daemon. */
		window_set(SUN(ifp)->frame, FRAME_NO_CONFIRM, TRUE, 0);
		window_destroy(SUN(ifp)->frame);
		imagepw = NULL;
	}
	else {
		/* if the user hasn't requested a lingering buffer, clear the 
		 * colormap so that we can see to log in on the console again
		 */
		if( (SUN(ifp)->su_mode & MODE_2MASK) != MODE_2LINGERING) {
			p = SUNPR(ifp);
			redmap[0] = grnmap[0] = blumap[0] = 255;
			for (i=1 ; i < 256 ; ++i)
				redmap[i] = grnmap[i] = blumap[i] = 0;
			pr_putcolormap(p, 0, 256, redmap, grnmap, blumap);
		}
		pr_close( SUNPR(ifp) );
	}
	/* free up memory associated with image */
	if( SUN(ifp)->su_shmid >= 0 ) {
		/* detach from shared memory */
		if( shmdt( ifp->if_mem ) == -1 ) {
			fb_log("sun_close shmdt failed, errno=%d\n", errno);
			return -1;
		}
	} else {
		/* free private memory */
		(void)free( ifp->if_mem );
	}
	(void) free( (char *) SUNL(ifp) );
	SUNL(ifp) = NULL;
	return	0;
}

/*
 *			S U N _ P O L L
 */
_LOCAL_ int
sun_poll(ifp)
FBIO	*ifp;
{
	/* XXX - Need to empty event queue here, not just one event */
	notify_dispatch();
}

/*
 *			S U N _ F R E E
 *
 *  Like close, but also releases shared memory if any.
 */
_LOCAL_ int
sun_free(ifp)
FBIO	*ifp;
{
	register Pixrect *p;
	register int i;

	if( SUNL(ifp) == (char *) NULL ) {
		fb_log( "sun_free: frame buffer not open.\n" );
		return	-1;
	}
	if( sun_pixwin ) {
		/* child or single process */
		alarm( 0 ); /* Turn off window redraw daemon. */
		window_set(SUN(ifp)->frame, FRAME_NO_CONFIRM, TRUE, 0);
		window_destroy(SUN(ifp)->frame);
		imagepw = NULL;
	}
	else {
		/* if the user hasn't requested a lingering buffer, clear the 
		 * colormap so that we can see to log in on the console again
		 */
		if( (SUN(ifp)->su_mode & MODE_2MASK) != MODE_2LINGERING) {
			p = SUNPR(ifp);
			redmap[0] = grnmap[0] = blumap[0] = 255;
			for (i=1 ; i < 256 ; ++i)
				redmap[i] = grnmap[i] = blumap[i] = 0;
			pr_putcolormap(p, 0, 256, redmap, grnmap, blumap);
		}
		pr_close( SUNPR(ifp) );
	}
	/* free up memory associated with image */
	if( SUN(ifp)->su_shmid >= 0 ) {
		/* release shared memory */
		sun_zapmem();
	} else {
		/* free private memory */
		(void)free( ifp->if_mem );
	}
	(void) free( (char *) SUNL(ifp) );
	SUNL(ifp) = NULL;
	return	0;
}

/*
 *			S U N _ C L E A R 
 */
_LOCAL_ int
sun_clear(ifp, pp)
FBIO			*ifp;
register RGBpixel	*pp;
{
	if( pp == (RGBpixel *) NULL )
		pp = (RGBpixel *) black;

	/* Clear 24-bit image in shared memory. */
	sun_storebackground( ifp, 0, 0, pp, ifp->if_width*ifp->if_height );

	/* Clear entire screen. */
	sun_rectclear( ifp, 0, 0, ifp->if_width, ifp->if_height, pp );
	return	0;
}

/*
 *			S U N _ V I E W
 */
_LOCAL_ int
sun_view(ifp, xcenter, ycenter, xzoom, yzoom)
FBIO	*ifp;
int     xcenter, ycenter;
int	xzoom, yzoom;
{
	/*fb_log( "sun_window_set(0x%x,%d,%d)\n", ifp, xcenter , ycenter );*/
	if( ifp->if_xcenter == xcenter && ifp->if_ycenter == ycenter
	 && ifp->if_xzoom == xzoom && ifp->if_yzoom == yzoom )
		return	0;
	if( xcenter < 0 || xcenter >= ifp->if_width )
		return	-1;
	if( ycenter < 0 || ycenter >= ifp->if_height )
		return	-1;
	if( xzoom >= ifp->if_width || yzoom >= ifp->if_height )
		return	-1;

	ifp->if_xcenter = xcenter;
	ifp->if_ycenter = ycenter;
	ifp->if_xzoom = xzoom;
	ifp->if_yzoom = yzoom;

	/* Redraw 24-bit image from memory. */
	sun_repaint(ifp);
	return	0;
}

/*
 *			S U N _ S E T C U R S O R
 */
_LOCAL_ int
sun_setcursor(ifp, bits, xbits, ybits, xorig, yorig )
FBIO		*ifp;
unsigned char	*bits;
int		xbits, ybits;
int		xorig, yorig;
{
	register int	xbytes;
	register int	y;
	Cursor		newcursor;
	/* Check size of cursor. */
	if( xbits < 0 )
		return	-1;
	if( xbits > 16 )
		xbits = 16;
	if( ybits < 0 )
		return	-1;
	if( ybits > 16 )
		ybits = 16;
	if( (xbytes = xbits / 8) * 8 != xbits )
		xbytes++;
#if 0
	for( y = 0; y < ybits; y++ ) {
		newcursor[y] = bits[(y*xbytes)+0] << 8 & 0xFF00;
		if( xbytes == 2 )
			newcursor[y] |= bits[(y*xbytes)+1] & 0x00FF;
	}
#endif
	return	0;
}

/*
 *			S U N _ C U R S O R
 */
_LOCAL_ int
sun_cursor( ifp, mode, x, y )
FBIO	*ifp;
int	mode;
int	x, y;
{
	short	xmin, ymin;
	register short	i;
	short	xwidth;

	fb_sim_cursor(ifp, mode, x, y);
	if( ! sun_pixwin )
		return	0; /* No cursor outside of suntools yet. */
	SUN(ifp)->su_curs_on = mode;
	if( ! mode ) {
		/* XXX turn off cursor. */
		return	0;
	}
	xwidth = ifp->if_width/ifp->if_xzoom;
	i = xwidth/2;
	xmin = ifp->if_xcenter - i;
	i = (ifp->if_height/2)/ifp->if_yzoom;
	ymin = ifp->if_ycenter - i;
	x -= xmin;
	y -= ymin;
	x *= ifp->if_xzoom;
	y *= ifp->if_yzoom;
	y = ifp->if_height - y;
	/* Move cursor/mouse to <x,y>. */	
	if(	x < 1 || x > ifp->if_width
	    ||	y < 1 || y > ifp->if_height
		)
		return	-1;
	/* Translate address from window to tile space. */
	x += BORDER;
	y += BORDER*2 + BANNER;
	SUN(ifp)->su_xcursor = x;
	SUN(ifp)->su_ycursor = y;
	win_setmouseposition( ifp->if_windowfd, x, y );
	return	0;
}

/*
 *			S U N _ G E T C U R S O R
 */
_LOCAL_ int
sun_getcursor(ifp, mode, x, y)
FBIO	*ifp;
int	*mode;
int	*x, *y;
{
	fb_sim_getcursor(ifp, mode, x, y);	/*XXX*/
	return	0;
}

/*
 *			S U N _ R E A D 
 */
_LOCAL_ int
sun_read(ifp, x, y, p, count)
FBIO			*ifp;
int			x, y;
register RGBpixel	*p;
register int		count;
{
	register RGBpixel	*memp;

	for(	memp =	(RGBpixel *)
			(&ifp->if_mem[(y*ifp->if_width+x)*sizeof(RGBpixel)]);
		count > 0;
		memp++, p++, count--
		)
		{
			COPYRGB( *p, *memp );
		}
	return	count;
}

/*
 *			S U N _ W R I T E
 */
_LOCAL_ int
sun_write(ifp, x, y, p, count)
register FBIO	*ifp;
int		x, y;
RGBpixel	*p;
register int	count;
{
	int		xmax, ymax;
	register int	xwidth;

	/*fb_log( "sun_write(0x%x,%d,%d,0x%x,%d)\n", ifp, x, y, p, count );
		/* XXX--debug */
	/* Store pixels in memory. */
	/*sun_storepixel( ifp, x, y, p, count );*/
	bcopy( p, &ifp->if_mem[(y*ifp->if_width+x)*sizeof(RGBpixel)],
		count*sizeof(RGBpixel) );

	xwidth = ifp->if_width/ifp->if_xzoom;
	xmax = count >= xwidth-x ? xwidth-1 : x+count-1;
	ymax = y + (count-1)/ ifp->if_width;
	sun_rectwrite( ifp, x, y, xmax, ymax, p, y*ifp->if_width+x );
	return	count;
}

/*
 *			S U N _ R M A P
 */
_LOCAL_ int
sun_rmap( ifp, cmp )
register FBIO		*ifp;
register ColorMap	*cmp;
{
	register int i;

	/* Just parrot back the stored colormap */
	for( i = 0; i < 256; i++)
		{
		cmp->cm_red[i] = CMR(ifp)[i]<<8;
		cmp->cm_green[i] = CMG(ifp)[i]<<8;
		cmp->cm_blue[i] = CMB(ifp)[i]<<8;
		}
	return	0;
}

/*
 *			I S _ L I N E A R _ C M A P
 *
 *  Check for a color map being linear in R, G, and B.
 *  Returns 1 for linear map, 0 for non-linear map
 *  (ie, non-identity map).
 */
static int
is_linear_cmap(ifp)
register FBIO	*ifp;
{
 	register int i;
	for( i=0; i<256; i++ )
		{
		if( CMR(ifp)[i] != i )  return(0);
		if( CMG(ifp)[i] != i )  return(0);
		if( CMB(ifp)[i] != i )  return(0);
		}
	return	1;
}

/*
 *			S U N _ W M A P
 */
_LOCAL_ int
sun_wmap(ifp, cmp)
register FBIO		*ifp;
register ColorMap	*cmp;
{
	register int i;
	if( cmp == COLORMAP_NULL ) {
		for( i = 0; i < 256; i++) {
			CMR(ifp)[i] = i;
			CMG(ifp)[i] = i;
			CMB(ifp)[i] = i;
		}
		if( SUN(ifp)->su_cmap_flag ) {
			SUN(ifp)->su_cmap_flag = FALSE;
			sun_repaint( ifp );
		}
		SUN(ifp)->su_cmap_flag = FALSE;
		return	0;
	}
	
	for( i = 0; i < 256; i++ ) {
		CMR(ifp)[i] = cmp-> cm_red[i]>>8;
		CMG(ifp)[i] = cmp-> cm_green[i]>>8; 
		CMB(ifp)[i] = cmp-> cm_blue[i]>>8;
	}
	SUN(ifp)->su_cmap_flag = !is_linear_cmap(ifp);
	sun_repaint( ifp );
	return	0;
}

_LOCAL_ int
sun_help( ifp )
FBIO	*ifp;
{
	struct	modeflags *mfp;

	fb_log( "Description: %s\n", sun_interface.if_type );
	fb_log( "Device: %s\n", ifp->if_name );
	fb_log( "Max width/height: %d %d\n",
		sun_interface.if_max_width,
		sun_interface.if_max_height );
	fb_log( "Default width/height: %d %d\n",
		sun_interface.if_width,
		sun_interface.if_height );
	fb_log( "Usage: /dev/sun[options]\n" );
	for( mfp = modeflags; mfp->c != '\0'; mfp++ ) {
		fb_log( "   %c   %s\n", mfp->c, mfp->help );
	}

	return(0);
}

static int window_not_destroyed = 1;

static Notify_value
my_real_destroy(frame, status)
Frame	frame;
Destroy_status	status;
{
	if( status != DESTROY_CHECKING ) {
		window_not_destroyed = 0;
	}
	/* Let frame get destroy event */
	return( notify_next_destroy_func(frame, status) );
}

/*
 *  Lingering Window.
 *  Wait around until a "quit" is selected.  Ideally this would
 *  happen in a child process with a fork done to free the original
 *  program and return control to the shell.  However, something
 *  in Suntools seems to stop notifying this window of repaints, etc.
 *  as soon as the PID changes.  Until we figure out how to get around
 *  this the parent will have to keep hanging on.
 */
static int
linger( ifp )
FBIO	*ifp;
{
	struct timeval  timeout;

#ifdef DOFORK
	/* allow child to inherit input events */
	window_release_event_lock(SUN(ifp)->frame);
	window_release_event_lock(SUN(ifp)->canvas);
	pw_unlock(SUNPW(ifp));

	notify_dispatch();

	printf("forking\n");
	if( fork() )
		return 1;	/* release the parent */
#endif

	notify_interpose_destroy_func(SUN(ifp)->frame,my_real_destroy);

	timeout.tv_sec = 0;
	timeout.tv_usec = 250000;

	while( window_not_destroyed ) {
		(void) select(0, (fd_set *)0, (fd_set *)0, (fd_set *)0, &timeout);
		notify_dispatch();
	}
	return	0;
}
@


11.3
log
@change conf.h to a wrapped config.h
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/libfb/if_sun.c,v 11.2 1998/06/27 04:29:17 mike Exp $ (BRL)";
@


11.2
log
@Additions to LIBFB interface and remote framebuffer protocol to
read and write monochrome rectangles.
Particularly important for sending thermal images at high speed.
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_sun.c,v 11.1 1995/01/04 09:53:05 mike Rel4_4 $ (BRL)";
d55 5
a59 1
#include "conf.h"
@


11.1
log
@Release_4.4
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_sun.c,v 10.3 94/08/24 19:11:15 gdurf Exp $ (BRL)";
d135 2
@


10.3
log
@Changed select(..., (long *)0, ...) to select(..., (fd_set *)0, ...)
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_sun.c,v 10.2 1994/08/12 20:25:49 gdurf Exp gdurf $ (BRL)";
@


10.2
log
@Added includes
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_sun.c,v 10.1 1991/10/12 06:37:31 mike Rel4_0 gdurf $ (BRL)";
d1563 1
a1563 1
		(void) select(0, (long *)0, (long *)0, (long *)0, &timeout);
@


10.1
log
@Release_4.0
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_sun.c,v 9.4 91/07/26 22:41:14 mike Exp $ (BRL)";
d55 2
d59 1
a60 1
#include <sys/types.h>
d67 2
d71 3
a73 3
extern char	*calloc(), *malloc();
extern int	errno;
extern char	*shmat();
@


9.4
log
@Added if_magic field, and FB_CK_FBIO() macro, to allow checking
FBIO pointers
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_sun.c,v 9.3 90/12/11 22:49:32 phil Exp $ (BRL)";
@


9.3
log
@if_ struct changes.  See fb.h.  Function name cleanups.
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_sun.c,v 9.2 89/09/01 02:56:00 phil Exp $ (BRL)";
d116 1
d895 2
@


9.2
log
@fb_flush and fb_free.
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: if_sun.c,v 9.1 89/05/19 05:48:13 phil Locked $ (BRL)";
d96 1
a96 1
 ((x)*SUN(ifp)->su_xzoom-(SUN(ifp)->su_xcenter*SUN(ifp)->su_xzoom-ifp->if_width/2))
d98 13
a110 14
 ((ifp->if_height-1)-((y)*SUN(ifp)->su_yzoom-(SUN(ifp)->su_ycenter*SUN(ifp)->su_yzoom - ifp->if_height/2)))
_LOCAL_ int	sun_dopen(),
		sun_dclose(),
		sun_dclear(),
		sun_bread(),
		sun_bwrite(),
		sun_cmread(),
		sun_cmwrite(),
		sun_viewport_set(),
		sun_window_set(),
		sun_zoom_set(),
		sun_curs_set(),
		sun_cmemory_addr(),
		sun_cscreen_addr(),
d116 12
a127 14
		sun_dopen,
		sun_dclose,
		fb_null,	/* reset? */
		sun_dclear,
		sun_bread,
		sun_bwrite,
		sun_cmread,
		sun_cmwrite,
		sun_viewport_set,
		sun_window_set,
		sun_zoom_set,
		sun_curs_set,
		sun_cmemory_addr,
		sun_cscreen_addr,
d130 1
d140 1
d142 3
a173 4
	short	su_xzoom;
	short	su_yzoom;
	short	su_xcenter;
	short	su_ycenter;
d624 1
a624 1
	register int	xzoom = SUN(ifp)->su_xzoom;
d633 1
a633 1
		int		yzoom = SUN(ifp)->su_yzoom;
d695 1
a695 1
			(xrgt-xlft+1)*xzoom, SUN(ifp)->su_yzoom,
d732 2
a733 2
		SUN(ifp)->su_xzoom, SUN(ifp)->su_yzoom,
		SUN(ifp)->su_xcenter, SUN(ifp)->su_ycenter ); /* XXX-debug */
d736 1
a736 1
	xwidth = ifp->if_width/SUN(ifp)->su_xzoom;
d738 5
a742 5
	xmin = SUN(ifp)->su_xcenter - i;
	xmax = SUN(ifp)->su_xcenter + i - 1;
	i = (ifp->if_height/2)/SUN(ifp)->su_yzoom;
	ymin = SUN(ifp)->su_ycenter - i;
	ymax = SUN(ifp)->su_ycenter + i - 1;
d744 1
a744 1
		xscroff = -xmin * SUN(ifp)->su_xzoom;
d748 1
a748 1
		yscroff = -ymin * SUN(ifp)->su_yzoom;
d752 1
a752 1
		xscrpad = (xmax-(ifp->if_width-1))*SUN(ifp)->su_xzoom;
d756 1
a756 1
		yscrpad = (ymax-(ifp->if_height-1))*SUN(ifp)->su_yzoom;
d851 1
a851 1
		sun_cmwrite( ifp, COLORMAP_NULL );
d880 1
a880 1
 *			S U N _ D O P E N 
d883 1
a883 1
sun_dopen(ifp, file, width, height)
d950 1
a950 1
		fb_log( "sun_dopen, already open\n" );
d954 1
a954 1
		fb_log( "sun_dopen:  suninfo calloc failed\n" );
d962 1
a962 1
		fb_log("sun_dopen: pf_open %s failure\n", WHICH_FONT);
d984 1
a984 1
			fb_log("sun_dopen: window_create frame failure\n");
d992 1
a992 1
			fb_log("sun_dopen: window_create canvas failure\n");
d1033 1
a1033 1
			fb_log("sun_dopen: pr_open /dev/fb failure\n");
d1042 1
a1042 1
			fb_log("sun_dopen: pr_region failure\n");
d1089 4
a1092 4
	SUN(ifp)->su_xzoom = 1;
	SUN(ifp)->su_yzoom = 1;
	SUN(ifp)->su_xcenter = width/2;
	SUN(ifp)->su_ycenter = height/2;
d1108 1
a1108 1
 *			S U N _ D C L O S E 
d1111 1
a1111 1
sun_dclose(ifp)
d1118 1
a1118 1
		fb_log( "sun_dclose: frame buffer not open.\n" );
d1149 1
a1149 1
			fb_log("sun_dclose shmdt failed, errno=%d\n", errno);
d1162 11
d1222 1
a1222 1
 *			S U N _ D C L E A R 
d1225 1
a1225 1
sun_dclear(ifp, pp)
d1241 1
a1241 1
 *			S U N _ W I N D O W _ S E T 
d1244 1
a1244 1
sun_window_set(ifp, xcenter, ycenter)
d1247 1
d1250 2
a1251 1
	if( SUN(ifp)->su_xcenter == xcenter && SUN(ifp)->su_ycenter == ycenter )
a1256 19
	SUN(ifp)->su_xcenter = xcenter;
	SUN(ifp)->su_ycenter = ycenter;

	/* Redraw 24-bit image from memory. */
	sun_repaint(ifp);
	return	0;
}

/*
 *			S U N _ Z O O M _ S E T 
 */
_LOCAL_ int
sun_zoom_set(ifp, xzoom, yzoom)
FBIO	*ifp;
int	xzoom, yzoom;
{
	/*fb_log( "sun_zoom_set(0x%x,%d,%d)\n", ifp, xzoom, yzoom );*/
	if( SUN(ifp)->su_xzoom == xzoom && SUN(ifp)->su_yzoom == yzoom )
		return	0;
a1258 2
	SUN(ifp)->su_xzoom = xzoom;
	SUN(ifp)->su_yzoom = yzoom;
d1260 5
d1266 1
a1266 1
	sun_repaint( ifp );
d1271 1
a1271 1
 *			S U N _ C U R S _ S E T
d1274 1
a1274 1
sun_curs_set(ifp, bits, xbits, ybits, xorig, yorig )
d1305 1
a1305 1
 *			S U N _ C M E M O R Y _ A D D R
d1308 1
a1308 1
sun_cmemory_addr( ifp, mode, x, y )
d1316 2
d1325 1
a1325 1
	xwidth = ifp->if_width/SUN(ifp)->su_xzoom;
d1327 3
a1329 3
	xmin = SUN(ifp)->su_xcenter - i;
	i = (ifp->if_height/2)/SUN(ifp)->su_yzoom;
	ymin = SUN(ifp)->su_ycenter - i;
d1332 2
a1333 2
	x *= SUN(ifp)->su_xzoom;
	y *= SUN(ifp)->su_yzoom;
d1350 1
a1350 1
 *			S U N _ C S C R E E N _ A D D R
d1353 1
a1353 1
sun_cscreen_addr( ifp, mode, x, y )
d1355 2
a1356 2
int	mode;
int	x, y;
d1358 1
a1358 19
	if( ! sun_pixwin )
		return	0; /* No cursor outside of suntools yet. */
	SUN(ifp)->su_curs_on = mode;
	if( ! mode ) {
		/* XXX turn off cursor. */
		return	0;
	}
	y = ifp->if_height - y;
	/* Move cursor/mouse to <x,y>. */	
	if(	x < 1 || x > ifp->if_width
	    ||	y < 1 || y > ifp->if_height
		)
		return	-1;
	/* Translate address from window to tile space. */
	x += BORDER;
	y += BORDER*2 + BANNER;
	SUN(ifp)->su_xcursor = x;
	SUN(ifp)->su_ycursor = y;
	win_setmouseposition( ifp->if_windowfd, x, y );
d1363 1
a1363 1
 *			S U N _ B R E A D 
d1366 1
a1366 1
sun_bread(ifp, x, y, p, count)
d1386 1
a1386 1
 *			S U N _ B W R I T E
d1389 1
a1389 1
sun_bwrite(ifp, x, y, p, count)
d1398 1
a1398 1
	/*fb_log( "sun_bwrite(0x%x,%d,%d,0x%x,%d)\n", ifp, x, y, p, count );
d1405 1
a1405 1
	xwidth = ifp->if_width/SUN(ifp)->su_xzoom;
d1413 1
a1413 1
 *			S U N _ V I E W P O R T _ S E T 
d1416 1
a1416 11
sun_viewport_set( ifp )
FBIO	*ifp;
{
	return	0;
}

/*
 *			S U N _ C M R E A D 
 */
_LOCAL_ int
sun_cmread( ifp, cmp )
d1454 1
a1454 1
 *			S U N _ C M W R I T E 
d1457 1
a1457 1
sun_cmwrite(ifp, cmp)
@


9.1
log
@Release_3.5
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: if_sun.c,v 8.18 89/05/15 23:46:37 phil Exp $ (BRL)";
a71 2
extern int	fb_sim_readrect(), fb_sim_writerect();

d112 1
d133 2
d1154 49
@


8.18
log
@Woops.  I missed the initialization of shmid to -1.
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: if_sun.c,v 8.17 89/05/11 00:33:43 phil Locked $ (BRL)";
@


8.17
log
@The current dithering code has serious problems if XMAXWIDOW is not
a multiple of 8.  I bumped it back to 640 until someone could look
at this.  Also note that subimages in shared memory needs work.
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: if_sun.c,v 8.16 89/05/04 03:56:39 phil Locked $ (BRL)";
d959 1
d1147 1
a1147 1
	if( SUN(ifp)->su_shmid != -1 ) {
@


8.16
log
@free private memory or release shared memory segment on close
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: if_sun.c,v 8.15 89/04/29 05:59:34 phil Locked $ (BRL)";
d83 1
a83 1
#define XMAXWINDOW	646	/* Max. width of frame buffer in pixels. */
@


8.15
log
@made modeflags static since it appears in more than one module
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: if_sun.c,v 8.14 89/04/24 17:22:34 phil Locked $ (BRL)";
d1144 11
@


8.14
log
@Added 'd' flag for support of color dithering.  Dithering off by default for
performance reasons.  Also tightened up code to parse option flags.
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: if_sun.c,v 8.13 89/04/03 19:46:32 butler Locked $ (BRL)";
d433 1
a433 1
struct modeflags {
@


8.13
log
@Made default width/height remain 512 while maxwidth is 646.
Removed excessive indentation of sun_interface
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: if_sun.c,v 8.12 89/03/09 01:31:26 phil Locked $ (BRL)";
d221 1
a221 3
static int	dither_flg = FALSE;   /* dither output */

/* dither pattern (threshold level) */
a232 19
#define NDITHER   8
#define LNDITHER  3
#define EXTERN extern

unsigned char   red8Amat[NDITHER][NDITHER];	/* red dither matrix */
unsigned char   grn8Amat[NDITHER][NDITHER];	/* green matrix */
unsigned char   blu8Amat[NDITHER][NDITHER];	/* blue  matrix */

typedef unsigned char uchar;

#ifdef DIT
EXTERN struct pixrect *redscr;	/* red screen */
EXTERN struct pixrect *grnscr;	/* green screen */
EXTERN struct pixrect *bluscr;	/* blue screen */
#endif

unsigned char   red8Amap[256];	/* red 8bit dither color map */
unsigned char   grn8Amap[256];	/* green 8bit dither color map */
unsigned char   blu8Amap[256];	/* blue 8bit dither color map */
a244 4
 *	Sun wants the first entry in the colormap to be white (all 255)
 *	and the last entry to be black (all 0).  In order to maintain some
 *	compatibility here, we store our colorcube and "extras" backwards
 *	from what makes sense so that our map is compatible with Sun's
a253 1
/*	238, 221, 187, 170, 136, 119, 85, 68, 34, 17 */
d257 3
a259 1
/* indicies of the primary colors and grey values in the color map */
a260 2
/* 215, 225, 224, 214, 223, 222, 213, 221, 
   220, 212, 219, 218, 211, 217, 216, 210 */
a263 2
/* 215, 235, 234, 209, 233, 232, 203, 231,
   230, 197, 229, 228, 191, 227, 226, 185 */
a266 2
/* 215, 245, 244, 179, 243, 242, 143, 241,
   240, 107, 239, 238, 71, 237, 236, 35 */
a269 2
/* 215, 255, 254, 172, 253, 252, 129, 251,
   250, 86, 249, 248, 43, 247, 246, 0 */
d273 9
d283 37
d326 1
a326 1
_LOCAL_ unsigned char convRGB(v)
d340 1
a340 1
		if (r == 0)  {
d344 1
d354 1
a354 1
	return r + g * 6 + b * 36;
d363 2
a364 2
void genmap(redmap, grnmap, blumap)
unsigned char redmap[], grnmap[], blumap[];
d372 3
a374 3
				redmap[r + g * 6 + b * 36] = cubevec[r];
				grnmap[r + g * 6 + b * 36] = cubevec[g];
				blumap[r + g * 6 + b * 36] = cubevec[b];
d379 2
a380 2
		redmap[r] = primary[r-216];	/* red */
		grnmap[r] = blumap[r] = 0;
d384 2
a385 2
		grnmap[g] = primary[g-226];	/* green */
		redmap[g] = blumap[g] = 0;
d389 2
a390 2
		blumap[b] = primary[b-236];	/* blue */
		redmap[b] = grnmap[b] = 0;
d394 2
a395 2
		redmap[r] = grnmap[r] = 
		blumap[r] = primary[r-246];
a401 5

#ifdef DIT
static int      biggest = RR * GR * BR - 1;
#endif

d415 1
d425 4
d443 2
d676 6
a681 1

d687 1
a687 1
			/* Get color map value for pixel. */
d689 2
a690 1
			value = convRGB(v);
d891 1
a891 1
	int		x, r, g, b;
a905 3
		char	modebuf[80];
		char	*mp;
		int	alpha;
d913 14
a926 9
			/* Parse the options */
			alpha = 0;
			mp = &modebuf[0];
			cp = &file[8];
			while( *cp != '\0' && !isspace(*cp) ) {
				*mp++ = *cp;	/* copy it to buffer */
				if( isdigit(*cp) ) {
					cp++;
					continue;
a927 11
				alpha++;
				for( mfp = modeflags; mfp->c != '\0'; mfp++ ) {
					if( mfp->c == *cp ) {
						mode = (mode&~mfp->mask)|mfp->value;
						break;
					}
				}
				if( mfp->c == '\0' && *cp != '-' ) {
					fb_log( "if_sun: unknown option '%c' ignored\n", *cp );
				}
				cp++;
a928 3
			*mp = '\0';
			if( !alpha )
				mode = atoi( modebuf );
d938 1
a938 1
		mode &= (MODE_1MASK | MODE_2MASK);
d1020 4
a1023 13
			if( dither_flg ) {
#ifdef DIT
				draw8Ainit();
				dither8Ainit();
				pw_set8Amap(imagepw, &sun_cmap);
#endif DIT
			}
			else {
				/* set a new cms name; initialize it */
				x = pw_setcmsname(imagepw, "libfb");
				x = pw_putcolormap(imagepw, 0, 256, 
						redmap, grnmap, blumap);
			}
a1453 197

/* --------------------------------------------------------------- */

#ifdef DIT
/*
 * draw8Abit.c 
 *
 * By: David H. Elrod;  Sun Microsystems; September 1986 
 *
 * Draw a pixel in 8 bit color space using a color cube that is 6values red, 
 * 7values green and 6values blue. 
 *
 * External Variables Used: redscr, grnscr, bluscr	- red, green and blue
 * pixrects red8Amap, grn8Amap, blue8Amap	- software color map 
 *
 * Bugs: 
 *
 */

draw8Abit(x, y, r, g, b)
	int             x, y;	/* pixel location */
	unsigned char   r, g, b;/* red, green, blue pixel values */
{
	int             red, green, blue;	/* return values */
	int             v;	/* 8 bit value */

	v = biggest - (((((r * (RR)) >> 8) * GR) + ((g * (GR)) >> 8)) * BR
		       + ((b * (BR)) >> 8));

	/* deal with 24 bit frame buffer */
	red = pr_put(redscr, x, y, red8Amap[v]);
	green = pr_put(grnscr, x, y, grn8Amap[v]);
	blue = pr_put(bluscr, x, y, blu8Amap[v]);

	if ((red == PIX_ERR) || (green == PIX_ERR) || (blue == PIX_ERR))
		return (PIX_ERR);
	return (0);
}

draw8Ainit()
{
	int             i, r, g, b;	/* loop counters */

	/* ordered dither matrix (6 reds, 7 greens and 6 blues) */
	i = 0;
	for (r = 0; r < RR; r++)
		for (g = 0; g < GR; g++)
			for (b = 0; b < BR; b++) {
				red8Amap[i] = 255 - (r * 255 / (RR - 1));
				grn8Amap[i] = 255 - (g * 255 / (GR - 1));
				blu8Amap[i] = 255 - (b * 255 / (BR - 1));
				i++;
			}
}


/*
 * pw_dither8Abit.c 
 *
 * Modified:	Bill Lindemann;	Sun Microsystems; September 1986 From
 * original by: David H. Elrod;  Sun Microsystems; September 1986 
 *
 * Display a pixel using an ordered dither algoritm to approximate the 24 bit
 * rgb value supplied.  Convert this value to an 8 bit system, and display in
 * the given pixwin.  Assume the colormap is already set. 
 *
 * External Variables Used: red8Amat, grn8Amat, blu8Amat	- dither matricies; 
 *
 * Bugs: 
 *
 */

pw_dither8Abit(pw, x, y, r, g, b)
	Pixwin         *pw;
	int             x, y;	/* pixel location */
	unsigned char   r, g, b;/* red, green, blue pixel values */
{
	int             red, green, blue;	/* return values */
	int             v;	/* 8 bit value */

	v = biggest - ((dit8A(r, red8Amat, RR - 1, x, y) * GR +
			dit8A(g, grn8Amat, GR - 1, x, y)) * BR +
		       dit8A(b, blu8Amat, BR - 1, x, y));

	pw_put(pw, x, y, v);

	if ((red == PIX_ERR) || (green == PIX_ERR) || (blue == PIX_ERR))
		return (PIX_ERR);
	return (0);
}

get_dither8Abit(x, y, r, g, b)
	int             x, y;	/* pixel location */
	unsigned char   r, g, b;/* red, green, blue pixel values */
{
	int             v;	/* 8 bit value */

	v = biggest - ((dit8A(r, red8Amat, RR - 1, x, y) * GR +
			dit8A(g, grn8Amat, GR - 1, x, y)) * BR +
		       dit8A(b, blu8Amat, BR - 1, x, y));

	return (v);
}

pw_set8Amap(pw, cmap)
	Pixwin         *pw;
	colormap_t     *cmap;
{
	pw_setcmsname(pw, "dith8Amap");
	pw_putcolormap(pw, 0, biggest + 1, red8Amap, grn8Amap, blu8Amap);
	if (cmap != (colormap_t *) 0) {
		cmap->type = RMT_EQUAL_RGB;
		cmap->length = biggest + 1;
		cmap->map[0] = red8Amap;
		cmap->map[1] = grn8Amap;
		cmap->map[2] = blu8Amap;
	}
}

pw_dither8Abit_rop(ifp, pr_red, pr_grn, pr_blu, size)
	FBIO		*ifp;
	Pixrect        *pr_red, *pr_grn, *pr_blu;
	int             size;
{
	register unsigned char *redP, *grnP, *bluP, *compP;
	register int    x, y;
	Pixrect        *pr_comp;
	struct mpr_data *mpr_red, *mpr_grn, *mpr_blu, *mpr_comp;
	unsigned char  *red_base, *grn_base, *blu_base, *comp_base;

	pr_comp = mem_create(size, size, 8);
	if (pr_comp == (Pixrect *) 0) {
		(void) printf(stderr, "mem_create failed\n");
		exit(1);
	}
	mpr_red = mpr_d(pr_red);
	mpr_grn = mpr_d(pr_grn);
	mpr_blu = mpr_d(pr_blu);
	mpr_comp = mpr_d(pr_comp);
	red_base = (unsigned char *) mpr_red->md_image;
	grn_base = (unsigned char *) mpr_grn->md_image;
	blu_base = (unsigned char *) mpr_blu->md_image;
	comp_base = (unsigned char *) mpr_comp->md_image;

	for (y = size; --y >= 0;) {
		redP = red_base + (y * mpr_red->md_linebytes);
		grnP = grn_base + (y * mpr_grn->md_linebytes);
		bluP = blu_base + (y * mpr_blu->md_linebytes);
		compP = comp_base + (y * mpr_comp->md_linebytes);
		for (x = 0; x < size; x++) {
			*compP++ = biggest - ((dit8A(*redP++, red8Amat, RR - 1, x, y) * GR +
			      dit8A(*grnP++, grn8Amat, GR - 1, x, y)) * BR +
				    dit8A(*bluP++, blu8Amat, BR - 1, x, y));
		}
	}
	sunrop( 0, 0, size, size, PIX_SRC, pr_comp, 0, 0 );
	pr_destroy(pr_comp);
}

pw_24dither8Abit_rop(ifp, pr_24, size)
	FBIO		*ifp;
	Pixrect        *pr_24;
	int             size;
{
	register unsigned char *pr24P, *compP;
	register int    red, grn, blu;
	register int    x, y;
	Pixrect        *pr_comp;
	struct mpr_data *mpr_24, *mpr_comp;
	unsigned char  *pr24_base, *comp_base;

	pr_comp = mem_create(size, size, 8);
	if (pr_comp == (Pixrect *) 0) {
		(void) printf(stderr, "mem_create failed\n");
		exit(1);
	}
	mpr_24 = mpr_d(pr_24);
	mpr_comp = mpr_d(pr_comp);
	pr24_base = (unsigned char *) mpr_24->md_image;
	comp_base = (unsigned char *) mpr_comp->md_image;

	for (y = size; --y >= 0;) {
		pr24P = pr24_base + (y * mpr_24->md_linebytes);
		compP = comp_base + (y * mpr_comp->md_linebytes);
		for (x = 0; x < size; x++) {
			red = *pr24P++;
			grn = *pr24P++;
			blu = *pr24P++;
			*compP++ = biggest - ((dit8A(red, red8Amat, RR - 1, x, y) * GR +
				  dit8A(grn, grn8Amat, GR - 1, x, y)) * BR +
					dit8A(blu, blu8Amat, BR - 1, x, y));
		}
	}
	sunrop( 0, 0, size, size, PIX_SRC, pr_comp, 0, 0 );
	pr_destroy(pr_comp);
}
#endif DIT
@


8.12
log
@Added some extra checking of Sun library routine return values,
to prevent unexpected core dumping.
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: if_sun.c,v 8.11 89/03/09 01:19:59 mike Locked $ (BRL)";
d117 33
a149 33
FBIO            sun_interface = {
				 sun_dopen,
				 sun_dclose,
				 fb_null,	/* reset? */
				 sun_dclear,
				 sun_bread,
				 sun_bwrite,
				 sun_cmread,
				 sun_cmwrite,
				 sun_viewport_set,
				 sun_window_set,
				 sun_zoom_set,
				 sun_curs_set,
				 sun_cmemory_addr,
				 sun_cscreen_addr,
				fb_sim_readrect,
				fb_sim_writerect,
				 sun_help,
				 "SUN SunView or raw Pixwin",
				 XMAXWINDOW,	/* max width */
				 YMAXWINDOW,	/* max height */
				 "/dev/sun",
				 XMAXWINDOW,	/* current/default width  */
				 YMAXWINDOW,	/* current/default height */
				 -1,	/* file descriptor */
				 PIXEL_NULL,	/* page_base */
				 PIXEL_NULL,	/* page_curp */
				 PIXEL_NULL,	/* page_endp */
				 -1,	/* page_no */
				 0,	/* page_ref */
				 0L,	/* page_curpos */
				 0L,	/* page_pixels */
				 0	/* debug */
d157 1
a157 1
 * because of signal routines the need to find it.
@


8.11
log
@Latest version from Lee Butler.
Re-installs Sun's default color map on fb_close,
except when LINGER mode is set.
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: if_sun.c,v 8.10 89/03/06 21:46:40 mike Exp $ (BRL)";
d948 6
a953 1
	myfont = pf_open( "/usr/lib/fonts/fixedwidthfonts/screen.b.14" );
d972 4
d980 4
d1026 2
a1027 2
		static Pixrect	*screenpr = NULL;
		static Pixrect	*windowpr;
d1029 1
d1031 2
a1032 6
			screenpr = pr_open( "/dev/fb" );
			windowpr = pr_region(	screenpr,
					XMAXSCREEN-width-BORDER*2,
					YMAXSCREEN-(height+BANNER+BORDER*3),
					width+BORDER*2, height+BANNER+BORDER*3
					);
d1034 10
d1077 1
d1079 6
a1084 1
	pf_close( myfont );
a1101 6
	if( (SUN(ifp)->su_depth != 1) && (SUN(ifp)->su_depth != 8) ) {
		fb_log( "if_sun: Can only handle 1bit and 8bit deep displays (not %d)\n",
			SUN(ifp)->su_depth );
		return	-1;
	}

d1103 1
a1103 1
	}
@


8.10
log
@Fixed "optimization".  This one works.
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: if_sun.c,v 8.9 89/03/03 06:15:03 mike Locked $ (BRL)";
d83 1
a83 1
#define XMAXWINDOW	512	/* Max. width of frame buffer in pixels. */
d279 2
a280 1
	238, 221, 187, 170, 136, 119, 85, 68, 34, 17
d285 3
a287 1
215, 225, 224, 214, 223, 222, 213, 221, 220, 212, 219, 218, 211, 217, 216, 210
d290 3
a292 1
215, 235, 234, 209, 233, 232, 203, 231, 230, 197, 229, 228, 191, 227, 226, 185
d295 3
a297 1
215, 245, 244, 179, 243, 242, 143, 241, 240, 107, 239, 238, 71, 237, 236, 35
d300 3
a302 1
215, 255, 254, 172, 253, 252, 129, 251, 250, 86, 249, 248, 43, 247, 246, 0
d339 1
a339 1
	return 215 - (r + g * 6 + b * 36);
d357 3
a359 3
				redmap[215 - (r + g * 6 + b * 36)] = cubevec[r];
				grnmap[215 - (r + g * 6 + b * 36)] = cubevec[g];
				blumap[215 - (r + g * 6 + b * 36)] = cubevec[b];
d1092 3
d1111 10
@


8.9
log
@Minor improvement to the logic
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: if_sun.c,v 8.8 89/03/03 06:05:19 mike Locked $ (BRL)";
d322 2
a323 1
	else if (g == b && g == 0)	/* all red */
d325 3
a327 2
		
	else if (r == b && r == 0)	/* all green */
d329 2
a330 3

	else				/* color cube val */
		return 215 - (r + g * 6 + b * 36);
@


8.8
log
@New color cube from Lee Butler
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: if_sun.c,v 8.7 89/03/03 05:54:49 mike Exp $ (BRL)";
d312 10
a321 3
	if ( r == g & r == b ) /* all grey, take average */
		return greyvec[( ((*v)[RED]+(*v)[GRN]+(*v)[BLU]) / 3 ) /16];
		
d327 1
a327 4
		
	else if (r == g && r == 0)	/* all blue */
		return bluvec[((*v)[BLU])/16];
		
@


8.7
log
@Added support for fb_readrect() and fb_writerect().
@
text
@d43 1
d52 1
a52 1
static char RCSid[] = "@@(#)$Header: if_sun.c,v 8.6 88/12/09 00:00:08 mike Locked $ (BRL)";
d215 1
a215 2
struct sun_cmap
	{
d219 1
a219 1
	};
d224 2
a225 3
static short	dither[MAXDITHERSZ][MAXDITHERSZ] =
	{
	6,  51,  14,  78,   8,  57,  16,  86,
d227 1
a227 1
	18,  96,  10,  63,  20, 106,  12,  70,
d229 1
a229 1
	9,  60,  17,  91,   7,  54,  15,  82,
d231 1
a231 1
	21, 112,  13,  74,  19, 101,  11,  66,
d233 1
a233 1
	};
d254 17
a270 1

d274 2
a275 3
#define RR	6
#define GR	7
#define BR	6
d277 97
a377 5
#define COLOR_APPROX(p) \
	(((p)[RED] * RR ) / 256) * GR*BR + \
	(((p)[GRN] * GR ) / 256) * BR  + \
	(((p)[BLU] * BR ) / 256) + 1

d421 1
a421 1
	{
d424 1
a424 1
	}
d428 1
a428 1
	{
d432 1
a432 2
	if( sun_damaged )
		{
d437 1
a437 1
		}
d440 1
a440 1
	}
d449 2
a450 1
	{	register RGBpixel	*memp;
d457 1
a457 1
		COPYRGB( *memp, *p );
d460 1
a460 1
	}
d491 8
a498 9
/* These lock routines are unused.  They do not seem to provide any speedup when
bracketing raster op routines.  This may pan out differently when other processes
are actively competing for raster ops. */
_LOCAL_ void
sun_lock( ifp )
FBIO	*ifp;
	{
	if( sun_pixwin )
		{ /* Lock the display and get the cursor out of the way. */
d500 1
a500 1
		}
d502 1
a502 1
	}
d507 3
a509 3
	{
	if( sun_pixwin )
		{ /* Release display lock and restore cursor. */
d511 1
a511 1
		}
d513 1
a513 1
	}
d528 4
a531 3
	{	static int		lastvalue = 0;
		register int		value;
		RGBpixel		v;
d537 2
a538 2
 	if( SUN(ifp)->su_depth == 1 )
		{ /* Construct dither pattern in memory pixrect. */
d540 1
a540 2
		if( value == 0 )
			{
d545 3
a547 3
			}
		if( value != lastvalue )
			{	register int	i, j;
d557 1
a557 1
			}
a560 9
		}
	else
		{ /* Grey-scale or color image. */
		pixel_mpr_buf[0] = COLOR_APPROX(v);
		sunreplrop( xlft, ytop, width, height,
			PIX_SRC, &pixel_mpr, 0, 0
			);
		}
	return;
d562 3
d566 6
d640 2
a641 1
	} else {
d647 1
a647 2
			register int	dx;
			register int	value;
d650 1
d653 1
a653 1
			value = COLOR_APPROX(v);
d674 3
a676 2
	{	register int		y;
		register RGBpixel	*p;
d683 1
a683 1
	}
d688 7
a694 6
	{	register int	i;
		register int	ymin, ymax;
		int		xmin, xmax;
		int		xwidth;
		int		xscroff, yscroff;
		int		xscrpad, yscrpad;
d707 1
a707 2
	if( xmin < 0 )
		{
d710 2
a711 3
		}
	if( ymin < 0 )
		{
d714 2
a715 3
		}
	if( xmax > ifp->if_width-1 )
		{
d718 2
a719 3
		}
	if( ymax > ifp->if_height-1 )
		{
d722 1
a722 1
		}
d744 1
a744 1
	}
d826 4
a829 4
	{ 	int	shmid;
		int	i;
	if( (shmid = shmget( SHMEM_KEY, 0, 0 )) < 0 )
		{
d832 1
a832 1
		}
d835 1
a835 2
	if( i < 0 )
		{
d838 1
a838 1
		}
d841 1
a841 1
	}
a842 30
#ifdef SUN_USE_AGENT
_LOCAL_ Notify_value
event_func( client, event, arg, when )
Notify_client		client;
Event			*event;
Notify_arg		arg;
Notify_event_type	when;
	{
	fb_log( "event_func(%s)\n", client );
	switch( event_id( event ) )
		{
	case WIN_REPAINT :
		sun_repair( win_get_pixwin( client ) );
		break;
	default :
		break;
		}
	return	NOTIFY_DONE;
	}

_LOCAL_ Notify_value
destroy_func( client, status )
Notify_client	client;
Destroy_status	status;
	{
	fb_log( "destroy_func(%s)\n", client );
	return	NOTIFY_DONE;
	}
#endif

d851 7
a857 6
	{	char		sun_parentwinname[WIN_NAMESIZE];
		Rect		winrect;
		int		x;
		struct pr_prpos	where;
		struct pixfont	*myfont;
		int	mode;
d877 2
a878 1
		} else {
d925 1
a925 2
	if( SUN(ifp) != (struct suninfo *) NULL )
		{
d928 2
a929 3
		}
	if( (SUNL(ifp) = calloc( 1, sizeof(struct suninfo) )) == NULL )
		{
d932 1
a932 1
		}
a939 1
	 * r | g | b, values = RR, GR, BR
a940 5
	for (x = 0; x < (RR * GR * BR); x++) {
		blumap[x + 1] = ((x % BR)) * 255 / (BR - 1);
		grnmap[x + 1] = (((x / BR) % GR)) * 255 / (GR - 1);
		redmap[x + 1] = ((x / (BR * GR))) * 255 / (RR - 1);
	}
d942 2
d981 2
a982 4
		if( SUN(ifp)->su_depth == 8 )
			{
			if( dither_flg )
				{
d988 2
a989 3
				}
			else
				{
d992 2
a993 20
				/*
				 * set first (background) and last (foreground)
				 * entries the same so suntools will fill them
				 * in for us.
				 */
				redmap[0] = redmap[255] = 0;
				grnmap[0] = grnmap[255] = 0;
				blumap[0] = blumap[255] = 0;
				x = pw_putcolormap(imagepw, 0, 256, redmap, grnmap, blumap);
				x = pw_getcolormap(imagepw, 0, 256, redmap, grnmap, blumap);
				/*
				 * save the filled in foreground color in
				 * last-1 since this is where the usual
				 * monochrome colormap segment lives.
				 */
				redmap[254] = redmap[0];
				grnmap[254] = grnmap[0];
				blumap[254] = blumap[0];
				x = pw_putcolormap(imagepw, 0, 256, redmap, grnmap, blumap);
				}
d995 3
a997 14
#ifdef SHOULDNOTNEEDTHIS
		(void) signal( SIGWINCH, sun_sigwinch );
		(void) signal( SIGALRM, sun_sigalarm );
		alarm( TIMEOUT );
#endif
#ifdef SUN_USE_AGENT
		/* Register pixwin with Agent so it can manage repaints. */
		win_register(	(Notify_client) ifp->if_type,
				SUNPW(ifp),
				event_func, destroy_func,
				PW_RETAIN | PW_REPAINT_ALL
				);
#endif SUN_USE_AGENT
	} else {
d1002 1
a1002 2
		if( screenpr == (Pixrect *) NULL )
			{
d1009 1
a1009 1
			}
d1039 2
a1040 2
			pr_putcolormap(windowpr, 1, 253,
				&redmap[1], &grnmap[1], &blumap[1] );
a1087 3
#ifdef SUN_USE_AGENT
		win_unregister( ifp->if_type );
#endif
d1092 2
a1093 1
	} else {
d1108 1
a1108 1
	{
d1118 1
a1118 1
	}
d1127 1
a1127 1
	{
d1141 1
a1141 1
	}
d1150 1
a1150 1
	{
d1162 1
a1162 1
	}
d1173 5
a1177 4
	{	register int	xbytes;
		register int	y;
		Cursor		newcursor;
	/* Check size of cursor.					*/
d1189 1
a1189 2
	for( y = 0; y < ybits; y++ )
		{
d1193 1
a1193 1
		}
d1196 1
a1196 1
	}
d1206 4
a1209 3
	{	short	xmin, ymin;
		register short	i;
		short	xwidth;
d1213 1
a1213 2
	if( ! mode )
		{
d1216 1
a1216 1
		}
d1239 1
a1239 1
	}
d1249 1
a1249 1
	{
d1253 1
a1253 2
	if( ! mode )
		{
d1256 1
a1256 1
		}
d1270 1
a1270 1
	}
d1281 3
a1283 1
	{	register RGBpixel	*memp;
d1290 1
a1290 1
		COPYRGB( *p, *memp );
d1293 1
a1293 1
	}
d1304 4
a1307 2
	{	int		xmax, ymax;
		register int	xwidth;
d1320 1
a1320 1
	}
d1328 1
a1328 1
	{
d1330 1
a1330 1
	}
d1339 3
a1341 1
	{	register int i;
d1350 1
a1350 1
	}
d1362 2
a1363 1
	{ 	register int i;
d1371 1
a1371 1
	}
d1380 4
a1383 5
	{	register int i;
	if( cmp == COLORMAP_NULL )
		{
		for( i = 0; i < 256; i++)
			{
d1387 2
a1388 3
			}
		if( SUN(ifp)->su_cmap_flag )
			{
d1391 1
a1391 1
			}
d1394 1
a1394 1
		}
d1396 1
a1396 2
	for( i = 0; i < 256; i++ )
		{
d1400 1
a1400 1
		}
d1404 1
a1404 1
	}
a1442 1
#endif DIT
d1460 1
d1476 1
a1476 1
#ifdef DIT
@


8.6
log
@a couple of efficiency enhancements
a little code neatening (a prelude to more efficiency work)
@
text
@d51 1
a51 1
static char RCSid[] = "@@(#)$Header: if_sun.c,v 8.5 88/12/04 15:09:33 phil Locked $ (BRL)";
d71 2
d131 2
@


8.5
log
@colormap now works without suntools as well
fixed slight nit in green colormap entry computation (max was 252)
@
text
@d51 1
a51 1
static char RCSid[] = "@@(#)$Header: if_sun.c,v 8.4 88/12/01 17:29:04 phil Locked $ (BRL)";
d151 1
a151 1
 * WARNING: this should be in suninfo but isn't there yet
d333 1
d351 1
d359 17
a375 8
	{	register RGBpixel	*memp;
	for(	memp =	(RGBpixel *)
			(&ifp->if_mem[(y*ifp->if_width+x)*sizeof(RGBpixel)]);
		count > 0;
		memp++, count--
		)
		{
		COPYRGB( *memp, *p );
d377 1
d379 1
a379 1
	}
d472 4
d483 4
a486 3
	{	register int	sy = YIMAGE2SCR( ybtm+1 ) + 1;
		register int	xzoom = SUN(ifp)->su_xzoom;
		int		xl = XIMAGE2SCR( xlft );
d490 6
a495 4
 	if( SUN(ifp)->su_depth == 1 )
		{	register int	x;
			register int	sx = xl;
			int		yzoom = SUN(ifp)->su_yzoom;
d498 5
a502 3
		for( x = xlft; x <= xrgt; x++, sx += xzoom, pp++ )
			{	register int		value;
				RGBpixel		v;
d506 3
a508 2
			if( value != 0 )
				{ register int	maxdy = yzoom < DITHERSZ ?
d510 3
a512 2
				  register int	dy;
				  register int	yoffset = sx;
d515 5
a519 5
				for( dy = 0; dy < maxdy; dy++, yoffset += XMAXWINDOW )
					{ register int dx;
					  register int ydit = DITHMASK(sy+dy);
					for( dx = 0; dx < xzoom; dx++ )
						{ register int xdit =
a522 1
						}
d526 1
d530 11
a540 10
			xl, 0
			);
		}
	else /* Grey-scale or color image. */
		{	register int	x;
			register int	sx = xl;
		for( x = xlft; x <= xrgt; x++, pp++, sx += xzoom )
			{	register int		dx;
				register int		value;
				RGBpixel		v;
d544 1
d547 1
a547 1
			}
d551 2
a552 3
			xl, 0
			);
		}
d554 1
a554 1
	}
d656 6
a661 5
	{	int	pixsize;
		int	size;
		int	new = 0;
		static char	*sp = NULL;
		extern caddr_t	sbrk();
d668 2
a669 2
	if( sp == (char *) NULL ) /* Do once per process. */
		{
d673 6
a678 8
		/* First try to attach to an existing one */
		if( (SUN(ifp)->su_shmid = shmget( SHMEM_KEY, size, 0 )) < 0 )
			{ /* No existing one, create a new one */
			if(	(SUN(ifp)->su_shmid =
				shmget( SHMEM_KEY, size, IPC_CREAT|0666 ))
				< 0 )
				{
				fb_log( "if_sun: shmget failed, errno=%d\n", errno );
a679 1
				}
d681 1
a681 1
			}
d683 1
a683 2
		if( (sp = shmat( SUN(ifp)->su_shmid, 0, 0 )) < 0 )
			{
d686 1
a686 1
			}
d689 2
a690 1
		fb_log("sun_getmem:  Unable to attach to shared memory.\nConsult comment in cad/libfb/if_sun.c for details\n");
d695 1
a695 2
		if( (sp = malloc( size )) == NULL )
			{
d698 1
a698 1
			}
d700 1
a700 1
		}
d705 2
a706 3
	/* Provide non-black colormap on creation of new shared mem */
	if( new )
		{
d709 1
a709 1
		}
d711 1
a711 1
	}
d1270 3
a1272 1
	sun_storepixel( ifp, x, y, p, count );
@


8.4
log
@first pass at real SunWindow support
also fixed colormap related problems for color suns
and fixed this so one binary could serve both B&W and color
@
text
@d51 1
a51 1
static char RCSid[] = "@@(#)$Header: if_sun.c,v 8.3 88/10/23 05:05:12 phil Exp $ (BRL)";
d252 1
d839 12
a899 1
				/* r | g | b, values = RR, GR, BR */
a901 9
				for (x = 0; x < (RR * GR * BR); x++)
					{	RGBpixel        q;
					blumap[x + 1] = ((x % BR)) * (255 / (BR - 1));
					grnmap[x + 1] = (((x / BR) % GR)) * (255 / (GR - 1));
					redmap[x + 1] = ((x / (BR * GR))) * (255 / (RR - 1));
					q[RED] = redmap[x + 1];
					q[GRN] = grnmap[x + 1];
					q[BLU] = blumap[x + 1];
					}
d936 1
a936 3
		}
	else
		{
d978 3
d982 1
@


8.3
log
@is_linear_cmap needed a static declaration before use
@
text
@d8 1
a8 2
 *  and captured, even with the 1-bit deep 3/50 displays.  Be sure to
 *  set the BITSDEEP parameter below under CONFIGURATION NOTES.
d51 1
a51 1
static char RCSid[] = "@@(#)$Header: if_sun.c,v 8.2 88/10/06 03:33:21 phil Locked $ (BRL)";
d61 2
a62 2
#include <pixrect/pixrect_hs.h>
#include <sunwindow/window_hs.h>
d69 1
d73 1
a73 1
	1] If you have 4 Megabytes of memory, best limit the window sizes
a76 3

	2] Change the BITSDEEP parameter below to match your particular
	Sun.
a81 3
#ifndef BITSDEEP
#define BITSDEEP	1	/* No. of bit planes, same as su_depth. */
#endif
d150 7
d162 2
a173 1
	Pixwin	*su_windowpw;	/* f. b. window Pixwin pointer under SUNTOOLS. */
a178 1
#define if_parentfd	u6.l	/* parent window file descriptor under SUNTOOLS */
d246 1
a246 1
#endif DIT
a247 9
EXTERN struct pixrect *redmem;	/* red memory pixrect */
EXTERN struct pixrect *grnmem;	/* grn memory pixrect */
EXTERN struct pixrect *blumem;	/* blu memory pixrect */
EXTERN unsigned char others[256];	/* unused colors */
EXTERN unsigned char redmap8[256];	/* red 8bit color map */
EXTERN unsigned char grnmap8[256];	/* green 8bit color map */
EXTERN unsigned char blumap8[256];	/* blue 8bit color map */

unsigned char   others[256];	/* unused colors */
d258 1
d260 1
a275 3
static Pixwin	*windowpw;
static Pixwin	*imagepw;

d318 1
a318 1
	if( windowpw == (Pixwin *) NULL || imagepw == (Pixwin *) NULL )
a322 1
		pw_damaged( windowpw );
a323 1
		pw_repairretained( windowpw );
a324 1
		pw_donedamaged( windowpw );
d393 3
a395 3
/* Dither pattern pixrect for fast raster ops. */
static char	dither_mpr_buf[8*BITSDEEP];
mpr_static( dither_mpr, DITHERSZ, DITHERSZ, BITSDEEP, (short *)dither_mpr_buf );
d397 1
a397 6
/* Scanline dither pattern pixrect, if DITHERSZ or BITSDEEP > sizeof(char)
	you must extend the length of scan_mpr_buf accordingly. */
static char	scan_mpr_buf[XMAXWINDOW];
mpr_static( scan_mpr, XMAXWINDOW, DITHERSZ, BITSDEEP, (short *)scan_mpr_buf );

/* Straight pixrect for grey-scale and color devices. */
d399 1
a399 1
mpr_static( pixel_mpr, 1, 1, BITSDEEP, (short *)pixel_mpr_buf );
d409 1
d450 9
d469 1
d505 1
a505 1
			PIX_SRC, &scan_mpr,
d524 1
a524 1
			PIX_SRC, &scan_mpr,
d668 3
d839 4
a842 11
        if( sun_pixwin = (we_getgfxwindow(sun_parentwinname) == 0) )
		{	int	parentno;
			int	parentfd;
			Rect	parentrect;
			int	windowfd;
		if( (parentfd = open( sun_parentwinname, 2 )) < 0 )
			{
			fb_log( "sun_dopen, couldn't open parent window.\n" );
			return	-1;	/* FAIL */
			}
		win_getrect( parentfd, &parentrect );
d844 12
a855 21
        	/* Running under SunView, with windows */
		if( (windowfd = win_getnewwindow()) == -1 )
			{
			fb_log("sun_dopen:  win_getnewwindow failed\n");
			return	-1;     /* FAIL */
			}
		winrect.r_left = rect_right(&parentrect) -
				(width+BORDER*2+PARENTBORDER);
		winrect.r_top = rect_bottom(&parentrect) -
				(height+BANNER+BORDER*3+PARENTBORDER+13);
		winrect.r_width = width+BORDER*2;
		winrect.r_height = height+BANNER+BORDER*3;
		win_setrect( windowfd, &winrect );
		parentno = win_nametonumber( sun_parentwinname );
		win_setlink( windowfd, WL_PARENT, parentno );
		win_insert( windowfd );
		windowpw = pw_open(windowfd);
		imagepw = pw_region(	windowpw,
					BORDER, BANNER+BORDER*2,
					width, height
					);
d857 2
d864 1
a864 3
		ifp->if_windowfd = windowfd;
		ifp->if_parentfd = parentfd;
		SUN(ifp)->su_windowpw = windowpw;
d866 9
a874 22
#ifdef SUN_USE_AGENT
		/* Register pixwin with Agent so it can manage repaints. */
		win_register(	(Notify_client) ifp->if_type,
				SUNPW(ifp),
				event_func, destroy_func,
				PW_RETAIN | PW_REPAINT_ALL
				);
#else
		imagepw->pw_prretained = mem_create(	width,
							height,
							SUN(ifp)->su_depth
							);
		windowpw->pw_prretained = mem_create(	winrect.r_width,
							winrect.r_height,
							SUN(ifp)->su_depth
							);
		pw_exposed( imagepw ); /* is this REALLY necessary??? */
		pw_exposed( windowpw ); /* is this REALLY necessary??? */
		(void) signal( SIGWINCH, sun_sigwinch );
		(void) signal( SIGALRM, sun_sigalarm );
		alarm( TIMEOUT );
#endif
a891 2
						RGBpixel       *qq = (RGBpixel *) q;

d899 8
d908 10
d920 13
a932 16
		/* Outer border is black. */
		pw_rop( windowpw, 0, 0,
			winrect.r_width, winrect.r_height,
			PIX_SET, (Pixrect *) NULL, 0, 0 );
		/* Inner border is white. */
		pw_rop( windowpw, 1, 1,
			winrect.r_width-2, winrect.r_height-2,
			PIX_CLR, (Pixrect *) NULL, 0, 0 );
		/* Black out title bar. */
		pw_rop( windowpw, BORDER, BORDER,
			width, BANNER,
			PIX_SET, (Pixrect *) NULL, 0, 0 );
		/* Draw title in title bar (banner). */
		pw_ttext( windowpw, TITLEXOFFSET, BANNER - TITLEYOFFSET,
			  PIX_CLR,
			  myfont, "BRL libfb Frame Buffer" );
d935 5
a939 2
		{	static Pixrect	*screenpr = NULL;
			static Pixrect	*windowpr;
d978 1
d992 4
a995 2
	/* Redraw 24-bit image from memory. */
	sun_repaint( ifp );
d997 6
d1012 2
a1013 3
	{
	if( SUNL(ifp) == (char *) NULL )
		{
d1016 5
d1022 1
a1022 2
	if( sun_pixwin )
		{
d1027 4
a1030 9
		pw_close( SUNPW(ifp) );
		pw_close( SUN(ifp)->su_windowpw );
		win_remove( ifp->if_windowfd );
		(void) close( ifp->if_windowfd );
		(void) close( ifp->if_parentfd );
		windowpw = imagepw = NULL;
		}
	else
		{
d1032 1
a1032 1
		}
d1036 1
a1036 1
	}
d1555 54
@


8.2
log
@gcc showed up a bug where a color was trying to be stored in a local
color pixel pointer, thus dereferencing an uninitialized pointer.
I changed these to a pixel, rather than pixel pointer and changed the
macros SUN_CMAPVAL and COLOR_APPROX to take a pixel as their second
arg (not a pointer).
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: if_sun.c,v 8.1 88/10/05 00:27:47 phil Locked $ (BRL)";
d152 2
@


8.1
log
@Release_3.0
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: if_sun.c,v 7.5 88/09/15 21:48:40 phil Locked $ (BRL)";
d267 3
a269 3
	(((*p)[RED] * RR ) / 256) * GR*BR + \
	(((*p)[GRN] * GR ) / 256) * BR  + \
	(((*p)[BLU] * BR ) / 256) + 1
d274 3
a276 3
		(*o)[RED] = CMR(ifp)[(*p)[RED]];\
		(*o)[GRN] = CMG(ifp)[(*p)[GRN]];\
		(*o)[BLU] = CMB(ifp)[(*p)[BLU]];\
d278 1
a278 1
	else	COPYRGB( *o, *p );
d423 1
a423 1
		register RGBpixel	*vp;
d426 1
a426 1
	SUN_CMAPVAL( pp, vp );
d430 1
a430 1
		value = ((*vp)[RED] + (*vp)[GRN] + (*vp)[BLU]);
d456 1
a456 1
		pixel_mpr_buf[0] = COLOR_APPROX(vp);
d484 1
a484 1
				register RGBpixel	*vp;
d486 2
a487 2
			SUN_CMAPVAL( pp, vp );
			value = (*vp)[RED] + (*vp)[GRN] + (*vp)[BLU];
a517 1
				register RGBpixel	*vp;
d519 1
d521 2
a522 2
			SUN_CMAPVAL( pp, vp );
			value = COLOR_APPROX(vp);
@


7.5
log
@added mode flag letters
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: if_sun.c,v 7.4 88/09/09 23:36:27 phil Locked $ (BRL)";
@


7.4
log
@fbhelp function
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: if_sun.c,v 7.3 88/05/17 12:05:23 phil Locked $ (BRL)";
d136 1
a136 1
				 "SUN Pixwin",
d170 1
d283 32
d648 3
d672 1
d759 42
a800 12
	if( file != NULL )
		{	register char *cp;
			int mode;
		/* "/dev/sun###" gives optional mode */
		for( cp = file; *cp != '\0' && !isdigit(*cp); cp++ ) ;
		mode = 0;
		if( *cp && isdigit(*cp) )
			(void)sscanf( cp, "%d", &mode );
		if( mode >= 99 )
			{ /* Attempt to release shared memory segment */
			sun_zapmem();
			return	-1;
d802 3
d806 11
d836 1
d1546 2
d1556 4
@


7.3
log
@Abandoned run-length encoding of pixels in favor of buffered scanlines
because complicated images were much too slow with the former method.
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: if_sun.c,v 7.2 88/03/22 14:22:44 moss Locked $ (BRL)";
d116 2
a117 1
		sun_cscreen_addr();
d135 1
d1459 16
@


7.2
log
@First pass over Sun 3/50 support.  Improvements include bug fixes to
sun_bwrite (while zooming), and support for the following;  sun_bread,
sun_window_set, sun_zoom_set, sun_cmemory_addr, sun_cscreen_addr,
sun_cmread, sun_cmwrite.  The use of shared memory ala if_sgi.c was
implemented, but the max window size limited to 512x512 as a default
due to only 4 Megs. of memory on typical 3/50s.  This was almost a
total rewrite with the exception of the color Sun support which was
left intact as much as possible.
@
text
@d8 2
a9 1
 *  and captured, even with the 1-bit deep 3/50 displays.
d33 1
a33 1
 *  FIGURATION NOTE below) and increase SHMPOOL appropriately.  If you
d52 1
a52 1
static char RCSid[] = "@@(#)$Header: if_sun.c,v 7.1 87/11/02 23:27:03 mike Rel $ (BRL)";
a66 2

extern char	*sbrk();
a69 1
extern int	brk();
d71 10
a80 4
/* CONFIGURATION NOTE:  If you have 4 Megabytes of memory, best limit the
	window sizes to 512-by-512 (whether or not your using shared memory)
	because a 24-bit image is stored in memory and we don't want our
	systems to thrash do we). */
d85 1
d87 1
d93 4
a96 2
#define RESTXMOUSE	BORDER	/* Out of way position for mouse while */
#define RESTYMOUSE	BORDER	/*	doing pixel writes. */
d98 19
a116 14
_LOCAL_ int 
sun_dopen(),
sun_dclose(),
sun_dclear(),
sun_bread(),
sun_bwrite(),
sun_cmread(),
sun_cmwrite(),
sun_viewport_set(),
sun_window_set(),
sun_zoom_set(),
sun_curs_set(),
sun_cmemory_addr(),
sun_cscreen_addr();
d166 2
d171 2
a172 2
#define if_windowfd	u4.l	/* window file descriptor under SUNTOOLS */
#define if_shmid	u6.l	/* shared memory ID */
d185 6
d201 1
a201 2
static int	sun_redraw = FALSE;  /* Doing a sun_repaint. */
static int	sun_damaged = FALSE; /* SIGWINCH fired, need sun_repair. */
d203 1
a203 1

a212 5
/* One scanline wide buffer */
extern struct pixrectops mem_ops;
char		sun_mpr_buf[1024];
mpr_static( sun_mpr, 1024, 1, BITSDEEP, (short *)sun_mpr_buf );

d214 1
a214 1
static short	dither[8][8] =
d268 12
d287 2
a288 2
sun_repair( pw )
Pixwin	*pw;
d290 15
a304 4
	pw_damaged( pw );
	pw_repairretained( pw );
	pw_donedamaged( pw );
	sun_damaged = FALSE;
d320 1
a320 3
		(*memp)[RED] = (*p)[RED];
		(*memp)[GRN] = (*p)[GRN];
		(*memp)[BLU] = (*p)[BLU];
d338 1
a338 3
		(*memp)[RED] = (*p)[RED];
		(*memp)[GRN] = (*p)[GRN];
		(*memp)[BLU] = (*p)[BLU];
d343 3
d347 172
d521 1
a521 2
	{	register int	y;
		register int	i;
d528 2
a529 1
		SUN(ifp)->su_xzoom, SUN(ifp)->su_yzoom, SUN(ifp)->su_xcenter, SUN(ifp)->su_ycenter );*/
d561 2
a562 6
		sunrop(	0, 0,
			xscroff,
			ifp->if_height,
			PIX_SET,
			(Pixrect *) NULL, 0, 0
			);
d565 3
a567 5
		sunrop(	0, ifp->if_height-yscroff,
			ifp->if_width, yscroff,
			PIX_SET,
			(Pixrect *) NULL, 0, 0
			);
d570 3
a572 5
		sunrop(	ifp->if_width-xscrpad, 0,
			xscrpad, ifp->if_height,
			PIX_SET,
			(Pixrect *) NULL, 0, 0
			);
d575 4
a578 16
		sunrop(	0, 0,
			ifp->if_width, yscrpad,
			PIX_SET,
			(Pixrect *) NULL, 0, 0
			);
	sun_redraw = TRUE;
	for( y = ymin; y <= ymax; y++ )
		if( sun_bwrite(	ifp,
				xmin, y,
				(RGBpixel *)(ifp->if_mem+(y*ifp->if_width+xmin)*sizeof(RGBpixel)),
				xwidth
				)
		     <	xwidth
			)
			fb_log( "sun_repaint: Write of %d pixels to <%d,%d> failed.\n", xwidth, xmin, y );
	sun_redraw = FALSE;
a595 12
 * 
 *  There are a few oddities, however.  The worst is that System V will
 *  not allow the break (see sbrk(2)) to be set above a shared memory
 *  segment, and shmat(2) does not seem to allow the selection of any
 *  reasonable memory address (like 6 Mbytes up) for the shared memory.
 *  In the initial version of this routine, that prevented subsequent
 *  calls to malloc() from succeeding, quite a drawback.  The work-around
 *  used here is to increase the current break to a large value,
 *  attach to the shared memory, and then return the break to it's
 *  original value.  This should allow most reasonable requests for
 *  memory to be satisfied.  In special cases, the values used here
 *  might need to be increased.
d600 1
a600 2
	{
		int	pixsize;
a601 1
		int	i;
d603 2
a604 1
		char	*sp;
a609 1

d611 16
a626 5
	/* First try to attach to an existing one */
	if( (ifp->if_shmid = shmget( SHMEM_KEY, size, 0 )) < 0 )
		{ /* No existing one, create a new one */
		if( (ifp->if_shmid = shmget(
		    SHMEM_KEY, size, IPC_CREAT|0666 )) < 0 )
d628 1
a628 1
			fb_log( "if_sun: shmget failed, errno=%d\n", errno );
d631 8
d641 1
a641 7

	/* Open the segment Read/Write, near the current break */
	if( (sp = shmat( ifp->if_shmid, 0, 0 )) == (char *)(-1) )
		{
		fb_log("shmat returned x%x, errno=%d\n", sp, errno );
		goto fail;
		}
d644 1
a644 1

d647 1
a647 1
		{	static RGBpixel black = { 0, 0, 0 };
a651 9
fail:
	fb_log("sun_getmem:  Unable to attach to shared memory.\nConsult comment in cad/libfb/if_sun.c for details\n");
	if(	ifp->if_mem == (char *) NULL
	    ||	(ifp->if_mem = malloc( size )) == NULL )
		{
		fb_log( "sun_getmem:  malloc failure, couldn't allocate %d bytes\n", size );
		return	-1;
		}
	return	0;
d677 30
a716 1
		int		i;
a752 1

d760 1
a760 2
			int	sun_windowfd;
			Pixwin	*sun_windowpw;
d769 1
a769 1
		if( (sun_windowfd = win_getnewwindow()) == -1 )
d780 1
a780 1
		win_setrect( sun_windowfd, &winrect );
d782 4
a785 5
		win_setlink( sun_windowfd, WL_PARENT, parentno );
		win_insert( sun_windowfd );
		sun_windowpw = pw_open(sun_windowfd);
		SUNPWL(ifp) = (char *)
			pw_region(	sun_windowpw,
d789 1
d795 3
a797 1
		ifp->if_windowfd = sun_windowfd;
d799 22
a820 2
		SUNPW(ifp)->pw_prretained = mem_create( width, height, SUN(ifp)->su_depth );
		sun_mpr.pr_depth = SUN(ifp)->su_depth;
d828 1
a828 1
				pw_set8Amap(SUN(ifp), &sun_cmap);
d835 1
a835 1
				x = pw_setcmsname(SUN(ifp), "libfb");
d837 1
a837 2
					{	int             new;
						RGBpixel        q;
a845 1
					new = COLOR_APPROX(qq);
d847 1
a847 1
				x = pw_putcolormap(SUN(ifp), 0, 256, redmap, grnmap, blumap);
d851 1
a851 1
		pw_rop( sun_windowpw, 0, 0,
d855 1
a855 1
		pw_rop( sun_windowpw, 1, 1,
d859 1
a859 1
		pw_rop( sun_windowpw, BORDER, BORDER,
d863 1
a863 1
		pw_ttext( sun_windowpw, TITLEXOFFSET, BANNER - TITLEYOFFSET,
d868 3
a870 3
		{	static Pixrect	*myscreen = NULL;
			static Pixrect	*mywindow;
		if( myscreen == (Pixrect *) NULL )
d872 2
a873 2
			myscreen = pr_open( "/dev/fb" );
			mywindow = pr_region(	myscreen,
d880 1
a880 1
			pr_region(	mywindow,
d885 1
a885 1
		pr_rop( mywindow, 0, 0,
d890 1
a890 1
		pr_rop( mywindow, 1, 1,
d895 1
a895 1
		pr_rop( mywindow, BORDER, BORDER,
d900 1
a900 1
		where.pr = mywindow;
d921 3
a923 1
	(void) signal( SIGWINCH, sun_sigwinch );
d934 1
a934 1
	if( SUNL(ifp) == (struct suninfo *) NULL )
d941 4
d946 1
d948 3
d969 2
a970 2
	if( sun_damaged )
		sun_repair( SUNPW(ifp) );
d972 1
d974 3
a976 1
	sun_repaint( ifp );
a988 2
	if( sun_damaged )
		sun_repair( SUNPW(ifp) );
a1011 2
	if( sun_damaged )
		sun_repair( SUNPW(ifp) );
d1033 2
a1034 2
	{	register int	y;
		register int	xbytes;
a1142 2
	if( sun_damaged )
		sun_repair( SUNPW(ifp) );
d1149 1
a1149 3
		(*p)[RED] = (*memp)[RED];
		(*p)[GRN] = (*memp)[GRN];
		(*p)[BLU] = (*memp)[BLU];
a1153 16
_LOCAL_ RGBpixel *
sun_cmapval( ifp, p )
register FBIO		*ifp;
register RGBpixel	*p;
	{	static RGBpixel	cmval;
	if( SUN(ifp)->su_cmap_flag )
		{
		cmval[RED] = CMR(ifp)[(*p)[RED]];
		cmval[GRN] = CMG(ifp)[(*p)[GRN]];
		cmval[BLU] = CMB(ifp)[(*p)[BLU]];
		return	(RGBpixel *) cmval;
		}
	else
		return	p;
	}

d1159 8
a1166 23
register FBIO		*ifp;
int			x, y;
register RGBpixel	*p;
register int		count;
	{	register	scrx, scry;
		register	value;
		register	i, j;
		register	cnt;
		register	cury;
		RGBpixel	*base = p;
	/*fb_log( "sun_bwrite(0x%x,%d,%d,0x%x,%d)\n", ifp, x, y, p, count );*/
	if( sun_damaged )
		sun_repair( SUNPW(ifp) );
	scrx =	(x*SUN(ifp)->su_xzoom -
		(SUN(ifp)->su_xcenter*SUN(ifp)->su_xzoom - ifp->if_width/2));
	scry =	(ifp->if_height-1) -
		(y*SUN(ifp)->su_yzoom -
		(SUN(ifp)->su_ycenter*SUN(ifp)->su_yzoom - ifp->if_height/2));
	if( scrx < 0 || scrx >= ifp->if_width )
		return	0;
	if( scry < 0 || scry >= ifp->if_height )
		return	0;

d1168 1
a1168 2
	if( ! sun_redraw )
		sun_storepixel( ifp, x, y, p, count );
d1170 4
a1173 97
	if( sun_pixwin )
		{ /* Lock the display and get the cursor out of the way. */
		pw_lock( SUNPW(ifp), SUNPW(ifp)->pw_pixrect );
		win_setmouseposition(	ifp->if_windowfd,
					RESTXMOUSE,
					RESTYMOUSE
					);
		}

	/* Take care of single-pixel case. */
	if( count == 1 )
		{	register RGBpixel *vp = sun_cmapval( ifp, p );
		if( SUN(ifp)->su_depth < 8 )
			value = ((*vp)[RED] + (*vp)[GRN] + (*vp)[BLU]);
		else
			value = COLOR_APPROX(vp);
		for(	i = 0, cury = scry;
			i < SUN(ifp)->su_yzoom && cury > 0;
			i++, cury-- )
			{	register curx;
			for(	j = 0, curx = scrx+j;
				j < SUN(ifp)->su_xzoom
			     &&	curx < ifp->if_width;
				j++, curx++ )
				{	register int	val;
				/* 0 gives white, 1 gives black */
				val = (value < dither[curx&07][cury&07]*3);
				sunput( curx, cury, val );
				}
			}
		if( sun_pixwin )
			{ /* Release display lock and restore cursor. */
			pw_unlock( SUNPW(ifp) );
			win_setmouseposition(	ifp->if_windowfd,
						SUN(ifp)->su_xcursor,
						SUN(ifp)->su_ycursor
						);
			}
		return	count;
		}

	/* Multiple pixels. */
	bzero( sun_mpr_buf, ifp->if_width * SUN(ifp)->su_depth / sizeof(char) );

	/* Need to write out each scanline YZOOM times. */
	for(	i = 0, cury = scry;
		i < SUN(ifp)->su_yzoom
	    &&	cury >= 0
	    &&	cury < ifp->if_height;
		i++, cury--, p = base )
		{	register int	curx;
		curx = 0;
		for( cnt = 0; cnt < count; cnt++, p++ )
			{	register RGBpixel *vp = sun_cmapval( ifp, p );
			/* Write pixel to memory pixrect. */
			if( SUN(ifp)->su_depth < 8 )
				{ /* Must build pixel from dither pattern,
					whose dimensions are based on the
					zoom factors. */
				value = ((*vp)[RED] + (*vp)[GRN] + (*vp)[BLU]);
				for( j = 0; j < SUN(ifp)->su_xzoom; j++ )
					{
					if( SUN(ifp)->su_depth < 8 )
						{ /* 0 gives white, 1 gives black */
						if( value < dither[curx+j&07][cury&07]*3 )
							sun_mpr_buf[curx+j>>3] |= (0x80>>(curx+j&07));
						}
					}
				}
			else
				{
				value = COLOR_APPROX(vp);
				for( j = 0; j < SUN(ifp)->su_xzoom; j++ )
					sun_mpr_buf[curx+j] = value;
				}
			curx += SUN(ifp)->su_xzoom;
	
			/* Output full scan-line. */
			if (curx >= ifp->if_width)
				{
				sunrop( scrx, cury,
					ifp->if_width, 1,
					PIX_SRC, &sun_mpr, 0, 0	);
				bzero( (char *) sun_mpr_buf,
					ifp->if_width * SUN(ifp)->su_depth
					/ sizeof(char) );
				}
			} /* all pixels done */
		}
	if( sun_pixwin )
		{ /* Release display lock and restore cursor. */
		pw_unlock( SUNPW(ifp) );
		win_setmouseposition(	ifp->if_windowfd,
					SUN(ifp)->su_xcursor,
					SUN(ifp)->su_ycursor
					);
		}
a1183 2
	if( sun_damaged )
		sun_repair( SUNPW(ifp) );
a1194 3
	if( sun_damaged )
		sun_repair( SUNPW(ifp) );

a1232 3
	if( sun_damaged )
		sun_repair( SUNPW(ifp) );

@


7.1
log
@Release 2.3
@
text
@d2 1
a2 1
 *		I F _ S U N . C 
d4 5
d10 28
d42 1
d51 1
a51 1
static char RCSid[] = "@@(#)$Header: if_sun.c,v 6.1 87/07/11 07:51:48 mike Rel $ (BRL)";
d55 1
d59 2
d67 23
d101 2
d118 3
a120 3
				 fb_null,	/* sun_curs_set, */
				 fb_null,	/* sun_cmemory_addr */
				 fb_null,	/* cscreen_addr */
d122 2
a123 2
				 1152,	/* max width */
				 896,	/* max height */
d125 2
a126 2
				 1152,	/* current/default width  */
				 896,	/* current/default height */
d138 25
a162 5
#define	SUNPW(ptr)	((Pixwin *)((ptr)->u1.p))
#define if_xzoom	u2.l
#define if_yzoom	u3.l
#define if_depth	u4.l	/* # bits/pixel */
#define if_rheight	u5.l	/* height of master_rect.r_height */
d164 5
a168 2
int             sun_damaged;	/* window has incurred damage */
int             dither_flg = 0;	/* dither output */
d170 23
d196 1
a196 1
mpr_static( sun_mpr, 1024, 1, 16, (short *)sun_mpr_buf );
d200 1
a200 1
{
d209 1
a209 1
};
a234 5
EXTERN int      fb_type;	/* 8 = 8 bit, 24 = 24 bit */
EXTERN struct pixfont *myfont;	/* font to label with */

EXTERN int      zbuf;		/* 1 = yes, 0 = no */
EXTERN int      antialias;	/* 1 = yes, 0 = no */
d240 2
a245 2
static unsigned char redmap[256], grnmap[256], blumap[256];

d253 6
a258 4
sun_sigwinch()
{
	sun_damaged = 1;
}
d260 7
a266 8
sun_repair(ifp)
register FBIO *ifp;
{
	if (sun_damaged) {
		pw_damaged(SUNPW(ifp));
		pw_repairretained(SUNPW(ifp));
		pw_donedamaged(SUNPW(ifp));
		sun_damaged = 0;
a267 1
}
d269 124
d394 105
d503 23
a525 10
	FBIO           *ifp;
	char           *file;
	int             width, height;
{
	int             sun_win_fd;
	char            gfxwinname[128];	/* Name of window to use */
	Rect            master_rect;
	int             i;
	int             x;

d535 4
a538 12
	if (SUNPW(ifp) != (Pixwin *) 0) {
		fb_log("sun_open, already open\n");
		return(-1);	/* FAIL */
	}

        if( we_getgfxwindow(gfxwinname) == 0 )  {
        	int	gfxfd;
                        
		/* Running under SunView, with windows */
		if( (sun_win_fd = win_getnewwindow()) < 0 )  {
			fb_log("sun_dopen:  win_getnewwindow failed\n");
			return(-1);     /* FAIL */
d540 5
d546 1
a546 5
		/* The blanket window covers current GFX window */
	       	gfxfd = open(gfxwinname, 2);
        	win_insertblanket(sun_win_fd, gfxfd);
        } else {
		struct screen sun_screen;
d548 13
a560 11
		/* Create root window on raw screen */
		bzero( (char *)&sun_screen, sizeof(sun_screen) );
		strcpy( sun_screen.scr_kbdname, "NONE" );
		strcpy( sun_screen.scr_msname, "NONE" );
		if( (sun_win_fd = win_screennew( &sun_screen )) < 0 )  {
			fb_log("sun_open:  Unable to attach to SunView or raw screen\n");
			return(-1);			/* FAIL */
		}
	}
	ifp->u1.p = (char *)pw_open(sun_win_fd);	/* set SUNPW() */
	win_getsize(sun_win_fd, &master_rect);
d562 26
a587 4
	if( width > master_rect.r_width )
		width = master_rect.r_width;
	if( height > master_rect.r_height )
		height = master_rect.r_height;
d589 8
a596 8
	ifp->if_rheight = master_rect.r_height;
	ifp->if_depth = SUNPW(ifp)->pw_pixrect->pr_depth;
	SUNPW(ifp)->pw_prretained = mem_create(width, height, ifp->if_depth);
	sun_mpr.pr_depth = ifp->if_depth;
	if( ifp->if_depth < 8 )  {
		;
	} else {
		if (dither_flg) {
d598 3
a600 3
			draw8Ainit();
			dither8Ainit();
			pw_set8Amap(SUNPW(ifp), &sun_cmap);
d602 10
a611 8
		} else {
			/* r | g | b, values = RR, GR, BR */
			/* set a new cms name; initialize it */
			x = pw_setcmsname(SUNPW(ifp), "libfb");
			for (x = 0; x < (RR * GR * BR); x++) {
				int             new;
				RGBpixel        q;
				RGBpixel       *qq = (RGBpixel *) q;
d613 10
a622 7
				blumap[x + 1] = ((x % BR)) * (255 / (BR - 1));
				grnmap[x + 1] = (((x / BR) % GR)) * (255 / (GR - 1));
				redmap[x + 1] = ((x / (BR * GR))) * (255 / (RR - 1));
				q[RED] = redmap[x + 1];
				q[GRN] = grnmap[x + 1];
				q[BLU] = blumap[x + 1];
				new = COLOR_APPROX(qq);
d624 16
a639 1
			x = pw_putcolormap(SUNPW(ifp), 0, 256, redmap, grnmap, blumap);
d641 42
a682 1
	}
d685 5
a689 2
	ifp->if_xzoom = 1;
	ifp->if_yzoom = 1;
d691 3
a693 4
	/* Set entire area to background color */
	/* SUN reserves [0] for white (background), [1] for black (fg) */
	pw_rop(SUNPW(ifp), 0, 0, master_rect.r_width, master_rect.r_height,
	       PIX_SRC | PIX_COLOR(1), (Pixrect *) 0, 0, 0);
d695 3
a697 3
	signal(SIGWINCH, sun_sigwinch);
	return (0);		/* "Success" */
}
d700 1
a700 1
 * S U N _ D C L O S E 
d704 20
a723 5
	FBIO           *ifp;
{
	char            ch;
	Pixrect        *pr_out;
	FILE           *ofp;
a724 5
	sun_repair(ifp);
	pw_close(SUNPW(ifp));
	SUNPW(ifp) = (Pixwin *) 0;
}

d726 1
a726 1
 * S U N _ D C L E A R 
d730 5
a734 5
	FBIO           *ifp;
	register RGBpixel *pp;
{
	sun_repair(ifp);
}
d736 5
d742 1
a742 1
 * S U N _ W I N D O W _ S E T 
d745 15
a759 6
sun_window_set(ifp, x, y)
	FBIO           *ifp;
	int             x, y;
{
	sun_repair(ifp);
}
d761 5
d767 1
a767 1
 * S U N _ Z O O M _ S E T 
d770 13
a782 8
sun_zoom_set(ifp, xpts, ypts)
	FBIO           *ifp;
	int             xpts, ypts;
{
	sun_repair(ifp);
	ifp->if_xzoom = xpts;
	ifp->if_yzoom = ypts;
}
d784 5
d790 109
d903 19
a921 7
	FBIO           *ifp;
	int             x, y;
	register RGBpixel *p;
	int             count;
{
	return(count);
}
d923 16
d944 22
a965 10
	FBIO           *ifp;
	int             x, y;
	register RGBpixel *p;
	int             count;
{
	register int    cx, cy;
	register int    value;
	register int	i;
	register int    cnt;
	int		needflush = 0;
d967 3
a969 12
	if (sun_damaged) {
		pw_damaged(SUNPW(ifp));
		pw_repairretained(SUNPW(ifp));
		pw_donedamaged(SUNPW(ifp));
		sun_damaged = 0;
	}
	cx = x;
	cy = ifp->if_rheight - 1 - y;
	if (cx < 0 || cx >= ifp->if_width)
		return(0);
	if (cy < 0 || cy >= ifp->if_rheight)
		return(0);
d971 7
a977 11
	if( count == 1 )  {
		if( ifp->if_depth < 8 )  {
			/* 0 gives white, 1 gives black */
			value = ((*p)[RED] + (*p)[GRN] + (*p)[BLU]);
			if( value < dither[(cx&07)][cy&07]*3 )
				pw_put( SUNPW(ifp), cx, cy, 1 );
			else
				pw_put( SUNPW(ifp), cx, cy, 0 );
		} else {
			value = COLOR_APPROX(p);
			pw_put( SUNPW(ifp), cx, cy, value );
a978 3
		return(1);
	}
	/* This code has problems if only part of a line is being written */
d980 16
a995 6
	bzero( sun_mpr_buf, ifp->if_width * ifp->if_depth / sizeof(char) );
	pw_lock( SUNPW(ifp), SUNPW(ifp)->pw_pixrect );
	for (cnt = count; --cnt >= 0; p++) {
		for( i=ifp->if_xzoom; i-- > 0; cx++)  {
			if( ifp->if_depth < 8 )  {
				register short xxx;
d997 3
a999 6
				value = ((*p)[RED] + (*p)[GRN] + (*p)[BLU]);
				if( value < dither[xxx=(cx&07)][cy&07]*3 )
					sun_mpr_buf[cx>>3] |= 0x80 >> xxx;
			} else {
				value = COLOR_APPROX(p);
				sun_mpr_buf[cx] = value;
d1001 7
a1007 8
		}
		needflush = 1;
		if (cx >= ifp->if_width) {
			for( i=ifp->if_yzoom; i-- > 0; cy-- )  {
				pw_rop( SUNPW(ifp), x, cy,
					cx-x, 1,
					PIX_SRC, &sun_mpr, x, 0 );
				x = cx = 0;
d1009 1
a1009 2
			bzero( sun_mpr_buf, ifp->if_width * ifp->if_depth / sizeof(char) );
			needflush = 0;
a1010 12
	}
	if(needflush)  {
		for( i=ifp->if_yzoom; i-- > 0; cy-- )  {
			pw_rop( SUNPW(ifp), x, cy,
				cx-x, 1,
				PIX_SRC, &sun_mpr, x, 0 );
			x = cx = 0;
		}
	}
	pw_unlock( SUNPW(ifp) );
	return(count);
}
d1012 2
a1013 10
#ifdef never
sun_put(pw, vx, vy, p)
	Pixwin         *pw;
	int             vx, vy;
	register RGBpixel *p;
{
	int             cx, cy;
	int             fx, fy;	/* framebuffer x,y */
	int             xcnt, ycnt;
	int             value;
d1015 44
a1058 11
	fx = vx * ifp->if_xzoom;
	fy = vy * ifp->if_yzoom;
	if (dither_flg) {
#ifdef DIT
		for (ycnt = ifp->if_yzoom; --ycnt >= 0;) {
			for (xcnt = ifp->if_xzoom; --xcnt >= 0;) {
				cx = fx + xcnt;
				cy = fy + ycnt;
				value = get_dither8Abit(cx, cy, (*p)[RED], (*p)[GRN], (*p)[BLU]);
				pw_put(pw, cx, cy, value);
			}
d1060 9
a1068 8
#endif DIT
	} else {
		value = ((((((*p)[RED] * (RR)) >> 8) * GR) +
			  (((*p)[GRN] * (GR)) >> 8)) * BR
			 + (((*p)[BLU] * (BR)) >> 8));
		/**	value = ((*p)[RED] + (*p)[GRN] + (*p)[BLU]) / 3; **/
		pw_rop(pw, fx, fy, ifp->if_xzoom, ifp->if_yzoom,
		       PIX_SRC | PIX_COLOR(value), (Pixrect *) 0, 0, 0);
a1069 2
}
#endif never
d1072 1
a1072 1
 * S U N _ V I E W P O R T _ S E T 
d1075 7
a1081 3
sun_viewport_set()
{
}
d1084 1
a1084 1
 * S U N _ C M R E A D 
d1087 6
a1092 3
sun_cmread()
{
}
d1094 10
d1105 5
a1109 1
 * S U N _ C M W R I T E 
d1111 16
d1129 5
a1133 5
	register FBIO  *ifp;
	register ColorMap *cmp;
{
	sun_repair(ifp);
}
d1135 28
d1281 2
a1282 2
pw_dither8Abit_rop(pw, pr_red, pr_grn, pr_blu, size)
	Pixwin         *pw;
d1317 1
a1317 1
	pw_rop(pw, 0, 0, size, size, PIX_SRC, pr_comp, 0, 0);
d1321 2
a1322 2
pw_24dither8Abit_rop(pw, pr_24, size)
	Pixwin         *pw;
d1355 1
a1355 1
	pw_rop(pw, 0, 0, size, size, PIX_SRC, pr_comp, 0, 0);
@


6.1
log
@Release 2.0
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_sun.c,v 5.1 87/06/24 21:51:57 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_sun.c,v 1.4 87/04/30 05:56:31 mike Exp $ (BRL)";
@


1.4
log
@Fix for single pixel output.
Moved most global variables into FBIO structure.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: bw-impress.c,v 4.2 87/02/13 00:37:16 mike Exp $ (BRL)";
@


1.3
log
@Added 8x8 dither for monochrome displays.
Added ability to operate on screens not running suntools.
@
text
@d63 2
a64 2
				 512,	/* current/default width  */
				 512,	/* current/default height */
d76 5
a81 4
Pixwin		*sun_pw;
int             sun_win_fd;
int             sun_xzoom = 1;
int             sun_yzoom = 1;
a83 2
Rect            master_rect;
int		sun_depth;
d155 2
a156 1
sun_repair()
d159 3
a161 3
		pw_damaged(sun_pw);
		pw_repairretained(sun_pw);
		pw_donedamaged(sun_pw);
d175 1
d177 1
d190 1
a190 1
	if (sun_pw != (Pixwin *) 0) {
d195 3
a197 3
	if( we_getgfxwindow(gfxwinname) == 0 )  {
		int             gfxfd;

d200 2
a201 2
			fb_log("sun_dopen:  win_getnewwindow returned %d\n", sun_win_fd);
			return(-1);	/* FAIL */
d203 1
a203 1
		
d205 3
a207 3
		gfxfd = open(gfxwinname, 2);
		win_insertblanket(sun_win_fd, gfxfd);
	} else {
a208 1
		Pixrect *screen_pr;
d215 2
a216 2
			fb_log("sun_dopen: win_screennew returned %d\n", sun_win_fd);
			return(-1);	/* FAIL */
d219 1
a219 1
	sun_pw = pw_open(sun_win_fd);
d227 6
a232 5
	sun_depth = sun_pw->pw_pixrect->pr_depth;
	sun_pw->pw_prretained = mem_create(width, height, sun_depth);
	sun_mpr.pr_depth = sun_depth;
	if( sun_depth < 8 )  {
/**		pr_whiteonblack( sun_pw->pw_pixrect, 0, 1 );**/
d238 1
a238 1
			pw_set8Amap(sun_pw, &sun_cmap);
d243 1
a243 2
			x = pw_setcmsname(sun_pw, "libfb");
			fb_log("setcmsname ret %d\n", x);
d257 1
a257 2
			x = pw_putcolormap(sun_pw, 0, 256, redmap, grnmap, blumap);
			fb_log("colormap ret %d\n", x);
d260 4
d267 1
a267 1
	pw_rop(sun_pw, 0, 0, master_rect.r_width, master_rect.r_height,
d285 3
a287 3
	sun_repair();
	pw_close(sun_pw);
	sun_pw = (Pixwin *) 0;
d298 1
a298 1
	sun_repair();
d309 1
a309 1
	sun_repair();
d320 3
a322 3
	sun_repair();
	sun_xzoom = xpts;
	sun_yzoom = ypts;
d354 6
a359 1
	sun_repair();
d361 5
a365 3
	cy = master_rect.r_height - 1 - y;
	if (cy < 0 || cy >= master_rect.r_height)
		return;
d368 1
a368 1
		if( sun_depth < 8 )  {
d372 3
a374 1
				pw_put( sun_pw, cx, cy, 1 );
d377 1
a377 1
			pw_put( sun_pw, cx, cy, value );
d383 2
a384 2
	bzero( sun_mpr_buf, ifp->if_width * sun_depth / sizeof(char) );
	pw_lock( sun_pw, sun_pw->pw_pixrect );
d386 2
a387 2
		for( i=sun_xzoom; i-- > 0; cx++)  {
			if( sun_depth < 8 )  {
d400 2
a401 2
			for( i=sun_yzoom; i-- > 0; cy-- )  {
				pw_rop( sun_pw, x, cy,
d406 1
a406 1
			bzero( sun_mpr_buf, ifp->if_width * sun_depth / sizeof(char) );
d411 2
a412 2
		for( i=sun_yzoom; i-- > 0; cy-- )  {
			pw_rop( sun_pw, x, cy,
d418 1
a418 1
	pw_unlock( sun_pw );
d422 1
d433 2
a434 2
	fx = vx * sun_xzoom;
	fy = vy * sun_yzoom;
d437 2
a438 2
		for (ycnt = sun_yzoom; --ycnt >= 0;) {
			for (xcnt = sun_xzoom; --xcnt >= 0;) {
d451 1
a451 1
		pw_rop(pw, fx, fy, sun_xzoom, sun_yzoom,
d455 1
d481 1
a481 1
	sun_repair();
@


1.2
log
@This version has rudimentary monochrome capability.
The previous color capability has not been re-tested.
@
text
@d2 1
a2 1
 * I F _ S U N . C 
a3 1
 * Based on original code from Bill Lindemann of SUN. 
d5 10
d16 4
d77 1
a77 2
Pixwin         *sun_pw, *sun_master_pw;
Rect            sun_rect;
a82 1
int             batch_flg;
d91 13
d167 1
a167 1
 * S U N _ D O P E N 
d175 1
a177 2
	int             gfxfd;
	char            gfxwinname[128];
d189 2
a190 3
		fprintf(stderr, "sun_open, already open\n");
		/**	fbclose(); */
		sun_pw = 0;
d192 27
a218 5
	sun_win_fd = win_getnewwindow();
	we_getgfxwindow(gfxwinname);
	gfxfd = open(gfxwinname, 2);
	win_insertblanket(sun_win_fd, gfxfd);
	sun_master_pw = pw_open(sun_win_fd);
d220 6
a225 2
	sun_rect = master_rect;
	sun_pw = sun_master_pw;
d230 1
a230 1
		pr_whiteonblack( sun_pw->pw_pixrect, 0, 1 );
d264 1
a264 1
	       PIX_SRC | PIX_COLOR(0), (Pixrect *) 0, 0, 0);
d317 2
a318 7
	if (batch_flg) {
		sun_xzoom = 1;
		sun_yzoom = 1;
	} else {
		sun_xzoom = xpts;
		sun_yzoom = ypts;
	}
a320 2
extern Pixwin  *sun_pw;

d322 1
a322 1
 * S U N _ B R E A D 
d325 5
a329 1
sun_bread()
d331 1
d335 1
a335 1
 * S U N _ B W R I T E 
d348 1
d356 14
d375 2
d378 2
a379 2
				if( value > 3*100 )
					sun_mpr_buf[cx>>3] |= 0x80 >> (cx&07);
d385 1
a385 5
#ifdef never
		pw_rop(sun_pw, cx, cy, sun_xzoom, sun_yzoom,
			PIX_SRC | PIX_COLOR(value), (Pixrect *) 0, 0, 0);
#endif

d389 1
a389 1
					ifp->if_width, 1,
d394 1
d397 1
a397 1
	if (cx >= ifp->if_width) {
d400 2
a401 2
				ifp->if_width, 1,
				PIX_SRC, &sun_mpr, 0, 0 );
d406 1
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 *			I F _ S U N . C
d4 1
a4 1
 *  Based on original code from Bill Lindemann of SUN.
d17 12
a28 11
_LOCAL_ int	sun_dopen(),
		sun_dclose(),
		sun_dclear(),
		sun_bread(),
		sun_bwrite(),
		sun_cmread(),
		sun_cmwrite(),
		sun_viewport_set(),
		sun_window_set(),
		sun_zoom_set(),
		sun_cscreen_addr();
d31 30
a60 30
FBIO sun_interface =  {
		sun_dopen,
		sun_dclose,
		fb_null,		/* reset? */
		sun_dclear,
		sun_bread,
		sun_bwrite,
		sun_cmread,
		sun_cmwrite,
		sun_viewport_set,
		sun_window_set,
		sun_zoom_set,
		fb_null,		/* sun_curs_set, */
		fb_null,		/* sun_cmemory_addr */
		fb_null,		/* cscreen_addr */
		"SUN Pixwin",
		1152,			/* max width */
		896,			/* max height */
		"/dev/sun",
		512,			/* current/default width  */
		512,			/* current/default height */
		-1,			/* file descriptor */
		PIXEL_NULL,		/* page_base */
		PIXEL_NULL,		/* page_curp */
		PIXEL_NULL,		/* page_endp */
		-1,			/* page_no */
		0,			/* page_ref */
		0L,			/* page_curpos */
		0L,			/* page_pixels */
		0			/* debug */
d67 3
a69 3
int             sun_xzoom=1;
int		sun_yzoom=1;
int             sun_damaged;		/* window has incurred damage */
d73 1
d75 5
d84 3
a86 3
unsigned char red8Amat[NDITHER][NDITHER];	/* red dither matrix */
unsigned char grn8Amat[NDITHER][NDITHER];	/* green matrix */
unsigned char blu8Amat[NDITHER][NDITHER];	/* blue  matrix */
d91 3
a93 3
EXTERN struct pixrect *redscr;		/* red screen */
EXTERN struct pixrect *grnscr;		/* green screen */
EXTERN struct pixrect *bluscr;		/* blue screen */
d96 3
a98 3
EXTERN struct pixrect *redmem;		/* red memory pixrect */
EXTERN struct pixrect *grnmem;		/* grn memory pixrect */
EXTERN struct pixrect *blumem;		/* blu memory pixrect */
d104 2
a105 2
EXTERN int fb_type;			/* 8 = 8 bit, 24 = 24 bit */
EXTERN struct pixfont *myfont;		/* font to label with */
d107 6
a112 6
EXTERN int zbuf;			/* 1 = yes, 0 = no */
EXTERN int antialias;			/* 1 = yes, 0 = no */
unsigned char others[256];	/* unused colors */
unsigned char red8Amap[256];	/* red 8bit dither color map */
unsigned char grn8Amap[256];	/* green 8bit dither color map */
unsigned char blu8Amap[256];	/* blue 8bit dither color map */
d118 1
a118 1
static unsigned char   redmap[256], grnmap[256], blumap[256];
d120 1
a120 1
static int biggest = RR*GR*BR-1;
d129 1
a129 1
    sun_damaged = 1;
d134 6
a139 7
    if (sun_damaged)
    {
	pw_damaged(sun_pw);
	pw_repairretained(sun_pw);
	pw_donedamaged(sun_pw);
	sun_damaged = 0;
    }
d143 1
a143 1
 *			S U N _ D O P E N
d146 4
a149 4
sun_dopen( ifp, file, width, height )
FBIO	*ifp;
char	*file;
int	width, height;
d151 4
a154 4
	int	i;
    int             x;
    int             gfxfd;
    char            gfxwinname[128];
d156 8
a163 6
    if (sun_pw != (Pixwin *) 0)
    {
	fprintf(stderr,"sun_open, already open\n");
/**	fbclose(); */
	sun_pw = 0;
    }
d165 20
a184 12
    sun_win_fd = win_getnewwindow();
    we_getgfxwindow(gfxwinname);
    gfxfd = open(gfxwinname, 2);
    win_insertblanket(sun_win_fd, gfxfd);
    sun_master_pw = pw_open(sun_win_fd);
    win_getsize(sun_win_fd, &master_rect);
    sun_rect = master_rect;
    sun_pw = sun_master_pw;
    sun_pw->pw_prretained = mem_create(512, 512, 8);

    if (dither_flg)
    {
d186 3
a188 3
	draw8Ainit();
	dither8Ainit();
	pw_set8Amap(sun_pw, &sun_cmap);
d190 9
a198 12
    }
    else
    {
	/* r | g | b, values = RR, GR, BR */
	/* set a new cms name; initialize it */
	x = pw_setcmsname(sun_pw, "libfb");
	fb_log("setcmsname ret %d\n", x);
	for (x = 0; x < (RR*GR*BR); x++)
	{
		int new;
		RGBpixel q;
		RGBpixel *qq = (RGBpixel *)q;
d200 10
a209 23
		blumap[x+1] = ((x % BR) ) * (255/(BR-1));
		grnmap[x+1] = (((x / BR) % GR)) * (255/(GR-1));
		redmap[x+1] = ((x / (BR*GR))) * (255/(RR-1));
		q[RED] = redmap[x+1];
		q[GRN] = grnmap[x+1];
		q[BLU] = blumap[x+1];
		new = COLOR_APPROX( qq );
#ifdef never
/**		if( new != x+1 )**/
fb_log(" %3d  %3d, %3d %3d %3d\n", x, new, q[RED], q[GRN], q[BLU] );
#endif
	}
	x = pw_putcolormap(sun_pw, 0, 256, redmap, grnmap, blumap);
	fb_log("colormap ret %d\n", x);
    }
#ifdef never
	{
		static unsigned char   redmp[256], grnmp[256], blump[256];
		pw_getcolormap(sun_pw, 0, 256, redmp, grnmp, blump);
		for( x=0; x< (RR*GR*BR); x++ )  {
fb_log("%3d %3d %3d =? %3d %3d %3d\n",
redmp[x], grnmp[x], blump[x],
redmap[x], grnmap[x], blumap[x] );
d212 3
a214 3
#endif
	/* Set entire area to background color (black) */
	/* SUN reserves [0] for white, [1] for black ?? */
d216 1
a216 1
		PIX_SRC | PIX_COLOR(0), (Pixrect *) 0, 0, 0);
d219 1
a219 1
	return (0);			/* "Success" */
d223 1
a223 1
 *			S U N _ D C L O S E
d226 2
a227 2
sun_dclose( ifp )
FBIO	*ifp;
d229 3
a231 3
    char            ch;
    Pixrect        *pr_out;
    FILE           *ofp;
d233 3
a235 3
    sun_repair();
    pw_close(sun_pw);
    sun_pw = (Pixwin *) 0;
d239 1
a239 1
 *			S U N _ D C L E A R
d242 3
a244 3
sun_dclear( ifp, pp )
FBIO	*ifp;
register RGBpixel	*pp;
d246 1
a246 1
    sun_repair();
d250 1
a250 1
 *			S U N _ W I N D O W _ S E T
d253 3
a255 3
sun_window_set( ifp, x, y )
FBIO	*ifp;
int	x, y;
d257 1
a257 1
    sun_repair();
d261 1
a261 1
 *			S U N _ Z O O M _ S E T
d264 3
a266 3
sun_zoom_set( ifp, xpts, ypts)
FBIO	*ifp;
int	xpts, ypts;
d268 8
a275 11
    sun_repair();
    if (batch_flg)
    {
	sun_xzoom = 1;
	sun_yzoom = 1;
    }
    else
    {
	sun_xzoom = xpts;
	sun_yzoom = ypts;
    }
d281 1
a281 1
 *			S U N _ B R E A D
d289 1
a289 1
 *			S U N _ B W R I T E
d292 5
a296 5
sun_bwrite( ifp, x, y, p, count)
FBIO	*ifp;
int	x, y;
register RGBpixel *p;
int	count;
d298 4
a301 3
    register int    cnt;
    register int    cx, cy;
    register int	value;
d303 19
a321 6
    sun_repair();
    cx = x;
    cy = master_rect.r_height-1-y;
	if( cy < 0 || cy >= master_rect.r_height) return;
    for( cnt = count; --cnt >= 0; p++ )  {
	value = COLOR_APPROX(p);
d323 2
a324 3
fb_log("%3d: %3d %3d %3d --> %3d %3d %3d\n", value,
(*p)[RED], (*p)[GRN], (*p)[BLU],
redmap[value], grnmap[value], blumap[value] );
a325 2
	pw_rop(sun_pw, cx, cy, sun_xzoom, sun_yzoom,
	       PIX_DONTCLIP | PIX_SRC | PIX_COLOR(value), (Pixrect *) 0, 0, 0);
d327 9
a335 4
	cx += sun_xzoom;
	if (cx >= ifp->if_width)  {
	    cx = 0;
	    cy -= sun_yzoom;
d337 9
a345 1
    }
d349 3
a351 3
Pixwin         *pw;
int		vx, vy;
register RGBpixel *p;
d353 4
a356 4
    int             cx, cy;
    int             fx, fy;	/* framebuffer x,y */
    int             xcnt, ycnt;
    int             value;
d358 3
a360 4
    fx = vx * sun_xzoom;
    fy = vy * sun_yzoom;
    if (dither_flg)
    {
d362 16
a377 9
	for (ycnt = sun_yzoom; --ycnt >= 0;)
	{
	    for (xcnt = sun_xzoom; --xcnt >= 0;)
	    {
		cx = fx + xcnt;
		cy = fy + ycnt;
		value = get_dither8Abit(cx, cy, (*p)[RED], (*p)[GRN], (*p)[BLU]);
		pw_put(pw, cx, cy, value);
	    }
a378 11
#endif DIT
    }
    else
    {
	value = ((((((*p)[RED] * (RR))>>8) * GR ) +
		(((*p)[GRN]*(GR))>>8)) * BR
		+ (((*p)[BLU] * (BR))>>8));
/**	value = ((*p)[RED] + (*p)[GRN] + (*p)[BLU]) / 3; **/
	pw_rop(pw, fx, fy, sun_xzoom, sun_yzoom,
	       PIX_SRC | PIX_COLOR(value), (Pixrect *) 0, 0, 0);
    }
d382 1
a382 1
 *			S U N _ V I E W P O R T _ S E T
d390 1
a390 1
 *			S U N _ C M R E A D
d398 1
a398 1
 *			S U N _ C M W R I T E
d401 3
a403 3
sun_cmwrite( ifp, cmp )
register FBIO	*ifp;
register ColorMap	*cmp;
d405 1
a405 1
    sun_repair();
d411 2
a412 1
/* draw8Abit.c
d414 1
a414 1
 * By: David H. Elrod;  Sun Microsystems; September 1986
d416 2
a417 2
 * Draw a pixel in 8 bit color space using a color cube that
 * is 6values red,  7values green and 6values blue.
d419 2
a420 3
 * External Variables Used:
 *	redscr, grnscr, bluscr	- red, green and blue pixrects
 *	red8Amap, grn8Amap, blue8Amap	- software color map
d422 1
a422 1
 * Bugs:
d427 2
a428 2
int x, y;			/* pixel location */
unsigned char r, g, b;		/* red, green, blue pixel values */
d430 2
a431 2
    int red, green, blue;	/* return values */
    int v;			/* 8 bit value */
d433 2
a434 2
    v = biggest - (((((r*(RR))>>8) * GR ) + ((g*(GR))>>8)) * BR
	+ ((b*(BR))>>8));
d436 4
a439 4
     /* deal with 24 bit frame buffer */
    red =   pr_put(redscr, x, y, red8Amap[v]);
    green = pr_put(grnscr, x, y, grn8Amap[v]);
    blue =  pr_put(bluscr, x, y, blu8Amap[v]);
d441 3
a443 3
    if((red == PIX_ERR) || (green == PIX_ERR) || (blue == PIX_ERR))
	return(PIX_ERR);
    return(0);
d448 13
a460 13
{   
    int i, r, g, b;		/* loop counters */
    
     /* ordered dither matrix (6 reds, 7 greens and 6 blues) */
    i = 0;
    for(r=0; r<RR; r++)
	for(g=0; g<GR; g++)
	    for(b=0; b<BR; b++) {
		red8Amap[i] = 255 - (r*255 / (RR - 1));
		grn8Amap[i] = 255 - (g*255 / (GR - 1));
		blu8Amap[i] = 255 - (b*255 / (BR - 1));
		i++;
	    }
d462 3
a464 2
    
/* pw_dither8Abit.c
d466 2
a467 2
 * Modified:	Bill Lindemann;	Sun Microsystems; September 1986
 * From original by: David H. Elrod;  Sun Microsystems; September 1986
d469 3
a471 3
 * Display a pixel using an ordered dither algoritm to approximate the
 * 24 bit rgb value supplied.  Convert this value to an 8 bit system,
 * and display in the given pixwin.  Assume the colormap is already set.
d473 1
a473 2
 * External Variables Used:
 *	red8Amat, grn8Amat, blu8Amat	- dither matricies;
d475 1
a475 1
 * Bugs:
d480 3
a482 3
Pixwin	*pw;
int x, y;			/* pixel location */
unsigned char r, g, b;		/* red, green, blue pixel values */
d484 2
a485 2
    int red, green, blue;	/* return values */
    int v;			/* 8 bit value */
d487 3
a489 3
    v = biggest - (( dit8A(r, red8Amat, RR-1, x, y)*GR +
	dit8A(g, grn8Amat, GR-1, x, y)  )*BR +
	dit8A(b, blu8Amat, BR-1, x, y));
d491 1
a491 1
    pw_put(pw, x, y, v);
d493 3
a495 3
    if((red == PIX_ERR) || (green == PIX_ERR) || (blue == PIX_ERR))
	return(PIX_ERR);
    return(0);
d499 2
a500 2
int x, y;			/* pixel location */
unsigned char r, g, b;		/* red, green, blue pixel values */
d502 1
a502 1
    int v;			/* 8 bit value */
d504 3
a506 3
    v = biggest - (( dit8A(r, red8Amat, RR-1, x, y)*GR +
	dit8A(g, grn8Amat, GR-1, x, y)  )*BR +
	dit8A(b, blu8Amat, BR-1, x, y));
d508 1
a508 1
    return(v);
d512 2
a513 2
Pixwin	*pw;
colormap_t	*cmap;
d515 9
a523 10
    pw_setcmsname(pw, "dith8Amap");
    pw_putcolormap(pw, 0, biggest+1, red8Amap, grn8Amap, blu8Amap);
    if (cmap != (colormap_t *) 0)
    {
	cmap->type = RMT_EQUAL_RGB;
	cmap->length = biggest+1;
	cmap->map[0] = red8Amap;
	cmap->map[1] = grn8Amap;
	cmap->map[2] = blu8Amap;
    }
d527 3
a529 3
Pixwin		*pw;
Pixrect		*pr_red, *pr_grn, *pr_blu;
int		size;
d531 5
a535 5
    register unsigned char *redP, *grnP, *bluP, *compP;
    register int    x, y;
    Pixrect        *pr_comp;
    struct mpr_data *mpr_red, *mpr_grn, *mpr_blu, *mpr_comp;
    unsigned char  *red_base, *grn_base, *blu_base, *comp_base;
d537 13
a549 14
    pr_comp = mem_create(size, size, 8);
    if (pr_comp == (Pixrect *) 0)
    {
	(void) printf(stderr, "mem_create failed\n");
	exit(1);
    }
    mpr_red = mpr_d(pr_red);
    mpr_grn = mpr_d(pr_grn);
    mpr_blu = mpr_d(pr_blu);
    mpr_comp = mpr_d(pr_comp);
    red_base = (unsigned char *) mpr_red->md_image;
    grn_base = (unsigned char *) mpr_grn->md_image;
    blu_base = (unsigned char *) mpr_blu->md_image;
    comp_base = (unsigned char *) mpr_comp->md_image;
d551 10
a560 11
    for (y = size; --y >= 0;)
    {
	redP = red_base + (y * mpr_red->md_linebytes);
	grnP = grn_base + (y * mpr_grn->md_linebytes);
	bluP = blu_base + (y * mpr_blu->md_linebytes);
	compP = comp_base + (y * mpr_comp->md_linebytes);
	for (x = 0; x < size; x++)
	{
	    *compP++ = biggest - (( dit8A(*redP++, red8Amat, RR-1, x, y)*GR +
		dit8A(*grnP++, grn8Amat, GR-1, x, y)  )*BR +
		dit8A(*bluP++, blu8Amat, BR-1, x, y));
d562 2
a563 3
    }
    pw_rop(pw, 0, 0, size, size, PIX_SRC, pr_comp, 0, 0);
    pr_destroy(pr_comp);
d567 3
a569 3
Pixwin		*pw;
Pixrect		*pr_24;
int		size;
d571 6
a576 6
    register unsigned char *pr24P, *compP;
    register int    red, grn, blu;
    register int    x, y;
    Pixrect        *pr_comp;
    struct mpr_data *mpr_24, *mpr_comp;
    unsigned char  *pr24_base, *comp_base;
d578 9
a586 10
    pr_comp = mem_create(size, size, 8);
    if (pr_comp == (Pixrect *) 0)
    {
	(void) printf(stderr, "mem_create failed\n");
	exit(1);
    }
    mpr_24 = mpr_d(pr_24);
    mpr_comp = mpr_d(pr_comp);
    pr24_base = (unsigned char *) mpr_24->md_image;
    comp_base = (unsigned char *) mpr_comp->md_image;
d588 11
a598 12
    for (y = size; --y >= 0;)
    {
	pr24P = pr24_base + (y * mpr_24->md_linebytes);
	compP = comp_base + (y * mpr_comp->md_linebytes);
	for (x = 0; x < size; x++)
	{
	    red = *pr24P++;
	    grn = *pr24P++;
	    blu = *pr24P++;
	    *compP++ = biggest - (( dit8A(red, red8Amat, RR-1, x, y)*GR +
		dit8A(grn, grn8Amat, GR-1, x, y)  )*BR +
		dit8A(blu, blu8Amat, BR-1, x, y));
d600 2
a601 3
    }
    pw_rop(pw, 0, 0, size, size, PIX_SRC, pr_comp, 0, 0);
    pr_destroy(pr_comp);
@
