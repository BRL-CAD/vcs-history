head	1.40;
access;
symbols
	ansi-20040405-merged:1.37.2.1
	postmerge-20040405-ansi:1.38
	premerge-20040404-ansi:1.37
	postmerge-autoconf:1.37
	autoconf-freeze:1.37
	premerge-autoconf:1.37
	ansi-20040316-freeze:1.37.2.1
	postmerge-20040315-windows:1.37
	premerge-20040315-windows:1.37
	windows-20040315-freeze:1.37
	autoconf-20031203:1.37
	autoconf-20031202:1.37
	autoconf-branch:1.37.0.10
	phong-branch:1.37.0.8
	photonmap-branch:1.37.0.6
	rel-6-1-DP:1.37
	windows-branch:1.37.0.4
	rel-6-0-2:1.35
	ansi-branch:1.37.0.2
	rel-6-0-1-branch:1.35.0.2
	hartley-6-0-post:1.36
	hartley-6-0-pre:1.35
	rel-6-0-1:1.35
	rel-6-0:1.35
	rel-5-4:1.32.2.1
	offsite-5-3-pre:1.33
	rel-5-3:1.32.2.1
	rel-5-2:1.32
	rel-5-1-branch:1.32.0.2
	rel-5-1:1.32
	rel-5-0:1.27
	rel-5-0-beta:1.27
	rel-4-5:1.24
	ctj-4-5-post:1.18
	ctj-4-5-pre:1.18;
locks; strict;
comment	@ * @;


1.40
date	2004.05.21.18.07.25;	author morrison;	state dead;
branches;
next	1.39;

1.39
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	1.38;

1.38
date	2004.04.05.07.44.42;	author morrison;	state Exp;
branches;
next	1.37;

1.37
date	2002.08.20.17.07.47;	author jra;	state Exp;
branches
	1.37.2.1;
next	1.36;

1.36
date	2002.08.15.20.55.00;	author hartley;	state Exp;
branches;
next	1.35;

1.35
date	2001.04.20.22.29.14;	author morrison;	state Exp;
branches;
next	1.34;

1.34
date	2001.04.05.12.52.54;	author bparker;	state Exp;
branches;
next	1.33;

1.33
date	2000.11.01.22.00.25;	author bparker;	state Exp;
branches;
next	1.32;

1.32
date	2000.01.28.15.49.00;	author bparker;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2000.01.21.20.05.11;	author butler;	state Exp;
branches;
next	1.30;

1.30
date	99.12.30.00.02.29;	author bparker;	state Exp;
branches;
next	1.29;

1.29
date	99.12.29.20.44.39;	author jra;	state Exp;
branches;
next	1.28;

1.28
date	99.12.17.16.32.21;	author bparker;	state Exp;
branches;
next	1.27;

1.27
date	98.06.27.04.29.16;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	98.05.15.14.58.44;	author bparker;	state Exp;
branches;
next	1.25;

1.25
date	98.04.23.13.50.36;	author bparker;	state Exp;
branches;
next	1.24;

1.24
date	98.01.29.06.02.27;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	98.01.20.20.43.23;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	98.01.20.19.52.09;	author bparker;	state Exp;
branches;
next	1.21;

1.21
date	98.01.05.20.22.53;	author bparker;	state Exp;
branches;
next	1.20;

1.20
date	97.12.04.08.53.34;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	97.12.04.01.35.07;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	97.06.26.03.03.00;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	97.06.04.13.37.55;	author gdurf;	state Exp;
branches;
next	1.16;

1.16
date	97.06.03.20.34.25;	author gdurf;	state Exp;
branches;
next	1.15;

1.15
date	97.06.03.14.00.59;	author gdurf;	state Exp;
branches;
next	1.14;

1.14
date	97.05.30.23.04.19;	author gdurf;	state Exp;
branches;
next	1.13;

1.13
date	97.05.20.16.15.51;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	97.05.20.16.15.07;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	96.12.31.17.47.05;	author jra;	state Exp;
branches;
next	1.10;

1.10
date	96.12.20.13.40.54;	author jra;	state Exp;
branches;
next	1.9;

1.9
date	96.11.01.22.05.05;	author bparker;	state Exp;
branches;
next	1.8;

1.8
date	95.07.24.20.32.27;	author cnuzman;	state Exp;
branches;
next	1.7;

1.7
date	95.07.24.16.05.51;	author cnuzman;	state Exp;
branches;
next	1.6;

1.6
date	95.07.20.21.01.00;	author cnuzman;	state Exp;
branches;
next	1.5;

1.5
date	95.07.20.17.23.30;	author cnuzman;	state Exp;
branches;
next	1.4;

1.4
date	95.07.19.23.50.35;	author cnuzman;	state Exp;
branches;
next	1.3;

1.3
date	95.07.18.23.00.34;	author cnuzman;	state Exp;
branches;
next	1.2;

1.2
date	95.07.17.22.57.45;	author cnuzman;	state Exp;
branches;
next	1.1;

1.1
date	95.07.13.22.28.33;	author cnuzman;	state Exp;
branches;
next	;

1.32.2.1
date	2000.11.01.22.02.30;	author bparker;	state Exp;
branches;
next	;

1.37.2.1
date	2002.09.19.18.01.19;	author morrison;	state Exp;
branches;
next	;


desc
@OpenGL framebuffer support
@


1.40
log
@moved to src/
@
text
@/*
 *			I F _ O G L . C
 *
 *  BRL Frame Buffer Library interface for OpenGL.
 *
 *  There are several different Frame Buffer modes supported.
 *  Set your environment FB_FILE to the appropriate type.
 *  Note that some of the /dev/sgi modes are not supported, and there are 
 *  some new modes. 
 *  (see the modeflag definitions below).
 *	/dev/ogl[options]
 *
 *  This code is basically a port of if_4d.c from IRIS GL to OpenGL.
 *
 *  Authors -
 *	Carl Nuzman
 *	Bob Parker
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libfb/if_ogl.c,v 1.39 2004/05/10 15:30:45 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h> 
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <stdlib.h>  
#include <unistd.h>
#include <ctype.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <signal.h>
#include <errno.h>
#include <X11/keysym.h> 
#include <X11/StringDefs.h> 
#include <GL/glx.h>
#include <GL/gl.h>
#undef RED

#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "fb.h"
#include "./fblocal.h"

#define CJDEBUG 0

/*WWW these come from Iris gl gl.h*/
#define XMAXSCREEN	1279
#define YMAXSCREEN	1023	
#define XMAXMEDIUM	1023
#define YMAXMEDIUM	767
#define XMAX170		645
#define YMAX170		484

/* Internal callbacks etc.*/
_LOCAL_ void		do_event(FBIO *ifp);
_LOCAL_ void		expose_callback(FBIO *ifp, XEvent *eventPtr);
void ogl_configureWindow FB_ARGS((FBIO *ifp, int width, int height));

/* Other Internal routines */
_LOCAL_ void		ogl_clipper(register FBIO *ifp);
_LOCAL_ int		ogl_getmem(FBIO *ifp);
_LOCAL_ void		backbuffer_to_screen(register FBIO *ifp, int one_y);
_LOCAL_ void		ogl_cminit(register FBIO *ifp);
#if 0
_LOCAL_ void		reorder_cursor();
#endif
_LOCAL_ XVisualInfo *	ogl_choose_visual(FBIO *ifp);
_LOCAL_ int		is_linear_cmap(register FBIO *ifp);

_LOCAL_ int	ogl_nwindows = 0; 	/* number of open windows */
_LOCAL_ int	multiple_windows = 0;	/* someone wants to be ready
					 * for multiple windows, at the
					 * expense of speed.
					 */
_LOCAL_	XColor	color_cell[256];		/* used to set colormap */

int ogl_refresh(FBIO *ifp, int x, int y, int w, int h);
int ogl_open_existing(FBIO *ifp, int argc, char **argv);
int ogl_close_existing(FBIO *ifp);
int _ogl_open_existing(FBIO *ifp, Display *dpy, Window win, Colormap cmap, XVisualInfo *vip, int width, int height, GLXContext glxc, int double_buffer, int soft_cmap);

_LOCAL_ int	ogl_open(FBIO *ifp, char *file, int width, int height),
		ogl_close(FBIO *ifp),
		ogl_clear(FBIO *ifp, unsigned char *pp),
		ogl_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count),
		ogl_write(FBIO *ifp, int xstart, int ystart, const unsigned char *pixelp, int count),
		ogl_rmap(register FBIO *ifp, register ColorMap *cmp),
		ogl_wmap(register FBIO *ifp, register const ColorMap *cmp),
		ogl_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
		ogl_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom),
		ogl_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig),
		ogl_cursor(FBIO *ifp, int mode, int x, int y),
#if 0
		ogl_getcursor(),
		ogl_readrect(),
		fb_cnull(),
#endif
		ogl_writerect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp),
		ogl_bwwriterect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp),
		ogl_poll(FBIO *ifp),
		ogl_flush(FBIO *ifp),
		ogl_free(FBIO *ifp),
		ogl_help(FBIO *ifp);

/* This is the ONLY thing that we normally "export" */
FBIO ogl_interface =  
	{
	0,			/* magic number slot	*/
	ogl_open,		/* open device		*/
	ogl_close,		/* close device		*/
	ogl_clear,		/* clear device		*/
	ogl_read,		/* read	pixels		*/
	ogl_write,		/* write pixels		*/
	ogl_rmap,		/* read colormap	*/
	ogl_wmap,		/* write colormap	*/
	ogl_view,		/* set view		*/
	ogl_getview,		/* get view		*/
	ogl_setcursor,		/* define cursor	*/
	ogl_cursor,		/* set cursor		*/
	fb_sim_getcursor,	/* get cursor		*/
	fb_sim_readrect,	/* read rectangle	*/
	ogl_writerect,		/* write rectangle	*/
	fb_sim_bwreadrect,
	ogl_bwwriterect,	/* write rectangle	*/
	ogl_poll,		/* process events	*/
	ogl_flush,		/* flush output		*/
	ogl_free,		/* free resources	*/
	ogl_help,		/* help message		*/
	"Silicon Graphics OpenGL",	/* device description	*/
	XMAXSCREEN+1,			/* max width		*/
	YMAXSCREEN+1,			/* max height		*/
	"/dev/ogl",		/* short device name	*/
	512,			/* default/current width  */
	512,			/* default/current height */
	-1,			/* select file desc	*/
	-1,			/* file descriptor	*/
	1, 1,			/* zoom			*/
	256, 256,		/* window center	*/
	0, 0, 0,		/* cursor		*/
	PIXEL_NULL,		/* page_base		*/
	PIXEL_NULL,		/* page_curp		*/
	PIXEL_NULL,		/* page_endp		*/
	-1,			/* page_no		*/
	0,			/* page_dirty		*/
	0L,			/* page_curpos		*/
	0L,			/* page_pixels		*/
	0			/* debug		*/
};


/*
 *  Structure of color map in shared memory region.
 *  Has exactly the same format as the SGI hardware "gammaramp" map
 *  Note that only the lower 8 bits are significant.
 */
struct ogl_cmap {
	short	cmr[256];
	short	cmg[256];
	short	cmb[256];
};

/* 
 *  This defines the format of the in-memory framebuffer copy.
 *  The alpha component and reverse order are maintained for
 *  compatibility with /dev/sgi
 */
struct ogl_pixel {
	unsigned char alpha;
	unsigned char blue;
	unsigned char green;
	unsigned char red;
};

/* Clipping structure for zoom/pan operations */
struct ogl_clip {
	int	xpixmin;	/* view clipping planes clipped to pixel memory space*/
	int	xpixmax;
	int	ypixmin;
	int	ypixmax;
	int	xscrmin;	/* view clipping planes */
	int	xscrmax;
	int	yscrmin;
	int	yscrmax;
	double	oleft;		/* glOrtho parameters */
	double	oright;
	double	otop;
	double	obottom;
	
};

/*
 *  Per window state information, overflow area. 
 *  Structure members have the same meaning as in the if_4d.c code.
 */
struct sgiinfo {
	short	mi_curs_on;
	short	mi_cmap_flag;		/* enabled when there is a non-linear map in memory */
	int	mi_shmid;
	int	mi_memwidth;		/* width of scanline in if_mem */
	short	mi_xoff;		/* X viewport offset, rel. window*/
	short	mi_yoff;		/* Y viewport offset, rel. window*/
	int	mi_pid;			/* for multi-cpu check */
	int	mi_parent;		/* PID of linger-mode process */
	int	mi_doublebuffer;	/* 0=singlebuffer 1=doublebuffer */
	struct ogl_pixel mi_scanline[XMAXSCREEN+1];	/* one scanline */
};

/*
 *  Per window state information particular to the OpenGL interface
 */
struct oglinfo {
	GLXContext	glxc;
	Display	       *dispp;		/* pointer to X display connection */
	Window		wind;		/* Window identifier */
	int		firstTime;
	int		alive;
	long		event_mask;	/* event types to be received */
	short		front_flag;	/* front buffer being used (b-mode) */
	short		copy_flag;	/* pan and zoom copied from backbuffer */
	short		soft_cmap_flag;	/* use software colormapping */
	int		cmap_size;	/* hardware colormap size */
	int 		win_width;	/* actual window width */
	int		win_height;	/* actual window height */
	int		vp_width;	/* actual viewport width */
	int		vp_height;	/* actual viewport height */
	struct ogl_clip	clip;		/* current view clipping */
	Window		cursor;
	XVisualInfo    *vip;		/* pointer to info on current visual */
	Colormap	xcmap;		/* xstyle color map */
	int		use_ext_ctrl;	/* for controlling the Ogl graphics engine externally */
};

#define	SGI(ptr)	((struct sgiinfo *)((ptr)->u1.p))
#define	SGIL(ptr)	((ptr)->u1.p)		/* left hand side version */
#define	OGL(ptr)	((struct oglinfo *)((ptr)->u6.p))
#define	OGLL(ptr)	((ptr)->u6.p)		/* left hand side version */
#define if_mem		u2.p			/* shared memory pointer */
#define if_cmap		u3.p			/* color map in shared memory */
#define CMR(x)		((struct ogl_cmap *)((x)->if_cmap))->cmr
#define CMG(x)		((struct ogl_cmap *)((x)->if_cmap))->cmg
#define CMB(x)		((struct ogl_cmap *)((x)->if_cmap))->cmb
#define if_zoomflag	u4.l			/* zoom > 1 */
#define if_mode		u5.l			/* see MODE_* defines */

#define MARGIN	4			/* # pixels margin to screen edge */

#define CLIP_XTRA 1

#define WIN_L (ifp->if_max_width - ifp->if_width - MARGIN)
#define WIN_T (ifp->if_max_height - ifp->if_height - MARGIN)

/*
 *  The mode has several independent bits:
 *	SHARED -vs- MALLOC'ed memory for the image
 *	TRANSIENT -vs- LINGERING windows
 *	Windowed -vs- Centered Full screen
 *	Suppress dither -vs- dither
 *	Double -vs- Single buffered
 *	DrawPixels -vs- CopyPixels
 */
#define MODE_1MASK	(1<<0)
#define MODE_1SHARED	(0<<0)		/* Use Shared memory */
#define MODE_1MALLOC	(1<<0)		/* Use malloc memory */

#define MODE_2MASK	(1<<1)
#define MODE_2TRANSIENT	(0<<1)
#define MODE_2LINGERING (1<<1)		/* leave window up after closing*/

#define MODE_3MASK	(1<<2)
#define MODE_3WINDOW	(0<<2)		/* window mode */
#define MODE_3FULLSCR	(1<<2)		/* full screen mode */

#define MODE_4MASK	(1<<3)
#define MODE_4NORMAL	(0<<3)		/* dither if it seems necessary */
#define MODE_4NODITH	(1<<3)		/* suppress any dithering */

#define MODE_5MASK	(1<<4)
#define MODE_5NORMAL	(0<<4)	 	/* fast - assume no multiple windows */
#define MODE_5MULTI	(1<<4)		/* be ready for multiple windows */

#define MODE_7MASK	(1<<6)
#define MODE_7NORMAL	(0<<6)		/* install colormap in hardware if possible*/
#define MODE_7SWCMAP	(1<<6)		/* use software colormapping */

#define MODE_9MASK	(1<<8)
#define MODE_9NORMAL	(0<<8)		/* doublebuffer if possible */
#define MODE_9SINGLEBUF	(1<<8)		/* singlebuffer only */

#define MODE_11MASK	(1<<10)
#define MODE_11NORMAL	(0<<10)		/* always draw from mem. to window*/
#define MODE_11COPY	(1<<10)		/* keep full image on back buffer,*/

#define MODE_12MASK	(1<<11)
#define MODE_12NORMAL	(0<<11)
#define MODE_12DELAY_WRITES_TILL_FLUSH	(1<<11)
					/* and copy current view to front */
#define MODE_15MASK	(1<<14)
#define MODE_15NORMAL	(0<<14)
#define MODE_15ZAP	(1<<14)		/* zap the shared memory segment */

_LOCAL_ struct modeflags {
	char	c;
	long	mask;
	long	value;
	char	*help;
} modeflags[] = {
	{ 'p',	MODE_1MASK, MODE_1MALLOC,
		"Private memory - else shared" },
	{ 'l',	MODE_2MASK, MODE_2LINGERING,
		"Lingering window - else transient" },
	{ 'f',	MODE_3MASK, MODE_3FULLSCR,
		"Full centered screen - else windowed" },
	{ 'd',  MODE_4MASK, MODE_4NODITH,
		"Suppress dithering - else dither if not 24-bit buffer" },
	{ 'm',  MODE_5MASK, MODE_5MULTI,
		"Be ready for multiple windows - else optimize for single windows" },
	{ 'c',	MODE_7MASK, MODE_7SWCMAP,
		"Perform software colormap - else use hardware colormap if possible" },
	{ 's',	MODE_9MASK, MODE_9SINGLEBUF,
		"Single buffer -  else double buffer if possible" },
	{ 'b',	MODE_11MASK, MODE_11COPY,
		"Fast pan and zoom using backbuffer copy -  else normal " },
	{ 'D',	MODE_12DELAY_WRITES_TILL_FLUSH, MODE_12DELAY_WRITES_TILL_FLUSH,
		"Don't update screen until fb_flush() is called.  (Double buffer sim)" },
	{ 'z',	MODE_15MASK, MODE_15ZAP,
		"Zap (free) shared memory.  Can also be done with fbfree command" },
	{ '\0', 0, 0, "" }
};


/************************************************************************/
/************************************************************************/
/************************************************************************/
/******************* Shared Memory Support ******************************/
/************************************************************************/
/************************************************************************/
/************************************************************************/

/*
 *			O G L _ G E T M E M
 *
 *			not changed from
 *
 *			S G I _ G E T M E M
 *
 *  Because there is no hardware zoom or pan, we need to repaint the
 *  screen (with big pixels) to implement these operations.
 *  This means that the actual "contents" of the frame buffer need
 *  to be stored somewhere else.  If possible, we allocate a shared
 *  memory segment to contain that image.  This has several advantages,
 *  the most important being that when operating the display in 12-bit
 *  output mode, pixel-readbacks still give the full 24-bits of color.
 *  System V shared memory persists until explicitly killed, so this
 *  also means that in MEX mode, the previous contents of the frame
 *  buffer still exist, and can be again accessed, even though the
 *  MEX windows are transient, per-process.
 * 
 *  There are a few oddities, however.  The worst is that System V will
 *  not allow the break (see sbrk(2)) to be set above a shared memory
 *  segment, and shmat(2) does not seem to allow the selection of any
 *  reasonable memory address (like 6 Mbytes up) for the shared memory.
 *  In the initial version of this routine, that prevented subsequent
 *  calls to malloc() from succeeding, quite a drawback.  The work-around
 *  used here is to increase the current break to a large value,
 *  attach to the shared memory, and then return the break to its
 *  original value.  This should allow most reasonable requests for
 *  memory to be satisfied.  In special cases, the values used here
 *  might need to be increased.
 */
_LOCAL_ int
ogl_getmem(FBIO *ifp)
{
#define SHMEM_KEY	42
	int	pixsize;
	int	size;
	int	i;
#if IRIX < 5
	char	*old_brk;
	char	*new_brk;
#endif
	char	*sp;
	int	new = 0;

#if 0
	if( sizeof(struct ogl_pixel) != sizeof(long) )  {
		fb_log("Warning, ogl_pixel=%d, long=%d bytes\n",
			sizeof(struct ogl_pixel), sizeof(long) );
	}
#endif

	errno = 0;

	if( (ifp->if_mode & MODE_1MASK) == MODE_1MALLOC )  {
		/*
		 *  In this mode, only malloc as much memory as is needed.
		 */
		SGI(ifp)->mi_memwidth = ifp->if_width;
		pixsize = ifp->if_height * ifp->if_width * sizeof(struct ogl_pixel);
		size = pixsize + sizeof(struct ogl_cmap);

		sp = calloc( 1, size );
		if( sp == 0 )  {
			fb_log("ogl_getmem: frame buffer memory malloc failed\n");
			goto fail;
		}
		new = 1;
		goto success;
	}

	/* The shared memory section never changes size */
	SGI(ifp)->mi_memwidth = ifp->if_max_width;

	/*
	 *  On Irix 5 with Indigo EXPRESS graphics,
	 *  lrectwrite() runs off the end!
	 *  So, provide a pad area of 2 scanlines.
	 *  (1 line is enough, but this avoids risk of damage to colormap table.)
	 */
	pixsize = (ifp->if_max_height+2) * ifp->if_max_width *
		sizeof(struct ogl_pixel);

	size = pixsize + sizeof(struct ogl_cmap);
	size = (size + getpagesize()-1) & ~(getpagesize()-1);

	/* First try to attach to an existing one */
	if( (SGI(ifp)->mi_shmid = shmget( SHMEM_KEY, size, 0 )) < 0 )  {
		/* No existing one, create a new one */
		if( (SGI(ifp)->mi_shmid = shmget(
		    SHMEM_KEY, size, IPC_CREAT|0666 )) < 0 )  {
			fb_log("ogl_getmem: shmget failed, errno=%d\n", errno);
			goto fail;
		}
		new = 1;
	}

/* WWW this is unnecessary in this version? */
#if IRIX < 5
	/* Move up the existing break, to leave room for later malloc()s */
	old_brk = sbrk(0);
	new_brk = (char *)(6 * (XMAXSCREEN+1) * 1024L);
	if( new_brk <= old_brk )
		new_brk = old_brk + (XMAXSCREEN+1) * 1024;
	new_brk = (char *)((((long)new_brk) + getpagesize()-1) & ~(getpagesize()-1));
	if( brk( new_brk ) < 0 )  {
		fb_log("ogl_getmem: new brk(x%x) failure, errno=%d\n", new_brk, errno);
		goto fail;
	}

	/* Open the segment Read/Write, near the current break */
	if( (sp = shmat( SGI(ifp)->mi_shmid, 0, 0 )) == (char *)(-1L) )  {
		fb_log("ogl_getmem: shmat returned x%x, errno=%d\n", sp, errno );
		goto fail;
	}

	/* Restore the old break */
	if( brk( old_brk ) < 0 )  {
		fb_log("ogl_getmem: restore brk(x%x) failure, errno=%d\n", old_brk, errno);
		/* Take the memory and run */
	}
#else
	/* Open the segment Read/Write */
	/* On Irix 5, this gets mapped in at a high address, no problem. */
	if( (sp = shmat( SGI(ifp)->mi_shmid, 0, 0 )) == (char *)(-1L) )  {
		fb_log("ogl_getmem: shmat returned x%x, errno=%d\n", sp, errno );
		goto fail;
	}
#endif

success:
	ifp->if_mem = sp;
	ifp->if_cmap = sp + pixsize;	/* cmap at end of area */
	i = CMB(ifp)[255];		/* try to deref last word */
	CMB(ifp)[255] = i;

	/* Provide non-black colormap on creation of new shared mem */
	if(new)
		ogl_cminit( ifp );
	return(0);
fail:
	fb_log("ogl_getmem:  Unable to attach to shared memory.\nConsult comment in cad/libfb/if_4d.c for details\n");
	if( (sp = calloc( 1, size )) == NULL )  {
		fb_log("ogl_getmem:  malloc failure\n");
		return(-1);
	}
	new = 1;
	goto success;
}

/*
 *			O G L _ Z A P M E M
 */
void
ogl_zapmem(void)
{
	int shmid;
	int i;

	if( (shmid = shmget( SHMEM_KEY, 0, 0 )) < 0 )  {
		fb_log("ogl_zapmem shmget failed, errno=%d\n", errno);
		return;
	}

	i = shmctl( shmid, IPC_RMID, 0 );
	if( i < 0 )  {
		fb_log("ogl_zapmem shmctl failed, errno=%d\n", errno);
		return;
	}
	fb_log("if_ogl: shared memory released\n");
}

/*
 *			S I G K I D
 */
static void
#if _XOPEN_SOURCE
sigkid(int pid)
        
#else
     sigkid(int pid)        
#endif
{
	exit(0);
}



/* 			O G L _ X M I T _ S C A N L I N E S
 *
 * Note: unlike sgi_xmit_scanlines, this function updates an arbitrary
 * rectangle of the frame buffer
 */
_LOCAL_ void
ogl_xmit_scanlines(register FBIO *ifp, int ybase, int nlines, int xbase, int npix)
{
	register int	y;
	register int	n;
	int		sw_cmap;	/* !0 => needs software color map */
	struct ogl_clip	*clp;

	/* Caller is expected to handle attaching context, etc. */

	clp = &(OGL(ifp)->clip);

	if( OGL(ifp)->soft_cmap_flag  && SGI(ifp)->mi_cmap_flag )  {
	    	sw_cmap = 1;
	} else {
		sw_cmap = 0;
	}

	if(xbase > clp->xpixmax || ybase > clp->ypixmax)
		return;
	if(xbase < clp->xpixmin)
		xbase = clp->xpixmin;
	if(ybase < clp->ypixmin)
		ybase = clp->ypixmin;

	if((xbase + npix -1 ) > clp->xpixmax)
		npix = clp->xpixmax - xbase + 1;
	if((ybase + nlines - 1) > clp->ypixmax)
		nlines = clp->ypixmax - ybase + 1;

	if(!OGL(ifp)->use_ext_ctrl){
	if (!OGL(ifp)->copy_flag){
		/*
		 * Blank out areas of the screen around the image, if exposed.
		 * In COPY mode, this is done in backbuffer_to_screen().
		 */

		/* Blank out area left of image */
		glColor3b( 0, 0, 0 );
		if( clp->xscrmin < 0 )  glRecti(
			clp->xscrmin - CLIP_XTRA,
			clp->yscrmin - CLIP_XTRA,
			CLIP_XTRA,
			clp->yscrmax + CLIP_XTRA);

		/* Blank out area below image */
		if( clp->yscrmin < 0 )  glRecti(
			clp->xscrmin - CLIP_XTRA,
			clp->yscrmin - CLIP_XTRA,
			clp->xscrmax + CLIP_XTRA,
			CLIP_XTRA);

		/* Blank out area right of image */
		if( clp->xscrmax >= ifp->if_width )  glRecti(
			ifp->if_width - CLIP_XTRA,
			clp->yscrmin - CLIP_XTRA,
			clp->xscrmax + CLIP_XTRA,
			clp->yscrmax + CLIP_XTRA);
		
		/* Blank out area above image */
		if( clp->yscrmax >= ifp->if_height )  glRecti(
			clp->xscrmin - CLIP_XTRA,
			ifp->if_height- CLIP_XTRA,
			clp->xscrmax + CLIP_XTRA,
			clp->yscrmax + CLIP_XTRA);
		
	} else if (OGL(ifp)->front_flag) {
		/* in COPY mode, always draw full sized image into backbuffer.
		 * backbuffer_to_screen() is used to update the front buffer
		 */ 
		glDrawBuffer(GL_BACK);
		OGL(ifp)->front_flag = 0;
		glMatrixMode(GL_PROJECTION);
		glPushMatrix();	/* store current view clipping matrix*/
		glLoadIdentity();
		glOrtho( -0.25, ((GLdouble) OGL(ifp)->vp_width)-0.25,
			-0.25, ((GLdouble) OGL(ifp)->vp_height)-0.25,
			-1.0, 1.0);
		glPixelZoom( 1.0, 1.0);
	}
	}

	if( sw_cmap ) { 
		/* Software colormap each line as it's transmitted */
		register int	x;
		register struct ogl_pixel	*oglp;
		register struct ogl_pixel	*op;

		y = ybase;
		if(CJDEBUG) printf("Doing sw colormap xmit\n");		
		/* Perform software color mapping into temp scanline */
		op = SGI(ifp)->mi_scanline;
		for( n=nlines; n>0; n--, y++ )  {
			oglp = (struct ogl_pixel *)&ifp->if_mem[
				(y*SGI(ifp)->mi_memwidth)*
				sizeof(struct ogl_pixel) ];
			for( x=xbase+npix-1; x>=xbase; x-- )  {
				op[x].red   = CMR(ifp)[oglp[x].red];
				op[x].green = CMG(ifp)[oglp[x].green];
				op[x].blue  = CMB(ifp)[oglp[x].blue];
			}
			
			glPixelStorei(GL_UNPACK_SKIP_PIXELS,xbase);
			glRasterPos2i(xbase,y);
			glDrawPixels(npix,1,GL_ABGR_EXT,GL_UNSIGNED_BYTE,
					(const GLvoid *) op);

		}

	} else  {
		/* No need for software colormapping */

		glPixelStorei(GL_UNPACK_ROW_LENGTH,SGI(ifp)->mi_memwidth);
		glPixelStorei(GL_UNPACK_SKIP_PIXELS,xbase);
		glPixelStorei(GL_UNPACK_SKIP_ROWS,ybase);
		
		glRasterPos2i(xbase,ybase);
		glDrawPixels(npix,nlines,GL_ABGR_EXT,GL_UNSIGNED_BYTE,
				(const GLvoid *) ifp->if_mem);
	}
}


_LOCAL_ int
ogl_open(FBIO *ifp, char *file, int width, int height)
{

	int		f;
	int		status;
	static char	title[128];
	int		mode, i, direct;
	long		valuemask;
	XSetWindowAttributes swa;

	FB_CK_FBIO(ifp);

	/*
	 *  First, attempt to determine operating mode for this open,
	 *  based upon the "unit number" or flags.
	 *  file = "/dev/ogl###"
	 *  The default mode is zero.
	 */
	mode = 0;

	if( file != NULL )  {
		register char *cp;
		char	modebuf[80];
		char	*mp;
		int	alpha;
		struct	modeflags *mfp;

		if( strncmp(file, "/dev/ogl", 8) ) {
			/* How did this happen?? */
			mode = 0;
		} else {
			/* Parse the options */
			alpha = 0;
			mp = &modebuf[0];
			cp = &file[8];
			while( *cp != '\0' && !isspace(*cp) ) {
				*mp++ = *cp;	/* copy it to buffer */
				if( isdigit(*cp) ) {
					cp++;
					continue;
				}
				alpha++;
				for( mfp = modeflags; mfp->c != '\0'; mfp++ ) {
					if( mfp->c == *cp ) {
						mode = (mode&~mfp->mask)|mfp->value;
						break;
					}
				}
				if( mfp->c == '\0' && *cp != '-' ) {
					fb_log( "if_4d: unknown option '%c' ignored\n", *cp );
				}
				cp++;
			}
			*mp = '\0';
			if( !alpha )
				mode = atoi( modebuf );
		}

		if( (mode & MODE_15MASK) == MODE_15ZAP ) {
			/* Only task: Attempt to release shared memory segment */
			ogl_zapmem();
			return(-1);
		}
	}
	ifp->if_mode = mode;

	/*
	 *  Allocate extension memory sections,
	 *  addressed by SGI(ifp)->mi_xxx and OGL(ifp)->xxx
	 */

	if( (SGIL(ifp) = (char *)calloc( 1, sizeof(struct sgiinfo) )) == NULL )  {
		fb_log("ogl_open:  sgiinfo malloc failed\n");
		return(-1);
	}
	if( (OGLL(ifp) = (char *)calloc( 1, sizeof(struct oglinfo) )) == NULL )  {
		fb_log("ogl_open:  oglinfo malloc failed\n");
		return(-1);
	}

	SGI(ifp)->mi_shmid = -1;	/* indicate no shared memory */

	if (ogl_nwindows && !multiple_windows){
		fb_log("Warning - ogl_open: Multiple windows opened. Use /dev/oglm for first window!");
	}

	/* Anyone can turn this on; no one can turn it off */
	if( (ifp->if_mode & MODE_5MASK) == MODE_5MULTI )
		multiple_windows = 1;

	/* the Silicon Graphics Library Window management routines
	 * use shared memory. This causes lots of problems when you
	 * want to pass a window structure to a child process.
	 * One hack to get around this is to immediately fork
	 * and create a child process and sleep until the child
	 * sends a kill signal to the parent process. (in FBCLOSE)
	 * This allows us to use the traditional fb utility programs 
	 * as well as allow the frame buffer window to remain around
	 * until killed by the menu subsystem.
    	 */

	if( (ifp->if_mode & MODE_2MASK) == MODE_2LINGERING )  {
		/* save parent pid for later signalling */
		SGI(ifp)->mi_parent = getpid();

		signal( SIGUSR1, sigkid);

		if( (f = fork()) > 0 )  {
			/* Parent process */
			int k;

			for(k=0; k< 20; k++)  {
				(void) close(k);
			}


			/*
			 *  Wait until the child dies, of whatever cause,
			 *  or until the child kills us.
			 *  Pretty vicious, this computer society.
			 */
			while( (k = wait(&status)) != -1 && k != f )
				/* NULL */ ;

			exit(0);
			/* NOTREACHED */
		} else if( f < 0 )  {
			fb_log("ogl_open:  linger-mode fork failure\n");
			return(-1);
		}
		/* Child Process falls through */
	}

	if( (ifp->if_mode & MODE_3MASK) == MODE_3FULLSCR )  {
		/* Bump default size up to full screen, since we have it all */
		ifp->if_width = XMAXSCREEN+1;		/* 1280 */
		ifp->if_height = YMAXSCREEN+1;		/* 1024 */
	}

	/* use defaults if invalid width and height specified */
	if( width <= 0 )
		width = ifp->if_width;
	if( height <= 0 )
		height = ifp->if_height;
	/* use max values if width and height are greater */
	if ( width > ifp->if_max_width )
		width = ifp->if_max_width;
	if ( height > ifp->if_max_height)
		height = ifp->if_max_height;

	ifp->if_width = width;
	ifp->if_height = height;


	if( (ifp->if_mode & MODE_3MASK) == MODE_3WINDOW )  {
		SGI(ifp)->mi_curs_on = 1;
	}  else  {
		/* MODE_3MASK == MODE_3FULLSCR */
		SGI(ifp)->mi_curs_on = 0;
	}

	/* Build a descriptive window title bar */
	(void)sprintf( title, "BRL-CAD /dev/ogl %s, %s",
		((ifp->if_mode & MODE_2MASK) == MODE_2TRANSIENT) ?
			"Transient Win":
			"Lingering Win",
		((ifp->if_mode & MODE_1MASK) == MODE_1MALLOC) ?
			"Private Mem" :
			"Shared Mem" );


	/* initialize window state variables before calling ogl_getmem */
	ifp->if_zoomflag = 0;
	ifp->if_xzoom = 1;	/* for zoom fakeout */
	ifp->if_yzoom = 1;	/* for zoom fakeout */
	ifp->if_xcenter = width/2;
	ifp->if_ycenter = height/2;
	SGI(ifp)->mi_pid = getpid();

	/* Attach to shared memory, potentially with a screen repaint */
	if( ogl_getmem(ifp) < 0 )
		return(-1);

	/* Open an X connection to the display.  Sending NULL to XOpenDisplay
	   tells it to use the DISPLAY environment variable. */
	if( (OGL(ifp)->dispp = XOpenDisplay(NULL)) == NULL ) {
		fb_log("ogl_open: Failed to open display.  Check DISPLAY environment variable.\n");
		return (-1);
	}
	ifp->if_selfd = ConnectionNumber(OGL(ifp)->dispp);
	if( CJDEBUG ) {
		printf("Connection opened to X display on fd %d.\n",
		       ConnectionNumber(OGL(ifp)->dispp));
	}

	/* Choose an appropriate visual. */
	if( (OGL(ifp)->vip = ogl_choose_visual(ifp)) == NULL ) {
		fb_log("ogl_open: Couldn't find an appropriate visual.  Exiting.\n");
		return (-1);
	}

	/* Open an OpenGL context with this visual*/
	if (multiple_windows){	/* force indirect context */
		OGL(ifp)->glxc = glXCreateContext(OGL(ifp)->dispp,
					OGL(ifp)->vip, 0, GL_FALSE);
	} else {		/* try direct context */
		OGL(ifp)->glxc = glXCreateContext(OGL(ifp)->dispp,
					OGL(ifp)->vip, 0, GL_TRUE);
	}

	if (CJDEBUG){
		direct = glXIsDirect(OGL(ifp)->dispp,OGL(ifp)->glxc);
		printf("Context is %s.\n", direct ? "direct" : "indirect");
	}


	/* Create a colormap for this visual */
	SGI(ifp)->mi_cmap_flag = !is_linear_cmap(ifp);
	if (!OGL(ifp)->soft_cmap_flag) {
		OGL(ifp)->xcmap = XCreateColormap(OGL(ifp)->dispp,
					RootWindow(OGL(ifp)->dispp,
						OGL(ifp)->vip->screen),
					OGL(ifp)->vip->visual,
					AllocAll);
		/* initialize virtual colormap - it will be loaded into
		 * the hardware. This code has not yet been tested.
		 */
		if(CJDEBUG) printf("Loading read/write colormap.\n");
	    	for (i = 0; i < 256; i++) {
	    		color_cell[i].pixel = i;
	    		color_cell[i].red = CMR(ifp)[i];
	    		color_cell[i].green = CMG(ifp)[i];
	    		color_cell[i].blue = CMB(ifp)[i];
	    		color_cell[i].flags = DoRed | DoGreen | DoBlue;
	    	}
    		XStoreColors(OGL(ifp)->dispp, OGL(ifp)->xcmap, color_cell,256);
	} else { /* read only colormap */
		if( CJDEBUG ) {
			printf("Allocating read-only colormap.");
		}
		OGL(ifp)->xcmap = XCreateColormap(OGL(ifp)->dispp,
					RootWindow(OGL(ifp)->dispp,
						   OGL(ifp)->vip->screen),
					OGL(ifp)->vip->visual,
					AllocNone);
	}

 	XSync(OGL(ifp)->dispp, 0);

	/* Create a window. */
	memset(&swa, 0, sizeof(swa));

	valuemask = CWBackPixel | CWBorderPixel | CWEventMask | CWColormap;

	swa.background_pixel = BlackPixel(OGL(ifp)->dispp,
					  OGL(ifp)->vip->screen);
	swa.border_pixel = BlackPixel(OGL(ifp)->dispp,
				      OGL(ifp)->vip->screen);
	swa.event_mask = OGL(ifp)->event_mask =
		ExposureMask | KeyPressMask | KeyReleaseMask |
 		ButtonPressMask | ButtonReleaseMask;
	swa.colormap = OGL(ifp)->xcmap;

#define XCreateWindowDebug(display, parent, x, y, width, height, \
			   border_width, depth, class, visual, valuemask, \
			   attributes) \
	(printf("XCreateWindow( display = %08X,\n", (long)display), \
	printf("                parent = %08X,\n", (long)parent), \
	printf("                     x = %d,\n", x), \
	printf("                     y = %d,\n", y), \
	printf("                 width = %d,\n", width), \
	printf("                height = %d,\n", height), \
	printf("          border_width = %d,\n", border_width), \
	printf("                 depth = %d,\n", depth), \
	printf("                 class = %d,\n", class), \
	printf("                visual = %08X,\n", (long)visual), \
        printf("             valuemask = %08X,\n", valuemask), \
	printf("            attributes = {"), \
	(valuemask & CWBackPixmap) ? printf(" background_pixmap = %08X ", (long)((attributes)->background_pixmap)) : 0, \
	(valuemask & CWBackPixel) ? printf(" background_pixel = %08X ", (attributes)->background_pixel) : 0, \
	(valuemask & CWBorderPixmap) ? printf(" border_pixmap = %08X ", (long)((attributes)->border_pixmap)) : 0, \
	(valuemask & CWBorderPixel) ? printf(" border_pixel = %08X ", (attributes)->border_pixel) : 0, \
	(valuemask & CWBitGravity) ? printf(" bit_gravity = %d ", (attributes)->bit_gravity) : 0, \
	(valuemask & CWWinGravity) ? printf(" win_gravity = %d ", (attributes)->win_gravity) : 0, \
	(valuemask & CWBackingStore) ? printf(" backing_store = %d ", (attributes)->backing_store) : 0, \
	(valuemask & CWBackingPlanes) ? printf(" backing_planes = %d ", (attributes)->backing_planes) : 0, \
	(valuemask & CWBackingPixel) ? printf(" backing_pixel = %08X ", (attributes)->backing_pixel) : 0, \
	(valuemask & CWOverrideRedirect) ? printf(" override_redirect = %d ", (attributes)->override_redirect) : 0, \
	(valuemask & CWSaveUnder) ? printf(" save_under = %d ", (attributes)->save_under) : 0, \
	(valuemask & CWEventMask) ? printf(" event_mask = %08X ", (attributes)->event_mask) : 0, \
	(valuemask & CWDontPropagate) ? printf(" do_not_propagate_mask = %08X ", (attributes)->do_not_propagate_mask) : 0, \
	(valuemask & CWColormap) ? printf(" colormap = %08X ", (long)((attributes)->colormap)) : 0, \
	(valuemask & CWCursor) ? printf(" cursor = %08X ", (long)((attributes)->cursor)) : 0, \
	printf(" }\n")) > 0 ? XCreateWindow(display, parent, x, y, width, height, border_width, depth, class, visual, valuemask, attributes) : -1;

	OGL(ifp)->wind = XCreateWindow(OGL(ifp)->dispp,
				       RootWindow(OGL(ifp)->dispp,
						  OGL(ifp)->vip->screen),
				       0, 0, ifp->if_width, ifp->if_height, 0,
				       OGL(ifp)->vip->depth,
				       InputOutput,
				       OGL(ifp)->vip->visual,
				       valuemask, &swa);

	XStoreName(OGL(ifp)->dispp, OGL(ifp)->wind, title);

	/* count windows */
	ogl_nwindows++;
	XMapRaised(OGL(ifp)->dispp, OGL(ifp)->wind);

	OGL(ifp)->alive = 1;
	OGL(ifp)->firstTime = 1;

	/* Loop through events until first exposure event is processed */
	while (OGL(ifp)->firstTime == 1)
		do_event(ifp);

	return 0;
}

int
ogl_open_existing(FBIO *ifp, int argc, char **argv)
{
  Display *dpy;
  Window win;
  Colormap cmap;
  XVisualInfo *vip;
  int width;
  int height;
  GLXContext glxc;
  int double_buffer;
  int soft_cmap;

  if(argc != 10)
    return -1;

  if(sscanf(argv[1], "%lu", (unsigned long *)&dpy) != 1)
    return -1;

  if(sscanf(argv[2], "%lu", (unsigned long *)&win) != 1)
    return -1;

  if(sscanf(argv[3], "%lu", (unsigned long *)&cmap) != 1)
    return -1;

  if(sscanf(argv[4], "%lu", (unsigned long *)&vip) != 1)
    return -1;

  if(sscanf(argv[5], "%d", &width) != 1)
    return -1;

  if(sscanf(argv[6], "%d", &height) != 1)
    return -1;

  if(sscanf(argv[7], "%lu", (unsigned long *)&glxc) != 1)
    return -1;

  if(sscanf(argv[8], "%d", &double_buffer) != 1)
    return -1;

  if(sscanf(argv[9], "%d", &soft_cmap) != 1)
    return -1;

  return _ogl_open_existing(ifp, dpy, win, cmap, vip, width, height,
			    glxc, double_buffer, soft_cmap);
}

int
_ogl_open_existing(FBIO *ifp, Display *dpy, Window win, Colormap cmap, XVisualInfo *vip, int width, int height, GLXContext glxc, int double_buffer, int soft_cmap)
{

  /*XXX for now use private memory */
  ifp->if_mode = MODE_1MALLOC;

  /*
   *  Allocate extension memory sections,
   *  addressed by SGI(ifp)->mi_xxx and OGL(ifp)->xxx
   */

  if( (SGIL(ifp) = (char *)calloc( 1, sizeof(struct sgiinfo) )) == NULL )  {
    fb_log("ogl_open:  sgiinfo malloc failed\n");
    return -1;
  }
  if( (OGLL(ifp) = (char *)calloc( 1, sizeof(struct oglinfo) )) == NULL )  {
    fb_log("ogl_open:  oglinfo malloc failed\n");
    return -1;
  }

  OGL(ifp)->use_ext_ctrl = 1;

  SGI(ifp)->mi_shmid = -1;	/* indicate no shared memory */
  multiple_windows = 1;
  ifp->if_width = ifp->if_max_width = width;
  ifp->if_height = ifp->if_max_height = height;

  OGL(ifp)->win_width = OGL(ifp)->vp_width = width;
  OGL(ifp)->win_height = OGL(ifp)->vp_height = height;

  SGI(ifp)->mi_curs_on = 1;

  /* initialize window state variables before calling ogl_getmem */
  ifp->if_zoomflag = 0;
  ifp->if_xzoom = 1;	/* for zoom fakeout */
  ifp->if_yzoom = 1;	/* for zoom fakeout */
  ifp->if_xcenter = width/2;
  ifp->if_ycenter = height/2;
  SGI(ifp)->mi_pid = getpid();

  /* Attach to shared memory, potentially with a screen repaint */
  if(ogl_getmem(ifp) < 0)
    return -1;

  OGL(ifp)->dispp = dpy;
  ifp->if_selfd = ConnectionNumber(OGL(ifp)->dispp);

  OGL(ifp)->vip = vip;
  OGL(ifp)->glxc = glxc;
  SGI(ifp)->mi_cmap_flag = !is_linear_cmap(ifp);
  OGL(ifp)->soft_cmap_flag = soft_cmap;
  SGI(ifp)->mi_doublebuffer = double_buffer;
  OGL(ifp)->xcmap = cmap;

  OGL(ifp)->wind = win;
  ++ogl_nwindows;

  OGL(ifp)->alive = 1;
  OGL(ifp)->firstTime = 1;

  ogl_clipper(ifp);

  return 0;
}

_LOCAL_ int 
ogl_final_close(FBIO *ifp)
{

  if( CJDEBUG ) {
    printf("ogl_final_close: All done...goodbye!\n");
  }

  if(OGL(ifp)->cursor)
    XDestroyWindow(OGL(ifp)->dispp, OGL(ifp)->cursor);

  XDestroyWindow(OGL(ifp)->dispp, OGL(ifp)->wind);
  XFreeColormap(OGL(ifp)->dispp, OGL(ifp)->xcmap);

  if( SGIL(ifp) != NULL ) {
    /* free up memory associated with image */
    if( SGI(ifp)->mi_shmid != -1 ) {
      /* detach from shared memory */
      if( shmdt( ifp->if_mem ) == -1 ) {
	fb_log("ogl_close shmdt failed, errno=%d\n",
	       errno);
	return -1;
      }
    } else {
      /* free private memory */
      (void)free( ifp->if_mem );
    }
    /* free state information */
    (void)free( (char *)SGIL(ifp) );
    SGIL(ifp) = NULL;
  }

  if( OGLL(ifp) != NULL) {
    (void) free( (char *)OGLL(ifp) );
    OGLL(ifp) = NULL;
  }

  ogl_nwindows--;
  return(0);
}


_LOCAL_ int
ogl_close(FBIO *ifp)
{

	ogl_flush( ifp );

	/* only the last open window can linger -
	 * call final_close if not lingering
	 */
	if( ogl_nwindows > 1 ||
	    (ifp->if_mode & MODE_2MASK) == MODE_2TRANSIENT )
		return ogl_final_close( ifp );

	if( CJDEBUG )
		printf("ogl_close: remaining open to linger awhile.\n");

	/*
	 *  else:
	 *  LINGER mode.  Don't return to caller until user mouses "close"
	 *  menu item.  This may delay final processing in the calling
	 *  function for some time, but the assumption is that the user
	 *  wishes to compare this image with others.
	 *
	 *  Since we plan to linger here, long after our invoker
	 *  expected us to be gone, be certain that no file descriptors
	 *  remain open to associate us with pipelines, network
	 *  connections, etc., that were ALREADY ESTABLISHED before
	 *  the point that fb_open() was called.
	 *
	 *  The simple for i=0..20 loop will not work, because that
	 *  smashes some window-manager files.  Therefore, we content
	 *  ourselves with eliminating stdin, stdout, and stderr,
	 *  (fd 0,1,2), in the hopes that this will successfully
	 *  terminate any pipes or network connections.  
	 */
	fclose( stdin );
	fclose( stdout );
	fclose( stderr );

	/* Ignore likely signals, perhaps in the background,
	 * from other typing at the keyboard
	 */
	(void)signal( SIGHUP, SIG_IGN );
	(void)signal( SIGINT, SIG_IGN );
	(void)signal( SIGQUIT, SIG_IGN );
	(void)signal( SIGALRM, SIG_IGN );

	while( OGL(ifp)->alive )
		do_event(ifp);

	return 0;
}

int
ogl_close_existing(FBIO *ifp)
{
  if(OGL(ifp)->cursor)
    XDestroyWindow(OGL(ifp)->dispp, OGL(ifp)->cursor);

  if( SGIL(ifp) != NULL ) {
    /* free up memory associated with image */
    if( SGI(ifp)->mi_shmid != -1 ) {
      /* detach from shared memory */
      if( shmdt( ifp->if_mem ) == -1 ) {
	fb_log("ogl_close shmdt failed, errno=%d\n",
	       errno);
	return -1;
      }
    } else {
      /* free private memory */
      (void)free( ifp->if_mem );
    }
    /* free state information */
    (void)free( (char *)SGIL(ifp) );
    SGIL(ifp) = NULL;
  }

  if( OGLL(ifp) != NULL) {
    (void) free( (char *)OGLL(ifp) );
    OGLL(ifp) = NULL;
  }

  return 0;
}

/*
 *			O G L _ P O L L
 *
 *	Handle any pending input events
 */
_LOCAL_ int
ogl_poll(FBIO *ifp)
{
	do_event(ifp);
	return(0);
}

/*
 *			O G L _ F R E E
 *
 *  Free shared memory resources, and close.
 */
_LOCAL_ int
ogl_free(FBIO *ifp)
{
	int	ret;

	if(CJDEBUG) printf("entering  ogl_free\n");
	/* Close the framebuffer */
	ret = ogl_final_close( ifp );

	if( (ifp->if_mode & MODE_1MASK) == MODE_1SHARED ) {
		/* If shared mem, release the shared memory segment */
		ogl_zapmem();
	}
	return ret;
}


_LOCAL_ int
ogl_clear(FBIO *ifp, unsigned char *pp)
    	     
             	    		/* pointer to beginning of memory segment*/
{
	struct ogl_pixel		bg;
	register struct ogl_pixel      *oglp;
	register int			cnt;
	register int			y;

	if( CJDEBUG ) printf("entering ogl_clear\n");

	if (multiple_windows) {
		if (glXMakeCurrent(OGL(ifp)->dispp,OGL(ifp)->wind,OGL(ifp)->glxc)==False){
		fb_log("Warning, ogl_clear: glXMakeCurrent unsuccessful.\n");
		}
	}

	/* Set clear colors */
	if ( pp != RGBPIXEL_NULL)  {
		bg.alpha = 0;
		bg.red   = (pp)[RED];
		bg.green = (pp)[GRN];
		bg.blue  = (pp)[BLU];
		glClearColor( pp[RED]/255.0, pp[GRN]/255.0, pp[BLU]/255.0, 0.0 );
	} else {
		bg.alpha = 0;
		bg.red   = 0;
		bg.green = 0;
		bg.blue  = 0;
		glClearColor( 0, 0, 0, 0 );
	}

	/* Flood rectangle in shared memory */
	for( y=0; y < ifp->if_height; y++ )  {
		oglp = (struct ogl_pixel *)&ifp->if_mem[
		    (y*SGI(ifp)->mi_memwidth+0)*sizeof(struct ogl_pixel) ];
		for( cnt=ifp->if_width-1; cnt >= 0; cnt-- )  {
			*oglp++ = bg;	/* struct copy */
		}
	}


	/* Update screen */
	if(OGL(ifp)->use_ext_ctrl){
		glClear(GL_COLOR_BUFFER_BIT);
	}else{
	if ( OGL(ifp)->copy_flag){
		/* COPY mode: clear both buffers */
		if (OGL(ifp)->front_flag){
			glDrawBuffer(GL_BACK);
			glClear(GL_COLOR_BUFFER_BIT);
			glDrawBuffer(GL_FRONT);
			glClear(GL_COLOR_BUFFER_BIT);
		} else {
			glDrawBuffer(GL_FRONT);
			glClear(GL_COLOR_BUFFER_BIT);
			glDrawBuffer(GL_BACK);
			glClear(GL_COLOR_BUFFER_BIT);
		}
	} else {
		glClear(GL_COLOR_BUFFER_BIT);
		if(SGI(ifp)->mi_doublebuffer){
			glXSwapBuffers( OGL(ifp)->dispp, OGL(ifp)->wind);
		}
	}

	if (multiple_windows) {
		/* unattach context for other threads to use */
		glXMakeCurrent(OGL(ifp)->dispp,None,NULL);
	}
	}

	return(0);
}


/*
 *			O G L _ V I E W
 */
_LOCAL_ int
ogl_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
{
	struct ogl_clip *clp;

	if(CJDEBUG) printf("entering ogl_view\n");

	if( xzoom < 1 ) xzoom = 1; 
	if( yzoom < 1 ) yzoom = 1;
	if( ifp->if_xcenter == xcenter && ifp->if_ycenter == ycenter
	  && ifp->if_xzoom == xzoom && ifp->if_yzoom == yzoom )
		return(0);

	if( xcenter < 0 || xcenter >= ifp->if_width )
		return(-1);
	if( ycenter < 0 || ycenter >= ifp->if_height )
		return(-1);
	if( xzoom >= ifp->if_width || yzoom >= ifp->if_height )
		return(-1);

	ifp->if_xcenter = xcenter;
	ifp->if_ycenter = ycenter;
	ifp->if_xzoom = xzoom;
	ifp->if_yzoom = yzoom;

	if( ifp->if_xzoom > 1 || ifp->if_yzoom > 1 )
		ifp->if_zoomflag = 1;
	else	ifp->if_zoomflag = 0;


	if(OGL(ifp)->use_ext_ctrl){
		ogl_clipper(ifp);
	}else{
	if (multiple_windows) {
		if (glXMakeCurrent(OGL(ifp)->dispp,OGL(ifp)->wind,OGL(ifp)->glxc)==False){
			fb_log("Warning, ogl_view: glXMakeCurrent unsuccessful.\n");
		}
	}

	/* Set clipping matrix  and zoom level */
	glMatrixMode(GL_PROJECTION);
	if (OGL(ifp)->copy_flag && !OGL(ifp)->front_flag){
		/* COPY mode - no changes to backbuffer copy - just 
		 * need to update front buffer
		 */
		glPopMatrix();
		glDrawBuffer(GL_FRONT);
		OGL(ifp)->front_flag = 1;
	}
	glLoadIdentity();

	ogl_clipper(ifp);
	clp = &(OGL(ifp)->clip);
	glOrtho( clp->oleft, clp->oright, clp->obottom, clp->otop, -1.0, 1.0);
	glPixelZoom((float) ifp->if_xzoom,(float) ifp->if_yzoom);

	if (OGL(ifp)->copy_flag){
		backbuffer_to_screen(ifp,-1);
	} else {
		ogl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
		if(SGI(ifp)->mi_doublebuffer){
			glXSwapBuffers( OGL(ifp)->dispp, OGL(ifp)->wind);
		}
	}

	if (multiple_windows) {
		/* unattach context for other threads to use */
		glXMakeCurrent(OGL(ifp)->dispp,None,NULL);
	}
	}

	return(0);
}

/*
 *			O G L _ G E T V I E W
 */
_LOCAL_ int
ogl_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom)
{
	if(CJDEBUG) printf("entering ogl_getview\n");

	*xcenter = ifp->if_xcenter;
	*ycenter = ifp->if_ycenter;
	*xzoom = ifp->if_xzoom;
	*yzoom = ifp->if_yzoom;

	return(0);
}


_LOCAL_ int
ogl_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count) /*read count pixels into pixelp starting at x,y*/
    	     
   	     
             	        
   	      
{
	register short		scan_count;	/* # pix on this scanline */
	register unsigned char	*cp;
	int			ret;
	register unsigned int	n;
	register struct ogl_pixel	*oglp;

	if(CJDEBUG) printf("entering ogl_read\n");

	if( x < 0 || x >= ifp->if_width ||
	    y < 0 || y >= ifp->if_height)
		return(-1);

	ret = 0;
	cp = (unsigned char *)(pixelp);

	while( count )  {
		if( y >= ifp->if_height )
			break;

		if ( count >= ifp->if_width-x )
			scan_count = ifp->if_width-x;
		else
			scan_count = count;

		oglp = (struct ogl_pixel *)&ifp->if_mem[
		    (y*SGI(ifp)->mi_memwidth+x)*sizeof(struct ogl_pixel) ];

		n = scan_count;
		while( n )  {
			cp[RED] = oglp->red;
			cp[GRN] = oglp->green;
			cp[BLU] = oglp->blue;
			oglp++;
			cp += 3;
			n--;
		}
		ret += scan_count;
		count -= scan_count;
		x = 0;
		/* Advance upwards */
		if( ++y >= ifp->if_height )
			break;
	}
	return(ret);
}



_LOCAL_ int
ogl_write(FBIO *ifp, int xstart, int ystart, const unsigned char *pixelp, int count) /*write count pixels from pixelp starting at xstart,ystart*/
    	     
   	               
                   	        
   	      
{
	register short		scan_count;	/* # pix on this scanline */
	register unsigned char	*cp;
	int			ret;
	int			ybase;
	register int		pix_count;	/* # pixels to send */
	register int		x;
	register int		y;

	if(CJDEBUG) printf("entering ogl_write\n");

	/* fast exit cases */
	if( (pix_count = count) == 0 )
		return 0;	/* OK, no pixels transferred */
	if( pix_count < 0 )
		return -1;	/* ERROR */

	x = xstart;
	ybase = y = ystart;

	if( x < 0 || x >= ifp->if_width ||
	    y < 0 || y >= ifp->if_height)
		return(-1);

	ret = 0;
	cp = (unsigned char *)(pixelp);

	while( pix_count )  {
		register unsigned int n;
		register struct ogl_pixel	*oglp;

		if( y >= ifp->if_height )
			break;

		if ( pix_count >= ifp->if_width-x )
			scan_count = ifp->if_width-x;
		else
			scan_count = pix_count;

		oglp = (struct ogl_pixel *)&ifp->if_mem[
		    (y*SGI(ifp)->mi_memwidth+x)*sizeof(struct ogl_pixel) ];

		n = scan_count;
		if( (n & 3) != 0 )  {
			/* This code uses 60% of all CPU time */
			while( n )  {
				/* alpha channel is always zero */
				oglp->red   = cp[RED];
				oglp->green = cp[GRN];
				oglp->blue  = cp[BLU];
				oglp++;
				cp += 3;
				n--;
			}
		} else {
			while( n )  {
				/* alpha channel is always zero */
				oglp[0].red   = cp[RED+0*3];
				oglp[0].green = cp[GRN+0*3];
				oglp[0].blue  = cp[BLU+0*3];
				oglp[1].red   = cp[RED+1*3];
				oglp[1].green = cp[GRN+1*3];
				oglp[1].blue  = cp[BLU+1*3];
				oglp[2].red   = cp[RED+2*3];
				oglp[2].green = cp[GRN+2*3];
				oglp[2].blue  = cp[BLU+2*3];
				oglp[3].red   = cp[RED+3*3];
				oglp[3].green = cp[GRN+3*3];
				oglp[3].blue  = cp[BLU+3*3];
				oglp += 4;
				cp += 3*4;
				n -= 4;
			}
		}
		ret += scan_count;
		pix_count -= scan_count;
		x = 0;
		if( ++y >= ifp->if_height )
			break;
	}

	if( (ifp->if_mode & MODE_12MASK) == MODE_12DELAY_WRITES_TILL_FLUSH )
		return ret;

	if (multiple_windows) {
		if (glXMakeCurrent(OGL(ifp)->dispp,OGL(ifp)->wind,OGL(ifp)->glxc)==False){
			fb_log("Warning, ogl_write: glXMakeCurrent unsuccessful.\n");
		}
	}

	if(!OGL(ifp)->use_ext_ctrl){
	if( xstart + count <= ifp->if_width  )  {
		/* "Fast path" case for writes of less than one scanline.
		 * The assumption is that there will be a lot of short
		 * writes, and it's best just to ignore the backbuffer
		 */
		if ( SGI(ifp)->mi_doublebuffer ) {
			/* "turn off" doublebuffering*/
			SGI(ifp)->mi_doublebuffer = 0;
			glDrawBuffer(GL_FRONT);
		}
		ogl_xmit_scanlines( ifp, ybase, 1, xstart, count );
		if (OGL(ifp)->copy_flag){
			/* repaint one scanline from backbuffer */
			backbuffer_to_screen(ifp,ybase);
		}
	} else {
		/* Normal case -- multi-pixel write */
		if ( SGI(ifp)->mi_doublebuffer) { /* refresh whole screen */
			ogl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
			glXSwapBuffers( OGL(ifp)->dispp, OGL(ifp)->wind);
		}
		else { /* just write rectangle */
			ogl_xmit_scanlines( ifp, ybase, y-ybase, 0, ifp->if_width );
			if (OGL(ifp)->copy_flag){
				backbuffer_to_screen(ifp,-1);
			}
		}
	}

	if (multiple_windows) {
		/* unattach context for other threads to use */
		glXMakeCurrent(OGL(ifp)->dispp,None,NULL);
	}
	}

	return(ret);

}

/*
 *			O G L _ W R I T E R E C T
 *
 *  The task of this routine is to reformat the pixels into
 *  SGI internal form, and then arrange to have them sent to
 *  the screen separately.
 */
_LOCAL_ int
ogl_writerect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp)
{
	register int		x;
	register int		y;
	register unsigned char	*cp;
	register struct ogl_pixel	*oglp;

	if(CJDEBUG) printf("entering ogl_writerect\n");


	if( width <= 0 || height <= 0 )
		return(0);  /* do nothing */
	if( xmin < 0 || xmin+width > ifp->if_width ||
	    ymin < 0 || ymin+height > ifp->if_height )
		return(-1); /* no can do */

	cp = (unsigned char *)(pp);
	for( y = ymin; y < ymin+height; y++ )  {
		oglp = (struct ogl_pixel *)&ifp->if_mem[
		    (y*SGI(ifp)->mi_memwidth+xmin)*sizeof(struct ogl_pixel) ];
		for( x = xmin; x < xmin+width; x++ )  {
			/* alpha channel is always zero */
			oglp->red   = cp[RED];
			oglp->green = cp[GRN];
			oglp->blue  = cp[BLU];
			oglp++;
			cp += 3;
		}
	}

	if( (ifp->if_mode & MODE_12MASK) == MODE_12DELAY_WRITES_TILL_FLUSH )
		return width*height;

	if(!OGL(ifp)->use_ext_ctrl){
	if (multiple_windows) {
	if (glXMakeCurrent(OGL(ifp)->dispp,OGL(ifp)->wind,OGL(ifp)->glxc)==False){
		fb_log("Warning, ogl_writerect: glXMakeCurrent unsuccessful.\n");
	}
	}

	if ( SGI(ifp)->mi_doublebuffer) { /* refresh whole screen */
		ogl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
		glXSwapBuffers( OGL(ifp)->dispp, OGL(ifp)->wind);
	}
	else { /* just write rectangle*/
		ogl_xmit_scanlines( ifp, ymin, height, xmin, width );
		if (OGL(ifp)->copy_flag){
			backbuffer_to_screen(ifp,-1);
		}
	}

	if (multiple_windows) {
	/* unattach context for other threads to use */
	glXMakeCurrent(OGL(ifp)->dispp,None,NULL);
	}
	}

	return(width*height);
}


/*
 *			O G L _ B W W R I T E R E C T
 *
 *  The task of this routine is to reformat the pixels into
 *  SGI internal form, and then arrange to have them sent to
 *  the screen separately.
 */
_LOCAL_ int
ogl_bwwriterect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp)
{
	register int		x;
	register int		y;
	register unsigned char	*cp;
	register struct ogl_pixel	*oglp;

	if(CJDEBUG) printf("entering ogl_bwwriterect\n");


	if( width <= 0 || height <= 0 )
		return(0);  /* do nothing */
	if( xmin < 0 || xmin+width > ifp->if_width ||
	    ymin < 0 || ymin+height > ifp->if_height )
		return(-1); /* no can do */

	cp = (unsigned char *)(pp);
	for( y = ymin; y < ymin+height; y++ )  {
		oglp = (struct ogl_pixel *)&ifp->if_mem[
		    (y*SGI(ifp)->mi_memwidth+xmin)*sizeof(struct ogl_pixel) ];
		for( x = xmin; x < xmin+width; x++ )  {
			register int	val;
			/* alpha channel is always zero */
			oglp->red   = (val = *cp++);
			oglp->green = val;
			oglp->blue  = val;
			oglp++;
		}
	}

	if( (ifp->if_mode & MODE_12MASK) == MODE_12DELAY_WRITES_TILL_FLUSH )
		return width*height;

	if(!OGL(ifp)->use_ext_ctrl){
	if (multiple_windows) {
	if (glXMakeCurrent(OGL(ifp)->dispp,OGL(ifp)->wind,OGL(ifp)->glxc)==False){
		fb_log("Warning, ogl_writerect: glXMakeCurrent unsuccessful.\n");
	}
	}

	if ( SGI(ifp)->mi_doublebuffer) { /* refresh whole screen */
		ogl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
		glXSwapBuffers( OGL(ifp)->dispp, OGL(ifp)->wind);
	}
	else { /* just write rectangle*/
		ogl_xmit_scanlines( ifp, ymin, height, xmin, width );
		if (OGL(ifp)->copy_flag){
			backbuffer_to_screen(ifp,-1);
		}
	}

	if (multiple_windows) {
	/* unattach context for other threads to use */
	glXMakeCurrent(OGL(ifp)->dispp,None,NULL);
	}
	}

	return(width*height);
}



_LOCAL_ int	
ogl_rmap(register FBIO *ifp, register ColorMap *cmp)
{
	register int i;

	if(CJDEBUG) printf("entering ogl_rmap\n");

	/* Just parrot back the stored colormap */
	for( i = 0; i < 256; i++)  {
		cmp->cm_red[i]   = CMR(ifp)[i]<<8;
		cmp->cm_green[i] = CMG(ifp)[i]<<8;
		cmp->cm_blue[i]  = CMB(ifp)[i]<<8;
	}
	return(0);
}

/*
 *			I S _ L I N E A R _ C M A P
 *
 *  Check for a color map being linear in R, G, and B.
 *  Returns 1 for linear map, 0 for non-linear map
 *  (ie, non-identity map).
 */
_LOCAL_ int
is_linear_cmap(register FBIO *ifp)
{
	register int i;

	for( i=0; i<256; i++ )  {
		if( CMR(ifp)[i] != i )  return(0);
		if( CMG(ifp)[i] != i )  return(0);
		if( CMB(ifp)[i] != i )  return(0);
	}
	return(1);
}

/*
 *			O G L _ C M I N I T
 */
_LOCAL_ void
ogl_cminit(register FBIO *ifp)
{
	register int	i;

	for( i = 0; i < 256; i++)  {
		CMR(ifp)[i] = i;
		CMG(ifp)[i] = i;
		CMB(ifp)[i] = i;
	}
}

/*
 *			 O G L _ W M A P
 */
_LOCAL_ int
ogl_wmap(register FBIO *ifp, register const ColorMap *cmp)
{
	register int	i;
	int		prev;	/* !0 = previous cmap was non-linear */
	
	if(CJDEBUG) printf("entering ogl_wmap\n");

	prev = SGI(ifp)->mi_cmap_flag;
	if ( cmp == COLORMAP_NULL)  {
		ogl_cminit( ifp );
	} else {
		for(i = 0; i < 256; i++)  {
			CMR(ifp)[i] = cmp-> cm_red[i]>>8;
			CMG(ifp)[i] = cmp-> cm_green[i]>>8; 
			CMB(ifp)[i] = cmp-> cm_blue[i]>>8;
		}
	}
	SGI(ifp)->mi_cmap_flag = !is_linear_cmap(ifp);


	if(!OGL(ifp)->use_ext_ctrl){
	if( OGL(ifp)->soft_cmap_flag )  {
		/* if current and previous maps are linear, return */
		if( SGI(ifp)->mi_cmap_flag == 0 && prev == 0 )  return(0);

		/* Software color mapping, trigger a repaint */

		if (multiple_windows) {
		if (glXMakeCurrent(OGL(ifp)->dispp,OGL(ifp)->wind,OGL(ifp)->glxc)==False){
			fb_log("Warning, ogl_wmap: glXMakeCurrent unsuccessful.\n");
		}
		}

		ogl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
		if(SGI(ifp)->mi_doublebuffer){
			glXSwapBuffers( OGL(ifp)->dispp, OGL(ifp)->wind);
		} else if (OGL(ifp)->copy_flag) {
			backbuffer_to_screen(ifp,-1);
		}
		if (multiple_windows) {
		/* unattach context for other threads to use, also flushes */
		glXMakeCurrent(OGL(ifp)->dispp,None,NULL);
		}
	} else {
		/* Send color map to hardware */
		/* This code has yet to be tested */

	    	for (i = 0; i < 256; i++) {
	    		color_cell[i].pixel = i;
	    		color_cell[i].red = CMR(ifp)[i];
	    		color_cell[i].green = CMG(ifp)[i];
	    		color_cell[i].blue = CMB(ifp)[i];
	    		color_cell[i].flags = DoRed | DoGreen | DoBlue;
	    	}
    		XStoreColors(OGL(ifp)->dispp, OGL(ifp)->xcmap, color_cell, 256);
	}
	}

	return(0);
}

/*
 *			O G L _ H E L P
 */
_LOCAL_ int
ogl_help(FBIO *ifp)
{
	struct	modeflags *mfp;
	XVisualInfo *visual = OGL(ifp)->vip;

	fb_log( "Description: %s\n", ifp->if_type );
	fb_log( "Device: %s\n", ifp->if_name );
	fb_log( "Max width height: %d %d\n",
		ifp->if_max_width,
		ifp->if_max_height );
	fb_log( "Default width height: %d %d\n",
		ifp->if_width,
		ifp->if_height );
	fb_log( "Usage: /dev/ogl[option letters]\n" );
	for( mfp = modeflags; mfp->c != '\0'; mfp++ ) {
		fb_log( "   %c   %s\n", mfp->c, mfp->help );
	}

	fb_log( "\nCurrent internal state:\n");
	fb_log( "	mi_doublebuffer=%d\n", SGI(ifp)->mi_doublebuffer );
	fb_log( "	mi_cmap_flag=%d\n", SGI(ifp)->mi_cmap_flag );
	fb_log( "	ogl_nwindows=%d\n", ogl_nwindows );
	fb_log( "	multiple_windows=%d\n", multiple_windows );

	fb_log("X11 Visual:\n");

	switch(visual->class) {
	case DirectColor:
		fb_log("\tDirectColor: Alterable RGB maps, pixel RGB subfield indicies\n");
		fb_log("\tRGB Masks: 0x%x 0x%x 0x%x\n", visual->red_mask,
		       visual->green_mask, visual->blue_mask);
		break;
	case TrueColor:
		fb_log("\tTrueColor: Fixed RGB maps, pixel RGB subfield indicies\n");
		fb_log("\tRGB Masks: 0x%x 0x%x 0x%x\n", visual->red_mask,
		       visual->green_mask, visual->blue_mask);
		break;
	case PseudoColor:
		fb_log("\tPseudoColor: Alterable RGB maps, single index\n");
		break;
	case StaticColor:
		fb_log("\tStaticColor: Fixed RGB maps, single index\n");
		break;
	case GrayScale:
		fb_log("\tGrayScale: Alterable map (R=G=B), single index\n");
		break;
	case StaticGray:
		fb_log("\tStaticGray: Fixed map (R=G=B), single index\n");
		break;
	default:
		fb_log("\tUnknown visual class %d\n",
		       visual->class);
		break;
	}
	fb_log("\tColormap Size: %d\n", visual->colormap_size);
	fb_log("\tBits per RGB: %d\n", visual->bits_per_rgb);
	fb_log("\tscreen: %d\n", visual->screen);
	fb_log("\tdepth (total bits per pixel): %d\n", visual->depth);
	if( visual->depth < 24 )
		fb_log("\tWARNING: unable to obtain full 24-bits of color, image will be quantized.\n");

	return 0;
}


_LOCAL_ int
ogl_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig)
{
  return 0;
}


_LOCAL_ int
ogl_cursor(FBIO *ifp, int mode, int x, int y)
{
  if(mode){
    register int xx, xy;
    register int delta;

    /* If we don't have a cursor, create it */
    if (!OGL(ifp)->cursor) {
      XSetWindowAttributes xswa;
      XColor rgb_db_def;
      XColor bg, bd;

      XAllocNamedColor(OGL(ifp)->dispp, OGL(ifp)->xcmap, "black",
		       &rgb_db_def, &bg);
      XAllocNamedColor(OGL(ifp)->dispp, OGL(ifp)->xcmap, "white",
		       &rgb_db_def, &bd);
      xswa.background_pixel = bg.pixel;
      xswa.border_pixel = bd.pixel;
      xswa.colormap = OGL(ifp)->xcmap;
      xswa.save_under = True;

      OGL(ifp)->cursor = XCreateWindow(OGL(ifp)->dispp, OGL(ifp)->wind,
				     0, 0, 4, 4, 2, OGL(ifp)->vip->depth, InputOutput,
				     OGL(ifp)->vip->visual, CWBackPixel | CWBorderPixel |
				     CWSaveUnder | CWColormap, &xswa);
    }

    delta = ifp->if_width/ifp->if_xzoom/2;
    xx = x - (ifp->if_xcenter - delta);
    xx *= ifp->if_xzoom;
    xx += ifp->if_xzoom/2;  /* center cursor */

    delta = ifp->if_height/ifp->if_yzoom/2;
    xy = y - (ifp->if_ycenter - delta);
    xy *= ifp->if_yzoom;
    xy += ifp->if_yzoom/2;  /* center cursor */
    xy = OGL(ifp)->win_height - xy;

    /* Move cursor into place; make it visible if it isn't */
    XMoveWindow(OGL(ifp)->dispp, OGL(ifp)->cursor, xx - 4, xy - 4);

    /* if cursor window is currently not mapped, map it */
    if (!ifp->if_cursmode)
      XMapRaised(OGL(ifp)->dispp, OGL(ifp)->cursor);
  } else {
    /* If we have a cursor and it's mapped, unmap it */
    if (OGL(ifp)->cursor && ifp->if_cursmode)
      XUnmapWindow(OGL(ifp)->dispp, OGL(ifp)->cursor);
  }

  /* Without this flush, cursor movement is sluggish */
  XFlush(OGL(ifp)->dispp);

  /* Update position of cursor */
  ifp->if_cursmode = mode;
  ifp->if_xcurs = x;
  ifp->if_ycurs = y;

  return(0);
}



_LOCAL_ int
ogl_flush(FBIO *ifp)
{
	if( (ifp->if_mode & MODE_12MASK) == MODE_12DELAY_WRITES_TILL_FLUSH )  {
		if (multiple_windows) {
			if (glXMakeCurrent(OGL(ifp)->dispp,OGL(ifp)->wind,OGL(ifp)->glxc)==False){
				fb_log("Warning, ogl_flush: glXMakeCurrent unsuccessful.\n");
			}
		}
		/* Send entire in-memory buffer to the screen, all at once */
		ogl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
		if ( SGI(ifp)->mi_doublebuffer) {
			glXSwapBuffers( OGL(ifp)->dispp, OGL(ifp)->wind);
		} else {
			if (OGL(ifp)->copy_flag){
				backbuffer_to_screen(ifp,-1);
			}
		}
	}
	XFlush(OGL(ifp)->dispp);
	glFlush();
	return(0);
}

#if 0
_LOCAL_ int 
fb_cnull(ifp)
FBIO *ifp;
{
	return(0);
}
#endif

/*
 * O G L _ C L I P P E R ( ) 
 * 
 * Given:- the size of the viewport in pixels (vp_width, vp_height)
 *	 - the size of the framebuffer image (if_width, if_height)
 *	 - the current view center (if_xcenter, if_ycenter)
 * 	 - the current zoom (if_xzoom, if_yzoom)
 * Calculate:
 *	 - the position of the viewport in image space
 *		(xscrmin,xscrmax,yscrmin,yscrmax)
 *	 - the portion of the image which is visible in the viewport
 *		(xpixmin,xpixmax,ypixmin,ypixmax)
 */
void
ogl_clipper(register FBIO *ifp)
{
	register struct ogl_clip *clp;
	register int	i;
	double pixels;

	clp = &(OGL(ifp)->clip);

	i = OGL(ifp)->vp_width/(2*ifp->if_xzoom);
	clp->xscrmin = ifp->if_xcenter - i;
	i = OGL(ifp)->vp_width/ifp->if_xzoom;
	clp->xscrmax = clp->xscrmin + i;
	pixels = (double) i;
	clp->oleft = ((double) clp->xscrmin) - 0.25*pixels/((double) OGL(ifp)->vp_width);
	clp->oright = clp->oleft + pixels;

	i = OGL(ifp)->vp_height/(2*ifp->if_yzoom);
	clp->yscrmin = ifp->if_ycenter - i;
	i = OGL(ifp)->vp_height/ifp->if_yzoom;
	clp->yscrmax = clp->yscrmin + i;
	pixels = (double) i;
	clp->obottom = ((double) clp->yscrmin) - 0.25*pixels/((double) OGL(ifp)->vp_height);
	clp->otop = clp->obottom + pixels;

	clp->xpixmin = clp->xscrmin;
	clp->xpixmax = clp->xscrmax;
	clp->ypixmin = clp->yscrmin;
	clp->ypixmax = clp->yscrmax;

	if( clp->xpixmin < 0 )  {
		clp->xpixmin = 0;
	}

	if( clp->ypixmin < 0 )  {
		clp->ypixmin = 0;
	}

	/* In copy mode, the backbuffer copy image is limited
	 * to the viewport size; use that for clipping.
	 * Otherwise, use size of framebuffer memory segment
	 */
	if (OGL(ifp)->copy_flag) {
		if( clp->xpixmax > OGL(ifp)->vp_width-1 )  {
			clp->xpixmax = OGL(ifp)->vp_width-1;
		}
		if( clp->ypixmax > OGL(ifp)->vp_height-1 )  {
			clp->ypixmax = OGL(ifp)->vp_height-1;
		}
	} else {
		if( clp->xpixmax > ifp->if_width-1 )  {
			clp->xpixmax = ifp->if_width-1;
		}
		if( clp->ypixmax > ifp->if_height-1 )  {
			clp->ypixmax = ifp->if_height-1;
		}
	}

}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *	Call back routines and so on				   *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 */

_LOCAL_ void
do_event(FBIO *ifp)
{
  XEvent event;

  while (XCheckWindowEvent(OGL(ifp)->dispp, OGL(ifp)->wind,
			   OGL(ifp)->event_mask, &event)) {
    switch (event.type) {
    case Expose:
      if(!OGL(ifp)->use_ext_ctrl)
	expose_callback(ifp, &event);
      break;
    case ButtonPress:
      break;
    case ButtonRelease:
      OGL(ifp)->alive = 0;
      break;
    case KeyPress:
      break;
    case KeyRelease:
      OGL(ifp)->alive = 0;
      break;
    case ConfigureNotify:
      {
	XConfigureEvent *conf = (XConfigureEvent *)&event;

	if(conf->width == OGL(ifp)->win_width &&
	   conf->height == OGL(ifp)->win_height)
	  return;

	ogl_configureWindow(ifp, conf->width, conf->height);
      }
    default:
      break;
    }
  }
}

_LOCAL_ void
expose_callback(FBIO *ifp, XEvent *eventPtr)
{    
	XWindowAttributes xwa;
	struct ogl_clip *clp;

	if( CJDEBUG ) fb_log("entering expose_callback()\n");


	if( multiple_windows || OGL(ifp)->firstTime ) {
		if( glXMakeCurrent(OGL(ifp)->dispp, OGL(ifp)->wind,
				   OGL(ifp)->glxc) == False) {
			fb_log("Warning, libfb/expose_callback: glXMakeCurrent unsuccessful.\n");
		}
	}

	if( OGL(ifp)->firstTime ) {
		OGL(ifp)->firstTime = 0;
		
		/* just in case the configuration is double buffered but
		 * we want to pretend it's not
		 */

		if( !SGI(ifp)->mi_doublebuffer ) {
			glDrawBuffer(GL_FRONT);
		}

		if( (ifp->if_mode & MODE_4MASK) == MODE_4NODITH ) {
			glDisable(GL_DITHER);
		}

		/* set copy mode if possible and requested */
		if( SGI(ifp)->mi_doublebuffer && 
		    ((ifp->if_mode & MODE_11MASK)==MODE_11COPY) ) {
			/* Copy mode only works if there are two 
			 * buffers to use. It conflicts with
			 * double buffering
			 */
			OGL(ifp)->copy_flag = 1;
			SGI(ifp)->mi_doublebuffer = 0;
			OGL(ifp)->front_flag = 1;
			glDrawBuffer(GL_FRONT);
		} else {
			OGL(ifp)->copy_flag = 0;
		}

		XGetWindowAttributes(OGL(ifp)->dispp, OGL(ifp)->wind, &xwa);
		OGL(ifp)->win_width = xwa.width;
		OGL(ifp)->win_height = xwa.height;

		/* clear entire window */
		glViewport(0, 0, OGL(ifp)->win_width, OGL(ifp)->win_height);
		glClearColor(0,0,0,0);
		glClear(GL_COLOR_BUFFER_BIT);

		/* Set normal viewport size to minimum of actual window
		 * size and requested framebuffer size
		 */
		OGL(ifp)->vp_width = (OGL(ifp)->win_width < ifp->if_width) ?
				OGL(ifp)->win_width : ifp->if_width;
		OGL(ifp)->vp_height = (OGL(ifp)->win_height < ifp->if_height) ?
				OGL(ifp)->win_height : ifp->if_height;
		ifp->if_xcenter = OGL(ifp)->vp_width/2;
		ifp->if_ycenter = OGL(ifp)->vp_height/2;

		/* center viewport in window */
		SGI(ifp)->mi_xoff=(OGL(ifp)->win_width-OGL(ifp)->vp_width)/2;
		SGI(ifp)->mi_yoff=(OGL(ifp)->win_height-OGL(ifp)->vp_height)/2;
		glViewport(SGI(ifp)->mi_xoff,
			   SGI(ifp)->mi_yoff,
			   OGL(ifp)->vp_width,
			   OGL(ifp)->vp_height);
		/* initialize clipping planes and zoom */
		ogl_clipper(ifp);
		clp = &(OGL(ifp)->clip);
		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();
		glOrtho( clp->oleft, clp->oright, clp->obottom, clp->otop,
				-1.0,1.0);
		glPixelZoom((float) ifp->if_xzoom,(float) ifp->if_yzoom);
	} else if( (OGL(ifp)->win_width > ifp->if_width) || 
		   (OGL(ifp)->win_height > ifp->if_height) ) {
		/* clear whole buffer if window larger than framebuffer */
	 	if( OGL(ifp)->copy_flag && !OGL(ifp)->front_flag ) {
	 		glDrawBuffer(GL_FRONT);
			glViewport(0, 0, OGL(ifp)->win_width,
				   OGL(ifp)->win_height);      
			glClearColor(0,0,0,0);
			glClear(GL_COLOR_BUFFER_BIT);
	 		glDrawBuffer(GL_BACK);
	 	} else {
			glViewport(0, 0, OGL(ifp)->win_width,
				   OGL(ifp)->win_height);      
			glClearColor(0,0,0,0);
			glClear(GL_COLOR_BUFFER_BIT);
	 	}
	 	/* center viewport */
		glViewport(SGI(ifp)->mi_xoff,
			   SGI(ifp)->mi_yoff,
			   OGL(ifp)->vp_width,
			   OGL(ifp)->vp_height);
	}

	/* repaint entire image */
	ogl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
	if( SGI(ifp)->mi_doublebuffer ) {
		glXSwapBuffers( OGL(ifp)->dispp, OGL(ifp)->wind);
	} else if( OGL(ifp)->copy_flag ) {
		backbuffer_to_screen(ifp,-1);
	}

	if( CJDEBUG ) {
		int dbb,db,view[4],getster,getaux;
		glGetIntegerv(GL_VIEWPORT, view);
		glGetIntegerv(GL_DOUBLEBUFFER,&dbb);
		glGetIntegerv(GL_DRAW_BUFFER,&db);
		fb_log("Viewport: x %d y %d width %d height %d\n",view[0],
		       view[1],view[2],view[3]);
		fb_log("expose: double buffered: %d, draw buffer %d\n",dbb,db);
		fb_log("front %d\tback%d\n",GL_FRONT,GL_BACK);
		glGetIntegerv(GL_STEREO,&getster);
		glGetIntegerv(GL_AUX_BUFFERS,&getaux);
		fb_log("double %d, stereo %d, aux %d\n",dbb,getster,getaux);
	}

	if( multiple_windows ) {
		/* unattach context for other threads to use */
		glXMakeCurrent(OGL(ifp)->dispp,None,NULL);
	}
#if 0
	XFlush(OGL(ifp)->dispp);
	glFlush();
#endif
}  

void
ogl_configureWindow(FBIO *ifp, int width, int height)
{
  if(width == OGL(ifp)->win_width &&
     height == OGL(ifp)->win_height)
    return;

  ifp->if_width = ifp->if_max_width = width;
  ifp->if_height = ifp->if_max_height = height;

  OGL(ifp)->win_width = OGL(ifp)->vp_width = width;
  OGL(ifp)->win_height = OGL(ifp)->vp_height = height;

  ifp->if_zoomflag = 0;
  ifp->if_xzoom = 1;
  ifp->if_yzoom = 1;
  ifp->if_xcenter = width/2;
  ifp->if_ycenter = height/2;

  ogl_getmem(ifp);
  ogl_clipper(ifp);
}

#if 0
/* reorder_cursor - reverses the order of the scanlines. 
 * scanlines are byte aligned, the specified cursor is xbits
 * by ybits bits in size.
 *
 */
_LOCAL_ void	
reorder_cursor(char *dst,char *src, int xbits, int ybits)
{
	int xbytes;
	int i,j,k;

	if( (xbytes = xbits /8) * 8 != xbits)
		xbytes++;

	for (j=0, k=(ybits-1)*xbytes; j < ybits*xbytes; j+=xbytes, k-=xbytes){
		for (i=0; i < xbytes; i++){
			dst[j+i] = src[k+i];
		}
	}

}
#endif

/* BACKBUFFER_TO_SCREEN - copy pixels from copy on the backbuffer
 * to the front buffer. Do one scanline specified by one_y, or whole
 * screen if one_y equals -1.
 */
_LOCAL_ void
backbuffer_to_screen(register FBIO *ifp, int one_y)
{
	struct ogl_clip *clp;

	if (!(OGL(ifp)->front_flag)){
		OGL(ifp)->front_flag = 1;
		glDrawBuffer(GL_FRONT);
		glMatrixMode(GL_PROJECTION);
		glPopMatrix();
		glPixelZoom((float) ifp->if_xzoom,(float) ifp->if_yzoom);
	}
	
	clp = &(OGL(ifp)->clip);

	if (one_y > clp->ypixmax) {
		return;
	} else if (one_y < 0) { /* do whole visible screen */

		/* Blank out area left of image */
		glColor3b( 0, 0, 0 );
		if( clp->xscrmin < 0 )  glRecti(
			clp->xscrmin - CLIP_XTRA,
			clp->yscrmin - CLIP_XTRA,
			CLIP_XTRA,
			clp->yscrmax + CLIP_XTRA);

		/* Blank out area below image */
		if( clp->yscrmin < 0 )  glRecti(
			clp->xscrmin - CLIP_XTRA,
			clp->yscrmin - CLIP_XTRA,
			clp->xscrmax + CLIP_XTRA,
			CLIP_XTRA);

		/* We are in copy mode, so we use vp_width rather
		 * than if_width
		 */
		/* Blank out area right of image */
		if( clp->xscrmax >= OGL(ifp)->vp_width )  glRecti(
			ifp->if_width - CLIP_XTRA,
			clp->yscrmin - CLIP_XTRA,
			clp->xscrmax + CLIP_XTRA,
			clp->yscrmax + CLIP_XTRA);
		
		/* Blank out area above image */
		if( clp->yscrmax >= OGL(ifp)->vp_height )  glRecti(
			clp->xscrmin - CLIP_XTRA,
			OGL(ifp)->vp_height - CLIP_XTRA,
			clp->xscrmax + CLIP_XTRA,
			clp->yscrmax + CLIP_XTRA);

		/* copy image from backbuffer */
		glRasterPos2i(clp->xpixmin,clp->ypixmin);
		glCopyPixels(SGI(ifp)->mi_xoff + clp->xpixmin,
			SGI(ifp)->mi_yoff + clp->ypixmin,
			clp->xpixmax - clp->xpixmin +1,
			clp->ypixmax - clp->ypixmin +1,
			GL_COLOR);


	} else if (one_y < clp->ypixmin) {
		return;
	} else { /* draw one scanline */
		glRasterPos2i(clp->xpixmin,one_y);
		glCopyPixels(SGI(ifp)->mi_xoff + clp->xpixmin,
			SGI(ifp)->mi_yoff + one_y,
			clp->xpixmax - clp->xpixmin +1,
			1,
			GL_COLOR);
	}
}

/* 		O G L _ C H O O S E _ V I S U A L
 *
 * Select an appropriate visual, and set flags.
 * 
 * The user requires support for:
 *    	-OpenGL rendering in RGBA mode
 * 	
 * The user may desire support for:
 *	-a single-buffered OpenGL context
 *	-a double-buffered OpenGL context
 *	-hardware colormapping (DirectColor)
 *	
 * We first try to satisfy all requirements and desires. If that fails,
 * we remove the desires one at a time until we succeed or until only
 * requirements are left. If at any stage more than one visual meets the
 * current criteria, the visual with the greatest depth is chosen.
 * 
 * The following flags are set:
 * 	SGI(ifp)->mi_doublebuffer
 *	OGL(ifp)->soft_cmap_flag
 *
 * Return NULL on failure.
 */
_LOCAL_ XVisualInfo *
ogl_choose_visual(FBIO *ifp)
{

	XVisualInfo *vip, *vibase, *maxvip, template;
#define NGOOD 200
	int good[NGOOD];
	int num, i, j;
	int m_hard_cmap, m_sing_buf, m_doub_buf;
	int use, rgba, dbfr;
	
	m_hard_cmap = ((ifp->if_mode & MODE_7MASK)==MODE_7NORMAL);
	m_sing_buf  = ((ifp->if_mode & MODE_9MASK)==MODE_9SINGLEBUF);
	m_doub_buf =  !m_sing_buf;

	bzero((void *)&template, sizeof(XVisualInfo));
	
	/* get a list of all visuals on this display */	
	vibase = XGetVisualInfo(OGL(ifp)->dispp, 0, &template, &num);
	while (1) {

		/* search for all visuals matching current criteria */
		for (i=0, j=0, vip=vibase; i<num; i++, vip++){
			/* requirements */
			glXGetConfig(OGL(ifp)->dispp,vip,GLX_USE_GL,&use);
			if( !use)
				continue;
			glXGetConfig(OGL(ifp)->dispp,vip,GLX_RGBA,&rgba);
			if (!rgba)
				continue;
			/* desires */
			/* X_CreateColormap needs a DirectColor visual */
			/* There should be some way of handling this with TrueColor,
			 * for example:
			    visual id:    0x50
			    class:    TrueColor
			    depth:    24 planes
			    available colormap entries:    256 per subfield
			    red, green, blue masks:    0xff0000, 0xff00, 0xff
			    significant bits in color specification:    8 bits
			 */
			if ( (m_hard_cmap) && (vip->class!=DirectColor))
				continue;
			if ( (m_hard_cmap) && (vip->colormap_size<256))
				continue;
			glXGetConfig(OGL(ifp)->dispp,vip,GLX_DOUBLEBUFFER,&dbfr);
			if ( (m_doub_buf) && (!dbfr) )
				continue;
			if ( (m_sing_buf) && (dbfr) )
				continue;

			/* this visual meets criteria */
			if( j >= NGOOD-1 )  {
				fb_log("ogl_open:  More than %d candidate visuals!\n", NGOOD);
				break;
			}
			good[j++] = i;
		}
		
		/* from list of acceptable visuals,
		 * choose the visual with the greatest depth */
		if (j>=1){
			maxvip = vibase + good[0];
			for (i=1; i<j; i++) {
				vip = vibase + good[i];
				if (vip->depth >= maxvip->depth) {
					maxvip = vip;
				}
			}
			/* set flags and return choice */
			OGL(ifp)->soft_cmap_flag = !m_hard_cmap;
			SGI(ifp)->mi_doublebuffer = m_doub_buf;
			return (maxvip);
		}

		/* if no success at this point,
		 * relax one of the criteria and try again.
		 */
		if (m_hard_cmap) {
			/* relax hardware colormap requirement */
			m_hard_cmap = 0;
			fb_log("ogl_open: hardware colormapping not available. Using software colormap.\n");
		} else if (m_sing_buf) {
			/* relax single buffering requirement.
			 * no need for any warning - we'll just use 
			 * the front buffer 
			 */
			m_sing_buf = 0;
		} else if (m_doub_buf) {
			/* relax double buffering requirement. */
			m_doub_buf = 0;
			fb_log("ogl_open: double buffering not available. Using single buffer.\n");
		} else {
			/* nothing else to relax */
			return(NULL);
		}

	}
		
}

int
ogl_refresh(FBIO *ifp, int x, int y, int w, int h)
{
  int mm;
  struct ogl_clip *clp;

  if(w < 0){
    w = -w;
    x -= w;
  }

  if(h < 0){
    h = -h;
    y -= h;
  }

#if 0
  if(glIsEnabled(GL_DEPTH_TEST)){
    glDisable(GL_DEPTH_TEST);
    dflag = 1;
  }
#endif

  glGetIntegerv(GL_MATRIX_MODE, &mm);
  glMatrixMode(GL_PROJECTION);
  glPushMatrix();
  glLoadIdentity();

#if 0
  glOrtho(0.0, OGL(ifp)->win_width, 0.0, OGL(ifp)->win_height, -1.0, 1.0);
#else
  ogl_clipper(ifp);
  clp = &(OGL(ifp)->clip);
  glOrtho( clp->oleft, clp->oright, clp->obottom, clp->otop, -1.0, 1.0);
  glPixelZoom((float) ifp->if_xzoom,(float) ifp->if_yzoom);
#endif
  glMatrixMode(GL_MODELVIEW);
  glPushMatrix();
  glLoadIdentity();
#if 0
  glTranslatef(0.0, 0.0, -1.0);
#endif
  glViewport(0, 0, OGL(ifp)->win_width, OGL(ifp)->win_height);
  ogl_xmit_scanlines(ifp, y, h, x, w);
  glMatrixMode(GL_PROJECTION);
  glPopMatrix();
  glMatrixMode(GL_MODELVIEW);
  glPopMatrix();
  glMatrixMode(mm);

#if 0
  if(dflag)
    glEnable(GL_DEPTH_TEST);
#endif

  glFlush();
  return 0;
}
@


1.39
log
@change conf.h to a wrapped config.h
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/libfb/if_ogl.c,v 1.38 2004/04/05 07:44:42 morrison Exp $ (ARL)";
@


1.38
log
@merge of ansi-6-0-branch into HEAD
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d30 5
a34 1
#include "conf.h"
@


1.37
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ogl.c,v 1.35 2001/04/20 22:29:14 morrison Exp $ (ARL)";
d68 2
a69 2
_LOCAL_ void		do_event();
_LOCAL_ void		expose_callback();
d73 4
a76 4
_LOCAL_ void		ogl_clipper();
_LOCAL_ int		ogl_getmem();
_LOCAL_ void		backbuffer_to_screen();
_LOCAL_ void		ogl_cminit();
d80 2
a81 2
_LOCAL_ XVisualInfo *	ogl_choose_visual();
_LOCAL_ int		is_linear_cmap();
d90 16
a105 16
int ogl_refresh();
int ogl_open_existing();
int ogl_close_existing();
int _ogl_open_existing();

_LOCAL_ int	ogl_open(),
		ogl_close(),
		ogl_clear(),
		ogl_read(),
		ogl_write(),
		ogl_rmap(),
		ogl_wmap(),
		ogl_view(),
		ogl_getview(),
		ogl_setcursor(),
		ogl_cursor(),
d111 6
a116 6
		ogl_writerect(),
		ogl_bwwriterect(),
		ogl_poll(),
		ogl_flush(),
		ogl_free(),
		ogl_help();
d384 1
a384 2
ogl_getmem( ifp )
FBIO	*ifp;
d506 1
a506 1
ogl_zapmem()
d529 2
a530 2
sigkid( pid )
int pid;
d532 1
a532 1
sigkid()
d546 1
a546 6
ogl_xmit_scanlines( ifp, ybase, nlines, xbase, npix )
register FBIO	*ifp;
int		ybase;
int		nlines;
int		xbase;
int		npix;
d669 1
a669 4
ogl_open( ifp, file, width, height ) 
FBIO	*ifp;
char	*file;
int	width, height;
d990 1
a990 4
ogl_open_existing(ifp, argc, argv)
FBIO *ifp;
int argc;
char **argv;
d1037 1
a1037 11
_ogl_open_existing(ifp, dpy, win, cmap, vip, width, height, glxc, double_buffer, soft_cmap)
FBIO *ifp;
Display *dpy;
Window win;
Colormap cmap;
XVisualInfo *vip;
int width;
int height;
GLXContext glxc;
int double_buffer;
int soft_cmap;
d1103 1
a1103 2
ogl_final_close( ifp )
FBIO	*ifp;
d1145 1
a1145 2
ogl_close( ifp )
FBIO	*ifp;
d1198 1
a1198 2
ogl_close_existing(ifp)
FBIO *ifp;
d1235 1
a1235 2
ogl_poll(ifp)
FBIO	*ifp;
d1247 1
a1247 2
ogl_free( ifp )
FBIO	*ifp;
d1264 3
a1266 3
ogl_clear( ifp, pp )
FBIO	*ifp;
unsigned char	*pp;		/* pointer to beginning of memory segment*/
d1344 1
a1344 4
ogl_view( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	xcenter, ycenter;
int	xzoom, yzoom;
d1421 1
a1421 4
ogl_getview( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	*xcenter, *ycenter;
int	*xzoom, *yzoom;
d1435 5
a1439 5
ogl_read( ifp, x, y, pixelp, count ) /*read count pixels into pixelp starting at x,y*/
FBIO	*ifp;
int	x, y;
unsigned char	*pixelp;
int	count;
d1490 5
a1494 5
ogl_write( ifp, xstart, ystart, pixelp, count ) /*write count pixels from pixelp starting at xstart,ystart*/
FBIO	*ifp;
int	xstart, ystart;
const unsigned char	*pixelp;
int	count;
d1633 1
a1633 5
ogl_writerect( ifp, xmin, ymin, width, height, pp )
FBIO		*ifp;
int		xmin, ymin;
int		width, height;
const unsigned char	*pp;
d1702 1
a1702 5
ogl_bwwriterect( ifp, xmin, ymin, width, height, pp )
FBIO		*ifp;
int		xmin, ymin;
int		width, height;
const unsigned char	*pp;
d1765 1
a1765 3
ogl_rmap( ifp, cmp )
register FBIO	*ifp;
register ColorMap	*cmp;
d1788 1
a1788 2
is_linear_cmap(ifp)
register FBIO	*ifp;
d1804 1
a1804 2
ogl_cminit( ifp )
register FBIO	*ifp;
d1819 1
a1819 3
ogl_wmap( ifp, cmp )
register FBIO	*ifp;
register const ColorMap	*cmp;
d1884 1
a1884 2
ogl_help( ifp )
FBIO	*ifp;
d1950 1
a1950 5
ogl_setcursor( ifp, bits, xbits, ybits, xorig, yorig )
FBIO	*ifp;
const unsigned char *bits;
int	xbits, ybits;
int	xorig, yorig;
d1957 1
a1957 4
ogl_cursor( ifp, mode, x, y )	
FBIO	*ifp;
int	mode;
int	x, y;
d2021 1
a2021 2
ogl_flush( ifp )
FBIO	*ifp;
d2067 1
a2067 2
ogl_clipper( ifp )
register FBIO	*ifp;
d2133 1
a2133 2
do_event(ifp)
FBIO *ifp;	
d2171 1
a2171 3
expose_callback(ifp, eventPtr)
FBIO *ifp;
XEvent *eventPtr;
d2306 1
a2306 3
ogl_configureWindow(ifp, width, height)
FBIO *ifp;
int width, height;
d2357 1
a2357 3
backbuffer_to_screen(ifp, one_y)
register FBIO	*ifp;
int		one_y;
d2452 1
a2452 2
ogl_choose_visual(ifp)
FBIO *ifp;
d2553 1
a2553 3
ogl_refresh(ifp, x, y, w, h)
FBIO *ifp;
int x, y, w, h;
@


1.37.2.1
log
@Initial ANSIfication
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ogl.c,v 1.37 2002/08/20 17:07:47 jra Exp $ (ARL)";
d68 2
a69 2
_LOCAL_ void		do_event(FBIO *ifp);
_LOCAL_ void		expose_callback(FBIO *ifp, XEvent *eventPtr);
d73 4
a76 4
_LOCAL_ void		ogl_clipper(register FBIO *ifp);
_LOCAL_ int		ogl_getmem(FBIO *ifp);
_LOCAL_ void		backbuffer_to_screen(register FBIO *ifp, int one_y);
_LOCAL_ void		ogl_cminit(register FBIO *ifp);
d80 2
a81 2
_LOCAL_ XVisualInfo *	ogl_choose_visual(FBIO *ifp);
_LOCAL_ int		is_linear_cmap(register FBIO *ifp);
d90 16
a105 16
int ogl_refresh(FBIO *ifp, int x, int y, int w, int h);
int ogl_open_existing(FBIO *ifp, int argc, char **argv);
int ogl_close_existing(FBIO *ifp);
int _ogl_open_existing(FBIO *ifp, Display *dpy, Window win, Colormap cmap, XVisualInfo *vip, int width, int height, GLXContext glxc, int double_buffer, int soft_cmap);

_LOCAL_ int	ogl_open(FBIO *ifp, char *file, int width, int height),
		ogl_close(FBIO *ifp),
		ogl_clear(FBIO *ifp, unsigned char *pp),
		ogl_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count),
		ogl_write(FBIO *ifp, int xstart, int ystart, const unsigned char *pixelp, int count),
		ogl_rmap(register FBIO *ifp, register ColorMap *cmp),
		ogl_wmap(register FBIO *ifp, register const ColorMap *cmp),
		ogl_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
		ogl_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom),
		ogl_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig),
		ogl_cursor(FBIO *ifp, int mode, int x, int y),
d111 6
a116 6
		ogl_writerect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp),
		ogl_bwwriterect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp),
		ogl_poll(FBIO *ifp),
		ogl_flush(FBIO *ifp),
		ogl_free(FBIO *ifp),
		ogl_help(FBIO *ifp);
d384 2
a385 1
ogl_getmem(FBIO *ifp)
d507 1
a507 1
ogl_zapmem(void)
d530 2
a531 2
sigkid(int pid)
        
d533 1
a533 1
     sigkid(int pid)        
d547 6
a552 1
ogl_xmit_scanlines(register FBIO *ifp, int ybase, int nlines, int xbase, int npix)
d675 4
a678 1
ogl_open(FBIO *ifp, char *file, int width, int height)
d999 4
a1002 1
ogl_open_existing(FBIO *ifp, int argc, char **argv)
d1049 11
a1059 1
_ogl_open_existing(FBIO *ifp, Display *dpy, Window win, Colormap cmap, XVisualInfo *vip, int width, int height, GLXContext glxc, int double_buffer, int soft_cmap)
d1125 2
a1126 1
ogl_final_close(FBIO *ifp)
d1168 2
a1169 1
ogl_close(FBIO *ifp)
d1222 2
a1223 1
ogl_close_existing(FBIO *ifp)
d1260 2
a1261 1
ogl_poll(FBIO *ifp)
d1273 2
a1274 1
ogl_free(FBIO *ifp)
d1291 3
a1293 3
ogl_clear(FBIO *ifp, unsigned char *pp)
    	     
             	    		/* pointer to beginning of memory segment*/
d1371 4
a1374 1
ogl_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
d1451 4
a1454 1
ogl_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom)
d1468 5
a1472 5
ogl_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count) /*read count pixels into pixelp starting at x,y*/
    	     
   	     
             	        
   	      
d1523 5
a1527 5
ogl_write(FBIO *ifp, int xstart, int ystart, const unsigned char *pixelp, int count) /*write count pixels from pixelp starting at xstart,ystart*/
    	     
   	               
                   	        
   	      
d1666 5
a1670 1
ogl_writerect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp)
d1739 5
a1743 1
ogl_bwwriterect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp)
d1806 3
a1808 1
ogl_rmap(register FBIO *ifp, register ColorMap *cmp)
d1831 2
a1832 1
is_linear_cmap(register FBIO *ifp)
d1848 2
a1849 1
ogl_cminit(register FBIO *ifp)
d1864 3
a1866 1
ogl_wmap(register FBIO *ifp, register const ColorMap *cmp)
d1931 2
a1932 1
ogl_help(FBIO *ifp)
d1998 5
a2002 1
ogl_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig)
d2009 4
a2012 1
ogl_cursor(FBIO *ifp, int mode, int x, int y)
d2076 2
a2077 1
ogl_flush(FBIO *ifp)
d2123 2
a2124 1
ogl_clipper(register FBIO *ifp)
d2190 2
a2191 1
do_event(FBIO *ifp)
d2229 3
a2231 1
expose_callback(FBIO *ifp, XEvent *eventPtr)
d2366 3
a2368 1
ogl_configureWindow(FBIO *ifp, int width, int height)
d2419 3
a2421 1
backbuffer_to_screen(register FBIO *ifp, int one_y)
d2516 2
a2517 1
ogl_choose_visual(FBIO *ifp)
d2618 3
a2620 1
ogl_refresh(FBIO *ifp, int x, int y, int w, int h)
@


1.36
log
@Converted from K&R to ANSI C - RFH
@
text
@d68 2
a69 2
_LOCAL_ void		do_event(FBIO *ifp);
_LOCAL_ void		expose_callback(FBIO *ifp, XEvent *eventPtr);
d73 4
a76 4
_LOCAL_ void		ogl_clipper(register FBIO *ifp);
_LOCAL_ int		ogl_getmem(FBIO *ifp);
_LOCAL_ void		backbuffer_to_screen(register FBIO *ifp, int one_y);
_LOCAL_ void		ogl_cminit(register FBIO *ifp);
d80 2
a81 2
_LOCAL_ XVisualInfo *	ogl_choose_visual(FBIO *ifp);
_LOCAL_ int		is_linear_cmap(register FBIO *ifp);
d90 16
a105 16
int ogl_refresh(FBIO *ifp, int x, int y, int w, int h);
int ogl_open_existing(FBIO *ifp, int argc, char **argv);
int ogl_close_existing(FBIO *ifp);
int _ogl_open_existing(FBIO *ifp, Display *dpy, Window win, Colormap cmap, XVisualInfo *vip, int width, int height, GLXContext glxc, int double_buffer, int soft_cmap);

_LOCAL_ int	ogl_open(FBIO *ifp, char *file, int width, int height),
		ogl_close(FBIO *ifp),
		ogl_clear(FBIO *ifp, unsigned char *pp),
		ogl_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count),
		ogl_write(FBIO *ifp, int xstart, int ystart, const unsigned char *pixelp, int count),
		ogl_rmap(register FBIO *ifp, register ColorMap *cmp),
		ogl_wmap(register FBIO *ifp, register const ColorMap *cmp),
		ogl_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
		ogl_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom),
		ogl_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig),
		ogl_cursor(FBIO *ifp, int mode, int x, int y),
d111 6
a116 6
		ogl_writerect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp),
		ogl_bwwriterect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp),
		ogl_poll(FBIO *ifp),
		ogl_flush(FBIO *ifp),
		ogl_free(FBIO *ifp),
		ogl_help(FBIO *ifp);
d384 2
a385 1
ogl_getmem(FBIO *ifp)
d507 1
a507 1
ogl_zapmem(void)
d530 2
a531 2
sigkid(int pid)
        
d533 1
a533 1
     sigkid(int pid)        
d547 6
a552 1
ogl_xmit_scanlines(register FBIO *ifp, int ybase, int nlines, int xbase, int npix)
d675 4
a678 1
ogl_open(FBIO *ifp, char *file, int width, int height)
d999 4
a1002 1
ogl_open_existing(FBIO *ifp, int argc, char **argv)
d1049 11
a1059 1
_ogl_open_existing(FBIO *ifp, Display *dpy, Window win, Colormap cmap, XVisualInfo *vip, int width, int height, GLXContext glxc, int double_buffer, int soft_cmap)
d1125 2
a1126 1
ogl_final_close(FBIO *ifp)
d1168 2
a1169 1
ogl_close(FBIO *ifp)
d1222 2
a1223 1
ogl_close_existing(FBIO *ifp)
d1260 2
a1261 1
ogl_poll(FBIO *ifp)
d1273 2
a1274 1
ogl_free(FBIO *ifp)
d1291 3
a1293 3
ogl_clear(FBIO *ifp, unsigned char *pp)
    	     
             	    		/* pointer to beginning of memory segment*/
d1371 4
a1374 1
ogl_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
d1451 4
a1454 1
ogl_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom)
d1468 5
a1472 5
ogl_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count) /*read count pixels into pixelp starting at x,y*/
    	     
   	     
             	        
   	      
d1523 5
a1527 5
ogl_write(FBIO *ifp, int xstart, int ystart, const unsigned char *pixelp, int count) /*write count pixels from pixelp starting at xstart,ystart*/
    	     
   	               
                   	        
   	      
d1666 5
a1670 1
ogl_writerect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp)
d1739 5
a1743 1
ogl_bwwriterect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp)
d1806 3
a1808 1
ogl_rmap(register FBIO *ifp, register ColorMap *cmp)
d1831 2
a1832 1
is_linear_cmap(register FBIO *ifp)
d1848 2
a1849 1
ogl_cminit(register FBIO *ifp)
d1864 3
a1866 1
ogl_wmap(register FBIO *ifp, register const ColorMap *cmp)
d1931 2
a1932 1
ogl_help(FBIO *ifp)
d1998 5
a2002 1
ogl_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig)
d2009 4
a2012 1
ogl_cursor(FBIO *ifp, int mode, int x, int y)
d2076 2
a2077 1
ogl_flush(FBIO *ifp)
d2123 2
a2124 1
ogl_clipper(register FBIO *ifp)
d2190 2
a2191 1
do_event(FBIO *ifp)
d2229 3
a2231 1
expose_callback(FBIO *ifp, XEvent *eventPtr)
d2366 3
a2368 1
ogl_configureWindow(FBIO *ifp, int width, int height)
d2419 3
a2421 1
backbuffer_to_screen(register FBIO *ifp, int one_y)
d2516 2
a2517 1
ogl_choose_visual(FBIO *ifp)
d2618 3
a2620 1
ogl_refresh(FBIO *ifp, int x, int y, int w, int h)
@


1.35
log
@CONST to const
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ogl.c,v 1.34 2001/04/05 12:52:54 bparker Exp $ (ARL)";
d68 2
a69 2
_LOCAL_ void		do_event();
_LOCAL_ void		expose_callback();
d73 4
a76 4
_LOCAL_ void		ogl_clipper();
_LOCAL_ int		ogl_getmem();
_LOCAL_ void		backbuffer_to_screen();
_LOCAL_ void		ogl_cminit();
d80 2
a81 2
_LOCAL_ XVisualInfo *	ogl_choose_visual();
_LOCAL_ int		is_linear_cmap();
d90 16
a105 16
int ogl_refresh();
int ogl_open_existing();
int ogl_close_existing();
int _ogl_open_existing();

_LOCAL_ int	ogl_open(),
		ogl_close(),
		ogl_clear(),
		ogl_read(),
		ogl_write(),
		ogl_rmap(),
		ogl_wmap(),
		ogl_view(),
		ogl_getview(),
		ogl_setcursor(),
		ogl_cursor(),
d111 6
a116 6
		ogl_writerect(),
		ogl_bwwriterect(),
		ogl_poll(),
		ogl_flush(),
		ogl_free(),
		ogl_help();
d384 1
a384 2
ogl_getmem( ifp )
FBIO	*ifp;
d506 1
a506 1
ogl_zapmem()
d529 2
a530 2
sigkid( pid )
int pid;
d532 1
a532 1
sigkid()
d546 1
a546 6
ogl_xmit_scanlines( ifp, ybase, nlines, xbase, npix )
register FBIO	*ifp;
int		ybase;
int		nlines;
int		xbase;
int		npix;
d669 1
a669 4
ogl_open( ifp, file, width, height ) 
FBIO	*ifp;
char	*file;
int	width, height;
d990 1
a990 4
ogl_open_existing(ifp, argc, argv)
FBIO *ifp;
int argc;
char **argv;
d1037 1
a1037 11
_ogl_open_existing(ifp, dpy, win, cmap, vip, width, height, glxc, double_buffer, soft_cmap)
FBIO *ifp;
Display *dpy;
Window win;
Colormap cmap;
XVisualInfo *vip;
int width;
int height;
GLXContext glxc;
int double_buffer;
int soft_cmap;
d1103 1
a1103 2
ogl_final_close( ifp )
FBIO	*ifp;
d1145 1
a1145 2
ogl_close( ifp )
FBIO	*ifp;
d1198 1
a1198 2
ogl_close_existing(ifp)
FBIO *ifp;
d1235 1
a1235 2
ogl_poll(ifp)
FBIO	*ifp;
d1247 1
a1247 2
ogl_free( ifp )
FBIO	*ifp;
d1264 3
a1266 3
ogl_clear( ifp, pp )
FBIO	*ifp;
unsigned char	*pp;		/* pointer to beginning of memory segment*/
d1344 1
a1344 4
ogl_view( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	xcenter, ycenter;
int	xzoom, yzoom;
d1421 1
a1421 4
ogl_getview( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	*xcenter, *ycenter;
int	*xzoom, *yzoom;
d1435 5
a1439 5
ogl_read( ifp, x, y, pixelp, count ) /*read count pixels into pixelp starting at x,y*/
FBIO	*ifp;
int	x, y;
unsigned char	*pixelp;
int	count;
d1490 5
a1494 5
ogl_write( ifp, xstart, ystart, pixelp, count ) /*write count pixels from pixelp starting at xstart,ystart*/
FBIO	*ifp;
int	xstart, ystart;
const unsigned char	*pixelp;
int	count;
d1633 1
a1633 5
ogl_writerect( ifp, xmin, ymin, width, height, pp )
FBIO		*ifp;
int		xmin, ymin;
int		width, height;
const unsigned char	*pp;
d1702 1
a1702 5
ogl_bwwriterect( ifp, xmin, ymin, width, height, pp )
FBIO		*ifp;
int		xmin, ymin;
int		width, height;
const unsigned char	*pp;
d1765 1
a1765 3
ogl_rmap( ifp, cmp )
register FBIO	*ifp;
register ColorMap	*cmp;
d1788 1
a1788 2
is_linear_cmap(ifp)
register FBIO	*ifp;
d1804 1
a1804 2
ogl_cminit( ifp )
register FBIO	*ifp;
d1819 1
a1819 3
ogl_wmap( ifp, cmp )
register FBIO	*ifp;
register const ColorMap	*cmp;
d1884 1
a1884 2
ogl_help( ifp )
FBIO	*ifp;
d1950 1
a1950 5
ogl_setcursor( ifp, bits, xbits, ybits, xorig, yorig )
FBIO	*ifp;
const unsigned char *bits;
int	xbits, ybits;
int	xorig, yorig;
d1957 1
a1957 4
ogl_cursor( ifp, mode, x, y )	
FBIO	*ifp;
int	mode;
int	x, y;
d2021 1
a2021 2
ogl_flush( ifp )
FBIO	*ifp;
d2067 1
a2067 2
ogl_clipper( ifp )
register FBIO	*ifp;
d2133 1
a2133 2
do_event(ifp)
FBIO *ifp;	
d2171 1
a2171 3
expose_callback(ifp, eventPtr)
FBIO *ifp;
XEvent *eventPtr;
d2306 1
a2306 3
ogl_configureWindow(ifp, width, height)
FBIO *ifp;
int width, height;
d2357 1
a2357 3
backbuffer_to_screen(ifp, one_y)
register FBIO	*ifp;
int		one_y;
d2452 1
a2452 2
ogl_choose_visual(ifp)
FBIO *ifp;
d2553 1
a2553 3
ogl_refresh(ifp, x, y, w, h)
FBIO *ifp;
int x, y, w, h;
@


1.34
log
@*- get rid of warnings
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ogl.c,v 1.33 2000/11/01 22:00:25 bparker Exp $ (ARL)";
d1526 1
a1526 1
CONST unsigned char	*pixelp;
d1670 1
a1670 1
CONST unsigned char	*pp;
d1743 1
a1743 1
CONST unsigned char	*pp;
d1866 1
a1866 1
register CONST ColorMap	*cmp;
d2000 1
a2000 1
CONST unsigned char *bits;
@


1.33
log
@Remove glu.h
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ogl.c,v 1.32 2000/01/28 15:49:00 bparker Exp $ (ARL)";
d33 5
d77 1
d79 1
d106 1
d109 2
a115 1
		fb_cnull(),
d2100 1
a2100 1

d2107 1
a2107 1

d2390 1
d2412 1
@


1.32
log
@*- mods to ogl_refresh and ogl_configureWindow
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ogl.c,v 1.31 2000/01/21 20:05:11 butler Exp $ (ARL)";
d43 1
a43 2
#include <GL/gl.h> 
#include <GL/glu.h> 
@


1.32.2.1
log
@removed glu.h
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ogl.c,v 1.32 2000/01/28 15:49:00 bparker Exp $ (ARL)";
d43 2
a44 1
#include <GL/gl.h>
@


1.31
log
@removed unused variables to clean up compile
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ogl.c,v 1.30 1999/12/30 00:02:29 bparker Exp $ (ARL)";
d2372 3
d2613 1
d2636 2
d2639 6
@


1.30
log
@*- still need old_brk and new_brk
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ogl.c,v 1.29 1999/12/29 20:44:39 jra Exp $ (ARL)";
d383 1
d386 1
@


1.29
log
@Eliminated some unused variables
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ogl.c,v 1.28 1999/12/17 16:32:21 bparker Exp $ (ARL)";
d383 2
@


1.28
log
@*- the XXX_open_existing routines are no longer hidden
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ogl.c,v 1.27 1998/06/27 04:29:16 mike Exp $ (ARL)";
a382 2
	char	*old_brk;
	char	*new_brk;
a544 4
	int		sw_zoom;	/* !0 => needs software zoom/pan */
	unsigned long 	*ulong;
	int		position[4];
	int 		xcoord,ycoord, i, j;
a672 7
	int 		xpos, ypos, win_width, win_height;
	Pixmap		src_bitmap, nil_bitmap;
	int 		n;
	int 		fake_argc = 0;
	FBIO 		*client_data1;
	GLXContext 	client_data2;
	XEvent 		event;
a674 1
	int fargc = 0;
a820 4
		xpos = WIN_L;
		ypos = WIN_T;
		win_width = ifp->if_width;
		win_height = ifp->if_height;
a823 4
		xpos = 0;
		ypos = YMAXSCREEN;
		win_width = XMAXSCREEN+1;
		win_height = XMAXSCREEN+1;
a1048 1
  Pixmap src_bitmap, nil_bitmap;
a1115 1
  XEvent event;
a1159 3
	FILE *fp = NULL;
	int n, scr;

a1857 2
	XVisualInfo *vi;
    	int num;
a2382 2
	char scan1;
	char scan2;
a2405 1
	int front;
a2605 1
  int dflag = 0;
@


1.27
log
@Additions to LIBFB interface and remote framebuffer protocol to
read and write monochrome rectangles.
Particularly important for sending thermal images at high speed.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ogl.c,v 1.26 1998/05/15 14:58:44 bparker Exp $ (ARL)";
d85 1
d87 1
a87 2
int ogl_open_existing();
_LOCAL_ int _ogl_open_existing();
d1058 1
a1058 1
_LOCAL_ int
@


1.26
log
@checkin for pjt/jra demo
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/libfb/if_ogl.c,v 1.25 1998/04/23 13:50:36 bparker Exp $ (ARL)";
d103 1
d128 2
d1712 73
@


1.25
log
@*- experimenting with ogl_refresh()
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ogl.c,v 1.24 1998/01/29 06:02:27 mike Exp bparker $ (ARL)";
d385 1
d390 2
@


1.24
log
@BParker mods to destroy cursor window.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ogl.c,v 1.23 1998/01/20 20:43:23 mike Exp bparker $ (ARL)";
d2559 1
d2571 7
d2586 3
d2596 5
@


1.23
log
@Added "D" option for real-time ray-tracer.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ogl.c,v 1.22 1998/01/20 19:52:09 bparker Exp mike $ (ARL)";
d1139 3
a1142 1
  XDestroyWindow(OGL(ifp)->dispp, OGL(ifp)->cursor);
d1234 3
a1255 1
    XDestroyWindow(OGL(ifp)->dispp, OGL(ifp)->cursor);
@


1.22
log
@*- mods to allow external control of the GL engine
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ogl.c,v 1.21 1998/01/05 20:22:53 bparker Exp bparker $ (ARL)";
d128 1
a128 1
	fb_cnull,		/* flush output		*/
d294 4
d325 2
d1614 3
d1705 3
d2013 16
@


1.21
log
@*- code to use existing resources (i.e. X window, colormap, visual, grapics context etc.)
	within FBIO
*- mods to use X window as cursor
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ogl.c,v 1.20 1997/12/04 08:53:34 mike Exp bparker $ (ARL)";
d66 1
d84 2
d232 1
d393 1
a393 1
		sp = malloc( size );
d473 1
a473 1
	if( (sp = malloc( size )) == NULL )  {
d563 1
a563 1

d613 1
d1061 2
a1062 1
  ifp->if_mode = 1;  /*XXX for now use private memory */
d1078 2
d1082 6
a1087 4
  ifp->if_width = width;
  ifp->if_height = height;
  OGL(ifp)->win_width = width;
  OGL(ifp)->win_height = height;
d1099 1
a1099 1
  if( ogl_getmem(ifp) < 0 )
d1118 2
d1333 3
d1360 1
d1402 3
d1422 1
d1441 1
d1614 1
d1648 1
d1696 1
d1718 1
d1808 1
d1844 1
a1844 1

d2099 26
a2124 1
	XEvent event;
d2126 6
a2131 18
	while (XCheckWindowEvent(OGL(ifp)->dispp, OGL(ifp)->wind,
				 OGL(ifp)->event_mask, &event)) {
		switch (event.type) {
		case Expose:
			expose_callback(ifp, &event);
			break;
		case ButtonPress:
			break;
		case ButtonRelease:
			OGL(ifp)->alive = 0;
			break;
		case KeyPress:
			break;
		case KeyRelease:
			OGL(ifp)->alive = 0;
			break;
		}
	}
d2271 17
a2287 1
 
d2289 3
d2519 37
@


1.20
log
@Changed window title bar, improved commenting.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
a62 24
_LOCAL_ XColor curs_color = {
		0,		/* unused */
		0xFFFF,		/* red */
		0x0000,		/* green */
		0x0000,		/* blue */
		0, 0		/* unused */
};

#define MAX_CURS_BYTES	128	
struct ogl_cursor {		/* for reading in default cursors from file*/
	int xbits, ybits;
	int xorig, yorig;
	char bits[MAX_CURS_BYTES];
};

_LOCAL_ struct ogl_cursor arr_data = {	/* default arrow cursor */
#include "./oglcursor.h"
};

_LOCAL_ struct ogl_cursor nil_data = {	/* default blank cursor */
#include "./nilcursor.h"
};
_LOCAL_ Cursor nil_cursor;

a72 1
_LOCAL_ Pixmap  	make_bitmap();
d76 1
a76 1
_LOCAL_ int	ogl_nwindows = 0; 	/* number of open windows*/
d83 3
d226 2
a227 2
	Cursor		cursor;		/* user's cursor */
	XVisualInfo    *vip;		/* pointer to info on current visual*/
a917 30
	/* 
	 * Cursor set-up:
	 * create the default cursor and an invisible cursor for when the
	 * cursor is off
	 */
	src_bitmap = make_bitmap(ifp, OGL(ifp)->vip->visual, arr_data.bits, 
				 arr_data.xbits, arr_data.ybits);
	/* (complication in last parameter is conversion from 
	 *  first quadrant to third quadrant coordinates)
	 */
	OGL(ifp)->cursor = XCreatePixmapCursor(OGL(ifp)->dispp, src_bitmap,
					       src_bitmap, &curs_color,
					       &curs_color, arr_data.xorig,
					       arr_data.ybits -
					       arr_data.yorig - 1);
	XFreePixmap(OGL(ifp)->dispp, src_bitmap);

	/* only need one copy of null cursor for all open windows*/
	if( ogl_nwindows < 2 ) {
		nil_bitmap = make_bitmap(ifp, OGL(ifp)->vip->visual,
					 nil_data.bits, nil_data.xbits,
					 nil_data.ybits);
		nil_cursor = XCreatePixmapCursor(OGL(ifp)->dispp, nil_bitmap,
						 nil_bitmap, &curs_color,
						 &curs_color, nil_data.xorig,
						 nil_data.ybits -
						 nil_data.yorig - 1);
		XFreePixmap(OGL(ifp)->dispp,nil_bitmap);
	}

d923 1
a923 2
	valuemask = CWBackPixel | CWBorderPixel | CWEventMask |
		CWColormap | CWCursor;
a932 1
	swa.cursor = OGL(ifp)->cursor;
d991 120
d1115 1
a1115 30
	XEvent event;
	
	XUndefineCursor(OGL(ifp)->dispp, OGL(ifp)->wind);
	if( CJDEBUG ) {
		printf("ogl_final_close: All done...goodbye!\n");
	}
	XDestroyWindow(OGL(ifp)->dispp, OGL(ifp)->wind);
	XFreeCursor(OGL(ifp)->dispp, OGL(ifp)->cursor);
	XFreeColormap(OGL(ifp)->dispp, OGL(ifp)->xcmap);
	if (ogl_nwindows < 2) {
		XFreeCursor(OGL(ifp)->dispp, nil_cursor);
	}

	if( SGIL(ifp) != NULL ) {
		/* free up memory associated with image */
		if( SGI(ifp)->mi_shmid != -1 ) {
			/* detach from shared memory */
			if( shmdt( ifp->if_mem ) == -1 ) {
				fb_log("ogl_close shmdt failed, errno=%d\n",
				       errno);
				return -1;
			}
		} else {
			/* free private memory */
			(void)free( ifp->if_mem );
		}
		/* free state information */
		(void)free( (char *)SGIL(ifp) );
		SGIL(ifp) = NULL;
	}
d1117 30
a1146 4
	if( OGLL(ifp) != NULL) {
		(void) free( (char *)OGLL(ifp) );
		OGLL(ifp) = NULL;
	}
d1148 2
a1149 2
	ogl_nwindows--;
	return(0);
d1210 31
d1301 1
a1301 1
		glClearColor(((pp)[RED]),  ((pp)[GRN]),  ((pp)[BLU]), 0);
d1307 1
a1307 1
		glClearColor(  0,  0,  0, 0);
d1900 1
a1900 37
	Pixmap new_bitmap;
	Cursor new_cursor;

	/* Check size of cursor */
	if( xbits < 0 )
		return	-1;
	if( xbits > 16 )
		xbits = 16;
	if( ybits < 0 )
		return	-1;
	if( ybits > 16 )
		ybits = 16;

	new_bitmap = make_bitmap(ifp, OGL(ifp)->vip->visual, bits, xbits,
				 ybits);
	
	/* complication in last parameter is conversion from 
	 * first quadrant to third quadrant coordinates
	 */
	new_cursor=XCreatePixmapCursor(OGL(ifp)->dispp, new_bitmap,
			new_bitmap, &curs_color, &curs_color, 
			xorig, ybits-yorig-1);
	XFreePixmap(OGL(ifp)->dispp,new_bitmap);
	if(CJDEBUG) fb_log("setcursor: id %d\ton %d\n",new_cursor, SGI(ifp)->mi_curs_on);
	if ( new_cursor) {
		if (SGI(ifp)->mi_curs_on){
			if(CJDEBUG) fb_log("New cursor defined: %d\n", new_cursor);
			XDefineCursor(OGL(ifp)->dispp,OGL(ifp)->wind,new_cursor);
		}
		XFreeCursor(OGL(ifp)->dispp,OGL(ifp)->cursor);
		OGL(ifp)->cursor = new_cursor;
		return(0);
	} else {
		fb_log("ogl_setcursor: Could not create new cursor - cursor unchanged.\n");
		return(-1);
	}

a1903 3
/* NOTE: this version allows you to turn cursor on or off, but doesn't use the
 * x and y parameters to set its position
 */
d1910 55
a1964 2
	/* set values into FBIO structure */
	fb_sim_cursor(ifp, mode, x, y);
d1966 1
a1966 8
	SGI(ifp)->mi_curs_on = mode;
	if (mode) {
		XDefineCursor(OGL(ifp)->dispp,OGL(ifp)->wind,OGL(ifp)->cursor);
		return(0);
	} else {
		XDefineCursor(OGL(ifp)->dispp,OGL(ifp)->wind,nil_cursor);
		return(0);
	}
a2257 61


_LOCAL_ Pixmap 
make_bitmap(ifp, visual, data, xbits, ybits)
FBIO *ifp;
Visual *visual;
char *data;
int xbits;
int ybits;
{
	Display *display;
	Window window;
	XImage *xip;
	GC pgc;
	int xbytes;
	Pixmap pmap;
	XGCValues gcval;
	char rdata[MAX_CURS_BYTES];	

	display = OGL(ifp)->dispp;

	/* calculate number of bytes per scanline */
	if( ( xbytes = xbits/8 ) * 8 != xbits)
		xbytes++;

	if(CJDEBUG) fb_log("cursor: xbits %d, ybits %d, xbytes %d\n",xbits,ybits,xbytes);

	if (xbytes*ybits > MAX_CURS_BYTES) {
		fb_log("make_bitmap: cursor %d bits by %d bits too large\n", xbits, ybits);
		return(0);
	}

	reorder_cursor(rdata, data, xbits, ybits);

	xip = XCreateImage(display, visual, 1, XYBitmap, 0, rdata, 
				xbits, ybits, 8, xbytes);

	/* note - this works on SGI servers so far. In a server with
	 * another endian-ness, the bits might be in the wrong order.
	 * watch out in the future.
	 */
	pmap = XCreatePixmap(display, RootWindow(OGL(ifp)->dispp,
						 OGL(ifp)->vip->screen),
			     xbits, ybits,1);

	/* create a GC specifically to do the putting */
	gcval.foreground = 1;
	gcval.background = 0;
	pgc = XCreateGC(display, pmap, GCForeground | GCBackground, &gcval);
	XPutImage(display, pmap, pgc, xip, 0, 0, 0, 0, xbits, ybits);

	XFreeGC(display,pgc);

	/* set data pointer to null before destroying, since data statically
	 * allocated */
	xip->data = NULL;
	XDestroyImage(xip);
	return(pmap);

}

@


1.19
log
@Added code to ogl_help() to describe the visual that was selected.
@
text
@d4 1
a4 14
 *  BRL Frame Buffer Library interface for SGI Iris-5D.
 *  This code is basically a port of if_4d.c from IRIS GL to OpenGL.
 *  
 *  In order to use a large chunk of memory with the shared memory 
 *  system it is necessary to increase the shmmax and shmall paramaters
 *  of the system. You can do this by changing the defaults in the
 *  /usr/sysgen/master.d/shm to
 *
 * 	#define SHMMAX	5131072
 *	#define SHMALL	4000
 *
 *  and rebooting your system twice.
 *
 *  Refer to the SGI Users Manuals when reconfiguring your kernel.
d13 6
d20 2
a21 3
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
d23 2
a24 1
 *  Porting done by Carl Nuzman
a25 3

/* 	$Id: if_ogl.c,v 1.18 1997/06/26 03:03:00 mike Exp mike $	 */

d27 2
a28 2
static char RCSid[] = "(#)$Header: /m/cad/libfb/RCS/if_ogl.c,v 1.18 1997/06/26 03:03:00 mike Exp mike $";
#endif /* lint */
d855 1
a855 1
	(void)sprintf( title, "BRL libfb /dev/ogl %s, %s",
@


1.18
log
@Prevent bountiful choices from overflowing the fixed array.
@
text
@d34 1
a34 1
/* 	$Id: if_ogl.c,v 1.17 1997/06/04 13:37:55 gdurf Exp bparker $	 */
d37 1
a37 1
static char RCSid[] = "(#)$Header: /m/cad/libfb/RCS/if_ogl.c,v 1.17 1997/06/04 13:37:55 gdurf Exp bparker $";
d1747 1
d1762 44
a1805 1
	return(0);
d1839 1
a1839 1
	if(CJDEBUG) printf("setcursor: id %d\ton %d\n",new_cursor, SGI(ifp)->mi_curs_on);
d1842 1
a1842 1
			if(CJDEBUG) printf("New cursor defined: %d\n", new_cursor);
d2012 1
a2012 1
	if( CJDEBUG ) printf("entering expose_callback()\n");
d2122 1
a2122 1
		printf("Viewport: x %d y %d width %d height %d\n",view[0],
d2124 2
a2125 2
		printf("expose: double buffered: %d, draw buffer %d\n",dbb,db);
		printf("front %d\tback%d\n",GL_FRONT,GL_BACK);
d2128 1
a2128 1
		printf("double %d, stereo %d, aux %d\n",dbb,getster,getaux);
d2192 1
a2192 1
	if(CJDEBUG) printf("cursor: xbits %d, ybits %d, xbytes %d\n",xbits,ybits,xbytes);
@


1.17
log
@Minor cleanups.
Incidentally, a previous revision (1.16) included fixes for the "linger"
mode (ogl_close() now loops indefinitely, processing events, until the
user signals the destruction of the window) but I forgot to mention this
in the appropriate log entry.
@
text
@d34 1
a34 1
/* 	$Id: if_ogl.c,v 1.16 1997/06/03 20:34:25 gdurf Exp gdurf $	 */
d37 1
a37 1
static char RCSid[] = "(#)$Header: /m/cad/libfb/RCS/if_ogl.c,v 1.16 1997/06/03 20:34:25 gdurf Exp gdurf $";
d2293 2
a2294 1
	int good[40];
d2302 2
d2319 10
d2340 4
a2387 1

@


1.16
log
@Expurgation of Tcl/Tk code complete.
This interface now uses only Xlib and GL calls.
The following bug remains: when the image is first drawn, on occasion it
is not drawn completely.  When a redraw is forced, the rest of the image
appears.  This might be a problem with the flush routine (although
ogl_flush() seems pretty thorough) or with the handling of the first exposure
event.
@
text
@d34 1
a34 1
/* 	$Id: if_ogl.c,v 1.15 1997/06/03 14:00:59 gdurf Exp gdurf $	 */
d37 1
a37 1
static char RCSid[] = "(#)$Header: /m/cad/libfb/RCS/if_ogl.c,v 1.15 1997/06/03 14:00:59 gdurf Exp gdurf $";
a96 9
_LOCAL_ char *visual_class[] = {
	"StaticGray",
	"GrayScale",
	"StaticColor",
	"PseudoColor",
	"TrueColor",
	"DirectColor"
};

d2091 4
a2296 7
	char *visual_class[] = {
		"StaticGrey",
		"GreyScale",
		"StaticColor",
		"PseudoColor",
		"TrueColor",
		"DirectColor" };
@


1.15
log
@First pass at expurgating Tcl/Tk code from the OpenGL frame buffer code.
Remaining bugs:
  1) "linger" mode doesn't work.  Apparently, it never did.
  2) XCreateWindow generates a BadMatch error (mismatch with the visual type
     chosen by ogl_choose_visual?  Why?  This makes no sense.)
@
text
@d34 1
a34 1
/* 	$Id: if_ogl.c,v 1.14 1997/05/30 23:04:19 gdurf Exp gdurf $	 */
d37 1
a37 1
static char RCSid[] = "(#)$Header: if_ogl.c,v 1.14 1997/05/30 23:04:19 gdurf Exp gdurf $";
d63 1
a63 1
#define CJDEBUG 1
d107 1
d255 2
a256 1
	int		firstTime;	/* flag for setup */
d317 1
a317 1
#define MODE_5NORMAL	(1<<4) /* 1? */	/* fast - assume no multiple windows */
d651 1
a651 1
	if( sw_cmap) { 
a687 12


if (CJDEBUG) {
	int valid;
	float rpos[4];

	glGetIntegerv(GL_CURRENT_RASTER_POSITION_VALID, &valid);
	glGetFloatv(GL_CURRENT_RASTER_POSITION, rpos);
	printf("Raster position (%g, %g, %g, %g) has validity %d.\n",rpos[0],rpos[1],rpos[2],rpos[3],valid);
}


a688 1

d814 1
d819 1
d874 1
a874 1
	(void)sprintf( title, "BRLGGG libfb /dev/ogl %s, %s",
d902 4
d950 1
a950 1
			printf("Allocating read-only colormap:");
a956 3
		if( CJDEBUG ) {
			printf(" %08X.\n", OGL(ifp)->xcmap);
		}
d994 2
a995 2
	valuemask = CWBackPixmap | CWBackPixel | CWBorderPixmap |
		CWBorderPixel | CWEventMask /* | CWColormap */ | CWCursor;
a996 1
	swa.background_pixmap = None;
a998 1
	swa.border_pixmap = None;
d1004 1
a1004 1
/*	swa.colormap = OGL(ifp)->xcmap; */
d1039 1
a1039 2
#if 0	
	OGL(ifp)->wind = XCreateWindowDebug(OGL(ifp)->dispp,
d1047 1
a1047 11
#else	
	OGL(ifp)->wind = XCreateWindowDebug(OGL(ifp)->dispp,
				       RootWindow(OGL(ifp)->dispp,
						  OGL(ifp)->vip->screen),
				       0, 0, ifp->if_width, ifp->if_height, 0,
				       CopyFromParent,
				       InputOutput,
				       CopyFromParent,
				       valuemask, &swa);
#endif
	printf("\nOGL(ifp)->wind = %08X\n\n", OGL(ifp)->wind);
a1051 1

d1054 1
d1058 3
a1060 5
	while (1) {
		XWindowEvent(OGL(ifp)->dispp, OGL(ifp)->wind,
			     OGL(ifp)->event_mask, &event);
		if (event.type == Expose) break;
	}
a1072 1
		sleep(5);
d1117 2
d1126 3
d1160 4
a1163 1
	return ogl_final_close( ifp );
a1165 1

d1175 1
a1175 21
	XEvent event;

	while (XCheckWindowEvent(OGL(ifp)->dispp, OGL(ifp)->wind,
				 OGL(ifp)->event_mask, &event)) {
		switch (event.type) {
		case Expose:
			expose_callback(ifp);
			break;
		case ButtonPress:
			break;
		case ButtonRelease:
			/* XXX Quit under certain conditions. */
			break;
		case KeyPress:
			break;
		case KeyRelease:
			/* XXX Quit under certain conditions. */
			break;
		}
	}

a1210 1
	XEvent event;
a1284 1
	XEvent event;
a1358 1
	XEvent event;
a1438 1
	XEvent event;
a1573 1
	XEvent event;
d1650 1
a1650 1
static int
a1689 1
	XEvent event;
a1829 2
	XEvent event;

d1850 1
d1943 25
d1969 1
a1969 1
static void
d2302 7
d2348 1
a2348 1
				if (vip->depth > maxvip->depth) {
a2354 4

			if (CJDEBUG) {
				printf("Selected visual: %s depth=%d colormap=%d\n",visual_class[maxvip->class],maxvip->depth,maxvip->colormap_size);
			}
@


1.14
log
@Added RCS id.
@
text
@d34 1
a34 1
/* 	$Id$	 */
d37 1
a37 1
static char RCSid[] = "@@(#)$Id$";
d41 1
a41 6
#include "tk.h"
#include <X11/keysym.h> 
#include <X11/StringDefs.h> 
#include <GL/glx.h>
#include <GL/gl.h> 
#include <GL/glu.h> 
a43 2


d50 5
d63 1
a63 1
#define CJDEBUG 0
d73 1
a73 1
static XColor curs_color = {
d88 1
a88 1
static struct ogl_cursor arr_data = {	/* default arrow cursor */
d92 1
a92 1
static struct ogl_cursor nil_data = {	/* default blank cursor */
d95 1
a95 1
static Cursor nil_cursor;
d97 1
a97 1
char *visual_class[] = {
d107 1
a107 4
static int input();
static int expose_callback();
static int CloseCB();
static int PostIt();
d110 2
a111 2
void ogl_clipper();
_LOCAL_ int ogl_getmem();
d117 1
a117 1
static int		is_linear_cmap();
d119 2
a120 2
static int	ogl_nwindows = 0; 	/* number of open windows*/
static int	multiple_windows = 0;	/* someone wants to be ready
a125 1

d251 5
a255 8
  Tcl_Interp *interp;
  Tk_Window main_tkwin;
  Tk_Window tkwin;
  GLXContext glxc;
  Display *dispp;
  Window wind;
	short 		firstTime;	/* first time exposed */
	short 		close_me; 	/* flag set by popup close button */
d266 1
a266 1
	XVisualInfo	*vip;		/* pointer to info on current visual*/
d315 1
a315 1
#define MODE_5NORMAL	(1<<4)		/* fast - assume no multiple windows */
d334 1
a334 1
static struct modeflags {
d396 1
a396 1
 *  attach to the shared memory, and then return the break to it's
d543 1
a543 1
sigkid(pid)
d721 2
d883 1
a883 1
	(void)sprintf( title, "BRL libfb /dev/ogl %s, %s",
a899 1

d904 5
a908 7

	OGL(ifp)->interp = Tcl_CreateInterp();

	/* This runs the init.tcl script */
	if( Tcl_Init(OGL(ifp)->interp) == TCL_ERROR ){
	  fb_log("Tcl_Init error %s\n", OGL(ifp)->interp->result);
	  return (-1);
d910 1
d912 4
a915 3
	if (Tk_Init(OGL(ifp)->interp) == TCL_ERROR){
	  fb_log("Tk_Init error %s\n", OGL(ifp)->interp->result);
	  return (-1);
a917 20
	if((OGL(ifp)->main_tkwin = Tk_MainWindow(OGL(ifp)->interp)) == NULL){
	  fb_log("ogl_open: Failed to get main window.\n");
	  return (-1);
	}

	if((OGL(ifp)->tkwin = Tk_CreateWindowFromPath(OGL(ifp)->interp,
						      OGL(ifp)->main_tkwin,
						      ".ogl", NULL)) == NULL){
	  fb_log("ogl_open: Failed to create window.\n");
	  return (-1);
	}

	OGL(ifp)->dispp = Tk_Display(OGL(ifp)->tkwin);

	/* Choose an appropriate visual */
	if ((OGL(ifp)->vip = ogl_choose_visual(ifp))==NULL){
	  fb_log("ogl_open: Couldn't find an appropriate visual. Exiting.\n");
	  exit(-1);
	}

d952 1
a952 1
    		XStoreColors(OGL(ifp)->dispp, OGL(ifp)->xcmap, color_cell, 256);
d954 3
d959 1
a959 1
						OGL(ifp)->vip->screen),
d962 3
a966 21
	/* count windows */
	ogl_nwindows++;

	Tk_GeometryRequest(OGL(ifp)->main_tkwin, ifp->if_width, ifp->if_height);
	Tk_ResizeWindow(OGL(ifp)->tkwin, ifp->if_width, ifp->if_height);
	Tk_SetWindowVisual(OGL(ifp)->tkwin, OGL(ifp)->vip->visual,
			   OGL(ifp)->vip->depth, OGL(ifp)->xcmap);
	Tk_MakeWindowExist(OGL(ifp)->tkwin);
	OGL(ifp)->wind = Tk_WindowId(OGL(ifp)->tkwin);

	{
	  char *str;
	  struct bu_vls vls;
	  int status;

	  str = (char *)malloc( strlen( title ) + 40 );
	  sprintf( str, "wm title . \"%s\"; wm resizable . 0 0", title );
	  status = Tcl_Eval(OGL(ifp)->interp, str);
	  free( str );
	}
	
d972 2
a973 2
	src_bitmap = make_bitmap(ifp, arr_data.bits, 
				arr_data.xbits, arr_data.ybits);
d978 5
a982 3
			src_bitmap, &curs_color, &curs_color, 
			arr_data.xorig, arr_data.ybits - arr_data.yorig - 1);
	XFreePixmap(OGL(ifp)->dispp,src_bitmap);
d985 4
a988 2
	if (ogl_nwindows < 2) {
		nil_bitmap = make_bitmap(ifp, nil_data.bits,nil_data.xbits, nil_data.ybits);
d990 4
a993 2
			nil_bitmap, &curs_color, &curs_color, 
			nil_data.xorig, nil_data.ybits - nil_data.yorig -1);
d997 78
a1074 5
	if ( SGI(ifp)->mi_curs_on == 0 ) {
		XDefineCursor(OGL(ifp)->dispp,OGL(ifp)->wind,nil_cursor);
	} else {
		XDefineCursor(OGL(ifp)->dispp,OGL(ifp)->wind,OGL(ifp)->cursor);
	}
d1076 1
a1076 4
	Tk_CreateGenericHandler(expose_callback, (ClientData)ifp);
	Tk_MapWindow(OGL(ifp)->tkwin);
	Tk_MapWindow(OGL(ifp)->main_tkwin);
	ifp->if_selfd = ConnectionNumber(OGL(ifp)->dispp);
d1079 4
a1082 3
	OGL(ifp)->firstTime = 1;
	while(OGL(ifp)->firstTime){
	  Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT);
a1083 1

a1086 2


a1090 1

d1093 10
a1102 6
	XUndefineCursor(OGL(ifp)->dispp,OGL(ifp)->wind);
	Tk_DestroyWindow(OGL(ifp)->main_tkwin);
	XFreeCursor(OGL(ifp)->dispp,OGL(ifp)->cursor);
	XFreeColormap(OGL(ifp)->dispp,OGL(ifp)->xcmap);
	if (ogl_nwindows < 2){
		XFreeCursor(OGL(ifp)->dispp,nil_cursor);
d1110 2
a1111 1
				fb_log("ogl_close shmdt failed, errno=%d\n", errno);
d1123 1
a1123 1
	if ( OGLL(ifp) != NULL) {
a1132 1

d1194 19
a1212 1
	while(Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT));
d1245 3
a1247 3
	register struct ogl_pixel	*oglp;
	register int	cnt;
	register int	y;
d1250 1
a1250 4
	if(CJDEBUG) printf("entering ogl_clear\n");
#if 0
	while(Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT));
#endif
d1253 1
a1253 1
	if (glXMakeCurrent(OGL(ifp)->dispp,OGL(ifp)->wind,OGL(ifp)->glxc)==False){
d1255 1
a1255 1
	}
d1305 2
a1306 2
	/* unattach context for other threads to use */
	glXMakeCurrent(OGL(ifp)->dispp,None,NULL);
d1326 1
a1326 3
#if 0
	while(Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT));
#endif
d1351 3
a1353 3
	if (glXMakeCurrent(OGL(ifp)->dispp,OGL(ifp)->wind,OGL(ifp)->glxc)==False){
		fb_log("Warning, ogl_view: glXMakeCurrent unsuccessful.\n");
	}
d1382 2
a1383 2
	/* unattach context for other threads to use */
	glXMakeCurrent(OGL(ifp)->dispp,None,NULL);
d1400 1
a1400 3
#if 0
	while(Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT));
#endif
a1552 7
	/*
	 * Handle events after updating the memory, and
	 * before updating the screen
	 */
#if 0
	while(Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT));
#endif
d1554 3
a1556 2
	if (glXMakeCurrent(OGL(ifp)->dispp,OGL(ifp)->wind,OGL(ifp)->glxc)==False){
		fb_log("Warning, ogl_write: glXMakeCurrent unsuccessful.\n");
a1557 1
	}
d1589 2
a1590 2
	/* unattach context for other threads to use */
	glXMakeCurrent(OGL(ifp)->dispp,None,NULL);
a1639 7
	/*
	 * Handle events after updating the memory, and
	 * before updating the screen
	 */
#if 0
	while(Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT));
#endif	
d1737 1
a1737 3
#if 0
	while(Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT));
#endif
a1823 1
	XEvent event;
d1826 1
a1826 3
#if 0
	while(Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT));
#endif
d1837 2
a1838 1
	new_bitmap = make_bitmap(ifp,bits, xbits, ybits);
d1874 1
a1874 3
#if 0
	while(Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT));
#endif
d1894 1
a1894 3
	XEvent event;

	while(Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT));
d1988 3
a1990 32
/* INPUT - The only thing this does is exit on <ESC> */
#ifndef FB_USING_TCL_TK
static void 
input(Widget w, XtPointer client_data,    XtPointer call) 
{    
	char buffer[1];    
	KeySym keysym;    
	XmDrawingAreaCallbackStruct *call_data;     

	if(CJDEBUG) printf("entering input()\n");


	call_data = (XmDrawingAreaCallbackStruct *) call;     
	switch(call_data->event->type)    {    
	case KeyRelease:      /* It is necessary to convert the keycode       * to a keysym before it is possible to check       * if it is an escape.       */      
		if (XLookupString( (XKeyEvent *)                         
			call_data->event, buffer, 1, &keysym,
			(XComposeStatus *)NULL) == 1 &&
			keysym == (KeySym)XK_Escape)        
		exit(0);    
		break;     
	default:    
		break;    
	} 

	return;
}   
#endif
  
static int
expose_callback(client_data, eventPtr)
ClientData client_data;
d1993 1
a1993 2
  XWindowAttributes xwa;
	FBIO *ifp;
d1996 1
a1996 1
	if(CJDEBUG) printf("entering expose_callback()\n");
a1997 1
	ifp = (FBIO *) client_data;     
d1999 5
a2003 4
	if (multiple_windows || OGL(ifp)->firstTime) {
	if (glXMakeCurrent(OGL(ifp)->dispp,OGL(ifp)->wind,OGL(ifp)->glxc)==False){
		fb_log("Warning, libfb/expose_callback: glXMakeCurrent unsuccessful.\n");
	}
d2006 1
a2006 1
	if (OGL(ifp)->firstTime){
d2012 2
a2013 1
		if ( !SGI(ifp)->mi_doublebuffer ){
d2017 1
a2017 1
		if ((ifp->if_mode & MODE_4MASK)==MODE_4NODITH){
d2022 2
a2023 2
		if (SGI(ifp)->mi_doublebuffer && 
			((ifp->if_mode & MODE_11MASK)==MODE_11COPY)){
d2041 1
a2041 1
		glViewport(0, 0, OGL(ifp)->win_width, OGL(ifp)->win_height);      
d2056 6
a2061 6
		SGI(ifp)->mi_xoff = (OGL(ifp)->win_width - OGL(ifp)->vp_width)/2;
		SGI(ifp)->mi_yoff = (OGL(ifp)->win_height - OGL(ifp)->vp_height)/2;
		glViewport(	SGI(ifp)->mi_xoff,
				SGI(ifp)->mi_yoff,
				OGL(ifp)->vp_width,
				OGL(ifp)->vp_height);
d2070 2
a2071 3
	} else if 
	((OGL(ifp)->win_width > ifp->if_width) || 
	 (OGL(ifp)->win_height > ifp->if_height)) {
d2073 1
a2073 1
	 	if (OGL(ifp)->copy_flag && !OGL(ifp)->front_flag){
d2075 2
a2076 1
			glViewport(0, 0, OGL(ifp)->win_width, OGL(ifp)->win_height);      
d2081 2
a2082 1
			glViewport(0, 0, OGL(ifp)->win_width, OGL(ifp)->win_height);      
d2087 4
a2090 4
		glViewport(	SGI(ifp)->mi_xoff,
				SGI(ifp)->mi_yoff,
				OGL(ifp)->vp_width,
				OGL(ifp)->vp_height);
d2095 1
a2095 1
	if(SGI(ifp)->mi_doublebuffer){
d2097 1
a2097 1
	} else if (OGL(ifp)->copy_flag) {
d2101 13
a2113 12
if(CJDEBUG) {
	int dbb,db,view[4],getster,getaux;
	glGetIntegerv(GL_VIEWPORT, view);
	glGetIntegerv(GL_DOUBLEBUFFER,&dbb);
	glGetIntegerv(GL_DRAW_BUFFER,&db);
	printf("Viewport: x %d y %d width %d height %d\n",view[0],view[1],view[2],view[3]);
	printf("expose: double buffered: %d, draw buffer %d\n",dbb,db);
	printf("front %d\tback%d\n",GL_FRONT,GL_BACK);
	glGetIntegerv(GL_STEREO,&getster);
	glGetIntegerv(GL_AUX_BUFFERS,&getaux);
	printf("double %d, stereo %d, aux %d\n",dbb,getster,getaux);
}
d2115 3
a2117 3
	if (multiple_windows) {
	/* unattach context for other threads to use */
	glXMakeCurrent(OGL(ifp)->dispp,None,NULL);
a2118 2

	return TCL_OK;
a2121 16
#ifndef FB_USING_TCL_TK
void PostIt(Widget w, XtPointer client_data, XButtonEvent *event)
{
	FBIO *ifp;

	if(CJDEBUG) printf("entering PostIt\n");

	if (event->button != Button3)
		return;

	ifp = (FBIO *) client_data;

	XmMenuPosition(popup, event);
	XtManageChild(popup);
	XtAddCallback(popup,XmNentryCallback, CloseCB, (XtPointer) ifp);
}
a2122 9
void CloseCB(Widget w, XtPointer client_data, XtPointer call_data)
{
	FBIO *ifp;

	if(CJDEBUG) printf("entering CloseCB\n");
	ifp =  (FBIO *) client_data;     
	OGL(ifp)->close_me = 1;
}
#endif
a2123 1

d2150 1
a2150 1
make_bitmap(ifp, data, xbits, ybits)
d2152 1
a2158 1
	XWindowAttributes wa;
a2166 1
	window = OGL(ifp)->wind;
d2181 1
a2181 3
	XGetWindowAttributes(display, window, &wa);

	xip = XCreateImage(display, wa.visual, 1, XYBitmap, 0, rdata, 
d2188 3
a2190 1
	pmap = XCreatePixmap(display, window, xbits, ybits,1);
a2366 3

#ifdef FB_USING_TCL_TK
#endif
@


1.13
log
@Fixed description string
@
text
@d34 6
@


1.12
log
@Bparker sigkid() support
@
text
@d168 1
a168 1
	"Silicon Graphics Iris '5D'",	/* device description	*/
@


1.11
log
@removed dependence on libbu.
@
text
@d109 1
d544 7
a550 1
static void sigkid()
d675 1
a675 1
					(unsigned long *) op);
d688 1
a688 1
				(unsigned long *) ifp->if_mem);
d1193 1
a1193 1

d1195 1
d1271 1
a1271 1

d1273 1
a1273 1

d1347 1
a1347 1

d1349 1
a1349 1

a1431 1

d1506 1
a1506 1

d1508 1
a1508 1

d1536 1
a1536 1
		else { /* just write rectangle*/
d1600 1
d1602 1
a1602 1
	
d1700 1
a1700 1

d1702 1
a1702 1

d1792 1
a1792 1

d1794 1
a1794 1

d1841 1
a1841 1

d1843 1
a1843 1

d1891 1
@


1.10
log
@mods made by bparker.
@
text
@d987 1
d991 4
a994 5
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "wm title . \"%s\";", title);
	  bu_vls_printf(&vls, "wm resizable . 0 0");
	  status = Tcl_Eval(OGL(ifp)->interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
@


1.9
log
@initial whack at ridding if_ogl of Motif
@
text
@a34 1
#ifdef FB_USING_TCL_TK
a35 8
#else
#include <Xm/Xm.h> 
#include <Xm/Form.h> 
#include <Xm/RowColumn.h>
#include <Xm/MenuShell.h>
#include <Xm/PushBG.h>
#include <Xm/DrawingA.h>
#endif
d55 1
a102 1
#ifdef FB_USING_TCL_TK
a106 6
#else
static void input(Widget, XtPointer, XtPointer); 
static void expose_callback (Widget, XtPointer, XtPointer); 
static void CloseCB(Widget, XtPointer, XtPointer);
static void PostIt(Widget, XtPointer, XButtonEvent *);
#endif
a116 4
#ifndef FB_USING_TCL_TK
static Widget 	popup;
static Widget 	popupshell;
#endif
a249 1
#ifdef FB_USING_TCL_TK
d251 1
a255 9
#else
	XtAppContext 	appc;		/* application context */
	GLXContext	glxc;		/* graphics context */
	Display     *	dispp;		/* display */
	Window 		wind;		/* window id */
	Widget 		toplevel;	/* top widget for this framebuffer */
	Widget 		form;		/* widget to add popup to */
	Widget		glw;		/* graphics library widget */
#endif
a711 3
#ifndef FB_USING_TCL_TK
	Arg args[20];  
#endif  
a899 1
#ifdef FB_USING_TCL_TK
d908 7
a914 3
	if((OGL(ifp)->tkwin = Tk_CreateMainWindow(OGL(ifp)->interp, (char *)NULL,
						  title, "LIBFB")) == NULL){
	  fb_log("ogl_open: Failed to create main window.\n");
d918 4
a921 2
	if (Tk_Init(OGL(ifp)->interp) == TCL_ERROR){
	  fb_log("Tk_Init error %s\n", OGL(ifp)->interp->result);
d979 2
a982 2
	Tk_GeometryRequest(OGL(ifp)->tkwin, ifp->if_width, ifp->if_height);
	Tk_ResizeWindow(OGL(ifp)->tkwin, ifp->if_width, ifp->if_height);
d985 11
d1029 1
d1035 1
a1035 131
	  Tk_DoOneEvent(TK_ALL_EVENTS|TK_DONT_WAIT);
	}
#else
	/* Start up XtIntrinsics */
	XtToolkitInitialize();
	OGL(ifp)->appc = XtCreateApplicationContext();
	OGL(ifp)->dispp = XtOpenDisplay(OGL(ifp)->appc, NULL, NULL, NULL,
				NULL, 0, &fargc, NULL);

	/* Choose an appropriate visual */
	if ((OGL(ifp)->vip = ogl_choose_visual(ifp))==NULL){
		fb_log("ogl_open: Couldn't find an appropriate visual. Exiting.\n");
		exit(-1);
	}

	/* Open an OpenGL context with this visual*/
	if (multiple_windows){	/* force indirect context */
		OGL(ifp)->glxc = glXCreateContext(OGL(ifp)->dispp,
					OGL(ifp)->vip, 0, GL_FALSE);
	} else {		/* try direct context */
		OGL(ifp)->glxc = glXCreateContext(OGL(ifp)->dispp,
					OGL(ifp)->vip, 0, GL_TRUE);
	}

	if (CJDEBUG){
		direct = glXIsDirect(OGL(ifp)->dispp,OGL(ifp)->glxc);
		printf("Context is %s.\n", direct ? "direct" : "indirect");
	}


	/* Create a colormap for this visual */
	SGI(ifp)->mi_cmap_flag = !is_linear_cmap(ifp);
	if (!OGL(ifp)->soft_cmap_flag) {
		OGL(ifp)->xcmap = XCreateColormap(OGL(ifp)->dispp,
					RootWindow(OGL(ifp)->dispp,
						OGL(ifp)->vip->screen),
					OGL(ifp)->vip->visual,
					AllocAll);
		/* initialize virtual colormap - it will be loaded into
		 * the hardware. This code has not yet been tested.
		 */
		if(CJDEBUG) printf("Loading read/write colormap.\n");
	    	for (i = 0; i < 256; i++) {
	    		color_cell[i].pixel = i;
	    		color_cell[i].red = CMR(ifp)[i];
	    		color_cell[i].green = CMG(ifp)[i];
	    		color_cell[i].blue = CMB(ifp)[i];
	    		color_cell[i].flags = DoRed | DoGreen | DoBlue;
	    	}
    		XStoreColors(OGL(ifp)->dispp, OGL(ifp)->xcmap, color_cell, 256);
	} else { /* read only colormap */
		OGL(ifp)->xcmap = XCreateColormap(OGL(ifp)->dispp,
					RootWindow(OGL(ifp)->dispp,
						OGL(ifp)->vip->screen),
					OGL(ifp)->vip->visual,
					AllocNone);
	}


	/* 
	 * Create Application shell and widgets
	 */
	n = 0;
	XtSetArg(args[n], XmNtitle, title); n++;	
	if (!ogl_nwindows) { /* else let wm decide */
		XtSetArg(args[n], XmNx, xpos); n++;
		XtSetArg(args[n], XmNy, ypos); n++;
	} 
	XtSetArg(args[n], XmNvisual, OGL(ifp)->vip->visual); n++;
	XtSetArg(args[n], XmNcolormap, OGL(ifp)->xcmap); n++;
	XtSetArg(args[n], XmNdepth, OGL(ifp)->vip->depth); n++;
	OGL(ifp)->toplevel = XtAppCreateShell(NULL,NULL,
			applicationShellWidgetClass, OGL(ifp)->dispp, args, n);

	n = 0;
	XtSetArg(args[n], XmNnoResize, True); n++;
	OGL(ifp)->form = XmCreateForm(OGL(ifp)->toplevel, "form", args, n);
	XtManageChild(OGL(ifp)->form);     

	n = 0;
	XtSetArg(args[n], XmNbottomAttachment, XmATTACH_FORM); n++;    
	XtSetArg(args[n], XmNtopAttachment, XmATTACH_FORM); n++;    
	XtSetArg(args[n], XmNleftAttachment, XmATTACH_FORM); n++;    
	XtSetArg(args[n], XmNrightAttachment, XmATTACH_FORM); n++;    
	XtSetArg(args[n], XmNwidth, win_width); n++;
	XtSetArg(args[n], XmNheight, win_height); n++;
	OGL(ifp)->glw = XmCreateDrawingArea(OGL(ifp)->form, "glwidget",
				args, n);

	XtManageChild (OGL(ifp)->glw);    

	XtAddCallback(OGL(ifp)->glw, XmNexposeCallback,    
		expose_callback, (XtPointer) ifp);    
	XtAddCallback(OGL(ifp)->glw, XmNinputCallback, 
		input,    (XtPointer) ifp);     


	/* realize window on the screen */
	XtRealizeWidget(OGL(ifp)->toplevel);
	OGL(ifp)->wind = XtWindow(OGL(ifp)->glw);
	/* count windows */
	ogl_nwindows++;

	/* 
	 * Cursor set-up:
	 * create the default cursor and an invisible cursor for when the
	 * cursor is off
	 */
	src_bitmap = make_bitmap(ifp, arr_data.bits, 
				arr_data.xbits, arr_data.ybits);
	/* (complication in last parameter is conversion from 
	 *  first quadrant to third quadrant coordinates)
	 */
	OGL(ifp)->cursor = XCreatePixmapCursor(OGL(ifp)->dispp, src_bitmap,
			src_bitmap, &curs_color, &curs_color, 
			arr_data.xorig, arr_data.ybits - arr_data.yorig - 1);
	XFreePixmap(OGL(ifp)->dispp,src_bitmap);

	/* only need one copy of null cursor for all open windows*/
	if (ogl_nwindows < 2) {
		nil_bitmap = make_bitmap(ifp, nil_data.bits,nil_data.xbits, nil_data.ybits);
		nil_cursor = XCreatePixmapCursor(OGL(ifp)->dispp, nil_bitmap,
			nil_bitmap, &curs_color, &curs_color, 
			nil_data.xorig, nil_data.ybits - nil_data.yorig -1);
		XFreePixmap(OGL(ifp)->dispp,nil_bitmap);
	}

	if ( SGI(ifp)->mi_curs_on == 0 ) {
		XDefineCursor(OGL(ifp)->dispp,OGL(ifp)->wind,nil_cursor);
	} else {
		XDefineCursor(OGL(ifp)->dispp,OGL(ifp)->wind,OGL(ifp)->cursor);
a1037 12


	/* Must call "is_linear_cmap" AFTER "ogl_getmem" which allocates
		space for the color map.				*/

	/* Loop through events until first exposure event is processed */
	OGL(ifp)->firstTime = 1;
	while(OGL(ifp)->firstTime){
		XtAppNextEvent(OGL(ifp)->appc, &event);
		XtDispatchEvent(&event);
	}
#endif
d1051 1
a1051 6
#ifdef FB_USING_TCL_TK
	Tk_DestroyWindow(OGL(ifp)->tkwin);
#else
	XtUnmapWidget(OGL(ifp)->toplevel);
	XtDestroyWidget(OGL(ifp)->toplevel);
#endif
a1091 5
#ifndef FB_USING_TCL_TK
	XEvent event;
	Widget closeit;
	Arg args[10];
#endif
a1131 33
#ifndef FB_USING_TCL_TK
	/* Line up at the "complaints window", just in case... */
	fp = fopen("/dev/console", "w");

	kill(SGI(ifp)->mi_parent, SIGUSR1);	/* zap the lurking parent */

	scr = DefaultScreen(OGL(ifp)->dispp);
	n = 0;
	XtSetArg(args[n], XmNvisual, DefaultVisual(OGL(ifp)->dispp, scr)); n++;
	XtSetArg(args[n], XmNdepth, DefaultDepth(OGL(ifp)->dispp, scr)); n++;
	XtSetArg(args[n], XmNcolormap, DefaultColormap(OGL(ifp)->dispp, scr));	n++;
	XtSetArg(args[n], XmNheight, 100); n++;
	XtSetArg(args[n], XmNwidth, 100); n++;
	popupshell = XmCreateMenuShell(OGL(ifp)->form, "pshell", args, n);
	
	n = 0;
	XtSetArg(args[n], XmNrowColumnType, XmMENU_POPUP); n++;
	popup = XmCreateRowColumn(popupshell, "popup", args, n);
	XtAddEventHandler(OGL(ifp)->form, ButtonPressMask, False, (XtEventHandler) PostIt, ifp);

	closeit = XmCreatePushButtonGadget(popup,"close",NULL,0);
	XtManageChild(closeit);

	/* loop until close menu is selected */
	OGL(ifp)->close_me = 0;
	while(!OGL(ifp)->close_me){
		XtAppNextEvent(OGL(ifp)->appc, &event);
		XtDispatchEvent(&event);
	}

	if( fp ) fclose(fp);		/* close our "complaints window" */
#endif

d1147 1
a1147 8
#ifdef FB_USING_TCL_TK
	while(Tk_DoOneEvent(TK_ALL_EVENTS|TK_DONT_WAIT));
#else
	while ((int) XtAppPending(OGL(ifp)->appc)){
		XtAppNextEvent(OGL(ifp)->appc,&event);
		XtDispatchEvent(&event);
	}
#endif
d1187 1
a1187 8
#ifdef FB_USING_TCL_TK
	while(Tk_DoOneEvent(TK_ALL_EVENTS|TK_DONT_WAIT));
#else
	while ((int) XtAppPending(OGL(ifp)->appc)){
		XtAppNextEvent(OGL(ifp)->appc,&event);
		XtDispatchEvent(&event);
	}
#endif
d1264 1
a1264 8
#ifdef FB_USING_TCL_TK
	while(Tk_DoOneEvent(TK_ALL_EVENTS|TK_DONT_WAIT));
#else
	while ((int) XtAppPending(OGL(ifp)->appc)){
		XtAppNextEvent(OGL(ifp)->appc,&event);
		XtDispatchEvent(&event);
	}
#endif
d1340 1
a1340 8
#ifdef FB_USING_TCL_TK
	        while(Tk_DoOneEvent(TK_ALL_EVENTS|TK_DONT_WAIT));
#else
	while ((int) XtAppPending(OGL(ifp)->appc)){
		XtAppNextEvent(OGL(ifp)->appc,&event);
		XtDispatchEvent(&event);
	}
#endif
d1500 1
a1500 8
#ifdef FB_USING_TCL_TK
	        while(Tk_DoOneEvent(TK_ALL_EVENTS|TK_DONT_WAIT));
#else
	while ((int) XtAppPending(OGL(ifp)->appc)){
		XtAppNextEvent(OGL(ifp)->appc,&event);
		XtDispatchEvent(&event);
	}
#endif
d1593 2
a1594 9
#ifdef FB_USING_TCL_TK
	        while(Tk_DoOneEvent(TK_ALL_EVENTS|TK_DONT_WAIT));
#else
	while ((int) XtAppPending(OGL(ifp)->appc)){
		XtAppNextEvent(OGL(ifp)->appc,&event);
		XtDispatchEvent(&event);
	}
#endif

a1687 3
#ifndef FB_USING_TCL_TK
	Arg args[1];	
#endif
d1693 1
a1693 8
#ifdef FB_USING_TCL_TK
	        while(Tk_DoOneEvent(TK_ALL_EVENTS|TK_DONT_WAIT));
#else
	while ((int) XtAppPending(OGL(ifp)->appc)){
		XtAppNextEvent(OGL(ifp)->appc,&event);
		XtDispatchEvent(&event);
	}
#endif
d1785 1
a1785 8
#ifdef FB_USING_TCL_TK
	        while(Tk_DoOneEvent(TK_ALL_EVENTS|TK_DONT_WAIT));
#else
	while ((int) XtAppPending(OGL(ifp)->appc)){
		XtAppNextEvent(OGL(ifp)->appc,&event);
		XtDispatchEvent(&event);
	}
#endif
d1834 1
a1834 8
#ifdef FB_USING_TCL_TK
	        while(Tk_DoOneEvent(TK_ALL_EVENTS|TK_DONT_WAIT));
#else
	while ((int) XtAppPending(OGL(ifp)->appc)){
		XtAppNextEvent(OGL(ifp)->appc,&event);
		XtDispatchEvent(&event);
	}
#endif
d1857 1
a1857 9
#ifdef FB_USING_TCL_TK
	        while(Tk_DoOneEvent(TK_ALL_EVENTS|TK_DONT_WAIT));
#else
	while ((int) XtAppPending(OGL(ifp)->appc)){
		XtAppNextEvent(OGL(ifp)->appc,&event);
		XtDispatchEvent(&event);
	}
#endif

a1978 1
#ifdef FB_USING_TCL_TK
a1982 4
#else
static void 
expose_callback (Widget w, XtPointer client_data, XtPointer call) 
#endif
a1983 1
#ifdef FB_USING_TCL_TK
a1984 6
#else
	XmDrawingAreaCallbackStruct *call_data;
	Arg args[10];
	int n;
	Dimension width, height;
#endif
a1991 4
#ifndef FB_USING_TCL_TK
	call_data = (XmDrawingAreaCallbackStruct *) call;    
#endif

a2026 1
#ifdef FB_USING_TCL_TK
d2030 1
a2030 8
#else
		n = 0;
		XtSetArg(args[n], XmNwidth, &width); n++;
		XtSetArg(args[n], XmNheight, &height); n++;
		XtGetValues(OGL(ifp)->glw, args, n);
		OGL(ifp)->win_width = width;
		OGL(ifp)->win_height = height;
#endif
@


1.8
log
@removed need for special GLwDrawingArea widgets
@
text
@d35 3
d44 1
d111 6
d121 1
d124 1
d132 1
d135 1
d269 7
d283 1
a738 1

d740 3
a742 1
	Arg args[20];    
d931 121
a1145 1

d1193 2
a1194 2

	return	0;
a1205 1

d1207 3
d1212 1
d1253 1
d1257 1
d1298 1
d1329 1
d1346 3
d1353 1
d1393 3
d1400 1
d1477 3
d1484 1
d1560 3
d1567 1
d1727 3
d1734 1
a1734 1

d1827 3
d1834 1
a1834 1

d1929 1
d1931 1
d1937 3
d1944 1
a1944 1

d2036 3
d2043 1
d2092 3
d2099 1
d2122 3
d2129 1
a2130 1

d2224 1
d2250 1
a2250 1

d2252 6
d2260 1
d2262 3
a2265 2
	FBIO *ifp;
	struct ogl_clip *clp;
d2269 3
d2277 1
d2279 1
d2316 5
d2327 1
a2327 1
		
d2406 1
d2410 1
a2410 1

d2435 1
d2682 4
@


1.7
log
@*** empty log message ***
@
text
@d38 1
d40 1
d43 1
a43 1
#include <GL/GLwMDrawA.h>  
a108 1
static void init_window(Widget, XtPointer, XtPointer);  
d121 1
d268 2
d595 1
a595 1
	if((xbase + npix -1) > clp->xpixmax)
d689 1
d715 1
a715 1
	int		mode, i;
d920 15
d973 3
a984 1
	XtSetArg(args[n], GLwNvisualInfo, OGL(ifp)->vip); n++;
d991 2
a992 2
	OGL(ifp)->glw = GLwCreateMDrawingArea(OGL(ifp)->form, "glwidget", 
				args, n);    
d996 1
a996 1
	XtAddCallback(OGL(ifp)->glw, GLwNexposeCallback,    
d998 1
a998 3
	XtAddCallback(OGL(ifp)->glw, GLwNginitCallback, 
		init_window,    (XtPointer) ifp);    
	XtAddCallback(OGL(ifp)->glw, GLwNinputCallback, 
d1109 2
a1110 1

d1155 12
a1166 2
	/* Create popup widget to act implement the close menu button */
	popup = XmCreatePopupMenu(OGL(ifp)->form, "popup", NULL, 0);
d2041 1
a2041 1
	GLwDrawingAreaCallbackStruct *call_data;     
d2046 1
a2046 1
	call_data = (GLwDrawingAreaCallbackStruct *) call;     
a2061 22
static void 
init_window(Widget w, XtPointer client_data, XtPointer call) 
{
	int direct;
	FBIO *ifp;

	if(CJDEBUG) printf("entering init_window\n");

	ifp = (FBIO *) client_data;

	if (multiple_windows){
		OGL(ifp)->glxc = glXCreateContext(OGL(ifp)->dispp,OGL(ifp)->vip, 0, GL_FALSE);
	} else {
		OGL(ifp)->glxc = glXCreateContext(OGL(ifp)->dispp,OGL(ifp)->vip, 0, GL_TRUE);
	}

	if (CJDEBUG){
		direct = glXIsDirect(OGL(ifp)->dispp,OGL(ifp)->glxc);
		printf("Context is %s.\n", direct ? "direct" : "indirect");
	}

}
d2066 1
a2066 1
	GLwDrawingAreaCallbackStruct *call_data;
d2069 3
d2077 1
a2077 1
	call_data = (GLwDrawingAreaCallbackStruct *) call;    
d2114 7
d2122 1
a2122 1
		glViewport(0, 0, call_data->width, call_data->height);      
d2129 4
a2132 4
		OGL(ifp)->vp_width = (call_data->width < ifp->if_width) ?
				call_data->width : ifp->if_width;
		OGL(ifp)->vp_height = (call_data->height < ifp->if_height) ?
				call_data->height : ifp->if_height;
d2137 2
a2138 2
		SGI(ifp)->mi_xoff = (call_data->width - OGL(ifp)->vp_width)/2;
		SGI(ifp)->mi_yoff = (call_data->height - OGL(ifp)->vp_height)/2;
d2152 2
a2153 2
	((call_data->width > ifp->if_width) || 
	 (call_data->height > ifp->if_height)) {
d2157 1
a2157 1
			glViewport(0, 0, call_data->width, call_data->height);      
d2162 1
a2162 1
			glViewport(0, 0, call_data->width, call_data->height);      
@


1.6
log
@Increased speed by using direct context and by not unattaching
theglXContext in every call. Hence need for 'm' option.
Changed pixel component order to be compatible with /dev/sgi
@
text
@d949 4
a952 2
	XtSetArg(args[n], XmNx, xpos); n++;
	XtSetArg(args[n], XmNy, ypos); n++;
@


1.5
log
@polished clipping calls and removed old code segments
@
text
@d120 5
a124 1
static int	ogl_nwindows = 0; 	/* track of open windows */
d205 2
d209 3
a212 3
	unsigned char green;
	unsigned char blue;
	unsigned char alpha;
d215 1
a215 1
/* Clipping structure, for zoom/pan operations on non-GT systems */
d318 4
d352 2
d552 2
a553 1
/* OGL_XMIT_SCANLINES
d574 1
a574 1
	/* Caller is expected handle attaching context, etc. */
d669 1
a669 1
			glDrawPixels(npix,1,GL_RGBA,GL_UNSIGNED_BYTE,
d682 1
a682 1
		glDrawPixels(npix,nlines,GL_RGBA,GL_UNSIGNED_BYTE,
d794 8
d812 1
a842 1

a871 1
/*		noborder();*/
d882 1
a882 1
			"Transient Win" :
a982 1
	ogl_nwindows++;		
d984 2
d1211 1
d1215 1
d1263 1
d1266 1
d1314 1
d1318 1
d1345 1
d1348 1
d1534 1
d1538 1
a1538 1

d1569 1
d1572 1
d1630 2
d1635 1
d1648 1
d1651 1
d1755 1
d1759 1
d1767 4
a1784 2
	/* unattach context for other threads to use, also flushes */
	glXMakeCurrent(OGL(ifp)->dispp,None,NULL);
d2032 1
a2032 4
	int dbb;
	Arg args[1];
        XVisualInfo *vi;
	int use, rgba, red, green, blue, alpha, dbfr, stereo;
d2039 10
a2048 1
	OGL(ifp)->glxc = glXCreateContext(OGL(ifp)->dispp,OGL(ifp)->vip, 0, GL_FALSE);
d2065 1
d2069 1
d2173 1
d2176 1
a2176 1

@


1.4
log
@improved clipping matrix calls
@
text
@a49 5
#include <get.h>
#include <device.h>
#if 0
#include <sys/invent.h>
#endif
d61 1
a61 1
#define CJDEBUG 1
d282 1
a282 1
#define CLIP_XTRA 2
a562 11
#if 0
	if( ifp->if_zoomflag )  {
		sw_zoom = 1;
	} else {
		sw_zoom = 0;
	}
	if( ifp->if_xcenter != ifp->if_width/2 ||
	    ifp->if_ycenter != ifp->if_height/2 )  {
	    	sw_zoom = 1;
	}
#endif
d584 39
a622 4
	/* in COPY mode, always draw full sized image into backbuffer.
	 * backbuffer_to_screen() is used to update the front buffer
	 */ 
	if ( OGL(ifp)->copy_flag && OGL(ifp)->front_flag){
d628 2
a629 2
		glOrtho( -0.5, ((GLdouble) OGL(ifp)->vp_width)-0.5,
			-0.5, ((GLdouble) OGL(ifp)->vp_height)-0.5,
a631 6
#if 0
	} else {
	/* Draw an extra edge of pixels for cleanness when zooming*/
	if ((xbase + npix) < ifp->if_width) npix++;
	if ((ybase + nlines) < ifp->if_height) nlines++;
#endif
a653 1

d669 3
d673 1
a673 1
	int valid, error;
a677 1
	error = glGetError();
a678 1
	printf("Error code %d\t",error);
a679 2
		glDrawPixels(npix,nlines,GL_RGBA,GL_UNSIGNED_BYTE,
				(unsigned long *) ifp->if_mem);
a681 6
if (CJDEBUG) {
	int error;
	error = glGetError();
	printf("Error code %d\n",error);
}

a683 40

	/*
	 * Blank out areas of the screen around the image, if exposed.
	 * In COPY mode, this is done in backbuffer_to_screen().
	 */
	if (!OGL(ifp)->copy_flag){
		/* Do a couple of extra pixels outside of the screen to eliminate 
		 * rounding fuzz
		 */
		/* Blank out area left of image */
		glColor3b( 0, 0, 0 );
		if( clp->xscrmin < 0 )  glRecti(
			clp->xscrmin - CLIP_XTRA,
			clp->yscrmin - CLIP_XTRA,
			0,
			clp->yscrmax + CLIP_XTRA);


		/* Blank out area below image */
		if( clp->yscrmin < 0 )  glRecti(
			clp->xscrmin - CLIP_XTRA,
			clp->yscrmin - CLIP_XTRA,
			clp->xscrmax + CLIP_XTRA,
			0);

		/* Blank out area right of image */
		if( clp->xscrmax > ifp->if_width )  glRecti(
			ifp->if_width,
			clp->yscrmin - CLIP_XTRA,
			clp->xscrmax + CLIP_XTRA,
			clp->yscrmax + CLIP_XTRA);
		
		/* Blank out area above image */
		if( clp->yscrmax > ifp->if_height )  glRecti(
			clp->xscrmin - CLIP_XTRA,
			ifp->if_height,
			clp->xscrmax + CLIP_XTRA,
			clp->yscrmax + CLIP_XTRA);
		
	}
d708 1
a708 9
	/* superceded by new visual selection procedure */
#if 0
	static String 	fallback_resources[] = {    
		"*glwidget*doublebuffer: TRUE",    /* this must be the first resource */
		"*glwidget*rgba: TRUE",    
		"*glwidget*allocateBackground: TRUE",    
		NULL    };
	static String 	single_buf_resource = "*glwidget*doublebuffer: FALSE";
#endif
a858 8
#if 0
	/* specify single buffering if set by the mode */
	if( (ifp->if_mode & MODE_9MASK) == MODE_9SINGLEBUF )  {
		fallback_resources[0] = single_buf_resource;
	} 
#endif
	

d883 1
a883 2


d906 1
a906 1
		if(CJDEBUG) printf("Attempting colormap change\n");
d925 1
a925 1
	 * Create Application context and widgets
d933 1
a933 4
#if 0
	OGL(ifp)->toplevel = XtAppInitialize(&(OGL(ifp)->appc), "Top",    
		(XrmOptionDescList) NULL , 0,&fake_argc, (String *) NULL, NULL, args, n);    
#endif
a959 1
	ogl_nwindows++;		/* track # of simultaneous windows */
a960 2


d963 1
a963 5

	/* store information about the window used */
#if 0
	OGL(ifp)->dispp = XtDisplay(OGL(ifp)->glw);
#endif
a999 1
#if 0
a1000 23
	/* note: By this point software colormapping has been enabled by
	 * init_window() if hardware mapping is not possible.
	 * Send colormap to hardware if we still think we can do it,
	 * and we think we need to (mi_cmap_flag)
	 */          
	SGI(ifp)->mi_cmap_flag = !is_linear_cmap(ifp);
	if( (!(OGL(ifp)->soft_cmap_flag)) && SGI(ifp)->mi_cmap_flag )  {
	    	XColor cells[256];
	    	int i;

		/* Send color map to hardware - not yet tested */
		if(CJDEBUG) printf("Attempted colormap change\n");

	    	for (i = 0; i < 256; i++) {
	    		color_cell[i].pixel = i;
	    		color_cell[i].red = CMR(ifp)[i];
	    		color_cell[i].green = CMG(ifp)[i];
	    		color_cell[i].blue = CMB(ifp)[i];
	    		color_cell[i].flags = DoRed | DoGreen | DoBlue;
	    	}
    		XStoreColors(OGL(ifp)->dispp, OGL(ifp)->xcmap, color_cell, 256);
	}
#endif
d1306 1
a1306 6
	glOrtho( clp->oleft,clp->oright,clp->obottom,clp->otop,-1.0,1.0);
#if 0
	glOrtho(((GLdouble) clp->xscrmin)-0.5, ((GLdouble) clp->xscrmax)-0.5, 
		((GLdouble) clp->yscrmin)-0.5, ((GLdouble) clp->yscrmax)-0.5, 
		-1.0, 1.0);
#endif
d2000 1
a2000 6
#if 0
        XtSetArg(args[0], GLwNvisualInfo, &vi);
        XtGetValues(w, args, 1); 
	OGL(ifp)->vip = vi;
        OGL(ifp)->glxc = glXCreateContext(XtDisplay(w), vi, 0, GL_FALSE);
#endif
a2001 3
#if 0	
	if(CJDEBUG) {

a2002 32

		printf("HERE ");

		glXGetConfig(XtDisplay(w),vi,GLX_USE_GL,&use);
		printf("GL %d ",use);
		glXGetConfig(XtDisplay(w),vi,GLX_RGBA,&rgba);
		glXGetConfig(XtDisplay(w),vi,GLX_RED_SIZE,&red);
		glXGetConfig(XtDisplay(w),vi,GLX_GREEN_SIZE,&green);
		glXGetConfig(XtDisplay(w),vi,GLX_BLUE_SIZE,&blue);
		glXGetConfig(XtDisplay(w),vi,GLX_ALPHA_SIZE,&alpha);
		glXGetConfig(XtDisplay(w),vi,GLX_DOUBLEBUFFER,&dbfr);
		glXGetConfig(XtDisplay(w),vi,GLX_STEREO,&stereo);
		printf("GL %d rgba %d %d/%d/%d/%d dbfr %d stereo %d\n",use,rgba,red,green,blue,alpha,dbfr,stereo);
		printf("CLass is %d\n",vi->class);
	}

	/* Determine whether the selected visual supports hardware cmapping.
	 * This may never happen. In future, choose our own visual to find one
	 * which does support hardware mapping
	 */
	if ((vi->class == DirectColor)&&(vi->depth == 24)&&(vi->colormap_size>=256)){
		OGL(ifp)->cmap_size = vi->colormap_size;
		OGL(ifp)->xcmap = XCreateColormap(XtDisplay(w), OGL(ifp)->wind,
				vi->visual, AllocNone);
	} else {
		/* any cmapping must be done by software */
		if(CJDEBUG) printf("NOTE: hardware colormapping not possible\n");
		OGL(ifp)->cmap_size = 0;
		ifp->if_mode |= MODE_7MASK; /* enables software flag */
	}
#endif

d2005 2
a2006 1
static void expose_callback (Widget w, XtPointer client_data, XtPointer call) 
d2025 1
a2025 1
		/* just incase the configuration is double buffered but
d2031 1
a2031 4
#if 0
		/* determine whether or not double buffering succeeded. */
		glGetIntegerv(GL_DOUBLEBUFFER,&(SGI(ifp)->mi_doublebuffer));
#endif
a2079 5
#if 0
		glOrtho(((GLdouble) clp->xscrmin)-0.5, ((GLdouble) clp->xscrmax)-0.5, 
			((GLdouble) clp->yscrmin)-0.5, ((GLdouble) clp->yscrmax)-0.5, 
			-1.0, 1.0);
#endif
d2117 1
a2117 1
	printf("expose: double buffer %d, draw buffer %d\n",dbb,db);
a2118 1

d2123 1
d2207 2
a2208 1
	if(CJDEBUG) printf("xbits %d, ybits %d, xbytes %d\n",xbits,ybits,xbytes);
a2268 12
#if 0
		xpixels = clp->xpixmax - clp->xpixmin +1;
		if( (clp->xpixmin + xpixels) < ifp->if_width) xpixels++;
		ypixels = clp->ypixmax - clp->ypixmin + 1;
		if( (clp->ypixmin + xpixels) < ifp->if_height) ypixels++;
#endif
		glRasterPos2i(clp->xpixmin,clp->ypixmin);
		glCopyPixels(SGI(ifp)->mi_xoff + clp->xpixmin,
			SGI(ifp)->mi_yoff + clp->ypixmin,
			clp->xpixmax - clp->xpixmin +1,
			clp->ypixmax - clp->ypixmin +1,
			GL_COLOR);
d2275 1
a2275 1
			0,
d2283 1
a2283 1
			0);
d2289 2
a2290 2
		if( clp->xscrmax > OGL(ifp)->vp_width )  glRecti(
			ifp->if_width,
d2296 1
a2296 1
		if( clp->yscrmax > OGL(ifp)->vp_height )  glRecti(
d2298 1
a2298 1
			OGL(ifp)->vp_height,
d2302 8
a2326 1
 *
d2399 1
d2412 1
a2412 3
			/* relax hardware colormap requirement
			 * and turn on software colormapping
			 */
d2422 1
a2422 4
			/* relax double buffering requirement.
			 * We must turn off double buffered mode 
			 * and copy mode.
			 */
d2426 1
a2426 1
			/* we're as relaxed as we can get already */
@


1.3
log
@added a visual selection strategy
@
text
@d66 1
a66 1
#define CJDEBUG 0
d124 3
a126 2
static Widget popup;
static int	ogl_nwindows = 0;
d128 1
d224 5
d346 1
a346 1
		"Suppress dithering - else dither if deemed appropriate" },
d594 1
a594 1
	if((xbase + npix - 1) > clp->xpixmax)
d609 2
a610 2
		glOrtho((GLdouble) 0, (GLdouble) OGL(ifp)->vp_width,
			(GLdouble) 0, (GLdouble) OGL(ifp)->vp_height,
d613 6
a620 1

d641 1
a641 1
				
d643 1
a643 1
			glRasterPos3i(xbase,y,0);
d656 1
a656 1
		glRasterPos3i(xbase,ybase,-1);
d658 2
a659 1
	int valid, rpos[4], error;
d662 1
a662 1
	glGetIntegerv(GL_CURRENT_RASTER_POSITION, rpos);
d664 2
a665 2
	printf("Raster position (%d, %d, %d, %d) has validity %d.\n",rpos[0],rpos[1],rpos[2],rpos[3],valid);
	printf("Error code %d\n",error);
a666 1

d670 7
d705 2
a706 2
		if( clp->xscrmax >= ifp->if_width )  glRecti(
			ifp->if_width - 1,
d712 1
a712 1
		if( clp->yscrmax >= ifp->if_height )  glRecti(
d714 1
a714 1
			ifp->if_height - 1,
a741 1
	XColor		cells[256];
d949 1
a949 1
	if (OGL(ifp)->soft_cmap_flag) {
d960 5
a964 5
	    		cells[i].pixel = i;
	    		cells[i].red = CMR(ifp)[i];
	    		cells[i].green = CMG(ifp)[i];
	    		cells[i].blue = CMB(ifp)[i];
	    		cells[i].flags = DoRed | DoGreen | DoBlue;
d966 1
a966 1
    		XStoreColors(OGL(ifp)->dispp, OGL(ifp)->xcmap, cells, 256);
d1078 5
a1082 5
	    		cells[i].pixel = i;
	    		cells[i].red = CMR(ifp)[i];
	    		cells[i].green = CMG(ifp)[i];
	    		cells[i].blue = CMB(ifp)[i];
	    		cells[i].flags = DoRed | DoGreen | DoBlue;
d1084 1
a1084 1
    		XStoreColors(OGL(ifp)->dispp, OGL(ifp)->xcmap, cells, 256);
d1392 4
a1395 2
	glOrtho((GLdouble) clp->xscrmin, (GLdouble) (clp->xscrmax + 1), 
		(GLdouble) clp->yscrmin, (GLdouble) (clp->yscrmax + 1), 
d1397 1
a1780 2
	XColor cells[256];	

d1824 5
a1828 5
	    		cells[i].pixel = i;
	    		cells[i].red = CMR(ifp)[i];
	    		cells[i].green = CMG(ifp)[i];
	    		cells[i].blue = CMB(ifp)[i];
	    		cells[i].flags = DoRed | DoGreen | DoBlue;
d1830 1
a1830 1
    		XStoreColors(OGL(ifp)->dispp, OGL(ifp)->xcmap, cells, 256);
d1833 1
a1833 1
	/* unattach context for other threads to use */
d1990 1
d1997 4
a2000 1
	clp->xscrmax = clp->xscrmin + i - 1;
d2005 4
a2008 1
	clp->yscrmax = clp->yscrmin + i - 1;
d2042 1
d2098 1
a2098 1
	
d2117 1
a2117 1
#if 0
d2211 5
a2215 2
		glOrtho((GLdouble) clp->xscrmin, (GLdouble) (clp->xscrmax + 1), 
			(GLdouble) clp->yscrmin, (GLdouble) (clp->yscrmax + 1), 
d2217 1
d2406 7
a2412 1
		glRasterPos3i(clp->xpixmin,clp->ypixmin,0);
a2426 1

d2438 2
a2439 2
		if( clp->xscrmax >= OGL(ifp)->vp_width )  glRecti(
			ifp->if_width - 1,
d2445 1
a2445 1
		if( clp->yscrmax >= OGL(ifp)->vp_height )  glRecti(
d2447 1
a2447 1
			OGL(ifp)->vp_height - 1,
d2455 1
a2455 1
		glRasterPos3i(clp->xpixmin,one_y,0);
@


1.2
log
@exploring possible visuals
@
text
@d52 1
d54 1
d100 8
a107 1
extern inventory_t	*getinvent();
d117 6
a122 5
_LOCAL_ void	backbuffer_to_screen();
_LOCAL_ void	ogl_cminit();
_LOCAL_ void	reorder_cursor();
_LOCAL_ Pixmap  make_bitmap();
static int	is_linear_cmap();
d256 1
d574 1
a574 2
	if( (ifp->if_mode & MODE_7MASK) == MODE_7SWCMAP  &&
	    SGI(ifp)->mi_cmap_flag )  {
d713 1
a713 2
	int		mode;
	inventory_t	*inv;
a719 1
/*	Widget 		glw;*/
d723 4
d733 1
a733 1

d884 1
d889 1
d902 56
d965 3
d969 2
a970 2
		(XrmOptionDescList) NULL , 0,&fake_argc, (String *) NULL, fallback_resources, args, n);    

d976 2
a977 1
	n = 0;    
a999 13
	/* initialize window state variables before calling ogl_getmem */
	ifp->if_zoomflag = 0;
	ifp->if_xzoom = 1;	/* for zoom fakeout */
	ifp->if_yzoom = 1;	/* for zoom fakeout */
	ifp->if_xcenter = width/2;
	ifp->if_ycenter = height/2;
	SGI(ifp)->mi_pid = getpid();


	/* Attach to shared memory, potentially with a screen repaint */
	if( ogl_getmem(ifp) < 0 )
		return(-1);

d1005 1
d1007 1
d1044 1
d1052 1
a1052 2
	if( ((ifp->if_mode & MODE_7MASK) != MODE_7SWCMAP)  &&
	    SGI(ifp)->mi_cmap_flag )  {
d1068 1
a1068 1

d1093 1
d1784 1
a1784 1
	if( (ifp->if_mode & MODE_7MASK) == MODE_7SWCMAP )  {
d2064 1
a2064 1

d2069 2
d2090 1
d2105 1
d2127 8
a2134 1

d2137 1
a2137 1

d2153 2
d2428 111
d2540 1
d2542 2
@


1.1
log
@Initial revision
@
text
@d1994 1
d1996 1
d2006 18
d2030 1
a2030 1
		OGL(ifp)->xcmap = XCreateColormap(OGL(ifp)->dispp, OGL(ifp)->wind,
@
