head	11.7;
access;
symbols
	ansi-20040405-merged:11.4.2.1
	postmerge-20040405-ansi:11.5
	premerge-20040404-ansi:11.4
	postmerge-autoconf:11.4
	autoconf-freeze:11.4
	premerge-autoconf:11.4
	ansi-20040316-freeze:11.4.2.1
	postmerge-20040315-windows:11.4
	premerge-20040315-windows:11.4
	windows-20040315-freeze:11.4
	autoconf-20031203:11.4
	autoconf-20031202:11.4
	autoconf-branch:11.4.0.10
	phong-branch:11.4.0.8
	photonmap-branch:11.4.0.6
	rel-6-1-DP:11.4
	windows-branch:11.4.0.4
	rel-6-0-2:11.2
	ansi-branch:11.4.0.2
	rel-6-0-1-branch:11.2.0.4
	hartley-6-0-post:11.3
	hartley-6-0-pre:11.2
	rel-6-0-1:11.2
	rel-6-0:11.2
	rel-5-4:11.2
	offsite-5-3-pre:11.2
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1;
locks; strict;
comment	@ * @;


11.7
date	2004.05.21.18.07.25;	author morrison;	state dead;
branches;
next	11.6;

11.6
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	11.5;

11.5
date	2004.04.05.07.44.42;	author morrison;	state Exp;
branches;
next	11.4;

11.4
date	2002.08.20.17.07.47;	author jra;	state Exp;
branches
	11.4.2.1;
next	11.3;

11.3
date	2002.08.15.20.55.01;	author hartley;	state Exp;
branches;
next	11.2;

11.2
date	98.06.27.04.29.16;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.52.57;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.12.20.25.31;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.37.27;	author mike;	state Rel4_0;
branches;
next	9.4;

9.4
date	91.07.26.22.41.08;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.12.11.22.34.16;	author phil;	state Exp;
branches;
next	9.2;

9.2
date	89.09.01.01.45.07;	author phil;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.47.59;	author mike;	state Rel3_5;
branches;
next	8.2;

8.2
date	89.03.03.05.54.34;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.27.38;	author mike;	state Rel3_0;
branches;
next	7.2;

7.2
date	88.09.09.23.23.50;	author phil;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.26.40;	author mike;	state Rel;
branches;
next	1.2;

1.2
date	87.10.28.21.17.33;	author phil;	state Exp;
branches;
next	1.1;

1.1
date	87.10.28.20.59.48;	author mike;	state Exp;
branches;
next	;

11.4.2.1
date	2002.09.19.18.01.19;	author morrison;	state Exp;
branches;
next	;


desc
@Raster Technology One/80 framebuffer with 24-bit RGB memory
@


11.7
log
@moved to src/
@
text
@/*
 *                     I F _ R A T . C
 *
 *  FrameBuffer library interface for Raster Technology One/80 with
 *  24-bit RGB memory.
 *
 *  Authors -
 *	Brant A. Ross
 *
 *  Source -
 * 	General Motors Military Vehicles Operation
 *      P.O. Box 420  Mail Code O01
 *	Indianapolis, IN  46206-0420
 *
 *  BRL NOTE: We have not been able to test this interface in a long
 *   time.  LIBFB has changed several times since then so this code
 *   may not even compile any longer.  If you make changes to this
 *   please let us know. <phil@@brl.mil>
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libfb/if_rat.c,v 11.6 2004/05/10 15:30:45 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <fcntl.h>

#include "machine.h"
#include "fb.h"
#include "./fblocal.h"

/* typedef unsigned char	u_char;	*/
int	_fbfd;
int	_fbsize = 512;
#define Max( a, b )	((a) < (b) ? (b) : (a))
#define Min( a, b )	((a) > (b) ? (b) : (a))

#define Rat_Cvt( x, y )	x -= _fbsize/2, y -= _fbsize/2
#define Rat_Write( cmd, buff ) \
	{	register int	ct, i; \
	if( write( _fbfd, buff, sizeof(buff) ) == -1 ) \
		{ \
		(void) fprintf( stderr, "%s : write failed!\n", cmd ); \
		return	0; \
		} \
	}
#define Round_N( a, n )	{ register int f = a%n; a = f<10 ? a-f : a+(n-f); }
#define PAD		0xA
#define	MAX_RAT_BUFF	(12*1024L)
#define	MAX_RAT_READ	1024
int		rat_debug = 0;
static int	zoom_factor = 1;

static int	cload(int creg, int x, int y),
		debug(int flag), entergraphics(void), flood(void), lutrmp(int code, int sind, int eind, int sval, int eval), lut8(int index, u_char r, u_char g, u_char b),
		memsel(int unit), movabs(register int x, register int y), pixels(int rows, int cols, register u_char *pix_buf, int bytes, FBIO *ifp), quit(void),
		rdmask(int bitm), rdmode(int flag), rdpixr(int vreg), readf(int func), readw(int rows, int cols, int bf), readvr(int vreg),
		rgbtru(int flag), scrorg(int x, int y), value(u_char red, u_char green, u_char blue), vidform(int mode, int flag),
		warm(void), wrmask(int bitm, int bankm), xhair(int num, int flag), zoom(int factor);

_LOCAL_ int	rat_open(FBIO *ifp, char *file, int width, int height),
		rat_close(FBIO *ifp),
		rat_clear(FBIO *ifp, RGBpixel (*pp)),
		rat_read(FBIO *ifp, int x, int y, RGBpixel (*pixelp), int count),
		rat_write(FBIO *ifp, int x, int y, RGBpixel (*pixelp), int count),
		rat_rmap(FBIO *ifp, ColorMap *cmp),
		rat_wmap(FBIO *ifp, ColorMap *cmp),
		rat_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
		rat_window_set(FBIO *ifp, int x, int y),	/* OLD */
		rat_zoom_set(FBIO *ifp, int x, int y),		/* OLD */
		rat_setcursor(FBIO *ifp, unsigned char *bits, int xbits, int ybits, int xorig, int yorig),
		rat_cursor(FBIO *ifp, int mode, int x, int y),
		rat_getcursor(),
		rat_help(FBIO *ifp);

/* This is the ONLY thing that we normally "export" */
FBIO rat_interface =  {
	0,
	rat_open,			/* device_open		*/
	rat_close,			/* device_close		*/
	rat_clear,			/* device_clear		*/
	rat_read,			/* buffer_read		*/
	rat_write,			/* buffer_write		*/
	rat_rmap,			/* colormap_read	*/
	rat_wmap,			/* colormap_write	*/
	rat_view,			/* set view		*/
	fb_sim_getview,			/* get view		*/
	rat_setcursor,			/* define cursor	*/
	rat_cursor,			/* set cursor		*/
	fb_sim_getcursor,		/* get cursor		*/
	fb_sim_readrect,		/* read rectangle	*/
	fb_sim_writerect,		/* write rectangle	*/
	fb_sim_bwreadrect,
	fb_sim_bwwriterect,
	fb_null,			/* handle events	*/
	fb_null,			/* flush output		*/
	rat_close,			/* free resources	*/
	rat_help,			/* help function	*/
	"Raster Technology One/80",	/* device description	*/
	1024,				/* max width		*/
	1024,				/* max height		*/
	"/dev/rt",			/* short device name	*/
	512,				/* default/current width  */
	512,				/* default/current height */
	-1,				/* select fd		*/
	-1,				/* file descriptor	*/
	1, 1,				/* zoom			*/
	256, 256,			/* window center	*/
	0, 0, 0,			/* cursor		*/
	PIXEL_NULL,			/* page_base		*/
	PIXEL_NULL,			/* page_curp		*/
	PIXEL_NULL,			/* page_endp		*/
	-1,				/* page_no		*/
	0,				/* page_dirty		*/
	0L,				/* page_curpos		*/
	0L,				/* page_pixels		*/
	0				/* debug		*/
};

_LOCAL_ int
rat_open(FBIO *ifp, char *file, int width, int height)
{
	FB_CK_FBIO(ifp);
	if( (ifp->if_fd = open( file, O_RDWR, 0 )) == -1)
		{
		perror(file);
		return -1;  }
	_fbfd = ifp->if_fd;
	_fbsize = width;
	if( width == 1024)
		{ ifp->if_width = width;
		  ifp->if_height = height; }
	_rat_init(ifp);
	return ifp->if_fd;
}

_LOCAL_ int
rat_close(FBIO *ifp)
    	     
/*	_ r a t _ c l o s e ( )
	Issue quit command, and close connection.
 */
{
	if(  !	quit()
	    ||	close( ifp->if_fd ) == -1
		)
		{
		(void) fprintf( stderr, "_rat_close() close failed!\n" );
		return	-1;
		}
	return	0;
}


_LOCAL_ int
rat_clear(FBIO *ifp, RGBpixel (*pp))
    	     
        	    
/*	_ r a t _ c l e a r ( )
	Clear the Raster Tech. to the background color.
 */
{
	if(	pp != NULL
	    &&	value(	(*pp)[RED],(*pp)[GRN],(*pp)[BLU] )
	    &&	flood()  )
		return	0;
	else
	    if ( !(value( 0, 0, 0 ) && flood() ) )
		return	1;
	return	0;
}

_LOCAL_ int
rat_read(FBIO *ifp, int x, int y, RGBpixel (*pixelp), int count)
    	     
   	     
        	        
   	      
/*	_ r a t _ r e a d ( )
 */
{
	register int	nrows;
	register int	bytes;
	register int	load;
	register u_char	*p;
	static u_char	pix_buf[MAX_RAT_BUFF];

	/* If first scanline is a partial, input it seperately.		*/
	if( x > 0 || x + count <= _fbsize )
		{	register int	i;
		if( ! movabs( x, y ) )
			return	-1;
		y++;
		if( x + count <= _fbsize )
			i = count;	/* Only 1 scanline is involved.	*/
		else
			i = _fbsize - x; /* First scan is a partial.	*/
		if( ! readw( 1, i, 1 ) )
			return	-1;
		for(	bytes = i * 3, p = pix_buf;
			bytes > 0;
			bytes -= load, p += load
			)
			{
			if( bytes > MAX_RAT_READ )
				load = MAX_RAT_READ;
			else
				load = bytes;		
			if( read( ifp->if_fd, p, load ) < load )
				{
				(void) fprintf( stderr,
						"_rat_read() read failed\n"
						);
				return	-1;
				}
			}
		for( p = pix_buf; i > 0; i--, pixelp++, count-- )
			{
			(*pixelp)[RED] = *p++;
			(*pixelp)[GRN] = *p++;
			(*pixelp)[BLU] = *p++;
			}
		}
	/* Do all full scanlines.					*/
	while( (nrows = count / _fbsize) != 0 )
		{	register int	i;
		if( ! movabs( 0, y ) )
			return	-1;
		if( nrows * _fbsize * 3 > MAX_RAT_BUFF )
			nrows = MAX_RAT_BUFF / (_fbsize * 3);
		i = nrows * _fbsize;
		y += nrows;
		if( ! readw( nrows, _fbsize, 1 ) )
			return	-1;
		for(	bytes = i * 3, p = pix_buf;
			bytes > 0;
			bytes -= load, p += load
			)
			{
			if( bytes > MAX_RAT_READ )
				load = MAX_RAT_READ;
			else
				load = bytes;		
			{ register int	ii;
			for( ii = 0; ii < load; ii++ )
				p[ii] = 100;
			}
			if( read( ifp->if_fd, p, load ) < load )
				{
				(void) fprintf( stderr,
						"_rat_read() read failed\n"
						);
				return	-1;
				}
			}
		for(	p = pix_buf;
			i > 0;
			i--, pixelp++, count--
			)
			{
			(*pixelp)[RED] = *p++;
			(*pixelp)[GRN] = *p++;
			(*pixelp)[BLU] = *p++;
			}
		}
	if( count > 0 )
		{ /* Do partial scanline.				*/
			register int	i;
			register u_char	*p = pix_buf;

		/*(void) fprintf( stderr, "doing partial scan at end\n" );*/
		if(   !	movabs( 0, y )
		   || ! readw( 1, count, 1 )
			)
			return	-1;
		for(	bytes = count * 3, p = pix_buf;
			bytes > 0;
			bytes -= load, p += load
			)
			{
			if( bytes > MAX_RAT_READ )
				load = MAX_RAT_READ;
			else
				load = bytes;		
			if( read( ifp->if_fd, p, load ) < load )
				{
				(void) fprintf( stderr,
						"_rat_read() read failed\n"
						);
				return	-1;
				}
			}
		for( p = pix_buf; count > 0; pixelp++, count-- )
			{
			(*pixelp)[RED] = *p++;
			(*pixelp)[GRN] = *p++;
			(*pixelp)[BLU] = *p++;
			}
		}
	return	0;
}

_LOCAL_ int
rat_write(FBIO *ifp, int x, int y, RGBpixel (*pixelp), int count)
    	     
   	     
        	        
   	      
/*	_ r a t _ w r i t e ( )
 */
{
	register int	nrows;
	int		ncols;
	static u_char	pix_buf[MAX_RAT_BUFF+1];

	/* If first scanline is a partial, output it separately.	*/
	if( x > 0 || x + count <= _fbsize )
		{	register int	bytes, i;
			register u_char	*p = pix_buf;
		if( ! movabs( x, y ) )
			return	-1;
		if( x + count <= _fbsize )
			ncols = i = count;  /* Only 1 scanline is involved.  */
		else			/* First scan is a partial.	*/
			ncols = i = _fbsize - x;
		y++;
		for( bytes = 0; i > 0; i--, pixelp++, bytes += 3, count-- )
			{
			*p++ = (*pixelp)[RED];
			*p++ = (*pixelp)[GRN];
			*p++ = (*pixelp)[BLU];
			}
		if( ! pixels( 1, ncols, pix_buf, bytes, ifp ) )
			return	-1;
		}
	/* Do all full scanlines.					*/
	while( (nrows = count / _fbsize) != 0 )
		{	register int	bytes, i, j;
			register u_char	*p = pix_buf,*p1;
		if( nrows * _fbsize * 3 > MAX_RAT_BUFF )
			nrows = MAX_RAT_BUFF / (_fbsize * 3);
		y += nrows;
		if( ! movabs( 0, y-1 ) )
			return	-1;
		for(	j = nrows , bytes = 0; j > 0; j-- )
		    {
		   p1 = p + ( (j-1)*_fbsize*3 );
		   for(	i = _fbsize; i > 0;
			i--, pixelp++, bytes += 3, count-- )
			{
			*p1++ = (*pixelp)[RED];
			*p1++ = (*pixelp)[GRN];
			*p1++ = (*pixelp)[BLU];
			}
		    }
		if( ! pixels( nrows, _fbsize, pix_buf, bytes, ifp ) )
			return	-1;
		}
	/* If partial scanline remains, finish up.			*/
	if( count > 0 )
		{	register int	bytes, i;
			register u_char	*p = pix_buf;
		if( ! movabs( 0, y ) )
			return	-1;
		ncols = count;
		for( bytes = 0; count > 0; pixelp++, bytes += 3, count-- )
			{
			*p++ = (*pixelp)[RED];
			*p++ = (*pixelp)[GRN];
			*p++ = (*pixelp)[BLU];
			}
		if( ! pixels( 1, ncols, pix_buf, bytes, ifp ) )
			return	-1;
		}
	return	0;
}

_LOCAL_ int
rat_rmap(FBIO *ifp, ColorMap *cmp)
{
	return(0);
}

_LOCAL_ int
rat_wmap(FBIO *ifp, ColorMap *cmp)
    	     
        	     
/*	_ r a t _ w m a p ( )
	Load the color map into the frame buffer.
 */
{
	{
	register int	i;
	
	/* If cmp is NULL, write standard map.				*/
	if( cmp == (ColorMap *) NULL )
/*		if( ! lutrmp( 7, 0, 255, 0, 255 ) )       */
/*			return	-1;         */
/*		else                   */
			return	0;
	else
		{
/*		for( i = 0; i < 256; i++ )
			if( ! lut8(	i,
					cmp->cm_red[i], 
					cmp->cm_green[i],
					cmp->cm_blue[i]
					)
				)
				return	-1;
 */
		}
	return	0;
	}
}

_LOCAL_ int
rat_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
{
	rat_window_set(ifp, xcenter, ycenter);
	rat_zoom_set(ifp, xzoom, yzoom);
	fb_sim_view(ifp, xcenter, ycenter, xzoom, yzoom);
	return	0;
}

_LOCAL_ int
rat_window_set(FBIO *ifp, int x, int y)
    	     
   	     
/*	_ r a t _ w i n d o w ( )
	This routine takes advantage of the fact that there is only 1
	scaling parameter available (equal scaling in x and y).
 */
{
	Rat_Cvt( x, y );
	Round_N( x, 20 );
	return	scrorg( x, y ) ? 0 : -1;
}

_LOCAL_ int
rat_zoom_set(FBIO *ifp, int x, int y)
    	     
   	     
/*	_ r a t _ z o o m ( )
	 The Raster Tech does not scale independently in x and y.
		Also addressing is the same in low and high res. so
		must zoom twice for low res.
 */
{
	zoom_factor = Max( x, y );
	zoom_factor = Min( zoom_factor, 16 );
	zoom_factor = Max( zoom_factor, 1 );
	return	zoom(	ifp->if_width == 512 && zoom_factor < 16 ?
			zoom_factor * 2 :
			zoom_factor
			) ? 0 : -1;
}

_LOCAL_ int
rat_setcursor(FBIO *ifp, unsigned char *bits, int xbits, int ybits, int xorig, int yorig)
{
	return	0;
}

_LOCAL_ int
rat_cursor(FBIO *ifp, int mode, int x, int y)
/*	Place cursor at image (pixel) coordinates x & y
 */
    	     
   	     
   	     
{
	fb_sim_cursor(ifp, mode, x, y);
/*	if(   !	cload( 5, x, y )  ||  ! xhair( 0, mode ) )
		return	-1;	*/
	if(   !	cload(17, x, y )  ||  ! cursor( 0, mode ) )
		return	-1;
	return	0;
}

/*	_ r a t _ i n i t ( )
	Reset, enter graphics mode, set interlace on, turn on 24 bit color.
	Set origin and zoom factor.
 */
_rat_init(FBIO *ifp)
{
	static unsigned char firstcmds[] = {0x10,0x01,0xFD,0x00};

	static unsigned char buff[] =
		{0x01,0x00,		/* Enter graphics	*/
		0x48,0x00,		/* MEMSEL 0		*/
		0x9D,0xFF,0x07,0x00};	/* WRMASK 255 7		*/

	if( warm()
	    &&	entergraphics()
/*	    &&	vidform( 0, 1 )   only if interlace needed  */
/*	    &&	memsel( 0 )		*/
/*	    &&	rgbtru( 1 )		*/
	    &&	wrmask( 255, 7 )	/* enable all bits & channels.	*/
	    &&	rdmask( 255 )		/* enable for reading.		*/
	    &&	readf( 0 )
	    &&	rdmode( 1 )
	    &&	rat_zoom_set( ifp, 1, 1 ) == 0
	    &&	scrorg( 0, 0 )
		)
		return	0;
	else
		return	-1;
	}






static int
cload(int creg, int x, int y)
{
	u_char	buff[8];

	Rat_Cvt( x, y );
	buff[0] = 0xA0;
	buff[1] = creg;
	buff[2] = (x>>8)&0x0FF;		/* high_x, low_x.	*/
	buff[3] = x&0x0FF;
	buff[4] = (y>>8)&0x0FF;		/* high_y, low_y.	*/
	buff[5] = y&0x0FF;
	buff[6] = PAD;
	buff[7] = PAD;
	Rat_Write( "cload", buff );
	return	1;
	}

static int
debug(int flag)
{
	u_char	buff[2];

	buff[0] = 0xA8;
	buff[1] = flag;
	Rat_Write( "debug", buff );
	return	1;
	}

static int
entergraphics(void)
{
	u_char	buff[2];

	buff[0] = 0x01;
	buff[1] = PAD;

	Rat_Write( "entergraphics", buff );
	return	1;
	}

static int
flood(void)
{
	u_char	buff[2];

	buff[0] = 0x07;
	buff[1] = PAD;
	Rat_Write( "flood", buff );
	return	1;
	}

static int
lutrmp(int code, int sind, int eind, int sval, int eval)
{
	u_char	buff[6];

	buff[0] = 0x01d;
	buff[1] = code;
	buff[2] = sind;
	buff[3] = eind;
	buff[4] = sval;
	buff[5] = eval;
/*	Rat_Write( "lutrmp", buff );   */
	return	1;
	}

static int
lut8(int index, u_char r, u_char g, u_char b)
{
	u_char	buff[6];

	buff[0] = 0x01c;
	buff[1] = index;
	buff[2] = r;
	buff[3] = g;
	buff[4] = b;
	buff[5] = PAD;
/*	Rat_Write( "lut8", buff );   */
	return	1;
	}

/*	m e m s e l ( )
	Select a memory unit.
	Since the RLE format splits up the colors running in RGBTRU OFF
	and selecting the unit for each color is the easiest way to go.
 */
static int
memsel(int unit)
{
	u_char	buff[2];

	buff[0] = 0x48;
	buff[1] = unit;
/*	Rat_Write( "memsel", buff );    */
	return	1;
	}

/*	m o v a b s ( )
	Set the current position (CREG 0) to (x, y).
	The generic device has its origin in the upper left corner (modeled
	after the Ikonas or a UNIX file)...


	(0,      0)........................(ifp->if_width,         0)
	.							   .
	.							   .
	.							   .
	.							   .
	.							   .
	.                                          		   .
	(0, ifp->if_width).................(ifp->if_width, ifp->if_width)


	The Raster Tech. is a 4-quadrant cartesian device, so its origin is at
	screen center...


	(-_fbsize/2, _fbsize/2)......(_fbsize/2, _fbsize/2)
	.                                                 .
	.                                                 .
	.                                                 .
	.                      (0, 0)                     .
	.                                                 .
	.                                                 .
	.                                                 .
	(-_fbsize/2, -_fbsize/2).....(_fbsize/2, -_fbsize/2)
 */
static int
movabs(register int x, register int y)
{
	u_char	buff[8];
	
	Rat_Cvt( x, y );
	buff[0] = 0x1;
	buff[1] = (x>>8)&0x0FF;		/* high_x, low_x.	*/
	buff[2] = x&0x0FF;
	buff[3] = (y>>8)&0x0FF;		/* high_y, low_y.	*/
	buff[4] = y&0x0FF;
	buff[5] = PAD;
	buff[6] = PAD;
	buff[7] = PAD;
	Rat_Write( "movabs", buff );
	return	1;
	}

static int
pixels(int rows, int cols, register u_char *pix_buf, int bytes, FBIO *ifp)
{
	static u_char	buff[MAX_RAT_BUFF+6];
	register int	i, ct;

	if( rat_debug == 1 )
		debug( 0 );
	ct = bytes & 1 ? 5 + bytes : 6 + bytes; /* Insure even count.	*/
	buff[0] = 0x28;
	buff[1] = rows>>8 & 0xFF;
	buff[2] = rows & 0xFF;
	buff[3] = cols>>8 & 0xFF;
	buff[4] = cols & 0xFF;
	for( i = 5; i < ct; i++ )
		buff[i] = *pix_buf++;
	if( ! (bytes & 1) )
		buff[ct-1] = PAD;
	if( write( ifp->if_fd, buff, ct ) == -1 )
		{
		(void) fprintf( stderr, "pixels : write failed!\n" );
		return	0;
		}
	if( rat_debug == 1 )
		debug( rat_debug );
	return	1;
	}

static int
quit(void)
{
	u_char	buff[2];

	buff[0] = 0xFF;
	buff[1] = PAD;
	Rat_Write( "quit", buff );
	return	1;
	}

/*	r d m a s k ( )
	Set read mask.
 */
static int
rdmask(int bitm)
{
	u_char	buff[2];

	buff[0] = 0x9E;
	buff[1] = bitm;
	Rat_Write( "rdmask", buff );
	return	1;
	}

/*	r d m o d e ( )
 */
static int
rdmode(int flag)
{
	u_char	buff[2];

	buff[0] = 0xD3;
	buff[1] = flag;
	Rat_Write( "rdmode", buff );
	return	1;
	}

static int
rdpixr(int vreg)
{
	u_char	buff[2];

	buff[0] = 0xAF;
	buff[1] = vreg;
	Rat_Write( "rdpixr", buff );
	return	1;
	}

static int
readf(int func)
{
	u_char	buff[2];

	buff[0] = 0x27;
	buff[1] = func;
	Rat_Write( "readf", buff );
	return	1;
	}
	
static int
readvr(int vreg)
{
	u_char	buff[2];

	buff[0] = 0x99;
	buff[1] = vreg;
	Rat_Write( "readvr", buff );
	return	1;
	}

static int
readw(int rows, int cols, int bf)
{
	u_char	buff[6];

	buff[0] = 0x96;
	buff[1] = rows>>8 & 0xFF;
	buff[2] = rows & 0xFF;
	buff[3] = cols>>8 & 0xFF;
	buff[4] = cols & 0xFF;
	buff[5] = bf;
	Rat_Write( "readw", buff );
	return	1;
	}

static int
rgbtru(int flag)
{
	u_char	buff[2];

	buff[0] = 0x4e;
	buff[1] = flag;
	Rat_Write( "rgbtru", buff );
	return	1;
	}


/*	s c r o r g ( )
	Set the screen-center coordinate (CREG 4) to (x, y).
 */
static int
scrorg(int x, int y)
{
	u_char	buff[6];

	buff[0] = 0x36;
	buff[1] = (x>>8) & 0x0FF;		/* high_x, low_x.	*/
	buff[2] = x & 0x0FF;
	buff[3] = (y>>8) & 0x0FF;		/* high_y, low_y.	*/
	buff[4] = y & 0x0FF;
	buff[5] = PAD;
	Rat_Write( "scrorg", buff );
	return	1;
	}

static int
value(u_char red, u_char green, u_char blue)
{
	char	buff[4];

	buff[0] = 0x06;
	buff[1] = red;
	buff[2] = green;
	buff[3] = blue;
	Rat_Write( "value", buff );
	return	1;
	}

static int
vidform(int mode, int flag)
{
	u_char	buff[4];

	buff[0] = 0x08;
	buff[1] = mode;
	buff[2] = flag;
	buff[3] = PAD;
	Rat_Write( "vidform", buff );
	return	1;
	}

static int
warm(void)
{
	u_char	buff[2];

	buff[0] = 0x10;
	buff[1] = PAD;
	Rat_Write( "warm", buff );
	return	1;
	}

/*	w r m a s k ( )
	Set write mask.
 */
static int
wrmask(int bitm, int bankm)
{
	u_char	buff[4];

	buff[0] = 0x9D;
	buff[1] = bitm;
	buff[2] = bankm;
	buff[3] = PAD;
	Rat_Write( "wrmask", buff );
	return	1;
	}

static int
cursor(int num, int flag)
{
	u_char	buff[4];

	buff[0] = 0x4A;
	buff[1] = num;
	buff[2] = flag;
	buff[3] = PAD;
	Rat_Write( "cursor", buff );
	return	1;
	}


static int
xhair(int num, int flag)
{
	u_char	buff[4];

	buff[0] = 0x9C;
	buff[1] = num;
	buff[2] = flag;
	buff[3] = PAD;
	Rat_Write( "xhair", buff );
	return	1;
	}

static int
zoom(int factor)
{
	u_char	buff[2];

	buff[0] = 0x34;
	buff[1] = factor;
	Rat_Write( "zoom", buff );
	return	1;
	}

_LOCAL_ int
rat_help(FBIO *ifp)
{
	fb_log( "Description: %s\n", rat_interface.if_type );
	fb_log( "Device: %s\n", ifp->if_name );
	fb_log( "Max width/height: %d %d\n",
		rat_interface.if_max_width,
		rat_interface.if_max_height );
	fb_log( "Default width/height: %d %d\n",
		rat_interface.if_width,
		rat_interface.if_height );
	return(0);
}
@


11.6
log
@change conf.h to a wrapped config.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/libfb/if_rat.c,v 11.5 2004/04/05 07:44:42 morrison Exp $ (BRL)";
@


11.5
log
@merge of ansi-6-0-branch into HEAD
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d24 5
a28 1
#include "conf.h"
@


11.4
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_rat.c,v 11.2 1998/06/27 04:29:16 mike Exp $ (BRL)";
d55 19
a73 19
static int	cload(),
		debug(), entergraphics(), flood(), lutrmp(), lut8(),
		memsel(), movabs(), pixels(), quit(),
		rdmask(), rdmode(), rdpixr(), readf(), readw(), readvr(),
		rgbtru(), scrorg(), value(), vidform(),
		warm(), wrmask(), xhair(), zoom();

_LOCAL_ int	rat_open(),
		rat_close(),
		rat_clear(),
		rat_read(),
		rat_write(),
		rat_rmap(),
		rat_wmap(),
		rat_view(),
		rat_window_set(),	/* OLD */
		rat_zoom_set(),		/* OLD */
		rat_setcursor(),
		rat_cursor(),
d75 1
a75 1
		rat_help();
d122 1
a122 4
rat_open( ifp, file, width, height )
FBIO	*ifp;
char	*file;
int	width, height;
d139 2
a140 2
rat_close( ifp )
FBIO	*ifp;
d157 3
a159 3
rat_clear( ifp, pp )
FBIO	*ifp;
RGBpixel	*pp;
d175 5
a179 5
rat_read( ifp, x, y, pixelp, count )
FBIO	*ifp;
int	x, y;
RGBpixel	*pixelp;
int	count;
d305 5
a309 5
rat_write( ifp, x, y, pixelp, count )
FBIO	*ifp;
int	x, y;
RGBpixel	*pixelp;
int	count;
d380 1
a380 3
rat_rmap( ifp, cmp )
FBIO	*ifp;
ColorMap	*cmp;
d386 3
a388 3
rat_wmap( ifp, cmp )
FBIO	*ifp;
ColorMap	*cmp;
d419 1
a419 4
rat_view( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	xcenter, ycenter;
int	xzoom, yzoom;
d428 3
a430 3
rat_window_set( ifp, x, y )
FBIO	*ifp;
int	x, y;
d442 3
a444 3
rat_zoom_set( ifp, x, y )
FBIO	*ifp;
int	x, y;
d461 1
a461 5
rat_setcursor( ifp, bits, xbits, ybits, xorig, yorig )
FBIO	*ifp;
unsigned char *bits;
int	xbits, ybits;
int	xorig, yorig;
d467 1
a467 1
rat_cursor( ifp, mode, x, y )
d470 3
a472 3
FBIO	*ifp;
int	mode;
int	x, y;
d486 2
a487 3
_rat_init(ifp)
FBIO	*ifp;
	{
d518 2
a519 3
cload( creg, x, y )
int	creg, x, y;
	{
d536 2
a537 3
debug( flag )
int	flag;
	{
d547 2
a548 2
entergraphics()
	{
d559 2
a560 2
flood()
	{
d570 2
a571 3
lutrmp( code, sind, eind, sval, eval )
int	code, sind, eind, sval, eval;
	{
d585 2
a586 4
lut8( index, r, g, b )
int	index;
u_char	r, g, b;
	{
d605 2
a606 3
memsel( unit )
int	unit;
	{
d646 2
a647 3
movabs( x, y )
register int	x, y;
	{
d664 2
a665 6
pixels( rows, cols, pix_buf, bytes, ifp )
int		rows, cols;
register u_char	*pix_buf;
int		bytes;
FBIO	*ifp;
	{
d692 2
a693 2
quit()
	{
d706 2
a707 3
rdmask( bitm )
int	bitm;
	{
d719 2
a720 3
rdmode( flag )
int	flag;
	{
d730 2
a731 3
rdpixr( vreg )
int	vreg;
	{
d741 2
a742 3
readf( func )
int	func;
	{
d752 2
a753 3
readvr( vreg )
int	vreg;
	{
d763 2
a764 3
readw( rows, cols, bf )
int	rows, cols, bf;
	{
d778 2
a779 3
rgbtru( flag )
int	flag;
	{
d793 2
a794 3
scrorg( x, y )
int	x, y;
	{
d808 2
a809 3
value( red, green, blue )
u_char	red, green, blue;
	{
d821 2
a822 3
vidform( mode, flag )
int	mode, flag;
	{
d834 2
a835 2
warm()
	{
d848 2
a849 3
wrmask( bitm, bankm )
int	bitm, bankm;
	{
d861 2
a862 3
cursor( num, flag )
int	num, flag;
	{
d875 2
a876 3
xhair( num, flag )
int	num, flag;
	{
d888 2
a889 3
zoom( factor )
int	factor;
	{
d899 1
a899 2
rat_help( ifp )
FBIO	*ifp;
@


11.4.2.1
log
@Initial ANSIfication
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_rat.c,v 11.4 2002/08/20 17:07:47 jra Exp $ (BRL)";
d55 19
a73 19
static int	cload(int creg, int x, int y),
		debug(int flag), entergraphics(void), flood(void), lutrmp(int code, int sind, int eind, int sval, int eval), lut8(int index, u_char r, u_char g, u_char b),
		memsel(int unit), movabs(register int x, register int y), pixels(int rows, int cols, register u_char *pix_buf, int bytes, FBIO *ifp), quit(void),
		rdmask(int bitm), rdmode(int flag), rdpixr(int vreg), readf(int func), readw(int rows, int cols, int bf), readvr(int vreg),
		rgbtru(int flag), scrorg(int x, int y), value(u_char red, u_char green, u_char blue), vidform(int mode, int flag),
		warm(void), wrmask(int bitm, int bankm), xhair(int num, int flag), zoom(int factor);

_LOCAL_ int	rat_open(FBIO *ifp, char *file, int width, int height),
		rat_close(FBIO *ifp),
		rat_clear(FBIO *ifp, RGBpixel (*pp)),
		rat_read(FBIO *ifp, int x, int y, RGBpixel (*pixelp), int count),
		rat_write(FBIO *ifp, int x, int y, RGBpixel (*pixelp), int count),
		rat_rmap(FBIO *ifp, ColorMap *cmp),
		rat_wmap(FBIO *ifp, ColorMap *cmp),
		rat_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
		rat_window_set(FBIO *ifp, int x, int y),	/* OLD */
		rat_zoom_set(FBIO *ifp, int x, int y),		/* OLD */
		rat_setcursor(FBIO *ifp, unsigned char *bits, int xbits, int ybits, int xorig, int yorig),
		rat_cursor(FBIO *ifp, int mode, int x, int y),
d75 1
a75 1
		rat_help(FBIO *ifp);
d122 4
a125 1
rat_open(FBIO *ifp, char *file, int width, int height)
d142 2
a143 2
rat_close(FBIO *ifp)
    	     
d160 3
a162 3
rat_clear(FBIO *ifp, RGBpixel (*pp))
    	     
        	    
d178 5
a182 5
rat_read(FBIO *ifp, int x, int y, RGBpixel (*pixelp), int count)
    	     
   	     
        	        
   	      
d308 5
a312 5
rat_write(FBIO *ifp, int x, int y, RGBpixel (*pixelp), int count)
    	     
   	     
        	        
   	      
d383 3
a385 1
rat_rmap(FBIO *ifp, ColorMap *cmp)
d391 3
a393 3
rat_wmap(FBIO *ifp, ColorMap *cmp)
    	     
        	     
d424 4
a427 1
rat_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
d436 3
a438 3
rat_window_set(FBIO *ifp, int x, int y)
    	     
   	     
d450 3
a452 3
rat_zoom_set(FBIO *ifp, int x, int y)
    	     
   	     
d469 5
a473 1
rat_setcursor(FBIO *ifp, unsigned char *bits, int xbits, int ybits, int xorig, int yorig)
d479 1
a479 1
rat_cursor(FBIO *ifp, int mode, int x, int y)
d482 3
a484 3
    	     
   	     
   	     
d498 3
a500 2
_rat_init(FBIO *ifp)
{
d531 3
a533 2
cload(int creg, int x, int y)
{
d550 3
a552 2
debug(int flag)
{
d562 2
a563 2
entergraphics(void)
{
d574 2
a575 2
flood(void)
{
d585 3
a587 2
lutrmp(int code, int sind, int eind, int sval, int eval)
{
d601 4
a604 2
lut8(int index, u_char r, u_char g, u_char b)
{
d623 3
a625 2
memsel(int unit)
{
d665 3
a667 2
movabs(register int x, register int y)
{
d684 6
a689 2
pixels(int rows, int cols, register u_char *pix_buf, int bytes, FBIO *ifp)
{
d716 2
a717 2
quit(void)
{
d730 3
a732 2
rdmask(int bitm)
{
d744 3
a746 2
rdmode(int flag)
{
d756 3
a758 2
rdpixr(int vreg)
{
d768 3
a770 2
readf(int func)
{
d780 3
a782 2
readvr(int vreg)
{
d792 3
a794 2
readw(int rows, int cols, int bf)
{
d808 3
a810 2
rgbtru(int flag)
{
d824 3
a826 2
scrorg(int x, int y)
{
d840 3
a842 2
value(u_char red, u_char green, u_char blue)
{
d854 3
a856 2
vidform(int mode, int flag)
{
d868 2
a869 2
warm(void)
{
d882 3
a884 2
wrmask(int bitm, int bankm)
{
d896 3
a898 2
cursor(int num, int flag)
{
d911 3
a913 2
xhair(int num, int flag)
{
d925 3
a927 2
zoom(int factor)
{
d937 2
a938 1
rat_help(FBIO *ifp)
@


11.3
log
@Converted from K&R to ANSI C - RFH
@
text
@d55 19
a73 19
static int	cload(int creg, int x, int y),
		debug(int flag), entergraphics(void), flood(void), lutrmp(int code, int sind, int eind, int sval, int eval), lut8(int index, u_char r, u_char g, u_char b),
		memsel(int unit), movabs(register int x, register int y), pixels(int rows, int cols, register u_char *pix_buf, int bytes, FBIO *ifp), quit(void),
		rdmask(int bitm), rdmode(int flag), rdpixr(int vreg), readf(int func), readw(int rows, int cols, int bf), readvr(int vreg),
		rgbtru(int flag), scrorg(int x, int y), value(u_char red, u_char green, u_char blue), vidform(int mode, int flag),
		warm(void), wrmask(int bitm, int bankm), xhair(int num, int flag), zoom(int factor);

_LOCAL_ int	rat_open(FBIO *ifp, char *file, int width, int height),
		rat_close(FBIO *ifp),
		rat_clear(FBIO *ifp, RGBpixel (*pp)),
		rat_read(FBIO *ifp, int x, int y, RGBpixel (*pixelp), int count),
		rat_write(FBIO *ifp, int x, int y, RGBpixel (*pixelp), int count),
		rat_rmap(FBIO *ifp, ColorMap *cmp),
		rat_wmap(FBIO *ifp, ColorMap *cmp),
		rat_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
		rat_window_set(FBIO *ifp, int x, int y),	/* OLD */
		rat_zoom_set(FBIO *ifp, int x, int y),		/* OLD */
		rat_setcursor(FBIO *ifp, unsigned char *bits, int xbits, int ybits, int xorig, int yorig),
		rat_cursor(FBIO *ifp, int mode, int x, int y),
d75 1
a75 1
		rat_help(FBIO *ifp);
d122 4
a125 1
rat_open(FBIO *ifp, char *file, int width, int height)
d142 2
a143 2
rat_close(FBIO *ifp)
    	     
d160 3
a162 3
rat_clear(FBIO *ifp, RGBpixel (*pp))
    	     
        	    
d178 5
a182 5
rat_read(FBIO *ifp, int x, int y, RGBpixel (*pixelp), int count)
    	     
   	     
        	        
   	      
d308 5
a312 5
rat_write(FBIO *ifp, int x, int y, RGBpixel (*pixelp), int count)
    	     
   	     
        	        
   	      
d383 3
a385 1
rat_rmap(FBIO *ifp, ColorMap *cmp)
d391 3
a393 3
rat_wmap(FBIO *ifp, ColorMap *cmp)
    	     
        	     
d424 4
a427 1
rat_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
d436 3
a438 3
rat_window_set(FBIO *ifp, int x, int y)
    	     
   	     
d450 3
a452 3
rat_zoom_set(FBIO *ifp, int x, int y)
    	     
   	     
d469 5
a473 1
rat_setcursor(FBIO *ifp, unsigned char *bits, int xbits, int ybits, int xorig, int yorig)
d479 1
a479 1
rat_cursor(FBIO *ifp, int mode, int x, int y)
d482 3
a484 3
    	     
   	     
   	     
d498 3
a500 2
_rat_init(FBIO *ifp)
{
d531 3
a533 2
cload(int creg, int x, int y)
{
d550 3
a552 2
debug(int flag)
{
d562 2
a563 2
entergraphics(void)
{
d574 2
a575 2
flood(void)
{
d585 3
a587 2
lutrmp(int code, int sind, int eind, int sval, int eval)
{
d601 4
a604 2
lut8(int index, u_char r, u_char g, u_char b)
{
d623 3
a625 2
memsel(int unit)
{
d665 3
a667 2
movabs(register int x, register int y)
{
d684 6
a689 2
pixels(int rows, int cols, register u_char *pix_buf, int bytes, FBIO *ifp)
{
d716 2
a717 2
quit(void)
{
d730 3
a732 2
rdmask(int bitm)
{
d744 3
a746 2
rdmode(int flag)
{
d756 3
a758 2
rdpixr(int vreg)
{
d768 3
a770 2
readf(int func)
{
d780 3
a782 2
readvr(int vreg)
{
d792 3
a794 2
readw(int rows, int cols, int bf)
{
d808 3
a810 2
rgbtru(int flag)
{
d824 3
a826 2
scrorg(int x, int y)
{
d840 3
a842 2
value(u_char red, u_char green, u_char blue)
{
d854 3
a856 2
vidform(int mode, int flag)
{
d868 2
a869 2
warm(void)
{
d882 3
a884 2
wrmask(int bitm, int bankm)
{
d896 3
a898 2
cursor(int num, int flag)
{
d911 3
a913 2
xhair(int num, int flag)
{
d925 3
a927 2
zoom(int factor)
{
d937 2
a938 1
rat_help(FBIO *ifp)
@


11.2
log
@Additions to LIBFB interface and remote framebuffer protocol to
read and write monochrome rectangles.
Particularly important for sending thermal images at high speed.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_rat.c,v 11.1 1995/01/04 09:52:57 mike Rel4_4 $ (BRL)";
d55 19
a73 19
static int	cload(),
		debug(), entergraphics(), flood(), lutrmp(), lut8(),
		memsel(), movabs(), pixels(), quit(),
		rdmask(), rdmode(), rdpixr(), readf(), readw(), readvr(),
		rgbtru(), scrorg(), value(), vidform(),
		warm(), wrmask(), xhair(), zoom();

_LOCAL_ int	rat_open(),
		rat_close(),
		rat_clear(),
		rat_read(),
		rat_write(),
		rat_rmap(),
		rat_wmap(),
		rat_view(),
		rat_window_set(),	/* OLD */
		rat_zoom_set(),		/* OLD */
		rat_setcursor(),
		rat_cursor(),
d75 1
a75 1
		rat_help();
d122 1
a122 4
rat_open( ifp, file, width, height )
FBIO	*ifp;
char	*file;
int	width, height;
d139 2
a140 2
rat_close( ifp )
FBIO	*ifp;
d157 3
a159 3
rat_clear( ifp, pp )
FBIO	*ifp;
RGBpixel	*pp;
d175 5
a179 5
rat_read( ifp, x, y, pixelp, count )
FBIO	*ifp;
int	x, y;
RGBpixel	*pixelp;
int	count;
d305 5
a309 5
rat_write( ifp, x, y, pixelp, count )
FBIO	*ifp;
int	x, y;
RGBpixel	*pixelp;
int	count;
d380 1
a380 3
rat_rmap( ifp, cmp )
FBIO	*ifp;
ColorMap	*cmp;
d386 3
a388 3
rat_wmap( ifp, cmp )
FBIO	*ifp;
ColorMap	*cmp;
d419 1
a419 4
rat_view( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	xcenter, ycenter;
int	xzoom, yzoom;
d428 3
a430 3
rat_window_set( ifp, x, y )
FBIO	*ifp;
int	x, y;
d442 3
a444 3
rat_zoom_set( ifp, x, y )
FBIO	*ifp;
int	x, y;
d461 1
a461 5
rat_setcursor( ifp, bits, xbits, ybits, xorig, yorig )
FBIO	*ifp;
unsigned char *bits;
int	xbits, ybits;
int	xorig, yorig;
d467 1
a467 1
rat_cursor( ifp, mode, x, y )
d470 3
a472 3
FBIO	*ifp;
int	mode;
int	x, y;
d486 2
a487 3
_rat_init(ifp)
FBIO	*ifp;
	{
d518 2
a519 3
cload( creg, x, y )
int	creg, x, y;
	{
d536 2
a537 3
debug( flag )
int	flag;
	{
d547 2
a548 2
entergraphics()
	{
d559 2
a560 2
flood()
	{
d570 2
a571 3
lutrmp( code, sind, eind, sval, eval )
int	code, sind, eind, sval, eval;
	{
d585 2
a586 4
lut8( index, r, g, b )
int	index;
u_char	r, g, b;
	{
d605 2
a606 3
memsel( unit )
int	unit;
	{
d646 2
a647 3
movabs( x, y )
register int	x, y;
	{
d664 2
a665 6
pixels( rows, cols, pix_buf, bytes, ifp )
int		rows, cols;
register u_char	*pix_buf;
int		bytes;
FBIO	*ifp;
	{
d692 2
a693 2
quit()
	{
d706 2
a707 3
rdmask( bitm )
int	bitm;
	{
d719 2
a720 3
rdmode( flag )
int	flag;
	{
d730 2
a731 3
rdpixr( vreg )
int	vreg;
	{
d741 2
a742 3
readf( func )
int	func;
	{
d752 2
a753 3
readvr( vreg )
int	vreg;
	{
d763 2
a764 3
readw( rows, cols, bf )
int	rows, cols, bf;
	{
d778 2
a779 3
rgbtru( flag )
int	flag;
	{
d793 2
a794 3
scrorg( x, y )
int	x, y;
	{
d808 2
a809 3
value( red, green, blue )
u_char	red, green, blue;
	{
d821 2
a822 3
vidform( mode, flag )
int	mode, flag;
	{
d834 2
a835 2
warm()
	{
d848 2
a849 3
wrmask( bitm, bankm )
int	bitm, bankm;
	{
d861 2
a862 3
cursor( num, flag )
int	num, flag;
	{
d875 2
a876 3
xhair( num, flag )
int	num, flag;
	{
d888 2
a889 3
zoom( factor )
int	factor;
	{
d899 1
a899 2
rat_help( ifp )
FBIO	*ifp;
@


11.1
log
@Release_4.4
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_rat.c,v 10.2 94/08/12 20:25:31 gdurf Exp $ (BRL)";
d94 2
@


10.2
log
@Added includes
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_rat.c,v 10.1 1991/10/12 06:37:27 mike Rel4_0 gdurf $ (BRL)";
@


10.1
log
@Release_4.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_rat.c,v 9.4 91/07/26 22:41:08 mike Exp $ (BRL)";
d24 2
d28 2
a29 1
#include <sys/types.h>
@


9.4
log
@Added if_magic field, and FB_CK_FBIO() macro, to allow checking
FBIO pointers
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_rat.c,v 9.3 90/12/11 22:34:16 phil Exp $ (BRL)";
@


9.3
log
@if_ struct changes.  See fb.h.  Cosmetic cleanups.  Not tested.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_rat.c,v 9.2 89/09/01 01:45:07 phil Exp $ (BRL)";
d76 1
d122 1
@


9.2
log
@fb_flush and fb_free hooks.
@
text
@d15 4
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: if_rat.c,v 9.1 89/05/19 05:47:59 phil Locked $ (BRL)";
a29 2
extern int	fb_sim_readrect(), fb_sim_writerect();

d59 13
a71 13
_LOCAL_ int	rat_dopen(),
		rat_dclose(),
		rat_dclear(),
		rat_bread(),
		rat_bwrite(),
		rat_cmread(),
		rat_cmwrite(),
		rat_viewport_set(),
		rat_window_set(),
		rat_zoom_set(),
		rat_curs_set(),
		rat_cmemory_addr(),
		rat_cscreen_addr(),
d76 15
a90 16
	rat_dopen,			/* device_open		*/
	rat_dclose,			/* device_close		*/
	fb_null,			/* device_reset		*/
	rat_dclear,			/* device_clear		*/
	rat_bread,			/* buffer_read		*/
	rat_bwrite,			/* buffer_write		*/
	rat_cmread,			/* colormap_read	*/
	rat_cmwrite,			/* colormap_write	*/
	rat_viewport_set,		/* viewport_set		*/
	rat_window_set,			/* window_set		*/
	rat_zoom_set,			/* zoom_set		*/
	rat_curs_set,			/* curs_set		*/
	rat_cmemory_addr,		/* cursor_move_memory_addr */
	rat_cscreen_addr,		/* cursor_move_screen_addr */
	fb_sim_readrect,
	fb_sim_writerect,
d92 1
a92 1
	rat_dclose,			/* free resources	*/
d100 1
d102 3
d116 1
a116 1
rat_dopen( ifp, file, width, height )
d135 1
a135 1
rat_dclose( ifp )
d153 1
a153 1
rat_dclear( ifp, pp )
d171 1
a171 1
rat_bread( ifp, x, y, pixelp, count )
d301 1
a301 1
rat_bwrite( ifp, x, y, pixelp, count )
d376 1
a376 1
rat_cmread( ifp, cmp )
d384 1
a384 1
rat_cmwrite( ifp, cmp )
a415 2


d417 1
a417 1
rat_viewport_set( ifp, left, top, right, bottom )
d419 2
a420 1
int	left, top, right, bottom;
d422 4
d462 1
a462 1
rat_curs_set( ifp, bits, xbits, ybits, xorig, yorig )
d472 1
a472 1
rat_cmemory_addr( ifp, mode, x, y )
d479 1
a479 15
/*	if(   !	cload( 5, x, y )  ||  ! xhair( 0, mode ) )
		return	-1;	*/
	if(   !	cload(17, x, y )  ||  ! cursor( 0, mode ) )
		return	-1;
	return	0;
}

_LOCAL_ int
rat_cscreen_addr( ifp, mode, x, y )
/*	Place cursor at Screen Coordinates x & y
 */
FBIO	*ifp;
int	mode;
int	x, y;
{
@


9.1
log
@Release_3.5
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_rat.c,v 8.2 89/03/03 05:54:34 mike Exp $ (BRL)";
d90 2
@


8.2
log
@Added support for fb_readrect() and fb_writerect().
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_rat.c,v 8.1 88/10/05 00:27:38 mike Locked $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_rat.c,v 7.2 88/09/09 23:23:50 phil Exp $ (BRL)";
d26 2
d88 2
@


7.2
log
@fbhelp function
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_rat.c,v 7.1 87/11/02 23:26:40 phil Locked $ (BRL)";
@


7.1
log
@Release 2.3
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_rat.c,v 1.2 87/10/28 21:17:33 phil Exp $ (BRL)";
d67 2
a68 1
		rat_cscreen_addr();
d86 1
d929 14
@


1.2
log
@rcsid and include file fix
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_rat.c,v 6.2 87/09/16 03:49:02 phil Exp $ (BRL)";
@


1.1
log
@Initial revision
@
text
@d16 3
d23 1
a24 1
#include "./fb.h"
d85 1
a85 1
	"Raster Technology one/80",	/* device description	*/
@
