head	11.15;
access;
symbols
	ansi-20040405-merged:11.11.2.2
	postmerge-20040405-ansi:11.13
	premerge-20040404-ansi:11.12
	postmerge-autoconf:11.12
	autoconf-freeze:11.11.10.2
	premerge-autoconf:11.12
	ansi-20040316-freeze:11.11.2.1
	postmerge-20040315-windows:11.12
	premerge-20040315-windows:11.12
	windows-20040315-freeze:11.11.4.1
	autoconf-20031203:11.11
	autoconf-20031202:11.11
	autoconf-branch:11.11.0.10
	phong-branch:11.11.0.8
	photonmap-branch:11.11.0.6
	rel-6-1-DP:11.11
	windows-branch:11.11.0.4
	rel-6-0-2:11.9
	ansi-branch:11.11.0.2
	rel-6-0-1-branch:11.9.0.2
	hartley-6-0-post:11.10
	hartley-6-0-pre:11.9
	rel-6-0-1:11.9
	rel-6-0:11.9
	rel-5-4:11.4
	offsite-5-3-pre:11.6
	rel-5-3:11.4
	rel-5-2:11.4
	rel-5-1-branch:11.4.0.2
	rel-5-1:11.4
	rel-5-0:11.4
	rel-5-0-beta:11.4
	rel-4-5:11.3
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.15
date	2004.05.21.18.07.25;	author morrison;	state dead;
branches;
next	11.14;

11.14
date	2004.05.10.15.30.44;	author erikg;	state Exp;
branches;
next	11.13;

11.13
date	2004.04.05.07.44.42;	author morrison;	state Exp;
branches;
next	11.12;

11.12
date	2004.02.02.17.39.12;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2002.08.20.17.07.46;	author jra;	state Exp;
branches
	11.11.2.1
	11.11.4.1
	11.11.10.1;
next	11.10;

11.10
date	2002.08.15.20.55.00;	author hartley;	state Exp;
branches;
next	11.9;

11.9
date	2001.10.17.07.40.02;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2001.08.11.13.11.15;	author butler;	state Exp;
branches;
next	11.7;

11.7
date	2001.04.20.22.29.14;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	2000.07.25.17.49.50;	author butler;	state Exp;
branches;
next	11.5;

11.5
date	2000.07.12.01.33.30;	author cjohnson;	state Exp;
branches;
next	11.4;

11.4
date	98.06.27.04.29.15;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	96.08.27.06.22.33;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.07.10.15.17.53;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.52.47;	author mike;	state Rel4_4;
branches;
next	10.12;

10.12
date	94.12.30.03.57.36;	author mike;	state Exp;
branches;
next	10.11;

10.11
date	94.11.04.05.02.17;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	94.10.21.19.32.46;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	94.10.19.21.14.27;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	94.08.12.20.24.26;	author gdurf;	state Exp;
branches;
next	10.7;

10.7
date	94.08.09.12.57.45;	author gdurf;	state Exp;
branches;
next	10.6;

10.6
date	93.12.17.02.25.43;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	93.10.22.20.23.17;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	93.09.25.08.47.20;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	93.09.24.19.40.08;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	93.01.06.23.02.11;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.37.21;	author mike;	state Rel4_0;
branches;
next	1.19;

1.19
date	91.09.23.20.36.23;	author butler;	state Exp;
branches;
next	1.18;

1.18
date	91.07.26.22.40.58;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	90.12.11.22.32.57;	author phil;	state Exp;
branches;
next	1.16;

1.16
date	90.11.08.00.03.56;	author phil;	state Exp;
branches;
next	1.15;

1.15
date	90.11.07.21.30.19;	author phil;	state Exp;
branches;
next	1.14;

1.14
date	90.11.04.02.44.51;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	90.11.04.01.02.44;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	90.11.04.00.55.51;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	90.10.15.23.14.44;	author phil;	state Exp;
branches;
next	1.10;

1.10
date	89.11.23.02.49.32;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	89.11.23.02.02.40;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	89.09.01.01.37.39;	author phil;	state Exp;
branches;
next	1.7;

1.7
date	89.08.09.19.47.56;	author phil;	state Exp;
branches;
next	1.6;

1.6
date	89.07.28.03.29.44;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	89.07.27.05.18.44;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	89.07.27.03.56.06;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	89.07.27.03.24.35;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	89.07.27.03.01.28;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	89.07.27.00.49.09;	author mike;	state Exp;
branches;
next	;

11.11.2.1
date	2002.09.19.18.01.18;	author morrison;	state Exp;
branches;
next	11.11.2.2;

11.11.2.2
date	2004.03.17.21.17.00;	author morrison;	state Exp;
branches;
next	;

11.11.4.1
date	2004.03.11.23.42.07;	author morrison;	state Exp;
branches;
next	;

11.11.10.1
date	2004.02.12.19.48.12;	author erikg;	state Exp;
branches;
next	11.11.10.2;

11.11.10.2
date	2004.03.15.14.06.19;	author erikg;	state Exp;
branches;
next	;


desc
@Abekas A60 framebuffer interface, via Ethernet
@


11.15
log
@moved to src/
@
text
@/*
 *			I F _ A B . C
 *
 *  Communicate with an Abekas A60 digital videodisk as if it was
 *  a framebuffer, to ease the task of loading and storing images.
 *
 *  Authors -
 *	Michael John Muuss
 *	Phillip Dykstra
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1989-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libfb/if_ab.c,v 11.14 2004/05/10 15:30:44 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <math.h>
#include <time.h>
#include <fcntl.h>

#ifdef BSD
#  define __BSDbackup BSD
#  undef BSD
#endif

#include <netdb.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#ifdef __BSDbackup
#  undef BSD
#  define BSD __BSDbackup
#endif

#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"			/* For malloc */
#include "fb.h"
#include "./fblocal.h"

static void	ab_log(FBIO *ifp, char *str);
static int	ab_get_reply(int fd);
static int	ab_mread(int fd, register char *bufp, int n);
static void	ab_yuv_to_rgb(unsigned char *rgb_buf, unsigned char *yuv_buf, int len);
static void	ab_rgb_to_yuv(unsigned char *yuv_buf, unsigned char *rgb_buf, int len);
static int	ab_yuvio(int, char *, char *, int, int, int);

_LOCAL_ int	ab_open(register FBIO *ifp, register char *file, int width, int height),
		ab_close(FBIO *ifp),
		ab_clear(FBIO *ifp, unsigned char *bgpp),
		ab_read(register FBIO *ifp, int x, register int y, unsigned char *pixelp, int count),
		ab_write(register FBIO *ifp, int x, int y, const unsigned char *pixelp, int count),
		ab_rmap(register FBIO *ifp, register ColorMap *cmap),
		ab_wmap(register FBIO *ifp, register ColorMap *cmap),
		ab_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
		ab_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom),
		ab_cursor(FBIO *ifp, int mode, int x, int y),
		ab_getcursor(FBIO *ifp, int *mode, int *x, int *y),
		ab_help(FBIO *ifp);

FBIO abekas_interface = {
	0,
	ab_open,
	ab_close,
	ab_clear,
	ab_read,
	ab_write,
	ab_rmap,
	ab_wmap,
	ab_view,
	ab_getview,
	fb_null_setcursor,		/* setcursor */
	ab_cursor,
	ab_getcursor,
	fb_sim_readrect,
	fb_sim_writerect,
	fb_sim_bwreadrect,
	fb_sim_bwwriterect,
	fb_null,			/* poll */
	fb_null,			/* flush */
	ab_close,			/* free */
	ab_help,
	"Abekas A60 Videodisk, via Ethernet",
	720,				/* max width */
	486,				/* max height */
	"/dev/ab",
	720,				/* current/default width */
	486,				/* current/default height */
	-1,				/* select fd */
	-1,				/* file descriptor */
	1, 1,				/* zoom */
	360, 243,			/* window center */
	0, 0, 0,			/* cursor */
	PIXEL_NULL,			/* page_base */
	PIXEL_NULL,			/* page_curp */
	PIXEL_NULL,			/* page_endp */
	-1,				/* page_no */
	0,				/* page_ref */
	0L,				/* page_curpos */
	0L,				/* page_pixels */
	0				/* debug */
};

#define if_frame	u1.l		/* frame number on A60 disk */
#define if_mode		u2.l		/* see MODE_ and STATE_ defines */
#define if_yuv		u3.p		/* YUV image, 4th quadrant */
#define if_rgb		u4.p		/* RGB image, 1st quadrant */
#define if_host		u5.p		/* Hostname */
#define if_xyoff	u6.l		/* (x<<16) | y pixel offsets */

/*
 *  The mode has several independent bits:
 *	Center -vs- lower-left
 *	Output-only (or well-behaved read-write) -vs- conservative read-write
 *
 *  Also, the state bits ride in some of the upper bits.
 */
#define MODE_1MASK	(1<<0)
#define MODE_1CENTER	(0<<0)
#define MODE_1LOWERLEFT	(1<<0)

#define MODE_2MASK	(1<<1)
#define MODE_2READFIRST	(0<<1)
#define MODE_2OUTONLY	(1<<1)

#define MODE_3MASK	(1<<2)
#define MODE_3QUIET	(0<<2)
#define MODE_3VERBOSE	(1<<2)

#define MODE_4MASK	(1<<3)
#define MODE_4NETWORK	(0<<3)
#define MODE_4DISK	(1<<3)

#define STATE_FRAME_WAS_READ	(1<<8)
#define STATE_USER_HAS_READ	(1<<9)
#define STATE_USER_HAS_WRITTEN	(1<<10)

static struct modeflags {
	char	c;
	long	mask;
	long	value;
	char	*help;
} modeflags[] = {
	{ 'l',	MODE_1MASK, MODE_1LOWERLEFT,
		"Lower left;  default=center" },
	{ 'o',	MODE_2MASK, MODE_2OUTONLY,
		"Output only (in before out); default=always read first" },
	{ 'v',	MODE_3MASK, MODE_3VERBOSE,
		"Verbose logging; default=quiet" },
	{ 'f',	MODE_4MASK, MODE_4DISK,
		"Read/write YUV to disk file given by @@#; default=use EtherNet" },
	{ '\0', 0, 0, "" }
};


/*
 *			A B _ O P E N
 *
 *  The device name is expected to have a fairly rigid format:
 *
 *	/dev/abco@@host#300
 *
 *  ie, options follow first (if any),
 *  "@@host" gives target host (else use environment variable),
 *  "#300" gives frame number (else use default frame).
 *
 *  It is intentional that the frame number is last in the sequence;
 *  this should make changing it easier with tcsh, etc.
 *
 */
_LOCAL_ int
ab_open(register FBIO *ifp, register char *file, int width, int height)
{
	register char	*cp;
	register int	i;
	char	message[128];
	int	mode;

	FB_CK_FBIO(ifp);
	mode = 0;

	if( file == NULL )  {
		fb_log( "ab_open: NULL device string\n" );
		return(-1);
	}

	if( strncmp( file, "/dev/ab", 7 ) != 0 )  {
		fb_log("ab_open: bad device '%s'\n", file );
		return(-1);
	}

	/* Process any options */
	for( cp = &file[7]; *cp != '\0'; cp++)  {
		register struct	modeflags *mfp;

		if( *cp == '@@' || *cp == '#' )  break;
		for( mfp = modeflags; mfp->c != '\0'; mfp++ )  {
			if( mfp->c != *cp )  continue;
			mode = (mode & ~(mfp->mask)) | mfp->value;
			break;
		}
		if( mfp->c == '\0' )  {
			fb_log("ab_open: unknown option '%c' ignored\n", *cp);
		}
	}
	ifp->if_mode = mode;

	/* Process host name */
	if( *cp == '@@' )  {
		register char	*ep;

		cp++;			/* advance over '@@' */

		/* Measure length, allocate memory for string */
		for( ep=cp; *ep != '\0' && *ep != '#'; ep++ ) /* NULL */ ;
		ifp->if_host = malloc(ep-cp+2);

		ep = ifp->if_host;
		for( ; *cp != '\0' && *cp != '#'; )
			*ep++ = *cp++;
		*ep++ = '\0';
	} else if( *cp != '#' && *cp != '\0' )  {
		fb_log("ab_open: error in file spec '%s'\n", cp);
		return(-1);
	} else {
		/* Get hostname from environment variable */
		if( (ifp->if_host = getenv("ABEKAS")) == NULL )  {
			if( (ifp->if_mode & MODE_4MASK) == MODE_4NETWORK )  {
				fb_log("ab_open: hostname not given and ABEKAS environment variable not set\n");
				return(-1);
			} else {
				/* Here, "host" is a filename prefix. */
				ifp->if_host = "";
			}
		}
	}

	/* Process frame number */
	ifp->if_frame = -1;		/* default to frame store */
	if( *cp == '#' )  {
		register int	i;

		i = atoi(cp+1);
		if( (ifp->if_mode & MODE_4MASK) == MODE_4NETWORK )  {
			/* Perform validity checking on frame numbers */
			if( i >= 50*30 )  {
				fb_log("ab_open: frame %d out of range\n", i);
				return(-1);
			}
			if( i < 0 ) {
				fb_log("ab_open: frame < 0, using frame store\n");
			}
		}
		ifp->if_frame = i;
	} else if( *cp != '\0' )  {
		fb_log("ab_open: error in file spec '%s'\n", cp);
		return(-1);
	}

	/* Allocate memory for YUV and RGB buffers */
	if( (ifp->if_yuv = malloc(720*486*2)) == NULL ||
	    (ifp->if_rgb = malloc(720*486*3)) == NULL )  {
		fb_log("ab_open: unable to malloc buffer\n");
		return(-1);
	}

	/* Handle size defaulting and checking */
	if( width <= 0 )
		width = ifp->if_width;
	if( height <= 0 )
		height = ifp->if_height;
	if ( width > ifp->if_max_width )
		width = ifp->if_max_width;
	if ( height > ifp->if_max_height)
		height = ifp->if_max_height;
	ifp->if_width = width;
	ifp->if_height = height;

	/* X and Y offsets if centering & non-full size */
	ifp->if_xyoff = 0;
	if( (ifp->if_mode & MODE_1MASK) == MODE_1CENTER )  {
		if( width < ifp->if_max_width )  {
			i = (ifp->if_max_width - width)/2;
			ifp->if_xyoff = i<<16;
		}
		if( height < ifp->if_max_height )  {
			i = (ifp->if_max_height - height)/2;
			i &= ~1;	/* preserve field alignment */
			ifp->if_xyoff |= i;
		}
	}


	/*
	 *  If "output-only" mode was set, clear the frame to black.
	 */
	if( (ifp->if_mode & MODE_2MASK) == MODE_2OUTONLY )  {
		(void)ab_clear( ifp, PIXEL_NULL );
		/* This sets STATE_USER_HAS_WRITTEN */
	}

	if( ifp->if_xyoff )  {
		sprintf(message,"ab_open %d*%d xoff=%ld yoff=%ld",
			ifp->if_width, ifp->if_height,
			ifp->if_xyoff>>16, ifp->if_xyoff&0xFFFF );
	} else {
		sprintf(message,"ab_open %d*%d",
			ifp->if_width, ifp->if_height);
	}
	ab_log(ifp, message);

	return( 0 );			/* OK */
}

/*
 *			A B _ L O G
 *
 *  If verbose mode is enabled, print the time and a message
 */
static void ab_log(FBIO *ifp, char *str)
{
	time_t		now;
	struct tm	*tmp;

	if( (ifp->if_mode & MODE_3MASK) != MODE_3VERBOSE )  return;

	(void)time( &now );
	tmp = localtime( &now );
	if( ifp->if_frame < 0 ) {
		fb_log("%2.2d:%2.2d:%2.2d %s frame store: %s\n",
			tmp->tm_hour, tmp->tm_min, tmp->tm_sec,
			ifp->if_host, str );
	} else {
		fb_log("%2.2d:%2.2d:%2.2d %s frame %d: %s\n",
			tmp->tm_hour, tmp->tm_min, tmp->tm_sec,
			ifp->if_host, ifp->if_frame, str );
	}
}

/*
 *			A B _ R E A D F R A M E
 */
static int
ab_readframe(FBIO *ifp)
{
	register int	y;

	ab_log(ifp, "Reading frame");
	if( ab_yuvio( 0, ifp->if_host, ifp->if_yuv,
	    720*486*2, ifp->if_frame,
	    (ifp->if_mode & MODE_4MASK) == MODE_4NETWORK
	    ) != 720*486*2 )  {
		fb_log("ab_readframe(%d): unable to get frame from %s!\n",
			ifp->if_frame, ifp->if_host);
		return(-1);
	}

	/* convert YUV to RGB */
	ab_log(ifp, "Converting YUV to RGB");
	for( y=0; y < 486; y++ )  {
		ab_yuv_to_rgb(
		    &ifp->if_rgb[(486-1-y)*720*3],
		    &ifp->if_yuv[y*720*2],
		    720 );
	}
	ab_log(ifp, "Conversion done");

	ifp->if_mode |= STATE_FRAME_WAS_READ;
	return(0);			/* OK */
}

/*
 *			A B _ C L O S E
 */
_LOCAL_ int
ab_close(FBIO *ifp)
{
	int	ret = 0;

	if( ifp->if_mode & STATE_USER_HAS_WRITTEN )  {
		register int y;		/* in Abekas coordinates */

		/* Convert RGB to YUV */
		ab_log(ifp, "Converting RGB to YUV");
		for( y=0; y < 486; y++ )  {
			ab_rgb_to_yuv(
			    &ifp->if_yuv[y*720*2],
			    &ifp->if_rgb[(486-1-y)*720*3],
			    720 );
		}
		ab_log(ifp, "Writing frame");

		if( ab_yuvio( 1, ifp->if_host, ifp->if_yuv,
		    720*486*2, ifp->if_frame,
		    (ifp->if_mode & MODE_4MASK) == MODE_4NETWORK
		    ) != 720*486*2 )  {
			fb_log("ab_close: unable to send frame %d to A60 %s!\n",
				ifp->if_frame, ifp->if_host);
		    	ret = -1;
		}
		ab_log(ifp, "Transmission done");
	}

	/* Free dynamic memory */
	free( ifp->if_yuv );
	ifp->if_yuv = NULL;
	free( ifp->if_rgb );
	ifp->if_rgb = NULL;

	ab_log(ifp, "ab_close");
	return(ret);
}

/*
 *			A B _ C L E A R
 */
_LOCAL_ int
ab_clear(FBIO *ifp, unsigned char *bgpp)
{
	register int	r,g,b;
	register int	count;
	register char	*cp;

	if( bgpp == PIXEL_NULL )  {
		/* Clear to black */
		bzero( ifp->if_rgb, 720*486*3 );
	} else {
		r = (bgpp)[RED];
		g = (bgpp)[GRN];
		b = (bgpp)[BLU];

		cp = ifp->if_rgb;
		for( count = 720*486-1; count >= 0; count-- )  {
			*cp++ = r;
			*cp++ = g;
			*cp++ = b;
		}
	}

	ifp->if_mode |= STATE_USER_HAS_WRITTEN;
	return(0);
}

/*
 *			A B _ R E A D
 */
_LOCAL_ int
ab_read(register FBIO *ifp, int x, register int y, unsigned char *pixelp, int count)
{
	register short		scan_count;	/* # pix on this scanline */
	register char		*cp;
	int			ret;
	int			xoff, yoff;

	if( count <= 0 )
		return(0);

	if( x < 0 || x > ifp->if_width ||
	    y < 0 || y > ifp->if_height)
		return(-1);

	if( (ifp->if_mode & STATE_FRAME_WAS_READ) == 0 )  {
		if( (ifp->if_mode & STATE_USER_HAS_WRITTEN) != 0 )  {
			fb_log("ab_read:  WARNING out-only mode set & pixels were written.  Subsequent read operation is unsafe\n");
			/* Give him whatever is in the buffer */
		} else {
			/* Read in the frame */
			if( ab_readframe(ifp) < 0 )  return(-1);
		}
	}

	xoff = ifp->if_xyoff>>16;
	yoff = ifp->if_xyoff & 0xFFFF;

	/* Copy from if_rgb[] */
	ret = 0;
	cp = (char *)(pixelp);

	while( count )  {
		if( y >= ifp->if_height )
			break;

		if ( count >= ifp->if_width-x )
			scan_count = ifp->if_width-x;
		else
			scan_count = count;

		bcopy( &ifp->if_rgb[((y+yoff)*720+(x+xoff))*3], cp,
			scan_count*3 );
		cp += scan_count * 3;
		ret += scan_count;
		count -= scan_count;
		/* Advance upwards */
		x = 0;
		y++;
	}
	ifp->if_mode |= STATE_USER_HAS_READ;
	return(ret);
}

/*
 *			A B _ W R I T E
 */
_LOCAL_ int
ab_write(register FBIO *ifp, int x, int y, const unsigned char *pixelp, int count)
{
	register short		scan_count;	/* # pix on this scanline */
	register const unsigned char	*cp;
	int			ret;
	int			xoff, yoff;

	if( count <= 0 )
		return(0);

	if( x < 0 || x > ifp->if_width ||
	    y < 0 || y > ifp->if_height)
		return(-1);

	/*
	 *  If this is the first write, and the frame has not
	 *  yet been read, then read it.
	 */
	if( (ifp->if_mode & STATE_FRAME_WAS_READ) == 0 &&
	    (ifp->if_mode & STATE_USER_HAS_WRITTEN) == 0 )  {
		/* Read in the frame first */
		(void)ab_readframe(ifp);
	}

	xoff = ifp->if_xyoff>>16;
	yoff = ifp->if_xyoff & 0xFFFF;

	/* Copy from if_rgb[] */
	ret = 0;
	cp = (pixelp);

	while( count )  {
		if( y >= ifp->if_height )
			break;

		if ( count >= ifp->if_width-x )
			scan_count = ifp->if_width-x;
		else
			scan_count = count;

		bcopy( (char *)cp, &ifp->if_rgb[((y+yoff)*720+(x+xoff))*3],
			scan_count*sizeof(RGBpixel) );
		cp += scan_count * sizeof(RGBpixel);
		ret += scan_count;
		count -= scan_count;
		/* Advance upwards */
		x = 0;
		y++;
	}
	ifp->if_mode |= STATE_USER_HAS_WRITTEN;
	return(ret);
}

/*
 */
_LOCAL_ int
ab_cursor(FBIO *ifp, int mode, int x, int y)
{
	fb_sim_cursor(ifp, mode, x, y);

	return(-1);
}

/*
 */
_LOCAL_ int
ab_getcursor(FBIO *ifp, int *mode, int *x, int *y)
{
	fb_sim_getcursor(ifp, mode, x, y);

	return(-1);
}

/*
 */
_LOCAL_ int
ab_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
{
	fb_sim_view(ifp, xcenter, ycenter, xzoom, yzoom);

	return(-1);
}

/*
 */
_LOCAL_ int
ab_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom)
{
	fb_sim_getview(ifp, xcenter, ycenter, xzoom, yzoom);

	return(-1);
}

_LOCAL_ int
ab_rmap(register FBIO *ifp, register ColorMap *cmap)
{
	register int	i;

	for( i = 0; i < 256; i++ ) {
		cmap->cm_red[i] = i<<8;
		cmap->cm_green[i] = i<<8;
		cmap->cm_blue[i] = i<<8;
	}
	return(0);
}

_LOCAL_ int
ab_wmap(register FBIO *ifp, register ColorMap *cmap)
{
	/* Just pretend it worked OK */
	return(0);
}

/*
 *			A B _ H E L P
 */
_LOCAL_ int
ab_help(FBIO *ifp)
{
	struct	modeflags *mfp;

	fb_log( "Abekas A60 Ethernet Interface\n" );
	fb_log( "Device: %s\n", ifp->if_name );
	fb_log( "Maximum width height: %d %d\n",
		ifp->if_max_width,
		ifp->if_max_height );
	fb_log( "Default width height: %d %d\n",
		ifp->if_width,
		ifp->if_height );
	fb_log( "A60 Host: %s\n", ifp->if_host );
	if( ifp->if_frame < 0 ) {
		fb_log( "Frame: store\n" );
	} else {
		fb_log( "Frame: %d\n", ifp->if_frame );
	}
	fb_log( "Usage: /dev/ab[options][@@host][#framenumber]\n" );
	fb_log( "       If no framenumber is given, the frame store is used\n" );
	for( mfp = modeflags; mfp->c != '\0'; mfp++ ) {
		fb_log( "   %c   %s\n", mfp->c, mfp->help );
	}

	return(0);
}

/*
 *			A B _ Y U V I O
 *
 *  Input or output a full frame image from the Abekas using the RCP
 *  protocol.
 *
 *  Returns -
 *	-1	error
 *	len	successful count
 */
int
ab_yuvio(int output, char *host, char *buf, int len, int frame, int to_network)
   	       		/* 0=read(input), 1=write(output) */
    	      
    	     
   	    
   	      		/* frame number */
   	           
{
	struct sockaddr_in	sinme;		/* Client */
	struct sockaddr_in	sinhim;		/* Server */
	struct servent		*rlogin_service;
	struct hostent		*hp;
	char			xmit_buf[128];
	int			n;
	int			netfd;
	int			got;

	if( !to_network )  {
		if( frame >= 0 )
			sprintf( xmit_buf, "%s%d.yuv", host, frame );
		else
			sprintf( xmit_buf, "%s.yuv", host);
		if( output )
			netfd = creat( xmit_buf, 0444 );
		else
			netfd = open( xmit_buf, 0 );
		if( netfd < 0 )  {
			perror( xmit_buf );
			return -1;
		}
		if( output )
			got = write( netfd, buf, len );
		else
			got = ab_mread( netfd, buf, len );
		if( got != len )  {
			perror("read/write");
			fb_log("ab_yuvio file read/write error, len=%d, got=%d\n", len, got );
			goto err;
		}
		(void)close(netfd);
		return got;		/* OK */
	}

	bzero((char *)&sinhim, sizeof(sinhim));
	bzero((char *)&sinme, sizeof(sinme));

	if( (rlogin_service = getservbyname("shell", "tcp")) == NULL )  {
		fb_log("getservbyname(shell,tcp) fail\n");
		return(-1);
	}
	sinhim.sin_port = rlogin_service->s_port;

	if( atoi( host ) > 0 )  {
		/* Numeric */
		sinhim.sin_family = AF_INET;
		sinhim.sin_addr.s_addr = inet_addr(host);
	} else {
		if( (hp = gethostbyname(host)) == NULL )  {
			fb_log("gethostbyname(%s) fail\n", host);
			return(-1);
		}
		sinhim.sin_family = hp->h_addrtype;
		bcopy(hp->h_addr, (char *)&sinhim.sin_addr, hp->h_length);
	}

	if( (netfd = socket(sinhim.sin_family, SOCK_STREAM, 0)) < 0 )  {
		perror("socket()");
		return(-1);
	}
	sinme.sin_port = 0;		/* let kernel pick it */

	if( bind(netfd, (struct sockaddr *)&sinme, sizeof(sinme)) < 0 )  {
		perror("bind()");
		goto err;
	}

	if( connect(netfd, (struct sockaddr *)&sinhim, sizeof(sinhim)) < 0 ) {
		perror("connect()");
		goto err;
	}

	/*
	 *  Connection established.  Now, speak the RCP protocol.
	 */

	/* Indicate that standard error is not connected */
	if( write( netfd, "\0", 1 ) != 1 )  {
		perror("write()");
		goto err;
	}

	/* Write local and remote user names, null terminated */
	if( write( netfd, "a60libfb\0", 9 ) != 9 )  {
		perror("write()");
		goto err;
	}
	if( write( netfd, "a60libfb\0", 9 ) != 9 )  {
		perror("write()");
		goto err;
	}
	if( ab_get_reply(netfd) < 0 )  goto err;

	if( output )  {
		/* Output from buffer to A60 */
		/* Send command, null-terminated */
		if( frame < 0 )
			sprintf( xmit_buf, "rcp -t store.yuv" );
		else
			sprintf( xmit_buf, "rcp -t %d.yuv", frame );
		n = strlen(xmit_buf)+1;		/* include null */
		if( write( netfd, xmit_buf, n ) != n )  {
			perror("write()");
			goto err;
		}
		if( ab_get_reply(netfd) < 0 )  goto err;

		/* Send Access flags, length, old name */
		if( frame < 0 )
			sprintf( xmit_buf, "C0664 %d store.yuv\n", len );
		else
			sprintf( xmit_buf, "C0664 %d %d.yuv\n", len, frame );
		n = strlen(xmit_buf);
		if( write( netfd, xmit_buf, n ) != n )  {
			perror("write()");
			goto err;
		}
		if( ab_get_reply(netfd) < 0 )  goto err;

		if( (got = write( netfd, buf, len )) != len )  {
			perror("write()");
			goto err;
		}

		/* Send final go-ahead */
		if( (got = write( netfd, "\0", 1 )) != 1 )  {
			fb_log("go-ahead write got %d\n", got);
			perror("write()");
			goto err;
		}
		if( (got = ab_get_reply(netfd)) < 0 )  {
			fb_log("get_reply got %d\n", got);
			goto err;
		}

		(void)close(netfd);
		return(len);		/* OK */
	} else {
		register char	*cp;
		int		perm;
		int		src_size;
		/* Input from A60 into buffer */
		/* Send command, null-terminated */
		if( frame < 0 )
			sprintf( xmit_buf, "rcp -f store.yuv" );
		else
			sprintf( xmit_buf, "rcp -f %d.yuv", frame );
		n = strlen(xmit_buf)+1;		/* include null */
		if( write( netfd, xmit_buf, n ) != n )  {
			perror("write()");
			goto err;
		}

		/* Send go-ahead */
		if( write( netfd, "\0", 1 ) != 1 )  {
			perror("write()");
			goto err;
		}

		/* Read up to a newline */
		cp = xmit_buf;
		for(;;)  {
			if( read( netfd, cp, 1 ) != 1 )  {
				perror("read()");
				goto err;
			}
			if( *cp == '\n' )  break;
			cp++;
			if( (cp - xmit_buf) >= sizeof(xmit_buf) )  {
				fb_log("cmd buffer overrun\n");
				goto err;
			}
		}
		*cp++ = '\0';
		/* buffer will contain old permission, size, old name */
		src_size = 0;
		if( sscanf( xmit_buf, "C%o %d", (unsigned int *)&perm, &src_size ) != 2 )  {
			fb_log("sscanf error\n");
			goto err;
		}

		/* Send go-ahead */
		if( write( netfd, "\0", 1 ) != 1 )  {
			perror("write()");
			goto err;
		}

		/* Read data */
		if( (got = ab_mread( netfd, buf, len )) != len )  {
			fb_log("ab_mread len=%d, got %d\n", len, got );
			goto err;
		}

		/* Send go-ahead */
		if( write( netfd, "\0", 1 ) != 1 )  {
			perror("write()");
			goto err;
		}
		(void)close(netfd);
		return(len);		/* OK */
	}

err:
	(void)close(netfd);
	return(-1);
}

static int
ab_get_reply(int fd)
{
	char	rep_buf[128];
	int	got;

	if( (got = read( fd, rep_buf, sizeof(rep_buf) )) < 0 )  {
		perror("ab_get_reply()/read()");
		fb_log("ab_get_reply() read error\n");
		return(-1);
	}

	if( got == 0 )  {
		fb_log("ab_get_reply() unexpected EOF\n");
		return(-2);		/* EOF seen */
	}

	/* got >= 1 */
	if( rep_buf[0] == 0 )
		return(0);		/* OK */

	if( got == 1 )  {
		fb_log("ab_get_reply() error reply code, no attached message\n");
		return(-3);
	}

	/* Print error code received from other end */
	fb_log("ab_get_reply() error='%s'\n", &rep_buf[1] );
	return(-4);
}

/*
 *			M R E A D
 *
 * Internal.
 * This function performs the function of a read(II) but will
 * call read(II) multiple times in order to get the requested
 * number of characters.  This can be necessary because pipes
 * and network connections don't deliver data with the same
 * grouping as it is written with.  Written by Robert S. Miles, BRL.
 */
static int
ab_mread(int fd, register char *bufp, int n)
{
	register int	count = 0;
	register int	nread;

	do {
		nread = read(fd, bufp, (unsigned)n-count);
		if(nread < 0)  {
			perror("ab_mread");
			return(-1);
		}
		if(nread == 0)
			return((int)count);
		count += (unsigned)nread;
		bufp += nread;
	 } while(count < n);

	return((int)count);
}

/*************************************************************************
 *************************************************************************
 *  Herein lies the conversion between YUV and RGB
 *************************************************************************
 *************************************************************************
 */
/*  A 4:2:2 framestore uses 2 bytes per pixel.  The even pixels (from 0)
 *  hold Cb and Y, the odd pixels Cr and Y.  Thus a scan line has:
 *      Cb Y Cr Y Cb Y Cr Y ...
 *  If we are at an even pixel, we use the Cr value following it.  If
 *  we are at an odd pixel, we use the Cb value following it.
 *
 *  Y:       0 .. 219 range, offset by 16   [16 .. 235]
 *  U, V: -112 .. +112 range, offset by 128 [16 .. 240]
 */

#define	VDOT(a,b)	(a[0]*b[0]+a[1]*b[1]+a[2]*b[2])
#define	V5DOT(a,b)	(a[0]*b[0]+a[1]*b[1]+a[2]*b[2]+a[3]*b[3]+a[4]*b[4])
#define	floor(d)	(d>=0?(int)d:((int)d==d?d:(int)(d-1.0)))
#define	CLIP(out,in)		{ register int t; \
		if( (t = (in)) < 0 )  (out) = 0; \
		else if( t >= 255 )  (out) = 255; \
		else (out) = t; }

#define	LINE_LENGTH	720
#define	FRAME_LENGTH	486

static double	y_weights[] = {  0.299,   0.587,   0.114 };
static double	u_weights[] = { -0.1686, -0.3311,  0.4997 };
static double	v_weights[] = {  0.4998, -0.4185, -0.0813 };

static double	y_filter[] = { -0.05674, 0.01883, 1.07582, 0.01883, -0.05674 };
static double	u_filter[] = {  0.14963, 0.22010, 0.26054, 0.22010,  0.14963 };
static double	v_filter[] = {  0.14963, 0.22010, 0.26054, 0.22010,  0.14963 };

static double	ybuf[724];
static double	ubuf[724];
static double	vbuf[724];

/* RGB to YUV */
static void
ab_rgb_to_yuv(unsigned char *yuv_buf, unsigned char *rgb_buf, int len)
{
	register unsigned char *cp;
	register double	*yp, *up, *vp;
	register int	i;
	static int	first=1;

	if(first)  {
		/* SETUP */
		for( i = 0; i < 5; i++ ) {
			y_filter[i] *= 219.0/255.0;
			u_filter[i] *= 224.0/255.0;
			v_filter[i] *= 224.0/255.0;
		}
		first = 0;
	}

	/* Matrix RGB's into separate Y, U, and V arrays */
	yp = &ybuf[2];
	up = &ubuf[2];
	vp = &vbuf[2];
	cp = rgb_buf;
	for( i = len; i; i-- ) {
		*yp++ = VDOT( y_weights, cp );
		*up++ = VDOT( u_weights, cp );
		*vp++ = VDOT( v_weights, cp );
		cp += 3;
	}

	/* filter, scale, and sample YUV arrays */
	yp = ybuf;
	up = ubuf;
	vp = vbuf;
	cp = yuv_buf;
	for( i = len/2; i; i-- ) {
		*cp++ = V5DOT(u_filter,up) + 128.0;	/* u */
		*cp++ = V5DOT(y_filter,yp) + 16.0;	/* y */
		*cp++ = V5DOT(v_filter,vp) + 128.0;	/* v */
		yp++;
		*cp++ = V5DOT(y_filter,yp) + 16.0;	/* y */
		yp++;
		up += 2;
		vp += 2;
	}
}

/* YUV to RGB */
static void
ab_yuv_to_rgb(unsigned char *rgb_buf, unsigned char *yuv_buf, int len)
{
	register unsigned char *rgbp;
	register unsigned char *yuvp;
	register double	y;
	register double	u = 0.0;
	register double	v;
	register int	pixel;
	int		last;

	/* Input stream looks like:  uy  vy  uy  vy  */

	rgbp = rgb_buf;
	yuvp = yuv_buf;
	last = len/2;
	for( pixel = last; pixel; pixel-- ) {
		/* even pixel, get y and next v */
		if( pixel == last ) {
			u = ((double)(((int)*yuvp++) - 128)) * (255.0/224.0);
		}
		y = ((double)(((int)*yuvp++) - 16)) * (255.0/219.0);
		v = ((double)(((int)*yuvp++) - 128)) * (255.0/224.0);

		CLIP( *rgbp++, y + 1.4026 * v);			/* R */
		CLIP( *rgbp++, y - 0.3444 * u - 0.7144 * v);	/* G */
		CLIP( *rgbp++, y + 1.7730 * u);			/* B */

		/* odd pixel, got v already, get y and next u */
		y = ((double)(((int)*yuvp++) - 16)) * (255.0/219.0);
		if( pixel != 1 ) {
			u = ((double)(((int)*yuvp++) - 128)) * (255.0/224.0);
		}

		CLIP( *rgbp++, y + 1.4026 * v);			/* R */
		CLIP( *rgbp++, y - 0.3444 * u - 0.7144 * v);	/* G */
		CLIP( *rgbp++, y + 1.7730 * u);			/* B */
	}
}
@


11.14
log
@change conf.h to a wrapped config.h
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/libfb/if_ab.c,v 11.13 2004/04/05 07:44:42 morrison Exp $ (BRL)";
@


11.13
log
@merge of ansi-6-0-branch into HEAD
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d24 5
a28 1
#include "conf.h"
@


11.12
log
@update copyright to include span through 2003
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ab.c,v 11.11 2002/08/20 17:07:46 jra Exp $ (BRL)";
d60 5
a64 5
static void	ab_log();
static int	ab_get_reply();
static int	ab_mread();
static void	ab_yuv_to_rgb();
static void	ab_rgb_to_yuv();
d67 12
a78 12
_LOCAL_ int	ab_open(),
		ab_close(),
		ab_clear(),
		ab_read(),
		ab_write(),
		ab_rmap(),
		ab_wmap(),
		ab_view(),
		ab_getview(),
		ab_cursor(),
		ab_getcursor(),
		ab_help();
d191 1
a191 4
ab_open( ifp, file, width, height )
register FBIO	*ifp;
register char	*file;
int		width, height;
d339 1
a339 3
static void ab_log(ifp, str)
FBIO	*ifp;
char	*str;
d363 1
a363 2
ab_readframe(ifp)
FBIO	*ifp;
d395 1
a395 2
ab_close( ifp )
FBIO	*ifp;
d437 1
a437 3
ab_clear( ifp, bgpp )
FBIO		*ifp;
unsigned char	*bgpp;
d467 1
a467 6
ab_read( ifp, x, y, pixelp, count )
register FBIO	*ifp;
int		x;
register int	y;
unsigned char	*pixelp;
int		count;
d524 1
a524 5
ab_write( ifp, x, y, pixelp, count )
register FBIO	*ifp;
int		x, y;
const unsigned char	*pixelp;
int		count;
d580 1
a580 4
ab_cursor( ifp, mode, x, y )
FBIO	*ifp;
int	mode;
int	x, y;
d590 1
a590 4
ab_getcursor( ifp, mode, x, y )
FBIO	*ifp;
int	*mode;
int	*x, *y;
d600 1
a600 4
ab_view( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	xcenter, ycenter;
int	xzoom, yzoom;
d610 1
a610 4
ab_getview( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	*xcenter, *ycenter;
int	*xzoom, *yzoom;
d618 1
a618 3
ab_rmap( ifp, cmap )
register FBIO		*ifp;
register ColorMap	*cmap;
d631 1
a631 3
ab_wmap( ifp, cmap )
register FBIO		*ifp;
register ColorMap	*cmap;
d641 1
a641 2
ab_help( ifp )
FBIO	*ifp;
d679 7
a685 7
ab_yuvio( output, host, buf, len, frame, to_network )
int	output;		/* 0=read(input), 1=write(output) */
char	*host;
char	*buf;
int	len;
int	frame;		/* frame number */
int	to_network;
d896 1
a896 2
ab_get_reply(fd)
int	fd;
d937 1
a937 4
ab_mread(fd, bufp, n)
int	fd;
register char	*bufp;
int	n;
d998 1
a998 4
ab_rgb_to_yuv( yuv_buf, rgb_buf, len )
unsigned char *yuv_buf;
unsigned char *rgb_buf;
int	len;
d1046 1
a1046 3
ab_yuv_to_rgb( rgb_buf, yuv_buf, len )
unsigned char *rgb_buf;
unsigned char *yuv_buf;
@


11.11
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1989 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ab.c,v 11.9 2001/10/17 07:40:02 morrison Exp $ (BRL)";
@


11.11.4.1
log
@sync to HEAD...
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libfb/if_ab.c,v 11.12 2004/02/02 17:39:12 morrison Exp $ (BRL)";
@


11.11.10.1
log
@merge from HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ab.c,v 11.12 2004/02/02 17:39:12 morrison Exp $ (BRL)";
@


11.11.10.2
log
@merge from head
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ab.c,v 11.11.10.1 2004/02/12 19:48:12 erikg Exp $ (BRL)";
@


11.11.2.1
log
@Initial ANSIfication
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ab.c,v 11.11 2002/08/20 17:07:46 jra Exp $ (BRL)";
d60 5
a64 5
static void	ab_log(FBIO *ifp, char *str);
static int	ab_get_reply(int fd);
static int	ab_mread(int fd, register char *bufp, int n);
static void	ab_yuv_to_rgb(unsigned char *rgb_buf, unsigned char *yuv_buf, int len);
static void	ab_rgb_to_yuv(unsigned char *yuv_buf, unsigned char *rgb_buf, int len);
d67 12
a78 12
_LOCAL_ int	ab_open(register FBIO *ifp, register char *file, int width, int height),
		ab_close(FBIO *ifp),
		ab_clear(FBIO *ifp, unsigned char *bgpp),
		ab_read(register FBIO *ifp, int x, register int y, unsigned char *pixelp, int count),
		ab_write(register FBIO *ifp, int x, int y, const unsigned char *pixelp, int count),
		ab_rmap(register FBIO *ifp, register ColorMap *cmap),
		ab_wmap(register FBIO *ifp, register ColorMap *cmap),
		ab_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
		ab_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom),
		ab_cursor(FBIO *ifp, int mode, int x, int y),
		ab_getcursor(FBIO *ifp, int *mode, int *x, int *y),
		ab_help(FBIO *ifp);
d191 4
a194 1
ab_open(register FBIO *ifp, register char *file, int width, int height)
d342 3
a344 1
static void ab_log(FBIO *ifp, char *str)
d368 2
a369 1
ab_readframe(FBIO *ifp)
d401 2
a402 1
ab_close(FBIO *ifp)
d444 3
a446 1
ab_clear(FBIO *ifp, unsigned char *bgpp)
d476 6
a481 1
ab_read(register FBIO *ifp, int x, register int y, unsigned char *pixelp, int count)
d538 5
a542 1
ab_write(register FBIO *ifp, int x, int y, const unsigned char *pixelp, int count)
d598 4
a601 1
ab_cursor(FBIO *ifp, int mode, int x, int y)
d611 4
a614 1
ab_getcursor(FBIO *ifp, int *mode, int *x, int *y)
d624 4
a627 1
ab_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
d637 4
a640 1
ab_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom)
d648 3
a650 1
ab_rmap(register FBIO *ifp, register ColorMap *cmap)
d663 3
a665 1
ab_wmap(register FBIO *ifp, register ColorMap *cmap)
d675 2
a676 1
ab_help(FBIO *ifp)
d714 7
a720 7
ab_yuvio(int output, char *host, char *buf, int len, int frame, int to_network)
   	       		/* 0=read(input), 1=write(output) */
    	      
    	     
   	    
   	      		/* frame number */
   	           
d931 2
a932 1
ab_get_reply(int fd)
d973 4
a976 1
ab_mread(int fd, register char *bufp, int n)
d1037 4
a1040 1
ab_rgb_to_yuv(unsigned char *yuv_buf, unsigned char *rgb_buf, int len)
d1088 3
a1090 1
ab_yuv_to_rgb(unsigned char *rgb_buf, unsigned char *yuv_buf, int len)
@


11.11.2.2
log
@sync branch with HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.10
log
@Converted from K&R to ANSI C - RFH
@
text
@d60 5
a64 5
static void	ab_log(FBIO *ifp, char *str);
static int	ab_get_reply(int fd);
static int	ab_mread(int fd, register char *bufp, int n);
static void	ab_yuv_to_rgb(unsigned char *rgb_buf, unsigned char *yuv_buf, int len);
static void	ab_rgb_to_yuv(unsigned char *yuv_buf, unsigned char *rgb_buf, int len);
d67 12
a78 12
_LOCAL_ int	ab_open(register FBIO *ifp, register char *file, int width, int height),
		ab_close(FBIO *ifp),
		ab_clear(FBIO *ifp, unsigned char *bgpp),
		ab_read(register FBIO *ifp, int x, register int y, unsigned char *pixelp, int count),
		ab_write(register FBIO *ifp, int x, int y, const unsigned char *pixelp, int count),
		ab_rmap(register FBIO *ifp, register ColorMap *cmap),
		ab_wmap(register FBIO *ifp, register ColorMap *cmap),
		ab_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
		ab_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom),
		ab_cursor(FBIO *ifp, int mode, int x, int y),
		ab_getcursor(FBIO *ifp, int *mode, int *x, int *y),
		ab_help(FBIO *ifp);
d191 4
a194 1
ab_open(register FBIO *ifp, register char *file, int width, int height)
d342 3
a344 1
static void ab_log(FBIO *ifp, char *str)
d368 2
a369 1
ab_readframe(FBIO *ifp)
d401 2
a402 1
ab_close(FBIO *ifp)
d444 3
a446 1
ab_clear(FBIO *ifp, unsigned char *bgpp)
d476 6
a481 1
ab_read(register FBIO *ifp, int x, register int y, unsigned char *pixelp, int count)
d538 5
a542 1
ab_write(register FBIO *ifp, int x, int y, const unsigned char *pixelp, int count)
d598 4
a601 1
ab_cursor(FBIO *ifp, int mode, int x, int y)
d611 4
a614 1
ab_getcursor(FBIO *ifp, int *mode, int *x, int *y)
d624 4
a627 1
ab_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
d637 4
a640 1
ab_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom)
d648 3
a650 1
ab_rmap(register FBIO *ifp, register ColorMap *cmap)
d663 3
a665 1
ab_wmap(register FBIO *ifp, register ColorMap *cmap)
d675 2
a676 1
ab_help(FBIO *ifp)
d714 7
a720 7
ab_yuvio(int output, char *host, char *buf, int len, int frame, int to_network)
   	       		/* 0=read(input), 1=write(output) */
    	      
    	     
   	    
   	      		/* frame number */
   	           
d931 2
a932 1
ab_get_reply(int fd)
d973 4
a976 1
ab_mread(int fd, register char *bufp, int n)
d1037 4
a1040 1
ab_rgb_to_yuv(unsigned char *yuv_buf, unsigned char *rgb_buf, int len)
d1088 3
a1090 1
ab_yuv_to_rgb(unsigned char *rgb_buf, unsigned char *yuv_buf, int len)
@


11.9
log
@Mac OS X warning and error fixes for non-production build
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ab.c,v 11.8 2001/08/11 13:11:15 butler Exp $ (BRL)";
d60 5
a64 5
static void	ab_log();
static int	ab_get_reply();
static int	ab_mread();
static void	ab_yuv_to_rgb();
static void	ab_rgb_to_yuv();
d67 12
a78 12
_LOCAL_ int	ab_open(),
		ab_close(),
		ab_clear(),
		ab_read(),
		ab_write(),
		ab_rmap(),
		ab_wmap(),
		ab_view(),
		ab_getview(),
		ab_cursor(),
		ab_getcursor(),
		ab_help();
d191 1
a191 4
ab_open( ifp, file, width, height )
register FBIO	*ifp;
register char	*file;
int		width, height;
d339 1
a339 3
static void ab_log(ifp, str)
FBIO	*ifp;
char	*str;
d363 1
a363 2
ab_readframe(ifp)
FBIO	*ifp;
d395 1
a395 2
ab_close( ifp )
FBIO	*ifp;
d437 1
a437 3
ab_clear( ifp, bgpp )
FBIO		*ifp;
unsigned char	*bgpp;
d467 1
a467 6
ab_read( ifp, x, y, pixelp, count )
register FBIO	*ifp;
int		x;
register int	y;
unsigned char	*pixelp;
int		count;
d524 1
a524 5
ab_write( ifp, x, y, pixelp, count )
register FBIO	*ifp;
int		x, y;
const unsigned char	*pixelp;
int		count;
d580 1
a580 4
ab_cursor( ifp, mode, x, y )
FBIO	*ifp;
int	mode;
int	x, y;
d590 1
a590 4
ab_getcursor( ifp, mode, x, y )
FBIO	*ifp;
int	*mode;
int	*x, *y;
d600 1
a600 4
ab_view( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	xcenter, ycenter;
int	xzoom, yzoom;
d610 1
a610 4
ab_getview( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	*xcenter, *ycenter;
int	*xzoom, *yzoom;
d618 1
a618 3
ab_rmap( ifp, cmap )
register FBIO		*ifp;
register ColorMap	*cmap;
d631 1
a631 3
ab_wmap( ifp, cmap )
register FBIO		*ifp;
register ColorMap	*cmap;
d641 1
a641 2
ab_help( ifp )
FBIO	*ifp;
d679 7
a685 7
ab_yuvio( output, host, buf, len, frame, to_network )
int	output;		/* 0=read(input), 1=write(output) */
char	*host;
char	*buf;
int	len;
int	frame;		/* frame number */
int	to_network;
d896 1
a896 2
ab_get_reply(fd)
int	fd;
d937 1
a937 4
ab_mread(fd, bufp, n)
int	fd;
register char	*bufp;
int	n;
d998 1
a998 4
ab_rgb_to_yuv( yuv_buf, rgb_buf, len )
unsigned char *yuv_buf;
unsigned char *rgb_buf;
int	len;
d1046 1
a1046 3
ab_yuv_to_rgb( rgb_buf, yuv_buf, len )
unsigned char *rgb_buf;
unsigned char *yuv_buf;
@


11.8
log
@Misc compiler warning changes
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ab.c,v 11.7 2001/04/20 22:29:14 morrison Exp $ (BRL)";
d33 5
d43 5
@


11.7
log
@CONST to const
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ab.c,v 11.6 2000/07/25 17:49:50 butler Exp $ (BRL)";
d889 1
a889 1
		if( sscanf( xmit_buf, "C%o %d", &perm, &src_size ) != 2 )  {
@


11.6
log
@Added include of unistd.h to get warning-free compile
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ab.c,v 11.5 2000/07/12 01:33:30 cjohnson Exp $ (BRL)";
d531 1
a531 1
CONST unsigned char	*pixelp;
d535 1
a535 1
	register CONST unsigned char	*cp;
@


11.5
log
@LINT from gcc -Wall.  Including some mods to h/pkg.h
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ab.c,v 11.4 1998/06/27 04:29:15 mike Exp $ (BRL)";
d27 1
@


11.4
log
@Additions to LIBFB interface and remote framebuffer protocol to
read and write monochrome rectangles.
Particularly important for sending thermal images at high speed.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ab.c,v 11.3 1996/08/27 06:22:33 mike Exp $ (BRL)";
d30 1
d36 1
d54 1
d702 1
@


11.3
log
@SunOS4.1.4 declaration problem.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ab.c,v 11.2 1996/07/10 15:17:53 jra Exp mike $ (BRL)";
d82 2
d311 1
a311 1
		sprintf(message,"ab_open %d*%d xoff=%d yoff=%d",
@


11.2
log
@Fixed some function declarations ab_yuv_to_rgb() and ab_rgb_to_yuv().
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ab.c,v 11.1 1995/01/04 09:52:47 mike Rel4_4 jra $ (BRL)";
d1019 1
a1019 1
void
d1070 1
a1070 1
void
@


11.1
log
@Release_4.4
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ab.c,v 10.12 94/12/30 03:57:36 mike Exp $ (BRL)";
d50 2
a52 1

d1019 1
d1070 1
@


10.12
log
@DEC Alpha
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ab.c,v 10.11 94/11/04 05:02:17 mike Exp Locker: mike $ (BRL)";
@


10.11
log
@Irix 6
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ab.c,v 10.10 94/10/21 19:32:46 mike Exp Locker: mike $ (BRL)";
d565 1
a565 1
		bcopy( cp, &ifp->if_rgb[((y+yoff)*720+(x+xoff))*3],
@


10.10
log
@ANSI quieting
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ab.c,v 10.9 94/10/19 21:14:27 mike Exp Locker: mike $ (BRL)";
d329 1
a329 1
	long		now;
@


10.9
log
@Cleaned up ANSI division
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ab.c,v 10.8 94/08/12 20:24:26 gdurf Exp Locker: mike $ (BRL)";
d1088 1
a1088 1
			u = ((double)(*yuvp++ - 128)) * (255.0/224.0);
d1090 2
a1091 2
		y = ((double)(*yuvp++ - 16)) * (255.0/219.0);
		v = ((double)(*yuvp++ - 128)) * (255.0/224.0);
d1098 1
a1098 1
		y = ((double)(*yuvp++ - 16)) * (255.0/219.0);
d1100 1
a1100 1
			u = ((double)(*yuvp++ - 128)) * (255.0/224.0);
@


10.8
log
@Added includes
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ab.c,v 10.7 1994/08/09 12:57:45 gdurf Exp gdurf $ (BRL)";
d1088 1
a1088 1
			u = (*yuvp++ - 128.0) * 255.0/224.0;
d1090 2
a1091 2
		y = (*yuvp++ - 16.0) * 255.0/219.0;
		v = (*yuvp++ - 128.0) * 255.0/224.0;
d1098 1
a1098 1
		y = (*yuvp++ - 16.0) * 255.0/219.0;
d1100 1
a1100 1
			u = (*yuvp++ - 128.0) * 255.0/224.0;
@


10.7
log
@Factored ifdefs
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ab.c,v 10.6 1993/12/17 02:25:43 mike Exp gdurf $ (BRL)";
a31 1
#define _BSD_TYPES		/* Needed for IRIX 5.0.1 */
d42 2
@


10.6
log
@Added support for YUV files with no frame number included.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ab.c,v 10.5 93/10/22 20:23:17 mike Exp Locker: mike $ (BRL)";
d24 2
d37 3
a39 1
#ifdef BSD
a40 2
#else
#include <string.h>
@


10.5
log
@IRIX 5.0.1 hack
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ab.c,v 10.4 93/09/25 08:47:20 mike Exp Locker: mike $ (BRL)";
d711 4
a714 1
		sprintf( xmit_buf, "%s%d.yuv", host, frame );
@


10.4
log
@Converted to new fb.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ab.c,v 10.3 93/09/24 19:40:08 mike Exp Locker: mike $ (BRL)";
d30 1
@


10.3
log
@fb_null_setcursor()
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ab.c,v 10.2 93/01/06 23:02:11 mike Exp Locker: mike $ (BRL)";
d425 1
a425 1
RGBpixel	*bgpp;
d435 3
a437 3
		r = (*bgpp)[RED];
		g = (*bgpp)[GRN];
		b = (*bgpp)[BLU];
d459 1
a459 1
RGBpixel	*pixelp;
d520 1
a520 1
RGBpixel	*pixelp;
d524 1
a524 1
	register char		*cp;
d550 1
a550 1
	cp = (char *)(pixelp);
d562 2
a563 2
			scan_count*3 );
		cp += scan_count * 3;
@


10.2
log
@Added "f" option, to write into a file.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ab.c,v 10.1 91/10/12 06:37:21 mike Rel4_0 Locker: mike $ (BRL)";
d72 1
a72 1
	fb_null,			/* setcursor */
@


10.1
log
@Release_4.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ab.c,v 1.19 91/09/23 20:36:23 butler Exp $ (BRL)";
d128 4
d148 2
d229 7
a235 2
			fb_log("ab_open: hostname not given and ABEKAS environment variable not set\n");
			return(-1);
d245 9
a253 3
		if( i >= 50*30 )  {
			fb_log("ab_open: frame %d out of range\n", i);
			return(-1);
a254 3
		if( i < 0 ) {
			fb_log("ab_open: frame < 0, using frame store\n");
		}
d354 3
a356 1
	    720*486*2, ifp->if_frame ) != 720*486*2 )  {
d399 5
a403 2
		    720*486*2, ifp->if_frame ) != 720*486*2 )  {
			fb_log("ab_close: unable to send frame to A60!\n");
d692 1
a692 1
ab_yuvio( output, host, buf, len, frame )
d698 1
d708 23
@


1.19
log
@changed cast of 2nd arg to bind() and connect() to be (struct sockaddr *)
instead of (char *) since Convex complained.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ab.c,v 1.18 91/07/26 22:40:58 mike Exp $ (BRL)";
@


1.18
log
@Added if_magic field, and FB_CK_FBIO() macro, to allow checking
FBIO pointers
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ab.c,v 1.17 90/12/11 22:32:57 phil Exp $ (BRL)";
d717 1
a717 1
	if( bind(netfd, (char *)&sinme, sizeof(sinme)) < 0 )  {
d722 1
a722 1
	if( connect(netfd, (char *)&sinhim, sizeof(sinhim)) < 0 )  {
@


1.17
log
@if_ struct changes.  See fb.h.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ab.c,v 1.16 90/11/08 00:03:56 phil Exp $ (BRL)";
d62 1
d174 1
@


1.16
log
@Added ability to use temporary frame store if no frame number is given.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ab.c,v 1.15 90/11/07 21:30:19 phil Exp $ (BRL)";
d55 2
a56 2
		ab_window(),
		ab_zoom(),
d58 1
a63 1
	fb_null,			/* reset */
d69 2
a70 3
	fb_null,			/* viewport */
	ab_window,
	ab_zoom,
d73 1
a73 1
	fb_null,			/* scursor */
d76 1
d86 1
d88 3
d561 2
d569 1
a569 1
ab_window( ifp, x, y )
d571 2
a572 1
int	x, y;
d574 2
d582 1
a582 1
ab_zoom( ifp, x, y )
d584 2
a585 1
int	x, y;
d587 2
d592 2
d595 11
d1022 3
a1024 1
	register double	y, u, v;
@


1.15
log
@Fixed bug in writing non-full-width offset images (was clipping)
Make non-output-only always preread if not cleared first.
Printf typo and comment tweak.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ab.c,v 1.14 90/11/04 02:44:51 mike Exp $ (BRL)";
d223 1
a223 1
	ifp->if_frame = 1;		/* default */
d228 1
a228 1
		if( i < 0 || i >= 50*30 )  {
d232 3
d312 9
a320 3
	fb_log("%2.2d:%2.2d:%2.2d %s frame %d: %s\n",
		tmp->tm_hour, tmp->tm_min, tmp->tm_sec,
		ifp->if_host, ifp->if_frame, str );
d622 5
a626 1
	fb_log( "Frame: %d\n", ifp->if_frame );
d628 1
d724 4
a727 1
		sprintf( xmit_buf, "rcp -t %d.yuv", frame );
d736 4
a739 1
		sprintf( xmit_buf, "C0664 %d %d.yuv\n", len, frame );
d771 4
a774 1
		sprintf( xmit_buf, "rcp -f %d.yuv", frame );
@


1.14
log
@Eliminated stray newlines
@
text
@a6 6
 *  Normal (non output-only) behavior depends on
 *  what the first operation of the caller is.
 *  If first op is a read, then Abekas is read.
 *  If first op is a full width write at scanline 0, the Abekas is NOT read.
 *  If first op is some other write, the Abekas is read first.
 *
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ab.c,v 1.14 90/11/04 01:17:04 mike Exp $ (BRL)";
d266 1
d281 1
a281 1
		sprintf(message,"ab_open %x*%d xoff=%d yoff=%d",
a453 2
	x += xoff;
	y += yoff;
d466 2
a467 1
		bcopy( &ifp->if_rgb[(y*720+x)*3], cp, scan_count*3 );
a470 1
		x = xoff;
d472 2
a473 2
		if( ++y >= ifp->if_height )
			break;
d502 2
a503 4
	 *  If nothing has been written yet, and nothing has been
	 *  read yet, and this does not seem to
	 *  be a "well behaved" sequential write, read the frame first.
	 *  Otherwise, just clear the frame to black.
d507 2
a508 7
		if( x != 0 || y != 0 || count < ifp->if_width )  {
	    		/* Read in the frame first */
			(void)ab_readframe(ifp);
		} else {
			/* Assume "well behaved": clear to black and proceed */
			(void)ab_clear( ifp, PIXEL_NULL );
		}
a514 2
	x += xoff;
	y += yoff;
d527 2
a528 1
		bcopy( cp, &ifp->if_rgb[(y*720+x)*3], scan_count*3 );
a531 1
		x = xoff;
d533 2
a534 2
		if( ++y >= ifp->if_height )
			break;
d884 2
a885 2
/*  A 4:2:2 framestore uses 2 bytes per pixel.  The even bytes (from 0)
 *  hold Cb and Y, the odd bytes Cr and Y.  Thus a scan line has:
d890 2
a891 2
 *  Y:      16 .. 235 range, offset by 16
 *  U, V: -112 .. +112 range, centered on 128
@


1.13
log
@ *  Normal (non output-only) behavior depends on
 *  what the first operation of the caller is.
 *  If first op is a read, then Abekas is read.
 *  If first op is a full width write at scanline 0, the Abekas is NOT read.
 *  If first op is some other write, the Abekas is read first.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ab.c,v 1.11 90/10/15 23:14:44 phil Exp $ (BRL)";
d286 1
a286 1
		sprintf(message,"ab_open %x*%d offset=%d,%d\n",
d290 1
a290 1
		sprintf(message,"ab_open %d*%d\n",
@


1.12
log
@Fixed problem with "centering" of image.
Needed to add size defaulting & range checking code.
Also changed ab_open to force frame to black in "output only" mode.
@
text
@d7 6
a275 4
	/* If not in output-only mode, read the frame first */
	if( (ifp->if_mode & MODE_2MASK) == MODE_2READFIRST )  {
		if( ab_readframe(ifp) < 0 )  return(-1);
	}
d516 2
a517 2
		if( x != 0 || y != 0 )  {
	    		/* Try to read in the frame */
d520 1
a520 1
			/* Just clear to black and proceed */
@


1.11
log
@Make output-only mode start the frame as black.  Useful for offsetting
pictures into the frame buffer without leaving crud in the background.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ab.c,v 1.10 89/11/23 02:49:32 mike Exp $ (BRL)";
d166 1
d245 12
d275 7
a281 1
	ab_log(ifp, "ab_open");
d283 10
d507 4
a510 3
	 *  If "output-only" mode was set and this is the first
	 *  time we have written anything, then clear the frame
	 *  to black.
d514 7
a520 1
		(void)ab_clear( ifp, PIXEL_NULL );
@


1.10
log
@As it turns out, the SGI 4D release 3.2 assembler couldn't deal
with this code in it's previous form, so I optimized the CLIP()
macro a bit.  Now it is happier, and probably faster too.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: if_ab.c,v 1.9 89/11/23 02:02:40 mike Locked $ (BRL)";
d478 3
a480 3
	 *  If "output-only" mode was set and this does not seem to
	 *  be a "well behaved" sequential write, read the frame first.
	 *  Otherwise, just 
d484 1
a484 7
		if( x != 0 || y != 0 )  {
	    		/* Try to read in the frame */
			(void)ab_readframe(ifp);
		} else {
			/* Just clear to black and proceed */
			(void)ab_clear( ifp, PIXEL_NULL );
		}
@


1.9
log
@Removed all the OLDTCP gunk, which no longer works at all on
Crays running UNICOS 5.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: if_ab.c,v 1.8 89/09/01 01:37:39 mike Locked $ (BRL)";
d881 4
a884 1
#define	CLIP(v)		(v<0?0:v>255?255:v)
a955 4
	int	pixel;
	double	y, u, v;
	double	r, g, b;

d958 3
d962 1
a962 1
	/*  uy  vy  uy  vy  */
d966 4
a969 3
	for( pixel = len/2; pixel; pixel-- ) {
		/* even pixel */
		if( pixel == len/2 ) {
d975 3
a977 3
		r = y + 1.4026 * v;		/* R */
		g = y - 0.3444 * u -0.7144 * v;	/* G */
		b = y + 1.7730 * u;		/* B */
a978 4
		*rgbp++ = CLIP(r);
		*rgbp++ = CLIP(g);
		*rgbp++ = CLIP(b);

d985 3
a987 7
		r = y + 1.4026 * v;		/* R */
		g = y - 0.3444 * u -0.7144 * v;	/* G */
		b = y + 1.7730 * u;		/* B */

		*rgbp++ = CLIP(r);
		*rgbp++ = CLIP(g);
		*rgbp++ = CLIP(b);
@


1.8
log
@fb_flush and fb_free.  Name changes.  static modeflags.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: if_ab.c,v 1.7 89/08/09 19:47:56 phil Locked $ (BRL)";
a630 1
	unsigned long		addr_tmp;
a643 4
#if CRAY && OLDTCP
		addr_tmp = inet_addr(host);
		sinhim.sin_addr = addr_tmp;
#else
a644 1
#endif
d651 1
a651 6
		bcopy(hp->h_addr, (char *)&addr_tmp, hp->h_length);
#		if CRAY && OLDTCP
			sinhim.sin_addr = addr_tmp;
#		else
			sinhim.sin_addr.s_addr = addr_tmp;
#		endif
@


1.7
log
@cleaner and faster RGB to YUV converter.  also fixes image shifting problem.
@
text
@d4 2
a5 3
 *  Communicate with an Abekas A60 digital videodisk as if
 *  it was a framebuffer, to ease the task of loading and storing
 *  images.
a6 1
 *
a18 2
 *
 *	$Header: if_ab.c,v 1.6 89/07/28 03:29:44 phil Locked $ (BRL)
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: if_ab.c,v 1.6 89/07/28 03:29:44 phil Locked $ (BRL)";
a46 2
extern int	fb_sim_readrect(),
		fb_sim_writerect();
d48 10
a57 11

_LOCAL_ int	ab_dopen(),
		ab_dclose(),
		ab_dclear(),
		ab_bread(),
		ab_bwrite(),
		ab_cmread(),
		ab_cmwrite(),
		ab_window_set(),
		ab_zoom_set(),
		ab_cmemory_addr(),
d61 14
a74 14
	ab_dopen,
	ab_dclose,
	fb_null,			/* reset		*/
	ab_dclear,
	ab_bread,
	ab_bwrite,
	ab_cmread,
	ab_cmwrite,
	fb_null,			/* viewport_set		*/
	ab_window_set,
	ab_zoom_set,
	fb_null,			/* curs_set		*/
	ab_cmemory_addr,
	fb_null,			/* cursor_move_screen_addr */
d77 2
d127 1
a127 1
struct modeflags {
d144 1
a144 1
 *			A B _ D O P E N
d159 1
a159 1
ab_dopen( ifp, file, width, height )
d171 1
a171 1
		fb_log( "ab_dopen: NULL device string\n" );
d176 1
a176 1
		fb_log("ab_dopen: bad device '%s'\n", file );
d191 1
a191 1
			fb_log("ab_dopen: unknown option '%c' ignored\n", *cp);
d211 1
a211 1
		fb_log("ab_dopen: error in file spec '%s'\n", cp);
d216 1
a216 1
			fb_log("ab_dopen: hostname not given and ABEKAS environment variable not set\n");
d228 1
a228 1
			fb_log("ab_dopen: frame %d out of range\n", i);
d233 1
a233 1
		fb_log("ab_dopen: error in file spec '%s'\n", cp);
d240 1
a240 1
		fb_log("ab_dopen: unable to malloc buffer\n");
d320 1
a320 1
 *			A B _ D C L O S E
d323 1
a323 1
ab_dclose( ifp )
d343 1
a343 1
			fb_log("ab_dclose: unable to send frame to A60!\n");
d355 1
a355 1
	ab_log(ifp, "ab_dclose");
d360 1
a360 1
 *			A B _ D C L E A R
d363 1
a363 1
ab_dclear( ifp, bgpp )
d392 1
a392 1
 *			A B _ B R E A D
d395 1
a395 1
ab_bread( ifp, x, y, pixelp, count )
d416 1
a416 1
			fb_log("ab_bread:  WARNING out-only mode set & pixels were written.  Subsequent read operation is unsafe\n");
d456 1
a456 1
 *			A B _ B W R I T E
d459 1
a459 1
ab_bwrite( ifp, x, y, pixelp, count )
d489 1
a489 1
			(void)ab_dclear( ifp, PIXEL_NULL );
d527 1
a527 1
ab_cmemory_addr( ifp, mode, x, y )
d538 1
a538 1
ab_window_set( ifp, x, y )
d548 1
a548 1
ab_zoom_set( ifp, x, y )
d556 1
a556 1
ab_cmread( ifp, cmap )
d571 1
a571 1
ab_cmwrite( ifp, cmap )
@


1.6
log
@Added verbose flag, and ab_log().
@
text
@d22 1
a22 1
 *	$Header: if_ab.c,v 1.5 89/07/27 05:18:44 mike Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_ab.c,v 1.5 89/07/27 05:18:44 mike Locked $ (BRL)";
d889 3
a893 1
#define	VSET(v,a,b,c)	{v[0] = a; v[1] = b; v[2] = c;}
a895 1
#define	SHIFTUP(v,n)	{v[4]=v[3]; v[3]=v[2]; v[2]=v[1]; v[1]=v[0]; v[0]=n;}
d910 3
a912 1
static double	y_buf[5], u_buf[5], v_buf[5];
d914 1
a914 3

/*
 */
d920 2
a921 6
	int	pixel;
	double	rgb[3];
	double	y, u, v;
	unsigned char tmp;
	register unsigned char *rgbp;
	register unsigned char *yuvp;
d935 11
a945 2
	for( i=0; i<5; i++ )
		y_buf[i] = u_buf[i] = v_buf[i] = 0;
d947 14
a960 32
	rgbp = rgb_buf;
	yuvp = yuv_buf;
	for( pixel = len/2; pixel; pixel-- ) {
		/*
		 * first pixel gives Y and both chroma
		 */
		VSET( rgb, *rgbp++, *rgbp++, *rgbp++ );

		y = VDOT( y_weights, rgb );
		SHIFTUP( y_buf, y );
		u = VDOT( u_weights, rgb );
		SHIFTUP( u_buf, u );
		v = VDOT( v_weights, rgb );
		SHIFTUP( v_buf, v );

		*yuvp++ = V5DOT(u_filter,u_buf) + 128.0;
		*yuvp++ = V5DOT(y_filter,y_buf) + 16.0;
		*yuvp++ = V5DOT(v_filter,v_buf) + 128.0;

		/*
		 * second pixel just yields a Y
		 */
		VSET( rgb, *rgbp++, *rgbp++, *rgbp++ );

		y = VDOT( y_weights, rgb );
		SHIFTUP( y_buf, y );
		u = VDOT( u_weights, rgb );
		SHIFTUP( u_buf, u );
		v = VDOT( v_weights, rgb );
		SHIFTUP( v_buf, v );

		*yuvp++ = V5DOT(y_filter,y_buf) + 16.0;
a963 1

a964 14
/*  A 4:2:2 framestore uses 2 bytes per pixel.  The even bytes (from 0)
 *  hold Cb and Y, the odd bytes Cr and Y.  Thus a scan line has:
 *      Cb Y Cr Y Cb Y Cr Y ...
 *  If we are at an even pixel, we use the Cr value following it.  If
 *  we are at an odd pixel, we use the Cb value following it.
 *
 *  Y:      16 .. 235 range, offset by 16
 *  U, V: -112 .. +112 range, centered on 128
 *
 *  Ideas:
 *    Premultiply filter by final multiplier
 *    Add final range shift before floor.  Then it's all >0 so floor = (int)
 *    Don't bother normallizing before filtering.
 */
@


1.5
log
@This version incorporates Phil's YUV to RGB conversion.
@
text
@d22 1
a22 1
 *	$Header: if_ab.c,v 1.4 89/07/27 03:56:06 mike Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_ab.c,v 1.4 89/07/27 03:56:06 mike Locked $ (BRL)";
d31 1
d47 1
d124 4
d142 2
d267 2
d273 21
d302 1
d311 1
a311 1
fb_log("Converting YUV to RGB\n");
d318 1
a318 1
fb_log("Conversion done\n");
d337 1
a337 1
fb_log("Converting RGB to YUV\n");
d344 1
a344 1
fb_log("Conversion done\n");
d351 1
d360 1
@


1.4
log
@Faster filter
@
text
@d22 1
a22 1
 *	$Header: if_ab.c,v 1.3 89/07/27 03:24:35 mike Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_ab.c,v 1.3 89/07/27 03:24:35 mike Locked $ (BRL)";
d111 2
d115 2
a116 2
#define MODE_1LOWERLEFT	(0<<0)
#define MODE_1CENTER	(1<<0)
d122 3
d132 2
a133 2
	{ 'c',	MODE_1MASK, MODE_1CENTER,
		"Center;  default=lower-left " },
a138 3
#define STATE_FRAME_WAS_READ	(1<<8)
#define STATE_USER_HAS_READ	(1<<9)
#define STATE_USER_HAS_WRITTEN	(1<<10)
a139 1

d269 2
d279 8
a286 1
fb_log("Unable to convert YUV to RGB, gak\n");
d305 1
a305 1
fb_log("Starting conversion\n");
d312 1
a319 1
fb_log("Conversion done\n");
a341 2
fb_log("ab_dclear\n");
	/* send a clear package to remote */
d608 1
a608 1
		fprintf(stderr,"getservbyname(shell,tcp) fail\n");
d624 1
a624 1
			fprintf(stderr,"gethostbyname(%s) fail\n", host);
a692 1
fprintf(stderr,"before write\n");
a696 1
fprintf(stderr,"after write, did %d\n", got);
d700 1
a700 1
			fprintf(stderr,"go-ahead write got %d\n", got);
d705 1
a705 1
			fprintf(stderr,"get_reply got %d\n", got);
d740 1
a740 1
				fprintf(stderr,"cmd buffer overrun\n");
d748 1
a748 1
			fprintf(stderr,"sscanf error\n");
a758 1
fprintf(stderr,"before ab_mread\n");
d760 1
a760 1
			fprintf(stderr,"ab_mread len=%d, got %d\n", len, got );
a762 1
fprintf(stderr,"after ab_mread, got %d\n", got);
d787 1
a787 1
		fprintf(stderr,"ab_get_reply() read error\n");
d792 1
a792 1
		fprintf(stderr,"ab_get_reply() unexpected EOF\n");
d801 1
a801 1
		fprintf(stderr,"ab_get_reply() error reply code, no attached message\n");
d806 1
a806 1
	fprintf(stderr,"ab_get_reply() error='%s'\n", &rep_buf[1] );
d862 1
d877 1
a888 1

d891 2
a892 1
	static int first=1;
a894 1
		register int i;
d904 3
d939 63
@


1.3
log
@The "center" mode now works.
@
text
@d22 1
a22 1
 *	$Header: if_ab.c,v 1.2 89/07/27 03:01:28 mike Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_ab.c,v 1.2 89/07/27 03:01:28 mike Locked $ (BRL)";
a290 1
fb_log("ab_dclose, state=x%x\n", ifp->if_mode);
d309 1
a446 1
fb_log("Initial check, x=%d, y=%d\n", x, y );
a450 1
fb_log("clear to black\n");
d884 3
a886 2
	unsigned char *rgbp;
	unsigned char *yuvp;
d888 11
d905 1
a905 1
		VSET( rgb, *rgbp++/255.0, *rgbp++/255.0, *rgbp++/255.0 );
d914 3
a916 3
		u = V5DOT(u_filter,u_buf);
		y = V5DOT(y_filter,y_buf);
		v = V5DOT(v_filter,v_buf);
a917 9
		u *= 224.0;			/* -112 .. +112 range */
		*yuvp++ = floor(u) + 128;	/* centered on 128 */

		y *= 219.0;			/* 16 .. 235 range */
		*yuvp++ = floor(y) + 16;	/* offset by 16 */

		v *= 224.0;			/* -112 .. +112 range */
		*yuvp++ = floor(v) + 128;	/* centered on 128 */

d921 1
a921 1
		VSET( rgb, *rgbp++/255.0, *rgbp++/255.0, *rgbp++/255.0 );
d930 1
a930 4
		/* only filter a Y */
		y = V5DOT(y_filter,y_buf);
		y *= 219.0;			/* 16 .. 235 range */
		*yuvp++ = floor(y) + 16;	/* offset by 16 */
@


1.2
log
@This version works for output only.
@
text
@d22 1
a22 1
 *	$Header: if_ab.c,v 1.1 89/07/27 00:49:09 mike Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_ab.c,v 1.1 89/07/27 00:49:09 mike Locked $ (BRL)";
d101 1
a101 1
#define if_mode		u2.l		/* see MODE_ defines */
d104 2
a105 2
#define if_state	u5.l		/* see STATE_ defines */
#define if_host		u6.p		/* Hostname */
d134 3
a136 3
#define STATE_FRAME_WAS_READ	(1<<1)
#define STATE_USER_HAS_READ	(1<<2)
#define STATE_USER_HAS_WRITTEN	(1<<3)
d240 12
a251 1
	/* X and Y offsets if centering & non-full size? */
d253 1
a253 1
	ifp->if_state = 0;
d278 1
a278 1
	ifp->if_state |= STATE_FRAME_WAS_READ;
d291 2
a292 2
fb_log("ab_dclose, state=x%x\n", ifp->if_state);
	if( ifp->if_state & STATE_USER_HAS_WRITTEN )  {
d350 1
a350 1
	ifp->if_state |= STATE_USER_HAS_WRITTEN;
d368 1
a368 1
	int			ybase;
d377 2
a378 2
	if( (ifp->if_state & STATE_FRAME_WAS_READ) == 0 )  {
		if( (ifp->if_state & STATE_USER_HAS_WRITTEN) != 0 )  {
d387 3
d391 2
a392 1
	ybase = y;
d409 1
a409 1
		x = 0;
d414 1
a414 1
	ifp->if_state |= STATE_USER_HAS_READ;
d431 1
a431 1
	int			ybase;
d445 2
a446 2
	if( (ifp->if_state & STATE_FRAME_WAS_READ) == 0 &&
	    (ifp->if_state & STATE_USER_HAS_WRITTEN) == 0 )  {
d458 3
d462 2
a463 1
	ybase = y;
d480 1
a480 1
		x = 0;
d485 1
a485 1
	ifp->if_state |= STATE_USER_HAS_WRITTEN;
d741 1
a741 2
		/* buffer will contain old permission, ??? (size, old name) */
		fprintf(stderr,"got '%s'\n", xmit_buf);
@


1.1
log
@Initial revision
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 9.1 89/05/19 05:48:03 mike Rel3_5 $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 9.1 89/05/19 05:48:03 mike Rel3_5 $ (BRL)";
d30 1
d102 2
a103 2
#define if_yuv		u3.p		/* buffer for YUV format image */
#define if_rgb		u4.p		/* buffer for RGB format image */
d265 1
d280 1
d282 1
d285 7
d321 1
d325 1
a325 1
		bzero( ifp->if_rgb, 720*484*3 );
d332 1
a332 1
		for( count = 720*484-1; count >= 0; count-- )  {
d347 1
a347 1
ab_bread( ifp, x, y, pixelp, num )
d352 1
a352 1
int		num;
a355 1
	int			count;
d359 1
a359 1
	if( num <= 0 )
d407 1
a407 1
ab_bwrite( ifp, x, y, pixelp, num )
d411 1
a411 1
int		num;
a414 1
	int			count;
d418 1
a418 1
	if( num <= 0 )
d432 1
d437 1
d521 2
a522 1
	return(-1);
d668 2
a669 1
		if( write( netfd, buf, len ) != len )  {
d673 1
d676 2
a677 2
fprintf(stderr,"before write\n");
		if( write( netfd, "\0", 1 ) != 1 )  {
d681 4
a684 2
fprintf(stderr,"after write\n");
		if( ab_get_reply(netfd) < 0 )  goto err;
d687 1
a687 1
		return(0);		/* OK */
d742 1
a742 1
fprintf(stderr,"after ab_mread\n");
d750 1
a750 1
		return(0);		/* OK */
d767 1
d822 94
@
