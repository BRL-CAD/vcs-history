head	11.5;
access;
symbols
	ansi-20040405-merged:11.2.6.1
	postmerge-20040405-ansi:11.3
	premerge-20040404-ansi:11.3
	postmerge-autoconf:11.3
	autoconf-freeze:11.2.14.2
	premerge-autoconf:11.3
	ansi-20040316-freeze:11.2
	postmerge-20040315-windows:11.3
	premerge-20040315-windows:11.3
	windows-20040315-freeze:11.2.8.1
	autoconf-20031203:11.2
	autoconf-20031202:11.2
	autoconf-branch:11.2.0.14
	phong-branch:11.2.0.12
	photonmap-branch:11.2.0.10
	rel-6-1-DP:11.2
	windows-branch:11.2.0.8
	rel-6-0-2:11.2
	ansi-branch:11.2.0.6
	rel-6-0-1-branch:11.2.0.4
	hartley-6-0-post:11.2
	hartley-6-0-pre:11.2
	rel-6-0-1:11.2
	rel-6-0:11.2
	rel-5-4:11.2
	offsite-5-3-pre:11.2
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.8
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.5
date	2004.05.21.18.07.25;	author morrison;	state dead;
branches;
next	11.4;

11.4
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	11.3;

11.3
date	2004.02.02.17.39.12;	author morrison;	state Exp;
branches;
next	11.2;

11.2
date	98.06.27.04.29.17;	author mike;	state Exp;
branches
	11.2.6.1
	11.2.8.1
	11.2.14.1;
next	11.1;

11.1
date	95.01.04.09.53.00;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.12.20.25.39;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.37.28;	author mike;	state Rel4_0;
branches;
next	9.6;

9.6
date	91.10.11.08.54.57;	author butler;	state Exp;
branches;
next	9.5;

9.5
date	91.07.26.22.41.11;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	91.07.19.02.22.09;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.12.11.22.50.55;	author phil;	state Exp;
branches;
next	9.2;

9.2
date	89.09.01.01.45.33;	author phil;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.48.06;	author mike;	state Rel3_5;
branches;
next	8.4;

8.4
date	89.05.12.20.07.59;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.05.04.04.58.07;	author phil;	state Exp;
branches;
next	8.2;

8.2
date	89.03.03.05.54.40;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.27.43;	author mike;	state Rel3_0;
branches;
next	7.2;

7.2
date	88.09.09.23.50.49;	author phil;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.26.51;	author mike;	state Rel;
branches;
next	6.2;

6.2
date	87.09.16.03.49.02;	author phil;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.51.39;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.21.51.44;	author mike;	state Rel;
branches;
next	4.8;

4.8
date	87.02.12.22.06.43;	author mike;	state Exp;
branches;
next	4.7;

4.7
date	87.01.17.02.06.37;	author mike;	state Exp;
branches;
next	4.6;

4.6
date	87.01.13.00.49.01;	author phil;	state Exp;
branches;
next	4.5;

4.5
date	87.01.08.11.37.29;	author moss;	state Exp;
branches;
next	4.4;

4.4
date	87.01.07.11.07.58;	author moss;	state Exp;
branches;
next	4.3;

4.3
date	87.01.05.17.28.28;	author moss;	state Exp;
branches;
next	4.2;

4.2
date	87.01.04.03.36.17;	author mike;	state Rel1;
branches;
next	4.1;

4.1
date	86.12.29.03.42.58;	author mike;	state Rel1;
branches;
next	1.48;

1.48
date	86.12.29.01.21.51;	author mike;	state Exp;
branches;
next	1.47;

1.47
date	86.12.24.04.19.00;	author mike;	state Exp;
branches;
next	1.46;

1.46
date	86.12.20.06.02.32;	author mike;	state Exp;
branches;
next	1.45;

1.45
date	86.12.20.04.32.03;	author mike;	state Exp;
branches;
next	1.44;

1.44
date	86.12.20.02.30.40;	author mike;	state Exp;
branches;
next	1.43;

1.43
date	86.12.19.23.50.58;	author mike;	state Exp;
branches;
next	1.42;

1.42
date	86.12.10.17.05.03;	author mike;	state Exp;
branches;
next	1.41;

1.41
date	86.12.10.05.55.05;	author mike;	state Exp;
branches;
next	1.40;

1.40
date	86.12.10.01.30.28;	author mike;	state Exp;
branches;
next	1.39;

1.39
date	86.12.10.00.38.46;	author mike;	state Exp;
branches;
next	1.38;

1.38
date	86.12.09.22.59.10;	author mike;	state Exp;
branches;
next	1.37;

1.37
date	86.12.09.05.50.36;	author mike;	state Exp;
branches;
next	1.36;

1.36
date	86.12.09.04.42.20;	author mike;	state Exp;
branches;
next	1.35;

1.35
date	86.12.01.09.02.37;	author mike;	state Exp;
branches;
next	1.34;

1.34
date	86.12.01.06.51.36;	author mike;	state Exp;
branches;
next	1.33;

1.33
date	86.11.29.05.20.23;	author mike;	state Exp;
branches;
next	1.32;

1.32
date	86.11.28.23.23.47;	author mike;	state Exp;
branches;
next	1.31;

1.31
date	86.11.28.22.04.26;	author mike;	state Exp;
branches;
next	1.30;

1.30
date	86.11.28.21.06.21;	author mike;	state Exp;
branches;
next	1.29;

1.29
date	86.11.25.04.10.48;	author mike;	state Exp;
branches;
next	1.28;

1.28
date	86.11.25.04.01.14;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	86.11.25.03.18.00;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	86.11.21.01.16.22;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	86.11.18.13.13.53;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	86.11.18.12.59.03;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	86.11.17.20.28.11;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	86.11.17.20.20.42;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	86.11.14.04.36.17;	author phil;	state Exp;
branches;
next	1.20;

1.20
date	86.10.29.01.37.27;	author phil;	state Exp;
branches;
next	1.19;

1.19
date	86.10.28.19.53.55;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	86.10.28.17.57.21;	author phil;	state Exp;
branches;
next	1.17;

1.17
date	86.10.28.15.32.11;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	86.10.25.19.04.44;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	86.10.25.16.20.51;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	86.10.25.10.54.56;	author phil;	state Exp;
branches;
next	1.13;

1.13
date	86.10.24.04.22.11;	author phil;	state Exp;
branches;
next	1.12;

1.12
date	86.10.24.03.39.29;	author phil;	state Exp;
branches;
next	1.11;

1.11
date	86.10.11.22.47.23;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	86.10.11.01.07.54;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	86.10.10.22.48.19;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	86.10.06.22.44.20;	author phil;	state Exp;
branches;
next	1.7;

1.7
date	86.10.06.21.26.21;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	86.10.03.22.59.08;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	86.10.03.22.28.46;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	86.10.03.13.11.12;	author stay;	state Exp;
branches;
next	1.3;

1.3
date	86.10.03.06.14.51;	author stay;	state Exp;
branches;
next	1.2;

1.2
date	86.10.03.06.03.36;	author stay;	state Exp;
branches;
next	1.1;

1.1
date	86.10.03.06.00.12;	author mike;	state Exp;
branches;
next	;

11.2.6.1
date	2004.03.17.21.17.02;	author morrison;	state Exp;
branches;
next	;

11.2.8.1
date	2004.03.11.23.42.07;	author morrison;	state Exp;
branches;
next	;

11.2.14.1
date	2004.02.12.19.48.12;	author erikg;	state Exp;
branches;
next	11.2.14.2;

11.2.14.2
date	2004.03.15.14.06.20;	author erikg;	state Exp;
branches;
next	;


desc
@Silicon Graphics IRIS interface
@


11.5
log
@moved to src/
@
text
@/*
 *			I F _ S G I . C
 *
 *  SGI display interface.  By default, we operate in 24-bit (RGB) mode.
 *  However, when running under MEX, 12-bit mode is utilized (actually,
 *  only 10 bits are available, thanks to MEX).  Several flavors of
 *  MEX operation are defined, either a best-fit color match, or
 *  a pre-defined colorspace.  Each has advantages and disadvantages.
 *
 *  In order to simulate the behavior of a real framebuffer, even
 *  when using the limited color map for display, an entire image
 *  worth of memory is saved using SysV shared memory.  This image
 *  exists across invocations of frame buffer utilities, and allows
 *  the full resolution of an image to be retained, and captured,
 *  even with the 10x10x10 color cube display.
 *
 *  In order to use this large a chunk of memory with the shared memory
 *  system, it is necessary to "poke" your kernel to authorize this.
 *  In the shminfo structure, change shmmax from 0x10000 to 0x250000,
 *  shmall from 0x40 to 0x258, and tcp spaces from 2000 to 4000 by running:
 *
 *	adb -w -k /vmunix
 *	shminfo?W 250000
 *	shminfo+0x14?W 258
 *	tcp_sendspace?W 4000
 *	tcp_recvspace?W 4000
 *
 *  Note that these numbers are for release 3.5;  other versions
 *  may vary.
 *
 *  Authors -
 *	Paul R. Stay
 *	Gary S. Moss
 *	Michael John Muuss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 *
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libfb/if_sgi.c,v 11.4 2004/05/10 15:30:45 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <ctype.h>
#include <errno.h>
#include <gl.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <gl2/immed.h>
#undef RED

#include "machine.h"
#include "externs.h"
#include "fb.h"
#include "./fblocal.h"

/*
 *  Defines for dealing with SGI Graphics Engine Pipeline
 */
union gepipe {
	unsigned short us;
	short	s;
	long	l;
	float	f;
};

/**#define MC_68010 xx	/* not a turbo */
#ifdef MC_68010
#define GE	(0X00FD5000)		/* Not a turbo */
#else
#define GE	(0X60001000)		/* A turbo */
#endif
#define GEPIPE	((union gepipe *)GE)
#define GEP_END(p)	((union gepipe *)(((char *)p)-0x1000))	/* 68000 efficient 0xFd4000 */

#define CMOV2S(_p,_x,_y) { \
		PASSCMD( _p, 0, FBCcharposnabs ); \
		(_p)->s = GEpoint | GEPA_2S; \
		(_p)->s = (_x); \
		(_p)->s = (_y); \
		}

#define PASSCMD(p, n, cmd)	{(p)->l = ((GEpassthru|((n)<<8))<<16)|(cmd); }

static Cursor	cursor =
	{
#include "./sgicursor.h"
	};

_LOCAL_ int	sgi_open(),
		sgi_close(),
		sgi_clear(),
		sgi_read(),
		sgi_write(),
		sgi_rmap(),
		sgi_wmap(),
		sgi_view(),
		sgi_setcursor(),
		sgi_cursor(),
		sgi_poll(),
		sgi_help();

/* This is the ONLY thing that we "export" */
FBIO sgi_interface =
		{
		0,
		sgi_open,
		sgi_close,
		sgi_clear,
		sgi_read,
		sgi_write,
		sgi_rmap,
		sgi_wmap,
		sgi_view,
		fb_sim_getview,
		sgi_setcursor,		/* define cursor */
		sgi_cursor,		/* set cursor */
		fb_sim_getcursor,	/* get cursor */
		fb_sim_readrect,
		fb_sim_writerect,
		fb_sim_bwreadrect,
		fb_sim_bwwriterect,
		sgi_poll,		/* poll */
		fb_null,		/* flush */
		sgi_close,		/* free */
		sgi_help,
		"Silicon Graphics IRIS",
		1024,			/* max width */
		768,			/* max height */
		"/dev/sgi",
		1024,			/* current/default width  */
		768,			/* current/default height */
		-1,			/* select fd */
		-1,			/* file descriptor */
		1, 1,			/* zoom */
		512, 384,		/* window center */
		0, 0, 0,		/* cursor */
		PIXEL_NULL,		/* page_base */
		PIXEL_NULL,		/* page_curp */
		PIXEL_NULL,		/* page_endp */
		-1,			/* page_no */
		0,			/* page_ref */
		0L,			/* page_curpos */
		0L,			/* page_pixels */
		0			/* debug */
		};


/* Interface to the 12-bit window version */
int		sgw_dopen();

_LOCAL_ Colorindex get_Color_Index();
_LOCAL_ void	sgw_inqueue();
_LOCAL_ void	sgi_rectf_pix();
static int	is_linear_cmap();

struct sgi_cmap {
	unsigned char	cmr[256];
	unsigned char	cmg[256];
	unsigned char	cmb[256];
};

/*
 *  Per SGI (window or device) state information
 *  Too much for just the if_u[1-6] area now.
 */
struct sgiinfo {
	short	si_curs_on;
	int	si_rgb_ct;
	short	si_cmap_flag;
	int	si_shmid;
};
#define	SGI(ptr)	((struct sgiinfo *)((ptr)->u1.p))
#define	SGIL(ptr)	((ptr)->u1.p)		/* left hand side version */
#define if_mem		u2.p			/* shared memory pointer */
#define if_cmap		u3.p			/* color map in shared memory */
#define CMR(x)		((struct sgi_cmap *)((x)->if_cmap))->cmr
#define CMG(x)		((struct sgi_cmap *)((x)->if_cmap))->cmg
#define CMB(x)		((struct sgi_cmap *)((x)->if_cmap))->cmb
#define if_zoomflag	u4.l			/* zoom > 1 */
#define if_mode		u5.l			/* see MODE_* defines */

/* Define current display operating mode */
#define MODE_RGB	0		/* 24-bit mode */
#define MODE_APPROX	1		/* color cube approximation */
#define MODE_FIT	2		/* Best-fit mode */

/* Map RGB onto 10x10x10 color cube, giving index in range 0..999 */
#define COLOR_APPROX(p)	\
	(((p)[RED]/26)+ ((p)[GRN]/26)*10 + ((p)[BLU]/26)*100 + MAP_RESERVED)
/***
#define COLOR_APPROX(p)	\
	(((((((((p)[BLU])*10)+((p)[GRN]))*10)+((p)[RED]))*10)>>8)+MAP_RESERVED)
***/


#define Abs( x_ )	((x_) < 0 ? -(x_) : (x_))

#define MARGIN	4			/* # pixels margin to screen edge */
#define BANNER	18			/* Size of MEX title banner */
#define WIN_L	(1024-ifp->if_width-MARGIN)
#define WIN_R	(1024-1-MARGIN)
#define WIN_B	MARGIN
#define WIN_T	(ifp->if_height-1+MARGIN)

#define MAP_RESERVED	16		/* # slots reserved by MEX */
#define MAP_TOL		15		/* pixel delta across all channels */

static int map_size;			/* # of color map slots available */

static RGBpixel	rgb_table[4096];

/*
 *			S G I _ G E T M E M
 *
 *  Because there is no hardware zoom or pan, we need to repaint the
 *  screen (with big pixels) to implement these operations.
 *  This means that the actual "contents" of the frame buffer need
 *  to be stored somewhere else.  If possible, we allocate a shared
 *  memory segment to contain that image.  This has several advantages,
 *  the most important being that when operating the display in 12-bit
 *  output mode, pixel-readbacks still give the full 24-bits of color.
 *  System V shared memory persists until explicitly killed, so this
 *  also means that in MEX mode, the previous contents of the frame
 *  buffer still exist, and can be again accessed, even though the
 *  MEX windows are transient, per-process.
 * 
 *  There are a few oddities, however.  The worst is that System V will
 *  not allow the break (see sbrk(2)) to be set above a shared memory
 *  segment, and shmat(2) does not seem to allow the selection of any
 *  reasonable memory address (like 6 Mbytes up) for the shared memory.
 *  In the initial version of this routine, that prevented subsequent
 *  calls to malloc() from succeeding, quite a drawback.  The work-around
 *  used here is to increase the current break to a large value,
 *  attach to the shared memory, and then return the break to it's
 *  original value.  This should allow most reasonable requests for
 *  memory to be satisfied.  In special cases, the values used here
 *  might need to be increased.
 */
_LOCAL_ int
sgi_getmem( ifp )
FBIO	*ifp;
{
#define SHMEM_KEY	42
	int	pixsize;
	int	size;
	int	i;
	char	*old_brk;
	char	*new_brk;
	char	*sp;
	int	new = 0;

	/* The shared memory section never changes size */
	errno = 0;
	pixsize = 1024 * 768 * sizeof(RGBpixel);
	size = pixsize + sizeof(struct sgi_cmap);
	size = (size + 4096-1) & ~(4096-1);
	/* First try to attach to an existing one */
	if( (SGI(ifp)->si_shmid = shmget( SHMEM_KEY, size, 0 )) < 0 )  {
		/* No existing one, create a new one */
		if( (SGI(ifp)->si_shmid = shmget(
		    SHMEM_KEY, size, IPC_CREAT|0666 )) < 0 )  {
			fb_log("if_sgi: shmget failed, errno=%d\n", errno);
			goto fail;
		}
		new = 1;
	}

	/* Move up the existing break, to leave room for later malloc()s */
	old_brk = sbrk(0);
	new_brk = (char *)(6 * 1024 * 1024);
	if( new_brk <= old_brk )
		new_brk = old_brk + 1024 * 1024;
	new_brk = (char *)((((int)new_brk) + 4096-1) & ~(4096-1));
	if( brk( new_brk ) < 0 )  {
		fb_log("new brk(x%x) failure, errno=%d\n", new_brk, errno);
		goto fail;
	}

	/* Open the segment Read/Write, near the current break */
	if( (sp = shmat( SGI(ifp)->si_shmid, 0, 0 )) == (char *)(-1) )  {
		fb_log("shmat returned x%x, errno=%d\n", sp, errno );
		goto fail;
	}

	/* Restore the old break */
	if( brk( old_brk ) < 0 )  {
		fb_log("restore brk(x%x) failure, errno=%d\n", old_brk, errno);
		/* Take the memory and run */
	}

success:
	ifp->if_mem = sp;
	ifp->if_cmap = sp + pixsize;	/* cmap at end of area */

	/* Provide non-black colormap on creation of new shared mem */
	if(new)
		sgi_wmap( ifp, COLORMAP_NULL );
	return(0);
fail:
	fb_log("sgi_getmem:  Unable to attach to shared memory.\nConsult comment in cad/libfb/if_sgi.c for details\n");
	if( (sp = malloc( size )) == NULL )  {
		fb_log("sgi_getmem:  malloc failure\n");
		return(-1);
	}
	new = 1;
	goto success;
}

/*
 *			S G I _ Z A P M E M
 */
void
sgi_zapmem()
{
	int shmid;
	int i;

	if( (shmid = shmget( SHMEM_KEY, 0, 0 )) < 0 )  {
		fb_log("sgi_zapmem shmget failed, errno=%d\n", errno);
		return;
	}

	i = shmctl( shmid, IPC_RMID, 0 );
	if( i < 0 )  {
		fb_log("sgi_zapmem shmctl failed, errno=%d\n", errno);
		return;
	}
	fb_log("if_sgi: shared memory released\n");
}

/*
 *			S G I _ R E P A I N T
 *
 *  Given the current window center, and the current zoom,
 *  repaint the screen from the shared memory buffer,
 *  which stores RGB pixels.
 */
_LOCAL_ int
sgi_repaint( ifp )
register FBIO	*ifp;
{
	register union gepipe *hole = GEPIPE;
	short xmin, xmax;
	short ymin, ymax;
	register short i;
	register unsigned char *ip;
	short y;
	short xscroff, yscroff, xscrpad, yscrpad;
	short xwidth;
	static RGBpixel black = { 0, 0, 0 };

	if( SGI(ifp)->si_curs_on )
		cursoff();		/* Cursor interferes with drawing */

	xscroff = yscroff = 0;
	xscrpad = yscrpad = 0;
	xwidth = ifp->if_width/ifp->if_xzoom;
	i = xwidth/2;
	xmin = ifp->if_xcenter - i;
	xmax = ifp->if_xcenter + i - 1;
	i = (ifp->if_height/2)/ifp->if_yzoom;
	ymin = ifp->if_ycenter - i;
	ymax = ifp->if_ycenter + i - 1;
	if( xmin < 0 )  {
		xscroff = -xmin * ifp->if_xzoom;
		xmin = 0;
	}
	if( ymin < 0 )  {
		yscroff = -ymin * ifp->if_yzoom;
		ymin = 0;
	}
	if( xmax > ifp->if_width-1 )  {
		xscrpad = (xmax-(ifp->if_width-1))*ifp->if_xzoom;
		xmax = ifp->if_width-1;
	}
	if( ymax > ifp->if_height-1 )  {
		yscrpad = (ymax-(ifp->if_height-1))*ifp->if_yzoom;
		ymax = ifp->if_height-1;
	}

	/* Blank out area left of image.			*/
	if( xscroff > 0 )
		sgi_rectf_pix(	ifp,
				0, 0,
				(Scoord) xscroff-1, (Scoord) ifp->if_height-1,
				(RGBpixel *) black
				);
	/* Blank out area below image.			*/
	if( yscroff > 0 )
		sgi_rectf_pix(	ifp,
				0, 0,
				(Scoord) ifp->if_width-1, (Scoord) yscroff-1,
				(RGBpixel *) black
				);
	/* Blank out area right of image.			*/
	if( xscrpad > 0 )
		sgi_rectf_pix(	ifp,
				(Scoord) ifp->if_width-xscrpad,
				0,
				(Scoord) ifp->if_width-1,
				(Scoord) ifp->if_height-1,
				(RGBpixel *) black
				);
	/* Blank out area above image.			*/
	if( yscrpad > 0 )
		sgi_rectf_pix(	ifp,
				0,
				(Scoord) ifp->if_height-yscrpad,
				(Scoord) ifp->if_width-1,
				(Scoord) ifp->if_height-1,
				(RGBpixel *) black
				);
	for( y = ymin; y <= ymax; y++ )  {

		ip = (unsigned char *)
			&ifp->if_mem[(y*1024+xmin)*sizeof(RGBpixel)];

		if( ifp->if_zoomflag )  {
			register Scoord l, b, r, t;

			l = xscroff;
			b = yscroff + (y-ymin)*ifp->if_yzoom;
			t = b + ifp->if_yzoom - 1;
			if ( SGI(ifp)->si_cmap_flag == FALSE )  {
				for( i=xwidth; i > 0; i--)  {
					switch( ifp->if_mode ) {
					case MODE_RGB:
						PASSCMD(hole,3,FBCrgbcolor);
						hole->s = (ip[RED]);
						hole->s = (ip[GRN]);
						hole->s = (ip[BLU]);
						break;
					case MODE_FIT:
						PASSCMD(hole,1,FBCcolor);
						hole->s = get_Color_Index( ifp, ip );
						break;
					case MODE_APPROX:
						PASSCMD(hole,1,FBCcolor);
						hole->s = COLOR_APPROX(ip);
						break;
					}
					r = l + ifp->if_xzoom - 1;
					/* left bottom right top: rectfs( l, b, r, t ); */
					hole->s = GEmovepoly | GEPA_2S;
					hole->s = l;
					hole->s = b;
					hole->s = GEdrawpoly | GEPA_2S;
					hole->s = r;
					hole->s = b;
					hole->s = GEdrawpoly | GEPA_2S;
					hole->s = r;
					hole->s = t;
					hole->s = GEdrawpoly | GEPA_2S;
					hole->s = l;
					hole->s = t;
					hole->s = GEclosepoly;	/* Last? */
					l = r + 1;
					ip += sizeof(RGBpixel);
				}
				continue;
			} else {
				for( i=xwidth; i > 0; i--)  {
					static RGBpixel new;

					switch( ifp->if_mode ) {
					case MODE_RGB:
						PASSCMD(hole,3,FBCrgbcolor);
						hole->s = CMR(ifp)[ip[RED]];
						hole->s = CMG(ifp)[ip[GRN]];
						hole->s = CMB(ifp)[ip[BLU]];
						break;
					case MODE_FIT:
						new[RED] = CMR(ifp)[ip[RED]];
						new[GRN] = CMG(ifp)[ip[GRN]];
						new[BLU] = CMB(ifp)[ip[BLU]];
						PASSCMD(hole,1,FBCcolor);
						hole->s = get_Color_Index( ifp, new );
						break;
					case MODE_APPROX:
						new[RED] = CMR(ifp)[ip[RED]];
						new[GRN] = CMG(ifp)[ip[GRN]];
						new[BLU] = CMB(ifp)[ip[BLU]];
						PASSCMD(hole,1,FBCcolor);
						hole->s = COLOR_APPROX(new);
						break;
					}
					r = l + ifp->if_xzoom - 1;
					/* left bottom right top: rectfs( l, b, r, t ); */
					hole->s = GEmovepoly | GEPA_2S;
					hole->s = l;
					hole->s = b;
					hole->s = GEdrawpoly | GEPA_2S;
					hole->s = r;
					hole->s = b;
					hole->s = GEdrawpoly | GEPA_2S;
					hole->s = r;
					hole->s = t;
					hole->s = GEdrawpoly | GEPA_2S;
					hole->s = l;
					hole->s = t;
					hole->s = GEclosepoly;	/* Last? */
					l = r + 1;
					ip += sizeof(RGBpixel);
				}
				continue;
			}
		}

		/* Non-zoomed case */
		CMOV2S( hole, xscroff, yscroff + (y-ymin) );

		switch( ifp->if_mode )  {
		case MODE_RGB:
			if ( SGI(ifp)->si_cmap_flag == FALSE )  {
				for( i=xwidth; i > 0; )  {
					register short chunk;

					if( i <= (127/3) )
						chunk = i;
					else
						chunk = 127/3;
					PASSCMD(hole, chunk*3, FBCdrawpixels);
					i -= chunk;
					for( ; chunk>0; chunk--)  {
						hole->us = *ip++;
						hole->us = *ip++;
						hole->us = *ip++;
					}
				}
			} else {
				for( i=xwidth; i > 0; )  {
					register short chunk;

					if( i <= (127/3) )
						chunk = i;
					else
						chunk = 127/3;
					PASSCMD(hole, chunk*3, FBCdrawpixels);
					i -= chunk;
					for( ; chunk>0; chunk--)  {
						hole->s = CMR(ifp)[*ip++];
						hole->s = CMG(ifp)[*ip++];
						hole->s = CMB(ifp)[*ip++];
					}
				}
			}
			break;
		case MODE_FIT:
			if ( SGI(ifp)->si_cmap_flag == FALSE )  {
				for( i=xwidth; i > 0; )  {
					register short chunk;

					if( i <= 127 )
						chunk = i;
					else
						chunk = 127;
					PASSCMD(hole, chunk, FBCdrawpixels);
					i -= chunk;
					for( ; chunk > 0; chunk--, ip += sizeof(RGBpixel) )  {
						hole->s = get_Color_Index( ifp, ip );
					}
				}
			} else {
				for( i=xwidth; i > 0; )  {
					register short chunk;

					if( i <= 127 )
						chunk = i;
					else
						chunk = 127;
					PASSCMD(hole, chunk, FBCdrawpixels);
					i -= chunk;
					for( ; chunk > 0; chunk-- )  {
						static RGBpixel new;
						new[RED] = CMR(ifp)[*ip++];
						new[GRN] = CMG(ifp)[*ip++];
						new[BLU] = CMB(ifp)[*ip++];
						hole->s = get_Color_Index( ifp, new );
					}
				}
			}
			break;
		case MODE_APPROX:
			if ( SGI(ifp)->si_cmap_flag == FALSE )  {
				for( i=xwidth; i > 0; )  {
					register short chunk;

					if( i <= 127 )
						chunk = i;
					else
						chunk = 127;
					PASSCMD(hole, chunk, FBCdrawpixels);
					i -= chunk;
					for( ; chunk > 0; chunk--, ip += sizeof(RGBpixel) )  {
						hole->s = COLOR_APPROX(ip);
					}
				}
			} else {
				for( i=xwidth; i > 0; )  {
					register short chunk;

					if( i <= 127 )
						chunk = i;
					else
						chunk = 127;
					PASSCMD(hole, chunk, FBCdrawpixels);
					i -= chunk;
					for( ; chunk > 0; chunk-- )  {
						static RGBpixel new;
						new[RED] = CMR(ifp)[*ip++];
						new[GRN] = CMG(ifp)[*ip++];
						new[BLU] = CMB(ifp)[*ip++];
						hole->s = COLOR_APPROX(new);
					}
				}
			}
			break;
		}
	}
	GEP_END(hole)->s = (0xFF<<8)|8;	/* im_last_passthru(0) */
	if( SGI(ifp)->si_curs_on )
		curson();		/* Cursor interferes with reading! */
}

/*
 *			S G I _ D O P E N
 */
_LOCAL_ int
sgi_open( ifp, file, width, height )
FBIO	*ifp;
char	*file;
int	width, height;
{
	int x_pos, y_pos;	/* Lower corner of viewport */
	register int i;
	
	FB_CK_FBIO(ifp);

	if( file != NULL )  {
		register char *cp;
		int mode;

		/* "/dev/sgi###" gives optional mode */
		for( cp = file; *cp != '\0' && !isdigit(*cp); cp++ ) ;
		mode = 0;
		if( *cp && isdigit(*cp) )
			(void)sscanf( cp, "%d", &mode );
		if( mode >= 99 )  {
			/* Attempt to release shared memory segment */
			sgi_zapmem();
			return(-1);
		}
		if( mode != 0 )
			return( sgw_dopen( ifp, file, width, height ) );
	}

	if( ismex() )  {
		return( sgw_dopen( ifp, file, width, height ) );
	}
	gbegin();		/* not ginit() */
	RGBmode();
	gconfig();
	if( getplanes() < 24 )  {
		singlebuffer();
		gconfig();
		return( sgw_dopen( ifp, file, width, height ) );
	}
	tpoff();		/* Turn off textport */
	cursoff();

	blanktime( 67 * 60 * 60L );	/* 1 hour blanking when fb open */

	if( width <= 0 )
		width = ifp->if_width;
	if( height <= 0 )
		height = ifp->if_height;
	if ( width > ifp->if_max_width) 
		width = ifp->if_max_width;

	if ( height > ifp->if_max_height) 
		height = ifp->if_max_height;

	ifp->if_width = width;
	ifp->if_height = height;

	if( (SGIL(ifp) = (char *)calloc( 1, sizeof(struct sgiinfo) )) == NULL )  {
		fb_log("sgi_open:  sgiinfo malloc failed\n");
		return(-1);
	}
	SGI(ifp)->si_shmid = -1;	/* indicate no shared memory */

	/* Must initialize these window state variables BEFORE calling
		"sgi_getmem", because this function can indirectly trigger
		a call to "sgi_repaint" (when initializing shared memory
		after a reboot).					*/
	ifp->if_zoomflag = 0;
	ifp->if_xzoom = 1;
	ifp->if_yzoom = 1;
	ifp->if_xcenter = width/2;
	ifp->if_ycenter = height/2;
	ifp->if_mode = MODE_RGB;

	if( sgi_getmem(ifp) < 0 )
		return(-1);

	/* Must call "is_linear_cmap" AFTER "sgi_getmem" which allocates
		space for the color map.				*/
	SGI(ifp)->si_cmap_flag = !is_linear_cmap(ifp);

	/* Setup default cursor.					*/
	defcursor( 1, cursor );
	curorigin( 1, 0, 0 );

	return(0);
}

/*
 *			S G I _ C L O S E
 *
 *  Finishing with a gexit() is mandatory.
 *  If we do a tpon() greset(), the text port pops up right
 *  away, spoiling the image.  Just doing the greset() causes
 *  the region of the text port to be disturbed, although the
 *  text port does not become readable.
 *
 *  Unfortunately, this means that the user has to run the
 *  "gclear" program before the screen can be used again,
 *  which is certainly a nuisance.  On the other hand, this
 *  means that images can be created AND READ BACK from
 *  separate programs, just like we do on the real framebuffers.
 */
_LOCAL_ int
sgi_close( ifp )
FBIO	*ifp;
{
	blanktime( 67 * 60 * 20L );	/* 20 minute blanking when fb closed */

	switch( ifp->if_mode )  {
	case MODE_RGB:
		gexit();
		break;
	case MODE_FIT:
	case MODE_APPROX:
		if( ismex() )  {
			winclose( ifp->if_fd );
			curson();	/* Leave mex's cursor on */
		}  else  {
			setcursor( 0, 1, 0x2000 );
			cursoff();
			greset();
			gexit();
		}
		break;
	}
	if( SGIL(ifp) != NULL ) {
		/* free up memory associated with image */
		if( SGI(ifp)->si_shmid != -1 ) {
			/* detach from shared memory */
			if( shmdt( ifp->if_mem ) == -1 ) {
				fb_log("sgi_close shmdt failed, errno=%d\n", errno);
				return -1;
			}
		} else {
			/* free private memory */
			(void)free( ifp->if_mem );
		}
		/* free state information */
		(void)free( (char *)SGIL(ifp) );
		SGIL(ifp) = NULL;
	}

	return(0);
}

/*
 *			S G I _ C L E A R
 */
_LOCAL_ int
sgi_clear( ifp, pp )
FBIO	*ifp;
register RGBpixel	*pp;
{

	if( qtest() )
		sgw_inqueue(ifp);

	if ( pp != RGBPIXEL_NULL)  {
		register char *op = ifp->if_mem;
		register int cnt;

		/* Slightly simplistic -- runover to right border */
		for( cnt=1024*ifp->if_height-1; cnt > 0; cnt-- )  {
			*op++ = (*pp)[RED];
			*op++ = (*pp)[GRN];
			*op++ = (*pp)[BLU];
		}

		switch( ifp->if_mode )  {
		case MODE_RGB:
			RGBcolor((short)((*pp)[RED]), (short)((*pp)[GRN]), (short)((*pp)[BLU]));
			break;
		case MODE_FIT:
			writemask( 0x3FF );
			color( get_Color_Index( ifp, pp ) );
			break;
		case MODE_APPROX:
			writemask( 0x3FF );
			color( COLOR_APPROX(*pp) );
			break;
		}
	} else {
		switch( ifp->if_mode )  {
		case MODE_RGB:
			RGBcolor( (short) 0, (short) 0, (short) 0);
			break;
		case MODE_FIT:
		case MODE_APPROX:
			color(BLACK);
			break;
		}
		bzero( ifp->if_mem, 1024*ifp->if_height*sizeof(RGBpixel) );
	}
	clear();
	return(0);
}

_LOCAL_ int
sgi_poll(ifp)
FBIO	*ifp;
{
	if( qtest() )
		sgw_inqueue(ifp);
}

_LOCAL_ int
sgi_view( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	xcenter, ycenter;
int	xzoom, yzoom;
{
	if( qtest() )
		sgw_inqueue(ifp);

	if( xzoom < 1 ) xzoom = 1;
	if( yzoom < 1 ) yzoom = 1;
	if( ifp->if_xcenter == xcenter && ifp->if_ycenter == ycenter
	 && ifp->if_xzoom == xzoom && ifp->if_yzoom == yzoom )
		return(0);

	if( xcenter < 0 || xcenter >= ifp->if_width )
		return(-1);
	if( ycenter < 0 || ycenter >= ifp->if_height )
		return(-1);
	if( xzoom >= ifp->if_width || yzoom >= ifp->if_height )
		return(-1);

	ifp->if_xcenter = xcenter;
	ifp->if_ycenter = ycenter;
	ifp->if_xzoom = xzoom;
	ifp->if_yzoom = yzoom;

	if( ifp->if_xzoom > 1 || ifp->if_yzoom > 1 )
		ifp->if_zoomflag = 1;
	else	ifp->if_zoomflag = 0;

	sgi_repaint( ifp );
	return(0);
}

/*
 *			S G I _ R E A D
 */
_LOCAL_ int
sgi_read( ifp, x, y, pixelp, count )
FBIO	*ifp;
int	x, y;
register RGBpixel	*pixelp;
int	count;
{
	register short scan_count;
	short xpos, ypos;
	register char *ip;
	int ret;

	if( qtest() )
		sgw_inqueue(ifp);

	if( x < 0 || x > ifp->if_width ||
	    y < 0 || y > ifp->if_height )
		return(-1);
	ret = 0;
	xpos = x;
	ypos = y;

	while( count > 0 )  {
		ip = &ifp->if_mem[(ypos*1024+xpos)*sizeof(RGBpixel)];

		if ( count >= ifp->if_width-xpos )  {
			scan_count = ifp->if_width-xpos;
		} else	{
			scan_count = count;
		}
		memcpy( *pixelp, ip, scan_count*sizeof(RGBpixel) );

		pixelp += scan_count;
		count -= scan_count;
		ret += scan_count;
		xpos = 0;
		/* Advance upwards */
		if( ++ypos >= ifp->if_height )
			break;
	}
	return(ret);
}

/*
 *			S G I _ B W R I T E
 */
_LOCAL_ int
sgi_write( ifp, xmem, ymem, pixelp, count )
FBIO	*ifp;
int	xmem, ymem;
RGBpixel *pixelp;
int	count;
{
	register union gepipe *hole = GEPIPE;
	register short scan_count;	/* # pixels on this scanline */
	int xscr, yscr;
	register int i;
	register unsigned char *cp;
	register unsigned char *op;
	int ret;
	int hfwidth = (ifp->if_width/ifp->if_xzoom)/2;
	int hfheight = (ifp->if_height/ifp->if_yzoom)/2;

	if( qtest() )
		sgw_inqueue(ifp);
	if( xmem < 0 || xmem > ifp->if_width ||
	    ymem < 0 || ymem > ifp->if_height)
		return(-1);
	if( SGI(ifp)->si_curs_on )
		cursoff();		/* Cursor interferes with writing */

	ret = 0;
	xscr = (xmem - (ifp->if_xcenter-hfwidth)) * ifp->if_xzoom;
	yscr = (ymem - (ifp->if_ycenter-hfheight)) * ifp->if_yzoom;
	cp = (unsigned char *)(*pixelp);
	while( count > 0 )  {
		if( yscr >= ifp->if_height )
			break;
		if ( count >= ifp->if_width-xmem )
			scan_count = ifp->if_width-xmem;
		else
			scan_count = count;

		op = (unsigned char *)&ifp->if_mem[(ymem*1024+xmem)*sizeof(RGBpixel)];

		if( ifp->if_zoomflag )  {
			register Scoord l, b, r, t;
			int todraw = (ifp->if_width-xscr)/ifp->if_xzoom;
			int tocopy;

			if( todraw > scan_count )  todraw = scan_count;
			tocopy = scan_count - todraw;

			l = xscr;
			b = yscr;
			t = b + ifp->if_yzoom - 1;
			for( i = todraw; i > 0; i-- )  {

				switch( ifp->if_mode )  {
				case MODE_RGB:
					PASSCMD(hole,3,FBCrgbcolor);
					if ( SGI(ifp)->si_cmap_flag == FALSE ) {
						hole->s = (cp[RED]);
						hole->s = (cp[GRN]);
						hole->s = (cp[BLU]);
					} else {
						hole->s = CMR(ifp)[cp[RED]];
						hole->s = CMG(ifp)[cp[GRN]];
						hole->s = CMB(ifp)[cp[BLU]];
					}
					break;
				case MODE_FIT:
					PASSCMD(hole,1,FBCcolor);
					if ( SGI(ifp)->si_cmap_flag == FALSE ) {
						hole->s = get_Color_Index( ifp, cp );
					} else {
						static RGBpixel new;
						new[RED] = CMR(ifp)[cp[RED]];
						new[GRN] = CMG(ifp)[cp[GRN]];
						new[BLU] = CMB(ifp)[cp[BLU]];
						hole->s = get_Color_Index( ifp, new );
					}
					break;
				case MODE_APPROX:
					PASSCMD(hole,1,FBCcolor);
					if ( SGI(ifp)->si_cmap_flag == FALSE ) {
						hole->s = COLOR_APPROX(cp);
					} else {
						static RGBpixel new;
						new[RED] = CMR(ifp)[cp[RED]];
						new[GRN] = CMG(ifp)[cp[GRN]];
						new[BLU] = CMB(ifp)[cp[BLU]];
						hole->s = COLOR_APPROX(new);
					}
					break;
				}
				r = l + ifp->if_xzoom - 1;

				/* left bottom right top: rectfs( l, b, r, t ); */
				hole->s = GEmovepoly | GEPA_2S;
				hole->s = l;
				hole->s = b;
				hole->s = GEdrawpoly | GEPA_2S;
				hole->s = r;
				hole->s = b;
				hole->s = GEdrawpoly | GEPA_2S;
				hole->s = r;
				hole->s = t;
				hole->s = GEdrawpoly | GEPA_2S;
				hole->s = l;
				hole->s = t;
				hole->s = GEclosepoly;	/* Last? */
				l = r + 1;

				*op++ = *cp++;
				*op++ = *cp++;
				*op++ = *cp++;
			}
			for( i = tocopy; i > 0; i-- )  {
				*op++ = *cp++;
				*op++ = *cp++;
				*op++ = *cp++;
			}				
			count -= scan_count;
			ret += scan_count;
			xmem = 0;
			ymem++;
			xscr = (hfwidth-ifp->if_xcenter) *
				ifp->if_xzoom;
			yscr += ifp->if_yzoom;
			continue;
		}
		/* Non-zoomed case */
		CMOV2S( hole, xscr, yscr );

		switch( ifp->if_mode )  {
		case MODE_RGB:
			if ( SGI(ifp)->si_cmap_flag == FALSE )  {
				for( i=scan_count; i > 0; )  {
					register short chunk;

					if( i <= (127/3) )
						chunk = i;
					else
						chunk = 127/3;
					PASSCMD(hole, chunk*3, FBCdrawpixels);
					i -= chunk;
					for( ; chunk>0; chunk--)  {
						hole->us = (*op++ = *cp++);
						hole->us = (*op++ = *cp++);
						hole->us = (*op++ = *cp++);
					}
				}
			} else {
				for( i=scan_count; i > 0; )  {
					register short chunk;

					if( i <= (127/3) )
						chunk = i;
					else
						chunk = 127/3;
					PASSCMD(hole, chunk*3, FBCdrawpixels);
					i -= chunk;
					for( ; chunk>0; chunk-- )  {
						hole->s = CMR(ifp)[
							*op++ = *cp++];
						hole->s = CMG(ifp)[
							*op++ = *cp++];
						hole->s = CMB(ifp)[
							*op++ = *cp++];
					}
				}
			}
			break;
		case MODE_FIT:
			if ( SGI(ifp)->si_cmap_flag == FALSE )  {
				for( i = scan_count; i > 0; )  {
					register short	chunk;
					if( i <= 127 )
						chunk = i;
					else
						chunk = 127;
					PASSCMD(hole, chunk, FBCdrawpixels);
					i -= chunk;
					for( ; chunk > 0; chunk--, pixelp++ )  {
						hole->s = get_Color_Index( ifp, pixelp );
						*op++ = (*pixelp)[RED];
						*op++ = (*pixelp)[GRN];
						*op++ = (*pixelp)[BLU];
					}
				}
			} else {
				for( i = scan_count; i > 0; )  {
					register short	chunk;
					if( i <= 127 )
						chunk = i;
					else
						chunk = 127;
					PASSCMD(hole, chunk, FBCdrawpixels);
					i -= chunk;
					for( ; chunk > 0; chunk--, pixelp++ )  {
						static RGBpixel new;
						new[RED] = CMR(ifp)[
							*op++ = (*pixelp)[RED]];
						new[GRN] = CMG(ifp)[
							*op++ = (*pixelp)[GRN]];
						new[BLU] = CMB(ifp)[
							*op++ = (*pixelp)[BLU]];
						hole->s = get_Color_Index(ifp,new);
					}
				}
			}
		case MODE_APPROX:
			if ( SGI(ifp)->si_cmap_flag == FALSE )  {
				for( i = scan_count; i > 0; )  {
					register short	chunk;
					if( i <= 127 )
						chunk = i;
					else
						chunk = 127;
					PASSCMD(hole, chunk, FBCdrawpixels);
					i -= chunk;
					for( ; chunk > 0; chunk--, pixelp++ )  {
						hole->s = COLOR_APPROX(*pixelp);
						*op++ = (*pixelp)[RED];
						*op++ = (*pixelp)[GRN];
						*op++ = (*pixelp)[BLU];
					}
				}
			} else {
				for( i = scan_count; i > 0; )  {
					register short	chunk;
					if( i <= 127 )
						chunk = i;
					else
						chunk = 127;
					PASSCMD(hole, chunk, FBCdrawpixels);
					i -= chunk;
					for( ; chunk > 0; chunk--, pixelp++ )  {
						static RGBpixel new;
						new[RED] = CMR(ifp)[
							*op++ = (*pixelp)[RED]];
						new[GRN] = CMG(ifp)[
							*op++ = (*pixelp)[GRN]];
						new[BLU] = CMB(ifp)[
							*op++ = (*pixelp)[BLU]];
						hole->s = COLOR_APPROX(new);
					}
				}
			}
		}

		count -= scan_count;
		ret += scan_count;
		xmem = 0;
		ymem++;
		xscr = ifp->if_xcenter - hfwidth;
		yscr++;
	}
	GEP_END(hole)->s = (0xFF<<8)|8;	/* im_last_passthru(0) */
	if( SGI(ifp)->si_curs_on )
		curson();		/* Cursor interferes with writing */
	return(ret);
}

/*
 *			S G I _ C M R E A D
 */
_LOCAL_ int
sgi_rmap( ifp, cmp )
register FBIO	*ifp;
register ColorMap	*cmp;
{
	register int i;

	if( qtest() )
		sgw_inqueue(ifp);

	/* Just parrot back the stored colormap */
	for( i = 0; i < 256; i++)
	{
		cmp->cm_red[i] = CMR(ifp)[i]<<8;
		cmp->cm_green[i] = CMG(ifp)[i]<<8;
		cmp->cm_blue[i] = CMB(ifp)[i]<<8;
	}
	return(0);
}

/*
 *			I S _ L I N E A R _ C M A P
 *
 *  Check for a color map being linear in R, G, and B.
 *  Returns 1 for linear map, 0 for non-linear map
 *  (ie, non-identity map).
 */
static int
is_linear_cmap(ifp)
register FBIO	*ifp;
{
	register int i;

	for( i=0; i<256; i++ )  {
		if( CMR(ifp)[i] != i )  return(0);
		if( CMG(ifp)[i] != i )  return(0);
		if( CMB(ifp)[i] != i )  return(0);
	}
	return(1);
}

/*
 *			 S G I _ C M W R I T E
 */
_LOCAL_ int
sgi_wmap( ifp, cmp )
register FBIO	*ifp;
register ColorMap	*cmp;
{
	register int i;

	if( qtest() )
		sgw_inqueue(ifp);

	if ( cmp == COLORMAP_NULL)  {
		for( i = 0; i < 256; i++)  {
			CMR(ifp)[i] = i;
			CMG(ifp)[i] = i;
			CMB(ifp)[i] = i;
		}
		if( SGI(ifp)->si_cmap_flag ) {
			SGI(ifp)->si_cmap_flag = FALSE;
			sgi_repaint( ifp );
		}
		SGI(ifp)->si_cmap_flag = FALSE;
		return(0);
	}
	
	for(i = 0; i < 256; i++)  {
		CMR(ifp)[i] = cmp-> cm_red[i]>>8;
		CMG(ifp)[i] = cmp-> cm_green[i]>>8; 
		CMB(ifp)[i] = cmp-> cm_blue[i]>>8;

	}
	SGI(ifp)->si_cmap_flag = !is_linear_cmap(ifp);
	sgi_repaint( ifp );
	return(0);
}

/*
 *			S G I _ C U R S _ S E T
 */
_LOCAL_ int
sgi_setcursor( ifp, bits, xbits, ybits, xorig, yorig )
FBIO	*ifp;
unsigned char	*bits;
int		xbits, ybits;
int		xorig, yorig;
{
	register int	y;
	register int	xbytes;
	Cursor		newcursor;

	if( qtest() )
		sgw_inqueue(ifp);

	/* Check size of cursor.					*/
	if( xbits < 0 )
		return	-1;
	if( xbits > 16 )
		xbits = 16;
	if( ybits < 0 )
		return	-1;
	if( ybits > 16 )
		ybits = 16;
	if( (xbytes = xbits / 8) * 8 != xbits )
		xbytes++;
	for( y = 0; y < ybits; y++ )  {
		newcursor[y] = bits[(y*xbytes)+0] << 8 & 0xFF00;
		if( xbytes == 2 )
			newcursor[y] |= bits[(y*xbytes)+1] & 0x00FF;
	}
	defcursor( 1, newcursor );
	curorigin( 1, (short) xorig, (short) yorig );
	return	0;
}

/*
 *			S G I _ C M E M O R Y _ A D D R
 */
_LOCAL_ int
sgi_cursor( ifp, mode, x, y )
FBIO	*ifp;
int	mode;
int	x, y;
{
	short	xmin, ymin;
	register short	i;
	short	xwidth;

	if( qtest() )
		sgw_inqueue(ifp);

	fb_sim_cursor(ifp,mode,x,y);
	SGI(ifp)->si_curs_on = mode;
	if( ! mode )  {
		cursoff();
		return	0;
	}
	xwidth = ifp->if_width/ifp->if_xzoom;
	i = xwidth/2;
	xmin = ifp->if_xcenter - i;
	i = (ifp->if_height/2)/ifp->if_yzoom;
	ymin = ifp->if_ycenter - i;
	x -= xmin;
	y -= ymin;
	x *= ifp->if_xzoom;
	y *= ifp->if_yzoom;
	curson();
	switch( ifp->if_mode )  {
	case MODE_RGB:
		RGBcursor( 1, 255, 255, 0, 0xFF, 0xFF, 0xFF );
		setvaluator( MOUSEX, x, 0, 1023 );
		setvaluator( MOUSEY, y, 0, 1023 );
		break;
	case MODE_APPROX:
	case MODE_FIT:
		{
			long	xwin, ywin;

		/* Color and bitmask ignored under MEX.	*/
		setcursor( 1, YELLOW, 0x2000 );
		getorigin( &xwin, &ywin );
		setvaluator( MOUSEX, (short)(x+xwin), 0, 1023 );
		setvaluator( MOUSEY, (short)(y+ywin), 0, 1023 );
		break;
		}
	}
	return	0;
}

/*
 *			g e t _ C o l o r _ I n d e x
 */
_LOCAL_ Colorindex
get_Color_Index( ifp, pixelp )
register FBIO		*ifp;
register RGBpixel	*pixelp;
{
	register int		i;
	int			best = 7;
	register RGBpixel	*sp;
	static int		groused = 0;
	register int		min_diff = 128;

	/* Find best fit in existing table */
	best = 0;
	for(	i = MAP_RESERVED, sp = (RGBpixel *)rgb_table[MAP_RESERVED];
		i < SGI(ifp)->si_rgb_ct;
		sp++, i++ ) {
		register int	diff;
		register int	d;

		d = ((int)((*pixelp)[RED])) - ((int)(*sp)[RED]);
		if( (diff = Abs(d)) >= min_diff )
			continue;
		d = ((int)((*pixelp)[GRN])) - ((int)(*sp)[GRN]);
		if( (diff += Abs(d)) >= min_diff )
			continue;
		d = ((int)((*pixelp)[BLU])) - ((int)(*sp)[BLU]);
		if( (diff += Abs(d)) >= min_diff )
			continue;

		/* [i]'th element is the best so far... */
		if( (min_diff = diff) <= 2 )  {
			/* Great match */
			return( (Colorindex)i );
		}
		best = i;
	}

	/* Match found to within tolerance? */
	if( min_diff < MAP_TOL ) 
		return	(Colorindex)best;

	/* Allocate new entry in color table if there's room.		*/
	if( i < map_size )  {
		COPYRGB( rgb_table[SGI(ifp)->si_rgb_ct], *pixelp);
		mapcolor(	(Colorindex)SGI(ifp)->si_rgb_ct,
				(short) (*pixelp)[RED],
				(short) (*pixelp)[GRN],
				(short) (*pixelp)[BLU]
				);
		return	(Colorindex)(SGI(ifp)->si_rgb_ct++);
	}

	/* No room to add, use best we found */
	if( !groused )  {
		groused = 1;
		fb_log( "Color table now full, will use closest matches.\n" );
	}
	return	(Colorindex)best;
}

#define SET(i,r,g,b)	{ \
	rgb_table[i][RED] = r; \
	rgb_table[i][GRN] = g; \
	rgb_table[i][BLU] = b; }


/*
 *			S G W _ D O P E N
 */
int
sgw_dopen( ifp, file, width, height )
FBIO	*ifp;
char	*file;
int	width, height;
{	register Colorindex i;

	if( (SGIL(ifp) = (char *)calloc( 1, sizeof(struct sgiinfo) )) == NULL )  {
		fb_log("sgw_dopen:  sgiinfo malloc failed\n");
		return(-1);
	}

	ifp->if_mode = MODE_APPROX;
	if( file != NULL )  {
		register char *cp;
		int mode;
		/* "/dev/sgi###" gives optional mode */
		for( cp = file; *cp != '\0' && !isdigit(*cp); cp++ ) ;
		mode = MODE_APPROX;
		if( isdigit(*cp) )
			(void)sscanf( cp, "%d", &mode );
		if( mode >= 99 )  {
			/* Attempt to release shared memory segment */
			sgi_zapmem();
			return(-1);
		}
		if( mode < MODE_APPROX || mode > MODE_FIT )
			mode = MODE_APPROX;
		ifp->if_mode = mode;
	}

	/* By default, pop up a 512x512 MEX window, rather than fullsize */
	if( width <= 0 )
		width = 512;
	if( height <= 0 )
		height = 512;
	if ( width > ifp->if_max_width)
		width = ifp->if_max_width;
	if ( height > ifp->if_max_height - 2 * MARGIN - BANNER)
		height = ifp->if_max_height - 2 * MARGIN - BANNER;

	ifp->if_width = width;
	ifp->if_height = height;

	if( ismex() )  {
		prefposition( WIN_L, WIN_R, WIN_B, WIN_T );
		foreground();		/* Direct focus here, don't detach */
		if( (ifp->if_fd = winopen( "Frame buffer" )) == -1 )
			{
			fb_log( "No more graphics ports available.\n" );
			return	-1;
			}
		wintitle( "BRL libfb Frame Buffer" );
		/* Free window of position constraint.		*/
		prefsize( (long)ifp->if_width, (long)ifp->if_height );
		winconstraints();
		singlebuffer();
		gconfig();	/* Must be called after singlebuffer().	*/
		/* Need to clean out images from windows below */
		/* This hack is necessary until windows persist from
		 * process to process */
		color(BLACK);
		clear();
	} else {
		ginit();
		singlebuffer();
		gconfig();	/* Must be called after singlebuffer().	*/
	}

	/* Must initialize these window state variables BEFORE calling
		"sgi_getmem", because this function can indirectly trigger
		a call to "sgi_repaint" (when initializing shared memory
		after a reboot).					*/
	ifp->if_zoomflag = 0;
	ifp->if_xzoom = 1;	/* for zoom fakeout */
	ifp->if_yzoom = 1;	/* for zoom fakeout */
	ifp->if_xcenter = width/2;
	ifp->if_ycenter = height/2;

	if( sgi_getmem(ifp) < 0 )
		return(-1);

	/* Must call "is_linear_cmap" AFTER "sgi_getmem" which allocates
		space for the color map.				*/
	SGI(ifp)->si_cmap_flag = !is_linear_cmap(ifp);

	/*
	 * Deal with the SGI hardware color map
	 */
	map_size = 1<<getplanes();	/* 10 or 12, depending on ismex() */

	/* The first 8 entries of the colormap are "known" colors */
	SET( 0, 000, 000, 000 );	/* BLACK */
	SET( 1, 255, 000, 000 );	/* RED */
	SET( 2, 000, 255, 000 );	/* GREEN */
	SET( 3, 255, 255, 000 );	/* YELLOW */
	SET( 4, 000, 000, 255 );	/* BLUE */
	SET( 5, 255, 000, 255 );	/* MAGENTA */
	SET( 6, 000, 255, 000 );	/* CYAN */
	SET( 7, 255, 255, 255 );	/* WHITE */

	SGI(ifp)->si_rgb_ct = MAP_RESERVED;
	if( ifp->if_mode == MODE_APPROX )  {
		/* Use fixed color map with 10x10x10 color cube */
		for( i = 0; i < map_size-MAP_RESERVED; i++ )
			mapcolor( 	i+MAP_RESERVED,
					(short)((i % 10) + 1) * 25,
					(short)(((i / 10) % 10) + 1) * 25,
					(short)((i / 100) + 1) * 25
					);
	}

	/* Setup default cursor.					*/
	defcursor( 1, cursor );
	curorigin( 1, 0, 0 );

	/* The screen has no useful state.  Restore it as it was before */
	/* SMART deferral logic needed */
	sgi_repaint( ifp );
	return	0;
}

/*
 *			S G W _ I N Q U E U E
 *
 *  Called when a qtest() indicates that there is a window event.
 *  Process all events, so that we don't loop on recursion to sgw_bwrite.
 */
_LOCAL_ void
sgw_inqueue(ifp)
register FBIO *ifp;
{
	short val;
	int redraw = 0;
	register int ev;

	while( qtest() )  {
		switch( ev = qread(&val) )  {
		case REDRAW:
			redraw = 1;
			break;
		case INPUTCHANGE:
			break;
		case MODECHANGE:
			/* This could be bad news.  Should we re-write
			 * the color map? */
			fb_log("sgw_inqueue:  modechange?\n");
			break;
		case MOUSEX :
		case MOUSEY :
		case KEYBD :
			break;
		default:
			fb_log("sgw_inqueue:  event %d unknown\n", ev);
			break;
		}
	}
	/*
	 * Now that all the events have been removed from the input
	 * queue, handle any actions that need to be done.
	 */
	if( redraw )  {
		sgi_repaint( ifp );
		redraw = 0;
	}
}

_LOCAL_ void
sgi_rectf_pix( ifp, l, b, r, t, pixelp )
FBIO		*ifp;
Scoord		l, b, r, t;
RGBpixel	*pixelp;
{
	register union gepipe *hole = GEPIPE;

	switch( ifp->if_mode ) {
	case MODE_RGB:
		PASSCMD(hole,3,FBCrgbcolor);
		hole->s = (*pixelp)[RED];
		hole->s = (*pixelp)[GRN];
		hole->s = (*pixelp)[BLU];
		break;
	case MODE_FIT:
		PASSCMD(hole,1,FBCcolor);
		hole->s = get_Color_Index( ifp, pixelp );
		break;
	case MODE_APPROX:
		PASSCMD(hole,1,FBCcolor);
		hole->s = COLOR_APPROX(*pixelp);
		break;
	}
	/* left bottom right top: rectfs( l, b, r, t ); */
	hole->s = GEmovepoly | GEPA_2S;
	hole->s = l;
	hole->s = b;
	hole->s = GEdrawpoly | GEPA_2S;
	hole->s = r;
	hole->s = b;
	hole->s = GEdrawpoly | GEPA_2S;
	hole->s = r;
	hole->s = t;
	hole->s = GEdrawpoly | GEPA_2S;
	hole->s = l;
	hole->s = t;
	hole->s = GEclosepoly;	/* Last? */
	return;
}

_LOCAL_ int
sgi_help( ifp )
FBIO	*ifp;
{
	fb_log( "Description: %s\n", sgi_interface.if_type );
	fb_log( "Device: %s\n", ifp->if_name );
	fb_log( "Max width/height: %d %d\n",
		sgi_interface.if_max_width,
		sgi_interface.if_max_height );
	fb_log( "Default width/height: %d %d\n",
		sgi_interface.if_width,
		sgi_interface.if_height );
	fb_log( "\
Usage: /dev/sgi[#]\n\
  where # is a optional number from:\n\
    0    fixed color cube approximation (default)\n\
    1    dynamic colormap entry allocation (slower)\n\
   99    release shared memory\n" );

	return(0);
}
@


11.4
log
@change conf.h to a wrapped config.h
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/libfb/if_sgi.c,v 11.3 2004/02/02 17:39:12 morrison Exp $ (BRL)";
@


11.3
log
@update copyright to include span through 2003
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_sgi.c,v 11.2 1998/06/27 04:29:17 mike Exp $ (BRL)";
d50 5
a54 1
#include "conf.h"
@


11.2
log
@Additions to LIBFB interface and remote framebuffer protocol to
read and write monochrome rectangles.
Particularly important for sending thermal images at high speed.
@
text
@d42 1
a42 1
 *	This software is Copyright (C) 1986 by the United States Army.
d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_sgi.c,v 11.1 1995/01/04 09:53:00 mike Rel4_4 $ (BRL)";
@


11.2.6.1
log
@sync branch with HEAD
@
text
@d42 1
a42 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d47 1
a47 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.2.8.1
log
@sync to HEAD...
@
text
@d42 1
a42 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libfb/if_sgi.c,v 11.3 2004/02/02 17:39:12 morrison Exp $ (BRL)";
@


11.2.14.1
log
@merge from HEAD
@
text
@d42 1
a42 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_sgi.c,v 11.3 2004/02/02 17:39:12 morrison Exp $ (BRL)";
@


11.2.14.2
log
@merge from head
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_sgi.c,v 11.2.14.1 2004/02/12 19:48:12 erikg Exp $ (BRL)";
@


11.1
log
@Release_4.4
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_sgi.c,v 10.2 94/08/12 20:25:39 gdurf Exp $ (BRL)";
d130 2
@


10.2
log
@Added includes
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_sgi.c,v 10.1 1991/10/12 06:37:28 mike Rel4_0 gdurf $ (BRL)";
@


10.1
log
@Release_4.0
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_sgi.c,v 9.6 91/10/11 08:54:57 butler Exp $ (BRL)";
d50 2
d54 1
a55 1
#include <sys/types.h>
d61 2
a64 10

#ifndef bzero
# define bzero(p,cnt)	memset(p,'\0',cnt)
#endif

extern char *sbrk();
extern char *malloc();
extern int errno;
extern char *shmat();
extern int brk();
@


9.6
log
@changed to reflect magic number in FBIO structure
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_sgi.c,v 9.5 91/07/26 22:41:11 mike Exp Locker: butler $ (BRL)";
@


9.5
log
@Added if_magic field, and FB_CK_FBIO() macro, to allow checking
FBIO pointers
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_sgi.c,v 9.4 91/07/19 02:22:09 mike Exp $ (BRL)";
d121 1
@


9.4
log
@bzero redefined
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_sgi.c,v 9.3 90/12/11 22:50:55 phil Exp $ (BRL)";
d650 2
@


9.3
log
@if_ struct changes.  See fb.h.
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_sgi.c,v 9.2 89/09/01 01:45:33 phil Exp $ (BRL)";
d62 3
a64 1
#define bzero(p,cnt)	memset(p,'\0',cnt)
@


9.2
log
@fb_flush and fb_free (to be implemented) hooks.
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 9.1 89/05/19 05:48:06 phil Locked $ (BRL)";
a69 2
extern int	fb_sim_readrect(), fb_sim_writerect();

d103 11
a113 13
_LOCAL_ int	sgi_dopen(),
		sgi_dclose(),
		sgi_dclear(),
		sgi_bread(),
		sgi_bwrite(),
		sgi_cmread(),
		sgi_cmwrite(),
		sgi_viewport_set(),
		sgi_window_set(),
		sgi_zoom_set(),
		sgi_curs_set(),
		sgi_cmemory_addr(),
		sgi_cscreen_addr(),
d119 12
a130 14
		sgi_dopen,
		sgi_dclose,
		fb_null,		/* reset? */
		sgi_dclear,
		sgi_bread,
		sgi_bwrite,
		sgi_cmread,
		sgi_cmwrite,
		sgi_viewport_set,
		sgi_window_set,
		sgi_zoom_set,
		sgi_curs_set,
		sgi_cmemory_addr,
		fb_null,		/* cscreen_addr */
d133 1
d135 1
a135 1
		sgi_dclose,		/* free */
d143 1
d145 3
a178 4
	short	si_xzoom;
	short	si_yzoom;
	short	si_xcenter;
	short	si_ycenter;
d308 1
a308 1
		sgi_cmwrite( ifp, COLORMAP_NULL );
d368 1
a368 1
	xwidth = ifp->if_width/SGI(ifp)->si_xzoom;
d370 5
a374 5
	xmin = SGI(ifp)->si_xcenter - i;
	xmax = SGI(ifp)->si_xcenter + i - 1;
	i = (ifp->if_height/2)/SGI(ifp)->si_yzoom;
	ymin = SGI(ifp)->si_ycenter - i;
	ymax = SGI(ifp)->si_ycenter + i - 1;
d376 1
a376 1
		xscroff = -xmin * SGI(ifp)->si_xzoom;
d380 1
a380 1
		yscroff = -ymin * SGI(ifp)->si_yzoom;
d384 1
a384 1
		xscrpad = (xmax-(ifp->if_width-1))*SGI(ifp)->si_xzoom;
d388 1
a388 1
		yscrpad = (ymax-(ifp->if_height-1))*SGI(ifp)->si_yzoom;
d433 2
a434 2
			b = yscroff + (y-ymin)*SGI(ifp)->si_yzoom;
			t = b + SGI(ifp)->si_yzoom - 1;
d453 1
a453 1
					r = l + SGI(ifp)->si_xzoom - 1;
d498 1
a498 1
					r = l + SGI(ifp)->si_xzoom - 1;
d640 1
a640 1
sgi_dopen( ifp, file, width, height )
d696 1
a696 1
		fb_log("sgi_dopen:  sgiinfo malloc failed\n");
d706 4
a709 4
	SGI(ifp)->si_xzoom = 1;
	SGI(ifp)->si_yzoom = 1;
	SGI(ifp)->si_xcenter = width/2;
	SGI(ifp)->si_ycenter = height/2;
d727 1
a727 1
 *			S G I _ D C L O S E
d742 1
a742 1
sgi_dclose( ifp )
d769 1
a769 1
				fb_log("sgi_dclose shmdt failed, errno=%d\n", errno);
d785 1
a785 1
 *			S G I _ D C L E A R
d788 1
a788 1
sgi_dclear( ifp, pp )
a835 3
/*
 *			S G I _ W I N D O W _ S E T
 */
d837 1
a837 1
sgi_window_set( ifp, x, y )
a838 1
int	x, y;
a841 11

	if( SGI(ifp)->si_xcenter == x && SGI(ifp)->si_ycenter == y )
		return(0);
	if( x < 0 || x >= ifp->if_width )
		return(-1);
	if( y < 0 || y >= ifp->if_height )
		return(-1);
	SGI(ifp)->si_xcenter = x;
	SGI(ifp)->si_ycenter = y;
	sgi_repaint( ifp );
	return(0);
a843 3
/*
 *			S G I _ Z O O M _ S E T
 */
d845 1
a845 1
sgi_zoom_set( ifp, x, y )
d847 2
a848 1
int	x, y;
d853 4
a856 3
	if( x < 1 ) x = 1;
	if( y < 1 ) y = 1;
	if( SGI(ifp)->si_xzoom == x && SGI(ifp)->si_yzoom == y )
d858 2
a859 1
	if( x >= ifp->if_width || y >= ifp->if_height )
d861 4
d866 4
a869 2
	SGI(ifp)->si_xzoom = x;
	SGI(ifp)->si_yzoom = y;
d871 1
a871 1
	if( SGI(ifp)->si_xzoom > 1 || SGI(ifp)->si_yzoom > 1 )
d880 1
a880 1
 *			S G I _ B R E A D
d883 1
a883 1
sgi_bread( ifp, x, y, pixelp, count )
d929 1
a929 1
sgi_bwrite( ifp, xmem, ymem, pixelp, count )
d942 2
a943 2
	int hfwidth = (ifp->if_width/SGI(ifp)->si_xzoom)/2;
	int hfheight = (ifp->if_height/SGI(ifp)->si_yzoom)/2;
d954 2
a955 2
	xscr = (xmem - (SGI(ifp)->si_xcenter-hfwidth)) * SGI(ifp)->si_xzoom;
	yscr = (ymem - (SGI(ifp)->si_ycenter-hfheight)) * SGI(ifp)->si_yzoom;
d969 1
a969 1
			int todraw = (ifp->if_width-xscr)/SGI(ifp)->si_xzoom;
d977 1
a977 1
			t = b + SGI(ifp)->si_yzoom - 1;
d1018 1
a1018 1
				r = l + SGI(ifp)->si_xzoom - 1;
d1049 3
a1051 3
			xscr = (hfwidth-SGI(ifp)->si_xcenter) *
				SGI(ifp)->si_xzoom;
			yscr += SGI(ifp)->si_yzoom;
d1178 1
a1178 1
		xscr = SGI(ifp)->si_xcenter - hfwidth;
a1187 20
 *			S G I _ V I E W P O R T _ S E T
 */
_LOCAL_ int
sgi_viewport_set( ifp, left, top, right, bottom )
FBIO	*ifp;
int	left, top, right, bottom;
{
	if( qtest() )
		sgw_inqueue(ifp);
#if 0
	viewport(	(Screencoord) left,
			(Screencoord) right,
			(Screencoord) top,
			(Screencoord) (bottom * fb2iris_scale)
			);
#endif
	return(0);
}

/*
d1191 1
a1191 1
sgi_cmread( ifp, cmp )
d1235 1
a1235 1
sgi_cmwrite( ifp, cmp )
d1273 1
a1273 1
sgi_curs_set( ifp, bits, xbits, ybits, xorig, yorig )
d1311 1
a1311 1
sgi_cmemory_addr( ifp, mode, x, y )
d1323 1
d1329 1
a1329 1
	xwidth = ifp->if_width/SGI(ifp)->si_xzoom;
d1331 3
a1333 3
	xmin = SGI(ifp)->si_xcenter - i;
	i = (ifp->if_height/2)/SGI(ifp)->si_yzoom;
	ymin = SGI(ifp)->si_ycenter - i;
d1336 2
a1337 2
	x *= SGI(ifp)->si_xzoom;
	y *= SGI(ifp)->si_yzoom;
d1507 4
a1510 4
	SGI(ifp)->si_xzoom = 1;	/* for zoom fakeout */
	SGI(ifp)->si_yzoom = 1;	/* for zoom fakeout */
	SGI(ifp)->si_xcenter = width/2;
	SGI(ifp)->si_ycenter = height/2;
@


9.1
log
@Release_3.5
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 8.4 89/05/12 20:07:59 mike Exp $ (BRL)";
d139 2
@


8.4
log
@If shared memory segment can not be opened, handle open
as private memory.
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 8.3 89/05/04 04:58:07 mike Locked $ (BRL)";
@


8.3
log
@free private memory or release shared memory segment on close
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 8.2 89/03/03 05:54:40 phil Locked $ (BRL)";
d266 1
d305 1
d319 2
a320 2
	ifp->if_mem = sp;
	return(0);
@


8.2
log
@Added support for fb_readrect() and fb_writerect().
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 8.1 88/10/05 00:27:43 mike Locked $ (BRL)";
d700 1
d765 13
a777 1
	if( SGIL(ifp) != NULL )
d779 3
@


8.1
log
@Release_3.0
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 7.2 88/09/09 23:50:49 phil Exp $ (BRL)";
d70 2
d137 2
@


7.2
log
@fbhelp function (I documented the status quo.  We should probably
pick up many of the 4D modes).
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 7.1 87/11/02 23:26:51 phil Locked $ (BRL)";
@


7.1
log
@Release 2.3
@
text
@a0 2
#undef _LOCAL_
#define _LOCAL_ /**/
d47 1
a47 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 6.2 87/09/16 03:49:02 phil Exp $ (BRL)";
d115 2
a116 1
		sgi_cscreen_addr();
d135 1
d1648 22
@


6.2
log
@added colormapping during zoomed writes
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 6.1 87/07/11 07:51:39 phil Locked $ (BRL)";
@


6.1
log
@Release 2.0
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 5.1 87/06/24 21:51:44 mike Rel $ (BRL)";
d973 9
a981 3
					hole->s = (cp[RED]);
					hole->s = (cp[GRN]);
					hole->s = (cp[BLU]);
d985 9
a993 1
					hole->s = get_Color_Index( ifp, cp );
d997 9
a1005 1
					hole->s = COLOR_APPROX(cp);
@


5.1
log
@Release 1.24
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 4.8 87/02/12 22:06:43 mike Exp $ (BRL)";
@


4.8
log
@Release 1.20 -- First Formal Release
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 4.7 87/01/17 02:06:37 mike Exp $ (BRL)";
@


4.7
log
@Fixed problem where writes shorter than one scanline were
extended to fill the rest of the scanline.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 4.6 87/01/13 00:49:01 phil Exp $ (BRL)";
@


4.6
log
@made it repaint when a standard (NULL) colormap is loaded
if the previous one was not linear.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 4.5 87/01/08 11:37:29 phil Locked $ (BRL)";
d960 4
a963 1
			int tocopy = scan_count - todraw;
@


4.5
log
@Fixed bug related to initializing shared memory. "sgi_repaint" was getting
called indirectly from "sgi_getmem" before the window state variables were
set, so that the "SGI(ifp)->si_[xy]zoom" were zero, and "sgi_repaint" would
divide by them causing a floating point exception.  This was done correctly
in the RGB mode portion of the code.  Therefor, it only occured while under
MEX, after a reboot (so that shared memory would be initialized), and when
I had had a rough morning...
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 4.4 87/01/07 11:07:58 moss Locked $ (BRL)";
d1235 4
d1244 1
a1244 1
		CMR(ifp)[i] = cmp -> cm_red[i]>>8;
@


4.4
log
@Fixed bugs in zoomed-in mode of "sgi_bwrite" so that the shared memory
	copy of the image is written correctly, and the screen is drawn
	properly.
Fixed bugs in windowing logic of "sgi_repaint" so that the image is
	drawn in the proper place when the window center is greater than
	the image center in X or Y and the off-image portions of the
	screen are blanked out.
Added "sgi_rectf_pix" function to neaten up the off-image blanking
	code.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.46 86/12/20 06:02:32 mike Exp $ (BRL)";
d696 5
d707 1
d710 3
d1482 4
a1485 3
	if( sgi_getmem(ifp) < 0 )
		return(-1);

d1491 6
@


4.3
log
@Fixed bug in pixel-replication stuff, the rectangles were 1 pixel too large
in both X and Y, so that adjacent pixels overlapped.  Added KEYBD, MOUSE[XY]
devices to switch in sgw_inqueue, so that input from these devices would be
ignored rather than squawking about them.
@
text
@d159 1
d356 1
a356 1
	short xscroff, yscroff;
d358 1
d364 1
d380 8
a387 2
	if( xmax > ifp->if_width-1 )  xmax = ifp->if_width-1;
	if( ymax > ifp->if_height-1 )  ymax = ifp->if_height-1;
d389 32
d518 1
a518 1
		CMOV2S( hole, xscroff + xmin, yscroff + y );
d941 3
a943 2
		scan_count = ifp->if_width / SGI(ifp)->si_xzoom;
		if( count < scan_count )
d950 2
d956 1
a956 1
			for( i=scan_count; i > 0; i-- )  {
d996 5
d1005 2
a1006 1
			xscr = SGI(ifp)->si_xcenter - hfwidth;
a1009 1

d1562 41
@


4.2
log
@Added range checking on read and write routines.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 4.1 86/12/29 03:42:58 mike Locked $ (BRL)";
d390 1
a390 1
			t = b + SGI(ifp)->si_yzoom;
d409 1
a409 1
					r = l + SGI(ifp)->si_xzoom;
d424 1
a424 1
					l = r;
d454 1
a454 1
					r = l + SGI(ifp)->si_xzoom;
d469 1
a469 1
					l = r;
d911 1
a911 1
			t = b + SGI(ifp)->si_yzoom;
d930 1
a930 1
				r = l + SGI(ifp)->si_xzoom;
d946 1
a946 1
				l = r;
d1495 4
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.48 86/12/29 01:21:51 mike Exp $ (BRL)";
d837 3
d884 6
d892 1
@


1.48
log
@Changes to bwrite() from Moss,
plus returning number of pixels actually written.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.47 86/12/24 04:19:00 mike Locked $ (BRL)";
@


1.47
log
@Minor fix for MEX mode.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.45 86/12/20 04:32:03 mike Exp $ (BRL)";
d866 1
a866 1
sgi_bwrite( ifp, x, y, pixelp, count )
d868 1
a868 1
int	x, y;
d874 1
a874 1
	int xpos, ypos;
d879 2
a880 1

d884 2
a885 2
	xpos = x;
	ypos = y;
d888 1
a888 1
		if( ypos >= ifp->if_height )
d894 1
a894 1
		op = (unsigned char *)&ifp->if_mem[(ypos*1024+xpos)*sizeof(RGBpixel)];
d899 2
a900 2
			l = xpos * SGI(ifp)->si_xzoom;
			b = ypos * SGI(ifp)->si_yzoom;
d943 5
a947 2
			xpos = 0;
			ypos++;
d952 1
a952 1
		CMOV2S( hole, xpos, ypos );
d1072 5
a1076 2
		xpos = 0;
		ypos++;
@


1.46
log
@When creating new shared memory segment, load standard colormap.
@
text
@a1381 7
	ifp->if_zoomflag = 0;
	SGI(ifp)->si_xzoom = 1;	/* for zoom fakeout */
	SGI(ifp)->si_yzoom = 1;	/* for zoom fakeout */
	SGI(ifp)->si_xcenter = width/2;
	SGI(ifp)->si_ycenter = height/2;
	SGI(ifp)->si_cmap_flag = !is_linear_cmap(ifp);

d1409 7
@


1.45
log
@Added colormap to shared memory area.
Added is_linear_cmap() routine.
Added /dev/sgi99 handling to free shared memory area
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.43 86/12/19 23:50:58 mike Locked $ (BRL)";
d259 1
d265 9
a273 3
	if( (SGI(ifp)->si_shmid = shmget( SHMEM_KEY, size, IPC_CREAT|0666 )) < 0 )  {
		fb_log("shmget returned %d, errno=%d\n", SGI(ifp)->si_shmid, errno);
		goto fail;
d301 4
d611 1
a611 1
		if( isdigit(*cp) )
a659 1
	SGI(ifp)->si_cmap_flag = !is_linear_cmap(ifp);
d663 1
@


1.44
log
@Fully implemented RGB colormap in redraw and write routines.
@
text
@d159 1
d161 6
d172 1
a172 1
	short	si_zoomflag;
a176 2
	short	si_special_zoom;
	short	si_mode;
a177 1
	short	si_curs_on;
d181 9
a189 3
#define	SGI(ptr) ((struct sgiinfo *)((ptr)->u1.p))
#define	SGIL(ptr) ((ptr)->u1.p)		/* left hand side version */
#define if_mem	u2.p			/* shared memory pointer */
a203 1
_LOCAL_ ColorMap _sgi_cmap;
d216 1
a216 1
/* TOL of 28 gives good rendering of the dragon picture without running out */
d253 1
d261 2
a262 1
	size = 1024 * 768 * sizeof(RGBpixel);
d293 1
d306 22
d374 1
a374 1
		if( SGI(ifp)->si_zoomflag )  {
d382 1
a382 1
					switch( SGI(ifp)->si_mode ) {
d421 1
a421 1
					switch( SGI(ifp)->si_mode ) {
d424 3
a426 6
						hole->s = _sgi_cmap.cm_red[
							ip[RED]];
						hole->s = _sgi_cmap.cm_green[
							ip[GRN]];
						hole->s = _sgi_cmap.cm_blue[
							ip[BLU]];
d429 3
a431 3
						new[RED] = _sgi_cmap.cm_red[ip[RED]];
						new[GRN] = _sgi_cmap.cm_green[ip[GRN]];
						new[BLU] = _sgi_cmap.cm_blue[ip[BLU]];
d436 3
a438 3
						new[RED] = _sgi_cmap.cm_red[ip[RED]];
						new[GRN] = _sgi_cmap.cm_green[ip[GRN]];
						new[BLU] = _sgi_cmap.cm_blue[ip[BLU]];
d468 1
a468 1
		switch( SGI(ifp)->si_mode )  {
d497 3
a499 6
						hole->s = _sgi_cmap.cm_red[
							*ip++];
						hole->s = _sgi_cmap.cm_green[
							*ip++];
						hole->s = _sgi_cmap.cm_blue[
							*ip++];
d531 3
a533 6
						new[RED] = _sgi_cmap.cm_red[
							*ip++];
						new[GRN] = _sgi_cmap.cm_green[
							*ip++];
						new[BLU] = _sgi_cmap.cm_blue[
							*ip++];
d566 3
a568 6
						new[RED] = _sgi_cmap.cm_red[
							*ip++];
						new[GRN] = _sgi_cmap.cm_green[
							*ip++];
						new[BLU] = _sgi_cmap.cm_blue[
							*ip++];
d593 18
d644 1
a644 1
	SGI(ifp)->si_zoomflag = 0;
d649 2
a650 1
	SGI(ifp)->si_mode = MODE_RGB;
a657 3
	/* Build a linear "colormap" in case he wants to read it */
	sgi_cmwrite( ifp, COLORMAP_NULL );

d682 1
a682 1
	switch( SGI(ifp)->si_mode )  {
a698 6
#ifdef never
	if( flag )  {
		/* Attempt to release shared memory segment */
		(void)shmctl( SGI(ifp)->si_shmid, IPC_RMID, 0 );
	}
#endif
d727 1
a727 1
		switch( SGI(ifp)->si_mode )  {
d741 1
a741 1
		switch( SGI(ifp)->si_mode )  {
d801 2
a802 2
		SGI(ifp)->si_zoomflag = 1;
	else	SGI(ifp)->si_zoomflag = 0;
d884 1
a884 1
		if( SGI(ifp)->si_zoomflag )  {
d892 1
a892 1
				switch( SGI(ifp)->si_mode )  {
d939 1
a939 1
		switch( SGI(ifp)->si_mode )  {
d968 1
a968 1
						hole->s = _sgi_cmap.cm_red[
d970 1
a970 1
						hole->s = _sgi_cmap.cm_green[
d972 1
a972 1
						hole->s = _sgi_cmap.cm_blue[
d1006 1
a1006 1
						new[RED] = _sgi_cmap.cm_red[
d1008 1
a1008 1
						new[GRN] = _sgi_cmap.cm_green[
d1010 1
a1010 1
						new[BLU] = _sgi_cmap.cm_blue[
d1044 1
a1044 1
						new[RED] = _sgi_cmap.cm_red[
d1046 1
a1046 1
						new[GRN] = _sgi_cmap.cm_green[
d1048 1
a1048 1
						new[BLU] = _sgi_cmap.cm_blue[
d1091 1
a1091 1
FBIO	*ifp;
d1102 3
a1104 3
		cmp->cm_red[i] = _sgi_cmap.cm_red[i]<<8;
		cmp->cm_green[i] = _sgi_cmap.cm_green[i]<<8;
		cmp->cm_blue[i] = _sgi_cmap.cm_blue[i]<<8;
d1110 21
d1135 1
a1135 1
FBIO	*ifp;
d1145 3
a1147 3
			_sgi_cmap.cm_red[i] = i;
			_sgi_cmap.cm_green[i] = i;
			_sgi_cmap.cm_blue[i] = i;
d1154 3
a1156 3
		_sgi_cmap.cm_red[i] = cmp -> cm_red[i]>>8;
		_sgi_cmap.cm_green[i] = cmp-> cm_green[i]>>8; 
		_sgi_cmap.cm_blue[i] = cmp-> cm_blue[i]>>8;
d1159 1
a1159 1
	SGI(ifp)->si_cmap_flag = TRUE;
d1233 1
a1233 1
	switch( SGI(ifp)->si_mode )  {
d1339 1
a1339 1
	SGI(ifp)->si_mode = MODE_APPROX;
d1343 1
a1343 1
		/* "/dev/sgiw###" gives optional mode */
d1348 5
d1355 1
a1355 1
		SGI(ifp)->si_mode = mode;
d1371 1
a1371 1
	SGI(ifp)->si_zoomflag = 0;
d1376 1
a1376 1
	SGI(ifp)->si_special_zoom = 0;
d1407 1
a1407 1
	 * Deal with the color map
d1422 1
a1422 1
	if( SGI(ifp)->si_mode == MODE_APPROX )  {
a1431 3

	/* Build a linear "colormap" in case he wants to read it */
	sgi_cmwrite( ifp, COLORMAP_NULL );
d1437 1
@


1.43
log
@Fixes from Gary Moss.
Corrected slot 255 handling in "color map",
fixed best-fit redraw code,
misc. cleanups.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.42 86/12/10 17:05:03 mike Exp $ (BRL)";
d346 35
a380 16
			for( i=xwidth; i > 0; i--)  {
				switch( SGI(ifp)->si_mode ) {
				case MODE_RGB:
					PASSCMD(hole,3,FBCrgbcolor);
					hole->s = (ip[RED]);
					hole->s = (ip[GRN]);
					hole->s = (ip[BLU]);
					break;
				case MODE_FIT:
					PASSCMD(hole,1,FBCcolor);
					hole->s = get_Color_Index( ifp, ip );
					break;
				case MODE_APPROX:
					PASSCMD(hole,1,FBCcolor);
					hole->s = COLOR_APPROX(ip);
					break;
d382 49
a430 17
				r = l + SGI(ifp)->si_xzoom;
				/* left bottom right top: rectfs( l, b, r, t ); */
				hole->s = GEmovepoly | GEPA_2S;
				hole->s = l;
				hole->s = b;
				hole->s = GEdrawpoly | GEPA_2S;
				hole->s = r;
				hole->s = b;
				hole->s = GEdrawpoly | GEPA_2S;
				hole->s = r;
				hole->s = t;
				hole->s = GEdrawpoly | GEPA_2S;
				hole->s = l;
				hole->s = t;
				hole->s = GEclosepoly;	/* Last? */
				l = r;
				ip += sizeof(RGBpixel);
a431 1
			continue;
d439 3
a441 2
			for( i=xwidth; i > 0; )  {
				register short chunk;
d443 11
a453 10
				if( i <= (127/3) )
					chunk = i;
				else
					chunk = 127/3;
				PASSCMD(hole, chunk*3, FBCdrawpixels);
				i -= chunk;
				for( ; chunk>0; chunk--)  {
					hole->us = *ip++;
					hole->us = *ip++;
					hole->us = *ip++;
d455 19
d477 3
a479 2
			for( i=xwidth; i > 0; )  {
				register short chunk;
d481 9
a489 8
				if( i <= 127 )
					chunk = i;
				else
					chunk = 127;
				PASSCMD(hole, chunk, FBCdrawpixels);
				i -= chunk;
				for( ; chunk > 0; chunk--, ip += sizeof(RGBpixel) )  {
					hole->s = get_Color_Index( ifp, ip );
d491 21
d515 3
a517 2
			for( i=xwidth; i > 0; )  {
				register short chunk;
d519 9
a527 8
				if( i <= 127 )
					chunk = i;
				else
					chunk = 127;
				PASSCMD(hole, chunk, FBCdrawpixels);
				i -= chunk;
				for( ; chunk > 0; chunk--, ip += sizeof(RGBpixel) )  {
					hole->s = COLOR_APPROX(ip);
d529 21
d1107 1
@


1.42
log
@Fixes from Gary Moss:
MEX Positioning of window, cursor positioning.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.41 86/12/10 05:55:05 mike Exp $ (BRL)";
d206 1
a206 1
#define MAP_TOL		28		/* pixel delta across all channels */
d415 1
a415 1
				for( ; chunk > 0; chunk-- )  {
d951 1
a951 1
	for( i = 0; i < 255; i++)
d974 1
a974 1
		for( i = 0; i < 255; i++)  {
d983 1
a983 1
	for(i = 0; i < 255; i++)  {
d1100 3
a1102 1
	for( i = 0, sp = rgb_table; i < SGI(ifp)->si_rgb_ct; sp++, i++ ) {
d1173 1
a1173 1
		for( cp = file; *cp != NULL && !isdigit(*cp); cp++ ) ;
d1175 2
a1176 1
		(void)sscanf( cp, "%d", &mode );
@


1.41
log
@Fixed new bug with bwrite in zoomed mode.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.40 86/12/10 01:30:28 mike Exp $ (BRL)";
d201 1
a201 1
#define WIN_R	(1024-MARGIN)
d203 1
a203 1
#define WIN_T	(ifp->if_height+MARGIN)
d534 2
a535 2
			/* Leave mex's cursor on */
			/* winclose( SGI(ifp)->si_fd ); */
a637 2
	int npts;

d1040 4
d1052 7
d1070 3
d1075 3
a1077 2
		setvaluator( MOUSEX, x + WIN_L, 0, 1023 );
		setvaluator( MOUSEY, y + WIN_B, 0, 1023 );
d1079 1
d1208 3
@


1.40
log
@Further optimization for speed.
Removed many magic hex constants & used SGI defines instead.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.37 86/12/09 05:50:36 mike Locked $ (BRL)";
d783 3
@


1.39
log
@Merged the rest of the sgw_ (12-bit) routines.
Improved shared memory, to leave room for malloc()s.
@
text
@d92 2
a93 2
		(_p)->l = 0x0008001A; \
		(_p)->s = 0x0912; \
a95 1
		GEP_END(hole)->s = (0xFF<<8)|8; \
d98 2
d349 4
a352 3
					RGBcolor( (short)(ip[RED]),
						(short)(ip[GRN]),
						(short)(ip[BLU]) );
d355 2
a356 1
					color(get_Color_Index( ifp, ip ));
d359 2
a360 1
					color(COLOR_APPROX(ip));
d385 2
a386 4
		hole->l = 0x0008001A;	/* passthru, */
		hole->s = 0x0912;		/* cmov2s */
		hole->s = xscroff + xmin;
		hole->s = yscroff + y;
d396 1
a396 2
				hole->s = ((chunk*3)<<8) | GEpassthru;
				hole->s = FBCdrawpixels;
d413 1
a413 2
				hole->s = (chunk<<8) | GEpassthru;
				hole->s = FBCdrawpixels;
d428 1
a428 2
				hole->s = (chunk<<8) | GEpassthru;
				hole->s = FBCdrawpixels;
d747 4
a750 3
					RGBcolor( (short)(cp[RED]),
						(short)(cp[GRN]),
						(short)(cp[BLU]) );
d753 2
a754 1
					color(get_Color_Index( ifp, cp ));
d757 2
a758 1
					color(COLOR_APPROX(cp));
d787 2
a788 4
		hole->l = 0x0008001A;		/* passthru, */
		hole->s = 0x0912;		/* cmov2s */
		hole->s = xpos;
		hole->s = ypos;
d799 1
a799 2
					hole->s = ((chunk*3)<<8) | GEpassthru;
					hole->s = FBCdrawpixels;
d815 1
a815 2
					hole->s = ((chunk*3)<<8) | GEpassthru;
					hole->s = FBCdrawpixels;
d836 1
a836 2
					hole->s = (chunk<<8) | GEpassthru;
					hole->s = FBCdrawpixels;
d852 1
a852 2
					hole->s = (chunk<<8) | GEpassthru;
					hole->s = FBCdrawpixels;
d874 1
a874 2
					hole->s = (chunk<<8) | GEpassthru;
					hole->s = FBCdrawpixels;
d890 1
a890 2
					hole->s = (chunk<<8) | GEpassthru;
					hole->s = FBCdrawpixels;
@


1.38
log
@Optimized version, with single sgi_bwrite().
@
text
@d19 2
a20 2
 *  In order to use this sized chunk of memory with the shared memory
 *  system, it is necessary to "poke" your kernel to authorized this.
a63 1
#ifdef SYSV
a64 1
#endif
d66 1
a66 1
/* Local state variables within the FBIO structure */
d68 3
d153 1
a153 1
/* Interface to the 12-bit window versions of these routines */
a154 3
_LOCAL_ int
		sgw_curs_set(),
		sgw_cmemory_addr();
a158 34
/* This one is not exported, but is used for roll-over to 12-bit mode */
static FBIO sgiw_interface =
		{
		sgw_dopen,
		sgi_dclose,
		fb_null,
		sgi_dclear,
		sgi_bread,
		sgi_bwrite,
		sgi_cmread,
		sgi_cmwrite,
		sgi_viewport_set,
		sgi_window_set,
		sgi_zoom_set,
		sgw_curs_set,
		sgw_cmemory_addr,
		fb_null,
		"Silicon Graphics IRIS, in 12-bit mode, for windows",
		1024,			/* max width */
		768,			/* max height */
		"/dev/sgiw",
		512,			/* current/default width  */
		512,			/* current/default height */
		-1,			/* file descriptor */
		PIXEL_NULL,		/* page_base */
		PIXEL_NULL,		/* page_curp */
		PIXEL_NULL,		/* page_endp */
		-1,			/* page_no */
		0,			/* pdirty */
		0L,			/* page_curpos */
		0L,			/* page_pixels */
		0			/* debug */
		};

d174 1
d211 27
d242 6
a247 7
	int key = 42;
	int shmid;
	int size = 1024 * 768 * sizeof(RGBpixel);
	int i;
	extern int errno;
	extern char *shmat();
	char *sp;
d250 4
a253 2
	if( (shmid = shmget( key, size, IPC_CREAT|0666 )) < 0 )  {
		fb_log("shmget returned %d, errno=%d\n", shmid, errno);
d256 14
a269 2
	/* Open the segment Read/Write */
	if( (sp = shmat( shmid, 0, 0 )) == (char *)(-1) )  {
d273 7
d443 3
a455 5
		char *name;

		name = ifp->if_name;
		*ifp = sgiw_interface;	/* struct copy */
		ifp->if_name = name;
a461 2
		char *name;

a463 3
		name = ifp->if_name;
		*ifp = sgiw_interface;	/* struct copy */
		ifp->if_name = name;
d545 6
d556 3
d608 3
d631 3
d662 3
a691 4

#ifdef BSD
		bcopy( ip, *pixelp, scan_count*sizeof(RGBpixel) );
#else
a692 1
#endif
d705 3
d922 3
d942 3
d965 3
d998 3
d1007 8
a1014 3
	{	register int	y;
		register int	xbytes;
		Cursor		newcursor;
d1026 1
a1026 2
	for( y = 0; y < ybits; y++ )
		{
d1030 1
a1030 1
		}
d1034 1
a1034 1
	}
d1036 3
d1044 4
a1047 1
	{
d1049 1
a1049 2
	if( ! mode )
		{
d1052 1
a1052 1
		}
d1056 14
a1069 3
	RGBcursor( 1, 255, 255, 0, 0xFF, 0xFF, 0xFF );
	setvaluator( MOUSEX, x, 0, 1023 );
	setvaluator( MOUSEY, y, 0, 1023 );
d1071 1
a1071 1
	}
d1140 3
d1168 1
d1170 1
a1170 1
		width = ifp->if_width;
d1172 1
a1172 1
		height = ifp->if_height;
a1249 59

_LOCAL_ int
sgw_curs_set( ifp, bits, xbits, ybits, xorig, yorig )
FBIO	*ifp;
unsigned char	*bits;
int		xbits, ybits;
int		xorig, yorig;
	{	register int	y;
		register int	xbytes;
		Cursor		newcursor;

	if( qtest() )
		sgw_inqueue(ifp);
	/* Check size of cursor.					*/
	if( xbits < 0 )
		return	-1;
	if( xbits > 16 )
		xbits = 16;
	if( ybits < 0 )
		return	-1;
	if( ybits > 16 )
		ybits = 16;
	if( (xbytes = xbits / 8) * 8 != xbits )
		xbytes++;
	for( y = 0; y < ybits; y++ )
		{
		newcursor[y] = bits[(y*xbytes)+0] << 8 & 0xFF00;
		if( xbytes == 2 )
			newcursor[y] |= bits[(y*xbytes)+1] & 0x00FF;
		}
	defcursor( 1, newcursor );
	curorigin( 1, (short) xorig, (short) yorig );
	return	0;
	}

_LOCAL_ int
sgw_cmemory_addr( ifp, mode, x, y )
FBIO	*ifp;
int	mode;
int	x, y;
	{	static Colorindex	cursor_color = YELLOW;
			/* Color and bitmask ignored under MEX.	*/
	if( qtest() )
		sgw_inqueue(ifp);
	SGI(ifp)->si_curs_on = mode;
	if( ! mode )
		{
		cursoff();
		setcursor( 0, 1, 0x2000 );
		return	0;
		}
	x *= SGI(ifp)->si_xzoom;
	y *= SGI(ifp)->si_yzoom;
	curson();
	setcursor( 1, cursor_color, 0x2000 );
	setvaluator( MOUSEX, x + WIN_L, 0, 1023 );
	setvaluator( MOUSEY, y + WIN_B, 0, 1023 );
	return	0;
	}
@


1.37
log
@More cleanups.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.35 86/12/01 09:02:37 mike Locked $ (BRL)";
a154 1
		sgw_bwrite(),
d156 2
a157 2
		sgw_cmemory_addr(),
		sgw_cscreen_addr();
d169 1
a169 1
		sgw_bwrite,
d175 2
a176 2
		sgi_curs_set,
		sgi_cmemory_addr,
d220 8
d298 1
d304 2
a305 1
	i = (ifp->if_width/2)/SGI(ifp)->si_xzoom;
d307 1
a307 1
	xmax = SGI(ifp)->si_xcenter + i + 1;
d310 1
a310 1
	ymax = SGI(ifp)->si_ycenter + i + 1;
d333 1
a333 1
			for( i=xmax-xmin; i > 0; i--)  {
d344 1
a344 4
					color(MAP_RESERVED +
						(ip[RED]/26) +
						(ip[GRN]/26) * 10 +
						(ip[BLU]/26) * 100 );
d348 1
a348 1
				/* left bottom right top: im_rectfs( l, b, r, t ); */
d375 1
a375 1
			for( i=xmax-xmin; i > 0; )  {
d382 2
a383 2
				hole->s = ((chunk*3)<<8)|8;	/* GEpassthru */
				hole->s = 0xD;		/* FBCdrawpixels */
d393 1
a393 1
			for( i=xmax-xmin; i > 0; )  {
d400 2
a401 2
				hole->s = (chunk<<8)|8; /* GEpassthru */
				hole->s = 0xD;		 /* FBCdrawpixels */
d409 1
a409 1
			for( i=xmax-xmin; i > 0; )  {
d416 2
a417 2
				hole->s = (chunk<<8)|8; /* GEpassthru */
				hole->s = 0xD;		 /* FBCdrawpixels */
d420 1
a420 4
					hole->s = MAP_RESERVED +
						(ip[RED]/26) +
						(ip[GRN]/26) * 10 +
						(ip[BLU]/26) * 100;
d575 1
a575 4
			color( MAP_RESERVED +
				((*pp)[RED]/26) +
				((*pp)[GRN]/26) * 10 +
				((*pp)[BLU]/26) * 100 );
d695 1
a695 1
	register int scan_count;
a714 4
		hole->l = 0x0008001A;	/* passthru, */
		hole->s = 0x0912;		/* cmov2s */
		hole->s = xpos;
		hole->s = ypos;
d717 2
a718 2
		for( i=scan_count; i > 0; )  {
			register short chunk;
d720 4
a723 2
			if( SGI(ifp)->si_zoomflag )  {
				Scoord l, b, r, t;
d725 13
a737 5
				RGBcolor( (short)(cp[RED]),
					(short)(cp[GRN]),
					(short)(cp[BLU]) );
				l = xpos * SGI(ifp)->si_xzoom;
				b = ypos * SGI(ifp)->si_yzoom;
a738 1
				t = b + SGI(ifp)->si_yzoom;
d740 1
a740 1
				/* left bottom right top: im_rectfs( l, b, r, t ); */
d754 1
a758 3
				i--;
				xpos++;
				continue;
d760 10
a769 7
			if( i <= (127/3) )
				chunk = i;
			else
				chunk = 127/3;
			hole->s = ((chunk*3)<<8)|8;	/* GEpassthru */
			hole->s = 0xD;		/* FBCdrawpixels */
			i -= chunk;
d771 15
a785 4
				for( ; chunk>0; chunk--)  {
					hole->us = (*op++ = *cp++);
					hole->us = (*op++ = *cp++);
					hole->us = (*op++ = *cp++);
d788 18
a805 4
				for( ; chunk>0; chunk-- )  {
					hole->s = _sgi_cmap.cm_red[*op++ = *cp++];
					hole->s = _sgi_cmap.cm_green[*op++ = *cp++];
					hole->s = _sgi_cmap.cm_blue[*op++ = *cp++];
d808 81
a1191 91
}

_LOCAL_ int
sgw_bwrite( ifp, x, y, pixelp, count )
FBIO	*ifp;
int	x, y;
register RGBpixel	*pixelp;
int	count;
{	
	register union gepipe *hole = GEPIPE;
	int scan_count;
	register int i;
	register unsigned char *op;
	int ret;

	if( qtest() )
		sgw_inqueue(ifp);
	writemask( 0x3FF );
	ret = 0;
	while( count > 0 )  {
		register short	ypos = y*SGI(ifp)->si_yzoom;
		register short	xpos = x*SGI(ifp)->si_xzoom;

		if( ypos >= ifp->if_height )
			break;
		scan_count = ifp->if_width / SGI(ifp)->si_xzoom;
		if( count < scan_count )
			scan_count = count;

		op = (unsigned char *)&ifp->if_mem[(y*1024+x)*sizeof(RGBpixel)];

		if( !(SGI(ifp)->si_zoomflag) )  {	
			register Colorindex	colori;

			CMOV2S( hole, xpos, ypos );
			for( i = scan_count; i > 0; )  {	
				register short	chunk;
				if( i <= 127 )
					chunk = i;
				else
					chunk = 127;
				hole->s = (chunk<<8)|8; /* GEpassthru */
				hole->s = 0xD;		 /* FBCdrawpixels */
				i -= chunk;
				for( ; chunk > 0; chunk--, pixelp++ )  {
					if( SGI(ifp)->si_mode == MODE_FIT ) {
						colori = get_Color_Index( ifp, pixelp );
						*op++ = (*pixelp)[RED];
						*op++ = (*pixelp)[GRN];
						*op++ = (*pixelp)[BLU];
						hole->s = colori;
						continue;
					}
					colori =  MAP_RESERVED +
					    ((*op++=(*pixelp)[RED])/26);
					colori += ((*op++=(*pixelp)[GRN])/26) * 10;
					colori += ((*op++=(*pixelp)[BLU])/26) * 100;
					hole->s = colori;
				}
			}
			GEP_END(hole)->s = (0xFF<<8)|8;	/* im_last_passthru(0) */
		} else {
			for( i = 0; i < scan_count; i++, pixelp++ )  {	
				register Colorindex	col;
				register Scoord	r = xpos + SGI(ifp)->si_xzoom - 1;
				register Scoord t = ypos + SGI(ifp)->si_yzoom - 1;

				CMOV2S( hole, xpos, ypos );
				if( SGI(ifp)->si_mode == MODE_FIT ) {
					col = get_Color_Index( ifp, pixelp );
					*op++ = (*pixelp)[RED];
					*op++ = (*pixelp)[GRN];
					*op++ = (*pixelp)[BLU];
				} else {
					col =  MAP_RESERVED +
					    ((*op++=(*pixelp)[RED])/26);
					col += ((*op++=(*pixelp)[GRN])/26) * 10;
					col += ((*op++=(*pixelp)[BLU])/26) * 100;
				}

				color( col );
				im_rectfs( (Scoord)xpos, (Scoord)ypos, r, t );
				xpos += SGI(ifp)->si_xzoom;
			}
		}
		count -= scan_count;
		ret += scan_count;
		x = 0;
		y++;
	}
	return(ret);
@


1.36
log
@Speedups and bug fixes.
@
text
@a104 1
		sgi_dreset(),
d122 1
a122 1
		sgi_dreset,
d126 2
a127 2
		fb_null,
		fb_null,
d133 1
a133 1
		fb_null,
d154 1
a154 3
_LOCAL_ int	sgw_dclose(),
		sgw_dreset(),
		sgw_dclear(),
a155 1
		sgw_viewport_set(),
d166 3
a168 3
		sgw_dclose,
		sgw_dreset,
		sgw_dclear,
d171 3
a173 3
		fb_null,
		fb_null,
		sgw_viewport_set,
d519 18
a536 6
#ifdef Ruins_Images
	tpon();			/* Turn on textport */
	greset();
	/* could be ginit(), gconfig() */
#endif
	gexit();
d543 1
a543 1
sgi_dreset( ifp )
d545 1
a546 3
	ginit();
	RGBmode();
	gconfig();
d548 2
a549 5
	RGBcolor( (short) 0, (short) 0, (short) 0);
	clear();
	bzero( ifp->if_mem, 1024*ifp->if_height*sizeof(RGBpixel) );
	return(0);
}
a550 5
_LOCAL_ int
sgi_dclear( ifp, pp )
FBIO	*ifp;
register RGBpixel	*pp;
{
d554 1
d561 17
a577 1
		RGBcolor((short)((*pp)[RED]), (short)((*pp)[GRN]), (short)((*pp)[BLU]));
d579 9
a587 1
		RGBcolor( (short) 0, (short) 0, (short) 0);
d781 1
a781 3
		/* Advance upwards */
		if( ++ypos >= ifp->if_height )
			break;
d794 9
a802 1
/*	viewport( left, right, top, bottom );*/
a1082 56
sgw_dclose( ifp )
FBIO	*ifp;
{
	setcursor( 0, 1, 0x2000 );
	if( ismex() )  {
		/* Leave mex's cursor on */
		; /* winclose( SGI(ifp)->si_fd ); */
	}  else  {
		cursoff();
		greset();
		gexit();
	}
	if( SGIL(ifp) != NULL )
		(void)free( (char *)SGIL(ifp) );
/** 	fb_log( "%d color table entries used.\n", SGI(ifp)->si_rgb_ct );  **/
	return	0;	
}

_LOCAL_ int
sgw_dreset( ifp )
FBIO	*ifp;
{
	ginit();
	singlebuffer();
	gconfig();

	if( qtest() )
		sgw_inqueue(ifp);
	color(BLACK);
	clear();
	return	0;	
}

_LOCAL_ int
sgw_dclear( ifp, pp )
FBIO	*ifp;
RGBpixel	*pp;
{
	Colorindex i;
	register int cnt;

	if( qtest() )
		sgw_inqueue(ifp);
	if ( pp != RGBPIXEL_NULL)
		i = get_Color_Index( ifp, pp );
	else
		i = BLACK;

	color(i);

	writemask( 0x3FF );
	clear();
	return	0;	
}

_LOCAL_ int
a1170 17
}

_LOCAL_ int
sgw_viewport_set( ifp, left, top, right, bottom )
FBIO	*ifp;
int	left, top, right, bottom;
{
	if( qtest() )
		sgw_inqueue(ifp);
#if 0
	viewport(	(Screencoord) left,
			(Screencoord) right,
			(Screencoord) top,
			(Screencoord) (bottom * fb2iris_scale)
			);
#endif
	return	0;
@


1.35
log
@Fixed 24-bit mode code sequence error.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.34 86/12/01 06:51:36 mike Locked $ (BRL)";
d218 1
a218 1
#define if_mem	u2.p		/* shared memory pointer */
d293 2
a294 1
	short x, y;
d297 1
a297 1
		cursoff();		/* Cursor interferes with reading! */
d299 1
d306 10
a315 4
	if( xmin < 0 )  xmin = 0;
	if( ymin < 0 )  ymin = 0;
	if( xmax > ifp->if_max_width-1 )  xmax = ifp->if_max_width-1;
	if( ymax > ifp->if_max_height-1 )  ymax = ifp->if_max_height-1;
a317 1
		x = xmin;
d319 2
a320 1
		ip = (unsigned char *)&ifp->if_mem[(y*1024+x)*sizeof(RGBpixel)];
d323 6
a328 2
			for( i=xmax-xmin; i > 0; i--, x++)  {
				register Coord l, b, r, t;
a344 2
				l = (x-xmin) * SGI(ifp)->si_xzoom;
				b = (y-ymin) * SGI(ifp)->si_yzoom;
d346 15
a360 3
				t = b + SGI(ifp)->si_yzoom;
				/* left bottom right top */
				im_rectf( l, b, r, t );
d369 2
a370 2
		hole->s = x;
		hole->s = y;
d553 1
a553 1
	if ( pp != NULL)  {
d581 4
d605 2
d634 1
a634 1
	ret = count;	/* save count */
d655 1
d657 3
a659 1
		ypos++;		/* Advance upwards */
d680 2
a681 2
		cursoff();		/* Cursor interferes with reading! */
	ret = count;	/* save count */
d686 4
a689 4
		if( ypos >= ifp->if_max_width )  return(0);
		if ( count >= ifp->if_width )  {
			scan_count = ifp->if_width;
		} else	{
a690 1
		}
d702 1
a702 1
				Coord l, b, r, t;
d712 15
a726 2
				/* left bottom right top */
				im_rectf( l, b, r, t );
d758 3
a760 1
		ypos++;		/* 1st quadrant */
d764 1
a764 1
		curson();		/* Cursor interferes with reading! */
d975 2
a976 2
	if ( width > ifp->if_max_width - 2 * MARGIN) 
		width = ifp->if_max_width - 2 * MARGIN;
d1115 4
a1118 3
	{	register union gepipe *hole = GEPIPE;
		int scan_count;
		register int i;
d1120 1
d1125 9
a1133 7
	while( count > 0 )
		{
			register short	ypos = y*SGI(ifp)->si_yzoom;
			register short	xpos = x*SGI(ifp)->si_xzoom;
		if ( count >= ifp->if_width )
			scan_count = ifp->if_width;
		else
d1135 1
d1138 3
a1140 2
		if( !(SGI(ifp)->si_zoomflag) )
			{	register Colorindex	colori;
d1142 2
a1143 2
			for( i = scan_count; i > 0; )
				{	register short	chunk;
d1151 1
a1151 2
				for( ; chunk > 0; chunk--, pixelp++ )
					{
d1161 1
a1161 1
						((*op++=(*pixelp)[RED])/26);
a1164 1
					}
d1166 1
d1168 6
a1173 6
			}
		else
			for( i = 0; i < scan_count; i++, pixelp++ )
				{	register Colorindex	col;
					register Coord	r = xpos + SGI(ifp)->si_xzoom - 1,
							t = ypos + SGI(ifp)->si_yzoom - 1;
d1182 1
a1182 1
						((*op++=(*pixelp)[RED])/26);
d1188 1
a1188 1
				im_rectf( (Coord)xpos, (Coord)ypos, r, t );
d1190 2
a1191 1
				}
d1193 1
a1195 2
		}
	return	0;
d1197 2
@


1.34
log
@Added tcp comment.
@
text
@d22 1
a22 1
 *  shmall from 0x40 to 0x258 by running:
d49 1
a49 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.33 86/11/29 05:20:23 mike Locked $ (BRL)";
a444 3
	/* Build a linear "colormap" in case he wants to read it */
	sgi_cmwrite( ifp, COLORMAP_NULL );

a461 1

d470 1
d474 4
@


1.33
log
@Initial version of fully accurate readback version,
with SysV shared memory.
Can also do full zooming, etc.
@
text
@d27 2
d49 1
a49 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.29 86/11/25 04:10:48 mike Exp $ (BRL)";
@


1.32
log
@Modified to use dynamic structure for local state information.
Turned off cursor when reading back image.
@
text
@d12 19
d53 3
a155 1
		sgw_bread(),
a156 2
		sgw_cmread(),
		sgw_cmwrite(),
a157 2
		sgw_window_set(),
		sgw_zoom_set(),
d161 1
d171 1
a171 1
		sgw_bread,
d176 4
a180 4
		sgw_zoom_set,
		sgw_curs_set,
		sgw_cmemory_addr,
		fb_null,
d200 1
a200 1
 *  Too much for the if_u[1-6] area now.
d203 1
d206 2
a210 1
	char	*si_save;
d212 1
d216 1
d218 4
a221 1
_LOCAL_ int _sgi_cmap_flag;
d225 16
d242 167
d464 8
a471 2
	SGI(ifp)->si_xzoom = 1;	/* for zoom fakeout */
	SGI(ifp)->si_yzoom = 1;	/* for zoom fakeout */
d519 1
d526 1
a526 1
RGBpixel	*pp;
d528 9
a536 1
	if ( pp != NULL)
d538 1
a538 1
	else
d540 2
d551 9
a559 1
	return(0);	/* Unable to do much */
d569 2
a570 5
	npts = ifp->if_width;
	if( npts > ifp->if_max_width )  npts = ifp->if_max_width;
	if( x < 1 )  x = 1;
	npts = npts / x;
	SGI(ifp)->si_xzoom = ifp->if_max_width/npts;
d572 13
a584 5
	npts = ifp->if_height;
	if( npts > ifp->if_max_height )  npts = ifp->if_max_height;
	if( y < 1 )  y = 1;
	npts = npts / y;
	SGI(ifp)->si_yzoom = ifp->if_max_height/npts;
d595 3
a597 4
	int scan_count;
	int xpos, ypos;
	RGBvalue rr[1024], gg[1024], bb[1024];
	register int i;
d600 3
a602 2
	if( SGI(ifp)->si_curs_on )
		cursoff();		/* Cursor interferes with reading! */
d608 4
a611 2
		if ( count >= ifp->if_width )  {
			scan_count = ifp->if_width;
d616 5
a620 2
		cmov2s( xpos, ypos );		/* move to current position */
		readRGB( scan_count, rr, gg, bb );
d622 1
a622 12
		for( i = 0; i < scan_count; i++, pixelp++)  {
			if ( _sgi_cmap_flag == FALSE )  {
				(*pixelp)[RED] = rr[i];
				(*pixelp)[GRN] = gg[i];
				(*pixelp)[BLU] = bb[i];
			} else {
				(*pixelp)[RED] = _sgi_cmap.cm_red[ rr[i] ];
				(*pixelp)[GRN] = _sgi_cmap.cm_green[ gg[i] ];
				(*pixelp)[BLU] = _sgi_cmap.cm_blue[ bb[i] ];
			}
		}

a626 2
	if( SGI(ifp)->si_curs_on )
		curson();		/* Cursor interferes with reading! */
d641 2
a642 1
	register char *cp;
d645 2
d650 1
a650 1
	cp = (char *)(*pixelp);
d663 1
d668 3
a670 2
			if( SGI(ifp)->si_xzoom > 1 )  {
				Coord l, b;
d676 3
d680 4
a683 2
				rectf( l, b,
					l+SGI(ifp)->si_xzoom, b+SGI(ifp)->si_yzoom);
a685 1
				cp += 3;
d695 1
a695 1
			if ( _sgi_cmap_flag == FALSE )  {
d697 3
a699 3
					hole->us = *cp++;
					hole->us = *cp++;
					hole->us = *cp++;
d703 3
a705 3
					hole->s = _sgi_cmap.cm_red[*cp++];
					hole->s = _sgi_cmap.cm_green[*cp++];
					hole->s = _sgi_cmap.cm_blue[*cp++];
d715 2
d736 3
d756 3
d765 1
a765 1
		_sgi_cmap_flag = FALSE;
d775 1
a775 1
	_sgi_cmap_flag = TRUE;
a830 16
#define Abs( x_ )	((x_) < 0 ? -(x_) : (x_))

#define MARGIN	4			/* # pixels margin to screen edge */
#define BANNER	18			/* Size of MEX title banner */
#define WIN_L	(1024-ifp->if_width-MARGIN)
#define WIN_R	(1024-MARGIN)
#define WIN_B	MARGIN
#define WIN_T	(ifp->if_height+MARGIN)

#define MAP_RESERVED	16		/* # slots reserved by MEX */
#define MAP_TOL		28		/* pixel delta across all channels */
/* TOL of 28 gives good rendering of the dragon picture without running out */
static int map_size;			/* # of color map slots available */

static RGBpixel	rgb_table[4096];

d834 1
a834 1
Colorindex
d910 1
a910 1
	SGI(ifp)->si_mode = 0;
d913 1
d916 5
a920 1
		(void)sscanf( cp, "%d", &SGI(ifp)->si_mode );
d935 1
d938 2
a940 5
	if( (SGI(ifp)->si_save = malloc( width*height*sizeof(Colorindex) )) == NULL )  {
		fb_log("sgw_dopen:  unable to malloc pixel buffer\n");
		return(-1);
	}
	bzero( SGI(ifp)->si_save, width*height*sizeof(Colorindex) );
d963 7
a981 1
	/* Mode 0 builds color map on the fly */
d983 2
a984 3
	if( SGI(ifp)->si_mode )
		{
		/* Mode 1 uses fixed color map */
d991 1
a991 1
		}
d995 1
a995 1
	sgw_cmwrite( ifp, COLORMAP_NULL );
d999 3
a1008 3
	free( SGI(ifp)->si_save );
	SGI(ifp)->si_save = (char *)0;

a1035 1
	bzero( SGI(ifp)->si_save, ifp->if_width*ifp->if_height*sizeof(Colorindex) );
a1044 1
	register Colorindex *p;
a1054 2
	for( cnt = ifp->if_width * ifp->if_height-1; cnt > 0; cnt-- )
		*p++ = i;
a1061 68
sgw_bread( ifp, x, y, pixelp, count )
FBIO	*ifp;
register int	x, y;
register RGBpixel	*pixelp;
int	count;
{	register union gepipe *hole = GEPIPE;
	int scan_count;
	Colorindex colors[1025];
	register int i;

	if( qtest() )
		sgw_inqueue(ifp);
	if( SGI(ifp)->si_curs_on )
		cursoff();		/* Cursor interferes with reading! */
	x *= SGI(ifp)->si_xzoom;
	while( count > 0 )
		{	register short	ypos = y*SGI(ifp)->si_yzoom;
		if ( count >= ifp->if_width )
			scan_count = ifp->if_width;
		else
			scan_count = count;
		if( (SGI(ifp)->si_xzoom == 1 && SGI(ifp)->si_yzoom == 1) || SGI(ifp)->si_special_zoom )
			{ /* No pixel replication, so read scan of pixels. */
			CMOV2S( hole, x, ypos );
			readpixels( scan_count, colors );
			}
		else
			{ /* We are sampling from rectangles
				(replicated pixels). */
			for( i = 0; i < scan_count; i++ )
				{
				CMOV2S( hole, x, ypos );
				x += SGI(ifp)->si_xzoom;
				readpixels( 1, &colors[i] );
				}
			}
		for( i = 0; i < scan_count; i++, pixelp++) 
			{
			if( SGI(ifp)->si_mode )
				{
				colors[i] -= MAP_RESERVED;
				(*pixelp)[RED] =   (colors[i] % 10 + 1) * 25;
				colors[i] /= 10;
				(*pixelp)[GRN] = (colors[i] % 10 + 1) * 25;
				colors[i] /= 10;
				(*pixelp)[BLU] =  (colors[i] % 10 + 1) * 25;
				}
			else
				{
				register int	ci = colors[i];
				if( ci < SGI(ifp)->si_rgb_ct )
					{
					COPYRGB( *pixelp, rgb_table[ci]);
					}
				else
					(*pixelp)[RED] = (*pixelp)[GRN] = (*pixelp)[BLU] = 0;
				}
			}
		count -= scan_count;
		x = 0;
		y++;
	}
	if( SGI(ifp)->si_curs_on )
		curson();		/* Cursor interferes with reading! */
	return	0;	
}

_LOCAL_ int
d1070 1
a1078 3
			register Colorindex *sp;
		sp = (Colorindex *)
			&SGI(ifp)->si_save[(y*ifp->if_width+x)*sizeof(Colorindex)];
d1083 3
a1085 1
		if( (SGI(ifp)->si_xzoom == 1 && SGI(ifp)->si_yzoom == 1) || SGI(ifp)->si_special_zoom )
d1099 1
a1099 8
					if( SGI(ifp)->si_mode )
						{
						colori =  MAP_RESERVED +
							((*pixelp)[RED]/26);
						colori += ((*pixelp)[GRN]/26) * 10;
						colori += ((*pixelp)[BLU]/26) * 100;
						}
					else
d1101 10
a1111 1
					*sp++ = colori;
d1122 6
a1127 2
				if( SGI(ifp)->si_mode )
					{
d1129 4
a1132 6
						((*pixelp)[RED]/26);
					col += ((*pixelp)[GRN]/26) * 10;
					col += ((*pixelp)[BLU]/26) * 100;
					}
				else
					col = get_Color_Index( ifp, pixelp );
a1136 1
				*sp++ = col;
a1162 69
sgw_cmread( ifp, cmp )
FBIO	*ifp;
register ColorMap	*cmp;
{
	register int i;

	if( qtest() )
		sgw_inqueue(ifp);
	/* Just parrot back the stored colormap */
	for( i = 0; i < 255; i++)
	{
		cmp->cm_red[i] = _sgi_cmap.cm_red[i]<<8;
		cmp->cm_green[i] = _sgi_cmap.cm_green[i]<<8;
		cmp->cm_blue[i] = _sgi_cmap.cm_blue[i]<<8;
	}
	return	0;
}

_LOCAL_ int
sgw_cmwrite( ifp, cmp )
FBIO	*ifp;
register ColorMap	*cmp;
{
	register int i;

	if( qtest() )
		sgw_inqueue(ifp);
	if ( cmp == COLORMAP_NULL)  {
		for( i = 0; i < 255; i++)  {
			_sgi_cmap.cm_red[i] = i;
			_sgi_cmap.cm_green[i] = i;
			_sgi_cmap.cm_blue[i] = i;
		}
		_sgi_cmap_flag = FALSE;
		return	0;
	}
	
	for(i = 0; i < 255; i++)  {
		_sgi_cmap.cm_red[i] = cmp -> cm_red[i]>>8;
		_sgi_cmap.cm_green[i] = cmp-> cm_green[i]>>8; 
		_sgi_cmap.cm_blue[i] = cmp-> cm_blue[i]>>8;

	}
	_sgi_cmap_flag = TRUE;
	return	0;
}

_LOCAL_ int
sgw_zoom_set( ifp, x, y )
FBIO	*ifp;
int	x, y;
	{
	if( qtest() )
		sgw_inqueue(ifp);
	if( x == 0 )  x = 1;
	if( y == 0 )  y = 1;
	if( x < 0 || y < 0 )
		{
		SGI(ifp)->si_special_zoom = 1;
		x = y = 1;
		}
	else
		SGI(ifp)->si_special_zoom = 0;
	SGI(ifp)->si_xzoom = x;
	SGI(ifp)->si_yzoom = y;
	return	0;
	}

_LOCAL_ int
d1257 1
a1257 8
		register int i;

		/* Redraw whole window from save area */
		for( i=0; i<ifp->if_height; i++ )  {
			cmov2s( 0, i );
			writepixels( ifp->if_width, (Colorindex *)
				&SGI(ifp)->si_save[i*ifp->if_width*sizeof(Colorindex)] );
		}
@


1.31
log
@20% speedup for 24-bit mode writes.
@
text
@a46 8
/* If there are any more of these, they ought to go into a malloc()d struct */
#define if_xzoom	u1.l
#define if_yzoom	u2.l
#define if_special_zoom	u3.l
#define if_mode		u4.l
#define if_rgb_ct	u5.l
#define if_save		u6.p

d180 16
d251 7
a257 2
	ifp->if_xzoom = 1;	/* for zoom fakeout */
	ifp->if_yzoom = 1;	/* for zoom fakeout */
d290 2
d340 1
a340 1
	ifp->if_xzoom = ifp->if_max_width/npts;
d346 1
a346 1
	ifp->if_yzoom = ifp->if_max_height/npts;
d363 2
d395 2
d434 1
a434 1
			if( ifp->if_xzoom > 1 )  {
d439 2
a440 2
				l = xpos * ifp->if_xzoom;
				b = ypos * ifp->if_yzoom;
d443 1
a443 1
					l+ifp->if_xzoom, b+ifp->if_yzoom);
d569 1
d575 2
a576 2
	x *= ifp->if_xzoom;
	y *= ifp->if_yzoom;
d616 1
a616 1
	for( i = 0, sp = rgb_table; i < ifp->if_rgb_ct; sp++, i++ ) {
d644 2
a645 2
		COPYRGB( rgb_table[ifp->if_rgb_ct], *pixelp);
		mapcolor(	(Colorindex)ifp->if_rgb_ct,
d650 1
a650 1
		return	(Colorindex)(ifp->if_rgb_ct++);
d674 6
a679 1
	ifp->if_mode = 0;
d684 1
a684 1
		(void)sscanf( cp, "%d", &ifp->if_mode );
d699 4
a702 4
	ifp->if_xzoom = 1;	/* for zoom fakeout */
	ifp->if_yzoom = 1;	/* for zoom fakeout */
	ifp->if_special_zoom = 0;
	if( (ifp->if_save = malloc( width*height*sizeof(Colorindex) )) == NULL )  {
d706 1
a706 1
	bzero( ifp->if_save, width*height*sizeof(Colorindex) );
d742 2
a743 2
	ifp->if_rgb_ct = MAP_RESERVED;
	if( ifp->if_mode )
d767 2
a768 2
	free( ifp->if_save );
	ifp->if_save = (char *)0;
d773 1
a773 1
		; /* winclose( ifp->if_fd ); */
d779 3
a781 1
/** 	fb_log( "%d color table entries used.\n", ifp->if_rgb_ct );  **/
d797 1
a797 1
	bzero( ifp->if_save, ifp->if_width*ifp->if_height*sizeof(Colorindex) );
d839 3
a841 1
	x *= ifp->if_xzoom;
d843 1
a843 1
		{	register short	ypos = y*ifp->if_yzoom;
d848 1
a848 1
		if( (ifp->if_xzoom == 1 && ifp->if_yzoom == 1) || ifp->if_special_zoom )
d859 1
a859 1
				x += ifp->if_xzoom;
d865 1
a865 1
			if( ifp->if_mode )
d877 1
a877 1
				if( ci < ifp->if_rgb_ct )
d889 2
d909 2
a910 2
			register short	ypos = y*ifp->if_yzoom;
			register short	xpos = x*ifp->if_xzoom;
d913 1
a913 1
			&ifp->if_save[(y*ifp->if_width+x)*sizeof(Colorindex)];
d918 1
a918 1
		if( (ifp->if_xzoom == 1 && ifp->if_yzoom == 1) || ifp->if_special_zoom )
d932 1
a932 1
					if( ifp->if_mode )
d950 2
a951 2
					register Coord	r = xpos + ifp->if_xzoom - 1,
							t = ypos + ifp->if_yzoom - 1;
d953 1
a953 1
				if( ifp->if_mode )
d965 1
a965 1
				xpos += ifp->if_xzoom;
d1051 1
a1051 1
		ifp->if_special_zoom = 1;
d1055 3
a1057 3
		ifp->if_special_zoom = 0;
	ifp->if_xzoom = x;
	ifp->if_yzoom = y;
d1104 1
d1111 2
a1112 2
	x *= ifp->if_xzoom;
	y *= ifp->if_yzoom;
d1162 1
a1162 1
				&ifp->if_save[i*ifp->if_width*sizeof(Colorindex)] );
d1164 1
@


1.30
log
@This version is faster in RGB mode,
remembers screen in MEX mode, and repaints when REDRAW is signalled.
Also has code to default screen size on size 0;
RGB mode is full screen, MEX mode is 512x512
@
text
@d59 1
a59 2
	unsigned char uc;
	char	c;
d392 1
a392 1
	register unsigned char *cp;
d398 1
a398 1
	cp = (unsigned char *)(*pixelp);
a410 1
		GEP_END(hole)->s = (0xFF<<8)|8;	/* im_last_passthru(0) */
d439 3
a441 3
					hole->s = *cp++;
					hole->s = *cp++;
					hole->s = *cp++;
a450 1
		GEP_END(hole)->s = (0xFF<<8)|8;	/* im_last_passthru(0) */
d456 1
@


1.29
log
@Added ifp parameter to get_Color_Index()
@
text
@d1 2
d28 1
a28 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.28 86/11/25 04:01:14 mike Exp $ (BRL)";
d40 4
d45 2
d53 1
d59 2
d153 1
d176 2
a177 2
		1024,			/* current/default width  */
		768,			/* current/default height */
d214 2
d218 1
a218 1
		gexit();
d220 1
d231 4
d386 1
a386 1
register RGBpixel	*pixelp;
d393 1
d399 1
d419 3
a421 3
				RGBcolor( (short)((*pixelp)[RED]),
					(short)((*pixelp)[GRN]),
					(short)((*pixelp)[BLU]) );
d429 1
a429 1
				pixelp++;
d440 4
a443 4
				for( ; chunk>0; chunk--,pixelp++ )  {
					hole->s = (*pixelp)[RED];
					hole->s = (*pixelp)[GRN];
					hole->s = (*pixelp)[BLU];
d446 4
a449 4
				for( ; chunk>0; chunk--,pixelp++ )  {
					hole->s = _sgi_cmap.cm_red[(*pixelp)[RED]];
					hole->s = _sgi_cmap.cm_green[(*pixelp)[GRN]];
					hole->s = _sgi_cmap.cm_blue[(*pixelp)[BLU]];
a575 1
#define MAP_SIZE	1024		/* # slots available, incl reserved */
d578 1
d580 1
a580 1
static RGBpixel	rgb_table[MAP_SIZE];
d625 1
a625 1
	if( i < MAP_SIZE )  {
d661 1
a661 1
		sscanf( cp, "%d", &ifp->if_mode );
d663 5
a669 1

d679 7
a685 3
	
	if( ismex() )
		{
d687 1
a687 1
		foreground();
d693 9
a701 3
		wintitle( "frame buffer" );
		}
	else
d703 4
d723 1
a723 1
		for( i = 0; i < MAP_SIZE-MAP_RESERVED; i++ )
a730 2
	singlebuffer();
	gconfig();	/* Must be called after singlebuffer().	*/
d744 6
a749 1
	if( ismex() )
d751 2
a752 2
	else
		{
d755 1
a755 1
		}
d768 2
d772 1
d781 6
d788 1
a788 1
		color( get_Color_Index( ifp, pp ) );
d790 6
a795 1
		color( BLACK );
d812 2
d868 1
a868 1
register int	x, y;
d875 2
a877 1
	x *= ifp->if_xzoom;
d879 6
a884 1
		{	register short	ypos = y*ifp->if_yzoom;
d891 1
a891 1
			CMOV2S( hole, x, ypos );
d893 1
a893 1
				{	register int	chunk;
d913 1
d921 1
a921 1
					register Coord	r = x + ifp->if_xzoom - 1,
d923 1
a923 1
				CMOV2S( hole, x, ypos );
d935 3
a937 2
				im_rectf( (Coord)x, (Coord)ypos, r, t );
				x += ifp->if_xzoom;
d951 2
d970 2
d989 2
d1016 2
d1041 3
d1073 2
d1089 47
@


1.28
log
@Changed some shorts to ints to allow large writes to work.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.27 86/11/25 03:18:00 mike Locked $ (BRL)";
d565 2
a566 1
get_Color_Index( pixelp )
d737 1
a737 1
		color( get_Color_Index( pp ) );
d847 1
a847 1
						colori = get_Color_Index( pixelp );
d867 1
a867 1
					col = get_Color_Index( pixelp );
@


1.27
log
@Changed default open size to full screen.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.26 86/11/21 01:16:22 mike Locked $ (BRL)";
d187 1
a187 1
	short x_pos, y_pos;	/* Lower corner of viewport */
a265 3
	short x_pos, y_pos;	/* Lower corner of viewport */

	
d324 2
a325 2
	short scan_count;
	short xpos, ypos;
d366 1
a366 1
short	x, y;
d368 1
a368 1
short	count;
d371 3
a373 3
	register short scan_count;
	short xpos, ypos;
	register short i;
d751 1
a751 1
	short scan_count;
d813 1
a813 1
		short scan_count;
@


1.26
log
@Fixed problem with if_name preservation on roll-over to 12-bit mode.
Moved rgb_ct into FBIO structure user variable,
reinitialized on each open.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.25 86/11/18 13:13:53 mike Locked $ (BRL)";
d113 2
a114 2
		512,			/* current/default width  */
		512,			/* current/default height */
d164 2
a165 2
		512,			/* current/default width  */
		512,			/* current/default height */
d317 1
@


1.25
log
@If less than 24 bits present, also use 12-bit interface.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.24 86/11/18 12:59:03 mike Locked $ (BRL)";
d39 1
d44 1
d191 3
d195 1
a561 1
static int	rgb_ct = MAP_RESERVED;
d578 1
a578 1
	for( i = 0, sp = rgb_table; i < rgb_ct; sp++, i++ ) {
d606 2
a607 2
		COPYRGB( rgb_table[rgb_ct], *pixelp);
		mapcolor(	(Colorindex)rgb_ct,
d612 1
a612 1
		return	(Colorindex)(rgb_ct++);
d681 1
d715 1
a715 1
/** 	fb_log( "%d color table entries used.\n", rgb_ct );  **/
d793 1
a793 1
				if( ci < rgb_ct )
@


1.24
log
@Combined 24-bit and 12-bit version of if_sgi.c
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.23 86/11/17 20:28:11 mike Exp $ (BRL)";
d196 5
a200 3
		fb_log("Only %d bit planes?  24 required\n", getplanes());
		(void)sgi_dclose(ifp);
		return(-1);
@


1.23
log
@Turned off cursor.
@
text
@d4 6
d12 1
d26 1
a26 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.22 86/11/17 20:20:42 mike Locked $ (BRL)";
d30 1
d38 5
d55 1
a55 1
#define GEPIPE	((union gepipe *)0X00FD5000)
d57 1
a57 1
#define GEPIPE	((union gepipe *)0X60001000)
d59 1
d62 8
d125 50
a187 2
	noport();
	gbegin();		/* not ginit() */
d189 2
a190 3
		fb_log("libfb/if_sgi can't run under MEX\n");
		(void)sgi_dclose(ifp);
		return(-1);
d192 1
d217 2
a218 2
#define if_pixsize	u1.l
	ifp->if_pixsize = 1;	/* for zoom fakeout */
d297 1
d299 1
a299 1
	if( npts > 768 )  npts = 768;
d302 7
a308 1
	ifp->if_pixsize = 768/npts;
d374 1
a374 1
		if( ypos >= 768 )  return(0);
d390 1
a390 1
			if( ifp->if_pixsize > 1 )  {
d395 2
a396 2
				l = xpos * ifp->if_pixsize;
				b = ypos * ifp->if_pixsize;
d399 1
a399 1
					l+ifp->if_pixsize, b+ifp->if_pixsize);
d524 1
a524 1
	{	static Colorindex	cursor_color = YELLOW;
a527 1
		setcursor( 0, 1, 0xFFFF );
d530 2
a531 2
	x *= ifp->if_pixsize;
	y *= ifp->if_pixsize;
d533 1
a533 1
	setcursor( 1, cursor_color, 0xFFFF );
d536 465
@


1.22
log
@Moss's cursor additions.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.21 86/11/14 04:36:17 phil Exp $ (BRL)";
d131 1
@


1.21
log
@curs_set change.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.20 86/10/29 01:37:27 phil Locked $ (BRL)";
d24 1
d48 4
d82 2
a84 2
		fb_null,
		fb_null,
d148 3
d362 1
a362 1
	viewport( left, right, top, bottom );
d409 52
@


1.20
log
@removed pbytes
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.19 86/10/28 19:53:55 phil Locked $ (BRL)";
d59 1
a59 1
		sgi_cinit_bitmap(),
@


1.19
log
@one more 1st quadrant problem.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.18 86/10/28 17:57:21 mike Locked $ (BRL)";
a92 1
		0L,			/* page_bytes */
@


1.18
log
@added if_debug
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.17 86/10/28 15:32:11 phil Locked $ (BRL)";
d345 1
a345 1
		ypos--;		/* LEFTOVER from 1st quadrant days */
@


1.17
log
@Added blanktime changes.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.16 86/10/25 19:04:44 mike Exp $ (BRL)";
d94 2
a95 1
		0L			/* page_pixels */
@


1.16
log
@Minor additions to open.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.15 86/10/25 16:20:51 mike Locked $ (BRL)";
d114 1
a114 1
		fb_log("libfb can't run under MEX\n");
d127 2
d165 1
@


1.15
log
@Changed multi-line transfers to head towards increasing y.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.14 86/10/25 10:54:56 mike Locked $ (BRL)";
d111 1
d113 5
@


1.14
log
@RGBpixel conversion
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.13 86/10/24 04:22:11 phil Locked $ (BRL)";
d257 1
a257 1
		ypos--;		/* LEFTOVER from 1st quadrant days */
@


1.13
log
@read and write return number of pixels.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.12 86/10/24 03:39:29 phil Locked $ (BRL)";
d24 1
d185 1
a185 1
Pixel	*pp;
d188 1
a188 1
		RGBcolor((short) pp->red, (short)pp->green, (short)pp->blue);
d220 1
a220 1
register Pixel	*pixelp;
d241 1
a241 1
		readRGB( scan_count, rr, gg, bb ); 
d245 3
a247 3
				pixelp->red = rr[i];
				pixelp->green = gg[i];
				pixelp->blue = bb[i];
d249 3
a251 3
				pixelp->red = _sgi_cmap.cm_red[ rr[i] ];
				pixelp->green = _sgi_cmap.cm_green[ gg[i] ];
				pixelp->blue = _sgi_cmap.cm_blue[ bb[i] ];
d266 1
a266 1
register Pixel	*pixelp;
d297 3
a299 3
				RGBcolor( (short)pixelp->red,
					(short)pixelp->green,
					(short)pixelp->blue );
d319 3
a321 3
					hole->s = pixelp->red;
					hole->s = pixelp->green;
					hole->s = pixelp->blue;
d325 3
a327 3
					hole->s = _sgi_cmap.cm_red[pixelp->red];
					hole->s = _sgi_cmap.cm_green[pixelp->green];
					hole->s = _sgi_cmap.cm_blue[pixelp->blue];
@


1.12
log
@local fbio variable change.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.11 86/10/11 22:47:23 phil Locked $ (BRL)";
d226 1
d228 1
d258 1
a258 1
	return(0);
d272 1
d274 1
d336 1
a336 1
	return(0);
@


1.11
log
@Changed to leave Iris screen undisturbed at end of program.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.9 86/10/10 22:48:19 mike Locked $ (BRL)";
d132 1
a132 1
#define if_pixsize	if_pref
@


1.10
log
@Added "big pixels" capability to simulate zoom.
@
text
@d137 15
d156 1
d160 1
@


1.9
log
@Faster version which outputs to GEpipe directly.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.8 86/10/06 22:44:20 phil Exp $ (BRL)";
d74 2
a78 2
		fb_null,
		fb_null,
d112 7
a118 1
	gconfig();		/* Must be called after RGBmode() */
a119 1

d131 3
d141 1
d143 1
d178 21
d257 1
a257 1
		if( xpos >= 768 )  return(0);
d271 1
a271 1
			register int chunk;
d273 15
@


1.8
log
@Added /dev/name convention.
@
text
@d2 15
a16 13
  Author -
	Paul R. Stay

  Source -
	SECAD/VLD Computing Consortium, Bldg 394
	The U. S. Army Ballistic Research Laboratory
	Aberdeen Proving Ground, Maryland  21005-5066
  
  Copyright Notice -
	This software is Copyright (C) 1986 by the United States Army.
	All rights reserved.

	$Header: if_sgi.c,v 1.7 86/10/06 21:26:21 phil Locked $ (BRL)
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.7 86/10/06 21:26:21 phil Locked $ (BRL)";
d24 1
d28 19
d126 1
a126 1
	
d133 1
d135 1
d151 1
d164 1
d208 1
d218 2
a219 1
	short scan_count;
d221 1
a221 2
	RGBvalue rr[1024], gg[1024], bb[1024];
	register int i;
d226 1
d233 5
a237 1
		cmov2s( xpos, ypos );		/* move to current position */
d239 10
a248 1
		for( i = 0; i < scan_count; i++, pixelp++)  {
d250 11
a260 10
				rr[i] = (RGBvalue) pixelp->red;
				gg[i] = (RGBvalue) pixelp->green;
				bb[i] = (RGBvalue) pixelp->blue;
			}  else  {
				rr[i] = (RGBvalue) 
				    _sgi_cmap.cm_red[ (int) pixelp->red ];
				gg[i] = (RGBvalue) 
				    _sgi_cmap.cm_green[ (int) pixelp->green ];
				bb[i] = (RGBvalue) 
				    _sgi_cmap.cm_blue[ (int) pixelp->blue ];
d263 1
a263 1
		writeRGB( scan_count, rr, gg, bb ); 
d269 1
d278 1
@


1.7
log
@Converted to 1st Quadrant semantics
Plus bug fixes
@
text
@d14 1
a14 1
	$Header: if_sgi.c,v 1.6 86/10/03 22:59:08 mike Exp $ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.6 86/10/03 22:59:08 mike Exp $ (BRL)";
d60 1
a60 1
		"sgi",
@


1.6
log
@do pseudo-dma in descending order.
@
text
@d14 1
a14 1
	$Header: if_sgi.c,v 1.5 86/10/03 22:28:46 mike Exp $ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.5 86/10/03 22:28:46 mike Exp $ (BRL)";
d75 1
a75 1
int _sgi_cmap_flag;
d77 1
a77 1
ColorMap _sgi_cmap;
d86 1
a86 1

d88 1
a88 1
	ginit();
d93 2
a94 1
	_sgi_cmap_flag = FALSE;
d145 1
a145 1
Pixel	*pixelp;
a150 2
	Pixel * pixptr;
	int first_time;
a151 1
	int x_pos, y_pos;
d153 2
a154 1
	first_time = 1;
d156 5
a160 10
	pixptr = pixelp;

	while( count > 0 )
	{
		if (first_time)
		{
			first_time = 0;
			scan_count = ifp->if_width - x;
			xpos = x;
			ypos = y;
a163 1

d166 9
a174 7
		for( i = 0; i < scan_count; i++, pixptr++)
		{
			if ( _sgi_cmap_flag == FALSE )
			{
				pixptr->red = rr[i];
				pixptr->green = gg[i];
				pixptr->blue = bb[i];
a175 6
			else
			{
				pixptr->red = _sgi_cmap.cm_red[ rr[i] ];
				pixptr->green = _sgi_cmap.cm_green[ gg[i] ];
				pixptr->blue = _sgi_cmap.cm_blue[ bb[i] ];
			}
d178 2
a179 8
		if ( count >= ifp->if_width )  {
			scan_count = ifp->if_width;
			count -= scan_count;
		} else	{
			scan_count = 0;
			count = 0;
		}
		x_pos = 0;
d188 1
a188 1
Pixel	*pixelp;
a193 2
	Pixel * pixptr;
	int first_time;
a194 1
	int x_pos, y_pos;
d196 7
a202 12
	first_time = 1;
	
	pixptr = pixelp;

	while( count > 0 )
	{
		if (first_time)
		{
			first_time = 0;
			scan_count = ifp->if_width - x;
			xpos = x;
			ypos = y;
d207 6
a212 10
		for( i = 0; i < scan_count; i++, pixptr++)
		{
			if ( _sgi_cmap_flag == FALSE )
			{
				rr[i] = (RGBvalue) pixptr->red;
				gg[i] = (RGBvalue) pixptr->green;
				bb[i] = (RGBvalue) pixptr->blue;
			}
			else
			{
d214 1
a214 1
				    _sgi_cmap.cm_red[ (int) pixptr->red ];
d216 1
a216 1
				    _sgi_cmap.cm_green[ (int) pixptr->green ];
d218 1
a218 1
				    _sgi_cmap.cm_blue[ (int) pixptr->blue ];
a220 1

d223 1
a223 7
		if ( count >= ifp->if_width )  {
			scan_count = ifp->if_width;
			count -= scan_count;
		} else	{
			scan_count = 0;
			count = 0;
		}
d238 1
a238 1
DEVNAME_cmread( ifp, cmp )
d240 1
a240 1
ColorMap	*cmp;
d244 1
d247 3
a249 3
		cmp->cm_red[i] = _sgi_cmap.cm_red[i];
		cmp->cm_green[i] = _sgi_cmap.cm_green[i];
		cmp->cm_blue[i] = _sgi_cmap.cm_blue[i];
d251 1
d255 1
a255 1
DEVNAME_cmwrite( ifp, cmp )
d257 1
a257 1
ColorMap	*cmp;
d261 8
a268 3
	if ( cmp == ( ColorMap *) 0)
	{
		return -1;
d271 4
a274 1
	_sgi_cmap_flag = TRUE;
a275 6
	for(i = 0; i < 255; i++)
	{
		_sgi_cmap.cm_red[i] = cmp -> cm_red[i];
		_sgi_cmap.cm_green[i] = cmp-> cm_green[i]; 
		_sgi_cmap.cm_blue[i] = cmp-> cm_blue[i];

d277 2
@


1.5
log
@Fixed minor buffering problem.
@
text
@d14 1
a14 1
	$Header: if_sgi.c,v 1.4 86/10/03 13:11:12 stay Exp $ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.4 86/10/03 13:11:12 stay Exp $ (BRL)";
a191 2
			x_pos = 0;
			ypos++;
a194 2
			x_pos = 0;
			ypos++;
d196 2
d230 1
a230 1
		cmov2s( xpos, ypos++ );		/* move to current position */
d261 1
@


1.4
log
@Fix buffered io
@
text
@d14 1
a14 1
	$Header: if_sgi.c,v 1.3 86/10/03 06:14:51 stay Exp $ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.3 86/10/03 06:14:51 stay Exp $ (BRL)";
a164 8
			if ( count > scan_count )
				count -= scan_count;
			else
			{
				scan_count = count;
				count = 0;
			}

a227 8
			if ( count > scan_count )
				count -= scan_count;
			else
			{
				scan_count = count;
				count = 0;
			}

a232 1

@


1.3
log
@*** empty log message ***
@
text
@d14 1
a14 1
	$Header: if_sgi.c,v 1.2 86/10/03 06:03:36 stay Exp $ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.2 86/10/03 06:03:36 stay Exp $ (BRL)";
a87 3
	ifp->if_width = width;
	ifp->if_height = height;
	
d101 3
a103 2
	x_pos = ( ifp->if_max_width - width ) /2;
	y_pos = ( ifp->if_max_height - height ) /2;
d197 2
a198 2
		if ( count >= ifp->if_max_width )  {
			scan_count = ifp->if_max_width;
d201 1
a201 1
			ypos--;
d206 1
a206 1
			ypos--;
d248 1
a248 1
		cmov2s( xpos, ypos );		/* move to current position */
d272 2
a273 2
		if ( count >= ifp->if_max_width )  {
			scan_count = ifp->if_max_width;
a274 2
			x_pos = 0;
			ypos--;
a277 2
			x_pos = 0;
			ypos--;
d279 1
@


1.2
log
@Updated version with Color map 
@
text
@d14 1
a14 1
	$Header$ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
@


1.1
log
@Initial revision
@
text
@d74 5
d95 3
d150 2
a151 2
	Coord xpos, ypos;
	static RGBvalue rr[1024], gg[1024], bb[1024];
a157 1
	
a158 2
	pixelp = (Pixel *) malloc( sizeof( Pixel) * count );

a166 1

d174 1
d176 1
a176 1
			ypos = ifp->if_height - y;
d179 1
a179 3
		cmov2i( xpos, ypos-- );		/* move to current position */
		
		readRGB( scan_count, rr, gg, bb );
d181 2
d185 12
a196 3
			pixptr->red = rr[i];
			pixptr->green = gg[i];
			pixptr->blue = bb[i];
d199 1
a199 2
		if ( count >= ifp->if_max_width )
		{
d203 2
a204 2
		} else
		{
d208 1
d255 15
a269 3
			rr[i] = (RGBvalue) pixptr->red;
			gg[i] = (RGBvalue) pixptr->green;
			bb[i] = (RGBvalue) pixptr->blue;
d296 37
@
