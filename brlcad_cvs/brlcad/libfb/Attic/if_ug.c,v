head	11.5;
access;
symbols
	ansi-20040405-merged:11.2.6.1
	postmerge-20040405-ansi:11.3
	premerge-20040404-ansi:11.3
	postmerge-autoconf:11.3
	autoconf-freeze:11.2.14.2
	premerge-autoconf:11.3
	ansi-20040316-freeze:11.2
	postmerge-20040315-windows:11.3
	premerge-20040315-windows:11.3
	windows-20040315-freeze:11.2.8.1
	autoconf-20031203:11.2
	autoconf-20031202:11.2
	autoconf-branch:11.2.0.14
	phong-branch:11.2.0.12
	photonmap-branch:11.2.0.10
	rel-6-1-DP:11.2
	windows-branch:11.2.0.8
	rel-6-0-2:11.2
	ansi-branch:11.2.0.6
	rel-6-0-1-branch:11.2.0.4
	hartley-6-0-post:11.2
	hartley-6-0-pre:11.2
	rel-6-0-1:11.2
	rel-6-0:11.2
	rel-5-4:11.2
	offsite-5-3-pre:11.2
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1;
locks; strict;
comment	@ * @;


11.5
date	2004.05.21.18.07.25;	author morrison;	state dead;
branches;
next	11.4;

11.4
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	11.3;

11.3
date	2004.02.02.17.39.13;	author morrison;	state Exp;
branches;
next	11.2;

11.2
date	98.06.27.04.29.17;	author mike;	state Exp;
branches
	11.2.6.1
	11.2.8.1
	11.2.14.1;
next	11.1;

11.1
date	95.01.04.09.53.10;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.12.20.25.55;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.37.33;	author mike;	state Rel4_0;
branches;
next	9.4;

9.4
date	91.07.26.22.41.17;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.12.11.22.52.46;	author phil;	state Exp;
branches;
next	9.2;

9.2
date	89.09.01.01.46.52;	author phil;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.48.18;	author mike;	state Rel3_5;
branches;
next	8.2;

8.2
date	89.03.03.05.54.53;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.27.50;	author mike;	state Rel3_0;
branches;
next	7.2;

7.2
date	88.09.09.23.42.02;	author phil;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.27.10;	author mike;	state Rel;
branches;
next	1.1;

1.1
date	87.09.03.01.09.41;	author mike;	state Exp;
branches;
next	;

11.2.6.1
date	2004.03.17.21.17.02;	author morrison;	state Exp;
branches;
next	;

11.2.8.1
date	2004.03.11.23.42.07;	author morrison;	state Exp;
branches;
next	;

11.2.14.1
date	2004.02.12.19.48.12;	author erikg;	state Exp;
branches;
next	11.2.14.2;

11.2.14.2
date	2004.03.15.14.06.20;	author erikg;	state Exp;
branches;
next	;


desc
@Frame Buffer interface for Ultra Graphics display
@


11.5
log
@moved to src/
@
text
@/*
 *			I F _ U G . C
 *
 *  Ultra Network Technologies "Ultra Graphics" Display Device.
 *  			PRELIMINARY!
 *
 *  BRL NOTE: This is only the scant beginnings of an Ultra interface.
 *   We have no way of testing this, and given the changes in LIBFB this
 *   code may not even compile any longer.  If you make improvements to
 *   this please let us know. <phil@@brl.mil>
 *
 *  Authors -
 *	Michael John Muuss
 *	Phillip Dykstra
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 *
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libfb/if_ug.c,v 11.4 2004/05/10 15:30:45 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <errno.h>

#include "machine.h"
#include "externs.h"		/* For malloc */
#include "fb.h"
#include "./fblocal.h"
#include <ultra/ugraf.h>

#define	FBSAVE	"/usr/tmp/ultrafb"

static struct UG_PARAM	ug_param;
static struct UG_TBLK	ug_tblk;
static char	*ugbuf, *ugbuf2, *ugcurs;
static int	x_zoom, y_zoom;
static int	x_window, y_window;	/* upper left of window (4th quad) */

_LOCAL_ int	ug_open(),
		ug_close(),
		ug_clear(),
		ug_read(),
		ug_write(),
		ug_rmap(),
		ug_wmap(),
		ug_view(),
		ug_setcursor(),
		ug_cursor(),
		ug_help();

/* This is the ONLY thing that we normally "export" */
FBIO ug_interface =  {
	0,
	ug_open,		/* device_open		*/
	ug_close,		/* device_close		*/
	ug_clear,		/* device_clear		*/
	ug_read,		/* buffer_read		*/
	ug_write,		/* buffer_write		*/
	ug_rmap,		/* colormap_read	*/
	ug_wmap,		/* colormap_write	*/
	ug_view,		/* set view		*/
	fb_sim_getview,		/* get view		*/
	ug_setcursor,		/* curs_set		*/
	ug_cursor,		/* cursor_move_memory_addr */
	fb_sim_getcursor,
	fb_sim_readrect,
	fb_sim_writerect,
	fb_sim_bwreadrect,
	fb_sim_bwwriterect,
	fb_null,			/* poll			*/
	fb_null,			/* flush		*/
	ug_close,			/* free			*/
	fb_null,			/* XXX add help here	*/
	"Ultra Graphics",		/* device description	*/
	1280,				/* max width		*/
	1024,				/* max height		*/
	"/dev/ug",			/* short device name	*/
	512,				/* default/current width  */
	512,				/* default/current height */
	-1,				/* select fd		*/
	-1,				/* file descriptor	*/
	1, 1,				/* zoom			*/
	256, 256,			/* window center	*/
	0, 0, 0,			/* cursor		*/
	PIXEL_NULL,			/* page_base		*/
	PIXEL_NULL,			/* page_curp		*/
	PIXEL_NULL,			/* page_endp		*/
	-1,				/* page_no		*/
	0,				/* page_dirty		*/
	0L,				/* page_curpos		*/
	0L,				/* page_pixels		*/
	0				/* debug		*/
};

ugprint( pp )
register struct UG_PARAM *pp;
{
	register struct UG_TBLK *tp;

	fprintf(stderr, "intern = %d\n", pp->intern);
	fprintf(stderr, "buffer = x%x\n", pp->buffer);
	fprintf(stderr, "dev_id = %s\n", pp->dev_id);
	fprintf(stderr, "dx = %d\n", pp->dx);
	fprintf(stderr, "dy = %d\n", pp->dy);
	fprintf(stderr, "term_type = %d\n", pp->term_type);
	fprintf(stderr, "blank = %d\n", pp->blank);
	fprintf(stderr, "buf_ctl = %d\n", pp->buf_ctl);
	fprintf(stderr, "link = x%x\n\n", pp->link);

	for( tp = pp->link; tp; tp = tp->link )  {
		fprintf(stderr, "addr = x%x\n", tp->addr);
		fprintf(stderr, "tx = %d\n", tp->tx);
		fprintf(stderr, "ty = %d\n", tp->ty);
		fprintf(stderr, "npixel = %d\n", tp->npixel);
		fprintf(stderr, "nline = %d\n", tp->nline);
		fprintf(stderr, "stride = %d\n", tp->stride);
		fprintf(stderr, "link = x%x\n\n", tp->link);
	}
}

_LOCAL_ int
ug_open( ifp, file, width, height )
FBIO	*ifp;
char	*file;
int	width, height;
{
	register int	i;
	int	status;
 	FILE	*fp;

	FB_CK_FBIO(ifp);

	ug_param.dx = ug_param.dy = 0;
	ug_param.buffer = 0;			/* No copy buffer */
	ug_param.dev_id = (char *)0;
	ug_param.term_type = UG_C7400;
	ug_param.blank = 0;
	ug_param.buf_ctl = NULL;
	ug_param.link = NULL;

	if( width <= 0 )
		width = ifp->if_width;
	if( height <= 0 )
		height = ifp->if_height;
	if ( width > ifp->if_max_width) 
		width = ifp->if_max_width;

 	ifp->if_width = width;
	ifp->if_height = height;

	x_zoom = y_zoom = 1;
	x_window = 0;
	y_window = 0;

	if( (ugbuf = malloc( width*height*4 )) == NULL )  {
		fprintf(stderr,"ug_open: malloc failure\n");
		return(-1);
	}
	if( (ugbuf2 = malloc( width*height*4 )) == NULL )  {
		fprintf(stderr,"ug_open: malloc 2 failure\n");
		return(-1);
	}
	if ( ( ugcurs = malloc( 16 * 16 * 4)) == NULL ) {
		fprintf(stderr, "ug_open: malloc failure\n");
		return(-1);
	}

	/* Do this after the malloc call -- UNICOS swapping bug */
	if ( ( status = ugraf ( UG_OPEN | UG_NORESET, &ug_param ) ) != UGE_OK ) {
		perror ( "ugraf open" );
		fprintf(stderr, "ugraf open failed with %d\n", status );
		return(-1);
	}

	if( (fp = fopen(FBSAVE, "r")) != NULL ) {
		fread( ugbuf, 4, height*width, fp );
		fclose( fp );
		unlink(FBSAVE);
	}
	
	return(1);			/* OK */
}

_LOCAL_ int
ug_close( ifp )
FBIO	*ifp;
{
	int	status;
	FILE	*fp;

	/* save image to file */
	if( (fp = fopen(FBSAVE, "w")) != NULL ) {
		fwrite( ugbuf, 4, ifp->if_height*ifp->if_width, fp );
		fclose( fp );
	} else {
		fprintf( stderr, "can't save framebuffer, errno = %d\n", errno );
	}

	/* Send whole buffer out one last time */
	ug_tblk.tx = 0;
	ug_tblk.ty = 0;
	ug_tblk.npixel = ifp->if_width;
	ug_tblk.nline = ifp->if_height;
	ug_tblk.addr = (int *)ugbuf;
	write_ug ("dclose");

	/* Now, close down */
	if ( ( status = ugraf ( UG_CLOSE, &ug_param ) ) != UGE_OK ) {
		perror ( "ugraf close" );
		fprintf(stderr, "ugraf close failed with %d\n", status );
		exit ( 1 );
	}
	return;
}

_LOCAL_ int
ug_clear( ifp, pp )
FBIO	*ifp;
RGBpixel	*pp;
{
	if( pp == RGBPIXEL_NULL )  {
		bzero( ugbuf, ifp->if_width * ifp->if_height * 4 );
	} else {
		register char *cp;
		register int todo;

		cp = &ugbuf[0];
		for( todo = ifp->if_width * ifp->if_height; todo > 0; todo-- )  {
			cp++;
			*cp++ = (*pp)[BLU];
			*cp++ = (*pp)[GRN];
			*cp++ = (*pp)[RED];
		}
	}

	ug_tblk.tx = 0;
	ug_tblk.ty = 0;
	ug_tblk.npixel = ifp->if_width;
	ug_tblk.nline = ifp->if_height;
	ug_tblk.addr = (int *)ugbuf;

	/* Do it twice to fill both buffers */
	write_ug ("dclear1");
	write_ug ("dclear2");

	return(0);
}

_LOCAL_ int
ug_read( ifp, x, y, pixelp, count )
FBIO	*ifp;
int	x, y;
RGBpixel	*pixelp;
int	count;
{
}

static write_ug (str)
char *str;
{
	int	status;

	ug_tblk.link = NULL;
	ug_tblk.stride = 0;

/**	ug_param.buf_ctl = UG_SW | UG_SW_H;	/* Flip after dump */
	ug_param.buf_ctl = UG_SW;	/* Flip after dump */
	ug_param.link = &ug_tblk;

	if ( ( status = ugraf ( UG_WRITE, &ug_param ) ) != UGE_OK ) {
		perror ( "ugraf write" );
		fprintf(stderr, "ugraf write error %d at %s\n", status, str );
		ugprint( &ug_param );
		return(-1);
	}

#ifndef never
	if ( ( status = ugraf ( UG_WAIT, &ug_param ) ) != UGE_OK ) {
		fprintf(stderr,"ugraf wait failed with %d at %s\n", status, str );
		perror ( "ugraf wait" );
		exit ( 1 );
	}
#endif
}

_LOCAL_ int
ug_write( ifp, x, y, pixelp, count )
FBIO	*ifp;
register int	x, y;
register char	*pixelp;
int	count;
{
	register char	*cp;
	register int	todo;
	int	start_y;
	
	y = ifp->if_height-1 - y;
	start_y = y;
	cp = &ugbuf[ ((y * ifp->if_width) + x)*4 ];
	for( todo = count; todo > 0; todo--, pixelp+=3 )  {
		if( ++x > ifp->if_width )  {
			y--;	/* 1st quadrant now */
			x = 0;
			cp = &ugbuf[ ((y * ifp->if_width) + x)*4 ];
		}
		cp++;
		*cp++ = (pixelp)[BLU];
		*cp++ = (pixelp)[GRN];
		*cp++ = (pixelp)[RED];
	}

	/* check for special zoom/window display */
	if( x_zoom != 1 || y_zoom != 1 || x_window != 0 || y_window != 0 ) {
		zandw( ifp );
		return( count );
	}

	ug_tblk.tx = 0;
	ug_tblk.ty = y;
	ug_tblk.npixel = ifp->if_width;
	ug_tblk.nline = start_y - y +1;
	ug_tblk.addr = (int *)(ugbuf + y*4*ifp->if_width);

	write_ug ( );
	write_ug ( );		/* Simulate a single buffered device */

	return(count);
}

_LOCAL_ int
ug_rmap( ifp, cmp )
FBIO	*ifp;
ColorMap	*cmp;
{
}

_LOCAL_ int
ug_wmap( ifp, cmp )
FBIO	*ifp;
ColorMap	*cmp;
{
}

_LOCAL_ int
ug_view( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	xcenter, ycenter;
int	xzoom, yzoom;
{
	int	ugx, ugy;

	/*
	 *  To start with, we are given the 1st quadrant coordinates
	 *  of the CENTER of the region we wish to view.  Since the
	 *  Ultra device is fourth quadrant,
	 *  first find the upper left corner of the rectangle
	 *  to window in on, accounting for the zoom factor too.
	 *  Then convert from first to fourth for the Ultra.
	 *  The order of these conversions is significant.
	 */
	ugx = xcenter - (ifp->if_width / x_zoom)/2;
	ugy = ycenter + (ifp->if_height / y_zoom)/2 - 1;
	ugy = ifp->if_height-1-ugy;		/* q1 -> q4 */

	/* save q4 upper left */
	x_window = ugx;
	y_window = ugy;

	/* Window needs to be set as well XXX */
	if( xzoom < 1 )  xzoom=1;
	if( yzoom < 1 )  yzoom=1;
	if( xzoom > 256 )  xzoom=256;
	if( yzoom > 256 )  yzoom=256;

	x_zoom = xzoom;
	y_zoom = yzoom;

	fb_sim_view(ifp, xcenter, ycenter, xzoom, yzoom);

	zandw( ifp );
}

_LOCAL_ int
ug_setcursor( ifp, bits, xbits, ybits, xorig, yorig )
FBIO	*ifp;
unsigned char *bits;
int	xbits, ybits;
int	xorig, yorig;
{
}

_LOCAL_ int
ug_cursor( ifp, mode, x, y )
FBIO	*ifp;
int	mode;
int	x, y;
{
	int	i;
	char	*cp;

	/* display a fresh image in both buffers */
	ug_tblk.tx = 0;
	ug_tblk.ty = 0;
	ug_tblk.npixel = ifp->if_width;
	ug_tblk.nline = ifp->if_height;
	ug_tblk.addr = (int *)ugbuf;

	write_ug("cursor");
	write_ug("cursor");

	/* build a cursor */
	cp = &ugcurs[0];	
	
	for(i = 0; i <= 16 * 16; i++) {
		cp++;
		*cp++ = 255;
		*cp++ = 255;
		*cp++ = 255;
	}

	y = ifp->if_height-1-y;		/* q1 -> q4 */
	y = y - y_window;
	x = x - x_window;
	x *= x_zoom;
	y *= y_zoom;

	ug_tblk.tx = x;
	ug_tblk.tx &= ~03;
	ug_tblk.ty = y;
	ug_tblk.npixel = 16;
	ug_tblk.nline = 16;
	ug_tblk.addr = (int *)ugcurs;	

	write_ug();
}

/* zoom and window */
zandw( ifp )
FBIO *ifp;
{
	int	x, y;
	int	xz, yz;
	int	numx, numy;
	char	*ip, *op;

/*	return;*/

	/* bound the window parameters - XXX */
	if( x_window < 0 ) x_window = 0;
	if( y_window < 0 ) y_window = 0;

	bzero( ugbuf2, ifp->if_width*ifp->if_height*4 );	/*XXX*/

	numx = (ifp->if_width-x_window) / x_zoom;
	numy = (ifp->if_height-y_window) / y_zoom;

fprintf( stderr, "numx,y= %d, %d; zoomx,y= %d, %d; windowx,y= %d, %d\n", numx, numy, x_zoom, y_zoom, x_window, y_window );

	for( y = 0; y < numy; y++ ) {
		for( yz = 0; yz < y_zoom; yz++ ) {
			for( x = 0; x < numx; x++ ) {
				ip = &ugbuf[ ((y+y_window)*ifp->if_width+(x+x_window))*4 ];
				for( xz = 0; xz < x_zoom; xz++ ) {
					op = &ugbuf2[ ((y*y_zoom+yz)*ifp->if_width
					      + (x*x_zoom+xz))*4 ];
					*op++ = *ip;
					*op++ = ip[1];
					*op++ = ip[2];
					*op++ = ip[3];
				}
			}
		}
	}

	ug_tblk.tx = 0;
	ug_tblk.ty = 0;
	ug_tblk.npixel = ifp->if_width;
	ug_tblk.nline = ifp->if_height;
	ug_tblk.addr = (int *)(ugbuf2);

	write_ug();
}

_LOCAL_ int
ug_help( ifp )
FBIO	*ifp;
{
	fb_log( "Description: %s\n", ug_interface.if_type );
	fb_log( "Device: %s\n", ifp->if_name );
	fb_log( "Max width/height: %d %d\n",
		ug_interface.if_max_width,
		ug_interface.if_max_height );
	fb_log( "Default width/height: %d %d\n",
		ug_interface.if_width,
		ug_interface.if_height );
	return(0);
}
@


11.4
log
@change conf.h to a wrapped config.h
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/libfb/if_ug.c,v 11.3 2004/02/02 17:39:13 morrison Exp $ (BRL)";
@


11.3
log
@update copyright to include span through 2003
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ug.c,v 11.2 1998/06/27 04:29:17 mike Exp $ (BRL)";
d30 5
a34 1
#include "conf.h"
@


11.2
log
@Additions to LIBFB interface and remote framebuffer protocol to
read and write monochrome rectangles.
Particularly important for sending thermal images at high speed.
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1986 by the United States Army.
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ug.c,v 11.1 1995/01/04 09:53:10 mike Rel4_4 $ (BRL)";
@


11.2.6.1
log
@sync branch with HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d27 1
a27 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.2.8.1
log
@sync to HEAD...
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libfb/if_ug.c,v 11.3 2004/02/02 17:39:13 morrison Exp $ (BRL)";
@


11.2.14.1
log
@merge from HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ug.c,v 11.3 2004/02/02 17:39:13 morrison Exp $ (BRL)";
@


11.2.14.2
log
@merge from head
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ug.c,v 11.2.14.1 2004/02/12 19:48:12 erikg Exp $ (BRL)";
@


11.1
log
@Release_4.4
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ug.c,v 10.2 94/08/12 20:25:55 gdurf Exp $ (BRL)";
d78 2
@


10.2
log
@Added includes
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ug.c,v 10.1 1991/10/12 06:37:33 mike Rel4_0 gdurf $ (BRL)";
@


10.1
log
@Release_4.0
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ug.c,v 9.4 91/07/26 22:41:17 mike Exp $ (BRL)";
d30 2
d33 4
a197 1
	extern int errno;
@


9.4
log
@Added if_magic field, and FB_CK_FBIO() macro, to allow checking
FBIO pointers
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ug.c,v 9.3 90/12/11 22:52:46 phil Exp $ (BRL)";
@


9.3
log
@if_ struct changes.  See fb.h.  No way to test this one.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ug.c,v 9.2 89/09/01 01:46:52 phil Exp $ (BRL)";
d57 1
d132 2
@


9.2
log
@fb_flush, fb_free, and fb_help hooks.
@
text
@d7 5
d14 1
a14 1
 *	Phil Dykstra
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: if_ug.c,v 9.1 89/05/19 05:48:18 phil Locked $ (BRL)";
a34 2
extern int	fb_sim_readrect(), fb_sim_writerect();

d43 10
a52 14
_LOCAL_ int	ug_dopen(),
		ug_dclose(),
		ug_dreset(),
		ug_dclear(),
		ug_bread(),
		ug_bwrite(),
		ug_cmread(),
		ug_cmwrite(),
		ug_viewport_set(),
		ug_window_set(),
		ug_zoom_set(),
		ug_curs_set(),
		ug_cmemory_addr(),
		ug_cscreen_addr(),
d57 12
a68 14
	ug_dopen,		/* device_open		*/
	ug_dclose,		/* device_close		*/
	ug_dreset,		/* device_reset		*/
	ug_dclear,		/* device_clear		*/
	ug_bread,		/* buffer_read		*/
	ug_bwrite,		/* buffer_write		*/
	ug_cmread,		/* colormap_read	*/
	ug_cmwrite,		/* colormap_write	*/
	ug_viewport_set,	/* viewport_set		*/
	ug_window_set,		/* window_set		*/
	ug_zoom_set,		/* zoom_set		*/
	ug_curs_set,		/* curs_set		*/
	ug_cmemory_addr,		/* cursor_move_memory_addr */
	ug_cscreen_addr,		/* cursor_move_screen_addr */
d71 1
d73 1
a73 1
	ug_dclose,			/* free			*/
d81 1
d83 3
d123 1
a123 1
ug_dopen( ifp, file, width, height )
d184 1
a184 1
ug_dclose( ifp )
d217 1
a217 1
ug_dreset( ifp )
a218 6
{
}

_LOCAL_ int
ug_dclear( ifp, pp )
FBIO	*ifp;
d250 1
a250 1
ug_bread( ifp, x, y, pixelp, count )
d287 1
a287 1
ug_bwrite( ifp, x, y, pixelp, count )
d331 1
a331 1
ug_cmread( ifp, cmp )
d338 1
a338 1
ug_cmwrite( ifp, cmp )
d345 1
a345 1
ug_viewport_set( ifp, left, top, right, bottom )
d347 2
a348 1
int	left, top, right, bottom;
a349 7
}

_LOCAL_ int
ug_window_set( ifp, x, y )
FBIO	*ifp;
int	x, y;
{
d361 2
a362 2
	ugx = x - (ifp->if_width / x_zoom)/2;
	ugy = y + (ifp->if_height / y_zoom)/2 - 1;
a368 8
	zandw( ifp );
}

_LOCAL_ int
ug_zoom_set( ifp, x, y )
FBIO	*ifp;
int	x, y;
{
d370 4
a373 4
	if( x < 1 )  x=1;
	if( y < 1 )  y=1;
	if( x > 256 )  x=256;
	if( y > 256 )  y=256;
d375 2
a376 2
	x_zoom = x;
	y_zoom = y;
d378 2
d384 1
a384 1
ug_curs_set( ifp, bits, xbits, ybits, xorig, yorig )
d393 1
a393 1
ug_cmemory_addr( ifp, mode, x, y )
a425 41

	ug_tblk.tx = x;
	ug_tblk.tx &= ~03;
	ug_tblk.ty = y;
	ug_tblk.npixel = 16;
	ug_tblk.nline = 16;
	ug_tblk.addr = (int *)ugcurs;	

	write_ug();
}

_LOCAL_ int
ug_cscreen_addr( ifp, mode, x, y )
FBIO	*ifp;
int	mode;
int	x, y;
{
	int	i;
	char	*cp;

	/* write a fresh image in both buffers */
	ug_tblk.tx = 0;
	ug_tblk.ty = 0;
	ug_tblk.npixel = ifp->if_width;
	ug_tblk.nline = ifp->if_height;
	ug_tblk.addr = (int *)ugbuf;

	write_ug("cursor");
	write_ug("cursor");
	
	/* build a cursor */
	cp = &ugcurs[0];	
	
	for(i = 0; i <= 16 * 16; i++) {
		cp++;
		*cp++ = 255;
		*cp++ = 255;
		*cp++ = 255;
	}
	
	y = ifp->if_width-1-y;		/* 1st quadrant */
@


9.1
log
@Release_3.5
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: if_ug.c,v 8.2 89/03/03 05:54:53 mike Exp $ (BRL)";
d74 3
a76 1
/* XXX add help here */
@


8.2
log
@Added support for fb_readrect() and fb_writerect().
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: if_ug.c,v 8.1 88/10/05 00:27:50 mike Locked $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: if_ug.c,v 7.2 88/09/09 23:42:02 phil Exp $ (BRL)";
d30 2
d72 3
@


7.2
log
@fbhelp function (untested)
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: if_ug.c,v 7.1 87/11/02 23:27:10 phil Locked $ (BRL)";
@


7.1
log
@Release 2.3
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: if_ug.c,v 1.1 87/09/03 01:09:41 mike Exp $ (BRL)";
d51 2
a52 1
		ug_cscreen_addr();
d532 15
@


1.1
log
@Initial revision
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 6.1 87/07/11 07:51:39 mike Rel $ (BRL)";
@
