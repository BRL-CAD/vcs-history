head	1.15;
access;
symbols
	ansi-20040405-merged:1.9.2.2
	postmerge-20040405-ansi:1.13
	premerge-20040404-ansi:1.12
	postmerge-autoconf:1.12
	autoconf-freeze:1.10.6.2
	premerge-autoconf:1.12
	ansi-20040316-freeze:1.9.2.1
	postmerge-20040315-windows:1.12
	premerge-20040315-windows:1.11
	windows-20040315-freeze:1.9.4.2
	autoconf-20031203:1.10
	autoconf-20031202:1.10
	autoconf-branch:1.10.0.6
	phong-branch:1.10.0.4
	photonmap-branch:1.10.0.2
	rel-6-1-DP:1.9
	windows-branch:1.9.0.4
	rel-6-0-2:1.7
	ansi-branch:1.9.0.2
	rel-6-0-1-branch:1.7.0.2
	hartley-6-0-post:1.8
	hartley-6-0-pre:1.7
	rel-6-0-1:1.7
	rel-6-0:1.7
	rel-5-4:1.5
	offsite-5-3-pre:1.7
	rel-5-3:1.5
	rel-5-2:1.5
	rel-5-1-branch:1.5.0.2
	rel-5-1:1.5;
locks; strict;
comment	@ * @;


1.15
date	2004.05.21.18.07.24;	author morrison;	state dead;
branches;
next	1.14;

1.14
date	2004.05.10.15.30.44;	author erikg;	state Exp;
branches;
next	1.13;

1.13
date	2004.04.05.07.44.42;	author morrison;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.16.19.59.35;	author morrison;	state Exp;
branches;
next	1.11;

1.11
date	2004.02.02.17.39.11;	author morrison;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.02.15.03.47;	author jra;	state Exp;
branches
	1.10.6.1;
next	1.9;

1.9
date	2002.08.20.17.07.46;	author jra;	state Exp;
branches
	1.9.2.1
	1.9.4.1;
next	1.8;

1.8
date	2002.08.15.20.54.59;	author hartley;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.12.03.26.49;	author cjohnson;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.12.01.33.30;	author cjohnson;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.31.14.42.01;	author jra;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.28.15.49.45;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.21.20.05.11;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	2000.01.15.00.46.55;	author bparker;	state Exp;
branches;
next	1.1;

1.1
date	2000.01.14.23.55.35;	author bparker;	state Exp;
branches;
next	;

1.9.2.1
date	2002.09.19.18.01.18;	author morrison;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2004.03.17.21.16.59;	author morrison;	state Exp;
branches;
next	;

1.9.4.1
date	2002.09.26.23.03.54;	author morrison;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2004.03.11.23.42.06;	author morrison;	state Exp;
branches;
next	;

1.10.6.1
date	2004.02.12.19.48.11;	author erikg;	state Exp;
branches;
next	1.10.6.2;

1.10.6.2
date	2004.03.18.18.10.28;	author erikg;	state Exp;
branches;
next	;


desc
@@


1.15
log
@moved to src/
@
text
@/*
 *				F B _ O B J . C
 *
 * A framebuffer object contains the attributes and
 * methods for controlling  framebuffers.
 * 
 * Source -
 *	SLAD CAD Team
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 * Authors -
 *	Robert G. Parker
 *	Ronald Bowers
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1997-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include "tcl.h"
#include "machine.h"
#include "externs.h"
#include "cmd.h"                  /* includes bu.h */
#include "fb.h"
#include "fbserv_obj.h"

/* defined in libfb/tcl.c */
extern int fb_refresh(FBIO *ifp, int x, int y, int w, int h);

static int fbo_open_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_cell_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_clear_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_close_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_cursor_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_getcursor_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_getheight_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_getsize_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_getwidth_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_pixel_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_flush_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_listen_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_refresh_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_rect_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_configure_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_coords_ok(Tcl_Interp *interp, FBIO *fbp, int x, int y);
static int fbo_tcllist2color(Tcl_Interp *interp, char *string, unsigned char *pixel);

#define FBO_CONSTRAIN(_v, _a, _b)\
	((_v > _a) ? (_v < _b ? _v : _b) : _a)

struct fb_obj {
	struct bu_list		l;
	struct bu_vls		fbo_name;	/* framebuffer object name/cmd */
	struct fbserv_obj	fbo_fbs;	/* fbserv object */
};

static struct fb_obj HeadFBObj;			/* head of display manager object list */

static struct bu_cmdtab fbo_cmds[] = {
       {"cell",		fbo_cell_tcl},
       {"clear",	fbo_clear_tcl},
       {"close",	fbo_close_tcl},
       {"configure",	fbo_configure_tcl},
       {"cursor",	fbo_cursor_tcl},
       {"pixel",	fbo_pixel_tcl},
       {"flush",	fbo_flush_tcl},
       {"getcursor",	fbo_getcursor_tcl},
       {"getheight",	fbo_getheight_tcl},
       {"getsize",	fbo_getsize_tcl},
       {"getwidth",	fbo_getwidth_tcl},
       {"listen",	fbo_listen_tcl},
       {"rect",		fbo_rect_tcl},
       {"refresh",	fbo_refresh_tcl},
       {(char *)0,	(int (*)())0}
};

/*
 *			F B O _ C M D
 *
 * Generic interface for framebuffer object routines.
 * Usage:
 *        procname cmd ?args?
 *
 * Returns: result of FB command.
 */
static int
fbo_cmd(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	return bu_cmd(clientData, interp, argc, argv, fbo_cmds, 1);
}

int
Fbo_Init(Tcl_Interp *interp)
{
	BU_LIST_INIT(&HeadFBObj.l);
	(void)Tcl_CreateCommand(interp, "fb_open", fbo_open_tcl,
				(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);

	return TCL_OK;
}

/*
 * Called by Tcl when the object is destroyed.
 */
static void
fbo_deleteProc(ClientData clientData)
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;

	/* close framebuffer */
	fb_close(fbop->fbo_fbs.fbs_fbp);

	bu_vls_free(&fbop->fbo_name);
	BU_LIST_DEQUEUE(&fbop->l);
	bu_free((genptr_t)fbop, "fbo_deleteProc: fbop");
}

/*
 * Close a framebuffer object.
 *
 * Usage:
 *	  procname close
 */
static int
fbo_close_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;
	struct bu_vls vls;

	if (argc != 2) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib fb_close");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* Among other things, this will call dmo_deleteProc. */
	Tcl_DeleteCommand(interp, bu_vls_addr(&fbop->fbo_name));

	return TCL_OK;
}

/*
 * Open/create a framebuffer object.
 *
 * Usage:
 *	  fb_open [name device [args]]
 */
static int
fbo_open_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct fb_obj *fbop;
	FBIO *ifp;
	int width = 512;
	int height = 512;
	register int c;
	struct bu_vls vls;

	if (argc == 1) {
		/* get list of framebuffer objects */
		for (BU_LIST_FOR(fbop, fb_obj, &HeadFBObj.l))
			Tcl_AppendResult(interp, bu_vls_addr(&fbop->fbo_name), " ", (char *)NULL);

		return TCL_OK;
	}

	if (argc < 3) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib fb_open");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* process args */
	bu_optind = 3;
	bu_opterr = 0;
	while ((c = bu_getopt(argc, argv, "w:W:s:S:n:N:")) != EOF)  {
		switch (c) {
		case 'W':
		case 'w':
			width = atoi(bu_optarg);
			break;
		case 'N':
		case 'n':
			height = atoi(bu_optarg);
			break;
		case 'S':
		case 's':
			width = atoi(bu_optarg);
			height = width;
			break;
		case '?':
		default:
			Tcl_AppendResult(interp, "fb_open: bad option - ",
					 bu_optarg, (char *)NULL);
			return TCL_ERROR;
		}
	}

	if ((ifp = fb_open(argv[2], width, height)) == FBIO_NULL) {
		Tcl_AppendResult(interp, "fb_open: bad device - ",
				 argv[2], (char *)NULL);
	}

	if (fb_ioinit(ifp) != 0) {
		Tcl_AppendResult(interp, "fb_open: fb_ioinit() failed.", (char *) NULL);
		return TCL_ERROR;
	}

	BU_GETSTRUCT(fbop, fb_obj);
	bu_vls_init(&fbop->fbo_name);
	bu_vls_strcpy(&fbop->fbo_name, argv[1]);
	fbop->fbo_fbs.fbs_fbp = ifp;
	fbop->fbo_fbs.fbs_listener.fbsl_fbsp = &fbop->fbo_fbs;
	fbop->fbo_fbs.fbs_listener.fbsl_fd = -1;
	fbop->fbo_fbs.fbs_listener.fbsl_port = -1;

	/* append to list of fb_obj's */
	BU_LIST_APPEND(&HeadFBObj.l,&fbop->l);

	(void)Tcl_CreateCommand(interp,
				bu_vls_addr(&fbop->fbo_name),
				(Tcl_CmdProc *)fbo_cmd,
				(ClientData)fbop,
				fbo_deleteProc);

	/* Return new function name as result */
	Tcl_ResetResult(interp);
	Tcl_AppendResult(interp, bu_vls_addr(&fbop->fbo_name), (char *)NULL);
	return TCL_OK;
}

/*
 * Clear the framebuffer with the specified color.
 * Otherwise, clear the framebuffer with black.
 *
 * Usage:
 *	  procname clear [rgb]
 */
static int
fbo_clear_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;
	int status;
	RGBpixel pixel;
	unsigned char *ms;


	if (argc < 2 || 3 < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib fb_clear");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if (argc == 3) {
		/*
		 * Decompose the color list into its constituents.
		 * For now must be in the form of rrr ggg bbb.
		 */
		if (fbo_tcllist2color(interp, argv[6], pixel) == TCL_ERROR) {
			Tcl_AppendResult(interp, "fb_cell: invalid color spec: ", argv[6], ".", 
					 (char *)NULL);
			return TCL_ERROR;
		}

		ms = pixel;
	}else
		ms = RGBPIXEL_NULL;

	status = fb_clear(fbop->fbo_fbs.fbs_fbp, ms);

	if(status < 0)
		return TCL_ERROR;

	return TCL_OK;
}

/*
 *
 * Usage:
 *	  procname cursor mode x y
 */
static int
fbo_cursor_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;
	int mode;
	int x, y;
	int status;
	struct bu_vls vls;

	if (argc != 5) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib fb_cursor");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
	}

	if (sscanf(argv[2], "%d", &mode) != 1) {
		Tcl_AppendResult(interp, "fb_cursor: bad mode - ",
				 argv[2], (char *)NULL);
		return TCL_ERROR;
	}

	if (sscanf(argv[3], "%d", &x) != 1) {
		Tcl_AppendResult(interp, "fb_cursor: bad x value - ",
				 argv[3], (char *)NULL);
		return TCL_ERROR;
	}

	if (sscanf(argv[4], "%d", &y) != 1) {
		Tcl_AppendResult(interp, "fb_cursor: bad y value - ",
				 argv[4], (char *)NULL);
		return TCL_ERROR;
	}

	status = fb_cursor(fbop->fbo_fbs.fbs_fbp, mode, x, y);
	if (status == 0)
		return TCL_OK;

	return TCL_ERROR;
}

/*
 *
 * Usage:
 *	  procname getcursor
 */
static int
fbo_getcursor_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;
	int status;
	int mode;
	int x, y;
	struct bu_vls vls;

	if (argc != 2) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib fb_getcursor");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	status = fb_getcursor(fbop->fbo_fbs.fbs_fbp, &mode, &x, &y);
	if (status == 0) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "%d %d %d", mode, x, y);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		return TCL_OK;
	}

	return TCL_ERROR;
}

/*
 * Refresh the entire framebuffer or that part specified by
 * a rectangle (i.e. x y width height)
 * Usage:
 *	  procname refresh [rect]
 */
static int
fbo_refresh_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;
	int x, y, w, h;		       /* rectangle to be refreshed */

	if (argc < 2 || 3 < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib fb_refresh");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if (argc == 2) {  /* refresh the whole display */
		x = y = 0;
		w = fbop->fbo_fbs.fbs_fbp->if_width;
		h = fbop->fbo_fbs.fbs_fbp->if_height;
	} else if (sscanf(argv[2], "%d %d %d %d", &x, &y, &w, &h) != 4) { /* refresh rectanglar area */
		Tcl_AppendResult(interp, "fb_refresh: bad rectangle - ",
				 argv[2], (char *)NULL);
		return TCL_ERROR;
	}

#if 1
	return fb_refresh(fbop->fbo_fbs.fbs_fbp, x, y, w, h);
#else
	return fbop->fbo_fbs.fbs_fbp->if_refresh(fbop->fbo_fbs.fbs_fbp, x, y, w, h)
#endif
}

/*
 * Listen for framebuffer clients.
 *
 * Usage:
 *	  procname listen port
 *
 * Returns the port number actually used.
 *
 */
static int
fbo_listen_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;
	struct bu_vls vls;

	bu_vls_init(&vls);

	if (fbop->fbo_fbs.fbs_fbp == FBIO_NULL) {
		bu_vls_printf(&vls, "%s listen: framebuffer not open!\n", argv[0]);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		return TCL_ERROR;
	}

	/* return the port number */
	if (argc == 2) {
		bu_vls_printf(&vls, "%d", fbop->fbo_fbs.fbs_listener.fbsl_port);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		return TCL_OK;
	}

	if (argc == 3) {
		int port;

		if (sscanf(argv[2], "%d", &port) != 1) {
			Tcl_AppendResult(interp, "listen: bad value - ", argv[2], "\n", (char *)NULL);
			return TCL_ERROR;
		}

		if (port >= 0)
			fbs_open(interp, &fbop->fbo_fbs, port);
		else {
			fbs_close(interp, &fbop->fbo_fbs);
		}
		bu_vls_printf(&vls, "%d", fbop->fbo_fbs.fbs_listener.fbsl_port);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		return TCL_OK;
	}

	bu_vls_printf(&vls, "helplib fb_listen");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
}

/*
 * Set/get the pixel value at position (x, y).
 *
 * Usage:
 *	  procname pixel x y [rgb]
 */
static int
fbo_pixel_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;
	struct bu_vls vls;
	int x, y; 	/* pixel position */
	RGBpixel pixel;


	if (argc < 4)
		goto error;

	/* get pixel position */
	if (sscanf(argv[2], "%d", &x) != 1) {
		Tcl_AppendResult(interp, "fb_pixel: bad x value - ",
				 argv[2], (char *)NULL);
		return TCL_ERROR;
	}

	if (sscanf(argv[3], "%d", &y) != 1) {
		Tcl_AppendResult(interp, "fb_pixel: bad y value - ",
				 argv[3], (char *)NULL);
		return TCL_ERROR;
	}

	/* check pixel position */
	if (!fbo_coords_ok(interp, fbop->fbo_fbs.fbs_fbp, x, y)) {
		Tcl_AppendResult(interp,
				 "fb_pixel: coordinates (", argv[2], ", ", argv[3],
				 ") are invalid.", (char *)NULL);
		return TCL_ERROR;
	}

	/* get pixel value */
	if (argc == 4) {
		fb_rpixel(fbop->fbo_fbs.fbs_fbp, pixel);
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "%d %d %d", pixel[RED], pixel[GRN], pixel[BLU]);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		return TCL_OK;
	}

	/* set pixel value */
	if (argc == 5) {
		/*
		 * Decompose the color list into its constituents.
		 * For now must be in the form of rrr ggg bbb.
		 */
    
		if (fbo_tcllist2color(interp, argv[4], pixel) == TCL_ERROR) {
			Tcl_AppendResult(interp, "fb_pixel: invalid color spec - ", argv[4], ".", 
					 (char *)NULL);
			return TCL_ERROR;
		}

		fb_write(fbop->fbo_fbs.fbs_fbp, x, y, pixel, 1);

		return TCL_OK;
	}

error:
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib fb_pixel");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
}

/*
 *
 * Usage:
 *	  procname cell xmin ymin width height color
 */
static int
fbo_cell_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;
	struct bu_vls vls;
	int xmin, ymin;
	int width;
	int height;
	int i;
	RGBpixel pixel;
	unsigned char *pp;


    
	if (argc != 7) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib fb_cell");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}
    
	if (sscanf(argv[2], "%d", &xmin) != 1) {
		Tcl_AppendResult(interp, "fb_cell: bad xmin value - ",
				 argv[2], (char *)NULL);
		return TCL_ERROR;
	}

	if (sscanf(argv[3], "%d", &ymin) != 1) {
		Tcl_AppendResult(interp, "fb_cell: bad ymin value - ",
				 argv[3], (char *)NULL);
		return TCL_ERROR;
	}

	/*  check coordinates */
	if (!fbo_coords_ok(interp, fbop->fbo_fbs.fbs_fbp, xmin, ymin)) {
		Tcl_AppendResult(interp,
				 "fb_cell: coordinates (", argv[2], ", ", argv[3],
				 ") are invalid.", (char *)NULL);
		return TCL_ERROR;
	}

	if (sscanf(argv[4], "%d", &width) != 1) {
		Tcl_AppendResult(interp, "fb_cell: bad width - ",
				 argv[4], (char *)NULL);
		return TCL_ERROR;
	}

	if (sscanf(argv[5], "%d", &height) != 1) {
		Tcl_AppendResult(interp, "fb_cell: bad height - ",
				 argv[5], (char *)NULL);
		return TCL_ERROR;
	}


	/* check width and height */
	if (width <=0  || height <=0) {
		Tcl_AppendResult(interp, "fb_cell: width and height must be > 0", (char *)NULL);
		return TCL_ERROR;
	}
    
	/*
	 * Decompose the color list into its constituents.
	 * For now must be in the form of rrr ggg bbb.
	 */
	if (fbo_tcllist2color(interp, argv[6], pixel) == TCL_ERROR) {
		Tcl_AppendResult(interp, "fb_cell: invalid color spec: ", argv[6], ".", 
				 (char *)NULL);
		return TCL_ERROR;
	}

	pp = (unsigned char *)calloc(width*height, sizeof(RGBpixel));
	for (i = 0; i < width*height*sizeof(RGBpixel); i+=sizeof(RGBpixel)) {
		pp[i] = pixel[0];
		pp[i+1] = pixel[1];
		pp[i+2] = pixel[2];
	}
	fb_writerect(fbop->fbo_fbs.fbs_fbp, xmin, ymin, width, height, pp);
	free((void *)pp);

	return TCL_OK;    
}

/*
 *
 * Usage:
 *	  procname flush
 */
static int
fbo_flush_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;


	if (argc != 2) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib fb_flush");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	fb_flush(fbop->fbo_fbs.fbs_fbp);

	return TCL_OK;    
}

/*
 *
 * Usage:
 *	  procname getheight
 */
static int
fbo_getheight_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;
	struct bu_vls vls;

	if (argc != 2) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib fb_getheight");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "%d", fb_getheight(fbop->fbo_fbs.fbs_fbp));
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

	return TCL_OK;    
}

/*
 *
 * Usage:
 *	  procname getwidth
 */
static int
fbo_getwidth_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;
	struct bu_vls vls;

	if (argc != 2) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib fb_getwidth");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "%d", fb_getwidth(fbop->fbo_fbs.fbs_fbp));
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

	return TCL_OK;    
}

/*
 *
 * Usage:
 *	  procname getsize
 */
static int
fbo_getsize_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;
	struct bu_vls vls;

	if (argc != 2) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib fb_getsize");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "%d %d",
		      fb_getwidth(fbop->fbo_fbs.fbs_fbp),
		      fb_getheight(fbop->fbo_fbs.fbs_fbp));
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);


	return TCL_OK;    
}

/*
 *
 * Usage:
 *	  procname cell xmin ymin width height color
 */
static int
fbo_rect_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;
	struct bu_vls vls;
	int xmin, ymin;
	int xmax, ymax;
	int width;
	int height;
	int i;
	RGBpixel pixel;

	if (argc != 7) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib fb_rect");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}
    
	if (sscanf(argv[2], "%d", &xmin) != 1) {
		Tcl_AppendResult(interp, "fb_rect: bad xmin value - ",
				 argv[2], (char *)NULL);
		return TCL_ERROR;
	}

	if (sscanf(argv[3], "%d", &ymin) != 1) {
		Tcl_AppendResult(interp, "fb_rect: bad ymin value - ",
				 argv[3], (char *)NULL);
		return TCL_ERROR;
	}

	/*  check coordinates */
	if (!fbo_coords_ok(interp, fbop->fbo_fbs.fbs_fbp, xmin, ymin)) {
		Tcl_AppendResult(interp,
				 "fb_rect: coordinates (", argv[2], ", ", argv[3],
				 ") are invalid.", (char *)NULL);
		return TCL_ERROR;
	}

	if (sscanf(argv[4], "%d", &width) != 1) {
		Tcl_AppendResult(interp, "fb_rect: bad width - ",
				 argv[4], (char *)NULL);
		return TCL_ERROR;
	}

	if (sscanf(argv[5], "%d", &height) != 1) {
		Tcl_AppendResult(interp, "fb_rect: bad height - ",
				 argv[5], (char *)NULL);
		return TCL_ERROR;
	}


	/* check width and height */
	if (width <=0  || height <=0) {
		Tcl_AppendResult(interp, "fb_rect: width and height must be > 0", (char *)NULL);
		return TCL_ERROR;
	}
    
	/*
	 * Decompose the color list into its constituents.
	 * For now must be in the form of rrr ggg bbb.
	 */
	if (fbo_tcllist2color(interp, argv[6], pixel) == TCL_ERROR) {
		Tcl_AppendResult(interp, "fb_rect: invalid color spec: ", argv[6], ".", 
				 (char *)NULL);
		return TCL_ERROR;
	}

	xmax = xmin + width;
	ymax = ymin + height;

	/* draw horizontal lines */
	for (i = xmin; i <= xmax; ++i) {
		/* working on bottom line */
		fb_write(fbop->fbo_fbs.fbs_fbp, i, ymin, pixel, 1);

		/* working on top line */
		fb_write(fbop->fbo_fbs.fbs_fbp, i, ymax, pixel, 1);
	}

	/* draw vertical lines */
	for (i = ymin; i <= ymax; ++i) {
		/* working on left line */
		fb_write(fbop->fbo_fbs.fbs_fbp, xmin, i, pixel, 1);

		/* working on right line */
		fb_write(fbop->fbo_fbs.fbs_fbp, xmax, i, pixel, 1);
	}

	return TCL_OK;    
}

/*
 * Usage:
 *	  procname configure width height
 */
int
fbo_configure_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;
	int width, height;

	if (argc != 4) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib fb_configure");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if (sscanf(argv[2], "%d", &width) != 1) {
		Tcl_AppendResult(interp, "fb_configure: bad width - ",
				 argv[2], (char *)NULL);
		return TCL_ERROR;
	}

	if (sscanf(argv[3], "%d", &height) != 1) {
		Tcl_AppendResult(interp, "fb_configure: bad height - ",
				 argv[3], (char *)NULL);
		return TCL_ERROR;
	}

	/* configure the framebuffer window */
	if (fbop->fbo_fbs.fbs_fbp != FBIO_NULL)
		fb_configureWindow(fbop->fbo_fbs.fbs_fbp, width, height);

	return TCL_OK;    
}
#if 0
/*
 *
 * Usage:
 *	  procname 
 */
int
fbo__tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int argc;
     char **argv;
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;
	struct bu_vls vls;

	return TCL_OK;    
}
#endif

/****************** utility routines ********************/
static int
fbo_coords_ok(Tcl_Interp *interp, FBIO *fbp, int x, int y)
{
	int	    width;
	int	    height;
	int	    errors;
	width = fb_getwidth(fbp);
	height = fb_getheight(fbp);

	errors = 0;

	if (x < 0) {
		Tcl_AppendResult(interp, "fbo_coords_ok: Error!: X value < 0\n", 
				 (char *)NULL);
		++errors;
	}
    
	if (y < 0) {
		Tcl_AppendResult(interp, "fbo_coords_ok: Error!: Y value < 0\n", 
				 (char *)NULL);
		++errors;
	}

	if (x > width - 1) {
		Tcl_AppendResult(interp, "fbo_coords_ok: Error!: X value too large\n", 
				 (char *)NULL);
		++errors;
	}

	if (y > height - 1) {
		Tcl_AppendResult(interp, "fbo_coords_ok: Error!: Y value too large\n", 
				 (char *)NULL);
		++errors;
	}

	if ( errors ) {
		return 0;
	} else {
		return 1;
	}
}

static int
fbo_tcllist2color(Tcl_Interp *interp, char *string, unsigned char *pixel)
{
    int r, g, b;

    if (sscanf(string, "%d %d %d", &r, &g, &b) != 3) {
	    Tcl_AppendResult(interp,
			     "fb_clear: bad color spec - ",
			     string, (char *)NULL);
	    return TCL_ERROR;
    }

    pixel[RED] = FBO_CONSTRAIN (r, 0, 255);
    pixel[GRN] = FBO_CONSTRAIN (g, 0, 255);
    pixel[BLU] = FBO_CONSTRAIN (b, 0, 255);

    return TCL_OK;
}
@


1.14
log
@change conf.h to a wrapped config.h
@
text
@@


1.13
log
@merge of ansi-6-0-branch into HEAD
@
text
@d30 5
a34 1
#include "conf.h"
@


1.12
log
@merge of windows-6-0-branch into head
@
text
@d40 1
a40 1
extern int fb_refresh();
d42 17
a58 18
static int fbo_open_tcl(ClientData clientData,Tcl_Interp *interp,int argc,char **argv);
static int fbo_cell_tcl();
static int fbo_clear_tcl();
static int fbo_close_tcl();
static int fbo_cursor_tcl();
static int fbo_getcursor_tcl();
static int fbo_getheight_tcl();
static int fbo_getsize_tcl();
static int fbo_getwidth_tcl();
static int fbo_pixel_tcl();
static int fbo_flush_tcl();
static int fbo_listen_tcl();
static int fbo_refresh_tcl();
static int fbo_rect_tcl();
static int fbo_configure_tcl();

static int fbo_coords_ok();
static int fbo_tcllist2color();
a97 8
#ifndef WIN32
static int
fbo_cmd(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
#else
d99 1
a99 6
fbo_cmd(
ClientData clientData,
Tcl_Interp *interp,
int     argc,
char    **argv)
#endif
d105 1
a105 2
Fbo_Init(interp)
Tcl_Interp *interp;
a116 1
#ifndef WIN32
d118 1
a118 5
fbo_deleteProc(clientData)
     ClientData clientData;
#else
static void fbo_deleteProc(ClientData clientData)
#endif
d137 1
a137 5
fbo_close_tcl(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
a161 8
#ifndef WIN32
static int
fbo_open_tcl(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
#else
d163 1
a163 6
fbo_open_tcl(
ClientData clientData,
Tcl_Interp *interp,
int argc,
char **argv)
#endif
d255 1
a255 5
fbo_clear_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int argc;
     char **argv;
d302 1
a302 5
fbo_cursor_tcl(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d348 1
a348 5
fbo_getcursor_tcl(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d384 1
a384 5
fbo_refresh_tcl(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d426 1
a426 5
fbo_listen_tcl(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d484 1
a484 5
fbo_pixel_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int argc;
     char **argv;
d559 1
a559 5
fbo_cell_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int argc;
     char **argv;
d647 1
a647 5
fbo_flush_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int argc;
     char **argv;
d673 1
a673 5
fbo_getheight_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int argc;
     char **argv;
d700 1
a700 5
fbo_getwidth_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int argc;
     char **argv;
d727 1
a727 5
fbo_getsize_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int argc;
     char **argv;
d757 1
a757 5
fbo_rect_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int argc;
     char **argv;
d854 1
a854 5
fbo_configure_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int argc;
     char **argv;
d909 1
a909 5
fbo_coords_ok(interp, fbp, x, y) 
     Tcl_Interp *interp;
     FBIO *fbp;
     int x;
     int y;
d951 1
a951 4
fbo_tcllist2color(interp, string, pixel)
     Tcl_Interp *interp;
     char *string;
     RGBpixel pixel;
@


1.11
log
@update copyright to include span through 2003
@
text
@d42 1
a42 1
static int fbo_open_tcl();
d99 1
d106 8
d132 1
d136 3
d186 1
d193 8
@


1.10
log
@Added a cast to quiet the compiler
@
text
@d26 1
a26 1
 *	This software is Copyright (C) 1997 by the United States Army
@


1.10.6.1
log
@merge from HEAD
@
text
@d26 1
a26 1
 *	This software is Copyright (C) 1997-2004 by the United States Army
@


1.10.6.2
log
@merge from head
@
text
@d42 1
a42 1
static int fbo_open_tcl(ClientData clientData,Tcl_Interp *interp,int argc,char **argv);
a98 1
#ifndef WIN32
a104 8
#else
static int
fbo_cmd(
ClientData clientData,
Tcl_Interp *interp,
int     argc,
char    **argv)
#endif
a122 1
#ifndef WIN32
a125 3
#else
static void fbo_deleteProc(ClientData clientData)
#endif
a172 1
#ifndef WIN32
a178 8
#else
static int
fbo_open_tcl(
ClientData clientData,
Tcl_Interp *interp,
int argc,
char **argv)
#endif
@


1.9
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d252 1
a252 1
				fbo_cmd,
@


1.9.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d42 1
a42 1
static int fbo_open_tcl(ClientData clientData,Tcl_Interp *interp,int argc,char **argv);
a98 1
#ifndef WIN32
a104 8
#else
static int
fbo_cmd(
ClientData clientData,
Tcl_Interp *interp,
int     argc,
char    **argv)
#endif
a122 1
#ifndef WIN32
a125 3
#else
static void fbo_deleteProc(ClientData clientData)
#endif
a172 1
#ifndef WIN32
a178 8
#else
static int
fbo_open_tcl(
ClientData clientData,
Tcl_Interp *interp,
int argc,
char **argv)
#endif
@


1.9.4.2
log
@sync to HEAD...
@
text
@d26 1
a26 1
 *	This software is Copyright (C) 1997-2004 by the United States Army
d274 1
a274 1
				(Tcl_CmdProc *)fbo_cmd,
@


1.9.2.1
log
@Initial ANSIfication
@
text
@d40 1
a40 1
extern int fb_refresh(FBIO *ifp, int x, int y, int w, int h);
d42 15
a56 15
static int fbo_open_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_cell_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_clear_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_close_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_cursor_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_getcursor_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_getheight_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_getsize_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_getwidth_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_pixel_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_flush_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_listen_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_refresh_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_rect_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_configure_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d58 2
a59 2
static int fbo_coords_ok(Tcl_Interp *interp, FBIO *fbp, int x, int y);
static int fbo_tcllist2color(Tcl_Interp *interp, char *string, unsigned char *pixel);
d100 5
a104 1
fbo_cmd(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d110 2
a111 1
Fbo_Init(Tcl_Interp *interp)
d124 2
a125 1
fbo_deleteProc(ClientData clientData)
d144 5
a148 1
fbo_close_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d174 5
a178 1
fbo_open_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d270 5
a274 1
fbo_clear_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d321 5
a325 1
fbo_cursor_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d371 5
a375 1
fbo_getcursor_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d411 5
a415 1
fbo_refresh_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d457 5
a461 1
fbo_listen_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d519 5
a523 1
fbo_pixel_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d598 5
a602 1
fbo_cell_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d690 5
a694 1
fbo_flush_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d720 5
a724 1
fbo_getheight_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d751 5
a755 1
fbo_getwidth_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d782 5
a786 1
fbo_getsize_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d816 5
a820 1
fbo_rect_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d917 5
a921 1
fbo_configure_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d976 5
a980 1
fbo_coords_ok(Tcl_Interp *interp, FBIO *fbp, int x, int y)
d1022 4
a1025 1
fbo_tcllist2color(Tcl_Interp *interp, char *string, unsigned char *pixel)
@


1.9.2.2
log
@sync branch with HEAD
@
text
@d26 1
a26 1
 *	This software is Copyright (C) 1997-2004 by the United States Army
d57 1
d238 1
a238 1
				(Tcl_CmdProc *)fbo_cmd,
@


1.8
log
@Converted from K&R to ANSI C - RFH
@
text
@d40 1
a40 1
extern int fb_refresh(FBIO *ifp, int x, int y, int w, int h);
d42 15
a56 15
static int fbo_open_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_cell_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_clear_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_close_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_cursor_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_getcursor_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_getheight_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_getsize_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_getwidth_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_pixel_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_flush_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_listen_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_refresh_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_rect_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_configure_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d58 2
a59 2
static int fbo_coords_ok(Tcl_Interp *interp, FBIO *fbp, int x, int y);
static int fbo_tcllist2color(Tcl_Interp *interp, char *string, unsigned char *pixel);
d100 5
a104 1
fbo_cmd(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d110 2
a111 1
Fbo_Init(Tcl_Interp *interp)
d124 2
a125 1
fbo_deleteProc(ClientData clientData)
d144 5
a148 1
fbo_close_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d174 5
a178 1
fbo_open_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d270 5
a274 1
fbo_clear_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d321 5
a325 1
fbo_cursor_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d371 5
a375 1
fbo_getcursor_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d411 5
a415 1
fbo_refresh_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d457 5
a461 1
fbo_listen_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d519 5
a523 1
fbo_pixel_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d598 5
a602 1
fbo_cell_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d690 5
a694 1
fbo_flush_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d720 5
a724 1
fbo_getheight_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d751 5
a755 1
fbo_getwidth_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d782 5
a786 1
fbo_getsize_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d816 5
a820 1
fbo_rect_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d917 5
a921 1
fbo_configure_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d976 5
a980 1
fbo_coords_ok(Tcl_Interp *interp, FBIO *fbp, int x, int y)
d1022 4
a1025 1
fbo_tcllist2color(Tcl_Interp *interp, char *string, unsigned char *pixel)
@


1.7
log
@LINT from gcc -Wall.  These mods are to support libdm.  General via moving
declerations to fb.h
@
text
@d40 1
a40 1
extern int fb_refresh();
d42 15
a56 15
static int fbo_open_tcl();
static int fbo_cell_tcl();
static int fbo_clear_tcl();
static int fbo_close_tcl();
static int fbo_cursor_tcl();
static int fbo_getcursor_tcl();
static int fbo_getheight_tcl();
static int fbo_getsize_tcl();
static int fbo_getwidth_tcl();
static int fbo_pixel_tcl();
static int fbo_flush_tcl();
static int fbo_listen_tcl();
static int fbo_refresh_tcl();
static int fbo_rect_tcl();
static int fbo_configure_tcl();
d58 2
a59 2
static int fbo_coords_ok();
static int fbo_tcllist2color();
d100 1
a100 5
fbo_cmd(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d106 1
a106 2
Fbo_Init(interp)
Tcl_Interp *interp;
d119 1
a119 2
fbo_deleteProc(clientData)
     ClientData clientData;
d138 1
a138 5
fbo_close_tcl(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d164 1
a164 5
fbo_open_tcl(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d256 1
a256 5
fbo_clear_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int argc;
     char **argv;
d303 1
a303 5
fbo_cursor_tcl(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d349 1
a349 5
fbo_getcursor_tcl(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d385 1
a385 5
fbo_refresh_tcl(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d427 1
a427 5
fbo_listen_tcl(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d485 1
a485 5
fbo_pixel_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int argc;
     char **argv;
d560 1
a560 5
fbo_cell_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int argc;
     char **argv;
d648 1
a648 5
fbo_flush_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int argc;
     char **argv;
d674 1
a674 5
fbo_getheight_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int argc;
     char **argv;
d701 1
a701 5
fbo_getwidth_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int argc;
     char **argv;
d728 1
a728 5
fbo_getsize_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int argc;
     char **argv;
d758 1
a758 5
fbo_rect_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int argc;
     char **argv;
d855 1
a855 5
fbo_configure_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int argc;
     char **argv;
d910 1
a910 5
fbo_coords_ok(interp, fbp, x, y) 
     Tcl_Interp *interp;
     FBIO *fbp;
     int x;
     int y;
d952 1
a952 4
fbo_tcllist2color(interp, string, pixel)
     Tcl_Interp *interp;
     char *string;
     RGBpixel pixel;
@


1.6
log
@LINT from gcc -Wall.  Including some mods to h/pkg.h
@
text
@a40 1
extern int fb_configureWindow(FBIO *, int, int);
@


1.5
log
@Eliminated an unused variable
@
text
@d41 1
d74 15
a88 15
       "cell",		fbo_cell_tcl,
       "clear",		fbo_clear_tcl,
       "close",		fbo_close_tcl,
       "configure",	fbo_configure_tcl,
       "cursor",	fbo_cursor_tcl,
       "pixel",		fbo_pixel_tcl,
       "flush",		fbo_flush_tcl,
       "getcursor",	fbo_getcursor_tcl,
       "getheight",	fbo_getheight_tcl,
       "getsize",	fbo_getsize_tcl,
       "getwidth",	fbo_getwidth_tcl,
       "listen",	fbo_listen_tcl,
       "rect",		fbo_rect_tcl,
       "refresh",	fbo_refresh_tcl,
       (char *)0,	(int (*)())0
@


1.4
log
@*- add configure command
@
text
@a923 1
	struct bu_vls vls;
@


1.3
log
@removed unused variables to clean up compile
@
text
@d56 1
d76 1
a830 2

    
d912 43
@


1.2
log
@*- fixed typo in fbo_refresh
*- return a value in fbo_pixel
@
text
@d278 1
a278 1
	int r, g, b;
a525 1
	int r, g, b;
d528 1
a606 1
	int red, green, blue;
a607 1
	char buffer[64];
d610 2
d695 1
a695 1
	struct bu_vls vls;
a825 1
	int red, green, blue;
a826 1
	char buffer[64];
d828 2
a984 1
    int ncolors, code;
@


1.1
log
@Framebuffer Object
@
text
@d432 1
a432 1
	} else if (sscanf(argv[2], "%d", &x, &y, &w, &h) != 4) { /* refresh rectanglar area */
d529 2
a530 7
	if (argc < 4) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib fb_pixel");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}
d581 7
@

