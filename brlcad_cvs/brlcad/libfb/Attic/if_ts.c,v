head	11.5;
access;
symbols
	ansi-20040405-merged:11.2.6.1
	postmerge-20040405-ansi:11.3
	premerge-20040404-ansi:11.3
	postmerge-autoconf:11.3
	autoconf-freeze:11.2.14.2
	premerge-autoconf:11.3
	ansi-20040316-freeze:11.2
	postmerge-20040315-windows:11.3
	premerge-20040315-windows:11.3
	windows-20040315-freeze:11.2.8.1
	autoconf-20031203:11.2
	autoconf-20031202:11.2
	autoconf-branch:11.2.0.14
	phong-branch:11.2.0.12
	photonmap-branch:11.2.0.10
	rel-6-1-DP:11.2
	windows-branch:11.2.0.8
	rel-6-0-2:11.2
	ansi-branch:11.2.0.6
	rel-6-0-1-branch:11.2.0.4
	hartley-6-0-post:11.2
	hartley-6-0-pre:11.2
	rel-6-0-1:11.2
	rel-6-0:11.2
	rel-5-4:11.2
	offsite-5-3-pre:11.2
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.5
date	2004.05.21.18.07.25;	author morrison;	state dead;
branches;
next	11.4;

11.4
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	11.3;

11.3
date	2004.02.02.17.39.13;	author morrison;	state Exp;
branches;
next	11.2;

11.2
date	98.06.27.04.29.17;	author mike;	state Exp;
branches
	11.2.6.1
	11.2.8.1
	11.2.14.1;
next	11.1;

11.1
date	95.01.04.09.53.09;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.12.20.25.52;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.37.32;	author mike;	state Rel4_0;
branches;
next	1.6;

1.6
date	91.10.12.02.27.33;	author phil;	state Exp;
branches;
next	1.5;

1.5
date	91.09.26.05.10.59;	author phil;	state Exp;
branches;
next	1.4;

1.4
date	91.07.26.22.41.16;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	91.02.09.04.16.10;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	90.12.12.08.03.18;	author phil;	state Exp;
branches;
next	1.1;

1.1
date	90.12.11.23.06.12;	author phil;	state Exp;
branches;
next	;

11.2.6.1
date	2004.03.17.21.17.02;	author morrison;	state Exp;
branches;
next	;

11.2.8.1
date	2004.03.11.23.42.07;	author morrison;	state Exp;
branches;
next	;

11.2.14.1
date	2004.02.12.19.48.12;	author erikg;	state Exp;
branches;
next	11.2.14.2;

11.2.14.2
date	2004.03.15.14.06.20;	author erikg;	state Exp;
branches;
next	;


desc
@LIBFB support for the Tech-Source GDS-3900.
@


11.5
log
@moved to src/
@
text
@/*
 *			I F _ T S . C
 *
 *  Tech-Source GDS-3924L+8 Interface.  This is a single VME board
 *  frame buffer, most likely plugged into a Sun Microsystems computer.
 *  Features include:  1280x1024x24bit display in a 2048x1024 window, or
 *  double buffered 1024x1024x24bit.  Hardware pan and zoom, colormaps,
 *  eight bits of overlay planes.
 *
 *  To use this module you must have the GDSLIB library and header
 *  files installed, and add -lgds to the LIBFB_LIBS in Cakefile.defs.
 *
 *  Authors -
 *	Phillip Dykstra
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libfb/if_ts.c,v 11.4 2004/05/10 15:30:45 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>

#include "machine.h"
#include "fb.h"
#include "./fblocal.h"
#include <ctype.h>
#include <gdslib.h>

_LOCAL_ int	ts_open(),
		ts_close(),
		ts_clear(),
		ts_read(),
		ts_write(),
		ts_rmap(),
		ts_wmap(),
		ts_view(),
		ts_getview(),
		ts_window(),		/* OLD */
		ts_zoom(),		/* OLD */
		ts_setcursor(),
		ts_cursor(),
		ts_getcursor(),
		ts_readrect(),
		ts_writerect(),
		ts_flush(),
		ts_free(),
		ts_help();

/* This is the ONLY thing that we normally "export" */
FBIO ts_interface =  {
	0,
	ts_open,		/* open device		*/
	ts_close,		/* close device		*/
	ts_clear,		/* clear device		*/
	ts_read,		/* read	pixels		*/
	ts_write,		/* write pixels		*/
	ts_rmap,		/* read colormap	*/
	ts_wmap,		/* write colormap	*/
	ts_view,		/* set view		*/
	ts_getview,		/* get view		*/
	ts_setcursor,		/* define cursor	*/
	ts_cursor,		/* set cursor		*/
	ts_getcursor,		/* get cursor		*/
	ts_readrect,		/* read rectangle	*/
	ts_writerect,		/* write rectangle	*/
	fb_sim_bwreadrect,
	fb_sim_bwwriterect,
	fb_null,		/* handle events	*/
	ts_flush,		/* flush output		*/
	ts_free,		/* free resources	*/
	ts_help,		/* help message		*/
	"Tech-Source GDS 39XX",	/* device description	*/
	2048,			/* max width		*/
	1024,			/* max height		*/
	"/dev/ts",		/* short device name	*/
	1280,			/* default/current width  */
	1024,			/* default/current height */
	-1,			/* select file desc	*/
	-1,			/* file descriptor	*/
	1, 1,			/* zoom			*/
	640, 512,		/* window		*/
	0, 0, 0,		/* cursor		*/
	PIXEL_NULL,		/* page_base		*/
	PIXEL_NULL,		/* page_curp		*/
	PIXEL_NULL,		/* page_endp		*/
	-1,			/* page_no		*/
	0,			/* page_dirty		*/
	0L,			/* page_curpos		*/
	0L,			/* page_pixels		*/
	0			/* debug		*/
};

#define MODE_1MASK	(1<<1)
#define MODE_1NORM	(0<<1)
#define MODE_1OVERLAY	(1<<1)

#define MODE_2MASK	(1<<2)
#define MODE_2NORM	(0<<2)
#define MODE_2OVERONLY	(1<<2)

static struct modeflags {
	char	c;
	long	mask;
	long	value;
	char	*help;
} modeflags[] = {
	{ 'o',	MODE_1MASK, MODE_1OVERLAY,
		"Enable Transparent Overlay Planes - else off" },
	{ 'O',	MODE_2MASK, MODE_2OVERONLY,
		"Enable ONLY the Overlay Planes" },
	{ '\0', 0, 0, "" }
};

/*
 *  GSD Unit Numbers (bottom 3 bits is the "Monitor"):
 *	0 for Red channel	(GMA0)
 *	1 for Green channel	(GMA1)
 *	2 for Blue channel	(GMA2)
 *	3 for Overlay channel	(GMA3)
 *	4 for RGB channels	(24bit GMA0-GMA2)
 *	5 for 8bit into RGB channels (8bit GMA0-GMA2)
 *
 *  The hardware maintains 32 Graphics Units which hold a set of
 *  "Local Attributes" (drawing colors, wite mask, clip rectangle, etc.)
 *  The GDSLIB also associates a display list buffer with each open unit.
 *  The bottom 3 bits of the Unit Number (0-7) become the "Monitor"
 *  which is one of eight mappings of GMA's (Graphics Memory Arrays)
 *  maintained by the GDP (Graphics Drawing Processor).
 *  Global_Attributes[Unit] -> Local_Attributes[Monitor] -> Monitor_Def
 */
static int unit = 4;

_LOCAL_ int
ts_open( ifp, file, width, height )
FBIO	*ifp;
char	*file;
int	width, height;
{
	struct point	viewmax;
	int mode;
	char curs_bitmap[512];
	int i;

	FB_CK_FBIO(ifp);

	/*
	 *  First, attempt to determine operating mode for this open,
	 *  based upon the "unit number" or flags.
	 *  file = "/dev/X###"
	 *  The default mode is zero.
	 */
	mode = 0;
	if( file != NULL )  {
		register char *cp;
		char	modebuf[80];
		char	*mp;
		int	alpha;
		struct	modeflags *mfp;

		if( strncmp(file, "/dev/ts", 7) ) {
			/* How did this happen?? */
			mode = 0;
		}
		else {
			/* Parse the options */
			alpha = 0;
			mp = &modebuf[0];
			cp = &file[7];
			while( *cp != '\0' && !isspace(*cp) ) {
				*mp++ = *cp;	/* copy it to buffer */
				if( isdigit(*cp) ) {
					cp++;
					continue;
				}
				alpha++;
				for( mfp = modeflags; mfp->c != '\0'; mfp++ ) {
					if( mfp->c == *cp ) {
						mode = (mode&~mfp->mask)|mfp->value;
						break;
					}
				}
				if( mfp->c == '\0' && *cp != '-' ) {
					fb_log( "if_ts: unknown option '%c' ignored\n", *cp );
				}
				cp++;
			}
			*mp = '\0';
			if( !alpha )
				mode = atoi( modebuf );
			if (strlen(cp) > 0) {
				unit = atoi(cp);
				printf("Unit %d\n", unit);
			}
		}
	}

	/*printf("GSD unit = %d\n", unit);*/
	/* GDSLSIZE 16bit words in display list */
	if (open_gds(unit,GDSDLSIZE) < 0) {
		fb_log("error %d\n", f_geterror());
		exit(1);
	}
	init_gds(0);	/* if non-zero, will clear to altcolor */

#if 0
	if ((mode&MODE_2MASK) == MODE_2OVERONLY) {
printf("Overlay Only\n");
		f_ovlset(GDS_OVL_DISPLAY, GDS_OVL_ONLY, 0);
	} else if ((mode&MODE_1MASK) == MODE_1OVERLAY) {
printf("Overlay On\n");
		f_ovlset(GDS_OVL_DISPLAY, GDS_OVL_ON, 0);
	} else {
/* Seems that even doing this overlay off command leaves us with
 * only the RED channel.
 */
printf("Overlay Off\n");
		f_ovlset(GDS_OVL_DISPLAY, GDS_OVL_OFF, 0);
	}
#endif

	getviewmax(&viewmax);
	ifp->if_width = viewmax.x + 1;
	ifp->if_height = viewmax.y + 1;

	/* Initialize the hardware cursor bitmap */
	for (i = 0; i < 512; i++) {
		/* start with black */
		curs_bitmap[i] = 0;
	}
	for (i = 0; i < 8; i++) {
		/* fill in top and bottom rows */
		curs_bitmap[i] = 255;
		curs_bitmap[i+504] = 255;
	}
	for (i = 0; i < 64; i++) {
		/* then three columns */
		curs_bitmap[i*8] |= 0x80;
		curs_bitmap[i*8+7] |= 0x01;
		curs_bitmap[i*8+4] |= 0x80;
	}
	f_hwcset(GDS_HWC_BITMAP, curs_bitmap, 0);

	return(0);
}

_LOCAL_ int
ts_close( ifp )
FBIO	*ifp;
{
	close_gds(unit);
	return(0);
}

_LOCAL_ int
ts_clear( ifp, pp )
FBIO	*ifp;
RGBpixel	*pp;
{
	struct	rectangle rect;

	if (pp != RGBPIXEL_NULL) {
		setaltcolor(COLR24((*pp)[RED],(*pp)[GRN],(*pp)[BLU]));
	} else {
		setaltcolor(COLR24(0,0,0));
	}

	rect.x0 = 0;
	rect.y0 = 0;
	rect.x1 = 1279;
	rect.y1 = 1023;
	if (f_fillrect(&rect)) {
		fb_log("error 3 %d\n", f_geterror());
		exit(1);
	}
	/* XXX - Note that this may not flush the display list */

	return(0);
}

_LOCAL_ int
ts_read( ifp, x, y, pixelp, count )
FBIO	*ifp;
int	x, y;
RGBpixel	*pixelp;
int	count;
{
	struct	point dest;
	struct	size size;

	dest.x = x;
	dest.y = y;
	size.width = count;
	size.height = 1;	/*XXX*/

	f_rdpixar_f(&dest,&size,2,pixelp);
	return(count);
}

_LOCAL_ int
ts_write( ifp, x, y, pixelp, count )
FBIO	*ifp;
int	x, y;
RGBpixel	*pixelp;
int	count;
{
	struct	point dest;
	struct	size size;
	int	i;
	unsigned char lbuf[1280][4];

#if 1
	for (i = 0; i < count; i++) {
		/*lbuf[i][0] = 0;*/
		lbuf[i][1] = pixelp[i][BLU];
		lbuf[i][2] = pixelp[i][GRN];
		lbuf[i][3] = pixelp[i][RED];
	}
#endif

	dest.x = x;
	dest.y = y;
	size.width = count;
	size.height = 1;	/*XXX*/
#if 0
	f_pixar_ff(&dest,&size,2,pixelp);
#else
#	if 0
	/* This way dumps core if writes are longer than 1020 bytes -M */
	f_pixar_ff(&dest,&size,3,lbuf);
#	else
	if( count > 800 )  {
		size.width = 800;
		f_pixar_ff(&dest,&size,3,lbuf);
		size.width = count-800;
		dest.x = 800;
		f_pixar_ff(&dest,&size,3,&lbuf[800][0]);
	} else {
		f_pixar_ff(&dest,&size,3,lbuf);
	}
#	endif
#endif

	return(count);
}

_LOCAL_ int
ts_rmap( ifp, cmp )
FBIO	*ifp;
ColorMap	*cmp;
{
	int	i;
	struct color cmap[256];

	if (f_rdclut(0,256,cmap)) {
		fb_log("error 2\n");
		exit(1);
	}
	for (i = 0; i < 256; i++) {
		cmp->cm_red[i] = cmap[i].red << 8;
		cmp->cm_green[i] = cmap[i].green << 8;
		cmp->cm_blue[i] = cmap[i].blue << 8;
	}

	return(0);
}

_LOCAL_ int
ts_wmap( ifp, cmp )
FBIO	*ifp;
ColorMap	*cmp;
{
	int	i;
	struct color cmap[256];

	if (cmp != COLORMAP_NULL) {
		for (i = 0; i < 256; i++) {
			cmap[i].red = cmp->cm_red[i]>>8;
			cmap[i].green = cmp->cm_green[i]>>8;
			cmap[i].blue = cmp->cm_blue[i]>>8;
		}
	} else {
		for (i = 0; i < 256; i++)
			cmap[i].red = cmap[i].green = cmap[i].blue = i;
	}
	if (f_wrclut(0,256,cmap)) {
		fb_log("error 2\n");
		exit(1);
	}

	return(0);
}


/*
 * Note: at first I didn't have any display list flushes in here and it
 * worked fine.  Then it started messing up so I added one at the end
 * (having learned from the cursor routine).  But, that would mess up.
 * The two flush version is working again.  Strange....
 */
_LOCAL_ int
ts_view( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	xcenter, ycenter;
int	xzoom, yzoom;
{
	struct point panorigin;
	struct point factor;

	if (xzoom <= 0) xzoom = 1;
	if (yzoom <= 0) yzoom = 1;

	/* save a working copy for outselves */
	ifp->if_xcenter = xcenter;
	ifp->if_ycenter = xcenter;
	ifp->if_xzoom = xzoom;
	ifp->if_yzoom = yzoom;

	panorigin.x = xcenter - ifp->if_width/(2*xzoom);
	panorigin.y = ycenter - ifp->if_height/(2*yzoom);
	f_pan(panorigin.x, panorigin.y);
	f_exec_wr_dl(0);	/* flush display list, no wait */

	factor.x = xzoom;
	factor.y = yzoom;
	f_zoom(factor.x, factor.y);
	f_exec_wr_dl(0);	/* flush display list, no wait */

	return(0);
}

/* return base^pow */
_LOCAL_ int
ipow(base,pow)
int base;
int pow;
{
	int	i, n;

	if (pow <= 0)
		return	1;

	n = base;
	for (i = 1; i < pow; i++)
		n *= base;

	return	n;
}

/*
 *  Note: A bug in the GDSLIB causes the yzoom factor to be read
 *  back as a power of two, rather than as a pixel replication count.
 */
_LOCAL_ int
ts_getview( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	*xcenter, *ycenter;
int	*xzoom, *yzoom;
{
	struct point rpanorigin;
	struct point rfactor;

	f_rdzoom(&rfactor);
	ifp->if_xzoom = rfactor.x;
	ifp->if_yzoom = ipow(2,rfactor.y);	/* Bug fix - see above */
	*xzoom = ifp->if_xzoom;
	*yzoom = ifp->if_yzoom;

	/* read lower left pixel coordinate */
	f_rdpan(&rpanorigin);
	/* convert to center pixel coordinate */
	*xcenter = rpanorigin.x + ifp->if_width/(2*ifp->if_xzoom);
	*ycenter = rpanorigin.y + ifp->if_height/(2*ifp->if_yzoom);

#if 0
	printf("getview: hw pan %d %d\n\r", rpanorigin.x, rpanorigin.y);
	printf("getview: hw zoom %d %d\n\r", rfactor.x, rfactor.y);
	printf("getview: returning %d %d %d %d\n", *xcenter, *ycenter, *xzoom, *yzoom);
#endif

	return(0);
}

_LOCAL_ int
ts_setcursor( ifp, bits, xbits, ybits, xorig, yorig )
FBIO	*ifp;
unsigned char *bits;
int	xbits, ybits;
int	xorig, yorig;
{
	return(0);
}

_LOCAL_ int
ts_cursor( ifp, mode, x, y )
FBIO	*ifp;
int	mode;
int	x, y;
{
	struct point pos;
	struct color color;
	struct rectangle rect;

	pos.x = x;
	pos.y = y;
	color.red = 255;
	color.green = 255;
	color.blue = 255;
	rect.x0 = 0;
	rect.x1 = 1279;

	/* XXX - BUG in GDSLIB, has these two backward! */
	rect.y1 = 0;
	rect.y0 = -1023;	/* Gross... */

	if (!mode) {
		f_hwcset(GDS_HWC_STYLE, GDS_HWCS_OFF, 0);
	} else {
		f_hwcset(GDS_HWC_STYLE, GDS_HWCS_CH1|GDS_HWCS_BITMAP,
			GDS_HWC_ASSIGN, 4,
			GDS_HWC_COLOR, &color,
			GDS_HWC_WINDOW, &rect,
			GDS_HWC_POSITION, &pos, 0);
	}
	f_exec_wr_dl(0);	/* flush display list, no wait */

#if 0
{
	int	assign;
	struct point *pp;
	assign = f_hwcget(GDS_HWC_ASSIGN);
	pp = (struct point *)f_hwcget(GDS_HWC_POSITION);
	printf("cursor: %d %d %d\n", assign, pp->x, pp->y);
}
#endif

	return(0);
}

_LOCAL_ int
ts_getcursor( ifp, mode, x, y )
FBIO	*ifp;
int	*mode;
int	*x, *y;
{
	/*int	style;*/
	int	assign;
	struct point *pp;

	/*style = f_hwcget(GDS_HWC_ASSIGN);*/
	assign = f_hwcget(GDS_HWC_ASSIGN);
	pp = (struct point *)f_hwcget(GDS_HWC_POSITION);

	if (assign)
		*mode = 1;
	else
		*mode = 0;
	*x = pp->x;
	*y = pp->y;
	printf("getcursor: %d %d %d\n", *mode, *x, *y);
}

_LOCAL_ int
ts_readrect( ifp, xmin, ymin, width, height, pp )
FBIO	*ifp;
int	xmin, ymin;
int	width, height;
RGBpixel	*pp;
{
#if 0
	struct	point dest;
	struct	size size;

	dest.x = xmin;
	dest.y = ymin;
	size.width = width;
	size.height = height;
	f_rdpixar_f(&dest,&size,2,pp);

	return( width*height );
#else
	/* until we get 24bit reads that work... sigh */
	return fb_sim_readrect(ifp, xmin, ymin, width, height, pp);
#endif
}

_LOCAL_ int
ts_writerect( ifp, xmin, ymin, width, height, pp )
FBIO	*ifp;
int	xmin, ymin;
int	width, height;
RGBpixel	*pp;
{
#if 0
	struct	point dest;
	struct	size size;

	dest.x = xmin;
	dest.y = ymin;
	size.width = width;
	size.height = height;
	f_pixar_ff(&dest,&size,2,pp);

	return( width*height );
#else
	/* until we get 24bit writes that work... sigh */
	return fb_sim_writerect(ifp, xmin, ymin, width, height, pp);
#endif
}

_LOCAL_ int
ts_flush( ifp )
FBIO	*ifp;
{
	f_exec_wr_dl(0);	/* flush display list, no wait */
	return(0);
}

_LOCAL_ int
ts_free( ifp )
FBIO	*ifp;
{
	/* XXX - should reset everything to sane mode */
	return(0);
}

_LOCAL_ int
ts_help( ifp )
FBIO	*ifp;
{
	struct	modeflags *mfp;

	fb_log( "Description: %s\n", ts_interface.if_type );
	fb_log( "Device: %s\n", ifp->if_name );
	fb_log( "Max width/height: %d %d\n",
		ts_interface.if_max_width,
		ts_interface.if_max_height );
	fb_log( "Default width/height: %d %d\n",
		ts_interface.if_width,
		ts_interface.if_height );
	fb_log( "Usage: /dev/ts[options] [channel]\n" );
	for( mfp = modeflags; mfp->c != '\0'; mfp++ ) {
		fb_log( "   %c   %s\n", mfp->c, mfp->help );
	}
	fb_log( "Channel Numbers:\n");
	fb_log( " 0 for Red channel\n");
	fb_log( " 1 for Green channel\n");
	fb_log( " 2 for Blue channel\n");
	fb_log( " 3 for Overlay channel\n");
	fb_log( " 4 for RGB channels\n");
	return(0);
}
@


11.4
log
@change conf.h to a wrapped config.h
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/libfb/if_ts.c,v 11.3 2004/02/02 17:39:13 morrison Exp $ (BRL)";
@


11.3
log
@update copyright to include span through 2003
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ts.c,v 11.2 1998/06/27 04:29:17 mike Exp $ (BRL)";
d29 5
a33 1
#include "conf.h"
@


11.2
log
@Additions to LIBFB interface and remote framebuffer protocol to
read and write monochrome rectangles.
Particularly important for sending thermal images at high speed.
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1990 by the United States Army.
d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ts.c,v 11.1 1995/01/04 09:53:09 mike Rel4_4 $ (BRL)";
@


11.2.6.1
log
@sync branch with HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d26 1
a26 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.2.8.1
log
@sync to HEAD...
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libfb/if_ts.c,v 11.3 2004/02/02 17:39:13 morrison Exp $ (BRL)";
@


11.2.14.1
log
@merge from HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ts.c,v 11.3 2004/02/02 17:39:13 morrison Exp $ (BRL)";
@


11.2.14.2
log
@merge from head
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_ts.c,v 11.2.14.1 2004/02/12 19:48:12 erikg Exp $ (BRL)";
@


11.1
log
@Release_4.4
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ts.c,v 10.2 94/08/12 20:25:52 gdurf Exp $ (BRL)";
d76 2
@


10.2
log
@Added includes
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ts.c,v 10.1 1991/10/12 06:37:32 mike Rel4_0 gdurf $ (BRL)";
@


10.1
log
@Release_4.0
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ts.c,v 1.6 91/10/12 02:27:33 phil Exp $ (BRL)";
d29 5
@


1.6
log
@Having problem with 24-bit rectangle reads
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ts.c,v 1.5 91/09/26 05:10:59 phil Exp Locker: phil $ (BRL)";
@


1.5
log
@Made if_flush actually flush the display list.  Added missing argument
to flush calls.  Fixed compile warning message.  Defined a cursor bitmap.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: if_ts.c,v 1.4 91/07/26 22:41:16 phil Locked $ (BRL)";
d290 9
d572 10
a581 1
	/* XXX */
d583 4
@


1.4
log
@Added if_magic field, and FB_CK_FBIO() macro, to allow checking
FBIO pointers
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ts.c,v 1.3 91/02/09 04:16:10 mike Exp $ (BRL)";
d144 2
d228 18
d278 1
d330 1
a330 1
		f_pixar_ff(&dest,&size,3,&lbuf[800]);
d415 1
a415 1
	f_exec_wr_dl();		/* flush display list */
d420 1
a420 1
	f_exec_wr_dl();		/* flush display list */
d518 1
a518 1
	f_exec_wr_dl();		/* flush display list */
d595 1
d603 1
@


1.3
log
@This hack version can write full-width scanlines.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: if_ts.c,v 1.2 90/12/12 08:03:18 mike Locked $ (BRL)";
d56 1
d144 2
@


1.2
log
@A nights work.  Somewhat better shape.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_ts.c,v 9.9 90/12/11 22:56:37 phil Exp $ (BRL)";
d297 2
d300 11
@


1.1
log
@My original experimental version
@
text
@d2 1
a2 1
 *  How to add a new device interface:
d4 20
a23 15
 *  Copy this file to if_devname.c
 *  Do a global replace of DEVNAME with your devname.
 *   (In the interest of non-flexnames, DEVNAME should be no more
 *   than three characters; except perhaps for DEVNAME_interface)
 *  Fill in the device description, max width and height,
 *   default width and height, and shortname (what you will
 *   look it up as).
 *  Set the unimplemented functions to "fb_null"
 *   (and remove the skeletons if you're tidy)
 *  Set DEVNAME_readrect to fb_sim_readrect, and DEVNAME_writerect
 *   to fb_sim_writerect, if not implemented.
 *  Make DEVNAME_free call DEVNAME_close if not implemented.
 *  Go add an "ifdef IF_DEVNAME" to fb_generic.c (two places).
 *  Add defines to ../Cakefile.defs.
 *  Replace this header.
d25 3
a35 1
		ts_reset(),
d41 4
a44 3
		ts_viewport(),
		ts_window(),
		ts_zoom(),
d47 1
a47 1
		ts_scursor(),
d56 19
a74 20
	ts_open,		/* open device	*/
	ts_close,		/* close device	*/
	ts_reset,		/* reset device	*/
	ts_clear,		/* clear device	*/
	ts_read,		/* read	pixels	*/
	ts_write,		/* write pixels */
	ts_rmap,		/* rmap - read colormap	*/
	ts_wmap,		/* wmap - write colormap */
	ts_viewport,	/* viewport set	*/
	ts_window,		/* window set	*/
	ts_zoom,		/* zoom set	*/
	ts_setcursor,	/* setcursor - define cursor	*/
	ts_cursor,		/* cursor - memory address	*/
	ts_scursor,	/* scursor - screen address	*/
	ts_readrect,	/* readrect - read rectangle	*/
	ts_writerect,	/* writerect - write rectangle	*/
	ts_flush,		/* flush output	*/
	ts_free,		/* free resources */
	ts_help,		/* help message	*/
	"Tech-Source GDS 39xx",	/* device description	*/
d80 1
d82 3
d116 17
d195 2
d201 1
a201 1
	init_gds(0);
d211 3
d220 2
a221 2
	ifp->if_width = viewmax.x;
	ifp->if_height = viewmax.y;
a234 7
ts_reset( ifp )
FBIO	*ifp;
{
	return(0);
}

_LOCAL_ int
d350 7
d358 1
a358 1
ts_viewport( ifp, left, top, right, bottom )
d360 2
a361 1
int	left, top, right, bottom;
d363 22
d388 1
d390 3
a392 3
ts_window( ifp, x, y )
FBIO	*ifp;
int	x, y;
d394 1
a394 2
	struct point panorigin;
	struct point rpanorigin;
d396 2
a397 6
	panorigin.x = x - ifp->if_width/2;
	panorigin.y = y - ifp->if_height/2;
	f_pan(panorigin.x, panorigin.y);
printf("pan %d %d -> %d %d\n\r", x, y, panorigin.x, panorigin.y);
	f_rdpan(&rpanorigin);
printf("hw pan %d %d\n\r", rpanorigin.x, rpanorigin.y);
d399 5
a403 1
	return(0);
d406 4
d411 1
a411 1
ts_zoom( ifp, x, y )
d413 2
a414 1
int	x, y;
d416 1
a416 1
	struct point factor;
a418 4
	factor.x = x;
	factor.y = y;
	f_zoom(factor.x, factor.y);
printf("zoom %d %d\n\r", factor.x, factor.y);
d420 4
a423 1
printf("hw zoom %d %d\n\r", rfactor.x, rfactor.y);
d425 12
d458 1
d465 2
d468 4
d475 2
a476 1
		f_hwcset(GDS_HWC_STYLE, GDS_HWCS_CH1,
d478 1
d481 1
d483 10
d497 1
a497 1
ts_scursor( ifp, mode, x, y )
d499 2
a500 2
int	mode;
int	x, y;
d502 3
a504 2
	struct point pos;
	struct color color;
d506 3
a508 5
	pos.x = x;
	pos.y = y;
	color.red = 255;
	color.green = 255;
	color.blue = 255;
d510 7
a516 8
	if (!mode) {
		f_hwcset(GDS_HWC_STYLE, GDS_HWCS_OFF, 0);
	} else {
		f_hwcset(GDS_HWC_STYLE, GDS_HWCS_CH1,
			GDS_HWC_COLOR, &color,
			GDS_HWC_POSITION, &pos, 0);
	}
	return(0);
d526 1
d537 1
d548 4
@
