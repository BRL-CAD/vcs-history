head	11.11;
access;
symbols
	ansi-20040405-merged:11.6.2.2
	postmerge-20040405-ansi:11.9
	premerge-20040404-ansi:11.8
	postmerge-autoconf:11.8
	autoconf-freeze:11.6.10.3
	premerge-autoconf:11.8
	ansi-20040316-freeze:11.6.2.1
	postmerge-20040315-windows:11.8
	premerge-20040315-windows:11.7
	windows-20040315-freeze:11.6.4.2
	autoconf-20031203:11.6
	autoconf-20031202:11.6
	autoconf-branch:11.6.0.10
	phong-branch:11.6.0.8
	photonmap-branch:11.6.0.6
	rel-6-1-DP:11.6
	windows-branch:11.6.0.4
	rel-6-0-2:11.4
	ansi-branch:11.6.0.2
	rel-6-0-1-branch:11.4.0.2
	hartley-6-0-post:11.5
	hartley-6-0-pre:11.4
	rel-6-0-1:11.4
	rel-6-0:11.4
	rel-5-4:11.2
	offsite-5-3-pre:11.3
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1;
locks; strict;
comment	@ * @;


11.11
date	2004.05.21.18.07.25;	author morrison;	state dead;
branches;
next	11.10;

11.10
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	11.9;

11.9
date	2004.04.05.07.44.42;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2004.03.16.19.59.35;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2004.02.02.17.39.12;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	2002.08.20.17.07.47;	author jra;	state Exp;
branches
	11.6.2.1
	11.6.4.1
	11.6.10.1;
next	11.5;

11.5
date	2002.08.15.20.55.01;	author hartley;	state Exp;
branches;
next	11.4;

11.4
date	2001.04.20.22.29.15;	author morrison;	state Exp;
branches;
next	11.3;

11.3
date	2000.07.12.01.33.31;	author cjohnson;	state Exp;
branches;
next	11.2;

11.2
date	98.06.27.04.29.17;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.53.04;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.08.12.20.25.45;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	93.09.25.08.42.37;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.37.30;	author mike;	state Rel4_0;
branches;
next	9.7;

9.7
date	91.07.26.22.41.13;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	91.07.19.01.02.30;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	91.07.18.16.32.42;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	91.01.10.23.58.27;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.12.11.22.20.35;	author phil;	state Exp;
branches;
next	9.2;

9.2
date	89.09.01.01.46.15;	author phil;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.48.11;	author mike;	state Rel3_5;
branches;
next	8.2;

8.2
date	89.03.03.05.54.46;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.27.46;	author mike;	state Rel3_0;
branches;
next	1.4;

1.4
date	88.10.01.05.40.14;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	88.09.14.17.30.11;	author phil;	state Exp;
branches;
next	1.2;

1.2
date	88.09.09.23.45.10;	author phil;	state Exp;
branches;
next	1.1;

1.1
date	88.07.14.21.01.27;	author phil;	state Exp;
branches;
next	;

11.6.2.1
date	2002.09.19.18.01.19;	author morrison;	state Exp;
branches;
next	11.6.2.2;

11.6.2.2
date	2004.03.17.21.17.02;	author morrison;	state Exp;
branches;
next	;

11.6.4.1
date	2002.09.26.23.03.55;	author morrison;	state Exp;
branches;
next	11.6.4.2;

11.6.4.2
date	2004.03.11.23.42.07;	author morrison;	state Exp;
branches;
next	;

11.6.10.1
date	2004.02.12.19.48.12;	author erikg;	state Exp;
branches;
next	11.6.10.2;

11.6.10.2
date	2004.03.15.14.06.20;	author erikg;	state Exp;
branches;
next	11.6.10.3;

11.6.10.3
date	2004.03.18.18.10.28;	author erikg;	state Exp;
branches;
next	;


desc
@/dev/stack to allow multiple frame buffers to be ganged together
@


11.11
log
@moved to src/
@
text
@/*
 *			I F _ S T A C K . C
 *
 *  Allows multiple frame buffers to be ganged together.
 *
 *  Authors -
 *	Phillip Dykstra
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *
 * Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libfb/if_stack.c,v 11.10 2004/05/10 15:30:45 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "machine.h"
#include "externs.h"
#include "fb.h"
#include "./fblocal.h"

_LOCAL_ int	stk_open(FBIO *ifp, char *file, int width, int height),
		stk_close(FBIO *ifp),
		stk_clear(FBIO *ifp, unsigned char *pp),
		stk_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count),
		stk_write(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count),
		stk_rmap(FBIO *ifp, ColorMap *cmp),
		stk_wmap(FBIO *ifp, const ColorMap *cmp),
		stk_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
		stk_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom),
		stk_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig),
		stk_cursor(FBIO *ifp, int mode, int x, int y),
		stk_getcursor(FBIO *ifp, int *mode, int *x, int *y),
		stk_readrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp),
		stk_writerect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp),
		stk_bwreadrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp),
		stk_bwwriterect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp),
		stk_poll(FBIO *ifp),
		stk_flush(FBIO *ifp),
		stk_free(FBIO *ifp),
		stk_help(FBIO *ifp);



/* This is the ONLY thing that we normally "export" */
FBIO stk_interface =  {
	0,
	stk_open,		/* device_open		*/
	stk_close,		/* device_close		*/
	stk_clear,		/* device_clear		*/
	stk_read,		/* buffer_read		*/
	stk_write,		/* buffer_write		*/
	stk_rmap,		/* colormap_read	*/
	stk_wmap,		/* colormap_write	*/
	stk_view,		/* set view		*/
	stk_getview,		/* get view		*/
	stk_setcursor,		/* define cursor	*/
	stk_cursor,		/* set cursor		*/
	stk_getcursor,		/* get cursor		*/
	stk_readrect,		/* read rectangle	*/
	stk_writerect,		/* write rectangle	*/
	stk_bwreadrect,		/* read bw rectangle	*/
	stk_bwwriterect,	/* write bw rectangle	*/
	stk_poll,		/* handle events	*/
	stk_flush,		/* flush output		*/
	stk_free,		/* free resources	*/
	stk_help,		/* help function	*/
	"Multiple Device Stacker", /* device description */
	1024*32,		/* max width		*/
	1024*32,		/* max height		*/
	"/dev/stack",		/* short device name	*/
	4,			/* default/current width  */
	4,			/* default/current height */
	-1,			/* select fd		*/
	-1,			/* file descriptor	*/
	1, 1,			/* zoom			*/
	2, 2,			/* window center	*/
	0, 0, 0,		/* cursor		*/
	PIXEL_NULL,		/* page_base		*/
	PIXEL_NULL,		/* page_curp		*/
	PIXEL_NULL,		/* page_endp		*/
	-1,			/* page_no		*/
	0,			/* page_dirty		*/
	0L,			/* page_curpos		*/
	0L,			/* page_pixels		*/
	0			/* debug		*/
};

/* List of interface struct pointers, one per dev */
#define	MAXIF	32
struct	stkinfo {
	FBIO	*if_list[MAXIF];
};
#define	SI(ptr) ((struct stkinfo *)((ptr)->u1.p))
#define	SIL(ptr) ((ptr)->u1.p)		/* left hand side version */

_LOCAL_ int
stk_open(FBIO *ifp, char *file, int width, int height)
{
	int	i;
	char	*cp;
	char	devbuf[80];

	FB_CK_FBIO(ifp);

	/* Check for /dev/stack */
	if( strncmp(file,ifp->if_name,strlen("/dev/stack")) != 0 ) {
		fb_log( "stack_dopen: Bad device %s\n", file );
		return(-1);
	}

	if( (SIL(ifp) = (char *)calloc( 1, sizeof(struct stkinfo) )) == NULL )  {
		fb_log("stack_dopen:  stkinfo malloc failed\n");
		return(-1);
	}

	cp = &file[strlen("/dev/stack")];
	while( *cp != '\0' && *cp != ' ' && *cp != '\t' )
		cp++;	/* skip suffix */

	/* special check for a possibly user confusing case */
	if( *cp == '\0' ) {
		fb_log("stack_dopen: No devices specified\n");
		fb_log("Usage: /dev/stack device_one; device_two; [etc]\n");
		return(-1);
	}

	ifp->if_width = ifp->if_max_width;
	ifp->if_height = ifp->if_max_height;
	i = 0;
	while( i < MAXIF && *cp != '\0' ) {
		register char	*dp;
		register FBIO	*fbp;

		while( *cp != '\0' && (*cp == ' ' || *cp == '\t' || *cp == ';') )
			cp++;	/* skip blanks and separators */
		if( *cp == '\0' )
			break;
		dp = devbuf;
		while( *cp != '\0' && *cp != ';' )
			*dp++ = *cp++;
		*dp = '\0';
		if( (fbp = fb_open(devbuf, width, height)) != FBIO_NULL )  {
			FB_CK_FBIO(fbp);
			/* Track the minimum of all the actual sizes */
			if( fbp->if_width < ifp->if_width )
				ifp->if_width = fbp->if_width;
			if( fbp->if_height < ifp->if_height )
				ifp->if_height = fbp->if_height;
			if( fbp->if_max_width < ifp->if_max_width )
				ifp->if_max_width = fbp->if_max_width;
			if( fbp->if_max_height < ifp->if_max_height )
				ifp->if_max_height = fbp->if_max_height;
			SI(ifp)->if_list[i++] = fbp;
		}
	}
	if( i > 0 )
		return(0);
	else
		return(-1);
}

_LOCAL_ int
stk_close(FBIO *ifp)
{
	register FBIO **ip = SI(ifp)->if_list;

	FB_CK_FBIO(ifp);
	while( *ip != (FBIO *)NULL ) {
		FB_CK_FBIO( (*ip) );
		fb_close( (*ip) );
		ip++;
	}

	return(0);
}

_LOCAL_ int
stk_clear(FBIO *ifp, unsigned char *pp)
{
	register FBIO **ip = SI(ifp)->if_list;

	while( *ip != (FBIO *)NULL ) {
		fb_clear( (*ip), pp );
		ip++;
	}

	return(0);
}

_LOCAL_ int
stk_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count)
{
	register FBIO **ip = SI(ifp)->if_list;

	if( *ip != (FBIO *)NULL ) {
		fb_read( (*ip), x, y, pixelp, count );
	}

	return(count);
}

_LOCAL_ int
stk_write(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count)
{
	register FBIO **ip = SI(ifp)->if_list;

	while( *ip != (FBIO *)NULL ) {
		fb_write( (*ip), x, y, pixelp, count );
		ip++;
	}

	return(count);
}

/*
 *			S T K _ R E A D R E C T
 *
 *  Read only from the first source on the stack.
 */
_LOCAL_ int
stk_readrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp)
{
	register FBIO **ip = SI(ifp)->if_list;

	if( *ip != (FBIO *)NULL ) {
		(void)fb_readrect( (*ip), xmin, ymin, width, height, pp );
	}

	return( width*height );
}

/*
 *			S T K _ W R I T E R E C T
 *
 *  Write to all destinations on the stack
 */
_LOCAL_ int
stk_writerect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp)
{
	register FBIO **ip = SI(ifp)->if_list;

	while( *ip != (FBIO *)NULL ) {
		(void)fb_writerect( (*ip), xmin, ymin, width, height, pp );
		ip++;
	}

	return( width*height );
}

/*
 *			S T K _ B W R E A D R E C T
 *
 *  Read only from the first source on the stack.
 */
_LOCAL_ int
stk_bwreadrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp)
{
	register FBIO **ip = SI(ifp)->if_list;

	if( *ip != (FBIO *)NULL ) {
		(void)fb_bwreadrect( (*ip), xmin, ymin, width, height, pp );
	}

	return width*height;
}

/*
 *			S T K _ B W W R I T E R E C T
 *
 *  Write to all destinations on the stack
 */
_LOCAL_ int
stk_bwwriterect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp)
{
	register FBIO **ip = SI(ifp)->if_list;

	while( *ip != (FBIO *)NULL ) {
		(void)fb_bwwriterect( (*ip), xmin, ymin, width, height, pp );
		ip++;
	}

	return width*height;
}

_LOCAL_ int
stk_rmap(FBIO *ifp, ColorMap *cmp)
{
	register FBIO **ip = SI(ifp)->if_list;

	if( *ip != (FBIO *)NULL ) {
		fb_rmap( (*ip), cmp );
	}

	return(0);
}

_LOCAL_ int
stk_wmap(FBIO *ifp, const ColorMap *cmp)
{
	register FBIO **ip = SI(ifp)->if_list;

	while( *ip != (FBIO *)NULL ) {
		fb_wmap( (*ip), cmp );
		ip++;
	}

	return(0);
}

_LOCAL_ int
stk_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
{
	register FBIO **ip = SI(ifp)->if_list;

	while( *ip != (FBIO *)NULL ) {
		fb_view( (*ip), xcenter, ycenter, xzoom, yzoom );
		ip++;
	}

	return(0);
}

_LOCAL_ int
stk_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom)
{
	register FBIO **ip = SI(ifp)->if_list;

	if( *ip != (FBIO *)NULL ) {
		fb_getview( (*ip), xcenter, ycenter, xzoom, yzoom );
	}

	return(0);
}

_LOCAL_ int
stk_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig)
{
	register FBIO **ip = SI(ifp)->if_list;

	while( *ip != (FBIO *)NULL ) {
		fb_setcursor( (*ip), bits, xbits, ybits, xorig, yorig );
		ip++;
	}

	return(0);
}

_LOCAL_ int
stk_cursor(FBIO *ifp, int mode, int x, int y)
{
	register FBIO **ip = SI(ifp)->if_list;

	while( *ip != (FBIO *)NULL ) {
		fb_cursor( (*ip), mode, x, y );
		ip++;
	}

	return(0);
}

_LOCAL_ int
stk_getcursor(FBIO *ifp, int *mode, int *x, int *y)
{
	register FBIO **ip = SI(ifp)->if_list;

	if( *ip != (FBIO *)NULL ) {
		fb_getcursor( (*ip), mode, x, y );
	}

	return(0);
}

_LOCAL_ int
stk_poll(FBIO *ifp)
{
	register FBIO **ip = SI(ifp)->if_list;

	while( *ip != (FBIO *)NULL ) {
		fb_poll( (*ip) );
		ip++;
	}

	return(0);
}

_LOCAL_ int
stk_flush(FBIO *ifp)
{
	register FBIO **ip = SI(ifp)->if_list;

	while( *ip != (FBIO *)NULL ) {
		fb_flush( (*ip) );
		ip++;
	}

	return(0);
}

_LOCAL_ int
stk_free(FBIO *ifp)
{
	register FBIO **ip = SI(ifp)->if_list;

	while( *ip != (FBIO *)NULL ) {
		fb_free( (*ip) );
		ip++;
	}

	return(0);
}

_LOCAL_ int
stk_help(FBIO *ifp)
{
	register FBIO **ip = SI(ifp)->if_list;
	int	i;

	fb_log("Device: /dev/stack\n");
	fb_log("Usage: /dev/stack device_one; device_two; [etc]\n");

	i = 0;
	while( *ip != (FBIO *)NULL ) {
		fb_log("=== Current stack device #%d ===\n", i++);
		fb_help( (*ip) );
		ip++;
	}

	return(0);
}
@


11.10
log
@change conf.h to a wrapped config.h
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/libfb/if_stack.c,v 11.9 2004/04/05 07:44:42 morrison Exp $ (BRL)";
@


11.9
log
@merge of ansi-6-0-branch into HEAD
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d22 5
a26 1
#include "conf.h"
@


11.8
log
@merge of windows-6-0-branch into head
@
text
@d35 21
a55 20
_LOCAL_ int	stk_open();
		stk_close(),
		stk_clear(),
		stk_read(),
		stk_write(),
		stk_rmap(),
		stk_wmap(),
		stk_view(),
		stk_getview(),
		stk_setcursor(),
		stk_cursor(),
		stk_getcursor(),
		stk_readrect(),
		stk_writerect(),
		stk_bwreadrect(),
		stk_bwwriterect(),
		stk_poll(),
		stk_flush(),
		stk_free(),
		stk_help();
d111 1
a111 4
stk_open( ifp, file, width, height )
FBIO	*ifp;
char	*file;
int	width, height;
d177 1
a177 2
stk_close( ifp )
FBIO	*ifp;
d192 1
a192 3
stk_clear( ifp, pp )
FBIO	*ifp;
unsigned char	*pp;
d205 1
a205 5
stk_read( ifp, x, y, pixelp, count )
FBIO	*ifp;
int	x, y;
unsigned char	*pixelp;
int	count;
d217 1
a217 5
stk_write( ifp, x, y, pixelp, count )
FBIO	*ifp;
int	x, y;
const unsigned char	*pixelp;
int	count;
d235 1
a235 5
stk_readrect( ifp, xmin, ymin, width, height, pp )
FBIO	*ifp;
int	xmin, ymin;
int	width, height;
unsigned char	*pp;
d252 1
a252 5
stk_writerect( ifp, xmin, ymin, width, height, pp )
FBIO	*ifp;
int	xmin, ymin;
int	width, height;
const unsigned char	*pp;
d270 1
a270 5
stk_bwreadrect( ifp, xmin, ymin, width, height, pp )
FBIO	*ifp;
int	xmin, ymin;
int	width, height;
unsigned char	*pp;
d287 1
a287 5
stk_bwwriterect( ifp, xmin, ymin, width, height, pp )
FBIO	*ifp;
int	xmin, ymin;
int	width, height;
const unsigned char	*pp;
d300 1
a300 3
stk_rmap( ifp, cmp )
FBIO	*ifp;
ColorMap	*cmp;
d312 1
a312 3
stk_wmap( ifp, cmp )
FBIO	*ifp;
const ColorMap	*cmp;
d325 1
a325 4
stk_view( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	xcenter, ycenter;
int	xzoom, yzoom;
d338 1
a338 4
stk_getview( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	*xcenter, *ycenter;
int	*xzoom, *yzoom;
d350 1
a350 5
stk_setcursor( ifp, bits, xbits, ybits, xorig, yorig )
FBIO	*ifp;
const unsigned char *bits;
int	xbits, ybits;
int	xorig, yorig;
d363 1
a363 4
stk_cursor( ifp, mode, x, y )
FBIO	*ifp;
int	mode;
int	x, y;
d376 1
a376 4
stk_getcursor( ifp, mode, x, y )
FBIO	*ifp;
int	*mode;
int	*x, *y;
d388 1
a388 2
stk_poll( ifp )
FBIO	*ifp;
d401 1
a401 2
stk_flush( ifp )
FBIO	*ifp;
d414 1
a414 2
stk_free( ifp )
FBIO	*ifp;
d427 1
a427 2
stk_help( ifp )
FBIO	*ifp;
@


11.7
log
@update copyright to include span through 2003
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_stack.c,v 11.6 2002/08/20 17:07:47 jra Exp $ (BRL)";
d35 1
a35 1
_LOCAL_ int	stk_open(),
d55 1
@


11.6
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_stack.c,v 11.4 2001/04/20 22:29:15 morrison Exp $ (BRL)";
@


11.6.10.1
log
@merge from HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_stack.c,v 11.7 2004/02/02 17:39:12 morrison Exp $ (BRL)";
@


11.6.10.2
log
@merge from head
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_stack.c,v 11.6.10.1 2004/02/12 19:48:12 erikg Exp $ (BRL)";
@


11.6.10.3
log
@merge from head
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d35 1
a35 1
_LOCAL_ int	stk_open();
a54 1

@


11.6.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_stack.c,v 11.6 2002/08/20 17:07:47 jra Exp $ (BRL)";
d35 1
a35 1
_LOCAL_ int	stk_open();
a54 1

@


11.6.4.2
log
@sync to HEAD...
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libfb/if_stack.c,v 11.6.4.1 2002/09/26 23:03:55 morrison Exp $ (BRL)";
@


11.6.2.1
log
@Initial ANSIfication
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_stack.c,v 11.6 2002/08/20 17:07:47 jra Exp $ (BRL)";
d35 20
a54 20
_LOCAL_ int	stk_open(FBIO *ifp, char *file, int width, int height),
		stk_close(FBIO *ifp),
		stk_clear(FBIO *ifp, unsigned char *pp),
		stk_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count),
		stk_write(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count),
		stk_rmap(FBIO *ifp, ColorMap *cmp),
		stk_wmap(FBIO *ifp, const ColorMap *cmp),
		stk_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
		stk_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom),
		stk_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig),
		stk_cursor(FBIO *ifp, int mode, int x, int y),
		stk_getcursor(FBIO *ifp, int *mode, int *x, int *y),
		stk_readrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp),
		stk_writerect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp),
		stk_bwreadrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp),
		stk_bwwriterect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp),
		stk_poll(FBIO *ifp),
		stk_flush(FBIO *ifp),
		stk_free(FBIO *ifp),
		stk_help(FBIO *ifp);
d109 4
a112 1
stk_open(FBIO *ifp, char *file, int width, int height)
d178 2
a179 1
stk_close(FBIO *ifp)
d194 3
a196 1
stk_clear(FBIO *ifp, unsigned char *pp)
d209 5
a213 1
stk_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count)
d225 5
a229 1
stk_write(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count)
d247 5
a251 1
stk_readrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp)
d268 5
a272 1
stk_writerect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp)
d290 5
a294 1
stk_bwreadrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp)
d311 5
a315 1
stk_bwwriterect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp)
d328 3
a330 1
stk_rmap(FBIO *ifp, ColorMap *cmp)
d342 3
a344 1
stk_wmap(FBIO *ifp, const ColorMap *cmp)
d357 4
a360 1
stk_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
d373 4
a376 1
stk_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom)
d388 5
a392 1
stk_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig)
d405 4
a408 1
stk_cursor(FBIO *ifp, int mode, int x, int y)
d421 4
a424 1
stk_getcursor(FBIO *ifp, int *mode, int *x, int *y)
d436 2
a437 1
stk_poll(FBIO *ifp)
d450 2
a451 1
stk_flush(FBIO *ifp)
d464 2
a465 1
stk_free(FBIO *ifp)
d478 2
a479 1
stk_help(FBIO *ifp)
@


11.6.2.2
log
@sync branch with HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a54 1

@


11.5
log
@Converted from K&R to ANSI C - RFH
@
text
@d35 20
a54 20
_LOCAL_ int	stk_open(FBIO *ifp, char *file, int width, int height),
		stk_close(FBIO *ifp),
		stk_clear(FBIO *ifp, unsigned char *pp),
		stk_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count),
		stk_write(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count),
		stk_rmap(FBIO *ifp, ColorMap *cmp),
		stk_wmap(FBIO *ifp, const ColorMap *cmp),
		stk_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
		stk_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom),
		stk_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig),
		stk_cursor(FBIO *ifp, int mode, int x, int y),
		stk_getcursor(FBIO *ifp, int *mode, int *x, int *y),
		stk_readrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp),
		stk_writerect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp),
		stk_bwreadrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp),
		stk_bwwriterect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp),
		stk_poll(FBIO *ifp),
		stk_flush(FBIO *ifp),
		stk_free(FBIO *ifp),
		stk_help(FBIO *ifp);
d109 4
a112 1
stk_open(FBIO *ifp, char *file, int width, int height)
d178 2
a179 1
stk_close(FBIO *ifp)
d194 3
a196 1
stk_clear(FBIO *ifp, unsigned char *pp)
d209 5
a213 1
stk_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count)
d225 5
a229 1
stk_write(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count)
d247 5
a251 1
stk_readrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp)
d268 5
a272 1
stk_writerect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp)
d290 5
a294 1
stk_bwreadrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp)
d311 5
a315 1
stk_bwwriterect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp)
d328 3
a330 1
stk_rmap(FBIO *ifp, ColorMap *cmp)
d342 3
a344 1
stk_wmap(FBIO *ifp, const ColorMap *cmp)
d357 4
a360 1
stk_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
d373 4
a376 1
stk_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom)
d388 5
a392 1
stk_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig)
d405 4
a408 1
stk_cursor(FBIO *ifp, int mode, int x, int y)
d421 4
a424 1
stk_getcursor(FBIO *ifp, int *mode, int *x, int *y)
d436 2
a437 1
stk_poll(FBIO *ifp)
d450 2
a451 1
stk_flush(FBIO *ifp)
d464 2
a465 1
stk_free(FBIO *ifp)
d478 2
a479 1
stk_help(FBIO *ifp)
@


11.4
log
@CONST to const
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_stack.c,v 11.3 2000/07/12 01:33:31 cjohnson Exp $ (BRL)";
d35 20
a54 20
_LOCAL_ int	stk_open(),
		stk_close(),
		stk_clear(),
		stk_read(),
		stk_write(),
		stk_rmap(),
		stk_wmap(),
		stk_view(),
		stk_getview(),
		stk_setcursor(),
		stk_cursor(),
		stk_getcursor(),
		stk_readrect(),
		stk_writerect(),
		stk_bwreadrect(),
		stk_bwwriterect(),
		stk_poll(),
		stk_flush(),
		stk_free(),
		stk_help();
d109 1
a109 4
stk_open( ifp, file, width, height )
FBIO	*ifp;
char	*file;
int	width, height;
d175 1
a175 2
stk_close( ifp )
FBIO	*ifp;
d190 1
a190 3
stk_clear( ifp, pp )
FBIO	*ifp;
unsigned char	*pp;
d203 1
a203 5
stk_read( ifp, x, y, pixelp, count )
FBIO	*ifp;
int	x, y;
unsigned char	*pixelp;
int	count;
d215 1
a215 5
stk_write( ifp, x, y, pixelp, count )
FBIO	*ifp;
int	x, y;
const unsigned char	*pixelp;
int	count;
d233 1
a233 5
stk_readrect( ifp, xmin, ymin, width, height, pp )
FBIO	*ifp;
int	xmin, ymin;
int	width, height;
unsigned char	*pp;
d250 1
a250 5
stk_writerect( ifp, xmin, ymin, width, height, pp )
FBIO	*ifp;
int	xmin, ymin;
int	width, height;
const unsigned char	*pp;
d268 1
a268 5
stk_bwreadrect( ifp, xmin, ymin, width, height, pp )
FBIO	*ifp;
int	xmin, ymin;
int	width, height;
unsigned char	*pp;
d285 1
a285 5
stk_bwwriterect( ifp, xmin, ymin, width, height, pp )
FBIO	*ifp;
int	xmin, ymin;
int	width, height;
const unsigned char	*pp;
d298 1
a298 3
stk_rmap( ifp, cmp )
FBIO	*ifp;
ColorMap	*cmp;
d310 1
a310 3
stk_wmap( ifp, cmp )
FBIO	*ifp;
const ColorMap	*cmp;
d323 1
a323 4
stk_view( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	xcenter, ycenter;
int	xzoom, yzoom;
d336 1
a336 4
stk_getview( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	*xcenter, *ycenter;
int	*xzoom, *yzoom;
d348 1
a348 5
stk_setcursor( ifp, bits, xbits, ybits, xorig, yorig )
FBIO	*ifp;
const unsigned char *bits;
int	xbits, ybits;
int	xorig, yorig;
d361 1
a361 4
stk_cursor( ifp, mode, x, y )
FBIO	*ifp;
int	mode;
int	x, y;
d374 1
a374 4
stk_getcursor( ifp, mode, x, y )
FBIO	*ifp;
int	*mode;
int	*x, *y;
d386 1
a386 2
stk_poll( ifp )
FBIO	*ifp;
d399 1
a399 2
stk_flush( ifp )
FBIO	*ifp;
d412 1
a412 2
stk_free( ifp )
FBIO	*ifp;
d425 1
a425 2
stk_help( ifp )
FBIO	*ifp;
@


11.3
log
@LINT from gcc -Wall.  Including some mods to h/pkg.h
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_stack.c,v 11.2 1998/06/27 04:29:17 mike Exp $ (BRL)";
d228 1
a228 1
CONST unsigned char	*pixelp;
d272 1
a272 1
CONST unsigned char	*pp;
d315 1
a315 1
CONST unsigned char	*pp;
d344 1
a344 1
CONST ColorMap	*cmp;
d390 1
a390 1
CONST unsigned char *bits;
@


11.2
log
@Additions to LIBFB interface and remote framebuffer protocol to
read and write monochrome rectangles.
Particularly important for sending thermal images at high speed.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_stack.c,v 11.1 1995/01/04 09:53:04 mike Rel4_4 $ (BRL)";
d25 5
a29 1

@


11.1
log
@Release_4.4
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_stack.c,v 10.3 94/08/12 20:25:45 gdurf Exp $ (BRL)";
d45 2
d69 2
d239 2
d258 5
d278 43
@


10.3
log
@Added includes
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_stack.c,v 10.2 1993/09/25 08:42:37 mike Exp gdurf $ (BRL)";
@


10.2
log
@Converted to new fb.h
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_stack.c,v 10.1 91/10/12 06:37:30 mike Rel4_0 Locker: mike $ (BRL)";
d22 2
d25 3
@


10.1
log
@Release_4.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_stack.c,v 9.7 91/07/26 22:41:13 mike Exp $ (BRL)";
d183 1
a183 1
RGBpixel	*pp;
d199 1
a199 1
RGBpixel	*pixelp;
d215 1
a215 1
RGBpixel	*pixelp;
d236 1
a236 1
RGBpixel	*pp;
d252 1
a252 1
RGBpixel	*pp;
d281 1
a281 1
ColorMap	*cmp;
d327 1
a327 1
unsigned char *bits;
@


9.7
log
@Added if_magic field, and FB_CK_FBIO() macro, to allow checking
FBIO pointers
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_stack.c,v 9.6 91/07/19 01:02:30 mike Exp $ (BRL)";
@


9.6
log
@lint
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_stack.c,v 9.5 91/07/18 16:32:42 mike Exp $ (BRL)";
d47 1
d105 2
d145 1
d170 1
d172 1
@


9.5
log
@lint
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_stack.c,v 9.4 91/01/10 23:58:27 mike Exp $ (BRL)";
d129 1
a129 1
	while( i < MAXIF && *cp != NULL ) {
@


9.4
log
@Changed so that the size returned is the ACTUAL size of the smallest
framebuffer in the stack, rather than the smaller of that size
and the requested size.

This makes it possible for applications to realize that they were
granted a framebuffer that is bigger than what they asked for.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_stack.c,v 9.3 90/12/11 22:20:35 phil Exp $ (BRL)";
d116 1
a116 1
	while( *cp != NULL && *cp != ' ' && *cp != '\t' )
d120 1
a120 1
	if( *cp == NULL ) {
d133 1
a133 1
		while( *cp != NULL && (*cp == ' ' || *cp == '\t' || *cp == ';') )
d135 1
a135 1
		if( *cp == NULL )
d138 1
a138 1
		while( *cp != NULL && *cp != ';' )
d140 1
a140 1
		*dp = NULL;
@


9.3
log
@if_ struct changes.  See fb.h.
TODO: Or together valid if_selfd's and export them?
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_stack.c,v 9.2 89/09/01 01:46:15 phil Exp $ (BRL)";
d126 2
a127 3
	/* Chamelion mode:  be any size he wants */
	ifp->if_width = width;
	ifp->if_height = height;
d141 2
a142 8
		if( (fbp = fb_open(devbuf, ifp->if_width, ifp->if_height)) != FBIO_NULL )  {
			/* Use first default size found */
			if( ifp->if_width == 0 )
				ifp->if_width = fbp->if_width;
			if( ifp->if_height == 0 )
				ifp->if_height = fbp->if_height;

			/* Track the minimum of all the sizes available */
@


9.2
log
@fb_flush and fb_free.  Name change cleanup.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_stack.c,v 9.1 89/05/19 05:48:11 phil Locked $ (BRL)";
a27 1
		stk_reset(),
d33 2
a34 3
		stk_viewport(),
		stk_window(),
		stk_zoom(),
d37 1
a37 1
		stk_scursor(),
d40 1
a48 1
	stk_reset,		/* device_reset		*/
d54 8
a61 8
	stk_viewport,		/* viewport_set		*/
	stk_window,		/* window_set		*/
	stk_zoom,		/* zoom_set		*/
	stk_setcursor,		/* curs_set		*/
	stk_cursor,		/* cursor_move_memory_addr */
	stk_scursor,		/* cursor_move_screen_addr */
	stk_readrect,		/* readrect		*/
	stk_writerect,		/* writerect		*/
d71 1
d73 3
d149 1
a149 1
			/* Track the minimum of all the sizes availible */
a181 14
stk_reset( ifp )
FBIO	*ifp;
{
	register FBIO **ip = SI(ifp)->if_list;

	while( *ip != (FBIO *)NULL ) {
		fb_reset( (*ip) );
		ip++;
	}

	return(0);
}

_LOCAL_ int
d295 1
a295 1
stk_viewport( ifp, left, top, right, bottom )
d297 2
a298 1
int	left, top, right, bottom;
d303 1
a303 1
		fb_viewport( (*ip), left, top, right, bottom );
d311 1
a311 1
stk_window( ifp, x, y )
d313 2
a314 1
int	x, y;
d318 2
a319 3
	while( *ip != (FBIO *)NULL ) {
		fb_window( (*ip), x, y );
		ip++;
d326 1
a326 1
stk_zoom( ifp, x, y )
d328 3
a330 1
int	x, y;
d335 1
a335 1
		fb_zoom( (*ip), x, y );
d343 1
a343 1
stk_setcursor( ifp, bits, xbits, ybits, xorig, yorig )
d345 2
a346 3
unsigned char *bits;
int	xbits, ybits;
int	xorig, yorig;
d351 1
a351 1
		fb_setcursor( (*ip), bits, xbits, ybits, xorig, yorig );
d359 1
a359 1
stk_cursor( ifp, mode, x, y )
d361 2
a362 2
int	mode;
int	x, y;
d366 2
a367 3
	while( *ip != (FBIO *)NULL ) {
		fb_cursor( (*ip), mode, x, y );
		ip++;
d374 1
a374 1
stk_scursor( ifp, mode, x, y )
a375 2
int	mode;
int	x, y;
d380 1
a380 1
		fb_scursor( (*ip), mode, x, y );
@


9.1
log
@Release_3.5
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_stack.c,v 8.2 89/03/03 05:54:46 mike Exp $ (BRL)";
d26 14
a39 14
_LOCAL_ int	stk_dopen(),
		stk_dclose(),
		stk_dreset(),
		stk_dclear(),
		stk_bread(),
		stk_bwrite(),
		stk_cmread(),
		stk_cmwrite(),
		stk_viewport_set(),
		stk_window_set(),
		stk_zoom_set(),
		stk_curs_set(),
		stk_cmemory_addr(),
		stk_cscreen_addr(),
d42 2
d48 14
a61 14
	stk_dopen,		/* device_open		*/
	stk_dclose,		/* device_close		*/
	stk_dreset,		/* device_reset		*/
	stk_dclear,		/* device_clear		*/
	stk_bread,		/* buffer_read		*/
	stk_bwrite,		/* buffer_write		*/
	stk_cmread,		/* colormap_read	*/
	stk_cmwrite,		/* colormap_write	*/
	stk_viewport_set,	/* viewport_set		*/
	stk_window_set,		/* window_set		*/
	stk_zoom_set,		/* zoom_set		*/
	stk_curs_set,		/* curs_set		*/
	stk_cmemory_addr,	/* cursor_move_memory_addr */
	stk_cscreen_addr,	/* cursor_move_screen_addr */
d64 2
d93 1
a93 1
stk_dopen( ifp, file, width, height )
d166 1
a166 1
stk_dclose( ifp )
d180 1
a180 1
stk_dreset( ifp )
d194 1
a194 1
stk_dclear( ifp, pp )
d209 1
a209 1
stk_bread( ifp, x, y, pixelp, count )
d225 1
a225 1
stk_bwrite( ifp, x, y, pixelp, count )
d278 1
a278 1
stk_cmread( ifp, cmp )
d292 1
a292 1
stk_cmwrite( ifp, cmp )
d307 1
a307 1
stk_viewport_set( ifp, left, top, right, bottom )
d322 1
a322 1
stk_window_set( ifp, x, y )
d337 1
a337 1
stk_zoom_set( ifp, x, y )
d352 1
a352 1
stk_curs_set( ifp, bits, xbits, ybits, xorig, yorig )
d369 1
a369 1
stk_cmemory_addr( ifp, mode, x, y )
d385 1
a385 1
stk_cscreen_addr( ifp, mode, x, y )
d394 28
@


8.2
log
@Added support for fb_readrect() and fb_writerect().
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_stack.c,v 8.1 88/10/05 00:27:46 mike Locked $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_stack.c,v 1.4 88/10/01 05:40:14 mike Exp $ (BRL)";
d40 2
d60 2
d235 36
@


1.4
log
@Made the size of the stacker track the smallest size
of the supplying devices
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_stack.c,v 1.3 88/09/14 17:30:11 mike Locked $ (BRL)";
@


1.3
log
@missing '*' on pointer, slightly better help messages
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_stack.c,v 1.2 88/09/09 23:45:10 phil Locked $ (BRL)";
d60 2
a61 2
	1280,			/* max width		*/
	1024,			/* max height		*/
d63 2
a64 2
	512,			/* default/current width  */
	512,			/* default/current height */
d116 3
d121 3
a123 1
		char	*dp;
d132 18
a149 2
		if( (SI(ifp)->if_list[i] = fb_open(devbuf, width, height)) != FBIO_NULL )
			i++;
@


1.2
log
@fbhelp function
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_stack.c,v 1.1 88/07/14 21:01:27 phil Locked $ (BRL)";
d58 2
a59 2
	stk_help,
	"Device Stacker",	/* device description	*/
d110 1
a110 1
	if( cp == NULL ) {
d112 2
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_adage.c,v 7.3 88/01/06 06:56:02 mike Exp $ (BRL)";
d39 2
a40 1
		stk_cscreen_addr();
d58 1
d109 5
d122 1
a122 1
		while( *cp != NULL && *cp != ' ' && *cp != '\t' && *cp != ';' )
d327 20
@
