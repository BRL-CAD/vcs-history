head	11.11;
access;
symbols
	ansi-20040405-merged:11.7.2.2
	postmerge-20040405-ansi:11.9
	premerge-20040404-ansi:11.8
	postmerge-autoconf:11.8
	autoconf-freeze:11.7.10.2
	premerge-autoconf:11.8
	ansi-20040316-freeze:11.7.2.1
	postmerge-20040315-windows:11.8
	premerge-20040315-windows:11.8
	windows-20040315-freeze:11.7.4.1
	autoconf-20031203:11.7
	autoconf-20031202:11.7
	autoconf-branch:11.7.0.10
	phong-branch:11.7.0.8
	photonmap-branch:11.7.0.6
	rel-6-1-DP:11.7
	windows-branch:11.7.0.4
	rel-6-0-2:11.5
	ansi-branch:11.7.0.2
	rel-6-0-1-branch:11.5.0.2
	hartley-6-0-post:11.6
	hartley-6-0-pre:11.5
	rel-6-0-1:11.5
	rel-6-0:11.5
	rel-5-4:11.3
	offsite-5-3-pre:11.4
	rel-5-3:11.3
	rel-5-2:11.3
	rel-5-1-branch:11.3.0.2
	rel-5-1:11.3
	rel-5-0:11.3
	rel-5-0-beta:11.3
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.11
date	2004.05.21.18.07.25;	author morrison;	state dead;
branches;
next	11.10;

11.10
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	11.9;

11.9
date	2004.04.05.07.44.42;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2004.02.02.17.39.12;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2002.08.20.17.07.47;	author jra;	state Exp;
branches
	11.7.2.1
	11.7.4.1
	11.7.10.1;
next	11.6;

11.6
date	2002.08.15.20.55.00;	author hartley;	state Exp;
branches;
next	11.5;

11.5
date	2001.04.20.22.29.14;	author morrison;	state Exp;
branches;
next	11.4;

11.4
date	2000.07.12.01.33.31;	author cjohnson;	state Exp;
branches;
next	11.3;

11.3
date	98.08.25.00.19.54;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	98.06.27.04.29.16;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.52.54;	author mike;	state Rel4_4;
branches;
next	10.5;

10.5
date	94.12.30.00.22.11;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.11.04.04.58.41;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.08.12.20.25.17;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	93.09.25.08.48.34;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.37.25;	author mike;	state Rel4_0;
branches;
next	1.7;

1.7
date	91.07.26.22.41.05;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	91.07.18.16.33.24;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	90.12.11.22.25.45;	author phil;	state Exp;
branches;
next	1.4;

1.4
date	90.11.08.13.44.02;	author phil;	state Exp;
branches;
next	1.3;

1.3
date	90.11.03.15.41.09;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	89.10.21.01.24.23;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	89.09.01.01.43.21;	author phil;	state Exp;
branches;
next	;

11.7.2.1
date	2002.09.19.18.01.19;	author morrison;	state Exp;
branches;
next	11.7.2.2;

11.7.2.2
date	2004.03.17.21.17.00;	author morrison;	state Exp;
branches;
next	;

11.7.4.1
date	2004.03.11.23.42.07;	author morrison;	state Exp;
branches;
next	;

11.7.10.1
date	2004.02.12.19.48.12;	author erikg;	state Exp;
branches;
next	11.7.10.2;

11.7.10.2
date	2004.03.15.14.06.19;	author erikg;	state Exp;
branches;
next	;


desc
@A Memory Frame Buffer
@


11.11
log
@moved to src/
@
text
@/*
 *			I F _ M E M . C
 *
 *  A Memory (virtual) Frame Buffer Interface.
 *
 *  Authors -
 *	Phillip Dykstra
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1989-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libfb/if_mem.c,v 11.10 2004/05/10 15:30:45 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <ctype.h>
#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "machine.h"
#include "externs.h"			/* For calloc */
#include "fb.h"
#include "./fblocal.h"

_LOCAL_ int	mem_open(FBIO *ifp, char *file, int width, int height),
		mem_close(FBIO *ifp),
		mem_clear(FBIO *ifp, unsigned char *pp),
		mem_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count),
		mem_write(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count),
		mem_rmap(FBIO *ifp, ColorMap *cmp),
		mem_wmap(FBIO *ifp, const ColorMap *cmp),
		mem_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
		mem_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom),
		mem_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig),
		mem_cursor(FBIO *ifp, int mode, int x, int y),
		mem_getcursor(FBIO *ifp, int *mode, int *x, int *y),
		mem_poll(FBIO *ifp),
		mem_flush(FBIO *ifp),
		mem_help(FBIO *ifp);

/* This is the ONLY thing that we normally "export" */
FBIO memory_interface =  {
	0,
	mem_open,		/* device_open		*/
	mem_close,		/* device_close		*/
	mem_clear,		/* device_clear		*/
	mem_read,		/* buffer_read		*/
	mem_write,		/* buffer_write		*/
	mem_rmap,		/* colormap_read	*/
	mem_wmap,		/* colormap_write	*/
	mem_view,		/* set view		*/
	mem_getview,		/* get view		*/
	mem_setcursor,		/* define cursor	*/
	mem_cursor,		/* set cursor		*/
	mem_getcursor,		/* get cursor		*/
	fb_sim_readrect,	/* rectangle read	*/
	fb_sim_writerect,	/* rectangle write	*/
	fb_sim_bwreadrect,
	fb_sim_bwwriterect,
	mem_poll,		/* poll			*/
	mem_flush,		/* flush		*/
	mem_close,		/* free			*/
	mem_help,		/* help message		*/
	"Memory Buffer",	/* device description	*/
	8192,			/* max width		*/
	8192,			/* max height		*/
	"/dev/mem",		/* short device name	*/
	512,			/* default/current width  */
	512,			/* default/current height */
	-1,			/* select fd		*/
	-1,			/* file descriptor	*/
	1, 1,			/* zoom			*/
	256, 256,		/* window center	*/
	0, 0, 0,		/* cursor		*/
	PIXEL_NULL,		/* page_base		*/
	PIXEL_NULL,		/* page_curp		*/
	PIXEL_NULL,		/* page_endp		*/
	-1,			/* page_no		*/
	0,			/* page_dirty		*/
	0L,			/* page_curpos		*/
	0L,			/* page_pixels		*/
	0			/* debug		*/
};

/* Per connection private info */
struct	meminfo {
	FBIO	*fbp;		/* attached frame buffer (if any) */
	unsigned char *mem;	/* memory frame buffer */
	ColorMap cmap;		/* color map buffer */
	int	mem_dirty;	/* !0 implies unflushed written data */
	int	cmap_dirty;	/* !0 implies unflushed written cmap */
	int	write_thru;	/* !0 implies pass-thru write mode */
};
#define	MI(ptr) ((struct meminfo *)((ptr)->u1.p))
#define	MIL(ptr) ((ptr)->u1.p)		/* left hand side version */

#define MODE_1MASK	(1<<1)
#define MODE_1BUFFERED	(0<<1)		/* output flushed only at close */
#define MODE_1IMMEDIATE	(1<<1)		/* pass-through writes */

#define MODE_2MASK	(1<<2)
#define MODE_2CLEAR	(0<<2)		/* assume fb opens clear */
#define MODE_2PREREAD	(1<<2)		/* pre-read data from fb */

static struct modeflags {
	char	c;
	long	mask;
	long	value;
	char	*help;
} modeflags[] = {
	{ 'w',	MODE_1MASK, MODE_1IMMEDIATE,
		"Write thru mode - pass writes directly to attached frame buffer" },
	{ 'r',  MODE_2MASK, MODE_2PREREAD,
		"Pre-Read attached frame buffer data - else assumes clear" },
	{ '\0', 0, 0, "" }
};

_LOCAL_ int
mem_open(FBIO *ifp, char *file, int width, int height)
{
	int	mode;
	char	*cp;
	FBIO	*fbp;

	FB_CK_FBIO(ifp);

	/*
	 *  First, attempt to determine operating mode for this open,
	 *  based upon the "unit number" or flags.
	 *  file = "/dev/mem###"
	 *  The default mode is zero.
	 */
	mode = 0;

	if( file != NULL )  {
		register char *cp;
		char	modebuf[80];
		char	*mp;
		int	alpha;
		struct	modeflags *mfp;

		if( strncmp(file, "/dev/mem", 8) ) {
			/* How did this happen?? */
			mode = 0;
		}
		else {
			/* Parse the options */
			alpha = 0;
			mp = &modebuf[0];
			cp = &file[8];
			while( *cp != '\0' && !isspace(*cp) ) {
				*mp++ = *cp;	/* copy it to buffer */
				if( isdigit(*cp) ) {
					cp++;
					continue;
				}
				alpha++;
				for( mfp = modeflags; mfp->c != '\0'; mfp++ ) {
					if( mfp->c == *cp ) {
						mode = (mode&~mfp->mask)|mfp->value;
						break;
					}
				}
				if( mfp->c == '\0' && *cp != '-' ) {
					fb_log( "if_mem: unknown option '%c' ignored\n", *cp );
				}
				cp++;
			}
			*mp = '\0';
			if( !alpha )
				mode = atoi( modebuf );
		}
	}

	/* build a local static info struct */
	if( (MIL(ifp) = (char *)calloc( 1, sizeof(struct meminfo) )) == NULL )  {
		fb_log("mem_open:  meminfo malloc failed\n");
		return(-1);
	}
	cp = &file[strlen("/dev/mem")];
	while( *cp != '\0' && *cp != ' ' && *cp != '\t' )
		cp++;	/* skip suffix */
	while( *cp != '\0' && (*cp == ' ' || *cp == '\t' || *cp == ';') )
		cp++;	/* skip blanks and separators */

	if( *cp ) {
		/* frame buffer device specified */
		if( (fbp = fb_open(cp, width, height)) == FBIO_NULL ) {
			free( MIL(ifp) );
			return( -1 );
		}
		MI(ifp)->fbp = fbp;
		ifp->if_width = fbp->if_width;
		ifp->if_height = fbp->if_height;
		ifp->if_selfd = fbp->if_selfd;
		if( (mode & MODE_1MASK) == MODE_1IMMEDIATE )
			MI(ifp)->write_thru = 1;
	} else {
		/* no frame buffer specified */
		if( width > 0 )
			ifp->if_width = width;
		if( height > 0 )
			ifp->if_height = height;
	}
	if( (MI(ifp)->mem = (unsigned char *)calloc( ifp->if_width*ifp->if_height, 3 )) == NULL ) {
		fb_log("mem_open:  memory buffer malloc failed\n");
		(void)free( MIL(ifp) );
		return(-1);
	}
	if( (MI(ifp)->fbp != FBIO_NULL)
	 && (mode & MODE_2MASK) == MODE_2PREREAD ) {
		/* Pre read all of the image data and cmap */
	 	int got;
		got = fb_readrect( MI(ifp)->fbp, 0, 0,
			ifp->if_width, ifp->if_height,
			(unsigned char *)MI(ifp)->mem );
	 	if( got != ifp->if_width * ifp->if_height )  {
	 		fb_log("if_mem:  WARNING: pre-read of %d only got %d, your image is truncated.\n",
	 			ifp->if_width * ifp->if_height, got );
	 	}
		if( fb_rmap( MI(ifp)->fbp, &(MI(ifp)->cmap) ) < 0 )
			fb_make_linear_cmap( &(MI(ifp)->cmap) );
	} else {
		/* Image data begins black, colormap linear */
		fb_make_linear_cmap( &(MI(ifp)->cmap) );
	}

	return(0);
}

_LOCAL_ int
mem_close(FBIO *ifp)
{
	/*
	 * Flush memory/cmap to attached frame buffer if any
	 */
	if( MI(ifp)->fbp != FBIO_NULL ) {
		if( MI(ifp)->cmap_dirty ) {
			fb_wmap( MI(ifp)->fbp, &(MI(ifp)->cmap) );
		}
		if( MI(ifp)->mem_dirty ) {
			fb_writerect( MI(ifp)->fbp, 0, 0,
				ifp->if_width, ifp->if_height, (unsigned char *)MI(ifp)->mem );
		}
		fb_close( MI(ifp)->fbp );
		MI(ifp)->fbp = FBIO_NULL;
	}
	(void)free( (char *)MI(ifp)->mem );
	(void)free( (char *)MIL(ifp) );

	return(0);
}

_LOCAL_ int
mem_clear(FBIO *ifp, unsigned char *pp)
{
	RGBpixel v;
	register int n;
	register unsigned char *cp;

	if( pp == RGBPIXEL_NULL ) {
		v[RED] = v[GRN] = v[BLU] = 0;
	} else {
		v[RED] = (pp)[RED];
		v[GRN] = (pp)[GRN];
		v[BLU] = (pp)[BLU];
	}

	cp = MI(ifp)->mem;
	if( v[RED] == v[GRN] && v[RED] == v[BLU] ) {
		int	bytes = ifp->if_width*ifp->if_height*3;
		if( v[RED] == 0 )
			bzero( (char *)cp, bytes );	/* all black */
		else
			memset( cp, v[RED], bytes );	/* all grey */
	} else {
		for( n = ifp->if_width*ifp->if_height; n; n-- ) {
			*cp++ = v[RED];
			*cp++ = v[GRN];
			*cp++ = v[BLU];
		}
	}
	if( MI(ifp)->write_thru ) {
		return fb_clear( MI(ifp)->fbp, pp );
	} else {
		MI(ifp)->mem_dirty = 1;
	}
	return(0);
}

_LOCAL_ int
mem_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count)
{
	int	pixels_to_end;

	if( x < 0 || x >= ifp->if_width || y < 0 || y >= ifp->if_height )
		return( -1 );

	/* make sure we don't run off the end of the buffer */
	pixels_to_end = ifp->if_width*ifp->if_height - (y*ifp->if_width + x);
	if( pixels_to_end < count )
		count = pixels_to_end;

	bcopy( &(MI(ifp)->mem[(y*ifp->if_width + x)*3]), (char *)pixelp,
		count*3 );

	return(count);
}

_LOCAL_ int
mem_write(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count)
{
	int	pixels_to_end;

	if( x < 0 || x >= ifp->if_width || y < 0 || y >= ifp->if_height )
		return( -1 );

	/* make sure we don't run off the end of the buffer */
	pixels_to_end = ifp->if_width*ifp->if_height - (y*ifp->if_width + x);
	if( pixels_to_end < count )
		count = pixels_to_end;

	bcopy( (char *)pixelp, &(MI(ifp)->mem[(y*ifp->if_width + x)*3]),
		count*3 );

	if( MI(ifp)->write_thru ) {
		return fb_write( MI(ifp)->fbp, x, y, pixelp, count );
	} else {
		MI(ifp)->mem_dirty = 1;
	}
	return(count);
}

_LOCAL_ int
mem_rmap(FBIO *ifp, ColorMap *cmp)
{
	*cmp = MI(ifp)->cmap;		/* struct copy */
	return(0);
}

_LOCAL_ int
mem_wmap(FBIO *ifp, const ColorMap *cmp)
{
	if( cmp == COLORMAP_NULL )  {
		fb_make_linear_cmap( &(MI(ifp)->cmap) );
	} else {
		MI(ifp)->cmap = *cmp;		/* struct copy */
	}

	if( MI(ifp)->write_thru ) {
		return fb_wmap( MI(ifp)->fbp, cmp );
	} else {
		MI(ifp)->cmap_dirty = 1;
	}
	return(0);
}

_LOCAL_ int
mem_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
{
	fb_sim_view( ifp, xcenter, ycenter, xzoom, yzoom );
	if( MI(ifp)->write_thru ) {
		return fb_view( MI(ifp)->fbp, xcenter, ycenter,
			xzoom, yzoom );
	}
	return(0);
}

_LOCAL_ int
mem_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom)
{
	if( MI(ifp)->write_thru ) {
		return fb_getview( MI(ifp)->fbp, xcenter, ycenter,
			xzoom, yzoom );
	}
	fb_sim_getview( ifp, xcenter, ycenter, xzoom, yzoom );
	return(0);
}

_LOCAL_ int
mem_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig)
{
	if( MI(ifp)->write_thru ) {
		return fb_setcursor( MI(ifp)->fbp,
			bits, xbits, ybits, xorig, yorig );
	}
	return(0);
}

_LOCAL_ int
mem_cursor(FBIO *ifp, int mode, int x, int y)
{
	fb_sim_cursor( ifp, mode, x, y );
	if( MI(ifp)->write_thru ) {
		return fb_cursor( MI(ifp)->fbp, mode, x, y );
	}
	return(0);
}

_LOCAL_ int
mem_getcursor(FBIO *ifp, int *mode, int *x, int *y)
{
	if( MI(ifp)->write_thru ) {
		return fb_getcursor( MI(ifp)->fbp, mode, x, y );
	}
	fb_sim_getcursor( ifp, mode, x, y );
	return(0);
}

_LOCAL_ int
mem_poll(FBIO *ifp)
{
	if( MI(ifp)->write_thru ) {
		return fb_poll( MI(ifp)->fbp );
	}
	return(0);
}

_LOCAL_ int
mem_flush(FBIO *ifp)
{
	/*
	 * Flush memory/cmap to attached frame buffer if any
	 */
	if( MI(ifp)->fbp != FBIO_NULL ) {
		if( MI(ifp)->cmap_dirty ) {
			fb_wmap( MI(ifp)->fbp, &(MI(ifp)->cmap) );
			MI(ifp)->cmap_dirty = 0;
		}
		if( MI(ifp)->mem_dirty ) {
			fb_writerect( MI(ifp)->fbp, 0, 0,
				ifp->if_width, ifp->if_height, (unsigned char *)MI(ifp)->mem );
			MI(ifp)->mem_dirty = 0;
		}
		return	fb_flush( MI(ifp)->fbp );
	}

	MI(ifp)->cmap_dirty = 0;
	MI(ifp)->mem_dirty = 0;
	return	0;	/* success */
}

_LOCAL_ int
mem_help(FBIO *ifp)
{
	struct	modeflags *mfp;

	fb_log( "Description: %s\n", memory_interface.if_type );
	fb_log( "Device: %s\n", ifp->if_name );
	fb_log( "Max width/height: %d %d\n",
		memory_interface.if_max_width,
		memory_interface.if_max_height );
	fb_log( "Default width/height: %d %d\n",
		memory_interface.if_width,
		memory_interface.if_height );
	fb_log( "Usage: /dev/mem[options] [attached_framebuffer]\n" );
	for( mfp = modeflags; mfp->c != '\0'; mfp++ ) {
		fb_log( "   %c   %s\n", mfp->c, mfp->help );
	}
	return(0);
}
@


11.10
log
@change conf.h to a wrapped config.h
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/libfb/if_mem.c,v 11.9 2004/04/05 07:44:42 morrison Exp $ (BRL)";
@


11.9
log
@merge of ansi-6-0-branch into HEAD
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d22 5
a26 1
#include "conf.h"
@


11.8
log
@update copyright to include span through 2003
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_mem.c,v 11.7 2002/08/20 17:07:47 jra Exp $ (BRL)";
d36 15
a50 15
_LOCAL_ int	mem_open(),
		mem_close(),
		mem_clear(),
		mem_read(),
		mem_write(),
		mem_rmap(),
		mem_wmap(),
		mem_view(),
		mem_getview(),
		mem_setcursor(),
		mem_cursor(),
		mem_getcursor(),
		mem_poll(),
		mem_flush(),
		mem_help();
d130 1
a130 4
mem_open( ifp, file, width, height )
FBIO	*ifp;
char	*file;
int	width, height;
d243 1
a243 2
mem_close( ifp )
FBIO	*ifp;
d266 1
a266 3
mem_clear( ifp, pp )
FBIO	*ifp;
unsigned char	*pp;
d303 1
a303 5
mem_read( ifp, x, y, pixelp, count )
FBIO	*ifp;
int	x, y;
unsigned char	*pixelp;
int	count;
d322 1
a322 5
mem_write( ifp, x, y, pixelp, count )
FBIO	*ifp;
int	x, y;
const unsigned char	*pixelp;
int	count;
d346 1
a346 3
mem_rmap( ifp, cmp )
FBIO	*ifp;
ColorMap	*cmp;
d353 1
a353 3
mem_wmap( ifp, cmp )
FBIO	*ifp;
const ColorMap	*cmp;
d370 1
a370 4
mem_view( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	xcenter, ycenter;
int	xzoom, yzoom;
d381 1
a381 4
mem_getview( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	*xcenter, *ycenter;
int	*xzoom, *yzoom;
d392 1
a392 5
mem_setcursor( ifp, bits, xbits, ybits, xorig, yorig )
FBIO	*ifp;
const unsigned char *bits;
int	xbits, ybits;
int	xorig, yorig;
d402 1
a402 4
mem_cursor( ifp, mode, x, y )
FBIO	*ifp;
int	mode;
int	x, y;
d412 1
a412 4
mem_getcursor( ifp, mode, x, y )
FBIO	*ifp;
int	*mode;
int	*x, *y;
d422 1
a422 2
mem_poll( ifp )
FBIO	*ifp;
d431 1
a431 2
mem_flush( ifp )
FBIO	*ifp;
d455 1
a455 2
mem_help( ifp )
FBIO	*ifp;
@


11.7
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1989 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_mem.c,v 11.5 2001/04/20 22:29:14 morrison Exp $ (BRL)";
@


11.7.4.1
log
@sync to HEAD...
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libfb/if_mem.c,v 11.8 2004/02/02 17:39:12 morrison Exp $ (BRL)";
@


11.7.10.1
log
@merge from HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_mem.c,v 11.8 2004/02/02 17:39:12 morrison Exp $ (BRL)";
@


11.7.10.2
log
@merge from head
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_mem.c,v 11.7.10.1 2004/02/12 19:48:12 erikg Exp $ (BRL)";
@


11.7.2.1
log
@Initial ANSIfication
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_mem.c,v 11.7 2002/08/20 17:07:47 jra Exp $ (BRL)";
d36 15
a50 15
_LOCAL_ int	mem_open(FBIO *ifp, char *file, int width, int height),
		mem_close(FBIO *ifp),
		mem_clear(FBIO *ifp, unsigned char *pp),
		mem_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count),
		mem_write(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count),
		mem_rmap(FBIO *ifp, ColorMap *cmp),
		mem_wmap(FBIO *ifp, const ColorMap *cmp),
		mem_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
		mem_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom),
		mem_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig),
		mem_cursor(FBIO *ifp, int mode, int x, int y),
		mem_getcursor(FBIO *ifp, int *mode, int *x, int *y),
		mem_poll(FBIO *ifp),
		mem_flush(FBIO *ifp),
		mem_help(FBIO *ifp);
d130 4
a133 1
mem_open(FBIO *ifp, char *file, int width, int height)
d246 2
a247 1
mem_close(FBIO *ifp)
d270 3
a272 1
mem_clear(FBIO *ifp, unsigned char *pp)
d309 5
a313 1
mem_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count)
d332 5
a336 1
mem_write(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count)
d360 3
a362 1
mem_rmap(FBIO *ifp, ColorMap *cmp)
d369 3
a371 1
mem_wmap(FBIO *ifp, const ColorMap *cmp)
d388 4
a391 1
mem_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
d402 4
a405 1
mem_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom)
d416 5
a420 1
mem_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig)
d430 4
a433 1
mem_cursor(FBIO *ifp, int mode, int x, int y)
d443 4
a446 1
mem_getcursor(FBIO *ifp, int *mode, int *x, int *y)
d456 2
a457 1
mem_poll(FBIO *ifp)
d466 2
a467 1
mem_flush(FBIO *ifp)
d491 2
a492 1
mem_help(FBIO *ifp)
@


11.7.2.2
log
@sync branch with HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.6
log
@Converted from K&R to ANSI C - RFH
@
text
@d36 15
a50 15
_LOCAL_ int	mem_open(FBIO *ifp, char *file, int width, int height),
		mem_close(FBIO *ifp),
		mem_clear(FBIO *ifp, unsigned char *pp),
		mem_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count),
		mem_write(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count),
		mem_rmap(FBIO *ifp, ColorMap *cmp),
		mem_wmap(FBIO *ifp, const ColorMap *cmp),
		mem_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
		mem_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom),
		mem_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig),
		mem_cursor(FBIO *ifp, int mode, int x, int y),
		mem_getcursor(FBIO *ifp, int *mode, int *x, int *y),
		mem_poll(FBIO *ifp),
		mem_flush(FBIO *ifp),
		mem_help(FBIO *ifp);
d130 4
a133 1
mem_open(FBIO *ifp, char *file, int width, int height)
d246 2
a247 1
mem_close(FBIO *ifp)
d270 3
a272 1
mem_clear(FBIO *ifp, unsigned char *pp)
d309 5
a313 1
mem_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count)
d332 5
a336 1
mem_write(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count)
d360 3
a362 1
mem_rmap(FBIO *ifp, ColorMap *cmp)
d369 3
a371 1
mem_wmap(FBIO *ifp, const ColorMap *cmp)
d388 4
a391 1
mem_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
d402 4
a405 1
mem_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom)
d416 5
a420 1
mem_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig)
d430 4
a433 1
mem_cursor(FBIO *ifp, int mode, int x, int y)
d443 4
a446 1
mem_getcursor(FBIO *ifp, int *mode, int *x, int *y)
d456 2
a457 1
mem_poll(FBIO *ifp)
d466 2
a467 1
mem_flush(FBIO *ifp)
d491 2
a492 1
mem_help(FBIO *ifp)
@


11.5
log
@CONST to const
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_mem.c,v 11.4 2000/07/12 01:33:31 cjohnson Exp $ (BRL)";
d36 15
a50 15
_LOCAL_ int	mem_open(),
		mem_close(),
		mem_clear(),
		mem_read(),
		mem_write(),
		mem_rmap(),
		mem_wmap(),
		mem_view(),
		mem_getview(),
		mem_setcursor(),
		mem_cursor(),
		mem_getcursor(),
		mem_poll(),
		mem_flush(),
		mem_help();
d130 1
a130 4
mem_open( ifp, file, width, height )
FBIO	*ifp;
char	*file;
int	width, height;
d243 1
a243 2
mem_close( ifp )
FBIO	*ifp;
d266 1
a266 3
mem_clear( ifp, pp )
FBIO	*ifp;
unsigned char	*pp;
d303 1
a303 5
mem_read( ifp, x, y, pixelp, count )
FBIO	*ifp;
int	x, y;
unsigned char	*pixelp;
int	count;
d322 1
a322 5
mem_write( ifp, x, y, pixelp, count )
FBIO	*ifp;
int	x, y;
const unsigned char	*pixelp;
int	count;
d346 1
a346 3
mem_rmap( ifp, cmp )
FBIO	*ifp;
ColorMap	*cmp;
d353 1
a353 3
mem_wmap( ifp, cmp )
FBIO	*ifp;
const ColorMap	*cmp;
d370 1
a370 4
mem_view( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	xcenter, ycenter;
int	xzoom, yzoom;
d381 1
a381 4
mem_getview( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	*xcenter, *ycenter;
int	*xzoom, *yzoom;
d392 1
a392 5
mem_setcursor( ifp, bits, xbits, ybits, xorig, yorig )
FBIO	*ifp;
const unsigned char *bits;
int	xbits, ybits;
int	xorig, yorig;
d402 1
a402 4
mem_cursor( ifp, mode, x, y )
FBIO	*ifp;
int	mode;
int	x, y;
d412 1
a412 4
mem_getcursor( ifp, mode, x, y )
FBIO	*ifp;
int	*mode;
int	*x, *y;
d422 1
a422 2
mem_poll( ifp )
FBIO	*ifp;
d431 1
a431 2
mem_flush( ifp )
FBIO	*ifp;
d455 1
a455 2
mem_help( ifp )
FBIO	*ifp;
@


11.4
log
@LINT from gcc -Wall.  Including some mods to h/pkg.h
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_mem.c,v 11.3 1998/08/25 00:19:54 mike Exp $ (BRL)";
d335 1
a335 1
CONST unsigned char	*pixelp;
d371 1
a371 1
CONST ColorMap	*cmp;
d418 1
a418 1
CONST unsigned char *bits;
@


11.3
log
@Added error checking on /dev/mem pre-read (/dev/memr)
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_mem.c,v 11.2 1998/06/27 04:29:16 mike Exp $ (BRL)";
d26 5
a30 1

@


11.2
log
@Additions to LIBFB interface and remote framebuffer protocol to
read and write monochrome rectangles.
Particularly important for sending thermal images at high speed.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_mem.c,v 11.1 1995/01/04 09:52:54 mike Rel4_4 $ (BRL)";
d223 10
a232 3
		fb_readrect( MI(ifp)->fbp, 0, 0,
			ifp->if_width, ifp->if_height, (unsigned char *)MI(ifp)->mem );
	 	fb_rmap( MI(ifp)->fbp, &(MI(ifp)->cmap) );
@


11.1
log
@Release_4.4
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_mem.c,v 10.5 94/12/30 00:22:11 mike Exp $ (BRL)";
d65 2
@


10.5
log
@DEC Alpha
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_mem.c,v 10.4 94/11/04 04:58:41 mike Exp Locker: mike $ (BRL)";
@


10.4
log
@Irix 6
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_mem.c,v 10.3 94/08/12 20:25:17 gdurf Exp Locker: mike $ (BRL)";
d277 1
a277 1
			bzero( cp, bytes );		/* all black */
@


10.3
log
@Added includes
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_mem.c,v 10.2 1993/09/25 08:48:34 mike Exp gdurf $ (BRL)";
a128 1
	int	i;
@


10.2
log
@Converted to new fb.h
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_mem.c,v 10.1 91/10/12 06:37:25 mike Rel4_0 Locker: mike $ (BRL)";
d22 2
d26 3
@


10.1
log
@Release_4.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_mem.c,v 1.7 91/07/26 22:41:05 mike Exp $ (BRL)";
d218 1
a218 1
			ifp->if_width, ifp->if_height, MI(ifp)->mem );
d241 1
a241 1
				ifp->if_width, ifp->if_height, MI(ifp)->mem );
d255 1
a255 1
RGBpixel	*pp;
d264 3
a266 3
		v[RED] = (*pp)[RED];
		v[GRN] = (*pp)[GRN];
		v[BLU] = (*pp)[BLU];
d295 1
a295 1
RGBpixel	*pixelp;
d318 1
a318 1
RGBpixel	*pixelp;
d354 1
a354 1
ColorMap	*cmp;
d401 1
a401 1
unsigned char *bits;
d462 1
a462 1
				ifp->if_width, ifp->if_height, MI(ifp)->mem );
@


1.7
log
@Added if_magic field, and FB_CK_FBIO() macro, to allow checking
FBIO pointers
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_mem.c,v 1.6 91/07/18 16:33:24 mike Exp $ (BRL)";
@


1.6
log
@lint
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_mem.c,v 1.5 90/12/11 22:25:45 phil Exp $ (BRL)";
d45 1
d128 2
@


1.5
log
@if_ struct changes.  See fb.h.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_mem.c,v 1.4 90/11/08 13:44:02 phil Exp $ (BRL)";
d182 1
a182 1
	while( *cp != NULL && *cp != ' ' && *cp != '\t' )
d184 1
a184 1
	while( *cp != NULL && (*cp == ' ' || *cp == '\t' || *cp == ';') )
@


1.4
log
@Now fb_make_linear_cmap().  Avoid unnecessary flushes when in
write-thru mode.  Preserve NULL cmap writes in write-thru mode.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_mem.c,v 1.3 90/11/03 15:41:09 mike Exp $ (BRL)";
a28 1
		mem_reset(),
d34 2
a35 3
		mem_viewport(),
		mem_window(),
		mem_zoom(),
d38 2
a39 1
		mem_scursor(),
a46 1
	mem_reset,		/* device_reset		*/
d52 2
a53 3
	mem_viewport,		/* viewport_set		*/
	mem_window,		/* window_set		*/
	mem_zoom,		/* zoom_set		*/
d55 2
a56 2
	mem_cursor,		/* cursor - memory addr */
	mem_scursor,		/* cursor - screen addr */
d59 1
d69 1
d71 3
d196 1
a249 10
mem_reset( ifp )
FBIO	*ifp;
{
	if( MI(ifp)->write_thru ) {
		return( fb_reset(MI(ifp)->fbp) );
	}
	return(0);
}

_LOCAL_ int
d368 1
a368 1
mem_viewport( ifp, left, top, right, bottom )
d370 2
a371 1
int	left, top, right, bottom;
d373 1
d375 2
a376 1
		return fb_viewport( MI(ifp)->fbp, left, top, right, bottom );
d382 1
a382 1
mem_window( ifp, x, y )
d384 2
a385 1
int	x, y;
d388 2
a389 1
		return fb_window( MI(ifp)->fbp, x, y );
d391 1
a395 11
mem_zoom( ifp, x, y )
FBIO	*ifp;
int	x, y;
{
	if( MI(ifp)->write_thru ) {
		return fb_zoom( MI(ifp)->fbp, x, y );
	}
	return(0);
}

_LOCAL_ int
d415 1
d423 1
a423 1
mem_scursor( ifp, mode, x, y )
d425 2
a426 2
int	mode;
int	x, y;
d429 12
a440 1
		return fb_scursor( MI(ifp)->fbp, mode, x, y );
@


1.3
log
@Changed to use fb_make_linear_colormap
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_mem.c,v 1.2 89/10/21 01:24:23 mike Exp $ (BRL)";
d214 3
d289 2
a291 1
	MI(ifp)->mem_dirty = 1;
d340 2
a342 1
	MI(ifp)->mem_dirty = 1;
d361 1
a361 1
		fb_make_linear_colormap( &(MI(ifp)->cmap) );
d365 1
d367 3
a369 2
		return fb_wmap( MI(ifp)->fbp, &(MI(ifp)->cmap) );
		/* Map isn't dirty if already written through */
a370 1
	MI(ifp)->cmap_dirty = 1;
@


1.2
log
@Handle writing a NULL colormap, which implies a linear ramp.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_mem.c,v 1.1 89/09/01 01:43:21 mike Locked $ (BRL)";
d356 1
a356 8
		/* Standard Colormap */
		register int	i;

		for( i=0; i<256; i++ )  {
			MI(ifp)->cmap.cm_red[i] = i<<8;
			MI(ifp)->cmap.cm_green[i] = i<<8;
			MI(ifp)->cmap.cm_blue[i] = i<<8;
		}
d361 1
a361 1
		return fb_wmap( MI(ifp)->fbp, cmp );
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_mem.c,v 9.4 89/08/14 00:10:57 phil Locked $ (BRL)";
d355 12
a366 1
	MI(ifp)->cmap = *cmp;		/* struct copy */
d369 1
@
