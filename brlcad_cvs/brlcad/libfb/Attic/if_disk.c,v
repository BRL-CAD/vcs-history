head	11.16;
access;
symbols
	ansi-20040405-merged:11.11.2.2
	postmerge-20040405-ansi:11.14
	premerge-20040404-ansi:11.13
	postmerge-autoconf:11.13
	autoconf-freeze:11.11.10.3
	premerge-autoconf:11.13
	ansi-20040316-freeze:11.11.2.1
	postmerge-20040315-windows:11.13
	premerge-20040315-windows:11.12
	windows-20040315-freeze:11.11.4.2
	autoconf-20031203:11.11
	autoconf-20031202:11.11
	autoconf-branch:11.11.0.10
	phong-branch:11.11.0.8
	photonmap-branch:11.11.0.6
	rel-6-1-DP:11.11
	windows-branch:11.11.0.4
	rel-6-0-2:11.9
	ansi-branch:11.11.0.2
	rel-6-0-1-branch:11.9.0.2
	hartley-6-0-post:11.10
	hartley-6-0-pre:11.9
	rel-6-0-1:11.9
	rel-6-0:11.9
	rel-5-4:11.5
	offsite-5-3-pre:11.8
	rel-5-3:11.5
	rel-5-2:11.5
	rel-5-1-branch:11.5.0.2
	rel-5-1:11.5
	rel-5-0:11.5
	rel-5-0-beta:11.5
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.16
date	2004.05.21.18.07.25;	author morrison;	state dead;
branches;
next	11.15;

11.15
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	11.14;

11.14
date	2004.04.05.07.44.42;	author morrison;	state Exp;
branches;
next	11.13;

11.13
date	2004.03.16.19.59.35;	author morrison;	state Exp;
branches;
next	11.12;

11.12
date	2004.02.02.17.39.12;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2002.08.20.17.07.46;	author jra;	state Exp;
branches
	11.11.2.1
	11.11.4.1
	11.11.10.1;
next	11.10;

11.10
date	2002.08.15.20.55.00;	author hartley;	state Exp;
branches;
next	11.9;

11.9
date	2001.04.20.22.29.14;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2000.10.18.18.10.33;	author butler;	state Exp;
branches;
next	11.7;

11.7
date	2000.07.25.16.44.22;	author butler;	state Exp;
branches;
next	11.6;

11.6
date	2000.07.12.01.33.31;	author cjohnson;	state Exp;
branches;
next	11.5;

11.5
date	98.08.28.21.14.07;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	98.08.25.00.34.34;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	98.08.25.00.29.08;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	98.06.27.04.29.16;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.52.53;	author mike;	state Rel4_4;
branches;
next	10.5;

10.5
date	94.08.12.20.25.03;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	94.08.09.12.58.03;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	93.09.25.08.52.25;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	93.09.24.19.20.30;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.37.24;	author mike;	state Rel4_0;
branches;
next	9.6;

9.6
date	91.07.26.22.41.03;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.12.11.22.16.33;	author phil;	state Exp;
branches;
next	9.4;

9.4
date	90.11.03.15.40.14;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.11.03.14.42.59;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.09.01.01.40.25;	author phil;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.47.55;	author mike;	state Rel3_5;
branches;
next	8.2;

8.2
date	89.03.03.05.54.30;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.27.32;	author mike;	state Rel3_0;
branches;
next	7.4;

7.4
date	88.09.09.23.26.01;	author phil;	state Exp;
branches;
next	7.3;

7.3
date	88.07.19.15.31.56;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.05.13.21.37.50;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.26.32;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.07.51.29;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.21.51.31;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.12.22.06.33;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.42.46;	author mike;	state Rel1;
branches;
next	1.14;

1.14
date	86.11.30.22.26.59;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	86.11.28.20.20.25;	author phil;	state Exp;
branches;
next	1.12;

1.12
date	86.11.13.21.30.39;	author phil;	state Exp;
branches;
next	1.11;

1.11
date	86.10.29.01.34.21;	author phil;	state Exp;
branches;
next	1.10;

1.10
date	86.10.28.17.54.10;	author phil;	state Exp;
branches;
next	1.9;

1.9
date	86.10.25.17.04.25;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	86.10.25.10.53.26;	author phil;	state Exp;
branches;
next	1.7;

1.7
date	86.10.25.01.25.39;	author phil;	state Exp;
branches;
next	1.6;

1.6
date	86.10.24.04.08.29;	author phil;	state Exp;
branches;
next	1.5;

1.5
date	86.10.14.23.12.27;	author phil;	state Exp;
branches;
next	1.4;

1.4
date	86.10.03.06.46.53;	author root;	state Exp;
branches;
next	1.3;

1.3
date	86.10.03.06.32.22;	author phil;	state Exp;
branches;
next	1.2;

1.2
date	86.10.03.03.12.25;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.10.02.02.17.51;	author mike;	state Exp;
branches;
next	;

11.11.2.1
date	2002.09.19.18.01.19;	author morrison;	state Exp;
branches;
next	11.11.2.2;

11.11.2.2
date	2004.03.17.21.17.00;	author morrison;	state Exp;
branches;
next	;

11.11.4.1
date	2002.09.26.23.03.54;	author morrison;	state Exp;
branches;
next	11.11.4.2;

11.11.4.2
date	2004.03.11.23.42.07;	author morrison;	state Exp;
branches;
next	;

11.11.10.1
date	2004.02.12.19.48.12;	author erikg;	state Exp;
branches;
next	11.11.10.2;

11.11.10.2
date	2004.03.15.14.06.19;	author erikg;	state Exp;
branches;
next	11.11.10.3;

11.11.10.3
date	2004.03.18.18.10.28;	author erikg;	state Exp;
branches;
next	;


desc
@FB disk I/O routines
@


11.16
log
@moved to src/
@
text
@/*
 *			I F _ D I S K . C
 *
 *  Author -
 *	Gary S. Moss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libfb/if_disk.c,v 11.15 2004/05/10 15:30:45 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif

#include <sys/types.h>
#ifndef WIN32
#include <unistd.h>
#endif
       
#ifdef HAVE_SYS_FILE_H
#include <sys/file.h>
#else
#include <fcntl.h>
#endif

#include "machine.h"
#include "externs.h"		/* For malloc */
#include "fb.h"
#include "./fblocal.h"

#define FILE_CMAP_ADDR	((long) ifp->if_width*ifp->if_height\
			*sizeof(RGBpixel))

/* Ensure integer number of pixels per DMA */
#define	DISK_DMA_BYTES	(16*1024/sizeof(RGBpixel)*sizeof(RGBpixel))
#define	DISK_DMA_PIXELS	(DISK_DMA_BYTES/sizeof(RGBpixel))

_LOCAL_ int	dsk_open(FBIO *ifp, char *file, int width, int height),
		dsk_close(FBIO *ifp),
		dsk_clear(FBIO *ifp, unsigned char *bgpp),
		dsk_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count),
		dsk_write(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count),
		dsk_rmap(FBIO *ifp, ColorMap *cmap),
		dsk_wmap(FBIO *ifp, const ColorMap *cmap),
		dsk_free(FBIO *ifp),
		dsk_help(FBIO *ifp);

FBIO disk_interface = {
	0,
	dsk_open,
	dsk_close,
	dsk_clear,
	dsk_read,
	dsk_write,
	dsk_rmap,
	dsk_wmap,
	fb_sim_view,		/* set view */
	fb_sim_getview,		/* get view */
	fb_null_setcursor,		/* define cursor */
	fb_sim_cursor,		/* set cursor */
	fb_sim_getcursor,	/* get cursor */
	fb_sim_readrect,
	fb_sim_writerect,
	fb_sim_bwreadrect,
	fb_sim_bwwriterect,
	fb_null,		/* poll */
	fb_null,		/* flush */
	dsk_free,
	dsk_help,
	"Disk File Interface",
	16*1024,		/* the sky's really the limit here */
	16*1024,
	"filename",		/* not in list so name is safe */
	512,
	512,
	-1,			/* select fd */
	-1,
	1, 1,			/* zoom */
	256, 256,		/* window center */
	0, 0, 0,		/* cursor */
	PIXEL_NULL,
	PIXEL_NULL,
	PIXEL_NULL,
	-1,
	0,
	0L,
	0L,
	0
};

#define if_seekpos	u5.l	/* stored seek position */

_LOCAL_ int	disk_color_clear(FBIO *ifp, register unsigned char *bpp);

_LOCAL_ int
dsk_open(FBIO *ifp, char *file, int width, int height)
{
	static char zero = 0;

	FB_CK_FBIO(ifp);

	/* check for default size */
	if( width == 0 )
		width = ifp->if_width;
	if( height == 0 )
		height = ifp->if_height;

	if( strcmp( file, "-" ) == 0 )  {
		/*
		 *  It is the applications job to write ascending scanlines.
		 *  If it does not, then this can be stacked with /dev/mem,
		 *  i.e.	/dev/mem -
		 */
		ifp->if_fd = 1;		/* fileno(stdout) */
		ifp->if_width = width;
		ifp->if_height = height;
		ifp->if_seekpos = 0L;
		return 0;
	}

	if( (ifp->if_fd = open( file, O_RDWR, 0 )) == -1
	  && (ifp->if_fd = open( file, O_RDONLY, 0 )) == -1 ) {
		if( (ifp->if_fd = open( file, O_RDWR|O_CREAT, 0664 )) > 0 ) {
			/* New file, write byte at end */
			if( lseek( ifp->if_fd, (off_t)(height*width*sizeof(RGBpixel)-1), 0 ) == -1 ) {
				fb_log( "disk_device_open : can not seek to end of new file.\n" );
				return	-1;
			}
			if( write( ifp->if_fd, &zero, 1 ) < 0 ) {
				fb_log( "disk_device_open : initial write failed.\n" );
				return	-1;
			}
		} else
			return	-1;
	}
	ifp->if_width = width;
	ifp->if_height = height;
	if( lseek( ifp->if_fd, (off_t)0L, 0 ) == -1L ) {
		fb_log( "disk_device_open : can not seek to beginning.\n" );
		return	-1;
	}
	ifp->if_seekpos = 0L;
	return	0;
}

_LOCAL_ int
dsk_close(FBIO *ifp)
{
	return	close( ifp->if_fd );
}

_LOCAL_ int
dsk_free(FBIO *ifp)
{
	close( ifp->if_fd );
	return	unlink( ifp->if_name );
}

_LOCAL_ int
dsk_clear(FBIO *ifp, unsigned char *bgpp)
{
	static RGBpixel	black = { 0, 0, 0 };

	if( bgpp == (unsigned char *)NULL )
		return disk_color_clear( ifp, black );

	return	disk_color_clear( ifp, bgpp );
}

_LOCAL_ int
dsk_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count)
{
	register long bytes = count * (long) sizeof(RGBpixel);
	register long todo;
	long		got;
	long		dest;
	long		bytes_read = 0;
	int		fd = ifp->if_fd;

	/* Reads on stdout make no sense.  Take reads from stdin. */
	if( fd == 1 )  fd = 0;

	dest = (((long) y * (long) ifp->if_width) + (long) x)
	     * (long) sizeof(RGBpixel);
	if( ifp->if_seekpos != dest && lseek(fd, (off_t)dest, 0) == -1L ) {
		fb_log( "disk_buffer_read : seek to %ld failed.\n", dest );
		return	-1;
	}
	ifp->if_seekpos = dest;
	while( bytes > 0 ) {
		todo = bytes;
		if( (got = read( fd, (char *) pixelp, todo )) != todo )  {
			if( got == 0 )  {
				if( bytes_read <= 0 )
					return -1;	/* error */
				/* early EOF -- indicate what we got */
				return bytes_read/sizeof(RGBpixel);
			}
			if( fd != 0 )  {
				/* This happens all the time reading from pipes */
				fb_log("disk_buffer_read(fd=%d): y=%d read of %d got %d bytes\n",
					fd, y, todo, got);
			}
		}
		bytes -= got;
		pixelp += got;
		ifp->if_seekpos += got;
		bytes_read += got;
	}
	return	bytes_read/sizeof(RGBpixel);
}

_LOCAL_ int
dsk_write(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count)
{
	register long	bytes = count * (long) sizeof(RGBpixel);
	register long	todo;
	long		dest;

	dest = ((long) y * (long) ifp->if_width + (long) x)
	     * (long) sizeof(RGBpixel);
	if( dest != ifp->if_seekpos )  {
		if( lseek(ifp->if_fd, (off_t)dest, 0) == -1L ) {
			fb_log( "disk_buffer_write : seek to %ld failed.\n", dest );
			return	-1;
		}
		ifp->if_seekpos = dest;
	}
	while( bytes > 0 ) {
		todo = bytes;
		if( write( ifp->if_fd, (char *) pixelp, todo ) != todo )  {
			fb_log( "disk_buffer_write: write failed\n" );
			return	-1;
		}
		bytes -= todo;
		pixelp += todo / sizeof(RGBpixel);
		ifp->if_seekpos += todo;
	}
	return	count;
}

_LOCAL_ int
dsk_rmap(FBIO *ifp, ColorMap *cmap)
{
	int		fd = ifp->if_fd;

	/* Reads on stdout make no sense.  Take reads from stdin. */
	if( fd == 1 )  fd = 0;

	if( ifp->if_seekpos != FILE_CMAP_ADDR &&
	    lseek( fd, (off_t)FILE_CMAP_ADDR, 0 ) == -1 ) {
		fb_log(	"disk_colormap_read : seek to %ld failed.\n",
				FILE_CMAP_ADDR );
	   	return	-1;
	}
	if( read( fd, (char *) cmap, sizeof(ColorMap) )
		!= sizeof(ColorMap) ) {
		/* Not necessarily an error.  It is not required
		 * that a color map be saved and the standard 
		 * map is not generally saved.
		 */
		return	-1;
	}
	return	0;
}

_LOCAL_ int
dsk_wmap(FBIO *ifp, const ColorMap *cmap)
{
	if( cmap == (ColorMap *) NULL )
		/* Do not write default map to file. */
		return	0;
	if( fb_is_linear_cmap( cmap ) )
		return  0;
	if( lseek( ifp->if_fd, (off_t)FILE_CMAP_ADDR, 0 ) == -1 ) {
		fb_log(	"disk_colormap_write : seek to %ld failed.\n",
				FILE_CMAP_ADDR );
		return	-1;
	}
	if( write( ifp->if_fd, (char *) cmap, sizeof(ColorMap) )
	    != sizeof(ColorMap) ) {
	    	fb_log( "disk_colormap_write : write failed.\n" );
		return	-1;
	}
	return	0;
}

/*
 *		D I S K _ C O L O R _ C L E A R
 *
 *  Clear the disk file to the given color.
 */
_LOCAL_ int
disk_color_clear(FBIO *ifp, register unsigned char *bpp)
{
	static unsigned char	*pix_buf = NULL;
	register unsigned char *pix_to;
	register long	i;
	int	fd, pixelstodo;

	if( pix_buf == NULL )
		if( (pix_buf = (unsigned char *) malloc(DISK_DMA_BYTES)) == PIXEL_NULL ) {
			Malloc_Bomb(DISK_DMA_BYTES);
			return	-1;
		}

	/* Fill buffer with background color. */
	for( i = DISK_DMA_PIXELS, pix_to = pix_buf; i > 0; i-- ) {
		COPYRGB( pix_to, bpp );
		pix_to += sizeof(RGBpixel);
	}

	/* Set start of framebuffer */
	fd = ifp->if_fd;
	if( ifp->if_seekpos != 0L && lseek( fd, (off_t)0L, 0 ) == -1 ) {
		fb_log( "disk_color_clear : seek failed.\n" );
		return	-1;
	}

	/* Send until frame buffer is full. */
	pixelstodo = ifp->if_height * ifp->if_width;
	while( pixelstodo > 0 ) {
		i = pixelstodo > DISK_DMA_PIXELS ? DISK_DMA_PIXELS : pixelstodo;
		if( write( fd, pix_buf, i * sizeof(RGBpixel) ) == -1 )
			return	-1;
		pixelstodo -= i;
		ifp->if_seekpos += i * sizeof(RGBpixel);
	}

	return	0;
}

_LOCAL_ int
dsk_help(FBIO *ifp)
{
	fb_log( "Description: %s\n", disk_interface.if_type );
	fb_log( "Device: %s\n", ifp->if_name );
	fb_log( "Max width/height: %d %d\n",
		disk_interface.if_max_width,
		disk_interface.if_max_height );
	fb_log( "Default width/height: %d %d\n",
		disk_interface.if_width,
		disk_interface.if_height );
	if( ifp->if_fd == 1 )  {
		fb_log("File \"-\" reads from stdin, writes to stdout\n");
	} else {
		fb_log( "Note: you may have just created a disk file\n" );
		fb_log( "called \"%s\" by running this.\n", ifp->if_name );
	}

	return(0);
}
@


11.15
log
@change conf.h to a wrapped config.h
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/libfb/if_disk.c,v 11.14 2004/04/05 07:44:42 morrison Exp $ (BRL)";
@


11.14
log
@merge of ansi-6-0-branch into HEAD
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d20 5
a24 1
#include "conf.h"
@


11.13
log
@merge of windows-6-0-branch into head
@
text
@d50 9
a58 9
_LOCAL_ int	dsk_open(),
		dsk_close(),
		dsk_clear(),
		dsk_read(),
		dsk_write(),
		dsk_rmap(),
		dsk_wmap(),
		dsk_free(),
		dsk_help();
d105 1
a105 1
_LOCAL_ int	disk_color_clear();
d108 1
a108 4
dsk_open( ifp, file, width, height )
FBIO	*ifp;
char	*file;
int	width, height;
d159 1
a159 2
dsk_close( ifp )
FBIO	*ifp;
d165 1
a165 2
dsk_free( ifp )
FBIO	*ifp;
d172 1
a172 3
dsk_clear( ifp, bgpp )
FBIO	*ifp;
unsigned char	*bgpp;
d183 1
a183 5
dsk_read( ifp, x, y, pixelp, count )
FBIO	*ifp;
int	x,  y;
unsigned char	*pixelp;
int	count;
d226 1
a226 5
dsk_write( ifp, x, y, pixelp, count )
FBIO	*ifp;
int	x, y;
const unsigned char	*pixelp;
long	count;
d255 1
a255 3
dsk_rmap( ifp, cmap )
FBIO	*ifp;
ColorMap	*cmap;
d280 1
a280 3
dsk_wmap( ifp, cmap )
FBIO	*ifp;
const ColorMap	*cmap;
d306 1
a306 3
disk_color_clear( ifp, bpp )
FBIO	*ifp;
register unsigned char	*bpp;
d346 1
a346 2
dsk_help( ifp )
FBIO	*ifp;
@


11.12
log
@update copyright to include span through 2003
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_disk.c,v 11.11 2002/08/20 17:07:46 jra Exp $ (BRL)";
d28 1
d30 1
@


11.11
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d13 1
a13 1
 *	This software is Copyright (C) 1986 by the United States Army.
d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_disk.c,v 11.9 2001/04/20 22:29:14 morrison Exp $ (BRL)";
@


11.11.10.1
log
@merge from HEAD
@
text
@d13 1
a13 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_disk.c,v 11.12 2004/02/02 17:39:12 morrison Exp $ (BRL)";
@


11.11.10.2
log
@merge from head
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_disk.c,v 11.11.10.1 2004/02/12 19:48:12 erikg Exp $ (BRL)";
@


11.11.10.3
log
@merge from head
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a27 1
#ifndef WIN32
a28 1
#endif
@


11.11.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_disk.c,v 11.11 2002/08/20 17:07:46 jra Exp $ (BRL)";
a27 1
#ifndef WIN32
a28 1
#endif
@


11.11.4.2
log
@sync to HEAD...
@
text
@d13 1
a13 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libfb/if_disk.c,v 11.11.4.1 2002/09/26 23:03:54 morrison Exp $ (BRL)";
@


11.11.2.1
log
@Initial ANSIfication
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_disk.c,v 11.11 2002/08/20 17:07:46 jra Exp $ (BRL)";
d48 9
a56 9
_LOCAL_ int	dsk_open(FBIO *ifp, char *file, int width, int height),
		dsk_close(FBIO *ifp),
		dsk_clear(FBIO *ifp, unsigned char *bgpp),
		dsk_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count),
		dsk_write(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count),
		dsk_rmap(FBIO *ifp, ColorMap *cmap),
		dsk_wmap(FBIO *ifp, const ColorMap *cmap),
		dsk_free(FBIO *ifp),
		dsk_help(FBIO *ifp);
d103 1
a103 1
_LOCAL_ int	disk_color_clear(FBIO *ifp, register unsigned char *bpp);
d106 4
a109 1
dsk_open(FBIO *ifp, char *file, int width, int height)
d160 2
a161 1
dsk_close(FBIO *ifp)
d167 2
a168 1
dsk_free(FBIO *ifp)
d175 3
a177 1
dsk_clear(FBIO *ifp, unsigned char *bgpp)
d188 5
a192 1
dsk_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count)
d235 5
a239 1
dsk_write(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count)
d268 3
a270 1
dsk_rmap(FBIO *ifp, ColorMap *cmap)
d295 3
a297 1
dsk_wmap(FBIO *ifp, const ColorMap *cmap)
d323 3
a325 1
disk_color_clear(FBIO *ifp, register unsigned char *bpp)
d365 2
a366 1
dsk_help(FBIO *ifp)
@


11.11.2.2
log
@sync branch with HEAD
@
text
@d13 1
a13 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d17 1
a17 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a27 1
#ifndef WIN32
a28 1
#endif
@


11.10
log
@Converted from K&R to ANSI C - RFH
@
text
@d48 9
a56 9
_LOCAL_ int	dsk_open(FBIO *ifp, char *file, int width, int height),
		dsk_close(FBIO *ifp),
		dsk_clear(FBIO *ifp, unsigned char *bgpp),
		dsk_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count),
		dsk_write(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count),
		dsk_rmap(FBIO *ifp, ColorMap *cmap),
		dsk_wmap(FBIO *ifp, const ColorMap *cmap),
		dsk_free(FBIO *ifp),
		dsk_help(FBIO *ifp);
d103 1
a103 1
_LOCAL_ int	disk_color_clear(FBIO *ifp, register unsigned char *bpp);
d106 4
a109 1
dsk_open(FBIO *ifp, char *file, int width, int height)
d160 2
a161 1
dsk_close(FBIO *ifp)
d167 2
a168 1
dsk_free(FBIO *ifp)
d175 3
a177 1
dsk_clear(FBIO *ifp, unsigned char *bgpp)
d188 5
a192 1
dsk_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count)
d235 5
a239 1
dsk_write(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count)
d268 3
a270 1
dsk_rmap(FBIO *ifp, ColorMap *cmap)
d295 3
a297 1
dsk_wmap(FBIO *ifp, const ColorMap *cmap)
d323 3
a325 1
disk_color_clear(FBIO *ifp, register unsigned char *bpp)
d365 2
a366 1
dsk_help(FBIO *ifp)
@


11.9
log
@CONST to const
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_disk.c,v 11.8 2000/10/18 18:10:33 butler Exp $ (BRL)";
d48 9
a56 9
_LOCAL_ int	dsk_open(),
		dsk_close(),
		dsk_clear(),
		dsk_read(),
		dsk_write(),
		dsk_rmap(),
		dsk_wmap(),
		dsk_free(),
		dsk_help();
d103 1
a103 1
_LOCAL_ int	disk_color_clear();
d106 1
a106 4
dsk_open( ifp, file, width, height )
FBIO	*ifp;
char	*file;
int	width, height;
d157 1
a157 2
dsk_close( ifp )
FBIO	*ifp;
d163 1
a163 2
dsk_free( ifp )
FBIO	*ifp;
d170 1
a170 3
dsk_clear( ifp, bgpp )
FBIO	*ifp;
unsigned char	*bgpp;
d181 1
a181 5
dsk_read( ifp, x, y, pixelp, count )
FBIO	*ifp;
int	x,  y;
unsigned char	*pixelp;
int	count;
d224 1
a224 5
dsk_write( ifp, x, y, pixelp, count )
FBIO	*ifp;
int	x, y;
const unsigned char	*pixelp;
long	count;
d253 1
a253 3
dsk_rmap( ifp, cmap )
FBIO	*ifp;
ColorMap	*cmap;
d278 1
a278 3
dsk_wmap( ifp, cmap )
FBIO	*ifp;
const ColorMap	*cmap;
d304 1
a304 3
disk_color_clear( ifp, bpp )
FBIO	*ifp;
register unsigned char	*bpp;
d344 1
a344 2
dsk_help( ifp )
FBIO	*ifp;
@


11.8
log
@Patches for compiling under RedHat 7.0
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_disk.c,v 11.7 2000/07/25 16:44:22 butler Exp $ (BRL)";
d238 1
a238 1
CONST unsigned char	*pixelp;
d297 1
a297 1
CONST ColorMap	*cmap;
@


11.7
log
@Added includes necessary for external definitions.
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_disk.c,v 11.6 2000/07/12 01:33:31 cjohnson Exp $ (BRL)";
d23 4
@


11.6
log
@LINT from gcc -Wall.  Including some mods to h/pkg.h
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_disk.c,v 11.5 1998/08/28 21:14:07 mike Exp $ (BRL)";
d23 3
@


11.5
log
@Because the file descriptor may be a pipe, and for overall efficiency,
don't lseek() unless you're actually changing position in the file.
Also, if reading from stdin, short reads are unremarkable, and the
code dutifuly slurps the rest in anyway.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_disk.c,v 11.4 1998/08/25 00:34:34 mike Exp $ (BRL)";
@


11.4
log
@The read-from-stdout bug also applies to obtaining the color map.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_disk.c,v 11.3 1998/08/25 00:29:08 mike Exp $ (BRL)";
d199 1
a199 1
	if( lseek(fd, (off_t)dest, 0) == -1L ) {
d213 5
a217 2
			fb_log("disk_buffer_read(fd=%d): y=%d read of %d got %d bytes\n",
				fd, y, todo, got);
d270 2
a271 1
	if( lseek( fd, (off_t)FILE_CMAP_ADDR, 0 ) == -1 ) {
@


11.3
log
@Fixed bug which was causing fb_read()s on disk framebuffer "-" to fail,
by virtue of reading from stdout rather than from stdin.
Also added a bunch of error checking and diagnostics to the read support.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_disk.c,v 11.2 1998/06/27 04:29:16 mike Exp $ (BRL)";
d262 6
a267 1
	if( lseek( ifp->if_fd, (off_t)FILE_CMAP_ADDR, 0 ) == -1 ) {
d272 1
a272 1
	if( read( ifp->if_fd, (char *) cmap, sizeof(ColorMap) )
d365 6
a370 2
	fb_log( "Note: you may have just created a disk file\n" );
	fb_log( "called \"%s\" by running this.\n", ifp->if_name );
@


11.2
log
@Additions to LIBFB interface and remote framebuffer protocol to
read and write monochrome rectangles.
Particularly important for sending thermal images at high speed.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_disk.c,v 11.1 1995/01/04 09:52:53 mike Rel4_4 $ (BRL)";
d120 1
a120 1
		ifp->if_fd = 1;		/* fileno(stdin) */
d191 2
d194 3
d199 1
a199 1
	if( lseek(ifp->if_fd, (off_t)dest, 0) == -1L ) {
d206 6
a211 4
		if( (got = read( ifp->if_fd, (char *) pixelp, todo )) != todo )  {
			if( got != 0 )  {
				fb_log("disk_buffer_read: read failed\n");
				return	-1;
d213 2
a214 1
			return  0;
d216 4
a219 3
		bytes -= todo;
		pixelp += todo / sizeof(RGBpixel);
		ifp->if_seekpos += todo;
d221 1
a221 1
	return	count;
@


11.1
log
@Release_4.4
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_disk.c,v 10.5 94/08/12 20:25:03 gdurf Exp $ (BRL)";
d67 2
@


10.5
log
@Added includes
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_disk.c,v 10.4 1994/08/09 12:58:03 gdurf Exp gdurf $ (BRL)";
@


10.4
log
@Factored ifdefs
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_disk.c,v 10.3 1993/09/25 08:52:25 mike Exp gdurf $ (BRL)";
d28 3
@


10.3
log
@Converted to new fb.h
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_disk.c,v 10.2 93/09/24 19:20:30 mike Exp Locker: mike $ (BRL)";
d20 2
d23 1
a23 1
#ifdef BSD
d126 1
a126 1
			if( lseek( ifp->if_fd, height*width*sizeof(RGBpixel)-1, 0 ) == -1 ) {
d139 1
a139 1
	if( lseek( ifp->if_fd, 0L, 0 ) == -1L ) {
d189 1
a189 1
	if( lseek(ifp->if_fd, dest, 0) == -1L ) {
d224 1
a224 1
		if( lseek(ifp->if_fd, dest, 0) == -1L ) {
d248 1
a248 1
	if( lseek( ifp->if_fd, FILE_CMAP_ADDR, 0 ) == -1 ) {
d274 1
a274 1
	if( lseek( ifp->if_fd, FILE_CMAP_ADDR, 0 ) == -1 ) {
d316 1
a316 1
	if( ifp->if_seekpos != 0L && lseek( fd, 0L, 0 ) == -1 ) {
@


10.2
log
@Null setcursor
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_disk.c,v 10.1 91/10/12 06:37:24 mike Rel4_0 Locker: mike $ (BRL)";
d163 1
a163 1
RGBpixel	*bgpp;
d167 1
a167 1
	if( bgpp == (RGBpixel *)NULL )
d177 1
a177 1
RGBpixel	*pixelp;
d212 1
a212 1
RGBpixel	*pixelp;
d265 1
a265 1
ColorMap	*cmap;
d293 1
a293 1
register RGBpixel	*bpp;
d295 2
a296 2
	static RGBpixel	*pix_buf = NULL;
	register RGBpixel *pix_to;
d301 1
a301 1
		if( (pix_buf = (RGBpixel *) malloc(DISK_DMA_BYTES)) == PIXEL_NULL ) {
d308 2
a309 2
		COPYRGB( *pix_to, *bpp );
		pix_to++;
@


10.1
log
@Release_4.0
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_disk.c,v 9.6 91/07/26 22:41:03 mike Exp $ (BRL)";
d57 1
a57 1
	fb_null,		/* define cursor */
@


9.6
log
@Added if_magic field, and FB_CK_FBIO() macro, to allow checking
FBIO pointers
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_disk.c,v 9.5 90/12/11 22:16:33 phil Exp $ (BRL)";
@


9.5
log
@if_ struct changes.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_disk.c,v 9.4 90/11/03 15:40:14 mike Exp $ (BRL)";
d47 1
d98 2
@


9.4
log
@Added tracking of if_seekpos, so that -F- operation will actually
work.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_disk.c,v 9.3 90/11/03 14:42:59 mike Exp $ (BRL)";
a48 1
	fb_null,		/* reset */
d54 5
a58 6
	fb_null,		/* viewport_set */
	fb_null,		/* window_set */
	fb_null,		/* zoom_set */
	fb_null,		/* setcursor */
	fb_null,		/* cursor */
	fb_null,		/* scursor */
d61 1
d71 1
d73 3
@


9.3
log
@Added "-F-" as a synonym for writing sequentially to stdout.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_disk.c,v 9.2 89/09/01 01:40:25 phil Exp $ (BRL)";
d83 2
d110 1
d135 1
d176 2
d179 4
a182 6
	if( lseek(ifp->if_fd,
	     (((long) y * (long) ifp->if_width) + (long) x)
	     * (long) sizeof(RGBpixel), 0) == -1L ) {
		fb_log( "disk_buffer_read : seek to %ld failed.\n",
			(((long) y * (long) ifp->if_width) + (long) x)
			* (long) sizeof(RGBpixel) );
d185 1
d188 7
a194 2
		if( read( ifp->if_fd, (char *) pixelp, todo ) != todo )
			return	-1;
d197 1
d210 2
a211 1
	register int	todo;
d213 8
a220 7
	if( lseek(ifp->if_fd,
	     ((long) y * (long) ifp->if_width + (long) x)
	     * (long) sizeof(RGBpixel), 0) == -1L ) {
		fb_log( "disk_buffer_write : seek to %ld failed.\n",
			(((long) y * (long) ifp->if_width) + (long) x)
			* (long) sizeof(RGBpixel) );
		return	-1;
d230 1
d264 2
d308 1
a308 1
	if( lseek( fd, 0L, 0 ) == -1 ) {
d320 1
@


9.2
log
@fb_flush and fb_free.  Name change cleanup.  Cosmetics.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_disk.c,v 9.1 89/05/19 05:47:55 phil Locked $ (BRL)";
d98 12
@


9.1
log
@Release_3.5
@
text
@d2 13
a14 13
  Author -
	Gary S. Moss

  Source -
	SECAD/VLD Computing Consortium, Bldg 394
	The U. S. Army Ballistic Research Laboratory
	Aberdeen Proving Ground, Maryland  21005-5066
  
  Copyright Notice -
	This software is Copyright (C) 1986 by the United States Army.
	All rights reserved.

	$Header: if_disk.c,v 8.2 89/03/03 05:54:30 mike Exp $ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_disk.c,v 8.2 89/03/03 05:54:30 mike Exp $ (BRL)";
a28 2
extern int	fb_sim_readrect(), fb_sim_writerect();

d36 8
a43 7
_LOCAL_ int	dsk_dopen(),
		dsk_dclose(),
		dsk_dclear(),
		dsk_bread(),
		dsk_bwrite(),
		dsk_cmread(),
		dsk_cmwrite(),
d46 36
a81 35
FBIO disk_interface =
		{
		dsk_dopen,
		dsk_dclose,
		fb_null,		/* dreset */
		dsk_dclear,
		dsk_bread,
		dsk_bwrite,
		dsk_cmread,
		dsk_cmwrite,
		fb_null,		/* viewport_set */
		fb_null,		/* window_set */
		fb_null,		/* zoom_set */
		fb_null,		/* curs_set */
		fb_null,		/* cmemory_addr */
		fb_null,		/* cscreen_addr */
		fb_sim_readrect,
		fb_sim_writerect,
		dsk_help,
		"Disk File Interface",
		16*1024,		/* the sky's really the limit here */
		16*1024,
		"filename",		/* not in list so name is safe */
		512,
		512,
		-1,
		PIXEL_NULL,
		PIXEL_NULL,
		PIXEL_NULL,
		-1,
		0,
		0L,
		0L,
		0
		};
d86 1
a86 1
dsk_dopen( ifp, file, width, height )
d90 1
a90 1
	{
d103 1
a103 2
			if( lseek( ifp->if_fd, height*width*sizeof(RGBpixel)-1, 0 ) == -1 )
				{
d106 2
a107 3
				}
			if( write( ifp->if_fd, &zero, 1 ) < 0 )
				{
d110 1
a110 1
				}
d116 1
a116 2
	if( lseek( ifp->if_fd, 0L, 0 ) == -1L )
		{
d119 1
a119 1
		}
d121 1
a121 1
	}
d124 1
a124 1
dsk_dclose( ifp )
d126 1
a126 1
	{
d128 1
a128 1
	}
d131 1
a131 1
dsk_dclear( ifp, bgpp )
d133 8
d152 1
a152 1
dsk_bread( ifp, x, y, pixelp, count )
d157 2
a158 1
{	register long bytes = count * (long) sizeof(RGBpixel);
d161 3
a163 8
	if( lseek(	ifp->if_fd,
			(((long) y * (long) ifp->if_width) + (long) x)
			* (long) sizeof(RGBpixel),
			0
			)
	    == -1L
		)
		{
d166 1
a166 2
			* (long) sizeof(RGBpixel)
			);
d168 2
a169 3
		}
	while( bytes > 0 )
		{
d175 1
a175 1
		}
d177 1
a177 1
	}
d180 1
a180 1
dsk_bwrite( ifp, x, y, pixelp, count )
d185 7
a191 10
	{	register long	bytes = count * (long) sizeof(RGBpixel);
		register int	todo;
	if( lseek(	ifp->if_fd,
			((long) y * (long) ifp->if_width + (long) x)
			* (long) sizeof(RGBpixel),
			0
			)
	    == -1L
		)
		{
d194 1
a194 2
			* (long) sizeof(RGBpixel)
			);
d196 2
a197 3
		}
	while( bytes > 0 )
		{
d205 1
a205 1
		}
d207 1
a207 1
	}
d210 1
a210 1
dsk_cmread( ifp, cmap )
d213 2
a214 3
	{
	if( lseek( ifp->if_fd, FILE_CMAP_ADDR, 0 ) == -1 )
		{
d216 1
a216 2
				FILE_CMAP_ADDR
				);
d218 1
a218 1
		}
d220 5
a224 6
		!= sizeof(ColorMap)
		)
		{ /* Not necessarily an error.  It is not required
			that a color map be saved and the standard 
			map is not generally saved.
		   */
d226 1
a226 1
		}
d228 1
a228 1
	}
d231 1
a231 1
dsk_cmwrite( ifp, cmap )
d234 1
a234 1
	{
d236 1
a236 1
		/* Do not write default map to file.			*/
d238 1
a238 2
	if( lseek( ifp->if_fd, FILE_CMAP_ADDR, 0 ) == -1 )
		{
d240 1
a240 2
				FILE_CMAP_ADDR
				);
d242 1
a242 1
		}
d244 1
a244 3
		!= sizeof(ColorMap)
		)
		{
d247 1
a247 1
		}
d249 1
a249 1
	}
@


8.2
log
@Added support for fb_readrect() and fb_writerect().
@
text
@d14 1
a14 1
	$Header: if_disk.c,v 8.1 88/10/05 00:27:32 mike Locked $ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_disk.c,v 8.1 88/10/05 00:27:32 mike Locked $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d14 1
a14 1
	$Header: if_disk.c,v 7.4 88/09/09 23:26:01 phil Exp $ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_disk.c,v 7.4 88/09/09 23:26:01 phil Exp $ (BRL)";
d29 2
d63 2
@


7.4
log
@fbhelp function
@
text
@d14 1
a14 1
	$Header: if_disk.c,v 7.3 88/07/19 15:31:56 phil Locked $ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_disk.c,v 7.3 88/07/19 15:31:56 phil Locked $ (BRL)";
@


7.3
log
@Added error message when disk write fails
@
text
@d14 1
a14 1
	$Header: if_disk.c,v 7.2 88/05/13 21:37:50 mike Locked $ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_disk.c,v 7.2 88/05/13 21:37:50 mike Locked $ (BRL)";
d42 2
a43 1
		dsk_cmwrite();
d61 1
d65 1
a65 1
		"*disk*",
d304 18
@


7.2
log
@lint fix
@
text
@d14 1
a14 1
	$Header: if_disk.c,v 7.1 87/11/02 23:26:32 mike Locked $ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_disk.c,v 7.1 87/11/02 23:26:32 mike Locked $ (BRL)";
a164 3
#ifdef never
		todo = (bytes > DISK_DMA_BYTES ? DISK_DMA_BYTES : bytes);
#else
a165 1
#endif
a197 3
#ifdef never
		todo = (bytes > DISK_DMA_BYTES ? DISK_DMA_BYTES : bytes);
#else
d199 2
a200 2
#endif
		if( write( ifp->if_fd, (char *) pixelp, todo ) != todo )
d202 1
@


7.1
log
@Release 2.3
@
text
@d14 1
a14 1
	$Header: if_disk.c,v 6.1 87/07/11 07:51:29 mike Rel $ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_disk.c,v 6.1 87/07/11 07:51:29 mike Rel $ (BRL)";
d76 2
@


6.1
log
@Release 2.0
@
text
@d14 1
a14 1
	$Header: if_disk.c,v 5.1 87/06/24 21:51:31 mike Rel $ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_disk.c,v 5.1 87/06/24 21:51:31 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d14 1
a14 1
	$Header: if_disk.c,v 4.2 87/02/12 22:06:33 mike Exp $ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_disk.c,v 4.2 87/02/12 22:06:33 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d14 1
a14 1
	$Header: if_disk.c,v 4.1 86/12/29 03:42:46 mike Rel1 $ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_disk.c,v 4.1 86/12/29 03:42:46 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d14 1
a14 1
	$Header: if_disk.c,v 1.14 86/11/30 22:26:59 mike Exp $ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_disk.c,v 1.14 86/11/30 22:26:59 mike Exp $ (BRL)";
@


1.14
log
@Fix from Moss to correct "write byte at end" of new file.
@
text
@d14 1
a14 1
	$Header: if_disk.c,v 1.13 86/11/28 20:20:25 mike Locked $ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_disk.c,v 1.13 86/11/28 20:20:25 mike Locked $ (BRL)";
@


1.13
log
@open default size code
@
text
@d14 1
a14 1
	$Header: if_disk.c,v 1.12 86/11/13 21:30:39 phil Locked $ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_disk.c,v 1.12 86/11/13 21:30:39 phil Locked $ (BRL)";
d83 1
a83 1
	static unsigned char zero = 0;
d100 1
a100 1
			if( write( ifp->if_fd, zero, 1 ) < 0 )
@


1.12
log
@curs_set name change
@
text
@d14 1
a14 1
	$Header: if_disk.c,v 1.11 86/10/29 01:34:21 phil Locked $ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_disk.c,v 1.11 86/10/29 01:34:21 phil Locked $ (BRL)";
d61 2
a62 2
		8*1024,		/* the sky's really the limit here... */
		8*1024,
d84 6
@


1.11
log
@removed pbytes
@
text
@d14 1
a14 1
	$Header: if_disk.c,v 1.10 86/10/28 17:54:10 phil Locked $ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_disk.c,v 1.10 86/10/28 17:54:10 phil Locked $ (BRL)";
d57 1
a57 1
		fb_null,		/* cinit_bitmap */
@


1.10
log
@added if_debug
@
text
@d14 1
a14 1
	$Header: if_disk.c,v 1.9 86/10/25 17:04:25 phil Locked $ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_disk.c,v 1.9 86/10/25 17:04:25 phil Locked $ (BRL)";
a71 1
		0L,
@


1.9
log
@Fixed to ensure integer number of pixels per DMA.
Then, changed to use only 1 DMA.  With .fb file == .pix file
in 1st quadrant, things are all the same.
@
text
@d14 1
a14 1
	$Header: if_disk.c,v 1.8 86/10/25 10:53:26 phil Exp $ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_disk.c,v 1.8 86/10/25 10:53:26 phil Exp $ (BRL)";
d74 2
a75 1
		0L
@


1.8
log
@RGBpixel conversion
@
text
@d14 1
a14 1
	$Header: if_disk.c,v 1.7 86/10/25 01:25:39 phil Locked $ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_disk.c,v 1.7 86/10/25 01:25:39 phil Locked $ (BRL)";
d32 2
a33 1
#define	DISK_DMA_BYTES	(16*1024)
d157 1
d159 3
d194 1
d196 3
@


1.7
log
@Flexname changes.
@
text
@d14 1
a14 1
	$Header: if_disk.c,v 1.6 86/10/24 04:08:29 phil Locked $ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_disk.c,v 1.6 86/10/24 04:08:29 phil Locked $ (BRL)";
d30 1
a30 1
			*sizeof(Pixel))
d32 3
d88 1
a88 1
			if( lseek( ifp->if_fd, height*width*sizeof(Pixel)-1, 0 ) == -1 )
d121 3
a123 3
Pixel	*bgpp;
	{
	static Pixel	black = { 0, 0, 0, 0 };
d125 2
a126 2
	if( bgpp == (Pixel *)NULL )
		return fb_fast_dma_bg( ifp, &black );
d128 2
a129 2
	return	fb_fast_dma_bg( ifp, bgpp );
	}
d134 4
a137 4
int		x,  y;
Pixel		*pixelp;
int		count;
{	register long bytes = count * (long) sizeof(Pixel);
d142 1
a142 1
			* (long) sizeof(Pixel),
d150 1
a150 1
			* (long) sizeof(Pixel)
d156 1
a156 1
		todo = (bytes > MAX_BYTES_DMA ? MAX_BYTES_DMA : bytes);
d160 1
a160 1
		pixelp += todo / sizeof(Pixel);
d169 1
a169 1
Pixel	*pixelp;
d171 1
a171 1
	{	register long	bytes = count * (long) sizeof(Pixel);
d175 1
a175 1
			* (long) sizeof(Pixel),
d183 1
a183 1
			* (long) sizeof(Pixel)
d189 1
a189 1
		todo = (bytes > MAX_BYTES_DMA ? MAX_BYTES_DMA : bytes);
d193 1
a193 1
		pixelp += todo / sizeof(Pixel);
d246 46
@


1.6
log
@read and write return number of bytes.
@
text
@d14 1
a14 1
	$Header: if_disk.c,v 1.5 86/10/14 23:12:27 phil Locked $ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_disk.c,v 1.5 86/10/14 23:12:27 phil Locked $ (BRL)";
d32 7
a38 7
_LOCAL_ int	disk_dopen(),
		disk_dclose(),
		disk_dclear(),
		disk_bread(),
		disk_bwrite(),
		disk_cmread(),
		disk_cmwrite();
d42 2
a43 2
		disk_dopen,
		disk_dclose,
d45 5
a49 5
		disk_dclear,
		disk_bread,
		disk_bwrite,
		disk_cmread,
		disk_cmwrite,
d74 1
a74 1
disk_dopen( ifp, file, width, height )
d109 1
a109 1
disk_dclose( ifp )
d116 1
a116 1
disk_dclear( ifp, bgpp )
d129 1
a129 1
disk_bread( ifp, x, y, pixelp, count )
d163 1
a163 1
disk_bwrite( ifp, x, y, pixelp, count )
d196 1
a196 1
disk_cmread( ifp, cmap )
d220 1
a220 1
disk_cmwrite( ifp, cmap )
@


1.5
log
@Added NULL check on clear
minor cosmetics
@
text
@d14 1
a14 1
	$Header: if_disk.c,v 1.4 86/10/03 06:46:53 phil Locked $ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_disk.c,v 1.4 86/10/03 06:46:53 phil Locked $ (BRL)";
d159 1
a159 1
	return	0;
d192 1
a192 1
	return	0;
@


1.4
log
@Fixed include problem
@
text
@d14 1
a14 1
	$Header: if_disk.c,v 1.3 86/10/03 06:32:22 phil Exp $ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_disk.c,v 1.3 86/10/03 06:32:22 phil Exp $ (BRL)";
d85 1
a85 1
			if( lseek( ifp->if_fd, height*width*4-1, 0 ) == -1 )
d120 5
d134 3
a136 2
	{	register long bytes = count * (long) sizeof(Pixel);
		register long todo;
@


1.3
log
@Shortened names.
@
text
@d14 1
a14 1
	$Header: if_disk.c,v 1.2 86/10/03 03:12:25 phil Locked $ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_disk.c,v 1.2 86/10/03 03:12:25 phil Locked $ (BRL)";
d19 1
d21 3
d25 1
@


1.2
log
@Clean up.
@
text
@d14 1
a14 1
	$Header: if_disk.c,v 1.1 86/10/02 02:17:51 mike Locked $ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: if_disk.c,v 1.1 86/10/02 02:17:51 mike Locked $ (BRL)";
d27 7
a33 7
_LOCAL_ int	disk_device_open(),
		disk_device_close(),
		disk_device_clear(),
		disk_buffer_read(),
		disk_buffer_write(),
		disk_colormap_read(),
		disk_colormap_write();
d37 14
a50 14
		disk_device_open,
		disk_device_close,
		fb_null,		/* device_reset */
		disk_device_clear,
		disk_buffer_read,
		disk_buffer_write,
		disk_colormap_read,
		disk_colormap_write,
		fb_null,
		fb_null,
		fb_null,
		fb_null,
		fb_null,
		fb_null,
d69 1
a69 1
disk_device_open( ifp, file, width, height )
d104 1
a104 1
disk_device_close( ifp )
d111 1
a111 1
disk_device_clear( ifp, bgpp )
d119 1
a119 1
disk_buffer_read( ifp, x, y, pixelp, count )
d152 1
a152 1
disk_buffer_write( ifp, x, y, pixelp, count )
d185 1
a185 1
disk_colormap_read( ifp, cmap )
d209 1
a209 1
disk_colormap_write( ifp, cmap )
@


1.1
log
@Initial revision
@
text
@d14 1
a14 1
	$Header$ (BRL)
d17 1
a17 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d20 1
a22 12

#ifndef O_CREAT
#ifdef O_RDONLY
#undef O_RDONLY
#undef O_WRONLY
#undef O_RDWR
#undef O_NDELAY
#undef O_APPEND
#endif
#include <sys/types.h>
#include <sys/file.h>
#endif
@
