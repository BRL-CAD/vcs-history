head	11.15;
access;
symbols
	ansi-20040405-merged:11.11.2.2
	postmerge-20040405-ansi:11.13
	premerge-20040404-ansi:11.12
	postmerge-autoconf:11.12
	autoconf-freeze:11.11.10.2
	premerge-autoconf:11.12
	ansi-20040316-freeze:11.11.2.1
	postmerge-20040315-windows:11.12
	premerge-20040315-windows:11.12
	windows-20040315-freeze:11.11.4.1
	autoconf-20031203:11.11
	autoconf-20031202:11.11
	autoconf-branch:11.11.0.10
	phong-branch:11.11.0.8
	photonmap-branch:11.11.0.6
	rel-6-1-DP:11.11
	windows-branch:11.11.0.4
	rel-6-0-2:11.9
	ansi-branch:11.11.0.2
	rel-6-0-1-branch:11.9.0.2
	hartley-6-0-post:11.10
	hartley-6-0-pre:11.9
	rel-6-0-1:11.9
	rel-6-0:11.9
	rel-5-4:11.5
	offsite-5-3-pre:11.8
	rel-5-3:11.5
	rel-5-2:11.5
	rel-5-1-branch:11.5.0.2
	rel-5-1:11.5
	rel-5-0:11.5
	rel-5-0-beta:11.5
	rel-4-5:11.3
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1;
locks; strict;
comment	@ * @;


11.15
date	2004.05.21.18.07.24;	author morrison;	state dead;
branches;
next	11.14;

11.14
date	2004.05.10.15.30.44;	author erikg;	state Exp;
branches;
next	11.13;

11.13
date	2004.04.05.07.44.42;	author morrison;	state Exp;
branches;
next	11.12;

11.12
date	2004.02.02.17.39.12;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2002.08.20.17.07.46;	author jra;	state Exp;
branches
	11.11.2.1
	11.11.4.1
	11.11.10.1;
next	11.10;

11.10
date	2002.08.15.20.55.00;	author hartley;	state Exp;
branches;
next	11.9;

11.9
date	2001.04.20.22.29.13;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2000.07.25.17.49.50;	author butler;	state Exp;
branches;
next	11.7;

11.7
date	2000.07.24.22.29.11;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	2000.07.12.01.33.30;	author cjohnson;	state Exp;
branches;
next	11.5;

11.5
date	98.09.14.15.59.15;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	98.06.27.04.29.15;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	96.08.27.06.23.55;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.07.10.15.25.43;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.52.41;	author mike;	state Rel4_4;
branches;
next	10.14;

10.14
date	94.12.30.03.57.25;	author mike;	state Exp;
branches;
next	10.13;

10.13
date	94.12.22.00.46.05;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	94.12.19.15.44.01;	author jra;	state Exp;
branches;
next	10.11;

10.11
date	94.12.15.16.27.41;	author jra;	state Exp;
branches;
next	10.10;

10.10
date	94.12.07.21.35.04;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	94.11.23.23.41.13;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	94.11.04.23.47.35;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.11.04.05.15.27;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.11.04.05.14.29;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.08.09.12.57.34;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	93.10.22.22.25.56;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	93.10.22.20.50.56;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	93.09.25.09.04.11;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.37.19;	author mike;	state Rel4_0;
branches;
next	9.12;

9.12
date	91.08.31.03.20.14;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	91.07.26.22.40.56;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	91.07.04.03.04.40;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	90.12.11.22.56.37;	author phil;	state Exp;
branches
	9.9.1.1;
next	9.8;

9.8
date	90.06.06.20.52.18;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	89.09.01.01.36.42;	author phil;	state Exp;
branches
	9.7.1.1;
next	9.6;

9.6
date	89.08.29.23.41.27;	author phil;	state Exp;
branches;
next	9.5;

9.5
date	89.08.23.03.20.21;	author phil;	state Exp;
branches;
next	9.4;

9.4
date	89.08.14.00.10.57;	author phil;	state Exp;
branches;
next	9.3;

9.3
date	89.08.13.23.07.07;	author phil;	state Exp;
branches;
next	9.2;

9.2
date	89.07.28.05.39.50;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.47.46;	author mike;	state Rel3_5;
branches;
next	8.6;

8.6
date	89.04.29.06.00.10;	author phil;	state Exp;
branches;
next	8.5;

8.5
date	89.04.07.05.50.07;	author phil;	state Exp;
branches;
next	8.4;

8.4
date	89.03.07.22.17.12;	author phil;	state Exp;
branches;
next	8.3;

8.3
date	89.03.03.05.54.21;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	89.03.02.20.34.28;	author phil;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.27.26;	author mike;	state Rel3_0;
branches;
next	1.2;

1.2
date	88.10.04.20.16.25;	author phil;	state Exp;
branches;
next	1.1;

1.1
date	88.09.15.21.26.31;	author phil;	state Exp;
branches;
next	;

9.7.1.1
date	89.10.01.18.01.39;	author phil;	state Exp;
branches;
next	;

9.9.1.1
date	91.06.28.00.28.52;	author cjohnson;	state Exp;
branches;
next	;

11.11.2.1
date	2002.09.19.18.01.18;	author morrison;	state Exp;
branches;
next	11.11.2.2;

11.11.2.2
date	2004.03.17.21.17.00;	author morrison;	state Exp;
branches;
next	;

11.11.4.1
date	2004.03.11.23.42.07;	author morrison;	state Exp;
branches;
next	;

11.11.10.1
date	2004.02.12.19.48.12;	author erikg;	state Exp;
branches;
next	11.11.10.2;

11.11.10.2
date	2004.03.15.14.06.19;	author erikg;	state Exp;
branches;
next	;


desc
@X Window System (X11) libfb interface
@


11.15
log
@moved to src/
@
text
@#define	DEBUGX	0
#define	CURSOR	1
/*
 *			I F _ X . C
 *
 *  X Window System (X11) libfb interface.
 *
 *  Authors -
 *	Phillip Dykstra
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1988-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libfb/if_X.c,v 11.14 2004/05/10 15:30:44 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <unistd.h>
#include <ctype.h>
#include <fcntl.h>
#ifdef HAVE_STRING_H
# include <string.h>
#else
# include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "fb.h"
#include "./fblocal.h"

#include <X11/X.h>
#ifdef HAVE_XOSDEFS_H
#include <X11/Xfuncproto.h>
#include <X11/Xosdefs.h>
#endif
#if defined(linux)
#	undef	X_NOT_STDC_ENV
#	undef	X_NOT_POSIX
#endif
#define XLIB_ILLEGAL_ACCESS	/* necessary on facist SGI 5.0.1 */
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/cursorfont.h>
#include <X11/Xatom.h>		/* for XA_RGB_BEST_MAP */

static	void	slowrect(FBIO *ifp, int xmin, int xmax, int ymin, int ymax);
static	int	linger(FBIO *ifp);
static	int	xsetup(FBIO *ifp, int width, int height);
void		x_print_display_info(Display *dpy);
static	int	x_make_colormap(FBIO *ifp);	/*XXX*/
static	int	x_make_cursor(FBIO *ifp);	/*XXX*/
static void	repaint(FBIO *ifp);

#define TMP_FILE	"/tmp/x.cmap"

_LOCAL_ int	X_scanwrite(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count, int save);

_LOCAL_ int	X_open(FBIO *ifp, char *file, int width, int height),
		X_close(FBIO *ifp),
		X_clear(FBIO *ifp, unsigned char *pp),
		X_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count),
		X_write(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count),
		X_rmap(FBIO *ifp, ColorMap *cmp),
		X_wmap(FBIO *ifp, const ColorMap *cmp),
		X_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
		X_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom),
		X_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig),
		X_cursor(FBIO *ifp, int mode, int x, int y),
		X_getcursor(FBIO *ifp, int *mode, int *x, int *y),
		X_poll(FBIO *ifp),
		X_flush(FBIO *ifp),
		X_help(FBIO *ifp);

#ifdef USE_PROTOTYPES
static void	Monochrome( unsigned char *bitbuf, unsigned char *bytebuf, int width, int height, int method);
static int	do_event( FBIO	*ifp );
#else
static void	Monochrome();
static int	do_event();
#endif

/* This is the ONLY thing that we normally "export" */
FBIO X_interface = {
	0,
	X_open,			/* device_open		*/
	X_close,		/* device_close		*/
	X_clear,		/* device_clear		*/
	X_read,			/* buffer_read		*/
	X_write,		/* buffer_write		*/
	X_rmap,			/* colormap_read	*/
	X_wmap,			/* colormap_write	*/
	X_view,			/* set view		*/
	X_getview,		/* get view		*/
	X_setcursor,		/* define cursor	*/
	X_cursor,		/* set cursor		*/
	X_getcursor,		/* get cursor		*/
	fb_sim_readrect,	/* read rectangle	*/
	fb_sim_writerect,	/* write rectangle	*/
	fb_sim_bwreadrect,
	fb_sim_bwwriterect,
	X_poll,			/* handle events	*/
	X_flush,		/* flush		*/
	X_close,		/* free			*/
	X_help,			/* help message		*/
	"X Window System (X11) 8-bit and 1-bit visuals only",
	2048,			/* max width		*/
	2048,			/* max height		*/
	"/dev/xold",		/* short device name	*/
	512,			/* default/current width  */
	512,			/* default/current height */
	-1,			/* select file desc	*/
	-1,			/* file descriptor	*/
	1, 1,			/* zoom			*/
	256, 256,		/* window center	*/
	0, 0, 0,		/* cursor		*/
	PIXEL_NULL,		/* page_base		*/
	PIXEL_NULL,		/* page_curp		*/
	PIXEL_NULL,		/* page_endp		*/
	-1,			/* page_no		*/
	0,			/* page_dirty		*/
	0L,			/* page_curpos		*/
	0L,			/* page_pixels		*/
	0			/* debug		*/
};

/*
 * Per window state information.
 */
struct	xinfo {
	Display	*dpy;			/* Display and Screen(s) info */
	Window	win;			/* Window ID */
	int	screen;			/* Our screen selection */
	Visual	*visual;		/* Our visual selection */
	GC	gc;			/* current graphics context */
	Colormap cmap;			/* 8bit X colormap */
	XImage	*image;
	XImage	*scanimage;
	unsigned char *bytebuf;		/* 8bit image buffer */
	unsigned char *bitbuf;		/* 1bit image buffer */
	unsigned char *scanbuf;		/* single scan line image buffer */
	unsigned char *mem;		/* optional 24bit store */
	int	method;			/* bitmap conversion method */
	Window	curswin;		/* Cursor Window ID */

	int	depth;			/* 1, 8, or 24bit */
	int	mode;			/* 0,1,2 */
	ColorMap rgb_cmap;		/* User's libfb colormap */
};
#define	XI(ptr) ((struct xinfo *)((ptr)->u1.p))
#define	XIL(ptr) ((ptr)->u1.p)		/* left hand side version */

#define MODE_1MASK	(1<<1)
#define MODE_1TRANSIENT	(0<<1)
#define MODE_1LINGERING (1<<1)

#define MODE_2MASK	(1<<2)
#define MODE_2RGB	(0<<2)
#define MODE_2_8BIT	(1<<2)

#define MODE_3MASK	(1<<3)
#define MODE_3NORMAL	(0<<3)
#define MODE_3MONO	(1<<3)

#define MODE_4MASK	(1<<4)
#define MODE_4NORMAL	(0<<4)
#define MODE_4MEM	(1<<4)

#define MODE_5MASK	(1<<5)
#define MODE_5NORMAL	(0<<5)
#define MODE_5INSTCMAP	(1<<5)

static struct modeflags {
	char	c;
	long	mask;
	long	value;
	char	*help;
} modeflags[] = {
	{ 'l',	MODE_1MASK, MODE_1LINGERING,
		"Lingering window - else transient" },
	{ 'b',  MODE_2MASK, MODE_2_8BIT,
		"8-bit Black and White from RED channel" },
	{ 'm',  MODE_4MASK, MODE_4MEM,
		"24-bit memory buffer" },
	{ 'M',  MODE_3MASK, MODE_3MONO,
		"Force Monochrome mode - debugging" },
	{ 'I',  MODE_5MASK, MODE_5INSTCMAP,
		"Install the colormap - debug" },
	{ '\0', 0, 0, "" }
};

/*
 *	Hardware colormap support
 *
 *	The color map is organized as a 6x6x6 colorcube, with 10 extra  
 *	entries each for the primary colors and grey values.
 *
 *	entries 0 -> 215 are the color cube
 *	entries 216 -> 225 are extra "red" values
 *	entries 226 -> 235 are extra "green" values
 *	entries 236 -> 245 are extra "blue" values
 *	entries 246 -> 255 are extra "grey" values
 *
 */
/* Our copy of the *hardware* colormap */
static unsigned char redmap[256], grnmap[256], blumap[256];

/* values for color cube entries */
static unsigned char cubevec[6] = { 0, 51, 102, 153, 204, 255 };

/* additional values for primaries */
static unsigned char primary[10] = {
	17, 34, 68, 85, 119, 136, 170, 187, 221, 238
};

/* Arrays containing the indicies of the primary colors and grey values
 * in the color map
 */
static unsigned short redvec[16] = {
0,  216, 217, 1, 218, 219, 2, 220, 221, 3, 222, 223, 4, 224, 225, 5
};
static unsigned short grnvec[16] = {
0, 226, 227, 6, 228, 229, 12, 230, 231, 18, 232, 233, 24, 234, 235, 30
};
static unsigned short bluvec[16] = {
0, 236, 237, 36, 238, 239, 72, 240, 241, 108, 242, 243, 144, 244, 245, 180
};
static unsigned short greyvec[16] = {
0, 246, 247, 43, 248, 249, 86, 250, 251, 129, 252, 253, 172, 254, 255, 215
};

static unsigned char convRGB(register const unsigned char *v);
unsigned long 	*x_pixel_table;
XColor 		*color_defs; 

_LOCAL_ int
X_open(FBIO *ifp, char *file, int width, int height)
{
	int	fd;
	int	mode;
	unsigned char *bytebuf;		/* local copy */
	unsigned char *bitbuf;		/* local copy */
	unsigned char *scanbuf;		/* local copy */

	FB_CK_FBIO(ifp);

	/*
	 *  First, attempt to determine operating mode for this open,
	 *  based upon the "unit number" or flags.
	 *  file = "/dev/X###"
	 *  The default mode is zero.
	 */
	mode = 0;

	if( file != NULL )  {
		register char *cp;
		char	modebuf[80];
		char	*mp;
		int	alpha;
		struct	modeflags *mfp;

		if( strncmp(file, "/dev/X", 6) ) {
			/* How did this happen?? */
			mode = 0;
		}
		else {
			/* Parse the options */
			alpha = 0;
			mp = &modebuf[0];
			cp = &file[6];
			while( *cp != '\0' && !isspace(*cp) ) {
				*mp++ = *cp;	/* copy it to buffer */
				if( isdigit(*cp) ) {
					cp++;
					continue;
				}
				alpha++;
				for( mfp = modeflags; mfp->c != '\0'; mfp++ ) {
					if( mfp->c == *cp ) {
						mode = (mode&~mfp->mask)|mfp->value;
						break;
					}
				}
				if( mfp->c == '\0' && *cp != '-' ) {
					fb_log( "if_X: unknown option '%c' ignored\n", *cp );
				}
				cp++;
			}
			*mp = '\0';
			if( !alpha )
				mode = atoi( modebuf );
		}
	}

	if( width <= 0 )
		width = ifp->if_width;
	if( height <= 0 )
		height = ifp->if_height;
	if ( width > ifp->if_max_width) 
		width = ifp->if_max_width;
	if ( height > ifp->if_max_height) 
		height = ifp->if_max_height;

	/* round width up to a multiple of eight bits */
	if( (width%8) != 0 )
		width = ((width + 7)/8)*8;
	ifp->if_width = width;
	ifp->if_height = height;

	/* create a struct of state information */
	if( (XIL(ifp) = (char *)calloc( 1, sizeof(struct xinfo) )) == NULL ) {
		fb_log("X_open: xinfo malloc failed\n");
		return(-1);
	}
	ifp->if_xzoom = 1;
	ifp->if_yzoom = 1;
	ifp->if_xcenter = width/2;
	ifp->if_ycenter = height/2;
	XI(ifp)->mode = mode;

	/* set up an X window, graphics context, etc. */
	if( xsetup( ifp, width, height ) < 0 ) {
		return(-1);
	}

	/* check for forced monochrome behavior */
	if( (XI(ifp)->mode&MODE_3MASK) == MODE_3MONO )
		XI(ifp)->depth = 1;

	/* Init our internal, and possibly X's, colormap */
	/* ColorMap File HACK */
	if( (fd = open( TMP_FILE, 0 )) >= 0 ) {
		/* restore it from a file */
		read( fd, &(XI(ifp)->rgb_cmap), sizeof(XI(ifp)->rgb_cmap) );
		close(fd);
		X_wmap( ifp, &(XI(ifp)->rgb_cmap) );
	} else {
		/* use linear map */
		X_wmap( ifp, (ColorMap *)NULL );
	}

	/* Allocate all of our working pixel/bit buffers */
	if( (bytebuf = (unsigned char *)calloc( 1, width*height )) == NULL ) {
		fb_log("X_open: bytebuf malloc failed\n");
		return(-1);
	}
	if( (bitbuf = (unsigned char *)calloc( 1, (width*height)/8 )) == NULL ) {
		fb_log("X_open: bitbuf malloc failed\n");
		return(-1);
	}
	if( (scanbuf = (unsigned char *)calloc( 1, width )) == NULL ) {
		fb_log("X_open: scanbuf malloc failed\n");
		return(-1);
	}
	XI(ifp)->bytebuf = bytebuf;
	XI(ifp)->bitbuf = bitbuf;
	XI(ifp)->scanbuf = scanbuf;

	if( (XI(ifp)->mode&MODE_4MASK) == MODE_4MEM ) {
		/* allocate a full 24-bit deep buffer */
		XI(ifp)->mem = (unsigned char *)calloc( 3, width*height );
		if( XI(ifp)->mem == NULL ) {
			fb_log("X_open: 24-bit buffer malloc failed\n");
		}
	}

	/*
	 *  Create an Image structure.
	 *  The image is our client resident copy which we
	 *  can get/put from/to a server resident Pixmap or
	 *  Window (i.e. a "Drawable").
	 */
	if( XI(ifp)->depth == 8 ) {
		XI(ifp)->image = XCreateImage( XI(ifp)->dpy,
			XI(ifp)->visual, 8, ZPixmap, 0,
			(char *)bytebuf, width, height, 32, 0);
		XI(ifp)->scanimage = XCreateImage( XI(ifp)->dpy,
			XI(ifp)->visual, 8, ZPixmap, 0,
			(char *)scanbuf, width, 1, 32, 0);
	} else {
		/* An XYBitmap can be used on any depth display.
		 * The GC of the XPutImage provides fg and bg
		 * pixels for each 1 and 0 bit respectively.
		 * (This may be very slow however for depth != 1)
		 */
		XI(ifp)->image = XCreateImage( XI(ifp)->dpy,
			XI(ifp)->visual, 1, XYBitmap, 0,
			(char *)bitbuf, width, height, 8, 0);
		XI(ifp)->scanimage = XCreateImage( XI(ifp)->dpy,
			XI(ifp)->visual, 1, XYBitmap, 0,
			(char *)scanbuf, width, 1, 8, 0);
		XI(ifp)->depth = 1;
	}

	/* Make the Display connection available for selecting on */

	ifp->if_selfd = XI(ifp)->dpy->fd;

	return(0);
}

_LOCAL_ int
X_close(FBIO *ifp)
{
	XFlush( XI(ifp)->dpy );
	if( (XI(ifp)->mode & MODE_1MASK) == MODE_1LINGERING ) {
		if( linger(ifp) )
			return(0);	/* parent leaves the display */
	}
	if( XIL(ifp) != NULL ) {
		XCloseDisplay( XI(ifp)->dpy );
		(void)free( (char *)XIL(ifp) );
	}
	return(0);
}

_LOCAL_ int
X_clear(FBIO *ifp, unsigned char *pp)
{
	unsigned char *bitbuf = XI(ifp)->bitbuf;
	unsigned char *bytebuf = XI(ifp)->bytebuf;
#ifdef XXX
	RGBpixel v;

	if( pp == RGBPIXEL_NULL ) {
		v[RED] = v[GRN] = v[BLU] = 0;
	} else {
		v[RED] = (pp)[RED];
		v[GRN] = (pp)[GRN];
		v[BLU] = (pp)[BLU];
	}
	if( v[RED] == v[GRN] && v[RED] == v[BLU] ) {
		int	bytes = ifp->if_width*ifp->if_height*3;
		if( v[RED] == 0 )
			bzero( cp, bytes );		/* all black */
		else
			memset( cp, v[RED], bytes );	/* all grey */
	} else {
		for( n = ifp->if_width*ifp->if_height; n; n-- ) {
			*cp++ = v[RED];
			*cp++ = v[GRN];
			*cp++ = v[BLU];
		}
	}
#endif
	if( pp == (unsigned char *)NULL
	 || ((pp)[RED] == 0 && (pp)[GRN] == 0 && (pp)[BLU] == 0) ) {
		bzero( (char *)bitbuf, (ifp->if_width * ifp->if_height)/8 );
		bzero( (char *)bytebuf, (ifp->if_width * ifp->if_height) );
		XClearWindow( XI(ifp)->dpy, XI(ifp)->win );
	}
	/*XXX*/
	return(0);
}

_LOCAL_ int
X_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count)
{
	unsigned char *bytebuf = XI(ifp)->bytebuf;
	register unsigned char	*cp;
	register int	i;

	if( x < 0 || x >= ifp->if_width || y < 0 || y >= ifp->if_height )
		return	-1;

	/* return 24bit store if available */
	if( XI(ifp)->mem ) {
		bcopy( &(XI(ifp)->mem[(y*ifp->if_width+x)*sizeof(RGBpixel)]),
		       pixelp, count*sizeof(RGBpixel) );
		return	count;
	}

	/* 1st -> 4th quadrant */
	y = ifp->if_height - 1 - y;

	/* give then gray scale pixels - XXX - may be pseudo color */
	cp = &bytebuf[y*ifp->if_width + x];
	for( i = 0; i < count; i++ ) {
		*pixelp++ = *cp;
		*pixelp++ = *cp;
		*pixelp++ = *cp++;
	}
	return	count;
}

/*
 * Dithering
 */
int dm4[4][4] = {
	{ 0,  8,  2, 10},
	{12,  4, 14,  6},
	{ 3, 11,  1,  9},
	{15,  7, 13,  5}
};
int dm8[8][8] = {
	{ 0, 32,  8, 40,  2, 34, 10, 42},
	{48, 16, 56, 24, 50, 18, 58, 26},
	{12, 44,  4, 36, 14, 46,  6, 38},
	{60, 28, 52, 20, 62, 30, 54, 22},
	{ 3, 35, 11, 43,  1, 33,  9, 41},
	{51, 19, 59, 27, 49, 17, 57, 25},
	{15, 47,  7, 39, 13, 45,  5, 37},
	{63, 31, 55, 23, 61, 29, 53, 21}
};
int ditherPeriod = 8;
int *dm = &(dm8[0][0]);
int *error1, *error2;

int dither_bw(unsigned int pixel, register int count, register int line)
{
	if( pixel > dm[((line%ditherPeriod)*ditherPeriod) +
	    (count%ditherPeriod)])
		return(1);
	else
		return(0);
}

/*
 * Floyd Steinberg error distribution algorithm
 */
int
fs_bw(unsigned int pixel, register int count, register int line)
{
	int  onoff;
	int  intensity, error;

	if( count == 0 ) {
		int *tmp;
		tmp = error1;
		error1 = error2;
		error2 = tmp;
		error2[0] = 0;
	}

	intensity = pixel + error1[count];
	if( intensity < 128 ) {
		onoff = 0;
		error = intensity;
	} else {
		onoff = 1;
		error = intensity - 255;
	}

	error1[count+1] += (int)(3*error)/8;	/* right */
	error2[count+1] = (int)error/4;		/* down */
	error2[count] += (int)(3*error)/8;	/* diagonal */
	return(onoff);
}

/*
 * Modified Floyd Steinberg algorithm
 */
int
mfs_bw(unsigned int pixel, register int count, register int line)
{
	int  onoff;
	int  intensity, error;

	if (count == 0) {
		int *tmp;
		tmp = error1;
		error1 = error2;
		error2 = tmp;
		error2[0] = 0;
	}

	intensity = pixel + error1[count];

	if (intensity < 128) {
		onoff = 0;
		error = 128 - intensity;
	} else {
		onoff = 1;
		error = 128 - intensity;
	}

	error1[count+1] += (int)(3*error)/8;	/* right */
	error2[count+1] = (int)error/4;		/* down */
	error2[count] += (int)(3*error)/8;	/* diagonal */
	return(onoff);
}

/*
 * Decompose a write of more than one scanline into multiple single
 * scanline writes.
 */
_LOCAL_ int
X_write(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count)
{
	int	maxcount;
	int	todo;
	int	num;

	/* check origin bounds */
	if( x < 0 || x >= ifp->if_width || y < 0 || y >= ifp->if_height )
		return	-1;

	/* check write length */
	maxcount = ifp->if_width * (ifp->if_height - y) - x;
	if( count > maxcount )
		count = maxcount;

	/* save it in 24bit store if available */
	if( XI(ifp)->mem ) {
		bcopy( pixelp,
		       &(XI(ifp)->mem[(y*ifp->if_width+x)*sizeof(RGBpixel)]),
		       count*sizeof(RGBpixel) );
	}

	todo = count;
	while( todo > 0 ) {
		if( x + todo > ifp->if_width )
			num = ifp->if_width - x;
		else
			num = todo;
		if( X_scanwrite( ifp, x, y, pixelp, num, 1 ) == 0 )
			return( 0 );
		x = 0;
		y++;
		todo -= num;
		pixelp += num;
	}
	return( count );
}

/*
 * This function converts a single scan line of (pre color mapped) pixels
 * into displayable form.  It will either save this data into our X image
 * buffer for later repaints/redisplay or it will put it into a single
 * scanline temporary buffer for immediate display.
 */
_LOCAL_ int
X_scanwrite(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count, int save)
{
	unsigned char *bitbuf = XI(ifp)->bitbuf;
	unsigned char *bytebuf = XI(ifp)->bytebuf;
	unsigned char *scanbuf = XI(ifp)->scanbuf;
	register unsigned char	*cp;
	register int	i;
	static unsigned char MSB[8] = { 0x80, 0x40, 0x20, 0x10, 8, 4, 2, 1 };
	static unsigned char LSB[8] = { 1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80 };
	register unsigned char *bits = MSB;
	unsigned char tmpbuf[1280];	/*XXX*/
	int	sy;			/* 4th quad y */

	/* 1st -> 4th quadrant */
	sy = ifp->if_height - 1 - y;
	if( save ) {
		cp = &bytebuf[sy*ifp->if_width + x];
	} else {
		if( XI(ifp)->depth == 1 )
			cp = tmpbuf;	/* save scanbuf for 1bit output */
		else
			cp = scanbuf;
	}

	if( XI(ifp)->depth == 8 ) {
		/* Gray Scale Mode */
		if( (XI(ifp)->mode&MODE_2MASK) == MODE_2_8BIT )  {
			for( i=0; i<count; i++ )  {
				cp[i] = pixelp[3*i+RED];
			}
			goto done;
		}
		/* PseudoColor Mode */
		for( i = 0; i < count; i++ ) {
			int value;
			value = convRGB(&pixelp[3*i]);
			cp[i] = (unsigned char) x_pixel_table[value];
		}
		goto done;
	}

	/* MONOCHROME Follows */

	/* save the 8bit black and white version of it */
	/* XXX - note replication of Gray Scale Mode above... */
	if( (XI(ifp)->mode&MODE_2MASK) == MODE_2_8BIT )  {
		for( i = 0; i < count; i++ ) {
			cp[i] = pixelp[3*i+RED];
		}
	} else {
		for( i = 0; i < count; i++ ) {
			/* Best possible 8-bit NTSC weights */
			/* Use three tables if this gets to be a bottleneck */
			cp[i] = (77*(int)pixelp[3*i+RED] + 150*(int)pixelp[3*i+GRN]
				+ 29*(int)pixelp[3*i+BLU]) >> 8;
		}
	}

	/* Convert the monochrome data to a bitmap */
	if (BitmapBitOrder(XI(ifp)->dpy) == LSBFirst) {
		bits = LSB;
	}

	{
	int	row, col, bit;
    	int	byte, rem;
	unsigned char	mvalue;
	unsigned char	*mbuffer;	/* = &buffer[(sy*ifp->if_width + x)/8]; */
    	byte = sy * ifp->if_width + x;
    	rem = byte % 8;
    	byte /= 8;
	if( save )
		mbuffer = &bitbuf[byte];
	else
		mbuffer = scanbuf;

	for( row = sy; row < sy+1; row++ ) {
		for( col=x; col < x+count; ) {
			/*mvalue = 0x00;*/
			/* pre-read the byte */
			mvalue = *mbuffer;
			/* diddle its bit */
			for( bit=rem; (bit < 8) && (col < x+count); bit++,col++ ) {
				/*val = (30*(pixelp)[RED] + 59*(pixelp)[GRN] + 11*(pixelp)[BLU] + 200) / 400;*/
				/*pixelp++;*/
				/*if( dither_bw(val, col, row) ) {*/
				if( (int)*cp++ > (dm[((row&7)<<3)+(col&7)]<<2)+1 ) {
					mvalue |= bits[bit];
				} else {
					mvalue &= ~bits[bit];
				}
			}
			/* put the byte back */
			*mbuffer++ = mvalue;
			rem = 0;
		}
	}
	}

done:
	/* XXX - Determine how much of the scan line is displayed in
	 * the window (if any) including pan & zoom, and display that
	 * portion.
	 */
	if( save && (ifp->if_xzoom != 1) ) {
		/* note: slowrect never asks us to save */
		slowrect( ifp, x, x+count-1, y, y );
	} else if( save ) {
		XPutImage(XI(ifp)->dpy, XI(ifp)->win, XI(ifp)->gc,
			XI(ifp)->image,
			x, sy, x, sy,
			count, 1 );
	} else {
		XPutImage(XI(ifp)->dpy, XI(ifp)->win, XI(ifp)->gc,
			XI(ifp)->scanimage,
			0, 0, x, sy,
			count, 1 );
	}

	/* XXX - until we get something better */
	if( count > 1 )
		XFlush(XI(ifp)->dpy);

    	return	count;
}

_LOCAL_ int
X_rmap(FBIO *ifp, ColorMap *cmp)
{
	*cmp = XI(ifp)->rgb_cmap;	/* struct copy */
	return(0);
}

_LOCAL_ int
X_wmap(FBIO *ifp, const ColorMap *cmp)
{
	register int i;
	int	is_linear = 1;

	if( cmp == (ColorMap *)NULL ) {
		fb_make_linear_cmap( &(XI(ifp)->rgb_cmap) );
		is_linear = 1;
	} else {
		XI(ifp)->rgb_cmap = *cmp;	/* struct copy */
		is_linear = fb_is_linear_cmap(cmp);
	}

	/* Hack to save it into a file - this may go away */
	if( is_linear ) {
		/* no file => linear map */
		(void) unlink( TMP_FILE );
	} else {
		/* save map for later */
		i=creat(TMP_FILE, 0666);
		if( i >= 0 )  {
			write( i, cmp, sizeof(*cmp) );
			close(i);
		} else {
			fprintf(stderr, "if_X: couldn't save color map\n");
			perror(TMP_FILE);
		}
	}

	if( XI(ifp)->depth != 8 )
		return(0);	/* no X colormap allocated - XXX */

	/* If MODE_2_8BIT, load it in the real window colormap */
	if( (XI(ifp)->mode&MODE_2MASK) == MODE_2_8BIT ) {
		for( i = 0; i < 256; i++ ) {
			/* Both sides expect 16-bit left-justified maps */
			color_defs[i].pixel = i;
			color_defs[i].red   = cmp->cm_red[i];
			color_defs[i].green = cmp->cm_green[i];
			color_defs[i].blue  = cmp->cm_blue[i];
		        color_defs[i].flags = DoRed | DoGreen | DoBlue;
		}
		XStoreColors( XI(ifp)->dpy, XI(ifp)->cmap, color_defs, 256 );
	}

	return(0);
}

_LOCAL_ int
X_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
{
	/* bypass if no change */
	if( ifp->if_xcenter == xcenter && ifp->if_ycenter == ycenter
	 && ifp->if_xzoom == xcenter && ifp->if_yzoom == ycenter )
		return	0;

	/* check bounds */
	if( xcenter < 0 || xcenter >= ifp->if_width
	 || ycenter < 0 || ycenter >= ifp->if_height )
		return	-1;
	if( xzoom <= 0 || xzoom >= ifp->if_width/2
	 || yzoom <= 0 || yzoom >= ifp->if_height/2 )
		return	-1;

	ifp->if_xcenter = xcenter;
	ifp->if_ycenter = ycenter;
	ifp->if_xzoom = xzoom;
	ifp->if_yzoom = yzoom;
	/* XXX - repaint */
	repaint(ifp);
	return	0;
}

_LOCAL_ int
X_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom)
{
	*xcenter = ifp->if_xcenter;
	*ycenter = ifp->if_ycenter;
	*xzoom = ifp->if_xzoom;
	*yzoom = ifp->if_yzoom;

	return	0;
}

_LOCAL_ int
X_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig)
{
	return	0;
}

_LOCAL_ int
X_cursor(FBIO *ifp, int mode, int x, int y)
{
	fb_sim_cursor(ifp, mode, x, y);

	/* remap image x,y to screen position */
	x = (x-ifp->if_xcenter)*ifp->if_xzoom+ifp->if_width/2;
	y = (y-ifp->if_ycenter)*ifp->if_yzoom+ifp->if_height/2;

	if( XI(ifp)->curswin == 0 )
		x_make_cursor(ifp);

	y = ifp->if_height - 1 - y;	/* 1st -> 4th quadrant */
	x -= 3;
	y -= 3;
	if( mode ) {
		XMoveWindow( XI(ifp)->dpy, XI(ifp)->curswin, x, y );
		XMapWindow( XI(ifp)->dpy, XI(ifp)->curswin );
	} else {
		XUnmapWindow( XI(ifp)->dpy, XI(ifp)->curswin );
	}
	XFlush( XI(ifp)->dpy );

	return	0;
}

_LOCAL_ int
X_getcursor(FBIO *ifp, int *mode, int *x, int *y)
{
	return fb_sim_getcursor(ifp, mode, x, y);
}

static
int
xsetup(FBIO *ifp, int width, int height)
{
	Display	*dpy;			/* local copy */
	int	screen;			/* local copy */
	Visual	*visual;		/* local copy */
	Window	win;			/* local copy */
	GC	gc;			/* local copy */
	XGCValues gcv;
	XSizeHints	xsh;		/* part of the "standard" props */
	XWMHints	xwmh;		/* size guidelines for window mngr */
	XSetWindowAttributes xswa;

	/* Open the display - use the env variable DISPLAY */
	if( (dpy = XOpenDisplay(NULL)) == NULL ) {
		fb_log( "if_X: Can't open X display \"%s\"\n",
			XDisplayName(NULL) );
		return	-1;
	}
	/* Use the screen we connected to */
	screen = DefaultScreen(dpy);
	/*
	 *  Note: all Windows, Colormaps and XImages have a Visual
	 *  attribute which determines how pixel values are mapped
	 *  to displayed colors.  We should eventually examine which
	 *  choices (if any) the current screen offers and pick a
	 *  "best" one.  For now use the default.  Most servers don't
	 *  offer a choice yet anyway.
	 */
	visual = DefaultVisual(dpy,screen);

	/* save values in state struct */
	XI(ifp)->dpy = dpy;
	XI(ifp)->screen = screen;
	XI(ifp)->visual = visual;
	XI(ifp)->depth = DisplayPlanes(dpy,screen);
	if( DisplayCells(dpy,screen) != 256 )
		XI(ifp)->depth = 1;	/*XXX - until cmap fix */

#if DEBUGX
	x_print_display_info(dpy);
#endif

	/*
	 * Fill in XSetWindowAttributes struct for XCreateWindow.
	 */
	xswa.event_mask = ExposureMask;
		/* |ButtonPressMask |LeaveWindowMask |EnterWindowMask */
		/* |ColormapChangeMask */
	xswa.background_pixel = BlackPixel(dpy, screen);
	xswa.border_pixel = WhitePixel(dpy, screen);
	xswa.bit_gravity = SouthWestGravity;
	xswa.backing_store = Always;
	/* could set colormap here... */
#ifdef CURSORFOO
	xswa.cursor = XCreateFontCursor(dpy, XC_gumby);
#endif

#if DEBUGX
printf("Creating window\n");
#endif
	win = XCreateWindow( dpy, DefaultRootWindow(dpy),
		0, 0, width, height, 3,
		DefaultDepth(dpy, screen), InputOutput, visual,
		CWEventMask |CWBackPixel |CWBorderPixel
		|CWBitGravity | CWBackingStore,
		/* |CWCursor, */
		&xswa );

	XI(ifp)->win = win;
	if( win == 0 ) {
		fb_log( "if_X: Can't create window\n" );
		return	-1;
	}

	/* get or set a colormap for our window */
	if( XI(ifp)->depth == 8 ) {
		x_make_colormap(ifp);
	} else {
		XI(ifp)->cmap = DefaultColormap(dpy,screen);
	}

	/*
	 * Fill in XSizeHints struct to inform window
	 * manager about initial size and location.
	 */
	xsh.flags = PPosition | PSize | PMinSize | PMaxSize;
	xsh.width = xsh.max_width = xsh.min_width = width;
	xsh.height = xsh.max_height = xsh.min_height = height;
	xsh.x = xsh.y = 0;

	/* Set standard properties for Window Managers */
#if DEBUGX
printf("Setting Standard Properties\n");
#endif
	XSetStandardProperties( dpy, win,
		"Frame buffer",		/* window name */
		"Frame buffer",		/* icon name */
		None,			/* icon pixmap */
		NULL, 0,		/* command (argv, argc) */
		&xsh );			/* size hints */
#if DEBUGX
printf("Setting WM Hints\n");
#endif
	xwmh.input = False;		/* no terminal input? */
	xwmh.initial_state = NormalState;
	xwmh.flags = InputHint |StateHint;
	XSetWMHints( dpy, win, &xwmh );

	/* Create a Graphics Context for drawing */
	gcv.foreground = WhitePixel( dpy, screen );
	gcv.background = BlackPixel( dpy, screen );
#if DEBUGX
printf("Making graphics context\n");
#endif
	gc = XCreateGC( dpy, win, (GCForeground|GCBackground), &gcv );
	XI(ifp)->gc = gc;

	XSelectInput( dpy, win, ExposureMask );
	XMapWindow( dpy, win );
	XFlush(dpy);

	while( 1 ) {
		XEvent	event;
		XNextEvent( dpy, &event );
		if( event.type == Expose && event.xexpose.count == 0 ) {
			XWindowAttributes xwa;

			/* remove other exposure events */
			while( XCheckTypedEvent(dpy, Expose, &event) ) ;

			if( XGetWindowAttributes( dpy, win, &xwa ) == 0 )
				break;

			width = xwa.width;
			height = xwa.height;
			break;
		}
	}
	XSelectInput( dpy, win, ExposureMask|ButtonPressMask );

	return	0;
}

static int alive = 1;

static int
linger(FBIO *ifp)
{
	if( fork() != 0 )
		return 1;	/* release the parent */

	XSelectInput( XI(ifp)->dpy, XI(ifp)->win,
		ExposureMask|ButtonPressMask );

	while( alive ) {
		do_event(ifp);
	}
	return 0;
}

static int
do_event(FBIO *ifp)
{
	XEvent	event;
	XExposeEvent	*expose;
	int	button;
	unsigned char *bitbuf = XI(ifp)->bitbuf;
	unsigned char *bytebuf = XI(ifp)->bytebuf;
#if CURSOR
	Cursor	watch = XCreateFontCursor(XI(ifp)->dpy, XC_watch);
#endif

	expose = (XExposeEvent *)&event;


		XNextEvent( XI(ifp)->dpy, &event );
		switch( (int)event.type ) {
		case Expose:
			/*XXXfprintf(stderr,
			"expose event x= %d y= %d width= %d height= %d\n",
			expose->x, expose->y, expose->width, expose->height);*/
			XPutImage(XI(ifp)->dpy, XI(ifp)->win, XI(ifp)->gc, XI(ifp)->image,
				expose->x, expose->y, expose->x, expose->y,
				expose->width, expose->height );
			break;
		case ButtonPress:
			button = (int)event.xbutton.button;
			if( button == Button1 ) {
				/* Check for single button mouse remap.
				 * ctrl-1 => 2
				 * meta-1 => 3
				 */
				if( event.xbutton.state & ControlMask )
					button = Button2;
				else if( event.xbutton.state & Mod1Mask )
					button = Button3;
			}
			switch( button ) {
			case Button1:
				/* monochrome only for now */
				if( XI(ifp)->depth != 1 )
					break;
				/* bump method */
				if( ++(XI(ifp)->method) > 3 )
					XI(ifp)->method = 0;
#if CURSOR
				XDefineCursor(XI(ifp)->dpy, XI(ifp)->win, watch);
				XFlush(XI(ifp)->dpy);
#endif
				Monochrome(bitbuf,bytebuf,ifp->if_width,ifp->if_height,XI(ifp)->method);
#if CURSOR
				XDefineCursor(XI(ifp)->dpy, XI(ifp)->win, None);
				XFlush(XI(ifp)->dpy);
#endif
				XPutImage(XI(ifp)->dpy, XI(ifp)->win, XI(ifp)->gc, XI(ifp)->image,
					0, 0, 0, 0,
					ifp->if_width, ifp->if_height );
				break;
			case Button2:
				{
				int	x, y, sy;
				unsigned char	*cp;
				x = event.xbutton.x;
				sy = event.xbutton.y;
				/* quadrant reverse y */
				y = ifp->if_height - 1 - sy;
				cp = &bytebuf[sy*ifp->if_width + x];
				fb_log("(%4d,%4d) index=%3d ", x, y, *cp);
				if( XI(ifp)->depth == 8 ) {
					/*XXX color_defs may not be allocated here */
					fb_log("rgb=(%3d %3d %3d) ",
						color_defs[*cp].red>>8,
						color_defs[*cp].green>>8,
						color_defs[*cp].blue>>8 );
				}
				if( XI(ifp)->mem ) {
					/* 24bit buffer */
					cp = &(XI(ifp)->mem[(y*ifp->if_width + x)*3]);
					fb_log("Real RGB=(%3d %3d %3d)\n",
						cp[RED], cp[GRN], cp[BLU] );
				} else {
					fb_log("\n");
				}
				}
				break;
			case Button3:
				alive = 0;
				break;
			}
			break;
		default:
			fb_log("Bad X event.\n");
			break;
		}

	return 0;
}

/*
 * Monochrome to Bitmap conversion
 * Convert width x height 8bit grey scale bytes in bytebuf to
 * a bitmap in bitbuf, using the selected "method"
 */
static void
Monochrome(unsigned char *bitbuf, unsigned char *bytebuf, int width, int height, int method)
{
	register unsigned char *mbuffer, mvalue;   /* monochrome bitmap buffer */
	register unsigned char *mpbuffer;          /* monochrome byte buffer */
	register int row, col, bit;
#if 1
	static unsigned char MSB[8] = { 0x80, 0x40, 0x20, 0x10, 8, 4, 2, 1 };
#else
	static unsigned char LSB[8] = { 1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80 };
#endif
	register unsigned char *bits = MSB;	/*XXX - for RT, Sun, etc.  */

	error1 = (int *)malloc((unsigned)(width+1) * sizeof(int));
	error2 = (int *)malloc((unsigned)(width+1) * sizeof(int));

	mpbuffer = bytebuf;
	mbuffer = bitbuf;

	for( row = 0; row < height; row++ ) {
		for( col=0; col < width; ) {
			mvalue = 0x00;
			for( bit=0; (bit < 8) && (col < width); bit++,col++ ) {
				/*if( dither_bw(val, col, row) ) {*/
				if( method == 0 ) {
					if( (int)*mpbuffer > (dm[((row&7)<<3)+(col&7)]<<2)+1 ) {
						mvalue |= bits[bit];
					}
				} else if( method == 1 ) {
					if( fs_bw(*mpbuffer, col, row) ) {
						mvalue |= bits[bit];
					}
				} else if( method == 2 ) {
					if( mfs_bw(*mpbuffer, col, row) ) {
						mvalue |= bits[bit];
					}
				} else if( method == 3 ) {
					if( (int)*mpbuffer > (dm4[(row&3)][(col&3)]<<4)+7 ) {
						mvalue |= bits[bit];
					}
				}
				mpbuffer++;
			}
			*mbuffer++ = mvalue;
		}
	}

	free((char *)error1);
	free((char *)error2);
}

_LOCAL_ int
X_poll(FBIO *ifp)
{
	XFlush( XI(ifp)->dpy );
	while( XPending(XI(ifp)->dpy) > 0 )
		do_event(ifp);

	return(0);
}

_LOCAL_ int
X_flush(FBIO *ifp)
{
	XFlush( XI(ifp)->dpy );
	while( XPending(XI(ifp)->dpy) > 0 )
		do_event(ifp);

	return(0);
}

_LOCAL_ int
X_help(FBIO *ifp)
{
	struct	modeflags *mfp;

	fb_log( "Description: %s\n", X_interface.if_type );
	fb_log( "Device: %s\n", ifp->if_name );
	fb_log( "Max width/height: %d %d\n",
		X_interface.if_max_width,
		X_interface.if_max_height );
	fb_log( "Default width/height: %d %d\n",
		X_interface.if_width,
		X_interface.if_height );
	fb_log( "Usage: /dev/X[options]\n" );
	for( mfp = modeflags; mfp->c != '\0'; mfp++ ) {
		fb_log( "   %c   %s\n", mfp->c, mfp->help );
	}
	return(0);
}

/*
 *	c o n v R G B
 *
 *	convert a single RGBpixel to its corresponding entry in the Sun
 *	colormap.
 */
static unsigned char convRGB(register const unsigned char *v)
{
	register int r, g, b;

	r = (int)( (v)[RED]+26 ) / 51;
	g = (int)( (v)[GRN]+26 ) / 51;
	b = (int)( (v)[BLU]+26 ) / 51;

	/*printf("Pixel r = %d, g = %d, b = %d\n",(v)[RED],(v)[GRN],(v)[BLU]);*/
	if ( r == g )  {
		if( r == b )  {
			/* all grey, take average */
			return greyvec[( ((int)(v)[RED]+(int)(v)[GRN]+(int)(v)[BLU]) / 3 ) /16];
		}
		else if (r == 0)  {
			/* r=g=0, all blue */
			return bluvec[((v)[BLU])/16];
		}
		else	return r + g * 6 + b * 36;
	}
	else if (g == b && g == 0)  {
		/* all red */
		return redvec[((v)[RED])/16];
	}
	else if (r == b && r == 0)  {
		/* all green */
		return grnvec[((v)[GRN])/16];
	}
	else
		return r + g * 6 + b * 36;
}


/*
 *	G E N M A P
 *
 *	initialize the Sun harware colormap
 */
static void genmap(unsigned char *rmap, unsigned char *gmap, unsigned char *bmap)
{
	register int r, g, b;

	/* build the basic color cube */
	for (r=0 ; r < 6 ; r++)
		for (g=0 ; g < 6 ; g ++)
			for (b=0 ; b < 6 ; b++) {
				rmap[r + g * 6 + b * 36] = cubevec[r];
				gmap[r + g * 6 + b * 36] = cubevec[g];
				bmap[r + g * 6 + b * 36] = cubevec[b];
			}

	/* put in the linear sections */
	for (r=216 ; r < 226 ; ++r) {
		rmap[r] = primary[r-216];	/* red */
		gmap[r] = bmap[r] = 0;
	}

	for (g=226 ; g < 236 ; ++g) {
		gmap[g] = primary[g-226];	/* green */
		rmap[g] = bmap[g] = 0;
	}
	
	for (b=236 ; b < 246 ; ++b) {
		bmap[b] = primary[b-236];	/* blue */
		rmap[b] = gmap[b] = 0;
	}

	for (r=246 ; r < 256 ; ++r) {		/* grey */
		rmap[r] = gmap[r] = 
		bmap[r] = primary[r-246];
	}
}

static int
x_make_colormap(FBIO *ifp)
{
	int 		tot_levels;
	int 		i;
	Colormap	color_map;
	int		tmp;
	long		b, w;	/* server black and white pixels */

	tot_levels = 256;

#if DEBUGX
	printf("make_colormap\n");
#endif
#ifdef notes
        colormap = GetColormap(colors, ncolors, &newmap_flag,
		buffer, buffer_size);
#endif

	genmap(redmap, grnmap, blumap); /* generate hardware color_map */

	color_defs = (XColor *) malloc (256 * sizeof (XColor) );
	x_pixel_table = (unsigned long *)
			malloc( tot_levels * sizeof( unsigned long) );

	color_map = XCreateColormap( XI(ifp)->dpy, 
		XI(ifp)->win, XI(ifp)->visual, AllocNone);

	if( color_map == (Colormap)NULL)
		fprintf(stderr,"Warning: color map missing\n");

	XI(ifp)->cmap = color_map;

	/* Allocate the colors cells */
	if( (XAllocColorCells( XI(ifp)->dpy, color_map, 0, NULL, 0,
	      x_pixel_table, tot_levels )) == 0) {
		fprintf(stderr,"XAllocColorCells died\n");
	}

	/* XXX - HACK
	 * Swap our white entry to 0, and our back entry to 1.
	 * Fix x_pixel_table[] to remap them.  This is to allow
	 * monochrome windows to still be readable while this colormap
	 * is loaded.
	 */
	b = BlackPixel(XI(ifp)->dpy, XI(ifp)->screen);
	w = WhitePixel(XI(ifp)->dpy, XI(ifp)->screen);

	tmp = x_pixel_table[215];		/* save 215 (our white) */
	x_pixel_table[215] = x_pixel_table[w];	/* move our White to w */
	x_pixel_table[w] = tmp;			/* and orig w to 215 */

	tmp = x_pixel_table[0];			/* save 0 (our black) */
	x_pixel_table[0] = x_pixel_table[b];	/* move our Black to b */
	x_pixel_table[b] = tmp;			/* and orig b to 0 */

	/* put our colors into those cells */
	for (i = 0; i < tot_levels; i++) {
        	color_defs[i].pixel = x_pixel_table[i];
	        color_defs[i].red   = redmap[i]<<8;
	        color_defs[i].green = grnmap[i]<<8;
	        color_defs[i].blue  = blumap[i]<<8;
	        color_defs[i].flags = DoRed | DoGreen | DoBlue;
	}
	XStoreColors ( XI(ifp)->dpy, color_map, color_defs, tot_levels);

	/* assign this colormap to our window */
	XSetWindowColormap( XI(ifp)->dpy, XI(ifp)->win, XI(ifp)->cmap);

	/* If you are real anti-social, install it.
	 * This should be left to the window managers though. */
	/* XInstallColormap( XI(ifp)->dpy, color_map ); */
	if( (XI(ifp)->mode&MODE_5MASK) == MODE_5INSTCMAP ) {
		XInstallColormap( XI(ifp)->dpy, color_map );
	}
	return 0;
}

static int
x_make_cursor(FBIO *ifp)
{
	XSetWindowAttributes	xswa;

	xswa.save_under = True;
	XI(ifp)->curswin = XCreateWindow( XI(ifp)->dpy, XI(ifp)->win,
		ifp->if_xcenter, ifp->if_ycenter, 1, 1, 3,
		CopyFromParent, InputOutput, CopyFromParent,
		CWSaveUnder, &xswa );
	return 0;
}

/*
 *  A given Display (i.e. Server) can have any number of Screens.
 *  Each Screen can support one or more Visual types.
 *  unix:0.1.2 => host:display.screen.visual
 *  Typically the screen and visual default to 0 by being omitted.
 */
void
x_print_display_info(Display *dpy)
{
	int	i;
	int	screen;
	Visual	*visual;
	XVisualInfo *vp;
	int	num;
	Window	win = DefaultRootWindow(dpy);
	XStandardColormap cmap;

	printf("Server \"%s\", release %d\n",
		ServerVendor(dpy), VendorRelease(dpy) );

	/* How many screens? */
	screen = DefaultScreen(dpy);
	printf("%d Screen(s), we connected to screen %d\n",
		ScreenCount(dpy), screen );

	/* How many visuals? */
	vp = XGetVisualInfo(dpy, VisualNoMask, NULL, &num );
	XFree( (char *)vp );
	printf("%d Visual(s)\n", num);
	printf("ImageByteOrder: %s\n",
		ImageByteOrder(dpy) == MSBFirst ? "MSBFirst" : "LSBFirst");
	printf("BitmapBitOrder: %s\n",
		BitmapBitOrder(dpy) == MSBFirst ? "MSBFirst" : "LSBFirst");
	printf("BitmapUnit: %d\n", BitmapUnit(dpy));
	printf("BitmapPad: %d\n", BitmapPad(dpy));

	printf("==== Screen %d ====\n", screen );
	printf("%d x %d pixels, %d x %d mm, (%.2f x %.2f dpi)\n",
		DisplayWidth(dpy,screen), DisplayHeight(dpy,screen),
		DisplayWidthMM(dpy,screen), DisplayHeightMM(dpy,screen),
		DisplayWidth(dpy,screen)*25.4/DisplayWidthMM(dpy,screen),
		DisplayHeight(dpy,screen)*25.4/DisplayHeightMM(dpy,screen));
	printf("%d DisplayPlanes (other Visuals, if any, may vary)\n",
		DisplayPlanes(dpy,screen) );
	printf("%d DisplayCells\n", DisplayCells(dpy,screen) );
	printf("BlackPixel = %lu\n", BlackPixel(dpy,screen) );
	printf("WhitePixel = %lu\n", WhitePixel(dpy,screen) );
	printf("Save Unders: %s\n",
		DoesSaveUnders(ScreenOfDisplay(dpy,screen)) ? "True" : "False");
	i = DoesBackingStore(ScreenOfDisplay(dpy,screen));
	printf("Backing Store: %s\n", i == WhenMapped ? "WhenMapped" :
		(i == Always ? "Always" : "NotUseful"));
	printf("Installed Colormaps: min %d, max %d\n",
		MinCmapsOfScreen(ScreenOfDisplay(dpy,screen)),
		MaxCmapsOfScreen(ScreenOfDisplay(dpy,screen)) );
	printf("DefaultColormap: 0lx%lx\n", DefaultColormap(dpy,screen));

	visual = DefaultVisual(dpy,screen);
	printf("---- Visual 0x%lx ----\n", (unsigned long int)visual );

	switch(visual->class) {
	case DirectColor:
		printf("DirectColor: Alterable RGB maps, pixel RGB subfield indicies\n");
		printf("RGB Masks: 0x%lx 0x%lx 0x%lx\n", visual->red_mask,
			visual->green_mask, visual->blue_mask);
		break;
	case TrueColor:
		printf("TrueColor: Fixed RGB maps, pixel RGB subfield indicies\n");
		printf("RGB Masks: 0x%lx 0x%lx 0x%lx\n", visual->red_mask,
			visual->green_mask, visual->blue_mask);
		break;
	case PseudoColor:
		printf("PseudoColor: Alterable RGB maps, single index\n");
		break;
	case StaticColor:
		printf("StaticColor: Fixed RGB maps, single index\n");
		break;
	case GrayScale:
		printf("GrayScale: Alterable map (R=G=B), single index\n");
		break;
	case StaticGray:
		printf("StaticGray: Fixed map (R=G=B), single index\n");
		break;
	default:
		printf("Unknown visual class %d\n",
			visual->class);
		break;
	}
	printf("Map Entries: %d\n", visual->map_entries);
	printf("Bits per RGB: %d\n", visual->bits_per_rgb);

	printf("==== Standard Colormaps ====\n");
	if( XGetStandardColormap( dpy, win, &cmap, XA_RGB_BEST_MAP ) ) {
		printf( "XA_RGB_BEST_MAP    - Yes (0x%lx)\n", cmap.colormap);
		printf( "R[0..%lu] * %lu + G[0..%lu] * %lu  + B[0..%lu] * %lu + %lu\n",
			cmap.red_max, cmap.red_mult, cmap.green_max, cmap.green_mult,
			cmap.blue_max, cmap.blue_mult, cmap.base_pixel);
	} else
		printf( "XA_RGB_BEST_MAP    - No\n" );
	if( XGetStandardColormap( dpy, win, &cmap, XA_RGB_DEFAULT_MAP ) ) {
		printf( "XA_RGB_DEFAULT_MAP - Yes (0x%lx)\n", cmap.colormap );
		printf( "R[0..%lu] * %lu + G[0..%lu] * %lu  + B[0..%lu] * %lu + %lu\n",
			cmap.red_max, cmap.red_mult, cmap.green_max, cmap.green_mult,
			cmap.blue_max, cmap.blue_mult, cmap.base_pixel);
	} else
		printf( "XA_RGB_DEFAULT_MAP - No\n" );
	if( XGetStandardColormap( dpy, win, &cmap, XA_RGB_GRAY_MAP ) ) {
		printf( "XA_RGB_GRAY_MAP    - Yes (0x%lx)\n", cmap.colormap );
		printf( "R[0..%lu] * %lu + %lu\n",
			cmap.red_max, cmap.red_mult, cmap.base_pixel);
	} else
		printf( "XA_RGB_GRAY_MAP    - No\n" );
}

/* Repaint.
 * Zooming an image can also be viewed as shrinking our "window" of
 * currently displayed data.  We then drop that window down over the
 * selected "center" position and check to see if it overhangs the
 * image edges.  We want to clear out any overhanging regions and then
 * display the (sub)rectangle of image data that falls in the window.
 *
 * We do all of our computation here in the first quadrant form and
 * only switch to fourth for Xlib commands.
 */
static void
repaint(FBIO *ifp)
{
	/* 1st and last image pixel coordinates *within* the window */
	int	xmin, xmax;
	int	ymin, ymax;
	/* screen pixel coordinates corresponding to above */
	int	sleft, sright;
	int	sbottom, stop;
	/* window height, width, and center */
	struct	{
		int	width;
		int	height;
		int	xcenter;
		int	ycenter;
	} w;

	/*
	 * Eventually the window size shouldn't be bound to
	 * the image size.  We are thinking ahead here.
	 */
	w.width = ifp->if_width;
	w.height = ifp->if_height;
	w.xcenter = w.width / 2;
	w.ycenter = w.height / 2;

	/*
	 * Compute which image pixels WOULD fall at the left, right,
	 * bottom, and top of the window if the image were unbounded.
	 */
	xmin = ifp->if_xcenter - w.width/(2*ifp->if_xzoom);
	xmax = ifp->if_xcenter + w.width/(2*ifp->if_xzoom) - 1;
	ymin = ifp->if_ycenter - w.height/(2*ifp->if_yzoom);
	ymax = ifp->if_ycenter + w.height/(2*ifp->if_yzoom) - 1;

	/*
	 * Clip these against the actual image dimensions.
	 */
	if( xmin < 0 )
		xmin = 0;
	if( xmax > ifp->if_width-1 )
		xmax = ifp->if_width-1;
	if( ymin < 0 )
		ymin = 0;
	if( ymax > ifp->if_height-1 )
		ymax = ifp->if_height-1;

	/*
	 * Compute the window pixel location corresponding to
	 * the included image data.
	 */
	sleft = (xmin - ifp->if_xcenter) * ifp->if_xzoom + w.width/2;
	sright = ((xmax+1) - ifp->if_xcenter) * ifp->if_xzoom + w.width/2 - 1;
	sbottom = (ymin - ifp->if_ycenter) * ifp->if_yzoom + w.height/2;
	stop = ((ymax+1) - ifp->if_ycenter) * ifp->if_yzoom + w.height/2 - 1;

	/*
	 * if(sleft || sbottom || sright != w.width-1 || stop != w.height-1)
	 *  then the image rectangle does not completely fill the screen
	 *  window rectangle.  I tried clearing the entire window first
	 *  and then repainting the image part, but this produced a nasty
	 *  flashing of the screen.  It is debatable whether we should clear
	 *  the borders before or after painting.  Ultimately it would be
	 *  nice if we could optimize with an in server XCopyArea bitblit
	 *  for the part of the image already displayed (if any).
	 */
	/*
	printf("window(%3d,%3d) zoom(%3d,%3d)\n\r",
		ifp->if_xcenter, ifp->if_ycenter,
		ifp->if_xzoom, ifp->if_yzoom);
	printf("Image ([%3d %3d],[%3d %3d]) Screen ([%3d %3d],[%3d %3d])\n\r",
		xmin, xmax, ymin, ymax, sleft, sright, sbottom, stop);
	*/

	/* Display our image rectangle */
	if( (ifp->if_xzoom == 1) && (ifp->if_yzoom == 1 ) ) {
		/* Note quadrant reversal */
		XPutImage(XI(ifp)->dpy, XI(ifp)->win, XI(ifp)->gc,
			XI(ifp)->image,
			xmin, w.width-1-ymax,
			sleft, w.height-1-stop,
			xmax-xmin+1, ymax-ymin+1 );
	} else {
		slowrect( ifp, xmin, xmax, ymin, ymax );
	}

	/* Clear any empty borders */
	if( sleft != 0 )
		XClearArea( XI(ifp)->dpy, XI(ifp)->win,
			0, 0,
			sleft, w.height,
			False);
	if( sright != w.width-1 )
		XClearArea( XI(ifp)->dpy, XI(ifp)->win,
			sright+1, 0,
			w.width-1-sright, w.height,
			False);
	/* could optimize bottom and top to clip sleft to sright */
	if( sbottom != 0 )
		XClearArea( XI(ifp)->dpy, XI(ifp)->win,
			0, w.height-sbottom,  /* (height-1)-(bottom-1) */
			w.width, sbottom,
			False);
	if( stop != w.height-1 )
		XClearArea( XI(ifp)->dpy, XI(ifp)->win,
			0, 0,
			w.width, w.height-1-stop,
			False);

	XFlush( XI(ifp)->dpy );
}

/*
 * Note: these return the "lower left corner" of a zoomed pixel
 */
#define	xIMG2SCR(x)	(((x)-ifp->if_xcenter)*ifp->if_xzoom+w.width/2)
#define	yIMG2SCR(y)	(((y)-ifp->if_ycenter)*ifp->if_yzoom+w.height/2)

/*
 * Repaint a (pre clipped) rectangle from the image onto the screen.
 */
static void
slowrect(FBIO *ifp, int xmin, int xmax, int ymin, int ymax)
          
               	/* image bounds */
               
{
	int	sxmin;		/* screen versions of above */
	int	symin;
	int	xlen, ylen;	/* number of image pixels in x,y */
	int	sxlen, sylen;	/* screen pixels in x,y */
	int	ix, iy;		/* image x, y */
	int	sy;		/* screen x, y */
	int	x, y;		/* dummys */
	/* window height, width, and center */
	struct	{
		int	width;
		int	height;
		int	xcenter;
		int	ycenter;
	} w;
	/*XXX-HACK VERSION-Depend on 24bit memory buffer and use scanwrite! */
	RGBpixel scanbuf[1024];
	RGBpixel *pp;
	if( XI(ifp)->mem == NULL )
		return;

	/*
	 * Eventually the window size shouldn't be bound to
	 * the image size.  We are thinking ahead here.
	 */
	w.width = ifp->if_width;
	w.height = ifp->if_height;
	w.xcenter = w.width / 2;
	w.ycenter = w.height / 2;

	xlen = xmax - xmin + 1;
	ylen = ymax - ymin + 1;
	sxlen = xlen * ifp->if_xzoom;
	sylen = ylen * ifp->if_yzoom;

	sxmin = xIMG2SCR(xmin);
	symin = yIMG2SCR(ymin);

	for( y = 0; y < sylen; y++ ) {
		sy = symin + y;
		iy = ymin + y/ifp->if_yzoom; 
		for( x = 0; x < sxlen; x++ ) {
			ix = xmin + x/ifp->if_xzoom;
#if 0
			sx = sxmin + x;
			printf("S(%3d,%3d) <- I(%3d,%3d)\n", sx, sy, ix, iy);
#endif
			pp = (RGBpixel *)&(XI(ifp)->mem[(iy*ifp->if_width+ix)*3]);
			scanbuf[x][RED] = (*pp)[RED];
			scanbuf[x][GRN] = (*pp)[GRN];
			scanbuf[x][BLU] = (*pp)[BLU];
		}
		/*printf("Write Scan %d pixels @@ S(%d,%d)\n", sxlen, sxmin, sy);*/
		X_scanwrite( ifp, sxmin, sy, &scanbuf[0][0], sxlen, 0 );
	}
}
@


11.14
log
@change conf.h to a wrapped config.h
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/libfb/if_X.c,v 11.13 2004/04/05 07:44:42 morrison Exp $ (BRL)";
@


11.13
log
@merge of ansi-6-0-branch into HEAD
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d24 5
a28 1
#include "conf.h"
@


11.12
log
@update copyright to include span through 2003
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X.c,v 11.11 2002/08/20 17:07:46 jra Exp $ (BRL)";
d56 7
a62 7
static	void	slowrect();
static	int	linger();
static	int	xsetup();
void		x_print_display_info();
static	int	x_make_colormap();	/*XXX*/
static	int	x_make_cursor();	/*XXX*/
static void	repaint();
d66 1
a66 1
_LOCAL_ int	X_scanwrite();
d68 15
a82 15
_LOCAL_ int	X_open(),
		X_close(),
		X_clear(),
		X_read(),
		X_write(),
		X_rmap(),
		X_wmap(),
		X_view(),
		X_getview(),
		X_setcursor(),
		X_cursor(),
		X_getcursor(),
		X_poll(),
		X_flush(),
		X_help();
d241 1
a241 1
static unsigned char convRGB();
d246 1
a246 4
X_open( ifp, file, width, height )
FBIO	*ifp;
char	*file;
int	width, height;
d412 1
a412 2
X_close( ifp )
FBIO	*ifp;
d427 1
a427 3
X_clear( ifp, pp )
FBIO	*ifp;
unsigned char	*pp;
d466 1
a466 5
X_read( ifp, x, y, pixelp, count )
FBIO	*ifp;
int	x, y;
unsigned char	*pixelp;
int	count;
d518 1
a518 3
int dither_bw(pixel,count,line)
unsigned int pixel;
register int count, line;
d531 1
a531 3
fs_bw(pixel, count, line)
unsigned int pixel;
register int count, line;
d563 1
a563 3
mfs_bw(pixel,count,line)
unsigned int pixel;
register int count, line;
d597 1
a597 5
X_write( ifp, x, y, pixelp, count )
FBIO	*ifp;
int	x, y;
const unsigned char	*pixelp;
int	count;
d642 1
a642 6
X_scanwrite( ifp, x, y, pixelp, count, save )
FBIO	*ifp;
int	x, y;
const unsigned char	*pixelp;
int	count;
int	save;
d769 1
a769 3
X_rmap( ifp, cmp )
FBIO	*ifp;
ColorMap	*cmp;
d776 1
a776 3
X_wmap( ifp, cmp )
FBIO	*ifp;
const ColorMap	*cmp;
d825 1
a825 4
X_view( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	xcenter, ycenter;
int	xzoom, yzoom;
d850 1
a850 4
X_getview( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	*xcenter, *ycenter;
int	*xzoom, *yzoom;
d861 1
a861 5
X_setcursor( ifp, bits, xbits, ybits, xorig, yorig )
FBIO	*ifp;
const unsigned char *bits;
int	xbits, ybits;
int	xorig, yorig;
d867 1
a867 4
X_cursor( ifp, mode, x, y )
FBIO	*ifp;
int	mode;
int	x, y;
d893 1
a893 4
X_getcursor( ifp, mode, x, y )
FBIO	*ifp;
int	*mode;
int	*x, *y;
d900 1
a900 3
xsetup( ifp, width, height )
FBIO	*ifp;
int	width, height;
d1046 1
a1046 2
linger( ifp )
FBIO	*ifp;
d1061 1
a1061 2
do_event( ifp )
FBIO	*ifp;
d1164 1
a1164 5
Monochrome(bitbuf,bytebuf,width,height,method)
unsigned char *bitbuf;
unsigned char *bytebuf;
int width, height;
int method;
d1215 1
a1215 2
X_poll( ifp )
FBIO	*ifp;
d1225 1
a1225 2
X_flush( ifp )
FBIO	*ifp;
d1235 1
a1235 2
X_help( ifp )
FBIO	*ifp;
d1260 1
a1260 2
static unsigned char convRGB(v)
register unsigned char *v;
d1298 1
a1298 2
static void genmap(rmap, gmap, bmap)
unsigned char rmap[], gmap[], bmap[];
d1334 1
a1334 2
x_make_colormap(ifp)
FBIO *ifp;
d1412 1
a1412 2
x_make_cursor(ifp)
FBIO *ifp;
d1431 1
a1431 2
x_print_display_info( dpy )
Display *dpy;
d1549 1
a1549 2
repaint(ifp)
FBIO	*ifp;
d1670 4
a1673 4
slowrect( ifp, xmin, xmax, ymin, ymax )
FBIO *ifp;
int xmin, xmax;	/* image bounds */
int ymin, ymax;
@


11.11
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1988 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X.c,v 11.9 2001/04/20 22:29:13 morrison Exp $ (BRL)";
@


11.11.4.1
log
@sync to HEAD...
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libfb/if_X.c,v 11.12 2004/02/02 17:39:12 morrison Exp $ (BRL)";
@


11.11.10.1
log
@merge from HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X.c,v 11.12 2004/02/02 17:39:12 morrison Exp $ (BRL)";
@


11.11.10.2
log
@merge from head
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X.c,v 11.11.10.1 2004/02/12 19:48:12 erikg Exp $ (BRL)";
@


11.11.2.1
log
@Initial ANSIfication
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X.c,v 11.11 2002/08/20 17:07:46 jra Exp $ (BRL)";
d56 7
a62 7
static	void	slowrect(FBIO *ifp, int xmin, int xmax, int ymin, int ymax);
static	int	linger(FBIO *ifp);
static	int	xsetup(FBIO *ifp, int width, int height);
void		x_print_display_info(Display *dpy);
static	int	x_make_colormap(FBIO *ifp);	/*XXX*/
static	int	x_make_cursor(FBIO *ifp);	/*XXX*/
static void	repaint(FBIO *ifp);
d66 1
a66 1
_LOCAL_ int	X_scanwrite(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count, int save);
d68 15
a82 15
_LOCAL_ int	X_open(FBIO *ifp, char *file, int width, int height),
		X_close(FBIO *ifp),
		X_clear(FBIO *ifp, unsigned char *pp),
		X_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count),
		X_write(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count),
		X_rmap(FBIO *ifp, ColorMap *cmp),
		X_wmap(FBIO *ifp, const ColorMap *cmp),
		X_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
		X_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom),
		X_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig),
		X_cursor(FBIO *ifp, int mode, int x, int y),
		X_getcursor(FBIO *ifp, int *mode, int *x, int *y),
		X_poll(FBIO *ifp),
		X_flush(FBIO *ifp),
		X_help(FBIO *ifp);
d241 1
a241 1
static unsigned char convRGB(register const unsigned char *v);
d246 4
a249 1
X_open(FBIO *ifp, char *file, int width, int height)
d415 2
a416 1
X_close(FBIO *ifp)
d431 3
a433 1
X_clear(FBIO *ifp, unsigned char *pp)
d472 5
a476 1
X_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count)
d528 3
a530 1
int dither_bw(unsigned int pixel, register int count, register int line)
d543 3
a545 1
fs_bw(unsigned int pixel, register int count, register int line)
d577 3
a579 1
mfs_bw(unsigned int pixel, register int count, register int line)
d613 5
a617 1
X_write(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count)
d662 6
a667 1
X_scanwrite(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count, int save)
d794 3
a796 1
X_rmap(FBIO *ifp, ColorMap *cmp)
d803 3
a805 1
X_wmap(FBIO *ifp, const ColorMap *cmp)
d854 4
a857 1
X_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
d882 4
a885 1
X_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom)
d896 5
a900 1
X_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig)
d906 4
a909 1
X_cursor(FBIO *ifp, int mode, int x, int y)
d935 4
a938 1
X_getcursor(FBIO *ifp, int *mode, int *x, int *y)
d945 3
a947 1
xsetup(FBIO *ifp, int width, int height)
d1093 2
a1094 1
linger(FBIO *ifp)
d1109 2
a1110 1
do_event(FBIO *ifp)
d1213 5
a1217 1
Monochrome(unsigned char *bitbuf, unsigned char *bytebuf, int width, int height, int method)
d1268 2
a1269 1
X_poll(FBIO *ifp)
d1279 2
a1280 1
X_flush(FBIO *ifp)
d1290 2
a1291 1
X_help(FBIO *ifp)
d1316 2
a1317 1
static unsigned char convRGB(register const unsigned char *v)
d1355 2
a1356 1
static void genmap(unsigned char *rmap, unsigned char *gmap, unsigned char *bmap)
d1392 2
a1393 1
x_make_colormap(FBIO *ifp)
d1471 2
a1472 1
x_make_cursor(FBIO *ifp)
d1491 2
a1492 1
x_print_display_info(Display *dpy)
d1610 2
a1611 1
repaint(FBIO *ifp)
d1732 4
a1735 4
slowrect(FBIO *ifp, int xmin, int xmax, int ymin, int ymax)
          
               	/* image bounds */
               
@


11.11.2.2
log
@sync branch with HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.10
log
@Converted from K&R to ANSI C - RFH
@
text
@d56 7
a62 7
static	void	slowrect(FBIO *ifp, int xmin, int xmax, int ymin, int ymax);
static	int	linger(FBIO *ifp);
static	int	xsetup(FBIO *ifp, int width, int height);
void		x_print_display_info(Display *dpy);
static	int	x_make_colormap(FBIO *ifp);	/*XXX*/
static	int	x_make_cursor(FBIO *ifp);	/*XXX*/
static void	repaint(FBIO *ifp);
d66 1
a66 1
_LOCAL_ int	X_scanwrite(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count, int save);
d68 15
a82 15
_LOCAL_ int	X_open(FBIO *ifp, char *file, int width, int height),
		X_close(FBIO *ifp),
		X_clear(FBIO *ifp, unsigned char *pp),
		X_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count),
		X_write(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count),
		X_rmap(FBIO *ifp, ColorMap *cmp),
		X_wmap(FBIO *ifp, const ColorMap *cmp),
		X_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
		X_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom),
		X_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig),
		X_cursor(FBIO *ifp, int mode, int x, int y),
		X_getcursor(FBIO *ifp, int *mode, int *x, int *y),
		X_poll(FBIO *ifp),
		X_flush(FBIO *ifp),
		X_help(FBIO *ifp);
d241 1
a241 1
static unsigned char convRGB(register const unsigned char *v);
d246 4
a249 1
X_open(FBIO *ifp, char *file, int width, int height)
d415 2
a416 1
X_close(FBIO *ifp)
d431 3
a433 1
X_clear(FBIO *ifp, unsigned char *pp)
d472 5
a476 1
X_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count)
d528 3
a530 1
int dither_bw(unsigned int pixel, register int count, register int line)
d543 3
a545 1
fs_bw(unsigned int pixel, register int count, register int line)
d577 3
a579 1
mfs_bw(unsigned int pixel, register int count, register int line)
d613 5
a617 1
X_write(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count)
d662 6
a667 1
X_scanwrite(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count, int save)
d794 3
a796 1
X_rmap(FBIO *ifp, ColorMap *cmp)
d803 3
a805 1
X_wmap(FBIO *ifp, const ColorMap *cmp)
d854 4
a857 1
X_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
d882 4
a885 1
X_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom)
d896 5
a900 1
X_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig)
d906 4
a909 1
X_cursor(FBIO *ifp, int mode, int x, int y)
d935 4
a938 1
X_getcursor(FBIO *ifp, int *mode, int *x, int *y)
d945 3
a947 1
xsetup(FBIO *ifp, int width, int height)
d1093 2
a1094 1
linger(FBIO *ifp)
d1109 2
a1110 1
do_event(FBIO *ifp)
d1213 5
a1217 1
Monochrome(unsigned char *bitbuf, unsigned char *bytebuf, int width, int height, int method)
d1268 2
a1269 1
X_poll(FBIO *ifp)
d1279 2
a1280 1
X_flush(FBIO *ifp)
d1290 2
a1291 1
X_help(FBIO *ifp)
d1316 2
a1317 1
static unsigned char convRGB(register const unsigned char *v)
d1355 2
a1356 1
static void genmap(unsigned char *rmap, unsigned char *gmap, unsigned char *bmap)
d1392 2
a1393 1
x_make_colormap(FBIO *ifp)
d1471 2
a1472 1
x_make_cursor(FBIO *ifp)
d1491 2
a1492 1
x_print_display_info(Display *dpy)
d1610 2
a1611 1
repaint(FBIO *ifp)
d1732 4
a1735 4
slowrect(FBIO *ifp, int xmin, int xmax, int ymin, int ymax)
          
               	/* image bounds */
               
@


11.9
log
@CONST to const
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X.c,v 11.8 2000/07/25 17:49:50 butler Exp $ (BRL)";
d56 7
a62 7
static	void	slowrect();
static	int	linger();
static	int	xsetup();
void		x_print_display_info();
static	int	x_make_colormap();	/*XXX*/
static	int	x_make_cursor();	/*XXX*/
static void	repaint();
d66 1
a66 1
_LOCAL_ int	X_scanwrite();
d68 15
a82 15
_LOCAL_ int	X_open(),
		X_close(),
		X_clear(),
		X_read(),
		X_write(),
		X_rmap(),
		X_wmap(),
		X_view(),
		X_getview(),
		X_setcursor(),
		X_cursor(),
		X_getcursor(),
		X_poll(),
		X_flush(),
		X_help();
d241 1
a241 1
static unsigned char convRGB();
d246 1
a246 4
X_open( ifp, file, width, height )
FBIO	*ifp;
char	*file;
int	width, height;
d412 1
a412 2
X_close( ifp )
FBIO	*ifp;
d427 1
a427 3
X_clear( ifp, pp )
FBIO	*ifp;
unsigned char	*pp;
d466 1
a466 5
X_read( ifp, x, y, pixelp, count )
FBIO	*ifp;
int	x, y;
unsigned char	*pixelp;
int	count;
d518 1
a518 3
int dither_bw(pixel,count,line)
unsigned int pixel;
register int count, line;
d531 1
a531 3
fs_bw(pixel, count, line)
unsigned int pixel;
register int count, line;
d563 1
a563 3
mfs_bw(pixel,count,line)
unsigned int pixel;
register int count, line;
d597 1
a597 5
X_write( ifp, x, y, pixelp, count )
FBIO	*ifp;
int	x, y;
const unsigned char	*pixelp;
int	count;
d642 1
a642 6
X_scanwrite( ifp, x, y, pixelp, count, save )
FBIO	*ifp;
int	x, y;
const unsigned char	*pixelp;
int	count;
int	save;
d769 1
a769 3
X_rmap( ifp, cmp )
FBIO	*ifp;
ColorMap	*cmp;
d776 1
a776 3
X_wmap( ifp, cmp )
FBIO	*ifp;
const ColorMap	*cmp;
d825 1
a825 4
X_view( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	xcenter, ycenter;
int	xzoom, yzoom;
d850 1
a850 4
X_getview( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	*xcenter, *ycenter;
int	*xzoom, *yzoom;
d861 1
a861 5
X_setcursor( ifp, bits, xbits, ybits, xorig, yorig )
FBIO	*ifp;
const unsigned char *bits;
int	xbits, ybits;
int	xorig, yorig;
d867 1
a867 4
X_cursor( ifp, mode, x, y )
FBIO	*ifp;
int	mode;
int	x, y;
d893 1
a893 4
X_getcursor( ifp, mode, x, y )
FBIO	*ifp;
int	*mode;
int	*x, *y;
d900 1
a900 3
xsetup( ifp, width, height )
FBIO	*ifp;
int	width, height;
d1046 1
a1046 2
linger( ifp )
FBIO	*ifp;
d1061 1
a1061 2
do_event( ifp )
FBIO	*ifp;
d1164 1
a1164 5
Monochrome(bitbuf,bytebuf,width,height,method)
unsigned char *bitbuf;
unsigned char *bytebuf;
int width, height;
int method;
d1215 1
a1215 2
X_poll( ifp )
FBIO	*ifp;
d1225 1
a1225 2
X_flush( ifp )
FBIO	*ifp;
d1235 1
a1235 2
X_help( ifp )
FBIO	*ifp;
d1260 1
a1260 2
static unsigned char convRGB(v)
register unsigned char *v;
d1298 1
a1298 2
static void genmap(rmap, gmap, bmap)
unsigned char rmap[], gmap[], bmap[];
d1334 1
a1334 2
x_make_colormap(ifp)
FBIO *ifp;
d1412 1
a1412 2
x_make_cursor(ifp)
FBIO *ifp;
d1431 1
a1431 2
x_print_display_info( dpy )
Display *dpy;
d1549 1
a1549 2
repaint(ifp)
FBIO	*ifp;
d1670 4
a1673 4
slowrect( ifp, xmin, xmax, ymin, ymax )
FBIO *ifp;
int xmin, xmax;	/* image bounds */
int ymin, ymax;
@


11.8
log
@Added include of unistd.h to get warning-free compile
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X.c,v 11.7 2000/07/24 22:29:11 mike Exp $ (BRL)";
d616 1
a616 1
CONST unsigned char	*pixelp;
d665 1
a665 1
CONST unsigned char	*pixelp;
d805 1
a805 1
CONST ColorMap	*cmp;
d898 1
a898 1
CONST unsigned char *bits;
@


11.7
log
@
Fixed typo in #include directive.
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X.c,v 11.6 2000/07/12 01:33:30 cjohnson Exp $ (BRL)";
d27 1
@


11.6
log
@LINT from gcc -Wall.  Including some mods to h/pkg.h
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X.c,v 11.5 1998/09/14 15:59:15 bparker Exp $ (BRL)";
d30 1
a30 1
#include <string.h>
d32 1
a32 1
#inlcude <strings.h>
@


11.5
log
@*- fix typos
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X.c,v 11.4 1998/06/27 04:29:15 mike Exp $ (BRL)";
d28 6
d508 4
a511 4
	 0,  8,  2, 10,
	12,  4, 14,  6,
	 3, 11,  1,  9,
	15,  7, 13,  5
d514 8
a521 8
	 0, 32,  8, 40,  2, 34, 10, 42,
	48, 16, 56, 24, 50, 18, 58, 26,
	12, 44,  4, 36, 14, 46,  6, 38,
	60, 28, 52, 20, 62, 30, 54, 22,
	 3, 35, 11, 43,  1, 33,  9, 41,
	51, 19, 59, 27, 49, 17, 57, 25,
	15, 47,  7, 39, 13, 45,  5, 37,
	63, 31, 55, 23, 61, 29, 53, 21
d943 1
d1542 1
a1542 1
	printf("---- Visual 0x%lx ----\n", visual );
@


11.4
log
@Additions to LIBFB interface and remote framebuffer protocol to
read and write monochrome rectangles.
Particularly important for sending thermal images at high speed.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X.c,v 11.3 1996/08/27 06:23:55 mike Exp $ (BRL)";
d1522 2
a1523 2
	printf("BlackPixel = %d\n", BlackPixel(dpy,screen) );
	printf("WhitePixel = %d\n", WhitePixel(dpy,screen) );
d1532 1
a1532 1
	printf("DefaultColormap: 0x%x\n", DefaultColormap(dpy,screen));
d1535 1
a1535 1
	printf("---- Visual 0x%x ----\n", visual );
d1540 1
a1540 1
		printf("RGB Masks: 0x%x 0x%x 0x%x\n", visual->red_mask,
d1545 1
a1545 1
		printf("RGB Masks: 0x%x 0x%x 0x%x\n", visual->red_mask,
d1570 2
a1571 2
		printf( "XA_RGB_BEST_MAP    - Yes (0x%x)\n", cmap.colormap);
		printf( "R[0..%d] * %d + G[0..%d] * %d  + B[0..%d] * %d + %d\n",
d1577 2
a1578 2
		printf( "XA_RGB_DEFAULT_MAP - Yes (0x%x)\n", cmap.colormap );
		printf( "R[0..%d] * %d + G[0..%d] * %d  + B[0..%d] * %d + %d\n",
d1584 2
a1585 2
		printf( "XA_RGB_GRAY_MAP    - Yes (0x%x)\n", cmap.colormap );
		printf( "R[0..%d] * %d + %d\n",
@


11.3
log
@SunOS 4.1.4 declaration prob
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X.c,v 11.2 1996/07/10 15:25:43 jra Exp mike $ (BRL)";
d102 2
@


11.2
log
@fixed some declarations.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X.c,v 11.1 1995/01/04 09:52:41 mike Rel4_4 jra $ (BRL)";
d1202 1
a1202 1
void
d1599 1
a1599 1
void
@


11.1
log
@Release_4.4
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X.c,v 10.14 94/12/30 03:57:25 mike Exp $ (BRL)";
d55 1
a55 1
int	repaint();
d78 1
d81 1
d521 1
a521 1
register count, line;
d536 1
a536 1
register count, line;
d570 1
a570 1
register count, line;
d1202 1
d1211 1
a1211 1
	register row, col, bit;
d1348 1
a1348 1
	register r, g, b;
d1599 1
@


10.14
log
@DEC Alpha
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X.c,v 10.13 94/12/22 00:46:05 mike Exp Locker: mike $ (BRL)";
@


10.13
log
@Changed to HAVE_XOSDEFS_H
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X.c,v 10.12 94/12/19 15:44:01 jra Exp Locker: mike $ (BRL)";
d452 2
a453 2
		bzero( bitbuf, (ifp->if_width * ifp->if_height)/8 );
		bzero( bytebuf, (ifp->if_width * ifp->if_height) );
@


10.12
log
@fixed call to  X_scanwrite to satisify CRAY.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/libfb/RCS/if_X.c,v 10.11 94/12/15 16:27:41 jra Exp Locker: jra $ (BRL)";
d35 1
a35 1
#ifndef CRAY2	/* not avaiable on CRAY2 */
d38 1
a38 1
#endif  /* CRAY2 */
@


10.11
log
@X11/Xfuncproto.h and X11/Xosdefs.h are not available on CRAY2.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X.c,v 10.10 94/12/07 21:35:04 mike Exp Locker: jra $ (BRL)";
d1775 1
a1775 1
		X_scanwrite( ifp, sxmin, sy, scanbuf, sxlen, 0 );
@


10.10
log
@Linux port.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X.c,v 10.9 94/11/23 23:41:13 mike Exp Locker: mike $ (BRL)";
d35 1
d38 1
@


10.9
log
@Changed name to /dev/xold.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X.c,v 10.8 94/11/04 23:47:35 mike Exp Locker: mike $ (BRL)";
d28 6
d35 6
a46 5
#include "machine.h"
#include "externs.h"
#include "fb.h"
#include "./fblocal.h"

d1405 1
a1405 1
	if( color_map == NULL)
@


10.8
log
@Irix 6
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X.c,v 10.7 94/11/04 05:15:27 mike Exp Locker: mike $ (BRL)";
d95 1
a95 1
	"X Window System (X11)",/* device description	*/
d98 1
a98 1
	"/dev/X",		/* short device name	*/
@


10.7
log
@Irix 6
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X.c,v 10.6 94/11/04 05:14:29 mike Exp Locker: mike $ (BRL)";
d43 1
a43 1
static	void	print_display_info();	/* debug */
d965 1
a965 1
	print_display_info(dpy);
d1468 2
a1469 2
static void
print_display_info( dpy )
@


10.6
log
@Irix  6
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X.c,v 10.5 94/08/09 12:57:34 gdurf Exp Locker: mike $ (BRL)";
d417 1
a426 1
#ifdef XXX
@


10.5
log
@Factored ifdefs
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X.c,v 10.4 1993/10/22 22:25:56 mike Exp gdurf $ (BRL)";
d711 1
a711 1
	int	row, col, bit, val;
a1051 1
			int	x, y;
d1084 1
a1092 1
	XCrossingEvent	*xcrossing;
d1200 1
d1202 1
d1204 1
d1445 1
d1459 1
a1595 3
	/* screen pixels of padding (i.e. window overlap) around image */
	int	spad_left, spad_right;
	int	spad_bottom, spad_top;
d1714 2
a1715 2
	int	sxmin, sxmax;	/* screen versions of above */
	int	symin, symax;
d1719 1
a1719 1
	int	sx, sy;		/* screen x, y */
d1755 2
d1758 2
a1759 2
			ix = xmin + x/ifp->if_xzoom;
			/*printf("S(%3d,%3d) <- I(%3d,%3d)\n", sx, sy, ix, iy);*/
@


10.4
log
@Fixed problem with dereferencing null pointer in X_wmap
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X.c,v 10.3 93/10/22 20:50:56 mike Exp Locker: mike $ (BRL)";
d24 1
a24 1
#include "machine.h"
d34 2
d68 1
a68 1
#if __STDC__
@


10.3
log
@Port to SGI IRIX 5.0.1
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/libfb/RCS/if_X.c,v 10.2 1993/09/25 09:04:11 mike Exp mike $ (BRL)";
a780 14
is_linear_cmap( cmp )
ColorMap *cmp;
{
	int	i;
	for( i = 0; i < 256; i++ ) {
		if( cmp->cm_red[i]>>8 != i
		 || cmp->cm_green[i]>>8 != i
		 || cmp->cm_blue[i]>>8 != i )
			return	0;
	}
	return	1;
}

_LOCAL_ int
d786 1
d790 1
d793 1
d797 1
a797 1
	if( is_linear_cmap(cmp) ) {
@


10.2
log
@Converted to new fb.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X.c,v 10.1 91/10/12 06:37:19 mike Rel4_0 Locker: mike $ (BRL)";
d28 2
d38 1
d386 1
d1716 1
@


10.1
log
@Release_4.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X.c,v 9.12 91/08/31 03:20:14 mike Exp $ (BRL)";
d407 1
a407 1
RGBpixel	*pp;
d416 3
a418 3
		v[RED] = (*pp)[RED];
		v[GRN] = (*pp)[GRN];
		v[BLU] = (*pp)[BLU];
d435 2
a436 2
	if( pp == (RGBpixel *)NULL
	 || ((*pp)[RED] == 0 && (*pp)[GRN] == 0 && (*pp)[BLU] == 0) ) {
d449 1
a449 1
RGBpixel	*pixelp;
d472 3
a474 3
		(*pixelp)[RED] = *cp;
		(*pixelp)[GRN] = *cp;
		(*pixelp++)[BLU] = *cp++;
d590 1
a590 1
RGBpixel	*pixelp;
d639 1
a639 1
RGBpixel	*pixelp;
d669 1
a669 1
				cp[i] = pixelp[i][RED];
d676 1
a676 1
			value = convRGB(pixelp[i]);
d688 1
a688 1
			cp[i] = pixelp[i][RED];
d694 2
a695 2
			cp[i] = (77*(int)pixelp[i][RED] + 150*(int)pixelp[i][GRN]
				+ 29*(int)pixelp[i][BLU]) >> 8;
d724 1
a724 1
				/*val = (30*(*pixelp)[RED] + 59*(*pixelp)[GRN] + 11*(*pixelp)[BLU] + 200) / 400;*/
d793 1
a793 1
ColorMap	*cmp;
d798 1
a798 7
		/* Linear map */
		cmp = &(XI(ifp)->rgb_cmap);
		for( i = 0; i < 256; i++ ) {
			cmp->cm_red[i] = i<<8;
			cmp->cm_green[i] = i<<8;
			cmp->cm_blue[i] = i<<8;
		}
d883 1
a883 1
unsigned char *bits;
d1298 1
a1298 1
register RGBpixel *v;
d1302 3
a1304 3
	r = (int)( (*v)[RED]+26 ) / 51;
	g = (int)( (*v)[GRN]+26 ) / 51;
	b = (int)( (*v)[BLU]+26 ) / 51;
d1306 1
a1306 1
	/*printf("Pixel r = %d, g = %d, b = %d\n",(*v)[RED],(*v)[GRN],(*v)[BLU]);*/
d1310 1
a1310 1
			return greyvec[( ((int)(*v)[RED]+(int)(*v)[GRN]+(int)(*v)[BLU]) / 3 ) /16];
d1314 1
a1314 1
			return bluvec[((*v)[BLU])/16];
d1320 1
a1320 1
		return redvec[((*v)[RED])/16];
d1324 1
a1324 1
		return grnvec[((*v)[GRN])/16];
d1732 2
a1733 1
	RGBpixel scanbuf[1024], *pp;
@


9.12
log
@Stardent ANSI C lint
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X.c,v 9.11 91/07/26 22:40:56 mike Exp $ (BRL)";
@


9.11
log
@Added if_magic field, and FB_CK_FBIO() macro, to allow checking
FBIO pointers
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X.c,v 9.10 91/07/04 03:04:40 mike Exp $ (BRL)";
d24 2
d694 2
a695 2
			cp[i] = (77*pixelp[i][RED] + 150*pixelp[i][GRN]
				+ 29*pixelp[i][BLU]) >> 8;
d727 1
a727 1
				if( *cp++ > (dm[((row&7)<<3)+(col&7)]<<2)+1 ) {
d1228 1
a1228 1
					if( *mpbuffer > (dm[((row&7)<<3)+(col&7)]<<2)+1 ) {
d1240 1
a1240 1
					if( *mpbuffer > (dm4[(row&3)][(col&3)]<<4)+7 ) {
d1308 3
a1310 3
	r = ( (*v)[RED]+26 ) / 51;
	g = ( (*v)[GRN]+26 ) / 51;
	b = ( (*v)[BLU]+26 ) / 51;
d1316 1
a1316 1
			return greyvec[( ((*v)[RED]+(*v)[GRN]+(*v)[BLU]) / 3 ) /16];
@


9.10
log
@ANSI compiler needs to know that a routine is static before first
mention of it, so that it can hide the references.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X.c,v 9.9 90/12/11 22:56:37 phil Exp $ (BRL)";
d69 1
d229 2
@


9.9
log
@if_ struct changes.  See fb.h.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X.c,v 9.8 90/06/06 20:52:18 mike Exp $ (BRL)";
d60 6
@


9.9.1.1
log
@This is a first pass at using LUV color space to map 24 bit to
an 8 bit color map.  Works a little better than the color cube
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X.c,v 9.9 90/12/11 22:56:37 phil Exp $ (BRL)";
a25 1
#include <math.h>
a123 1
	double	luvmap[3*256];		/* Luv version of rgb_cmap */
a207 1
static int TotalColors;
a661 3

		TotalColors = DisplayCells(XI(ifp)->dpy, XI(ifp)->screen);

d665 1
a665 1
			value = convRGB(ifp,pixelp[i]);
a785 4

	TotalColors = DisplayCells(XI(ifp)->dpy, XI(ifp)->screen);


d827 1
a827 1
		XStoreColors( XI(ifp)->dpy, XI(ifp)->cmap, color_defs, TotalColors );
a829 1
/* 	x_make_luv(ifp); */
d961 2
d1292 2
a1293 3
static unsigned char convRGB(ifp,colorwanted)
FBIO *ifp;
register RGBpixel *colorwanted;
d1295 1
a1295 8
	static int oldr = -1, oldg = -1, oldb = -1;
	static unsigned char last = '\0';
	int r, g, b;
	register double *luvp;
	double red,green,blue,x,y,z;
	register double l,u,v;
	register double smallest,new;
	int i;
d1297 3
a1299 3
	r = (*colorwanted)[RED];
	g = (*colorwanted)[GRN];
	b = (*colorwanted)[BLU];
d1301 5
a1305 32
	if (oldr == r && oldg == g && oldb == b) return(last);

	red = ((r<<8) +1) / 65280.0;
	green =((g<<8)+1) / 65280.0;
	blue  =((b<<8)+1) / 65280.0;

	x = 58.9316 * red + 17.8982 * green + 18.307 * blue;
	y = 29.026 * red  + 60.5128 * green + 10.4612 * blue;
	z =                 6.81835* green + 101.996 * blue;

	l = 25.0 * pow(((100.0*y)/100.0),.33333) - 16.0;
	u = 13.0 * l * 
	    (((4.0 * x) / (x + (15.0 *y) +(3.0 *z))) - 0.198039);
	v = 13.0 * l *
	    (((9.0 * y) / (x + (15.0 *y) +(3.0 *z))) - 0.468364);

	luvp = XI(ifp)->luvmap;

	last = '\0';
	smallest =	(*luvp - l) * (*luvp - l) +
			(*(luvp+1) - u) * (*(luvp+1) - u) +
			(*(luvp+2) - v) * (*(luvp+2) - v);
	luvp += 3;
	for (i = 1; i< TotalColors; i++) {
		new =	(*luvp - l) * (*luvp - l) +
			(*(luvp+1) - u) * (*(luvp+1) - u) +
			(*(luvp+2) - v) * (*(luvp+2) - v);
		luvp += 3;

		if (new < smallest) {
			last = i;
			smallest = new;
d1307 5
d1313 10
a1322 10
#if DEBUGX
	luvp = &XI(ifp)->luvmap[last*3];
	printf("[%g, %g, %g][%d] - [%g, %g, %g] = %g\n", *luvp, *(luvp+1), *(luvp+2),
	    last, l, u, v, smallest);
#endif
		
	oldr = r;
	oldg = g;
	oldb = b;
	return(last);
d1371 1
d1377 1
a1377 1
	TotalColors  = 256;
d1391 1
a1391 1
			malloc( TotalColors * sizeof( unsigned long) );
a1400 1
	TotalColors = DisplayCells(XI(ifp)->dpy,XI(ifp)->screen);
d1403 1
a1403 1
	      x_pixel_table, TotalColors )) == 0) {
d1425 1
a1425 1
	for (i = 0; i < TotalColors; i++) {
d1427 3
a1429 6
		XI(ifp)->rgb_cmap.cm_red[i] = 
		    color_defs[i].red   = redmap[i]<<8;
		XI(ifp)->rgb_cmap.cm_green[i] = 
		    color_defs[i].green = grnmap[i]<<8;
		XI(ifp)->rgb_cmap.cm_blue[i] = 
		    color_defs[i].blue  = blumap[i]<<8;
a1430 1

d1432 1
a1432 1
	XStoreColors ( XI(ifp)->dpy, color_map, color_defs, TotalColors);
a1442 1
 	x_make_luv(ifp);
a1761 39
	}
}
x_make_luv(ifp)
FBIO *ifp;
{
	int i;
	register double *luvp;
	ColorMap *mapp;
	double	l,u,v;
	double	red,green,blue;
	double	x,y,z;

#if DEBUGX
	printf("x_make_luv\n");
#endif
	mapp = & XI(ifp)->rgb_cmap;
	luvp = XI(ifp)->luvmap;
	for (i=0 ; i < 256; i++) {
		red = (mapp->cm_red[i]+1) / 65280.0;  /* 255 * 256 */
		green = (mapp->cm_green[i]+1) / 65280.0;
		blue  = (mapp->cm_blue[i]+1) / 65280.0;

		x = 58.9316 * red + 17.8982 * green + 18.307 * blue;
		y = 29.026 * red  + 60.5128 * green + 10.4612 * blue;
		z =                 6.81835* green + 101.996 * blue;

		l = 25.0 * pow(((100.0*y)/100.0),.33333) - 16.0;
		u = 13.0 * l * 
		    (((4.0 * x) / (x + (15.0 *y) +(3.0 *z))) - 0.198039);
		v = 13.0 * l *
		    (((9.0 * y) / (x + (15.0 *y) +(3.0 *z))) - 0.468364);
		*luvp = l;
		*(luvp+1) = u;
		*(luvp+2) = v;
		luvp += 3;
#if DEBUGX
	printf("[%g, %g, %g] -> luvmap[%d] = [%g, %g, %g]\n", x, y, z,
	    i, l, u, v);
#endif
@


9.8
log
@lint
@
text
@a2 1
#define	NEWLIBFB 1
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X.c,v 9.7 89/09/01 01:36:42 phil Exp $ (BRL)";
a33 4
#if !NEWLIBFB
extern int	fb_sim_readrect(), fb_sim_writerect();
#endif

a46 1
		X_reset(),
d52 2
a53 3
		X_viewport(),
		X_window(),
		X_zoom(),
d56 2
a57 1
		X_scursor(),
a64 1
	X_reset,		/* device_reset		*/
d70 2
a71 3
	X_viewport,		/* viewport_set		*/
	X_window,		/* window_set		*/
	X_zoom,			/* zoom_set		*/
d73 5
a77 5
	X_cursor,		/* cursor - memory addr */
	X_scursor,		/* cursor - screen addr */
	fb_sim_readrect,
	fb_sim_writerect,
#if NEWLIBFB
a79 1
#endif
d87 1
d89 3
a122 2
	int	xzoom, yzoom;		/* fb_zoom() parameters */
	int	xcenter, ycenter;	/* fb_window() parameters */
d291 4
a294 4
	XI(ifp)->xzoom = 1;
	XI(ifp)->yzoom = 1;
	XI(ifp)->xcenter = width/2;
	XI(ifp)->ycenter = height/2;
d371 3
a393 7
X_reset( ifp )
FBIO	*ifp;
{
	return(0);
}

_LOCAL_ int
d734 1
a734 1
	if( save && (XI(ifp)->xzoom != 1) ) {
d834 1
a834 1
X_viewport( ifp, left, top, right, bottom )
d836 2
a837 1
int	left, top, right, bottom;
a838 7
}

_LOCAL_ int
X_window( ifp, x, y )
FBIO	*ifp;
int	x, y;
{
d840 2
a841 1
	if( XI(ifp)->xcenter == x && XI(ifp)->ycenter == y )
d845 2
a846 1
	if( x < 0 || x >= ifp->if_width || y < 0 || y >= ifp->if_height )
d848 3
d852 4
a855 2
	XI(ifp)->xcenter = x;
	XI(ifp)->ycenter = y;
d862 1
a862 1
X_zoom( ifp, x, y )
d864 2
a865 1
int	x, y;
d867 4
a870 3
	/* bypass if no change */
	if( XI(ifp)->xzoom == x && XI(ifp)->yzoom == y )
		return	0;
a871 8
	/* check bounds */
	if( x <= 0 || x >= ifp->if_width/2 || y <= 0 || y >= ifp->if_height/2 )
		return	-1;

	XI(ifp)->xzoom = x;
	XI(ifp)->yzoom = y;
	/* XXX - repaint */
	repaint(ifp);
d891 2
d894 2
a895 2
	x = (x-XI(ifp)->xcenter)*XI(ifp)->xzoom+ifp->if_width/2;
	y = (y-XI(ifp)->ycenter)*XI(ifp)->yzoom+ifp->if_height/2;
a896 9
	return	X_scursor( ifp, mode, x, y );
}

_LOCAL_ int
X_scursor( ifp, mode, x, y )
FBIO	*ifp;
int	mode;
int	x, y;
{
d914 9
d1065 1
d1070 2
d1076 15
a1093 1
	int	alive = 1;
d1101 1
a1101 2
	if( fork() != 0 )
		return 1;	/* release the parent */
d1103 1
a1103 4
	XSelectInput( XI(ifp)->dpy, XI(ifp)->win,
		ExposureMask|ButtonPressMask );
	expose = (XExposeEvent *)&event;
	while( alive ) {
a1182 1
	}
d1244 11
d1259 3
d1453 1
a1453 1
		XI(ifp)->xcenter, XI(ifp)->ycenter, 1, 1, 3,
d1616 4
a1619 4
	xmin = XI(ifp)->xcenter - w.width/(2*XI(ifp)->xzoom);
	xmax = XI(ifp)->xcenter + w.width/(2*XI(ifp)->xzoom) - 1;
	ymin = XI(ifp)->ycenter - w.height/(2*XI(ifp)->yzoom);
	ymax = XI(ifp)->ycenter + w.height/(2*XI(ifp)->yzoom) - 1;
d1637 4
a1640 4
	sleft = (xmin - XI(ifp)->xcenter) * XI(ifp)->xzoom + w.width/2;
	sright = ((xmax+1) - XI(ifp)->xcenter) * XI(ifp)->xzoom + w.width/2 - 1;
	sbottom = (ymin - XI(ifp)->ycenter) * XI(ifp)->yzoom + w.height/2;
	stop = ((ymax+1) - XI(ifp)->ycenter) * XI(ifp)->yzoom + w.height/2 - 1;
d1654 2
a1655 2
		XI(ifp)->xcenter, XI(ifp)->ycenter,
		XI(ifp)->xzoom, XI(ifp)->yzoom);
d1661 1
a1661 1
	if( (XI(ifp)->xzoom == 1) && (XI(ifp)->yzoom == 1 ) ) {
d1701 2
a1702 2
#define	xIMG2SCR(x)	(((x)-XI(ifp)->xcenter)*XI(ifp)->xzoom+w.width/2)
#define	yIMG2SCR(y)	(((y)-XI(ifp)->ycenter)*XI(ifp)->yzoom+w.height/2)
d1742 2
a1743 2
	sxlen = xlen * XI(ifp)->xzoom;
	sylen = ylen * XI(ifp)->yzoom;
d1750 1
a1750 1
		iy = ymin + y/XI(ifp)->yzoom; 
d1753 1
a1753 1
			ix = xmin + x/XI(ifp)->xzoom;
@


9.7
log
@fb_free hook.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: if_X.c,v 9.6 89/08/29 23:41:27 phil Locked $ (BRL)";
d1474 1
a1474 1
	XFree( vp );
@


9.7.1.1
log
@Chris Johnson's Mac Hack
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: if_X.c,v 9.7 89/09/01 01:36:42 phil Exp $ (BRL)";
d975 1
a975 1
/* ctj	if( DisplayCells(dpy,screen) != 256 )
d1365 1
a1365 1
	tot_levels = 254;	/* XXX ctj should be 256 */
@


9.6
log
@First cut at working pan and zoom.  We now allocate a scanline
XImage buffer for zoomed repaints.  Currently only works in
'm' 24bit store mode.  Needs some cleanup/reorganization.
Added single-button-mouse remapping.  Fixed [s]cursor to actually
do screen/memory locations.  Neatened colormap file hack.
todo - libfb colormap repaints, better scanwrite hack, 6x6x6 cube.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: if_X.c,v 9.5 89/08/23 03:20:21 phil Locked $ (BRL)";
d87 1
@


9.5
log
@name changes, fb_flush, portability improvements, new modes,
cursor hack, beginning of pan and zoom, etc.  Time for a checkpoint!
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: if_X.c,v 9.4 89/08/14 00:10:57 phil Locked $ (BRL)";
d46 2
d117 1
d120 1
d164 2
a167 2
	{ 'm',  MODE_4MASK, MODE_4MEM,
		"24-bit memory buffer" },
d223 1
a223 1
	char	*display_name = NULL;
a224 1
	int	i;
d227 1
d308 14
a321 5
	/* init a linear libfb colormap */
	for( i = 0; i < 256; i++ ) {
		XI(ifp)->rgb_cmap.cm_red[i] = i<<8;
		XI(ifp)->rgb_cmap.cm_green[i] = i<<8;
		XI(ifp)->rgb_cmap.cm_blue[i] = i<<8;
d324 1
a324 1
	/* an image data buffer */
d333 4
d339 1
a348 3
	if( (XI(ifp)->mode&MODE_3MASK) == MODE_3MONO )
		XI(ifp)->depth = 1;	/* force monochrome behavior */

d359 3
d371 3
a376 14
	if( (XI(ifp)->mode&MODE_2MASK) == MODE_2_8BIT )  {
		int	fd;
#define TMP_FILE	"/tmp/x.cmap"
		fd = open( TMP_FILE, 0 );
		if( fd >= 0 )  {
			read( fd, &(XI(ifp)->rgb_cmap), sizeof(XI(ifp)->rgb_cmap) );
			close(fd);
			X_wmap( ifp, &(XI(ifp)->rgb_cmap) );
		} else {
			/* use linear map */
			X_wmap( ifp, (ColorMap *)NULL );
		}
	}

d592 2
a593 1
	int	todo = count;
d596 1
d600 5
d612 1
d618 1
a618 1
		if( X_scanwrite( ifp, x, y, pixelp, num ) == 0 )
d628 6
d635 1
a635 1
X_scanwrite( ifp, x, y, pixelp, count )
d640 1
d644 1
d650 2
d654 9
a662 2
	y = ifp->if_height - 1 - y;
	cp = &bytebuf[y*ifp->if_width + x];
d699 1
a699 1
	if (XBitmapBitOrder(XI(ifp)->dpy) == LSBFirst) {
d707 2
a708 2
	unsigned char	*mbuffer;	/* = &buffer[(y*ifp->if_width + x)/8]; */
    	byte = y * ifp->if_width + x;
d711 4
a714 1
	mbuffer = (unsigned char *)&bitbuf[byte];
d716 1
a716 1
	for( row = y; row < y+1; row++ ) {
d744 14
a757 3
	XPutImage(XI(ifp)->dpy, XI(ifp)->win, XI(ifp)->gc, XI(ifp)->image,
		x, y, x, y,
		count, 1 );
d808 1
a808 13
	/* If MODE_2_8BIT, load it in the real window colormap */
	if( (XI(ifp)->mode&MODE_2MASK) == MODE_2_8BIT ) {
		for( i = 0; i < 256; i++ ) {
			/* Both sides expect 16-bit left-justified maps */
			color_defs[i].pixel = i;
			color_defs[i].red   = cmp->cm_red[i];
			color_defs[i].green = cmp->cm_green[i];
			color_defs[i].blue  = cmp->cm_blue[i];
		        color_defs[i].flags = DoRed | DoGreen | DoBlue;
		}
		XStoreColors( XI(ifp)->dpy, XI(ifp)->cmap, color_defs, 256 );
	}

d823 17
d906 13
a931 1
}
d933 1
a933 6
_LOCAL_ int
X_scursor( ifp, mode, x, y )
FBIO	*ifp;
int	mode;
int	x, y;
{
d974 2
d1090 1
d1115 12
a1126 1
			switch( (int)event.xbutton.button ) {
d1455 1
d1475 6
d1483 7
a1489 2
	/* Note: DisplayPlanes if Visual dependent */
	printf("%d DisplayPlanes\n", DisplayPlanes(dpy,screen) );
d1493 5
d1509 2
d1514 2
d1534 2
d1538 1
a1538 1
	if( XGetStandardColormap( dpy, win, &cmap, XA_RGB_BEST_MAP ) == 0 ) {
d1545 1
a1545 1
	if( XGetStandardColormap( dpy, win, &cmap, XA_RGB_DEFAULT_MAP ) == 0 ) {
d1552 1
a1552 1
	if( XGetStandardColormap( dpy, win, &cmap, XA_RGB_GRAY_MAP ) == 0 ) {
d1647 11
a1657 5
	/* Display our image rectangle.  Note quadrant reversal. */
	XPutImage(XI(ifp)->dpy, XI(ifp)->win, XI(ifp)->gc, XI(ifp)->image,
		xmin, w.width-1-ymax,
		sleft, w.height-1-stop,
		xmax-xmin+1, ymax-ymin+1 );
d1683 67
@


9.4
log
@A semi production version?  No debug output, fix for y coord of
pixel display, hack to keep black/white pixel values from changing.
@
text
@d1 3
a3 1
/*#define DEBUGX 1*/
a19 1
 *
d22 1
a22 1
static char RCSid[] = "@@(#)$Header: if_X.c,v 9.3 89/08/13 23:07:07 phil Locked $ (BRL)";
d35 1
d37 1
d41 4
d46 17
a62 14
_LOCAL_ int	X_dopen(),
		X_dclose(),
		X_dreset(),
		X_dclear(),
		X_bread(),
		X_bwrite(),
		X_cmread(),
		X_cmwrite(),
		X_viewport_set(),
		X_window_set(),
		X_zoom_set(),
		X_curs_set(),
		X_cmemory_addr(),
		X_cscreen_addr(),
a64 2
_LOCAL_ int	X_multiwrite();

d66 15
a80 15
FBIO X_interface =  {
	X_dopen,		/* device_open		*/
	X_dclose,		/* device_close		*/
	X_dreset,		/* device_reset		*/
	X_dclear,		/* device_clear		*/
	X_bread,		/* buffer_read		*/
	X_multiwrite,		/* buffer_write		*/
	X_cmread,		/* colormap_read	*/
	X_cmwrite,		/* colormap_write	*/
	X_viewport_set,		/* viewport_set		*/
	X_window_set,		/* window_set		*/
	X_zoom_set,		/* zoom_set		*/
	X_curs_set,		/* curs_set		*/
	X_cmemory_addr,		/* cursor_move_memory_addr */
	X_cscreen_addr,		/* cursor_move_screen_addr */
d83 3
d88 2
a89 2
	1024,			/* max width		*/
	1024,			/* max height		*/
d113 1
a113 1
	Colormap cmap;			/* 8bit colormap */
d115 5
d123 3
a125 4
	int	x_zoom, y_zoom;
	int	x_window, y_window;	/**/
	int	x_corig, y_corig;	/* cursor origin offsets */
	ColorMap rgb_cmap;		/* User's libfb cmap */
a129 3
static unsigned char	*bytebuf = NULL;	/*XXXXXX*/
static char		*bitbuf = NULL;		/*XXXXXX*/

d138 12
d159 7
a165 1
		"8-bit Monochrome from RED channel" },
d210 2
a211 2
unsigned long 	* x_pixel_table;
XColor 			*color_defs; 
d214 1
a214 1
X_dopen( ifp, file, width, height )
d221 3
d288 1
d290 1
a290 1
		fb_log("X_dopen: xinfo malloc failed\n");
d293 4
d304 7
d313 1
a313 1
		fb_log("X_dopen: bytebuf malloc failed\n");
d316 2
a317 2
	if( (bitbuf = (char *)calloc( 1, (width*height)/8 )) == NULL ) {
		fb_log("X_dopen: bitbuf malloc failed\n");
d320 2
d323 11
d340 1
a340 1
	if( XI(ifp)->depth == 1 ) {
a341 4
			XI(ifp)->visual, 1, XYBitmap, 0,
			(char *)bitbuf, width, height, 8, 0);
	} else if( XI(ifp)->depth == 8 ) {
		XI(ifp)->image = XCreateImage( XI(ifp)->dpy,
d345 9
a353 3
		fprintf( stderr, "if_X: can't handle a depth of %d\n",
			XI(ifp)->depth );
		return(-1);
d363 1
a363 1
			X_cmwrite( ifp, &(XI(ifp)->rgb_cmap) );
d366 1
a366 1
			X_cmwrite( ifp, (ColorMap *)NULL );
d374 1
a374 1
X_dclose( ifp )
d390 1
a390 1
X_dreset( ifp )
d393 1
d397 1
a397 1
X_dclear( ifp, pp )
d401 33
a433 3
	XClearWindow( XI(ifp)->dpy, XI(ifp)->win );
	bzero( bitbuf, (ifp->if_width * ifp->if_height)/8 );
	bzero( bytebuf, (ifp->if_width * ifp->if_height) );
d438 1
a438 1
X_bread( ifp, x, y, pixelp, count )
d444 1
d448 10
d461 1
d468 1
a468 1
	return( count );
d579 1
a579 1
X_multiwrite( ifp, x, y, pixelp, count )
d588 10
d603 1
a603 1
		if( X_bwrite( ifp, x, y, pixelp, num ) == 0 )
d614 1
a614 1
X_bwrite( ifp, x, y, pixelp, count )
d620 2
d624 3
d630 1
d633 1
a633 1
		cp = &bytebuf[y*ifp->if_width + x];
d636 1
a636 1
				cp[i] = x_pixel_table[pixelp[i][RED]];
d640 1
d644 1
a644 8
#ifdef never
			printf("Conv value, %d r = %d g = %d b = %d\n\n",value,
				color_defs[value].red >> 8,
				color_defs[value].green >> 8,
				color_defs[value].blue >> 8 );
#endif
			cp[i] = (unsigned char) 
				x_pixel_table[value];
d652 1
a652 1
	cp = &bytebuf[y*ifp->if_width + x];
d667 5
a671 13
    if (XBitmapBitOrder(XI(ifp)->dpy) == LSBFirst) {
    	fb_log("if_X: can't do LSBFirst machines yet\n");
#ifdef LATER
        for (row=0; row < height; row++)
            for (col=0; col < width; ) {
                mvalue = 0x00;
                for (bit=0; (bit < 8) && (col < width); bit++,col++)
                    if( dither_bw(*mpbuffer++, col, row) )
                        mvalue |= (0x01 << bit);    /*  for Vax */
                *mbuffer++ = mvalue;
            }
#endif
    } else {
d684 1
d686 1
d692 1
a692 1
					mvalue |= (0x80 >> bit);    /*  for RT, Sun  */
d694 1
a694 1
					mvalue &= ~(0x80 >> bit);    /*  for RT, Sun  */
d697 2
a699 1
			*mbuffer++ = mvalue;
d702 1
a702 1
    }
d705 4
d712 5
d721 1
a721 1
X_cmread( ifp, cmp )
d744 1
a744 1
X_cmwrite( ifp, cmp )
d762 11
a772 7
	/* This really only works for MODE_2_8BIT */
	for( i=0; i<256; i++ )  {
		/* Both sides expect 16-bit left-justified color maps */
		color_defs[i].red   = cmp->cm_red[i];
		color_defs[i].green = cmp->cm_green[i];
		color_defs[i].blue  = cmp->cm_blue[i];
	        color_defs[i].flags = DoRed | DoGreen | DoBlue;
a774 2
	XStoreColors ( XI(ifp)->dpy, XI(ifp)->cmap, color_defs, 256);

d789 1
d793 1
a793 1
X_viewport_set( ifp, left, top, right, bottom )
d800 1
a800 1
X_window_set( ifp, x, y )
d804 13
d820 1
a820 1
X_zoom_set( ifp, x, y )
d824 13
d840 1
a840 1
X_curs_set( ifp, bits, xbits, ybits, xorig, yorig )
d846 1
d850 1
a850 1
X_cmemory_addr( ifp, mode, x, y )
d855 13
d871 1
a871 1
X_cscreen_addr( ifp, mode, x, y )
a877 11
static XWMHints xwmh = {
	(InputHint|StateHint),		/* flags */
	False,				/* input */
	NormalState,			/* initial_state */
	0,				/* icon pixmap */
	0,				/* icon window */
	0, 0,				/* icon location */
	0,				/* icon mask */
	0				/* Window group */
};

a882 7
	char	hostname[80];
	char	display[80];
	char	*envp;
	unsigned long	bd, bg, fg, bw;
	XSizeHints xsh;
	XEvent	event;
	XGCValues gcv;
a883 1
	Window	win;			/* local copy */
d886 1
d888 4
a891 1
	XSetWindowAttributes	xswa;
d899 1
d901 8
d911 1
d917 2
a918 30
#ifdef DEBUGX
printf("%d DisplayPlanes\n", DisplayPlanes(dpy,screen) );
printf("%d DisplayCells\n", DisplayCells(dpy,screen) );
printf("BlackPixel = %d\n", BlackPixel(dpy,screen) );
printf("WhitePixel = %d\n", WhitePixel(dpy,screen) );
switch(DefaultVisual(dpy,screen)->class) {
case DirectColor:
	printf("DirectColor: Alterable RGB maps, pixel RGB subfield indicies\n");
	break;
case TrueColor:
	printf("TrueColor: Fixed RGB maps, pixel RGB subfield indicies\n");
	break;
case PseudoColor:
	printf("PseudoColor: Alterable RGB maps, single index\n");
	break;
case StaticColor:
	printf("StaticColor: Fixed RGB maps, single index\n");
	break;
case GrayScale:
	printf("GrayScale: Alterable map (R=G=B), single index\n");
	break;
case StaticGray:
	printf("StaticGray: Fixed map (R=G=B), single index\n");
	break;
default:
	printf("Unknown visual class %d\n",
		DefaultVisual(dpy,screen)->class);
	break;
}
visinfo(ifp);
a921 18
	 * Select border, background, foreground colors,
	 * and border width.
	 */
	bd = WhitePixel( dpy, screen );
	bg = BlackPixel( dpy, screen );
	fg = WhitePixel( dpy, screen );
	bw = 1;

	/*
	 * Fill in XSizeHints struct to inform window
	 * manager about initial size and location.
	 */
	xsh.flags = PPosition | PSize | PMinSize | PMaxSize;
	xsh.width = xsh.max_width = xsh.min_width = width;
	xsh.height = xsh.max_height = xsh.min_height = height;
	xsh.x = xsh.y = 0;

	/*
d925 1
a925 1
		/* |ButtonPressMask |LeaveWindowMask | EnterWindowMask; */
d929 4
a932 1
#ifdef CURSOR
d936 1
a936 6
	/*
	 *  Note: all Windows, Colormaps and XImages have
	 *  a Visual attribute which determines how pixel
	 *  values are mapped to displayed colors.
	 */
#ifdef DEBUGX
d940 4
a943 4
		0, 0, xsh.width, xsh.height,
		3, XDefaultDepth(dpy, screen),
		InputOutput, visual,
		CWBackPixel |CWEventMask |CWBorderPixel,
d957 1
a957 1
		XI(ifp)->cmap = XDefaultColormap(dpy,screen);
d960 9
d970 2
a971 2
#ifdef DEBUGX
printf("Setting properties\n");
d973 8
a980 4
	XSetStandardProperties( dpy, win, "Frame buffer", "Frame buffer",
		None, NULL, 0, &xsh );
#ifdef DEBUGX
printf("Setting Hints\n");
d982 3
d988 3
a990 4
	/*gcv.font = NULL;*/
	gcv.foreground = fg;
	gcv.background = bg;
#ifdef DEBUGX
d1001 1
d1030 5
d1056 15
a1070 1
				Monochrome(bitbuf,bytebuf,ifp->if_width,ifp->if_height);
d1077 1
a1077 1
				int	x, y;
d1080 11
a1090 10
				y = event.xbutton.y;
				/* 8-bit display */
				cp = &bytebuf[y*ifp->if_width + x];
				/* quadrant reverse y for output */
				y = ifp->if_height - 1 - event.xbutton.y;
				fb_log("(%4d,%4d) index=%3d rgb=(%3d %3d %3d)\n",
					x, y, *cp,
					color_defs[*cp].red>>8,
					color_defs[*cp].green>>8,
					color_defs[*cp].blue>>8 );
d1092 9
d1116 7
a1122 5
static int method = 0;

/* Monochrome to Bitmap conversion */
Monochrome(bitbuf,bytebuf,width,height)
char *bitbuf;
d1125 1
d1130 3
d1138 1
a1138 1
	mbuffer = (unsigned char *)bitbuf;
d1147 1
a1147 1
						mvalue |= (0x80 >> bit);    /*  for RT, Sun  */
d1151 1
a1151 1
						mvalue |= (0x80 >> bit);    /*  for RT, Sun  */
d1155 1
a1155 1
						mvalue |= (0x80 >> bit);    /*  for RT, Sun  */
d1159 1
a1159 1
						mvalue |= (0x80 >> bit);    /*  for RT, Sun  */
a1167 9
	if( method == 0 )
		method = 1;
	else if( method == 1 )
		method = 2;
	else if( method == 2 )
		method = 3;
	else if( method == 3 )
		method = 0;

d1173 8
d1282 1
d1286 3
a1288 3
	int 			tot_levels;
	int 			i;
	Colormap		color_map;
d1290 1
d1294 1
a1294 1
#ifdef DEBUGX
d1328 3
d1332 2
a1333 2
	x_pixel_table[215] = x_pixel_table[0];	/* move our White to 0 */
	x_pixel_table[0] = tmp;			/* and orig 0 to 215 */
d1336 2
a1337 2
	x_pixel_table[0] = x_pixel_table[1];	/* move our Black to 1 */
	x_pixel_table[1] = tmp;			/* and orig 1 to 0 */
d1355 3
d1360 2
a1361 1
visinfo(ifp)
d1364 22
a1385 1
	XVisualInfo	*vp;
d1387 2
d1390 192
a1581 2
	vp = XGetVisualInfo(XI(ifp)->dpy, VisualNoMask, NULL, &num );
	printf("%d Visuals returned\n", num);
@


9.3
log
@Checkpoint.  Works again on color and B&W Suns.  Beat on colormap
code a bit.  Back to using Lee's full 256 entry cube.  Fixed bug
in width rounding.  Relaxed window size restriction.  Made the
NULL colormap be linear and remove the /tmp/x.cmap file on linear
maps (8bit mode).
@
text
@d1 1
a1 1
#define DEBUGX 1
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: if_X.c,v 9.2 89/07/28 05:39:50 phil Locked $ (BRL)";
d938 1
a938 1
				y = ifp->if_height - 1 - event.xbutton.y;
d941 2
d1131 1
d1162 14
@


9.2
log
@Includes unfinished 8-bit color support a.la. Apollo.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: if_X.c,v 9.1 89/05/19 05:47:46 mike Rel3_5 $ (BRL)";
d179 1
a179 1
unsigned char convRGB();
d251 1
a251 1
		width = (width + 7)/8;
a265 8
#ifdef notes
	/* monochrome */
        colormap = XDefaultColormap(dpy,screen);
	/* color */
        colormap = GetColormap(colors, ncolors, &newmap_flag, buffer,
            buffer_size);
#endif

d305 2
a306 1
			perror(TMP_FILE);
d536 2
d540 11
a550 5
	for( i = 0; i < count; i++ ) {
		/* Best possible 8-bit NTSC weights */
		/* Use three tables if this gets to be a bottleneck */
		
		cp[i] =(unsigned char)  x_pixel_table[convRGB(pixelp[i])];
d613 14
d633 11
a643 1
	XI(ifp)->rgb_cmap = *cmp;	/* struct copy */
d656 3
a658 4
	i=creat(TMP_FILE, 0664);
	if( i >= 0 )  {
		write( i, cmp, sizeof(*cmp) );
		close(i);
d660 9
a668 1
		perror(TMP_FILE);
a747 2
	width = height = 512;

a761 8
	XI(ifp)->cmap = XCreateColormap( dpy, RootWindow(dpy,screen),
		visual, None);
	XInstallColormap( dpy, XI(ifp)->cmap );

	if( XI(ifp)->depth == 8 ) {
		x_make_colormap(ifp);
	}

d764 3
d769 1
a769 1
	printf("DirectColor: Full Color changeable map\n");
d772 1
a772 1
	printf("TrueColor: Full Color, no map\n");
d775 1
a775 1
	printf("PseudoColor: Some Color, changeable map\n");
d778 1
a778 1
	printf("StaticColor: Some Color, fixed map\n");
d781 1
a781 1
	printf("GrayScale: gray scale, changeable map\n");
d784 1
a784 1
	printf("StaticGray: gray scale, fixed map\n");
d791 1
a817 1
	xswa.colormap = XI(ifp)->cmap;
d836 2
a837 2
		CWBackPixel |CWEventMask |CWBorderPixel
		|CWColormap, /* |CWCursor, */
d846 6
a851 2
	XMapWindow( dpy, win);
	XClearWindow(dpy, win);
a852 1
	XSetWindowColormap( dpy, win, XI(ifp)->cmap);
d871 1
a871 1
	gc = XCreateGC( dpy, win, (GCPlaneMask|GCForeground|GCBackground), &gcv );
a873 2
	XFlush(dpy);

d876 1
d928 1
a928 1
				Monochrome(bitbuf,bytebuf,512,512);
d931 1
a931 1
					512, 512 );
d1048 1
a1048 1
unsigned char convRGB(v)
d1057 1
a1057 2
#ifdef never
	printf("Pixel r = %d, g = %d, b = %d\n",(*v)[RED],(*v)[GRN],(*v)[BLU]);
d1078 1
a1078 2
#endif 
	return r + g * 6 + b * 36 + 16;
d1087 1
a1087 1
void genmap(rmap, gmap, bmap)
d1130 1
a1130 1
	tot_levels = 216+16;
d1132 1
d1134 5
d1147 1
a1147 2
		RootWindow( XI(ifp)->dpy, XI(ifp)->screen),
		XI(ifp)->visual, None);
d1150 1
a1150 1
		printf("Warning: color map missing\n");
a1151 2
	XInstallColormap( XI(ifp)->dpy, color_map);

a1154 1

d1156 2
a1157 3
		    x_pixel_table, tot_levels )) == 0)
	{
		printf("XAllockCOlorCelss died\n");
d1160 2
a1161 3
	/* initialize table */

	for (i = 16; i < tot_levels; i++) {
d1163 3
a1165 3
	        color_defs[i].red   = redmap[i-16]<<8;
	        color_defs[i].green = grnmap[i-16]<<8;
	        color_defs[i].blue  = blumap[i-16]<<8;
d1168 1
d1170 16
a1185 1
	XStoreColors ( XI(ifp)->dpy, color_map, color_defs, tot_levels);
@


9.1
log
@Release_3.5
@
text
@d1 1
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: if_X.c,v 8.6 89/04/29 06:00:10 phil Exp $ (BRL)";
d102 1
a102 1
	XStandardColormap cmap;		/* 8bit colormap */
d110 1
d122 4
d134 2
d139 44
d297 1
a297 1
			(char *)bytebuf, width, height, 8, 0);
d304 13
d502 1
a520 1
		/* assuming SGI 4Ds strange form of pseudocolor XXX */
d522 6
d529 10
a538 3
			cp[i] = (int)(pixelp[i][RED]/52)
				+ 25*(int)(pixelp[i][GRN]/28.45)
				+ 5*(int)(pixelp[i][BLU]/52) + 31;
d548 2
a549 2
		cp[i] = (77*pixelp[i][RED] + 150*pixelp[i][GRN]
			+ 29*pixelp[i][BLU]) >> 8;
d607 2
d616 22
a725 4
XI(ifp)->dpy = dpy;
XI(ifp)->screen = screen;
XI(ifp)->visual = visual;
XI(ifp)->depth = DisplayPlanes(dpy,screen);
d727 13
d792 1
a792 1
	/*xswa.colormap = colormap;*/
d811 2
a812 2
		CWBackPixel |CWEventMask |CWBorderPixel,
		/* |CWColormap |CWCursor */
d815 1
a815 1
XI(ifp)->win = win;
d821 4
d843 2
a844 2
	gc = XCreateGC( dpy, win, (GCForeground|GCBackground), &gcv );
XI(ifp)->gc = gc;
d846 1
a846 18
	if( XI(ifp)->depth == 8 ) {
		int	ret;
		ret = XGetStandardColormap( dpy, RootWindow(dpy,screen),
			&(XI(ifp)->cmap), XA_RGB_BEST_MAP );
		if( !ret ) {
			fb_log("if_X: can't get colormap\n");
		} else {
#ifdef DEBUGX
printf("R G B Max: %d %d %d\n",
XI(ifp)->cmap.red_max, XI(ifp)->cmap.green_max, XI(ifp)->cmap.blue_max);
printf("R G B Mult: %d %d %d\n",
XI(ifp)->cmap.red_mult, XI(ifp)->cmap.green_mult, XI(ifp)->cmap.blue_mult);
printf("Base: %d\n",
XI(ifp)->cmap.base_pixel);
#endif
			;
		}
	}
d912 1
d914 5
a918 2
				fb_log("(%4d,%4d) %3d %3d %3d\n",
					x, y, *cp, *cp, *cp );
d1013 132
@


8.6
log
@made modeflags static since it appears in more than one module
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: if_X.c,v 8.5 89/04/07 05:50:07 phil Locked $ (BRL)";
@


8.5
log
@added mode flags, cleaned up some dither code, made some things static
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: if_X.c,v 8.4 89/03/07 22:17:12 phil Locked $ (BRL)";
d120 1
a120 1
struct modeflags {
@


8.4
log
@added X_multiwrite to handle multiline writes (such as pix-fb).
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: if_X.c,v 8.3 89/03/03 05:54:21 phil Locked $ (BRL)";
d24 1
d29 1
d36 1
d113 2
a114 2
unsigned char	*bytebuf = NULL;	/*XXXXXX*/
char	*bitbuf = NULL;		/*XXXXXX*/
d116 15
d138 1
d140 48
d207 1
a208 3
	if( file[strlen("/dev/X")] != NULL )
		XI(ifp)->mode = 1;

a216 2
        image = XCreateImage(dpy, visual, 1, XYBitmap, 0,
                (char *)buffer, buf_width, buf_height, 8, 0);
a219 9
        image = XCreateImage(dpy, visual, 8, ZPixmap, 0, (char *)buffer,
            buf_width, buf_height, 8, 0);
	/* expose event */
	XPutImage(dpy, image_win, gc, image,
		expose->x, expose->y, expose->x, expose->y,
		expose->width, expose->height);
	/* normal draw */
	XPutImage(dpy, image_win, gc, image, 0, 0, 0, 0,
		image->width, image->height);
d260 1
a260 1
	if( XI(ifp)->mode ) {
d283 2
d295 13
d310 3
a312 3
/*************************
* code for dithering     *
*************************/
d314 4
a317 4
     0,  8,  2, 10,
    12,  4, 14,  6,
     3, 11,  1,  9,
    15,  7, 13,  5
d320 8
a327 8
     0, 32,  8, 40,  2, 34, 10, 42,
    48, 16, 56, 24, 50, 18, 58, 26,
    12, 44,  4, 36, 14, 46,  6, 38,
    60, 28, 52, 20, 62, 30, 54, 22,
     3, 35, 11, 43,  1, 33,  9, 41,
    51, 19, 59, 27, 49, 17, 57, 25,
    15, 47,  7, 39, 13, 45,  5, 37,
    63, 31, 55, 23, 61, 29, 53, 21
d336 6
a341 6
{   
    if( pixel > dm[((line%ditherPeriod)*ditherPeriod) +
            (count%ditherPeriod)])
        return(1);
    else
        return(0);
d343 6
a348 4
/***************************************
* code for modified floyd steinberg    *
****************************************/
int mfs_bw(pixel,count,line)
d352 2
a353 2
    int  onoff, *te;
    long  intensity, pixerr;
d355 7
a361 11
    if (count == 0) {
        te = error1;
        error1 = error2;
        error2 = te;
        error2[0] = 0;
    }  
    intensity = pixel + error1[count];
    if (intensity > 255)
        intensity = 255;
    else if (intensity < 0)
        intensity = 0;
d363 13
a375 12
    if (intensity < 128) {
        onoff = 0;
        pixerr = 128 - intensity;
    }
    else {
        onoff = 1;
        pixerr = 128 - intensity;
    }
    error1[count+1] += (int)(3*pixerr)/8;
    error2[count+1] = (int)pixerr/4;
    error2[count] += (int)(3*pixerr)/8;
    return(onoff);
d377 6
a382 4
/*****************************
* code for floyd steinberg   *
*****************************/
int fs_bw(pixel, count, line)
d386 2
a387 2
    int  onoff, *te; 
    long  intensity, pixerr;
d389 7
a395 11
    if (count == 0) {
        te = error1;
        error1 = error2;
        error2 = te;
        error2[0] = 0;
    }  
    intensity = pixel + error1[count];
    if (intensity > 255)
        intensity = 255;
    else if (intensity < 0)
            intensity = 0;
d397 14
a410 11
    if (intensity < 128) {
        onoff = 0;
        pixerr = intensity;
    } else {
        onoff = 1;
        pixerr = intensity - 255;
    }
    error1[count+1] += (int)(3*pixerr)/8;
    error2[count+1] = (int)pixerr/4;
    error2[count] += (int)(3*pixerr)/8;
    return(onoff);
d468 4
a471 2
		cp[i] = (30*pixelp[i][RED] + 59*pixelp[i][GRN]
			+ 11*pixelp[i][BLU]) / 100;
d476 1
d584 1
a584 1
XWMHints xwmh = {
d595 1
a687 6
#ifdef OLD
	win = XCreateSimpleWindow( dpy, DefaultRootWindow(dpy),
		xsh.x, xsh.y, xsh.width, xsh.height,
		bw, bd, bg );
#endif /* OLD */

a699 1
/*CURSOR	CWBackPixel |CWEventMask |CWCursor |CWBorderPixel,*/
d701 1
a701 1
		/* |CWColormap */
d809 9
a817 1
				fb_log("(%d,%d)\n", event.xbutton.x, event.xbutton.y );
a843 1
	char  *malloc(), *calloc();
d896 2
d906 4
@


8.3
log
@Added support for fb_readrect() and fb_writerect().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: if_X.c,v 8.2 89/03/02 20:34:28 mike Locked $ (BRL)";
d51 2
d60 1
a60 1
	X_bwrite,		/* buffer_write		*/
d344 4
d349 24
d449 1
@


8.2
log
@#endif fix
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: if_X.c,v 8.1 88/10/05 00:27:26 phil Locked $ (BRL)";
d31 2
d67 2
@


8.1
log
@Release_3.0
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: if_X.c,v 1.2 88/10/04 20:16:25 phil Exp $ (BRL)";
d584 1
a584 1
#endif OLD
@


1.2
log
@This version has initial support for 8-bit color displays,
as well as 1-bit monochrome.
The current 8-bit code assumes the display is a brain-damaged
SGI 4D MAX server, for now.
Some debugging hooks have been left in.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: if_X.c,v 1.1 88/09/15 21:26:31 phil Locked $ (BRL)";
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: if_X.c,v 7.4 88/09/09 23:36:27 phil Locked $ (BRL)";
d27 1
d31 2
d87 6
a92 2
	Display	*dpy;
	Window	win;
d94 2
a95 5
	GC	gc;
/*
	int	screen;
	Visual	*visual;
*/
a134 10
	/* an image data buffer */
	if( (bytebuf = (unsigned char *)calloc( 1, width*height )) == NULL ) {
		fb_log("X_dopen: bytebuf malloc failed\n");
		return(-1);
	}
	if( (bitbuf = (char *)calloc( 1, (width*height)/8 )) == NULL ) {
		fb_log("X_dopen: bitbuf malloc failed\n");
		return(-1);
	}

d138 4
a141 12
#ifdef never
	if ((dpy = XOpenDisplay(display_name)) == NULL)
		fb_log("X_dopen: Can't open display '%s'", XDisplayName(display_name));
	screen = XDefaultScreen(dpy);
	root_win = XDefaultRootWindow(dpy, screen);
	visual = XDefaultVisual(dpy, screen);
	blackpixel = XBlackPixel(dpy, screen);
	whitepixel = XWhitePixel(dpy, screen);
	if( XDisplayPlanes(dpy, screen) == 1 )
		mono_flag = True;
#endif
	xsetup( ifp, width, height );
d162 9
a170 4
	XI(ifp)->image = XCreateImage( XI(ifp)->dpy,
		XDefaultVisual(XI(ifp)->dpy,XDefaultScreen(XI(ifp)->dpy)),
		1, XYBitmap, 0,
		(char *)bitbuf, width, height, 8, 0);
d172 20
d351 11
d411 1
d499 5
a503 3
	Display	*dpy;
	Window	win;
	GC	gc;
d508 1
a508 1
	/* Open the display - XXX use the env var DISPLAY */
d510 3
a512 2
		fb_log( "if_X: Can't open X display\n" );
		exit( 2 );
d514 2
d517 3
d521 30
a550 1
	/* Select border, background, foreground colors,
d553 3
a555 3
	bd = WhitePixel( dpy, DefaultScreen(dpy) );
	bg = BlackPixel( dpy, DefaultScreen(dpy) );
	fg = WhitePixel( dpy, DefaultScreen(dpy) );
d568 1
a568 1
	 * Fill in XSetWindowAttributes struct for CreateWindow
d574 3
a576 2
	xswa.background_pixel = BlackPixel(dpy, DefaultScreen(dpy));
	xswa.border_pixel = WhitePixel(dpy, DefaultScreen(dpy));
d578 1
a579 8
	win = XCreateWindow( dpy, DefaultRootWindow(dpy),
		0, 0, xsh.width, xsh.height,
		3, XDefaultDepth(dpy,XDefaultScreen(dpy)),
		InputOutput, XDefaultVisual(dpy, DefaultScreen(dpy)),
		CWBackPixel |CWEventMask |CWCursor |CWBorderPixel,
		/* |CWColormap */
		&xswa);

d585 18
d606 1
a606 1
		exit( 3 );
d610 3
d615 3
d624 3
d630 19
d669 2
a670 1
/*printf("%d XDisplayPlanes\n", XDisplayPlanes(dpy,DefaultScreen(dpy)) );*/
d673 1
@
