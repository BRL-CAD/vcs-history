head	11.28;
access;
symbols
	ansi-20040405-merged:11.23.2.2
	postmerge-20040405-ansi:11.26
	premerge-20040404-ansi:11.25
	postmerge-autoconf:11.25
	autoconf-freeze:11.24.6.2
	premerge-autoconf:11.25
	ansi-20040316-freeze:11.23.2.1
	postmerge-20040315-windows:11.25
	premerge-20040315-windows:11.25
	windows-20040315-freeze:11.23.4.1
	autoconf-20031203:11.24
	autoconf-20031202:11.24
	autoconf-branch:11.24.0.6
	phong-branch:11.24.0.4
	photonmap-branch:11.24.0.2
	rel-6-1-DP:11.23
	windows-branch:11.23.0.4
	rel-6-0-2:11.21
	ansi-branch:11.23.0.2
	rel-6-0-1-branch:11.21.0.2
	hartley-6-0-post:11.22
	hartley-6-0-pre:11.21
	rel-6-0-1:11.21
	rel-6-0:11.21
	rel-5-4:11.10.2.2
	offsite-5-3-pre:11.16
	rel-5-3:11.10.2.2
	rel-5-2:11.10.2.2
	rel-5-1-branch:11.10.0.2
	rel-5-1:11.10
	rel-5-0:11.10
	rel-5-0-beta:11.10
	rel-4-5:11.7
	ctj-4-5-post:11.6
	ctj-4-5-pre:11.6
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.4
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.28
date	2004.05.24.04.12.51;	author morrison;	state dead;
branches;
next	11.27;

11.27
date	2004.05.10.15.30.42;	author erikg;	state Exp;
branches;
next	11.26;

11.26
date	2004.04.05.07.48.30;	author morrison;	state Exp;
branches;
next	11.25;

11.25
date	2004.02.02.17.39.02;	author morrison;	state Exp;
branches;
next	11.24;

11.24
date	2003.03.12.21.40.23;	author jra;	state Exp;
branches
	11.24.6.1;
next	11.23;

11.23
date	2002.08.20.17.07.28;	author jra;	state Exp;
branches
	11.23.2.1
	11.23.4.1;
next	11.22;

11.22
date	2002.08.15.20.54.41;	author hartley;	state Exp;
branches;
next	11.21;

11.21
date	2001.08.11.13.09.56;	author butler;	state Exp;
branches;
next	11.20;

11.20
date	2001.08.10.21.20.27;	author morrison;	state Exp;
branches;
next	11.19;

11.19
date	2001.05.16.21.37.16;	author morrison;	state Exp;
branches;
next	11.18;

11.18
date	2001.04.20.22.28.47;	author morrison;	state Exp;
branches;
next	11.17;

11.17
date	2001.03.19.22.19.22;	author butler;	state Exp;
branches;
next	11.16;

11.16
date	2000.08.24.21.48.03;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	2000.08.18.02.58.44;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	2000.08.17.19.28.48;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	2000.08.17.19.26.22;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	2000.07.25.17.50.16;	author butler;	state Exp;
branches;
next	11.11;

11.11
date	2000.07.12.04.00.16;	author cjohnson;	state Exp;
branches;
next	11.10;

11.10
date	98.11.14.08.34.35;	author mike;	state Exp;
branches
	11.10.2.1;
next	11.9;

11.9
date	98.04.28.07.26.55;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	98.03.27.03.51.43;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	97.09.23.21.38.47;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	96.12.19.21.08.47;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	96.08.27.06.26.20;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	96.07.10.19.57.36;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.07.13.05.31.16;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.07.13.03.05.12;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.53.25;	author mike;	state Rel4_4;
branches;
next	10.8;

10.8
date	94.12.30.13.25.24;	author stay;	state Exp;
branches;
next	10.7;

10.7
date	94.12.27.22.47.17;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.11.07.22.56.40;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.11.04.05.31.38;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.08.25.15.53.35;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	93.10.25.19.40.22;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	91.11.15.01.32.45;	author butler;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.37.40;	author mike;	state Rel4_0;
branches;
next	9.16;

9.16
date	91.09.23.20.38.56;	author butler;	state Exp;
branches;
next	9.15;

9.15
date	91.09.21.01.32.13;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	91.06.23.02.27.33;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	91.02.09.00.50.59;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	91.01.04.23.10.55;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	91.01.03.02.23.30;	author phil;	state Exp;
branches;
next	9.10;

9.10
date	90.12.12.03.00.49;	author phil;	state Exp;
branches;
next	9.9;

9.9
date	90.12.03.16.06.55;	author phil;	state Exp;
branches;
next	9.8;

9.8
date	90.11.07.13.44.04;	author phil;	state Exp;
branches;
next	9.7;

9.7
date	89.10.27.16.46.46;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	89.10.27.16.44.26;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	89.10.27.16.14.31;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	89.10.10.23.48.59;	author phil;	state Exp;
branches;
next	9.3;

9.3
date	89.07.28.04.59.44;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.05.19.21.05.01;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.48.35;	author mike;	state Rel3_5;
branches;
next	8.6;

8.6
date	89.04.28.06.18.04;	author mike;	state Exp;
branches;
next	8.5;

8.5
date	89.04.04.03.21.39;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	89.03.03.06.47.33;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.03.01.00.08.51;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.16.21.31.02;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.28.04;	author mike;	state Rel3_0;
branches;
next	7.6;

7.6
date	88.09.22.21.02.54;	author phil;	state Exp;
branches;
next	7.5;

7.5
date	88.09.17.07.08.34;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.09.09.23.55.52;	author phil;	state Exp;
branches;
next	7.3;

7.3
date	88.05.13.21.51.15;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.05.06.04.58.12;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.27.39;	author mike;	state Rel;
branches;
next	6.2;

6.2
date	87.09.16.22.54.39;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.52.11;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.21.52.22;	author mike;	state Rel;
branches;
next	4.5;

4.5
date	87.03.11.17.31.02;	author phil;	state Exp;
branches;
next	4.4;

4.4
date	87.02.12.22.07.22;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.02.11.04.51.59;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	86.12.30.16.55.19;	author mike;	state Rel1;
branches;
next	4.1;

4.1
date	86.12.29.02.49.29;	author mike;	state Rel1;
branches;
next	1.19;

1.19
date	86.12.19.02.02.18;	author phil;	state Exp;
branches;
next	1.18;

1.18
date	86.12.09.22.41.11;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	86.11.18.10.24.59;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	86.10.29.04.51.25;	author phil;	state Exp;
branches;
next	1.15;

1.15
date	86.10.29.03.16.36;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	86.10.25.11.32.33;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	86.10.24.09.42.28;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	86.10.24.09.40.59;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	86.10.24.06.35.47;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	86.10.24.05.30.31;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	86.10.24.04.52.20;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	86.10.24.04.37.44;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	86.10.24.03.31.29;	author phil;	state Exp;
branches;
next	1.6;

1.6
date	86.10.22.21.58.48;	author phil;	state Exp;
branches;
next	1.5;

1.5
date	86.10.22.20.35.37;	author phil;	state Exp;
branches;
next	1.4;

1.4
date	86.10.15.17.01.03;	author phil;	state Exp;
branches;
next	1.3;

1.3
date	86.10.12.23.52.38;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.08.13.10.32.58;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.08.13.07.17.30;	author mike;	state Exp;
branches;
next	;

11.10.2.1
date	2000.08.18.13.50.51;	author jra;	state Exp;
branches;
next	11.10.2.2;

11.10.2.2
date	2000.09.11.19.54.07;	author jra;	state Exp;
branches;
next	;

11.23.2.1
date	2002.09.19.18.00.51;	author morrison;	state Exp;
branches;
next	11.23.2.2;

11.23.2.2
date	2004.03.17.21.16.10;	author morrison;	state Exp;
branches;
next	;

11.23.4.1
date	2004.03.11.23.40.45;	author morrison;	state Exp;
branches;
next	;

11.24.6.1
date	2004.02.12.19.47.09;	author erikg;	state Exp;
branches;
next	11.24.6.2;

11.24.6.2
date	2004.03.15.14.06.09;	author erikg;	state Exp;
branches;
next	;


desc
@Server for remote frame buffer library
@


11.28
log
@moved to src/fbserv/
@
text
@/*
 *			F B S E R V . C
 *
 *  Remote libfb server (originally rfbd).
 *
 *  There are three ways this program can be run:
 *  Inetd Daemon - every PKG connection invokes a new copy of us,
 *	courtesy of inetd.  We process a single frame buffer
 *	open/process/close cycle and then exit.  A full installation
 *	includes setting up inetd and /etc/services to start one
 *	of these, with these entries:
 *
 * remotefb stream tcp     nowait  nobody   /usr/brlcad/bin/fbserv  fbserv
 * remotefb        5558/tcp                        # remote frame buffer
 *
 *  Stand-Alone Daemon - once started we run forever, forking a
 *	copy of ourselves for each new connection.  Each child is
 *	essentially like above, i.e. one open/process/close cycle.
 *	Useful for running a daemon on a totally "unmodified" system,
 *	or when inetd is not available.
 *	A child process is necessary because different framebuffers
 *	may be specified in each open.
 *
 *  Single-Frame-Buffer Server - we open a particular frame buffer
 *	at invocation time and leave it open.  We will accept
 *	multiple connections for this frame buffer.
 *	Frame buffer open and close requests are effectively ignored.
 *	Major purpose is to create "reattachable" frame buffers when
 *	using libfb on a window system.  In this case there is no
 *	hardware to preserve "state" information (image data, color
 *	maps, etc.).  By leaving the frame buffer open, the daemon
 *	keeps this state in memory.
 *	Requests can be interleaved from different clients.
 *
 *  Authors -
 *	Phillip Dykstra
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1995-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/fbserv/fbserv.c,v 11.27 2004/05/10 15:30:42 erikg Exp $ (ARL)";
#endif

#if defined(IRIX) && IRIX==5
#define	_BSD_COMPAT
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <signal.h>
#include <errno.h>

#if defined(HAVE_STDARG_H)
# include <stdarg.h>
#endif
#if !defined(HAVE_STDARG_H) && defined(HAVE_VARARGS_H)
# include <varargs.h>
#endif

#if defined(BSD) && !defined(CRAY2)
#	include <syslog.h>
#endif

#include <sys/socket.h>
#include <netinet/in.h>		/* For htonl(), etc */
#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <sys/wait.h>

#include <sys/time.h>		/* For struct timeval */

#include "machine.h"
#include "externs.h"		/* For malloc, getopt */
#include "fb.h"
#include "pkg.h"

#include "../libfb/pkgtypes.h"

/* These symbols are provided by libfb/server.c */
extern struct pkg_switch fb_server_pkg_switch[];
extern FBIO	*fb_server_fbp;
extern fd_set	*fb_server_select_list;			/* master copy */
extern int	*fb_server_max_fd;
extern	int	fb_server_retain_on_close;	/* !0 => we are holding a reusable FB open */
extern	int	fb_server_got_fb_free;	/* !0 => we have received an fb_free */

fd_set	select_list;			/* master copy */
int	max_fd;

extern	int	_fb_disk_enable;

static  void	main_loop(void);
static	void	comm_error(char *str);
static	void	init_syslog(void);
static	void	setup_socket(int fd);
static	int	use_syslog;	/* error messages to stderr if 0 */

static	char	*framebuffer = NULL;	/* frame buffer name */
static	int	width = 0;		/* use default size */
static	int	height = 0;
static	int	port = 0;
static	int	port_set = 0;		/* !0 if user supplied port num */
static	int	once_only = 0;
static 	int	netfd;

#define MAX_CLIENTS	32
struct pkg_conn	*clients[MAX_CLIENTS];

int	verbose = 0;


/* Hidden args: -p<port_num> -F<frame_buffer> */
static char usage[] = "\
Usage: fbserv port_num\n\
          (for a stand-alone daemon)\n\
   or  fbserv [-v] [-h] [-S squaresize]\n\
          [-W width] [-N height] port_num frame_buffer\n\
          (for a single-frame-buffer server)\n\
";

int
get_args(int argc, register char **argv)
{
	register int c;

	while ( (c = getopt( argc, argv, "hvF:s:w:n:S:W:N:p:" )) != EOF )  {
		switch( c )  {
		case 'v':
			verbose = 1;
			break;
		case 'h':
			/* high-res */
			height = width = 1024;
			break;
		case 'F':
			framebuffer = optarg;
			break;
		case 's':
		case 'S':
			height = width = atoi(optarg);
			break;
		case 'w':
		case 'W':
			width = atoi(optarg);
			break;
		case 'n':
		case 'N':
			height = atoi(optarg);
			break;
		case 'p':
			port = atoi(optarg);
			port_set = 1;
			break;

		default:		/* '?' */
			return(0);
		}
	}
	/* If no "-p port", port comes from 1st extra */
	if( (optind < argc) && (port_set == 0) ) {
		port = atoi(argv[optind++]);
		port_set = 1;
	}
	/* If no "-F framebuffer", fb comes from 2nd extra */
	if( (optind < argc) && (framebuffer == NULL) ) {
		framebuffer = argv[optind++];
	}
	if( argc > optind )
		return(0);	/* print usage */

	return(1);		/* OK */
}

/*
 *			I S _ S O C K E T
 *
 * Determine if a file descriptor corresponds to an open socket.
 * Used to detect when we are started from INETD which gives us an
 * open socket connection on fd 0.
 */
int
is_socket(int fd)
{
	struct sockaddr saddr;
	/* Should be: socklen_t namelen but SGI's are complaining... */
	int namelen;

	if( getsockname(fd,&saddr,&namelen) == 0 )
		return	1;
	else
		return	0;
}

static void
sigalarm(int code)
{
	printf("alarm %s\n", fb_server_fbp ? "FBP" : "NULL");
	if( fb_server_fbp != FBIO_NULL )
		fb_poll(fb_server_fbp);
	(void)signal( SIGALRM, sigalarm );	/* SYSV removes handler */
	alarm(1);
}

/*
 *			N E W _ C L I E N T
 */
void
new_client(struct pkg_conn *pcp)
{
	register int	i;

	if( pcp == PKC_ERROR )
		return;

	for( i = MAX_CLIENTS-1; i >= 0; i-- )  {
		if( clients[i] != NULL )  continue;
		/* Found an available slot */
		clients[i] = pcp;
		FD_SET(pcp->pkc_fd, &select_list);
		if( pcp->pkc_fd > max_fd )  max_fd = pcp->pkc_fd;
		setup_socket( pcp->pkc_fd );
		return;
	}
	fprintf(stderr,"fbserv: too many clients\n");
	pkg_close(pcp);
}

/*
 *			D R O P _ C L I E N T
 */
void
drop_client(int sub)
{
	int fd = clients[sub]->pkc_fd;

	if( clients[sub] == PKC_NULL )  return;

	FD_CLR( fd, &select_list );
	pkg_close( clients[sub] );
	clients[sub] = PKC_NULL;
	(void)close( fd );			/* double-safety */
}

/*
 *			M A I N
 */
int
main(int argc, char **argv)
{
	char	portname[32];

	/* No disk files on remote machine */
	_fb_disk_enable = 0;
	memset((void *)clients, 0, sizeof(struct pkg_conn *) * MAX_CLIENTS);

	(void)signal( SIGPIPE, SIG_IGN );
	(void)signal( SIGALRM, sigalarm );
	/*alarm(1)*/

	FD_ZERO(&select_list);
	fb_server_select_list = &select_list;
	fb_server_max_fd = &max_fd;

	/*
	 * Inetd Daemon.
	 * Check to see if we were invoked by /etc/inetd.  If so
	 * we will have an open network socket on fd=0.  Become
	 * a Transient PKG server if this is so.
	 */
	netfd = 0;
	if( is_socket(netfd) ) {
		init_syslog();
		new_client( pkg_transerver( fb_server_pkg_switch, comm_error ) );
		max_fd = 8;
		once_only = 1;
		main_loop();
		exit(0);
	}

	/* for now, make them set a port_num, for usage message */
	if ( !get_args( argc, argv ) || !port_set ) {
		(void)fputs(usage, stderr);
		exit( 1 );
	}

	/* Single-Frame-Buffer Server */
	if( framebuffer != NULL ) {
		fb_server_retain_on_close = 1;	/* don't ever close the frame buffer */

		/* open a frame buffer */
		if( (fb_server_fbp = fb_open(framebuffer, width, height)) == FBIO_NULL )
			exit(1);
		if( fb_server_fbp->if_selfd > 0 )  {
			FD_SET(fb_server_fbp->if_selfd, &select_list);
			max_fd = fb_server_fbp->if_selfd;
		}

		/* check/default port */
		if( port_set ) {
			if( port < 1024 )
				port += 5559;
		}
		sprintf(portname,"%d",port);

		/*
		 * Hang an unending listen for PKG connections
		 */
		if( (netfd = pkg_permserver(portname, 0, 0, comm_error)) < 0 )
			exit(-1);
		FD_SET(netfd, &select_list);
		if (netfd > max_fd)
			max_fd = netfd;

		main_loop();
		exit(0);
	}
	/*
	 * Stand-Alone Daemon
	 */
	/* check/default port */
	if( port_set ) {
		if( port < 1024 )
			port += 5559;
		sprintf(portname,"%d",port);
	} else {
		sprintf(portname,"%s","remotefb");
	}

	init_syslog();
	while( (netfd = pkg_permserver(portname, 0, 0, comm_error)) < 0 ) {
		sleep(5);
		continue;
		/*exit(1);*/
	}

	while(1) {
		int stat;
		struct pkg_conn	*pcp;

		pcp = pkg_getclient( netfd, fb_server_pkg_switch, comm_error, 0 );
		if( pcp == PKC_ERROR )
			break;		/* continue is unlikely to work */

		if( fork() == 0 )  {
			/* 1st level child process */
			(void)close(netfd);	/* Child is not listener */

			/* Create 2nd level child process, "double detatch" */
			if( fork() == 0 )  {
				/* 2nd level child -- start work! */
				new_client( pcp );
				once_only = 1;
				main_loop();
				exit(0);
			} else {
				/* 1st level child -- vanish */
				exit(1);
			}
		} else {
			/* Parent: lingering server daemon */
			pkg_close(pcp);	/* Daemon is not the server */
			/* Collect status from 1st level child */
			(void)wait( &stat );
		}
	}
	exit(2);	/* ERROR exit */
}

/*
 *			M A I N _ L O O P
 *
 *  Loop forever handling clients as they come and go.
 *  Access to the framebuffer may be interleaved, if the user
 *  wants it that way.
 */
static void
main_loop(void)
{
	int	nopens = 0;
	int	ncloses = 0;

	while( !fb_server_got_fb_free ) {
		fd_set infds;
		struct timeval tv;
		register int	i;

		infds = select_list;	/* struct copy */

		tv.tv_sec = 60L;
		tv.tv_usec = 0L;
		if( (select( max_fd+1, &infds, (fd_set *)0, (fd_set *)0, 
			     (void *)&tv )) == 0 ) {
			/* Process fb events while waiting for client */
			/*printf("select timeout waiting for client\n");*/
			if(fb_server_fbp) fb_poll(fb_server_fbp);
			continue;
		}
		/* Handle any events from the framebuffer */
		if (fb_server_fbp && fb_server_fbp->if_selfd > 0 && FD_ISSET(fb_server_fbp->if_selfd, &infds))
			fb_poll(fb_server_fbp);

		/* Accept any new client connections */
		if( netfd > 0 && FD_ISSET(netfd, &infds))  {
			new_client( pkg_getclient( netfd, fb_server_pkg_switch, comm_error, 0 ) );
			nopens++;
		}

		/* Process arrivals from existing clients */
		/* First, pull the data out of the kernel buffers */
		for( i = MAX_CLIENTS-1; i >= 0; i-- )  {
			if( clients[i] == NULL )  continue;
			if( pkg_process( clients[i] ) < 0 ) {
				fprintf(stderr,"pkg_process error encountered (1)\n");
			}
			if( ! FD_ISSET( clients[i]->pkc_fd, &infds ) )  continue;
			if( pkg_suckin( clients[i] ) <= 0 )  {
				/* Probably EOF */
				drop_client( i );
				ncloses++;
				continue;
			}
		}
		/* Second, process all the finished ones that we just got */
		for( i = MAX_CLIENTS-1; i >= 0; i-- )  {
			if( clients[i] == NULL )  continue;
			if( pkg_process( clients[i] ) < 0 ) {
				fprintf(stderr,"pkg_process error encountered (2)\n");
			}
		}
		if( once_only && nopens > 1 && ncloses > 1 )
			return;
	}
}

static void
init_syslog(void)
{
	use_syslog = 1;
#if defined(BSD) && !defined(CRAY2)
#   ifdef LOG_DAEMON
	openlog( "fbserv", LOG_PID|LOG_NOWAIT, LOG_DAEMON );	/* 4.3 style */
#   else
	openlog( "fbserv", LOG_PID );				/* 4.2 style */
#   endif
#endif /* BSD && !CRAY2 */
}

static void
setup_socket(int fd)
{
	int	on = 1;

#if defined(SO_KEEPALIVE)
	if( setsockopt( fd, SOL_SOCKET, SO_KEEPALIVE, (char *)&on, sizeof(on)) < 0 ) {
#if		defined(BSD) && !defined(CRAY2)
		syslog( LOG_WARNING, "setsockopt (SO_KEEPALIVE): %s", strerror(errno) );
#		endif
	}
#endif
#if defined(SO_RCVBUF)
	/* try to set our buffers up larger */
	{
		int	m = 0;
		int	n = 0;
		int	val;
		int	size;

		for( size = 256; size > 16; size /= 2 )  {
			val = size * 1024;
			m = setsockopt( fd, SOL_SOCKET, SO_RCVBUF,
				(char *)&val, sizeof(val) );
			val = size * 1024;
			n = setsockopt( fd, SOL_SOCKET, SO_SNDBUF,
				(char *)&val, sizeof(val) );
			if( m >= 0 && n >= 0 )  break;
		}
		if( m < 0 || n < 0 )  perror("fbserv setsockopt()");
	}
#endif
}

/*
 *			C O M M _ E R R O R
 *
 *  Communication error.  An error occured on the PKG link.
 *  It may be local, or it may be between us and the client we are serving.
 *  We send a copy to syslog or stderr.
 *  Don't send one down the wire, this can cause loops.
 */
static void
comm_error(char *str)
{
#if defined(BSD) && !defined(CRAY2)
	if( use_syslog )
		syslog( LOG_ERR, str );
	else
		fprintf( stderr, "%s", str );
#else
	fprintf( stderr, "%s", str );
#endif
	if(verbose) fprintf( stderr, "%s", str );
}

/*
 *			F B _ L O G
 *
 *  Handles error or log messages from the frame buffer library.
 *  We route these back to all clients in an ERROR packet.  Note that
 *  this is a replacement for the default fb_log function in libfb
 *  (which just writes to stderr).
 *
 *  Log an FB library event, when _doprnt() is not available.
 *  This version should work on practically any machine, but
 *  it serves to highlight the the grossness of the varargs package
 *  requiring the size of a parameter to be known at compile time.
 */
#if defined(HAVE_STDARG_H)
void
fb_log( char *fmt, ... )
{
	va_list ap;
	char	outbuf[4096];			/* final output string */
	int	want;
	int	i;
	int	nsent = 0;

	va_start( ap, fmt );
	(void)vsprintf( outbuf, fmt, ap );
	va_end(ap);

	want = strlen(outbuf)+1;
	for( i = MAX_CLIENTS-1; i >= 0; i-- )  {
		if( clients[i] == NULL )  continue;
		if( pkg_send( MSG_ERROR, outbuf, want, clients[i] ) != want )  {
			comm_error("pkg_send error in fb_log, message was:\n");
			comm_error(outbuf);
		} else {
			nsent++;
		}
	}
	if( nsent == 0 || verbose )  {
		/* No PKG connection open yet! */
		fputs( outbuf, stderr );
		fflush(stderr);
	}
}

/* VARARGS */
#elif !defined(HAVE_STDARG_H) && defined(HAVE_VARARGS_H)

void
fb_log( va_alist )
va_dcl
{
	va_list ap;
	register char	*sp;			/* start pointer */
	register char	*ep;			/* end pointer */
	int	longify;
	char	fbuf[64];			/* % format buffer */
	char	nfmt[256];
	char	outbuf[4096];			/* final output string */
	char	*op;				/* output buf pointer */
	int	want, got;
	int	i;
	int	nsent = 0;

	/* prefix all messages with "hostname: " */
	gethostname( outbuf, sizeof(outbuf) );
	op = &outbuf[strlen(outbuf)];
	*op++ = ':';
	*op++ = ' ';

	va_start(ap);
	sp = va_arg(ap,char *);
	while( *sp )  {
		/* Initial state:  just printing chars */
		if( *sp != '%' )  {
			*op++ = *sp;
			if( *sp == '\n' && *(sp+1) ) {
				/* newline plus text, output hostname */
				gethostname( op, sizeof(outbuf) );
				op += strlen(op);
				*op++ = ':';
				*op++ = ' ';
			}
			sp++;
			continue;
		}

		/* Saw a percent sign, find end of fmt specifier */
		longify = 0;
		ep = sp+1;
		while( *ep )  {
			if( isalpha(*ep) )
				break;
			ep++;
		}

		/* Check for digraphs, eg "%ld" */
		if( *ep == 'l' )  {
			ep++;
			longify = 1;
		}

		/* Copy off the format string */
		{
			register int len;
			len = ep-sp+1;
			strncpy( fbuf, sp, len );
			fbuf[len] = '\0';
		}
		
		/* Grab parameter from arg list, and print it */
		switch( *ep )  {
		case 'e':
		case 'E':
		case 'f':
		case 'g':
		case 'G':
			/* All floating point ==> "double" */
			{
				register double d;
				d = va_arg(ap, double);
				sprintf( op, fbuf, d );
				op = &outbuf[strlen(outbuf)];
			}
			break;

		default:
			if( longify )  {
				register long ll;
				/* Long int */
				ll = va_arg(ap, long);
				sprintf( op, fbuf, ll );
				op = &outbuf[strlen(outbuf)];
			} else {
				register int i;
				/* Regular int */
				i = va_arg(ap, int);
				sprintf( op, fbuf, i );
				op = &outbuf[strlen(outbuf)];
			}
			break;
		}
		sp = ep+1;
	}
	va_end(ap);
	*op = NULL;


	want = strlen(outbuf)+1;
	for( i = MAX_CLIENTS-1; i >= 0; i-- )  {
		if( clients[i] == NULL )  continue;
		if( pkg_send( MSG_ERROR, outbuf, want, clients[i] ) != want )  {
			comm_error("pkg_send error in fb_log, message was:\n");
			comm_error(outbuf);
		} else {
			nsent++;
		}
	}
	if( nsent == 0 || verbose )  {
		/* No PKG connection open yet! */
		fputs( outbuf, stderr );
		fflush(stderr);
	}
}
#else

#error /* no stdarg and no vararg */

#endif /* !have_stdarg_h */
@


11.27
log
@change conf.h to a wrapped config.h
@
text
@d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/fbserv/fbserv.c,v 11.26 2004/04/05 07:48:30 morrison Exp $ (ARL)";
@


11.26
log
@merge of ansi-6-0-branch into HEAD
@
text
@d53 1
a53 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d60 5
a64 1
#include "conf.h"
@


11.25
log
@update copyright to include span through 2003
@
text
@d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fbserv/fbserv.c,v 11.24 2003/03/12 21:40:23 jra Exp $ (ARL)";
d99 1
a99 1
extern const struct pkg_switch fb_server_pkg_switch[];
d111 4
a114 4
static  void	main_loop();
static	void	comm_error();
static	void	init_syslog();
static	void	setup_socket();
d141 1
a141 2
get_args( argc, argv )
register char **argv;
d201 1
a201 2
is_socket(fd)
int fd;
d204 1
d214 1
a214 2
sigalarm(code)
int	code;
d227 1
a227 2
new_client(pcp)
struct pkg_conn	*pcp;
d251 1
a251 2
drop_client( sub )
int	sub;
d267 1
a267 2
main( argc, argv )
int argc; char **argv;
d396 1
a396 1
main_loop()
d455 1
a455 1
init_syslog()
d468 1
a468 2
setup_socket(fd)
int	fd;
d510 1
a510 2
comm_error( str )
char *str;
@


11.24
log
@new_client() was incorrectly checking the clients array
@
text
@d49 1
a49 1
 *	This software is Copyright (C) 1995 by the United States Army
d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fbserv/fbserv.c,v 11.23 2002/08/20 17:07:28 jra Exp $ (ARL)";
@


11.24.6.1
log
@merge from HEAD
@
text
@d49 1
a49 1
 *	This software is Copyright (C) 1995-2004 by the United States Army
d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fbserv/fbserv.c,v 11.25 2004/02/02 17:39:02 morrison Exp $ (ARL)";
@


11.24.6.2
log
@merge from head
@
text
@d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fbserv/fbserv.c,v 11.24.6.1 2004/02/12 19:47:09 erikg Exp $ (ARL)";
@


11.23
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fbserv/fbserv.c,v 11.21 2001/08/11 13:09:56 butler Exp $ (ARL)";
d238 1
a238 1
		if( clients == NULL )  continue;
@


11.23.4.1
log
@sync to HEAD...
@
text
@d49 1
a49 1
 *	This software is Copyright (C) 1995-2004 by the United States Army
d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/fbserv/fbserv.c,v 11.25 2004/02/02 17:39:02 morrison Exp $ (ARL)";
d238 1
a238 1
		if( clients[i] != NULL )  continue;
@


11.23.2.1
log
@Initial ANSIfication
@
text
@d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fbserv/fbserv.c,v 11.23 2002/08/20 17:07:28 jra Exp $ (ARL)";
d99 1
a99 1
extern struct pkg_switch fb_server_pkg_switch[];
d111 4
a114 4
static  void	main_loop(void);
static	void	comm_error(char *str);
static	void	init_syslog(void);
static	void	setup_socket(int fd);
d141 2
a142 1
get_args(int argc, register char **argv)
d202 2
a203 1
is_socket(int fd)
a205 1
	/* Should be: socklen_t namelen but SGI's are complaining... */
d215 2
a216 1
sigalarm(int code)
d229 2
a230 1
new_client(struct pkg_conn *pcp)
d254 2
a255 1
drop_client(int sub)
d271 2
a272 1
main(int argc, char **argv)
d401 1
a401 1
main_loop(void)
d460 1
a460 1
init_syslog(void)
d473 2
a474 1
setup_socket(int fd)
d516 2
a517 1
comm_error(char *str)
@


11.23.2.2
log
@sync branch with HEAD
@
text
@d49 1
a49 1
 *	This software is Copyright (C) 1995-2004 by the United States Army
d53 1
a53 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d235 1
a235 1
		if( clients[i] != NULL )  continue;
@


11.22
log
@Converted from K&R to ANSI C - RFH
@
text
@d99 1
a99 1
extern struct pkg_switch fb_server_pkg_switch[];
d111 4
a114 4
static  void	main_loop(void);
static	void	comm_error(char *str);
static	void	init_syslog(void);
static	void	setup_socket(int fd);
d141 2
a142 1
get_args(int argc, register char **argv)
d202 2
a203 1
is_socket(int fd)
a205 1
	/* Should be: socklen_t namelen but SGI's are complaining... */
d215 2
a216 1
sigalarm(int code)
d229 2
a230 1
new_client(struct pkg_conn *pcp)
d254 2
a255 1
drop_client(int sub)
d271 2
a272 1
main(int argc, char **argv)
d401 1
a401 1
main_loop(void)
d460 1
a460 1
init_syslog(void)
d473 2
a474 1
setup_socket(int fd)
d516 2
a517 1
comm_error(char *str)
@


11.21
log
@compiler warning changes
@
text
@d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fbserv/fbserv.c,v 11.20 2001/08/10 21:20:27 morrison Exp $ (ARL)";
d99 1
a99 1
extern const struct pkg_switch fb_server_pkg_switch[];
d111 4
a114 4
static  void	main_loop();
static	void	comm_error();
static	void	init_syslog();
static	void	setup_socket();
d141 1
a141 2
get_args( argc, argv )
register char **argv;
d201 1
a201 2
is_socket(fd)
int fd;
d204 1
d214 1
a214 2
sigalarm(code)
int	code;
d227 1
a227 2
new_client(pcp)
struct pkg_conn	*pcp;
d251 1
a251 2
drop_client( sub )
int	sub;
d267 1
a267 2
main( argc, argv )
int argc; char **argv;
d396 1
a396 1
main_loop()
d455 1
a455 1
init_syslog()
d468 1
a468 2
setup_socket(fd)
int	fd;
d510 1
a510 2
comm_error( str )
char *str;
@


11.20
log
@minor changes to quell sun5
@
text
@d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fbserv/fbserv.c,v 11.19 2001/05/16 21:37:16 morrison Exp $ (ARL)";
d481 1
a481 1
		syslog( LOG_WARNING, "setsockopt (SO_KEEPALIVE): %m" );
@


11.19
log
@PRODUCTION optimizations
@
text
@d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fbserv/fbserv.c,v 11.18 2001/04/20 22:28:47 morrison Exp $ (ARL)";
d63 1
d543 1
a543 1
#if __STDC__
d573 1
a573 1
#else
d575 2
d693 5
a697 1
#endif /* !__STDC__ */
@


11.18
log
@CONST to const
@
text
@d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fbserv/fbserv.c,v 11.17 2001/03/19 22:19:22 butler Exp $ (ARL)";
d277 1
a277 1
	bzero((void *)clients, sizeof(struct pkg_conn *) * MAX_CLIENTS);
@


11.17
log
@patches to merge 5.3 into 6.0
@
text
@d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/fbserv/fbserv.c,v 11.10.2.2 2000/09/11 19:54:07 jra Exp $ (ARL)";
d98 1
a98 1
extern CONST struct pkg_switch fb_server_pkg_switch[];
@


11.16
log
@
lint
@
text
@d53 5
a57 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fbserv/fbserv.c,v 11.15 2000/08/18 02:58:44 mike Exp $ (ARL)";
a74 2
#include <sys/time.h>		/* For struct timeval */

d88 2
d415 1
a415 1
			     &tv )) == 0 ) {
@


11.15
log
@
Converted clients[] array into pointers to PKG connections, rather
than container structs with a duplicate of the fd.

Fixes the problem that Keith reported, where fbserv as started from
inetd.conf would connect with client, but not take any data.
In that case, fd==0, which was used as the marker for an empty slot
in the clients[] array.  Thus, the select() input indication would
always be skipped over, and no PKGs would be read off the network.
@
text
@d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fbserv/fbserv.c,v 11.14 2000/08/17 19:28:48 mike Exp $ (ARL)";
d483 2
a484 1
		int	m, n;
@


11.14
log
@
Removed unnecessary #ifdef
@
text
@d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fbserv/fbserv.c,v 11.13 2000/08/17 19:26:22 mike Exp $ (ARL)";
a119 4
struct client {
	int		fd;
	struct pkg_conn	*pkg;
};
d121 1
a121 1
struct client	clients[MAX_CLIENTS];
d233 1
a233 1
		if( clients[i].fd != 0 )  continue;
d235 1
a235 2
		clients[i].pkg = pcp;
		clients[i].fd = pcp->pkc_fd;
d252 1
d254 6
a259 9
	if( clients[sub].pkg != PKC_NULL )  {
		pkg_close( clients[sub].pkg );
		clients[sub].pkg = PKC_NULL;
	}
	if( clients[sub].fd != 0 )  {
		FD_CLR( clients[sub].fd, &select_list );
		close( clients[sub].fd );
		clients[sub].fd = 0;
	}
d273 1
a273 1
	bzero((void *)clients, sizeof(struct client) * MAX_CLIENTS);
d430 2
a431 2
			if( clients[i].fd == 0 )  continue;
			if( pkg_process( clients[i].pkg ) < 0 ) {
d434 2
a435 2
			if( ! FD_ISSET( clients[i].fd, &infds ) )  continue;
			if( pkg_suckin( clients[i].pkg ) <= 0 )  {
d444 2
a445 2
			if( clients[i].fd == 0 )  continue;
			if( pkg_process( clients[i].pkg ) < 0 ) {
d553 2
a554 2
		if( clients[i].fd == 0 )  continue;
		if( pkg_send( MSG_ERROR, outbuf, want, clients[i].pkg ) != want )  {
d671 2
a672 2
		if( clients[i].fd == 0 )  continue;
		if( pkg_send( MSG_ERROR, outbuf, want, clients[i].pkg ) != want )  {
@


11.13
log
@
Added comment.
@
text
@d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fbserv/fbserv.c,v 11.12 2000/07/25 17:50:16 butler Exp $ (ARL)";
a192 1
#ifdef BSD
a211 1
#endif /* BSD */
a289 1
#ifdef BSD
a304 1
#endif /* BSD */
@


11.12
log
@added include of unistd.h to get warning-free compile
@
text
@d11 5
a15 1
 *	of these.
d23 1
d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fbserv/fbserv.c,v 11.11 2000/07/12 04:00:16 cjohnson Exp $ (ARL)";
@


11.11
log
@LINT from gcc -Wall.
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fbserv/fbserv.c,v 11.10 1998/11/14 08:34:35 mike Exp $ (ARL)";
d54 1
@


11.10
log
@Added -v flag to also print messages to stderr.
Because if fb_log() is sent back to client, and client is only
writing on the network connection (not ever reading), the messages
will be lost.
This frustrated me for quite some time this evening.
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fbserv/fbserv.c,v 11.9 1998/04/28 07:26:55 mike Exp $ (ARL)";
d73 6
d133 1
d268 1
@


11.10.2.1
log
@Updated fbserv to latest revision
@
text
@d11 1
a11 5
 *	of these, with these entries:
 *
 * remotefb stream tcp     nowait  nobody   /usr/brlcad/bin/fbserv  fbserv
 * remotefb        5558/tcp                        # remote frame buffer
 *
a18 1
 *
d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fbserv/fbserv.c,v 11.15 2000/08/18 02:58:44 mike Exp $ (ARL)";
a53 1
#include <unistd.h>
a72 6
#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <sys/wait.h>
d108 4
d113 1
a113 1
struct pkg_conn	*clients[MAX_CLIENTS];
a126 1
int
d180 1
d200 1
d226 1
a226 1
		if( clients == NULL )  continue;
d228 2
a229 1
		clients[i] = pcp;
a245 1
	int fd = clients[sub]->pkc_fd;
d247 9
a255 6
	if( clients[sub] == PKC_NULL )  return;

	FD_CLR( fd, &select_list );
	pkg_close( clients[sub] );
	clients[sub] = PKC_NULL;
	(void)close( fd );			/* double-safety */
a260 1
int
d268 1
a268 1
	bzero((void *)clients, sizeof(struct pkg_conn *) * MAX_CLIENTS);
d278 1
d294 1
d427 2
a428 2
			if( clients[i] == NULL )  continue;
			if( pkg_process( clients[i] ) < 0 ) {
d431 2
a432 2
			if( ! FD_ISSET( clients[i]->pkc_fd, &infds ) )  continue;
			if( pkg_suckin( clients[i] ) <= 0 )  {
d441 2
a442 2
			if( clients[i] == NULL )  continue;
			if( pkg_process( clients[i] ) < 0 ) {
d550 2
a551 2
		if( clients[i] == NULL )  continue;
		if( pkg_send( MSG_ERROR, outbuf, want, clients[i] ) != want )  {
d668 2
a669 2
		if( clients[i] == NULL )  continue;
		if( pkg_send( MSG_ERROR, outbuf, want, clients[i] ) != want )  {
@


11.10.2.2
log
@Hack to get "struct timeval" defined and "select" call to compile under Irix 5.3
@
text
@d53 1
a53 5
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fbserv/fbserv.c,v 11.10.2.1 2000/08/18 13:50:51 jra Exp $ (ARL)";
#endif

#if defined(IRIX) && IRIX==5
#define	_BSD_COMPAT
d71 2
a85 2
#include <sys/time.h>		/* For struct timeval */

d411 1
a411 1
			     (void *)&tv )) == 0 ) {
@


11.9
log
@Performance optimization.
Only really matters for real-time ray-tracer.
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbserv/RCS/fbserv.c,v 11.8 1998/03/27 03:51:43 mike Exp mike $ (ARL)";
d115 1
d117 1
d122 1
a122 1
   or  fbserv [-h] [-S squaresize]\n\
d132 1
a132 1
	while ( (c = getopt( argc, argv, "hF:s:w:n:S:W:N:p:" )) != EOF )  {
d134 3
d518 1
d558 1
a558 1
	if( nsent == 0 )  {
d676 1
a676 1
	if( nsent == 0 )  {
@


11.8
log
@Moved server support over into libfb/server.c
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbserv/RCS/fbserv.c,v 11.7 1997/09/23 21:38:47 bparker Exp mike $ (ARL)";
d420 1
d433 4
@


11.7
log
@added some initialization
@
text
@d4 1
a4 1
 *  Remote libfb server (formerly rfbd).
d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbserv/RCS/fbserv.c,v 11.6 1996/12/19 21:08:47 jra Exp bparker $ (ARL)";
a79 1
#include "./fbserv.h"
d81 10
a90 1
#define NET_LONG_LEN	4	/* # bytes to network long */
a104 3
static	FBIO	*fbp;
static	int	single_fb = 0;	/* !0 => we are holding a reusable FB open */
static	int	got_fb_free = 0;	/* !0 => we have received an fb_free */
a113 2
static fd_set	select_list;			/* master copy */
static int	max_fd;
d201 3
a203 3
	printf("alarm %s\n", fbp ? "FBP" : "NULL");
	if( fbp != FBIO_NULL )
		fb_poll(fbp);
d270 2
d283 1
a283 1
		new_client( pkg_transerver( pkg_switch, comm_error ) );
d299 1
a299 1
		single_fb = 1;	/* don't ever close the frame buffer */
d302 1
a302 1
		if( (fbp = fb_open(framebuffer, width, height)) == FBIO_NULL )
d304 3
a306 3
		if( fbp->if_selfd > 0 )  {
			FD_SET(fbp->if_selfd, &select_list);
			max_fd = fbp->if_selfd;
d351 1
a351 1
		pcp = pkg_getclient( netfd, pkg_switch, comm_error, 0 );
d393 1
a393 1
	while( !got_fb_free ) {
d406 1
a406 1
			if(fbp) fb_poll(fbp);
d410 2
a411 2
		if (fbp && fbp->if_selfd > 0 && FD_ISSET(fbp->if_selfd, &infds))
			fb_poll(fbp);
d415 1
a415 1
			new_client( pkg_getclient( netfd, pkg_switch, comm_error, 0 ) );
a509 502
/*
 * This is where we go for message types we don't understand.
 */
void
pkgfoo(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
	fb_log( "fbserv: unable to handle message type %d\n",
		pcp->pkc_type );
	(void)free(buf);
}

/******** Here's where the hooks lead *********/

void
rfbopen(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
	int	height, width;
	char	rbuf[5*NET_LONG_LEN+1];
	int	want;

	width = pkg_glong( &buf[0*NET_LONG_LEN] );
	height = pkg_glong( &buf[1*NET_LONG_LEN] );

	if( fbp == FBIO_NULL ) {
		if( strlen(&buf[8]) == 0 )
			fbp = fb_open( NULL, width, height );
		else
			fbp = fb_open( &buf[8], width, height );
	}

	if( fbp == FBIO_NULL )  {
		(void)pkg_plong( &rbuf[0*NET_LONG_LEN], -1 );	/* ret */
		(void)pkg_plong( &rbuf[1*NET_LONG_LEN], 0 );
		(void)pkg_plong( &rbuf[2*NET_LONG_LEN], 0 );
		(void)pkg_plong( &rbuf[3*NET_LONG_LEN], 0 );
		(void)pkg_plong( &rbuf[4*NET_LONG_LEN], 0 );
	} else {
		(void)pkg_plong( &rbuf[0*NET_LONG_LEN], 0 );	/* ret */
		(void)pkg_plong( &rbuf[1*NET_LONG_LEN], fbp->if_max_width );
		(void)pkg_plong( &rbuf[2*NET_LONG_LEN], fbp->if_max_height );
		(void)pkg_plong( &rbuf[3*NET_LONG_LEN], fbp->if_width );
		(void)pkg_plong( &rbuf[4*NET_LONG_LEN], fbp->if_height );
		if(fbp->if_selfd > 0 )  {
			FD_SET(fbp->if_selfd, &select_list);
			if( fbp->if_selfd > max_fd )  max_fd = fbp->if_selfd;
		}
	}

	want = 5*NET_LONG_LEN;
	if( pkg_send( MSG_RETURN, rbuf, want, pcp ) != want )
		comm_error("pkg_send fb_open reply\n");
	if( buf ) (void)free(buf);
}

void
rfbclose(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
	char	rbuf[NET_LONG_LEN+1];
	
	if( single_fb ) {
		/*
		 * We are playing FB server so we don't really close the
		 * frame buffer.  We should flush output however.
		 */
		(void)fb_flush( fbp );
		(void)pkg_plong( &rbuf[0], 0 );		/* return success */
	} else {
		if(fbp->if_selfd > 0 )  {
			FD_CLR(fbp->if_selfd, &select_list);
		}
		(void)pkg_plong( &rbuf[0], fb_close( fbp ) );
		fbp = FBIO_NULL;
	}
	/* Don't check for errors, SGI linger mode or other events
	 * may have already closed down all the file descriptors.
	 * If communication has broken, other end will know we are gone.
	 */
	(void)pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

void
rfbfree(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
	char	rbuf[NET_LONG_LEN+1];
	
	(void)pkg_plong( &rbuf[0], fb_free( fbp ) );
	fbp = FBIO_NULL;
	if( pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp ) != NET_LONG_LEN )
		comm_error("pkg_send fb_free reply\n");
	if( buf ) (void)free(buf);

	got_fb_free = 1;
}

void
rfbclear(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
	RGBpixel bg;
	char	rbuf[NET_LONG_LEN+1];

	bg[RED] = buf[0];
	bg[GRN] = buf[1];
	bg[BLU] = buf[2];

	(void)pkg_plong( rbuf, fb_clear( fbp, bg ) );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

void
rfbread(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
	int	x, y, num;
	int	ret;
	static unsigned char	*scanbuf = NULL;
	static int	buflen = 0;

	x = pkg_glong( &buf[0*NET_LONG_LEN] );
	y = pkg_glong( &buf[1*NET_LONG_LEN] );
	num = pkg_glong( &buf[2*NET_LONG_LEN] );

	if( num*sizeof(RGBpixel) > buflen ) {
		if( scanbuf != NULL )
			free( (char *)scanbuf );
		buflen = num*sizeof(RGBpixel);
		if( buflen < 1024*sizeof(RGBpixel) )
			buflen = 1024*sizeof(RGBpixel);
		if( (scanbuf = (unsigned char *)malloc( buflen )) == NULL ) {
			fb_log("fb_read: malloc failed!");
			if( buf ) (void)free(buf);
			buflen = 0;
			return;
		}
	}

	ret = fb_read( fbp, x, y, scanbuf, num );
	if( ret < 0 )  ret = 0;		/* map error indications */
	/* sending a 0-length package indicates error */
	pkg_send( MSG_RETURN, scanbuf, ret*sizeof(RGBpixel), pcp );
	if( buf ) (void)free(buf);
}

void
rfbwrite(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
	int	x, y, num;
	char	rbuf[NET_LONG_LEN+1];
	int	ret;
	int	type;

	x = pkg_glong( &buf[0*NET_LONG_LEN] );
	y = pkg_glong( &buf[1*NET_LONG_LEN] );
	num = pkg_glong( &buf[2*NET_LONG_LEN] );
	type = pcp->pkc_type;
	ret = fb_write( fbp, x, y, (unsigned char *)&buf[3*NET_LONG_LEN], num );

	if( type < MSG_NORETURN ) {
		(void)pkg_plong( &rbuf[0*NET_LONG_LEN], ret );
		pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	}
	if( buf ) (void)free(buf);
}

/*
 *			R F B R E A D R E C T
 */
void
rfbreadrect(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
	int	xmin, ymin;
	int	width, height;
	int	num;
	int	ret;
	static unsigned char	*scanbuf = NULL;
	static int	buflen = 0;

	xmin = pkg_glong( &buf[0*NET_LONG_LEN] );
	ymin = pkg_glong( &buf[1*NET_LONG_LEN] );
	width = pkg_glong( &buf[2*NET_LONG_LEN] );
	height = pkg_glong( &buf[3*NET_LONG_LEN] );
	num = width * height;

	if( num*sizeof(RGBpixel) > buflen ) {
		if( scanbuf != NULL )
			free( (char *)scanbuf );
		buflen = num*sizeof(RGBpixel);
		if( buflen < 1024*sizeof(RGBpixel) )
			buflen = 1024*sizeof(RGBpixel);
		if( (scanbuf = (unsigned char *)malloc( buflen )) == NULL ) {
			fb_log("fb_read: malloc failed!");
			if( buf ) (void)free(buf);
			buflen = 0;
			return;
		}
	}

	ret = fb_readrect( fbp, xmin, ymin, width, height, scanbuf );
	if( ret < 0 )  ret = 0;		/* map error indications */
	/* sending a 0-length package indicates error */
	pkg_send( MSG_RETURN, scanbuf, ret*sizeof(RGBpixel), pcp );
	if( buf ) (void)free(buf);
}

/*
 *			R F B W R I T E R E C T
 */
void
rfbwriterect(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
	int	x, y;
	int	width, height;
	char	rbuf[NET_LONG_LEN+1];
	int	ret;
	int	type;

	x = pkg_glong( &buf[0*NET_LONG_LEN] );
	y = pkg_glong( &buf[1*NET_LONG_LEN] );
	width = pkg_glong( &buf[2*NET_LONG_LEN] );
	height = pkg_glong( &buf[3*NET_LONG_LEN] );

	type = pcp->pkc_type;
	ret = fb_writerect( fbp, x, y, width, height,
		(unsigned char *)&buf[4*NET_LONG_LEN] );

	if( type < MSG_NORETURN ) {
		(void)pkg_plong( &rbuf[0*NET_LONG_LEN], ret );
		pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	}
	if( buf ) (void)free(buf);
}

void
rfbcursor(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
	int	mode, x, y;
	char	rbuf[NET_LONG_LEN+1];

	mode = pkg_glong( &buf[0*NET_LONG_LEN] );
	x = pkg_glong( &buf[1*NET_LONG_LEN] );
	y = pkg_glong( &buf[2*NET_LONG_LEN] );

	(void)pkg_plong( &rbuf[0], fb_cursor( fbp, mode, x, y ) );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

void
rfbgetcursor(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
	int	ret;
	int	mode, x, y;
	char	rbuf[4*NET_LONG_LEN+1];

	ret = fb_getcursor( fbp, &mode, &x, &y );
	(void)pkg_plong( &rbuf[0*NET_LONG_LEN], ret );
	(void)pkg_plong( &rbuf[1*NET_LONG_LEN], mode );
	(void)pkg_plong( &rbuf[2*NET_LONG_LEN], x );
	(void)pkg_plong( &rbuf[3*NET_LONG_LEN], y );
	pkg_send( MSG_RETURN, rbuf, 4*NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

void
rfbsetcursor(pcp, buf)
struct pkg_conn *pcp;
char		*buf;
{
	char	rbuf[NET_LONG_LEN+1];
	int	ret;
	int	xbits, ybits;
	int	xorig, yorig;

	xbits = pkg_glong( &buf[0*NET_LONG_LEN] );
	ybits = pkg_glong( &buf[1*NET_LONG_LEN] );
	xorig = pkg_glong( &buf[2*NET_LONG_LEN] );
	yorig = pkg_glong( &buf[3*NET_LONG_LEN] );

	ret = fb_setcursor( fbp, (unsigned char *)&buf[4*NET_LONG_LEN],
		xbits, ybits, xorig, yorig );

	if( pcp->pkc_type < MSG_NORETURN ) {
		(void)pkg_plong( &rbuf[0*NET_LONG_LEN], ret );
		pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	}
	if( buf ) (void)free(buf);
}

/*OLD*/
void
rfbscursor(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
	int	mode, x, y;
	char	rbuf[NET_LONG_LEN+1];

	mode = pkg_glong( &buf[0*NET_LONG_LEN] );
	x = pkg_glong( &buf[1*NET_LONG_LEN] );
	y = pkg_glong( &buf[2*NET_LONG_LEN] );

	(void)pkg_plong( &rbuf[0], fb_scursor( fbp, mode, x, y ) );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

/*OLD*/
void
rfbwindow(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
	int	x, y;
	char	rbuf[NET_LONG_LEN+1];

	x = pkg_glong( &buf[0*NET_LONG_LEN] );
	y = pkg_glong( &buf[1*NET_LONG_LEN] );

	(void)pkg_plong( &rbuf[0], fb_window( fbp, x, y ) );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

/*OLD*/
void
rfbzoom(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
	int	x, y;
	char	rbuf[NET_LONG_LEN+1];

	x = pkg_glong( &buf[0*NET_LONG_LEN] );
	y = pkg_glong( &buf[1*NET_LONG_LEN] );

	(void)pkg_plong( &rbuf[0], fb_zoom( fbp, x, y ) );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

void
rfbview(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
	int	ret;
	int	xcenter, ycenter, xzoom, yzoom;
	char	rbuf[NET_LONG_LEN+1];

	xcenter = pkg_glong( &buf[0*NET_LONG_LEN] );
	ycenter = pkg_glong( &buf[1*NET_LONG_LEN] );
	xzoom = pkg_glong( &buf[2*NET_LONG_LEN] );
	yzoom = pkg_glong( &buf[3*NET_LONG_LEN] );

	ret = fb_view( fbp, xcenter, ycenter, xzoom, yzoom );
	(void)pkg_plong( &rbuf[0], ret );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

void
rfbgetview(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
	int	ret;
	int	xcenter, ycenter, xzoom, yzoom;
	char	rbuf[5*NET_LONG_LEN+1];

	ret = fb_getview( fbp, &xcenter, &ycenter, &xzoom, &yzoom );
	(void)pkg_plong( &rbuf[0*NET_LONG_LEN], ret );
	(void)pkg_plong( &rbuf[1*NET_LONG_LEN], xcenter );
	(void)pkg_plong( &rbuf[2*NET_LONG_LEN], ycenter );
	(void)pkg_plong( &rbuf[3*NET_LONG_LEN], xzoom );
	(void)pkg_plong( &rbuf[4*NET_LONG_LEN], yzoom );
	pkg_send( MSG_RETURN, rbuf, 5*NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

void
rfbrmap(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
	register int	i;
	char	rbuf[NET_LONG_LEN+1];
	ColorMap map;
	char	cm[256*2*3];

	(void)pkg_plong( &rbuf[0*NET_LONG_LEN], fb_rmap( fbp, &map ) );
	for( i = 0; i < 256; i++ ) {
		(void)pkg_pshort( cm+2*(0+i), map.cm_red[i] );
		(void)pkg_pshort( cm+2*(256+i), map.cm_green[i] );
		(void)pkg_pshort( cm+2*(512+i), map.cm_blue[i] );
	}
	pkg_send( MSG_DATA, cm, sizeof(cm), pcp );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

/*
 *			R F B W M A P
 *
 *  Accept a color map sent by the client, and write it to the framebuffer.
 *  Network format is to send each entry as a network (IBM) order 2-byte
 *  short, 256 red shorts, followed by 256 green and 256 blue, for a total
 *  of 3*256*2 bytes.
 */
void
rfbwmap(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
	int	i;
	char	rbuf[NET_LONG_LEN+1];
	long	ret;
	ColorMap map;

	if( pcp->pkc_len == 0 )
		ret = fb_wmap( fbp, COLORMAP_NULL );
	else {
		for( i = 0; i < 256; i++ ) {
			map.cm_red[i] = pkg_gshort( buf+2*(0+i) );
			map.cm_green[i] = pkg_gshort( buf+2*(256+i) );
			map.cm_blue[i] = pkg_gshort( buf+2*(512+i) );
		}
		ret = fb_wmap( fbp, &map );
	}
	(void)pkg_plong( &rbuf[0], ret );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

void
rfbflush(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
	int	ret;
	char	rbuf[NET_LONG_LEN+1];

	ret = fb_flush( fbp );

	if( pcp->pkc_type < MSG_NORETURN ) {
		(void)pkg_plong( rbuf, ret );
		pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	}
	if( buf ) (void)free(buf);
}

void
rfbpoll(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
	(void)fb_poll( fbp );
	if( buf ) (void)free(buf);
}

/*
 *  At one time at least we couldn't send a zero length PKG
 *  message back and forth, so we receive a dummy long here.
 */
void
rfbhelp(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
	long	ret;
	char	rbuf[NET_LONG_LEN+1];

	(void)pkg_glong( &buf[0*NET_LONG_LEN] );

	ret = fb_help(fbp);
	(void)pkg_plong( &rbuf[0], ret );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

/**************************************************************/
@


11.6
log
@inconsistency in syslog ifdefs.
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbserv/RCS/fbserv.c,v 11.5 1996/08/27 06:26:20 mike Exp jra $ (ARL)";
d96 1
a96 1
static	int	port_set;		/* !0 if user supplied port num */
d98 2
a99 2
static	int	single_fb;	/* !0 => we are holding a reusable FB open */
static	int	got_fb_free;	/* !0 => we have received an fb_free */
d260 1
@


11.5
log
@SunOS 4.1.4 declaration mismatch
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbserv/RCS/fbserv.c,v 11.4 1996/07/10 19:57:36 jra Exp mike $ (ARL)";
d455 2
a456 2
	if( setsockopt( fd, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on)) < 0 ) {
#		ifndef CRAY2
@


11.4
log
@Fixed some declaration problems.
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbserv/RCS/fbserv.c,v 11.3 1995/07/13 05:31:16 mike Exp jra $ (ARL)";
d448 1
a448 1
void
@


11.3
log
@Added support for multiple simultaneous clients.
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d89 1
d234 1
d448 1
@


11.2
log
@Improved conditionals a tad.
@
text
@d17 2
d21 1
a21 1
 *	multiple connections for this frame buffer, one at a time.
d28 1
d35 2
a36 3
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
d38 5
d44 2
a45 2
 *	This software is Copyright (C) 1986 by the United States Army.
 *	All rights reserved.
d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbserv/RCS/fbserv.c,v 11.1 1995/01/04 09:53:25 mike Rel4_4 mike $ (BRL)";
d86 1
a87 1
static	void	do1();
a90 2
static	struct	pkg_conn *rem_pcp;

d99 2
d102 10
d173 2
d204 47
a253 3
	int	netfd;
	int	fbfd;
	int	maxfd;
a255 1

d263 2
d275 4
a278 2
		rem_pcp = pkg_transerver( pkg_switch, comm_error );
		do1();
d296 4
a300 3
		/* If zero, one isn't provided.  Don't want to select on stdin by accident. */
		fbfd = fbp->if_selfd;

d309 1
a309 1
		 * Listen for PKG connections
d313 3
d317 1
a317 33
		maxfd = netfd;
		if (fbfd > maxfd)
			maxfd = fbfd;

		/* loop forever handling clients */
		while( !got_fb_free ) {
			fd_set infds;
			struct timeval tv;

			FD_ZERO(&infds);
			FD_SET(netfd, &infds);
			if (fbfd > 0)
				FD_SET(fbfd, &infds);
			tv.tv_sec = 1L;
			tv.tv_usec = 0L;
			if( (select( maxfd+1, &infds, (fd_set *)0, (fd_set *)0, 
				     &tv )) == 0 ) {
				/* Process fb events while waiting for client */
				/*printf("select timeout waiting for client\n");*/
				fb_poll(fbp);
				continue;
			}
			if (fbfd > 0 && FD_ISSET(fbfd, &infds))
				fb_poll(fbp);

			if (FD_ISSET(netfd, &infds))
			{
				rem_pcp = pkg_getclient( netfd, pkg_switch, comm_error, 0 );
				if( rem_pcp == PKC_ERROR )
					break;
				do1();
			}
		}
d341 4
a344 2
		rem_pcp = pkg_getclient( netfd, pkg_switch, comm_error, 0 );
		if( rem_pcp == PKC_ERROR )
d354 3
a356 1
				do1();
d364 1
a364 1
			pkg_close(rem_pcp);	/* Daemon is not the server */
d372 7
d380 54
d446 2
a447 2
static void
do1()
d452 1
a452 1
	if( setsockopt( rem_pcp->pkc_fd, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on)) < 0 ) {
d461 1
a461 1
		int	n;
d463 1
a463 11
#define MAXVAL	(31*1024)
		val = MAXVAL;
		n = setsockopt( rem_pcp->pkc_fd, SOL_SOCKET,
			SO_RCVBUF, (char *)&val, sizeof(val) );
		if( n < 0 )  perror("setsockopt: SO_RCVBUF");
		val = MAXVAL;
		n = setsockopt( rem_pcp->pkc_fd, SOL_SOCKET,
			SO_SNDBUF, (char *)&val, sizeof(val) );
		if( n < 0 )  perror("setsockopt: SO_SNDBUF");
	}
#endif
d465 8
a472 12
	/*
	 * This used to be simply:
	 *	while( pkg_block(rem_pcp) > 0 ) ;
	 * but libfb event handling requires us to break it up.
	 */
	for(;;) {
		fd_set	infds;
		struct timeval tv;

		if( pkg_process( rem_pcp ) < 0 ) {
			printf("pkg_process error encountered\n");
			continue;
d474 2
a475 26

		FD_ZERO( &infds );
		FD_SET( rem_pcp->pkc_fd, &infds );
		tv.tv_sec = 1L;
		tv.tv_usec = 0L;

		if( select( rem_pcp->pkc_fd+1, &infds, (fd_set *)0, 
			    (fd_set *)0, &tv ) != 0 ){
			if( pkg_suckin( rem_pcp ) <= 0 ) {
				/* Probably EOF */
				break;
			}
		} else {
			/* Timeout - check for fb events */
			/*printf("select timeout in do1()\n");*/
			if( fbp != FBIO_NULL )
				fb_poll(fbp);
			else
				break;
		}
#if 0
		if( pkg_process( rem_pcp ) < 0 ) {
			printf("pkg_process error encountered\n");
			continue;
		}
		/*do_other_stuff();*/
a476 8
	}

	if( !single_fb && fbp != FBIO_NULL )
		fb_close(fbp);
	if( rem_pcp != PKC_NULL ) {
		pkg_close( rem_pcp );
		rem_pcp = PKC_NULL;	/* so we wont use fb_log() */
	}
a527 1
	/*printf("fbserv: I have been asked to open \"%s\"\n", &buf[8]);*/
a534 6
#if 0
	{	char s[81];
sprintf( s, "Device: \"%s\"", &buf[8] );
fb_log(s);
	}
#endif
d547 4
d574 3
d1007 1
a1007 1
 *  We route these back to our client in an ERROR packet.  Note that
d1023 2
a1029 6
	if( rem_pcp == PKC_NULL ) {
		/* PKG connection not open yet! */
		printf("%s", outbuf);
		fflush(stdout);
		return;
	}
d1031 8
a1038 3
	if( pkg_send( MSG_ERROR, outbuf, want, rem_pcp ) != want )  {
		comm_error("pkg_send error in fb_log, message was:\n");
		comm_error(outbuf);
d1040 5
d1061 2
d1145 1
d1147 1
a1147 7
	*op = NULL;
	if( rem_pcp == PKC_NULL ) {
		/* PKG connection not open yet! */
		printf("%s", outbuf);
		fflush(stdout);
		return;
	}
d1149 8
a1156 3
	if( (got = pkg_send( MSG_ERROR, outbuf, want, rem_pcp )) != want )  {
		comm_error("pkg_send error in fb_log, message was:\n");
		comm_error(outbuf);
d1158 5
a1162 1
	return;
@


11.1
log
@Release_4.4
@
text
@d41 1
a41 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbserv/RCS/fbserv.c,v 10.8 94/12/30 13:25:24 stay Exp $ (BRL)";
d348 1
a348 1
#ifdef BSD
d355 2
a356 2
#if BSD >= 43
	/* try to set our buffers to 32k bytes */
d360 2
a361 1
		val = 32767;
d365 1
a365 1
		val = 32767;
@


10.8
log
@fixed call to elif
@
text
@d41 1
a41 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/fbserv/RCS/fbserv.c,v 10.7 1994/12/27 22:47:17 mike Exp stay $ (BRL)";
@


10.7
log
@Bug #65 -- added rbfsetcursor.
@
text
@d41 1
a41 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbserv/RCS/fbserv.c,v 10.6 94/11/07 22:56:40 mike Exp Locker: mike $ (BRL)";
d50 1
d53 2
a54 1
#elif defined(HAVE_VARARGS_H)
d57 1
@


10.6
log
@Added polling mods from Tim Smith.
@
text
@d41 1
a41 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbserv/RCS/fbserv.c,v 10.5 94/11/04 05:31:38 mike Exp Locker: mike $ (BRL)";
d722 25
@


10.5
log
@Irix 6
@
text
@d41 1
a41 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbserv/RCS/fbserv.c,v 10.4 94/08/25 15:53:35 gdurf Exp Locker: mike $ (BRL)";
d186 2
d228 3
d244 4
d254 3
a256 1
			FD_SET(netfd, &infds);	/* XXX FD_SET(fbfd, &infds) */
d259 1
a259 1
			if( (select( netfd+1, &infds, (fd_set *)0, (fd_set *)0, 
d266 10
a275 4
			rem_pcp = pkg_getclient( netfd, pkg_switch, comm_error, 0 );
			if( rem_pcp == PKC_ERROR )
				break;
			do1();
@


10.4
log
@Converted bsdselect to select
@
text
@d41 1
a41 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbserv/RCS/fbserv.c,v 10.3 1993/10/25 19:40:22 mike Exp gdurf $ (BRL)";
d445 1
a445 1
	int	want, did;
d479 1
a479 1
	if( (did = pkg_send( MSG_RETURN, rbuf, want, pcp )) != want )
a887 1
	int	x;	/* dummy */
d891 1
a891 1
	x = pkg_glong( &buf[0*NET_LONG_LEN] );
d919 1
a919 1
	int	want, got;
d932 1
a932 1
	if( (got = pkg_send( MSG_ERROR, outbuf, want, rem_pcp )) != want )  {
@


10.3
log
@IRIX 5.0.1
New fb.h
@
text
@d41 1
a41 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbserv/RCS/fbserv.c,v 10.2 91/11/15 01:32:45 butler Exp Locker: mike $ (BRL)";
d44 2
a46 1
#define _BSD_TYPES		/* Needed for IRIX 5.0.1 */
d50 1
a50 1
#if __STDC__ && !apollo
d52 1
a52 1
#else
d55 1
d57 1
a57 2
#ifdef BSD
# ifndef CRAY2
d59 2
a60 2
# endif
#include <sys/types.h>
a62 1
#endif
d64 2
a73 1
extern	char	*malloc();
a100 4
extern int	getopt();
extern char	*optarg;
extern int	optind;

d241 9
a249 3
			int	infds, fds;
			infds = (1<<netfd);	/*XXX (1<<fbfd) */
			if( (fds = bsdselect( infds, 1, 0 )) == 0 ) {
d357 3
a359 2
		long	infds;
		long	fds;
d364 8
a371 3
		infds = (1<<rem_pcp->pkc_fd);
		if( (fds = bsdselect( infds, 1, 0 )) != 0 ) {
			/*printf("select returned %d\n", fds);*/
@


10.2
log
@potential fix to "undead" fbserv lingering and consuming user/system CPU.
@
text
@d41 1
a41 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/fbserv/RCS/fbserv.c,v 10.1 91/10/12 06:37:40 mike Rel4_0 Locker: butler $ (BRL)";
d45 1
d541 1
a541 1
	static char	*scanbuf = NULL;
d550 1
a550 1
			free( scanbuf );
d554 1
a554 1
		if( (scanbuf = malloc( buflen )) == NULL ) {
d583 1
a583 1
	ret = fb_write( fbp, x, y, (RGBpixel *)&buf[3*NET_LONG_LEN], num );
d604 1
a604 1
	static char	*scanbuf = NULL;
d615 1
a615 1
			free( scanbuf );
d619 1
a619 1
		if( (scanbuf = malloc( buflen )) == NULL ) {
d655 1
a655 1
		(RGBpixel *)&buf[4*NET_LONG_LEN] );
@


10.1
log
@Release_4.0
@
text
@d41 1
a41 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbserv/RCS/fbserv.c,v 9.16 91/09/23 20:38:56 butler Exp $ (BRL)";
d371 2
@


9.16
log
@removed unused label "fail:"
@
text
@d41 1
a41 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbserv/RCS/fbserv.c,v 9.15 91/09/21 01:32:13 mike Exp $ (BRL)";
@


9.15
log
@Silence syslog messages of the form:
 pkg_send fb_close reply
 Don't check for errors, SGI linger mode or other events
 may have already closed down all the file descriptors.
 If communication has broken, other end will know we are gone.
@
text
@d41 1
a41 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbserv/RCS/fbserv.c,v 9.14 91/06/23 02:27:33 mike Exp $ (BRL)";
a452 1
fail:
@


9.14
log
@Silenced compiler warning about main() having no exit point.
@
text
@d41 1
a41 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbserv/RCS/fbserv.c,v 9.13 91/02/09 00:50:59 mike Exp $ (BRL)";
d491 5
a495 2
	if( pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp ) != NET_LONG_LEN )
		comm_error("pkg_send fb_close reply\n");
@


9.13
log
@lint
@
text
@d41 1
a41 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbserv/RCS/fbserv.c,v 9.12 91/01/04 23:10:55 mike Exp $ (BRL)";
d280 3
a282 3
		if( rem_pcp == PKC_ERROR )  {
			exit(2);	/* continue?! */
		}
d303 1
@


9.12
log
@Increase both xmit and rcv buffers
@
text
@d41 1
a41 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbserv/RCS/fbserv.c,v 9.11 91/01/03 02:23:30 phil Exp $ (BRL)";
d173 1
a173 1
static void *
@


9.11
log
@Added new packages for fb_getview(), fb_poll(), etc.
@
text
@d41 1
a41 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbserv/RCS/fbserv.c,v 9.10 90/12/12 03:00:49 phil Exp $ (BRL)";
d331 1
a331 1
	/* try to set our receive buffer to 32k bytes */
d334 2
a335 1
		int	val = 32767;
d339 4
@


9.10
log
@Working experimental version.
@
text
@d41 1
a41 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbserv/RCS/fbserv.c,v 9.9 90/12/03 16:06:55 phil Exp $ (BRL)";
a357 1
				printf("pkg_suckin error or EOF\n");
d671 19
d706 1
d723 1
d741 39
d847 9
@


9.9
log
@Simple SIGALRM -> fb_flush() scheme.  Bad because if can interrupt
pkg system calls and because Xlib calls are not reentrant (so alarmed
calls to fb_flush may clobber whatever if_xxx may have been doing).
Saved for reference.
@
text
@d41 1
a41 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbserv/RCS/fbserv.c,v 9.8 90/11/07 13:44:04 phil Exp $ (BRL)";
d174 2
a175 1
sigalarm()
d177 1
a177 1
	/*printf("alarm %s\n", fbp ? "FBP" : "NULL");*/
d179 1
a179 1
		fb_flush(fbp);
d196 1
a196 1
	alarm(1);
d243 8
d341 34
a374 2
	while( pkg_block(rem_pcp) > 0 )
		;
@


9.8
log
@Changed _disk_enable to _fb_disk_enable.
@
text
@d41 1
a41 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbserv/RCS/fbserv.c,v 9.7 89/10/27 16:46:46 mike Exp $ (BRL)";
d173 10
d194 2
d337 1
a337 1
	if( rem_pcp != PKC_NULL )
d339 2
@


9.7
log
@This one works, and has been cleaned up a bit.
@
text
@d41 1
a41 1
static char RCSid[] = "@@(#)$Header: fbserv.c,v 9.6 89/10/27 16:44:26 mike Locked $ (BRL)";
d72 1
a72 1
extern	int	_disk_enable;
d181 1
a181 1
	_disk_enable = 0;
@


9.6
log
@This one works
@
text
@d41 1
a41 1
static char RCSid[] = "@@(#)$Header: fbserv.c,v 9.5 89/10/27 16:14:31 mike Locked $ (BRL)";
d196 1
a196 1
		do1( netfd );
d233 1
a233 3
			/*printf("Accepted connection 0x%x\n", rem_pcp);*/
			do1(netfd);
			/*printf("Closed connection 0x%x\n", rem_pcp);*/
a249 1
printf("permserver start\n");fflush(stdout);
a257 1
printf("awaiting client, netfd=%d\n",netfd);fflush(stdout);
a258 1
printf("got client on fd=%d\n", rem_pcp->pkc_fd);fflush(stdout);
a261 1
printf("forking\n");fflush(stdout);
a264 1
printf("child closing netfd %d\n", netfd);fflush(stdout);
a269 1
printf("2nd child back from do1, exiting\n");fflush(stdout);
a276 1
printf("Parent closing client on fd=%d\n", rem_pcp->pkc_fd);fflush(stdout);
a303 1
printf("setsockopt KEEPALIVE error\n");fflush(stdout);
a319 1
/*printf("child: into pkg loop\n");fflush(stdout);*/
@


9.5
log
@Standalone daemon works now.  One file descriptor still seems to be
dangling.
@
text
@d41 1
a41 1
static char RCSid[] = "@@(#)$Header: fbserv.c,v 9.4 89/10/10 23:48:59 mike Locked $ (BRL)";
d251 1
a251 1
	/*init_syslog();/*XXX*/
d261 1
a261 1
printf("awaiting client\n");fflush(stdout);
d263 1
a263 1
printf("got client\n");fflush(stdout);
d269 1
a269 1
			/* Child Process */
d271 1
d285 1
d307 1
a307 2
do1(netfd)
int netfd;
d312 2
a313 1
	if( setsockopt( netfd, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on)) < 0 ) {
@


9.4
log
@rfbd => fbserv
Three modes of operation.  Stand-Alone daemon doesn't work yet.  There
are problems with reusable sock addrs.  Inetd operation is not yet tested.
This version has debugging comments in it but was checked in as a major
checkpoint.  Added fbflush, fbfree, fbscursor to server.
@
text
@d41 1
a41 1
static char RCSid[] = "@@(#)$Header: fbserv.c,v 9.3 89/07/28 04:59:44 mike Exp $ (BRL)";
d250 9
d261 1
a261 11
		/*
		 * Listen for PKG connections, no /etc/inetd
		 */
		/*init_syslog();/*XXX*/
/*printf("permserver start\n");fflush(stdout);*/
		if( (netfd = pkg_permserver(portname, 0, 0, comm_error)) < 0 ) {
			sleep(5);
			continue;
			/*exit(1);*/
		}
printf("getting client\n");fflush(stdout);
d263 2
a264 1
		if( rem_pcp == PKC_ERROR )
d266 1
d269 4
a272 1
			/* Child */
d283 3
a285 3
			/* Original server daemon */
printf("parent closing netfd\n");fflush(stdout);
			(void)close(netfd);
@


9.3
log
@Apollo fixes
@
text
@d2 1
a2 1
 *		R F B D . C
d4 1
a4 1
 *  Remote libfb server.
d6 21
d41 1
a41 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 9.2 89/05/19 21:05:01 mike Exp $ (BRL)";
d67 1
a67 1
#include "./rfbd.h"
d75 3
d80 6
d87 2
d90 83
a175 1
	int	on = 1;
d177 1
d179 1
d186 6
a191 1
	/* Transient server, started by /etc/inetd, network fd=0 */
d193 58
a250 3
	rem_pcp = pkg_transerver( pkg_switch, comm_error );
#else
	while(1)  {
d255 4
a258 1
		if( (netfd = pkg_permserver("remotefb", 0, 0, comm_error)) < 0 )
d260 3
d265 2
a266 1
			continue;
d271 3
a273 1
				break;
d280 1
d285 1
a285 1
#endif
d287 5
a291 2
#ifdef BSD
# ifndef CRAY2
d293 1
a293 1
	openlog( "rfbd", LOG_PID|LOG_NOWAIT, LOG_DAEMON );	/* 4.3 style */
d295 1
a295 1
	openlog( "rfbd", LOG_PID );				/* 4.2 style */
d297 10
a306 1
# endif
d314 1
d324 1
d328 1
a328 1
	if( fbp != FBIO_NULL )
a331 1
	exit(0);
d347 4
a350 1
	syslog( LOG_ERR, str );
d352 1
a352 1
	fprintf( stderr, "%s\n", str );
d364 1
a364 1
	fb_log( "rfbd: unable to handle message type %d\n",
d383 7
a389 4
	if( strlen(&buf[8]) == 0 )
		fbp = fb_open( NULL, width, height );
	else
		fbp = fb_open( &buf[8], width, height );
d398 1
d424 12
a435 2

	(void)pkg_plong( &rbuf[0], fb_close( fbp ) );
d439 10
d450 5
d622 17
d724 17
d788 6
d899 6
@


9.2
log
@Eliminated old Cray (UNICOS 3) hack.
Added STDC support
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 9.1 89/05/19 05:48:35 mike Rel3_5 $ (BRL)";
d27 1
a27 1
#if __STDC__
@


9.1
log
@Release_3.5
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 8.6 89/04/28 06:18:04 mike Exp $ (BRL)";
d27 5
a31 1
#include <varargs.h>
a53 4
void		fb_log();
#ifdef CRAY
void		rfbd_log();
#endif
a161 4
#ifdef CRAY
	rfbd_log( "rfbd: unable to handle message type %d\n",
		pcp->pkc_type );
#else
a163 1
#endif
a188 3
#ifdef CRAY
rfbd_log(s);
#else
a189 1
#endif
a263 3
#ifdef CRAY
			rfbd_log("fb_read: malloc failed!");
#else
a264 1
#endif
a328 3
#ifdef CRAY
			rfbd_log("fb_read: malloc failed!");
#else
a329 1
#endif
d511 19
a531 4
#ifdef CRAY
/* Segldr can't handle the multiple defines of fb_log here & in libfb */
rfbd_log( va_alist )
#else
a532 1
#endif
d635 1
@


8.6
log
@Added a pkg_close(), some error checking.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 8.5 89/04/04 03:21:39 mike Locked $ (BRL)";
@


8.5
log
@Cray2 UNICOS 4 does NOT have syslog
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 8.4 89/03/03 06:47:33 mike Locked $ (BRL)";
d130 2
d140 2
a141 1
 *  We send a copy down the wire, and another to syslog.
a151 1
/**	(void)pkg_send( MSG_ERROR, str, strlen(str)+1, rem_pcp ); **/
d181 1
d215 3
a217 1
	pkg_send( MSG_RETURN, rbuf, 5*NET_LONG_LEN, pcp );
d229 2
a230 1
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
d546 1
d631 5
a635 1
	pkg_send( MSG_ERROR, outbuf, strlen(outbuf)+1, rem_pcp );
@


8.4
log
@Added support for fb_readrect and fb_writerect
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 8.3 89/03/01 00:08:51 mike Locked $ (BRL)";
d30 3
a32 1
#include <syslog.h>
d102 2
a103 1
#ifdef LOG_DAEMON
d105 1
a105 1
#else
d107 2
a108 1
#endif
d110 1
a110 1
		openlog( argv[0], LOG_PID, 0 );
d112 1
d144 1
a144 1
#ifdef BSD
@


8.3
log
@Increased receive buffer, for improved performance
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 8.2 88/12/16 21:31:02 mike Locked $ (BRL)";
d295 76
@


8.2
log
@Fixed problem de-referencing null pointer.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 8.1 88/10/05 00:28:04 mike Locked $ (BRL)";
d108 9
@


8.1
log
@Release_3.0
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 7.6 88/09/22 21:02:54 phil Exp $ (BRL)";
a163 1
	long	ret;
d184 13
a196 6
	ret = fbp == FBIO_NULL ? -1 : 0;
	(void)pkg_plong( &rbuf[0*NET_LONG_LEN], ret );
	(void)pkg_plong( &rbuf[1*NET_LONG_LEN], fbp->if_max_width );
	(void)pkg_plong( &rbuf[2*NET_LONG_LEN], fbp->if_max_height );
	(void)pkg_plong( &rbuf[3*NET_LONG_LEN], fbp->if_width );
	(void)pkg_plong( &rbuf[4*NET_LONG_LEN], fbp->if_height );
@


7.6
log
@only output hostname after newline if more text follows
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 7.5 88/09/17 07:08:34 phil Locked $ (BRL)";
@


7.5
log
@changed cray-->CRAY
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 7.4 88/09/09 23:55:52 mike Locked $ (BRL)";
d457 2
a458 2
			if( *sp == '\n' ) {
				/* newline, put out the hostname again */
@


7.4
log
@fbhelp function
"new and improved" fb_log function
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 7.3 88/05/13 21:51:15 phil Locked $ (BRL)";
d49 1
a49 1
#ifdef cray
d146 1
a146 1
#ifdef cray
d178 1
a178 1
#ifdef cray
d247 1
a247 1
#ifdef cray
d251 1
a251 1
#endif cray
d428 2
a429 2
#ifdef cray
/* Segloader can't handle the multiple defines */
@


7.3
log
@lint fixes
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 7.2 88/05/06 04:58:12 mike Locked $ (BRL)";
d24 1
d48 4
a138 76
 *			F B _ L O G
 *
 *  Errors from the framebuffer library.  We route these back to
 *  our client in an ERROR packet.  Note that this is a replacement
 *  for the default fb_log function in libfb (which just writes
 *  to stderr).
 */
/* VARARGS */
void
#ifdef cray
/* Segloader can't handle the multiple defines */
rfbd_log( va_alist )
#else
fb_log( va_alist )
#endif
va_dcl
{
	va_list	ap;
	char *fmt;
	int a=0,b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0;
	int cnt=0;
	register char *cp;
	static char errbuf[80];

	va_start( ap );
	fmt = va_arg(ap,char *);
	cp = fmt;
	while( *cp )  if( *cp++ == '%' )  {
		cnt++;
		/* WARNING:  This assumes no fancy format specs like %.1f */
		switch( *cp )  {
		case 'e':
		case 'f':
		case 'g':
			cnt++;		/* Doubles are bigger! */
		}
	}
	if( cnt > 0 )  {
		a = va_arg(ap,int);
	}
	if( cnt > 1 )  {
		b = va_arg(ap,int);
	}
	if( cnt > 2 )  {
		c = va_arg(ap,int);
	}
	if( cnt > 3 )  {
		d = va_arg(ap,int);
	}
	if( cnt > 4 )  {
		e = va_arg(ap,int);
	}
	if( cnt > 5 )  {
		f = va_arg(ap,int);
	}
	if( cnt > 6 )  {
		g = va_arg(ap,int);
	}
	if( cnt > 7 )  {
		h = va_arg(ap,int);
	}
	if( cnt > 8 )  {
		i = va_arg(ap,int);
	}
	if( cnt > 9 )  {
		a = (int)fmt;
		fmt = "Max args exceeded on: %s\n";
	}
	va_end( ap );
	
	(void) sprintf( errbuf, fmt, a,b,c,d,e,f,g,h,i );
	pkg_send( MSG_ERROR, errbuf, strlen(errbuf)+1, rem_pcp );
	return;
}

/*
d389 141
@


7.2
log
@If framebuffer is still open when EOF is received on the network connection,
gracefully close the framebuffer before exiting.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 7.1 87/11/02 23:27:39 mike Locked $ (BRL)";
d212 1
a212 1
int
d229 1
d267 1
d280 1
d297 1
d336 1
d359 1
d376 1
d392 1
d408 1
d437 1
@


7.1
log
@Release 2.3
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 6.2 87/09/16 22:54:39 mike Exp $ (BRL)";
d109 2
@


6.2
log
@Converted to using a well-defined network order for color maps.
"short" vars are not always 2 bytes wide (eg, on the Crays).
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 6.1 87/07/11 07:52:11 mike Locked $ (BRL)";
@


6.1
log
@Release 2.0
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 5.1 87/06/24 21:52:22 mike Rel $ (BRL)";
d402 1
a402 1
	int	i;
d404 2
a405 1
	ColorMap map, map2;
d409 3
a411 3
		(void)pkg_pshort( &map2.cm_red[i], map.cm_red[i] );
		(void)pkg_pshort( &map2.cm_green[i], map.cm_green[i] );
		(void)pkg_pshort( &map2.cm_blue[i], map.cm_blue[i] );
d413 1
a413 1
	pkg_send( MSG_DATA, (char *)&map2, sizeof(map2), pcp );
d418 8
d439 3
a441 3
			map.cm_red[i] = pkg_gshort( &(((ColorMap *)buf)->cm_red[i]) );
			map.cm_green[i] = pkg_gshort( &(((ColorMap *)buf)->cm_green[i]) );
			map.cm_blue[i] = pkg_gshort( &(((ColorMap *)buf)->cm_blue[i]) );
@


5.1
log
@Release 1.24
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 4.5 87/03/11 17:31:02 phil Exp $ (BRL)";
@


4.5
log
@changed rfbd_log back to fb_log so libfb will use it.
added cray ifdefs for rfbd_log to avoid segloader conflicts.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 4.4 87/02/12 22:07:22 phil Locked $ (BRL)";
@


4.4
log
@Release 1.20 -- First Formal Release
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 4.3 87/02/11 04:51:59 mike Exp $ (BRL)";
d132 1
a132 1
 *			R F B D _ L O G
d135 3
a137 1
 *  our client.
d141 2
d144 3
d215 1
d218 4
d246 1
d248 3
d312 1
d314 3
@


4.3
log
@Latest Cray-inspired cleanups
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 4.2 86/12/30 16:55:19 mike Locked $ (BRL)";
@


4.2
log
@4.2 compatability for openlog() call,
discovered during testing.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 4.1 86/12/29 02:49:29 mike Locked $ (BRL)";
d72 1
a72 1
		if( (netfd = pkg_initserver("remotefb", 0, comm_error)) < 0 )
d132 1
a132 1
 *			F B _ L O G
d139 1
a139 1
fb_log( va_alist )
d208 1
a208 1
	fb_log( "rfbd: unable to handle message type %d\n",
d223 2
a224 2
	width = fbgetlong( &buf[0*NET_LONG_LEN] );
	height = fbgetlong( &buf[1*NET_LONG_LEN] );
d234 1
a234 1
fb_log(s);
d238 5
a242 5
	(void)fbputlong( ret, &rbuf[0*NET_LONG_LEN] );
	(void)fbputlong( fbp->if_max_width, &rbuf[1*NET_LONG_LEN] );
	(void)fbputlong( fbp->if_max_height, &rbuf[2*NET_LONG_LEN] );
	(void)fbputlong( fbp->if_width, &rbuf[3*NET_LONG_LEN] );
	(void)fbputlong( fbp->if_height, &rbuf[4*NET_LONG_LEN] );
d254 1
a254 1
	(void)fbputlong( fb_close( fbp ), &rbuf[0] );
d271 1
a271 1
	(void)fbputlong( fb_clear( fbp, bg ), rbuf );
d285 3
a287 3
	x = fbgetlong( &buf[0*NET_LONG_LEN] );
	y = fbgetlong( &buf[1*NET_LONG_LEN] );
	num = fbgetlong( &buf[2*NET_LONG_LEN] );
d296 1
a296 1
			fb_log("fb_read: malloc failed!");
d319 3
a321 3
	x = fbgetlong( &buf[0*NET_LONG_LEN] );
	y = fbgetlong( &buf[1*NET_LONG_LEN] );
	num = fbgetlong( &buf[2*NET_LONG_LEN] );
d326 1
a326 1
		(void)fbputlong( ret, &rbuf[0*NET_LONG_LEN] );
d339 3
a341 3
	mode = fbgetlong( &buf[0*NET_LONG_LEN] );
	x = fbgetlong( &buf[1*NET_LONG_LEN] );
	y = fbgetlong( &buf[2*NET_LONG_LEN] );
d343 1
a343 1
	(void)fbputlong( fb_cursor( fbp, mode, x, y ), &rbuf[0] );
d355 2
a356 2
	x = fbgetlong( &buf[0*NET_LONG_LEN] );
	y = fbgetlong( &buf[1*NET_LONG_LEN] );
d358 1
a358 1
	(void)fbputlong( fb_window( fbp, x, y ), &rbuf[0] );
d370 2
a371 2
	x = fbgetlong( &buf[0*NET_LONG_LEN] );
	y = fbgetlong( &buf[1*NET_LONG_LEN] );
d373 1
a373 1
	(void)fbputlong( fb_zoom( fbp, x, y ), &rbuf[0] );
d386 1
a386 1
	(void)fbputlong( fb_rmap( fbp, &map ), &rbuf[0*NET_LONG_LEN] );
d388 3
a390 3
		(void)fbputshort( map.cm_red[i], &map2.cm_red[i] );
		(void)fbputshort( map.cm_green[i], &map2.cm_green[i] );
		(void)fbputshort( map.cm_blue[i], &map2.cm_blue[i] );
d410 3
a412 3
			map.cm_red[i] = fbgetshort( &(((ColorMap *)buf)->cm_red[i]) );
			map.cm_green[i] = fbgetshort( &(((ColorMap *)buf)->cm_green[i]) );
			map.cm_blue[i] = fbgetshort( &(((ColorMap *)buf)->cm_blue[i]) );
d416 1
a416 1
	(void)fbputlong( ret, &rbuf[0] );
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 1.19 86/12/19 02:02:18 phil Exp $ (BRL)";
d95 5
a99 1
	openlog( "rfbd", LOG_PID|LOG_NOWAIT, LOG_DAEMON );
@


1.19
log
@now uses new transerver rather than makeconn for inetd starts.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 1.18 86/12/09 22:41:11 phil Locked $ (BRL)";
@


1.18
log
@Added syslog capability for logging errors with pkg connection.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 1.17 86/11/18 10:24:59 mike Exp $ (BRL)";
d63 1
a63 1
	/* Started by /etc/inetd, network fd=0 */
d65 1
a65 1
	rem_pcp = pkg_makeconn( netfd, pkg_switch, comm_error );
@


1.17
log
@Changed to "remotefb" service.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 1.16 86/10/29 04:51:25 mike Locked $ (BRL)";
d95 1
d111 3
a113 4
 *  Communication error.  An error occured on the PKG link between us
 *  and the client we are serving.  We can't safely route these down
 *  that connection so for now we just blat to stderr.
 *  Should use syslog.
d119 6
a124 1
	(void)fprintf( stderr, "%s\n", str );
@


1.16
log
@network order colormaps
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 1.15 86/10/29 03:16:36 phil Locked $ (BRL)";
d72 1
a72 1
		if( (netfd = pkg_initserver("mfb", 0, comm_error)) < 0 )
@


1.15
log
@Fixed fb_read return package type.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 1.14 86/10/25 11:32:33 mike Locked $ (BRL)";
a368 1
/* XXX - need to convert from network shorts! */
d373 1
d375 1
a375 1
	ColorMap map;
d378 6
a383 1
	pkg_send( MSG_DATA, (char *)&map, sizeof(map), pcp );
d392 1
d395 1
d399 8
a406 3
	else
		ret = fb_wmap( fbp, buf );

@


1.14
log
@Converted to RGBpixel, improved parameterization,
changed buffer_read packaging.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 1.13 86/10/24 09:42:28 mike Locked $ (BRL)";
d297 1
a297 1
	pkg_send( MSG_DATA, scanbuf, ret*sizeof(RGBpixel), pcp );
@


1.13
log
@Typo, added ret.
@
text
@d6 1
a6 1
 *  Author -
d8 1
d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 1.12 86/10/24 09:40:59 mike Locked $ (BRL)";
d41 2
a43 1
extern	double	atof();
d48 1
a48 1
static	struct	pkg_conn *pcp;
d65 1
a65 1
	pcp = pkg_makeconn( netfd, pkg_switch, comm_error );
d74 2
a75 2
		pcp = pkg_getclient( netfd, pkg_switch, comm_error, 0 );
		if( pcp == PKC_ERROR )
d101 1
a101 1
	while( pkg_block(pcp) > 0 )
d187 1
a187 1
	pkg_send( MSG_ERROR, errbuf, strlen(errbuf)+1, pcp );
d212 1
a212 1
	char	rbuf[5*4+1];
d214 2
a215 2
	width = fbgetlong( &buf[0*4] );
	height = fbgetlong( &buf[1*4] );
d229 5
a233 5
	(void)fbputlong( ret, &rbuf[0*4] );
	(void)fbputlong( fbp->if_max_width, &rbuf[1*4] );
	(void)fbputlong( fbp->if_max_height, &rbuf[2*4] );
	(void)fbputlong( fbp->if_width, &rbuf[3*4] );
	(void)fbputlong( fbp->if_height, &rbuf[4*4] );
d235 1
a235 1
	pkg_send( MSG_RETURN, rbuf, 5*4, pcp );
d243 1
a243 1
	char	rbuf[4+1];
d246 1
a246 1
	pkg_send( MSG_RETURN, rbuf, 4, pcp );
d255 2
a256 2
	Pixel	bg;
	char	rbuf[4+1];
d258 6
a263 6
	bg.red = buf[0];
	bg.green = buf[1];
	bg.blue = buf[2];
	bg.spare = 0;
	(void)fbputlong( fb_clear( fbp, &bg ), rbuf );
	pkg_send( MSG_RETURN, rbuf, 4, pcp );
a272 1
	char	rbuf[4+1];
d276 3
a278 3
	x = fbgetlong( &buf[0*4] );
	y = fbgetlong( &buf[1*4] );
	num = fbgetlong( &buf[2*4] );
d280 1
a280 1
	if( num > buflen ) {
d283 3
a285 3
		buflen = num*sizeof(Pixel);
		if( buflen < 1024*sizeof(Pixel) )
			buflen = 1024*sizeof(Pixel);
d295 3
a297 6
	(void)fbputlong( ret, &rbuf[0] );
	pkg_send( MSG_RETURN, rbuf, 4, pcp );

	/* Send back the data */
	if( ret >= 0 )
		pkg_send( MSG_DATA, scanbuf, num*sizeof(Pixel), pcp );
d306 1
a306 1
	char	rbuf[4+1];
d310 3
a312 3
	x = fbgetlong( &buf[0*4] );
	y = fbgetlong( &buf[1*4] );
	num = fbgetlong( &buf[2*4] );
d314 1
a314 1
	ret = fb_write( fbp, x, y, &buf[3*4], num );
d317 2
a318 2
		(void)fbputlong( ret, &rbuf[0] );
		pkg_send( MSG_RETURN, rbuf, 4, pcp );
d328 1
a328 1
	char	rbuf[4+1];
d330 3
a332 3
	mode = fbgetlong( &buf[0*4] );
	x = fbgetlong( &buf[1*4] );
	y = fbgetlong( &buf[2*4] );
d335 1
a335 1
	pkg_send( MSG_RETURN, rbuf, 4, pcp );
d344 1
a344 1
	char	rbuf[4+1];
d346 2
a347 2
	x = fbgetlong( &buf[0*4] );
	y = fbgetlong( &buf[1*4] );
d350 1
a350 1
	pkg_send( MSG_RETURN, rbuf, 4, pcp );
d359 1
a359 1
	char	rbuf[4+1];
d361 2
a362 2
	x = fbgetlong( &buf[0*4] );
	y = fbgetlong( &buf[1*4] );
d365 1
a365 1
	pkg_send( MSG_RETURN, rbuf, 4, pcp );
d374 1
a374 1
	char	rbuf[4+1];
d377 3
a379 3
	(void)fbputlong( fb_rmap( fbp, &map ), &rbuf[0] );
	pkg_send( MSG_DATA, &map, sizeof(map), pcp );
	pkg_send( MSG_RETURN, rbuf, 4, pcp );
d387 1
a387 1
	char	rbuf[4+1];
d396 1
a396 1
	pkg_send( MSG_RETURN, rbuf, 4, pcp );
@


1.12
log
@Fixed free() error
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 1.11 86/10/24 06:35:47 mike Locked $ (BRL)";
d309 1
@


1.11
log
@First version which works on SGI, without inetd.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 1.9 86/10/24 04:52:20 mike Locked $ (BRL)";
a308 2
	long	ret;
	char	*datap;
a320 1
	free( datap );
@


1.10
log
@More typos
@
text
@d65 25
a89 11
	/*
	 * Listen for PKG connections.
	 * This is what we would do if we weren't being started
	 * by inetd
	 * XXXXX needs loop to restart afterwards, or something !
	 */
	if( (netfd = pkg_initserver("mfb", 0, comm_error)) < 0 )
		exit(1);
	pcp = pkg_getclient( netfd, pkg_switch, comm_error, 0 );
	if( pcp == PKC_ERROR )
		exit(2);
@


1.9
log
@Changed to use pkg_2send for bwrite.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 1.8 86/10/24 04:37:44 mike Locked $ (BRL)";
d25 4
d32 1
a32 3
#include <syslog.h>
#include <sys/uio.h>		/* for struct iovec */
#include <varargs.h>
d213 5
a217 5
	(void)putlong( ret, &rbuf[0*4] );
	(void)putlong( fbp->if_max_width, &rbuf[1*4] );
	(void)putlong( fbp->if_max_height, &rbuf[2*4] );
	(void)putlong( fbp->if_width, &rbuf[3*4] );
	(void)putlong( fbp->if_height, &rbuf[4*4] );
@


1.8
log
@Converted to use fbget/set short/long, for portability.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 1.7 86/10/24 03:31:29 mike Locked $ (BRL)";
d301 1
a302 5
	/* Get space, fetch data into it, do write, free space. */
	datap = malloc( num*4 );
	pkg_waitfor( MSG_DATA, datap, num*4, pcp );
	ret = fb_write( fbp, x, y, datap, num );

d357 1
@


1.7
log
@added call/return info.  fixed bug.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 1.6 86/10/22 21:58:48 phil Locked $ (BRL)";
d34 1
d56 7
a62 1
#ifdef NEVER
d66 2
a67 1
	 * by inetd (plus some other code that's been removed...).
d69 1
a69 1
	if( (netfd = pkg_initserver("rlibfb", 0)) < 0 )
d71 3
d75 2
a76 1
	netfd = 0;
d81 1
a81 1
	(void)signal( SIGPIPE, SIG_IGN );
a82 2
	pcp = pkg_makeconn( netfd, pkg_switch, comm_error );

d194 1
a194 1
	long	rbuf[5];
d196 2
a197 2
	width = ntohl( *(long *)(&buf[0]) );
	height = ntohl( *(long *)(&buf[4]) );
d211 7
a217 6
	rbuf[0] = htonl( ret );
	rbuf[1] = htonl( fbp->if_max_width );
	rbuf[2] = htonl( fbp->if_max_height );
	rbuf[3] = htonl( fbp->if_width );
	rbuf[4] = htonl( fbp->if_height );
	pkg_send( MSG_RETURN, &rbuf[0], 20, pcp );
d225 1
a225 1
	long	ret;
d227 2
a228 3
	ret = fb_close( fbp );
	ret = htonl( ret );
	pkg_send( MSG_RETURN, &ret, 4, pcp );
d238 1
a238 1
	long	ret;
d244 2
a245 3
	ret = fb_clear( fbp, &bg );
	ret = htonl( ret );
	pkg_send( MSG_RETURN, &ret, 4, pcp );
d254 3
a256 2
	long	ret;
	static char	*rbuf = NULL;
d259 3
a261 3
	x =  ntohl( *(long *)(&buf[0]) );
	y =  ntohl( *(long *)(&buf[4]) );
	num =  ntohl( *(long *)(&buf[8]) );
d264 2
a265 2
		if( rbuf != NULL )
			free( rbuf );
d269 1
a269 1
		if( (rbuf = malloc( buflen )) == NULL ) {
d277 3
a279 3
	ret = fb_read( fbp, x, y, rbuf, num );
	ret = htonl( ret );
	pkg_send( MSG_RETURN, &ret, 4, pcp );
d283 1
a283 1
		pkg_send( MSG_DATA, rbuf, num*sizeof(Pixel), pcp );
d292 1
d297 3
a299 3
	x =  ntohl( *(long *)(&buf[0]) );
	y =  ntohl( *(long *)(&buf[4]) );
	num =  ntohl( *(long *)(&buf[8]) );
d308 2
a309 2
		ret = htonl( ret );
		pkg_send( MSG_RETURN, &ret, 4, pcp );
d320 1
a320 1
	long	ret;
d322 3
a324 3
	mode =  ntohl( *(long *)(&buf[0]) );
	x =  ntohl( *(long *)(&buf[4]) );
	y =  ntohl( *(long *)(&buf[8]) );
d326 2
a327 3
	ret = fb_cursor( fbp, mode, x, y );
	ret = htonl( ret );
	pkg_send( MSG_RETURN, &ret, 4, pcp );
d336 1
a336 1
	long	ret;
d338 2
a339 2
	x =  ntohl( *(long *)(&buf[0]) );
	y =  ntohl( *(long *)(&buf[4]) );
d341 2
a342 3
	ret = fb_window( fbp, x, y );
	ret = htonl( ret );
	pkg_send( MSG_RETURN, &ret, 4, pcp );
d351 1
a351 1
	long	ret;
d353 2
a354 2
	x =  ntohl( *(long *)(&buf[0]) );
	y =  ntohl( *(long *)(&buf[4]) );
d356 2
a357 3
	ret = fb_zoom( fbp, x, y );
	ret = htonl( ret );
	pkg_send( MSG_RETURN, &ret, 4, pcp );
a360 39
#ifdef NEVER	XXX
/* void */
rfbsetsize(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
	int	size;

	size =  ntohl( *(long *)(&buf[0]) );

	fb_setsize( size );
	if( buf ) (void)free(buf);
}

rfbgetsize(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
	long	ret;

	ret = fb_getsize( fbp );
	ret = htonl( ret );
	pkg_send( MSG_RETURN, &ret, 4, pcp );
	if( buf ) (void)free(buf);
}

rfbsetbackground(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
	long	ret;

	fb_setbackground( fbp, ((Pixel *) buf) );
	ret = htonl( 0 );	/* Should NOT return value.	*/
	pkg_send( MSG_RETURN, &ret, 4, pcp );
	if( buf ) (void)free(buf);
}
#endif NEVER

d365 1
a365 1
	long	ret;
d368 1
a368 1
	ret = fb_rmap( fbp, &map );
d370 1
a370 2
	ret = htonl( ret );
	pkg_send( MSG_RETURN, &ret, 4, pcp );
d378 1
d386 2
a387 2
	ret = htonl( ret );
	pkg_send( MSG_RETURN, &ret, 4, pcp );
@


1.6
log
@new pkg_makeconn call.
disk interface disable flag.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 1.5 86/10/22 20:35:37 phil Locked $ (BRL)";
d159 1
a159 1
	pkg_send( MSG_ERROR, errbuf, strlen(errbuf), pcp );
d171 1
a171 1
	fb_log( "rlibfb: unable to handle message type %d\n",
d184 1
d201 6
a206 2
	ret = htonl( ret );
	pkg_send( MSG_RETURN, &ret, 4, pcp );
d227 1
d230 5
a234 1
	ret = fb_clear( fbp, PIXEL_NULL );
d284 1
d289 1
d296 1
a296 1
	if( pcp->pkc_type < MSG_NORETURN ) {
@


1.5
log
@New error logging code.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 1.4 86/10/15 17:01:03 phil Locked $ (BRL)";
d39 1
d52 3
d71 1
a71 14
/*	pcp = pkg_getclient( netfd, pkg_switch, 0 );*/
	/* XXXX */
	if( (pcp = (struct pkg_conn *)malloc(sizeof(struct pkg_conn)))==PKC_NULL )  {
		fprintf(stderr,"pkg_getclient: malloc failure\n");
		exit( 0 );
	}
	pcp->pkc_magic = PKG_MAGIC;
	pcp->pkc_fd = netfd;
	pcp->pkc_switch = pkg_switch;
	pcp->pkc_errlog = comm_error;
	pcp->pkc_left = -1;
	pcp->pkc_buf = (char *)0;
	pcp->pkc_curpos = (char *)0;
	/* XXXX */
@


1.4
log
@Changed to use the new PKG library.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rfbd.c,v 1.3 86/10/12 23:52:38 phil Locked $ (BRL)";
d30 1
d40 3
a49 1
	struct	pkg_conn *pcp;
d76 1
d89 1
a89 1
 *			E R R L O G
d91 4
a94 1
 *  Log an error.  Route it to user.
d97 1
a97 1
errlog( str, pcp )
a99 1
#ifdef TTY
a100 3
#else
	pkg_send( MSG_ERROR, str, strlen(str), pcp );
#endif
d104 69
d175 1
d180 1
a180 4
	register int i;
	char str[256];

	sprintf( str, "rlibfb: unable to handle message type %d\n",
a181 1
	errlog( str, pcp );
d205 1
a205 1
errlog(s, pcp);
d259 1
a259 1
			errlog("fb_read: malloc failed!", pcp);
@


1.3
log
@Phil's latest version
Updated for new libfb
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rlibfb.c,v 1.2 86/08/13 10:32:58 mike Exp $ (BRL)";
d27 1
a27 1
/* #include <netinet/in.h>		/* For htonl(), etc XXX */
d29 1
d32 3
a34 2
#include "./pkg.h"
#include "./pkgtypes.h"
a39 1
static	int	netfd;
d44 3
a46 1
	int on = 1;
d54 1
a54 1
	if( (tcp_listen_fd = pkg_initserver("rlibfb", 0)) < 0 )
d57 2
a58 1
	if( setsockopt(0, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on)) < 0 ) {
a61 1

d64 13
a76 1
	netfd = 0;
d78 1
a78 1
	while( pkg_block(netfd) > 0 )
d90 1
a90 1
errlog( str )
d96 1
a96 1
	pkg_send( MSG_ERROR, str, strlen(str), netfd );
d103 2
a104 2
pkgfoo(type, buf, length)
int type, length;
d110 3
a112 7
	for( i=0; i<pkg_swlen; i++ )  {
		if( pkg_switch[i].pks_type == type )  break;
	}
	sprintf( str, "rlibfb: unable to handle %s message: len %d\n",
		pkg_switch[i].pks_title, length );
	errlog( str );
	*buf = '*';
d118 2
a119 2
rfbopen(type, buf, length)
int type, length;
d125 2
a126 2
	height = ntohl( *(long *)(&buf[0]) );
	width = ntohl( *(long *)(&buf[4]) );
d129 1
a129 1
		fbp = fb_open( NULL, height, width );
d131 1
a131 1
		fbp = fb_open( &buf[8], height, width );
d136 1
a136 1
errlog(s);
d141 1
a141 1
	pkg_send( MSG_RETURN, &ret, 4, netfd );
d145 2
a146 2
rfbclose(type, buf, length)
int type, length;
d153 1
a153 1
	pkg_send( MSG_RETURN, &ret, 4, netfd );
d158 2
a159 2
rfbclear(type, buf, length)
int type, length;
d166 1
a166 1
	pkg_send( MSG_RETURN, &ret, 4, netfd );
d170 2
a171 2
rfbread(type, buf, length)
int type, length;
d190 1
a190 1
			errlog("fb_read: malloc failed!");
d199 1
a199 1
	pkg_send( MSG_RETURN, &ret, 4, netfd );
d203 1
a203 1
		pkg_send( MSG_DATA, rbuf, num*sizeof(Pixel), netfd );
d207 2
a208 2
rfbwrite(type, buf, length)
int type, length;
d221 1
a221 1
	pkg_waitfor( MSG_DATA, datap, num*4, netfd );
d224 1
a224 1
	if( type < MSG_NORETURN ) {
d226 1
a226 1
		pkg_send( MSG_RETURN, &ret, 4, netfd );
d232 2
a233 2
rfbcursor(type, buf, length)
int type, length;
d245 1
a245 1
	pkg_send( MSG_RETURN, &ret, 4, netfd );
d249 2
a250 2
rfbwindow(type, buf, length)
int type, length;
d261 1
a261 1
	pkg_send( MSG_RETURN, &ret, 4, netfd );
d265 2
a266 2
rfbzoom(type, buf, length)
int type, length;
d277 1
a277 1
	pkg_send( MSG_RETURN, &ret, 4, netfd );
d283 2
a284 2
rfbsetsize(type, buf, length)
int type, length;
d295 2
a296 2
rfbgetsize(type, buf, length)
int type, length;
d303 1
a303 1
	pkg_send( MSG_RETURN, &ret, 4, netfd );
d307 2
a308 2
rfbsetbackground(type, buf, length)
int type, length;
d315 1
a315 1
	pkg_send( MSG_RETURN, &ret, 4, netfd );
d320 2
a321 2
rfbrmap(type, buf, length)
int type, length;
d328 1
a328 1
	pkg_send( MSG_DATA, &map, sizeof(map), netfd );
d330 1
a330 1
	pkg_send( MSG_RETURN, &ret, 4, netfd );
d334 2
a335 2
rfbwmap(type, buf, length)
int type, length;
d340 1
a340 1
	if( length == 0 )
d346 1
a346 1
	pkg_send( MSG_RETURN, &ret, 4, netfd );
@


1.2
log
@Added header file for htonl().
@
text
@d2 1
a2 1
 *	R L I B F B . C
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rlibfb.c,v 1.1 86/08/13 07:17:30 mike Exp $ (BRL)";
d27 1
a27 1
#include <netinet/in.h>		/* For htonl(), etc */
d29 1
a29 2
#include	"./pkg.h"
#include	"./pkgtypes.h"
d31 2
d34 2
a35 1
char	*malloc();
d37 2
a38 31
/*
 * Package Handlers.
 */
int pkgfoo();	/* foobar message handler */
int rfbopen(), rfbclose(), rfbclear(), rfbread(), rfbwrite(), rfbcursor();
int rfbwindow(), rfbzoom(), rfbgetsize(), rfbsetsize(), rfbsetbackground();
int rfbrmap(), rfbwmap();
int rfbioinit(), rfbwpixel();
int rpagein(), rpageout();
struct pkg_switch pkg_switch[] = {
	{ MSG_FBOPEN,	rfbopen,	"Open Framebuffer" },
	{ MSG_FBCLOSE,	rfbclose,	"" },
	{ MSG_FBCLEAR,	rfbclear,	"Clear Framebuffer" },
	{ MSG_FBREAD,	rfbread,	"Read Pixels" },
	{ MSG_FBWRITE,	rfbwrite,	"Write Pixels" },
	{ MSG_FBWRITE + MSG_NORETURN,	rfbwrite,	"Asynch write" },
	{ MSG_FBCURSOR,	rfbcursor,	"" },
	{ MSG_FBWINDOW,	rfbwindow,	"" },
	{ MSG_FBZOOM,	rfbzoom,	"" },
	{ MSG_FBGETSIZE,rfbgetsize,	"" },
	{ MSG_FBSETSIZE,rfbsetsize,	"" },
	{ MSG_FBSETBACKG,rfbsetbackground,"" },
	{ MSG_FBRMAP,	rfbrmap,	"" },
	{ MSG_FBWMAP,	rfbwmap,	"" },
	{ MSG_FBIOINIT,	rfbioinit,	"" },
	{ MSG_ERROR,	pkgfoo,		"Error Message" },
	{ MSG_CLOSE,	pkgfoo,		"Close Connection" },
	{ MSG_PAGEIN,	rpagein,	"Get buffer page" },
	{ MSG_PAGEOUT,	rpageout,	"Put buffer page" }
};
int pkg_swlen = 19;
d40 1
a40 12
static	int	cur_fd;

#ifdef NEVER
/* Buffered IO variables */
extern	char	*_pagep;
extern	int	_pagesz;
extern	int	_pageno;
#endif NEVER

extern double atof();

main(argc, argv)
a42 1
	register int i;
d46 5
a50 1
	/* Listen for our PKG connections */
d54 3
a56 3
	if (setsockopt(0, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof (on)) < 0) {
		openlog(argv[0], LOG_PID, 0);
		syslog(LOG_WARNING, "setsockopt (SO_KEEPALIVE): %m");
d61 1
a61 1
	cur_fd = 0;
d63 1
a63 1
	while( pkg_block(cur_fd) > 0 )
d72 1
a72 1
 *  Log an error.  We supply the newline, and route to user.
d74 2
a75 3
/* VARARGS */
void
errlog( str, a, b, c, d, e, f, g, h )
a77 2
	char buf[256];		/* a generous output line */

d79 4
a82 2
	(void)fprintf( stderr, str, a, b, c, d, e, f, g, h );
#endif TTY
d85 3
d93 1
d98 3
a100 2
	errlog("rlibfb: unable to handle %s message: len %d\n",
		pkg_switch[i].pks_title, length);
d111 2
a112 2
	int	mode, size, ret;
/*char s[50];*/
d114 2
a115 2
	mode = ntohl( *(long *)(&buf[0]) );
	size = ntohl( *(long *)(&buf[4]) );
a116 2
	(void)fbsetsize( size );	/* XXX - should return any error */
					/*       as an async message */
d118 1
a118 1
		ret = fbopen( 0L, mode );
d120 1
a120 1
		ret = fbopen( &buf[8], mode );
d122 7
a128 2
/*sprintf( s, "Device: \"%s\"", &buf[8] );*/
/*pkg_send( MSG_ERROR, s, strlen(s), cur_fd );*/
d130 1
a130 1
	pkg_send( MSG_RETURN, &ret, 4, cur_fd );
a133 1
/* NB: This is supposed to take an fd arg! */
d138 1
a138 1
	int	ret;
d140 1
a140 1
	ret = fbclose( 0 );
d142 1
a142 1
	pkg_send( MSG_RETURN, &ret, 4, cur_fd );
d144 1
d151 1
a151 1
	int	ret;
d153 1
a153 1
	ret = fbclear();
d155 1
a155 1
	pkg_send( MSG_RETURN, &ret, 4, cur_fd );
d163 4
a166 2
	int	x, y, num, ret;
	char	dat[10000];
d172 12
a183 3
	if( num > 10000/4 ) {
		pkg_send( MSG_ERROR, "fbread: too many bytes!", 24, cur_fd );
		num = 10000/4;
d186 1
a186 1
	ret = fbread( x, y, &dat[0], num );
d188 1
a188 1
	pkg_send( MSG_RETURN, &ret, 4, cur_fd );
d192 1
a192 1
		pkg_send( MSG_DATA, &dat[0], num*4, cur_fd );
d200 2
a201 1
	int	x, y, num, ret;
d210 2
a211 2
	pkg_waitfor( MSG_DATA, datap, num*4, cur_fd );
	ret = fbwrite( x, y, datap, num );
d215 1
a215 1
		pkg_send( MSG_RETURN, &ret, 4, cur_fd );
d226 1
a226 1
	int	ret;
d232 1
a232 1
	ret = fbcursor(mode, x, y);
d234 1
a234 1
	pkg_send( MSG_RETURN, &ret, 4, cur_fd );
d243 1
a243 1
	int	ret;
d248 1
a248 1
	ret = fbwindow(x, y);
d250 1
a250 1
	pkg_send( MSG_RETURN, &ret, 4, cur_fd );
d259 1
a259 1
	int	ret;
d264 1
a264 1
	ret = fbzoom(x, y);
d266 1
a266 1
	pkg_send( MSG_RETURN, &ret, 4, cur_fd );
d270 1
d280 1
a280 1
	fbsetsize( size );
d288 1
a288 1
	int	ret;
d290 1
a290 1
	ret = fbgetsize();
d292 1
a292 1
	pkg_send( MSG_RETURN, &ret, 4, cur_fd );
d300 1
a300 1
	int	ret;
d302 3
a304 3
	ret = fbsetbackground( buf );
	ret = htonl( ret );
	pkg_send( MSG_RETURN, &ret, 4, cur_fd );
d307 1
d313 1
a313 1
	int	ret;
d316 2
a317 2
	ret = fb_rmap( &map );
	pkg_send( MSG_DATA, &map, sizeof(map), cur_fd );
d319 1
a319 1
	pkg_send( MSG_RETURN, &ret, 4, cur_fd );
d327 1
a327 1
	int	ret;
d330 1
a330 1
		ret = fb_wmap( 0 );
d332 1
a332 1
		ret = fb_wmap( buf );
d335 1
a335 1
	pkg_send( MSG_RETURN, &ret, 4, cur_fd );
a336 51
}

/*
 * XXX - we eventually have to give PAGE_SIZE back to remote.
 */
rfbioinit(type, buf, length)
int type, length;
char *buf;
{
	fbioinit();
	if( buf ) (void)free(buf);
}

/*
 * We get _pageno from remote.
 */
rpageout(type, buf, length)
int type, length;
char *buf;
{
	long	ret;

	_pageno = ntohl( *(long *)(&buf[0]) );

	/* Get page data */
	pkg_waitfor( MSG_DATA, _pagep, _pagesz, cur_fd );

	ret = _pageout();
	ret = htonl( ret );
	pkg_send( MSG_RETURN, &ret, 4, cur_fd );

	if( buf ) (void)free(buf);
}

/*
 * We get pageno from remote.
 */
rpagein(type, buf, length)
int type, length;
char *buf;
{
	long	ret;
	int	pageno;

	pageno = ntohl( *(long *)(&buf[0]) );
	ret = _pagein( pageno );
	ret = htonl( ret );
	pkg_send( MSG_RETURN, &ret, 4, cur_fd );

	if( ntohl(ret) >= 0 )
		pkg_send( MSG_DATA, _pagep, _pagesz, cur_fd );
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d27 1
@
