head	11.42;
access;
symbols
	ansi-20040405-merged:11.37.2.2
	postmerge-20040405-ansi:11.40
	premerge-20040404-ansi:11.39
	postmerge-autoconf:11.39
	autoconf-freeze:11.38.4.2
	premerge-autoconf:11.39
	ansi-20040316-freeze:11.37.2.1
	postmerge-20040315-windows:11.39
	premerge-20040315-windows:11.39
	windows-20040315-freeze:11.37.4.1
	autoconf-20031203:11.38
	autoconf-20031202:11.38
	autoconf-branch:11.38.0.4
	phong-branch:11.38.0.2
	photonmap-branch:11.37.0.6
	rel-6-1-DP:11.37
	windows-branch:11.37.0.4
	rel-6-0-2:11.35
	ansi-branch:11.37.0.2
	rel-6-0-1-branch:11.35.0.2
	hartley-6-0-post:11.36
	hartley-6-0-pre:11.35
	rel-6-0-1:11.35
	rel-6-0:11.33
	rel-5-4:11.20
	offsite-5-3-pre:11.28
	rel-5-3:11.20
	rel-5-2:11.20
	rel-5-1-branch:11.20.0.2
	rel-5-1:11.20
	rel-5-0:11.13
	rel-5-0-beta:11.12
	rel-4-5:11.9
	ctj-4-5-post:11.9
	ctj-4-5-pre:11.9
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.42
date	2004.05.24.04.16.12;	author morrison;	state dead;
branches;
next	11.41;

11.41
date	2004.05.10.15.30.41;	author erikg;	state Exp;
branches;
next	11.40;

11.40
date	2004.04.05.07.49.36;	author morrison;	state Exp;
branches;
next	11.39;

11.39
date	2004.02.02.17.39.00;	author morrison;	state Exp;
branches;
next	11.38;

11.38
date	2003.04.24.17.44.09;	author jra;	state Exp;
branches
	11.38.4.1;
next	11.37;

11.37
date	2002.08.20.17.07.21;	author jra;	state Exp;
branches
	11.37.2.1
	11.37.4.1
	11.37.6.1;
next	11.36;

11.36
date	2002.08.15.20.54.34;	author hartley;	state Exp;
branches;
next	11.35;

11.35
date	2002.05.28.18.48.53;	author jra;	state Exp;
branches;
next	11.34;

11.34
date	2002.05.17.12.48.56;	author morrison;	state Exp;
branches;
next	11.33;

11.33
date	2002.03.13.03.33.31;	author jra;	state Exp;
branches;
next	11.32;

11.32
date	2001.08.10.21.22.53;	author butler;	state Exp;
branches;
next	11.31;

11.31
date	2001.05.17.20.03.14;	author morrison;	state Exp;
branches;
next	11.30;

11.30
date	2001.04.05.19.34.59;	author morrison;	state Exp;
branches;
next	11.29;

11.29
date	2001.04.02.21.37.35;	author morrison;	state Exp;
branches;
next	11.28;

11.28
date	2000.10.31.22.35.12;	author mike;	state Exp;
branches;
next	11.27;

11.27
date	2000.10.20.20.29.24;	author jra;	state Exp;
branches;
next	11.26;

11.26
date	2000.09.08.05.55.42;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	2000.08.24.03.17.21;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	2000.08.23.09.53.15;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	2000.07.21.12.44.34;	author jra;	state Exp;
branches;
next	11.22;

11.22
date	2000.07.12.21.59.35;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	2000.07.10.23.53.57;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	2000.03.29.18.15.16;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	2000.03.29.18.07.44;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	2000.01.04.17.58.19;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	99.12.30.18.33.26;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	99.12.29.23.23.01;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	99.12.29.21.09.17;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	99.11.29.18.01.49;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	99.06.03.21.54.20;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	99.05.10.21.46.33;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	98.08.11.15.05.38;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	98.02.25.19.25.07;	author jra;	state Exp;
branches;
next	11.9;

11.9
date	97.03.04.21.55.56;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	96.12.20.18.03.01;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	96.08.02.12.48.21;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	96.07.12.13.20.17;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	95.04.03.19.48.38;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	95.03.29.18.35.08;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.03.29.13.25.22;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.02.22.05.40.55;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.59.34;	author mike;	state Rel4_4;
branches;
next	1.7;

1.7
date	94.12.29.20.22.44;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	94.12.16.16.32.46;	author jra;	state Exp;
branches;
next	1.5;

1.5
date	94.12.08.17.56.27;	author jra;	state Exp;
branches;
next	1.4;

1.4
date	94.11.08.16.15.06;	author jra;	state Exp;
branches;
next	1.3;

1.3
date	94.11.01.04.16.30;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	94.08.11.00.05.57;	author gdurf;	state Exp;
branches;
next	1.1;

1.1
date	94.01.07.13.01.59;	author jra;	state Exp;
branches;
next	;

11.37.2.1
date	2002.09.19.18.00.36;	author morrison;	state Exp;
branches;
next	11.37.2.2;

11.37.2.2
date	2004.03.17.21.15.56;	author morrison;	state Exp;
branches;
next	;

11.37.4.1
date	2004.03.11.23.40.30;	author morrison;	state Exp;
branches;
next	;

11.37.6.1
date	2003.08.26.14.03.21;	author justin;	state Exp;
branches;
next	;

11.38.4.1
date	2004.02.12.19.24.23;	author erikg;	state Exp;
branches;
next	11.38.4.2;

11.38.4.2
date	2004.03.15.14.06.08;	author erikg;	state Exp;
branches;
next	;


desc
@Routine to convert BRLCAD models to BRLCAD NMG models
@


11.42
log
@moved to src/conv/
@
text
@/*
 *			G - N M G . C
 *
 *  Program to convert a BRL-CAD model (in a .g file) to an NMG facetted model
 *  by calling on the NMG booleans.
 *
 *  Author -
 *	John R. Anderson
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1993-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */

#ifndef lint
static const char RCSid[] = "$Header: /n/xoff/cvs/brlcad/conv/g-nmg.c,v 11.41 2004/05/10 15:30:41 erikg Exp $";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "wdb.h"
#include "../librt/debug.h"

BU_EXTERN(union tree *do_region_end, (struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data));

static char	usage[] = "Usage: %s [-v] [-b] [-xX lvl] [-a abs_tol] [-r rel_tol] [-n norm_tol] [-o out_file] brlcad_db.g object(s)\n";

static char	*tok_sep = " \t";
static int	NMG_debug;		/* saved arg of -X, for longjmp handling */
static int	verbose;
static int	do_bots=0;		/* flag to output BOT's instead of NMG's */
/* static int	ncpu = 1; */		/* Number of processors */
static int	nmg_count=0;		/* Count of nmgregions written to output */
static char	*out_file = "nmg.g";	/* Output filename */
static struct rt_wdb		*fp_out; /* Output file pointer */
static struct db_i		*dbip;
static struct rt_tess_tol	ttol;
static struct bn_tol		tol;
static struct model		*the_model;

static struct db_tree_state	tree_state;	/* includes tol & model */

static int	regions_tried = 0;
static int	regions_converted = 0;

/*
*			D O _ R E G I O N _ E N D
*
*  Called from db_walk_tree().
*
*  This routine must be prepared to run in parallel.
*/
union tree *do_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
{
	struct nmgregion	*r;
	struct bu_list		vhead;
	union tree		*ret_tree;
	char			*sofar;
	struct bu_vls		shader_params;
	char nmg_name[16];
	unsigned char rgb[3];
	unsigned char *color = (unsigned char *)NULL;
	char *shader;
	char *matparm;
	struct wmember headp;
	struct rt_bot_internal *bot;

	RT_CK_TESS_TOL(tsp->ts_ttol);
	BN_CK_TOL(tsp->ts_tol);
	NMG_CK_MODEL(*tsp->ts_m);

	BU_LIST_INIT(&vhead);

	if (RT_G_DEBUG&DEBUG_TREEWALK || verbose) {
		sofar = db_path_to_string(pathp);
		bu_log("\ndo_region_end(%d %d%%) %s\n",
			regions_tried,
			regions_tried>0 ? (regions_converted * 100) / regions_tried : 0,
			sofar);
		bu_free(sofar, "path string");
	}

	if (curtree->tr_op == OP_NOP)
		return  curtree;

	regions_tried++;
	/* Begin rt_bomb() protection */
	if( BU_SETJUMP )
	{
		/* Error, bail out */
		BU_UNSETJUMP;		/* Relinquish the protection */

		sofar = db_path_to_string(pathp);
		bu_log( "FAILED: %s\n", sofar );
		bu_free( (char *)sofar, "sofar" );

		/* Sometimes the NMG library adds debugging bits when
		 * it detects an internal error, before rt_bomb().
		 */
		rt_g.NMG_debug = NMG_debug;	/* restore mode */

		/* Release any intersector 2d tables */
		nmg_isect2d_final_cleanup();

		/* Release the tree memory & input regions */
		db_free_tree(curtree, &rt_uniresource);	/* Does an nmg_kr() */

		/* Get rid of (m)any other intermediate structures */
		if( (*tsp->ts_m)->magic == NMG_MODEL_MAGIC )
		{
			nmg_km(*tsp->ts_m);
		}
		else
		{
			bu_log("WARNING: tsp->ts_m pointer corrupted, ignoring it.\n");
		}
	
		/* Now, make a new, clean model structure for next pass. */
		*tsp->ts_m = nmg_mm();
		goto out;
	}
	ret_tree = nmg_booltree_evaluate(curtree, tsp->ts_tol, &rt_uniresource);	/* librt/nmg_bool.c */

	if( ret_tree )
		r = ret_tree->tr_d.td_r;
	else
		r = (struct nmgregion *)NULL;
	if( do_bots ) {
		bot = nmg_bot( BU_LIST_FIRST( shell, &r->s_hd ), tsp->ts_tol );
	}

	BU_UNSETJUMP;		/* Relinquish the protection */
	regions_converted++;

	shader = strtok( tsp->ts_mater.ma_shader, tok_sep );
	matparm = strtok( (char *)NULL, tok_sep );
	bu_vls_init( &shader_params );
	if( matparm )
	{
		bu_vls_strcpy( &shader_params, matparm );
		matparm = strtok( (char *)NULL, tok_sep );
		while( matparm )
		{
			bu_vls_putc( &shader_params, ' ' );
			bu_vls_strcat( &shader_params, matparm );
			matparm = strtok( (char *)NULL, tok_sep );
		}
	}
	if (r != 0)
	{
		struct shell *s;
		int empty_region=0;
		int empty_model=0;

		/* Kill cracks */
		s = BU_LIST_FIRST( shell, &r->s_hd );
		while( BU_LIST_NOT_HEAD( &s->l, &r->s_hd ) )
		{
			struct shell *next_s;

			next_s = BU_LIST_PNEXT( shell, &s->l );
			if( nmg_kill_cracks( s ) )
			{
				if( nmg_ks( s ) )
				{
					empty_region = 1;
					break;
				}
			}
			s = next_s;
		}

		/* kill zero length edgeuses */
		if( !empty_region )
		{
			 empty_model = nmg_kill_zero_length_edgeuses( *tsp->ts_m );
		}

		if( !empty_region && !empty_model )
		{
			/* Write the nmgregion to the output file */
			nmg_count++;
			sprintf( nmg_name , "nmg.%d" , nmg_count );

			if( do_bots ) {
				wdb_export( fp_out, nmg_name, (genptr_t)bot, ID_BOT, 1.0 );
			} else {
				mk_nmg( fp_out , nmg_name , r->m_p );
			}
		}

		/* Now make a normal brlcad region */
		if( tsp->ts_mater.ma_color_valid )
		{
			rgb[0] = (int)(tsp->ts_mater.ma_color[0] * 255.0);
			rgb[1] = (int)(tsp->ts_mater.ma_color[1] * 255.0);
			rgb[2] = (int)(tsp->ts_mater.ma_color[2] * 255.0);
			color = rgb;
		}
		else
			color = (unsigned char *)NULL;

		BU_LIST_INIT( &headp.l );
		(void)mk_addmember( nmg_name , &headp.l , NULL, WMOP_UNION );
		if( mk_lrcomb( fp_out,
		    pathp->fp_names[pathp->fp_len-1]->d_namep, &headp, 1,
		    shader, bu_vls_addr( &shader_params ), color,
		    tsp->ts_regionid, tsp->ts_aircode, tsp->ts_gmater,
		    tsp->ts_los, tsp->ts_mater.ma_cinherit ) )
		{
			bu_log( "G-nmg: error in making region (%s)\n" , pathp->fp_names[pathp->fp_len-1]->d_namep );
		}
	}
	else
	{
		BU_LIST_INIT( &headp.l );
		if( mk_lrcomb( fp_out,
		    pathp->fp_names[pathp->fp_len-1]->d_namep, &headp, 1,
		    shader, bu_vls_addr( &shader_params ), color,
		    tsp->ts_regionid, tsp->ts_aircode, tsp->ts_gmater,
		    tsp->ts_los, tsp->ts_mater.ma_cinherit ) )
		{
			bu_log( "G-nmg: error in making region (%s)\n" , pathp->fp_names[pathp->fp_len-1]->d_namep );
		}
	}

	bu_vls_free( &shader_params );

	/*
	 *  Dispose of original tree, so that all associated dynamic
	 *  memory is released now, not at the end of all regions.
	 *  A return of TREE_NULL from this routine signals an error,
	 *  so we need to cons up an OP_NOP node to return.
	 */
	db_free_tree(curtree, &rt_uniresource);		/* Does an nmg_kr() */

out:

	if( RT_G_DEBUG&DEBUG_MEM_FULL )
		bu_prmem( "At end of do_region_end()" );

	BU_GETUNION(curtree, tree);
	curtree->magic = RT_TREE_MAGIC;
	curtree->tr_op = OP_NOP;
	return(curtree);
}

void
csg_comb_func(struct db_i *dbip, struct directory *dp, genptr_t ptr)
{
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;
	struct rt_tree_array *tree_list;
	int node_count;
	int actual_count;
	int i;
	struct wmember headp;
	struct wmember *wm;
	unsigned char *color;
	char *endp;
	int len;
	char matname[33];
	char matparm[61];

	if( dp->d_uses < 0 )
		return;

	dp->d_uses = (-1);

	if( dp->d_flags & DIR_REGION )
	{
		char **name;

		/* convert a region to NMG's */

		the_model = nmg_mm();
		tree_state = rt_initial_tree_state;	/* struct copy */
		tree_state.ts_tol = &tol;
		tree_state.ts_ttol = &ttol;
		tree_state.ts_m = &the_model;

		name = (&(dp->d_namep));

		(void) db_walk_tree( dbip, 1, (const char **)name,
			1,
			&tree_state,
			0,
			do_region_end,
			nmg_booltree_leaf_tess,
			(genptr_t)NULL);

		/* Release dynamic storage */
		nmg_km(the_model);

		return;
	}

	/* have a combination that is not a region */

	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
	{
		bu_log( "Cannot get internal form of combination (%s)\n", dp->d_namep );
		return;
	}
	comb = (struct rt_comb_internal *)intern.idb_ptr;
	RT_CK_COMB( comb );

	if( verbose )
		bu_log( "Combination - %s\n" , dp->d_namep );

	if( comb->tree && db_ck_v4gift_tree( comb->tree ) < 0 )
	{
		db_non_union_push( comb->tree, &rt_uniresource );
		if( db_ck_v4gift_tree( comb->tree ) < 0 )
		{
			bu_log( "Cannot flatten tree (%s) for editing\n", dp->d_namep );
			return;
		}
	}
	node_count = db_tree_nleaves( comb->tree );
	if( node_count > 0 )
	{
		tree_list = (struct rt_tree_array *)bu_calloc( node_count,
			sizeof( struct rt_tree_array ), "tree list" );
		actual_count = (struct rt_tree_array *)db_flatten_tree( tree_list,
			comb->tree, OP_UNION, 0, &rt_uniresource ) - tree_list;
		BU_ASSERT_LONG( actual_count, ==, node_count );
	}
	else
	{
		tree_list = (struct rt_tree_array *)NULL;
		actual_count = 0;
	}

	if( actual_count < 1 )
	{
		bu_log( "Warning: empty combination (%s)\n" , dp->d_namep );
		dp->d_uses = 0;
		rt_db_free_internal( &intern , &rt_uniresource);
		return;
	}

	BU_LIST_INIT( &headp.l );

	for( i=0 ; i<actual_count ; i++ )
	{
		char op;

		switch( tree_list[i].tl_op )
		{
			case OP_UNION:
				op = 'u';
				break;
			case OP_INTERSECT:
				op = '+';
				break;
			case OP_SUBTRACT:
				op = '-';
				break;
			default:
				bu_log( "Unrecognized Boolean operator in combination (%s)\n", dp->d_namep );
				bu_free( (char *)tree_list, "tree_list" );
				rt_db_free_internal( &intern , &rt_uniresource);
				return;
		}
		wm = mk_addmember( tree_list[i].tl_tree->tr_l.tl_name , &headp.l, NULL , op );
		if( tree_list[i].tl_tree->tr_l.tl_mat )
			MAT_COPY( wm->wm_mat, tree_list[i].tl_tree->tr_l.tl_mat );
	}

	if( comb->rgb_valid  )
		color = comb->rgb;
	else
		color = (unsigned char *)NULL;

	endp = strchr( bu_vls_addr(&comb->shader), ' ' );
	if( endp )
	{
		len = endp - bu_vls_addr(&comb->shader);
		if( len > 32 ) len = 32;
		strncpy( matname, bu_vls_addr(&comb->shader), len );
		strncpy( matparm, endp+1, 60 );
	}
	else
	{
		strncpy( matname, bu_vls_addr(&comb->shader), 32 );
		matparm[0] = '\0';
	}

	if( mk_lrcomb( fp_out, dp->d_namep, &headp, comb->region_flag,
	    matname, matparm,
	    color, comb->region_id,
	    comb->aircode, comb->GIFTmater,comb->los,
	    comb->inherit ) )
		{
			bu_log( "G-nmg: error in making region (%s)\n" , dp->d_namep );
		}
}

/*
 *			M A I N
 */
int
main(int argc, char **argv)
{
	int		i;
	register int	c;
	double		percent;

	port_setlinebuf( stderr );

#if MEMORY_LEAK_CHECKING
	rt_g.debug |= DEBUG_MEM_FULL;
#endif
	BU_LIST_INIT( &rt_g.rtg_vlfree );	/* for vlist macros */

	ttol.magic = RT_TESS_TOL_MAGIC;
	/* Defaults, updated by command line options. */
	ttol.abs = 0.0;
	ttol.rel = 0.01;
	ttol.norm = 0.0;

	/* XXX These need to be improved */
	tol.magic = BN_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;

	rt_init_resource( &rt_uniresource, 0, NULL );

	/* Get command line arguments. */
	while ((c = getopt(argc, argv, "t:a:n:o:r:bvx:P:X:")) != EOF) {
		switch (c) {
		case 'b':		/* make BOT's instead of NMG's */
			do_bots = 1;
			break;
		case 't':		/* calculational tolerance */
			tol.dist = atof( optarg );
			tol.dist_sq = tol.dist * tol.dist;
		case 'a':		/* Absolute tolerance. */
			ttol.abs = atof(optarg);
			ttol.rel = 0.0;
			break;
		case 'n':		/* Surface normal tolerance. */
			ttol.norm = atof(optarg)*bn_pi/180.0;
			ttol.rel = 0.0;
			break;
		case 'o':		/* Output file name */
			out_file = optarg;
			break;
		case 'r':		/* Relative tolerance. */
			ttol.rel = atof(optarg);
			break;
		case 'v':
			verbose++;
			break;
		case 'P':
/*			ncpu = atoi( optarg ); */
			rt_g.debug = 1;	/* XXX DEBUG_ALLRAYS -- to get core dumps */
			break;
		case 'x':
			sscanf( optarg, "%x", (unsigned int *)&rt_g.debug );
			bu_printb( "librt RT_G_DEBUG", RT_G_DEBUG, DEBUG_FORMAT );
			bu_log("\n");
			break;
		case 'X':
			sscanf( optarg, "%x", (unsigned int *)&rt_g.NMG_debug );
			NMG_debug = rt_g.NMG_debug;
			bu_printb( "librt rt_g.NMG_debug", rt_g.NMG_debug, NMG_DEBUG_FORMAT );
			bu_log("\n");
			break;
		default:
			fprintf(stderr, usage, argv[0]);
			exit(1);
			break;
		}
	}

	if (optind+1 >= argc) {
		fprintf(stderr, usage, argv[0]);
		exit(1);
	}

	/* Open brl-cad database */
	if ((dbip = db_open( argv[optind] , "r")) == DBI_NULL)
	{
		bu_log( "Cannot open %s\n" , argv[optind] );
		perror(argv[0]);
		exit(1);
	}
	db_dirbuild( dbip );

	if ((fp_out = wdb_fopen( out_file )) == NULL)
	{
		perror( out_file );
		bu_log( "g-nng: Cannot open %s\n" , out_file );
		return 2;
	}

	optind++;

	mk_id_editunits( fp_out , dbip->dbi_title , dbip->dbi_local2base );

	/* Walk the trees outputting regions and combinations */
	for( i=optind ; i<argc ; i++ )
	{
		struct directory *dp;

		dp = db_lookup( dbip , argv[i] , 0 );
		if( dp == DIR_NULL )
		{
			bu_log( "WARNING!!! Could not find %s, skipping\n", argv[i] );
			continue;
		}
		db_functree( dbip , dp , csg_comb_func , 0 , &rt_uniresource , NULL );
	}

	rt_vlist_cleanup();
	db_close(dbip);

#if MEMORY_LEAK_CHECKING
	bu_prmem("After complete G-NMG conversion");
#endif

	percent = 100;
	if( regions_tried > 0 )
		percent = ((double)regions_converted * 100) / regions_tried;

	printf( "Tried %d regions, %d converted successfully.  %g%%\n",
		regions_tried, regions_converted, percent );

	wdb_close(fp_out);
	return 0;
}

@


11.41
log
@change conf.h to a wrapped config.h
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /cvs/brlcad/conv/g-nmg.c,v 11.40 2004/04/05 07:49:36 morrison Exp $";
@


11.40
log
@merge of ansi-6-0-branch into HEAD
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header$";
d28 5
a32 1
#include "conf.h"
@


11.39
log
@update copyright to include span through 2003
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.38 2003/04/24 17:44:09 jra Exp $";
d76 1
a76 5
union tree *do_region_end(tsp, pathp, curtree, client_data)
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
d272 1
a272 4
csg_comb_func( dbip , dp, ptr )
struct db_i *dbip;
struct directory *dp;
genptr_t	ptr;
d427 1
a427 3
main(argc, argv)
int	argc;
char	*argv[];
@


11.38
log
@Added option to output BOT primitives rather than NMG's
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1993 by the United States Army
d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.37 2002/08/20 17:07:21 jra Exp $";
@


11.38.4.1
log
@merge from HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.39 2004/02/02 17:39:00 morrison Exp $";
@


11.38.4.2
log
@merge from head
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.38.4.1 2004/02/12 19:24:23 erikg Exp $";
@


11.37
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.35 2002/05/28 18:48:53 jra Exp $";
d49 1
a49 1
static char	usage[] = "Usage: %s [-v] [-xX lvl] [-a abs_tol] [-r rel_tol] [-n norm_tol] [-o out_file] brlcad_db.g object(s)\n";
d54 1
d93 1
a150 1
	BU_UNSETJUMP;		/* Relinquish the protection */
d155 3
d159 1
d211 6
a216 1
			mk_nmg( fp_out , nmg_name , r->m_p );
d465 1
a465 1
	while ((c = getopt(argc, argv, "t:a:n:o:r:vx:P:X:")) != EOF) {
d467 3
@


11.37.4.1
log
@sync to HEAD...
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d25 1
a25 1
static const char RCSid[] = "$Header: /n/cad/c/CVS/brlcad/conv/g-nmg.c,v 11.39 2004/02/02 17:39:00 morrison Exp $";
d49 1
a49 1
static char	usage[] = "Usage: %s [-v] [-b] [-xX lvl] [-a abs_tol] [-r rel_tol] [-n norm_tol] [-o out_file] brlcad_db.g object(s)\n";
a53 1
static int	do_bots=0;		/* flag to output BOT's instead of NMG's */
a91 1
	struct rt_bot_internal *bot;
d149 1
a153 3
	if( do_bots ) {
		bot = nmg_bot( BU_LIST_FIRST( shell, &r->s_hd ), tsp->ts_tol );
	}
a154 1
	BU_UNSETJUMP;		/* Relinquish the protection */
d206 1
a206 6

			if( do_bots ) {
				wdb_export( fp_out, nmg_name, (genptr_t)bot, ID_BOT, 1.0 );
			} else {
				mk_nmg( fp_out , nmg_name , r->m_p );
			}
d455 1
a455 1
	while ((c = getopt(argc, argv, "t:a:n:o:r:bvx:P:X:")) != EOF) {
a456 3
		case 'b':		/* make BOT's instead of NMG's */
			do_bots = 1;
			break;
@


11.37.6.1
log
@updated for merging
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.38 2003/04/24 17:44:09 jra Exp $";
d49 1
a49 1
static char	usage[] = "Usage: %s [-v] [-b] [-xX lvl] [-a abs_tol] [-r rel_tol] [-n norm_tol] [-o out_file] brlcad_db.g object(s)\n";
a53 1
static int	do_bots=0;		/* flag to output BOT's instead of NMG's */
a91 1
	struct rt_bot_internal *bot;
d149 1
a153 3
	if( do_bots ) {
		bot = nmg_bot( BU_LIST_FIRST( shell, &r->s_hd ), tsp->ts_tol );
	}
a154 1
	BU_UNSETJUMP;		/* Relinquish the protection */
d206 1
a206 6

			if( do_bots ) {
				wdb_export( fp_out, nmg_name, (genptr_t)bot, ID_BOT, 1.0 );
			} else {
				mk_nmg( fp_out , nmg_name , r->m_p );
			}
d455 1
a455 1
	while ((c = getopt(argc, argv, "t:a:n:o:r:bvx:P:X:")) != EOF) {
a456 3
		case 'b':		/* make BOT's instead of NMG's */
			do_bots = 1;
			break;
@


11.37.2.1
log
@Initial ANSIfication
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.37 2002/08/20 17:07:21 jra Exp $";
d75 5
a79 1
union tree *do_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
d266 4
a269 1
csg_comb_func(struct db_i *dbip, struct directory *dp, genptr_t ptr)
d424 3
a426 1
main(int argc, char **argv)
@


11.37.2.2
log
@sync branch with HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d25 1
a25 1
static const char RCSid[] = "$Header$";
d49 1
a49 1
static char	usage[] = "Usage: %s [-v] [-b] [-xX lvl] [-a abs_tol] [-r rel_tol] [-n norm_tol] [-o out_file] brlcad_db.g object(s)\n";
a53 1
static int	do_bots=0;		/* flag to output BOT's instead of NMG's */
a87 1
	struct rt_bot_internal *bot;
d145 1
a149 3
	if( do_bots ) {
		bot = nmg_bot( BU_LIST_FIRST( shell, &r->s_hd ), tsp->ts_tol );
	}
a150 1
	BU_UNSETJUMP;		/* Relinquish the protection */
d202 1
a202 6

			if( do_bots ) {
				wdb_export( fp_out, nmg_name, (genptr_t)bot, ID_BOT, 1.0 );
			} else {
				mk_nmg( fp_out , nmg_name , r->m_p );
			}
d446 1
a446 1
	while ((c = getopt(argc, argv, "t:a:n:o:r:bvx:P:X:")) != EOF) {
a447 3
		case 'b':		/* make BOT's instead of NMG's */
			do_bots = 1;
			break;
@


11.36
log
@Converted from K&R to ANSI C - RFH
@
text
@d75 5
a79 1
union tree *do_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
d266 4
a269 1
csg_comb_func(struct db_i *dbip, struct directory *dp, genptr_t ptr)
d424 3
a426 1
main(int argc, char **argv)
@


11.35
log
@Sean missed one mk_addmember() call in the previous update
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.34 2002/05/17 12:48:56 morrison Exp $";
d75 1
a75 5
union tree *do_region_end(tsp, pathp, curtree, client_data)
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
d262 1
a262 4
csg_comb_func( dbip , dp, ptr )
struct db_i *dbip;
struct directory *dp;
genptr_t	ptr;
d417 1
a417 3
main(argc, argv)
int	argc;
char	*argv[];
@


11.34
log
@added matrix parameter to mk_addmember()
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.33 2002/03/13 03:33:31 jra Exp $";
d386 1
a386 1
		wm = mk_addmember( tree_list[i].tl_tree->tr_l.tl_name , &headp.l , op );
@


11.33
log
@removed an excess nmg_kr()
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.32 2001/08/10 21:22:53 butler Exp $";
d221 1
a221 1
		(void)mk_addmember( nmg_name , &headp.l , WMOP_UNION );
@


11.32
log
@Compiler warning patches
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.31 2001/05/17 20:03:14 morrison Exp $";
a207 4

		/* NMG region is no longer necessary */
		if( !empty_model )
			nmg_kr(r);
@


11.31
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.30 2001/04/05 19:34:59 morrison Exp $";
d486 1
a486 1
			sscanf( optarg, "%x", &rt_g.debug );
d491 1
a491 1
			sscanf( optarg, "%x", &rt_g.NMG_debug );
@


11.30
log
@updated SIGNED to signed
updated CONST to const
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.29 2001/04/02 21:37:35 morrison Exp $";
d99 1
a99 1
	if (rt_g.debug&DEBUG_TREEWALK || verbose) {
d260 1
a260 1
	if( rt_g.debug&DEBUG_MEM_FULL )
d487 1
a487 1
			bu_printb( "librt rt_g.debug", rt_g.debug, DEBUG_FORMAT );
@


11.29
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.28 2000/10/31 22:35:12 mike Exp $";
d308 1
a308 1
		(void) db_walk_tree( dbip, 1, (CONST char **)name,
@


11.28
log
@
compiler lint
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.27 2000/10/20 20:29:24 jra Exp $";
d392 1
a392 1
			bn_mat_copy( wm->wm_mat, tree_list[i].tl_tree->tr_l.tl_mat );
@


11.27
log
@Added resource structure pointer to calls of db_functree()
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.26 2000/09/08 05:55:42 mike Exp $";
d88 1
a88 1
	unsigned char *color;
@


11.26
log
@
Tree routines now need resource structure.
Added rt_init_resource() call.
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.25 2000/08/24 03:17:21 mike Exp $";
d539 1
a539 1
		db_functree( dbip , dp , csg_comb_func , 0 , NULL );
@


11.25
log
@
mk_addmember()
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.24 2000/08/23 09:53:15 mike Exp $";
d131 1
a131 1
		db_free_tree(curtree);		/* Does an nmg_kr() */
d147 1
a147 1
	ret_tree = nmg_booltree_evaluate(curtree, tsp->ts_tol);	/* librt/nmg_bool.c */
d256 1
a256 1
	db_free_tree(curtree);		/* Does an nmg_kr() */
d324 1
a324 1
	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )
d337 1
a337 1
		db_non_union_push( comb->tree );
d349 2
a350 1
		actual_count = (struct rt_tree_array *)db_flatten_tree( tree_list, comb->tree, OP_UNION, 0 ) - tree_list;
d363 1
a363 1
		rt_db_free_internal( &intern );
d387 1
a387 1
				rt_db_free_internal( &intern );
d455 2
@


11.24
log
@
db_flatten_tree() got a new argument.
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.23 2000/07/21 12:44:34 jra Exp $";
d225 1
a225 1
		(void)mk_addmember( nmg_name , &headp , WMOP_UNION );
d389 1
a389 1
		wm = mk_addmember( tree_list[i].tl_tree->tr_l.tl_name , &headp , op );
d539 1
a539 1
	bn_vlist_cleanup();
@


11.23
log
@Replaced db_scan() calls with db_dirbuild()
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.22 2000/07/12 21:59:35 mike Exp $";
d349 2
a350 3
		actual_count = (struct rt_tree_array *)db_flatten_tree( tree_list, comb->tree, OP_UNION ) - tree_list;
		if( actual_count > node_count )  bu_bomb("csg_comb_func() array overflow!");
		if( actual_count < node_count )  bu_log("WARNING csg_comb_func() array underflow! %d < %d", actual_count, node_count);
@


11.22
log
@
Converted to use new version of LIBWDB
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.21 2000/07/10 23:53:57 mike Exp $";
d513 1
a513 1
	db_scan(dbip, (int (*)())db_diradd, 1, NULL);
@


11.21
log
@
lint
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.20 2000/03/29 18:15:16 mike Exp $";
d56 2
a57 2
static char	*out_file = NULL;	/* Output filename */
static FILE	*fp_out;		/* Output file pointer */
a80 1
	extern FILE		*fp_fig;
a432 1
	CONST char	*units;
d515 1
a515 3
	if( out_file == NULL )
		fp_out = stdout;
	else
d517 3
a519 6
		if ((fp_out = fopen( out_file , "w")) == NULL)
		{
			bu_log( "Cannot open %s\n" , out_file );
			perror( argv[0] );
			return 2;
		}
d524 1
a524 4
	if( units=rt_units_string( dbip->dbi_local2base ) )
		mk_id_units( fp_out , dbip->dbi_title , units );
	else
		mk_id( fp_out , dbip->dbi_title );
d554 1
@


11.20
log
@
Eliminated macro which also appears in vmath.h now
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.19 2000/03/29 18:07:44 mike Exp $";
@


11.19
log
@
Removed stray RT_EXTERNs, added bn_ prefix.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.18 2000/01/04 17:58:19 bparker Exp $";
a66 6

/* macro to determine if one bounding box is within another */
#define V3RPP1_IN_RPP2( _lo1 , _hi1 , _lo2 , _hi2 )	( \
	(_lo1)[X] >= (_lo2)[X] && (_hi1)[X] <= (_hi2)[X] && \
	(_lo1)[Y] >= (_lo2)[Y] && (_hi1)[Y] <= (_hi2)[Y] && \
	(_lo1)[Z] >= (_lo2)[Z] && (_hi1)[Z] <= (_hi2)[Z] )
@


11.18
log
@*- add client_data to db_walk_tree
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.17 1999/12/30 18:33:26 jra Exp $";
d47 1
a47 2
RT_EXTERN(union tree *do_region_end, (struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data));
RT_EXTERN( struct face *nmg_find_top_face , (struct shell *s , long *flags ));
@


11.17
log
@Eliminated some unused variables
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.16 1999/12/29 23:23:01 mike Exp $";
d47 1
a47 1
RT_EXTERN(union tree *do_region_end, (struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree));
d82 1
a82 1
union tree *do_region_end(tsp, pathp, curtree)
d86 1
d321 2
a322 1
			nmg_booltree_leaf_tess);
@


11.16
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.15 1999/12/29 21:09:17 mike Exp $";
d55 1
a55 1
static int	ncpu = 1;		/* Number of processors */
d287 1
a287 3
	int comb_len;
	int i,j;
	int region_flag;
d487 1
a487 1
			ncpu = atoi( optarg );
@


11.15
log
@
Added client_data pointer to db_functree() to eliminate use of
global variables.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.14 1999/11/29 18:01:49 mike Exp $";
d522 1
a522 1
	db_scan(dbip, (int (*)())db_diradd, 1);
@


11.14
log
@
Fixed compiler warning
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.13 1999/06/03 21:54:20 mike Exp $";
d277 1
a277 1
csg_comb_func( dbip , dp )
d280 1
d554 1
a554 1
		db_functree( dbip , dp , csg_comb_func , 0 );
@


11.13
log
@
sed4
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.12 1999/05/10 21:46:33 mike Exp $";
d331 1
a331 1
	if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )
@


11.12
log
@ma_override to ma_color_valid
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.11 1998/08/11 15:05:38 jra Exp $";
d61 1
a61 1
static struct rt_tol		tol;
d89 1
a89 1
	struct rt_list		vhead;
d101 1
a101 1
	RT_CK_TOL(tsp->ts_tol);
d104 1
a104 1
	RT_LIST_INIT(&vhead);
d108 1
a108 1
		rt_log("\ndo_region_end(%d %d%%) %s\n",
d112 1
a112 1
		rt_free(sofar, "path string");
d120 1
a120 1
	if( RT_SETJUMP )
d123 1
a123 1
		RT_UNSETJUMP;		/* Relinquish the protection */
d126 2
a127 2
		rt_log( "FAILED: %s\n", sofar );
		rt_free( (char *)sofar, "sofar" );
d147 1
a147 1
			rt_log("WARNING: tsp->ts_m pointer corrupted, ignoring it.\n");
d156 1
a156 1
	RT_UNSETJUMP;		/* Relinquish the protection */
d185 2
a186 2
		s = RT_LIST_FIRST( shell, &r->s_hd );
		while( RT_LIST_NOT_HEAD( &s->l, &r->s_hd ) )
d190 1
a190 1
			next_s = RT_LIST_PNEXT( shell, &s->l );
d231 1
a231 1
		RT_LIST_INIT( &headp.l );
d239 1
a239 1
			rt_log( "G-nmg: error in making region (%s)\n" , pathp->fp_names[pathp->fp_len-1]->d_namep );
d244 1
a244 1
		RT_LIST_INIT( &headp.l );
d251 1
a251 1
			rt_log( "G-nmg: error in making region (%s)\n" , pathp->fp_names[pathp->fp_len-1]->d_namep );
d268 1
a268 1
		rt_prmem( "At end of do_region_end()" );
d270 1
a270 1
	GETUNION(curtree, tree);
d340 1
a340 1
		rt_log( "Combination - %s\n" , dp->d_namep );
d368 1
a368 1
		rt_log( "Warning: empty combination (%s)\n" , dp->d_namep );
d374 1
a374 1
	RT_LIST_INIT( &headp.l );
d427 1
a427 1
			rt_log( "G-nmg: error in making region (%s)\n" , dp->d_namep );
d449 1
a449 1
	RT_LIST_INIT( &rt_g.rtg_vlfree );	/* for vlist macros */
d458 1
a458 1
	tol.magic = RT_TOL_MAGIC;
d493 2
a494 2
			rt_printb( "librt rt_g.debug", rt_g.debug, DEBUG_FORMAT );
			rt_log("\n");
d499 2
a500 2
			rt_printb( "librt rt_g.NMG_debug", rt_g.NMG_debug, NMG_DEBUG_FORMAT );
			rt_log("\n");
d517 1
a517 1
		rt_log( "Cannot open %s\n" , argv[optind] );
d529 1
a529 1
			rt_log( "Cannot open %s\n" , out_file );
d550 1
a550 1
			rt_log( "WARNING!!! Could not find %s, skipping\n", argv[i] );
d556 1
a556 1
	rt_vlist_cleanup();
d560 1
a560 1
	rt_prmem("After complete G-NMG conversion");
@


11.11
log
@Was not getting all the shader parameters!!!
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.10 1998/02/25 19:25:07 jra Exp $";
d221 1
a221 1
		if( tsp->ts_mater.ma_override )
@


11.10
log
@Eliminated a redundant nmg_model_fuse() and made the -r option accept degrees.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-nmg.c,v 11.9 1997/03/04 21:55:56 jra Exp jra $";
d92 1
d166 12
d235 1
a235 1
		    shader, matparm, color,
d247 1
a247 1
		    shader, matparm, color,
d254 2
@


11.9
log
@converted to comb import/export.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-nmg.c,v 11.8 1996/12/20 18:03:01 jra Exp jra $";
a152 1
	(void)nmg_model_fuse(*tsp->ts_m, tsp->ts_tol);
d460 1
a460 1
			ttol.norm = atof(optarg);
@


11.8
log
@Mods for new mater_info structure.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-nmg.c,v 11.7 1996/08/02 12:48:21 jra Exp jra $";
a40 1
#include "db.h"
d267 5
a271 1
	union record *rp;
d278 4
d315 1
a315 2
	if( (rp = db_getmrec( dbip, dp )) == (union record *)0 )
                return;
d317 8
d328 25
a352 2
	comb_len = dp->d_len - 1;
	if( comb_len == 0 )
d356 1
d362 1
a362 1
	for( i=1 ; i<dp->d_len ; i++ )
d364 22
a385 3
		wm = mk_addmember( rp[i].M.m_instname , &headp , rp[i].M.m_relation );
		for( j=0 ; j<16 ; j++ )
			wm->wm_mat[j] = rp[i].M.m_mat[j];
d388 2
a389 2
	if( rp[0].c.c_flags == 'R' )
		region_flag = 1;
d391 1
a391 1
		region_flag = 0;
d393 8
a400 2
	if( rp[0].c.c_override )
		color = rp[0].c.c_rgb;
d402 4
a405 1
		color = (unsigned char *)NULL;
d407 5
a411 5
	if( mk_lrcomb( fp_out, rp[0].c.c_name, &headp, region_flag,
	    rp[0].c.c_matname, rp[0].c.c_matparm,
	    color, rp[0].c.c_regionid,
	    rp[0].c.c_aircode, rp[0].c.c_material,rp[0].c.c_los,
	    rp[0].c.c_inherit ) )
d413 1
a413 1
			rt_log( "G-nmg: error in making region (%s)\n" , rp[0].c.c_name );
@


11.7
log
@Added "-t" option and improved handling of tessellation tolerance options.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-nmg.c,v 11.6 1996/07/12 13:20:17 jra Exp jra $";
d53 1
d96 2
d164 3
d224 1
a224 1
		    tsp->ts_mater.ma_matname, tsp->ts_mater.ma_matparm, color,
d236 1
a236 1
		    tsp->ts_mater.ma_matname, tsp->ts_mater.ma_matparm, color,
@


11.6
log
@Minor MOds for IRIX 6.2
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-nmg.c,v 11.5 1995/04/03 19:48:38 jra Exp jra $";
a286 13
		ttol.magic = RT_TESS_TOL_MAGIC;
		/* Defaults, updated by command line options. */
		ttol.abs = 0.0;
		ttol.rel = 0.01;
		ttol.norm = 0.0;

		/* XXX These need to be improved */
		tol.magic = RT_TOL_MAGIC;
		tol.dist = 0.005;
		tol.dist_sq = tol.dist * tol.dist;
		tol.perp = 1e-6;
		tol.para = 1 - tol.perp;

d365 13
d379 1
a379 1
	while ((c = getopt(argc, argv, "a:n:o:r:vx:P:X:")) != EOF) {
d381 3
d386 1
d390 1
@


11.5
log
@Added calls to nmg_kill_cracks() and nmg_kill_zero_length_edgeuses().
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-nmg.c,v 11.4 1995/03/29 18:35:08 jra Exp jra $";
d75 182
d264 1
a264 1
	int i;
d267 7
d276 36
d313 1
d332 5
a336 1
		(void)mk_addmember( rp[i].M.m_instname , &headp , rp[i].M.m_relation );
d343 5
d350 1
a350 1
	    (unsigned char *)rp[0].c.c_rgb, rp[0].c.c_regionid,
a375 26
	the_model = nmg_mm();
	tree_state = rt_initial_tree_state;	/* struct copy */
	tree_state.ts_tol = &tol;
	tree_state.ts_ttol = &ttol;
	tree_state.ts_m = &the_model;

	ttol.magic = RT_TESS_TOL_MAGIC;
	/* Defaults, updated by command line options. */
	ttol.abs = 0.0;
	ttol.rel = 0.01;
	ttol.norm = 0.0;

	/* XXX These need to be improved */
	tol.magic = RT_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;

	/* XXX For visualization purposes, in the debug plot files */
	{
		extern fastf_t	nmg_eue_dist;	/* librt/nmg_plot.c */
		/* XXX This value is specific to the Bradley */
		nmg_eue_dist = 2.0;
	}

d402 2
d408 2
d451 1
a451 18
	/* Walk indicated tree(s).  Each region will be output separately */
	(void)db_walk_tree(dbip, argc-optind, (CONST char **)(&argv[optind]),
		1,				/* ncpu */
		&tree_state,
		0,				/* select all regions */
		do_region_end,
		nmg_booltree_leaf_tess);	/* in librt/nmg_bool.c */

	percent = 0;
	if( regions_tried > 0 )
		percent = ((double)regions_converted * 100) / regions_tried;
	printf( "Tried %d regions, %d converted successfully.  %g%%\n",
		regions_tried, regions_converted, percent );

	/* Release dynamic storage */
	nmg_km(the_model);

	/* Now walk the same trees again, but only output groups */
d456 6
a461 1
		dp = db_lookup( dbip , argv[i] , 1 );
d472 7
a481 152
/*
*			D O _ R E G I O N _ E N D
*
*  Called from db_walk_tree().
*
*  This routine must be prepared to run in parallel.
*/
union tree *do_region_end(tsp, pathp, curtree)
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
{
	extern FILE		*fp_fig;
	struct nmgregion	*r;
	struct rt_list		vhead;
	union tree		*ret_tree;

	RT_CK_TESS_TOL(tsp->ts_ttol);
	RT_CK_TOL(tsp->ts_tol);
	NMG_CK_MODEL(*tsp->ts_m);

	RT_LIST_INIT(&vhead);

	if (rt_g.debug&DEBUG_TREEWALK || verbose) {
		char	*sofar = db_path_to_string(pathp);
		rt_log("\ndo_region_end(%d %d%%) %s\n",
			regions_tried,
			regions_tried>0 ? (regions_converted * 100) / regions_tried : 0,
			sofar);
		rt_free(sofar, "path string");
	}

	if (curtree->tr_op == OP_NOP)
		return  curtree;

	regions_tried++;
	/* Begin rt_bomb() protection */
	if( RT_SETJUMP )
	{
		/* Error, bail out */
		RT_UNSETJUMP;		/* Relinquish the protection */

		/* Sometimes the NMG library adds debugging bits when
		 * it detects an internal error, before rt_bomb().
		 */
		rt_g.NMG_debug = NMG_debug;	/* restore mode */

		/* Release any intersector 2d tables */
		nmg_isect2d_final_cleanup();

		/* Release the tree memory & input regions */
		db_free_tree(curtree);		/* Does an nmg_kr() */

		/* Get rid of (m)any other intermediate structures */
		if( (*tsp->ts_m)->magic == NMG_MODEL_MAGIC )
		{
			nmg_km(*tsp->ts_m);
		}
		else
		{
			rt_log("WARNING: tsp->ts_m pointer corrupted, ignoring it.\n");
		}
	
		/* Now, make a new, clean model structure for next pass. */
		*tsp->ts_m = nmg_mm();
		goto out;
	}
	(void)nmg_model_fuse(*tsp->ts_m, tsp->ts_tol);
	ret_tree = nmg_booltree_evaluate(curtree, tsp->ts_tol);	/* librt/nmg_bool.c */

	if( ret_tree )
		r = ret_tree->tr_d.td_r;
	else
		r = (struct nmgregion *)NULL;

	RT_UNSETJUMP;		/* Relinquish the protection */
	regions_converted++;
	if (r != 0)
	{
		char nmg_name[16];
		unsigned char rgb[3];
		struct wmember headp;
		struct shell *s;
		int empty_region=0;
		int empty_model=0;

		/* Kill cracks */
		s = RT_LIST_FIRST( shell, &r->s_hd );
		while( RT_LIST_NOT_HEAD( &s->l, &r->s_hd ) )
		{
			struct shell *next_s;

			next_s = RT_LIST_PNEXT( shell, &s->l );
			if( nmg_kill_cracks( s ) )
			{
				if( nmg_ks( s ) )
				{
					empty_region = 1;
					break;
				}
			}
			s = next_s;
		}

		/* kill zero length edgeuses */
		if( !empty_region )
		{
			 empty_model = nmg_kill_zero_length_edgeuses( *tsp->ts_m );
		}

		if( !empty_region && !empty_model )
		{
			/* Write the nmgregion to the output file */
			nmg_count++;
			sprintf( nmg_name , "nmg.%d" , nmg_count );
			mk_nmg( fp_out , nmg_name , *tsp->ts_m );
		}

		/* NMG region is no longer necessary */
		if( !empty_model )
			nmg_kr(r);

		/* Now make a normal brlcad region */
		RT_LIST_INIT( &headp.l );
		(void)mk_addmember( nmg_name , &headp , WMOP_UNION );
		rgb[0] = (int)(tsp->ts_mater.ma_color[0] * 255.0);
		rgb[1] = (int)(tsp->ts_mater.ma_color[1] * 255.0);
		rgb[2] = (int)(tsp->ts_mater.ma_color[2] * 255.0);
		if( mk_lrcomb( fp_out,
		    pathp->fp_names[pathp->fp_len-1]->d_namep, &headp, 1,
		    tsp->ts_mater.ma_matname, tsp->ts_mater.ma_matparm, rgb,
		    tsp->ts_regionid, tsp->ts_aircode, tsp->ts_gmater,
		    tsp->ts_los, tsp->ts_mater.ma_cinherit ) )
		{
			rt_log( "G-nmg: error in making region (%s)\n" , pathp->fp_names[pathp->fp_len-1]->d_namep );
		}
	}

	/*
	 *  Dispose of original tree, so that all associated dynamic
	 *  memory is released now, not at the end of all regions.
	 *  A return of TREE_NULL from this routine signals an error,
	 *  so we need to cons up an OP_NOP node to return.
	 */
	db_free_tree(curtree);		/* Does an nmg_kr() */

out:
	GETUNION(curtree, tree);
	curtree->magic = RT_TREE_MAGIC;
	curtree->tr_op = OP_NOP;
	return(curtree);
}
@


11.4
log
@Added "curtree->magic = RT_TREE_MAGIC;" to do_region_end().
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-nmg.c,v 11.3 1995/03/29 13:25:22 jra Exp jra $";
d356 27
d384 7
a390 4
		/* Write the nmgregion to the output file */
		nmg_count++;
		sprintf( nmg_name , "nmg.%d" , nmg_count );
		mk_nmg( fp_out , nmg_name , *tsp->ts_m );
d393 2
a394 1
		nmg_kr(r);
@


11.3
log
@Mods to account for new return of nmg_booltree_evaluate().
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-nmg.c,v 11.2 1995/02/22 05:40:55 mike Exp jra $";
d391 1
@


11.2
log
@nmg_model_fuse() is still accounting for 25% of the runtime.  In order
to correct this, it is necessary for me to make calling nmg_model_fuse()
a pre-condition of calling nmg_booltree_evaluate().  That way it's done
exactly once per region.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /n/wolf/m/cad/conv/RCS/g-nmg.c,v 11.1 1995/01/04 09:59:34 mike Rel4_4 mike $";
d289 1
d342 7
a348 1
	r = nmg_booltree_evaluate(curtree, tsp->ts_tol);	/* librt/nmg_bool.c */
@


11.1
log
@Release_4.4
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-nmg.c,v 1.7 94/12/29 20:22:44 mike Exp $";
d340 1
@


1.7
log
@#include resequence, so that db.h comes before raytrace.h,
so that types of db_getmrec() are properly defined.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-nmg.c,v 1.6 94/12/16 16:32:46 jra Exp Locker: mike $";
@


1.6
log
@removed setjmp.h
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-nmg.c,v 1.5 94/12/08 17:56:27 jra Exp Locker: jra $";
d41 1
a45 1
#include "db.h"
@


1.5
log
@Mod for CRAY2.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /n/wolf/m/cad/conv/RCS/g-nmg.c,v 1.4 94/11/08 16:15:06 jra Exp Locker: jra $";
a36 2

#include <setjmp.h>
@


1.4
log
@Mods for Irix 6.0
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /n/wolf/m/cad/conv/RCS/g-nmg.c,v 1.3 1994/11/01 04:16:30 butler Exp jra $";
d38 2
d312 1
a312 1
	if( ncpu == 1 && RT_SETJUMP )
@


1.3
log
@fixed libwdb calls
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-nmg.c,v 1.2 1994/08/11 00:05:57 gdurf Exp butler $";
d51 1
a51 1
static char	usage[] = "Usage: %s [-v] [-d] [-xX lvl] [-a abs_tol] [-r rel_tol] [-n norm_tol] [-o out_file] brlcad_db.g object(s)\n";
a54 1
static int	debug_plots;		/* Make debugging plots */
d84 1
a84 1
	struct wmember *wmem,headp;
d106 1
a106 1
		wmem = mk_addmember( rp[i].M.m_instname , &headp , rp[i].M.m_relation );
d131 1
a131 1
	int		i,j,ret;
d170 1
a170 1
	while ((c = getopt(argc, argv, "a:dn:o:r:vx:P:X:")) != EOF) {
a174 3
		case 'd':		/* debug plots */
			debug_plots = 1;
			break;
d239 1
a239 1
	ret = db_walk_tree(dbip, argc-optind, (CONST char **)(&argv[optind]),
d347 1
a347 1
		struct wmember headp,*wmem;
d359 1
a359 1
		wmem = mk_addmember( nmg_name , &headp , WMOP_UNION );
@


1.2
log
@Factored ifdefs
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-nmg.c,v 1.1 1994/01/07 13:01:59 jra Exp gdurf $";
d114 5
a118 3
	if( mk_lrcomb( fp_out , rp[0].c.c_name , &headp , region_flag , rp[0].c.c_matname , rp[0].c.c_matparm ,
		(char *)rp[0].c.c_rgb , rp[0].c.c_regionid , rp[0].c.c_aircode , rp[0].c.c_material ,
		rp[0].c.c_los , rp[0].c.c_inherit ) )
d350 1
a350 1
		char rgb[3];
d367 5
a371 3
		if( mk_lrcomb( fp_out , pathp->fp_names[pathp->fp_len-1]->d_namep , &headp , 1 ,
			tsp->ts_mater.ma_matname , tsp->ts_mater.ma_matparm , rgb , tsp->ts_regionid,
			tsp->ts_aircode , tsp->ts_gmater , tsp->ts_los , tsp->ts_mater.ma_cinherit ) )
@


1.1
log
@Initial revision
@
text
@d25 1
a25 1
static char RCSid[] = "$Header$";
d28 2
d32 1
d34 4
d135 1
a135 12
#ifdef BSD
	setlinebuf( stderr );
#else
#	if defined( SYSV ) && !defined( sgi ) && !defined(CRAY2) && \
	 !defined(n16)
		(void) setvbuf( stderr, (char *) NULL, _IOLBF, BUFSIZ );
#	endif
#	if defined(sgi) && defined(mips)
		if( setlinebuf( stderr ) != 0 )
			perror("setlinebuf(stderr)");
#	endif
#endif
@
