head	1.12;
access;
symbols
	ansi-20040405-merged:1.8.4.1
	postmerge-20040405-ansi:1.10
	premerge-20040404-ansi:1.10
	postmerge-autoconf:1.10
	autoconf-freeze:1.9.4.2
	premerge-autoconf:1.10
	ansi-20040316-freeze:1.8
	postmerge-20040315-windows:1.10
	premerge-20040315-windows:1.10
	windows-20040315-freeze:1.8.6.1
	autoconf-20031203:1.9
	autoconf-20031202:1.9
	autoconf-branch:1.9.0.4
	phong-branch:1.9.0.2
	photonmap-branch:1.8.0.8
	rel-6-1-DP:1.8
	windows-branch:1.8.0.6
	rel-6-0-2:1.8
	ansi-branch:1.8.0.4
	rel-6-0-1-branch:1.8.0.2
	hartley-6-0-post:1.8
	hartley-6-0-pre:1.8
	rel-6-0-1:1.8
	rel-6-0:1.8
	rel-5-4:1.5
	offsite-5-3-pre:1.7
	rel-5-3:1.5
	rel-5-2:1.5
	rel-5-1-branch:1.5.0.2
	rel-5-1:1.5
	rel-5-0:1.2
	rel-5-0-beta:1.1;
locks; strict;
comment	@ * @;


1.12
date	2004.05.24.04.16.12;	author morrison;	state dead;
branches;
next	1.11;

1.11
date	2004.05.10.15.30.41;	author erikg;	state Exp;
branches;
next	1.10;

1.10
date	2004.02.02.17.39.00;	author morrison;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.02.19.10.42;	author jra;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2001.05.17.20.03.14;	author morrison;	state Exp;
branches
	1.8.4.1
	1.8.6.1;
next	1.7;

1.7
date	2000.07.21.12.44.34;	author jra;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.10.23.53.58;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.29.18.07.45;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	99.12.29.23.23.02;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	99.12.29.21.09.17;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	99.06.03.21.54.20;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	99.01.27.03.08.37;	author jra;	state Exp;
branches;
next	;

1.8.4.1
date	2004.03.17.21.16.00;	author morrison;	state Exp;
branches;
next	;

1.8.6.1
date	2004.03.11.23.40.31;	author morrison;	state Exp;
branches;
next	;

1.9.4.1
date	2004.02.12.19.24.23;	author erikg;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2004.03.15.14.06.08;	author erikg;	state Exp;
branches;
next	;


desc
@@


1.12
log
@moved to src/conv/
@
text
@/*
 *			G - X X X . C
 *
 *	Sample code for converting BRL-CAD models to some other format.
 *	This code assumes that your receiving format can handle CSG primitives
 *	and Boolean trees with transformation matrices
 *
 *  Author -
 *	John R. Anderson
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1993-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */

#ifndef lint
static const char RCSid[] = "$Header: /n/xoff/cvs/brlcad/conv/g-xxx.c,v 1.11 2004/05/10 15:30:41 erikg Exp $";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "wdb.h"
#include "../librt/debug.h"

BU_EXTERN( void comb_func , ( struct db_i *dbip , struct directory *dp, genptr_t data ) );
BU_EXTERN( void primitive_func , ( struct db_i *dbip , struct directory *dp, genptr_t data ) );

static int	verbose;
static struct db_i		*dbip;
static struct bn_tol		tol;


static char	usage[] = "Usage: %s [-v] [-xX lvl] [-a abs_tol] [-r rel_tol] [-n norm_tol] [-o out_file] brlcad_db.g object(s)\n";

/*
 *			M A I N
 */
int
main(argc, argv)
int	argc;
char	*argv[];
{
	int		i;
	register int	c;

	port_setlinebuf( stderr );

	rt_init_resource(&rt_uniresource, 0, NULL);
	
	/* calculational tolerances
	 * mostly used by NMG routines
	 */
	tol.magic = BN_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;

	/* Get command line arguments. */
	while ((c = getopt(argc, argv, "t:a:n:o:r:vx:X:")) != EOF) {
		switch (c) {
		case 't':		/* calculational tolerance */
			tol.dist = atof( optarg );
			tol.dist_sq = tol.dist * tol.dist;
		case 'o':		/* Output file name */
			/* grab output file name */
			break;
		case 'v':		/* verbosity */
			verbose++;
			break;
		case 'x':		/* librt debug flag (see librt/debug.h) */
			sscanf( optarg, "%x", &rt_g.debug );
			bu_printb( "librt RT_G_DEBUG", RT_G_DEBUG, DEBUG_FORMAT );
			bu_log("\n");
			break;
		case 'X':		/* NMG debug flag (see h/nmg.h) */
			sscanf( optarg, "%x", &rt_g.NMG_debug );
			bu_printb( "librt rt_g.NMG_debug", rt_g.NMG_debug, NMG_DEBUG_FORMAT );
			bu_log("\n");
			break;
		default:
			fprintf(stderr, usage, argv[0]);
			exit(1);
			break;
		}
	}

	if (optind+1 >= argc) {
		fprintf(stderr, usage, argv[0]);
		exit(1);
	}

	/* Open brl-cad database */
	if ((dbip = db_open( argv[optind] , "r")) == DBI_NULL)
	{
		bu_log( "Cannot open %s\n" , argv[optind] );
		perror(argv[0]);
		exit(1);
	}

	/* scan all the records in the database and build a directory */
	db_dirbuild( dbip );

	/* open output file */

	optind++;

	/* Walk the trees named on the command line
	 * outputting combinations and primitives
	 */
	for( i=optind ; i<argc ; i++ )
	{
		struct directory *dp;

		dp = db_lookup( dbip , argv[i] , 0 );
		if( dp == DIR_NULL )
		{
			bu_log( "WARNING!!! Could not find %s, skipping\n", argv[i] );
			continue;
		}
		db_functree( dbip, dp, comb_func, primitive_func, &rt_uniresource, NULL );
	}

	db_close(dbip);

	return 0;
}

/* This routine just produces an ascii description of the Boolean tree.
 * In a real converter, this would output the tree in the desired format.
 */
void
describe_tree( dbip, comb, tree, str )
struct db_i             *dbip;
struct rt_comb_internal *comb;
union tree              *tree;
struct bu_vls		*str;
{
	struct bu_vls left, right;
	char *unionn=" u ";
	char *sub=" - ";
	char *inter=" + ";
	char *xor=" ^ ";
	char *op=NULL;

	BU_CK_VLS(str);

	if( !tree )
	{
		/* this tree has no members */
		bu_vls_strcat( str, "-empty-" );
		return;
	}

	RT_CK_TREE(tree);

	/* Handle all the possible node types.
	 * the first four are the most common types, and are typically
	 * the only ones found in a BRL-CAD database.
	 */
	switch( tree->tr_op )
	{
		case OP_DB_LEAF:	/* leaf node, this is a member */
			/* Note: tree->tr_l.tl_mat is a pointer to a
			 * transformation matrix to apply to this member
			 */
			bu_vls_strcat( str,  tree->tr_l.tl_name );
			break;
		case OP_UNION:		/* union operator node */
			op = unionn;
			goto binary;
		case OP_INTERSECT:	/* intersection operator node */
			op = inter;
			goto binary;
		case OP_SUBTRACT:	/* subtraction operator node */
			op = sub;
			goto binary;
		case OP_XOR:		/* exclusive "or" operator node */
			op = xor;
binary:				/* common for all binary nodes */
			bu_vls_init( &left );
			bu_vls_init( &right );
			describe_tree( dbip, comb, tree->tr_b.tb_left, &left );
			describe_tree( dbip, comb, tree->tr_b.tb_right, &right );
			bu_vls_putc( str, '(' );
			bu_vls_vlscatzap( str, &left );
			bu_vls_strcat( str, op );
			bu_vls_vlscatzap( str, &right );
			bu_vls_putc( str, ')' );
			break;
		case OP_NOT:
			bu_vls_strcat( str, "(!" );
			describe_tree( dbip, comb, tree->tr_b.tb_left, str );
			bu_vls_putc( str, ')' );
			break;
		case OP_GUARD:
			bu_vls_strcat( str, "(G" );
			describe_tree( dbip, comb, tree->tr_b.tb_left, str );
			bu_vls_putc( str, ')' );
			break;
		case OP_XNOP:
			bu_vls_strcat( str, "(X" );
			describe_tree( dbip, comb, tree->tr_b.tb_left, str );
			bu_vls_putc( str, ')' );
			break;
		case OP_NOP:
			bu_vls_strcat( str, "NOP" );
			break;
		default:
			bu_log( "ERROR: describe_tree() got unrecognized op (%d)\n", tree->tr_op );
			bu_bomb( "ERROR: bad op\n" );
	}
}

/* This function is called by the tree walker "db_functree" for each
 * combination encountered. This should either call a routine
 * to output the combination in your format, or do it itself.
 */
void
comb_func( dbip, dp, ptr )
struct db_i *dbip;
struct directory *dp;
genptr_t	ptr;
{
	struct rt_db_internal itrn;
	struct rt_comb_internal *comb;
	int id;
	struct bu_vls str;

	/* check if we already output this object */
	if( dp->d_uses )
		return;

	/* get the internal format of this combination */
	if( (id=rt_db_get_internal( &itrn, dp, dbip, bn_mat_identity, &rt_uniresource ) ) < 0 )
	{
		bu_log( "rt_db_get_internal failed for %s\n", dp->d_namep );
		return;
	}

	RT_CK_DB_INTERNAL( &itrn );

	if( id != ID_COMBINATION )
	{
		bu_log( "ERROR: comb_func called for a non-combination (%s)\n", dp->d_namep );
		exit( 1 );
	}

	/* get the combination structure */
	comb = (struct rt_comb_internal *)itrn.idb_ptr;

	/* here is where the conversion should be done */
	if( comb->region_flag )
		printf( "Write this region (name=%s) as a part in your format:\n", dp->d_namep );
	else
		printf( "Write this combination (name=%s) as an assembly in your format:\n", dp->d_namep );

	bu_vls_init( &str );

	describe_tree( dbip, comb, comb->tree, &str );

	printf( "\t%s\n\n", bu_vls_addr( &str ) );

	bu_vls_free( &str );

	/* mark this object as converted */
	dp->d_uses++;
}

/* This routine is called by the tree walker (db_functree)
 * for every primitive encountered in the trees specified on the command line */
void
primitive_func( dbip, dp, ptr )
struct db_i *dbip;
struct directory *dp;
genptr_t	ptr;
{
	struct rt_db_internal itrn;

	/* check if we already converted this primitive */
	if( dp->d_uses )
		return;

	/* get the internal form of the primitive */
	if( rt_db_get_internal( &itrn, dp, dbip, bn_mat_identity, &rt_uniresource ) < 0 )
	{
		bu_log( "rt_db_get_internal failed for %s\n", dp->d_namep );
		return;
	}

	RT_CK_DB_INTERNAL( &itrn );

	/* handle each type of primitive (see h/rtgeom.h) */
	if( itrn.idb_major_type == DB5_MAJORTYPE_BRLCAD ) {
		switch( itrn.idb_type )
			{
				/* most commonly used primitives */
			case ID_TOR:	/* torus */
				{
					struct rt_tor_internal *tor = (struct rt_tor_internal *)itrn.idb_ptr;

					printf( "Write this torus (name=%s) in your format:\n", dp->d_namep );
					printf( "\tV=(%g %g %g)\n", V3ARGS( tor->v ) );
					printf( "\tnormal=(%g %g %g)\n", V3ARGS( tor->h ) );
					printf( "\tradius1 = %g\n", tor->r_a );
					printf( "\tradius2 = %g\n", tor->r_h );
					break;
				}
			case ID_TGC: /* truncated general cone frustum */
			case ID_REC: /* right elliptical cylinder */
				{
					/* This primitive includes circular cross-section
					 * cones and cylinders
					 */
					struct rt_tgc_internal *tgc = (struct rt_tgc_internal *)itrn.idb_ptr;

					printf( "Write this TGC (name=%s) in your format:\n", dp->d_namep );
					printf( "\tV=(%g %g %g)\n", V3ARGS( tgc->v ) );
					printf( "\tH=(%g %g %g)\n", V3ARGS( tgc->h ) );
					printf( "\tA=(%g %g %g)\n", V3ARGS( tgc->a ) );
					printf( "\tB=(%g %g %g)\n", V3ARGS( tgc->b ) );
					printf( "\tC=(%g %g %g)\n", V3ARGS( tgc->c ) );
					printf( "\tD=(%g %g %g)\n", V3ARGS( tgc->d ) );
					break;
				}
			case ID_ELL:
			case ID_SPH:
				{
					/* spheres and ellipsoids */
					struct rt_ell_internal *ell = (struct rt_ell_internal *)itrn.idb_ptr;

					printf( "Write this ellipsoid (name=%s) in your format:\n", dp->d_namep );
					printf( "\tV=(%g %g %g)\n", V3ARGS( ell->v ) );
					printf( "\tA=(%g %g %g)\n", V3ARGS( ell->a ) );
					printf( "\tB=(%g %g %g)\n", V3ARGS( ell->b ) );
					printf( "\tC=(%g %g %g)\n", V3ARGS( ell->c ) );
					break;
				}
			case ID_ARB8:	/* convex primitive with from four to six faces */
				{
					/* this primitive may have degenerate faces
					 * faces are: 0123, 7654, 0347, 1562, 0451, 3267
					 * (points listed above in counter-clockwise order)
					 */
					struct rt_arb_internal *arb = (struct rt_arb_internal *)itrn.idb_ptr;
					int i;

					printf( "Write this ARB (name=%s) in your format:\n", dp->d_namep );
					for( i=0 ; i<8 ; i++ )
						printf( "\tpoint #%d: (%g %g %g)\n", i, V3ARGS( arb->pt[i] ) );
					break;
				}
			case ID_BOT:	/* Bag O' Triangles */
				{
					struct rt_bot_internal *bot = (struct rt_bot_internal *)itrn.idb_ptr;
					break;
				}

				/* less commonly used primitives */
			case ID_ARS:
				{
					/* series of curves
					 * each with the same number of points
					 */
					struct rt_ars_internal *ars = (struct rt_ars_internal *)itrn.idb_ptr;
					break;
				}
			case ID_HALF:
				{
					/* half universe defined by a plane */
					struct rt_half_internal *half = (struct rt_half_internal *)itrn.idb_ptr;
					break;
				}
			case ID_POLY:
				{
					/* polygons (up to 5 vertices per) */
					struct rt_pg_internal *pg = (struct rt_pg_internal *)itrn.idb_ptr;
					break;
				}
			case ID_BSPLINE:
				{
					/* NURB surfaces */
					struct rt_nurb_internal *nurb = (struct rt_nurb_internal *)itrn.idb_ptr;
					break;
				}
			case ID_NMG:
				{
					/* N-manifold geometry */
					struct model *m = (struct model *)itrn.idb_ptr;
					break;
				}
			case ID_ARBN:
				{
					struct rt_arbn_internal *arbn = (struct rt_arbn_internal *)itrn.idb_ptr;
					break;
				}

			case ID_DSP:
				{
					/* Displacement map (terrain primitive) */
					/* normally used for terrain only */
					/* the DSP primitive may reference an external file */
					struct rt_dsp_internal *dsp = (struct rt_dsp_internal *)itrn.idb_ptr;
					break;
				}
			case ID_HF:
				{
					/* height field (terrain primitive) */
					/* the HF primitive references an external file */
					struct rt_hf_internal *hf = (struct rt_hf_internal *)itrn.idb_ptr;
					break;
				}

				/* rarely used primitives */
			case ID_EBM:
				{
					/* extruded bit-map */
					/* the EBM primitive references an external file */
					struct rt_ebm_internal *ebm = (struct rt_ebm_internal *)itrn.idb_ptr;
					break;
				}
			case ID_VOL:
				{
					/* the VOL primitive references an external file */
					struct rt_vol_internal *vol = (struct rt_vol_internal *)itrn.idb_ptr;
					break;
				}
			case ID_PIPE:
				{
					struct rt_pipe_internal *pipe = (struct rt_pipe_internal *)itrn.idb_ptr;
					break;
				}
			case ID_PARTICLE:
				{
					struct rt_part_internal *part = (struct rt_part_internal *)itrn.idb_ptr;
					break;
				}
			case ID_RPC:
				{
					struct rt_rpc_internal *rpc = (struct rt_rpc_internal *)itrn.idb_ptr;
					break;
				}
			case ID_RHC:
				{
					struct rt_rhc_internal *rhc = (struct rt_rhc_internal *)itrn.idb_ptr;
					break;
				}
			case ID_EPA:
				{
					struct rt_epa_internal *epa = (struct rt_epa_internal *)itrn.idb_ptr;
					break;
				}
			case ID_EHY:
				{
					struct rt_ehy_internal *ehy = (struct rt_ehy_internal *)itrn.idb_ptr;
					break;
				}
			case ID_ETO:
				{
					struct rt_eto_internal *eto = (struct rt_eto_internal *)itrn.idb_ptr;
					break;
				}
			case ID_GRIP:
				{
					struct rt_grip_internal *grip = (struct rt_grip_internal *)itrn.idb_ptr;
					break;
				}
				
			case ID_SKETCH:
				{
					struct rt_sketch_internal *sketch = (struct rt_sketch_internal *)itrn.idb_ptr;
					break;
				}
			case ID_EXTRUDE:
				{
					/* note that an extrusion references a sketch, make sure you convert
					 * the sketch also
					 */
					struct rt_extrude_internal *extrude = (struct rt_extrude_internal *)itrn.idb_ptr;
					break;
				}
				
			default:
				bu_log( "Primitive %s is unrecognized type (%d)\n", dp->d_namep, itrn.idb_type );
				break;
			}
	} else {
		switch( itrn.idb_major_type ) {
			case DB5_MAJORTYPE_BINARY_UNIF:
				{
					/* not actually a primitive, just a block of storage for data
					 * a uniform array of chars, ints, floats, doubles, ...
					 */
					struct rt_binunif_internal *bin = (struct rt_binunif_internal *)itrn.idb_ptr;

					printf( "Found a binary object (%s)\n\n", dp->d_namep );
					break;
				}
			default:
				bu_log( "Major type of %s is unrecognized type (%d)\n", dp->d_namep, itrn.idb_major_type );
				break;
		}
	}

	/* mark this primitive as converted */
	dp->d_uses++;
}
@


1.11
log
@change conf.h to a wrapped config.h
@
text
@d26 1
a26 1
static const char RCSid[] = "$Header: /cvs/brlcad/conv/g-xxx.c,v 1.10 2004/02/02 17:39:00 morrison Exp $";
@


1.10
log
@update copyright to include span through 2003
@
text
@d26 1
a26 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-xxx.c,v 1.9 2003/09/02 19:10:42 jra Exp $";
d29 5
a33 1
#include "conf.h"
@


1.9
log
@Updated so it would compile
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1993 by the United States Army
d26 1
a26 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-xxx.c,v 1.8 2001/05/17 20:03:14 morrison Exp $";
@


1.9.4.1
log
@merge from HEAD
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d26 1
a26 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-xxx.c,v 1.10 2004/02/02 17:39:00 morrison Exp $";
@


1.9.4.2
log
@merge from head
@
text
@d26 1
a26 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-xxx.c,v 1.9.4.1 2004/02/12 19:24:23 erikg Exp $";
@


1.8
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d2 1
a2 1
 *			G - X X X , C
d4 3
a6 1
 *	Sample code for converting BRL-CAD models to some other format
d26 1
a26 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-xxx.c,v 1.7 2000/07/21 12:44:34 jra Exp $";
d48 2
a49 2
BU_EXTERN( void comb_func , ( struct db_i *dbip , struct directory *dp ) );
BU_EXTERN( void solid_func , ( struct db_i *dbip , struct directory *dp ) );
a50 2
static char	*tok_sep = " \t";
static int	NMG_debug;		/* saved arg of -X, for longjmp handling */
a51 3
static int	ncpu = 1;		/* Number of processors */
static char	*out_file = NULL;	/* Output filename */
static FILE	*fp_out;		/* Output file pointer */
a52 1
static struct rt_tess_tol	ttol;
a53 1
static struct model		*the_model;
a54 1
static struct db_tree_state	tree_state;	/* includes tol & model */
a67 1
	double		percent;
d71 2
a72 11
	BU_LIST_INIT( &rt_g.rtg_vlfree );	/* for vlist macros */

	/* tesselation tolerances
	 * only needed if you tessellate any solids
	 */
	ttol.magic = RT_TESS_TOL_MAGIC;
	/* Defaults, updated by command line options. */
	ttol.abs = 0.0;
	ttol.rel = 0.01;
	ttol.norm = 0.0;

a87 8
		case 'a':		/* Absolute tolerance. */
			ttol.abs = atof(optarg);
			ttol.rel = 0.0;
			break;
		case 'n':		/* Surface normal tolerance. */
			ttol.norm = atof(optarg)*bn_pi/180.0;
			ttol.rel = 0.0;
			break;
d89 1
a89 4
			out_file = optarg;
			break;
		case 'r':		/* Relative tolerance. */
			ttol.rel = atof(optarg);
a100 1
			NMG_debug = rt_g.NMG_debug;
a127 11
	if( out_file == NULL )
		fp_out = stdout;
	else
	{
		if ((fp_out = fopen( out_file , "w")) == NULL)
		{
			bu_log( "Cannot open %s\n" , out_file );
			perror( argv[0] );
			exit( 2 );
		}
	}
d132 1
a132 1
	 * outputting combinations and solids
d144 1
a144 1
		db_functree( dbip , dp , comb_func , solid_func , NULL );
a146 1
	bn_vlist_cleanup();
d258 1
a258 1
	if( (id=rt_db_get_internal( &itrn, dp, dbip, bn_mat_identity ) ) < 0 )
d279 1
a279 1
		printf( "Write this group (name=%s) as an assembly in your format:\n", dp->d_namep );
d285 1
a285 1
	printf( "%s\n", bu_vls_addr( &str ) );
d294 1
a294 1
 * for every solid encountered in the trees specified on the command line */
d296 1
a296 1
solid_func( dbip, dp, ptr )
a301 1
	int id;
d303 1
a303 1
	/* check if we already converted this solid */
d307 2
a308 2
	/* get the internal form of the solid */
	if( (id=rt_db_get_internal( &itrn, dp, dbip, bn_mat_identity ) ) < 0 )
d316 209
a524 97
	/* handle each type of solid (see h/rtgeom.h) */
	switch( itrn.idb_type )
	{
		/* most commonly used solids */
		case ID_TOR:	/* torus */
		{
			struct rt_tor_internal *tor = (struct rt_tor_internal *)itrn.idb_ptr;

			printf( "Write this torus (name=%s) in your format:\n", dp->d_namep );
			printf( "\tV=(%g %g %g)\n", V3ARGS( tor->v ) );
			printf( "\tnormal=(%g %g %g)\n", V3ARGS( tor->h ) );
			printf( "\tradius1 = %g\n", tor->r_a );
			printf( "\tradius2 = %g\n", tor->r_h );
			break;
		}
		case ID_TGC: /* truncated general cone frustum */
		case ID_REC: /* right elliptical cylinder */
		{
			/* This solid includes circular cross-section
			 * cones and cylinders
			 */
			struct rt_tgc_internal *tgc = (struct rt_tgc_internal *)itrn.idb_ptr;

			printf( "Write this TGC (name=%s) in your format:\n", dp->d_namep );
			printf( "\tV=(%g %g %g)\n", V3ARGS( tgc->v ) );
			printf( "\tH=(%g %g %g)\n", V3ARGS( tgc->h ) );
			printf( "\tA=(%g %g %g)\n", V3ARGS( tgc->a ) );
			printf( "\tB=(%g %g %g)\n", V3ARGS( tgc->b ) );
			printf( "\tC=(%g %g %g)\n", V3ARGS( tgc->c ) );
			printf( "\tD=(%g %g %g)\n", V3ARGS( tgc->d ) );
			break;
		}
		case ID_ELL:
		case ID_SPH:
		{
			/* spheres and ellipsoids */
			struct rt_ell_internal *ell = (struct rt_ell_internal *)itrn.idb_ptr;

			printf( "Write this ellipsoid (name=%s) in your format:\n", dp->d_namep );
			printf( "\tV=(%g %g %g)\n", V3ARGS( ell->v ) );
			printf( "\tA=(%g %g %g)\n", V3ARGS( ell->a ) );
			printf( "\tB=(%g %g %g)\n", V3ARGS( ell->b ) );
			printf( "\tC=(%g %g %g)\n", V3ARGS( ell->c ) );
			break;
		}
		case ID_ARB8:	/* convex solid with from four to six faces */
		{
			/* this solid may have degenerate faces
			 * faces are: 0123, 7654, 0347, 1562, 0451, 3267
			 * (points listed above in counter-clockwise order)
			 */
			struct rt_arb_internal *arb = (struct rt_arb_internal *)itrn.idb_ptr;
			int i;

			printf( "Write this ARB (name=%s) in your format:\n", dp->d_namep );
			for( i=0 ; i<8 ; i++ )
				printf( "\tpoint #%d: (%g %g %g)\n", i, V3ARGS( arb->pt[i] ) );
			break;
		}

		/* less commonly used solids */
		case ID_ARS:
		{
			/* series of curves
			 * each with the same number of points
			 */
			struct rt_ars_internal *ars = (struct rt_ars_internal *)itrn.idb_ptr;
			break;
		}
		case ID_HALF:
		{
			/* half universe defined by a plane */
			struct rt_half_internal *half = (struct rt_half_internal *)itrn.idb_ptr;
			break;
		}
		case ID_POLY:
		{
			/* polygons (up to 5 vertices per) */
			struct rt_pg_internal *pg = (struct rt_pg_internal *)itrn.idb_ptr;
			break;
		}
		case ID_BSPLINE:
		{
			/* NURB surfaces */
			struct rt_nurb_internal *nurb = (struct rt_nurb_internal *)itrn.idb_ptr;
			break;
		}
		case ID_NMG:
		{
			/* N-manifold geometry */
			struct model *m = (struct model *)itrn.idb_ptr;
			break;
		}
		case ID_ARBN:
		{
			struct rt_arbn_internal *arbn = (struct rt_arbn_internal *)itrn.idb_ptr;
			break;
a525 83

		/* normally used for terrain only */
		case ID_DSP:
		{
			/* Displacement map (terrain solid) */
			struct rt_dsp_internal *dsp = (struct rt_dsp_internal *)itrn.idb_ptr;
			break;
		}
		case ID_HF:
		{
			/* height field (terrain solid) */
			struct rt_hf_internal *hf = (struct rt_hf_internal *)itrn.idb_ptr;
			break;
		}

		/* rarely used solids */
		case ID_EBM:
		{
			/* extruded bit-map */
			struct rt_ebm_internal *ebm = (struct rt_ebm_internal *)itrn.idb_ptr;
			break;
		}
		case ID_VOL:
		{
			struct rt_vol_internal *vol = (struct rt_vol_internal *)itrn.idb_ptr;
			break;
		}
		case ID_PIPE:
		{
			struct rt_pipe_internal *pipe = (struct rt_pipe_internal *)itrn.idb_ptr;
			break;
		}
		case ID_PARTICLE:
		{
			struct rt_part_internal *part = (struct rt_part_internal *)itrn.idb_ptr;
			break;
		}
		case ID_RPC:
		{
			struct rt_rpc_internal *rpc = (struct rt_rpc_internal *)itrn.idb_ptr;
			break;
		}
		case ID_RHC:
		{
			struct rt_rhc_internal *rhc = (struct rt_rhc_internal *)itrn.idb_ptr;
			break;
		}
		case ID_EPA:
		{
			struct rt_epa_internal *epa = (struct rt_epa_internal *)itrn.idb_ptr;
			break;
		}
		case ID_EHY:
		{
			struct rt_ehy_internal *ehy = (struct rt_ehy_internal *)itrn.idb_ptr;
			break;
		}
		case ID_ETO:
		{
			struct rt_eto_internal *eto = (struct rt_eto_internal *)itrn.idb_ptr;
			break;
		}
		case ID_GRIP:
		{
			struct rt_grip_internal *grip = (struct rt_grip_internal *)itrn.idb_ptr;
			break;
		}

		/* Unimplemented solids */
		case ID_SKETCH:
		{
			struct rt_sketch_internal *sketch = (struct rt_sketch_internal *)itrn.idb_ptr;
			break;
		}
		case ID_EXTRUDE:
		{
			struct rt_extrude_internal *extrude = (struct rt_extrude_internal *)itrn.idb_ptr;
			break;
		}

		default:
			bu_log( "Solid %s is unrecognized type (%d)\n", dp->d_namep, itrn.idb_type );
			break;
d528 1
a528 1
	/* mark this solid as converted */
@


1.8.4.1
log
@sync branch with HEAD
@
text
@d2 1
a2 1
 *			G - X X X . C
d4 1
a4 3
 *	Sample code for converting BRL-CAD models to some other format.
 *	This code assumes that your receiving format can handle CSG primitives
 *	and Boolean trees with transformation matrices
d19 1
a19 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "$Header$";
d46 2
a47 2
BU_EXTERN( void comb_func , ( struct db_i *dbip , struct directory *dp, genptr_t data ) );
BU_EXTERN( void primitive_func , ( struct db_i *dbip , struct directory *dp, genptr_t data ) );
d49 2
d52 3
d56 1
d58 1
d60 1
d74 1
d78 11
a88 2
	rt_init_resource(&rt_uniresource, 0, NULL);
	
d104 8
d113 4
a116 1
			/* grab output file name */
d128 1
d156 11
d171 1
a171 1
	 * outputting combinations and primitives
d183 1
a183 1
		db_functree( dbip, dp, comb_func, primitive_func, &rt_uniresource, NULL );
d186 1
d298 1
a298 1
	if( (id=rt_db_get_internal( &itrn, dp, dbip, bn_mat_identity, &rt_uniresource ) ) < 0 )
d319 1
a319 1
		printf( "Write this combination (name=%s) as an assembly in your format:\n", dp->d_namep );
d325 1
a325 1
	printf( "\t%s\n\n", bu_vls_addr( &str ) );
d334 1
a334 1
 * for every primitive encountered in the trees specified on the command line */
d336 1
a336 1
primitive_func( dbip, dp, ptr )
d342 1
d344 1
a344 1
	/* check if we already converted this primitive */
d348 2
a349 2
	/* get the internal form of the primitive */
	if( rt_db_get_internal( &itrn, dp, dbip, bn_mat_identity, &rt_uniresource ) < 0 )
d357 97
a453 209
	/* handle each type of primitive (see h/rtgeom.h) */
	if( itrn.idb_major_type == DB5_MAJORTYPE_BRLCAD ) {
		switch( itrn.idb_type )
			{
				/* most commonly used primitives */
			case ID_TOR:	/* torus */
				{
					struct rt_tor_internal *tor = (struct rt_tor_internal *)itrn.idb_ptr;

					printf( "Write this torus (name=%s) in your format:\n", dp->d_namep );
					printf( "\tV=(%g %g %g)\n", V3ARGS( tor->v ) );
					printf( "\tnormal=(%g %g %g)\n", V3ARGS( tor->h ) );
					printf( "\tradius1 = %g\n", tor->r_a );
					printf( "\tradius2 = %g\n", tor->r_h );
					break;
				}
			case ID_TGC: /* truncated general cone frustum */
			case ID_REC: /* right elliptical cylinder */
				{
					/* This primitive includes circular cross-section
					 * cones and cylinders
					 */
					struct rt_tgc_internal *tgc = (struct rt_tgc_internal *)itrn.idb_ptr;

					printf( "Write this TGC (name=%s) in your format:\n", dp->d_namep );
					printf( "\tV=(%g %g %g)\n", V3ARGS( tgc->v ) );
					printf( "\tH=(%g %g %g)\n", V3ARGS( tgc->h ) );
					printf( "\tA=(%g %g %g)\n", V3ARGS( tgc->a ) );
					printf( "\tB=(%g %g %g)\n", V3ARGS( tgc->b ) );
					printf( "\tC=(%g %g %g)\n", V3ARGS( tgc->c ) );
					printf( "\tD=(%g %g %g)\n", V3ARGS( tgc->d ) );
					break;
				}
			case ID_ELL:
			case ID_SPH:
				{
					/* spheres and ellipsoids */
					struct rt_ell_internal *ell = (struct rt_ell_internal *)itrn.idb_ptr;

					printf( "Write this ellipsoid (name=%s) in your format:\n", dp->d_namep );
					printf( "\tV=(%g %g %g)\n", V3ARGS( ell->v ) );
					printf( "\tA=(%g %g %g)\n", V3ARGS( ell->a ) );
					printf( "\tB=(%g %g %g)\n", V3ARGS( ell->b ) );
					printf( "\tC=(%g %g %g)\n", V3ARGS( ell->c ) );
					break;
				}
			case ID_ARB8:	/* convex primitive with from four to six faces */
				{
					/* this primitive may have degenerate faces
					 * faces are: 0123, 7654, 0347, 1562, 0451, 3267
					 * (points listed above in counter-clockwise order)
					 */
					struct rt_arb_internal *arb = (struct rt_arb_internal *)itrn.idb_ptr;
					int i;

					printf( "Write this ARB (name=%s) in your format:\n", dp->d_namep );
					for( i=0 ; i<8 ; i++ )
						printf( "\tpoint #%d: (%g %g %g)\n", i, V3ARGS( arb->pt[i] ) );
					break;
				}
			case ID_BOT:	/* Bag O' Triangles */
				{
					struct rt_bot_internal *bot = (struct rt_bot_internal *)itrn.idb_ptr;
					break;
				}

				/* less commonly used primitives */
			case ID_ARS:
				{
					/* series of curves
					 * each with the same number of points
					 */
					struct rt_ars_internal *ars = (struct rt_ars_internal *)itrn.idb_ptr;
					break;
				}
			case ID_HALF:
				{
					/* half universe defined by a plane */
					struct rt_half_internal *half = (struct rt_half_internal *)itrn.idb_ptr;
					break;
				}
			case ID_POLY:
				{
					/* polygons (up to 5 vertices per) */
					struct rt_pg_internal *pg = (struct rt_pg_internal *)itrn.idb_ptr;
					break;
				}
			case ID_BSPLINE:
				{
					/* NURB surfaces */
					struct rt_nurb_internal *nurb = (struct rt_nurb_internal *)itrn.idb_ptr;
					break;
				}
			case ID_NMG:
				{
					/* N-manifold geometry */
					struct model *m = (struct model *)itrn.idb_ptr;
					break;
				}
			case ID_ARBN:
				{
					struct rt_arbn_internal *arbn = (struct rt_arbn_internal *)itrn.idb_ptr;
					break;
				}

			case ID_DSP:
				{
					/* Displacement map (terrain primitive) */
					/* normally used for terrain only */
					/* the DSP primitive may reference an external file */
					struct rt_dsp_internal *dsp = (struct rt_dsp_internal *)itrn.idb_ptr;
					break;
				}
			case ID_HF:
				{
					/* height field (terrain primitive) */
					/* the HF primitive references an external file */
					struct rt_hf_internal *hf = (struct rt_hf_internal *)itrn.idb_ptr;
					break;
				}

				/* rarely used primitives */
			case ID_EBM:
				{
					/* extruded bit-map */
					/* the EBM primitive references an external file */
					struct rt_ebm_internal *ebm = (struct rt_ebm_internal *)itrn.idb_ptr;
					break;
				}
			case ID_VOL:
				{
					/* the VOL primitive references an external file */
					struct rt_vol_internal *vol = (struct rt_vol_internal *)itrn.idb_ptr;
					break;
				}
			case ID_PIPE:
				{
					struct rt_pipe_internal *pipe = (struct rt_pipe_internal *)itrn.idb_ptr;
					break;
				}
			case ID_PARTICLE:
				{
					struct rt_part_internal *part = (struct rt_part_internal *)itrn.idb_ptr;
					break;
				}
			case ID_RPC:
				{
					struct rt_rpc_internal *rpc = (struct rt_rpc_internal *)itrn.idb_ptr;
					break;
				}
			case ID_RHC:
				{
					struct rt_rhc_internal *rhc = (struct rt_rhc_internal *)itrn.idb_ptr;
					break;
				}
			case ID_EPA:
				{
					struct rt_epa_internal *epa = (struct rt_epa_internal *)itrn.idb_ptr;
					break;
				}
			case ID_EHY:
				{
					struct rt_ehy_internal *ehy = (struct rt_ehy_internal *)itrn.idb_ptr;
					break;
				}
			case ID_ETO:
				{
					struct rt_eto_internal *eto = (struct rt_eto_internal *)itrn.idb_ptr;
					break;
				}
			case ID_GRIP:
				{
					struct rt_grip_internal *grip = (struct rt_grip_internal *)itrn.idb_ptr;
					break;
				}
				
			case ID_SKETCH:
				{
					struct rt_sketch_internal *sketch = (struct rt_sketch_internal *)itrn.idb_ptr;
					break;
				}
			case ID_EXTRUDE:
				{
					/* note that an extrusion references a sketch, make sure you convert
					 * the sketch also
					 */
					struct rt_extrude_internal *extrude = (struct rt_extrude_internal *)itrn.idb_ptr;
					break;
				}
				
			default:
				bu_log( "Primitive %s is unrecognized type (%d)\n", dp->d_namep, itrn.idb_type );
				break;
			}
	} else {
		switch( itrn.idb_major_type ) {
			case DB5_MAJORTYPE_BINARY_UNIF:
				{
					/* not actually a primitive, just a block of storage for data
					 * a uniform array of chars, ints, floats, doubles, ...
					 */
					struct rt_binunif_internal *bin = (struct rt_binunif_internal *)itrn.idb_ptr;

					printf( "Found a binary object (%s)\n\n", dp->d_namep );
					break;
				}
			default:
				bu_log( "Major type of %s is unrecognized type (%d)\n", dp->d_namep, itrn.idb_major_type );
				break;
d455 83
d540 1
a540 1
	/* mark this primitive as converted */
@


1.8.6.1
log
@sync to HEAD...
@
text
@d2 1
a2 1
 *			G - X X X . C
d4 1
a4 3
 *	Sample code for converting BRL-CAD models to some other format.
 *	This code assumes that your receiving format can handle CSG primitives
 *	and Boolean trees with transformation matrices
d19 1
a19 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "$Header: /n/cad/c/CVS/brlcad/conv/g-xxx.c,v 1.10 2004/02/02 17:39:00 morrison Exp $";
d46 2
a47 2
BU_EXTERN( void comb_func , ( struct db_i *dbip , struct directory *dp, genptr_t data ) );
BU_EXTERN( void primitive_func , ( struct db_i *dbip , struct directory *dp, genptr_t data ) );
d49 2
d52 3
d56 1
d58 1
d60 1
d74 1
d78 11
a88 2
	rt_init_resource(&rt_uniresource, 0, NULL);
	
d104 8
d113 4
a116 1
			/* grab output file name */
d128 1
d156 11
d171 1
a171 1
	 * outputting combinations and primitives
d183 1
a183 1
		db_functree( dbip, dp, comb_func, primitive_func, &rt_uniresource, NULL );
d186 1
d298 1
a298 1
	if( (id=rt_db_get_internal( &itrn, dp, dbip, bn_mat_identity, &rt_uniresource ) ) < 0 )
d319 1
a319 1
		printf( "Write this combination (name=%s) as an assembly in your format:\n", dp->d_namep );
d325 1
a325 1
	printf( "\t%s\n\n", bu_vls_addr( &str ) );
d334 1
a334 1
 * for every primitive encountered in the trees specified on the command line */
d336 1
a336 1
primitive_func( dbip, dp, ptr )
d342 1
d344 1
a344 1
	/* check if we already converted this primitive */
d348 2
a349 2
	/* get the internal form of the primitive */
	if( rt_db_get_internal( &itrn, dp, dbip, bn_mat_identity, &rt_uniresource ) < 0 )
d357 97
a453 209
	/* handle each type of primitive (see h/rtgeom.h) */
	if( itrn.idb_major_type == DB5_MAJORTYPE_BRLCAD ) {
		switch( itrn.idb_type )
			{
				/* most commonly used primitives */
			case ID_TOR:	/* torus */
				{
					struct rt_tor_internal *tor = (struct rt_tor_internal *)itrn.idb_ptr;

					printf( "Write this torus (name=%s) in your format:\n", dp->d_namep );
					printf( "\tV=(%g %g %g)\n", V3ARGS( tor->v ) );
					printf( "\tnormal=(%g %g %g)\n", V3ARGS( tor->h ) );
					printf( "\tradius1 = %g\n", tor->r_a );
					printf( "\tradius2 = %g\n", tor->r_h );
					break;
				}
			case ID_TGC: /* truncated general cone frustum */
			case ID_REC: /* right elliptical cylinder */
				{
					/* This primitive includes circular cross-section
					 * cones and cylinders
					 */
					struct rt_tgc_internal *tgc = (struct rt_tgc_internal *)itrn.idb_ptr;

					printf( "Write this TGC (name=%s) in your format:\n", dp->d_namep );
					printf( "\tV=(%g %g %g)\n", V3ARGS( tgc->v ) );
					printf( "\tH=(%g %g %g)\n", V3ARGS( tgc->h ) );
					printf( "\tA=(%g %g %g)\n", V3ARGS( tgc->a ) );
					printf( "\tB=(%g %g %g)\n", V3ARGS( tgc->b ) );
					printf( "\tC=(%g %g %g)\n", V3ARGS( tgc->c ) );
					printf( "\tD=(%g %g %g)\n", V3ARGS( tgc->d ) );
					break;
				}
			case ID_ELL:
			case ID_SPH:
				{
					/* spheres and ellipsoids */
					struct rt_ell_internal *ell = (struct rt_ell_internal *)itrn.idb_ptr;

					printf( "Write this ellipsoid (name=%s) in your format:\n", dp->d_namep );
					printf( "\tV=(%g %g %g)\n", V3ARGS( ell->v ) );
					printf( "\tA=(%g %g %g)\n", V3ARGS( ell->a ) );
					printf( "\tB=(%g %g %g)\n", V3ARGS( ell->b ) );
					printf( "\tC=(%g %g %g)\n", V3ARGS( ell->c ) );
					break;
				}
			case ID_ARB8:	/* convex primitive with from four to six faces */
				{
					/* this primitive may have degenerate faces
					 * faces are: 0123, 7654, 0347, 1562, 0451, 3267
					 * (points listed above in counter-clockwise order)
					 */
					struct rt_arb_internal *arb = (struct rt_arb_internal *)itrn.idb_ptr;
					int i;

					printf( "Write this ARB (name=%s) in your format:\n", dp->d_namep );
					for( i=0 ; i<8 ; i++ )
						printf( "\tpoint #%d: (%g %g %g)\n", i, V3ARGS( arb->pt[i] ) );
					break;
				}
			case ID_BOT:	/* Bag O' Triangles */
				{
					struct rt_bot_internal *bot = (struct rt_bot_internal *)itrn.idb_ptr;
					break;
				}

				/* less commonly used primitives */
			case ID_ARS:
				{
					/* series of curves
					 * each with the same number of points
					 */
					struct rt_ars_internal *ars = (struct rt_ars_internal *)itrn.idb_ptr;
					break;
				}
			case ID_HALF:
				{
					/* half universe defined by a plane */
					struct rt_half_internal *half = (struct rt_half_internal *)itrn.idb_ptr;
					break;
				}
			case ID_POLY:
				{
					/* polygons (up to 5 vertices per) */
					struct rt_pg_internal *pg = (struct rt_pg_internal *)itrn.idb_ptr;
					break;
				}
			case ID_BSPLINE:
				{
					/* NURB surfaces */
					struct rt_nurb_internal *nurb = (struct rt_nurb_internal *)itrn.idb_ptr;
					break;
				}
			case ID_NMG:
				{
					/* N-manifold geometry */
					struct model *m = (struct model *)itrn.idb_ptr;
					break;
				}
			case ID_ARBN:
				{
					struct rt_arbn_internal *arbn = (struct rt_arbn_internal *)itrn.idb_ptr;
					break;
				}

			case ID_DSP:
				{
					/* Displacement map (terrain primitive) */
					/* normally used for terrain only */
					/* the DSP primitive may reference an external file */
					struct rt_dsp_internal *dsp = (struct rt_dsp_internal *)itrn.idb_ptr;
					break;
				}
			case ID_HF:
				{
					/* height field (terrain primitive) */
					/* the HF primitive references an external file */
					struct rt_hf_internal *hf = (struct rt_hf_internal *)itrn.idb_ptr;
					break;
				}

				/* rarely used primitives */
			case ID_EBM:
				{
					/* extruded bit-map */
					/* the EBM primitive references an external file */
					struct rt_ebm_internal *ebm = (struct rt_ebm_internal *)itrn.idb_ptr;
					break;
				}
			case ID_VOL:
				{
					/* the VOL primitive references an external file */
					struct rt_vol_internal *vol = (struct rt_vol_internal *)itrn.idb_ptr;
					break;
				}
			case ID_PIPE:
				{
					struct rt_pipe_internal *pipe = (struct rt_pipe_internal *)itrn.idb_ptr;
					break;
				}
			case ID_PARTICLE:
				{
					struct rt_part_internal *part = (struct rt_part_internal *)itrn.idb_ptr;
					break;
				}
			case ID_RPC:
				{
					struct rt_rpc_internal *rpc = (struct rt_rpc_internal *)itrn.idb_ptr;
					break;
				}
			case ID_RHC:
				{
					struct rt_rhc_internal *rhc = (struct rt_rhc_internal *)itrn.idb_ptr;
					break;
				}
			case ID_EPA:
				{
					struct rt_epa_internal *epa = (struct rt_epa_internal *)itrn.idb_ptr;
					break;
				}
			case ID_EHY:
				{
					struct rt_ehy_internal *ehy = (struct rt_ehy_internal *)itrn.idb_ptr;
					break;
				}
			case ID_ETO:
				{
					struct rt_eto_internal *eto = (struct rt_eto_internal *)itrn.idb_ptr;
					break;
				}
			case ID_GRIP:
				{
					struct rt_grip_internal *grip = (struct rt_grip_internal *)itrn.idb_ptr;
					break;
				}
				
			case ID_SKETCH:
				{
					struct rt_sketch_internal *sketch = (struct rt_sketch_internal *)itrn.idb_ptr;
					break;
				}
			case ID_EXTRUDE:
				{
					/* note that an extrusion references a sketch, make sure you convert
					 * the sketch also
					 */
					struct rt_extrude_internal *extrude = (struct rt_extrude_internal *)itrn.idb_ptr;
					break;
				}
				
			default:
				bu_log( "Primitive %s is unrecognized type (%d)\n", dp->d_namep, itrn.idb_type );
				break;
			}
	} else {
		switch( itrn.idb_major_type ) {
			case DB5_MAJORTYPE_BINARY_UNIF:
				{
					/* not actually a primitive, just a block of storage for data
					 * a uniform array of chars, ints, floats, doubles, ...
					 */
					struct rt_binunif_internal *bin = (struct rt_binunif_internal *)itrn.idb_ptr;

					printf( "Found a binary object (%s)\n\n", dp->d_namep );
					break;
				}
			default:
				bu_log( "Major type of %s is unrecognized type (%d)\n", dp->d_namep, itrn.idb_major_type );
				break;
d455 83
d540 1
a540 1
	/* mark this primitive as converted */
@


1.7
log
@Replaced db_scan() calls with db_dirbuild()
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-xxx.c,v 1.6 2000/07/10 23:53:58 mike Exp $";
d123 1
a123 1
			bu_printb( "librt rt_g.debug", rt_g.debug, DEBUG_FORMAT );
@


1.6
log
@
lint
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-xxx.c,v 1.5 2000/03/29 18:07:45 mike Exp $";
d153 1
a153 1
	db_scan(dbip, (int (*)())db_diradd, 1, NULL);
@


1.5
log
@
Removed stray RT_EXTERNs, added bn_ prefix.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-xxx.c,v 1.4 1999/12/29 23:23:02 mike Exp $";
@


1.4
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-xxx.c,v 1.3 1999/12/29 21:09:17 mike Exp $";
d46 2
a47 2
RT_EXTERN( void comb_func , ( struct db_i *dbip , struct directory *dp ) );
RT_EXTERN( void solid_func , ( struct db_i *dbip , struct directory *dp ) );
@


1.3
log
@
Added client_data pointer to db_functree() to eliminate use of
global variables.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-xxx.c,v 1.2 1999/06/03 21:54:20 mike Exp $";
d153 1
a153 1
	db_scan(dbip, (int (*)())db_diradd, 1);
@


1.2
log
@
sed4
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-xxx.c,v 1.1 1999/01/27 03:08:37 jra Exp $";
d183 1
a183 1
		db_functree( dbip , dp , comb_func , solid_func );
d283 1
a283 1
comb_func( dbip, dp )
d286 1
d336 1
a336 1
solid_func( dbip, dp )
d339 1
@


1.1
log
@A sample converter.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.11 1998/08/11 15:05:38 jra Exp $";
d57 1
a57 1
static struct rt_tol		tol;
d78 1
a78 1
	RT_LIST_INIT( &rt_g.rtg_vlfree );	/* for vlist macros */
d92 1
a92 1
	tol.magic = RT_TOL_MAGIC;
d123 2
a124 2
			rt_printb( "librt rt_g.debug", rt_g.debug, DEBUG_FORMAT );
			rt_log("\n");
d129 2
a130 2
			rt_printb( "librt rt_g.NMG_debug", rt_g.NMG_debug, NMG_DEBUG_FORMAT );
			rt_log("\n");
d147 1
a147 1
		rt_log( "Cannot open %s\n" , argv[optind] );
d162 1
a162 1
			rt_log( "Cannot open %s\n" , out_file );
d180 1
a180 1
			rt_log( "WARNING!!! Could not find %s, skipping\n", argv[i] );
d186 1
a186 1
	rt_vlist_cleanup();
@

