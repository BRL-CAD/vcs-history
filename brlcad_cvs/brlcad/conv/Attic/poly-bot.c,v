head	11.13;
access;
symbols
	ansi-20040405-merged:11.9.2.2
	postmerge-20040405-ansi:11.11
	premerge-20040404-ansi:11.10
	postmerge-autoconf:11.10
	autoconf-freeze:11.9.10.2
	premerge-autoconf:11.10
	ansi-20040316-freeze:11.9.2.1
	postmerge-20040315-windows:11.10
	premerge-20040315-windows:11.10
	windows-20040315-freeze:11.9.4.1
	autoconf-20031203:11.9
	autoconf-20031202:11.9
	autoconf-branch:11.9.0.10
	phong-branch:11.9.0.8
	photonmap-branch:11.9.0.6
	rel-6-1-DP:11.9
	windows-branch:11.9.0.4
	rel-6-0-2:11.7
	ansi-branch:11.9.0.2
	rel-6-0-1-branch:11.7.0.2
	hartley-6-0-post:11.8
	hartley-6-0-pre:11.7
	rel-6-0-1:11.7
	rel-6-0:11.7
	rel-5-4:1.1.2.2
	offsite-5-3-pre:11.6
	rel-5-3:1.1.2.2
	rel-5-2:1.1.2.1
	rel-5-1-branch:1.1.0.2;
locks; strict;
comment	@ * @;


11.13
date	2004.05.24.04.16.13;	author morrison;	state dead;
branches;
next	11.12;

11.12
date	2004.05.10.15.30.42;	author erikg;	state Exp;
branches;
next	11.11;

11.11
date	2004.04.05.07.49.36;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2004.02.02.17.39.00;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2002.08.20.17.07.22;	author jra;	state Exp;
branches
	11.9.2.1
	11.9.4.1
	11.9.10.1;
next	11.8;

11.8
date	2002.08.15.20.54.35;	author hartley;	state Exp;
branches;
next	11.7;

11.7
date	2001.04.05.19.34.59;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	2000.11.20.20.18.12;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	2000.10.31.22.12.45;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	2000.10.30.22.11.50;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	2000.10.30.21.51.01;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	2000.10.24.19.10.43;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	2000.10.24.18.36.11;	author jra;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.01.14.30.12;	author jra;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2000.09.01.14.30.12;	author jra;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2000.11.20.19.56.36;	author jra;	state Exp;
branches;
next	;

11.9.2.1
date	2002.09.19.18.00.37;	author morrison;	state Exp;
branches;
next	11.9.2.2;

11.9.2.2
date	2004.03.17.21.16.01;	author morrison;	state Exp;
branches;
next	;

11.9.4.1
date	2004.03.11.23.40.31;	author morrison;	state Exp;
branches;
next	;

11.9.10.1
date	2004.02.12.19.24.24;	author erikg;	state Exp;
branches;
next	11.9.10.2;

11.9.10.2
date	2004.03.15.14.06.08;	author erikg;	state Exp;
branches;
next	;


desc
@@


11.13
log
@moved to src/conv/
@
text
@/*
 *			P O L Y - B O T
 *
 *  Program to convert all the polysolids in a BRL-CAD model (in a .g file) to BOT solids
 *
 *  Author -
 *	John R. Anderson
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 2000-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */

#ifndef lint
static const char RCSid[] = "$Header: /n/xoff/cvs/brlcad/conv/poly-bot.c,v 11.12 2004/05/10 15:30:42 erikg Exp $";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "nmg.h"
#include "db.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "wdb.h"
#include "../librt/plane.h"
#include "../librt/debug.h"

#define POLY_BLOCK	512

static const char *usage="\
Usage: poly-bot < file_poly.g > file_bot.g\n\
   or  poly-bot file_poly.g file_bot.g\n\
 Convert polysolids to BOT solids in v4 database format only\n";

int
main(int argc, char **argv)
{
	FILE *ifp;
	FILE *ofp;
	union record record;
	union record *poly;
	long poly_limit=0;
	long curr_poly=0;
	struct bn_tol		tol;
	int polys=0;
	int frees=0;
	int others=0;
	int bots=0;
	int i;
	int num_rec;
	int first=1;

	ifp = stdin;
	ofp = stdout;

        /* XXX These need to be improved */
        tol.magic = BN_TOL_MAGIC;
        tol.dist = 0.005;
        tol.dist_sq = tol.dist * tol.dist;
        tol.perp = 1e-6;
        tol.para = 1 - tol.perp;

	if( argc >= 3 ) {
		ifp = fopen(argv[1],"r");
		if( !ifp )  perror(argv[1]);
		ofp = fopen(argv[2],"w");
		if( !ofp )  perror(argv[2]);
		if (ifp == NULL || ofp == NULL) {
			(void)fprintf(stderr, "poly-bot: can't open files.");
			exit(1);
		}
	}
	if (isatty(fileno(ifp))) {
		(void)fprintf(stderr, usage);
		exit(1);
	}

	poly = (union record *)bu_malloc( POLY_BLOCK * sizeof( union record ), "poly" );
	poly_limit = POLY_BLOCK;

	/* Read database file */
	while( fread( (char *)&record, sizeof record, 1, ifp ) == 1  && !feof(ifp) )
	{
top:
		switch( record.u_id )
		{
			case ID_FREE:
				frees++;
				continue;

			case DBID_SKETCH:
				num_rec = bu_glong( (const unsigned char *)&record.skt.skt_count );
				others += num_rec + 1;
				if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
					bu_bomb( "Write failed!!!\n" );
				for( i=0 ; i<num_rec ; i++ )
				{
					if( fread( (char *)&record, sizeof record, 1, ifp ) != 1 )
						bu_bomb( "Unexpected EOF encountered while copying a SKETCH\n" );
					if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
						bu_bomb( "Write failed!!!\n" );
				}
				break;
			case DBID_EXTR:
				num_rec = bu_glong( (const unsigned char *)&record.extr.ex_count );
				others += num_rec + 1;
				if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
					bu_bomb( "Write failed!!!\n" );
				for( i=0 ; i<num_rec ; i++ )
				{
					if( fread( (char *)&record, sizeof record, 1, ifp ) != 1 )
						bu_bomb( "Unexpected EOF encountered while copying an EXTUSION\n" );
					if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
						bu_bomb( "Write failed!!!\n" );
				}
				break;
			case DBID_NMG:
				num_rec = bu_glong( (const unsigned char *)&record.nmg.N_count );
				others += num_rec + 1;
				if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
					bu_bomb( "Write failed!!!\n" );
				for( i=0 ; i<num_rec ; i++ )
				{
					if( fread( (char *)&record, sizeof record, 1, ifp ) != 1 )
						bu_bomb( "Unexpected EOF encountered while copying an ARBN\n" );
					if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
						bu_bomb( "Write failed!!!\n" );
				}
				break;
			case DBID_PIPE:
				num_rec = bu_glong( (const unsigned char *)&record.pwr.pwr_count );
				others += num_rec + 1;
				if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
					bu_bomb( "Write failed!!!\n" );
				for( i=0 ; i<num_rec ; i++ )
				{
					if( fread( (char *)&record, sizeof record, 1, ifp ) != 1 )
						bu_bomb( "Unexpected EOF encountered while copying a PIPE\n" );
					if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
						bu_bomb( "Write failed!!!\n" );
				}
				break;
			case DBID_ARBN:
				num_rec = bu_glong( (const unsigned char *)&record.n.n_grans );
				others += num_rec + 1;
				if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
					bu_bomb( "Write failed!!!\n" );
				for( i=0 ; i<num_rec ; i++ )
				{
					if( fread( (char *)&record, sizeof record, 1, ifp ) != 1 )
						bu_bomb( "Unexpected EOF encountered while copying an ARBN\n" );
					if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
						bu_bomb( "Write failed!!!\n" );
				}
				break;
			case DBID_STRSOL:
				num_rec = DB_SS_NGRAN - 1;
				others += num_rec + 1;
				if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
					bu_bomb( "Write failed!!!\n" );
				for( i=0 ; i<num_rec ; i++ )
				{
					if( fread( (char *)&record, sizeof record, 1, ifp ) != 1 )
						bu_bomb( "Unexpected EOF encountered while copying a STRSOL\n" );
					if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
						bu_bomb( "Write failed!!!\n" );
				}
				break;
			case ID_BSURF:
				num_rec = record.d.d_nknots + record.d.d_nctls;
				others += num_rec + 1;
				if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
					bu_bomb( "Write failed!!!\n" );
				for( i=0 ; i<num_rec ; i++ )
				{
					if( fread( (char *)&record, sizeof record, 1, ifp ) != 1 )
						bu_bomb( "Unexpected EOF encountered while copying a NURB\n" );
					if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
						bu_bomb( "Write failed!!!\n" );
				}
				break;
			case DBID_BOT:
				bots++;
				if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
					bu_bomb( "Write failed!!!\n" );
				num_rec = bu_glong( (const unsigned char *)&record.bot.bot_nrec );
				for( i=0 ; i<num_rec ; i++ )
				{
					if( fread( (char *)&record, sizeof record, 1, ifp ) != 1 )
						bu_bomb( "Unexpected EOF encountered while copying a BOT\n" );
					if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
						bu_bomb( "Write failed!!!\n" );
				}
				break;
			case ID_P_HEAD:
			{
				struct rt_db_internal intern;
				struct bu_external ext;
				struct bu_external ext2;

				polys++;
				curr_poly = 0;
				poly[curr_poly++] = record;	/* struct copy */
				bu_log( "Converting %s\n", poly[0].p.p_name );
				while( fread( (char *)&record, sizeof record, 1, ifp ) == 1  &&
					!feof(ifp) &&
					record.u_id == ID_P_DATA )
				{
					if( curr_poly >= poly_limit )
					{
						poly_limit += POLY_BLOCK;
						poly = (union record *)bu_realloc( poly, poly_limit*sizeof( union record ), "poly realloc" );
					}
					poly[curr_poly++] = record;	/* struct copy */
				}
				BU_INIT_EXTERNAL( &ext );
				ext.ext_nbytes = curr_poly * sizeof( union record );
				ext.ext_buf = (char *)poly;
				if( rt_functab[ID_POLY].ft_import( &intern, &ext, bn_mat_identity, (struct db_i *)NULL, &rt_uniresource ) )
				{
					bu_log( "Import failed for polysolid %s\n", poly[0].p.p_name );
					bu_bomb( "Import failed for polysolid\n" );
				}
				/* Don't free this ext buffer! */

				if( rt_pg_to_bot( &intern, &tol, &rt_uniresource ) < 0 )  {
					bu_log( "Unable to convert polysolid %s\n", poly[0].p.p_name );
					bu_bomb( "Unable to convert!!!\n" );
				}

				BU_INIT_EXTERNAL( &ext2 );
				if( rt_functab[ID_POLY].ft_export( &ext2, &intern, 1.0, (struct db_i *)NULL, &rt_uniresource ) < 0 )  {
					bu_log( "Unable to export v4 BoT %s\n", poly[0].p.p_name );
					bu_bomb( "Unable to convert!!!\n" );
				}
				rt_db_free_internal( &intern, &rt_uniresource );
				if( db_fwrite_external( ofp, poly[0].p.p_name, &ext2 ) < 0 )  {
					bu_log( "Unable to fwrite v4 BoT %s\n", poly[0].p.p_name );
					bu_bomb( "Unable to convert!!!\n" );
				}
				db_free_external( &ext2 );

				if( feof( ifp ) )
					break;
				goto top;
			}
			case ID_P_DATA:
				/* This should not happen!!!! */
				bu_log( "ERROR: Unattached polysolid data record!!!!\n" );
				continue;
			default:
				if( first )
				{
					if( record.u_id != ID_IDENT ) {
						bu_log( "This is not a BRL-CAD 'v4' database, aborting.\n" );
						exit( 1 );
					}
					first = 0;
				}
				others++;
				if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
					bu_bomb( "Write failed!!!\n" );
		}
	}

	bu_log( "%d polysolids converted to BOT solids\n", polys );
	bu_log( "%d BOT solids copied without change\n", bots );
	bu_log( "%d other records copied without change\n", others );
	bu_log( "%d free records skipped\n", frees );

	fclose(ofp);
	return 0;
}
@


11.12
log
@change conf.h to a wrapped config.h
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /cvs/brlcad/conv/poly-bot.c,v 11.11 2004/04/05 07:49:36 morrison Exp $";
@


11.11
log
@merge of ansi-6-0-branch into HEAD
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header$";
d27 5
a31 1
#include "conf.h"
@


11.10
log
@update copyright to include span through 2003
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/poly-bot.c,v 11.9 2002/08/20 17:07:22 jra Exp $";
d56 1
a56 3
main( argc, argv )
int argc;
char *argv[];
@


11.9
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 2000 by the United States Army
d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/poly-bot.c,v 11.7 2001/04/05 19:34:59 morrison Exp $";
@


11.9.4.1
log
@sync to HEAD...
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 2000-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "$Header: /n/cad/c/CVS/brlcad/conv/poly-bot.c,v 11.10 2004/02/02 17:39:00 morrison Exp $";
@


11.9.10.1
log
@merge from HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 2000-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/poly-bot.c,v 11.10 2004/02/02 17:39:00 morrison Exp $";
@


11.9.10.2
log
@merge from head
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/poly-bot.c,v 11.9.10.1 2004/02/12 19:24:24 erikg Exp $";
@


11.9.2.1
log
@Initial ANSIfication
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/poly-bot.c,v 11.9 2002/08/20 17:07:22 jra Exp $";
d56 3
a58 1
main(int argc, char **argv)
@


11.9.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 2000-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "$Header$";
@


11.8
log
@Converted from K&R to ANSI C - RFH
@
text
@d56 3
a58 1
main(int argc, char **argv)
@


11.7
log
@updated SIGNED to signed
updated CONST to const
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/poly-bot.c,v 11.6 2000/11/20 20:18:12 jra Exp $";
d56 1
a56 3
main( argc, argv )
int argc;
char *argv[];
@


11.6
log
@Needed to add code to actually look at any solid type that uses more than one granule :-(
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/poly-bot.c,v 11.5 2000/10/31 22:12:45 mike Exp $";
d114 1
a114 1
				num_rec = bu_glong( (CONST unsigned char *)&record.skt.skt_count );
d127 1
a127 1
				num_rec = bu_glong( (CONST unsigned char *)&record.extr.ex_count );
d140 1
a140 1
				num_rec = bu_glong( (CONST unsigned char *)&record.nmg.N_count );
d153 1
a153 1
				num_rec = bu_glong( (CONST unsigned char *)&record.pwr.pwr_count );
d166 1
a166 1
				num_rec = bu_glong( (CONST unsigned char *)&record.n.n_grans );
d208 1
a208 1
				num_rec = bu_glong( (CONST unsigned char *)&record.bot.bot_nrec );
@


11.5
log
@
Removed dead variable.
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/poly-bot.c,v 11.4 2000/10/30 22:11:50 mike Exp $";
d70 3
d112 105
d289 1
@


11.4
log
@
Converted to use LIBRT (g_pg.c) pg-->bot converter.
Changed to use the functab.
Changed not to use LIBWDB, so as to stick with raw v4 operation.
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/poly-bot.c,v 11.3 2000/10/30 21:51:01 mike Exp $";
a65 1
	struct rt_tess_tol	ttol;
a73 6

        ttol.magic = RT_TESS_TOL_MAGIC;
        /* Defaults, updated by command line options. */
        ttol.abs = 0.0;
        ttol.rel = 0.01;
        ttol.norm = 0.0;
@


11.3
log
@
Minor lint
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/poly-bot.c,v 11.2 2000/10/24 19:10:43 jra Exp $";
d120 1
a120 7
				struct rt_bot_internal *bot;
				struct soltab st;
				struct rt_i rti;
				struct tri_specific *tri;
				int i;

				rti.rti_tol = tol;
d140 1
a140 1
				if( rt_pg_import( &intern, &ext, bn_mat_identity, (struct db_i *)NULL ) )
d145 3
a147 3
				st.st_specific = (genptr_t)NULL;
				if( rt_pg_prep( &st, &intern, &rti ) )
				{
d152 4
a155 12
				tri = (struct tri_specific *)st.st_specific;
				bot = (struct rt_bot_internal *)bu_calloc( 1, sizeof( struct rt_bot_internal), "bot" );
				bot->magic = RT_BOT_INTERNAL_MAGIC;
				bot->mode = RT_BOT_SOLID;
				bot->orientation = RT_BOT_CCW;
				bot->num_vertices = 0;
				bot->num_faces = 0;

				while( tri )
				{
					bot->num_faces++;
					tri = tri->tri_forw;
d157 4
a160 17

				bot->faces = (int *)bu_calloc( bot->num_faces * 3, sizeof( int ), "bot->faces" );
				bot->num_vertices = bot->num_faces * 3;
				bot->vertices = (fastf_t *)bu_calloc( bot->num_vertices * 3, sizeof( fastf_t ), "bot->vertices" );

				i = 0;
				tri = (struct tri_specific *)st.st_specific;
				while( tri )
				{
					bot->faces[i] = i;
					bot->faces[i + 1] = i + 1;
					bot->faces[i + 2] = i + 2;
					VMOVE( &bot->vertices[i*3], tri->tri_A );
					VADD2( &bot->vertices[(i+1)*3], tri->tri_A, tri->tri_BA );
					VADD2( &bot->vertices[(i+2)*3], tri->tri_A, tri->tri_CA );
					tri = tri->tri_forw;
					i += 3;
d162 1
a163 16
				(void)rt_bot_vertex_fuse( bot );

				mk_export_fwrite( ofp, poly[0].p.p_name, (genptr_t)bot, ID_BOT );

				tri = (struct tri_specific *)st.st_specific;
				while( tri )
				{
					struct tri_specific *tmp;

					tmp = tri;
					tri = tri->tri_forw;
					bu_free( (char *)tmp, "tri_specific" );
				}
				bu_free( (char *)bot->faces, "bot->faces" );
				bu_free( (char *)bot->vertices, "bot->vertices" );
				bu_free( (char *)bot, "bot" );
d176 1
a176 1
						bu_log( "This is not a 'v4' database!!!\n" );
@


11.2
log
@Mods to recognize a v5 database and refuse to process it
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/poly-bot.c,v 11.1 2000/10/24 18:36:11 jra Exp $";
d50 1
a50 1
static char *usage="\
d53 1
a53 1
 Convert polysolids to BOT solids\n";
d55 1
d190 1
a190 1
				(void)bot_vertex_fuse( bot );
d232 3
@


11.1
log
@Corrected an error message
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/Attic/poly-bot.c,v 1.1.2.1 2000/09/01 14:30:12 jra Exp $";
d70 1
d214 8
@


1.1
log
@file poly-bot.c was initially added on branch rel-5-1-patches.
@
text
@d1 222
@


1.1.2.1
log
@Initial version of code to convert all the polysolids in a model to BOT's
@
text
@a0 222
/*
 *			P O L Y - B O T
 *
 *  Program to convert all the polysolids in a BRL-CAD model (in a .g file) to BOT solids
 *
 *  Author -
 *	John R. Anderson
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 2000 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */

#ifndef lint
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-nmg.c,v 11.20 2000/03/29 18:15:16 mike Exp $";
#endif

#include "conf.h"

#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "nmg.h"
#include "db.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "wdb.h"
#include "../librt/plane.h"
#include "../librt/debug.h"

#define POLY_BLOCK	512

static char *usage="\
Usage: poly-bot < file_poly.g > file_bot.g\n\
   or  poly-bot file_poly.g file_bot.g\n\
 Convert polysolids to BOT solids\n";

main( argc, argv )
int argc;
char *argv[];
{
	FILE *ifp;
	FILE *ofp;
	union record record;
	union record *poly;
	long poly_limit=0;
	long curr_poly=0;
	struct rt_tess_tol	ttol;
	struct bn_tol		tol;
	int polys=0;
	int frees=0;
	int others=0;

	ifp = stdin;
	ofp = stdout;

        ttol.magic = RT_TESS_TOL_MAGIC;
        /* Defaults, updated by command line options. */
        ttol.abs = 0.0;
        ttol.rel = 0.01;
        ttol.norm = 0.0;

        /* XXX These need to be improved */
        tol.magic = BN_TOL_MAGIC;
        tol.dist = 0.005;
        tol.dist_sq = tol.dist * tol.dist;
        tol.perp = 1e-6;
        tol.para = 1 - tol.perp;

	if( argc >= 3 ) {
		ifp = fopen(argv[1],"r");
		if( !ifp )  perror(argv[1]);
		ofp = fopen(argv[2],"w");
		if( !ofp )  perror(argv[2]);
		if (ifp == NULL || ofp == NULL) {
			(void)fprintf(stderr, "g2asc: can't open files.");
			exit(1);
		}
	}
	if (isatty(fileno(ifp))) {
		(void)fprintf(stderr, usage);
		exit(1);
	}

	poly = (union record *)bu_malloc( POLY_BLOCK * sizeof( union record ), "poly" );
	poly_limit = POLY_BLOCK;

	/* Read database file */
	while( fread( (char *)&record, sizeof record, 1, ifp ) == 1  && !feof(ifp) )
	{
top:
		switch( record.u_id )
		{
			case ID_FREE:
				frees++;
				continue;
			case ID_P_HEAD:
			{
				struct rt_db_internal intern;
				struct bu_external ext;
				struct rt_bot_internal *bot;
				struct soltab st;
				struct rt_i rti;
				struct tri_specific *tri;
				int i;

				rti.rti_tol = tol;

				polys++;
				curr_poly = 0;
				poly[curr_poly++] = record;	/* struct copy */
				bu_log( "Converting %s\n", poly[0].p.p_name );
				while( fread( (char *)&record, sizeof record, 1, ifp ) == 1  &&
					!feof(ifp) &&
					record.u_id == ID_P_DATA )
				{
					if( curr_poly >= poly_limit )
					{
						poly_limit += POLY_BLOCK;
						poly = (union record *)bu_realloc( poly, poly_limit*sizeof( union record ), "poly realloc" );
					}
					poly[curr_poly++] = record;	/* struct copy */
				}
				BU_INIT_EXTERNAL( &ext );
				ext.ext_nbytes = curr_poly * sizeof( union record );
				ext.ext_buf = (char *)poly;
				if( rt_pg_import( &intern, &ext, bn_mat_identity, (struct db_i *)NULL ) )
				{
					bu_log( "Import failed for polysolid %s\n", poly[0].p.p_name );
					bu_bomb( "Import failed for polysolid\n" );
				}
				st.st_specific = (genptr_t)NULL;
				if( rt_pg_prep( &st, &intern, &rti ) )
				{
					bu_log( "Unable to convert polysolid %s\n", poly[0].p.p_name );
					bu_bomb( "Unable to convert!!!\n" );
				}

				tri = (struct tri_specific *)st.st_specific;
				bot = (struct rt_bot_internal *)bu_calloc( 1, sizeof( struct rt_bot_internal), "bot" );
				bot->magic = RT_BOT_INTERNAL_MAGIC;
				bot->mode = RT_BOT_SOLID;
				bot->orientation = RT_BOT_CCW;
				bot->num_vertices = 0;
				bot->num_faces = 0;

				while( tri )
				{
					bot->num_faces++;
					tri = tri->tri_forw;
				}

				bot->faces = (int *)bu_calloc( bot->num_faces * 3, sizeof( int ), "bot->faces" );
				bot->num_vertices = bot->num_faces * 3;
				bot->vertices = (fastf_t *)bu_calloc( bot->num_vertices * 3, sizeof( fastf_t ), "bot->vertices" );

				i = 0;
				tri = (struct tri_specific *)st.st_specific;
				while( tri )
				{
					bot->faces[i] = i;
					bot->faces[i + 1] = i + 1;
					bot->faces[i + 2] = i + 2;
					VMOVE( &bot->vertices[i*3], tri->tri_A );
					VADD2( &bot->vertices[(i+1)*3], tri->tri_A, tri->tri_BA );
					VADD2( &bot->vertices[(i+2)*3], tri->tri_A, tri->tri_CA );
					tri = tri->tri_forw;
					i += 3;
				}

				(void)bot_vertex_fuse( bot );

				mk_export_fwrite( ofp, poly[0].p.p_name, (genptr_t)bot, ID_BOT );

				tri = (struct tri_specific *)st.st_specific;
				while( tri )
				{
					struct tri_specific *tmp;

					tmp = tri;
					tri = tri->tri_forw;
					bu_free( (char *)tmp, "tri_specific" );
				}
				bu_free( (char *)bot->faces, "bot->faces" );
				bu_free( (char *)bot->vertices, "bot->vertices" );
				bu_free( (char *)bot, "bot" );
				if( feof( ifp ) )
					break;
				goto top;
			}
			case ID_P_DATA:
				/* This should not happen!!!! */
				bu_log( "ERROR: Unattached polysolid data record!!!!\n" );
				continue;
			default:
				others++;
				if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
					bu_bomb( "Write failed!!!\n" );
		}
	}

	bu_log( "%d polysolids converted to BOT solids\n", polys );
	bu_log( "%d other records copied without change\n", others );
	bu_log( "%d free records skipped\n", frees );
}
@


1.1.2.2
log
@Needed to add code to actually look at any solid type that uses more than one granule :-(
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/Attic/poly-bot.c,v 1.1.2.1 2000/09/01 14:30:12 jra Exp $";
a69 3
	int bots=0;
	int i;
	int num_rec;
a113 105

			case DBID_SKETCH:
				num_rec = bu_glong( (CONST unsigned char *)&record.skt.skt_count );
				others += num_rec + 1;
				if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
					bu_bomb( "Write failed!!!\n" );
				for( i=0 ; i<num_rec ; i++ )
				{
					if( fread( (char *)&record, sizeof record, 1, ifp ) != 1 )
						bu_bomb( "Unexpected EOF encountered while copying a SKETCH\n" );
					if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
						bu_bomb( "Write failed!!!\n" );
				}
				break;
			case DBID_EXTR:
				num_rec = bu_glong( (CONST unsigned char *)&record.extr.ex_count );
				others += num_rec + 1;
				if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
					bu_bomb( "Write failed!!!\n" );
				for( i=0 ; i<num_rec ; i++ )
				{
					if( fread( (char *)&record, sizeof record, 1, ifp ) != 1 )
						bu_bomb( "Unexpected EOF encountered while copying an EXTUSION\n" );
					if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
						bu_bomb( "Write failed!!!\n" );
				}
				break;
			case DBID_NMG:
				num_rec = bu_glong( (CONST unsigned char *)&record.nmg.N_count );
				others += num_rec + 1;
				if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
					bu_bomb( "Write failed!!!\n" );
				for( i=0 ; i<num_rec ; i++ )
				{
					if( fread( (char *)&record, sizeof record, 1, ifp ) != 1 )
						bu_bomb( "Unexpected EOF encountered while copying an ARBN\n" );
					if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
						bu_bomb( "Write failed!!!\n" );
				}
				break;
			case DBID_PIPE:
				num_rec = bu_glong( (CONST unsigned char *)&record.pwr.pwr_count );
				others += num_rec + 1;
				if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
					bu_bomb( "Write failed!!!\n" );
				for( i=0 ; i<num_rec ; i++ )
				{
					if( fread( (char *)&record, sizeof record, 1, ifp ) != 1 )
						bu_bomb( "Unexpected EOF encountered while copying a PIPE\n" );
					if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
						bu_bomb( "Write failed!!!\n" );
				}
				break;
			case DBID_ARBN:
				num_rec = bu_glong( (CONST unsigned char *)&record.n.n_grans );
				others += num_rec + 1;
				if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
					bu_bomb( "Write failed!!!\n" );
				for( i=0 ; i<num_rec ; i++ )
				{
					if( fread( (char *)&record, sizeof record, 1, ifp ) != 1 )
						bu_bomb( "Unexpected EOF encountered while copying an ARBN\n" );
					if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
						bu_bomb( "Write failed!!!\n" );
				}
				break;
			case DBID_STRSOL:
				num_rec = DB_SS_NGRAN - 1;
				others += num_rec + 1;
				if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
					bu_bomb( "Write failed!!!\n" );
				for( i=0 ; i<num_rec ; i++ )
				{
					if( fread( (char *)&record, sizeof record, 1, ifp ) != 1 )
						bu_bomb( "Unexpected EOF encountered while copying a STRSOL\n" );
					if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
						bu_bomb( "Write failed!!!\n" );
				}
				break;
			case ID_BSURF:
				num_rec = record.d.d_nknots + record.d.d_nctls;
				others += num_rec + 1;
				if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
					bu_bomb( "Write failed!!!\n" );
				for( i=0 ; i<num_rec ; i++ )
				{
					if( fread( (char *)&record, sizeof record, 1, ifp ) != 1 )
						bu_bomb( "Unexpected EOF encountered while copying a NURB\n" );
					if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
						bu_bomb( "Write failed!!!\n" );
				}
				break;
			case DBID_BOT:
				bots++;
				if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
					bu_bomb( "Write failed!!!\n" );
				num_rec = bu_glong( (CONST unsigned char *)&record.bot.bot_nrec );
				for( i=0 ; i<num_rec ; i++ )
				{
					if( fread( (char *)&record, sizeof record, 1, ifp ) != 1 )
						bu_bomb( "Unexpected EOF encountered while copying a BOT\n" );
					if( fwrite( &record, sizeof( union record ), 1, ofp ) < 1 )
						bu_bomb( "Write failed!!!\n" );
				}
				break;
a219 1
	bu_log( "%d BOT solids copied without change\n", bots );
@


