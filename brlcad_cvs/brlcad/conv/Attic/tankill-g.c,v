head	11.24;
access;
symbols
	ansi-20040405-merged:11.19.2.2
	postmerge-20040405-ansi:11.22
	premerge-20040404-ansi:11.21
	postmerge-autoconf:11.21
	autoconf-freeze:11.19.10.3
	premerge-autoconf:11.21
	ansi-20040316-freeze:11.19.2.1
	postmerge-20040315-windows:11.21
	premerge-20040315-windows:11.21
	windows-20040315-freeze:11.19.4.1
	autoconf-20031203:11.19.10.1
	autoconf-20031202:11.19
	autoconf-branch:11.19.0.10
	phong-branch:11.19.0.8
	photonmap-branch:11.19.0.6
	rel-6-1-DP:11.19
	windows-branch:11.19.0.4
	rel-6-0-2:11.17
	ansi-branch:11.19.0.2
	rel-6-0-1-branch:11.17.0.2
	hartley-6-0-post:11.18
	hartley-6-0-pre:11.17
	rel-6-0-1:11.17
	rel-6-0:11.16
	rel-5-4:11.11
	offsite-5-3-pre:11.14
	rel-5-3:11.11
	rel-5-2:11.11
	rel-5-1-branch:11.11.0.2
	rel-5-1:11.11
	rel-5-0:11.9
	rel-5-0-beta:11.8
	rel-4-5:11.8
	ctj-4-5-post:11.7
	ctj-4-5-pre:11.7
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.24
date	2004.05.24.04.16.13;	author morrison;	state dead;
branches;
next	11.23;

11.23
date	2004.05.10.15.30.42;	author erikg;	state Exp;
branches;
next	11.22;

11.22
date	2004.04.05.07.49.36;	author morrison;	state Exp;
branches;
next	11.21;

11.21
date	2004.02.02.17.39.00;	author morrison;	state Exp;
branches;
next	11.20;

11.20
date	2003.11.06.19.41.04;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	2002.08.20.17.07.22;	author jra;	state Exp;
branches
	11.19.2.1
	11.19.4.1
	11.19.10.1;
next	11.18;

11.18
date	2002.08.15.20.54.35;	author hartley;	state Exp;
branches;
next	11.17;

11.17
date	2002.05.17.12.48.56;	author morrison;	state Exp;
branches;
next	11.16;

11.16
date	2001.08.10.21.22.53;	author butler;	state Exp;
branches;
next	11.15;

11.15
date	2001.05.17.20.03.14;	author morrison;	state Exp;
branches;
next	11.14;

11.14
date	2000.08.24.03.15.30;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	2000.07.12.21.59.35;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	2000.07.10.23.54.00;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	2000.03.29.18.15.17;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	99.12.30.18.28.47;	author jra;	state Exp;
branches;
next	11.9;

11.9
date	99.06.03.21.54.21;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	97.12.24.13.52.50;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	97.03.05.20.01.30;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	96.10.25.16.20.07;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	96.08.02.12.49.22;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	96.07.02.18.18.21;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.03.01.13.17.21;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.01.18.10.57.45;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.59.44;	author mike;	state Rel4_4;
branches;
next	1.11;

1.11
date	94.11.08.16.15.11;	author jra;	state Exp;
branches;
next	1.10;

1.10
date	94.11.01.04.08.39;	author butler;	state Exp;
branches;
next	1.9;

1.9
date	94.08.11.00.06.15;	author gdurf;	state Exp;
branches;
next	1.8;

1.8
date	94.07.13.12.06.16;	author jra;	state Exp;
branches;
next	1.7;

1.7
date	94.04.20.11.34.52;	author jra;	state Exp;
branches;
next	1.6;

1.6
date	94.03.18.12.47.30;	author jra;	state Exp;
branches;
next	1.5;

1.5
date	93.12.09.13.25.13;	author jra;	state Exp;
branches;
next	1.4;

1.4
date	93.12.07.15.40.23;	author jra;	state Exp;
branches;
next	1.3;

1.3
date	93.12.07.13.50.23;	author jra;	state Exp;
branches;
next	1.2;

1.2
date	93.12.01.15.26.45;	author jra;	state Exp;
branches;
next	1.1;

1.1
date	93.12.01.15.22.30;	author jra;	state Exp;
branches;
next	;

11.19.2.1
date	2002.09.19.18.00.37;	author morrison;	state Exp;
branches;
next	11.19.2.2;

11.19.2.2
date	2004.03.17.21.16.01;	author morrison;	state Exp;
branches;
next	;

11.19.4.1
date	2004.03.11.23.40.32;	author morrison;	state Exp;
branches;
next	;

11.19.10.1
date	2003.12.03.16.24.03;	author erikg;	state Exp;
branches;
next	11.19.10.2;

11.19.10.2
date	2004.02.12.19.24.24;	author erikg;	state Exp;
branches;
next	11.19.10.3;

11.19.10.3
date	2004.03.15.14.06.08;	author erikg;	state Exp;
branches;
next	;


desc
@UK TANKILL format to BRL-CAD converter
@


11.24
log
@moved to src/conv/
@
text
@/*
 *                      T A N K I L L - G
 *
 *  Program to convert the UK TANKILL format to BRL-CAD.
 *
 *  Author -
 *      John R. Anderson
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1993-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */

#ifndef lint
static const char RCSid[] = "$Header: /n/xoff/cvs/brlcad/conv/tankill-g.c,v 11.23 2004/05/10 15:30:42 erikg Exp $";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <errno.h>

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "wdb.h"
#include "../librt/debug.h"

static int keep_1001=0;		/* flag to indicate that components with id 1001 should not be ignored */
static int verbose=0;		/* verbosity flag */

#define START_ARRAY_SIZE	64
#define ARRAY_BLOCK_SIZE	64

#define	NAMESIZE	16	/* from db.h */

struct tankill_verts
{
	point_t coord;
	struct vertex *vp;
};

struct comp_idents		/* structure for linked list of components */
{
	int ident;
	int no_of_solids;
	struct comp_idents *next;
} *id_root;


/*	Adds another solid to the list of solids for each component code number.
 *	Returns the number of solids in this component (including the one just added)
 */
static int
Add_solid(int comp_code_num)
{
	struct comp_idents *ptr;

	/* if list is empty, start one */
	if( id_root == NULL )
	{
		id_root = (struct comp_idents *)bu_malloc( sizeof( struct comp_idents ) , "tankill-g: idents list" );
		id_root->next = (struct comp_idents *)NULL;
		id_root->ident = comp_code_num;
		id_root->no_of_solids = 1;
		return( 1 );
	}
	else
	{
		/* look for an entry for this component code number */
		ptr = id_root;
		while( ptr->next != (struct comp_idents *)NULL && ptr->ident != comp_code_num )
			ptr = ptr->next;

		/* if found one, just increment the number of solids */
		if( ptr->ident == comp_code_num )
		{
			ptr->no_of_solids++;
			return( ptr->no_of_solids );
		}
		else
		{
			/* make a new entry for this component */
			ptr->next = (struct comp_idents *)bu_malloc( sizeof( struct comp_idents ) , "tankill-g: idents list " );
			ptr = ptr->next;
			ptr->next = NULL;
			ptr->ident = comp_code_num;
			ptr->no_of_solids = 1;
			return( 1 );
		}
	}
}

/*	T A N K I L L - G
 *
 *	Converts "tankill" format geometry to BRLCAD model
 */

static char *usage="Usage: tankill-g [-v] [-p] [-k] [-t tolerance] [-x lvl] [-X lvl] [-i input_tankill_file] [-o output_brlcad_model]\n\
    where tolerance is the minimum distance (mm) between distinct vertices,\n\
    input_tankill_file is the file name for input TANKILL model\n\
    output_brlcad_model is the file name for output BRL-CAD model\n\
	-v -> verbose\n\
	-p -> write output as polysolids rather than NMG's\n\
	-k -> keep components with id = 1001 (normally skipped)\n\
	-x lvl -> sets the librt debug flag to lvl\n\
	-X lvl -> sets the NMG debug flag to lvl\n";

int
main(int argc, char **argv)
{
	register int c;
	int i;
	int vert1,vert2;
	int vert_no;
	int no_of_verts;
	int comp_code;
	int array_size=START_ARRAY_SIZE;		/* size of "tankill_verts" array */
	int surr_code;	/* not useful */
	float x,y,z;
	struct tankill_verts *verts;
	struct vertex **face_verts[3];
	struct model *m;
	struct nmgregion *r;
	struct shell *s;
	struct faceuse *fu;
	struct bu_ptbl faces;
	struct bn_tol tol;
	struct wmember reg_head;
	struct comp_idents *ptr;
	char name[NAMESIZE+1];
	char *input_file;				/* input file name */
	char *output_file = "tankill.g";
	FILE *in_fp;					/* input file pointer */
	struct rt_wdb *out_fp;				/* output file pointer */
	int polysolids;					/* flag indicating polysolid output */
	int group_len[100];
	int all_len=0;

	/* Set defaults */

        /* XXX These need to be improved */
        tol.magic = BN_TOL_MAGIC;
        tol.dist = 0.005;
        tol.dist_sq = tol.dist * tol.dist;
        tol.perp = 1e-6;
        tol.para = 1 - tol.perp;

	in_fp = stdin;
	polysolids = 1;
	input_file = (char *)NULL;
	id_root = (struct comp_idents *)NULL;
	bu_ptbl_init( &faces , 64, " &faces ");

	/* get command line arguments */
	while ((c = getopt(argc, argv, "vknt:i:o:x:X:")) != EOF)
	{
		switch( c )
		{
			case 'v':
				verbose = 1;
				break;
			case 'x':
				sscanf( optarg, "%x", (unsigned int *)&rt_g.debug );
				bu_printb( "librt RT_G_DEBUG", RT_G_DEBUG, DEBUG_FORMAT );
				bu_log("\n");
				break;
			case 'X':
				sscanf( optarg, "%x", (unsigned int *)&rt_g.NMG_debug );
				bu_printb( "librt rt_g.NMG_debug", rt_g.NMG_debug, NMG_DEBUG_FORMAT );
				bu_log("\n");
				break;
			case 'k': /* keep component codes of 1001 */
				keep_1001 = 1;
				break;
			case 'n': /* choose NMG output */
				polysolids = 0;
				break;
			case 't': /* tolerance */
				tol.dist = atof( optarg );
				tol.dist_sq = tol.dist * tol.dist;
				break;
			case 'i': /* input file name */
				if( (in_fp = fopen( optarg , "r" )) == NULL )
				{
					fprintf( stderr , "Cannot open %s\n" , optarg );
					perror( "tankill-g" );
					rt_bomb( "Cannot open input file" );
				}
				input_file = bu_malloc( sizeof( optarg ) +1 , "tankill-g: input file name" );
				strcpy( input_file , optarg );
				break;
			case 'o': /* output file name */
				output_file = optarg;
				break;
			default:
				rt_bomb( usage );
				break;
		}
	}

	if( (out_fp = wdb_fopen( output_file )) == NULL )
	{
		perror( output_file );
		fprintf( stderr , "tankill-g: Cannot open %s\n" , output_file );
		rt_bomb( "Cannot open output file\n" );
	}

	/* use the input file name as the title (if available) */
	if( input_file == (char *)NULL )
		mk_id( out_fp , "Conversion from TANKILL" );
	else
		mk_id( out_fp , input_file );

	/* make some space to store the vertices */
	verts = (struct tankill_verts *)bu_malloc( array_size*sizeof( struct tankill_verts ) , "tankill-g: verts array " );

	/* read the number of vertices to expect */
	while( fscanf( in_fp , "%d" , &no_of_verts ) != EOF )
	{
		/* make a new shell */
		m = nmg_mm();
		r = nmg_mrsv( m );
		s = BU_LIST_FIRST( shell , &r->s_hd );

		/* make sure there is enough room */
		if( no_of_verts > array_size )
		{
			while( array_size < no_of_verts )
				array_size += ARRAY_BLOCK_SIZE;
		        verts = (struct tankill_verts *)rt_realloc( (char *)verts , array_size*sizeof( struct tankill_verts ) , "tankill-g: vertex array" );
		}

		/* read the component code number */
		if( fscanf( in_fp , "%d" , &comp_code ) == EOF )
		{
			fprintf( stderr , "Unexpected EOF\n" );
			break;
		}

		if( verbose )
			bu_log( "Component code %d (%d vertices)\n", comp_code, no_of_verts );

		/* read the surroundings code (I think this is like the space code in GIFT/FASTGEN) */
		if( fscanf( in_fp , "%d " , &surr_code ) == EOF )
		{
			fprintf( stderr , "Unexpected EOF\n" );
			break;
		}

		/* read the vertices into our structure and set the nmg vertex pointer to NULL */
		for( vert_no=0 ; vert_no < no_of_verts ; vert_no++ )
		{
			if( fscanf( in_fp , "%f %f %f" , &x , &y , &z ) == EOF )
			{
				fprintf( stderr , "Unexpected EOF\n" );
				break;
			}
			VSET( verts[vert_no].coord , x , y , z );
			verts[vert_no].vp = (struct vertex *)NULL;
		}

		/* skip component codes of 1001 (these are not real components) */
		if( comp_code == 1001 && !keep_1001 )
		{
			if( verbose )
				bu_log( "Skipping component code %d (%d vertices)\n", comp_code, no_of_verts );
			continue;
		}

		/* now start making faces, patch-style */
		vert_no = 0;
		vert1 = 0;
		while( vert_no < no_of_verts - 2 )
		{
			/* skip combinations that won't make a face */
			if( bn_3pts_collinear( verts[vert_no].coord , verts[vert_no+1].coord , verts[vert_no+2].coord , &tol ) )
				vert_no++;
			else if( !bn_3pts_distinct( verts[vert_no].coord , verts[vert_no+1].coord , verts[vert_no+2].coord , &tol ) )
				vert_no++;
			else
			{
				/* put next three vertices in an array for nmg_cface */
				for( i=0 ; i<3 ; i++ )
					face_verts[i] = &verts[i+vert_no].vp;

				/* make a face */
				fu = nmg_cmface( s , face_verts , 3 );

				/* make sure any duplicate vertices get the same vertex pointer */
				for( ; vert1 < vert_no+3 ; vert1++ )
				{
					for( vert2=vert1+1 ; vert2 < no_of_verts ; vert2++ )
					{
						if( verts[vert2].vp )
							continue;
						if( VEQUAL( verts[vert1].coord , verts[vert2].coord ) )
							verts[vert2].vp = verts[vert1].vp;
					}
				}
				vert_no++;
			}
		}

		/* assign geometry */
		for( i=0 ; i<no_of_verts ; i++ )
		{
			if( (verts[i].vp != (struct vertex *)NULL) &&
				(verts[i].vp->vg_p == (struct vertex_g *)NULL) )
					nmg_vertex_gv( verts[i].vp , verts[i].coord );
		}

		/* calculate plane equations for faces */
		for (BU_LIST_FOR(s, shell, &r->s_hd))
		{
		    NMG_CK_SHELL( s );
		    for (BU_LIST_FOR(fu, faceuse, &s->fu_hd))
		    {
		        NMG_CK_FACEUSE( fu );
		        if( fu->orientation == OT_SAME )
		        {
		                if( nmg_calc_face_g( fu ) )
		                        bu_log( "Failed to calculate plane eqn\n" );

				/* save the face in a table */
				bu_ptbl_ins( &faces , (long *)fu );
		        }
		    }
		}

		/* look for edges that need to be broken apart for sharing
		 *
		 * Like so:
		 *    *------->*-------->*--------->*
		 *    *<----------------------------*
		 *
		 * bottom edge needs to be broken into three to share with
		 * upper edge
		 */

		s = BU_LIST_FIRST( shell , &r->s_hd );
		nmg_break_long_edges( s , &tol );

		/* glue all the faces together */
		nmg_gluefaces( (struct faceuse **)BU_PTBL_BASEADDR( &faces) , BU_PTBL_END( &faces ), &tol );

		/* re-initialize the face list */
		bu_ptbl_reset( &faces );

		/* Calculate bounding boxes */
		nmg_region_a( r , &tol );

		/* fix the normals */
		s = BU_LIST_FIRST( shell , &r->s_hd );

		nmg_fix_normals( s, &tol );

		/* make a name for this solid */
		sprintf( name , "s.%d.%d" , comp_code , Add_solid( comp_code ) );

		/* write the solid to the brlcad database */
		s = BU_LIST_FIRST( shell, &r->s_hd );
		if( polysolids )
		{
			if( verbose )
				bu_log( "\twriting polysolid %s\n", name );
			write_shell_as_polysolid( out_fp , name , s );
		}
		else
		{
			/* simplify the structure as much as possible before writing */
/*			nmg_shell_coplanar_face_merge( s , &tol , 1 );
			if( nmg_simplify_shell( s ) )
			{
				bu_log( "tankill-g: nmg_simplify_shell emptied %s\n" , name );
				nmg_km( m );
				continue;
			}
			else */
			{
				/* write it out */
				if( verbose )
					bu_log( "\twriting polysolid %s\n", name );
				mk_nmg( out_fp , name , m );
			}
		}

		/* kill the nmg model */
		nmg_km( m );

	}

	/* free the memory for the face list */
	bu_ptbl_free( &faces );

	/* Make regions */
	ptr = id_root;
	while( ptr != NULL )
	{
		BU_LIST_INIT( &reg_head.l );

		/* make linked list of members */
		for( i=0 ; i<ptr->no_of_solids ; i++ )
		{
			/* recreate the name of each solid */
			sprintf( name , "s.%d.%d" , ptr->ident , i+1 );
			(void)mk_addmember( name , &reg_head.l , NULL, WMOP_UNION );
		}

		/* make the region name */
		sprintf( name , "r.%d" , ptr->ident );

		/* make the region */
		if( verbose )
		{
			if( ptr->ident == 1000 )
				bu_log( "Creating air region %s\n", name );
			else
				bu_log( "Creating region %s\n", name );
		}
		if( ptr->ident == 1000 )
		{
			if (mk_lrcomb( out_fp , name , &reg_head , 1 , (char *)NULL ,
				(char *)NULL , (unsigned char *)NULL , 0 , 1 ,
				0 , 0 , 0 ) )
			{
				rt_bomb( "tankill: Error in freeing region memory" );
			}
		}
		else
		{
			if (mk_lrcomb( out_fp , name , &reg_head , 1 , (char *)NULL ,
				(char *)NULL , (unsigned char *)NULL , ptr->ident , 0 ,
				1 , 100 , 0 ) )
			{
				rt_bomb( "tankill: Error in freeing region memory" );
			}
		}
		ptr = ptr->next;
	}

	/* Make groups based on ident numbers */
	for( i=0 ; i<100 ; i++ )
	{
		BU_LIST_INIT( &reg_head.l );

		group_len[i] = 0;
		ptr = id_root;
		while( ptr != NULL )
		{
			if( ptr->ident/100 == i )
			{
				/* make the region name */
				sprintf( name , "r.%d" , ptr->ident );

				(void)mk_addmember( name , &reg_head.l , NULL, WMOP_UNION );
				group_len[i]++;
			}
			ptr = ptr->next;
		}

		if( group_len[i] )
		{
			/* make a group name */
			sprintf( name , "%02dXX_codes" , i );

			/* make the group */
			if( verbose )
				bu_log( "Creating group %s\n", name );
			if( mk_lcomb( out_fp , name , &reg_head , 0,
				(char *)NULL, (char *)NULL,
				(unsigned char *)NULL, 0 ) )
			{
				rt_bomb( "tankill: Error in freeing region memory" );
			}
		}
	}

	/* Make next higher level groups */
	for( i=0 ; i<10 ; i++ )
	{
		int do_group;
		int k;

		BU_LIST_INIT( &reg_head.l );

		do_group = 0;
		for( k=i*10 ; k<(i+1)*10 ; k++ )
		{
			if( group_len[k] )
			{
				do_group = 1;

				/* make group name */
				sprintf( name , "%02dXX_codes" , k );
				(void)mk_addmember( name , &reg_head.l , NULL, WMOP_UNION );
			}
		}
		if( do_group )
		{
			/* make the group */
			sprintf( name , "%dXXX_codes" , i );
			if( verbose )
				bu_log( "Creating group %s\n", name );
			if( mk_lcomb( out_fp , name , &reg_head , 0,
			(char *)NULL, (char *)NULL, (unsigned char *)0, 0 ) )
			{
				rt_bomb( "tankill: Error in freeing region memory" );
			}
		}
	}

	/* Make top level group "all" */

	BU_LIST_INIT( &reg_head.l );

	for( i=0 ; i<10 ; i++ )
	{
		int do_group;
		int k;

		do_group = 0;
		for( k=i*10 ; k<(i+1)*10 ; k++ )
		{
			if( group_len[k] )
			{
				do_group = 1;
				break;
			}
		}
		if( do_group )
		{
			/* make the group */
			sprintf( name , "%dXXX_codes" , i );

			if( mk_addmember( name , &reg_head.l , NULL, WMOP_UNION ) == WMEMBER_NULL )
				bu_log( "mk_admember failed for %s\n" , name );
			all_len++;
		}
	}
	if( all_len )
	{
		if( verbose )
			bu_log( "Creating top level group 'all'\n" );
		if( mk_lcomb( out_fp , "all" , &reg_head , 0,
		    (char *)NULL, (char *)NULL, (unsigned char *)NULL, 0 ) )
			rt_bomb( "tankill: Error in freeing region memory" );
	}
	wdb_close( out_fp );
	return 0;
}
@


11.23
log
@change conf.h to a wrapped config.h
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /cvs/brlcad/conv/tankill-g.c,v 11.22 2004/04/05 07:49:36 morrison Exp $";
@


11.22
log
@merge of ansi-6-0-branch into HEAD
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header$";
d27 5
a31 1
#include "conf.h"
@


11.21
log
@update copyright to include span through 2003
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/tankill-g.c,v 11.20 2003/11/06 19:41:04 jra Exp $";
d73 1
a73 2
Add_solid( comp_code_num )
int comp_code_num;
d128 1
a128 3
main( argc , argv )
int argc;
char *argv[];
@


11.20
log
@Default is now BOT primitives
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1993 by the United States Army
d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/tankill-g.c,v 11.19 2002/08/20 17:07:22 jra Exp $";
@


11.19
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/tankill-g.c,v 11.17 2002/05/17 12:48:56 morrison Exp $";
d171 1
a171 1
	polysolids = 0;
d177 1
a177 1
	while ((c = getopt(argc, argv, "vkpt:i:o:x:X:")) != EOF)
d197 2
a198 2
			case 'p': /* choose polysolid output */
				polysolids = 1;
@


11.19.4.1
log
@sync to HEAD...
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "$Header: /n/cad/c/CVS/brlcad/conv/tankill-g.c,v 11.21 2004/02/02 17:39:00 morrison Exp $";
d171 1
a171 1
	polysolids = 1;
d177 1
a177 1
	while ((c = getopt(argc, argv, "vknt:i:o:x:X:")) != EOF)
d197 2
a198 2
			case 'n': /* choose NMG output */
				polysolids = 0;
@


11.19.10.1
log
@updates from HEAD, part 1
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/tankill-g.c,v 11.20 2003/11/06 19:41:04 jra Exp $";
d171 1
a171 1
	polysolids = 1;
d177 1
a177 1
	while ((c = getopt(argc, argv, "vknt:i:o:x:X:")) != EOF)
d197 2
a198 2
			case 'n': /* choose NMG output */
				polysolids = 0;
@


11.19.10.2
log
@merge from HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/tankill-g.c,v 11.21 2004/02/02 17:39:00 morrison Exp $";
@


11.19.10.3
log
@merge from head
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/tankill-g.c,v 11.19.10.2 2004/02/12 19:24:24 erikg Exp $";
@


11.19.2.1
log
@Initial ANSIfication
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/tankill-g.c,v 11.19 2002/08/20 17:07:22 jra Exp $";
d73 2
a74 1
Add_solid(int comp_code_num)
d129 3
a131 1
main(int argc, char **argv)
@


11.19.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "$Header$";
d168 1
a168 1
	polysolids = 1;
d174 1
a174 1
	while ((c = getopt(argc, argv, "vknt:i:o:x:X:")) != EOF)
d194 2
a195 2
			case 'n': /* choose NMG output */
				polysolids = 0;
@


11.18
log
@Converted from K&R to ANSI C - RFH
@
text
@d73 2
a74 1
Add_solid(int comp_code_num)
d129 3
a131 1
main(int argc, char **argv)
@


11.17
log
@added matrix parameter to mk_addmember()
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/tankill-g.c,v 11.16 2001/08/10 21:22:53 butler Exp $";
d73 1
a73 2
Add_solid( comp_code_num )
int comp_code_num;
d128 1
a128 3
main( argc , argv )
int argc;
char *argv[];
@


11.16
log
@Compiler warning patches
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/tankill-g.c,v 11.15 2001/05/17 20:03:14 morrison Exp $";
d428 1
a428 1
			(void)mk_addmember( name , &reg_head.l , WMOP_UNION );
d477 1
a477 1
				(void)mk_addmember( name , &reg_head.l , WMOP_UNION );
d517 1
a517 1
				(void)mk_addmember( name , &reg_head.l , WMOP_UNION );
d557 1
a557 1
			if( mk_addmember( name , &reg_head.l , WMOP_UNION ) == WMEMBER_NULL )
@


11.15
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/tankill-g.c,v 11.14 2000/08/24 03:15:30 mike Exp $";
d185 1
a185 1
				sscanf( optarg, "%x", &rt_g.debug );
d190 1
a190 1
				sscanf( optarg, "%x", &rt_g.NMG_debug );
@


11.14
log
@
mk_addmember()
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/tankill-g.c,v 11.13 2000/07/12 21:59:35 mike Exp $";
d186 1
a186 1
				bu_printb( "librt rt_g.debug", rt_g.debug, DEBUG_FORMAT );
@


11.13
log
@
Converted to use new version of LIBWDB
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/tankill-g.c,v 11.12 2000/07/10 23:54:00 mike Exp $";
d428 1
a428 1
			(void)mk_addmember( name , &reg_head , WMOP_UNION );
d477 1
a477 1
				(void)mk_addmember( name , &reg_head , WMOP_UNION );
d517 1
a517 1
				(void)mk_addmember( name , &reg_head , WMOP_UNION );
d557 1
a557 1
			if( mk_addmember( name , &reg_head , WMOP_UNION ) == WMEMBER_NULL )
@


11.12
log
@
lint
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/tankill-g.c,v 11.11 2000/03/29 18:15:17 mike Exp $";
d128 1
d154 1
d156 1
a156 1
	FILE *out_fp;					/* output file pointer */
a170 1
	out_fp = stdout;
d215 1
a215 6
				if( (out_fp = fopen( optarg , "w" )) == NULL )
				{
					fprintf( stderr , "Cannot open %s\n" , optarg );
					perror( "tankill-g" );
					rt_bomb( "Cannot open output file\n" );
				}
d223 6
d570 1
@


11.11
log
@
Eliminated macro which also appears in vmath.h now
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/tankill-g.c,v 11.10 1999/12/30 18:28:47 jra Exp $";
@


11.10
log
@Eliminated some unused variables
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/tankill-g.c,v 11.9 1999/06/03 21:54:21 mike Exp $";
a66 8

/* macro to determine if one bounding box in entirely within another
 * also returns true if the boxes are the same
 */
#define V3RPP1_IN_RPP2( _lo1 , _hi1 , _lo2 , _hi2 )	( \
	(_lo1)[X] >= (_lo2)[X] && (_hi1)[X] <= (_hi2)[X] && \
	(_lo1)[Y] >= (_lo2)[Y] && (_hi1)[Y] <= (_hi2)[Y] && \
	(_lo1)[Z] >= (_lo2)[Z] && (_hi1)[Z] <= (_hi2)[Z] )
@


11.9
log
@
sed4
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/tankill-g.c,v 11.8 1997/12/24 13:52:50 jra Exp $";
a145 1
	int shell_count;
a153 1
	struct shell *s2;
@


11.8
log
@Mod to handle air regions.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/tankill-g.c,v 11.7 1997/03/05 20:01:30 jra Exp $";
d89 1
a89 1
		id_root = (struct comp_idents *)rt_malloc( sizeof( struct comp_idents ) , "tankill-g: idents list" );
d111 1
a111 1
			ptr->next = (struct comp_idents *)rt_malloc( sizeof( struct comp_idents ) , "tankill-g: idents list " );
d157 2
a158 2
	struct nmg_ptbl faces;
	struct rt_tol tol;
d172 1
a172 1
        tol.magic = RT_TOL_MAGIC;
d183 1
a183 1
	nmg_tbl( &faces , TBL_INIT , NULL );
d195 2
a196 2
				rt_printb( "librt rt_g.debug", rt_g.debug, DEBUG_FORMAT );
				rt_log("\n");
d200 2
a201 2
				rt_printb( "librt rt_g.NMG_debug", rt_g.NMG_debug, NMG_DEBUG_FORMAT );
				rt_log("\n");
d220 1
a220 1
				input_file = rt_malloc( sizeof( optarg ) +1 , "tankill-g: input file name" );
d245 1
a245 1
	verts = (struct tankill_verts *)rt_malloc( array_size*sizeof( struct tankill_verts ) , "tankill-g: verts array " );
d253 1
a253 1
		s = RT_LIST_FIRST( shell , &r->s_hd );
d271 1
a271 1
			rt_log( "Component code %d (%d vertices)\n", comp_code, no_of_verts );
d296 1
a296 1
				rt_log( "Skipping component code %d (%d vertices)\n", comp_code, no_of_verts );
d306 1
a306 1
			if( rt_3pts_collinear( verts[vert_no].coord , verts[vert_no+1].coord , verts[vert_no+2].coord , &tol ) )
d308 1
a308 1
			else if( !rt_3pts_distinct( verts[vert_no].coord , verts[vert_no+1].coord , verts[vert_no+2].coord , &tol ) )
d343 1
a343 1
		for (RT_LIST_FOR(s, shell, &r->s_hd))
d346 1
a346 1
		    for (RT_LIST_FOR(fu, faceuse, &s->fu_hd))
d352 1
a352 1
		                        rt_log( "Failed to calculate plane eqn\n" );
d355 1
a355 1
				nmg_tbl( &faces , TBL_INS , (long *)fu );
d370 1
a370 1
		s = RT_LIST_FIRST( shell , &r->s_hd );
d374 1
a374 1
		nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ), &tol );
d377 1
a377 1
		nmg_tbl( &faces , TBL_RST , NULL );
d383 1
a383 1
		s = RT_LIST_FIRST( shell , &r->s_hd );
d391 1
a391 1
		s = RT_LIST_FIRST( shell, &r->s_hd );
d395 1
a395 1
				rt_log( "\twriting polysolid %s\n", name );
d404 1
a404 1
				rt_log( "tankill-g: nmg_simplify_shell emptied %s\n" , name );
d412 1
a412 1
					rt_log( "\twriting polysolid %s\n", name );
d423 1
a423 1
	nmg_tbl( &faces , TBL_FREE , NULL );
d429 1
a429 1
		RT_LIST_INIT( &reg_head.l );
d446 1
a446 1
				rt_log( "Creating air region %s\n", name );
d448 1
a448 1
				rt_log( "Creating region %s\n", name );
d474 1
a474 1
		RT_LIST_INIT( &reg_head.l );
d498 1
a498 1
				rt_log( "Creating group %s\n", name );
d514 1
a514 1
		RT_LIST_INIT( &reg_head.l );
d533 1
a533 1
				rt_log( "Creating group %s\n", name );
d544 1
a544 1
	RT_LIST_INIT( &reg_head.l );
d566 1
a566 1
				rt_log( "mk_admember failed for %s\n" , name );
d573 1
a573 1
			rt_log( "Creating top level group 'all'\n" );
@


11.7
log
@removed include of db.h
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/tankill-g.c,v 11.6 1996/10/25 16:20:07 jra Exp jra $";
a443 4
			rt_log( "Creating region %s\n", name );
		if (mk_lrcomb( out_fp , name , &reg_head , 1 , (char *)NULL ,
			(char *)NULL , (unsigned char *)NULL , ptr->ident , 0 ,
			1 , 100 , 0 ) )
d445 22
a466 1
			rt_bomb( "tankill: Error in freeing region memory" );
@


11.6
log
@Removed section handling void shells (now done in nmg_fix_normals).
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/tankill-g.c,v 11.5 1996/08/02 12:49:22 jra Exp $";
a38 1
#include "db.h"
d52 2
@


11.5
log
@Minor mod to allow free format input.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/tankill-g.c,v 11.4 1996/07/02 18:18:21 jra Exp jra $";
d49 1
d125 5
a129 2
static char *usage="Usage: tankill-g [-p] [-k] [-t tolerance] [-i input_tankill_file] [-o output_brlcad_model]\n\
	where tolerance is the minimum distance (mm) between distinct vertices\n\
d131 3
a133 1
	-k -> keep components with id = 1001 (normally skipped)\n";
d145 1
d154 1
d185 1
a185 1
	while ((c = getopt(argc, argv, "kpt:i:o:")) != EOF)
d189 13
d269 3
d293 3
d297 1
a317 3
				/* save the face in a table */
				nmg_tbl( &faces , TBL_INS , (long *)fu );

d352 3
d373 1
a373 1
		nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ) );
d383 1
a385 77
		/* if the shell we just built has a void shell inside, nmg_fix_normals will
		 * point the normals of the void shell in the wrong direction. This section
		 * of code looks for such a situation and reverses the normals of the void shell
		 *
		 * first decompose the shell into maximally connected shells
		 */
		if( nmg_decompose_shell( s , &tol ) > 1 )
		{
			/* This shell has more than one part */
			struct shell *outer_shell=NULL;
			long *flags;

			flags = (long *)rt_calloc( m->maxindex , sizeof( long ) , "tankill-g: flags" );

			for( RT_LIST_FOR( s , shell , &r->s_hd ) )
			{
				struct shell *s2;

				int is_outer=1;

				/* insure that bounding boxes are available */
				if( !s->sa_p )
					nmg_shell_a( s , &tol );

				/* Check if this shells contains all the others
				 * In TANKILL, there should only be one outer shell
				 */
				for( RT_LIST_FOR( s2 , shell , &r->s_hd ) )
				{
					if( !s2->sa_p )

						nmg_shell_a( s2 , &tol );

					if( !V3RPP1_IN_RPP2( s2->sa_p->min_pt , s2->sa_p->max_pt ,
							    s->sa_p->min_pt , s->sa_p->max_pt ) )
					{
						/* doesn't contain shell s2, so it's not an outer shell */
						is_outer = 0;
						break;
					}
				}
				if( is_outer )
				{
					outer_shell = s;
					break;
				}
			}
			if( !outer_shell )
			{
				rt_log( "tankill-g: Could not find outer shell for component code %d\n" , comp_code );
				outer_shell = RT_LIST_FIRST( shell , &r->s_hd );
			}

			/* reverse the normals for each void shell
			 * and merge back into one shell */
			s = RT_LIST_FIRST( shell , &r->s_hd );
			while( RT_LIST_NOT_HEAD( s , &r->s_hd ) )
			{
				struct faceuse *fu;
				struct shell *next_s;

				if( s == outer_shell )
				{
					s = RT_LIST_PNEXT( shell , s );
					continue;
				}

				next_s = RT_LIST_PNEXT( shell , s );
				fu = RT_LIST_FIRST( faceuse , &s->fu_hd );
				nmg_reverse_face( fu );
				nmg_propagate_normals( fu , flags, &tol );
				nmg_js( outer_shell , s , &tol );
				s = next_s;
			}
		}
		s = RT_LIST_FIRST( shell , &r->s_hd );

d390 1
d392 3
d396 1
d400 1
a400 1
			nmg_shell_coplanar_face_merge( s , &tol , 1 );
d407 1
a407 1
			else
d410 2
d442 2
d479 2
d514 2
d554 2
@


11.4
log
@Added tol arg to call of nmg_propagate_normals() and added missing 'k' to getopt() call.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/tankill-g.c,v 11.3 1995/03/01 13:17:21 jra Exp jra $";
d258 1
a258 1
			if( fscanf( in_fp , "%6f %6f %6f" , &x , &y , &z ) == EOF )
@


11.3
log
@Replaced call to nmg_fu_planeeqn() with call to nmg_calc_face_g().
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/tankill-g.c,v 11.2 95/01/18 10:57:45 jra Exp Locker: jra $";
d177 1
a177 1
	while ((c = getopt(argc, argv, "pt:i:o:")) != EOF)
d427 1
a427 1
				nmg_propagate_normals( fu , flags );
@


11.2
log
@nmg_fix_normals needed a tol arg.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/tankill-g.c,v 11.1 95/01/04 09:59:44 mike Rel4_4 Locker: jra $";
d325 1
a325 1
		                if( nmg_fu_planeeqn( fu , &tol ) )
@


11.1
log
@Release_4.4
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/tankill-g.c,v 1.11 94/11/08 16:15:11 jra Exp $";
d355 1
a355 1
		nmg_fix_normals( s );
@


1.11
log
@Mods for Irix 6.0
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /n/wolf/m/cad/conv/RCS/tankill-g.c,v 1.10 1994/11/01 04:08:39 butler Exp jra $";
@


1.10
log
@fixed casts to match function prototypes
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/tankill-g.c,v 1.9 1994/08/11 00:06:15 gdurf Exp butler $";
a147 2
	struct loopuse *lu;
	struct edgeuse *eu;
a468 2
		struct wmember *wmem;

d476 1
a476 1
			wmem = mk_addmember( name , &reg_head , WMOP_UNION );
a494 2
		struct wmember *wmem;

d506 1
a506 1
				wmem = mk_addmember( name , &reg_head , WMOP_UNION );
a529 1
		struct wmember *wmem;
d544 1
a544 1
				wmem = mk_addmember( name , &reg_head , WMOP_UNION );
a564 1
		struct wmember *wmem;
d582 1
a582 1
			if( (wmem = mk_addmember( name , &reg_head , WMOP_UNION ) ) == WMEMBER_NULL )
@


1.9
log
@Factored ifdefs
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/tankill-g.c,v 1.8 1994/07/13 12:06:16 jra Exp gdurf $";
d488 1
a488 1
			(char *)NULL , (char *)NULL , ptr->ident , 0 ,
d524 3
a526 1
			if( mk_lcomb( out_fp , name , &reg_head , 0, (char *)0, (char *)0, (char *)0, 0 ) )
d558 2
a559 1
			if( mk_lcomb( out_fp , name , &reg_head , 0, (char *)0, (char *)0, (char *)0, 0 ) )
d597 2
a598 1
		if( mk_lcomb( out_fp , "all" , &reg_head , 0, (char *)0, (char *)0, (char *)0, 0 ) )
@


1.8
log
@Removed arg declarations from routine definitions.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /n/wolf/m/cad/conv/RCS/tankill-g.c,v 1.7 94/04/20 11:34:52 jra Exp Locker: jra $";
d27 2
d31 1
d33 5
a47 1
extern int errno;
d597 1
@


1.7
log
@Added tol argument to nmg-decompose_shell call
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/tankill-g.c,v 1.6 94/03/18 12:47:30 jra Exp Locker: jra $";
d72 2
a73 1
Add_solid( int comp_code_num )
d122 3
a124 1
main( int argc , char *argv[] )
@


1.6
log
@Replace nmg_merge_shells with nmg_js
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/tankill-g.c,v 1.5 93/12/09 13:25:13 jra Exp $";
d355 1
a355 1
		if( nmg_decompose_shell( s ) > 1 )
@


1.5
log
@housekeeping
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/tankill-g.c,v 1.4 93/12/07 15:40:23 jra Exp $";
d420 1
a420 1
				nmg_merge_shells( outer_shell , s );
@


1.4
log
@Added option to keep 1001 component ids
@
text
@d10 2
a11 2
 *      The US Army Research Laboratory
 *      Aberdeen Proving Ground, Maryland  21005-5066
d13 8
a20 2
 *  Distribution Status -
 *      Public Domain, Distribution Unlimitied.
d22 1
d24 1
a24 1
static char RCSid[] = "$Header: /vld/jra/SOURCE/cad/TANKILL/RCS/tankill-g.c,v 1.3 93/12/07 13:50:23 jra Exp $";
d41 1
a41 1
static int keep_1001=0;
d52 1
a52 1
struct comp_idents
d59 3
d129 1
a129 1
	int array_size=START_ARRAY_SIZE;
d145 4
a148 3
	char *input_file;
	FILE *in_fp,*out_fp;
	int polysolids;
d165 2
d208 1
a208 4
	id_root = (struct comp_idents *)NULL;

	nmg_tbl( &faces , TBL_INIT , NULL );

d263 1
a263 1
		/* now start making faces */
d349 6
d357 1
d366 1
d369 1
d373 3
a375 1
				/* Check if this shells contains all the others */
d379 1
d385 1
d402 2
a433 2
			int loop_count;

d436 11
a446 4
			nmg_simplify_shell( s );

			/* write it out */
			mk_nmg( out_fp , name , m );
@


1.3
log
@Modified to detect external/void shells
@
text
@d17 1
a17 1
static char RCSid[] = "$Header: /vld/jra/SOURCE/cad/TANKILL/RCS/tankill-g.c,v 1.2 93/12/01 15:26:45 jra Exp Locker: jra $";
d34 1
d106 4
a109 2
static char *usage="Usage: tankill-g [-p] [-t tolerance] [-i input_tankill_file] [-o output_brlcad_model]\n\
	where tolerance is the minimum distance (mm) between distinct vertices\n";
d160 3
d250 1
a250 1
		if( comp_code == 1001 )
@


1.2
log
@Removed private copy of write_shell_as_polysolid
@
text
@d17 1
a17 1
static char RCSid[] = "$Header: /vld/jra/SOURCE/cad/TANKILL/RCS/tankill-g.c,v 1.1 93/12/01 15:22:30 jra Exp Locker: jra $";
d51 4
d56 1
d332 62
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 *			T A N K I L L - G
d7 1
a7 1
 *	John R. Anderson
d10 2
a11 2
 *	The US Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
d14 1
a14 1
 *	Public Domain, Distribution Unlimitied.
d17 1
a17 1
static char RCSid[] = "$Header$";
a50 19
/*	W R I T E _ S H E L L _ A S _ P O L Y S O L I D
 *
 *	This routine take an NMG shell and writes it out to the file
 *	out_fp as a polysolid with the indicated name.  Obviously,
 *	the shell should be a 3-manifold (winged edge).
 *	since polysolids may only have up to 5 vertices per face,
 *	any face with a loop of more than 5 vertices is triangulated
 *	using "nmg_triangulate_face" prior to output.
 */
void
write_shell_as_polysolid( FILE *out_fp , char *name , struct shell *s )
{
	struct faceuse *fu;
	struct loopuse *lu;
	struct edgeuse *eu;
	point_t verts[5];
	int count_npts;
	int max_count;
	int i;
a51 52
	NMG_CK_SHELL( s );

	mk_polysolid( out_fp , name );

	for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
	{
		NMG_CK_FACEUSE( fu );

		/* only do OT_SAME faces */
		if( fu->orientation != OT_SAME )
			continue;

		/* count vertices in loops */
		max_count = 0;
		for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
		{
			NMG_CK_LOOPUSE( lu );
			if( RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
				continue;

			count_npts = 0;
			for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
				count_npts++;

			if( count_npts > max_count )
				max_count = count_npts;
		}

		/* if any loop has more than 5 vertices, triangulate the face */
		if( max_count > 5 )
			nmg_triangulate_face( fu );

		for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
		{
			NMG_CK_LOOPUSE( lu );
			if( RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
				continue;

			count_npts = 0;
			for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
			{
				for( i=0 ; i<3 ; i++ )
					verts[count_npts][i] = eu->vu_p->v_p->vg_p->coord[i];
				count_npts++;
			}

			if( mk_fpoly( out_fp , count_npts , verts ) )
				rt_log( "write_shell_as_polysolid: mk_fpoly failed for object %s\n" , name );
		}
	}
}

a185 1
	/* make a table for the outward pointing faceuses (for nmg_gluefaces) */
d313 1
a313 1
		(void)nmg_break_long_edges( s , &tol );
d322 1
a322 1
		nmg_region_a( r );
@
