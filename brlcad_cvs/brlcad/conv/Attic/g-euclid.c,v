head	11.29;
access;
symbols
	ansi-20040405-merged:11.25.2.2
	postmerge-20040405-ansi:11.27
	premerge-20040404-ansi:11.26
	postmerge-autoconf:11.26
	autoconf-freeze:11.26
	premerge-autoconf:11.26
	ansi-20040316-freeze:11.25.2.1
	postmerge-20040315-windows:11.26
	premerge-20040315-windows:11.26
	windows-20040315-freeze:11.25.4.1
	autoconf-20031203:11.26
	autoconf-20031202:11.26
	autoconf-branch:11.26.0.6
	phong-branch:11.26.0.4
	photonmap-branch:11.26.0.2
	rel-6-1-DP:11.26
	windows-branch:11.25.0.4
	rel-6-0-2:11.23
	ansi-branch:11.25.0.2
	rel-6-0-1-branch:11.23.0.2
	hartley-6-0-post:11.24
	hartley-6-0-pre:11.23
	rel-6-0-1:11.23
	rel-6-0:11.23
	rel-5-4:11.13
	offsite-5-3-pre:11.20
	rel-5-3:11.13
	rel-5-2:11.13
	rel-5-1-branch:11.13.0.2
	rel-5-1:11.13
	rel-5-0:11.7
	rel-5-0-beta:11.6
	rel-4-5:11.6
	ctj-4-5-post:11.6
	ctj-4-5-pre:11.6
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.29
date	2004.05.24.04.16.12;	author morrison;	state dead;
branches;
next	11.28;

11.28
date	2004.05.10.15.30.41;	author erikg;	state Exp;
branches;
next	11.27;

11.27
date	2004.04.05.07.49.36;	author morrison;	state Exp;
branches;
next	11.26;

11.26
date	2002.10.15.17.36.22;	author jra;	state Exp;
branches;
next	11.25;

11.25
date	2002.08.20.17.07.21;	author jra;	state Exp;
branches
	11.25.2.1
	11.25.4.1;
next	11.24;

11.24
date	2002.08.15.20.54.34;	author hartley;	state Exp;
branches;
next	11.23;

11.23
date	2001.08.10.21.22.53;	author butler;	state Exp;
branches;
next	11.22;

11.22
date	2001.05.17.20.03.14;	author morrison;	state Exp;
branches;
next	11.21;

11.21
date	2001.04.05.19.34.59;	author morrison;	state Exp;
branches;
next	11.20;

11.20
date	2000.09.13.12.53.23;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	2000.09.08.05.55.42;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	2000.08.24.03.14.24;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	2000.07.21.12.44.34;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	2000.07.12.21.59.34;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	2000.07.10.23.53.57;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	2000.06.29.20.51.37;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	2000.03.29.18.15.12;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	2000.03.29.18.07.44;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	2000.03.03.03.34.34;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	2000.01.04.17.58.19;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	99.12.30.18.25.08;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	99.12.29.23.23.00;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	99.06.03.21.54.20;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	96.08.02.12.46.58;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	95.04.03.19.48.38;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	95.03.29.13.25.22;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.02.22.05.40.55;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.01.24.10.10.01;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.59.32;	author mike;	state Rel4_4;
branches;
next	1.10;

1.10
date	94.12.16.16.32.34;	author jra;	state Exp;
branches;
next	1.9;

1.9
date	94.12.08.17.56.15;	author jra;	state Exp;
branches;
next	1.8;

1.8
date	94.11.08.16.15.03;	author jra;	state Exp;
branches;
next	1.7;

1.7
date	94.08.23.14.29.45;	author jra;	state Exp;
branches;
next	1.6;

1.6
date	94.08.11.00.05.51;	author gdurf;	state Exp;
branches;
next	1.5;

1.5
date	94.04.20.15.59.05;	author jra;	state Exp;
branches;
next	1.4;

1.4
date	94.03.18.10.32.23;	author jra;	state Exp;
branches;
next	1.3;

1.3
date	94.03.17.16.46.28;	author jra;	state Exp;
branches;
next	1.2;

1.2
date	94.01.07.12.59.58;	author jra;	state Exp;
branches;
next	1.1;

1.1
date	93.12.09.09.34.25;	author jra;	state Exp;
branches;
next	;

11.25.2.1
date	2002.09.19.18.00.36;	author morrison;	state Exp;
branches;
next	11.25.2.2;

11.25.2.2
date	2004.03.17.21.15.56;	author morrison;	state Exp;
branches;
next	;

11.25.4.1
date	2004.03.11.23.40.30;	author morrison;	state Exp;
branches;
next	;


desc
@BRLCAD to Euclid "decoded" format converter
@


11.29
log
@moved to src/conv/
@
text
@/*
 *			G - E U C L I D . C
 *
 *  Program to convert a BRL-CAD model (in a .g file) to a Euclid "decoded" facetted model
 *  by calling on the NMG booleans.
 *
 *  Author -
 *	John R. Anderson
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimitied.
 */

#ifndef lint
static const char RCSid[] = "$Header: /n/xoff/cvs/brlcad/conv/g-euclid.c,v 11.28 2004/05/10 15:30:41 erikg Exp $";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "../librt/debug.h"

BU_EXTERN(union tree *do_region_end, (struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data));

static char	usage[] = "Usage: %s [-v] [-xX lvl] [-a abs_tol] [-r rel_tol] [-n norm_tol] [-o out_file] brlcad_db.g object(s)\n";

static int	NMG_debug=0;		/* saved arg of -X, for longjmp handling */
static int	verbose;
static int	curr_id;		/* Current region ident code */
static int	face_count;		/* Count of faces output for a region id */
static char	*out_file = NULL;	/* Output filename */
static FILE	*fp_out;		/* Output file pointer */
static int	*idents;		/* Array of region ident numbers */
static int	ident_count=0;		/* Number of idents in above array */
static int	ident_length=0;		/* Length of idents array */
#define		IDENT_BLOCK	256	/* Number of idents array slots to allocate */

static struct db_i		*dbip;
static struct rt_tess_tol	ttol;
static struct bn_tol		tol;
static struct model		*the_model;

static struct db_tree_state	tree_state;	/* includes tol & model */

static int	regions_tried = 0;
static int	regions_converted = 0;
static int	regions_written = 0;

struct facets
{
	struct loopuse *lu;
	struct loopuse *outer_loop;
	fastf_t diag_len;
	int facet_type;
};

void
fastf_print(FILE *fp_out, int length, fastf_t f)
{
	char buffer[128];
	char *ptr;
	int i;
	int buf_len;

	sprintf( &buffer[1], "%f", f );
	buffer[0] = ' ';

	buf_len = strlen( buffer );
	if( buf_len <= length )
	{
		for( i=0 ; i<length ; i++ )
		{
			if( i < buf_len )
				fputc( buffer[i], fp_out );
			else
				fputc( ' ', fp_out );
		}

		return;
	}

	ptr = strchr( buffer, '.' );
	if( (ptr - buffer) > length )
	{
		bu_log( "Value (%f) too large for format length (%d)\n" , f, length );
		rt_bomb( "fastf_print\n" );
	}

	for( i=0 ; i<length ; i++ )
		fputc( buffer[i], fp_out );
}

void
insert_id(int id)
{
	int i;

	for( i=0 ; i<ident_count ; i++ )
	{
		if( idents[i] == id )
			return;
	}

	if( ident_count == ident_length )
	{
		idents = (int *)rt_realloc( (char *)idents , (ident_length + IDENT_BLOCK)*sizeof( int ) , "insert_id: idents" );
		ident_length += IDENT_BLOCK;
	}

	idents[ident_count] = id;
	ident_count++;
}

static int
select_region(register struct db_tree_state *tsp, struct db_full_path *pathp, const struct rt_comb_internal *combp, genptr_t client_data)
{
	if(verbose )
		bu_log( "select_region: curr_id = %d, tsp->ts_regionid = %d\n" , curr_id , tsp->ts_regionid);

	if( tsp->ts_regionid == curr_id )
		return( 0 );
	else
		return( -1 );
}

static int
get_reg_id(register struct db_tree_state *tsp, struct db_full_path *pathp, const struct rt_comb_internal *combp, genptr_t client_data)
{
	if( verbose )
		bu_log( "get_reg_id: Adding id %d to list\n" , tsp->ts_regionid );
	insert_id( tsp->ts_regionid );
	return( -1 );
}

static union tree *
region_stub(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
{
	bu_log( "region stub called, this shouldn't happen\n" );
	rt_bomb( "region_stub\n" );

	return( (union tree *)NULL ); /* just to keep the compilers happy */
}

static union tree *
leaf_stub(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
{
	bu_log( "leaf stub called, this shouldn't happen\n" );
	rt_bomb( "leaf_stub\n" );

	return( (union tree *)NULL ); /* just to keep the compilers happy */
}

static void
Write_euclid_face(const struct loopuse *lu, const int facet_type, const int regionid, const int face_number)
{
	struct faceuse *fu;
	struct edgeuse *eu;
	plane_t plane;
	int vertex_count=0;

	NMG_CK_LOOPUSE( lu );

	if( verbose )
		bu_log( "Write_euclid_face: lu=x%x, facet_type=%d, regionid=%d, face_number=%d\n",
			lu,facet_type,regionid,face_number );

	if( BU_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
		return;

	if( *lu->up.magic_p != NMG_FACEUSE_MAGIC )
		return;

	for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
		vertex_count++;

	fprintf( fp_out , "%10d%3d     0.    1%5d" , regionid , facet_type , vertex_count );

	vertex_count = 0;
	for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
	{
		struct vertex *v;
		int i;

		NMG_CK_EDGEUSE( eu );
		v = eu->vu_p->v_p;
		NMG_CK_VERTEX( v );
/*		fprintf( fp_out , "%10d%8f%8f%8f" , ++vertex_count , V3ARGS( v->vg_p->coord ) ); */
		vertex_count++;
		fprintf( fp_out, "%10d", vertex_count );

		for( i=X; i<=Z; i++ )
			fastf_print( fp_out, 8, v->vg_p->coord[i] );
	}

	fu = lu->up.fu_p;
	NMG_CK_FACEUSE( fu );
	NMG_GET_FU_PLANE( plane , fu );
	fprintf( fp_out , "%10d%15.5f%15.5f%15.5f%15.5f" , face_number , V4ARGS( plane ) );
}

/*	Routine to write an nmgregion in the Euclid "decoded" format */
static void
Write_euclid_region(struct nmgregion *r, struct db_tree_state *tsp)
{
	struct shell *s;
	struct facets *faces=NULL;
	int i,j;

	NMG_CK_REGION( r );

	if( verbose )
		bu_log( "Write_euclid_region: r=x%x\n" , r );

	/* if bounds haven't been calculated, do it now */
	if( r->ra_p == NULL )
		nmg_region_a( r , &tol );

	/* Check if region extents are beyond the limitations of the format */
	for( i=X ; i<ELEMENTS_PER_PT ; i++ )
	{
		if( r->ra_p->min_pt[i] < (-999999.0) )
		{
			bu_log( "g-euclid: Coordinates too large (%g) for Euclid format\n" , r->ra_p->min_pt[i] );
			return;
		}
		if( r->ra_p->max_pt[i] > 9999999.0 )
		{
			bu_log( "g-euclid: Coordinates too large (%g) for Euclid format\n" , r->ra_p->max_pt[i] );
			return;
		}
	}

	/* write out each face in the region */
	for( BU_LIST_FOR( s , shell , &r->s_hd ) )
	{
		struct faceuse *fu;

		for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
		{
			struct loopuse *lu;
			int no_of_loops=0;
			int no_of_holes=0;

			if( fu->orientation != OT_SAME )
				continue;

			/* count the loops in this face */
			for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
			{
				if( BU_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
					continue;

				no_of_loops++;
			}

			if( !no_of_loops )
				continue;

			faces = (struct facets *)bu_calloc( no_of_loops , sizeof( struct facets ) , "g-euclid: faces" );

			i = 0;
			for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
			{
				if( BU_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
					continue;

				faces[i].lu = lu;
				if( lu->orientation == OT_OPPOSITE )
					faces[i].facet_type = 1; /* this is a hole */
				else
					faces[i].facet_type = (-1); /* TBD */

				faces[i].outer_loop = NULL;
				i++;
			}

			/* determine type of face 
			 * 0 -> simple facet (no holes )
			 * 1 -> a hole
			 * 2 -> a facet that will have holes
			 */

			for( i=0 ; i<no_of_loops ; i++ )
			{
				if( faces[i].facet_type == 1 )
					no_of_holes++;
			}

			if( !no_of_holes )
			{
				/* no holes, so each loop is a simple face (type 0) */
				for( i=0 ; i<no_of_loops ; i++ )
					faces[i].facet_type = 0;
			}
			else if( no_of_loops == no_of_holes + 1 )
			{
				struct loopuse *outer_lu=(struct loopuse *)NULL;

				/* only one outer loop, so find it */
				for( i=0 ; i<no_of_loops ; i++ )
				{
					if( faces[i].facet_type == (-1) )
					{
						outer_lu = faces[i].lu;
						faces[i].facet_type = 2;
						break;
					}
				}

				/* every hole must have this same outer_loop */
				for( i=0 ; i<no_of_loops ; i++ )
				{
					if( faces[i].facet_type == 1 )
						faces[i].outer_loop = outer_lu;
				}
			}
			else
			{
				int loop1,loop2;
				int outer_loop_count;

				/* must determine which holes go with which outer loops */
				for( loop1=0 ; loop1<no_of_loops ; loop1++ )
				{
					if( faces[loop1].facet_type != 1 )
						continue;

					/* loop1 is a hole look for loops containing loop1 */
					outer_loop_count = 0;
					for( loop2=0 ; loop2<no_of_loops ; loop2++ )
					{
						int class;

						if( faces[loop2].facet_type == 1 )
							continue;

						class = nmg_classify_lu_lu( faces[loop1].lu,
								faces[loop2].lu , &tol );

						if( class != NMG_CLASS_AinB )
							continue;

						/* loop1 is inside loop2, possible outer loop */
						faces[loop2].facet_type = (-2);
						outer_loop_count++;
					}

					if( outer_loop_count > 1 )
					{
						/* must choose outer loop from a list of candidates
						 * if any of these candidates contain one of the
						 * other candidates, the outer one can be eliminated
						 * as a possible choice */
						for( loop2=0 ; loop2<no_of_loops ; loop2++ )
						{
							if( faces[loop2].facet_type != (-2) )
								continue;

							for( i=0 ; i<no_of_loops ; i++ )
							{
								if( faces[i].facet_type != (-2) )
									continue;

								if( nmg_classify_lu_lu( faces[i].lu,
									faces[loop2].lu , &tol ) )
								{
									if( faces[i].facet_type != (-2) )
										continue;

									faces[loop2].facet_type = (-1);
									outer_loop_count--;
								}
							}
						}
					}

					if( outer_loop_count != 1 )
					{
						bu_log( "Failed to find outer loop for hole in component %d\n" , tsp->ts_regionid );
						goto outt;
					}

					for( i=0 ; i<no_of_loops ; i++ )
					{
						if( faces[i].facet_type == (-2) )
						{
							faces[i].facet_type = 2;
							faces[loop1].outer_loop = faces[i].lu;
						}
					}
				}

				/* Check */
				for( i=0 ; i<no_of_loops ; i++ )
				{
					if( faces[i].facet_type < 0 )
					{
						/* all holes have been placed 
						 * so these must be simple faces
						 */
						faces[i].facet_type = 0;
					}

					if( faces[i].facet_type == 1 && faces[i].outer_loop == NULL )
					{
						bu_log( "Failed to find outer loop for hole in component %d\n" , tsp->ts_regionid );
						goto outt;
					}
				}
			}
			/* output faces with holes first */
			for( i=0 ; i<no_of_loops ; i++ )
			{
				struct loopuse *outer_loop;

				if( faces[i].facet_type != 2 )
					continue;

				outer_loop = faces[i].lu;
				Write_euclid_face( outer_loop , 2 , tsp->ts_regionid , ++face_count );

				/* output holes for this face */
				for( j=0 ; j<no_of_loops ; j++ )
				{
					if( j == i )
						continue;

					if( faces[j].outer_loop == outer_loop )
						Write_euclid_face( faces[j].lu , 1 , tsp->ts_regionid , ++face_count );
				}
			}
			/* output simple faces */
			for( i=0 ; i<no_of_loops ; i++ )
			{
				if( faces[i].facet_type != 0 )
					continue;
				Write_euclid_face( faces[i].lu , 0 , tsp->ts_regionid , ++face_count );
			}

			bu_free( (char *)faces , "g-euclid: faces" );
			faces = (struct facets*)NULL;
		}
	}

	regions_written++;

   outt:
	if( faces )
		bu_free( (char *)faces , "g-euclid: faces" );
	return;
}

/*
 *			M A I N
 */
int
main(int argc, char **argv)
{
	int		i,j;
	register int	c;
	double		percent;

	port_setlinebuf( stderr );

	rt_g.debug = 0;
#if MEMORY_LEAK_CHECKING
	rt_g.debug |= DEBUG_MEM_FULL;
#endif

	ttol.magic = RT_TESS_TOL_MAGIC;
	/* Defaults, updated by command line options. */
	ttol.abs = 0.0;
	ttol.rel = 0.01;
	ttol.norm = 0.0;

	/* XXX These need to be improved */
	tol.magic = BN_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;

	the_model = (struct model *)NULL;
	tree_state = rt_initial_tree_state;	/* struct copy */
	tree_state.ts_m = &the_model;
	tree_state.ts_tol = &tol;
	tree_state.ts_ttol = &ttol;

	rt_init_resource( &rt_uniresource, 0, NULL );

	/* XXX For visualization purposes, in the debug plot files */
	{
		extern fastf_t	nmg_eue_dist;	/* librt/nmg_plot.c */
		/* XXX This value is specific to the Bradley */
		nmg_eue_dist = 2.0;
	}
	BU_LIST_INIT( &rt_g.rtg_vlfree );	/* for vlist macros */

	/* Get command line arguments. */
	while ((c = getopt(argc, argv, "a:n:o:r:s:vx:P:X:")) != EOF) {
		switch (c) {
		case 'a':		/* Absolute tolerance. */
			ttol.abs = atof(optarg);
			ttol.rel = 0.0;
			break;
		case 'n':		/* Surface normal tolerance. */
			ttol.norm = atof(optarg);
			ttol.rel = 0.0;
			break;
		case 'o':		/* Output file name */
			out_file = optarg;
			break;
		case 'r':		/* Relative tolerance. */
			ttol.rel = atof(optarg);
			break;
		case 'v':
			verbose++;
			break;
		case 'P':
/*			ncpu = atoi( optarg ); */
			rt_g.debug = 1;	/* XXX DEBUG_ALLRAYS -- to get core dumps */
			break;
		case 'x':
			sscanf( optarg, "%x", (unsigned int *)&rt_g.debug );
			break;
		case 'X':
			sscanf( optarg, "%x", (unsigned int *)&rt_g.NMG_debug );
			NMG_debug = rt_g.NMG_debug;
			break;
		default:
			fprintf(stderr, usage, argv[0]);
			exit(1);
			break;
		}
	}

	if (optind+1 >= argc) {
		fprintf(stderr, usage, argv[0]);
		exit(1);
	}

	/* Open brl-cad database */
	if ((dbip = db_open( argv[optind] , "r")) == DBI_NULL)
	{
		bu_log( "Cannot open %s\n" , argv[optind] );
		perror(argv[0]);
		exit(1);
	}
	db_dirbuild( dbip );

	if( out_file == NULL )
		fp_out = stdout;
	else
	{
		if ((fp_out = fopen( out_file , "w")) == NULL)
		{
			bu_log( "Cannot open %s\n" , out_file );
			perror( argv[0] );
			return 2;
		}
	}
	optind++;

	fprintf( fp_out , "$03" );

	/* First produce an unordered list of region ident codes */
	(void)db_walk_tree(dbip, argc-optind, (const char **)(&argv[optind]),
		1,			/* ncpu */
		&tree_state,
		get_reg_id,			/* put id in table */
		region_stub,
		leaf_stub,
		(genptr_t)NULL);

	/* Process regions in ident order */
	curr_id = 0;
	for( i=0 ; i<ident_length ; i++ )
	{
		int next_id = 99999999;
		for( j=0 ; j<ident_length ; j++ )
		{
			int test_id;

			test_id = idents[j];
			if( test_id > curr_id && test_id < next_id )
				next_id = test_id;
		}
		curr_id = next_id;
		face_count = 0;

		bu_log( "Processing id %d\n" , curr_id );

		/* Walk indicated tree(s).  Each region will be output separately */

		tree_state = rt_initial_tree_state;	/* struct copy */
		the_model = nmg_mm();
		tree_state.ts_m = &the_model;
		tree_state.ts_tol = &tol;
		tree_state.ts_ttol = &ttol;

		(void)db_walk_tree(dbip, argc-optind, (const char **)(&argv[optind]),
			1,			/* ncpu */
			&tree_state,
			select_region,
			do_region_end,
			nmg_booltree_leaf_tess,
			(genptr_t)NULL);	/* in librt/nmg_bool.c */

		nmg_km( the_model );

#if MEMORY_LEAK_CHECKING
		bu_prmem("After conversion of id");
#endif
	}

	percent = 0;
	if( regions_tried > 0 )
		percent = ((double)regions_converted * 100) / regions_tried;
	printf( "Tried %d regions, %d converted successfully.  %g%%\n",
		regions_tried, regions_converted, percent );
	percent = 0;
	if( regions_tried > 0 )
		percent = ((double)regions_written * 100) / regions_tried;
	printf( "                  %d written successfully. %g%%\n",
		regions_written, percent );

	/* Release dynamic storage */
	rt_vlist_cleanup();
	db_close(dbip);

#if MEMORY_LEAK_CHECKING
	bu_prmem("After complete G-EUCLID conversion");
#endif

	return 0;
}

/*
*			D O _ R E G I O N _ E N D
*
*  Called from db_walk_tree().
*
*  This routine must be prepared to run in parallel.
*/
union tree *do_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
{
	struct nmgregion	*r;
	struct bu_list		vhead;
	union tree		*ret_tree;

	if( verbose )
		bu_log( "do_region_end: regionid = %d\n" , tsp->ts_regionid );

	RT_CK_TESS_TOL(tsp->ts_ttol);
	BN_CK_TOL(tsp->ts_tol);
	NMG_CK_MODEL(*tsp->ts_m);

	BU_LIST_INIT(&vhead);

	if (RT_G_DEBUG&DEBUG_TREEWALK || verbose) {
		char	*sofar = db_path_to_string(pathp);
		bu_log("\ndo_region_end(%d %d%%) %s\n",
			regions_tried,
			regions_tried>0 ? (regions_converted * 100) / regions_tried : 0,
			sofar);
		bu_free(sofar, "path string");
	}

	if (curtree->tr_op == OP_NOP)
		return  curtree;

	regions_tried++;
	/* Begin rt_bomb() protection */
	if( BU_SETJUMP )
	{
		/* Error, bail out */
		BU_UNSETJUMP;		/* Relinquish the protection */

		/* Sometimes the NMG library adds debugging bits when
		 * it detects an internal error, before rt_bomb().
		 */
		rt_g.NMG_debug = NMG_debug;	/* restore mode */

		/* Release any intersector 2d tables */
		nmg_isect2d_final_cleanup();

		/* Release the tree memory & input regions */
		db_free_tree(curtree, &rt_uniresource);	/* Does an nmg_kr() */

		/* Get rid of (m)any other intermediate structures */
		if( (*tsp->ts_m)->magic == NMG_MODEL_MAGIC )
			nmg_km(*tsp->ts_m);
		else
			bu_log("WARNING: tsp->ts_m pointer corrupted, ignoring it.\n");

		/* Now, make a new, clean model structure for next pass. */
		*tsp->ts_m = nmg_mm();
	
		goto out;
	}
	if( verbose )
		bu_log( "\tEvaluating region\n" );
	(void)nmg_model_fuse(*tsp->ts_m, tsp->ts_tol);

	/* librt/nmg_bool.c */
	ret_tree = nmg_booltree_evaluate(curtree, tsp->ts_tol, &rt_uniresource);

	if( ret_tree )
		r = ret_tree->tr_d.td_r;
	else
		r = (struct nmgregion *)NULL;

	BU_UNSETJUMP;		/* Relinquish the protection */
	regions_converted++;
	if (r != 0)
	{
		struct shell *s;
		int empty_region=0;
		int empty_model=0;

		/* Kill cracks */
		s = BU_LIST_FIRST( shell, &r->s_hd );
		while( BU_LIST_NOT_HEAD( &s->l, &r->s_hd ) )
		{
			struct shell *next_s;

			next_s = BU_LIST_PNEXT( shell, &s->l );
			if( nmg_kill_cracks( s ) )
			{
				if( nmg_ks( s ) )
				{
					empty_region = 1;
					break;
				}
			}
			s = next_s;
		}

		/* kill zero length edgeuses */
		if( !empty_region )
		{
			 empty_model = nmg_kill_zero_length_edgeuses( *tsp->ts_m );
		}

		if( !empty_region && !empty_model )
		{
			/* Write the region to the EUCLID file */
			Write_euclid_region( r , tsp );
		}

		if( !empty_model )
			nmg_kr( r );
	}

	/*
	 *  Dispose of original tree, so that all associated dynamic
	 *  memory is released now, not at the end of all regions.
	 *  A return of TREE_NULL from this routine signals an error,
	 *  so we need to cons up an OP_NOP node to return.
	 */
	db_free_tree(curtree, &rt_uniresource);		/* Does an nmg_kr() */

out:
	BU_GETUNION(curtree, tree);
	curtree->magic = RT_TREE_MAGIC;
	curtree->tr_op = OP_NOP;
	return(curtree);
}
@


11.28
log
@change conf.h to a wrapped config.h
@
text
@d19 1
a19 1
static const char RCSid[] = "$Header: /cvs/brlcad/conv/g-euclid.c,v 11.27 2004/04/05 07:49:36 morrison Exp $";
@


11.27
log
@merge of ansi-6-0-branch into HEAD
@
text
@d19 1
a19 1
static const char RCSid[] = "$Header$";
d22 5
a26 1
#include "conf.h"
@


11.26
log
@Eliminated non-existent option from usage statement
@
text
@d19 1
a19 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-euclid.c,v 11.25 2002/08/20 17:07:21 jra Exp $";
d75 1
a75 4
fastf_print( fp_out, length, f )
FILE *fp_out;
int length;
fastf_t f;
d111 1
a111 2
insert_id( id )
int id;
d132 1
a132 5
select_region( tsp, pathp, combp, client_data )
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
const struct rt_comb_internal *combp;
genptr_t		client_data;
d144 1
a144 5
get_reg_id( tsp, pathp, combp, client_data )
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
const struct rt_comb_internal *combp;
genptr_t client_data;
d153 1
a153 5
region_stub( tsp, pathp, curtree, client_data )
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
d162 1
a162 5
leaf_stub( tsp, pathp, ip, client_data )
struct db_tree_state    *tsp;
struct db_full_path     *pathp;
struct rt_db_internal	*ip;
genptr_t		client_data;
d171 1
a171 5
Write_euclid_face( lu , facet_type , regionid , face_number )
const struct loopuse *lu;
const int facet_type;
const int regionid;
const int face_number;
d220 1
a220 3
Write_euclid_region( r , tsp )
struct nmgregion *r;
struct db_tree_state *tsp;
d474 1
a474 3
main(argc, argv)
int	argc;
char	*argv[];
d662 1
a662 5
union tree *do_region_end(tsp, pathp, curtree, client_data)
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
@


11.25
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d19 1
a19 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-euclid.c,v 11.23 2001/08/10 21:22:53 butler Exp $";
d42 1
a42 1
static char	usage[] = "Usage: %s [-v] [-d] [-xX lvl] [-a abs_tol] [-r rel_tol] [-n norm_tol] [-o out_file] brlcad_db.g object(s)\n";
@


11.25.4.1
log
@sync to HEAD...
@
text
@d19 1
a19 1
static const char RCSid[] = "$Header: /n/cad/c/CVS/brlcad/conv/g-euclid.c,v 11.26 2002/10/15 17:36:22 jra Exp $";
d42 1
a42 1
static char	usage[] = "Usage: %s [-v] [-xX lvl] [-a abs_tol] [-r rel_tol] [-n norm_tol] [-o out_file] brlcad_db.g object(s)\n";
@


11.25.2.1
log
@Initial ANSIfication
@
text
@d19 1
a19 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-euclid.c,v 11.25 2002/08/20 17:07:21 jra Exp $";
d75 4
a78 1
fastf_print(FILE *fp_out, int length, fastf_t f)
d114 2
a115 1
insert_id(int id)
d136 5
a140 1
select_region(register struct db_tree_state *tsp, struct db_full_path *pathp, const struct rt_comb_internal *combp, genptr_t client_data)
d152 5
a156 1
get_reg_id(register struct db_tree_state *tsp, struct db_full_path *pathp, const struct rt_comb_internal *combp, genptr_t client_data)
d165 5
a169 1
region_stub(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
d178 5
a182 1
leaf_stub(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
d191 5
a195 1
Write_euclid_face(const struct loopuse *lu, const int facet_type, const int regionid, const int face_number)
d244 3
a246 1
Write_euclid_region(struct nmgregion *r, struct db_tree_state *tsp)
d500 3
a502 1
main(int argc, char **argv)
d690 5
a694 1
union tree *do_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
@


11.25.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
static const char RCSid[] = "$Header$";
d42 1
a42 1
static char	usage[] = "Usage: %s [-v] [-xX lvl] [-a abs_tol] [-r rel_tol] [-n norm_tol] [-o out_file] brlcad_db.g object(s)\n";
@


11.24
log
@Converted from K&R to ANSI C - RFH
@
text
@d75 4
a78 1
fastf_print(FILE *fp_out, int length, fastf_t f)
d114 2
a115 1
insert_id(int id)
d136 5
a140 1
select_region(register struct db_tree_state *tsp, struct db_full_path *pathp, const struct rt_comb_internal *combp, genptr_t client_data)
d152 5
a156 1
get_reg_id(register struct db_tree_state *tsp, struct db_full_path *pathp, const struct rt_comb_internal *combp, genptr_t client_data)
d165 5
a169 1
region_stub(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
d178 5
a182 1
leaf_stub(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
d191 5
a195 1
Write_euclid_face(const struct loopuse *lu, const int facet_type, const int regionid, const int face_number)
d244 3
a246 1
Write_euclid_region(struct nmgregion *r, struct db_tree_state *tsp)
d500 3
a502 1
main(int argc, char **argv)
d690 5
a694 1
union tree *do_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
@


11.23
log
@Compiler warning patches
@
text
@d19 1
a19 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-euclid.c,v 11.22 2001/05/17 20:03:14 morrison Exp $";
d75 1
a75 4
fastf_print( fp_out, length, f )
FILE *fp_out;
int length;
fastf_t f;
d111 1
a111 2
insert_id( id )
int id;
d132 1
a132 5
select_region( tsp, pathp, combp, client_data )
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
const struct rt_comb_internal *combp;
genptr_t		client_data;
d144 1
a144 5
get_reg_id( tsp, pathp, combp, client_data )
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
const struct rt_comb_internal *combp;
genptr_t client_data;
d153 1
a153 5
region_stub( tsp, pathp, curtree, client_data )
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
d162 1
a162 5
leaf_stub( tsp, pathp, ip, client_data )
struct db_tree_state    *tsp;
struct db_full_path     *pathp;
struct rt_db_internal	*ip;
genptr_t		client_data;
d171 1
a171 5
Write_euclid_face( lu , facet_type , regionid , face_number )
const struct loopuse *lu;
const int facet_type;
const int regionid;
const int face_number;
d220 1
a220 3
Write_euclid_region( r , tsp )
struct nmgregion *r;
struct db_tree_state *tsp;
d474 1
a474 3
main(argc, argv)
int	argc;
char	*argv[];
d662 1
a662 5
union tree *do_region_end(tsp, pathp, curtree, client_data)
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
@


11.22
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d19 1
a19 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-euclid.c,v 11.21 2001/04/05 19:34:59 morrison Exp $";
d569 1
a569 1
			sscanf( optarg, "%x", &rt_g.debug );
d572 1
a572 1
			sscanf( optarg, "%x", &rt_g.NMG_debug );
@


11.21
log
@updated SIGNED to signed
updated CONST to const
@
text
@d19 1
a19 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-euclid.c,v 11.20 2000/09/13 12:53:23 jra Exp $";
d709 1
a709 1
	if (rt_g.debug&DEBUG_TREEWALK || verbose) {
@


11.20
log
@lint
@
text
@d19 1
a19 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-euclid.c,v 11.19 2000/09/08 05:55:42 mike Exp $";
d139 1
a139 1
CONST struct rt_comb_internal *combp;
d155 1
a155 1
CONST struct rt_comb_internal *combp;
d192 4
a195 4
CONST struct loopuse *lu;
CONST int facet_type;
CONST int regionid;
CONST int face_number;
d612 1
a612 1
	(void)db_walk_tree(dbip, argc-optind, (CONST char **)(&argv[optind]),
d646 1
a646 1
		(void)db_walk_tree(dbip, argc-optind, (CONST char **)(&argv[optind]),
@


11.19
log
@
Tree routines now need resource structure.
Added rt_init_resource() call.
@
text
@d19 1
a19 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-euclid.c,v 11.18 2000/08/24 03:14:24 mike Exp $";
d249 1
a249 1
	struct facets *faces;
d340 1
a340 1
				struct loopuse *outer_lu;
@


11.18
log
@
lint
@
text
@d19 1
a19 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-euclid.c,v 11.17 2000/07/21 12:44:34 jra Exp $";
d534 2
d737 1
a737 1
		db_free_tree(curtree);		/* Does an nmg_kr() */
d753 3
a755 1
	ret_tree = nmg_booltree_evaluate(curtree, tsp->ts_tol);	/* librt/nmg_bool.c */
d810 1
a810 1
	db_free_tree(curtree);		/* Does an nmg_kr() */
@


11.17
log
@Replaced db_scan() calls with db_dirbuild()
@
text
@d19 1
a19 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-euclid.c,v 11.16 2000/07/12 21:59:34 mike Exp $";
d671 1
a671 1
	bn_vlist_cleanup();
@


11.16
log
@
Converted to use new version of LIBWDB
@
text
@d19 1
a19 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-euclid.c,v 11.15 2000/07/10 23:53:57 mike Exp $";
d592 1
a592 1
	db_scan(dbip, (int (*)())db_diradd, 1, NULL);
@


11.15
log
@
lint
@
text
@d19 1
a19 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-euclid.c,v 11.14 2000/06/29 20:51:37 mike Exp $";
a693 1
	extern FILE		*fp_fig;
@


11.14
log
@
db_walk_tree leaf callback arg change
@
text
@d19 1
a19 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-euclid.c,v 11.13 2000/03/29 18:15:12 mike Exp $";
@


11.13
log
@
Eliminated macro which also appears in vmath.h now
@
text
@d19 1
a19 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-euclid.c,v 11.12 2000/03/29 18:07:44 mike Exp $";
d178 1
a178 1
leaf_stub( tsp, pathp, ep, id, client_data )
d181 1
a181 2
struct bu_external      *ep;
int                     id;
@


11.12
log
@
Removed stray RT_EXTERNs, added bn_ prefix.
@
text
@d19 1
a19 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-euclid.c,v 11.11 2000/03/03 03:34:34 mike Exp $";
a72 5

#define V3RPP1_IN_RPP2( _lo1 , _hi1 , _lo2 , _hi2 )	( \
	(_lo1)[X] >= (_lo2)[X] && (_hi1)[X] <= (_hi2)[X] && \
	(_lo1)[Y] >= (_lo2)[Y] && (_hi1)[Y] <= (_hi2)[Y] && \
	(_lo1)[Z] >= (_lo2)[Z] && (_hi1)[Z] <= (_hi2)[Z] )
@


11.11
log
@
Made function args match prototype.
@
text
@d19 1
a19 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-euclid.c,v 11.10 2000/01/04 17:58:19 bparker Exp $";
d40 1
a40 2
RT_EXTERN(union tree *do_region_end, (struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data));
RT_EXTERN( struct face *nmg_find_top_face , (struct shell *s , long *flags ));
@


11.10
log
@*- add client_data to db_walk_tree
@
text
@d19 1
a19 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-euclid.c,v 11.9 1999/12/30 18:25:08 jra Exp $";
d142 1
a142 1
select_region( tsp, pathp, curtree, client_data )
d145 1
a145 1
union tree		*curtree;
d158 1
a158 1
get_reg_id( tsp, pathp, curtree )
d161 2
a162 1
union tree		*curtree;
@


11.9
log
@Eliminated some unused variables
@
text
@d19 1
a19 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-euclid.c,v 11.8 1999/12/29 23:23:00 mike Exp $";
d40 1
a40 1
RT_EXTERN(union tree *do_region_end, (struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree));
d142 1
a142 1
select_region( tsp, pathp, curtree )
d146 1
d170 1
a170 1
region_stub( tsp, pathp, curtree )
d174 1
d183 1
a183 1
leaf_stub( tsp, pathp, ep, id )
d188 1
d621 2
a622 1
		leaf_stub );
d655 2
a656 1
			nmg_booltree_leaf_tess);	/* in librt/nmg_bool.c */
d694 1
a694 1
union tree *do_region_end(tsp, pathp, curtree)
d698 1
@


11.8
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d19 1
a19 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-euclid.c,v 11.7 1999/06/03 21:54:20 mike Exp $";
a46 1
static int	ncpu = 1;		/* Number of processors */
d566 1
a566 1
			ncpu = atoi( optarg );
@


11.7
log
@
sed4
@
text
@d19 1
a19 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-euclid.c,v 11.6 1996/08/02 12:46:58 jra Exp $";
d596 1
a596 1
	db_scan(dbip, (int (*)())db_diradd, 1);
@


11.6
log
@Corrected handling of tessellation tolerances options.
@
text
@d19 1
a19 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-euclid.c,v 11.5 1995/04/03 19:48:38 jra Exp jra $";
d59 1
a59 1
static struct rt_tol		tol;
d112 1
a112 1
		rt_log( "Value (%f) too large for format length (%d)\n" , f, length );
d149 1
a149 1
		rt_log( "select_region: curr_id = %d, tsp->ts_regionid = %d\n" , curr_id , tsp->ts_regionid);
d164 1
a164 1
		rt_log( "get_reg_id: Adding id %d to list\n" , tsp->ts_regionid );
d175 1
a175 1
	rt_log( "region stub called, this shouldn't happen\n" );
d185 1
a185 1
struct rt_external      *ep;
d188 1
a188 1
	rt_log( "leaf stub called, this shouldn't happen\n" );
d209 1
a209 1
		rt_log( "Write_euclid_face: lu=x%x, facet_type=%d, regionid=%d, face_number=%d\n",
d212 1
a212 1
	if( RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
d218 1
a218 1
	for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d224 1
a224 1
	for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d259 1
a259 1
		rt_log( "Write_euclid_region: r=x%x\n" , r );
d270 1
a270 1
			rt_log( "g-euclid: Coordinates too large (%g) for Euclid format\n" , r->ra_p->min_pt[i] );
d275 1
a275 1
			rt_log( "g-euclid: Coordinates too large (%g) for Euclid format\n" , r->ra_p->max_pt[i] );
d281 1
a281 1
	for( RT_LIST_FOR( s , shell , &r->s_hd ) )
d285 1
a285 1
		for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
d295 1
a295 1
			for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d297 1
a297 1
				if( RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
d306 1
a306 1
			faces = (struct facets *)rt_calloc( no_of_loops , sizeof( struct facets ) , "g-euclid: faces" );
d309 1
a309 1
			for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d311 1
a311 1
				if( RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
d426 1
a426 1
						rt_log( "Failed to find outer loop for hole in component %d\n" , tsp->ts_regionid );
d453 1
a453 1
						rt_log( "Failed to find outer loop for hole in component %d\n" , tsp->ts_regionid );
d487 1
a487 1
			rt_free( (char *)faces , "g-euclid: faces" );
d496 1
a496 1
		rt_free( (char *)faces , "g-euclid: faces" );
d526 1
a526 1
	tol.magic = RT_TOL_MAGIC;
d544 1
a544 1
	RT_LIST_INIT( &rt_g.rtg_vlfree );	/* for vlist macros */
d592 1
a592 1
		rt_log( "Cannot open %s\n" , argv[optind] );
d604 1
a604 1
			rt_log( "Cannot open %s\n" , out_file );
d637 1
a637 1
		rt_log( "Processing id %d\n" , curr_id );
d657 1
a657 1
		rt_prmem("After conversion of id");
d673 1
a673 1
	rt_vlist_cleanup();
d677 1
a677 1
	rt_prmem("After complete G-EUCLID conversion");
d697 1
a697 1
	struct rt_list		vhead;
d701 1
a701 1
		rt_log( "do_region_end: regionid = %d\n" , tsp->ts_regionid );
d704 1
a704 1
	RT_CK_TOL(tsp->ts_tol);
d707 1
a707 1
	RT_LIST_INIT(&vhead);
d711 1
a711 1
		rt_log("\ndo_region_end(%d %d%%) %s\n",
d715 1
a715 1
		rt_free(sofar, "path string");
d723 1
a723 1
	if( RT_SETJUMP )
d726 1
a726 1
		RT_UNSETJUMP;		/* Relinquish the protection */
d743 1
a743 1
			rt_log("WARNING: tsp->ts_m pointer corrupted, ignoring it.\n");
d751 1
a751 1
		rt_log( "\tEvaluating region\n" );
d760 1
a760 1
	RT_UNSETJUMP;		/* Relinquish the protection */
d769 2
a770 2
		s = RT_LIST_FIRST( shell, &r->s_hd );
		while( RT_LIST_NOT_HEAD( &s->l, &r->s_hd ) )
d774 1
a774 1
			next_s = RT_LIST_PNEXT( shell, &s->l );
d811 1
a811 1
	GETUNION(curtree, tree);
@


11.5
log
@Added calls to nmg_kill_cracks() and nmg_kill_zero_length_edgeuses().
@
text
@d19 1
a19 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-euclid.c,v 11.4 1995/03/29 13:25:22 jra Exp $";
d551 1
d555 1
@


11.4
log
@Mods to account for new return of nmg_booltree_evaluate().
@
text
@d19 1
a19 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-euclid.c,v 11.3 1995/02/22 05:40:55 mike Exp jra $";
d762 33
a794 2
		/* Write the region to the EUCLID file */
		Write_euclid_region( r , tsp );
d796 2
a797 1
		nmg_kr( r );
@


11.3
log
@nmg_model_fuse() is still accounting for 25% of the runtime.  In order
to correct this, it is necessary for me to make calling nmg_model_fuse()
a pre-condition of calling nmg_booltree_evaluate().  That way it's done
exactly once per region.
@
text
@d19 1
a19 1
static char RCSid[] = "$Header: /n/wolf/m/cad/conv/RCS/g-euclid.c,v 11.2 1995/01/24 10:10:01 jra Exp mike $";
d696 1
d751 7
a757 1
	r = nmg_booltree_evaluate(curtree, tsp->ts_tol);	/* librt/nmg_bool.c */
@


11.2
log
@Added missing "curtree->magic = RT_TREE_MAGIC;" and modified output technique
for vertex coordinates.
@
text
@d19 1
a19 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-euclid.c,v 11.1 95/01/04 09:59:32 mike Rel4_4 Locker: jra $";
d749 1
@


11.1
log
@Release_4.4
@
text
@d19 1
a19 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-euclid.c,v 1.10 94/12/16 16:32:34 jra Exp $";
d81 10
d92 28
d227 1
d232 6
a237 1
		fprintf( fp_out , "%10d%8f%8f%8f" , ++vertex_count , V3ARGS( v->vg_p->coord ) );
d770 1
@


1.10
log
@removed setjmp.h
@
text
@d19 1
a19 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-euclid.c,v 1.9 94/12/08 17:56:15 jra Exp Locker: jra $";
@


1.9
log
@Mod for CRAY2.
@
text
@d19 1
a19 1
static char RCSid[] = "$Header: /n/wolf/m/cad/conv/RCS/g-euclid.c,v 1.8 94/11/08 16:15:03 jra Exp Locker: jra $";
a30 2

#include <setjmp.h>
@


1.8
log
@Mods for Irix 6.0
@
text
@d19 1
a19 1
static char RCSid[] = "$Header: /n/wolf/m/cad/conv/RCS/g-euclid.c,v 1.7 1994/08/23 14:29:45 jra Exp jra $";
d32 2
d678 1
a678 1
	if( ncpu == 1 && RT_SETJUMP )
@


1.7
log
@removed unused debug_plots variable.
@
text
@d19 1
a19 1
static char RCSid[] = "$Header: /n/wolf/m/cad/conv/RCS/g-euclid.c,v 1.6 94/08/11 00:05:51 gdurf Exp Locker: jra $";
d45 1
a45 1
static int	NMG_debug;		/* saved arg of -X, for longjmp handling */
d52 5
a56 1
static struct nmg_ptbl		idents;	/* Table of region ident numbers */
d81 23
d127 1
a127 1
	nmg_tbl( &idents , TBL_INS_UNIQUE , (long *)tsp->ts_regionid );
d139 2
d152 2
a243 1
			int face_type=0;
d464 1
a464 2
	char		*dot;
	int		i,j,ret;
d470 1
a493 3
	/* Initialize ident table */
	nmg_tbl( &idents , TBL_INIT , NULL );

a499 1

d568 1
a568 1
	ret = db_walk_tree(dbip, argc-optind, (CONST char **)(&argv[optind]),
a574 1

d577 1
a577 1
	for( i=0 ; i<NMG_TBL_END( &idents ) ; i++ )
d580 1
a580 1
		for( j=0 ; j<NMG_TBL_END( &idents ) ; j++ )
d584 1
a584 1
			test_id = (int)NMG_TBL_GET( &idents , j );
d601 1
a601 1
		ret = db_walk_tree(dbip, argc-optind, (CONST char **)(&argv[optind]),
@


1.6
log
@Factored ifdefs
@
text
@d19 1
a19 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-euclid.c,v 1.5 1994/04/20 15:59:05 jra Exp gdurf $";
a46 1
static int	debug_plots;		/* Make debugging plots */
d477 1
a477 1
	while ((c = getopt(argc, argv, "a:dn:o:r:s:vx:P:X:")) != EOF) {
a480 3
			break;
		case 'd':
			debug_plots = 1;
@


1.5
log
@minor formatting change for more precision
@
text
@d19 1
a19 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-euclid.c,v 1.4 94/03/18 10:32:23 jra Exp Locker: jra $";
d22 2
d26 1
d28 4
d440 1
a440 12
#ifdef BSD
	setlinebuf( stderr );
#else
#	if defined( SYSV ) && !defined( sgi ) && !defined(CRAY2) && \
	 !defined(n16)
		(void) setvbuf( stderr, (char *) NULL, _IOLBF, BUFSIZ );
#	endif
#	if defined(sgi) && defined(mips)
		if( setlinebuf( stderr ) != 0 )
			perror("setlinebuf(stderr)");
#	endif
#endif
@


1.4
log
@Added code to kill model and make new one between calls to db_walk_tree
@
text
@d19 1
a19 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-euclid.c,v 1.3 94/03/17 16:46:28 jra Exp Locker: jra $";
d156 1
a156 1
		fprintf( fp_out , "%10d%8.1f%8.1f%8.1f" , ++vertex_count , V3ARGS( v->vg_p->coord ) );
@


1.3
log
@Added some logging.
@
text
@d19 1
a19 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-euclid.c,v 1.2 94/01/07 12:59:58 jra Exp $";
a293 2
rt_log( "Hole Loop:\n" );
nmg_pr_lu_briefly( faces[loop1].lu , (char *)NULL );
a305 2
rt_log( "Possible outer loop classified %s (%d):\n" , nmg_class_name( class ) , class );
nmg_pr_lu_briefly( faces[loop2].lu , (char *)NULL );
a313 1
rt_log( "outer_loop_count = %d\n" , outer_loop_count );
d408 1
d415 2
a416 1
	rt_free( (char *)faces , "g-euclid: faces" );
d463 1
a463 1
	the_model = nmg_mm();
d577 1
d579 1
d590 6
@


1.2
log
@Added loop organizer (holes vs outer loops)
@
text
@d19 1
a19 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-euclid.c,v 1.1 93/12/09 09:34:25 jra Exp Locker: jra $";
d77 3
d92 2
d133 4
d177 3
d189 1
a189 1
			rt_log( "g-tankill: Coordinates too large (%g) for Euclid format\n" , r->ra_p->min_pt[i] );
d194 1
a194 1
			rt_log( "g-tankill: Coordinates too large (%g) for Euclid format\n" , r->ra_p->max_pt[i] );
d294 2
d308 2
d318 1
d370 4
a373 2
						rt_log( "Failed to classify loops in component code %d\n" , tsp->ts_regionid );
						goto outt;
a434 1
	struct rt_vls	fig_file;
a451 5
	the_model = nmg_mm();
	tree_state = rt_initial_tree_state;	/* struct copy */
	tree_state.ts_tol = &tol;
	tree_state.ts_ttol = &ttol;
	tree_state.ts_m = &the_model;
d466 6
d552 1
a552 1
	/* First produce a list of region ident codes */
d576 3
a578 1
rt_log( "Processing id %d\n" , curr_id );
d580 5
a604 1
	nmg_km(the_model);
d609 1
a609 1
	rt_prmem("After complete G-TANKILL conversion");
d631 3
a671 1
		{
a672 1
		}
a673 1
		{
d675 1
a675 2
		}
	
d678 1
d681 2
d688 1
a688 1
		/* Write the region to the TANKILL file */
d691 1
a691 2
		/* NMG region is no longer necessary */
		nmg_kr(r);
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
static char RCSid[] = "$Header$";
d229 1
d250 3
d254 19
a272 1
			if( no_of_holes )
d274 3
d278 1
a278 1
				for( i=0 ; i<no_of_loops ; i++ )
d280 1
a280 1
					if( faces[i].facet_type != 1 )
d282 4
a285 1
					for( j=0 ; j<no_of_loops ; j++ )
d287 3
a289 1
						if( j == i )
d292 4
a295 1
						if( faces[j].facet_type == 1 )
d298 12
a309 4
						if( V3RPP1_IN_RPP2( faces[i].lu->l_p->lg_p->min_pt ,
								    faces[i].lu->l_p->lg_p->max_pt ,
								    faces[j].lu->l_p->lg_p->min_pt ,
								    faces[j].lu->l_p->lg_p->max_pt ) )
d311 2
a312 2
							vect_t diag;
							fastf_t diag_len;
d314 1
a314 1
							if( faces[i].outer_loop == NULL )
d316 5
a320 11
								VSUB2( diag , faces[j].lu->l_p->lg_p->max_pt ,
									      faces[j].lu->l_p->lg_p->min_pt );
								faces[i].diag_len = MAGSQ( diag );
								faces[i].outer_loop = faces[j].lu;
							}
							else
							{
								VSUB2( diag , faces[j].lu->l_p->lg_p->max_pt ,
									      faces[j].lu->l_p->lg_p->min_pt );
								diag_len = MAGSQ( diag );
								if( diag_len < faces[i].diag_len )
d322 5
a326 2
									faces[i].outer_loop = faces[j].lu;
									faces[i].diag_len = diag_len;
d331 15
d392 2
@
