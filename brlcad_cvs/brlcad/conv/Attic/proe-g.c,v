head	11.67;
access;
symbols
	ansi-20040405-merged:11.61.2.3
	postmerge-20040405-ansi:11.65
	premerge-20040404-ansi:11.64
	postmerge-autoconf:11.64
	autoconf-freeze:11.63.6.2
	premerge-autoconf:11.64
	ansi-20040316-freeze:11.61.2.1
	postmerge-20040315-windows:11.64
	premerge-20040315-windows:11.64
	windows-20040315-freeze:11.61.4.1
	autoconf-20031203:11.63
	autoconf-20031202:11.63
	autoconf-branch:11.63.0.6
	phong-branch:11.63.0.4
	photonmap-branch:11.63.0.2
	rel-6-1-DP:11.61
	windows-branch:11.61.0.4
	rel-6-0-2:11.59
	ansi-branch:11.61.0.2
	rel-6-0-1-branch:11.59.0.2
	hartley-6-0-post:11.60
	hartley-6-0-pre:11.59
	rel-6-0-1:11.59
	rel-6-0:11.58
	rel-5-4:11.42.2.2
	offsite-5-3-pre:11.52
	rel-5-3:11.42.2.2
	rel-5-2:11.42
	rel-5-1-branch:11.42.0.2
	rel-5-1:11.42
	rel-5-0:11.35
	rel-5-0-beta:11.28
	rel-4-5:11.18
	ctj-4-5-post:11.18
	ctj-4-5-pre:11.18
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.67
date	2004.05.24.04.16.13;	author morrison;	state dead;
branches;
next	11.66;

11.66
date	2004.05.10.15.30.42;	author erikg;	state Exp;
branches;
next	11.65;

11.65
date	2004.04.05.07.49.36;	author morrison;	state Exp;
branches;
next	11.64;

11.64
date	2004.02.02.17.39.00;	author morrison;	state Exp;
branches;
next	11.63;

11.63
date	2002.11.01.18.03.39;	author jra;	state Exp;
branches
	11.63.6.1;
next	11.62;

11.62
date	2002.11.01.16.22.36;	author jra;	state Exp;
branches;
next	11.61;

11.61
date	2002.08.20.17.07.22;	author jra;	state Exp;
branches
	11.61.2.1
	11.61.4.1;
next	11.60;

11.60
date	2002.08.15.20.54.35;	author hartley;	state Exp;
branches;
next	11.59;

11.59
date	2002.05.17.12.48.56;	author morrison;	state Exp;
branches;
next	11.58;

11.58
date	2001.11.09.13.28.41;	author jra;	state Exp;
branches;
next	11.57;

11.57
date	2001.09.21.17.33.22;	author jra;	state Exp;
branches;
next	11.56;

11.56
date	2001.09.07.18.54.17;	author jra;	state Exp;
branches;
next	11.55;

11.55
date	2001.08.10.21.22.53;	author butler;	state Exp;
branches;
next	11.54;

11.54
date	2001.05.17.20.03.14;	author morrison;	state Exp;
branches;
next	11.53;

11.53
date	2001.03.19.22.19.20;	author butler;	state Exp;
branches;
next	11.52;

11.52
date	2000.10.31.22.35.12;	author mike;	state Exp;
branches;
next	11.51;

11.51
date	2000.10.26.13.19.37;	author jra;	state Exp;
branches;
next	11.50;

11.50
date	2000.09.22.15.56.21;	author jra;	state Exp;
branches;
next	11.49;

11.49
date	2000.09.08.05.55.42;	author mike;	state Exp;
branches;
next	11.48;

11.48
date	2000.08.30.23.28.07;	author mike;	state Exp;
branches;
next	11.47;

11.47
date	2000.08.24.03.26.00;	author mike;	state Exp;
branches;
next	11.46;

11.46
date	2000.08.23.09.53.15;	author mike;	state Exp;
branches;
next	11.45;

11.45
date	2000.07.21.12.44.34;	author jra;	state Exp;
branches;
next	11.44;

11.44
date	2000.07.12.21.59.35;	author mike;	state Exp;
branches;
next	11.43;

11.43
date	2000.07.10.23.53.59;	author mike;	state Exp;
branches;
next	11.42;

11.42
date	2000.05.15.17.18.00;	author jra;	state Exp;
branches
	11.42.2.1;
next	11.41;

11.41
date	2000.05.05.15.38.17;	author jra;	state Exp;
branches;
next	11.40;

11.40
date	2000.05.04.21.12.28;	author jra;	state Exp;
branches;
next	11.39;

11.39
date	2000.03.29.18.10.59;	author mike;	state Exp;
branches;
next	11.38;

11.38
date	2000.03.29.18.07.46;	author mike;	state Exp;
branches;
next	11.37;

11.37
date	99.12.30.18.40.04;	author jra;	state Exp;
branches;
next	11.36;

11.36
date	99.12.29.23.23.03;	author mike;	state Exp;
branches;
next	11.35;

11.35
date	99.08.04.13.56.17;	author jra;	state Exp;
branches;
next	11.34;

11.34
date	99.08.04.13.27.16;	author jra;	state Exp;
branches;
next	11.33;

11.33
date	99.07.29.16.13.27;	author jra;	state Exp;
branches;
next	11.32;

11.32
date	99.07.29.15.53.00;	author jra;	state Exp;
branches;
next	11.31;

11.31
date	99.07.29.15.14.49;	author jra;	state Exp;
branches;
next	11.30;

11.30
date	99.06.07.12.25.06;	author jra;	state Exp;
branches;
next	11.29;

11.29
date	99.06.03.21.54.21;	author mike;	state Exp;
branches;
next	11.28;

11.28
date	99.05.24.20.34.09;	author jra;	state Exp;
branches;
next	11.27;

11.27
date	99.05.24.20.30.20;	author jra;	state Exp;
branches;
next	11.26;

11.26
date	99.05.16.03.37.48;	author jra;	state Exp;
branches;
next	11.25;

11.25
date	99.05.13.18.02.40;	author jra;	state Exp;
branches;
next	11.24;

11.24
date	98.12.31.05.03.30;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	98.11.06.14.42.06;	author jra;	state Exp;
branches;
next	11.22;

11.22
date	98.10.29.14.52.34;	author jra;	state Exp;
branches;
next	11.21;

11.21
date	98.10.28.17.15.22;	author jra;	state Exp;
branches;
next	11.20;

11.20
date	98.07.09.20.11.13;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	98.07.09.14.59.23;	author jra;	state Exp;
branches;
next	11.18;

11.18
date	97.07.11.15.03.34;	author jra;	state Exp;
branches;
next	11.17;

11.17
date	97.05.30.19.11.22;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	97.03.04.21.10.03;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	96.10.28.14.54.21;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	96.10.28.14.17.58;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	96.08.27.07.30.25;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	96.07.12.13.00.38;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	96.02.20.15.31.12;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	96.02.09.17.38.37;	author jra;	state Exp;
branches;
next	11.9;

11.9
date	96.02.02.21.11.50;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	96.02.01.16.07.46;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	95.08.18.15.35.15;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	95.05.11.20.44.59;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	95.05.02.20.59.46;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	95.04.05.19.56.54;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.04.05.13.43.44;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.03.24.20.58.32;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.59.42;	author mike;	state Rel4_4;
branches;
next	1.10;

1.10
date	94.12.08.18.09.15;	author jra;	state Exp;
branches;
next	1.9;

1.9
date	94.12.07.13.46.47;	author jra;	state Exp;
branches;
next	1.8;

1.8
date	94.11.08.16.15.09;	author jra;	state Exp;
branches;
next	1.7;

1.7
date	94.11.01.07.11.28;	author butler;	state Exp;
branches;
next	1.6;

1.6
date	94.11.01.04.18.45;	author butler;	state Exp;
branches;
next	1.5;

1.5
date	94.08.11.00.06.10;	author gdurf;	state Exp;
branches;
next	1.4;

1.4
date	94.08.05.13.56.52;	author jra;	state Exp;
branches;
next	1.3;

1.3
date	94.08.04.09.53.39;	author jra;	state Exp;
branches;
next	1.2;

1.2
date	94.08.02.10.47.44;	author jra;	state Exp;
branches;
next	1.1;

1.1
date	94.07.22.16.56.47;	author jra;	state Exp;
branches;
next	;

11.42.2.1
date	2000.09.22.17.34.54;	author jra;	state Exp;
branches;
next	11.42.2.2;

11.42.2.2
date	2000.10.26.12.44.59;	author jra;	state Exp;
branches;
next	;

11.61.2.1
date	2002.09.19.18.00.37;	author morrison;	state Exp;
branches;
next	11.61.2.2;

11.61.2.2
date	2004.03.17.21.16.01;	author morrison;	state Exp;
branches;
next	11.61.2.3;

11.61.2.3
date	2004.04.02.07.54.06;	author morrison;	state Exp;
branches;
next	;

11.61.4.1
date	2004.03.11.23.40.32;	author morrison;	state Exp;
branches;
next	;

11.63.6.1
date	2004.02.12.19.24.24;	author erikg;	state Exp;
branches;
next	11.63.6.2;

11.63.6.2
date	2004.03.15.14.06.08;	author erikg;	state Exp;
branches;
next	;


desc
@Pro/Engineer to BRL-CAD converter
@


11.67
log
@moved to src/conv/
@
text
@/*
 *		P R O E - G
 *
 * Code to convert ascii output from Pro/Engineer to BRL-CAD
 * The required output is from the Pro/Develop application proe-brl
 * that must be initiated from the "BRL-CAD" option of Pro/Engineer's
 * "EXPORT" menu.  The Pro/develop application may be obtained via
 * anonymous FTP from ftp.brl.mil or via email from "jra@@arl.mil"
 *
 *  Author -
 *	John R. Anderson
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1994-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */

#ifndef lint
static const char RCSid[] = "$Header: /n/xoff/cvs/brlcad/conv/proe-g.c,v 11.66 2004/05/10 15:30:42 erikg Exp $";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <ctype.h>

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "wdb.h"
#include <regex.h>

extern char *optarg;
extern int optind,opterr,optopt;
extern int errno;

static	struct wmember all_head;
static char *input_file;	/* name of the input file */
static char *brlcad_file;	/* name of output file */
static struct bu_vls ret_name;	/* unique name built by Build_unique_name() */
static char *forced_name=NULL;	/* name specified on command line */
static int stl_format=0;	/* Flag, non-zero indocates raw Stereolithography format input */
static int solid_count=0;	/* count of solids converted */
static struct bn_tol tol;	/* Tolerance structure */
static int id_no=1000;		/* Ident numbers */
static int const_id=-1;		/* Constant ident number (assigned to all regions if non-negative) */
static int mat_code=1;		/* default material code */
static int air_no=1;		/* Air numbers */
static int debug=0;		/* Debug flag */
static int cut_count=0;		/* count of assembly cut HAF solids created */
static int do_regex=0;		/* flag to indicate if 'u' option is in effect */
#if 0
static int do_simplify=0;	/* flag to try to simplify solids */
#endif
static regex_t reg_cmp;		/* compiled regular expression */
static char *proe_usage="%s [-darS] [-t tolerance] [-i initial_ident] [-I constant_ident] [-m material_code] [-u reg_exp] [-x rt_debug_flag] proe_file.brl output.g\n\
	where proe_file.brl is the output from Pro/Engineer's BRL-CAD EXPORT option\n\
	and output.g is the name of a BRL-CAD database file to receive the conversion.\n\
	The -d option prints additional debugging information.\n\
	The -i option sets the initial region ident number (default is 1000).\n\
	The -I option sets the non-negative ident number that will be assigned to all regions (conflicts with -i).\n\
	The -m option sets the integer material code for all the parts. (default is 1)\n\
	The -u option indicates that portions of object names that match the regular expression\n\
		'reg_exp' should be ignored.\n\
	The -a option creates BRL-CAD 'air' regions from everything in the model.\n\
	The -r option indicates that the model should not be re-oriented or scaled,\n\
		but left in the same orientation as it was in Pro/E.\n\
		This is to allow conversion of parts to be included in\n\
		previously converted Pro/E assemblies.\n\
	The -S option indicates that the input file is raw STL (STereoLithography) format.\n\
	The -t option specifies the minumim distance between two distinct vertices (mm).\n\
	The -x option specifies an RT debug flags (see cad/librt/debug.h).\n";
static char *stl_usage="%s [-da] [-t tolerance] [-N forced_name] [-i initial_ident] [-I constant_ident] [-m material_code] [-c units_str] [-u reg_exp] [-x rt_debug_flag] input.stl output.g\n\
	where input.stl is a STereoLithography file\n\
	and output.g is the name of a BRL-CAD database file to receive the conversion.\n\
	The -c option specifies the units used in the STL file (units_str may be \"in\", \"ft\",... default is \"mm\"\n\
	The -N option specifies a name to use for the object.\n\
	The -d option prints additional debugging information.\n\
	The -i option sets the initial region ident number (default is 1000).\n\
	The -I option sets the ident number that will be assigned to all regions (conflicts with -i).\n\
	The -m option sets the integer material code for all the parts (default is 1).\n\
	The -u option indicates that portions of object names that match the regular expression\n\
		'reg_exp' should be ignored.\n\
	The -a option creates BRL-CAD 'air' regions from everything in the model.\n\
	The -t option specifies the minumim distance between two distinct vertices (mm).\n\
	The -x option specifies an RT debug flags (see cad/librt/debug.h).\n";
static char *usage;
static FILE *fd_in;		/* input file (from Pro/E) */
static struct rt_wdb *fd_out;	/* Resulting BRL-CAD file */
static struct bu_ptbl null_parts; /* Table of NULL solids */
static float conv_factor=1.0;	/* conversion factor from model units to mm */
static int top_level=1;		/* flag to catch top level assembly or part */
static mat_t re_orient;		/* rotation matrix to put model in BRL-CAD orientation
				 * (+x towards front +z is up ) */
static int do_air=0;		/* When set, all regions are BRL-CAD "air" regions */
static int do_reorient=1;	/* When set, reorient entire model to BRL-CAD style */
static unsigned int obj_count=0; /* Count of parts converted for "stl-g" conversions */
static int *bot_faces=NULL;	 /* array of ints (indices into vert_tree_root->the_array array) three per face */
static int bot_fsize=0;		/* current size of the bot_faces array */
static int bot_fcurr=0;		/* current bot face */
static struct vert_root *vert_tree_root;	/* binary search tree for vertices */

/* Size of blocks of faces to malloc */
#define BOT_FBLOCK	128

struct render_verts
{
	point_t pt;
	struct vertex *v;
};

struct name_conv_list
{
	char *brlcad_name;
	char *solid_name;
	char *name;
	unsigned int obj;
	int solid_use_no;
	int comb_use_no;
	struct name_conv_list *next;
} *name_root=(struct name_conv_list *)NULL;

struct ptc_plane
{
	double  e1[3], e2[3], e3[3], origin[3];
};

struct ptc_cylinder
{
	double  e1[3], e2[3], e3[3], origin[3];
	double  radius;
};

union ptc_surf
{
	struct ptc_plane plane;
	struct ptc_cylinder cylinder;
};

struct ptc_surf_list
{
	struct bu_list	l;
	int type;
	union ptc_surf	surf;
} *surf_root=(struct ptc_surf_list *)NULL;

/* for type in struct ptc_plane and struct ptc_cylinder */
#define	SURF_PLANE	1
#define	SURF_CYLINDER	2

#define	MAX_LINE_LEN	512

#define	UNKNOWN_TYPE	0
#define	ASSEMBLY_TYPE	1
#define	PART_TYPE	2
#define	CUT_SOLID_TYPE	3

char *
Build_unique_name(char *name)
{
	struct name_conv_list *ptr;
	int name_len;
	int tries=0;

	name_len = strlen( name );
	bu_vls_strcpy( &ret_name, name );
	ptr = name_root;
	while( ptr )
	{
		if( !strcmp( bu_vls_addr( &ret_name ) , ptr->brlcad_name ) ||
		    (ptr->solid_name && !strcmp( bu_vls_addr( &ret_name ) , ptr->solid_name ) ) )
		{
			/* this name already exists, build a new one */
			++tries;
			bu_vls_trunc( &ret_name, name_len );
			bu_vls_printf( &ret_name, "_%d", tries );

			ptr = name_root;
		}

		ptr = ptr->next;
	}

	return( bu_vls_addr( &ret_name ) );
}

static struct name_conv_list *
Add_new_name(char *name, unsigned int obj, int type)
{
	struct name_conv_list *ptr;

	if( debug )
		bu_log( "Add_new_name( %s, x%x, %d )\n", name, obj, type );

	if( type != ASSEMBLY_TYPE && type != PART_TYPE && type != CUT_SOLID_TYPE )
	{
		bu_log( "Bad type for name (%s) in Add_new_name\n", name );
		rt_bomb( "Add_new_name\n" );
	}


	/* Add a new name */
	ptr = (struct name_conv_list *)bu_calloc( 1, sizeof( struct name_conv_list ) , "Add_new_name: prev->next" );
	ptr->next = (struct name_conv_list *)NULL;
	ptr->brlcad_name = bu_strdup( name );
	ptr->obj = obj;
	if( do_regex && type != CUT_SOLID_TYPE )
	{
		regmatch_t pmatch;

		if( regexec( &reg_cmp, ptr->brlcad_name, 1, &pmatch, 0  ) == 0 )
		{
			/* got a match */
			strcpy( &ptr->brlcad_name[pmatch.rm_so], &ptr->brlcad_name[pmatch.rm_eo] );
		}
		if( debug )
			bu_log( "\tafter reg_ex, name is %s\n", ptr->brlcad_name );
	}
	else if( type == CUT_SOLID_TYPE ) {
		bu_free( (char *)ptr->brlcad_name, "brlcad_name" );
		ptr->brlcad_name = NULL;
	}
	ptr->solid_use_no = 0;
	ptr->comb_use_no = 0;

	if( type != CUT_SOLID_TYPE )
	{
		/* make sure brlcad_name is unique */
		char *tmp;

		tmp = ptr->brlcad_name;
		ptr->brlcad_name = bu_strdup( Build_unique_name( ptr->brlcad_name ) );
		bu_free( (char *)tmp, "brlcad_name" );
	}

	if( type == ASSEMBLY_TYPE )
	{
		ptr->solid_name = NULL;
		return( ptr );
	}
	else if( type == PART_TYPE )
	{
		struct bu_vls vls;

		bu_vls_init( &vls );

		bu_vls_strcpy( &vls , "s." );
		bu_vls_strcat( &vls, ptr->brlcad_name );

		ptr->solid_name = bu_vls_strgrab( &vls );
	}
	else
	{
		struct bu_vls vls;

		bu_vls_init( &vls );

		bu_vls_strcpy( &vls , "s." );
		bu_vls_strcat( &vls, ptr->brlcad_name );

		ptr->solid_name = bu_vls_strgrab( &vls );
	}

	/* make sure solid name is unique */
	ptr->solid_name = bu_strdup( Build_unique_name( ptr->solid_name ) );
	return( ptr );
}

static char *
Get_unique_name(char *name, unsigned int obj, int type)
{
	struct name_conv_list *ptr,*prev;

	if( name_root == (struct name_conv_list *)NULL )
	{
		/* start new list */
		name_root = Add_new_name( name , obj , type );
		ptr = name_root;
	}
	else
	{
		int found=0;

		prev = (struct name_conv_list *)NULL;
		ptr = name_root;
		while( ptr && !found )
		{
			if( obj == ptr->obj )
				found = 1;
			else
			{
				prev = ptr;
				ptr = ptr->next;
			}
		}

		if( !found )
		{
			prev->next = Add_new_name( name , obj , type );
			ptr = prev->next;
		}
	}

	return( ptr->brlcad_name );
}

static char *
Get_solid_name(char *name, unsigned int obj)
{
	struct name_conv_list *ptr;

	ptr = name_root;

	while( ptr && obj != ptr->obj )
		ptr = ptr->next;

	if( !ptr )
		ptr = Add_new_name( name , 0 , PART_TYPE );

	return( ptr->solid_name );
}

static void
Convert_assy(char *line)
{
	struct wmember head;
	struct wmember *wmem = NULL;
	char line1[MAX_LINE_LEN];
	char name[80];
	unsigned int obj;
	char memb_name[80];
	unsigned int memb_obj;
	char *brlcad_name = NULL;
	float mat_col[4];
	float junk;
	int start;
	int i;

	if( RT_G_DEBUG & DEBUG_MEM_FULL )
	{
		bu_log( "Barrier check at start of Convert_assy:\n" );
		if( bu_mem_barriercheck() )
			rt_bomb( "Barrier check failed!!!\n" );
	}

	BU_LIST_INIT( &head.l );

	start = (-1);
	/* skip leading blanks */
	while( isspace( line[++start] ) && line[start] != '\0' );
	if( strncmp( &line[start] , "assembly" , 8 ) && strncmp( &line[start] , "ASSEMBLY" , 8 ) )
	{
		bu_log( "PROE-G: Convert_assy called for non-assembly:\n%s\n" , line );
		return;
	}

	/* skip blanks before name */
	start += 7;
	while( isspace( line[++start] ) && line[start] != '\0' );

	/* get name */
	i = (-1);
	start--;
	while( !isspace( line[++start] ) && line[start] != '\0' && line[start] != '\n' )
		name[++i] = line[start];
	name[++i] = '\0';

	/* get object pointer */
	sscanf( &line[start] , "%x %f" , &obj, &junk );

	bu_log( "Converting Assembly: %s\n" , name );

	if( debug )
		bu_log( "Convert_assy: %s x%x\n" , name , obj );

	while( fgets( line1, MAX_LINE_LEN, fd_in ) )
	{
		/* skip leading blanks */
		start = (-1);
		while( isspace( line1[++start] ) && line[start] != '\0' );

		if( !strncmp( &line1[start] , "endassembly" , 11 ) || !strncmp( &line1[start] , "ENDASSEMBLY" , 11 ) )
		{

			brlcad_name = Get_unique_name( name , obj , ASSEMBLY_TYPE );
			if( debug )
			{
				struct wmember *wp;

				bu_log( "\tmake assembly ( %s)\n" , brlcad_name );
				for( BU_LIST_FOR( wp, wmember, &head.l ) )
					bu_log( "\t%c %s\n", wp->wm_op, wp->wm_name );
			}
			else
				bu_log( "\tUsing name: %s\n", brlcad_name );

			mk_lcomb( fd_out , brlcad_name , &head , 0 ,
			(char *)NULL , (char *)NULL , (unsigned char *)NULL , 0 );
			break;
		}
		else if( !strncmp( &line1[start] , "member" , 6 ) || !strncmp( &line1[start] , "MEMBER" , 6 ) )
		{
			start += 5;
			while( isspace( line1[++start] ) && line1[start] != '\0' );
			i = (-1);
			start--;
			while( !isspace( line1[++start] ) && line1[start] != '\0' && line1[start] != '\n' )
				memb_name[++i] = line1[start];
			memb_name[++i] = '\0';


			sscanf( &line1[start] , "%x" , &memb_obj );

			brlcad_name = Get_unique_name( memb_name , memb_obj , PART_TYPE );
			if( debug )
				bu_log( "\tmember (%s)\n" , brlcad_name );
			wmem = mk_addmember( brlcad_name , &head.l , NULL, WMOP_UNION );
		}
		else if( !strncmp( &line1[start] , "matrix" , 6 ) || !strncmp( &line1[start] , "MATRIX" , 6 ) )
		{
			int i,j;
			double scale,inv_scale;

			for( j=0 ; j<4 ; j++ )
			{
				fgets( line1, MAX_LINE_LEN, fd_in );
				sscanf( line1 , "%f %f %f %f" , &mat_col[0] , &mat_col[1] , &mat_col[2] , &mat_col[3] );
				for( i=0 ; i<4 ; i++ )
					wmem->wm_mat[4*i+j] = mat_col[i];
			}

			/* convert this matrix to seperate scale factor into element #15 */
/*			scale = MAGNITUDE( &wmem->wm_mat[0] ); */
			scale = pow( bn_mat_det3( wmem->wm_mat ), 1.0/3.0 );
			if( debug )
			{
				bn_mat_print( brlcad_name, wmem->wm_mat );
				bu_log( "\tscale = %g, conv_factor = %g\n", scale, conv_factor );
			}
			if( scale != 1.0 )
			{
				inv_scale = 1.0/scale;
				for( j=0 ; j<3 ; j++ )
					HSCALE( &wmem->wm_mat[j*4], &wmem->wm_mat[j*4], inv_scale )

				/* clamp rotation elements to fabs(1.0) */
				for( j=0 ; j<3 ; j++ )
				{
					for( i=0 ; i<3 ; i++ )
					{
						if( wmem->wm_mat[j*4 + i] > 1.0 )
							wmem->wm_mat[j*4 + i] = 1.0;
						else if( wmem->wm_mat[j*4 + i] < -1.0 )
							wmem->wm_mat[j*4 + i] = -1.0;
					}
				}

				if( top_level)
					wmem->wm_mat[15] *= (inv_scale/conv_factor);
				else
					wmem->wm_mat[15] *= inv_scale;
			}
			else if( top_level )
				wmem->wm_mat[15] /= conv_factor;

			if( top_level && do_reorient )
			{
				/* apply re_orient transformation here */
				if( debug )
				{
					bu_log( "Applying re-orient matrix to member %s\n", brlcad_name );
					bn_mat_print( "re-orient matrix", re_orient );
				}
				bn_mat_mul2( re_orient, wmem->wm_mat );
			}
			if( debug )
				bn_mat_print( "final matrix", wmem->wm_mat );
		}
		else
		{
			bu_log( "Unrecognized line in assembly (%s)\n%s\n" , name , line1 );
		}
	}

	if( RT_G_DEBUG & DEBUG_MEM_FULL )
	{
		bu_log( "Barrier check at end of Convet_assy:\n" );
		if( bu_mem_barriercheck() )
			rt_bomb( "Barrier check failed!!!\n" );
	}

	top_level = 0;

}

static void
do_modifiers(char *line1, int *start, struct wmember *head, char *name, fastf_t *min, fastf_t *max)
{
	struct wmember *wmem;
	int i;

	while( strncmp( &line1[*start], "endmodifiers", 12 ) && strncmp( &line1[*start], "ENDMODIFIERS", 12 ) )
	{
		if( !strncmp( &line1[*start], "plane", 5 ) || !strncmp( &line1[*start], "PLANE", 5 ) )
		{
			struct name_conv_list *ptr;
			char haf_name[80];
			fastf_t dist;
			fastf_t tmp_dist;
			point_t origin;
			plane_t plane;
			vect_t e1,e2;
			double u_min,u_max,v_min,v_max;
			double x,y,z;
			int orient;
			point_t arb_pt[8];
			point_t rpp_corner;

			fgets( line1, MAX_LINE_LEN, fd_in );
			sscanf( line1, "%lf %lf %lf", &x, &y, &z );
			VSET( origin, x, y, z );
			fgets( line1, MAX_LINE_LEN, fd_in );
			sscanf( line1, "%lf %lf %lf", &x, &y, &z );
			VSET( e1, x, y, z );
			fgets( line1, MAX_LINE_LEN, fd_in );
			sscanf( line1, "%lf %lf %lf", &x, &y, &z );
			VSET( e2, x, y, z );
			fgets( line1, MAX_LINE_LEN, fd_in );
			sscanf( line1, "%lf %lf %lf", &x, &y, &z );
			VSET( plane, x, y, z );
			fgets( line1, MAX_LINE_LEN, fd_in );
			sscanf( line1, "%lf %lf", &u_min, &v_min );
			fgets( line1, MAX_LINE_LEN, fd_in );
			sscanf( line1, "%lf %lf", &u_max, &v_max );
			fgets( line1, MAX_LINE_LEN, fd_in );
			sscanf( line1, "%d", &orient );

			plane[H] = VDOT( plane, origin );

			VJOIN2( arb_pt[0], origin, u_min, e1, v_min, e2 );
			VJOIN2( arb_pt[1], origin, u_max, e1, v_min, e2 );
			VJOIN2( arb_pt[2], origin, u_max, e1, v_max, e2 );
			VJOIN2( arb_pt[3], origin, u_min, e1, v_max, e2 );

			/* find max distance to corner of enclosing RPP */
			dist = 0.0;
			VSET( rpp_corner, min[X], min[Y], min[Z] );
			tmp_dist = DIST_PT_PLANE( rpp_corner, plane ) * (fastf_t)orient;
			if( tmp_dist > dist )
				dist = tmp_dist;

			VSET( rpp_corner, min[X], min[Y], max[Z] );
			tmp_dist = DIST_PT_PLANE( rpp_corner, plane ) * (fastf_t)orient;
			if( tmp_dist > dist )
				dist = tmp_dist;

			VSET( rpp_corner, min[X], max[Y], min[Z] );
			tmp_dist = DIST_PT_PLANE( rpp_corner, plane ) * (fastf_t)orient;
			if( tmp_dist > dist )
				dist = tmp_dist;

			VSET( rpp_corner, min[X], max[Y], max[Z] );
			tmp_dist = DIST_PT_PLANE( rpp_corner, plane ) * (fastf_t)orient;
			if( tmp_dist > dist )
				dist = tmp_dist;

			VSET( rpp_corner, max[X], min[Y], min[Z] );
			tmp_dist = DIST_PT_PLANE( rpp_corner, plane ) * (fastf_t)orient;
			if( tmp_dist > dist )
				dist = tmp_dist;

			VSET( rpp_corner, max[X], min[Y], max[Z] );
			tmp_dist = DIST_PT_PLANE( rpp_corner, plane ) * (fastf_t)orient;
			if( tmp_dist > dist )
				dist = tmp_dist;

			VSET( rpp_corner, max[X], max[Y], min[Z] );
			tmp_dist = DIST_PT_PLANE( rpp_corner, plane ) * (fastf_t)orient;
			if( tmp_dist > dist )
				dist = tmp_dist;

			VSET( rpp_corner, max[X], max[Y], max[Z] );
			tmp_dist = DIST_PT_PLANE( rpp_corner, plane ) * (fastf_t)orient;
			if( tmp_dist > dist )
				dist = tmp_dist;

			for( i=0 ; i<4 ; i++ )
			{
				VJOIN1( arb_pt[i+4], arb_pt[i], dist*(fastf_t)orient, plane );
			}

			if( top_level )
			{
				for( i=0 ; i<8 ; i++ )
					VSCALE( arb_pt[i], arb_pt[i], conv_factor )
			}

			cut_count++;

			sprintf( haf_name, "cut.%d", cut_count );
			ptr = Add_new_name( haf_name, 0, CUT_SOLID_TYPE );
			if( mk_arb8( fd_out, ptr->solid_name, (fastf_t *)arb_pt ) )
				bu_log( "Failed to create ARB8 solid for Assembly cut in part %s\n", name );
			else
			{
				/* Add this cut to the region */
				wmem = mk_addmember( ptr->solid_name, &(head->l), NULL, 
						WMOP_SUBTRACT );

				if( top_level && do_reorient )
				{
					/* apply re_orient transformation here */
					if( debug )
					{
						bu_log( "Applying re-orient matrix to solid %s\n", ptr->solid_name );
						bn_mat_print( "re-orient matrix", re_orient );
					}
					bn_mat_mul2( re_orient, wmem->wm_mat );
				}
				
			}
		}
		fgets( line1, MAX_LINE_LEN, fd_in );
		(*start) = (-1);
		while( isspace( line1[++(*start)] ) );
	}
}

void
Add_face(int *face)
{
	if( !bot_faces )
	{
		bot_faces = (int *)bu_malloc( 3 * BOT_FBLOCK * sizeof( int ), "bot_faces" );
		bot_fsize = BOT_FBLOCK;
		bot_fcurr = 0;
	}
	else if( bot_fcurr >= bot_fsize )
	{
		bot_fsize += BOT_FBLOCK;
		bot_faces = (int *)bu_realloc( (void *)bot_faces, 3 * bot_fsize * sizeof( int ), "bot_faces increase" );
	}

	VMOVE( &bot_faces[3*bot_fcurr], face );
	bot_fcurr++;
}

static void
Convert_part(char *line)
{
	char line1[MAX_LINE_LEN];
	char name[MAX_LINE_LEN + 1];
	unsigned int obj=0;
	char *solid_name;
	int start;
	int i;
	int face_count=0;
	int degenerate_count=0;
	int small_count=0;
	float colr[3]={0.5, 0.5, 0.5};
	unsigned char color[3]={ 128, 128, 128 };
	char *brlcad_name;
	struct wmember head;
	struct wmember *wmem;
	vect_t normal={0,0,0};
	int solid_in_region=0;
	point_t part_max,part_min;	/* Part RPP */

	if( RT_G_DEBUG & DEBUG_MEM_FULL )
		bu_prmem( "At start of Conv_prt():\n" );

	if( RT_G_DEBUG & DEBUG_MEM_FULL )
	{
		bu_log( "Barrier check at start of Convet_part:\n" );
		if( bu_mem_barriercheck() )
			rt_bomb( "Barrier check failed!!!\n" );
	}


	bot_fcurr = 0;
	BU_LIST_INIT( &head.l );
	VSETALL( part_min, MAX_FASTF );
	VSETALL( part_max, -MAX_FASTF );

	clean_vert_tree( vert_tree_root );

	start = (-1);
	/* skip leading blanks */
	while( isspace( line[++start] ) && line[start] != '\0' );
	if( strncmp( &line[start] , "solid" , 5 ) && strncmp( &line[start] , "SOLID" , 5 ) )
	{
		bu_log( "Convert_part: Called for non-part\n%s\n" , line );
		return;
	}

	/* skip blanks before name */
	start += 4;
	while( isspace( line[++start] ) && line[start] != '\0' );

	if( line[start] != '\0' )
	{
		/* get name */
		i = (-1);
		start--;
		while( !isspace( line[++start] ) && line[start] != '\0' && line[start] != '\n' )
			name[++i] = line[start];
		name[++i] = '\0';

		/* get object id */
		sscanf( &line[start] , "%x" , &obj );
	}
	else if( stl_format && forced_name )
		strcpy( name, forced_name );
	else if( stl_format ) /* build a name from the file name */
	{
		char tmp_str[512];
		char *ptr;
		int len, suff_len;

		obj_count++;
		obj = obj_count;

		/* copy the file name into our work space */
		strncpy( tmp_str, input_file, 512 );
		tmp_str[511] = '\0';

		/* eliminate a trailing ".stl" */
		len = strlen( tmp_str );
		if( len > 4 )
		{
			if( !strncmp( &tmp_str[len-4], ".stl", 4 ) )
				tmp_str[len-4] = '\0';
		}

		/* skip over all characters prior to the last '/' */
		ptr = strrchr( tmp_str, '/' );
		if( !ptr )
			ptr = tmp_str;
		else
			ptr++;

		/* now copy what is left to the name */
		strncpy( name, ptr, MAX_LINE_LEN );
		name[MAX_LINE_LEN] = '\0';
		sprintf( tmp_str, "_%d", obj_count );
		len = strlen( name );
		suff_len = strlen( tmp_str );
		if( len + suff_len < MAX_LINE_LEN )
			strcat( name, tmp_str );
		else
			sprintf( &name[MAX_LINE_LEN-suff_len-1], tmp_str );
	}
	else
		strcpy( name, "noname" );

	bu_log( "Converting Part: %s\n" , name );

	if( debug )
		bu_log( "Conv_part %s x%x\n" , name , obj );

	solid_count++;
	solid_name = Get_solid_name( name , obj );

	bu_log( "\tUsing solid name: %s\n" , solid_name );

	if( RT_G_DEBUG & DEBUG_MEM || RT_G_DEBUG & DEBUG_MEM_FULL )
		bu_prmem( "At start of Convert_part()" );

	while( fgets( line1, MAX_LINE_LEN, fd_in ) != NULL )
	{
		start = (-1);
		while( isspace( line1[++start] ) );
		if( !strncmp( &line1[start] , "endsolid" , 8 ) || !strncmp( &line1[start] , "ENDSOLID" , 8 ) )
			break;
		else if( !strncmp( &line1[start] , "color" , 5 ) || !strncmp( &line1[start] , "COLOR" , 5 ) )
		{
			sscanf( &line1[start+5] , "%f%f%f" , &colr[0] , &colr[1] , &colr[2] );
			for( i=0 ; i<3 ; i++ )
				color[i] = (int)(colr[i] * 255.0);
		}
		else if( !strncmp( &line1[start] , "normal" , 6 ) || !strncmp( &line1[start] , "NORMAL" , 6 ) )
		{
			float x,y,z;

			start += 6;
			sscanf( &line1[start] , "%f%f%f" , &x , &y , &z );
			VSET( normal , x , y , z );
		}
		else if( !strncmp( &line1[start] , "facet" , 5 ) || !strncmp( &line1[start] , "FACET" , 5 ) )
		{
			VSET( normal , 0.0 , 0.0 , 0.0 );

			start += 4;
			while( line1[++start] && isspace( line1[start] ) );

			if( line1[start] )
			{
				if( !strncmp( &line1[start] , "normal" , 6 ) || !strncmp( &line1[start] , "NORMAL" , 6 ) )
				{
					float x,y,z;

					start += 6;
					sscanf( &line1[start] , "%f%f%f" , &x , &y , &z );
					VSET( normal , x , y , z );
				}
			}
		}
		else if( !strncmp( &line1[start] , "outer loop" , 10 ) || !strncmp( &line1[start] , "OUTER LOOP" , 10 ) )
		{
			int endloop=0;
			int vert_no=0;
			int tmp_face[3];

			while( !endloop )
			{
				if( fgets( line1, MAX_LINE_LEN, fd_in ) == NULL )
					bu_bomb( "Unexpected EOF while reading a loop in a part!!!\n" );
				
				start = (-1);
				while( isspace( line1[++start] ) );

				if( !strncmp( &line1[start] , "endloop" , 7 ) || !strncmp( &line1[start] , "ENDLOOP" , 7 ) )
					endloop = 1;
				else if ( !strncmp( &line1[start] , "vertex" , 6 ) || !strncmp( &line1[start] , "VERTEX" , 6 ) )
				{
					double x,y,z;

					sscanf( &line1[start+6] , "%lf%lf%lf" , &x , &y , &z );
					if( top_level )
					{
						x *= conv_factor;
						y *= conv_factor;
						z *= conv_factor;
					}

					if( vert_no > 2 )
					{
						int n;

						bu_log( "Non-triangular loop:\n" );
						for( n=0 ; n<3 ; n++ )
							bu_log( "\t( %g %g %g )\n", V3ARGS( &vert_tree_root->the_array[tmp_face[n]] ) );

						bu_log( "\t( %g %g %g )\n", x, y, z );
					}
					tmp_face[vert_no++] = Add_vert( x, y, z, vert_tree_root, tol.dist_sq );
					VMINMAX( part_min, part_max, &vert_tree_root->the_array[tmp_face[vert_no-1]*3] );
				}
				else
					bu_log( "Unrecognized line: %s\n", line1 );
			}

			/* check for degenerate faces */
			if( tmp_face[0] == tmp_face[1] )
			{
				degenerate_count++;
				continue;
			}

			if( tmp_face[0] == tmp_face[2] )
			{
				degenerate_count++;
				continue;
			}

			if( tmp_face[1] == tmp_face[2] )
			{
				degenerate_count++;
				continue;
			}

			if( debug )
			{
				int n;

				bu_log( "Making Face:\n" );
				for( n=0 ; n<3; n++ )
					bu_log( "\tvertex #%d: ( %g %g %g )\n", tmp_face[n], V3ARGS( &vert_tree_root->the_array[3*tmp_face[n]] ) );
				VPRINT(" normal", normal);
			}

			Add_face( tmp_face );
			face_count++;
		}
		else if( !strncmp( &line1[start], "modifiers", 9 ) || !strncmp( &line1[start], "MODIFIERS", 9 ) )
		{
			if( face_count )
			{
				wmem = mk_addmember( solid_name , &head.l , NULL, WMOP_UNION );
				if( top_level && do_reorient )
				{
					/* apply re_orient transformation here */
					if( debug )
					{
						bu_log( "Applying re-orient matrix to solid %s\n", solid_name );
						bn_mat_print( "re-orient matrix", re_orient );
					}
					bn_mat_mul2( re_orient, wmem->wm_mat );
				}
				solid_in_region = 1;
			}
			do_modifiers( line1, &start, &head, name, part_min, part_max );
		}
	}

	/* Check if this part has any solid parts */
	if( face_count == 0 )
	{
		char *save_name;

		bu_log( "\t%s has no solid parts, ignoring\n" , name );
		if( degenerate_count )
			bu_log( "\t%d faces were degenerate\n", degenerate_count );
		if( small_count )
			bu_log( "\t%d faces were too small\n", small_count );
		brlcad_name = Get_unique_name( name , obj , PART_TYPE );
		save_name = bu_strdup( brlcad_name );
		bu_ptbl_ins( &null_parts, (long *)save_name );
		return;
	}
	else
	{
		if( degenerate_count )
			bu_log( "\t%d faces were degenerate\n", degenerate_count );
		if( small_count )
			bu_log( "\t%d faces were too small\n", small_count );
	}

	mk_bot( fd_out, solid_name, RT_BOT_SOLID, RT_BOT_UNORIENTED, 0, vert_tree_root->curr_vert, bot_fcurr,
		vert_tree_root->the_array, bot_faces, NULL, NULL );

	if( face_count && !solid_in_region )
	{
		wmem = mk_addmember( solid_name , &head.l , NULL, WMOP_UNION );
		if( top_level && do_reorient )
		{
			/* apply re_orient transformation here */
			if( debug )
			{
				bu_log( "Applying re-orient matrix to solid %s\n", solid_name );
				bn_mat_print( "re-orient matrix", re_orient );
			}
			bn_mat_mul2( re_orient, wmem->wm_mat );
		}
	}
	brlcad_name = Get_unique_name( name , obj , PART_TYPE );

	if( do_air )
	{
		bu_log( "\tMaking air region (%s)\n" , brlcad_name );

		mk_lrcomb( fd_out, brlcad_name, &head, 1, (char *)NULL, (char *)NULL,
		color, 0, air_no, 0, 100, 0 );
		air_no++;
	}
	else
	{
		bu_log( "\tMaking region (%s)\n" , brlcad_name );

		if( const_id >= 0 )
		{
			mk_lrcomb( fd_out, brlcad_name, &head, 1, (char *)NULL, (char *)NULL,
			color, const_id, 0, mat_code, 100, 0 );
			if( stl_format && face_count )
				(void)mk_addmember( brlcad_name, &all_head.l, NULL, WMOP_UNION );
		}
		else
		{
			mk_lrcomb( fd_out, brlcad_name, &head, 1, (char *)NULL, (char *)NULL,
			color, id_no, 0, mat_code, 100, 0 );
			if( stl_format && face_count )
				(void)mk_addmember( brlcad_name, &all_head.l, NULL, WMOP_UNION );
			id_no++;
		}
	}

	if( RT_G_DEBUG & DEBUG_MEM_FULL )
	{
		bu_log( "Barrier check at end of Convert_part:\n" );
		if( bu_mem_barriercheck() )
			rt_bomb( "Barrier check failed!!!\n" );
	}

	top_level = 0;

	return;
}

static void
Convert_input(void)
{
	char line[ MAX_LINE_LEN ];

	if( !stl_format )
	{
		if( !fgets( line, MAX_LINE_LEN, fd_in ) )
			return;

		sscanf( line, "%f", &conv_factor );
	}

	if( !do_reorient && !stl_format )
		conv_factor = 1.0;

	while( fgets( line, MAX_LINE_LEN, fd_in ) != NULL )
	{
		if( !strncmp( line , "assembly" , 8 ) || !strncmp( line , "ASSEMBLY" , 8 ) )
			Convert_assy( line );
		else if( !strncmp( line , "solid" , 5 ) || !strncmp( line , "SOLID" , 5 ) )
			Convert_part( line );
		else
			bu_log( "Unrecognized line:\n%s\n" , line );
	}
}

static void
Rm_nulls(void)
{
	struct db_i *dbip;
	int i;	

	dbip = fd_out->dbip;

	if( debug || BU_PTBL_END( &null_parts )  )
	{
		bu_log( "Deleting references to the following null parts:\n" );
		for( i=0 ; i<BU_PTBL_END( &null_parts ) ; i++ )
		{
			char *save_name;

			save_name = (char *)BU_PTBL_GET( &null_parts, i );
			bu_log( "\t%s\n" , save_name );
		}
	}

	for( i=0 ; i<RT_DBNHASH ; i++ )
	{
		struct directory *dp;

		for( dp=dbip->dbi_Head[i] ; dp!=DIR_NULL ; dp=dp->d_forw )
		{
			struct rt_tree_array	*tree_list;
			struct rt_db_internal	intern;
			struct rt_comb_internal	*comb;
			int j;
			int node_count,actual_count;
			int changed=0;

			/* skip solids */
			if( dp->d_flags & DIR_SOLID )
				continue;

			/* skip non-geometry */
			if( !(dp->d_flags & ( DIR_SOLID | DIR_COMB ) ) )
				continue;

			if( rt_db_get_internal( &intern, dp, dbip, (matp_t)NULL, &rt_uniresource ) < 1 )
			{
				bu_log( "Cannot get internal form of combination %s\n", dp->d_namep );
				continue;
			}
			comb = (struct rt_comb_internal *)intern.idb_ptr;
			RT_CK_COMB( comb );
			if( comb->tree && db_ck_v4gift_tree( comb->tree ) < 0 )
			{
				db_non_union_push( comb->tree , &rt_uniresource);
				if( db_ck_v4gift_tree( comb->tree ) < 0 )
				{
					bu_log( "Cannot flatten tree (%s) for editing\n", dp->d_namep );
					continue;
				}
			}
			node_count = db_tree_nleaves( comb->tree );
			if( node_count > 0 )
			{
				tree_list = (struct rt_tree_array *)bu_calloc( node_count,
					sizeof( struct rt_tree_array ), "tree list" );
				actual_count = (struct rt_tree_array *)db_flatten_tree( tree_list, comb->tree, OP_UNION, 0, &rt_uniresource ) - tree_list;
				BU_ASSERT_LONG( actual_count, ==, node_count );
			}
			else
			{
				tree_list = (struct rt_tree_array *)NULL;
				actual_count = 0;
			}


			for( j=0; j<actual_count; j++ )
			{
				int k;
				int found=0;

				for( k=0 ; k<BU_PTBL_END( &null_parts ) ; k++ )
				{
					char *save_name;

					save_name = (char *)BU_PTBL_GET( &null_parts, k );
					if( !strcmp( save_name, tree_list[j].tl_tree->tr_l.tl_name ) )
					{
						found = 1;
						break;
					}
				}
				if( found )
				{
					/* This is a NULL part, delete the reference */
/*					if( debug ) */
						bu_log( "Deleting reference to null part (%s) from combination %s\n",
							tree_list[j].tl_tree->tr_l.tl_name, dp->d_namep );

					db_free_tree( tree_list[j].tl_tree , &rt_uniresource);

					for( k=j+1 ; k<actual_count ; k++ )
						tree_list[k-1] = tree_list[k]; /* struct copy */

					actual_count--;
					j--;
					changed = 1;
				}
			}

			if( changed )
			{
				if( actual_count )
					comb->tree = (union tree *)db_mkgift_tree( tree_list, actual_count, &rt_uniresource );
				else
					comb->tree = (union tree *)NULL;

				if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) < 0 )
				{
					bu_log( "Unable to write modified combination '%s' to database\n", dp->d_namep );
					rt_comb_ifree( &intern , &rt_uniresource);
					continue;
				}
			}
			bu_free( (char *)tree_list, "tree_list" );
		}
	}
}

/*
 *			M A I N
 */
int
main(int argc, char **argv)
{
	register int c;

        tol.magic = BN_TOL_MAGIC;

	/* this value selected as a resaonable compromise between eliminating
	 * needed faces and keeping degenerate faces
	 */
        tol.dist = 0.005;	/* default, same as MGED, RT, ... */
        tol.dist_sq = tol.dist * tol.dist;
        tol.perp = 1e-6;
        tol.para = 1 - tol.perp;

	vert_tree_root = create_vert_tree();

	bu_ptbl_init( &null_parts, 64, " &null_parts");
	bu_vls_init( &ret_name );

	forced_name = NULL;

	if( strstr( argv[0], "stl-g" ) )
	{
		/* this code was called as stl-g */
		stl_format = 1;
		do_reorient = 0;
		conv_factor = 1.0;	/* default */
		usage = stl_usage;
	}
	else
		usage = proe_usage;

	if( argc < 2 )
	{
		bu_log( usage, argv[0]);
		exit(1);
	}

	/* Get command line arguments. */
	while ((c = getopt(argc, argv, "St:i:I:m:rsdax:u:N:c:")) != EOF) {
		double tmp;

		switch (c) {
		case 't':	/* tolerance */
			tmp = atof( optarg );
			if( tmp <= 0.0 ) {
				bu_log( "Tolerance must be greater then zero, using default (%g)\n",
					tol.dist );
				break;
			}
			tol.dist = tmp;
			tol.dist_sq = tmp * tmp;
			break;
		case 'c':	/* convert from units */
			conv_factor = bu_units_conversion( optarg );
			if( conv_factor == 0.0 )
			{
				bu_log( "Illegal units: (%s)\n", optarg );
				bu_bomb( "Illegal units!!\n" );
			}
			else
				bu_log( "Converting units from %s to mm (conversion factor is %g)\n", optarg, conv_factor );
			break;
		case 'N':	/* force a name on this object */
			forced_name = optarg;
			break;

		case 'S':	/* raw stl_format format */
			stl_format = 1;
			do_reorient = 0;
			break;
		case 'i':
			id_no = atoi( optarg );
			break;
		case  'I':
			const_id = atoi( optarg );
			if( const_id < 0 )
			{
				bu_log( "Illegal value for '-I' option, must be zero or greater!!!\n" );
				bu_log( usage, argv[0] );
				bu_bomb( "Illegal value for option '-I'\n" );
			}
			break;
		case 'm':
			mat_code = atoi( optarg );
			break;
		case 'd':
			debug = 1;
			break;
		case 'x':
			sscanf( optarg, "%x", (unsigned int *)&rt_g.debug );
			bu_printb( "librt RT_G_DEBUG", RT_G_DEBUG, DEBUG_FORMAT );
			bu_log("\n");
			break;
		case 'u':
			do_regex = 1;
			if( regcomp( &reg_cmp, optarg, 0 ) )
			{
				bu_log( "Bad regular expression (%s)\n", optarg );
				bu_log( usage, argv[0] );
				exit( 1 );
			}
			break;
		case 'a':
			do_air = 1;
			break;
		case 'r':
			do_reorient = 0;
			break;
#if 0
		case 's':
			do_simplify = 1;
			break;
#endif
		default:
			bu_log( usage, argv[0]);
			exit(1);
			break;
		}
	}

	rt_init_resource( &rt_uniresource, 0, NULL );

	input_file = argv[optind];
	if( (fd_in=fopen( input_file, "r")) == NULL )
	{
		bu_log( "Cannot open input file (%s)\n" , input_file );
		perror( argv[0] );
		exit( 1 );
	}
	optind++;
	brlcad_file = argv[optind];
	if( (fd_out=wdb_fopen( brlcad_file)) == NULL )
	{
		bu_log( "Cannot open BRL-CAD file (%s)\n" , brlcad_file );
		perror( argv[0] );
		exit( 1 );
	}

	if( stl_format )
		mk_id_units( fd_out , "Conversion from Stereolithography format" , "mm" );
	else
		mk_id_units( fd_out , "Conversion from Pro/Engineer" , "in" );

	/* Create re-orient matrix */
	bn_mat_angles( re_orient, 0.0, 90.0, 90.0 );

	BU_LIST_INIT( &all_head.l );

	Convert_input();

	if( stl_format )
	{
		/* make a top level group */
		mk_lcomb( fd_out, "all", &all_head, 0, (char *)NULL, (char *)NULL, (unsigned char *)NULL, 0 );
	}

	fclose( fd_in );

	/* Remove references to null parts */
	Rm_nulls();

	wdb_close( fd_out );

	return 0;
}
@


11.66
log
@change conf.h to a wrapped config.h
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header: /cvs/brlcad/conv/proe-g.c,v 11.65 2004/04/05 07:49:36 morrison Exp $";
@


11.65
log
@merge of ansi-6-0-branch into HEAD
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header$";
d31 5
a35 1
#include "conf.h"
@


11.64
log
@update copyright to include span through 2003
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.63 2002/11/01 18:03:39 jra Exp $";
d177 1
a177 2
Build_unique_name( name )
char *name;
d206 1
a206 4
Add_new_name( name , obj , type )
char *name;
unsigned int obj;
int type;
d288 1
a288 4
Get_unique_name( name , obj , type )
char *name;
unsigned int obj;
int type;
d326 1
a326 3
Get_solid_name( name , obj )
char *name;
unsigned int obj;
d342 1
a342 2
Convert_assy( line )
char line[MAX_LINE_LEN];
d515 1
a515 6
do_modifiers( line1, start, head, name, min, max )
char *line1;
int *start;
struct wmember *head;
char *name;
point_t min, max;
d648 1
a648 2
Add_face( face )
int face[3];
d667 1
a667 2
Convert_part( line )
char line[MAX_LINE_LEN];
d1008 1
a1008 1
Convert_input()
d1035 1
a1035 1
Rm_nulls()
d1163 1
a1163 3
main(argc, argv)
int	argc;
char	*argv[];
@


11.63
log
@Add_vert() now requires doubles instead of floats
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1994 by the United States Army
d28 1
a28 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.62 2002/11/01 16:22:36 jra Exp $";
@


11.63.6.1
log
@merge from HEAD
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d28 1
a28 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.64 2004/02/02 17:39:00 morrison Exp $";
@


11.63.6.2
log
@merge from head
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.63.6.1 2004/02/12 19:24:24 erikg Exp $";
@


11.62
log
@Now use libbn binary search trees of vertices
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.61 2002/08/20 17:07:22 jra Exp $";
d861 1
a861 1
					float x,y,z;
d863 1
a863 1
					sscanf( &line1[start+6] , "%f%f%f" , &x , &y , &z );
@


11.61
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.59 2002/05/17 12:48:56 morrison Exp $";
d116 1
a116 4
static fastf_t *bot_verts=NULL;	 /* array of vertices for a bot solid */
static int *bot_faces=NULL;	 /* array of ints (indices into bot_verts array) three per face */
static int bot_vsize=0;		/* current size of the bot_verts array */
static int bot_vcurr=0;		/* current bot vertex */
d119 1
a119 3

/* Size of blocks of vertices to malloc */
#define	BOT_VBLOCK	128
a661 40
int
Add_vert( x, y, z )
fastf_t x, y, z;
{
	int i;
	fastf_t *v;
	point_t new_v;
	vect_t diff;
	fastf_t dist_sq;

	VSET( new_v, x, y, z );

	/* first search for this vertex in list */
	for( i=0 ; i<bot_vcurr ; i++ )
	{
		v = &bot_verts[i*3];
		VSUB2( diff, v, new_v );
		dist_sq = MAGSQ( diff );
		if( dist_sq <= tol.dist_sq )
			return( i );
	}

	/* didn't find it, so add a new vertex to the list */
	if( !bot_verts )
	{
		bot_verts = (fastf_t *)bu_malloc( 3 * BOT_VBLOCK * sizeof( fastf_t ), "bot_verts" );
		bot_vsize = BOT_VBLOCK;
		bot_vcurr = 0;
	}
	else if( bot_vcurr >= bot_vsize )
	{
		/* increase size of vertex array */
		bot_vsize += BOT_VBLOCK;
		bot_verts = (fastf_t *)bu_realloc( (void *)bot_verts, bot_vsize * 3 * sizeof( fastf_t ), "bot_verts increase" );
	}

	VMOVE( &bot_verts[bot_vcurr * 3], new_v );
	return( bot_vcurr++ );
}

a714 1
	bot_vcurr = 0;
d720 2
d877 1
a877 1
							bu_log( "\t( %g %g %g )\n", V3ARGS( &bot_verts[tmp_face[n]] ) );
d881 2
a882 2
					tmp_face[vert_no++] = Add_vert( x, y, z );
					VMINMAX( part_min, part_max, &bot_verts[tmp_face[vert_no-1]*3] );
d913 1
a913 1
					bu_log( "\tvertex #%d: ( %g %g %g )\n", tmp_face[n], V3ARGS( &bot_verts[3*tmp_face[n]] ) );
d964 2
a965 1
	mk_bot( fd_out, solid_name, RT_BOT_SOLID, RT_BOT_UNORIENTED, 0, bot_vcurr, bot_fcurr, bot_verts, bot_faces, NULL, NULL );
d1195 2
@


11.61.4.1
log
@sync to HEAD...
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d28 1
a28 1
static const char RCSid[] = "$Header: /n/cad/c/CVS/brlcad/conv/proe-g.c,v 11.64 2004/02/02 17:39:00 morrison Exp $";
d116 4
a119 1
static int *bot_faces=NULL;	 /* array of ints (indices into vert_tree_root->the_array array) three per face */
d122 3
a124 1
static struct vert_root *vert_tree_root;	/* binary search tree for vertices */
d667 40
d760 1
a765 2
	clean_vert_tree( vert_tree_root );

d905 1
a905 1
					double x,y,z;
d907 1
a907 1
					sscanf( &line1[start+6] , "%lf%lf%lf" , &x , &y , &z );
d921 1
a921 1
							bu_log( "\t( %g %g %g )\n", V3ARGS( &vert_tree_root->the_array[tmp_face[n]] ) );
d925 2
a926 2
					tmp_face[vert_no++] = Add_vert( x, y, z, vert_tree_root, tol.dist_sq );
					VMINMAX( part_min, part_max, &vert_tree_root->the_array[tmp_face[vert_no-1]*3] );
d957 1
a957 1
					bu_log( "\tvertex #%d: ( %g %g %g )\n", tmp_face[n], V3ARGS( &vert_tree_root->the_array[3*tmp_face[n]] ) );
d1008 1
a1008 2
	mk_bot( fd_out, solid_name, RT_BOT_SOLID, RT_BOT_UNORIENTED, 0, vert_tree_root->curr_vert, bot_fcurr,
		vert_tree_root->the_array, bot_faces, NULL, NULL );
a1237 2

	vert_tree_root = create_vert_tree();
@


11.61.2.1
log
@Initial ANSIfication
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.61 2002/08/20 17:07:22 jra Exp $";
d182 2
a183 1
Build_unique_name(char *name)
d212 4
a215 1
Add_new_name(char *name, unsigned int obj, int type)
d297 4
a300 1
Get_unique_name(char *name, unsigned int obj, int type)
d338 3
a340 1
Get_solid_name(char *name, unsigned int obj)
d356 2
a357 1
Convert_assy(char *line)
d530 6
a535 1
do_modifiers(char *line1, int *start, struct wmember *head, char *name, fastf_t *min, fastf_t *max)
d668 2
a669 1
Add_vert(fastf_t x, fastf_t y, fastf_t z)
d708 2
a709 1
Add_face(int *face)
d728 2
a729 1
Convert_part(char *line)
d1068 1
a1068 1
Convert_input(void)
d1095 1
a1095 1
Rm_nulls(void)
d1223 3
a1225 1
main(int argc, char **argv)
@


11.61.2.2
log
@sync branch with HEAD
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d28 1
a28 1
static const char RCSid[] = "$Header$";
d116 4
a119 1
static int *bot_faces=NULL;	 /* array of ints (indices into vert_tree_root->the_array array) three per face */
d122 3
a124 1
static struct vert_root *vert_tree_root;	/* binary search tree for vertices */
d742 1
a747 2
	clean_vert_tree( vert_tree_root );

d887 1
a887 1
					double x,y,z;
d889 1
a889 1
					sscanf( &line1[start+6] , "%lf%lf%lf" , &x , &y , &z );
d903 1
a903 1
							bu_log( "\t( %g %g %g )\n", V3ARGS( &vert_tree_root->the_array[tmp_face[n]] ) );
d907 2
a908 2
					tmp_face[vert_no++] = Add_vert( x, y, z, vert_tree_root, tol.dist_sq );
					VMINMAX( part_min, part_max, &vert_tree_root->the_array[tmp_face[vert_no-1]*3] );
d939 1
a939 1
					bu_log( "\tvertex #%d: ( %g %g %g )\n", tmp_face[n], V3ARGS( &vert_tree_root->the_array[3*tmp_face[n]] ) );
d990 1
a990 2
	mk_bot( fd_out, solid_name, RT_BOT_SOLID, RT_BOT_UNORIENTED, 0, vert_tree_root->curr_vert, bot_fcurr,
		vert_tree_root->the_array, bot_faces, NULL, NULL );
a1217 2

	vert_tree_root = create_vert_tree();
@


11.61.2.3
log
@merge head into branch; code moved to libbn/.
@
text
@d647 38
@


11.60
log
@Converted from K&R to ANSI C - RFH
@
text
@d182 2
a183 1
Build_unique_name(char *name)
d212 4
a215 1
Add_new_name(char *name, unsigned int obj, int type)
d297 4
a300 1
Get_unique_name(char *name, unsigned int obj, int type)
d338 3
a340 1
Get_solid_name(char *name, unsigned int obj)
d356 2
a357 1
Convert_assy(char *line)
d530 6
a535 1
do_modifiers(char *line1, int *start, struct wmember *head, char *name, fastf_t *min, fastf_t *max)
d668 2
a669 1
Add_vert(fastf_t x, fastf_t y, fastf_t z)
d708 2
a709 1
Add_face(int *face)
d728 2
a729 1
Convert_part(char *line)
d1068 1
a1068 1
Convert_input(void)
d1095 1
a1095 1
Rm_nulls(void)
d1223 3
a1225 1
main(int argc, char **argv)
@


11.59
log
@added matrix parameter to mk_addmember()
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.58 2001/11/09 13:28:41 jra Exp $";
d182 1
a182 2
Build_unique_name( name )
char *name;
d211 1
a211 4
Add_new_name( name , obj , type )
char *name;
unsigned int obj;
int type;
d293 1
a293 4
Get_unique_name( name , obj , type )
char *name;
unsigned int obj;
int type;
d331 1
a331 3
Get_solid_name( name , obj )
char *name;
unsigned int obj;
d347 1
a347 2
Convert_assy( line )
char line[MAX_LINE_LEN];
d520 1
a520 6
do_modifiers( line1, start, head, name, min, max )
char *line1;
int *start;
struct wmember *head;
char *name;
point_t min, max;
d653 1
a653 2
Add_vert( x, y, z )
fastf_t x, y, z;
d692 1
a692 2
Add_face( face )
int face[3];
d711 1
a711 2
Convert_part( line )
char line[MAX_LINE_LEN];
d1050 1
a1050 1
Convert_input()
d1077 1
a1077 1
Rm_nulls()
d1205 1
a1205 3
main(argc, argv)
int	argc;
char	*argv[];
@


11.58
log
@Added "-t" option to set tolerance, default tolerance is 0.005
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.57 2001/09/21 17:33:22 jra Exp $";
d450 1
a450 1
			wmem = mk_addmember( brlcad_name , &head.l , WMOP_UNION );
d645 1
a645 1
				wmem = mk_addmember( ptr->solid_name, &(head->l),
d968 1
a968 1
				wmem = mk_addmember( solid_name , &head.l , WMOP_UNION );
d1012 1
a1012 1
		wmem = mk_addmember( solid_name , &head.l , WMOP_UNION );
d1043 1
a1043 1
				(void)mk_addmember( brlcad_name, &all_head.l, WMOP_UNION );
d1050 1
a1050 1
				(void)mk_addmember( brlcad_name, &all_head.l, WMOP_UNION );
@


11.57
log
@Now makes unoriented BOT's (The orientation of Pro/E and STL files has been unreliable)
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.56 2001/09/07 18:54:17 jra Exp $";
d74 1
a74 1
static char *proe_usage="%s [-darS] [-i initial_ident] [-I constant_ident] [-m material_code] [-u reg_exp] [-x rt_debug_flag] proe_file.brl output.g\n\
d89 1
d91 1
a91 1
static char *stl_usage="%s [-da] [-N forced_name] [-i initial_ident] [-I constant_ident] [-m material_code] [-c units_str] [-u reg_exp] [-x rt_debug_flag] input.stl output.g\n\
d103 1
d1234 1
a1234 1
        tol.dist = 0.00001;
d1262 3
a1264 1
	while ((c = getopt(argc, argv, "Si:I:m:rsdax:u:N:c:")) != EOF) {
d1266 10
@


11.56
log
@Now uses unlmited name lengths
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.55 2001/08/10 21:22:53 butler Exp $";
d1006 1
a1006 1
	mk_bot( fd_out, solid_name, RT_BOT_SOLID, RT_BOT_CCW, 0, bot_vcurr, bot_fcurr, bot_verts, bot_faces, NULL, NULL );
@


11.55
log
@Compiler warning patches
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.54 2001/05/17 20:03:14 morrison Exp $";
d49 1
a49 1
#include "regex.h"
a54 3
#define NAME_LENGTH	79
#define NAMESIZE	16	/* from db.h */

d58 2
a59 2
static char ret_name[NAMESIZE]; /* unique name built by Build_unique_name() */
static char forced_name[NAME_LENGTH+1];	/* name specified on command line */
d135 3
a137 3
	char brlcad_name[NAMESIZE];
	char solid_name[NAMESIZE];
	char name[80];
a182 1
	char suff[NAMESIZE];
d184 1
a184 1
	int name_len, suff_len;
d188 1
a188 2
	strncpy( ret_name, name, NAMESIZE );
	ret_name[NAMESIZE-1] = '\0';
d192 2
a193 1
		if( !strncmp( ret_name , ptr->brlcad_name , NAMESIZE ) || !strncmp( ret_name , ptr->solid_name , NAMESIZE ) )
d197 2
a198 18
			sprintf( suff, "_%d", tries );
			suff_len = strlen( suff );
			if( suff_len >= NAMESIZE-1 )
			{
				bu_log( "Cannot build unique name for '%s'\n", name );
				bu_log( "Conversion aborted\n" );
				exit( 1 );
			}
			if( name_len + suff_len < NAMESIZE )
			{
				strcpy( ret_name, name );
				strcat( ret_name, suff );
			}
			else
			{
				strncpy( ret_name, name, NAMESIZE );
				sprintf( &ret_name[NAMESIZE-suff_len-1], "%s", suff );
			}
d206 1
a206 1
	return( ret_name );
a215 2
	char tmp_name[NAMESIZE];
	int suffix_insert;
d230 1
a230 1
	strncpy( ptr->name , name, 80 );
d236 1
a236 1
		if( !regexec( &reg_cmp, ptr->name, 1, &pmatch, 0  ) )
a237 3
			char *c=ptr->brlcad_name;
			int i=(-1);

d239 1
a239 6
			while( ptr->name[++i] )
			{
				if( i < pmatch.rm_so || i >= pmatch.rm_eo )
					*c++ = ptr->name[i];
			}
			*c++ = '\0';
a240 2
		else
			strncpy( ptr->brlcad_name , name , NAMESIZE-2 );
d244 4
a247 5
	else if( type == CUT_SOLID_TYPE )
		ptr->brlcad_name[0] = '\0';
	else
		strncpy( ptr->brlcad_name , name , NAMESIZE-2 );
	ptr->brlcad_name[NAMESIZE-2] = '\0';
d254 5
a258 1
		strncpy( ptr->brlcad_name, Build_unique_name( name ), NAMESIZE );
d263 1
a263 1
		ptr->solid_name[0] = '\0';
d268 8
a275 3
		strcpy( ptr->solid_name , "s." );
		strncpy( &ptr->solid_name[2] , ptr->brlcad_name , NAMESIZE-4 );
		ptr->solid_name[NAMESIZE-1] = '\0';
d279 8
a286 3
		strcpy( ptr->solid_name , "s." );
		strncpy( &ptr->solid_name[2] , name , NAMESIZE-4 );
		ptr->solid_name[NAMESIZE-1] = '\0';
d290 1
a290 6
	suffix_insert = strlen( ptr->solid_name );
	if( suffix_insert > NAMESIZE - 3 )
		suffix_insert = NAMESIZE - 3;

	strncpy( tmp_name, ptr->solid_name, NAMESIZE );
	strncpy( ptr->solid_name, Build_unique_name( ptr->solid_name ), NAMESIZE );
d543 1
a543 1
			char haf_name[NAMESIZE+1];
d730 1
a730 1
	char name[NAME_LENGTH + 1];
d789 1
a789 1
	else if( stl_format && forced_name[0] != '\0' )
d820 2
a821 2
		strncpy( name, ptr, NAMESIZE-1 );
		name[NAMESIZE-1] = '\0';
d825 1
a825 1
		if( len + suff_len < NAMESIZE-3 )
d828 1
a828 1
			sprintf( &name[NAMESIZE-suff_len-4], tmp_str );
a992 1
		save_name = (char *)bu_malloc( NAMESIZE*sizeof( char ), "save_name" );
d994 1
a994 1
		strncpy( save_name, brlcad_name, NAMESIZE );
d1174 1
a1174 1
					if( !strncmp( save_name, tree_list[j].tl_tree->tr_l.tl_name, NAMESIZE ) )
a1199 4
				char name[NAMESIZE+1];

				strncpy( name, dp->d_namep, NAMESIZE );

d1238 1
d1240 1
a1240 1
	forced_name[0] = '\0';
d1273 1
a1273 3
			strncpy( forced_name, optarg, NAME_LENGTH );
			if( strlen( optarg ) > NAME_LENGTH )
				forced_name[NAME_LENGTH] = '\0';
d1305 1
a1305 1
			if( regcomp( &reg_cmp, optarg, REG_BASIC ) )
@


11.54
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.53 2001/03/19 22:19:20 butler Exp $";
d1329 1
a1329 1
			sscanf( optarg, "%x", &rt_g.debug );
@


11.53
log
@patches to merge 5.3 into 6.0
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header: /d/CVS/brlcad/conv/proe-g.c,v 11.52 2000/10/31 22:35:12 mike Exp $";
d394 1
a394 1
	if( rt_g.debug & DEBUG_MEM_FULL )
d540 1
a540 1
	if( rt_g.debug & DEBUG_MEM_FULL )
d771 1
a771 1
	if( rt_g.debug & DEBUG_MEM_FULL )
d774 1
a774 1
	if( rt_g.debug & DEBUG_MEM_FULL )
d867 1
a867 1
	if( rt_g.debug & DEBUG_MEM || rt_g.debug & DEBUG_MEM_FULL )
d1078 1
a1078 1
	if( rt_g.debug & DEBUG_MEM_FULL )
d1330 1
a1330 1
			bu_printb( "librt rt_g.debug", rt_g.debug, DEBUG_FORMAT );
@


11.52
log
@
compiler lint
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.51 2000/10/26 13:19:37 jra Exp $";
a1255 1
        /* XXX These need to be improved */
d1257 4
@


11.51
log
@Now using the dbip from the wdb_fd instead of re-opening the database
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.50 2000/09/22 15:56:21 jra Exp $";
d382 1
a382 1
	struct wmember *wmem;
d388 1
a388 1
	char *brlcad_name;
@


11.50
log
@A VMINMAX call was missing (to get part bounding box).
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.49 2000/09/08 05:55:42 mike Exp $";
a1087 14

#if 0
empty_model:
	{
		char *save_name;

		bu_log( "\t%s is empty, ignoring\n" , name );
		save_name = (char *)bu_malloc( NAMESIZE*sizeof( char ), "save_name" );
		brlcad_name = Get_unique_name( name , obj , PART_TYPE );
		strncpy( save_name, brlcad_name, NAMESIZE );
		bu_ptbl_ins( &null_parts, (long *)save_name );
		return;
	}
#endif
d1123 1
a1123 8
/* XXX you can just use existing fd_out->dbip here. */
	dbip = db_open( brlcad_file, "rw" );
	if( dbip == DBI_NULL )
	{
		bu_log( "Cannot db_open %s\n", brlcad_file );
		bu_log( "References to NULL parts not removed\n" );
		return;
	}
a1136 2
	db_dirbuild( dbip );

d1154 4
a1243 1
	db_close( dbip );
a1393 1
	wdb_close( fd_out );
d1397 3
@


11.49
log
@
Tree routines now need resource structure.
Added rt_init_resource() call.
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.48 2000/08/30 23:28:07 mike Exp $";
d948 1
a948 1

@


11.48
log
@
Eliminated lint complaints.
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.47 2000/08/24 03:26:00 mike Exp $";
d1177 1
a1177 1
			if( rt_db_get_internal( &intern, dp, dbip, (matp_t)NULL ) < 1 )
d1186 1
a1186 1
				db_non_union_push( comb->tree );
d1198 1
a1198 1
				actual_count = (struct rt_tree_array *)db_flatten_tree( tree_list, comb->tree, OP_UNION, 0 ) - tree_list;
d1231 1
a1231 1
					db_free_tree( tree_list[j].tl_tree );
d1249 1
a1249 1
					comb->tree = (union tree *)db_mkgift_tree( tree_list, actual_count, (struct db_tree_state *)NULL );
d1253 1
a1253 1
				if( rt_db_put_internal( dp, dbip, &intern ) < 0 )
d1256 1
a1256 1
					rt_comb_ifree( &intern );
d1376 2
@


11.47
log
@
cvs: ----------------------------------------------------------------------
lint
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.46 2000/08/23 09:53:15 mike Exp $";
d73 1
d75 1
d767 1
a767 1
	vect_t normal;
d980 1
a1244 1
				int flags;
a1246 1
				flags = dp->d_flags;
a1252 16
/* XXX Why delete and re-add, why not just put the new version? */
#if 0
				if( db_delete( dbip, dp ) || db_dirdelete( dbip, dp ) )
				{
					bu_log( "Failed to delete combination (%s)\n", dp->d_namep );
					rt_db_free_internal( &intern );
					continue;
				}
				if( (dp=db_diradd( dbip, name, -1, 0, flags, NULL)) == DIR_NULL )
				{
					bu_log( "Could not add modified '%s' to directory\n", dp->d_namep );
					rt_comb_ifree( &intern );
					continue;
				}
#endif

d1365 1
d1369 1
@


11.46
log
@
db_flatten_tree() got a new argument.
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.45 2000/07/21 12:44:34 jra Exp $";
d470 1
a470 1
			wmem = mk_addmember( brlcad_name , &head , WMOP_UNION );
d665 1
a665 1
				wmem = mk_addmember( ptr->solid_name, head,
a754 1
	int tmp_count;
a766 1
	int solid_is_written=0;
d987 1
a987 1
				wmem = mk_addmember( solid_name , &head , WMOP_UNION );
d1032 1
a1032 1
		wmem = mk_addmember( solid_name , &head , WMOP_UNION );
d1063 1
a1063 1
				(void)mk_addmember( brlcad_name, &all_head, WMOP_UNION );
d1070 1
a1070 1
				(void)mk_addmember( brlcad_name, &all_head, WMOP_UNION );
d1086 1
d1098 1
a1098 1

a1173 1
top:
@


11.45
log
@Replaced db_scan() calls with db_dirbuild()
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.44 2000/07/12 21:59:35 mike Exp $";
d1197 2
a1198 3
				actual_count = (struct rt_tree_array *)db_flatten_tree( tree_list, comb->tree, OP_UNION ) - tree_list;
				if( actual_count > node_count )  bu_bomb("Rm_nulls() array overflow!");
				if( actual_count < node_count )  bu_log("WARNING Rm_nulls() array underflow! %d < %d", actual_count, node_count);
@


11.44
log
@
Converted to use new version of LIBWDB
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.43 2000/07/10 23:53:59 mike Exp $";
d1156 2
a1157 1
	db_scan(dbip, (int (*)())db_diradd, 1, NULL);
@


11.43
log
@
lint
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.42 2000/05/15 17:18:00 jra Exp $";
a48 1
#include "../librt/debug.h"
a63 1
static int polysolid=1;		/* Flag for polysolid output rather than NMG's */
d106 1
a106 1
static FILE *fd_out;		/* Resulting BRL-CAD file */
d1135 1
d1254 2
d1259 1
a1259 1
					rt_comb_ifree( &intern );
d1268 1
d1401 1
a1401 1
	if( (fd_out=fopen( brlcad_file, "w")) == NULL )
d1427 1
a1427 1
	fclose( fd_out );
d1431 1
@


11.42
log
@Fixed bug in solid names and clamped rotation elements to +-1.0
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.41 2000/05/05 15:38:17 jra Exp $";
@


11.42.2.1
log
@Convert_part() was missing a call to VMINMAX to get part bounding box
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.42 2000/05/15 17:18:00 jra Exp $";
d950 1
a950 1
					VMINMAX( part_min, part_max, &bot_verts[tmp_face[vert_no-1]*3] );
@


11.42.2.2
log
@Added a comment about the selected tolerance
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.42.2.1 2000/09/22 17:34:54 jra Exp $";
d1291 1
a1292 4

	/* this value selected as a resaonable compromise between eliminating
	 * needed faces and keeping degenerate faces
	 */
@


11.41
log
@Fixed a bug, removed some unused code
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.40 2000/05/04 21:12:28 jra Exp $";
d250 1
a250 1
	ptr = (struct name_conv_list *)bu_malloc( sizeof( struct name_conv_list ) , "Add_new_name: prev->next" );
d500 12
@


11.40
log
@Converted to produce BOT solids
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.39 2000/03/29 18:10:59 mike Exp $";
d77 1
a77 1
static char *proe_usage="%s [-sdarSn] [-i initial_ident] [-I constant_ident] [-m material_code] [-u reg_exp] [-x rt_debug_flag] [-X nmg_debug_flag] proe_file.brl output.g\n\
a79 1
	The -s option is to simplify the objects to ARB's where possible.\n\
d93 1
a93 1
static char *stl_usage="%s [-dsan] [-N forced_name] [-i initial_ident] [-I constant_ident] [-m material_code] [-c units_str] [-u reg_exp] [-x rt_debug_flag] [-X nmg_debug_flag] input.stl output.g\n\
a97 1
	The -s option is to simplify the objects to ARB's where possible.\n\
a286 37
#if 0
		suffix_insert = strlen( ptr->brlcad_name );
		if( suffix_insert > NAMESIZE - 3 )
			suffix_insert = NAMESIZE - 3;

		strncpy( tmp_name, ptr->brlcad_name, NAMESIZE );
		if( debug )
			bu_log( "\tMaking sure %s is a unique name\n", tmp_name );
		ptr2 = name_root;
		while( ptr2 )
		{
			if( !strncmp( tmp_name , ptr2->brlcad_name , NAMESIZE ) || !strncmp( tmp_name , ptr2->solid_name , NAMESIZE ) )
			{
				if( debug )
					bu_log( "\t\t%s matches existing name (%s or %s)\n", tmp_name, ptr2->brlcad_name, ptr2->solid_name );
				try_char++;
				if( try_char == '[' )
					try_char = 'a';
				if( debug )
					bu_log( "\t\t\ttry_char = %c\n", try_char );
				if( try_char == '{' )
				{
					bu_log( "Too many objects with same name (%s)\n" , ptr->brlcad_name );
					exit(1);
				}

				strncpy( tmp_name, ptr->brlcad_name, NAMESIZE );
				sprintf( &tmp_name[suffix_insert] , "_%c" , try_char );
				if( debug )
					bu_log( "\t\tNew name to try is %s\n", tmp_name );
				ptr2 = name_root;
			}
			else
				ptr2 = ptr2->next;
		}
		strncpy( ptr->brlcad_name, tmp_name, NAMESIZE );
#else
a287 1
#endif
a313 32
#if 0
	ptr2 = name_root;
	try_char = '@@';
	while( ptr2 )
	{
		if( !strncmp( tmp_name , ptr2->brlcad_name , NAMESIZE ) || !strncmp( tmp_name , ptr2->solid_name , NAMESIZE ) )
		{
			if( debug )
				bu_log( "\t\t%s matches existing name (%s or %s)\n", tmp_name, ptr2->brlcad_name, ptr2->solid_name );
			try_char++;
			if( try_char == '[' )
				try_char = 'a';
			if( debug )
				bu_log( "\t\t\ttry_char = %c\n", try_char );
			if( try_char == '{' )
			{
				bu_log( "Too many solids with same name (%s)\n" , ptr->solid_name );
				exit(1);
			}

			strncpy( tmp_name, ptr->solid_name, NAMESIZE );
			sprintf( &tmp_name[suffix_insert] , "_%c" , try_char );
			if( debug )
				bu_log( "\t\tNew name to try is %s\n", tmp_name );
			ptr2 = name_root;
		}
		else
			ptr2 = ptr2->next;
	}

	strncpy( ptr->solid_name, tmp_name, NAMESIZE );
#else
a314 1
#endif
a675 7
#if 0
static int
Unbreak_shell_edges( s_in )
struct shell *s_in;
{
	struct faceuse *fu;
	int count=0;
a676 92
	NMG_CK_SHELL( s_in );

	for( BU_LIST_FOR( fu, faceuse, &s_in->fu_hd ) )
	{
		struct loopuse *lu;

		for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
		{
			struct edgeuse *eu;

			if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
				continue;

			eu = BU_LIST_FIRST( edgeuse, &lu->down_hd );
			while( BU_LIST_NOT_HEAD( &eu->l, &lu->down_hd ))
			{
				struct edgeuse *next_eu, *prev_eu;

				next_eu = BU_LIST_PNEXT( edgeuse, &eu->l );
				prev_eu = BU_LIST_PPREV_CIRC( edgeuse, &eu->l );

				if( prev_eu == next_eu )
					break;

				if( prev_eu->g.magic_p == eu->g.magic_p )
				{
					if( nmg_unbreak_shell_edge_unsafe( prev_eu ) > 0 )
						count++;
				}

				eu = next_eu;
			}
		}
	}
	return( count );
}
void
Check_edge_uses( m )
struct model *m;
{
	struct bu_ptbl edges;
	int i;
	int use_count;
	long bad_count=0;

	if( !m )
		return;

	NMG_CK_MODEL( m );

	bu_ptbl_init( &edges, 64, "edge list" );

	nmg_edge_tabulate( &edges, &m->magic );

	for( i=0 ; i<BU_PTBL_END( &edges ) ; i++ )
	{
		struct edge *e;
		struct edgeuse *eu_start;
		struct edgeuse *eu;

		e = (struct edge *)BU_PTBL_GET( &edges, i );

		use_count = 1;
		eu_start = e->eu_p;
		eu = eu_start->radial_p->eumate_p;
		while( eu != eu_start && eu->eumate_p != eu_start )
		{
			eu = eu->radial_p->eumate_p;
			use_count++;
		}

		if( use_count != 2 )
		{
			struct vertex_g *vg1, *vg2;

			bad_count++;

			vg1 = eu->vu_p->v_p->vg_p;
			vg2 = eu->eumate_p->vu_p->v_p->vg_p;

			bu_log( "\tedge has %d uses (should always be 2!!!)\n", use_count );
			bu_log( "\t\t(%g %g %g) <-> (%g %g %g)\n",
				V3ARGS( vg1->coord ), V3ARGS( vg2->coord ) );
		}
	}

	if( bad_count )
		bu_log( "%d of %d edges had the wrong number of uses\n", bad_count, BU_PTBL_END( &edges ) );

	bu_ptbl_free( &edges );
}
#endif
d690 1
a690 1
	for( i=0 ; i<bot_vsize ; i++ )
a737 9
Make_bot( solid_name )
char *solid_name;
{
	mk_bot( fd_out, solid_name, RT_BOT_SOLID, RT_BOT_CCW, 0, bot_vcurr, bot_fcurr, bot_verts, bot_faces, NULL, NULL );
	bot_vcurr = 0;
	bot_fcurr = 0;
}

static void
d772 2
d969 1
a969 1
					bu_log( "\t( %g %g %g )\n" , V3ARGS( &bot_verts[tmp_face[n]] ) );
d1020 1
a1020 1
	Make_bot( solid_name );
@


11.39
log
@
Changed from Release 4 function names.
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.38 2000/03/29 18:07:46 mike Exp $";
a79 1
	The -n option is to NMG solids rather than polysolids.\n\
d93 1
a93 2
	The -x option specifies an RT debug flags (see cad/librt/debug.h).\n\
	The -X option specifies an NMG debug flag (see cad/h/nmg.h).\n";
a98 1
	The -n option is to NMG solids rather than polysolids.\n\
d107 1
a107 2
	The -x option specifies an RT debug flags (see cad/librt/debug.h).\n\
	The -X option specifies an NMG debug flag (see cad/h/nmg.h).\n";
d119 12
d749 1
a749 1

d848 69
a931 5
	struct model *m;
	struct nmgregion *r;
	struct shell *s;
	struct render_verts verts[3];
	struct vertex   **vts[3];
a956 7
	m = nmg_mm();
	NMG_CK_MODEL( m );
	r = nmg_mrsv( m );
	NMG_CK_REGION( r );
	s = BU_LIST_FIRST( shell , &r->s_hd );
	NMG_CK_SHELL( s );

a962 1
		nmg_km( m );
a1079 2
			struct faceuse *fu;
			fastf_t area;
d1082 1
a1082 3
			struct loopuse *lu;
			struct edgeuse *eu;
			plane_t pl;
d1112 1
a1112 1
							bu_log( "\t( %g %g %g )\n", V3ARGS( verts[n].pt ) );
d1116 1
a1116 3
					VSET( verts[vert_no].pt , x , y , z );
					VMINMAX( part_min, part_max, verts[vert_no].pt );
					vert_no++;
d1124 1
a1124 3
			if( verts[0].pt[X] == verts[1].pt[X] &&
			    verts[0].pt[Y] == verts[1].pt[Y] &&
			    verts[0].pt[Z] == verts[1].pt[Z] )
d1130 1
a1130 3
			if( verts[0].pt[X] == verts[2].pt[X] &&
			    verts[0].pt[Y] == verts[2].pt[Y] &&
			    verts[0].pt[Z] == verts[2].pt[Z] )
d1136 1
a1136 3
			if( verts[1].pt[X] == verts[2].pt[X] &&
			    verts[1].pt[Y] == verts[2].pt[Y] &&
			    verts[1].pt[Z] == verts[2].pt[Z] )
a1141 30
			if( normal[X] != 0.0 || normal[Y] != 0.0 || normal[Z] != 0.0 )
			{
				vect_t v1, v2;

				/* We have some normal info. use it */

				VSUB2( v1, verts[1].pt, verts[0].pt )
				VSUB2( v2, verts[2].pt, verts[0].pt )

				VCROSS( pl, v1, v2 )

				if( VDOT( pl, normal ) < 0.0 )
				{
					point_t tmp;

					VMOVE( tmp, verts[2].pt )
					VMOVE( verts[2].pt, verts[1].pt )
					VMOVE( verts[1].pt, tmp )
				}
				VREVERSE( pl, pl )

				pl[3] = VDOT( pl, verts[0].pt );
			}

			for( i=0 ; i<3 ; i++ )
			{
				verts[i].v = (struct vertex *)NULL;
				vts[i] = &verts[i].v;
			}

d1148 1
a1148 1
					bu_log( "\t( %g %g %g )\n" , V3ARGS( verts[n].pt ) );
d1151 2
a1152 32
			fu = nmg_cmface( s , vts , 3 );

			for( i=0 ; i<3 ; i++ )
				nmg_vertex_gv( verts[i].v , verts[i].pt );

			lu = BU_LIST_FIRST( loopuse , &fu->lu_hd );
			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
				nmg_edge_g( eu );

			area = nmg_loop_plane_area( lu , pl );

			if( area > 0.0 )
			{
				if( normal[X] != 0.0 || normal[Y] != 0.0 || normal[Z] != 0.0 )
				{
					if( VDOT( normal , pl ) < 0.0 )
					{
						HREVERSE( pl , pl );
					}
				}
				nmg_face_g( fu , pl );
				face_count++;
			}
			else
			{
				small_count++;
				bu_log( "Ignoring small face:\n" );
				bu_log( "\t(%g %g %g)\n", V3ARGS( verts[0].pt ) );
				bu_log( "\t(%g %g %g)\n", V3ARGS( verts[1].pt ) );
				bu_log( "\t(%g %g %g)\n", V3ARGS( verts[2].pt ) );
				(void)nmg_kfu( fu );
			}
a1188 1
		nmg_km( m );
d1199 1
a1199 120
	if( !polysolid || ( do_simplify && face_count < 13 ) )
	{
		/* fuse vertices that are within tolerance of each other */
		bu_log( "\tFusing vertices for part\n" );
		(void)nmg_model_vertex_fuse( m , &tol );

		/* Break edges on vertices */
		if( debug )
			bu_log( "\tBreak edges\n" );
		tmp_count = nmg_model_break_e_on_v( m, &tol );
		if( debug )
			bu_log( "\t\t%d edges broken\n", tmp_count );

		/* kill zero length edgeuses */
		if( debug )
			bu_log( "\tKill zero length edges\n" );
		if( nmg_kill_zero_length_edgeuses( m ) )
			goto empty_model;

		/* kill cracks */
		if( debug )
			bu_log( "\tKill cracks\n" );
		if( nmg_kill_cracks( s ) )
		{
			if( nmg_ks( s ) )
				goto empty_model;
		}

		nmg_rebound( m , &tol );

		/* Glue faceuses together (nmg_model_break_e_on_v may have created some edges to fuse). */
		if( debug )
			bu_log( "\tEdge fuse\n" );
		(void)nmg_model_edge_fuse( m, &tol );

		if( debug )
			bu_log( "\tJoin touching loops\n" );
		nmg_s_join_touchingloops( s, &tol );

		/* kill cracks */
		if( debug )
			bu_log( "\tKill cracks\n" );
		r = BU_LIST_FIRST( nmgregion, &m->r_hd );
		if( nmg_kill_cracks( s ) )
		{
			if( nmg_ks( s ) )
				goto empty_model;
		}

		if( debug )
			bu_log( "\tSplit touching loops\n" );
		nmg_s_split_touchingloops( s, &tol);

		/* kill cracks */
		if( debug )
			bu_log( "\tKill cracks\n" );
			
		if( nmg_kill_cracks( s ) )
		{
			if( nmg_ks( s ) )
				goto empty_model;
		}

		/* verify face plane calculations */

#if 1
		nmg_shell_coplanar_face_merge( s , &tol , 0 );

		nmg_simplify_shell( s );

		if( debug )
			bu_log( "\tMake faces within tolerance\n" );
		nmg_make_faces_within_tol( s, &tol );
#endif
		nmg_rebound( m , &tol );

	}
	else

		nmg_rebound( m , &tol );

	if( do_simplify && face_count < 13 )
	{
		struct rt_arb_internal arb_int;

		if( solid_is_written = nmg_to_arb( m, &arb_int ) )
		{
			if( mk_arb8( fd_out, solid_name, (fastf_t *)arb_int.pt ) )
			{
				bu_log( "failed to write ARB8 to database for solid %s\n", solid_name );
				rt_bomb( "failed to write to database" );
			}
			bu_log( "\t%s written as an ARB\n", solid_name );
		}
/*		else if( solid_is_written = nmg_to_tgc( m, &tgc_int, &tol ) )
		{
			if( mk_tgc( fd_out, solid_name, tgc_int.v, tgc_int.h, tgc_int.a,
					tgc_int.b, tgc_int.c, tgc_int.d ) )
			{
				bu_log( "failed to write TGC to database for solid %s\n", solid_name );
				rt_bomb( "failed to write to database" );
			}
			bu_log( "\t%s written as a TGC\n", solid_name );
		} */
	}

	if( polysolid && !solid_is_written )
	{
		Unbreak_shell_edges( s );
		bu_log( "\tWriting polysolid with %d faces\n", face_count );
		write_shell_as_polysolid( fd_out , solid_name , s );
	}
	else if( !solid_is_written )
	{
		Check_edge_uses( m );
		bu_log( "\tWriting NMG\n" );
		mk_nmg( fd_out , solid_name , m );
	}

	nmg_km( m );
a1265 1
		nmg_km( m );
d1487 1
a1487 1
	while ((c = getopt(argc, argv, "Si:I:m:rsdax:X:nu:N:c:")) != EOF) {
a1530 8
			break;
		case 'X':
			sscanf( optarg, "%x", &rt_g.NMG_debug );
			bu_printb( "librt rt_g.NMG_debug", rt_g.NMG_debug, NMG_DEBUG_FORMAT );
			bu_log("\n");
			break;
		case 'n':
			polysolid = 0;
@


11.38
log
@
Removed stray RT_EXTERNs, added bn_ prefix.
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.37 1999/12/30 18:40:04 jra Exp $";
d1718 1
a1718 1
	RT_LIST_INIT( &all_head.l );
@


11.37
log
@Eliminated some unused variables
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.36 1999/12/29 23:23:03 mike Exp $";
a51 5
RT_EXTERN( fastf_t nmg_loop_plane_area , ( struct loopuse *lu , plane_t pl ) );
RT_EXTERN( fastf_t mat_determinant , ( mat_t m ) );
RT_EXTERN( fastf_t mat_det3 , ( mat_t m ) );
RT_EXTERN( struct edgeuse *nmg_next_radial_eu, ( struct edgeuse *eu, struct shell *s, int wires ) );

d554 1
a554 1
			scale = pow( mat_det3( wmem->wm_mat ), 1.0/3.0 );
@


11.36
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.35 1999/08/04 13:56:17 jra Exp $";
d234 1
a234 1
	struct name_conv_list *ptr,*ptr2;
a236 1
	char try_char='@@';
a1296 1
		struct rt_tgc_internal tgc_int;
a1544 1
				union tree *final_tree;
@


11.35
log
@Updated option descriptions
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.34 1999/08/04 13:27:16 jra Exp $";
d1460 1
a1460 1
	db_scan(dbip, (int (*)())db_diradd, 1);
d1565 1
a1565 1
				if( (dp=db_diradd( dbip, name, -1, 0, flags)) == DIR_NULL )
@


11.34
log
@Added -I and -m options.
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.33 1999/07/29 16:13:27 jra Exp $";
d82 1
a82 1
static char *proe_usage="%s [-psdarS] [-i initial_ident] [-I constant_ident] [-m material_code] [-u reg_exp] [-x rt_debug_flag] [-X nmg_debug_flag] proe_file.brl output.g\n\
d101 1
a101 1
static char *stl_usage="%s [-psda] [-i initial_ident] [-I constant_ident] [-m material_code] [-c units_str] [-u reg_exp] [-x rt_debug_flag] [-X nmg_debug_flag] input.stl output.g\n\
@


11.33
log
@Added an nmg_km()
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.32 1999/07/29 15:53:00 jra Exp $";
d74 2
d82 1
a82 1
static char *proe_usage="%s [-psdarS] [-u reg_exp] [-x rt_debug_flag] [-X nmg_debug_flag] proe_file.brl output.g\n\
d89 2
d101 1
a101 1
static char *stl_usage="%s [-psda] [-c units_str] [-u reg_exp] [-x rt_debug_flag] [-X nmg_debug_flag] input.stl output.g\n\
d110 2
d943 2
a944 2
			if( !strncmp( &tmp_str[len-5], ".stl", 4 ) )
				tmp_str[len-5] = '\0';
d1214 1
a1214 1
	if( !polysolid || (do_simplify && face_count < 175) )
d1295 1
a1295 1
	if( do_simplify && face_count < 165 )
d1357 1
a1357 1
		color, 0, air_no, 1, 100, 0 );
d1364 15
a1378 5
		mk_lrcomb( fd_out, brlcad_name, &head, 1, (char *)NULL, (char *)NULL,
		color, id_no, 0, 1, 100, 0 );
		if( stl_format && face_count )
			(void)mk_addmember( brlcad_name, &all_head, WMOP_UNION );
		id_no++;
d1624 1
a1624 1
	while ((c = getopt(argc, argv, "Si:rsdax:X:nu:N:c:")) != EOF) {
d1648 12
@


11.32
log
@Improved name building code
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.31 1999/07/29 15:14:49 jra Exp $";
d898 1
@


11.31
log
@Added some error checking
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.30 1999/06/07 12:25:06 jra Exp $";
d921 1
a921 1
		char tmp_str[NAME_LENGTH+1];
d929 2
a930 3
		strncpy( tmp_str, input_file, NAME_LENGTH );
		if( strlen( input_file ) >= NAME_LENGTH )
			tmp_str[NAME_LENGTH] = '\0';
d933 6
a938 3
		ptr = strstr( tmp_str, ".stl" );
		if( ptr )
			*ptr = '\0';
d948 2
a949 1
		strcpy( name, ptr );
d956 1
a956 1
			sprintf( &name[NAMESIZE-suff_len-3], tmp_str );
@


11.30
log
@Improved name building for STL files
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.29 1999/06/03 21:54:21 mike Exp $";
d1022 2
a1023 1
				fgets( line1, MAX_LINE_LEN, fd_in );
d1403 1
a1403 1
	while( fgets( line, MAX_LINE_LEN, fd_in ) )
@


11.29
log
@
sed4
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.28 1999/05/24 20:34:09 jra Exp $";
d62 3
d67 1
d121 1
a121 2

#define NAMESIZE	16	/* from db.h */
d175 47
d281 1
a315 1

d317 3
d346 1
a346 2
	if( debug )
		bu_log( "\tMaking sure %s is a unique solid name\n", tmp_name );
d377 3
a379 1

d847 1
a847 1
	unsigned int obj;
d923 4
a926 1
		int len;
d947 7
d1355 2
d1693 2
d1696 6
@


11.28
log
@Added -c option to usage string for STL-G
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.27 1999/05/24 20:30:20 jra Exp $";
d68 1
a68 1
static struct rt_tol tol;	/* Tolerance structure */
d110 1
a110 1
static struct nmg_ptbl null_parts; /* Table of NULL solids */
d156 1
a156 1
	struct rt_list	l;
d184 1
a184 1
		rt_log( "Add_new_name( %s, x%x, %d )\n", name, obj, type );
d188 1
a188 1
		rt_log( "Bad type for name (%s) in Add_new_name\n", name );
d194 1
a194 1
	ptr = (struct name_conv_list *)rt_malloc( sizeof( struct name_conv_list ) , "Add_new_name: prev->next" );
d218 1
a218 1
			rt_log( "\tafter reg_ex, name is %s\n", ptr->brlcad_name );
d237 1
a237 1
			rt_log( "\tMaking sure %s is a unique name\n", tmp_name );
d244 1
a244 1
					rt_log( "\t\t%s matches existing name (%s or %s)\n", tmp_name, ptr2->brlcad_name, ptr2->solid_name );
d249 1
a249 1
					rt_log( "\t\t\ttry_char = %c\n", try_char );
d252 1
a252 1
					rt_log( "Too many objects with same name (%s)\n" , ptr->brlcad_name );
d259 1
a259 1
					rt_log( "\t\tNew name to try is %s\n", tmp_name );
d294 1
a294 1
		rt_log( "\tMaking sure %s is a unique solid name\n", tmp_name );
d302 1
a302 1
				rt_log( "\t\t%s matches existing name (%s or %s)\n", tmp_name, ptr2->brlcad_name, ptr2->solid_name );
d307 1
a307 1
				rt_log( "\t\t\ttry_char = %c\n", try_char );
d310 1
a310 1
				rt_log( "Too many solids with same name (%s)\n" , ptr->solid_name );
d317 1
a317 1
				rt_log( "\t\tNew name to try is %s\n", tmp_name );
d407 2
a408 2
		rt_log( "Barrier check at start of Convert_assy:\n" );
		if( rt_mem_barriercheck() )
d412 1
a412 1
	RT_LIST_INIT( &head.l );
d419 1
a419 1
		rt_log( "PROE-G: Convert_assy called for non-assembly:\n%s\n" , line );
d437 1
a437 1
	rt_log( "Converting Assembly: %s\n" , name );
d440 1
a440 1
		rt_log( "Convert_assy: %s x%x\n" , name , obj );
d456 3
a458 3
				rt_log( "\tmake assembly ( %s)\n" , brlcad_name );
				for( RT_LIST_FOR( wp, wmember, &head.l ) )
					rt_log( "\t%c %s\n", wp->wm_op, wp->wm_name );
d461 1
a461 1
				rt_log( "\tUsing name: %s\n", brlcad_name );
d482 1
a482 1
				rt_log( "\tmember (%s)\n" , brlcad_name );
d503 2
a504 2
				mat_print( brlcad_name, wmem->wm_mat );
				rt_log( "\tscale = %g, conv_factor = %g\n", scale, conv_factor );
d525 2
a526 2
					rt_log( "Applying re-orient matrix to member %s\n", brlcad_name );
					mat_print( "re-orient matrix", re_orient );
d528 1
a528 1
				mat_mul2( re_orient, wmem->wm_mat );
d531 1
a531 1
				mat_print( "final matrix", wmem->wm_mat );
d535 1
a535 1
			rt_log( "Unrecognized line in assembly (%s)\n%s\n" , name , line1 );
d541 2
a542 2
		rt_log( "Barrier check at end of Convet_assy:\n" );
		if( rt_mem_barriercheck() )
d662 1
a662 1
				rt_log( "Failed to create ARB8 solid for Assembly cut in part %s\n", name );
d674 2
a675 2
						rt_log( "Applying re-orient matrix to solid %s\n", ptr->solid_name );
						mat_print( "re-orient matrix", re_orient );
d677 1
a677 1
					mat_mul2( re_orient, wmem->wm_mat );
d817 1
a817 1
		rt_prmem( "At start of Conv_prt():\n" );
d821 2
a822 2
		rt_log( "Barrier check at start of Convet_part:\n" );
		if( rt_mem_barriercheck() )
d827 1
a827 1
	RT_LIST_INIT( &head.l );
d835 1
a835 1
	s = RT_LIST_FIRST( shell , &r->s_hd );
d843 1
a843 1
		rt_log( "Convert_part: Called for non-part\n%s\n" , line );
d894 1
a894 1
	rt_log( "Converting Part: %s\n" , name );
d897 1
a897 1
		rt_log( "Conv_part %s x%x\n" , name , obj );
d902 1
a902 1
	rt_log( "\tUsing solid name: %s\n" , solid_name );
d905 1
a905 1
		rt_prmem( "At start of Convert_part()" );
d981 1
a981 1
						rt_log( "Non-triangular loop:\n" );
d983 1
a983 1
							rt_log( "\t( %g %g %g )\n", V3ARGS( verts[n].pt ) );
d985 1
a985 1
						rt_log( "\t( %g %g %g )\n", x, y, z );
d993 1
a993 1
					rt_log( "Unrecognized line: %s\n", line1 );
d1055 1
a1055 1
				rt_log( "Making Face:\n" );
d1057 1
a1057 1
					rt_log( "\t( %g %g %g )\n" , V3ARGS( verts[n].pt ) );
d1065 1
a1065 1
			lu = RT_LIST_FIRST( loopuse , &fu->lu_hd );
d1103 2
a1104 2
						rt_log( "Applying re-orient matrix to solid %s\n", solid_name );
						mat_print( "re-orient matrix", re_orient );
d1106 1
a1106 1
					mat_mul2( re_orient, wmem->wm_mat );
d1119 1
a1119 1
		rt_log( "\t%s has no solid parts, ignoring\n" , name );
d1121 1
a1121 1
			rt_log( "\t%d faces were degenerate\n", degenerate_count );
d1123 2
a1124 2
			rt_log( "\t%d faces were too small\n", small_count );
		save_name = (char *)rt_malloc( NAMESIZE*sizeof( char ), "save_name" );
d1127 1
a1127 1
		nmg_tbl( &null_parts, TBL_INS, (long *)save_name );
d1134 1
a1134 1
			rt_log( "\t%d faces were degenerate\n", degenerate_count );
d1136 1
a1136 1
			rt_log( "\t%d faces were too small\n", small_count );
d1142 1
a1142 1
		rt_log( "\tFusing vertices for part\n" );
d1147 1
a1147 1
			rt_log( "\tBreak edges\n" );
d1154 1
a1154 1
			rt_log( "\tKill zero length edges\n" );
d1160 1
a1160 1
			rt_log( "\tKill cracks\n" );
d1171 1
a1171 1
			rt_log( "\tEdge fuse\n" );
d1175 1
a1175 1
			rt_log( "\tJoin touching loops\n" );
d1180 2
a1181 2
			rt_log( "\tKill cracks\n" );
		r = RT_LIST_FIRST( nmgregion, &m->r_hd );
d1189 1
a1189 1
			rt_log( "\tSplit touching loops\n" );
d1194 1
a1194 1
			rt_log( "\tKill cracks\n" );
d1210 1
a1210 1
			rt_log( "\tMake faces within tolerance\n" );
d1229 1
a1229 1
				rt_log( "failed to write ARB8 to database for solid %s\n", solid_name );
d1232 1
a1232 1
			rt_log( "\t%s written as an ARB\n", solid_name );
d1239 1
a1239 1
				rt_log( "failed to write TGC to database for solid %s\n", solid_name );
d1242 1
a1242 1
			rt_log( "\t%s written as a TGC\n", solid_name );
d1249 1
a1249 1
		rt_log( "\tWriting polysolid with %d faces\n", face_count );
d1255 1
a1255 1
		rt_log( "\tWriting NMG\n" );
d1269 2
a1270 2
				rt_log( "Applying re-orient matrix to solid %s\n", solid_name );
				mat_print( "re-orient matrix", re_orient );
d1272 1
a1272 1
			mat_mul2( re_orient, wmem->wm_mat );
d1279 1
a1279 1
		rt_log( "\tMaking air region (%s)\n" , brlcad_name );
d1287 1
a1287 1
		rt_log( "\tMaking region (%s)\n" , brlcad_name );
d1296 2
a1297 2
		rt_log( "Barrier check at end of Convert_part:\n" );
		if( rt_mem_barriercheck() )
d1309 2
a1310 2
		rt_log( "\t%s is empty, ignoring\n" , name );
		save_name = (char *)rt_malloc( NAMESIZE*sizeof( char ), "save_name" );
d1313 1
a1313 1
		nmg_tbl( &null_parts, TBL_INS, (long *)save_name );
d1343 1
a1343 1
			rt_log( "Unrecognized line:\n%s\n" , line );
d1356 2
a1357 2
		rt_log( "Cannot db_open %s\n", brlcad_file );
		rt_log( "References to NULL parts not removed\n" );
d1361 1
a1361 1
	if( debug || NMG_TBL_END( &null_parts )  )
d1363 2
a1364 2
		rt_log( "Deleting references to the following null parts:\n" );
		for( i=0 ; i<NMG_TBL_END( &null_parts ) ; i++ )
d1368 2
a1369 2
			save_name = (char *)NMG_TBL_GET( &null_parts, i );
			rt_log( "\t%s\n" , save_name );
d1429 1
a1429 1
				for( k=0 ; k<NMG_TBL_END( &null_parts ) ; k++ )
d1433 1
a1433 1
					save_name = (char *)NMG_TBL_GET( &null_parts, k );
d1444 1
a1444 1
						rt_log( "Deleting reference to null part (%s) from combination %s\n",
d1509 1
a1509 1
        tol.magic = RT_TOL_MAGIC;
d1515 1
a1515 1
	nmg_tbl( &null_parts, TBL_INIT, (long *)NULL );
d1532 1
a1532 1
		rt_log( usage, argv[0]);
d1567 2
a1568 2
			rt_printb( "librt rt_g.debug", rt_g.debug, DEBUG_FORMAT );
			rt_log("\n");
d1572 2
a1573 2
			rt_printb( "librt rt_g.NMG_debug", rt_g.NMG_debug, NMG_DEBUG_FORMAT );
			rt_log("\n");
d1582 2
a1583 2
				rt_log( "Bad regular expression (%s)\n", optarg );
				rt_log( usage, argv[0] );
d1597 1
a1597 1
			rt_log( usage, argv[0]);
d1606 1
a1606 1
		rt_log( "Cannot open input file (%s)\n" , input_file );
d1614 1
a1614 1
		rt_log( "Cannot open BRL-CAD file (%s)\n" , brlcad_file );
d1625 1
a1625 1
	mat_angles( re_orient, 0.0, 90.0, 90.0 );
@


11.27
log
@Added units conversion option for stl-g
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.26 1999/05/16 03:37:48 jra Exp $";
d93 1
a93 1
static char *stl_usage="%s [-psda] [-u reg_exp] [-x rt_debug_flag] [-X nmg_debug_flag] input.stl output.g\n\
d96 1
@


11.26
log
@Added some name building routines for STL files
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.25 1999/05/13 18:02:40 jra Exp $";
a805 1
	float part_conv_factor;
a1330 2
	else
		conv_factor = 1.0;
d1332 1
a1332 1
	if( !do_reorient )
d1523 1
d1536 1
a1536 1
	while ((c = getopt(argc, argv, "Si:rsdax:X:nu:N:")) != EOF) {
d1538 10
@


11.25
log
@Mods to ignore degenerate faces and report number of bad  faces
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.24 1998/12/31 05:03:30 mike Exp $";
d61 2
d64 2
a65 1
static int stl_format=0;		/* Flag, non-zero indocates raw Stereolithography format input */
d96 1
d791 1
a791 1
	char name[80];
d863 28
d1519 2
d1538 1
a1538 1
	while ((c = getopt(argc, argv, "Si:rsdax:X:nu:")) != EOF) {
d1540 6
d1594 2
a1595 1
	if( (fd_in=fopen( argv[optind], "r")) == NULL )
d1597 1
a1597 1
		rt_log( "Cannot open input file (%s)\n" , argv[optind] );
@


11.24
log
@#include <libgen.h>
doesn't seem to be necessary.
And it doesn't exist on all machines.
Got rid of it.
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.23 1998/11/06 14:42:06 jra Exp $";
d794 2
d847 8
a854 6
	/* get name */
	i = (-1);
	start--;
	while( !isspace( line[++start] ) && line[start] != '\0' && line[start] != '\n' )
		name[++i] = line[start];
	name[++i] = '\0';
d856 5
a860 2
	/* get object id */
	sscanf( &line[start] , "%x" , &obj );
d964 25
d1038 1
d1053 1
d1088 4
d1098 7
@


11.23
log
@Mods to get it to handle Stereolithography format.
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.22 1998/10/29 14:52:34 jra Exp $";
a34 1
#include <libgen.h>		/* this is sgi-specific, or maybe ANSI-specific */
@


11.22
log
@Converted to use POSIX regular expressions.
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.21 1998/10/28 17:15:22 jra Exp $";
d63 1
d74 1
a74 1
static char *usage="proe-g [-psdar] [-u reg_exp] [-x rt_debug_flag] [-X nmg_debug_flag] proe_file.brl output.g\n\
d88 1
d91 13
d413 1
a413 1
	if( strncmp( &line[start] , "assembly" , 8 ) )
d444 1
a444 1
		if( !strncmp( &line1[start] , "endassembly" , 11 ) )
d463 1
a463 1
		else if( !strncmp( &line1[start] , "member" , 6 ) )
d481 1
a481 1
		else if( !strncmp( &line1[start] , "matrix" , 6 ) )
d557 1
a557 1
	while( strncmp( &line1[*start], "endmodifiers", 12 ) )
d559 1
a559 1
		if( !strncmp( &line1[*start], "plane", 5 ) )
d727 55
d791 1
d800 1
a800 1
	float colr[3];
d802 1
a802 1
	unsigned char color[3];
d836 1
a836 1
	if( strncmp( &line[start] , "solid" , 5 ) )
d873 1
a873 1
		if( !strncmp( &line1[start] , "endsolid" , 8 ) )
d875 1
a875 1
		else if( !strncmp( &line1[start] , "color" , 5 ) )
d881 1
a881 1
		else if( !strncmp( &line1[start] , "normal" , 6 ) )
d889 1
a889 1
		else if( !strncmp( &line1[start] , "facet" , 5 ) )
d892 15
d908 1
a908 1
		else if( !strncmp( &line1[start] , "outer loop" , 10 ) )
d925 1
a925 1
				if( !strncmp( &line1[start] , "endloop" , 7 ) )
d927 1
a927 1
				else if ( !strncmp( &line1[start] , "vertex" , 6 ) )
d958 24
d1020 5
d1026 1
d1028 1
a1028 1
		else if( !strncmp( &line1[start], "modifiers", 9 ) )
d1055 1
a1055 1
		save_name = (char *)rt_malloc( NAMESIZE*sizeof( char ), "proe-g: save_name" );
d1072 3
a1074 1
		(void)nmg_model_break_e_on_v( m, &tol );
d1093 1
a1093 1
		/* Glue faceuses together. */
d1153 2
a1154 2
				rt_log( "proe-g: failed to write ARB8 to database for solid %s\n", solid_name );
				rt_bomb( "proe-g: failed to write to database" );
d1163 2
a1164 2
				rt_log( "proe-g: failed to write TGC to database for solid %s\n", solid_name );
				rt_bomb( "proe-g: failed to write to database" );
d1173 1
a1173 1
		rt_log( "\tWriting polysolid\n" );
d1178 1
d1234 1
a1234 1
		save_name = (char *)rt_malloc( NAMESIZE*sizeof( char ), "proe-g: save_name" );
d1249 4
a1252 2
	if( !fgets( line, MAX_LINE_LEN, fd_in ) )
		return;
d1254 4
a1257 1
	sscanf( line, "%f", &conv_factor );
d1264 1
a1264 1
		if( !strncmp( line , "assembly" , 8 ) )
d1266 1
a1266 1
		else if( !strncmp( line , "solid" , 5 ) )
d1436 1
a1436 1
        tol.dist = 0.005;
d1443 10
d1460 1
a1460 1
	while ((c = getopt(argc, argv, "i:rsdax:X:nu:")) != EOF) {
d1462 4
d1489 1
a1489 1
				rt_log( "proe-g: Bad regular expression (%s)\n", optarg );
d1525 4
a1528 1
	mk_id_units( fd_out , "Conversion from Pro/Engineer" , "in" );
@


11.21
log
@Mods to compile under Linux. Use LIBSYSV regular expressions.
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.20 1998/07/09 20:11:13 jra Exp $";
d72 1
a72 1
static regex_t *reg_cmp=(regex_t *)NULL;		/* compiled regular expression */
a162 1
	char *after_match;
d181 1
a181 20
#if 0
		after_match = regex( reg_cmp, ptr->name );
		if( after_match && *after_match != '\0' )
		{
			if( __loc1 == ptr->name )
				strncpy( ptr->brlcad_name , after_match , NAMESIZE-2 );
			else
			{
				char *str;
				int i=0;

				str = ptr->name;
				while( str != __loc1 && i<NAMESIZE )
					ptr->brlcad_name[i++] = *str++;
				strncpy( str, after_match, NAMESIZE-2-i );
			}
		}
#else
		size_t no_of_matches=0;
		regmatch_t *matches;
d183 1
a183 1
		if( !regexec( reg_cmp, ptr->name, &no_of_matches, matches, 0 ) )
d185 2
a186 2
			int i=0;
			char *str = ptr->brlcad_name;
d188 2
a189 1
			while( ptr->name[i] )
d191 2
a192 23
				int match_no;
				int keep=1;

				for( match_no=0 ; match_no<no_of_matches ; match_no++ )
				{
					if( matches[match_no].rm_so <= i && matches[match_no].rm_eo >= i )
					{
						keep = 0;
						break;
					}
				}

				if( keep )
				{
					if( str - ptr->brlcad_name == NAMESIZE-1 )
					{
						str++;
						break;
					}
					*str++ = ptr->name[i++];
				}
				else
					++i;
d194 1
a194 1
			*str = '\0';
a195 1
#endif
d1349 1
a1349 6
#if 0
			reg_cmp = regcmp( optarg, (char *)0 );
#else
			reg_cmp = re_comp( optarg, (char *)0 );
#endif
			if( reg_cmp != (char *)NULL )
@


11.20
log
@Minor mods.
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.19 1998/07/09 14:59:23 jra Exp $";
d51 1
a57 1
extern char *__loc1;	/* used by regex */
d72 1
a72 1
static char *reg_cmp=(char *)NULL;		/* compiled regular expression */
d182 1
d199 38
d1390 1
d1392 4
a1395 1
			if( reg_cmp == (char *)NULL )
@


11.19
log
@Changed option to 'n' for NMG's and minor mods to get a clean compile on an m4i64.
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/proe-g.c,v 11.18 1997/07/11 15:03:34 jra Exp $";
d909 1
a910 3

			if( area > 0.0 )
				face_count++;
d1011 6
a1019 4
#if 0
		nmg_shell_coplanar_face_merge( s , &tol , 0 );

		nmg_simplify_shell( s );
d1314 1
a1314 1
        tol.dist = 0.1;
d1316 1
a1316 1
        tol.perp = 1e-3;
d1328 1
a1328 1
	while ((c = getopt(argc, argv, "i:rsdax:X:pu:")) != EOF) {
@


11.18
log
@Added Unbreak_shell_edges().
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/proe-g.c,v 11.17 1997/05/30 19:11:22 jra Exp jra $";
d63 1
a63 1
static int polysolid=0;		/* Flag for polysolid output rather than NMG's */
d76 1
a76 1
	The -p option is to create polysolids rather than NMG's.\n\
d112 1
a112 1
	char *obj;
d155 2
a156 1
char *name,*obj;
d314 2
a315 1
char *name,*obj;
d355 2
a356 1
char *name,*obj;
d366 1
a366 1
		ptr = Add_new_name( name , (char *)NULL , PART_TYPE );
d379 1
a379 1
	char *obj;
d381 1
a381 1
	char *memb_obj;
d384 1
d418 1
a418 1
	sscanf( &line[start] , "%x %f" , &obj );
d643 1
a643 1
			ptr = Add_new_name( haf_name, (char *)NULL, CUT_SOLID_TYPE );
d721 1
a721 1
	char *obj;
d831 1
d895 2
d1016 1
a1016 1

d1020 1
a1020 1

d1346 2
a1347 2
		case 'p':
			polysolid = 1;
@


11.17
log
@Added -i option.
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/proe-g.c,v 11.16 1997/03/04 21:10:03 jra Exp jra $";
d667 44
d1049 1
@


11.16
log
@converted to combination import/export.
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/proe-g.c,v 11.15 1996/10/28 14:54:21 jra Exp jra $";
d79 1
d1276 1
a1276 1
	while ((c = getopt(argc, argv, "rsdax:X:pu:")) != EOF) {
d1278 3
@


11.15
log
@Commented out code to simplify NMG to TGC's (too dangerous).
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/proe-g.c,v 11.14 1996/10/28 14:17:58 jra Exp jra $";
a49 1
#include "db.h"
d73 1
a73 1
static char *usage="proe-g [-p] [-s] [-d] [-a] [-u reg_exp] [-x rt_debug_flag] [-X nmg_debug_flag] proe_file.brl output.g\n\
d80 1
a80 1
		'reg_exp' shouold be ignored.\n\
d98 2
d216 1
a216 1
		NAMEMOVE( ptr->brlcad_name, tmp_name );
d237 1
a237 1
				NAMEMOVE( ptr->brlcad_name, tmp_name );
d247 1
a247 1
		NAMEMOVE( tmp_name, ptr->brlcad_name );
d273 1
a273 1
	NAMEMOVE( ptr->solid_name, tmp_name );
d295 1
a295 1
			NAMEMOVE( ptr->solid_name, tmp_name );
d305 1
a305 1
	NAMEMOVE( tmp_name, ptr->solid_name );
d893 1
a893 1
		NAMEMOVE( brlcad_name, save_name );
d1066 1
a1066 1
		NAMEMOVE( brlcad_name, save_name );
d1112 1
a1112 1
	if( debug )
d1131 3
a1133 1
			union record *rp;
d1135 2
d1143 1
a1143 1
			if( (rp=db_getmrec( dbip , dp )) == (union record *)0 )
d1145 1
a1145 1
				rt_log( "Cannot get records for combination %s\n" , dp->d_namep );
d1148 26
d1175 1
a1175 1
			for( j=1; j<dp->d_len; j++ )
d1185 1
a1185 1
					if( !strncmp( save_name, rp[j].M.m_instname, NAMESIZE ) )
d1194 1
a1194 1
					if( debug )
d1196 10
a1205 10
							rp[j].M.m_instname, dp->d_namep );
					if( db_delrec( dbip, dp, j ) < 0 )
					{
						rt_log( "Error in deleting reference to null part (%s)\n", rp[j].M.m_instname );
						rt_log( "Your database should still be O.K., but there may be\n" );
						rt_log( "references to NULL parts (just a nuisance)\n" );
						exit( 1 );
					}
					rt_free( (char *)rp, "Rm_nulls: rp" );
					goto top;
d1209 35
a1243 1
			rt_free( (char *)rp, "Rm_nulls: rp" );
@


11.14
log
@Fixed -r option.
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/proe-g.c,v 11.13 1996/08/27 07:30:25 mike Exp jra $";
d78 1
a78 1
	The -s option is to simplify the objects to ARB's or TGC's where possible.\n\
d989 1
a989 1
		else if( solid_is_written = nmg_to_tgc( m, &tgc_int, &tol ) )
d998 1
a998 1
		}
@


11.13
log
@Tagged #include
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/proe-g.c,v 11.12 1996/07/12 13:00:38 jra Exp mike $";
d83 1
a83 1
	The -r option indicates that the model should not be re-oriented,\n\
d85 2
d1082 3
@


11.12
log
@Minor Mod for IRIX6.2
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/proe-g.c,v 11.11 1996/02/20 15:31:12 jra Exp jra $";
d35 1
a35 1
#include <libgen.h>
@


11.11
log
@Simplify option now uses librt routines.
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/proe-g.c,v 11.10 1996/02/09 17:38:37 jra Exp jra $";
d525 1
a525 1
static int
@


11.10
log
@Added simplify option to write NMG's as ARB's or TGC's when possible.
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/proe-g.c,v 11.9 1996/02/02 21:11:50 jra Exp $";
a363 392
static int
Write_shell_as_tgc( fd, s, solid_name, tol )
FILE *fd;
struct shell *s;
char *solid_name;
CONST struct rt_tol *tol;
{
	struct faceuse *fu;
	struct loopuse *lu;
	struct edgeuse *eu;
	struct faceuse *fu_base=(struct faceuse *)NULL;
	struct faceuse *fu_top=(struct faceuse *)NULL;
	int four_vert_faces=0;
	int many_vert_faces=0;
	int base_vert_count=0;
	int top_vert_count=0;
	int ret=0;
	point_t sum;
	fastf_t vert_count=0.0;
	fastf_t one_over_vert_count;
	point_t base_center;
	fastf_t min_base_r_sq;
	fastf_t max_base_r_sq;
	fastf_t sum_base_r_sq;
	fastf_t ave_base_r_sq;
	fastf_t base_r;
	point_t top_center;
	fastf_t min_top_r_sq;
	fastf_t max_top_r_sq;
	fastf_t sum_top_r_sq;
	fastf_t ave_top_r_sq;
	fastf_t top_r;
	plane_t top_pl;
	plane_t base_pl;
	vect_t height;
	vect_t plv_1,plv_2;
	vect_t a,b,c,d;

	NMG_CK_SHELL( s );
	RT_CK_TOL( tol );

	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )
	{
		int lu_count=0;

		NMG_CK_FACEUSE( fu );
		if( fu->orientation != OT_SAME )
			continue;

		vert_count = 0.0;

		for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
		{

			NMG_CK_LOOPUSE( lu );

			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
				return( 0 );

			lu_count++;
			if( lu_count > 1 )
				return( 0 );

			for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
				vert_count++;
		}

		if( vert_count < 4 )
			return( 0 );

		if( vert_count == 4 )
			four_vert_faces++;
		else
		{
			many_vert_faces++;
			if( many_vert_faces > 2 )
				return( 0 );

			if( many_vert_faces == 1 )
			{
				fu_base = fu;
				base_vert_count = vert_count;
				NMG_GET_FU_PLANE( base_pl, fu_base );
			}
			else if( many_vert_faces == 2 )
			{
				fu_top = fu;
				top_vert_count = vert_count;
				NMG_GET_FU_PLANE( top_pl, fu_top );
			}
		}
	}
	if( base_vert_count != top_vert_count )
		return( 0 );
	if( base_vert_count != four_vert_faces )
		return( 0 );

	if( !NEAR_ZERO( 1.0 + VDOT( top_pl, base_pl ), tol->perp ) )
		return( 0 );

	/* This looks like a good candidate,
	 * Calculate center of base and top faces
	 */

	vert_count = 0.0;
	VSETALL( sum, 0.0 );
	lu = RT_LIST_FIRST( loopuse, &fu_base->lu_hd );
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
	{
		struct vertex_g *vg;

		NMG_CK_EDGEUSE( eu );

		NMG_CK_VERTEXUSE( eu->vu_p );
		NMG_CK_VERTEX( eu->vu_p->v_p );
		vg = eu->vu_p->v_p->vg_p;
		NMG_CK_VERTEX_G( vg );

		VADD2( sum, sum, vg->coord );
		vert_count++;
	}

	one_over_vert_count = 1.0/vert_count;
	VSCALE( base_center, sum, one_over_vert_count );

	/* Calculate Average Radius */
	min_base_r_sq = MAX_FASTF;
	max_base_r_sq = (-min_base_r_sq);
	sum_base_r_sq = 0.0;
	lu = RT_LIST_FIRST( loopuse, &fu_base->lu_hd );
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
	{
		struct vertex_g *vg;
		vect_t rad_vect;
		fastf_t r_sq;

		vg = eu->vu_p->v_p->vg_p;

		VSUB2( rad_vect, vg->coord, base_center );
		r_sq = MAGSQ( rad_vect );
		if( r_sq > max_base_r_sq )
			max_base_r_sq = r_sq;
		if( r_sq < min_base_r_sq )
			min_base_r_sq = r_sq;

		sum_base_r_sq += r_sq;
	}

	ave_base_r_sq = sum_base_r_sq/vert_count;

	base_r = sqrt( max_base_r_sq );

	if( !NEAR_ZERO( (max_base_r_sq - ave_base_r_sq)/ave_base_r_sq, 0.001 ) ||
	    !NEAR_ZERO( (min_base_r_sq - ave_base_r_sq)/ave_base_r_sq, 0.001 ) )
			return( 0 );

	VSETALL( sum, 0.0 );
	lu = RT_LIST_FIRST( loopuse, &fu_top->lu_hd );
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
	{
		struct vertex_g *vg;

		NMG_CK_EDGEUSE( eu );

		NMG_CK_VERTEXUSE( eu->vu_p );
		NMG_CK_VERTEX( eu->vu_p->v_p );
		vg = eu->vu_p->v_p->vg_p;
		NMG_CK_VERTEX_G( vg );

		VADD2( sum, sum, vg->coord );
	}

	VSCALE( top_center, sum, one_over_vert_count );

	/* Calculate Average Radius */
	min_top_r_sq = MAX_FASTF;
	max_top_r_sq = (-min_top_r_sq);
	sum_top_r_sq = 0.0;
	lu = RT_LIST_FIRST( loopuse, &fu_top->lu_hd );
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
	{
		struct vertex_g *vg;
		vect_t rad_vect;
		fastf_t r_sq;

		vg = eu->vu_p->v_p->vg_p;

		VSUB2( rad_vect, vg->coord, top_center );
		r_sq = MAGSQ( rad_vect );
		if( r_sq > max_top_r_sq )
			max_top_r_sq = r_sq;
		if( r_sq < min_top_r_sq )
			min_top_r_sq = r_sq;

		sum_top_r_sq += r_sq;
	}

	ave_top_r_sq = sum_top_r_sq/vert_count;
	top_r = sqrt( max_top_r_sq );

	if( !NEAR_ZERO( (max_top_r_sq - ave_top_r_sq)/ave_top_r_sq, 0.001 ) ||
	    !NEAR_ZERO( (min_top_r_sq - ave_top_r_sq)/ave_top_r_sq, 0.001 ) )
			return( 0 );


	VSUB2( height, top_center, base_center );

	mat_vec_perp( plv_1, top_pl );
	VCROSS( plv_2, top_pl, plv_1 );
	VUNITIZE( plv_1 );
	VUNITIZE( plv_2 );
	VSCALE( a, plv_1, base_r );
	VSCALE( b, plv_2, base_r );
	VSCALE( c, plv_1, top_r );
	VSCALE( d, plv_2, top_r );

	if( (ret=mk_tgc( fd, solid_name, base_center, height, a, b, c, d )) )
	{
		rt_log( "Write_shell_as_tgc: Failed to make TGC for %s (%d)\n", solid_name, ret );
		rt_bomb( "Write_shell_as_tgc failed\n" );
	}

	return( 1 );
}

static int
Shell_is_arb( s, tab )
struct shell *s;
struct nmg_ptbl *tab;
{
	struct faceuse *fu;
	struct face *f;
	int arb;
	int four_verts=0;
	int three_verts=0;
	int face_count=0;
	int loop_count;

	NMG_CK_SHELL( s );

	nmg_vertex_tabulate( tab, &s->l.magic );

	if( NMG_TBL_END( tab ) > 8 || NMG_TBL_END( tab ) < 4 )
		goto not_arb;

	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )
	{
		struct loopuse *lu;
		vect_t fu_norm;

		NMG_CK_FACEUSE( fu );

		if( fu->orientation != OT_SAME )
			continue;

		f = fu->f_p;
		NMG_CK_FACE( f );

		if( *f->g.magic_p != NMG_FACE_G_PLANE_MAGIC )
			goto not_arb;

		NMG_GET_FU_NORMAL( fu_norm, fu );

		loop_count = 0;
		for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
		{
			struct edgeuse *eu;

			NMG_CK_LOOPUSE( lu );

			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
				goto not_arb;

			loop_count++;

			if( loop_count > 1 )
				goto not_arb;

			for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
			{
				struct edgeuse *eu_radial;
				struct faceuse *fu_radial;
				struct face *f_radial;
				vect_t norm_radial;
				vect_t eu_dir;
				vect_t cross;

				NMG_CK_EDGEUSE( eu );

				eu_radial = nmg_next_radial_eu( eu, s, 0 );

				if( eu_radial == eu || eu_radial == eu->eumate_p )
					goto not_arb;

				fu_radial = nmg_find_fu_of_eu( eu_radial );
				NMG_CK_FACEUSE( fu_radial );

				if( fu_radial->orientation != OT_SAME )
					fu_radial = fu_radial->fumate_p;

				f_radial = fu_radial->f_p;
				NMG_CK_FACE( f_radial );

				if( *f_radial->g.magic_p != NMG_FACE_G_PLANE_MAGIC )
					goto not_arb;

				NMG_GET_FU_NORMAL( norm_radial, fu_radial );

				VCROSS( cross, fu_norm, norm_radial );

				if( eu->orientation == OT_NONE )
				{
					VSUB2( eu_dir, eu->vu_p->v_p->vg_p->coord, eu->eumate_p->vu_p->v_p->vg_p->coord )
					if( eu->orientation != OT_SAME )
						VREVERSE( eu_dir, eu_dir )
				}
				else
					VMOVE( eu_dir, eu->g.lseg_p->e_dir )

				if( eu->orientation == OT_SAME || eu->orientation == OT_NONE )
				{
					if( VDOT( cross, eu_dir ) < 0.0 )
						goto not_arb;
				}
				else
				{
					if( VDOT( cross, eu_dir ) > 0.0 )
						goto not_arb;
				}
			}
		}
	}

	/* count face types */
	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )
	{
		struct loopuse *lu;
		int vert_count=0;

		if( fu->orientation != OT_SAME )
			continue;

		face_count++;
		for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
		{
			struct edgeuse *eu;

			for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
				vert_count++;
		}

		if( vert_count == 3 )
			three_verts++;
		else if( vert_count == 4 )
			four_verts++;
	}

	if( face_count != three_verts + four_verts )
		goto not_arb;

	switch( NMG_TBL_END( tab ) )
	{
		case 4:		/* each face must have 3 vertices */
			if( three_verts != 4 || four_verts != 0 )
				goto not_arb;
			break;
		case 5:		/* one face with 4 verts, four with 3 verts */
			if( four_verts != 1 || three_verts != 4 )
				goto not_arb;
			break;
		case 6:		/* three faces with 4 verts, two with 3 verts */
			if( three_verts != 2 || four_verts != 3 )
				goto not_arb;
			break;
		case 7:		/* four faces with 4 verts, two with 3 verts */
			if( four_verts != 4 || three_verts != 2 )
				goto not_arb;
			break;
		case 8:		/* each face must have 4 vertices */
			if( four_verts != 6 || three_verts != 0 )
				goto not_arb;
			break;
	}

	return( NMG_TBL_END( tab ) );


not_arb:
	nmg_tbl( tab, TBL_FREE, (long *)NULL );
	return( 0 );
}

d896 1
a896 1
	if( !polysolid || (do_simplify && face_count < 165) )
d975 2
a976 66
		struct vertex *v;
		struct nmg_ptbl tab;
		int j;
		point_t arb_pts[8];
		struct faceuse *fu;
		struct loopuse *lu;
		struct edgeuse *eu;
		struct faceuse *fu1;
		struct faceuse *fu2;
		struct edgeuse *eu_start;
		int face_verts;
		int found;

		switch( Shell_is_arb( s, &tab ) )
		{
			case 0:
				break;
			case 4:
				v = (struct vertex *)NMG_TBL_GET( &tab, 0 );
				NMG_CK_VERTEX( v );
				VMOVE( arb_pts[0], v->vg_p->coord );
				v = (struct vertex *)NMG_TBL_GET( &tab, 1 );
				NMG_CK_VERTEX( v );
				VMOVE( arb_pts[1], v->vg_p->coord );
				v = (struct vertex *)NMG_TBL_GET( &tab, 2 );
				NMG_CK_VERTEX( v );
				VMOVE( arb_pts[2], v->vg_p->coord );
				VMOVE( arb_pts[3], v->vg_p->coord );
				v = (struct vertex *)NMG_TBL_GET( &tab, 3 );
				NMG_CK_VERTEX( v );
				VMOVE( arb_pts[4], v->vg_p->coord );
				VMOVE( arb_pts[5], v->vg_p->coord );
				VMOVE( arb_pts[6], v->vg_p->coord );
				VMOVE( arb_pts[7], v->vg_p->coord );
				if( mk_arb8( fd_out, solid_name, (fastf_t *)arb_pts ) )
				{
					rt_log( "mk_arb8 failed for part %s\n", name );
					rt_bomb( "mk_arb8 failed" );
				}
				solid_is_written = 1;
				nmg_tbl( &tab, TBL_FREE, (long *)NULL );
				break;
			case 5:
				fu = RT_LIST_FIRST( faceuse, &s->fu_hd );
				face_verts = 0;
				while( face_verts != 4 )
				{
					face_verts = 0;
					fu = RT_LIST_PNEXT_CIRC( faceuse, &fu->l );
					lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
					for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
						face_verts++;
				}
				NMG_CK_FACEUSE( fu );
				if( fu->orientation != OT_SAME )
					fu = fu->fumate_p;
				NMG_CK_FACEUSE( fu );

				lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
				j = 0;
				eu_start = RT_LIST_FIRST( edgeuse, &lu->down_hd );
				for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
				{
					VMOVE( arb_pts[j], eu->vu_p->v_p->vg_p->coord )
					j++;
				}
d978 8
a985 166
				eu = eu_start->radial_p;
				eu = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
				eu = eu->eumate_p;
				for( i=0 ; i<4 ; i++ )
				{
					VMOVE( arb_pts[j], eu->vu_p->v_p->vg_p->coord )
					j++;
				}
				if( mk_arb8( fd_out, solid_name, (fastf_t *)arb_pts ) )
				{
					rt_log( "mk_arb8 failed for part %s\n", name );
					rt_bomb( "mk_arb8 failed" );
				}
				solid_is_written = 1;
				nmg_tbl( &tab, TBL_FREE, (long *)NULL );
				break;
			case 6:
				fu = RT_LIST_FIRST( faceuse, &s->fu_hd );
				face_verts = 0;
				while( face_verts != 3 )
				{
					face_verts = 0;
					fu = RT_LIST_PNEXT_CIRC( faceuse, &fu->l );
					lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
					for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
						face_verts++;
				}
				NMG_CK_FACEUSE( fu );
				if( fu->orientation != OT_SAME )
					fu = fu->fumate_p;
				NMG_CK_FACEUSE( fu );

				lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );

				eu_start = RT_LIST_FIRST( edgeuse, &lu->down_hd );
				eu = eu_start;
				VMOVE( arb_pts[1], eu->vu_p->v_p->vg_p->coord );
				eu = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
				VMOVE( arb_pts[0], eu->vu_p->v_p->vg_p->coord );
				eu = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
				VMOVE( arb_pts[4], eu->vu_p->v_p->vg_p->coord );
				VMOVE( arb_pts[5], eu->vu_p->v_p->vg_p->coord );

				eu = eu_start->radial_p;
				eu = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
				eu = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
				eu = eu->radial_p->eumate_p;
				VMOVE( arb_pts[2], eu->vu_p->v_p->vg_p->coord );
				eu = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
				VMOVE( arb_pts[3], eu->vu_p->v_p->vg_p->coord );
				eu = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
				VMOVE( arb_pts[6], eu->vu_p->v_p->vg_p->coord );
				VMOVE( arb_pts[7], eu->vu_p->v_p->vg_p->coord );

				if( mk_arb8( fd_out, solid_name, (fastf_t *)arb_pts ) )
				{
					rt_log( "mk_arb8 failed for part %s\n", name );
					rt_bomb( "mk_arb8 failed" );
				}
				solid_is_written = 1;
				nmg_tbl( &tab, TBL_FREE, (long *)NULL );
				break;
			case 7:
				found = 0;
				fu = RT_LIST_FIRST( faceuse, &s->fu_hd );
				while( !found )
				{
					int verts4=0,verts3=0;

					lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
					for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
					{
						struct loopuse *lu1;
						struct edgeuse *eu1;
						int vert_count=0;

						fu1 = nmg_find_fu_of_eu( eu->radial_p );
						lu1 = RT_LIST_FIRST( loopuse, &fu1->lu_hd );
						for( RT_LIST_FOR( eu1, edgeuse, &lu1->down_hd ) )
							vert_count++;

						if( vert_count == 4 )
							verts4++;
						else if( vert_count == 3 )
							verts3++;
					}

					if( verts4 == 2 && verts3 == 2 )
						found = 1;
				}
				if( fu->orientation != OT_SAME )
					fu = fu->fumate_p;
				NMG_CK_FACEUSE( fu );

				lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
				j = 0;
				eu_start = RT_LIST_FIRST( edgeuse, &lu->down_hd );
				for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
				{
					VMOVE( arb_pts[j], eu->vu_p->v_p->vg_p->coord )
					j++;
				}

				eu = eu_start->radial_p;
				eu = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
				eu = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
				eu = eu->radial_p->eumate_p;
				fu1 = nmg_find_fu_of_eu( eu );
				if( nmg_faces_are_radial( fu, fu1 ) )
				{
					eu = eu_start->radial_p;
					eu = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
					eu = eu->radial_p->eumate_p;
				}
				for( i=0 ; i<4 ; i++ )
				{
					VMOVE( arb_pts[j], eu->vu_p->v_p->vg_p->coord )
					j++;
					eu = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
				}
				if( mk_arb8( fd_out, solid_name, (fastf_t *)arb_pts ) )
				{
					rt_log( "mk_arb8 failed for part %s\n", name );
					rt_bomb( "mk_arb8 failed" );
				}
				solid_is_written = 1;
				nmg_tbl( &tab, TBL_FREE, (long *)NULL );
				break;
			case 8:
				fu = RT_LIST_FIRST( faceuse, &s->fu_hd );
				NMG_CK_FACEUSE( fu );
				if( fu->orientation != OT_SAME )
					fu = fu->fumate_p;
				NMG_CK_FACEUSE( fu );

				lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
				j = 0;
				eu_start = RT_LIST_FIRST( edgeuse, &lu->down_hd );
				for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
				{
					VMOVE( arb_pts[j], eu->vu_p->v_p->vg_p->coord )
					j++;
				}

				eu = eu_start->radial_p;
				eu = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
				eu = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
				eu = eu->radial_p->eumate_p;
				for( i=0 ; i<4 ; i++ )
				{
					VMOVE( arb_pts[j], eu->vu_p->v_p->vg_p->coord )
					j++;
					eu = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
				}
				if( mk_arb8( fd_out, solid_name, (fastf_t *)arb_pts ) )
				{
					rt_log( "mk_arb8 failed for part %s\n", name );
					rt_bomb( "mk_arb8 failed" );
				}
				solid_is_written = 1;
				nmg_tbl( &tab, TBL_FREE, (long *)NULL );
				break;
			default:
				fprintf( stderr, "Shell_is_arb returned illegal value for part %s\n", name );
				rt_bomb( "Shell_is_arb screwed up" );
				
d987 8
a994 8
		if( solid_is_written )
			rt_log( "\t%s written as an ARB\n", solid_name );
	}

	if( do_simplify && !solid_is_written )
	{
		solid_is_written = Write_shell_as_tgc( fd_out, s, solid_name, &tol );
		if( solid_is_written )
d996 1
d1191 1
a1191 1
        tol.dist = 0.005;
d1193 1
a1193 1
        tol.perp = 1e-6;
@


11.9
log
@Checkpoint.
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/proe-g.c,v 11.8 1996/02/01 16:07:46 jra Exp jra $";
d74 1
a74 1
static char *usage="proe-g [-p] [-d] [-a] [-u reg_exp] [-x rt_debug_flag] [-X nmg_debug_flag] proe_file.brl output.g\n\
d78 1
d365 225
d1288 1
a1288 1
	if( !polysolid || do_simplify )
d1365 1
a1365 1
	if( do_simplify )
d1601 2
d1607 3
a1609 1
		/* Check if this is a TGC */
@


11.8
log
@Checkpoint.
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/proe-g.c,v 11.7 1995/08/18 15:35:15 jra Exp $";
d56 1
d72 1
d146 1
d148 1
a148 1
struct name_conv_list *
d162 1
a162 1
	if( type != ASSEMBLY_TYPE && type != PART_TYPE )
d174 1
a174 1
	if( do_regex )
d197 2
d205 6
a210 4
	/* make sure brlcad_name is unique */
	suffix_insert = strlen( ptr->brlcad_name );
	if( suffix_insert > NAMESIZE - 3 )
		suffix_insert = NAMESIZE - 3;
d212 5
a216 7
	NAMEMOVE( ptr->brlcad_name, tmp_name );
	if( debug )
		rt_log( "\tMaking sure %s is a unique name\n", tmp_name );
	ptr2 = name_root;
	while( ptr2 )
	{
		if( !strncmp( tmp_name , ptr2->brlcad_name , NAMESIZE ) || !strncmp( tmp_name , ptr2->solid_name , NAMESIZE ) )
d218 1
a218 8
			if( debug )
				rt_log( "\t\t%s matches existing name (%s or %s)\n", tmp_name, ptr2->brlcad_name, ptr2->solid_name );
			try_char++;
			if( try_char == '[' )
				try_char = 'a';
			if( debug )
				rt_log( "\t\t\ttry_char = %c\n", try_char );
			if( try_char == '{' )
d220 18
a237 2
				rt_log( "Too many objects with same name (%s)\n" , ptr->brlcad_name );
				exit(1);
d239 3
d243 1
a243 8
			NAMEMOVE( ptr->brlcad_name, tmp_name );
			sprintf( &tmp_name[suffix_insert] , "_%c" , try_char );
			if( debug )
				rt_log( "\t\tNew name to try is %s\n", tmp_name );
			ptr2 = name_root;
		}
		else
			ptr2 = ptr2->next;
a245 2
	NAMEMOVE( tmp_name, ptr->brlcad_name );

d251 6
d260 1
a260 1
		strncpy( &ptr->solid_name[2] , ptr->brlcad_name , NAMESIZE-4 );
d306 1
a306 1
char *
d346 1
a346 1
char *
d363 168
a530 1
void
d692 1
a692 1
do_modifiers( line1, start, head, name )
d697 1
d700 1
d706 1
d708 6
a713 3
			double dist;
			point_t plane_origin;
			vect_t plane_norm;
d716 2
d721 1
a721 1
			VSET( plane_origin, x, y, z );
d724 1
d727 1
d730 1
a730 1
			VSET( plane_norm, x, y, z );
d732 1
a732 1
			sscanf( line1, "%lf %lf", &x, &y );
d734 1
a734 1
			sscanf( line1, "%lf %lf", &x, &y );
d738 60
d800 4
a803 4
			dist = VDOT( plane_norm, plane_origin );
			sprintf( haf_name, "s.haf.%d", cut_count );
			if( mk_half( fd_out, haf_name, plane_norm, dist ) )
				rt_log( "Failed to create HAF solid for Assembly cut in part %s\n", name );
d807 2
a808 6
				if( orient == (-1) )
					wmem = mk_addmember( haf_name, head,
							WMOP_SUBTRACT );
				else
					wmem = mk_addmember( haf_name, head,
							WMOP_INTERSECT );
d815 1
a815 1
						rt_log( "Applying re-orient matrix to solid %s\n", haf_name );
a822 4
		else if( !strncmp( &line1[*start], "cylinder", 8 ) )
		{
rt_log( "Cyinder\n" );
		}
d829 1
a829 1
void
d853 2
d868 2
a898 3
#if 0
	sscanf( &line[start] , "%x %f" , &obj, &part_conv_factor );
#else
a899 1
#endif
a903 3
#if 0
		rt_log( "Conv_part %s x%x %g\n" , name , obj, part_conv_factor );
#else
a904 1
#endif
d979 1
d1044 1
a1044 1
			do_modifiers( line1, &start, &head, name );
d1062 1
a1062 1
	if( !polysolid )
d1139 239
a1377 1
	if( polysolid )
d1379 5
d1387 1
a1387 1
	else
d1454 1
a1454 1
void
d1475 1
a1475 1
void
d1588 1
a1588 1
	while ((c = getopt(argc, argv, "rdax:X:pu:")) != EOF) {
d1621 3
@


11.7
log
@FIxed bug in scale factor.
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/proe-g.c,v 11.6 1995/05/11 20:44:59 jra Exp jra $";
d35 1
d54 2
d57 1
d67 1
d69 4
a72 1
static char *usage="proe-g [-p] [-d] [-x rt_debug_flag] [-X nmg_debug_flag] proe_file.brl output.g\n\
d77 5
d89 4
d111 28
d152 1
a152 1
	int len;
d154 4
d165 1
d171 25
a195 1
	strncpy( ptr->brlcad_name , name , NAMESIZE-2 );
d201 3
a203 3
	len = strlen( ptr->brlcad_name );
	if( len >= NAMESIZE )
		len = NAMESIZE - 1;
d206 2
d211 1
a211 1
		if( !strncmp( tmp_name , ptr2->brlcad_name , NAMESIZE-2 ) || !strncmp( tmp_name , ptr2->solid_name , NAMESIZE-2 ) )
d213 2
d218 2
d221 1
d223 2
d227 3
a229 1
			sprintf( &tmp_name[len-2] , "_%c" , try_char );
d246 1
a246 1
		strncpy( &ptr->solid_name[2] , name , NAMESIZE-4 );
d251 3
a253 3
	len = strlen( ptr->solid_name );
	if( len >= NAMESIZE )
		len = NAMESIZE - 1;
d256 2
d262 1
a262 1
		if( !strncmp( tmp_name , ptr2->brlcad_name , NAMESIZE-2 ) || !strncmp( tmp_name , ptr2->solid_name , NAMESIZE-2 ) )
d264 2
d269 2
d272 4
a275 1
				rt_log( "Too many objects with same name (%s)\n" , ptr->brlcad_name );
d278 3
a280 1
			sprintf( &tmp_name[len-2] , "_%c" , try_char );
d420 3
d459 7
a465 1
			scale = MAGNITUDE( &wmem->wm_mat[0] );
d472 1
a472 1
				if( top_level )
d474 2
d479 13
d495 1
a495 1
			fprintf( stderr , "Unrecognized line in assembly (%s)\n%s\n" , name , line1 );
d510 76
d603 1
d607 1
d609 1
d652 5
a656 1
	sscanf( &line[start] , "%x %f" , &obj );
d661 3
d665 6
d787 19
a898 6
	solid_count++;
	solid_name = Get_solid_name( name , obj );

	if( debug )
		rt_log( "Writing solid (%s)\n" , solid_name );

d912 19
a930 1
	mk_addmember( solid_name , &head , WMOP_UNION );
d932 7
a938 3
	brlcad_name = Get_unique_name( name , obj , PART_TYPE );
	if( debug )
		rt_log( "\tMake region (%s)\n" , brlcad_name );
d940 4
a943 3
	mk_lrcomb( fd_out, brlcad_name, &head, 1, (char *)NULL, (char *)NULL,
	color, id_no, 0, 1, 100, 0 );
	id_no++;
d988 1
a988 1
			fprintf( stderr , "Unrecognized line:\n%s\n" , line );
d1100 1
a1100 1
		fprintf(stderr, usage, argv[0]);
d1105 1
a1105 1
	while ((c = getopt(argc, argv, "dx:X:p")) != EOF) {
d1123 16
d1140 1
a1140 1
			fprintf(stderr, usage, argv[0]);
d1148 1
a1148 1
		fprintf( stderr, "Cannot open input file (%s)\n" , argv[optind] );
d1156 1
a1156 1
		fprintf( stderr, "Cannot open BRL-CAD file (%s)\n" , brlcad_file );
d1162 3
@


11.6
log
@removed nmg_process_imported_model().
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/proe-g.c,v 11.5 1995/05/02 20:59:46 jra Exp $";
d74 2
a265 1
	float conv_factor;
d298 2
a299 2
	/* get object pointer and conversion factor */
	sscanf( &line[start] , "%x %f" , &obj, &conv_factor );
d349 1
d358 14
a371 3
#if 0
			wmem->wm_mat[15] /= conv_factor;
#endif
d386 2
a410 1
	float conv_factor;
d452 2
a453 2
	/* get object id and conversion factor */
	sscanf( &line[start] , "%x %f" , &obj, &conv_factor );
a508 1

d510 6
d704 2
d727 5
@


11.5
log
@More fiddling with nmg_process_imported_model().
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/proe-g.c,v 11.4 1995/04/05 19:56:54 jra Exp $";
a97 284
int
nmg_process_imported_model( m, outfaceuses, nfaces, tol )
struct model *m;
struct faceuse *outfaceuses[];
int nfaces;
struct rt_tol *tol;
{
	struct nmgregion *r;
	struct shell *s;
	int return_val=0;
	int i;

	NMG_CK_MODEL( m );
	RT_CK_TOL( tol );

	if( rt_g.debug & DEBUG_MEM_FULL )
	{
		rt_log( "Barrier check at start of nmg_process_imported_model:\n" );
		if( rt_mem_barriercheck() )
			rt_bomb( "Barrier check failed!!!\n" );
	}

	if( debug )
		rt_log( "\tvertex fuse\n" );
	(void)nmg_model_vertex_fuse( m, tol );

	/* Break edges on vertices */
	if( debug )
		rt_log( "\tBreak edges\n" );
	(void)nmg_model_break_e_on_v( m, tol );

	/* kill zero length edgeuses */
	if( debug )
		rt_log( "\tKill zero length edges\n" );
	if( nmg_kill_zero_length_edgeuses( m ) )
		return( 1 );

	/* kill cracks */
	if( debug )
		rt_log( "\tKill cracks\n" );
	r = RT_LIST_FIRST( nmgregion, &m->r_hd );
	while( RT_LIST_NOT_HEAD( &r->l, &m->r_hd ) )
	{
		struct nmgregion *next_r;

		next_r = RT_LIST_PNEXT( nmgregion, &r->l );

		s = RT_LIST_FIRST( shell , &r->s_hd );
		while( RT_LIST_NOT_HEAD( &s->l, &r->s_hd ) )
		{
			struct shell *next_s;

			next_s = RT_LIST_PNEXT( shell, &s->l );

			if( nmg_kill_cracks( s ) )
			{
				if( nmg_ks( s ) )
					return_val = 1;
			}
			if( return_val )
				break;
			s = next_s;
		}
		if( return_val )
			break;
		r = next_r;
	}

	if( return_val )
		return( return_val );

	/* Associate the face geometry. */
	if( debug )
		rt_log( "\tCalculate Face geometry\n" );
	for (i = 0; i < nfaces; i++)
	{
		/* skip faceuses that were killed */
		if( outfaceuses[i]->l.magic != NMG_FACEUSE_MAGIC )
			continue;

		/* calculate plane for this faceuse */
		if( !outfaceuses[i]->f_p->g.magic_p )
		{
			if( nmg_calc_face_g( outfaceuses[i] ) )
			{
				rt_log( "nmg_calc_face_g failed\n" );
				nmg_pr_fu_briefly( outfaceuses[i], "" );
			}
		}
	}

	/* Compute "geometry" for model, region, and shell */
	if( debug )
		rt_log( "\trebound\n" );
	nmg_rebound( m , tol );
#if 0

	/* Break edges on vertices */
	if( debug )
		rt_log( "\tBreak edges\n" );
	(void)nmg_model_break_e_on_v( m, tol );

	/* kill cracks */
	if( debug )
		rt_log( "\tKill cracks\n" );
	r = RT_LIST_FIRST( nmgregion, &m->r_hd );
	while( RT_LIST_NOT_HEAD( &r->l, &m->r_hd ) )
	{
		struct nmgregion *next_r;

		next_r = RT_LIST_PNEXT( nmgregion, &r->l );

		s = RT_LIST_FIRST( shell , &r->s_hd );
		while( RT_LIST_NOT_HEAD( &s->l, &r->s_hd ) )
		{
			struct shell *next_s;

			next_s = RT_LIST_PNEXT( shell, &s->l );

			if( nmg_kill_cracks( s ) )
			{
				if( nmg_ks( s ) )
					return_val = 1;
			}
			if( return_val )
				break;
			s = next_s;
		}
		if( return_val )
			break;
		r = next_r;
	}

	if( return_val )
		return( return_val );

	/* kill zero length edgeuses */
	if( debug )
		rt_log( "\tKill zero length edges\n" );
	if( nmg_kill_zero_length_edgeuses( m ) )
		return( 1 );
#endif

	if( !polysolid )
	{
		/* Glue faceuses together. */
		if( debug )
			rt_log( "\tEdge fuse\n" );
		(void)nmg_model_edge_fuse( m, tol );

		/* Compute "geometry" for model, region, and shell */
		if( debug )
			rt_log( "\trebound\n" );
		nmg_rebound( m , tol );

		/* fix the normals */
		if( debug )
			rt_log( "\tFix normals\n" );
		for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
		{
			for( RT_LIST_FOR( s, shell, &r->s_hd ) )
				nmg_fix_normals( s, tol );
		}

		if( debug )
			rt_log( "\tJoin touching loops\n" );
		for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
		{
			for( RT_LIST_FOR( s, shell, &r->s_hd ) )
				nmg_s_join_touchingloops( s, tol );
		}

		/* kill cracks */
		if( debug )
			rt_log( "\tKill cracks\n" );
		r = RT_LIST_FIRST( nmgregion, &m->r_hd );
		while( RT_LIST_NOT_HEAD( &r->l, &m->r_hd ) )
		{
			struct nmgregion *next_r;

			next_r = RT_LIST_PNEXT( nmgregion, &r->l );

			s = RT_LIST_FIRST( shell , &r->s_hd );
			while( RT_LIST_NOT_HEAD( &s->l, &r->s_hd ) )
			{
				struct shell *next_s;

				next_s = RT_LIST_PNEXT( shell, &s->l );
				
				if( nmg_kill_cracks( s ) )
				{
					if( nmg_ks( s ) )
						return_val = 1;
				}
				if( return_val )
					break;
				s = next_s;
			}
			if( return_val )
				break;
			r = next_r;
		}

		if( return_val )
			return( return_val );

		if( debug )
			rt_log( "\tSplit touching loops\n" );
		for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
		{
			for( RT_LIST_FOR( s, shell, &r->s_hd ) )
				nmg_s_split_touchingloops( s, tol);
		}

		/* kill cracks */
		if( debug )
			rt_log( "\tKill cracks\n" );
		r = RT_LIST_FIRST( nmgregion, &m->r_hd );
		while( RT_LIST_NOT_HEAD( &r->l, &m->r_hd ) )
		{
			struct nmgregion *next_r;

			next_r = RT_LIST_PNEXT( nmgregion, &r->l );
			
			s = RT_LIST_FIRST( shell , &r->s_hd );
			while( RT_LIST_NOT_HEAD( &s->l, &r->s_hd ) )
			{
				struct shell *next_s;

				next_s = RT_LIST_PNEXT( shell, &s->l );

				if( nmg_kill_cracks( s ) )
				{
					if( nmg_ks( s ) )
						return_val = 1;
				}
				if( return_val )
					break;
				s = next_s;
			}
			if( return_val )
				break;
			r = next_r;
		}

		if( return_val )
			return( return_val );

		/* verify face plane calculations */
		if( debug )
			rt_log( "\tMake faces within tolerance\n" );
		for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
		{
			for( RT_LIST_FOR( s, shell, &r->s_hd ) )
				nmg_make_faces_within_tol( s, tol );
		}
#if 0
		/* Fuse */
		if( debug )
			rt_log( "\tFuse\n" );
		(void)nmg_model_fuse( m, tol );

		if( debug )
			rt_log( "\tJoin and split touching loops\n" );
		for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
		{
			for( RT_LIST_FOR( s, shell, &r->s_hd ) )
			{
				nmg_s_join_touchingloops( s, tol );
				nmg_s_split_touchingloops( s, tol);
			}
		}
#endif
	}
	if( rt_g.debug & DEBUG_MEM_FULL )
	{
		rt_log( "Barrier check at end of nmg_process_imported_model:\n" );
		if( rt_mem_barriercheck() )
			rt_bomb( "Barrier check failed!!!\n" );
	}

	return( 0 );
}

d385 1
a390 1
	struct nmg_ptbl faces;
a409 1
	nmg_tbl( &faces , TBL_INIT , (long *)NULL );
a423 1
		nmg_tbl( &faces, TBL_FREE, (long *)NULL );
d552 1
a552 1
				nmg_tbl( &faces , TBL_INS , (long *)fu );
d559 1
a559 1
	if( NMG_TBL_END( &faces ) == 0 )
a567 1
		nmg_tbl( &faces, TBL_FREE, (long *)NULL );
d572 1
a572 2
#if 1
	if( nmg_process_imported_model( m, (struct faceuse **)NMG_TBL_BASEADDR( &faces), NMG_TBL_END( &faces ), &tol ) )
d574 63
a636 14
		nmg_tbl( &faces , TBL_FREE , (long *)NULL );
		nmg_km( m );
		rt_log( "Note: %s is an empty solid\n" , name );
		return;
	}
	nmg_tbl( &faces , TBL_FREE , (long *)NULL );
#else
	/* fuse vertices that are within tolerance of each other */
	rt_log( "\tFusing vertices for part\n" );
	(void)nmg_model_vertex_fuse( m , &tol );

	rt_log( "\tGlueing faces together\n" );
	nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ) );
	nmg_tbl( &faces , TBL_FREE , (long *)NULL );
a637 2
	if( !polysolid )
	{
a643 1
		(void)nmg_model_vertex_fuse( m , &tol );
d648 1
a648 1
#endif
d683 15
@


11.4
log
@Added some debug statements, freed some memory.
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/proe-g.c,v 11.3 1995/04/05 13:43:44 jra Exp jra $";
d179 1
a179 1
		if( nmg_calc_face_g( outfaceuses[i] ) )
d181 5
a185 2
			rt_log( "nmg_calc_face_g failed\n" );
			nmg_pr_fu_briefly( outfaceuses[i], "" );
a239 9
	/* Glue faceuses together. */
	if( debug )
		rt_log( "\tEdge fuse\n" );
	(void)nmg_model_edge_fuse( m, tol );

	/* Compute "geometry" for model, region, and shell */
	if( debug )
		rt_log( "\trebound\n" );
	nmg_rebound( m , tol );
d241 1
a241 4
	/* fix the normals */
	if( debug )
		rt_log( "\tFix normals\n" );
	for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
d243 18
a260 3
		for( RT_LIST_FOR( s, shell, &r->s_hd ) )
			nmg_fix_normals( s, tol );
	}
d262 7
a268 17
	if( debug )
		rt_log( "\tJoin touching loops\n" );
	for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
	{
		for( RT_LIST_FOR( s, shell, &r->s_hd ) )
			nmg_s_join_touchingloops( s, tol );
	}

	/* kill cracks */
	if( debug )
		rt_log( "\tKill cracks\n" );
	r = RT_LIST_FIRST( nmgregion, &m->r_hd );
	while( RT_LIST_NOT_HEAD( &r->l, &m->r_hd ) )
	{
		struct nmgregion *next_r;

		next_r = RT_LIST_PNEXT( nmgregion, &r->l );
d270 5
a274 2
		s = RT_LIST_FIRST( shell , &r->s_hd );
		while( RT_LIST_NOT_HEAD( &s->l, &r->s_hd ) )
d276 1
a276 1
			struct shell *next_s;
d278 1
a278 1
			next_s = RT_LIST_PNEXT( shell, &s->l );
d280 2
a281 1
			if( nmg_kill_cracks( s ) )
d283 12
a294 2
				if( nmg_ks( s ) )
					return_val = 1;
d298 1
a298 1
			s = next_s;
d300 1
d302 1
a302 3
			break;
		r = next_r;
	}
d304 7
a310 2
	if( return_val )
		return( return_val );
d312 7
a318 7
	if( debug )
		rt_log( "\tSplit touching loops\n" );
	for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
	{
		for( RT_LIST_FOR( s, shell, &r->s_hd ) )
			nmg_s_split_touchingloops( s, tol);
	}
d320 6
a325 7
	/* kill cracks */
	if( debug )
		rt_log( "\tKill cracks\n" );
	r = RT_LIST_FIRST( nmgregion, &m->r_hd );
	while( RT_LIST_NOT_HEAD( &r->l, &m->r_hd ) )
	{
		struct nmgregion *next_r;
d327 1
a327 6
		next_r = RT_LIST_PNEXT( nmgregion, &r->l );

		s = RT_LIST_FIRST( shell , &r->s_hd );
		while( RT_LIST_NOT_HEAD( &s->l, &r->s_hd ) )
		{
			struct shell *next_s;
d329 8
a336 6
			next_s = RT_LIST_PNEXT( shell, &s->l );

			if( nmg_kill_cracks( s ) )
			{
				if( nmg_ks( s ) )
					return_val = 1;
d340 1
a340 1
			s = next_s;
d342 1
d344 1
a344 3
			break;
		r = next_r;
	}
d346 8
a353 11
	if( return_val )
		return( return_val );

	/* verify face plane calculations */
	if( debug )
		rt_log( "\tMake faces within tolerance\n" );
	for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
	{
		for( RT_LIST_FOR( s, shell, &r->s_hd ) )
			nmg_make_faces_within_tol( s, tol );
	}
d355 8
a362 10
	/* Fuse */
	if( debug )
		rt_log( "\tFuse\n" );
	(void)nmg_model_fuse( m, tol );

	if( debug )
		rt_log( "\tJoin and split touching loops\n" );
	for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
	{
		for( RT_LIST_FOR( s, shell, &r->s_hd ) )
d364 5
a368 2
			nmg_s_join_touchingloops( s, tol );
			nmg_s_split_touchingloops( s, tol);
d370 1
a371 1
#endif
@


11.3
log
@Added nmg_process_imported_model(). and fixed strcpy bug.
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/proe-g.c,v 11.2 1995/03/24 20:58:32 jra Exp $";
d593 3
d597 3
d702 1
d789 1
d844 2
a845 1
		NAMEMOVE( name, save_name );
d948 1
a948 1
		rt_log( "References to NULL pat not removed\n" );
d952 12
d978 1
a984 1
top:
d1004 3
d1014 1
d1018 2
@


11.2
log
@Uses command line file names rather than stdin and stdout.
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/proe-g.c,v 11.1 95/01/04 09:59:42 mike Rel4_4 Locker: jra $";
d73 1
a73 1
static struct db_i *dbip;
d98 277
d394 1
a394 1
	strcpy( ptr->name , name );
d403 4
a406 1
	strcpy( tmp_name , ptr->brlcad_name );
d418 1
a418 1
			strcpy( tmp_name , ptr->brlcad_name );
d426 1
a426 1
	strcpy( ptr->brlcad_name , tmp_name );
d442 4
a445 1
	strcpy( tmp_name , ptr->solid_name );
d447 1
d458 1
a458 1
			strcpy( tmp_name , ptr->solid_name );
d466 1
a466 1
	strcpy( ptr->solid_name , tmp_name );
d540 2
a541 2
	double mat_col[4];
	double conv_factor;
d545 7
d623 1
a623 1
				sscanf( line1 , "%lf %lf %lf %lf" , &mat_col[0] , &mat_col[1] , &mat_col[2] , &mat_col[3] );
d627 3
a629 6

			for( j=0 ; j<15 ; j++ )
			{
				/* element #15 should not be affected by conversion factor */
				wmem->wm_mat[j] *= conv_factor;
			}
d636 8
d667 11
a677 1
	double conv_factor;
d679 1
d684 1
d686 1
d688 1
d718 3
d767 1
d769 11
d783 2
d793 9
d832 2
d835 4
d843 10
d861 1
a861 1
/*	if( !polysolid )
d872 1
a872 1
*/
d874 1
a874 1

d903 8
d929 69
d1010 1
a1010 1
        tol.dist = 0.0005;
d1015 2
d1031 2
d1036 2
d1068 5
@


11.1
log
@Release_4.4
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/proe-g.c,v 1.10 94/12/08 18:09:15 jra Exp $";
d54 5
d64 1
a64 1
static char *usage="proe-g [-p] [-d] [-x rt_debug_flag] [-X nmg_debug_flag] < proe_file.brl > output.g\n\
d66 1
a66 1
	and output.g is the name of a BRL-CAD database file.\n\
d71 3
d87 2
d119 4
a122 2
	strncpy( ptr->brlcad_name , name , NAMESIZE-1 );
	ptr->brlcad_name[NAMESIZE-1] = '\0';
d130 1
a130 1
		if( !strncmp( tmp_name , ptr2->brlcad_name , NAMESIZE ) || !strncmp( tmp_name , ptr2->solid_name , NAMESIZE ) )
d156 1
a156 1
		strncpy( &ptr->solid_name[2] , name , NAMESIZE-3 );
d166 1
a166 1
		if( !strncmp( tmp_name , ptr2->brlcad_name , NAMESIZE ) || !strncmp( tmp_name , ptr2->solid_name , NAMESIZE ) )
d257 1
d279 1
a279 1
	while( !isspace( line[++start] ) && line[start] != '\0' )
d283 2
a284 2
	/* get object pointer */
	sscanf( &line[start] , "%x" , &obj );
d291 1
a291 1
	while( gets( line1 ) )
d303 1
a303 1
			mk_lcomb( stdout , brlcad_name , &head , 0 ,
d313 1
a313 1
			while( !isspace( line1[++start] ) && line1[start] != '\0' )
d331 1
a331 1
				gets( line1 );
d337 5
a341 3
			wmem->wm_mat[3] *= 25.4;
			wmem->wm_mat[7] *= 25.4;
			wmem->wm_mat[11] *= 25.4;
d371 1
d396 1
a396 1
	while( !isspace( line[++start] ) && line[start] != '\0' )
d400 2
a401 2
	/* get object id */
	sscanf( &line[start] , "%x" , &obj );
d408 1
a408 1
	while( gets( line1 ) != NULL )
d443 1
a443 1
				gets( line1 );
d455 1
a455 1
					VSET( verts[vert_no].pt , x*25.4 , y*25.4 , z*25.4 );
d509 1
a509 1
	if( !polysolid )
d511 3
a513 1
		nmg_shell_coplanar_face_merge( s , &tol , 1 );
d520 1
d532 1
a532 1
		write_shell_as_polysolid( stdout , solid_name , s );
d536 2
a537 3
		rt_log( "Writing NMG\n" );
		nmg_shell_coplanar_face_merge( s , &tol , 1 );
		mk_nmg( stdout , solid_name , m );
d548 1
a548 1
	mk_lrcomb( stdout, brlcad_name, &head, 1, (char *)NULL, (char *)NULL,
d558 1
a558 1
	while( gets( line ) )
d586 6
d614 16
a629 1
	mk_id_units( stdout , "Conversion from Pro/Engineer" , "in" );
d632 1
@


1.10
log
@Made solid names "s.part_name" to make concats easier.
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/proe-g.c,v 1.9 94/12/07 13:46:47 jra Exp Locker: jra $";
@


1.9
log
@Added check for empty parts
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/proe-g.c,v 1.8 94/11/08 16:15:09 jra Exp Locker: jra $";
d59 1
a59 1
static char *usage="proe-g [-p] < proe_file.brl > output.g\n\
d61 5
a65 2
	and output.g is the name of a BRL-CAD database file\n\
	The -p option is to create polysolids rather than NMG's\n";
d75 2
a76 1
	char brlcad_name[NAMESIZE+1];
d84 4
d89 1
a89 1
Add_new_name( name , obj )
d91 1
d98 6
d109 2
a110 2
	strncpy( ptr->brlcad_name , name , NAMESIZE );
	ptr->brlcad_name[NAMESIZE] = '\0';
d118 1
a118 1
		if( !strncmp( tmp_name , ptr2->brlcad_name , NAMESIZE ) )
d135 37
d176 1
a176 1
Get_unique_name( name , obj )
d178 1
d185 1
a185 1
		name_root = Add_new_name( name , obj );
d207 1
a207 1
			prev->next = Add_new_name( name , obj );
d215 5
d221 11
d287 1
a287 1
			brlcad_name = Get_unique_name( name , obj );
d307 1
a307 1
			brlcad_name = Get_unique_name( memb_name , memb_obj );
d342 1
a342 1
	char solid_name[NAMESIZE+1];
d390 1
a390 1
		rt_log( "Conv_part %s %s x%x\n" , name , obj );
a503 1
	sprintf( solid_name , "sol.%d" , solid_count );
d505 1
d507 3
d526 1
a526 1
	brlcad_name = Get_unique_name( name , obj );
@


1.8
log
@Mods for Irix 6.0
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /n/wolf/m/cad/conv/RCS/proe-g.c,v 1.7 1994/11/01 07:11:28 butler Exp jra $";
d406 8
@


1.7
log
@changed type for "color" to unsigned char to match parameter for mk_lrcomb()
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/proe-g.c,v 1.6 1994/11/01 04:18:45 butler Exp butler $";
a54 1
static int NMG_debug=0;		/* NMG debug flag */
a86 1
	int try_count=0;
a285 1
	struct wmember *wmem;
a498 1
			NMG_debug = rt_g.NMG_debug;
@


1.6
log
@fixed call to mk_lcomb()
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/proe-g.c,v 1.5 1994/08/11 00:06:10 gdurf Exp butler $";
d285 1
a285 1
	char color[3];
d453 2
a454 1
	mk_lrcomb( stdout , brlcad_name , &head , 1 , (char *)NULL , (char *)NULL , color , id_no , 0 , 1 , 100 , 0 );
@


1.5
log
@Factored ifdefs
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/proe-g.c,v 1.4 1994/08/05 13:56:52 jra Exp gdurf $";
d223 2
a224 1
			mk_lcomb( stdout , brlcad_name , &head , 0 , (char *)NULL , (char *)NULL , (char *)NULL , 0 );
@


1.4
log
@Added a few more log messages to keep the user abreast of what's happening.
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/proe-g.c,v 1.3 94/08/04 09:53:39 jra Exp $";
d31 1
d35 1
d37 3
d41 1
@


1.3
log
@Eliminate use of object type and path. Use Pro/E pointer as identifier.
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /n/wolf/m/cad/conv/RCS/proe-g.c,v 1.2 94/08/02 10:47:44 jra Exp Locker: jra $";
d405 1
d408 1
d427 2
d430 1
d433 1
@


1.2
log
@Use normal information to get correct face orientations
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/proe-g.c,v 1.1 94/07/22 16:56:47 jra Exp $";
d53 1
d68 2
a69 1
	char name[80],type[10],path[256];
d76 2
a77 2
Add_new_name( name , type , path )
char *name,*type,*path;
d86 1
a86 1
	ptr = (struct name_conv_list *)rt_malloc( sizeof( struct name_conv_list ) , "Get_unique_name: prev->next" );
d89 1
a89 2
	strcpy( ptr->type , type );
	strcpy( ptr->path , path );
d120 2
a121 2
Get_unique_name( name , type , path )
char *name,*type,*path;
d128 1
a128 1
		name_root = Add_new_name( name , type , path );
d139 3
a141 10
			found = 1;

			if( strcmp( name , ptr->name ) )
				found = 0;
			else if( strcmp( type , ptr->type ) )
				found = 0;
			else if( strcmp( path , ptr->path ) )
				found = 0;

			if( !found )
d150 1
a150 1
			prev->next = Add_new_name( name , type , path );
d167 1
a167 2
	char type[10];
	char path[256];
d169 1
a169 2
	char memb_type[10];
	char memb_path[256];
d197 2
a198 7
	/* get type */
	i = (-1);
	while( isspace( line[++start] ) && line[start] != '\0' );
	start--;
	while( !isspace( line[++start] ) && line[start] != '\0' )
		type[++i] = line[start];
	type[++i] = '\0';
d200 1
a200 7
	/* get path */
	i = (-1);
	while( isspace( line[++start] ) && line[start] != '\0' );
	start--;
	while( !isspace( line[++start] ) && line[start] != '\0' )
		path[++i] = line[start];
	path[++i] = '\0';
d202 3
d214 3
a216 1
			brlcad_name = Get_unique_name( name , type , path );
a229 6
			while( isspace( line1[++start] ) && line1[start] != '\0' );
			i = (-1);
			start--;
			while( !isspace( line1[++start] ) && line1[start] != '\0' )
				memb_type[++i] = line1[start];
			memb_type[++i] = '\0';
d231 1
a231 6
			while( isspace( line1[++start] ) && line1[start] != '\0' );
			i = (-1);
			start--;
			while( !isspace( line1[++start] ) && line1[start] != '\0' )
				memb_path[++i] = line1[start];
			memb_path[++i] = '\0';
d233 3
a235 1
			brlcad_name = Get_unique_name( memb_name , memb_type , memb_path );
d267 1
a267 2
	char type[10];
	char path[256];
d311 2
a312 7
	/* get type */
	i = (-1);
	while( isspace( line[++start] ) && line[start] != '\0' );
	start--;
	while( !isspace( line[++start] ) && line[start] != '\0' )
		type[++i] = line[start];
	type[++i] = '\0';
d314 1
a314 7
	/* get path */
	i = (-1);
	while( isspace( line[++start] ) && line[start] != '\0' );
	start--;
	while( !isspace( line[++start] ) && line[start] != '\0' )
		path[++i] = line[start];
	path[++i] = '\0';
d316 3
d418 2
d436 3
a438 1
	brlcad_name = Get_unique_name( name , type , path );
d478 1
a478 1
	while ((c = getopt(argc, argv, "x:X:p")) != EOF) {
d480 3
@


1.1
log
@Initial revision
@
text
@d28 1
a28 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-nmg.c,v 1.1 94/01/07 13:01:59 jra Exp $";
d35 1
d53 1
a53 1
static char *usage="proe-g < proe_file.brl > output.g\n\
d55 2
a56 1
	and output.g is the name of a BRL-CAD database file\n";
d64 6
a69 1
#define	MAX_LINE_LEN	256
d71 94
d172 7
a178 2
	char name[NAMESIZE+1];
	char memb_name[NAMESIZE+1];
d181 1
d185 8
a192 2
	start = 7;
	while( isspace( line[++start] ) );
d194 3
a196 2
	strncpy( name , &line[start] , NAMESIZE );
	name[NAMESIZE] = '\0';
d198 23
d223 5
a227 1
		if( !strncmp( line1 , "endassembly" , 11 ) )
d229 3
a231 1
			mk_lcomb( stdout , name , &head , 0 , (char *)NULL , (char *)NULL , (char *)NULL , 0 );
d234 1
a234 1
		else if( !strncmp( line1 , " member" , 7 ) )
d236 24
a259 5
			start = 6;
			while( isspace( line1[++start] ) );
			strncpy( memb_name , &line1[start] , NAMESIZE );
			memb_name[NAMESIZE] = '\0';
			wmem = mk_addmember( memb_name , &head , WMOP_UNION );
d261 1
a261 1
		else if( !strncmp( line1 , " matrix" , 7 ) )
d289 3
a291 1
	char name[NAMESIZE+1];
d303 1
d306 1
d315 8
a322 4
	start = 5;
	while( isspace( line[++start] ) );
	strcpy( name , &line[start] );
	name[NAMESIZE] = '\0';
d324 27
d363 12
d382 1
d414 4
a417 1
			for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d419 1
a419 4
				plane_t pl;

				area = nmg_loop_plane_area( lu , pl );
				if( area > 0.0 )
d421 2
a422 1
					if( lu->orientation == OT_OPPOSITE )
d424 1
a424 2
					nmg_face_g( fu , pl );
					break;
d426 1
a441 2
	nmg_fix_normals( s , &tol );

d443 1
d446 1
a446 1
	nmg_rebound( m , &tol );
d448 2
a449 1
	nmg_model_vertex_fuse( m , &tol );
d465 4
a468 1
	mk_lrcomb( stdout , name , &head , 1 , (char *)NULL , (char *)NULL , color , id_no , 0 , 1 , 100 , 0 );
@
