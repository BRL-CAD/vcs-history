head	11.29;
access;
symbols
	ansi-20040405-merged:11.24.2.2
	postmerge-20040405-ansi:11.27
	premerge-20040404-ansi:11.26
	postmerge-autoconf:11.26
	autoconf-freeze:11.24.10.3
	premerge-autoconf:11.26
	ansi-20040316-freeze:11.24.2.1
	postmerge-20040315-windows:11.26
	premerge-20040315-windows:11.26
	windows-20040315-freeze:11.24.4.1
	autoconf-20031203:11.24.10.1
	autoconf-20031202:11.24
	autoconf-branch:11.24.0.10
	phong-branch:11.24.0.8
	photonmap-branch:11.24.0.6
	rel-6-1-DP:11.24
	windows-branch:11.24.0.4
	rel-6-0-2:11.22
	ansi-branch:11.24.0.2
	rel-6-0-1-branch:11.22.0.2
	hartley-6-0-post:11.23
	hartley-6-0-pre:11.22
	rel-6-0-1:11.22
	rel-6-0:11.21
	rel-5-4:11.13
	offsite-5-3-pre:11.19
	rel-5-3:11.13
	rel-5-2:11.13
	rel-5-1-branch:11.13.0.2
	rel-5-1:11.13
	rel-5-0:11.10
	rel-5-0-beta:11.9
	rel-4-5:11.9
	ctj-4-5-post:11.9
	ctj-4-5-pre:11.9
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.29
date	2004.05.24.04.16.11;	author morrison;	state dead;
branches;
next	11.28;

11.28
date	2004.05.10.15.30.41;	author erikg;	state Exp;
branches;
next	11.27;

11.27
date	2004.04.05.07.49.36;	author morrison;	state Exp;
branches;
next	11.26;

11.26
date	2003.11.06.19.48.20;	author jra;	state Exp;
branches;
next	11.25;

11.25
date	2003.11.06.19.20.48;	author jra;	state Exp;
branches;
next	11.24;

11.24
date	2002.08.20.17.07.21;	author jra;	state Exp;
branches
	11.24.2.1
	11.24.4.1
	11.24.10.1;
next	11.23;

11.23
date	2002.08.15.20.54.33;	author hartley;	state Exp;
branches;
next	11.22;

11.22
date	2002.05.17.12.48.56;	author morrison;	state Exp;
branches;
next	11.21;

11.21
date	2001.08.10.21.22.52;	author butler;	state Exp;
branches;
next	11.20;

11.20
date	2001.05.17.20.03.13;	author morrison;	state Exp;
branches;
next	11.19;

11.19
date	2000.10.19.19.19.44;	author butler;	state Exp;
branches;
next	11.18;

11.18
date	2000.09.13.12.53.23;	author jra;	state Exp;
branches;
next	11.17;

11.17
date	2000.09.09.04.52.24;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	2000.08.24.03.05.14;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	2000.07.12.21.59.34;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	2000.07.10.23.53.55;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	2000.03.29.18.15.12;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	2000.03.29.18.07.43;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	99.12.30.18.23.09;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	99.06.03.21.54.19;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	96.07.12.13.20.17;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	95.03.24.13.26.29;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	95.03.17.15.49.54;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	95.03.08.10.54.32;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	95.03.03.15.19.33;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	95.01.24.10.08.54;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.01.19.09.25.39;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.01.18.10.57.24;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.59.25;	author mike;	state Rel4_4;
branches;
next	1.10;

1.10
date	94.11.08.04.06.16;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	94.11.01.06.51.37;	author butler;	state Exp;
branches;
next	1.8;

1.8
date	94.10.14.15.26.34;	author jra;	state Exp;
branches;
next	1.7;

1.7
date	94.08.10.23.49.39;	author gdurf;	state Exp;
branches;
next	1.6;

1.6
date	94.04.19.18.50.18;	author jra;	state Exp;
branches;
next	1.5;

1.5
date	94.03.21.13.30.55;	author jra;	state Exp;
branches;
next	1.4;

1.4
date	94.03.18.10.30.34;	author jra;	state Exp;
branches;
next	1.3;

1.3
date	93.12.01.15.19.55;	author jra;	state Exp;
branches;
next	1.2;

1.2
date	93.12.01.15.10.32;	author jra;	state Exp;
branches;
next	1.1;

1.1
date	93.12.01.15.00.33;	author jra;	state Exp;
branches;
next	;

11.24.2.1
date	2002.09.19.18.00.35;	author morrison;	state Exp;
branches;
next	11.24.2.2;

11.24.2.2
date	2004.03.17.21.15.55;	author morrison;	state Exp;
branches;
next	;

11.24.4.1
date	2004.03.11.23.40.29;	author morrison;	state Exp;
branches;
next	;

11.24.10.1
date	2003.12.03.16.24.02;	author erikg;	state Exp;
branches;
next	11.24.10.2;

11.24.10.2
date	2004.02.12.19.24.23;	author erikg;	state Exp;
branches;
next	11.24.10.3;

11.24.10.3
date	2004.03.15.14.06.07;	author erikg;	state Exp;
branches;
next	;


desc
@Euclid "decoded" file converter to BRL-CAD
@


11.29
log
@moved to src/conv/
@
text
@/*
 *			E U C L I D - G . C
 *
 *  Program to convert Euclid file into a BRL-CAD NMG object.
 *
 *  Authors -
 *	Michael Markowski
 *	John R. Anderson
 *  
 *  Source -
 *	The US Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimitied.
 */
#ifndef lint
static const char RCSid[] = "$Header: /n/xoff/cvs/brlcad/conv/euclid-g.c,v 11.28 2004/05/10 15:30:41 erikg Exp $";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "nmg.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "rtlist.h"
#include "wdb.h"
#include "../librt/debug.h"

#define BRLCAD_TITLE_LENGTH	72
#define MAX_FACES_PER_REGION	8192
#define MAX_PTS_PER_FACE	8192

#define MAX(A, B) ((A) > (B) ? (A) : (B))

#define inout(_i,_j)	in_out[_i*shell_count + _j]
#define OUTSIDE		1
#define INSIDE		(-1)
#define OUTER_SHELL	0x00000001
#define	INNER_SHELL	0x00000002
#define INVERT_SHELL	0x00000004

struct vlist {
	fastf_t		pt[3*MAX_PTS_PER_FACE];
	struct vertex	*vt[MAX_PTS_PER_FACE];
};

void euclid_to_brlcad(FILE *fpin, struct rt_wdb *fpout);
int find_vert(struct vlist *vert, int nv, fastf_t x, fastf_t y, fastf_t z);
int store_vert(struct vlist *vert, int *nv, fastf_t x, fastf_t y, fastf_t z);
int read_euclid_face(int *lst, int *ni, FILE *fp, struct vlist *vert, int *nv);
int cvt_euclid_region(FILE *fp, struct rt_wdb *fpdb, int reg_id);

extern int errno;


struct bu_ptbl groups[11];

static int polysolids;
static int debug;
static char	usage[] = "Usage: %s [-v] [-i euclid_db] [-o brlcad_db] [-d tolerance] [-p] [-xX lvl]\n\t\t(-p indicates write as polysolids)\n ";
static struct bn_tol  tol;

void
Find_loop_crack(struct shell *s)
{
	struct faceuse *fu;

	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
	{
		struct loopuse *lu;

		for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
		{
			struct edgeuse *eu;
			int found=0;

			if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
				continue;

			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
			{
				struct edgeuse *eu_next;

				eu_next = BU_LIST_PNEXT_CIRC( edgeuse, &eu->l );
				if( eu->vu_p->v_p == eu_next->vu_p->v_p )
				{
					found = 2;
					break;
				}
				eu_next = BU_LIST_PNEXT_CIRC( edgeuse, &eu_next->l );

				if( eu->vu_p->v_p == eu_next->vu_p->v_p )
				{
					found = 1;
					break;
				}
			}

			if( !found )
				continue;

			if( found == 1 )
				bu_log( "Found a crack:\n" );
			else if( found ==2 )
				bu_log( "Found a zero length edge:\n" );
			nmg_pr_fu_briefly( fu, "" );
		}
	}
}

int
main(int argc, char **argv)
{
	char		*bfile, *efile;
	FILE		*fpin;
	struct rt_wdb	*fpout;
	char		title[BRLCAD_TITLE_LENGTH];	/* BRL-CAD database title */
	register int	c;
	int i;

	fpin = stdin;
	efile = NULL;
	bfile = "euclid.g";
	polysolids = 1;
	debug = 0;

        tol.magic = BN_TOL_MAGIC;
        tol.dist = 0.005;
        tol.dist_sq = tol.dist * tol.dist;
        tol.perp = 1e-6;
        tol.para = 1 - tol.perp;


	/* Get command line arguments. */
	while ((c = getopt(argc, argv, "d:vi:o:nx:X:")) != EOF) {
		switch (c) {
		case 'd':
			tol.dist = atof( optarg );
			tol.dist_sq = tol.dist * tol.dist;
			break;
		case 'v':
			debug = 1;
			break;
		case 'i':
			efile = optarg;
			if ((fpin = fopen(efile, "r")) == NULL)
			{
				fprintf(stderr,	"%s: cannot open %s for reading\n",
					argv[0], efile);
				perror( argv[0] );
				exit(1);
			}
			break;
		case 'o':
			bfile = optarg;
			break;
		case 'n':
			polysolids = 0;
			break;
		case 'x':
			sscanf( optarg, "%x", (unsigned int *)&rt_g.debug );
			break;
		case 'X':
			sscanf( optarg, "%x", (unsigned int *)&rt_g.NMG_debug );
			break;
		default:
			fprintf(stderr, usage, argv[0]);
			exit(1);
			break;
		}
	}

	/* Output BRL-CAD database header.  No problem if more than one. */
	if( efile == NULL )
		sprintf( title, "Conversion from EUCLID (tolerance distance = %gmm)", tol.dist );
	else
	{
		char tol_str[BRLCAD_TITLE_LENGTH];
		int title_len,tol_len;

		sprintf( tol_str, " (tolerance distance = %gmm)", tol.dist );
		sprintf( title, "%s", efile );
		title_len = strlen( title );
		tol_len =  strlen( tol_str );
		if( title_len + tol_len > BRLCAD_TITLE_LENGTH )
			strcat( &title[BRLCAD_TITLE_LENGTH-tol_len-1], tol_str );
		else
			strcat( title, tol_str );
	}

	if ((fpout = wdb_fopen(bfile)) == NULL) {
		fprintf(stderr,	"%s: cannot open %s for writing\n",
			argv[0], bfile);
		perror( argv[0] );
		exit(1);
	}

	mk_id( fpout, title );

	for( i=0 ; i<11 ; i++ )
		bu_ptbl_init( &groups[i] , 64, " &groups[i] ");

	euclid_to_brlcad(fpin, fpout);

	fclose(fpin);
	wdb_close(fpout);
	return 0;
}

/*
 *	A d d _ N M G _ t o _ D b
 *
 *	Write the nmg to a brl-cad style data base.
 */
static void
add_nmg_to_db(struct rt_wdb *fpout, struct model *m, int reg_id)
{
	char	id[80], *rname, *sname;
	int gift_ident;
	int group_id;
	struct nmgregion *r;
	struct shell *s;
	struct wmember head;

	BU_LIST_INIT( &head.l );

	r = BU_LIST_FIRST( nmgregion , &m->r_hd );
	s = BU_LIST_FIRST( shell , &r->s_hd );

	sprintf(id, "%d", reg_id);
	rname = malloc(sizeof(id) + 3);	/* Region name. */
	sname = malloc(sizeof(id) + 3);	/* Solid name. */

	sprintf(sname, "%s.s", id);
	if( polysolids )
		mk_bot_from_nmg( fpout , sname , s );
	else
	{
		int something_left=1;

		while( BU_LIST_NOT_HEAD( s, &r->s_hd ) )
		{
			struct shell *next_s;

			next_s = BU_LIST_PNEXT( shell, &s->l );
			if( nmg_simplify_shell( s ) )
			{
				if( nmg_ks( s ) )
				{
					/* we killed it all!!! */
					something_left = 0;
					break;
				}
			}
			s = next_s;
		}
		if( something_left )
			mk_nmg(fpout, sname,  m);		/* Make nmg object. */
	}

	gift_ident = reg_id % 100000;
	group_id = gift_ident/1000;
	if( group_id > 10 )
		group_id = 10;

	sprintf(rname, "%s.r", id);

	if( mk_addmember( sname, &head.l, NULL, WMOP_UNION ) == WMEMBER_NULL )
	{
		bu_log( "add_nmg_to_db: mk_addmember failed for solid %s\n" , sname );
		rt_bomb( "add_nmg_to_db: FAILED\n" );
	}

	if( mk_lrcomb( fpout, rname, &head, 1, (char *)NULL, (char *)NULL,
	    (unsigned char *)NULL, gift_ident, 0, 0, 100, 0 ) )
	{
		bu_log( "add_nmg_to_db: mk_rlcomb failed for region %s\n" , rname );
		rt_bomb( "add_nmg_to_db: FAILED\n" );
	}

	bu_ptbl_ins( &groups[group_id] , (long *)rname );

	bu_free( (char *)sname , "euclid-g: solid name" );
}

static void
build_groups(struct rt_wdb *fpout)
{
	int i,j;
	struct wmember head;
	struct wmember head_all;
	char group_name[18];

	BU_LIST_INIT( &head.l );
	BU_LIST_INIT( &head_all.l );

	for( i=0 ; i<11 ; i++ )
	{

		if( BU_PTBL_END( &groups[i] ) < 1 )
			continue;

		for( j=0 ; j<BU_PTBL_END( &groups[i] ) ; j++ )
		{
			char *region_name;

			region_name = (char *)BU_PTBL_GET( &groups[i] , j );
			if( mk_addmember( region_name , &head.l , NULL, WMOP_UNION ) == WMEMBER_NULL )
			{
				bu_log( "build_groups: mk_addmember failed for region %s\n" , region_name );
				rt_bomb( "build_groups: FAILED\n" );
			}
		}

		if( i < 10 )
			sprintf( group_name , "%dxxx_series" , i );
		else
			sprintf( group_name , "ids_over_9999" );

		j = mk_lfcomb( fpout , group_name , &head , 0 )
		if( j )
		{
			bu_log( "build_groups: mk_lcomb failed for group %s\n" , group_name );
			rt_bomb( "build_groups: mk_lcomb FAILED\n" );
		}

		if( mk_addmember( group_name , &head_all.l , NULL, WMOP_UNION ) == WMEMBER_NULL )
		{
			bu_log( "build_groups: mk_addmember failed for group %s\n" , group_name );
			rt_bomb( "build_groups: FAILED\n" );
		}
	}

	j = mk_lfcomb( fpout , "all" , &head_all , 0 )
	if( j )
		rt_bomb( "build_groups: mk_lcomb failed for group 'all'\n" );
}

/*
 *	E u c l i d _ t o _ B r l C a d
 *
 *	Convert a Euclid data base into a BRL-CAD data base.  This might or
 *	might not be correct, but a Euclid data base of faceted objects is
 *	assumed to be an ascii file of records of the following form:
 *
 *		RID FT A? B? NPT
 *		I0 X0 Y0 Z0
 *		I1 X1 Y1 Z1
 *	    	...
 *		Inpt Xnpt Ynpt Znpt
 *		Ip A B C D
 *
 *	where RID is an integer closed region id number,
 *
 *		FT is the facet type with the following values:
 *		   0: simple facet (no holes).
 *		   1: this facet is a hole.
 *		   2: this is a surface facet which will be given holes.
 *
 *		A? B? are unknown variables.
 *
 *		NPT is the number of data point coordinates which will follow.
 *
 *		Ij is a data point index number.
 *
 *		Xi Yi Zi are data point coordinates in mm.
 *
 *		A, B, C, D are the facet's plane equation coefficients and
 *		<A B C> is an outward pointing surface normal.
 */
void
euclid_to_brlcad(FILE *fpin, struct rt_wdb *fpout)
{
	char	str[80];
	int	reg_id;

	/* skip first string in file (what is it??) */
	if( fscanf( fpin , "%s" , str ) == EOF )
		rt_bomb( "Failed on first attempt to read input" );

	/* Id of first region. */
	if (fscanf(fpin, "%d", &reg_id) != 1) {
		fprintf(stderr, "euclid_to_brlcad: no region id\n");
		exit(1);
	}

	/* Convert each region to an individual nmg. */
	do {
		fprintf( stderr , "Converting region %d...\n", reg_id);
		reg_id = cvt_euclid_region(fpin, fpout, reg_id);
	} while (reg_id != -1);

	/* Build groups based on idents */
	build_groups( fpout );
}

#if 0
static void
add_shells_to_db( fpout, shell_count, shells, reg_id )
struct rt_wdb *fpout;
int shell_count;
struct shell *shells[];
int reg_id;
{
	struct model *m=(struct model *)NULL;
	char sol_name[80];
	char *reg_name;
	struct wmember head;
	int solid_no=0;
	int shell_no;
	int gift_ident, group_id;

	BU_LIST_INIT( &head.l );

	for( shell_no=0 ; shell_no < shell_count ; shell_no++ )
	{
		if( !shells[shell_no] )
			continue;

		NMG_CK_SHELL( shells[shell_no] );

		if( !m )
			m = nmg_find_model( &shells[shell_no]->l.magic );

		solid_no++;
		sprintf( sol_name , "%d.%d.s", reg_id, solid_no );

		if( mk_addmember( sol_name, &head.l, NULL, WMOP_UNION ) == WMEMBER_NULL )
		{
			bu_log( "add_shells_to_db: mk_addmember failed for solid %s\n" , sol_name );
			rt_bomb( "add_shells_to_db: FAILED\n" );
		}

		if( polysolids )
			mk_bot_from_nmg( fpout, sol_name, shells[shell_no] );
		else
		{
			struct model *m_tmp;
			struct nmgregion *r_tmp;
			struct shell *s=shells[shell_no];

			/* Move this shell to a seperate model and write to .g file */
			m_tmp = nmg_mmr();
			r_tmp = BU_LIST_FIRST( nmgregion , &m_tmp->r_hd );
			BU_LIST_DEQUEUE( &s->l );
			s->r_p = r_tmp;
			BU_LIST_APPEND( &r_tmp->s_hd, &s->l )

			nmg_m_reindex( m_tmp , 0 );

			nmg_rebound( m_tmp, &tol );

			mk_nmg( fpout , sol_name, m_tmp );

			nmg_km( m_tmp );

		}
	}

	nmg_m_reindex( m , 0 );

	gift_ident = reg_id % 100000;
	group_id = gift_ident/1000;
	if( group_id > 10 )
		group_id = 10;

	reg_name = (char *)bu_malloc( strcspn( sol_name, "." ) + 3, "reg_name" );
	sprintf( reg_name, "%d.r", reg_id );
	if( mk_lrcomb( fpout, reg_name, &head, 1, (char *)NULL, (char *)NULL,
	    (unsigned char *)NULL, gift_ident, 0, 0, 100, 0 ) )
	{
		bu_log( "add_nmg_to_db: mk_rlcomb failed for region %s\n" , reg_name );
		rt_bomb( "add_nmg_to_db: FAILED\n" );
	}

	bu_ptbl_ins( &groups[group_id] , (long *)reg_name );
}
#endif

/*
 *	R e a d _ E u c l i d _ R e g i o n
 *
 *	Make a list of indices into global vertex coordinate array.
 *	This list represents the face under construction.
 */
int
cvt_euclid_region(FILE *fp, struct rt_wdb *fpdb, int reg_id)
{
	int	cur_id, face, facet_type, i, lst[MAX_PTS_PER_FACE], np, nv;
	int hole_face = -4200;
	struct faceuse	*outfaceuses[MAX_PTS_PER_FACE];
	struct model	*m;	/* Input/output, nmg model. */
	struct nmgregion *r;
	struct shell	*s;
	struct faceuse	*fu;
	struct vertex	*vertlist[MAX_PTS_PER_FACE];
	struct vlist	vert;

	m = nmg_mm();		/* Make nmg model. */
	r = nmg_mrsv(m);	/* Make region, empty shell, vertex. */
	s = BU_LIST_FIRST(shell, &r->s_hd);

	nv = 0;			/* Initially no vertices for this region. */
	face = 0;		/* No faces either. */
	/* Grab all the faces for one region. */
	do {
		/* Get vertices for a single face. */
		facet_type = read_euclid_face(lst, &np, fp, &vert, &nv);

		if( np > 2 )
		{

			/* Make face out of vertices in lst. */
			for (i = 0; i < np; i++)
				vertlist[i] = vert.vt[lst[i]];

			switch(facet_type) {
			case 0:	/* Simple facet (no holes). */
				if( debug )
				{
					bu_log( "Making simple face:\n" );
					for( i=0; i<np; i++ )
						bu_log( "\t( %g %g %g )\n" , V3ARGS( &vert.pt[lst[i]*3] ));
				}
				outfaceuses[face] = nmg_cface(s, vertlist, np);
				face++;
				break;

			case 1:	/* Facet is a hole. */
				if( debug )
				{
					bu_log( "Making a hole:\n" );
					for( i=0; i<np; i++ )
						bu_log( "\t( %g %g %g )\n" , V3ARGS( &vert.pt[lst[i]*3] ));
				}
				nmg_add_loop_to_face(s, outfaceuses[hole_face],
					vertlist, np, OT_OPPOSITE);
				break;

			case 2:	/* Facet will be given at least one hole. */
				if( debug )
				{
					bu_log( "Making face which will get a hole:\n" );
					for( i=0; i<np; i++ )
						bu_log( "\t( %g %g %g )\n" , V3ARGS( &vert.pt[lst[i]*3] ));
				}
				outfaceuses[face] = nmg_cface(s, vertlist, np);
				hole_face = face;
				face++;
				break;

			default:
				fprintf(stderr, "cvt_euclid_face: in region %d, face %d is an unknown facet type\n", reg_id, face);
				break;
			}

			/* Save (possibly) newly created vertex structs. */
			for (i = 0; i < np; i++)
				vert.vt[lst[i]] = vertlist[i];
		}

		/* Get next face's region id. */
		if (fscanf(fp, "%d", &cur_id) != 1)
			cur_id = -1;
	} while (reg_id == cur_id);

	if( RT_G_DEBUG&DEBUG_MEM_FULL )
		bu_prmem( "After building faces:\n" );

	/* Associate the vertex geometry, ccw. */
	if( debug )
		bu_log( "Associating vertex geometry:\n" );
	for (i = 0; i < nv; i++)
	{
		if (vert.vt[i])
		{
			if( debug )
				bu_log( "\t( %g %g %g )\n" , V3ARGS( &vert.pt[3*i] ) );
			nmg_vertex_gv(vert.vt[i], &vert.pt[3*i]);
		}
	}

	if( debug )
		bu_log( "Calling nmg_model_vertex_fuse()\n" );
	(void)nmg_model_vertex_fuse( m, &tol );

	/* Break edges on vertices */
	if( debug )
		bu_log( "Calling nmg_model_break_e_on_v()\n" );
	(void)nmg_model_break_e_on_v( m, &tol );

	/* kill zero length edgeuses */
	if( nmg_kill_zero_length_edgeuses( m ) )
	{
		nmg_km( m );
		m = (struct model *)NULL;
		return( cur_id );
	}

	/* kill cracks */
	s = BU_LIST_FIRST( shell , &r->s_hd );
	if( nmg_kill_cracks( s ) )
	{
		if( nmg_ks( s ) )
		{
			nmg_km( m );
			m = (struct model *)0;
		}
		s = (struct shell *)0;
	}

	if( !m )
		return( cur_id );

	if( RT_G_DEBUG&DEBUG_MEM_FULL )
		bu_prmem( "Before assoc face geom:\n" );

	/* Associate the face geometry. */
	if( debug )
		bu_log( "Associating face geometry:\n" );
	for (i = 0; i < face; i++)
	{
		/* skip faceuses that were killed */
		if( outfaceuses[i]->l.magic != NMG_FACEUSE_MAGIC )
			continue;

		/* calculate plane for this faceuse */
		if( nmg_calc_face_g( outfaceuses[i] ) )
		{
			bu_log( "nmg_calc_face_g failed\n" );
			nmg_pr_fu_briefly( outfaceuses[i], "" );
		}
	}

	/* Compute "geometry" for model, region, and shell */
	if( debug )
		bu_log( "Rebound\n" );
	nmg_rebound( m , &tol );

#if 0
	/* Break edges on vertices */
	if( debug )
		bu_log( "Calling nmg_model_break_e_on_v()\n" );
	(void)nmg_model_break_e_on_v( m, &tol );

	/* kill cracks */
	s = BU_LIST_FIRST( shell , &r->s_hd );
	if( nmg_kill_cracks( s ) )
	{
		if( nmg_ks( s ) )
		{
			nmg_km( m );
			m = (struct model *)0;
		}
		s = (struct shell *)0;
	}

	if( !m )
		return( cur_id );

	/* kill zero length edgeuses */
	if( nmg_kill_zero_length_edgeuses( m ) )
	{
		nmg_km( m );
		m = (struct model *)NULL;
		return( cur_id );
	}
#endif

	if( RT_G_DEBUG&DEBUG_MEM_FULL )
		bu_prmem( "Before glueing faces:\n" );

	/* Glue faceuses together. */
	if( debug )
		bu_log( "Glueing faces\n" );
	(void)nmg_model_edge_fuse( m, &tol );

	/* Compute "geometry" for model, region, and shell */
	if( debug )
		bu_log( "Rebound\n" );
	nmg_rebound( m , &tol );

	/* fix the normals */
	if( debug )
		bu_log( "Fix normals\n" );
	nmg_fix_normals( s, &tol );

	if( RT_G_DEBUG&DEBUG_MEM_FULL )
		bu_prmem( "After fixing normals:\n" );

	if( debug )
		bu_log( "nmg_s_join_touchingloops( %x )\n", s );
	nmg_s_join_touchingloops( s, &tol );

	/* kill cracks */
	s = BU_LIST_FIRST( shell , &r->s_hd );
	if( nmg_kill_cracks( s ) )
	{
		if( nmg_ks( s ) )
		{
			nmg_km( m );
			m = (struct model *)0;
		}
		s = (struct shell *)0;
	}

	if( !m )
		return( cur_id );

	if( debug )
		bu_log( "nmg_s_split_touchingloops( %x )\n", s );
	nmg_s_split_touchingloops( s, &tol);

	/* kill cracks */
	s = BU_LIST_FIRST( shell , &r->s_hd );
	if( nmg_kill_cracks( s ) )
	{
		if( nmg_ks( s ) )
		{
			nmg_km( m );
			m = (struct model *)0;
		}
		s = (struct shell *)0;
	}

	if( !m )
		return( cur_id );

	/* verify face plane calculations */
	if( debug )
	{
		nmg_stash_model_to_file( "before_tri.g", m, "before_tri" );
		bu_log( "Verify plane equations:\n" );
	}

	if( RT_G_DEBUG&DEBUG_MEM_FULL )
		bu_prmem( "Before nmg_make_faces_within_tol():\n" );

	nmg_make_faces_within_tol( s, &tol );

	if( RT_G_DEBUG&DEBUG_MEM_FULL )
		bu_prmem( "After nmg_make_faces_within_tol():\n" );

	if( debug )
	{
		bu_log( "Checking faceuses:\n" );
		for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
		{
			struct loopuse *lu;
			struct edgeuse *eu;
			struct vertexuse *vu;
			fastf_t dist_to_plane;
			plane_t pl;

			NMG_CK_FACEUSE( fu );

			if( fu->orientation != OT_SAME )
				continue;

			NMG_GET_FU_PLANE( pl, fu );

			if( debug )
				bu_log( "faceuse x%x ( %g %g %g %g )\n", fu, V4ARGS( pl ) );

			/* check if all the vertices for this face lie on the plane */
			for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
			{
				NMG_CK_LOOPUSE( lu );

				if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )
				{
					vu = BU_LIST_FIRST( vertexuse, &lu->down_hd );
					dist_to_plane = DIST_PT_PLANE( vu->v_p->vg_p->coord, pl );
					if( dist_to_plane > tol.dist || dist_to_plane < -tol.dist )
						bu_log( "\tvertex x%x ( %g %g %g ) is %g off plane\n",
							vu->v_p, V3ARGS( vu->v_p->vg_p->coord ), dist_to_plane );
				}
				else
				{
					for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
					{
						NMG_CK_EDGEUSE( eu );
						vu = eu->vu_p;
						dist_to_plane = DIST_PT_PLANE( vu->v_p->vg_p->coord, pl );
						if( dist_to_plane > tol.dist || dist_to_plane < -tol.dist )
							bu_log( "\tvertex x%x ( %g %g %g ) is %g off plane\n",
								vu->v_p, V3ARGS( vu->v_p->vg_p->coord ), dist_to_plane );
					}
				}
			}
		}
	}

	if( debug )
		bu_log( "%d vertices out of tolerance after fixing out of tolerance faces\n" , nmg_ck_geometry( m , &tol ) );
#if 0
	/* Fuse */
	if( debug )
	{
		nmg_stash_model_to_file( "before_fuse.g", m, "before_fuse" );
		bu_log( "Fuse model:\n" );
	}
	i = nmg_model_fuse( m, &tol );
	if( debug )
		bu_log( "\t%d objects fused\n" , i );
#endif

	nmg_s_join_touchingloops( s, &tol );
	nmg_s_split_touchingloops( s, &tol);

#if 0
	/* if the shell we just built has a void shell inside, nmg_fix_normals will
	 * point the normals of the void shell in the wrong direction. This section
	 * of code looks for such a situation and reverses the normals of the void shell
	 *
	 * first decompose the shell into maximally connected shells
	 */
	if( (shell_count = nmg_decompose_shell( s , &tol )) > 1 )
	{
		/* This shell has more than one part */
		struct shell **shells;
		struct bu_ptbl verts;
		int shell1_no, shell2_no, outer_shell_count=0;
		short *in_out;
		short *shell_inout;

		shell_inout = (short *)bu_calloc( shell_count, sizeof( short ), "shell_inout" );
		in_out = (short *)bu_calloc( shell_count * shell_count , sizeof( short ) , "in_out" );

		bu_ptbl_init( &verts , 64, " &verts ");

		shells = (struct shell **)bu_calloc( shell_count, sizeof( struct shell *), "shells" );

		/* fuse geometry */
		(void)nmg_model_vertex_fuse( m, &tol );

		i = 0;

		if( debug )
			bu_log( "\nShell decomposed into %d sub-shells\n", shell_count );


		/* insure that bounding boxes are available
		 * and that all the shells are closed.
		 */
		shell1_no = (-1);
		for( BU_LIST_FOR( s , shell , &r->s_hd ) )
		{
			shells[++shell1_no] = s;
			if( !s->sa_p )
				nmg_shell_a( s , &tol );

			if( nmg_check_closed_shell( s , &tol ) )
			{
				bu_log( "Warning: Region %d is not a closed surface\n" , reg_id );
				bu_log( "\tCreating new faces to close region\n" );
				nmg_close_shell( s , &tol );
				if( nmg_check_closed_shell( s , &tol ) )
					rt_bomb( "Cannot close shell\n" );
			}
		}

		shell1_no = (-1);
		for( BU_LIST_FOR( s, shell , &r->s_hd ) )
		{
			struct shell *s2;
			int outside=0;
			int inside=0;

			shell1_no++;

			nmg_vertex_tabulate( &verts, &s->l.magic );

			shell2_no = (-1);
			for( BU_LIST_FOR( s2 , shell , &r->s_hd ) )
			{
				int j;
				int in=0;
				int on=0;
				int out=0;

				shell2_no++;

				if( s2 == s )
					continue;

				for( j=0 ; j<BU_PTBL_END( &verts ) ; j++ )
				{
					struct vertex *v;

					v = (struct vertex *)BU_PTBL_GET( &verts , j );
					NMG_CK_VERTEX( v );

					if( nmg_find_v_in_shell( v, s2, 1 ) )
					{
						on++;
						continue;
					}

					switch( nmg_class_pt_s(v->vg_p->coord, s2, &tol) )
					{
						case NMG_CLASS_AinB:
							in++;
							break;
						case NMG_CLASS_AonBshared:
							on++;
							break;
						case NMG_CLASS_AoutB:
							out++;
							break;
						default:
							rt_bomb( "UNKNOWN CLASS!!!\n" );
							break;
					}
				}

				if( out > in )
					inout( shell1_no, shell2_no ) = OUTSIDE;
				else
					inout( shell1_no, shell2_no ) = INSIDE;

			}

			bu_ptbl_reset( &verts );
		}

		bu_ptbl_free( &verts);

		/* determine which shells are outer shells, which are inner,
		 * and which must be inverted
		 */
		for( shell1_no=0 ; shell1_no < shell_count ; shell1_no++ )
		{
			int outers=0,inners=0;

			shell_inout[shell1_no] = 0;
			for( shell2_no=0 ; shell2_no < shell_count ; shell2_no++ )
			{

				if( shell1_no == shell2_no )
					continue;

				if( inout( shell1_no, shell2_no ) == OUTSIDE )
					outers++;
				else if( inout( shell1_no, shell2_no ) == INSIDE )
					inners++;
			}

			if( outers && !inners )
				shell_inout[shell1_no] |= OUTER_SHELL;
			if( inners )
				shell_inout[shell1_no] |= INNER_SHELL;
			if( inners%2 )
			{
				shell_inout[shell1_no] |= INVERT_SHELL;
				nmg_invert_shell( shells[shell1_no], &tol );
			}
		}

		/* join inner shells to outer shells */
		for( shell1_no=0 ; shell1_no < shell_count ; shell1_no++ )
		{
			struct shell *outer_shell=(struct shell *)NULL;

			if( shell_inout[shell1_no] & OUTER_SHELL )
				continue;

			if( !shell_inout[shell1_no] & INNER_SHELL )
				rt_bomb( "Found a shell that is neither inner nor outer!!!\n" );

			/* Look for an outer shell to take this inner shell */
			for( shell2_no=0 ; shell2_no < shell_count ; shell2_no++ )
			{
				if( shell2_no == shell1_no )
					continue;

				if( !shells[shell2_no] )
					continue;

				if( inout( shell1_no, shell2_no ) == INSIDE &&
					shell_inout[shell2_no] & OUTER_SHELL )
				{
					outer_shell = shells[shell2_no];
					break;
				}

			}
			if( !outer_shell )
				rt_bomb( "Cannot find outer shell for inner shell!!!\n" );

			/* Place this inner shell in the outer shell */
			nmg_js( outer_shell, shells[shell1_no], &tol );
			shells[shell1_no] = (struct shell *)NULL;
		}

		/* Check and count the outer shells */
		for( shell1_no=0 ; shell1_no < shell_count ; shell1_no++ )
		{
			if( !shells[shell1_no] )
				continue;

			if( shell_inout[shell1_no] & INNER_SHELL )
				rt_bomb( "An inner shell was not placed in an outer shell!!\n" );

			outer_shell_count++;
		}

		if( outer_shell_count < 1 )
			rt_bomb( "No shells!!!!\n" );
		else if( outer_shell_count == 1 )
			add_nmg_to_db( fpdb, m, reg_id );
		else
			add_shells_to_db( fpdb, shell_count, shells, reg_id );

		bu_free( (char *)shells, "shells" );
		bu_free( (char *)shell_inout, "shell_inout" );
		bu_free( (char *)in_out, "in_out" );
	}
	else
#endif
	{
		if( debug )
			bu_log( "Writing model to database:\n" );
		add_nmg_to_db( fpdb, m, reg_id );
	}

	nmg_km(m);				/* Safe to kill model now. */

	return(cur_id);
}

/*
 *	R e a d _ E u c l i d _ F a c e
 *
 *	Read in vertices from a Euclid facet file and store them in an
 *	array of nmg vertex structures.  Then make a list of indices of these
 *	vertices in the vertex array.  This list represents the face under
 *	construction.
 *
 *	XXX Fix this!  Only allows set max of points and assumes
 *	no errors during reading...
 */
int
read_euclid_face(int *lst, int *ni, FILE *fp, struct vlist *vert, int *nv)
{
	double	num_points, x, y, z, a, b, c, d;
	int	i, j, k, facet_type;

	/* Description of record. */
	fscanf(fp, "%d %*f %*f %lf", &facet_type, &num_points);
	*ni = (int)num_points;

	if( debug )
		bu_log( "facet type %d has %d points:\n", facet_type,  *ni );
	
	/* Read in data points. */
	for (i = 0; i < *ni; i++)
	{
		fscanf(fp, "%*d %lf %lf %lf", &x, &y, &z);

		if( debug )
			bu_log( "\tpoint #%d ( %g %g %g )\n", i+1, x, y, z );

		if ((lst[i] = find_vert(vert, *nv, x, y, z)) == -1)
		{
			lst[i] = store_vert(vert, nv, x, y, z);
			if( debug )
				bu_log( "\t\tStoring vertex ( %g %g %g ) at index %d\n" , x, y, z, lst[i] );
		}
		else if( debug )
			bu_log( "\t\tFound vertex ( %g %g %g ) at index %d\n" , x, y, z, lst[i] );
	}

	/* Read in plane equation. */
	fscanf(fp, "%*d %lf %lf %lf %lf", &a, &b, &c, &d);
	if( debug )
		bu_log( "plane equation for face is ( %f %f %f %f )\n", a, b, c, d );

	/* Remove duplicate points (XXX this should be improved). */
	for (i = 0; i < *ni; i++)
		for (j = i+1; j < *ni; j++)
			if (lst[i] == lst[j]) {
				int increment;

				if( debug )
					bu_log( "\tComparing vertices at indices lst[%d]=%d and lst[%d]=%d\n", i, lst[i], j, lst[j] );
				
				if( j == i+1 || (i == 0 && j == (*ni-1))  )
					increment = 1;
				else if( j == i+2 )
				{
					j = i+1;
					increment = 2;
				}
				else
				{
					bu_log( "warning: removing distant duplicates\n" );
					increment = 1;
				}

				for (k = j ; k < *ni-increment; k++)
					lst[k] = lst[k + increment];
				*ni -= increment;
			}

	return(facet_type);
}

/*
 *	F i n d _ V e r t
 *
 *	Try to locate a geometric point in the list of vertices.  If found,
 *	return the index number within the vertex array, otherwise return
 *	a -1.
 */
int
find_vert(struct vlist *vert, int nv, fastf_t x, fastf_t y, fastf_t z)
{
	int	found, i;
	point_t new_pt;

	VSET( new_pt, x, y, z );
	found = 0;
	for (i = 0; i < nv; i++)
	{
		if( bn_pt3_pt3_equal( &vert->pt[3*i], new_pt, &tol ) )
		{
			found = 1;
			break;
		}
	}
	if (!found)
		return( -1 );
	else
		return( i );
}

/*
 *	S t o r e _ V e r t
 *
 *	Store vertex in an array of vertices.
 */
int
store_vert(struct vlist *vert, int *nv, fastf_t x, fastf_t y, fastf_t z)
{
	vert->pt[*nv*3+0] = x;
	vert->pt[*nv*3+1] = y;
	vert->pt[*nv*3+2] = z;
	vert->vt[*nv] = (struct vertex *)NULL;

	++*nv;

	if (*nv > MAX_PTS_PER_FACE) {
		fprintf(stderr,
		"read_euclid_face: no more vertex room\n");
		exit(1);
	}

	return(*nv - 1);
}
@


11.28
log
@change conf.h to a wrapped config.h
@
text
@d18 1
a18 1
static const char RCSid[] = "$Header: /cvs/brlcad/conv/euclid-g.c,v 11.27 2004/04/05 07:49:36 morrison Exp $";
@


11.27
log
@merge of ansi-6-0-branch into HEAD
@
text
@d18 1
a18 1
static const char RCSid[] = "$Header$";
d21 5
a25 1
#include "conf.h"
@


11.26
log
@Now produces BOT primitives as default
@
text
@d18 1
a18 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/euclid-g.c,v 11.25 2003/11/06 19:20:48 jra Exp $";
a53 8
void euclid_to_brlcad();
int find_vert();
int store_vert();
int read_euclid_face();
int cvt_euclid_region();

extern int errno;

d59 9
d76 1
a76 2
Find_loop_crack( s )
struct shell *s;
d124 1
a124 3
main(argc, argv)
int	argc;
char	*argv[];
d228 1
a228 4
add_nmg_to_db(fpout, m, reg_id)
struct rt_wdb	*fpout;
struct model	*m;
int		reg_id;
d299 1
a299 2
build_groups( fpout )
struct rt_wdb *fpout;
d384 1
a384 3
euclid_to_brlcad(fpin, fpout)
FILE	*fpin;
struct rt_wdb *fpout;
d499 1
a499 4
cvt_euclid_region(fp, fpdb, reg_id)
FILE	*fp;
struct rt_wdb *fpdb;
int	reg_id;
d1056 1
a1056 4
read_euclid_face(lst, ni, fp, vert, nv)
FILE	*fp;
int	*lst, *ni, *nv;
struct vlist	*vert;
d1129 1
a1129 4
find_vert(vert, nv, x, y, z)
struct vlist	*vert;
int		nv;
fastf_t		x, y, z;
d1156 1
a1156 4
store_vert(vert, nv, x, y, z)
struct vlist	*vert;
int	*nv;
fastf_t	x, y, z;
@


11.25
log
@Now writes BOT primitives rather than polysolids
@
text
@d18 1
a18 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/euclid-g.c,v 11.24 2002/08/20 17:07:21 jra Exp $";
d138 1
a138 1
	polysolids = 0;
d149 1
a149 1
	while ((c = getopt(argc, argv, "d:vi:o:px:X:")) != EOF) {
d171 2
a172 2
		case 'p':
			polysolids = 1;
@


11.24
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d18 1
a18 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/euclid-g.c,v 11.22 2002/05/17 12:48:56 morrison Exp $";
d253 1
a253 1
		write_shell_as_polysolid( fpout , sname , s );
d455 1
a455 1
			write_shell_as_polysolid( fpout, sol_name, shells[shell_no] );
@


11.24.4.1
log
@sync to HEAD...
@
text
@d18 1
a18 1
static const char RCSid[] = "$Header: /n/cad/c/CVS/brlcad/conv/euclid-g.c,v 11.26 2003/11/06 19:48:20 jra Exp $";
d138 1
a138 1
	polysolids = 1;
d149 1
a149 1
	while ((c = getopt(argc, argv, "d:vi:o:nx:X:")) != EOF) {
d171 2
a172 2
		case 'n':
			polysolids = 0;
d253 1
a253 1
		mk_bot_from_nmg( fpout , sname , s );
d455 1
a455 1
			mk_bot_from_nmg( fpout, sol_name, shells[shell_no] );
@


11.24.10.1
log
@updates from HEAD, part 1
@
text
@d18 1
a18 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/euclid-g.c,v 11.26 2003/11/06 19:48:20 jra Exp $";
d138 1
a138 1
	polysolids = 1;
d149 1
a149 1
	while ((c = getopt(argc, argv, "d:vi:o:nx:X:")) != EOF) {
d171 2
a172 2
		case 'n':
			polysolids = 0;
d253 1
a253 1
		mk_bot_from_nmg( fpout , sname , s );
d455 1
a455 1
			mk_bot_from_nmg( fpout, sol_name, shells[shell_no] );
@


11.24.10.2
log
@merge from HEAD
@
text
@@


11.24.10.3
log
@merge from head
@
text
@d18 1
a18 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/euclid-g.c,v 11.24.10.2 2004/02/12 19:24:23 erikg Exp $";
@


11.24.2.1
log
@Initial ANSIfication
@
text
@d18 1
a18 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/euclid-g.c,v 11.24 2002/08/20 17:07:21 jra Exp $";
d54 8
a66 9
void euclid_to_brlcad(FILE *fpin, struct rt_wdb *fpout);
int find_vert(struct vlist *vert, int nv, fastf_t x, fastf_t y, fastf_t z);
int store_vert(struct vlist *vert, int *nv, fastf_t x, fastf_t y, fastf_t z);
int read_euclid_face(int *lst, int *ni, FILE *fp, struct vlist *vert, int *nv);
int cvt_euclid_region(FILE *fp, struct rt_wdb *fpdb, int reg_id);

extern int errno;


d75 2
a76 1
Find_loop_crack(struct shell *s)
d124 3
a126 1
main(int argc, char **argv)
d230 4
a233 1
add_nmg_to_db(struct rt_wdb *fpout, struct model *m, int reg_id)
d304 2
a305 1
build_groups(struct rt_wdb *fpout)
d390 3
a392 1
euclid_to_brlcad(FILE *fpin, struct rt_wdb *fpout)
d507 4
a510 1
cvt_euclid_region(FILE *fp, struct rt_wdb *fpdb, int reg_id)
d1067 4
a1070 1
read_euclid_face(int *lst, int *ni, FILE *fp, struct vlist *vert, int *nv)
d1143 4
a1146 1
find_vert(struct vlist *vert, int nv, fastf_t x, fastf_t y, fastf_t z)
d1173 4
a1176 1
store_vert(struct vlist *vert, int *nv, fastf_t x, fastf_t y, fastf_t z)
@


11.24.2.2
log
@sync branch with HEAD
@
text
@d18 1
a18 1
static const char RCSid[] = "$Header$";
d136 1
a136 1
	polysolids = 1;
d147 1
a147 1
	while ((c = getopt(argc, argv, "d:vi:o:nx:X:")) != EOF) {
d169 2
a170 2
		case 'n':
			polysolids = 0;
d248 1
a248 1
		mk_bot_from_nmg( fpout , sname , s );
d447 1
a447 1
			mk_bot_from_nmg( fpout, sol_name, shells[shell_no] );
@


11.23
log
@Converted from K&R to ANSI C - RFH
@
text
@d54 8
a66 9
void euclid_to_brlcad(FILE *fpin, struct rt_wdb *fpout);
int find_vert(struct vlist *vert, int nv, fastf_t x, fastf_t y, fastf_t z);
int store_vert(struct vlist *vert, int *nv, fastf_t x, fastf_t y, fastf_t z);
int read_euclid_face(int *lst, int *ni, FILE *fp, struct vlist *vert, int *nv);
int cvt_euclid_region(FILE *fp, struct rt_wdb *fpdb, int reg_id);

extern int errno;


d75 2
a76 1
Find_loop_crack(struct shell *s)
d124 3
a126 1
main(int argc, char **argv)
d230 4
a233 1
add_nmg_to_db(struct rt_wdb *fpout, struct model *m, int reg_id)
d304 2
a305 1
build_groups(struct rt_wdb *fpout)
d390 3
a392 1
euclid_to_brlcad(FILE *fpin, struct rt_wdb *fpout)
d507 4
a510 1
cvt_euclid_region(FILE *fp, struct rt_wdb *fpdb, int reg_id)
d1067 4
a1070 1
read_euclid_face(int *lst, int *ni, FILE *fp, struct vlist *vert, int *nv)
d1143 4
a1146 1
find_vert(struct vlist *vert, int nv, fastf_t x, fastf_t y, fastf_t z)
d1173 4
a1176 1
store_vert(struct vlist *vert, int *nv, fastf_t x, fastf_t y, fastf_t z)
@


11.22
log
@added matrix parameter to mk_addmember()
@
text
@d18 1
a18 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/euclid-g.c,v 11.21 2001/08/10 21:22:52 butler Exp $";
a53 8
void euclid_to_brlcad();
int find_vert();
int store_vert();
int read_euclid_face();
int cvt_euclid_region();

extern int errno;

d59 9
d76 1
a76 2
Find_loop_crack( s )
struct shell *s;
d124 1
a124 3
main(argc, argv)
int	argc;
char	*argv[];
d228 1
a228 4
add_nmg_to_db(fpout, m, reg_id)
struct rt_wdb	*fpout;
struct model	*m;
int		reg_id;
d299 1
a299 2
build_groups( fpout )
struct rt_wdb *fpout;
d384 1
a384 3
euclid_to_brlcad(fpin, fpout)
FILE	*fpin;
struct rt_wdb *fpout;
d499 1
a499 4
cvt_euclid_region(fp, fpdb, reg_id)
FILE	*fp;
struct rt_wdb *fpdb;
int	reg_id;
d1056 1
a1056 4
read_euclid_face(lst, ni, fp, vert, nv)
FILE	*fp;
int	*lst, *ni, *nv;
struct vlist	*vert;
d1129 1
a1129 4
find_vert(vert, nv, x, y, z)
struct vlist	*vert;
int		nv;
fastf_t		x, y, z;
d1156 1
a1156 4
store_vert(vert, nv, x, y, z)
struct vlist	*vert;
int	*nv;
fastf_t	x, y, z;
@


11.21
log
@Compiler warning patches
@
text
@d18 1
a18 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/euclid-g.c,v 11.20 2001/05/17 20:03:13 morrison Exp $";
d285 1
a285 1
	if( mk_addmember( sname, &head.l, WMOP_UNION ) == WMEMBER_NULL )
d326 1
a326 1
			if( mk_addmember( region_name , &head.l , WMOP_UNION ) == WMEMBER_NULL )
d345 1
a345 1
		if( mk_addmember( group_name , &head_all.l , WMOP_UNION ) == WMEMBER_NULL )
d448 1
a448 1
		if( mk_addmember( sol_name, &head.l, WMOP_UNION ) == WMEMBER_NULL )
@


11.20
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d18 1
a18 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/euclid-g.c,v 11.19 2000/10/19 19:19:44 butler Exp $";
d175 1
a175 1
			sscanf( optarg, "%x", &rt_g.debug );
d178 1
a178 1
			sscanf( optarg, "%x", &rt_g.NMG_debug );
@


11.19
log
@Changes to compile under RedHat 7.0
@
text
@d18 1
a18 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/euclid-g.c,v 11.18 2000/09/13 12:53:23 jra Exp $";
d590 1
a590 1
	if( rt_g.debug&DEBUG_MEM_FULL )
d638 1
a638 1
	if( rt_g.debug&DEBUG_MEM_FULL )
d693 1
a693 1
	if( rt_g.debug&DEBUG_MEM_FULL )
d711 1
a711 1
	if( rt_g.debug&DEBUG_MEM_FULL )
d759 1
a759 1
	if( rt_g.debug&DEBUG_MEM_FULL )
d764 1
a764 1
	if( rt_g.debug&DEBUG_MEM_FULL )
@


11.18
log
@lint
@
text
@d18 1
a18 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/euclid-g.c,v 11.17 2000/09/09 04:52:24 mike Exp $";
d512 2
a513 2
	int	cur_id, face, facet_type, hole_face, i,
		lst[MAX_PTS_PER_FACE], np, nv;
@


11.17
log
@
lint
@
text
@d18 1
a18 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/euclid-g.c,v 11.16 2000/08/24 03:05:14 mike Exp $";
d55 4
@


11.16
log
@
new mk_addmember
@
text
@d18 1
a18 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/euclid-g.c,v 11.15 2000/07/12 21:59:34 mike Exp $";
d413 1
d494 1
d1068 1
a1068 1
	fastf_t	num_points, x, y, z, a, b, c, d;
d1072 1
a1072 1
	fscanf(fp, "%d %*lf %*lf %lf", &facet_type, &num_points);
@


11.15
log
@
Converted to use new version of LIBWDB
@
text
@d18 1
a18 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/euclid-g.c,v 11.14 2000/07/10 23:53:55 mike Exp $";
d281 1
a281 1
	if( mk_addmember( sname, &head, WMOP_UNION ) == WMEMBER_NULL )
d322 1
a322 1
			if( mk_addmember( region_name , &head , WMOP_UNION ) == WMEMBER_NULL )
d341 1
a341 1
		if( mk_addmember( group_name , &head_all , WMOP_UNION ) == WMEMBER_NULL )
d443 1
a443 1
		if( mk_addmember( sol_name, &head, WMOP_UNION ) == WMEMBER_NULL )
@


11.14
log
@
lint
@
text
@d18 1
a18 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/euclid-g.c,v 11.13 2000/03/29 18:15:12 mike Exp $";
d119 1
d125 2
a126 1
	FILE		*fpin, *fpout;
a131 1
	fpout = stdout;
d133 1
a133 1
	bfile = NULL;
a165 6
			if ((fpout = fopen(bfile, "w")) == NULL) {
				fprintf(stderr,	"%s: cannot open %s for writing\n",
					argv[0], bfile);
				perror( argv[0] );
				exit(1);
			}
d201 7
d216 2
a217 1
	fclose(fpout);
d227 1
a227 1
FILE		*fpout;
d301 1
a301 1
FILE *fpout;
d387 2
a388 1
FILE	*fpin, *fpout;
d415 1
a415 1
FILE *fpout;
d502 2
a503 1
FILE	*fp, *fpdb;
@


11.13
log
@
Eliminated macro which also appears in vmath.h now
@
text
@d18 1
a18 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/euclid-g.c,v 11.12 2000/03/29 18:07:43 mike Exp $";
@


11.12
log
@
Removed stray RT_EXTERNs, added bn_ prefix.
@
text
@d18 1
a18 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/euclid-g.c,v 11.11 1999/12/30 18:23:09 jra Exp $";
a45 8

/* macro to determine if one bounding box in entirely within another
 * also returns true if the boxes are the same
 */
#define V3RPP1_IN_RPP2( _lo1 , _hi1 , _lo2 , _hi2 )	( \
	(_lo1)[X] >= (_lo2)[X] && (_hi1)[X] <= (_hi2)[X] && \
	(_lo1)[Y] >= (_lo2)[Y] && (_hi1)[Y] <= (_hi2)[Y] && \
	(_lo1)[Z] >= (_lo2)[Z] && (_hi1)[Z] <= (_hi2)[Z] )
@


11.11
log
@Eliminated some unused variables
@
text
@d18 1
a18 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/euclid-g.c,v 11.10 1999/06/03 21:54:19 mike Exp $";
a61 3

RT_EXTERN( fastf_t nmg_loop_plane_area , ( struct loopuse *lu , plane_t pl ) );
RT_EXTERN( struct faceuse *nmg_add_loop_to_face , (struct shell *s, struct faceuse *fu, struct vertex *verts[], int n, int dir ) );
@


11.10
log
@
sed4
@
text
@d18 1
a18 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/euclid-g.c,v 11.9 1996/07/12 13:20:17 jra Exp $";
d512 2
a513 2
	int	cur_id, face, facet_type, hole_face, i, j,
		lst[MAX_PTS_PER_FACE], np, nv, shell_count;
@


11.9
log
@Minor MOds for IRIX 6.2
@
text
@d18 1
a18 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/euclid-g.c,v 11.8 1995/03/24 13:26:29 jra Exp jra $";
d74 1
a74 1
struct nmg_ptbl groups[11];
d79 1
a79 1
static struct rt_tol  tol;
d87 1
a87 1
	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )
d91 1
a91 1
		for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
d96 1
a96 1
			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d99 1
a99 1
			for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d103 1
a103 1
				eu_next = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
d109 1
a109 1
				eu_next = RT_LIST_PNEXT_CIRC( edgeuse, &eu_next->l );
d122 1
a122 1
				rt_log( "Found a crack:\n" );
d124 1
a124 1
				rt_log( "Found a zero length edge:\n" );
d147 1
a147 1
        tol.magic = RT_TOL_MAGIC;
d220 1
a220 1
		nmg_tbl( &groups[i] , TBL_INIT , (long *)NULL );
d246 1
a246 1
	RT_LIST_INIT( &head.l );
d248 2
a249 2
	r = RT_LIST_FIRST( nmgregion , &m->r_hd );
	s = RT_LIST_FIRST( shell , &r->s_hd );
d262 1
a262 1
		while( RT_LIST_NOT_HEAD( s, &r->s_hd ) )
d266 1
a266 1
			next_s = RT_LIST_PNEXT( shell, &s->l );
d291 1
a291 1
		rt_log( "add_nmg_to_db: mk_addmember failed for solid %s\n" , sname );
d298 1
a298 1
		rt_log( "add_nmg_to_db: mk_rlcomb failed for region %s\n" , rname );
d302 1
a302 1
	nmg_tbl( &groups[group_id] , TBL_INS , (long *)rname );
d304 1
a304 1
	rt_free( (char *)sname , "euclid-g: solid name" );
d316 2
a317 2
	RT_LIST_INIT( &head.l );
	RT_LIST_INIT( &head_all.l );
d322 1
a322 1
		if( NMG_TBL_END( &groups[i] ) < 1 )
d325 1
a325 1
		for( j=0 ; j<NMG_TBL_END( &groups[i] ) ; j++ )
d329 1
a329 1
			region_name = (char *)NMG_TBL_GET( &groups[i] , j );
d332 1
a332 1
				rt_log( "build_groups: mk_addmember failed for region %s\n" , region_name );
d345 1
a345 1
			rt_log( "build_groups: mk_lcomb failed for group %s\n" , group_name );
d351 1
a351 1
			rt_log( "build_groups: mk_addmember failed for group %s\n" , group_name );
d435 1
a435 1
	RT_LIST_INIT( &head.l );
d452 1
a452 1
			rt_log( "add_shells_to_db: mk_addmember failed for solid %s\n" , sol_name );
d466 2
a467 2
			r_tmp = RT_LIST_FIRST( nmgregion , &m_tmp->r_hd );
			RT_LIST_DEQUEUE( &s->l );
d469 1
a469 1
			RT_LIST_APPEND( &r_tmp->s_hd, &s->l )
d489 1
a489 1
	reg_name = (char *)rt_malloc( strcspn( sol_name, "." ) + 3, "reg_name" );
d494 1
a494 1
		rt_log( "add_nmg_to_db: mk_rlcomb failed for region %s\n" , reg_name );
d498 1
a498 1
	nmg_tbl( &groups[group_id] , TBL_INS , (long *)reg_name );
d524 1
a524 1
	s = RT_LIST_FIRST(shell, &r->s_hd);
d544 1
a544 1
					rt_log( "Making simple face:\n" );
d546 1
a546 1
						rt_log( "\t( %g %g %g )\n" , V3ARGS( &vert.pt[lst[i]*3] ));
d555 1
a555 1
					rt_log( "Making a hole:\n" );
d557 1
a557 1
						rt_log( "\t( %g %g %g )\n" , V3ARGS( &vert.pt[lst[i]*3] ));
d566 1
a566 1
					rt_log( "Making face which will get a hole:\n" );
d568 1
a568 1
						rt_log( "\t( %g %g %g )\n" , V3ARGS( &vert.pt[lst[i]*3] ));
d591 1
a591 1
		rt_prmem( "After building faces:\n" );
d595 1
a595 1
		rt_log( "Associating vertex geometry:\n" );
d601 1
a601 1
				rt_log( "\t( %g %g %g )\n" , V3ARGS( &vert.pt[3*i] ) );
d607 1
a607 1
		rt_log( "Calling nmg_model_vertex_fuse()\n" );
d612 1
a612 1
		rt_log( "Calling nmg_model_break_e_on_v()\n" );
d624 1
a624 1
	s = RT_LIST_FIRST( shell , &r->s_hd );
d639 1
a639 1
		rt_prmem( "Before assoc face geom:\n" );
d643 1
a643 1
		rt_log( "Associating face geometry:\n" );
d653 1
a653 1
			rt_log( "nmg_calc_face_g failed\n" );
d660 1
a660 1
		rt_log( "Rebound\n" );
d666 1
a666 1
		rt_log( "Calling nmg_model_break_e_on_v()\n" );
d670 1
a670 1
	s = RT_LIST_FIRST( shell , &r->s_hd );
d694 1
a694 1
		rt_prmem( "Before glueing faces:\n" );
d698 1
a698 1
		rt_log( "Glueing faces\n" );
d703 1
a703 1
		rt_log( "Rebound\n" );
d708 1
a708 1
		rt_log( "Fix normals\n" );
d712 1
a712 1
		rt_prmem( "After fixing normals:\n" );
d715 1
a715 1
		rt_log( "nmg_s_join_touchingloops( %x )\n", s );
d719 1
a719 1
	s = RT_LIST_FIRST( shell , &r->s_hd );
d734 1
a734 1
		rt_log( "nmg_s_split_touchingloops( %x )\n", s );
d738 1
a738 1
	s = RT_LIST_FIRST( shell , &r->s_hd );
d756 1
a756 1
		rt_log( "Verify plane equations:\n" );
d760 1
a760 1
		rt_prmem( "Before nmg_make_faces_within_tol():\n" );
d765 1
a765 1
		rt_prmem( "After nmg_make_faces_within_tol():\n" );
d769 2
a770 2
		rt_log( "Checking faceuses:\n" );
		for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )
d786 1
a786 1
				rt_log( "faceuse x%x ( %g %g %g %g )\n", fu, V4ARGS( pl ) );
d789 1
a789 1
			for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
d793 1
a793 1
				if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )
d795 1
a795 1
					vu = RT_LIST_FIRST( vertexuse, &lu->down_hd );
d798 1
a798 1
						rt_log( "\tvertex x%x ( %g %g %g ) is %g off plane\n",
d803 1
a803 1
					for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d809 1
a809 1
							rt_log( "\tvertex x%x ( %g %g %g ) is %g off plane\n",
d818 1
a818 1
		rt_log( "%d vertices out of tolerance after fixing out of tolerance faces\n" , nmg_ck_geometry( m , &tol ) );
d824 1
a824 1
		rt_log( "Fuse model:\n" );
d828 1
a828 1
		rt_log( "\t%d objects fused\n" , i );
d845 1
a845 1
		struct nmg_ptbl verts;
d850 2
a851 2
		shell_inout = (short *)rt_calloc( shell_count, sizeof( short ), "shell_inout" );
		in_out = (short *)rt_calloc( shell_count * shell_count , sizeof( short ) , "in_out" );
d853 1
a853 1
		nmg_tbl( &verts , TBL_INIT , (long *)NULL );
d855 1
a855 1
		shells = (struct shell **)rt_calloc( shell_count, sizeof( struct shell *), "shells" );
d863 1
a863 1
			rt_log( "\nShell decomposed into %d sub-shells\n", shell_count );
d870 1
a870 1
		for( RT_LIST_FOR( s , shell , &r->s_hd ) )
d878 2
a879 2
				rt_log( "Warning: Region %d is not a closed surface\n" , reg_id );
				rt_log( "\tCreating new faces to close region\n" );
d887 1
a887 1
		for( RT_LIST_FOR( s, shell , &r->s_hd ) )
d898 1
a898 1
			for( RT_LIST_FOR( s2 , shell , &r->s_hd ) )
d910 1
a910 1
				for( j=0 ; j<NMG_TBL_END( &verts ) ; j++ )
d914 1
a914 1
					v = (struct vertex *)NMG_TBL_GET( &verts , j );
d947 1
a947 1
			nmg_tbl( &verts , TBL_RST, (long *)NULL );
d950 1
a950 1
		nmg_tbl( &verts, TBL_FREE, (long *)NULL );
d1038 3
a1040 3
		rt_free( (char *)shells, "shells" );
		rt_free( (char *)shell_inout, "shell_inout" );
		rt_free( (char *)in_out, "in_out" );
d1046 1
a1046 1
			rt_log( "Writing model to database:\n" );
d1080 1
a1080 1
		rt_log( "facet type %d has %d points:\n", facet_type,  *ni );
d1088 1
a1088 1
			rt_log( "\tpoint #%d ( %g %g %g )\n", i+1, x, y, z );
d1094 1
a1094 1
				rt_log( "\t\tStoring vertex ( %g %g %g ) at index %d\n" , x, y, z, lst[i] );
d1097 1
a1097 1
			rt_log( "\t\tFound vertex ( %g %g %g ) at index %d\n" , x, y, z, lst[i] );
d1103 1
a1103 1
		rt_log( "plane equation for face is ( %f %f %f %f )\n", a, b, c, d );
d1112 1
a1112 1
					rt_log( "\tComparing vertices at indices lst[%d]=%d and lst[%d]=%d\n", i, lst[i], j, lst[j] );
d1123 1
a1123 1
					rt_log( "warning: removing distant duplicates\n" );
d1155 1
a1155 1
		if( rt_pt3_pt3_equal( &vert->pt[3*i], new_pt, &tol ) )
@


11.8
log
@Checkpoint.
@
text
@d18 1
a18 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/euclid-g.c,v 11.7 95/03/17 15:49:54 jra Exp $";
d65 1
d94 1
a94 2
			struct vertex_g *vg;
			int found=1;
a98 2
			vg = RT_LIST_FIRST( edgeuse, &lu->down_hd )->vu_p->v_p->vg_p;

d101 1
a101 1
				struct vertex_g *vg1;
d103 7
a109 1
				vg1 = eu->vu_p->v_p->vg_p;
d111 1
a111 1
				if( vg1->coord[Y] != vg->coord[Y] || vg1->coord[Z] != vg->coord[Z] )
d113 1
a113 1
					found = 0;
d121 4
a124 1
			rt_log( "Found a crack:\n" );
d393 1
d590 3
d606 9
a614 1
Find_loop_crack( s );
d638 2
a639 10
	for (i = 0; i < face; i++)
	{
		if( outfaceuses[i]->l.magic != NMG_FACEUSE_MAGIC )
		{
			face--;
			for( j=i; j<face; j++ )
				outfaceuses[j] = outfaceuses[j+1];
			i--;
		}
	}
d646 4
d663 1
a663 1
Find_loop_crack( s );
a668 10
Find_loop_crack( s );
	/* Glue edges of outward pointing face uses together. */
#if 0
	if( debug )
		rt_log( "Glueing faces\n" );
	nmg_gluefaces(outfaceuses, face);
#else
	(void)nmg_model_edge_fuse( m, &tol );
#endif

d684 17
d711 3
a713 1
	/* Get rid of cracks */
d715 4
a718 1
		rt_log( "Kill cracks\n" );
d733 3
a735 7
	/* kill zero length edgeuses */
	if( nmg_kill_zero_length_edgeuses( m ) )
	{
		nmg_km( m );
		m = (struct model *)NULL;
		return( cur_id );
	}
d737 1
a737 3
	/* Get rid of cracks */
	if( debug )
		rt_log( "Kill cracks\n" );
a751 10
Find_loop_crack( s );
	if( debug )
		rt_log( "nmg_s_join_touchingloops( %x )\n", s );
	nmg_s_join_touchingloops( s, &tol );
	if( debug )
		rt_log( "nmg_s_split_touchingloops( %x )\n", s );

	nmg_s_split_touchingloops( s, &tol);

Find_loop_crack( s );
d759 3
d763 4
d819 1
a819 34

Find_loop_crack( s );
	/* Break edges on vertices */
	if( debug )
		rt_log( "Calling nmg_model_break_e_on_v()\n" );
	(void)nmg_model_break_e_on_v( m, &tol );

Find_loop_crack( s );
	/* Get rid of cracks */
	if( debug )
		rt_log( "Kill cracks\n" );
	s = RT_LIST_FIRST( shell , &r->s_hd );
	if( nmg_kill_cracks( s ) )
	{
		if( nmg_ks( s ) )
		{
			nmg_km( m );
			m = (struct model *)0;
		}
		s = (struct shell *)0;
	}

	if( !m )
		return( cur_id );

	/* kill zero length edgeuses */
	if( nmg_kill_zero_length_edgeuses( m ) )
	{
		nmg_km( m );
		m = (struct model *)NULL;
		return( cur_id );
	}

#if 1
a825 1
Find_loop_crack( s );
d829 1
a830 1
Find_loop_crack( s );
a832 3
Find_loop_crack( s );

#endif
@


11.7
log
@Added calls to fuser, join_touching_loops, slpit_touching_loops, kill_cracks, and kill zero length edgeuses.
@
text
@d18 1
a18 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/euclid-g.c,v 11.6 1995/03/08 10:54:32 jra Exp jra $";
d80 43
d538 1
a538 1
						rt_log( "\( %g %g %g )\n" , V3ARGS( &vert.pt[lst[i]*3] ));
d549 1
a549 1
						rt_log( "\( %g %g %g )\n" , V3ARGS( &vert.pt[lst[i]*3] ));
d560 1
a560 1
						rt_log( "\( %g %g %g )\n" , V3ARGS( &vert.pt[lst[i]*3] ));
d595 1
d643 6
d654 1
d656 1
d660 18
d731 3
d735 3
d740 1
a746 127
	for (i = 0; i < face; i++)
	{
		plane_t pl;
		struct loopuse *lu;
		struct edgeuse *eu;
		struct vertexuse *vu;
		fastf_t dist_to_plane;
		int triangulate=0;

		NMG_GET_FU_PLANE( pl, outfaceuses[i] );

		/* check if all the vertices for this face lie on the plane */
		for( RT_LIST_FOR( lu, loopuse, &outfaceuses[i]->lu_hd ) )
		{
			NMG_CK_LOOPUSE( lu );
			if( debug )
				rt_log( "Checking fu x%x ( %g %g %g %g )\n", outfaceuses[i], V4ARGS( pl ) );

			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )
			{
				vu = RT_LIST_FIRST( vertexuse, &lu->down_hd );
				dist_to_plane = DIST_PT_PLANE( vu->v_p->vg_p->coord, pl );
				if( dist_to_plane > tol.dist || dist_to_plane < -tol.dist )
				{
					if( debug )
						rt_log( "\tvertex x%x ( %g %g %g ) is %g off plane\n",
							vu->v_p,
							V3ARGS( vu->v_p->vg_p->coord ),
							dist_to_plane );
					triangulate = 1;
					break;
				}
			}
			else
			{
				for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
				{
					NMG_CK_EDGEUSE( eu );
					vu = eu->vu_p;
					dist_to_plane = DIST_PT_PLANE( vu->v_p->vg_p->coord, pl );
					if( dist_to_plane > tol.dist || dist_to_plane < -tol.dist )
					{
						if( debug )
							rt_log( "\tvertex x%x ( %g %g %g ) is %g off plane\n",
								vu->v_p,
								V3ARGS( vu->v_p->vg_p->coord ),
								dist_to_plane );
						triangulate = 1;
						break;
					}
				}
				if( triangulate )
					break;
			}
		}

		if( triangulate )
		{
			/* Need to triangulate this face */
			if( debug )
			{
				rt_log( "\tTriangulating fu x%x (mate is x%x)\n",
					outfaceuses[i], outfaceuses[i]->fumate_p );
				nmg_pr_fu_briefly( outfaceuses[i], "" );
			}

			nmg_triangulate_fu( outfaceuses[i], &tol );

			/* split each triangular loop into its own face */
			fu = outfaceuses[i];
			if( fu->orientation != OT_SAME )
				fu = fu->fumate_p;
			if( fu->orientation != OT_SAME )
			{
				rt_log( "cvt_euclid_region: face (fu = x%x) with no OT_SAME use!!\n", fu );
				nmg_pr_fu_briefly( fu , "" );
				rt_bomb( "cvt_euclid_region: face with no OT_SAME use\n" );
			}

			if( debug )
				rt_log( "\tSplitting loops into face for fu x%x\n", fu );

			(void)nmg_split_loops_into_faces( &fu->l.magic, &tol );
			if( nmg_calc_face_g( fu ) )
			{
				rt_log( "cvt_euclid_region: nmg_calc_face_g failed!!\n" );
				rt_bomb( "euclid-g: Could not calculate new face geometry\n" );
			}

			if( debug )
			{
				NMG_GET_FU_PLANE( pl, fu );
				rt_log( "\tNew face geometry for fu x%x ( %g %g %g %g )\n", fu, V4ARGS( pl ) );
			}
		}
	}

	if( debug )
		rt_log( "Looking for new faces:\n" );

	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )
	{
		int found=0;

		if( fu->orientation != OT_SAME )
			continue;

		for( j=0; j<face; j++ )
		{
			if( fu == outfaceuses[j] || fu->fumate_p == outfaceuses[j] )
			{
				found = 1;
				break;
			}
		}
		if( !found )
		{
			plane_t pl;
			nmg_calc_face_g( fu );

			if( debug )
			{
				NMG_GET_FU_PLANE( pl, fu );
				rt_log( "\tnew geometry for fu x%x ( %g %g %g %g )\n", fu, V4ARGS( pl ) );
			}
		}
	}
d748 1
d802 32
d841 1
d846 1
d849 1
@


11.6
log
@Improved vertex fusing on the fly. Moved face fusing prior to triangulation.
@
text
@d18 1
a18 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/euclid-g.c,v 11.5 1995/03/03 15:19:33 jra Exp jra $";
d77 1
a77 1
static char	usage[] = "Usage: %s [-i euclid_db] [-o brlcad_db] [-p] [-xX lvl]\n\t\t(-p indicates write as polysolids)\n ";
d491 6
d502 6
d513 6
d552 34
d599 5
d605 2
d610 2
d615 2
a616 1
	s = RT_LIST_FIRST( shell , &r->s_hd );
d619 5
a623 3
	/* Fuse faces */
	(void)nmg_model_face_fuse( m, &tol );
	if( nmg_simplify_shell( s ) )
a624 1
		/* Simplified away to nothing!!! */
d628 1
a628 1
			m = (struct model *)NULL;
d630 1
a630 1
		s = (struct shell *)NULL;
d636 28
d665 5
d730 1
d733 2
d847 20
d1077 3
d1081 1
@


11.5
log
@Added triangulation of faces with vertices off plane of face.
Added tolerance to title string.
@
text
@d18 1
a18 1
static char RCSid[] = "$Header: /n/wolf/m/cad/conv/RCS/euclid-g.c,v 11.4 95/01/24 10:08:54 jra Exp $";
d557 16
d589 2
d598 5
d616 5
d633 4
d649 4
d659 6
d668 3
d687 2
d690 7
d698 50
d988 3
d993 2
a994 1
	for (i = 0; i < *ni; i++) {
d997 3
d1001 1
d1003 5
d1012 2
d1020 3
d1033 1
a1033 1
					fprintf( stderr , "warning: removing distant duplicates\n" );
d1059 1
d1061 1
a1061 3
/* XXX What's good here? */
#define ZERO_TOL 0.0001

d1063 3
a1065 4
	for (i = 0; i < nv; i++) {
		if (NEAR_ZERO(x - vert->pt[3*i+0], ZERO_TOL)
			&& NEAR_ZERO(y - vert->pt[3*i+1], ZERO_TOL)
			&& NEAR_ZERO(z - vert->pt[3*i+2], ZERO_TOL))
@


11.4
log
@Added inner void shell capability.
@
text
@d18 1
a18 1
static char RCSid[] = "$Header: /n/wolf/m/cad/conv/RCS/euclid-g.c,v 11.3 95/01/19 09:25:39 jra Exp Locker: jra $";
d41 3
a43 2
#define MAX_FACES_PER_REGION 8192
#define MAX_PTS_PER_FACE 8192
d77 1
a77 1
static char	usage[] = "Usage: %s [-i euclid_db] [-o brlcad_db] [-p]\n\t\t(-p indicates write as polysolids)\n ";
d86 1
d105 1
a105 1
	while ((c = getopt(argc, argv, "d:vi:o:p")) != EOF) {
d136 6
d151 1
a151 1
		mk_id( fpout , "Conversion from EUCLID" );
d153 3
a155 1
		mk_id(fpout, efile);
d157 12
d209 2
a210 1
		mk_nmg(fpout, sname,  m);		/* Make nmg object. */
d212 20
d461 1
a461 1
	int	cur_id, face, facet_type, hole_face, i,
d467 1
d539 21
a560 1
		fastf_t area;
d562 4
d567 4
a570 1
		for( RT_LIST_FOR( lu , loopuse , &outfaceuses[i]->lu_hd ) )
d572 3
a574 2
			area = nmg_loop_plane_area( lu , pl );
			if( area > 0.0 )
d576 3
a578 3
				if( debug )
					rt_log( "\t( %g %g %g %g )\n" , V4ARGS( pl ) );
				if( lu->orientation == OT_OPPOSITE )
d580 2
a581 3
					if( debug )
						rt_log( "\t\treversing plane normal for OT_OPPOSITE loop\n" );
					HREVERSE( pl , pl );
a582 2
				nmg_face_g( outfaceuses[i] , pl );
				break;
d586 13
a598 2
				rt_log( "Cannot calculate geometry for loop:\n" );
				nmg_pr_lu_briefly( lu, "" );
d601 23
d626 3
a628 2
	/* Glue edges of outward pointing face uses together. */
	nmg_gluefaces(outfaceuses, face);
d630 2
a631 2
	/* Compute "geometry" for region and shell */
	nmg_region_a( r , &tol );
d633 12
a644 4
	/* fix the normals */
	s = RT_LIST_FIRST( shell , &r->s_hd );
	nmg_fix_normals( s, &tol );

d853 1
@


11.3
log
@Changed handling of non-closed shells.
@
text
@d18 1
a18 1
static char RCSid[] = "$Header: /n/wolf/m/cad/conv/RCS/euclid-g.c,v 11.2 95/01/18 10:57:24 jra Exp Locker: jra $";
d54 6
d61 1
d75 1
d77 1
d93 1
d95 7
d103 1
a103 1
	while ((c = getopt(argc, argv, "i:o:p")) != EOF) {
d105 7
a171 1
	struct rt_tol  tol;
a175 7
        /* XXX These need to be improved */
        tol.magic = RT_TOL_MAGIC;
        tol.dist = 0.005;
        tol.dist_sq = tol.dist * tol.dist;
        tol.perp = 1e-6;
        tol.para = 1 - tol.perp;

d326 81
d419 1
a419 1
		lst[MAX_PTS_PER_FACE], np, nv;
a422 1
	struct rt_tol	tol;
a426 7
	/* Copied from proc-db/nmgmodel.c */
	tol.magic = RT_TOL_MAGIC;
	tol.dist = 0.01;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 0.001;
	tol.para = 0.999;

d478 2
d481 1
d483 3
d487 2
d491 2
d504 2
d507 3
d511 1
d515 5
d539 1
a539 1
	if( nmg_decompose_shell( s , &tol ) > 1 )
d542 5
a546 2
		struct shell *outer_shell=NULL;
		long *flags;
d548 2
a549 1
		flags = (long *)rt_calloc( m->maxindex , sizeof( long ) , "euclid-g: flags" );
d551 17
d570 17
d588 2
d591 1
a591 1
			int is_outer=1;
d593 1
a593 3
			/* insure that bounding boxes are available */
			if( !s->sa_p )
				nmg_shell_a( s , &tol );
d595 1
a595 3
			/* Check if this shells contains all the others
			 * In TANKILL, there should only be one outer shell
			 */
d598 4
a601 1
				if( !s2->sa_p )
d603 1
a603 1
					nmg_shell_a( s2 , &tol );
d605 4
a608 2
				if( !V3RPP1_IN_RPP2( s2->sa_p->min_pt , s2->sa_p->max_pt ,
						    s->sa_p->min_pt , s->sa_p->max_pt ) )
d610 26
a635 3
					/* doesn't contain shell s2, so it's not an outer shell */
					is_outer = 0;
					break;
d637 6
d644 15
a658 1
			if( is_outer )
d660 8
a667 2
				outer_shell = s;
				break;
d669 10
a679 5
		if( !outer_shell )
		{
			rt_log( "euclid-g: Could not find outer shell for component code %d\n" , cur_id );
			outer_shell = RT_LIST_FIRST( shell , &r->s_hd );
		}
d681 2
a682 4
		/* reverse the normals for each void shell
		 * and merge back into one shell */
		s = RT_LIST_FIRST( shell , &r->s_hd );
		while( RT_LIST_NOT_HEAD( s , &r->s_hd ) )
d684 1
a684 2
			struct faceuse *fu;
			struct shell *next_s;
d686 8
a693 1
			if( s == outer_shell )
d695 13
a707 2
				s = RT_LIST_PNEXT( shell , s );
				continue;
d709 2
d712 3
a714 6
			next_s = RT_LIST_PNEXT( shell , s );
			fu = RT_LIST_FIRST( faceuse , &s->fu_hd );
			nmg_reverse_face( fu );
			nmg_propagate_normals( fu , flags , &tol );
			nmg_js( outer_shell , s , &tol );
			s = next_s;
a715 3
		rt_free( (char *)flags , "euclid-g: flags" );
	}
	s = RT_LIST_FIRST( shell , &r->s_hd );
d717 22
a738 7
	if( nmg_check_closed_shell( s , &tol ) )
	{
		rt_log( "Warning: Region %d is not a closed surface\n" , reg_id );
		rt_log( "\tCreating new faces to close region\n" );
		nmg_close_shell( s , &tol );
		if( nmg_check_closed_shell( s , &tol ) )
			rt_bomb( "Cannot close shell\n" );
d740 2
a742 1
	add_nmg_to_db(fpdb, m, reg_id);		/* Put region in db. */
@


11.2
log
@nmg_fix_normals needed a tol arg.
@
text
@d18 1
a18 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/euclid-g.c,v 11.1 95/01/04 09:59:25 mike Rel4_4 Locker: jra $";
d500 9
a508 3
	
	if( nmg_ck_closed_surf( s , &tol ) )
		fprintf( stderr , "Warning: Region %d is not a closed surface\n" , reg_id );
@


11.1
log
@Release_4.4
@
text
@d18 1
a18 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/euclid-g.c,v 1.10 94/11/08 04:06:16 mike Exp $";
d421 1
a421 1
	nmg_fix_normals( s );
@


1.10
log
@Irix 6
@
text
@d18 1
a18 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/euclid-g.c,v 1.9 94/11/01 06:51:37 butler Exp Locker: mike $";
@


1.9
log
@changed cast for parameter to mk_lrcomb() to match function prototype
@
text
@d18 1
a18 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/euclid-g.c,v 1.8 1994/10/14 15:26:34 jra Exp butler $";
a148 1
	struct wmember *wmem;
d321 1
a321 1
	int	cur_id, face, facet_type, hole_face, i, j,
a528 1
	vect_t	N;
@


1.8
log
@removed a debug print.
@
text
@d18 1
a18 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/euclid-g.c,v 1.7 94/08/10 23:49:39 gdurf Exp Locker: jra $";
d187 2
a188 1
	if( mk_lrcomb( fpout, rname, &head, 1, (char *)NULL, (char *)NULL, (char *)NULL, gift_ident, 0, 0, 100, 0 ) )
@


1.7
log
@Factored ifdefs
@
text
@d18 1
a18 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/euclid-g.c,v 1.6 1994/04/19 18:50:18 jra Exp gdurf $";
a409 5
		}
		if( !outfaceuses[i]->f_p->fg_p )
		{
			nmg_pr_fu_briefly( outfaceuses[i] , (char *)NULL );
			rt_bomb( "Cannot find plane eqn for above faceuse\n" );
@


1.6
log
@Added void shell check after fixing normals
@
text
@d18 1
a18 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/euclid-g.c,v 1.5 94/03/21 13:30:55 jra Exp Locker: jra $";
d21 2
a23 1
#include <stdlib.h>
d25 1
d27 3
@


1.5
log
@Added code to build groups.
@
text
@d18 1
a18 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/euclid-g.c,v 1.4 94/03/18 10:30:34 jra Exp Locker: jra $";
d41 9
d422 78
@


1.4
log
@Converted to use nmg_loop_plane_area to get face plane equations.
@
text
@d18 1
a18 1
static char RCSid[] = "$Header: /n/wolf/m/cad/conv/RCS/euclid-g.c,v 1.3 93/12/01 15:19:55 jra Exp Locker: jra $";
d33 1
d42 1
a43 1
extern struct faceuse *nmg_add_loop_to_face();
d51 2
d63 1
d109 3
d119 120
d291 3
a544 43
}

/*
 *	A d d _ N M G _ t o _ D b
 *
 *	Write the nmg to a brl-cad style data base.
 */
int
add_nmg_to_db(fpout, m, reg_id)
FILE		*fpout;
struct model	*m;
int		reg_id;
{
	char	id[80], *rname, *sname;
	struct nmgregion *r;
	struct shell *s;
	struct rt_tol  tol;

        /* XXX These need to be improved */
        tol.magic = RT_TOL_MAGIC;
        tol.dist = 0.005;
        tol.dist_sq = tol.dist * tol.dist;
        tol.perp = 1e-6;
        tol.para = 1 - tol.perp;

	r = RT_LIST_FIRST( nmgregion , &m->r_hd );
	s = RT_LIST_FIRST( shell , &r->s_hd );

	sprintf(id, "%d", reg_id);
	rname = malloc(sizeof(id) + 3);	/* Region name. */
	sname = malloc(sizeof(id) + 3);	/* Solid name. */

	sprintf(sname, "%s.s", id);
	if( polysolids )
		write_shell_as_polysolid( fpout , sname , s );
	else
		mk_nmg(fpout, sname,  m);		/* Make nmg object. */

	sprintf(rname, "%s.r", id);
	mk_comb1(fpout, rname, sname, 1);	/* Put object in a region. */
	
	rt_free( (char *)rname , "euclid-g: region name" );
	rt_free( (char *)sname , "euclid-g: solid name" );
@


1.3
log
@Added RCSid string
@
text
@d18 1
a18 1
static char RCSid[] = "$Header$";
d40 2
d177 1
a177 1
	int	cur_id, face, facet_type, fail, hole_face, i, j,
d250 16
a265 3
	for (i = 0, fail = 0; i < face; i++)
		if (nmg_fu_planeeqn(outfaceuses[i], &tol) < 0) {
			fprintf(stderr, "Warning: in region %d, face %d is degenerate.\n", reg_id, i);
d267 6
@


1.2
log
@Added nmg_fix_normals routine and a few small mods
@
text
@d17 3
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
 *  Author -
d8 1
a16 3
#ifndef lint
static char rcsid[] = "$Header$";
#endif
d37 3
d45 2
a46 1
static char	usage[] = "Usage: %s [euclid_db] [brlcad_db]\n";
d52 1
a52 1
	char		*base, *bfile, *grp_name, *efile, *reg_name;
a53 1
	int		doti;
d56 5
a60 1
	grp_name = reg_name = NULL;
d63 1
a63 1
	while ((c = getopt(argc, argv, "x")) != EOF) {
d65 9
a73 1
		case 'x':
d75 12
a93 29
	/* Get Euclid input file name. */
	if (optind >= argc) {
		efile = "-";
		fpin = stdin;
	} else {
		efile = argv[optind];
		if ((fpin = fopen(efile, "r")) == NULL) {
			fprintf(stderr,
				"%s: cannot open %s for reading\n",
				argv[0], efile);
			exit(1);
		}
	}

	/* Get BRL-CAD output data base name. */
	optind++;
	if (optind >= argc) {
		bfile = "-";
		fpout = stdout;
	} else {
		bfile = argv[optind];
		if ((fpout = fopen(bfile, "w")) == NULL) {
			fprintf(stderr,
				"%s: cannot open %s for writing\n",
				argv[0], bfile);
			exit(1);
		}
	}

d95 4
a98 1
	mk_id(fpout, efile);
d144 4
d156 1
a156 1
		printf("Converting region %d...\n", reg_id);
d172 2
a173 2
	int	cur_id, face, facet_type, fail, i, j, lst[MAX_PTS_PER_FACE],
		np, nv;
d200 2
a201 3
		/* Make face out of vertices in lst. */
		for (i = 0; i < np; i++)
			vertlist[i] = vert.vt[lst[i]];
d203 3
a205 5
		switch(facet_type) {
		case 0:	/* Simple facet (no holes). */
			outfaceuses[face] = nmg_cface(s, vertlist, np);
			face++;
			break;
d207 5
a211 6
		case 1:	/* Facet is a hole. */
			outfaceuses[face] = nmg_add_loop_to_face(
				s, (struct faceuse *)NULL, vertlist, np,
				OT_OPPOSITE);
			face++;
			break;
d213 4
a216 4
		case 2:	/* Facet will be given at least one hole. */
			outfaceuses[face] = nmg_cface(s, vertlist, np);
			face++;
			break;
d218 14
a231 3
		default:
			fprintf(stderr, "cvt_euclid_face: in region %d, face %d is an unknown facet type\n", reg_id, face);
			break;
a233 4
		/* Save (possibly) newly created vertex structs. */
		for (i = 0; i < np; i++)
			vert.vt[lst[i]] = vertlist[i];

a247 4
			for (j = i; j < face-1; j++)
				outfaceuses[j] = outfaceuses[j+1];
			face--;
			i--;
d254 1
a254 1
	nmg_region_a(r);
d256 7
d293 1
a293 1

d309 18
a326 4
				fprintf(stderr, "warning: removing duplicate point.\n");
				for (k = MAX(i, j); k < *ni-1; k++)
					lst[k] = lst[k+1];
				--*ni;
a327 6
	
	/* See if a face needs flipping. */
	VSET(N, a, b, c);
	VUNITIZE(N);
	poly_flop(lst, *ni, facet_type, &(vert->pt[lst[0]*3]),
		&(vert->pt[lst[1]*3]), &(vert->pt[lst[2]*3]), N);
a332 57
 *	P o l y _ F l o p
 *
 *	Take 3 points of a Euclid polygon and generate a surface normal
 *	from them.  If the surface normal is opposite the normal stored
 *	in the Euclid data base, assume the face needs flipping.
 *
 *	Assume the normal read from the Euclid data base points outward for
 *	faces and inward for holes.
 */
poly_flop(lst, n, facet_type, x, y, z, N)
int	*lst, n, facet_type;
point_t	x, y, z;
vect_t	N;
{
	int	i, tmp;
	vect_t	A, B, Nb, Nb_rev;

	VSUB2(A, y, x);
	VSUB2(B, z, x);
	VCROSS(Nb, A, B);
	VUNITIZE(Nb);
	VREVERSE(Nb_rev, Nb);

	if ((facet_type != 1 && VAPPROXEQUAL(N, Nb, 0.1))
		|| (facet_type == 1 && VAPPROXEQUAL(N, Nb_rev, 0.1))) {
#if 0
		fprintf(stderr,"   Face is ok\n");
#endif
	} else if (VAPPROXEQUAL(N, Nb, 0.1) && VAPPROXEQUAL(N, Nb_rev, 0.1)) {
#if 0
		fprintf(stderr, "   Flipping a face\n");
#endif
		/* Reverse order of points in face. */
		for (i = 0; i < n/2; i++) {
			tmp = lst[i];
			lst[i] = lst[n-i-1];
			lst[n-i-1] = tmp;
		}
	} else {
		fprintf(stderr, "   Hmm, this is weird.  ");
		fprintf(stderr, "Neuc=<%lf %lf %lf>, Nbrl=<%lf %lf %lf>\n",
			V3ARGS(N), V3ARGS(Nb));
		fprintf(stderr, "facet type is %d\n", facet_type);
#if 0
		for (i = 0; i < n; i++)
			printf("%lf %lf %lf\n", 
				vert->pt[3*lst[i]+0],
				vert->pt[3*lst[i]+1],
				vert->pt[3*lst[i]+2]);
		printf("plane eqn is: %lf %lf %lf %lf\n",a,b,c,d);
		printf("my normal is: %lf %lf %lf\n",V3ARGS(Nb));
		exit(0);
#endif
	}
}

/*
d345 1
a345 1
	int	done, i;
d350 2
a351 2
	done = 0;
	for (i = 0; !done && i < nv; i++) {
d355 4
a358 1
			done = 1;
d360 4
a363 4
	if (!done)
		i = 0;

	return(i-1);
d405 3
d409 10
d423 6
a428 2
	sprintf(sname, "%s.nmg", id);
	mk_nmg(fpout, sname,  m);		/* Make nmg object. */
d431 3
@
