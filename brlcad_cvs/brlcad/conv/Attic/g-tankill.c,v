head	11.30;
access;
symbols
	ansi-20040405-merged:11.26.2.2
	postmerge-20040405-ansi:11.28
	premerge-20040404-ansi:11.27
	postmerge-autoconf:11.27
	autoconf-freeze:11.26.10.2
	premerge-autoconf:11.27
	ansi-20040316-freeze:11.26.2.1
	postmerge-20040315-windows:11.27
	premerge-20040315-windows:11.27
	windows-20040315-freeze:11.26.4.1
	autoconf-20031203:11.26
	autoconf-20031202:11.26
	autoconf-branch:11.26.0.10
	phong-branch:11.26.0.8
	photonmap-branch:11.26.0.6
	rel-6-1-DP:11.26
	windows-branch:11.26.0.4
	rel-6-0-2:11.24
	ansi-branch:11.26.0.2
	rel-6-0-1-branch:11.24.0.2
	hartley-6-0-post:11.25
	hartley-6-0-pre:11.24
	rel-6-0-1:11.24
	rel-6-0:11.24
	rel-5-4:11.15
	offsite-5-3-pre:11.21
	rel-5-3:11.15
	rel-5-2:11.15
	rel-5-1-branch:11.15.0.2
	rel-5-1:11.15
	rel-5-0:11.9
	rel-5-0-beta:11.8
	rel-4-5:11.8
	ctj-4-5-post:11.8
	ctj-4-5-pre:11.8
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.30
date	2004.05.24.04.16.12;	author morrison;	state dead;
branches;
next	11.29;

11.29
date	2004.05.10.15.30.41;	author erikg;	state Exp;
branches;
next	11.28;

11.28
date	2004.04.05.07.49.36;	author morrison;	state Exp;
branches;
next	11.27;

11.27
date	2004.02.02.17.39.00;	author morrison;	state Exp;
branches;
next	11.26;

11.26
date	2002.08.20.17.07.21;	author jra;	state Exp;
branches
	11.26.2.1
	11.26.4.1
	11.26.10.1;
next	11.25;

11.25
date	2002.08.15.20.54.34;	author hartley;	state Exp;
branches;
next	11.24;

11.24
date	2001.08.10.21.22.53;	author butler;	state Exp;
branches;
next	11.23;

11.23
date	2001.05.17.20.03.14;	author morrison;	state Exp;
branches;
next	11.22;

11.22
date	2001.04.05.19.34.59;	author morrison;	state Exp;
branches;
next	11.21;

11.21
date	2000.09.09.04.53.46;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	2000.09.08.05.55.42;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	2000.07.21.12.44.34;	author jra;	state Exp;
branches;
next	11.18;

11.18
date	2000.07.12.21.59.35;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	2000.07.10.23.53.57;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	2000.06.30.15.04.00;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	2000.03.29.18.15.16;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	2000.03.29.18.07.45;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	2000.03.03.03.37.58;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	2000.01.04.17.58.19;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	99.12.30.18.31.54;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	99.12.29.23.23.01;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	99.06.03.21.54.20;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	96.12.04.04.03.51;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	96.08.02.12.46.58;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	96.07.02.18.13.52;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	95.04.03.19.48.38;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	95.03.29.18.35.08;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.03.29.13.25.22;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.02.22.05.40.55;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.59.36;	author mike;	state Rel4_4;
branches;
next	1.14;

1.14
date	94.12.16.16.32.47;	author jra;	state Exp;
branches;
next	1.13;

1.13
date	94.12.08.17.56.29;	author jra;	state Exp;
branches;
next	1.12;

1.12
date	94.11.08.16.15.08;	author jra;	state Exp;
branches;
next	1.11;

1.11
date	94.11.02.14.45.53;	author jra;	state Exp;
branches;
next	1.10;

1.10
date	94.08.23.14.30.10;	author jra;	state Exp;
branches;
next	1.9;

1.9
date	94.08.11.00.06.03;	author gdurf;	state Exp;
branches;
next	1.8;

1.8
date	94.07.13.12.22.02;	author jra;	state Exp;
branches;
next	1.7;

1.7
date	94.04.19.18.49.19;	author jra;	state Exp;
branches;
next	1.6;

1.6
date	94.04.19.18.10.17;	author jra;	state Exp;
branches;
next	1.5;

1.5
date	94.03.19.21.49.24;	author jra;	state Exp;
branches;
next	1.4;

1.4
date	94.03.18.12.43.59;	author jra;	state Exp;
branches;
next	1.3;

1.3
date	94.01.07.13.01.12;	author jra;	state Exp;
branches;
next	1.2;

1.2
date	93.12.09.13.52.16;	author jra;	state Exp;
branches;
next	1.1;

1.1
date	93.12.07.12.32.12;	author jra;	state Exp;
branches;
next	;

11.26.2.1
date	2002.09.19.18.00.36;	author morrison;	state Exp;
branches;
next	11.26.2.2;

11.26.2.2
date	2004.03.17.21.15.58;	author morrison;	state Exp;
branches;
next	;

11.26.4.1
date	2004.03.11.23.40.30;	author morrison;	state Exp;
branches;
next	;

11.26.10.1
date	2004.02.12.19.24.23;	author erikg;	state Exp;
branches;
next	11.26.10.2;

11.26.10.2
date	2004.03.15.14.06.08;	author erikg;	state Exp;
branches;
next	;


desc
@BRLCAD to TANKILL conveter
@


11.30
log
@moved to src/conv/
@
text
@/*
 *			G - T A N K I L L . C
 *
 *  Program to convert a BRL-CAD model (in a .g file) to a TANKILL facetted model
 *  by calling on the NMG booleans.
 *
 *  Author -
 *	John R. Anderson
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1993-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */

#ifndef lint
static const char RCSid[] = "$Header: /n/xoff/cvs/brlcad/conv/g-tankill.c,v 11.29 2004/05/10 15:30:41 erikg Exp $";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "../librt/debug.h"

BU_EXTERN(union tree *do_region_end, (struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data));

static char	usage[] = "Usage:\n\
	%s [-v] [-xX lvl] [-a abs_tol] [-r rel_tol] [-n norm_tol] [-s surroundings_code] [-i idents_output_file] [-o out_file] brlcad_db.g object(s)\n\
		v - verbose\n\
		x - librt debug level\n\
		X - NMG debug level\n\
		a - absolute tolerance for tesselation\n\
		r - relative tolerance for tesselation\n\
		n - surface normal tolerance for tesselation\n\
		s - surroundings code to use in tankill file\n\
		i - assign new idents sequentially and output ident list\n\
		o - TANKILL output file\n";

static int	NMG_debug;		/* saved arg of -X, for longjmp handling */
static int	verbose;
/* static int	ncpu = 1; */		/* Number of processors */
static int	surr_code = 1000;	/* Surroundings code */
static int	curr_id;		/* Current region ident code */
static int	id_counter;		/* Ident counter */
static char	*out_file = NULL;	/* Output filename */
static FILE	*fp_out;		/* Output file pointer */
static char	*id_file = NULL;	/* Output ident file */
static FILE	*fp_id = NULL;		/* Output ident file pointer */
static int	*idents;		/* Array of region ident numbers */
static int	ident_count=0;		/* Number of idents in above array */
static int	ident_length=0;		/* Length of idents array */
#define		IDENT_BLOCK	256	/* Number of idents array slots to allocate */

static struct db_i		*dbip;
static struct rt_tess_tol	ttol;
static struct bn_tol		tol;
static struct model		*the_model;

static struct db_tree_state	tree_state;	/* includes tol & model */

static int	regions_tried = 0;
static int	regions_converted = 0;
static int	regions_written = 0;

void
insert_id(int id)
{
	int i;

	for( i=0 ; i<ident_count ; i++ )
	{
		if( idents[i] == id )
			return;
	}

	if( ident_count == ident_length )
	{
		idents = (int *)rt_realloc( (char *)idents , (ident_length + IDENT_BLOCK)*sizeof( int ) , "insert_id: idents" );
		ident_length += IDENT_BLOCK;
	}

	idents[ident_count] = id;
	ident_count++;
}

/* routine used in tree walker to select regions with the current ident number */
static int
select_region(register struct db_tree_state *tsp, struct db_full_path *pathp, const struct rt_comb_internal *combp, genptr_t client_data)
{
	if( tsp->ts_regionid == curr_id )
		return( 0 );
	else
		return( -1 );
}

/* routine used in tree walker to collect region ident numbers */
static int
get_reg_id(register struct db_tree_state *tsp, struct db_full_path *pathp, const struct rt_comb_internal *combp, genptr_t client_data)
{
	insert_id( tsp->ts_regionid );
	return( -1 );
}

/* stubs to warn of the unexpected */
static union tree *
region_stub(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
{
	struct directory *fp_name;	/* name from pathp */

	fp_name = DB_FULL_PATH_CUR_DIR( pathp );
	bu_log( "region stub called (for object %s), this shouldn't happen\n" , fp_name->d_namep );
	return( (union tree *)NULL );
}

static union tree *
leaf_stub(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
{
	struct directory *fp_name;	/* name from pathp */

	fp_name = DB_FULL_PATH_CUR_DIR( pathp );
	bu_log( "Only regions may be converted to TANKILL format\n\t%s is not a region and will be ignored\n" , fp_name->d_namep );
	return( (union tree *)NULL );
}

#if 0
/* Routine to identify external/void shells
 *	Marks external shells with a +1 in the flags array
 *	Marks void shells with a -1 in the flags array
 */
static void
nmg_find_void_shells( r , flags , ttol )
const struct nmgregion *r;
const struct bn_tol *ttol;
long *flags;
{
	struct model *m;
	struct shell *s;

	NMG_CK_REGION( r );

	m = r->m_p;
	NMG_CK_MODEL( m );

	for( BU_LIST_FOR( s , shell , &r->s_hd ) )
	{
		struct face *f;
		struct faceuse *fu;
		vect_t normal;
		int dir;

		f = nmg_find_top_face( s, &dir, flags );
		fu = f->fu_p;
		if( fu->orientation != OT_SAME )
			fu = fu->fumate_p;
		if( fu->orientation != OT_SAME )
			rt_bomb( "nmg_find_void_shells: Neither faceuse nor mate have OT_SAME orient\n" );

		NMG_GET_FU_NORMAL( normal , fu );
		if( normal[dir] > 0.0 )
		{
			NMG_INDEX_ASSIGN( flags , s , 1 )	/* external shell */
		}
		else
		{
			NMG_INDEX_ASSIGN( flags , s , -1 )	/* void shell */
		}
	}
}

static void
nmg_assoc_void_shells( r , flags , ttol )
struct nmgregion *r;
long *flags;
const struct bn_tol *ttol;
{
	struct shell *s;
	struct faceuse *fu;
	struct loopuse *lu;
	struct edgeuse *eu;
	int ext_shell_id=1;

	NMG_CK_REGION( r );

	if( !r->ra_p )
		nmg_region_a( r , ttol );

	for( BU_LIST_FOR( s , shell , &r->s_hd ) )
	{

		NMG_CK_SHELL( s );
		if( !s->sa_p )
			nmg_shell_a( s , ttol );

		if( NMG_INDEX_GET( flags , s ) == 1 )
		{
			struct shell *void_s;

			/* identify this external shell */
			NMG_INDEX_ASSIGN( flags , s , ++ext_shell_id );

			/* found an external shell, look for voids */
			for( BU_LIST_FOR( void_s , shell , &r->s_hd ) )
			{
				int wrong_void=0;

				if( void_s == s )
					continue;

				NMG_CK_SHELL( s );
				if( !s->sa_p )
					nmg_shell_a( s , ttol );

				if( NMG_INDEX_GET( flags , void_s ) == (-1) )
				{
					struct shell *test_s;
					int breakout=0;
					int not_in_this_shell=0;

					/* this is a void shell
					 * but does it belong with external shell s */
					if( !V3RPP1_IN_RPP2( void_s->sa_p->min_pt , void_s->sa_p->max_pt , s->sa_p->min_pt , s->sa_p->max_pt ) )
						continue;

					for( BU_LIST_FOR( fu , faceuse , &void_s->fu_hd ) )
					{
						for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
						{
							if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
								continue;
							for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
							{
								int class;

								class = nmg_class_pt_s( eu->vu_p->v_p->vg_p->coord , s, 1 , ttol );

								if( class == NMG_CLASS_AoutB )
								{
									breakout = 1;
									not_in_this_shell = 1;
									break;
								}
								else if( class == NMG_CLASS_AinB )
								{
									breakout = 1;
									break;
								}
							}
							if( breakout )
								break;
						}
						if( breakout )
							break;
					}

					if( not_in_this_shell )
						continue;

					/* Make sure there are no other external shells between these two */
					for( BU_LIST_FOR( test_s , shell , &r->s_hd ) )
					{
						if( NMG_INDEX_GET( flags , test_s ) > 1 )
						{

							if( !V3RPP1_IN_RPP2( void_s->sa_p->min_pt , void_s->sa_p->max_pt , test_s->sa_p->min_pt , test_s->sa_p->max_pt ) )
								continue;

							/* XXXX check for wrong_void, set to one if wrong */
						}
					}
					if( wrong_void )
						continue;

					/* This void shell belongs with shell s
					 * mark it with the negative of external shells flag id */
					NMG_INDEX_ASSIGN( flags , void_s , (-NMG_INDEX_GET( flags , s )) );
				}
			}
		}
	}
}
#endif

/*	Routine to write an nmgregion in the TANKILL format */
static void
Write_tankill_region(struct nmgregion *r, struct db_tree_state *tsp, struct db_full_path *pathp)
{
	struct model *m;
	struct shell *s;
	struct bu_ptbl vertices;	/* vertex list in TANKILL order */
	long *flags;			/* array to insure that no loops are missed */
	int i;

	NMG_CK_REGION( r );
	m = r->m_p;
	NMG_CK_MODEL( m );

	/* if bounds haven't been calculated, do it now */
	if( r->ra_p == NULL )
		nmg_region_a( r , &tol );

	/* Check if region extents are beyond the limitations of the TANKILL format */
	for( i=X ; i<ELEMENTS_PER_PT ; i++ )
	{
		if( r->ra_p->min_pt[i] < (-12000.0) )
		{
			bu_log( "g-tankill: Coordinates too large (%g) for TANKILL format\n" , r->ra_p->min_pt[i] );
			return;
		}
		if( r->ra_p->max_pt[i] > 12000.0 )
		{
			bu_log( "g-tankill: Coordinates too large (%g) for TANKILL format\n" , r->ra_p->max_pt[i] );
			return;
		}
	}
#if 0

	/* First make sure that each shell is broken down into maximally connected shells
	 * and while we're at it, split touching loops
	 */
	bu_ptbl_init( &shells , 64, " &shells ");
	for( BU_LIST_FOR( s , shell , &r->s_hd ) )
	{
		NMG_CK_SHELL( s );
		bu_ptbl_ins( &shells , (long *)s );
		nmg_s_split_touchingloops( s , &tol );
	}

	for( i=0 ; i<BU_PTBL_END( &shells ) ; i++ )
	{
		s = (struct shell *)BU_PTBL_GET( &shells , i );
		(void)nmg_decompose_shell( s , &tol );
	}

	bu_ptbl_free( &shells );

	/* Now triangulate the entire model */
	nmg_triangulate_model( r->m_p , &tol );

	/* XXXXX temporary fix for OT_UNSPEC loops */
	for( BU_LIST_FOR( r , nmgregion , &l->r_hd ) )
	{
		for( BU_LIST_FOR( s , shell , &r->s_hd ) )
		{
			struct faceuse *fu;

			for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
			{
				struct loopuse *lu;

				for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
				{
					if( lu->orientation == OT_UNSPEC )
						lu->orientation = OT_SAME;
				}
			}
		}
	}

	r = BU_LIST_FIRST( nmgregion , &the_model->r_hd );

	/* Need a flag array to insure that no loops are missed */
	flags = (long *)bu_calloc( (*tsp->ts_m)->maxindex , sizeof( long ) , "g-tankill: flags" );

	/* Worry about external/void shells here
	 * void shells should be merged back into their respective external shells
	 * first mark all shells as external or void
	 */
	nmg_find_void_shells( r , flags , &tol );

	/* Now asociate void shells with their respective external shells */
	nmg_assoc_void_shells( r , flags , &tol );

	/* Now merge external shell with all its void shells */
	for( BU_LIST_FOR( s , shell , &r->s_hd ) )
	{
		if( NMG_INDEX_GET( flags , s ) > 1 )
		{
			struct shell *s2;

			s2 = BU_LIST_FIRST( shell , &r->s_hd );
			while( BU_LIST_NOT_HEAD( s2 , &r->s_hd ) )
			{
				if( NMG_INDEX_GET( flags , s2 ) == (-NMG_INDEX_GET( flags , s ) ) )
				{
					struct shell *s_next;

					s_next = BU_LIST_PNEXT( shell , s2 );
					nmg_js( s , s2 , &tol );
					s2 = s_next;
				}
				else
					s2 = BU_LIST_PNEXT( shell , s2 );
			}
		}
		else if( NMG_INDEX_GET( flags , s ) > (-2) )
			bu_log( "Shell x%x is incorrectly marked as %d\n" , s , NMG_INDEX_GET( flags , s ) );
	}
#else
	/* Now triangulate the entire model */
	nmg_triangulate_model( m , &tol );

	/* Need a flag array to insure that no loops are missed */
	flags = (long *)bu_calloc( m->maxindex , sizeof( long ) , "g-tankill: flags" );
#endif

	/* Output each shell as a TANKILL object */
	bu_ptbl_init( &vertices , 64, " &vertices ");
	for( BU_LIST_FOR( s , shell , &r->s_hd ) )
	{
		struct faceuse *fu;
		struct loopuse *lu;
		struct edgeuse *eu;
		struct edgeuse *eu1;
		int missed_loops;

		NMG_CK_SHELL( s );

		/* Make the "patch" style list of vertices */

		/* Put entire first loop on list */
		fu = BU_LIST_FIRST( faceuse , &s->fu_hd );
		NMG_CK_FACEUSE( fu );
		while( fu->orientation != OT_SAME && BU_LIST_NOT_HEAD( fu , &s->fu_hd ) )
			fu = BU_LIST_PNEXT( faceuse , fu );

		if( BU_LIST_IS_HEAD( fu , &s->fu_hd ) )
			continue;

		lu = BU_LIST_FIRST( loopuse , &fu->lu_hd );
		NMG_CK_LOOPUSE( lu );
		while( BU_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC &&
			BU_LIST_NOT_HEAD( lu , &fu->lu_hd ) )
		{
			lu = BU_LIST_PNEXT( loopuse , lu );
		}

		if( BU_LIST_IS_HEAD( lu , &fu->lu_hd ) )
		{
			bu_log( "g-tankill: faceuse has no loops with edges\n" );
			goto outt;
		}

		if( lu->orientation != OT_SAME )
		{
			bu_log( "g-tankill: Found a hole in a triangulated face!!!\n" );
			nmg_pr_fu_briefly( fu , (char *)NULL );
			goto outt;
		}

		for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
		{
			NMG_CK_EDGEUSE( eu );
			bu_ptbl_ins( &vertices , (long *)eu->vu_p->v_p );
		}
		eu1 = BU_LIST_PLAST_PLAST( edgeuse , &lu->down_hd );
		NMG_CK_EDGEUSE( eu1 );

		/* mark this loopuse as processed */
		NMG_INDEX_SET( flags , lu );
		NMG_INDEX_SET( flags , lu->lumate_p );

		/* Now travel through all the loops via radial structure */
		missed_loops = 1;
		while( missed_loops )
		{
			NMG_CK_EDGEUSE( eu1 );

			/* move to the radial */
			eu = eu1->eumate_p->radial_p;
			NMG_CK_EDGEUSE( eu );

			/* make sure we stay within the intended shell */
			while(     nmg_find_s_of_eu( eu ) != s
				&& eu != eu1
				&& eu != eu1->eumate_p
				&& *eu->up.magic_p != NMG_LOOPUSE_MAGIC )
					eu = eu->eumate_p->radial_p;

			if( nmg_find_s_of_eu( eu ) != s )
			{
				bu_log( "g-tankill: different shells are connected via radials\n" );
				goto outt;
			}

			/* get the loopuse containing this edgeuse */
			lu = eu->up.lu_p;
			NMG_CK_LOOPUSE( lu );

			/* if this loop hasn't been processed, put it on the list */
			if( NMG_INDEX_TEST_AND_SET( flags , lu ) )
			{
				NMG_INDEX_SET( flags , lu->lumate_p );
				eu1 = BU_LIST_PNEXT_CIRC( edgeuse , eu );
				bu_ptbl_ins( &vertices , (long *)eu1->eumate_p->vu_p->v_p );
			}
			else
			{
				/* back to a loop that was already done */
				fastf_t dist_to_loop=MAX_FASTF;
				vect_t to_loop;
				struct loopuse *next_lu=NULL;

				/* Check for missed loops */
				for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
				{
					if( fu->orientation != OT_SAME )
						continue;

					for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
					{
						fastf_t tmp_dist;

						/* if this loop was done continue looking */
						if( NMG_INDEX_TEST( flags , lu ) )
							continue;

						/* skips loops of a single vertex */
						if( BU_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
							continue;

						/* shouldn't be any holes!!! */
						if( lu->orientation != OT_SAME )
						{
							bu_log( "g-tankill: Found a hole in a triangulated face!!!\n" );
							nmg_pr_fu_briefly( fu , (char *)NULL );
							goto outt;
						}

						/* find the closest unprocessed loop */
						eu = BU_LIST_FIRST( edgeuse , &lu->down_hd );
						VSUB2( to_loop , eu->vu_p->v_p->vg_p->coord , eu1->vu_p->v_p->vg_p->coord );
						tmp_dist = MAGSQ( to_loop );
						if( tmp_dist < dist_to_loop )
						{
							dist_to_loop = tmp_dist;
							next_lu = lu;
						}
					}
				}
				if( next_lu == NULL )
				{
					/* we're done */
					missed_loops = 0;
					break;
				}

				/* repeat the last vertex */
				bu_ptbl_ins( &vertices , BU_PTBL_GET( &vertices , BU_PTBL_END( &vertices ) - 1 ) );

				/* put first vertex of next loop on list twice */
				lu = next_lu;
				eu = BU_LIST_FIRST( edgeuse , &lu->down_hd );
				NMG_CK_EDGEUSE( eu );
				bu_ptbl_ins( &vertices , (long *)eu->vu_p->v_p );

				/* put loop on list */
				for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
					bu_ptbl_ins( &vertices , (long *)eu->vu_p->v_p );

				eu1 = BU_LIST_PLAST_PLAST( edgeuse , &lu->down_hd );
				NMG_CK_EDGEUSE( eu1 );

				/* mark loopuse as processed */
				NMG_INDEX_SET( flags , lu );
				NMG_INDEX_SET( flags , lu->lumate_p );
			}
		}

		/* Now write the data out */
		if( fp_id )	/* Use id count instead of actual id */
			fprintf( fp_out , "%d %d %d           " ,
				BU_PTBL_END( &vertices ), id_counter , surr_code );
		else
			fprintf( fp_out , "%d %d %d           " ,
				BU_PTBL_END( &vertices ), tsp->ts_regionid , surr_code );
		for( i=0 ; i<BU_PTBL_END( &vertices ) ; i++ )
		{
			struct vertex *v;

			v = (struct vertex *)BU_PTBL_GET( &vertices , i );
			if( (i-1)%4 == 0 )
				fprintf( fp_out , " %.3f %.3f %.3f\n" , V3ARGS( v->vg_p->coord ) );
			else
				fprintf( fp_out , " %.3f %.3f %.3f" , V3ARGS( v->vg_p->coord ) );
		}
		if( (BU_PTBL_END( &vertices )-2)%4 != 0 )
			fprintf( fp_out, "\n" );

		/* clear the vertices list for the next shell */
		bu_ptbl_reset( &vertices );
	}

	/* write info to the idents file if one is open */
	if( fp_id != NULL )
	{
		struct directory *fp_name;	/* name from pathp */

		fp_name = DB_FULL_PATH_CUR_DIR( pathp );
		fprintf( fp_id , "%d %d %s %d %d %d %s\n" , id_counter , tsp->ts_regionid ,
			fp_name->d_namep , tsp->ts_aircode , tsp->ts_gmater , tsp->ts_los ,
			tsp->ts_mater.ma_shader );
	}

 outt:	bu_free( (char *)flags , "g-tankill: flags" );
	bu_ptbl_free( &vertices );
}

/*
 *			M A I N
 */
int
main(int argc, char **argv)
{
	int		j;
	register int	c;
	double		percent;

	port_setlinebuf( stderr );

#if MEMORY_LEAK_CHECKING
	rt_g.debug |= DEBUG_MEM_FULL;
#endif
	the_model = nmg_mm();
	tree_state = rt_initial_tree_state;	/* struct copy */
	tree_state.ts_tol = &tol;
	tree_state.ts_ttol = &ttol;
	tree_state.ts_m = &the_model;

	ttol.magic = RT_TESS_TOL_MAGIC;
	/* Defaults, updated by command line options. */
	ttol.abs = 0.0;
	ttol.rel = 0.01;
	ttol.norm = 0.0;

	/* XXX These need to be improved */
	tol.magic = BN_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;

	/* XXX For visualization purposes, in the debug plot files */
	{
		extern fastf_t	nmg_eue_dist;	/* librt/nmg_plot.c */
		/* XXX This value is specific to the Bradley */
		nmg_eue_dist = 2.0;
	}

	rt_init_resource( &rt_uniresource, 0, NULL );

	BU_LIST_INIT( &rt_g.rtg_vlfree );	/* for vlist macros */

	/* Get command line arguments. */
	while ((c = getopt(argc, argv, "a:i:n:o:r:s:vx:P:X:")) != EOF) {
		switch (c) {
		case 'a':		/* Absolute tolerance. */
			ttol.abs = atof(optarg);
			ttol.rel = 0.0;
			break;
		case 'i':		/* Idents output file */
			id_file = optarg;
			break;
		case 'n':		/* Surface normal tolerance. */
			ttol.norm = atof(optarg);
			ttol.rel = 0.0;
			break;
		case 'o':		/* Output file name */
			out_file = optarg;
			break;
		case 'r':		/* Relative tolerance. */
			ttol.rel = atof(optarg);
			break;
		case 's':		/* Surroundings Code */
			surr_code = atoi(optarg);
			break;
		case 'v':
			verbose++;
			break;
		case 'P':
/*			ncpu = atoi( optarg ); */
			bu_debug = BU_DEBUG_COREDUMP;	/* to get core dumps */
			break;
		case 'x':
			sscanf( optarg, "%x", (unsigned int *)&rt_g.debug );
			break;
		case 'X':
			sscanf( optarg, "%x", (unsigned int *)&rt_g.NMG_debug );
			NMG_debug = rt_g.NMG_debug;
			break;
		default:
			fprintf(stderr, usage, argv[0]);
			exit(1);
			break;
		}
	}

	if (optind+1 >= argc) {
		fprintf(stderr, usage, argv[0]);
		exit(1);
	}

	/* Open brl-cad database */
	if ((dbip = db_open( argv[optind] , "r")) == DBI_NULL)
	{
		bu_log( "Cannot open %s\n" , argv[optind] );
		perror(argv[0]);
		exit(1);
	}
	db_dirbuild( dbip );

	if( out_file == NULL )
		fp_out = stdout;
	else
	{
		if ((fp_out = fopen( out_file , "w")) == NULL)
		{
			bu_log( "Cannot open %s\n" , out_file );
			perror( argv[0] );
			return 2;
		}
	}

	if( id_file != NULL )
	{
		if ((fp_id = fopen( id_file , "w")) == NULL)
		{
			bu_log( "Cannot open %s\n" , id_file );
			perror( argv[0] );
			return 2;
		}
	}

	optind++;

	/* First produce a list of region ident codes */
	(void)db_walk_tree(dbip, argc-optind, (const char **)(&argv[optind]),
		1,				/* ncpu */
		&tree_state,
		get_reg_id,			/* put id in table */
		region_stub,			/* do nothing */
		leaf_stub,
		(genptr_t)NULL );			/* do nothing */

	/* TANKILL only allows up to 2000 distinct component codes */
	if( ident_count > 2000 )
	{
		bu_log( "Too many ident codes for TANKILL\n" );
		bu_log( "\tProcessing all regions anyway\n" );
	}

	/* Process regions in ident order */
	curr_id = 0;
	for( id_counter=0 ; id_counter<ident_count ; id_counter++ )
	{
		int next_id = 99999999;
		for( j=0 ; j<ident_count ; j++ )
		{
			int test_id;

			test_id = idents[j];
			if( test_id > curr_id && test_id < next_id )
				next_id = test_id;
		}
		curr_id = next_id;

		/* give user something to look at */
		bu_log( "Processing id %d\n" , curr_id );

		/* Walk indicated tree(s).  Each region will be output separately */
		(void)db_walk_tree(dbip, argc-optind, (const char **)(&argv[optind]),
			1,				/* ncpu */
			&tree_state,
			select_region,			/* selects regions with curr_id */
			do_region_end,			/* calls Write_tankill_region */
			nmg_booltree_leaf_tess,
			(genptr_t)NULL);	/* in librt/nmg_bool.c */
	}

	percent = 0;
	if( regions_tried > 0 )
		percent = ((double)regions_converted * 100) / regions_tried;
	printf( "Tried %d regions, %d converted to NMG's successfully.  %g%%\n",
		regions_tried, regions_converted, percent );
	percent = 0;
	if( regions_tried > 0 )
		percent = ((double)regions_written * 100) / regions_tried;
	printf( "                  %d triangulated successfully. %g%%\n",
		regions_written, percent );
#if 0
	/* Release dynamic storage */
	nmg_km(the_model);
	bn_vlist_cleanup();
	db_close(dbip); 
#endif
#if MEMORY_LEAK_CHECKING
	bu_prmem("After complete G-TANKILL conversion");
#endif

	return 0;
}

/*
*			D O _ R E G I O N _ E N D
*
*  Called from db_walk_tree().
*
*  This routine must be prepared to run in parallel.
*/
union tree *do_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
{
	struct nmgregion	*r;
	struct bu_list		vhead;
	union tree		*ret_tree;

	RT_CK_TESS_TOL(tsp->ts_ttol);
	BN_CK_TOL(tsp->ts_tol);
	NMG_CK_MODEL(*tsp->ts_m);

	BU_LIST_INIT(&vhead);

	if (RT_G_DEBUG&DEBUG_TREEWALK || verbose) {
		char	*sofar = db_path_to_string(pathp);
		bu_log("\ndo_region_end(%d %d%%) %s\n",
			regions_tried,
			regions_tried>0 ? (regions_converted * 100) / regions_tried : 0,
			sofar);
		bu_free(sofar, "path string");
	}

	if (curtree->tr_op == OP_NOP)
		return  curtree;

	regions_tried++;
	/* Begin rt_bomb() protection */
	if( BU_SETJUMP )
	{
		char *sofar;

		/* Error, bail out */
		BU_UNSETJUMP;		/* Relinquish the protection */

		sofar = db_path_to_string(pathp);
		bu_log( "FAILED in Boolean evaluation: %s\n", sofar );
		bu_free( (char *)sofar, "sofar" );

		/* Sometimes the NMG library adds debugging bits when
		 * it detects an internal error, before rt_bomb().
		 */
		rt_g.NMG_debug = NMG_debug;	/* restore mode */

		/* Release any intersector 2d tables */
		nmg_isect2d_final_cleanup();

		/* Get rid of (m)any other intermediate structures */
		if( (*tsp->ts_m)->magic == NMG_MODEL_MAGIC )
		{
			nmg_km(*tsp->ts_m);
		}
		else
		{
			bu_log("WARNING: tsp->ts_m pointer corrupted, ignoring it.\n");
		}
	
		/* Now, make a new, clean model structure for next pass. */
		*tsp->ts_m = nmg_mm();
		goto out;
	}
	(void)nmg_model_fuse(*tsp->ts_m, tsp->ts_tol);
	/* librt/nmg_bool.c */
	ret_tree = nmg_booltree_evaluate(curtree, tsp->ts_tol, &rt_uniresource);

	if( ret_tree )
		r = ret_tree->tr_d.td_r;
	else
		r = (struct nmgregion *)NULL;

	BU_UNSETJUMP;		/* Relinquish the protection */
	regions_converted++;
	if (r != 0)
	{
		struct shell *s;
		int empty_region=0;
		int empty_model=0;

		/* Kill cracks */
		s = BU_LIST_FIRST( shell, &r->s_hd );
		while( BU_LIST_NOT_HEAD( &s->l, &r->s_hd ) )
		{
			struct shell *next_s;

			next_s = BU_LIST_PNEXT( shell, &s->l );
			if( nmg_kill_cracks( s ) )
			{
				if( nmg_ks( s ) )
				{
					empty_region = 1;
					break;
				}
			}
			s = next_s;
		}

		/* kill zero length edgeuses */
		if( !empty_region )
		{
			 empty_model = nmg_kill_zero_length_edgeuses( *tsp->ts_m );
		}

		if( !empty_region && !empty_model )
		{
			if( BU_SETJUMP )
			{
				char *sofar;

				BU_UNSETJUMP;

				sofar = db_path_to_string(pathp);
				bu_log( "FAILED in triangulator: %s\n", sofar );
				bu_free( (char *)sofar, "sofar" );

				/* Sometimes the NMG library adds debugging bits when
				 * it detects an internal error, before rt_bomb().
				 */
				rt_g.NMG_debug = NMG_debug;	/* restore mode */

				/* Release any intersector 2d tables */
				nmg_isect2d_final_cleanup();

				/* Get rid of (m)any other intermediate structures */
				if( (*tsp->ts_m)->magic == NMG_MODEL_MAGIC )
				{
					nmg_km(*tsp->ts_m);
				}
				else
				{
					bu_log("WARNING: tsp->ts_m pointer corrupted, ignoring it.\n");
				}
			
				/* Now, make a new, clean model structure for next pass. */
				*tsp->ts_m = nmg_mm();
				goto out;
			}

			/* Write the region to the TANKILL file */
			Write_tankill_region( r , tsp , pathp );

			regions_written++;

			BU_UNSETJUMP;
		}

		if( !empty_model )
			nmg_kr( r );
	}

out:
	/*
	 *  Dispose of original tree, so that all associated dynamic
	 *  memory is released now, not at the end of all regions.
	 *  A return of TREE_NULL from this routine signals an error,
	 *  so we need to cons up an OP_NOP node to return.
	 */
	db_free_tree(curtree, &rt_uniresource);		/* Does an nmg_kr() */

	BU_GETUNION(curtree, tree);
	curtree->magic = RT_TREE_MAGIC;
	curtree->tr_op = OP_NOP;
	return(curtree);
}
@


11.29
log
@change conf.h to a wrapped config.h
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /cvs/brlcad/conv/g-tankill.c,v 11.28 2004/04/05 07:49:36 morrison Exp $";
@


11.28
log
@merge of ansi-6-0-branch into HEAD
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header$";
d28 5
a32 1
#include "conf.h"
@


11.27
log
@update copyright to include span through 2003
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-tankill.c,v 11.26 2002/08/20 17:07:21 jra Exp $";
d87 1
a87 2
insert_id( id )
int id;
d109 1
a109 5
select_region( tsp, pathp, combp, client_data )
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
const struct rt_comb_internal *combp;
genptr_t		client_data;
d119 1
a119 5
get_reg_id( tsp, pathp, combp, client_data )
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
const struct rt_comb_internal *combp;
genptr_t		client_data;
d127 1
a127 5
region_stub( tsp, pathp, curtree, client_data )
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
d137 1
a137 5
leaf_stub( tsp, pathp, ip, client_data )
struct db_tree_state    *tsp;
struct db_full_path     *pathp;
struct rt_db_internal	*ip;
genptr_t		client_data;
d306 1
a306 4
Write_tankill_region( r , tsp , pathp )
struct nmgregion *r;
struct db_tree_state *tsp;
struct db_full_path *pathp;
d633 1
a633 3
main(argc, argv)
int	argc;
char	*argv[];
d830 1
a830 5
union tree *do_region_end(tsp, pathp, curtree, client_data)
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
@


11.26
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1993 by the United States Army
d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-tankill.c,v 11.24 2001/08/10 21:22:53 butler Exp $";
@


11.26.4.1
log
@sync to HEAD...
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d25 1
a25 1
static const char RCSid[] = "$Header: /n/cad/c/CVS/brlcad/conv/g-tankill.c,v 11.27 2004/02/02 17:39:00 morrison Exp $";
@


11.26.10.1
log
@merge from HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-tankill.c,v 11.27 2004/02/02 17:39:00 morrison Exp $";
@


11.26.10.2
log
@merge from head
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-tankill.c,v 11.26.10.1 2004/02/12 19:24:23 erikg Exp $";
@


11.26.2.1
log
@Initial ANSIfication
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-tankill.c,v 11.26 2002/08/20 17:07:21 jra Exp $";
d87 2
a88 1
insert_id(int id)
d110 5
a114 1
select_region(register struct db_tree_state *tsp, struct db_full_path *pathp, const struct rt_comb_internal *combp, genptr_t client_data)
d124 5
a128 1
get_reg_id(register struct db_tree_state *tsp, struct db_full_path *pathp, const struct rt_comb_internal *combp, genptr_t client_data)
d136 5
a140 1
region_stub(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
d150 5
a154 1
leaf_stub(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
d323 4
a326 1
Write_tankill_region(struct nmgregion *r, struct db_tree_state *tsp, struct db_full_path *pathp)
d653 3
a655 1
main(int argc, char **argv)
d852 5
a856 1
union tree *do_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
@


11.26.2.2
log
@sync branch with HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d25 1
a25 1
static const char RCSid[] = "$Header$";
@


11.25
log
@Converted from K&R to ANSI C - RFH
@
text
@d87 2
a88 1
insert_id(int id)
d110 5
a114 1
select_region(register struct db_tree_state *tsp, struct db_full_path *pathp, const struct rt_comb_internal *combp, genptr_t client_data)
d124 5
a128 1
get_reg_id(register struct db_tree_state *tsp, struct db_full_path *pathp, const struct rt_comb_internal *combp, genptr_t client_data)
d136 5
a140 1
region_stub(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
d150 5
a154 1
leaf_stub(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
d323 4
a326 1
Write_tankill_region(struct nmgregion *r, struct db_tree_state *tsp, struct db_full_path *pathp)
d653 3
a655 1
main(int argc, char **argv)
d852 5
a856 1
union tree *do_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
@


11.24
log
@Compiler warning patches
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-tankill.c,v 11.23 2001/05/17 20:03:14 morrison Exp $";
d87 1
a87 2
insert_id( id )
int id;
d109 1
a109 5
select_region( tsp, pathp, combp, client_data )
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
const struct rt_comb_internal *combp;
genptr_t		client_data;
d119 1
a119 5
get_reg_id( tsp, pathp, combp, client_data )
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
const struct rt_comb_internal *combp;
genptr_t		client_data;
d127 1
a127 5
region_stub( tsp, pathp, curtree, client_data )
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
d137 1
a137 5
leaf_stub( tsp, pathp, ip, client_data )
struct db_tree_state    *tsp;
struct db_full_path     *pathp;
struct rt_db_internal	*ip;
genptr_t		client_data;
d306 1
a306 4
Write_tankill_region( r , tsp , pathp )
struct nmgregion *r;
struct db_tree_state *tsp;
struct db_full_path *pathp;
d633 1
a633 3
main(argc, argv)
int	argc;
char	*argv[];
d830 1
a830 5
union tree *do_region_end(tsp, pathp, curtree, client_data)
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
@


11.23
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-tankill.c,v 11.22 2001/04/05 19:34:59 morrison Exp $";
d727 1
a727 1
			sscanf( optarg, "%x", &rt_g.debug );
d730 1
a730 1
			sscanf( optarg, "%x", &rt_g.NMG_debug );
@


11.22
log
@updated SIGNED to signed
updated CONST to const
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-tankill.c,v 11.21 2000/09/09 04:53:46 mike Exp $";
d868 1
a868 1
	if (rt_g.debug&DEBUG_TREEWALK || verbose) {
@


11.21
log
@
lint
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-tankill.c,v 11.20 2000/09/08 05:55:42 mike Exp $";
d113 1
a113 1
CONST struct rt_comb_internal *combp;
d127 1
a127 1
CONST struct rt_comb_internal *combp;
d170 2
a171 2
CONST struct nmgregion *r;
CONST struct bn_tol *ttol;
d212 1
a212 1
CONST struct bn_tol *ttol;
d779 1
a779 1
	(void)db_walk_tree(dbip, argc-optind, (CONST char **)(&argv[optind]),
d813 1
a813 1
		(void)db_walk_tree(dbip, argc-optind, (CONST char **)(&argv[optind]),
@


11.20
log
@
Tree routines now need resource structure.
Added rt_init_resource() call.
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-tankill.c,v 11.19 2000/07/21 12:44:34 jra Exp $";
d163 1
d319 1
@


11.19
log
@Replaced db_scan() calls with db_dirbuild()
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-tankill.c,v 11.18 2000/07/12 21:59:35 mike Exp $";
d690 2
d722 1
a722 1
			rt_g.debug = 1;	/* XXX DEBUG_ALLRAYS -- to get core dumps */
d914 2
a915 1
	ret_tree = nmg_booltree_evaluate(curtree, tsp->ts_tol);	/* librt/nmg_bool.c */
d1008 1
a1008 1
	db_free_tree(curtree);		/* Does an nmg_kr() */
@


11.18
log
@
Converted to use new version of LIBWDB
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-tankill.c,v 11.17 2000/07/10 23:53:57 mike Exp $";
d748 1
a748 1
	db_scan(dbip, (int (*)())db_diradd, 1, NULL);
@


11.17
log
@
lint
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-tankill.c,v 11.16 2000/06/30 15:04:00 mike Exp $";
a853 1
	extern FILE		*fp_fig;
@


11.16
log
@
db_walk_tree new arg list for leaf callback.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-tankill.c,v 11.15 2000/03/29 18:15:16 mike Exp $";
@


11.15
log
@
Eliminated macro which also appears in vmath.h now
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-tankill.c,v 11.14 2000/03/29 18:07:45 mike Exp $";
d150 1
a150 1
leaf_stub( tsp, pathp, ep, id, client_data )
d153 1
a153 2
struct bu_external      *ep;
int                     id;
@


11.14
log
@
Removed stray RT_EXTERNs, added bn_ prefix.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-tankill.c,v 11.13 2000/03/03 03:37:58 mike Exp $";
a84 6

/* macro to determine if one bounding box is within another */
#define V3RPP1_IN_RPP2( _lo1 , _hi1 , _lo2 , _hi2 )	( \
	(_lo1)[X] >= (_lo2)[X] && (_hi1)[X] <= (_hi2)[X] && \
	(_lo1)[Y] >= (_lo2)[Y] && (_hi1)[Y] <= (_hi2)[Y] && \
	(_lo1)[Z] >= (_lo2)[Z] && (_hi1)[Z] <= (_hi2)[Z] )
@


11.13
log
@
Made function args match prototype.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-tankill.c,v 11.12 2000/01/04 17:58:19 bparker Exp $";
d46 1
a46 2
RT_EXTERN(union tree *do_region_end, (struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data));
RT_EXTERN( struct face *nmg_find_top_face , (struct shell *s, int *dir, long *flags ));
@


11.12
log
@*- add client_data to db_walk_tree
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-tankill.c,v 11.11 1999/12/30 18:31:54 jra Exp $";
d117 1
a117 1
select_region( tsp, pathp, curtree, client_data )
d120 1
a120 1
union tree		*curtree;
d131 1
a131 1
get_reg_id( tsp, pathp, curtree, client_data )
d134 1
a134 1
union tree		*curtree;
@


11.11
log
@Eliminated some unused variables
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-tankill.c,v 11.10 1999/12/29 23:23:01 mike Exp $";
d46 1
a46 1
RT_EXTERN(union tree *do_region_end, (struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree));
d117 1
a117 1
select_region( tsp, pathp, curtree )
d121 1
d131 1
a131 1
get_reg_id( tsp, pathp, curtree )
d135 1
d143 1
a143 1
region_stub( tsp, pathp, curtree )
d147 1
d157 1
a157 1
leaf_stub( tsp, pathp, ep, id )
d162 1
d788 2
a789 1
		leaf_stub );			/* do nothing */
d822 2
a823 1
			nmg_booltree_leaf_tess);	/* in librt/nmg_bool.c */
d856 1
a856 1
union tree *do_region_end(tsp, pathp, curtree)
d860 1
@


11.10
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-tankill.c,v 11.9 1999/06/03 21:54:20 mike Exp $";
d63 1
a63 1
static int	ncpu = 1;		/* Number of processors */
a216 1
	struct model *m;
a224 2
	m = r->m_p;

a237 2
			struct face *ext_f;
			int dir;
a241 2
			ext_f = nmg_find_top_face( s, &dir, flags );

a331 1
	struct bu_ptbl shells;		/* list of shells to be decomposed */
d723 1
a723 1
			ncpu = atoi( optarg );
@


11.9
log
@
sed4
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-tankill.c,v 11.8 1996/12/04 04:03:51 mike Exp $";
d760 1
a760 1
	db_scan(dbip, (int (*)())db_diradd, 1);
@


11.8
log
@ma_shader
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-tankill.c,v 11.7 1996/08/02 12:46:58 jra Exp mike $";
d78 1
a78 1
static struct rt_tol		tol;
d149 1
a149 1
	rt_log( "region stub called (for object %s), this shouldn't happen\n" , fp_name->d_namep );
d157 1
a157 1
struct rt_external      *ep;
d163 1
a163 1
	rt_log( "Only regions may be converted to TANKILL format\n\t%s is not a region and will be ignored\n" , fp_name->d_namep );
d174 1
a174 1
CONST struct rt_tol *ttol;
d185 1
a185 1
	for( RT_LIST_FOR( s , shell , &r->s_hd ) )
d215 1
a215 1
CONST struct rt_tol *ttol;
d231 1
a231 1
	for( RT_LIST_FOR( s , shell , &r->s_hd ) )
d250 1
a250 1
			for( RT_LIST_FOR( void_s , shell , &r->s_hd ) )
d272 1
a272 1
					for( RT_LIST_FOR( fu , faceuse , &void_s->fu_hd ) )
d274 1
a274 1
						for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d276 1
a276 1
							if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d278 1
a278 1
							for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d307 1
a307 1
					for( RT_LIST_FOR( test_s , shell , &r->s_hd ) )
d339 2
a340 2
	struct nmg_ptbl shells;		/* list of shells to be decomposed */
	struct nmg_ptbl vertices;	/* vertex list in TANKILL order */
d357 1
a357 1
			rt_log( "g-tankill: Coordinates too large (%g) for TANKILL format\n" , r->ra_p->min_pt[i] );
d362 1
a362 1
			rt_log( "g-tankill: Coordinates too large (%g) for TANKILL format\n" , r->ra_p->max_pt[i] );
d371 2
a372 2
	nmg_tbl( &shells , TBL_INIT , NULL );
	for( RT_LIST_FOR( s , shell , &r->s_hd ) )
d375 1
a375 1
		nmg_tbl( &shells , TBL_INS , (long *)s );
d379 1
a379 1
	for( i=0 ; i<NMG_TBL_END( &shells ) ; i++ )
d381 1
a381 1
		s = (struct shell *)NMG_TBL_GET( &shells , i );
d385 1
a385 1
	nmg_tbl( &shells , TBL_FREE , NULL );
d391 1
a391 1
	for( RT_LIST_FOR( r , nmgregion , &l->r_hd ) )
d393 1
a393 1
		for( RT_LIST_FOR( s , shell , &r->s_hd ) )
d397 1
a397 1
			for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
d401 1
a401 1
				for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d410 1
a410 1
	r = RT_LIST_FIRST( nmgregion , &the_model->r_hd );
d413 1
a413 1
	flags = (long *)rt_calloc( (*tsp->ts_m)->maxindex , sizeof( long ) , "g-tankill: flags" );
d425 1
a425 1
	for( RT_LIST_FOR( s , shell , &r->s_hd ) )
d431 2
a432 2
			s2 = RT_LIST_FIRST( shell , &r->s_hd );
			while( RT_LIST_NOT_HEAD( s2 , &r->s_hd ) )
d438 1
a438 1
					s_next = RT_LIST_PNEXT( shell , s2 );
d443 1
a443 1
					s2 = RT_LIST_PNEXT( shell , s2 );
d447 1
a447 1
			rt_log( "Shell x%x is incorrectly marked as %d\n" , s , NMG_INDEX_GET( flags , s ) );
d454 1
a454 1
	flags = (long *)rt_calloc( m->maxindex , sizeof( long ) , "g-tankill: flags" );
d458 2
a459 2
	nmg_tbl( &vertices , TBL_INIT , NULL );
	for( RT_LIST_FOR( s , shell , &r->s_hd ) )
d472 1
a472 1
		fu = RT_LIST_FIRST( faceuse , &s->fu_hd );
d474 2
a475 2
		while( fu->orientation != OT_SAME && RT_LIST_NOT_HEAD( fu , &s->fu_hd ) )
			fu = RT_LIST_PNEXT( faceuse , fu );
d477 1
a477 1
		if( RT_LIST_IS_HEAD( fu , &s->fu_hd ) )
d480 1
a480 1
		lu = RT_LIST_FIRST( loopuse , &fu->lu_hd );
d482 2
a483 2
		while( RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC &&
			RT_LIST_NOT_HEAD( lu , &fu->lu_hd ) )
d485 1
a485 1
			lu = RT_LIST_PNEXT( loopuse , lu );
d488 1
a488 1
		if( RT_LIST_IS_HEAD( lu , &fu->lu_hd ) )
d490 1
a490 1
			rt_log( "g-tankill: faceuse has no loops with edges\n" );
d496 1
a496 1
			rt_log( "g-tankill: Found a hole in a triangulated face!!!\n" );
d501 1
a501 1
		for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d504 1
a504 1
			nmg_tbl( &vertices , TBL_INS , (long *)eu->vu_p->v_p );
d506 1
a506 1
		eu1 = RT_LIST_PLAST_PLAST( edgeuse , &lu->down_hd );
d532 1
a532 1
				rt_log( "g-tankill: different shells are connected via radials\n" );
d544 2
a545 2
				eu1 = RT_LIST_PNEXT_CIRC( edgeuse , eu );
				nmg_tbl( &vertices , TBL_INS , (long *)eu1->eumate_p->vu_p->v_p );
d555 1
a555 1
				for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
d560 1
a560 1
					for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d569 1
a569 1
						if( RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
d575 1
a575 1
							rt_log( "g-tankill: Found a hole in a triangulated face!!!\n" );
d581 1
a581 1
						eu = RT_LIST_FIRST( edgeuse , &lu->down_hd );
d599 1
a599 1
				nmg_tbl( &vertices , TBL_INS , NMG_TBL_GET( &vertices , NMG_TBL_END( &vertices ) - 1 ) );
d603 1
a603 1
				eu = RT_LIST_FIRST( edgeuse , &lu->down_hd );
d605 1
a605 1
				nmg_tbl( &vertices , TBL_INS , (long *)eu->vu_p->v_p );
d608 2
a609 2
				for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
					nmg_tbl( &vertices , TBL_INS , (long *)eu->vu_p->v_p );
d611 1
a611 1
				eu1 = RT_LIST_PLAST_PLAST( edgeuse , &lu->down_hd );
d623 1
a623 1
				NMG_TBL_END( &vertices ), id_counter , surr_code );
d626 2
a627 2
				NMG_TBL_END( &vertices ), tsp->ts_regionid , surr_code );
		for( i=0 ; i<NMG_TBL_END( &vertices ) ; i++ )
d631 1
a631 1
			v = (struct vertex *)NMG_TBL_GET( &vertices , i );
d637 1
a637 1
		if( (NMG_TBL_END( &vertices )-2)%4 != 0 )
d641 1
a641 1
		nmg_tbl( &vertices , TBL_RST , NULL );
d655 2
a656 2
 outt:	rt_free( (char *)flags , "g-tankill: flags" );
	nmg_tbl( &vertices , TBL_FREE , NULL );
d689 1
a689 1
	tol.magic = RT_TOL_MAGIC;
d702 1
a702 1
	RT_LIST_INIT( &rt_g.rtg_vlfree );	/* for vlist macros */
d756 1
a756 1
		rt_log( "Cannot open %s\n" , argv[optind] );
d768 1
a768 1
			rt_log( "Cannot open %s\n" , out_file );
d778 1
a778 1
			rt_log( "Cannot open %s\n" , id_file );
d797 2
a798 2
		rt_log( "Too many ident codes for TANKILL\n" );
		rt_log( "\tProcessing all regions anyway\n" );
d817 1
a817 1
		rt_log( "Processing id %d\n" , curr_id );
d841 1
a841 1
	rt_vlist_cleanup();
d845 1
a845 1
	rt_prmem("After complete G-TANKILL conversion");
d865 1
a865 1
	struct rt_list		vhead;
d869 1
a869 1
	RT_CK_TOL(tsp->ts_tol);
d872 1
a872 1
	RT_LIST_INIT(&vhead);
d876 1
a876 1
		rt_log("\ndo_region_end(%d %d%%) %s\n",
d880 1
a880 1
		rt_free(sofar, "path string");
d888 1
a888 1
	if( RT_SETJUMP )
d893 1
a893 1
		RT_UNSETJUMP;		/* Relinquish the protection */
d896 2
a897 2
		rt_log( "FAILED in Boolean evaluation: %s\n", sofar );
		rt_free( (char *)sofar, "sofar" );
d914 1
a914 1
			rt_log("WARNING: tsp->ts_m pointer corrupted, ignoring it.\n");
d929 1
a929 1
	RT_UNSETJUMP;		/* Relinquish the protection */
d938 2
a939 2
		s = RT_LIST_FIRST( shell, &r->s_hd );
		while( RT_LIST_NOT_HEAD( &s->l, &r->s_hd ) )
d943 1
a943 1
			next_s = RT_LIST_PNEXT( shell, &s->l );
d963 1
a963 1
			if( RT_SETJUMP )
d967 1
a967 1
				RT_UNSETJUMP;
d970 2
a971 2
				rt_log( "FAILED in triangulator: %s\n", sofar );
				rt_free( (char *)sofar, "sofar" );
d988 1
a988 1
					rt_log("WARNING: tsp->ts_m pointer corrupted, ignoring it.\n");
d1001 1
a1001 1
			RT_UNSETJUMP;
d1017 1
a1017 1
	GETUNION(curtree, tree);
@


11.7
log
@Corrected handling of tessellation tolerances options.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-tankill.c,v 11.6 1996/07/02 18:13:52 jra Exp jra $";
d652 1
a652 1
			tsp->ts_mater.ma_matname );
@


11.6
log
@Added code to count and display failures in both the Boolean and Triangulator code.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-tankill.c,v 11.5 1995/04/03 19:48:38 jra Exp jra $";
d622 1
a622 1
			fprintf( fp_out , "%11d%7d%7d           " ,
d625 1
a625 1
			fprintf( fp_out , "%11d%7d%7d           " ,
d633 1
a633 1
				fprintf( fp_out , "%5.0f.%5.0f.%5.0f.\n" , V3ARGS( v->vg_p->coord ) );
d635 1
a635 1
				fprintf( fp_out , "%5.0f.%5.0f.%5.0f." , V3ARGS( v->vg_p->coord ) );
d709 1
d716 1
@


11.5
log
@Added calls to nmg_kill_cracks() and nmg_kill_zero_length_edgeuses().
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-tankill.c,v 11.4 1995/03/29 18:35:08 jra Exp $";
d282 1
a282 1
								class = nmg_class_pt_s( eu->vu_p->v_p->vg_p->coord , s , ttol );
d337 1
d345 2
d388 1
a388 1
	nmg_triangulate_model( the_model , &tol );
d391 1
a391 1
	for( RT_LIST_FOR( r , nmgregion , &the_model->r_hd ) )
d451 1
a451 1
	nmg_triangulate_model( the_model , &tol );
d454 1
a454 1
	flags = (long *)rt_calloc( (*tsp->ts_m)->maxindex , sizeof( long ) , "g-tankill: flags" );
d637 2
a654 2
	regions_written++;

d829 1
a829 1
	printf( "Tried %d regions, %d converted successfully.  %g%%\n",
d834 1
a834 1
	printf( "                  %d written successfully. %g%%\n",
d836 1
a836 1

d840 2
a841 2
	db_close(dbip);

d888 2
d893 4
a904 3
		/* Release the tree memory & input regions */
		db_free_tree(curtree);		/* Does an nmg_kr() */

d961 33
d996 4
d1006 1
a1014 1
out:
@


11.4
log
@Added "curtree->magic = RT_TREE_MAGIC;" to do_region_end().
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-tankill.c,v 11.3 1995/03/29 13:25:22 jra Exp jra $";
d446 6
d925 33
a957 2
		/* Write the region to the TANKILL file */
		Write_tankill_region( r , tsp , pathp );
d959 2
a960 2
		/* NMG region is no longer necessary */
		nmg_kr(r);
@


11.3
log
@Mods to account for new return of nmg_booltree_evaluate().
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-tankill.c,v 11.2 1995/02/22 05:40:55 mike Exp jra $";
d47 1
a47 1
RT_EXTERN( struct face *nmg_find_top_face , (struct shell *s , long *flags ));
d190 1
d192 1
a192 1
		f = nmg_find_top_face( s , flags );
d200 1
a200 1
		if( normal[Z] > 0.0 )
d217 1
d226 2
d242 1
d247 1
a247 1
			ext_f = nmg_find_top_face( s , flags );
a262 1
					struct face *int_f;
a305 2
					int_f = nmg_find_top_face( void_s , flags );

a310 1
							struct face *test_f;
d315 1
a315 7
							test_f = nmg_find_top_face( test_s , flags );
							if( test_f->max_pt[Z] > int_f->max_pt[Z]
							    && test_f->max_pt[Z] < ext_f->max_pt[Z] )
							{
								wrong_void = 1;
								break;
							}
d363 1
d446 1
d936 1
@


11.2
log
@nmg_model_fuse() is still accounting for 25% of the runtime.  In order
to correct this, it is necessary for me to make calling nmg_model_fuse()
a pre-condition of calling nmg_booltree_evaluate().  That way it's done
exactly once per region.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /n/wolf/m/cad/conv/RCS/g-tankill.c,v 11.1 1995/01/04 09:59:36 mike Rel4_4 mike $";
d858 1
d911 7
a917 1
	r = nmg_booltree_evaluate(curtree, tsp->ts_tol);	/* librt/nmg_bool.c */
@


11.1
log
@Release_4.4
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-tankill.c,v 1.14 94/12/16 16:32:47 jra Exp $";
d909 1
@


1.14
log
@removed setjmp.h
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-tankill.c,v 1.13 94/12/08 17:56:29 jra Exp Locker: jra $";
@


1.13
log
@Mod for CRAY2.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /n/wolf/m/cad/conv/RCS/g-tankill.c,v 1.12 94/11/08 16:15:08 jra Exp Locker: jra $";
a36 2

#include <setjmp.h>
@


1.12
log
@Mods for Irix 6.0
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /n/wolf/m/cad/conv/RCS/g-tankill.c,v 1.11 1994/11/02 14:45:53 jra Exp jra $";
d38 2
d881 1
a881 1
	if( ncpu == 1 && RT_SETJUMP )
@


1.11
log
@Updated usage message.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /n/wolf/m/cad/conv/RCS/g-tankill.c,v 1.10 94/08/23 14:30:10 jra Exp Locker: jra $";
d71 5
a75 1
static struct nmg_ptbl		idents;	/* Table of region ident numbers */
d93 22
d135 1
a135 1
	nmg_tbl( &idents , TBL_INS_UNIQUE , (long *)tsp->ts_regionid );
a309 1
							fastf_t test_z;
d661 1
a661 1
	int		i,j,ret;
a688 3
	/* Initialize ident table */
	nmg_tbl( &idents , TBL_INIT , NULL );

d779 1
a779 1
	ret = db_walk_tree(dbip, argc-optind, (CONST char **)(&argv[optind]),
d787 1
a787 1
	if( NMG_TBL_END( &idents ) > 2000 )
d795 1
a795 1
	for( id_counter=0 ; id_counter<NMG_TBL_END( &idents ) ; id_counter++ )
d798 1
a798 1
		for( j=0 ; j<NMG_TBL_END( &idents ) ; j++ )
d802 1
a802 1
			test_id = (int)NMG_TBL_GET( &idents , j );
d812 1
a812 1
		ret = db_walk_tree(dbip, argc-optind, (CONST char **)(&argv[optind]),
@


1.10
log
@removed unused debug_plots variable.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /n/wolf/m/cad/conv/RCS/g-tankill.c,v 1.9 94/08/11 00:06:03 gdurf Exp Locker: jra $";
d49 11
a59 1
static char	usage[] = "Usage: %s [-v] [-d] [-xX lvl] [-a abs_tol] [-r rel_tol] [-n norm_tol] [-s surroundings_code] [-o out_file] brlcad_db.g object(s)\n";
@


1.9
log
@Factored ifdefs
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-tankill.c,v 1.8 1994/07/13 12:22:02 jra Exp gdurf $";
a52 1
static int	debug_plots;		/* Make debugging plots */
d667 1
a667 1
	while ((c = getopt(argc, argv, "a:di:n:o:r:s:vx:P:X:")) != EOF) {
a670 3
			break;
		case 'd':
			debug_plots = 1;
@


1.8
log
@Removed arg declarations from routine definitions.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-tankill.c,v 1.7 94/04/19 18:49:19 jra Exp $";
d28 2
d32 1
d34 4
d631 1
a631 12
#ifdef BSD
	setlinebuf( stderr );
#else
#	if defined( SYSV ) && !defined( sgi ) && !defined(CRAY2) && \
	 !defined(n16)
		(void) setvbuf( stderr, (char *) NULL, _IOLBF, BUFSIZ );
#	endif
#	if defined(sgi) && defined(mips)
		if( setlinebuf( stderr ) != 0 )
			perror("setlinebuf(stderr)");
#	endif
#endif
@


1.7
log
@removed more debug prints
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-tankill.c,v 1.6 94/04/19 18:10:17 jra Exp Locker: jra $";
d342 1
a342 1
		(void)nmg_decompose_shell( s );
d349 22
@


1.6
log
@Removed some debug prints
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-tankill.c,v 1.5 94/03/19 21:49:24 jra Exp $";
a191 2
rt_log( "Checking Shell x%x\n" , s );

a198 1
rt_log( "\tIt is an external shell, give it id %d\n" , NMG_INDEX_GET( flags , s ) );
a209 2
rt_log( "\t\tChecking shell x%x as possible void\n" , void_s );

a219 1
rt_log( "\t\t\tIt is a void shell...\n" );
a223 2
					{
rt_log( "\t\t\t\tNot for this external shell (bounding boxes not within one another)\n" );
a224 1
					}
a239 1
rt_log( "\t\t\tNot for this external shell (point on void shell is outside external shell)\n" );
a282 2
					{
rt_log( "\t\t\t\tWrong void\n" );
a283 1
					}
a287 1
rt_log( "\t\t\t\tMarked this Shell (x%x) as %d\n" , void_s , NMG_INDEX_GET( flags , void_s ) );
a368 2
			rt_log( "Shell x%x is an external shell\n" , s );

a375 1
					rt_log( "\tShell x%x is a void shell\n" , s2 );
d405 1
a405 1
		while( fu->orientation != OT_SAME )
d408 3
d507 1
@


1.5
log
@Added call to split touching loops prior to triangulating faces.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-tankill.c,v 1.4 94/03/18 12:43:59 jra Exp Locker: jra $";
a136 1
rt_log( "In nmg_find_void_shells\n" );
a159 1
rt_log( "Shell x%x is an external shell\n" , s );
a163 1
rt_log( "Shell x%x is a void shell\n" , s );
@


1.4
log
@replaced nmg_merge_shells with nmg_js.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-tankill.c,v 1.3 94/01/07 13:01:12 jra Exp $";
d345 3
a347 1
	/* First make sure that each shell is broken down into maximally connected shells */
d353 1
d445 1
@


1.3
log
@Added ident file capability
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-tankill.c,v 1.2 93/12/09 13:52:16 jra Exp Locker: jra $";
d394 1
a394 1
					nmg_merge_shells( s , s2 );
@


1.2
log
@modified to process regions in order
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /vld/jra/SOURCE/cad/TANKILL/RCS/g-tankill.c,v 1.1 93/12/07 12:32:12 jra Exp Locker: jra $";
d50 1
d53 2
d104 5
a108 2
	rt_log( "region stub called, this shouldn't happen\n" );
	rt_bomb( "region_stub\n" );
d118 5
a122 2
	rt_log( "leaf stub called, this shouldn't happen\n" );
	rt_bomb( "leaf_stub\n" );
d178 3
d226 2
d234 1
a234 1
rt_log( "\t\t\t\tNot for this external shell\n" );
d238 35
d287 2
a288 2
							if( test_f->fg_p->max_pt[Z] > int_f->fg_p->max_pt[Z]
							    && test_f->fg_p->max_pt[Z] < ext_f->fg_p->max_pt[Z] )
d313 1
a313 1
Write_tankill_region( r , tsp )
d316 1
d333 1
a333 1
		if( r->ra_p->min_pt[i] < (-9999.0) )
d338 1
a338 1
		if( r->ra_p->max_pt[i] > 99999.0 )
d564 6
a569 2
		fprintf( fp_out , "%11d%7d%7d           " ,
			NMG_TBL_END( &vertices ), tsp->ts_regionid , surr_code );
d585 11
d662 1
a662 1
	while ((c = getopt(argc, argv, "a:dn:o:r:s:vx:P:X:")) != EOF) {
d670 3
d731 11
d752 6
d761 1
a761 1
	for( i=0 ; i<NMG_TBL_END( &idents ) ; i++ )
d881 1
a881 1
		Write_tankill_region( r , tsp );
@


1.1
log
@Initial revision
@
text
@d14 8
a21 2
 *  Distribution Status -
 *	Public Domain, Distribution Unlimitied.
d25 1
a25 1
static char RCSid[] = "$Header$";
d42 1
a42 1
static char	usage[] = "Usage: %s [-v] [-d] [-xX lvl] [-a abs_tol] [-r rel_tol] [-n norm_tol] [-o out_file] brlcad_db.g object(s)\n";
d48 3
a50 1
static char	*out_file = NULL;	/* output filename */
d52 1
d64 1
d70 46
a313 1
	/* Output each shell as a TANKILL object */
d317 1
a317 1
	/* XXXXXX Need to worry about external/void shells here
d355 1
a366 2
nmg_pr_s_briefly( s , (char *)NULL );

a397 1
rt_log( "vertex: ( %g %g %g ) (first loop x%x eu = x%x)\n" , V3ARGS( eu->vu_p->v_p->vg_p->coord ) , lu , eu );
a401 2
rt_log( "edgeuse: ( %g %g %g ) -> ( %g %g %g ) x%x\n" , V3ARGS( eu1->vu_p->v_p->vg_p->coord ) , 
V3ARGS( eu1->eumate_p->vu_p->v_p->vg_p->coord ) , eu1 );
a410 2
struct vertex *v;
rt_log( "In loop loop\n" );
a423 3
			if( eu == eu1 || eu == eu1->eumate_p )
				continue;

d430 1
d433 2
a439 3
rt_log( "vertex: ( %g %g %g ) (makes another face lu = x%x, eu = x%x)\n" , V3ARGS( eu1->eumate_p->vu_p->v_p->vg_p->coord ) , lu , eu1 );
rt_log( "edgeuse: ( %g %g %g ) -> ( %g %g %g ) x%x\n" , V3ARGS( eu1->vu_p->v_p->vg_p->coord ) , 
V3ARGS( eu1->eumate_p->vu_p->v_p->vg_p->coord ) , eu1 );
d443 1
d458 1
d462 1
d466 1
d486 1
a492 2
v = (struct vertex *)NMG_TBL_GET( &vertices , NMG_TBL_END( &vertices ) - 1 );
rt_log( "vertex: ( %g %g %g ) (repeat of previous)\n" , V3ARGS( v->vg_p->coord ) );
a498 1
rt_log( "vertex: ( %g %g %g ) (extra copy of first vertex in loop)\n" , V3ARGS( eu->vu_p->v_p->vg_p->coord ) );
a501 1
				{
d503 1
a503 2
rt_log( "vertex: ( %g %g %g ) (new loop) lu = x%x , eu = x%x\n" , V3ARGS( eu->vu_p->v_p->vg_p->coord ) , lu , eu );
				}
a505 2
rt_log( "edgeuse: ( %g %g %g ) -> ( %g %g %g )\n" , V3ARGS( eu1->vu_p->v_p->vg_p->coord ) , 
V3ARGS( eu1->eumate_p->vu_p->v_p->vg_p->coord ) , eu1 );
d514 2
a515 2
		fprintf( fp_out , "%11d%7d   1000           " ,
			NMG_TBL_END( &vertices ), tsp->ts_regionid );
d545 1
a545 2
	char		*dot;
	int		i, ret;
a547 1
	struct rt_vls	fig_file;
d584 3
d597 1
a597 1
	while ((c = getopt(argc, argv, "a:dn:o:r:vx:P:X:")) != EOF) {
d614 3
d665 1
a665 1
	/* Walk indicated tree(s).  Each region will be output separately */
d667 1
a667 1
		1,			/* ncpu */
d669 31
a699 3
		0,			/* take all regions */
		do_region_end,
		nmg_booltree_leaf_tess);	/* in librt/nmg_bool.c */
@
