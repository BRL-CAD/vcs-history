head	11.13;
access;
symbols
	ansi-20040405-merged:11.11.2.1
	postmerge-20040405-ansi:11.12
	premerge-20040404-ansi:11.11
	postmerge-autoconf:11.11
	autoconf-freeze:11.11
	premerge-autoconf:11.11
	ansi-20040316-freeze:11.11.2.1
	postmerge-20040315-windows:11.11
	premerge-20040315-windows:11.11
	windows-20040315-freeze:11.11
	autoconf-20031203:11.11
	autoconf-20031202:11.11
	autoconf-branch:11.11.0.10
	phong-branch:11.11.0.8
	photonmap-branch:11.11.0.6
	rel-6-1-DP:11.11
	windows-branch:11.11.0.4
	rel-6-0-2:11.9
	ansi-branch:11.11.0.2
	rel-6-0-1-branch:11.9.0.2
	hartley-6-0-post:11.10
	hartley-6-0-pre:11.9
	rel-6-0-1:11.9
	rel-6-0:11.9
	rel-5-4:11.5
	offsite-5-3-pre:11.9
	rel-5-3:11.5
	rel-5-2:11.5
	rel-5-1-branch:11.5.0.2
	rel-5-1:11.5
	rel-5-0:11.4
	rel-5-0-beta:11.3
	rel-4-5:11.3
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.13
date	2004.05.24.04.16.11;	author morrison;	state dead;
branches;
next	11.12;

11.12
date	2004.04.05.07.49.36;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2002.08.20.17.07.20;	author jra;	state Exp;
branches
	11.11.2.1;
next	11.10;

11.10
date	2002.08.15.20.54.33;	author hartley;	state Exp;
branches;
next	11.9;

11.9
date	2000.10.31.22.35.11;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	2000.07.12.21.59.34;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	2000.07.12.03.51.10;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	2000.07.10.23.53.55;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	2000.03.29.18.07.43;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	99.06.03.21.54.19;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	97.03.05.20.03.58;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	96.07.12.13.20.17;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.59.18;	author mike;	state Rel4_4;
branches;
next	1.8;

1.8
date	94.12.12.21.56.44;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	94.11.22.14.36.45;	author jra;	state Exp;
branches;
next	1.6;

1.6
date	94.11.14.11.04.12;	author jra;	state Exp;
branches;
next	1.5;

1.5
date	94.11.08.16.14.43;	author jra;	state Exp;
branches;
next	1.4;

1.4
date	94.10.11.19.52.15;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	94.10.07.19.45.38;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	94.10.07.19.28.53;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	94.10.07.19.11.46;	author butler;	state Exp;
branches;
next	;

11.11.2.1
date	2002.09.19.18.00.34;	author morrison;	state Exp;
branches;
next	;


desc
@A program to build nmg faces from an ascii description.
@


11.13
log
@moved to src/conv/
@
text
@/*
 *			A S C - N M G . C
 *
 *  Program to convert an ascii description of an NMG into a BRL-CAD
 *  NMG model.
 *
 *  Authors -
 *	Michael Markowski
 *	Lee A. Butler
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/conv/asc-nmg.c,v 11.12 2004/04/05 07:49:36 morrison Exp $ (ARL)";
#endif

#include <stdio.h>
#include <math.h>
#include <string.h>
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "nmg.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "wdb.h"

static int ascii_to_brlcad(FILE *fpin, struct rt_wdb *fpout, char *reg_name, char *grp_name);
static void descr_to_nmg(struct shell *s, FILE *fp, fastf_t *Ext);

char		usage[] = "Usage: %s [file]\n";
extern char	*optarg;
extern int	optind;

/*
 *	M a i n
 *
 *	Get ascii input file and output file names.
 */
int
main(int argc, char **argv)
{
	char		*afile, *bfile = "nmg.g";
	FILE		*fpin;
	struct rt_wdb	*fpout;

	/* Get ascii NMG input file name. */
	if (optind >= argc) {
		afile = "-";
		fpin = stdin;
	} else {
		afile = argv[optind];
		if ((fpin = fopen(afile, "r")) == NULL) {
			fprintf(stderr,
				"%s: cannot open %s for reading\n",
				argv[0], afile);
			exit(1);
		}
	}

	/* Get BRL-CAD output data base name. */
	optind++;
	if (optind >= argc) {
		bfile = "nmg.g";
	} else {
		bfile = argv[optind];
	}
	if ((fpout = wdb_fopen(bfile)) == NULL) {
		fprintf(stderr, "%s: cannot open %s for writing\n",
			argv[0], bfile);
		exit(1);
	}

	ascii_to_brlcad(fpin, fpout, "nmg", NULL);
	fclose(fpin);
	wdb_close(fpout);
	return 0;
}

/*
 *	C r e a t e _ B r l c a d _ D b
 *
 *	Write the nmg to a brl-cad style data base.
 */
void
create_brlcad_db(struct rt_wdb *fpout, struct model *m, char *reg_name, char *grp_name)
{
	char	*rname, *sname;

	mk_id(fpout, "Ascii NMG");

	rname = malloc(sizeof(reg_name) + 3);	/* Region name. */
	sname = malloc(sizeof(reg_name) + 3);	/* Solid name. */

	sprintf(sname, "s.%s", reg_name);
	mk_nmg(fpout, sname,  m);		/* Make nmg object. */
	sprintf(rname, "r.%s", reg_name);
	mk_comb1(fpout, rname, sname, 1);	/* Put object in a region. */
	if (grp_name) {
		mk_comb1(fpout, grp_name, rname, 1);	/* Region in group. */
	}
}

/*
 *	A s c i i _ t o _ B r l c a d
 *
 *	Convert an ascii nmg description into a BRL-CAD data base.
 */
static int
ascii_to_brlcad(FILE *fpin, struct rt_wdb *fpout, char *reg_name, char *grp_name)
{
	struct model	*m;
	struct nmgregion	*r;
	struct bn_tol	tol;
	struct shell	*s;
	vect_t		Ext;
	struct faceuse *fu;
	plane_t		pl;

	VSETALL(Ext, 0.);

	m = nmg_mm();		/* Make nmg model. */
	r = nmg_mrsv(m);	/* Make region, empty shell, vertex */
	s = BU_LIST_FIRST(shell, &r->s_hd);
	descr_to_nmg(s, fpin, Ext);	/* Convert ascii description to nmg. */

        /* Copied from proc-db/nmgmodel.c */
	tol.magic = BN_TOL_MAGIC;
	tol.dist = 0.01;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 0.001;
	tol.para = 0.999;

	/* Associate the face geometry. */
	fu = BU_LIST_FIRST( faceuse , &s->fu_hd );
	if (nmg_loop_plane_area(BU_LIST_FIRST(loopuse, &fu->lu_hd), pl) < 0.0)
		return(-1);
	else
		nmg_face_g( fu , pl );

	if (!NEAR_ZERO(MAGNITUDE(Ext), 0.001))
		nmg_extrude_face(BU_LIST_FIRST(faceuse, &s->fu_hd), Ext, &tol);

	nmg_region_a(r, &tol);	/* Calculate geometry for region and shell. */

	nmg_fix_normals( s , &tol ); /* insure that faces have outward pointing normals */

	create_brlcad_db(fpout, m, reg_name, grp_name);

	nmg_km(m);		/* Destroy the nmg model. */

	return( 0 );
}

/*
 *	D e s c r _ t o _ N M G
 *
 *	Convert an ascii description of an nmg to an actual nmg.
 *	(This should be done with lex and yacc.)
 */
static void
descr_to_nmg(struct shell *s, FILE *fp, fastf_t *Ext)
            	   	/* NMG shell to add loops to. */
    		    	/* File pointer for ascii nmg file. */
      		    	/* Extrusion vector. */
{
#define MAXV	1024

	char	token[80];	/* Token read from ascii nmg file. */
	fastf_t	x, y, z;	/* Coordinates of a vertex. */
	int	dir = OT_NONE;	/* Direction of face. */
	int	i,
		lu_verts[MAXV],	/* Vertex names making up loop. */
		n,		/* Number of vertices so far in loop. */
		stat,		/* Set to EOF when finished ascii file. */
		vert_num;	/* Current vertex in ascii file. */
	fastf_t	pts[3*MAXV];	/* Points in current loop. */
	struct faceuse *fu;	/* Face created. */
	struct vertex	*cur_loop[MAXV],/* Vertices in current loop. */
			*verts[MAXV];	/* Vertices in all loops. */

	n = 0;			/* No vertices read in yet. */
	fu = NULL;		/* Face to be created elsewhere. */
	for (i = 0; i < MAXV; i++)
		verts[i] = NULL;
	stat = fscanf(fp, "%s", token);	/* Get 1st token. */
	do {
		switch (token[0]) {
		case 'e':		/* Extrude face. */
			stat = fscanf(fp, "%s", token);
			switch (token[0]) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case '.':
			case '+':
			case '-':
				/* Get x value of vector. */
				x = atof(token);
				if (fscanf(fp, "%lf%lf", &y, &z) != 2)
					rt_bomb("descr_to_nmg: messed up vector\n");
				VSET(Ext, x, y, z);

				/* Get token for next trip through loop. */
				stat = fscanf(fp, "%s", token);
				break;
			}
			break;
		case 'l':		/* Start new loop. */
			/* Make a loop with vertices previous to this 'l'. */
			if (n) {
				for (i = 0; i < n; i++)
					if (lu_verts[i] >= 0)
						cur_loop[i] = verts[lu_verts[i]];
					else /* Reuse of a vertex. */
						cur_loop[i] = NULL;
				fu = nmg_add_loop_to_face(s, fu, cur_loop, n,
					dir);
				/* Associate geometry with vertices. */
				for (i = 0; i < n; i++) {
					if (lu_verts[i] >= 0 && !verts[lu_verts[i]]) {
						nmg_vertex_gv( cur_loop[i],
							&pts[3*lu_verts[i]]);
						verts[lu_verts[i]] =
							cur_loop[i];
					}
				}
				/* Take care of reused vertices. */
				for (i = 0; i < n; i++)
					if (lu_verts[i] < 0)
						nmg_jv(verts[-lu_verts[i]], cur_loop[i]);
				n = 0;
			}
			stat = fscanf(fp, "%s", token);

			switch (token[0]) {
			case 'h':	/* Is it cw or ccw? */
				if (!strcmp(token, "hole"))
					dir = OT_OPPOSITE;
				else
					rt_bomb("descr_to_nmg: expected \"hole\"\n");
				/* Get token for next trip through loop. */
				stat = fscanf(fp, "%s", token);
				break;

			default:
				dir = OT_SAME;
				break;
			}
			break;

		case 'v':		/* Vertex in current loop. */
			if (token[1] == '\0')
				rt_bomb("descr_to_nmg: vertices must be numbered.\n");
			vert_num = atoi(token+1);
			stat = fscanf(fp, "%s", token);
			switch (token[0]) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case '.':
			case '+':
			case '-':
				/* Get coordinates of vertex. */
				x = atof(token);
				if (fscanf(fp, "%lf%lf", &y, &z) != 2)
					rt_bomb("descr_to_nmg: messed up vertex\n");
				/* Save vertex with others in current loop. */
				pts[3*vert_num] = x;
				pts[3*vert_num+1] = y;
				pts[3*vert_num+2] = z;
				/* Save vertex number. */
				lu_verts[n] = vert_num;
				if (++n > MAXV)
					rt_bomb("descr_to_nmg: too many points in loop\n");
				/* Get token for next trip through loop. */
				stat = fscanf(fp, "%s", token);
				break;

			default:
				/* Use negative vert number to mark vertex as being reused. */
				lu_verts[n] = -vert_num;
				if (++n > MAXV)
					rt_bomb("descr_to_nmg: too many points in loop\n");
				break;
			}
			break;

		default:
			bu_log("descr_to_nmg: unexpected token \"%s\"\n", token);
			rt_bomb("");
			break;
		}
	} while (stat != EOF);

	/* Make a loop with vertices previous to this 'l'. */
	if (n) {
		for (i = 0; i < n; i++)
			if (lu_verts[i] >= 0)
				cur_loop[i] = verts[lu_verts[i]];
			else /* Reuse of a vertex. */
				cur_loop[i] = NULL;
		fu = nmg_add_loop_to_face(s, fu, cur_loop, n,
			dir);
		/* Associate geometry with vertices. */
		for (i = 0; i < n; i++) {
			if (lu_verts[i] >= 0 && !verts[lu_verts[i]]) {
				nmg_vertex_gv( cur_loop[i],
					&pts[3*lu_verts[i]]);
				verts[lu_verts[i]] =
					cur_loop[i];
			}
		}
		/* Take care of reused vertices. */
		for (i = 0; i < n; i++)
			if (lu_verts[i] < 0)
				nmg_jv(verts[-lu_verts[i]], cur_loop[i]);
		n = 0;
	}
}
@


11.12
log
@merge of ansi-6-0-branch into HEAD
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


11.11
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc-nmg.c,v 11.9 2000/10/31 22:35:11 mike Exp $ (ARL)";
d33 2
a34 2
static int ascii_to_brlcad();
static void descr_to_nmg();
d46 1
a46 3
main(argc, argv)
int	argc;
char	*argv[];
d91 1
a91 4
create_brlcad_db(fpout, m, reg_name, grp_name)
struct rt_wdb	*fpout;
char		*grp_name, *reg_name;
struct model	*m;
d115 1
a115 4
ascii_to_brlcad(fpin, fpout, reg_name, grp_name)
FILE	*fpin;
struct rt_wdb *fpout;
char	*reg_name, *grp_name;
d167 4
a170 4
descr_to_nmg(s, fp, Ext)
struct shell	*s;	/* NMG shell to add loops to. */
FILE		*fp;	/* File pointer for ascii nmg file. */
vect_t		Ext;	/* Extrusion vector. */
@


11.11.2.1
log
@Initial ANSIfication
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc-nmg.c,v 11.11 2002/08/20 17:07:20 jra Exp $ (ARL)";
d33 2
a34 2
static int ascii_to_brlcad(FILE *fpin, struct rt_wdb *fpout, char *reg_name, char *grp_name);
static void descr_to_nmg(struct shell *s, FILE *fp, fastf_t *Ext);
d46 3
a48 1
main(int argc, char **argv)
d93 4
a96 1
create_brlcad_db(struct rt_wdb *fpout, struct model *m, char *reg_name, char *grp_name)
d120 4
a123 1
ascii_to_brlcad(FILE *fpin, struct rt_wdb *fpout, char *reg_name, char *grp_name)
d175 4
a178 4
descr_to_nmg(struct shell *s, FILE *fp, fastf_t *Ext)
            	   	/* NMG shell to add loops to. */
    		    	/* File pointer for ascii nmg file. */
      		    	/* Extrusion vector. */
@


11.10
log
@Converted from K&R to ANSI C - RFH
@
text
@d33 2
a34 2
static int ascii_to_brlcad(FILE *fpin, struct rt_wdb *fpout, char *reg_name, char *grp_name);
static void descr_to_nmg(struct shell *s, FILE *fp, fastf_t *Ext);
d46 3
a48 1
main(int argc, char **argv)
d93 4
a96 1
create_brlcad_db(struct rt_wdb *fpout, struct model *m, char *reg_name, char *grp_name)
d120 4
a123 1
ascii_to_brlcad(FILE *fpin, struct rt_wdb *fpout, char *reg_name, char *grp_name)
d175 4
a178 4
descr_to_nmg(struct shell *s, FILE *fp, fastf_t *Ext)
            	   	/* NMG shell to add loops to. */
    		    	/* File pointer for ascii nmg file. */
      		    	/* Extrusion vector. */
@


11.9
log
@
compiler lint
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc-nmg.c,v 11.8 2000/07/12 21:59:34 mike Exp $ (ARL)";
d33 2
a34 2
static int ascii_to_brlcad();
static void descr_to_nmg();
d46 1
a46 3
main(argc, argv)
int	argc;
char	*argv[];
d91 1
a91 4
create_brlcad_db(fpout, m, reg_name, grp_name)
struct rt_wdb	*fpout;
char		*grp_name, *reg_name;
struct model	*m;
d115 1
a115 4
ascii_to_brlcad(fpin, fpout, reg_name, grp_name)
FILE	*fpin;
struct rt_wdb *fpout;
char	*reg_name, *grp_name;
d167 4
a170 4
descr_to_nmg(s, fp, Ext)
struct shell	*s;	/* NMG shell to add loops to. */
FILE		*fp;	/* File pointer for ascii nmg file. */
vect_t		Ext;	/* Extrusion vector. */
@


11.8
log
@
Converted to use new version of LIBWDB
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc-nmg.c,v 11.7 2000/07/12 03:51:10 mike Exp $ (ARL)";
d184 2
a185 2
	int	dir,		/* Direction of face. */
		i,
@


11.7
log
@
header files
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc-nmg.c,v 11.6 2000/07/10 23:53:55 mike Exp $ (ARL)";
d50 3
a52 2
	char		*afile, *bfile;
	FILE		*fpin, *fpout;
d71 1
a71 2
		bfile = "-";
		fpout = stdout;
d74 5
a78 5
		if ((fpout = fopen(bfile, "w")) == NULL) {
			fprintf(stderr, "%s: cannot open %s for writing\n",
				argv[0], bfile);
			exit(1);
		}
d83 2
a84 1
	fclose(fpout);
d94 1
a94 1
FILE		*fpout;
d121 2
a122 1
FILE	*fpin, *fpout;
@


11.6
log
@
lint
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc-nmg.c,v 11.5 2000/03/29 18:07:43 mike Exp $ (ARL)";
d26 1
d31 1
a31 1
#include "rtlist.h"
d45 1
@


11.5
log
@
Removed stray RT_EXTERNs, added bn_ prefix.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc-nmg.c,v 11.4 1999/06/03 21:54:19 mike Exp $ (ARL)";
@


11.4
log
@
sed4
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc-nmg.c,v 11.3 1997/03/05 20:03:58 jra Exp $ (ARL)";
a30 3

RT_EXTERN( struct faceuse *nmg_add_loop_to_face, (struct shell *s, struct faceuse *fu, struct vertex **verts, int n, int dir ) );
RT_EXTERN( fastf_t nmg_loop_plane_area, (CONST struct loopuse *lu, plane_t pl ) );
@


11.3
log
@removed include of db.h
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc-nmg.c,v 11.2 1996/07/12 13:20:17 jra Exp jra $ (ARL)";
d126 1
a126 1
	struct rt_tol	tol;
d136 1
a136 1
	s = RT_LIST_FIRST(shell, &r->s_hd);
d140 1
a140 1
	tol.magic = RT_TOL_MAGIC;
d147 2
a148 2
	fu = RT_LIST_FIRST( faceuse , &s->fu_hd );
	if (nmg_loop_plane_area(RT_LIST_FIRST(loopuse, &fu->lu_hd), pl) < 0.0)
d154 1
a154 1
		nmg_extrude_face(RT_LIST_FIRST(faceuse, &s->fu_hd), Ext, &tol);
d316 1
a316 1
			rt_log("descr_to_nmg: unexpected token \"%s\"\n", token);
@


11.2
log
@Minor MOds for IRIX 6.2
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc-nmg.c,v 11.1 1995/01/04 09:59:18 mike Rel4_4 jra $ (ARL)";
a26 1
#include "db.h"
@


11.1
log
@Release_4.4
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc-nmg.c,v 1.8 94/12/12 21:56:44 mike Exp $ (ARL)";
d36 3
d120 1
d164 2
d174 1
@


1.8
log
@Linux
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc-nmg.c,v 1.7 94/11/22 14:36:45 jra Exp Locker: mike $ (ARL)";
@


1.7
log
@Replaced call to nmg_fu_planeeqn with nmg_loop_plane_area.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc-nmg.c,v 1.6 94/11/14 11:04:12 jra Exp Locker: jra $ (ARL)";
d266 1
a266 1
			if (token[1] == NULL)
@


1.6
log
@removed private version of face extruder, use nmg_extrude.c.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc-nmg.c,v 1.5 94/11/08 16:14:43 jra Exp $ (ARL)";
d33 2
a34 1
struct faceuse *nmg_add_loop_to_face();
d126 2
d144 2
a145 1
	if (nmg_fu_planeeqn(RT_LIST_FIRST(faceuse, &s->fu_hd), &tol) < 0)
d147 2
@


1.5
log
@Mods for Irix 6.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/conv/RCS/asc-nmg.c,v 1.4 1994/10/11 19:52:15 mike Exp jra $ (ARL)";
d139 1
d144 3
d148 3
a150 2
	if (!NEAR_ZERO(MAGNITUDE(Ext), 0.001))
		extrude_nmg_face(RT_LIST_FIRST(faceuse, &s->fu_hd), Ext, &tol);
d152 1
a334 184


/*
 *	FROM HERE DOWN ARE ROUTINES FOR FACE/SURFACE EXTRUSION
 */

/*
 *	E x t r u d e _ N M G _ F a c e
 *
 *	Duplicate a given NMG face, move it by specified vector,
 *	and create a solid bounded by these faces.
 */
extrude_nmg_face(fu, Vec, tol)
struct faceuse	*fu;	/* Face to extrude. */
vect_t		Vec;	/* Magnitude and direction of extrusion. */
struct rt_tol	*tol;	/* NMG tolerances. */
{
	fastf_t		cosang;
	int		cnt, i, j, nfaces;
	struct edgeuse	*eu;
	struct faceuse	*back, *front, *fu2, *nmg_dup_face(), **outfaceuses;
	struct loopuse	*lu, *lu2;
	struct vertex	*vertlist[4], **verts, **verts2;
	plane_t		N;

#define MIKE_TOL 0.0001

	j = 0;

	/* Duplicate face. */
	fu2 = nmg_dup_face(fu, fu->s_p);

	/* Figure out which face to flip. */
	NMG_GET_FU_NORMAL(N, fu);
	cosang = VDOT(Vec, N);
	front = fu;
	back = fu2;
	if (NEAR_ZERO(cosang, MIKE_TOL)) {
		rt_bomb("extrude_nmg_face: extrusion cannot be parallel to face\n");
	} else if (cosang > 0.) {
		flip_nmg_face(back, tol);
		translate_nmg_face(front, Vec, tol);
	} else if (cosang < 0.) {
		flip_nmg_face(back, tol);
		translate_nmg_face(back, Vec, tol);
	}

	lu = (struct loopuse *)((&front->lu_hd)->forw);
	lu2 = (struct loopuse *)((&back->lu_hd)->forw);
	nfaces = verts_in_nmg_face(front);
	outfaceuses = (struct faceuse **)
		rt_malloc((nfaces+2) * sizeof(struct faceuse *), "faces");

	do {
		cnt = verts_in_nmg_loop(lu);
		if (cnt < 3)
			rt_bomb("extrude_nmg_face: need at least 3 points\n");
		verts = (struct vertex **)
			rt_malloc((cnt+1)*sizeof(struct vertex *), "verts");
		verts2 = (struct vertex **)
			rt_malloc((cnt+1)*sizeof(struct vertex *), "verts");

		/* Collect vertex structures from 1st face. */
		i = 0;
		NMG_CK_LOOPUSE(lu);
		if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC) {
			for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
				verts[i++] = eu->vu_p->v_p;
			}
		} else
			rt_bomb("extrude_nmg_face: bad loopuse (1)\n");

		/* Collect vertex structures from 2nd face. */
		i = 0;
		NMG_CK_LOOPUSE(lu2);
		if (RT_LIST_FIRST_MAGIC(&lu2->down_hd) == NMG_EDGEUSE_MAGIC) {
			for (RT_LIST_FOR(eu, edgeuse, &lu2->down_hd)) {
				verts2[cnt-i-1] = eu->vu_p->v_p;
				i++;
			}
		} else
			rt_bomb("extrude_nmg_face: bad loopuse (2)\n");

		verts[cnt] = verts[0];
		verts2[cnt] = verts2[0];

		for (i = 0; i < cnt; i++) {
			/* Generate connecting faces. */
			vertlist[0] = verts[i];
			vertlist[1] = verts2[i];
			vertlist[2] = verts2[i+1];
			vertlist[3] = verts[i+1];
			outfaceuses[2+i+j] = nmg_cface(fu->s_p, vertlist, 4);
		}
		j += cnt;

		/* Free memory. */
		rt_free((char *)verts, "verts");
		rt_free((char *)verts2, "verts");

		/* On to next loopuse. */
		lu = (struct loopuse *)((struct rt_list *)(lu))->forw;
		lu2 = (struct loopuse *)((struct rt_list *)(lu2))->forw;

	} while (lu != (struct loopuse *)(&fu->lu_hd));

	outfaceuses[0] = fu;
	outfaceuses[1] = fu2;

	/* Associate the face geometry. */
	for (i = 0; i < nfaces+2; i++) {
		if (nmg_fu_planeeqn(outfaceuses[i], tol) < 0)
			return(-1);	/* FAIL */
	}

	/* Glue the edges of different outward pointing face uses together. */
	nmg_gluefaces(outfaceuses, nfaces+2);

	/* Compute geometry for region and shell. */
	nmg_region_a(fu->s_p->r_p, tol);

	/* Free memory. */
	rt_free((char *)outfaceuses, "faces");
}

/*
 *	F l i p _ N M G _ F a c e
 *
 *	Given a pointer to a faceuse, flip the face by reversing the
 *	order of vertex pointers in each loopuse.
 */
flip_nmg_face(fu, tol)
struct faceuse	*fu;
struct rt_tol	*tol;
{
	int		cnt,		/* Number of vertices in face. */
			i;
	struct vertex	**verts;	/* List of verts in face. */
	struct edgeuse	*eu;
	struct loopuse	*lu;
	struct vertex	*v;

	/* Go through each loop and flip it. */
	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
		cnt = verts_in_nmg_loop(lu);	/* # of vertices in loop. */
		verts = (struct vertex **)
			rt_malloc(cnt * sizeof(struct vertex *), "verts");

		/* Collect vertex structure pointers from current loop. */
		i = 0;
		NMG_CK_LOOPUSE(lu);
		if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC) {
			for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
				verts[i++] = eu->vu_p->v_p;
			}
		} else if (RT_LIST_FIRST_MAGIC(&lu->down_hd)
			== NMG_VERTEXUSE_MAGIC) {
			v = RT_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p;
			verts[i++] = v;
		} else
			rt_bomb("extrude_nmg_face: loopuse mess up!\n");

		/* Reverse order of vertex structures in current loop. */
		i = 0;
		if (RT_LIST_FIRST_MAGIC(&lu->down_hd)
			== NMG_EDGEUSE_MAGIC) {
			for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
				eu->vu_p->v_p = verts[cnt-i-1];
				i++;
			}
		} else if (RT_LIST_FIRST_MAGIC(&lu->down_hd)
			== NMG_VERTEXUSE_MAGIC) {
			RT_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p
				= verts[cnt-i-1];
			i++;
		} else
			rt_bomb("extrude_nmg_face: loopuse mess up!\n");

		rt_free((char *)verts, "verts");
	}

	nmg_fu_planeeqn(fu, tol);
}

@


1.4
log
@Eliminated unnecessary (and incorrect) include of librt/debug.h
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d85 27
a119 1
	FILE		*fp;
a150 27
 *	C r e a t e _ B r l c a d _ D b
 *
 *	Write the nmg to a brl-cad style data base.
 */
int
create_brlcad_db(fpout, m, reg_name, grp_name)
FILE		*fpout;
char		*grp_name, *reg_name;
struct model	*m;
{
	char	*rname, *sname;

	mk_id(fpout, "Ascii NMG");

	rname = malloc(sizeof(reg_name) + 3);	/* Region name. */
	sname = malloc(sizeof(reg_name) + 3);	/* Solid name. */

	sprintf(sname, "s.%s", reg_name);
	mk_nmg(fpout, sname,  m);		/* Make nmg object. */
	sprintf(rname, "r.%s", reg_name);
	mk_comb1(fpout, rname, sname, 1);	/* Put object in a region. */
	if (grp_name) {
		mk_comb1(fpout, grp_name, rname, 1);	/* Region in group. */
	}
}

/*
d351 1
a351 2
	struct shell	*s;
	struct vertex	*v, *vertlist[4], **verts, **verts2;
d468 1
a468 1
	struct loopuse	*lu, *lu2;
@


1.3
log
@corrected for fumble-fingers in last edit.
@
text
@d2 1
a2 1
 *			A - G . C
d9 1
d12 5
a16 2
 *      The US Army Research Laboratory
 *      Aberdeen Proving Ground, Maryland  21005-5066
d18 4
a31 1
#include "/m/cad/librt/debug.h"
@


1.2
log
@brought up to date with new NMG support in librt
@
text
@d324 184
@


1.1
log
@Initial revision
@
text
@a323 366
/*
 *	N M G _ A d d _ L o o p _ t o _ F a c e
 *
 *	Create a new loop within a face, given a list of vertices.
 *	Modified version of nmg_cface().
 *
 *	"verts" is an array of "n" pointers to (struct vertex).  "s" is the
 *	parent shell for the new face.  The face will consist of a single loop
 *	made from edges between the n vertices.
 *
 *	If verts is a null pointer (no vertex list), all vertices of the face
 *	will be new points.  Otherwise, verts is a pointer to a list of
 *	vertices to use in creating the face/loop.  Null entries within the
 *	list will cause a new vertex to be created for that point.  Such new
 *	vertices will be inserted into the list for return to the caller.
 *
 *	The vertices should be listed in "counter-clockwise" (CCW) order if
 *	this is an ordinary face (loop), and in "clockwise" (CW) order if
 *	this is an interior ("hole" or "subtracted") face (loop).  This
 *	routine makes only topology, without reference to any geometry.
 *
 *	Note that this routine inserts new vertices (by edge use splitting)
 *	at the head of the loop, which reverses the order.  Therefore, the
 *	caller's vertices are traversed in reverse order to counter this
 *	behavior, and to effect the proper vertex order in the final face
 *	loop.
 */

#if 0
struct faceuse *
nmg_add_loop_to_face(s, fu, verts, n, dir)
struct shell *s;
struct faceuse *fu;
struct vertex *verts[];
int n, dir;
{
	int i, j;
	struct edgeuse *eu;
	struct loopuse *lu;
	struct vertexuse *vu;

	NMG_CK_SHELL(s);
	if (n < 1) {
		rt_log("nmg_add_loop_to_face(s=x%x, verts=x%x, n=%d.)\n",
			s, verts, n );
		rt_bomb("nmg_add_loop_to_face: request to make 0 faces\n");
	}

	if (verts) {
		if (!fu) {
			lu = nmg_mlv(&s->l.magic, verts[n-1], dir);
			fu = nmg_mf(lu);
		} else {
			lu = nmg_mlv(&fu->l.magic, verts[n-1], dir);
		}
		vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
		eu = nmg_meonvu(vu);
		if (!verts[n-1])
			verts[n-1] = eu->vu_p->v_p;

		for (i = n-2 ; i >= 0 ; i--) {
			eu = RT_LIST_FIRST(edgeuse, &lu->down_hd);
			eu = nmg_eusplit(verts[i], eu);
			if (!verts[i])
				verts[i] = eu->vu_p->v_p;
		}
	} else {
		lu = nmg_mlv(&s->l.magic, (struct vertex *)NULL, dir);
		fu = nmg_mf(lu);
		vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
		eu = nmg_meonvu(vu);
		while (--n) {
			(void)nmg_eusplit((struct vertex *)NULL, eu);
		}
	}
	return (fu);
}
#endif

/*
 *	FROM HERE DOWN ARE ROUTINES FOR FACE/SURFACE EXTRUSION
 */

/*
 *	E x t r u d e _ N M G _ F a c e
 *
 *	Duplicate a given NMG face, move it by specified vector,
 *	and create a solid bounded by these faces.
 */
extrude_nmg_face(fu, Vec, tol)
struct faceuse	*fu;	/* Face to extrude. */
vect_t		Vec;	/* Magnitude and direction of extrusion. */
struct rt_tol	*tol;	/* NMG tolerances. */
{
	fastf_t		cosang;
	int		cnt, i, j, nfaces;
	struct edgeuse	*eu;
	struct faceuse	*back, *front, *fu2, *nmg_dup_face(), **outfaceuses;
	struct loopuse	*lu, *lu2;
	struct shell	*s;
	struct vertex	*v, *vertlist[4], **verts, **verts2;
	plane_t		N;

#define MIKE_TOL 0.0001

	j = 0;

	/* Duplicate face. */
	fu2 = nmg_dup_face(fu, fu->s_p);

	/* Figure out which face to flip. */
	NMG_GET_FU_NORMAL(N, fu);
	cosang = VDOT(Vec, N);
	front = fu;
	back = fu2;
	if (NEAR_ZERO(cosang, MIKE_TOL)) {
		rt_bomb("extrude_nmg_face: extrusion cannot be parallel to face\n");
	} else if (cosang > 0.) {
		flip_nmg_face(back, tol);
		translate_nmg_face(front, Vec, tol);
	} else if (cosang < 0.) {
		flip_nmg_face(back, tol);
		translate_nmg_face(back, Vec, tol);
	}

	lu = (struct loopuse *)((&front->lu_hd)->forw);
	lu2 = (struct loopuse *)((&back->lu_hd)->forw);
	nfaces = verts_in_nmg_face(front);
	outfaceuses = (struct faceuse **)
		rt_malloc((nfaces+2) * sizeof(struct faceuse *), "faces");

	do {
		cnt = verts_in_nmg_loop(lu);
		if (cnt < 3)
			rt_bomb("extrude_nmg_face: need at least 3 points\n");
		verts = (struct vertex **)
			rt_malloc((cnt+1)*sizeof(struct vertex *), "verts");
		verts2 = (struct vertex **)
			rt_malloc((cnt+1)*sizeof(struct vertex *), "verts");

		/* Collect vertex structures from 1st face. */
		i = 0;
		NMG_CK_LOOPUSE(lu);
		if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC) {
			for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
				verts[i++] = eu->vu_p->v_p;
			}
		} else
			rt_bomb("extrude_nmg_face: bad loopuse (1)\n");

		/* Collect vertex structures from 2nd face. */
		i = 0;
		NMG_CK_LOOPUSE(lu2);
		if (RT_LIST_FIRST_MAGIC(&lu2->down_hd) == NMG_EDGEUSE_MAGIC) {
			for (RT_LIST_FOR(eu, edgeuse, &lu2->down_hd)) {
				verts2[cnt-i-1] = eu->vu_p->v_p;
				i++;
			}
		} else
			rt_bomb("extrude_nmg_face: bad loopuse (2)\n");

		verts[cnt] = verts[0];
		verts2[cnt] = verts2[0];

		for (i = 0; i < cnt; i++) {
			/* Generate connecting faces. */
			vertlist[0] = verts[i];
			vertlist[1] = verts2[i];
			vertlist[2] = verts2[i+1];
			vertlist[3] = verts[i+1];
			outfaceuses[2+i+j] = nmg_cface(fu->s_p, vertlist, 4);
		}
		j += cnt;

		/* Free memory. */
		rt_free((char *)verts, "verts");
		rt_free((char *)verts2, "verts");

		/* On to next loopuse. */
		lu = (struct loopuse *)((struct rt_list *)(lu))->forw;
		lu2 = (struct loopuse *)((struct rt_list *)(lu2))->forw;

	} while (lu != (struct loopuse *)(&fu->lu_hd));

	outfaceuses[0] = fu;
	outfaceuses[1] = fu2;

	/* Associate the face geometry. */
	for (i = 0; i < nfaces+2; i++) {
		if (nmg_fu_planeeqn(outfaceuses[i], tol) < 0)
			return(-1);	/* FAIL */
	}

	/* Glue the edges of different outward pointing face uses together. */
	nmg_gluefaces(outfaceuses, nfaces+2);

	/* Compute geometry for region and shell. */
	nmg_region_a(fu->s_p->r_p, tol);

	/* Free memory. */
	rt_free((char *)outfaceuses, "faces");
}

/*
 *	F l i p _ N M G _ F a c e
 *
 *	Given a pointer to a faceuse, flip the face by reversing the
 *	order of vertex pointers in each loopuse.
 */
flip_nmg_face(fu, tol)
struct faceuse	*fu;
struct rt_tol	*tol;
{
	int		cnt,		/* Number of vertices in face. */
			i;
	struct vertex	**verts;	/* List of verts in face. */
	struct edgeuse	*eu;
	struct loopuse	*lu, *lu2;
	struct vertex	*v;

	/* Go through each loop and flip it. */
	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
		cnt = verts_in_nmg_loop(lu);	/* # of vertices in loop. */
		verts = (struct vertex **)
			rt_malloc(cnt * sizeof(struct vertex *), "verts");

		/* Collect vertex structure pointers from current loop. */
		i = 0;
		NMG_CK_LOOPUSE(lu);
		if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC) {
			for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
				verts[i++] = eu->vu_p->v_p;
			}
		} else if (RT_LIST_FIRST_MAGIC(&lu->down_hd)
			== NMG_VERTEXUSE_MAGIC) {
			v = RT_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p;
			verts[i++] = v;
		} else
			rt_bomb("extrude_nmg_face: loopuse mess up!\n");

		/* Reverse order of vertex structures in current loop. */
		i = 0;
		if (RT_LIST_FIRST_MAGIC(&lu->down_hd)
			== NMG_EDGEUSE_MAGIC) {
			for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
				eu->vu_p->v_p = verts[cnt-i-1];
				i++;
			}
		} else if (RT_LIST_FIRST_MAGIC(&lu->down_hd)
			== NMG_VERTEXUSE_MAGIC) {
			RT_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p
				= verts[cnt-i-1];
			i++;
		} else
			rt_bomb("extrude_nmg_face: loopuse mess up!\n");

		rt_free((char *)verts, "verts");
	}

	nmg_fu_planeeqn(fu, tol);
}

/*
 *	V e r t s _ i n _ N M G _ L o o p
 *
 *	Count number of vertices in an NMG loop.
 */
int
verts_in_nmg_loop(lu)
struct loopuse	*lu;
{
	int		cnt;
	struct edgeuse	*eu;
	struct vertex	*v;

	/* Count number of vertices in loop. */
	cnt = 0;
	NMG_CK_LOOPUSE(lu);
	if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC) {
		for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
			NMG_CK_EDGEUSE(eu);
			NMG_CK_EDGE(eu->e_p);
			NMG_CK_VERTEXUSE(eu->vu_p);
			NMG_CK_VERTEX(eu->vu_p->v_p);
			cnt++;
		}
	} else if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC) {
		v = RT_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p;
		NMG_CK_VERTEX(v);
		cnt++;
	} else
		rt_bomb("verts_in_nmg_loop: bad loopuse\n");
	return(cnt);
}

/*
 *	V e r t s _ i n _ N M G _ F a c e
 *
 *	Count number of vertices in an NMG face.
 */
int
verts_in_nmg_face(fu)
struct faceuse	*fu;
{
	int		cnt;
	struct loopuse	*lu;

	cnt = 0;
	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd))
		cnt += verts_in_nmg_loop(lu);
	return(cnt);
}

/*
 *	T r a n s l a t e _ N M G _ F a c e
 *
 *	Translate a face using a vector's magnitude and direction.
 */
translate_nmg_face(fu, Vec, tol)
struct faceuse	*fu;
vect_t		Vec;
struct rt_tol	*tol;
{
	int		cnt,		/* Number of vertices in face. */
			cur,
			i,
			in_there;
	struct vertex	**verts;	/* List of verts in face. */
	struct edgeuse	*eu;
	struct loopuse	*lu;
	struct vertex	*v;

	cur = 0;
	cnt = verts_in_nmg_face(fu);
	verts = (struct vertex **)
		rt_malloc(cnt * sizeof(struct vertex *), "verts");
	for (i = 0; i < cnt; i++)
		verts[i] = NULL;

	/* Go through each loop and translate it. */
	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
		NMG_CK_LOOPUSE(lu);
		if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC) {
			for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
				in_there = 0;
				for (i = 0; i < cur && !in_there; i++)
					if (verts[i] == eu->vu_p->v_p)
						in_there = 1;
				if (!in_there) {
					verts[cur++] = eu->vu_p->v_p;
					VADD2(eu->vu_p->v_p->vg_p->coord,
						eu->vu_p->v_p->vg_p->coord,
						Vec);
				}
			}
		} else if (RT_LIST_FIRST_MAGIC(&lu->down_hd)
			== NMG_VERTEXUSE_MAGIC) {
			VADD2(v->vg_p->coord, v->vg_p->coord, Vec);
		} else
			rt_bomb("translate_nmg_face: bad loopuse\n");
	}

	nmg_fu_planeeqn(fu, tol);
	rt_free((char *)verts, "verts");
}

@
