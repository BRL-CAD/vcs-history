head	1.48;
access;
symbols
	ansi-20040405-merged:1.43.2.2
	postmerge-20040405-ansi:1.46
	premerge-20040404-ansi:1.45
	postmerge-autoconf:1.45
	autoconf-freeze:1.43.10.3
	premerge-autoconf:1.45
	ansi-20040316-freeze:1.43.2.1
	postmerge-20040315-windows:1.45
	premerge-20040315-windows:1.45
	windows-20040315-freeze:1.43.4.1
	autoconf-20031203:1.43.10.1
	autoconf-20031202:1.43
	autoconf-branch:1.43.0.10
	phong-branch:1.43.0.8
	photonmap-branch:1.43.0.6
	rel-6-1-DP:1.43
	windows-branch:1.43.0.4
	rel-6-0-2:1.41
	ansi-branch:1.43.0.2
	rel-6-0-1-branch:1.41.0.2
	hartley-6-0-post:1.42
	hartley-6-0-pre:1.41
	rel-6-0-1:1.41
	rel-6-0:1.41
	rel-5-4:1.24.2.4
	offsite-5-3-pre:1.35
	rel-5-3:1.24.2.2
	rel-5-2:1.24.2.1
	rel-5-1-branch:1.24.0.2
	rel-5-1:1.24
	rel-5-0:1.16
	rel-5-0-beta:1.15
	rel-4-5:1.11
	ctj-4-5-post:1.11
	ctj-4-5-pre:1.11;
locks; strict;
comment	@ * @;


1.48
date	2004.05.24.04.16.12;	author morrison;	state dead;
branches;
next	1.47;

1.47
date	2004.05.10.15.30.41;	author erikg;	state Exp;
branches;
next	1.46;

1.46
date	2004.04.05.07.49.36;	author morrison;	state Exp;
branches;
next	1.45;

1.45
date	2004.02.02.17.39.00;	author morrison;	state Exp;
branches;
next	1.44;

1.44
date	2003.12.01.16.26.25;	author morrison;	state Exp;
branches;
next	1.43;

1.43
date	2002.08.20.17.07.21;	author jra;	state Exp;
branches
	1.43.2.1
	1.43.4.1
	1.43.10.1;
next	1.42;

1.42
date	2002.08.15.20.54.34;	author hartley;	state Exp;
branches;
next	1.41;

1.41
date	2001.10.02.19.24.09;	author jra;	state Exp;
branches;
next	1.40;

1.40
date	2001.08.21.17.33.44;	author jra;	state Exp;
branches;
next	1.39;

1.39
date	2001.08.17.15.19.22;	author jra;	state Exp;
branches;
next	1.38;

1.38
date	2001.08.10.21.22.53;	author butler;	state Exp;
branches;
next	1.37;

1.37
date	2001.05.17.20.03.14;	author morrison;	state Exp;
branches;
next	1.36;

1.36
date	2001.04.05.19.34.59;	author morrison;	state Exp;
branches;
next	1.35;

1.35
date	2000.10.20.20.29.24;	author jra;	state Exp;
branches;
next	1.34;

1.34
date	2000.10.12.14.12.21;	author jra;	state Exp;
branches;
next	1.33;

1.33
date	2000.09.08.05.55.42;	author mike;	state Exp;
branches;
next	1.32;

1.32
date	2000.08.17.20.09.58;	author jra;	state Exp;
branches;
next	1.31;

1.31
date	2000.08.17.17.03.23;	author jra;	state Exp;
branches;
next	1.30;

1.30
date	2000.08.17.14.31.23;	author jra;	state Exp;
branches;
next	1.29;

1.29
date	2000.08.17.14.17.10;	author jra;	state Exp;
branches;
next	1.28;

1.28
date	2000.07.20.20.56.46;	author jra;	state Exp;
branches;
next	1.27;

1.27
date	2000.07.20.19.32.20;	author jra;	state Exp;
branches;
next	1.26;

1.26
date	2000.07.12.21.59.35;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	2000.07.10.23.53.58;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	2000.03.29.18.15.17;	author mike;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2000.03.29.18.10.59;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	2000.03.29.18.07.45;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	2000.03.03.03.43.54;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	2000.01.04.17.58.19;	author bparker;	state Exp;
branches;
next	1.19;

1.19
date	99.12.30.18.43.43;	author jra;	state Exp;
branches;
next	1.18;

1.18
date	99.12.29.23.23.01;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	99.09.21.19.44.29;	author jra;	state Exp;
branches;
next	1.16;

1.16
date	99.06.03.21.54.20;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	99.05.13.13.04.07;	author jra;	state Exp;
branches;
next	1.14;

1.14
date	99.05.10.21.46.34;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	99.01.27.13.35.39;	author jra;	state Exp;
branches;
next	1.12;

1.12
date	98.05.13.13.22.11;	author jra;	state Exp;
branches;
next	1.11;

1.11
date	97.07.11.15.03.01;	author jra;	state Exp;
branches;
next	1.10;

1.10
date	97.03.05.19.57.20;	author jra;	state Exp;
branches;
next	1.9;

1.9
date	96.12.20.17.48.06;	author jra;	state Exp;
branches;
next	1.8;

1.8
date	96.12.04.04.02.04;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	96.08.31.08.53.05;	author butler;	state Exp;
branches;
next	1.6;

1.6
date	96.08.29.23.09.18;	author butler;	state Exp;
branches;
next	1.5;

1.5
date	96.08.29.23.05.24;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	96.08.02.12.46.58;	author jra;	state Exp;
branches;
next	1.3;

1.3
date	96.07.12.13.20.17;	author jra;	state Exp;
branches;
next	1.2;

1.2
date	95.08.24.13.34.14;	author jra;	state Exp;
branches;
next	1.1;

1.1
date	95.08.16.20.58.06;	author jra;	state Exp;
branches;
next	;

1.24.2.1
date	2000.08.17.15.24.38;	author jra;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	2000.10.12.15.10.07;	author jra;	state Exp;
branches;
next	1.24.2.3;

1.24.2.3
date	2001.08.16.16.09.20;	author jra;	state Exp;
branches;
next	1.24.2.4;

1.24.2.4
date	2001.08.17.17.00.28;	author jra;	state Exp;
branches;
next	;

1.43.2.1
date	2002.09.19.18.00.36;	author morrison;	state Exp;
branches;
next	1.43.2.2;

1.43.2.2
date	2004.03.17.21.16.00;	author morrison;	state Exp;
branches;
next	;

1.43.4.1
date	2004.03.11.23.40.30;	author morrison;	state Exp;
branches;
next	;

1.43.10.1
date	2003.12.03.16.24.03;	author erikg;	state Exp;
branches;
next	1.43.10.2;

1.43.10.2
date	2004.02.12.19.24.23;	author erikg;	state Exp;
branches;
next	1.43.10.3;

1.43.10.3
date	2004.03.15.14.06.08;	author erikg;	state Exp;
branches;
next	;


desc
@Convert BRL-CAD model to VRML.
@


1.48
log
@moved to src/conv/
@
text
@/*
 *			G - V R M L 2 . C
 *
 *  Program to convert a BRL-CAD model (in a .g file) to a VRML (2.0)  facetted model
 *  by calling on the NMG booleans.
 *
 *  Author -
 *	John R. Anderson
 *  Modified -
 *	July 1999 by John P. Williams, QUADRA Enterprises to output VRML2 format
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1995-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */

#ifndef lint
static const char RCSid[] = "$Header: /n/xoff/cvs/brlcad/conv/g-vrml.c,v 1.47 2004/05/10 15:30:41 erikg Exp $";
#endif

/* #define MEMORY_LEAK_CHECKING 1 */

#ifdef MEMORY_LEAK_CHECKING
#define BARRIER_CHECK { \
	if( bu_mem_barriercheck() ) { \
		bu_log( "memory is corrupted at line %d in file %d\n", __LINE__, __FILE__ ); \
	} \
}
#else
#define BARRIER_CHECK /* */
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "nmg.h"
#include "rtgeom.h"
#include "bu.h"
#include "raytrace.h"
#include "wdb.h"
#include "../librt/debug.h"

#define TXT_BUF_LEN	512
#define TXT_NAME_LEN	128

struct plate_mode {
	int num_bots;
	int num_nonbots;
	int array_size;
	struct rt_bot_internal **bots;
};

struct vrml_mat {
	/* typical shader parameters */
	char shader[TXT_NAME_LEN];
	int shininess;
	double transparency;

	/* light paramaters */
	fastf_t lt_fraction;
	vect_t  lt_dir;
	fastf_t lt_angle;

	/* texture parameters */
	char	tx_file[TXT_NAME_LEN];
	int	tx_w;
	int	tx_n;
};

#define PL_O(_m)	offsetof(struct vrml_mat, _m)
#define PL_OA(_m)	bu_offsetofarray(struct vrml_mat, _m)

struct bu_structparse vrml_mat_parse[]={
	{"%s", TXT_NAME_LEN, "ma_shader", PL_OA(shader), 	FUNC_NULL },
	{"%d", 1, "shine",		PL_O(shininess),	FUNC_NULL },
	{"%d", 1, "sh",			PL_O(shininess),	FUNC_NULL },
	{"%f", 1, "transmit",		PL_O(transparency),	FUNC_NULL },
	{"%f", 1, "tr",			PL_O(transparency),	FUNC_NULL },
	{"%f",	1, "angle",		PL_O(lt_angle),		FUNC_NULL },
	{"%f",	1, "fract",		PL_O(lt_fraction),	FUNC_NULL },
	{"%f",	3, "aim",		PL_OA(lt_dir),		FUNC_NULL },
	{"%d",  1, "w",         	PL_O(tx_w),             BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "n",         	PL_O(tx_n),             BU_STRUCTPARSE_FUNC_NULL },
	{"%s",  TXT_NAME_LEN, "file",	PL_OA(tx_file), 	FUNC_NULL },
	{"",	0, (char *)0,		0,			FUNC_NULL }
};

BU_EXTERN(union tree *do_region_end, (struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data));
BU_EXTERN(union tree *nmg_region_end, (struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data));

static char	usage[] = "Usage: %s [-v] [-xX lvl] [-d tolerance_distance (mm) ] [-a abs_tol (mm)] [-r rel_tol] [-n norm_tol] [-o out_file] [-u units] brlcad_db.g object(s)\n";

static char	*tok_sep = " \t";
static int	NMG_debug;		/* saved arg of -X, for longjmp handling */
static int	verbose=0;
/* static int	ncpu = 1; */		/* Number of processors */
static char	*out_file = NULL;	/* Output filename */
static FILE	*fp_out;		/* Output file pointer */
static struct db_i		*dbip;
static struct rt_tess_tol	ttol;
static struct bn_tol		tol;
static struct model		*the_model;

static	char*	units=NULL;
static fastf_t	scale_factor=1.0;

static struct db_tree_state	tree_state;	/* includes tol & model */

static int	regions_tried = 0;
static int	regions_converted = 0;

static void
clean_pmp( struct plate_mode *pmp )
{
	int i;

	BARRIER_CHECK;

	pmp->num_bots = 0;
	pmp->num_nonbots = 0;
	for( i=0 ; i<pmp->array_size ; i++ ) {
		if( pmp->bots[i] ) {
			struct rt_db_internal intern;

			intern.idb_ptr = (genptr_t) pmp->bots[i];
			intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
			intern.idb_type = ID_BOT;
			intern.idb_meth = &rt_functab[ID_BOT];
			intern.idb_magic = RT_DB_INTERNAL_MAGIC;
			intern.idb_meth->ft_ifree( &intern, &rt_uniresource );
			pmp->bots[i] = NULL;
		}
	}
	BARRIER_CHECK;
}

struct rt_bot_internal *
dup_bot( struct rt_bot_internal *bot_in )
{
	struct rt_bot_internal *bot;
	int i;

	RT_BOT_CK_MAGIC( bot_in );

	bot = (struct rt_bot_internal *)bu_malloc( sizeof( struct rt_bot_internal ), "dup bot" );

	*bot = *bot_in;	/* struct copy */

	bot->faces = (int *)bu_calloc( bot_in->num_faces*3, sizeof( int ), "bot faces" );
	for( i=0 ; i<bot_in->num_faces*3 ; i++ )
		bot->faces[i] = bot_in->faces[i];

	bot->vertices = (fastf_t *)bu_calloc( bot_in->num_vertices*3, sizeof( fastf_t ), "bot verts" );
	for( i=0 ; i<bot_in->num_vertices*3 ; i++ )
		bot->vertices[i] = bot_in->vertices[i];

	if( bot_in->thickness ) {
		bot->thickness = (fastf_t *)bu_calloc( bot_in->num_faces, sizeof( fastf_t ), "bot thickness" );
		for( i=0 ; i<bot_in->num_faces ; i++ )
			bot->thickness[i] = bot_in->thickness[i];
	}

	if( bot_in->face_mode ) {
		bot->face_mode = bu_bitv_dup( bot_in->face_mode );
	}

	return( bot );
}

static int
select_lights(register struct db_tree_state *tsp, struct db_full_path *pathp, const struct rt_comb_internal *combp, genptr_t client_data)
{
	struct directory *dp;
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;
	int id;

	RT_CK_FULL_PATH( pathp );
	dp = DB_FULL_PATH_CUR_DIR( pathp );

	if( !(dp->d_flags & DIR_COMB) )
		return( -1 );

	id = rt_db_get_internal( &intern, dp, dbip, (matp_t)NULL, &rt_uniresource );
	if( id < 0 )
	{
		bu_log( "Cannot internal form of %s\n", dp->d_namep );
		return( -1 );
	}

	if( id != ID_COMBINATION )
	{
		bu_log( "Directory/database mismatch!!\n\t is '%s' a combination or not???\n",
			dp->d_namep );
		return( -1 );
	}

	comb = (struct rt_comb_internal *)intern.idb_ptr;
	RT_CK_COMB( comb );

	if( !strcmp( bu_vls_addr( &comb->shader ), "light" ) )
	{
		rt_db_free_internal( &intern, &rt_uniresource );
		return( 0 );
	}
	else
	{
		rt_db_free_internal( &intern, &rt_uniresource );
		return( -1 );
	}
}

static int
select_non_lights(register struct db_tree_state *tsp, struct db_full_path *pathp, const struct rt_comb_internal *combp, genptr_t client_data)
{
	int ret;

	ret =  select_lights( tsp, pathp, combp, client_data );
	if( ret == 0 )
		return( -1 );
	else
		return( 0 );
}

union tree *
leaf_tess(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
{
	struct rt_bot_internal *bot;
	struct plate_mode *pmp = (struct plate_mode *)client_data;

	BARRIER_CHECK;

	if( ip->idb_type != ID_BOT ) {
		pmp->num_nonbots++;
		return( nmg_booltree_leaf_tess(tsp, pathp, ip, client_data) );
	}

	bot = (struct rt_bot_internal *)ip->idb_ptr;
	RT_BOT_CK_MAGIC( bot );

	if( bot->mode == RT_BOT_PLATE || bot->mode == RT_BOT_SURFACE )
	{
		if( pmp->array_size <= pmp->num_bots ) {
			pmp->array_size += 5;
			pmp->bots = (struct rt_bot_internal **)bu_realloc(
				    (char *)pmp->bots,
				    pmp->array_size * sizeof( struct rt_bot_internal *),
				    "pmp->bots" );
		}

		/* walk tree will free the BOT, so we need a copy */
		pmp->bots[pmp->num_bots] = dup_bot( bot );
		BARRIER_CHECK;
		pmp->num_bots++;
		return( (union tree *)NULL );
	}

	pmp->num_nonbots++;

	BARRIER_CHECK;

	return( nmg_booltree_leaf_tess(tsp, pathp, ip, client_data) );
}

/*
 *			M A I N
 */
int
main(int argc, char **argv)
{
	int		i;
	register int	c;
	struct plate_mode pm;

	port_setlinebuf( stderr );

#if MEMORY_LEAK_CHECKING
	bu_debug |= BU_DEBUG_MEM_CHECK;
#endif
	the_model = nmg_mm();
	tree_state = rt_initial_tree_state;	/* struct copy */
	tree_state.ts_tol = &tol;
	tree_state.ts_ttol = &ttol;
	tree_state.ts_m = &the_model;

	ttol.magic = RT_TESS_TOL_MAGIC;
	/* Defaults, updated by command line options. */
	ttol.abs = 0.0;
	ttol.rel = 0.01;
	ttol.norm = 0.0;

	/* XXX These need to be improved */
	tol.magic = BN_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;

	/* XXX For visualization purposes, in the debug plot files */
	{
		extern fastf_t	nmg_eue_dist;	/* librt/nmg_plot.c */
		/* XXX This value is specific to the Bradley */
		nmg_eue_dist = 2.0;
	}

	rt_init_resource( &rt_uniresource, 0, NULL );

	BU_LIST_INIT( &rt_g.rtg_vlfree );	/* for vlist macros */

	BARRIER_CHECK;
	/* Get command line arguments. */
	while ((c = getopt(argc, argv, "d:a:n:o:r:vx:P:X:u:")) != EOF) {
		switch (c) {
		case 'a':		/* Absolute tolerance. */
			ttol.abs = atof(optarg);
			ttol.rel = 0.0;
			break;
		case 'd':		/* calculational tolerance */
			tol.dist = atof( optarg );
			tol.dist_sq = tol.dist * tol.dist;
			break;
		case 'n':		/* Surface normal tolerance. */
			ttol.norm = atof(optarg)*bn_pi/180.0;
			ttol.rel = 0.0;
			break;
		case 'o':		/* Output file name */
			out_file = optarg;
			break;
		case 'r':		/* Relative tolerance. */
			ttol.rel = atof(optarg);
			break;
		case 'v':
			verbose++;
			break;
		case 'P':
/*			ncpu = atoi( optarg ); */
			rt_g.debug = 1;	/* XXX DEBUG_ALLRAYS -- to get core dumps */
			break;
		case 'x':
			sscanf( optarg, "%x", (unsigned int *)&rt_g.debug );
			break;
		case 'X':
			sscanf( optarg, "%x", (unsigned int *)&rt_g.NMG_debug );
			NMG_debug = rt_g.NMG_debug;
			break;
		case 'u':
			units = bu_strdup( optarg );
			scale_factor = bu_units_conversion( units );
			if( scale_factor == 0.0 )
			{
				bu_log( "Unrecognized units (%s)\n", units );
				bu_bomb( "Unrecognized units\n" );
			}
			scale_factor = 1.0 / scale_factor;
			break;
		default:
			fprintf(stderr, usage, argv[0]);
			exit(1);
			break;
		}
	}

	if (optind+1 >= argc) {
		fprintf(stderr, usage, argv[0]);
		exit(1);
	}

	if( !units )
		units = "mm";

	/* Open brl-cad database */
	if ((dbip = db_open( argv[optind] , "r")) == DBI_NULL)
	{
		bu_log( "Cannot open %s\n" , argv[optind] );
		perror(argv[0]);
		exit(1);
	}
	if( db_dirbuild( dbip ) ) {
		bu_bomb( "db_dirbuild() failed!\n" );
	}

	if( out_file == NULL )
		fp_out = stdout;
	else
	{
		if ((fp_out = fopen( out_file , "w")) == NULL)
		{
			bu_log( "Cannot open %s\n" , out_file );
			perror( argv[0] );
			return 2;
		}
	}

	fprintf( fp_out, "#VRML V2.0 utf8\n" );
	fprintf( fp_out, "#Units are %s\n", units);
	/* Note we may want to inquire about bounding boxes for the various groups and add Viewpoints nodes that
	 * point the camera to the center and orient for Top, Side, etc Views
	 *
	 * We will add some default Material Color definitions (for thousands groups) before we start defining the geometry 
	 */
	fprintf( fp_out, "Shape { appearance Appearance { material DEF Material_999 Material { diffuseColor 0.78 0.78 0.78 } } }\n");
	fprintf( fp_out, "Shape { appearance Appearance { material DEF Material_1999 Material { diffuseColor 0.88 0.29 0.29 } } }\n");
	fprintf( fp_out, "Shape { appearance Appearance { material DEF Material_2999 Material { diffuseColor 0.82 0.53 0.54 } } }\n");
	fprintf( fp_out, "Shape { appearance Appearance { material DEF Material_3999 Material { diffuseColor 0.39 0.89 0.00 } } }\n");
	fprintf( fp_out, "Shape { appearance Appearance { material DEF Material_4999 Material { diffuseColor 1.00 0.00 0.00 } } }\n");
	fprintf( fp_out, "Shape { appearance Appearance { material DEF Material_5999 Material { diffuseColor 0.82 0.00 0.82 } } }\n");
	fprintf( fp_out, "Shape { appearance Appearance { material DEF Material_6999 Material { diffuseColor 0.62 0.62 0.62 } } }\n");
	fprintf( fp_out, "Shape { appearance Appearance { material DEF Material_7999 Material { diffuseColor 0.49 0.49 0.49 } } }\n");
	fprintf( fp_out, "Shape { appearance Appearance { material DEF Material_8999 Material { diffuseColor 0.18 0.31 0.31 } } }\n");
	fprintf( fp_out, "Shape { appearance Appearance { material DEF Material_9999 Material { diffuseColor 0.00 0.41 0.82 } } }\n");

	/* I had hoped to create a separate sub-tree (using the Transform node) for each group name argument
	 * however, it appears they are all handled at the same time so I will only have one Transform for the
	 * complete conversion
	 * Later on switch nodes may be added to turn on and off the groups (via ROUTE nodes) */
	fprintf ( fp_out, "Transform {\n");
	fprintf ( fp_out, "\tchildren [\n");

	optind++;

	BARRIER_CHECK;

	pm.num_bots = 0;
	pm.num_nonbots = 0;
	pm.array_size = 5;
	pm.bots = (struct rt_bot_internal **)bu_calloc( pm.array_size,
		sizeof( struct rt_bot_internal *), "pm.bots" );
	for( i=optind ; i<argc ; i++ )
	{
		struct directory *dp;

		dp = db_lookup( dbip, argv[i], LOOKUP_QUIET );
		if( dp == DIR_NULL )
		{
			bu_log( "Cannot find %s\n", argv[i] );
			continue;
		}

		fprintf ( fp_out, "#Includes group %s\n", argv[i]);

		/* light source must be a combibation */
		if( !(dp->d_flags & DIR_COMB) )
			continue;

		/* walk trees selecting only light source regions */
		(void)db_walk_tree(dbip, 1, (const char **)(&argv[i]),
			1,				/* ncpu */
			&tree_state,
			select_lights,
			do_region_end,
			leaf_tess,
			(genptr_t)&pm);	/* in librt/nmg_bool.c */


	}
	BARRIER_CHECK;

	/* Walk indicated tree(s).  Each non-light-source region will be output separately */
	(void)db_walk_tree(dbip, argc-optind, (const char **)(&argv[optind]),
		1,				/* ncpu */
		&tree_state,
		select_non_lights,
		do_region_end,
		leaf_tess,
		(genptr_t)&pm);	/* in librt/nmg_bool.c */

	BARRIER_CHECK;
	/* Release dynamic storage */
	nmg_km(the_model);

	db_close(dbip);

		/* Now we need to close each group set */
		fprintf ( fp_out, "\t]\n}\n");

	if( verbose )
		bu_log( "Total of %d regions converted of %d regions attempted\n",
			regions_converted, regions_tried );

	return 0;
}

void
nmg_2_vrml(FILE *fp, struct db_full_path *pathp, struct model *m, struct mater_info *mater)
{
	struct nmgregion *reg;
	struct bu_ptbl verts;
	struct vrml_mat mat;
	struct bu_vls vls;
	char *tok;
	int i;
	int first=1;
	int is_light=0;
	float r,g,b;
	point_t ave_pt;
	char *full_path;
	/*There may be a better way to capture the region_id, than getting the rt_comb_internal structure, 
	 * (and may be a better way to capture the rt_comb_internal struct), but for now I just copied the
	 * method used in select_lights/select_non_lights above, could have used a global variable but I noticed
	 * none other were used, so I didn't want to be the first
	 */
	struct directory *dp;
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;
	int id;

	NMG_CK_MODEL( m );

	BARRIER_CHECK;

	full_path = db_path_to_string( pathp );

	RT_CK_FULL_PATH( pathp );
	dp = DB_FULL_PATH_CUR_DIR( pathp );

	if( !(dp->d_flags & DIR_COMB) )
		return;

	id = rt_db_get_internal( &intern, dp, dbip, (matp_t)NULL, &rt_uniresource );
	if( id < 0 )
	{
		bu_log( "Cannot internal form of %s\n", dp->d_namep );
		return;
	}

	if( id != ID_COMBINATION )
	{
		bu_log( "Directory/database mismatch!!\n\t is '%s' a combination or not???\n",
			dp->d_namep );
		return;
	}

	comb = (struct rt_comb_internal *)intern.idb_ptr;
	RT_CK_COMB( comb );

	if( mater->ma_color_valid )
	{
		r = mater->ma_color[0];
		g = mater->ma_color[1];
		b = mater->ma_color[2];
	}
	else
	{
		r = g = b = 0.5;
	}

	if( mater->ma_shader )
	{
		tok = strtok( mater->ma_shader, tok_sep );
		strcpy( mat.shader, tok );
	}
	else
		mat.shader[0] = '\0';
	mat.shininess = -1;
	mat.transparency = -1.0;
	mat.lt_fraction = -1.0;
	VSETALL( mat.lt_dir, 0.0 );
	mat.lt_angle = -1.0;
	mat.tx_file[0] = '\0';
	mat.tx_w = -1;
	mat.tx_n = -1;
	bu_vls_init( &vls );
	bu_vls_strcpy( &vls, &mater->ma_shader[strlen(mat.shader)] );
	(void)bu_struct_parse( &vls, vrml_mat_parse, (char *)&mat );

	if( strncmp( "light", mat.shader, 5 ) == 0 )
	{
		/* this is a light source */
		is_light = 1;
	}
	else
	{
		fprintf( fp, "\t\tShape { \n");
		fprintf( fp, "\t\t\t# Component_ID: %d   %s\n",comb->region_id,full_path);
		fprintf( fp, "\t\t\tappearance Appearance { \n");


		if( strncmp( "plastic", mat.shader, 7 ) == 0 )
		{
			if( mat.shininess < 0 )
				mat.shininess = 10;
			if( mat.transparency < 0.0 )
				mat.transparency = 0.0;

			fprintf( fp, "\t\t\t\tmaterial Material {\n" );
			fprintf( fp, "\t\t\t\t\tdiffuseColor %g %g %g \n", r, g, b );
			fprintf( fp, "\t\t\t\t\tshininess %g\n", 1.0-exp(-(double)mat.shininess/20.0 ) );
			if( mat.transparency > 0.0 )
				fprintf( fp, "\t\t\t\t\ttransparency %g\n", mat.transparency );
			fprintf( fp, "\t\t\t\t\tspecularColor %g %g %g \n\t\t\t\t}\n", 1.0, 1.0, 1.0 );
		}
		else if( strncmp( "glass", mat.shader, 5 ) == 0 )
		{
			if( mat.shininess < 0 )
				mat.shininess = 4;
			if( mat.transparency < 0.0 )
				mat.transparency = 0.8;

			fprintf( fp, "\t\t\t\tmaterial Material {\n" );
			fprintf( fp, "\t\t\t\t\tdiffuseColor %g %g %g \n", r, g, b );
			fprintf( fp, "\t\t\t\t\tshininess %g\n", 1.0-exp(-(double)mat.shininess/20.0 ) );
			if( mat.transparency > 0.0 )
				fprintf( fp, "\t\t\t\t\ttransparency %g\n", mat.transparency );
			fprintf( fp, "\t\t\t\t\tspecularColor %g %g %g \n\t\t\t\t}\n", 1.0, 1.0, 1.0 );
		}
		else if( strncmp( "texture", mat.shader, 7 ) == 0 )
		{
			if( mat.tx_w < 0 )
				mat.tx_w = 512;
			if( mat.tx_n < 0 )
				mat.tx_n = 512;

			if( strlen( mat.tx_file ) )
			{
				int tex_fd;
				int nbytes;
				long tex_len;
				long bytes_read=0;
				unsigned char tex_buf[TXT_BUF_LEN*3];

				if( (tex_fd = open( mat.tx_file, O_RDONLY )) == (-1) )
				{
					bu_log( "Cannot open texture file (%s)\n", mat.tx_file );
					perror( "g-vrml: " );
				}
				else
				{
					/* Johns note - need to check (test) the texture stuff */
					fprintf( fp, "\t\t\t\ttextureTransform TextureTransform {\n");
					fprintf( fp, "\t\t\t\t\tscale 1.33333 1.33333\n\t\t\t\t}\n");
					fprintf( fp, "\t\t\t\ttexture PixelTexture {\n");
					fprintf( fp, "\t\t\t\t\trepeatS TRUE\n");
					fprintf( fp, "\t\t\t\t\trepeatT TRUE\n");
					fprintf( fp, "\t\t\t\t\timage %d %d %d\n", mat.tx_w, mat.tx_n, 3 );
					tex_len = mat.tx_w*mat.tx_n*3;
					while( bytes_read < tex_len )
					{
						long bytes_to_go=tex_len;

						bytes_to_go = tex_len - bytes_read;
						if( bytes_to_go > TXT_BUF_LEN*3 )
							bytes_to_go = TXT_BUF_LEN*3;
						nbytes = 0;
						while( nbytes < bytes_to_go )
							nbytes += read( tex_fd, &tex_buf[nbytes],
								bytes_to_go-nbytes );

						bytes_read += nbytes;
						for( i=0 ; i<nbytes ; i += 3 )
							fprintf( fp, "\t\t\t0x%02x%02x%02x\n",
								tex_buf[i],
								tex_buf[i+1],
								tex_buf[i+2] );
					}
					fprintf( fp, "\t\t\t\t}\n" );
				}
			}
		}
		else if( mater->ma_color_valid )
		{
			/* no shader specified, but a color is assigned */
			fprintf( fp, "\t\t\t\tmaterial Material {\n" );
			fprintf( fp, "\t\t\t\t\tdiffuseColor %g %g %g }\n", r, g, b );
		}
		else
		{
			/* If no color was defined set the colors according to the thousands groups */
			int thou = comb->region_id/1000;
			thou == 0 ? fprintf( fp, "\t\t\tmaterial USE Material_999\n")
			: thou == 1 ? fprintf( fp, "\t\t\tmaterial USE Material_1999\n")
			: thou == 2 ? fprintf( fp, "\t\t\tmaterial USE Material_2999\n")
			: thou == 3 ? fprintf( fp, "\t\t\tmaterial USE Material_3999\n")
			: thou == 4 ? fprintf( fp, "\t\t\tmaterial USE Material_4999\n")
			: thou == 5 ? fprintf( fp, "\t\t\tmaterial USE Material_5999\n")
			: thou == 6 ? fprintf( fp, "\t\t\tmaterial USE Material_6999\n")
			: thou == 7 ? fprintf( fp, "\t\t\tmaterial USE Material_7999\n")
			: thou == 8 ? fprintf( fp, "\t\t\tmaterial USE Material_8999\n")
			: fprintf( fp, "\t\t\tmaterial USE Material_9999\n");

/*			fprintf( fp, "\t\t\t\tmaterial Material {\n" );
 *			fprintf( fp, "\t\t\t\t\tdiffuseColor %g %g %g \n", r, g, b );
 *			fprintf( fp, "\t\t\t\t\tspecularColor %g %g %g \n\t\t\t\t}\n", 1.0, 1.0, 1.0 );
*/
		}
	}

	if( !is_light )
	{
		/* triangulate any faceuses with holes */
		for( BU_LIST_FOR( reg, nmgregion, &m->r_hd ) )
		{
			struct shell *s;

			NMG_CK_REGION( reg );
			s = BU_LIST_FIRST( shell, &reg->s_hd );
			while( BU_LIST_NOT_HEAD( s, &reg->s_hd ) )
			{
				struct shell *next_s;
				struct faceuse *fu;

				NMG_CK_SHELL( s );
				next_s = BU_LIST_PNEXT( shell, &s->l );
				fu = BU_LIST_FIRST( faceuse, &s->fu_hd );
				while( BU_LIST_NOT_HEAD( &fu->l, &s->fu_hd ) )
				{
					struct faceuse *next_fu;
					struct loopuse *lu;
					int shell_is_dead=0;
					int face_is_dead=0;

					NMG_CK_FACEUSE( fu );

					next_fu = BU_LIST_PNEXT( faceuse, &fu->l );

					if( fu->orientation != OT_SAME )
					{
						fu = next_fu;
						continue;
					}

					/* check if this faceuse has any holes */
					for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
					{
						NMG_CK_LOOPUSE( lu );
						if( lu->orientation == OT_OPPOSITE )
						{
							/* this is a hole, so
							 * triangulate the faceuse
							 */
							if( BU_SETJUMP )
							{
								BU_UNSETJUMP;
								bu_log( "A face has failed triangulation!!!!\n" );
								if( next_fu == fu->fumate_p )
									next_fu = BU_LIST_PNEXT( faceuse, &next_fu->l );
								if( nmg_kfu( fu ) )
								{
									(void) nmg_ks( s );
									shell_is_dead = 1;
								}
								face_is_dead = 1;
							}
							if( !face_is_dead )
								nmg_triangulate_fu( fu, &tol );
							BU_UNSETJUMP;
							break;
						}

					}
					if( shell_is_dead )
						break;
					fu = next_fu;
				}
				s = next_s;
			}
		}
		fprintf( fp, "\t\t\t} \n");
		fprintf( fp, "\t\t\tgeometry IndexedFaceSet { \n");
		fprintf( fp, "\t\t\t\tcoord Coordinate { \n");

	}

	/* get list of vertices */
	nmg_vertex_tabulate( &verts, &m->magic );
	if( !is_light )
		fprintf( fp, "\t\t\t\t\tpoint [");
	else
	{
		VSETALL( ave_pt, 0.0 );
	}

	for( i=0 ; i<BU_PTBL_END( &verts ) ; i++ )
	{
		struct vertex *v;
		struct vertex_g *vg;
		point_t pt_meters;

		v = (struct vertex *)BU_PTBL_GET( &verts, i );
		NMG_CK_VERTEX( v );
		vg = v->vg_p;
		NMG_CK_VERTEX_G( vg );

		/* convert to desired units */
		VSCALE( pt_meters, vg->coord, scale_factor );

		if( is_light )
			VADD2( ave_pt, ave_pt, pt_meters )
		if( first )
		{
			if( !is_light )
				fprintf( fp, " %10.10e %10.10e %10.10e, # point %d\n", V3ARGS( pt_meters ), i );
			first = 0;
		}
		else
			if( !is_light )
				fprintf( fp, "\t\t\t\t\t%10.10e %10.10e %10.10e, # point %d\n", V3ARGS( pt_meters ), i );
	}
	if( !is_light )
		fprintf( fp, "\t\t\t\t\t]\n\t\t\t\t}\n" );
	else
	{
		fastf_t one_over_count;

		one_over_count = 1.0/(fastf_t)BU_PTBL_END( &verts );
		VSCALE( ave_pt, ave_pt, one_over_count );
	}

	first = 1;
	if( !is_light )
	{
		fprintf( fp, "\t\t\t\tcoordIndex [\n");
		for( BU_LIST_FOR( reg, nmgregion, &m->r_hd ) )
		{
			struct shell *s;

			NMG_CK_REGION( reg );
			for( BU_LIST_FOR( s, shell, &reg->s_hd ) )
			{
				struct faceuse *fu;

				NMG_CK_SHELL( s );
				for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
				{
					struct loopuse *lu;

					NMG_CK_FACEUSE( fu );

					if( fu->orientation != OT_SAME )
						continue;

					for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
					{
						struct edgeuse *eu;

						NMG_CK_LOOPUSE( lu );

						if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
							continue;

						if( !first )
							fprintf( fp, ",\n" );
						else
							first = 0;

						fprintf( fp, "\t\t\t\t\t" );
						for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
						{
							struct vertex *v;

							NMG_CK_EDGEUSE( eu );

							v = eu->vu_p->v_p;
							NMG_CK_VERTEX( v );
							fprintf( fp, " %d,", bu_ptbl_locate( &verts, (long *)v ) );
						}
						fprintf( fp, "-1" );
					}
				}
			}
		}
		fprintf( fp, "\n\t\t\t\t]\n\t\t\t\tnormalPerVertex FALSE\n");
		fprintf( fp, "\t\t\t\tconvex FALSE\n");
		fprintf( fp, "\t\t\t\tcreaseAngle 0.5\n");
		fprintf( fp, "\t\t\t}\n\t\t}\n");
	}
	else
	{
		mat.lt_fraction = 0.0;
		mat.lt_angle = 180.0;
		VSETALL( mat.lt_dir, 0.0 );

		if( mat.lt_dir[X] != 0.0 || mat.lt_dir[Y] != 0.0 ||mat.lt_dir[Z] != 0.0 )
		{
			fprintf( fp, "\t\tSpotLight {\n" );
			fprintf( fp, "\t\t\ton \tTRUE\n" );
			if( mat.lt_fraction > 0.0 )
				fprintf( fp, "\t\t\tintensity \t%g\n", mat.lt_fraction );
			fprintf( fp, "\t\t\tcolor \t%g %g %g\n", r,g,b );
			fprintf( fp, "\t\t\tlocation \t%g %g %g\n", V3ARGS( ave_pt ) );
			fprintf( fp, "\t\t\tdirection \t%g %g %g\n", V3ARGS( mat.lt_dir ) );
			fprintf( fp, "\t\t\tcutOffAngle \t%g }\n", mat.lt_angle );
		}
		else
			fprintf( fp, "\t\tPointLight {\n\t\t\ton TRUE\n\t\t\tintensity 1\n\t\t\tcolor %g %g %g\n\t\t\tlocation %g %g %g\n\t\t}\n",r,g,b,V3ARGS( ave_pt ) );
	}
	BARRIER_CHECK;
}

void
bot2vrml( struct plate_mode *pmp, struct db_full_path *pathp, int region_id )
{
	char *path_str;
	int appearance;
	struct rt_bot_internal *bot;
	int bot_num;
	int i;
	int vert_count=0;

	BARRIER_CHECK;

	path_str = db_path_to_string( pathp );

	fprintf( fp_out, "\t\tShape {\n\t\t\t# Component_ID: %d   %s\n",
		 region_id, path_str );
	bu_free( path_str, "result of db_path_to_string" );

	appearance = region_id / 1000;
	appearance = appearance * 1000 + 999;
	fprintf( fp_out, "\t\t\tappearance Appearance {\n\t\t\tmaterial USE Material_%d\n\t\t\t}\n", appearance );
	fprintf( fp_out, "\t\t\tgeometry IndexedFaceSet {\n\t\t\t\tcoord Coordinate {\n\t\t\t\tpoint [\n" );

	for( bot_num = 0 ; bot_num < pmp->num_bots ; bot_num++ ) {
		bot = pmp->bots[bot_num];
		RT_BOT_CK_MAGIC( bot );
		for( i=0 ; i<bot->num_vertices ; i++ )
			{
				point_t pt;

				VSCALE( pt, &bot->vertices[i*3], scale_factor );
				fprintf( fp_out, "\t\t\t\t\t%10.10e %10.10e %10.10e, # point %d\n", V3ARGS( pt ), vert_count );
				vert_count++;
			}
	}
	fprintf( fp_out, "\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\tcoordIndex [\n" );
	vert_count = 0;
	for( bot_num = 0 ; bot_num < pmp->num_bots ; bot_num++ ) {
		bot = pmp->bots[bot_num];
		RT_BOT_CK_MAGIC( bot );
		for( i=0 ; i<bot->num_faces ; i++ )
			fprintf( fp_out, "\t\t\t\t\t%d, %d, %d, -1,\n",
				 vert_count+bot->faces[i*3],
				 vert_count+bot->faces[i*3+1],
				 vert_count+bot->faces[i*3+2]);
		vert_count += bot->num_vertices;
	}
	fprintf( fp_out, "\t\t\t\t]\n\t\t\t\tnormalPerVertex FALSE\n" );
	fprintf( fp_out, "\t\t\t\tconvex TRUE\n" );
	fprintf( fp_out, "\t\t\t\tcreaseAngle 0.5\n" );
	fprintf( fp_out, "\t\t\t\tsolid FALSE\n" );
	fprintf( fp_out, "\t\t\t}\n\t\t}\n" );
	BARRIER_CHECK;
}

/*
*			D O _ R E G I O N _ E N D
*
*  Called from db_walk_tree().
*
*  This routine must be prepared to run in parallel.
*/
union tree *do_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
{
	struct plate_mode *pmp = (struct plate_mode *)client_data;
	char *name;

	BARRIER_CHECK;
	if( tsp->ts_is_fastgen != REGION_FASTGEN_PLATE ) {
		clean_pmp( pmp );
		return( nmg_region_end(tsp, pathp, curtree, client_data) );
	}

	/* FASTGEN plate mode region, just spew the bot triangles */
	if( pmp->num_bots < 1 || pmp->num_nonbots > 0 ) {
		clean_pmp( pmp );
		BARRIER_CHECK;
		return( nmg_region_end(tsp, pathp, curtree, client_data) );
	}

	if (RT_G_DEBUG&DEBUG_TREEWALK || verbose) {
		bu_log("\nConverted %d%% so far (%d of %d)\n",
			regions_tried>0 ? (regions_converted * 100) / regions_tried : 0,
		       regions_converted, regions_tried );
	}

	regions_tried++;
	name = db_path_to_string( pathp );
	bu_log( "Attempting %s\n", name );
	bu_free( name, "db_path_to_string" );
	bot2vrml( pmp, pathp, tsp->ts_regionid );
	clean_pmp( pmp );
	regions_converted++;
	BARRIER_CHECK;
	return( (union tree *)NULL );
}

union tree *nmg_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
{
	struct nmgregion	*r;
	struct bu_list		vhead;
	union tree		*ret_tree;
	char			*name;

	RT_CK_TESS_TOL(tsp->ts_ttol);
	BN_CK_TOL(tsp->ts_tol);
	NMG_CK_MODEL(*tsp->ts_m);

	BARRIER_CHECK;
	BU_LIST_INIT(&vhead);

	if (RT_G_DEBUG&DEBUG_TREEWALK || verbose) {
		bu_log("\nConverted %d%% so far (%d of %d)\n",
			regions_tried>0 ? (regions_converted * 100) / regions_tried : 0,
		       regions_converted, regions_tried );
	}

	if (curtree->tr_op == OP_NOP)
		return  curtree;

	name = db_path_to_string( pathp );
	bu_log( "Attempting %s\n", name );

	regions_tried++;
	/* Begin rt_bomb() protection */
	if( BU_SETJUMP )
	{
		/* Error, bail out */
		BU_UNSETJUMP;		/* Relinquish the protection */
		bu_log( "conversion of %s FAILED!!!\n", name );

		/* Sometimes the NMG library adds debugging bits when
		 * it detects an internal error, before rt_bomb().
		 */
		rt_g.NMG_debug = NMG_debug;	/* restore mode */

		/* Release any intersector 2d tables */
		nmg_isect2d_final_cleanup();

		/* Release the tree memory & input regions */
		db_free_tree(curtree, &rt_uniresource);		/* Does an nmg_kr() */

		/* Get rid of (m)any other intermediate structures */
		if( (*tsp->ts_m)->magic == NMG_MODEL_MAGIC )
		{
			nmg_km(*tsp->ts_m);
		}
		else
		{
			bu_log("WARNING: tsp->ts_m pointer corrupted, ignoring it.\n");
		}
	
		bu_free( name, "db_path_to_string" );
		/* Now, make a new, clean model structure for next pass. */
		*tsp->ts_m = nmg_mm();
		goto out;
	}
	ret_tree = nmg_booltree_evaluate(curtree, tsp->ts_tol, &rt_uniresource);

	if( ret_tree )
		r = ret_tree->tr_d.td_r;
	else
		r = (struct nmgregion *)NULL;

	BU_UNSETJUMP;		/* Relinquish the protection */
	bu_free( name, "db_path_to_string" );
	regions_converted++;
	if (r != 0)
	{
		struct shell *s;
		int empty_region=0;
		int empty_model=0;

		/* Kill cracks */
		s = BU_LIST_FIRST( shell, &r->s_hd );
		while( BU_LIST_NOT_HEAD( &s->l, &r->s_hd ) )
		{
			struct shell *next_s;

			next_s = BU_LIST_PNEXT( shell, &s->l );
			if( nmg_kill_cracks( s ) )
			{
				if( nmg_ks( s ) )
				{
					empty_region = 1;
					break;
				}
			}
			s = next_s;
		}

		/* kill zero length edgeuses */
		if( !empty_region )
		{
			 empty_model = nmg_kill_zero_length_edgeuses( *tsp->ts_m );
		}

		if( !empty_region && !empty_model )
		{
			/* Write the nmgregion to the output file */
			nmg_2_vrml( fp_out, pathp, r->m_p, &tsp->ts_mater );
		}

		/* NMG region is no longer necessary */
		if( !empty_model )
			nmg_kr(r);

	}
	else
		bu_log( "WARNING: Nothing left after Boolean evaluation of %s\n",
			db_path_to_string( pathp ) );

	/*
	 *  Dispose of original tree, so that all associated dynamic
	 *  memory is released now, not at the end of all regions.
	 *  A return of TREE_NULL from this routine signals an error,
	 *  so we need to cons up an OP_NOP node to return.
	 */
	db_free_tree(curtree, &rt_uniresource);		/* Does an nmg_kr() */

out:
	BU_GETUNION(curtree, tree);
	curtree->magic = RT_TREE_MAGIC;
	curtree->tr_op = OP_NOP;
	BARRIER_CHECK;
	return(curtree);
}
@


1.47
log
@change conf.h to a wrapped config.h
@
text
@d27 1
a27 1
static const char RCSid[] = "$Header: /cvs/brlcad/conv/g-vrml.c,v 1.46 2004/04/05 07:49:36 morrison Exp $";
@


1.46
log
@merge of ansi-6-0-branch into HEAD
@
text
@d27 1
a27 1
static const char RCSid[] = "$Header$";
d42 5
a46 1
#include "conf.h"
@


1.45
log
@update copyright to include span through 2003
@
text
@d27 1
a27 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.44 2003/12/01 16:26:25 morrison Exp $";
d193 1
a193 5
select_lights( tsp, pathp, combp, client_data )
register struct db_tree_state	*tsp;
struct db_full_path		*pathp;
const struct rt_comb_internal	*combp;
genptr_t			client_data;
d236 1
a236 5
select_non_lights( tsp, pathp, combp, client_data )
register struct db_tree_state	*tsp;
struct db_full_path		*pathp;
const struct rt_comb_internal	*combp;
genptr_t			client_data;
d248 1
a248 5
leaf_tess(tsp, pathp, ip, client_data)
struct db_tree_state    *tsp;
struct db_full_path     *pathp;
struct rt_db_internal	*ip;
genptr_t                client_data;
d291 1
a291 3
main(argc, argv)
int	argc;
char	*argv[];
d506 1
a506 5
nmg_2_vrml( fp, pathp, m, mater )
FILE *fp;
struct db_full_path *pathp;
struct model *m;
struct mater_info *mater;
d973 1
a973 5
union tree *do_region_end(tsp, pathp, curtree, client_data)
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
d1008 1
a1008 5
union tree *nmg_region_end(tsp, pathp, curtree, client_data)
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
@


1.44
log
@use RT_G_DEBUG define in if statements
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1995 by the United States Army
d27 1
a27 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.43 2002/08/20 17:07:21 jra Exp $";
@


1.43
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d27 1
a27 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.41 2001/10/02 19:24:09 jra Exp $";
d1013 1
a1013 1
	if (rt_g.debug&DEBUG_TREEWALK || verbose) {
d1048 1
a1048 1
	if (rt_g.debug&DEBUG_TREEWALK || verbose) {
@


1.43.4.1
log
@sync to HEAD...
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1995-2004 by the United States Army
d27 1
a27 1
static const char RCSid[] = "$Header: /n/cad/c/CVS/brlcad/conv/g-vrml.c,v 1.45 2004/02/02 17:39:00 morrison Exp $";
d1013 1
a1013 1
	if (RT_G_DEBUG&DEBUG_TREEWALK || verbose) {
d1048 1
a1048 1
	if (RT_G_DEBUG&DEBUG_TREEWALK || verbose) {
@


1.43.10.1
log
@updates from HEAD, part 1
@
text
@d27 1
a27 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.44 2003/12/01 16:26:25 morrison Exp $";
d1013 1
a1013 1
	if (RT_G_DEBUG&DEBUG_TREEWALK || verbose) {
d1048 1
a1048 1
	if (RT_G_DEBUG&DEBUG_TREEWALK || verbose) {
@


1.43.10.2
log
@merge from HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1995-2004 by the United States Army
d27 1
a27 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.45 2004/02/02 17:39:00 morrison Exp $";
@


1.43.10.3
log
@merge from head
@
text
@d27 1
a27 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.43.10.2 2004/02/12 19:24:23 erikg Exp $";
@


1.43.2.1
log
@Initial ANSIfication
@
text
@d27 1
a27 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.43 2002/08/20 17:07:21 jra Exp $";
d193 5
a197 1
select_lights(register struct db_tree_state *tsp, struct db_full_path *pathp, const struct rt_comb_internal *combp, genptr_t client_data)
d240 5
a244 1
select_non_lights(register struct db_tree_state *tsp, struct db_full_path *pathp, const struct rt_comb_internal *combp, genptr_t client_data)
d256 5
a260 1
leaf_tess(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
d303 3
a305 1
main(int argc, char **argv)
d520 5
a524 1
nmg_2_vrml(FILE *fp, struct db_full_path *pathp, struct model *m, struct mater_info *mater)
d991 5
a995 1
union tree *do_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
d1030 5
a1034 1
union tree *nmg_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
@


1.43.2.2
log
@sync branch with HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1995-2004 by the United States Army
d27 1
a27 1
static const char RCSid[] = "$Header$";
d991 1
a991 1
	if (RT_G_DEBUG&DEBUG_TREEWALK || verbose) {
d1022 1
a1022 1
	if (RT_G_DEBUG&DEBUG_TREEWALK || verbose) {
@


1.42
log
@Converted from K&R to ANSI C - RFH
@
text
@d193 5
a197 1
select_lights(register struct db_tree_state *tsp, struct db_full_path *pathp, const struct rt_comb_internal *combp, genptr_t client_data)
d240 5
a244 1
select_non_lights(register struct db_tree_state *tsp, struct db_full_path *pathp, const struct rt_comb_internal *combp, genptr_t client_data)
d256 5
a260 1
leaf_tess(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
d303 3
a305 1
main(int argc, char **argv)
d520 5
a524 1
nmg_2_vrml(FILE *fp, struct db_full_path *pathp, struct model *m, struct mater_info *mater)
d991 5
a995 1
union tree *do_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
d1030 5
a1034 1
union tree *nmg_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
@


1.41
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d27 1
a27 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.40 2001/08/21 17:33:44 jra Exp $";
d193 1
a193 5
select_lights( tsp, pathp, combp, client_data )
register struct db_tree_state	*tsp;
struct db_full_path		*pathp;
const struct rt_comb_internal	*combp;
genptr_t			client_data;
d236 1
a236 5
select_non_lights( tsp, pathp, combp, client_data )
register struct db_tree_state	*tsp;
struct db_full_path		*pathp;
const struct rt_comb_internal	*combp;
genptr_t			client_data;
d248 1
a248 5
leaf_tess(tsp, pathp, ip, client_data)
struct db_tree_state    *tsp;
struct db_full_path     *pathp;
struct rt_db_internal	*ip;
genptr_t                client_data;
d291 1
a291 3
main(argc, argv)
int	argc;
char	*argv[];
d506 1
a506 5
nmg_2_vrml( fp, pathp, m, mater )
FILE *fp;
struct db_full_path *pathp;
struct model *m;
struct mater_info *mater;
d973 1
a973 5
union tree *do_region_end(tsp, pathp, curtree, client_data)
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
d1008 1
a1008 5
union tree *nmg_region_end(tsp, pathp, curtree, client_data)
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
@


1.40
log
@Oops, left memory debugging turned on
Also changed to use db_dirbuild() instead of db_scan
Fixed a warning by using intern.idb_meth->ft_ifree() instead of a rt_bot_ifree() call
@
text
@d27 1
a27 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.39 2001/08/17 15:19:22 jra Exp $";
d148 1
@


1.39
log
@code was expecting the BOT to be directly within a region. Now it is more general
@
text
@d27 1
a27 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.24.2.3 2001/08/16 16:09:20 jra Exp $";
d30 1
a30 1
#define MEMORY_LEAK_CHECKING 1
d151 1
a151 1
			rt_bot_ifree( &intern );
d413 3
a415 1
	db_scan(dbip, (int (*)())db_diradd, 1, NULL);
@


1.38
log
@Compiler warning patches
@
text
@d27 13
a39 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.37 2001/05/17 20:03:14 morrison Exp $";
d68 7
d113 1
a113 1
static char   usage[] = "Usage: %s [-v] [-xX lvl] [-d tolerance_distance (mm) ] [-a abs_tol (mm)] [-r rel_tol] [-n norm_tol] [-o out_file] [-u units] brlcad_db.g object(s)\n";
d134 57
d209 1
a209 1
	id = rt_db_get_internal( &intern, dp, dbip, (matp_t)NULL , &rt_uniresource);
d228 1
a228 1
		rt_db_free_internal( &intern , &rt_uniresource);
d233 1
a233 1
		rt_db_free_internal( &intern , &rt_uniresource);
d258 1
a258 1
struct rt_db_internal   *ip;
d262 3
d266 2
a267 1
	if( ip->idb_type != ID_BOT )
d269 1
d275 13
d289 5
d308 1
d313 1
a313 1
	rt_g.debug |= DEBUG_MEM_FULL;
d345 1
d413 1
a413 6

	if( db_dirbuild( dbip ) )
	{
		bu_log( "Failed to build directory for %s\n", argv[optind] );
		exit(1);
	}
d454 7
d485 1
a485 1
			(genptr_t)NULL);	/* in librt/nmg_bool.c */
d489 1
a489 1

d498 1
a498 1
		(genptr_t)NULL);	/* in librt/nmg_bool.c */
d500 1
d509 3
a511 3
#if MEMORY_LEAK_CHECKING
	bu_prmem("After complete G-NMG conversion");
#endif
d546 2
d556 1
a556 1
	id = rt_db_get_internal( &intern, dp, dbip, (matp_t)NULL , &rt_uniresource);
d614 1
d797 1
d923 1
d927 1
a927 4
is_leaf_bot( dbip, dp, clientdata )
struct db_i *dbip;
struct directory *dp;
genptr_t clientdata;
a928 29
	struct rt_db_internal intern;
	int id;

	id = rt_db_get_internal( &intern, dp, dbip, bn_mat_identity , &rt_uniresource);
	if( id < 0 )
	{
		bu_log( "Error importing solid (%s)\n", dp->d_namep );
		bu_bomb( "Error importing solid\n" );
	}

	if( id == ID_BOT )
	{
		int *i;

		i = (int *)clientdata;
		(*i)++;
	}
	else
		rt_db_free_internal( &intern , &rt_uniresource);
}

void
bot2vrml( dbip, comb, tree, ptr1, ptr2, ptr3 )
struct db_i *dbip;
struct rt_comb_internal *comb;
union tree *tree;
genptr_t ptr1, ptr2, ptr3;
{
	struct db_full_path *pathp;
a930 2
	struct directory *dp;
	struct rt_db_internal intern;
d932 1
a932 1
	int id;
d934 1
d936 1
a936 12
	if( (dp = db_lookup( dbip, tree->tr_l.tl_name, 1 )) == DIR_NULL )
		bu_bomb( "db_lookup failed!!\n" );

	id = rt_db_get_internal( &intern, dp, dbip, tree->tr_l.tl_mat , &rt_uniresource);
	if( id != ID_BOT )
	{
		bu_log( "ERROR: %s is not a BOT solid!!!!\n", tree->tr_l.tl_name );
		bu_bomb( "ERROR: expecting a BOT solid!!!!\n" );
	}

	bot = (struct rt_bot_internal *)intern.idb_ptr;
	RT_BOT_CK_MAGIC( bot );
a937 1
	pathp = (struct db_full_path *)ptr1;
d940 2
a941 1
	fprintf( fp_out, "\t\tShape {\n\t\t\t# Component_ID: %d   %s\n", comb->region_id, path_str );
d944 1
a944 1
	appearance = comb->region_id / 1000;
d949 6
a954 3
	for( i=0 ; i<bot->num_vertices ; i++ )
	{
		point_t pt;
d956 4
a959 2
		VSCALE( pt, &bot->vertices[i*3], scale_factor );
		fprintf( fp_out, "\t\t\t\t\t%10.10e %10.10e %10.10e, # point %d\n", V3ARGS( pt ), i );
d962 11
a972 2
	for( i=0 ; i<bot->num_faces ; i++ )
		fprintf( fp_out, "\t\t\t\t\t%d, %d, %d, -1,\n", V3ARGS( &bot->faces[i*3] ) );
d978 1
d994 1
a994 5
	struct directory *dp;
	struct rt_comb_internal *comb;
	struct rt_db_internal intern;
	int id;
	int bot=0;
d997 3
a999 1
	if( tsp->ts_is_fastgen != REGION_FASTGEN_PLATE )
d1001 1
d1004 3
a1006 3
	dp = DB_FULL_PATH_CUR_DIR(pathp);
	db_functree( tsp->ts_dbip, dp, NULL, is_leaf_bot, &rt_uniresource, (genptr_t)&bot );
	if( !bot )
a1007 14
	else
	{
		id = rt_db_get_internal( &intern, dp, dbip, bn_mat_identity , &rt_uniresource);
		if( id != ID_COMBINATION )
		{
			bu_log( "ERROR: %s is not a combination????\n", dp->d_namep );
			bu_bomb( "Expected a region!!!!\n" );
		}
		comb = (struct rt_comb_internal *)intern.idb_ptr;
		name = db_path_to_string( pathp );
		bu_log( "Attempting %s\n", name );
		bu_free( name, "db_path_to_string" );
		db_tree_funcleaf( tsp->ts_dbip, comb, comb->tree, bot2vrml, pathp, NULL, NULL );
		return( (union tree *)NULL );
d1009 16
d1042 1
d1045 2
a1046 4
	if (RT_G_DEBUG&DEBUG_TREEWALK || verbose) {
		char	*sofar = db_path_to_string(pathp);
		bu_log("\ndo_region_end(%d %d%%) %s\n",
			regions_tried,
d1048 1
a1048 2
			sofar);
		bu_free(sofar, "path string");
a1055 1
	bu_free( name, "db_path_to_string" );
d1063 1
d1086 1
d1091 1
a1091 1
	ret_tree = nmg_booltree_evaluate(curtree, tsp->ts_tol, &rt_uniresource);	/* librt/nmg_bool.c */
d1099 1
d1158 1
@


1.37
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d27 1
a27 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.36 2001/04/05 19:34:59 morrison Exp $";
d274 1
a274 1
			sscanf( optarg, "%x", &rt_g.debug );
d277 1
a277 1
			sscanf( optarg, "%x", &rt_g.NMG_debug );
@


1.36
log
@updated SIGNED to signed
updated CONST to const
@
text
@d27 1
a27 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.35 2000/10/20 20:29:24 jra Exp $";
d963 1
a963 1
	if (rt_g.debug&DEBUG_TREEWALK || verbose) {
@


1.35
log
@Added resource structure pointer to calls of db_functree()
@
text
@d27 1
a27 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.34 2000/10/12 14:12:21 jra Exp $";
d119 1
a119 1
CONST struct rt_comb_internal	*combp;
d166 1
a166 1
CONST struct rt_comb_internal	*combp;
d376 1
a376 1
		(void)db_walk_tree(dbip, 1, (CONST char **)(&argv[i]),
d389 1
a389 1
	(void)db_walk_tree(dbip, argc-optind, (CONST char **)(&argv[optind]),
@


1.34
log
@A few fixes:
 1. lights are only done once!!!!
 2. Use region color, even if no shader is assigned
 3. Eliminated emissive color for non-lights
@
text
@d27 1
a27 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.33 2000/09/08 05:55:42 mike Exp $";
d926 1
a926 1
	db_functree( tsp->ts_dbip, dp, NULL, is_leaf_bot, (genptr_t)&bot );
@


1.33
log
@
Tree routines now need resource structure.
Added rt_init_resource() call.
@
text
@d27 1
a27 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.32 2000/08/17 20:09:58 jra Exp $";
d169 7
a175 1
	return( !select_lights( tsp, pathp, combp, client_data ) );
d349 7
a386 6
	/* I had hoped to create a separate sub-tree (using the Transform node) for each group name argument
	 * however, it appears they are all handled at the same time so I will only have one Transform for the
	 * complete conversion
	 * Later on switch nodes may be added to turn on and off the groups (via ROUTE nodes) */
	fprintf ( fp_out, "Transform {\n");
	fprintf ( fp_out, "\tchildren [\n");
a466 4
	fprintf( fp, "\t\tShape { \n");
	fprintf( fp, "\t\t\t# Component_ID: %d   %s\n",comb->region_id,full_path);
	fprintf( fp, "\t\t\tappearance Appearance { \n");

d502 1
a502 1
	else if( strncmp( "plastic", mat.shader, 7 ) == 0 )
d504 3
a506 42
		if( mat.shininess < 0 )
			mat.shininess = 10;
		if( mat.transparency < 0.0 )
			mat.transparency = 0.0;

		fprintf( fp, "\t\t\t\tmaterial Material {\n" );
		fprintf( fp, "\t\t\t\t\tdiffuseColor %g %g %g \n", r, g, b );
		fprintf( fp, "\t\t\t\t\temissiveColor %g %g %g \n", r, g, b );
		fprintf( fp, "\t\t\t\t\tshininess %g\n", 1.0-exp(-(double)mat.shininess/20.0 ) );
		if( mat.transparency > 0.0 )
			fprintf( fp, "\t\t\t\t\ttransparency %g\n", mat.transparency );
		fprintf( fp, "\t\t\t\t\tspecularColor %g %g %g \n\t\t\t\t}\n", 1.0, 1.0, 1.0 );
	}
	else if( strncmp( "glass", mat.shader, 5 ) == 0 )
	{
		if( mat.shininess < 0 )
			mat.shininess = 4;
		if( mat.transparency < 0.0 )
			mat.transparency = 0.8;

		fprintf( fp, "\t\t\t\tmaterial Material {\n" );
		fprintf( fp, "\t\t\t\t\tdiffuseColor %g %g %g \n", r, g, b );
		fprintf( fp, "\t\t\t\t\temissiveColor %g %g %g \n", r, g, b );
		fprintf( fp, "\t\t\t\t\tshininess %g\n", 1.0-exp(-(double)mat.shininess/20.0 ) );
		if( mat.transparency > 0.0 )
			fprintf( fp, "\t\t\t\t\ttransparency %g\n", mat.transparency );
		fprintf( fp, "\t\t\t\t\tspecularColor %g %g %g \n\t\t\t\t}\n", 1.0, 1.0, 1.0 );
	}
	else if( strncmp( "texture", mat.shader, 7 ) == 0 )
	{
		if( mat.tx_w < 0 )
			mat.tx_w = 512;
		if( mat.tx_n < 0 )
			mat.tx_n = 512;

		if( strlen( mat.tx_file ) )
		{
			int tex_fd;
			int nbytes;
			long tex_len;
			long bytes_read=0;
			unsigned char tex_buf[TXT_BUF_LEN*3];
d508 36
a543 1
			if( (tex_fd = open( mat.tx_file, O_RDONLY )) == (-1) )
d545 12
a556 14
				bu_log( "Cannot open texture file (%s)\n", mat.tx_file );
				perror( "g-vrml: " );
			}
			else
			{
				/* Johns note - need to check (test) the texture stuff */
				fprintf( fp, "\t\t\t\ttextureTransform TextureTransform {\n");
				fprintf( fp, "\t\t\t\t\tscale 1.33333 1.33333\n\t\t\t\t}\n");
				fprintf( fp, "\t\t\t\ttexture PixelTexture {\n");
				fprintf( fp, "\t\t\t\t\trepeatS TRUE\n");
				fprintf( fp, "\t\t\t\t\trepeatT TRUE\n");
				fprintf( fp, "\t\t\t\t\timage %d %d %d\n", mat.tx_w, mat.tx_n, 3 );
				tex_len = mat.tx_w*mat.tx_n*3;
				while( bytes_read < tex_len )
d558 11
a568 1
					long bytes_to_go=tex_len;
d570 16
a585 14
					bytes_to_go = tex_len - bytes_read;
					if( bytes_to_go > TXT_BUF_LEN*3 )
						bytes_to_go = TXT_BUF_LEN*3;
					nbytes = 0;
					while( nbytes < bytes_to_go )
						nbytes += read( tex_fd, &tex_buf[nbytes],
							bytes_to_go-nbytes );

					bytes_read += nbytes;
					for( i=0 ; i<nbytes ; i += 3 )
						fprintf( fp, "\t\t\t0x%02x%02x%02x\n",
							tex_buf[i],
							tex_buf[i+1],
							tex_buf[i+2] );
a586 1
				fprintf( fp, "\t\t\t\t}\n" );
d589 24
a612 20
	}
	else
	{
		/* If no color was defined set the colors according to the thousands groups */
		int thou = comb->region_id/1000;
		thou == 0 ? fprintf( fp, "\t\t\tmaterial USE Material_999\n")
		: thou == 1 ? fprintf( fp, "\t\t\tmaterial USE Material_1999\n")
		: thou == 2 ? fprintf( fp, "\t\t\tmaterial USE Material_2999\n")
		: thou == 3 ? fprintf( fp, "\t\t\tmaterial USE Material_3999\n")
		: thou == 4 ? fprintf( fp, "\t\t\tmaterial USE Material_4999\n")
		: thou == 5 ? fprintf( fp, "\t\t\tmaterial USE Material_5999\n")
		: thou == 6 ? fprintf( fp, "\t\t\tmaterial USE Material_6999\n")
		: thou == 7 ? fprintf( fp, "\t\t\tmaterial USE Material_7999\n")
		: thou == 8 ? fprintf( fp, "\t\t\tmaterial USE Material_8999\n")
		: fprintf( fp, "\t\t\tmaterial USE Material_9999\n");

/*		fprintf( fp, "\t\t\t\tmaterial Material {\n" );
 *		fprintf( fp, "\t\t\t\t\tdiffuseColor %g %g %g \n", r, g, b );
 *		fprintf( fp, "\t\t\t\t\temissiveColor %g %g %g \n", r, g, b );
 *		fprintf( fp, "\t\t\t\t\tspecularColor %g %g %g \n\t\t\t\t}\n", 1.0, 1.0, 1.0 );
d614 1
d687 3
a691 4
	fprintf( fp, "\t\t\t} \n");
	fprintf( fp, "\t\t\tgeometry IndexedFaceSet { \n");
	fprintf( fp, "\t\t\t\tcoord Coordinate { \n");

d803 2
a804 2
			fprintf( fp, "SpotLight {\n" );
			fprintf( fp, "\ton \tTRUE\n" );
d806 5
a810 5
				fprintf( fp, "\tintensity \t%g\n", mat.lt_fraction );
			fprintf( fp, "\tcolor \t%g %g %g\n", r,g,b );
			fprintf( fp, "\tlocation \t%g %g %g\n", V3ARGS( ave_pt ) );
			fprintf( fp, "\tdirection \t%g %g %g\n", V3ARGS( mat.lt_dir ) );
			fprintf( fp, "\tcutOffAngle \t%g }\n", mat.lt_angle );
d813 1
a813 1
			fprintf( fp, "PointLight {\n\ton TRUE\n\tintensity 1\n\tcolor %g %g %g\n\tlocation %g %g %g\n}\n",r,g,b,V3ARGS( ave_pt ) );
@


1.32
log
@Lint
@
text
@d27 1
a27 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.31 2000/08/17 17:03:23 jra Exp $";
d133 1
a133 1
	id = rt_db_get_internal( &intern, dp, dbip, (matp_t)NULL );
d152 1
a152 1
		rt_db_free_internal( &intern );
d157 1
a157 1
		rt_db_free_internal( &intern );
d235 2
d443 1
a443 1
	id = rt_db_get_internal( &intern, dp, dbip, (matp_t)NULL );
d814 1
a814 1
	id = rt_db_get_internal( &intern, dp, dbip, bn_mat_identity );
d829 1
a829 1
		rt_db_free_internal( &intern );
d851 1
a851 1
	id = rt_db_get_internal( &intern, dp, dbip, tree->tr_l.tl_mat );
d919 1
a919 1
		id = rt_db_get_internal( &intern, dp, dbip, bn_mat_identity );
d983 1
a983 1
		db_free_tree(curtree);		/* Does an nmg_kr() */
d999 1
a999 1
	ret_tree = nmg_booltree_evaluate(curtree, tsp->ts_tol);	/* librt/nmg_bool.c */
d1059 1
a1059 1
	db_free_tree(curtree);		/* Does an nmg_kr() */
@


1.31
log
@Needed a declaration of nmg_region_end()
@
text
@d27 1
a27 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.30 2000/08/17 14:31:23 jra Exp $";
d94 1
a94 1
static char	usage[] = "Usage: %s [-v] [-xX lvl] [-d tolerance_distance (mm) ] [-a abs_tol (mm)] [-r rel_tol] [-n norm_tol] [-o out_file] brlcad_db.g object(s)\n";
a179 1
	struct directory *dp;
a187 2
	{
		/* bot2vrml( bot ); */
a188 1
	}
a808 1
	struct rt_bot_internal *bot, **abot;
@


1.30
log
@Forgot a break and to list the new option in the call to getopt()
@
text
@d27 1
a27 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.29 2000/08/17 14:17:10 jra Exp $";
d92 1
@


1.29
log
@Added support for plate mode BOTS
@
text
@d27 1
a27 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.28 2000/07/20 20:56:46 jra Exp $";
d241 1
a241 1
	while ((c = getopt(argc, argv, "d:a:n:o:r:vx:P:X:")) != EOF) {
d284 1
@


1.28
log
@replaced db_scan() call with db_dirbuild()
@
text
@d27 1
a27 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.27 2000/07/20 19:32:20 jra Exp $";
d106 3
d171 25
d275 9
d296 3
d326 1
a326 1
	fprintf( fp_out, "#Original Database Units were %s, VRML units are meters\n",rt_units_string(dbip->dbi_local2base));
d368 1
a368 1
			nmg_booltree_leaf_tess,
d387 1
a387 1
		nmg_booltree_leaf_tess,
d700 2
a701 2
		/* convert to meters */
		VSCALE( pt_meters, vg->coord, 0.001 );
d805 85
d903 38
d944 1
d964 3
a966 1
	bu_log( "Attempting %s\n", db_path_to_string( pathp ) );
@


1.27
log
@Eliminated an unecessary bn_vlist_free() call
@
text
@d27 1
a27 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.26 2000/07/12 21:59:35 mike Exp $";
d266 6
a271 1
	db_scan(dbip, (int (*)())db_diradd, 1, NULL);
@


1.26
log
@
Converted to use new version of LIBWDB
@
text
@d27 1
a27 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.25 2000/07/10 23:53:58 mike Exp $";
a347 1
	bn_vlist_cleanup();
@


1.25
log
@
lint
@
text
@d27 1
a27 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.24 2000/03/29 18:15:17 mike Exp $";
a773 1
	extern FILE		*fp_fig;
@


1.24
log
@
Eliminated macro which also appears in vmath.h now
@
text
@d27 1
a27 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.23 2000/03/29 18:10:59 mike Exp $";
@


1.24.2.1
log
@Added support for BOT plate mode objects
@
text
@d27 1
a27 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.30 2000/08/17 14:31:23 jra Exp $";
a91 1
BU_EXTERN(union tree *nmg_region_end, (struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data));
d93 1
a93 1
static char	usage[] = "Usage: %s [-v] [-xX lvl] [-d tolerance_distance (mm) ] [-a abs_tol (mm)] [-r rel_tol] [-n norm_tol] [-o out_file] [-u units] brlcad_db.g object(s)\n";
a105 3
static	char*	units=NULL;
static fastf_t	scale_factor=1.0;

a167 36
union tree *
leaf_tess(tsp, pathp, ep, id, client_data)
struct db_tree_state    *tsp;
struct db_full_path     *pathp;
struct bu_external	*ep;
int			id;
genptr_t                client_data;
{
	struct rt_db_internal intern;
	struct rt_bot_internal *bot;
	struct directory *dp;

	if( id != ID_BOT )
		return( nmg_booltree_leaf_tess(tsp, pathp, ep, id, client_data) );

        RT_INIT_DB_INTERNAL(&intern);
        if (rt_functab[id].ft_import(&intern, ep, tsp->ts_mat, tsp->ts_dbip) < 0) {
                bu_log("nmg_booltree_leaf_tess(%s):  solid import failure\n", dp->d_namep);
                if (intern.idb_ptr)  rt_functab[id].ft_ifree(&intern);
                return(TREE_NULL);              /* ERROR */
        }
        RT_CK_DB_INTERNAL(&intern);

	bot = (struct rt_bot_internal *)intern.idb_ptr;
	RT_BOT_CK_MAGIC( bot );

	if( bot->mode == RT_BOT_PLATE || bot->mode == RT_BOT_SURFACE )
	{
		rt_db_free_internal( &intern );
		return( (union tree *)NULL );
	}

	rt_db_free_internal( &intern );
	return( nmg_booltree_leaf_tess(tsp, pathp, ep, id, client_data) );
}

d213 1
a213 1
	while ((c = getopt(argc, argv, "d:a:n:o:r:vx:P:X:u:")) != EOF) {
a246 10
		case 'u':
			units = bu_strdup( optarg );
			scale_factor = bu_units_conversion( units );
			if( scale_factor == 0.0 )
			{
				bu_log( "Unrecognized units (%s)\n", units );
				bu_bomb( "Unrecognized units\n" );
			}
			scale_factor = 1.0 / scale_factor;
			break;
a258 3
	if( !units )
		units = "mm";

d281 1
a281 1
	fprintf( fp_out, "#Units are %s\n", units);
d323 1
a323 1
			leaf_tess,
d342 1
a342 1
		leaf_tess,
d348 1
d656 2
a657 2
		/* convert to desired units */
		VSCALE( pt_meters, vg->coord, scale_factor );
a760 85
void
is_leaf_bot( dbip, dp, clientdata )
struct db_i *dbip;
struct directory *dp;
genptr_t clientdata;
{
	struct rt_bot_internal *bot, **abot;
	struct rt_db_internal intern;
	int id;

	id = rt_db_get_internal( &intern, dp, dbip, bn_mat_identity );
	if( id < 0 )
	{
		bu_log( "Error importing solid (%s)\n", dp->d_namep );
		bu_bomb( "Error importing solid\n" );
	}

	if( id == ID_BOT )
	{
		int *i;

		i = (int *)clientdata;
		(*i)++;
	}
	else
		rt_db_free_internal( &intern );
}

void
bot2vrml( dbip, comb, tree, ptr1, ptr2, ptr3 )
struct db_i *dbip;
struct rt_comb_internal *comb;
union tree *tree;
genptr_t ptr1, ptr2, ptr3;
{
	struct db_full_path *pathp;
	char *path_str;
	int appearance;
	struct directory *dp;
	struct rt_db_internal intern;
	struct rt_bot_internal *bot;
	int id;
	int i;

	if( (dp = db_lookup( dbip, tree->tr_l.tl_name, 1 )) == DIR_NULL )
		bu_bomb( "db_lookup failed!!\n" );

	id = rt_db_get_internal( &intern, dp, dbip, tree->tr_l.tl_mat );
	if( id != ID_BOT )
	{
		bu_log( "ERROR: %s is not a BOT solid!!!!\n", tree->tr_l.tl_name );
		bu_bomb( "ERROR: expecting a BOT solid!!!!\n" );
	}

	bot = (struct rt_bot_internal *)intern.idb_ptr;
	RT_BOT_CK_MAGIC( bot );

	pathp = (struct db_full_path *)ptr1;
	path_str = db_path_to_string( pathp );

	fprintf( fp_out, "\t\tShape {\n\t\t\t# Component_ID: %d   %s\n", comb->region_id, path_str );
	bu_free( path_str, "result of db_path_to_string" );

	appearance = comb->region_id / 1000;
	appearance = appearance * 1000 + 999;
	fprintf( fp_out, "\t\t\tappearance Appearance {\n\t\t\tmaterial USE Material_%d\n\t\t\t}\n", appearance );
	fprintf( fp_out, "\t\t\tgeometry IndexedFaceSet {\n\t\t\t\tcoord Coordinate {\n\t\t\t\tpoint [\n" );

	for( i=0 ; i<bot->num_vertices ; i++ )
	{
		point_t pt;

		VSCALE( pt, &bot->vertices[i*3], scale_factor );
		fprintf( fp_out, "\t\t\t\t\t%10.10e %10.10e %10.10e, # point %d\n", V3ARGS( pt ), i );
	}
	fprintf( fp_out, "\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\tcoordIndex [\n" );
	for( i=0 ; i<bot->num_faces ; i++ )
		fprintf( fp_out, "\t\t\t\t\t%d, %d, %d, -1,\n", V3ARGS( &bot->faces[i*3] ) );
	fprintf( fp_out, "\t\t\t\t]\n\t\t\t\tnormalPerVertex FALSE\n" );
	fprintf( fp_out, "\t\t\t\tconvex TRUE\n" );
	fprintf( fp_out, "\t\t\t\tcreaseAngle 0.5\n" );
	fprintf( fp_out, "\t\t\t\tsolid FALSE\n" );
	fprintf( fp_out, "\t\t\t}\n\t\t}\n" );
}

d774 1
a774 38
	struct directory *dp;
	struct rt_comb_internal *comb;
	struct rt_db_internal intern;
	int id;
	int bot=0;
	char *name;

	if( tsp->ts_is_fastgen != REGION_FASTGEN_PLATE )
		return( nmg_region_end(tsp, pathp, curtree, client_data) );

	/* FASTGEN plate mode region, just spew the bot triangles */
	dp = DB_FULL_PATH_CUR_DIR(pathp);
	db_functree( tsp->ts_dbip, dp, NULL, is_leaf_bot, (genptr_t)&bot );
	if( !bot )
		return( nmg_region_end(tsp, pathp, curtree, client_data) );
	else
	{
		id = rt_db_get_internal( &intern, dp, dbip, bn_mat_identity );
		if( id != ID_COMBINATION )
		{
			bu_log( "ERROR: %s is not a combination????\n", dp->d_namep );
			bu_bomb( "Expected a region!!!!\n" );
		}
		comb = (struct rt_comb_internal *)intern.idb_ptr;
		name = db_path_to_string( pathp );
		bu_log( "Attempting %s\n", name );
		bu_free( name, "db_path_to_string" );
		db_tree_funcleaf( tsp->ts_dbip, comb, comb->tree, bot2vrml, pathp, NULL, NULL );
		return( (union tree *)NULL );
	}
}

union tree *nmg_region_end(tsp, pathp, curtree, client_data)
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
{
a777 1
	char			*name;
d797 1
a797 3
	name = db_path_to_string( pathp );
	bu_log( "Attempting %s\n", name );
	bu_free( name, "db_path_to_string" );
@


1.24.2.2
log
@a few updates:
 1. Lights are only done once.
 2. Use asigned color even if no shader is specified.
 3. Eliminated emissive color for non-lights.
@
text
@d27 1
a27 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.24.2.1 2000/08/17 15:24:38 jra Exp $";
d169 1
a169 7
	int ret;

	ret =  select_lights( tsp, pathp, combp, client_data );
	if( ret == 0 )
		return( -1 );
	else
		return( 0 );
a350 7
	/* I had hoped to create a separate sub-tree (using the Transform node) for each group name argument
	 * however, it appears they are all handled at the same time so I will only have one Transform for the
	 * complete conversion
	 * Later on switch nodes may be added to turn on and off the groups (via ROUTE nodes) */
	fprintf ( fp_out, "Transform {\n");
	fprintf ( fp_out, "\tchildren [\n");

d382 7
d468 4
d507 1
a507 1
	else
d509 42
a550 3
		fprintf( fp, "\t\tShape { \n");
		fprintf( fp, "\t\t\t# Component_ID: %d   %s\n",comb->region_id,full_path);
		fprintf( fp, "\t\t\tappearance Appearance { \n");
d552 6
a557 37

		if( strncmp( "plastic", mat.shader, 7 ) == 0 )
		{
			if( mat.shininess < 0 )
				mat.shininess = 10;
			if( mat.transparency < 0.0 )
				mat.transparency = 0.0;

			fprintf( fp, "\t\t\t\tmaterial Material {\n" );
			fprintf( fp, "\t\t\t\t\tdiffuseColor %g %g %g \n", r, g, b );
			fprintf( fp, "\t\t\t\t\tshininess %g\n", 1.0-exp(-(double)mat.shininess/20.0 ) );
			if( mat.transparency > 0.0 )
				fprintf( fp, "\t\t\t\t\ttransparency %g\n", mat.transparency );
			fprintf( fp, "\t\t\t\t\tspecularColor %g %g %g \n\t\t\t\t}\n", 1.0, 1.0, 1.0 );
		}
		else if( strncmp( "glass", mat.shader, 5 ) == 0 )
		{
			if( mat.shininess < 0 )
				mat.shininess = 4;
			if( mat.transparency < 0.0 )
				mat.transparency = 0.8;

			fprintf( fp, "\t\t\t\tmaterial Material {\n" );
			fprintf( fp, "\t\t\t\t\tdiffuseColor %g %g %g \n", r, g, b );
			fprintf( fp, "\t\t\t\t\tshininess %g\n", 1.0-exp(-(double)mat.shininess/20.0 ) );
			if( mat.transparency > 0.0 )
				fprintf( fp, "\t\t\t\t\ttransparency %g\n", mat.transparency );
			fprintf( fp, "\t\t\t\t\tspecularColor %g %g %g \n\t\t\t\t}\n", 1.0, 1.0, 1.0 );
		}
		else if( strncmp( "texture", mat.shader, 7 ) == 0 )
		{
			if( mat.tx_w < 0 )
				mat.tx_w = 512;
			if( mat.tx_n < 0 )
				mat.tx_n = 512;

			if( strlen( mat.tx_file ) )
d559 9
a567 7
				int tex_fd;
				int nbytes;
				long tex_len;
				long bytes_read=0;
				unsigned char tex_buf[TXT_BUF_LEN*3];

				if( (tex_fd = open( mat.tx_file, O_RDONLY )) == (-1) )
d569 1
a569 16
					bu_log( "Cannot open texture file (%s)\n", mat.tx_file );
					perror( "g-vrml: " );
				}
				else
				{
					/* Johns note - need to check (test) the texture stuff */
					fprintf( fp, "\t\t\t\ttextureTransform TextureTransform {\n");
					fprintf( fp, "\t\t\t\t\tscale 1.33333 1.33333\n\t\t\t\t}\n");
					fprintf( fp, "\t\t\t\ttexture PixelTexture {\n");
					fprintf( fp, "\t\t\t\t\trepeatS TRUE\n");
					fprintf( fp, "\t\t\t\t\trepeatT TRUE\n");
					fprintf( fp, "\t\t\t\t\timage %d %d %d\n", mat.tx_w, mat.tx_n, 3 );
					tex_len = mat.tx_w*mat.tx_n*3;
					while( bytes_read < tex_len )
					{
						long bytes_to_go=tex_len;
d571 14
a584 16
						bytes_to_go = tex_len - bytes_read;
						if( bytes_to_go > TXT_BUF_LEN*3 )
							bytes_to_go = TXT_BUF_LEN*3;
						nbytes = 0;
						while( nbytes < bytes_to_go )
							nbytes += read( tex_fd, &tex_buf[nbytes],
								bytes_to_go-nbytes );

						bytes_read += nbytes;
						for( i=0 ; i<nbytes ; i += 3 )
							fprintf( fp, "\t\t\t0x%02x%02x%02x\n",
								tex_buf[i],
								tex_buf[i+1],
								tex_buf[i+2] );
					}
					fprintf( fp, "\t\t\t\t}\n" );
d586 1
d589 20
a608 24
		else if( mater->ma_color_valid )
		{
			/* no shader specified, but a color is assigned */
			fprintf( fp, "\t\t\t\tmaterial Material {\n" );
			fprintf( fp, "\t\t\t\t\tdiffuseColor %g %g %g }\n", r, g, b );
		}
		else
		{
			/* If no color was defined set the colors according to the thousands groups */
			int thou = comb->region_id/1000;
			thou == 0 ? fprintf( fp, "\t\t\tmaterial USE Material_999\n")
			: thou == 1 ? fprintf( fp, "\t\t\tmaterial USE Material_1999\n")
			: thou == 2 ? fprintf( fp, "\t\t\tmaterial USE Material_2999\n")
			: thou == 3 ? fprintf( fp, "\t\t\tmaterial USE Material_3999\n")
			: thou == 4 ? fprintf( fp, "\t\t\tmaterial USE Material_4999\n")
			: thou == 5 ? fprintf( fp, "\t\t\tmaterial USE Material_5999\n")
			: thou == 6 ? fprintf( fp, "\t\t\tmaterial USE Material_6999\n")
			: thou == 7 ? fprintf( fp, "\t\t\tmaterial USE Material_7999\n")
			: thou == 8 ? fprintf( fp, "\t\t\tmaterial USE Material_8999\n")
			: fprintf( fp, "\t\t\tmaterial USE Material_9999\n");

/*			fprintf( fp, "\t\t\t\tmaterial Material {\n" );
 *			fprintf( fp, "\t\t\t\t\tdiffuseColor %g %g %g \n", r, g, b );
 *			fprintf( fp, "\t\t\t\t\tspecularColor %g %g %g \n\t\t\t\t}\n", 1.0, 1.0, 1.0 );
a609 1
		}
d682 1
a682 3
		fprintf( fp, "\t\t\t} \n");
		fprintf( fp, "\t\t\tgeometry IndexedFaceSet { \n");
		fprintf( fp, "\t\t\t\tcoord Coordinate { \n");
d684 3
a686 1
	}
d799 2
a800 2
			fprintf( fp, "\t\tSpotLight {\n" );
			fprintf( fp, "\t\t\ton \tTRUE\n" );
d802 5
a806 5
				fprintf( fp, "\t\t\tintensity \t%g\n", mat.lt_fraction );
			fprintf( fp, "\t\t\tcolor \t%g %g %g\n", r,g,b );
			fprintf( fp, "\t\t\tlocation \t%g %g %g\n", V3ARGS( ave_pt ) );
			fprintf( fp, "\t\t\tdirection \t%g %g %g\n", V3ARGS( mat.lt_dir ) );
			fprintf( fp, "\t\t\tcutOffAngle \t%g }\n", mat.lt_angle );
d809 1
a809 1
			fprintf( fp, "\t\tPointLight {\n\t\t\ton TRUE\n\t\t\tintensity 1\n\t\t\tcolor %g %g %g\n\t\t\tlocation %g %g %g\n\t\t}\n",r,g,b,V3ARGS( ave_pt ) );
@


1.24.2.3
log
@Fixed bug where convertr was expecting all Bot solids to be directly under region
@
text
@d27 1
a27 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.24.2.2 2000/10/12 15:10:07 jra Exp $";
a55 7
struct plate_mode {
	int num_bots;
	int num_nonbots;
	int array_size;
	struct rt_bot_internal **bots;
};

a114 21
static void
clean_pmp( struct plate_mode *pmp )
{
	int i;

	pmp->num_bots = 0;
	pmp->num_nonbots = 0;
	for( i=0 ; i<pmp->array_size ; i++ ) {
		if( pmp->bots[i] ) {
			struct rt_db_internal intern;

			intern.idb_ptr = (genptr_t) pmp->bots[i];
			intern.idb_type = ID_BOT;
			intern.idb_meth = &rt_functab[ID_BOT];
			intern.idb_magic = RT_DB_INTERNAL_MAGIC;
			rt_bot_ifree( &intern );
			pmp->bots[i] = NULL;
		}
	}
}

a188 1
	struct plate_mode *pmp = (struct plate_mode *)client_data;
d190 1
a190 2
	if( id != ID_BOT ) {
		pmp->num_nonbots++;
a191 1
	}
d206 1
a206 8
		if( pmp->array_size <= pmp->num_bots ) {
			pmp->array_size += 5;
			pmp->bots = (struct rt_bot_internal **)bu_realloc(
				    (char *)pmp->bots, pmp->array_size,
				    "pmp->bots" );
		}
		pmp->bots[pmp->num_bots] = bot;
		pmp->num_bots++;
a210 1
	pmp->num_nonbots++;
a223 1
	struct plate_mode pm;
d287 1
a287 1
			sscanf( optarg, "%x", (unsigned int *)&rt_g.debug );
d290 1
a290 1
			sscanf( optarg, "%x", (unsigned int *)&rt_g.NMG_debug );
a365 5
	pm.num_bots = 0;
	pm.num_nonbots = 0;
	pm.array_size = 5;
	pm.bots = (struct rt_bot_internal **)bu_calloc( pm.array_size,
		sizeof( struct rt_bot_internal *), "pm.bots" );
d390 1
a390 1
			(genptr_t)&pm);	/* in librt/nmg_bool.c */
d402 1
a402 1
		(genptr_t)&pm);	/* in librt/nmg_bool.c */
a415 4
	if( verbose )
		bu_log( "Total of %d regions converted of %d regions attempted\n",
			regions_converted, regions_tried );

d827 4
a830 1
bot2vrml( struct plate_mode *pmp, struct db_full_path *pathp, int region_id )
d832 30
d864 2
d867 1
a867 1
	int bot_num;
a868 1
	int vert_count=0;
d870 14
d886 1
a886 2
	fprintf( fp_out, "\t\tShape {\n\t\t\t# Component_ID: %d   %s\n",
		 region_id, path_str );
d889 1
a889 1
	appearance = region_id / 1000;
d894 3
a896 6
	for( bot_num = 0 ; bot_num < pmp->num_bots ; bot_num++ ) {
		bot = pmp->bots[bot_num];
		RT_BOT_CK_MAGIC( bot );
		for( i=0 ; i<bot->num_vertices ; i++ )
			{
				point_t pt;
d898 2
a899 4
				VSCALE( pt, &bot->vertices[i*3], scale_factor );
				fprintf( fp_out, "\t\t\t\t\t%10.10e %10.10e %10.10e, # point %d\n", V3ARGS( pt ), vert_count );
				vert_count++;
			}
d902 2
a903 11
	vert_count = 0;
	for( bot_num = 0 ; bot_num < pmp->num_bots ; bot_num++ ) {
		bot = pmp->bots[bot_num];
		RT_BOT_CK_MAGIC( bot );
		for( i=0 ; i<bot->num_faces ; i++ )
			fprintf( fp_out, "\t\t\t\t\t%d, %d, %d, -1,\n",
				 vert_count+bot->faces[i*3],
				 vert_count+bot->faces[i*3+1],
				 vert_count+bot->faces[i*3+2]);
		vert_count += bot->num_vertices;
	}
d924 5
a928 1
	struct plate_mode *pmp = (struct plate_mode *)client_data;
d931 1
a931 2
	if( tsp->ts_is_fastgen != REGION_FASTGEN_PLATE ) {
		clean_pmp( pmp );
a932 1
	}
d935 3
a937 2
	if( pmp->num_bots < 1 || pmp->num_nonbots > 0 ) {
		clean_pmp( pmp );
d939 14
a953 15

	if (rt_g.debug&DEBUG_TREEWALK || verbose) {
		bu_log("\nConverted %d%% so far (%d of %d)\n",
			regions_tried>0 ? (regions_converted * 100) / regions_tried : 0,
		       regions_converted, regions_tried );
	}

	regions_tried++;
	name = db_path_to_string( pathp );
	bu_log( "Attempting %s\n", name );
	bu_free( name, "db_path_to_string" );
	bot2vrml( pmp, pathp, tsp->ts_regionid );
	clean_pmp( pmp );
	regions_converted++;
	return( (union tree *)NULL );
d974 3
a976 1
		bu_log("\nConverted %d%% so far (%d of %d)\n",
d978 2
a979 1
		       regions_converted, regions_tried );
d987 1
a994 1
		bu_log( "conversion of %s FAILED!!!\n", name );
a1016 1
		bu_free( name, "db_path_to_string" );
a1028 1
	bu_free( name, "db_path_to_string" );
@


1.24.2.4
log
@Now copies BOT (because db_walk_tree frees its copy)
@
text
@d27 1
a27 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.24.2.3 2001/08/16 16:09:20 jra Exp $";
a142 33
struct rt_bot_internal *
dup_bot( struct rt_bot_internal *bot_in )
{
	struct rt_bot_internal *bot;
	int i;

	RT_BOT_CK_MAGIC( bot_in );

	bot = (struct rt_bot_internal *)bu_malloc( sizeof( struct rt_bot_internal ), "dup bot" );

	*bot = *bot_in;	/* struct copy */

	bot->faces = (int *)bu_calloc( bot_in->num_faces*3, sizeof( int ), "bot faces" );
	for( i=0 ; i<bot_in->num_faces*3 ; i++ )
		bot->faces[i] = bot_in->faces[i];

	bot->vertices = (fastf_t *)bu_calloc( bot_in->num_vertices*3, sizeof( fastf_t ), "bot verts" );
	for( i=0 ; i<bot_in->num_vertices*3 ; i++ )
		bot->vertices[i] = bot_in->vertices[i];

	if( bot_in->thickness ) {
		bot->thickness = (fastf_t *)bu_calloc( bot_in->num_faces, sizeof( fastf_t ), "bot thickness" );
		for( i=0 ; i<bot_in->num_faces ; i++ )
			bot->thickness[i] = bot_in->thickness[i];
	}

	if( bot_in->face_mode ) {
		bot->face_mode = bu_bitv_dup( bot_in->face_mode );
	}

	return( bot );
}

d243 1
a243 2
		/* db_walk_tree() will free the BOT, so we need a copy */
		pmp->bots[pmp->num_bots] = dup_bot( bot );
d461 3
a463 2
	bu_log( "Total of %d regions converted of %d regions attempted\n",
		regions_converted, regions_tried );
@


1.23
log
@
Changed from Release 4 function names.
@
text
@d27 1
a27 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.22 2000/03/29 18:07:45 mike Exp $";
a109 6

/* macro to determine if one bounding box is within another */
#define V3RPP1_IN_RPP2( _lo1 , _hi1 , _lo2 , _hi2 )	( \
	(_lo1)[X] >= (_lo2)[X] && (_hi1)[X] <= (_hi2)[X] && \
	(_lo1)[Y] >= (_lo2)[Y] && (_hi1)[Y] <= (_hi2)[Y] && \
	(_lo1)[Z] >= (_lo2)[Z] && (_hi1)[Z] <= (_hi2)[Z] )
@


1.22
log
@
Removed stray RT_EXTERNs, added bn_ prefix.
@
text
@d27 1
a27 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.21 2000/03/03 03:43:54 mike Exp $";
d74 1
a74 1
#define PL_OA(_m)	offsetofarray(struct vrml_mat, _m)
d85 2
a86 2
	{"%d",  1, "w",         	PL_O(tx_w),             FUNC_NULL },
	{"%d",  1, "n",         	PL_O(tx_n),             FUNC_NULL },
d103 1
a103 1
static struct rt_tol		tol;
d138 1
a138 1
		rt_log( "Cannot internal form of %s\n", dp->d_namep );
d203 1
a203 1
	tol.magic = RT_TOL_MAGIC;
d216 1
a216 1
	RT_LIST_INIT( &rt_g.rtg_vlfree );	/* for vlist macros */
d268 1
a268 1
		rt_log( "Cannot open %s\n" , argv[optind] );
d280 1
a280 1
			rt_log( "Cannot open %s\n" , out_file );
d313 1
a313 1
			rt_log( "Cannot find %s\n", argv[i] );
d354 1
a354 1
	rt_vlist_cleanup();
d361 1
a361 1
	rt_prmem("After complete G-NMG conversion");
d375 1
a375 1
	struct nmg_ptbl verts;
d408 1
a408 1
		rt_log( "Cannot internal form of %s\n", dp->d_namep );
d508 1
a508 1
				rt_log( "Cannot open texture file (%s)\n", mat.tx_file );
d569 1
a569 1
		for( RT_LIST_FOR( reg, nmgregion, &m->r_hd ) )
d574 2
a575 2
			s = RT_LIST_FIRST( shell, &reg->s_hd );
			while( RT_LIST_NOT_HEAD( s, &reg->s_hd ) )
d581 3
a583 3
				next_s = RT_LIST_PNEXT( shell, &s->l );
				fu = RT_LIST_FIRST( faceuse, &s->fu_hd );
				while( RT_LIST_NOT_HEAD( &fu->l, &s->fu_hd ) )
d592 1
a592 1
					next_fu = RT_LIST_PNEXT( faceuse, &fu->l );
d601 1
a601 1
					for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
d609 1
a609 1
							if( RT_SETJUMP )
d611 2
a612 2
								RT_UNSETJUMP;
								rt_log( "A face has failed triangulation!!!!\n" );
d614 1
a614 1
									next_fu = RT_LIST_PNEXT( faceuse, &next_fu->l );
d624 1
a624 1
							RT_UNSETJUMP;
d651 1
a651 1
	for( i=0 ; i<NMG_TBL_END( &verts ) ; i++ )
d657 1
a657 1
		v = (struct vertex *)NMG_TBL_GET( &verts, i );
d683 1
a683 1
		one_over_count = 1.0/(fastf_t)NMG_TBL_END( &verts );
d691 1
a691 1
		for( RT_LIST_FOR( reg, nmgregion, &m->r_hd ) )
d696 1
a696 1
			for( RT_LIST_FOR( s, shell, &reg->s_hd ) )
d701 1
a701 1
				for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )
d710 1
a710 1
					for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
d716 1
a716 1
						if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d725 1
a725 1
						for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d733 1
a733 1
							fprintf( fp, " %d,", nmg_tbl( &verts, TBL_LOC, (long *)v ) );
d782 1
a782 1
	struct rt_list		vhead;
d786 1
a786 1
	RT_CK_TOL(tsp->ts_tol);
d789 1
a789 1
	RT_LIST_INIT(&vhead);
d793 1
a793 1
		rt_log("\ndo_region_end(%d %d%%) %s\n",
d797 1
a797 1
		rt_free(sofar, "path string");
d807 1
a807 1
	if( RT_SETJUMP )
d810 1
a810 1
		RT_UNSETJUMP;		/* Relinquish the protection */
d830 1
a830 1
			rt_log("WARNING: tsp->ts_m pointer corrupted, ignoring it.\n");
d844 1
a844 1
	RT_UNSETJUMP;		/* Relinquish the protection */
d853 2
a854 2
		s = RT_LIST_FIRST( shell, &r->s_hd );
		while( RT_LIST_NOT_HEAD( &s->l, &r->s_hd ) )
d858 1
a858 1
			next_s = RT_LIST_PNEXT( shell, &s->l );
d900 1
a900 1
	GETUNION(curtree, tree);
@


1.21
log
@
Made function args match prototypes.
@
text
@d27 1
a27 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.20 2000/01/04 17:58:19 bparker Exp $";
d91 1
a91 2
RT_EXTERN(union tree *do_region_end, (struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data));
RT_EXTERN( struct face *nmg_find_top_face , (struct shell *s , long *flags ));
@


1.20
log
@*- add client_data to db_walk_tree
@
text
@d27 1
a27 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.19 1999/12/30 18:43:43 jra Exp $";
d119 1
a119 1
select_lights( tsp, pathp, curtree, client_data )
d122 1
a122 1
union tree			*curtree;
d166 1
a166 1
select_non_lights( tsp, pathp, curtree, client_data )
d169 1
a169 1
union tree			*curtree;
d172 1
a172 1
	return( !select_lights( tsp, pathp, curtree ) );
@


1.19
log
@Eliminated some unused variables
@
text
@d27 1
a27 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.18 1999/12/29 23:23:01 mike Exp $";
d91 1
a91 1
RT_EXTERN(union tree *do_region_end, (struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree));
d119 1
a119 1
select_lights( tsp, pathp, curtree )
d123 1
d166 1
a166 1
select_non_lights( tsp, pathp, curtree )
d170 1
d330 2
a331 1
			nmg_booltree_leaf_tess);	/* in librt/nmg_bool.c */
d349 2
a350 1
		nmg_booltree_leaf_tess);	/* in librt/nmg_bool.c */
d775 1
a775 1
union tree *do_region_end(tsp, pathp, curtree)
d779 1
@


1.18
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d27 1
a27 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.17 1999/09/21 19:44:29 jra Exp $";
d99 1
a99 2
static int	ncpu = 1;		/* Number of processors */
static int	nmg_count=0;		/* Count of nmgregions written to output */
a182 1
	double		percent;
d242 1
a242 1
			ncpu = atoi( optarg );
a380 1
	fastf_t pt_count=0.0;
a500 1
			int buf_start=0;
a843 3
		char nmg_name[16];
		unsigned char rgb[3];
		struct wmember headp;
@


1.17
log
@Modified July 1999 by John P. Williams, QUADRA Enterprises to output VRML2 format
@
text
@d27 1
a27 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.15 1999/05/13 13:04:07 jra Exp $";
d273 1
a273 1
	db_scan(dbip, (int (*)())db_diradd, 1);
@


1.16
log
@
sed4
@
text
@d2 1
a2 1
 *			G - V R M L . C
d4 1
a4 1
 *  Program to convert a BRL-CAD model (in a .g file) to a VRML  facetted model
d9 2
d74 1
a74 1
#define PL_OA(_m)	bu_offsetofarray(struct vrml_mat, _m)
d85 2
a86 2
	{"%d",  1, "w",         	PL_O(tx_w),             BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "n",         	PL_O(tx_n),             BU_STRUCTPARSE_FUNC_NULL },
d105 1
a105 1
static struct bn_tol		tol;
d139 1
a139 1
		bu_log( "Cannot internal form of %s\n", dp->d_namep );
d204 1
a204 1
	tol.magic = BN_TOL_MAGIC;
d217 1
a217 1
	BU_LIST_INIT( &rt_g.rtg_vlfree );	/* for vlist macros */
d269 1
a269 1
		bu_log( "Cannot open %s\n" , argv[optind] );
d281 1
a281 1
			bu_log( "Cannot open %s\n" , out_file );
d287 17
a303 5
	fprintf( fp_out, "#VRML V1.0 ascii\n" );
	fprintf( fp_out, "ShapeHints {\n" );
	fprintf( fp_out, "\tvertexOrdering	COUNTERCLOCKWISE\n" );
	fprintf( fp_out, "\tshapeType		SOLID\n" );
	fprintf( fp_out, "\tfaceType		UNKNOWN_FACE_TYPE\n\t}\n" );
d314 1
a314 1
			bu_log( "Cannot find %s\n", argv[i] );
d318 2
d334 8
d353 1
a353 1
	bn_vlist_cleanup();
d356 3
d360 1
a360 1
	bu_prmem("After complete G-NMG conversion");
d374 1
a374 1
	struct bu_ptbl verts;
d385 9
d399 27
d468 4
a471 5
		fprintf( fp, "Separator { # start of %s\n", full_path );
		fprintf( fp, "\tMaterial {\n" );
		fprintf( fp, "\t\tdiffuseColor %g %g %g \n", r, g, b );
		fprintf( fp, "\t\tambientColor %g %g %g \n", r, g, b );
		fprintf( fp, "\t\tshininess %g\n", 1.0-exp(-(double)mat.shininess/20.0 ) );
d473 2
a474 2
			fprintf( fp, "\t\ttransparency %g\n", mat.transparency );
		fprintf( fp, "\t\tspecularColor %g %g %g }\n", 1.0, 1.0, 1.0 );
d483 4
a486 5
		fprintf( fp, "Separator { # start of %s\n", full_path );
		fprintf( fp, "\tMaterial {\n" );
		fprintf( fp, "\t\tdiffuseColor %g %g %g \n", r, g, b );
		fprintf( fp, "\t\tambientColor %g %g %g \n", r, g, b );
		fprintf( fp, "\t\tshininess %g\n", 1.0-exp(-(double)mat.shininess/20.0 ) );
d488 2
a489 2
			fprintf( fp, "\t\ttransparency %g\n", mat.transparency );
		fprintf( fp, "\t\tspecularColor %g %g %g }\n", 1.0, 1.0, 1.0 );
a497 1
		fprintf( fp, "Separator { # start of %s\n", full_path );
d509 1
a509 1
				bu_log( "Cannot open texture file (%s)\n", mat.tx_file );
d514 7
a520 7
				fprintf( fp, "\tTexture2Transform {\n" );
				fprintf( fp, "\t\tscaleFactor 1.33333 1.33333\n" );
				fprintf( fp, "\t\t}\n" );
				fprintf( fp, "\tTexture2 {\n" );
				fprintf( fp, "\t\twrapS REPEAT\n" );
				fprintf( fp, "\t\twrapT REPEAT\n" );
				fprintf( fp, "\t\timage %d %d %d\n", mat.tx_w, mat.tx_n, 3 );
d541 1
a541 1
				fprintf( fp, "\t}\n" );
d547 18
a564 5
		fprintf( fp, "Separator { # start of %s\n", full_path );
		fprintf( fp, "\tMaterial {\n" );
		fprintf( fp, "\t\tdiffuseColor %g %g %g \n", r, g, b );
		fprintf( fp, "\t\tambientColor %g %g %g \n", r, g, b );
		fprintf( fp, "\t\tspecularColor %g %g %g }\n", 1.0, 1.0, 1.0 );
d570 1
a570 1
		for( BU_LIST_FOR( reg, nmgregion, &m->r_hd ) )
d575 2
a576 2
			s = BU_LIST_FIRST( shell, &reg->s_hd );
			while( BU_LIST_NOT_HEAD( s, &reg->s_hd ) )
d582 3
a584 3
				next_s = BU_LIST_PNEXT( shell, &s->l );
				fu = BU_LIST_FIRST( faceuse, &s->fu_hd );
				while( BU_LIST_NOT_HEAD( &fu->l, &s->fu_hd ) )
d593 1
a593 1
					next_fu = BU_LIST_PNEXT( faceuse, &fu->l );
d602 1
a602 1
					for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
d610 1
a610 1
							if( BU_SETJUMP )
d612 2
a613 2
								BU_UNSETJUMP;
								bu_log( "A face has failed triangulation!!!!\n" );
d615 1
a615 1
									next_fu = BU_LIST_PNEXT( faceuse, &next_fu->l );
d625 1
a625 1
							BU_UNSETJUMP;
d639 4
d646 1
a646 1
		fprintf( fp, "\tCoordinate3 {\n\t\tpoint [" );
d652 1
a652 1
	for( i=0 ; i<BU_PTBL_END( &verts ) ; i++ )
d658 1
a658 1
		v = (struct vertex *)BU_PTBL_GET( &verts, i );
d676 1
a676 1
				fprintf( fp, "\t\t\t%10.10e %10.10e %10.10e, # point %d\n", V3ARGS( pt_meters ), i );
d679 1
a679 1
		fprintf( fp, "\t\t\t]\n\t\t}\n" );
d684 1
a684 1
		one_over_count = 1.0/(fastf_t)BU_PTBL_END( &verts );
d691 2
a692 2
		fprintf( fp, "\tIndexedFaceSet {\n\t\tcoordIndex [\n" );
		for( BU_LIST_FOR( reg, nmgregion, &m->r_hd ) )
d697 1
a697 1
			for( BU_LIST_FOR( s, shell, &reg->s_hd ) )
d702 1
a702 1
				for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
d711 1
a711 1
					for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
d717 1
a717 1
						if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d725 2
a726 2
						fprintf( fp, "\t\t\t" );
						for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d734 1
a734 1
							fprintf( fp, " %d,", bu_ptbl_locate( &verts, (long *)v ) );
d741 4
a744 1
		fprintf( fp, " ]\n\t}\n}\n" );
d782 1
a782 1
	struct bu_list		vhead;
d786 1
a786 1
	BN_CK_TOL(tsp->ts_tol);
d789 1
a789 1
	BU_LIST_INIT(&vhead);
d793 1
a793 1
		bu_log("\ndo_region_end(%d %d%%) %s\n",
d797 1
a797 1
		bu_free(sofar, "path string");
d807 1
a807 1
	if( BU_SETJUMP )
d810 1
a810 1
		BU_UNSETJUMP;		/* Relinquish the protection */
d830 1
a830 1
			bu_log("WARNING: tsp->ts_m pointer corrupted, ignoring it.\n");
d844 1
a844 1
	BU_UNSETJUMP;		/* Relinquish the protection */
d856 2
a857 2
		s = BU_LIST_FIRST( shell, &r->s_hd );
		while( BU_LIST_NOT_HEAD( &s->l, &r->s_hd ) )
d861 1
a861 1
			next_s = BU_LIST_PNEXT( shell, &s->l );
d903 1
a903 1
	BU_GETUNION(curtree, tree);
@


1.15
log
@default setting of verbose   flag was missing.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.14 1999/05/10 21:46:34 mike Exp $";
d72 1
a72 1
#define PL_OA(_m)	offsetofarray(struct vrml_mat, _m)
d83 2
a84 2
	{"%d",  1, "w",         	PL_O(tx_w),             FUNC_NULL },
	{"%d",  1, "n",         	PL_O(tx_n),             FUNC_NULL },
d103 1
a103 1
static struct rt_tol		tol;
d137 1
a137 1
		rt_log( "Cannot internal form of %s\n", dp->d_namep );
d202 1
a202 1
	tol.magic = RT_TOL_MAGIC;
d215 1
a215 1
	RT_LIST_INIT( &rt_g.rtg_vlfree );	/* for vlist macros */
d267 1
a267 1
		rt_log( "Cannot open %s\n" , argv[optind] );
d279 1
a279 1
			rt_log( "Cannot open %s\n" , out_file );
d300 1
a300 1
			rt_log( "Cannot find %s\n", argv[i] );
d329 1
a329 1
	rt_vlist_cleanup();
d333 1
a333 1
	rt_prmem("After complete G-NMG conversion");
d347 1
a347 1
	struct nmg_ptbl verts;
d449 1
a449 1
				rt_log( "Cannot open texture file (%s)\n", mat.tx_file );
d497 1
a497 1
		for( RT_LIST_FOR( reg, nmgregion, &m->r_hd ) )
d502 2
a503 2
			s = RT_LIST_FIRST( shell, &reg->s_hd );
			while( RT_LIST_NOT_HEAD( s, &reg->s_hd ) )
d509 3
a511 3
				next_s = RT_LIST_PNEXT( shell, &s->l );
				fu = RT_LIST_FIRST( faceuse, &s->fu_hd );
				while( RT_LIST_NOT_HEAD( &fu->l, &s->fu_hd ) )
d520 1
a520 1
					next_fu = RT_LIST_PNEXT( faceuse, &fu->l );
d529 1
a529 1
					for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
d537 1
a537 1
							if( RT_SETJUMP )
d539 2
a540 2
								RT_UNSETJUMP;
								rt_log( "A face has failed triangulation!!!!\n" );
d542 1
a542 1
									next_fu = RT_LIST_PNEXT( faceuse, &next_fu->l );
d552 1
a552 1
							RT_UNSETJUMP;
d575 1
a575 1
	for( i=0 ; i<NMG_TBL_END( &verts ) ; i++ )
d581 1
a581 1
		v = (struct vertex *)NMG_TBL_GET( &verts, i );
d607 1
a607 1
		one_over_count = 1.0/(fastf_t)NMG_TBL_END( &verts );
d615 1
a615 1
		for( RT_LIST_FOR( reg, nmgregion, &m->r_hd ) )
d620 1
a620 1
			for( RT_LIST_FOR( s, shell, &reg->s_hd ) )
d625 1
a625 1
				for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )
d634 1
a634 1
					for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
d640 1
a640 1
						if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d649 1
a649 1
						for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d657 1
a657 1
							fprintf( fp, " %d,", nmg_tbl( &verts, TBL_LOC, (long *)v ) );
d702 1
a702 1
	struct rt_list		vhead;
d706 1
a706 1
	RT_CK_TOL(tsp->ts_tol);
d709 1
a709 1
	RT_LIST_INIT(&vhead);
d713 1
a713 1
		rt_log("\ndo_region_end(%d %d%%) %s\n",
d717 1
a717 1
		rt_free(sofar, "path string");
d727 1
a727 1
	if( RT_SETJUMP )
d730 1
a730 1
		RT_UNSETJUMP;		/* Relinquish the protection */
d750 1
a750 1
			rt_log("WARNING: tsp->ts_m pointer corrupted, ignoring it.\n");
d764 1
a764 1
	RT_UNSETJUMP;		/* Relinquish the protection */
d776 2
a777 2
		s = RT_LIST_FIRST( shell, &r->s_hd );
		while( RT_LIST_NOT_HEAD( &s->l, &r->s_hd ) )
d781 1
a781 1
			next_s = RT_LIST_PNEXT( shell, &s->l );
d823 1
a823 1
	GETUNION(curtree, tree);
@


1.14
log
@ma_override to ma_color_valid
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.13 1999/01/27 13:35:39 jra Exp $";
d96 1
a96 1
static int	verbose;
@


1.13
log
@Corrected usage output.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/g-vrml.c,v 1.12 1998/05/13 13:22:11 jra Exp $";
d363 1
a363 1
	if( mater->ma_override )
@


1.12
log
@surface normal tolerance is now in degrees.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-vrml.c,v 1.11 1997/07/11 15:03:01 jra Exp jra $";
d92 1
a92 1
static char	usage[] = "Usage: %s [-v] [-i] [-xX lvl] [-d tolerance_distance (mm) ] [-a abs_tol (mm)] [-r rel_tol] [-n norm_tol] [-o out_file] brlcad_db.g object(s)\n";
@


1.11
log
@Added some logging messages.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-vrml.c,v 1.10 1997/03/05 19:57:20 jra Exp jra $";
d229 1
a229 1
			ttol.norm = atof(optarg);
@


1.10
log
@converted to use combination import/export.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-vrml.c,v 1.9 1996/12/20 17:48:06 jra Exp jra $";
d723 2
d810 3
@


1.9
log
@Mods for new mater_info structure.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-vrml.c,v 1.8 1996/12/04 04:02:04 mike Exp jra $";
a43 1
#include "db.h"
d124 3
a126 1
	union record rec;
d134 2
a135 1
	if( db_get( dbip, dp, &rec, 0, 1 ) < 0 )
d137 1
a137 1
		rt_log( "Cannot get header record for %s\n", dp->d_namep );
d141 13
a153 1
	if( !strcmp( rec.c.c_matname, "light" ) )
d155 1
d157 2
d160 1
d169 1
a169 19
	struct directory *dp;
	union record rec;

	RT_CK_FULL_PATH( pathp );
	dp = DB_FULL_PATH_CUR_DIR( pathp );

	if( !(dp->d_flags & DIR_COMB) )
		return( 0 );

	if( db_get( dbip, dp, &rec, 0, 1 ) < 0 )
	{
		rt_log( "Cannot get header record for %s\n", dp->d_namep );
		return( -1 );
	}

	if( !strcmp( rec.c.c_matname, "light" ) )
		return( -1 );
	else
		return( 0 );
d374 7
a380 2
	tok = strtok( mater->ma_shader, tok_sep );
	strcpy( mat.shader, tok );
@


1.8
log
@half a fix
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-vrml.c,v 1.7 1996/08/31 08:53:05 butler Exp mike $";
d52 3
d56 2
a59 1
};
d61 1
a61 1
struct vrml_light {
a64 1
};
d66 1
a66 3
#define TXT_BUF_LEN	512
#define TXT_NAME_LEN	128
struct vrml_texture {
d72 2
a73 4
#define LIGHT_O(m)	offsetof(struct vrml_light, m)
#define LIGHT_OA(m)	offsetofarray(struct vrml_light, m)

#define PL_O(m)	offsetof(struct vrml_mat, m)
a74 2
#define TX_O(m) offsetof(struct vrml_texture, m)

d76 1
d81 6
a89 14
struct bu_structparse vrml_light_parse[] = {
	{"%f",	1, "angle",	LIGHT_O(lt_angle),	FUNC_NULL },
	{"%f",	1, "fract",	LIGHT_O(lt_fraction),	FUNC_NULL },
	{"%f",	3, "aim",	LIGHT_OA(lt_dir),	FUNC_NULL },
	{"",	0, (char *)0,	0,			FUNC_NULL }
};

struct bu_structparse vrml_texture_parse[] = {
	{"%d",  1, "w",         TX_O(tx_w),             FUNC_NULL },
	{"%d",  1, "n",         TX_O(tx_n),             FUNC_NULL },
	{"%s",  TXT_NAME_LEN, "file", offsetofarray(struct vrml_texture, tx_file), FUNC_NULL },
	{"",	0, (char *)0,	0,			FUNC_NULL }
};

d95 1
d348 3
d374 15
a388 1
	if( strncmp( "light", mater->ma_shader, 5 ) == 0 )
d392 2
a393 2
		}
	else if( strcmp( "plastic", mater->ma_shader, 7 ) == 0 )
d395 4
a398 5
		struct vrml_mat mat;
		struct rt_vls vls;

		mat.shininess = 10;
		mat.transparency = 0.0;
a399 7
		if( strlen( mater->ma_matparm ) )
		{
			rt_vls_init( &vls );
			rt_vls_strcpy( &vls, mater->ma_matparm );
			(void)bu_struct_parse( &vls, vrml_mat_parse, (char *)&mat );
			rt_vls_free( &vls );
		}
d409 1
a409 1
	else if( strncmp( "glass", mater->ma_shader, 5 ) == 0 )
d411 4
a414 2
		struct vrml_mat mat;
		struct rt_vls vls;
a415 10
		mat.shininess = 4;
		mat.transparency = 0.8;

		if( strlen( mater->ma_matparm ) )
		{
			rt_vls_init( &vls );
			rt_vls_strcpy( &vls, mater->ma_matparm );
			(void)bu_struct_parse( &vls, vrml_mat_parse, (char *)&mat );
			rt_vls_free( &vls );
		}
d425 1
a425 1
	else if( strncmp( "texture", mater->ma_shader, 7 ) == 0 )
d427 4
a430 6
		struct vrml_texture tex;
		struct rt_vls vls;

		tex.tx_file[0] = '\0';
		tex.tx_w = (-1);
		tex.tx_n = (-1);
a431 14
		if( strlen( mater->ma_matparm ) )
		{
			rt_vls_init( &vls );
			rt_vls_strcpy( &vls, mater->ma_matparm );
			bzero( tex.tx_file, TXT_NAME_LEN );
			(void)bu_struct_parse( &vls, vrml_texture_parse, (char *)&tex );
			rt_vls_free( &vls );
		}

		if( tex.tx_w < 0 )
			tex.tx_w = 512;
		if( tex.tx_n < 0 )
			tex.tx_n = 512;

d433 1
a433 1
		if( strlen( tex.tx_file ) )
d442 1
a442 1
			if( (tex_fd = open( tex.tx_file, O_RDONLY )) == (-1) )
d444 1
a444 1
				rt_log( "Cannot open texture file (%s)\n", tex.tx_file );
d455 2
a456 2
				fprintf( fp, "\t\timage %d %d %d\n", tex.tx_w, tex.tx_n, 3 );
				tex_len = tex.tx_w*tex.tx_n*3;
d663 3
a665 13
		struct vrml_light v_light;
		struct rt_vls vls;

		v_light.lt_fraction = 0.0;
		v_light.lt_angle = 180.0;
		VSETALL( v_light.lt_dir, 0.0 );
		if( strlen( mater->ma_matparm ) )
		{
			rt_vls_init( &vls );
			rt_vls_strcpy( &vls, mater->ma_matparm );
			(void)bu_struct_parse( &vls, vrml_light_parse, (char *)&v_light );
			rt_vls_free( &vls );
		}
d667 1
a667 1
		if( v_light.lt_dir[X] != 0.0 || v_light.lt_dir[Y] != 0.0 ||v_light.lt_dir[Z] != 0.0 )
d671 2
a672 2
			if( v_light.lt_fraction > 0.0 )
				fprintf( fp, "\tintensity \t%g\n", v_light.lt_fraction );
d675 2
a676 2
			fprintf( fp, "\tdirection \t%g %g %g\n", V3ARGS( v_light.lt_dir ) );
			fprintf( fp, "\tcutOffAngle \t%g }\n", v_light.lt_angle );
@


1.7
log
@struct_parse
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-vrml.c,v 1.6 1996/08/29 23:09:18 butler Exp butler $";
d380 1
a380 1
	if( strcmp( "light", mater->ma_matname ) == 0 )
d385 1
a385 1
	else if( strcmp( "plastic", mater->ma_matname ) == 0 )
d409 1
a409 1
	else if( strcmp( "glass", mater->ma_matname ) == 0 )
d433 1
a433 1
	else if( strcmp( "texture", mater->ma_matname ) == 0 )
@


1.6
log
@structparse moved to libbu
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-vrml.c,v 1.5 1996/08/29 23:05:24 butler Exp butler $";
d397 1
a397 1
			(void)bu_structparse( &vls, vrml_mat_parse, (char *)&mat );
d421 1
a421 1
			(void)bu_structparse( &vls, vrml_mat_parse, (char *)&mat );
d447 1
a447 1
			(void)bu_structparse( &vls, vrml_texture_parse, (char *)&tex );
d697 1
a697 1
			(void)bu_structparse( &vls, vrml_light_parse, (char *)&v_light );
@


1.5
log
@structparse moved to libbu
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-vrml.c,v 1.4 1996/08/02 12:46:58 jra Exp butler $";
d47 1
@


1.4
log
@Corrected handling of tessellation tolerances options.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-vrml.c,v 1.3 1996/07/12 13:20:17 jra Exp jra $";
d77 1
a77 1
struct structparse vrml_mat_parse[]={
d85 1
a85 1
struct structparse vrml_light_parse[] = {
d92 1
a92 1
struct structparse vrml_texture_parse[] = {
d396 1
a396 1
			(void)rt_structparse( &vls, vrml_mat_parse, (char *)&mat );
d420 1
a420 1
			(void)rt_structparse( &vls, vrml_mat_parse, (char *)&mat );
d446 1
a446 1
			(void)rt_structparse( &vls, vrml_texture_parse, (char *)&tex );
d696 1
a696 1
			(void)rt_structparse( &vls, vrml_light_parse, (char *)&v_light );
@


1.3
log
@Minor MOds for IRIX 6.2
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-vrml.c,v 1.2 1995/08/24 13:34:14 jra Exp $";
d230 1
d238 1
@


1.2
log
@Added textures.
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-vrml.c,v 1.1 1995/08/16 20:58:06 jra Exp jra $";
d102 1
a102 1
static char	usage[] = "Usage: %s [-v] [-i] [-xX lvl] [-a abs_tol] [-r rel_tol] [-n norm_tol] [-o out_file] brlcad_db.g object(s)\n";
d147 3
a149 1
	if( strcmp( rec.c.c_matname, "light" ) )
a150 2
	else
		return( 0 );
d174 3
a176 1
	if( strcmp( rec.c.c_matname, "light" ) )
a177 2
	else
		return( -1 );
d226 1
a226 1
	while ((c = getopt(argc, argv, "a:n:o:r:vx:P:X:")) != EOF) {
d231 4
d299 22
a320 7
	/* walk trees selecting only light source regions */
	(void)db_walk_tree(dbip, argc-optind, (CONST char **)(&argv[optind]),
		1,				/* ncpu */
		&tree_state,
		select_lights,
		do_region_end,
		nmg_booltree_leaf_tess);	/* in librt/nmg_bool.c */
d323 1
a331 1

d346 1
a346 1
nmg_2_vrml( fp, dp, m )
d348 1
a348 1
struct directory *dp;
d350 1
a356 1
	union record rec;
d360 1
d364 9
a372 1
	if( dp->d_flags & DIR_COMB )
d374 2
d377 9
a385 4
		if( db_get( dbip, dp, &rec, 0, 1 ) < 0 )
			rt_log( "Cannot get header record for %s\n" , dp->d_namep );
		else
		{
d387 2
a388 3
			r = (float)rec.c.c_rgb[0]/255.0;
			g = (float)rec.c.c_rgb[1]/255.0;
			b = (float)rec.c.c_rgb[2]/255.0;
d390 20
a409 10
			if( strcmp( "light", rec.c.c_matname ) == 0 )
			{
				/* this is a light source */
				is_light = 1;
				}
			else if( strcmp( "plastic", rec.c.c_matname ) == 0 ||
				 strcmp( "glass", rec.c.c_matname ) == 0 )
			{
				struct vrml_mat mat;
				struct rt_vls vls;
d411 2
a412 2
				mat.shininess = 10;
				mat.transparency = 0.0;
d414 20
a433 20
				if( strlen( rec.c.c_matparm ) )
				{
					rt_vls_init( &vls );
					rt_vls_strcpy( &vls, rec.c.c_matparm );
					(void)rt_structparse( &vls, vrml_mat_parse, (char *)&mat );
					rt_vls_free( &vls );
				}
				fprintf( fp, "Separator { # start of %s\n", dp->d_namep );
				fprintf( fp, "\tMaterial {\n" );
				fprintf( fp, "\t\tdiffuseColor %g %g %g \n", r, g, b );
				fprintf( fp, "\t\tambientColor %g %g %g \n", r, g, b );
				fprintf( fp, "\t\tshininess %g\n", 1.0-exp(-(double)mat.shininess/20.0 ) );
				if( mat.transparency > 0.0 )
					fprintf( fp, "\t\ttransparency %g\n", mat.transparency );
				fprintf( fp, "\t\tspecularColor %g %g %g }\n", 1.0, 1.0, 1.0 );
			}
			else if( strcmp( "texture", rec.c.c_matname ) == 0 )
			{
				struct vrml_texture tex;
				struct rt_vls vls;
d435 3
a437 3
				tex.tx_file[0] = '\0';
				tex.tx_w = 0;
				tex.tx_n = 0;
d439 8
a446 8
				if( strlen( rec.c.c_matparm ) )
				{
					rt_vls_init( &vls );
					rt_vls_strcpy( &vls, rec.c.c_matparm );
					bzero( tex.tx_file, TXT_NAME_LEN );
					(void)rt_structparse( &vls, vrml_texture_parse, (char *)&tex );
					rt_vls_free( &vls );
				}
d448 14
a461 9
				fprintf( fp, "Separator { # start of %s\n", dp->d_namep );
				if( strlen( tex.tx_file ) )
				{
					int tex_fd;
					int nbytes;
					long tex_len;
					long bytes_read=0;
					int buf_start=0;
					unsigned char tex_buf[TXT_BUF_LEN*3];
d463 4
a466 34
					if( (tex_fd = open( tex.tx_file, O_RDONLY )) == (-1) )
					{
						rt_log( "Cannot open texture file (%s)\n", tex.tx_file );
						perror( "g-vrml: " );
					}
					else
					{
						fprintf( fp, "\tTexture2 {\n" );
						fprintf( fp, "\t\twrapS REPEAT\n" );
						fprintf( fp, "\t\twrapT REPEAT\n" );
						fprintf( fp, "\t\timage %d %d %d\n", tex.tx_w, tex.tx_n, 3 );
						tex_len = tex.tx_w*tex.tx_n*3;
						while( bytes_read < tex_len )
						{
							long bytes_to_go=tex_len;

							bytes_to_go = tex_len - bytes_read;
							if( bytes_to_go > TXT_BUF_LEN*3 )
								bytes_to_go = TXT_BUF_LEN*3;
							nbytes = 0;
							while( nbytes < bytes_to_go )
								nbytes += read( tex_fd, &tex_buf[nbytes],
									bytes_to_go-nbytes );

							bytes_read += nbytes;
							for( i=0 ; i<nbytes ; i += 3 )
								fprintf( fp, "\t\t\t0x%2.2x%2.2x%2.2x\n",
									tex_buf[i],
									tex_buf[i+1],
									tex_buf[i+2] );
						}
						fprintf( fp, "\t}\n" );
					}
				}
d470 28
a497 5
				fprintf( fp, "Separator { # start of %s\n", dp->d_namep );
				fprintf( fp, "\tMaterial {\n" );
				fprintf( fp, "\t\tdiffuseColor %g %g %g \n", r, g, b );
				fprintf( fp, "\t\tambientColor %g %g %g \n", r, g, b );
				fprintf( fp, "\t\tspecularColor %g %g %g }\n", 1.0, 1.0, 1.0 );
d501 8
d518 2
a519 1
			for( RT_LIST_FOR( s, shell, &reg->s_hd ) )
d521 1
d525 3
a527 1
				for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )
d529 1
d531 2
d536 2
d539 2
d542 1
d553 16
a568 1
							nmg_triangulate_fu( fu, &tol );
d573 3
d577 1
d603 1
a603 1
		VSCALE( pt_meters, vg->coord, 1.0/1000.0 );
d610 1
a610 1
				fprintf( fp, " %g %g %g,\n", V3ARGS( pt_meters ) );
d615 1
a615 1
				fprintf( fp, "\t\t\t%g %g %g,\n", V3ARGS( pt_meters ) );
d690 1
a690 1
		if( strlen( rec.c.c_matparm ) )
d693 1
a693 1
			rt_vls_strcpy( &vls, rec.c.c_matparm );
a780 1
	(void)nmg_model_fuse(*tsp->ts_m, tsp->ts_tol);
a824 2
			struct directory *dp;

d826 1
a826 2
			dp = DB_FULL_PATH_CUR_DIR( pathp );
			nmg_2_vrml( fp_out, dp, *tsp->ts_m );
@


1.1
log
@Initial revision
@
text
@d25 1
a25 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/g-nmg.c,v 11.5 1995/04/03 19:48:38 jra Exp $";
d31 3
d62 8
d75 2
d92 7
d102 1
a102 1
static char	usage[] = "Usage: %s [-v] [-xX lvl] [-a abs_tol] [-r rel_tol] [-n norm_tol] [-o out_file] brlcad_db.g object(s)\n";
d361 2
a362 1
			else
d384 71
@
