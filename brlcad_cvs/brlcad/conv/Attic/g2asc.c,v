head	11.47;
access;
symbols
	ansi-20040405-merged:11.38.2.2
	postmerge-20040405-ansi:11.45
	premerge-20040404-ansi:11.44
	postmerge-autoconf:11.44
	autoconf-freeze:11.42.4.3
	premerge-autoconf:11.44
	ansi-20040316-freeze:11.38.2.1
	postmerge-20040315-windows:11.44
	premerge-20040315-windows:11.43
	windows-20040315-freeze:11.38.4.2
	autoconf-20031203:11.42
	autoconf-20031202:11.42
	autoconf-branch:11.42.0.4
	phong-branch:11.42.0.2
	photonmap-branch:11.40.0.2
	rel-6-1-DP:11.38
	windows-branch:11.38.0.4
	rel-6-0-2:11.36
	ansi-branch:11.38.0.2
	rel-6-0-1-branch:11.36.0.2
	hartley-6-0-post:11.37
	hartley-6-0-pre:11.36
	rel-6-0-1:11.36
	rel-6-0:11.36
	rel-5-4:11.13.2.3
	offsite-5-3-pre:11.24
	rel-5-3:11.13.2.3
	rel-5-2:11.13.2.1
	rel-5-1-branch:11.13.0.2
	rel-5-1:11.13
	rel-5-0:11.4
	rel-5-0-beta:11.3
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:1.3;
locks; strict;
comment	@ * @;


11.47
date	2004.05.24.04.16.12;	author morrison;	state dead;
branches;
next	11.46;

11.46
date	2004.05.10.15.30.41;	author erikg;	state Exp;
branches;
next	11.45;

11.45
date	2004.04.05.07.49.36;	author morrison;	state Exp;
branches;
next	11.44;

11.44
date	2004.03.16.13.54.29;	author morrison;	state Exp;
branches;
next	11.43;

11.43
date	2004.02.02.17.39.00;	author morrison;	state Exp;
branches;
next	11.42;

11.42
date	2003.08.05.12.24.33;	author jra;	state Exp;
branches
	11.42.4.1;
next	11.41;

11.41
date	2003.06.20.12.54.35;	author jra;	state Exp;
branches;
next	11.40;

11.40
date	2003.04.03.15.10.47;	author jra;	state Exp;
branches
	11.40.2.1;
next	11.39;

11.39
date	2002.11.27.13.41.40;	author jra;	state Exp;
branches;
next	11.38;

11.38
date	2002.08.20.17.07.22;	author jra;	state Exp;
branches
	11.38.2.1
	11.38.4.1;
next	11.37;

11.37
date	2002.08.15.20.54.34;	author hartley;	state Exp;
branches;
next	11.36;

11.36
date	2002.02.05.03.13.06;	author jra;	state Exp;
branches;
next	11.35;

11.35
date	2001.10.22.17.33.06;	author jra;	state Exp;
branches;
next	11.34;

11.34
date	2001.10.10.15.48.17;	author butler;	state Exp;
branches;
next	11.33;

11.33
date	2001.10.05.15.20.14;	author jra;	state Exp;
branches;
next	11.32;

11.32
date	2001.10.04.20.20.48;	author rbowers;	state Exp;
branches;
next	11.31;

11.31
date	2001.10.04.19.36.09;	author rbowers;	state Exp;
branches;
next	11.30;

11.30
date	2001.10.01.20.02.23;	author jra;	state Exp;
branches;
next	11.29;

11.29
date	2001.08.24.12.36.52;	author jra;	state Exp;
branches;
next	11.28;

11.28
date	2001.07.18.14.41.03;	author jra;	state Exp;
branches;
next	11.27;

11.27
date	2001.07.18.03.25.44;	author jra;	state Exp;
branches;
next	11.26;

11.26
date	2001.06.22.14.40.24;	author jra;	state Exp;
branches;
next	11.25;

11.25
date	2001.04.05.19.34.59;	author morrison;	state Exp;
branches;
next	11.24;

11.24
date	2000.10.31.22.57.30;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	2000.10.30.20.37.39;	author jra;	state Exp;
branches;
next	11.22;

11.22
date	2000.10.30.18.15.07;	author jra;	state Exp;
branches;
next	11.21;

11.21
date	2000.09.08.05.55.42;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	2000.09.05.12.44.03;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	2000.08.29.22.34.51;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	2000.08.25.22.10.06;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	2000.08.25.21.31.59;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	2000.08.09.20.41.29;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	2000.07.12.03.56.40;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	2000.07.10.23.53.58;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	2000.06.19.18.51.56;	author jra;	state Exp;
branches
	11.13.2.1;
next	11.12;

11.12
date	2000.03.16.13.39.11;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	2000.03.04.05.54.40;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	2000.03.02.15.48.25;	author jra;	state Exp;
branches;
next	11.9;

11.9
date	2000.03.02.14.39.40;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	2000.02.02.21.13.03;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	99.12.07.01.01.06;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	99.11.09.15.42.39;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	99.10.12.13.58.11;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	99.06.03.21.54.20;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	98.09.14.15.58.51;	author bparker;	state Exp;
branches;
next	11.2;

11.2
date	95.08.18.19.24.35;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.59.38;	author mike;	state Rel4_4;
branches;
next	10.8;

10.8
date	94.11.05.02.40.16;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.10.17.16.54.31;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.10.16.09.33.15;	author jra;	state Exp;
branches;
next	10.5;

10.5
date	94.10.14.15.43.33;	author jra;	state Exp;
branches;
next	10.4;

10.4
date	94.10.14.13.44.38;	author jra;	state Exp;
branches;
next	10.3;

10.3
date	94.08.11.00.02.39;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	93.07.02.08.59.12;	author stay;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.41.20;	author mike;	state Rel4_0;
branches;
next	9.17;

9.17
date	91.09.30.02.22.42;	author mike;	state Exp;
branches;
next	9.16;

9.16
date	91.09.24.16.59.53;	author butler;	state Exp;
branches;
next	9.15;

9.15
date	91.09.19.15.38.21;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	91.06.12.21.58.15;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	91.06.12.21.24.55;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	91.06.12.21.19.19;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	91.03.05.03.50.55;	author phil;	state Exp;
branches;
next	9.10;

9.10
date	91.02.12.09.30.17;	author sue;	state Exp;
branches;
next	9.9;

9.9
date	91.01.12.08.40.45;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	90.12.07.02.56.59;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.12.07.02.24.24;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.12.05.21.09.25;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.12.05.21.05.33;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.12.05.03.19.48;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.12.05.02.34.20;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.12.05.02.25.56;	author sue;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.46.17;	author mike;	state Rel3_5;
branches;
next	8.2;

8.2
date	89.03.06.17.02.59;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.25.37;	author mike;	state Rel3_0;
branches;
next	7.3;

7.3
date	88.05.13.21.25.52;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.01.27.02.13.10;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.24.10;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.07.49.46;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.21.48.59;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.12.22.02.51;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.02.48.28;	author mike;	state Rel1;
branches;
next	1.14;

1.14
date	86.12.03.18.36.43;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	86.12.03.15.34.37;	author stay;	state Exp;
branches;
next	1.12;

1.12
date	86.11.19.01.07.29;	author kermit;	state Exp;
branches;
next	1.11;

1.11
date	86.08.13.06.25.01;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	86.08.02.04.00.32;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	86.08.02.01.36.41;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	86.07.31.05.10.34;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	86.07.27.17.31.45;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	86.07.27.17.22.20;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	86.06.12.20.26.15;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	86.03.26.01.04.21;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	85.06.03.16.58.58;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	85.03.26.13.36.48;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	85.03.08.21.23.34;	author mike;	state Exp;
branches;
next	;

11.13.2.1
date	2000.09.05.12.45.12;	author jra;	state Exp;
branches;
next	11.13.2.2;

11.13.2.2
date	2000.10.30.18.10.19;	author jra;	state Exp;
branches;
next	11.13.2.3;

11.13.2.3
date	2000.10.30.20.38.26;	author jra;	state Exp;
branches;
next	;

11.38.2.1
date	2002.09.19.18.00.36;	author morrison;	state Exp;
branches;
next	11.38.2.2;

11.38.2.2
date	2004.03.17.21.16.00;	author morrison;	state Exp;
branches;
next	;

11.38.4.1
date	2003.08.14.08.07.24;	author morrison;	state Exp;
branches;
next	11.38.4.2;

11.38.4.2
date	2004.03.11.23.40.31;	author morrison;	state Exp;
branches;
next	;

11.40.2.1
date	2003.08.26.14.03.21;	author justin;	state Exp;
branches;
next	;

11.42.4.1
date	2004.02.12.19.24.23;	author erikg;	state Exp;
branches;
next	11.42.4.2;

11.42.4.2
date	2004.03.15.14.06.08;	author erikg;	state Exp;
branches;
next	11.42.4.3;

11.42.4.3
date	2004.03.18.18.10.24;	author erikg;	state Exp;
branches;
next	;


desc
@Binary to ASCII GED database converter.
@


11.47
log
@moved to src/conv/
@
text
@/*
 *		G 2 A S C . C
 *  
 *  This program generates an ASCII data file which contains
 *  a GED database.
 *
 *  Usage:  g2asc < file.g > file.asc
 *  
 *  Author -
 *  	Charles M Kennedy
 *  	Michael J Muuss
 *	Susanne Muuss, J.D.
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/conv/g2asc.c,v 11.46 2004/05/10 15:30:41 erikg Exp $ (BRL)";
#endif
 
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <ctype.h>
#include "machine.h"
#include "vmath.h"
#include "externs.h"
#include "db.h"
#include "raytrace.h"
#include "wdb.h"
#include "rtgeom.h"
#include "tcl.h"
#ifndef WIN32
#include <fcntl.h>
#endif

const mat_t	id_mat = {
	1.0, 0.0, 0.0, 0.0,
	0.0, 1.0, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.0, 0.0, 0.0, 1.0};	/* identity matrix for pipes */

char *name(char *str);
char *strchop(char *str, int len);
#define CH(x)	strchop(x,sizeof(x))

int	combdump(void);
void	idendump(void), polyhead(void), polydata(void);
void	soldump(void), extrdump(void), sketchdump(void);
void	membdump(union record *rp), arsadump(void), arsbdump(void);
void	materdump(void), bspldump(void), bsurfdump(void);
void	pipe_dump(void), particle_dump(void), dump_pipe_segs(char *name, struct bu_list *headp);
void	arbn_dump(void), cline_dump(void), bot_dump(void);
void	nmg_dump(void);
void	strsol_dump(void);

union record	record;		/* GED database record */

static char usage[] = "\
Usage: g2asc < file.g > file.asc\n\
   or  g2asc file.g file.asc\n\
 Convert a binary BRL-CAD database to machine-independent ASCII form\n\
";

FILE	*ifp;
FILE	*ofp;
char	*iname = "-";

static char *tclified_name=NULL;
static int tclified_name_buffer_len=0;


/*	This routine escapes the '{' and '}' characters in any string and returns a static buffer containing the
 *	resulting string. Used for names and db title on output.
 *
 *	NOTE: RETURN OF STATIC BUFFER
 */
char *
tclify_name( const char *name )
{
	const char *src=name;
	char *dest;

	int max_len=2*strlen( name ) + 1;

	if( max_len < 2 ) {
		return( (char *)NULL );
	}

	if( max_len > tclified_name_buffer_len ) {
		tclified_name_buffer_len = max_len;
		tclified_name = bu_realloc( tclified_name, tclified_name_buffer_len, "tclified_name buffer" );
	}

	dest = tclified_name;

	while( *src ) {
		if( *src == '{' || *src == '}' ) {
			*dest++ = '\\';
		}
		*dest++ = *src++;
	}
	*dest = '\0';

	return( tclified_name );
}

int
main(int argc, char **argv)
{
	int i;

#ifdef WIN32
	_fmode = _O_BINARY;
#endif

	iname = "-";
#ifdef WIN32
	ifp = fopen(iname, "r");
#else
	ifp = stdin;
#endif
	ofp = stdout;

	bu_debug = BU_DEBUG_COREDUMP;

#if 0
	if( argc > 1 && strcmp( argv[1], "-d" ) == 0 )  {
		argc--; argv++;
		debug = 1;
	}
#endif

	if( argc >= 3 ) {
		iname = argv[1];
		if( strcmp(iname, "-") == 0 )  {
			ifp = stdin;
		} else {
			ifp = fopen(iname,"r");
		}
		if( !ifp )  perror(iname);
		if( strcmp(argv[2], "-") == 0 )  {
			ofp = stdout;
		} else {
			ofp = fopen(argv[2],"w");
		}
		if( !ofp )  perror(argv[2]);
		if (ifp == NULL || ofp == NULL) {
			(void)fprintf(stderr, "g2asc: can't open files.");
			exit(1);
		}
	}
	if (isatty(fileno(ifp))) {
		(void)fprintf(stderr, usage);
		exit(1);
	}

	rt_init_resource( &rt_uniresource, 0, NULL );

	/* First, determine what version database this is */
	if( fread( (char *)&record, sizeof record, 1, ifp ) != 1 )  {
		bu_log("g2asc(%s) ERROR, file too short to be BRL-CAD database\n",
			iname);
		exit(2);
	}

	if( db5_header_is_valid( (unsigned char *)&record ) )  {
		Tcl_Interp	*interp;
		struct db_i	*dbip;
		struct directory *dp;

		if( ifp == stdin || ofp == stdout ) {
			bu_log( "Cannot use stdin or stdout for Release 6 or later databases\n");
			bu_log( "Please use the \"g2asc input.g output.g\" form\n" );
			exit( 1 );
		}

		bu_log("Exporting Release 6 database\n" );
		bu_log("  Note that the Release 6 binary format is machine independent.\n");
		bu_log("  Converting to ASCII to move database to a different\n");
		bu_log("  computer architecture is no longer necessary.\n");
		interp = Tcl_CreateInterp();
		/* This runs the init.tcl script */
		if( Tcl_Init(interp) == TCL_ERROR )
			bu_log("Tcl_Init error %s\n", interp->result);

		if( (dbip = db_open( iname, "rb" )) == NULL )  {
			bu_log("Unable to db_open() file '%s', aborting\n", iname );
			exit(4);
		}
		RT_CK_DBI(dbip);
		db_dirbuild( dbip );
		if( dbip->dbi_title[0] ) {
			fprintf( ofp, "title {%s}\n", tclify_name( dbip->dbi_title ) );
		} else {
			fprintf( ofp, "title {Untitled BRL-CAD Database}\n" );
		}
		fprintf( ofp, "units %s\n", bu_units_string( dbip->dbi_local2base ) );
		FOR_ALL_DIRECTORY_START(dp, dbip)  {
			struct rt_db_internal	intern;
			struct bu_attribute_value_set *avs=NULL;

			/* Skip GLOBAL object */
			if( dp->d_major_type == 2 && dp->d_minor_type == 0 ) {
				const char *value;
				Tcl_Obj	*list, *obj;
				int list_len;
				struct bu_attribute_value_set g_avs;

				/* get region colortable */
				if( db5_get_attributes( dbip, &g_avs, dp ) ) {
					bu_log( "Failed to get attributes of _GLOBAL!!\n" );
					continue;
				}
				value = bu_avs_get( &g_avs, "regionid_colortable" );
				if( !value )
					continue;
				list = Tcl_NewStringObj( value, -1);
				if( Tcl_ListObjLength( interp, list, &list_len ) != TCL_OK ) {
					bu_log( "Failed to get length of region color table!!\n" );
					continue;
				}
				for( i=0 ; i<list_len ; i++ ) {
					if( Tcl_ListObjIndex( interp, list, i, &obj ) != TCL_OK ) {
						bu_log( "Cannot get entry %d from the color table!!\n",
							i );
						continue;
					}
					fprintf( ofp, "color %s\n",
						 Tcl_GetStringFromObj(obj, NULL) );
				}
				bu_avs_free( &g_avs );
				continue;
			}

			if( rt_db_get_internal( &intern, dp, dbip, NULL, &rt_uniresource ) < 0 )  {
				bu_log("Unable to read '%s', skipping\n", dp->d_namep);
				continue;
			}
			if( dp->d_flags & DIR_COMB ) {
				if( intern.idb_meth->ft_tclget( interp, &intern, "tree" ) != TCL_OK )  {
					rt_db_free_internal( &intern, &rt_uniresource );
					bu_log("Unable to export '%s', skipping\n", dp->d_namep );
					continue;
				}
				if( dp->d_flags & DIR_REGION ) {
					fprintf( ofp, "put {%s} comb region yes tree {%s}\n",
						 tclify_name( dp->d_namep ),
						 interp->result );
				} else {
					fprintf( ofp, "put {%s} comb region no tree {%s}\n",
						 tclify_name( dp->d_namep ),
						 interp->result );
				}
			} else {
				if( intern.idb_meth->ft_tclget( interp, &intern, NULL ) != TCL_OK )  {
					rt_db_free_internal( &intern, &rt_uniresource );
					bu_log("Unable to export '%s', skipping\n", dp->d_namep );
					continue;
				}
				fprintf( ofp, "put {%s} %s\n",
					 tclify_name( dp->d_namep ),
					 interp->result );
			}
			avs = &intern.idb_avs;
			if( avs->magic == BU_AVS_MAGIC && avs->count > 0 ) {
				int i;

				fprintf( ofp, "attr set {%s}", tclify_name( dp->d_namep ) );
				for( i=0 ; i<avs->count ; i++ ) {
					fprintf( ofp, " {%s}", avs->avp[i].name );
					fprintf( ofp, " {%s}", avs->avp[i].value );
				}
				fprintf( ofp, "\n" );
			}
			Tcl_ResetResult( interp );
			rt_db_free_internal( &intern, &rt_uniresource );
		} FOR_ALL_DIRECTORY_END;
		return 0;
	} else {
		/* A record is already in the input buffer */
		goto top;
	}

	/* Read database file */
top:
	do {
		/* Check record type and skip deleted records */
	    	switch( record.u_id )  {
	    	case ID_FREE:
			continue;
	    	case ID_SOLID:
			soldump();
			continue;
	    	case ID_COMB:
			if( combdump() > 0 )  goto top;
			continue;
	    	case ID_MEMB:
	    		(void)fprintf(stderr, "g2asc: stray MEMB record, skipped\n");
	    		continue;
	    	case ID_ARS_A:
			arsadump();
	    		continue;
	    	case ID_P_HEAD:
			polyhead();
	    		continue;
	    	case ID_P_DATA:
			polydata();
	    		continue;
	    	case ID_IDENT:
			idendump();
	    		continue;
	    	case ID_MATERIAL:
			materdump();
	    		continue;
	    	case DBID_PIPE:
	    		pipe_dump();
	    		continue;
	    	case DBID_STRSOL:
	    		strsol_dump();
	    		continue;
	    	case DBID_NMG:
	    		nmg_dump();
	    		continue;
	    	case DBID_PARTICLE:
	    		particle_dump();
	    		continue;
	    	case DBID_ARBN:
	    		arbn_dump();
	    		continue;
	    	case DBID_CLINE:
	    		cline_dump();
	    		continue;
	    	case DBID_BOT:
	    		bot_dump();
	    		continue;
	    	case ID_BSOLID:
			bspldump();
	    		continue;
	    	case ID_BSURF:
			bsurfdump();
	    		continue;
	    	case DBID_SKETCH:
	    		sketchdump();
	    		continue;
	    	case DBID_EXTR:
	    		extrdump();
	    		continue;
	    	default:
			(void)fprintf(stderr,
				"g2asc: unable to convert record type '%c' (0%o), skipping\n",
				record.u_id, record.u_id);
	    		continue;
		}
	}  while( fread( (char *)&record, sizeof record, 1, ifp ) == 1  &&
	    !feof(ifp) );
	exit(0);
}

/*
 *			G E T _ E X T
 *
 *  Take "ngran" granueles, and put them in memory.
 *  The first granule comes from the global extern "record",
 *  the remainder are read from ifp.
 */
void
get_ext(struct bu_external *ep, int ngran)
{
	int	count;

	BU_INIT_EXTERNAL(ep);

	ep->ext_nbytes = ngran * sizeof(union record);
	ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes, "get_ext ext_buf" );

	/* Copy the freebie (first) record into the array of records.  */
	bcopy( (char *)&record, (char *)ep->ext_buf, sizeof(union record) );
	if( ngran <= 1 )  return;

	count = fread( ((char *)ep->ext_buf)+sizeof(union record),
		sizeof(union record), ngran-1, ifp);
	if( count != ngran-1 )  {
		fprintf(stderr,
			"g2asc: get_ext:  wanted to read %d granules, got %d\n",
			ngran-1, count);
		exit(1);
	}
}

void
nmg_dump(void)
{
	union record		rec;
	long			i,granules;
	long			struct_count[26];
	int			j,k;

	/* just in case someone changes the record size */
	if( sizeof( union record )%32 )
	{
		fprintf( stderr , "g2asc: nmg_dump cannot work with records not multiple of 32\n" );
		exit( -1 );
	}

	/* get number of granules needed for this NMG */
	granules = bu_glong(record.nmg.N_count);

	/* get the array of structure counts */
	for( j=0 ; j<26 ; j++ )
		struct_count[j] = bu_glong( &record.nmg.N_structs[j*4] );

	/* output some header info */
	(void)fprintf(ofp,  "%c %d %.16s %ld\n",
		record.nmg.N_id,	/* N */
		record.nmg.N_version,	/* NMG version */
		record.nmg.N_name,	/* solid name */
		granules );		/* number of additional granules */

	/* output the structure counts */
	for( j=0 ; j<26 ; j++ )
		(void)fprintf(ofp,  " %ld" , struct_count[j] );
	(void)fputc( '\n', ofp );

	/* dump the reminder in hex format */
	for( i=0 ; i<granules ; i++ )
	{
		char *cp;
		/* Read the record */
		if( !fread( (char *)&rec, sizeof record, 1, ifp ) )
		{
			(void)fprintf(stderr , "Error reading nmg granules\n" );
			exit( -1 );
		}
		cp = (char *)&rec;

		/* 32 bytes per line */
		for( k=0 ; k<sizeof( union record)/32 ; k++ )
		{
			for( j=0 ; j<32 ; j++ )
				fprintf(ofp,  "%02x" , (0xff & (*cp++)) );	 /* two hex digits per byte */
			fputc( '\n', ofp );
		}
	}
}

void
strsol_dump(void)	/* print out strsol solid info */
{
	union record rec[DB_SS_NGRAN];
	char *cp;

	/* get all the strsol granules */
	rec[0] = record;	/* struct copy the current record */

	/* read the rest from ifp */
	if( !fread( (char *)&rec[1], sizeof record, DB_SS_NGRAN-1, ifp ) )
	{
		(void)fprintf(stderr , "Error reading strsol granules\n" );
		exit( -1 );
	}

	/* make sure that at least the last byte is null */
	cp = (char *)&rec[DB_SS_NGRAN-1];
	cp += (sizeof( union record ) - 1);
	*cp = '\0';

	(void)fprintf(ofp,  "%c %.16s %.16s %s\n",
		rec[0].ss.ss_id,	/* s */
		rec[0].ss.ss_keyword,	/* "ebm", "vol", or ??? */
		rec[0].ss.ss_name,	/* solid name */
		rec[0].ss.ss_args );	/* everything else */

}

void
idendump(void)	/* Print out Ident record information */
{
	(void)fprintf(ofp,  "%c %d %.6s\n",
		record.i.i_id,			/* I */
		record.i.i_units,		/* units */
		CH(record.i.i_version)		/* version */
	);
	(void)fprintf(ofp,  "%.72s\n",
		CH(record.i.i_title)	/* title or description */
	);

	/* Print a warning message on stderr if versions differ */
	if( strcmp( record.i.i_version, ID_VERSION ) != 0 )  {
		(void)fprintf(stderr,
			"g2asc: File is version (%s), Program is version (%s)\n",
			record.i.i_version, ID_VERSION );
	}
}

void
polyhead(void)	/* Print out Polyhead record information */
{
	(void)fprintf(ofp, "%c ", record.p.p_id );		/* P */
	(void)fprintf(ofp, "%.16s", name(record.p.p_name) );	/* unique name */
	(void)fprintf(ofp, "\n");			/* Terminate w/ a newline */
}

void
polydata(void)	/* Print out Polydata record information */
{
	register int i, j;

	(void)fprintf(ofp, "%c ", record.q.q_id );		/* Q */
	(void)fprintf(ofp, "%d ", record.q.q_count );		/* # of vertices <= 5 */
	for( i = 0; i < 5; i++ )  {			/* [5][3] vertices */
		for( j = 0; j < 3; j++ ) {
			(void)fprintf(ofp, "%.12e ", record.q.q_verts[i][j] );
		}
	}
	for( i = 0; i < 5; i++ )  {			/* [5][3] normals */
		for( j = 0; j < 3; j++ ) {
			(void)fprintf(ofp, "%.12e ", record.q.q_norms[i][j] );
		}
	}
	(void)fprintf(ofp, "\n");			/* Terminate w/ a newline */
}

void
soldump(void)	/* Print out Solid record information */
{
	register int i;

	(void)fprintf(ofp, "%c ", record.s.s_id );	/* S */
	(void)fprintf(ofp, "%d ", record.s.s_type );	/* GED primitive type */
	(void)fprintf(ofp, "%.16s ", name(record.s.s_name) );	/* unique name */
	(void)fprintf(ofp, "%d ", record.s.s_cgtype );/* COMGEOM solid type */
	for( i = 0; i < 24; i++ )
		(void)fprintf(ofp, "%.12e ", record.s.s_values[i] ); /* parameters */
	(void)fprintf(ofp, "\n");			/* Terminate w/ a newline */
}

void
cline_dump(void)
{
	int				ngranules;	/* number of granules, total */
	char				*name;
	struct rt_cline_internal	*cli;
	struct bu_external		ext;
	struct rt_db_internal		intern;

	ngranules = 1;
	name = record.cli.cli_name;

	get_ext( &ext, ngranules );

	/* Hand off to librt's import() routine */
	RT_INIT_DB_INTERNAL(&intern);
	if( (rt_functab[ID_CLINE].ft_import( &intern, &ext, id_mat, DBI_NULL, &rt_uniresource )) != 0 )  {
		fprintf(stderr, "g2asc: cline import failure\n");
		exit(-1);
	}

	cli = (struct rt_cline_internal *)intern.idb_ptr;
	RT_CLINE_CK_MAGIC(cli);

	(void)fprintf(ofp, "%c ", DBID_CLINE );	/* c */
	(void)fprintf(ofp, "%.16s ", name );	/* unique name */
	(void)fprintf(ofp, "%26.20e %26.20e %26.20e ", V3ARGS( cli->v ) );
	(void)fprintf(ofp, "%26.20e %26.20e %26.20e ", V3ARGS( cli->h ) );
	(void)fprintf(ofp, "%26.20e %26.20e", cli->radius, cli->thickness );
	(void)fprintf(ofp, "\n");			/* Terminate w/ a newline */

	rt_db_free_internal( &intern, &rt_uniresource );
	db_free_external( &ext );
}

void
bot_dump(void)
{
	int				ngranules;
	char				*name;
	struct rt_bot_internal		*bot;
	struct bu_external		ext;
	struct rt_db_internal		intern;
	int				i;

	name = record.bot.bot_name;
	ngranules = bu_glong( record.bot.bot_nrec) + 1;
	get_ext( &ext, ngranules );

	/* Hand off to librt's import() routine */
	RT_INIT_DB_INTERNAL(&intern);
	if( (rt_functab[ID_BOT].ft_import( &intern, &ext, id_mat, DBI_NULL, &rt_uniresource )) != 0 )  {
		fprintf(stderr, "g2asc: bot import failure\n");
		exit(-1);
	}

	bot = (struct rt_bot_internal *)intern.idb_ptr;
	RT_BOT_CK_MAGIC(bot);

	(void)fprintf(ofp, "%c ", DBID_BOT );	/* t */
	(void)fprintf(ofp, "%.16s ", name );	/* unique name */
	(void)fprintf(ofp, "%d ", bot->mode );
	(void)fprintf(ofp, "%d ", bot->orientation );
	(void)fprintf(ofp, "%d ", 0 );	/* was error_mode */
	(void)fprintf(ofp, "%d ", bot->num_vertices );
	(void)fprintf(ofp, "%d ", bot->num_faces );
	(void)fprintf(ofp, "\n");

	for( i=0 ; i<bot->num_vertices ; i++ )
		fprintf(ofp,  "	%d: %26.20e %26.20e %26.20e\n", i, V3ARGS( &bot->vertices[i*3] ) );
	if( bot->mode == RT_BOT_PLATE )
	{
		struct bu_vls vls;

		for( i=0 ; i<bot->num_faces ; i++ )
			fprintf(ofp,  "	%d: %d %d %d %26.20e\n", i, V3ARGS( &bot->faces[i*3] ),
				bot->thickness[i] );
		bu_vls_init( &vls );
		bu_bitv_to_hex( &vls, bot->face_mode );
		fprintf(ofp,  "	%s\n", bu_vls_addr( &vls ) );
		bu_vls_free( &vls );
	}
	else
	{
		for( i=0 ; i<bot->num_faces ; i++ )
			fprintf(ofp,  "	%d: %d %d %d\n", i, V3ARGS( &bot->faces[i*3] ) );
	}

	rt_db_free_internal( &intern, &rt_uniresource );
	db_free_external( &ext );
}

void
pipe_dump(void)	/* Print out Pipe record information */
{

	int			ngranules;	/* number of granules, total */
	char			*name;
	struct rt_pipe_internal	*pipe;		/* want a struct for the head, not a ptr. */
	struct bu_external	ext;
	struct rt_db_internal	intern;

	ngranules = bu_glong(record.pwr.pwr_count)+1;
	name = record.pwr.pwr_name;

	get_ext( &ext, ngranules );

	/* Hand off to librt's import() routine */
	RT_INIT_DB_INTERNAL(&intern);
	if( (rt_functab[ID_PIPE].ft_import( &intern, &ext, id_mat, NULL, &rt_uniresource )) != 0 )  {
		fprintf(stderr, "g2asc: pipe import failure\n");
		exit(-1);
	}

	pipe = (struct rt_pipe_internal *)intern.idb_ptr;
	RT_PIPE_CK_MAGIC(pipe);

	/* send the doubly linked list off to dump_pipe_segs(), which
	 * will print all the information.
	 */

	dump_pipe_segs(name, &pipe->pipe_segs_head);

	rt_db_free_internal( &intern, &rt_uniresource );
	db_free_external( &ext );
}

void
dump_pipe_segs(char *name, struct bu_list *headp)
{

	struct wdb_pipept	*sp;

	fprintf(ofp, "%c %.16s\n", DBID_PIPE, name);

	/* print parameters for each point: one point per line */

	for( BU_LIST_FOR( sp, wdb_pipept, headp ) )  {
			fprintf(ofp,  "%26.20e %26.20e %26.20e %26.20e %26.20e %26.20e\n",
				sp->pp_id, sp->pp_od, sp->pp_bendradius, V3ARGS( sp->pp_coord ) );
	}
	fprintf(ofp,  "END_PIPE %s\n", name );
}

/*
 * Print out Particle record information.
 * Note that particles fit into one granule only.
 */
void
particle_dump(void)
{
	struct rt_part_internal 	*part;	/* head for the structure */
	struct bu_external	ext;
	struct rt_db_internal	intern;

	get_ext( &ext, 1 );

	/* Hand off to librt's import() routine */
	RT_INIT_DB_INTERNAL(&intern);
	if( (rt_functab[ID_PARTICLE].ft_import( &intern, &ext, id_mat, NULL, &rt_uniresource )) != 0 )  {
		fprintf(stderr, "g2asc: particle import failure\n");
		exit(-1);
	}

	part = (struct rt_part_internal *)intern.idb_ptr;
	RT_PART_CK_MAGIC(part);
	
	/* Particle type is picked up on here merely to ensure receiving
	 * valid data.  The type is not used any further.
	 */

	switch( part->part_type )  {
	case RT_PARTICLE_TYPE_SPHERE:
		break;
	case RT_PARTICLE_TYPE_CYLINDER:
		break;
	case RT_PARTICLE_TYPE_CONE:
		break;
	default:
		fprintf(stderr, "g2asc: no particle type %d\n", part->part_type);
		exit(-1);
	}

	fprintf(ofp, "%c %.16s %26.20e %26.20e %26.20e %26.20e %26.20e %26.20e %26.20e %26.20e\n",
		record.part.p_id, record.part.p_name,
		part->part_V[X],
		part->part_V[Y],
		part->part_V[Z],
		part->part_H[X],
		part->part_H[Y],
		part->part_H[Z],
		part->part_vrad, part->part_hrad);
}


/*			A R B N _ D U M P
 *
 *  Print out arbn information.
 *
 */
void
arbn_dump(void)
{
	int		ngranules;	/* number of granules to be read */
	int		i;		/* a counter */
	char		*name;
	struct rt_arbn_internal	*arbn;
	struct bu_external	ext;
	struct rt_db_internal	intern;

	ngranules = bu_glong(record.n.n_grans)+1;
	name = record.n.n_name;

	get_ext( &ext, ngranules );

	/* Hand off to librt's import() routine */
	RT_INIT_DB_INTERNAL(&intern);
	if( (rt_functab[ID_ARBN].ft_import( &intern, &ext, id_mat, NULL, &rt_uniresource )) != 0 )  {
		fprintf(stderr, "g2asc: arbn import failure\n");
		exit(-1);
	}

	arbn = (struct rt_arbn_internal *)intern.idb_ptr;
	RT_ARBN_CK_MAGIC(arbn);

	fprintf(ofp, "%c %.16s %d\n", 'n', name, arbn->neqn);
	for( i = 0; i < arbn->neqn; i++ )  {
		fprintf(ofp, "n %26.20e %20.26e %26.20e %26.20e\n",
			arbn->eqn[i][X], arbn->eqn[i][Y],
			arbn->eqn[i][Z], arbn->eqn[i][3]);
	}

	rt_db_free_internal( &intern, &rt_uniresource );
	db_free_external( &ext );
}

	
/*
 *			C O M B D U M P
 *
 *  Note that for compatability with programs such as FRED that
 *  (inappropriately) read .asc files, the member count has to be
 *  recalculated here.
 *
 *  Returns -
 *	0	converted OK
 *	1	converted OK, left next record in global "record" for reuse.
 */
int
combdump(void)	/* Print out Combination record information */
{
	int	m1, m2;		/* material property flags */
	struct bu_list	head;
	struct mchain {
		struct bu_list	l;
		union record	r;
	};
	struct mchain	*mp;
	struct mchain	*ret_mp = (struct mchain *)0;
	int		mcount;

	/*
	 *  Gobble up all subsequent member records, so that
	 *  an accurate count of them can be output.
	 */
	BU_LIST_INIT( &head );
	mcount = 0;
	while(1)  {
		BU_GETSTRUCT( mp, mchain );
		if( fread( (char *)&mp->r, sizeof(mp->r), 1, ifp ) != 1
		    || feof( ifp ) )
			break;
		if( mp->r.u_id != ID_MEMB )  {
			ret_mp = mp;	/* Handle it later */
			break;
		}
		BU_LIST_INSERT( &head, &(mp->l) );
		mcount++;
	}

	/*
	 *  Output the combination
	 */
	(void)fprintf(ofp, "%c ", record.c.c_id );		/* C */
	switch( record.c.c_flags )  {
	case DBV4_REGION:
		(void)fprintf(ofp, "Y ");			/* Y if `R' */
		break;
	case DBV4_NON_REGION_NULL:
	case DBV4_NON_REGION:
		(void)fprintf(ofp, "N ");			/* N if ` ' or '\0' */
		break;
	case DBV4_REGION_FASTGEN_PLATE:
		(void)fprintf(ofp, "P ");
		break;
	case DBV4_REGION_FASTGEN_VOLUME:
		(void)fprintf(ofp, "V ");
		break;
	}
	(void)fprintf(ofp, "%.16s ", name(record.c.c_name) );	/* unique name */
	(void)fprintf(ofp, "%d ", record.c.c_regionid );	/* region ID code */
	(void)fprintf(ofp, "%d ", record.c.c_aircode );	/* air space code */
	(void)fprintf(ofp, "%d ", mcount );       		/* DEPRECATED: # of members */
#if 1
	(void)fprintf(ofp, "%d ", 0 );			/* DEPRECATED: COMGEOM region # */
#else
	(void)fprintf(ofp, "%d ", record.c.c_num );           /* DEPRECATED: COMGEOM region # */
#endif
	(void)fprintf(ofp, "%d ", record.c.c_material );	/* material code */
	(void)fprintf(ofp, "%d ", record.c.c_los );		/* equiv. LOS est. */
	(void)fprintf(ofp, "%d %d %d %d ",
		record.c.c_override ? 1 : 0,
		record.c.c_rgb[0],
		record.c.c_rgb[1],
		record.c.c_rgb[2] );
	m1 = m2 = 0;
	if( isascii(record.c.c_matname[0]) && isprint(record.c.c_matname[0]) )  {
		m1 = 1;
		if( record.c.c_matparm[0] )
			m2 = 1;
	}
	fprintf(ofp, "%d %d ", m1, m2 );
	switch( record.c.c_inherit )  {
	case DB_INH_HIGHER:
		fprintf(ofp, "%d ", DB_INH_HIGHER );
		break;
	default:
	case DB_INH_LOWER:
		fprintf(ofp, "%d ", DB_INH_LOWER );
		break;
	}
	(void)fprintf(ofp, "\n");			/* Terminate w/ a newline */

	if( m1 )
		(void)fprintf(ofp, "%.32s\n", CH(record.c.c_matname) );
	if( m2 )
		(void)fprintf(ofp, "%.60s\n", CH(record.c.c_matparm) );

	/*
	 *  Output the member records now
	 */
	while( BU_LIST_WHILE( mp, mchain, &head ) )  {
		membdump( &mp->r );
		BU_LIST_DEQUEUE( &mp->l );
		bu_free( (char *)mp, "mchain");
	}

	if( ret_mp )  {
		bcopy( (char *)&ret_mp->r, (char *)&record, sizeof(record) );
		bu_free( (char *)ret_mp, "mchain");
		return 1;
	}
	return 0;
}

/*
 *			M E M B D U M P
 *
 *  Print out Member record information.
 *  Intented to be called by combdump only.
 */
void
membdump(union record *rp)
{
	register int i;

	(void)fprintf(ofp, "%c ", rp->M.m_id );		/* M */
	(void)fprintf(ofp, "%c ", rp->M.m_relation );	/* Boolean oper. */
	(void)fprintf(ofp, "%.16s ", name(rp->M.m_instname) );	/* referred-to obj. */
	for( i = 0; i < 16; i++ )			/* homogeneous transform matrix */
		(void)fprintf(ofp, "%.12e ", rp->M.m_mat[i] );
	(void)fprintf(ofp, "%d ", 0 );			/* was COMGEOM solid # */
	(void)fprintf(ofp, "\n");				/* Terminate w/ nl */
}

void
arsadump(void)	/* Print out ARS record information */
{
	register int i;
	register int length;	/* Keep track of number of ARS B records */

	(void)fprintf(ofp, "%c ", record.a.a_id );	/* A */
	(void)fprintf(ofp, "%d ", record.a.a_type );	/* primitive type */
	(void)fprintf(ofp, "%.16s ", name(record.a.a_name) );	/* unique name */
	(void)fprintf(ofp, "%d ", record.a.a_m );	/* # of curves */
	(void)fprintf(ofp, "%d ", record.a.a_n );	/* # of points per curve */
	(void)fprintf(ofp, "%d ", record.a.a_curlen );/* # of granules per curve */
	(void)fprintf(ofp, "%d ", record.a.a_totlen );/* # of granules for ARS */
	(void)fprintf(ofp, "%.12e ", record.a.a_xmax );	/* max x coordinate */
	(void)fprintf(ofp, "%.12e ", record.a.a_xmin );	/* min x coordinate */
	(void)fprintf(ofp, "%.12e ", record.a.a_ymax );	/* max y coordinate */
	(void)fprintf(ofp, "%.12e ", record.a.a_ymin );	/* min y coordinate */
	(void)fprintf(ofp, "%.12e ", record.a.a_zmax );	/* max z coordinate */
	(void)fprintf(ofp, "%.12e ", record.a.a_zmin );	/* min z coordinate */
	(void)fprintf(ofp, "\n");			/* Terminate w/ a newline */
			
	length = (int)record.a.a_totlen;	/* Get # of ARS B records */

	for( i = 0; i < length; i++ )  {
		arsbdump();
	}
}

void
arsbdump(void)	/* Print out ARS B record information */
{
	register int i;
	
	/* Read in a member record for processing */
	(void)fread( (char *)&record, sizeof record, 1, ifp );
	(void)fprintf(ofp, "%c ", record.b.b_id );		/* B */
	(void)fprintf(ofp, "%d ", record.b.b_type );		/* primitive type */
	(void)fprintf(ofp, "%d ", record.b.b_n );		/* current curve # */
	(void)fprintf(ofp, "%d ", record.b.b_ngranule );	/* current granule */
	for( i = 0; i < 24; i++ )  {			/* [8*3] vectors */
		(void)fprintf(ofp, "%.12e ", record.b.b_values[i] );
	}
	(void)fprintf(ofp, "\n");			/* Terminate w/ a newline */
}

void
materdump(void)	/* Print out material description record information */
{
	(void)fprintf(ofp,  "%c %d %d %d %d %d %d\n",
		record.md.md_id,			/* m */
		record.md.md_flags,			/* UNUSED */
		record.md.md_low,	/* low end of region IDs affected */
		record.md.md_hi,	/* high end of region IDs affected */
		record.md.md_r,
		record.md.md_g,		/* color of regions: 0..255 */
		record.md.md_b );
}

void
bspldump(void)	/* Print out B-spline solid description record information */
{
	(void)fprintf(ofp,  "%c %.16s %d %.12e\n",
		record.B.B_id,		/* b */
		name(record.B.B_name),	/* unique name */
		record.B.B_nsurf,	/* # of surfaces in this solid */
		record.B.B_resolution );	/* resolution of flatness */
}

void
bsurfdump(void)	/* Print d-spline surface description record information */
{
	register int i;
	register float *vp;
	int nbytes, count;
	float *fp;

	(void)fprintf(ofp,  "%c %d %d %d %d %d %d %d %d %d\n",
		record.d.d_id,		/* D */
		record.d.d_order[0],	/* order of u and v directions */
		record.d.d_order[1],	/* order of u and v directions */
		record.d.d_kv_size[0],	/* knot vector size (u and v) */
		record.d.d_kv_size[1],	/* knot vector size (u and v) */
		record.d.d_ctl_size[0],	/* control mesh size (u and v) */
		record.d.d_ctl_size[1],	/* control mesh size (u and v) */
		record.d.d_geom_type,	/* geom type 3 or 4 */
		record.d.d_nknots,	/* # granules of knots */
		record.d.d_nctls );	/* # granules of ctls */
	/* 
	 * The b_surf_head record is followed by
	 * d_nknots granules of knot vectors (first u, then v),
	 * and then by d_nctls granules of control mesh information.
	 * Note that neither of these have an ID field!
	 *
	 * B-spline surface record, followed by
	 *	d_kv_size[0] floats,
	 *	d_kv_size[1] floats,
	 *	padded to d_nknots granules, followed by
	 *	ctl_size[0]*ctl_size[1]*geom_type floats,
	 *	padded to d_nctls granules.
	 *
	 * IMPORTANT NOTE: granule == sizeof(union record)
	 */

	/* Malloc and clear memory for the KNOT DATA and read it */
	nbytes = record.d.d_nknots * sizeof(union record);
	if( (vp = (float *)malloc(nbytes))  == (float *)0 )  {
		(void)fprintf(stderr, "g2asc: spline knot malloc error\n");
		exit(1);
	}
	fp = vp;
	(void)bzero( (char *)fp, nbytes );
	count = fread( (char *)fp, 1, nbytes, ifp );
	if( count != nbytes )  {
		(void)fprintf(stderr, "g2asc: spline knot read failure\n");
		exit(1);
	}
	/* Print the knot vector information */
	count = record.d.d_kv_size[0] + record.d.d_kv_size[1];
	for( i = 0; i < count; i++ )  {
		(void)fprintf(ofp, "%.12e\n", *vp++);
	}
	/* Free the knot data memory */
	(void)free( (char *)fp );

	/* Malloc and clear memory for the CONTROL MESH data and read it */
	nbytes = record.d.d_nctls * sizeof(union record);
	if( (vp = (float *)malloc(nbytes))  == (float *)0 )  {
		(void)fprintf(stderr, "g2asc: control mesh malloc error\n");
		exit(1);
	}
	fp = vp;
	(void)bzero( (char *)fp, nbytes );
	count = fread( (char *)fp, 1, nbytes, ifp );
	if( count != nbytes )  {
		(void)fprintf(stderr, "g2asc: control mesh read failure\n");
		exit(1);
	}
	/* Print the control mesh information */
	count = record.d.d_ctl_size[0] * record.d.d_ctl_size[1] *
		record.d.d_geom_type;
	for( i = 0; i < count; i++ )  {
		(void)fprintf(ofp, "%.12e\n", *vp++);
	}
	/* Free the control mesh memory */
	(void)free( (char *)fp );
}

/*
 *			N A M E
 *
 *  Take a database name and null-terminate it,
 *  converting unprintable characters to something printable.
 *  Here we deal with NAMESIZE long names not being null-terminated.
 */
char *name(char *str)
{
	static char buf[NAMESIZE+2];
	register char *ip = str;
	register char *op = buf;
	register int warn = 0;

	while( op < &buf[NAMESIZE] )  {
		if( *ip == '\0' )  break;
		if( isascii(*ip) && isprint(*ip) && !isspace(*ip) )  {
			*op++ = *ip++;
		}  else  {
			*op++ = '@@';
			ip++;
			warn = 1;
		}
	}
	*op = '\0';
	if(warn)  {
		(void)fprintf(stderr,
			"g2asc: Illegal char in object name, converted to '%s'\n",
			buf );
	}
	if( op == buf )  {
		/* Null input name */
		(void)fprintf(stderr,
			"g2asc:  NULL object name converted to -=NULL=-\n");
		return("-=NULL=-");
	}
	return(buf);
}

/*
 *			S T R C H O P
 *
 *  Take a string and a length, and null terminate,
 *  converting unprintable characters to something printable.
 */
char *strchop(char *str, int len)
{
	static char buf[1024];
	register char *ip = str;
	register char *op = buf;
	register int warn = 0;
	char *ep;

	if( len > sizeof(buf)-2 )  len=sizeof(buf)-2;
	ep = &buf[len-1];		/* Leave room for null */
	while( op < ep )  {
		if( *ip == '\0' )  break;
		if( isascii(*ip) && (isprint(*ip) || isspace(*ip)) )  {
			*op++ = *ip++;
		}  else  {
			*op++ = '@@';
			ip++;
			warn = 1;
		}
	}
	*op = '\0';
	if(warn)  {
		(void)fprintf(stderr,
			"g2asc: Illegal char in string, converted to '%s'\n",
			buf );
	}
	if( op == buf )  {
		/* Null input name */
		(void)fprintf(stderr,
			"g2asc:  NULL string converted to -=STRING=-\n");
		return("-=STRING=-");
	}
	return(buf);
}

void
extrdump(void)
{
	struct rt_extrude_internal	*extr;
	int				ngranules;
	char				*myname;
	struct bu_external		ext;
	struct rt_db_internal		intern;

	myname = record.extr.ex_name;
	ngranules = bu_glong( record.extr.ex_count) + 1;
	get_ext( &ext, ngranules );

	/* Hand off to librt's import() routine */
	RT_INIT_DB_INTERNAL(&intern);
	if( (rt_functab[ID_EXTRUDE].ft_import( &intern, &ext, id_mat, DBI_NULL, &rt_uniresource )) != 0 )  {
		fprintf(stderr, "g2asc: extrusion import failure\n");
		exit(-1);
	}

	extr = (struct rt_extrude_internal *)intern.idb_ptr;
	RT_EXTRUDE_CK_MAGIC(extr);

	(void)fprintf(ofp, "%c ", DBID_EXTR );	/* e */
	(void)fprintf(ofp, "%.16s ", name( myname ) );	/* unique name */
	(void)fprintf(ofp, "%.16s ", name( extr->sketch_name ) );
	(void)fprintf(ofp, "%d ", extr->keypoint );
	(void)fprintf(ofp, "%.12e %.12e %.12e ", V3ARGS( extr->V ) );
	(void)fprintf(ofp, "%.12e %.12e %.12e ", V3ARGS( extr->h ) );
	(void)fprintf(ofp, "%.12e %.12e %.12e ", V3ARGS( extr->u_vec ) );
	(void)fprintf(ofp, "%.12e %.12e %.12e\n", V3ARGS( extr->v_vec ) );
}

void
sketchdump(void)
{
	struct rt_sketch_internal	*skt;
	int				ngranules;
	char				*myname;
	struct bu_external		ext;
	struct rt_db_internal		intern;
	int				i, j;
	struct curve			*crv;

	myname = record.skt.skt_name;
	ngranules = bu_glong( record.skt.skt_count) + 1;
	get_ext( &ext, ngranules );

	/* Hand off to librt's import() routine */
	RT_INIT_DB_INTERNAL(&intern);
	if( (rt_functab[ID_SKETCH].ft_import( &intern, &ext, id_mat, DBI_NULL, &rt_uniresource )) != 0 )  {
		fprintf(stderr, "g2asc: sketch import failure\n");
		exit( -1 );
	}

	skt = (struct rt_sketch_internal *)intern.idb_ptr;
	RT_SKETCH_CK_MAGIC( skt );
	crv = &skt->skt_curve;
	(void)fprintf(ofp, "%c ", DBID_SKETCH ); /* d */
	(void)fprintf(ofp, "%.16s ", name( myname ) );  /* unique name */
	(void)fprintf(ofp, "%.12e %.12e %.12e ", V3ARGS( skt->V ) );
	(void)fprintf(ofp, "%.12e %.12e %.12e ", V3ARGS( skt->u_vec ) );
	(void)fprintf(ofp, "%.12e %.12e %.12e ", V3ARGS( skt->v_vec ) );
	(void)fprintf(ofp, "%d %d\n ", skt->vert_count, crv->seg_count );
	for( i=0 ; i<skt->vert_count ; i++ )
		(void)fprintf(ofp, "%.12e %.12e ", V2ARGS( skt->verts[i] ) );
	(void)fprintf(ofp, "\n" );

	for( j=0 ; j<crv->seg_count ; j++ )
	{
		long *lng;
		struct line_seg *lsg;
		struct carc_seg *csg;
		struct nurb_seg *nsg;
		int k;

		lng = (long *)crv->segments[j];
		switch( *lng )
		{
			case CURVE_LSEG_MAGIC:
				lsg = (struct line_seg *)lng;
				(void)fprintf(ofp, "  L %d %d %d\n", crv->reverse[j], lsg->start, lsg->end );
				break;
			case CURVE_CARC_MAGIC:
				csg = (struct carc_seg *)lng;
				(void)fprintf(ofp, "  A %d %d %d %.12e %d %d\n", crv->reverse[j], csg->start, csg->end,
					csg->radius, csg->center_is_left, csg->orientation );
				break;
			case CURVE_NURB_MAGIC:
				nsg = (struct nurb_seg *)lng;
				(void)fprintf(ofp, "  N %d %d %d %d %d\n   ", crv->reverse[j], nsg->order, nsg->pt_type,
					nsg->k.k_size, nsg->c_size );
				for( k=0 ; k<nsg->k.k_size ; k++ )
					(void)fprintf(ofp, " %.12e", nsg->k.knots[k] );
				(void)fprintf(ofp, "\n   " );
				for( k=0 ; k<nsg->c_size ; k++ )
					(void)fprintf(ofp, " %d", nsg->ctl_points[k] );
				(void)fprintf(ofp, "\n" );
				break;
		}
	}
}
@


11.46
log
@change conf.h to a wrapped config.h
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/conv/g2asc.c,v 11.45 2004/04/05 07:49:36 morrison Exp $ (BRL)";
@


11.45
log
@merge of ansi-6-0-branch into HEAD
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d27 5
a31 1
#include "conf.h"
@


11.44
log
@merge of windows-6-0-branch into head
@
text
@d54 2
a55 2
char *name();
char *strchop();
d58 9
a66 9
int	combdump();
void	idendump(), polyhead(), polydata();
void	soldump(), extrdump(), sketchdump();
void	membdump(), arsadump(), arsbdump();
void	materdump(), bspldump(), bsurfdump();
void	pipe_dump(), particle_dump(), dump_pipe_segs();
void	arbn_dump(), cline_dump(), bot_dump();
void	nmg_dump();
void	strsol_dump();
d120 1
a120 2
main(argc, argv)
char **argv;
d379 1
a379 3
get_ext( ep, ngran )
struct bu_external	*ep;
int			ngran;
d403 1
a403 1
nmg_dump()
d459 1
a459 1
strsol_dump()	/* print out strsol solid info */
d488 1
a488 1
idendump()	/* Print out Ident record information */
d508 1
a508 1
polyhead()	/* Print out Polyhead record information */
d516 1
a516 1
polydata()	/* Print out Polydata record information */
d536 1
a536 1
soldump()	/* Print out Solid record information */
d550 1
a550 1
cline_dump()
d585 1
a585 1
bot_dump()
d642 1
a642 1
pipe_dump()	/* Print out Pipe record information */
d677 1
a677 3
dump_pipe_segs(name, headp)
char			*name;
struct bu_list	*headp;
d698 1
a698 1
particle_dump()
d750 1
a750 1
arbn_dump()
d798 1
a798 1
combdump()	/* Print out Combination record information */
d911 1
a911 2
membdump(rp)
union record	*rp;
d925 1
a925 1
arsadump()	/* Print out ARS record information */
d953 1
a953 1
arsbdump()	/* Print out ARS B record information */
d970 1
a970 1
materdump()	/* Print out material description record information */
d983 1
a983 1
bspldump()	/* Print out B-spline solid description record information */
d993 1
a993 1
bsurfdump()	/* Print d-spline surface description record information */
d1078 1
a1078 2
char *name( str )
char *str;
d1116 1
a1116 2
char *strchop( str, len )
char *str;
d1152 1
a1152 1
extrdump()
d1185 1
a1185 1
sketchdump()
@


11.43
log
@update copyright to include span through 2003
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.42 2003/08/05 12:24:33 jra Exp $ (BRL)";
d44 3
a46 1

d125 4
d130 3
d134 1
d199 1
a199 1
		if( (dbip = db_open( iname, "r" )) == NULL )  {
@


11.42
log
@Oops, last mod escaped special characters in attribute names and values. Can't do that!!!!
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1985 by the United States Army.
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.41 2003/06/20 12:54:35 jra Exp $ (BRL)";
@


11.42.4.1
log
@merge from HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.43 2004/02/02 17:39:00 morrison Exp $ (BRL)";
@


11.42.4.2
log
@merge from head
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.42.4.1 2004/02/12 19:24:23 erikg Exp $ (BRL)";
@


11.42.4.3
log
@merge from head
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d44 1
a44 3
#ifndef WIN32
#include <fcntl.h>
#endif
a122 4
#ifdef WIN32
	_fmode = _O_BINARY;
#endif

a123 3
#ifdef WIN32
	ifp = fopen(iname, "r");
#else
a124 1
#endif
d189 1
a189 1
		if( (dbip = db_open( iname, "rb" )) == NULL )  {
@


11.41
log
@Mods to handle object names, attribute names, and attribute values with imbedded special characters
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.40 2003/04/03 15:10:47 jra Exp $ (BRL)";
d273 2
a274 2
					fprintf( ofp, " {%s}", tclify_name( avs->avp[i].name ) );
					fprintf( ofp, " {%s}", tclify_name( avs->avp[i].value ) );
@


11.40
log
@Now refuses to run using redirected input or output for version 5 databases
(because it will not work)
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.39 2002/11/27 13:41:40 jra Exp $ (BRL)";
d78 39
d196 3
a198 12
			char *c;

			fprintf( ofp, "title ");
			c = dbip->dbi_title;
			while( *c ) {
				if( ispunct( *c ) ) {
					putc( '\\', ofp );
				}
				putc( *c, ofp );
				c++;
			}
                        putc( '\n', ofp );
d249 2
a250 2
					fprintf( ofp, "put %s comb region yes tree {%s}\n",
						 dp->d_namep,
d253 2
a254 2
					fprintf( ofp, "put %s comb region no tree {%s}\n",
						 dp->d_namep,
d263 2
a264 2
				fprintf( ofp, "put %s %s\n",
					 dp->d_namep,
d271 1
a271 1
				fprintf( ofp, "attr set %s", dp->d_namep );
d273 2
a274 1
					fprintf( ofp, " %s {%s}", avs->avp[i].name, avs->avp[i].value );
@


11.40.2.1
log
@updated for merging
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.42 2003/08/05 12:24:33 jra Exp $ (BRL)";
a77 39
static char *tclified_name=NULL;
static int tclified_name_buffer_len=0;


/*	This routine escapes the '{' and '}' characters in any string and returns a static buffer containing the
 *	resulting string. Used for names and db title on output.
 *
 *	NOTE: RETURN OF STATIC BUFFER
 */
char *
tclify_name( const char *name )
{
	const char *src=name;
	char *dest;

	int max_len=2*strlen( name ) + 1;

	if( max_len < 2 ) {
		return( (char *)NULL );
	}

	if( max_len > tclified_name_buffer_len ) {
		tclified_name_buffer_len = max_len;
		tclified_name = bu_realloc( tclified_name, tclified_name_buffer_len, "tclified_name buffer" );
	}

	dest = tclified_name;

	while( *src ) {
		if( *src == '{' || *src == '}' ) {
			*dest++ = '\\';
		}
		*dest++ = *src++;
	}
	*dest = '\0';

	return( tclified_name );
}

d157 12
a168 3
			fprintf( ofp, "title {%s}\n", tclify_name( dbip->dbi_title ) );
		} else {
			fprintf( ofp, "title {Untitled BRL-CAD Database}\n" );
d219 2
a220 2
					fprintf( ofp, "put {%s} comb region yes tree {%s}\n",
						 tclify_name( dp->d_namep ),
d223 2
a224 2
					fprintf( ofp, "put {%s} comb region no tree {%s}\n",
						 tclify_name( dp->d_namep ),
d233 2
a234 2
				fprintf( ofp, "put {%s} %s\n",
					 tclify_name( dp->d_namep ),
d241 1
a241 1
				fprintf( ofp, "attr set {%s}", tclify_name( dp->d_namep ) );
d243 1
a243 2
					fprintf( ofp, " {%s}", avs->avp[i].name );
					fprintf( ofp, " {%s}", avs->avp[i].value );
@


11.39
log
@BOT primitives can now have vertex normals
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.38 2002/08/20 17:07:22 jra Exp $ (BRL)";
d134 6
@


11.38
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.36 2002/02/05 03:13:06 jra Exp $ (BRL)";
d568 1
a568 1
	(void)fprintf(ofp, "%d ", bot->error_mode );
@


11.38.4.1
log
@Survice Engineering patch to clean up the build environment and several runtime issues
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.38 2002/08/20 17:07:22 jra Exp $ (BRL)";
d44 1
a44 3
#ifndef WIN32
#include <fcntl.h>
#endif
a83 4
#ifdef WIN32
	_fmode = _O_BINARY;
#endif

a84 3
#ifdef WIN32
	ifp = fopen(iname, "r");
#else
a85 1
#endif
d144 1
a144 1
		if( (dbip = db_open( iname, "rb" )) == NULL )  {
@


11.38.4.2
log
@sync to HEAD...
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/conv/g2asc.c,v 11.38.4.1 2003/08/14 08:07:24 morrison Exp $ (BRL)";
a79 39
static char *tclified_name=NULL;
static int tclified_name_buffer_len=0;


/*	This routine escapes the '{' and '}' characters in any string and returns a static buffer containing the
 *	resulting string. Used for names and db title on output.
 *
 *	NOTE: RETURN OF STATIC BUFFER
 */
char *
tclify_name( const char *name )
{
	const char *src=name;
	char *dest;

	int max_len=2*strlen( name ) + 1;

	if( max_len < 2 ) {
		return( (char *)NULL );
	}

	if( max_len > tclified_name_buffer_len ) {
		tclified_name_buffer_len = max_len;
		tclified_name = bu_realloc( tclified_name, tclified_name_buffer_len, "tclified_name buffer" );
	}

	dest = tclified_name;

	while( *src ) {
		if( *src == '{' || *src == '}' ) {
			*dest++ = '\\';
		}
		*dest++ = *src++;
	}
	*dest = '\0';

	return( tclified_name );
}

a144 6
		if( ifp == stdin || ofp == stdout ) {
			bu_log( "Cannot use stdin or stdout for Release 6 or later databases\n");
			bu_log( "Please use the \"g2asc input.g output.g\" form\n" );
			exit( 1 );
		}

d161 12
a172 3
			fprintf( ofp, "title {%s}\n", tclify_name( dbip->dbi_title ) );
		} else {
			fprintf( ofp, "title {Untitled BRL-CAD Database}\n" );
d223 2
a224 2
					fprintf( ofp, "put {%s} comb region yes tree {%s}\n",
						 tclify_name( dp->d_namep ),
d227 2
a228 2
					fprintf( ofp, "put {%s} comb region no tree {%s}\n",
						 tclify_name( dp->d_namep ),
d237 2
a238 2
				fprintf( ofp, "put {%s} %s\n",
					 tclify_name( dp->d_namep ),
d245 1
a245 1
				fprintf( ofp, "attr set {%s}", tclify_name( dp->d_namep ) );
d247 1
a247 2
					fprintf( ofp, " {%s}", avs->avp[i].name );
					fprintf( ofp, " {%s}", avs->avp[i].value );
d578 1
a578 1
	(void)fprintf(ofp, "%d ", 0 );	/* was error_mode */
@


11.38.2.1
log
@Initial ANSIfication
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.38 2002/08/20 17:07:22 jra Exp $ (BRL)";
d52 2
a53 2
char *name(char *str);
char *strchop(char *str, int len);
d56 9
a64 9
int	combdump(void);
void	idendump(void), polyhead(void), polydata(void);
void	soldump(void), extrdump(void), sketchdump(void);
void	membdump(union record *rp), arsadump(void), arsbdump(void);
void	materdump(void), bspldump(void), bsurfdump(void);
void	pipe_dump(void), particle_dump(void), dump_pipe_segs(char *name, struct bu_list *headp);
void	arbn_dump(void), cline_dump(void), bot_dump(void);
void	nmg_dump(void);
void	strsol_dump(void);
d79 2
a80 1
main(int argc, char **argv)
d333 3
a335 1
get_ext(struct bu_external *ep, int ngran)
d359 1
a359 1
nmg_dump(void)
d415 1
a415 1
strsol_dump(void)	/* print out strsol solid info */
d444 1
a444 1
idendump(void)	/* Print out Ident record information */
d464 1
a464 1
polyhead(void)	/* Print out Polyhead record information */
d472 1
a472 1
polydata(void)	/* Print out Polydata record information */
d492 1
a492 1
soldump(void)	/* Print out Solid record information */
d506 1
a506 1
cline_dump(void)
d541 1
a541 1
bot_dump(void)
d598 1
a598 1
pipe_dump(void)	/* Print out Pipe record information */
d633 3
a635 1
dump_pipe_segs(char *name, struct bu_list *headp)
d656 1
a656 1
particle_dump(void)
d708 1
a708 1
arbn_dump(void)
d756 1
a756 1
combdump(void)	/* Print out Combination record information */
d869 2
a870 1
membdump(union record *rp)
d884 1
a884 1
arsadump(void)	/* Print out ARS record information */
d912 1
a912 1
arsbdump(void)	/* Print out ARS B record information */
d929 1
a929 1
materdump(void)	/* Print out material description record information */
d942 1
a942 1
bspldump(void)	/* Print out B-spline solid description record information */
d952 1
a952 1
bsurfdump(void)	/* Print d-spline surface description record information */
d1037 2
a1038 1
char *name(char *str)
d1076 2
a1077 1
char *strchop(char *str, int len)
d1113 1
a1113 1
extrdump(void)
d1146 1
a1146 1
sketchdump(void)
@


11.38.2.2
log
@sync branch with HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d44 1
a44 3
#ifndef WIN32
#include <fcntl.h>
#endif
a77 39
static char *tclified_name=NULL;
static int tclified_name_buffer_len=0;


/*	This routine escapes the '{' and '}' characters in any string and returns a static buffer containing the
 *	resulting string. Used for names and db title on output.
 *
 *	NOTE: RETURN OF STATIC BUFFER
 */
char *
tclify_name( const char *name )
{
	const char *src=name;
	char *dest;

	int max_len=2*strlen( name ) + 1;

	if( max_len < 2 ) {
		return( (char *)NULL );
	}

	if( max_len > tclified_name_buffer_len ) {
		tclified_name_buffer_len = max_len;
		tclified_name = bu_realloc( tclified_name, tclified_name_buffer_len, "tclified_name buffer" );
	}

	dest = tclified_name;

	while( *src ) {
		if( *src == '{' || *src == '}' ) {
			*dest++ = '\\';
		}
		*dest++ = *src++;
	}
	*dest = '\0';

	return( tclified_name );
}

a82 4
#ifdef WIN32
	_fmode = _O_BINARY;
#endif

a83 3
#ifdef WIN32
	ifp = fopen(iname, "r");
#else
a84 1
#endif
a133 6
		if( ifp == stdin || ofp == stdout ) {
			bu_log( "Cannot use stdin or stdout for Release 6 or later databases\n");
			bu_log( "Please use the \"g2asc input.g output.g\" form\n" );
			exit( 1 );
		}

d143 1
a143 1
		if( (dbip = db_open( iname, "rb" )) == NULL )  {
d150 12
a161 3
			fprintf( ofp, "title {%s}\n", tclify_name( dbip->dbi_title ) );
		} else {
			fprintf( ofp, "title {Untitled BRL-CAD Database}\n" );
d212 2
a213 2
					fprintf( ofp, "put {%s} comb region yes tree {%s}\n",
						 tclify_name( dp->d_namep ),
d216 2
a217 2
					fprintf( ofp, "put {%s} comb region no tree {%s}\n",
						 tclify_name( dp->d_namep ),
d226 2
a227 2
				fprintf( ofp, "put {%s} %s\n",
					 tclify_name( dp->d_namep ),
d234 1
a234 1
				fprintf( ofp, "attr set {%s}", tclify_name( dp->d_namep ) );
d236 1
a236 2
					fprintf( ofp, " {%s}", avs->avp[i].name );
					fprintf( ofp, " {%s}", avs->avp[i].value );
d565 1
a565 1
	(void)fprintf(ofp, "%d ", 0 );	/* was error_mode */
@


11.37
log
@Converted from K&R to ANSI C - RFH
@
text
@d52 2
a53 2
char *name(char *str);
char *strchop(char *str, int len);
d56 9
a64 9
int	combdump(void);
void	idendump(void), polyhead(void), polydata(void);
void	soldump(void), extrdump(void), sketchdump(void);
void	membdump(union record *rp), arsadump(void), arsbdump(void);
void	materdump(void), bspldump(void), bsurfdump(void);
void	pipe_dump(void), particle_dump(void), dump_pipe_segs(char *name, struct bu_list *headp);
void	arbn_dump(void), cline_dump(void), bot_dump(void);
void	nmg_dump(void);
void	strsol_dump(void);
d79 2
a80 1
main(int argc, char **argv)
d333 3
a335 1
get_ext(struct bu_external *ep, int ngran)
d359 1
a359 1
nmg_dump(void)
d415 1
a415 1
strsol_dump(void)	/* print out strsol solid info */
d444 1
a444 1
idendump(void)	/* Print out Ident record information */
d464 1
a464 1
polyhead(void)	/* Print out Polyhead record information */
d472 1
a472 1
polydata(void)	/* Print out Polydata record information */
d492 1
a492 1
soldump(void)	/* Print out Solid record information */
d506 1
a506 1
cline_dump(void)
d541 1
a541 1
bot_dump(void)
d598 1
a598 1
pipe_dump(void)	/* Print out Pipe record information */
d633 3
a635 1
dump_pipe_segs(char *name, struct bu_list *headp)
d656 1
a656 1
particle_dump(void)
d708 1
a708 1
arbn_dump(void)
d756 1
a756 1
combdump(void)	/* Print out Combination record information */
d869 2
a870 1
membdump(union record *rp)
d884 1
a884 1
arsadump(void)	/* Print out ARS record information */
d912 1
a912 1
arsbdump(void)	/* Print out ARS B record information */
d929 1
a929 1
materdump(void)	/* Print out material description record information */
d942 1
a942 1
bspldump(void)	/* Print out B-spline solid description record information */
d952 1
a952 1
bsurfdump(void)	/* Print d-spline surface description record information */
d1037 2
a1038 1
char *name(char *str)
d1076 2
a1077 1
char *strchop(char *str, int len)
d1113 1
a1113 1
extrdump(void)
d1146 1
a1146 1
sketchdump(void)
@


11.36
log
@Mods due to change in "attr" command
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.35 2001/10/22 17:33:06 jra Exp $ (BRL)";
d52 2
a53 2
char *name();
char *strchop();
d56 9
a64 9
int	combdump();
void	idendump(), polyhead(), polydata();
void	soldump(), extrdump(), sketchdump();
void	membdump(), arsadump(), arsbdump();
void	materdump(), bspldump(), bsurfdump();
void	pipe_dump(), particle_dump(), dump_pipe_segs();
void	arbn_dump(), cline_dump(), bot_dump();
void	nmg_dump();
void	strsol_dump();
d79 1
a79 2
main(argc, argv)
char **argv;
d332 1
a332 3
get_ext( ep, ngran )
struct bu_external	*ep;
int			ngran;
d356 1
a356 1
nmg_dump()
d412 1
a412 1
strsol_dump()	/* print out strsol solid info */
d441 1
a441 1
idendump()	/* Print out Ident record information */
d461 1
a461 1
polyhead()	/* Print out Polyhead record information */
d469 1
a469 1
polydata()	/* Print out Polydata record information */
d489 1
a489 1
soldump()	/* Print out Solid record information */
d503 1
a503 1
cline_dump()
d538 1
a538 1
bot_dump()
d595 1
a595 1
pipe_dump()	/* Print out Pipe record information */
d630 1
a630 3
dump_pipe_segs(name, headp)
char			*name;
struct bu_list	*headp;
d651 1
a651 1
particle_dump()
d703 1
a703 1
arbn_dump()
d751 1
a751 1
combdump()	/* Print out Combination record information */
d864 1
a864 2
membdump(rp)
union record	*rp;
d878 1
a878 1
arsadump()	/* Print out ARS record information */
d906 1
a906 1
arsbdump()	/* Print out ARS B record information */
d923 1
a923 1
materdump()	/* Print out material description record information */
d936 1
a936 1
bspldump()	/* Print out B-spline solid description record information */
d946 1
a946 1
bsurfdump()	/* Print d-spline surface description record information */
d1031 1
a1031 2
char *name( str )
char *str;
d1069 1
a1069 2
char *strchop( str, len )
char *str;
d1105 1
a1105 1
extrdump()
d1138 1
a1138 1
sketchdump()
@


11.35
log
@Changed output "db xxx" commands to leave off the "db "
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.34 2001/10/10 15:48:17 butler Exp $ (BRL)";
d235 1
a235 1
				fprintf( ofp, "attr %s", dp->d_namep );
@


11.34
log
@Implemented conversion for EBM and VOL primitives
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.33 2001/10/05 15:20:14 jra Exp $ (BRL)";
d153 1
a153 1
			fprintf( ofp, "db title ");
d164 1
a164 1
		fprintf( ofp, "db units %s\n", bu_units_string( dbip->dbi_local2base ) );
d195 1
a195 1
					fprintf( ofp, "db color %s\n",
d213 1
a213 1
					fprintf( ofp, "db put %s comb region yes tree {%s}\n",
d217 1
a217 1
					fprintf( ofp, "db put %s comb region no tree {%s}\n",
d227 1
a227 1
				fprintf( ofp, "db put %s %s\n",
d235 1
a235 1
				fprintf( ofp, "db attr %s", dp->d_namep );
@


11.33
log
@Added units and colortable for db version 5
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.32 2001/10/04 20:20:48 rbowers Exp $ (BRL)";
d135 2
a136 2
		bu_log("Attempting to export Release 6 database\n" );
		bu_log("  Note that the Release 6 binary format is machine independent\n");
@


11.32
log
@-* improved message that is printed when used on a version 5 database.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.31 2001/10/04 19:36:09 rbowers Exp $ (BRL)";
d43 1
d82 2
d164 1
d167 1
a167 1
			struct bu_attribute_value_set *avs;
d170 29
a198 1
			if( dp->d_major_type == 2 && dp->d_minor_type == 0 )
d200 1
@


11.31
log
@-* modified to eliminate user-visible v4 references.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.30 2001/10/01 20:02:23 jra Exp $ (BRL)";
d133 3
a135 3
		bu_log("\tNote that the binary format is machine independent\n");
		bu_log("\tConverting to ASCII to move database to a different architecture\n");
		bu_log("\tis no longer necessary.\n");
@


11.30
log
@Attributes were being output with "attr" command, should have been "db attr"
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.29 2001/08/24 12:36:52 jra Exp $ (BRL)";
d132 1
a132 1
		bu_log("Attempting to export v5 database\n" );
d134 2
a135 1

@


11.29
log
@Moved a label to avoid compiler warnings
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.28 2001/07/18 14:41:03 jra Exp $ (BRL)";
d201 1
a201 1
				fprintf( ofp, "attr %s", dp->d_namep );
@


11.28
log
@Now skips _GLOBAL_ object and does not duplicate combination attributes
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.27 2001/07/18 03:25:44 jra Exp $ (BRL)";
d217 1
a218 1
top:
@


11.27
log
@Added attributes for v5 databases
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.26 2001/06/22 14:40:24 jra Exp $ (BRL)";
d132 2
a133 1
		bu_log("Attempting to export v5 database\n");
d164 4
d172 24
a195 4
			if( intern.idb_meth->ft_tclget( interp, &intern, NULL ) != TCL_OK )  {
				rt_db_free_internal( &intern, &rt_uniresource );
				bu_log("Unable to export '%s', skipping\n", dp->d_namep );
				continue;
a196 3
			fprintf( ofp, "db put %s %s\n",
				dp->d_namep,
				interp->result );
@


11.26
log
@Now handles db5 titles
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.25 2001/04/05 19:34:59 morrison Exp $ (BRL)";
d146 1
a146 1
			unsigned char *c;
a151 1
					bu_log( "Adding a \\ to %c\n", *c );
d161 1
a171 1
			rt_db_free_internal( &intern, &rt_uniresource );
d175 10
d186 1
@


11.25
log
@updated SIGNED to signed
updated CONST to const
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.24 2000/10/31 22:57:30 mike Exp $ (BRL)";
d145 15
d324 1
a324 1
	(void)putchar( '\n' );
d343 1
a343 1
			putchar( '\n' );
@


11.24
log
@
Init &intern to prevent core dump
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.23 2000/10/30 20:37:39 jra Exp $ (BRL)";
d45 1
a45 1
CONST mat_t	id_mat = {
@


11.23
log
@Eliminated some unnecessary blathering
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.22 2000/10/30 18:15:07 jra Exp $ (BRL)";
d85 2
d88 2
a89 1
	if( argc == 2 || argc == 4 )
d91 1
d439 1
d474 1
d532 1
d584 1
d642 1
@


11.22
log
@Needed more precision in cline_dump()
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.21 2000/09/08 05:55:42 mike Exp $ (BRL)";
a167 2
	    	if( argc > 1 )
			(void)fprintf(stderr,"0%o (%c)\n", record.u_id, record.u_id);
@


11.21
log
@
Tree routines now need resource structure.
Added rt_init_resource() call.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.20 2000/09/05 12:44:03 jra Exp $ (BRL)";
d447 3
a449 3
	(void)fprintf(ofp, "%.12e %.12e %.12e ", V3ARGS( cli->v ) );
	(void)fprintf(ofp, "%.12e %.12e %.12e ", V3ARGS( cli->h ) );
	(void)fprintf(ofp, "%.12e %.12e", cli->radius, cli->thickness );
@


11.20
log
@Added DBV4_NON_REGION_NULL flag for combinations
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.19 2000/08/29 22:34:51 mike Exp $ (BRL)";
d114 2
d144 1
a144 1
			if( rt_db_get_internal( &intern, dp, dbip, NULL ) < 0 )  {
d149 1
a149 1
				rt_db_free_internal( &intern );
d153 1
a153 1
			rt_db_free_internal( &intern );
d437 1
a437 1
	if( (rt_functab[ID_CLINE].ft_import( &intern, &ext, id_mat, DBI_NULL )) != 0 )  {
d452 1
a452 1
	rt_db_free_internal( &intern );
d471 1
a471 1
	if( (rt_functab[ID_BOT].ft_import( &intern, &ext, id_mat, DBI_NULL )) != 0 )  {
d508 1
a508 1
	rt_db_free_internal( &intern );
d528 1
a528 1
	if( (rt_functab[ID_PIPE].ft_import( &intern, &ext, id_mat, NULL )) != 0 )  {
d542 1
a542 1
	rt_db_free_internal( &intern );
d579 1
a579 1
	if( (rt_functab[ID_PARTICLE].ft_import( &intern, &ext, id_mat, NULL )) != 0 )  {
d636 1
a636 1
	if( (rt_functab[ID_ARBN].ft_import( &intern, &ext, id_mat, NULL )) != 0 )  {
d651 1
a651 1
	rt_db_free_internal( &intern );
d1039 1
a1039 1
	if( (rt_functab[ID_EXTRUDE].ft_import( &intern, &ext, id_mat, DBI_NULL )) != 0 )  {
d1074 1
a1074 1
	if( (rt_functab[ID_SKETCH].ft_import( &intern, &ext, id_mat, DBI_NULL )) != 0 )  {
@


11.19
log
@
Fixed lint message.
Added handling of "-" argument as name for stdin and/or stdout.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.18 2000/08/25 22:10:06 mike Exp $ (BRL)";
d705 1
d707 1
a707 1
		(void)fprintf(ofp, "N ");			/* N if ` ' */
@


11.18
log
@
Auto-detects v5 database on input.
Produces Tcl script to re-create the database in that case.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.17 2000/08/25 21:31:59 mike Exp $ (BRL)";
d92 5
a96 1
		ifp = fopen(iname,"r");
d98 5
a102 1
		ofp = fopen(argv[2],"w");
d159 1
d164 1
a164 2
	while( fread( (char *)&record, sizeof record, 1, ifp ) == 1  &&
	    !feof(ifp) )  {
d235 2
a236 1
	}
@


11.17
log
@
Fixed lint.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.16 2000/08/09 20:41:29 mike Exp $ (BRL)";
d30 5
d75 1
d81 1
d91 3
a93 2
		ifp = fopen(argv[1],"r");
		if( !ifp )  perror(argv[1]);
d104 48
@


11.16
log
@
Fixed interface for extrusions and sketches.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.15 2000/07/12 03:56:40 mike Exp $ (BRL)";
d370 1
a370 1
	if( (rt_cline_import( &intern, &ext, id_mat, DBI_NULL )) != 0 )  {
d385 1
a385 1
	rt_cline_ifree( &intern );
d404 1
a404 1
	if( (rt_bot_import( &intern, &ext, id_mat, DBI_NULL )) != 0 )  {
d441 1
a441 1
	rt_bot_ifree( &intern );
d461 1
a461 1
	if( (rt_pipe_import( &intern, &ext, id_mat )) != 0 )  {
d475 1
a475 1
	rt_pipe_ifree( &intern );
d512 1
a512 1
	if( (rt_part_import( &intern, &ext, id_mat )) != 0 )  {
d569 1
a569 1
	if( (rt_arbn_import( &intern, &ext, id_mat )) != 0 )  {
d584 1
a584 1
	rt_arbn_ifree( &intern );
d971 1
a971 1
	if( (rt_extrude_import( &intern, &ext, id_mat, DBI_NULL )) != 0 )  {
d1006 1
a1006 1
	if( (rt_sketch_import( &intern, &ext, id_mat, DBI_NULL )) != 0 )  {
@


11.15
log
@
return type
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.14 2000/07/10 23:53:58 mike Exp $ (BRL)";
d970 1
d1005 1
@


11.14
log
@
lint
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.13 2000/06/19 18:51:56 jra Exp $ (BRL)";
d71 1
@


11.13
log
@The nmg_dump() routine was writing too many bytes for 0xff bytes
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.12 2000/03/16 13:39:11 jra Exp $ (BRL)";
d35 1
a36 1
#include "raytrace.h"
@


11.13.2.1
log
@Added DBV4_NON_REGION_NULL flag for combinations
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.13 2000/06/19 18:51:56 jra Exp $ (BRL)";
a638 1
	case DBV4_NON_REGION_NULL:
d640 1
a640 1
		(void)fprintf(ofp, "N ");			/* N if ` ' or '\0' */
@


11.13.2.2
log
@Needed more precision in CLINE dump routine
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.13.2.1 2000/09/05 12:45:12 jra Exp $ (BRL)";
d379 3
a381 3
	(void)fprintf(ofp, "%26.20e %26.20e %26.20e ", V3ARGS( cli->v ) );
	(void)fprintf(ofp, "%26.20e %26.20e %26.20e ", V3ARGS( cli->h ) );
	(void)fprintf(ofp, "%26.20e %26.20e", cli->radius, cli->thickness );
@


11.13.2.3
log
@Eliminated some unnecessary blathering
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.13.2.2 2000/10/30 18:10:19 jra Exp $ (BRL)";
d101 2
@


11.12
log
@Sketch solid can only have one curve now
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.11 2000/03/04 05:54:40 mike Exp $ (BRL)";
d257 1
a257 1
				fprintf(ofp,  "%02x" , *cp++ );	 /* two hex digits per byte */
@


11.11
log
@
Added support for FASTGEN PLATE and VOLUME mode regions,
which are special cases of the orginary BRL-CAD region.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.10 2000/03/02 15:48:25 jra Exp $ (BRL)";
a979 1
	(void)fprintf(ofp, "%.16s ", name( extr->curve_name ) );
d996 1
d1010 1
d1016 1
a1016 1
	(void)fprintf(ofp, "%d %d\n ", skt->vert_count, skt->curve_count );
d1020 2
a1021 1
	for( i=0 ; i<skt->curve_count ; i++ )
d1023 5
a1027 1
		struct curve *crv;
d1029 2
a1030 3
		crv = &skt->curves[i];
		(void)fprintf(ofp, " %.16s %d\n", name( crv->crv_name ), crv->seg_count );
		for( j=0 ; j<crv->seg_count ; j++ )
d1032 20
a1051 30
			long *lng;
			struct line_seg *lsg;
			struct carc_seg *csg;
			struct nurb_seg *nsg;
			int k;

			lng = (long *)crv->segments[j];
			switch( *lng )
			{
				case CURVE_LSEG_MAGIC:
					lsg = (struct line_seg *)lng;
					(void)fprintf(ofp, "  L %d %d %d\n", crv->reverse[j], lsg->start, lsg->end );
					break;
				case CURVE_CARC_MAGIC:
					csg = (struct carc_seg *)lng;
					(void)fprintf(ofp, "  A %d %d %d %.12e %d %d\n", crv->reverse[j], csg->start, csg->end,
						csg->radius, csg->center_is_left, csg->orientation );
					break;
				case CURVE_NURB_MAGIC:
					nsg = (struct nurb_seg *)lng;
					(void)fprintf(ofp, "  N %d %d %d %d %d\n   ", crv->reverse[j], nsg->order, nsg->pt_type,
						nsg->k.k_size, nsg->c_size );
					for( k=0 ; k<nsg->k.k_size ; k++ )
						(void)fprintf(ofp, " %.12e", nsg->k.knots[k] );
					(void)fprintf(ofp, "\n   " );
					for( k=0 ; k<nsg->c_size ; k++ )
						(void)fprintf(ofp, " %d", nsg->ctl_points[k] );
					(void)fprintf(ofp, "\n" );
					break;
			}
@


11.10
log
@Eliminated some unused variables
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.9 2000/03/02 14:39:40 jra Exp $ (BRL)";
d635 2
a636 1
	if( record.c.c_flags == 'R' )			/* set region flag */
d638 2
a639 1
	else
d641 8
@


11.9
log
@Eliminated FGP solid and added CLINE solid
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.8 2000/02/02 21:13:03 jra Exp $ (BRL)";
a952 1
	int				i;
@


11.8
log
@support for extrusion and sketch
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.7 1999/12/07 01:01:06 mike Exp $ (BRL)";
d56 1
a56 1
void	arbn_dump(), fgp_dump(), bot_dump();
d146 2
a147 2
	    	case DBID_FGP:
	    		fgp_dump();
d355 1
a355 1
fgp_dump()
d359 1
a359 1
	struct rt_fgp_internal	*plt;
d364 1
a364 1
	name = record.fgp.fgp_name;
d369 2
a370 2
	if( (rt_fgp_import( &intern, &ext, id_mat, DBI_NULL )) != 0 )  {
		fprintf(stderr, "g2asc: fgp import failure\n");
d374 2
a375 2
	plt = (struct rt_fgp_internal *)intern.idb_ptr;
	RT_FGP_CK_MAGIC(plt);
d377 1
a377 1
	(void)fprintf(ofp, "%c ", DBID_FGP );	/* f */
d379 3
a381 3
	(void)fprintf(ofp, "%.16s ", plt->referenced_solid );	/* name of referenced solid */
	(void)fprintf(ofp, "%.12e ", plt->thickness );	/* fgp thickness */
	(void)fprintf(ofp, "%d ", plt->mode );		/* fgp mode */
d384 1
a384 1
	rt_fgp_ifree( &intern );
@


11.7
log
@
Added capability to specify filenames on command line.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.6 1999/11/09 15:42:39 jra Exp $ (BRL)";
d52 1
a52 1
void	soldump();
d158 6
d943 107
@


11.6
log
@Added support for BOT solid.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.5 1999/10/12 13:58:11 jra Exp $ (BRL)";
a35 1
#include "rtlist.h"
d40 1
a40 1
mat_t	id_mat = {
d62 9
d74 23
d98 2
a99 2
	while( fread( (char *)&record, sizeof record, 1, stdin ) == 1  &&
	    !feof(stdin) )  {
d173 1
a173 1
 *  the remainder are read from stdin.
d192 1
a192 1
		sizeof(union record), ngran-1, stdin);
d224 1
a224 1
	(void)printf( "%c %d %.16s %ld\n",
d232 1
a232 1
		(void)printf( " %ld" , struct_count[j] );
d240 1
a240 1
		if( !fread( (char *)&rec, sizeof record, 1, stdin ) )
d242 1
a242 1
			(void)fprintf( stderr , "Error reading nmg granules\n" );
d251 1
a251 1
				printf( "%02x" , *cp++ );	 /* two hex digits per byte */
d266 2
a267 2
	/* read the rest from stdin */
	if( !fread( (char *)&rec[1], sizeof record, DB_SS_NGRAN-1, stdin ) )
d269 1
a269 1
		(void)fprintf( stderr , "Error reading strsol granules\n" );
d278 1
a278 1
	(void)printf( "%c %.16s %.16s %s\n",
d289 1
a289 1
	(void)printf( "%c %d %.6s\n",
d294 1
a294 1
	(void)printf( "%.72s\n",
d309 3
a311 3
	(void)printf("%c ", record.p.p_id );		/* P */
	(void)printf("%.16s", name(record.p.p_name) );	/* unique name */
	(void)printf("\n");			/* Terminate w/ a newline */
d319 2
a320 2
	(void)printf("%c ", record.q.q_id );		/* Q */
	(void)printf("%d ", record.q.q_count );		/* # of vertices <= 5 */
d323 1
a323 1
			(void)printf("%.12e ", record.q.q_verts[i][j] );
d328 1
a328 1
			(void)printf("%.12e ", record.q.q_norms[i][j] );
d331 1
a331 1
	(void)printf("\n");			/* Terminate w/ a newline */
d339 4
a342 4
	(void)printf("%c ", record.s.s_id );	/* S */
	(void)printf("%d ", record.s.s_type );	/* GED primitive type */
	(void)printf("%.16s ", name(record.s.s_name) );	/* unique name */
	(void)printf("%d ", record.s.s_cgtype );/* COMGEOM solid type */
d344 2
a345 2
		(void)printf("%.12e ", record.s.s_values[i] ); /* parameters */
	(void)printf("\n");			/* Terminate w/ a newline */
d371 6
a376 6
	(void)printf("%c ", DBID_FGP );	/* f */
	(void)printf("%.16s ", name );	/* unique name */
	(void)printf("%.16s ", plt->referenced_solid );	/* name of referenced solid */
	(void)printf("%.12e ", plt->thickness );	/* fgp thickness */
	(void)printf("%d ", plt->mode );		/* fgp mode */
	(void)printf("\n");			/* Terminate w/ a newline */
d405 8
a412 8
	(void)printf("%c ", DBID_BOT );	/* t */
	(void)printf("%.16s ", name );	/* unique name */
	(void)printf("%d ", bot->mode );
	(void)printf("%d ", bot->orientation );
	(void)printf("%d ", bot->error_mode );
	(void)printf("%d ", bot->num_vertices );
	(void)printf("%d ", bot->num_faces );
	(void)printf("\n");
d415 1
a415 1
		printf( "	%d: %26.20e %26.20e %26.20e\n", i, V3ARGS( &bot->vertices[i*3] ) );
d421 1
a421 1
			printf( "	%d: %d %d %d %26.20e\n", i, V3ARGS( &bot->faces[i*3] ),
d425 1
a425 1
		printf( "	%s\n", bu_vls_addr( &vls ) );
d431 1
a431 1
			printf( "	%d: %d %d %d\n", i, V3ARGS( &bot->faces[i*3] ) );
d480 1
a480 1
	printf("%c %.16s\n", DBID_PIPE, name);
d485 1
a485 1
			printf( "%26.20e %26.20e %26.20e %26.20e %26.20e %26.20e\n",
d488 1
a488 1
	printf( "END_PIPE %s\n", name );
d529 1
a529 1
	printf("%c %.16s %26.20e %26.20e %26.20e %26.20e %26.20e %26.20e %26.20e %26.20e\n",
d570 1
a570 1
	fprintf(stdout, "%c %.16s %d\n", 'n', name, arbn->neqn);
d572 1
a572 1
		printf("n %26.20e %20.26e %26.20e %26.20e\n",
d614 2
a615 2
		if( fread( (char *)&mp->r, sizeof(mp->r), 1, stdin ) != 1
		    || feof( stdin ) )
d628 1
a628 1
	(void)printf("%c ", record.c.c_id );		/* C */
d630 1
a630 1
		(void)printf("Y ");			/* Y if `R' */
d632 5
a636 5
		(void)printf("N ");			/* N if ` ' */
	(void)printf("%.16s ", name(record.c.c_name) );	/* unique name */
	(void)printf("%d ", record.c.c_regionid );	/* region ID code */
	(void)printf("%d ", record.c.c_aircode );	/* air space code */
	(void)printf("%d ", mcount );       		/* DEPRECATED: # of members */
d638 1
a638 1
	(void)printf("%d ", 0 );			/* DEPRECATED: COMGEOM region # */
d640 1
a640 1
	(void)printf("%d ", record.c.c_num );           /* DEPRECATED: COMGEOM region # */
d642 3
a644 3
	(void)printf("%d ", record.c.c_material );	/* material code */
	(void)printf("%d ", record.c.c_los );		/* equiv. LOS est. */
	(void)printf("%d %d %d %d ",
d655 1
a655 1
	printf("%d %d ", m1, m2 );
d658 1
a658 1
		printf("%d ", DB_INH_HIGHER );
d662 1
a662 1
		printf("%d ", DB_INH_LOWER );
d665 1
a665 1
	(void)printf("\n");			/* Terminate w/ a newline */
d668 1
a668 1
		(void)printf("%.32s\n", CH(record.c.c_matname) );
d670 1
a670 1
		(void)printf("%.60s\n", CH(record.c.c_matparm) );
d701 3
a703 3
	(void)printf("%c ", rp->M.m_id );		/* M */
	(void)printf("%c ", rp->M.m_relation );	/* Boolean oper. */
	(void)printf("%.16s ", name(rp->M.m_instname) );	/* referred-to obj. */
d705 3
a707 3
		(void)printf("%.12e ", rp->M.m_mat[i] );
	(void)printf("%d ", 0 );			/* was COMGEOM solid # */
	(void)printf("\n");				/* Terminate w/ nl */
d716 14
a729 14
	(void)printf("%c ", record.a.a_id );	/* A */
	(void)printf("%d ", record.a.a_type );	/* primitive type */
	(void)printf("%.16s ", name(record.a.a_name) );	/* unique name */
	(void)printf("%d ", record.a.a_m );	/* # of curves */
	(void)printf("%d ", record.a.a_n );	/* # of points per curve */
	(void)printf("%d ", record.a.a_curlen );/* # of granules per curve */
	(void)printf("%d ", record.a.a_totlen );/* # of granules for ARS */
	(void)printf("%.12e ", record.a.a_xmax );	/* max x coordinate */
	(void)printf("%.12e ", record.a.a_xmin );	/* min x coordinate */
	(void)printf("%.12e ", record.a.a_ymax );	/* max y coordinate */
	(void)printf("%.12e ", record.a.a_ymin );	/* min y coordinate */
	(void)printf("%.12e ", record.a.a_zmax );	/* max z coordinate */
	(void)printf("%.12e ", record.a.a_zmin );	/* min z coordinate */
	(void)printf("\n");			/* Terminate w/ a newline */
d744 5
a748 5
	(void)fread( (char *)&record, sizeof record, 1, stdin );
	(void)printf("%c ", record.b.b_id );		/* B */
	(void)printf("%d ", record.b.b_type );		/* primitive type */
	(void)printf("%d ", record.b.b_n );		/* current curve # */
	(void)printf("%d ", record.b.b_ngranule );	/* current granule */
d750 1
a750 1
		(void)printf("%.12e ", record.b.b_values[i] );
d752 1
a752 1
	(void)printf("\n");			/* Terminate w/ a newline */
d758 1
a758 1
	(void)printf( "%c %d %d %d %d %d %d\n",
d771 1
a771 1
	(void)printf( "%c %.16s %d %.12e\n",
d786 1
a786 1
	(void)printf( "%c %d %d %d %d %d %d %d %d %d\n",
d821 1
a821 1
	count = fread( (char *)fp, 1, nbytes, stdin );
d829 1
a829 1
		(void)printf("%.12e\n", *vp++);
d842 1
a842 1
	count = fread( (char *)fp, 1, nbytes, stdin );
d851 1
a851 1
		(void)printf("%.12e\n", *vp++);
@


11.5
log
@Added fgp solid (FastGen Plate mode)
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.4 1999/06/03 21:54:20 mike Exp $ (BRL)";
d57 1
a57 1
void	arbn_dump(), fgp_dump();
d118 3
d346 59
@


11.4
log
@
sed4
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.3 1998/09/14 15:58:51 bparker Exp $ (BRL)";
d57 1
a57 1
void	arbn_dump();
d115 3
d311 31
@


11.3
log
@*- fix typos
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g2asc.c,v 11.2 1995/08/18 19:24:35 jra Exp $ (BRL)";
d140 1
a140 1
struct rt_external	*ep;
d145 1
a145 1
	RT_INIT_EXTERNAL(ep);
d148 1
a148 1
	ep->ext_buf = (genptr_t)rt_malloc( ep->ext_nbytes, "get_ext ext_buf" );
d180 1
a180 1
	granules = rt_glong(record.nmg.N_count);
d184 1
a184 1
		struct_count[j] = rt_glong( &record.nmg.N_structs[j*4] );
d318 1
a318 1
	struct rt_external	ext;
d321 1
a321 1
	ngranules = rt_glong(record.pwr.pwr_count)+1;
d348 1
a348 1
struct rt_list	*headp;
d357 1
a357 1
	for( RT_LIST_FOR( sp, wdb_pipept, headp ) )  {
d372 1
a372 1
	struct rt_external	ext;
d426 1
a426 1
	struct rt_external	ext;
d429 1
a429 1
	ngranules = rt_glong(record.n.n_grans)+1;
d470 1
a470 1
	struct rt_list	head;
d472 1
a472 1
		struct rt_list	l;
d483 1
a483 1
	RT_LIST_INIT( &head );
d486 1
a486 1
		GETSTRUCT( mp, mchain );
d494 1
a494 1
		RT_LIST_INSERT( &head, &(mp->l) );
d548 1
a548 1
	while( RT_LIST_WHILE( mp, mchain, &head ) )  {
d550 2
a551 2
		RT_LIST_DEQUEUE( &mp->l );
		rt_free( (char *)mp, "mchain");
d556 1
a556 1
		rt_free( (char *)ret_mp, "mchain");
@


11.2
log
@Mods for new pipe solid.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/g2asc.c,v 11.1 1995/01/04 09:59:38 mike Rel4_4 jra $ (BRL)";
d187 1
a187 1
	(void)printf( "%c %d %.16s %d\n",
d195 1
a195 1
		(void)printf( " %d" , struct_count[j] );
@


11.1
log
@Release_4.4
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/g2asc.c,v 10.8 94/11/05 02:40:16 mike Exp $ (BRL)";
d321 2
a322 2
	ngranules = rt_glong(record.pw.pw_count)+1;
	name = record.pw.pw_name;
d348 1
a348 1
struct wdb_pipeseg	*headp;
d351 1
a351 1
	struct wdb_pipeseg	*sp;
d355 1
a355 1
	/* print parameters for each segment: one segment per line */
d357 3
a359 31
	for( RT_LIST_FOR( sp, wdb_pipeseg, &(headp->l) ) )  {
		switch(sp->ps_type)  {
		case WDB_PIPESEG_TYPE_END:
			printf("end %26.20e %26.20e %26.20e %26.20e %26.20e\n",
				sp->ps_id, sp->ps_od,
				sp->ps_start[X],
				sp->ps_start[Y],
				sp->ps_start[Z] );
			break;
		case WDB_PIPESEG_TYPE_LINEAR:
			printf("linear %26.20e %26.20e %26.20e %26.20e %26.20e\n",
				sp->ps_id, sp->ps_od,
				sp->ps_start[X],
				sp->ps_start[Y],
				sp->ps_start[Z] );
			break;
		case WDB_PIPESEG_TYPE_BEND:
			printf("bend %26.20e %26.20e %26.20e %26.20e %26.20e %26.20e %26.20e %26.20e\n",
				sp->ps_id, sp->ps_od,
				sp->ps_start[X],
				sp->ps_start[Y],
				sp->ps_start[Z],
				sp->ps_bendcenter[X],
				sp->ps_bendcenter[Y],
				sp->ps_bendcenter[Z]);
			break;
		default:
			fprintf(stderr, "g2asc: unknown pipe type %d\n",
				sp->ps_type);
			break;
		}
d361 1
@


10.8
log
@Irix 6
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/g2asc.c,v 10.7 94/10/17 16:54:31 mike Exp Locker: mike $ (BRL)";
@


10.7
log
@Added function declarations.
Improved string solid read code slightly.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/g2asc.c,v 10.6 94/10/16 09:33:15 jra Exp Locker: mike $ (BRL)";
a224 1
	int i;
a315 2
	int			count;
	int			ret;
a317 1
	struct wdb_pipeseg	head;		/* actual head, not a ptr. */
d327 1
a327 1
	if( (ret = rt_pipe_import( &intern, &ext, id_mat )) != 0 )  {
a397 2
	int			ret;
	char			*type;
d405 1
a405 1
	if( (ret = rt_part_import( &intern, &ext, id_mat )) != 0 )  {
a418 1
		type = "sphere";
a420 1
		type = "cylinder";
a422 1
		type = "cone";
a449 1
	int		ret;		/* return code catcher */
d462 1
a462 1
	if( (ret = rt_arbn_import( &intern, &ext, id_mat )) != 0 )  {
a495 2
	register int i;
	register int length;	/* Keep track of number of members */
@


10.6
log
@eliminated alloc and free from nmg_dump().
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/g2asc.c,v 10.5 94/10/14 15:43:33 jra Exp Locker: jra $ (BRL)";
d58 2
d231 1
a231 1
	for( i=1 ; i<DB_SS_NGRAN ; i++ )
d233 2
a234 5
		if( !fread( (char *)&rec[i], sizeof record, 1, stdin ) )
		{
			(void)fprintf( stderr , "Error reading strsol granules\n" );
			exit( -1 );
		}
@


10.5
log
@Added support for NMG solids.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/g2asc.c,v 10.4 94/10/14 13:44:38 jra Exp Locker: jra $ (BRL)";
d165 1
a165 1
	union record		*rec;
a179 13
	/* allocate memory to store the granules */
	rec = (union record *)rt_calloc( granules , sizeof( union record ) , "g2asc: nmg: rec" );

	/* Read the records */
	for( i=0 ; i<granules ; i++ )
	{
		if( !fread( (char *)&rec[i], sizeof record, 1, stdin ) )
		{
			(void)fprintf( stderr , "Error reading nmg granules\n" );
			exit( -1 );
		}
	}

d200 7
a207 2
		cp = (char *)&rec[i];

a215 2

	rt_free( (char *)rec , "g2asc: nmg: rec" );
@


10.4
log
@Added support for strsol's.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/g2asc.c,v 10.3 94/08/11 00:02:39 gdurf Exp Locker: jra $ (BRL)";
d104 3
d163 1
a163 1
strsol_dump()	/* print out ebm or vol solid info */
d165 66
d255 1
a255 1
		rec[0].ss.ss_keyword,	/* "ebm" or "vol" */
@


10.3
log
@Added include of conf.h
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/g2asc.c,v 10.2 1993/07/02 08:59:12 stay Exp gdurf $ (BRL)";
d101 3
d157 33
@


10.2
log
@changed RT_LIST to RT_LIST_FOR (somehow this got missed)
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/conv/RCS/g2asc.c,v 10.1 91/10/12 06:41:20 mike Rel4_0 Locker: stay $ (BRL)";
d27 2
@


10.1
log
@Release_4.0
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/g2asc.c,v 9.17 91/09/30 02:22:42 mike Exp $ (BRL)";
d265 1
a265 1
	for( RT_LIST( sp, wdb_pipeseg, &(headp->l) ) )  {
@


9.17
log
@For some reason, the 5d compiler didn't like sizeof(union record) in this
one place.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/g2asc.c,v 9.16 91/09/24 16:59:53 butler Exp Locker: mike $ (BRL)";
@


9.16
log
@fixed condition where variable "type" in routine "particle_dump()" was
used before set.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/g2asc.c,v 9.15 91/09/19 15:38:21 mike Exp Locker: butler $ (BRL)";
d430 1
a430 1
		if( fread( (char *)&mp->r, sizeof(union record), 1, stdin ) != 1
@


9.15
log
@Modified to produce .asc files with valid combination length
numbers.  While BRL software no longer needs them, it turns out
that programs like FRED use .asc format files as input, and
depend on having that length field.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/g2asc.c,v 9.14 91/06/12 21:58:15 mike Exp $ (BRL)";
d338 1
a338 1
		fprintf(stderr, "g2asc: no particle type %s\n", type);
@


9.14
log
@Converted to use LIBRT import/export interface
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/g2asc.c,v 9.13 91/06/12 21:24:55 mike Exp $ (BRL)";
d34 1
a35 1
#include "rtlist.h"
d49 1
a49 1
void	combdump();
d65 1
d76 1
a76 1
			combdump();
d79 1
a79 2
	    		/* Just convert them as they are found.  Assume DB is good */
	    		membdump();
d399 7
d407 1
a407 1
void
d413 8
d422 22
d452 1
a453 1
	(void)printf("%d ", 0 );			/* DEPRECATED: # of members */
a455 1
	(void)printf("%d ", record.c.c_length );        /* DEPRECATED: # of members */
d487 16
d505 6
d512 2
a513 1
membdump()	/* Print out Member record information */
d517 3
a519 3
	(void)printf("%c ", record.M.m_id );		/* M */
	(void)printf("%c ", record.M.m_relation );	/* Boolean oper. */
	(void)printf("%.16s ", name(record.M.m_instname) );	/* referred-to obj. */
d521 1
a521 1
		(void)printf("%.12e ", record.M.m_mat[i] );
@


9.13
log
@lint
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/g2asc.c,v 9.12 91/06/12 21:19:19 mike Exp $ (BRL)";
d36 1
a37 3
#define RT_PARTICLE_TYPE_SPHERE		1
#define RT_PARTICLE_TYPE_CYLINDER	2
#define RT_PARTICLE_TYPE_CONE		3
a38 19
struct	pipe_internal {
	int			pipe_count;
	struct wdb_pipeseg	pipe_segs;
};

struct	part_internal {
	point_t		part_V;
	vect_t		part_H;
	fastf_t		part_vrad;
	fastf_t		part_hrad;
	int		part_type;
};

struct	arbn_internal {
	int		neqn;
	plane_t		*eqn;
};


a48 1
int	_rt_pipe_import(), _rt_part_import(), _rt_arbn_import();
d121 7
d129 26
d224 1
a224 3
	char			id;
	union record		*rp;		/* pointer to an array of granules */
	struct pipe_internal	pipe;		/* want a struct for the head, not a ptr. */
d226 2
a230 1
	id = record.pw.pw_id;
d232 1
a232 5
	/* malloc enough space for ngranules */
	if( (rp = (union record *)malloc(ngranules * sizeof(union record)) ) == 0)  {
		fprintf(stderr, "g2asc: malloc failure\n");
		exit(-1);
	}
d234 3
a236 7
	/* copy the freebee record into the array */
	bcopy( (char *)&record, (char *)rp, sizeof(union record) );

	/* copy ngranules-1 more records into the array */

	if( (count = fread( (char *)&rp[1], sizeof(union record), ngranules - 1, stdin) ) != ngranules - 1)  {
		fprintf(stderr, "g2asc: pipe read failure\n");
d240 2
a241 4
	/* Send this off to _rt_pipe_import() for conversion into machine
	 * dependent format and making of a doubly linked list.  rt_pipe_internal()
	 * fills in the "pipe_internal" structure.
	 */
a242 5
	if( (ret = (_rt_pipe_import(&pipe, rp, id_mat) ) !=0 ) )   {
		fprintf(stderr, "g2asc: pipe_import failure\n" );
		exit(-1);
	}

d247 4
a250 3
	dump_pipe_segs(id, name, &pipe.pipe_segs);
	mk_pipe_free( &pipe.pipe_segs );	/* give back memory */
	free( (char *)rp );
d254 1
a254 2
dump_pipe_segs(id, name, headp)
char			id;
d261 1
a261 1
	printf("%c %.16s\n", id, name);
d299 4
d304 1
a304 1
particle_dump()	/* Print out Particle record information */
d306 5
d312 1
a312 1
	/* Note that particles fit into one granule only. */
d314 2
a315 5
	int			ret;
	char			*type;
	struct part_internal 	part;	/* head for the structure */
	
	if( (ret = (_rt_part_import(&part, &record, id_mat)) ) != 0)  {
d320 3
d327 1
a327 1
	switch( part.part_type )  {
d344 7
a350 7
		part.part_V[X],
		part.part_V[Y],
		part.part_V[Z],
		part.part_H[X],
		part.part_H[Y],
		part.part_H[Z],
		part.part_vrad, part.part_hrad);
a361 1

a362 1
	int		count;
d366 3
a368 3
	char		id;
	union record	*rp;
	struct arbn_internal	arbn;
a371 1
	id = record.n.n_id;
d373 1
a373 5
	/* malloc space for ngranules */
	if( (rp = (union record *) malloc( ngranules * sizeof(union record)) ) == 0)  {
		fprintf( stderr, "g2asc: malloc failure\n");
		exit(-1);
	}
d375 2
a376 10
	/* Copy the freebie (first) record into the array of records.  Then
	 * copy ngranules more. 
	 */
	bcopy( (char *)&record, (char *)rp, sizeof(union record) );
	if( (count = fread( (char *)&rp[1], sizeof(union record), ngranules, stdin) ) != ngranules )  {
		fprintf(stderr, "g2asc: arbn read failure\n");
	}

	/* Hand off the rt's arbn_import() routine */
	if( ret = (_rt_arbn_import(&arbn, rp, id_mat) ) != 0)  {
d381 8
a388 4
	fprintf(stdout, "%c %.16s %d\n", id, name, arbn.neqn);
	for( i = 0; i < arbn.neqn; i++ )  {
		printf("n %26.20e %20.26e %26.20e %26.20e\n", arbn.eqn[i][X], arbn.eqn[i][Y],
			arbn.eqn[i][Z], arbn.eqn[i][3]);
d391 2
a392 1
	free( (char *)rp );
a693 186
}

/*** XXX temporary copy, until formal import library exists ***/
/*
 *			R T _ P I P E _ I M P O R T
 */
int
_rt_pipe_import( pipe, rp, mat )
struct pipe_internal	*pipe;
union record		*rp;
register mat_t		mat;
{
	register struct exported_pipeseg *ep;
	register struct wdb_pipeseg	*psp;
	struct wdb_pipeseg		tmp;

	/* Check record type */
	if( rp->u_id != DBID_PIPE )  {
		fprintf(stderr,"_rt_pipe_import: defective record\n");
		return(-1);
	}

	/* Count number of segments */
	pipe->pipe_count = 0;
	for( ep = &rp->pw.pw_data[0]; ; ep++ )  {
		pipe->pipe_count++;
		switch( (int)(ep->eps_type[0]) )  {
		case WDB_PIPESEG_TYPE_END:
			goto done;
		case WDB_PIPESEG_TYPE_LINEAR:
		case WDB_PIPESEG_TYPE_BEND:
			break;
		default:
			return(-2);	/* unknown segment type */
		}
	}
done:	;
	if( pipe->pipe_count <= 1 )
		return(-3);		/* Not enough for 1 pipe! */

	/*
	 *  Walk the array of segments in reverse order,
	 *  allocating a linked list of segments in internal format,
	 *  using exactly the same structures as libwdb.
	 */
	RT_LIST_INIT( &pipe->pipe_segs.l );
	for( ep = &rp->pw.pw_data[pipe->pipe_count-1]; ep >= &rp->pw.pw_data[0]; ep-- )  {
		tmp.ps_type = (int)ep->eps_type[0];
		ntohd( tmp.ps_start, ep->eps_start, 3 );
		ntohd( &tmp.ps_id, ep->eps_id, 1 );
		ntohd( &tmp.ps_od, ep->eps_od, 1 );

		/* Apply modeling transformations */
		psp = (struct wdb_pipeseg *)calloc( 1, sizeof(struct wdb_pipeseg) );
		psp->ps_type = tmp.ps_type;
		MAT4X3PNT( psp->ps_start, mat, tmp.ps_start );
		if( psp->ps_type == WDB_PIPESEG_TYPE_BEND )  {
			ntohd( tmp.ps_bendcenter, ep->eps_bendcenter, 3 );
			MAT4X3PNT( psp->ps_bendcenter, mat, tmp.ps_bendcenter );
		} else {
			VSETALL( psp->ps_bendcenter, 0 );
		}
		psp->ps_id = tmp.ps_id / mat[15];
		psp->ps_od = tmp.ps_od / mat[15];
		RT_LIST_APPEND( &pipe->pipe_segs.l, &psp->l );
	}

	return(0);			/* OK */
}

/*		R T _ P A R T_ I M P O R T
 *
 */
int
_rt_part_import( part, rp, mat )
struct part_internal	  *part;
union record		  *rp;
register mat_t		  mat;
{
	point_t		  v;
	vect_t		  h;
	double		  vrad;
	double		  hrad;
	fastf_t		  maxrad, minrad;

	/* Check record type */
	if( rp->u_id != DBID_PARTICLE )  {
		fprintf(stderr,"_rt_part_import: defective record\n");
		return(-1);
	}

	/* Convert from database to internal format */
	ntohd( v, rp->part.p_v, 3 );
	ntohd( h, rp->part.p_h, 3 );
	ntohd( &vrad, rp->part.p_vrad, 1 );
	ntohd( &hrad, rp->part.p_hrad, 1 );

	/* Apply modeling transformations */
	MAT4X3PNT( part->part_V, mat, v );
	MAT4X3PNT( part->part_H, mat, h );
	if( (part->part_vrad = vrad / mat[15]) < 0 )
		return(-2);
	if( (part->part_hrad = hrad / mat[15]) < 0 )
		return(-2);

	if( part->part_vrad > part->part_hrad )  {
		maxrad = part->part_vrad;
		minrad = part->part_hrad;
	} else {
		maxrad = part->part_hrad;
		minrad = part->part_vrad;
	}
	if( maxrad <= 0 )
		return(-4);

	if( MAGSQ( part->part_H ) * 1000000 < maxrad * maxrad)  {
		/* Height vector is insignificant, particle is a sphere */
		part->part_vrad = part->part_hrad = maxrad;
		VSETALL( part->part_H, 0 );		 /* sanity */
		part->part_type = RT_PARTICLE_TYPE_SPHERE;
		return(0);		 /* OK */
	}

	if( (maxrad - minrad) / maxrad < 0.001 )  {
		/* radii are nearly equal, particle is a cylinder (lozenge) */
		part->part_vrad = part->part_hrad = maxrad;
		part->part_type = RT_PARTICLE_TYPE_CYLINDER;
		return(0);		 /* OK */
	}

	part->part_type = RT_PARTICLE_TYPE_CONE;
	return(0);		 /* OK */

}

/*		R T _ A R B N _ I M P O R T
 *
 * Cannabalized from the rt library.  For temporary use only, pending
 * the arrival of a formal import library.
 *
 */

int
_rt_arbn_import( aip, rp, mat )
struct arbn_internal	*aip;
union record		*rp;
register mat_t		mat;
{

	register int	i;

	if( rp->u_id != DBID_ARBN )  {
		rt_log("_rt_arbn_import: defective record, id=x%x\n", rp->u_id);
		return(-1);
	}

	aip->neqn = rt_glong(rp->n.n_neqn);
	if( aip->neqn <= 0 )
		return( -1 );
	aip->eqn = (plane_t *)rt_malloc( aip->neqn * sizeof(plane_t), "_rt_arbn_import() planes");
	

	ntohd( (char *)aip->eqn, (char *)(&rp[1]), aip->neqn*4 );

	/* Transform by the matrix */
#	include "noalias.h"
	for( i = 0; i < aip->neqn; i++ )  {
		point_t	orig_pt;
		point_t	pt;
		vect_t	norm;


		/* Pick a point on the original halfspace */
		VSCALE( orig_pt, aip->eqn[i], aip->eqn[i][3] );

		/* Transform the point and the normal */
		MAT4X3VEC( norm, mat, aip->eqn[i] );
		MAT4X3PNT( pt, mat, orig_pt );

		/* Measure new distance from origin to new point */
		VMOVE( aip->eqn[i], norm );
		aip->eqn[i][3] = VDOT( pt, norm );

	}

	return(0);
@


9.12
log
@lint
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/g2asc.c,v 9.11 91/03/05 03:50:55 phil Exp $ (BRL)";
d218 1
a218 1
	ngranules = record.pw.pw_count;
a360 1
	int		neqn;		/* number of plane equations */
d368 1
a368 1
	ngranules = record.n.n_grans;
a370 1
	neqn = record.n.n_neqn;
d372 2
a373 2
	/* malloc space for ngranules + 1 */
	if( (rp = (union record *) malloc( (ngranules + 1) * sizeof(union record)) ) == 0)  {
d392 1
a392 1
	fprintf(stdout, "%c %.16s %d\n", id, name, neqn);
d856 1
a856 1
	aip->neqn = rp->n.n_neqn;
@


9.11
log
@Gave *import routines underscores to keep them from conflicting
with librt.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/g2asc.c,v 9.10 91/02/12 09:30:17 sue Exp $ (BRL)";
d31 1
a64 2

extern void	exit();
@


9.10
log
@Have added arbn support.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/g2asc.c,v 9.8 90/12/07 02:56:59 mike Exp $ (BRL)";
d71 1
a71 1
int	rt_pipe_import(), rt_part_import(), rt_arbn_import();
d239 1
a239 1
	/* Send this off to rt_pipe_import() for conversion into machine
d244 1
a244 1
	if( (ret = (rt_pipe_import(&pipe, rp, id_mat) ) !=0 ) )   {
d315 1
a315 1
	if( (ret = (rt_part_import(&part, &record, id_mat)) ) != 0)  {
d390 1
a390 1
	if( ret = (rt_arbn_import(&arbn, rp, id_mat) ) != 0)  {
d710 1
a710 1
rt_pipe_import( pipe, rp, mat )
d721 1
a721 1
		fprintf(stderr,"rt_pipe_import: defective record\n");
d777 1
a777 1
rt_part_import( part, rp, mat )
d790 1
a790 1
		fprintf(stderr,"rt_part_import: defective record\n");
d846 1
a846 1
rt_arbn_import( aip, rp, mat )
d855 1
a855 1
		rt_log("rt_arbn_import: defective record, id=x%x\n", rp->u_id);
d862 1
a862 1
	aip->eqn = (plane_t *)rt_malloc( aip->neqn * sizeof(plane_t), "rt_arbn_import() planes");
@


9.9
log
@lint
@
text
@d33 1
a34 2
#include "raytrace.h"
#include "externs.h"
d53 6
d65 1
d71 1
d78 1
d125 3
d274 1
a274 1
			printf("end %e %e %e %e %e\n",
d281 1
a281 1
			printf("linear %e %e %e %e %e\n",
d288 1
a288 1
			printf("bend %e %e %e %e %e %e %e %e\n",
d339 1
a339 1
	printf("%c %.16s %e %e %e %e %e %e %e %e\n",
d350 55
d836 53
@


9.8
log
@Expunged m_num
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/g2asc.c,v 9.7 90/12/07 02:24:24 mike Exp $ (BRL)";
d33 1
d35 1
a35 1
#include "rtlist.h"
a59 1
extern void	exit();
@


9.7
log
@Eliminated use of c_length.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/g2asc.c,v 9.6 90/12/05 21:09:25 mike Exp $ (BRL)";
d406 1
a406 1
	(void)printf("%d ", record.M.m_num );		/* COMGEOM solid # */
@


9.6
log
@Pipe routine was calling wrong free subroutine
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/g2asc.c,v 9.5 90/12/05 21:05:33 mike Exp $ (BRL)";
d65 1
d67 2
a68 1
void	soldump(), combdump(), membdump(), arsadump(), arsbdump();
d92 4
d339 4
d358 7
a364 2
	(void)printf("%d ", record.c.c_length );	/* # of members */
	(void)printf("%d ", record.c.c_num );		/* COMGEOM region # */
a393 6

	length = (int)record.c.c_length;	/* Get # of member records */

	for( i = 0; i < length; i++ )  {
		membdump();
	}
a400 2
	/* Read in a member record for processing */
	(void)fread( (char *)&record, sizeof record, 1, stdin );
@


9.5
log
@lint
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/g2asc.c,v 9.4 90/12/05 03:19:48 mike Exp $ (BRL)";
d237 1
a237 1
	mk_freemembers( &pipe.pipe_segs );		/* give back memory */
@


9.4
log
@Minor neatness issue.
This version has been checked against the Release 3.7 version,
and produces the "same" results (modulo a few more warnings,
nicer values in c.c_override [0/1], etc).
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/g2asc.c,v 9.3 90/12/05 02:34:20 mike Exp $ (BRL)";
d238 1
a238 1
	free( rp );
@


9.3
log
@bzero() is handled in machine.h, no rt_log() available here.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/g2asc.c,v 9.2 90/12/05 02:25:56 sue Exp $ (BRL)";
d353 1
a353 1
		record.c.c_override,
@


9.2
log
@Added support for particle solids and pipe solids
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: g2asc.c,v 9.1 89/05/19 05:46:17 mike Rel3_5 $ (BRL)";
a549 11
#ifdef SYSV

bzero( str, n )
register char *str;
register int n;
{
	while( n-- > 0 )
		*str++ = '\0';
}
#endif

d717 1
a717 1
		rt_log("rt_part_import: defective record\n");
@


9.1
log
@Release_3.5
@
text
@d12 1
d24 1
a24 1
static char RCSid[] = "@@(#)$Header: g2asc.c,v 8.2 89/03/06 17:02:59 mike Exp $ (BRL)";
d29 2
d32 3
d36 23
d68 1
d105 6
d190 144
d641 133
@


8.2
log
@ansii
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: g2asc.c,v 8.1 88/10/05 00:25:37 mike Locked $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: g2asc.c,v 7.3 88/05/13 21:25:52 mike Exp $ (BRL)";
a30 1
extern int	printf(), fprintf();
@


7.3
log
@Removed (void) cast on void function calls.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: g2asc.c,v 7.2 88/01/27 02:13:10 mike Locked $ (BRL)";
@


7.2
log
@Added code to handle c_inherit flag field,
and made ASCII form of C record have fixed number of fields,
rather than variable.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: g2asc.c,v 7.1 87/11/02 23:24:10 mike Locked $ (BRL)";
d56 1
a56 1
			(void)soldump();
d59 1
a59 1
			(void)combdump();
d62 1
a62 1
			(void)arsadump();
d65 1
a65 1
			(void)polyhead();
d68 1
a68 1
			(void)polydata();
d71 1
a71 1
			(void)idendump();
d204 1
a204 1
		(void)membdump();
d248 1
a248 1
		(void)arsbdump();
@


7.1
log
@Release 2.3
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: g2asc.c,v 6.1 87/07/11 07:49:46 mike Rel $ (BRL)";
d159 1
d178 1
d180 1
a180 1
		printf("1 ");	/* flag: line 1 follows */
d182 1
a182 1
			printf("2 ");	/* flag: line 2 follows */
d184 10
d196 1
a196 1
	if( isascii(record.c.c_matname[0]) && isprint(record.c.c_matname[0]) )  {
d198 2
a199 3
		if( record.c.c_matparm[0] )
			(void)printf("%.60s\n", CH(record.c.c_matparm) );
	}
d441 1
a441 1
		if( isascii(*ip) && isprint(*ip) )  {
@


6.1
log
@Release 2.0
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: g2asc.c,v 5.1 87/06/24 21:48:59 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: g2asc.c,v 4.2 87/02/12 22:02:51 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: g2asc.c,v 4.1 86/12/29 02:48:28 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: g2asc.c,v 1.14 86/12/03 18:36:43 mike Exp $ (BRL)";
@


1.14
log
@Left room for null.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: g2asc.c,v 1.13 86/12/03 15:34:37 mike Locked $ (BRL)";
@


1.13
log
@Fixed problem with writing out knot vectors.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: g2asc.c,v 1.12 86/11/19 01:07:29 stay Locked $ (BRL)";
d427 1
a427 1
	ep = &buf[len];
@


1.12
log
@Fixed up error printout a bit.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: g2asc.c,v 1.11 86/08/13 06:25:01 kermit Locked $ (BRL)";
d325 1
a325 1
	if( count != 1 )  {
@


1.11
log
@New #include conventions
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: g2asc.c,v 1.10 86/08/02 04:00:32 mike Exp $ (BRL)";
d50 1
a50 1
			fprintf(stderr,"0%o (%c)\n", record.u_id, record.u_id);
d106 2
a107 1
		(void)fprintf(stderr,"File is Version %s, Program is version %s\n",
d319 1
a319 1
		(void)fprintf(stderr, "G2ASC: spline knot malloc error\n");
d326 1
a326 1
		(void)fprintf(stderr, "G2ASC: spline knot read failure\n");
d340 1
a340 1
		(void)fprintf(stderr, "G2ASC: control mesh malloc error\n");
d347 1
a347 1
		(void)fprintf(stderr, "G2ASC: control mesh read failure\n");
d399 2
a400 2
		"g2asc: Illegal char in object name, converted to '%s'\n",
		buf );
d441 2
a442 2
		"g2asc: Illegal char in string, converted to '%s'\n",
		buf );
@


1.10
log
@Further improved by adding checking for other strings
(like material property, database title, etc)
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: g2asc.c,v 1.9 86/08/02 01:36:41 mike Exp $ (BRL)";
d28 1
a28 1
#include "../h/db.h"
d359 1
a359 1
#ifndef BSD42
@


1.9
log
@Added code to convert database names, valid or not,
to vaid output names free of unprintable characters,
and of the proper length.  Null names are suitably treated.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: g2asc.c,v 1.8 86/07/31 05:10:34 mike Exp $ (BRL)";
d34 2
d98 1
a98 1
		record.i.i_version		/* version */
d101 1
a101 1
		record.i.i_title	/* title or description */
d176 1
a176 1
	if( record.c.c_matname[0] )  {
d183 2
a184 2
	if( record.c.c_matname[0] )  {
		(void)printf("%.32s\n", record.c.c_matname );
d186 1
a186 1
			(void)printf("%.60s\n", record.c.c_matparm );
d387 1
a387 1
		if( isprint(*ip) && !isspace(*ip) )  {
d398 2
a399 2
		"g2asc: Illegal char in object name.  '%s' converted to '%s'\n",
		str, buf );
d406 42
@


1.8
log
@Addition of length limiting formats for %s to %.42s types,
changes %.9e to %.12e
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: g2asc.c,v 1.7 86/07/27 17:31:45 mike Exp $ (BRL)";
d26 2
a27 1
#include	<stdio.h>
d33 2
d48 1
a48 1
	    		fprintf(stderr,"0%o (%c)\n", record.u_id, record.u_id);
d50 2
a51 1
		if( record.u_id == ID_FREE )  {
d53 1
a53 2
		}
		if( record.u_id == ID_SOLID )  {
d55 2
a56 2
		}
		else if( record.u_id == ID_COMB )  {
d58 2
a59 2
		}
		else if( record.u_id == ID_ARS_A )  {
d61 2
a62 2
		}
		else if( record.u_id == ID_P_HEAD )  {
d64 2
a65 2
		}
		else if( record.u_id == ID_P_DATA )  {
d67 2
a68 2
		}
		else if( record.u_id == ID_IDENT )  {
d70 2
a71 2
		}
		else if( record.u_id == ID_MATERIAL )  {
d73 2
a74 2
		}
		else if( record.u_id == ID_BSOLID )  {
d76 2
a77 2
		}
		else if( record.u_id == ID_BSURF )  {
d79 6
a85 4
		else  {
			(void)fprintf(stderr,"G2ASC: bad record type\n");
			exit(1);
		}
d87 1
a87 1
	return(0);
d113 1
a113 1
	(void)printf("%.16s", record.p.p_name );	/* unique name */
d144 1
a144 1
	(void)printf("%.16s ", record.s.s_name );	/* unique name */
d162 1
a162 1
	(void)printf("%.16s ", record.c.c_name );	/* unique name */
d203 1
a203 1
	(void)printf("%.16s ", record.M.m_instname );	/* referred-to obj. */
d218 1
a218 1
	(void)printf("%.16s ", record.a.a_name );	/* unique name */
d273 1
a273 1
		record.B.B_name,	/* unique name */
d367 40
@


1.7
log
@Converted to stdio, added debugging flag
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: g2asc.c,v 1.6 86/07/27 17:22:20 mike Exp $ (BRL)";
d88 1
a88 1
	(void)printf( "%c %d %s\n",
d93 1
a93 1
	(void)printf( "%s\n",
d108 1
a108 1
	(void)printf("%s", record.p.p_name );		/* unique name */
d121 1
a121 1
			(void)printf("%.9e ", record.q.q_verts[i][j] );
d126 1
a126 1
			(void)printf("%.9e ", record.q.q_norms[i][j] );
d139 1
a139 1
	(void)printf("%s ", record.s.s_name );	/* unique name */
d142 1
a142 1
		(void)printf("%.9e ", record.s.s_values[i] ); /* parameters */
d157 1
a157 1
	(void)printf("%s ", record.c.c_name );		/* unique name */
d177 1
a177 1
		(void)printf("%s\n", record.c.c_matname );
d179 1
a179 1
			(void)printf("%s\n", record.c.c_matparm );
d198 1
a198 1
	(void)printf("%s ", record.M.m_instname );	/* referred-to obj. */
d200 1
a200 1
		(void)printf("%.9e ", record.M.m_mat[i] );
d213 1
a213 1
	(void)printf("%s ", record.a.a_name );	/* unique name */
d218 6
a223 6
	(void)printf("%.9e ", record.a.a_xmax );	/* max x coordinate */
	(void)printf("%.9e ", record.a.a_xmin );	/* min x coordinate */
	(void)printf("%.9e ", record.a.a_ymax );	/* max y coordinate */
	(void)printf("%.9e ", record.a.a_ymin );	/* min y coordinate */
	(void)printf("%.9e ", record.a.a_zmax );	/* max z coordinate */
	(void)printf("%.9e ", record.a.a_zmin );	/* min z coordinate */
d245 1
a245 1
		(void)printf("%.9e ", record.b.b_values[i] );
d266 1
a266 1
	(void)printf( "%c %s %d %.9e\n",
d324 1
a324 1
		(void)printf("%.9e\n", *vp++);
d346 1
a346 1
		(void)printf("%.9e\n", *vp++);
@


1.6
log
@Added bzero for non-bsd
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: g2asc.c,v 1.5 86/06/12 20:26:15 mike Exp $ (BRL)";
a29 1
extern int	close(), creat(), open(), read(), write();
a30 1
extern long	lseek();
d38 2
a39 1
main()
d42 4
a45 2
	while( read( 0, (char*)&record, sizeof record ) > 0 )  {

d195 1
a195 2
	(void)read( 0, (char*)&record, sizeof record );

d239 1
a239 2
	(void)read( 0, (char*)&record, sizeof record );

d316 2
a317 2
	count =	read( 0, (char*)fp, nbytes );
	if( count != nbytes )  {
d337 1
a337 1
	count =	read( 0, (char*)fp, nbytes );
@


1.5
log
@Added handling for c_matname, etc.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: g2asc.c,v 1.4 86/03/26 01:04:21 mike Exp $ (BRL)";
d352 11
@


1.4
log
@This version supports the new spline solid,
plus some efficiency improvements, thanks to Kermit.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: g2asc.c,v 1.3 85/06/03 16:58:58 mike Exp $ (BRL)";
d163 10
d174 6
@


1.3
log
@New version without branch name sillyness.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: g2asc.c,v 1.2 85/03/26 13:36:48 mike Exp $ (BRL)";
d36 1
a36 1
void	materdump();
a38 1
int	count;				/* Number of records */
a41 2
	count = 0;

a43 1
		count++;
d70 6
d87 8
a94 6
	(void)printf("%c ", record.i.i_id );		/* I */
	(void)printf("%d ", record.i.i_units );		/* units */
	(void)printf("%s ", record.i.i_version );	/* version */
	(void)printf("\n");			/* Terminate w/ a newline */
	(void)printf("%s", record.i.i_title );		/* title or description */
	(void)printf("\n");			/* Terminate w/ a newline */
d98 2
a99 2
			(void)fprintf(stderr,"File is Version %s, Program is version %s\n",
				record.i.i_version, ID_VERSION );
d236 1
a236 1
materdump()
d238 5
a242 5
	(void)printf( "%c %d %d %d %d %d %d %s\n",
		record.md.md_id,
		record.md.md_flags,
		record.md.md_low,
		record.md.md_hi,
d244 1
a244 1
		record.md.md_g,
d246 89
@


1.2
log
@Working version
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: g2asc.c,v 1.1 85/03/08 21:23:34 mike Exp $ (BRL)";
a28 2
#define NONAME	"NoNaMe"		/* For null string names */

d75 1
a75 1
			(void)fprintf(stderr,"VG2ASC: bad record type\n");
a177 1
	(void)printf("%s ", record.M.m_brname[0] ? record.M.m_brname : NONAME );	/* name of branch */
@


1.1
log
@Initial revision
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
a30 2
extern void	idendump(), polyhead(), polydata();
extern void	soldump(), combdump(), membdump(), arsadump(), arsbdump();
d36 5
a40 1
static union record	record;		/* GED database record */
d73 3
d232 13
@
