head	11.24;
access;
symbols
	ansi-20040405-merged:11.11.2.2
	postmerge-20040405-ansi:11.22
	premerge-20040404-ansi:11.22
	postmerge-autoconf:11.22
	autoconf-freeze:11.21.2.1
	premerge-autoconf:11.22
	ansi-20040316-freeze:11.11.2.1
	postmerge-20040315-windows:11.22
	premerge-20040315-windows:11.22
	windows-20040315-freeze:11.11.4.1
	autoconf-20031203:11.21.2.1
	autoconf-20031202:11.21
	autoconf-branch:11.21.0.2
	phong-branch:11.20.0.2
	photonmap-branch:11.15.0.2
	rel-6-1-DP:11.12
	windows-branch:11.11.0.4
	rel-6-0-2:11.9
	ansi-branch:11.11.0.2
	rel-6-0-1-branch:11.9.0.2
	hartley-6-0-post:11.10
	hartley-6-0-pre:11.9
	rel-6-0-1:11.9
	rel-6-0:11.9
	rel-5-4:11.7
	offsite-5-3-pre:11.9
	rel-5-3:11.7
	rel-5-2:11.7
	rel-5-1-branch:11.7.0.2
	rel-5-1:11.7
	rel-5-0:11.6
	rel-5-0-beta:11.5
	rel-4-5:11.5
	ctj-4-5-post:11.5
	ctj-4-5-pre:11.5
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.24
date	2004.05.24.04.16.11;	author morrison;	state dead;
branches;
next	11.23;

11.23
date	2004.05.10.15.30.41;	author erikg;	state Exp;
branches;
next	11.22;

11.22
date	2003.10.23.19.54.38;	author jra;	state Exp;
branches;
next	11.21;

11.21
date	2003.09.17.00.16.56;	author jra;	state Exp;
branches
	11.21.2.1;
next	11.20;

11.20
date	2003.09.05.17.24.50;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	2003.08.25.13.24.48;	author jra;	state Exp;
branches;
next	11.18;

11.18
date	2003.08.25.13.15.35;	author jra;	state Exp;
branches;
next	11.17;

11.17
date	2003.08.21.20.23.53;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	2003.08.20.13.11.54;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	2003.02.13.14.38.44;	author jra;	state Exp;
branches
	11.15.2.1;
next	11.14;

11.14
date	2003.02.11.20.53.55;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	2003.02.11.20.52.58;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	2002.10.15.19.06.14;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	2002.08.20.17.07.20;	author jra;	state Exp;
branches
	11.11.2.1
	11.11.4.1;
next	11.10;

11.10
date	2002.08.15.20.54.33;	author hartley;	state Exp;
branches;
next	11.9;

11.9
date	2000.10.19.19.19.44;	author butler;	state Exp;
branches;
next	11.8;

11.8
date	2000.07.12.21.59.34;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	2000.03.29.18.07.43;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	99.06.03.21.54.19;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	97.03.05.19.58.57;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	96.10.25.15.56.26;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.11.30.15.21.39;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.04.07.16.53.12;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.59.24;	author mike;	state Rel4_4;
branches;
next	1.6;

1.6
date	94.10.31.13.52.58;	author jra;	state Exp;
branches;
next	1.5;

1.5
date	94.08.10.23.48.37;	author gdurf;	state Exp;
branches;
next	1.4;

1.4
date	94.07.13.12.20.52;	author jra;	state Exp;
branches;
next	1.3;

1.3
date	94.03.18.12.39.37;	author jra;	state Exp;
branches;
next	1.2;

1.2
date	93.10.20.12.12.26;	author jra;	state Exp;
branches;
next	1.1;

1.1
date	93.10.20.10.13.49;	author jra;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	93.10.21.14.14.44;	author jra;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	93.10.21.15.33.46;	author jra;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	93.12.09.09.52.56;	author jra;	state Exp;
branches;
next	;

11.11.2.1
date	2002.09.19.18.00.35;	author morrison;	state Exp;
branches;
next	11.11.2.2;

11.11.2.2
date	2004.03.17.21.15.55;	author morrison;	state Exp;
branches;
next	;

11.11.4.1
date	2004.03.11.23.40.29;	author morrison;	state Exp;
branches;
next	;

11.15.2.1
date	2003.08.26.14.03.20;	author justin;	state Exp;
branches;
next	;

11.21.2.1
date	2003.12.03.16.24.02;	author erikg;	state Exp;
branches;
next	;


desc
@Converter from Autocad's DXF format to BRLCAD .g format
@


11.24
log
@moved to src/conv/
@
text
@#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "wdb.h"

#include <ctype.h>

struct insert_data {
	fastf_t scale[3];
	fastf_t rotation;
	point_t insert_pt;
	vect_t extrude_dir;
};

struct state_data {
	struct bu_list l;
	struct block_list *curr_block;
	long file_offset;
	int state;
	int sub_state;
	mat_t xform;
};

static struct bu_list state_stack;
static struct state_data *curr_state;
static int curr_color=7;
static int ignore_colors=0;
static char *curr_layer_name;
static int color_by_layer=0;		/* flag, if set, colors are set by layer */

struct layer {
	char *name;			/* layer name */
	int color_number;		/* color */
	struct vert_root *vert_tree_root; /* root of vertex tree */
	int *part_tris;			/* list of triangles for current part */
	int max_tri;			/* number of triangles currently malloced */
	int curr_tri;			/* number of triangles currently being used */
	int line_count;
	int point_count;
	struct bu_ptbl solids;
	struct model *m;
	struct shell *s;
};

struct block_list {
	struct bu_list l;
	char *block_name;
	long offset;
	char handle[17];
	point_t base;
};

static struct bu_list block_head;
static struct block_list *curr_block=NULL;

static struct layer **layers=NULL;
static int max_layers;
static int next_layer;
static int curr_layer;

/* SECTIONS (states) */
#define UNKNOWN_SECTION		0
#define HEADER_SECTION		1
#define CLASSES_SECTION		2
#define TABLES_SECTION		3
#define BLOCKS_SECTION		4
#define ENTITIES_SECTION	5
#define OBJECTS_SECTION		6
#define THUMBNAILIMAGE_SECTION	7
#define NUM_SECTIONS		8

/* states for the ENTITIES section */
#define UNKNOWN_ENTITY_STATE		0
#define POLYLINE_ENTITY_STATE		1
#define POLYLINE_VERTEX_ENTITY_STATE	2
#define FACE3D_ENTITY_STATE		3
#define LINE_ENTITY_STATE		4
#define INSERT_ENTITY_STATE		5
#define POINT_ENTITY_STATE		6
#define CIRCLE_ENTITY_STATE		7
#define	ARC_ENTITY_STATE		8
#define DIMENSION_ENTITY_STATE		9
#define NUM_ENTITY_STATES		10

/* POLYLINE flags */
static int polyline_flag=0;
#define POLY_CLOSED		1
#define POLY_CURVE_FIT		2
#define POLY_SPLINE_FIT		4
#define	POLY_3D			8
#define	POLY_3D_MESH		16
#define	POLY_CLOSED_MESH	32
#define POLY_FACE_MESH		64
#define	POLY_PATTERN		128

/* POLYLINE VERTEX flags */
#define POLY_VERTEX_EXTRA	1
#define POLY_VERTEX_CURVE	2
#define POLY_VERTEX_SPLINE_V	8
#define POLY_VERTEX_SPLINE_C	16
#define POLY_VERTEX_3D_V	32
#define POLY_VERTEX_3D_M	64
#define POLY_VERTEX_FACE	128

/* states for the TABLES section */
#define UNKNOWN_TABLE_STATE	0
#define LAYER_TABLE_STATE	1
#define NUM_TABLE_STATES	2

static fastf_t *polyline_verts=NULL;
static int polyline_vertex_count=0;
static int polyline_vertex_max=0;
static int mesh_m_count=0;
static int mesh_n_count=0;
static int *polyline_vert_indices=NULL;
static int polyline_vert_indices_count=0;
static int polyline_vert_indices_max=0;
#define PVINDEX( _i, _j )	((_i)*mesh_n_count + (_j))
#define POLYLINE_VERTEX_BLOCK	10

static point_t pts[4];

#define UNKNOWN_ENTITY	0
#define POLYLINE_VERTEX		1

static int invisible=0;

#define ERROR_FLAG	-999
#define EOF_FLAG	-998

#define TOL_SQ	0.00001
#define LINELEN	2050
char line[LINELEN];

static char *usage="dxf-g [-d] [-v] [-t tolerance] [-s scale_factor] input_dxf_file output_file.g\n";

static FILE *dxf;
static struct rt_wdb *out_fp;
static char *output_file;
static char *dxf_file;
static int verbose=0;
static fastf_t tol=0.01;
static fastf_t tol_sq;
static char *base_name;
static char tmp_name[256];
static int segs_per_circle=32;
static fastf_t sin_delta, cos_delta;
static fastf_t delta_angle;
static point_t *circle_pts;
static fastf_t scale_factor;

#define TRI_BLOCK 512			/* number of triangles to malloc per call */

static int (*process_code[NUM_SECTIONS])( int code );
static int (*process_entities_code[NUM_ENTITY_STATES])( int code );
static int (*process_tables_sub_code[NUM_TABLE_STATES])( int code );

static int *int_ptr=NULL;
static int units=0;
static fastf_t units_conv[]={
	/* 0 */	1.0,
	/* 1 */	25.4,
	/* 2 */	304.8,
	/* 3 */	1609344.0,
	/* 4 */	1.0,
	/* 5 */	10.0,
	/* 6 */	1000.0,
	/* 7 */	1000000.0,
	/* 8 */	0.0000254,
	/* 9 */	0.0254,
	/* 10 */ 914.4,
	/* 11 */ 1.0e-7,
	/* 12 */ 1.0e-6,
	/* 13 */ 1.0e-3,
	/* 14 */ 100.0,
	/* 15 */ 10000.0,
	/* 16 */ 100000.0,
	/* 17 */ 1.0e+12,
	/* 18 */ 1.495979e+14,
	/* 19 */ 9.460730e+18,
	/* 20 */ 3.085678e+19
};

static unsigned char rgb[]={
	0, 0, 0,
	255, 0, 0,
	255, 255, 0,
	0, 255, 0,
	0, 255, 255,
	0, 0, 255,
	255, 0, 255,
	255, 255, 255,
	65, 65, 65,
	128, 128, 128,
	255, 0, 0,
	255, 128, 128,
	166, 0, 0,
	166, 83, 83,
	128, 0, 0,
	128, 64, 64,
	77, 0, 0,
	77, 38, 38,
	38, 0, 0,
	38, 19, 19,
	255, 64, 0,
	255, 159, 128,
	166, 41, 0,
	166, 104, 83,
	128, 32, 0,
	128, 80, 64,
	77, 19, 0,
	77, 48, 38,
	38, 10, 0,
	38, 24, 19,
	255, 128, 0,
	255, 191, 128,
	166, 83, 0,
	166, 124, 83,
	128, 64, 0,
	128, 96, 64,
	77, 38, 0,
	77, 57, 38,
	38, 19, 0,
	38, 29, 19,
	255, 191, 0,
	255, 223, 128,
	166, 124, 0,
	166, 145, 83,
	128, 96, 0,
	128, 112, 64,
	77, 57, 0,
	77, 67, 38,
	38, 29, 0,
	38, 33, 19,
	255, 255, 0,
	255, 255, 128,
	166, 166, 0,
	166, 166, 83,
	128, 128, 0,
	128, 128, 64,
	77, 77, 0,
	77, 77, 38,
	38, 38, 0,
	38, 38, 19,
	191, 255, 0,
	223, 255, 128,
	124, 166, 0,
	145, 166, 83,
	96, 128, 0,
	112, 128, 64,
	57, 77, 0,
	67, 77, 38,
	29, 38, 0,
	33, 38, 19,
	128, 255, 0,
	191, 255, 128,
	83, 166, 0,
	124, 166, 83,
	64, 128, 0,
	96, 128, 64,
	38, 77, 0,
	57, 77, 38,
	19, 38, 0,
	29, 38, 19,
	64, 255, 0,
	159, 255, 128,
	41, 166, 0,
	104, 166, 83,
	32, 128, 0,
	80, 128, 64,
	19, 77, 0,
	48, 77, 38,
	10, 38, 0,
	24, 38, 19,
	0, 255, 0,
	128, 255, 128,
	0, 166, 0,
	83, 166, 83,
	0, 128, 0,
	64, 128, 64,
	0, 77, 0,
	38, 77, 38,
	0, 38, 0,
	19, 38, 19,
	0, 255, 64,
	128, 255, 159,
	0, 166, 41,
	83, 166, 104,
	0, 128, 32,
	64, 128, 80,
	0, 77, 19,
	38, 77, 48,
	0, 38, 10,
	19, 38, 24,
	0, 255, 128,
	128, 255, 191,
	0, 166, 83,
	83, 166, 124,
	0, 128, 64,
	64, 128, 96,
	0, 77, 38,
	38, 77, 57,
	0, 38, 19,
	19, 38, 29,
	0, 255, 191,
	128, 255, 223,
	0, 166, 124,
	83, 166, 145,
	0, 128, 96,
	64, 128, 112,
	0, 77, 57,
	38, 77, 67,
	0, 38, 29,
	19, 38, 33,
	0, 255, 255,
	128, 255, 255,
	0, 166, 166,
	83, 166, 166,
	0, 128, 128,
	64, 128, 128,
	0, 77, 77,
	38, 77, 77,
	0, 38, 38,
	19, 38, 38,
	0, 191, 255,
	128, 223, 255,
	0, 124, 166,
	83, 145, 166,
	0, 96, 128,
	64, 112, 128,
	0, 57, 77,
	38, 67, 77,
	0, 29, 38,
	19, 33, 38,
	0, 128, 255,
	128, 191, 255,
	0, 83, 166,
	83, 124, 166,
	0, 64, 128,
	64, 96, 128,
	0, 38, 77,
	38, 57, 77,
	0, 19, 38,
	19, 29, 38,
	0, 64, 255,
	128, 159, 255,
	0, 41, 166,
	83, 104, 166,
	0, 32, 128,
	64, 80, 128,
	0, 19, 77,
	38, 48, 77,
	0, 10, 38,
	19, 24, 38,
	0, 0, 255,
	128, 128, 255,
	0, 0, 166,
	83, 83, 166,
	0, 0, 128,
	64, 64, 128,
	0, 0, 77,
	38, 38, 77,
	0, 0, 38,
	19, 19, 38,
	64, 0, 255,
	159, 128, 255,
	41, 0, 166,
	104, 83, 166,
	32, 0, 128,
	80, 64, 128,
	19, 0, 77,
	48, 38, 77,
	10, 0, 38,
	24, 19, 38,
	128, 0, 255,
	191, 128, 255,
	83, 0, 166,
	124, 83, 166,
	64, 0, 128,
	96, 64, 128,
	38, 0, 77,
	57, 38, 77,
	19, 0, 38,
	29, 19, 38,
	191, 0, 255,
	223, 128, 255,
	124, 0, 166,
	145, 83, 166,
	96, 0, 128,
	112, 64, 128,
	57, 0, 77,
	67, 38, 77,
	29, 0, 38,
	33, 19, 38,
	255, 0, 255,
	255, 128, 255,
	166, 0, 166,
	166, 83, 166,
	128, 0, 128,
	128, 64, 128,
	77, 0, 77,
	77, 38, 77,
	38, 0, 38,
	38, 19, 38,
	255, 0, 191,
	255, 128, 223,
	166, 0, 124,
	166, 83, 145,
	128, 0, 96,
	128, 64, 112,
	77, 0, 57,
	77, 38, 67,
	38, 0, 29,
	38, 19, 33,
	255, 0, 128,
	255, 128, 191,
	166, 0, 83,
	166, 83, 124,
	128, 0, 64,
	128, 64, 96,
	77, 0, 38,
	77, 38, 57,
	38, 0, 19,
	38, 19, 29,
	255, 0, 64,
	255, 128, 159,
	166, 0, 41,
	166, 83, 104,
	128, 0, 32,
	128, 64, 80,
	77, 0, 19,
	77, 38, 48,
	38, 0, 10,
	38, 19, 24,
	84, 84, 84,
	118, 118, 118,
	152, 152, 152,
	187, 187, 187,
	221, 221, 221,
	255, 255, 255 };


static char *
make_brlcad_name( char *line )
{
	char *name;
	char *c;

	name = bu_strdup( line );

	c = name;
	while( *c != '\0' ) {
		if( *c == '/' || *c == '[' || *c == ']' || *c == '*' || isspace( *c ) ) {
			*c = '_';
		}
		c++;
	}

	return( name );
}

static void
get_layer()
{
	int i;
	int old_layer=curr_layer;

	/* do we already have a layer by this name and color */
	curr_layer = -1;
	for( i = 1 ; i < next_layer ; i++ ) {
		if( !color_by_layer && !ignore_colors ) {
			if( layers[i]->color_number == curr_color && !strcmp( curr_layer_name, layers[i]->name ) ) {
				curr_layer = i;
				break;
			}
		} else {
			if( !strcmp( curr_layer_name, layers[i]->name ) ) {
				curr_layer = i;
				break;
			}
		}
	}

	if( curr_layer == -1 ) {
		/* add a new layer */
		if( next_layer >= max_layers ) {
			if( verbose ) {
				bu_log( "Creating new block of layers\n" );
			}
			max_layers += 5;
			layers = (struct layer **)bu_realloc( layers,
					    max_layers*sizeof( struct layer *), "layers" );
			for( i=0 ; i<5 ; i++ ) {
				BU_GETSTRUCT( layers[max_layers-i-1], layer );
			}
		}
		curr_layer = next_layer++;
		if( verbose ) {
			bu_log( "New layer: %s, color number: %d", line, curr_color );
		}
		layers[curr_layer]->name = bu_strdup( curr_layer_name );
		layers[curr_layer]->vert_tree_root = create_vert_tree();
		layers[curr_layer]->color_number = curr_color;
		bu_ptbl_init( &layers[curr_layer]->solids, 8, "layers[curr_layer]->solids" );
		if( verbose ) {
			bu_log( "\tNew layer name: %s\n", layers[curr_layer]->name );
		}
	}

	if( verbose && curr_layer != old_layer ) {
		bu_log( "changed to layer #%d, (m = x%x, s=x%x)\n", curr_layer, layers[curr_layer]->m, layers[curr_layer]->s );
	}
}

static void
create_nmg()
{
	struct model *m;
	struct nmgregion *r;

	m = nmg_mm();
	r = nmg_mrsv( m );
	layers[curr_layer]->s = BU_LIST_FIRST( shell, &r->s_hd );
	layers[curr_layer]->m = m;
}

/* routine to add a new triangle to the current part */
void
add_triangle( int v1, int v2, int v3, int layer )
{
	if( verbose ) {
		bu_log( "Adding triangle %d %d %d, to layer %s\n", v1, v2, v3, layers[layer]->name );
	}
	if( v1 == v2 || v2 == v3 || v3 == v1 ) {
		if( verbose ) {
			bu_log( "\tSkipping degenerate triangle\n" );
		}
		return;
	}
	if( layers[layer]->curr_tri >= layers[layer]->max_tri ) {
		/* allocate more memory for triangles */
		layers[layer]->max_tri += TRI_BLOCK;
		layers[layer]->part_tris = (int *)realloc( layers[layer]->part_tris,
							  sizeof( int ) * layers[layer]->max_tri * 3 );
		if( !layers[layer]->part_tris ) {
			bu_log( "ERROR: Failed to allocate memory for part triangles on layer %s\n",
				 layers[layer]->name);
			exit( 1 );
		}
	}

	/* fill in triangle info */
	layers[layer]->part_tris[layers[layer]->curr_tri*3 + 0] = v1;
	layers[layer]->part_tris[layers[layer]->curr_tri*3 + 1] = v2;
	layers[layer]->part_tris[layers[layer]->curr_tri*3 + 2] = v3;

	/* increment count */
	layers[layer]->curr_tri++;
}

static int
process_unknown_code( int code )
{
	switch( code ) {
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 0:		/* text string */
		if( !strncmp( line, "SECTION", 7 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		} else if( !strncmp( line, "ENDSEC", 6 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		}
		break;
	case 2:		/* name */
		if( !strncmp( line, "HEADER", 6 ) ) {
			curr_state->state = HEADER_SECTION;
			if( verbose ) {
				bu_log( "Change state to %d\n", curr_state->state );
			}
			break;
		} else if( !strncmp( line, "CLASSES", 7 ) ) {
			curr_state->state = CLASSES_SECTION;
			if( verbose ) {
				bu_log( "Change state to %d\n", curr_state->state );
			}
			break;
		} else if( !strncmp( line, "TABLES", 6 ) ) {
			curr_state->state = TABLES_SECTION;
			curr_state->sub_state = UNKNOWN_TABLE_STATE;
			if( verbose ) {
				bu_log( "Change state to %d\n", curr_state->state );
			}
			break;
		} else if( !strncmp( line, "BLOCKS", 6 ) ) {
			curr_state->state = BLOCKS_SECTION;
			if( verbose ) {
				bu_log( "Change state to %d\n", curr_state->state );
			}
			break;
		} else if( !strncmp( line, "ENTITIES", 8 ) ) {
			curr_state->state = ENTITIES_SECTION;
			curr_state->sub_state =UNKNOWN_ENTITY_STATE; 
			if( verbose ) {
				bu_log( "Change state to %d\n", curr_state->state );
			}
			break;
		} else if( !strncmp( line, "OBJECTS", 7 ) ) {
			curr_state->state = OBJECTS_SECTION;
			if( verbose ) {
				bu_log( "Change state to %d\n", curr_state->state );
			}
			break;
		} else if( !strncmp( line, "THUMBNAILIMAGE", 14 ) ) {
			curr_state->state = THUMBNAILIMAGE_SECTION;
			if( verbose ) {
				bu_log( "Change state to %d\n", curr_state->state );
			}
			break;
		}
		break;
	case 62:	/* color number */
		curr_color = atoi( line );
		break;
		}
	return( 0 );
}

static int
process_header_code( int code )
{
	switch( code ) {
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 0:		/* text string */
		if( !strncmp( line, "SECTION", 7 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		} else if( !strncmp( line, "ENDSEC", 6 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		}
		break;
	case 9:		/* variable name */
		if( !strncmp( line, "$INSUNITS", 9 ) ) {
			int_ptr = &units;
		} else if( !strcmp( line, "$CECOLOR" ) ) {
			int_ptr = &color_by_layer;
		}
		break;
	case 70:
	case 62:
		if( int_ptr ) {
			(*int_ptr) = atoi( line );
		}
		int_ptr = NULL;
		break;
	}
		
	return( 0 );
}

static int
process_classes_code( int code )
{
	switch( code ) {
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 0:		/* text string */
		if( !strncmp( line, "SECTION", 7 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		} else if( !strncmp( line, "ENDSEC", 6 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		}
		break;
	}
		
	return( 0 );
}

static int
process_tables_unknown_code( int code )
{

	switch( code ) {
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 0:		/* text string */
		if( !strcmp( line, "LAYER" ) ) {
			if( curr_layer_name ) {
				bu_free( curr_layer_name, "cur_layer_name" );
				curr_layer_name = NULL;
			}
			curr_color = 0;
			curr_state->sub_state = LAYER_TABLE_STATE;
			break;
		} else if( !strcmp( line, "ENDTAB" ) ) {
			if( curr_layer_name ) {
				bu_free( curr_layer_name, "cur_layer_name" );
				curr_layer_name = NULL;
			}
			curr_color = 0;
			curr_state->sub_state = UNKNOWN_TABLE_STATE;
			break;
		} else if( !strncmp( line, "SECTION", 7 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		} else if( !strncmp( line, "ENDSEC", 6 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		}
		break;
	}
		
	return( 0 );
}

static int
process_tables_layer_code( int code )
{
	switch( code ) {
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 2:		/* layer name */
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "curr_layer_name" );
		}
		curr_layer_name = make_brlcad_name( line );
		break;
	case 62:	/* layer color */
		curr_color = atoi( line );
		break;
	case 0:		/* text string */
		if( color_by_layer ) {
			if( curr_layer_name && curr_color ) {
				get_layer();
			}
		}

		if( curr_layer_name ) {
			bu_free( curr_layer_name, "cur_layer_name" );
			curr_layer_name = NULL;
		}
		curr_color = 0;
		curr_state->sub_state = UNKNOWN_TABLE_STATE;
		return( process_tables_unknown_code( code ) );
	}
		
	return( 0 );
}

static int
process_tables_code( int code )
{
	return( process_tables_sub_code[curr_state->sub_state]( code ) );
}

static int
process_blocks_code( int code )
{
	int len;
	int coord;

	switch( code ) {
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 0:		/* text string */
		if( !strncmp( line, "SECTION", 7 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		} else if( !strncmp( line, "ENDSEC", 6 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		} else if( !strcmp( line, "ENDBLK" ) ) {
			curr_block = NULL;
			break;
		} else if( !strncmp( line, "BLOCK", 5 ) ) {
			/* start of a new block */
			BU_GETSTRUCT( curr_block, block_list );
			curr_block->offset = ftell( dxf );
			BU_LIST_INSERT( &(block_head), &(curr_block->l) );
			break;
		}
		break;
	case 2:		/* block name */
		if( curr_block ) {
			curr_block->block_name = bu_strdup( line );
			if( verbose ) {
				bu_log( "BLOCK %s begins at %ld\n",
					curr_block->block_name,
					curr_block->offset );
			}
		}
		break;
	case 5:		/* block handle */
		if( curr_block ) {
			len = strlen( line );
			if( len > 16 ) {
				len = 16;
			}
			strncpy( curr_block->handle, line, len );
			curr_block->handle[len] = '\0';
		}
		break;
	case 10:
	case 20:
	case 30:
		if( curr_block ) {
			coord = code / 10 - 1;
			curr_block->base[coord] = atof( line ) * units_conv[units] * scale_factor;
		}
		break;
	}
		
	return( 0 );
}

void
add_polyface_mesh_triangle( int v1, int v2, int v3 )
{
}

void
add_polyline_vertex( fastf_t x, fastf_t y, fastf_t z )
{
	if( !polyline_verts ) {
		polyline_verts = (fastf_t *)bu_malloc( POLYLINE_VERTEX_BLOCK*3*sizeof( fastf_t ), "polyline_verts" );
		polyline_vertex_count = 0;
		polyline_vertex_max = POLYLINE_VERTEX_BLOCK;
	} else if( polyline_vertex_count >= polyline_vertex_max ) {
		polyline_vertex_max += POLYLINE_VERTEX_BLOCK;
		polyline_verts = (fastf_t *)bu_realloc( polyline_verts, polyline_vertex_max * 3 * sizeof( fastf_t ), "polyline_verts" );
	}

	VSET( &polyline_verts[polyline_vertex_count*3], x, y, z );
	polyline_vertex_count++;

	if( verbose ) {
		bu_log( "Added polyline vertex (%g %g %g) #%d\n", x, y, z, polyline_vertex_count );
	}
}

static int
process_point_entities_code( int code )
{
	static point_t pt;
	int coord;

	switch( code ) {
	case 8:		/* layer name */
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "curr_layer_name" );
		}
		curr_layer_name = make_brlcad_name( line );
		break;
	case 10:
	case 20:
	case 30:
		coord = code / 10 - 1;
		pt[coord] = atof( line ) * units_conv[units] * scale_factor;
		break;
	case 62:	/* color number */
		curr_color = atoi( line );
		break;
	case 0:
		get_layer();
		layers[curr_layer]->point_count++;
		sprintf( tmp_name, "point.%d", layers[curr_layer]->point_count );
		(void)mk_sph( out_fp, tmp_name, pt, 0.1 );
		(void)bu_ptbl_ins( &(layers[curr_layer]->solids), (long *)bu_strdup( tmp_name ) );
		curr_state->sub_state = UNKNOWN_ENTITY_STATE;
		process_entities_code[curr_state->sub_state]( code );
		break;
	}

	return( 0 );
}

static int
process_entities_polyline_vertex_code( int code )
{
	static fastf_t x, y, z;
	static int face[4];
	static int vertex_flag=0;
	int coord;

	switch( code ) {
	case 8:		/* layer name */
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "curr_layer_name" );
		}
		curr_layer_name = make_brlcad_name( line );
		break;
	case 70:	/* vertex flag */
		vertex_flag = atoi( line );
		break;
	case 71:
	case 72:
	case 73:
	case 74:
		coord = (code % 70) - 1;
		face[coord] = abs( atoi( line ) );
		break;
	case 0:
		get_layer();
		if( vertex_flag == POLY_VERTEX_FACE ) {
			add_triangle( polyline_vert_indices[face[0]-1],
				      polyline_vert_indices[face[1]-1],
				      polyline_vert_indices[face[2]-1],
				      curr_layer );
			if( face[3] > 0 ) {
			add_triangle( polyline_vert_indices[face[2]-1],
				      polyline_vert_indices[face[3]-1],
				      polyline_vert_indices[face[0]-1],
				      curr_layer );
			}
		} else if( vertex_flag & POLY_VERTEX_3D_M) {
			if( polyline_vert_indices_count >= polyline_vert_indices_max ) {
				polyline_vert_indices_max += POLYLINE_VERTEX_BLOCK;
				polyline_vert_indices = (int *)bu_realloc( polyline_vert_indices,
									   polyline_vert_indices_max * sizeof( int ),
									   "polyline_vert_indices" );
			}
			polyline_vert_indices[polyline_vert_indices_count++] = Add_vert( x, y, z,
									     layers[curr_layer]->vert_tree_root,
									     tol_sq );
			if( verbose) {
				bu_log( "Added 3D mesh vertex (%g %g %g) index = %d, number = %d\n",
					x, y, z, polyline_vert_indices[polyline_vert_indices_count-1],
					polyline_vert_indices_count-1 );
			}
		} else {
			add_polyline_vertex( x, y, z );
		}
		curr_state->sub_state = POLYLINE_ENTITY_STATE;
		if( verbose ) {
			bu_log( "sub_state changed to %d\n", curr_state->sub_state );
		}
		return( process_entities_code[curr_state->sub_state]( code ) );
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 10:
		x = atof( line ) * units_conv[units] * scale_factor;
		break;
	case 20:
		y = atof( line ) * units_conv[units] * scale_factor;
		break;
	case 30:
		z = atof( line ) * units_conv[units] * scale_factor;
		break;
	case 62:	/* color number */
		curr_color = atoi( line );
		break;
	}
		
	return( 0 );
}

static int
process_entities_polyline_code( int code )
{

	switch( code ) {
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 0:		/* text string */
		get_layer();
		if( !strncmp( line, "SEQEND", 6 ) ) {
			/* build any polyline meshes here */
			if( polyline_flag & POLY_3D_MESH ) {
				if( polyline_vert_indices_count == 0 ) {
					return( 0 );
				} else if( polyline_vert_indices_count != mesh_m_count * mesh_n_count ) {
					bu_log( "Incorrect number of vertices for polygon mesh!!!\n" );
					polyline_vert_indices_count = 0;
				} else {
					int i, j;

					if( polyline_vert_indices_count >= polyline_vert_indices_max ) {
						polyline_vert_indices_max = ((polyline_vert_indices_count % POLYLINE_VERTEX_BLOCK) + 1) *
							POLYLINE_VERTEX_BLOCK;
						polyline_vert_indices = (int *)bu_realloc( polyline_vert_indices,
											   polyline_vert_indices_max * sizeof( int ),
											   "polyline_vert_indices" );
					}

					if( mesh_m_count < 2 ) {
						if( mesh_n_count > 4 ) {
							bu_log( "Cannot handle polyline meshes with m<2 and n>4\n");
							polyline_vert_indices_count=0;
							polyline_vert_indices_count = 0;
							break;
						}
						if( mesh_n_count < 3 ) {
							polyline_vert_indices_count=0;
							polyline_vert_indices_count = 0;
							break;
						}
						add_triangle( polyline_vert_indices[0],
							      polyline_vert_indices[1],
							      polyline_vert_indices[2],
							      curr_layer );
						if( mesh_n_count == 4 ) {
							add_triangle( polyline_vert_indices[2],
								      polyline_vert_indices[3],
								      polyline_vert_indices[0],
								      curr_layer );
						}
					}

					for( j=1 ; j<mesh_n_count ; j++ ) {
						for( i=1 ; i<mesh_m_count ; i++ ) {
							add_triangle( polyline_vert_indices[PVINDEX(i-1,j-1)],
								      polyline_vert_indices[PVINDEX(i-1,j)],
								      polyline_vert_indices[PVINDEX(i,j-1)],
								      curr_layer );
							add_triangle( polyline_vert_indices[PVINDEX(i-1,j-1)],
								      polyline_vert_indices[PVINDEX(i,j-1)],
								      polyline_vert_indices[PVINDEX(i,j)],
								      curr_layer );
						}
					}
					polyline_vert_indices_count=0;
					polyline_vertex_count = 0;
				}
			} else {
				int i;
				struct edgeuse *eu;
				struct vertex *v0=NULL, *v1=NULL, *v2=NULL;

				if( polyline_vertex_count > 1 ) {
					if( !layers[curr_layer]->m ) {
						create_nmg();
					}

					for( i=0 ; i<polyline_vertex_count-1 ; i++ ) {
						eu = nmg_me( v1, v2, layers[curr_layer]->s );
						if( i == 0 ) {
							v1 = eu->vu_p->v_p;
							nmg_vertex_gv( v1, polyline_verts );
							v0 = v1;
						}
						v2 = eu->eumate_p->vu_p->v_p;
						nmg_vertex_gv( v2, &polyline_verts[(i+1)*3] );
						if( verbose ) {
							bu_log( "Wire edge (polyline): (%g %g %g) <-> (%g %g %g)\n",
								V3ARGS( v1->vg_p->coord ),
								V3ARGS( v2->vg_p->coord ) );
						}
						v1 = v2;
						v2 = NULL;
					}

					if( polyline_flag & POLY_CLOSED ) {
						v2 = v0;
						(void)nmg_me( v1, v2, layers[curr_layer]->s );
						if( verbose ) {
							bu_log( "Wire edge (closing polyline): (%g %g %g) <-> (%g %g %g)\n",
								V3ARGS( v1->vg_p->coord ),
								V3ARGS( v2->vg_p->coord ) );
						}
					}
				}
				polyline_vert_indices_count=0;	
				polyline_vertex_count = 0;
			}

			curr_state->state = ENTITIES_SECTION;
			curr_state->sub_state = UNKNOWN_ENTITY_STATE;
			if( verbose ) {
				bu_log( "sub_state changed to %d\n", curr_state->sub_state );
			}
			break;
		} else if( !strncmp( line, "VERTEX", 6 ) ) {
			if( verbose)
				bu_log( "Found a POLYLINE VERTEX\n" );
			curr_state->sub_state = POLYLINE_VERTEX_ENTITY_STATE;
			break;
		} else {
			if( verbose ) {
				bu_log( "Unrecognized text string while in polyline entity: %s\n", line );
			}
			break;
		}
	case 70:	/* polyline flag */
		polyline_flag = atoi( line );
		break;
	case 71:
		mesh_m_count = atoi( line );
		break;
	case 72:
		mesh_n_count = atoi( line );
		break;
	case 62:	/* color number */
		curr_color = atoi( line );
		break;
	case 60:
		invisible = atoi( line );
		break;
	case 8:		/* layer name */
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "curr_layer_name" );
		}
		curr_layer_name = make_brlcad_name( line );
		break;
	}
		
	return( 0 );
}

static int
process_entities_unknown_code( int code )
{
	struct state_data *tmp_state;

	invisible = 0;

	switch( code ) {
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 0:		/* text string */
		if( !strncmp( line, "SECTION", 7 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		} else if( !strncmp( line, "ENDSEC", 6 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		} else if( !strncmp( line, "POLYLINE", 8 ) ) {
			if( verbose)
				bu_log( "Found a POLYLINE\n" );
			curr_state->sub_state = POLYLINE_ENTITY_STATE;
			if( verbose ) {
				bu_log( "sub_state changed to %d\n", curr_state->sub_state );
			}
			break;
		} else if( !strncmp( line, "3DFACE", 6 ) ) {
			curr_state->sub_state = FACE3D_ENTITY_STATE;
			if( verbose ) {
				bu_log( "sub_state changed to %d\n", curr_state->sub_state );
			}
			break;
		} else if( !strcmp( line, "CIRCLE" ) ) {
			curr_state->sub_state = CIRCLE_ENTITY_STATE;
			if( verbose ) {
				bu_log( "sub_state changed to %d\n", curr_state->sub_state );
			}
			break;
		} else if( !strcmp( line, "ARC" ) ) {
			curr_state->sub_state = ARC_ENTITY_STATE;
			if( verbose ) {
				bu_log( "sub_state changed to %d\n", curr_state->sub_state );
			}
			break;
		} else if( !strcmp( line, "DIMENSION" ) ) {
			curr_state->sub_state = DIMENSION_ENTITY_STATE;
			if( verbose ) {
				bu_log( "sub_state changed to %d\n", curr_state->sub_state );
			}
			break;
		} else if( !strncmp( line, "LINE", 4 ) ) {
			curr_state->sub_state = LINE_ENTITY_STATE;
			if( verbose ) {
				bu_log( "sub_state changed to %d\n", curr_state->sub_state );
			}
			break;
		} else if( !strcmp( line, "POINT" ) ) {
			curr_state->sub_state = POINT_ENTITY_STATE;
			if( verbose ) {
				bu_log( "sub_state changed to %d\n", curr_state->sub_state );
			}
			break;
		} else if( !strncmp( line, "INSERT", 6 ) ) {
			curr_state->sub_state = INSERT_ENTITY_STATE;
			if( verbose ) {
				bu_log( "sub_state changed to %d\n", curr_state->sub_state );
			}
			break;
		} else if( !strcmp( line, "ENDBLK" ) ) {
			/* found end of an inserted block, pop the state stack */
			tmp_state = curr_state;
			BU_LIST_POP( state_data, &state_stack, curr_state );
			if( !curr_state ) {
				bu_log( "ERROR: end of block encountered while not inserting!!!\n" );
				curr_state = tmp_state;
				break;
			}
			bu_free( (char *)tmp_state, "curr_state" );
			fseek( dxf, curr_state->file_offset, SEEK_SET );
			curr_state->sub_state = UNKNOWN_ENTITY_STATE;
			if( verbose ) {
				bu_log( "Popped state at end of inserted block (seeked to %ld)\n", curr_state->file_offset );
			}
			break;
		} else {
			if( verbose ) {
				bu_log( "Unrecognized text string while in unknown entities state: %s\n",
					line );
			}
			break;
		}
	}
		
	return( 0 );
}

static void
insert_init( struct insert_data *ins )
{
	VSETALL( ins->scale, 1.0 );
	ins->rotation = 0.0;
	VSETALL( ins->insert_pt, 0.0 );
	VSET( ins->extrude_dir, 0, 0, 1 );
}

static int
process_insert_entities_code( int code )
{
	static struct insert_data ins;
	static struct state_data *new_state=NULL;
	struct block_list *blk;
	int coord;

	if( !new_state ) {
		insert_init( &ins );
		BU_GETSTRUCT( new_state, state_data );
		*new_state = *curr_state;
		if( verbose ) {
			bu_log( "Created a new state for INSERT\n" );
		}
	}

	switch( code ) {
	case 8:		/* layer name */
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "curr_layer_name" );
		}
		curr_layer_name = make_brlcad_name( line );
		break;
	case 2:		/* block name */
		for( BU_LIST_FOR( blk, block_list, &block_head ) ) {
			if( !strcmp( blk->block_name, line ) ) {
				break;
			}
		}
		if( BU_LIST_IS_HEAD( blk, &block_head ) ) {
			bu_log( "ERROR: INSERT references non-existent block (%s)\n", line );
			bu_log( "\tignoring missing block\n" );
			blk = NULL;
		}
		new_state->curr_block = blk;
		if( verbose && blk ) {
			bu_log( "Inserting block %s\n", blk->block_name );
		}
		break;
	case 10:
	case 20:
	case 30:
		coord = (code / 10) - 1;
		ins.insert_pt[coord] = atof( line );
		break;
	case 41:
	case 42:
	case 43:
		coord = (code % 40) - 1;
		ins.scale[coord] = atof( line );
		break;
	case 50:
		ins.rotation = atof( line );
		break;
	case 62:	/* color number */
		curr_color = atoi( line );
		break;
	case 70:
	case 71:
		if( atof( line ) != 1 ) {
			bu_log( "Cannot yet handle insertion of a pattern\n\tignoring\n" );
		}
		break;
	case 44:
	case 45:
		break;
	case 210:
	case 220:
	case 230:
		coord = ((code / 10) % 20) - 1;
		ins.extrude_dir[coord] = atof( line );
		break;
	case 0:		/* end of this insert */
		if( new_state->curr_block ) {
			BU_LIST_PUSH( &state_stack, &(curr_state->l) );
			curr_state = new_state;
			new_state = NULL;
			fseek( dxf, curr_state->curr_block->offset, SEEK_SET );
			curr_state->state = ENTITIES_SECTION;
			curr_state->sub_state = UNKNOWN_ENTITY_STATE;
			if( verbose ) {
				bu_log( "Changing state for INSERT\n" );
				bu_log( "seeked to %ld\n", curr_state->curr_block->offset );
			}
		}
		break;
	}

	return( 0 );
}

static int
process_line_entities_code( int code )
{
	int vert_no;
	int coord;
	static point_t line_pt[2];
	struct edgeuse *eu;

	switch( code ) {
	case 8:
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "curr_layer_name" );
		}
		curr_layer_name = make_brlcad_name( line );
		break;
	case 10:
	case 20:
	case 30:
	case 11:
	case 21:
	case 31:
		vert_no = code % 10;
		coord = code / 10 - 1;
		line_pt[vert_no][coord] = atof( line ) * units_conv[units] * scale_factor;
		if( verbose ) {
			bu_log( "LINE vertex #%d coord #%d = %g\n", vert_no, coord, line_pt[vert_no][coord] );
		}
		break;
	case 62:	/* color number */
		curr_color = atoi( line );
		break;
	case 0:
		/* end of this line */
		get_layer();
		if( verbose ) {
			bu_log( "Found end of LINE\n" );
		}

		layers[curr_layer]->line_count++;

		if( !layers[curr_layer]->m ) {
			create_nmg();
		}

		/* create a wire edge in the NMG */
		eu = nmg_me( NULL, NULL, layers[curr_layer]->s );
		nmg_vertex_gv( eu->vu_p->v_p, line_pt[0] );
		nmg_vertex_gv( eu->eumate_p->vu_p->v_p, line_pt[1] );
		if( verbose ) {
			bu_log( "Wire edge (line): (%g %g %g) <-> (%g %g %g)\n",
				V3ARGS(eu->vu_p->v_p->vg_p->coord ),
				V3ARGS(eu->eumate_p->vu_p->v_p->vg_p->coord ) );
		}

		curr_state->sub_state = UNKNOWN_ENTITY_STATE;
		process_entities_code[curr_state->sub_state]( code );
		break;
	}
	
	return( 0 );
}

static int
process_circle_entities_code( int code )
{
	static point_t center;
	static fastf_t radius;
	int coord, i;
	struct vertex *v0=NULL, *v1=NULL, *v2=NULL;
	struct edgeuse *eu;

	switch( code ) {
	case 8:		/* layer name */
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "curr_layer_name" );
		}
		curr_layer_name = make_brlcad_name( line );
		break;
	case 10:
	case 20:
	case 30:
		coord = code / 10 - 1;
		center[coord] = atof( line ) * units_conv[units] * scale_factor;
		if( verbose ) {
			bu_log( "CIRCLE center coord #%d = %g\n", coord, center[coord] );
		}
		break;
	case 40:
		radius = atof( line ) * units_conv[units] * scale_factor;
		break;
	case 62:	/* color number */
		curr_color = atoi( line );
		break;
	case 0:
		/* end of this circle entity
		 * make a series of wire edges in the NMG to approximate a circle
		 */

		get_layer();
		if( verbose ) {
			bu_log( "Found a circle\n" );
		}

		if( !layers[curr_layer]->m ) {
			create_nmg();
		}

		/* calculate circle at origin first */
		VSET( circle_pts[0], radius, 0.0, 0.0 );
		for( i=1 ; i<segs_per_circle ; i++ ) {
			circle_pts[i][X] = circle_pts[i-1][X]*cos_delta - circle_pts[i-1][Y]*sin_delta;
			circle_pts[i][Y] = circle_pts[i-1][Y]*cos_delta + circle_pts[i-1][X]*sin_delta;
		}

		/* move everything to the specified center */
		for( i=0 ; i<segs_per_circle ; i++ ) {
			VADD2( circle_pts[i], circle_pts[i], center );
		}

		/* make nmg wire edges */
		for( i=0 ; i<segs_per_circle ; i++ ) {
			if( i+1 == segs_per_circle ) {
				v2 = v0;
			}
			eu = nmg_me( v1, v2, layers[curr_layer]->s );
			if( i == 0 ) {
				v1 = eu->vu_p->v_p;
				v0 = v1;
				nmg_vertex_gv( v1, circle_pts[0] );
			}
			v2 = eu->eumate_p->vu_p->v_p;
			if( i+1 < segs_per_circle ) {
				nmg_vertex_gv( v2, circle_pts[i+1] );
			}
			if( verbose ) {
				bu_log( "Wire edge (circle): (%g %g %g) <-> (%g %g %g)\n",
					V3ARGS( v1->vg_p->coord ),
					V3ARGS( v2->vg_p->coord ) );
			}
			v1 = v2;
			v2 = NULL;
		}

		curr_state->sub_state = UNKNOWN_ENTITY_STATE;
		process_entities_code[curr_state->sub_state]( code );
		break;
	}

	return( 0 );
}

static int
process_dimension_entities_code( int code )
{
	static point_t def_pt={0.0, 0.0, 0.0};
	static char *block_name=NULL;
	static struct state_data *new_state=NULL;
	struct block_list *blk;
	int coord;

	switch( code ) {
	case 10:
	case 20:
	case 30:
		coord = (code / 10) - 1;
		def_pt[coord] = atof( line ) * units_conv[units] * scale_factor;
		break;
	case 8:		/* layer name */
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "curr_layer_name" );
		}
		curr_layer_name = make_brlcad_name( line );
		break;
	case 2:	/* block name */
		block_name = bu_strdup( line );
		break;
	case 0:
		/* insert this dimension */
		get_layer();
		BU_GETSTRUCT( new_state, state_data );
		*new_state = *curr_state;
		if( verbose ) {
			bu_log( "Created a new state for DIMENSION\n" );
		}
		for( BU_LIST_FOR( blk, block_list, &block_head ) ) {
			if( !strcmp( blk->block_name, block_name ) ) {
				break;
			}
		}
		if( BU_LIST_IS_HEAD( blk, &block_head ) ) {
			bu_log( "ERROR: INSERT references non-existent block (%s)\n", line );
			bu_log( "\tignoring missing block\n" );
			blk = NULL;
		}
		new_state->curr_block = blk;
		if( verbose && blk ) {
			bu_log( "Inserting block %s\n", blk->block_name );
		}

		bu_free( block_name, "block_name" );
		
		if( new_state->curr_block ) {
			BU_LIST_PUSH( &state_stack, &(curr_state->l) );
			curr_state = new_state;
			new_state = NULL;
			fseek( dxf, curr_state->curr_block->offset, SEEK_SET );
			curr_state->state = ENTITIES_SECTION;
			curr_state->sub_state = UNKNOWN_ENTITY_STATE;
			if( verbose ) {
				bu_log( "Changing state for INSERT\n" );
				bu_log( "seeked to %ld\n", curr_state->curr_block->offset );
			}
		}

		break;
	}

	return( 0 );
}

static int
process_arc_entities_code( int code )
{
	static point_t center={0,0,0};
	static fastf_t radius;
	static fastf_t start_angle, end_angle;
	int num_segs;
	int coord, i;
	struct vertex *v0=NULL, *v1=NULL, *v2=NULL;
	struct edgeuse *eu;

	switch( code ) {
	case 8:		/* layer name */
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "curr_layer_name" );
		}
		curr_layer_name = make_brlcad_name( line );
		break;
	case 10:
	case 20:
	case 30:
		coord = code / 10 - 1;
		center[coord] = atof( line ) * units_conv[units] * scale_factor;
		if( verbose ) {
			bu_log( "ARC center coord #%d = %g\n", coord, center[coord] );
		}
		break;
	case 40:
		radius = atof( line ) * units_conv[units] * scale_factor;
		if( verbose) {
			bu_log( "ARC radius = %g\n", radius );
		}
		break;
	case 50:
		start_angle = atof( line );
		if( verbose ) {
			bu_log( "ARC start angle = %g\n", start_angle );
		}
		break;
	case 51:
		end_angle = atof( line );
		if( verbose ) {
			bu_log( "ARC end angle = %g\n", end_angle );
		}
		break;
	case 62:	/* color number */
		curr_color = atoi( line );
		break;
	case 0:
		/* end of this arc entity
		 * make a series of wire edges in the NMG to approximate an arc
		 */

		get_layer();
		if( verbose ) {
			bu_log( "Found an arc\n" );
		}

		if( !layers[curr_layer]->m ) {
			create_nmg();
		}

		while( end_angle < start_angle ) {
			end_angle += 360.0;
		}

		/* calculate arc at origin first */
		num_segs = (end_angle - start_angle) / 360.0 * segs_per_circle;
		start_angle *= M_PI / 180.0;
		end_angle *= M_PI / 180.0;
		if( verbose ) {
			bu_log( "arc has %d segs\n", num_segs );
		}

		if( num_segs < 1 ) {
			num_segs = 1;
		}
		VSET( circle_pts[0], radius * cos( start_angle ), radius * sin( start_angle ), 0.0 );
		for( i=1 ; i<num_segs ; i++ ) {
			circle_pts[i][X] = circle_pts[i-1][X]*cos_delta - circle_pts[i-1][Y]*sin_delta;
			circle_pts[i][Y] = circle_pts[i-1][Y]*cos_delta + circle_pts[i-1][X]*sin_delta;
		}
		circle_pts[num_segs][X] = radius * cos( end_angle );
		circle_pts[num_segs][Y] = radius * sin( end_angle );
		num_segs++;

		if( verbose ) {
			bu_log( "ARC points calculated:\n" );
			for( i=0 ; i<num_segs ; i++ ) {
				bu_log( "\t point #%d: (%g %g %g)\n", i, V3ARGS( circle_pts[i] ) );
			}
		}

		/* move everything to the specified center */
		for( i=0 ; i<num_segs ; i++ ) {
			VADD2( circle_pts[i], circle_pts[i], center );
		}

		if( verbose ) {
			bu_log( "ARC points after move to center at (%g %g %g):\n", V3ARGS( center ) );
			for( i=0 ; i<num_segs ; i++ ) {
				bu_log( "\t point #%d: (%g %g %g)\n", i, V3ARGS( circle_pts[i] ) );
			}
		}

		/* make nmg wire edges */
		for( i=1 ; i<num_segs ; i++ ) {
			if( i == num_segs ) {
				v2 = v0;
			}
			eu = nmg_me( v1, v2, layers[curr_layer]->s );
			if( i == 1 ) {
				v1 = eu->vu_p->v_p;
				v0 = v1;
				nmg_vertex_gv( v1, circle_pts[0] );
			}
			v2 = eu->eumate_p->vu_p->v_p;
			if( i < segs_per_circle ) {
				nmg_vertex_gv( v2, circle_pts[i] );
			}
			if( verbose ) {
				bu_log( "Wire edge (arc) #%d (%g %g %g) <-> (%g %g %g)\n", i,
					V3ARGS( v1->vg_p->coord ),
					V3ARGS( v2->vg_p->coord ) );
			}
			v1 = v2;
			v2 = NULL;
		}

		VSETALL( center, 0.0 );
		for( i=0 ; i<segs_per_circle ; i++ ) {
			VSETALL( circle_pts[i], 0.0 );
		}

		curr_state->sub_state = UNKNOWN_ENTITY_STATE;
		process_entities_code[curr_state->sub_state]( code );
		break;
	}

	return( 0 );
}

static int
process_3dface_entities_code( int code )
{
	int vert_no;
	int coord;
	int face[5];

	switch( code ) {
	case 8:
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "curr_layer_name" );
		}
		curr_layer_name = make_brlcad_name( line );
		break;
	case 10:
	case 20:
	case 30:
	case 11:
	case 21:
	case 31:
	case 12:
	case 22:
	case 32:
	case 13:
	case 23:
	case 33:
		vert_no = code % 10;
		coord = code / 10 - 1;
		pts[vert_no][coord] = atof( line ) * units_conv[units] * scale_factor;
		if( verbose ) {
			bu_log( "3dface vertex #%d coord #%d = %g\n", vert_no, coord, pts[vert_no][coord] );
		}
		if( vert_no == 2 ) {
			pts[3][coord] = pts[2][coord];
		}
		break;
	case 62:	/* color number */
		curr_color = atoi( line );
		break;
	case 0:
		/* end of this 3dface */
		get_layer();
		if( verbose ) {
			bu_log( "Found end of 3DFACE\n" );
		}
		if( verbose ) {
			bu_log( "\tmaking two triangles\n" );
		}
		for( vert_no=0 ; vert_no<4; vert_no++ ) {
			face[vert_no] = Add_vert( V3ARGS( pts[vert_no]),
						  layers[curr_layer]->vert_tree_root,
						  tol_sq );
		}
		add_triangle( face[0], face[1], face[2], curr_layer );
		add_triangle( face[2], face[3], face[0], curr_layer );
		if( verbose ) {
			bu_log( "finished face\n" );
		}

		curr_state->sub_state = UNKNOWN_ENTITY_STATE;
		process_entities_code[curr_state->sub_state]( code );
		break;
	}
	
	return( 0 );
}

static int
process_entity_code( int code )
{
	return( process_entities_code[curr_state->sub_state]( code ) );
}

static int
process_objects_code( int code )
{
	switch( code ) {
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 0:		/* text string */
		if( !strncmp( line, "SECTION", 7 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		} else if( !strncmp( line, "ENDSEC", 6 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		}
		break;
	}
		
	return( 0 );
}

static int
process_thumbnail_code( int code )
{
	switch( code ) {
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 0:		/* text string */
		if( !strncmp( line, "SECTION", 7 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		} else if( !strncmp( line, "ENDSEC", 6 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		}
		break;
	}
		
	return( 0 );
}

int
readcodes()
{
	int code;
	int line_len;
	static int line_num=0;

	curr_state->file_offset = ftell( dxf );

	if( fgets( line, LINELEN, dxf ) == NULL ) {
		return( ERROR_FLAG );
	} else {
		code = atoi( line );
	}

	if( fgets( line, LINELEN, dxf ) == NULL ) {
		return( ERROR_FLAG );
	}

	if( !strncmp( line, "EOF", 3 ) ) {
		return( EOF_FLAG );
	}

	line_len = strlen( line );
	if( line_len ) {
		line[line_len-1] = '\0';
		line_len--;
	}

	if( line_len && line[line_len-1] == '\r' ) {
		line[line_len-1] = '\0';
		line_len--;
	}

	if( verbose ) {
		line_num++;
		bu_log( "%d:\t%d\n", line_num, code );
		line_num++;
		bu_log( "%d:\t%s\n", line_num, line );
	}

	return( code );
}

int
main( int argc, char *argv[] )
{
	struct bu_list head_all;
	int name_len;
	char *ptr1, *ptr2;
	int code;
	int c;
	int i;

	tol_sq = tol * tol;

	delta_angle = 2.0 * M_PI / (fastf_t)segs_per_circle;
	sin_delta = sin( delta_angle );
	cos_delta = cos( delta_angle );

	/* get command line arguments */
	scale_factor = 1.0;
	while ((c = getopt(argc, argv, "cdvt:s:")) != EOF)
	{
		switch( c )
		{
		        case 's':	/* scale factor */
				scale_factor = atof( optarg );
				if( scale_factor < SQRT_SMALL_FASTF ) {
					bu_log( "scale factor too small\n" );
					bu_log( "%s", usage );
					exit( 1 );
				}
				break;
		        case 'c':	/* ignore colors */
				ignore_colors = 1;
				break;
		        case 'd':	/* debug */
				bu_debug = BU_DEBUG_COREDUMP;
				break;
			case 't':	/* tolerance */
				tol = atof( optarg );
				tol_sq = tol * tol;
				break;
			case 'v':	/* verbose */
				verbose = 1;
				break;
			default:
				bu_bomb( usage );
				break;
		}
	}

	if( argc - optind < 2 ) {
		bu_bomb( usage );
	}

	dxf_file = argv[optind++];
	output_file = argv[optind];

	if( (out_fp = wdb_fopen( output_file )) == NULL ) {
		bu_log( "Cannot open output file (%s)\n", output_file );
		perror( output_file );
		bu_bomb( "Cannot open output file\n" );
	}

	if( (dxf=fopen( dxf_file, "r")) == NULL ) {
		bu_log( "Cannot open DXF file (%s)\n", dxf_file );
		perror( dxf_file );
		bu_bomb( "Cannot open DXF file\n" );
	}

	ptr1 = strrchr( dxf_file , '/' );
	if( ptr1 == NULL )
		ptr1 = dxf_file;
	else
		ptr1++;
	ptr2 = strchr( ptr1 , '.' );

	if( ptr2 == NULL )
		name_len = strlen( ptr1 );
	else
		name_len = ptr2 - ptr1;

	base_name = (char *)bu_malloc( name_len + 1 , "base_name" );
	strncpy( base_name , ptr1 , name_len );

	mk_id( out_fp , base_name );

	BU_LIST_INIT( &block_head );

	process_code[UNKNOWN_SECTION] = process_unknown_code;
	process_code[HEADER_SECTION] = process_header_code;
	process_code[CLASSES_SECTION] = process_classes_code;
	process_code[TABLES_SECTION] = process_tables_code;
	process_code[BLOCKS_SECTION] = process_blocks_code;
	process_code[ENTITIES_SECTION] = process_entity_code;
	process_code[OBJECTS_SECTION] = process_objects_code;
	process_code[THUMBNAILIMAGE_SECTION] = process_thumbnail_code;

	process_entities_code[UNKNOWN_ENTITY_STATE] = process_entities_unknown_code;
	process_entities_code[POLYLINE_ENTITY_STATE] = process_entities_polyline_code;
	process_entities_code[POLYLINE_VERTEX_ENTITY_STATE] = process_entities_polyline_vertex_code;
	process_entities_code[FACE3D_ENTITY_STATE] = process_3dface_entities_code;
	process_entities_code[LINE_ENTITY_STATE] = process_line_entities_code;
	process_entities_code[INSERT_ENTITY_STATE] = process_insert_entities_code;
	process_entities_code[POINT_ENTITY_STATE] = process_point_entities_code;
	process_entities_code[CIRCLE_ENTITY_STATE] = process_circle_entities_code;
	process_entities_code[ARC_ENTITY_STATE] = process_arc_entities_code;
	process_entities_code[DIMENSION_ENTITY_STATE] = process_dimension_entities_code;

	process_tables_sub_code[UNKNOWN_TABLE_STATE] = process_tables_unknown_code;
	process_tables_sub_code[LAYER_TABLE_STATE] = process_tables_layer_code;

	/* create storage for circles */
	circle_pts = (point_t *)bu_calloc( segs_per_circle, sizeof( point_t ), "circle_pts" );
	for( i=0 ; i<segs_per_circle ; i++ ) {
		VSETALL( circle_pts[i], 0.0 );
	}

	/* initialize state stack */
	BU_LIST_INIT( &state_stack );

	/* create initial state */
	BU_GETSTRUCT( curr_state, state_data );
	curr_state->file_offset = 0;
	curr_state->state = UNKNOWN_SECTION;
	curr_state->sub_state = UNKNOWN_ENTITY_STATE;
	MAT_IDN( curr_state->xform );

	/* make space for 5 layers to start */
	max_layers = 5;
	next_layer = 1;
	curr_layer = 0;
	layers = (struct layer **)bu_calloc( 5, sizeof( struct layer *), "layers" );
	for( i=0 ; i<max_layers ; i++ ) {
		BU_GETSTRUCT( layers[i], layer );
	}
	layers[0]->name = bu_strdup( "noname" );
	layers[0]->color_number = 7;	/* default white */
	layers[0]->vert_tree_root = create_vert_tree();
	bu_ptbl_init( &layers[0]->solids, 8, "layers[curr_layer]->solids" );

	curr_color = layers[0]->color_number;
	curr_layer_name = bu_strdup( layers[0]->name );

	while( (code=readcodes()) > -900 ) {
		process_code[curr_state->state](code);
	}

	BU_LIST_INIT( &head_all );
	for( i=0 ; i<next_layer ; i++ ) {
		struct bu_list head;
		int j;

		BU_LIST_INIT( &head );

		if( layers[i]->curr_tri || BU_PTBL_END( &layers[i]->solids ) || layers[i]->m ) {
			bu_log( "LAYER: %s\n", layers[i]->name );
		}

		if( layers[i]->curr_tri ) {
			bu_log( "\t%d triangles\n", layers[i]->curr_tri );
			sprintf( tmp_name, "bot.s%d", i );
			if( mk_bot( out_fp, tmp_name, RT_BOT_SURFACE, RT_BOT_UNORIENTED,0,
				    layers[i]->vert_tree_root->curr_vert, layers[i]->curr_tri, layers[i]->vert_tree_root->the_array,
				    layers[i]->part_tris, (fastf_t *)NULL, (struct bu_bitv *)NULL ) ) {
				bu_log( "Failed to make Bot\n" );
			} else {
				(void)mk_addmember( tmp_name, &head, NULL, WMOP_UNION );
			}
		}

		if( BU_PTBL_END( &layers[i]->solids ) > 0 ) {
			bu_log( "\t%d points\n", BU_PTBL_END( &layers[i]->solids ) );
		}

		for( j=0 ; j<BU_PTBL_END( &layers[i]->solids ) ; j++ ) {
			(void)mk_addmember((char *)BU_PTBL_GET( &layers[i]->solids, j ), &head,
					    NULL, WMOP_UNION );
			bu_free( (char *)BU_PTBL_GET( &layers[i]->solids, j), "solid_name" );
		}

		if( layers[i]->m ) {
			char name[32];

			sprintf( name, "nmg.%d", i );
			mk_nmg( out_fp, name, layers[i]->m );
			(void)mk_addmember( name, &head, NULL, WMOP_UNION );
		}

		if( layers[i]->line_count ) {
			bu_log( "\t%d lines\n", layers[i]->line_count );
		}

		if( layers[i]->point_count ) {
			bu_log( "\t%d points\n", layers[i]->point_count );
		}

		if( BU_LIST_NON_EMPTY( &head ) ) {
			unsigned char *tmp_rgb;
			struct bu_vls comb_name;

			if( layers[i]->color_number < 0 ) {
				tmp_rgb = &rgb[7];
			} else {
				tmp_rgb = &rgb[layers[i]->color_number*3];
			}
			bu_vls_init( &comb_name );
			bu_vls_printf( &comb_name, "%s.c.%d", layers[i]->name, i );
			if( mk_comb( out_fp, bu_vls_addr( &comb_name ), &head, 1, NULL, NULL,
				     tmp_rgb, 1, 0, 1, 100, 0, 0, 0 ) ) {
				bu_log( "Failed to make region %s\n", layers[i]->name );
			} else {
				(void)mk_addmember( bu_vls_addr( &comb_name ), &head_all, NULL, WMOP_UNION );
			}
		}

	}

	if( BU_LIST_NON_EMPTY( &head_all ) ) {
		struct bu_vls top_name;
		int count=0;

		bu_vls_strcpy( &top_name, "all" );
		while( db_lookup( out_fp->dbip, bu_vls_addr( &top_name ), LOOKUP_QUIET ) != DIR_NULL ) {
			count++;
			bu_vls_trunc( &top_name, 0 );
			bu_vls_printf( &top_name, "all.%d", count );
		}

		(void)mk_comb( out_fp, bu_vls_addr( &top_name ), &head_all, 0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 0, 0 );
	}

	return( 0 );
}
@


11.23
log
@change conf.h to a wrapped config.h
@
text
@@


11.22
log
@vertex indices for meshes may be negative (needed to take absolute value)
@
text
@d1 5
a5 1
#include "conf.h"
@


11.21
log
@Now legalizes region names
@
text
@d922 1
a922 1
		face[coord] = atoi( line );
@


11.21.2.1
log
@updates from HEAD, part 1
@
text
@d922 1
a922 1
		face[coord] = abs( atoi( line ) );
@


11.20
log
@lint
@
text
@d17 2
d454 19
d747 1
a747 1
		curr_layer_name = bu_strdup( line );
d874 1
a874 1
		curr_layer_name = bu_strdup( line );
d912 1
a912 1
		curr_layer_name = bu_strdup( line );
d1126 1
a1126 1
		curr_layer_name = bu_strdup( line );
d1260 1
a1260 1
		curr_layer_name = bu_strdup( line );
d1343 1
a1343 1
		curr_layer_name = bu_strdup( line );
d1406 1
a1406 1
		curr_layer_name = bu_strdup( line );
d1501 1
a1501 1
		curr_layer_name = bu_strdup( line );
d1566 1
a1566 1
		curr_layer_name = bu_strdup( line );
d1704 1
a1704 1
		curr_layer_name = bu_strdup( line );
@


11.19
log
@Forgot to initialize scale factor
@
text
@a744 1
		break;
a938 1
		break;
a1085 1
		break;
a1202 1
		break;
@


11.18
log
@Entity insertion points now respect the units and scale factors
@
text
@d1851 1
@


11.17
log
@Added scale factor
@
text
@d860 1
a860 1
		pt[coord] = atof( line );
@


11.16
log
@Added "-c" option to ignore colors when building layers
@
text
@d144 1
a144 1
static char *usage="dxf-g [-d] [-v] [-t tolerance] input_dxf_file output_file.g\n";
d159 1
d810 1
a810 1
			curr_block->base[coord] = atof( line ) * units_conv[units];
d945 1
a945 1
		x = atof( line ) * units_conv[units];
d948 1
a948 1
		y = atof( line ) * units_conv[units];
d951 1
a951 1
		z = atof( line ) * units_conv[units];
d1336 1
a1336 1
		line_pt[vert_no][coord] = atof( line ) * units_conv[units];
d1395 1
a1395 1
		center[coord] = atof( line ) * units_conv[units];
d1401 1
a1401 1
		radius = atof( line ) * units_conv[units];
d1478 1
a1478 1
		def_pt[coord] = atof( line ) * units_conv[units];
d1555 1
a1555 1
		center[coord] = atof( line ) * units_conv[units];
d1561 1
a1561 1
		radius = atof( line ) * units_conv[units];
d1703 1
a1703 1
		pts[vert_no][coord] = atof( line ) * units_conv[units];
d1851 1
a1851 1
	while ((c = getopt(argc, argv, "cdvt:")) != EOF)
d1855 8
@


11.15
log
@Fixed bug in polyface meshes
Now we don't create an NMG primitive unless we have something to put in it
@
text
@d36 1
d460 1
a460 1
		if( !color_by_layer ) {
d488 1
a488 1
			bu_log( "New layer: %s", line );
d1850 1
a1850 1
	while ((c = getopt(argc, argv, "dvt:")) != EOF)
d1854 3
@


11.15.2.1
log
@updated for merging
@
text
@a35 1
static int ignore_colors=0;
d143 1
a143 1
static char *usage="dxf-g [-d] [-v] [-t tolerance] [-s scale_factor] input_dxf_file output_file.g\n";
a157 1
static fastf_t scale_factor;
d459 1
a459 1
		if( !color_by_layer && !ignore_colors ) {
d487 1
a487 1
			bu_log( "New layer: %s, color number: %d", line, curr_color );
d808 1
a808 1
			curr_block->base[coord] = atof( line ) * units_conv[units] * scale_factor;
d858 1
a858 1
		pt[coord] = atof( line ) * units_conv[units] * scale_factor;
d943 1
a943 1
		x = atof( line ) * units_conv[units] * scale_factor;
d946 1
a946 1
		y = atof( line ) * units_conv[units] * scale_factor;
d949 1
a949 1
		z = atof( line ) * units_conv[units] * scale_factor;
d1334 1
a1334 1
		line_pt[vert_no][coord] = atof( line ) * units_conv[units] * scale_factor;
d1393 1
a1393 1
		center[coord] = atof( line ) * units_conv[units] * scale_factor;
d1399 1
a1399 1
		radius = atof( line ) * units_conv[units] * scale_factor;
d1476 1
a1476 1
		def_pt[coord] = atof( line ) * units_conv[units] * scale_factor;
d1553 1
a1553 1
		center[coord] = atof( line ) * units_conv[units] * scale_factor;
d1559 1
a1559 1
		radius = atof( line ) * units_conv[units] * scale_factor;
d1701 1
a1701 1
		pts[vert_no][coord] = atof( line ) * units_conv[units] * scale_factor;
d1849 1
a1849 2
	scale_factor = 1.0;
	while ((c = getopt(argc, argv, "cdvt:s:")) != EOF)
a1852 11
		        case 's':	/* scale factor */
				scale_factor = atof( optarg );
				if( scale_factor < SQRT_SMALL_FASTF ) {
					bu_log( "scale factor too small\n" );
					bu_log( "%s", usage );
					exit( 1 );
				}
				break;
		        case 'c':	/* ignore colors */
				ignore_colors = 1;
				break;
@


11.14
log
@Corrected usage message
@
text
@d1016 1
a1016 1
								      polyline_vert_indices[PVINDEX(i,j)],
d1018 1
a1018 1
							add_triangle( polyline_vert_indices[PVINDEX(i,j)],
d1020 1
a1020 1
								      polyline_vert_indices[PVINDEX(i-1,j-1)],
d1032 4
a1035 3
				if( !layers[curr_layer]->m ) {
					create_nmg();
				}
d1037 16
a1052 13
				for( i=0 ; i<polyline_vertex_count-1 ; i++ ) {
					eu = nmg_me( v1, v2, layers[curr_layer]->s );
					if( i == 0 ) {
						v1 = eu->vu_p->v_p;
						nmg_vertex_gv( v1, polyline_verts );
						v0 = v1;
					}
					v2 = eu->eumate_p->vu_p->v_p;
					nmg_vertex_gv( v2, &polyline_verts[(i+1)*3] );
					if( verbose ) {
						bu_log( "Wire edge (polyline): (%g %g %g) <-> (%g %g %g)\n",
							V3ARGS( v1->vg_p->coord ),
							V3ARGS( v2->vg_p->coord ) );
a1053 3
					v1 = v2;
					v2 = NULL;
				}
d1055 8
a1062 7
				if( polyline_flag & POLY_CLOSED ) {
					v2 = v0;
					(void)nmg_me( v1, v2, layers[curr_layer]->s );
					if( verbose ) {
						bu_log( "Wire edge (closing polyline): (%g %g %g) <-> (%g %g %g)\n",
							V3ARGS( v1->vg_p->coord ),
							V3ARGS( v2->vg_p->coord ) );
a1064 1

@


11.13
log
@Re-wrote dxf-g. Now supports many more entity types
@
text
@d143 1
a143 1
static char *usage="dxf-g [-v] [-t tolerance] input_dxf_file output_file.g\n";
@


11.12
log
@Eliminated non-existent option from usage statement
@
text
@a1 1

d5 1
a5 1
#include <string.h>
d7 1
a7 1
#include <strings.h>
a8 1
#include <errno.h>
d11 1
d13 1
a13 2
#include "nmg.h"
#include "rtgeom.h"
a15 1
#include "../librt/debug.h"
d17 35
a51 1
#define	LINELEN	256 /* max input line length from elements file */
d53 395
a447 1
static char *usage="dxf-g [-v] [-p] [-t tolerance] [-i input_file] [-o output_file_name]";
a448 25
int
main( argc , argv )
int argc;
char *argv[];
{
	register int c;
	FILE *dxf;
	struct rt_wdb *out_fp;
	char *output_file = "dxf.g";
	char *base_name,*dxf_name;
	char *ptr1,*ptr2;
	char curr_name[LINELEN];
	int name_len;
	struct bn_tol tol;
	int done=0;
	int polysolids=0;
	int verbose=0;
	int i,j,group_code;
	char line[LINELEN];
	struct bu_ptbl vertices;
	struct bu_ptbl faces;
	struct model *m;
	struct nmgregion *r;
	struct shell *s;
	struct faceuse *fu;
d450 5
a454 10
        /* XXX These need to be improved */
        tol.magic = BN_TOL_MAGIC;
        tol.dist = 0.0005;
        tol.dist_sq = tol.dist * tol.dist;
        tol.perp = 1e-6;
        tol.para = 1 - tol.perp;

	dxf = stdin;
	dxf_name = (char *)NULL;
	base_name = (char *)NULL;
d456 6
a461 8
	/* get command line arguments */
	while ((c = getopt(argc, argv, "pvt:i:o:")) != EOF)
	{
		switch( c )
		{
			case 't':	/* tolerance */
				tol.dist = atof( optarg );
				tol.dist_sq = tol.dist * tol.dist;
d463 4
a466 21
			case 'v':	/* verbose */
				verbose = 1;
				break;
			case 'i':	/* input DXF file name */
				dxf_name = (char *)bu_malloc( strlen( optarg ) + 1 , "Dxf-g: dxf_name" );
				strcpy( dxf_name , optarg );
				if( (dxf = fopen( dxf_name , "r" )) == NULL )
				{
					bu_log( "Cannot open %s\n" , dxf_name );
					perror( "viewpoint-g" );
					rt_bomb( "Cannot open input file" );
				}
				break;
			case 'o':	/* output file name */
				output_file = optarg;
				break;
			case 'p':	/* produce polysolids as output instead of NMG's */
				polysolids = 1;
				break;
			default:
				rt_bomb( usage );
d468 69
d540 78
a617 5
	if( (out_fp = wdb_fopen( output_file )) == NULL )
	{
		rt_bomb( "Cannot open output file\n" );
		bu_log( "tankill-g: Cannot open %s\n" , output_file );
		perror( output_file );
d619 30
d650 3
d654 20
a673 13
	if( dxf_name )
	{
		ptr1 = strrchr( dxf_name , '/' );
		if( ptr1 == NULL )
			ptr1 = dxf_name;
		else
			ptr1++;
		ptr2 = strchr( ptr1 , '.' );

		if( ptr2 == NULL )
			name_len = strlen( ptr1 );
		else
			name_len = ptr2 - ptr1;
d675 3
a677 2
		base_name = (char *)bu_malloc( name_len + 1 , "base_name" );
		strncpy( base_name , ptr1 , name_len );
d679 29
a707 1
		mk_id( out_fp , base_name );
d709 3
a711 3
	else
		mk_id( out_fp , "Conversion from DXF" );
	
d713 20
a732 38
	/* Find the ENTITIES SECTION */
	if( verbose )
		bu_log( "Looking for ENTITIES section..\n" );
	while( fgets( line , LINELEN , dxf ) != NULL )
	{
		sscanf( line , "%d" , &group_code );
		if( group_code == 0 )
		{
			if( verbose )
				bu_log( "Found group code 0\n" );
			/* read label from next line */
			if( fgets( line , LINELEN , dxf ) == NULL )
				rt_bomb( "Unexpected EOF in input file\n" );
			if( !strncmp( line , "SECTION" , 7 ) )
			{
				if( verbose )
					bu_log( "Found 'SECTION'\n" );
				if( fgets( line , LINELEN , dxf ) == NULL )
					rt_bomb( "Unexpected EOF in input file\n" );
				sscanf( line , "%d" , &group_code );
				if( group_code == 2 )
				{
					if( verbose )
						bu_log( "Found group code 2\n" );
					if( fgets( line , LINELEN , dxf ) == NULL )
						rt_bomb( "Unexpected EOF in input file\n" );
					if( !strncmp( line , "ENTITIES" , 8 ) )
					{
						if( verbose )
							bu_log( "Found 'ENTITIES'\n" );
						if( fgets( line , LINELEN , dxf ) == NULL )
							rt_bomb( "Unexpected EOF in input file\n" );
						sscanf( line , "%d" , &group_code );
						if( group_code != 0 )
							rt_bomb( "Expected group code 0 at start of ENTITIES\n" );
						break;
					}
				}
d735 9
d745 3
d749 5
a753 4
	/* make basic nmg structures */
	m = nmg_mm();
	r = nmg_mrsv( m );
	s = BU_LIST_FIRST( shell , &r->s_hd );
d755 5
a759 2
	bu_ptbl_init( &vertices , 64, " &vertices ");
	bu_ptbl_init( &faces , 64, " &faces ");
d761 29
a789 18
	/* Read the ENTITIES section */
	while( !done )
	{
		struct vertex *vp[4];
		point_t pt[4];
		int no_of_pts;
		int line_entity=0;
		int face_entity=0;

		if( fgets( line , LINELEN , dxf ) == NULL )
			rt_bomb( "Unexpected EOF in input file\n" );
		while( strncmp( line , "3DFACE" , 6 ) && strncmp( line, "LINE", 4 ) )
		{
			if( !strncmp( line , "ENDSEC" , 6 ) )
			{
				bu_log( "Found end of ENTITIES section\n" );
				done = 1;
				break;
d791 7
a797 10
			line[ strlen(line)-1 ] = '\0';
			bu_log( "Unknown entity type (%s), skipping\n" , line );
			group_code = 5;
			while( group_code != 0 )
			{
				if( fgets( line , LINELEN , dxf ) == NULL )
					rt_bomb( "Unexpected EOF in input file\n" );
				sscanf( line , "%d" , &group_code );
				if( fgets( line , LINELEN , dxf ) == NULL )
					rt_bomb( "Unexpected EOF in input file\n" );
d799 52
d852 24
d877 55
a931 11
		if( done )
			break;

		if( !strncmp( line, "3DFACE", 6 ) )
			face_entity = 1;
		else if( !strncmp( line, "LINE", 4 ) )
			line_entity = 1;
		else
		{
			bu_log(  "Unknown entity type (%s), skipping\n" , line );
			continue;
d933 3
a935 6
		if( verbose )
		{
			if( face_entity )
				bu_log( "Found 3DFACE\n" );
			else if( line_entity )
				bu_log( "Found LINE\n" );
d937 21
d959 3
a961 5
		no_of_pts = (-1);
		group_code = 1;
		while( group_code )
		{
			struct loopuse *lu;
d963 23
a985 13
			if( fgets( line , LINELEN , dxf ) == NULL )
				rt_bomb( "Unexpected EOF in input file\n" );
			sscanf( line , "%d" , &group_code );
			switch( group_code )
			{
				case 8:
					if( fgets( line , LINELEN , dxf ) == NULL )
						rt_bomb( "Unexpected EOF in input file\n" );
					line[ strlen( line ) - 1 ] = '\0';
					if( strcmp( line , curr_name ) )
					{
						strcpy( curr_name , line );
						bu_log( "Making %s\n" , curr_name );
d987 22
a1008 43
					break;
				case 10:
				case 20:
				case 30:
				case 11:
				case 21:
				case 31:
				case 12:
				case 22:
				case 32:
				case 13:
				case 23:
				case 33:
					i = group_code%10;
					j = group_code/10 - 1;
					if( i > no_of_pts )
						no_of_pts = i;
					if( fgets( line , LINELEN , dxf ) == NULL )
						rt_bomb( "Unexpected EOF in input file\n" );
					pt[i][j] = atof( line );
					if( verbose )
						bu_log( "\tpt[%d][%d]=%g\n", i,j,pt[i][j] );
					break;
				case 0:
					no_of_pts++;
					for( i=0 ; i<no_of_pts ; i++ )
					{
						for( j=i+1 ; j<no_of_pts ; j++ )
						{
							if( VAPPROXEQUAL( pt[i] , pt[j] , tol.dist ) )
							{
								int k;

								if( verbose )
									bu_log( "Combining points %d (%g,%g,%g) and %d (%g,%g,%g)\n",
										i, V3ARGS(pt[i]),j, V3ARGS(pt[j]) );
								no_of_pts--;
								for( k=j ; k<no_of_pts ; k++ )
								{
									VMOVE( pt[k] , pt[k+1] );
								}
								j--;
							}
d1011 11
a1021 6
					if( face_entity)
					{
						if( no_of_pts != 3 && no_of_pts != 4 )
						{
							bu_log( "Skipping face with %d vertices\n" , no_of_pts );
							break;
d1024 7
d1032 10
a1041 6
					if( verbose )
					{
						if( face_entity )
							bu_log( "FACE:\n" );
						else if( line_entity )
							bu_log( "LINE:\n" );
d1043 6
a1048 5
					for( i=0 ; i<no_of_pts ; i++ )
					{
						if( verbose )
							bu_log( "\t( %f %f %f )\n" , V3ARGS( pt[i] ) );
						vp[i] = (struct vertex *)NULL;
d1050 3
d1054 7
a1060 27
					if( face_entity )
					{
						fu = nmg_cface( s , vp , no_of_pts );
						bu_ptbl_ins( &faces , (long *)fu );

						for( i=0 ; i<no_of_pts ; i++ )
						{
							if( vp[i]->vg_p == NULL )
							{
								nmg_vertex_gv( vp[i] , pt[i] );
								bu_ptbl_ins( &vertices , (long *)vp[i] );
							}
						}
						for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
						{
							fastf_t area;
							plane_t pl;

							area = nmg_loop_plane_area( lu , pl );
							if( area > 0.0 )
							{
								if( lu->orientation == OT_OPPOSITE )
									HREVERSE( pl , pl );
								nmg_face_g( fu , pl );
								break;
							}
						}
d1062 459
a1520 17
					else if( line_entity )
					{
						struct edgeuse *eu = 
							(struct edgeuse *)NULL;

						for( i=1 ; i<no_of_pts ; i++ )
						{
							eu = nmg_me( vp[i-1], vp[i], s );
							nmg_vertex_gv( eu->vu_p->v_p, pt[i-1] );
						}
						nmg_vertex_gv( eu->eumate_p->vu_p->v_p, pt[no_of_pts-1] );
					}
					break;
				default:
					if( fgets( line , LINELEN , dxf ) == NULL )
						rt_bomb( "Unexpected EOF in input file\n" );
					break;
d1523 2
d1527 2
a1528 2
	/* fuse vertices that are within tolerance of each other */
	(void)nmg_model_vertex_fuse( m , &tol );
d1530 65
a1594 3
	/* glue faces together */
	bu_log( "Glueing %d faces together...\n" , BU_PTBL_END( &faces ) );
	nmg_gluefaces( (struct faceuse **)BU_PTBL_BASEADDR( &faces) , BU_PTBL_END( &faces ), &tol );
d1596 7
a1602 1
	nmg_rebound( m , &tol );
d1604 18
a1621 1
	nmg_fix_normals( s , &tol );
d1623 107
a1729 1
	nmg_vshell( &r->s_hd , r );
d1731 118
a1848 2
	/* write the nmg to the output file */
	if( polysolids )
d1850 35
a1884 5
		bu_log( "Writing polysolid to output...\n" );
		if( base_name )
			write_shell_as_polysolid( out_fp , base_name , s );
		else
			write_shell_as_polysolid( out_fp , "DXF" , s );
d1886 10
d1897 150
a2046 6
	{
		bu_log( "Writing NMG to output...\n" );
		if( base_name )
			mk_nmg( out_fp , base_name  , m );
		else
			mk_nmg( out_fp , "DXF"  , m );
d2049 1
a2049 2
	fprintf( stderr , "%d polygons\n" , BU_PTBL_END( &faces ) );
	return 0;
@


11.11
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d22 1
a22 1
static char *usage="dxf-g [-v] [-d] [-p] [-t tolerance] [-i input_file] [-o output_file_name]";
@


11.11.4.1
log
@sync to HEAD...
@
text
@d2 1
d6 1
a6 1
#  include <string.h>
d8 1
a8 1
#  include <strings.h>
d10 1
a12 1
#include "bu.h"
d14 2
a15 1
#include "bn.h"
d18 3
d22 1
a22 1
#include <ctype.h>
d24 21
a44 33
struct insert_data {
	fastf_t scale[3];
	fastf_t rotation;
	point_t insert_pt;
	vect_t extrude_dir;
};

struct state_data {
	struct bu_list l;
	struct block_list *curr_block;
	long file_offset;
	int state;
	int sub_state;
	mat_t xform;
};

static struct bu_list state_stack;
static struct state_data *curr_state;
static int curr_color=7;
static int ignore_colors=0;
static char *curr_layer_name;
static int color_by_layer=0;		/* flag, if set, colors are set by layer */

struct layer {
	char *name;			/* layer name */
	int color_number;		/* color */
	struct vert_root *vert_tree_root; /* root of vertex tree */
	int *part_tris;			/* list of triangles for current part */
	int max_tri;			/* number of triangles currently malloced */
	int curr_tri;			/* number of triangles currently being used */
	int line_count;
	int point_count;
	struct bu_ptbl solids;
d46 1
d48 1
a48 1
};
d50 10
a59 396
struct block_list {
	struct bu_list l;
	char *block_name;
	long offset;
	char handle[17];
	point_t base;
};

static struct bu_list block_head;
static struct block_list *curr_block=NULL;

static struct layer **layers=NULL;
static int max_layers;
static int next_layer;
static int curr_layer;

/* SECTIONS (states) */
#define UNKNOWN_SECTION		0
#define HEADER_SECTION		1
#define CLASSES_SECTION		2
#define TABLES_SECTION		3
#define BLOCKS_SECTION		4
#define ENTITIES_SECTION	5
#define OBJECTS_SECTION		6
#define THUMBNAILIMAGE_SECTION	7
#define NUM_SECTIONS		8

/* states for the ENTITIES section */
#define UNKNOWN_ENTITY_STATE		0
#define POLYLINE_ENTITY_STATE		1
#define POLYLINE_VERTEX_ENTITY_STATE	2
#define FACE3D_ENTITY_STATE		3
#define LINE_ENTITY_STATE		4
#define INSERT_ENTITY_STATE		5
#define POINT_ENTITY_STATE		6
#define CIRCLE_ENTITY_STATE		7
#define	ARC_ENTITY_STATE		8
#define DIMENSION_ENTITY_STATE		9
#define NUM_ENTITY_STATES		10

/* POLYLINE flags */
static int polyline_flag=0;
#define POLY_CLOSED		1
#define POLY_CURVE_FIT		2
#define POLY_SPLINE_FIT		4
#define	POLY_3D			8
#define	POLY_3D_MESH		16
#define	POLY_CLOSED_MESH	32
#define POLY_FACE_MESH		64
#define	POLY_PATTERN		128

/* POLYLINE VERTEX flags */
#define POLY_VERTEX_EXTRA	1
#define POLY_VERTEX_CURVE	2
#define POLY_VERTEX_SPLINE_V	8
#define POLY_VERTEX_SPLINE_C	16
#define POLY_VERTEX_3D_V	32
#define POLY_VERTEX_3D_M	64
#define POLY_VERTEX_FACE	128

/* states for the TABLES section */
#define UNKNOWN_TABLE_STATE	0
#define LAYER_TABLE_STATE	1
#define NUM_TABLE_STATES	2

static fastf_t *polyline_verts=NULL;
static int polyline_vertex_count=0;
static int polyline_vertex_max=0;
static int mesh_m_count=0;
static int mesh_n_count=0;
static int *polyline_vert_indices=NULL;
static int polyline_vert_indices_count=0;
static int polyline_vert_indices_max=0;
#define PVINDEX( _i, _j )	((_i)*mesh_n_count + (_j))
#define POLYLINE_VERTEX_BLOCK	10

static point_t pts[4];

#define UNKNOWN_ENTITY	0
#define POLYLINE_VERTEX		1

static int invisible=0;

#define ERROR_FLAG	-999
#define EOF_FLAG	-998

#define TOL_SQ	0.00001
#define LINELEN	2050
char line[LINELEN];

static char *usage="dxf-g [-d] [-v] [-t tolerance] [-s scale_factor] input_dxf_file output_file.g\n";

static FILE *dxf;
static struct rt_wdb *out_fp;
static char *output_file;
static char *dxf_file;
static int verbose=0;
static fastf_t tol=0.01;
static fastf_t tol_sq;
static char *base_name;
static char tmp_name[256];
static int segs_per_circle=32;
static fastf_t sin_delta, cos_delta;
static fastf_t delta_angle;
static point_t *circle_pts;
static fastf_t scale_factor;

#define TRI_BLOCK 512			/* number of triangles to malloc per call */

static int (*process_code[NUM_SECTIONS])( int code );
static int (*process_entities_code[NUM_ENTITY_STATES])( int code );
static int (*process_tables_sub_code[NUM_TABLE_STATES])( int code );

static int *int_ptr=NULL;
static int units=0;
static fastf_t units_conv[]={
	/* 0 */	1.0,
	/* 1 */	25.4,
	/* 2 */	304.8,
	/* 3 */	1609344.0,
	/* 4 */	1.0,
	/* 5 */	10.0,
	/* 6 */	1000.0,
	/* 7 */	1000000.0,
	/* 8 */	0.0000254,
	/* 9 */	0.0254,
	/* 10 */ 914.4,
	/* 11 */ 1.0e-7,
	/* 12 */ 1.0e-6,
	/* 13 */ 1.0e-3,
	/* 14 */ 100.0,
	/* 15 */ 10000.0,
	/* 16 */ 100000.0,
	/* 17 */ 1.0e+12,
	/* 18 */ 1.495979e+14,
	/* 19 */ 9.460730e+18,
	/* 20 */ 3.085678e+19
};

static unsigned char rgb[]={
	0, 0, 0,
	255, 0, 0,
	255, 255, 0,
	0, 255, 0,
	0, 255, 255,
	0, 0, 255,
	255, 0, 255,
	255, 255, 255,
	65, 65, 65,
	128, 128, 128,
	255, 0, 0,
	255, 128, 128,
	166, 0, 0,
	166, 83, 83,
	128, 0, 0,
	128, 64, 64,
	77, 0, 0,
	77, 38, 38,
	38, 0, 0,
	38, 19, 19,
	255, 64, 0,
	255, 159, 128,
	166, 41, 0,
	166, 104, 83,
	128, 32, 0,
	128, 80, 64,
	77, 19, 0,
	77, 48, 38,
	38, 10, 0,
	38, 24, 19,
	255, 128, 0,
	255, 191, 128,
	166, 83, 0,
	166, 124, 83,
	128, 64, 0,
	128, 96, 64,
	77, 38, 0,
	77, 57, 38,
	38, 19, 0,
	38, 29, 19,
	255, 191, 0,
	255, 223, 128,
	166, 124, 0,
	166, 145, 83,
	128, 96, 0,
	128, 112, 64,
	77, 57, 0,
	77, 67, 38,
	38, 29, 0,
	38, 33, 19,
	255, 255, 0,
	255, 255, 128,
	166, 166, 0,
	166, 166, 83,
	128, 128, 0,
	128, 128, 64,
	77, 77, 0,
	77, 77, 38,
	38, 38, 0,
	38, 38, 19,
	191, 255, 0,
	223, 255, 128,
	124, 166, 0,
	145, 166, 83,
	96, 128, 0,
	112, 128, 64,
	57, 77, 0,
	67, 77, 38,
	29, 38, 0,
	33, 38, 19,
	128, 255, 0,
	191, 255, 128,
	83, 166, 0,
	124, 166, 83,
	64, 128, 0,
	96, 128, 64,
	38, 77, 0,
	57, 77, 38,
	19, 38, 0,
	29, 38, 19,
	64, 255, 0,
	159, 255, 128,
	41, 166, 0,
	104, 166, 83,
	32, 128, 0,
	80, 128, 64,
	19, 77, 0,
	48, 77, 38,
	10, 38, 0,
	24, 38, 19,
	0, 255, 0,
	128, 255, 128,
	0, 166, 0,
	83, 166, 83,
	0, 128, 0,
	64, 128, 64,
	0, 77, 0,
	38, 77, 38,
	0, 38, 0,
	19, 38, 19,
	0, 255, 64,
	128, 255, 159,
	0, 166, 41,
	83, 166, 104,
	0, 128, 32,
	64, 128, 80,
	0, 77, 19,
	38, 77, 48,
	0, 38, 10,
	19, 38, 24,
	0, 255, 128,
	128, 255, 191,
	0, 166, 83,
	83, 166, 124,
	0, 128, 64,
	64, 128, 96,
	0, 77, 38,
	38, 77, 57,
	0, 38, 19,
	19, 38, 29,
	0, 255, 191,
	128, 255, 223,
	0, 166, 124,
	83, 166, 145,
	0, 128, 96,
	64, 128, 112,
	0, 77, 57,
	38, 77, 67,
	0, 38, 29,
	19, 38, 33,
	0, 255, 255,
	128, 255, 255,
	0, 166, 166,
	83, 166, 166,
	0, 128, 128,
	64, 128, 128,
	0, 77, 77,
	38, 77, 77,
	0, 38, 38,
	19, 38, 38,
	0, 191, 255,
	128, 223, 255,
	0, 124, 166,
	83, 145, 166,
	0, 96, 128,
	64, 112, 128,
	0, 57, 77,
	38, 67, 77,
	0, 29, 38,
	19, 33, 38,
	0, 128, 255,
	128, 191, 255,
	0, 83, 166,
	83, 124, 166,
	0, 64, 128,
	64, 96, 128,
	0, 38, 77,
	38, 57, 77,
	0, 19, 38,
	19, 29, 38,
	0, 64, 255,
	128, 159, 255,
	0, 41, 166,
	83, 104, 166,
	0, 32, 128,
	64, 80, 128,
	0, 19, 77,
	38, 48, 77,
	0, 10, 38,
	19, 24, 38,
	0, 0, 255,
	128, 128, 255,
	0, 0, 166,
	83, 83, 166,
	0, 0, 128,
	64, 64, 128,
	0, 0, 77,
	38, 38, 77,
	0, 0, 38,
	19, 19, 38,
	64, 0, 255,
	159, 128, 255,
	41, 0, 166,
	104, 83, 166,
	32, 0, 128,
	80, 64, 128,
	19, 0, 77,
	48, 38, 77,
	10, 0, 38,
	24, 19, 38,
	128, 0, 255,
	191, 128, 255,
	83, 0, 166,
	124, 83, 166,
	64, 0, 128,
	96, 64, 128,
	38, 0, 77,
	57, 38, 77,
	19, 0, 38,
	29, 19, 38,
	191, 0, 255,
	223, 128, 255,
	124, 0, 166,
	145, 83, 166,
	96, 0, 128,
	112, 64, 128,
	57, 0, 77,
	67, 38, 77,
	29, 0, 38,
	33, 19, 38,
	255, 0, 255,
	255, 128, 255,
	166, 0, 166,
	166, 83, 166,
	128, 0, 128,
	128, 64, 128,
	77, 0, 77,
	77, 38, 77,
	38, 0, 38,
	38, 19, 38,
	255, 0, 191,
	255, 128, 223,
	166, 0, 124,
	166, 83, 145,
	128, 0, 96,
	128, 64, 112,
	77, 0, 57,
	77, 38, 67,
	38, 0, 29,
	38, 19, 33,
	255, 0, 128,
	255, 128, 191,
	166, 0, 83,
	166, 83, 124,
	128, 0, 64,
	128, 64, 96,
	77, 0, 38,
	77, 38, 57,
	38, 0, 19,
	38, 19, 29,
	255, 0, 64,
	255, 128, 159,
	166, 0, 41,
	166, 83, 104,
	128, 0, 32,
	128, 64, 80,
	77, 0, 19,
	77, 38, 48,
	38, 0, 10,
	38, 19, 24,
	84, 84, 84,
	118, 118, 118,
	152, 152, 152,
	187, 187, 187,
	221, 221, 221,
	255, 255, 255 };
d61 27
a87 32

static char *
make_brlcad_name( char *line )
{
	char *name;
	char *c;

	name = bu_strdup( line );

	c = name;
	while( *c != '\0' ) {
		if( *c == '/' || *c == '[' || *c == ']' || *c == '*' || isspace( *c ) ) {
			*c = '_';
		}
		c++;
	}

	return( name );
}

static void
get_layer()
{
	int i;
	int old_layer=curr_layer;

	/* do we already have a layer by this name and color */
	curr_layer = -1;
	for( i = 1 ; i < next_layer ; i++ ) {
		if( !color_by_layer && !ignore_colors ) {
			if( layers[i]->color_number == curr_color && !strcmp( curr_layer_name, layers[i]->name ) ) {
				curr_layer = i;
d89 2
a90 4
			}
		} else {
			if( !strcmp( curr_layer_name, layers[i]->name ) ) {
				curr_layer = i;
a91 1
			}
d95 6
a100 24
	if( curr_layer == -1 ) {
		/* add a new layer */
		if( next_layer >= max_layers ) {
			if( verbose ) {
				bu_log( "Creating new block of layers\n" );
			}
			max_layers += 5;
			layers = (struct layer **)bu_realloc( layers,
					    max_layers*sizeof( struct layer *), "layers" );
			for( i=0 ; i<5 ; i++ ) {
				BU_GETSTRUCT( layers[max_layers-i-1], layer );
			}
		}
		curr_layer = next_layer++;
		if( verbose ) {
			bu_log( "New layer: %s, color number: %d", line, curr_color );
		}
		layers[curr_layer]->name = bu_strdup( curr_layer_name );
		layers[curr_layer]->vert_tree_root = create_vert_tree();
		layers[curr_layer]->color_number = curr_color;
		bu_ptbl_init( &layers[curr_layer]->solids, 8, "layers[curr_layer]->solids" );
		if( verbose ) {
			bu_log( "\tNew layer name: %s\n", layers[curr_layer]->name );
		}
d103 13
a115 4
	if( verbose && curr_layer != old_layer ) {
		bu_log( "changed to layer #%d, (m = x%x, s=x%x)\n", curr_layer, layers[curr_layer]->m, layers[curr_layer]->s );
	}
}
d117 2
a118 5
static void
create_nmg()
{
	struct model *m;
	struct nmgregion *r;
d120 1
a120 29
	m = nmg_mm();
	r = nmg_mrsv( m );
	layers[curr_layer]->s = BU_LIST_FIRST( shell, &r->s_hd );
	layers[curr_layer]->m = m;
}

/* routine to add a new triangle to the current part */
void
add_triangle( int v1, int v2, int v3, int layer )
{
	if( verbose ) {
		bu_log( "Adding triangle %d %d %d, to layer %s\n", v1, v2, v3, layers[layer]->name );
	}
	if( v1 == v2 || v2 == v3 || v3 == v1 ) {
		if( verbose ) {
			bu_log( "\tSkipping degenerate triangle\n" );
		}
		return;
	}
	if( layers[layer]->curr_tri >= layers[layer]->max_tri ) {
		/* allocate more memory for triangles */
		layers[layer]->max_tri += TRI_BLOCK;
		layers[layer]->part_tris = (int *)realloc( layers[layer]->part_tris,
							  sizeof( int ) * layers[layer]->max_tri * 3 );
		if( !layers[layer]->part_tris ) {
			bu_log( "ERROR: Failed to allocate memory for part triangles on layer %s\n",
				 layers[layer]->name);
			exit( 1 );
		}
d122 3
d126 38
a163 36
	/* fill in triangle info */
	layers[layer]->part_tris[layers[layer]->curr_tri*3 + 0] = v1;
	layers[layer]->part_tris[layers[layer]->curr_tri*3 + 1] = v2;
	layers[layer]->part_tris[layers[layer]->curr_tri*3 + 2] = v3;

	/* increment count */
	layers[layer]->curr_tri++;
}

static int
process_unknown_code( int code )
{
	switch( code ) {
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 0:		/* text string */
		if( !strncmp( line, "SECTION", 7 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		} else if( !strncmp( line, "ENDSEC", 6 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		}
		break;
	case 2:		/* name */
		if( !strncmp( line, "HEADER", 6 ) ) {
			curr_state->state = HEADER_SECTION;
			if( verbose ) {
				bu_log( "Change state to %d\n", curr_state->state );
			}
			break;
		} else if( !strncmp( line, "CLASSES", 7 ) ) {
			curr_state->state = CLASSES_SECTION;
			if( verbose ) {
				bu_log( "Change state to %d\n", curr_state->state );
a164 38
			break;
		} else if( !strncmp( line, "TABLES", 6 ) ) {
			curr_state->state = TABLES_SECTION;
			curr_state->sub_state = UNKNOWN_TABLE_STATE;
			if( verbose ) {
				bu_log( "Change state to %d\n", curr_state->state );
			}
			break;
		} else if( !strncmp( line, "BLOCKS", 6 ) ) {
			curr_state->state = BLOCKS_SECTION;
			if( verbose ) {
				bu_log( "Change state to %d\n", curr_state->state );
			}
			break;
		} else if( !strncmp( line, "ENTITIES", 8 ) ) {
			curr_state->state = ENTITIES_SECTION;
			curr_state->sub_state =UNKNOWN_ENTITY_STATE; 
			if( verbose ) {
				bu_log( "Change state to %d\n", curr_state->state );
			}
			break;
		} else if( !strncmp( line, "OBJECTS", 7 ) ) {
			curr_state->state = OBJECTS_SECTION;
			if( verbose ) {
				bu_log( "Change state to %d\n", curr_state->state );
			}
			break;
		} else if( !strncmp( line, "THUMBNAILIMAGE", 14 ) ) {
			curr_state->state = THUMBNAILIMAGE_SECTION;
			if( verbose ) {
				bu_log( "Change state to %d\n", curr_state->state );
			}
			break;
		}
		break;
	case 62:	/* color number */
		curr_color = atoi( line );
		break;
a165 33
	return( 0 );
}

static int
process_header_code( int code )
{
	switch( code ) {
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 0:		/* text string */
		if( !strncmp( line, "SECTION", 7 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		} else if( !strncmp( line, "ENDSEC", 6 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		}
		break;
	case 9:		/* variable name */
		if( !strncmp( line, "$INSUNITS", 9 ) ) {
			int_ptr = &units;
		} else if( !strcmp( line, "$CECOLOR" ) ) {
			int_ptr = &color_by_layer;
		}
		break;
	case 70:
	case 62:
		if( int_ptr ) {
			(*int_ptr) = atoi( line );
		}
		int_ptr = NULL;
		break;
a166 3
		
	return( 0 );
}
d168 4
a171 20
static int
process_classes_code( int code )
{
	switch( code ) {
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 0:		/* text string */
		if( !strncmp( line, "SECTION", 7 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		} else if( !strncmp( line, "ENDSEC", 6 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		}
		break;
	}
		
	return( 0 );
}
d173 2
a174 3
static int
process_tables_unknown_code( int code )
{
d176 18
a193 9
	switch( code ) {
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 0:		/* text string */
		if( !strcmp( line, "LAYER" ) ) {
			if( curr_layer_name ) {
				bu_free( curr_layer_name, "cur_layer_name" );
				curr_layer_name = NULL;
d195 10
a204 44
			curr_color = 0;
			curr_state->sub_state = LAYER_TABLE_STATE;
			break;
		} else if( !strcmp( line, "ENDTAB" ) ) {
			if( curr_layer_name ) {
				bu_free( curr_layer_name, "cur_layer_name" );
				curr_layer_name = NULL;
			}
			curr_color = 0;
			curr_state->sub_state = UNKNOWN_TABLE_STATE;
			break;
		} else if( !strncmp( line, "SECTION", 7 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		} else if( !strncmp( line, "ENDSEC", 6 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		}
		break;
	}
		
	return( 0 );
}

static int
process_tables_layer_code( int code )
{
	switch( code ) {
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 2:		/* layer name */
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "curr_layer_name" );
		}
		curr_layer_name = make_brlcad_name( line );
		break;
	case 62:	/* layer color */
		curr_color = atoi( line );
		break;
	case 0:		/* text string */
		if( color_by_layer ) {
			if( curr_layer_name && curr_color ) {
				get_layer();
d208 1
a208 37
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "cur_layer_name" );
			curr_layer_name = NULL;
		}
		curr_color = 0;
		curr_state->sub_state = UNKNOWN_TABLE_STATE;
		return( process_tables_unknown_code( code ) );
	}
		
	return( 0 );
}

static int
process_tables_code( int code )
{
	return( process_tables_sub_code[curr_state->sub_state]( code ) );
}

static int
process_blocks_code( int code )
{
	int len;
	int coord;

	switch( code ) {
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 0:		/* text string */
		if( !strncmp( line, "SECTION", 7 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		} else if( !strncmp( line, "ENDSEC", 6 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		} else if( !strcmp( line, "ENDBLK" ) ) {
			curr_block = NULL;
a209 40
		} else if( !strncmp( line, "BLOCK", 5 ) ) {
			/* start of a new block */
			BU_GETSTRUCT( curr_block, block_list );
			curr_block->offset = ftell( dxf );
			BU_LIST_INSERT( &(block_head), &(curr_block->l) );
			break;
		}
		break;
	case 2:		/* block name */
		if( curr_block ) {
			curr_block->block_name = bu_strdup( line );
			if( verbose ) {
				bu_log( "BLOCK %s begins at %ld\n",
					curr_block->block_name,
					curr_block->offset );
			}
		}
		break;
	case 5:		/* block handle */
		if( curr_block ) {
			len = strlen( line );
			if( len > 16 ) {
				len = 16;
			}
			strncpy( curr_block->handle, line, len );
			curr_block->handle[len] = '\0';
		}
		break;
	case 10:
	case 20:
	case 30:
		if( curr_block ) {
			coord = code / 10 - 1;
			curr_block->base[coord] = atof( line ) * units_conv[units] * scale_factor;
		}
		break;
	}
		
	return( 0 );
}
d211 8
a218 35
void
add_polyface_mesh_triangle( int v1, int v2, int v3 )
{
}

void
add_polyline_vertex( fastf_t x, fastf_t y, fastf_t z )
{
	if( !polyline_verts ) {
		polyline_verts = (fastf_t *)bu_malloc( POLYLINE_VERTEX_BLOCK*3*sizeof( fastf_t ), "polyline_verts" );
		polyline_vertex_count = 0;
		polyline_vertex_max = POLYLINE_VERTEX_BLOCK;
	} else if( polyline_vertex_count >= polyline_vertex_max ) {
		polyline_vertex_max += POLYLINE_VERTEX_BLOCK;
		polyline_verts = (fastf_t *)bu_realloc( polyline_verts, polyline_vertex_max * 3 * sizeof( fastf_t ), "polyline_verts" );
	}

	VSET( &polyline_verts[polyline_vertex_count*3], x, y, z );
	polyline_vertex_count++;

	if( verbose ) {
		bu_log( "Added polyline vertex (%g %g %g) #%d\n", x, y, z, polyline_vertex_count );
	}
}

static int
process_point_entities_code( int code )
{
	static point_t pt;
	int coord;

	switch( code ) {
	case 8:		/* layer name */
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "curr_layer_name" );
d220 6
a225 37
		curr_layer_name = make_brlcad_name( line );
		break;
	case 10:
	case 20:
	case 30:
		coord = code / 10 - 1;
		pt[coord] = atof( line ) * units_conv[units] * scale_factor;
		break;
	case 62:	/* color number */
		curr_color = atoi( line );
		break;
	case 0:
		get_layer();
		layers[curr_layer]->point_count++;
		sprintf( tmp_name, "point.%d", layers[curr_layer]->point_count );
		(void)mk_sph( out_fp, tmp_name, pt, 0.1 );
		(void)bu_ptbl_ins( &(layers[curr_layer]->solids), (long *)bu_strdup( tmp_name ) );
		curr_state->sub_state = UNKNOWN_ENTITY_STATE;
		process_entities_code[curr_state->sub_state]( code );
		break;
	}

	return( 0 );
}

static int
process_entities_polyline_vertex_code( int code )
{
	static fastf_t x, y, z;
	static int face[4];
	static int vertex_flag=0;
	int coord;

	switch( code ) {
	case 8:		/* layer name */
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "curr_layer_name" );
a226 67
		curr_layer_name = make_brlcad_name( line );
		break;
	case 70:	/* vertex flag */
		vertex_flag = atoi( line );
		break;
	case 71:
	case 72:
	case 73:
	case 74:
		coord = (code % 70) - 1;
		face[coord] = abs( atoi( line ) );
		break;
	case 0:
		get_layer();
		if( vertex_flag == POLY_VERTEX_FACE ) {
			add_triangle( polyline_vert_indices[face[0]-1],
				      polyline_vert_indices[face[1]-1],
				      polyline_vert_indices[face[2]-1],
				      curr_layer );
			if( face[3] > 0 ) {
			add_triangle( polyline_vert_indices[face[2]-1],
				      polyline_vert_indices[face[3]-1],
				      polyline_vert_indices[face[0]-1],
				      curr_layer );
			}
		} else if( vertex_flag & POLY_VERTEX_3D_M) {
			if( polyline_vert_indices_count >= polyline_vert_indices_max ) {
				polyline_vert_indices_max += POLYLINE_VERTEX_BLOCK;
				polyline_vert_indices = (int *)bu_realloc( polyline_vert_indices,
									   polyline_vert_indices_max * sizeof( int ),
									   "polyline_vert_indices" );
			}
			polyline_vert_indices[polyline_vert_indices_count++] = Add_vert( x, y, z,
									     layers[curr_layer]->vert_tree_root,
									     tol_sq );
			if( verbose) {
				bu_log( "Added 3D mesh vertex (%g %g %g) index = %d, number = %d\n",
					x, y, z, polyline_vert_indices[polyline_vert_indices_count-1],
					polyline_vert_indices_count-1 );
			}
		} else {
			add_polyline_vertex( x, y, z );
		}
		curr_state->sub_state = POLYLINE_ENTITY_STATE;
		if( verbose ) {
			bu_log( "sub_state changed to %d\n", curr_state->sub_state );
		}
		return( process_entities_code[curr_state->sub_state]( code ) );
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 10:
		x = atof( line ) * units_conv[units] * scale_factor;
		break;
	case 20:
		y = atof( line ) * units_conv[units] * scale_factor;
		break;
	case 30:
		z = atof( line ) * units_conv[units] * scale_factor;
		break;
	case 62:	/* color number */
		curr_color = atoi( line );
		break;
	}
		
	return( 0 );
}
d228 5
a232 3
static int
process_entities_polyline_code( int code )
{
d234 13
a246 23
	switch( code ) {
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 0:		/* text string */
		get_layer();
		if( !strncmp( line, "SEQEND", 6 ) ) {
			/* build any polyline meshes here */
			if( polyline_flag & POLY_3D_MESH ) {
				if( polyline_vert_indices_count == 0 ) {
					return( 0 );
				} else if( polyline_vert_indices_count != mesh_m_count * mesh_n_count ) {
					bu_log( "Incorrect number of vertices for polygon mesh!!!\n" );
					polyline_vert_indices_count = 0;
				} else {
					int i, j;

					if( polyline_vert_indices_count >= polyline_vert_indices_max ) {
						polyline_vert_indices_max = ((polyline_vert_indices_count % POLYLINE_VERTEX_BLOCK) + 1) *
							POLYLINE_VERTEX_BLOCK;
						polyline_vert_indices = (int *)bu_realloc( polyline_vert_indices,
											   polyline_vert_indices_max * sizeof( int ),
											   "polyline_vert_indices" );
d248 43
a290 7

					if( mesh_m_count < 2 ) {
						if( mesh_n_count > 4 ) {
							bu_log( "Cannot handle polyline meshes with m<2 and n>4\n");
							polyline_vert_indices_count=0;
							polyline_vert_indices_count = 0;
							break;
d292 6
a297 3
						if( mesh_n_count < 3 ) {
							polyline_vert_indices_count=0;
							polyline_vert_indices_count = 0;
a299 10
						add_triangle( polyline_vert_indices[0],
							      polyline_vert_indices[1],
							      polyline_vert_indices[2],
							      curr_layer );
						if( mesh_n_count == 4 ) {
							add_triangle( polyline_vert_indices[2],
								      polyline_vert_indices[3],
								      polyline_vert_indices[0],
								      curr_layer );
						}
d302 6
a307 11
					for( j=1 ; j<mesh_n_count ; j++ ) {
						for( i=1 ; i<mesh_m_count ; i++ ) {
							add_triangle( polyline_vert_indices[PVINDEX(i-1,j-1)],
								      polyline_vert_indices[PVINDEX(i-1,j)],
								      polyline_vert_indices[PVINDEX(i,j-1)],
								      curr_layer );
							add_triangle( polyline_vert_indices[PVINDEX(i-1,j-1)],
								      polyline_vert_indices[PVINDEX(i,j-1)],
								      polyline_vert_indices[PVINDEX(i,j)],
								      curr_layer );
						}
d309 5
a313 11
					polyline_vert_indices_count=0;
					polyline_vertex_count = 0;
				}
			} else {
				int i;
				struct edgeuse *eu;
				struct vertex *v0=NULL, *v1=NULL, *v2=NULL;

				if( polyline_vertex_count > 1 ) {
					if( !layers[curr_layer]->m ) {
						create_nmg();
d316 12
a327 6
					for( i=0 ; i<polyline_vertex_count-1 ; i++ ) {
						eu = nmg_me( v1, v2, layers[curr_layer]->s );
						if( i == 0 ) {
							v1 = eu->vu_p->v_p;
							nmg_vertex_gv( v1, polyline_verts );
							v0 = v1;
d329 13
a341 6
						v2 = eu->eumate_p->vu_p->v_p;
						nmg_vertex_gv( v2, &polyline_verts[(i+1)*3] );
						if( verbose ) {
							bu_log( "Wire edge (polyline): (%g %g %g) <-> (%g %g %g)\n",
								V3ARGS( v1->vg_p->coord ),
								V3ARGS( v2->vg_p->coord ) );
a342 2
						v1 = v2;
						v2 = NULL;
d344 9
a352 8

					if( polyline_flag & POLY_CLOSED ) {
						v2 = v0;
						(void)nmg_me( v1, v2, layers[curr_layer]->s );
						if( verbose ) {
							bu_log( "Wire edge (closing polyline): (%g %g %g) <-> (%g %g %g)\n",
								V3ARGS( v1->vg_p->coord ),
								V3ARGS( v2->vg_p->coord ) );
d354 1
d356 5
a360 3
				}
				polyline_vert_indices_count=0;	
				polyline_vertex_count = 0;
a361 36

			curr_state->state = ENTITIES_SECTION;
			curr_state->sub_state = UNKNOWN_ENTITY_STATE;
			if( verbose ) {
				bu_log( "sub_state changed to %d\n", curr_state->sub_state );
			}
			break;
		} else if( !strncmp( line, "VERTEX", 6 ) ) {
			if( verbose)
				bu_log( "Found a POLYLINE VERTEX\n" );
			curr_state->sub_state = POLYLINE_VERTEX_ENTITY_STATE;
			break;
		} else {
			if( verbose ) {
				bu_log( "Unrecognized text string while in polyline entity: %s\n", line );
			}
			break;
		}
	case 70:	/* polyline flag */
		polyline_flag = atoi( line );
		break;
	case 71:
		mesh_m_count = atoi( line );
		break;
	case 72:
		mesh_n_count = atoi( line );
		break;
	case 62:	/* color number */
		curr_color = atoi( line );
		break;
	case 60:
		invisible = atoi( line );
		break;
	case 8:		/* layer name */
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "curr_layer_name" );
a362 2
		curr_layer_name = make_brlcad_name( line );
		break;
a363 3
		
	return( 0 );
}
d365 2
a366 4
static int
process_entities_unknown_code( int code )
{
	struct state_data *tmp_state;
d368 3
a370 1
	invisible = 0;
d372 1
a372 88
	switch( code ) {
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 0:		/* text string */
		if( !strncmp( line, "SECTION", 7 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		} else if( !strncmp( line, "ENDSEC", 6 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		} else if( !strncmp( line, "POLYLINE", 8 ) ) {
			if( verbose)
				bu_log( "Found a POLYLINE\n" );
			curr_state->sub_state = POLYLINE_ENTITY_STATE;
			if( verbose ) {
				bu_log( "sub_state changed to %d\n", curr_state->sub_state );
			}
			break;
		} else if( !strncmp( line, "3DFACE", 6 ) ) {
			curr_state->sub_state = FACE3D_ENTITY_STATE;
			if( verbose ) {
				bu_log( "sub_state changed to %d\n", curr_state->sub_state );
			}
			break;
		} else if( !strcmp( line, "CIRCLE" ) ) {
			curr_state->sub_state = CIRCLE_ENTITY_STATE;
			if( verbose ) {
				bu_log( "sub_state changed to %d\n", curr_state->sub_state );
			}
			break;
		} else if( !strcmp( line, "ARC" ) ) {
			curr_state->sub_state = ARC_ENTITY_STATE;
			if( verbose ) {
				bu_log( "sub_state changed to %d\n", curr_state->sub_state );
			}
			break;
		} else if( !strcmp( line, "DIMENSION" ) ) {
			curr_state->sub_state = DIMENSION_ENTITY_STATE;
			if( verbose ) {
				bu_log( "sub_state changed to %d\n", curr_state->sub_state );
			}
			break;
		} else if( !strncmp( line, "LINE", 4 ) ) {
			curr_state->sub_state = LINE_ENTITY_STATE;
			if( verbose ) {
				bu_log( "sub_state changed to %d\n", curr_state->sub_state );
			}
			break;
		} else if( !strcmp( line, "POINT" ) ) {
			curr_state->sub_state = POINT_ENTITY_STATE;
			if( verbose ) {
				bu_log( "sub_state changed to %d\n", curr_state->sub_state );
			}
			break;
		} else if( !strncmp( line, "INSERT", 6 ) ) {
			curr_state->sub_state = INSERT_ENTITY_STATE;
			if( verbose ) {
				bu_log( "sub_state changed to %d\n", curr_state->sub_state );
			}
			break;
		} else if( !strcmp( line, "ENDBLK" ) ) {
			/* found end of an inserted block, pop the state stack */
			tmp_state = curr_state;
			BU_LIST_POP( state_data, &state_stack, curr_state );
			if( !curr_state ) {
				bu_log( "ERROR: end of block encountered while not inserting!!!\n" );
				curr_state = tmp_state;
				break;
			}
			bu_free( (char *)tmp_state, "curr_state" );
			fseek( dxf, curr_state->file_offset, SEEK_SET );
			curr_state->sub_state = UNKNOWN_ENTITY_STATE;
			if( verbose ) {
				bu_log( "Popped state at end of inserted block (seeked to %ld)\n", curr_state->file_offset );
			}
			break;
		} else {
			if( verbose ) {
				bu_log( "Unrecognized text string while in unknown entities state: %s\n",
					line );
			}
			break;
		}
	}
		
	return( 0 );
}
d374 1
a374 8
static void
insert_init( struct insert_data *ins )
{
	VSETALL( ins->scale, 1.0 );
	ins->rotation = 0.0;
	VSETALL( ins->insert_pt, 0.0 );
	VSET( ins->extrude_dir, 0, 0, 1 );
}
d376 1
a376 16
static int
process_insert_entities_code( int code )
{
	static struct insert_data ins;
	static struct state_data *new_state=NULL;
	struct block_list *blk;
	int coord;

	if( !new_state ) {
		insert_init( &ins );
		BU_GETSTRUCT( new_state, state_data );
		*new_state = *curr_state;
		if( verbose ) {
			bu_log( "Created a new state for INSERT\n" );
		}
	}
d378 2
a379 615
	switch( code ) {
	case 8:		/* layer name */
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "curr_layer_name" );
		}
		curr_layer_name = make_brlcad_name( line );
		break;
	case 2:		/* block name */
		for( BU_LIST_FOR( blk, block_list, &block_head ) ) {
			if( !strcmp( blk->block_name, line ) ) {
				break;
			}
		}
		if( BU_LIST_IS_HEAD( blk, &block_head ) ) {
			bu_log( "ERROR: INSERT references non-existent block (%s)\n", line );
			bu_log( "\tignoring missing block\n" );
			blk = NULL;
		}
		new_state->curr_block = blk;
		if( verbose && blk ) {
			bu_log( "Inserting block %s\n", blk->block_name );
		}
		break;
	case 10:
	case 20:
	case 30:
		coord = (code / 10) - 1;
		ins.insert_pt[coord] = atof( line );
		break;
	case 41:
	case 42:
	case 43:
		coord = (code % 40) - 1;
		ins.scale[coord] = atof( line );
		break;
	case 50:
		ins.rotation = atof( line );
		break;
	case 62:	/* color number */
		curr_color = atoi( line );
		break;
	case 70:
	case 71:
		if( atof( line ) != 1 ) {
			bu_log( "Cannot yet handle insertion of a pattern\n\tignoring\n" );
		}
		break;
	case 44:
	case 45:
		break;
	case 210:
	case 220:
	case 230:
		coord = ((code / 10) % 20) - 1;
		ins.extrude_dir[coord] = atof( line );
		break;
	case 0:		/* end of this insert */
		if( new_state->curr_block ) {
			BU_LIST_PUSH( &state_stack, &(curr_state->l) );
			curr_state = new_state;
			new_state = NULL;
			fseek( dxf, curr_state->curr_block->offset, SEEK_SET );
			curr_state->state = ENTITIES_SECTION;
			curr_state->sub_state = UNKNOWN_ENTITY_STATE;
			if( verbose ) {
				bu_log( "Changing state for INSERT\n" );
				bu_log( "seeked to %ld\n", curr_state->curr_block->offset );
			}
		}
		break;
	}

	return( 0 );
}

static int
process_line_entities_code( int code )
{
	int vert_no;
	int coord;
	static point_t line_pt[2];
	struct edgeuse *eu;

	switch( code ) {
	case 8:
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "curr_layer_name" );
		}
		curr_layer_name = make_brlcad_name( line );
		break;
	case 10:
	case 20:
	case 30:
	case 11:
	case 21:
	case 31:
		vert_no = code % 10;
		coord = code / 10 - 1;
		line_pt[vert_no][coord] = atof( line ) * units_conv[units] * scale_factor;
		if( verbose ) {
			bu_log( "LINE vertex #%d coord #%d = %g\n", vert_no, coord, line_pt[vert_no][coord] );
		}
		break;
	case 62:	/* color number */
		curr_color = atoi( line );
		break;
	case 0:
		/* end of this line */
		get_layer();
		if( verbose ) {
			bu_log( "Found end of LINE\n" );
		}

		layers[curr_layer]->line_count++;

		if( !layers[curr_layer]->m ) {
			create_nmg();
		}

		/* create a wire edge in the NMG */
		eu = nmg_me( NULL, NULL, layers[curr_layer]->s );
		nmg_vertex_gv( eu->vu_p->v_p, line_pt[0] );
		nmg_vertex_gv( eu->eumate_p->vu_p->v_p, line_pt[1] );
		if( verbose ) {
			bu_log( "Wire edge (line): (%g %g %g) <-> (%g %g %g)\n",
				V3ARGS(eu->vu_p->v_p->vg_p->coord ),
				V3ARGS(eu->eumate_p->vu_p->v_p->vg_p->coord ) );
		}

		curr_state->sub_state = UNKNOWN_ENTITY_STATE;
		process_entities_code[curr_state->sub_state]( code );
		break;
	}
	
	return( 0 );
}

static int
process_circle_entities_code( int code )
{
	static point_t center;
	static fastf_t radius;
	int coord, i;
	struct vertex *v0=NULL, *v1=NULL, *v2=NULL;
	struct edgeuse *eu;

	switch( code ) {
	case 8:		/* layer name */
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "curr_layer_name" );
		}
		curr_layer_name = make_brlcad_name( line );
		break;
	case 10:
	case 20:
	case 30:
		coord = code / 10 - 1;
		center[coord] = atof( line ) * units_conv[units] * scale_factor;
		if( verbose ) {
			bu_log( "CIRCLE center coord #%d = %g\n", coord, center[coord] );
		}
		break;
	case 40:
		radius = atof( line ) * units_conv[units] * scale_factor;
		break;
	case 62:	/* color number */
		curr_color = atoi( line );
		break;
	case 0:
		/* end of this circle entity
		 * make a series of wire edges in the NMG to approximate a circle
		 */

		get_layer();
		if( verbose ) {
			bu_log( "Found a circle\n" );
		}

		if( !layers[curr_layer]->m ) {
			create_nmg();
		}

		/* calculate circle at origin first */
		VSET( circle_pts[0], radius, 0.0, 0.0 );
		for( i=1 ; i<segs_per_circle ; i++ ) {
			circle_pts[i][X] = circle_pts[i-1][X]*cos_delta - circle_pts[i-1][Y]*sin_delta;
			circle_pts[i][Y] = circle_pts[i-1][Y]*cos_delta + circle_pts[i-1][X]*sin_delta;
		}

		/* move everything to the specified center */
		for( i=0 ; i<segs_per_circle ; i++ ) {
			VADD2( circle_pts[i], circle_pts[i], center );
		}

		/* make nmg wire edges */
		for( i=0 ; i<segs_per_circle ; i++ ) {
			if( i+1 == segs_per_circle ) {
				v2 = v0;
			}
			eu = nmg_me( v1, v2, layers[curr_layer]->s );
			if( i == 0 ) {
				v1 = eu->vu_p->v_p;
				v0 = v1;
				nmg_vertex_gv( v1, circle_pts[0] );
			}
			v2 = eu->eumate_p->vu_p->v_p;
			if( i+1 < segs_per_circle ) {
				nmg_vertex_gv( v2, circle_pts[i+1] );
			}
			if( verbose ) {
				bu_log( "Wire edge (circle): (%g %g %g) <-> (%g %g %g)\n",
					V3ARGS( v1->vg_p->coord ),
					V3ARGS( v2->vg_p->coord ) );
			}
			v1 = v2;
			v2 = NULL;
		}

		curr_state->sub_state = UNKNOWN_ENTITY_STATE;
		process_entities_code[curr_state->sub_state]( code );
		break;
	}

	return( 0 );
}

static int
process_dimension_entities_code( int code )
{
	static point_t def_pt={0.0, 0.0, 0.0};
	static char *block_name=NULL;
	static struct state_data *new_state=NULL;
	struct block_list *blk;
	int coord;

	switch( code ) {
	case 10:
	case 20:
	case 30:
		coord = (code / 10) - 1;
		def_pt[coord] = atof( line ) * units_conv[units] * scale_factor;
		break;
	case 8:		/* layer name */
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "curr_layer_name" );
		}
		curr_layer_name = make_brlcad_name( line );
		break;
	case 2:	/* block name */
		block_name = bu_strdup( line );
		break;
	case 0:
		/* insert this dimension */
		get_layer();
		BU_GETSTRUCT( new_state, state_data );
		*new_state = *curr_state;
		if( verbose ) {
			bu_log( "Created a new state for DIMENSION\n" );
		}
		for( BU_LIST_FOR( blk, block_list, &block_head ) ) {
			if( !strcmp( blk->block_name, block_name ) ) {
				break;
			}
		}
		if( BU_LIST_IS_HEAD( blk, &block_head ) ) {
			bu_log( "ERROR: INSERT references non-existent block (%s)\n", line );
			bu_log( "\tignoring missing block\n" );
			blk = NULL;
		}
		new_state->curr_block = blk;
		if( verbose && blk ) {
			bu_log( "Inserting block %s\n", blk->block_name );
		}

		bu_free( block_name, "block_name" );
		
		if( new_state->curr_block ) {
			BU_LIST_PUSH( &state_stack, &(curr_state->l) );
			curr_state = new_state;
			new_state = NULL;
			fseek( dxf, curr_state->curr_block->offset, SEEK_SET );
			curr_state->state = ENTITIES_SECTION;
			curr_state->sub_state = UNKNOWN_ENTITY_STATE;
			if( verbose ) {
				bu_log( "Changing state for INSERT\n" );
				bu_log( "seeked to %ld\n", curr_state->curr_block->offset );
			}
		}

		break;
	}

	return( 0 );
}

static int
process_arc_entities_code( int code )
{
	static point_t center={0,0,0};
	static fastf_t radius;
	static fastf_t start_angle, end_angle;
	int num_segs;
	int coord, i;
	struct vertex *v0=NULL, *v1=NULL, *v2=NULL;
	struct edgeuse *eu;

	switch( code ) {
	case 8:		/* layer name */
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "curr_layer_name" );
		}
		curr_layer_name = make_brlcad_name( line );
		break;
	case 10:
	case 20:
	case 30:
		coord = code / 10 - 1;
		center[coord] = atof( line ) * units_conv[units] * scale_factor;
		if( verbose ) {
			bu_log( "ARC center coord #%d = %g\n", coord, center[coord] );
		}
		break;
	case 40:
		radius = atof( line ) * units_conv[units] * scale_factor;
		if( verbose) {
			bu_log( "ARC radius = %g\n", radius );
		}
		break;
	case 50:
		start_angle = atof( line );
		if( verbose ) {
			bu_log( "ARC start angle = %g\n", start_angle );
		}
		break;
	case 51:
		end_angle = atof( line );
		if( verbose ) {
			bu_log( "ARC end angle = %g\n", end_angle );
		}
		break;
	case 62:	/* color number */
		curr_color = atoi( line );
		break;
	case 0:
		/* end of this arc entity
		 * make a series of wire edges in the NMG to approximate an arc
		 */

		get_layer();
		if( verbose ) {
			bu_log( "Found an arc\n" );
		}

		if( !layers[curr_layer]->m ) {
			create_nmg();
		}

		while( end_angle < start_angle ) {
			end_angle += 360.0;
		}

		/* calculate arc at origin first */
		num_segs = (end_angle - start_angle) / 360.0 * segs_per_circle;
		start_angle *= M_PI / 180.0;
		end_angle *= M_PI / 180.0;
		if( verbose ) {
			bu_log( "arc has %d segs\n", num_segs );
		}

		if( num_segs < 1 ) {
			num_segs = 1;
		}
		VSET( circle_pts[0], radius * cos( start_angle ), radius * sin( start_angle ), 0.0 );
		for( i=1 ; i<num_segs ; i++ ) {
			circle_pts[i][X] = circle_pts[i-1][X]*cos_delta - circle_pts[i-1][Y]*sin_delta;
			circle_pts[i][Y] = circle_pts[i-1][Y]*cos_delta + circle_pts[i-1][X]*sin_delta;
		}
		circle_pts[num_segs][X] = radius * cos( end_angle );
		circle_pts[num_segs][Y] = radius * sin( end_angle );
		num_segs++;

		if( verbose ) {
			bu_log( "ARC points calculated:\n" );
			for( i=0 ; i<num_segs ; i++ ) {
				bu_log( "\t point #%d: (%g %g %g)\n", i, V3ARGS( circle_pts[i] ) );
			}
		}

		/* move everything to the specified center */
		for( i=0 ; i<num_segs ; i++ ) {
			VADD2( circle_pts[i], circle_pts[i], center );
		}

		if( verbose ) {
			bu_log( "ARC points after move to center at (%g %g %g):\n", V3ARGS( center ) );
			for( i=0 ; i<num_segs ; i++ ) {
				bu_log( "\t point #%d: (%g %g %g)\n", i, V3ARGS( circle_pts[i] ) );
			}
		}

		/* make nmg wire edges */
		for( i=1 ; i<num_segs ; i++ ) {
			if( i == num_segs ) {
				v2 = v0;
			}
			eu = nmg_me( v1, v2, layers[curr_layer]->s );
			if( i == 1 ) {
				v1 = eu->vu_p->v_p;
				v0 = v1;
				nmg_vertex_gv( v1, circle_pts[0] );
			}
			v2 = eu->eumate_p->vu_p->v_p;
			if( i < segs_per_circle ) {
				nmg_vertex_gv( v2, circle_pts[i] );
			}
			if( verbose ) {
				bu_log( "Wire edge (arc) #%d (%g %g %g) <-> (%g %g %g)\n", i,
					V3ARGS( v1->vg_p->coord ),
					V3ARGS( v2->vg_p->coord ) );
			}
			v1 = v2;
			v2 = NULL;
		}

		VSETALL( center, 0.0 );
		for( i=0 ; i<segs_per_circle ; i++ ) {
			VSETALL( circle_pts[i], 0.0 );
		}

		curr_state->sub_state = UNKNOWN_ENTITY_STATE;
		process_entities_code[curr_state->sub_state]( code );
		break;
	}

	return( 0 );
}

static int
process_3dface_entities_code( int code )
{
	int vert_no;
	int coord;
	int face[5];

	switch( code ) {
	case 8:
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "curr_layer_name" );
		}
		curr_layer_name = make_brlcad_name( line );
		break;
	case 10:
	case 20:
	case 30:
	case 11:
	case 21:
	case 31:
	case 12:
	case 22:
	case 32:
	case 13:
	case 23:
	case 33:
		vert_no = code % 10;
		coord = code / 10 - 1;
		pts[vert_no][coord] = atof( line ) * units_conv[units] * scale_factor;
		if( verbose ) {
			bu_log( "3dface vertex #%d coord #%d = %g\n", vert_no, coord, pts[vert_no][coord] );
		}
		if( vert_no == 2 ) {
			pts[3][coord] = pts[2][coord];
		}
		break;
	case 62:	/* color number */
		curr_color = atoi( line );
		break;
	case 0:
		/* end of this 3dface */
		get_layer();
		if( verbose ) {
			bu_log( "Found end of 3DFACE\n" );
		}
		if( verbose ) {
			bu_log( "\tmaking two triangles\n" );
		}
		for( vert_no=0 ; vert_no<4; vert_no++ ) {
			face[vert_no] = Add_vert( V3ARGS( pts[vert_no]),
						  layers[curr_layer]->vert_tree_root,
						  tol_sq );
		}
		add_triangle( face[0], face[1], face[2], curr_layer );
		add_triangle( face[2], face[3], face[0], curr_layer );
		if( verbose ) {
			bu_log( "finished face\n" );
		}

		curr_state->sub_state = UNKNOWN_ENTITY_STATE;
		process_entities_code[curr_state->sub_state]( code );
		break;
	}
	
	return( 0 );
}

static int
process_entity_code( int code )
{
	return( process_entities_code[curr_state->sub_state]( code ) );
}

static int
process_objects_code( int code )
{
	switch( code ) {
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 0:		/* text string */
		if( !strncmp( line, "SECTION", 7 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		} else if( !strncmp( line, "ENDSEC", 6 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		}
		break;
	}
		
	return( 0 );
}

static int
process_thumbnail_code( int code )
{
	switch( code ) {
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 0:		/* text string */
		if( !strncmp( line, "SECTION", 7 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		} else if( !strncmp( line, "ENDSEC", 6 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		}
		break;
	}
		
	return( 0 );
}

int
readcodes()
{
	int code;
	int line_len;
	static int line_num=0;

	curr_state->file_offset = ftell( dxf );

	if( fgets( line, LINELEN, dxf ) == NULL ) {
		return( ERROR_FLAG );
	} else {
		code = atoi( line );
	}

	if( fgets( line, LINELEN, dxf ) == NULL ) {
		return( ERROR_FLAG );
	}

	if( !strncmp( line, "EOF", 3 ) ) {
		return( EOF_FLAG );
	}

	line_len = strlen( line );
	if( line_len ) {
		line[line_len-1] = '\0';
		line_len--;
	}

	if( line_len && line[line_len-1] == '\r' ) {
		line[line_len-1] = '\0';
		line_len--;
	}

	if( verbose ) {
		line_num++;
		bu_log( "%d:\t%d\n", line_num, code );
		line_num++;
		bu_log( "%d:\t%s\n", line_num, line );
	}

	return( code );
}

int
main( int argc, char *argv[] )
{
	struct bu_list head_all;
	int name_len;
	char *ptr1, *ptr2;
	int code;
	int c;
	int i;

	tol_sq = tol * tol;

	delta_angle = 2.0 * M_PI / (fastf_t)segs_per_circle;
	sin_delta = sin( delta_angle );
	cos_delta = cos( delta_angle );

	/* get command line arguments */
	scale_factor = 1.0;
	while ((c = getopt(argc, argv, "cdvt:s:")) != EOF)
d381 5
a385 46
		switch( c )
		{
		        case 's':	/* scale factor */
				scale_factor = atof( optarg );
				if( scale_factor < SQRT_SMALL_FASTF ) {
					bu_log( "scale factor too small\n" );
					bu_log( "%s", usage );
					exit( 1 );
				}
				break;
		        case 'c':	/* ignore colors */
				ignore_colors = 1;
				break;
		        case 'd':	/* debug */
				bu_debug = BU_DEBUG_COREDUMP;
				break;
			case 't':	/* tolerance */
				tol = atof( optarg );
				tol_sq = tol * tol;
				break;
			case 'v':	/* verbose */
				verbose = 1;
				break;
			default:
				bu_bomb( usage );
				break;
		}
	}

	if( argc - optind < 2 ) {
		bu_bomb( usage );
	}

	dxf_file = argv[optind++];
	output_file = argv[optind];

	if( (out_fp = wdb_fopen( output_file )) == NULL ) {
		bu_log( "Cannot open output file (%s)\n", output_file );
		perror( output_file );
		bu_bomb( "Cannot open output file\n" );
	}

	if( (dxf=fopen( dxf_file, "r")) == NULL ) {
		bu_log( "Cannot open DXF file (%s)\n", dxf_file );
		perror( dxf_file );
		bu_bomb( "Cannot open DXF file\n" );
a386 4

	ptr1 = strrchr( dxf_file , '/' );
	if( ptr1 == NULL )
		ptr1 = dxf_file;
d388 6
a393 156
		ptr1++;
	ptr2 = strchr( ptr1 , '.' );

	if( ptr2 == NULL )
		name_len = strlen( ptr1 );
	else
		name_len = ptr2 - ptr1;

	base_name = (char *)bu_malloc( name_len + 1 , "base_name" );
	strncpy( base_name , ptr1 , name_len );

	mk_id( out_fp , base_name );

	BU_LIST_INIT( &block_head );

	process_code[UNKNOWN_SECTION] = process_unknown_code;
	process_code[HEADER_SECTION] = process_header_code;
	process_code[CLASSES_SECTION] = process_classes_code;
	process_code[TABLES_SECTION] = process_tables_code;
	process_code[BLOCKS_SECTION] = process_blocks_code;
	process_code[ENTITIES_SECTION] = process_entity_code;
	process_code[OBJECTS_SECTION] = process_objects_code;
	process_code[THUMBNAILIMAGE_SECTION] = process_thumbnail_code;

	process_entities_code[UNKNOWN_ENTITY_STATE] = process_entities_unknown_code;
	process_entities_code[POLYLINE_ENTITY_STATE] = process_entities_polyline_code;
	process_entities_code[POLYLINE_VERTEX_ENTITY_STATE] = process_entities_polyline_vertex_code;
	process_entities_code[FACE3D_ENTITY_STATE] = process_3dface_entities_code;
	process_entities_code[LINE_ENTITY_STATE] = process_line_entities_code;
	process_entities_code[INSERT_ENTITY_STATE] = process_insert_entities_code;
	process_entities_code[POINT_ENTITY_STATE] = process_point_entities_code;
	process_entities_code[CIRCLE_ENTITY_STATE] = process_circle_entities_code;
	process_entities_code[ARC_ENTITY_STATE] = process_arc_entities_code;
	process_entities_code[DIMENSION_ENTITY_STATE] = process_dimension_entities_code;

	process_tables_sub_code[UNKNOWN_TABLE_STATE] = process_tables_unknown_code;
	process_tables_sub_code[LAYER_TABLE_STATE] = process_tables_layer_code;

	/* create storage for circles */
	circle_pts = (point_t *)bu_calloc( segs_per_circle, sizeof( point_t ), "circle_pts" );
	for( i=0 ; i<segs_per_circle ; i++ ) {
		VSETALL( circle_pts[i], 0.0 );
	}

	/* initialize state stack */
	BU_LIST_INIT( &state_stack );

	/* create initial state */
	BU_GETSTRUCT( curr_state, state_data );
	curr_state->file_offset = 0;
	curr_state->state = UNKNOWN_SECTION;
	curr_state->sub_state = UNKNOWN_ENTITY_STATE;
	MAT_IDN( curr_state->xform );

	/* make space for 5 layers to start */
	max_layers = 5;
	next_layer = 1;
	curr_layer = 0;
	layers = (struct layer **)bu_calloc( 5, sizeof( struct layer *), "layers" );
	for( i=0 ; i<max_layers ; i++ ) {
		BU_GETSTRUCT( layers[i], layer );
	}
	layers[0]->name = bu_strdup( "noname" );
	layers[0]->color_number = 7;	/* default white */
	layers[0]->vert_tree_root = create_vert_tree();
	bu_ptbl_init( &layers[0]->solids, 8, "layers[curr_layer]->solids" );

	curr_color = layers[0]->color_number;
	curr_layer_name = bu_strdup( layers[0]->name );

	while( (code=readcodes()) > -900 ) {
		process_code[curr_state->state](code);
	}

	BU_LIST_INIT( &head_all );
	for( i=0 ; i<next_layer ; i++ ) {
		struct bu_list head;
		int j;

		BU_LIST_INIT( &head );

		if( layers[i]->curr_tri || BU_PTBL_END( &layers[i]->solids ) || layers[i]->m ) {
			bu_log( "LAYER: %s\n", layers[i]->name );
		}

		if( layers[i]->curr_tri ) {
			bu_log( "\t%d triangles\n", layers[i]->curr_tri );
			sprintf( tmp_name, "bot.s%d", i );
			if( mk_bot( out_fp, tmp_name, RT_BOT_SURFACE, RT_BOT_UNORIENTED,0,
				    layers[i]->vert_tree_root->curr_vert, layers[i]->curr_tri, layers[i]->vert_tree_root->the_array,
				    layers[i]->part_tris, (fastf_t *)NULL, (struct bu_bitv *)NULL ) ) {
				bu_log( "Failed to make Bot\n" );
			} else {
				(void)mk_addmember( tmp_name, &head, NULL, WMOP_UNION );
			}
		}

		if( BU_PTBL_END( &layers[i]->solids ) > 0 ) {
			bu_log( "\t%d points\n", BU_PTBL_END( &layers[i]->solids ) );
		}

		for( j=0 ; j<BU_PTBL_END( &layers[i]->solids ) ; j++ ) {
			(void)mk_addmember((char *)BU_PTBL_GET( &layers[i]->solids, j ), &head,
					    NULL, WMOP_UNION );
			bu_free( (char *)BU_PTBL_GET( &layers[i]->solids, j), "solid_name" );
		}

		if( layers[i]->m ) {
			char name[32];

			sprintf( name, "nmg.%d", i );
			mk_nmg( out_fp, name, layers[i]->m );
			(void)mk_addmember( name, &head, NULL, WMOP_UNION );
		}

		if( layers[i]->line_count ) {
			bu_log( "\t%d lines\n", layers[i]->line_count );
		}

		if( layers[i]->point_count ) {
			bu_log( "\t%d points\n", layers[i]->point_count );
		}

		if( BU_LIST_NON_EMPTY( &head ) ) {
			unsigned char *tmp_rgb;
			struct bu_vls comb_name;

			if( layers[i]->color_number < 0 ) {
				tmp_rgb = &rgb[7];
			} else {
				tmp_rgb = &rgb[layers[i]->color_number*3];
			}
			bu_vls_init( &comb_name );
			bu_vls_printf( &comb_name, "%s.c.%d", layers[i]->name, i );
			if( mk_comb( out_fp, bu_vls_addr( &comb_name ), &head, 1, NULL, NULL,
				     tmp_rgb, 1, 0, 1, 100, 0, 0, 0 ) ) {
				bu_log( "Failed to make region %s\n", layers[i]->name );
			} else {
				(void)mk_addmember( bu_vls_addr( &comb_name ), &head_all, NULL, WMOP_UNION );
			}
		}

	}

	if( BU_LIST_NON_EMPTY( &head_all ) ) {
		struct bu_vls top_name;
		int count=0;

		bu_vls_strcpy( &top_name, "all" );
		while( db_lookup( out_fp->dbip, bu_vls_addr( &top_name ), LOOKUP_QUIET ) != DIR_NULL ) {
			count++;
			bu_vls_trunc( &top_name, 0 );
			bu_vls_printf( &top_name, "all.%d", count );
		}

		(void)mk_comb( out_fp, bu_vls_addr( &top_name ), &head_all, 0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 0, 0 );
d396 2
a397 1
	return( 0 );
@


11.11.2.1
log
@Initial ANSIfication
@
text
@d25 3
a27 1
main(int argc, char **argv)
@


11.11.2.2
log
@sync branch with HEAD
@
text
@d2 1
d6 1
a6 1
#  include <string.h>
d8 1
a8 1
#  include <strings.h>
d10 1
a12 1
#include "bu.h"
d14 2
a15 1
#include "bn.h"
d18 3
d22 1
a22 1
#include <ctype.h>
d24 19
a42 33
struct insert_data {
	fastf_t scale[3];
	fastf_t rotation;
	point_t insert_pt;
	vect_t extrude_dir;
};

struct state_data {
	struct bu_list l;
	struct block_list *curr_block;
	long file_offset;
	int state;
	int sub_state;
	mat_t xform;
};

static struct bu_list state_stack;
static struct state_data *curr_state;
static int curr_color=7;
static int ignore_colors=0;
static char *curr_layer_name;
static int color_by_layer=0;		/* flag, if set, colors are set by layer */

struct layer {
	char *name;			/* layer name */
	int color_number;		/* color */
	struct vert_root *vert_tree_root; /* root of vertex tree */
	int *part_tris;			/* list of triangles for current part */
	int max_tri;			/* number of triangles currently malloced */
	int curr_tri;			/* number of triangles currently being used */
	int line_count;
	int point_count;
	struct bu_ptbl solids;
d44 1
d46 1
a46 1
};
d48 10
a57 396
struct block_list {
	struct bu_list l;
	char *block_name;
	long offset;
	char handle[17];
	point_t base;
};

static struct bu_list block_head;
static struct block_list *curr_block=NULL;

static struct layer **layers=NULL;
static int max_layers;
static int next_layer;
static int curr_layer;

/* SECTIONS (states) */
#define UNKNOWN_SECTION		0
#define HEADER_SECTION		1
#define CLASSES_SECTION		2
#define TABLES_SECTION		3
#define BLOCKS_SECTION		4
#define ENTITIES_SECTION	5
#define OBJECTS_SECTION		6
#define THUMBNAILIMAGE_SECTION	7
#define NUM_SECTIONS		8

/* states for the ENTITIES section */
#define UNKNOWN_ENTITY_STATE		0
#define POLYLINE_ENTITY_STATE		1
#define POLYLINE_VERTEX_ENTITY_STATE	2
#define FACE3D_ENTITY_STATE		3
#define LINE_ENTITY_STATE		4
#define INSERT_ENTITY_STATE		5
#define POINT_ENTITY_STATE		6
#define CIRCLE_ENTITY_STATE		7
#define	ARC_ENTITY_STATE		8
#define DIMENSION_ENTITY_STATE		9
#define NUM_ENTITY_STATES		10

/* POLYLINE flags */
static int polyline_flag=0;
#define POLY_CLOSED		1
#define POLY_CURVE_FIT		2
#define POLY_SPLINE_FIT		4
#define	POLY_3D			8
#define	POLY_3D_MESH		16
#define	POLY_CLOSED_MESH	32
#define POLY_FACE_MESH		64
#define	POLY_PATTERN		128

/* POLYLINE VERTEX flags */
#define POLY_VERTEX_EXTRA	1
#define POLY_VERTEX_CURVE	2
#define POLY_VERTEX_SPLINE_V	8
#define POLY_VERTEX_SPLINE_C	16
#define POLY_VERTEX_3D_V	32
#define POLY_VERTEX_3D_M	64
#define POLY_VERTEX_FACE	128

/* states for the TABLES section */
#define UNKNOWN_TABLE_STATE	0
#define LAYER_TABLE_STATE	1
#define NUM_TABLE_STATES	2

static fastf_t *polyline_verts=NULL;
static int polyline_vertex_count=0;
static int polyline_vertex_max=0;
static int mesh_m_count=0;
static int mesh_n_count=0;
static int *polyline_vert_indices=NULL;
static int polyline_vert_indices_count=0;
static int polyline_vert_indices_max=0;
#define PVINDEX( _i, _j )	((_i)*mesh_n_count + (_j))
#define POLYLINE_VERTEX_BLOCK	10

static point_t pts[4];

#define UNKNOWN_ENTITY	0
#define POLYLINE_VERTEX		1

static int invisible=0;

#define ERROR_FLAG	-999
#define EOF_FLAG	-998

#define TOL_SQ	0.00001
#define LINELEN	2050
char line[LINELEN];

static char *usage="dxf-g [-d] [-v] [-t tolerance] [-s scale_factor] input_dxf_file output_file.g\n";

static FILE *dxf;
static struct rt_wdb *out_fp;
static char *output_file;
static char *dxf_file;
static int verbose=0;
static fastf_t tol=0.01;
static fastf_t tol_sq;
static char *base_name;
static char tmp_name[256];
static int segs_per_circle=32;
static fastf_t sin_delta, cos_delta;
static fastf_t delta_angle;
static point_t *circle_pts;
static fastf_t scale_factor;

#define TRI_BLOCK 512			/* number of triangles to malloc per call */

static int (*process_code[NUM_SECTIONS])( int code );
static int (*process_entities_code[NUM_ENTITY_STATES])( int code );
static int (*process_tables_sub_code[NUM_TABLE_STATES])( int code );

static int *int_ptr=NULL;
static int units=0;
static fastf_t units_conv[]={
	/* 0 */	1.0,
	/* 1 */	25.4,
	/* 2 */	304.8,
	/* 3 */	1609344.0,
	/* 4 */	1.0,
	/* 5 */	10.0,
	/* 6 */	1000.0,
	/* 7 */	1000000.0,
	/* 8 */	0.0000254,
	/* 9 */	0.0254,
	/* 10 */ 914.4,
	/* 11 */ 1.0e-7,
	/* 12 */ 1.0e-6,
	/* 13 */ 1.0e-3,
	/* 14 */ 100.0,
	/* 15 */ 10000.0,
	/* 16 */ 100000.0,
	/* 17 */ 1.0e+12,
	/* 18 */ 1.495979e+14,
	/* 19 */ 9.460730e+18,
	/* 20 */ 3.085678e+19
};

static unsigned char rgb[]={
	0, 0, 0,
	255, 0, 0,
	255, 255, 0,
	0, 255, 0,
	0, 255, 255,
	0, 0, 255,
	255, 0, 255,
	255, 255, 255,
	65, 65, 65,
	128, 128, 128,
	255, 0, 0,
	255, 128, 128,
	166, 0, 0,
	166, 83, 83,
	128, 0, 0,
	128, 64, 64,
	77, 0, 0,
	77, 38, 38,
	38, 0, 0,
	38, 19, 19,
	255, 64, 0,
	255, 159, 128,
	166, 41, 0,
	166, 104, 83,
	128, 32, 0,
	128, 80, 64,
	77, 19, 0,
	77, 48, 38,
	38, 10, 0,
	38, 24, 19,
	255, 128, 0,
	255, 191, 128,
	166, 83, 0,
	166, 124, 83,
	128, 64, 0,
	128, 96, 64,
	77, 38, 0,
	77, 57, 38,
	38, 19, 0,
	38, 29, 19,
	255, 191, 0,
	255, 223, 128,
	166, 124, 0,
	166, 145, 83,
	128, 96, 0,
	128, 112, 64,
	77, 57, 0,
	77, 67, 38,
	38, 29, 0,
	38, 33, 19,
	255, 255, 0,
	255, 255, 128,
	166, 166, 0,
	166, 166, 83,
	128, 128, 0,
	128, 128, 64,
	77, 77, 0,
	77, 77, 38,
	38, 38, 0,
	38, 38, 19,
	191, 255, 0,
	223, 255, 128,
	124, 166, 0,
	145, 166, 83,
	96, 128, 0,
	112, 128, 64,
	57, 77, 0,
	67, 77, 38,
	29, 38, 0,
	33, 38, 19,
	128, 255, 0,
	191, 255, 128,
	83, 166, 0,
	124, 166, 83,
	64, 128, 0,
	96, 128, 64,
	38, 77, 0,
	57, 77, 38,
	19, 38, 0,
	29, 38, 19,
	64, 255, 0,
	159, 255, 128,
	41, 166, 0,
	104, 166, 83,
	32, 128, 0,
	80, 128, 64,
	19, 77, 0,
	48, 77, 38,
	10, 38, 0,
	24, 38, 19,
	0, 255, 0,
	128, 255, 128,
	0, 166, 0,
	83, 166, 83,
	0, 128, 0,
	64, 128, 64,
	0, 77, 0,
	38, 77, 38,
	0, 38, 0,
	19, 38, 19,
	0, 255, 64,
	128, 255, 159,
	0, 166, 41,
	83, 166, 104,
	0, 128, 32,
	64, 128, 80,
	0, 77, 19,
	38, 77, 48,
	0, 38, 10,
	19, 38, 24,
	0, 255, 128,
	128, 255, 191,
	0, 166, 83,
	83, 166, 124,
	0, 128, 64,
	64, 128, 96,
	0, 77, 38,
	38, 77, 57,
	0, 38, 19,
	19, 38, 29,
	0, 255, 191,
	128, 255, 223,
	0, 166, 124,
	83, 166, 145,
	0, 128, 96,
	64, 128, 112,
	0, 77, 57,
	38, 77, 67,
	0, 38, 29,
	19, 38, 33,
	0, 255, 255,
	128, 255, 255,
	0, 166, 166,
	83, 166, 166,
	0, 128, 128,
	64, 128, 128,
	0, 77, 77,
	38, 77, 77,
	0, 38, 38,
	19, 38, 38,
	0, 191, 255,
	128, 223, 255,
	0, 124, 166,
	83, 145, 166,
	0, 96, 128,
	64, 112, 128,
	0, 57, 77,
	38, 67, 77,
	0, 29, 38,
	19, 33, 38,
	0, 128, 255,
	128, 191, 255,
	0, 83, 166,
	83, 124, 166,
	0, 64, 128,
	64, 96, 128,
	0, 38, 77,
	38, 57, 77,
	0, 19, 38,
	19, 29, 38,
	0, 64, 255,
	128, 159, 255,
	0, 41, 166,
	83, 104, 166,
	0, 32, 128,
	64, 80, 128,
	0, 19, 77,
	38, 48, 77,
	0, 10, 38,
	19, 24, 38,
	0, 0, 255,
	128, 128, 255,
	0, 0, 166,
	83, 83, 166,
	0, 0, 128,
	64, 64, 128,
	0, 0, 77,
	38, 38, 77,
	0, 0, 38,
	19, 19, 38,
	64, 0, 255,
	159, 128, 255,
	41, 0, 166,
	104, 83, 166,
	32, 0, 128,
	80, 64, 128,
	19, 0, 77,
	48, 38, 77,
	10, 0, 38,
	24, 19, 38,
	128, 0, 255,
	191, 128, 255,
	83, 0, 166,
	124, 83, 166,
	64, 0, 128,
	96, 64, 128,
	38, 0, 77,
	57, 38, 77,
	19, 0, 38,
	29, 19, 38,
	191, 0, 255,
	223, 128, 255,
	124, 0, 166,
	145, 83, 166,
	96, 0, 128,
	112, 64, 128,
	57, 0, 77,
	67, 38, 77,
	29, 0, 38,
	33, 19, 38,
	255, 0, 255,
	255, 128, 255,
	166, 0, 166,
	166, 83, 166,
	128, 0, 128,
	128, 64, 128,
	77, 0, 77,
	77, 38, 77,
	38, 0, 38,
	38, 19, 38,
	255, 0, 191,
	255, 128, 223,
	166, 0, 124,
	166, 83, 145,
	128, 0, 96,
	128, 64, 112,
	77, 0, 57,
	77, 38, 67,
	38, 0, 29,
	38, 19, 33,
	255, 0, 128,
	255, 128, 191,
	166, 0, 83,
	166, 83, 124,
	128, 0, 64,
	128, 64, 96,
	77, 0, 38,
	77, 38, 57,
	38, 0, 19,
	38, 19, 29,
	255, 0, 64,
	255, 128, 159,
	166, 0, 41,
	166, 83, 104,
	128, 0, 32,
	128, 64, 80,
	77, 0, 19,
	77, 38, 48,
	38, 0, 10,
	38, 19, 24,
	84, 84, 84,
	118, 118, 118,
	152, 152, 152,
	187, 187, 187,
	221, 221, 221,
	255, 255, 255 };
d59 27
a85 32

static char *
make_brlcad_name( char *line )
{
	char *name;
	char *c;

	name = bu_strdup( line );

	c = name;
	while( *c != '\0' ) {
		if( *c == '/' || *c == '[' || *c == ']' || *c == '*' || isspace( *c ) ) {
			*c = '_';
		}
		c++;
	}

	return( name );
}

static void
get_layer()
{
	int i;
	int old_layer=curr_layer;

	/* do we already have a layer by this name and color */
	curr_layer = -1;
	for( i = 1 ; i < next_layer ; i++ ) {
		if( !color_by_layer && !ignore_colors ) {
			if( layers[i]->color_number == curr_color && !strcmp( curr_layer_name, layers[i]->name ) ) {
				curr_layer = i;
d87 2
a88 4
			}
		} else {
			if( !strcmp( curr_layer_name, layers[i]->name ) ) {
				curr_layer = i;
a89 1
			}
d93 6
a98 24
	if( curr_layer == -1 ) {
		/* add a new layer */
		if( next_layer >= max_layers ) {
			if( verbose ) {
				bu_log( "Creating new block of layers\n" );
			}
			max_layers += 5;
			layers = (struct layer **)bu_realloc( layers,
					    max_layers*sizeof( struct layer *), "layers" );
			for( i=0 ; i<5 ; i++ ) {
				BU_GETSTRUCT( layers[max_layers-i-1], layer );
			}
		}
		curr_layer = next_layer++;
		if( verbose ) {
			bu_log( "New layer: %s, color number: %d", line, curr_color );
		}
		layers[curr_layer]->name = bu_strdup( curr_layer_name );
		layers[curr_layer]->vert_tree_root = create_vert_tree();
		layers[curr_layer]->color_number = curr_color;
		bu_ptbl_init( &layers[curr_layer]->solids, 8, "layers[curr_layer]->solids" );
		if( verbose ) {
			bu_log( "\tNew layer name: %s\n", layers[curr_layer]->name );
		}
d101 13
a113 4
	if( verbose && curr_layer != old_layer ) {
		bu_log( "changed to layer #%d, (m = x%x, s=x%x)\n", curr_layer, layers[curr_layer]->m, layers[curr_layer]->s );
	}
}
d115 2
a116 5
static void
create_nmg()
{
	struct model *m;
	struct nmgregion *r;
d118 1
a118 29
	m = nmg_mm();
	r = nmg_mrsv( m );
	layers[curr_layer]->s = BU_LIST_FIRST( shell, &r->s_hd );
	layers[curr_layer]->m = m;
}

/* routine to add a new triangle to the current part */
void
add_triangle( int v1, int v2, int v3, int layer )
{
	if( verbose ) {
		bu_log( "Adding triangle %d %d %d, to layer %s\n", v1, v2, v3, layers[layer]->name );
	}
	if( v1 == v2 || v2 == v3 || v3 == v1 ) {
		if( verbose ) {
			bu_log( "\tSkipping degenerate triangle\n" );
		}
		return;
	}
	if( layers[layer]->curr_tri >= layers[layer]->max_tri ) {
		/* allocate more memory for triangles */
		layers[layer]->max_tri += TRI_BLOCK;
		layers[layer]->part_tris = (int *)realloc( layers[layer]->part_tris,
							  sizeof( int ) * layers[layer]->max_tri * 3 );
		if( !layers[layer]->part_tris ) {
			bu_log( "ERROR: Failed to allocate memory for part triangles on layer %s\n",
				 layers[layer]->name);
			exit( 1 );
		}
d120 3
d124 38
a161 30
	/* fill in triangle info */
	layers[layer]->part_tris[layers[layer]->curr_tri*3 + 0] = v1;
	layers[layer]->part_tris[layers[layer]->curr_tri*3 + 1] = v2;
	layers[layer]->part_tris[layers[layer]->curr_tri*3 + 2] = v3;

	/* increment count */
	layers[layer]->curr_tri++;
}

static int
process_unknown_code( int code )
{
	switch( code ) {
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 0:		/* text string */
		if( !strncmp( line, "SECTION", 7 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		} else if( !strncmp( line, "ENDSEC", 6 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		}
		break;
	case 2:		/* name */
		if( !strncmp( line, "HEADER", 6 ) ) {
			curr_state->state = HEADER_SECTION;
			if( verbose ) {
				bu_log( "Change state to %d\n", curr_state->state );
a162 39
			break;
		} else if( !strncmp( line, "CLASSES", 7 ) ) {
			curr_state->state = CLASSES_SECTION;
			if( verbose ) {
				bu_log( "Change state to %d\n", curr_state->state );
			}
			break;
		} else if( !strncmp( line, "TABLES", 6 ) ) {
			curr_state->state = TABLES_SECTION;
			curr_state->sub_state = UNKNOWN_TABLE_STATE;
			if( verbose ) {
				bu_log( "Change state to %d\n", curr_state->state );
			}
			break;
		} else if( !strncmp( line, "BLOCKS", 6 ) ) {
			curr_state->state = BLOCKS_SECTION;
			if( verbose ) {
				bu_log( "Change state to %d\n", curr_state->state );
			}
			break;
		} else if( !strncmp( line, "ENTITIES", 8 ) ) {
			curr_state->state = ENTITIES_SECTION;
			curr_state->sub_state =UNKNOWN_ENTITY_STATE; 
			if( verbose ) {
				bu_log( "Change state to %d\n", curr_state->state );
			}
			break;
		} else if( !strncmp( line, "OBJECTS", 7 ) ) {
			curr_state->state = OBJECTS_SECTION;
			if( verbose ) {
				bu_log( "Change state to %d\n", curr_state->state );
			}
			break;
		} else if( !strncmp( line, "THUMBNAILIMAGE", 14 ) ) {
			curr_state->state = THUMBNAILIMAGE_SECTION;
			if( verbose ) {
				bu_log( "Change state to %d\n", curr_state->state );
			}
			break;
a163 38
		break;
	case 62:	/* color number */
		curr_color = atoi( line );
		break;
		}
	return( 0 );
}

static int
process_header_code( int code )
{
	switch( code ) {
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 0:		/* text string */
		if( !strncmp( line, "SECTION", 7 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		} else if( !strncmp( line, "ENDSEC", 6 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		}
		break;
	case 9:		/* variable name */
		if( !strncmp( line, "$INSUNITS", 9 ) ) {
			int_ptr = &units;
		} else if( !strcmp( line, "$CECOLOR" ) ) {
			int_ptr = &color_by_layer;
		}
		break;
	case 70:
	case 62:
		if( int_ptr ) {
			(*int_ptr) = atoi( line );
		}
		int_ptr = NULL;
		break;
a164 3
		
	return( 0 );
}
d166 4
a169 20
static int
process_classes_code( int code )
{
	switch( code ) {
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 0:		/* text string */
		if( !strncmp( line, "SECTION", 7 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		} else if( !strncmp( line, "ENDSEC", 6 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		}
		break;
	}
		
	return( 0 );
}
d171 2
a172 3
static int
process_tables_unknown_code( int code )
{
d174 18
a191 17
	switch( code ) {
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 0:		/* text string */
		if( !strcmp( line, "LAYER" ) ) {
			if( curr_layer_name ) {
				bu_free( curr_layer_name, "cur_layer_name" );
				curr_layer_name = NULL;
			}
			curr_color = 0;
			curr_state->sub_state = LAYER_TABLE_STATE;
			break;
		} else if( !strcmp( line, "ENDTAB" ) ) {
			if( curr_layer_name ) {
				bu_free( curr_layer_name, "cur_layer_name" );
				curr_layer_name = NULL;
d193 10
a202 36
			curr_color = 0;
			curr_state->sub_state = UNKNOWN_TABLE_STATE;
			break;
		} else if( !strncmp( line, "SECTION", 7 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		} else if( !strncmp( line, "ENDSEC", 6 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		}
		break;
	}
		
	return( 0 );
}

static int
process_tables_layer_code( int code )
{
	switch( code ) {
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 2:		/* layer name */
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "curr_layer_name" );
		}
		curr_layer_name = make_brlcad_name( line );
		break;
	case 62:	/* layer color */
		curr_color = atoi( line );
		break;
	case 0:		/* text string */
		if( color_by_layer ) {
			if( curr_layer_name && curr_color ) {
				get_layer();
d206 1
a206 34
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "cur_layer_name" );
			curr_layer_name = NULL;
		}
		curr_color = 0;
		curr_state->sub_state = UNKNOWN_TABLE_STATE;
		return( process_tables_unknown_code( code ) );
	}
		
	return( 0 );
}

static int
process_tables_code( int code )
{
	return( process_tables_sub_code[curr_state->sub_state]( code ) );
}

static int
process_blocks_code( int code )
{
	int len;
	int coord;

	switch( code ) {
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 0:		/* text string */
		if( !strncmp( line, "SECTION", 7 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		} else if( !strncmp( line, "ENDSEC", 6 ) ) {
			curr_state->state = UNKNOWN_SECTION;
a207 43
		} else if( !strcmp( line, "ENDBLK" ) ) {
			curr_block = NULL;
			break;
		} else if( !strncmp( line, "BLOCK", 5 ) ) {
			/* start of a new block */
			BU_GETSTRUCT( curr_block, block_list );
			curr_block->offset = ftell( dxf );
			BU_LIST_INSERT( &(block_head), &(curr_block->l) );
			break;
		}
		break;
	case 2:		/* block name */
		if( curr_block ) {
			curr_block->block_name = bu_strdup( line );
			if( verbose ) {
				bu_log( "BLOCK %s begins at %ld\n",
					curr_block->block_name,
					curr_block->offset );
			}
		}
		break;
	case 5:		/* block handle */
		if( curr_block ) {
			len = strlen( line );
			if( len > 16 ) {
				len = 16;
			}
			strncpy( curr_block->handle, line, len );
			curr_block->handle[len] = '\0';
		}
		break;
	case 10:
	case 20:
	case 30:
		if( curr_block ) {
			coord = code / 10 - 1;
			curr_block->base[coord] = atof( line ) * units_conv[units] * scale_factor;
		}
		break;
	}
		
	return( 0 );
}
d209 8
a216 35
void
add_polyface_mesh_triangle( int v1, int v2, int v3 )
{
}

void
add_polyline_vertex( fastf_t x, fastf_t y, fastf_t z )
{
	if( !polyline_verts ) {
		polyline_verts = (fastf_t *)bu_malloc( POLYLINE_VERTEX_BLOCK*3*sizeof( fastf_t ), "polyline_verts" );
		polyline_vertex_count = 0;
		polyline_vertex_max = POLYLINE_VERTEX_BLOCK;
	} else if( polyline_vertex_count >= polyline_vertex_max ) {
		polyline_vertex_max += POLYLINE_VERTEX_BLOCK;
		polyline_verts = (fastf_t *)bu_realloc( polyline_verts, polyline_vertex_max * 3 * sizeof( fastf_t ), "polyline_verts" );
	}

	VSET( &polyline_verts[polyline_vertex_count*3], x, y, z );
	polyline_vertex_count++;

	if( verbose ) {
		bu_log( "Added polyline vertex (%g %g %g) #%d\n", x, y, z, polyline_vertex_count );
	}
}

static int
process_point_entities_code( int code )
{
	static point_t pt;
	int coord;

	switch( code ) {
	case 8:		/* layer name */
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "curr_layer_name" );
d218 6
a223 37
		curr_layer_name = make_brlcad_name( line );
		break;
	case 10:
	case 20:
	case 30:
		coord = code / 10 - 1;
		pt[coord] = atof( line ) * units_conv[units] * scale_factor;
		break;
	case 62:	/* color number */
		curr_color = atoi( line );
		break;
	case 0:
		get_layer();
		layers[curr_layer]->point_count++;
		sprintf( tmp_name, "point.%d", layers[curr_layer]->point_count );
		(void)mk_sph( out_fp, tmp_name, pt, 0.1 );
		(void)bu_ptbl_ins( &(layers[curr_layer]->solids), (long *)bu_strdup( tmp_name ) );
		curr_state->sub_state = UNKNOWN_ENTITY_STATE;
		process_entities_code[curr_state->sub_state]( code );
		break;
	}

	return( 0 );
}

static int
process_entities_polyline_vertex_code( int code )
{
	static fastf_t x, y, z;
	static int face[4];
	static int vertex_flag=0;
	int coord;

	switch( code ) {
	case 8:		/* layer name */
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "curr_layer_name" );
a224 67
		curr_layer_name = make_brlcad_name( line );
		break;
	case 70:	/* vertex flag */
		vertex_flag = atoi( line );
		break;
	case 71:
	case 72:
	case 73:
	case 74:
		coord = (code % 70) - 1;
		face[coord] = abs( atoi( line ) );
		break;
	case 0:
		get_layer();
		if( vertex_flag == POLY_VERTEX_FACE ) {
			add_triangle( polyline_vert_indices[face[0]-1],
				      polyline_vert_indices[face[1]-1],
				      polyline_vert_indices[face[2]-1],
				      curr_layer );
			if( face[3] > 0 ) {
			add_triangle( polyline_vert_indices[face[2]-1],
				      polyline_vert_indices[face[3]-1],
				      polyline_vert_indices[face[0]-1],
				      curr_layer );
			}
		} else if( vertex_flag & POLY_VERTEX_3D_M) {
			if( polyline_vert_indices_count >= polyline_vert_indices_max ) {
				polyline_vert_indices_max += POLYLINE_VERTEX_BLOCK;
				polyline_vert_indices = (int *)bu_realloc( polyline_vert_indices,
									   polyline_vert_indices_max * sizeof( int ),
									   "polyline_vert_indices" );
			}
			polyline_vert_indices[polyline_vert_indices_count++] = Add_vert( x, y, z,
									     layers[curr_layer]->vert_tree_root,
									     tol_sq );
			if( verbose) {
				bu_log( "Added 3D mesh vertex (%g %g %g) index = %d, number = %d\n",
					x, y, z, polyline_vert_indices[polyline_vert_indices_count-1],
					polyline_vert_indices_count-1 );
			}
		} else {
			add_polyline_vertex( x, y, z );
		}
		curr_state->sub_state = POLYLINE_ENTITY_STATE;
		if( verbose ) {
			bu_log( "sub_state changed to %d\n", curr_state->sub_state );
		}
		return( process_entities_code[curr_state->sub_state]( code ) );
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 10:
		x = atof( line ) * units_conv[units] * scale_factor;
		break;
	case 20:
		y = atof( line ) * units_conv[units] * scale_factor;
		break;
	case 30:
		z = atof( line ) * units_conv[units] * scale_factor;
		break;
	case 62:	/* color number */
		curr_color = atoi( line );
		break;
	}
		
	return( 0 );
}
d226 5
a230 3
static int
process_entities_polyline_code( int code )
{
d232 13
a244 23
	switch( code ) {
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 0:		/* text string */
		get_layer();
		if( !strncmp( line, "SEQEND", 6 ) ) {
			/* build any polyline meshes here */
			if( polyline_flag & POLY_3D_MESH ) {
				if( polyline_vert_indices_count == 0 ) {
					return( 0 );
				} else if( polyline_vert_indices_count != mesh_m_count * mesh_n_count ) {
					bu_log( "Incorrect number of vertices for polygon mesh!!!\n" );
					polyline_vert_indices_count = 0;
				} else {
					int i, j;

					if( polyline_vert_indices_count >= polyline_vert_indices_max ) {
						polyline_vert_indices_max = ((polyline_vert_indices_count % POLYLINE_VERTEX_BLOCK) + 1) *
							POLYLINE_VERTEX_BLOCK;
						polyline_vert_indices = (int *)bu_realloc( polyline_vert_indices,
											   polyline_vert_indices_max * sizeof( int ),
											   "polyline_vert_indices" );
d246 43
a288 7

					if( mesh_m_count < 2 ) {
						if( mesh_n_count > 4 ) {
							bu_log( "Cannot handle polyline meshes with m<2 and n>4\n");
							polyline_vert_indices_count=0;
							polyline_vert_indices_count = 0;
							break;
d290 6
a295 3
						if( mesh_n_count < 3 ) {
							polyline_vert_indices_count=0;
							polyline_vert_indices_count = 0;
a297 10
						add_triangle( polyline_vert_indices[0],
							      polyline_vert_indices[1],
							      polyline_vert_indices[2],
							      curr_layer );
						if( mesh_n_count == 4 ) {
							add_triangle( polyline_vert_indices[2],
								      polyline_vert_indices[3],
								      polyline_vert_indices[0],
								      curr_layer );
						}
d300 6
a305 11
					for( j=1 ; j<mesh_n_count ; j++ ) {
						for( i=1 ; i<mesh_m_count ; i++ ) {
							add_triangle( polyline_vert_indices[PVINDEX(i-1,j-1)],
								      polyline_vert_indices[PVINDEX(i-1,j)],
								      polyline_vert_indices[PVINDEX(i,j-1)],
								      curr_layer );
							add_triangle( polyline_vert_indices[PVINDEX(i-1,j-1)],
								      polyline_vert_indices[PVINDEX(i,j-1)],
								      polyline_vert_indices[PVINDEX(i,j)],
								      curr_layer );
						}
d307 5
a311 11
					polyline_vert_indices_count=0;
					polyline_vertex_count = 0;
				}
			} else {
				int i;
				struct edgeuse *eu;
				struct vertex *v0=NULL, *v1=NULL, *v2=NULL;

				if( polyline_vertex_count > 1 ) {
					if( !layers[curr_layer]->m ) {
						create_nmg();
d314 12
a325 6
					for( i=0 ; i<polyline_vertex_count-1 ; i++ ) {
						eu = nmg_me( v1, v2, layers[curr_layer]->s );
						if( i == 0 ) {
							v1 = eu->vu_p->v_p;
							nmg_vertex_gv( v1, polyline_verts );
							v0 = v1;
d327 13
a339 6
						v2 = eu->eumate_p->vu_p->v_p;
						nmg_vertex_gv( v2, &polyline_verts[(i+1)*3] );
						if( verbose ) {
							bu_log( "Wire edge (polyline): (%g %g %g) <-> (%g %g %g)\n",
								V3ARGS( v1->vg_p->coord ),
								V3ARGS( v2->vg_p->coord ) );
a340 2
						v1 = v2;
						v2 = NULL;
d342 9
a350 8

					if( polyline_flag & POLY_CLOSED ) {
						v2 = v0;
						(void)nmg_me( v1, v2, layers[curr_layer]->s );
						if( verbose ) {
							bu_log( "Wire edge (closing polyline): (%g %g %g) <-> (%g %g %g)\n",
								V3ARGS( v1->vg_p->coord ),
								V3ARGS( v2->vg_p->coord ) );
d352 1
d354 5
a358 368
				}
				polyline_vert_indices_count=0;	
				polyline_vertex_count = 0;
			}

			curr_state->state = ENTITIES_SECTION;
			curr_state->sub_state = UNKNOWN_ENTITY_STATE;
			if( verbose ) {
				bu_log( "sub_state changed to %d\n", curr_state->sub_state );
			}
			break;
		} else if( !strncmp( line, "VERTEX", 6 ) ) {
			if( verbose)
				bu_log( "Found a POLYLINE VERTEX\n" );
			curr_state->sub_state = POLYLINE_VERTEX_ENTITY_STATE;
			break;
		} else {
			if( verbose ) {
				bu_log( "Unrecognized text string while in polyline entity: %s\n", line );
			}
			break;
		}
	case 70:	/* polyline flag */
		polyline_flag = atoi( line );
		break;
	case 71:
		mesh_m_count = atoi( line );
		break;
	case 72:
		mesh_n_count = atoi( line );
		break;
	case 62:	/* color number */
		curr_color = atoi( line );
		break;
	case 60:
		invisible = atoi( line );
		break;
	case 8:		/* layer name */
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "curr_layer_name" );
		}
		curr_layer_name = make_brlcad_name( line );
		break;
	}
		
	return( 0 );
}

static int
process_entities_unknown_code( int code )
{
	struct state_data *tmp_state;

	invisible = 0;

	switch( code ) {
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 0:		/* text string */
		if( !strncmp( line, "SECTION", 7 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		} else if( !strncmp( line, "ENDSEC", 6 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		} else if( !strncmp( line, "POLYLINE", 8 ) ) {
			if( verbose)
				bu_log( "Found a POLYLINE\n" );
			curr_state->sub_state = POLYLINE_ENTITY_STATE;
			if( verbose ) {
				bu_log( "sub_state changed to %d\n", curr_state->sub_state );
			}
			break;
		} else if( !strncmp( line, "3DFACE", 6 ) ) {
			curr_state->sub_state = FACE3D_ENTITY_STATE;
			if( verbose ) {
				bu_log( "sub_state changed to %d\n", curr_state->sub_state );
			}
			break;
		} else if( !strcmp( line, "CIRCLE" ) ) {
			curr_state->sub_state = CIRCLE_ENTITY_STATE;
			if( verbose ) {
				bu_log( "sub_state changed to %d\n", curr_state->sub_state );
			}
			break;
		} else if( !strcmp( line, "ARC" ) ) {
			curr_state->sub_state = ARC_ENTITY_STATE;
			if( verbose ) {
				bu_log( "sub_state changed to %d\n", curr_state->sub_state );
			}
			break;
		} else if( !strcmp( line, "DIMENSION" ) ) {
			curr_state->sub_state = DIMENSION_ENTITY_STATE;
			if( verbose ) {
				bu_log( "sub_state changed to %d\n", curr_state->sub_state );
			}
			break;
		} else if( !strncmp( line, "LINE", 4 ) ) {
			curr_state->sub_state = LINE_ENTITY_STATE;
			if( verbose ) {
				bu_log( "sub_state changed to %d\n", curr_state->sub_state );
			}
			break;
		} else if( !strcmp( line, "POINT" ) ) {
			curr_state->sub_state = POINT_ENTITY_STATE;
			if( verbose ) {
				bu_log( "sub_state changed to %d\n", curr_state->sub_state );
			}
			break;
		} else if( !strncmp( line, "INSERT", 6 ) ) {
			curr_state->sub_state = INSERT_ENTITY_STATE;
			if( verbose ) {
				bu_log( "sub_state changed to %d\n", curr_state->sub_state );
			}
			break;
		} else if( !strcmp( line, "ENDBLK" ) ) {
			/* found end of an inserted block, pop the state stack */
			tmp_state = curr_state;
			BU_LIST_POP( state_data, &state_stack, curr_state );
			if( !curr_state ) {
				bu_log( "ERROR: end of block encountered while not inserting!!!\n" );
				curr_state = tmp_state;
				break;
			}
			bu_free( (char *)tmp_state, "curr_state" );
			fseek( dxf, curr_state->file_offset, SEEK_SET );
			curr_state->sub_state = UNKNOWN_ENTITY_STATE;
			if( verbose ) {
				bu_log( "Popped state at end of inserted block (seeked to %ld)\n", curr_state->file_offset );
			}
			break;
		} else {
			if( verbose ) {
				bu_log( "Unrecognized text string while in unknown entities state: %s\n",
					line );
			}
			break;
		}
	}
		
	return( 0 );
}

static void
insert_init( struct insert_data *ins )
{
	VSETALL( ins->scale, 1.0 );
	ins->rotation = 0.0;
	VSETALL( ins->insert_pt, 0.0 );
	VSET( ins->extrude_dir, 0, 0, 1 );
}

static int
process_insert_entities_code( int code )
{
	static struct insert_data ins;
	static struct state_data *new_state=NULL;
	struct block_list *blk;
	int coord;

	if( !new_state ) {
		insert_init( &ins );
		BU_GETSTRUCT( new_state, state_data );
		*new_state = *curr_state;
		if( verbose ) {
			bu_log( "Created a new state for INSERT\n" );
		}
	}

	switch( code ) {
	case 8:		/* layer name */
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "curr_layer_name" );
		}
		curr_layer_name = make_brlcad_name( line );
		break;
	case 2:		/* block name */
		for( BU_LIST_FOR( blk, block_list, &block_head ) ) {
			if( !strcmp( blk->block_name, line ) ) {
				break;
			}
		}
		if( BU_LIST_IS_HEAD( blk, &block_head ) ) {
			bu_log( "ERROR: INSERT references non-existent block (%s)\n", line );
			bu_log( "\tignoring missing block\n" );
			blk = NULL;
		}
		new_state->curr_block = blk;
		if( verbose && blk ) {
			bu_log( "Inserting block %s\n", blk->block_name );
		}
		break;
	case 10:
	case 20:
	case 30:
		coord = (code / 10) - 1;
		ins.insert_pt[coord] = atof( line );
		break;
	case 41:
	case 42:
	case 43:
		coord = (code % 40) - 1;
		ins.scale[coord] = atof( line );
		break;
	case 50:
		ins.rotation = atof( line );
		break;
	case 62:	/* color number */
		curr_color = atoi( line );
		break;
	case 70:
	case 71:
		if( atof( line ) != 1 ) {
			bu_log( "Cannot yet handle insertion of a pattern\n\tignoring\n" );
		}
		break;
	case 44:
	case 45:
		break;
	case 210:
	case 220:
	case 230:
		coord = ((code / 10) % 20) - 1;
		ins.extrude_dir[coord] = atof( line );
		break;
	case 0:		/* end of this insert */
		if( new_state->curr_block ) {
			BU_LIST_PUSH( &state_stack, &(curr_state->l) );
			curr_state = new_state;
			new_state = NULL;
			fseek( dxf, curr_state->curr_block->offset, SEEK_SET );
			curr_state->state = ENTITIES_SECTION;
			curr_state->sub_state = UNKNOWN_ENTITY_STATE;
			if( verbose ) {
				bu_log( "Changing state for INSERT\n" );
				bu_log( "seeked to %ld\n", curr_state->curr_block->offset );
			}
		}
		break;
	}

	return( 0 );
}

static int
process_line_entities_code( int code )
{
	int vert_no;
	int coord;
	static point_t line_pt[2];
	struct edgeuse *eu;

	switch( code ) {
	case 8:
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "curr_layer_name" );
		}
		curr_layer_name = make_brlcad_name( line );
		break;
	case 10:
	case 20:
	case 30:
	case 11:
	case 21:
	case 31:
		vert_no = code % 10;
		coord = code / 10 - 1;
		line_pt[vert_no][coord] = atof( line ) * units_conv[units] * scale_factor;
		if( verbose ) {
			bu_log( "LINE vertex #%d coord #%d = %g\n", vert_no, coord, line_pt[vert_no][coord] );
		}
		break;
	case 62:	/* color number */
		curr_color = atoi( line );
		break;
	case 0:
		/* end of this line */
		get_layer();
		if( verbose ) {
			bu_log( "Found end of LINE\n" );
		}

		layers[curr_layer]->line_count++;

		if( !layers[curr_layer]->m ) {
			create_nmg();
		}

		/* create a wire edge in the NMG */
		eu = nmg_me( NULL, NULL, layers[curr_layer]->s );
		nmg_vertex_gv( eu->vu_p->v_p, line_pt[0] );
		nmg_vertex_gv( eu->eumate_p->vu_p->v_p, line_pt[1] );
		if( verbose ) {
			bu_log( "Wire edge (line): (%g %g %g) <-> (%g %g %g)\n",
				V3ARGS(eu->vu_p->v_p->vg_p->coord ),
				V3ARGS(eu->eumate_p->vu_p->v_p->vg_p->coord ) );
		}

		curr_state->sub_state = UNKNOWN_ENTITY_STATE;
		process_entities_code[curr_state->sub_state]( code );
		break;
	}
	
	return( 0 );
}

static int
process_circle_entities_code( int code )
{
	static point_t center;
	static fastf_t radius;
	int coord, i;
	struct vertex *v0=NULL, *v1=NULL, *v2=NULL;
	struct edgeuse *eu;

	switch( code ) {
	case 8:		/* layer name */
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "curr_layer_name" );
		}
		curr_layer_name = make_brlcad_name( line );
		break;
	case 10:
	case 20:
	case 30:
		coord = code / 10 - 1;
		center[coord] = atof( line ) * units_conv[units] * scale_factor;
		if( verbose ) {
			bu_log( "CIRCLE center coord #%d = %g\n", coord, center[coord] );
		}
		break;
	case 40:
		radius = atof( line ) * units_conv[units] * scale_factor;
		break;
	case 62:	/* color number */
		curr_color = atoi( line );
		break;
	case 0:
		/* end of this circle entity
		 * make a series of wire edges in the NMG to approximate a circle
		 */

		get_layer();
		if( verbose ) {
			bu_log( "Found a circle\n" );
		}

		if( !layers[curr_layer]->m ) {
			create_nmg();
		}

		/* calculate circle at origin first */
		VSET( circle_pts[0], radius, 0.0, 0.0 );
		for( i=1 ; i<segs_per_circle ; i++ ) {
			circle_pts[i][X] = circle_pts[i-1][X]*cos_delta - circle_pts[i-1][Y]*sin_delta;
			circle_pts[i][Y] = circle_pts[i-1][Y]*cos_delta + circle_pts[i-1][X]*sin_delta;
		}

		/* move everything to the specified center */
		for( i=0 ; i<segs_per_circle ; i++ ) {
			VADD2( circle_pts[i], circle_pts[i], center );
		}

		/* make nmg wire edges */
		for( i=0 ; i<segs_per_circle ; i++ ) {
			if( i+1 == segs_per_circle ) {
				v2 = v0;
a359 272
			eu = nmg_me( v1, v2, layers[curr_layer]->s );
			if( i == 0 ) {
				v1 = eu->vu_p->v_p;
				v0 = v1;
				nmg_vertex_gv( v1, circle_pts[0] );
			}
			v2 = eu->eumate_p->vu_p->v_p;
			if( i+1 < segs_per_circle ) {
				nmg_vertex_gv( v2, circle_pts[i+1] );
			}
			if( verbose ) {
				bu_log( "Wire edge (circle): (%g %g %g) <-> (%g %g %g)\n",
					V3ARGS( v1->vg_p->coord ),
					V3ARGS( v2->vg_p->coord ) );
			}
			v1 = v2;
			v2 = NULL;
		}

		curr_state->sub_state = UNKNOWN_ENTITY_STATE;
		process_entities_code[curr_state->sub_state]( code );
		break;
	}

	return( 0 );
}

static int
process_dimension_entities_code( int code )
{
	static point_t def_pt={0.0, 0.0, 0.0};
	static char *block_name=NULL;
	static struct state_data *new_state=NULL;
	struct block_list *blk;
	int coord;

	switch( code ) {
	case 10:
	case 20:
	case 30:
		coord = (code / 10) - 1;
		def_pt[coord] = atof( line ) * units_conv[units] * scale_factor;
		break;
	case 8:		/* layer name */
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "curr_layer_name" );
		}
		curr_layer_name = make_brlcad_name( line );
		break;
	case 2:	/* block name */
		block_name = bu_strdup( line );
		break;
	case 0:
		/* insert this dimension */
		get_layer();
		BU_GETSTRUCT( new_state, state_data );
		*new_state = *curr_state;
		if( verbose ) {
			bu_log( "Created a new state for DIMENSION\n" );
		}
		for( BU_LIST_FOR( blk, block_list, &block_head ) ) {
			if( !strcmp( blk->block_name, block_name ) ) {
				break;
			}
		}
		if( BU_LIST_IS_HEAD( blk, &block_head ) ) {
			bu_log( "ERROR: INSERT references non-existent block (%s)\n", line );
			bu_log( "\tignoring missing block\n" );
			blk = NULL;
		}
		new_state->curr_block = blk;
		if( verbose && blk ) {
			bu_log( "Inserting block %s\n", blk->block_name );
		}

		bu_free( block_name, "block_name" );
		
		if( new_state->curr_block ) {
			BU_LIST_PUSH( &state_stack, &(curr_state->l) );
			curr_state = new_state;
			new_state = NULL;
			fseek( dxf, curr_state->curr_block->offset, SEEK_SET );
			curr_state->state = ENTITIES_SECTION;
			curr_state->sub_state = UNKNOWN_ENTITY_STATE;
			if( verbose ) {
				bu_log( "Changing state for INSERT\n" );
				bu_log( "seeked to %ld\n", curr_state->curr_block->offset );
			}
		}

		break;
	}

	return( 0 );
}

static int
process_arc_entities_code( int code )
{
	static point_t center={0,0,0};
	static fastf_t radius;
	static fastf_t start_angle, end_angle;
	int num_segs;
	int coord, i;
	struct vertex *v0=NULL, *v1=NULL, *v2=NULL;
	struct edgeuse *eu;

	switch( code ) {
	case 8:		/* layer name */
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "curr_layer_name" );
		}
		curr_layer_name = make_brlcad_name( line );
		break;
	case 10:
	case 20:
	case 30:
		coord = code / 10 - 1;
		center[coord] = atof( line ) * units_conv[units] * scale_factor;
		if( verbose ) {
			bu_log( "ARC center coord #%d = %g\n", coord, center[coord] );
		}
		break;
	case 40:
		radius = atof( line ) * units_conv[units] * scale_factor;
		if( verbose) {
			bu_log( "ARC radius = %g\n", radius );
		}
		break;
	case 50:
		start_angle = atof( line );
		if( verbose ) {
			bu_log( "ARC start angle = %g\n", start_angle );
		}
		break;
	case 51:
		end_angle = atof( line );
		if( verbose ) {
			bu_log( "ARC end angle = %g\n", end_angle );
		}
		break;
	case 62:	/* color number */
		curr_color = atoi( line );
		break;
	case 0:
		/* end of this arc entity
		 * make a series of wire edges in the NMG to approximate an arc
		 */

		get_layer();
		if( verbose ) {
			bu_log( "Found an arc\n" );
		}

		if( !layers[curr_layer]->m ) {
			create_nmg();
		}

		while( end_angle < start_angle ) {
			end_angle += 360.0;
		}

		/* calculate arc at origin first */
		num_segs = (end_angle - start_angle) / 360.0 * segs_per_circle;
		start_angle *= M_PI / 180.0;
		end_angle *= M_PI / 180.0;
		if( verbose ) {
			bu_log( "arc has %d segs\n", num_segs );
		}

		if( num_segs < 1 ) {
			num_segs = 1;
		}
		VSET( circle_pts[0], radius * cos( start_angle ), radius * sin( start_angle ), 0.0 );
		for( i=1 ; i<num_segs ; i++ ) {
			circle_pts[i][X] = circle_pts[i-1][X]*cos_delta - circle_pts[i-1][Y]*sin_delta;
			circle_pts[i][Y] = circle_pts[i-1][Y]*cos_delta + circle_pts[i-1][X]*sin_delta;
		}
		circle_pts[num_segs][X] = radius * cos( end_angle );
		circle_pts[num_segs][Y] = radius * sin( end_angle );
		num_segs++;

		if( verbose ) {
			bu_log( "ARC points calculated:\n" );
			for( i=0 ; i<num_segs ; i++ ) {
				bu_log( "\t point #%d: (%g %g %g)\n", i, V3ARGS( circle_pts[i] ) );
			}
		}

		/* move everything to the specified center */
		for( i=0 ; i<num_segs ; i++ ) {
			VADD2( circle_pts[i], circle_pts[i], center );
		}

		if( verbose ) {
			bu_log( "ARC points after move to center at (%g %g %g):\n", V3ARGS( center ) );
			for( i=0 ; i<num_segs ; i++ ) {
				bu_log( "\t point #%d: (%g %g %g)\n", i, V3ARGS( circle_pts[i] ) );
			}
		}

		/* make nmg wire edges */
		for( i=1 ; i<num_segs ; i++ ) {
			if( i == num_segs ) {
				v2 = v0;
			}
			eu = nmg_me( v1, v2, layers[curr_layer]->s );
			if( i == 1 ) {
				v1 = eu->vu_p->v_p;
				v0 = v1;
				nmg_vertex_gv( v1, circle_pts[0] );
			}
			v2 = eu->eumate_p->vu_p->v_p;
			if( i < segs_per_circle ) {
				nmg_vertex_gv( v2, circle_pts[i] );
			}
			if( verbose ) {
				bu_log( "Wire edge (arc) #%d (%g %g %g) <-> (%g %g %g)\n", i,
					V3ARGS( v1->vg_p->coord ),
					V3ARGS( v2->vg_p->coord ) );
			}
			v1 = v2;
			v2 = NULL;
		}

		VSETALL( center, 0.0 );
		for( i=0 ; i<segs_per_circle ; i++ ) {
			VSETALL( circle_pts[i], 0.0 );
		}

		curr_state->sub_state = UNKNOWN_ENTITY_STATE;
		process_entities_code[curr_state->sub_state]( code );
		break;
	}

	return( 0 );
}

static int
process_3dface_entities_code( int code )
{
	int vert_no;
	int coord;
	int face[5];

	switch( code ) {
	case 8:
		if( curr_layer_name ) {
			bu_free( curr_layer_name, "curr_layer_name" );
		}
		curr_layer_name = make_brlcad_name( line );
		break;
	case 10:
	case 20:
	case 30:
	case 11:
	case 21:
	case 31:
	case 12:
	case 22:
	case 32:
	case 13:
	case 23:
	case 33:
		vert_no = code % 10;
		coord = code / 10 - 1;
		pts[vert_no][coord] = atof( line ) * units_conv[units] * scale_factor;
		if( verbose ) {
			bu_log( "3dface vertex #%d coord #%d = %g\n", vert_no, coord, pts[vert_no][coord] );
		}
		if( vert_no == 2 ) {
			pts[3][coord] = pts[2][coord];
a360 97
		break;
	case 62:	/* color number */
		curr_color = atoi( line );
		break;
	case 0:
		/* end of this 3dface */
		get_layer();
		if( verbose ) {
			bu_log( "Found end of 3DFACE\n" );
		}
		if( verbose ) {
			bu_log( "\tmaking two triangles\n" );
		}
		for( vert_no=0 ; vert_no<4; vert_no++ ) {
			face[vert_no] = Add_vert( V3ARGS( pts[vert_no]),
						  layers[curr_layer]->vert_tree_root,
						  tol_sq );
		}
		add_triangle( face[0], face[1], face[2], curr_layer );
		add_triangle( face[2], face[3], face[0], curr_layer );
		if( verbose ) {
			bu_log( "finished face\n" );
		}

		curr_state->sub_state = UNKNOWN_ENTITY_STATE;
		process_entities_code[curr_state->sub_state]( code );
		break;
	}
	
	return( 0 );
}

static int
process_entity_code( int code )
{
	return( process_entities_code[curr_state->sub_state]( code ) );
}

static int
process_objects_code( int code )
{
	switch( code ) {
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 0:		/* text string */
		if( !strncmp( line, "SECTION", 7 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		} else if( !strncmp( line, "ENDSEC", 6 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		}
		break;
	}
		
	return( 0 );
}

static int
process_thumbnail_code( int code )
{
	switch( code ) {
	case 999:	/* comment */
		printf( "%s\n", line );
		break;
	case 0:		/* text string */
		if( !strncmp( line, "SECTION", 7 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		} else if( !strncmp( line, "ENDSEC", 6 ) ) {
			curr_state->state = UNKNOWN_SECTION;
			break;
		}
		break;
	}
		
	return( 0 );
}

int
readcodes()
{
	int code;
	int line_len;
	static int line_num=0;

	curr_state->file_offset = ftell( dxf );

	if( fgets( line, LINELEN, dxf ) == NULL ) {
		return( ERROR_FLAG );
	} else {
		code = atoi( line );
	}

	if( fgets( line, LINELEN, dxf ) == NULL ) {
		return( ERROR_FLAG );
d363 2
a364 3
	if( !strncmp( line, "EOF", 3 ) ) {
		return( EOF_FLAG );
	}
d366 3
a368 5
	line_len = strlen( line );
	if( line_len ) {
		line[line_len-1] = '\0';
		line_len--;
	}
d370 1
a370 4
	if( line_len && line[line_len-1] == '\r' ) {
		line[line_len-1] = '\0';
		line_len--;
	}
d372 1
a372 6
	if( verbose ) {
		line_num++;
		bu_log( "%d:\t%d\n", line_num, code );
		line_num++;
		bu_log( "%d:\t%s\n", line_num, line );
	}
d374 1
a374 2
	return( code );
}
d376 2
a377 19
int
main( int argc, char *argv[] )
{
	struct bu_list head_all;
	int name_len;
	char *ptr1, *ptr2;
	int code;
	int c;
	int i;

	tol_sq = tol * tol;

	delta_angle = 2.0 * M_PI / (fastf_t)segs_per_circle;
	sin_delta = sin( delta_angle );
	cos_delta = cos( delta_angle );

	/* get command line arguments */
	scale_factor = 1.0;
	while ((c = getopt(argc, argv, "cdvt:s:")) != EOF)
d379 5
a383 27
		switch( c )
		{
		        case 's':	/* scale factor */
				scale_factor = atof( optarg );
				if( scale_factor < SQRT_SMALL_FASTF ) {
					bu_log( "scale factor too small\n" );
					bu_log( "%s", usage );
					exit( 1 );
				}
				break;
		        case 'c':	/* ignore colors */
				ignore_colors = 1;
				break;
		        case 'd':	/* debug */
				bu_debug = BU_DEBUG_COREDUMP;
				break;
			case 't':	/* tolerance */
				tol = atof( optarg );
				tol_sq = tol * tol;
				break;
			case 'v':	/* verbose */
				verbose = 1;
				break;
			default:
				bu_bomb( usage );
				break;
		}
a384 23

	if( argc - optind < 2 ) {
		bu_bomb( usage );
	}

	dxf_file = argv[optind++];
	output_file = argv[optind];

	if( (out_fp = wdb_fopen( output_file )) == NULL ) {
		bu_log( "Cannot open output file (%s)\n", output_file );
		perror( output_file );
		bu_bomb( "Cannot open output file\n" );
	}

	if( (dxf=fopen( dxf_file, "r")) == NULL ) {
		bu_log( "Cannot open DXF file (%s)\n", dxf_file );
		perror( dxf_file );
		bu_bomb( "Cannot open DXF file\n" );
	}

	ptr1 = strrchr( dxf_file , '/' );
	if( ptr1 == NULL )
		ptr1 = dxf_file;
d386 6
a391 156
		ptr1++;
	ptr2 = strchr( ptr1 , '.' );

	if( ptr2 == NULL )
		name_len = strlen( ptr1 );
	else
		name_len = ptr2 - ptr1;

	base_name = (char *)bu_malloc( name_len + 1 , "base_name" );
	strncpy( base_name , ptr1 , name_len );

	mk_id( out_fp , base_name );

	BU_LIST_INIT( &block_head );

	process_code[UNKNOWN_SECTION] = process_unknown_code;
	process_code[HEADER_SECTION] = process_header_code;
	process_code[CLASSES_SECTION] = process_classes_code;
	process_code[TABLES_SECTION] = process_tables_code;
	process_code[BLOCKS_SECTION] = process_blocks_code;
	process_code[ENTITIES_SECTION] = process_entity_code;
	process_code[OBJECTS_SECTION] = process_objects_code;
	process_code[THUMBNAILIMAGE_SECTION] = process_thumbnail_code;

	process_entities_code[UNKNOWN_ENTITY_STATE] = process_entities_unknown_code;
	process_entities_code[POLYLINE_ENTITY_STATE] = process_entities_polyline_code;
	process_entities_code[POLYLINE_VERTEX_ENTITY_STATE] = process_entities_polyline_vertex_code;
	process_entities_code[FACE3D_ENTITY_STATE] = process_3dface_entities_code;
	process_entities_code[LINE_ENTITY_STATE] = process_line_entities_code;
	process_entities_code[INSERT_ENTITY_STATE] = process_insert_entities_code;
	process_entities_code[POINT_ENTITY_STATE] = process_point_entities_code;
	process_entities_code[CIRCLE_ENTITY_STATE] = process_circle_entities_code;
	process_entities_code[ARC_ENTITY_STATE] = process_arc_entities_code;
	process_entities_code[DIMENSION_ENTITY_STATE] = process_dimension_entities_code;

	process_tables_sub_code[UNKNOWN_TABLE_STATE] = process_tables_unknown_code;
	process_tables_sub_code[LAYER_TABLE_STATE] = process_tables_layer_code;

	/* create storage for circles */
	circle_pts = (point_t *)bu_calloc( segs_per_circle, sizeof( point_t ), "circle_pts" );
	for( i=0 ; i<segs_per_circle ; i++ ) {
		VSETALL( circle_pts[i], 0.0 );
	}

	/* initialize state stack */
	BU_LIST_INIT( &state_stack );

	/* create initial state */
	BU_GETSTRUCT( curr_state, state_data );
	curr_state->file_offset = 0;
	curr_state->state = UNKNOWN_SECTION;
	curr_state->sub_state = UNKNOWN_ENTITY_STATE;
	MAT_IDN( curr_state->xform );

	/* make space for 5 layers to start */
	max_layers = 5;
	next_layer = 1;
	curr_layer = 0;
	layers = (struct layer **)bu_calloc( 5, sizeof( struct layer *), "layers" );
	for( i=0 ; i<max_layers ; i++ ) {
		BU_GETSTRUCT( layers[i], layer );
	}
	layers[0]->name = bu_strdup( "noname" );
	layers[0]->color_number = 7;	/* default white */
	layers[0]->vert_tree_root = create_vert_tree();
	bu_ptbl_init( &layers[0]->solids, 8, "layers[curr_layer]->solids" );

	curr_color = layers[0]->color_number;
	curr_layer_name = bu_strdup( layers[0]->name );

	while( (code=readcodes()) > -900 ) {
		process_code[curr_state->state](code);
	}

	BU_LIST_INIT( &head_all );
	for( i=0 ; i<next_layer ; i++ ) {
		struct bu_list head;
		int j;

		BU_LIST_INIT( &head );

		if( layers[i]->curr_tri || BU_PTBL_END( &layers[i]->solids ) || layers[i]->m ) {
			bu_log( "LAYER: %s\n", layers[i]->name );
		}

		if( layers[i]->curr_tri ) {
			bu_log( "\t%d triangles\n", layers[i]->curr_tri );
			sprintf( tmp_name, "bot.s%d", i );
			if( mk_bot( out_fp, tmp_name, RT_BOT_SURFACE, RT_BOT_UNORIENTED,0,
				    layers[i]->vert_tree_root->curr_vert, layers[i]->curr_tri, layers[i]->vert_tree_root->the_array,
				    layers[i]->part_tris, (fastf_t *)NULL, (struct bu_bitv *)NULL ) ) {
				bu_log( "Failed to make Bot\n" );
			} else {
				(void)mk_addmember( tmp_name, &head, NULL, WMOP_UNION );
			}
		}

		if( BU_PTBL_END( &layers[i]->solids ) > 0 ) {
			bu_log( "\t%d points\n", BU_PTBL_END( &layers[i]->solids ) );
		}

		for( j=0 ; j<BU_PTBL_END( &layers[i]->solids ) ; j++ ) {
			(void)mk_addmember((char *)BU_PTBL_GET( &layers[i]->solids, j ), &head,
					    NULL, WMOP_UNION );
			bu_free( (char *)BU_PTBL_GET( &layers[i]->solids, j), "solid_name" );
		}

		if( layers[i]->m ) {
			char name[32];

			sprintf( name, "nmg.%d", i );
			mk_nmg( out_fp, name, layers[i]->m );
			(void)mk_addmember( name, &head, NULL, WMOP_UNION );
		}

		if( layers[i]->line_count ) {
			bu_log( "\t%d lines\n", layers[i]->line_count );
		}

		if( layers[i]->point_count ) {
			bu_log( "\t%d points\n", layers[i]->point_count );
		}

		if( BU_LIST_NON_EMPTY( &head ) ) {
			unsigned char *tmp_rgb;
			struct bu_vls comb_name;

			if( layers[i]->color_number < 0 ) {
				tmp_rgb = &rgb[7];
			} else {
				tmp_rgb = &rgb[layers[i]->color_number*3];
			}
			bu_vls_init( &comb_name );
			bu_vls_printf( &comb_name, "%s.c.%d", layers[i]->name, i );
			if( mk_comb( out_fp, bu_vls_addr( &comb_name ), &head, 1, NULL, NULL,
				     tmp_rgb, 1, 0, 1, 100, 0, 0, 0 ) ) {
				bu_log( "Failed to make region %s\n", layers[i]->name );
			} else {
				(void)mk_addmember( bu_vls_addr( &comb_name ), &head_all, NULL, WMOP_UNION );
			}
		}

	}

	if( BU_LIST_NON_EMPTY( &head_all ) ) {
		struct bu_vls top_name;
		int count=0;

		bu_vls_strcpy( &top_name, "all" );
		while( db_lookup( out_fp->dbip, bu_vls_addr( &top_name ), LOOKUP_QUIET ) != DIR_NULL ) {
			count++;
			bu_vls_trunc( &top_name, 0 );
			bu_vls_printf( &top_name, "all.%d", count );
		}

		(void)mk_comb( out_fp, bu_vls_addr( &top_name ), &head_all, 0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 0, 0 );
d394 2
a395 1
	return( 0 );
@


11.10
log
@Converted from K&R to ANSI C - RFH
@
text
@d25 3
a27 1
main(int argc, char **argv)
@


11.9
log
@Changes to compile under RedHat 7.0
@
text
@d25 1
a25 3
main( argc , argv )
int argc;
char *argv[];
@


11.8
log
@
Converted to use new version of LIBWDB
@
text
@d346 2
a347 1
						struct edgeuse *eu;
@


11.7
log
@
Removed stray RT_EXTERNs, added bn_ prefix.
@
text
@d24 1
d31 2
a32 1
	FILE *out_fp;
a56 1
	out_fp = stdout;
d84 1
a84 6
				if( (out_fp = fopen( optarg , "w" )) == NULL )
				{
					bu_log( "Cannot open %s\n" , optarg );
					perror( "tankill-g" );
					rt_bomb( "Cannot open output file\n" );
				}
d95 1
a95 1
	if( isatty( fileno( out_fp ) ) )
d97 4
a100 2
		bu_log( "This routine creates a BRL-CAD which you wold not want sent to your terminal\n" );
		rt_bomb( usage );
@


11.6
log
@
sed4
@
text
@a19 3
RT_EXTERN( fastf_t nmg_loop_plane_area , (struct loopuse *lu , plane_t pl ) );


@


11.5
log
@removed include of db.h
@
text
@d38 1
a38 1
	struct rt_tol tol;
d44 2
a45 2
	struct nmg_ptbl vertices;
	struct nmg_ptbl faces;
d52 1
a52 1
        tol.magic = RT_TOL_MAGIC;
d76 1
a76 1
				dxf_name = (char *)rt_malloc( strlen( optarg ) + 1 , "Dxf-g: dxf_name" );
d80 1
a80 1
					rt_log( "Cannot open %s\n" , dxf_name );
d88 1
a88 1
					rt_log( "Cannot open %s\n" , optarg );
d104 1
a104 1
		rt_log( "This routine creates a BRL-CAD which you wold not want sent to your terminal\n" );
d122 1
a122 1
		base_name = (char *)rt_malloc( name_len + 1 , "base_name" );
d133 1
a133 1
		rt_log( "Looking for ENTITIES section..\n" );
d140 1
a140 1
				rt_log( "Found group code 0\n" );
d147 1
a147 1
					rt_log( "Found 'SECTION'\n" );
d154 1
a154 1
						rt_log( "Found group code 2\n" );
d160 1
a160 1
							rt_log( "Found 'ENTITIES'\n" );
d176 1
a176 1
	s = RT_LIST_FIRST( shell , &r->s_hd );
d178 2
a179 2
	nmg_tbl( &vertices , TBL_INIT , NULL );
	nmg_tbl( &faces , TBL_INIT , NULL );
d196 1
a196 1
				rt_log( "Found end of ENTITIES section\n" );
d201 1
a201 1
			rt_log( "Unknown entity type (%s), skipping\n" , line );
d222 1
a222 1
			rt_log(  "Unknown entity type (%s), skipping\n" , line );
d228 1
a228 1
				rt_log( "Found 3DFACE\n" );
d230 1
a230 1
				rt_log( "Found LINE\n" );
d251 1
a251 1
						rt_log( "Making %s\n" , curr_name );
d274 1
a274 1
						rt_log( "\tpt[%d][%d]=%g\n", i,j,pt[i][j] );
d287 1
a287 1
									rt_log( "Combining points %d (%g,%g,%g) and %d (%g,%g,%g)\n",
d302 1
a302 1
							rt_log( "Skipping face with %d vertices\n" , no_of_pts );
d310 1
a310 1
							rt_log( "FACE:\n" );
d312 1
a312 1
							rt_log( "LINE:\n" );
d317 1
a317 1
							rt_log( "\t( %f %f %f )\n" , V3ARGS( pt[i] ) );
d324 1
a324 1
						nmg_tbl( &faces , TBL_INS , (long *)fu );
d331 1
a331 1
								nmg_tbl( &vertices , TBL_INS , (long *)vp[i] );
d334 1
a334 1
						for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d373 2
a374 2
	rt_log( "Glueing %d faces together...\n" , NMG_TBL_END( &faces ) );
	nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ), &tol );
d385 1
a385 1
		rt_log( "Writing polysolid to output...\n" );
d393 1
a393 1
		rt_log( "Writing NMG to output...\n" );
d400 1
a400 1
	fprintf( stderr , "%d polygons\n" , NMG_TBL_END( &faces ) );
@


11.4
log
@Mod to include tolerance arg to nmg_gluefaces().
@
text
@a11 1
#include "db.h"
@


11.3
log
@Added -p option for polysolids.
@
text
@d375 1
a375 1
	nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ) );
@


11.2
log
@Added LINE capability.
@
text
@d26 1
a26 1
static char *usage="dxf-g [-v] [-d] [-t tolerance] [-i input_file] [-o output_file_name]";
@


11.1
log
@Release_4.4
@
text
@d188 2
d193 1
a193 1
		while( strncmp( line , "3DFACE" , 6 ) )
d217 9
d227 6
a232 1
			rt_log( "Found 3DFACE\n" );
d299 1
a299 1
					if( no_of_pts != 3 && no_of_pts != 4 )
d301 5
a305 2
						rt_log( "Skipping face with %d vertices\n" , no_of_pts );
						break;
d309 6
a314 1
						rt_log( "FACE:\n" );
d321 2
a322 3
					fu = nmg_cface( s , vp , no_of_pts );
					nmg_tbl( &faces , TBL_INS , (long *)fu );
					for( i=0 ; i<no_of_pts ; i++ )
d324 4
a327 1
						if( vp[i]->vg_p == NULL )
d329 5
a333 2
							nmg_vertex_gv( vp[i] , pt[i] );
							nmg_tbl( &vertices , TBL_INS , (long *)vp[i] );
d335 14
d350 1
a350 2

					for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d352 1
a352 2
						fastf_t area;
						plane_t pl;
d354 1
a354 2
						area = nmg_loop_plane_area( lu , pl );
						if( area > 0.0 )
d356 2
a357 4
							if( lu->orientation == OT_OPPOSITE )
								HREVERSE( pl , pl );
							nmg_face_g( fu , pl );
							break;
d359 1
@


1.6
log
@Added verbose option and added default cad to switch statement.
@
text
@@


1.5
log
@Factored ifdefs
@
text
@d26 1
a26 1
static char *usage="dxf-g [-p] [-t tolerance] [-i input_file] [-o output_file_name]";
d42 1
d60 3
a62 1
	dxf = NULL;
a63 3
	if( argc < 2 )
		rt_bomb( usage );

d65 1
a65 1
	while ((c = getopt(argc, argv, "pt:i:o:")) != EOF)
d73 3
d77 1
a77 1
				dxf_name = (char *)rt_malloc( strlen( optarg ) + 1 , "Viewpoint-g: base name" );
d103 3
a105 1
	if( dxf == NULL )
d107 1
d109 8
a116 6
	ptr1 = strrchr( dxf_name , '/' );
	if( ptr1 == NULL )
		ptr1 = dxf_name;
	else
		ptr1++;
	ptr2 = strchr( ptr1 , '.' );
d118 10
a127 2
	if( ptr2 == NULL )
		name_len = strlen( ptr1 );
d129 1
a129 4
		name_len = ptr2 - ptr1;

	base_name = (char *)rt_malloc( name_len + 1 , "base_name" );
	strncpy( base_name , ptr1 , name_len );
a130 1
	mk_id( out_fp , base_name );
d133 2
d140 2
d147 2
d154 2
d160 2
d215 3
d258 2
d270 4
a273 1
/* rt_log( "Combining points %d and %d\n" , i , j ); */
d279 1
d288 3
a290 1
/* rt_log( "FACE:\n" ); */
d293 2
a294 1
/* rt_log( "\t( %f %f %f )\n" , V3ARGS( pt[i] ) ); */
d323 4
d338 2
a341 2
	nmg_rebound( m , &tol );

d348 4
a351 1
		write_shell_as_polysolid( out_fp , base_name , s );
d356 4
a359 1
		mk_nmg( out_fp , base_name  , m );
@


1.4
log
@removed declaration of args from routine definition
@
text
@d1 2
d5 1
d7 4
a22 1
extern int errno;
d319 1
@


1.3
log
@Converted to use nmg_loop_plane_area
@
text
@d22 3
a24 1
main( int argc , char *argv[] )
@


1.2
log
@Modified to make one call to nmg_region_vfuse after all geometry built
@
text
@d14 2
d51 1
a51 1
	dxf = stdin;
d189 2
d265 15
a279 2
			                if( nmg_fu_planeeqn( fu , &tol ) )
			                        rt_log( "Failed to calculate plane eqn\n" );
d286 1
a286 3
	rt_log( "Checking %d vertices for repeats...\n" , NMG_TBL_END( &vertices ) );
	(void)nmg_region_self_vfuse( &vertices , &tol );
	rt_log( "\t%d unique vertices found\n" , NMG_TBL_END( &vertices ) );
d292 3
a294 1
	nmg_fix_normals( s );
@


1.1
log
@Initial revision
@
text
@a249 11
						for( j=0 ; j<NMG_TBL_END( &vertices ) ; j++ )
						{
							struct vertex *v;

							v = (struct vertex *)NMG_TBL_GET( &vertices , j );
							if( VAPPROXEQUAL( pt[i] , v->vg_p->coord , tol.dist ) )
							{
								vp[i] = v;
								break;
							}
						}
a262 8
					for( i=0 ; i<no_of_pts ; i++ )
					{
						for( j=i+1 ; j<no_of_pts ; j++ )
						{
							if( vp[i] == vp[j] )
								rt_log( "vertex %d is same as vertex %d\n" , i , j );
						}
					}
d267 5
@


1.1.1.1
log
@Checkpoint (working version for just 3DFACE entities).
@
text
@d16 1
a16 2
#define	LINELEN		256	/* max input line length from elements file */
#define	LAYERLEN	32	/* max length for a layer name */
d18 1
a18 2
static char *usage="dxf-g [-d] [-l] [-n] [-p] [-t tolerance] [-i input_file] [-o output_file_name]";
static char *all="all";
d22 14
a35 20
	register int c;			/* Command line option letter */
	FILE *dxf;			/* Input DXF file */
	FILE *out_fp;			/* Output BRLCAD file */
	char *dxf_name;			/* Name of input file */
	char *base_name;		/* Base name from dxf_name (no /`s) */
	char *curr_name;		/* Current layer name */
	int name_len;			/* Length of name */
	struct rt_tol tol;		/* Tolerance */
	int done=0;			/* Flag for loop control */
	int polysolids=0;		/* Flag for polysolid output */
	int debug=0;			/* Debug flag */
	int do_layers=1;		/* Flag for grouping according to layer name */
	int no_of_layers;		/* number of layers to process */
	int curr_layer;			/* current layer number */
	int do_normals=0;
	int obj_count=0;		/* count of objects written to BRLCAD DB file */
	char line[LINELEN];		/* Buffer for line from input file */
	struct nmg_ptbl vertices;	/* Table of vertices */
	struct nmg_ptbl faces;		/* Table of faceuses */
	struct nmg_ptbl	layers;		/* Table of layer names */
a39 2
	char *ptr1,*ptr2;
	int i,j,group_code;
d55 1
a55 1
	while ((c = getopt(argc, argv, "dlpt:i:o:")) != EOF)
a58 9
			case 'n':	/* Try to fix normals */
				do_normals = 1;
				break;
			case 'l':	/* do not use layers to form groups */
				do_layers = 0;
				break;
			case 'd':	/* debug */
				debug = 1;
				break;
d104 1
a104 1
	
d107 2
d110 2
a111 3
	curr_name = NULL;

	if( do_layers )
d113 2
a114 3
		/* Make list of layer names */
		nmg_tbl( &layers , TBL_INIT , NULL );
		while( fgets( line , LINELEN , dxf ) != NULL )
d116 1
a116 1
			group_code = atoi( line );
d119 1
a119 1
			if( group_code == 8 )	/* layer name */
d121 4
a124 6
				char *name;
				int found=0;

				name_len = strlen( line );
				line[--name_len] = '\0';
				for( i=0 ; i<NMG_TBL_END( &layers ) ; i++ )
d126 3
a128 1
					if( !strcmp( line , (char *)NMG_TBL_GET( &layers , i ) ) )
d130 5
a134 1
						found = 1;
a137 6
				if( !found )
				{
					name = (char *)rt_malloc( name_len , "dxf-g: layer name" );
					strcpy( name , line );
					nmg_tbl( &layers , TBL_INS , (long *)name );
				}
a139 1
		no_of_layers = NMG_TBL_END( &layers );
a140 2
	else
		no_of_layers = 1;
d142 4
a145 8
	if( debug && do_layers )
	{
		rt_log( "%d layers: \n" , NMG_TBL_END( &layers ) );
		for( i=0 ; i<NMG_TBL_END( &layers ) ; i++ )
			rt_log( "\t%s\n" , (char *)NMG_TBL_GET( &layers , i ) );
	}
	
	mk_id( out_fp , base_name );
d147 5
a151 1
	for( curr_layer = 0; curr_layer < no_of_layers ; curr_layer++ )
d153 3
a155 4
		if( do_layers )
			curr_name = (char *)NMG_TBL_GET( &layers , curr_layer );
		else
			curr_name = (char *)NULL;
d157 3
a159 1
		if( debug )
d161 1
a161 13
			if( do_layers )
				rt_log( "Making layer %d of %d: %s\n", curr_layer+1 , NMG_TBL_END( &layers ),
					curr_name );
			else
				rt_log( "Making one layer\n" );
		}

		/* Find the ENTITIES SECTION */
		rewind( dxf );
		while( fgets( line , LINELEN , dxf ) != NULL )
		{
			sscanf( line , "%d" , &group_code );
			if( group_code == 0 )
d163 3
a165 28
				/* read label from next line */
				if( fgets( line , LINELEN , dxf ) == NULL )
					rt_bomb( "Unexpected EOF in input file\n" );
				if( !strncmp( line , "SECTION" , 7 ) )
				{
					if( fgets( line , LINELEN , dxf ) == NULL )
						rt_bomb( "Unexpected EOF in input file\n" );
					sscanf( line , "%d" , &group_code );
					if( group_code == 2 )
					{
						if( fgets( line , LINELEN , dxf ) == NULL )
							rt_bomb( "Unexpected EOF in input file\n" );
						if( !strncmp( line , "ENTITIES" , 8 ) )
						{
							if( fgets( line , LINELEN , dxf ) == NULL )
								rt_bomb( "Unexpected EOF in input file\n" );
							sscanf( line , "%d" , &group_code );
							if( group_code != 0 )
								rt_bomb( "Expected group code 0 at start of ENTITIES\n" );
							break;
						}
					}
					else	/* skip next line */
					{
						if( fgets( line , LINELEN , dxf ) == NULL )
							rt_bomb( "Unexpected EOF in input file\n" );
					}
				}
d167 4
a170 1
			else	/* skip next line */
d174 3
d180 2
a181 4
		/* make basic nmg structures */
		m = nmg_mm();
		r = nmg_mrsv( m );
		s = RT_LIST_FIRST( shell , &r->s_hd );
d183 3
a185 6
		nmg_tbl( &vertices , TBL_INIT , NULL );
		nmg_tbl( &faces , TBL_INIT , NULL );

		/* Read the ENTITIES section */
		done = 0;
		while( !done )
a186 5
			struct vertex *vp[4];
			point_t pt[4];
			int no_of_pts;
			int skip_face;

d189 2
a190 1
			while( strncmp( line , "3DFACE" , 6 ) )
d192 1
a192 12
				if( !strncmp( line , "ENDSEC" , 6 ) )
				{
					rt_log( "Found end of ENTITIES section\n" );
					done = 1;
					break;
				}
				line[ strlen(line)-1 ] = '\0';
				if( debug )
					rt_log( "Unknown entity type (%s), skipping\n" , line );
				group_code = 1;
				while( group_code != 0 )
				{
d195 23
a217 1
					sscanf( line , "%d" , &group_code );
d220 7
a226 42
				}
			}
			skip_face = 0;

			if( done )
				break;

			no_of_pts = (-1);
			group_code = 1;
			while( group_code )
			{
				if( fgets( line , LINELEN , dxf ) == NULL )
					rt_bomb( "Unexpected EOF in input file\n" );
				sscanf( line , "%d" , &group_code );
				switch( group_code )
				{
					default:
						if( fgets( line , LINELEN , dxf ) == NULL )
							rt_bomb( "Unexpected EOF in input file\n" );
						break;
					case 8:
						if( fgets( line , LINELEN , dxf ) == NULL )
							rt_bomb( "Unexpected EOF in input file\n" );
						line[ strlen( line ) - 1 ] = '\0';
						if( curr_name != NULL && strcmp( line , curr_name ) )
							skip_face = 1;
						break;
					case 10:
					case 20:
					case 30:
					case 11:
					case 21:
					case 31:
					case 12:
					case 22:
					case 32:
					case 13:
					case 23:
					case 33:
						if( fgets( line , LINELEN , dxf ) == NULL )
							rt_bomb( "Unexpected EOF in input file\n" );
						if( !skip_face )
d228 1
a228 20
							i = group_code%10;
							j = group_code/10 - 1;
							if( i > no_of_pts )
								no_of_pts = i;
							pt[i][j] = atof( line );
						}
						break;
					case 0:
						if( skip_face )
							break;
						no_of_pts++;
						if( debug )
						{
							rt_log( "Original FACE:\n" );
							for( i=0 ; i<no_of_pts ; i++ )
								rt_log( "\t( %f %f %f )\n" , V3ARGS( pt[i] ) );
						}
						for( i=0 ; i<no_of_pts ; i++ )
						{
							for( j=i+1 ; j<no_of_pts ; j++ )
d230 4
a233 1
								if( VAPPROXEQUAL( pt[i] , pt[j] , tol.dist ) )
d235 1
a235 10
									int k;

									if( debug )
										rt_log( "Combining points %d and %d\n" , i , j );
									no_of_pts--;
									for( k=j ; k<no_of_pts ; k++ )
									{
										VMOVE( pt[k] , pt[k+1] );
									}
									j--;
d239 12
a250 1
						if( no_of_pts != 3 && no_of_pts != 4 )
d252 1
a252 20
							if( debug )
								rt_log( "Skipping face with %d vertices\n" , no_of_pts );
							break;
						}
						if( no_of_pts == 3 && rt_3pts_collinear( pt[0],pt[1],pt[2],&tol ) )
						{
							if( debug )
								rt_log( "Skipping triangular face with collinear vertices\n" );
							break;
						}
						if( debug )
							rt_log( "final FACE:\n" );
						for( i=0 ; i<no_of_pts ; i++ )
						{
							if( debug )
								rt_log( "\t( %f %f %f )\n" , V3ARGS( pt[i] ) );
							vp[i] = (struct vertex *)NULL;
							for( j=0 ; j<NMG_TBL_END( &vertices ) ; j++ )
							{
								struct vertex *v;
d254 2
a255 12
								v = (struct vertex *)NMG_TBL_GET( &vertices , j );
								if( rt_pt3_pt3_equal( pt[i] , v->vg_p->coord , &tol) )
								{
									vp[i] = v;
									break;
								}
							}
						}
						fu = nmg_cface( s , vp , no_of_pts );
						for( i=0 ; i<no_of_pts ; i++ )
						{
							if( vp[i]->vg_p == NULL )
d257 2
a258 2
								nmg_vertex_gv( vp[i] , pt[i] );
								nmg_tbl( &vertices , TBL_INS , (long *)vp[i] );
d261 6
a266 1
				                if( nmg_fu_planeeqn( fu , &tol ) )
d268 2
a269 4
				                        rt_log( "Failed to calculate plane eqn\n" );
							rt_log( "FACE:\n" );
							for( i=0 ; i<no_of_pts ; i++ )
								rt_log( "( %f %f %f )\n" , V3ARGS( pt[i] ) );
d271 6
a276 3
						else
							nmg_tbl( &faces , TBL_INS , (long *)fu );
						for( i=0 ; i<no_of_pts ; i++ )
d278 2
a279 5
							for( j=i+1 ; j<no_of_pts ; j++ )
							{
								if( vp[i] == vp[j] )
									rt_log( "vertex %d is same as vertex %d\n" , i , j );
							}
d281 2
a282 2
						break;
				}
d285 1
d287 3
a289 2
		if( debug )
			rt_log( "%d unique vertices\n" , NMG_TBL_END( &vertices ) );
d291 1
a291 4
		/* glue faces together */
		if( debug )
			rt_log( "Glueing %d faces together...\n" , NMG_TBL_END( &faces ) );
		nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ) );
d293 1
a293 2
		if( do_normals )
			nmg_fix_normals( s );
d295 5
a299 19
		/* write the nmg to the output file */
		obj_count++;
		if( polysolids )
		{
			if( debug )
				rt_log( "Writing polysolid to output...\n" );
			write_shell_as_polysolid( out_fp , curr_name , s );
		}
		else
		{
			if( debug )
				rt_log( "Writing NMG to output...\n" );
			mk_nmg( out_fp , curr_name  , m );
		}

		rt_log( "%d polygons\n" , NMG_TBL_END( &faces ) );
		nmg_km( m );
		nmg_tbl( &faces , TBL_RST , NULL );
		nmg_tbl( &vertices , TBL_RST , NULL );
d301 5
a305 3
	for( i=0 ; i<NMG_TBL_END( &layers ) ; i++ )
		rt_free( (char *)NMG_TBL_GET( &layers , i ) , "dxf-g: layer names" );
	nmg_tbl( &layers , TBL_RST , NULL );
d307 1
a307 1
	rt_log( "%d objects written to output file\n" , obj_count );
@


1.1.1.2
log
@Checkpoint
@
text
@a20 12
static FILE *dxf;			/* Input DXF file */
static FILE *out_fp;			/* Output BRLCAD file */
static struct rt_tol tol;		/* Tolerance */
static char line[LINELEN];		/* Buffer for line from input file */
static char *curr_name;			/* Current layer name */
static int debug=0;			/* Debug flag */
static struct nmg_ptbl vertices;	/* Table of vertices */
static struct nmg_ptbl faces;		/* Table of faceuses */
static struct nmg_ptbl layers;		/* Table of layer names */
static struct model *m;
static struct nmgregion *r;
static struct shell *s;
a21 148
int
Do_3dface()
{
	struct faceuse *fu;
	struct vertex *vp[4];
	point_t pt[4];
	int no_of_pts;
	int skip_face;
	int i,j,group_code;

	if( debug )
		rt_log( "3DFACE\n" );
	skip_face = 0;
	no_of_pts = (-1);
	group_code = 1;
	while( group_code )
	{
		if( fgets( line , LINELEN , dxf ) == NULL )
			rt_bomb( "Unexpected EOF in input file\n" );
		sscanf( line , "%d" , &group_code );
		switch( group_code )
		{
			default:
				if( fgets( line , LINELEN , dxf ) == NULL )
					rt_bomb( "Unexpected EOF in input file\n" );
				break;
			case 8:
				if( fgets( line , LINELEN , dxf ) == NULL )
					rt_bomb( "Unexpected EOF in input file\n" );
				line[ strlen( line ) - 1 ] = '\0';
				if( curr_name != NULL && strcmp( line , curr_name ) )
					skip_face = 1;
				break;
			case 10:
			case 20:
			case 30:
			case 11:
			case 21:
			case 31:
			case 12:
			case 22:
			case 32:
			case 13:
			case 23:
			case 33:
				if( fgets( line , LINELEN , dxf ) == NULL )
					rt_bomb( "Unexpected EOF in input file\n" );
				if( !skip_face )
				{
					i = group_code%10;
					j = group_code/10 - 1;
					if( i > no_of_pts )
						no_of_pts = i;
					pt[i][j] = atof( line );
				}
				break;
			case 0:
				if( skip_face )
					break;
				no_of_pts++;
				if( debug )
				{
					rt_log( "Original FACE:\n" );
					for( i=0 ; i<no_of_pts ; i++ )
						rt_log( "\t( %f %f %f )\n" , V3ARGS( pt[i] ) );
				}
				for( i=0 ; i<no_of_pts ; i++ )
				{
					for( j=i+1 ; j<no_of_pts ; j++ )
					{
						if( VAPPROXEQUAL( pt[i] , pt[j] , tol.dist ) )
						{
							int k;

							if( debug )
								rt_log( "Combining points %d and %d\n" , i , j );
							no_of_pts--;
							for( k=j ; k<no_of_pts ; k++ )
							{
								VMOVE( pt[k] , pt[k+1] );
							}
							j--;
						}
					}
				}
				if( no_of_pts != 3 && no_of_pts != 4 )
				{
					if( debug )
						rt_log( "Skipping face with %d vertices\n" , no_of_pts );
					break;
				}
				if( no_of_pts == 3 && rt_3pts_collinear( pt[0],pt[1],pt[2],&tol ) )
				{
					if( debug )
						rt_log( "Skipping triangular face with collinear vertices\n" );
					break;
				}
				if( debug )
					rt_log( "final FACE:\n" );
				for( i=0 ; i<no_of_pts ; i++ )
				{
					if( debug )
						rt_log( "\t( %f %f %f )\n" , V3ARGS( pt[i] ) );
					vp[i] = (struct vertex *)NULL;
					for( j=0 ; j<NMG_TBL_END( &vertices ) ; j++ )
					{
						struct vertex *v;

						v = (struct vertex *)NMG_TBL_GET( &vertices , j );
						if( rt_pt3_pt3_equal( pt[i] , v->vg_p->coord , &tol) )
						{
							vp[i] = v;
							break;
						}
					}
				}
				fu = nmg_cface( s , vp , no_of_pts );
				for( i=0 ; i<no_of_pts ; i++ )
				{
					if( vp[i]->vg_p == NULL )
					{
						nmg_vertex_gv( vp[i] , pt[i] );
						nmg_tbl( &vertices , TBL_INS , (long *)vp[i] );
					}
				}
		                if( nmg_fu_planeeqn( fu , &tol ) )
				{
		                        rt_log( "Failed to calculate plane eqn\n" );
					rt_log( "FACE:\n" );
					for( i=0 ; i<no_of_pts ; i++ )
						rt_log( "( %f %f %f )\n" , V3ARGS( pt[i] ) );
				}
				else
					nmg_tbl( &faces , TBL_INS , (long *)fu );
				for( i=0 ; i<no_of_pts ; i++ )
				{
					for( j=i+1 ; j<no_of_pts ; j++ )
					{
						if( vp[i] == vp[j] )
							rt_log( "vertex %d is same as vertex %d\n" , i , j );
					}
				}
				break;
		}
	}
	return( group_code );
}

d25 2
d29 1
d31 1
d34 1
d40 8
a127 1
	nmg_tbl( &layers , TBL_INIT , NULL );
d132 1
d195 1
a195 1
			group_code = atoi( line );
d198 1
a202 1
					/* start of a section, is it the ENTITIES section ??? */
d205 2
a206 3
					group_code = atoi( line );
					/* look for the section name */
					while( group_code != 2 )
d210 12
a223 1
						group_code = atoi(line );
a224 8
					if( fgets( line , LINELEN , dxf ) == NULL )
						rt_bomb( "Unexpected EOF in input file\n" );
					if( !strncmp( line , "ENTITIES" , 8 ) )
					{
						if( debug )
							rt_log( "Found ENTITIES Section\n" );
						break;
					}
a242 3
		if( fgets( line , LINELEN , dxf ) == NULL )
			rt_bomb( "Unexpected EOF in input file\n" );
		group_code = atoi( line );
d246 8
a253 1
			if (group_code == 0 )
d255 1
a255 5
				if( fgets( line , LINELEN , dxf ) == NULL )
					rt_bomb( "Unexpected EOF in input file\n" );
				if( !strncmp( line , "3DFACE" , 6 ) )
					group_code = Do_3dface();
				else if( !strncmp( line , "ENDSEC" , 6 ) )
d257 1
a257 2
					if( debug )
						rt_log( "Found end of ENTITIES section\n" );
d261 12
d274 8
a281 1
			else
d285 125
a409 3
				if( fgets( line , LINELEN , dxf ) == NULL )
					rt_bomb( "Unexpected EOF in input file\n" );
				group_code = atoi( line );
d417 3
a419 6
		if( NMG_TBL_END( &faces ) )
		{
			if( debug )
				rt_log( "Glueing %d faces together...\n" , NMG_TBL_END( &faces ) );
			nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ) );
		}
a425 3

		if( !do_layers )
			curr_name = all;
@


1.1.1.3
log
@Checkpoint
@
text
@a17 1
#define SKIP_LINE_SEGS	1	/* flag to inhibit creation of wire edges */
d19 1
a19 13
struct dxf_verts
{
	point_t pt;
	struct vertex *vp;
};

static char *usage="dxf-g [-d debug_level] [-l] [-n] [-p] [-t tolerance] [-i input_file] [-o output_file_name]\n\
\tdebug_level is 1 or 2\n\
\t-l -> do not process DXF file by layers\n\
\t-n -> try to fix surface normal directions\n\
\t-p -> build polysolids instead of NMG's\n\
\t\tIf an input file is not specified, the -l option must be used\n";

a22 1
static char *std_in_name="stdin";	/* Name for standard input */
a34 281
Do_vertex( pt , flags )
point_t pt;
int *flags;
{
	int done=0;
	int group_code;

	while( !done )
	{
		if( fgets( line , LINELEN , dxf ) == NULL )
			rt_bomb( "Unexpected EOF in input file\n" );
		group_code = atoi( line );
		switch( group_code )
		{
			default:
				if( fgets( line , LINELEN , dxf ) == NULL )
					rt_bomb( "Unexpected EOF in input file\n" );
				break;
			case 70:	/* vertex flags */
				if( fgets( line , LINELEN , dxf ) == NULL )
					rt_bomb( "Unexpected EOF in input file\n" );
				(*flags) = atoi( line );
				break;
			case 10:
			case 20:
			case 30:	/* Coordinates */
				if( fgets( line , LINELEN , dxf ) == NULL )
					rt_bomb( "Unexpected EOF in input file\n" );
				pt[ group_code/10 - 1 ] = atof( line );
				break;
			case 0:
				done = 1;
		}
	}
	return( group_code );
}

int
Do_polyline()
{
	int done=0;
	int group_code;
	int flags=0;
	int m_count=0,n_count=0;
	int mesh_size;
	int vert_count=0;
	int i,j;
	struct dxf_verts *mesh;

	mesh = (struct dxf_verts *)NULL;
	while( !done )
	{
		if( fgets( line , LINELEN , dxf ) == NULL )
			rt_bomb( "Unexpected EOF in input file\n" );
		group_code = atoi( line );
		switch( group_code )
		{
			default:
				if( fgets( line , LINELEN , dxf ) == NULL )
					rt_bomb( "Unexpected EOF in input file\n" );
				break;
			case 8:		/* Layer name */
				if( fgets( line , LINELEN , dxf ) == NULL )
					rt_bomb( "Unexpected EOF in input file\n" );
				line[ strlen( line ) - 1 ] = '\0';
				if( curr_name != NULL && strcmp( curr_name , line ) )
				{
					/* skip this entity */
					while( !done )
					{
						if( fgets( line , LINELEN , dxf ) == NULL )
							rt_bomb( "Unexpected EOF in input file\n" );
						group_code = atoi( line );
						if( fgets( line , LINELEN , dxf ) == NULL )
							rt_bomb( "Unexpected EOF in input file\n" );
						if( group_code == 0 && !strncmp( line , "SEQEND" , 6 ) )
							done = 1;
					}
				}
				else if( debug )
					rt_log( "Polyline:\n" );
				break;
			case 66:	/* vertices follow flag */
				if( fgets( line , LINELEN , dxf ) == NULL )
					rt_bomb( "Unexpected EOF in input file\n" );
				if( atoi( line ) != 1 )
					rt_bomb( "dxf-g: POLYLINE with 'vertices follow' flag not one\n" );
				break;
			case 70:	/* flags */
				if( fgets( line , LINELEN , dxf ) == NULL )
					rt_bomb( "Unexpected EOF in input file\n" );
				flags = atoi( line );
				break;
			case 71:	/* Mesh count 'M' */
				if( fgets( line , LINELEN , dxf ) == NULL )
					rt_bomb( "Unexpected EOF in input file\n" );
				m_count = atoi( line );
				break;
			case 72:	/* Mesh count 'N' */
				if( fgets( line , LINELEN , dxf ) == NULL )
					rt_bomb( "Unexpected EOF in input file\n" );
				n_count = atoi( line );
				break;
			case 0:		/* Start of something (hopefully vertex list) */
				if( fgets( line , LINELEN , dxf ) == NULL )
					rt_bomb( "Unexpected EOF in input file\n" );
				mesh_size = m_count * n_count;
				if( mesh_size )
				{
					struct faceuse *fu;

					/* read and store a mesh */
					mesh = (struct dxf_verts *)rt_calloc( mesh_size , sizeof( struct dxf_verts ) , "dxf-g: mesh" );
					while( !strncmp( line , "VERTEX" , 6 ) )
					{
						int pt_flags=0;

						group_code = Do_vertex( mesh[vert_count].pt , &pt_flags );
						mesh[vert_count].vp = (struct vertex *)NULL;
						if( ++vert_count > mesh_size )
							rt_bomb( "dxf-g: Too many vertices for mesh size\n" );
						if( fgets( line , LINELEN , dxf ) == NULL )
							rt_bomb( "Unexpected EOF in input file\n" );
					}
					/* Look for vertices already existing */
					for( i=0 ; i<vert_count ; i++ )
					{
						for( j=0 ; j<NMG_TBL_END( &vertices ) ; j++ )
						{
							struct vertex *v;

							v = (struct vertex *)NMG_TBL_GET( &vertices , j );
							if( rt_pt3_pt3_equal( mesh[i].pt , v->vg_p->coord , &tol) )
							{
								mesh[i].vp = v;
								if( debug == 2 )
									rt_log( "\tReusing existing vertex at ( %f %f %f )\n" , V3ARGS( mesh[i].vp->vg_p->coord ) );
								break;
							}
						}
					}


					/* make faces */
					for( i=1 ; i<m_count ; i++ )
					{
						for( j=0 ; j<n_count-1 ; j++ )
						{
							struct vertex **vp[4];
							point_t pt[4];
							int nverts;
							int k,l,m;

							VMOVE( pt[0] , mesh[i*n_count + j].pt);
							VMOVE( pt[1] , mesh[i*n_count + j + 1].pt);
							VMOVE( pt[2] , mesh[(i-1)*n_count + j + 1].pt);
							VMOVE( pt[3] , mesh[(i-1)*n_count + j].pt);
							vp[0] = &mesh[i*n_count + j].vp;
							vp[1] = &mesh[i*n_count + j + 1].vp;
							vp[2] = &mesh[(i-1)*n_count + j + 1].vp;
							vp[3] = &mesh[(i-1)*n_count + j].vp;
							nverts = 4;
							if( debug == 2 )
							{
								rt_log( "Making face:\n" ) ;
								rt_log( "\t( %f %f %f )\n" , V3ARGS( pt[0] ) );
								rt_log( "\t( %f %f %f )\n" , V3ARGS( pt[1] ) );
								rt_log( "\t( %f %f %f )\n" , V3ARGS( pt[2] ) );
								rt_log( "\t( %f %f %f )\n" , V3ARGS( pt[3] ) );
							}

							/* check for zero length edges */
							for( k=0 ; k<nverts-1 ; k++ )
							{
								if( rt_pt3_pt3_equal( pt[k] , pt[k+1] , &tol ) )
								{
									for( m=k+1 ; m<nverts-1 ; m++ )
									{
										VMOVE( pt[m] , pt[m+1] );
										vp[m] = vp[m+1];
									}
									nverts--;
									k--;
								}
							}

							if( debug == 2 )
							{
								if( nverts > 2 )
								{
									rt_log( "Making face:\n" ) ;
									for( k=0 ; k<nverts ; k++ )
										rt_log( "\t( %f %f %f )\n" , V3ARGS( pt[k] ) );
								}
								else
									rt_log( "Skip this face\n" );
							}
							if( nverts > 2 )
							{
								fu = nmg_cmface( s , vp , nverts );
								nmg_tbl( &faces , TBL_INS , (long *)fu );
							}
						}
					}
					/* assign geometry */
					for( i=0 ; i<mesh_size ; i++ )
					{
						if( mesh[i].vp )
						{
							if( !mesh[i].vp->vg_p )
							{
								nmg_vertex_gv( mesh[i].vp , mesh[i].pt );
								nmg_tbl( &vertices , TBL_INS , (long *)mesh[i].vp );
							}
						}
					}
				}
				else if( !SKIP_LINE_SEGS )
				{
					/* just a series of line segments */
					point_t pt1,pt2;
					struct vertex *v1,*v2;
					int first=1;

					if( debug )
						rt_log( "\tjust a line segment\n" );

					v1 = (struct vertex *)NULL;
					v2 = (struct vertex *)NULL;
					while( !strncmp( line , "VERTEX" , 6 ) )
					{
						int pt_flags=0;

						group_code = Do_vertex( pt2 , &pt_flags );
						if( debug == 2 )
							rt_log( "\t( %f %f %f )\n" , V3ARGS( pt2 ) );

						if( first )
						{
							VMOVE( pt1 , pt2 );
							first = 0;
						}
						else
						{
							struct edgeuse *eu;

							eu = nmg_me( v1 , v2 , s );
							nmg_vertex_gv( eu->eumate_p->vu_p->v_p , pt2 );
							if( !eu->vu_p->v_p->vg_p )
								nmg_vertex_gv( eu->vu_p->v_p , pt1 );
							VMOVE( pt1 , pt2 );
							v1 = v2;
							v2 = (struct vertex *)NULL;
						}
						if( fgets( line , LINELEN , dxf ) == NULL )
							rt_bomb( "Unexpected EOF in input file\n" );
					}
				}
				if( !strncmp( line , "SEQEND" , 6 ) )
					done = 1;
				break;
		}
	}
	if( debug )
	{
		int i;

		if( mesh_size )
		{
			rt_log( "POLYLINE: %d by %d mesh\n" , m_count , n_count );
			for( i=0 ; i<vert_count ; i++ )
				rt_log( "\t( %f %f %f )\n" , V3ARGS( mesh[i].pt ) );
		}
	}
	if( mesh != NULL )
		rt_free( (char *)mesh , "dxf-g: mesh" );

	return( group_code );
}

int
d44 2
d53 1
a53 1
		group_code = atoi( line );
a65 2
				else if( debug )
					rt_log( "3DFACE\n" );
d94 1
a94 1
				if( debug == 2 )
d108 1
a108 1
							if( debug == 2 )
d121 1
a121 1
					if( debug == 2 )
d127 1
a127 1
					if( debug == 2 )
a145 2
							if( debug == 2 )
								rt_log( "\tRe-using existing vertex at ( %f %f %f )\n" , V3ARGS( vp[i]->vg_p->coord ) );
a206 1
	dxf_name = std_in_name;
d212 1
a212 1
	while ((c = getopt(argc, argv, "nd:lpt:i:o:")) != EOF)
d223 1
a223 1
				debug = atoi( optarg );
d256 1
a256 1
	if( dxf == NULL || do_layers && dxf == stdin )
d339 1
a339 2
		if( do_layers )
			rewind( dxf );
a399 2
				else if( !strncmp( line , "POLYLINE" , 8 ) )
					group_code = Do_polyline();
d450 1
a450 2
		if( debug )
			rt_log( "%d polygons\n" , NMG_TBL_END( &faces ) );
@
