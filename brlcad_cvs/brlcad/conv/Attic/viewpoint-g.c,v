head	11.17;
access;
symbols
	ansi-20040405-merged:11.12.2.2
	postmerge-20040405-ansi:11.15
	premerge-20040404-ansi:11.14
	postmerge-autoconf:11.14
	autoconf-freeze:11.12.10.2
	premerge-autoconf:11.14
	ansi-20040316-freeze:11.12.2.1
	postmerge-20040315-windows:11.14
	premerge-20040315-windows:11.14
	windows-20040315-freeze:11.12.4.1
	autoconf-20031203:11.12.10.1
	autoconf-20031202:11.12
	autoconf-branch:11.12.0.10
	phong-branch:11.12.0.8
	photonmap-branch:11.12.0.6
	rel-6-1-DP:11.12
	windows-branch:11.12.0.4
	rel-6-0-2:11.10
	ansi-branch:11.12.0.2
	rel-6-0-1-branch:11.10.0.2
	hartley-6-0-post:11.11
	hartley-6-0-pre:11.10
	rel-6-0-1:11.10
	rel-6-0:11.9
	rel-5-4:11.6
	offsite-5-3-pre:11.9
	rel-5-3:11.6
	rel-5-2:11.6
	rel-5-1-branch:11.6.0.2
	rel-5-1:11.6
	rel-5-0:11.5
	rel-5-0-beta:11.4
	rel-4-5:11.4
	ctj-4-5-post:11.4
	ctj-4-5-pre:11.4
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.17
date	2004.05.24.04.16.13;	author morrison;	state dead;
branches;
next	11.16;

11.16
date	2004.05.10.15.30.42;	author erikg;	state Exp;
branches;
next	11.15;

11.15
date	2004.04.05.07.49.36;	author morrison;	state Exp;
branches;
next	11.14;

11.14
date	2004.02.02.17.39.00;	author morrison;	state Exp;
branches;
next	11.13;

11.13
date	2003.11.06.20.33.22;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	2002.08.20.17.07.22;	author jra;	state Exp;
branches
	11.12.2.1
	11.12.4.1
	11.12.10.1;
next	11.11;

11.11
date	2002.08.15.20.54.35;	author hartley;	state Exp;
branches;
next	11.10;

11.10
date	2002.05.17.12.48.56;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2000.10.19.19.19.44;	author butler;	state Exp;
branches;
next	11.8;

11.8
date	2000.08.24.03.16.20;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	2000.07.12.21.59.35;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	2000.03.29.18.07.46;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	99.06.03.21.54.21;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	97.03.05.20.02.18;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	96.10.25.15.56.26;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	96.07.12.13.20.17;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.59.46;	author mike;	state Rel4_4;
branches;
next	1.9;

1.9
date	94.11.08.16.15.13;	author jra;	state Exp;
branches;
next	1.8;

1.8
date	94.10.31.16.30.49;	author jra;	state Exp;
branches;
next	1.7;

1.7
date	94.08.11.00.06.19;	author gdurf;	state Exp;
branches;
next	1.6;

1.6
date	94.07.13.12.09.06;	author jra;	state Exp;
branches;
next	1.5;

1.5
date	94.04.15.16.29.07;	author jra;	state Exp;
branches;
next	1.4;

1.4
date	94.03.18.12.53.41;	author jra;	state Exp;
branches;
next	1.3;

1.3
date	93.12.09.12.47.30;	author jra;	state Exp;
branches;
next	1.2;

1.2
date	93.08.23.11.22.05;	author jra;	state Exp;
branches;
next	1.1;

1.1
date	93.08.20.09.35.46;	author jra;	state Exp;
branches;
next	;

11.12.2.1
date	2002.09.19.18.00.37;	author morrison;	state Exp;
branches;
next	11.12.2.2;

11.12.2.2
date	2004.03.17.21.16.01;	author morrison;	state Exp;
branches;
next	;

11.12.4.1
date	2004.03.11.23.40.32;	author morrison;	state Exp;
branches;
next	;

11.12.10.1
date	2003.12.03.16.24.03;	author erikg;	state Exp;
branches;
next	11.12.10.2;

11.12.10.2
date	2004.02.12.19.24.24;	author erikg;	state Exp;
branches;
next	;


desc
@Code to convert Viewpoint datasets to BRLCAD
@


11.17
log
@moved to src/conv/
@
text
@/*
 *	V I E W P O I N T - G
 *
 *  Converter from Viewpoint Datalabs coor/elem format
 *  to BRLCAD format.  Will assign vertex normals if they
 *  are present in the input files.  Two files are expected
 *  one containing vertex coordinates (and optional normals)
 *  and the second which lists the vertex numbers for each polygonal face.
 *
 *  Author:
 *	John R. Anderson
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1993-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <errno.h>

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "wdb.h"
#include "../librt/debug.h"

#define START_ARRAY_SIZE	64
#define ARRAY_BLOCK_SIZE	64

/* structure for storing coordinates and associated vertex pointer */
struct viewpoint_verts
{
	point_t coord;
	vect_t norm;
	struct vertex *vp;
	short has_norm;
};

#define	LINELEN	256 /* max input line length from elements file */

static char *tok_sep=" ";		/* seperator used in input files */
static char *usage="viewpoint-g [-t tol] -c coord_file_name -e elements_file_name -o output_file_name";

int
main(int argc, char **argv)
{
	register int c;
	FILE *coords,*elems;		/* input file pointers */
	struct rt_wdb *out_fp;		/* output file pointers */
	char *output_file = "viewpoint.g";
	char *base_name;		/* title and top level group name */
	char *coords_name=(char *)NULL;	/* input coordinates file name */
	char *elems_name;		/* input elements file name */
	float x,y,z,nx,ny,nz;		/* vertex and normal coords */
	char *ptr1,*ptr2;
	int name_len;
	struct bn_tol tol;
	int done=0;
	int i;
	int no_of_verts;
	int no_of_faces=0;
	char line[LINELEN];
	struct bu_ptbl vertices;	/* table of vertices for one face */
	struct bu_ptbl faces;		/* table of faces for one element */
	struct bu_ptbl names;		/* table of element names */
	struct model *m;
	struct nmgregion *r;
	struct shell *s;
	struct faceuse *fu;
	struct viewpoint_verts *verts;	/* array of structures holding coordinates and normals */
	struct wmember reg_head;

        /* XXX These need to be improved */
        tol.magic = BN_TOL_MAGIC;
        tol.dist = 0.005;
        tol.dist_sq = tol.dist * tol.dist;
        tol.perp = 1e-6;
        tol.para = 1 - tol.perp;

	coords = NULL;
	elems = NULL;

	if( argc < 2 )
		rt_bomb( usage );

	/* get command line arguments */
	while ((c = getopt(argc, argv, "t:c:e:o:")) != EOF)
	{
		switch( c )
		{
			case 't': /* tolerance */
				tol.dist = atof( optarg );
				tol.dist_sq = tol.dist * tol.dist;
				break;
			case 'c': /* input coordinates file name */
				coords_name = (char *)bu_malloc( strlen( optarg ) + 1 , "Viewpoint-g: base name" );
				strcpy( coords_name , optarg );
				if( (coords = fopen( coords_name , "r" )) == NULL )
				{
					bu_log( "Cannot open %s\n" , coords_name );
					perror( "viewpoint-g" );
					rt_bomb( "Cannot open input file" );
				}
				break;
			case 'e': /* input elements file name */
				elems_name = (char *)bu_malloc( strlen( optarg ) + 1 , "Viewpoint-g: base name" );
				strcpy( elems_name , optarg );
				if( (elems = fopen( elems_name , "r" )) == NULL )
				{
					bu_log( "Cannot open %s\n" , elems_name );
					perror( "viewpoint-g" );
					rt_bomb( "Cannot open input file" );
				}
				break;
			case 'o': /* output file name */
				output_file = optarg;
				break;
			default:
				rt_bomb( usage );
				break;
		}
	}
	if( (out_fp = wdb_fopen( output_file )) == NULL )
	{
		perror( output_file );
		bu_log( "tankill-g: Cannot open %s\n" , output_file );
		rt_bomb( "Cannot open output file\n" );
	}

	/* Must have some input */
	if( coords == NULL || elems == NULL )
		rt_bomb( usage );

	/* build a title for the BRLCAD database */
	if ( !coords_name ) {
		bu_log("%s:%d no coords_name set\n", __FILE__, __LINE__);
		bu_bomb("croak\n");
	}

	ptr1 = strrchr( coords_name , '/' );
	if( ptr1 == NULL )
		ptr1 = coords_name;
	else
		ptr1++;
	ptr2 = strchr( ptr1 , '.' );

	if( ptr2 == NULL )
		name_len = strlen( ptr1 );
	else
		name_len = ptr2 - ptr1;

	base_name = (char *)bu_malloc( name_len + 1 , "base_name" );
	strncpy( base_name , ptr1 , name_len );

	/* make title record */	
	mk_id( out_fp , base_name );

	/* count vertices */
	no_of_verts = 1;
	while( fgets( line , LINELEN , coords ) != NULL )
		no_of_verts++;

	/* allocate memory to store vertex coordinates and normal coordinates and a pointer to
	 * an NMG vertex structure */
	verts = (struct viewpoint_verts *)bu_calloc( no_of_verts , sizeof( struct viewpoint_verts ) , "viewpoint-g: vertex list" );

	/* Now read the vertices again and store them */
	rewind( coords );
	while( fgets( line , LINELEN ,  coords ) != NULL )
	{
		int number_scanned;
		number_scanned = sscanf( line , "%d,%f,%f,%f,%f,%f,%f" , &i , &x , &z , &y , &nx , &ny , &nz );
		if( number_scanned < 4 )
			break;
		if( i >= no_of_verts )
			bu_log( "vertex number too high (%d) only allowed for %d\n" , i , no_of_verts );
		VSET( verts[i].coord , x , y , z );

		if( number_scanned == 7 ) /* we get normals too!!! */
		{
			VSET( verts[i].norm , nx , ny , nz );
			verts[i].has_norm = 1;
		}
	}

	/* Let the user know that something is happening */
	fprintf( stderr , "%d vertices\n" , no_of_verts-1 );

	/* initialize tables */
	bu_ptbl_init( &vertices , 64, " &vertices ");
	bu_ptbl_init( &faces , 64, " &faces ");
	bu_ptbl_init( &names , 64, " &names ");

	while( !done )
	{
		char *name,*curr_name,*ptr;
		int eof=0;

		/* Find an element name that has not already been processed */
		curr_name = NULL;
		done = 1;
		while( fgets( line , LINELEN , elems ) != NULL )
		{
			line[strlen(line)-1] = '\0';
			name = strtok( line , tok_sep );
			if( BU_PTBL_END( &names ) == 0 )
			{
				/* this is the first element processed */
				curr_name = bu_malloc( sizeof( name ) + 1 , "viewpoint-g: component name" );
				strcpy( curr_name , name );

				/* add this name to the table */
				bu_ptbl_ins( &names , (long *)curr_name );
				done = 0;
				break;
			}
			else
			{
				int found=0;

				/* check the list to see if this name is already there */
				for( i=0 ; i<BU_PTBL_END( &names ) ; i++ )
				{
					if( !strcmp( (char *)BU_PTBL_GET( &names , i ) , name ) )
					{
						/* found it, so go back and read the next line */
						found = 1;
						break;
					}
				}
				if( !found )
				{
					/* didn't find name, so this becomes the current name */
					curr_name = bu_malloc( sizeof( name ) + 1 , "viewpoint-g: component name" );
					strcpy( curr_name , name );

					/* add it to the table */
					bu_ptbl_ins( &names , (long *)curr_name );
					done = 0;
					break;
				}
			}
		}

		/* if no current name, then we are done */
		if( curr_name == NULL )
			break;

		/* Hopefully, the user is still around */
		fprintf( stderr , "\tMaking %s\n" , curr_name );

		/* make basic nmg structures */
		m = nmg_mm();
		r = nmg_mrsv( m );
		s = BU_LIST_FIRST( shell , &r->s_hd );

		/* set all vertex pointers to NULL so that different models don't share vertices */
		for( i=0 ; i<no_of_verts ; i++ )
			verts[i].vp = (struct vertex *)NULL;

		/* read elements file and make faces */
		while( !eof )
		{
			/* loop through vertex numbers */
			while( (ptr = strtok( (char *)NULL , tok_sep ) ) != NULL )
			{
				i = atoi( ptr );
				if( i >= no_of_verts )
					bu_log( "vertex number (%d) too high in element, only allowed for %d\n" , i , no_of_verts );

				bu_ptbl_ins( &vertices , (long *)(&verts[i].vp) );
			}

			if( BU_PTBL_END( &vertices ) > 2 )
			{
				/* make face */
				fu = nmg_cmface( s , (struct vertex ***)BU_PTBL_BASEADDR( &vertices ) , BU_PTBL_END( &vertices ) );
				no_of_faces++;

				/* put faceuse in list for the current named object */
				bu_ptbl_ins( &faces , (long *)fu );

				/* restart the vertex list for the next face */
				bu_ptbl_reset( &vertices );
			}
			else
			{
				bu_log( "Skipping degenerate face\n" );
				bu_ptbl_reset( &vertices );
			}

			/* skip elements with the wrong name */
			name = NULL;
			while( name == NULL || strcmp( name , curr_name ) )
			{
				/* check for enf of file */
				if( fgets( line , LINELEN , elems ) == NULL )
				{
					eof = 1;
					break;
				}

				/* get name from input line (first item on line) */
				line[strlen(line)-1] = '\0';
				name = strtok( line ,  tok_sep );
			}
			
		}

		/* assign geometry */
		for( i=0 ; i<no_of_verts ; i++ )
		{
			if( verts[i].vp )
			{
				NMG_CK_VERTEX( verts[i].vp );
				nmg_vertex_gv( verts[i].vp , verts[i].coord );

				/* check if a vertex normal exists */
				if( verts[i].has_norm )
				{
					struct vertexuse *vu;

					/* assign this normal to all uses of this vertex */
					for( BU_LIST_FOR( vu , vertexuse , &verts[i].vp->vu_hd ) )
					{
						NMG_CK_VERTEXUSE( vu );
						nmg_vertexuse_nv( vu , verts[i].norm );
					}
				}
			}
		}

		(void)nmg_model_vertex_fuse( m , &tol );

		/* calculate plane equations for faces */
		    NMG_CK_SHELL( s );
		    fu = BU_LIST_FIRST( faceuse , &s->fu_hd );
		    while( BU_LIST_NOT_HEAD( fu , &s->fu_hd))
		    {
			struct faceuse *kill_fu=(struct faceuse *)NULL;
		    	struct faceuse *next_fu;

		        NMG_CK_FACEUSE( fu );

		    	next_fu = BU_LIST_NEXT( faceuse , &fu->l );
		        if( fu->orientation == OT_SAME )
		    	{
	    			struct loopuse *lu;
		    		struct edgeuse *eu;
	    			fastf_t area;
	    			plane_t pl;

	    			lu = BU_LIST_FIRST( loopuse , &fu->lu_hd );
		    		NMG_CK_LOOPUSE( lu );
		    		for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
		    		{
		    			NMG_CK_EDGEUSE( eu );
		    			if( eu->vu_p->v_p == eu->eumate_p->vu_p->v_p )
		    				kill_fu = fu;
		    		}
		    		if( !kill_fu )
		    		{
		    			area = nmg_loop_plane_area( lu , pl );
		    			if( area <= 0.0 )
		    			{

		    				bu_log( "ERROR: Can't get plane for face\n" );

		    				kill_fu = fu;
		    			}
		    		}
		    		if( kill_fu )
		    		{
	    				if( next_fu == kill_fu->fumate_p )
	    					next_fu = BU_LIST_NEXT( faceuse , &next_fu->l );
		    			bu_ptbl_rm( &faces , (long *)kill_fu );
	    				nmg_kfu( kill_fu );
	    			}
		    		else
		    			nmg_face_g( fu , pl );
		    	}
		    	fu = next_fu;
		    }

		if( BU_PTBL_END( &faces ) )
		{
			/* glue faces together */
			nmg_gluefaces( (struct faceuse **)BU_PTBL_BASEADDR( &faces) , BU_PTBL_END( &faces ), &tol );

			nmg_rebound( m , &tol );
			nmg_fix_normals( s , &tol );

			nmg_shell_coplanar_face_merge( s , &tol , 1 );

			nmg_rebound( m , &tol );

			/* write the nmg to the output file */
			mk_bot_from_nmg( out_fp , curr_name  , s );
		}
		else
			bu_log( "Object %s has no faces\n" , curr_name );

		/* kill the current model */
		nmg_km( m );

		/* restart the list of faces for the next object */
		bu_ptbl_reset( &faces );

		/* rewind the elements file for the next object */
		rewind( elems );
	}

	fprintf( stderr , "%d polygons\n" , no_of_faces );

	/* make a top level group with all the objects as members */
	BU_LIST_INIT( &reg_head.l );
	for( i=0 ; i<BU_PTBL_END( &names ) ; i++ )
	{
		if( mk_addmember( (char *)BU_PTBL_GET( &names , i ) , &reg_head.l , NULL, WMOP_UNION ) == WMEMBER_NULL )
		{
			bu_log( "Cannot make top level group\n" );
			exit( 1 );
		}
	}

	fprintf( stderr , "Making top level group (%s)\n" , base_name );
	if( mk_lcomb( out_fp , base_name , &reg_head , 0, (char *)0, (char *)0, (unsigned char *)0, 0 ) )
		bu_log( "viewpoint-g: Error in making top level group" );

	return 0;
}
@


11.16
log
@change conf.h to a wrapped config.h
@
text
@@


11.15
log
@merge of ansi-6-0-branch into HEAD
@
text
@d27 5
a31 1
#include "conf.h"
@


11.14
log
@update copyright to include span through 2003
@
text
@d65 1
a65 3
main( argc , argv )
int argc;
char *argv[];
@


11.13
log
@Now produces BOT's rather than NMG's
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1993 by the United States Army
@


11.12
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d420 1
a420 1
			mk_nmg( out_fp , curr_name  , m );
@


11.12.4.1
log
@sync to HEAD...
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d420 1
a420 1
			mk_bot_from_nmg( out_fp , curr_name  , s );
@


11.12.10.1
log
@updates from HEAD, part 1
@
text
@d420 1
a420 1
			mk_bot_from_nmg( out_fp , curr_name  , s );
@


11.12.10.2
log
@merge from HEAD
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
@


11.12.2.1
log
@Initial ANSIfication
@
text
@d65 3
a67 1
main(int argc, char **argv)
@


11.12.2.2
log
@sync branch with HEAD
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d418 1
a418 1
			mk_bot_from_nmg( out_fp , curr_name  , s );
@


11.11
log
@Converted from K&R to ANSI C - RFH
@
text
@d65 3
a67 1
main(int argc, char **argv)
@


11.10
log
@added matrix parameter to mk_addmember()
@
text
@d65 1
a65 3
main( argc , argv )
int argc;
char *argv[];
@


11.9
log
@Changes to compile under RedHat 7.0
@
text
@d441 1
a441 1
		if( mk_addmember( (char *)BU_PTBL_GET( &names , i ) , &reg_head.l , WMOP_UNION ) == WMEMBER_NULL )
@


11.8
log
@
mk_addmember
@
text
@d74 1
a74 1
	char *coords_name;		/* input coordinates file name */
d157 5
@


11.7
log
@
Converted to use new version of LIBWDB
@
text
@d436 1
a436 1
		if( mk_addmember( (char *)BU_PTBL_GET( &names , i ) , &reg_head , WMOP_UNION ) == WMEMBER_NULL )
@


11.6
log
@
Removed stray RT_EXTERNs, added bn_ prefix.
@
text
@d64 1
d71 2
a72 1
	FILE *out_fp;			/* output file pointers */
a101 1
	out_fp = stdout;
d138 1
a138 6
				if( (out_fp = fopen( optarg , "w" )) == NULL )
				{
					bu_log( "Cannot open %s\n" , optarg );
					perror( "tankill-g" );
					rt_bomb( "Cannot open output file\n" );
				}
d144 6
@


11.5
log
@
sed4
@
text
@a46 2
RT_EXTERN( fastf_t nmg_loop_plane_area , (struct loopuse *lu , plane_t pl ) );

@


11.4
log
@removed include of db.h
@
text
@d79 1
a79 1
	struct rt_tol tol;
d85 3
a87 3
	struct nmg_ptbl vertices;	/* table of vertices for one face */
	struct nmg_ptbl faces;		/* table of faces for one element */
	struct nmg_ptbl names;		/* table of element names */
d96 1
a96 1
        tol.magic = RT_TOL_MAGIC;
d119 1
a119 1
				coords_name = (char *)rt_malloc( strlen( optarg ) + 1 , "Viewpoint-g: base name" );
d123 1
a123 1
					rt_log( "Cannot open %s\n" , coords_name );
d129 1
a129 1
				elems_name = (char *)rt_malloc( strlen( optarg ) + 1 , "Viewpoint-g: base name" );
d133 1
a133 1
					rt_log( "Cannot open %s\n" , elems_name );
d141 1
a141 1
					rt_log( "Cannot open %s\n" , optarg );
d169 1
a169 1
	base_name = (char *)rt_malloc( name_len + 1 , "base_name" );
d182 1
a182 1
	verts = (struct viewpoint_verts *)rt_calloc( no_of_verts , sizeof( struct viewpoint_verts ) , "viewpoint-g: vertex list" );
d193 1
a193 1
			rt_log( "vertex number too high (%d) only allowed for %d\n" , i , no_of_verts );
d207 3
a209 3
	nmg_tbl( &vertices , TBL_INIT , NULL );
	nmg_tbl( &faces , TBL_INIT , NULL );
	nmg_tbl( &names , TBL_INIT , NULL );
d223 1
a223 1
			if( NMG_TBL_END( &names ) == 0 )
d226 1
a226 1
				curr_name = rt_malloc( sizeof( name ) + 1 , "viewpoint-g: component name" );
d230 1
a230 1
				nmg_tbl( &names , TBL_INS , (long *)curr_name );
d239 1
a239 1
				for( i=0 ; i<NMG_TBL_END( &names ) ; i++ )
d241 1
a241 1
					if( !strcmp( (char *)NMG_TBL_GET( &names , i ) , name ) )
d251 1
a251 1
					curr_name = rt_malloc( sizeof( name ) + 1 , "viewpoint-g: component name" );
d255 1
a255 1
					nmg_tbl( &names , TBL_INS , (long *)curr_name );
d272 1
a272 1
		s = RT_LIST_FIRST( shell , &r->s_hd );
d286 1
a286 1
					rt_log( "vertex number (%d) too high in element, only allowed for %d\n" , i , no_of_verts );
d288 1
a288 1
				nmg_tbl( &vertices , TBL_INS , (long *)(&verts[i].vp) );
d291 1
a291 1
			if( NMG_TBL_END( &vertices ) > 2 )
d294 1
a294 1
				fu = nmg_cmface( s , (struct vertex ***)NMG_TBL_BASEADDR( &vertices ) , NMG_TBL_END( &vertices ) );
d298 1
a298 1
				nmg_tbl( &faces , TBL_INS , (long *)fu );
d301 1
a301 1
				nmg_tbl( &vertices , TBL_RST , (long *)NULL );
d305 2
a306 2
				rt_log( "Skipping degenerate face\n" );
				nmg_tbl( &vertices , TBL_RST , (long *)NULL );
d341 1
a341 1
					for( RT_LIST_FOR( vu , vertexuse , &verts[i].vp->vu_hd ) )
d354 2
a355 2
		    fu = RT_LIST_FIRST( faceuse , &s->fu_hd );
		    while( RT_LIST_NOT_HEAD( fu , &s->fu_hd))
d362 1
a362 1
		    	next_fu = RT_LIST_NEXT( faceuse , &fu->l );
d370 1
a370 1
	    			lu = RT_LIST_FIRST( loopuse , &fu->lu_hd );
d372 1
a372 1
		    		for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d384 1
a384 1
		    				rt_log( "ERROR: Can't get plane for face\n" );
d392 2
a393 2
	    					next_fu = RT_LIST_NEXT( faceuse , &next_fu->l );
		    			nmg_tbl( &faces , TBL_RM , (long *)kill_fu );
d402 1
a402 1
		if( NMG_TBL_END( &faces ) )
d405 1
a405 1
			nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ), &tol );
d418 1
a418 1
			rt_log( "Object %s has no faces\n" , curr_name );
d424 1
a424 1
		nmg_tbl( &faces , TBL_RST , (long *)NULL );
d433 2
a434 2
	RT_LIST_INIT( &reg_head.l );
	for( i=0 ; i<NMG_TBL_END( &names ) ; i++ )
d436 1
a436 1
		if( mk_addmember( (char *)NMG_TBL_GET( &names , i ) , &reg_head , WMOP_UNION ) == WMEMBER_NULL )
d438 1
a438 1
			rt_log( "Cannot make top level group\n" );
d445 1
a445 1
		rt_log( "viewpoint-g: Error in making top level group" );
@


11.3
log
@Mod to include tolerance arg to nmg_gluefaces().
@
text
@a38 1
#include "db.h"
@


11.2
log
@Minor MOds for IRIX 6.2
@
text
@d406 1
a406 1
			nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ) );
@


11.1
log
@Release_4.4
@
text
@d403 4
a406 2
		/* glue faces together */
		nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ) );
d408 2
a409 2
		nmg_rebound( m , &tol );
		nmg_fix_normals( s , &tol );
d411 1
a411 4
		/* restart the list of faces for the next object */
		nmg_tbl( &faces , TBL_RST , (long *)NULL );

		nmg_shell_coplanar_face_merge( s , &tol , 1 );
d413 1
a413 1
		nmg_rebound( m , &tol );
d415 5
a419 2
		/* write the nmg to the output file */
		mk_nmg( out_fp , curr_name  , m );
d423 3
@


1.9
log
@Mods for Irix 6.0
@
text
@@


1.8
log
@Modified to kill degenerate faces and to call nmg_fix_normals.
@
text
@d82 1
a82 1
	int i,j;
d94 1
a94 1
	struct wmember reg_head,*wmem;
d432 1
a432 1
		if( (wmem = mk_addmember( (char *)NMG_TBL_GET( &names , i ) , &reg_head , WMOP_UNION ) ) == WMEMBER_NULL )
@


1.7
log
@Factored ifdefs
@
text
@d82 1
a82 1
	int i;
d287 1
a287 1
					rt_log( "vertex number too high in element (%d) only allowed for %d\n" , i , no_of_verts );
a288 1
				/* put vertex pointer in list for this face */
d292 1
a292 1
			if( NMG_TBL_END( &vertices ) )
d302 1
a302 1
				nmg_tbl( &vertices , TBL_RST , NULL );
d304 5
d351 2
d358 1
d367 1
d372 12
a383 4
	    			area = nmg_loop_plane_area( lu , pl );
	    			if( area <= 0.0 )
	    			{
	    				struct faceuse *kill_fu;
d385 1
a385 1
	    				rt_log( "ERROR: Can't get plane for face\n" );
d387 5
a391 1
	    				kill_fu = fu;
d394 1
d397 2
a398 2

	    			nmg_face_g( fu , pl );
d406 3
d410 1
a410 1
		nmg_tbl( &faces , TBL_RST , NULL );
d414 2
d440 1
a440 1
	if( mk_lcomb( out_fp , base_name , &reg_head , 0, (char *)0, (char *)0, (char *)0, 0 ) )
@


1.6
log
@Moved arg declarations out of routine definition.
@
text
@d27 2
d31 1
d33 5
a49 2
extern int errno;

d417 1
@


1.5
log
@Removed uneccessary loop on shells
@
text
@d61 3
a63 1
main( int argc , char *argv[] )
@


1.4
log
@Converted to use nmg_loop_plane_area
@
text
@d90 1
a90 1
        tol.dist = 0.01;
a339 2
		for (RT_LIST_FOR(s, shell, &r->s_hd))
		{
d351 3
a353 5
		                if( nmg_fu_planeeqn( fu , &tol ) )
		    		{
		    			struct loopuse *lu;
		    			fastf_t area;
		    			plane_t pl;
d355 5
a359 5
		    			lu = RT_LIST_FIRST( loopuse , &fu->lu_hd );
		    			area = nmg_loop_plane_area( lu , pl );
		    			if( area <= 0.0 )
		    			{
		    				struct faceuse *kill_fu;
d361 1
a361 1
		    				rt_log( "ERROR: Can't get plane for face\n" );
d363 5
a367 5
		    				kill_fu = fu;
		    				if( next_fu == kill_fu->fumate_p )
		    					next_fu = RT_LIST_NEXT( faceuse , &next_fu->l );
		    				nmg_kfu( kill_fu );
		    			}
d369 1
a369 2
		    			nmg_face_g( fu , pl );
		    		}
a372 1
		}
d379 2
@


1.3
log
@modification to capture vertex normals if they are in the input file
@
text
@d40 2
d90 1
a90 1
        tol.dist = 0.0005;
d343 2
a344 1
		    for (RT_LIST_FOR(fu, faceuse, &s->fu_hd))
d346 2
d349 2
d352 1
d354 23
a376 1
		                        rt_log( "Failed to calculate plane eqn\n" );
@


1.2
log
@Modified to build seperate elements based on names in elements file
@
text
@d1 26
d49 1
d51 1
d56 2
a57 4
static char *tok_sep=" ";
static char *coords_suffix=".coor.txt";
static char *elems_suffix=".elem.txt";
static char *usage="viewpoint-g input_file_base output_file_name";
d62 8
a69 3
	FILE *coords,*elems;
	FILE *out_fp;
	char *base_name,*coords_name,*elems_name;
a70 1
	float x,y,z;
d76 3
a78 3
	struct nmg_ptbl vertices;
	struct nmg_ptbl faces;
	struct nmg_ptbl names;
d83 1
a83 1
	struct viewpoint_verts *verts;
a84 1
	float tmp;
d101 1
a101 1
	while ((c = getopt(argc, argv, "t:i:o:")) != EOF)
d109 2
a110 4
			case 'i': /* input file name */
				base_name = (char *)rt_malloc( strlen( optarg ) + 1 , "Viewpoint-g: base name" );
				strcpy( base_name , optarg );
				coords_name = (char *)rt_malloc( strlen( optarg ) + strlen( coords_suffix ) + 1 , "viewpoint-g: coord file name" );
a111 1
				strcat( coords_name , coords_suffix );
d118 3
a120 1
				elems_name = (char *)rt_malloc( strlen( optarg ) + strlen( elems_suffix ) + 1 , "viewpoint-g: coord file name" );
a121 1
				strcat( elems_name , elems_suffix );
d143 1
d147 17
d168 1
a168 1
	while( fscanf( coords , "%d,%f,%f,%f" , &i , &tmp , &tmp , &tmp ) != EOF )
d171 2
d174 2
d177 1
a177 1
	while( fscanf( coords , "%d,%f,%f,%f" , &i , &x , &z , &y ) != EOF )
d179 4
d185 7
a191 1
		VSET( verts[i].coord , (-x) , y , z );
d194 1
d197 1
d219 2
d244 2
d257 1
d272 1
a272 1
			/* loop through vertx numbers */
d283 5
a287 3
			/* make face */
			fu = nmg_cmface( s , (struct vertex ***)NMG_TBL_BASEADDR( &vertices ) , NMG_TBL_END( &vertices ) );
			no_of_faces++;
d289 2
a290 2
			/* put faceuse in list for the current named object */
			nmg_tbl( &faces , TBL_INS , (long *)fu );
d292 3
a294 2
			/* restart the vertex list for the next face */
			nmg_tbl( &vertices , TBL_RST , NULL );
d318 2
d321 14
d371 1
d377 1
@


1.1
log
@Initial revision
@
text
@d19 1
a25 7
struct components
{
	char *name;
	int no_of_solids;
	struct comp_idents *next;
} *comp_root;

d38 1
a38 1
	char *coords_name,*elems_name;
a39 1
	int polysolids=0;
d41 1
d44 1
a44 1
	char tmp_name[80];
d48 1
d54 1
d72 1
a72 1
	while ((c = getopt(argc, argv, "pt:i:o:")) != EOF)
a75 3
			case 'p': /* choose polysolid output */
				polysolids = 1;
				break;
d81 2
d116 2
a117 1
	mk_id( out_fp , "test" );
d119 2
a125 4
	if( i+1 != no_of_verts )
		rt_log( "screwy vertex numbers!!!\n" );

	
a132 1
		verts[i].vp = (struct vertex *)NULL;
d135 1
a135 3
	m = nmg_mm();
	r = nmg_mrsv( m );
	s = RT_LIST_FIRST( shell , &r->s_hd );
d139 3
a141 2
	/* read elements file and make faces */
	while( fgets( line , LINELEN , elems ) != NULL )
d143 2
a144 1
		char *name,*ptr;
d146 19
a164 1
		line[strlen(line)-1] = '\0';
d166 39
a204 2
		name = strtok( line ,  tok_sep );
		while( (ptr = strtok( (char *)NULL , tok_sep ) ) != NULL )
d206 37
a242 4
			i = atoi( ptr );
			if( i >= no_of_verts )
				rt_log( "vertex number too high in element (%d) only allowed for %d\n" , i , no_of_verts );
			nmg_tbl( &vertices , TBL_INS , (long *)(&verts[i].vp) );
d245 6
a250 4
		fu = nmg_cmface( s , (struct vertex ***)NMG_TBL_BASEADDR( &vertices ) , NMG_TBL_END( &vertices ) );
		nmg_tbl( &faces , TBL_INS , (long *)fu );
		nmg_tbl( &vertices , TBL_RST , NULL );
	}
d252 12
a263 6
	/* assign geometry */
	for( i=0 ; i<no_of_verts ; i++ )
	{
		if( verts[i].vp )
			nmg_vertex_gv( verts[i].vp , verts[i].coord );
	}
d265 14
a278 11
	/* calculate plane equations for faces */
	for (RT_LIST_FOR(s, shell, &r->s_hd))
	{
	    NMG_CK_SHELL( s );
	    for (RT_LIST_FOR(fu, faceuse, &s->fu_hd))
	    {
	        NMG_CK_FACEUSE( fu );
	        if( fu->orientation == OT_SAME )
	                if( nmg_fu_planeeqn( fu , &tol ) )
	                        rt_log( "Failed to calculate plane eqn\n" );
	    }
d281 1
d283 8
a290 1
	nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ) );
d292 3
a294 2
	nmg_tbl( &faces , TBL_FREE , NULL );
	nmg_tbl( &vertices , TBL_FREE , NULL );
a295 1
	mk_nmg( out_fp , "test" , m );
@
