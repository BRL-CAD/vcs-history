head	1.26;
access;
symbols
	ansi-20040405-merged:1.21.2.2
	postmerge-20040405-ansi:1.24
	premerge-20040404-ansi:1.23
	postmerge-autoconf:1.23
	autoconf-freeze:1.21.10.3
	premerge-autoconf:1.23
	ansi-20040316-freeze:1.21.2.1
	postmerge-20040315-windows:1.23
	premerge-20040315-windows:1.22
	windows-20040315-freeze:1.21.4.2
	autoconf-20031203:1.21
	autoconf-20031202:1.21
	autoconf-branch:1.21.0.10
	phong-branch:1.21.0.8
	photonmap-branch:1.21.0.6
	rel-6-1-DP:1.21
	windows-branch:1.21.0.4
	rel-6-0-2:1.19
	ansi-branch:1.21.0.2
	rel-6-0-1-branch:1.19.0.2
	hartley-6-0-post:1.20
	hartley-6-0-pre:1.19
	rel-6-0-1:1.19
	rel-6-0:1.19
	rel-5-4:1.12
	offsite-5-3-pre:1.16
	rel-5-3:1.12
	rel-5-2:1.12
	rel-5-1-branch:1.12.0.2
	rel-5-1:1.12
	rel-5-0:1.8
	rel-5-0-beta:1.6
	rel-4-5:1.2
	ctj-4-5-post:1.2
	ctj-4-5-pre:1.2;
locks; strict;
comment	@ * @;


1.26
date	2004.05.24.04.16.12;	author morrison;	state dead;
branches;
next	1.25;

1.25
date	2004.05.10.15.30.41;	author erikg;	state Exp;
branches;
next	1.24;

1.24
date	2004.04.05.07.49.36;	author morrison;	state Exp;
branches;
next	1.23;

1.23
date	2004.03.16.13.54.29;	author morrison;	state Exp;
branches;
next	1.22;

1.22
date	2004.02.02.17.39.00;	author morrison;	state Exp;
branches;
next	1.21;

1.21
date	2002.08.20.17.07.21;	author jra;	state Exp;
branches
	1.21.2.1
	1.21.4.1
	1.21.10.1;
next	1.20;

1.20
date	2002.08.15.20.54.34;	author hartley;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.10.21.22.53;	author butler;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.17.20.03.14;	author morrison;	state Exp;
branches;
next	1.17;

1.17
date	2001.04.05.19.34.59;	author morrison;	state Exp;
branches;
next	1.16;

1.16
date	2000.09.08.05.55.42;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	2000.08.24.03.28.30;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	2000.07.21.12.44.34;	author jra;	state Exp;
branches;
next	1.13;

1.13
date	2000.07.10.23.53.58;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	2000.03.29.18.07.45;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.04.17.58.19;	author bparker;	state Exp;
branches;
next	1.10;

1.10
date	99.12.30.18.50.50;	author jra;	state Exp;
branches;
next	1.9;

1.9
date	99.12.29.23.23.01;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	99.06.03.21.54.20;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	99.06.03.13.43.17;	author jra;	state Exp;
branches;
next	1.6;

1.6
date	98.11.19.18.50.09;	author jra;	state Exp;
branches;
next	1.5;

1.5
date	98.10.26.03.45.41;	author jra;	state Exp;
branches;
next	1.4;

1.4
date	98.10.14.13.29.33;	author jra;	state Exp;
branches;
next	1.3;

1.3
date	98.09.14.15.58.50;	author bparker;	state Exp;
branches;
next	1.2;

1.2
date	97.06.11.21.01.25;	author jra;	state Exp;
branches;
next	1.1;

1.1
date	97.06.11.20.21.48;	author jra;	state Exp;
branches;
next	;

1.21.2.1
date	2002.09.19.18.00.36;	author morrison;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2004.03.17.21.16.00;	author morrison;	state Exp;
branches;
next	;

1.21.4.1
date	2002.09.26.23.03.43;	author morrison;	state Exp;
branches;
next	1.21.4.2;

1.21.4.2
date	2004.03.11.23.40.31;	author morrison;	state Exp;
branches;
next	;

1.21.10.1
date	2004.02.12.19.24.23;	author erikg;	state Exp;
branches;
next	1.21.10.2;

1.21.10.2
date	2004.03.15.14.06.08;	author erikg;	state Exp;
branches;
next	1.21.10.3;

1.21.10.3
date	2004.03.18.18.10.24;	author erikg;	state Exp;
branches;
next	;


desc
@BRL-CAD to Wavefront (OBJ) converter.
@


1.26
log
@moved to src/conv/
@
text
@/*
 *			G - W A V E . C
 *
 *  Program to convert a BRL-CAD model (in a .g file) to a Wavefront '.obj' file
 *  by calling on the NMG booleans.
 *
 *  Authors -
 *	John R. Anderson
 *	Bill Mermagen Jr.
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1996-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/conv/g-wave.c,v 1.25 2004/05/10 15:30:41 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "../librt/debug.h"
#define V3ARGSIN(a)       (a)[X]/25.4, (a)[Y]/25.4, (a)[Z]/25.4

#ifdef WIN32
#include <fcntl.h>
#endif


BU_EXTERN(union tree *do_region_end, (struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data));

extern double nmg_eue_dist;		/* from nmg_plot.c */

static char	usage[] = "\
Usage: %s [-m][-v][-i][-u][-xX lvl][-a abs_tess_tol][-r rel_tess_tol][-n norm_tess_tol]\n\
[-e error_file ][-D dist_calc_tol] -o output_file_name brlcad_db.g object(s)\n";

static long	vert_offset=0;
static long	norm_offset=0;
static int	do_normals=0;
static int	NMG_debug;	/* saved arg of -X, for longjmp handling */
static int	verbose;
static int	usemtl=0;	/* flag to include 'usemtl' statements with a code for GIFT materials:
				 * 	usemtl 0_100_32
				 *		means aircode is 0
				 *		      los is 100
				 *		      GIFT material is 32
				 */
static int	ncpu = 1;	/* Number of processors */
static char	*output_file = NULL;	/* output filename */
static char	*error_file = NULL;	/* error filename */
static FILE	*fp;		/* Output file pointer */
static FILE	*fpe;		/* Error file pointer */
static struct db_i		*dbip;
static struct rt_tess_tol	ttol;
static struct bn_tol		tol;
static struct model		*the_model;

static struct db_tree_state	tree_state;	/* includes tol & model */

static int	regions_tried = 0;
static int	regions_converted = 0;
static int	regions_written = 0;
static int	inches = 0;

/*
 *			M A I N
 */
int
main(int argc, char **argv)
{
	register int	c;
	double		percent;

#ifdef WIN32
	_fmode = _O_BINARY;
#endif

#ifdef BSD
	setlinebuf( stderr );
#else
#	if defined( SYSV ) && !defined( sgi ) && !defined(CRAY2) && \
	 !defined(n16)
		(void) setvbuf( stderr, (char *) NULL, _IOLBF, BUFSIZ );
#	endif
#	if defined(sgi) && defined(mips)
		if( setlinebuf( stderr ) != 0 )
			perror("setlinebuf(stderr)");
#	endif
#endif

#if MEMORY_LEAK_CHECKING
	rt_g.debug |= DEBUG_MEM_FULL;
#endif
	tree_state = rt_initial_tree_state;	/* struct copy */
	tree_state.ts_tol = &tol;
	tree_state.ts_ttol = &ttol;
	tree_state.ts_m = &the_model;

	ttol.magic = RT_TESS_TOL_MAGIC;
	/* Defaults, updated by command line options. */
	ttol.abs = 0.0;
	ttol.rel = 0.01;
	ttol.norm = 0.0;

	/* XXX These need to be improved */
	tol.magic = BN_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-5;
	tol.para = 1 - tol.perp;

	rt_init_resource( &rt_uniresource, 0, NULL );

	the_model = nmg_mm();
	BU_LIST_INIT( &rt_g.rtg_vlfree );	/* for vlist macros */

	/* Get command line arguments. */
	while ((c = getopt(argc, argv, "mua:n:o:r:vx:D:P:X:e:i:")) != EOF) {
		switch (c) {
		case 'm':		/* include 'usemtl' statements */
			usemtl = 1;
			break;
		case 'u':		/* Include vertexuse normals */
			do_normals = 1;
			break;
		case 'a':		/* Absolute tolerance. */
			ttol.abs = atof(optarg);
			ttol.rel = 0.0;
			break;
		case 'n':		/* Surface normal tolerance. */
			ttol.norm = atof(optarg);
			ttol.rel = 0.0;
			break;
		case 'o':		/* Output file name. */
			output_file = optarg;
			break;
		case 'r':		/* Relative tolerance. */
			ttol.rel = atof(optarg);
			break;
		case 'v':
			verbose++;
			break;
		case 'P':
			ncpu = atoi( optarg );
			rt_g.debug = 1;	/* XXX DEBUG_ALLRAYS -- to get core dumps */
			break;
		case 'x':
			sscanf( optarg, "%x", (unsigned int *)&rt_g.debug );
			break;
		case 'D':
			tol.dist = atof(optarg);
			tol.dist_sq = tol.dist * tol.dist;
			rt_pr_tol( &tol );
			break;
		case 'X':
			sscanf( optarg, "%x", (unsigned int *)&rt_g.NMG_debug );
			NMG_debug = rt_g.NMG_debug;
			break;
		case 'e':		/* Error file name. */
			error_file = optarg;
			break;
		case 'i':
			inches = 1;
			break;
		default:
			bu_log(  usage, argv[0]);
			exit(1);
			break;
		}
	}

	if (optind+1 >= argc) {
		bu_log( usage, argv[0]);
		exit(1);
	}

	if( !output_file )
		fp = stdout;
	else
	{
		/* Open output file */
		if( (fp=fopen( output_file, "w+" )) == NULL )
		{
			bu_log( "Cannot open output file (%s) for writing\n", output_file );
			perror( argv[0] );
			exit( 1 );
		}
	}

	/* Open g-wave error log file */
	if( !error_file)
		fpe = stderr;
	else
	if( (fpe=fopen( error_file, "w" )) == NULL )
	{
	bu_log( "Cannot open output file (%s) for writing\n", error_file );
		perror( argv[0] );
		exit( 1 );
	}

	/* Open brl-cad database */
	argc -= optind;
	argv += optind;
	if ((dbip = db_open(argv[0], "r")) == DBI_NULL) {
		perror(argv[0]);
		exit(1);
	}
	db_dirbuild( dbip );

	BN_CK_TOL(tree_state.ts_tol);
	RT_CK_TESS_TOL(tree_state.ts_ttol);

/* Write out  header */
	if (inches)
		fprintf(fp,"# BRL-CAD generated Wavefront OBJ file (Units in)\n");
	else
		fprintf(fp,"# BRL-CAD generated Wavefront OBJ file (Units mm)\n");

	fprintf( fp, "# BRL-CAD model: %s\n# BRL_CAD objects:", argv[0] );

	for( c=1 ; c<argc ; c++ )
		fprintf( fp, " %s", argv[c] );
	fprintf( fp, "\n" );

	/* Walk indicated tree(s).  Each region will be output separately */
	(void) db_walk_tree(dbip, argc-1, (const char **)(argv+1),
		1,			/* ncpu */
		&tree_state,
		0,			/* take all regions */
		do_region_end,
		nmg_booltree_leaf_tess,
		(genptr_t)NULL);	/* in librt/nmg_bool.c */

	percent = 0;
	if(regions_tried>0){
		percent = ((double)regions_converted * 100) / regions_tried;
		printf("Tried %d regions, %d converted to NMG's successfully.  %g%%\n",
			regions_tried, regions_converted, percent);
	}
	percent = 0;

	if( regions_tried > 0 ){
		percent = ((double)regions_written * 100) / regions_tried;
		printf( "                  %d triangulated successfully. %g%%\n",
			regions_written, percent );
	}
	fclose(fp);

	/* Release dynamic storage */
	nmg_km(the_model);
	rt_vlist_cleanup();
	db_close(dbip);

#if MEMORY_LEAK_CHECKING
	bu_prmem("After complete G-ACAD conversion");
#endif

	return 0;
}

static void
nmg_to_wave(struct nmgregion *r, struct db_full_path *pathp, int region_id, int aircode, int los, int material_id)
{
	struct model *m;
	struct shell *s;
	struct vertex *v;
	struct bu_ptbl verts;
	struct bu_ptbl norms;
	char *region_name;
	int numverts = 0;		/* Number of vertices to output */
	int numtri   = 0;		/* Number of triangles to output */
	int i;

	NMG_CK_REGION( r );
	RT_CK_FULL_PATH(pathp);

	region_name = db_path_to_string( pathp );

#if 0
	printf("Attempting to process region %s\n",region_name);
	fflush(stdout);
#endif

	m = r->m_p;
	NMG_CK_MODEL( m );

	/* triangulate model */
	nmg_triangulate_model( m, &tol );

	/* list all vertices in result */
	nmg_vertex_tabulate( &verts, &r->l.magic );

	/* Get number of vertices */
	numverts = BU_PTBL_END (&verts);

	/* get list of vertexuse normals */
	if( do_normals )
		nmg_vertexuse_normal_tabulate( &norms, &r->l.magic );

/* XXX Check vertices, shells faces first? Do not want to punt mid-stream */
/* BEGIN CHECK SECTION */
/* Check vertices */

	for( i=0 ; i<numverts ; i++ )
	{
		v = (struct vertex *)BU_PTBL_GET( &verts, i );
		NMG_CK_VERTEX( v );
	}

/* Check triangles */
 	for( BU_LIST_FOR( s, shell, &r->s_hd ) )
	{
		struct faceuse *fu;

		NMG_CK_SHELL( s );

		for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
		{
			struct loopuse *lu;

			NMG_CK_FACEUSE( fu );

			if( fu->orientation != OT_SAME )
				continue;

			for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
			{
				struct edgeuse *eu;
				int vert_count=0;

				NMG_CK_LOOPUSE( lu );

				if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
					continue;

				/* check vertex numbers for each triangle */
				for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
				{
					NMG_CK_EDGEUSE( eu );

					v = eu->vu_p->v_p;
					NMG_CK_VERTEX( v );

					vert_count++;
					i = bu_ptbl_locate( &verts, (long *)v );
					if( i < 0 )
					{
		/*XXX*/				bu_ptbl_free( &verts);
		/*XXX*/				bu_free( region_name, "region name" );
						bu_log( "Vertex from eu x%x is not in nmgregion x%x\n", eu, r );
						rt_bomb( "Can't find vertex in list!!!" );
					}
				}
				if( vert_count > 3 )
				{
		/*XXX*/			bu_ptbl_free( &verts);
		/*XXX*/			bu_free( region_name, "region name" );
					bu_log( "lu x%x has %d vertices!!!!\n", lu, vert_count );
					rt_bomb( "LU is not a triangle" );
				}
				else if( vert_count < 3 )
					continue;
				numtri++;
			}
		}
	}

/* END CHECK SECTION */
/* Write pertinent info for this region */

	if( usemtl )
		fprintf( fp, "usemtl %d_%d_%d\n", aircode, los, material_id );

	fprintf( fp, "g %s", pathp->fp_names[0]->d_namep );
	for( i=1 ; i<pathp->fp_len ; i++ )
		fprintf( fp, "/%s", pathp->fp_names[i]->d_namep );
	fprintf( fp, "\n" );

	/* Write vertices */
	for( i=0 ; i<numverts ; i++ )
	{
		v = (struct vertex *)BU_PTBL_GET( &verts, i );
		NMG_CK_VERTEX( v );
		if (inches)
			fprintf( fp, "v %f %f %f\n", V3ARGSIN( v->vg_p->coord ));
		else
			fprintf( fp, "v %f %f %f\n", V3ARGS( v->vg_p->coord ));
	}

	/* Write vertexuse normals */
	if( do_normals )
	{
		for( i=0 ; i<BU_PTBL_END( &norms ) ; i++ )
		{
			struct vertexuse_a_plane *va;

			va = (struct vertexuse_a_plane *)BU_PTBL_GET( &norms, i );
			NMG_CK_VERTEXUSE_A_PLANE( va );
			if (inches)
				fprintf( fp, "vn %f %f %f\n", V3ARGSIN( va->N ));
			else
				fprintf( fp, "vn %f %f %f\n", V3ARGS( va->N ));
		}
	}

	/* output triangles */
 	for( BU_LIST_FOR( s, shell, &r->s_hd ) )
	{
		struct faceuse *fu;

		NMG_CK_SHELL( s );

		for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
		{
			struct loopuse *lu;

			NMG_CK_FACEUSE( fu );

			if( fu->orientation != OT_SAME )
				continue;

			for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
			{
				struct edgeuse *eu;
				int vert_count=0;
				int use_normals=1;

				NMG_CK_LOOPUSE( lu );

				if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
					continue;

				/* Each vertexuse of the face must have a normal in order
				 * to use the normals in Wavefront
				 */
				if( do_normals )
				{
					for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
					{
						NMG_CK_EDGEUSE( eu );

						if( !eu->vu_p->a.magic_p )
						{
							use_normals = 0;
							break;
						}

						if( *eu->vu_p->a.magic_p != NMG_VERTEXUSE_A_PLANE_MAGIC )
						{
							use_normals = 0;
							break;
						}
					}
				}
				else
					use_normals = 0;

				fprintf( fp, "f" );

				/* list vertex numbers for each triangle */
				for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
				{
					NMG_CK_EDGEUSE( eu );

					v = eu->vu_p->v_p;
					NMG_CK_VERTEX( v );

					vert_count++;
					i = bu_ptbl_locate( &verts, (long *)v );
					if( i < 0 )
					{
						bu_ptbl_free( &verts);
						bu_log( "Vertex from eu x%x is not in nmgregion x%x\n", eu, r );
		/*XXX*/				bu_free( region_name, "region name" );
		/*XXX*/				rt_bomb( "Can't find vertex in list!!!" );
					}

					if( use_normals )
					{
						int j;

						j = bu_ptbl_locate( &norms, (long *)eu->vu_p->a.magic_p );
						fprintf( fp, " %ld//%ld", i+1+vert_offset, j+1+norm_offset );
					}
					else
						fprintf( fp, " %ld", i+1+vert_offset );
				}

				fprintf( fp, "\n" );

				if( vert_count > 3 )
				{
					bu_ptbl_free( &verts);
					bu_free( region_name, "region name" );
					bu_log( "lu x%x has %d vertices!!!!\n", lu, vert_count );
					rt_bomb( "LU is not a triangle" );
				}
			}
		}
	}
/*	regions_converted++;  
	printf("Processed region %s\n",region_name);
	printf("Regions attempted = %d Regions done = %d\n",regions_tried,regions_converted);
	fflush(stdout);
*/
	vert_offset += numverts;
	bu_ptbl_free( &verts);
	if( do_normals )
	{
		norm_offset += BU_PTBL_END( &norms );
		bu_ptbl_free( &norms);
	}
	bu_free( region_name, "region name" );
}

/*
*			D O _ R E G I O N _ E N D
*
*  Called from db_walk_tree().
*
*  This routine must be prepared to run in parallel.
*/
union tree *do_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
{
	union tree		*ret_tree;
	struct bu_list		vhead;
	struct nmgregion	*r;

	RT_CK_FULL_PATH(pathp);
	RT_CK_TREE(curtree);
	RT_CK_TESS_TOL(tsp->ts_ttol);
	BN_CK_TOL(tsp->ts_tol);
	NMG_CK_MODEL(*tsp->ts_m);

	BU_LIST_INIT(&vhead);

	if (RT_G_DEBUG&DEBUG_TREEWALK || verbose) {
		char	*sofar = db_path_to_string(pathp);
		bu_log("\ndo_region_end(%d %d%%) %s\n",
			regions_tried,
			regions_tried>0 ? (regions_converted * 100) / regions_tried : 0,
			sofar);
		bu_free(sofar, "path string");
	}

	if (curtree->tr_op == OP_NOP)
		return  curtree;

	regions_tried++;
	/* Begin rt_bomb() protection */
	if( ncpu == 1 ) {
		if( BU_SETJUMP )  {
			/* Error, bail out */
			char *sofar;
			BU_UNSETJUMP;		/* Relinquish the protection */
			
			sofar = db_path_to_string(pathp);
	                bu_log( "FAILED in Boolean evaluation: %s\n", sofar );
			fprintf(fpe,"Failed Bool. Eval.: %s\n",sofar);
			fflush(fpe);
                        bu_free( (char *)sofar, "sofar" );
                                
			/* Sometimes the NMG library adds debugging bits when
			 * it detects an internal error, before rt_bomb().
			 */
			rt_g.NMG_debug = NMG_debug;	/* restore mode */

			/* Release any intersector 2d tables */
			nmg_isect2d_final_cleanup();

			/* Release the tree memory & input regions */
/*XXX*/			/* db_free_tree(curtree);*/		/* Does an nmg_kr() */

			/* Get rid of (m)any other intermediate structures */
			if( (*tsp->ts_m)->magic == NMG_MODEL_MAGIC )  {
				nmg_km(*tsp->ts_m);
			} else {
				bu_log("WARNING: tsp->ts_m pointer corrupted, ignoring it.\n");
			}

			/* Now, make a new, clean model structure for next pass. */
			*tsp->ts_m = nmg_mm();
			goto out;
		}
	}
	ret_tree = nmg_booltree_evaluate( curtree, tsp->ts_tol, &rt_uniresource );	/* librt/nmg_bool.c */

	if( ret_tree )
		r = ret_tree->tr_d.td_r;
	else
		r = (struct nmgregion *)NULL;
/*	regions_done++;  XXX */
	
	BU_UNSETJUMP;		/* Relinquish the protection */
	regions_converted++;

	if (r != 0)
	{
		struct shell *s;
		int empty_region=0;
		int empty_model=0;

		/* Kill cracks */
		s = BU_LIST_FIRST( shell, &r->s_hd );
		while( BU_LIST_NOT_HEAD( &s->l, &r->s_hd ) )
		{
			struct shell *next_s;

			next_s = BU_LIST_PNEXT( shell, &s->l );
			if( nmg_kill_cracks( s ) )
			{
				if( nmg_ks( s ) )
				{
					empty_region = 1;
					break;
				}
			}
			s = next_s;
		}

		/* kill zero length edgeuses */
		if( !empty_region )
		{
			 empty_model = nmg_kill_zero_length_edgeuses( *tsp->ts_m );
		}

		if( !empty_region && !empty_model )
		{
			if( BU_SETJUMP )
			{
				char *sofar;

				BU_UNSETJUMP;

				sofar = db_path_to_string(pathp);
				bu_log( "FAILED in triangulator: %s\n", sofar );
				fprintf(fpe,"Failed in triangulator: %s\n",sofar);
				fflush(fpe);
				bu_free( (char *)sofar, "sofar" );

				/* Sometimes the NMG library adds debugging bits when
				 * it detects an internal error, before rt_bomb().
				 */
				rt_g.NMG_debug = NMG_debug;	/* restore mode */

				/* Release any intersector 2d tables */
				nmg_isect2d_final_cleanup();

				/* Get rid of (m)any other intermediate structures */
				if( (*tsp->ts_m)->magic == NMG_MODEL_MAGIC )
				{
					nmg_km(*tsp->ts_m);
				}
				else
				{
					bu_log("WARNING: tsp->ts_m pointer corrupted, ignoring it.\n");
				}
			
				/* Now, make a new, clean model structure for next pass. */
				*tsp->ts_m = nmg_mm();
				goto out;
			}
		/* Write the region to the TANKILL file */
			nmg_to_wave( r, pathp, tsp->ts_regionid, tsp->ts_aircode, tsp->ts_los, tsp->ts_gmater );

			regions_written++;

			BU_UNSETJUMP;
		}

		if( !empty_model )
			nmg_kr( r );
	}

out:
	/*
	 *  Dispose of original tree, so that all associated dynamic
	 *  memory is released now, not at the end of all regions.
	 *  A return of TREE_NULL from this routine signals an error,
	 *  and there is no point to adding _another_ message to our output,
	 *  so we need to cons up an OP_NOP node to return.
	 */



	db_free_tree(curtree, &rt_uniresource);		/* Does an nmg_kr() */

	if(regions_tried>0){
		float npercent;
		float tpercent;

		npercent = (float)(regions_converted * 100) / regions_tried;
		tpercent = (float)(regions_written * 100) / regions_tried;
		printf("Tried %d regions, %d conv. to NMG's %d conv. to tri. nmgper = %.2f%% triper = %.2f%% \n",
		regions_tried, regions_converted, regions_written, npercent,tpercent);
	}

	BU_GETUNION(curtree, tree);
	curtree->magic = RT_TREE_MAGIC;
	curtree->tr_op = OP_NOP;
	return(curtree);
}
@


1.25
log
@change conf.h to a wrapped config.h
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/conv/g-wave.c,v 1.24 2004/04/05 07:49:36 morrison Exp $ (BRL)";
@


1.24
log
@merge of ansi-6-0-branch into HEAD
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d29 5
a33 1
#include "conf.h"
@


1.23
log
@merge of windows-6-0-branch into head
@
text
@d92 1
a92 3
main(argc, argv)
int	argc;
char	*argv[];
d285 1
a285 7
nmg_to_wave( r, pathp, region_id, aircode, los, material_id )
struct nmgregion *r;
struct db_full_path *pathp;
int region_id;
int aircode;
int los;
int material_id;
d546 1
a546 5
union tree *do_region_end(tsp, pathp, curtree, client_data)
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
@


1.22
log
@update copyright to include span through 2003
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-wave.c,v 1.21 2002/08/20 17:07:21 jra Exp $ (BRL)";
d47 5
d98 5
@


1.21
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1996 by the United States Army
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-wave.c,v 1.19 2001/08/10 21:22:53 butler Exp $ (BRL)";
@


1.21.10.1
log
@merge from HEAD
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1996-2004 by the United States Army
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-wave.c,v 1.22 2004/02/02 17:39:00 morrison Exp $ (BRL)";
@


1.21.10.2
log
@merge from head
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-wave.c,v 1.21.10.1 2004/02/12 19:24:23 erikg Exp $ (BRL)";
@


1.21.10.3
log
@merge from head
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a46 5
#ifdef WIN32
#include <fcntl.h>
#endif


a92 5

#ifdef WIN32
	_fmode = _O_BINARY;
#endif

@


1.21.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-wave.c,v 1.21 2002/08/20 17:07:21 jra Exp $ (BRL)";
a46 5
#ifdef WIN32
#include <fcntl.h>
#endif


a92 5

#ifdef WIN32
	_fmode = _O_BINARY;
#endif

@


1.21.4.2
log
@sync to HEAD...
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1996-2004 by the United States Army
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/conv/g-wave.c,v 1.21.4.1 2002/09/26 23:03:43 morrison Exp $ (BRL)";
@


1.21.2.1
log
@Initial ANSIfication
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-wave.c,v 1.21 2002/08/20 17:07:21 jra Exp $ (BRL)";
d87 3
a89 1
main(int argc, char **argv)
d277 7
a283 1
nmg_to_wave(struct nmgregion *r, struct db_full_path *pathp, int region_id, int aircode, int los, int material_id)
d544 5
a548 1
union tree *do_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
@


1.21.2.2
log
@sync branch with HEAD
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1996-2004 by the United States Army
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a46 5
#ifdef WIN32
#include <fcntl.h>
#endif


a90 5

#ifdef WIN32
	_fmode = _O_BINARY;
#endif

@


1.20
log
@Converted from K&R to ANSI C - RFH
@
text
@d87 3
a89 1
main(int argc, char **argv)
d277 7
a283 1
nmg_to_wave(struct nmgregion *r, struct db_full_path *pathp, int region_id, int aircode, int los, int material_id)
d544 5
a548 1
union tree *do_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
@


1.19
log
@Compiler warning patches
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-wave.c,v 1.18 2001/05/17 20:03:14 morrison Exp $ (BRL)";
d87 1
a87 3
main(argc, argv)
int	argc;
char	*argv[];
d275 1
a275 7
nmg_to_wave( r, pathp, region_id, aircode, los, material_id )
struct nmgregion *r;
struct db_full_path *pathp;
int region_id;
int aircode;
int los;
int material_id;
d536 1
a536 5
union tree *do_region_end(tsp, pathp, curtree, client_data)
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
@


1.18
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-wave.c,v 1.17 2001/04/05 19:34:59 morrison Exp $ (BRL)";
d163 1
a163 1
			sscanf( optarg, "%x", &rt_g.debug );
d171 1
a171 1
			sscanf( optarg, "%x", &rt_g.NMG_debug );
@


1.17
log
@updated SIGNED to signed
updated CONST to const
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-wave.c,v 1.16 2000/09/08 05:55:42 mike Exp $ (BRL)";
d562 1
a562 1
	if (rt_g.debug&DEBUG_TREEWALK || verbose) {
@


1.16
log
@
Tree routines now need resource structure.
Added rt_init_resource() call.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-wave.c,v 1.15 2000/08/24 03:28:30 mike Exp $ (BRL)";
d241 1
a241 1
	(void) db_walk_tree(dbip, argc-1, (CONST char **)(argv+1),
@


1.15
log
@
lint
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-wave.c,v 1.14 2000/07/21 12:44:34 jra Exp $ (BRL)";
d127 2
d611 1
a611 1
	ret_tree = nmg_booltree_evaluate( curtree, tsp->ts_tol );	/* librt/nmg_bool.c */
d711 1
a711 1
	db_free_tree(curtree);		/* Does an nmg_kr() */
@


1.14
log
@Replaced db_scan() calls with db_dirbuild()
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-wave.c,v 1.13 2000/07/10 23:53:58 mike Exp $ (BRL)";
d264 1
a264 1
	bn_vlist_cleanup();
a547 1
	extern FILE		*fp_fig;
@


1.13
log
@
lint
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-wave.c,v 1.12 2000/03/29 18:07:45 mike Exp $ (BRL)";
d221 1
a221 2
	db_scan(dbip, (int (*)())db_diradd, 1, NULL);

@


1.12
log
@
Removed stray RT_EXTERNs, added bn_ prefix.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-wave.c,v 1.11 2000/01/04 17:58:19 bparker Exp $ (BRL)";
@


1.11
log
@*- add client_data to db_walk_tree
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-wave.c,v 1.10 1999/12/30 18:50:50 jra Exp $ (BRL)";
d47 1
a47 1
RT_EXTERN(union tree *do_region_end, (struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data));
@


1.10
log
@Eliminated some unused variables
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-wave.c,v 1.9 1999/12/29 23:23:01 mike Exp $ (BRL)";
d47 1
a47 1
RT_EXTERN(union tree *do_region_end, (struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree));
d245 2
a246 1
		nmg_booltree_leaf_tess);	/* in librt/nmg_bool.c */
d543 1
a543 1
union tree *do_region_end(tsp, pathp, curtree)
d547 1
@


1.9
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-wave.c,v 1.8 1999/06/03 21:54:20 mike Exp $ (BRL)";
a71 1
static struct bu_vls		base_seg;
a92 1
	char 		buf[80];
a290 1
	int tricount = 0;		/* Triangle number */
a550 1
	int			failed;
@


1.8
log
@
sed4
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-wave.c,v 1.7 1999/06/03 13:43:17 jra Exp $ (BRL)";
d223 1
a223 1
	db_scan(dbip, (int (*)())db_diradd, 1);
@


1.7
log
@Object names are output as full paths
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-wave.c,v 1.6 1998/11/19 18:50:09 jra Exp $ (BRL)";
d72 1
a72 1
static struct rt_vls		base_seg;
d74 1
a74 1
static struct rt_tol		tol;
d123 1
a123 1
	tol.magic = RT_TOL_MAGIC;
d130 1
a130 1
	RT_LIST_INIT( &rt_g.rtg_vlfree );	/* for vlist macros */
d181 1
a181 1
			rt_log(  usage, argv[0]);
d188 1
a188 1
		rt_log( usage, argv[0]);
d199 1
a199 1
			rt_log( "Cannot open output file (%s) for writing\n", output_file );
d211 1
a211 1
	rt_log( "Cannot open output file (%s) for writing\n", error_file );
d226 1
a226 1
	RT_CK_TOL(tree_state.ts_tol);
d266 1
a266 1
	rt_vlist_cleanup();
d270 1
a270 1
	rt_prmem("After complete G-ACAD conversion");
d288 2
a289 2
	struct nmg_ptbl verts;
	struct nmg_ptbl norms;
d316 1
a316 1
	numverts = NMG_TBL_END (&verts);
d328 1
a328 1
		v = (struct vertex *)NMG_TBL_GET( &verts, i );
d333 1
a333 1
 	for( RT_LIST_FOR( s, shell, &r->s_hd ) )
d339 1
a339 1
		for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )
d348 1
a348 1
			for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
d355 1
a355 1
				if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d359 1
a359 1
				for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d367 1
a367 1
					i = nmg_tbl( &verts, TBL_LOC, (long *)v );
d370 3
a372 3
		/*XXX*/				nmg_tbl( &verts, TBL_FREE, (long *)NULL );
		/*XXX*/				rt_free( region_name, "region name" );
						rt_log( "Vertex from eu x%x is not in nmgregion x%x\n", eu, r );
d378 3
a380 3
		/*XXX*/			nmg_tbl( &verts, TBL_FREE, (long *)NULL );
		/*XXX*/			rt_free( region_name, "region name" );
					rt_log( "lu x%x has %d vertices!!!!\n", lu, vert_count );
d404 1
a404 1
		v = (struct vertex *)NMG_TBL_GET( &verts, i );
d415 1
a415 1
		for( i=0 ; i<NMG_TBL_END( &norms ) ; i++ )
d419 1
a419 1
			va = (struct vertexuse_a_plane *)NMG_TBL_GET( &norms, i );
d429 1
a429 1
 	for( RT_LIST_FOR( s, shell, &r->s_hd ) )
d435 1
a435 1
		for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )
d444 1
a444 1
			for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
d452 1
a452 1
				if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d460 1
a460 1
					for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d483 1
a483 1
				for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d491 1
a491 1
					i = nmg_tbl( &verts, TBL_LOC, (long *)v );
d494 3
a496 3
						nmg_tbl( &verts, TBL_FREE, (long *)NULL );
						rt_log( "Vertex from eu x%x is not in nmgregion x%x\n", eu, r );
		/*XXX*/				rt_free( region_name, "region name" );
d504 1
a504 1
						j = nmg_tbl( &norms, TBL_LOC, (long *)eu->vu_p->a.magic_p );
d515 3
a517 3
					nmg_tbl( &verts, TBL_FREE, (long *)NULL );
					rt_free( region_name, "region name" );
					rt_log( "lu x%x has %d vertices!!!!\n", lu, vert_count );
d529 1
a529 1
	nmg_tbl( &verts, TBL_FREE, (long *)NULL );
d532 2
a533 2
		norm_offset += NMG_TBL_END( &norms );
		nmg_tbl( &norms, TBL_FREE, (long *)NULL );
d535 1
a535 1
	rt_free( region_name, "region name" );
d552 1
a552 1
	struct rt_list		vhead;
d559 1
a559 1
	RT_CK_TOL(tsp->ts_tol);
d562 1
a562 1
	RT_LIST_INIT(&vhead);
d566 1
a566 1
		rt_log("\ndo_region_end(%d %d%%) %s\n",
d570 1
a570 1
		rt_free(sofar, "path string");
d579 1
a579 1
		if( RT_SETJUMP )  {
d582 1
a582 1
			RT_UNSETJUMP;		/* Relinquish the protection */
d585 1
a585 1
	                rt_log( "FAILED in Boolean evaluation: %s\n", sofar );
d588 1
a588 1
                        rt_free( (char *)sofar, "sofar" );
d605 1
a605 1
				rt_log("WARNING: tsp->ts_m pointer corrupted, ignoring it.\n");
d621 1
a621 1
	RT_UNSETJUMP;		/* Relinquish the protection */
d631 2
a632 2
		s = RT_LIST_FIRST( shell, &r->s_hd );
		while( RT_LIST_NOT_HEAD( &s->l, &r->s_hd ) )
d636 1
a636 1
			next_s = RT_LIST_PNEXT( shell, &s->l );
d656 1
a656 1
			if( RT_SETJUMP )
d660 1
a660 1
				RT_UNSETJUMP;
d663 1
a663 1
				rt_log( "FAILED in triangulator: %s\n", sofar );
d666 1
a666 1
				rt_free( (char *)sofar, "sofar" );
d683 1
a683 1
					rt_log("WARNING: tsp->ts_m pointer corrupted, ignoring it.\n");
d695 1
a695 1
			RT_UNSETJUMP;
d725 1
a725 1
	GETUNION(curtree, tree);
@


1.6
log
@Added a '-m' option
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-wave.c,v 1.5 1998/10/26 03:45:41 jra Exp $ (BRL)";
d396 4
a399 1
	fprintf( fp, "g %s %s\n", pathp->fp_names[0]->d_namep, DB_FULL_PATH_CUR_DIR(pathp)->d_namep); 
@


1.5
log
@Now ignores loops of less than 3 vertices.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-wave.c,v 1.4 1998/10/14 13:29:33 jra Exp $ (BRL)";
d52 1
a52 1
Usage: %s [-v][-i][-u][-xX lvl][-a abs_tess_tol][-r rel_tess_tol][-n norm_tess_tol]\n\
d60 6
d133 1
a133 1
	while ((c = getopt(argc, argv, "ua:n:o:r:vx:D:P:X:e:i:")) != EOF) {
d135 3
d277 1
a277 1
nmg_to_wave( r, pathp, region_id, material_id )
d281 2
d393 3
d688 1
a688 1
			nmg_to_wave( r, pathp, tsp->ts_regionid, tsp->ts_gmater );
@


1.4
log
@Corrected progress reporting.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-wave.c,v 1.3 1998/09/14 15:58:50 bparker Exp $ (BRL)";
d365 1
a365 1
				if( vert_count != 3 )
d372 2
d496 1
a496 1
				if( vert_count != 3 )
@


1.3
log
@*- fix typos
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-wave.c,v 1.2 1997/06/11 21:01:25 jra Exp $ (BRL)";
d250 2
a251 2
	printf( "                  %d triangulated successfully. %g%%\n",
		regions_written, percent );
a283 2
	float npercent;
	float tpercent;
d290 1
d293 2
a294 8
/* XXX */
	if(regions_tried>0){
		npercent = (float)(regions_converted * 100) / regions_tried;
		tpercent = (float)(regions_written * 100) / regions_tried;
		printf("Tried %d regions, %d conv. to NMG's %d conv. to tri. nmgper = %.2f%% triper = %.2f%% \n",
		regions_tried, regions_converted, regions_written, npercent,tpercent);
	}
/* XXX */
d695 10
@


1.2
log
@Made vertex normals an option.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/g-wave.c,v 1.1 1997/06/11 20:21:48 jra Exp jra $ (BRL)";
d493 1
a493 1
						fprintf( fp, " %d//%d", i+1+vert_offset, j+1+norm_offset );
d496 1
a496 1
						fprintf( fp, " %d", i+1+vert_offset );
@


1.1
log
@Initial revision
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/g-wave.c,v 1.5 1996/07/31 14:44:57 jra Exp $ (BRL)";
d52 1
a52 1
Usage: %s [-v][-i][-xX lvl][-a abs_tess_tol][-r rel_tess_tol][-n norm_tess_tol]\n\
d57 1
d127 1
a127 1
	while ((c = getopt(argc, argv, "a:n:o:r:vx:D:P:X:e:i:")) != EOF) {
d129 3
d315 2
a316 1
	nmg_vertexuse_normal_tabulate( &norms, &r->l.magic );
d401 1
a401 1
	for( i=0 ; i<NMG_TBL_END( &norms ) ; i++ )
d403 3
a405 1
		struct vertexuse_a_plane *va;
d407 7
a413 6
		va = (struct vertexuse_a_plane *)NMG_TBL_GET( &norms, i );
		NMG_CK_VERTEXUSE_A_PLANE( va );
		if (inches)
			fprintf( fp, "vn %f %f %f\n", V3ARGSIN( va->N ));
		else
			fprintf( fp, "vn %f %f %f\n", V3ARGS( va->N ));
d446 1
a446 1
				for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d448 1
a448 3
					NMG_CK_EDGEUSE( eu );

					if( !eu->vu_p->a.magic_p )
d450 1
a450 3
						use_normals = 0;
						break;
					}
d452 11
a462 4
					if( *eu->vu_p->a.magic_p != NMG_VERTEXUSE_A_PLANE_MAGIC )
					{
						use_normals = 0;
						break;
d465 2
a516 1
	norm_offset += NMG_TBL_END( &norms );
d518 5
a522 1
	nmg_tbl( &norms, TBL_FREE, (long *)NULL );
@
