head	11.63;
access;
symbols
	ansi-20040405-merged:11.55.2.2
	postmerge-20040405-ansi:11.61
	premerge-20040404-ansi:11.60
	postmerge-autoconf:11.60
	autoconf-freeze:11.58.4.3
	premerge-autoconf:11.60
	ansi-20040316-freeze:11.55.2.1
	postmerge-20040315-windows:11.60
	premerge-20040315-windows:11.59
	windows-20040315-freeze:11.55.4.2
	autoconf-20031203:11.58
	autoconf-20031202:11.58
	autoconf-branch:11.58.0.4
	phong-branch:11.58.0.2
	photonmap-branch:11.57.0.2
	rel-6-1-DP:11.55
	windows-branch:11.55.0.4
	rel-6-0-2:11.53
	ansi-branch:11.55.0.2
	rel-6-0-1-branch:11.53.0.2
	hartley-6-0-post:11.54
	hartley-6-0-pre:11.53
	rel-6-0-1:11.53
	rel-6-0:11.51
	rel-5-4:11.16.2.1
	offsite-5-3-pre:11.39
	rel-5-3:11.16.2.1
	rel-5-2:11.16
	rel-5-1-branch:11.16.0.2
	rel-5-1:11.16
	rel-5-0:11.7
	rel-5-0-beta:11.6
	rel-4-5:11.5
	ctj-4-5-post:11.4
	ctj-4-5-pre:11.4
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:1.4;
locks; strict;
comment	@ * @;


11.63
date	2004.05.24.04.16.11;	author morrison;	state dead;
branches;
next	11.62;

11.62
date	2004.05.10.15.30.41;	author erikg;	state Exp;
branches;
next	11.61;

11.61
date	2004.04.05.07.49.36;	author morrison;	state Exp;
branches;
next	11.60;

11.60
date	2004.03.16.13.54.29;	author morrison;	state Exp;
branches;
next	11.59;

11.59
date	2004.02.02.17.38.59;	author morrison;	state Exp;
branches;
next	11.58;

11.58
date	2003.08.06.21.05.04;	author jra;	state Exp;
branches
	11.58.4.1;
next	11.57;

11.57
date	2003.04.01.19.23.20;	author jra;	state Exp;
branches
	11.57.2.1;
next	11.56;

11.56
date	2002.11.27.13.41.40;	author jra;	state Exp;
branches;
next	11.55;

11.55
date	2002.08.20.17.07.20;	author jra;	state Exp;
branches
	11.55.2.1
	11.55.4.1;
next	11.54;

11.54
date	2002.08.15.20.54.33;	author hartley;	state Exp;
branches;
next	11.53;

11.53
date	2002.05.17.12.48.56;	author morrison;	state Exp;
branches;
next	11.52;

11.52
date	2002.05.02.14.51.01;	author jra;	state Exp;
branches;
next	11.51;

11.51
date	2002.01.08.13.41.18;	author jra;	state Exp;
branches;
next	11.50;

11.50
date	2001.11.30.15.27.33;	author jra;	state Exp;
branches;
next	11.49;

11.49
date	2001.10.22.19.50.29;	author bparker;	state Exp;
branches;
next	11.48;

11.48
date	2001.10.17.23.19.28;	author bparker;	state Exp;
branches;
next	11.47;

11.47
date	2001.10.10.15.48.16;	author butler;	state Exp;
branches;
next	11.46;

11.46
date	2001.10.04.14.10.21;	author jra;	state Exp;
branches;
next	11.45;

11.45
date	2001.10.02.19.24.08;	author jra;	state Exp;
branches;
next	11.44;

11.44
date	2001.09.18.17.33.50;	author jra;	state Exp;
branches;
next	11.43;

11.43
date	2001.08.10.21.22.52;	author butler;	state Exp;
branches;
next	11.42;

11.42
date	2001.03.23.22.33.31;	author butler;	state Exp;
branches;
next	11.41;

11.41
date	2001.03.20.16.08.36;	author jra;	state Exp;
branches;
next	11.40;

11.40
date	2001.03.19.22.19.19;	author butler;	state Exp;
branches;
next	11.39;

11.39
date	2000.11.17.15.57.40;	author jra;	state Exp;
branches;
next	11.38;

11.38
date	2000.10.19.19.19.44;	author butler;	state Exp;
branches;
next	11.37;

11.37
date	2000.09.14.20.20.21;	author jra;	state Exp;
branches;
next	11.36;

11.36
date	2000.09.08.05.55.41;	author mike;	state Exp;
branches;
next	11.35;

11.35
date	2000.08.31.01.02.37;	author mike;	state Exp;
branches;
next	11.34;

11.34
date	2000.08.24.03.00.42;	author mike;	state Exp;
branches;
next	11.33;

11.33
date	2000.08.15.02.42.19;	author mike;	state Exp;
branches;
next	11.32;

11.32
date	2000.08.11.00.44.58;	author mike;	state Exp;
branches;
next	11.31;

11.31
date	2000.08.10.05.02.31;	author mike;	state Exp;
branches;
next	11.30;

11.30
date	2000.08.10.04.57.51;	author mike;	state Exp;
branches;
next	11.29;

11.29
date	2000.08.10.03.20.56;	author mike;	state Exp;
branches;
next	11.28;

11.28
date	2000.08.09.19.35.38;	author mike;	state Exp;
branches;
next	11.27;

11.27
date	2000.07.26.17.17.56;	author mike;	state Exp;
branches;
next	11.26;

11.26
date	2000.07.25.22.40.47;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	2000.07.25.18.36.35;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	2000.07.13.02.28.51;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	2000.07.13.01.48.42;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	2000.07.12.21.59.34;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	2000.07.12.04.23.17;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	2000.07.12.03.49.10;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	2000.07.11.03.56.37;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	2000.07.11.02.42.52;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	2000.07.10.23.53.55;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	2000.05.23.01.46.58;	author mike;	state Exp;
branches
	11.16.2.1;
next	11.15;

11.15
date	2000.03.16.13.39.10;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	2000.03.04.05.54.40;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	2000.03.02.15.48.25;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	2000.03.02.14.39.39;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	2000.02.02.21.13.02;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	99.11.16.19.12.45;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	99.11.09.15.42.40;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	99.10.12.13.58.11;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	99.06.03.21.54.19;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	98.09.14.15.58.50;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	97.12.16.00.27.13;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	97.06.19.19.30.22;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	97.06.13.23.37.17;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.08.18.19.24.35;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.59.19;	author mike;	state Rel4_4;
branches;
next	10.11;

10.11
date	94.11.05.02.37.55;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	94.10.28.17.46.00;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	94.10.19.23.42.45;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	94.10.17.16.51.33;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.10.17.12.26.33;	author jra;	state Exp;
branches;
next	10.6;

10.6
date	94.10.16.12.18.07;	author jra;	state Exp;
branches;
next	10.5;

10.5
date	94.10.11.23.25.53;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.08.10.23.38.53;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	92.10.08.23.42.37;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.07.16.23.37.23;	author phil;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.41.16;	author mike;	state Rel4_0;
branches;
next	9.18;

9.18
date	91.07.05.23.44.51;	author mike;	state Exp;
branches;
next	9.17;

9.17
date	91.07.02.02.46.14;	author mike;	state Exp;
branches;
next	9.16;

9.16
date	91.06.13.03.08.05;	author mike;	state Exp;
branches;
next	9.15;

9.15
date	91.03.05.01.08.12;	author phil;	state Exp;
branches;
next	9.14;

9.14
date	91.02.12.09.29.44;	author sue;	state Exp;
branches;
next	9.13;

9.13
date	90.12.07.02.42.16;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	90.12.05.21.09.12;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	90.12.05.21.05.07;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	90.12.05.21.02.22;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	90.12.05.05.38.07;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	90.12.05.05.10.11;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.12.05.04.47.04;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.12.05.04.22.40;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.12.05.04.11.58;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.12.05.03.58.22;	author sue;	state Exp;
branches;
next	9.3;

9.3
date	90.12.05.03.51.52;	author mike;	state Exp;
branches
	9.3.1.1;
next	9.2;

9.2
date	90.04.23.21.07.50;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.46.06;	author mike;	state Rel3_5;
branches;
next	8.2;

8.2
date	89.03.06.17.02.20;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.25.24;	author mike;	state Rel3_0;
branches;
next	7.4;

7.4
date	88.09.17.07.55.26;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.05.15.20.32.53;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.01.27.02.14.13;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.23.54;	author mike;	state Rel;
branches;
next	6.3;

6.3
date	87.10.15.18.48.50;	author stay;	state Exp;
branches;
next	6.2;

6.2
date	87.07.16.10.05.32;	author moss;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.49.32;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.21.48.43;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.12.22.02.11;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.02.48.15;	author mike;	state Rel1;
branches;
next	1.17;

1.17
date	86.12.06.17.08.29;	author stay;	state Exp;
branches;
next	1.16;

1.16
date	86.12.03.18.38.19;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	86.11.19.01.14.08;	author kermit;	state Exp;
branches;
next	1.14;

1.14
date	86.08.13.06.24.38;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	86.08.02.01.37.57;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	86.07.31.05.26.07;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	86.07.31.05.22.39;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	86.07.31.00.51.33;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	86.07.29.16.57.19;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	86.07.27.18.48.25;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	86.07.27.18.27.13;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	86.06.12.20.26.32;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	86.03.26.01.03.40;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	85.06.04.21.33.03;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	85.06.03.16.59.15;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	85.03.26.13.36.32;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	85.03.08.21.23.17;	author mike;	state Exp;
branches;
next	;

9.3.1.1
date	90.12.05.04.15.33;	author mike;	state Exp;
branches;
next	9.3.1.2;

9.3.1.2
date	90.12.05.04.24.25;	author mike;	state Exp;
branches;
next	9.3.1.3;

9.3.1.3
date	90.12.05.04.28.20;	author mike;	state Exp;
branches;
next	9.3.1.4;

9.3.1.4
date	90.12.05.05.13.39;	author mike;	state Exp;
branches;
next	;

11.16.2.1
date	2000.11.17.15.53.47;	author jra;	state Exp;
branches;
next	;

11.55.2.1
date	2002.09.19.18.00.34;	author morrison;	state Exp;
branches;
next	11.55.2.2;

11.55.2.2
date	2004.03.17.21.15.54;	author morrison;	state Exp;
branches;
next	;

11.55.4.1
date	2003.08.14.08.07.24;	author morrison;	state Exp;
branches;
next	11.55.4.2;

11.55.4.2
date	2004.03.11.23.40.29;	author morrison;	state Exp;
branches;
next	;

11.57.2.1
date	2003.08.26.14.03.20;	author justin;	state Exp;
branches;
next	;

11.58.4.1
date	2004.02.12.19.24.22;	author erikg;	state Exp;
branches;
next	11.58.4.2;

11.58.4.2
date	2004.03.15.14.06.07;	author erikg;	state Exp;
branches;
next	11.58.4.3;

11.58.4.3
date	2004.03.18.18.10.24;	author erikg;	state Exp;
branches;
next	;


desc
@ASCII to Binary GED database converter.
@


11.63
log
@moved to src/conv/
@
text
@/*
 *		A S C 2 G . C
 *  
 *  This program generates a GED database from an
 *  ASCII GED data file.
 *
 *  Usage:  asc2g file.asc file.g
 *  
 *  Authors -
 *  	Charles M Kennedy
 *  	Michael J Muuss
 *	Susanne Muuss, J.D.	 Converted to libwdb, Oct. 1990 
 *
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/conv/asc2g.c,v 11.62 2004/05/10 15:30:41 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif




#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include <stdio.h>
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "bu.h"
#include "bn.h"
#include "db.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "wdb.h"
#include "mater.h"
#ifdef WIN32
#include <fcntl.h>
#endif

extern void rt_dsp_ifree( struct rt_db_internal	*ip);
extern void rt_ebm_ifree( struct rt_db_internal	*ip);
extern void rt_vol_ifree( struct rt_db_internal	*ip);


#define BUFSIZE			(8*1024)	/* input line buffer size */
#define TYPELEN			10
#define NAME_LEN			20

void		identbld(void), polyhbld(void), pipebld(void), particlebld(void);
void		solbld(void), arbnbld(void), clinebld(void), botbld(void), extrbld(void), sktbld(void);
int		combbld(void);
void		membbld(struct bu_list *headp), arsabld(void), arsbbld(void);
void		materbld(void), bsplbld(void), bsurfbld(void), zap_nl(void);
char		*nxt_spc(register char *cp);
void		strsolbld(void), nmgbld(void);

static union record	record;			/* GED database record */
static char 		buf[BUFSIZE];		/* Record input buffer */
char			name[NAMESIZE + 2];

FILE	*ifp;
struct rt_wdb	*ofp;
static int ars_ncurves=0;
static int ars_ptspercurve=0;
static int ars_curve=0;
static int ars_pt=0;
static char *ars_name;
static fastf_t **ars_curves=NULL;
static char *slave_name = "safe_interp";
static char *db_name = "db";

static char usage[] = "\
Usage: asc2g file.asc file.g\n\
 Convert an ASCII BRL-CAD database to binary form\n\
";

char *aliases[] = {
	"attr",
	"color",
	"put",
	"title",
	"units",
	"find",
	"dbfind",
	"rm",
	(char *)0
};

int
incr_ars_pt(void)
{
	int ret=0;

	ars_pt++;
	if( ars_pt >= ars_ptspercurve )
	{
		ars_curve++;
		ars_pt = 0;
		ret = 1;
	}

	if( ars_curve >= ars_ncurves )
		return( 2 );

	return( ret );
}

/*
 *			M A I N
 */
int
main(int argc, char **argv)
{
	char c1[3];
#ifdef WIN32
	_fmode = _O_BINARY;
#endif

	bu_debug = BU_DEBUG_COREDUMP;

	if( argc != 3 ) {
		bu_log( "%s", usage );
		exit( 1 );
	}

	ifp = fopen(argv[1],"r");
	if( !ifp )  perror(argv[1]);
	
	ofp = wdb_fopen(argv[2]);
	if( !ofp )  perror(argv[2]);
	if (ifp == NULL || ofp == NULL) {
		(void)fprintf(stderr, "asc2g: can't open files.");
		exit(1);
	}

	rt_init_resource( &rt_uniresource, 0, NULL );

	if( fgets( c1, 6, ifp ) == NULL ) {
		bu_bomb( "Unexpected EOF!!!\n" );
	}

	/* new style ascii database */
	if (!strncmp(c1, "title", 5) || !strncmp(c1, "put ", 4) ) {
		Tcl_Interp     *interp;
		Tcl_Interp     *safe_interp;

		/* this is a Tcl script */

		rewind( ifp );
		BU_LIST_INIT(&rt_g.rtg_headwdb.l);
		interp = Tcl_CreateInterp();
		if( wdb_init_obj( interp, ofp, db_name ) != TCL_OK ) {
			bu_bomb( "Failed to initialize wdb_obj!!\n" );
		}

		/* Create the safe interpreter */
		if ((safe_interp = Tcl_CreateSlave(interp, slave_name, 1)) == NULL) {
			bu_log("Failed to create safe interpreter");
			exit(1);
		}

		/* Create aliases */
		{
			int	i;
			int	ac = 1;
			const char	*av[2];

			av[1] = (char *)0;
			for (i = 0; aliases[i] != (char *)0; ++i) {
				av[0] = aliases[i];
				Tcl_CreateAlias(safe_interp, aliases[i], interp, db_name, ac, av);
			}
			/* add "dbfind" separately */
			av[0] = "find";
			Tcl_CreateAlias(safe_interp, "dbfind", interp, db_name, ac, av);
		}

		if( Tcl_EvalFile( safe_interp, argv[1] ) != TCL_OK ) {
			bu_log( "Failed to process input file (%s)!!\n", argv[1] );
			bu_log( "%s\n", Tcl_GetStringResult(safe_interp) );
			exit( 1 );
		}

		exit( 0 );
	} else {
		rewind( ifp );
	}

	/* Read ASCII input file, each record on a line */
	while( ( fgets( buf, BUFSIZE, ifp ) ) != (char *)0 )  {

after_read:
		/* Clear the output record -- vital! */
		(void)bzero( (char *)&record, sizeof(record) );

		/* Check record type */
		switch( buf[0] )  {
		case ID_SOLID:
			solbld();
			continue;

		case ID_COMB:
			if( combbld() > 0 )  goto after_read;
			continue;

		case ID_MEMB:
			bu_log("Warning: unattached Member record, ignored\n");
			continue;

		case ID_ARS_A:
			arsabld();
			continue;

		case ID_ARS_B:
			arsbbld();
			continue;

		case ID_P_HEAD:
			polyhbld();
			continue;

		case ID_P_DATA:
			bu_log("Unattached POLY-solid P_DATA (Q) record, skipping\n");
			continue;

		case ID_IDENT:
			identbld();
			continue;

		case ID_MATERIAL:
			materbld();
			continue;

		case ID_BSOLID:
			bsplbld();
			continue;

		case ID_BSURF:
			bsurfbld();
			continue;

		case DBID_PIPE:
			pipebld();
			continue;

		case DBID_STRSOL:
			strsolbld();
			continue;

		case DBID_NMG:
			nmgbld();
			continue;

		case DBID_PARTICLE:
			particlebld();
			continue;

		case DBID_ARBN:
			arbnbld();
			continue;

		case DBID_CLINE:
			clinebld();
			continue;

		case DBID_BOT:
			botbld();
			continue;

		case DBID_EXTR:
			extrbld();
			continue;

		case DBID_SKETCH:
			sktbld();
			continue;

		default:
			bu_log("asc2g: bad record type '%c' (0%o), skipping\n", buf[0], buf[0]);
			bu_log("%s\n", buf );
			continue;
		}
	}

	/* Now, at the end of the database, dump out the entire
	 * region-id-based color table.
	 */
	mk_write_color_table( ofp );
	wdb_close(ofp);

	exit(0);
}

/*
 *			S T R S O L B L D
 *
 *  Input format is:
 *	s type name args...\n
 *
 *  Individual processing is needed for each 'type' of solid,
 *  to hand it off to the appropriate LIBWDB routine.
 */
void
strsolbld(void)
{
    char	*type;
    char	*name;
    char	*args;
    struct bu_vls	str;

    bu_vls_init(&str);

    (void)strtok( buf, " " );
    /* skip stringsolid_id */
    type = strtok( NULL, " " );
    name = strtok( NULL, " " );
    args = strtok( NULL, "\n" );

    if( strcmp( type, "dsp" ) == 0 )  {
	struct rt_dsp_internal *dsp;

	BU_GETSTRUCT( dsp, rt_dsp_internal );
	bu_vls_init( &dsp->dsp_name );
	bu_vls_strcpy( &str, args );
	if( bu_struct_parse( &str, rt_functab[ID_DSP].ft_parsetab, (char *)dsp ) < 0 )  {
	    bu_log("strsolbld(%s): Unable to parse %s solid's args of '%s'\n",
		   name, type, args);
	    rt_dsp_ifree( (struct rt_db_internal *)dsp );
	    goto out;
	}
	dsp->magic = RT_DSP_INTERNAL_MAGIC;
	if( wdb_export( ofp, name, (genptr_t)dsp, ID_DSP, mk_conv2mm ) < 0 )  {
	    bu_log("strsolbld(%s): Unable to export %s solid, args='%s'\n",
		   name, type, args);
	    goto out;
	}
	/* 'dsp' has already been freed by wdb_export() */
    } else if ( strcmp(type, "ebm") == 0) {
	struct rt_ebm_internal *ebm;

	BU_GETSTRUCT( ebm, rt_ebm_internal );

	MAT_IDN(ebm->mat);

	bu_vls_strcpy( &str, args );
	if (bu_struct_parse( &str, rt_functab[ID_EBM].ft_parsetab, (char *)ebm) < 0) {
	    bu_log("strsolbld(%s): Unable to parse %s solid's args of '%s'\n",
		   name, type, args);
	    rt_ebm_ifree( (struct rt_db_internal *)ebm );
	    return;
	}
	ebm->magic = RT_EBM_INTERNAL_MAGIC;
	if (wdb_export(ofp, name, (genptr_t)ebm, ID_EBM, mk_conv2mm) < 0) {
	    bu_log("strsolbld(%s): Unable to export %s solid, args='%s'\n",
		   name, type, args);
	    goto out;
	}
	/* 'ebm' has already been freed by wdb_export() */
    } else if ( strcmp(type, "vol") == 0) {
	struct rt_vol_internal *vol;

	BU_GETSTRUCT( vol, rt_vol_internal );
	MAT_IDN(vol->mat);

	bu_vls_strcpy( &str, args );
	if (bu_struct_parse( &str, rt_functab[ID_VOL].ft_parsetab, (char *)vol) < 0) {
	    bu_log("strsolbld(%s): Unable to parse %s solid's args of '%s'\n",
		   name, type, args);
	    rt_vol_ifree( (struct rt_db_internal *)vol );
	    return;
	}
	vol->magic = RT_VOL_INTERNAL_MAGIC;
	if (wdb_export(ofp, name, (genptr_t)vol, ID_VOL, mk_conv2mm) < 0) {
	    bu_log("strsolbld(%s): Unable to export %s solid, args='%s'\n",
		   name, type, args);
	    goto out;
	}
	/* 'vol' has already been freed by wdb_export() */
    } else {
	bu_log("strsolbld(%s): unable to convert '%s' type solid, skipping\n",
	       name, type);
    }

 out:
    bu_vls_free(&str);
}

#define LSEG 'L'
#define CARC 'A'
#define NURB 'N'

void
sktbld(void)
{
	register char *cp, *ptr;
	int i, j;
	int vert_count, seg_count;
	float fV[3], fu[3], fv[3];
	point_t V;
	vect_t u, v;
	point2d_t *verts;
	char name[NAMESIZE+1];
	struct rt_sketch_internal *skt;
	struct curve *crv;
	struct line_seg *lsg;
	struct carc_seg *csg;
	struct nurb_seg *nsg;

	cp = buf;

	cp++;
	cp++;

	(void)sscanf( cp, "%s %f %f %f %f %f %f %f %f %f %d %d",
		name,
		&fV[0], &fV[1], &fV[2],
		&fu[0], &fu[1], &fu[2],
		&fv[0], &fv[1], &fv[2],
		&vert_count, &seg_count );

	VMOVE( V, fV );
	VMOVE( u, fu );
	VMOVE( v, fv );

	verts = (point2d_t *)bu_calloc( vert_count, sizeof( point2d_t ), "verts" );

	if( fgets( buf, BUFSIZE, ifp ) == (char *)0 )
	{
		bu_log( "Unexpected EOF while reading sketch (%s) data\n", name );
		exit( -1 );
	}

	verts = (point2d_t *)bu_calloc( vert_count, sizeof( point2d_t ), "verts" );
	cp = buf;
	ptr = strtok( buf, " " );
	if( !ptr )
	{
		bu_log( "ERROR: no vertices for sketch (%s)!!!\n", name );
		exit( 1 );
	}
	for( i=0 ; i<vert_count ; i++ )
	{
		verts[i][0] = atof( ptr );
		ptr = strtok( (char *)NULL, " " );
		if( !ptr )
		{
			bu_log( "ERROR: not enough vertices for sketch (%s)!!!\n", name );
			exit( 1 );
		}
		verts[i][1] = atof( ptr );
		ptr = strtok( (char *)NULL, " " );
		if( !ptr && i < vert_count-1 )
		{
			bu_log( "ERROR: not enough vertices for sketch (%s)!!!\n", name );
			exit( 1 );
		}
	}

	skt = (struct rt_sketch_internal *)bu_calloc( 1, sizeof( struct rt_sketch_internal ), "sketch" );
	skt->magic = RT_SKETCH_INTERNAL_MAGIC;
	VMOVE( skt->V, V );
	VMOVE( skt->u_vec, u );
	VMOVE( skt->v_vec, v );
	skt->vert_count = vert_count;
	skt->verts = verts;
	crv = &skt->skt_curve;
	crv->seg_count = seg_count;

	crv->segments = (genptr_t *)bu_calloc( crv->seg_count, sizeof( genptr_t ), "segments" );
	crv->reverse = (int *)bu_calloc( crv->seg_count, sizeof( int ), "reverse" );
	for( j=0 ; j<crv->seg_count ; j++ )
	{
		double radius;
		int k;

		if( fgets( buf, BUFSIZE, ifp ) == (char *)0 )
		{
			bu_log( "Unexpected EOF while reading sketch (%s) data\n", name );
			exit( -1 );
		}

		cp = buf + 2;
		switch( *cp )
		{
			case LSEG:
				lsg = (struct line_seg *)bu_malloc( sizeof( struct line_seg ), "line segment" );
				sscanf( cp+1, "%d %d %d", &crv->reverse[j], &lsg->start, &lsg->end );
				lsg->magic = CURVE_LSEG_MAGIC;
				crv->segments[j] = lsg;
				break;
			case CARC:
				csg = (struct carc_seg *)bu_malloc( sizeof( struct carc_seg ), "arc segment" );
				sscanf( cp+1, "%d %d %d %lf %d %d", &crv->reverse[j], &csg->start, &csg->end,
					&radius, &csg->center_is_left, &csg->orientation );
				csg->radius = radius;
				csg->magic = CURVE_CARC_MAGIC;
				crv->segments[j] = csg;
				break;
			case NURB:
				nsg = (struct nurb_seg *)bu_malloc( sizeof( struct nurb_seg ), "nurb segment" );
				sscanf( cp+1, "%d %d %d %d %d", &crv->reverse[j], &nsg->order, &nsg->pt_type,
					&nsg->k.k_size, &nsg->c_size );
				nsg->k.knots = (fastf_t *)bu_calloc( nsg->k.k_size, sizeof( fastf_t ), "knots" );
				nsg->ctl_points = (int *)bu_calloc( nsg->c_size, sizeof( int ), "control points" );
				if( fgets( buf, BUFSIZE, ifp ) == (char *)0 )
				{
					bu_log( "Unexpected EOF while reading sketch (%s) data\n", name );
					exit( -1 );
				}
				cp = buf + 3;
				ptr = strtok( cp, " " );
				if( !ptr )
				{
					bu_log( "ERROR: not enough knots for nurb segment in sketch (%s)!!!\n", name );
					exit( 1 );
				}
				for( k=0 ; k<nsg->k.k_size ; k++ )
				{
					nsg->k.knots[k] = atof( ptr );
					ptr = strtok( (char *)NULL, " " );
					if( !ptr && k<nsg->k.k_size-1 )
					{
						bu_log( "ERROR: not enough knots for nurb segment in sketch (%s)!!!\n", name );
						exit( 1 );
					}
				}
				if( fgets( buf, BUFSIZE, ifp ) == (char *)0 )
				{
					bu_log( "Unexpected EOF while reading sketch (%s) data\n", name );
					exit( -1 );
				}
				cp = buf + 3;
				ptr = strtok( cp, " " );
				if( !ptr )
				{
					bu_log( "ERROR: not enough control points for nurb segment in sketch (%s)!!!\n", name );
					exit( 1 );
				}
				for( k=0 ; k<nsg->c_size ; k++ )
				{
					nsg->ctl_points[k] = atoi( ptr );
					ptr = strtok( (char *)NULL, " " );
					if( !ptr && k<nsg->c_size-1 )
					{
						bu_log( "ERROR: not enough control points for nurb segment in sketch (%s)!!!\n", name );
						exit( 1 );
					}
				}
				nsg->magic = CURVE_NURB_MAGIC;
				crv->segments[j] = nsg;
				break;
			default:
				bu_log( "Unrecognized segment type (%c) in sketch (%s)!!!\n",
					*cp, name );
				exit( 1 );
		}

	}

	(void)mk_sketch(ofp, name,  skt );
}

void
extrbld(void)
{
	register char *cp;
	char name[NAMESIZE+1];
	char sketch_name[NAMESIZE+1];
	int keypoint;
	float fV[3];
	float fh[3];
	float fu_vec[3], fv_vec[3];
	point_t V;
	vect_t h, u_vec, v_vec;

	cp = buf;

	cp++;

	cp++;
	(void)sscanf( cp, "%s %s %d %f %f %f  %f %f %f %f %f %f %f %f %f",
		name, sketch_name, &keypoint, &fV[0], &fV[1], &fV[2], &fh[0], &fh[1], &fh[2],
		&fu_vec[0], &fu_vec[1], &fu_vec[2], &fv_vec[0], &fv_vec[1], &fv_vec[2] );

	VMOVE( V, fV );
	VMOVE( h, fh );
	VMOVE( u_vec, fu_vec );
	VMOVE( v_vec, fv_vec );
	(void)mk_extrusion( ofp, name, sketch_name, V, h, u_vec, v_vec, keypoint );
}

/*
 *			N M G B L D
 *
 *  For the time being, what we read in from the ascii form is
 *  a hex dump of the on-disk form of NMG.
 *  This is the same between v4 and v5.
 *  Reassemble it in v5 binary form here,
 *  then import it,
 *  then re-export it.
 *  This extra step is necessary because we don't know what version
 *  database the output it, LIBWDB is only interested in writing
 *  in-memory versions.
 */
void
nmgbld(void)
{
	register char *cp;
	int	version;
	char	*name;
	long	granules;
	long	struct_count[26];
	struct bu_external	ext;
	struct rt_db_internal	intern;
	int	j;

	/* First, process the header line */
	cp = strtok( buf, " " );
	/* This is nmg_id, unused here. */
	cp = strtok( NULL, " " );
	version = atoi(cp);
	cp = strtok( NULL, " " );
	name = bu_strdup( cp );
	cp = strtok( NULL, " " );
	granules = atol( cp );

	/* Allocate storage for external v5 form of the body */
	BU_INIT_EXTERNAL(&ext);
	ext.ext_nbytes = SIZEOF_NETWORK_LONG + 26*SIZEOF_NETWORK_LONG + 128 * granules;
	ext.ext_buf = bu_malloc( ext.ext_nbytes, "nmg ext_buf" );
	bu_plong( ext.ext_buf, version );
	BU_ASSERT_LONG( version, ==, 1 );	/* DISK_MODEL_VERSION */

	/* Get next line of input with the 26 counts on it */
	if( fgets( buf, BUFSIZE, ifp ) == (char *)0 )  {
		bu_log( "Unexpected EOF while reading NMG %s data, line 2\n", name );
		exit(-1);
	}

	/* Second, process counts for each kind of structure */
	cp = strtok( buf , " " );
	for( j=0 ; j<26 ; j++ )
	{
		struct_count[j] = atol( cp );
		bu_plong( ((unsigned char *)ext.ext_buf)+
			SIZEOF_NETWORK_LONG*(j+1), struct_count[j] );
		cp = strtok( (char *)NULL , " " );
	}

	/* Remaining lines have 32 bytes per line, in hex */
	/* There are 4 lines to make up one granule */
	cp = ((char *)ext.ext_buf) + (26+1)*SIZEOF_NETWORK_LONG;
	for( j=0; j < granules * 4; j++ )  {
		int k;
		unsigned int cp_i;

		if( fgets( buf, BUFSIZE, ifp ) == (char *)0 )
		{
			bu_log( "Unexpected EOF while reading NMG %s data, hex line %d\n", name, j );
			exit( -1 );
		}

		for( k=0 ; k<32 ; k++ )
		{
			sscanf( &buf[k*2] , "%2x" , &cp_i );
			*cp++ = cp_i;
		}
	}

	/* Next, import this disk record into memory */
	RT_INIT_DB_INTERNAL(&intern);
	if( rt_functab[ID_NMG].ft_import5( &intern, &ext, bn_mat_identity, ofp->dbip, &rt_uniresource, ID_NMG ) < 0 )  {
		bu_log("ft_import5 failed on NMG %s\n", name );
		exit( -1 );
	}
	bu_free_external(&ext);

	/* Now we should have a good NMG in memory */
	nmg_vmodel( (struct model *)intern.idb_ptr );

	/* Finally, squirt it back out through LIBWDB */
	mk_nmg( ofp, name, (struct model *)intern.idb_ptr );
	/* mk_nmg() frees the intern.idp_ptr pointer */
	RT_INIT_DB_INTERNAL(&intern);

	bu_free( name, "nmg name" );
}

/*		S O L B L D
 *
 * This routine parses a solid record and determines which libwdb routine
 * to call to replicate this solid.  Simple primitives are expected.
 */

void
solbld(void)
{
	register char *cp;
	register char *np;
	register int i;

	char	s_type;			/* id for the type of primitive */
	fastf_t	val[24];		/* array of values/parameters for solid */
	point_t	center;			/* center; used by many solids */
	point_t pnts[9];		/* array of points for the arbs */
	point_t	norm;
	vect_t	a, b, c, d, n;		/* various vectors required */
	vect_t	height;			/* height vector for tgc */
	vect_t	breadth;		/* breadth vector for rpc */
	double	dd, rad1, rad2;

	cp = buf;
	cp++;				/* ident */
	cp = nxt_spc( cp );		/* skip the space */
	s_type = atoi(cp);

	cp = nxt_spc( cp );

	np = name;
	while( *cp != ' ' )  {
		*np++ = *cp++;
	}
	*np = '\0';
	
	cp = nxt_spc( cp );
	/* Comgeom solid type */

	for( i = 0; i < 24; i++ )  {
		cp = nxt_spc( cp );
		val[i] = atof( cp );
	}

	/* Switch on the record type to make the solids. */

	switch( s_type ) {

		case GRP:
			VSET(center, val[0], val[1], val[2]);
			VSET(n, val[3], val[4], val[5]);
			(void)mk_grip( ofp, name, center, n, val[6] );
			break;

		case TOR:
			VSET(center, val[0], val[1], val[2]);
			VSET(n, val[3], val[4], val[5]);
			rad1 = MAGNITUDE(&val[6]);
			rad2 = MAGNITUDE(n);
			VUNITIZE(n);

			/* Prevent illegal torii from floating point fuzz */
			if( rad2 > rad1 )  rad2 = rad1;

			mk_tor(ofp, name, center, n, rad1, rad2);
			break;

		case GENTGC:
			VSET(center, val[0], val[1], val[2]);
			VSET(height, val[3], val[4], val[5]);
			VSET(a, val[6], val[7], val[8]);
			VSET(b, val[9], val[10], val[11]);
			VSET(c, val[12], val[13], val[14]);
			VSET(d, val[15], val[16], val[17]);
			
			mk_tgc(ofp, name, center, height, a, b, c, d);
			break;

		case GENELL:
			VSET(center, val[0], val[1], val[2]);
			VSET(a, val[3], val[4], val[5]);
			VSET(b, val[6], val[7], val[8]);
			VSET(c, val[9], val[10], val[11]);

			mk_ell(ofp, name, center, a, b, c);
			break;

		case GENARB8:
			VSET(pnts[0], val[0], val[1], val[2]);
			VSET(pnts[1], val[3], val[4], val[5]);
			VSET(pnts[2], val[6], val[7], val[8]);
			VSET(pnts[3], val[9], val[10], val[11]);
			VSET(pnts[4], val[12], val[13], val[14]);
			VSET(pnts[5], val[15], val[16], val[17]);
			VSET(pnts[6], val[18], val[19], val[20]);
			VSET(pnts[7], val[21], val[22], val[23]);

			/* Convert from vector notation to absolute points */
			for( i=1; i<8; i++ )  {
				VADD2( pnts[i], pnts[i], pnts[0] );
			}

			mk_arb8(ofp, name, &pnts[0][X]);
			break;

		case HALFSPACE:
			VSET(norm, val[0], val[1], val[2]);
			dd = val[3];

			mk_half(ofp, name, norm, dd);
			break;

		case RPC:
			VSET( center, val[0], val[1], val[2] );
			VSET( height, val[3], val[4], val[5] );
			VSET( breadth, val[6], val[7], val[8] );
			dd = val[9];

			mk_rpc( ofp, name, center, height, breadth, dd );
			break;

		case RHC:
			VSET( center, val[0], val[1], val[2] );
			VSET( height, val[3], val[4], val[5] );
			VSET( breadth, val[6], val[7], val[8] );
			rad1 = val[9];
			dd = val[10];

			mk_rhc( ofp, name, center, height, breadth, rad1, dd );
			break;

		case EPA:
			VSET( center, val[0], val[1], val[2] );
			VSET( height, val[3], val[4], val[5] );
			VSET( a, val[6], val[7], val[8] );
			VUNITIZE( a );
			rad1 = val[9];
			rad2 = val[10];

			mk_epa( ofp, name, center, height, a, rad1, rad2 );
			break;

		case EHY:
			VSET( center, val[0], val[1], val[2] );
			VSET( height, val[3], val[4], val[5] );
			VSET( a, val[6], val[7], val[8] );
			VUNITIZE( a );
			rad1 = val[9];
			rad2 = val[10];
			dd = val[11];

			mk_ehy( ofp, name, center, height, a, rad1, rad2, dd );
			break;

		case ETO:
			VSET( center, val[0], val[1], val[2] );
			VSET( norm, val[3], val[4], val[5] );
			VSET( c, val[6], val[7], val[8] );
			rad1 = val[9];
			rad2 = val[10];

			mk_eto( ofp, name, center, norm, c, rad1, rad2 );
			break;

		default:
			bu_log("asc2g: bad solid %s s_type= %d, skipping\n",
				name, s_type);
	}

}


/*			C O M B B L D
 *
 *  This routine builds combinations.
 *  It does so by processing the "C" combination input line,
 *  (which may be followed by optional material properties lines),
 *  and it then slurps up any following "M" member lines,
 *  building up a linked list of all members.
 *  Reading continues until a non-"M" record is encountered.
 *
 *  Returns -
 *	0	OK
 *	1	OK, another record exists in global input line buffer.
 */
int
combbld(void)
{
	struct bu_list	head;
	register char 	*cp;
	register char 	*np;
	int 		temp_nflag, temp_pflag;

	char		override;
	char		reg_flags;	/* region flag */
	int		is_reg;
	short		regionid;
	short		aircode;
	short		material;	/* GIFT material code */
	short		los;		/* LOS estimate */
	unsigned char	rgb[3];		/* Red, green, blue values */
	char		matname[32];	/* String of material name */
	char		matparm[60];	/* String of material parameters */
	char		inherit;	/* Inheritance property */

	/* Set all flags initially. */
	BU_LIST_INIT( &head );

	override = 0;
	temp_nflag = temp_pflag = 0;	/* indicators for optional fields */

	cp = buf;
	cp++;				/* ID_COMB */
	cp = nxt_spc( cp );		/* skip the space */

	reg_flags = *cp++;		/* Y, N, or new P, F */
	cp = nxt_spc( cp );

	np = name;
	while( *cp != ' ' )  {
		*np++ = *cp++;
	}
	*np = '\0';
	
	cp = nxt_spc( cp );

	regionid = (short)atoi( cp );
	cp = nxt_spc( cp );
	aircode = (short)atoi( cp );
	cp = nxt_spc( cp );
	/* DEPRECTED: number of members expected */
	cp = nxt_spc( cp );
	/* DEPRECATED: Comgeom reference number */
	cp = nxt_spc( cp );
	material = (short)atoi( cp );
	cp = nxt_spc( cp );
	los = (short)atoi( cp );
	cp = nxt_spc( cp );
	override = (char)atoi( cp );
	cp = nxt_spc( cp );

	rgb[0] = (unsigned char)atoi( cp );
	cp = nxt_spc( cp );
	rgb[1] = (unsigned char)atoi( cp );
	cp = nxt_spc( cp );
	rgb[2] = (unsigned char)atoi( cp );
	cp = nxt_spc( cp );

	temp_nflag = atoi( cp );
	cp = nxt_spc( cp );
	temp_pflag = atoi( cp );

	cp = nxt_spc( cp );
	inherit = atoi( cp );

	/* To support FASTGEN, different kinds of regions now exist. */
	switch( reg_flags )  {
	case 'Y':
	case 'R':
		is_reg = DBV4_REGION;
		break;
	case 'P':
		is_reg = DBV4_REGION_FASTGEN_PLATE;
		break;
	case 'V':
		is_reg = DBV4_REGION_FASTGEN_VOLUME;
		break;
	case 'N':
	default:
		is_reg = 0;
	}

	if( temp_nflag )  {
		fgets( buf, BUFSIZE, ifp );
		zap_nl();
		bzero( matname, sizeof(matname) );
		strncpy( matname, buf, sizeof(matname)-1 );
	}
	if( temp_pflag )  {
		fgets( buf, BUFSIZE, ifp );
		zap_nl();
		bzero( matparm, sizeof(matparm) );
		strncpy( matparm, buf, sizeof(matparm)-1 );
	}

	for(;;)  {
		buf[0] = '\0';
		if( fgets( buf, BUFSIZE, ifp ) == (char *)0 )
			break;

		if( buf[0] != ID_MEMB )  break;

		/* Process (and accumulate) the members */
		membbld( &head );
	}

	/* Spit them out, all at once.  Use GIFT semantics. */
	if( mk_comb(ofp, name, &head, is_reg,
		temp_nflag ? matname : (char *)0,
		temp_pflag ? matparm : (char *)0,
		override ? (unsigned char *)rgb : (unsigned char *)0,
		regionid, aircode, material, los, inherit, 0, 1) < 0 )  {
			fprintf(stderr,"asc2g: mk_lrcomb fail\n");
			abort();
	}

	if( buf[0] == '\0' )  return(0);
	return(1);
}


/*		M E M B B L D
 *
 *  This routine invokes libwdb to build a member of a combination.
 *  Called only from combbld()
 */
void
membbld(struct bu_list *headp)
{
	register char 	*cp;
	register char 	*np;
	register int 	i;
	char		relation;	/* boolean operation */
	char		inst_name[NAMESIZE+2];
	struct wmember	*memb;

	cp = buf;
	cp++;				/* ident */
	cp = nxt_spc( cp );		/* skip the space */

	relation = *cp++;
	cp = nxt_spc( cp );

	np = inst_name;
	while( *cp != ' ' )  {
		*np++ = *cp++;
	}
	*np = '\0';

	cp = nxt_spc( cp );

	memb = mk_addmember( inst_name, headp, NULL, relation );

	for( i = 0; i < 16; i++ )  {
		memb->wm_mat[i] = atof( cp );
		cp = nxt_spc( cp );
	}
}


/*		A R S B L D
 *
 * This routine builds ARS's.
 */

void
arsabld(void)
{
	char *cp;
	char *np;
	int i;

	if( ars_name )
		bu_free( (char *)ars_name, "ars_name" );
	cp = buf;
	cp = nxt_spc( cp );
	cp = nxt_spc( cp );

	np = cp;
	while( *(++cp) != ' ' );
	*cp++ = '\0';
	ars_name = bu_strdup( np );
	ars_ncurves = (short)atoi( cp );
	cp = nxt_spc( cp );
	ars_ptspercurve = (short)atoi( cp );

	ars_curves = (fastf_t **)bu_calloc( (ars_ncurves+1), sizeof(fastf_t *), "ars_curves" );
	for( i=0 ; i<ars_ncurves ; i++ )
	{
		ars_curves[i] = (fastf_t *)bu_calloc( ars_ptspercurve + 1,
			sizeof( fastf_t ) * ELEMENTS_PER_VECT, "ars_curve" );
	}

	ars_pt = 0;
	ars_curve = 0;
}

/*		A R S B L D
 *
 * This is the second half of the ARS-building.  It builds the ARS B record.
 */

void
arsbbld(void)
{
	char *cp;
	int i;
	int incr_ret;

	cp = buf;
	cp = nxt_spc( cp );		/* skip the space */
	cp = nxt_spc( cp );
	cp = nxt_spc( cp );
	for( i = 0; i < 8; i++ )  {
		cp = nxt_spc( cp );
		ars_curves[ars_curve][ars_pt*3] = atof( cp );
		cp = nxt_spc( cp );
		ars_curves[ars_curve][ars_pt*3 + 1] = atof( cp );
		cp = nxt_spc( cp );
		ars_curves[ars_curve][ars_pt*3 + 2] = atof( cp );
		if( ars_curve > 0 || ars_pt > 0 )
			VADD2( &ars_curves[ars_curve][ars_pt*3], &ars_curves[ars_curve][ars_pt*3], &ars_curves[0][0] )

		incr_ret = incr_ars_pt();
		if( incr_ret == 2 )
		{
			/* finished, write out the ARS solid */
			if( mk_ars( ofp, ars_name, ars_ncurves, ars_ptspercurve, ars_curves ) )
			{
				bu_log( "Failed trying to make ARS (%s)\n", ars_name );
				bu_bomb( "Failed trying to make ARS\n" );
			}
			return;
		}
		else if( incr_ret == 1 )
		{
			/* end of curve, ignore remainder of reocrd */
			return;
		}
	}
}


/*		Z A P _ N L
 *
 * This routine removes newline characters from the buffer and substitutes
 * in NULL.
 */

void
zap_nl(void)
{
	register char *bp;

	bp = &buf[0];

	while( *bp != '\0' )  {
		if( *bp == '\n' )
			*bp = '\0';
		bp++;
	}
}


/*		I D E N T B L D
 *
 * This routine makes an ident record.  It calls libwdb to do this.
 */

void
identbld(void)
{
	register char	*cp;
	register char	*np;
	char		units;		/* units code number */
	char		version[6];
	char		title[72];
	char		*unit_str = "none";
	double		local2mm;

	cp = buf;
	cp++;				/* ident */
	cp = nxt_spc( cp );		/* skip the space */

	units = (char)atoi( cp );
	cp = nxt_spc( cp );

	/* Note that there is no provision for handing libwdb the version.
	 * However, this is automatically provided when needed.
	 */

	np = version;
	while( *cp != '\n' && *cp != '\0' )  {
		*np++ = *cp++;
	}
	*np = '\0';

	if( strcmp( version, ID_VERSION ) != 0 )  {
		bu_log("WARNING:  input file version (%s) is not %s\n",
			version, ID_VERSION);
	}

	(void)fgets( buf, BUFSIZE, ifp);
	zap_nl();
	(void)strncpy( title, buf, sizeof(title)-1 );

/* XXX Should use db_conversions() for this */
	switch(units)  {
	case ID_NO_UNIT:
		unit_str = "mm";
		break;
	case ID_MM_UNIT:
		unit_str = "mm";
		break;
	case ID_UM_UNIT:
		unit_str = "um";
		break;
	case ID_CM_UNIT:
		unit_str = "cm";
		break;
	case ID_M_UNIT:
		unit_str = "m";
		break;
	case ID_KM_UNIT:
		unit_str = "km";
		break;
	case ID_IN_UNIT:
		unit_str = "in";
		break;
	case ID_FT_UNIT:
		unit_str = "ft";
		break;
	case ID_YD_UNIT:
		unit_str = "yard";
		break;
	case ID_MI_UNIT:
		unit_str = "mile";
		break;
	default:
		fprintf(stderr,"asc2g: unknown v4 units code = %d\n", units);
		exit(1);
	}
	local2mm = bu_units_conversion(unit_str);
	if( local2mm <= 0 )  {
		fprintf(stderr, "asc2g: unable to convert v4 units string '%s', got local2mm=%g\n",
			unit_str, local2mm);
		exit(3);
	}

	if( mk_id_editunits(ofp, title, local2mm) < 0 )  {
		bu_log("asc2g: unable to write database ID\n");
		exit(2);
	}
}


/*		P O L Y H B L D
 *
 *  Collect up all the information for a POLY-solid.
 *  These are handled as BoT solids in v5, but we still have to read
 *  the data in the old format, and then convert it.
 *
 *  The poly header line is followed by an unknown number of
 *  poly data lines.
 */

void
polyhbld(void)
{
	char	*cp;
	char	*name;
	long	startpos;
	long	nlines;
	struct rt_pg_internal	*pg;
	struct rt_db_internal	intern;
	struct bn_tol	tol;

	(void)strtok( buf, " " );	/* skip the ident character */
	cp = strtok( NULL, " \n" );
	name = bu_strdup(cp);

	/* Count up the number of poly data lines which follow */
	startpos = ftell(ifp);
	for( nlines = 0; ; nlines++ )  {
		if( fgets( buf, BUFSIZE, ifp ) == NULL )  break;
		if( buf[0] != ID_P_DATA )  break;	/* 'Q' */
	}
	BU_ASSERT_LONG( nlines, >, 0 );

	/* Allocate storage for the faces */
	BU_GETSTRUCT( pg, rt_pg_internal );
	pg->magic = RT_PG_INTERNAL_MAGIC;
	pg->npoly = nlines;
	pg->poly = (struct rt_pg_face_internal *)bu_calloc( pg->npoly,
		sizeof(struct rt_pg_face_internal), "poly[]" );
	pg->max_npts = 0;

	/* Return to first 'Q' record */
	fseek( ifp, startpos, 0 );

	for( nlines = 0; nlines < pg->npoly; nlines++ )  {
		register struct rt_pg_face_internal	*fp = &pg->poly[nlines];
		register int	i;

		if( fgets( buf, BUFSIZE, ifp ) == NULL )  break;
		if( buf[0] != ID_P_DATA )  bu_bomb("mis-count of Q records?\n");

		/* Input always has 5 points, even if all aren't significant */
		fp->verts = (fastf_t *)bu_malloc( 5*3*sizeof(fastf_t), "verts[]" );
		fp->norms = (fastf_t *)bu_malloc( 5*3*sizeof(fastf_t), "norms[]" );

		cp = buf;
		cp++;				/* ident */
		cp = nxt_spc( cp );		/* skip the space */

		fp->npts = (char)atoi( cp );
		if( fp->npts > pg->max_npts )  pg->max_npts = fp->npts;

		for( i = 0; i < 5*3; i++ )  {
			cp = nxt_spc( cp );
			fp->verts[i] = atof( cp );
		}

		for( i = 0; i < 5*3; i++ )  {
			cp = nxt_spc( cp );
			fp->norms[i] = atof( cp );
		}
	}

	/* Convert the polysolid to a BoT */
	RT_INIT_DB_INTERNAL(&intern);
	intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern.idb_type = ID_POLY;
	intern.idb_meth = &rt_functab[ID_POLY];
	intern.idb_ptr = pg;

	/* this tolerance structure is only used for converting polysolids to BOT's
	 * use zero distance to avoid losing any polysolid facets
	 */
        tol.magic = BN_TOL_MAGIC;
        tol.dist = 0.0;
        tol.dist_sq = tol.dist * tol.dist;
        tol.perp = 1e-6;
        tol.para = 1 - tol.perp;

	if( rt_pg_to_bot( &intern, &tol, &rt_uniresource ) < 0 )
		bu_bomb("rt_pg_to_bot() failed\n");
	/* The polysolid is freed by the converter */

	/*
	 * Since we already have an internal form, this is much simpler than
	 * calling mk_bot().
	 */
	if( wdb_put_internal( ofp, name, &intern, mk_conv2mm ) < 0 )
		bu_bomb("wdb_put_internal() failure on BoT from polysolid\n");
	/* BoT internal has been freed */
}

/*		M A T E R B L D
 *
 *  Add information to the region-id based coloring table.
 */

void
materbld(void)
{
	register char *cp;
	int	low, hi;
	int	r,g,b;

	cp = buf;
	cp++;				/* skip ID_MATERIAL */
	cp = nxt_spc( cp );		/* skip the space */

	/* flags = (char)atoi( cp ); */
	cp = nxt_spc( cp );
	low = (short)atoi( cp );
	cp = nxt_spc( cp );
	hi = (short)atoi( cp );
	cp = nxt_spc( cp );
	r = (unsigned char)atoi( cp);
	cp = nxt_spc( cp );
	g = (unsigned char)atoi( cp);
	cp = nxt_spc( cp );
	b = (unsigned char)atoi( cp);

	/* Put it on a linked list for output later */
	rt_color_addrec( low, hi, r, g, b, -1L );
}

/*		B S P L B L D
 *
 *  This routine builds B-splines using libwdb.
 */

void
bsplbld(void)
{
#if 0
	register char	*cp;
	register char	*np;
	short		nsurf;		/* number of surfaces */
	fastf_t		resolution;	/* resolution of flatness */
	
	cp = buf;
	cp++;				/* ident */
	cp = nxt_spc( cp );		/* skip the space */

	np = name;
	while( *cp != ' ' )  {
		*np++ = *cp++;
	}
	*np = '\0';
	cp = nxt_spc( cp );

	nsurf = (short)atoi( cp );
	cp = nxt_spc( cp );
	resolution = atof( cp );

	mk_bsolid(ofp, name, nsurf, resolution);
#else
	bu_bomb("bsplbld() needs to be upgraded to v5\n");
#endif
}

/* 		B S U R F B L D
 *
 * This routine builds d-spline surface descriptions using libwdb.
 */

void
bsurfbld(void)
{
#if 0

/* HELP! This involves mk_bsurf(filep, bp) where bp is a ptr to struct */

	register char	*cp;
	register int	i;
	register float	*vp;
	int		nbytes, count;
	float		*fp;

	cp = buf;
	record.d.d_id = *cp++;
	cp = nxt_spc( cp );		/* skip the space */

	record.d.d_order[0] = (short)atoi( cp );
	cp = nxt_spc( cp );
	record.d.d_order[1] = (short)atoi( cp );
	cp = nxt_spc( cp );
	record.d.d_kv_size[0] = (short)atoi( cp );
	cp = nxt_spc( cp );
	record.d.d_kv_size[1] = (short)atoi( cp );
	cp = nxt_spc( cp );
	record.d.d_ctl_size[0] = (short)atoi( cp );
	cp = nxt_spc( cp );
	record.d.d_ctl_size[1] = (short)atoi( cp );
	cp = nxt_spc( cp );
	record.d.d_geom_type = (short)atoi( cp );
	cp = nxt_spc( cp );
	record.d.d_nknots = (short)atoi( cp );
	cp = nxt_spc( cp );
	record.d.d_nctls = (short)atoi( cp );

	record.d.d_nknots = 
		ngran( record.d.d_kv_size[0] + record.d.d_kv_size[1] );

	record.d.d_nctls = 
		ngran( record.d.d_ctl_size[0] * record.d.d_ctl_size[1] 
			* record.d.d_geom_type);

	/* Write out the record */
	(void)fwrite( (char *)&record, sizeof record, 1, ofp );

	/* 
	 * The b_surf_head record is followed by
	 * d_nknots granules of knot vectors (first u, then v),
	 * and then by d_nctls granules of control mesh information.
	 * Note that neither of these have an ID field!
	 *
	 * B-spline surface record, followed by
	 *	d_kv_size[0] floats,
	 *	d_kv_size[1] floats,
	 *	padded to d_nknots granules, followed by
	 *	ctl_size[0]*ctl_size[1]*geom_type floats,
	 *	padded to d_nctls granules.
	 *
	 * IMPORTANT NOTE: granule == sizeof(union record)
	 */

	/* Malloc and clear memory for the KNOT DATA and read it */
	nbytes = record.d.d_nknots * sizeof(union record);
	if( (vp = (float *)malloc(nbytes))  == (float *)0 )  {
		bu_log( "asc2g: spline knot malloc error\n");
		exit(1);
	}
	fp = vp;
	(void)bzero( (char *)vp, nbytes );
	/* Read the knot vector information */
	count = record.d.d_kv_size[0] + record.d.d_kv_size[1];
	for( i = 0; i < count; i++ )  {
		fgets( buf, BUFSIZE, ifp );
		(void)sscanf( buf, "%f", vp++);
	}
	/* Write out the information */
	(void)fwrite( (char *)fp, nbytes, 1, ofp );

	/* Free the knot data memory */
	(void)free( (char *)fp );

	/* Malloc and clear memory for the CONTROL MESH data and read it */
	nbytes = record.d.d_nctls * sizeof(union record);
	if( (vp = (float *)malloc(nbytes))  == (float *)0 )  {
		bu_log( "asc2g: control mesh malloc error\n");
		exit(1);
	}
	fp = vp;
	(void)bzero( (char *)vp, nbytes );
	/* Read the control mesh information */
	count = record.d.d_ctl_size[0] * record.d.d_ctl_size[1] *
		record.d.d_geom_type;
	for( i = 0; i < count; i++ )  {
		fgets( buf, BUFSIZE, ifp );
		(void)sscanf( buf, "%f", vp++);
	}
	/* Write out the information */
	(void)fwrite( (char *)fp, nbytes, 1, ofp );

	/* Free the control mesh memory */
	(void)free( (char *)fp );
#else
	bu_bomb("bsrfbld() needs to be upgraded to v5\n");
#endif
}

/*		C L I N E B L D
 *
 */
void
clinebld(void)
{
	char			my_name[NAME_LEN];
	fastf_t			thickness;
	fastf_t			radius;
	point_t			V;
	vect_t			height;
	register char		*cp;
	register char		*np;

	cp = buf;
	cp++;
	cp = nxt_spc( cp );

	np = my_name;
	while( *cp != ' ' && *cp != '\n' )
		*np++ = *cp++;
	*np = '\0';

	cp = nxt_spc( cp );

	V[0] = atof( cp );

	cp = nxt_spc( cp );

	V[1] = atof( cp );

	cp = nxt_spc( cp );

	V[2] = atof( cp );

	cp = nxt_spc( cp );

	height[0] = atof( cp );

	cp = nxt_spc( cp );

	height[1] = atof( cp );

	cp = nxt_spc( cp );

	height[2] = atof( cp );

	cp = nxt_spc( cp );

	radius = atof( cp );

	cp = nxt_spc( cp );

	thickness = atof( cp );

	mk_cline( ofp, my_name, V, height, radius, thickness );
}

/*		B O T B L D
 *
 */
void
botbld(void)
{
	char			my_name[NAME_LEN];
	char			type;
	int			mode, orientation, error_mode, num_vertices, num_faces;
	int			i,j;
	double			a[3];
	fastf_t			*vertices;
	fastf_t			*thick=NULL;
	int			*faces;
	struct bu_bitv		*facemode=NULL;

	sscanf( buf, "%c %s %d %d %d %d %d", &type, my_name, &mode, &orientation,
		&error_mode, &num_vertices, &num_faces );

	/* get vertices */
	vertices = (fastf_t *)bu_calloc( num_vertices * 3, sizeof( fastf_t ), "botbld: vertices" );
	for( i=0 ; i<num_vertices ; i++ )
	{
		fgets( buf, BUFSIZE, ifp);
		sscanf( buf, "%d: %le %le %le", &j, &a[0], &a[1], &a[2] );
		if( i != j )
		{
			bu_log( "Vertices out of order in solid %s (expecting %d, found %d)\n",
				my_name, i, j );
			bu_free( (char *)vertices, "botbld: vertices" );
			bu_log( "Skipping this solid!!!\n" );
			while( buf[0] == '\t' )
				fgets( buf, BUFSIZE, ifp);
			return;
		}
		VMOVE( &vertices[i*3], a );
	}

	/* get faces (and possibly thicknesses */
	faces = (int *)bu_calloc( num_faces * 3, sizeof( int ), "botbld: faces" );
	if( mode == RT_BOT_PLATE )
		thick = (fastf_t *)bu_calloc( num_faces, sizeof( fastf_t ), "botbld thick" );
	for( i=0 ; i<num_faces ; i++ )
	{
		fgets( buf, BUFSIZE, ifp);
		if( mode == RT_BOT_PLATE )
			sscanf( buf, "%d: %d %d %d %le", &j, &faces[i*3], &faces[i*3+1], &faces[i*3+2], &a[0] );
		else
			sscanf( buf, "%d: %d %d %d", &j, &faces[i*3], &faces[i*3+1], &faces[i*3+2] );

		if( i != j )
		{
			bu_log( "Faces out of order in solid %s (expecting %d, found %d)\n",
				my_name, i, j );
			bu_free( (char *)vertices, "botbld: vertices" );
			bu_free( (char *)faces, "botbld: faces" );
			if( mode == RT_BOT_PLATE )
				bu_free( (char *)thick, "botbld thick" );
			bu_log( "Skipping this solid!!!\n" );
			while( buf[0] == '\t' )
				fgets( buf, BUFSIZE, ifp);
			return;
		}

		if( mode == RT_BOT_PLATE )
			thick[i] = a[0];
	}

	if( mode == RT_BOT_PLATE )
	{
		/* get bit vector */
		fgets( buf, BUFSIZE, ifp);
		facemode = bu_hex_to_bitv( &buf[1] );
	}

	mk_bot( ofp, my_name, mode, orientation, 0, num_vertices, num_faces,
		vertices, faces, thick, facemode );

	bu_free( (char *)vertices, "botbld: vertices" );
	bu_free( (char *)faces, "botbld: faces" );
	if( mode == RT_BOT_PLATE )
	{
		bu_free( (char *)thick, "botbld thick" );
		bu_free( (char *)facemode, "botbld facemode" );
	}

}

/*		P I P E B L D
 *
 *  This routine reads pipe data from standard in, constructs a doublely
 *  linked list of pipe points, and sends this list to mk_pipe().
 */

void
pipebld(void)
{

	char			name[NAME_LEN];
	register char		*cp;
	register char		*np;
	struct wdb_pipept	*sp;
	struct bu_list		head;

	/* Process the first buffer */

	cp = buf;
	cp++;				/* ident, not used later */
	cp = nxt_spc( cp );		/* skip spaces */

	np = name;
	while( *cp != '\n' )  {
		*np++ = *cp++;
	}
	*np = '\0';			/* null terminate the string */


	/* Read data lines and process */

	BU_LIST_INIT( &head );
	fgets( buf, BUFSIZE, ifp);
	while( strncmp (buf , "END_PIPE", 8 ) )
	{
		double id,od,x,y,z,bendradius;

		if( (sp = (struct wdb_pipept *)malloc(sizeof(struct wdb_pipept)) ) == NULL)
		{
				fprintf(stderr,"asc2g: malloc failure for pipe\n");
				exit(-1);
		}

		(void)sscanf( buf, "%le %le %le %le %le %le",
				&id, &od,
				&bendradius, &x, &y, &z );

		sp->l.magic = WDB_PIPESEG_MAGIC;

		sp->pp_id = id;
		sp->pp_od = od;
		sp->pp_bendradius = bendradius;
		VSET( sp->pp_coord, x, y, z );

		BU_LIST_INSERT( &head, &sp->l);
		fgets( buf, BUFSIZE, ifp);
	}

	mk_pipe(ofp, name, &head);
	mk_pipe_free( &head );
}

/*			P A R T I C L E B L D
 *
 * This routine reads particle data from standard in, and constructs the
 * parameters required by mk_particle.
 */

void
particlebld(void)
{

	char		name[NAME_LEN];
	char		ident;
	point_t		vertex;
	vect_t		height;
	double		vrad;
	double		hrad;


	/* Read all the information out of the existing buffer.  Note that
	 * particles fit into one granule.
	 */

	(void)sscanf(buf, "%c %s %le %le %le %le %le %le %le %le",
		&ident, name,
		&vertex[0],
		&vertex[1],
		&vertex[2],
		&height[0],
		&height[1],
		&height[2],
		&vrad, &hrad);

	mk_particle( ofp, name, vertex, height, vrad, hrad);
}


/*			A R B N B L D
 *
 *  This routine reads arbn data from standard in and sendss it to
 *  mk_arbn().
 */

void
arbnbld(void)
{

	char		name[NAME_LEN];
	char		type[TYPELEN];
	int		i;
	int		neqn;			/* number of eqn expected */
	plane_t		*eqn;			/* pointer to plane equations for faces */
	register char	*cp;
	register char	*np;

	/* Process the first buffer */

	cp = buf;
	cp++;					/* ident */
	cp = nxt_spc(cp);			/* skip spaces */

	np = name;
	while( *cp != ' ')  {
		*np++ = *cp++;
	}
	*np = '\0';				/* null terminate the string */

	cp = nxt_spc(cp);

	neqn = atoi(cp);			/* find number of eqns */
/*bu_log("neqn = %d\n", neqn);
 */
	/* Check to make sure plane equations actually came in. */
	if( neqn <= 0 )  {
		bu_log("asc2g: warning: %d equations counted for arbn %s\n", neqn, name);
	}

/*bu_log("mallocing space for eqns\n");
 */
	/* Malloc space for the in-coming plane equations */
	if( (eqn = (plane_t *)malloc( sizeof( plane_t ) * neqn ) ) == NULL)  {
		bu_log("asc2g: malloc failure for arbn\n");
		exit(-1);
	}

	/* Now, read the plane equations and put in appropriate place */

/*bu_log("starting to dump eqns\n");
 */
	for( i = 0; i < neqn; i++ )  {
		fgets( buf, BUFSIZE, ifp);
		(void)sscanf( buf, "%s %le %le %le %le", type,
			&eqn[i][X], &eqn[i][Y], &eqn[i][Z], &eqn[i][3]);
	}

/*bu_log("sending info to mk_arbn\n");
 */
	mk_arbn( ofp, name, neqn, eqn);
}

char *
nxt_spc(register char *cp)
{
	while( *cp != ' ' && *cp != '\t' && *cp !='\0' )  {
		cp++;
	}
	if( *cp != '\0' )  {
		cp++;
	}
	return( cp );
}

int
ngran(int nfloat)
{
	register int gran;
	/* Round up */
	gran = nfloat + ((sizeof(union record)-1) / sizeof(float) );
	gran = (gran * sizeof(float)) / sizeof(union record);
	return(gran);
}
@


11.62
log
@change conf.h to a wrapped config.h
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/conv/asc2g.c,v 11.61 2004/04/05 07:49:36 morrison Exp $ (BRL)";
@


11.61
log
@merge of ansi-6-0-branch into HEAD
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d28 5
a32 1
#include "conf.h"
@


11.60
log
@merge of windows-6-0-branch into head
@
text
@d62 7
a68 7
void		identbld(), polyhbld(), pipebld(), particlebld();
void		solbld(), arbnbld(), clinebld(), botbld(), extrbld(), sktbld();
int		combbld();
void		membbld(), arsabld(), arsbbld();
void		materbld(), bsplbld(), bsurfbld(), zap_nl();
char		*nxt_spc();
void		strsolbld(), nmgbld();
d103 1
a103 1
incr_ars_pt()
d125 1
a125 3
main(argc, argv)
int argc;
char **argv;
d317 1
a317 1
strsolbld()
d406 1
a406 1
sktbld()
d577 1
a577 1
extrbld()
d619 1
a619 1
nmgbld()
d709 1
a709 1
solbld()
d888 1
a888 1
combbld()
d1019 1
a1019 2
membbld( headp )
struct bu_list	*headp;
d1058 1
a1058 1
arsabld()
d1095 1
a1095 1
arsbbld()
d1142 1
a1142 1
zap_nl()
d1162 1
a1162 1
identbld()
d1259 1
a1259 1
polyhbld()
d1356 1
a1356 1
materbld()
d1388 1
a1388 1
bsplbld()
d1423 1
a1423 1
bsurfbld()
d1532 1
a1532 1
clinebld()
d1590 1
a1590 1
botbld()
d1681 1
a1681 1
pipebld()
d1743 1
a1743 1
particlebld()
d1779 1
a1779 1
arbnbld()
d1836 1
a1836 2
nxt_spc( cp)
register char *cp;
d1848 1
a1848 1
ngran( nfloat )
@


11.59
log
@update copyright to include span through 2003
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.58 2003/08/06 21:05:04 jra Exp $ (BRL)";
d49 3
a51 1

d130 3
@


11.58
log
@Conversion from polysolid to BOT now uses zero distance tolerance
to avoid losing facets
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1985 by the United States Army.
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.57 2003/04/01 19:23:20 jra Exp $ (BRL)";
@


11.58.4.1
log
@merge from HEAD
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.59 2004/02/02 17:38:59 morrison Exp $ (BRL)";
@


11.58.4.2
log
@merge from head
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.58.4.1 2004/02/12 19:24:22 erikg Exp $ (BRL)";
@


11.58.4.3
log
@merge from head
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d49 1
a49 3
#ifdef WIN32
#include <fcntl.h>
#endif
a127 3
#ifdef WIN32
	_fmode = _O_BINARY;
#endif
@


11.57
log
@Added a "const" to quiet the compiler
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.56 2002/11/27 13:41:40 jra Exp $ (BRL)";
d1265 1
d1325 11
a1335 1
	if( rt_pg_to_bot( &intern, &ofp->wdb_tol, &rt_uniresource ) < 0 )
@


11.57.2.1
log
@updated for merging
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.58 2003/08/06 21:05:04 jra Exp $ (BRL)";
a1264 1
	struct bn_tol	tol;
d1324 1
a1324 11

	/* this tolerance structure is only used for converting polysolids to BOT's
	 * use zero distance to avoid losing any polysolid facets
	 */
        tol.magic = BN_TOL_MAGIC;
        tol.dist = 0.0;
        tol.dist_sq = tol.dist * tol.dist;
        tol.perp = 1e-6;
        tol.para = 1 - tol.perp;

	if( rt_pg_to_bot( &intern, &tol, &rt_uniresource ) < 0 )
@


11.56
log
@BOT primitives can now have vertex normals
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.55 2002/08/20 17:07:20 jra Exp $ (BRL)";
d176 1
a176 1
			char	*av[2];
@


11.55
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.53 2002/05/17 12:48:56 morrison Exp $ (BRL)";
d1648 1
a1648 1
	mk_bot( ofp, my_name, mode, orientation, error_mode, num_vertices, num_faces,
@


11.55.4.1
log
@Survice Engineering patch to clean up the build environment and several runtime issues
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.55 2002/08/20 17:07:20 jra Exp $ (BRL)";
d49 1
a49 3
#ifdef WIN32
#include <fcntl.h>
#endif
a127 3
#ifdef WIN32
	_fmode = _O_BINARY;
#endif
@


11.55.4.2
log
@sync to HEAD...
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/conv/asc2g.c,v 11.55.4.1 2003/08/14 08:07:24 morrison Exp $ (BRL)";
d181 1
a181 1
			const char	*av[2];
a1269 1
	struct bn_tol	tol;
d1329 1
a1329 11

	/* this tolerance structure is only used for converting polysolids to BOT's
	 * use zero distance to avoid losing any polysolid facets
	 */
        tol.magic = BN_TOL_MAGIC;
        tol.dist = 0.0;
        tol.dist_sq = tol.dist * tol.dist;
        tol.perp = 1e-6;
        tol.para = 1 - tol.perp;

	if( rt_pg_to_bot( &intern, &tol, &rt_uniresource ) < 0 )
d1653 1
a1653 1
	mk_bot( ofp, my_name, mode, orientation, 0, num_vertices, num_faces,
@


11.55.2.1
log
@Initial ANSIfication
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.55 2002/08/20 17:07:20 jra Exp $ (BRL)";
d60 7
a66 7
void		identbld(void), polyhbld(void), pipebld(void), particlebld(void);
void		solbld(void), arbnbld(void), clinebld(void), botbld(void), extrbld(void), sktbld(void);
int		combbld(void);
void		membbld(struct bu_list *headp), arsabld(void), arsbbld(void);
void		materbld(void), bsplbld(void), bsurfbld(void), zap_nl(void);
char		*nxt_spc(register char *cp);
void		strsolbld(void), nmgbld(void);
d101 1
a101 1
incr_ars_pt(void)
d123 3
a125 1
main(int argc, char **argv)
d314 1
a314 1
strsolbld(void)
d403 1
a403 1
sktbld(void)
d574 1
a574 1
extrbld(void)
d616 1
a616 1
nmgbld(void)
d706 1
a706 1
solbld(void)
d885 1
a885 1
combbld(void)
d1016 2
a1017 1
membbld(struct bu_list *headp)
d1056 1
a1056 1
arsabld(void)
d1093 1
a1093 1
arsbbld(void)
d1140 1
a1140 1
zap_nl(void)
d1160 1
a1160 1
identbld(void)
d1257 1
a1257 1
polyhbld(void)
d1343 1
a1343 1
materbld(void)
d1375 1
a1375 1
bsplbld(void)
d1410 1
a1410 1
bsurfbld(void)
d1519 1
a1519 1
clinebld(void)
d1577 1
a1577 1
botbld(void)
d1668 1
a1668 1
pipebld(void)
d1730 1
a1730 1
particlebld(void)
d1766 1
a1766 1
arbnbld(void)
d1823 2
a1824 1
nxt_spc(register char *cp)
d1836 1
a1836 1
ngran(int nfloat)
@


11.55.2.2
log
@sync branch with HEAD
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d49 1
a49 3
#ifdef WIN32
#include <fcntl.h>
#endif
a125 3
#ifdef WIN32
	_fmode = _O_BINARY;
#endif
d174 1
a174 1
			const char	*av[2];
a1261 1
	struct bn_tol	tol;
d1321 1
a1321 11

	/* this tolerance structure is only used for converting polysolids to BOT's
	 * use zero distance to avoid losing any polysolid facets
	 */
        tol.magic = BN_TOL_MAGIC;
        tol.dist = 0.0;
        tol.dist_sq = tol.dist * tol.dist;
        tol.perp = 1e-6;
        tol.para = 1 - tol.perp;

	if( rt_pg_to_bot( &intern, &tol, &rt_uniresource ) < 0 )
d1645 1
a1645 1
	mk_bot( ofp, my_name, mode, orientation, 0, num_vertices, num_faces,
@


11.54
log
@Converted from K&R to ANSI C - RFH
@
text
@d60 7
a66 7
void		identbld(void), polyhbld(void), pipebld(void), particlebld(void);
void		solbld(void), arbnbld(void), clinebld(void), botbld(void), extrbld(void), sktbld(void);
int		combbld(void);
void		membbld(struct bu_list *headp), arsabld(void), arsbbld(void);
void		materbld(void), bsplbld(void), bsurfbld(void), zap_nl(void);
char		*nxt_spc(register char *cp);
void		strsolbld(void), nmgbld(void);
d101 1
a101 1
incr_ars_pt(void)
d123 3
a125 1
main(int argc, char **argv)
d314 1
a314 1
strsolbld(void)
d403 1
a403 1
sktbld(void)
d574 1
a574 1
extrbld(void)
d616 1
a616 1
nmgbld(void)
d706 1
a706 1
solbld(void)
d885 1
a885 1
combbld(void)
d1016 2
a1017 1
membbld(struct bu_list *headp)
d1056 1
a1056 1
arsabld(void)
d1093 1
a1093 1
arsbbld(void)
d1140 1
a1140 1
zap_nl(void)
d1160 1
a1160 1
identbld(void)
d1257 1
a1257 1
polyhbld(void)
d1343 1
a1343 1
materbld(void)
d1375 1
a1375 1
bsplbld(void)
d1410 1
a1410 1
bsurfbld(void)
d1519 1
a1519 1
clinebld(void)
d1577 1
a1577 1
botbld(void)
d1668 1
a1668 1
pipebld(void)
d1730 1
a1730 1
particlebld(void)
d1766 1
a1766 1
arbnbld(void)
d1823 2
a1824 1
nxt_spc(register char *cp)
d1836 1
a1836 1
ngran(int nfloat)
@


11.53
log
@added matrix parameter to mk_addmember()
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.52 2002/05/02 14:51:01 jra Exp $ (BRL)";
d60 7
a66 7
void		identbld(), polyhbld(), pipebld(), particlebld();
void		solbld(), arbnbld(), clinebld(), botbld(), extrbld(), sktbld();
int		combbld();
void		membbld(), arsabld(), arsbbld();
void		materbld(), bsplbld(), bsurfbld(), zap_nl();
char		*nxt_spc();
void		strsolbld(), nmgbld();
d101 1
a101 1
incr_ars_pt()
d123 1
a123 3
main(argc, argv)
int argc;
char **argv;
d312 1
a312 1
strsolbld()
d401 1
a401 1
sktbld()
d572 1
a572 1
extrbld()
d614 1
a614 1
nmgbld()
d704 1
a704 1
solbld()
d883 1
a883 1
combbld()
d1014 1
a1014 2
membbld( headp )
struct bu_list	*headp;
d1053 1
a1053 1
arsabld()
d1090 1
a1090 1
arsbbld()
d1137 1
a1137 1
zap_nl()
d1157 1
a1157 1
identbld()
d1254 1
a1254 1
polyhbld()
d1340 1
a1340 1
materbld()
d1372 1
a1372 1
bsplbld()
d1407 1
a1407 1
bsurfbld()
d1516 1
a1516 1
clinebld()
d1574 1
a1574 1
botbld()
d1665 1
a1665 1
pipebld()
d1727 1
a1727 1
particlebld()
d1763 1
a1763 1
arbnbld()
d1820 1
a1820 2
nxt_spc( cp)
register char *cp;
d1832 1
a1832 1
ngran( nfloat )
@


11.52
log
@Added "dbfind" as another alias to "find" in the safe interpreter. Now scripts can use "dbfind"
and be executed by both MGED and ASC2G.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.51 2002/01/08 13:41:18 jra Exp $ (BRL)";
d1041 1
a1041 1
	memb = mk_addmember( inst_name, headp, relation );
@


11.51
log
@Added "find" and "rm" commands to the interpreter
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.50 2001/11/30 15:27:33 jra Exp $ (BRL)";
d95 1
d183 3
@


11.50
log
@Minor change to recognize tcl scripts output by new Pro/E converter
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.49 2001/10/22 19:50:29 bparker Exp $ (BRL)";
d94 2
d186 1
a186 1
			bu_log( "%s\n", Tcl_GetStringResult(interp) );
@


11.49
log
@*- mods to allow only the following commands
   in a .asc file:  attr, color, put, title, units
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.48 2001/10/17 23:19:28 bparker Exp $ (BRL)";
d150 1
a150 1
	if (!strncmp(c1, "title", 5)) {
@


11.48
log
@*- mods to use safe interpreter
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.47 2001/10/10 15:48:16 butler Exp $ (BRL)";
d88 9
d145 1
a145 1
	if( fgets( c1, 3, ifp ) == NULL ) {
d149 2
a150 1
	if( !strncmp( c1, db_name, 2 ) ) {
d164 4
a167 1
		safe_interp = Tcl_CreateSlave(interp, slave_name, 1);
d171 9
a179 5
			int	ac = 0;
			char	*av[1];

			argv[0] = (char *)0;
			Tcl_CreateAlias(safe_interp, db_name, interp, db_name, ac, av);
@


11.47
log
@Implemented conversion for EBM and VOL primitives
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.46 2001/10/04 14:10:21 jra Exp $ (BRL)";
d80 2
d140 1
a140 1
	if( !strncmp( c1, "db", 2 ) ) {
d142 1
d149 1
a149 1
		if( wdb_init_obj( interp, ofp, "db" ) != TCL_OK ) {
d153 13
a165 1
		if( Tcl_EvalFile( interp, argv[1] ) != TCL_OK ) {
d170 1
@


11.46
log
@Mods to stop trying to use stdin and stdout
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.45 2001/10/02 19:24:08 jra Exp $ (BRL)";
d52 2
a53 1

d277 71
a347 35
	char	*type;
	char	*name;
	char	*args;
	struct bu_vls	str;

	bu_vls_init(&str);

	(void)strtok( buf, " " );
	/* skip stringsolid_id */
	type = strtok( NULL, " " );
	name = strtok( NULL, " " );
	args = strtok( NULL, "\n" );

	if( strcmp( type, "dsp" ) == 0 )  {
		struct rt_dsp_internal *dsp;

		BU_GETSTRUCT( dsp, rt_dsp_internal );
		bu_vls_init( &dsp->dsp_name );
		bu_vls_strcpy( &str, args );
		if( bu_struct_parse( &str, rt_functab[ID_DSP].ft_parsetab, (char *)dsp ) < 0 )  {
			bu_log("strsolbld(%s): Unable to parse %s solid's args of '%s'\n",
				name, type, args);
			rt_dsp_ifree( (struct rt_db_internal *)dsp );
			goto out;
		}
		dsp->magic = RT_DSP_INTERNAL_MAGIC;
		if( wdb_export( ofp, name, (genptr_t)dsp, ID_DSP, mk_conv2mm ) < 0 )  {
			bu_log("strsolbld(%s): Unable to export %s solid, args='%s'\n",
				name, type, args);
			goto out;
		}
		/* 'dsp' has already been freed by wdb_export() */
	} else {
		bu_log("strsolbld(%s): unable to convert '%s' type solid, skipping\n",
			name, type);
d349 5
d355 2
a356 2
out:
	bu_vls_free(&str);
@


11.45
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d7 1
a7 1
 *  Usage:  asc2g < file.asc > file.g
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.44 2001/09/18 17:33:50 jra Exp $ (BRL)";
a69 1
int 			debug;
d82 1
a82 1
 Convert an ASCII v4 BRL-CAD database to binary form\n\
d112 1
a112 2
	int c1;
	ifp = stdin;
d116 3
a118 4

	if( argc > 1 && strcmp( argv[1], "-d" ) == 0 )  {
		argc--; argv++;
		debug = 1;
d121 8
a128 16
	if( argc == 3 ) {
		if( strcmp(argv[1], "-") == 0 )
			ifp = stdin;
		else
			ifp = fopen(argv[1],"r");
		if( !ifp )  perror(argv[1]);

		ofp = wdb_fopen(argv[2]);
		if( !ofp )  perror(argv[2]);
		if (ifp == NULL || ofp == NULL) {
			(void)fprintf(stderr, "asc2g: can't open files.");
			exit(1);
		}
	} else {
		fprintf(stderr, "%s", usage);
		return 2;
d133 1
a133 2
	c1 = fgetc( ifp );
	if( c1 == EOF ) {
d137 1
a137 1
	if( c1 == 'd' ) {
d142 1
a142 1
		ungetc( c1, ifp );
d149 4
a152 27
		if( ifp == stdin ) {
			Tcl_Obj	*input_script;
			struct bu_vls	str;
			char ch_block[BUFSIZE];

			bu_vls_init( &str );

			while( fgets( ch_block, BUFSIZE, ifp ) ) {
				bu_vls_strcat( &str, ch_block );
			}

			input_script = Tcl_NewStringObj( bu_vls_addr( &str ), bu_vls_strlen( &str ) );
			bu_vls_free( &str );

			if( Tcl_EvalObjEx(interp, input_script, TCL_EVAL_DIRECT ) != TCL_OK ) {
				bu_log( "Failed to process input from stdin!!\n" );
				bu_log( "%s\n", Tcl_GetStringResult(interp) );
				bu_log( "script:\n%s\n", bu_vls_addr( &str ) );
				exit( 1 );
			}

		} else {
			if( Tcl_EvalFile( interp, argv[1] ) != TCL_OK ) {
				bu_log( "Failed to process input file (%s)!!\n", argv[1] );
				bu_log( "%s\n", Tcl_GetStringResult(interp) );
				exit( 1 );
			}
d156 1
a156 1
		ungetc( c1, ifp );
a166 2
		if( debug )
			bu_log("rec %c\n", buf[0] );
@


11.44
log
@Now recognizes Tcl scripts from new g2asc, and processes them
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.43 2001/08/10 21:22:52 butler Exp $ (BRL)";
d1276 1
@


11.43
log
@Compiler warning patches
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.42 2001/03/23 22:33:31 butler Exp $ (BRL)";
d113 1
d143 50
@


11.42
log
@Changes to support new DSP primitive representation
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /n/tgm/d/CVS/brlcad/conv/asc2g.c,v 11.41 2001/03/20 16:08:36 jra Exp $ (BRL)";
d570 1
a570 1
		int cp_i;
@


11.41
log
@ft_import5() and ft_export5() now have a const int minor_type argument
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/conv/asc2g.c,v 11.40 2001/03/19 22:19:19 butler Exp $ (BRL)";
d279 1
a279 1
		bu_vls_init( &dsp->dsp_file );
@


11.40
log
@patches to merge 5.3 into 6.0
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/conv/asc2g.c,v 11.39 2000/11/17 15:57:40 jra Exp $ (BRL)";
d587 1
a587 1
	if( rt_functab[ID_NMG].ft_import5( &intern, &ext, bn_mat_identity, ofp->dbip, &rt_uniresource ) < 0 )  {
@


11.39
log
@shader parameters were being copied using strncpy() (Does not append a NULL!!!!)
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.38 2000/10/19 19:19:44 butler Exp $ (BRL)";
d879 1
a879 1
		bzero( matname, sizeof( matname ) );
d885 1
a885 1
		bzero( matparm, sizeof( matparm ) );
@


11.38
log
@Changes to compile under RedHat 7.0
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.37 2000/09/14 20:20:21 jra Exp $ (BRL)";
d879 1
d885 1
@


11.37
log
@Added support for ARS solid (v5)
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.36 2000/09/08 05:55:41 mike Exp $ (BRL)";
d51 4
d277 1
d284 1
a284 1
			rt_dsp_ifree( dsp );
@


11.36
log
@
Tree routines now need resource structure.
Added rt_init_resource() call.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.35 2000/08/31 01:02:37 mike Exp $ (BRL)";
d70 6
d82 19
d956 3
a958 3
#if 0
	register char *cp;
	register char *np;
d960 2
a962 4
	record.a.a_id = *cp++;
	cp = nxt_spc( cp );		/* skip the space */

	record.a.a_type = (char)atoi( cp );
a963 5

	np = record.a.a_name;
	while( *cp != ' ' )  {
		*np++ = *cp++;
	}
d966 5
a970 7
	record.a.a_m = (short)atoi( cp );
	cp = nxt_spc( cp );
	record.a.a_n = (short)atoi( cp );
	cp = nxt_spc( cp );
	record.a.a_curlen = (short)atoi( cp );
	cp = nxt_spc( cp );
	record.a.a_totlen = (short)atoi( cp );
d972 1
d974 6
a979 11
	record.a.a_xmax = atof( cp );
	cp = nxt_spc( cp );
	record.a.a_xmin = atof( cp );
	cp = nxt_spc( cp );
	record.a.a_ymax = atof( cp );
	cp = nxt_spc( cp );
	record.a.a_ymin = atof( cp );
	cp = nxt_spc( cp );
	record.a.a_zmax = atof( cp );
	cp = nxt_spc( cp );
	record.a.a_zmin = atof( cp );
d981 2
a982 5
	/* Write out the record */
	(void)fwrite( (char *)&record, sizeof record, 1, ofp );
#else
	bu_bomb("arsabld() needs to be upgraded to v5\n");
#endif
d993 3
a995 3
#if 0
	register char *cp;
	register int i;
a997 1
	record.b.b_id = *cp++;
a998 2

	record.b.b_type = (char)atoi( cp );
a999 1
	record.b.b_n = (short)atoi( cp );
d1001 9
a1009 1
	record.b.b_ngranule = (short)atoi( cp );
d1011 16
a1026 3
	for( i = 0; i < 24; i++ )  {
		cp = nxt_spc( cp );
		record.b.b_values[i] = atof( cp );
a1027 6

	/* Write out the record */
	(void)fwrite( (char *)&record, sizeof record, 1, ofp );
#else
	bu_bomb("arbbbld() needs to be upgraded to v5\n");
#endif
@


11.35
log
@
When converting combinations, must use GIFT semantics!
This was showing up as an error in the benchmark test 'star'
(missing r16) and 'bldg391'.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.34 2000/08/24 03:00:42 mike Exp $ (BRL)";
d112 2
d557 1
a557 1
	if( rt_functab[ID_NMG].ft_import5( &intern, &ext, bn_mat_identity, ofp->dbip ) < 0 )  {
d1201 1
a1201 1
	if( rt_pg_to_bot( &intern, &ofp->wdb_tol ) < 0 )
@


11.34
log
@
new mk_comb
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.33 2000/08/15 02:42:19 mike Exp $ (BRL)";
d866 1
a866 1
	/* Spit them out, all at once */
d871 1
a871 1
		regionid, aircode, material, los, inherit, 0, 0) < 0 )  {
@


11.33
log
@
Modified to take "-" to represent stdin.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.32 2000/08/11 00:44:58 mike Exp $ (BRL)";
a230 1
	register char *cp;
d760 1
a760 1
	struct wmember	head;
d778 1
a778 1
	BU_LIST_INIT( &head.l );
d867 1
a867 1
	if( mk_lrcomb(ofp, name, &head, is_reg,
d871 1
a871 1
		regionid, aircode, material, los, inherit) < 0 )  {
d888 1
a888 1
struct wmember	*headp;
a1139 1
	struct rt_pg_face_internal	*face;
@


11.32
log
@
Added support for DSP solid
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.31 2000/08/10 05:02:31 mike Exp $ (BRL)";
d76 3
d95 4
a98 1
		ifp = fopen(argv[1],"r");
d100 1
@


11.31
log
@
Removed obsolete polydbld() routine.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.30 2000/08/10 04:57:51 mike Exp $ (BRL)";
d214 6
a223 1
#if 0
d225 34
a258 11
	register char *np;
	char keyword[10];
	char name[NAME_LEN+1];

	cp = buf;

	if( *cp != DBID_STRSOL )
	{
		bu_log( "asc2g: expecting STRSOL, found '%c' (0%o) (skipping)\n" , buf[0], buf[0] );
		bu_log( "%s\n" , buf );
		return;
d261 2
a262 24
	cp = nxt_spc( cp );
	np = keyword;
	while( *cp != ' ' )
		*np++ = *cp++;
	*np = '\0';

	cp = nxt_spc( cp );
	np = name;
	while( *cp != ' ' )
		*np++ = *cp++;
	*np = '\0';

	cp = nxt_spc( cp );

	/* Zap the trailing newline */
	cp[strlen(cp)-1] = '\0';

	if( mk_strsol( ofp, name, keyword, cp ) )  {
		bu_log("asc2g(%s) couldn't convert %s type solid\n",
			name, keyword );
	}
#else
	bu_bomb("strsolbld() needs to be upgraded to v5\n");
#endif
@


11.30
log
@
Added code to read in polysolids and handle them.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.29 2000/08/10 03:20:56 mike Exp $ (BRL)";
d55 1
a55 1
void		identbld(), polyhbld(), polydbld(), pipebld(), particlebld();
d141 1
a141 1
			polydbld();
a1200 42
/*		P O L Y D B L D
 *
 * This routine builds a polydata record using libwdb.
 */

void
polydbld()
{
#if 0
	register char	*cp;
	register int	i, j;
	char		count;		/* number of vertices */
	fastf_t		verts[5][3];	/* vertices for the polygon */
	fastf_t		norms[5][3];	/* normals at each vertex */

	cp = buf;
	cp++;				/* ident */
	cp = nxt_spc( cp );		/* skip the space */

	count = (char)atoi( cp );

	for( i = 0; i < 5; i++ )  {
		for( j = 0; j < 3; j++ )  {
			cp = nxt_spc( cp );
			verts[i][j] = atof( cp );
		}
	}

	for( i = 0; i < 5; i++ )  {
		for( j = 0; j < 3; j++ )  {
			cp = nxt_spc( cp );
			norms[i][j] = atof( cp );
		}
	}

	mk_poly(ofp, count, verts, norms);
#else
	bu_bomb("polydbld() needs to be upgraded to v5\n");
#endif
}


d1203 1
a1203 1
 * The need for this is being phased out. Leave alone.
@


11.29
log
@
Added ability to process an NMG.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.28 2000/08/09 19:35:38 mike Exp $ (BRL)";
d1112 6
a1117 1
 *  This routine builds the record headder for a polysolid.
d1123 7
a1129 2
#if 0
	/* Headder for polysolid */
d1131 45
a1175 2
	register char	*cp;
	register char	*np;
d1177 4
a1180 7
	cp = buf;
	cp++;				/* ident */
	cp = nxt_spc( cp );		/* skip the space */

	np = name;
	while( *cp != '\n' && *cp != '\0' )  {
		*np++ = *cp++;
a1181 1
	*np = '\0';
d1183 16
a1198 4
	mk_polysolid(ofp, name);
#else
	bu_bomb("bsrfbld() needs to be upgraded to v5\n");
#endif
@


11.28
log
@
Added check for being invoked with no args.
Fixed lint.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.27 2000/07/26 17:17:56 mike Exp $ (BRL)";
d42 1
d83 2
a84 5
#if 0
(void)fprintf(stderr, "About to call bu_log\n");
bu_log("Hello cold cruel world!\n");
(void)fprintf(stderr, "About to begin\n");
#endif
d463 13
a478 1
#if 0
d480 34
a513 10
	int cp_i;
	char *ptr;
	char nmg_id;
	int version;
	char name[NAMESIZE+1];
	long granules,struct_count[26];
	int i;
	long j;

	if( sizeof( union record )%32 )
d515 4
a518 2
		bu_log( "asc2g: nmgbld() will only work with union records with size multipe of 32\n" );
		exit( -1 );
d521 12
a532 2
	cp = buf;
	sscanf( buf , "%c %d %s %ld" , &nmg_id, &version, name, &granules );
d534 5
a538 4
	if( fgets( buf, BUFSIZE, ifp ) == (char *)0 )
	{
		bu_log( "Unexpected EOF while reading NMG data\n" );
		exit( -1 );
d541 5
a545 5
	ptr = strtok( buf , " " );
	for( i=0 ; i<26 ; i++ )
	{
		struct_count[i] = atof( ptr );
		ptr = strtok( (char *)NULL , " " );
d547 1
d549 2
a550 6
	record.nmg.N_id = nmg_id;
	record.nmg.N_version = version;
	strncpy( record.nmg.N_name , name , NAMESIZE );
	bu_plong( record.nmg.N_count , granules );
	for( i=0 ; i<26 ; i++ )
		bu_plong( &record.nmg.N_structs[i*4] , struct_count[i] );
d552 4
a555 2
	/* write out first record */
	(void)fwrite( (char *)&record , sizeof( union record ) , 1 , ofp );
d557 1
a557 25
	/* read and write the remaining granules */
	for( j=0 ; j<granules ; j++ )
	{
		cp = (char *)&record;
		for( i=0 ; i<sizeof( union record )/32 ; i++ )
		{
			int k;

			if( fgets( buf, BUFSIZE, ifp ) == (char *)0 )
			{
				bu_log( "Unexpected EOF while reading NMG data\n" );
				exit( -1 );
			}

			for( k=0 ; k<32 ; k++ )
			{
				sscanf( &buf[k*2] , "%2x" , &cp_i );
				*cp++ = cp_i;
			}
		}
		(void)fwrite( (char *)&record , sizeof( union record ) , 1 , ofp );
	}
#else
	bu_bomb("nmgbld() needs to be upgraded to v5\n");
#endif
@


11.27
log
@
Improvements in v4->v5 converstion.  Auto conversion of shader strings.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.26 2000/07/25 22:40:47 mike Exp $ (BRL)";
d88 1
a88 1
	if( strcmp( argv[1], "-d" ) == 0 )  {
a1168 1
	int	flags;			/* unused */
d1176 1
a1176 1
	flags = (char)atoi( cp );
@


11.26
log
@
libwdb additions for writing NMGs at BoTs.
Initial support for writing region-id-based-color table.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.25 2000/07/25 18:36:35 mike Exp $ (BRL)";
d72 1
a72 1
 Convert an ASCII BRL-CAD database to binary form\n\
a207 1
if(rt_material_head) rt_pr_mater(rt_material_head);
@


11.25
log
@
Fixed libwdb type change.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.24 2000/07/13 02:28:51 mike Exp $ (BRL)";
d208 1
@


11.24
log
@
Added helpful suggestion
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.23 2000/07/13 01:48:42 mike Exp $ (BRL)";
d1499 1
a1499 1
	struct wdb_pipept	head;
d1516 1
a1516 1
	BU_LIST_INIT( &head.l );
d1539 1
a1539 1
		BU_LIST_INSERT( &head.l, &sp->l);
@


11.23
log
@
Partial conversion to new LIBWDB interface.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.22 2000/07/12 21:59:34 mike Exp $ (BRL)";
d1038 1
@


11.22
log
@
Converted to use new version of LIBWDB
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.21 2000/07/12 04:23:17 mike Exp $ (BRL)";
d75 1
d209 1
a209 1
	fclose(ofp);
d220 1
d256 3
d468 1
d533 3
d895 1
d935 3
a937 1

d948 1
d969 3
a971 1

d1095 1
a1095 1

d1112 3
d1125 1
d1153 3
d1200 1
d1222 3
d1235 1
d1333 3
@


11.21
log
@
Collect up region-id-based color table, and spew it at the end of
the file.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.20 2000/07/12 03:49:10 mike Exp $ (BRL)";
d68 1
a68 1
FILE	*ofp;
d71 1
a71 2
Usage: asc2g < file.asc > file.g\n\
   or  asc2g file.asc file.g\n\
a79 1
	ofp = stdout;
d87 2
a88 1
	if( argc == 2 || argc == 4 )
d90 1
d92 1
a92 1
	if( argc >= 3 ) {
d95 1
a95 1
		ofp = fopen(argv[2],"w");
d101 3
a103 4
	}
	if (isatty(fileno(ofp))) {
		(void)fprintf(stderr, usage);
		exit(1);
@


11.20
log
@
Header file order
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.19 2000/07/11 03:56:37 mike Exp $ (BRL)";
d47 1
d204 7
a1145 1

d1147 3
d1152 1
a1152 1
	record.md.md_id = *cp++;
d1155 1
a1155 1
	record.md.md_flags = (char)atoi( cp );
d1157 1
a1157 1
	record.md.md_low = (short)atoi( cp );
d1159 1
a1159 1
	record.md.md_hi = (short)atoi( cp );
d1161 1
a1161 1
	record.md.md_r = (unsigned char)atoi( cp);
d1163 1
a1163 1
	record.md.md_g = (unsigned char)atoi( cp);
d1165 1
a1165 1
	record.md.md_b = (unsigned char)atoi( cp);
d1167 2
a1168 2
	/* Write out the record */
	(void)fwrite( (char *)&record, sizeof record, 1, ofp );
d1629 1
@


11.19
log
@
Sending forth code 'none' isn't very useful for v5.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.18 2000/07/11 02:42:52 mike Exp $ (BRL)";
d39 1
d41 1
a41 1
#include "rtlist.h"
a46 1
#include "externs.h"
@


11.18
log
@
Improved error handling
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.17 2000/07/10 23:53:55 mike Exp $ (BRL)";
d988 1
d1018 1
a1018 1
		unit_str = "none";
d1048 1
a1048 1
		fprintf(stderr,"asc2g: unknown units = %d\n", units);
d1051 6
d1058 1
a1058 1
	if( mk_id_units(ofp, title, unit_str) < 0 )  {
@


11.17
log
@
lint
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.16 2000/05/23 01:46:58 mike Exp $ (BRL)";
d822 2
a823 2
			fprintf(stderr,"asc2g: mk_rcomb fail\n");
			exit(1);
@


11.16
log
@
added logic to asc2g to create proper values for that 'region'
argument in an expandable way.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.15 2000/03/16 13:39:10 jra Exp $ (BRL)";
@


11.16.2.1
log
@Material parameters were being copied using strncpy() (does not append a NULL!!!!)
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.16 2000/05/23 01:46:58 mike Exp $ (BRL)";
a796 1
		bzero( matname, sizeof(matname) );
a801 1
		bzero( matparm, sizeof(matparm) );
@


11.15
log
@Sketch solid can only have one curve now
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.14 2000/03/04 05:54:40 mike Exp $ (BRL)";
d777 14
a790 4
	/* XXX Need support for P and V, for FASTGEN */
	if( reg_flags == 'Y' )
		is_reg = 1;
	else
d792 1
@


11.14
log
@
Added support for FASTGEN PLATE and VOLUME mode regions,
which are special cases of the orginary BRL-CAD region.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.13 2000/03/02 15:48:25 jra Exp $ (BRL)";
d257 2
a258 2
	int i;
	int vert_count, curve_count;
d265 1
d276 5
a280 1
		name, &fV[0], &fV[1], &fV[2], &fu[0], &fu[1], &fu[2], &fv[0], &fv[1], &fv[2], &vert_count, &curve_count );
d320 13
a332 4
	skt = (struct rt_sketch_internal *)sketch_start( V, u, v );
	(void)sketch_add_verts( skt, vert_count, verts );

	for( i=0 ; i<curve_count ; i++ )
d334 2
a335 2
		int j;
		struct curve crv;
d343 2
a344 6
		cp = buf+1;
		bzero( &crv, sizeof( struct curve ) );
		sscanf( cp, "%s %d", crv.crv_name, &crv.seg_count );
		crv.segments = (genptr_t *)bu_calloc( crv.seg_count, sizeof( genptr_t ), "segments" );
		crv.reverse = (int *)bu_calloc( crv.seg_count, sizeof( int ), "reverse" );
		for( j=0 ; j<crv.seg_count ; j++ )
d346 37
a382 40
			double radius;
			int k;

			if( fgets( buf, BUFSIZE, ifp ) == (char *)0 )
			{
				bu_log( "Unexpected EOF while reading sketch (%s) data\n", name );
				exit( -1 );
			}

			cp = buf + 2;
			switch( *cp )
			{
				case LSEG:
					lsg = (struct line_seg *)bu_malloc( sizeof( struct line_seg ), "line segment" );
					sscanf( cp+1, "%d %d %d", &crv.reverse[j], &lsg->start, &lsg->end );
					lsg->magic = CURVE_LSEG_MAGIC;
					crv.segments[j] = lsg;
					break;
				case CARC:
					csg = (struct carc_seg *)bu_malloc( sizeof( struct carc_seg ), "arc segment" );
					sscanf( cp+1, "%d %d %d %lf %d %d", &crv.reverse[j], &csg->start, &csg->end,
						&radius, &csg->center_is_left, &csg->orientation );
					csg->radius = radius;
					csg->magic = CURVE_CARC_MAGIC;
					crv.segments[j] = csg;
					break;
				case NURB:
					nsg = (struct nurb_seg *)bu_malloc( sizeof( struct nurb_seg ), "nurb segment" );
					sscanf( cp+1, "%d %d %d %d %d", &crv.reverse[j], &nsg->order, &nsg->pt_type,
						&nsg->k.k_size, &nsg->c_size );
					nsg->k.knots = (fastf_t *)bu_calloc( nsg->k.k_size, sizeof( fastf_t ), "knots" );
					nsg->ctl_points = (int *)bu_calloc( nsg->c_size, sizeof( int ), "control points" );
					if( fgets( buf, BUFSIZE, ifp ) == (char *)0 )
					{
						bu_log( "Unexpected EOF while reading sketch (%s) data\n", name );
						exit( -1 );
					}
					cp = buf + 3;
					ptr = strtok( cp, " " );
					if( !ptr )
d384 1
a384 1
						bu_log( "ERROR: not enough knots for nurb segment of curve (%s) in sketch (%s)!!!\n", crv.crv_name, name );
d387 18
a404 18
					for( k=0 ; k<nsg->k.k_size ; k++ )
					{
						nsg->k.knots[k] = atof( ptr );
						ptr = strtok( (char *)NULL, " " );
						if( !ptr && k<nsg->k.k_size-1 )
						{
							bu_log( "ERROR: not enough knots for nurb segment of curve (%s) in sketch (%s)!!!\n", crv.crv_name, name );
							exit( 1 );
						}
					}
					if( fgets( buf, BUFSIZE, ifp ) == (char *)0 )
					{
						bu_log( "Unexpected EOF while reading sketch (%s) data\n", name );
						exit( -1 );
					}
					cp = buf + 3;
					ptr = strtok( cp, " " );
					if( !ptr )
d406 1
a406 1
						bu_log( "ERROR: not enough control points for nurb segment of curve (%s) in sketch (%s)!!!\n", crv.crv_name, name );
d409 8
a416 18
					for( k=0 ; k<nsg->c_size ; k++ )
					{
						nsg->ctl_points[k] = atoi( ptr );
						ptr = strtok( (char *)NULL, " " );
						if( !ptr && k<nsg->c_size-1 )
						{
							bu_log( "ERROR: not enough control points for nurb segment of curve (%s) in sketch (%s)!!!\n", crv.crv_name, name );
							exit( 1 );
						}
					}
					nsg->magic = CURVE_NURB_MAGIC;
					crv.segments[j] = nsg;
					break;
				default:
					bu_log( "Unrecognized segment type (%c) in sketch (%s), curve (%s)!!!\n",
						*cp, name, crv.crv_name );
					exit( 1 );
			}
a418 24
		(void)sketch_add_curve( skt, &crv );

		/* now free the temporary memory */
		for( i=0 ; i<curve_count ; i++ )
		{
			long *lng;

			lng = (long *)crv.segments[i];
			switch( *lng )
			{
				case CURVE_NURB_MAGIC:
					nsg = (struct nurb_seg *)lng;
					bu_free( nsg->k.knots, "knots" );
					bu_free( nsg->ctl_points, "control points" );
				case CURVE_LSEG_MAGIC:
				case CURVE_CARC_MAGIC:
					bu_free( crv.segments[i], "segment" );
					break;
				default:
					bu_log( "Unrecognized segment type in sketch (%s), curve (%s)!!!\n",
						*cp, name, crv.crv_name );
					exit( 1 );
			}
		}
a429 1
	char curve_name[NAMESIZE+1];
d442 2
a443 2
	(void)sscanf( cp, "%s %s %s %d %f %f %f  %f %f %f %f %f %f %f %f %f",
		name, sketch_name, curve_name, &keypoint, &fV[0], &fV[1], &fV[2], &fh[0], &fh[1], &fh[2],
d450 1
a450 1
	(void)mk_extrusion( ofp, name, sketch_name, curve_name, V, h, u_vec, v_vec, keypoint );
@


11.13
log
@Eliminated some unused variables
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.12 2000/03/02 14:39:39 jra Exp $ (BRL)";
d765 1
a765 1
	reg_flags = *cp++;
d805 1
@


11.12
log
@Eliminated FGP solid and added CLINE solid
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.11 2000/02/02 21:13:02 jra Exp $ (BRL)";
a256 2
	int skt_id;
	int ret;
d271 1
a271 1
	skt_id = *cp++;
d274 1
a274 1
	ret = sscanf( cp, "%s %f %f %f %f %f %f %f %f %f %d %d",
a454 1
	int extr_id;
a463 1
	int ret;
d467 1
a467 1
	extr_id = *cp++;
d470 1
a470 1
	ret = sscanf( cp, "%s %s %s %d %f %f %f  %f %f %f %f %f %f %f %f %f",
@


11.11
log
@support for extrusion and sketch
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.10 1999/11/16 19:12:45 mike Exp $ (BRL)";
d54 1
a54 1
void		solbld(), arbnbld(), fgpbld(), botbld(), extrbld(), sktbld();
d181 2
a182 2
		case DBID_FGP:
			fgpbld();
d1312 1
a1312 1
/*		F G P B L D
d1316 1
a1316 1
fgpbld()
a1318 1
	char			ref_name[NAME_LEN];
d1320 3
a1322 1
	int			mode;
d1337 21
a1357 4
	np = ref_name;
	while( *cp != ' ' && *cp != '\n' )
		*np++ = *cp++;
	*np = '\0';
d1361 1
a1361 1
	thickness = atof( cp );
d1365 1
a1365 1
	mode = atoi( cp );
d1367 1
a1367 1
	mk_fgp( ofp, my_name, ref_name, thickness, mode );
@


11.10
log
@
Fixed lint problem on line 1123.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.9 1999/11/09 15:42:40 jra Exp $ (BRL)";
d54 1
a54 1
void		solbld(), arbnbld(), fgpbld(), botbld();
d189 8
d247 236
@


11.9
log
@Added support for BOT solid.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.8 1999/10/12 13:58:11 jra Exp $ (BRL)";
d1115 2
a1116 1
	int			type, mode, orientation, error_mode, num_vertices, num_faces;
@


11.8
log
@Added fgp solid (FastGen Plate mode)
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.7 1999/06/03 21:54:19 mike Exp $ (BRL)";
d54 1
a54 1
void		solbld(), arbnbld(), fgpbld();
d185 4
d1106 87
@


11.7
log
@
sed4
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.6 1998/09/14 15:58:50 bparker Exp $ (BRL)";
d51 1
a51 1
#define NAMELEN			20
d54 1
a54 1
void		solbld(), arbnbld();
d181 4
d203 1
a203 1
	char name[NAMELEN+1];
d1064 40
d1114 1
a1114 1
	char			name[NAMELEN];
d1176 1
a1176 1
	char		name[NAMELEN];
d1212 1
a1212 1
	char		name[NAMELEN];
@


11.6
log
@*- fix typos
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/asc2g.c,v 11.5 1997/12/16 00:27:13 mike Exp $ (BRL)";
d83 2
a84 2
(void)fprintf(stderr, "About to call rt_log\n");
rt_log("Hello cold cruel world!\n");
d115 1
a115 1
			rt_log("rec %c\n", buf[0] );
d126 1
a126 1
			rt_log("Warning: unattached Member record, ignored\n");
d182 2
a183 2
			rt_log("asc2g: bad record type '%c' (0%o), skipping\n", buf[0], buf[0]);
			rt_log("%s\n", buf );
d205 2
a206 2
		rt_log( "asc2g: expecting STRSOL, found '%c' (0%o) (skipping)\n" , buf[0], buf[0] );
		rt_log( "%s\n" , buf );
d228 1
a228 1
		rt_log("asc2g(%s) couldn't convert %s type solid\n",
d248 1
a248 1
		rt_log( "asc2g: nmgbld() will only work with union records with size multipe of 32\n" );
d257 1
a257 1
		rt_log( "Unexpected EOF while reading NMG data\n" );
d271 1
a271 1
	rt_plong( record.nmg.N_count , granules );
d273 1
a273 1
		rt_plong( &record.nmg.N_structs[i*4] , struct_count[i] );
d288 1
a288 1
				rt_log( "Unexpected EOF while reading NMG data\n" );
d467 1
a467 1
			rt_log("asc2g: bad solid %s s_type= %d, skipping\n",
d508 1
a508 1
	RT_LIST_INIT( &head.l );
d775 1
a775 1
		rt_log("WARNING:  input file version (%s) is not %s\n",
d820 1
a820 1
		rt_log("asc2g: unable to write database ID\n");
d1021 1
a1021 1
		rt_log( "asc2g: spline knot malloc error\n");
d1041 1
a1041 1
		rt_log( "asc2g: control mesh malloc error\n");
d1091 1
a1091 1
	RT_LIST_INIT( &head.l );
d1114 1
a1114 1
		RT_LIST_INSERT( &head.l, &sp->l);
d1191 1
a1191 1
/*rt_log("neqn = %d\n", neqn);
d1195 1
a1195 1
		rt_log("asc2g: warning: %d equations counted for arbn %s\n", neqn, name);
d1198 1
a1198 1
/*rt_log("mallocing space for eqns\n");
d1202 1
a1202 1
		rt_log("asc2g: malloc failure for arbn\n");
d1208 1
a1208 1
/*rt_log("starting to dump eqns\n");
d1216 1
a1216 1
/*rt_log("sending info to mk_arbn\n");
@


11.5
log
@bu_semaphore_xxx() routines don't need to be initialized any more.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 11.4 1997/06/19 19:30:22 jra Exp mike $ (BRL)";
d253 1
a253 1
	sscanf( buf , "%c %d %s %d" , &nmg_id, &version, name, &granules );
@


11.4
log
@Added support for GRIP solid.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 11.3 1997/06/13 23:37:17 mike Exp jra $ (BRL)";
a80 11

#if 0
	/*  Because LIBWDB uses LIBRT routines (esp. rt_log), must init */
	rt_g.rtg_parallel = 0;
	RES_INIT( &rt_g.res_syscall );
	RES_INIT( &rt_g.res_worker );
	RES_INIT( &rt_g.res_stats );
	RES_INIT( &rt_g.res_results );
	RES_INIT( &rt_g.res_model );
	/* Do not use rt_log() or rt_malloc() before here. */
#endif
@


11.3
log
@Added entries for the rest of the i_units fields.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 11.2 1995/08/18 19:24:35 jra Exp mike $ (BRL)";
d360 6
@


11.2
log
@Mods for new pipe solid.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 11.1 1995/01/04 09:59:19 mike Rel4_4 jra $ (BRL)";
d795 3
d804 3
d812 6
@


11.1
log
@Release_4.4
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 10.11 94/11/05 02:37:55 mike Exp $ (BRL)";
d1056 1
a1056 1
 *  linked list of pipe segments, and sends this list to mk_pipe().
a1063 5
	char			type[TYPELEN];
	fastf_t			id;
	fastf_t			od;
	point_t			start;
	point_t			bendcenter;
d1066 2
a1067 2
	struct wdb_pipeseg	*sp;
	struct wdb_pipeseg	head;
d1085 4
a1088 10
	do{
		fgets( buf, BUFSIZE, ifp);
		(void)sscanf( buf, "%s %le %le %le %le %le %le %le %le", type, 
				&id, &od,
				&start[0],
				&start[1],
				&start[2],
				&bendcenter[0],
				&bendcenter[1],
				&bendcenter[2]);
d1090 2
a1091 2
		if( (sp = (struct wdb_pipeseg *)malloc(sizeof(struct wdb_pipeseg) ) )
			== WDB_PIPESEG_NULL)  {
d1096 10
a1105 15
		sp->ps_id = id;
		sp->ps_od = od;
		VMOVE(sp->ps_start, start);

		/* Identify type */
		if( ((strcmp( type, "end" ))) == 0)  {
			sp->ps_type = WDB_PIPESEG_TYPE_END;
		} else if( ((strcmp( type, "linear" ))) == 0)  {
			sp->ps_type = WDB_PIPESEG_TYPE_LINEAR;
		} else if( ((strcmp( type, "bend"))) == 0)  {
			sp->ps_type = WDB_PIPESEG_TYPE_BEND;
			VMOVE(sp->ps_bendcenter, bendcenter);
		} else  {
			rt_log("asc2g: no pipe type %s\n", type);
		}
d1108 2
a1109 1
	} while( ((strcmp (type , "end"))) != 0);
a1112 1
	free( (char *)sp );
@


10.11
log
@Irix 6
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 10.10 94/10/28 17:46:00 mike Exp Locker: mike $ (BRL)";
@


10.10
log
@Zap trailing newline on string solids.
Eliminated knowledge of string solid internals.
rgb values are unsigned now.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 10.9 94/10/19 23:42:45 mike Exp Locker: mike $ (BRL)";
a210 1
	struct rt_vls vls;
a325 1
	char	s_id;			/* id code for the record */
a326 1
	short	s_cgtype;		/* comgeom solid type */
d331 1
a331 2
	point_t	min, max;
	vect_t	a, b, c, d, n, r1, r2;	/* various vectors required */
d337 1
a337 1
	s_id = *cp++;
d339 1
a340 1
	s_type = (char)atoi( cp );
d350 1
a350 1
	s_cgtype = (short)atoi( cp );
a500 1
	char		id;		/* == ID_COMB */
a504 2
	short		length;		/* DEPRECTED: number of members expected */
	short		num;		/* DEPRECATED: Comgeom reference number */
d519 1
a519 1
	id = *cp++;			/* ID_COMB */
d537 1
a537 1
	length = (short)atoi( cp );		/* unused */
d539 1
a539 1
	num = (short)atoi( cp );		/* unused */
a615 1
	char		id;
d621 1
a621 1
	id = *cp++;
a651 2


a653 2
	point_t	      max[3];
	point_t	      min[3];
a703 1
	point_t	      pnt[8];		/* need 8 points */
a756 1
	char		id;		/* a freebie */
d763 1
a763 1
	id = *cp++;
a831 1
	char		id;
d834 1
a834 1
	id = *cp++;
a855 1
	char		id;
d861 1
a861 1
	id = *cp++;
a893 1
	register char *np;
a924 1
	char		id;
d929 1
a929 1
	id = *cp++;
a1063 1
	char			ident;
a1064 1
	int			ret;
d1077 1
a1077 1
	ident = *cp++;			/* not used later */
d1112 1
a1112 1
		if( (ret = (strcmp( type, "end" ))) == 0)  {
d1114 1
a1114 1
		} else if( (ret = (strcmp( type, "linear" ))) == 0)  {
d1116 1
a1116 1
		} else if( (ret = (strcmp( type, "bend"))) == 0)  {
d1124 1
a1124 1
	} while( (ret = (strcmp (type , "end"))) != 0);
a1142 1
	char		type[TYPELEN];
a1146 2
	register char	*cp;
	register char	*np;
a1177 1
	char		ident;
a1178 1
	int		ret;
d1188 1
a1188 1
	ident = *cp++;				/* not used later */
@


10.9
log
@Improved string solid support.
Handled mk_arb8() prototype problem.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 10.8 94/10/17 16:51:33 mike Exp Locker: mike $ (BRL)";
d201 3
a203 34
/* XXX structparse for EBM and VOL taken from g_ebm.c and g_vol.c, should be kept in just one place */
#define RT_EBM_O(m)	offsetof(struct rt_ebm_internal, m)

struct structparse ebm_parse[] = {
#if CRAY && !__STDC__
	{"%s",	RT_EBM_NAME_LEN, "file",	1,	FUNC_NULL },
#else
	{"%s",	RT_EBM_NAME_LEN, "file", offsetofarray(struct rt_ebm_internal, file), FUNC_NULL },
#endif
	{"%d",	1, "w",		RT_EBM_O(xdim),		FUNC_NULL },
	{"%d",	1, "n",		RT_EBM_O(ydim),		FUNC_NULL },
	{"%f",	1, "d",		RT_EBM_O(tallness),	FUNC_NULL },
	{"%f",	16, "mat", offsetofarray(struct rt_ebm_internal, mat), FUNC_NULL },
	{"",	0, (char *)0, 0,			FUNC_NULL }
};

#define VOL_O(m)	offsetof(struct rt_vol_internal, m)

struct structparse vol_parse[] = {
#if CRAY && !__STDC__
	{"%s",	RT_VOL_NAME_LEN, "file",	1,		FUNC_NULL },
#else
	{"%s",	RT_VOL_NAME_LEN, "file",	offsetofarray(struct rt_vol_internal, file), FUNC_NULL },
#endif
	{"%d",	1, "w",		VOL_O(xdim),	FUNC_NULL },
	{"%d",	1, "n",		VOL_O(ydim),	FUNC_NULL },
	{"%d",	1, "d",		VOL_O(zdim),	FUNC_NULL },
	{"%d",	1, "lo",	VOL_O(lo),		FUNC_NULL },
	{"%d",	1, "hi",	VOL_O(hi),		FUNC_NULL },
	{"%f",	ELEMENTS_PER_VECT, "size",offsetofarray(struct rt_vol_internal, cellsize), FUNC_NULL },
	{"%f",	16, "mat", offsetofarray(struct rt_vol_internal,mat), FUNC_NULL },
	{"",	0, (char *)0,	0,			FUNC_NULL }
};

d236 2
a237 5
/* XXX This block of code could easily be disposed of */
#if 1
	if( !strcmp( keyword , "ebm" ) )
	{
		struct rt_ebm_internal ebm;
d239 3
a241 11
		mat_idn( ebm.mat );
		rt_vls_init( &vls );
		rt_vls_strcat( &vls , cp );
		rt_structparse( &vls , ebm_parse , (char *)&ebm );
		ebm.magic =  RT_EBM_INTERNAL_MAGIC;
		if( mk_export_fwrite( ofp , name , (genptr_t)&ebm , ID_EBM ) )
		{
			rt_log( "asc2g: Failed to convert EBM solid\n" );
			rt_log( "buf=%s\n" , buf );
		}
		rt_vls_free( &vls );
a242 25
	else if( !strcmp( keyword , "vol" ) )
	{
		struct rt_vol_internal vol;

		mat_idn( vol.mat );
		VSET( vol.cellsize , 1 , 1 , 1 );
		rt_vls_init( &vls );
		rt_vls_strcat( &vls , cp );
		rt_structparse( &vls , vol_parse , (char *)&vol );
		vol.magic =  RT_VOL_INTERNAL_MAGIC;
		if( mk_export_fwrite( ofp , name , (genptr_t)&vol , ID_VOL ) )
		{
			rt_log( "asc2g: Failed to convert VOL solid\n" );
			rt_log( "buf=%s\n" , buf );
		}
		rt_vls_free( &vls );
	}
	else
#endif
	{
		if( mk_strsol( ofp, name, keyword, cp ) )  {
			rt_log("asc2g(%s) couldn't convert %s type solid\n",
				name, keyword );
		}
	}
d600 1
a600 1
		override ? (char *)rgb : (char *)0,
@


10.8
log
@Added proper declarations for strsolbld(), nmgbld().
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 10.7 94/10/17 12:26:33 jra Exp Locker: mike $ (BRL)";
d267 2
d303 1
d305 4
a308 3
		rt_log( "asc2g: Unrecognized STRSOL keyword '%s', skipping\n" , keyword );
		rt_log( "buf=%s\n" , buf );
		return;
d480 1
a480 1
			mk_arb8(ofp, name, (CONST point_t *)pnts);
@


10.7
log
@Added EBM,VOL,RPC,RHC,EPA,EHY, and ETO solids.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 10.6 94/10/16 12:18:07 jra Exp Locker: jra $ (BRL)";
d59 1
@


10.6
log
@Added support for NMG's.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 10.5 94/10/11 23:25:53 mike Exp Locker: jra $ (BRL)";
d42 2
d175 4
d200 34
d235 73
d399 1
d483 52
@


10.5
log
@Begun conversion to rt_log(), including setup for it.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 10.4 94/08/10 23:38:53 gdurf Exp Locker: mike $ (BRL)";
d30 7
d173 4
d192 69
@


10.4
log
@Added include of conf.h
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 10.3 1992/10/08 23:42:37 mike Exp gdurf $ (BRL)";
d35 1
d72 17
d94 1
d96 1
d98 1
a98 1
			fprintf(stderr, "asc2g: can't open files.");
d103 1
a103 1
		fprintf(stderr, usage);
d116 1
a116 1
			(void)fprintf(stderr,"rec %c\n", buf[0] );
d127 1
a127 1
			(void)fprintf(stderr,"Warning: unattached Member record, ignored\n");
d175 2
a176 2
			(void)fprintf(stderr,"asc2g: bad record type '%c' (0%o), skipping\n", buf[0], buf[0]);
			(void)fprintf(stderr,"%s\n", buf );
d292 1
a292 1
			fprintf(stderr, "asc2g: bad solid %s s_type= %d, skipping\n",
d610 1
a610 1
		fprintf(stderr, "WARNING:  input file version (%s) is not %s\n",
d643 1
a643 1
		fprintf(stderr, "asc2g: unable to write database ID\n");
d848 1
a848 1
		(void)fprintf(stderr, "asc2g: spline knot malloc error\n");
d868 1
a868 1
		(void)fprintf(stderr, "asc2g: control mesh malloc error\n");
d956 1
a956 1
			fprintf(stderr, "asc2g: no pipe type %s\n", type);
d1041 1
a1041 1
/*fprintf(stderr, "neqn = %d\n", neqn);
d1045 1
a1045 1
		fprintf(stderr, "asc2g: warning: %d equations counted for arbn %s\n", neqn, name);
d1048 1
a1048 1
/*fprintf(stderr, "mallocing space for eqns\n");
d1052 1
a1052 1
		fprintf(stderr, "asc2g: malloc failure for arbn\n");
d1058 1
a1058 1
/*fprintf(stderr, "starting to dump eqns\n");
d1066 1
a1066 1
/*fprintf(stderr, "sending info to mk_arbn\n");
@


10.3
log
@Fix from John Anderson, re: missing NULL in PolySolid records.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 10.2 92/07/16 23:37:23 phil Exp Locker: mike $ (BRL)";
d27 2
@


10.2
log
@Added the option of naming input and output files on the
command line for machine that aren't so good about reading
stdin (namely the Intel Hypercubes and Delta).
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 10.1 91/10/12 06:41:16 mike Rel4_0 $ (BRL)";
d650 1
@


10.1
log
@Release_4.0
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 9.18 91/07/05 23:44:51 mike Exp $ (BRL)";
d53 9
d63 1
d66 4
a69 1
	if( argc > 1 )
d72 13
d86 1
a86 1
	while( ( fgets( buf, BUFSIZE, stdin ) ) != (char *)0 )  {
d221 1
a221 1
			mk_tor(stdout, name, center, n, rad1, rad2);
d232 1
a232 1
			mk_tgc(stdout, name, center, height, a, b, c, d);
d241 1
a241 1
			mk_ell(stdout, name, center, a, b, c);
d259 1
a259 1
			mk_arb8(stdout, name, (CONST point_t *)pnts);
d266 1
a266 1
			mk_half(stdout, name, norm, dd);
d369 1
a369 1
		fgets( buf, BUFSIZE, stdin );
d374 1
a374 1
		fgets( buf, BUFSIZE, stdin );
d381 1
a381 1
		if( fgets( buf, BUFSIZE, stdin ) == (char *)0 )
d391 1
a391 1
	if( mk_lrcomb(stdout, name, &head, is_reg,
d496 1
a496 1
	(void)fwrite( (char *)&record, sizeof record, 1, stdout );
d528 1
a528 1
	(void)fwrite( (char *)&record, sizeof record, 1, stdout );
d592 1
a592 1
	(void)fgets( buf, BUFSIZE, stdin);
d620 1
a620 1
	if( mk_id_units(stdout, title, unit_str) < 0 )  {
d651 1
a651 1
	mk_polysolid(stdout, name);
d689 1
a689 1
	mk_poly(stdout, count, verts, norms);
d722 1
a722 1
	(void)fwrite( (char *)&record, sizeof record, 1, stdout );
d754 1
a754 1
	mk_bsolid(stdout, name, nsurf, resolution);
d804 1
a804 1
	(void)fwrite( (char *)&record, sizeof record, 1, stdout );
d833 1
a833 1
		fgets( buf, BUFSIZE, stdin );
d837 1
a837 1
	(void)fwrite( (char *)fp, nbytes, 1, stdout );
d854 1
a854 1
		fgets( buf, BUFSIZE, stdin );
d858 1
a858 1
	(void)fwrite( (char *)fp, nbytes, 1, stdout );
d904 1
a904 1
		fgets( buf, BUFSIZE, stdin);
d916 1
a916 1
				printf("asc2g: malloc failure for pipe\n");
d939 1
a939 1
	mk_pipe(stdout, name, &head);
d979 1
a979 1
	mk_particle( stdout, name, vertex, height, vrad, hrad);
d1029 1
a1029 1
		printf("asc2g: malloc failure for arbn\n");
d1038 1
a1038 1
		fgets( buf, BUFSIZE, stdin);
d1045 1
a1045 1
	mk_arbn( stdout, name, neqn, eqn);
@


9.18
log
@ANSI lint
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 9.17 91/07/02 02:46:14 mike Exp $ (BRL)";
@


9.17
log
@ANSI lint
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 9.16 91/06/13 03:08:05 mike Exp $ (BRL)";
d368 1
a368 1
		override ? rgb : (unsigned char *)0,
@


9.16
log
@Uses new libwdb routine to indicate working units
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 9.15 91/03/05 01:08:12 phil Exp $ (BRL)";
d233 1
a233 1
			mk_arb8(stdout, name, pnts);
d542 1
a542 1
	char		*unit_str;
@


9.15
log
@The Gould didn't like mixed types on a ?: statement.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 9.14 91/02/12 09:29:44 sue Exp $ (BRL)";
d539 1
a539 1
	char		units;		/* libwdb doesn't take this?! */
d542 1
a547 4
	/* Note that there is no provision for handing libwdb the units.  Just
	 * ignore.
	 */

d551 1
a551 1
	/* Note that there is no provision for handing libwdb the version either.
d570 28
a597 1
	mk_id(stdout, title);
@


9.14
log
@Have added arbn support.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 9.13 90/12/07 02:42:16 mike Exp $ (BRL)";
d368 1
a368 1
		override ? rgb : (char *)0,
@


9.13
log
@Modified to process all member records in one fell swoop,
using linked lists, rather than doing them one at a time.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 9.12 90/12/05 21:09:12 mike Exp $ (BRL)";
d42 1
a42 1
void		solbld();
d122 4
d932 65
@


9.12
log
@Pipe routine was calling wrong free subroutine
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 9.11 90/12/05 21:05:07 mike Exp $ (BRL)";
d42 3
a44 1
void		solbld(), combbld(), membbld(), arsabld(), arsbbld();
d62 1
d75 1
a75 1
			combbld();
d79 1
a79 1
			membbld();
d250 9
d260 1
a260 2

void
d263 1
d274 2
a275 2
	short		length;		/* number of members expected */
	short		num;		/* Comgeom reference number: DEPRECATED */
a282 1

d284 1
d308 1
a308 1
	length = (short)atoi( cp );
d310 1
a310 1
	num = (short)atoi( cp );
d349 13
a361 1
	if( mk_rcomb(stdout, name, length, is_reg,
d370 2
d378 1
a379 1

d381 2
a382 1
membbld()
d389 2
a390 2
	char		inst_name[NAMESIZE];
	fastf_t		mat[16];	/* transformation matrix */
d407 2
d410 1
a410 1
		mat[i] = atof( cp );
a412 2

	mk_memb(stdout, inst_name, mat, relation );
@


9.11
log
@More lint
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 9.10 90/12/05 21:02:22 mike Exp $ (BRL)";
d859 1
a859 1
	mk_freemembers( &head );
@


9.10
log
@Minor lint fix.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 9.9 90/12/05 05:38:07 mike Exp $ (BRL)";
d860 1
a860 1
	free( sp );
@


9.9
log
@This version has been validated as operating correctly
(or, at least operating in the same way as the previous version),
for all the databases in /m/cad/db, with these caveats:
1)  the axis of the torus ABCD vectors has rotated 45 degrees.
    Makes the same torus, but the numbers are different.
2)  Unused entires for sphere, polygon, etc, are zeroed now.
3)  c_num and m_num forced to zero.
4)  Current working units from last MGED session are not brought along.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 9.8 90/12/05 05:10:11 mike Exp $ (BRL)";
d858 2
a859 2
	mk_pipe(stdout, name, &head.l);
	mk_freemembers( &head.l );
@


9.8
log
@Minor tweeks, such as using externs.h
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 9.7 90/12/05 04:47:04 mike Exp $ (BRL)";
@


9.7
log
@Prevent illegal torii from floating point fuzz
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 9.6 90/12/05 04:22:40 mike Exp $ (BRL)";
d34 1
d37 1
a37 1
#define BUFSIZE			1024		/* Record input buffer size */
a40 5
extern void	exit();
extern int	atoi();	/* bzero()? */
extern char	*strcpy();
extern double	atof();

d391 1
a391 1
 * This routine builds ARS's.  Leave alone for now.
d445 1
a445 2
 * This is the second half of the ars-building.  It builds the ARS B record.
 * Also leave alone for now.
a450 2


a541 1
	/* Call mk_id() */
a569 1
	/* Call mk_polysolid()  */
a607 1
	/* Call mk_poly() */
a672 1
	/* Call mk_bsolid() */
@


9.6
log
@Fixed to output proper region id
on combination records.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 9.5 90/12/05 04:11:58 mike Exp $ (BRL)";
d188 3
@


9.5
log
@Eliminated mention of m_num field on Member record
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 9.4 90/12/05 03:58:22 sue Exp $ (BRL)";
d258 1
a258 1
	char		id;		/* Freebie.. not used */
d279 1
a279 1
	id = *cp++;
d342 1
a342 1
		id, aircode, material, los, inherit) < 0 )  {
@


9.4
log
@Converted to use LIBWDB to write most solids to the .g file,
rather than having special knowledge of the database structure.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 9.2 90/04/23 21:07:50 mike Exp $ (BRL)";
a364 1
	short		num;		/* comgeom reference num: DEPRECATED */
a384 5

	num = (short)atoi( cp );	/* What to do with this? */


	/* Call mk_memb(). Should the name or the inst_name be used? */
@


9.3
log
@Eliminated pesky cgtype.
@
text
@d12 2
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 9.2 90/04/23 21:07:50 mike Exp $ (BRL)";
d29 3
d33 1
d35 5
d45 4
a48 4
void	identbld(), polyhbld(), polydbld();
void	solbld(), combbld(), membbld(), arsabld(), arsbbld();
void	materbld(), bsplbld(), bsurfbld(), zap_nl();
char	*nxt_spc();
d50 4
a53 3
static union record	record;		/* GED database record */
#define BUFSIZE		1024		/* Record input buffer size */
static char buf[BUFSIZE];		/* Record input buffer */
a54 2
int debug;

d115 8
d132 6
d139 1
a139 1
solbld()	/* Build Solid record */
d145 12
d158 1
a158 1
	record.s.s_id = *cp++;
d161 1
a161 1
	record.s.s_type = (char)atoi( cp );
d164 1
a164 1
	np = record.s.s_name;
d168 2
d171 1
a172 6
#if 0
	record.s.s_cgtype = (short)atoi( cp );
#else
	record.s.s_cgtype = 0;	/* no longer significant */
#endif

d175 1
a175 1
		record.s.s_values[i] = atof( cp );
d178 62
a239 9
	if( debug )  {
		(void)fprintf(stderr,"%s ty%d [0]=%f,%f,%f [3]=%e,%e,%e\n",
			record.s.s_name, record.s.s_type,
			record.s.s_values[0],
			record.s.s_values[1],
			record.s.s_values[2],
			record.s.s_values[3],
			record.s.s_values[4],
			record.s.s_values[5] );
d241 1
a241 2
	/* Write out the record */
	(void)fwrite( (char *)&record, sizeof record, 1, stdout );
d244 6
d251 1
a251 1
combbld()	/* Build Combination record */
d253 3
a255 3
	register char *cp;
	register char *np;
	int temp_nflag, temp_pflag;
d257 19
a275 1
	record.c.c_override = 0;
d279 1
a279 1
	record.c.c_id = *cp++;
d282 1
a282 1
	record.c.c_flags = *cp++;
d285 1
a285 1
	np = record.c.c_name;
d289 2
d293 1
a293 1
	record.c.c_regionid = (short)atoi( cp );
d295 1
a295 1
	record.c.c_aircode = (short)atoi( cp );
d297 1
a297 1
	record.c.c_length = (short)atoi( cp );
d299 1
a299 1
	record.c.c_num = (short)atoi( cp );
d301 1
a301 1
	record.c.c_material = (short)atoi( cp );
d303 1
a303 1
	record.c.c_los = (short)atoi( cp );
d305 1
a305 1
	record.c.c_override = (char)atoi( cp );
d308 1
a308 1
	record.c.c_rgb[0] = (unsigned char)atoi( cp );
d310 1
a310 1
	record.c.c_rgb[1] = (unsigned char)atoi( cp );
d312 1
a312 1
	record.c.c_rgb[2] = (unsigned char)atoi( cp );
d320 1
a320 1
	record.c.c_inherit = atoi( cp );
d322 2
a323 2
	if( record.c.c_flags == 'Y' )
		record.c.c_flags = 'R';
d325 1
a325 1
		record.c.c_flags = ' ';
d330 1
a330 1
		strncpy( record.c.c_matname, buf, sizeof(record.c.c_matname)-1 );
d335 1
a335 1
		strncpy( record.c.c_matparm, buf, sizeof(record.c.c_matparm)-1 );
d338 9
a346 2
	/* Write out the record */
	(void)fwrite( (char *)&record, sizeof record, 1, stdout );
d349 6
d356 1
a356 1
membbld()	/* Build Member record */
d358 8
a365 3
	register char *cp;
	register char *np;
	register int i;
d368 1
a368 1
	record.M.m_id = *cp++;
d371 1
a371 1
	record.M.m_relation = *cp++;
d374 1
a374 1
	np = record.M.m_instname;
d378 2
d383 1
a383 1
		record.M.m_mat[i] = atof( cp );
d387 1
a387 1
	record.M.m_num = (short)atoi( cp );
d389 4
a392 2
	/* Write out the record */
	(void)fwrite( (char *)&record, sizeof record, 1, stdout );
d395 6
d402 1
a402 1
arsabld()	/* Build ARS A record */
d404 2
d408 2
a444 23
#ifdef never
	(void)sscanf( buf, "%c %d %s %d %d %d %d %f %f %f %f %f %f",
		&record.a.a_id,
		&temp1,
		&record.a.a_name[0],
		&temp2,
		&temp3,
		&temp4,
		&temp5,
		&record.a.a_xmax,
		&record.a.a_xmin,
		&record.a.a_ymax,
		&record.a.a_ymin,
		&record.a.a_zmax,
		&record.a.a_zmin
	);
	record.a.a_type = (char)temp1;
	record.a.a_m = (short)temp2;
	record.a.a_n = (short)temp3;
	record.a.a_curlen = (short)temp4;
	record.a.a_totlen = (short)temp5;
#endif

d447 1
d450 6
d457 1
a457 1
arsbbld()	/* Build ARS B record */
d459 2
d463 1
a479 37
#ifdef never
		/*		   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 */
	(void)sscanf( buf, "%c %d %d %d %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f",
		&record.b.b_id,
		&temp1,
		&temp2,
		&temp3,
		&record.b.b_values[0],
		&record.b.b_values[1],
		&record.b.b_values[2],
		&record.b.b_values[3],
		&record.b.b_values[4],
		&record.b.b_values[5],
		&record.b.b_values[6],
		&record.b.b_values[7],
		&record.b.b_values[8],
		&record.b.b_values[9],
		&record.b.b_values[10],
		&record.b.b_values[11],
		&record.b.b_values[12],
		&record.b.b_values[13],
		&record.b.b_values[14],
		&record.b.b_values[15],
		&record.b.b_values[16],
		&record.b.b_values[17],
		&record.b.b_values[18],
		&record.b.b_values[19],
		&record.b.b_values[20],
		&record.b.b_values[21],
		&record.b.b_values[22],
		&record.b.b_values[23]
	);
	record.b.b_type = (char)temp1;
	record.b.b_n = (short)temp2;
	record.b.b_ngranule = (short)temp3;
#endif

d482 1
d485 7
d506 6
d513 1
a513 1
identbld()	/* Build Ident record */
d515 6
a520 2
	register char *cp;
	register char *np;
d523 1
a523 1
	record.i.i_id = *cp++;
d526 5
a530 1
	record.i.i_units = (char)atoi( cp );
d533 5
a537 1
	np = record.i.i_version;
d541 1
d543 5
d550 1
a550 1
	(void)strcpy( &record.i.i_title[0], buf );
d552 2
a553 2
	/* Write out the record */
	(void)fwrite( (char *)&record, sizeof record, 1, stdout );
d556 6
d563 1
a563 1
polyhbld()	/* Build Polyhead record */
a564 2
	register char *cp;
	register char *np;
d566 6
d573 1
a573 1
	record.p.p_id = *cp++;
d576 1
a576 1
	np = record.p.p_name;
d581 2
a582 2
	/* Write out the record */
	(void)fwrite( (char *)&record, sizeof record, 1, stdout );
d585 5
d591 1
a591 1
polydbld()	/* Build Polydata record */
d593 6
a598 2
	register char *cp;
	register int i, j;
d601 1
a601 1
	record.q.q_id = *cp++;
d604 1
a604 1
	record.q.q_count = (char)atoi( cp );
d609 1
a609 1
			record.q.q_verts[i][j] = atof( cp );
d616 1
a616 1
			record.q.q_norms[i][j] = atof( cp );
d620 3
a622 2
#ifdef never
	int temp1;
a623 37
		/*		   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 */
	(void)sscanf( buf, "%c %d %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f", 
		&record.q.q_id,
		&temp1,
		&record.q.q_verts[0][0],
		&record.q.q_verts[0][1],
		&record.q.q_verts[0][2],
		&record.q.q_verts[1][0],
		&record.q.q_verts[1][1],
		&record.q.q_verts[1][2],
		&record.q.q_verts[2][0],
		&record.q.q_verts[2][1],
		&record.q.q_verts[2][2],
		&record.q.q_verts[3][0],
		&record.q.q_verts[3][1],
		&record.q.q_verts[3][2],
		&record.q.q_verts[4][0],
		&record.q.q_verts[4][1],
		&record.q.q_verts[4][2],
		&record.q.q_norms[0][0],
		&record.q.q_norms[0][1],
		&record.q.q_norms[0][2],
		&record.q.q_norms[1][0],
		&record.q.q_norms[1][1],
		&record.q.q_norms[1][2],
		&record.q.q_norms[2][0],
		&record.q.q_norms[2][1],
		&record.q.q_norms[2][2],
		&record.q.q_norms[3][0],
		&record.q.q_norms[3][1],
		&record.q.q_norms[3][2],
		&record.q.q_norms[4][0],
		&record.q.q_norms[4][1],
		&record.q.q_norms[4][2]
	);
	record.q.q_count = (char)temp1;
#endif
d625 4
a628 3
	/* Write out the record */
	(void)fwrite( (char *)&record, sizeof record, 1, stdout );
}
d633 1
d635 1
d657 5
d663 1
a663 1
bsplbld()	/* Build B-spline solid record */
d665 6
a670 3
	register char *cp;
	register char *np;

d672 1
a672 1
	record.B.B_id = *cp++;
d675 1
a675 1
	np = record.B.B_name;
d679 1
d682 1
a682 1
	record.B.B_nsurf = (short)atoi( cp );
d684 1
a684 1
	record.B.B_resolution = atof( cp );
d686 2
a687 12
#ifdef never
	(void)sscanf( buf, "%c %s %d %f",
		&record.B.B_id,
		&record.B.B_name[0],
		&temp1,
		&record.B.B_resolution
	);
	record.B.B_nsurf = (short)temp1;
#endif

	/* Write out the record */
	(void)fwrite( (char *)&record, sizeof record, 1, stdout );
d690 5
d696 1
a696 1
bsurfbld()	/* Build d-spline surface description record */
a697 5
	register char *cp;
	register int i;
	register float *vp;
	int nbytes, count;
	float *fp;
d699 8
a735 26
#ifdef never
	int temp1, temp2, temp3, temp4, temp5, temp6, temp7, temp8, temp9;

	(void)sscanf( buf, "%c %d %d %d %d %d %d %d %d %d",
		&record.d.d_id,
		&temp1,
		&temp2,
		&temp3,
		&temp4,
		&temp5,
		&temp6,
		&temp7,
		&temp8,
		&temp9
	);
	record.d.d_order[0] = (short)temp1;
	record.d.d_order[1] = (short)temp2;
	record.d.d_kv_size[0] = (short)temp3;
	record.d.d_kv_size[1] = (short)temp4;
	record.d.d_ctl_size[0] = (short)temp5;
	record.d.d_ctl_size[1] = (short)temp6;
	record.d.d_geom_type = (short)temp7;
	record.d.d_nknots = (short)temp8;
	record.d.d_nctls = (short)temp9;
#endif

d797 119
a936 11

#ifdef SYSV

bzero( str, n )
register char *str;
register int n;
{
	while( n-- > 0 )
		*str++ = '\0';
}
#endif
@


9.3.1.1
log
@Zeroed c_num and m_num, to facilitate testing against new libwdb version.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 9.3 90/12/05 03:51:52 mike Exp $ (BRL)";
d188 1
a188 5
#if 0
	record.c.c_num = (short)atoi( cp );		/* DEPRECATED */
#else
	record.c.c_num = 0;
#endif
d256 1
a256 5
#if 0
	record.M.m_num = (short)atoi( cp );	/* DEPRECATED */
#else
	record.M.m_num = 0;
#endif
@


9.3.1.2
log
@Added cleanup code, to further ease comparison.
If not a region, set regionid to zero.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 9.3.1.1 90/12/05 04:15:33 mike Exp $ (BRL)";
d215 1
a215 1
	if( record.c.c_flags == 'Y' )  {
d217 1
a217 1
	}  else  {
a218 2
		record.c.c_regionid = 0;		/* sanity */
	}
@


9.3.1.3
log
@More sanity checking.
This time on RGB
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 9.3.1.2 90/12/05 04:24:25 mike Exp $ (BRL)";
a206 6

	if( record.c.c_override == 0 )  {
		record.c.c_rgb[0] = 0;			/* sanity */
		record.c.c_rgb[1] = 0;
		record.c.c_rgb[2] = 0;
	}
@


9.3.1.4
log
@Removed trash from unused polygon entries
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/asc2g.c,v 9.3.1.3 90/12/05 04:28:20 mike Exp $ (BRL)";
a488 8
		}
	}

	/* Remove trash from unused entries */
	for( i = record.q.q_count; i < 5; i++ )  {
		for( j=0; j < 3; j++ )  {
			record.q.q_verts[i][j] = 0;
			record.q.q_norms[i][j] = 0;
@


9.2
log
@Fixed problem with stray newline on end of Poly solid (header) records.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 9.1 89/05/19 05:46:06 mike Locked $ (BRL)";
d134 1
d136 3
@


9.1
log
@Release_3.5
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 8.2 89/03/06 17:02:20 mike Exp $ (BRL)";
d438 1
a438 1
	while( *cp != '\0' )  {
a440 7

#ifdef never
	(void)sscanf( buf, "%c %s",
		&record.p.p_id,
		&record.p.p_name[0]
	);
#endif
@


8.2
log
@ansii fixes
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 8.1 88/10/05 00:25:24 mike Locked $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 7.4 88/09/17 07:55:26 mike Exp $ (BRL)";
d30 1
a30 1
extern int	printf(), fprintf(), sscanf(), atoi();	/* bzero()? */
a739 208

#ifdef CRAY_COS
/******* Needed only on broken versions of COS ********/
/*
 *	ascii to floating (atof)
 */
#include <ctype.h>
/******#include <values.h>******/
/* These values work with any binary representation of integers
 * where the high-order bit contains the sign. */

/* a number used normally for size of a shift */
#define BITSPERBYTE	8
#define BITS(type)	(BITSPERBYTE * (int)sizeof(type))

/* short, regular and long ints with only the high-order bit turned on */
#define HIBITS	((short)(1 << BITS(short) - 1))
#define HIBITI	(1 << BITS(int) - 1)
#define HIBITL	(1L << BITS(long) - 1)

/* largest short, regular and long int */
#define MAXSHORT	((short)~HIBITS)
#define MAXINT	(~HIBITI)
#define MAXLONG	(~HIBITL)

/* various values that describe the binary floating-point representation
 * _EXPBASE	- the exponent base
 * DMAXEXP 	- the maximum exponent of a double (as returned by frexp())
 * FMAXEXP 	- the maximum exponent of a float  (as returned by frexp())
 * DMINEXP 	- the minimum exponent of a double (as returned by frexp())
 * FMINEXP 	- the minimum exponent of a float  (as returned by frexp())
 * MAXDOUBLE	- the largest double
			((_EXPBASE ** DMAXEXP) * (1 - (_EXPBASE ** -DSIGNIF)))
 * MAXFLOAT	- the largest float
			((_EXPBASE ** FMAXEXP) * (1 - (_EXPBASE ** -FSIGNIF)))
 * MINDOUBLE	- the smallest double (_EXPBASE ** (DMINEXP - 1))
 * MINFLOAT	- the smallest float (_EXPBASE ** (FMINEXP - 1))
 * DSIGNIF	- the number of significant bits in a double
 * FSIGNIF	- the number of significant bits in a float
 * DMAXPOWTWO	- the largest power of two exactly representable as a double
 * FMAXPOWTWO	- the largest power of two exactly representable as a float
 * _IEEE	- 1 if IEEE standard representation is used
 * _DEXPLEN	- the number of bits for the exponent of a double
 * _FEXPLEN	- the number of bits for the exponent of a float
 * _HIDDENBIT	- 1 if high-significance bit of mantissa is implicit
 * LN_MAXDOUBLE	- the natural log of the largest double  -- log(MAXDOUBLE)
 * LN_MINDOUBLE	- the natural log of the smallest double -- log(MINDOUBLE)
 */
#define MAXDOUBLE	0.7237005577332262e+76
#define MAXFLOAT	((float)0.7237005145e+76)
#define MINDOUBLE	5.3976053469342702e-79
#define MINFLOAT	((float)MINDOUBLE)
#define _IEEE		0
#define _DEXPLEN	15
#define _HIDDENBIT	0
#define DMINEXP	(-(DMAXEXP + 1))
#define FMINEXP	(-(FMAXEXP + 1))

#define _FEXPLEN	15
#define DSIGNIF	(BITS(double) - _DEXPLEN + _HIDDENBIT - 1)
#define FSIGNIF	(BITS(float)  - _FEXPLEN + _HIDDENBIT - 1)
#define DMAXPOWTWO	((double)(1L << BITS(long) - 2) * \
				(1L << DSIGNIF - BITS(long) + 1))
#define FMAXPOWTWO	((float)(1L << FSIGNIF - 1))
#define DMAXEXP	((1 << _DEXPLEN - 1) - 1 + _IEEE)
#define FMAXEXP	((1 << _FEXPLEN - 1) - 1 + _IEEE)
#define LN_MAXDOUBLE	(M_LN2 * DMAXEXP)
#define LN_MINDOUBLE	(M_LN2 * (DMINEXP - 1))
#define H_PREC	(DSIGNIF % 2 ? (1L << DSIGNIF/2) * M_SQRT2 : 1L << DSIGNIF/2)
#define X_EPS	(1.0/H_PREC)
#define X_PLOSS	((double)(long)(M_PI * H_PREC))
#define X_TLOSS	(M_PI * DMAXPOWTWO)
#define M_LN2	0.69314718055994530942
#define M_PI	3.14159265358979323846
#define M_SQRT2	1.41421356237309504880
#define MAXBEXP	DMAXEXP /* for backward compatibility */
#define MINBEXP	DMINEXP /* for backward compatibility */
#define MAXPOWTWO	DMAXPOWTWO /* for backward compatibility */
/******#include <values.h>******/

extern double ldexp();

#	define POW1_25LEN	7

static double pow1_25[POW1_25LEN] = { 0.0 };

#define STORE_PTR
#define GOT_DIGIT
#define RET_ZERO(val)	if (!val) return (0.0)

double
atof(p)
register char *p;
{
	register int c;
	int exp = 0, neg_val = 0;
	double fl_val;

	while (isspace(c = *p)) /* eat leading white space */
		p++;
	switch (c) { /* process sign */
	case '-':
		neg_val++;
	case '+': /* fall-through */
		p++;
	}
	{	/* accumulate value */
		register long high = 0, low = 0, scale = 1;
		register int decpt = 0, nzeroes = 0;

		while (isdigit(c = *p++) || c == '.' && !decpt++) {
			if (c == '.')
				continue;
			GOT_DIGIT;
			if (decpt) { /* handle trailing zeroes specially */
				if (c == '0') { /* ignore zero for now */
					nzeroes++;
					continue;
				}
				while (nzeroes > 0) { /* put zeroes back in */
					exp--;
					if (high < MAXLONG/10) {
						high *= 10;
					} else if (scale < MAXLONG/10) {
						scale *= 10;
						low *= 10;
					} else
						exp++;
					nzeroes--;
				}
				exp--; /* decr exponent if decimal pt. seen */
			}
			if (high < MAXLONG/10) {
				high *= 10;
				high += c - '0';
			} else if (scale < MAXLONG/10) {
				scale *= 10;
				low *= 10;
				low += c - '0';
			} else
				exp++;
		}
		RET_ZERO(high);
		fl_val = (double)high;
		if (scale > 1)
			fl_val = (double)scale * fl_val + (double)low;
	}
	STORE_PTR; /* in case there is no legitimate exponent */
	if (c == 'E' || c == 'e') { /* accumulate exponent */
		register int e_exp = 0, neg_exp = 0;

		switch (*p) { /* process sign */
		case '-':
			neg_exp++;
		case '+': /* fall-through */
		case ' ': /* many FORTRAN environments generate this! */
			p++;
		}
		if (isdigit(c = *p)) { /* found a legitimate exponent */
			do {
				/* limit outrageously large exponents */
				if (e_exp < DMAXEXP)
					e_exp = 10 * e_exp + c - '0';
			} while (isdigit(c = *++p));
			if (neg_exp)
				exp -= e_exp;
			else
				exp += e_exp;
			STORE_PTR;
		}
	}
	/*
	 * The following computation is done in two stages,
	 * first accumulating powers of (10/8), then jamming powers of 8,
	 * to avoid underflow in situations like the following (for
	 * the DEC representation): 1.2345678901234567890e-37,
	 * where exp would be about (-37 + -18) = -55, and the
	 * value 10^(-55) can't be represented, but 1.25^(-55) can
	 * be represented, and then 8^(-55) jammed via ldexp().
	 */
	if (exp != 0) { /* apply exponent */
		register double *powptr = pow1_25, fl_exp = fl_val;

		if (*powptr == 0.0) { /* need to initialize table */
			*powptr = 1.25;
			for (; powptr < &pow1_25[POW1_25LEN - 1]; powptr++)
				powptr[1] = *powptr * *powptr;
			powptr = pow1_25;
		}
		if ((c = exp) < 0) {
			c = -c;
			fl_exp = 1.0;
		}
		if (c > DMAXEXP/2) /* outrageously large exponents */
			c = DMAXEXP/2; /* will be handled by ldexp */
		for ( ; ; powptr++) {
			/* binary representation of ints assumed; otherwise
			 * replace (& 01) by (% 2) and (>>= 1) by (/= 2) */
			if (c & 01)
				fl_exp *= *powptr;
			if ((c >>= 1) == 0)
				break;
		}
		fl_val = ldexp(exp < 0 ? fl_val/fl_exp : fl_exp, 3 * exp);
	}
	return (neg_val ? -fl_val : fl_val); /* apply sign */
}
#endif CRAY_COS
@


7.4
log
@changed cray-->CRAY_COS
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 7.3 88/05/15 20:32:53 mike Locked $ (BRL)";
@


7.3
log
@lint fix
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 7.2 88/01/27 02:14:13 mike Locked $ (BRL)";
d741 1
a741 1
#ifdef cray
d947 1
a947 1
#endif cray
@


7.2
log
@Added code to handle c_inherit flag field,
and made ASCII form of C record have fixed number of fields,
rather than variable.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 7.1 87/11/02 23:23:54 mike Locked $ (BRL)";
d36 1
a36 1
void	materbld(), bsplbld(), bsurfbld();
d387 1
@


7.1
log
@Release 2.3
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 6.3 87/10/15 18:48:50 stay Exp $ (BRL)";
d203 3
@


6.3
log
@ADDED calculation for number of granuals so that machines like
the cray which have a larger floating point number than the 32 bit
machines will work properly. this mainly effected the b-spline code.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 6.1 87/07/11 07:49:32 mike Rel $ (BRL)";
@


6.2
log
@Fixed bug in polyhbld(), the new-line in the name wasn't getting NULed out.
Added warning about atof() implementation (only guaranteed to work if the
	numbers are printed in %.12e format, as with "g2asc").
@
text
@d12 1
a12 1
 *      Gary S Moss (minor bug fixes)
a21 6
/*	WARNING:  The implementation of "atof()" provided here is not fully
	general.  It assumes that the %e format as specified in "g2asc" has
	been used for printing the floats.  There is a work around for this
	by using some #ifdef'd out code that uses "scanf()", see "polydbld()"
	for my note and an example. [GSM]
 */
d23 1
a23 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 6.1 87/07/11 07:49:32 moss Locked $ (BRL)";
d437 1
a437 1
	*(np-1) = '\0';			/* Clobber new-line. [GSM] */
d452 1
a452 4
#if 1	/* The following does not always work, it seems atof() is not
		a fully general implementation.  As long as the file
		was created with G2ASC, you're OK. [GSM]
	 */
a453 1
	register char *cp;
d475 1
a475 1
#else
d610 7
d715 9
@


6.1
log
@Release 2.0
@
text
@d12 1
a12 1
 *  
d22 6
d29 1
a29 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 5.1 87/06/24 21:48:43 mike Rel $ (BRL)";
d443 1
a443 1

d458 5
a463 1
	register int i, j;
d485 1
a485 1
#ifdef never
@


5.1
log
@Release 1.24
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 4.2 87/02/12 22:02:11 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 4.1 86/12/29 02:48:15 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 1.17 86/12/06 17:08:29 stay Exp $ (BRL)";
@


1.17
log
@Corrected a problem with writing out b-spline surface records
in the fwrite routine.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 1.16 86/12/03 18:38:19 stay Locked $ (BRL)";
@


1.16
log
@Left room for null.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 1.15 86/11/19 01:14:08 kermit Exp $ (BRL)";
d670 1
a670 1
	(void)fwrite( (char *)&fp, nbytes, 1, stdout );
d691 1
a691 1
	(void)fwrite( (char *)&fp, nbytes, 1, stdout );
@


1.15
log
@Fixed up error messages.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 1.14 86/08/13 06:24:38 kermit Locked $ (BRL)";
d212 1
a212 1
		strncpy( record.c.c_matname, buf, sizeof(record.c.c_matname) );
d217 1
a217 1
		strncpy( record.c.c_matparm, buf, sizeof(record.c.c_matparm) );
@


1.14
log
@New #include conventions
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 1.13 86/08/02 01:37:57 mike Exp $ (BRL)";
d59 1
a59 1
			fprintf(stderr,"rec %c\n", buf[0] );
d106 1
a106 1
			(void)fprintf(stderr,"ASC2G: bad record type '%c' (0%o), skipping\n", buf[0], buf[0]);
d142 1
a142 1
		fprintf(stderr,"%s ty%d [0]=%f,%f,%f [3]=%e,%e,%e\n",
d658 1
a658 1
		(void)fprintf(stderr, "ASC2G: spline knot malloc error\n");
d678 1
a678 1
		(void)fprintf(stderr, "ASC2G: control mesh malloc error\n");
@


1.13
log
@Increased resistance to defective input.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 1.12 86/07/31 05:26:07 mike Exp $ (BRL)";
d26 2
a27 2
#include	<stdio.h>
#include "../h/db.h"
d710 1
a710 1
#ifndef BSD42
@


1.12
log
@Minor fixup.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 1.11 86/07/31 05:22:39 mike Exp $ (BRL)";
d54 1
a54 1
		/* Clear the output record */
d60 2
a61 2
		if( buf[0] == ID_SOLID )  {
			/* Build the record */
d63 3
a65 3
		}
		else if( buf[0] == ID_COMB )  {
			/* Build the record */
d67 3
a69 3
		}
		else if( buf[0] == ID_MEMB )  {
			/* Build the record */
d71 3
a73 3
		}
		else if( buf[0] == ID_ARS_A )  {
			/* Build the record */
d75 3
a77 3
		}
		else if( buf[0] == ID_ARS_B )  {
			/* Build the record */
d79 3
a81 3
		}
		else if( buf[0] == ID_P_HEAD )  {
			/* Build the record */
d83 3
a85 3
		}
		else if( buf[0] == ID_P_DATA )  {
			/* Build the record */
d87 3
a89 3
		}
		else if( buf[0] == ID_IDENT )  {
			/* Build the record */
d91 3
a93 3
		}
		else if( buf[0] == ID_MATERIAL )  {
			/* Build the record */
d95 3
a97 3
		}
		else if( buf[0] == ID_BSOLID )  {
			/* Build the record */
d99 3
a101 3
		}
		else if( buf[0] == ID_BSURF )  {
			/* Build the record */
d103 6
a109 4
		else  {
			(void)fprintf(stderr,"ASC2G: bad record type '%c'\n", buf[0]);
			exit(1);
		}
d111 1
a111 1
	return(0);
@


1.11
log
@Inline atof() for Crays and other broken C libraries.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 1.10 86/07/31 00:51:33 mike Exp $ (BRL)";
a725 1
#ifndef BITSPERBYTE
@


1.10
log
@Kermit's improvements to get rid of the massive sscanf() calls.
Polygon records now implemented.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 1.9 86/07/29 16:57:19 mike Exp $ (BRL)";
d718 209
@


1.9
log
@Added debugging.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 1.8 86/07/27 18:48:25 mike Exp $ (BRL)";
d30 1
a30 1
extern int	printf(), fprintf(), sscanf();		/* bzero()? */
d32 1
d37 1
d115 2
a117 1
	auto int temp1, temp2;
d119 10
a128 36
	i=sscanf( buf,
		/*	      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 */
		"%c %d %s %d %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f",
		&record.s.s_id,
		&temp1,
		&record.s.s_name[0],
		&temp2,
		&record.s.s_values[0],
		&record.s.s_values[1],
		&record.s.s_values[2],
		&record.s.s_values[3],
		&record.s.s_values[4],
		&record.s.s_values[5],
		&record.s.s_values[6],
		&record.s.s_values[7],
		&record.s.s_values[8],
		&record.s.s_values[9],
		&record.s.s_values[10],
		&record.s.s_values[11],
		&record.s.s_values[12],
		&record.s.s_values[13],
		&record.s.s_values[14],
		&record.s.s_values[15],
		&record.s.s_values[16],
		&record.s.s_values[17],
		&record.s.s_values[18],
		&record.s.s_values[19],
		&record.s.s_values[20],
		&record.s.s_values[21],
		&record.s.s_values[22],
		&record.s.s_values[23]
	);
	if( i != 24+4 )  {
		fprintf(stderr,"solbld(%s)  %d items converted, dropped\n",
			record.s.s_name, i);
		return;
d130 9
a138 2
	record.s.s_type = (char)temp1;
	record.s.s_cgtype = (short)temp2;
d156 2
a157 2
	int temp1, temp2, temp3, temp4, temp5, temp6;
	int temp_override, temp_r, temp_g, temp_b;
d160 2
a161 2
	temp_override = 0;
	temp_nflag = temp_pflag = 0;	/* optional fields */
d163 39
a201 15
	(void)sscanf( buf, "%c %c %s %d %d %d %d %d %d %d %d %d %d %d %d",
		&record.c.c_id,
		&record.c.c_flags,
		&record.c.c_name[0],
		&temp1,
		&temp2,
		&temp3,
		&temp4,
		&temp5,
		&temp6,
		&temp_override,
		&temp_r, &temp_g, &temp_b,
		&temp_nflag,
		&temp_pflag
	);
a205 10
	record.c.c_regionid = (short)temp1;
	record.c.c_aircode = (short)temp2;
	record.c.c_length = (short)temp3;
	record.c.c_num = (short)temp4;
	record.c.c_material = (short)temp5;
	record.c.c_los = (short)temp6;
	record.c.c_override = temp_override;
	record.c.c_rgb[0] = temp_r;
	record.c.c_rgb[1] = temp_g;
	record.c.c_rgb[2] = temp_b;
d225 3
a227 1
	int temp1;
d229 3
a231 24
		/*		      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 */
	(void)sscanf( buf, "%c %c %s %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %d", 
		&record.M.m_id,
		&record.M.m_relation,
		&record.M.m_instname[0],
		&record.M.m_mat[0],
		&record.M.m_mat[1],
		&record.M.m_mat[2],
		&record.M.m_mat[3],
		&record.M.m_mat[4],
		&record.M.m_mat[5],
		&record.M.m_mat[6],
		&record.M.m_mat[7],
		&record.M.m_mat[8],
		&record.M.m_mat[9],
		&record.M.m_mat[10],
		&record.M.m_mat[11],
		&record.M.m_mat[12],
		&record.M.m_mat[13],
		&record.M.m_mat[14],
		&record.M.m_mat[15],
		&temp1
	);
	record.M.m_num = (short)temp1;
d233 16
d256 2
a257 1
	int temp1, temp2, temp3, temp4, temp5;
d259 35
d314 1
d323 2
a324 1
	int temp1, temp2, temp3;
d326 16
d376 1
d398 2
a399 1
	int temp1;
d401 3
a403 6
	(void)sscanf( buf, "%c %d %s",
		&record.i.i_id,
		&temp1,
		&record.i.i_version[0]
	);
	record.i.i_units = (char)temp1;
d405 8
d424 13
d441 1
d450 24
a475 1
#ifdef later
d512 1
a515 1
#endif
d521 1
a521 1
	int flags, low, hi, r, g, b;
d523 3
a525 11
	(void)sscanf( buf, "%c %d %d %d %d %d %d",
		&record.md.md_id,
		&flags, &low, &hi,
		&r, &g, &b
	);
	record.md.md_flags = (char)flags;
	record.md.md_low = (short)low;
	record.md.md_hi = (short)hi;
	record.md.md_r = (unsigned char)r;
	record.md.md_g = (unsigned char)g;
	record.md.md_b = (unsigned char)b;
d527 12
d546 2
a547 1
	int temp1;
d549 15
d571 1
d580 1
d585 24
d632 1
d693 13
@


1.8
log
@Changed from %e to %f scanf format (what is %e?)
Added some error checking.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 1.7 86/07/27 18:27:13 mike Exp $ (BRL)";
d41 2
d46 3
d56 2
a57 2
		if( argc > 1 )
			fprintf(stderr,"0%o (%c)\n", buf[0], buf[0] );
d155 10
a164 1

@


1.7
log
@Converted to stdio, added debug flag
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 1.6 86/06/12 20:26:32 mike Exp $ (BRL)";
d108 2
a109 1
	int temp1, temp2;
d111 3
a113 2
		/*		   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 */
	(void)sscanf( buf, "%c %d %s %d %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e",
d143 5
d216 1
a216 1
	(void)sscanf( buf, "%c %c %s %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %d", 
d249 1
a249 1
	(void)sscanf( buf, "%c %d %s %d %d %d %d %e %e %e %e %e %e",
d280 1
a280 1
	(void)sscanf( buf, "%c %d %d %d %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e",
d370 1
a370 1
	(void)sscanf( buf, "%c %d %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e", 
d437 1
a437 1
	(void)sscanf( buf, "%c %s %d %e",
d511 1
a511 1
		(void)sscanf( buf, "%e", vp++);
d532 1
a532 1
		(void)sscanf( buf, "%e", vp++);
@


1.6
log
@Added handling for c_matname, etc.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 1.5 86/03/26 01:03:40 mike Exp $ (BRL)";
a29 1
extern int	close(), creat(), open(), read(), write();
a30 1
extern long	lseek();
d38 1
a38 1
#define BUFSIZE		1000		/* Record input buffer size */
d41 2
a42 1
main()
d51 2
d145 1
a145 1
	(void)write( 1, (char *)&record, sizeof record );
d200 1
a200 1
	(void)write( 1, (char *)&record, sizeof record );
d234 1
a234 1
	(void)write( 1, (char *)&record, sizeof record );
d264 1
a264 1
	(void)write( 1, (char *)&record, sizeof record );
d308 1
a308 1
	(void)write( 1, (char *)&record, sizeof record );
d341 1
a341 1
	(void)write( 1, (char *)&record, sizeof record );
d353 1
a353 1
	(void)write( 1, (char *)&record, sizeof record );
d400 1
a400 1
	(void)write( 1, (char *)&record, sizeof record );
d422 1
a422 1
	(void)write( 1, (char *)&record, sizeof record );
d439 1
a439 1
	(void)write( 1, (char *)&record, sizeof record );
d474 1
a474 1
	(void)write( 1, (char *)&record, sizeof record );
d507 1
a507 1
	(void)write( 1, (char *)fp, nbytes );
d528 1
a528 1
	(void)write( 1, (char *)fp, nbytes );
@


1.5
log
@This version supports the new spline solid,
plus some efficiency improvements, thanks to Kermit.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 1.4 85/06/04 21:33:03 mike Exp $ (BRL)";
a39 1
char	*bp;				/* Pointer for input buffer */
a46 1
		bp = &buf[0];
d97 1
a97 1
			(void)fprintf(stderr,"ASC2G: bad record type\n");
d151 2
d154 4
a157 1
	(void)sscanf( buf, "%c %c %s %d %d %d %d %d %d",
d166 5
a170 1
		&temp6
d182 4
d187 11
d310 13
d336 1
a336 7
	bp = &buf[0];

	while( *bp != '\0' )  {
		if( *bp == '\n' )
			*bp = '\0';
		bp++;
	}
@


1.4
log
@Added definition of bzero() if this is not a 4.2 UNIX
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 1.3 85/06/03 16:59:15 mike Exp $ (BRL)";
d37 1
a37 1
void	materbld();
a39 1
int	count;				/* Number of records */
a45 2
	count = 0;

a47 1
		count++;
a56 2
			/* Write out the record */
			(void)write( 1, (char *)&record, sizeof record );
a60 2
			/* Write out the record */
			(void)write( 1, (char *)&record, sizeof record );
a64 2
			/* Write out the record */
			(void)write( 1, (char *)&record, sizeof record );
a68 2
			/* Write out the record */
			(void)write( 1, (char *)&record, sizeof record );
a72 2
			/* Write out the record */
			(void)write( 1, (char *)&record, sizeof record );
a76 2
			/* Write out the record */
			(void)write( 1, (char *)&record, sizeof record );
a80 2
			/* Write out the record */
			(void)write( 1, (char *)&record, sizeof record );
a84 2
			/* Write out the record */
			(void)write( 1, (char *)&record, sizeof record );
d87 1
a88 1
			(void)write( 1, (char *)&record, sizeof record );
d90 8
d99 1
a99 1
			(void)fprintf(stderr,"ASC2VG: bad record type\n");
d144 3
d175 3
d209 3
d239 3
d283 3
d309 3
d321 3
d368 3
d379 1
a379 1
	(void)sscanf( buf, "%c %d %d %d %d %d %d %s",
d382 120
a501 8
		&r, &g, &b,
		record.md.md_material );
	record.md.md_flags = flags;
	record.md.md_low = low;
	record.md.md_hi = hi;
	record.md.md_r = r;
	record.md.md_g = g;
	record.md.md_b = b;
@


1.3
log
@New version without branch name sillyness.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 1.2 85/03/26 13:36:32 mike Exp $ (BRL)";
d379 11
@


1.2
log
@Working version
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: asc2g.c,v 1.1 85/03/08 21:23:17 mike Exp $ (BRL)";
a28 2
#define NONAME "NoNaMe"			/* For null string names */

d191 2
a192 2
		/*		   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 */
	(void)sscanf( buf, "%c %c %s %s %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %d", 
a194 1
		&record.M.m_brname[0],
a213 5
	/* Check for NONAME entry */
	if( (strcmp( record.M.m_brname, NONAME )) == 0 )  {
		/* Fill string with nulls */
		(void)bzero( (char *)record.M.m_brname, sizeof(record.M.m_brname) );
	}
d322 1
d359 1
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
 *  Author -
d23 1
a23 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
a30 2
extern void	identbld(), polyhbld(), polydbld();
extern void	solbld(), combbld(), membbld(), arsabld(), arsbbld();
d37 4
d108 4
d366 18
@
