head	1.19;
access;
symbols
	ansi-20040405-merged:1.15.2.2
	postmerge-20040405-ansi:1.17
	premerge-20040404-ansi:1.16
	postmerge-autoconf:1.16
	autoconf-freeze:1.15.10.1
	premerge-autoconf:1.16
	ansi-20040316-freeze:1.15.2.1
	postmerge-20040315-windows:1.16
	premerge-20040315-windows:1.15
	windows-20040315-freeze:1.15.4.1
	autoconf-20031203:1.15
	autoconf-20031202:1.15
	autoconf-branch:1.15.0.10
	phong-branch:1.15.0.8
	photonmap-branch:1.15.0.6
	rel-6-1-DP:1.15
	windows-branch:1.15.0.4
	rel-6-0-2:1.13
	ansi-branch:1.15.0.2
	rel-6-0-1-branch:1.13.0.2
	hartley-6-0-post:1.14
	hartley-6-0-pre:1.13
	rel-6-0-1:1.13
	rel-6-0:1.13
	rel-5-4:1.8
	offsite-5-3-pre:1.12
	rel-5-3:1.8
	rel-5-2:1.8
	rel-5-1-branch:1.8.0.2
	rel-5-1:1.8
	rel-5-0:1.6
	rel-5-0-beta:1.5
	rel-4-5:1.1;
locks; strict;
comment	@ * @;


1.19
date	2004.05.24.04.16.12;	author morrison;	state dead;
branches;
next	1.18;

1.18
date	2004.05.10.15.30.41;	author erikg;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.05.07.49.36;	author morrison;	state Exp;
branches;
next	1.16;

1.16
date	2004.03.16.13.54.29;	author morrison;	state Exp;
branches;
next	1.15;

1.15
date	2002.08.20.17.07.21;	author jra;	state Exp;
branches
	1.15.2.1
	1.15.4.1
	1.15.10.1;
next	1.14;

1.14
date	2002.08.15.20.54.34;	author hartley;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.10.21.22.53;	author butler;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.31.22.35.12;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.17.20.20.58;	author jra;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.12.21.59.35;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.10.23.53.57;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.29.17.58.43;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	99.12.30.18.57.27;	author jra;	state Exp;
branches;
next	1.6;

1.6
date	99.06.03.21.54.20;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	98.05.22.12.41.32;	author jra;	state Exp;
branches;
next	1.4;

1.4
date	98.03.04.15.21.04;	author jra;	state Exp;
branches;
next	1.3;

1.3
date	98.02.24.16.14.36;	author jra;	state Exp;
branches;
next	1.2;

1.2
date	98.02.18.22.19.42;	author jra;	state Exp;
branches;
next	1.1;

1.1
date	98.01.14.20.17.07;	author jra;	state Exp;
branches;
next	;

1.15.2.1
date	2002.09.19.18.00.36;	author morrison;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2004.03.17.21.15.56;	author morrison;	state Exp;
branches;
next	;

1.15.4.1
date	2002.09.26.23.03.43;	author morrison;	state Exp;
branches;
next	;

1.15.10.1
date	2004.03.18.18.10.24;	author erikg;	state Exp;
branches;
next	;


desc
@Initial revision. code to create an NMG shell from a model.
@


1.19
log
@moved to src/conv/
@
text
@/*		G - S H E L L . R E C T
 *
 *	This routine creates an single NMG shell from an object by
 *	raytracing and using the hit points as vertices in the shell.
 *	Raytracing is doe in the Y-direction primarily. The -r option
 *	requests raytracing in the X and Z directions to refine the
 *	shape of the shell.
 */

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/conv/g-shell.rect.c,v 1.18 2004/05/10 15:30:41 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "wdb.h"

#ifdef WIN32
#include <fcntl.h>
#endif


#define MAKE_TRIANGLES	0

#define ABS( _x )	((_x)<0.0?(-(_x)):(_x))

#define IN_SEG( _x, _a, _b)	(((_x) > _a + tol.dist && (_x) < _b - tol.dist) || \
				 ((_x) < _a - tol.dist && (_x) > _b + tol.dist))

struct refine_rpp
{
	struct bu_list h;
	point_t min, max;
	fastf_t tolerance;
};

static struct bu_list add_rpp_head;
static struct bu_list subtract_rpp_head;

struct refine_data
{
	struct loopuse *lu1, *lu2;
	struct edgeuse *eu1, *eu2;
	struct faceuse *fu1, *fu2;
	pointp_t mid_pt;
	struct bu_ptbl *new_edges;
};

struct nmg_shot_data
{
	struct shell *s;
	struct hitmiss **hitmiss;
	char *manifolds;
};

struct end_pt
{
	struct vertex *v;
	point_t pt;
};

struct local_part
{
	struct bu_list l;
	char is_void;
	fastf_t in_coord, out_coord;
	struct end_pt *in, *out;
};

static struct bu_ptbl verts;
static struct xray *xy_rays;
static struct xray *xz_rays;
static struct xray *yz_rays;
static struct rt_i *rtip;
static struct bn_tol tol;
static char *usage="Usage:\n\
	%s [-d debug_level] [-b] [-n] [-v] [-i initial_ray_dir] [-g cell_size] [-d debug_level] -o brlcad_output_file database.g object1 object2...\n";
static char dir_ch[3]={ 'X', 'Y', 'Z' };

static struct local_part *xy_parts=(struct local_part *)NULL;
static struct local_part *xz_parts=(struct local_part *)NULL;
static struct local_part *yz_parts=(struct local_part *)NULL;

static int	initial_ray_dir=-1;
static int	do_extra_rays=1;
static long	face_count=0;
static fastf_t	cell_size=50.0;
static fastf_t	cell_size_sq=2500.0;
static fastf_t	edge_tol=0.0;
static struct rt_wdb *fd_out=NULL;
static FILE	*fd_plot=NULL;
static char	*output_file=(char *)NULL;
static char	*plotfile;
static short	vert_ids[8]={1, 2, 4, 8, 16, 32, 64, 128};
static int	debug=0;
static char	*token_seps=" \t,;\n";
static int	cur_dir=0;
static int	cell_count[3];
static fastf_t	decimation_tol=0.0;
static fastf_t	min_angle=0.0;
static int	bot=0;

#define	XY_CELL( _i, _j )	((_i)*cell_count[Y] + (_j))
#define	XZ_CELL( _i, _j )	((_i)*cell_count[Z] + (_j))
#define	YZ_CELL( _i, _j )	((_i)*cell_count[Z] + (_j))
#define ADJ1(_i)		(_i+1>3?0:_i+1)
#define ADJ2(_i)		(_i-1<0?3:_i-1)

#define	GET_Y_INDEX( _y )	((int)(((_y) - rtip->mdl_min[Y])/cell_size))
#define GET_Y_VALUE( _index )	(rtip->mdl_min[Y] + (fastf_t)(_index)*cell_size)

#define NO		'n'
#define	YES		'y'
#define UNKNOWN		'\0'

#define GET_PART	(struct local_part *)bu_calloc( 1, sizeof( struct local_part ), "get_part" )
#define	GET_END		(struct end_pt *)bu_calloc( 1, sizeof( struct end_pt ), "get_end" )

#define	MAKE_FACE( _ep0, _ep1, _ep2, _s )	{\
	struct faceuse *_fu; \
	struct vertex **_v[3]; \
	if( debug > 3 ) \
	{ \
		bu_log( "\t\tMaking face:\n" ); \
		bu_log( "\t\t\tx%x (%g %g %g)\n", _ep0, V3ARGS( _ep0->pt ) ); \
		bu_log( "\t\t\tx%x (%g %g %g)\n", _ep1, V3ARGS( _ep1->pt ) ); \
		bu_log( "\t\t\tx%x (%g %g %g)\n", _ep2, V3ARGS( _ep2->pt ) ); \
	} \
	_v[0] = &_ep0->v; \
	_v[1] = &_ep1->v; \
	_v[2] = &_ep2->v; \
	_fu = nmg_cmface( _s, _v, 3 ); \
	if( !(*_v[0])->vg_p ) \
		nmg_vertex_gv( *_v[0], _ep0->pt ); \
	if( !(*_v[1])->vg_p ) \
		nmg_vertex_gv( *_v[1], _ep1->pt ); \
	if( !(*_v[2])->vg_p ) \
		nmg_vertex_gv( *_v[2], _ep2->pt ); \
	if( nmg_calc_face_g( _fu ) ) \
	{ \
		if( debug > 3 ) \
			bu_log( "Killing degenerate face\n" ); \
		(void)nmg_kfu( _fu ); \
		if( (*_v[0])->vg_p->magic != NMG_VERTEX_G_MAGIC ) \
			(*_v[0])->vg_p = (struct vertex_g *)NULL; \
		if( (*_v[1])->vg_p->magic != NMG_VERTEX_G_MAGIC ) \
			(*_v[1])->vg_p = (struct vertex_g *)NULL; \
		if( (*_v[2])->vg_p->magic != NMG_VERTEX_G_MAGIC ) \
			(*_v[2])->vg_p = (struct vertex_g *)NULL; \
	} \
}
#define	MAKE_FACE_R( _ep0, _ep1, _ep2, _ep3, _s )	{\
	struct faceuse *_fu; \
	struct vertex **_v[4]; \
	if( debug > 3 ) \
	{ \
		bu_log( "\t\tMaking face:\n" ); \
		bu_log( "\t\t\tx%x (%g %g %g)\n", _ep0, V3ARGS( _ep0->pt ) ); \
		bu_log( "\t\t\tx%x (%g %g %g)\n", _ep1, V3ARGS( _ep1->pt ) ); \
		bu_log( "\t\t\tx%x (%g %g %g)\n", _ep2, V3ARGS( _ep2->pt ) ); \
		bu_log( "\t\t\tx%x (%g %g %g)\n", _ep3, V3ARGS( _ep3->pt ) ); \
	} \
	_v[0] = &_ep0->v; \
	_v[1] = &_ep1->v; \
	_v[2] = &_ep2->v; \
	_v[3] = &_ep3->v; \
	_fu = nmg_cmface( _s, _v, 4 ); \
	if( !(*_v[0])->vg_p ) \
		nmg_vertex_gv( *_v[0], _ep0->pt ); \
	if( !(*_v[1])->vg_p ) \
		nmg_vertex_gv( *_v[1], _ep1->pt ); \
	if( !(*_v[2])->vg_p ) \
		nmg_vertex_gv( *_v[2], _ep2->pt ); \
	if( !(*_v[3])->vg_p ) \
		nmg_vertex_gv( *_v[3], _ep3->pt ); \
	if( nmg_calc_face_g( _fu ) ) \
	{ \
		if( debug > 3 ) \
			bu_log( "Killing degenerate face\n" ); \
		(void)nmg_kfu( _fu ); \
		if( (*_v[0])->vg_p->magic != NMG_VERTEX_G_MAGIC ) \
			(*_v[0])->vg_p = (struct vertex_g *)NULL; \
		if( (*_v[1])->vg_p->magic != NMG_VERTEX_G_MAGIC ) \
			(*_v[1])->vg_p = (struct vertex_g *)NULL; \
		if( (*_v[2])->vg_p->magic != NMG_VERTEX_G_MAGIC ) \
			(*_v[2])->vg_p = (struct vertex_g *)NULL; \
		if( (*_v[3])->vg_p->magic != NMG_VERTEX_G_MAGIC ) \
			(*_v[3])->vg_p = (struct vertex_g *)NULL; \
	} \
}

/* flags for vertex status */
#define	ON_SURFACE	1
#define	OUTSIDE		2
#define	INSIDE		3

/* routine to replace default overlap handler.
 * overlaps are irrelevant to this application
 */
static int
a_overlap(register struct application *ap, register struct partition *pp, struct region *reg1, struct region *reg2, struct partition *pheadp)
{
	return( 1 );
}


static int
miss(register struct application *ap)
{
	return(0);
}


static void
pr_part(struct local_part *ptr)
{
	bu_log( "local_part: x%x\n", ptr );
	if( !ptr )
		return;
	if( ptr->is_void == YES )
		bu_log( "\tVOID: in_coord=%g, out_coord=%g\n", ptr->in_coord, ptr->out_coord );
	else if( ptr->is_void == NO )
		bu_log( "\tSOLID: in_coord=%g, out_coord=%g\n", ptr->in_coord, ptr->out_coord );
	else if( ptr->is_void == UNKNOWN )
		bu_log( "\tUNKNOWN: in_coord=%g, out_coord=%g\n", ptr->in_coord, ptr->out_coord );
	else
		bu_log( "\tERROR: in_coord=%g, out_coord=%g\n", ptr->in_coord, ptr->out_coord );
	if( ptr->in )
		bu_log( "\tin = x%x (%g %g %g), v=x%x\n", ptr->in, V3ARGS( ptr->in->pt ), ptr->in->v );
	else
		bu_log( "\tin = NULL\n" );
	if( ptr->out )
		bu_log( "\tout = x%x (%g %g %g), v=x%x\n", ptr->out, V3ARGS( ptr->out->pt ), ptr->out->v );
	else
		bu_log( "\tout = NULL\n" );
}

static void
Make_simple_faces(struct shell *s, int status, struct local_part **lpart)
{
	fastf_t ave_y;
	fastf_t diff[4];
	int max_diff;
	int i;

	switch( status )
	{
		case 3:		/* bottom faces */
#if MAKE_TRIANGLES
				MAKE_FACE( lpart[1]->in, lpart[1]->out, lpart[0]->out, s )
				MAKE_FACE( lpart[1]->in, lpart[0]->out, lpart[0]->in, s )
#else
				MAKE_FACE_R( lpart[1]->in, lpart[1]->out, lpart[0]->out, lpart[0]->in, s )
#endif
			break;
		case 6:		/* right side faces */
#if MAKE_TRIANGLES
				MAKE_FACE( lpart[2]->in, lpart[2]->out, lpart[1]->out, s )
				MAKE_FACE( lpart[2]->in, lpart[1]->out, lpart[1]->in, s )
#else
				MAKE_FACE_R( lpart[2]->in, lpart[2]->out, lpart[1]->out, lpart[1]->in, s )
#endif
			break;
		case 7:		/* partial front and back faces and a diagonal face */
				MAKE_FACE( lpart[0]->in, lpart[1]->in, lpart[2]->in, s )
				MAKE_FACE( lpart[2]->out, lpart[1]->out, lpart[0]->out, s )
#if MAKE_TRIANGLES
				MAKE_FACE( lpart[2]->in, lpart[2]->out, lpart[0]->out, s )
				MAKE_FACE( lpart[2]->in, lpart[0]->out, lpart[0]->in, s )
#else
				MAKE_FACE_R( lpart[2]->in, lpart[2]->out, lpart[0]->out, lpart[0]->in, s )
#endif
			break;
		case 9:		/* left side faces */
#if MAKE_TRIANGLES
				MAKE_FACE( lpart[0]->in, lpart[0]->out, lpart[3]->out, s )
				MAKE_FACE( lpart[0]->in, lpart[3]->out, lpart[3]->in, s )
#else
				MAKE_FACE_R( lpart[0]->in, lpart[0]->out, lpart[3]->out, lpart[3]->in, s )
#endif
			break;
		case 11:	/* partial front and back faces and a diagonal face */
				MAKE_FACE( lpart[0]->in, lpart[1]->in, lpart[3]->in, s )
				MAKE_FACE( lpart[3]->out, lpart[1]->out, lpart[0]->out, s )
#if MAKE_TRIANGLES
				MAKE_FACE( lpart[1]->in, lpart[1]->out, lpart[3]->out, s )
				MAKE_FACE( lpart[1]->in, lpart[3]->out, lpart[3]->in, s )
#else
				MAKE_FACE_R( lpart[1]->in, lpart[1]->out, lpart[3]->out, lpart[3]->in, s )
#endif
			break;
		case 12:	/* top faces */
#if MAKE_TRIANGLES
				MAKE_FACE( lpart[3]->in, lpart[3]->out, lpart[2]->out, s )
				MAKE_FACE( lpart[3]->in, lpart[2]->out, lpart[2]->in, s )
#else
				MAKE_FACE_R( lpart[3]->in, lpart[3]->out, lpart[2]->out, lpart[2]->in, s )
#endif
			break;
		case 13:	/* partial front and back faces and a diagonal face */
				MAKE_FACE( lpart[0]->in, lpart[2]->in, lpart[3]->in, s )
				MAKE_FACE( lpart[3]->out, lpart[2]->out, lpart[0]->out, s )
#if MAKE_TRIANGLES
				MAKE_FACE( lpart[0]->in, lpart[0]->out, lpart[2]->out, s )
				MAKE_FACE( lpart[0]->in, lpart[2]->out, lpart[2]->in, s )
#else
				MAKE_FACE_R( lpart[0]->in, lpart[0]->out, lpart[2]->out, lpart[2]->in, s )
#endif
			break;
		case 14:	/* partial front and back faces and a diagonal face */
				MAKE_FACE( lpart[1]->in, lpart[2]->in, lpart[3]->in, s )
				MAKE_FACE( lpart[3]->out, lpart[2]->out, lpart[1]->out, s )
#if MAKE_TRIANGLES
				MAKE_FACE( lpart[3]->in, lpart[3]->out, lpart[1]->out, s )
				MAKE_FACE( lpart[3]->in, lpart[1]->out, lpart[1]->in, s )
#else
				MAKE_FACE_R( lpart[3]->in, lpart[3]->out, lpart[1]->out, lpart[1]->in, s )
#endif
			break;
		case 15:	/* front and back faces */
				ave_y = 0;
				for( i=0 ; i<4 ; i++ )
					ave_y += lpart[i]->in->pt[Y];
				ave_y /= 4.0;
				for( i=0 ; i<4 ; i++ )
				{
					diff[i] = lpart[i]->in->pt[Y] - ave_y;
					diff[i] = ABS( diff[i] );
				}
				max_diff = 0;
				for( i=1 ; i<4 ; i++ )
				{
					if( diff[i] > diff[max_diff] )
						max_diff = i;
				}
				if( max_diff == 1 || max_diff == 3 )
				{
					MAKE_FACE( lpart[0]->in, lpart[1]->in, lpart[2]->in, s )
					MAKE_FACE( lpart[0]->in, lpart[2]->in, lpart[3]->in, s )
				}
				else
				{
					MAKE_FACE( lpart[0]->in, lpart[1]->in, lpart[3]->in, s )
					MAKE_FACE( lpart[3]->in, lpart[1]->in, lpart[2]->in, s )
				}

				ave_y = 0;
				for( i=0 ; i<4 ; i++ )
					ave_y += lpart[i]->out->pt[Y];
				ave_y /= 4.0;
				for( i=0 ; i<4 ; i++ )
				{
					diff[i] = lpart[i]->out->pt[Y] - ave_y;
					diff[i] = ABS( diff[i] );
				}
				max_diff = 0;
				for( i=1 ; i<4 ; i++ )
				{
					if( diff[i] > diff[max_diff] )
						max_diff = i;
				}
				if( max_diff == 1 || max_diff == 3 )
				{
					MAKE_FACE( lpart[2]->out, lpart[1]->out, lpart[0]->out, s )
					MAKE_FACE( lpart[2]->out, lpart[0]->out, lpart[3]->out, s )
				}
				else
				{
					MAKE_FACE( lpart[3]->out, lpart[1]->out, lpart[0]->out, s )
					MAKE_FACE( lpart[2]->out, lpart[1]->out, lpart[3]->out, s )
				}
			break;
	}
}

static int
Get_extremes(struct shell *s, struct application *ap, struct hitmiss **hitmiss, char *manifolds, fastf_t *hit1, fastf_t *hit2)
{
	struct model *m;
	struct ray_data rd;
	struct seg seghead;
	struct xray *rp;
	int ret;

	NMG_CK_SHELL( s );
	m = nmg_find_model( &s->l.magic );

	bzero( &rd, sizeof( struct ray_data ) );

	rp = &ap->a_ray;
	rd.tol = &tol;
	rd.rd_m = m;
	rd.rp = rp;
	rd.ap = ap;
	rd.manifolds = manifolds;
	rd.hitmiss = hitmiss;
	bzero( hitmiss, m->maxindex*sizeof( struct hitmiss *) );
	BU_LIST_INIT(&rd.rd_hit);
	BU_LIST_INIT(&rd.rd_miss);
	BU_LIST_INIT( &seghead.l );
	rd.seghead = &seghead;

	/* Compute the inverse of the direction cosines */
	if( !NEAR_ZERO( rp->r_dir[X], SQRT_SMALL_FASTF ) )  {
		rd.rd_invdir[X]=1.0/rp->r_dir[X];
	} else {
		rd.rd_invdir[X] = INFINITY;
		rp->r_dir[X] = 0.0;
	}
	if( !NEAR_ZERO( rp->r_dir[Y], SQRT_SMALL_FASTF ) )  {
		rd.rd_invdir[Y]=1.0/rp->r_dir[Y];
	} else {
		rd.rd_invdir[Y] = INFINITY;
		rp->r_dir[Y] = 0.0;
	}
	if( !NEAR_ZERO( rp->r_dir[Z], SQRT_SMALL_FASTF ) )  {
		rd.rd_invdir[Z]=1.0/rp->r_dir[Z];
	} else {
		rd.rd_invdir[Z] = INFINITY;
		rp->r_dir[Z] = 0.0;
	}
	rd.magic = NMG_RAY_DATA_MAGIC;

	nmg_isect_ray_model(&rd);

	if( BU_LIST_IS_EMPTY( &rd.rd_hit ) )
		ret = 0;
	else
	{
		struct hitmiss *a_hit;

		a_hit = BU_LIST_FIRST( hitmiss, &rd.rd_hit );
		VMOVE( hit1, a_hit->hit.hit_point );
		a_hit = BU_LIST_LAST( hitmiss, &rd.rd_hit );
		VMOVE( hit2, a_hit->hit.hit_point );

		NMG_FREE_HITLIST( &rd.rd_hit, ap );

		ret = 1;
	}

	NMG_FREE_HITLIST( &rd.rd_miss, ap );

	return( ret );
}

static int
shrink_hit(register struct application *ap, struct partition *PartHeadp, struct seg *segs)
{
	point_t hit1, hit2;
	point_t mhit1, mhit2;
	struct partition *pp;
	struct vertex *hit1_v=(struct vertex *)NULL;
	struct vertex *hit2_v=(struct vertex *)NULL;
	fastf_t extreme_dist1;
	fastf_t extreme_dist2;
	struct application ap2;
	struct shell *s;
	struct shell_a *sa;
	struct nmgregion *r;
	struct nmgregion_a *ra;
	struct model *m;
	struct nmg_shot_data *sd;
	int i;

	sd = (struct nmg_shot_data *)ap->a_uptr;
	s = sd->s;
	NMG_CK_SHELL( s );
	sa = s->sa_p;
	r = s->r_p;
	ra = r->ra_p;
	m = r->m_p;
	NMG_CK_MODEL( m );
	bzero( &ap2, sizeof( struct application ) );
	ap2.a_resource = ap->a_resource;
	ap2.a_ray = ap->a_ray;
	
	pp = PartHeadp->pt_forw;

	VJOIN1( mhit1, ap->a_ray.r_pt, pp->pt_inhit->hit_dist, ap->a_ray.r_dir )

	pp = PartHeadp->pt_back;

	VJOIN1( mhit2, ap->a_ray.r_pt, pp->pt_outhit->hit_dist, ap->a_ray.r_dir )

	extreme_dist1 = MAX_FASTF;
	extreme_dist2 = -MAX_FASTF;

	/* find hit vertex */
	for( i=0 ; i<BU_PTBL_END( &verts ) ; i++ )
	{
		struct vertex *v;
		struct vertex_g *vg;
		fastf_t dist;

		v = (struct vertex *)BU_PTBL_GET( &verts, i );
		if( !v )
			continue;
		vg = v->vg_p;

		if( (ap->a_user == X || NEAR_ZERO( ap->a_ray.r_pt[X] - vg->coord[X], tol.dist )) &&
		    (ap->a_user == Y || NEAR_ZERO( ap->a_ray.r_pt[Y] - vg->coord[Y], tol.dist )) &&
		    (ap->a_user == Z || NEAR_ZERO( ap->a_ray.r_pt[Z] - vg->coord[Z], tol.dist )) )
		{
			dist = vg->coord[ap->a_user] - ap->a_ray.r_pt[ap->a_user];
			if( dist < extreme_dist1 )
			{
				extreme_dist1 = dist;
				hit1_v = v;
			}
			if( dist > extreme_dist2 )
			{
				extreme_dist2 = dist;
				hit2_v = v;
			}
		}
	}

	if( hit1_v || hit2_v )
	{
		vect_t diff1, diff2;
		fastf_t len1_sq, len2_sq;

		(void)Get_extremes( s, &ap2, sd->hitmiss, sd->manifolds, hit1, hit2 );

		if( debug )
		{
			bu_log( "shrink_hit:\n\thit1_v=(%g %g %g), hit2_v=(%g %g %g)\n",
				V3ARGS( hit1_v->vg_p->coord ),
				V3ARGS( hit2_v->vg_p->coord ) );
			bu_log( "\tNMG extremes are (%g %g %g)<->(%g %g %g)\n",
				V3ARGS( hit1 ),
				V3ARGS( hit2 ) );
			bu_log( "\tmodel extremes are (%g %g %g)<->(%g %g %g)\n",
				V3ARGS( mhit1 ),
				V3ARGS( mhit2 ) );
		}

		VSUB2( diff1, hit1_v->vg_p->coord, hit1 );
		VSUB2( diff2, hit2_v->vg_p->coord, hit2 );

		len1_sq = MAGSQ( diff1 );
		len2_sq = MAGSQ( diff2 );

		if( !NEAR_ZERO( len1_sq, tol.dist_sq ) )
			hit1_v = (struct vertex *)NULL;

		if( !NEAR_ZERO( len2_sq, tol.dist_sq ) )
			hit2_v = (struct vertex *)NULL;
	}

	if( hit1_v && hit1_v == hit2_v )
	{
		/* only one vertex found, which is it?? */
		fastf_t dist1, dist2;

		if( debug )
			bu_log( "hit1_v == hit2_v (still) (%g %g %g)\n", V3ARGS( hit1_v->vg_p->coord ) );

		dist1 = hit1_v->vg_p->coord[ap->a_user] - mhit1[ap->a_user];
		if( dist1 < 0.0 )
			dist1 = -dist1;
		dist2 = hit2_v->vg_p->coord[ap->a_user] - mhit2[ap->a_user];
		if( dist2 < 0.0 )
			dist2 = -dist2;

		if( debug )
		{
			bu_log( "\tmhit1=(%g %g %g) mhit2=(%g %g %g)\n", V3ARGS( mhit1 ), V3ARGS( mhit2 ) );
			bu_log( "\tdist1=%g dist2=%g\n", dist1, dist2 );
		}

		if( dist2 >= dist1 )
		{
			if( debug )
				bu_log( "\t\teliminating hit2_v\n" );
			hit2_v = (struct vertex *)NULL;
		}
		else
		{
			if( debug )
				bu_log( "\t\teliminating hit1_v\n" );
			hit1_v = (struct vertex *)NULL;
		}
	}

	/* Don't allow moving the vertex normalward more than a cell width.
	 * If the point should have been there, the original rays should have caught it.
	 */
	if( hit1_v )
	{
		vect_t v1;
		struct vertexuse *vu;
		fastf_t dist_sq;

		VSUB2( v1, mhit1, hit1_v->vg_p->coord );
		dist_sq = MAGSQ( v1 );

		if( dist_sq > cell_size_sq )
		{

			for( BU_LIST_FOR( vu, vertexuse, &hit1_v->vu_hd ) )
			{
				struct faceuse *fu;
				vect_t norm;

				fu = nmg_find_fu_of_vu( vu );
				if( fu->orientation != OT_SAME )
					continue;

				NMG_GET_FU_NORMAL( norm, fu );

				if( VDOT( norm, v1 ) > 0.0 )
				{
					hit1_v = (struct vertex *)NULL;
					break;
				}
			}
		}
	}
	if( hit2_v )
	{
		vect_t v2;
		struct vertexuse *vu;
		fastf_t dist_sq;

		VSUB2( v2, mhit2, hit2_v->vg_p->coord );
		dist_sq = MAGSQ( v2 );

		if( dist_sq > cell_size_sq )
		{

			for( BU_LIST_FOR( vu, vertexuse, &hit2_v->vu_hd ) )
			{
				struct faceuse *fu;
				vect_t norm;

				fu = nmg_find_fu_of_vu( vu );
				if( fu->orientation != OT_SAME )
					continue;

				NMG_GET_FU_NORMAL( norm, fu );

				if( VDOT( norm, v2 ) > 0.0 )
				{
					hit2_v = (struct vertex *)NULL;
					break;
				}
			}
		}
	}

	if( hit1_v )
	{
		struct vertexuse *vu;

		if( debug )
			bu_log( "Moving first hit vg x%x from (%g %g %g) to (%g %g %g)\n", hit1_v->vg_p,
				V3ARGS( hit1_v->vg_p->coord ), V3ARGS( mhit1 ) );
		VMOVE( hit1_v->vg_p->coord, mhit1 )
		for( BU_LIST_FOR( vu, vertexuse, &hit1_v->vu_hd ) )
		{
			struct faceuse *fu;
			struct face *f;
			struct edgeuse *eu;
			struct edge_g_lseg *eg;
			pointp_t pt;

			if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
				continue;

			eu = vu->up.eu_p;
			eg = eu->g.lseg_p;

			VMOVE( eg->e_pt, mhit1 );
			pt = eu->eumate_p->vu_p->v_p->vg_p->coord;
			VSUB2(eg->e_dir, eg->e_pt, pt);

			fu = nmg_find_fu_of_eu( eu );
			if( !fu )
				continue;
			if( fu->orientation != OT_SAME )
				continue;

			nmg_calc_face_g( fu );
			f = fu->f_p;
			nmg_face_bb( f, &tol );

			VMINMAX( sa->min_pt, sa->max_pt, f->min_pt )
			VMINMAX( sa->min_pt, sa->max_pt, f->max_pt )
		}

		VMINMAX( ra->min_pt, ra->max_pt, sa->min_pt )
		VMINMAX( ra->min_pt, ra->max_pt, sa->max_pt )

		bu_ptbl_zero( &verts, (long *)hit1_v );
	}

	if( hit2_v )
	{
		struct vertexuse *vu;

		if( debug )
			bu_log( "Moving last hit vg x%x from (%g %g %g) to (%g %g %g)\n", hit2_v->vg_p,
				V3ARGS( hit2_v->vg_p->coord ), V3ARGS( mhit2 ) );
		VMOVE( hit2_v->vg_p->coord, mhit2 )
		for( BU_LIST_FOR( vu, vertexuse, &hit2_v->vu_hd ) )
		{
			struct faceuse *fu;
			struct face *f;
			struct edgeuse *eu;
			struct edge_g_lseg *eg;
			pointp_t pt;

			if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
				continue;

			eu = vu->up.eu_p;
			eg = eu->g.lseg_p;

			VMOVE( eg->e_pt, mhit2 );
			pt = eu->eumate_p->vu_p->v_p->vg_p->coord;
			VSUB2(eg->e_dir, eg->e_pt, pt);

			fu = nmg_find_fu_of_eu( eu );
			if( !fu )
				continue;
			if( fu->orientation != OT_SAME )
				continue;

			nmg_calc_face_g( fu );
			f = fu->f_p;
			nmg_face_bb( f, &tol );

			VMINMAX( sa->min_pt, sa->max_pt, f->min_pt )
			VMINMAX( sa->min_pt, sa->max_pt, f->max_pt )
		}

		VMINMAX( ra->min_pt, ra->max_pt, sa->min_pt )
		VMINMAX( ra->min_pt, ra->max_pt, sa->max_pt )

		bu_ptbl_zero( &verts, (long *)hit2_v );
	}

	return( 1 );
}

static void
Split_side_faces(struct shell *s, struct bu_ptbl *tab)
{
	struct faceuse *fu;
	struct loopuse *lu;
	struct edgeuse *eu;
	struct bu_ptbl faces;
	int face_no;

	NMG_CK_SHELL( s );

	bu_ptbl_init( &faces, 128, "faces" );

	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
	{
		int count=0;

		if( fu->orientation != OT_SAME )
			continue;

		lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );

		for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
			count++;

		if( count == 3 )
			continue;

		if( count != 4 )
		{
			bu_log( "Found a loop with %d edge!!!! (should be 3 or 4)\n", count );
			nmg_pr_fu_briefly( fu, "" );
			continue;
		}

		bu_ptbl_ins( &faces, (long *)fu );
	}

	for( face_no=0 ; face_no<BU_PTBL_END( &faces ) ; face_no++ )
	{
		struct edgeuse *eu1=(struct edgeuse *)NULL, *eu2=(struct edgeuse *)NULL;
		fastf_t min_coord1=MAX_FASTF, min_coord2=MAX_FASTF;
		struct vertex_g *vg1a, *vg1b, *vg2a, *vg2b;
		int cell_no;

		fu = (struct faceuse *)BU_PTBL_GET( &faces, face_no );
		lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );

		for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
		{
			vect_t edge_dir;
			struct vertex_g *vga, *vgb;

			vga = eu->vu_p->v_p->vg_p;
			vgb = eu->eumate_p->vu_p->v_p->vg_p;

			VSUB2( edge_dir, vgb->coord, vga->coord );

			if( (cur_dir == X && (edge_dir[Y] != 0.0 || edge_dir[Z] != 0.0) ) ||
			    (cur_dir == Y && (edge_dir[X] != 0.0 || edge_dir[Z] != 0.0) ) ||
			    (cur_dir == Z && (edge_dir[Y] != 0.0 || edge_dir[X] != 0.0) ) )
				continue;

			if( edge_dir[cur_dir] > 0.0 )
			{
				if( vga->coord[cur_dir] < min_coord1 )
				{
					min_coord1 = vga->coord[cur_dir];
					eu1 = eu;
				}
			}
			else
			{
				if( vgb->coord[cur_dir] < min_coord2 )
				{
					min_coord2 = vgb->coord[cur_dir];
					eu2 = eu->eumate_p;
				}
			}
		}

		if( !eu1 || !eu2 )
		{
			bu_log( "Could not find edges to split in loop:\n" );
			nmg_pr_fu_briefly( fu, "" );
			continue;
		}

		/* split the parallel edges and cut the loop */
		for( cell_no=0 ; cell_no<cell_count[cur_dir] ; cell_no++ )
		{
			struct loopuse *new_lu;
			struct vertexuse *vu_cut;
			fastf_t cut_value = -1;
			struct vertexuse *vu1_cut, *vu2_cut;

			switch( cur_dir )
			{
				case X:
					cut_value = xy_rays[XY_CELL(cell_no,0)].r_pt[cur_dir];
					break;
				case Y:
					cut_value = xy_rays[XY_CELL(0,cell_no)].r_pt[cur_dir];
					break;
				case Z:
					cut_value = xz_rays[XZ_CELL(0,cell_no)].r_pt[cur_dir];
					break;
			}

			vg1a = eu1->vu_p->v_p->vg_p;
			vg1b = eu1->eumate_p->vu_p->v_p->vg_p;
			vg2a = eu2->vu_p->v_p->vg_p;
			vg2b = eu2->eumate_p->vu_p->v_p->vg_p;

			while( vg1b->coord[cur_dir] < cut_value )
			{
				struct edgeuse *eu_tmp;
				struct vertex_g *vg_tmp;

				/* go to next eu */
				eu_tmp = BU_LIST_PNEXT_CIRC( edgeuse, &eu1->l );
				vg_tmp = eu_tmp->eumate_p->vu_p->v_p->vg_p;

				if( (cur_dir == X && (vg_tmp->coord[Y] == vg1b->coord[Y] && vg_tmp->coord[Z] == vg1b->coord[Z]) ) ||
				    (cur_dir == Y && (vg_tmp->coord[X] == vg1b->coord[X] && vg_tmp->coord[Z] == vg1b->coord[Z]) ) ||
				    (cur_dir == Z && (vg_tmp->coord[X] == vg1b->coord[X] && vg_tmp->coord[Y] == vg1b->coord[Y]) ) )
				{
					eu1 = eu_tmp;
					vg1a = vg1b;
					vg1b = vg_tmp;
				}
				else
					break;
			}

			while( vg2b->coord[cur_dir] < cut_value )
			{
				struct edgeuse *eu_tmp;
				struct vertex_g *vg_tmp;

				/* go to next eu */
				eu_tmp = BU_LIST_PNEXT_CIRC( edgeuse, &eu2->l );
				vg_tmp = eu_tmp->eumate_p->vu_p->v_p->vg_p;

				if( (cur_dir == X && (vg_tmp->coord[Y] == vg2b->coord[Y] && vg_tmp->coord[Z] == vg2b->coord[Z]) ) ||
				    (cur_dir == Y && (vg_tmp->coord[X] == vg2b->coord[X] && vg_tmp->coord[Z] == vg2b->coord[Z]) ) ||
				    (cur_dir == Z && (vg_tmp->coord[X] == vg2b->coord[X] && vg_tmp->coord[Y] == vg2b->coord[Y]) ) )
				{
					eu2 = eu_tmp;
					vg2a = vg2b;
					vg2b = vg_tmp;
				}
				else
					break;
			}

			vu1_cut = (struct vertexuse *)NULL;
			vu2_cut = (struct vertexuse *)NULL;

			if( IN_SEG( cut_value, vg1a->coord[cur_dir], vg1b->coord[cur_dir] ) )
			{
				point_t cut_pt;

				/* split eu1 at cut_value */
				eu1 = nmg_esplit( (struct vertex *)NULL, eu1, 0 );
				VMOVE( cut_pt, vg1a->coord );
				cut_pt[cur_dir] = cut_value;
				nmg_vertex_gv( eu1->vu_p->v_p, cut_pt );
				bu_ptbl_ins( tab, (long *)eu1->vu_p->v_p );
				vg1a = eu1->vu_p->v_p->vg_p;
				vu1_cut = eu1->vu_p;
			}
			else if( vg1a->coord[cur_dir] == cut_value )
				vu1_cut = eu1->vu_p;
			else if( vg1b->coord[cur_dir] == cut_value )
				vu1_cut = BU_LIST_PNEXT_CIRC( edgeuse, &eu1->l )->vu_p;

			if( IN_SEG( cut_value, vg2a->coord[cur_dir], vg2b->coord[cur_dir] ) )
			{
				point_t cut_pt;

				/* split eu2 at cut_value */
				eu2 = nmg_esplit( (struct vertex *)NULL, eu2, 0 );
				VMOVE( cut_pt, vg2a->coord );
				cut_pt[cur_dir] = cut_value;
				nmg_vertex_gv( eu2->vu_p->v_p, cut_pt );
				bu_ptbl_ins( tab, (long *)eu2->vu_p->v_p );
				vg2a = eu2->vu_p->v_p->vg_p;
				vu_cut = (struct vertexuse *)NULL;
				for( BU_LIST_FOR( vu_cut, vertexuse, &eu2->vu_p->v_p->vu_hd ) )
				{
					if( nmg_find_lu_of_vu( vu_cut ) == lu )
					{
						vu2_cut = vu_cut;
						break;
					}
				}
			}
			else if( vg2a->coord[cur_dir] == cut_value )
			{
				vu_cut = (struct vertexuse *)NULL;
				for( BU_LIST_FOR( vu_cut, vertexuse, &eu2->vu_p->v_p->vu_hd ) )
				{
					if( nmg_find_lu_of_vu( vu_cut ) == lu )
					{
						vu2_cut = vu_cut;
						break;
					}
				}
			}
			else if( vg2b->coord[cur_dir] == cut_value )
			{
				vu_cut = (struct vertexuse *)NULL;
				for( BU_LIST_FOR( vu_cut, vertexuse, &eu2->eumate_p->vu_p->v_p->vu_hd ) )
				{
					if( nmg_find_lu_of_vu( vu_cut ) == lu )
					{
						vu2_cut = vu_cut;
						break;
					}
				}
			}

			if( vu1_cut && vu2_cut )
			{
				/* need to set new eu1 and eu2 before cut, because they may up in new_lu */
				if( vu2_cut->v_p == eu2->eumate_p->vu_p->v_p )
					eu2 = BU_LIST_PNEXT_CIRC( edgeuse, &eu2->l );
				if( vu1_cut->v_p == eu1->eumate_p->vu_p->v_p )
					eu1 = BU_LIST_PNEXT_CIRC( edgeuse, &eu1->l );
				/* cut loop */
				new_lu = nmg_cut_loop( vu1_cut, vu2_cut );
				lu->orientation = OT_SAME;
				lu->lumate_p->orientation = OT_SAME;
				new_lu->orientation = OT_SAME;
				new_lu->lumate_p->orientation = OT_SAME;
			}
		}
	}

	bu_ptbl_free( &faces );
}

static void
shrink_wrap(struct shell *s)
{
	struct faceuse *fu;
	struct application ap;
	struct nmg_shot_data sd;
	struct bu_ptbl extra_verts;
	struct model *m;
	int vert_no;
	int i,j;
	int dirs;

	NMG_CK_SHELL( s );

	m = nmg_find_model( &s->l.magic);

	bu_ptbl_init( &extra_verts, 64, "extra verts" );

	bu_ptbl_init( &verts, 128, "verts" );
	Split_side_faces( s, &verts );

	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
	{
		if( fu->orientation == OT_SAME )
			nmg_triangulate_fu( fu, &tol );
	}

	nmg_split_loops_into_faces( &s->l.magic, &tol );

	sd.s = s;
	sd.manifolds = nmg_manifolds( m );
	sd.hitmiss = (struct hitmiss **)bu_calloc( 2 * m->maxindex, sizeof( struct hitmiss *), "nmg geom hit list");

	bzero( &ap, sizeof( struct application ) );
	ap.a_uptr = (genptr_t)&sd;
	ap.a_rt_i = rtip;
	ap.a_miss = miss;
	ap.a_overlap = a_overlap;
	ap.a_logoverlap = rt_silent_logoverlap;
	ap.a_onehit = 0;
	ap.a_hit = shrink_hit;

	for( dirs=0 ; dirs<2 ; dirs++ )
	{
		cur_dir++;
		if( cur_dir == 3 )
			cur_dir = 0;
		bu_log( "Shooting refining rays in %c-direction...\n", dir_ch[cur_dir] );
		ap.a_user = cur_dir;
		switch( cur_dir )
		{
			case X:
				for( i=0 ; i<cell_count[Y] ; i++ )
				{
					for( j=0 ; j<cell_count[Z] ; j++ )
					{
						VMOVE( ap.a_ray.r_pt, yz_rays[YZ_CELL(i,j)].r_pt )
						VMOVE( ap.a_ray.r_dir, yz_rays[YZ_CELL(i,j)].r_dir )
						(void)rt_shootray( &ap );
					}
				}
				break;
			case Y:
				for( i=0 ; i<cell_count[X] ; i++ )
				{
					for( j=0 ; j<cell_count[Z] ; j++ )
					{
						VMOVE( ap.a_ray.r_pt, xz_rays[XZ_CELL(i,j)].r_pt )
						VMOVE( ap.a_ray.r_dir, xz_rays[XZ_CELL(i,j)].r_dir )
						(void)rt_shootray( &ap );
					}
				}
				break;
			case Z:
				for( i=0 ; i<cell_count[X] ; i++ )
				{
					for( j=0 ; j<cell_count[Y] ; j++ )
					{
						VMOVE( ap.a_ray.r_pt, xy_rays[XY_CELL(i,j)].r_pt )
						VMOVE( ap.a_ray.r_dir, xy_rays[XY_CELL(i,j)].r_dir )
						(void)rt_shootray( &ap );
					}
				}
				break;
		}
	}

	for( vert_no=0 ; vert_no<BU_PTBL_END( &extra_verts ) ; vert_no++ )
	{
		struct vertex *v;
		struct faceuse *fu;
		struct vertexuse *vu;
		vect_t dir;
		vect_t abs_dir;
		int dir_index;

		v = (struct vertex *)BU_PTBL_GET( &extra_verts, vert_no );
		VSETALL( dir, 0.0 );
		for( BU_LIST_FOR( vu, vertexuse, &v->vu_hd ) )
		{
			vect_t norm;

			fu = nmg_find_fu_of_vu( vu );
			if( fu->orientation != OT_SAME )
				continue;

			NMG_GET_FU_NORMAL( norm, fu );

			VADD2( dir, dir, norm );
		}

		VUNITIZE( dir );

		abs_dir[X] = ABS( dir[X] );
		abs_dir[Y] = ABS( dir[Y] );
		abs_dir[Z] = ABS( dir[Z] );

		dir_index = X;
		if( abs_dir[Y] > abs_dir[dir_index] )
			dir_index = Y;
		if( abs_dir[Z] > abs_dir[dir_index] )
			dir_index = Z;

		ap.a_user = dir_index;
		VMOVE( ap.a_ray.r_pt, v->vg_p->coord );
		ap.a_ray.r_pt[dir_index] -=  5 * cell_size;
		VSETALL( ap.a_ray.r_dir, 0.0 );
		ap.a_ray.r_dir[dir_index] = 1.0;
		(void)rt_shootray( &ap );
	}
	bu_free( sd.manifolds, "manifolds" );
	bu_free( (char *)sd.hitmiss, "hitmiss" );
}

static int
refine_hit(register struct application *ap, struct partition *PartHeadp, struct seg *segs)
{
	struct partition *pp;
	struct refine_data *ref_data;
	struct vertexuse *vu1, *vu2;
	struct edgeuse *new_eu;
	struct vertexuse *new_vu;
	struct vertexuse *new_vu1, *new_vu2;
	struct loopuse *new_lu1, *new_lu2;
	struct vertexuse *vu;
	struct edgeuse *eu;
	point_t hit_pt;
	vect_t diff;
	fastf_t dist;
	fastf_t use_tolerance=edge_tol;
	struct refine_rpp *rpp;

	if( debug )
		bu_log( "hit\n" );

	ref_data = (struct refine_data *)ap->a_uptr;
	pp = PartHeadp->pt_forw;
	VJOIN1( hit_pt, ap->a_ray.r_pt, pp->pt_inhit->hit_dist, ap->a_ray.r_dir );

	for( BU_LIST_FOR( rpp, refine_rpp, &add_rpp_head ) )
	{
		if( V3PT_IN_RPP( hit_pt, rpp->min, rpp->max ) )
		{
			if( rpp->tolerance < use_tolerance )
				use_tolerance = rpp->tolerance;
		}
	}

	VSUB2( diff, hit_pt, ref_data->mid_pt );
	dist = MAGNITUDE( diff );
	if( dist <= use_tolerance || dist > 1.4142 * cell_size )
		return( 0 );

	if( fd_plot )
	{
		struct loopuse *lu;
		struct vertex_g *vg;

		fprintf( fd_plot, "-----\n" );
		fprintf( fd_plot, "vdraw params color 00ff00\n" );
		for( BU_LIST_FOR( lu, loopuse, &ref_data->fu1->lu_hd ) )
		{
			eu = BU_LIST_LAST( edgeuse, &lu->down_hd );
			vg = eu->vu_p->v_p->vg_p;
			fprintf( fd_plot, "vdraw write 0 %g %g %g\n", V3ARGS( vg->coord ) );
			
			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
			{
				vg = eu->vu_p->v_p->vg_p;
				fprintf( fd_plot, "vdraw write 1 %g %g %g\n", V3ARGS( vg->coord ) );
			}
		}

		for( BU_LIST_FOR( lu, loopuse, &ref_data->fu2->lu_hd ) )
		{
			eu = BU_LIST_LAST( edgeuse, &lu->down_hd );
			vg = eu->vu_p->v_p->vg_p;
			fprintf( fd_plot, "vdraw write 0 %g %g %g\n", V3ARGS( vg->coord ) );
			
			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
			{
				vg = eu->vu_p->v_p->vg_p;
				fprintf( fd_plot, "vdraw write 1 %g %g %g\n", V3ARGS( vg->coord ) );
			}
		}
	}

	eu = BU_LIST_PNEXT_CIRC( edgeuse, &ref_data->eu1->l );
	eu = BU_LIST_PNEXT_CIRC( edgeuse, &eu->l );
	vu1 = eu->vu_p;
	eu = BU_LIST_PNEXT_CIRC( edgeuse, &ref_data->eu2->l );
	eu = BU_LIST_PNEXT_CIRC( edgeuse, &eu->l );
	vu2 = eu->vu_p;
	new_eu = nmg_esplit( (struct vertex *)NULL, ref_data->eu1, 0 );
	new_vu = new_eu->vu_p;

	/* find new vu in lu1 */
	new_vu1 = (struct vertexuse *)NULL;
	for( BU_LIST_FOR( vu, vertexuse, &new_vu->v_p->vu_hd ) )
	{
		if( nmg_find_lu_of_vu( vu ) == ref_data->lu1 )
		{
			new_vu1 = vu;
			break;
		}
	}
	if( !new_vu1 )
		bu_bomb( "Cannot find VU in lu1\n" );

	/* find new vu in lu2 */
	new_vu2 = (struct vertexuse *)NULL;
	for( BU_LIST_FOR( vu, vertexuse, &new_vu->v_p->vu_hd ) )
	{
		if( nmg_find_lu_of_vu( vu ) == ref_data->lu2 )
		{
			new_vu2 = vu;
			break;
		}
	}
	if( !new_vu2 )
		bu_bomb( "Cannot find VU in lu2\n" );
	new_lu1 = nmg_cut_loop( new_vu1, vu1 );
	new_lu2 = nmg_cut_loop( new_vu2, vu2 );
	ref_data->lu1->orientation = OT_SAME;
	ref_data->lu2->orientation = OT_SAME;
	new_lu1->orientation = OT_SAME;
	new_lu2->orientation = OT_SAME;
	ref_data->lu1->lumate_p->orientation = OT_SAME;
	ref_data->lu2->lumate_p->orientation = OT_SAME;
	new_lu1->lumate_p->orientation = OT_SAME;
	new_lu2->lumate_p->orientation = OT_SAME;

	if( debug )
		bu_log( "\tmoving to (%g %g %g)\n", V3ARGS( hit_pt ) );
	nmg_vertex_gv( new_vu->v_p, hit_pt );

	if( fd_plot )
	{
		struct loopuse *lu;
		struct vertex_g *vg;

		fprintf( fd_plot, "xxxxx\n" );
		fprintf( fd_plot, "vdraw params color 0000ff\n" );
		for( BU_LIST_FOR( lu, loopuse, &ref_data->fu1->lu_hd ) )
		{
			eu = BU_LIST_LAST( edgeuse, &lu->down_hd );
			vg = eu->vu_p->v_p->vg_p;
			fprintf( fd_plot, "vdraw write 0 %g %g %g\n", V3ARGS( vg->coord ) );
			
			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
			{
				vg = eu->vu_p->v_p->vg_p;
				fprintf( fd_plot, "vdraw write 1 %g %g %g\n", V3ARGS( vg->coord ) );
			}
		}

		for( BU_LIST_FOR( lu, loopuse, &ref_data->fu2->lu_hd ) )
		{
			eu = BU_LIST_LAST( edgeuse, &lu->down_hd );
			vg = eu->vu_p->v_p->vg_p;
			fprintf( fd_plot, "vdraw write 0 %g %g %g\n", V3ARGS( vg->coord ) );
			
			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
			{
				vg = eu->vu_p->v_p->vg_p;
				fprintf( fd_plot, "vdraw write 1 %g %g %g\n", V3ARGS( vg->coord ) );
			}
		}
	}

	(void) nmg_split_loops_into_faces( &ref_data->fu1->l.magic , &tol );
	(void) nmg_split_loops_into_faces( &ref_data->fu2->l.magic , &tol );

	for( BU_LIST_FOR( vu, vertexuse, &new_vu->v_p->vu_hd ) )
	{
		struct faceuse *fu;

		if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
			continue;

		eu = vu->up.eu_p;

		fu = nmg_find_fu_of_vu ( vu );
		if( !fu )
			continue;

		if( fu->orientation != OT_SAME )
			continue;

		bu_ptbl_ins( ref_data->new_edges, (long *)eu->e_p );

		nmg_calc_face_g( fu );
	}

	return( 1 );
}

static int
refine_edges(struct shell *s)
{
	struct bu_ptbl edges_1;
	struct bu_ptbl edges_2;
	struct bu_ptbl *cur, *next, *tmp;
	struct application ap;
	struct model *m;
	int breaks=0;
	int loop_count=0;
	int i;

	NMG_CK_SHELL( s );

	m = nmg_find_model( &s->l.magic );

	nmg_edge_tabulate( &edges_1, &s->l.magic );
	cur = &edges_1;
	bu_ptbl_init( &edges_2, 64, "edges_2" );
	next = &edges_2;

	bzero( &ap, sizeof( struct application ) );
	ap.a_rt_i = rtip;
	ap.a_miss = miss;
	ap.a_overlap = a_overlap;
	ap.a_logoverlap = rt_silent_logoverlap;
	ap.a_onehit = 0;
	ap.a_hit = refine_hit;

	if( debug )
	{
		nmg_rebound( m, &tol );
		mk_nmg( fd_out, "break.0", m );
	}

	breaks = 1;
	while( breaks && loop_count < 6 )
	{
		struct refine_data ref_data;

		breaks = 0;
		ref_data.new_edges = next;

		for( i=0 ; i<BU_PTBL_END( cur ) ; i++ )
		{
			vect_t v1, v2, v3, v4;
			fastf_t alpha, cosa, sina;
			vect_t ave_norm;
			struct edge *e;
			struct vertex_g *vga, *vgb;
			struct edgeuse *eu1, *eu2;
			struct loopuse *lu1, *lu2;
			struct faceuse *fu1, *fu2;
			point_t mid_pt;
			vect_t norm1, norm2;

			e = (struct edge *)BU_PTBL_GET( cur, i );
			NMG_CK_EDGE( e );

			eu1 = e->eu_p;
			if( *eu1->up.magic_p != NMG_LOOPUSE_MAGIC )
				continue;
			lu1 = eu1->up.lu_p;
			if( *lu1->up.magic_p != NMG_FACEUSE_MAGIC )
				continue;
			fu1 = lu1->up.fu_p;

			if( fu1->orientation != OT_SAME )
			{
				eu1 = eu1->eumate_p;
				if( *eu1->up.magic_p != NMG_LOOPUSE_MAGIC )
					continue;
				lu1 = eu1->up.lu_p;
				if( *lu1->up.magic_p != NMG_FACEUSE_MAGIC )
					continue;
				fu1 = lu1->up.fu_p;
			}

			if( fu1->orientation != OT_SAME )
				bu_bomb( "Cannot find OT_SAME side of face\n" );

			eu2 = eu1->radial_p;
			if( *eu2->up.magic_p != NMG_LOOPUSE_MAGIC )
				continue;
			lu2 = eu2->up.lu_p;
			if( *lu2->up.magic_p != NMG_FACEUSE_MAGIC )
				continue;
			fu2 = lu2->up.fu_p;

			if( fu2->orientation != OT_SAME )
			{
				eu2 = eu2->eumate_p;
				if( *eu2->up.magic_p != NMG_LOOPUSE_MAGIC )
					continue;
				lu2 = eu2->up.lu_p;
				if( *lu2->up.magic_p != NMG_FACEUSE_MAGIC )
					continue;
				fu2 = lu2->up.fu_p;
			}

			if( fu2->orientation != OT_SAME )
				bu_bomb( "Cannot find OT_SAME side of face\n" );

			NMG_GET_FU_NORMAL( norm1, fu1 );
			NMG_GET_FU_NORMAL( norm2, fu2 );

			vga = eu1->vu_p->v_p->vg_p;
			vgb = eu1->eumate_p->vu_p->v_p->vg_p;

			VSUB2( v3, vgb->coord, vga->coord )
			VUNITIZE( v3 )
			VMOVE( v2, norm1 )
			VCROSS( v1, v2, v3)
			VUNITIZE( v1 )
			VCROSS( v4, v3, norm2 )
			alpha = atan2( VDOT( v4, v2 ), VDOT( v4, v1 ) );
			if( alpha < 0.0 )
				alpha += bn_twopi;
			alpha = alpha / 2.0;
			cosa = cos( alpha );
			sina = sin( alpha );
			VBLEND2( ave_norm, cosa, v1, sina, v2 )

			VBLEND2( mid_pt, 0.5, vga->coord, 0.5, vgb->coord );
			VJOIN1( ap.a_ray.r_pt, mid_pt, (2.0*cell_size), ave_norm );
			VREVERSE( ap.a_ray.r_dir, ave_norm );
			ref_data.fu1 = fu1;
			ref_data.fu2 = fu2;
			ref_data.lu1 = lu1;
			ref_data.lu2 = lu2;
			ref_data.eu1 = eu1;
			ref_data.eu2 = eu2;
			ref_data.mid_pt = mid_pt;
			ap.a_uptr = (genptr_t)&ref_data;

			if( debug )
			{
				bu_log( "norm1=(%g %g %g), norm2=(%g %g %g), alpha=%g, ave_norm=(%g %g %g)\n",
					V3ARGS( norm1 ), V3ARGS( norm2 ), alpha, V3ARGS( ave_norm ) );
				bu_log( "\tmid_pt = (%g %g %g)\n", V3ARGS( mid_pt ) );
				bu_log( "\tray_pt=(%g %g %g), dir=(%g %g %g)\n", V3ARGS( ap.a_ray.r_pt ), V3ARGS( ap.a_ray.r_dir ) );
			}
			breaks += rt_shootray( &ap );
		}

		bu_log( "\tBroke %d edges\n", breaks );
		if( debug )
		{
			char name[16];

			sprintf( name, "break.%d", loop_count );
			nmg_rebound( m, &tol );
			mk_nmg( fd_out, name, m );
		}

		bu_ptbl_reset( cur );
		tmp = cur;
		cur = next;
		next = tmp;

		++loop_count;
	}

	bu_ptbl_free( cur );
	bu_ptbl_free( next );

	return( breaks );
}

static void
Make_shell(void)
{
	int i;
	int x_index, y_index, z_index;
	int cell_no[4];
	int status;
	struct model *m;
	struct nmgregion *r;
	struct shell *s;
	struct faceuse *fu;
	struct local_part *lpart[4];

	bu_log( "Building initial shell...\n" );

	m = nmg_mm();
	r = nmg_mrsv( m );
	s = BU_LIST_FIRST( shell, &r->s_hd );

	switch (cur_dir )
	{
		case X:
			for( y_index=1 ; y_index < cell_count[Y] ; y_index++ )
			{
				for( z_index=0 ; z_index < cell_count[Z] - 1 ; z_index++ )
				{
					cell_no[0] = YZ_CELL(y_index,z_index);
					cell_no[1] = YZ_CELL(y_index-1,z_index);
					cell_no[2] = YZ_CELL(y_index-1,z_index+1);
					cell_no[3] = YZ_CELL(y_index,z_index+1);

					for( i=0 ; i<4 ; i++ )
					{
						if( BU_LIST_IS_EMPTY( &yz_parts[cell_no[i]].l ) )
							lpart[i] = (struct local_part *)NULL;
						else
							lpart[i] = BU_LIST_FIRST( local_part, &yz_parts[cell_no[i]].l );
					}

					status = 0;
					for( i=0 ; i<4 ; i++ )
					{
						if( lpart[i] && lpart[i]->is_void == NO )
							status += vert_ids[i];
					}

					if( debug > 3 )
					{
						bu_log( "Making faces for y_index=%d, z_index=%d\n", y_index, z_index );
						for( i=0 ; i<4 ; i++ )
						{
							bu_log( "part #%d:\n", i );
							bu_log( "\tray start is (%g %g %g)\n", V3ARGS( yz_rays[cell_no[i]].r_pt ) );
							pr_part( lpart[i] );
						}
					}

					Make_simple_faces( s, status, lpart );
				}
			}
			break;
		case Y:
			for( x_index=0 ; x_index < cell_count[X] - 1 ; x_index++ )
			{
				for( z_index=0 ; z_index < cell_count[Z] - 1 ; z_index++ )
				{
					cell_no[0] = XZ_CELL(x_index,z_index);
					cell_no[1] = XZ_CELL(x_index+1,z_index);
					cell_no[2] = XZ_CELL(x_index+1,z_index+1);
					cell_no[3] = XZ_CELL(x_index,z_index+1);

					for( i=0 ; i<4 ; i++ )
					{
						if( BU_LIST_IS_EMPTY( &xz_parts[cell_no[i]].l ) )
							lpart[i] = (struct local_part *)NULL;
						else
							lpart[i] = BU_LIST_FIRST( local_part, &xz_parts[cell_no[i]].l );
					}

					status = 0;
					for( i=0 ; i<4 ; i++ )
					{
						if( lpart[i] && lpart[i]->is_void == NO )
							status += vert_ids[i];
					}

					if( debug > 3 )
					{
						bu_log( "Making faces for x_index=%d, z_index=%d\n", x_index, z_index );
						for( i=0 ; i<4 ; i++ )
						{
							bu_log( "part #%d:\n", i );
							bu_log( "\tray start is (%g %g %g)\n", V3ARGS( xz_rays[cell_no[i]].r_pt ) );
							pr_part( lpart[i] );
						}
					}

					Make_simple_faces( s, status, lpart );
				}
			}
			break;
		case Z:
			for( x_index=1 ; x_index < cell_count[X] ; x_index++ )
			{
				for( y_index=0 ; y_index < cell_count[Y] - 1 ; y_index++ )
				{
					cell_no[0] = XY_CELL(x_index,y_index);
					cell_no[1] = XY_CELL(x_index-1,y_index);
					cell_no[2] = XY_CELL(x_index-1,y_index+1);
					cell_no[3] = XY_CELL(x_index,y_index+1);

					for( i=0 ; i<4 ; i++ )
					{
						if( BU_LIST_IS_EMPTY( &xy_parts[cell_no[i]].l ) )
							lpart[i] = (struct local_part *)NULL;
						else
							lpart[i] = BU_LIST_FIRST( local_part, &xy_parts[cell_no[i]].l );
					}

					status = 0;
					for( i=0 ; i<4 ; i++ )
					{
						if( lpart[i] && lpart[i]->is_void == NO )
							status += vert_ids[i];
					}

					if( debug > 3 )
					{
						bu_log( "Making faces for x_index=%d, y_index=%d\n", x_index, y_index );
						for( i=0 ; i<4 ; i++ )
						{
							bu_log( "part #%d:\n", i );
							bu_log( "\tray start is (%g %g %g)\n", V3ARGS( xy_rays[cell_no[i]].r_pt ) );
							pr_part( lpart[i] );
						}
					}

					Make_simple_faces( s, status, lpart );
				}
			}
			break;
	}

	nmg_rebound( m, &tol );

	if( do_extra_rays )
		shrink_wrap( s );

	if( edge_tol > 0.0 )
	{
		if( debug )
		{
			nmg_rebound( m, &tol );
			mk_nmg( fd_out, "break.0", m );
		}

		bu_log( "Shooting rays at edge mid points...\n" );
		refine_edges( s );
	}

	if( decimation_tol > 0.0 )
	{
		bu_log( "%d edges eliminated by decimation to tolerance of %gmm\n",
			nmg_edge_collapse( m, &tol, decimation_tol, min_angle ), decimation_tol );
	}

	if( do_extra_rays || edge_tol > 0.0 || decimation_tol > 0.0 )
		nmg_rebound( m, &tol );

	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
	{
		if( fu->orientation != OT_SAME )
			continue;
		face_count++;
	}

	bu_log( "Bounding box of output: (%g %g %g) <-> (%g %g %g)\n", V3ARGS( r->ra_p->min_pt ), V3ARGS( r->ra_p->max_pt ) );
	bu_log( "%d facets\n", face_count );

	if( bot )
		mk_bot_from_nmg( fd_out, "shell", s );
	else
		mk_nmg( fd_out, "shell", m );
}

static int
hit(register struct application *ap, struct partition *PartHeadp, struct seg *segs)
{
	register struct partition *first_pp;
	register struct partition *last_pp;
	struct local_part *lpart;
	fastf_t part_len;

	first_pp = PartHeadp->pt_forw;
	last_pp = PartHeadp->pt_back;

	part_len = last_pp->pt_outhit->hit_dist - first_pp->pt_inhit->hit_dist;
	if( NEAR_ZERO( part_len, tol.dist ) )
		return( 0 );

	lpart = GET_PART;
	lpart->in = GET_END;
	lpart->out = GET_END;
	lpart->is_void = NO;
	lpart->in->v = (struct vertex *)NULL;

	switch( cur_dir )
	{
		case X:
			VSET( lpart->in->pt, 
				yz_rays[ap->a_user].r_pt[X] + first_pp->pt_inhit->hit_dist,
				yz_rays[ap->a_user].r_pt[Y],
				yz_rays[ap->a_user].r_pt[Z] );
			lpart->out->v = (struct vertex *)NULL;
			VSET( lpart->out->pt, 
				yz_rays[ap->a_user].r_pt[X] + last_pp->pt_outhit->hit_dist,
				yz_rays[ap->a_user].r_pt[Y],
				yz_rays[ap->a_user].r_pt[Z] );
			BU_LIST_INSERT( &yz_parts[ap->a_user].l, &lpart->l )
			break;
		case Y:
			VSET( lpart->in->pt, 
				xz_rays[ap->a_user].r_pt[X],
				xz_rays[ap->a_user].r_pt[Y] + first_pp->pt_inhit->hit_dist,
				xz_rays[ap->a_user].r_pt[Z] );
			lpart->out->v = (struct vertex *)NULL;
			VSET( lpart->out->pt, 
				xz_rays[ap->a_user].r_pt[X],
				xz_rays[ap->a_user].r_pt[Y] + last_pp->pt_outhit->hit_dist,
				xz_rays[ap->a_user].r_pt[Z] );
			BU_LIST_INSERT( &xz_parts[ap->a_user].l, &lpart->l )
			break;
		case Z:
			VSET( lpart->in->pt, 
				xy_rays[ap->a_user].r_pt[X],
				xy_rays[ap->a_user].r_pt[Y],
				xy_rays[ap->a_user].r_pt[Z] + first_pp->pt_inhit->hit_dist );
			lpart->out->v = (struct vertex *)NULL;
			VSET( lpart->out->pt, 
				xy_rays[ap->a_user].r_pt[X],
				xy_rays[ap->a_user].r_pt[Y],
				xy_rays[ap->a_user].r_pt[Z] + last_pp->pt_outhit->hit_dist );
			BU_LIST_INSERT( &xy_parts[ap->a_user].l, &lpart->l )
			break;
	}
	return( 1 );
}

int
main(int argc, char **argv)
{
	char idbuf[132];
	struct application ap;
	int i,j;
	int c;
	fastf_t x_start, y_start, z_start;
	fastf_t bb_area[3];

	bu_debug = BU_DEBUG_COREDUMP;

#ifdef WIN32
	_fmode = _O_BINARY;
#endif


#ifdef BSD
	setlinebuf( stderr );
#else
#	if defined( SYSV ) && !defined( sgi ) && !defined(CRAY2) && \
	 !defined(n16)
		(void) setvbuf( stderr, (char *) NULL, _IOLBF, BUFSIZ );
#	endif
#	if defined(sgi) && defined(mips)
		if( setlinebuf( stderr ) != 0 )
			perror("setlinebuf(stderr)");
#	endif
#endif

	/* These need to be improved */
	tol.magic = BN_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-5;
	tol.para = 1 - tol.perp;

	BU_LIST_INIT( &add_rpp_head );
	BU_LIST_INIT( &subtract_rpp_head );

	/* Get command line arguments. */
	while( (c=getopt( argc, argv, "bi:a:s:nR:g:o:d:p:X:")) != EOF)
	{
		switch( c )
		{
			case 'i':	/* set initial ray direction */
					switch( *optarg )
					{
						case 'x':
						case 'X':

							initial_ray_dir = X;
							break;
						case 'y':
						case 'Y':
							initial_ray_dir = Y;
							break;
						case 'z':
						case 'Z':
							initial_ray_dir = Z;
							break;
						default:
							bu_log( "Illegal ray direction (%c), must be X, Y, or Z!!!\n", *optarg );
							exit( 1 );
					}
					break;
			case 'a':	/* add an rpp for refining */
				{
					char *ptr;
					struct refine_rpp *rpp;
					int bad_opt=0;

					ptr = optarg;

					rpp = ( struct refine_rpp *)bu_malloc( sizeof( struct refine_rpp ), "add refine rpp" );
					ptr = strtok( optarg, token_seps );
					if( !ptr )
					{
						bu_log( "Bad -a option '%s'\n", optarg );
						bu_free( (char *) rpp, "rpp" );
						break;
					}

					rpp->tolerance = atof( ptr );
					if( rpp->tolerance <= 0.0 )
					{
						bu_log( "Illegal tolerance in -a option (%s)\n", ptr );
						bu_free( (char *) rpp, "rpp" );
						break;
					}

					/* get minimum */
					for( i=0 ; i<3 ; i++ )
					{
						ptr = strtok( (char *)NULL, token_seps );
						if( !ptr )
						{
							bu_log( "Unexpected end of option args for -a!!!\n" );
							bad_opt = 1;
							break;
						}
						rpp->min[i] = atof( ptr );
					}
					if( bad_opt )
					{
						bu_free( (char *) rpp, "rpp" );
						break;
					}

					/* get maximum */
					for( i=0 ; i<3 ; i++ )
					{
						ptr = strtok( (char *)NULL, token_seps );
						if( !ptr )
						{
							bu_log( "Unexpected end of option args for -a!!!\n" );
							bad_opt = 1;
							break;
						}
						rpp->max[i] = atof( ptr );
					}
					if( bad_opt )
					{
						bu_free( (char *) rpp, "rpp" );
						break;
					}

					BU_LIST_APPEND( &add_rpp_head, &rpp->h );
				}
				break;
			case 'n':	/* don't do extra raytracing to refine shape */
				do_extra_rays = 0;
				break;
			case 'R':	/* do edge breaking */
				edge_tol = atof( optarg );
				break;
			case 'p':	/* plot edge breaking */
				plotfile = optarg;
				break;
			case 'd':	/* debug level */
				debug = atoi( optarg );
				break;
			case 'g':	/* cell size */
				cell_size = atof( optarg );
				cell_size_sq = cell_size * cell_size;
				break;
			case 'o':	/* BRL-CAD output file */
				output_file = optarg;
				break;
			case 'b':	/* Output a BOT rather than an NMG */
				bot = 1;
				break;
			case 'X':	/* nmg debug flags */
				sscanf( optarg, "%x", (unsigned int *)&rt_g.NMG_debug );
				bu_log( "%s: setting rt_g.NMG_debug to x%x\n", argv[0], rt_g.NMG_debug );
				break;
		}
	}

	if (optind+1 >= argc)
	{
		bu_log( usage, argv[0] );
		exit( 1 );
	}

	if( output_file )
	{
		if( (fd_out=wdb_fopen( output_file )) == NULL )
		{
			bu_log( "Cannot open output file (%s)\n", output_file );
			perror( argv[0] );
			exit( 1 );
		}
		mk_id( fd_out, "test g-sgp" );
	}
	else
		bu_bomb( "Output file must be specified!!!\n" );

	if( plotfile )
	{
		if( (fd_plot=fopen( plotfile, "w")) == NULL )
		{
			bu_log( "Cannot open plot file (%s)\n", plotfile );
			perror( argv[0] );
			exit( 1 );
		}
	}

	/* Open brl-cad database */
	if ((rtip=rt_dirbuild(argv[optind], idbuf, sizeof(idbuf))) == RTI_NULL )
	{
		bu_log( "rt_durbuild FAILED on %s\n", argv[optind] );
		exit(1);
	}

	rtip->rti_space_partition = RT_PART_NUBSPT;

	bzero( &ap, sizeof( struct application ) );
	ap.a_rt_i = rtip;
	ap.a_hit = hit;
	ap.a_miss = miss;
	ap.a_overlap = a_overlap;
	ap.a_logoverlap = rt_silent_logoverlap;
	ap.a_onehit = 0;

	while( ++optind < argc )
	{
		if( rt_gettree( rtip, argv[optind] ) < 0 )
			bu_log( "rt_gettree failed on %s\n", argv[optind] );
	}

	rt_prep( rtip );

	if( initial_ray_dir == -1 )
	{
		bb_area[X] = (rtip->mdl_max[Y] - rtip->mdl_min[Y]) *
			     (rtip->mdl_max[Z] - rtip->mdl_min[Z]);

		bb_area[Y] = (rtip->mdl_max[X] - rtip->mdl_min[X]) *
			     (rtip->mdl_max[Z] - rtip->mdl_min[Z]);

		bb_area[Z] = (rtip->mdl_max[Y] - rtip->mdl_min[Y]) *
			     (rtip->mdl_max[X] - rtip->mdl_min[X]);

		cur_dir = X;
		if( bb_area[Y] > bb_area[cur_dir] )
			cur_dir = Y;
		if( bb_area[Z] > bb_area[cur_dir] )
			cur_dir = Z;
	}
	else
		cur_dir = initial_ray_dir;

	cell_count[X] = (int)((rtip->mdl_max[X] - rtip->mdl_min[X])/cell_size) + 3;
	cell_count[Y] = (int)((rtip->mdl_max[Y] - rtip->mdl_min[Y])/cell_size) + 3;
	cell_count[Z] = (int)((rtip->mdl_max[Z] - rtip->mdl_min[Z])/cell_size) + 3;
	bu_log( "cell size is %gmm\n\t%d cells in X-direction\n\t%d cells in Y-direction\n\t%d cells in Z-direction\n",
		cell_size, cell_count[X], cell_count[Y], cell_count[Z] );

	x_start = rtip->mdl_min[X] - ((double)cell_count[X] * cell_size - (rtip->mdl_max[X] - rtip->mdl_min[X]))/2.0;
	y_start = rtip->mdl_min[Y] - ((double)cell_count[Y] * cell_size - (rtip->mdl_max[Y] - rtip->mdl_min[Y]))/2.0;
	z_start = rtip->mdl_min[Z] - ((double)cell_count[Z] * cell_size - (rtip->mdl_max[Z] - rtip->mdl_min[Z]))/2.0;

	xz_parts = (struct local_part *)bu_calloc( cell_count[X] * cell_count[Z], sizeof( struct local_part ), "xz_parts" );
	yz_parts = (struct local_part *)bu_calloc( cell_count[Y] * cell_count[Z], sizeof( struct local_part ), "yz_parts" );
	xy_parts = (struct local_part *)bu_calloc( cell_count[X] * cell_count[Y], sizeof( struct local_part ), "xy_parts" );

	xy_rays = (struct xray *)bu_calloc( cell_count[X] * cell_count[Y], sizeof( struct xray ), "xy_rays" );
	xz_rays = (struct xray *)bu_calloc( cell_count[X] * cell_count[Z], sizeof( struct xray ), "xz_rays" );
	yz_rays = (struct xray *)bu_calloc( cell_count[Y] * cell_count[Z], sizeof( struct xray ), "yz_rays" );

	for( i=0 ; i<cell_count[Y] ; i++ )
	{
		for( j=0 ; j<cell_count[Z] ; j++ )
		{
			VSET( yz_rays[YZ_CELL(i,j)].r_dir, 1.0, 0.0, 0.0 )
			VSET( yz_rays[YZ_CELL(i,j)].r_pt,
				rtip->mdl_min[X] - cell_size,
				y_start + (fastf_t)i * cell_size,
				z_start + (fastf_t)j * cell_size )
			yz_parts[YZ_CELL(i,j)].is_void = UNKNOWN;
			yz_parts[YZ_CELL(i,j)].in_coord = -MAX_FASTF;
			yz_parts[YZ_CELL(i,j)].out_coord = -MAX_FASTF;
			yz_parts[YZ_CELL(i,j)].in = (struct end_pt *)NULL;
			yz_parts[YZ_CELL(i,j)].out = (struct end_pt *)NULL;
			BU_LIST_INIT( &yz_parts[YZ_CELL(i,j)].l );
		}
	}

	for( i=0 ; i<cell_count[X] ; i++ )
	{
		for( j=0 ; j<cell_count[Y] ; j++ )
		{
			VSET( xy_rays[XY_CELL(i,j)].r_dir, 0.0, 0.0, 1.0 )
			VSET( xy_rays[XY_CELL(i,j)].r_pt,
				x_start + (fastf_t)i * cell_size,
				y_start + (fastf_t)j * cell_size,
				rtip->mdl_min[Z] - cell_size )
			xy_parts[XY_CELL(i,j)].is_void = UNKNOWN;
			xy_parts[XY_CELL(i,j)].in_coord = -MAX_FASTF;
			xy_parts[XY_CELL(i,j)].out_coord = -MAX_FASTF;
			xy_parts[XY_CELL(i,j)].in = (struct end_pt *)NULL;
			xy_parts[XY_CELL(i,j)].out = (struct end_pt *)NULL;
			BU_LIST_INIT( &xy_parts[XY_CELL(i,j)].l );
		}

		for( j=0 ; j<cell_count[Z] ; j++ )
		{
			VSET( xz_rays[XZ_CELL(i,j)].r_dir, 0.0, 1.0, 0.0 )
			VSET( xz_rays[XZ_CELL(i,j)].r_pt,
				x_start + (fastf_t)i * cell_size,
				rtip->mdl_min[Y] - cell_size,
				z_start + (fastf_t)j * cell_size )
			xz_parts[XZ_CELL(i,j)].is_void = UNKNOWN;
			xz_parts[XZ_CELL(i,j)].in_coord = -MAX_FASTF;
			xz_parts[XZ_CELL(i,j)].out_coord = -MAX_FASTF;
			xz_parts[XZ_CELL(i,j)].in = (struct end_pt *)NULL;
			xz_parts[XZ_CELL(i,j)].out = (struct end_pt *)NULL;
			BU_LIST_INIT( &xz_parts[XZ_CELL(i,j)].l );
		}
	}

	bu_log( "Bounding box of BRL-CAD model: (%g %g %g) <-> (%g %g %g)\n", V3ARGS( rtip->mdl_min ), V3ARGS( rtip->mdl_max ) );
	bu_log( "Shooting rays in %c-direction...\n", dir_ch[cur_dir] );
	switch( cur_dir )
	{
		case X:
			for( i=0 ; i<cell_count[Y] ; i++ )
			{
				for( j=0 ; j<cell_count[Z] ; j++ )
				{
					ap.a_x = i;
					ap.a_y = j;
					ap.a_user = YZ_CELL(i,j);
					VMOVE( ap.a_ray.r_pt, yz_rays[YZ_CELL(i,j)].r_pt )
					VMOVE( ap.a_ray.r_dir, yz_rays[YZ_CELL(i,j)].r_dir )
					(void)rt_shootray( &ap );
				}
			}
			break;
		case Y:
			for( i=0 ; i<cell_count[X] ; i++ )
			{
				for( j=0 ; j<cell_count[Z] ; j++ )
				{
					ap.a_x = i;
					ap.a_y = j;
					ap.a_user = XZ_CELL(i,j);
					VMOVE( ap.a_ray.r_pt, xz_rays[XZ_CELL(i,j)].r_pt )
					VMOVE( ap.a_ray.r_dir, xz_rays[XZ_CELL(i,j)].r_dir )
					(void)rt_shootray( &ap );
				}
			}
			break;
		case Z:
			for( i=0 ; i<cell_count[X] ; i++ )
			{
				for( j=0 ; j<cell_count[Y] ; j++ )
				{
					ap.a_x = i;
					ap.a_y = j;
					ap.a_user = XY_CELL(i,j);
					VMOVE( ap.a_ray.r_pt, xy_rays[XY_CELL(i,j)].r_pt )
					VMOVE( ap.a_ray.r_dir, xy_rays[XY_CELL(i,j)].r_dir )
					(void)rt_shootray( &ap );
				}
			}
			break;
	}

	Make_shell();
	wdb_close(fd_out);
	return 0;
}
@


1.18
log
@change conf.h to a wrapped config.h
@
text
@d11 1
a11 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/conv/g-shell.rect.c,v 1.17 2004/04/05 07:49:36 morrison Exp $ (BRL)";
@


1.17
log
@merge of ansi-6-0-branch into HEAD
@
text
@d11 1
a11 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d14 5
a18 1
#include "conf.h"
@


1.16
log
@merge of windows-6-0-branch into head
@
text
@d214 1
a214 6
a_overlap( ap, pp, reg1, reg2, pheadp )
register struct application     *ap;
register struct partition       *pp;
struct region                   *reg1;
struct region                   *reg2;
struct partition                *pheadp;
d221 1
a221 2
miss( ap )
register struct application *ap;
d228 1
a228 2
pr_part( ptr )
struct local_part *ptr;
d252 1
a252 4
Make_simple_faces( s, status, lpart )
struct shell *s;
int status;
struct local_part *lpart[4];
d390 1
a390 6
Get_extremes( s, ap, hitmiss, manifolds, hit1, hit2 )
struct application *ap;
struct shell *s;
struct hitmiss **hitmiss;
char *manifolds;
point_t hit1, hit2;
d461 1
a461 4
shrink_hit( ap, PartHeadp, segs )
register struct application *ap;
struct partition *PartHeadp;
struct seg *segs;
d762 1
a762 3
Split_side_faces( s, tab )
struct shell *s;
struct bu_ptbl *tab;
d1005 1
a1005 2
shrink_wrap( s )
struct shell *s;
d1139 1
a1139 4
refine_hit( ap, PartHeadp, segs )
register struct application *ap;
struct partition *PartHeadp;
struct seg *segs;
d1322 1
a1322 2
refine_edges( s )
struct shell *s;
d1491 1
a1491 1
Make_shell()
d1676 1
a1676 4
hit( ap, PartHeadp, segs )
register struct application *ap;
struct partition *PartHeadp;
struct seg *segs;
d1739 1
a1739 3
main( argc, argv )
int argc;
char *argv[];
@


1.15
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d11 1
a11 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-shell.rect.c,v 1.13 2001/08/10 21:22:53 butler Exp $ (BRL)";
d31 5
d1779 5
@


1.15.10.1
log
@merge from head
@
text
@d11 1
a11 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a30 5
#ifdef WIN32
#include <fcntl.h>
#endif


a1773 5

#ifdef WIN32
	_fmode = _O_BINARY;
#endif

@


1.15.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d11 1
a11 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-shell.rect.c,v 1.15 2002/08/20 17:07:21 jra Exp $ (BRL)";
a30 5
#ifdef WIN32
#include <fcntl.h>
#endif


a1773 5

#ifdef WIN32
	_fmode = _O_BINARY;
#endif

@


1.15.2.1
log
@Initial ANSIfication
@
text
@d11 1
a11 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-shell.rect.c,v 1.15 2002/08/20 17:07:21 jra Exp $ (BRL)";
d209 6
a214 1
a_overlap(register struct application *ap, register struct partition *pp, struct region *reg1, struct region *reg2, struct partition *pheadp)
d221 2
a222 1
miss(register struct application *ap)
d229 2
a230 1
pr_part(struct local_part *ptr)
d254 4
a257 1
Make_simple_faces(struct shell *s, int status, struct local_part **lpart)
d395 6
a400 1
Get_extremes(struct shell *s, struct application *ap, struct hitmiss **hitmiss, char *manifolds, fastf_t *hit1, fastf_t *hit2)
d471 4
a474 1
shrink_hit(register struct application *ap, struct partition *PartHeadp, struct seg *segs)
d775 3
a777 1
Split_side_faces(struct shell *s, struct bu_ptbl *tab)
d1020 2
a1021 1
shrink_wrap(struct shell *s)
d1155 4
a1158 1
refine_hit(register struct application *ap, struct partition *PartHeadp, struct seg *segs)
d1341 2
a1342 1
refine_edges(struct shell *s)
d1511 1
a1511 1
Make_shell(void)
d1696 4
a1699 1
hit(register struct application *ap, struct partition *PartHeadp, struct seg *segs)
d1762 3
a1764 1
main(int argc, char **argv)
@


1.15.2.2
log
@sync branch with HEAD
@
text
@d11 1
a11 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a30 5
#ifdef WIN32
#include <fcntl.h>
#endif


a1743 5

#ifdef WIN32
	_fmode = _O_BINARY;
#endif

@


1.14
log
@Converted from K&R to ANSI C - RFH
@
text
@d209 6
a214 1
a_overlap(register struct application *ap, register struct partition *pp, struct region *reg1, struct region *reg2, struct partition *pheadp)
d221 2
a222 1
miss(register struct application *ap)
d229 2
a230 1
pr_part(struct local_part *ptr)
d254 4
a257 1
Make_simple_faces(struct shell *s, int status, struct local_part **lpart)
d395 6
a400 1
Get_extremes(struct shell *s, struct application *ap, struct hitmiss **hitmiss, char *manifolds, fastf_t *hit1, fastf_t *hit2)
d471 4
a474 1
shrink_hit(register struct application *ap, struct partition *PartHeadp, struct seg *segs)
d775 3
a777 1
Split_side_faces(struct shell *s, struct bu_ptbl *tab)
d1020 2
a1021 1
shrink_wrap(struct shell *s)
d1155 4
a1158 1
refine_hit(register struct application *ap, struct partition *PartHeadp, struct seg *segs)
d1341 2
a1342 1
refine_edges(struct shell *s)
d1511 1
a1511 1
Make_shell(void)
d1696 4
a1699 1
hit(register struct application *ap, struct partition *PartHeadp, struct seg *segs)
d1762 3
a1764 1
main(int argc, char **argv)
@


1.13
log
@Compiler warning patches
@
text
@d11 1
a11 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-shell.rect.c,v 1.12 2000/10/31 22:35:12 mike Exp $ (BRL)";
d209 1
a209 6
a_overlap( ap, pp, reg1, reg2, pheadp )
register struct application     *ap;
register struct partition       *pp;
struct region                   *reg1;
struct region                   *reg2;
struct partition                *pheadp;
d216 1
a216 2
miss( ap )
register struct application *ap;
d223 1
a223 2
pr_part( ptr )
struct local_part *ptr;
d247 1
a247 4
Make_simple_faces( s, status, lpart )
struct shell *s;
int status;
struct local_part *lpart[4];
d385 1
a385 6
Get_extremes( s, ap, hitmiss, manifolds, hit1, hit2 )
struct application *ap;
struct shell *s;
struct hitmiss **hitmiss;
char *manifolds;
point_t hit1, hit2;
d456 1
a456 4
shrink_hit( ap, PartHeadp, segs )
register struct application *ap;
struct partition *PartHeadp;
struct seg *segs;
d757 1
a757 3
Split_side_faces( s, tab )
struct shell *s;
struct bu_ptbl *tab;
d1000 1
a1000 2
shrink_wrap( s )
struct shell *s;
d1134 1
a1134 4
refine_hit( ap, PartHeadp, segs )
register struct application *ap;
struct partition *PartHeadp;
struct seg *segs;
d1317 1
a1317 2
refine_edges( s )
struct shell *s;
d1486 1
a1486 1
Make_shell()
d1671 1
a1671 4
hit( ap, PartHeadp, segs )
register struct application *ap;
struct partition *PartHeadp;
struct seg *segs;
d1734 1
a1734 3
main( argc, argv )
int argc;
char *argv[];
@


1.12
log
@
compiler lint
@
text
@d11 1
a11 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-shell.rect.c,v 1.11 2000/10/17 20:20:58 jra Exp $ (BRL)";
d1911 1
a1911 1
				sscanf( optarg, "%x", &rt_g.NMG_debug );
@


1.11
log
@Eliminated overlap blathering
@
text
@d11 1
a11 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-shell.rect.c,v 1.10 2000/07/12 21:59:35 mike Exp $ (BRL)";
d869 1
a869 1
			fastf_t cut_value;
@


1.10
log
@
Converted to use new version of LIBWDB
@
text
@d11 1
a11 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-shell.rect.c,v 1.9 2000/07/10 23:53:57 mike Exp $ (BRL)";
d85 1
a85 1
	%s [-d debug_level] [-n] [-v] [-i initial_ray_dir] [-g cell_size] [-d debug_level] -o brlcad_output_file database.g object1 object2...\n";
d109 1
d1058 1
d1366 1
d1689 4
a1692 1
	mk_nmg( fd_out, "shell", m );
d1799 1
a1799 1
	while( (c=getopt( argc, argv, "i:a:s:nR:g:o:d:p:X:")) != EOF)
d1808 1
d1907 3
d1960 1
@


1.9
log
@
lint
@
text
@d11 1
a11 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-shell.rect.c,v 1.8 2000/03/29 17:58:43 mike Exp $ (BRL)";
d29 1
a29 1
#include "../librt/debug.h"
d98 2
a99 1
static FILE	*fd_out=NULL, *fd_plot=NULL;
d1755 1
d1915 1
a1915 1
		if( (fd_out=fopen( output_file, "w")) == NULL )
d2098 2
@


1.8
log
@
Fixed args
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-shell.rect.c,v 1.7 1999/12/30 18:57:27 jra Exp $ (BRL)";
@


1.7
log
@Eliminated some unused variables
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-shell.rect.c,v 1.6 1999/06/03 21:54:20 mike Exp $ (BRL)";
d145 1
a145 1
	if( nmg_calc_face_g( _fu, &tol ) ) \
d182 1
a182 1
	if( nmg_calc_face_g( _fu, &tol ) ) \
d1310 2
a1311 2
	(void) nmg_split_loops_into_faces( ref_data->fu1 , &tol );
	(void) nmg_split_loops_into_faces( ref_data->fu2 , &tol );
d1331 1
a1331 1
		nmg_calc_face_g( fu, &tol );
@


1.6
log
@
sed4
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/conv/g-shell.rect.c,v 1.5 1998/05/22 12:41:32 jra Exp $ (BRL)";
a77 6
static struct cube_str
{
	point_t start_pt;
	struct end_pt *corner[8];
} cube;

a85 2
static char *_inside="inside";
static char *_outside="outside";
d98 1
a98 1
static FILE	*fd_sgp=NULL, *fd_out=NULL, *fd_plot=NULL;
a100 1
static long	rpp_count=0;
a101 2
static int	x_del[4]={0, 1, 1, 0};
static int	z_del[4]={0, 0, 1, 1};
a488 1
	int extremes;
d548 1
a548 1
		extremes=Get_extremes( s, &ap2, sd->hitmiss, sd->manifolds, hit1, hit2 );
a780 1
	vect_t ray_dir;
a786 3
	VSETALL( ray_dir, 0.0 );
	ray_dir[cur_dir] = 1.0;

a825 1
			fastf_t dot;
a934 1
				struct edgeuse *new_eu;
a952 1
				struct edgeuse *new_eu;
a1108 1
		fastf_t count=0;
a1110 1
		vect_t min_dist, max_dist, mins;
d1509 1
a1509 1
	int i,j;
@


1.5
log
@updated caling sequence for "hit" routines.
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/g-shell.rect.c,v 1.4 1998/03/04 15:21:04 jra Exp jra $ (BRL)";
d1802 1
a1802 1
	tol.magic = RT_TOL_MAGIC;
@


1.4
log
@Added check to not adjust a vertex more than cellwidth mormalward (and removed
a bunch of unused code).
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/g-shell.rect.c,v 1.3 1998/02/24 16:14:36 jra Exp jra $ (BRL)";
d480 1
a480 1
shrink_hit( ap, PartHeadp )
d483 1
d1173 1
a1173 1
refine_hit( ap, PartHeadp )
d1176 1
d1710 1
a1710 1
hit( ap, PartHeadp )
d1713 1
@


1.3
log
@Just a bit more fiddling.
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/g-shell.rect.c,v 1.2 1998/02/18 22:19:42 jra Exp jra $ (BRL)";
d91 1
a91 1
	%s [-d debug_level] [-n] [-c] [-v] [-i initial_ray_dir] [-g cell_size] [-d debug_level] -o brlcad_output_file database.g object1 object2...\n";
d104 1
d621 4
a624 2
#if 0
	/* eliminate any vertices that plainly should be moved in a different direction */
d627 1
d629 4
a632 4
		struct faceuse *fu;
		vect_t norm;
		fastf_t dot;
		int ok=0;
d634 1
a634 1
		for( BU_LIST_FOR( vu, vertexuse, &hit1_v->vu_hd ) )
d636 2
a637 6
			fu = nmg_find_fu_of_vu( vu );
			if( fu->orientation != OT_SAME )
				continue;
			NMG_GET_FU_NORMAL( norm, fu );
			dot = VDOT( norm, ap->a_ray.r_dir );
			if( !NEAR_ZERO( dot, 0.00001 ) )
d639 8
a646 4
				ok = 1;
				break;
			}
		}
d648 5
a652 7
		if( !ok )
		{
			if( debug )
			{
				bu_log( "Eliminating hit1_v (%g %g %g) dir=(%g %g %g)\n",
					V3ARGS( hit1_v->vg_p->coord ),
					V3ARGS( ap->a_ray.r_dir ) );
a653 1
			hit1_v = (struct vertex *)NULL;
a655 1

d658 1
d660 4
a663 4
		struct faceuse *fu;
		vect_t norm;
		fastf_t dot;
		int ok=0;
d665 1
a665 1
		for( BU_LIST_FOR( vu, vertexuse, &hit2_v->vu_hd ) )
d667 2
a668 6
			fu = nmg_find_fu_of_vu( vu );
			if( fu->orientation != OT_SAME )
				continue;
			NMG_GET_FU_NORMAL( norm, fu );
			dot = VDOT( norm, ap->a_ray.r_dir );
			if( !NEAR_ZERO( dot, 0.00001 ) )
d670 6
a675 4
				ok = 1;
				break;
			}
		}
d677 1
a677 11
		if( !ok )
		{
			if( debug )
			{
				bu_log( "Eliminating hit2_v (%g %g %g) dir=(%g %g %g)\n",
					V3ARGS( hit2_v->vg_p->coord ),
					V3ARGS( ap->a_ray.r_dir ) );
			}
			hit2_v = (struct vertex *)NULL;
		}
	}
d679 1
a679 9
	if( hit1_v )
	{
		/* check if hit1_v is an extreme vertex (raytrace the NMG) */
		if( extremes )
		{
			if( hit1[ap->a_user] > hit1_v->vg_p->coord[ap->a_user] + tol.dist )
			{
				hit1_v = (struct vertex *)NULL;
				if( debug )
d681 2
a682 3
					bu_log( "Eliminating hit1_v (%g %g %g) hit1=(%g %g %g)\n",
						V3ARGS( hit1_v->vg_p->coord ),
						V3ARGS( hit1 ) );
a685 6
		else if( debug )
		{
			bu_log( "No hits for pt=(%g %g %g) dir=(%g %g %g), not adjusting vertex at (%g %g %g)\n",
				V3ARGS( ap->a_ray.r_pt ), V3ARGS( ap->a_ray.r_dir ), V3ARGS( hit1_v->vg_p->coord ) );
			hit1_v = (struct vertex *)NULL;
		}
d687 1
a687 6
	else if( debug )
	{
		bu_log( "Cannot find NMG vertex for first hit at (%g %g %g), in dir (%g %g %g)\n",
			V3ARGS( mhit1 ), V3ARGS( ap->a_ray.r_dir ) );
	}
#endif
d733 1
a733 36
#if 0
	if( hit2_v )
	{
		/* check if hit2_v is an extreme vertex (raytrace the NMG) */
		if( extremes == (-1) )
			extremes=Get_extremes( s, &ap2, sd->hitmiss, sd->manifolds, hit1, hit2 );
		if( extremes )
		{
			if( hit2[ap->a_user] < hit2_v->vg_p->coord[ap->a_user] - tol.dist )
			{
				if( debug )
				{
					bu_log( "Eliminating hit2_v (%g %g %g) hit2=(%g %g %g)\n",
						V3ARGS( hit2_v->vg_p->coord ),
						V3ARGS( hit2 ) );
				}
				hit2_v = (struct vertex *)NULL;
			}
		}
		else
		{
			if( debug )
			{
				bu_log( "Eliminating hit2_v (%g %g %g) hit2=(%g %g %g)\n",
					V3ARGS( hit2_v->vg_p->coord ),
					V3ARGS( hit2 ) );
			}
			hit2_v = (struct vertex *)NULL;
		}
	}
	else if( debug )
	{
		bu_log( "Cannot find NMG vertex for last hit at (%g %g %g), in dir (%g %g %g)\n",
			V3ARGS( mhit2 ), V3ARGS( ap->a_ray.r_dir ) );
	}
#endif
d782 1
a782 1
#if 1
a1033 236
#else
static void
Split_side_faces( s, tab )
struct shell *s;
struct bu_ptbl *tab;
{
	int i, j;
	int dir1, dir2;
	int edge_no;
	struct bu_ptbl edges;
	fastf_t cell_diag_sq = 2.0 * cell_size * cell_size;

	nmg_edge_tabulate( &edges, &s->l.magic );
	bu_ptbl_init( &verts, 128, "verts" );

	dir1 = cur_dir + 1;
	if( dir1 == 3 )
		dir1 = 0;
	dir2 = dir1 + 1;
	if( dir2 == 3 )
		dir2 = 0;


	for( edge_no=0 ; edge_no<BU_PTBL_END( &edges ) ; edge_no++ )
	{
		struct faceuse *fu;
		struct edge *e;
		struct vertex_g *vg1, *vg2;
		struct edgeuse *new_eu;
		struct vertex *v;
		fastf_t y_coord;
		point_t pt;
		fastf_t d0, d1, d2;
		fastf_t dist_dir0, dist_dir1, dist_dir2;

		e = (struct edge *)BU_PTBL_GET( &edges, edge_no );
		NMG_CK_EDGE( e );

		vg1 = e->eu_p->vu_p->v_p->vg_p;
		vg2 = e->eu_p->eumate_p->vu_p->v_p->vg_p;

		d0 = vg1->coord[cur_dir] - vg2->coord[cur_dir];
		d1 = vg1->coord[dir1] - vg2->coord[dir1];
		d2 = vg1->coord[dir2] - vg2->coord[dir2];

		dist_dir0 = ABS( d0 );
		dist_dir1 = ABS( d1 );
		dist_dir2 = ABS( d2 );

bu_log( "edge (%g %g %g)<->(%g %g %g)\n", V3ARGS( vg1->coord ), V3ARGS( vg2->coord ) );

		if( (cur_dir == X || vg1->coord[X] == vg2->coord[X]) &&
		    (cur_dir == Y || vg1->coord[Y] == vg2->coord[Y]) &&
		    (cur_dir == Z || vg1->coord[Z] == vg2->coord[Z]) )
		{
			if( vg1->coord[cur_dir] > vg2->coord[cur_dir] )
			{
				struct vertex_g *tmp_vg;

				tmp_vg = vg1;
				vg1 = vg2;
				vg2 = tmp_vg;
				new_eu = e->eu_p->eumate_p;
			}
			else
				new_eu = e->eu_p;
bu_log( "\tedge is in direction of initial rays\n" );

			switch( cur_dir)
			{
				case X:
					for( j=0 ; j<cell_count[X] ; j++ )
					{
						VSET( pt, xy_rays[XY_CELL(j,0)].r_pt[X], vg1->coord[Y], vg1->coord[Z] )
						if( !IN_SEG( pt[X], vg1->coord[X], vg2->coord[X] ))
							continue;

						new_eu = nmg_esplit( (struct vertex *)NULL, new_eu, 0 );
						nmg_vertex_gv( new_eu->vu_p->v_p, pt );
						bu_ptbl_ins( &verts, (long *)new_eu->vu_p->v_p );
					}
					break;
				case Y:
					for( j=0 ; j<cell_count[Y] ; j++ )
					{
						VSET( pt, vg1->coord[X], xy_rays[XY_CELL(0,j)].r_pt[Y], vg1->coord[Z] )
						if( !IN_SEG( pt[Y], vg1->coord[Y], vg2->coord[Y] ) )
							continue;

						new_eu = nmg_esplit( (struct vertex *)NULL, new_eu, 0 );
						nmg_vertex_gv( new_eu->vu_p->v_p, pt );
						bu_ptbl_ins( &verts, (long *)new_eu->vu_p->v_p );
					}
					break;
				case Z:
					for( j=0 ; j<cell_count[Z] ; j++ )
					{
						VSET( pt, vg1->coord[X], vg1->coord[Y], xz_rays[XZ_CELL(0,j)].r_pt[Z] );
						if( !IN_SEG( pt[Z], vg1->coord[Z], vg2->coord[Z] ) )
							continue;

						new_eu = nmg_esplit( (struct vertex *)NULL, new_eu, 0 );
						nmg_vertex_gv( new_eu->vu_p->v_p, pt );
						bu_ptbl_ins( &verts, (long *)new_eu->vu_p->v_p );
					}
					break;
			}
		}
		else if( dist_dir0 < dist_dir1 && dist_dir0 < dist_dir2 &&
			((cur_dir != X && vg1->coord[X] == vg2->coord[X]) ||
			 (cur_dir != Y && vg1->coord[Y] == vg2->coord[Y]) ||
			 (cur_dir != Z && vg1->coord[Z] == vg2->coord[Z])) )
		{
			int loop_end;

			new_eu = e->eu_p;
bu_log( "\tedge has at least one other coordinate constant\n" );
			if( dist_dir1 > dist_dir2 && dist_dir1 > cell_size )
			{
				if( d1 > 0.0 )
					new_eu = new_eu->eumate_p;

				for( j=0 ; j<cell_count[dir1] ; j++ )
				{
					switch( dir1 )
					{
						case X:
							pt[dir1] = xy_rays[XY_CELL(j,0)].r_pt[dir1];
							break;
						case Y:
							pt[dir1] = xy_rays[XY_CELL(0,j)].r_pt[dir1];
							break;
						case Z:
							pt[dir1] = yz_rays[YZ_CELL(0,j)].r_pt[dir1];
							break;
					}
					if( !IN_SEG( pt[dir1], vg1->coord[dir1], vg2->coord[dir1] ) )
						continue;
					pt[dir2] = vg2->coord[dir2] + d2 * (pt[dir1] - vg2->coord[dir1]) / d1;
					if( !IN_SEG( pt[dir2], vg1->coord[dir2], vg2->coord[dir2] ))
						continue;

					pt[cur_dir] = vg1->coord[cur_dir];

					new_eu = nmg_esplit( (struct vertex *)NULL, new_eu, 0 );
					nmg_vertex_gv( new_eu->vu_p->v_p, pt );
					bu_ptbl_ins( &verts, (long *)new_eu->vu_p->v_p );
				}
			}
			else if( dist_dir2 > cell_size )
			{
				if( d2 > 0.0 )
					new_eu = new_eu->eumate_p;

				for( j=0 ; j<cell_count[dir2] ; j++ )
				{
					switch( dir2 )
					{
						case X:
							pt[dir2] = xy_rays[XY_CELL(j,0)].r_pt[dir2];
							break;
						case Y:
							pt[dir2] = xy_rays[XY_CELL(0,j)].r_pt[dir2];
							break;
						case Z:
							pt[dir2] = yz_rays[YZ_CELL(0,j)].r_pt[dir2];
							break;
					}
					if( !IN_SEG( pt[dir2], vg1->coord[dir2], vg2->coord[dir2] ) )
						continue;
					pt[dir1] = vg2->coord[dir1] + d1 * (pt[dir2] - vg2->coord[dir2]) / d2;
					if( !IN_SEG( pt[dir1], vg1->coord[dir1], vg2->coord[dir1] ))
						continue;

					pt[cur_dir] = vg1->coord[cur_dir];

					new_eu = nmg_esplit( (struct vertex *)NULL, new_eu, 0 );
					nmg_vertex_gv( new_eu->vu_p->v_p, pt );
					bu_ptbl_ins( &verts, (long *)new_eu->vu_p->v_p );
				}
			}
		}
		else
		{
			struct vertex *new_v;
			fastf_t d[3];
			fastf_t dist[3];
			fastf_t len, len_sq;
			vect_t edge_dir;
			point_t pt;
			int splits;
			fastf_t split_len;

			new_eu = e->eu_p;
bu_log( "\tlast resort\n" );

			d[X] = vg2->coord[X] - vg1->coord[X];
			d[Y] = vg2->coord[Y] - vg1->coord[Y];
			d[Z] = vg2->coord[Z] - vg1->coord[Z];

			len_sq = d[X] * d[X] + d[Y] * d[Y] + d[Z] * d[Z];
			if( len_sq <= 1.5 * cell_diag_sq )
				continue;

			len = sqrt( len_sq );
			splits = len / cell_size;
			if( splits < 1 )
				continue;

			split_len = len / (double)(splits + 1);

			dist[X] = ABS( d[X] );
			dist[Y] = ABS( d[Y] );
			dist[Z] = ABS( d[Z] );

			VMOVE( edge_dir, d );
			VUNITIZE( edge_dir );

			for( i=1 ; i<=splits ; i++ )
			{
				fastf_t a;

				a = split_len * (double)i;
				VJOIN1( pt, vg1->coord, a, edge_dir );
				new_eu = nmg_esplit( (struct vertex *)NULL, new_eu, 0 );
				new_v = new_eu->vu_p->v_p;
				bu_ptbl_ins( tab, (long *)new_v );
				nmg_vertex_gv( new_v, pt );
				bu_ptbl_ins( &verts, (long *)new_eu->vu_p->v_p );
			}
		}
	}

	bu_ptbl_free( &edges );
}
#endif
d1911 1
@


1.2
log
@First useful version.
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/g-shell.rect.c,v 1.1 1998/01/14 20:17:07 jra Exp jra $ (BRL)";
d90 2
a91 1
static char *usage="Usage:\n%s [-d debug_level] [-r] [-R refinement_tolerance] [-c] [-v] [-g cell_size] [-o brlcad_output_file] [-d debug_level] database.g object1 object2...\n";
d100 2
a101 2
static int	verbose=0;
static int	do_extra_rays=0;
a106 1
static char	*sgp_file=(char *)NULL;
d116 2
d1987 7
a1993 1
	if( do_extra_rays || edge_tol > 0.0 )
d2017 1
d2022 4
d2111 1
a2111 1
	while( (c=getopt( argc, argv, "a:s:rR:vg:o:d:p:X:")) != EOF)
d2115 20
d2199 2
a2200 2
			case 'r':	/* do extra raytracing to refine shape */
				do_extra_rays = 1;
a2210 3
			case 'v':	/* verbose */
				verbose = 1;
				break;
a2229 6
	if( output_file && sgp_file )
	{
		bu_log( usage, argv[0] );
		exit( 1 );
	}

d2240 2
a2241 11

	if( sgp_file )
	{
		if( (fd_sgp=fopen( sgp_file, "w")) == NULL )
		{
			bu_log( "Cannot open output file (%s)\n", sgp_file );
			perror( argv[0] );
			exit( 1 );
		}
		fprintf( fd_sgp, "object\n" );
	}
d2277 4
a2280 2
	bb_area[X] = (rtip->mdl_max[Y] - rtip->mdl_min[Y]) *
		     (rtip->mdl_max[Z] - rtip->mdl_min[Z]);
d2282 2
a2283 2
	bb_area[Y] = (rtip->mdl_max[X] - rtip->mdl_min[X]) *
		     (rtip->mdl_max[Z] - rtip->mdl_min[Z]);
d2285 11
a2295 8
	bb_area[Z] = (rtip->mdl_max[Y] - rtip->mdl_min[Y]) *
		     (rtip->mdl_max[X] - rtip->mdl_min[X]);

	cur_dir = X;
	if( bb_area[Y] > bb_area[cur_dir] )
		cur_dir = Y;
	if( bb_area[Z] > bb_area[cur_dir] )
		cur_dir = Z;
@


1.1
log
@Initial revision
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /m/cad/conv/RCS/g-wave.c,v 1.2 1997/06/11 21:01:25 jra Exp $ (BRL)";
d31 26
d90 1
a90 1
static char *usage="Usage:\n%s [-r] [-c] [-v] [-g cell_size] [-o brlcad_output_file] [-d debug_level] database.g object1 object2...\n";
d93 1
d101 1
d103 1
a103 2
static int	x_cells, y_cells, z_cells;
static int	ray_dir;
d113 7
a119 5
static int	close_shell=1;

#define	XY_CELL( _i, _j )	((_i)*y_cells + (_j))
#define	XZ_CELL( _i, _j )	((_i)*z_cells + (_j))
#define	YZ_CELL( _i, _j )	((_i)*z_cells + (_j))
d265 3
a267 2
	struct vertex **verts[3];
	struct faceuse *fu;
d273 4
d278 1
d281 4
d286 1
d291 4
d296 1
d299 4
d304 1
d309 4
d314 1
d317 4
d322 1
d326 5
a330 1
				MAKE_FACE( lpart[3]->out, lpart[0]->out, lpart[2]->out, s )
d332 1
d337 4
d342 1
d345 51
a395 4
				MAKE_FACE( lpart[0]->in, lpart[1]->in, lpart[2]->in, s )
				MAKE_FACE( lpart[0]->in, lpart[2]->in, lpart[3]->in, s )
				MAKE_FACE( lpart[2]->out, lpart[1]->out, lpart[0]->out, s )
				MAKE_FACE( lpart[2]->out, lpart[0]->out, lpart[3]->out, s )
d509 1
a509 1

d533 26
a558 1
		switch( ap->a_user )
d560 9
a568 34
			case X:
				if( NEAR_ZERO( ap->a_ray.r_pt[Y] - vg->coord[Y], tol.dist ) &&
				    NEAR_ZERO( ap->a_ray.r_pt[Z] - vg->coord[Z], tol.dist ) )
				{
					dist = ap->a_ray.r_pt[X] - vg->coord[X];
					if( dist < extreme_dist1 )
					{
						extreme_dist1 = dist;
						hit1_v = v;
					}
					if( dist > extreme_dist2 )
					{
						extreme_dist2 = dist;
						hit2_v = v;
					}
				}
				break;
			case Z:
				if( NEAR_ZERO( ap->a_ray.r_pt[Y] - vg->coord[Y], tol.dist ) &&
				    NEAR_ZERO( ap->a_ray.r_pt[X] - vg->coord[X], tol.dist ) )
				{
					dist = ap->a_ray.r_pt[Z] - vg->coord[Z];
					if( dist < extreme_dist1 )
					{
						extreme_dist1 = dist;
						hit1_v = v;
					}
					if( dist > extreme_dist2 )
					{
						extreme_dist2 = dist;
						hit2_v = v;
					}
				}
				break;
d570 12
d586 1
d589 3
d599 6
d606 3
d610 1
d612 38
d651 35
d691 1
a691 1
		if( (extremes=Get_extremes( s, &ap2, sd->hitmiss, sd->manifolds, hit1, hit2 ) ))
d693 1
a693 1
			switch( ap->a_user )
d695 7
a701 16
				case X:
					if( hit1[X] > hit1_v->vg_p->coord[X] + tol.dist )
						hit1_v = (struct vertex *)NULL;
					break;
				case Z:
					if( hit1[Z] > hit1_v->vg_p->coord[Z] + tol.dist )
					{
						if( debug )
						{
							bu_log( "Eliminating hit1_v (%g %g %g) hit1=(%g %g %g)\n",
								V3ARGS( hit1_v->vg_p->coord ),
								V3ARGS( hit1 ) );
						}
						hit1_v = (struct vertex *)NULL;
					}
					break;
d716 1
d729 3
d733 11
a743 1
			fu = nmg_find_fu_of_vu( vu );
d762 1
a762 1

d766 2
d770 1
a770 1
			switch( ap->a_user )
d772 7
a778 16
				case X:
					if( hit2[X] < hit2_v->vg_p->coord[X] - tol.dist )
						hit2_v = (struct vertex *)NULL;
					break;
				case Z:
					if( hit2[Z] < hit2_v->vg_p->coord[Z] - tol.dist )
					{
						if( debug )
						{
							bu_log( "Eliminating hit2_v (%g %g %g) hit2=(%g %g %g)\n",
								V3ARGS( hit2_v->vg_p->coord ),
								V3ARGS( hit2 ) );
						}
						hit2_v = (struct vertex *)NULL;
					}
					break;
d782 7
d790 1
d797 1
d810 3
d814 11
a824 1
			fu = nmg_find_fu_of_vu( vu );
d846 249
d1096 3
d1100 1
a1100 1
Split_side_faces( s )
d1102 1
d1104 3
a1106 1
	int i;
d1108 1
d1113 9
a1121 1
	for( i=0 ; i<BU_PTBL_END( &edges ) ; i++ )
d1123 1
d1130 2
a1131 1
		int j;
d1133 1
a1133 1
		e = (struct edge *)BU_PTBL_GET( &edges, i );
d1139 26
a1164 4
		if( vg1->coord[X] != vg2->coord[X] )
			continue;
		if( vg1->coord[Z] != vg2->coord[Z] )
			continue;
d1166 44
a1209 1
		if( vg1->coord[Y] > vg2->coord[Y] )
d1211 40
a1250 1
			struct vertex_g *tmp_vg;
d1252 27
a1278 4
			tmp_vg = vg1;
			vg1 = vg2;
			vg2 = tmp_vg;
			new_eu = e->eu_p->eumate_p;
d1281 10
d1292 5
d1298 7
a1304 4
		for( j=0 ; j<y_cells ; j++ )
		{
			VSET( pt, vg1->coord[X], xy_rays[XY_CELL(0,j)].r_pt[Y], vg1->coord[Z] )
			if( pt[Y] <= vg1->coord[Y] + tol.dist || pt[Y] >= vg2->coord[Y] - tol.dist )
d1307 21
a1327 3
			new_eu = nmg_esplit( (struct vertex *)NULL, new_eu, 0 );
			nmg_vertex_gv( new_eu->vu_p->v_p, pt );
			bu_ptbl_ins( &verts, (long *)new_eu->vu_p->v_p );
d1333 1
d1342 1
d1344 1
d1346 1
d1350 6
a1355 1
	Split_side_faces( s );
a1364 4
	m = nmg_find_model( &s->l.magic);
	nmg_rebound( m, &tol );
	mk_nmg( fd_out, "shell.1", m );

d1367 1
a1367 1
	sd.hitmiss = (struct hitmiss **)bu_calloc( m->maxindex, sizeof( struct hitmiss *), "nmg geom hit list");
a1375 1
	ap.a_user = X;
d1377 1
a1377 2
	/* shoot rays in the X-direction */
	for( i=0 ; i<y_cells ; i++ )
d1379 6
a1384 1
		for( j=0 ; j<z_cells ; j++ )
d1386 33
a1418 3
			VMOVE( ap.a_ray.r_pt, yz_rays[YZ_CELL(i,j)].r_pt )
			VMOVE( ap.a_ray.r_dir, yz_rays[YZ_CELL(i,j)].r_dir )
			(void)rt_shootray( &ap );
d1422 1
a1422 3
	/* shoot rays in the Z-direction */
	ap.a_user = Z;
	for( i=0 ; i<x_cells ; i++ )
d1424 12
a1435 1
		for( j=0 ; j<y_cells ; j++ )
d1437 9
a1445 3
			VMOVE( ap.a_ray.r_pt, xy_rays[XY_CELL(i,j)].r_pt )
			VMOVE( ap.a_ray.r_dir, xy_rays[XY_CELL(i,j)].r_dir )
			(void)rt_shootray( &ap );
d1447 19
a1466 1

d1471 354
d1829 1
a1829 1
	int x_index, z_index;
d1835 1
d1838 2
d1844 1
a1844 1
	for( x_index=0 ; x_index < x_cells - 1 ; x_index++ )
d1846 35
a1880 6
		for( z_index=0 ; z_index < z_cells - 1 ; z_index++ )
		{
			cell_no[0] = XZ_CELL(x_index,z_index);
			cell_no[1] = XZ_CELL(x_index+1,z_index);
			cell_no[2] = XZ_CELL(x_index+1,z_index+1);
			cell_no[3] = XZ_CELL(x_index,z_index+1);
d1882 6
a1887 1
			for( i=0 ; i<4 ; i++ )
d1889 32
a1920 5
				if( BU_LIST_IS_EMPTY( &xz_parts[cell_no[i]].l ) )
					lpart[i] = (struct local_part *)NULL;
				else
					lpart[i] = BU_LIST_FIRST( local_part, &xz_parts[cell_no[i]].l );
			}
d1922 2
a1923 5
			status = 0;
			for( i=0 ; i<4 ; i++ )
			{
				if( lpart[i] && lpart[i]->is_void == NO )
					status += vert_ids[i];
d1925 3
a1927 2

			if( debug > 3 )
d1929 1
a1929 2
				bu_log( "Making faces for x_index=%d, z_index=%d\n", x_index, z_index );
				for( i=0 ; i<4 ; i++ )
d1931 32
a1962 3
					bu_log( "part #%d:\n", i );
					bu_log( "\tray start is (%g %g %g)\n", V3ARGS( xz_rays[cell_no[i]].r_pt ) );
					pr_part( lpart[i] );
d1965 1
a1965 3

			Make_simple_faces( s, status, lpart );
		}
d1971 3
d1975 11
a1985 1
		shrink_wrap( s );
d1987 6
d1996 1
d2018 40
a2057 10
	VSET( lpart->in->pt, 
		xz_rays[ap->a_user].r_pt[X],
		xz_rays[ap->a_user].r_pt[Y] + first_pp->pt_inhit->hit_dist,
		xz_rays[ap->a_user].r_pt[Z] );
	lpart->out->v = (struct vertex *)NULL;
	VSET( lpart->out->pt, 
		xz_rays[ap->a_user].r_pt[X],
		xz_rays[ap->a_user].r_pt[Y] + last_pp->pt_outhit->hit_dist,
		xz_rays[ap->a_user].r_pt[Z] );
	BU_LIST_INSERT( &xz_parts[ap->a_user].l, &lpart->l )
d2070 1
d2094 2
d2098 1
a2098 1
	while( (c=getopt( argc, argv, "rcvg:o:d:p:X:")) != EOF)
d2102 64
d2169 4
a2172 1
			case 'p':	/* plot final partitions */
a2186 3
			case 'c':	/* don't close shell */
				close_shell = 0;
				break;
d2262 2
a2263 2
	if( fd_plot )
		pdv_3space( fd_plot, rtip->mdl_min, rtip->mdl_max );
d2265 2
a2266 5
	x_cells = (int)((rtip->mdl_max[X] - rtip->mdl_min[X])/cell_size) + 3;
	y_cells = (int)((rtip->mdl_max[Y] - rtip->mdl_min[Y])/cell_size) + 3;
	z_cells = (int)((rtip->mdl_max[Z] - rtip->mdl_min[Z])/cell_size) + 3;
	bu_log( "cell size is %gmm\n\t%d cells in X-direction\n\t%d cells in Y-direction\n\t%d cells in Z-direction\n",
		cell_size, x_cells, y_cells, z_cells );
d2268 2
a2269 3
	x_start = rtip->mdl_min[X] - ((double)x_cells * cell_size - (rtip->mdl_max[X] - rtip->mdl_min[X]))/2.0;
	y_start = rtip->mdl_min[Y] - ((double)y_cells * cell_size - (rtip->mdl_max[Y] - rtip->mdl_min[Y]))/2.0;
	z_start = rtip->mdl_min[Z] - ((double)z_cells * cell_size - (rtip->mdl_max[Z] - rtip->mdl_min[Z]))/2.0;
d2271 11
a2281 1
	xz_parts = (struct local_part *)bu_calloc( x_cells * z_cells, sizeof( struct local_part ), "xz_parts" );
d2283 3
a2285 3
	xy_rays = (struct xray *)bu_calloc( x_cells * y_cells, sizeof( struct xray ), "xy_rays" );
	xz_rays = (struct xray *)bu_calloc( x_cells * z_cells, sizeof( struct xray ), "xz_rays" );
	yz_rays = (struct xray *)bu_calloc( y_cells * z_cells, sizeof( struct xray ), "yz_rays" );
d2287 3
a2289 12
	for( i=0 ; i<x_cells ; i++ )
	{
		for( j=0 ; j<z_cells ; j++ )
		{
			xz_parts[XZ_CELL(i,j)].is_void = UNKNOWN;
			xz_parts[XZ_CELL(i,j)].in_coord = -MAX_FASTF;
			xz_parts[XZ_CELL(i,j)].out_coord = -MAX_FASTF;
			xz_parts[XZ_CELL(i,j)].in = (struct end_pt *)NULL;
			xz_parts[XZ_CELL(i,j)].out = (struct end_pt *)NULL;
			BU_LIST_INIT( &xz_parts[XZ_CELL(i,j)].l );
		}
	}
d2291 3
d2295 1
a2295 1
	for( i=0 ; i<y_cells ; i++ )
d2297 1
a2297 1
		for( j=0 ; j<z_cells ; j++ )
d2299 1
a2299 1
			VSET( yz_rays[YZ_CELL(i,j)].r_dir, -1.0, 0.0, 0.0 )
d2301 1
a2301 1
				rtip->mdl_max[X] + cell_size,
d2304 6
d2313 1
a2313 1
	for( i=0 ; i<x_cells ; i++ )
d2315 1
a2315 1
		for( j=0 ; j<y_cells ; j++ )
d2317 1
a2317 1
			VSET( xy_rays[XY_CELL(i,j)].r_dir, 0.0, 0.0, -1.0 )
d2321 7
a2327 1
				rtip->mdl_max[Z] + cell_size )
d2330 1
a2330 1
		for( j=0 ; j<z_cells ; j++ )
d2337 6
d2347 2
a2348 2
	/* shoot rays in Y-direction */
	for( i=0 ; i<x_cells ; i++ )
d2350 32
a2381 36
		ray_dir = Y;
		for( j=0 ; j<z_cells ; j++ )
		{
			ap.a_x = i;
			ap.a_y = j;
			ap.a_user = XZ_CELL(i,j);
			VMOVE( ap.a_ray.r_pt, xz_rays[XZ_CELL(i,j)].r_pt )
			VMOVE( ap.a_ray.r_dir, xz_rays[XZ_CELL(i,j)].r_dir )
			(void)rt_shootray( &ap );
		}
	}

	Make_shell();
	if( fd_plot )
	{
		vect_t tmp_dir;
		fastf_t dir_len;

		VSET( tmp_dir, 0, 0, 1 );
		dir_len = (rtip->mdl_max[Z] - rtip->mdl_min[Z])/((double)(z_cells * 2));
		VSCALE( tmp_dir, tmp_dir, dir_len );
		/* plot partitions */
		for( i=0 ; i<x_cells ; i++ )
		{
			for( j=0 ; j<z_cells ; j++ )
			{
				struct local_part *lpart;
				int index;
				point_t tmp_pt;

				index = XZ_CELL(i,j);
				if( BU_LIST_IS_EMPTY( &xz_parts[index].l ) )
					continue;

				lpart = BU_LIST_FIRST( local_part,  &xz_parts[index].l );
				while( BU_LIST_NOT_HEAD( &lpart->l, &xz_parts[index].l ) )
d2383 6
a2388 31
					switch( lpart->is_void )
					{
						case YES:
							/* make voids red */
							pl_color( fd_plot, 255, 0, 0 );
							pdv_3line( fd_plot, lpart->in->pt, lpart->out->pt );
							break;
						case NO:
							/* make solid area green */
							pl_color( fd_plot, 0, 255, 0 );
							pdv_3line( fd_plot, lpart->in->pt, lpart->out->pt );
							break;
						case UNKNOWN:
							/* make unknown blue */
							pl_color( fd_plot, 0, 0, 255 );
							pdv_3line( fd_plot, lpart->in->pt, lpart->out->pt );
							break;
						default:
							/* make errors purple */
							pl_color( fd_plot, 255, 0, 255 );
							pdv_3line( fd_plot, lpart->in->pt, lpart->out->pt );
							break;
					}
					/* put a little white line at start and end of each partition */
					pl_color( fd_plot, 255, 255, 255 );
					VADD2( tmp_pt, lpart->in->pt, tmp_dir );
					pdv_3line( fd_plot, lpart->in->pt, tmp_pt );
					VADD2( tmp_pt, lpart->out->pt, tmp_dir );
					pdv_3line( fd_plot, lpart->out->pt, tmp_pt );

					lpart = BU_LIST_NEXT( local_part, &lpart->l );
d2391 1
a2391 1
		}
d2393 2
@
