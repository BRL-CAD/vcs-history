head	11.84;
access;
symbols
	ansi-20040405-merged:11.78.2.2
	postmerge-20040405-ansi:11.81
	premerge-20040404-ansi:11.80
	postmerge-autoconf:11.80
	autoconf-freeze:11.79.6.2
	premerge-autoconf:11.80
	ansi-20040316-freeze:11.78.2.1
	postmerge-20040315-windows:11.80
	premerge-20040315-windows:11.80
	windows-20040315-freeze:11.78.4.1
	autoconf-20031203:11.79
	autoconf-20031202:11.79
	autoconf-branch:11.79.0.6
	phong-branch:11.79.0.4
	photonmap-branch:11.79.0.2
	rel-6-1-DP:11.78
	windows-branch:11.78.0.4
	rel-6-0-2:11.76
	ansi-branch:11.78.0.2
	rel-6-0-1-branch:11.76.0.2
	hartley-6-0-post:11.77
	hartley-6-0-pre:11.76
	rel-6-0-1:11.76
	rel-6-0:11.73
	rel-5-4:11.52.2.1.2.5
	offsite-5-3-pre:11.67
	rel-5-3:11.52.2.1.2.5
	rel-5-2:11.52.2.1
	rel-5-1-branch:11.52.2.1.0.2
	rel-5-1:11.52.2.1
	rel-5-0:11.23
	rel-5-0-beta:11.21
	rel-4-5:11.11
	ctj-4-5-post:11.11
	ctj-4-5-pre:11.11
	rel-4-4:11.1
	brlcad_5_1_alpha_patch:11.52.0.2;
locks; strict;
comment	@ * @;


11.84
date	2004.05.24.04.16.12;	author morrison;	state dead;
branches;
next	11.83;

11.83
date	2004.05.10.15.30.41;	author erikg;	state Exp;
branches;
next	11.82;

11.82
date	2004.05.05.14.20.24;	author morrison;	state Exp;
branches;
next	11.81;

11.81
date	2004.04.05.07.49.36;	author morrison;	state Exp;
branches;
next	11.80;

11.80
date	2004.02.02.17.39.00;	author morrison;	state Exp;
branches;
next	11.79;

11.79
date	2002.11.27.13.41.40;	author jra;	state Exp;
branches
	11.79.6.1;
next	11.78;

11.78
date	2002.08.20.17.07.21;	author jra;	state Exp;
branches
	11.78.2.1
	11.78.4.1;
next	11.77;

11.77
date	2002.08.15.20.54.33;	author hartley;	state Exp;
branches;
next	11.76;

11.76
date	2002.06.20.13.45.33;	author butler;	state Exp;
branches;
next	11.75;

11.75
date	2002.06.19.20.07.28;	author butler;	state Exp;
branches;
next	11.74;

11.74
date	2002.05.17.12.48.56;	author morrison;	state Exp;
branches;
next	11.73;

11.73
date	2002.03.19.20.39.25;	author jra;	state Exp;
branches;
next	11.72;

11.72
date	2001.09.11.12.32.25;	author jra;	state Exp;
branches;
next	11.71;

11.71
date	2001.08.10.21.22.53;	author butler;	state Exp;
branches;
next	11.70;

11.70
date	2001.05.17.20.03.14;	author morrison;	state Exp;
branches;
next	11.69;

11.69
date	2001.04.02.13.04.20;	author jra;	state Exp;
branches;
next	11.68;

11.68
date	2001.03.20.19.13.48;	author jra;	state Exp;
branches;
next	11.67;

11.67
date	2000.12.22.16.49.27;	author jra;	state Exp;
branches;
next	11.66;

11.66
date	2000.12.22.01.09.22;	author jra;	state Exp;
branches;
next	11.65;

11.65
date	2000.12.21.15.05.52;	author jra;	state Exp;
branches;
next	11.64;

11.64
date	2000.12.01.13.37.19;	author jra;	state Exp;
branches;
next	11.63;

11.63
date	2000.11.30.14.33.42;	author jra;	state Exp;
branches;
next	11.62;

11.62
date	2000.10.31.22.35.11;	author mike;	state Exp;
branches;
next	11.61;

11.61
date	2000.10.24.14.41.31;	author mike;	state Exp;
branches;
next	11.60;

11.60
date	2000.10.20.20.29.23;	author jra;	state Exp;
branches;
next	11.59;

11.59
date	2000.09.08.05.55.41;	author mike;	state Exp;
branches;
next	11.58;

11.58
date	2000.08.24.03.24.07;	author mike;	state Exp;
branches;
next	11.57;

11.57
date	2000.08.24.03.23.12;	author mike;	state Exp;
branches;
next	11.56;

11.56
date	2000.07.21.12.44.34;	author jra;	state Exp;
branches;
next	11.55;

11.55
date	2000.07.13.19.55.21;	author jra;	state Exp;
branches;
next	11.54;

11.54
date	2000.07.12.21.59.34;	author mike;	state Exp;
branches;
next	11.53;

11.53
date	2000.07.10.23.53.56;	author mike;	state Exp;
branches;
next	11.52;

11.52
date	2000.07.07.20.24.16;	author jra;	state Exp;
branches
	11.52.2.1;
next	11.51;

11.51
date	2000.06.27.15.03.48;	author jra;	state Exp;
branches;
next	11.50;

11.50
date	2000.06.20.17.30.00;	author jra;	state Exp;
branches;
next	11.49;

11.49
date	2000.06.19.17.54.34;	author jra;	state Exp;
branches;
next	11.48;

11.48
date	2000.06.08.17.53.32;	author jra;	state Exp;
branches;
next	11.47;

11.47
date	2000.06.06.20.45.22;	author jra;	state Exp;
branches;
next	11.46;

11.46
date	2000.04.13.13.08.30;	author mike;	state Exp;
branches;
next	11.45;

11.45
date	2000.04.11.18.13.48;	author jra;	state Exp;
branches;
next	11.44;

11.44
date	2000.03.29.18.07.44;	author mike;	state Exp;
branches;
next	11.43;

11.43
date	2000.03.17.18.25.45;	author jra;	state Exp;
branches;
next	11.42;

11.42
date	2000.03.17.16.34.00;	author jra;	state Exp;
branches;
next	11.41;

11.41
date	2000.03.17.16.09.35;	author jra;	state Exp;
branches;
next	11.40;

11.40
date	2000.03.10.19.53.19;	author jra;	state Exp;
branches;
next	11.39;

11.39
date	2000.03.10.18.19.27;	author jra;	state Exp;
branches;
next	11.38;

11.38
date	2000.03.09.18.20.21;	author jra;	state Exp;
branches;
next	11.37;

11.37
date	2000.03.02.15.55.44;	author jra;	state Exp;
branches;
next	11.36;

11.36
date	2000.03.02.14.39.40;	author jra;	state Exp;
branches;
next	11.35;

11.35
date	2000.02.17.19.24.32;	author jra;	state Exp;
branches;
next	11.34;

11.34
date	99.12.30.18.38.42;	author jra;	state Exp;
branches;
next	11.33;

11.33
date	99.12.30.14.20.01;	author jra;	state Exp;
branches;
next	11.32;

11.32
date	99.12.29.23.22.59;	author mike;	state Exp;
branches;
next	11.31;

11.31
date	99.12.29.21.09.17;	author mike;	state Exp;
branches;
next	11.30;

11.30
date	99.11.17.21.27.20;	author jra;	state Exp;
branches;
next	11.29;

11.29
date	99.11.17.16.20.33;	author jra;	state Exp;
branches;
next	11.28;

11.28
date	99.11.15.17.47.54;	author jra;	state Exp;
branches;
next	11.27;

11.27
date	99.11.15.14.13.54;	author jra;	state Exp;
branches;
next	11.26;

11.26
date	99.11.15.14.09.15;	author jra;	state Exp;
branches;
next	11.25;

11.25
date	99.11.15.13.34.11;	author jra;	state Exp;
branches;
next	11.24;

11.24
date	99.09.22.15.30.31;	author jra;	state Exp;
branches;
next	11.23;

11.23
date	99.06.03.21.54.19;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	99.06.03.13.38.54;	author jra;	state Exp;
branches;
next	11.21;

11.21
date	99.05.26.23.02.17;	author jra;	state Exp;
branches;
next	11.20;

11.20
date	99.05.26.19.20.00;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	99.05.25.20.23.00;	author jra;	state Exp;
branches;
next	11.18;

11.18
date	99.05.25.14.18.43;	author jra;	state Exp;
branches;
next	11.17;

11.17
date	99.05.24.17.33.07;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	99.05.17.20.36.40;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	99.05.12.20.35.28;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	98.10.19.20.08.33;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	98.10.16.00.36.53;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	98.07.27.12.34.24;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	97.07.11.15.00.29;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	97.06.04.19.11.35;	author jra;	state Exp;
branches;
next	11.9;

11.9
date	97.05.28.18.06.20;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	97.03.05.20.00.14;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	96.10.25.15.56.26;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	96.10.08.19.34.51;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	96.07.12.13.20.17;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	95.10.19.17.09.17;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.01.17.10.56.22;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.01.13.16.21.24;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.59.27;	author mike;	state Rel4_4;
branches;
next	1.20;

1.20
date	95.01.03.09.49.16;	author jra;	state Exp;
branches;
next	1.19;

1.19
date	94.12.09.16.21.43;	author jra;	state Exp;
branches;
next	1.18;

1.18
date	94.12.02.16.27.19;	author jra;	state Exp;
branches;
next	1.17;

1.17
date	94.12.02.16.24.55;	author jra;	state Exp;
branches;
next	1.16;

1.16
date	94.12.01.11.16.44;	author jra;	state Exp;
branches;
next	1.15;

1.15
date	94.11.08.16.14.57;	author jra;	state Exp;
branches;
next	1.14;

1.14
date	94.11.01.09.34.22;	author jra;	state Exp;
branches;
next	1.13;

1.13
date	94.10.19.22.03.33;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	94.09.22.13.12.53;	author jra;	state Exp;
branches;
next	1.11;

1.11
date	94.09.21.04.30.22;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	94.09.21.04.20.45;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	94.08.10.23.52.07;	author gdurf;	state Exp;
branches;
next	1.8;

1.8
date	94.07.15.15.59.17;	author jra;	state Exp;
branches;
next	1.7;

1.7
date	94.07.14.12.31.57;	author jra;	state Exp;
branches;
next	1.6;

1.6
date	94.07.13.13.43.26;	author jra;	state Exp;
branches;
next	1.5;

1.5
date	94.06.27.10.49.25;	author jra;	state Exp;
branches;
next	1.4;

1.4
date	94.05.03.13.08.31;	author jra;	state Exp;
branches;
next	1.3;

1.3
date	94.04.18.14.06.20;	author jra;	state Exp;
branches;
next	1.2;

1.2
date	94.04.15.16.10.03;	author jra;	state Exp;
branches;
next	1.1;

1.1
date	94.04.15.14.41.39;	author jra;	state Exp;
branches;
next	;

11.52.2.1
date	2000.07.13.19.07.33;	author jra;	state Exp;
branches
	11.52.2.1.2.1;
next	;

11.52.2.1.2.1
date	2000.11.30.14.31.57;	author jra;	state Exp;
branches;
next	11.52.2.1.2.2;

11.52.2.1.2.2
date	2000.12.21.15.09.22;	author jra;	state Exp;
branches;
next	11.52.2.1.2.3;

11.52.2.1.2.3
date	2000.12.22.14.06.15;	author jra;	state Exp;
branches;
next	11.52.2.1.2.4;

11.52.2.1.2.4
date	2000.12.22.15.09.33;	author jra;	state Exp;
branches;
next	11.52.2.1.2.5;

11.52.2.1.2.5
date	2000.12.26.18.57.38;	author jra;	state Exp;
branches;
next	;

11.78.2.1
date	2002.09.19.18.00.35;	author morrison;	state Exp;
branches;
next	11.78.2.2;

11.78.2.2
date	2004.03.17.21.15.55;	author morrison;	state Exp;
branches;
next	;

11.78.4.1
date	2004.03.11.23.40.29;	author morrison;	state Exp;
branches;
next	;

11.79.6.1
date	2004.02.12.19.24.23;	author erikg;	state Exp;
branches;
next	11.79.6.2;

11.79.6.2
date	2004.03.15.14.06.07;	author erikg;	state Exp;
branches;
next	;


desc
@Fastgen4 to BRLCAD Converter
@


11.84
log
@moved to src/conv/
@
text
@/*
 *                      F A S T 4 - G
 *
 *  Program to convert the FASTGEN4 format to BRL-CAD.
 *
 *  Author -
 *      John R. Anderson
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1994-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */

#ifndef lint
static const char RCSid[] = "$Header: /n/xoff/cvs/brlcad/conv/fast4-g.c,v 11.83 2004/05/10 15:30:41 erikg Exp $";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <ctype.h>
#include <errno.h>

#include "machine.h"
#include "externs.h"
#include "db.h"
#include "vmath.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "wdb.h"
#include "plot3.h"
#include "../librt/debug.h"

#define		LINELEN		128	/* Length of char array for input line */

#define		REGION_LIST_BLOCK	256	/* initial length of array of region ids to process */

static char	line[LINELEN+1];		/* Space for input line */
static FILE	*fdin;			/* Input FASTGEN4 file pointer */
static struct rt_wdb *fdout;		/* Output BRL-CAD file pointer */
static FILE	*fd_plot=NULL;		/* file for plot output */
static FILE	*fd_muves=NULL;		/* file for MUVES data, output CHGCOMP and CBACKING data */
static int	grid_size;		/* Number of points that will fit in current grid_pts array */
static int	max_grid_no=0;		/* Maximum grid number used */
static int	mode=0;			/* Plate mode (1) or volume mode (2), of current component */
static int	group_id=(-1);		/* Group identification number from SECTION card */
static int	comp_id=(-1);		/* Component identification number from SECTION card */
static int	region_id=0;		/* Region id number (group id no X 1000 + component id no) */
static char	field[9];		/* Space for storing one field from an input line */
static char	vehicle[17];		/* Title for BRLCAD model from VEHICLE card */
static int	name_count;		/* Count of number of times this name_name has been used */
static int	pass;			/* Pass number (0 -> only make names, 1-> do geometry ) */
static int	bot=0;			/* Flag: >0 -> There are BOT's in current component */
static int	warnings=0;		/* Flag: >0 -> Print warning messages */
static int	debug=0;		/* Debug flag */
static int	rt_debug=0;		/* RT_G_DEBUG */
static int	quiet=0;		/* flag to not blather */
static int	comp_count=0;		/* Count of components in FASTGEN4 file */
static int	do_skips=0;		/* flag indicating that not all components will be processed */
static int	*region_list;		/* array of region_ids to be processed */
static int	region_list_len=0;	/* actual length of the malloc'd region_list array */
static int	do_plot=0;		/* flag indicating plot file should be created */
static struct wmember  group_head[11];	/* Lists of regions for groups */
static struct wmember  hole_head;	/* List of regions used as holes (not solid parts of model) */
static struct bu_ptbl stack;		/* Stack for traversing name_tree */
static struct bu_ptbl stack2;		/* Stack for traversing name_tree */
static fastf_t	min_radius;		/* minimum radius for TGC solids */

static int		*faces=NULL;	/* one triplet per face indexing three grid points */
static fastf_t		*thickness;	/* thickness of each face */
static char		*facemode;	/* mode for each face */
static int		face_size=0;	/* actual length of above arrays */
static int		face_count=0;	/* number of faces in above arrays */

static int	*int_list;		/* Array of integers */
static int	int_list_count=0;	/* Number of ints in above array */
static int	int_list_length=0;	/* Length of int_list array */
#define		INT_LIST_BLOCK	256	/* Number of int_list array slots to allocate */

static char	*usage="Usage:\n\tfast4-g [-dwq] [-c component_list] [-m muves_file] [-o plot_file] [-b BU_DEBUG_FLAG] [-x RT_DEBUG_FLAG] fastgen4_bulk_data_file output.g\n\
	d - print debugging info\n\
	q - quiet mode (don't say anyhing except error messages\n\
	w - print warnings about creating default names\n\
	c - process only the listed region ids, may be a list (3001,4082,5347) or a range (2314-3527)\n\
	m - create a MUVES input file containing CHGCOMP and CBACKING elements\n\
	o - create a 'plot_file' containing a libplot3 plot file of all CTRI and CQUAD elements processed\n\
	b - set LIBBU debug flag\n\
	x - set RT debug flag\n";

#define		PLATE_MODE	1
#define		VOLUME_MODE	2

#define		POS_CENTER	1	/* face positions for facets */
#define		POS_FRONT	2

#define		END_OPEN	1	/* End closure codes for cones */
#define		END_CLOSED	2

#define		GRID_BLOCK	256	/* allocate space for grid points in blocks of 256 points */

#define		CLINE		'l'
#define		CHEX1		'p'
#define		CHEX2		'b'
#define		CTRI		't'
#define		CQUAD		'q'
#define		CCONE1		'c'
#define		CCONE2		'd'
#define		CCONE3		'e'
#define		CSPHERE		's'
#define		NMG		'n'
#define		BOT		't'
#define		COMPSPLT	'h'

void make_region_name(int g_id, int c_id);
char * make_solid_name(char type, int element_id, int c_id, int g_id, int inner);

unsigned char *get_fast4_color();

struct fast4_color {
  struct bu_list l;
  short low;
  short high;
  unsigned char rgb[3];
};

struct fast4_color HeadColor;

/* convenient macro for building regions */
#define	MK_REGION( fp , headp , name , r_id, rgb ) \
			{\
				if( mode == 1 ) {\
					if( !quiet )\
						bu_log( "Making region: %s (PLATE)\n", name ); \
					mk_fastgen_region( fp , name , &((headp)->l) , 'P' ,\
						(char *)NULL, (char *)NULL, rgb, r_id, 0, 0, 0, 0 ); \
				}\
				else if( mode == 2 ) {\
					if( !quiet ) \
						bu_log( "Making region: %s (VOLUME)\n", name ); \
					mk_fastgen_region( fp , name , &((headp)->l) , 'V' ,\
						(char *)NULL, (char *)NULL, rgb, r_id, 0, 0, 0, 0 ); \
				}\
				else\
				{\
					bu_log( "Illegal mode (%d), while trying to make region (%s)\n",\
						mode, name );\
					bu_log( "\tRegion not made!!!!!\n");\
				}\
			}

#define	PUSH( ptr )	bu_ptbl_ins( &stack , (long *)ptr )
#define POP( structure , ptr )	{ if( BU_PTBL_END( &stack ) == 0 ) \
				ptr = (struct structure *)NULL; \
			  else \
			  { \
			  	ptr = (struct structure *)BU_PTBL_GET( &stack , BU_PTBL_END( &stack )-1 ); \
			  	bu_ptbl_rm( &stack , (long *)ptr ); \
			  } \
			}
#define	PUSH2( ptr )	bu_ptbl_ins( &stack2 , (long *)ptr )
#define POP2( structure , ptr )	{ if( BU_PTBL_END( &stack2 ) == 0 ) \
				ptr = (struct structure *)NULL; \
			  else \
			  { \
			  	ptr = (struct structure *)BU_PTBL_GET( &stack2 , BU_PTBL_END( &stack2 )-1 ); \
			  	bu_ptbl_rm( &stack2 , (long *)ptr ); \
			  } \
			}

#define	NHEX_FACES	12
int hex_faces[12][3]={
	{ 0 , 1 , 4 }, /* 1 */
	{ 1 , 5 , 4 }, /* 2 */
	{ 1 , 2 , 5 }, /* 3 */
	{ 2 , 6 , 5 }, /* 4 */
	{ 2 , 3 , 6 }, /* 5 */
	{ 3 , 7 , 6 }, /* 6 */
	{ 3 , 0 , 7 }, /* 7 */
	{ 0 , 4 , 7 }, /* 8 */
	{ 4 , 6 , 7 }, /* 9 */
	{ 4 , 5 , 6 }, /* 10 */
	{ 0 , 1 , 2 }, /* 11 */
	{ 0 , 2 , 3 }  /* 12 */
};

struct cline
{
	int pt1,pt2;
	int element_id;
	int made;
	fastf_t thick;
	fastf_t radius;
	struct cline *next;
} *cline_root;

#define	NAME_TREE_MAGIC	0x55555555
#define CK_TREE_MAGIC( ptr )	\
	{\
		if( !ptr )\
			bu_log( "ERROR: Null name_tree pointer, file=%s, line=%d\n", __FILE__, __LINE__ );\
		else if( ptr->magic != NAME_TREE_MAGIC )\
			bu_log( "ERROR: bad name_tree pointer (x%x), file=%s, line=%d\n", ptr, __FILE__, __LINE__ );\
	}

struct name_tree
{
	long magic;
	int region_id;
	int mode;		/* PLATE_MODE or VOLUME_MODE */
	int inner;		/* 0 => this is a base/group name for a FASTGEN element */
	int in_comp_group;	/* > 0 -> region already in a component group */
	char *name;
	struct name_tree *nleft,*nright,*rleft,*rright;
} *name_root;

struct compsplt
{
	int ident_to_split;
	int new_ident;
	fastf_t z;
	struct compsplt *next;
} *compsplt_root;

struct hole_list
{
	int group;
	int component;
	struct hole_list *next;
};

struct holes
{
	int group;
	int component;
	int type;
	struct hole_list *holes;
	struct holes *next;
} *hole_root;

#define HOLE 1
#define WALL 2

point_t *grid_pts;

int getline(void);
void Add_holes( int type, int gr, int comp, struct hole_list *ptr );
void make_bot_object(void);
int skip_region( int id );

int
is_a_hole(int id)
{
	struct holes *hole_ptr;
	struct hole_list *ptr;

	hole_ptr = hole_root;

	while( hole_ptr )
	{
		if( hole_ptr->type == HOLE )
		{
			ptr = hole_ptr->holes;
			while( ptr )
			{
				if( (ptr->group * 1000 + ptr->component) == id )
					return( 1 );
				ptr = ptr->next;
			}
		}
		hole_ptr = hole_ptr->next;
	}
	return( 0 );
}

void
add_to_holes(char *name, int reg_id)
{
	if( mk_addmember( name , &hole_head.l, NULL, WMOP_UNION ) == (struct wmember *)NULL )
		bu_log( "add_to_holes: mk_addmember failed for region %s\n" , name );
}

void
plot_tri(int pt1, int pt2, int pt3)
{
	pdv_3move( fd_plot, grid_pts[pt1] );
	pdv_3cont( fd_plot, grid_pts[pt2] );
	pdv_3cont( fd_plot, grid_pts[pt3] );
	pdv_3cont( fd_plot, grid_pts[pt1] );
}

void
Check_names(void)
{
	struct name_tree *ptr;

	if( !name_root )
		return;

	bu_ptbl_reset( &stack );

	CK_TREE_MAGIC( name_root )
	/* ident order */
	ptr = name_root;
	while( 1 )
	{
		while( ptr )
		{
			PUSH( ptr );
			ptr = ptr->rleft;
		}
		POP( name_tree , ptr );
		if( !ptr )
			break;

		/* visit node */
		CK_TREE_MAGIC( ptr )
		ptr = ptr->rright;
	}

	/* alpabetical order */
	ptr = name_root;
	while( 1 )
	{
		while( ptr )
		{
			PUSH( ptr );
			ptr = ptr->nleft;
		}
		POP( name_tree , ptr );
		if( !ptr )
			break;

		/* visit node */
		CK_TREE_MAGIC( ptr )
		ptr = ptr->nright;
	}
}

void
insert_int(int in)
{
	int i;

	for( i=0 ; i<int_list_count ; i++ )
	{
		if( int_list[i] == in )
			return;
	}

	if( int_list_count == int_list_length )
	{
		if( int_list_length == 0 )
			int_list = (int *)bu_malloc( INT_LIST_BLOCK*sizeof( int ) , "insert_id: int_list" );
		else
			int_list = (int *)bu_realloc( (char *)int_list , (int_list_length + INT_LIST_BLOCK)*sizeof( int ) , "insert_id: int_list" );
		int_list_length += INT_LIST_BLOCK;
	}

	int_list[int_list_count] = in;
	int_list_count++;

	if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in insert_int\n" );
}

void
Subtract_holes(struct wmember *head, int comp_id, int group_id)
{
	struct holes *hole_ptr;
	struct hole_list *list_ptr;

	if( debug )
		bu_log( "Subtract_holes( comp_id=%d, group_id=%d )\n" , comp_id , group_id );

	hole_ptr = hole_root;
	while( hole_ptr )
	{
		if( hole_ptr->group == group_id && hole_ptr->component == comp_id )
		{
			list_ptr = hole_ptr->holes;
			while( list_ptr )
			{
				struct name_tree *ptr;
				int reg_id;

				reg_id = list_ptr->group * 1000 + list_ptr->component;
				ptr = name_root;
				while( ptr && ptr->region_id != reg_id )
				{
					int diff;

					diff = reg_id - ptr->region_id;
					if( diff > 0 )
						ptr = ptr->rright;
					else if( diff < 0 )
						ptr = ptr->rleft;
				}

				bu_ptbl_reset( &stack );

				while( ptr && ptr->region_id == reg_id )
				{

					while( ptr && ptr->region_id == reg_id )
					{
						PUSH( ptr );
						ptr = ptr->rleft;
					}
					POP( name_tree , ptr );
					if( !ptr ||  ptr->region_id != reg_id )
						break;

					if( debug )
						bu_log( "\tSubtracting %s\n", ptr->name );

					if( mk_addmember( ptr->name , &(head->l), NULL , WMOP_SUBTRACT ) == (struct wmember *)NULL )
						rt_bomb( "Subtract_holes: mk_addmember failed\n" );

					ptr = ptr->rright;
				}

				list_ptr = list_ptr->next;
			}
			break;
		}
		hole_ptr = hole_ptr->next;
	}
	if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in subtract_holes\n" );
}

void
do_compsplt(void)
{
	int gr, co, gr1,  co1;
	fastf_t z;
	struct compsplt *splt;

	strncpy( field, &line[8], 8 );
	gr = atoi( field );

	strncpy( field, &line[16], 8 );
	co = atoi( field );

	strncpy( field, &line[24], 8 );
	gr1 = atoi( field );

	strncpy( field, &line[32], 8 );
	co1 = atoi( field );

	strncpy( field, &line[40], 8 );
	z = atof( field ) * 25.4;

	if( compsplt_root == NULL )
	{
		compsplt_root = (struct compsplt *)bu_calloc( 1, sizeof( struct compsplt ), "compsplt_root" );
		splt = compsplt_root;
	}
	else
	{
		splt = compsplt_root;
		while( splt->next )
			splt = splt->next;
		splt->next = (struct compsplt *)bu_calloc( 1, sizeof( struct compsplt ), "compsplt_root" );
		splt = splt->next;
	}
	splt->next = (struct compsplt *)NULL;
	splt->ident_to_split = gr * 1000 + co;
	splt->new_ident = gr1 * 1000 + co1;
	splt->z = z;
	make_region_name( gr1, co1 );
}

void
List_holes(void)
{
	struct holes *hole_ptr;
	struct hole_list *list_ptr;

	hole_ptr = hole_root;

	while( hole_ptr )
	{
		bu_log( "Holes for Group %d, Component %d:\n" , hole_ptr->group, hole_ptr->component );
		list_ptr = hole_ptr->holes;
		while( list_ptr )
		{
			bu_log( "\tgroup %d component %d\n" , list_ptr->group, list_ptr->component );
			list_ptr = list_ptr->next;
		}
		hole_ptr = hole_ptr->next;
	}
}

void
List_names(void)
{
	struct name_tree *ptr;

	bu_ptbl_reset( &stack );

	bu_log( "\nNames in ident order:\n" );
	ptr = name_root;
	while( 1 )
	{
		while( ptr )
		{
			PUSH( ptr );
			ptr = ptr->rleft;
		}
		POP( name_tree , ptr );
		if( !ptr )
			break;

		if( ptr->in_comp_group )
			bu_log( "%s %d %d (in a comp group)\n" , ptr->name , ptr->region_id , ptr->inner );
		else
			bu_log( "%s %d %d (not in a comp group)\n" , ptr->name , ptr->region_id , ptr->inner );
		ptr = ptr->rright;
	}

	bu_log( "\tAlphabetical list of names:\n" );
	ptr = name_root;
	while( 1 )
	{
		while( ptr )
		{
			PUSH( ptr );
			ptr = ptr->nleft;
		}
		POP( name_tree , ptr );
		if( !ptr )
			break;

		bu_log( "%s %d %d\n" , ptr->name, ptr->region_id , ptr->inner );
		ptr = ptr->nright;
	}
}

struct name_tree *
Search_names(struct name_tree *root, char *name, int *found)
{
	struct name_tree *ptr;

	*found = 0;

	ptr = root;
	if( !ptr )
		return( (struct name_tree *)NULL );

	while( 1 )
	{
		int diff;

		diff = strcmp( name , ptr->name );
		if( diff == 0 )
		{
			*found = 1;
			return( ptr );
		}
		else if( diff > 0 )
		{
			if( ptr->nright )
				ptr = ptr->nright;
			else
				return( ptr );
		}
		else if( diff < 0 )
		{
			if( ptr->nleft )
				ptr = ptr->nleft;
			else
				return( ptr );
		}
	}
}

struct name_tree *
Search_ident(struct name_tree *root, int reg_id, int *found)
{
	struct name_tree *ptr;

	*found = 0;

	ptr = root;
	if( !ptr )
		return( (struct name_tree *)NULL );

	while( 1 )
	{
		int diff;

		diff = reg_id -  ptr->region_id;

		if( diff == 0 )
		{
			*found = 1;
			return( ptr );
		}
		else if( diff > 0 )
		{
			if( ptr->rright )
				ptr = ptr->rright;
			else
				return( ptr );
		}
		else if( diff < 0 )
		{
			if( ptr->rleft )
				ptr = ptr->rleft;
			else
				return( ptr );
		}
	}
}

void
Delete_name(struct name_tree **root, char *name)
{
	struct name_tree *ptr,*parent,*ptr2;
	int r_id;
	int found;
	int diff;

	/* first delete from name portion of tree */
	ptr = *root;
	parent = (struct name_tree *)NULL;
	found = 0;

	while( 1 )
	{
		diff = strcmp( name , ptr->name );
		if( diff == 0 )
		{
			found = 1;
			break;
		}
		else if( diff > 0 )
		{
			if( ptr->nright )
			{
				parent = ptr;
				ptr = ptr->nright;
			}
			else
				break;
		}
		else if( diff < 0 )
		{
			if( ptr->nleft )
			{
				parent = ptr;
				ptr = ptr->nleft;
			}
			else
				break;
		}
	}

	if( !found )
		return;

	r_id = ptr->region_id;

	if( parent == (struct name_tree *)NULL )
	{
		if( ptr->nright )
		{
			*root = ptr->nright;
			ptr2 = *root;
			while( ptr2->nleft )
				ptr2 = ptr2->nleft;
			ptr2->nleft = ptr->nleft;

			ptr2 = *root;
			while( ptr2->rleft )
				ptr2 = ptr2->rleft;
			ptr2->rleft = ptr->rleft;
		}
		else if( ptr->nleft )
		{
			*root = ptr->nleft;
			ptr2 = *root;
			while( ptr2->nright )
				ptr2 = ptr2->nright;
			ptr2->nright = ptr->nright;
			ptr2 = *root;
			while( ptr2->rright )
				ptr2 = ptr2->rright;
			ptr2->rright = ptr->rright;
		}
		else
		{
			/* This was the only name in the tree */
			*root = (struct name_tree *)NULL;
		}
		bu_free( (char *)ptr , "Delete_name: ptr" );
		if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
			bu_log( "ERROR: bu_mem_barriercheck failed in Delete_name\n" );
		return;
	}
	else
	{
		if( parent->nright == ptr )
		{
			if( ptr->nleft )
			{
				parent->nright = ptr->nleft;
				ptr2 = ptr->nleft;
				while( ptr2->nright )
					ptr2 = ptr2->nright;
				ptr2->nright = ptr->nright;
			}
			else
				parent->nright = ptr->nright;
		}
		else if( parent->nleft == ptr )
		{
			if( ptr->nright )
			{
				parent->nleft = ptr->nright;
				ptr2 = ptr->nright;
				while( ptr2->nleft )
					ptr2 = ptr2->nleft;
				ptr2->nleft = ptr->nleft;
			}
			else
				parent->nleft = ptr->nleft;
		}
	}


	/* now delete from ident prtion of tree */
	ptr = *root;
	parent = (struct name_tree *)NULL;
	found = 0;

	while( 1 )
	{
		diff = r_id - ptr->region_id;

		if( diff == 0 )
		{
			found = 1;
			break;
		}
		else if( diff > 0 )
		{
			if( ptr->rright )
			{
				parent = ptr;
				ptr = ptr->rright;
			}
			else
				break;
		}
		else if( diff < 0 )
		{
			if( ptr->rleft )
			{
				parent = ptr;
				ptr = ptr->rleft;
			}
			else
				break;
		}
	}

	if( !found )
	{
		bu_log( "name (%s) deleted from name tree, but not found in ident tree!!\n" , name );
		rt_bomb( "Delete_name\n" );
	}

	if( !parent )
	{
		bu_log( "name (%s) is root of ident tree, but not name tree!!\n" , name );
		rt_bomb( "Delete_name\n" );
	}


	if( parent->rright == ptr )
	{
		if( ptr->rleft )
		{
			parent->rright = ptr->rleft;
			ptr2 = ptr->rleft;
			while( ptr2->rright )
				ptr2 = ptr2->rright;
			ptr2->rright = ptr->rright;
		}
		else
			parent->rright = ptr->rright;
	}
	else if( parent->rleft == ptr )
	{
		if( ptr->rright )
		{
			parent->rleft = ptr->rright;
			ptr2 = ptr->rright;
			while( ptr2->rleft )
				ptr2 = ptr2->rleft;
			ptr2->rleft = ptr->rleft;
		}
		else
			parent->rleft = ptr->rleft;
	}
	bu_free( (char *)ptr , "Delete_name: ptr" );
	if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in Delete_name\n" );
	Check_names();
}

void
Insert_name(struct name_tree **root, char *name, int inner)
{
	struct name_tree *ptr;
	struct name_tree *new_ptr;
	int found;
	int diff;

	ptr = Search_names( *root , name , &found );

	if( found )
	{
		bu_log( "Insert_name: %s already in name tree\n" , name );
		return;
	}

	new_ptr = (struct name_tree *)bu_malloc( sizeof( struct name_tree ) , "Insert_name: new_ptr" );

	new_ptr->name = bu_strdup( name );
	new_ptr->nleft = (struct name_tree *)NULL;
	new_ptr->nright = (struct name_tree *)NULL;
	new_ptr->rleft = (struct name_tree *)NULL;
	new_ptr->rright = (struct name_tree *)NULL;
	new_ptr->region_id = (-region_id);
	new_ptr->in_comp_group = 0;
	new_ptr->inner = inner;
	new_ptr->magic = NAME_TREE_MAGIC;

	if( !*root )
	{
		*root = new_ptr;
		return;
	}

	diff = strcmp( name , ptr->name );
	if( diff > 0 )
	{
		if( ptr->nright )
		{
			bu_log( "Insert_name: ptr->nright not null\n" );
			rt_bomb( "\tCannot insert new node\n" );
		}
		ptr->nright = new_ptr;
	}
	else
	{
		if( ptr->nleft )
		{
			bu_log( "Insert_name: ptr->nleft not null\n" );
			rt_bomb( "\tCannot insert new node\n" );
		}
		ptr->nleft = new_ptr;
	}
	if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in Insert_name\n" );
}

void
Insert_region_name(char *name, int reg_id)
{
	struct name_tree *nptr_model,*rptr_model;
	struct name_tree *new_ptr;
	int foundn,foundr;
	int diff;

	if( debug )
		bu_log( "Insert_region_name( name=%s, reg_id=%d\n" , name, reg_id );

	rptr_model = Search_ident( name_root , reg_id , &foundr );
	nptr_model = Search_names( name_root , name , &foundn );

	if( foundn && foundr )
		return;

	if( foundn != foundr )
	{
		bu_log( "Insert_region_name: name %s ident %d\n\tfound name is %d\n\tfound ident is %d\n",
			name, reg_id, foundn, foundr );
		List_names();
		rt_bomb( "\tCannot insert new node\n" );
	}

	/* Add to tree for entire model */
	new_ptr = (struct name_tree *)bu_malloc( sizeof( struct name_tree ) , "Insert_region_name: new_ptr" );
	new_ptr->rleft = (struct name_tree *)NULL;
	new_ptr->rright = (struct name_tree *)NULL;
	new_ptr->nleft = (struct name_tree *)NULL;
	new_ptr->nright = (struct name_tree *)NULL;
	new_ptr->region_id = reg_id;
	new_ptr->mode = mode;
	new_ptr->inner = -1;
	new_ptr->in_comp_group = 0;
	new_ptr->name = bu_strdup( name );
	new_ptr->magic = NAME_TREE_MAGIC;

	if( !name_root )
		name_root = new_ptr;
	else
	{
		diff = strcmp( name , nptr_model->name );

		if( diff > 0 )
		{
			if( nptr_model->nright )
			{
				bu_log( "Insert_region_name: nptr_model->nright not null\n" );
				rt_bomb( "\tCannot insert new node\n" );
			}
			nptr_model->nright = new_ptr;
		}
		else
		{
			if( nptr_model->nleft )
			{
				bu_log( "Insert_region_name: nptr_model->nleft not null\n" );
				rt_bomb( "\tCannot insert new node\n" );
			}
			nptr_model->nleft = new_ptr;
		}


		diff = reg_id - rptr_model->region_id;

		if( diff > 0 )
		{
			if( rptr_model->rright )
			{
				bu_log( "Insert_region_name: rptr_model->rright not null\n" );
				rt_bomb( "\tCannot insert new node\n" );
			}
			rptr_model->rright = new_ptr;
		}
		else
		{
			if( rptr_model->rleft )
			{
				bu_log( "Insert_region_name: rptr_model->rleft not null\n" );
				rt_bomb( "\tCannot insert new node\n" );
			}
			rptr_model->rleft = new_ptr;
		}
	}
	Check_names();
	if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in Insert_region_name\n" );
}

char *
find_region_name(int g_id, int c_id)
{
	struct name_tree *ptr;
	int reg_id;
	int found;

	reg_id = g_id * 1000 + c_id;

	if( debug )
		bu_log( "find_region_name( g_id=%d, c_id=%d ), reg_id=%d\n" , g_id, c_id, reg_id );

	ptr = Search_ident( name_root , reg_id , &found );

	if( found )
		return( ptr->name );
	else
		return( (char *)NULL );
}

char *
make_unique_name(char *name)
{
	struct bu_vls vls;
	int found;

	/* make a unique name from what we got off the $NAME card */

	(void)Search_names( name_root , name , &found );
	if( !found )
		return( bu_strdup( name ) );

	bu_vls_init( &vls );

	while( found )
	{
		bu_vls_trunc( &vls, 0 );
		bu_vls_printf( &vls, "%s_%d", name, name_count );
		(void)Search_names( name_root , bu_vls_addr( &vls ) , &found );
	}
	if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in make_unique_name\n" );

	return( bu_vls_strgrab( &vls ) );
}

void
add_to_series(char *name, int reg_id)
{
	if( group_id < 0 || group_id > 10 )
	{
		bu_log( "add_to_series: region (%s) not added, illegal group number %d, region_id=$d\n" ,
			name , group_id , reg_id );
		return;
	}

	if( mk_addmember( name , &group_head[group_id].l, NULL ,WMOP_UNION ) == (struct wmember *)NULL )
		bu_log( "add_to_series: mk_addmember failed for region %s\n" , name );
}

void
make_comp_group(void)
{
	struct wmember g_head;
	struct name_tree *ptr;

	if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in make_comp_group\n" );

	BU_LIST_INIT( &g_head.l );

	bu_ptbl_reset( &stack );

	ptr = name_root;
	while( 1 )
	{
		while( ptr )
		{
			PUSH( ptr );
			ptr = ptr->nleft;
		}
		POP( name_tree , ptr );
		if( !ptr )
			break;

		if(ptr->region_id == region_id && !ptr->inner && !ptr->in_comp_group )
		{
			if( mk_addmember( ptr->name , &g_head.l , NULL , WMOP_UNION ) == (struct wmember *)NULL )
			{
				bu_log( "make_comp_group: Could not add %s to group for ident %d\n" , ptr->name , ptr->region_id );
				break;
			}
			ptr->in_comp_group = 1;
		}
		ptr = ptr->nright;
	}

	if( BU_LIST_NON_EMPTY( &g_head.l ) )
	{
		char *name;
		struct bu_vls vls;

		if( !(name=find_region_name( group_id , comp_id )) )
		{
			bu_vls_init( &vls );
			bu_vls_printf( &vls , "comp_%d" , region_id );
			name = make_unique_name( bu_vls_addr( &vls ) );
			bu_vls_free( &vls );
			if( warnings )
				bu_log( "Creating default name (%s) for group %d component %d\n",
						name , group_id , comp_id );
			Insert_name( &name_root , name, 1 );
		}

		mk_lfcomb( fdout , name , &g_head , 0 );
		if( !is_a_hole( region_id ) )
			add_to_series( name , region_id );
		else
			add_to_holes( name, region_id );

		bu_free( (char *)name, "str_dupped name" );
	}
}

void
Add_stragglers_to_groups(void)
{
	struct name_tree *ptr;

	ptr = name_root;

	while( 1 )
	{
		while( ptr )
		{
			PUSH( ptr );
			ptr = ptr->rleft;
		}
		POP( name_tree, ptr );
		if( !ptr )
			break;

		/* visit node */
		CK_TREE_MAGIC( ptr );

		if( !ptr->in_comp_group && ptr->region_id > 0 && !is_a_hole( ptr->region_id ) )
		{
			/* add this component to a series */
			(void)mk_addmember( ptr->name, &group_head[ptr->region_id/1000].l, NULL, WMOP_UNION );
			ptr->in_comp_group = 1;
		}

		ptr = ptr->rright;
	}
}

void
do_groups(void)
{
	int group_no;
	struct wmember head_all;

	if( debug )
		bu_log( "do_groups\n" );

	BU_LIST_INIT( &head_all.l );

	Add_stragglers_to_groups();

	for( group_no=0 ; group_no < 11 ; group_no++ )
	{
		char name[20];

		if( BU_LIST_IS_EMPTY( &group_head[group_no].l ) )
			continue;

		sprintf( name , "%dxxx_series" , group_no );
		mk_lfcomb( fdout , name , &group_head[group_no] , 0 );

		if( mk_addmember( name , &head_all.l , NULL, WMOP_UNION ) == (struct wmember *)NULL )
			bu_log( "do_groups: mk_addmember failed to add %s to group all\n" , name );
	}

	if( BU_LIST_NON_EMPTY( &head_all.l ) )
		mk_lfcomb( fdout , "all" , &head_all , 0 );

	if( BU_LIST_NON_EMPTY( &hole_head.l ) )
		mk_lfcomb( fdout , "holes" , &hole_head , 0 );
}

void
do_name(void)
{
	int i,j;
	int g_id;
	int c_id;
	char comp_name[25];
	char tmp_name[25];

	if( pass )
		return;

	if( debug )
		bu_log( "do_name: %s\n" , line );

	strncpy( field , &line[8] , 8 );
	g_id = atoi( field );

	if( g_id != group_id )
	{
		bu_log( "$NAME card for group %d in section for group %d ignored\n" , g_id , group_id );
		bu_log( "%s\n" , line );
		return;
	}

	strncpy( field , &line[16] , 8 );
	c_id = atoi( field );

	if( c_id != comp_id )
	{
		bu_log( "$NAME card for component %d in section for component %d ignored\n" , c_id , comp_id );
		bu_log( "%s\n" , line );
		return;
	}

	/* skip leading blanks */
	i = 56;
	while( i < 80 && isspace( line[i] ) )
		i++;
	if( i == 80 )
		return;

	strncpy( comp_name , &line[i] , 80 - i );

	/* eliminate trailing blanks */
	i = 80 - i;
	while(  --i >= 0 && isspace( comp_name[i] ) )
		comp_name[i] = '\0';

	/* copy comp_name to tmp_name while replacing white space with "_" */
	i = (-1);
	j = (-1);

	/* copy */
	while( comp_name[++i] != '\0' )
	{
		if( isspace( comp_name[i] ) || comp_name[i] == '/' )
		{
			if( j == (-1) || tmp_name[j] != '_' )
				tmp_name[++j] = '_';
		}
		else
			tmp_name[++j] = comp_name[i];
	}
	tmp_name[++j] = '\0';

	/* reserve this name for group name */
	make_unique_name( tmp_name );
	Insert_region_name( tmp_name , region_id );

	name_count = 0;
	if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in do_name\n" );
}

void
make_region_name(int g_id, int c_id)
{
	int r_id;
	char *tmp_name;
	char *name;

	r_id = g_id * 1000 + c_id;

	if( debug )
		bu_log( "make_region_name( g_id=%d, c_id=%d )\n" , g_id, c_id );

	tmp_name = find_region_name( g_id , c_id );
	if( tmp_name )
		return;

	/* create a new name */
	name = (char *)bu_malloc( 12, "make_region_name" );
	sprintf( name , "comp_%04d.r" , r_id );

	make_unique_name( name );

	Insert_region_name( name , r_id );
}

char *
get_solid_name(char type, int element_id, int c_id, int g_id, int inner)
{
	int reg_id;
	struct bu_vls vls;

	reg_id = g_id * 1000 + c_id;

	bu_vls_init( &vls );
	bu_vls_printf( &vls , "%d.%d.%c%d" , reg_id , element_id , type , inner );

	return( bu_vls_strgrab( &vls ) );
}

char *
make_solid_name(char type, int element_id, int c_id, int g_id, int inner)
{
	char *name;

	name = get_solid_name( type , element_id , c_id , g_id , inner );

	Insert_name( &name_root , name, inner );

	return( name );
}

void
do_grid(void)
{
	int grid_no;
	fastf_t x,y,z;

	if( !pass )	/* not doing geometry yet */
		return;

	if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed at start of do_grid\n" );

	strncpy( field , &line[8] , 8 );
	grid_no = atoi( field );

	if( grid_no < 1 )
	{
		bu_log( "ERROR: grid id number = %d\n" , grid_no );
		rt_bomb( "BAD GRID ID NUMBER\n" );
	}

	strncpy( field , &line[24] , 8 );
	x = atof( field );

	strncpy( field , &line[32] , 8 );
	y = atof( field );

	strncpy( field , &line[40] , 8 );
	z = atof( field );

	while( grid_no > grid_size - 1 )
	{
		grid_size += GRID_BLOCK;
		grid_pts = (point_t *)bu_realloc( (char *)grid_pts , grid_size * sizeof( point_t ) , "fast4-g: grid_pts" );
	}

	VSET( grid_pts[grid_no] , x*25.4 , y*25.4 , z*25.4 );

	if( grid_no > max_grid_no )
		max_grid_no = grid_no;
	if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed at end of do_grid\n" );
}

void
do_sphere(void)
{
	int element_id;
	int center_pt;
	fastf_t thick;
	fastf_t radius;
	fastf_t inner_radius;
	char *name;
	struct wmember sphere_group;

	if( !pass )
	{
		make_region_name( group_id , comp_id );
		return;
	}

	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );

	strncpy( field , &line[24] , 8 );
	center_pt = atoi( field );

	strncpy( field , &line[56] , 8 );
	thick = atof( field ) * 25.4;

	strncpy( field , &line[64] , 8 );
	radius = atof( field ) * 25.4;
	if( radius <= 0.0 )
	{
		bu_log( "do_sphere: illegal radius (%f), skipping sphere\n" , radius );
		bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
		return;
	}

	if( center_pt < 1 || center_pt > max_grid_no )
	{
		bu_log( "do_sphere: illegal grid number for center point %d, skipping sphere\n" , center_pt );
		bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
		return;
	}

	BU_LIST_INIT( &sphere_group.l );

	if( mode == VOLUME_MODE )
	{
		name = make_solid_name( CSPHERE , element_id , comp_id , group_id , 0 );
		mk_sph( fdout , name , grid_pts[center_pt] , radius );
		bu_free( name, "solid_name" );
	}
	else if( mode == PLATE_MODE )
	{
		name = make_solid_name( CSPHERE , element_id , comp_id , group_id , 1 );
		mk_sph( fdout , name , grid_pts[center_pt] , radius );

		BU_LIST_INIT( &sphere_group.l );

		if( mk_addmember( name ,  &sphere_group.l , NULL, WMOP_UNION ) == (struct wmember *)NULL )
		{
			bu_log( "do_sphere: Error in adding %s to sphere group\n" , name );
			rt_bomb( "do_sphere" );
		}
		bu_free( name, "solid_name" );

		inner_radius = radius - thick;
		if( thick > 0.0 && inner_radius <= 0.0 )
		{
			bu_log( "do_sphere: illegal thickness (%f), skipping inner sphere\n" , thick );
			bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
			return;
		}

		name = make_solid_name( CSPHERE , element_id , comp_id , group_id , 2 );
		mk_sph( fdout , name , grid_pts[center_pt] , inner_radius );

		if( mk_addmember( name , &sphere_group.l , NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
		{
			bu_log( "do_sphere: Error in subtracting %s from sphere region\n" , name );
			rt_bomb( "do_sphere" );
		}
		bu_free( name, "solid_name" );

		name = make_solid_name( CSPHERE , element_id , comp_id , group_id , 0 );
		mk_comb( fdout, name, &sphere_group.l, 0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 1, 1 );
		bu_free( name, "solid_name" );
	}
}

void
do_vehicle(void)
{
	if( pass )
		return;

	strncpy( vehicle , &line[8] , 16 );
	mk_id_units( fdout , vehicle , "in" );
}

void
do_cline(void)
{
	int element_id;
	int pt1,pt2;
	fastf_t thick;
	fastf_t radius;
	vect_t height;
	char *name;

	if( debug )
		bu_log( "do_cline: %s\n" , line );

	if( !pass )
	{
		make_region_name( group_id , comp_id );
		return;
	}

	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );

	strncpy( field , &line[24] , 8 );
	pt1 = atoi( field );
	if( pass && (pt1 < 1 || pt1 > max_grid_no) )
	{
		bu_log( "Illegal grid point (%d) in CLINE, skipping\n", pt1 );
		bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
		return;
	}

	strncpy( field , &line[32] , 8 );
	pt2 = atoi( field );
	if( pass && (pt2 < 1 || pt2 > max_grid_no) )
	{
		bu_log( "Illegal grid point in CLINE (%d), skipping\n", pt2 );
		bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
		return;
	}

	if( pt1 == pt2 )
	{
		bu_log( "Ilegal grid points in CLINE ( %d and %d ), skipping\n", pt1 , pt2 );
		bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
		return;
	}

	strncpy( field , &line[56] , 8 );
	thick = atof( field ) * 25.4;

	strncpy( field , &line[64] , 8 );
	radius = atof( field ) * 25.4;

	VSUB2( height , grid_pts[pt2] , grid_pts[pt1] );

	name = make_solid_name( CLINE , element_id , comp_id , group_id , 0 );
	mk_cline( fdout , name , grid_pts[pt1] , height , radius, thick );
	bu_free( name, "solid_name" );
}

void
do_ccone1(void)
{
	int element_id;
	int pt1,pt2;
	fastf_t thick;
	int c1,c2;
	int end1,end2;
	vect_t height;
	fastf_t r1,r2;
	char *outer_name;
	char *inner_name;
	char *name;
	struct wmember r_head;

	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );

	if( !pass )
	{
		make_region_name( group_id , comp_id );
		if( !getline() )
		{
			bu_log( "Unexpected EOF while reading continuation card for CCONE1\n" );
			bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
				group_id, comp_id, element_id );
			rt_bomb( "CCONE1\n" );
		}
		return;
	}

	strncpy( field , &line[24] , 8 );
	pt1 = atoi( field );

	strncpy( field , &line[32] , 8 );
	pt2 = atoi( field );

	strncpy( field , &line[56] , 8 );
	thick = atof( field ) * 25.4;

	strncpy( field , &line[64] , 8 );
	r1 = atof( field ) * 25.4;

	strncpy( field , &line[72] , 8 );
	c1 = atoi( field );

	if( !getline() )
	{
		bu_log( "Unexpected EOF while reading continuation card for CCONE1\n" );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d, c1 = %d\n",
			group_id, comp_id, element_id , c1 );
		rt_bomb( "CCONE1\n" );
	}

	strncpy( field , line , 8 );
	c2 = atoi( field );

	if( c1 != c2 )
	{
		bu_log( "WARNING: CCONE1 continuation flags disagree, %d vs %d\n" , c1 , c2 );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			group_id, comp_id, element_id );
	}

	strncpy( field , &line[8] , 8 );
	r2 = atof( field ) * 25.4;

	strncpy( field , &line[16] , 8 );
	end1 = atoi( field );

	strncpy( field , &line[24] , 8 );
	end2 = atoi( field );

	if( r1 < 0.0 || r2 < 0.0 )
	{
		bu_log( "ERROR: CCONE1 has illegal radii, %f and %f\n" , r1/25.4 , r2/25.4 );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			group_id, comp_id, element_id );
		bu_log( "\tCCONE1 solid ignored\n" );
		return;
	}

	if( mode == PLATE_MODE )
	{
		if( thick <= 0.0 )
		{
			bu_log( "ERROR: Plate mode CCONE1 has illegal thickness (%f)\n" , thick/25.4 );
			bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
				group_id, comp_id, element_id );
			bu_log( "\tCCONE1 solid ignored\n" );
			return;
		}

		if( r1-thick < min_radius && r2-thick < min_radius )
		{
			bu_log( "ERROR: Plate mode CCONE1 has too large thickness (%f)\n" , thick/25.4 );
			bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
				group_id, comp_id, element_id );
			bu_log( "\tCCONE1 solid ignored\n" );
			return;
		}
	}

	if( pt1 < 1 || pt1 > max_grid_no || pt2 < 1 || pt2 > max_grid_no || pt1 == pt2 )
	{
		bu_log( "ERROR: CCONE1 has illegal grid points ( %d and %d)\n" , pt1 , pt2 );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			group_id, comp_id, element_id );
		bu_log( "\tCCONE1 solid ignored\n" );
		return;
	}

	/* BRL_CAD doesn't allow zero radius, so use a very small radius */
	if( r1 < min_radius )
		r1 = min_radius;
	if( r2 < min_radius )
		r2 = min_radius;

	VSUB2( height , grid_pts[pt2] , grid_pts[pt1] );

	if( mode == VOLUME_MODE )
	{
		outer_name = make_solid_name( CCONE1 , element_id , comp_id , group_id , 0 );
		mk_trc_h( fdout , outer_name , grid_pts[pt1] , height , r1 , r2 );
		bu_free( outer_name, "solid_name" );
	}
	else if( mode == PLATE_MODE )
	{
		/* make inside TGC */

		point_t base;
		point_t top;
		vect_t inner_height;
		fastf_t inner_r1,inner_r2;
		fastf_t length;
		fastf_t sin_ang;
		fastf_t slant_len;
		fastf_t r1a,r2a;
		vect_t height_dir;

		/* make outside TGC */
		outer_name = make_solid_name( CCONE1 , element_id , comp_id , group_id , 1 );
		mk_trc_h( fdout , outer_name , grid_pts[pt1] , height , r1 , r2 );

		BU_LIST_INIT( &r_head.l );
		if( mk_addmember( outer_name , &r_head.l , NULL, WMOP_UNION ) == (struct wmember *)NULL )
			rt_bomb( "CCONE1: mk_addmember failed\n" );
		bu_free( outer_name, "solid_name" );

		length = MAGNITUDE( height );
		VSCALE( height_dir , height , 1.0/length );
		slant_len = sqrt( length*length + (r2 - r1)*(r2 - r1) );

		sin_ang = length/slant_len;

		if( end1 == END_OPEN )
		{
			r1a = r1;
			inner_r1 = r1 - thick/sin_ang;
			VMOVE( base , grid_pts[pt1] );
		}
		else
		{
			r1a = r1 + (r2 - r1)*thick/length;
			inner_r1 = r1a - thick/sin_ang;
			VJOIN1( base , grid_pts[pt1] , thick , height_dir );
		}

		if( inner_r1 < 0.0 )
		{
			fastf_t dist_to_new_base;

			dist_to_new_base = inner_r1 * length/(r1 - r2 );
			inner_r1 = min_radius;
			VJOIN1( base , base , dist_to_new_base , height_dir );
		}
		else if( inner_r1 < min_radius )
			inner_r1 = min_radius;

		if( end2 == END_OPEN )
		{
			r2a = r2;
			inner_r2 = r2 - thick/sin_ang;
			VMOVE( top , grid_pts[pt2] );
		}
		else
		{
			r2a = r2 + (r1 - r2)*thick/length;
			inner_r2 = r2a - thick/sin_ang;
			VJOIN1( top , grid_pts[pt2] , -thick , height_dir );
		}

		if( inner_r2 < 0.0 )
		{
			fastf_t dist_to_new_top;

			dist_to_new_top = inner_r2 * length/(r2 - r1 );
			inner_r2 = min_radius;
			VJOIN1( top , top , -dist_to_new_top , height_dir );
		}
		else if( inner_r2 < min_radius )
			inner_r2 = min_radius;

		VSUB2( inner_height , top , base );
		if( VDOT( inner_height , height ) <= 0.0 )
		{
			bu_log( "ERROR: CCONE1 height (%f) too small for thickness (%f)\n" , length/25.4 , thick/25.4 );
			bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
				group_id, comp_id, element_id );
			bu_log( "\tCCONE1 inner solid ignored\n" );
		}
		else
		{
			/* make inner tgc */

			inner_name = make_solid_name( CCONE1 , element_id , comp_id , group_id , 2 );
			mk_trc_h( fdout , inner_name , base , inner_height , inner_r1 , inner_r2 );

			if( mk_addmember( inner_name , &r_head.l , NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
				rt_bomb( "CCONE1: mk_addmember failed\n" );
			bu_free( inner_name, "solid_name" );
		}

		name = make_solid_name( CCONE1 , element_id , comp_id , group_id , 0 );
		mk_comb( fdout, name, &r_head.l, 0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 1, 1 );
		bu_free( name, "solid_name" );
	}

}

void
do_ccone2(void)
{
	int element_id;
	int pt1,pt2;
	int c1,c2;
	fastf_t ro1,ro2,ri1,ri2;
	vect_t height;
	char *name;
	struct wmember r_head;

	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );

	if( !pass )
	{
		make_region_name( group_id , comp_id );
		if( !getline() )
		{
			bu_log( "Unexpected EOF while reading continuation card for CCONE2\n" );
			bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
				group_id, comp_id, element_id );
			rt_bomb( "CCONE2\n" );
		}
		return;
	}

	strncpy( field , &line[24] , 8 );
	pt1 = atoi( field );

	strncpy( field , &line[32] , 8 );
	pt2 = atoi( field );

	strncpy( field , &line[64] , 8 );
	ro1 = atof( field ) * 25.4;

	strncpy( field , &line[72] , 8 );
	c1 = atoi( field );

	if( !getline() )
	{
		bu_log( "Unexpected EOF while reading continuation card for CCONE2\n" );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d, c1 = %d\n",
			group_id, comp_id, element_id , c1 );
		rt_bomb( "CCONE2\n" );
	}

	strncpy( field , line , 8 );
	c2 = atoi( field );

	if( c1 != c2 )
	{
		bu_log( "WARNING: CCONE2 continuation flags disagree, %d vs %d\n" , c1 , c2 );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			group_id, comp_id, element_id );
	}

	strncpy( field , &line[8] , 8 );
	ro2 = atof( field ) * 25.4;

	strncpy( field , &line[16] , 8 );
	ri1 = atof( field ) * 25.4;

	strncpy( field , &line[24] , 8 );
	ri2 = atof( field ) * 25.4;

	if( pt1 == pt2 )
	{
		bu_log( "ERROR: CCONE2 has same endpoints %d and %d\n", pt1, pt2 );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			group_id, comp_id, element_id );
		return;
	}

	if( ro1 < 0.0 || ro2 < 0.0 || ri1 < 0.0 || ri2 < 0.0 )
	{
		bu_log( "ERROR: CCONE2 has illegal radii %f %f %f %f\n" , ro1, ro2, ri1, ri2 );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			group_id, comp_id, element_id );
		return;
	}

	if( ro1 < min_radius )
		ro1 = min_radius;

	if( ro2 < min_radius )
		ro2 = min_radius;

	BU_LIST_INIT( &r_head.l );

	VSUB2( height , grid_pts[pt2] , grid_pts[pt1] );

	if( ri1 <= 0.0 && ri2 <= 0.0 )
	{
		name = make_solid_name( CCONE2 , element_id , comp_id , group_id , 0 );
		mk_trc_h( fdout , name , grid_pts[pt1] , height , ro1 , ro2 );
		bu_free( name, "solid_name" );
	}
	else
	{
		name = make_solid_name( CCONE2 , element_id , comp_id , group_id , 1 );
		mk_trc_h( fdout , name , grid_pts[pt1] , height , ro1 , ro2 );

		if( mk_addmember( name , &r_head.l , NULL, WMOP_UNION ) == (struct wmember *)NULL )
			rt_bomb( "mk_addmember failed!\n" );
		bu_free( name, "solid_name" );

		if( ri1 < min_radius )
			ri1 = min_radius;

		if( ri2 < min_radius )
			ri2 = min_radius;

		name = make_solid_name( CCONE2 , element_id , comp_id , group_id , 2 );
		mk_trc_h( fdout , name , grid_pts[pt1] , height , ri1 , ri2 );

		if( mk_addmember( name , &r_head.l , NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
			rt_bomb( "mk_addmember failed!\n" );
		bu_free( name, "solid_name" );

		name = make_solid_name( CCONE2 , element_id , comp_id , group_id , 0 );
		mk_comb( fdout, name, &r_head.l, 0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 1, 1 );
		bu_free( name, "solid_name" );
	}
}

void
do_ccone3(void)
{
	int element_id;
	int pt1, pt2, pt3, pt4, i;
	char *name;
	fastf_t ro[4], ri[4], len03, len01, len12, len23;
	vect_t diff, diff2, diff3, diff4;
	struct wmember r_head;

	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );

	if( !pass )
	{
		make_region_name( group_id , comp_id );
		if( !getline() )
		{
			bu_log( "Unexpected EOF while reading continuation card for CCONE3\n" );
			bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
				group_id, comp_id, element_id );
			rt_bomb( "CCONE3\n" );
		}
		return;
	}

	strncpy( field , &line[24] , 8 );
	pt1 = atoi( field );

	strncpy( field , &line[32] , 8 );
	pt2 = atoi( field );

	strncpy( field , &line[40] , 8 );
	pt3 = atoi( field );

	strncpy( field , &line[48] , 8 );
	pt4 = atoi( field );

	strncpy( field, &line[72], 8 );

	if( !getline() )
	{
		bu_log( "Unexpected EOF while reading continuation card for CCONE3\n" );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d, c1 = %8.8s\n",
			group_id, comp_id, element_id , field );
		rt_bomb( "CCONE3\n" );
	}

	if( strncmp( field, line, 8 ) )
	{
		bu_log( "WARNING: CCONE3 continuation flags disagree, %8.8s vs %8.8s\n" , field , line );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			group_id, comp_id, element_id );
	}

	for( i=0 ; i<4 ; i++ )
	{
		strncpy( field, &line[8*(i+1)], 8 );
		ro[i] = atof( field ) * 25.4;
		if( ro[i] < 0.0 )
		{
			bu_log( "ERROR: CCONE3 has illegal radius %f\n", ro[i] );
			bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
				group_id, comp_id, element_id );
			return;
		}
		if( !strcmp( field, "        " ) )
			ro[i] = -1.0;
	}

	for( i=0 ; i<4 ; i++ )
	{
		strncpy( field, &line[32 + 8*(i+1)], 8 );
		ri[i] = atof( field ) * 25.4;
		if( ri[i] < 0.0 )
		{
			bu_log( "ERROR: CCONE3 has illegal radius %f\n", ri[i] );
			bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
				group_id, comp_id, element_id );
			return;
		}
		if( !strcmp( field, "        " ) )
			ri[i] = -1.0;
	}

	VSUB2( diff4, grid_pts[pt4], grid_pts[pt1] );
	VSUB2( diff3, grid_pts[pt3], grid_pts[pt1] );
	VSUB2( diff2, grid_pts[pt2], grid_pts[pt1] );

	len03 = MAGNITUDE( diff4 );
	len01 = MAGNITUDE( diff2 );
	len12 = MAGNITUDE( diff3 ) - len01;
	len23 = len03 - len01 - len12;

	for( i=0 ; i<4 ; i+=3 )
	{
		if( ro[i] ==-1.0 )
		{
			if( ri[i] == -1.0 )
			{
				bu_log( "ERROR: both inner and outer radii at g%d of a CCONE3 are undefined\n", i+1 );
				bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
					group_id, comp_id, element_id );
				return;
			}
			else
				ro[i] = ri[i];
			
		}
		else if( ri[i] == -1.0 )
			ri[i] = ro[i];
	}

	if( ro[1] == -1.0 )
	{
		if( ro[2] != -1.0 )
			ro[1] = ro[0] + (ro[2] - ro[0]) * len01 / (len01 + len12);
		else
			ro[1] = ro[0] + (ro[3] - ro[0]) * len01 / len03;
	}
	if( ro[2] == -1.0 )
	{
		if( ro[1] != -1.0 )
			ro[2] = ro[1] + (ro[3] - ro[1]) * len12 / (len12 + len23);
		else
			ro[2] = ro[0] + (ro[3] - ro[0]) * (len01 + len12) / len03;
	}
	if( ri[1] == -1.0 )
	{
		if( ri[2] != -1.0 )
			ri[1] = ri[0] + (ri[2] - ri[0]) * len01 / (len01 + len12);
		else
			ri[1] = ri[0] + (ri[3] - ri[0]) * len01 / len03;
	}
	if( ri[2] == -1.0 )
	{
		if( ri[1] != -1.0 )
			ri[2] = ri[1] + (ri[3] - ri[1]) * len12 / (len12 + len23);
		else
			ri[2] = ri[0] + (ri[3] - ri[0]) * (len01 + len12) / len03;
	}

	for( i=0 ; i<4 ; i++ )
	{
		if( ro[i] < min_radius )
			ro[i] = min_radius;
		if( ri[i] < min_radius )
			ri[i] = min_radius;
	}

	BU_LIST_INIT( &r_head.l );

	if( pt1 != pt2 )
	{
		VSUB2( diff, grid_pts[pt2], grid_pts[pt1] );

		/* make first cone */
		if( ro[0] != min_radius || ro[1] != min_radius )
		{
			name = make_solid_name( CCONE3, element_id, comp_id, group_id, 1 );
			mk_trc_h( fdout, name, grid_pts[pt1], diff, ro[0], ro[1] );
			if( mk_addmember( name , &r_head.l , NULL, WMOP_UNION ) == (struct wmember *)NULL )
				bu_bomb( "mk_addmember failed!\n" );
			bu_free( name, "solid_name" );

			/* and the inner cone */
			if( ri[0] != min_radius || ri[1] != min_radius )
			{
				name = make_solid_name( CCONE3, element_id, comp_id, group_id, 11 );
				mk_trc_h( fdout, name, grid_pts[pt1], diff, ri[0], ri[1] );
				if( mk_addmember( name , &r_head.l , NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
					bu_bomb( "mk_addmember failed!\n" );
				bu_free( name, "solid_name" );
			}
		}
	}

	if( pt2 != pt3 )
	{
		VSUB2( diff, grid_pts[pt3], grid_pts[pt2] );

		/* make second cone */
		if( ro[1] != min_radius || ro[2] != min_radius )
		{
			name = make_solid_name( CCONE3, element_id, comp_id, group_id, 2 );
			mk_trc_h( fdout, name, grid_pts[pt2], diff, ro[1], ro[2] );
			if( mk_addmember( name , &r_head.l , NULL, WMOP_UNION ) == (struct wmember *)NULL )
				bu_bomb( "mk_addmember failed!\n" );
			bu_free( name, "solid_name" );

			/* and the inner cone */
			if( ri[1] != min_radius || ri[2] != min_radius )
			{
				name = make_solid_name( CCONE3, element_id, comp_id, group_id, 22 );
				mk_trc_h( fdout, name, grid_pts[pt2], diff, ri[1], ri[2] );
				if( mk_addmember( name , &r_head.l , NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
					bu_bomb( "mk_addmember failed!\n" );
				bu_free( name, "solid_name" );
			}
		}
	}

	if( pt3 != pt4 )
	{
		VSUB2( diff, grid_pts[pt4], grid_pts[pt3] );

		/* make third cone */
		if( ro[2] != min_radius || ro[3] != min_radius )
		{
			name = make_solid_name( CCONE3, element_id, comp_id, group_id, 3 );
			mk_trc_h( fdout, name, grid_pts[pt3], diff, ro[2], ro[3] );
			if( mk_addmember( name , &r_head.l , NULL, WMOP_UNION ) == (struct wmember *)NULL )
				bu_bomb( "mk_addmember failed!\n" );
			bu_free( name, "solid_name" );

			/* and the inner cone */
			if( ri[2] != min_radius || ri[3] != min_radius )
			{
				name = make_solid_name( CCONE3, element_id, comp_id, group_id, 33 );
				mk_trc_h( fdout, name, grid_pts[pt3], diff, ri[2], ri[3] );
				if( mk_addmember( name , &r_head.l , NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
					bu_bomb( "mk_addmember failed!\n" );
				bu_free( name, "solid_name" );
			}
		}
	}

	name = make_solid_name( CCONE3 , element_id , comp_id , group_id , 0 );
	mk_comb( fdout, name, &r_head.l, 0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 1, 1 );
	bu_free( name, "solid_name" );
}

void
Add_holes( int type, int gr, int comp, struct hole_list *ptr )
{
	struct holes *hole_ptr, *prev;
	struct hole_list *hptr;

	if( debug )
	{
		bu_log( "Adding holes for group %d, component %d:\n", gr, comp );
		hptr = ptr;
		while( hptr )
		{
			bu_log( "\t%d %d\n", hptr->group, hptr->component );
			hptr = hptr->next;
		}
	}

	if( do_skips )
	{
		if( !skip_region(gr*1000 + comp) )
		{
			/* add holes for this region to the list of regions to process */
			hptr = ptr;
			if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
				bu_log( "ERROR: bu_mem_barriercheck failed in Add_hole\n" );
			while( hptr )
			{
				if( do_skips == region_list_len )
				{
					region_list_len += REGION_LIST_BLOCK;
					region_list = (int *)bu_realloc( (char *)region_list, region_list_len*sizeof( int ), "region_list" );
					if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
						bu_log( "ERROR: bu_mem_barriercheck failed in Add_hole (after realloc)\n" );
				}
				region_list[do_skips++] = 1000*hptr->group + hptr->component;
				if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
					bu_log( "ERROR: bu_mem_barriercheck failed in Add_hole (after adding %d\n)\n", 1000*hptr->group + hptr->component );
				hptr = hptr->next;
			}
		}
	}

	if( !hole_root )
	{
		hole_root = (struct holes *)bu_malloc( sizeof( struct holes ) , "Add_holes: hole_root" );
		hole_root->group = gr;
		hole_root->component = comp;
		hole_root->type = type;
		hole_root->holes = ptr;
		hole_root->next = (struct holes *)NULL;
		return;
	}

	hole_ptr = hole_root;
	prev = hole_root;
	while( hole_ptr )
	{
		if( hole_ptr->group == gr &&
			hole_ptr->component == comp &&
			hole_ptr->type == type )
				break;
		prev = hole_ptr;
		hole_ptr = hole_ptr->next;
	}

	if( hole_ptr && hole_ptr->group == gr && hole_ptr->component == comp && hole_ptr->type == type )
	{
		struct hole_list *list;

		if( !hole_ptr->holes )
			hole_ptr->holes = ptr;
		else
		{
			list = hole_ptr->holes;
			while( list->next )
				list = list->next;
			list->next = ptr;
		}
	}
	else
	{
		prev->next = (struct holes *)bu_malloc( sizeof( struct holes ) , "Add_holes: hole_ptr->next" );
		hole_ptr = prev->next;
		hole_ptr->group = gr;
		hole_ptr->component = comp;
		hole_ptr->type = type;
		hole_ptr->holes = ptr;
		hole_ptr->next = (struct holes *)NULL;
	}
}

void
do_hole_wall(int type)
{
	struct hole_list *list_ptr;
	struct hole_list *list_start;
	int group, comp;
	int igrp, icmp;
	int s_len;
	int col;

	if( debug )
		bu_log( "do_hole_wall: %s\n" , line );

	if( pass )
		return;

	if( type != HOLE && type != WALL )
	{
		bu_log( "do_hole_wall: unrecognized type (%d)\n", type );
		bu_bomb( "do_hole_wall: unrecognized type\n" );
	}

	/* eliminate trailing blanks */
	s_len = strlen( line );
	while( isspace(line[--s_len] ) )
		line[s_len] = '\0';

	s_len = strlen( line );
	if( s_len > 80 )
		s_len = 80;

	strncpy( field , &line[8] , 8 );
	group = atoi( field );

	strncpy( field , &line[16] , 8 );
	comp = atoi( field );

	list_start = (struct hole_list *)NULL;
	list_ptr = (struct hole_list *)NULL;
	col = 24;

	while( col < s_len )
	{
		strncpy( field , &line[col] , 8 );
		igrp = atoi( field );

		col += 8;
		if( col >= s_len )
			break;

		strncpy( field , &line[col] , 8 );
		icmp = atoi( field );

		if( igrp >= 0 && icmp > 0 )
		{
			if( igrp == group && comp == icmp )
				bu_log( "Hole or wall card references itself (ignoring): (%s)\n", line );
			else
			{
				if( list_ptr )
				{
					list_ptr->next = (struct hole_list *)bu_malloc( sizeof( struct hole_list ) , "do_hole_wall: list_ptr" );
					list_ptr = list_ptr->next;
				}
				else
				{
					list_ptr = (struct hole_list *)bu_malloc( sizeof( struct hole_list ) , "do_hole_wall: list_ptr" );
					list_start = list_ptr;
				}
			
				list_ptr->group = igrp;
				list_ptr->component = icmp;
				list_ptr->next = (struct hole_list *)NULL;
			}
		}

		col += 8;
	}

	Add_holes( type, group , comp , list_start );
}

int
getline(void)
{
	int len;

	bzero( (void *)line , LINELEN );

	if( fgets( line , LINELEN , fdin ) == (char *)NULL )
		return( 0 );

	len = strlen( line );
	if( line[len-1] != '\n' ) {
		/* long line skip over remainder of line */
		int c=1;

		while( c != '\n' && c != EOF )
			c = getc( fdin );
		if( c == EOF )
			return( 0 );
	} else
		line[len-1] = '\0';

	return( 1 );
}

void
Add_bot_face(int pt1, int pt2, int pt3, fastf_t thick, int pos)
{

	if( pt1 == pt2 || pt2 == pt3 || pt1 == pt3 )
	{
		bu_log( "Add_bot_face: ignoring degenerate triangle in group %d component %d\n", group_id, comp_id );
		return;
	}

	if( pos == 0 )	/* use default */
		pos = POS_FRONT;

	if( mode == PLATE_MODE )
	{
		if( pos != POS_CENTER && pos != POS_FRONT )
		{
			bu_log( "Add_bot_face: illegal postion parameter (%d), must be one or two (ignoring face for group %d component %d)\n" , pos, group_id, comp_id );
			return;
		}
	}

	if( face_count >= face_size )
	{
		face_size += GRID_BLOCK;
		if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
			bu_log( "memory corrupted before realloc of faces, thickness, and facemode\n" );
		faces = (int *)bu_realloc( (void *)faces,  face_size*3*sizeof( int ), "faces" );
		thickness = (fastf_t *)bu_realloc( (void *)thickness, face_size*sizeof( fastf_t ), "thickness" );
		facemode = (char *)bu_realloc( (void *)facemode, face_size*sizeof( char ), "facemode" );
		if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
			bu_log( "memory corrupted after realloc of faces, thickness, and facemode\n" );
	}

	faces[face_count*3] = pt1;
	faces[face_count*3+1] = pt2;
	faces[face_count*3+2] = pt3;

	if( mode == PLATE_MODE )
	{
		thickness[face_count] = thick;
		facemode[face_count] = pos;
	}
	else
	{
		thickness[face_count] = 0,0;
		facemode[face_count] = 0;
	}

	face_count++;

	if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
		bu_log( "memory corrupted at end of Add_bot_face()\n" );
}

void
do_tri(void)
{
	int element_id;
	int pt1,pt2,pt3;
	fastf_t thick;
	int pos;

	if( debug )
		bu_log( "do_tri: %s\n" , line );

	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );

	if( !bot )
		bot = element_id;

	if( !pass )
		return;

	if( faces == NULL )
	{
		if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
			bu_log( "memory corrupted before malloc of faces\n" );
		faces = (int *)bu_malloc( GRID_BLOCK*3*sizeof( int ), "faces" );
		thickness = (fastf_t *)bu_malloc( GRID_BLOCK*sizeof( fastf_t ), "thickness" );
		facemode = (char *)bu_malloc( GRID_BLOCK*sizeof( char ), "facemode" );
		face_size = GRID_BLOCK;
		face_count = 0;
		if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
			bu_log( "memory corrupted after malloc of faces , thickness, and facemode\n" );
	}

	strncpy( field , &line[24] , 8 );
	pt1 = atoi( field );

	strncpy( field , &line[32] , 8 );
	pt2 = atoi( field );

	strncpy( field , &line[40] , 8 );
	pt3 = atoi( field );

	thick = 0.0;
	pos = 0;

	if( mode == PLATE_MODE )
	{
		strncpy( field , &line[56] , 8 );
		thick = atof( field ) * 25.4;

		strncpy( field , &line[64] , 8 );
		pos = atoi( field );
		if( pos == 0 )
			pos = POS_FRONT;

		if( debug )
			bu_log( "\tplate mode: thickness = %f\n" , thick );

	}

	if( do_plot )
		plot_tri( pt1, pt2, pt3 );

	if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
		bu_log( "memory corrupted before call to Add_bot_face()\n" );

	Add_bot_face( pt1, pt2, pt3, thick, pos );

	if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
		bu_log( "memory corrupted after call to Add_bot_face()\n" );
}

void
do_quad(void)
{
	int element_id;
	int pt1,pt2,pt3,pt4;
	fastf_t thick = 0.0;
	int pos = 0;

	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );

	if( debug )
		bu_log( "do_quad: %s\n" , line );

	if( !bot )
		bot = element_id;

	if( !pass )
		return;

	if( faces == NULL )
	{
		faces = (int *)bu_malloc( GRID_BLOCK*3*sizeof( int ), "faces" );
		thickness = (fastf_t *)bu_malloc( GRID_BLOCK*sizeof( fastf_t ), "thickness" );
		facemode = (char *)bu_malloc( GRID_BLOCK*sizeof( char ), "facemode" );
		face_size = GRID_BLOCK;
		face_count = 0;
	}

	strncpy( field , &line[24] , 8 );
	pt1 = atoi( field );

	strncpy( field , &line[32] , 8 );
	pt2 = atoi( field );

	strncpy( field , &line[40] , 8 );
	pt3 = atoi( field );

	strncpy( field , &line[48] , 8 );
	pt4 = atoi( field );

	if( mode == PLATE_MODE )
	{
		strncpy( field , &line[56] , 8 );
		thick = atof( field ) * 25.4;

		strncpy( field , &line[64] , 8 );
		pos = atoi( field );

		if( pos == 0 )	/* use default */
			pos = POS_FRONT;

		if( pos != POS_CENTER && pos != POS_FRONT )
		{
			bu_log( "do_quad: illegal postion parameter (%d), must be one or two\n" , pos );
			bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
			return;
		}
	}

	Add_bot_face( pt1, pt2, pt3, thick, pos );
	Add_bot_face( pt1, pt3, pt4, thick, pos );
}

int
skip_region( int id )
{
	int i;

	if( !do_skips )
		return( 0 );

	for( i=0 ; i<do_skips ; i++ )
	{
		if( id == region_list[i] )
			return( 0 );
	}

	return( 1 );
}

void
make_bot_object(void)
{
	int i;
	int max_pt=0, min_pt=999999;
	int num_vertices;
	struct bu_bitv *bv=NULL;
	int bot_mode;
	char *name;
	int element_id=bot;
	int count;
	struct rt_bot_internal bot_ip;

	if( !pass )
	{
		make_region_name( group_id , comp_id );
		return;
	}

	bot_ip.magic = RT_BOT_INTERNAL_MAGIC;
	for( i=0 ; i<face_count ; i++ )
	{
		V_MIN( min_pt, faces[i*3] );
		V_MAX( max_pt, faces[i*3] );
		V_MIN( min_pt, faces[i*3+1] );
		V_MAX( max_pt, faces[i*3+1] );
		V_MIN( min_pt, faces[i*3+2] );
		V_MAX( max_pt, faces[i*3+2] );
	}

	num_vertices = max_pt - min_pt + 1;
	bot_ip.num_vertices = num_vertices;
	bot_ip.vertices = (fastf_t *)bu_calloc( num_vertices*3, sizeof( fastf_t ), "BOT vertices" );
	for( i=0 ; i<num_vertices ; i++ )
		VMOVE( &bot_ip.vertices[i*3], grid_pts[min_pt+i] )

	for( i=0 ; i<face_count*3 ; i++ )
		faces[i] -= min_pt;
	bot_ip.num_faces = face_count;
	bot_ip.faces = bu_calloc( face_count*3, sizeof( int ), "BOT faces" );
	for( i=0 ; i<face_count*3 ; i++ )
		bot_ip.faces[i] = faces[i];

	bot_ip.face_mode = (struct bu_bitv *)NULL;
	bot_ip.thickness = (fastf_t *)NULL;
	if( mode == PLATE_MODE )
	{
		bot_mode = RT_BOT_PLATE;
		bv = bu_bitv_new( face_count );
		bu_bitv_clear( bv );
		for( i=0 ; i<face_count ; i++ )
		{
			if( facemode[i] == POS_FRONT )
				BU_BITSET( bv, i );
		}
		bot_ip.face_mode = bv;
		bot_ip.thickness = (fastf_t *)bu_calloc( face_count, sizeof( fastf_t ), "BOT thickness" );
		for( i=0 ; i<face_count ; i++ )
			bot_ip.thickness[i] = thickness[i];
	}
	else
		bot_mode = RT_BOT_SOLID;

	bot_ip.mode = bot_mode;
	bot_ip.orientation = RT_BOT_UNORIENTED;
	bot_ip.bot_flags = 0;

	count = rt_bot_vertex_fuse( &bot_ip );
	if( count )
		(void)rt_bot_condense( &bot_ip );

	count = rt_bot_face_fuse( &bot_ip );
	if( count )
		bu_log( "WARNING: %d duplicate faces eliminated from group %d component %d\n", count, group_id, comp_id );

	name = make_solid_name( BOT , element_id , comp_id , group_id , 0 );
	mk_bot( fdout, name, bot_mode, RT_BOT_UNORIENTED, 0, bot_ip.num_vertices, bot_ip.num_faces, bot_ip.vertices,
		bot_ip.faces, bot_ip.thickness, bot_ip.face_mode );
	bu_free( name, "solid_name" );

	if( mode == PLATE_MODE )
	{
		bu_free( (char *)bot_ip.thickness, "BOT thickness" );
		bu_free( (char *)bot_ip.face_mode, "BOT face_mode" );
	}
	bu_free( (char *)bot_ip.vertices, "BOT vertices" );
	bu_free( (char *)bot_ip.faces, "BOT faces" );

}

void
skip_section(void)
{
	long section_start;

	/* skip to start of next section */
	section_start = ftell( fdin );
	if( getline() )
	{
		while( line[0] && strncmp( line, "SECTION" , 7 ) &&
				strncmp( line, "HOLE", 4 ) &&
				strncmp( line, "WALL", 4 ) &&
				strncmp( line, "VEHICLE", 7 ) )
		{
			section_start = ftell( fdin );
			if( !getline() )
				break;
		}
	}
	/* seek to start of the section */
	fseek( fdin, section_start, SEEK_SET );
}

/*	cleanup from previous component and start a new one.
 *	This is called with final == 1 when ENDDATA is found
 */
void
do_section(int final)
{
	int found;
	struct name_tree *nm_ptr;

	if( debug )
		bu_log( "do_section(%d): %s\n", final , line );

	if( pass )	/* doing geometry */
	{
		if( region_id && !skip_region( region_id ) )
		{
			comp_count++;

			if( bot )
				make_bot_object();
		}
		if( final && debug ) /* The ENDATA card has been found */
			List_names();
	}
	else if( bot )
	{
		make_region_name( group_id , comp_id );
	}

	if( !final )
	{
		strncpy( field , &line[8] , 8 );
		group_id = atoi( field );

		strncpy( field , &line[16] , 8 );
		comp_id = atoi( field );

		region_id = group_id * 1000 + comp_id;

		if( skip_region( region_id ) ) /* do not process this component */
		{
			skip_section();
			return;
		}

		if( comp_id > 999 )
		{
			bu_log( "Illegal component id number %d, changed to 999\n" , comp_id );
			comp_id = 999;
		}

		strncpy( field , &line[24] , 8 );
		mode = atoi( field );
		if( mode != 1 && mode != 2 )
		{
			bu_log( "Illegal mode (%d) for group %d component %d, using volume mode\n",
				mode, group_id, comp_id );
			mode = 2;
		}

		if( !pass )
		{
			nm_ptr = Search_ident( name_root, region_id, &found );
			if( found && nm_ptr->mode != mode ) {
				bu_log( "ERROR: second SECTION card found with different mode for component (group=%d, component=%d), conversion of this component will be incorrect!!!\n",
					group_id, comp_id );
			}
		}
	}

	bot = 0;
	face_count = 0;
}

void
do_hex1(void)
{
	fastf_t thick=0.0;
	int pos;
	int pts[8];
	int element_id;
	int i;
	int cont1,cont2;

	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );

	if( !bot )
		bot = element_id;

	if( !pass )
	{
		if( !getline() )
		{
			bu_log( "Unexpected EOF while reading continuation card for CHEX1\n" );
			bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
				group_id, comp_id, element_id );
			rt_bomb( "CHEX1\n" );
		}
		return;
	}

	if( faces == NULL )
	{
		faces = (int *)bu_malloc( GRID_BLOCK*3*sizeof( int ), "faces" );
		thickness = (fastf_t *)bu_malloc( GRID_BLOCK*sizeof( fastf_t ), "thickness" );
		facemode = (char *)bu_malloc( GRID_BLOCK*sizeof( char ), "facemode" );
		face_size = GRID_BLOCK;
		face_count = 0;
	}

	for( i=0 ; i<6 ; i++ )
	{
		strncpy( field , &line[24 + i*8] , 8 );
		pts[i] = atoi( field );
	}

	strncpy( field , &line[72] , 8 );
	cont1 = atoi( field );

	if( !getline() )
	{
		bu_log( "Unexpected EOF while reading continuation card for CHEX1\n" );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d, c1 = %d\n",
			group_id, comp_id, element_id , cont1 );
		rt_bomb( "CHEX1\n" );
	}

	strncpy( field , line , 8 );
	cont2 = atoi( field );

	if( cont1 != cont2 )
	{
		bu_log( "Continuation card numbers do not match for CHEX1 element (%d vs %d)\n", cont1 , cont2 );
		bu_log( "\tskipping CHEX1 element: group_id = %d, comp_id = %d, element_id = %d\n",
			group_id, comp_id, element_id );
		return;
	}

	strncpy( field , &line[8] , 8 );
	pts[6] = atoi( field );

	strncpy( field , &line[16] , 8 );
	pts[7] = atoi( field );

	if( mode == PLATE_MODE )
	{
		strncpy( field , &line[56] , 8 );
		thick = atof( field ) * 25.4;
		if( thick <= 0.0 )
		{
			bu_log( "do_hex1: illegal thickness (%f), skipping CHEX1 element\n" , thick );
			bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
			return;
		}

		strncpy( field , &line[64] , 8 );
		pos = atoi( field );

		if( pos == 0 )	/* use default */
			pos = POS_FRONT;

		if( pos != POS_CENTER && pos != POS_FRONT )
		{
			bu_log( "do_hex1: illegal postion parameter (%d), must be 1 or 2, skipping CHEX1 element\n" , pos );
			bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
			return;
		}
	}
	else
	{
		pos =  POS_FRONT;
		thick = 0.0;
	}

	for( i=0 ; i<12 ; i++ )
		Add_bot_face( pts[hex_faces[i][0]], pts[hex_faces[i][1]], pts[hex_faces[i][2]], thick, pos );
}

void
do_hex2(void)
{
	int pts[8];
	int element_id;
	int i;
	int cont1,cont2;
	point_t points[8];
	char *name;

	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );

	if( !pass )
	{
		make_region_name( group_id , comp_id );
		if( !getline() )
		{
			bu_log( "Unexpected EOF while reading continuation card for CHEX2\n" );
			bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
				group_id, comp_id, element_id );
			rt_bomb( "CHEX2\n" );
		}
		return;
	}

	for( i=0 ; i<6 ; i++ )
	{
		strncpy( field , &line[24 + i*8] , 8 );
		pts[i] = atoi( field );
	}

	strncpy( field , &line[72] , 8 );
	cont1 = atoi( field );

	if( !getline() )
	{
		bu_log( "Unexpected EOF while reading continuation card for CHEX2\n" );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d, c1 = %d\n",
			group_id, comp_id, element_id , cont1 );
		rt_bomb( "CHEX2\n" );
	}

	strncpy( field , line , 8 );
	cont2 = atoi( field );

	if( cont1 != cont2 )
	{
		bu_log( "Continuation card numbers do not match for CHEX2 element (%d vs %d)\n", cont1 , cont2 );
		bu_log( "\tskipping CHEX2 element: group_id = %d, comp_id = %d, element_id = %d\n",
			group_id, comp_id, element_id );
		return;
	}

	strncpy( field , &line[8] , 8 );
	pts[6] = atoi( field );

	strncpy( field , &line[16] , 8 );
	pts[7] = atoi( field );

	for( i=0 ; i<8 ; i++ )
		VMOVE( points[i] , grid_pts[pts[i]] );

	name = make_solid_name( CHEX2 , element_id , comp_id , group_id , 0 );
	mk_arb8( fdout , name , &points[0][X] );
	bu_free( name, "solid_name" );

}

void
Process_hole_wall(void)
{
	if( debug )
		bu_log( "Process_hole_wall\n" );
	if( bu_debug & BU_DEBUG_MEM_CHECK )
		bu_prmem( "At start of Process_hole_wall:" );

	rewind( fdin );
	while( 1 )
	{
		if( !strncmp( line , "HOLE" , 4 ) )
			do_hole_wall( HOLE );
		else if( !strncmp( line , "WALL" , 4 ) )
			do_hole_wall( WALL );
		else if( !strncmp( line , "COMPSPLT", 8 ) )
			do_compsplt();
		else if( !strncmp( line, "SECTION", 7 ) )
		{
			strncpy( field , &line[24] , 8 );
			mode = atoi( field );
			if( mode != 1 && mode != 2 )
			{
				bu_log( "Illegal mode (%d) for group %d component %d, using volume mode\n",
					mode, group_id, comp_id );
				mode = 2;
			}
		}
		else if( !strncmp( line , "ENDDATA" , 7 ) )
			break;

		if( !getline() || !line[0] )
			break;
	}

	if( debug )
	{
		bu_log( "At end of Process_hole_wall:\n" );
		List_holes();
	}
}

void
do_chgcomp(void)
{

	if( !pass )
		return;

	if( !fd_muves )
		return;

	fprintf( fd_muves, "%s", line );
}

void
do_cbacking(void)
{
	int gr1, co1, gr2, co2, material;
	fastf_t thickness, probability;

	if( !pass )
		return;

	if( !fd_muves )
		return;

	strncpy( field, &line[8], 8 );
	gr1 = atoi( field );

	strncpy( field, &line[16], 8 );
	co1 = atoi( field );

	strncpy( field, &line[24], 8 );
	gr2 = atoi( field );

	strncpy( field, &line[32], 8 );
	co2 = atoi( field );

	strncpy( field, &line[40], 8 );
	thickness = atof( field ) * 25.4;

	strncpy( field, &line[48], 8 );
	probability = atof( field );

	strncpy( field, &line[56], 8 );
	material = atoi( field );

	fprintf( fd_muves, "CBACKING %d %d %g %g %d\n", gr1*1000+co1, gr2*1000+co2, thickness, probability, material );
}

int
Process_input(int pass_number)
{

	if( debug )
		bu_log( "\n\nProcess_input( pass = %d )\n" , pass_number );
	if( bu_debug & BU_DEBUG_MEM_CHECK )
		bu_prmem( "At start of Process_input:" );

	if( pass_number != 0 && pass_number != 1 )
	{
		bu_log( "Process_input: illegal pass number %d\n" , pass_number );
		rt_bomb( "Process_input" );
	}

	region_id = 0;
	pass = pass_number;
	if( !getline() || !line[0] )
		strcpy( line, "ENDDATA" );
	while( 1 )
	{
		if( !strncmp( line , "VEHICLE" , 7 ) )
			do_vehicle();
		else if( !strncmp( line , "HOLE" , 4 ) )
			;
		else if( !strncmp( line , "WALL" , 4 ) )
			;
		else if( !strncmp( line , "COMPSPLT", 8 ) )
			;
		else if( !strncmp( line, "CBACKING", 8 ) )
			do_cbacking();
		else if( !strncmp( line, "CHGCOMP", 7 ) )
			do_chgcomp();
		else if( !strncmp( line , "SECTION" , 7 ) )
			do_section( 0 );
		else if( !strncmp( line , "$NAME" , 5 ) )
			do_name();
		else if( !strncmp( line , "$COMMENT" , 8 ) )
			;
		else if( !strncmp( line , "GRID" , 4 ) )
			do_grid();
		else if( !strncmp( line , "CLINE" , 5 ) )
			do_cline();
		else if( !strncmp( line , "CHEX1" , 5 ) )
			do_hex1();
		else if( !strncmp( line , "CHEX2" , 5 ) )
			do_hex2();
		else if( !strncmp( line , "CTRI" , 4 ) )
			do_tri();
		else if( !strncmp( line , "CQUAD" , 5 ) )
			do_quad();
		else if( !strncmp( line , "CCONE1" , 6 ) )
			do_ccone1();
		else if( !strncmp( line , "CCONE2" , 6 ) )
			do_ccone2();
		else if( !strncmp( line , "CCONE3" , 6 ) )
			do_ccone3();
		else if( !strncmp( line , "CSPHERE" , 7 ) )
			do_sphere();
		else if( !strncmp( line , "ENDDATA" , 7 ) )
		{
			do_section( 1 );
			break;
		}
		else
			bu_log( "ERROR: skipping unrecognized data type\n%s\n" , line );

		if( !getline() || !line[0] )
			strcpy( line, "ENDDATA" );
	}

	if( debug )
	{
		bu_log( "At pass %d:\n" , pass );
		List_names();
	}

	return( 0 );
}

/* This routine is called for each combination in the model (via db_functree).
 * It looks for regions that consist of only one member. If that one member
 * is a combination, then the tree from that combination is placed in the
 * region (eliminating an extra, unnecessary redirection).
 */
void
fix_regions(struct db_i *dbip, struct directory *dp, genptr_t ptr)
{
	struct directory	*dp2;
	struct rt_db_internal   internal, internal2;
	struct rt_comb_internal *comb, *comb2;
	union tree		*tree, *tree2;

	/* only process regions */
	if( !(dp->d_flags & DIR_REGION) )
		return;

	if( rt_db_get_internal( &internal, dp, dbip, NULL, &rt_uniresource ) < 0 )
	{
		bu_log( "Failed to get internal representation of %s\n", dp->d_namep );
		bu_bomb( "rt_db_get_internal() Failed!!!\n" );
	}

	if( internal.idb_type != ID_COMBINATION )
	{
		bu_log( "In fix_regions:%s is not a combination!!!!\n", dp->d_namep );
		bu_bomb( "Expecting a combination!!!!\n" );
	}

	comb = (struct rt_comb_internal *)internal.idb_ptr;
	if( !comb->region_flag )
	{
		bu_log( "%s is not a region!!!!\n", dp->d_namep );
		bu_bomb( "Expecting a region!!!!\n" );
	}
	RT_CK_COMB( comb );
	tree = comb->tree;

	if( tree->tr_op != MKOP(12) )
	{
		rt_db_free_internal( &internal , &rt_uniresource);
		return;
	}

	/* only one element in tree */

	if( (dp2=db_lookup( dbip, tree->tr_l.tl_name, 0 )) == DIR_NULL )
	{
		bu_log( "Could not find %s\n", tree->tr_l.tl_name );
		rt_db_free_internal( &internal , &rt_uniresource);
		return;
	}

	if( rt_db_get_internal( &internal2, dp2, dbip, NULL, &rt_uniresource ) < 0 )
	{
		bu_log( "Failed to get internal representation of %s\n", dp2->d_namep );
		bu_bomb( "rt_db_get_internal() Failed!!!\n" );
	}

	if( internal2.idb_type != ID_COMBINATION )
	{
		rt_db_free_internal( &internal , &rt_uniresource);
		rt_db_free_internal( &internal2 , &rt_uniresource);
		return;
	}

	comb2 = (struct rt_comb_internal *)internal2.idb_ptr;
	RT_CK_COMB( comb2 );

	if( debug )
		bu_log( "Fixing region %s\n", dp->d_namep );

	/* move the second tree into the first */
	tree2 = comb2->tree;
	comb->tree = tree2;
	if( rt_db_put_internal( dp, dbip, &internal, &rt_uniresource ) < 0 )
	{
		bu_log( "Failed to write region %s\n", dp->d_namep );
		bu_bomb( "rt_db_put_internal() failed!!!\n" );
	}

	/* now kill the second combination */
	db_delete( dbip, dp2 );
	db_dirdelete( dbip, dp2 );

	db_free_tree( tree , &rt_uniresource);

}

void
Post_process(char *output_file)
{
	struct db_i *dbip;
	struct directory *dp;

	bu_log( "Cleaning up please wait.....\n" );

	if ((dbip = db_open( output_file , "rw")) == DBI_NULL)
	{
		bu_log( "Cannot open %s, post processing not completed\n", output_file );
		return;
	}

	if( debug )
		bu_log( "Rescanning file\n" );

	db_dirbuild( dbip );

	if( debug )
		bu_log( "looking up 'all'\n" );

	if( (dp=db_lookup( dbip, "all", 0 )) == DIR_NULL )
	{
		bu_log( "Cannot find group 'all' in model, post processing not completed\n" );
		db_close( dbip );
		return;
	}

	if( debug )
		bu_log( "Calling db_functree\n" );

	db_functree( dbip, dp, fix_regions, 0, &rt_uniresource, NULL );

	if( debug )
		bu_log( "Post-processing complete\n" );
}

void
make_region_list(char *str)
{
	char *ptr, *ptr2;

	region_list = (int *)bu_calloc( REGION_LIST_BLOCK, sizeof( int ), "region_list" );
	region_list_len = REGION_LIST_BLOCK;
	do_skips = 0;

	ptr = strtok( str, "," );
	while( ptr )
	{
		if( (ptr2=strchr( ptr, '-')) )
		{
			int i, start, stop;

			*ptr2 = '\0';
			ptr2++;
			start = atoi( ptr );
			stop = atoi( ptr2 );
			if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
				bu_log( "ERROR: bu_mem_barriercheck failed in make_region_list\n" );
			for( i=start ; i<=stop ; i++ )
			{
				if( do_skips == region_list_len )
				{
					region_list_len += REGION_LIST_BLOCK;
					region_list = (int *)bu_realloc( (char *)region_list, region_list_len*sizeof( int ), "region_list" );
					if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
						bu_log( "ERROR: bu_mem_barriercheck failed in make_region_list (after realloc)\n" );
				}
				region_list[do_skips++] = i;
				if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
					bu_log( "ERROR: bu_mem_barriercheck failed in make_region_list (after adding %d)\n", i );
			}
		}
		else
		{
			if( do_skips == region_list_len )
			{
				region_list_len += REGION_LIST_BLOCK;
				region_list = (int *)bu_realloc( (char *)region_list, region_list_len*sizeof( int ), "region_list" );
			}
			region_list[do_skips++] = atoi( ptr );
		}
		ptr = strtok( (char *)NULL, "," );
	}
}

void make_regions(void)
{
	struct name_tree *ptr1, *ptr2;
	struct holes *hptr;
	struct hole_list *lptr;
	struct compsplt *splt;
	struct wmember region;
	struct wmember solids;
	struct wmember holes;
	char reg_name[16];
	char solids_name[16];
	char hole_name[16];
	char splt_name[16];

	BU_LIST_INIT( &holes.l );

	/* loop through the list of region names (by ident) */
	bu_ptbl_reset( &stack );
	ptr1 = name_root;
	while( 1 )
	{
		while( ptr1 )
		{
			PUSH( ptr1 );
			ptr1 = ptr1->rleft;
		}
		POP( name_tree, ptr1 );
		if( !ptr1 )
			break;

		/* check if we are skipping some regions (but we might need all the holes) */
		if( skip_region( ptr1->region_id ) && !is_a_hole( ptr1->region_id ) )
			goto cont1;

		/* place all the solids for this ident in a "solids" combination */
		BU_LIST_INIT( &solids.l );
		bu_ptbl_reset( &stack2 );
		ptr2 = name_root;
		while( 1 )
		{
			while( ptr2 )
			{
				PUSH2( ptr2 );
				ptr2 = ptr2->nleft;
			}
			POP2( name_tree, ptr2 );
			if( !ptr2 )
				break;

			if( ptr2->region_id == -ptr1->region_id && ptr2->inner == 0 )
			{
				if( mk_addmember( ptr2->name, &solids.l, NULL, WMOP_UNION ) == (struct wmember *)NULL )
					bu_log( "make_regions: mk_addmember failed to add %s to %s\n", ptr1->name, ptr2->name );
			}

			ptr2 = ptr2->nright;
		}

		if( BU_LIST_IS_EMPTY( &solids.l ) )
			goto cont1;

		sprintf( solids_name, "solids_%d", ptr1->region_id );
		if( mk_comb( fdout, solids_name, &solids.l, 0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 1, 1) )
			bu_log("Failed to make combination of solids (%s)!!!!\n\tRegion %s is in ERROR!!!\n",
				solids_name, ptr1->name );

		/* hole components do not get made into regions */
		if( is_a_hole( ptr1->region_id ) )
		{
			/* just add it to the "holes" group */
			if( mk_addmember( solids_name, &holes.l, NULL, WMOP_UNION ) == (struct wmember *)NULL )
				bu_log( "make_regions: mk_addmember failed to add %s to holes group\n", ptr1->name );
			goto cont1;
		}

		hptr = hole_root;
		while( hptr && hptr->group * 1000 + hptr->component != ptr1->region_id )
			hptr = hptr->next;
		if( hptr )
			lptr = hptr->holes;
		else
			lptr = (struct hole_list *)NULL;

		splt = compsplt_root;
		while( splt && splt->ident_to_split != ptr1->region_id )
			splt = splt->next;

		mode = ptr1->mode;
		if( debug )
			bu_log( "Build region for %s %d, mode = %d\n", ptr1->name, ptr1->region_id, mode );

		if( splt )
		{
			vect_t norm;
			struct name_tree *ptr2;
			int found;

			/* make a halfspace */
			VSET( norm, 0.0, 0.0, 1.0 );
			sprintf( splt_name, "splt_%d.s", ptr1->region_id );
			mk_half( fdout, splt_name, norm, splt->z );

			/* intersect halfspace with current region */
			BU_LIST_INIT( &region.l );
			if( mk_addmember( solids_name, &region.l, NULL, WMOP_UNION ) == (struct wmember *)NULL )
				bu_log( "make_regions: mk_addmember failed to add %s to %s\n", solids_name, ptr1->name );

			if( mk_addmember( splt_name, &region.l, NULL, WMOP_INTERSECT ) == (struct wmember *)NULL )
				bu_log( "make_regions: mk_addmember failed to add %s to %s\n", splt_name, ptr1->name );

			while( lptr )
			{
				sprintf( hole_name, "solids_%d", (lptr->group * 1000 + lptr->component) );
				if( mk_addmember( hole_name, &region.l, NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
					bu_log( "make_regions: mk_addmember failed to add %s to %s\n", hole_name, ptr1->name );
				lptr = lptr->next;
			}
			MK_REGION( fdout, &region, ptr1->name, ptr1->region_id, get_fast4_color(ptr1->region_id) )

			/* create new region by subtracting halfspace */
			BU_LIST_INIT( &region.l );
			if( mk_addmember( solids_name, &region.l, NULL, WMOP_UNION ) == (struct wmember *)NULL )
				bu_log( "make_regions: mk_addmember failed to add %s to %s\n", solids_name, ptr1->name );

			if( mk_addmember( splt_name, &region.l, NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
				bu_log( "make_regions: mk_addmember failed to add %s to %s\n", splt_name, ptr1->name );

			while( lptr )
			{
				sprintf( hole_name, "solids_%d", (lptr->group * 1000 + lptr->component) );
				if( mk_addmember( hole_name, &region.l, NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
					bu_log( "make_regions: mk_addmember failed to add %s to %s\n", hole_name, ptr1->name );
				lptr = lptr->next;
			}
			ptr2 = Search_ident( name_root, splt->new_ident, &found );
			if( found ) {
				MK_REGION( fdout, &region, ptr2->name, splt->new_ident, get_fast4_color(splt->new_ident) )
			} else {
				sprintf( reg_name, "comp_%d.r", splt->new_ident );
				MK_REGION( fdout, &region, reg_name, splt->new_ident, get_fast4_color(splt->new_ident) )
			}
		}
		else
		{
			BU_LIST_INIT( &region.l );
			if( mk_addmember( solids_name, &region.l, NULL, WMOP_UNION ) == (struct wmember *)NULL )
				bu_log( "make_regions: mk_addmember failed to add %s to %s\n", solids_name, ptr1->name );

			while( lptr )
			{
				sprintf( hole_name, "solids_%d", (lptr->group * 1000 + lptr->component) );
				if( mk_addmember( hole_name, &region.l, NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
					bu_log( "make_regions: mk_addmember failed to add %s to %s\n", hole_name, ptr1->name );
				lptr = lptr->next;
			}
			MK_REGION( fdout, &region, ptr1->name, ptr1->region_id, get_fast4_color(ptr1->region_id) )
		}
cont1:
		ptr1 = ptr1->rright;
	}

	if( BU_LIST_NON_EMPTY( &holes.l ) )
	{
		/* build a "holes" group */
		if( mk_comb( fdout, "holes", &holes.l, 0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 1, 1) )
			bu_log("Failed to make holes group!!!!\n" );
	}
}

#define COLOR_LINE_LEN 256

void read_fast4_colors(char *color_file) {
  FILE *fp;
  char line[COLOR_LINE_LEN];
  int low, high;
  int r, g, b;
  struct fast4_color *color;

  if ((fp = fopen(color_file, "r")) == (FILE *)NULL) {
    bu_log("Cannot open color file (%s)\n", color_file);
    return;
  }

  while (fgets(line, COLOR_LINE_LEN, fp) != NULL) {
    if (sscanf(line, "%d %d %d %d %d", &low, &high, &r, &g, &b) != 5)
      continue;

    /* skip invalid colors */
    if (r < 0 || 255 < r ||
	g < 0 || 255 < g ||
	b < 0 || 255 < b)
      continue;

    /* skip bad region id ranges */
    if (high < low)
      continue;

    BU_GETSTRUCT(color, fast4_color);
    color->low = low;
    color->high = high;
    color->rgb[0] = r;
    color->rgb[1] = g;
    color->rgb[2] = b;
    BU_LIST_APPEND(&HeadColor.l, &color->l);
  }
}

unsigned char *
get_fast4_color(int r_id) {
  struct fast4_color *fcp;

  for (BU_LIST_FOR(fcp, fast4_color, &HeadColor.l)) {
    if (fcp->low <= r_id && r_id <= fcp->high)
      return fcp->rgb;
  }

  return (unsigned char *)NULL;
}


int
main(int argc, char **argv)
{
	int i;
	int c;
	char *plot_file=NULL;
	char *color_file=NULL;

	while( (c=getopt( argc , argv , "qm:o:c:dwx:b:X:C:" ) ) != EOF )
	{
		switch( c )
		{
			case 'q':	/* quiet mode */
				quiet = 1;
				break;
			case 'm':
				if( (fd_muves=fopen( optarg, "w" )) == (FILE *)NULL )
				{
					bu_log( "Unable to open MUVES file (%s)\n\tno MUVES file created\n",
						optarg );
				}
				break;
			case 'o':	/* output a plotfile of original FASTGEN4 elements */
				do_plot = 1;
				plot_file = optarg;
				break;
			case 'c':	/* convert only the specified components */
				make_region_list( optarg );
				break;
			case 'd':	/* debug option */
				debug = 1;
				break;
			case 'w':	/* print warnings */
				warnings = 1;
				break;
			case 'x':
				sscanf( optarg, "%x", (unsigned int *)&rt_debug );
				bu_debug = rt_debug;
				break;
			case 'b':
				sscanf( optarg, "%x", (unsigned int *)&bu_debug );
				break;
			case 'C':
				color_file = optarg;
				break;
			default:
				bu_log( "Unrecognzed option (%c)\n", c );
				rt_bomb( usage );
				break;
		}
	}

	if( bu_debug & BU_DEBUG_MEM_CHECK )
		bu_log( "doing memory checking\n" );

	if( argc-optind != 2 ) {
		bu_log( usage );
		exit( 1 );
	}

	rt_init_resource( &rt_uniresource, 0, NULL );

	if( (fdin=fopen( argv[optind] , "r" )) == (FILE *)NULL )
	{
		bu_log( "Cannot open FASTGEN4 file (%s)\n" , argv[optind] );
		perror( "fast4-g" );
		exit( 1 );
	}

	if( (fdout=wdb_fopen( argv[optind+1] )) == NULL )
	{
		bu_log( "Cannot open file for output (%s)\n" , argv[optind+1] );
		perror( "fast4-g" );
		exit( 1 );
	}

	if( plot_file )
	{
		if( (fd_plot=fopen( plot_file, "w")) == NULL )
		{
			bu_log( "Cannot open plot file (%s)\n", plot_file );
			bu_bomb( usage );
		}
	}

	if(bu_debug )
	{
		bu_printb( "librtbu_debug",bu_debug, DEBUG_FORMAT );
		bu_log("\n");
	}
	if( rt_g.NMG_debug )
	{
		bu_printb( "librt rt_g.NMG_debug", rt_g.NMG_debug, NMG_DEBUG_FORMAT );
		bu_log("\n");
	}

	BU_LIST_INIT(&HeadColor.l);
	if (color_file)
	  read_fast4_colors(color_file);

	grid_size = GRID_BLOCK;
	grid_pts = (point_t *)bu_malloc( grid_size * sizeof( point_t ) , "fast4-g: grid_pts" );

	cline_root = (struct cline *)NULL;

	name_root = (struct name_tree *)NULL;

	hole_root = (struct holes *)NULL;

	compsplt_root = (struct compsplt *)NULL;

	min_radius = 2.0 * sqrt( SQRT_SMALL_FASTF );

	name_count = 0;

	vehicle[0] = '\0';

	bu_ptbl_init( &stack , 64, " &stack ");
	bu_ptbl_init( &stack2 , 64, " &stack2 ");

	for( i=0 ; i<11 ; i++ )
		BU_LIST_INIT( &group_head[i].l );

	BU_LIST_INIT( &hole_head.l );

	if( !quiet )
		bu_log( "Scanning for HOLE, WALL, and COMPLSPLT cards...\n" );

	Process_hole_wall();

	rewind( fdin );

	if( !quiet )
		bu_log( "Building component names....\n" );

	Process_input( 0 );

	rewind( fdin );

	/* Make an ID record if no vehicle card was found */
	if( !vehicle[0] )
		mk_id_units( fdout , argv[optind] , "in" );

	if( !quiet )
		bu_log( "Building components....\n" );

	while( Process_input( 1 ) );

	if( !quiet )
		bu_log( "Building regions and groups....\n" );

	/* make regions */
	make_regions();

	/* make groups */
	do_groups();

	if( debug )
		List_holes();

	wdb_close( fdout );

	if( !quiet )
		bu_log( "%d components converted\n", comp_count );

	return 0;
}
@


11.83
log
@change conf.h to a wrapped config.h
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /cvs/brlcad/conv/fast4-g.c,v 11.82 2004/05/05 14:20:24 morrison Exp $";
@


11.82
log
@make the USE_SURVICE_MODS not compile-time-optional.  so that means the #if sections go bye bye.
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header$";
d27 5
a31 1
#include "conf.h"
@


11.81
log
@merge of ansi-6-0-branch into HEAD
@
text
@a132 1
#if USE_SURVICE_MODS
d145 1
a145 1
#define		MK_REGION( fp , headp , name , r_id, rgb ) \
a165 24
#else
/* convenient macro for building regions */
#define		MK_REGION( fp , headp , name , r_id ) \
			{\
				if( mode == 1 ) {\
					if( !quiet )\
						bu_log( "Making region: %s (PLATE)\n", name ); \
					mk_fastgen_region( fp , name , &((headp)->l) , 'P' ,\
						(char *)NULL, (char *)NULL, (unsigned char *)NULL, r_id, 0, 0, 0, 0 ); \
				}\
				else if( mode == 2 ) {\
					if( !quiet ) \
						bu_log( "Making region: %s (VOLUME)\n", name ); \
					mk_fastgen_region( fp , name , &((headp)->l) , 'V' ,\
						(char *)NULL, (char *)NULL, (unsigned char *)NULL, r_id, 0, 0, 0, 0 ); \
				}\
				else\
				{\
					bu_log( "Illegal mode (%d), while trying to make region (%s)\n",\
						mode, name );\
					bu_log( "\tRegion not made!!!!!\n");\
				}\
			}
#endif
a3313 1
#if USE_SURVICE_MODS
a3314 3
#else
			MK_REGION( fdout, &region, ptr1->name, ptr1->region_id )
#endif
a3332 1
#if USE_SURVICE_MODS
a3333 3
#else
				MK_REGION( fdout, &region, ptr2->name, splt->new_ident )
#endif
a3335 1
#if USE_SURVICE_MODS
a3336 3
#else
				MK_REGION( fdout, &region, reg_name, splt->new_ident )
#endif
a3351 1
#if USE_SURVICE_MODS
a3352 3
#else
			MK_REGION( fdout, &region, ptr1->name, ptr1->region_id )
#endif
a3365 1
#if USE_SURVICE_MODS
d3415 1
a3415 1
#endif
a3422 1
#if USE_SURVICE_MODS
a3423 1
#endif
a3458 1
#if USE_SURVICE_MODS
a3461 1
#endif
a3512 1
#if USE_SURVICE_MODS
a3515 1
#endif
@


11.80
log
@update copyright to include span through 2003
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.79 2002/11/27 13:41:40 jra Exp $";
d130 2
a131 2
void make_region_name();
char * make_solid_name();
d286 1
a286 1
int getline();
d288 1
a288 1
void make_bot_object();
d292 1
a292 2
is_a_hole( id )
int id;
d317 1
a317 3
add_to_holes( name, reg_id )
char *name;
int reg_id;
d324 1
a324 2
plot_tri( pt1, pt2, pt3 )
int pt1, pt2, pt3;
d333 1
a333 1
Check_names()
d381 1
a381 2
insert_int( in )
int in;
d408 1
a408 4
Subtract_holes( head , comp_id , group_id )
struct wmember *head;
int comp_id;
int group_id;
d474 1
a474 1
do_compsplt()
d516 1
a516 1
List_holes()
d537 1
a537 1
List_names()
d582 1
a582 4
Search_names( root , name , found )
struct name_tree *root;
char *name;
int *found;
d620 1
a620 4
Search_ident( root , reg_id , found )
struct name_tree *root;
int reg_id;
int *found;
d659 1
a659 3
Delete_name( root , name )
struct name_tree **root;
char *name;
d856 1
a856 4
Insert_name( root , name, inner )
struct name_tree **root;
char *name;
int inner;
d913 1
a913 3
Insert_region_name( name , reg_id )
char *name;
int reg_id;
d1003 1
a1003 3
find_region_name( g_id , c_id )
int g_id;
int c_id;
d1023 1
a1023 2
make_unique_name( name )
char *name;
d1049 1
a1049 3
add_to_series( name , reg_id )
char *name;
int reg_id;
d1063 1
a1063 1
make_comp_group()
d1127 1
a1127 1
Add_stragglers_to_groups()
d1159 1
a1159 1
do_groups()
d1193 1
a1193 1
do_name()
d1268 1
a1268 3
make_region_name( g_id , c_id )
int g_id;
int c_id;
d1293 1
a1293 6
get_solid_name( type , element_id , c_id , g_id , inner )
char type;
int element_id;
int c_id;
int g_id;
int inner;
d1307 1
a1307 6
make_solid_name( type , element_id , c_id , g_id , inner )
char type;
int element_id;
int c_id;
int g_id;
int inner;
d1319 1
a1319 1
do_grid()
d1363 1
a1363 1
do_sphere()
d1451 1
a1451 1
do_vehicle()
d1461 1
a1461 1
do_cline()
d1521 1
a1521 1
do_ccone1()
d1751 1
a1751 1
do_ccone2()
d1877 1
a1877 1
do_ccone3()
d2200 1
a2200 2
do_hole_wall( type )
int type;
d2282 1
a2282 1
getline()
d2307 1
a2307 4
Add_bot_face( pt1, pt2, pt3, thick, pos )
int pt1, pt2, pt3;
fastf_t thick;
int pos;
d2362 1
a2362 1
do_tri()
d2434 1
a2434 1
do_quad()
d2515 1
a2515 1
make_bot_object()
d2605 1
a2605 1
skip_section()
d2631 1
a2631 2
do_section( final )
int final;
d2702 1
a2702 1
do_hex1()
d2807 1
a2807 1
do_hex2()
d2876 1
a2876 1
Process_hole_wall()
d2918 1
a2918 1
do_chgcomp()
d2931 1
a2931 1
do_cbacking()
d2967 1
a2967 2
Process_input( pass_number )
int pass_number;
d3052 1
a3052 4
fix_regions( dbip, dp, ptr )
struct db_i *dbip;
struct directory *dp;
genptr_t	ptr;
d3136 1
a3136 2
Post_process( output_file )
char *output_file;
d3174 1
a3174 2
make_region_list( str )
char *str;
d3222 1
a3222 1
void make_regions()
d3460 1
a3460 3
main( argc , argv )
int argc;
char *argv[];
@


11.79
log
@BOT primitives can now have vertex normals
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1994 by the United States Army
d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.78 2002/08/20 17:07:21 jra Exp $";
@


11.79.6.1
log
@merge from HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.80 2004/02/02 17:39:00 morrison Exp $";
@


11.79.6.2
log
@merge from head
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.79.6.1 2004/02/12 19:24:23 erikg Exp $";
@


11.78
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.76 2002/06/20 13:45:33 butler Exp $";
d2621 1
a2621 1
	bot_ip.error_mode = 0;
@


11.78.4.1
log
@sync to HEAD...
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "$Header: /n/cad/c/CVS/brlcad/conv/fast4-g.c,v 11.80 2004/02/02 17:39:00 morrison Exp $";
d2621 1
a2621 1
	bot_ip.bot_flags = 0;
@


11.78.2.1
log
@Initial ANSIfication
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.78 2002/08/20 17:07:21 jra Exp $";
d130 2
a131 2
void make_region_name(int g_id, int c_id);
char * make_solid_name(char type, int element_id, int c_id, int g_id, int inner);
d286 1
a286 1
int getline(void);
d288 1
a288 1
void make_bot_object(void);
d292 2
a293 1
is_a_hole(int id)
d318 3
a320 1
add_to_holes(char *name, int reg_id)
d327 2
a328 1
plot_tri(int pt1, int pt2, int pt3)
d337 1
a337 1
Check_names(void)
d385 2
a386 1
insert_int(int in)
d413 4
a416 1
Subtract_holes(struct wmember *head, int comp_id, int group_id)
d482 1
a482 1
do_compsplt(void)
d524 1
a524 1
List_holes(void)
d545 1
a545 1
List_names(void)
d590 4
a593 1
Search_names(struct name_tree *root, char *name, int *found)
d631 4
a634 1
Search_ident(struct name_tree *root, int reg_id, int *found)
d673 3
a675 1
Delete_name(struct name_tree **root, char *name)
d872 4
a875 1
Insert_name(struct name_tree **root, char *name, int inner)
d932 3
a934 1
Insert_region_name(char *name, int reg_id)
d1024 3
a1026 1
find_region_name(int g_id, int c_id)
d1046 2
a1047 1
make_unique_name(char *name)
d1073 3
a1075 1
add_to_series(char *name, int reg_id)
d1089 1
a1089 1
make_comp_group(void)
d1153 1
a1153 1
Add_stragglers_to_groups(void)
d1185 1
a1185 1
do_groups(void)
d1219 1
a1219 1
do_name(void)
d1294 3
a1296 1
make_region_name(int g_id, int c_id)
d1321 6
a1326 1
get_solid_name(char type, int element_id, int c_id, int g_id, int inner)
d1340 6
a1345 1
make_solid_name(char type, int element_id, int c_id, int g_id, int inner)
d1357 1
a1357 1
do_grid(void)
d1401 1
a1401 1
do_sphere(void)
d1489 1
a1489 1
do_vehicle(void)
d1499 1
a1499 1
do_cline(void)
d1559 1
a1559 1
do_ccone1(void)
d1789 1
a1789 1
do_ccone2(void)
d1915 1
a1915 1
do_ccone3(void)
d2238 2
a2239 1
do_hole_wall(int type)
d2321 1
a2321 1
getline(void)
d2346 4
a2349 1
Add_bot_face(int pt1, int pt2, int pt3, fastf_t thick, int pos)
d2404 1
a2404 1
do_tri(void)
d2476 1
a2476 1
do_quad(void)
d2557 1
a2557 1
make_bot_object(void)
d2647 1
a2647 1
skip_section(void)
d2673 2
a2674 1
do_section(int final)
d2745 1
a2745 1
do_hex1(void)
d2850 1
a2850 1
do_hex2(void)
d2919 1
a2919 1
Process_hole_wall(void)
d2961 1
a2961 1
do_chgcomp(void)
d2974 1
a2974 1
do_cbacking(void)
d3010 2
a3011 1
Process_input(int pass_number)
d3096 4
a3099 1
fix_regions(struct db_i *dbip, struct directory *dp, genptr_t ptr)
d3183 2
a3184 1
Post_process(char *output_file)
d3222 2
a3223 1
make_region_list(char *str)
d3271 1
a3271 1
void make_regions(void)
d3509 3
a3511 1
main(int argc, char **argv)
@


11.78.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "$Header$";
d2579 1
a2579 1
	bot_ip.bot_flags = 0;
@


11.77
log
@Converted from K&R to ANSI C - RFH
@
text
@d130 2
a131 2
void make_region_name(int g_id, int c_id);
char * make_solid_name(char type, int element_id, int c_id, int g_id, int inner);
d286 1
a286 1
int getline(void);
d288 1
a288 1
void make_bot_object(void);
d292 2
a293 1
is_a_hole(int id)
d318 3
a320 1
add_to_holes(char *name, int reg_id)
d327 2
a328 1
plot_tri(int pt1, int pt2, int pt3)
d337 1
a337 1
Check_names(void)
d385 2
a386 1
insert_int(int in)
d413 4
a416 1
Subtract_holes(struct wmember *head, int comp_id, int group_id)
d482 1
a482 1
do_compsplt(void)
d524 1
a524 1
List_holes(void)
d545 1
a545 1
List_names(void)
d590 4
a593 1
Search_names(struct name_tree *root, char *name, int *found)
d631 4
a634 1
Search_ident(struct name_tree *root, int reg_id, int *found)
d673 3
a675 1
Delete_name(struct name_tree **root, char *name)
d872 4
a875 1
Insert_name(struct name_tree **root, char *name, int inner)
d932 3
a934 1
Insert_region_name(char *name, int reg_id)
d1024 3
a1026 1
find_region_name(int g_id, int c_id)
d1046 2
a1047 1
make_unique_name(char *name)
d1073 3
a1075 1
add_to_series(char *name, int reg_id)
d1089 1
a1089 1
make_comp_group(void)
d1153 1
a1153 1
Add_stragglers_to_groups(void)
d1185 1
a1185 1
do_groups(void)
d1219 1
a1219 1
do_name(void)
d1294 3
a1296 1
make_region_name(int g_id, int c_id)
d1321 6
a1326 1
get_solid_name(char type, int element_id, int c_id, int g_id, int inner)
d1340 6
a1345 1
make_solid_name(char type, int element_id, int c_id, int g_id, int inner)
d1357 1
a1357 1
do_grid(void)
d1401 1
a1401 1
do_sphere(void)
d1489 1
a1489 1
do_vehicle(void)
d1499 1
a1499 1
do_cline(void)
d1559 1
a1559 1
do_ccone1(void)
d1789 1
a1789 1
do_ccone2(void)
d1915 1
a1915 1
do_ccone3(void)
d2238 2
a2239 1
do_hole_wall(int type)
d2321 1
a2321 1
getline(void)
d2346 4
a2349 1
Add_bot_face(int pt1, int pt2, int pt3, fastf_t thick, int pos)
d2404 1
a2404 1
do_tri(void)
d2476 1
a2476 1
do_quad(void)
d2557 1
a2557 1
make_bot_object(void)
d2647 1
a2647 1
skip_section(void)
d2673 2
a2674 1
do_section(int final)
d2745 1
a2745 1
do_hex1(void)
d2850 1
a2850 1
do_hex2(void)
d2919 1
a2919 1
Process_hole_wall(void)
d2961 1
a2961 1
do_chgcomp(void)
d2974 1
a2974 1
do_cbacking(void)
d3010 2
a3011 1
Process_input(int pass_number)
d3096 4
a3099 1
fix_regions(struct db_i *dbip, struct directory *dp, genptr_t ptr)
d3183 2
a3184 1
Post_process(char *output_file)
d3222 2
a3223 1
make_region_list(char *str)
d3271 1
a3271 1
void make_regions(void)
d3509 3
a3511 1
main(int argc, char **argv)
@


11.76
log
@Removed extra comma.  It seems Bob never compiled his code.
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.75 2002/06/19 20:07:28 butler Exp $";
d130 2
a131 2
void make_region_name();
char * make_solid_name();
d286 1
a286 1
int getline();
d288 1
a288 1
void make_bot_object();
d292 1
a292 2
is_a_hole( id )
int id;
d317 1
a317 3
add_to_holes( name, reg_id )
char *name;
int reg_id;
d324 1
a324 2
plot_tri( pt1, pt2, pt3 )
int pt1, pt2, pt3;
d333 1
a333 1
Check_names()
d381 1
a381 2
insert_int( in )
int in;
d408 1
a408 4
Subtract_holes( head , comp_id , group_id )
struct wmember *head;
int comp_id;
int group_id;
d474 1
a474 1
do_compsplt()
d516 1
a516 1
List_holes()
d537 1
a537 1
List_names()
d582 1
a582 4
Search_names( root , name , found )
struct name_tree *root;
char *name;
int *found;
d620 1
a620 4
Search_ident( root , reg_id , found )
struct name_tree *root;
int reg_id;
int *found;
d659 1
a659 3
Delete_name( root , name )
struct name_tree **root;
char *name;
d856 1
a856 4
Insert_name( root , name, inner )
struct name_tree **root;
char *name;
int inner;
d913 1
a913 3
Insert_region_name( name , reg_id )
char *name;
int reg_id;
d1003 1
a1003 3
find_region_name( g_id , c_id )
int g_id;
int c_id;
d1023 1
a1023 2
make_unique_name( name )
char *name;
d1049 1
a1049 3
add_to_series( name , reg_id )
char *name;
int reg_id;
d1063 1
a1063 1
make_comp_group()
d1127 1
a1127 1
Add_stragglers_to_groups()
d1159 1
a1159 1
do_groups()
d1193 1
a1193 1
do_name()
d1268 1
a1268 3
make_region_name( g_id , c_id )
int g_id;
int c_id;
d1293 1
a1293 6
get_solid_name( type , element_id , c_id , g_id , inner )
char type;
int element_id;
int c_id;
int g_id;
int inner;
d1307 1
a1307 6
make_solid_name( type , element_id , c_id , g_id , inner )
char type;
int element_id;
int c_id;
int g_id;
int inner;
d1319 1
a1319 1
do_grid()
d1363 1
a1363 1
do_sphere()
d1451 1
a1451 1
do_vehicle()
d1461 1
a1461 1
do_cline()
d1521 1
a1521 1
do_ccone1()
d1751 1
a1751 1
do_ccone2()
d1877 1
a1877 1
do_ccone3()
d2200 1
a2200 2
do_hole_wall( type )
int type;
d2282 1
a2282 1
getline()
d2307 1
a2307 4
Add_bot_face( pt1, pt2, pt3, thick, pos )
int pt1, pt2, pt3;
fastf_t thick;
int pos;
d2362 1
a2362 1
do_tri()
d2434 1
a2434 1
do_quad()
d2515 1
a2515 1
make_bot_object()
d2605 1
a2605 1
skip_section()
d2631 1
a2631 2
do_section( final )
int final;
d2702 1
a2702 1
do_hex1()
d2807 1
a2807 1
do_hex2()
d2876 1
a2876 1
Process_hole_wall()
d2918 1
a2918 1
do_chgcomp()
d2931 1
a2931 1
do_cbacking()
d2967 1
a2967 2
Process_input( pass_number )
int pass_number;
d3052 1
a3052 4
fix_regions( dbip, dp, ptr )
struct db_i *dbip;
struct directory *dp;
genptr_t	ptr;
d3136 1
a3136 2
Post_process( output_file )
char *output_file;
d3174 1
a3174 2
make_region_list( str )
char *str;
d3222 1
a3222 1
void make_regions()
d3460 1
a3460 3
main( argc , argv )
int argc;
char *argv[];
@


11.75
log
@SURVICE mods
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.73 2002/03/19 20:39:25 jra Exp $";
d169 1
a169 1
#define		MK_REGION( fp , headp , name , r_id, ) \
@


11.74
log
@added matrix parameter to mk_addmember()
@
text
@d133 12
d146 24
a169 1
#define		MK_REGION( fp , headp , name , r_id ) \
d190 1
d322 1
a322 1
	if( mk_addmember( name , &hole_head.l , NULL, WMOP_UNION ) == (struct wmember *)NULL )
d465 1
a465 1
					if( mk_addmember( ptr->name , &(head->l) , NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
d1084 1
a1084 1
	if( mk_addmember( name , &group_head[group_id].l , NULL, WMOP_UNION ) == (struct wmember *)NULL )
d1115 1
a1115 1
			if( mk_addmember( ptr->name , &g_head.l , NULL, WMOP_UNION ) == (struct wmember *)NULL )
d3388 3
d3392 1
d3411 3
d3415 1
d3418 3
d3422 1
d3438 3
d3442 1
d3456 52
d3516 3
d3520 1
a3520 1
	while( (c=getopt( argc , argv , "qm:o:c:dwx:b:X:" ) ) != EOF )
d3554 5
d3609 6
@


11.73
log
@Minimum radius for a TGC is actually sqrt(SQRT_SMALL_FASTF)
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.72 2001/09/11 12:32:25 jra Exp $";
d286 1
a286 1
	if( mk_addmember( name , &hole_head.l , WMOP_UNION ) == (struct wmember *)NULL )
d429 1
a429 1
					if( mk_addmember( ptr->name , &(head->l) , WMOP_SUBTRACT ) == (struct wmember *)NULL )
d1048 1
a1048 1
	if( mk_addmember( name , &group_head[group_id].l , WMOP_UNION ) == (struct wmember *)NULL )
d1079 1
a1079 1
			if( mk_addmember( ptr->name , &g_head.l , WMOP_UNION ) == (struct wmember *)NULL )
d1140 1
a1140 1
			(void)mk_addmember( ptr->name, &group_head[ptr->region_id/1000].l, WMOP_UNION );
d1171 1
a1171 1
		if( mk_addmember( name , &head_all.l , WMOP_UNION ) == (struct wmember *)NULL )
d1421 1
a1421 1
		if( mk_addmember( name ,  &sphere_group.l , WMOP_UNION ) == (struct wmember *)NULL )
d1439 1
a1439 1
		if( mk_addmember( name , &sphere_group.l , WMOP_SUBTRACT ) == (struct wmember *)NULL )
d1667 1
a1667 1
		if( mk_addmember( outer_name , &r_head.l , WMOP_UNION ) == (struct wmember *)NULL )
d1740 1
a1740 1
			if( mk_addmember( inner_name , &r_head.l , WMOP_SUBTRACT ) == (struct wmember *)NULL )
d1855 1
a1855 1
		if( mk_addmember( name , &r_head.l , WMOP_UNION ) == (struct wmember *)NULL )
d1868 1
a1868 1
		if( mk_addmember( name , &r_head.l , WMOP_SUBTRACT ) == (struct wmember *)NULL )
d2039 1
a2039 1
			if( mk_addmember( name , &r_head.l , WMOP_UNION ) == (struct wmember *)NULL )
d2048 1
a2048 1
				if( mk_addmember( name , &r_head.l , WMOP_SUBTRACT ) == (struct wmember *)NULL )
d2064 1
a2064 1
			if( mk_addmember( name , &r_head.l , WMOP_UNION ) == (struct wmember *)NULL )
d2073 1
a2073 1
				if( mk_addmember( name , &r_head.l , WMOP_SUBTRACT ) == (struct wmember *)NULL )
d2089 1
a2089 1
			if( mk_addmember( name , &r_head.l , WMOP_UNION ) == (struct wmember *)NULL )
d2098 1
a2098 1
				if( mk_addmember( name , &r_head.l , WMOP_SUBTRACT ) == (struct wmember *)NULL )
d3286 1
a3286 1
				if( mk_addmember( ptr2->name, &solids.l, WMOP_UNION ) == (struct wmember *)NULL )
d3305 1
a3305 1
			if( mk_addmember( solids_name, &holes.l, WMOP_UNION ) == (struct wmember *)NULL )
d3339 1
a3339 1
			if( mk_addmember( solids_name, &region.l, WMOP_UNION ) == (struct wmember *)NULL )
d3342 1
a3342 1
			if( mk_addmember( splt_name, &region.l, WMOP_INTERSECT ) == (struct wmember *)NULL )
d3348 1
a3348 1
				if( mk_addmember( hole_name, &region.l, WMOP_SUBTRACT ) == (struct wmember *)NULL )
d3356 1
a3356 1
			if( mk_addmember( solids_name, &region.l, WMOP_UNION ) == (struct wmember *)NULL )
d3359 1
a3359 1
			if( mk_addmember( splt_name, &region.l, WMOP_SUBTRACT ) == (struct wmember *)NULL )
d3365 1
a3365 1
				if( mk_addmember( hole_name, &region.l, WMOP_SUBTRACT ) == (struct wmember *)NULL )
d3380 1
a3380 1
			if( mk_addmember( solids_name, &region.l, WMOP_UNION ) == (struct wmember *)NULL )
d3386 1
a3386 1
				if( mk_addmember( hole_name, &region.l, WMOP_SUBTRACT ) == (struct wmember *)NULL )
@


11.72
log
@Eliminated 16 character name restriction
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.71 2001/08/10 21:22:53 butler Exp $";
d83 1
d1615 1
a1615 1
		if( r1-thick <= SQRT_SMALL_FASTF && r2-thick <= SQRT_SMALL_FASTF )
d1635 4
a1638 4
	if( r1 < SQRT_SMALL_FASTF )
		r1 = SQRT_SMALL_FASTF;
	if( r2 < SQRT_SMALL_FASTF )
		r2 = SQRT_SMALL_FASTF;
d1695 1
a1695 1
			inner_r1 = SQRT_SMALL_FASTF;
d1698 2
a1699 2
		else if( inner_r1 < SQRT_SMALL_FASTF )
			inner_r1 = SQRT_SMALL_FASTF;
d1719 1
a1719 1
			inner_r2 = SQRT_SMALL_FASTF;
d1722 2
a1723 2
		else if( inner_r2 < SQRT_SMALL_FASTF )
			inner_r2 = SQRT_SMALL_FASTF;
d1726 1
a1726 1
		if( VDOT( inner_height , height ) < 0.0 )
d1834 2
a1835 2
	if( ro1 < SQRT_SMALL_FASTF )
		ro1 = SQRT_SMALL_FASTF;
d1837 2
a1838 2
	if( ro2 < SQRT_SMALL_FASTF )
		ro2 = SQRT_SMALL_FASTF;
d1859 2
a1860 2
		if( ri1 < SQRT_SMALL_FASTF )
			ri1 = SQRT_SMALL_FASTF;
d1862 2
a1863 2
		if( ri2 < SQRT_SMALL_FASTF )
			ri2 = SQRT_SMALL_FASTF;
d2022 4
a2025 4
		if( ro[i] < SQRT_SMALL_FASTF )
			ro[i] = SQRT_SMALL_FASTF;
		if( ri[i] < SQRT_SMALL_FASTF )
			ri[i] = SQRT_SMALL_FASTF;
d2035 1
a2035 1
		if( ro[0] != SQRT_SMALL_FASTF || ro[1] != SQRT_SMALL_FASTF )
d2044 1
a2044 1
			if( ri[0] != SQRT_SMALL_FASTF || ri[1] != SQRT_SMALL_FASTF )
d2060 1
a2060 1
		if( ro[1] != SQRT_SMALL_FASTF || ro[2] != SQRT_SMALL_FASTF )
d2069 1
a2069 1
			if( ri[1] != SQRT_SMALL_FASTF || ri[2] != SQRT_SMALL_FASTF )
d2085 1
a2085 1
		if( ro[2] != SQRT_SMALL_FASTF || ro[3] != SQRT_SMALL_FASTF )
d2094 1
a2094 1
			if( ri[2] != SQRT_SMALL_FASTF || ri[3] != SQRT_SMALL_FASTF )
d3508 2
@


11.71
log
@Compiler warning patches
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.70 2001/05/17 20:03:14 morrison Exp $";
a49 2
#define		NAMESIZE	16	/* from db.h */

a66 1
static char	name_name[NAMESIZE+1];	/* Component name built from $NAME card */
d130 1
a130 1
void make_solid_name();
d216 1
a216 1
	char name[NAMESIZE+1];
a449 1
	char name[NAMESIZE+1];
d483 1
a483 1
	make_region_name( name, gr1, co1 );
d855 1
a855 1
	strncpy( new_ptr->name , name , NAMESIZE+1 );
d871 1
a871 1
	diff = strncmp( name , ptr->name , NAMESIZE );
d931 1
a931 1
	strncpy( new_ptr->name , name , NAMESIZE+1 );
d938 1
a938 1
		diff = strncmp( name , nptr_model->name , NAMESIZE );
d1008 1
a1008 1
void
d1012 1
a1012 3
	char append[10];
	int append_len;
	int len;
d1017 5
a1021 1
	len = strlen( name );
a1022 1
	(void)Search_names( name_root , name , &found );
d1025 3
a1027 13
		sprintf( append , "_%d" , name_count );
		name_count++;
		append_len = strlen( append );

		if( len + append_len < NAMESIZE )
			strcat( name , append );
		else
		{
			strcpy( &name[NAMESIZE-append_len] , append );
			name[NAMESIZE] = '\0';
		}

		(void)Search_names( name_root , name , &found );
d1031 2
a1055 1
	char name[NAMESIZE+1];
d1090 2
a1091 1
		char *tmp_name;
d1093 1
a1093 3
		if( (tmp_name=find_region_name( group_id , comp_id )) )
			strcpy( name , tmp_name );
		else
d1095 4
a1098 2
			sprintf( name , "comp_%d" , region_id );
			make_unique_name( name );
d1110 2
d1162 1
a1162 1
		char name[NAMESIZE+1];
a1186 1
	int len;
a1246 7
	len = strlen( tmp_name );
	if( len <= NAMESIZE )
		strncpy( name_name , tmp_name , NAMESIZE );
	else
		strncpy( name_name , &tmp_name[len-NAMESIZE] , NAMESIZE );
	name_name[NAMESIZE] = '\0';

d1248 2
a1249 2
	make_unique_name( name_name );
	Insert_region_name( name_name , region_id );
d1257 1
a1257 2
make_region_name( name , g_id , c_id )
char *name;
d1263 1
a1271 2
	{
		strncpy( name , tmp_name , NAMESIZE+1 );
a1272 1
	}
d1275 2
a1276 4
	if( name_name[0] )
		strncpy( name , name_name , NAMESIZE+1 );
	else
		sprintf( name , "comp_%04d.r" , r_id );
d1283 2
a1284 3
void
get_solid_name( name , type , element_id , c_id , g_id , inner )
char *name;
d1292 1
d1296 4
a1299 1
	sprintf( name , "%d.%d.%c%d" , reg_id , element_id , type , inner );
d1302 2
a1303 3
void
make_solid_name( name , type , element_id , c_id , g_id , inner )
char *name;
d1310 3
a1312 1
	get_solid_name( name , type , element_id , c_id , g_id , inner );
d1315 2
d1371 1
a1371 1
	char name[NAMESIZE+1];
d1376 1
a1376 1
		make_region_name( name , group_id , comp_id );
d1409 1
a1409 1
		make_solid_name( name , CSPHERE , element_id , comp_id , group_id , 0 );
d1411 1
d1415 1
a1415 1
		make_solid_name( name , CSPHERE , element_id , comp_id , group_id , 1 );
d1425 1
d1435 1
a1435 1
		make_solid_name( name , CSPHERE , element_id , comp_id , group_id , 2 );
d1443 1
d1445 1
a1445 1
		make_solid_name( name , CSPHERE , element_id , comp_id , group_id , 0 );
d1447 1
d1469 1
a1469 1
	char name[NAMESIZE+1];
d1476 1
a1476 1
		make_region_name( name , group_id , comp_id );
d1516 1
a1516 1
	make_solid_name( name , CLINE , element_id , comp_id , group_id , 0 );
d1518 1
d1531 3
a1533 3
	char outer_name[NAMESIZE+1];
	char inner_name[NAMESIZE+1];
	char name[NAMESIZE+1];
d1541 1
a1541 1
		make_region_name( outer_name , group_id , comp_id );
d1643 1
a1643 1
		make_solid_name( outer_name , CCONE1 , element_id , comp_id , group_id , 0 );
d1645 1
d1662 1
a1662 1
		make_solid_name( outer_name , CCONE1 , element_id , comp_id , group_id , 1 );
d1668 1
d1736 1
a1736 1
			make_solid_name( inner_name , CCONE1 , element_id , comp_id , group_id , 2 );
d1741 1
d1744 1
a1744 1
		make_solid_name( name , CCONE1 , element_id , comp_id , group_id , 0 );
d1746 1
d1759 1
a1759 1
	char name[NAMESIZE+1];
d1767 1
a1767 1
		make_region_name( name , group_id , comp_id );
d1845 1
a1845 1
		make_solid_name( name , CCONE2 , element_id , comp_id , group_id , 0 );
d1847 1
d1851 1
a1851 1
		make_solid_name( name , CCONE2 , element_id , comp_id , group_id , 1 );
d1856 1
d1864 1
a1864 1
		make_solid_name( name , CCONE2 , element_id , comp_id , group_id , 2 );
d1869 1
d1871 1
a1871 1
		make_solid_name( name , CCONE2 , element_id , comp_id , group_id , 0 );
d1873 1
d1882 1
a1882 1
	char name[NAMESIZE+1];
d1892 1
a1892 1
		make_region_name( name , group_id , comp_id );
d2036 1
a2036 1
			make_solid_name( name, CCONE3, element_id, comp_id, group_id, 1 );
d2040 1
d2045 1
a2045 1
				make_solid_name( name, CCONE3, element_id, comp_id, group_id, 11 );
d2049 1
d2061 1
a2061 1
			make_solid_name( name, CCONE3, element_id, comp_id, group_id, 2 );
d2065 1
d2070 1
a2070 1
				make_solid_name( name, CCONE3, element_id, comp_id, group_id, 22 );
d2074 1
d2086 1
a2086 1
			make_solid_name( name, CCONE3, element_id, comp_id, group_id, 3 );
d2090 1
d2095 1
a2095 1
				make_solid_name( name, CCONE3, element_id, comp_id, group_id, 33 );
d2099 1
d2104 1
a2104 1
	make_solid_name( name , CCONE3 , element_id , comp_id , group_id , 0 );
d2106 1
d2527 1
a2527 1
	char name[NAMESIZE+1];
d2534 1
a2534 1
		make_region_name( name , group_id , comp_id );
d2594 1
a2594 1
	make_solid_name( name , BOT , element_id , comp_id , group_id , 0 );
d2597 1
a2644 2
	name_name[0] = '\0';

d2659 1
a2659 3
		char	name[NAMESIZE+1];

		make_region_name( name , group_id , comp_id );
a2700 3
		else
			name_name[0] = '\0';

d2820 1
a2820 1
	char name[NAMESIZE+1];
d2827 1
a2827 1
		make_region_name( name , group_id , comp_id );
d2875 1
a2875 1
	make_solid_name( name , CHEX2 , element_id , comp_id , group_id , 0 );
d2877 2
a3507 1
	name_name[0] = '\0';
@


11.70
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.69 2001/04/02 13:04:20 jra Exp $";
d3440 1
a3440 1
				sscanf( optarg, "%x", &rt_debug );
d3444 1
a3444 1
				sscanf( optarg, "%x", &bu_debug );
@


11.69
log
@Lint
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.68 2001/03/20 19:13:48 jra Exp $";
d75 1
a75 1
static int	rt_debug=0;		/* rt_g.debug */
d374 1
a374 1
	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
d443 1
a443 1
	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
d722 1
a722 1
		if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
d833 1
a833 1
	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
d894 1
a894 1
	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
d986 1
a986 1
	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
d1042 1
a1042 1
	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
d1069 1
a1069 1
	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
d1269 1
a1269 1
	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
d1344 1
a1344 1
	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
d1375 1
a1375 1
	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
d2128 1
a2128 1
			if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
d2136 1
a2136 1
					if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
d2140 1
a2140 1
				if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
@


11.68
log
@Merge with 5.3 version
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /d/CVS/brlcad/conv/fast4-g.c,v 11.67 2000/12/22 16:49:27 jra Exp $";
d1104 1
a1104 1
		if( (tmp_name=find_region_name( group_id , comp_id , 0 )) )
d1266 1
a1266 1
	Insert_region_name( name_name , region_id , 0 );
d2530 1
a2530 1
		make_region_name( name , group_id , comp_id , element_id , BOT );
d2658 1
a2658 1
		make_region_name( name , group_id , comp_id , bot , NMG );
a3409 1
	char *output_file;
a3475 1
	output_file = argv[optind+1];
@


11.67
log
@Added check for illegal second SECTION card for the same component
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.66 2000/12/22 01:09:22 jra Exp $";
d453 1
d487 1
d2213 6
a2236 5
	if( type == HOLE ) {
		while( col < s_len )
		{
			strncpy( field , &line[col] , 8 );
			igrp = atoi( field );
d2238 8
a2245 3
			col += 8;
			if( col >= s_len )
				break;
d2247 2
a2248 2
			strncpy( field , &line[col] , 8 );
			icmp = atoi( field );
d2250 5
a2254 1
			if( igrp >= 0 && icmp > 0 )
d2256 5
a2260 2
				if( igrp == group && comp == icmp )
					bu_log( "Hole or wall card references itself (ignoring): (%s)\n", line );
d2263 2
a2264 14
					if( list_ptr )
					{
						list_ptr->next = (struct hole_list *)bu_malloc( sizeof( struct hole_list ) , "do_hole_wall: list_ptr" );
						list_ptr = list_ptr->next;
					}
					else
					{
						list_ptr = (struct hole_list *)bu_malloc( sizeof( struct hole_list ) , "do_hole_wall: list_ptr" );
						list_start = list_ptr;
					}
				
					list_ptr->group = igrp;
					list_ptr->component = icmp;
					list_ptr->next = (struct hole_list *)NULL;
d2266 4
a2270 2

			col += 8;
d2273 2
a2274 5
		Add_holes( type, group , comp , list_start );
	} else if( type == WALL ) {
		while( col < s_len ) {
			strncpy( field , &line[col] , 8 );
			igrp = atoi( field );
d2276 1
a2276 21
			col += 8;
			if( col >= s_len )
				break;

			strncpy( field , &line[col] , 8 );
			icmp = atoi( field );

			if( igrp >= 0 && icmp > 0 ) {
				list_ptr = (struct hole_list *)bu_malloc( sizeof( struct hole_list ) , "do_hole_wall: list_ptr" );
				list_ptr->group = group;
				list_ptr->component = comp;
				list_ptr->next = (struct hole_list *)NULL;
				Add_holes( type, igrp, icmp, list_ptr );
			}

			col += 8;
		}
	} else {
		bu_log( "do_hole_wall: unrecognized type (%d)\n", type );
		bu_bomb( "do_hole_wall: unrecognized type\n" );
	}
d2692 9
a2700 9
               if( !pass )
               {
                       nm_ptr = Search_ident( name_root, region_id, &found );
                       if( found && nm_ptr->mode != mode ) {
                               bu_log( "ERROR: second SECTION card found with different mode for component (group=%d, component=%d), conversion of this component will be incorrect!!!\n",
                                       group_id, comp_id );
                       }
               }
               else
d2829 1
d2898 11
d3292 3
d3328 2
d3368 7
a3374 2
			sprintf( reg_name, "comp_%d.r", splt->new_ident );
			MK_REGION( fdout, &region, reg_name, splt->new_ident )
d3457 4
a3460 2
	if( argc-optind != 2 )
		bu_bomb( usage );
@


11.66
log
@Corrections to get correct mode assigned to regions
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.65 2000/12/21 15:05:52 jra Exp $";
d2622 23
d2652 2
a2667 3

			make_comp_group();

d2691 1
a2691 18
			long section_start;

			/* skip to start of next section */
			section_start = ftell( fdin );
			if( getline() )
			{
				while( line[0] && strncmp( line, "SECTION" , 7 ) &&
						strncmp( line, "HOLE", 4 ) &&
						strncmp( line, "WALL", 4 ) &&
						strncmp( line, "VEHICLE", 7 ) )
				{
					section_start = ftell( fdin );
					if( !getline() )
						break;
				}
			}
			/* seek to start of the section */
			fseek( fdin, section_start, SEEK_SET );
d2710 9
a2718 1
		if( pass )
@


11.65
log
@Reworked region building to better handle HOLE/WALL cards
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.64 2000/12/01 13:37:19 jra Exp $";
d63 1
a63 1
static int	mode=0;			/* Plate mode (1) or volume mode (2) */
d138 3
a140 3
				if( !quiet ) \
					bu_log( "Making region: %s\n", name ); \
				if( mode == 1 )\
d143 4
a146 1
				else if( mode == 2 )\
d149 1
d216 1
d930 1
d3311 1
d3313 1
a3313 1
			bu_log( "Build region for %s %d\n", ptr1->name, ptr1->region_id );
@


11.64
log
@Previous commit was really hosed!!!!!
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.62 2000/10/31 22:35:11 mike Exp $";
a66 1
static int	joint_no=0;		/* Count of CLINE joints (sph solids created to connect CLINES) */
d85 1
a85 1
static struct bu_ptbl tstack;		/* Stack for traversing union tree */
d136 1
a136 1
#define		MK_REGION( fp , headp , g_id , c_id , e_id , type ) \
d138 1
a138 5
				int r_id; \
				char name[NAMESIZE+1]; \
				r_id = g_id * 1000 + c_id; \
				make_region_name( name , g_id , c_id , e_id , type ); \
				if( debug ) \
d163 9
d212 1
a212 3
	int element_id;		/* > 0  -> normal fastgen4 element id
				 * < 0  -> CLINE element (-pt1)
				 * == 0 -> component name */
d409 3
a411 7
				if( !ptr || ptr->region_id != reg_id )
				{
					bu_log( "WARNING: Can't find a hole/wall to subtract for group %d, component %d\n" , group_id , comp_id );
					bu_log( "         Missing group #%d component #%d\n",
						list_ptr->group, list_ptr->component );
				}
				else
a413 2
					bu_ptbl_reset( &stack );

d416 9
a424 8
						while( ptr && ptr->region_id == reg_id )
						{
							PUSH( ptr );
							ptr = ptr->rleft;
						}
						POP( name_tree , ptr );
						if( !ptr ||  ptr->region_id != reg_id )
							break;
d426 2
a427 2
						if( mk_addmember( ptr->name , &(head->l) , WMOP_SUBTRACT ) == (struct wmember *)NULL )
							rt_bomb( "Subtract_holes: mk_addmember failed\n" );
d429 1
a429 2
						ptr = ptr->rright;
					}
a442 85
Compsplt( headp, comp_id, group_id )
struct wmember *headp;
int comp_id, group_id;
{
	int ident;
	struct compsplt *splt;
	struct wmember spl_head;
	struct wmember *m1, *m2;
	vect_t norm;
	char name[NAMESIZE+1];
	int found_union;

	ident = group_id * 1000 + comp_id;

	splt = compsplt_root;

	while( splt )
	{
		if( splt->ident_to_split == ident )
		{
			/* make a halfspace */
			VSET( norm, 0.0, 0.0, 1.0 );
			make_solid_name( name, COMPSPLT, 0, comp_id, group_id, 0 );
			mk_half( fdout, name, norm, splt->z );

			BU_LIST_INIT( &spl_head.l );

			/* Go through member list simultaneoulsy copying the list
			 * and adding references to the halfspace
			 */
			m1 = BU_LIST_FIRST( wmember, &headp->l );
			if( m1->wm_op == UNION )
				found_union = -1;
			else
				found_union = 0;
			while( BU_LIST_NOT_HEAD( &m1->l, &headp->l ) )
			{
				if( m1->wm_op == UNION )
					found_union++;
				if( found_union > 0 )
				{
					/* time to subtract the halfspace from the new region */
					(void)mk_addmember( name, &spl_head.l, WMOP_SUBTRACT );

					/* and intersect it with the old one */
					/* start by adding the new membwe to the end of the list */
					m2 = mk_addmember( name, &(headp->l), WMOP_INTERSECT );

					/* now get it out of the list */
					BU_LIST_DEQUEUE( &m2->l );

					/* and put it back in where I want it */
					BU_LIST_INSERT( &m1->l, &m2->l );

					found_union = 0;
				}

				/* copy this member to the new list */
				switch( m1->wm_op )
				{
					case UNION:
						(void)mk_addmember( m1->wm_name, &spl_head.l, WMOP_UNION );
						break;
					case INTERSECT:
						(void)mk_addmember( m1->wm_name, &spl_head.l, WMOP_INTERSECT );
						break;
					case SUBTRACT:
						(void)mk_addmember( m1->wm_name, &spl_head.l, WMOP_SUBTRACT );
						break;
				}
				m1 = BU_LIST_NEXT( wmember, &m1->l );
			}

			(void)mk_addmember( name, &spl_head.l, WMOP_SUBTRACT );
			(void)mk_addmember( name, &(headp->l), WMOP_INTERSECT );

			MK_REGION( fdout, &spl_head, splt->new_ident/1000, splt->new_ident%1000, 0, COMPSPLT )

			return;
		}
		splt = splt->next;
	}
}

void
d525 1
a525 1
			bu_log( "%s %d %d (in a comp group)\n" , ptr->name , ptr->region_id , ptr->element_id );
d527 1
a527 1
			bu_log( "%s %d %d (not in a comp group)\n" , ptr->name , ptr->region_id , ptr->element_id );
d544 1
a544 1
		bu_log( "%s\n" , ptr->name );
a589 51
char *
find_nmg_region_name( g_id, c_id )
int g_id;
int c_id;
{
	int reg_id;
	struct name_tree *ptr;

	reg_id = g_id*1000 + c_id;

	ptr = name_root;
	if( !ptr )
		return( (char *)NULL );

	while( 1 )
	{
		int diff;

		diff = reg_id - ptr->region_id;
		if( diff == 0 )
		{
			int len;

			len = strlen( ptr->name );
			if( !strcmp( &ptr->name[len-4] , ".n.r" ) )
				return( ptr->name );
			else
			{
				if( ptr->rright )
					ptr = ptr->rright;
				else
					return( (char *)NULL );
			}
		}
		else if( diff > 0 )
		{
			if( ptr->rright )
				ptr = ptr->rright;
			else
				return( (char *)NULL );
		}
		else if( diff < 0 )
		{
			if( ptr->rleft )
				ptr = ptr->rleft;
			else
				return( (char *)NULL );
		}
	}
}

d591 1
a591 1
Search_ident( root , reg_id , el_id , found )
a593 1
int el_id;
a608 2
		if( diff == 0 )
			diff = el_id - ptr->element_id;
d638 1
a638 1
	int r_id, e_id;
a680 1
	e_id = ptr->element_id;
a757 2
		if( diff == 0 )
			diff = e_id - ptr->element_id;
d832 1
a832 1
Insert_name( root , name )
d835 1
d859 1
a859 1
	new_ptr->element_id = 0;
d892 1
a892 1
Insert_region_name( name , reg_id , el_id )
a894 1
int el_id;
d902 1
a902 1
		bu_log( "Insert_region_name( name=%s, reg_id=%d, el_id=%d\n" , name, reg_id, el_id );
d904 1
a904 1
	rptr_model = Search_ident( name_root , reg_id , el_id , &foundr );
d912 2
a913 2
		bu_log( "Insert_region_name: name %s ident %d element %d\n\tfound name is %d\n\tfound ident is %d\n",
			name, reg_id, el_id, foundn, foundr );
d925 1
a925 1
	new_ptr->element_id = el_id;
a957 3
		if( diff == 0 )
			diff = el_id - rptr_model->element_id;

d983 1
a983 1
find_region_name( g_id , c_id , el_id )
a985 1
int el_id;
d994 1
a994 1
		bu_log( "find_region_name( g_id=%d, c_id=%d, el_id=%d ), reg_id=%d\n" , g_id, c_id, el_id, reg_id );
d996 1
a996 1
	ptr = Search_ident( name_root , reg_id , el_id , &found );
d1080 1
a1080 1
		if(ptr->region_id == region_id && ptr->element_id && !ptr->in_comp_group )
d1105 1
a1105 1
			Insert_name( &name_root , name );
d1137 1
a1137 1
		if( !ptr->in_comp_group && ptr->region_id > 0 )
d1218 8
a1225 1
	strncpy( comp_name , &line[56] , 24 );
d1228 1
a1228 1
	i = 26;
d1266 1
a1266 1
make_region_name( name , g_id , c_id , element_id , type )
a1269 2
int element_id;
char type;
d1277 1
a1277 1
		bu_log( "make_region_name( g_id=%d, c_id=%d, element_id=%d, type=%c )\n" , g_id, c_id, element_id, type );
d1279 1
a1279 1
	tmp_name = find_region_name( g_id , c_id , element_id );
a1288 2
	else if( element_id < 0 && type == CLINE )
		sprintf( name , "%d.j.%d.r" , r_id , joint_no++ );
d1290 1
a1290 1
		sprintf( name , "%d.%d.%c.r" , r_id , element_id , type );
d1294 1
a1294 1
	Insert_region_name( name , r_id , element_id );
d1324 1
a1324 1
	Insert_name( &name_root , name );
d1380 1
a1380 4
	struct wmember sphere_region;

	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );
d1384 1
a1384 1
		make_region_name( name , group_id , comp_id , element_id , CSPHERE );
d1388 3
d1413 1
a1413 4
	BU_LIST_INIT( &sphere_region.l );

	make_solid_name( name , CSPHERE , element_id , comp_id , group_id , 0 );
	mk_sph( fdout , name , grid_pts[center_pt] , radius );
d1415 1
a1415 1
	if( mk_addmember( name ,  &sphere_region.l , WMOP_UNION ) == (struct wmember *)NULL )
d1417 2
a1418 2
		bu_log( "do_sphere: Error in adding %s to sphere region\n" , name );
		rt_bomb( "do_sphere" );
d1420 12
a1432 2
	if( mode == PLATE_MODE )
	{
d1441 1
a1441 1
		make_solid_name( name , CSPHERE , element_id , comp_id , group_id , 1 );
d1444 1
a1444 1
		if( mk_addmember( name , &sphere_region.l , WMOP_SUBTRACT ) == (struct wmember *)NULL )
d1449 3
a1452 18

	/* subtract any holes for this component */
	Subtract_holes( &sphere_region , comp_id , group_id );

	/* process any component splitting */
	Compsplt( &sphere_region, comp_id, group_id );

	MK_REGION( fdout , &sphere_region , group_id , comp_id , element_id , CSPHERE )
}

void
make_nmg_name( name , r_id )
char *name;
int r_id;
{
	sprintf( name , "nmg.%d" , r_id );

	make_unique_name( name );
a1473 1
	struct wmember r_head;
d1478 6
a1511 6
	if( !pass )
	{
		make_region_name( name , group_id , comp_id , element_id , CLINE );
		return;
	}

a1521 13

	BU_LIST_INIT( &r_head.l );
	if( mk_addmember( name , &r_head.l , WMOP_UNION ) == (struct wmember *)NULL )
		bu_bomb( "CLINE: mk_addmember failed\n" );

	/* subtract any holes for this component */
	Subtract_holes( &r_head , comp_id , group_id );

	/* process any component splitting */
	Compsplt( &r_head, comp_id, group_id );

	MK_REGION( fdout , &r_head , group_id , comp_id , element_id , CLINE )

d1536 1
d1544 1
a1544 1
		make_region_name( outer_name , group_id , comp_id , element_id , CCONE1 );
a1641 1
	/* make outside TGC */
a1642 2
	make_solid_name( outer_name , CCONE1 , element_id , comp_id , group_id , 0 );
	mk_trc_h( fdout , outer_name , grid_pts[pt1] , height , r1 , r2 );
d1644 6
a1649 5
	BU_LIST_INIT( &r_head.l );
	if( mk_addmember( outer_name , &r_head.l , WMOP_UNION ) == (struct wmember *)NULL )
		rt_bomb( "CCONE1: mk_addmember failed\n" );

	if( mode == PLATE_MODE )
d1663 8
d1737 1
a1737 1
			make_solid_name( inner_name , CCONE1 , element_id , comp_id , group_id , 1 );
d1743 3
a1747 7
	/* subtract any holes for this component */
	Subtract_holes( &r_head , comp_id , group_id );

	/* process any component splitting */
	Compsplt( &r_head, comp_id, group_id );

	MK_REGION( fdout , &r_head , group_id , comp_id , element_id , CCONE1 )
d1766 1
a1766 1
		make_region_name( name , group_id , comp_id , element_id , CCONE2 );
d1842 9
a1850 2
	make_solid_name( name , CCONE2 , element_id , comp_id , group_id , 0 );
	mk_trc_h( fdout , name , grid_pts[pt1] , height , ro1 , ro2 );
d1852 2
a1853 2
	if( mk_addmember( name , &r_head.l , WMOP_UNION ) == (struct wmember *)NULL )
		rt_bomb( "mk_addmember failed!\n" );
a1854 2
	if( ri1 > 0.0 || ri2 > 0.0 )
	{
d1861 1
a1861 1
		make_solid_name( name , CCONE2 , element_id , comp_id , group_id , 1 );
d1866 3
a1869 8

	/* subtract any holes for this component */
	Subtract_holes( &r_head , comp_id , group_id );

	/* process any component splitting */
	Compsplt( &r_head, comp_id, group_id );

	MK_REGION( fdout , &r_head , group_id , comp_id , element_id , CCONE2 )
d1887 1
a1887 1
		make_region_name( name , group_id , comp_id , element_id , CCONE3 );
a2043 3

			/* subtract any holes for this component */
			Subtract_holes( &r_head , comp_id , group_id );
a2066 3

			/* subtract any holes for this component */
			Subtract_holes( &r_head , comp_id , group_id );
a2089 3

			/* subtract any holes for this component */
			Subtract_holes( &r_head , comp_id , group_id );
d2093 2
a2094 4
	/* process any component splitting */
	Compsplt( &r_head, comp_id, group_id );

	MK_REGION( fdout , &r_head , group_id , comp_id , element_id , CCONE3 )
d2223 5
a2227 4
	while( col < s_len )
	{
		strncpy( field , &line[col] , 8 );
		igrp = atoi( field );
d2229 3
a2231 3
		col += 8;
		if( col >= s_len )
			break;
d2233 2
a2234 2
		strncpy( field , &line[col] , 8 );
		icmp = atoi( field );
d2236 1
a2236 5
		if( igrp >= 0 && icmp > 0 )
		{
			if( igrp == group && comp == icmp )
				bu_log( "Hole or wall card references itself (ignoring): (%s)\n", line );
			else
d2238 2
a2239 5
				if( list_ptr )
				{
					list_ptr->next = (struct hole_list *)bu_malloc( sizeof( struct hole_list ) , "do_hole_wall: list_ptr" );
					list_ptr = list_ptr->next;
				}
d2242 14
a2255 2
					list_ptr = (struct hole_list *)bu_malloc( sizeof( struct hole_list ) , "do_hole_wall: list_ptr" );
					list_start = list_ptr;
d2257 22
a2278 3
			
				list_ptr->group = igrp;
				list_ptr->component = icmp;
d2280 1
d2282 2
d2285 3
a2287 2

		col += 8;
a2288 2

	Add_holes( type, group , comp , list_start );
a2535 1
	struct wmember bot_region;
d2600 1
a2600 3
		bu_log( "\t%d duplicate faces eliminated\n", count );

	BU_LIST_INIT( &bot_region.l );
a2613 14
	if( mk_addmember( name ,  &bot_region.l , WMOP_UNION ) == (struct wmember *)NULL )
	{
		bu_log( "make_bot_object: Error in adding %s to bot region\n" , name );
		rt_bomb( "make_bot_object" );
	}


	/* subtract any holes for this component */
	Subtract_holes( &bot_region , comp_id , group_id );

	/* process any component splitting */
	Compsplt( &bot_region, comp_id, group_id );

	MK_REGION( fdout , &bot_region , group_id , comp_id , element_id , BOT )
d2627 2
d2637 1
a2637 3
#if 0
			make_cline_regions();
#endif
a2683 4
		if( pass && !quiet )
			bu_log( "Making component %s, group #%d, component #%d\n",
				name_name, group_id , comp_id );

a2821 1
	struct wmember head;
a2876 16

	BU_LIST_INIT( &head.l );

	if( mk_addmember( name , &head.l , WMOP_UNION ) == (struct wmember *)NULL )
		rt_bomb( "CHEX2: mk_addmember failed\n" );

	/* subtract any holes for this component */
	Subtract_holes( &head , comp_id , group_id );

	/* process any component splitting */
	Compsplt( &head, comp_id, group_id );

	MK_REGION( fdout , &head , group_id , comp_id , element_id , CHEX1 )

	if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in Do_hex2\n" );
d3068 1
a3068 1
		bu_log( "%s is not a combination!!!!\n", dp->d_namep );
d3221 1
a3221 13
#define	TPUSH( ptr )	bu_ptbl_ins( &tstack , (long *)ptr )
#define TPOP( ptr )	{ if( BU_PTBL_END( &tstack ) == 0 ) \
				ptr = (union tree *)NULL; \
			  else \
			  { \
			  	ptr = (union tree *)BU_PTBL_GET( &tstack , BU_PTBL_END( &tstack )-1 ); \
			  	bu_ptbl_rm( &tstack , (long *)ptr ); \
			  } \
			}
union tree *
expand_tree( ptr, dbip )
union tree *ptr;
struct db_i *dbip;
d3223 11
a3233 5
	struct directory *dp;
	struct rt_db_internal internal;
	struct rt_comb_internal *comb;
	union tree *tr_ptr, *new_tree;
	int saw_a_union, used_node;
d3235 1
a3235 1
	RT_CK_TREE( ptr );
d3237 4
a3240 1
	switch( ptr->tr_op )
d3242 8
a3249 7
		case OP_DB_LEAF:
			if( (dp=db_lookup( dbip, ptr->tr_l.tl_name, LOOKUP_QUIET)) == DIR_NULL )
			{
				db_free_tree( ptr , &rt_uniresource);
				ptr = TREE_NULL;
				return( TREE_NULL );
			}
d3251 11
a3261 5
			if( !(dp->d_flags & DIR_REGION) )
				return( ptr );

			/* this is a region */
			if( rt_db_get_internal( &internal, dp, dbip, NULL, &rt_uniresource ) < 0 )
d3263 2
a3264 2
				bu_log( "Failed to get internal representation of %s\n", dp->d_namep );
				bu_bomb( "rt_db_get_internal() Failed!!!\n");
d3266 3
d3270 1
a3270 1
			if( internal.idb_type != ID_COMBINATION )
d3272 2
a3273 2
				bu_log( "%s is not a combination!!!!\n", dp->d_namep );
				bu_bomb( "Expecting a combination!!!!\n" );
d3276 2
a3277 7
			comb = (struct rt_comb_internal *)internal.idb_ptr;
			if( !comb->region_flag )
			{
				bu_log( "%s is not a region!!!!\n", dp->d_namep );
				bu_bomb( "Expecting a region!!!!\n" );
			}
			RT_CK_COMB( comb );
d3279 4
a3282 15
			new_tree = ptr;
			tr_ptr = comb->tree;
			saw_a_union = 1;
			used_node = 0;
			while( 1 )
			{
				while( tr_ptr )
				{
					TPUSH( tr_ptr );
					if( tr_ptr->tr_op != OP_DB_LEAF )
						tr_ptr = tr_ptr->tr_b.tb_left;
					else
						tr_ptr = (union tree *)NULL;
				}
				TPOP( tr_ptr );
d3284 8
a3291 2
				if( !tr_ptr )
					break;
d3293 7
a3299 27
				/* visit node */
				if( tr_ptr->tr_op == OP_DB_LEAF )
				{
					if( saw_a_union )
					{
						saw_a_union = 0;
						if( !used_node )
						{
							ptr->tr_l.tl_name = bu_strdup( tr_ptr->tr_l.tl_name );
							used_node = 1;
						}
						else
						{
							BU_GETUNION( new_tree, tree );
							new_tree->tr_b.magic = RT_TREE_MAGIC;
							new_tree->tr_b.tb_op = OP_SUBTRACT;
							new_tree->tr_b.tb_left = ptr;
							BU_GETUNION( new_tree->tr_b.tb_right, tree );
							new_tree->tr_b.tb_right->tr_l.magic = RT_TREE_MAGIC;
							new_tree->tr_b.tb_right->tr_l.tl_op = OP_DB_LEAF;
							new_tree->tr_b.tb_right->tr_l.tl_name = bu_strdup( tr_ptr->tr_l.tl_name );
							ptr = new_tree;
						}
					}
				}
				else if( tr_ptr->tr_op == OP_UNION )
					saw_a_union = 1;
d3301 3
a3303 6
				if( tr_ptr->tr_op != OP_DB_LEAF )
					tr_ptr = tr_ptr->tr_b.tb_right;
				else
					tr_ptr = (union tree *)NULL;
			}
			return( ptr );
d3305 2
a3306 24
			break;
		default:
			/* recurse */
			ptr->tr_b.tb_left = expand_tree( ptr->tr_b.tb_left, dbip );
			ptr->tr_b.tb_right = expand_tree( ptr->tr_b.tb_right, dbip );
			if( (ptr->tr_b.tb_left == TREE_NULL) && (ptr->tr_b.tb_right == TREE_NULL) )
			{
				ptr->tr_op = 0;
				bu_free( (char *)ptr, "union tree" );
				ptr = TREE_NULL;
			}
			else if( ptr->tr_b.tb_right == TREE_NULL )
			{
				if( ptr->tr_op == OP_INTERSECT )
				{
					/* intersection with nothing is nothing */
					db_free_tree( ptr->tr_b.tb_left , &rt_uniresource);
					ptr->tr_op = 0;
					bu_free( (char *)ptr, "union tree" );
					ptr = TREE_NULL;
				}
				else
				{
					union tree *save;
d3308 3
a3310 12
					/* just return the left tree */
					save = ptr->tr_b.tb_left;
					ptr->tr_op = 0;
					bu_free( (char *)ptr, "union tree" );
					ptr = save;
				}
			}
			else if( ptr->tr_b.tb_left == TREE_NULL )
			{
				if( ptr->tr_op == OP_UNION )
				{
					union tree *save;
d3312 4
a3315 19
					/* return the right tree */
					save = ptr->tr_b.tb_right;
					ptr->tr_op = 0;
					bu_free( (char *)ptr, "union tree" );
					ptr = save;
				}
				else
				{
					/* result is nothing */
					db_free_tree( ptr->tr_b.tb_right , &rt_uniresource);
					ptr->tr_op = 0;
					bu_free( (char *)ptr, "union tree" );
					ptr = TREE_NULL;
				}
			}
			return( ptr );
			break;
	}
}
d3317 4
a3320 8
void
do_expansion( dbip, name )
struct db_i *dbip;
char *name;
{
	struct directory *dp;
	struct rt_db_internal internal;
	struct rt_comb_internal *comb;
d3322 2
a3323 2
	if( (dp=db_lookup( dbip, name, LOOKUP_QUIET)) == DIR_NULL )
		return;
d3325 8
a3332 2
	if( !(dp->d_flags & DIR_REGION) )
		return;
d3334 4
a3337 6
	/* this is a region */
	if( rt_db_get_internal( &internal, dp, dbip, NULL, &rt_uniresource ) < 0 )
	{
		bu_log( "Failed to get internal representation of %s\n", dp->d_namep );
		bu_bomb( "rt_db_get_internal() Failed!!!\n" );
	}
d3339 2
a3340 5
	if( internal.idb_type != ID_COMBINATION )
	{
		bu_log( "%s is not a combination!!!!\n", dp->d_namep );
		bu_bomb( "Expecting a combination!!!!\n" );
	}
d3342 15
a3356 2
	comb = (struct rt_comb_internal *)internal.idb_ptr;
	RT_CK_COMB( comb );
d3358 11
a3368 4
	if( !comb->region_flag )
	{
		bu_log( "%s is not a region!!!!\n", dp->d_namep );
		bu_bomb( "Expecting a region!!!!\n" );
d3371 1
a3371 3
	comb->tree = expand_tree( comb->tree, dbip );

	if( rt_db_put_internal( dp, dbip, &internal, &rt_uniresource ) < 0 )
d3373 3
a3375 2
		bu_log( "Failed to write region %s\n", dp->d_namep );
		bu_bomb( "rt_db_put_internal() failed!!!\n" );
a3378 43
void
expand_subtracted_regions( output_file )
char *output_file;
{
	struct name_tree *ptr;
	struct db_i *dbip;

	bu_log( "Expanding subtracted regions please wait.....\n" );

	if ((dbip = db_open( output_file , "rw")) == DBI_NULL)
	{
		bu_log( "Cannot open %s, post processing not completed\n", output_file );
		return;
	}
	dbip->dbi_version = 4;

	if( debug )
		bu_log( "Rescanning file\n" );

	db_dirbuild( dbip );

	bu_ptbl_reset( &stack );

	ptr = name_root;
	while( 1 )
	{
		while( ptr )
		{
			PUSH( ptr );
			ptr = ptr->rleft;
		}
		POP( name_tree , ptr );
		if( !ptr )
			break;

		/* visit node */
		do_expansion( dbip, ptr->name );

		ptr = ptr->rright;
	}

}

d3490 1
d3497 3
d3504 3
d3515 3
d3520 6
a3532 4

	/* post process */
	bu_ptbl_init( &tstack , 64, " tstack ");
	expand_subtracted_regions( output_file );
@


11.63
log
@Added handling for long lines
@
text
@a2451 2449
/*
 *                      F A S T 4 - G
 *
 *  Program to convert the FASTGEN4 format to BRL-CAD.
 *
 *  Author -
 *      John R. Anderson
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1994 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */

#ifndef lint
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.52.2.1.2.1 2000/11/30 14:31:57 jra Exp $";
#endif

#include "conf.h"

#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <errno.h>

#include "machine.h"
#include "externs.h"
#include "db.h"
#include "vmath.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "wdb.h"
#include "../librt/debug.h"

#define		NAMESIZE	16	/* from db.h */

#define		LINELEN		128	/* Length of char array for input line */

#define		REGION_LIST_BLOCK	256	/* initial length of array of region ids to process */

static char	line[LINELEN+1];		/* Space for input line */
static FILE	*fdin;			/* Input FASTGEN4 file pointer */
static FILE	*fdout;			/* Output BRL-CAD file pointer */
static FILE	*fd_plot=NULL;		/* file for plot output */
static FILE	*fd_muves=NULL;		/* file for MUVES data, output CHGCOMP and CBACKING data */
static int	grid_size;		/* Number of points that will fit in current grid_pts array */
static int	max_grid_no=0;		/* Maximum grid number used */
static int	mode=0;			/* Plate mode (1) or volume mode (2) */
static int	group_id=(-1);		/* Group identification number from SECTION card */
static int	comp_id=(-1);		/* Component identification number from SECTION card */
static int	region_id=0;		/* Region id number (group id no X 1000 + component id no) */
static int	joint_no=0;		/* Count of CLINE joints (sph solids created to connect CLINES) */
static char	field[9];		/* Space for storing one field from an input line */
static char	vehicle[17];		/* Title for BRLCAD model from VEHICLE card */
static char	name_name[NAMESIZE+1];	/* Component name built from $NAME card */
static int	name_count;		/* Count of number of times this name_name has been used */
static int	pass;			/* Pass number (0 -> only make names, 1-> do geometry ) */
static int	bot=0;			/* Flag: >0 -> There are BOT's in current component */
static int	warnings=0;		/* Flag: >0 -> Print warning messages */
static int	debug=0;		/* Debug flag */
static int	rt_debug=0;		/* rt_g.debug */
static int	quiet=0;		/* flag to not blather */
static int	comp_count=0;		/* Count of components in FASTGEN4 file */
static int	do_skips=0;		/* flag indicating that not all components will be processed */
static int	*region_list;		/* array of region_ids to be processed */
static int	region_list_len=0;	/* actual length of the malloc'd region_list array */
static int	do_plot=0;		/* flag indicating plot file should be created */
static struct cline    *cline_last_ptr; /* Pointer to last element in linked list of clines */
static struct wmember  group_head[11];	/* Lists of regions for groups */
static struct wmember  hole_head;	/* List of regions used as holes (not solid parts of model) */
static struct bu_ptbl stack;		/* Stack for traversing name_tree */
static struct bu_ptbl tstack;		/* Stack for traversing union tree */

static int		*faces=NULL;	/* one triplet per face indexing three grid points */
static fastf_t		*thickness;	/* thickness of each face */
static char		*facemode;	/* mode for each face */
static int		face_size=0;	/* actual length of above arrays */
static int		face_count=0;	/* number of faces in above arrays */

static int	*int_list;		/* Array of integers */
static int	int_list_count=0;	/* Number of ints in above array */
static int	int_list_length=0;	/* Length of int_list array */
#define		INT_LIST_BLOCK	256	/* Number of int_list array slots to allocate */

static char	*usage="Usage:\n\tfast4-g [-dwq] [-c component_list] [-m muves_file] [-o plot_file] [-b BU_DEBUG_FLAG] [-x RT_DEBUG_FLAG] fastgen4_bulk_data_file output.g\n\
	d - print debugging info\n\
	q - quiet mode (don't say anyhing except error messages\n\
	w - print warnings about creating default names\n\
	c - process only the listed region ids, may be a list (3001,4082,5347) or a range (2314-3527)\n\
	m - create a MUVES input file containing CHGCOMP and CBACKING elements\n\
	o - create a 'plot_file' containing a libplot3 plot file of all CTRI and CQUAD elements processed\n\
	b - set LIBBU debug flag\n\
	x - set RT debug flag\n";

#define		PLATE_MODE	1
#define		VOLUME_MODE	2

#define		POS_CENTER	1	/* face positions for facets */
#define		POS_FRONT	2

#define		END_OPEN	1	/* End closure codes for cones */
#define		END_CLOSED	2

#define		GRID_BLOCK	256	/* allocate space for grid points in blocks of 256 points */

#define		CLINE		'l'
#define		CHEX1		'p'
#define		CHEX2		'b'
#define		CTRI		't'
#define		CQUAD		'q'
#define		CCONE1		'c'
#define		CCONE2		'd'
#define		CCONE3		'e'
#define		CSPHERE		's'
#define		NMG		'n'
#define		BOT		't'
#define		COMPSPLT	'h'

void make_region_name();
void make_solid_name();

/* convenient macro for building regions */
#define		MK_REGION( fp , headp , g_id , c_id , e_id , type ) \
			{\
				int r_id; \
				char name[NAMESIZE+1]; \
				r_id = g_id * 1000 + c_id; \
				make_region_name( name , g_id , c_id , e_id , type ); \
				if( debug ) \
					bu_log( "Making region: %s\n", name ); \
				if( mode == 1 )\
					mk_fastgen_region( fp , name , headp , 'P' ,\
						(char *)NULL, (char *)NULL, (unsigned char *)NULL, r_id, 0, 0, 0, 0 ); \
				else if( mode == 2 )\
					mk_fastgen_region( fp , name , headp , 'V' ,\
						(char *)NULL, (char *)NULL, (unsigned char *)NULL, r_id, 0, 0, 0, 0 ); \
				else\
				{\
					bu_log( "Illegal mode (%d), while trying to make region (%s)\n",\
						mode, name );\
					bu_log( "\tRegion not made!!!!!\n");\
				}\
			}

#define	PUSH( ptr )	bu_ptbl_ins( &stack , (long *)ptr )
#define POP( structure , ptr )	{ if( BU_PTBL_END( &stack ) == 0 ) \
				ptr = (struct structure *)NULL; \
			  else \
			  { \
			  	ptr = (struct structure *)BU_PTBL_GET( &stack , BU_PTBL_END( &stack )-1 ); \
			  	bu_ptbl_rm( &stack , (long *)ptr ); \
			  } \
			}

#define	NHEX_FACES	12
int hex_faces[12][3]={
	{ 0 , 1 , 4 }, /* 1 */
	{ 1 , 5 , 4 }, /* 2 */
	{ 1 , 2 , 5 }, /* 3 */
	{ 2 , 6 , 5 }, /* 4 */
	{ 2 , 3 , 6 }, /* 5 */
	{ 3 , 7 , 6 }, /* 6 */
	{ 3 , 0 , 7 }, /* 7 */
	{ 0 , 4 , 7 }, /* 8 */
	{ 4 , 6 , 7 }, /* 9 */
	{ 4 , 5 , 6 }, /* 10 */
	{ 0 , 1 , 2 }, /* 11 */
	{ 0 , 2 , 3 }  /* 12 */
};

struct cline
{
	int pt1,pt2;
	int element_id;
	int made;
	fastf_t thick;
	fastf_t radius;
	struct cline *next;
} *cline_root;

#define	NAME_TREE_MAGIC	0x55555555
#define CK_TREE_MAGIC( ptr )	\
	{\
		if( !ptr )\
			bu_log( "ERROR: Null name_tree pointer, file=%s, line=%d\n", __FILE__, __LINE__ );\
		else if( ptr->magic != NAME_TREE_MAGIC )\
			bu_log( "ERROR: bad name_tree pointer (x%x), file=%s, line=%d\n", ptr, __FILE__, __LINE__ );\
	}

struct name_tree
{
	long magic;
	int region_id;
	int element_id;		/* > 0  -> normal fastgen4 element id
				 * < 0  -> CLINE element (-pt1)
				 * == 0 -> component name */
	int in_comp_group;	/* > 0 -> region already in a component group */
	char name[NAMESIZE+1];
	struct name_tree *nleft,*nright,*rleft,*rright;
} *name_root;

struct compsplt
{
	int ident_to_split;
	int new_ident;
	fastf_t z;
	struct compsplt *next;
} *compsplt_root;

struct hole_list
{
	int group;
	int component;
	struct hole_list *next;
};

struct holes
{
	int group;
	int component;
	int type;
	struct hole_list *holes;
	struct holes *next;
} *hole_root;

#define HOLE 1
#define WALL 2

point_t *grid_pts;

int
is_a_hole( id )
int id;
{
	struct holes *hole_ptr;
	struct hole_list *ptr;

	hole_ptr = hole_root;

	while( hole_ptr )
	{
		if( hole_ptr->type == HOLE )
		{
			ptr = hole_ptr->holes;
			while( ptr )
			{
				if( (ptr->group * 1000 + ptr->component) == id )
					return( 1 );
				ptr = ptr->next;
			}
		}
		hole_ptr = hole_ptr->next;
	}
	return( 0 );
}

void
add_to_holes( name, reg_id )
char *name;
int reg_id;
{
	if( mk_addmember( name , &hole_head , WMOP_UNION ) == (struct wmember *)NULL )
		bu_log( "add_to_holes: mk_addmember failed for region %s\n" , name );
}

void
plot_tri( pt1, pt2, pt3 )
int pt1, pt2, pt3;
{
	pdv_3move( fd_plot, grid_pts[pt1] );
	pdv_3cont( fd_plot, grid_pts[pt2] );
	pdv_3cont( fd_plot, grid_pts[pt3] );
	pdv_3cont( fd_plot, grid_pts[pt1] );
}

void
Check_names()
{
	struct name_tree *ptr;

	if( !name_root )
		return;

	bu_ptbl_reset( &stack );

	CK_TREE_MAGIC( name_root )
	/* ident order */
	ptr = name_root;
	while( 1 )
	{
		while( ptr )
		{
			PUSH( ptr );
			ptr = ptr->rleft;
		}
		POP( name_tree , ptr );
		if( !ptr )
			break;

		/* visit node */
		CK_TREE_MAGIC( ptr )
		ptr = ptr->rright;
	}

	/* alpabetical order */
	ptr = name_root;
	while( 1 )
	{
		while( ptr )
		{
			PUSH( ptr );
			ptr = ptr->nleft;
		}
		POP( name_tree , ptr );
		if( !ptr )
			break;

		/* visit node */
		CK_TREE_MAGIC( ptr )
		ptr = ptr->nright;
	}
}

void
insert_int( in )
int in;
{
	int i;

	for( i=0 ; i<int_list_count ; i++ )
	{
		if( int_list[i] == in )
			return;
	}

	if( int_list_count == int_list_length )
	{
		if( int_list_length == 0 )
			int_list = (int *)bu_malloc( INT_LIST_BLOCK*sizeof( int ) , "insert_id: int_list" );
		else
			int_list = (int *)bu_realloc( (char *)int_list , (int_list_length + INT_LIST_BLOCK)*sizeof( int ) , "insert_id: int_list" );
		int_list_length += INT_LIST_BLOCK;
	}

	int_list[int_list_count] = in;
	int_list_count++;

	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in insert_int\n" );
}

void
Subtract_holes( head , comp_id , group_id )
struct wmember *head;
int comp_id;
int group_id;
{
	struct holes *hole_ptr;
	struct hole_list *list_ptr;

	if( debug )
		bu_log( "Subtract_holes( comp_id=%d, group_id=%d )\n" , comp_id , group_id );

	hole_ptr = hole_root;
	while( hole_ptr )
	{
		if( hole_ptr->group == group_id && hole_ptr->component == comp_id )
		{
			list_ptr = hole_ptr->holes;
			while( list_ptr )
			{
				struct name_tree *ptr;
				int reg_id;

				reg_id = list_ptr->group * 1000 + list_ptr->component;
				ptr = name_root;
				while( ptr && ptr->region_id != reg_id )
				{
					int diff;

					diff = reg_id - ptr->region_id;
					if( diff > 0 )
						ptr = ptr->rright;
					else if( diff < 0 )
						ptr = ptr->rleft;
				}

				if( !ptr || ptr->region_id != reg_id )
				{
					bu_log( "WARNING: Can't find a hole/wall to subtract for group %d, component %d\n" , group_id , comp_id );
					bu_log( "         Missing group #%d component #%d\n",
						list_ptr->group, list_ptr->component );
				}
				else
				{

					bu_ptbl_reset( &stack );

					while( ptr && ptr->region_id == reg_id )
					{
						while( ptr && ptr->region_id == reg_id )
						{
							PUSH( ptr );
							ptr = ptr->rleft;
						}
						POP( name_tree , ptr );
						if( !ptr ||  ptr->region_id != reg_id )
							break;

						if( mk_addmember( ptr->name , head , WMOP_SUBTRACT ) == (struct wmember *)NULL )
							rt_bomb( "Subtract_holes: mk_addmember failed\n" );

						ptr = ptr->rright;
					}
				}

				list_ptr = list_ptr->next;
			}
			break;
		}
		hole_ptr = hole_ptr->next;
	}
	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in subtract_holes\n" );
}

void
Compsplt( headp, comp_id, group_id )
struct wmember *headp;
int comp_id, group_id;
{
	int ident;
	struct compsplt *splt;
	struct wmember spl_head;
	struct wmember *m1, *m2;
	vect_t norm;
	char name[NAMESIZE+1];
	int found_union;

	ident = group_id * 1000 + comp_id;

	splt = compsplt_root;

	while( splt )
	{
		if( splt->ident_to_split == ident )
		{
			/* make a halfspace */
			VSET( norm, 0.0, 0.0, 1.0 );
			make_solid_name( name, COMPSPLT, 0, comp_id, group_id, 0 );
			mk_half( fdout, name, norm, splt->z );

			BU_LIST_INIT( &spl_head.l );

			/* Go through member list simultaneoulsy copying the list
			 * and adding references to the halfspace
			 */
			m1 = BU_LIST_FIRST( wmember, &headp->l );
			if( m1->wm_op == UNION )
				found_union = -1;
			else
				found_union = 0;
			while( BU_LIST_NOT_HEAD( &m1->l, &headp->l ) )
			{
				if( m1->wm_op == UNION )
					found_union++;
				if( found_union > 0 )
				{
					/* time to subtract the halfspace from the new region */
					(void)mk_addmember( name, &spl_head, WMOP_SUBTRACT );

					/* and intersect it with the old one */
					/* start by adding the new membwe to the end of the list */
					m2 = mk_addmember( name, headp, WMOP_INTERSECT );

					/* now get it out of the list */
					BU_LIST_DEQUEUE( &m2->l );

					/* and put it back in where I want it */
					BU_LIST_INSERT( &m1->l, &m2->l );

					found_union = 0;
				}

				/* copy this member to the new list */
				switch( m1->wm_op )
				{
					case UNION:
						(void)mk_addmember( m1->wm_name, &spl_head, WMOP_UNION );
						break;
					case INTERSECT:
						(void)mk_addmember( m1->wm_name, &spl_head, WMOP_INTERSECT );
						break;
					case SUBTRACT:
						(void)mk_addmember( m1->wm_name, &spl_head, WMOP_SUBTRACT );
						break;
				}
				m1 = BU_LIST_NEXT( wmember, &m1->l );
			}

			(void)mk_addmember( name, &spl_head, WMOP_SUBTRACT );
			(void)mk_addmember( name, headp, WMOP_INTERSECT );

			MK_REGION( fdout, &spl_head, splt->new_ident/1000, splt->new_ident%1000, 0, COMPSPLT )

			return;
		}
		splt = splt->next;
	}
}

void
do_compsplt()
{
	int gr, co, gr1,  co1;
	fastf_t z;
	struct compsplt *splt;

	strncpy( field, &line[8], 8 );
	gr = atoi( field );

	strncpy( field, &line[16], 8 );
	co = atoi( field );

	strncpy( field, &line[24], 8 );
	gr1 = atoi( field );

	strncpy( field, &line[32], 8 );
	co1 = atoi( field );

	strncpy( field, &line[40], 8 );
	z = atof( field ) * 25.4;

	if( compsplt_root == NULL )
	{
		compsplt_root = (struct compsplt *)bu_calloc( 1, sizeof( struct compsplt ), "compsplt_root" );
		splt = compsplt_root;
	}
	else
	{
		splt = compsplt_root;
		while( splt->next )
			splt = splt->next;
		splt->next = (struct compsplt *)bu_calloc( 1, sizeof( struct compsplt ), "compsplt_root" );
		splt = splt->next;
	}
	splt->next = (struct compsplt *)NULL;
	splt->ident_to_split = gr * 1000 + co;
	splt->new_ident = gr1 * 1000 + co1;
	splt->z = z;
}

void
List_holes()
{
	struct holes *hole_ptr;
	struct hole_list *list_ptr;

	hole_ptr = hole_root;

	while( hole_ptr )
	{
		bu_log( "Holes for Group %d, Component %d:\n" , hole_ptr->group, hole_ptr->component );
		list_ptr = hole_ptr->holes;
		while( list_ptr )
		{
			bu_log( "\tgroup %d component %d\n" , list_ptr->group, list_ptr->component );
			list_ptr = list_ptr->next;
		}
		hole_ptr = hole_ptr->next;
	}
}

void
List_names()
{
	struct name_tree *ptr;

	bu_ptbl_reset( &stack );

	bu_log( "\nNames in ident order:\n" );
	ptr = name_root;
	while( 1 )
	{
		while( ptr )
		{
			PUSH( ptr );
			ptr = ptr->rleft;
		}
		POP( name_tree , ptr );
		if( !ptr )
			break;

		if( ptr->in_comp_group )
			bu_log( "%s %d %d (in a comp group)\n" , ptr->name , ptr->region_id , ptr->element_id );
		else
			bu_log( "%s %d %d (not in a comp group)\n" , ptr->name , ptr->region_id , ptr->element_id );
		ptr = ptr->rright;
	}

	bu_log( "\tAlphabetical list of names:\n" );
	ptr = name_root;
	while( 1 )
	{
		while( ptr )
		{
			PUSH( ptr );
			ptr = ptr->nleft;
		}
		POP( name_tree , ptr );
		if( !ptr )
			break;

		bu_log( "%s\n" , ptr->name );
		ptr = ptr->nright;
	}
}

struct name_tree *
Search_names( root , name , found )
struct name_tree *root;
char *name;
int *found;
{
	struct name_tree *ptr;

	*found = 0;

	ptr = root;
	if( !ptr )
		return( (struct name_tree *)NULL );

	while( 1 )
	{
		int diff;

		diff = strcmp( name , ptr->name );
		if( diff == 0 )
		{
			*found = 1;
			return( ptr );
		}
		else if( diff > 0 )
		{
			if( ptr->nright )
				ptr = ptr->nright;
			else
				return( ptr );
		}
		else if( diff < 0 )
		{
			if( ptr->nleft )
				ptr = ptr->nleft;
			else
				return( ptr );
		}
	}
}

char *
find_nmg_region_name( g_id, c_id )
int g_id;
int c_id;
{
	int reg_id;
	struct name_tree *ptr;

	reg_id = g_id*1000 + c_id;

	ptr = name_root;
	if( !ptr )
		return( (char *)NULL );

	while( 1 )
	{
		int diff;

		diff = reg_id - ptr->region_id;
		if( diff == 0 )
		{
			int len;

			len = strlen( ptr->name );
			if( !strcmp( &ptr->name[len-4] , ".n.r" ) )
				return( ptr->name );
			else
			{
				if( ptr->rright )
					ptr = ptr->rright;
				else
					return( (char *)NULL );
			}
		}
		else if( diff > 0 )
		{
			if( ptr->rright )
				ptr = ptr->rright;
			else
				return( (char *)NULL );
		}
		else if( diff < 0 )
		{
			if( ptr->rleft )
				ptr = ptr->rleft;
			else
				return( (char *)NULL );
		}
	}
}

struct name_tree *
Search_ident( root , reg_id , el_id , found )
struct name_tree *root;
int reg_id;
int el_id;
int *found;
{
	struct name_tree *ptr;

	*found = 0;

	ptr = root;
	if( !ptr )
		return( (struct name_tree *)NULL );

	while( 1 )
	{
		int diff;

		diff = reg_id -  ptr->region_id;
		if( diff == 0 )
			diff = el_id - ptr->element_id;

		if( diff == 0 )
		{
			*found = 1;
			return( ptr );
		}
		else if( diff > 0 )
		{
			if( ptr->rright )
				ptr = ptr->rright;
			else
				return( ptr );
		}
		else if( diff < 0 )
		{
			if( ptr->rleft )
				ptr = ptr->rleft;
			else
				return( ptr );
		}
	}
}

void
Delete_name( root , name )
struct name_tree **root;
char *name;
{
	struct name_tree *ptr,*parent,*ptr2;
	int r_id, e_id;
	int found;
	int diff;

	/* first delete from name portion of tree */
	ptr = *root;
	parent = (struct name_tree *)NULL;
	found = 0;

	while( 1 )
	{
		diff = strcmp( name , ptr->name );
		if( diff == 0 )
		{
			found = 1;
			break;
		}
		else if( diff > 0 )
		{
			if( ptr->nright )
			{
				parent = ptr;
				ptr = ptr->nright;
			}
			else
				break;
		}
		else if( diff < 0 )
		{
			if( ptr->nleft )
			{
				parent = ptr;
				ptr = ptr->nleft;
			}
			else
				break;
		}
	}

	if( !found )
		return;

	r_id = ptr->region_id;
	e_id = ptr->element_id;

	if( parent == (struct name_tree *)NULL )
	{
		if( ptr->nright )
		{
			*root = ptr->nright;
			ptr2 = *root;
			while( ptr2->nleft )
				ptr2 = ptr2->nleft;
			ptr2->nleft = ptr->nleft;

			ptr2 = *root;
			while( ptr2->rleft )
				ptr2 = ptr2->rleft;
			ptr2->rleft = ptr->rleft;
		}
		else if( ptr->nleft )
		{
			*root = ptr->nleft;
			ptr2 = *root;
			while( ptr2->nright )
				ptr2 = ptr2->nright;
			ptr2->nright = ptr->nright;
			ptr2 = *root;
			while( ptr2->rright )
				ptr2 = ptr2->rright;
			ptr2->rright = ptr->rright;
		}
		else
		{
			/* This was the only name in the tree */
			*root = (struct name_tree *)NULL;
		}
		bu_free( (char *)ptr , "Delete_name: ptr" );
		if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
			bu_log( "ERROR: bu_mem_barriercheck failed in Delete_name\n" );
		return;
	}
	else
	{
		if( parent->nright == ptr )
		{
			if( ptr->nleft )
			{
				parent->nright = ptr->nleft;
				ptr2 = ptr->nleft;
				while( ptr2->nright )
					ptr2 = ptr2->nright;
				ptr2->nright = ptr->nright;
			}
			else
				parent->nright = ptr->nright;
		}
		else if( parent->nleft == ptr )
		{
			if( ptr->nright )
			{
				parent->nleft = ptr->nright;
				ptr2 = ptr->nright;
				while( ptr2->nleft )
					ptr2 = ptr2->nleft;
				ptr2->nleft = ptr->nleft;
			}
			else
				parent->nleft = ptr->nleft;
		}
	}


	/* now delete from ident prtion of tree */
	ptr = *root;
	parent = (struct name_tree *)NULL;
	found = 0;

	while( 1 )
	{
		diff = r_id - ptr->region_id;
		if( diff == 0 )
			diff = e_id - ptr->element_id;

		if( diff == 0 )
		{
			found = 1;
			break;
		}
		else if( diff > 0 )
		{
			if( ptr->rright )
			{
				parent = ptr;
				ptr = ptr->rright;
			}
			else
				break;
		}
		else if( diff < 0 )
		{
			if( ptr->rleft )
			{
				parent = ptr;
				ptr = ptr->rleft;
			}
			else
				break;
		}
	}

	if( !found )
	{
		bu_log( "name (%s) deleted from name tree, but not found in ident tree!!\n" , name );
		rt_bomb( "Delete_name\n" );
	}

	if( !parent )
	{
		bu_log( "name (%s) is root of ident tree, but not name tree!!\n" , name );
		rt_bomb( "Delete_name\n" );
	}


	if( parent->rright == ptr )
	{
		if( ptr->rleft )
		{
			parent->rright = ptr->rleft;
			ptr2 = ptr->rleft;
			while( ptr2->rright )
				ptr2 = ptr2->rright;
			ptr2->rright = ptr->rright;
		}
		else
			parent->rright = ptr->rright;
	}
	else if( parent->rleft == ptr )
	{
		if( ptr->rright )
		{
			parent->rleft = ptr->rright;
			ptr2 = ptr->rright;
			while( ptr2->rleft )
				ptr2 = ptr2->rleft;
			ptr2->rleft = ptr->rleft;
		}
		else
			parent->rleft = ptr->rleft;
	}
	bu_free( (char *)ptr , "Delete_name: ptr" );
	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in Delete_name\n" );
	Check_names();
}

void
Insert_name( root , name )
struct name_tree **root;
char *name;
{
	struct name_tree *ptr;
	struct name_tree *new_ptr;
	int found;
	int diff;

	ptr = Search_names( *root , name , &found );

	if( found )
	{
		bu_log( "Insert_name: %s already in name tree\n" , name );
		return;
	}

	new_ptr = (struct name_tree *)bu_malloc( sizeof( struct name_tree ) , "Insert_name: new_ptr" );

	strncpy( new_ptr->name , name , NAMESIZE+1 );
	new_ptr->nleft = (struct name_tree *)NULL;
	new_ptr->nright = (struct name_tree *)NULL;
	new_ptr->rleft = (struct name_tree *)NULL;
	new_ptr->rright = (struct name_tree *)NULL;
	new_ptr->region_id = (-region_id);
	new_ptr->in_comp_group = 0;
	new_ptr->element_id = 0;
	new_ptr->magic = NAME_TREE_MAGIC;

	if( !*root )
	{
		*root = new_ptr;
		return;
	}

	diff = strncmp( name , ptr->name , NAMESIZE );
	if( diff > 0 )
	{
		if( ptr->nright )
		{
			bu_log( "Insert_name: ptr->nright not null\n" );
			rt_bomb( "\tCannot insert new node\n" );
		}
		ptr->nright = new_ptr;
	}
	else
	{
		if( ptr->nleft )
		{
			bu_log( "Insert_name: ptr->nleft not null\n" );
			rt_bomb( "\tCannot insert new node\n" );
		}
		ptr->nleft = new_ptr;
	}
	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in Insert_name\n" );
}

void
Insert_region_name( name , reg_id , el_id )
char *name;
int reg_id;
int el_id;
{
	struct name_tree *nptr_model,*rptr_model;
	struct name_tree *new_ptr;
	int foundn,foundr;
	int diff;

	if( debug )
		bu_log( "Insert_region_name( name=%s, reg_id=%d, el_id=%d\n" , name, reg_id, el_id );

	rptr_model = Search_ident( name_root , reg_id , el_id , &foundr );
	nptr_model = Search_names( name_root , name , &foundn );

	if( foundn && foundr )
		return;

	if( foundn != foundr )
	{
		bu_log( "Insert_region_name: name %s ident %d element %d\n\tfound name is %d\n\tfound ident is %d\n",
			name, reg_id, el_id, foundn, foundr );
		List_names();
		rt_bomb( "\tCannot insert new node\n" );
	}

	/* Add to tree for entire model */
	new_ptr = (struct name_tree *)bu_malloc( sizeof( struct name_tree ) , "Insert_region_name: new_ptr" );
	new_ptr->rleft = (struct name_tree *)NULL;
	new_ptr->rright = (struct name_tree *)NULL;
	new_ptr->nleft = (struct name_tree *)NULL;
	new_ptr->nright = (struct name_tree *)NULL;
	new_ptr->region_id = reg_id;
	new_ptr->element_id = el_id;
	new_ptr->in_comp_group = 0;
	strncpy( new_ptr->name , name , NAMESIZE+1 );
	new_ptr->magic = NAME_TREE_MAGIC;

	if( !name_root )
		name_root = new_ptr;
	else
	{
		diff = strncmp( name , nptr_model->name , NAMESIZE );

		if( diff > 0 )
		{
			if( nptr_model->nright )
			{
				bu_log( "Insert_region_name: nptr_model->nright not null\n" );
				rt_bomb( "\tCannot insert new node\n" );
			}
			nptr_model->nright = new_ptr;
		}
		else
		{
			if( nptr_model->nleft )
			{
				bu_log( "Insert_region_name: nptr_model->nleft not null\n" );
				rt_bomb( "\tCannot insert new node\n" );
			}
			nptr_model->nleft = new_ptr;
		}


		diff = reg_id - rptr_model->region_id;

		if( diff == 0 )
			diff = el_id - rptr_model->element_id;

		if( diff > 0 )
		{
			if( rptr_model->rright )
			{
				bu_log( "Insert_region_name: rptr_model->rright not null\n" );
				rt_bomb( "\tCannot insert new node\n" );
			}
			rptr_model->rright = new_ptr;
		}
		else
		{
			if( rptr_model->rleft )
			{
				bu_log( "Insert_region_name: rptr_model->rleft not null\n" );
				rt_bomb( "\tCannot insert new node\n" );
			}
			rptr_model->rleft = new_ptr;
		}
	}
	Check_names();
	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in Insert_region_name\n" );
}

char *
find_region_name( g_id , c_id , el_id )
int g_id;
int c_id;
int el_id;
{
	struct name_tree *ptr;
	int reg_id;
	int found;

	reg_id = g_id * 1000 + c_id;

	if( debug )
		bu_log( "find_region_name( g_id=%d, c_id=%d, el_id=%d ), reg_id=%d\n" , g_id, c_id, el_id, reg_id );

	ptr = Search_ident( name_root , reg_id , el_id , &found );

	if( found )
		return( ptr->name );
	else
		return( (char *)NULL );
}

void
make_unique_name( name )
char *name;
{
	char append[10];
	int append_len;
	int len;
	int found;

	/* make a unique name from what we got off the $NAME card */

	len = strlen( name );

	(void)Search_names( name_root , name , &found );
	while( found )
	{
		sprintf( append , "_%d" , name_count );
		name_count++;
		append_len = strlen( append );

		if( len + append_len < NAMESIZE )
			strcat( name , append );
		else
		{
			strcpy( &name[NAMESIZE-append_len] , append );
			name[NAMESIZE] = '\0';
		}

		(void)Search_names( name_root , name , &found );
	}
	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in make_unique_name\n" );
}

void
add_to_series( name , reg_id )
char *name;
int reg_id;
{
	if( group_id < 0 || group_id > 10 )
	{
		bu_log( "add_to_series: region (%s) not added, illegal group number %d, region_id=$d\n" ,
			name , group_id , reg_id );
		return;
	}

	if( mk_addmember( name , &group_head[group_id] , WMOP_UNION ) == (struct wmember *)NULL )
		bu_log( "add_to_series: mk_addmember failed for region %s\n" , name );
}

void
make_comp_group()
{
	struct wmember g_head;
	struct name_tree *ptr;
	char name[NAMESIZE+1];

	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in make_comp_group\n" );

	BU_LIST_INIT( &g_head.l );

	bu_ptbl_reset( &stack );

	ptr = name_root;
	while( 1 )
	{
		while( ptr )
		{
			PUSH( ptr );
			ptr = ptr->nleft;
		}
		POP( name_tree , ptr );
		if( !ptr )
			break;

		if(ptr->region_id == region_id && ptr->element_id && !ptr->in_comp_group )
		{
			if( mk_addmember( ptr->name , &g_head , WMOP_UNION ) == (struct wmember *)NULL )
			{
				bu_log( "make_comp_group: Could not add %s to group for ident %d\n" , ptr->name , ptr->region_id );
				break;
			}
			ptr->in_comp_group = 1;
		}
		ptr = ptr->nright;
	}

	if( BU_LIST_NON_EMPTY( &g_head.l ) )
	{
		char *tmp_name;

		if( (tmp_name=find_region_name( group_id , comp_id , 0 )) )
			strcpy( name , tmp_name );
		else
		{
			sprintf( name , "comp_%d" , region_id );
			make_unique_name( name );
			if( warnings )
				bu_log( "Creating default name (%s) for group %d component %d\n",
						name , group_id , comp_id );
			Insert_name( &name_root , name );
		}

		mk_lfcomb( fdout , name , &g_head , 0 );
		if( !is_a_hole( region_id ) )
			add_to_series( name , region_id );
		else
			add_to_holes( name, region_id );
	}
}

void
Add_stragglers_to_groups()
{
	struct name_tree *ptr;

	ptr = name_root;

	while( 1 )
	{
		while( ptr )
		{
			PUSH( ptr );
			ptr = ptr->rleft;
		}
		POP( name_tree, ptr );
		if( !ptr )
			break;

		/* visit node */
		CK_TREE_MAGIC( ptr );

		if( !ptr->in_comp_group && ptr->region_id > 0 )
		{
			/* add this component to a series */
			(void)mk_addmember( ptr->name, &group_head[ptr->region_id/1000], WMOP_UNION );
			ptr->in_comp_group = 1;
		}

		ptr = ptr->rright;
	}
}

void
do_groups()
{
	int group_no;
	struct wmember head_all;

	if( debug )
		bu_log( "do_groups\n" );

	BU_LIST_INIT( &head_all.l );

	Add_stragglers_to_groups();

	for( group_no=0 ; group_no < 11 ; group_no++ )
	{
		char name[NAMESIZE+1];

		if( BU_LIST_IS_EMPTY( &group_head[group_no].l ) )
			continue;

		sprintf( name , "%dxxx_series" , group_no );
		mk_lfcomb( fdout , name , &group_head[group_no] , 0 );

		if( mk_addmember( name , &head_all , WMOP_UNION ) == (struct wmember *)NULL )
			bu_log( "do_groups: mk_addmember failed to add %s to group all\n" , name );
	}

	if( BU_LIST_NON_EMPTY( &head_all.l ) )
		mk_lfcomb( fdout , "all" , &head_all , 0 );

	if( BU_LIST_NON_EMPTY( &hole_head.l ) )
		mk_lfcomb( fdout , "holes" , &hole_head , 0 );
}

void
do_name()
{
	int i,j;
	int g_id;
	int c_id;
	int len;
	char comp_name[25];
	char tmp_name[25];

	if( pass )
		return;

	if( debug )
		bu_log( "do_name: %s\n" , line );

	strncpy( field , &line[8] , 8 );
	g_id = atoi( field );

	if( g_id != group_id )
	{
		bu_log( "$NAME card for group %d in section for group %d ignored\n" , g_id , group_id );
		bu_log( "%s\n" , line );
		return;
	}

	strncpy( field , &line[16] , 8 );
	c_id = atoi( field );

	if( c_id != comp_id )
	{
		bu_log( "$NAME card for component %d in section for component %d ignored\n" , c_id , comp_id );
		bu_log( "%s\n" , line );
		return;
	}

	strncpy( comp_name , &line[56] , 24 );

	/* eliminate trailing blanks */
	i = 26;
	while(  --i >= 0 && isspace( comp_name[i] ) )
		comp_name[i] = '\0';

	/* copy comp_name to tmp_name while replacing white space with "_" */
	i = (-1);
	j = (-1);

	/* copy */
	while( comp_name[++i] != '\0' )
	{
		if( isspace( comp_name[i] ) || comp_name[i] == '/' )
		{
			if( j == (-1) || tmp_name[j] != '_' )
				tmp_name[++j] = '_';
		}
		else
			tmp_name[++j] = comp_name[i];
	}
	tmp_name[++j] = '\0';

	len = strlen( tmp_name );
	if( len <= NAMESIZE )
		strncpy( name_name , tmp_name , NAMESIZE );
	else
		strncpy( name_name , &tmp_name[len-NAMESIZE] , NAMESIZE );
	name_name[NAMESIZE] = '\0';

	/* reserve this name for group name */
	make_unique_name( name_name );
	Insert_region_name( name_name , region_id , 0 );

	name_count = 0;
	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in do_name\n" );
}

void
make_region_name( name , g_id , c_id , element_id , type )
char *name;
int g_id;
int c_id;
int element_id;
char type;
{
	int r_id;
	char *tmp_name;

	r_id = g_id * 1000 + c_id;

	if( debug )
		bu_log( "make_region_name( g_id=%d, c_id=%d, element_id=%d, type=%c )\n" , g_id, c_id, element_id, type );

	tmp_name = find_region_name( g_id , c_id , element_id );
	if( tmp_name )
	{
		strncpy( name , tmp_name , NAMESIZE+1 );
		return;
	}

	/* create a new name */
	if( name_name[0] )
		strncpy( name , name_name , NAMESIZE+1 );
	else if( element_id < 0 && type == CLINE )
		sprintf( name , "%d.j.%d.r" , r_id , joint_no++ );
	else
		sprintf( name , "%d.%d.%c.r" , r_id , element_id , type );

	make_unique_name( name );

	Insert_region_name( name , r_id , element_id );
}

void
get_solid_name( name , type , element_id , c_id , g_id , inner )
char *name;
char type;
int element_id;
int c_id;
int g_id;
int inner;
{
	int reg_id;

	reg_id = g_id * 1000 + c_id;

	sprintf( name , "%d.%d.%c%d" , reg_id , element_id , type , inner );
}

void
make_solid_name( name , type , element_id , c_id , g_id , inner )
char *name;
char type;
int element_id;
int c_id;
int g_id;
int inner;
{
	get_solid_name( name , type , element_id , c_id , g_id , inner );

	Insert_name( &name_root , name );
}

void
do_grid()
{
	int grid_no;
	fastf_t x,y,z;

	if( !pass )	/* not doing geometry yet */
		return;

	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed at start of do_grid\n" );

	strncpy( field , &line[8] , 8 );
	grid_no = atoi( field );

	if( grid_no < 1 )
	{
		bu_log( "ERROR: grid id number = %d\n" , grid_no );
		rt_bomb( "BAD GRID ID NUMBER\n" );
	}

	strncpy( field , &line[24] , 8 );
	x = atof( field );

	strncpy( field , &line[32] , 8 );
	y = atof( field );

	strncpy( field , &line[40] , 8 );
	z = atof( field );

	while( grid_no > grid_size - 1 )
	{
		grid_size += GRID_BLOCK;
		grid_pts = (point_t *)bu_realloc( (char *)grid_pts , grid_size * sizeof( point_t ) , "fast4-g: grid_pts" );
	}

	VSET( grid_pts[grid_no] , x*25.4 , y*25.4 , z*25.4 );

	if( grid_no > max_grid_no )
		max_grid_no = grid_no;
	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed at end of do_grid\n" );
}

void
do_sphere()
{
	int element_id;
	int center_pt;
	fastf_t thick;
	fastf_t radius;
	fastf_t inner_radius;
	char name[NAMESIZE+1];
	struct wmember sphere_region;

	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );

	if( !pass )
	{
		make_region_name( name , group_id , comp_id , element_id , CSPHERE );
		return;
	}

	strncpy( field , &line[24] , 8 );
	center_pt = atoi( field );

	strncpy( field , &line[56] , 8 );
	thick = atof( field ) * 25.4;

	strncpy( field , &line[64] , 8 );
	radius = atof( field ) * 25.4;
	if( radius <= 0.0 )
	{
		bu_log( "do_sphere: illegal radius (%f), skipping sphere\n" , radius );
		bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
		return;
	}

	if( center_pt < 1 || center_pt > max_grid_no )
	{
		bu_log( "do_sphere: illegal grid number for center point %d, skipping sphere\n" , center_pt );
		bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
		return;
	}

	BU_LIST_INIT( &sphere_region.l );

	make_solid_name( name , CSPHERE , element_id , comp_id , group_id , 0 );
	mk_sph( fdout , name , grid_pts[center_pt] , radius );

	if( mk_addmember( name ,  &sphere_region , WMOP_UNION ) == (struct wmember *)NULL )
	{
		bu_log( "do_sphere: Error in adding %s to sphere region\n" , name );
		rt_bomb( "do_sphere" );
	}

	if( mode == PLATE_MODE )
	{
		inner_radius = radius - thick;
		if( thick > 0.0 && inner_radius <= 0.0 )
		{
			bu_log( "do_sphere: illegal thickness (%f), skipping inner sphere\n" , thick );
			bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
			return;
		}

		make_solid_name( name , CSPHERE , element_id , comp_id , group_id , 1 );
		mk_sph( fdout , name , grid_pts[center_pt] , inner_radius );

		if( mk_addmember( name , &sphere_region , WMOP_SUBTRACT ) == (struct wmember *)NULL )
		{
			bu_log( "do_sphere: Error in subtracting %s from sphere region\n" , name );
			rt_bomb( "do_sphere" );
		}
	}

	/* subtract any holes for this component */
	Subtract_holes( &sphere_region , comp_id , group_id );

	/* process any component splitting */
	Compsplt( &sphere_region, comp_id, group_id );

	MK_REGION( fdout , &sphere_region , group_id , comp_id , element_id , CSPHERE )
}

void
make_nmg_name( name , r_id )
char *name;
int r_id;
{
	sprintf( name , "nmg.%d" , r_id );

	make_unique_name( name );
}

void
do_vehicle()
{
	if( pass )
		return;

	strncpy( vehicle , &line[8] , 16 );
	mk_id_units( fdout , vehicle , "in" );
}

void
do_cline()
{
	int element_id;
	int pt1,pt2;
	fastf_t thick;
	fastf_t radius;
	vect_t height;
	char name[NAMESIZE+1];
	struct wmember r_head;

	if( debug )
		bu_log( "do_cline: %s\n" , line );

	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );

	strncpy( field , &line[24] , 8 );
	pt1 = atoi( field );
	if( pass && (pt1 < 1 || pt1 > max_grid_no) )
	{
		bu_log( "Illegal grid point (%d) in CLINE, skipping\n", pt1 );
		bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
		return;
	}

	strncpy( field , &line[32] , 8 );
	pt2 = atoi( field );
	if( pass && (pt2 < 1 || pt2 > max_grid_no) )
	{
		bu_log( "Illegal grid point in CLINE (%d), skipping\n", pt2 );
		bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
		return;
	}

	if( pt1 == pt2 )
	{
		bu_log( "Ilegal grid points in CLINE ( %d and %d ), skipping\n", pt1 , pt2 );
		bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
		return;
	}

	if( !pass )
	{
		make_region_name( name , group_id , comp_id , element_id , CLINE );
		return;
	}

	strncpy( field , &line[56] , 8 );
	thick = atof( field ) * 25.4;

	strncpy( field , &line[64] , 8 );
	radius = atof( field ) * 25.4;

	VSUB2( height , grid_pts[pt2] , grid_pts[pt1] );

	make_solid_name( name , CLINE , element_id , comp_id , group_id , 0 );
	mk_cline( fdout , name , grid_pts[pt1] , height , radius, thick );

	BU_LIST_INIT( &r_head.l );
	if( mk_addmember( name , &r_head , WMOP_UNION ) == (struct wmember *)NULL )
		bu_bomb( "CLINE: mk_addmember failed\n" );

	/* subtract any holes for this component */
	Subtract_holes( &r_head , comp_id , group_id );

	/* process any component splitting */
	Compsplt( &r_head, comp_id, group_id );

	MK_REGION( fdout , &r_head , group_id , comp_id , element_id , CLINE )

}

void
do_ccone1()
{
	int element_id;
	int pt1,pt2;
	fastf_t thick;
	int c1,c2;
	int end1,end2;
	vect_t height;
	fastf_t r1,r2;
	char outer_name[NAMESIZE+1];
	char inner_name[NAMESIZE+1];
	struct wmember r_head;

	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );

	if( !pass )
	{
		make_region_name( outer_name , group_id , comp_id , element_id , CCONE1 );
		if( !getline() )
		{
			bu_log( "Unexpected EOF while reading continuation card for CCONE1\n" );
			bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
				group_id, comp_id, element_id );
			rt_bomb( "CCONE1\n" );
		}
		return;
	}

	strncpy( field , &line[24] , 8 );
	pt1 = atoi( field );

	strncpy( field , &line[32] , 8 );
	pt2 = atoi( field );

	strncpy( field , &line[56] , 8 );
	thick = atof( field ) * 25.4;

	strncpy( field , &line[64] , 8 );
	r1 = atof( field ) * 25.4;

	strncpy( field , &line[72] , 8 );
	c1 = atoi( field );

	if( !getline() )
	{
		bu_log( "Unexpected EOF while reading continuation card for CCONE1\n" );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d, c1 = %d\n",
			group_id, comp_id, element_id , c1 );
		rt_bomb( "CCONE1\n" );
	}

	strncpy( field , line , 8 );
	c2 = atoi( field );

	if( c1 != c2 )
	{
		bu_log( "WARNING: CCONE1 continuation flags disagree, %d vs %d\n" , c1 , c2 );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			group_id, comp_id, element_id );
	}

	strncpy( field , &line[8] , 8 );
	r2 = atof( field ) * 25.4;

	strncpy( field , &line[16] , 8 );
	end1 = atoi( field );

	strncpy( field , &line[24] , 8 );
	end2 = atoi( field );

	if( r1 < 0.0 || r2 < 0.0 )
	{
		bu_log( "ERROR: CCONE1 has illegal radii, %f and %f\n" , r1/25.4 , r2/25.4 );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			group_id, comp_id, element_id );
		bu_log( "\tCCONE1 solid ignored\n" );
		return;
	}

	if( mode == PLATE_MODE )
	{
		if( thick <= 0.0 )
		{
			bu_log( "ERROR: Plate mode CCONE1 has illegal thickness (%f)\n" , thick/25.4 );
			bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
				group_id, comp_id, element_id );
			bu_log( "\tCCONE1 solid ignored\n" );
			return;
		}

		if( r1-thick <= SQRT_SMALL_FASTF && r2-thick <= SQRT_SMALL_FASTF )
		{
			bu_log( "ERROR: Plate mode CCONE1 has too large thickness (%f)\n" , thick/25.4 );
			bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
				group_id, comp_id, element_id );
			bu_log( "\tCCONE1 solid ignored\n" );
			return;
		}
	}

	if( pt1 < 1 || pt1 > max_grid_no || pt2 < 1 || pt2 > max_grid_no || pt1 == pt2 )
	{
		bu_log( "ERROR: CCONE1 has illegal grid points ( %d and %d)\n" , pt1 , pt2 );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			group_id, comp_id, element_id );
		bu_log( "\tCCONE1 solid ignored\n" );
		return;
	}

	/* BRL_CAD doesn't allow zero radius, so use a very small radius */
	if( r1 < SQRT_SMALL_FASTF )
		r1 = SQRT_SMALL_FASTF;
	if( r2 < SQRT_SMALL_FASTF )
		r2 = SQRT_SMALL_FASTF;

	/* make outside TGC */
	VSUB2( height , grid_pts[pt2] , grid_pts[pt1] );
	make_solid_name( outer_name , CCONE1 , element_id , comp_id , group_id , 0 );
	mk_trc_h( fdout , outer_name , grid_pts[pt1] , height , r1 , r2 );

	BU_LIST_INIT( &r_head.l );
	if( mk_addmember( outer_name , &r_head , WMOP_UNION ) == (struct wmember *)NULL )
		rt_bomb( "CCONE1: mk_addmember failed\n" );

	if( mode == PLATE_MODE )
	{
		/* make inside TGC */

		point_t base;
		point_t top;
		vect_t inner_height;
		fastf_t inner_r1,inner_r2;
		fastf_t length;
		fastf_t sin_ang;
		fastf_t slant_len;
		fastf_t r1a,r2a;
		vect_t height_dir;

		length = MAGNITUDE( height );
		VSCALE( height_dir , height , 1.0/length );
		slant_len = sqrt( length*length + (r2 - r1)*(r2 - r1) );

		sin_ang = length/slant_len;

		if( end1 == END_OPEN )
		{
			r1a = r1;
			inner_r1 = r1 - thick/sin_ang;
			VMOVE( base , grid_pts[pt1] );
		}
		else
		{
			r1a = r1 + (r2 - r1)*thick/length;
			inner_r1 = r1a - thick/sin_ang;
			VJOIN1( base , grid_pts[pt1] , thick , height_dir );
		}

		if( inner_r1 < 0.0 )
		{
			fastf_t dist_to_new_base;

			dist_to_new_base = inner_r1 * length/(r1 - r2 );
			inner_r1 = SQRT_SMALL_FASTF;
			VJOIN1( base , base , dist_to_new_base , height_dir );
		}
		else if( inner_r1 < SQRT_SMALL_FASTF )
			inner_r1 = SQRT_SMALL_FASTF;

		if( end2 == END_OPEN )
		{
			r2a = r2;
			inner_r2 = r2 - thick/sin_ang;
			VMOVE( top , grid_pts[pt2] );
		}
		else
		{
			r2a = r2 + (r1 - r2)*thick/length;
			inner_r2 = r2a - thick/sin_ang;
			VJOIN1( top , grid_pts[pt2] , -thick , height_dir );
		}

		if( inner_r2 < 0.0 )
		{
			fastf_t dist_to_new_top;

			dist_to_new_top = inner_r2 * length/(r2 - r1 );
			inner_r2 = SQRT_SMALL_FASTF;
			VJOIN1( top , top , -dist_to_new_top , height_dir );
		}
		else if( inner_r2 < SQRT_SMALL_FASTF )
			inner_r2 = SQRT_SMALL_FASTF;

		VSUB2( inner_height , top , base );
		if( VDOT( inner_height , height ) < 0.0 )
		{
			bu_log( "ERROR: CCONE1 height (%f) too small for thickness (%f)\n" , length/25.4 , thick/25.4 );
			bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
				group_id, comp_id, element_id );
			bu_log( "\tCCONE1 inner solid ignored\n" );
		}
		else
		{
			/* make inner tgc */

			make_solid_name( inner_name , CCONE1 , element_id , comp_id , group_id , 1 );
			mk_trc_h( fdout , inner_name , base , inner_height , inner_r1 , inner_r2 );

			if( mk_addmember( inner_name , &r_head , WMOP_SUBTRACT ) == (struct wmember *)NULL )
				rt_bomb( "CCONE1: mk_addmember failed\n" );
		}
	}

	/* subtract any holes for this component */
	Subtract_holes( &r_head , comp_id , group_id );

	/* process any component splitting */
	Compsplt( &r_head, comp_id, group_id );

	MK_REGION( fdout , &r_head , group_id , comp_id , element_id , CCONE1 )
}

void
do_ccone2()
{
	int element_id;
	int pt1,pt2;
	int c1,c2;
	fastf_t ro1,ro2,ri1,ri2;
	vect_t height;
	char name[NAMESIZE+1];
	struct wmember r_head;

	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );

	if( !pass )
	{
		make_region_name( name , group_id , comp_id , element_id , CCONE2 );
		if( !getline() )
		{
			bu_log( "Unexpected EOF while reading continuation card for CCONE2\n" );
			bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
				group_id, comp_id, element_id );
			rt_bomb( "CCONE2\n" );
		}
		return;
	}

	strncpy( field , &line[24] , 8 );
	pt1 = atoi( field );

	strncpy( field , &line[32] , 8 );
	pt2 = atoi( field );

	strncpy( field , &line[64] , 8 );
	ro1 = atof( field ) * 25.4;

	strncpy( field , &line[72] , 8 );
	c1 = atoi( field );

	if( !getline() )
	{
		bu_log( "Unexpected EOF while reading continuation card for CCONE2\n" );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d, c1 = %d\n",
			group_id, comp_id, element_id , c1 );
		rt_bomb( "CCONE2\n" );
	}

	strncpy( field , line , 8 );
	c2 = atoi( field );

	if( c1 != c2 )
	{
		bu_log( "WARNING: CCONE2 continuation flags disagree, %d vs %d\n" , c1 , c2 );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			group_id, comp_id, element_id );
	}

	strncpy( field , &line[8] , 8 );
	ro2 = atof( field ) * 25.4;

	strncpy( field , &line[16] , 8 );
	ri1 = atof( field ) * 25.4;

	strncpy( field , &line[24] , 8 );
	ri2 = atof( field ) * 25.4;

	if( pt1 == pt2 )
	{
		bu_log( "ERROR: CCONE2 has same endpoints %d and %d\n", pt1, pt2 );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			group_id, comp_id, element_id );
		return;
	}

	if( ro1 < 0.0 || ro2 < 0.0 || ri1 < 0.0 || ri2 < 0.0 )
	{
		bu_log( "ERROR: CCONE2 has illegal radii %f %f %f %f\n" , ro1, ro2, ri1, ri2 );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			group_id, comp_id, element_id );
		return;
	}

	if( ro1 < SQRT_SMALL_FASTF )
		ro1 = SQRT_SMALL_FASTF;

	if( ro2 < SQRT_SMALL_FASTF )
		ro2 = SQRT_SMALL_FASTF;

	BU_LIST_INIT( &r_head.l );

	VSUB2( height , grid_pts[pt2] , grid_pts[pt1] );

	make_solid_name( name , CCONE2 , element_id , comp_id , group_id , 0 );
	mk_trc_h( fdout , name , grid_pts[pt1] , height , ro1 , ro2 );

	if( mk_addmember( name , &r_head , WMOP_UNION ) == (struct wmember *)NULL )
		rt_bomb( "mk_addmember failed!\n" );

	if( ri1 > 0.0 || ri2 > 0.0 )
	{
		if( ri1 < SQRT_SMALL_FASTF )
			ri1 = SQRT_SMALL_FASTF;

		if( ri2 < SQRT_SMALL_FASTF )
			ri2 = SQRT_SMALL_FASTF;

		make_solid_name( name , CCONE2 , element_id , comp_id , group_id , 1 );
		mk_trc_h( fdout , name , grid_pts[pt1] , height , ri1 , ri2 );

		if( mk_addmember( name , &r_head , WMOP_SUBTRACT ) == (struct wmember *)NULL )
			rt_bomb( "mk_addmember failed!\n" );
	}

	/* subtract any holes for this component */
	Subtract_holes( &r_head , comp_id , group_id );

	/* process any component splitting */
	Compsplt( &r_head, comp_id, group_id );

	MK_REGION( fdout , &r_head , group_id , comp_id , element_id , CCONE2 )
}

void
do_ccone3()
{
	int element_id;
	int pt1, pt2, pt3, pt4, i;
	char name[NAMESIZE+1];
	fastf_t ro[4], ri[4], len03, len01, len12, len23;
	vect_t diff, diff2, diff3, diff4;
	struct wmember r_head;

	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );

	if( !pass )
	{
		make_region_name( name , group_id , comp_id , element_id , CCONE3 );
		if( !getline() )
		{
			bu_log( "Unexpected EOF while reading continuation card for CCONE3\n" );
			bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
				group_id, comp_id, element_id );
			rt_bomb( "CCONE3\n" );
		}
		return;
	}

	strncpy( field , &line[24] , 8 );
	pt1 = atoi( field );

	strncpy( field , &line[32] , 8 );
	pt2 = atoi( field );

	strncpy( field , &line[40] , 8 );
	pt3 = atoi( field );

	strncpy( field , &line[48] , 8 );
	pt4 = atoi( field );

	strncpy( field, &line[72], 8 );

	if( !getline() )
	{
		bu_log( "Unexpected EOF while reading continuation card for CCONE3\n" );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d, c1 = %8.8s\n",
			group_id, comp_id, element_id , field );
		rt_bomb( "CCONE3\n" );
	}

	if( strncmp( field, line, 8 ) )
	{
		bu_log( "WARNING: CCONE3 continuation flags disagree, %8.8s vs %8.8s\n" , field , line );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			group_id, comp_id, element_id );
	}

	for( i=0 ; i<4 ; i++ )
	{
		strncpy( field, &line[8*(i+1)], 8 );
		ro[i] = atof( field ) * 25.4;
		if( ro[i] < 0.0 )
		{
			bu_log( "ERROR: CCONE3 has illegal radius %f\n", ro[i] );
			bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
				group_id, comp_id, element_id );
			return;
		}
		if( !strcmp( field, "        " ) )
			ro[i] = -1.0;
	}

	for( i=0 ; i<4 ; i++ )
	{
		strncpy( field, &line[32 + 8*(i+1)], 8 );
		ri[i] = atof( field ) * 25.4;
		if( ri[i] < 0.0 )
		{
			bu_log( "ERROR: CCONE3 has illegal radius %f\n", ri[i] );
			bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
				group_id, comp_id, element_id );
			return;
		}
		if( !strcmp( field, "        " ) )
			ri[i] = -1.0;
	}

	VSUB2( diff4, grid_pts[pt4], grid_pts[pt1] );
	VSUB2( diff3, grid_pts[pt3], grid_pts[pt1] );
	VSUB2( diff2, grid_pts[pt2], grid_pts[pt1] );

	len03 = MAGNITUDE( diff4 );
	len01 = MAGNITUDE( diff2 );
	len12 = MAGNITUDE( diff3 ) - len01;
	len23 = len03 - len01 - len12;

	for( i=0 ; i<4 ; i+=3 )
	{
		if( ro[i] ==-1.0 )
		{
			if( ri[i] == -1.0 )
			{
				bu_log( "ERROR: both inner and outer radii at g%d of a CCONE3 are undefined\n", i+1 );
				bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
					group_id, comp_id, element_id );
				return;
			}
			else
				ro[i] = ri[i];
			
		}
		else if( ri[i] == -1.0 )
			ri[i] = ro[i];
	}

	if( ro[1] == -1.0 )
	{
		if( ro[2] != -1.0 )
			ro[1] = ro[0] + (ro[2] - ro[0]) * len01 / (len01 + len12);
		else
			ro[1] = ro[0] + (ro[3] - ro[0]) * len01 / len03;
	}
	if( ro[2] == -1.0 )
	{
		if( ro[1] != -1.0 )
			ro[2] = ro[1] + (ro[3] - ro[1]) * len12 / (len12 + len23);
		else
			ro[2] = ro[0] + (ro[3] - ro[0]) * (len01 + len12) / len03;
	}
	if( ri[1] == -1.0 )
	{
		if( ri[2] != -1.0 )
			ri[1] = ri[0] + (ri[2] - ri[0]) * len01 / (len01 + len12);
		else
			ri[1] = ri[0] + (ri[3] - ri[0]) * len01 / len03;
	}
	if( ri[2] == -1.0 )
	{
		if( ri[1] != -1.0 )
			ri[2] = ri[1] + (ri[3] - ri[1]) * len12 / (len12 + len23);
		else
			ri[2] = ri[0] + (ri[3] - ri[0]) * (len01 + len12) / len03;
	}

	for( i=0 ; i<4 ; i++ )
	{
		if( ro[i] < SQRT_SMALL_FASTF )
			ro[i] = SQRT_SMALL_FASTF;
		if( ri[i] < SQRT_SMALL_FASTF )
			ri[i] = SQRT_SMALL_FASTF;
	}

	BU_LIST_INIT( &r_head.l );

	if( pt1 != pt2 )
	{
		VSUB2( diff, grid_pts[pt2], grid_pts[pt1] );

		/* make first cone */
		if( ro[0] != SQRT_SMALL_FASTF || ro[1] != SQRT_SMALL_FASTF )
		{
			make_solid_name( name, CCONE3, element_id, comp_id, group_id, 1 );
			mk_trc_h( fdout, name, grid_pts[pt1], diff, ro[0], ro[1] );
			if( mk_addmember( name , &r_head , WMOP_UNION ) == (struct wmember *)NULL )
				bu_bomb( "mk_addmember failed!\n" );

			/* and the inner cone */
			if( ri[0] != SQRT_SMALL_FASTF || ri[1] != SQRT_SMALL_FASTF )
			{
				make_solid_name( name, CCONE3, element_id, comp_id, group_id, 11 );
				mk_trc_h( fdout, name, grid_pts[pt1], diff, ri[0], ri[1] );
				if( mk_addmember( name , &r_head , WMOP_SUBTRACT ) == (struct wmember *)NULL )
					bu_bomb( "mk_addmember failed!\n" );
			}

			/* subtract any holes for this component */
			Subtract_holes( &r_head , comp_id , group_id );
		}
	}

	if( pt2 != pt3 )
	{
		VSUB2( diff, grid_pts[pt3], grid_pts[pt2] );

		/* make second cone */
		if( ro[1] != SQRT_SMALL_FASTF || ro[2] != SQRT_SMALL_FASTF )
		{
			make_solid_name( name, CCONE3, element_id, comp_id, group_id, 2 );
			mk_trc_h( fdout, name, grid_pts[pt2], diff, ro[1], ro[2] );
			if( mk_addmember( name , &r_head , WMOP_UNION ) == (struct wmember *)NULL )
				bu_bomb( "mk_addmember failed!\n" );

			/* and the inner cone */
			if( ri[1] != SQRT_SMALL_FASTF || ri[2] != SQRT_SMALL_FASTF )
			{
				make_solid_name( name, CCONE3, element_id, comp_id, group_id, 22 );
				mk_trc_h( fdout, name, grid_pts[pt2], diff, ri[1], ri[2] );
				if( mk_addmember( name , &r_head , WMOP_SUBTRACT ) == (struct wmember *)NULL )
					bu_bomb( "mk_addmember failed!\n" );
			}

			/* subtract any holes for this component */
			Subtract_holes( &r_head , comp_id , group_id );
		}
	}

	if( pt3 != pt4 )
	{
		VSUB2( diff, grid_pts[pt4], grid_pts[pt3] );

		/* make third cone */
		if( ro[2] != SQRT_SMALL_FASTF || ro[3] != SQRT_SMALL_FASTF )
		{
			make_solid_name( name, CCONE3, element_id, comp_id, group_id, 3 );
			mk_trc_h( fdout, name, grid_pts[pt3], diff, ro[2], ro[3] );
			if( mk_addmember( name , &r_head , WMOP_UNION ) == (struct wmember *)NULL )
				bu_bomb( "mk_addmember failed!\n" );

			/* and the inner cone */
			if( ri[2] != SQRT_SMALL_FASTF || ri[3] != SQRT_SMALL_FASTF )
			{
				make_solid_name( name, CCONE3, element_id, comp_id, group_id, 33 );
				mk_trc_h( fdout, name, grid_pts[pt3], diff, ri[2], ri[3] );
				if( mk_addmember( name , &r_head , WMOP_SUBTRACT ) == (struct wmember *)NULL )
					bu_bomb( "mk_addmember failed!\n" );
			}

			/* subtract any holes for this component */
			Subtract_holes( &r_head , comp_id , group_id );
		}
	}

	/* process any component splitting */
	Compsplt( &r_head, comp_id, group_id );

	MK_REGION( fdout , &r_head , group_id , comp_id , element_id , CCONE3 )
}

void
Add_holes( type, gr , comp , ptr )
int type;
int gr;
int comp;
struct hole_list *ptr;
{
	struct holes *hole_ptr, *prev;
	struct hole_list *hptr;

	if( debug )
	{
		bu_log( "Adding holes for group %d, component %d:\n", gr, comp );
		hptr = ptr;
		while( hptr )
		{
			bu_log( "\t%d %d\n", hptr->group, hptr->component );
			hptr = hptr->next;
		}
	}

	if( do_skips )
	{
		if( !skip_region(gr*1000 + comp) )
		{
			/* add holes for this region to the list of regions to process */
			hptr = ptr;
			if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
				bu_log( "ERROR: bu_mem_barriercheck failed in Add_hole\n" );
			while( hptr )
			{
				if( do_skips == region_list_len )
				{
					region_list_len += REGION_LIST_BLOCK;
					region_list = (int *)bu_realloc( (char *)region_list, region_list_len*sizeof( int ), "region_list" );
					if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
						bu_log( "ERROR: bu_mem_barriercheck failed in Add_hole (after realloc)\n" );
				}
				region_list[do_skips++] = 1000*hptr->group + hptr->component;
				if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
					bu_log( "ERROR: bu_mem_barriercheck failed in Add_hole (after adding %d\n)\n", 1000*hptr->group + hptr->component );
				hptr = hptr->next;
			}
		}
	}

	if( !hole_root )
	{
		hole_root = (struct holes *)bu_malloc( sizeof( struct holes ) , "Add_holes: hole_root" );
		hole_root->group = gr;
		hole_root->component = comp;
		hole_root->type = type;
		hole_root->holes = ptr;
		hole_root->next = (struct holes *)NULL;
		return;
	}

	hole_ptr = hole_root;
	prev = hole_root;
	while( hole_ptr )
	{
		if( hole_ptr->group == gr &&
			hole_ptr->component == comp &&
			hole_ptr->type == type )
				break;
		prev = hole_ptr;
		hole_ptr = hole_ptr->next;
	}

	if( hole_ptr && hole_ptr->group == gr && hole_ptr->component == comp && hole_ptr->type == type )
	{
		struct hole_list *list;

		if( !hole_ptr->holes )
			hole_ptr->holes = ptr;
		else
		{
			list = hole_ptr->holes;
			while( list->next )
				list = list->next;
			list->next = ptr;
		}
	}
	else
	{
		prev->next = (struct holes *)bu_malloc( sizeof( struct holes ) , "Add_holes: hole_ptr->next" );
		hole_ptr = prev->next;
		hole_ptr->group = gr;
		hole_ptr->component = comp;
		hole_ptr->type = type;
		hole_ptr->holes = ptr;
		hole_ptr->next = (struct holes *)NULL;
	}
}

void
do_hole_wall( type )
int type;
{
	struct hole_list *list_ptr;
	struct hole_list *list_start;
	int group, comp;
	int igrp, icmp;
	int s_len;
	int col;

	if( debug )
		bu_log( "do_hole_wall: %s\n" , line );

	if( pass )
		return;

	/* eliminate trailing blanks */
	s_len = strlen( line );
	while( isspace(line[--s_len] ) )
		line[s_len] = '\0';

	s_len = strlen( line );
	if( s_len > 80 )
		s_len = 80;

	strncpy( field , &line[8] , 8 );
	group = atoi( field );

	strncpy( field , &line[16] , 8 );
	comp = atoi( field );

	list_start = (struct hole_list *)NULL;
	list_ptr = (struct hole_list *)NULL;
	col = 24;
	while( col < s_len )
	{
		strncpy( field , &line[col] , 8 );
		igrp = atoi( field );

		col += 8;
		if( col >= s_len )
			break;

		strncpy( field , &line[col] , 8 );
		icmp = atoi( field );

		if( igrp >= 0 && icmp > 0 )
		{
			if( igrp == group && comp == icmp )
				bu_log( "Hole or wall card references itself (ignoring): (%s)\n", line );
			else
			{
				if( list_ptr )
				{
					list_ptr->next = (struct hole_list *)bu_malloc( sizeof( struct hole_list ) , "do_hole_wall: list_ptr" );
					list_ptr = list_ptr->next;
				}
				else
				{
					list_ptr = (struct hole_list *)bu_malloc( sizeof( struct hole_list ) , "do_hole_wall: list_ptr" );
					list_start = list_ptr;
				}
			
				list_ptr->group = igrp;
				list_ptr->component = icmp;
				list_ptr->next = (struct hole_list *)NULL;
			}
		}

		col += 8;
	}

	Add_holes( type, group , comp , list_start );
}

int
getline()
{
	int len;

	bzero( (void *)line , LINELEN );

	if( fgets( line , LINELEN , fdin ) == (char *)NULL )
		return( 0 );

	len = strlen( line );
@


11.62
log
@
compiler lint
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.61 2000/10/24 14:41:31 mike Exp $";
d2452 2458
a4909 1
	if( line[len-1] == '\n' )
@


11.61
log
@
Fixed compiler lint
Modified to use rt_bot_ prefixes on names of support routines.
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.60 2000/10/20 20:29:23 jra Exp $";
d2593 2
a2594 2
	fastf_t thick;
	int pos;
@


11.60
log
@Added resource structure pointer to calls of db_functree()
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.59 2000/09/08 05:55:41 mike Exp $";
d245 5
d2275 1
a2275 5
Add_holes( type, gr , comp , ptr )
int type;
int gr;
int comp;
struct hole_list *ptr;
d2653 1
a2653 2
skip_region( id )
int id;
d2737 1
a2737 1
	count = bot_vertex_fuse( &bot_ip );
d2739 1
a2739 1
		(void)bot_condense( &bot_ip );
d2741 1
a2741 1
	count = bot_face_fuse( &bot_ip );
@


11.59
log
@
Tree routines now need resource structure.
Added rt_init_resource() call.
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.58 2000/08/24 03:24:07 mike Exp $";
d3345 1
a3345 1
	db_functree( dbip, dp, fix_regions, 0, NULL );
@


11.58
log
@
Added plot3.h
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.57 2000/08/24 03:23:12 mike Exp $";
d3240 1
a3240 1
	if( rt_db_get_internal( &internal, dp, dbip, NULL ) < 0 )
d3263 1
a3263 1
		rt_db_free_internal( &internal );
d3272 1
a3272 1
		rt_db_free_internal( &internal );
d3276 1
a3276 1
	if( rt_db_get_internal( &internal2, dp2, dbip, NULL ) < 0 )
d3284 2
a3285 2
		rt_db_free_internal( &internal );
		rt_db_free_internal( &internal2 );
d3298 1
a3298 1
	if( rt_db_put_internal( dp, dbip, &internal ) < 0 )
d3308 1
a3308 1
	db_free_tree( tree );
d3428 1
a3428 1
				db_free_tree( ptr );
d3437 1
a3437 1
			if( rt_db_get_internal( &internal, dp, dbip, NULL ) < 0 )
d3440 1
a3440 1
				bu_bomb( "rt_db_get_internal() Failed!!!\n" );
d3527 1
a3527 1
					db_free_tree( ptr->tr_b.tb_left );
d3558 1
a3558 1
					db_free_tree( ptr->tr_b.tb_right );
d3585 1
a3585 1
	if( rt_db_get_internal( &internal, dp, dbip, NULL ) < 0 )
d3608 1
a3608 1
	if( rt_db_put_internal( dp, dbip, &internal ) < 0 )
d3714 2
@


11.57
log
@
mk_addmember
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.56 2000/07/21 12:44:34 jra Exp $";
d47 1
@


11.56
log
@Replaced db_scan() calls with db_dirbuild()
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.55 2000/07/13 19:55:21 jra Exp $";
d36 1
d145 1
a145 1
					mk_fastgen_region( fp , name , headp , 'P' ,\
d148 1
a148 1
					mk_fastgen_region( fp , name , headp , 'V' ,\
d275 1
a275 1
	if( mk_addmember( name , &hole_head , WMOP_UNION ) == (struct wmember *)NULL )
d423 1
a423 1
						if( mk_addmember( ptr->name , head , WMOP_SUBTRACT ) == (struct wmember *)NULL )
d483 1
a483 1
					(void)mk_addmember( name, &spl_head, WMOP_SUBTRACT );
d487 1
a487 1
					m2 = mk_addmember( name, headp, WMOP_INTERSECT );
d502 1
a502 1
						(void)mk_addmember( m1->wm_name, &spl_head, WMOP_UNION );
d505 1
a505 1
						(void)mk_addmember( m1->wm_name, &spl_head, WMOP_INTERSECT );
d508 1
a508 1
						(void)mk_addmember( m1->wm_name, &spl_head, WMOP_SUBTRACT );
d514 2
a515 2
			(void)mk_addmember( name, &spl_head, WMOP_SUBTRACT );
			(void)mk_addmember( name, headp, WMOP_INTERSECT );
d1194 1
a1194 1
	if( mk_addmember( name , &group_head[group_id] , WMOP_UNION ) == (struct wmember *)NULL )
d1226 1
a1226 1
			if( mk_addmember( ptr->name , &g_head , WMOP_UNION ) == (struct wmember *)NULL )
d1284 1
a1284 1
			(void)mk_addmember( ptr->name, &group_head[ptr->region_id/1000], WMOP_UNION );
d1315 1
a1315 1
		if( mk_addmember( name , &head_all , WMOP_UNION ) == (struct wmember *)NULL )
d1559 1
a1559 1
	if( mk_addmember( name ,  &sphere_region , WMOP_UNION ) == (struct wmember *)NULL )
d1578 1
a1578 1
		if( mk_addmember( name , &sphere_region , WMOP_SUBTRACT ) == (struct wmember *)NULL )
d1674 1
a1674 1
	if( mk_addmember( name , &r_head , WMOP_UNION ) == (struct wmember *)NULL )
d1810 1
a1810 1
	if( mk_addmember( outer_name , &r_head , WMOP_UNION ) == (struct wmember *)NULL )
d1896 1
a1896 1
			if( mk_addmember( inner_name , &r_head , WMOP_SUBTRACT ) == (struct wmember *)NULL )
d2005 1
a2005 1
	if( mk_addmember( name , &r_head , WMOP_UNION ) == (struct wmember *)NULL )
d2019 1
a2019 1
		if( mk_addmember( name , &r_head , WMOP_SUBTRACT ) == (struct wmember *)NULL )
d2193 1
a2193 1
			if( mk_addmember( name , &r_head , WMOP_UNION ) == (struct wmember *)NULL )
d2201 1
a2201 1
				if( mk_addmember( name , &r_head , WMOP_SUBTRACT ) == (struct wmember *)NULL )
d2219 1
a2219 1
			if( mk_addmember( name , &r_head , WMOP_UNION ) == (struct wmember *)NULL )
d2227 1
a2227 1
				if( mk_addmember( name , &r_head , WMOP_SUBTRACT ) == (struct wmember *)NULL )
d2245 1
a2245 1
			if( mk_addmember( name , &r_head , WMOP_UNION ) == (struct wmember *)NULL )
d2253 1
a2253 1
				if( mk_addmember( name , &r_head , WMOP_SUBTRACT ) == (struct wmember *)NULL )
d2758 1
a2758 1
	if( mk_addmember( name ,  &bot_region , WMOP_UNION ) == (struct wmember *)NULL )
d3043 1
a3043 1
	if( mk_addmember( name , &head , WMOP_UNION ) == (struct wmember *)NULL )
@


11.55
log
@Merged branch 11.52.2.1 into main trunk
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.54 2000/07/12 21:59:34 mike Exp $";
d3328 1
a3328 1
	db_scan(dbip, (int (*)())db_diradd, 1, NULL);
d3632 1
a3632 1
	db_scan(dbip, (int (*)())db_diradd, 1, NULL);
@


11.54
log
@
Converted to use new version of LIBWDB
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.53 2000/07/10 23:53:56 mike Exp $";
a80 1
static struct cline    *cline_last_ptr; /* Pointer to last element in linked list of clines */
d3426 3
a3428 2
				ptr->tr_l.tl_op = OP_NOP;
				return( ptr );
d3514 48
a3751 1
	cline_last_ptr = (struct cline *)NULL;
@


11.53
log
@
lint
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.52 2000/07/07 20:24:16 jra Exp $";
d56 1
a56 1
static FILE	*fdout;			/* Output BRL-CAD file pointer */
a3418 1
	int i;
a3526 1
	struct db_full_path path;
d3672 1
a3672 1
	if( (fdout=fopen( argv[optind+1] , "w" )) == (FILE *)NULL )
d3744 1
a3744 1
	fclose( fdout );
@


11.52
log
@Changed the way HOLE and WALL's are handled
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.51 2000/06/27 15:03:48 jra Exp $";
@


11.52.2.1
log
@Fixed a bug in the subtracted region expansion code
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.52 2000/07/07 20:24:16 jra Exp $";
d3428 2
a3429 3
				db_free_tree( ptr );
				ptr = TREE_NULL;
				return( TREE_NULL );
a3514 48
			if( (ptr->tr_b.tb_left == TREE_NULL) && (ptr->tr_b.tb_right == TREE_NULL) )
			{
				ptr->tr_op = 0;
				bu_free( (char *)ptr, "union tree" );
				ptr = TREE_NULL;
			}
			else if( ptr->tr_b.tb_right == TREE_NULL )
			{
				if( ptr->tr_op == OP_INTERSECT )
				{
					/* intersection with nothing is nothing */
					db_free_tree( ptr->tr_b.tb_left );
					ptr->tr_op = 0;
					bu_free( (char *)ptr, "union tree" );
					ptr = TREE_NULL;
				}
				else
				{
					union tree *save;

					/* just return the left tree */
					save = ptr->tr_b.tb_left;
					ptr->tr_op = 0;
					bu_free( (char *)ptr, "union tree" );
					ptr = save;
				}
			}
			else if( ptr->tr_b.tb_left == TREE_NULL )
			{
				if( ptr->tr_op == OP_UNION )
				{
					union tree *save;

					/* return the right tree */
					save = ptr->tr_b.tb_right;
					ptr->tr_op = 0;
					bu_free( (char *)ptr, "union tree" );
					ptr = save;
				}
				else
				{
					/* result is nothing */
					db_free_tree( ptr->tr_b.tb_right );
					ptr->tr_op = 0;
					bu_free( (char *)ptr, "union tree" );
					ptr = TREE_NULL;
				}
			}
@


11.52.2.1.2.1
log
@Added handling for long lines
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.52.2.1 2000/07/13 19:07:33 jra Exp $";
d2450 1
a2450 9
	if( line[len-1] != '\n' ) {
		/* long line skip over remainder of line */
		int c=1;

		while( c != '\n' && c != EOF )
			c = getc( fdin );
		if( c == EOF )
			return( 0 );
	} else
@


11.52.2.1.2.2
log
@Reworked region building to better handle HOLE/WALL cards
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.64 2000/12/01 13:37:19 jra Exp $";
a35 1
#include <ctype.h>
a45 1
#include "plot3.h"
d65 1
d81 1
d85 1
a85 1
static struct bu_ptbl stack2;		/* Stack for traversing name_tree */
d136 1
a136 1
#define		MK_REGION( fp , headp , name , r_id ) \
d138 5
a142 1
				if( !quiet ) \
d145 1
a145 1
					mk_fastgen_region( fp , name , &((headp)->l) , 'P' ,\
d148 1
a148 1
					mk_fastgen_region( fp , name , &((headp)->l) , 'V' ,\
a166 9
#define	PUSH2( ptr )	bu_ptbl_ins( &stack2 , (long *)ptr )
#define POP2( structure , ptr )	{ if( BU_PTBL_END( &stack2 ) == 0 ) \
				ptr = (struct structure *)NULL; \
			  else \
			  { \
			  	ptr = (struct structure *)BU_PTBL_GET( &stack2 , BU_PTBL_END( &stack2 )-1 ); \
			  	bu_ptbl_rm( &stack2 , (long *)ptr ); \
			  } \
			}
d207 3
a209 1
	int inner;		/* 0 => this is a base/group name for a FASTGEN element */
a243 5
int getline();
void Add_holes( int type, int gr, int comp, struct hole_list *ptr );
void make_bot_object();
int skip_region( int id );

d401 8
a408 1
				bu_ptbl_reset( &stack );
d410 1
a410 2
				while( ptr && ptr->region_id == reg_id )
				{
d414 8
a421 6
						PUSH( ptr );
						ptr = ptr->rleft;
					}
					POP( name_tree , ptr );
					if( !ptr ||  ptr->region_id != reg_id )
						break;
d423 2
a424 2
					if( debug )
						bu_log( "\tSubtracting %s\n", ptr->name );
d426 2
a427 4
					if( mk_addmember( ptr->name , head , WMOP_SUBTRACT ) == (struct wmember *)NULL )
						rt_bomb( "Subtract_holes: mk_addmember failed\n" );

					ptr = ptr->rright;
d441 85
d608 1
a608 1
			bu_log( "%s %d %d (in a comp group)\n" , ptr->name , ptr->region_id , ptr->inner );
d610 1
a610 1
			bu_log( "%s %d %d (not in a comp group)\n" , ptr->name , ptr->region_id , ptr->inner );
d627 1
a627 1
		bu_log( "%s %d %d\n" , ptr->name, ptr->region_id , ptr->inner );
d673 51
d725 1
a725 1
Search_ident( root , reg_id , found )
d728 1
d744 2
d775 1
a775 1
	int r_id;
d818 1
d896 2
d972 1
a972 1
Insert_name( root , name, inner )
a974 1
int inner;
d998 1
a998 1
	new_ptr->inner = inner;
d1031 1
a1031 1
Insert_region_name( name , reg_id )
d1034 1
d1042 1
a1042 1
		bu_log( "Insert_region_name( name=%s, reg_id=%d\n" , name, reg_id );
d1044 1
a1044 1
	rptr_model = Search_ident( name_root , reg_id , &foundr );
d1052 2
a1053 2
		bu_log( "Insert_region_name: name %s ident %d\n\tfound name is %d\n\tfound ident is %d\n",
			name, reg_id, foundn, foundr );
d1065 1
a1065 1
	new_ptr->inner = -1;
d1098 3
d1126 1
a1126 1
find_region_name( g_id , c_id )
d1129 1
d1138 1
a1138 1
		bu_log( "find_region_name( g_id=%d, c_id=%d ), reg_id=%d\n" , g_id, c_id, reg_id );
d1140 1
a1140 1
	ptr = Search_ident( name_root , reg_id , &found );
d1224 1
a1224 1
		if(ptr->region_id == region_id && !ptr->inner && !ptr->in_comp_group )
d1249 1
a1249 1
			Insert_name( &name_root , name, 1 );
d1281 1
a1281 1
		if( !ptr->in_comp_group && ptr->region_id > 0 && !is_a_hole( ptr->region_id ) )
d1362 1
a1362 8
	/* skip leading blanks */
	i = 56;
	while( i < 80 && isspace( line[i] ) )
		i++;
	if( i == 80 )
		return;

	strncpy( comp_name , &line[i] , 80 - i );
d1365 1
a1365 1
	i = 80 - i;
d1403 1
a1403 1
make_region_name( name , g_id , c_id )
d1407 2
d1416 1
a1416 1
		bu_log( "make_region_name( g_id=%d, c_id=%d )\n" , g_id, c_id );
d1418 1
a1418 1
	tmp_name = find_region_name( g_id , c_id );
d1428 2
d1431 1
a1431 1
		sprintf( name , "comp_%04d.r" , r_id );
d1435 1
a1435 1
	Insert_region_name( name , r_id );
d1465 1
a1465 1
	Insert_name( &name_root , name, inner );
d1521 4
a1524 1
	struct wmember sphere_group;
d1528 1
a1528 1
		make_region_name( name , group_id , comp_id );
a1531 3
	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );

d1554 1
a1554 1
	BU_LIST_INIT( &sphere_group.l );
d1556 4
a1559 1
	if( mode == VOLUME_MODE )
d1561 2
a1562 2
		make_solid_name( name , CSPHERE , element_id , comp_id , group_id , 0 );
		mk_sph( fdout , name , grid_pts[center_pt] , radius );
d1564 2
a1565 1
	else if( mode == PLATE_MODE )
a1566 11
		make_solid_name( name , CSPHERE , element_id , comp_id , group_id , 1 );
		mk_sph( fdout , name , grid_pts[center_pt] , radius );

		BU_LIST_INIT( &sphere_group.l );

		if( mk_addmember( name ,  &sphere_group , WMOP_UNION ) == (struct wmember *)NULL )
		{
			bu_log( "do_sphere: Error in adding %s to sphere group\n" , name );
			rt_bomb( "do_sphere" );
		}

d1575 1
a1575 1
		make_solid_name( name , CSPHERE , element_id , comp_id , group_id , 2 );
d1578 1
a1578 1
		if( mk_addmember( name , &sphere_group , WMOP_SUBTRACT ) == (struct wmember *)NULL )
d1583 7
d1591 11
a1601 3
		make_solid_name( name , CSPHERE , element_id , comp_id , group_id , 0 );
		mk_lcomb( fdout, name, &sphere_group, 0, NULL, NULL, NULL, 0);
	}
d1623 1
a1627 6
	if( !pass )
	{
		make_region_name( name , group_id , comp_id );
		return;
	}

d1656 6
d1672 13
a1698 1
	char name[NAMESIZE+1];
d1706 1
a1706 1
		make_region_name( outer_name , group_id , comp_id );
d1804 1
d1806 2
d1809 5
a1813 6
	if( mode == VOLUME_MODE )
	{
		make_solid_name( outer_name , CCONE1 , element_id , comp_id , group_id , 0 );
		mk_trc_h( fdout , outer_name , grid_pts[pt1] , height , r1 , r2 );
	}
	else if( mode == PLATE_MODE )
a1826 8
		/* make outside TGC */
		make_solid_name( outer_name , CCONE1 , element_id , comp_id , group_id , 1 );
		mk_trc_h( fdout , outer_name , grid_pts[pt1] , height , r1 , r2 );

		BU_LIST_INIT( &r_head.l );
		if( mk_addmember( outer_name , &r_head , WMOP_UNION ) == (struct wmember *)NULL )
			rt_bomb( "CCONE1: mk_addmember failed\n" );

d1893 1
a1893 1
			make_solid_name( inner_name , CCONE1 , element_id , comp_id , group_id , 2 );
d1899 4
d1904 2
a1905 3
		make_solid_name( name , CCONE1 , element_id , comp_id , group_id , 0 );
		mk_lcomb( fdout, name, &r_head, 0, NULL, NULL, NULL, 0);
	}
d1907 1
d1926 1
a1926 1
		make_region_name( name , group_id , comp_id );
d2002 2
a2003 9
	if( ri1 <= 0.0 && ri2 <= 0.0 )
	{
		make_solid_name( name , CCONE2 , element_id , comp_id , group_id , 0 );
		mk_trc_h( fdout , name , grid_pts[pt1] , height , ro1 , ro2 );
	}
	else
	{
		make_solid_name( name , CCONE2 , element_id , comp_id , group_id , 1 );
		mk_trc_h( fdout , name , grid_pts[pt1] , height , ro1 , ro2 );
d2005 2
a2006 2
		if( mk_addmember( name , &r_head , WMOP_UNION ) == (struct wmember *)NULL )
			rt_bomb( "mk_addmember failed!\n" );
d2008 2
d2016 1
a2016 1
		make_solid_name( name , CCONE2 , element_id , comp_id , group_id , 2 );
d2021 7
d2029 1
a2029 3
		make_solid_name( name , CCONE2 , element_id , comp_id , group_id , 0 );
		mk_lcomb( fdout, name, &r_head, 0, NULL, NULL, NULL, 0);
	}
d2047 1
a2047 1
		make_region_name( name , group_id , comp_id );
d2204 3
d2230 3
d2256 3
d2262 4
a2265 2
	make_solid_name( name , CCONE3 , element_id , comp_id , group_id , 0 );
	mk_lcomb( fdout, name, &r_head, 0, NULL, NULL, NULL, 0);
d2269 5
a2273 1
Add_holes( int type, int gr, int comp, struct hole_list *ptr )
d2398 4
a2401 5
	if( type == HOLE ) {
		while( col < s_len )
		{
			strncpy( field , &line[col] , 8 );
			igrp = atoi( field );
d2403 3
a2405 3
			col += 8;
			if( col >= s_len )
				break;
d2407 2
a2408 2
			strncpy( field , &line[col] , 8 );
			icmp = atoi( field );
d2410 5
a2414 1
			if( igrp >= 0 && icmp > 0 )
d2416 5
a2420 2
				if( igrp == group && comp == icmp )
					bu_log( "Hole or wall card references itself (ignoring): (%s)\n", line );
d2423 2
a2424 14
					if( list_ptr )
					{
						list_ptr->next = (struct hole_list *)bu_malloc( sizeof( struct hole_list ) , "do_hole_wall: list_ptr" );
						list_ptr = list_ptr->next;
					}
					else
					{
						list_ptr = (struct hole_list *)bu_malloc( sizeof( struct hole_list ) , "do_hole_wall: list_ptr" );
						list_start = list_ptr;
					}
				
					list_ptr->group = igrp;
					list_ptr->component = icmp;
					list_ptr->next = (struct hole_list *)NULL;
d2426 4
a2430 2

			col += 8;
d2433 2
a2434 12
		Add_holes( type, group , comp , list_start );
	} else if( type == WALL ) {
		while( col < s_len ) {
			strncpy( field , &line[col] , 8 );
			igrp = atoi( field );

			col += 8;
			if( col >= s_len )
				break;

			strncpy( field , &line[col] , 8 );
			icmp = atoi( field );
d2436 1
a2436 14
			if( igrp >= 0 && icmp > 0 ) {
				list_ptr = (struct hole_list *)bu_malloc( sizeof( struct hole_list ) , "do_hole_wall: list_ptr" );
				list_ptr->group = group;
				list_ptr->component = comp;
				list_ptr->next = (struct hole_list *)NULL;
				Add_holes( type, igrp, icmp, list_ptr );
			}

			col += 8;
		}
	} else {
		bu_log( "do_hole_wall: unrecognized type (%d)\n", type );
		bu_bomb( "do_hole_wall: unrecognized type\n" );
	}
d2599 2
a2600 2
	fastf_t thick = 0.0;
	int pos = 0;
d2659 2
a2660 1
skip_region( int id )
d2685 1
d2750 3
a2752 1
		bu_log( "WARNING: %d duplicate faces eliminated from group %d component %d\n", count, group_id, comp_id );
d2766 14
a2792 2
	name_name[0] = '\0';

d2801 3
a2803 1

d2850 4
d2992 1
d3048 16
d3255 1
a3255 1
		bu_log( "In fix_regions:%s is not a combination!!!!\n", dp->d_namep );
d3270 1
a3270 1
		rt_db_free_internal( &internal , &rt_uniresource);
d3279 1
a3279 1
		rt_db_free_internal( &internal , &rt_uniresource);
d3291 2
a3292 2
		rt_db_free_internal( &internal , &rt_uniresource);
		rt_db_free_internal( &internal2 , &rt_uniresource);
d3315 1
a3315 1
	db_free_tree( tree);
d3337 1
a3337 1
	db_dirbuild( dbip );
d3408 13
a3420 1
void make_regions()
d3422 6
a3427 11
	struct name_tree *ptr1, *ptr2;
	struct holes *hptr;
	struct hole_list *lptr;
	struct compsplt *splt;
	struct wmember region;
	struct wmember solids;
	struct wmember holes;
	char reg_name[16];
	char solids_name[16];
	char hole_name[16];
	char splt_name[16];
d3429 1
a3429 1
	BU_LIST_INIT( &holes.l );
d3431 1
a3431 4
	/* loop through the list of region names (by ident) */
	bu_ptbl_reset( &stack );
	ptr1 = name_root;
	while( 1 )
d3433 23
a3455 8
		while( ptr1 )
		{
			PUSH( ptr1 );
			ptr1 = ptr1->rleft;
		}
		POP( name_tree, ptr1 );
		if( !ptr1 )
			break;
d3457 2
a3458 11
		/* check if we are skipping some regions (but we might need all the holes) */
		if( skip_region( ptr1->region_id ) && !is_a_hole( ptr1->region_id ) )
			goto cont1;

		/* place all the solids for this ident in a "solids" combination */
		BU_LIST_INIT( &solids.l );
		bu_ptbl_reset( &stack2 );
		ptr2 = name_root;
		while( 1 )
		{
			while( ptr2 )
d3460 2
a3461 2
				PUSH2( ptr2 );
				ptr2 = ptr2->nleft;
d3463 1
a3463 3
			POP2( name_tree, ptr2 );
			if( !ptr2 )
				break;
d3465 5
a3469 1
			if( ptr2->region_id == -ptr1->region_id && ptr2->inner == 0 )
d3471 45
a3515 2
				if( mk_addmember( ptr2->name, &solids, WMOP_UNION ) == (struct wmember *)NULL )
					bu_log( "make_regions: mk_addmember failed to add %s to %s\n", ptr1->name, ptr2->name );
d3517 1
d3519 24
a3542 2
			ptr2 = ptr2->nright;
		}
d3544 12
a3555 4
		sprintf( solids_name, "solids_%d", ptr1->region_id );
		if( mk_lcomb( fdout, solids_name, &solids, 0, NULL, NULL, NULL, 0) )
			bu_log("Failed to make combination of solids (%s)!!!!\n\tRegion %s is in ERROR!!!\n",
				solids_name, ptr1->name );
d3557 19
a3575 8
		/* hole components do not get made into regions */
		if( is_a_hole( ptr1->region_id ) )
		{
			/* just add it to the "holes" group */
			if( mk_addmember( solids_name, &holes, WMOP_UNION ) == (struct wmember *)NULL )
				bu_log( "make_regions: mk_addmember failed to add %s to holes group\n", ptr1->name );
			goto cont1;
		}
d3577 9
a3585 7
		hptr = hole_root;
		while( hptr && hptr->group * 1000 + hptr->component != ptr1->region_id )
			hptr = hptr->next;
		if( hptr )
			lptr = hptr->holes;
		else
			lptr = (struct hole_list *)NULL;
d3587 2
a3588 3
		splt = compsplt_root;
		while( splt && splt->ident_to_split != ptr1->region_id )
			splt = splt->next;
d3590 2
a3591 2
		if( debug )
			bu_log( "Build region for %s %d\n", ptr1->name, ptr1->region_id );
d3593 6
a3598 3
		if( splt )
		{
			vect_t norm;
d3600 5
a3604 4
			/* make a halfspace */
			VSET( norm, 0.0, 0.0, 1.0 );
			sprintf( splt_name, "splt_%d.s", ptr1->region_id );
			mk_half( fdout, splt_name, norm, splt->z );
d3606 2
a3607 4
			/* intersect halfspace with current region */
			BU_LIST_INIT( &region.l );
			if( mk_addmember( solids_name, &region, WMOP_UNION ) == (struct wmember *)NULL )
				bu_log( "make_regions: mk_addmember failed to add %s to %s\n", solids_name, ptr1->name );
d3609 5
a3613 2
			if( mk_addmember( splt_name, &region, WMOP_INTERSECT ) == (struct wmember *)NULL )
				bu_log( "make_regions: mk_addmember failed to add %s to %s\n", splt_name, ptr1->name );
d3615 1
a3615 8
			while( lptr )
			{
				sprintf( hole_name, "solids_%d", (lptr->group * 1000 + lptr->component) );
				if( mk_addmember( hole_name, &region, WMOP_SUBTRACT ) == (struct wmember *)NULL )
					bu_log( "make_regions: mk_addmember failed to add %s to %s\n", hole_name, ptr1->name );
				lptr = lptr->next;
			}
			MK_REGION( fdout, &region, ptr1->name, ptr1->region_id )
d3617 6
a3622 4
			/* create new region by subtracting halfspace */
			BU_LIST_INIT( &region.l );
			if( mk_addmember( solids_name, &region, WMOP_UNION ) == (struct wmember *)NULL )
				bu_log( "make_regions: mk_addmember failed to add %s to %s\n", solids_name, ptr1->name );
d3624 6
a3629 2
			if( mk_addmember( splt_name, &region, WMOP_SUBTRACT ) == (struct wmember *)NULL )
				bu_log( "make_regions: mk_addmember failed to add %s to %s\n", splt_name, ptr1->name );
d3631 1
a3631 15
			while( lptr )
			{
				sprintf( hole_name, "solids_%d", (lptr->group * 1000 + lptr->component) );
				if( mk_addmember( hole_name, &region, WMOP_SUBTRACT ) == (struct wmember *)NULL )
					bu_log( "make_regions: mk_addmember failed to add %s to %s\n", hole_name, ptr1->name );
				lptr = lptr->next;
			}
			sprintf( reg_name, "comp_%d.r", splt->new_ident );
			MK_REGION( fdout, &region, reg_name, splt->new_ident )
		}
		else
		{
			BU_LIST_INIT( &region.l );
			if( mk_addmember( solids_name, &region, WMOP_UNION ) == (struct wmember *)NULL )
				bu_log( "make_regions: mk_addmember failed to add %s to %s\n", solids_name, ptr1->name );
d3633 4
a3636 11
			while( lptr )
			{
				sprintf( hole_name, "solids_%d", (lptr->group * 1000 + lptr->component) );
				if( mk_addmember( hole_name, &region, WMOP_SUBTRACT ) == (struct wmember *)NULL )
					bu_log( "make_regions: mk_addmember failed to add %s to %s\n", hole_name, ptr1->name );
				lptr = lptr->next;
			}
			MK_REGION( fdout, &region, ptr1->name, ptr1->region_id )
		}
cont1:
		ptr1 = ptr1->rright;
d3638 8
d3647 2
a3648 1
	if( BU_LIST_NON_EMPTY( &holes.l ) )
d3650 13
a3662 3
		/* build a "holes" group */
		if( mk_lcomb( fdout, "holes", &holes, 0, NULL, NULL, NULL, 0 ))
			bu_log("Failed to make holes group!!!!\n" );
d3664 1
a3723 2
	rt_init_resource( &rt_uniresource, 0 );

d3731 1
a3731 1
	if( (fdout=fopen( argv[optind+1], "w" )) == NULL )
d3763 1
a3776 1
	bu_ptbl_init( &stack2 , 64, " &stack2 ");
a3782 3
	if( !quiet )
		bu_log( "Scanning for HOLE, WALL, and COMPLSPLT cards...\n" );

a3786 3
	if( !quiet )
		bu_log( "Building component names....\n" );

a3794 3
	if( !quiet )
		bu_log( "Building components....\n" );

a3796 6
	if( !quiet )
		bu_log( "Building regions and groups....\n" );

	/* make regions */
	make_regions();

d3804 4
@


11.52.2.1.2.3
log
@Corrections to get correct mode assigned to regions
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.52.2.1.2.2 2000/12/21 15:09:22 jra Exp $";
d63 1
a63 1
static int	mode=0;			/* Plate mode (1) or volume mode (2), of current component  */
d100 1
a100 1
	q - quiet mode (don't say anyhing except error messages)\n\
d138 3
a140 3
				if( mode == 1 ) {\
					if( !quiet ) \
						bu_log( "Making region: %s (PLATE)\n", name ); \
d143 1
a143 4
				}\
				else if( mode == 2 ) {\
					if( !quiet ) \
						bu_log( "Making region: %s (VOLUME)\n", name ); \
a145 1
				}\
a211 1
	int mode;		/* PLATE_MODE or VOLUME_MODE */
a924 1
	new_ptr->mode = mode;
a3304 1
		mode = ptr1->mode;
d3306 1
a3306 1
			bu_log( "Build region for %s %d, mode = %d\n", ptr1->name, ptr1->region_id, mode );
@


11.52.2.1.2.4
log
@Added check for illegal second SECTION card for the same component
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.52.2.1.2.3 2000/12/22 14:06:15 jra Exp $";
a2621 23
void
skip_section()
{
	long section_start;

	/* skip to start of next section */
	section_start = ftell( fdin );
	if( getline() )
	{
		while( line[0] && strncmp( line, "SECTION" , 7 ) &&
		strncmp( line, "HOLE", 4 ) &&
		strncmp( line, "WALL", 4 ) &&
		strncmp( line, "VEHICLE", 7 ) )
		{
			section_start = ftell( fdin );
			if( !getline() )
		break;
		}
	}
	/* seek to start of the section */
	fseek( fdin, section_start, SEEK_SET );
}

d2643 3
a2658 3
		int found;
		struct name_tree *nm_ptr;

d2669 18
a2686 1
			skip_section();
d2705 1
a2705 9
		if( !pass )
		{
			nm_ptr = Search_ident( name_root, region_id, &found );
			if( found && nm_ptr->mode != mode ) {
				bu_log( "ERROR: second SECTION card found with different mode for component (group=%d, component=%d), conversion of this component will be incorrect!!!\n",
					group_id, comp_id );
			}
		}
		else
@


11.52.2.1.2.5
log
@Corrected wall treatment and included compsplt regions in series groups
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.52.2.1.2.4 2000/12/22 15:09:33 jra Exp $";
a452 1
	char name[NAMESIZE+1];
a485 1
	make_region_name( name, gr1, co1 );
a2210 6
	if( type != HOLE && type != WALL )
	{
		bu_log( "do_hole_wall: unrecognized type (%d)\n", type );
		bu_bomb( "do_hole_wall: unrecognized type\n" );
	}

d2229 5
d2235 3
a2237 8
	while( col < s_len )
	{
		strncpy( field , &line[col] , 8 );
		igrp = atoi( field );

		col += 8;
		if( col >= s_len )
			break;
d2239 2
a2240 2
		strncpy( field , &line[col] , 8 );
		icmp = atoi( field );
d2242 1
a2242 5
		if( igrp >= 0 && icmp > 0 )
		{
			if( igrp == group && comp == icmp )
				bu_log( "Hole or wall card references itself (ignoring): (%s)\n", line );
			else
d2244 2
a2245 5
				if( list_ptr )
				{
					list_ptr->next = (struct hole_list *)bu_malloc( sizeof( struct hole_list ) , "do_hole_wall: list_ptr" );
					list_ptr = list_ptr->next;
				}
d2248 14
a2261 2
					list_ptr = (struct hole_list *)bu_malloc( sizeof( struct hole_list ) , "do_hole_wall: list_ptr" );
					list_start = list_ptr;
d2263 22
a2284 3
			
				list_ptr->group = igrp;
				list_ptr->component = icmp;
d2286 1
d2288 2
d2291 3
a2293 2

		col += 8;
a2294 2

	Add_holes( type, group , comp , list_start );
a2847 1
		make_region_name( name , group_id , comp_id );
a2915 11
		else if( !strncmp( line, "SECTION", 7 ) )
		{
			strncpy( field , &line[24] , 8 );
			mode = atoi( field );
			if( mode != 1 && mode != 2 )
			{
				bu_log( "Illegal mode (%d) for group %d component %d, using volume mode\n",
					mode, group_id, comp_id );
				mode = 2;
			}
		}
a3298 3
		if( BU_LIST_IS_EMPTY( &solids.l ) )
			goto cont1;

a3331 2
			struct name_tree *ptr2;
			int found;
d3370 2
a3371 7
			ptr2 = Search_ident( name_root, splt->new_ident, &found );
			if( found ) {
				MK_REGION( fdout, &region, ptr2->name, splt->new_ident )
			} else {
				sprintf( reg_name, "comp_%d.r", splt->new_ident );
				MK_REGION( fdout, &region, reg_name, splt->new_ident )
			}
@


11.51
log
@Added check for hole/wall card rferencing itself, and added more debugging prints
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.50 2000/06/20 17:30:00 jra Exp $";
d85 1
d403 3
a405 2
					bu_log( "ERROR: Can't find holes to subtract for group %d, component %d\n" , group_id , comp_id );
					return;
d407 2
d410 1
a410 1
				bu_ptbl_reset( &stack );
a411 2
				while( ptr && ptr->region_id == reg_id )
				{
d414 8
a421 6
						PUSH( ptr );
						ptr = ptr->rleft;
					}
					POP( name_tree , ptr );
					if( !ptr ||  ptr->region_id != reg_id )
						break;
d423 2
a424 2
					if( mk_addmember( ptr->name , head , WMOP_SUBTRACT ) == (struct wmember *)NULL )
						rt_bomb( "Subtract_holes: mk_addmember failed\n" );
d426 2
a427 1
					ptr = ptr->rright;
a1614 31
Add_to_clines( element_id , pt1 , pt2 , thick , radius )
int element_id;
int pt1;
int pt2;
fastf_t thick;
fastf_t radius;
{
	struct cline *cline_ptr;

	cline_ptr = (struct cline *)bu_malloc( sizeof( struct cline ) , "Add_to_clines: cline_ptr" );

	cline_ptr->pt1 = pt1;
	cline_ptr->pt2 = pt2;
	cline_ptr->element_id = element_id;
	cline_ptr->made = 0;
	cline_ptr->thick = thick;
	cline_ptr->radius = radius;
	cline_ptr->next = (struct cline *)NULL;

	if( cline_last_ptr == (struct cline *)NULL )
		cline_root = cline_ptr;
	else
		cline_last_ptr->next = cline_ptr;

	cline_last_ptr = cline_ptr;

	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in Add_to_clines\n" );
}

void
a3091 1
	int id1, id2, id3;
d3400 211
d3746 2
d3749 2
a3750 2
	fclose( fdout );
	Post_process( output_file );
d3755 1
@


11.50
log
@reinstated duplicate face check
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.49 2000/06/19 17:54:34 jra Exp $";
d2438 2
a2439 5
			if( list_ptr )
			{
				list_ptr->next = (struct hole_list *)bu_malloc( sizeof( struct hole_list ) , "do_hole_wall: list_ptr" );
				list_ptr = list_ptr->next;
			}
d2442 14
a2455 2
				list_ptr = (struct hole_list *)bu_malloc( sizeof( struct hole_list ) , "do_hole_wall: list_ptr" );
				list_start = list_ptr;
a2456 4
			
			list_ptr->group = igrp;
			list_ptr->component = icmp;
			list_ptr->next = (struct hole_list *)NULL;
d3317 4
a3320 1
bu_log( "Fixing region %s\n", dp->d_namep );
d3353 3
d3358 3
d3367 4
d3372 3
@


11.49
log
@Duplicate faces are no longer checked for.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.48 2000/06/08 17:53:32 jra Exp $";
d2760 1
a2760 1
#if 0
d2764 1
a2764 1
#endif
d3312 1
a3312 1

@


11.48
log
@A minor non-critical typo fix
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.47 2000/06/06 20:45:22 jra Exp $";
d2760 1
a2760 1

d2764 1
a2764 1

d3336 2
@


11.47
log
@Fixed a memory corruption bug and corrected some debug messages
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.46 2000/04/13 13:08:30 mike Exp $";
d2079 1
a2079 1
			rt_bomb( "CCONE2\n" );
@


11.46
log
@
Fixed syntax error
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.45 2000/04/11 18:13:48 jra Exp $";
d86 1
a86 1
static int		*faces;		/* one triplet per face indexing three grid points */
d2436 1
a2436 1
		if( igrp > 0 && icmp > 0 )
d2505 2
d2510 2
d2530 3
d2557 2
d2564 2
d2579 1
d2587 2
a2592 2
		thickness[face_count] = thick;
		facemode[face_count] = pos;
d2598 3
d2602 3
d3075 1
a3075 1
	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
d3084 1
a3084 1
	if( bu_debug & DEBUG_MEM_FULL )
d3167 1
a3167 1
	if( bu_debug & DEBUG_MEM_FULL )
d3375 1
a3375 1
			if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
d3383 1
a3383 1
					if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
d3387 1
a3387 1
				if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
d3484 1
a3484 1
	if( rt_g.debug )
d3486 1
a3486 1
		bu_printb( "librt rt_g.debug", rt_g.debug, DEBUG_FORMAT );
@


11.45
log
@Added CHGCOMP to MUVES output
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.44 2000/03/29 18:07:44 mike Exp $";
d3095 1
a3095 1
	int id1 id2 id3;
@


11.44
log
@
Removed stray RT_EXTERNs, added bn_ prefix.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.43 2000/03/17 18:25:45 jra Exp $";
d58 1
a58 1
static FILE	*fd_muves=NULL;		/* file for MUVES data, output CBAR and CBACKING data */
d102 1
a102 1
	m - create a MUVES input file containing CBAR and CBACKING elements\n\
d3093 14
d3174 2
@


11.43
log
@Eliminated some unused code and corrected Add_stragglers_to_groups()
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.42 2000/03/17 16:34:00 jra Exp $";
a105 2

RT_EXTERN( fastf_t mat_determinant , (mat_t matrix ) );
@


11.42
log
@Fixed a bug in hole handling (was adding a hole with group=0 and comp=0 for blank fields)
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.41 2000/03/17 16:09:35 jra Exp $";
d1278 1
a1278 1
		if( !ptr->in_comp_group )
a1507 62
#if 0
void
make_cline_regions()
{
	struct cline *cline_ptr;
	struct wmember head;
	char name[NAMESIZE+1];
	int sph_no;

	if( debug )
		bu_log( "make_cline_regions\n" );

	BU_LIST_INIT( &head.l );

	/* make a list of all the endpoints */
	cline_ptr = cline_root;
	while( cline_ptr )
	{
		/* Add endpoints to points list */
		insert_int( cline_ptr->pt1 );
		insert_int( cline_ptr->pt2 );
		
		cline_ptr = cline_ptr->next;
	}

	/* Now build cline objects */
	for( sph_no=0 ; sph_no < int_list_count ; sph_no++ )
	{
		int pt_no;
		int line_no;
		struct bu_ptbl lines;
		fastf_t sph_radius=0.0;
		fastf_t sph_inner_radius=0.0;

		bu_ptbl_init( &lines , 64, " &lines ");

		pt_no = int_list[sph_no];

		/* get list of clines that touch this point */
		cline_ptr = cline_root;
		while( cline_ptr )
		{
			if( cline_ptr->pt1 == pt_no || cline_ptr->pt2 == pt_no )
			{
				/* get outer radius for sphere */
				if( cline_ptr->radius > sph_radius )
					sph_radius = cline_ptr->radius;

				/* get inner radius for sphere */
				if( cline_ptr->thick > 0.0 &&
				    (cline_ptr->radius - cline_ptr->thick > sph_inner_radius ) )
					sph_inner_radius =  cline_ptr->radius - cline_ptr->thick;

				bu_ptbl_ins( &lines , (long *)cline_ptr );
			}

			cline_ptr = cline_ptr->next;
		}

		if( BU_PTBL_END( &lines ) > 1 )
		{
			/* make a joint where CLINE's meet */
a1508 147
			/* make sphere solid at cline joint */
			sprintf( name , "%d.%d.j0" , region_id , pt_no );
			Insert_name( &name_root , name );
			mk_sph( fdout , name , grid_pts[pt_no] , sph_radius );

			/* Union sphere */
			if( mk_addmember( name , &head , WMOP_UNION ) == (struct wmember *)NULL )
			{
				bu_log( "make_cline_regions: mk_addmember failed for outer sphere %s\n" , name );
				bu_ptbl_free( &lines );
				break;
			}

			/* subtract inner sphere if required */
			if( sph_inner_radius > 0.0 && sph_inner_radius < sph_radius )
			{
				sprintf( name , "%d.%d.j1" , region_id , pt_no );
				Insert_name( &name_root , name );
				mk_sph( fdout , name , grid_pts[pt_no] , sph_inner_radius );

				if( mk_addmember( name , &head , WMOP_SUBTRACT ) == (struct wmember *)NULL )
				{
					bu_log( "make_cline_regions: mk_addmember failed for outer sphere %s\n" , name );
					bu_ptbl_free( &lines );
					break;
				}
			}

			/* subtract all outer cylinders that touch this point */
			for( line_no=0 ; line_no < BU_PTBL_END( &lines ) ; line_no++ )
			{
				cline_ptr = (struct cline *)BU_PTBL_GET( &lines , line_no );

				get_solid_name( name , CLINE , cline_ptr->element_id , comp_id , group_id , 0 );
				if( mk_addmember( name , &head , WMOP_SUBTRACT ) == (struct wmember *)NULL )
				{
					bu_log( "make_cline_regions: mk_addmember failed for line at joint %s\n" , name );
					bu_ptbl_free( &lines );
					break;
				}
			}

			/* subtract any holes for this component */
			Subtract_holes( &head , comp_id , group_id );

			/* process any component splitting */
			Compsplt( &head, comp_id, group_id );

			/* now make the region */
			if( BU_LIST_NON_EMPTY( &head.l ) )
				MK_REGION( fdout , &head , group_id , comp_id , -pt_no , CLINE )
		}
		else
		{
			char *bad_name;

			/* no need for a region here
			 * but we need to remove this region from the name tree
			 */
			bad_name = find_region_name( group_id , comp_id , -pt_no );
			if( bad_name )
				Delete_name( &name_root , bad_name );
		}

		/* make regions for all CLINE elements that start at this pt_no */
		for( line_no=0 ; line_no < BU_PTBL_END( &lines ) ; line_no++ )
		{
			int i;
			cline_ptr = (struct cline *)BU_PTBL_GET( &lines , line_no ) ;
			if( cline_ptr->pt1 != pt_no )
				continue;

			/* make name for outer cylinder */
			get_solid_name( name , CLINE , cline_ptr->element_id , comp_id , group_id , 0 );

			/* start region */
			if( mk_addmember( name , &head , WMOP_UNION ) == (struct wmember *)NULL )
			{
				bu_log( "make_cline_regions: mk_addmember failed for outer solid %s\n" , name );
				break;
			}
			cline_ptr->made = 1;

			if( cline_ptr->thick > 0.0 )
			{
				/* subtract inside cylinder */
				get_solid_name( name , CLINE , cline_ptr->element_id , comp_id , group_id , 1 );
				if( mk_addmember( name , &head , WMOP_SUBTRACT ) == (struct wmember *)NULL )
				{
					bu_log( "make_cline_regions: mk_addmember failed for inner solid %s\n" , name );
					break;
				}
			}

			/* subtract outside cylinders of any other clines that use this grid point */
			for( i=0 ; i < BU_PTBL_END( &lines ) ; i++ )
			{
				struct cline *ptr2;

				ptr2 = (struct cline *)BU_PTBL_GET( &lines , i );

				if( ptr2 != cline_ptr &&
				    ptr2->pt1 == pt_no || ptr2->pt2 == pt_no )
				{
					get_solid_name( name , CLINE , ptr2->element_id , comp_id , group_id , 0 );
					if( mk_addmember( name , &head , WMOP_SUBTRACT ) == (struct wmember *)NULL )
					{
						bu_log( "make_cline_regions: mk_addmember failed for inner solid %s\n" , name );
						break;
					}
				}
			}

			/* subtract any holes for this component */
			Subtract_holes( &head , comp_id , group_id );

			/* process any component splitting */
			Compsplt( &head, comp_id, group_id );

			/* make the region */
			MK_REGION( fdout , &head , group_id , comp_id , cline_ptr->element_id , CLINE );
		}
		bu_ptbl_free( &lines );
	}

	int_list_count = 0;

	/* free the linked list of cline pointers */
	cline_ptr = cline_root;
	while( cline_ptr )
	{
		struct cline *ptr;

		ptr = cline_ptr;
		cline_ptr = cline_ptr->next;

		bu_free( (char *)ptr , "make_cline_regions: cline_ptr" );
	}

	cline_root = (struct cline *)NULL;
	cline_last_ptr = (struct cline *)NULL;

	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in make_cline_regions\n" );

}
#endif
@


11.41
log
@Now uses mk_fastgen_region()
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.40 2000/03/10 19:53:19 jra Exp $";
d2647 1
a2647 1
		if( list_ptr )
d2649 14
a2662 7
			list_ptr->next = (struct hole_list *)bu_malloc( sizeof( struct hole_list ) , "do_hole_wall: list_ptr" );
			list_ptr = list_ptr->next;
		}
		else
		{
			list_ptr = (struct hole_list *)bu_malloc( sizeof( struct hole_list ) , "do_hole_wall: list_ptr" );
			list_start = list_ptr;
a2663 4

		list_ptr->group = igrp;
		list_ptr->component = icmp;
		list_ptr->next = (struct hole_list *)NULL;
@


11.40
log
@Added CBACKING (just output for MUVES)
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.39 2000/03/10 18:19:27 jra Exp $";
d145 12
a156 2
				mk_lrcomb( fp , name , headp , 1 ,\
					(char *)NULL, (char *)NULL, (unsigned char *)NULL, r_id, 0, 0, 0, 0 ); \
@


11.39
log
@Added support for COMPSPLT
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.38 2000/03/09 18:20:21 jra Exp $";
d58 1
d97 1
a97 1
static char	*usage="Usage:\n\tfast4-g [-dwq] [-c component_list] [-o plot_file] [-b BU_DEBUG_FLAG] [-x RT_DEBUG_FLAG] fastgen4_bulk_data_file output.g\n\
d102 1
d3290 36
d3356 2
d3577 1
a3577 1
	while( (c=getopt( argc , argv , "qo:c:dwx:b:X:" ) ) != EOF )
d3583 7
@


11.38
log
@Renamed list_regions to fix_regions, and added a comment
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.37 2000/03/02 15:55:44 jra Exp $";
d40 1
d129 4
d204 8
d426 126
d592 4
a595 1
		bu_log( "%s %d %d\n" , ptr->name , ptr->region_id , ptr->element_id );
d1246 32
d1288 2
d1496 1
a1496 1

d1604 3
d1675 3
d1705 1
a1705 1

d1782 3
d1905 3
d2129 3
d2251 3
d2486 4
d2967 3
d2992 1
d2994 1
d3248 3
d3272 2
d3316 2
d3575 1
a3575 1
		rt_bomb( usage );
d3622 2
d3662 1
@


11.37
log
@Eliminated some unused variables
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.36 2000/03/02 14:39:40 jra Exp $";
d3155 5
d3161 1
a3161 1
list_regions( dbip, dp, ptr )
d3265 1
a3265 1
	db_functree( dbip, dp, list_regions, 0, NULL );
@


11.36
log
@Eliminated FGP solid and added CLINE solid
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.35 2000/02/17 19:24:32 jra Exp $";
a1662 1
	char name2[NAMESIZE+1];
d2067 1
a2067 1
	int pt1, pt2, pt3, pt4, c1, c2, i;
d2069 1
a2069 1
	fastf_t ro[4], ri[4], dot2, dot3, len03, len01, len12, len23;
d2106 2
a2107 2
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d, c1 = %d\n",
			group_id, comp_id, element_id , c1 );
d2113 1
a2113 1
		bu_log( "WARNING: CCONE3 continuation flags disagree, %d vs %d\n" , c1 , c2 );
a2150 2
	dot3 = VDOT( diff4, diff3 );
	dot2 = VDOT( diff4, diff2 );
@


11.35
log
@Added support for CCONE3 solids
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.34 1999/12/30 18:38:42 jra Exp $";
d1663 2
a1699 1
		make_region_name( name , group_id , comp_id , -pt1 , CLINE );
d1712 1
a1712 1
	mk_rcc( fdout , name , grid_pts[pt1] , height , radius );
d1714 8
a1721 12
	if( thick > radius )
	{
		bu_log( "ERROR: CLINE thickness (%f) greater than radius (%f)\n", thick, radius );
		bu_log( "\tnot making inner cylinder\n" );
		bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
		thick = 0.0;
	}
	else if( thick > 0.0 )
	{
		make_solid_name( name , CLINE , element_id , comp_id , group_id , 1 );
		mk_rcc( fdout , name , grid_pts[pt1] , height , radius-thick );
	}
a1722 1
	Add_to_clines( element_id , pt1 , pt2 , thick , radius );
@


11.34
log
@Eliminated some unused variables
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.33 1999/12/30 14:20:01 jra Exp $";
d124 1
d1968 1
a1968 1
			bu_log( "Unexpected EOF while reading continuation card for CCONE1\n" );
d2069 234
d3137 2
@


11.33
log
@Now uses some of the new BOT routines to eliminate duplicate bot faces
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.32 1999/12/29 23:22:59 mike Exp $";
a72 1
static int	nmg_debug=0;		/* rt_g.NMG_debug */
a73 1
static int	sol_count=0;		/* number of solids, used to create unique solid names */
a74 3
static long	curr_offset=0;		/* Offset into input file for current element */
static long	curr_sect=0;		/* Offset into input file for current section card */
static long	prev_sect=0;		/* Offset into input file for previous section card */
a218 2
static int elem_match[4]={1,2,4,8};

a2304 1
	int overlap;
a2554 3
	prev_sect = curr_sect;
	curr_sect = curr_offset;

a2640 1
	struct wmember head;
a2641 1
	point_t points[8];
a2646 1
	char name[NAMESIZE+1];
a2869 1
	curr_offset = ftell( fdin );
a2910 6

		if( (curr_offset = ftell( fdin )) < 0 )
		{
			perror( "ftell" );
			bu_bomb( "ftell() failed!!\n" );
		}
@


11.32
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.31 1999/12/29 21:09:17 mike Exp $";
d2460 2
d2469 1
d2481 4
d2488 4
d2493 2
d2505 4
d2513 12
d2528 10
a2537 2
	mk_bot( fdout, name, bot_mode, RT_BOT_UNORIENTED, 0, num_vertices, face_count, &grid_pts[min_pt],
		faces, thickness, bv );
a2544 2
	if( bv )
		bu_free( (char *)bv, "bv" );
d3141 1
@


11.31
log
@
Added client_data pointer to db_functree() to eliminate use of
global variables.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.30 1999/11/17 21:27:20 jra Exp $";
d3008 1
a3008 1
	db_scan(dbip, (int (*)())db_diradd, 1);
@


11.30
log
@Fixed bug in do_hex1()
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.29 1999/11/17 16:20:33 jra Exp $";
d2912 1
a2912 1
list_regions( dbip, dp )
d2915 1
d3016 1
a3016 1
	db_functree( dbip, dp, list_regions, 0 );
@


11.29
log
@Finished conversion to use BOT solids, improved handling of HOLE/WALL cards, added seom debugug prints
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.28 1999/11/15 17:47:54 jra Exp $";
d140 2
d2526 1
a2526 1
		bu_log( "do_section: %s\n" , line );
a2607 2
		bot = 0;
		face_count = 0;
d2609 3
a2719 12

	BU_LIST_INIT( &head.l );

	if( mk_addmember( name , &head , WMOP_UNION ) == (struct wmember *)NULL )
		rt_bomb( "CHEX1: mk_addmember failed\n" );

	Subtract_holes( &head, comp_id, group_id );

	MK_REGION( fdout , &head , group_id , comp_id , element_id , CHEX1 )

	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in Do_hex1\n" );
d2826 1
a2826 1
		bu_log( "At end of Processa_hole_wall:\n" );
@


11.28
log
@Eliminated  all the old NMG code
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.26 1999/11/15 14:09:15 jra Exp $";
d53 1
a53 1
static char	line[LINELEN];		/* Space for input line */
d74 1
d100 1
a100 1
static char	*usage="Usage:\n\tfast4-g [-dw] [-c component_list] [-o plot_file] [-b BU_DEBUG_FLAG] [-x RT_DEBUG_FLAG] fastgen4_bulk_data_file output.g\n\
d102 1
d334 1
a334 1
			int_list = (int *)rt_realloc( (char *)int_list , (int_list_length + INT_LIST_BLOCK)*sizeof( int ) , "insert_id: int_list" );
d1314 1
a1314 1
		grid_pts = (point_t *)rt_realloc( (char *)grid_pts , grid_size * sizeof( point_t ) , "fast4-g: grid_pts" );
d2080 37
d2261 1
a2261 1
		bu_log( "Add_bot_face: ignoring degenerate triangle\n" );
d2272 1
a2272 1
			bu_log( "Add_bot_face: illegal postion parameter (%d), must be one or two (ignoring face)\n" , pos );
a2522 2
	static int	old_region_id;

d2567 1
a2567 2
			(void)getline();
			while( line[0] &&  strncmp( line, "SECTION" , 7 ) )
d2569 9
a2577 2
				section_start = ftell( fdin );
				(void)getline();
d2584 1
a2584 1
		if( pass )
d2685 1
a2685 8
	BU_LIST_INIT( &head.l );

	if( mk_addmember( name , &head , WMOP_UNION ) == (struct wmember *)NULL )
		rt_bomb( "CHEX1: mk_addmember failed\n" );

	strncpy( field , &line[56] , 8 );
	thick = atof( field ) * 25.4;
	if( thick <= 0.0 )
d2687 8
a2694 4
		bu_log( "do_hex1: illegal thickness (%f), skipping CHEX1 element\n" , thick );
		bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
		return;
	}
d2696 2
a2697 2
	strncpy( field , &line[64] , 8 );
	pos = atoi( field );
d2699 2
a2700 2
	if( pos == 0 )	/* use default */
		pos = POS_FRONT;
d2702 8
a2709 1
	if( pos != POS_CENTER && pos != POS_FRONT )
d2711 2
a2712 3
		bu_log( "do_hex1: illegal postion parameter (%d), must be 1 or 2, skipping CHEX1 element\n" , pos );
		bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
		return;
d2718 5
d2811 29
d2847 2
a2848 1
/*	bu_prmem( "At start of Process_input:" );	*/
d2859 1
a2859 2
	(void)getline();
	if( !line[0] )
d2866 1
a2866 1
			do_hole_wall( HOLE );
d2868 1
a2868 1
			do_hole_wall( WALL );
d2901 7
a2907 3
		curr_offset = ftell( fdin );
		(void)getline();
		if( !line[0] )
d3048 2
d3055 3
a3057 1
					bu_realloc( region_list, region_list_len*sizeof( int ), "region_list" );
d3060 2
d3069 1
a3069 1
				bu_realloc( region_list, region_list_len*sizeof( int ), "region_list" );
d3086 1
a3086 1
	while( (c=getopt( argc , argv , "o:c:pa:dnwx:b:X:D:P:" ) ) != EOF )
d3090 3
d3108 1
a3108 1
				rt_g.debug = rt_debug;
d3182 4
d3206 2
a3207 1
	bu_log( "%d components converted\n", comp_count );
@


11.27
log
@Removed an excess debug print
@
text
@d266 3
a268 4
#if 0
struct fast_fus *
Find_fus( fu )
struct faceuse *fu;
d270 1
a270 1
	struct fast_fus *fus;
d272 4
a275 2
	if( !fus_root )
		return( (struct fast_fus *)NULL );
d277 4
a280 2
	fus = fus_root;
	while( fus )
d282 8
a289 2
		if( fus->fu == fu || fus->fu == fu->fumate_p )
			return( fus );
d291 3
a293 1
		fus = fus->next;
d296 17
a312 1
	return( (struct fast_fus *)NULL );
d315 3
a317 2
static int
Check_acute_angles()
d319 1
a319 3
	struct fast_fus *fus;
	int errors=0;
	long *flags;
d321 5
a325 1
	flags = (long *)bu_calloc( m->maxindex , sizeof( long ) , "Check_acute_angles: flags" );
d327 1
a327 2
	fus = fus_root;
	while( fus )
d329 6
a334 1
		struct loopuse *lu;
d336 6
a341 2
		NMG_INDEX_SET( flags, fus->fu )
		NMG_INDEX_SET( flags, fus->fu->fumate_p )
d343 8
a350 3
		for( BU_LIST_FOR( lu, loopuse, &fus->fu->lu_hd ) )
		{
			struct edgeuse *eu;
d352 2
a353 2
			if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
				continue;
d355 7
a361 1
			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d363 2
a364 5
				struct edgeuse *eu_radial;
				struct faceuse *fu;
				vect_t eu_left;
				vect_t rad_left;
				fastf_t dot;
d366 5
a370 3
				eu_radial = eu->radial_p;
				if( eu_radial == eu->eumate_p )
					continue;
d372 6
a377 1
				fu = nmg_find_fu_of_eu( eu_radial );
d379 5
a383 2
				if( NMG_INDEX_TEST( flags, fu ) )
					continue;
d385 1
a385 2
				if( fus->fu == fu->fumate_p || fus->fu == fu )
					continue;
d387 1
a387 11
				if( fus->fu->f_p == fu->f_p )
					continue;

				if( nmg_find_eu_leftvec( eu_left, eu ) )
					continue;
				if( nmg_find_eu_leftvec( rad_left, eu_radial ) )
					continue;

				dot = VDOT( eu_left, rad_left );

				if( dot > max_cos )
d389 8
a396 2
					struct fast_fus *fus2;
					fastf_t angle;
d398 2
a399 1
					errors++;
d401 1
a401 10
					if( dot > 1.0 )
						angle = 0.0;
					else
						angle = acos( dot ) * 180.0 / bn_pi;

					fus2 = Find_fus( fu );
					if( fus2 )
						bu_log( "WARNING: Angle between adjancent elements (%d and %d) is only %g degrees.\n", fus->element, fus2->element, angle );
					else
						bu_log( "WARNING: Angle between element %d and a neighbor is only %g degrees.\n", fus->element, angle );
d403 2
d406 1
d408 1
a408 1
		fus = fus->next;
d410 9
d420 1
a420 1
	bu_free( (char *)flags, "Check_acute_angles: flags" );
d422 1
a422 1
	if( errors )
d424 8
a431 3
		bu_log( "\tThis may cause unexpected results in PLATE-MODE components.\n" );
		bu_log( "\tThis component will be converted using ARB6 solids.\n" );
		return( 1 );
a432 2
	else
		return( 0 );
d435 2
a436 3
static int
Unbreak_shell_edges( s_in )
struct shell *s_in;
d438 1
a438 2
	struct faceuse *fu;
	int count=0;
d440 1
a440 1
	NMG_CK_SHELL( s_in );
d442 3
a444 1
	for( BU_LIST_FOR( fu, faceuse, &s_in->fu_hd ) )
d446 1
a446 3
		struct loopuse *lu;

		for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
d448 6
a453 1
			struct edgeuse *eu;
d455 3
a457 2
			if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
				continue;
d459 12
a470 4
			eu = BU_LIST_FIRST( edgeuse, &lu->down_hd );
			while( BU_LIST_NOT_HEAD( &eu->l, &lu->down_hd ))
			{
				struct edgeuse *next_eu, *prev_eu;
d472 2
a473 15
				next_eu = BU_LIST_PNEXT( edgeuse, &eu->l );
				prev_eu = BU_LIST_PPREV_CIRC( edgeuse, &eu->l );

				if( prev_eu == next_eu )
					break;

				if( prev_eu->g.magic_p == eu->g.magic_p )
				{
					if( nmg_unbreak_shell_edge_unsafe( prev_eu ) > 0 )
						count++;
				}

				eu = next_eu;
			}
		}
a474 1
	return( count );
d477 5
a481 3
static struct faceuse *
nmg_pop_fu( stack )
struct bu_ptbl *stack;
d483 1
a483 1
        struct faceuse *fu;
d485 1
a485 3
        /* return a NULL if stack is empty */
        if( BU_PTBL_END( stack ) == 0 )
                return( (struct faceuse *)NULL );
d487 3
a489 2
        /* get last faceuse on the stack */
        fu = (struct faceuse *)BU_PTBL_GET( stack , BU_PTBL_END( stack )-1 );
d491 1
a491 15
        /* remove that faceuse from the stack */
        bu_ptbl_rm( stack , (long *)fu );

        return( fu );
}

static void
Add_elem( element, no_pts, pt1, pt2, pt3, pt4 )
int element;
int no_pts;
int pt1, pt2, pt3, pt4;
{
	struct elem_list *elem;

	if( !elem_root )
d493 1
a493 32
		elem_root = (struct elem_list *)bu_malloc( sizeof( struct elem_list ), "Add_elem: elem_root" );
		elem = elem_root;
	}
	else
	{
		elem = elem_root;
		while( elem->next )
			elem = elem->next;

		elem->next = (struct elem_list *)bu_malloc( sizeof( struct elem_list ), "Add_elem: elem" );
		elem = elem->next;
	}

	elem->element = element;
	elem->no_pts = no_pts;
	elem->pt[0] = pt1;
	elem->pt[1] = pt2;
	elem->pt[2] = pt3;
	elem->pt[3] = pt4;
	elem->next = (struct elem_list *)NULL;
}

static int
Check_tri_overlap( element_no, pt1, pt2, pt3 )
int element_no;
int pt1, pt2, pt3;
{
	struct elem_list *elem;
	int matches;
	int match[4];
	int match_pt;
	int i;
d495 2
a496 5
	elem = elem_root;
	while( elem )
	{
		matches = 0;
		for( i=0 ; i<elem->no_pts ; i++ )
d498 2
a499 20
			if( pt1 == elem->pt[i] )
			{
				matches += elem_match[i];
				match[i] = pt1;
			}
			else if( pt2 == elem->pt[i] )
			{
				matches += elem_match[i];
				match[i] = pt2;
			}
			else if( pt3 == elem->pt[i] )
			{
				matches += elem_match[i];
				match[i] = pt3;
			}
			else
				match[i] = 0;

			if( match[i] )
				match_pt = match[i];
d501 1
a501 2

		if( matches < 3 )
d503 4
a506 2
			elem = elem->next;
			continue;
d508 1
a508 2

		if( elem->no_pts == 4 )
d510 4
a513 150
			vect_t v0;

			switch( matches )
			{
				case 7:
				case 13:
					bu_log( "Check_tri_overlap: ERROR found duplicate face!!!\n" );
					return( elem->element );
				case 11:
				case 14:
					/* overlap */
					return( elem->element );
				case 3:
				case 5:
				case 6:
				case 9:
				case 10:
				case 12:
					switch( matches )
					{
						case 3:
							VSUB2( v0, grid_pts[elem->pt[0]], grid_pts[elem->pt[1]] );
							break;
						case 5:
							VSUB2( v0, grid_pts[elem->pt[0]], grid_pts[elem->pt[2]] );
							break;
						case 6:
							VSUB2( v0, grid_pts[elem->pt[1]], grid_pts[elem->pt[2]] );
							break;
						case 9:
							VSUB2( v0, grid_pts[elem->pt[0]], grid_pts[elem->pt[3]] );
							break;
						case 10:
							VSUB2( v0, grid_pts[elem->pt[1]], grid_pts[elem->pt[3]] );
							break;
						case 12:
							VSUB2( v0, grid_pts[elem->pt[2]], grid_pts[elem->pt[3]] );
							break;
					}
					/* one edge in common */
					{
						int found=0;
						int odd_pt=0;
						plane_t pl1, pl2;
						vect_t v1, v2;
						fastf_t dot;

						if( bn_mk_plane_3pts( pl1,
							grid_pts[pt1],
							grid_pts[pt2],
							grid_pts[pt3], &tol ) )
								break;

						if( bn_mk_plane_3pts( pl2,
							grid_pts[elem->pt[0]],
							grid_pts[elem->pt[1]],
							grid_pts[elem->pt[2]], &tol ) )
								break;

						if( bn_coplanar( pl1, pl2, &tol ) < 1 )
							break;

						/* elements are coplanar,
						 * now check if they overlap */
						for( i=0 ; i<elem->no_pts ; i++ )
						{
							if( match[i] == pt1 )
							{
								found = 1;
								break;
							}
						}

						if( !found )
							odd_pt = pt1;

						if( !odd_pt )
						{
							found = 0;
							for( i=0 ; i<elem->no_pts ; i++ )
							{
								if( match[i] == pt2 )
								{
									found = 1;
									break;
								}
							}
							if( !found )
								odd_pt = pt2;
						}


						if( !odd_pt )
						{
							found = 0;
							for( i=0 ; i<elem->no_pts ; i++ )
							{
								if( match[i] == pt3 )
								{
									found = 1;
									break;
								}
							}
							if( !found )
								odd_pt = pt3;
						}
						/* odd_pt is the point not in common.
						 * Calculate vector from match_pt to odd_pt
						 */
						VSUB2( v1, grid_pts[odd_pt], grid_pts[match_pt] );

						/* Calculate vector from match_pt to
						 * an unmatched point in elem
						 */
						for( i=0 ; i< elem->no_pts ; i++ )
						{
							if( match[i] )
								continue;
							VSUB2( v2, grid_pts[elem->pt[i]], grid_pts[match_pt] );
							break;
						}
						VUNITIZE( v0 );
						dot = VDOT( v1, v0 );
						VJOIN1( v1, v1, -dot, v0 );

						dot = VDOT( v2, v0 );
						VJOIN1( v2, v2, -dot, v0 );

						if( VDOT( v1, v2 ) > 0.0 )
						{
							bu_log( "WARNING: element %d overlaps with element %d\n",
								element_no, elem->element );
						}
					}
			}
		}
		else if( elem->no_pts == 3 )
		{
			switch( matches )
			{
				case 7:
					bu_log( "Check_tri_overlap: ERROR found duplicate face!!!\n" );
					return( elem->element );
				case 3:
				case 5:
				case 6:
					/* one edge in common */
					break;
			}

a514 2

		elem = elem->next;
a515 2

	return( 0 );
d518 7
a524 10
static int
Check_quad_overlap( element_no, pt1, pt2, pt3, pt4 )
int element_no;
int pt1, pt2, pt3, pt4;
{
	struct elem_list *elem;
	int matches;
	int match[4];
	int match_pt;
	int i;
d526 1
a526 1904
	elem = elem_root;
	while( elem )
	{
		vect_t v0;

		matches = 0;
		for( i=0 ; i<elem->no_pts ; i++ )
		{
			if( pt1 == elem->pt[i] )
			{
				matches += elem_match[i];
				match[i] = pt1;
			}
			else if( pt2 == elem->pt[i] )
			{
				matches += elem_match[i];
				match[i] = pt2;
			}
			else if( pt3 == elem->pt[i] )
			{
				matches += elem_match[i];
				match[i] = pt3;
			}
			else if( pt4 == elem->pt[i] )
			{
				matches += elem_match[i];
				match[i] = pt4;
			}
			else
				match[i] = 0;

			if( match[i] )
				match_pt = match[i];
		}

		if( matches < 3 )
		{
			elem = elem->next;
			continue;
		}

		switch( matches )
		{
			case 15:
				/* found matching CQUAD */
				return( elem->element );

			case 7:
			case 13:
				/* overlap, but triangle check should catch this */
				return( 0 );

			case 11:
			case 14:
				/* crossed overlap */
				return( -elem->element );
			case 3:
			case 5:
			case 6:
			case 9:
			case 10:
			case 12:
				switch( matches )
				{
					case 3:
						VSUB2( v0, grid_pts[elem->pt[0]], grid_pts[elem->pt[1]] );
						break;
					case 5:
						VSUB2( v0, grid_pts[elem->pt[0]], grid_pts[elem->pt[2]] );
						break;
					case 6:
						VSUB2( v0, grid_pts[elem->pt[1]], grid_pts[elem->pt[2]] );
						break;
					case 9:
						VSUB2( v0, grid_pts[elem->pt[0]], grid_pts[elem->pt[3]] );
						break;
					case 10:
						VSUB2( v0, grid_pts[elem->pt[1]], grid_pts[elem->pt[3]] );
						break;
					case 12:
						VSUB2( v0, grid_pts[elem->pt[2]], grid_pts[elem->pt[3]] );
						break;
				}
				/* one edge in common */
				{
					int found=0;
					int odd_pt=0;
					plane_t pl1, pl2;
					vect_t v1, v2;
					fastf_t dot;

					if( bn_mk_plane_3pts( pl1,
						grid_pts[pt1],
						grid_pts[pt2],
						grid_pts[pt3], &tol ) )
							break;

					if( bn_mk_plane_3pts( pl2,
						grid_pts[elem->pt[0]],
						grid_pts[elem->pt[1]],
						grid_pts[elem->pt[2]], &tol ) )
							break;

					if( bn_coplanar( pl1, pl2, &tol ) < 1 )
						break;

					/* elements are coplanar,
					 * now check if they overlap */
					for( i=0 ; i<elem->no_pts ; i++ )
					{
						if( match[i] == pt1 )
						{
							found = 1;
							break;
						}
					}

					if( !found )
						odd_pt = pt1;

					if( !odd_pt )
					{
						found = 0;
						for( i=0 ; i<elem->no_pts ; i++ )
						{
							if( match[i] == pt2 )
							{
								found = 1;
								break;
							}
						}
						if( !found )
							odd_pt = pt2;
					}


					if( !odd_pt )
					{
						found = 0;
						for( i=0 ; i<elem->no_pts ; i++ )
						{
							if( match[i] == pt3 )
							{
								found = 1;
								break;
							}
						}
						if( !found )
							odd_pt = pt3;
					}
					/* odd_pt is the point not in common.
					 * Calculate vector from match_pt to odd_pt
					 */
					VSUB2( v1, grid_pts[odd_pt], grid_pts[match_pt] );

					/* Calculate vector from match_pt to
					 * an unmatched point in elem
					 */
					for( i=0 ; i< elem->no_pts ; i++ )
					{
						if( match[i] )
							continue;
						VSUB2( v2, grid_pts[elem->pt[i]], grid_pts[match_pt] );
						break;
					}
					VUNITIZE( v0 );
					dot = VDOT( v1, v0 );
					VJOIN1( v1, v1, -dot, v0 );

					dot = VDOT( v2, v0 );
					VJOIN1( v2, v2, -dot, v0 );

					if( VDOT( v1, v2 ) > 0.0 )
					{
						bu_log( "WARNING: element %d overlaps with element %d\n",
							element_no, elem->element );
					}
				}
		}
		
		elem = elem->next;
	}

	return( 0 );
}

static void
Rm_internal_faces()
{
	int i;
	int XZ_plane;
	struct faceuse *fu;
	struct loopuse *lu;
	struct bu_ptbl stack;

	if( !dup_count )
		return;

	bu_ptbl_init( &stack, 32, "faceuse stack" );

	for( i=0 ; i<dup_count ; i++ )
	{
		fu = dup_fu[i];
		NMG_CK_FACEUSE( fu );

		if( fu->orientation != OT_SAME )
			fu = fu->fumate_p;

		/* only consider faces in the XZ-plane */
		XZ_plane = 1;
		for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
		{
			struct edgeuse *eu;

			if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
				continue;

			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
			{
				if( eu->vu_p->v_p->vg_p->coord[Y] != 0.0 )
				{
					XZ_plane = 0;
					break;
				}
			}
			if( !XZ_plane )
				break;
		}
		if( !XZ_plane )
			continue;

		/* check if fu is inside by checking radial faces */
		for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
		{
			struct edgeuse *eu;

			if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
				continue;

			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
			{
				struct faceuse *fu1,*fu2;

				fu1 = nmg_find_fu_of_eu( eu->radial_p );
				fu2 = nmg_find_fu_of_eu( eu->eumate_p->radial_p );

				if( fu1->fumate_p != fu2 )
					NMG_PUSH( fu, &stack );
			}
		}
	}

	if( !BU_PTBL_END( &stack ) )
	{
		bu_ptbl_free( &stack );
		return;
	}

	while( BU_PTBL_END( &stack ) )
	{
		fu = nmg_pop_fu( &stack );
		NMG_CK_FACEUSE( fu );

		/* only consider faces in the XZ-plane */
		XZ_plane = 1;
		for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
		{
			struct edgeuse *eu;

			if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
				continue;

			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
			{
				if( eu->vu_p->v_p->vg_p->coord[Y] != 0.0 )
				{
					XZ_plane = 0;
					break;
				}
			}
			if( !XZ_plane )
				break;
		}
		if( !XZ_plane )
			continue;

		for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
		{
			struct edgeuse *eu;

			if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
				continue;

			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
			{
				struct faceuse *fu1,*fu2;

				fu1 = nmg_find_fu_of_eu( eu->radial_p );
				fu2 = nmg_find_fu_of_eu( eu->eumate_p->radial_p );

				if( fu1->fumate_p == fu2 && fu1 != fu && fu1 != fu->fumate_p )
				{
					if( fu1->orientation != OT_SAME )
						fu1 = fu1->fumate_p;
					NMG_PUSH( fu1, &stack );
				}
			}
		}

		nmg_kfu( fu );
	}

	bu_ptbl_free( &stack );
}

void
Add_dup( fu )
struct faceuse *fu;
{
	while( dup_count > dup_size-1 )
	{
		dup_size += DUP_BLOCK;
		dup_fu = (struct faceuse **)bu_realloc( (char *)dup_fu, dup_size, "realloc dup_fu" );
	}

	dup_fu[dup_count] = fu;
	dup_count++;
}

void
Add_fu( fu, thick, pos, pt1, pt2, pt3, element_no )
struct faceuse *fu;
fastf_t thick;
int pos;
int pt1, pt2, pt3;
int element_no;
{
	struct fast_fus *fus;

	if( !fus_root )
	{
		fus_root = (struct fast_fus *)bu_malloc( sizeof( struct fast_fus ) , "fus_root" );
		fus = fus_root;
	}
	else
	{
		fus = fus_root;
		while( fus->next )
			fus = fus->next;
		fus->next = (struct fast_fus *)bu_malloc( sizeof( struct fast_fus ) , "fus" );
		fus = fus->next;
	}

	fus->next = (struct fast_fus *)NULL;
	fus->fu = fu;
	fus->thick = thick;
	fus->pos = pos;
	fus->pt1 = pt1;
	fus->pt2 = pt2;
	fus->pt3 = pt3;
	fus->element = element_no;
}
#endif
void
Check_names()
{
	struct name_tree *ptr;

	if( !name_root )
		return;

	bu_ptbl_reset( &stack );

	CK_TREE_MAGIC( name_root )
	/* ident order */
	ptr = name_root;
	while( 1 )
	{
		while( ptr )
		{
			PUSH( ptr );
			ptr = ptr->rleft;
		}
		POP( name_tree , ptr );
		if( !ptr )
			break;

		/* visit node */
		CK_TREE_MAGIC( ptr )
		ptr = ptr->rright;
	}

	/* alpabetical order */
	ptr = name_root;
	while( 1 )
	{
		while( ptr )
		{
			PUSH( ptr );
			ptr = ptr->nleft;
		}
		POP( name_tree , ptr );
		if( !ptr )
			break;

		/* visit node */
		CK_TREE_MAGIC( ptr )
		ptr = ptr->nright;
	}
}

void
insert_int( in )
int in;
{
	int i;

	for( i=0 ; i<int_list_count ; i++ )
	{
		if( int_list[i] == in )
			return;
	}

	if( int_list_count == int_list_length )
	{
		if( int_list_length == 0 )
			int_list = (int *)bu_malloc( INT_LIST_BLOCK*sizeof( int ) , "insert_id: int_list" );
		else
			int_list = (int *)rt_realloc( (char *)int_list , (int_list_length + INT_LIST_BLOCK)*sizeof( int ) , "insert_id: int_list" );
		int_list_length += INT_LIST_BLOCK;
	}

	int_list[int_list_count] = in;
	int_list_count++;

	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in insert_int\n" );
}

void
tmp_shell_coplanar_face_merge( s, tmp_tol, simplify )
struct shell		*s;
CONST struct bn_tol	*tmp_tol;
CONST int		simplify;
{
	struct model	*m;
	int		len;
	char		*flags1;
	char		*flags2;
	struct faceuse	*fu1;
	struct faceuse	*fu2;
	struct face	*f1;
	struct face	*f2;
	struct face_g_plane	*fg1;
	struct face_g_plane	*fg2;

	NMG_CK_SHELL(s);
	m = nmg_find_model( &s->l.magic );
	len = sizeof(char) * m->maxindex * 2;
	flags1 = (char *)bu_calloc( sizeof(char), m->maxindex * 2,
		"tmp_shell_coplanar_face_mergetmp flags1[]" );
	flags2 = (char *)bu_calloc( sizeof(char), m->maxindex * 2,
		"tmp_shell_coplanar_face_merge flags2[]" );

	/* Visit each face in the shell */
	for( BU_LIST_FOR( fu1, faceuse, &s->fu_hd ) )  {
		plane_t		n1;

		if( BU_LIST_NEXT_IS_HEAD(fu1, &s->fu_hd) )  break;
		f1 = fu1->f_p;
		NMG_CK_FACE(f1);
		if( NMG_INDEX_TEST(flags1, f1) )  continue;
		NMG_INDEX_SET(flags1, f1);

		fg1 = f1->g.plane_p;
		NMG_CK_FACE_G_PLANE(fg1);
		NMG_GET_FU_PLANE( n1, fu1 );

		/* For this face, visit all remaining faces in the shell. */
		/* Don't revisit any faces already considered. */
		bcopy( flags1, flags2, len );
		for( fu2 = BU_LIST_NEXT(faceuse, &fu1->l);
		     BU_LIST_NOT_HEAD(fu2, &s->fu_hd);
		     fu2 = BU_LIST_NEXT(faceuse,&fu2->l)
		)  {
			register fastf_t	dist;
			plane_t			n2;

			f2 = fu2->f_p;
			NMG_CK_FACE(f2);
			if( NMG_INDEX_TEST(flags2, f2) )  continue;
			NMG_INDEX_SET(flags2, f2);

			fg2 = f2->g.plane_p;
			NMG_CK_FACE_G_PLANE(fg2);

			if( fu2->fumate_p == fu1 || fu1->fumate_p == fu2 )
				rt_bomb("tmp_shell_coplanar_face_merge() mate confusion\n");

			/* See if face geometry is shared & same direction */
			if( fg1 != fg2 || f1->flip != f2->flip )  {
				/* If plane equations are different, done */
				NMG_GET_FU_PLANE( n2, fu2 );

				/* Compare distances from origin */
				dist = n1[3] - n2[3];
				if( !NEAR_ZERO(dist, tmp_tol->dist) )  continue;

				/*
				 *  Compare angle between normals.
				 *  Can't just use BN_VECT_ARE_PARALLEL here,
				 *  because they must point in the same direction.
				 */
				dist = VDOT( n1, n2 );
				if( !(dist >= tmp_tol->para) )  continue;
			}

			/*
			 * Plane equations are the same, within tolerance,
			 * or by shared fg topology.
			 * Move everything into fu1, and
			 * kill now empty faceuse, fumate, and face
			 */
			{
				struct faceuse	*prev_fu;

				prev_fu = BU_LIST_PREV(faceuse, &fu2->l);
				/* The prev_fu can never be the head */
				if( BU_LIST_IS_HEAD(prev_fu, &s->fu_hd) )
					rt_bomb("prev is head?\n");
				if( nmg_ck_fu_verts( fu1 , fu1->f_p , tmp_tol ) )
					rt_bomb( "tmp_shell_coplanar_face_merge: verts not on face\n" );

				if( !nmg_ck_fg_verts( fu2 , fu1->f_p , tmp_tol ) )
				{
					if( debug )
					{
						bu_log( "Merging coplanar faces:\n" );
						bu_log( "plane = ( %f %f %f %f )\n" , V4ARGS( fu1->f_p->g.plane_p->N ) );
						nmg_pr_fu_briefly( fu1 , (char *)NULL );
						bu_log( "plane = ( %f %f %f %f )\n" , V4ARGS( fu2->f_p->g.plane_p->N ) );
						nmg_pr_fu_briefly( fu2 , (char *)NULL );
					}
					nmg_jf( fu1, fu2 );
					if( nmg_ck_fg_verts( fu1 , fu1->f_p , tmp_tol ) )
						rt_bomb( "tmp_coplanar_face_merge: joined faces made bad face\n" );
				}

				fu2 = prev_fu;
			}

			/* There is now the option of simplifying the face,
			 * by removing unnecessary edges.
			 */
			if( simplify )  {
				struct loopuse *lu;

				for (BU_LIST_FOR(lu, loopuse, &fu1->lu_hd))
					nmg_simplify_loop(lu);
			}
		}
	}
	bu_free( (char *)flags1, "tmp_shell_coplanar_face_merge flags1[]" );
	bu_free( (char *)flags2, "tmp_shell_coplanar_face_merge flags2[]" );

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("tmp_shell_coplanar_face_merge(s=x%x, tol=x%x, simplify=%d)\n",
			s, tmp_tol, simplify);
	}
	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in tmp_shell_coplanar_face_merge\n" );
}

void
Subtract_holes( head , comp_id , group_id )
struct wmember *head;
int comp_id;
int group_id;
{
	struct holes *hole_ptr;
	struct hole_list *list_ptr;

	if( debug )
		bu_log( "Subtract_holes( comp_id=%d, group_id=%d )\n" , comp_id , group_id );

	hole_ptr = hole_root;
	while( hole_ptr )
	{
		if( hole_ptr->group == group_id && hole_ptr->component == comp_id )
		{
			list_ptr = hole_ptr->holes;
			while( list_ptr )
			{
				struct name_tree *ptr;
				int reg_id;

				reg_id = list_ptr->group * 1000 + list_ptr->component;
				ptr = name_root;
				while( ptr && ptr->region_id != reg_id )
				{
					int diff;

					diff = reg_id - ptr->region_id;
					if( diff > 0 )
						ptr = ptr->rright;
					else if( diff < 0 )
						ptr = ptr->rleft;
				}

				if( !ptr || ptr->region_id != reg_id )
				{
					bu_log( "ERROR: Can't find holes to subtract for group %d, component %d\n" , group_id , comp_id );
					return;
				}

				bu_ptbl_reset( &stack );

				while( ptr && ptr->region_id == reg_id )
				{
					while( ptr && ptr->region_id == reg_id )
					{
						PUSH( ptr );
						ptr = ptr->rleft;
					}
					POP( name_tree , ptr );
					if( !ptr ||  ptr->region_id != reg_id )
						break;

					if( mk_addmember( ptr->name , head , WMOP_SUBTRACT ) == (struct wmember *)NULL )
						rt_bomb( "Subtract_holes: mk_addmember failed\n" );

					ptr = ptr->rright;
				}

				list_ptr = list_ptr->next;
			}
			break;
		}
		hole_ptr = hole_ptr->next;
	}
	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in subtract_holes\n" );
}

void
List_holes()
{
	struct holes *hole_ptr;
	struct hole_list *list_ptr;

	hole_ptr = hole_root;

	while( hole_ptr )
	{
		bu_log( "Holes for Group %d, Component %d:\n" , hole_ptr->group, hole_ptr->component );
		list_ptr = hole_ptr->holes;
		while( list_ptr )
		{
			bu_log( "\tgroup %d component %d\n" , list_ptr->group, list_ptr->component );
			list_ptr = list_ptr->next;
		}
		hole_ptr = hole_ptr->next;
	}
}

void
List_names()
{
	struct name_tree *ptr;

	bu_ptbl_reset( &stack );

	bu_log( "\nNames in ident order:\n" );
	ptr = name_root;
	while( 1 )
	{
		while( ptr )
		{
			PUSH( ptr );
			ptr = ptr->rleft;
		}
		POP( name_tree , ptr );
		if( !ptr )
			break;

		bu_log( "%s %d %d\n" , ptr->name , ptr->region_id , ptr->element_id );
		ptr = ptr->rright;
	}

	bu_log( "\tAlphabetical list of names:\n" );
	ptr = name_root;
	while( 1 )
	{
		while( ptr )
		{
			PUSH( ptr );
			ptr = ptr->nleft;
		}
		POP( name_tree , ptr );
		if( !ptr )
			break;

		bu_log( "%s\n" , ptr->name );
		ptr = ptr->nright;
	}
}

struct name_tree *
Search_names( root , name , found )
struct name_tree *root;
char *name;
int *found;
{
	struct name_tree *ptr;

	*found = 0;

	ptr = root;
	if( !ptr )
		return( (struct name_tree *)NULL );

	while( 1 )
	{
		int diff;

		diff = strcmp( name , ptr->name );
		if( diff == 0 )
		{
			*found = 1;
			return( ptr );
		}
		else if( diff > 0 )
		{
			if( ptr->nright )
				ptr = ptr->nright;
			else
				return( ptr );
		}
		else if( diff < 0 )
		{
			if( ptr->nleft )
				ptr = ptr->nleft;
			else
				return( ptr );
		}
	}
}

char *
find_nmg_region_name( g_id, c_id )
int g_id;
int c_id;
{
	int reg_id;
	struct name_tree *ptr;

	reg_id = g_id*1000 + c_id;

	ptr = name_root;
	if( !ptr )
		return( (char *)NULL );

	while( 1 )
	{
		int diff;

		diff = reg_id - ptr->region_id;
		if( diff == 0 )
		{
			int len;

			len = strlen( ptr->name );
			if( !strcmp( &ptr->name[len-4] , ".n.r" ) )
				return( ptr->name );
			else
			{
				if( ptr->rright )
					ptr = ptr->rright;
				else
					return( (char *)NULL );
			}
		}
		else if( diff > 0 )
		{
			if( ptr->rright )
				ptr = ptr->rright;
			else
				return( (char *)NULL );
		}
		else if( diff < 0 )
		{
			if( ptr->rleft )
				ptr = ptr->rleft;
			else
				return( (char *)NULL );
		}
	}
}

struct name_tree *
Search_ident( root , reg_id , el_id , found )
struct name_tree *root;
int reg_id;
int el_id;
int *found;
{
	struct name_tree *ptr;

	*found = 0;

	ptr = root;
	if( !ptr )
		return( (struct name_tree *)NULL );

	while( 1 )
	{
		int diff;

		diff = reg_id -  ptr->region_id;
		if( diff == 0 )
			diff = el_id - ptr->element_id;

		if( diff == 0 )
		{
			*found = 1;
			return( ptr );
		}
		else if( diff > 0 )
		{
			if( ptr->rright )
				ptr = ptr->rright;
			else
				return( ptr );
		}
		else if( diff < 0 )
		{
			if( ptr->rleft )
				ptr = ptr->rleft;
			else
				return( ptr );
		}
	}
}

void
Delete_name( root , name )
struct name_tree **root;
char *name;
{
	struct name_tree *ptr,*parent,*ptr2;
	int r_id, e_id;
	int found;
	int diff;

	/* first delete from name portion of tree */
	ptr = *root;
	parent = (struct name_tree *)NULL;
	found = 0;

	while( 1 )
	{
		diff = strcmp( name , ptr->name );
		if( diff == 0 )
		{
			found = 1;
			break;
		}
		else if( diff > 0 )
		{
			if( ptr->nright )
			{
				parent = ptr;
				ptr = ptr->nright;
			}
			else
				break;
		}
		else if( diff < 0 )
		{
			if( ptr->nleft )
			{
				parent = ptr;
				ptr = ptr->nleft;
			}
			else
				break;
		}
	}

	if( !found )
		return;

	r_id = ptr->region_id;
	e_id = ptr->element_id;

	if( parent == (struct name_tree *)NULL )
	{
		if( ptr->nright )
		{
			*root = ptr->nright;
			ptr2 = *root;
			while( ptr2->nleft )
				ptr2 = ptr2->nleft;
			ptr2->nleft = ptr->nleft;

			ptr2 = *root;
			while( ptr2->rleft )
				ptr2 = ptr2->rleft;
			ptr2->rleft = ptr->rleft;
		}
		else if( ptr->nleft )
		{
			*root = ptr->nleft;
			ptr2 = *root;
			while( ptr2->nright )
				ptr2 = ptr2->nright;
			ptr2->nright = ptr->nright;
			ptr2 = *root;
			while( ptr2->rright )
				ptr2 = ptr2->rright;
			ptr2->rright = ptr->rright;
		}
		else
		{
			/* This was the only name in the tree */
			*root = (struct name_tree *)NULL;
		}
		bu_free( (char *)ptr , "Delete_name: ptr" );
		if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
			bu_log( "ERROR: bu_mem_barriercheck failed in Delete_name\n" );
		return;
	}
	else
	{
		if( parent->nright == ptr )
		{
			if( ptr->nleft )
			{
				parent->nright = ptr->nleft;
				ptr2 = ptr->nleft;
				while( ptr2->nright )
					ptr2 = ptr2->nright;
				ptr2->nright = ptr->nright;
			}
			else
				parent->nright = ptr->nright;
		}
		else if( parent->nleft == ptr )
		{
			if( ptr->nright )
			{
				parent->nleft = ptr->nright;
				ptr2 = ptr->nright;
				while( ptr2->nleft )
					ptr2 = ptr2->nleft;
				ptr2->nleft = ptr->nleft;
			}
			else
				parent->nleft = ptr->nleft;
		}
	}


	/* now delete from ident prtion of tree */
	ptr = *root;
	parent = (struct name_tree *)NULL;
	found = 0;

	while( 1 )
	{
		diff = r_id - ptr->region_id;
		if( diff == 0 )
			diff = e_id - ptr->element_id;

		if( diff == 0 )
		{
			found = 1;
			break;
		}
		else if( diff > 0 )
		{
			if( ptr->rright )
			{
				parent = ptr;
				ptr = ptr->rright;
			}
			else
				break;
		}
		else if( diff < 0 )
		{
			if( ptr->rleft )
			{
				parent = ptr;
				ptr = ptr->rleft;
			}
			else
				break;
		}
	}

	if( !found )
	{
		bu_log( "name (%s) deleted from name tree, but not found in ident tree!!\n" , name );
		rt_bomb( "Delete_name\n" );
	}

	if( !parent )
	{
		bu_log( "name (%s) is root of ident tree, but not name tree!!\n" , name );
		rt_bomb( "Delete_name\n" );
	}


	if( parent->rright == ptr )
	{
		if( ptr->rleft )
		{
			parent->rright = ptr->rleft;
			ptr2 = ptr->rleft;
			while( ptr2->rright )
				ptr2 = ptr2->rright;
			ptr2->rright = ptr->rright;
		}
		else
			parent->rright = ptr->rright;
	}
	else if( parent->rleft == ptr )
	{
		if( ptr->rright )
		{
			parent->rleft = ptr->rright;
			ptr2 = ptr->rright;
			while( ptr2->rleft )
				ptr2 = ptr2->rleft;
			ptr2->rleft = ptr->rleft;
		}
		else
			parent->rleft = ptr->rleft;
	}
	bu_free( (char *)ptr , "Delete_name: ptr" );
	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in Delete_name\n" );
	Check_names();
}

void
Insert_name( root , name )
struct name_tree **root;
char *name;
{
	struct name_tree *ptr;
	struct name_tree *new_ptr;
	int found;
	int diff;

	ptr = Search_names( *root , name , &found );

	if( found )
	{
		bu_log( "Insert_name: %s already in name tree\n" , name );
		return;
	}

	new_ptr = (struct name_tree *)bu_malloc( sizeof( struct name_tree ) , "Insert_name: new_ptr" );

	strncpy( new_ptr->name , name , NAMESIZE+1 );
	new_ptr->nleft = (struct name_tree *)NULL;
	new_ptr->nright = (struct name_tree *)NULL;
	new_ptr->rleft = (struct name_tree *)NULL;
	new_ptr->rright = (struct name_tree *)NULL;
	new_ptr->region_id = (-region_id);
	new_ptr->in_comp_group = 0;
	new_ptr->element_id = 0;
	new_ptr->magic = NAME_TREE_MAGIC;

	if( !*root )
	{
		*root = new_ptr;
		return;
	}

	diff = strncmp( name , ptr->name , NAMESIZE );
	if( diff > 0 )
	{
		if( ptr->nright )
		{
			bu_log( "Insert_name: ptr->nright not null\n" );
			rt_bomb( "\tCannot insert new node\n" );
		}
		ptr->nright = new_ptr;
	}
	else
	{
		if( ptr->nleft )
		{
			bu_log( "Insert_name: ptr->nleft not null\n" );
			rt_bomb( "\tCannot insert new node\n" );
		}
		ptr->nleft = new_ptr;
	}
	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in Insert_name\n" );
}

void
Insert_region_name( name , reg_id , el_id )
char *name;
int reg_id;
int el_id;
{
	struct name_tree *nptr_model,*rptr_model;
	struct name_tree *new_ptr;
	int foundn,foundr;
	int diff;

	if( debug )
		bu_log( "Insert_region_name( name=%s, reg_id=%d, el_id=%d\n" , name, reg_id, el_id );

	rptr_model = Search_ident( name_root , reg_id , el_id , &foundr );
	nptr_model = Search_names( name_root , name , &foundn );

	if( foundn && foundr )
		return;

	if( foundn != foundr )
	{
		bu_log( "Insert_region_name: name %s ident %d element %d\n\tfound name is %d\n\tfound ident is %d\n",
			name, reg_id, el_id, foundn, foundr );
		List_names();
		rt_bomb( "\tCannot insert new node\n" );
	}

	/* Add to tree for entire model */
	new_ptr = (struct name_tree *)bu_malloc( sizeof( struct name_tree ) , "Insert_region_name: new_ptr" );
	new_ptr->rleft = (struct name_tree *)NULL;
	new_ptr->rright = (struct name_tree *)NULL;
	new_ptr->nleft = (struct name_tree *)NULL;
	new_ptr->nright = (struct name_tree *)NULL;
	new_ptr->region_id = reg_id;
	new_ptr->element_id = el_id;
	new_ptr->in_comp_group = 0;
	strncpy( new_ptr->name , name , NAMESIZE+1 );
	new_ptr->magic = NAME_TREE_MAGIC;

	if( !name_root )
		name_root = new_ptr;
	else
	{
		diff = strncmp( name , nptr_model->name , NAMESIZE );

		if( diff > 0 )
		{
			if( nptr_model->nright )
			{
				bu_log( "Insert_region_name: nptr_model->nright not null\n" );
				rt_bomb( "\tCannot insert new node\n" );
			}
			nptr_model->nright = new_ptr;
		}
		else
		{
			if( nptr_model->nleft )
			{
				bu_log( "Insert_region_name: nptr_model->nleft not null\n" );
				rt_bomb( "\tCannot insert new node\n" );
			}
			nptr_model->nleft = new_ptr;
		}


		diff = reg_id - rptr_model->region_id;

		if( diff == 0 )
			diff = el_id - rptr_model->element_id;

		if( diff > 0 )
		{
			if( rptr_model->rright )
			{
				bu_log( "Insert_region_name: rptr_model->rright not null\n" );
				rt_bomb( "\tCannot insert new node\n" );
			}
			rptr_model->rright = new_ptr;
		}
		else
		{
			if( rptr_model->rleft )
			{
				bu_log( "Insert_region_name: rptr_model->rleft not null\n" );
				rt_bomb( "\tCannot insert new node\n" );
			}
			rptr_model->rleft = new_ptr;
		}
	}
	Check_names();
	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in Insert_region_name\n" );
}

char *
find_region_name( g_id , c_id , el_id )
int g_id;
int c_id;
int el_id;
{
	struct name_tree *ptr;
	int reg_id;
	int found;

	reg_id = g_id * 1000 + c_id;

	if( debug )
		bu_log( "find_region_name( g_id=%d, c_id=%d, el_id=%d ), reg_id=%d\n" , g_id, c_id, el_id, reg_id );

	ptr = Search_ident( name_root , reg_id , el_id , &found );

	if( found )
		return( ptr->name );
	else
		return( (char *)NULL );
}

void
make_unique_name( name )
char *name;
{
	char append[10];
	int append_len;
	int len;
	int found;

	/* make a unique name from what we got off the $NAME card */

	len = strlen( name );

	(void)Search_names( name_root , name , &found );
	while( found )
	{
		sprintf( append , "_%d" , name_count );
		name_count++;
		append_len = strlen( append );

		if( len + append_len < NAMESIZE )
			strcat( name , append );
		else
		{
			strcpy( &name[NAMESIZE-append_len] , append );
			name[NAMESIZE] = '\0';
		}

		(void)Search_names( name_root , name , &found );
	}
	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in make_unique_name\n" );
}

void
add_to_series( name , reg_id )
char *name;
int reg_id;
{
	if( group_id < 0 || group_id > 10 )
	{
		bu_log( "add_to_series: region (%s) not added, illegal group number %d, region_id=$d\n" ,
			name , group_id , reg_id );
		return;
	}

	if( mk_addmember( name , &group_head[group_id] , WMOP_UNION ) == (struct wmember *)NULL )
		bu_log( "add_to_series: mk_addmember failed for region %s\n" , name );
}

void
make_comp_group()
{
	struct wmember g_head;
	struct name_tree *ptr;
	char name[NAMESIZE+1];

	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in make_comp_group\n" );

	BU_LIST_INIT( &g_head.l );

	bu_ptbl_reset( &stack );

	ptr = name_root;
	while( 1 )
	{
		while( ptr )
		{
			PUSH( ptr );
			ptr = ptr->nleft;
		}
		POP( name_tree , ptr );
		if( !ptr )
			break;

		if(ptr->region_id == region_id && ptr->element_id && !ptr->in_comp_group )
		{
			if( mk_addmember( ptr->name , &g_head , WMOP_UNION ) == (struct wmember *)NULL )
			{
				bu_log( "make_comp_group: Could not add %s to group for ident %d\n" , ptr->name , ptr->region_id );
				break;
			}
			ptr->in_comp_group = 1;
		}
		ptr = ptr->nright;
	}

	if( BU_LIST_NON_EMPTY( &g_head.l ) )
	{
		char *tmp_name;

		if( (tmp_name=find_region_name( group_id , comp_id , 0 )) )
			strcpy( name , tmp_name );
		else
		{
			sprintf( name , "comp_%d" , region_id );
			make_unique_name( name );
			if( warnings )
				bu_log( "Creating default name (%s) for group %d component %d\n",
						name , group_id , comp_id );
			Insert_name( &name_root , name );
		}

		mk_lfcomb( fdout , name , &g_head , 0 );
		if( !is_a_hole( region_id ) )
			add_to_series( name , region_id );
		else
			add_to_holes( name, region_id );
	}
}

void
do_groups()
{
	int group_no;
	struct wmember head_all;

	if( debug )
		bu_log( "do_groups\n" );

	BU_LIST_INIT( &head_all.l );

	for( group_no=0 ; group_no < 11 ; group_no++ )
	{
		char name[NAMESIZE+1];

		if( BU_LIST_IS_EMPTY( &group_head[group_no].l ) )
			continue;

		sprintf( name , "%dxxx_series" , group_no );
		mk_lfcomb( fdout , name , &group_head[group_no] , 0 );

		if( mk_addmember( name , &head_all , WMOP_UNION ) == (struct wmember *)NULL )
			bu_log( "do_groups: mk_addmember failed to add %s to group all\n" , name );
	}

	if( BU_LIST_NON_EMPTY( &head_all.l ) )
		mk_lfcomb( fdout , "all" , &head_all , 0 );

	if( BU_LIST_NON_EMPTY( &hole_head.l ) )
		mk_lfcomb( fdout , "holes" , &hole_head , 0 );
}

void
do_name()
{
	int i,j;
	int g_id;
	int c_id;
	int len;
	char comp_name[25];
	char tmp_name[25];

	if( pass )
		return;

	if( debug )
		bu_log( "do_name: %s\n" , line );

	strncpy( field , &line[8] , 8 );
	g_id = atoi( field );

	if( g_id != group_id )
	{
		bu_log( "$NAME card for group %d in section for group %d ignored\n" , g_id , group_id );
		bu_log( "%s\n" , line );
		return;
	}

	strncpy( field , &line[16] , 8 );
	c_id = atoi( field );

	if( c_id != comp_id )
	{
		bu_log( "$NAME card for component %d in section for component %d ignored\n" , c_id , comp_id );
		bu_log( "%s\n" , line );
		return;
	}

	strncpy( comp_name , &line[56] , 24 );

	/* eliminate trailing blanks */
	i = 26;
	while(  --i >= 0 && isspace( comp_name[i] ) )
		comp_name[i] = '\0';

	/* copy comp_name to tmp_name while replacing white space with "_" */
	i = (-1);
	j = (-1);

	/* copy */
	while( comp_name[++i] != '\0' )
	{
		if( isspace( comp_name[i] ) || comp_name[i] == '/' )
		{
			if( j == (-1) || tmp_name[j] != '_' )
				tmp_name[++j] = '_';
		}
		else
			tmp_name[++j] = comp_name[i];
	}
	tmp_name[++j] = '\0';

	len = strlen( tmp_name );
	if( len <= NAMESIZE )
		strncpy( name_name , tmp_name , NAMESIZE );
	else
		strncpy( name_name , &tmp_name[len-NAMESIZE] , NAMESIZE );
	name_name[NAMESIZE] = '\0';

	/* reserve this name for group name */
	make_unique_name( name_name );
	Insert_region_name( name_name , region_id , 0 );

	name_count = 0;
	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in do_name\n" );
}

void
make_region_name( name , g_id , c_id , element_id , type )
char *name;
int g_id;
int c_id;
int element_id;
char type;
{
	int r_id;
	char *tmp_name;

	r_id = g_id * 1000 + c_id;

	if( debug )
		bu_log( "make_region_name( g_id=%d, c_id=%d, element_id=%d, type=%c )\n" , g_id, c_id, element_id, type );

	tmp_name = find_region_name( g_id , c_id , element_id );
	if( tmp_name )
	{
		strncpy( name , tmp_name , NAMESIZE+1 );
		return;
	}

	/* create a new name */
	if( name_name[0] )
		strncpy( name , name_name , NAMESIZE+1 );
	else if( element_id < 0 && type == CLINE )
		sprintf( name , "%d.j.%d.r" , r_id , joint_no++ );
	else
		sprintf( name , "%d.%d.%c.r" , r_id , element_id , type );

	make_unique_name( name );

	Insert_region_name( name , r_id , element_id );
}

void
get_solid_name( name , type , element_id , c_id , g_id , inner )
char *name;
char type;
int element_id;
int c_id;
int g_id;
int inner;
{
	int reg_id;

	reg_id = g_id * 1000 + c_id;

	sprintf( name , "%d.%d.%c%d" , reg_id , element_id , type , inner );
}

void
make_solid_name( name , type , element_id , c_id , g_id , inner )
char *name;
char type;
int element_id;
int c_id;
int g_id;
int inner;
{
	get_solid_name( name , type , element_id , c_id , g_id , inner );

	Insert_name( &name_root , name );
}

void
do_grid()
{
	int grid_no;
	fastf_t x,y,z;

	if( !pass )	/* not doing geometry yet */
		return;

	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed at start of do_grid\n" );

	strncpy( field , &line[8] , 8 );
	grid_no = atoi( field );

	if( grid_no < 1 )
	{
		bu_log( "ERROR: grid id number = %d\n" , grid_no );
		rt_bomb( "BAD GRID ID NUMBER\n" );
	}

	strncpy( field , &line[24] , 8 );
	x = atof( field );

	strncpy( field , &line[32] , 8 );
	y = atof( field );

	strncpy( field , &line[40] , 8 );
	z = atof( field );

	while( grid_no > grid_size - 1 )
	{
		grid_size += GRID_BLOCK;
		grid_pts = (point_t *)rt_realloc( (char *)grid_pts , grid_size * sizeof( point_t ) , "fast4-g: grid_pts" );
	}

	VSET( grid_pts[grid_no] , x*25.4 , y*25.4 , z*25.4 );

	if( grid_no > max_grid_no )
		max_grid_no = grid_no;
	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed at end of do_grid\n" );
}

void
make_cline_regions()
{
	struct cline *cline_ptr;
	struct wmember head;
	char name[NAMESIZE+1];
	int sph_no;

	if( debug )
		bu_log( "make_cline_regions\n" );

	BU_LIST_INIT( &head.l );

	/* make a list of all the endpoints */
	cline_ptr = cline_root;
	while( cline_ptr )
	{
		/* Add endpoints to points list */
		insert_int( cline_ptr->pt1 );
		insert_int( cline_ptr->pt2 );
		
		cline_ptr = cline_ptr->next;
	}

	/* Now build cline objects */
	for( sph_no=0 ; sph_no < int_list_count ; sph_no++ )
	{
		int pt_no;
		int line_no;
		struct bu_ptbl lines;
		fastf_t sph_radius=0.0;
		fastf_t sph_inner_radius=0.0;

		bu_ptbl_init( &lines , 64, " &lines ");

		pt_no = int_list[sph_no];

		/* get list of clines that touch this point */
		cline_ptr = cline_root;
		while( cline_ptr )
		{
			if( cline_ptr->pt1 == pt_no || cline_ptr->pt2 == pt_no )
			{
				/* get outer radius for sphere */
				if( cline_ptr->radius > sph_radius )
					sph_radius = cline_ptr->radius;

				/* get inner radius for sphere */
				if( cline_ptr->thick > 0.0 &&
				    (cline_ptr->radius - cline_ptr->thick > sph_inner_radius ) )
					sph_inner_radius =  cline_ptr->radius - cline_ptr->thick;

				bu_ptbl_ins( &lines , (long *)cline_ptr );
			}

			cline_ptr = cline_ptr->next;
		}

		if( BU_PTBL_END( &lines ) > 1 )
		{
			/* make a joint where CLINE's meet */

			/* make sphere solid at cline joint */
			sprintf( name , "%d.%d.j0" , region_id , pt_no );
			Insert_name( &name_root , name );
			mk_sph( fdout , name , grid_pts[pt_no] , sph_radius );

			/* Union sphere */
			if( mk_addmember( name , &head , WMOP_UNION ) == (struct wmember *)NULL )
			{
				bu_log( "make_cline_regions: mk_addmember failed for outer sphere %s\n" , name );
				bu_ptbl_free( &lines );
				break;
			}

			/* subtract inner sphere if required */
			if( sph_inner_radius > 0.0 && sph_inner_radius < sph_radius )
			{
				sprintf( name , "%d.%d.j1" , region_id , pt_no );
				Insert_name( &name_root , name );
				mk_sph( fdout , name , grid_pts[pt_no] , sph_inner_radius );

				if( mk_addmember( name , &head , WMOP_SUBTRACT ) == (struct wmember *)NULL )
				{
					bu_log( "make_cline_regions: mk_addmember failed for outer sphere %s\n" , name );
					bu_ptbl_free( &lines );
					break;
				}
			}

			/* subtract all outer cylinders that touch this point */
			for( line_no=0 ; line_no < BU_PTBL_END( &lines ) ; line_no++ )
			{
				cline_ptr = (struct cline *)BU_PTBL_GET( &lines , line_no );

				get_solid_name( name , CLINE , cline_ptr->element_id , comp_id , group_id , 0 );
				if( mk_addmember( name , &head , WMOP_SUBTRACT ) == (struct wmember *)NULL )
				{
					bu_log( "make_cline_regions: mk_addmember failed for line at joint %s\n" , name );
					bu_ptbl_free( &lines );
					break;
				}
			}

			/* subtract any holes for this component */
			Subtract_holes( &head , comp_id , group_id );

			/* now make the region */
			if( BU_LIST_NON_EMPTY( &head.l ) )
				MK_REGION( fdout , &head , group_id , comp_id , -pt_no , CLINE )
		}
		else
		{
			char *bad_name;

			/* no need for a region here
			 * but we need to remove this region from the name tree
			 */
			bad_name = find_region_name( group_id , comp_id , -pt_no );
			if( bad_name )
				Delete_name( &name_root , bad_name );
		}

		/* make regions for all CLINE elements that start at this pt_no */
		for( line_no=0 ; line_no < BU_PTBL_END( &lines ) ; line_no++ )
		{
			int i;
			cline_ptr = (struct cline *)BU_PTBL_GET( &lines , line_no ) ;
			if( cline_ptr->pt1 != pt_no )
				continue;

			/* make name for outer cylinder */
			get_solid_name( name , CLINE , cline_ptr->element_id , comp_id , group_id , 0 );

			/* start region */
			if( mk_addmember( name , &head , WMOP_UNION ) == (struct wmember *)NULL )
			{
				bu_log( "make_cline_regions: mk_addmember failed for outer solid %s\n" , name );
				break;
			}
			cline_ptr->made = 1;

			if( cline_ptr->thick > 0.0 )
			{
				/* subtract inside cylinder */
				get_solid_name( name , CLINE , cline_ptr->element_id , comp_id , group_id , 1 );
				if( mk_addmember( name , &head , WMOP_SUBTRACT ) == (struct wmember *)NULL )
				{
					bu_log( "make_cline_regions: mk_addmember failed for inner solid %s\n" , name );
					break;
				}
			}

			/* subtract outside cylinders of any other clines that use this grid point */
			for( i=0 ; i < BU_PTBL_END( &lines ) ; i++ )
			{
				struct cline *ptr2;

				ptr2 = (struct cline *)BU_PTBL_GET( &lines , i );

				if( ptr2 != cline_ptr &&
				    ptr2->pt1 == pt_no || ptr2->pt2 == pt_no )
				{
					get_solid_name( name , CLINE , ptr2->element_id , comp_id , group_id , 0 );
					if( mk_addmember( name , &head , WMOP_SUBTRACT ) == (struct wmember *)NULL )
					{
						bu_log( "make_cline_regions: mk_addmember failed for inner solid %s\n" , name );
						break;
					}
				}
			}

			/* subtract any holes for this component */
			Subtract_holes( &head , comp_id , group_id );

			/* make the region */
			MK_REGION( fdout , &head , group_id , comp_id , cline_ptr->element_id , CLINE );
		}
		bu_ptbl_free( &lines );
	}

	int_list_count = 0;

	/* free the linked list of cline pointers */
	cline_ptr = cline_root;
	while( cline_ptr )
	{
		struct cline *ptr;

		ptr = cline_ptr;
		cline_ptr = cline_ptr->next;

		bu_free( (char *)ptr , "make_cline_regions: cline_ptr" );
	}

	cline_root = (struct cline *)NULL;
	cline_last_ptr = (struct cline *)NULL;

	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in make_cline_regions\n" );

}

void
do_sphere()
{
	int element_id;
	int center_pt;
	fastf_t thick;
	fastf_t radius;
	fastf_t inner_radius;
	char name[NAMESIZE+1];
	struct wmember sphere_region;

	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );

	if( !pass )
	{
		make_region_name( name , group_id , comp_id , element_id , CSPHERE );
		return;
	}

	strncpy( field , &line[24] , 8 );
	center_pt = atoi( field );

	strncpy( field , &line[56] , 8 );
	thick = atof( field ) * 25.4;

	strncpy( field , &line[64] , 8 );
	radius = atof( field ) * 25.4;
	if( radius <= 0.0 )
	{
		bu_log( "do_sphere: illegal radius (%f), skipping sphere\n" , radius );
		bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
		return;
	}

	if( center_pt < 1 || center_pt > max_grid_no )
	{
		bu_log( "do_sphere: illegal grid number for center point %d, skipping sphere\n" , center_pt );
		bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
		return;
	}

	BU_LIST_INIT( &sphere_region.l );

	make_solid_name( name , CSPHERE , element_id , comp_id , group_id , 0 );
	mk_sph( fdout , name , grid_pts[center_pt] , radius );

	if( mk_addmember( name ,  &sphere_region , WMOP_UNION ) == (struct wmember *)NULL )
	{
		bu_log( "do_sphere: Error in adding %s to sphere region\n" , name );
		rt_bomb( "do_sphere" );
	}

	if( mode == PLATE_MODE )
	{
		inner_radius = radius - thick;
		if( thick > 0.0 && inner_radius <= 0.0 )
		{
			bu_log( "do_sphere: illegal thickness (%f), skipping inner sphere\n" , thick );
			bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
			return;
		}

		make_solid_name( name , CSPHERE , element_id , comp_id , group_id , 1 );
		mk_sph( fdout , name , grid_pts[center_pt] , inner_radius );

		if( mk_addmember( name , &sphere_region , WMOP_SUBTRACT ) == (struct wmember *)NULL )
		{
			bu_log( "do_sphere: Error in subtracting %s from sphere region\n" , name );
			rt_bomb( "do_sphere" );
		}
	}

	/* subtract any holes for this component */
	Subtract_holes( &sphere_region , comp_id , group_id );

	MK_REGION( fdout , &sphere_region , group_id , comp_id , element_id , CSPHERE )
}

void
make_nmg_name( name , r_id )
char *name;
int r_id;
{
	sprintf( name , "nmg.%d" , r_id );

	make_unique_name( name );
}
#if 0
void
Check_normals()
{
	/* XXXX This routine is far from complete */
	struct bu_ptbl verts;
	struct shell *s1;

	if( debug )
		bu_log( "Check_normals\n" );
	
	bu_ptbl_init( &verts , 64, " &verts ");

	NMG_CK_SHELL( s );

	nmg_decompose_shell( s , &tol );

	/* Calculate center of shell */
	for( BU_LIST_FOR( s1 , shell , &r->s_hd ) )
	{
		struct vertex *v;
		point_t shell_center;
		struct faceuse *fu;
		int i;

		NMG_CK_SHELL( s1 );

		VSET( shell_center , 0.0 , 0.0 , 0.0 );

		nmg_vertex_tabulate( &verts , &s1->l.magic );

		for( i=0 ; i<BU_PTBL_END( &verts ) ; i++ )
		{
			v = (struct vertex *)BU_PTBL_GET( &verts , i );
			VADD2( shell_center , shell_center , v->vg_p->coord );
		}

		VSCALE( shell_center , shell_center , (fastf_t)(BU_PTBL_END( &verts ) ) );

		bu_ptbl_reset( &verts );

		/* check if outward normal points away from center */
		for( BU_LIST_FOR( fu , faceuse , &s1->fu_hd ) )
		{
			vect_t norm;
			vect_t to_center;
			struct loopuse *lu;
			struct edgeuse *eu;
			fastf_t dot;

			NMG_CK_FACEUSE( fu );

			if( fu->orientation != OT_SAME )
				continue;

			NMG_GET_FU_NORMAL( norm , fu );
			lu = BU_LIST_FIRST( loopuse , &fu->lu_hd );
			NMG_CK_LOOPUSE( lu );
			eu = BU_LIST_FIRST( edgeuse , &lu->down_hd );
			NMG_CK_EDGEUSE( eu );
d528 3
a530 1
			v = eu->vu_p->v_p;
d532 1
a532 22
			NMG_CK_VERTEX( v );

			VSUB2( to_center , shell_center , v->vg_p->coord )

			dot = VDOT( to_center , norm );
			if( BN_VECT_ARE_PERP( dot , &tol ) )
			{
				/* shell center is on face, probably only one face */
				break;
			}

			if( dot > 0.0 )
			{
				/* outward normal points inward */
				nmg_invert_shell( s1 , &tol );
				break;
			}
		}
	}

	s1 = BU_LIST_FIRST( shell , &r->s_hd );
	while( BU_LIST_NOT_HEAD( s1 , &r->s_hd ) )
d534 1
a534 1
		struct shell *next_s;
d536 2
a537 3
		next_s = BU_LIST_PNEXT( shell , &s1->l );

		if( s1 == s )
d539 1
a539 3
			s1 = next_s;
			continue;
		}
d541 4
a544 25
		nmg_js( s , s1 , &tol );

		s1 = next_s;
	}

	bu_ptbl_free( &verts );
}

int
Sort_fus_by_thickness()
{
	struct fast_fus *fus,*tmp,*prev;
	fastf_t thick;
	int done;
	int num_thicks=0;

	done=0;
	while( !done )
	{
		done = 1;
		prev = NULL;
		fus = fus_root;
		while( fus->next )
		{
			if( fus->thick > fus->next->thick )
d546 2
a547 9
				done = 0;
				tmp = fus->next->next;
				if( fus == fus_root )
				{
					fus_root = fus->next;
					fus_root->next = fus;
					fus->next = tmp;
					prev = fus_root;
				}
d549 1
a549 11
				{
					prev->next = fus->next;
					prev->next->next = fus;
					fus->next = tmp;
					prev = prev->next;
				}
			}
			else
			{
				prev = fus;
				fus = fus->next;
d552 1
a552 8
	}

	fus = fus_root;
	thick = fus->thick;
	num_thicks = 1;
	while( fus )
	{
		if( thick != fus->thick )
d554 4
a557 2
			thick = fus->thick;
			num_thicks++;
d559 1
a559 32
		fus = fus->next;
	}

	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in sort_fus_by_thickness\n" );

	return( num_thicks );
}

void
Recalc_edge_g( new_s )
struct shell * new_s;
{
	int i;
	struct bu_ptbl list;
	int *flags;

	bu_ptbl_init( &list , 64, " &list ");

	flags = (int *)bu_calloc( m->maxindex , sizeof( int ) , "Recalc_edge_g: flags" );

	nmg_edgeuse_tabulate( &list , &new_s->l.magic );

	/* get rid of all the old edge geometry */
	for( i=0 ; i<BU_PTBL_END( &list ) ; i++ )
	{
		struct edgeuse	*eu;

		eu = (struct edgeuse *)BU_PTBL_GET( &list , i );
		NMG_CK_EDGEUSE( eu );

		if( eu->g.magic_p )
d561 2
a562 112
			BU_LIST_DEQUEUE( &eu->l2 );
			BU_LIST_INIT( &eu->l2 );
			eu->l2.magic = NMG_EDGEUSE2_MAGIC;
			nmg_keg( eu );
		}
	}

	for( i=0 ; i<BU_PTBL_END( &list ) ; i++ )
	{
		struct edgeuse		*eu;

		eu = (struct edgeuse *)BU_PTBL_GET( &list , i );
		NMG_CK_EDGEUSE( eu );

		if( NMG_INDEX_TEST_AND_SET( flags , eu ) )
		{
			if( !eu->g.magic_p )
				nmg_edge_g( eu );
			NMG_INDEX_SET( flags , eu->eumate_p );
		}
	}

	bu_free( (char *)flags , "Recalc_edge_g: flags" );

	bu_ptbl_free( &list );

	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in Recalc_edge_g\n" );
}

void
Recalc_face_g( new_s )
struct shell *new_s;
{
	struct faceuse *fu;
	int *flags;

	flags = (int *)bu_calloc( m->maxindex , sizeof( int ) , "Recalc_face_g: flags " );

	for( BU_LIST_FOR( fu , faceuse , &new_s->fu_hd ) )
	{
		struct face *f;
		struct face_g_plane *fg;

		NMG_CK_FACEUSE( fu );

		if( fu->orientation != OT_SAME )
			continue;

		f = fu->f_p;
		NMG_CK_FACE( f );
		fg = f->g.plane_p;
		NMG_CK_FACE_G_PLANE( fg );

		if( NMG_INDEX_TEST_AND_SET( flags , fg ) )
		{
			if( debug )
				bu_log( "Recalculating geometry for face x%x fg=x%x\n", f, fg );
			(void)nmg_calc_face_g( fu );
			if( debug )
			{
				NMG_CK_FACE_G_PLANE( fu->f_p->g.plane_p );
				bu_log( "New geometry is ( %g %g %g %g )\n", V4ARGS( fu->f_p->g.plane_p->N ) );
			}
		}
	}

	bu_free( (char *)flags , "Recalc_face_g: flags" );

	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in Recalc_face_g\n" );
}

int
Adjust_vertices( new_s , thick )
struct shell *new_s;
CONST fastf_t thick;
{
	struct faceuse *fu;
	struct bu_ptbl verts;
	long *flags;
	int vert_no;
	int failures=0;

	flags = (long *)bu_calloc( m->maxindex , sizeof( long ) , "Adjust_vertices: flags" );

	if( debug )
		bu_log( "Adjust_vertices( s=x%x, thick = %g )\n", new_s, thick );

	/* now adjust all the planes, first move them by distance "thick" */
	for( BU_LIST_FOR( fu , faceuse , &new_s->fu_hd ) )
	{
		struct face_g_plane *fg_p;

		NMG_CK_FACEUSE( fu );
		NMG_CK_FACE( fu->f_p );
		fg_p = fu->f_p->g.plane_p;
		NMG_CK_FACE_G_PLANE( fg_p );

		/* move the faces by the distance "thick" */
		if( NMG_INDEX_TEST_AND_SET( flags , fg_p ) )
		{
			if( debug )
			{
				bu_log( "Moving face_g x%x ( %f %f %f %f ) from face x%x" ,
					fu->f_p->g.plane_p,
					V4ARGS( fu->f_p->g.plane_p->N ) ,
					fu->f_p );
				bu_log( "\tflip = %d\n" , fu->f_p->flip );
			}
			if( fu->f_p->flip )
				fg_p->N[3] -= thick;
d564 1
a564 404
				fg_p->N[3] += thick;
			if( debug )
				bu_log( " to (%f %f %f %f)\n", V4ARGS( fu->f_p->g.plane_p->N ) );
		}
	}

	bu_free( (char *)flags , "Adjust_vertices: flags" );

	/* get table of vertices in this shell */
	nmg_vertex_tabulate( &verts , &new_s->l.magic );

	/* now move all the vertices */
	for( vert_no = 0 ; vert_no < BU_PTBL_END( &verts ) ; vert_no++ )
	{
		struct vertex *new_v;

		new_v = (struct vertex *)BU_PTBL_GET( &verts , vert_no );
		NMG_CK_VERTEX( new_v );

		if( debug )
			bu_log( "\tMoving vertex x%x from ( %g %g %g ) ", new_v, V3ARGS( new_v->vg_p->coord ) );

		if( nmg_in_vert( new_v , 1 , &tol ) )
		{
			bu_log( "Adjust_vertices: Failed to calculate new vertex at v=x%x was ( %f %f %f )\n",
				new_v , V3ARGS( new_v->vg_p->coord ) );
			bu_log( "\tgroup id %d, component id %d\n" , group_id , comp_id );
			failures++;
		}

		if( debug )
			bu_log( "to ( %g %g %g )\n", V3ARGS( new_v->vg_p->coord ) );
	}

	bu_ptbl_free( &verts );

	/* since we used approximate mode in nmg_in_vert, recalculate planes */
	Recalc_face_g( new_s );

	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in Adjust_vertices\n" );

	return( failures );
}

struct edgeuse *
Use_of_eu_outside_shell( eu )
CONST struct edgeuse *eu;
{
	struct edgeuse *eu_radial;
	struct shell *s_eu;

	NMG_CK_EDGEUSE( eu );

	s_eu = nmg_find_s_of_eu( eu );

	eu_radial = nmg_next_radial_eu( eu , (struct shell *)NULL , 0 );
	while( eu_radial != eu )
	{
		if( nmg_find_s_of_eu( eu_radial ) != s_eu )
			return( eu_radial );
		eu_radial = nmg_next_radial_eu( eu_radial , (struct shell *)NULL , 0 );
	}

	return( (struct edgeuse *)NULL );
}

int
vu_used_outside_shell( vu )
CONST struct vertexuse *vu;
{
	struct vertexuse *vu1;
	struct shell *s_vu;

	NMG_CK_VERTEXUSE( vu );

	s_vu = nmg_find_s_of_vu( vu );

	for( BU_LIST_FOR( vu1 , vertexuse , &vu->v_p->vu_hd ) )
	{
		if( nmg_find_s_of_vu( vu1 ) != s_vu )
			return( 1 );
	}

	return( 0 );
}

void
Move_vus_in_s_to_newv( vu , new_s , new_v )
struct vertexuse *vu;
CONST struct shell *new_s;
struct vertex *new_v;
{
	struct vertex *old_v;
	struct vertexuse *tmp_vu;

	NMG_CK_VERTEXUSE( vu );
	NMG_CK_SHELL( new_s );
	NMG_CK_VERTEX( new_v );

	old_v = vu->v_p;
	tmp_vu = BU_LIST_FIRST( vertexuse , &old_v->vu_hd );
	while( BU_LIST_NOT_HEAD( tmp_vu , &old_v->vu_hd ) )
	{
		struct vertexuse *next_vu;

		next_vu = BU_LIST_PNEXT( vertexuse , tmp_vu );
		if( nmg_find_s_of_vu( tmp_vu ) == new_s )
			nmg_movevu( tmp_vu , new_v );

		tmp_vu = next_vu;
	}
}

void
Glue_shell_faces( new_s )
struct shell *new_s;
{
	struct bu_ptbl faces;
	struct faceuse *fu;

	NMG_CK_SHELL( new_s );

	bu_ptbl_init( &faces , 64, " &faces ");

	for( BU_LIST_FOR( fu , faceuse , &new_s->fu_hd ) )
	{
		NMG_CK_FACEUSE( fu );

		if( fu->orientation != OT_SAME )
			continue;

		bu_ptbl_ins( &faces , (long *)fu );
	}
	nmg_gluefaces( (struct faceuse **)BU_PTBL_BASEADDR( &faces) , BU_PTBL_END( &faces ), &tol );

	bu_ptbl_free( &faces );

	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in Glue_shell_faces\n" );
}

struct shell *
Get_shell( thick , center, source_shell )
CONST fastf_t thick;
CONST int center;
CONST struct shell *source_shell;
{
	struct shell *new_s;
	struct faceuse *fu;
	struct fast_fus *fus;
	struct bu_ptbl vert_tbl;
	struct bu_ptbl vert_repl;
	struct vertex **vert_new;
	int i,j;

	NMG_CK_SHELL( source_shell );

	r = BU_LIST_FIRST( nmgregion, &m->r_hd );

	new_s = nmg_msv( r );
	s = BU_LIST_LAST( shell, &r->s_hd );

	fus = fus_root;
	while( fus )
	{
		NMG_CK_FACEUSE( fus->fu );
		if( fus->thick == thick && fus->pos == center && fus->fu->s_p == source_shell )
			nmg_mv_fu_between_shells( new_s , fus->fu->s_p , fus->fu );

		fus = fus->next;
	}

	if( BU_LIST_IS_EMPTY( &new_s->fu_hd ) )
	{
		nmg_ks( new_s );
		new_s = (struct shell *)NULL;
		return( new_s );
	}

	nmg_kvu( new_s->vu_p );

	/* construct a list of all the vertices in `new_s' that are used in other shells.
	 * the list will be in `vert_repl'
	 */
	bu_ptbl_init( &vert_repl, 64, "vert_repl table" );
	nmg_vertex_tabulate( &vert_tbl, &new_s->l.magic );
	for( i=0 ; i<BU_PTBL_END( &vert_tbl ) ; i++ )
	{
		struct vertex *v;
		struct vertexuse *vu;

		v = (struct vertex *)BU_PTBL_GET( &vert_tbl, i );
		NMG_CK_VERTEX( v );

		for( BU_LIST_FOR( vu, vertexuse, &v->vu_hd ) )
		{
			if( nmg_find_s_of_vu( vu ) != new_s )
			{
				bu_ptbl_ins( &vert_repl, (long *)v );
				break;
			}
		}
	}

	bu_ptbl_free( &vert_tbl );

	if( BU_PTBL_END( &vert_repl ) == 0 )
	{
		bu_ptbl_free( &vert_repl );
		return( new_s );
	}

	/* construct an array of new vertices (initially all NULL) to replace
	 * the vertices in `vert_repl'
	 */
	vert_new = (struct vertex **)bu_calloc( BU_PTBL_END( &vert_repl ), sizeof( struct vertex *), "new vertex array" );

	/* disconnect faceuses from those not in this shell */
	for( BU_LIST_FOR( fu , faceuse , &new_s->fu_hd ) )
	{
		struct loopuse *lu;

		if( fu->orientation != OT_SAME )
			continue;

		for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
		{
			struct edgeuse *eu;

			if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
				continue;

			for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
			{
				struct edgeuse *eu_radial;
				struct vertex *v1,*v2;
				struct edgeuse *new_eu;
				struct adjacent_faces *adj;
				struct faceuse *fu2;

				/* Check if this edge has a use outside this shell */
				if( (eu_radial = Use_of_eu_outside_shell( eu )) ==
						(struct edgeuse *)NULL )
							continue;

				/* Two adjacent faces here will be seperated
				 * put them on the list to be reunited later
				 */
				if( adj_root == (struct adjacent_faces *)NULL )
				{
					adj_root = (struct adjacent_faces *)bu_malloc(
						sizeof( struct adjacent_faces ),
						"Get_shell: adj_root" );
					adj = adj_root;
				}
				else
				{
					adj = adj_root;
					while( adj->next )
						adj = adj->next;
					adj->next = (struct adjacent_faces *)bu_malloc(
						sizeof( struct adjacent_faces ),
						"Get_shell: adj_next" );
					adj = adj->next;
				}
				adj->next = (struct adjacent_faces *)NULL;
				adj->fu1 = fu;
				adj->eu1 = eu;

				fu2 = nmg_find_fu_of_eu( eu_radial );
				if( fu2->orientation != OT_SAME )
				{
					fu2 = fu2->fumate_p;
					eu_radial = eu_radial->eumate_p;
				}
				adj->fu2 = fu2;
				adj->eu2 = eu_radial;

				/* unglue the edge */
				nmg_unglueedge( eu );

				/* make a new edge using any existing replacement vertices */
				i = bu_ptbl_locate( &vert_repl, (long *)eu->vu_p->v_p );
				if( i < 0 )
					v1 = eu->vu_p->v_p;
				else
					v1 = vert_new[i];
				j = bu_ptbl_locate( &vert_repl, (long *)eu->eumate_p->vu_p->v_p );
				if( j < 0 )
					v2 = eu->eumate_p->vu_p->v_p;
				else
					v2 = vert_new[j];

				new_eu = nmg_me( v1 , v2 , new_s );
				if( i >= 0 && !vert_new[i] )
					vert_new[i] = new_eu->vu_p->v_p;
				if( j >= 0 && !vert_new[j] )
					vert_new[j] = new_eu->eumate_p->vu_p->v_p;

				/* assign same geometry to this new edge */
				if( i >= 0 && !vert_new[i]->vg_p )
					nmg_vertex_gv( vert_new[i],
						eu->vu_p->v_p->vg_p->coord );
				if( j >= 0 && !vert_new[j]->vg_p )
					nmg_vertex_gv( vert_new[j] ,
						eu->eumate_p->vu_p->v_p->vg_p->coord );
				/* Also move any uses of these
				 * vertices in new_s to the new shell
				 */
				if( i >= 0 )
					Move_vus_in_s_to_newv( eu->vu_p, new_s, vert_new[i] );

				if( j >= 0 )
					Move_vus_in_s_to_newv( eu->eumate_p->vu_p, new_s, vert_new[j] );

				/* kill the new edge,
				 * I only wanted it for its vertices.
				 */
				nmg_keu( new_eu );
			}
		}
	}
	bu_ptbl_free( &vert_repl );
	bu_free( (char *)vert_new, "new vertex array" );
	Glue_shell_faces( new_s );

	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in Get_shell\n" );

	return( new_s );
}

void
Build_connecting_face( eu1 , eu2 , s1 )
struct edgeuse *eu1,*eu2;
struct shell *s1;
{
	struct vertex *verts[3];

	NMG_CK_EDGEUSE( eu1 );
	NMG_CK_EDGEUSE( eu2 );
	NMG_CK_SHELL( s1 );

	/* need to build a connecting face between these two */
	if( eu1->vu_p->v_p != eu2->eumate_p->vu_p->v_p &&
		eu1->eumate_p->vu_p->v_p != eu2->eumate_p->vu_p->v_p )
	{
		struct faceuse *new_fu;
		struct loopuse *lu;
		fastf_t area;
		plane_t pl;

		verts[0] = eu1->eumate_p->vu_p->v_p;
		verts[1] = eu1->vu_p->v_p;
		verts[2] = eu2->eumate_p->vu_p->v_p;

		new_fu = nmg_cface( s1 , verts , 3 );
		lu = BU_LIST_FIRST( loopuse , &new_fu->lu_hd );
		area = nmg_loop_plane_area( lu , pl );
		if( area < 0.0 )
		{
			bu_log( "Cannot calculate plane equation for new face: \n" );
			bu_log( "\t( %f %f %f ), ( %f %f %f ), ( %f %f %f )\n",
				V3ARGS( verts[0]->vg_p->coord ),
				V3ARGS( verts[1]->vg_p->coord ),
				V3ARGS( verts[2]->vg_p->coord ) );
			nmg_kfu( new_fu );
		}
		else
		{
			nmg_face_g( new_fu , pl );
			nmg_loop_g( lu->l_p , &tol );
		}
	}

	if( eu1->eumate_p->vu_p->v_p != eu2->vu_p->v_p &&
		eu1->eumate_p->vu_p->v_p != eu2->eumate_p->vu_p->v_p )
	{
		struct faceuse *new_fu;
		struct loopuse *lu;
		fastf_t area;
		plane_t pl;

		verts[0] = eu1->eumate_p->vu_p->v_p;
		verts[1] = eu2->eumate_p->vu_p->v_p;
		verts[2] = eu2->vu_p->v_p;

		new_fu = nmg_cface( s1 , verts , 3 );
		lu = BU_LIST_FIRST( loopuse , &new_fu->lu_hd );
		area = nmg_loop_plane_area( lu , pl );
		if( area < 0.0 )
		{
			bu_log( "Cannot calculate plane equation for new face: \n" );
			bu_log( "\t( %f %f %f ), ( %f %f %f ), ( %f %f %f )\n",
				V3ARGS( verts[0]->vg_p->coord ),
				V3ARGS( verts[1]->vg_p->coord ),
				V3ARGS( verts[2]->vg_p->coord ) );
			nmg_kfu( new_fu );
		}
		else
		{
			nmg_face_g( new_fu , pl );
			nmg_loop_g( lu->l_p , &tol );
a566 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in Build_connecting_face\n" );
d569 6
a574 4
void
Sort_vertices_along_vect( norm, verts )
vect_t norm;
struct vertex *verts[4];
d576 7
a582 5
	int i;
	fastf_t dist[4];
	fastf_t dist_tmp;
	struct vertex *v_tmp;
	int done=0;
d584 1
a584 2
	dist[0] = 0.0;
	for( i=1 ; i<4 ; i++ )
d586 1
a586 1
		vect_t to_v;
d588 3
a590 3
		VSUB2( to_v, verts[i]->vg_p->coord, verts[0]->vg_p->coord );
		dist[i] = VDOT( to_v, norm );
	}
d592 13
a604 4
	while( !done )
	{
		done = 1;
		for( i=0 ; i<3 ; i++ )
d606 4
a609 10
			if( dist[i] > dist[i+1] )
			{
				dist_tmp = dist[i];
				v_tmp = verts[i];
				dist[i] = dist[i+1];
				verts[i] = verts[i+1];
				dist[i+1] = dist_tmp;
				verts[i+1] = v_tmp;
				done = 0;
			}
a611 1

d615 3
a617 2
Reunite_faces( tbl )
long **tbl;
d619 2
a620 5
	struct adjacent_faces *adj;
	struct adjacent_faces *adj2;
	struct shell *s_eu1;
	struct vertex *verts[4];
	vect_t norm;
d622 1
d624 4
a627 3
	/* maybe there's nothing to do */
	if( adj_root == (struct adjacent_faces *)NULL )
		return;
d629 1
a629 7
	/* rebound the model again */
	nmg_rebound( m , &tol );

	nmg_model_fuse( m , &tol );

	adj = adj_root;
	while( adj )
d631 7
a637 31
		struct vertex *v_other_end;
		struct edgeuse *eu1,*eu2;
		struct faceuse *fu1,*fu2;
		point_t pca;
		fastf_t dist;

		v_other_end = adj->eu1->eumate_p->vu_p->v_p;

		/* make the four vertices that define
		 * the edge in both shells colinear.
		 */

		verts[0] = adj->eu1->vu_p->v_p;
		verts[1] = adj->eu2->eumate_p->vu_p->v_p;
		verts[2] = NMG_INDEX_GETP( vertex, tbl, verts[0] );
		verts[3] = NMG_INDEX_GETP( vertex, tbl, verts[1] );
		NMG_GET_FU_NORMAL( norm, adj->fu1 );
		Sort_vertices_along_vect( norm, verts );

		(void) bn_dist_pt3_lseg3( &dist, pca, verts[0]->vg_p->coord,
					verts[3]->vg_p->coord, verts[1]->vg_p->coord, &tol );
		VMOVE( verts[1]->vg_p->coord, pca );

		(void) bn_dist_pt3_lseg3( &dist, pca, verts[0]->vg_p->coord,
					verts[3]->vg_p->coord, verts[2]->vg_p->coord, &tol );
		VMOVE( verts[2]->vg_p->coord, pca );

		/* Check if the other ends of these edges is another adjacent faces struct */
		found = 0;
		adj2 = adj_root;
		while( adj2 )
d639 1
a639 1
			if( adj2 == adj )
d641 2
a642 2
				adj2 = adj2->next;
				continue;
d644 6
a649 2

			if( adj2->eu1->vu_p->v_p == v_other_end )
d651 4
a654 1
				found = 1;
a655 2
			}
			adj2 = adj2->next;
d657 1
d659 2
a660 3
		if( !found )
		{
			/* Need to align the other end */
d662 2
a663 6
			verts[0] = adj->eu1->eumate_p->vu_p->v_p;
			verts[1] = adj->eu2->vu_p->v_p;
			verts[2] = NMG_INDEX_GETP( vertex, tbl, verts[0] );
			verts[3] = NMG_INDEX_GETP( vertex, tbl, verts[1] );
			NMG_GET_FU_NORMAL( norm, adj->fu1 );
			Sort_vertices_along_vect( norm, verts );
d665 9
a673 7
			(void) bn_dist_pt3_lseg3( &dist, pca, verts[0]->vg_p->coord,
						verts[3]->vg_p->coord, verts[1]->vg_p->coord, &tol );
			VMOVE( verts[1]->vg_p->coord, pca );

			(void) bn_dist_pt3_lseg3( &dist, pca, verts[0]->vg_p->coord,
						verts[3]->vg_p->coord, verts[2]->vg_p->coord, &tol );
			VMOVE( verts[2]->vg_p->coord, pca );
d675 4
d680 1
a680 3

		/* if the two faceuses are radial, nothing to do */
		if( !nmg_faces_are_radial( adj->fu1 , adj->fu2 ) )
d682 9
a690 9

			eu1 = adj->eu1;
			eu2 = adj->eu2;
			NMG_CK_EDGEUSE( eu1 );
			NMG_CK_EDGEUSE( eu2 );

			s_eu1 = nmg_find_s_of_eu( eu1 );

			Build_connecting_face( eu1 , eu2 , s_eu1 );
d692 1
a692 4

		fu1 = NMG_INDEX_GETP( faceuse , tbl , adj->fu1 );
		fu2 = NMG_INDEX_GETP( faceuse , tbl , adj->fu2 );
		if( !nmg_faces_are_radial( fu1 , fu2 ) )
d694 2
a695 11
			NMG_CK_FACEUSE( fu1 );
			NMG_CK_FACEUSE( fu2 );

			eu1 = NMG_INDEX_GETP( edgeuse , tbl , adj->eu1 );
			eu2 = NMG_INDEX_GETP( edgeuse , tbl , adj->eu2 );
			NMG_CK_EDGEUSE( eu1 );
			NMG_CK_EDGEUSE( eu2 );

			s_eu1 = nmg_find_s_of_eu( eu1 );

			Build_connecting_face( eu1 , eu2 , s_eu1 );
d697 4
a700 2

		adj = adj->next;
d702 1
a702 49
	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in Reunite_face\n" );
}

/* Support routine for "Stitch_adj_shells"
 * creates the actual faces to connect the two shells
 * in the problem area
 */
void
Connect_at_adj_edges( s1, s2, eu1, adj, dup_tbl )
struct shell *s1;
struct shell *s2;
struct edgeuse *eu1;
struct adjacent_faces *adj;
long **dup_tbl;
{
	struct edgeuse *eu2;	/* eu in s2 corresponding to eu1 in s1 */
	struct vertex *v2a,*v2b,*v2c,*v2d; /* vertices along free edge of shell s2 */
	struct vertex *v1a,*v1b,*v1c,*v1d; /* vertices along free edge of shell s1 */
	vect_t norm1;		/* normal for face containing edge from v1a to v1b */
	vect_t norm2;		/* normal for face containing edge from v2a to v2b */
	int normalward1;	/* flag indicating if eu1 points in norm1 direction */
	int normalward2;	/* flag indicating if eu2 points in norm2 direction */
	struct edgeuse *eu;
	struct vertexuse *vu;
	vect_t a_to_b;
	fastf_t area;
	plane_t pl;

	NMG_CK_SHELL( s1 );
	NMG_CK_SHELL( s2 );
	NMG_CK_EDGEUSE( eu1 );

	if( eu1->radial_p != eu1->eumate_p )
	{
		bu_log( "Connect_at_adj_edges: Called with non dangling edge!!\n" );
		rt_bomb( "Connect_at_adj_edges\n" );
	}

	/* find the v1 vertices */
	v1b = eu1->vu_p->v_p;
	NMG_CK_VERTEX( v1b );
	v1c = eu1->eumate_p->vu_p->v_p;
	NMG_CK_VERTEX( v1c );

	v1a = (struct vertex *)NULL;
	v1d = (struct vertex *)NULL;

	for( BU_LIST_FOR( vu, vertexuse, &v1b->vu_hd ) )
d704 26
a729 14
		if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
			continue;

		eu = vu->up.eu_p;
		NMG_CK_EDGEUSE( eu );
		if( eu->radial_p != eu->eumate_p )
			continue;	/* not a free edge */

		if( eu->eumate_p->vu_p->v_p == v1c )
			continue;	/* wrong free edge */

		v1a = eu->eumate_p->vu_p->v_p;
		NMG_CK_VERTEX( v1a );
		break;
a730 4
	for( BU_LIST_FOR( vu, vertexuse, &v1c->vu_hd ) )
	{
		if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
			continue;
a731 4
		eu = vu->up.eu_p;
		NMG_CK_EDGEUSE( eu );
		if( eu->radial_p != eu->eumate_p )
			continue;	/* not a free edge */
d733 4
a736 2
		if( eu->eumate_p->vu_p->v_p == v1b )
			continue;	/* wrong free edge */
d738 1
a738 20
		v1d = eu->eumate_p->vu_p->v_p;
		NMG_CK_VERTEX( v1d );
		break;
	}

	if( adj->eu1->vu_p->v_p == v1b )
		NMG_GET_FU_NORMAL( norm1, adj->fu1 )
	else if( adj->eu1->eumate_p->vu_p->v_p == v1c )
		NMG_GET_FU_NORMAL( norm1, adj->fu2 )

	VREVERSE( norm2, norm1 );

	v2b = NMG_INDEX_GETP( vertex, dup_tbl, v1b );
	NMG_CK_VERTEX( v2b );
	v2c = NMG_INDEX_GETP( vertex, dup_tbl, v1c );

	v2a = (struct vertex *)NULL;
	v2d = (struct vertex *)NULL;

	for( BU_LIST_FOR( vu, vertexuse, &v2b->vu_hd ) )
d740 3
a742 2
		if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
			continue;
d744 25
a768 28
		eu = vu->up.eu_p;
		NMG_CK_EDGEUSE( eu );
		if( eu->radial_p != eu->eumate_p )
			continue;	/* not a free edge */

		if( eu->eumate_p->vu_p->v_p == v2c )
			continue;	/* wrong free edge */

		v2a = eu->eumate_p->vu_p->v_p;
		NMG_CK_VERTEX( v2a );
		break;
	}
	for( BU_LIST_FOR( vu, vertexuse, &v2c->vu_hd ) )
	{
		if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
			continue;

		eu = vu->up.eu_p;
		NMG_CK_EDGEUSE( eu );
		if( eu->radial_p != eu->eumate_p )
			continue;	/* not a free edge */

		if( eu->eumate_p->vu_p->v_p == v2b )
			continue;	/* wrong free edge */

		v2d = eu->eumate_p->vu_p->v_p;
		NMG_CK_VERTEX( v2d );
		break;
d771 1
a771 1
	if( !v1a || !v1d || !v2a || !v2d )
d773 2
a774 2
		bu_log( "Connect_at_adj_edges: Could not find vertices for adjacent edges\n" );
		rt_bomb( "Connect_at_adj_edges\n" );
d777 1
a777 2
	eu2 = nmg_findeu( v2b, v2c, s2, (struct edgeuse *)NULL, 1 );
	if( !eu2 )
d779 2
a780 2
		bu_log( "Connect_at_adj_edges: Could not find eu2 corresponding to eu1\n" );
		rt_bomb( "Connect_at_adj_edges\n" );
a782 5
	VSUB2( a_to_b, v1b->vg_p->coord, v1a->vg_p->coord );
	if( VDOT( a_to_b, norm1 ) > 0.0 )
		normalward1 = 1;
	else
		normalward1 = 0;
d784 1
a784 7
	VSUB2( a_to_b, v2b->vg_p->coord, v2a->vg_p->coord );
	if( VDOT( a_to_b, norm2 ) > 0.0 )
		normalward2 = 1;
	else
		normalward2 = 0;

	if( normalward1 == normalward2 )
d786 1
a786 5
		struct faceuse *fu;
		struct loopuse *lu;
		struct vertex *verts[3];

		if( normalward1 )
d788 5
a792 3
			verts[0] = v1d;
			verts[1] = v1c;
			verts[2] = v1b;
d795 5
d801 5
a805 47
			verts[0] = v1c;
			verts[1] = v1b;
			verts[2] = v1a;
		}

		fu = nmg_cface( s1, verts, 3 );
		lu = BU_LIST_FIRST( loopuse , &fu->lu_hd );
		area = nmg_loop_plane_area( lu , pl );
		if( area < 0.0 )
		{
			bu_log( "Cannot calculate plane equation for new face: \n" );
			bu_log( "\t( %f %f %f ), ( %f %f %f ), ( %f %f %f )\n",
				V3ARGS( verts[0]->vg_p->coord ),
				V3ARGS( verts[1]->vg_p->coord ),
				V3ARGS( verts[2]->vg_p->coord ) );
			nmg_kfu( fu );
		}
		else
		{
			nmg_face_g( fu , pl );
			nmg_loop_g( lu->l_p , &tol );
		}

		if( normalward2 )
		{
			verts[0] = v2b;
			verts[1] = v2c;
			verts[2] = v2d;
		}
		else
		{
			verts[0] = v2a;
			verts[1] = v2b;
			verts[2] = v2c;
		}

		fu = nmg_cface( s2, verts, 3 );
		lu = BU_LIST_FIRST( loopuse , &fu->lu_hd );
		area = nmg_loop_plane_area( lu , pl );
		if( area < 0.0 )
		{
			bu_log( "Cannot calculate plane equation for new face: \n" );
			bu_log( "\t( %f %f %f ), ( %f %f %f ), ( %f %f %f )\n",
				V3ARGS( verts[0]->vg_p->coord ),
				V3ARGS( verts[1]->vg_p->coord ),
				V3ARGS( verts[2]->vg_p->coord ) );
			nmg_kfu( fu );
d808 1
a808 5
		{
			nmg_face_g( fu , pl );
			nmg_loop_g( lu->l_p , &tol );
		}
		return;
d810 4
a815 3
/* This routine stitches together the two shells just in the areas where "Reunite_shells"
 * made its connections. These areas get too complicated for "nmg_open_shells_connect".
 */
d817 3
a819 4
Stitch_adj_shells( s1, s2, dup_tbl )
struct shell *s1;
struct shell *s2;
long **dup_tbl;
d821 4
a824 1
	struct adjacent_faces *adj;
d826 1
a826 2
	NMG_CK_SHELL( s1 );
	NMG_CK_SHELL( s2 );
d828 1
a828 5
	/* loop through list of faces that Reunite_shells connected
	 * looking for created dangling edges
	 */
	adj = adj_root;
	while( adj )
d830 3
a832 1
		struct edgeuse *eu1;
d834 1
a834 2
		eu1 = nmg_findeu( adj->eu1->vu_p->v_p, adj->eu2->eumate_p->vu_p->v_p, s1,
				(struct edgeuse *)NULL, 1 );
d836 9
a844 3
		/* eu1 is a dangling edge created by Reunite_shells */
		if( eu1 )
			Connect_at_adj_edges( s1, s2, eu1, adj, dup_tbl );
d846 4
a849 9
		/* Check other end of adjacent edges */
		eu1 = nmg_findeu( adj->eu2->vu_p->v_p, adj->eu1->eumate_p->vu_p->v_p,
				s1, (struct edgeuse *)NULL, 1 );

		/* eu1 is a dangling edge created by Reunite_shells */
		if( eu1 )
			Connect_at_adj_edges( s1, s2, eu1, adj, dup_tbl );

		adj = adj->next;
a850 1
}
d852 2
a853 58
int
Extrude_faces()
{
	struct nmgregion *tmp_r;
	struct shell *s1,*s2;
	struct shell **shells,**dup_shells,**source_shells;
	struct fast_fus *fus;
	fastf_t *thicks;
	int i;
	int num_thicks=0;
	int thick_no;
	int num_centers;
	int only_center;
	int center;
	int table_size;
	int shell_count;
	int shell_no;
	long **dup_tbl;

	if( debug )
		bu_log( "Extrude_faces:\n" );

	num_thicks = Sort_fus_by_thickness();
	if( debug )
		bu_log( "\tComponent has %d unique thicknesses\n", num_thicks );

	thicks = (fastf_t *)bu_calloc( num_thicks , sizeof( fastf_t ) , "Extrude_faces: thicks" );
	i = 0;
	fus = fus_root;
	only_center = fus->pos;
	num_centers = 1;
	thicks[i] = fus->thick;
	while( fus )
	{
		if( fus->thick != thicks[i] )
		{
			if( ++i >= num_thicks )
				rt_bomb( "Extrude_faces: Wrong number of shell thicknesses\n" );
			thicks[i] = fus->thick;
		}
		if( fus->pos != only_center && num_centers == 1 )
			num_centers = 2;

		fus = fus->next;
	}

	/* Decompose the shell into constituent shells. This is to separate
	 * surfaces that the extruder cannot handle, i.e, where the web and flange
	 * of an "I" beam come together	the extrusion cannot be performed.
	 */
	r = BU_LIST_FIRST( nmgregion, &m->r_hd );
	s = BU_LIST_FIRST( shell, &r->s_hd );
	shell_count = nmg_decompose_shell( s, &tol );

	/* rebound the region */
	nmg_rebound( m , &tol );

	if( debug )
d855 6
a860 2
		bu_log( "%d shells\n", shell_count );
		nmg_stash_model_to_file( "shell.g", m, "before fix normals" );
d862 1
a862 2

	for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) )
d864 1
a864 2
		NMG_CK_REGION( r )
		for( BU_LIST_FOR( s, shell, &r->s_hd ) )
d866 2
a867 5
			NMG_CK_SHELL( s );
			Fix_normals( s );

			if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
				bu_log( "ERROR: bu_mem_barriercheck failed in make_nmg_objects (after fix_normals)\n" );
d869 1
d871 14
d887 1
a887 4
	{
		bu_log( "%d shells\n", shell_count );
		nmg_stash_model_to_file( "shell1.g", m, "after fix normals" );
	}
d889 2
a890 4
	/* make array of shells, each with unique combination of "center postion"
	 * original shell, and thickness */
	shells = (struct shell **)bu_calloc( num_thicks*shell_count*2 ,
		sizeof( struct shell *) , "Extrude_faces: shells" );
d892 2
a893 3
	/* and another for the opposite (extruded) side */
	dup_shells = (struct shell **)bu_calloc( num_thicks*shell_count*2 ,
		sizeof( struct shell *) , "Extrude_faces: dup_shells" );
d895 7
a901 3
	/* make an array of the source shells */
	source_shells = (struct shell **)bu_calloc( shell_count,
		sizeof( struct shell *) , "Extrude_faces: source_shells" );
d903 11
d915 3
a917 4
	/* fill in the source shells array */
	r = BU_LIST_FIRST( nmgregion, &m->r_hd );
	source_shells[0] = BU_LIST_FIRST( shell, &r->s_hd );
	for( BU_LIST_FOR( s1, shell, &r->s_hd ) )
d919 1
a919 1
		int found=0;
d921 1
a921 1
		for( i=0 ; i<shell_count ; i++ )
d923 1
a923 1
			if( s1 == source_shells[i] )
d925 2
a926 2
				found = 1;
				break;
d928 5
a932 2

			if( !source_shells[i] )
d934 2
a935 3
				source_shells[i] = s1;
				found = 1;
				break;
d937 1
a939 9
		if( !found )
		{
			bu_log( "Extrude_faces: ERROR: too many shells!!!\n" );
			bu_free( (char *)shells, "Extrude_faces: shells" );
			bu_free( (char *)dup_shells, "Extrude_faces: dup_shells" );
			bu_free( (char *)source_shells, "Extrude_faces: source_shells" );
			return( 1 );
		}
	}
d941 6
a946 5
	/* Now get the first set of shells */
	i = (-1);
	for( thick_no=0 ; thick_no<num_thicks ; thick_no++ )
	{
		for( center=1 ; center<3 ; center++ )
d948 1
a948 4
			int shell_no;
			int source_shell_no;

			for( source_shell_no=0 ; source_shell_no<shell_count ; source_shell_no++ )
d950 2
a951 16
				shell_no = thick_no*2*shell_count + (center-1)*shell_count + source_shell_no;
				if( num_thicks == 1 && num_centers == 1 && shell_count == 1 )
				{
					if( center == only_center )
						shells[shell_no] = source_shells[0];
					else
						shells[shell_no] = (struct shell *)NULL;
				}
				else
					shells[ shell_no ] = Get_shell( thicks[thick_no],
						center, source_shells[source_shell_no] );
				if( debug && shells[shell_no] )
				{
					bu_log( "Shell thickness = %g, center position = %d, source shell = x%x:\n",
						thicks[thick_no], center, source_shells[source_shell_no] );
				}
d953 1
d955 1
a955 19
	}

	/* Extrude faces with POS_CENTER first (these faces were defined as the center
	 * of the actual object, so must be extruded in both directions)
	 */
	center = POS_CENTER;
	for( thick_no=0 ; thick_no<num_thicks ; thick_no++ )
	{
	    int shell_no;
	    int source_shell_no;

	    for( source_shell_no=0 ; source_shell_no<shell_count ; source_shell_no++ )
	    {
	    	shell_no = thick_no*2*shell_count + (center-1)*shell_count + source_shell_no;
		if( shells[shell_no ] == (struct shell *)NULL )
			continue;

		/* Extrude distance is one-half the thickness */
		if( Adjust_vertices( shells[shell_no] , (fastf_t)(thicks[thick_no]/2.0) ) )
d957 6
a962 5
			bu_free( (char *)thicks , "Extrude_faces: thicks" );
			bu_free( (char *)shells , "Extrude_faces: shells" );
			bu_free( (char *)dup_shells , "Extrude_faces: dup_shells" );
			bu_free( (char *)source_shells, "Extrude_faces: source_shells" );
			return( 1 );
a963 1
	    }
d965 4
d970 9
a978 3
	/* make a translation table to store correspondence between original and dups */
	table_size = m->maxindex;
	dup_tbl = (long **)bu_calloc( m->maxindex , sizeof( long *) , "Extrude_faces: dup_tbl" );
d980 1
a980 7
	/* Now extrude all the faces by the entire thickness */
	for( thick_no=0 ; thick_no<num_thicks ; thick_no++ )
	{
		for( center=1 ; center<3 ; center++ )
		{
		    int shell_no;
		    int source_shell_no;
d982 2
a983 3
		    for( source_shell_no=0 ; source_shell_no<shell_count ; source_shell_no++ )
		    {
			long **trans_tbl;
d985 1
a985 1
		    	shell_no = thick_no*2*shell_count + (center-1)*shell_count + source_shell_no;
d987 5
a991 2
			if( shells[shell_no] == (struct shell *)NULL )
				continue;
d993 8
a1000 2
			dup_shells[shell_no] = nmg_dup_shell( shells[shell_no],
							&trans_tbl, &tol );
d1002 1
a1002 6
			/* move trans_tbl info to dup_tbl */
			for( i=0 ; i<table_size ; i++ )
			{
				if( trans_tbl[i] )
					dup_tbl[i] = trans_tbl[i];
			}
d1004 1
d1006 2
a1007 33
			Glue_shell_faces( dup_shells[shell_no] );

			nmg_invert_shell( dup_shells[shell_no] , &tol );

			if( Adjust_vertices( dup_shells[shell_no] , thicks[thick_no] ) )
			{
				bu_free( (char *)thicks , "Extrude_faces: thicks" );
				bu_free( (char *)shells , "Extrude_faces: shells" );
				bu_free( (char *)dup_shells , "Extrude_faces: dup_shells" );
				bu_free( (char *)dup_tbl , "Extrude_faces: dup_tbl" );
				bu_free( (char *)trans_tbl , "Extrude_faces: trans_tbl" );
				bu_free( (char *)source_shells, "Extrude_faces: source_shells" );
				return( 1 );
			}
			if( nmg_open_shells_connect( shells[shell_no],
						dup_shells[shell_no],
						trans_tbl, &tol ) )
			{
				bu_log( "Extrude_faces: Failed to connect shells\n" );
				bu_free( (char *)thicks , "Extrude_faces: thicks" );
				bu_free( (char *)shells , "Extrude_faces: shells" );
				bu_free( (char *)dup_shells , "Extrude_faces: dup_shells" );
				bu_free( (char *)dup_tbl , "Extrude_faces: dup_tbl" );
				bu_free( (char *)trans_tbl , "Extrude_faces: trans_tbl" );
				bu_free( (char *)source_shells, "Extrude_faces: source_shells" );
				return( 1 );
			}
			bu_free( (char *)trans_tbl , "Extrude_faces: trans_tbl" );
		    }
		}
	}

	for( BU_LIST_FOR( tmp_r, nmgregion, &m->r_hd ) )
d1009 3
a1011 1
		struct shell *next_s;
d1013 3
a1015 2
		s = BU_LIST_FIRST( shell, &tmp_r->s_hd );
		while( BU_LIST_NOT_HEAD( &s->l, &tmp_r->s_hd ) )
d1017 2
a1018 5
			next_s = BU_LIST_PNEXT( shell, &s->l );
			if( BU_LIST_IS_EMPTY( &s->fu_hd ) )
				nmg_ks( s );

			s = next_s;
a1019 1
	}
d1021 1
a1021 14
	if( debug )
	{
		nmg_rebound( m, &tol );
		nmg_stash_model_to_file( "error0.g", m, "unconnected shells" );
	}

	/* Re-calculate face geometries */
	for( BU_LIST_FOR( tmp_r, nmgregion, &m->r_hd ) )
	{
		for( BU_LIST_FOR( s , shell, &tmp_r->s_hd ) )
		{
			NMG_CK_SHELL( s );
			Recalc_face_g( s );
		}
a1022 9

	bu_free( (char *)thicks , "Extrude_faces: thicks" );
	bu_free( (char *)shells , "Extrude_faces: shells" );
	bu_free( (char *)dup_shells , "Extrude_faces: dup_shells" );
	bu_free( (char *)dup_tbl , "Extrude_faces: dup_tbl" );
	bu_free( (char *)source_shells, "Extrude_faces: source_shells" );

	(void)nmg_kill_zero_length_edgeuses( m );

d1024 2
a1025 1
		bu_log( "ERROR: bu_mem_barriercheck failed in Extrude_faces\n" );
d1027 6
a1032 1
	if( debug )
d1034 3
a1036 2
		nmg_rebound( m, &tol );
		nmg_stash_model_to_file( "error2.g", m, "connected shells" );
d1039 2
a1040 1
	return( 0 );
d1044 1
a1044 1
Make_arb6_obj()
d1046 2
a1047 3
	int arb_count=0;
	point_t pts[8];
	struct fast_fus *fus;
a1048 3
	struct wmember head;
	struct wmember arb6_head;
	int tmp_id;
d1050 4
a1053 1
	tmp_id = group_id * 1000 + comp_id;
d1055 1
a1055 1
	BU_LIST_INIT( &arb6_head.l );
d1057 2
a1058 2
	fus = fus_root;
	while( fus )
d1060 4
a1063 18
		struct faceuse *fu;
		struct loopuse *lu;
		struct edgeuse *eu;
		struct vertex *v;
		struct vertex_g *vg;
		vect_t normal;
		char arb6_name[NAMESIZE+1];

		fu = fus->fu;

		NMG_CK_FACEUSE( fu );

		if( fu->orientation != OT_SAME )
			fu = fu->fumate_p;
		if( fu->orientation != OT_SAME )
		{
			bu_log( "Make_arb6_obj: face has no OT_SAME use (fu=x%x)\n" , fu );
			return;
d1065 3
d1069 1
a1069 2
		lu = BU_LIST_FIRST( loopuse , &fu->lu_hd );
		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d1071 6
a1076 2
			bu_log( "Make_arb6_obj: Failed (loop without edgeuses)\n" );
			return;
d1078 2
d1081 3
a1083 1
		NMG_GET_FU_NORMAL( normal , fu );
d1085 2
a1086 31
		if( fus->pt1 < 0 || fus->pt2 < 0 || fus->pt3 < 0 )
		{
#if 1
			continue;
#else
			eu = BU_LIST_FIRST( edgeuse , &lu->down_hd );
			NMG_CK_EDGEUSE( eu );
			v = eu->vu_p->v_p;
			NMG_CK_VERTEX( v );
			vg = v->vg_p;
			NMG_CK_VERTEX_G( vg );
			VMOVE( pts[0] , vg->coord );

			eu = BU_LIST_PNEXT( edgeuse , eu );
			NMG_CK_EDGEUSE( eu );
			v = eu->vu_p->v_p;
			NMG_CK_VERTEX( v );
			vg = v->vg_p;
			NMG_CK_VERTEX_G( vg );
			VMOVE( pts[1] , vg->coord );

			eu = BU_LIST_PNEXT( edgeuse , eu );
			NMG_CK_EDGEUSE( eu );
			v = eu->vu_p->v_p;
			NMG_CK_VERTEX( v );
			vg = v->vg_p;
			NMG_CK_VERTEX_G( vg );
			VMOVE( pts[4] , vg->coord );
			VMOVE( pts[5] , pts[4] );
#endif
		}
d1089 6
a1094 3
			VMOVE( pts[0], grid_pts[fus->pt1] )
			VMOVE( pts[1], grid_pts[fus->pt2] )
			VMOVE( pts[4], grid_pts[fus->pt3] )
d1097 7
a1103 4
		/* move one side of the arb6 half the thickness */
		VJOIN1( pts[3] , pts[0] , 0.5*fus->thick , normal );
		VJOIN1( pts[2] , pts[1] , 0.5*fus->thick , normal );
		VJOIN1( pts[6] , pts[4] , 0.5*fus->thick , normal );
d1105 5
a1109 4
		/* move the other side the full thickness */
		VJOIN1( pts[0], pts[3], -fus->thick, normal );
		VJOIN1( pts[1], pts[2], -fus->thick, normal );
		VJOIN1( pts[4], pts[6], -fus->thick, normal );
d1111 2
a1112 2
		VMOVE( pts[7], pts[6] );
		VMOVE( pts[5], pts[4] );
d1114 1
a1114 2
		sprintf( arb6_name , "arb.%d.%d" , tmp_id , arb_count );
		arb_count++;
d1116 1
a1116 16
		mk_arb8( fdout , arb6_name , &pts[0][X] );

		if( mk_addmember( arb6_name , &arb6_head , WMOP_UNION ) == WMEMBER_NULL )
			bu_log( "Make_arb6_obj: Failed to add %s to member list\n" , arb6_name );

		fus = fus->next;
	}

	nmg_km( m );

	m = (struct model *)NULL;
	r = (struct nmgregion *)NULL;
	s = (struct shell *)NULL;

	fus = fus_root;
	while( fus )
d1118 1
a1118 1
		struct fast_fus *tmp;
d1120 2
a1121 5
		tmp = fus;
		fus = fus->next;
		bu_free( (char *)tmp , "make_nmg_objects: fus" );
	}
	fus_root = (struct fast_fus *)NULL;
d1123 2
a1124 3
	/* make arb6 group */
	make_nmg_name( name , region_id );
	mk_lfcomb( fdout, name, &arb6_head, 0 );
d1126 2
a1127 7
	/* make region containing nmg object */
	BU_LIST_INIT( &head.l );

	if( mk_addmember( name , &head , WMOP_UNION ) == (struct wmember *)NULL )
	{
		bu_log( "make_nmg_objects: mk_addmember failed\n" , name );
		rt_bomb( "Cannot make nmg region\n" );
d1130 2
a1131 2
	/* subtract any holes for this component */
	Subtract_holes( &head , comp_id , group_id );
d1133 2
a1134 4
	MK_REGION( fdout , &head , group_id , comp_id , bot , NMG )

	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in make_arb6_obj\n" );
d1138 1
a1138 2
Fix_normals( sh )
struct shell *sh;
d1140 6
a1145 18
	struct faceuse *fu;
	struct loopuse *lu;
	struct edgeuse *eu;
	vect_t out;
	vect_t norm;
	fastf_t outdot;
	fastf_t min_dot=MAX_FASTF;
	int planar;
	int missed_faces;
	long *flags;
	plane_t pl1,old_pl;
	point_t centroid;
	struct bu_ptbl verts;
	int i;
	mat_t matrix,inverse;
	point_t vsum;
	fastf_t det;
	double one_over_vertex_count;
d1147 2
a1148 1
	bu_ptbl_init( &verts, 64, " &verts");
d1151 1
a1151 1
		bu_log( "Fix_normals( sh = x%x )\n",sh );
d1153 2
a1154 1
	VSETALL( centroid, 0.0 );
d1156 1
a1156 5
	fu = BU_LIST_FIRST( faceuse, &sh->fu_hd );
	NMG_GET_FU_PLANE( old_pl, fu );

	nmg_vertex_tabulate( &verts, &sh->l.magic );
	for( i=0 ; i<BU_PTBL_END( &verts ) ; i++ )
d1158 3
a1160 4
		struct vertex *v;

		v = (struct vertex *)BU_PTBL_GET( &verts, i );
		VADD2( centroid, centroid, v->vg_p->coord );
d1163 2
a1164 1
	VSCALE( centroid, centroid, (fastf_t)(BU_PTBL_END( &verts ) ) )
d1166 1
a1166 7
	/* build matrix */
	bn_mat_zero( matrix );
	VSET( vsum , 0.0 , 0.0 , 0.0 );

	one_over_vertex_count = 1.0/(double)(BU_PTBL_END( &verts ));

	for( i=0 ; i<BU_PTBL_END( &verts ) ; i++ )
d1168 3
a1170 16
		struct vertex *v;
		struct vertex_g *vg;

		v = (struct vertex *)BU_PTBL_GET( &verts , i );
		vg = v->vg_p;

		matrix[0] += vg->coord[X] * vg->coord[X];
		matrix[1] += vg->coord[X] * vg->coord[Y];
		matrix[2] += vg->coord[X] * vg->coord[Z];
		matrix[5] += vg->coord[Y] * vg->coord[Y];
		matrix[6] += vg->coord[Y] * vg->coord[Z];
		matrix[10] += vg->coord[Z] * vg->coord[Z];

		vsum[X] += vg->coord[X];
		vsum[Y] += vg->coord[Y];
		vsum[Z] += vg->coord[Z];
a1171 4
	matrix[4] = matrix[1];
	matrix[8] = matrix[2];
	matrix[9] = matrix[6];
	matrix[15] = 1.0;
d1173 1
d1175 4
a1178 2
	/* Check that we don't have a singular matrix */
	det = mat_determinant( matrix );
d1180 3
a1182 3
	if( !NEAR_ZERO( det , SMALL_FASTF ) )
	{
		fastf_t inv_len_pl;
d1184 2
a1185 21
		/* invert matrix */
		bn_mat_inv( inverse , matrix );

		/* get normal vector */
		MAT4X3PNT( pl1 , inverse , vsum );

		/* unitize direction vector */
		inv_len_pl = 1.0/(MAGNITUDE( pl1 ));
		HSCALE( pl1 , pl1 , inv_len_pl );

		/* get average vertex coordinates */
		VSCALE( vsum, vsum, one_over_vertex_count );

		/* get distance from plane to orgin */
		pl1[H] = VDOT( pl1 , vsum );

		/* make sure it points in the correct direction */
		if( VDOT( pl1 , old_pl ) < 0.0 )
			HREVERSE( pl1 , pl1 );
	}
	else
d1187 1
a1187 25
		struct vertex *v,*v0;
		int x_same=1;
		int y_same=1;
		int z_same=1;

		/* singular matrix, may occur if all vertices have the same zero
		 * component.
		 */
		v0 = (struct vertex *)BU_PTBL_GET( &verts , 0 );
		for( i=1 ; i<BU_PTBL_END( &verts ) ; i++ )
		{
			v = (struct vertex *)BU_PTBL_GET( &verts , i );

			if( v->vg_p->coord[X] != v0->vg_p->coord[X] )
				x_same = 0;
			if( v->vg_p->coord[Y] != v0->vg_p->coord[Y] )
				y_same = 0;
			if( v->vg_p->coord[Z] != v0->vg_p->coord[Z] )
				z_same = 0;

			if( !x_same && !y_same && !z_same )
				break;
		}

		if( x_same )
d1189 2
a1190 22
			VSET( pl1 , 1.0 , 0.0 , 0.0 );
		}
		else if( y_same )
		{
			VSET( pl1 , 0.0 , 1.0 , 0.0 );
		}
		else if( z_same )
		{
			VSET( pl1 , 0.0 , 0.0 , 1.0 );
		}

		if( x_same || y_same || z_same )
		{
			/* get average vertex coordinates */
			VSCALE( vsum, vsum, one_over_vertex_count );

			/* get distance from plane to orgin */
			pl1[H] = VDOT( pl1 , vsum );

			/* make sure it points in the correct direction */
			if( VDOT( pl1 , old_pl ) < 0.0 )
				HREVERSE( pl1 , pl1 );
d1193 1
a1193 5
		{
			bu_log( "Fix_normals: Cannot calculate plane for fu x%x\n" , fu );
			nmg_pr_fu_briefly( fu , (char *)NULL );
			bu_log( "%d verts\n" , BU_PTBL_END( &verts ) );
		}
d1195 1
d1197 6
a1202 1
	bu_ptbl_free( &verts );
d1204 3
a1206 3
	for( BU_LIST_FOR( fu , faceuse , &sh->fu_hd ) )
	{
		struct faceuse *fu1;
d1208 4
a1211 3
		NMG_CK_FACEUSE( fu );
		if( fu->orientation != OT_SAME )
			continue;
d1213 10
a1222 5
		NMG_GET_FU_NORMAL( norm , fu );
		for( BU_LIST_FOR( fu1 , faceuse , &sh->fu_hd ) )
		{
			vect_t norm1;
			fastf_t dot;
d1224 1
a1224 2
			if( fu1->orientation != OT_SAME )
				continue;
d1226 2
a1227 2
			if( fu == fu1 )
				continue;
d1229 5
a1233 7
			NMG_GET_FU_NORMAL( norm1 , fu1 );
			dot = VDOT( norm, norm1 );
			if( dot < 0.0 )
				dot = (-dot );
			if( dot < min_dot )
				min_dot = dot;
		}
d1236 5
a1240 2
	if( min_dot > 0.8 )
		planar = 1;
d1242 1
a1242 1
		planar = 0;
d1244 1
a1244 2
	fu = BU_LIST_FIRST( faceuse, &sh->fu_hd );
	NMG_CK_FACEUSE( fu );
d1246 2
a1247 2
	/* Create a flags array for the model to make sure each face gets its orientation set */
	flags = (long *)bu_calloc( m->maxindex , sizeof( long ) , "patch-g: flags" );
d1249 10
a1258 6
	/* loop to catch all faces */
	missed_faces = 1;
	while( missed_faces )
	{
		struct faceuse *fu1;
		vect_t normal;
d1260 1
a1260 6
		/* get the normal direction for the first face */
		if( fu->orientation != OT_SAME )
			fu = fu->fumate_p;
		if( fu->orientation != OT_SAME )
			rt_bomb( "Neither faceuse nor mate have an OT_SAME side\n" );
		NMG_GET_FU_NORMAL( normal , fu );
d1262 1
a1262 41
		if( !planar )
		{
			/* calculate "out" direction, from centroid to face */
			lu = BU_LIST_FIRST( loopuse , &fu->lu_hd );
			eu = BU_LIST_FIRST( edgeuse , &lu->down_hd );
			VSUB2( out , eu->vu_p->v_p->vg_p->coord , centroid );
			VUNITIZE( out );

			outdot = VDOT( out , normal );
		}
		else
			outdot = VDOT( pl1, normal );

		/* if "normal" and "out" disagree, reverse normal */
		if( outdot < 0.0 )
			nmg_reverse_face_and_radials( fu , &tol );

		if( fu->orientation != OT_SAME )
			fu = fu->fumate_p;

		/* propagate this normal direction throughout the shell */
		nmg_propagate_normals( fu , flags , &tol );

		/* check if all the faces have been processed */
		missed_faces = 0;
		for( BU_LIST_FOR( fu1 , faceuse , &sh->fu_hd ) )
		{
			NMG_CK_FACEUSE( fu1 );
			if( fu1->orientation == OT_SAME )
			{
				if( !NMG_INDEX_TEST( flags , fu1->f_p ) )
				{
					fu = fu1;
					missed_faces++;
					if( debug )
						bu_log( "\t\tMissed some faces on the first try\n" );
					break;
				}
			}
		}
	}
d1266 7
a1272 1
Check_edge_uses()
d1274 1
a1274 3
	struct bu_ptbl edges;
	int i;
	int use_count;
d1276 1
a1276 38
	if( !m )
		return;

	bu_ptbl_init( &edges, 64, "edge list" );

	nmg_edge_tabulate( &edges, &m->magic );

	for( i=0 ; i<BU_PTBL_END( &edges ) ; i++ )
	{
		struct edge *e;
		struct edgeuse *eu_start;
		struct edgeuse *eu;

		e = (struct edge *)BU_PTBL_GET( &edges, i );

		use_count = 1;
		eu_start = e->eu_p;
		eu = eu_start->radial_p->eumate_p;
		while( eu != eu_start && eu->eumate_p != eu_start )
		{
			eu = eu->radial_p->eumate_p;
			use_count++;
		}

		if( use_count != 2 )
		{
			struct vertex_g *vg1, *vg2;

			vg1 = eu->vu_p->v_p->vg_p;
			vg2 = eu->eumate_p->vu_p->v_p->vg_p;

			bu_log( "\tedge has %d uses (should always be 2!!!)\n", use_count );
			bu_log( "\t\t(%g %g %g) <-> (%g %g %g)\n",
				V3ARGS( vg1->coord ), V3ARGS( vg2->coord ) );
		}
	}

	bu_ptbl_free( &edges );
d1279 2
a1280 2
int
make_nmg_objects()
d1282 2
a1283 8
	struct faceuse *fu;
	struct bu_ptbl faces;
	struct fast_fus *fus;
	struct adjacent_faces *adj;
	struct elem_list *elem;
	struct wmember head;
	int failed=0;
	char name[NAMESIZE+1];
d1285 2
a1286 3
	if( !m ||  BU_LIST_IS_EMPTY( &s->fu_hd ) )
	{
		char *bad_name;
d1288 2
a1289 7
		if( m )
		{
			nmg_km( m );
			m = (struct model *)NULL;
			r = (struct nmgregion *)NULL;
			s = (struct shell *)NULL;
		}
d1291 2
a1292 2
		bu_log( "***********component %s, group #%d, component #%d is empty, skipping\n",
			name_name, group_id , comp_id );
d1294 4
a1297 4
		while( (bad_name = find_nmg_region_name( group_id , comp_id ) ) )
			Delete_name( &name_root , bad_name );

		return(0);
d1300 2
a1301 5
	/* Fuse vertices.
	 * Don't want to do an overall model fuse here,
	 * shared face geometry will cause problems during extrusion
	 */
	(void)nmg_model_vertex_fuse( m , &tol );
d1303 2
a1304 3
	/* FASTGEN modellers don't always put vertices in the middle of edges where
	 * another edge ends
	 */
d1306 2
a1307 1
	(void)nmg_break_edges( &m->magic, &tol );
d1309 1
a1309 3
	bu_ptbl_init( &faces , 64, " &faces ");

	for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) )
d1311 3
a1313 8
		for( BU_LIST_FOR( s, shell, &r->s_hd ) )
		{
			if( debug )
				bu_log( "shell x%x", s );
			bu_ptbl_reset( &faces);
			for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
			{
				NMG_CK_FACEUSE( fu );
d1315 1
a1315 2
				if( fu->orientation != OT_SAME )
					continue;
d1317 5
a1321 7
				bu_ptbl_ins( &faces , (long *)fu );
			}
			if( debug )
				bu_log( " has %d faces\n", BU_PTBL_END( &faces ) );
			nmg_gluefaces( (struct faceuse **)BU_PTBL_BASEADDR( &faces) , BU_PTBL_END( &faces ), &tol );
		}
	}
d1323 7
a1329 4
	if( mode == VOLUME_MODE )
	{
		/* check for edges with wrong number of uses */
		Check_edge_uses();
d1331 2
a1332 2
		/* check for extra internal faces based on list of duplicates */
		Rm_internal_faces();
d1334 1
a1334 7
		for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) )
		{
			for( BU_LIST_FOR( s, shell, &r->s_hd ) )
			{
				nmg_fix_normals( s , &tol );
			}
		}
d1336 9
d1346 3
a1348 1
	else if( mode == PLATE_MODE )
d1350 5
a1354 4
		nmg_rebound( m , &tol );
		if( debug )
		{
			char name[NAMESIZE+1];
d1356 1
a1356 5
			bu_log( "\tExtrude faces\n" );
			sprintf( name , "shell.%d.%d" , group_id , comp_id );
			mk_nmg( fdout , name , m );
			fflush( fdout );
		}
d1358 1
a1358 2
		if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
			bu_log( "ERROR: bu_mem_barriercheck failed in make_nmg_objects (before triangulation)\n" );
d1360 3
a1362 7
		/* make all faces triangular
		 * nmg_break_long_edges may have made non-triangular faces
		 */
		nmg_triangulate_model( m , &tol );

		/* Split loops created by triangulation into separate faces */
		for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) )
d1364 1
a1364 1
			for( BU_LIST_FOR( s, shell, &r->s_hd ) )
d1366 3
a1368 4
				for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
				{
					struct loopuse *lu;
					struct loopuse *next_lu;
d1370 4
a1373 2
					if( fu->orientation != OT_SAME )
						continue;
d1375 1
a1375 30
					lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );
					next_lu = BU_LIST_PNEXT( loopuse, &lu->l );
					while( BU_LIST_NOT_HEAD( &next_lu->l, &fu->lu_hd ) )
					{
						struct faceuse *new_fu;
						struct fast_fus *fus;
						plane_t pl;

						lu = next_lu;
						next_lu = BU_LIST_PNEXT( loopuse, &lu->l );

						if( lu->orientation != OT_SAME )
						{
							bu_log( "make_nmg_objects: found loop with orientation (%s) after triangulation\n",
								nmg_orientation( lu->orientation ) );
							rt_bomb( "make_nmg_objects: found loop with bad orientation after triangulation\n" );
						}
						if( debug )
							bu_log( "Breaking a loop into its own face\n" );
						/* make new face */
						new_fu = nmg_mk_new_face_from_loop( lu );
						NMG_GET_FU_PLANE( pl, fu );
						nmg_face_g( new_fu, pl );
						nmg_face_bb( new_fu->f_p, &tol );

						/* add new face to `fus_root' list */
						fus = Find_fus( fu );
						Add_fu( new_fu, fus->thick, fus->pos, -1, -1, -1, fus->element );
					}
				}
a1376 1
		}
d1378 1
a1378 11
		if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
			bu_log( "ERROR: bu_mem_barriercheck failed in make_nmg_objects (after triangulation)\n" );

		if( debug )
			bu_log( "extrude faces\n" );

		if( Check_acute_angles() )
		{
			bu_ptbl_free( &faces );
			failed = 1;
			goto out;
d1381 1
a1381 1
		if( Extrude_faces() )
d1383 1
a1383 5
			bu_log( "Failed to Extrude group_id = %d, component_id = %d\n" , group_id , comp_id );
			bu_ptbl_free( &faces );
			failed = 1;
			goto out;
		}
d1385 4
a1388 1
		nmg_rebound( m , &tol );
d1390 7
a1396 2
		if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
			bu_log( "ERROR: bu_mem_barriercheck failed in make_nmg_objects (after extrusion)\n" );
d1398 2
a1399 8
		NMG_CK_MODEL( m );
		for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) )
		{
			struct shell *next_shell;

			NMG_CK_REGION( r );
			s = BU_LIST_FIRST( shell, &r->s_hd );
			while( BU_LIST_NOT_HEAD( &s->l, &r->s_hd ) )
d1401 3
a1403 1
				NMG_CK_SHELL( s );
d1405 1
a1405 4
				next_shell = BU_LIST_PNEXT( shell, &s->l );
				bu_ptbl_reset( &faces );

				for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
d1407 5
a1411 1
					NMG_CK_FACEUSE( fu );
d1413 4
a1416 2
					if( fu->orientation != OT_SAME )
						continue;
d1418 2
a1419 3
					bu_ptbl_ins( &faces , (long *)fu );
				}
				if( BU_PTBL_END( &faces ) )
d1421 3
a1423 1
					nmg_gluefaces( (struct faceuse **)BU_PTBL_BASEADDR( &faces) , BU_PTBL_END( &faces ), &tol );
d1425 1
a1425 5
				else
				{
					if( nmg_ks( s ) )
					{
						char *bad_name;
d1427 2
a1428 6
						s = (struct shell *)NULL;
						nmg_km( m );
						r = (struct nmgregion *)NULL;
						m = (struct model *)NULL;
						bu_log( "***********component %s, group #%d, component #%d is empty, skipping\n",
							name_name, group_id , comp_id );
d1430 7
a1436 2
						while( (bad_name = find_nmg_region_name( group_id , comp_id ) ) )
							Delete_name( &name_root , bad_name );
d1438 6
a1443 6
						bu_ptbl_free( &faces);
						return( 0 );
					}
				}
				s = next_shell;
			}
d1446 2
a1447 19
		if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
			bu_log( "ERROR: bu_mem_barriercheck failed in make_nmg_objects (after making table of faceuses)\n" );

	}
	bu_ptbl_free( &faces );

	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in make_nmg_objects (after BU_PTBL_FREE of faces)\n" );

	/* recompute the bounding boxes */
	nmg_rebound( m , &tol );

	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in make_nmg_objects (after rebound)\n" );

	/*  Make sure faces are within tolerance */
	for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) )
	{
		for( BU_LIST_FOR( s, shell, &r->s_hd ) )
d1449 4
a1452 3
			nmg_make_faces_within_tol( s, &tol );
		}
	}
d1454 2
a1455 4
	if( !polysolids )
	{
		if( debug )
			bu_log( "Coplanar face merge\n" );
d1457 2
a1458 3
		for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) )
		{
			for( BU_LIST_FOR( s, shell, &r->s_hd ) )
d1460 2
a1461 1
				tmp_shell_coplanar_face_merge( s , &tol , 0 );
d1463 1
a1463 1
		}
d1465 1
a1465 6
		if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
			bu_log( "ERROR: bu_mem_barriercheck failed in make_nmg_objects (after tmp_shell_coplanar_face_merge)\n" );

		for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) )
		{
			for( BU_LIST_FOR( s, shell, &r->s_hd ) )
d1467 7
a1473 1
				Recalc_face_g( s );
a1474 2
		}
	}
d1476 2
a1477 30
	if( debug && mode != PLATE_MODE )
	{
		char name[NAMESIZE+1];

		sprintf( name , "shell.%d.%d" , group_id , comp_id );
		mk_nmg( fdout , name , m );
		fflush( fdout );
	}

	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in make_nmg_objects (after model_fuse)\n" );

	make_nmg_name( name , region_id );

	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in make_nmg_objects (after make_nmg_name)\n" );

	if( polysolids )
	{
		char tmp_name[NAMESIZE+1];
		struct wmember *wmem;
		struct wmember tmp_head;
		int count;

		BU_LIST_INIT( &tmp_head.l );

		for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) )
		{
			NMG_CK_REGION( r );
			for( BU_LIST_FOR( s, shell, &r->s_hd ) )
d1479 1
a1479 2
				NMG_CK_SHELL( s );
				Recalc_edge_g( s );
d1481 1
a1481 2
				if( nmg_simplify_shell( s ) )
					continue;
d1483 2
a1484 7
				if( nmg_kill_cracks( s ) )
					continue;

				if( debug )
					nmg_pr_s_briefly( s, "" );

				if( debug )
d1486 6
a1491 2
					nmg_stash_model_to_file( "shell", m, "shell" );
					nmg_pr_s_briefly( s, "" );
a1492 1

a1493 1
		}
d1495 2
a1496 2
		if(debug)
			nmg_stash_model_to_file( "extruded.g" , m, "extruded" );
d1498 2
a1499 27
		count = nmg_model_edge_g_fuse( m, &tol );
				if( debug )
					bu_log( "%d edge_g's fused\n", count );

		for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) )
		{
			NMG_CK_REGION( r );
			for( BU_LIST_FOR( s, shell, &r->s_hd ) )
			{
				int tmp_id;

				NMG_CK_SHELL( s );

				count = Unbreak_shell_edges( s );
				if( debug )
					bu_log( "%d edges mended by Unbreak_shell_edges()\n", count );

				if( debug )
					nmg_pr_s_briefly( s, "" );

				sol_count++;
				tmp_id = group_id * 1000 + comp_id;
				sprintf( tmp_name, "s.%d.%d", tmp_id, sol_count );
				make_unique_name( tmp_name );
				write_shell_as_polysolid( fdout , tmp_name , s );
				mk_addmember( tmp_name, &tmp_head, WMOP_UNION );
			}
d1501 1
a1501 1
		mk_lcomb( fdout, name, &tmp_head, 0, (char *)NULL, (char *)NULL, (unsigned char *)NULL, 0 );
a1502 2
	else
	{
d1504 1
a1504 7
		/* Check if a valid closed shell has been produced */
		for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) )
		{
			NMG_CK_REGION( r );
			for( BU_LIST_FOR( s, shell, &r->s_hd ) )
			{
				NMG_CK_SHELL( s );
d1506 5
a1510 2
				if( nmg_simplify_shell( s ) )
					continue;
d1512 2
a1513 2
				if( nmg_kill_cracks( s ) )
					continue;
d1515 2
a1516 7
				if( nmg_ck_closed_surf( s , &tol ) )
				{
					bu_log( "Final shell is not closed\n" );
					return( 1 );
				}
			}
		}
d1518 2
a1519 2
		if( debug )
			bu_log( "model fuse\n" );
d1521 2
a1522 1
		nmg_model_fuse( m , &tol );
d1524 1
a1524 6
		for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) )
		{
			NMG_CK_REGION( r );
			for( BU_LIST_FOR( s, shell, &r->s_hd ) )
			{
				NMG_CK_SHELL( s );
d1526 10
a1535 3
				nmg_simplify_shell( s );
			}
		}
d1537 2
a1538 2
		if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
			bu_log( "ERROR: bu_mem_barriercheck failed in make_nmg_objects (before mk_nmg)\n" );
d1540 4
a1543 5
		mk_nmg( fdout , name , m );
		fflush( fdout );

		if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
			bu_log( "ERROR: bu_mem_barriercheck failed in make_nmg_objects (after mk_nmg)\n" );
d1546 2
a1547 1
out:	nmg_km( m );
d1549 2
a1550 3
	m = (struct model *)NULL;
	r = (struct nmgregion *)NULL;
	s = (struct shell *)NULL;
d1552 3
a1554 2
	fus = fus_root;
	while( fus )
d1556 3
a1558 5
		struct fast_fus *tmp;

		tmp = fus;
		fus = fus->next;
		bu_free( (char *)tmp , "make_nmg_objects: fus" );
a1559 1
	fus_root = (struct fast_fus *)NULL;
d1561 1
a1561 2
	adj = adj_root;
	while( adj )
d1563 3
a1565 5
		struct adjacent_faces *tmp;

		tmp = adj;
		adj = adj->next;
		bu_free( (char *)tmp , "make_nmg_objects: adj" );
a1566 1
	adj_root = (struct adjacent_faces *)NULL;
d1568 1
a1568 1
	dup_count = 0;
d1570 2
a1571 2
	if( failed )
		return(1);
d1573 5
a1577 2
	/* make region containing nmg object */
	BU_LIST_INIT( &head.l );
d1579 1
a1579 1
	if( mk_addmember( name , &head , WMOP_UNION ) == (struct wmember *)NULL )
d1581 16
a1596 2
		bu_log( "make_nmg_objects: mk_addmember failed\n" , name );
		rt_bomb( "Cannot make nmg region\n" );
d1600 1
a1600 1
	Subtract_holes( &head , comp_id , group_id );
d1602 2
a1603 1
	MK_REGION( fdout , &head , group_id , comp_id , bot , NMG )
d1605 6
a1610 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in make_nmg_obj\n" );
d1612 1
a1612 1
	return( 0 );
a1613 1
#endif
d2077 1
a2077 1
	struct holes *hole_ptr;
d2091 8
a2098 5
	while( hole_ptr &&
	    hole_ptr->group != gr &&
	    hole_ptr->component != comp &&
	    hole_ptr->type != type &&
	    hole_ptr->next )
d2100 1
d2102 1
a2102 4
	if( !hole_ptr )
		rt_bomb( "ERROR: Add_holes fell off end of list\n" );

	if( hole_ptr->group == gr && hole_ptr->component == comp && hole_ptr->type == type )
d2118 2
a2119 2
		hole_ptr->next = (struct holes *)bu_malloc( sizeof( struct holes ) , "Add_holes: hole_ptr->next" );
		hole_ptr = hole_ptr->next;
d2139 4
a2142 1
	if( !pass )
d2145 4
a2148 2
	if( debug )
		bu_log( "do_hole_wall: %s\n" , line );
d2212 1
a2212 1
#if 0
d2214 2
a2215 3
make_fast_fu( pt1 , pt2 , pt3 , element_id , thick , pos )
int pt1,pt2,pt3;
int element_id;
a2218 6
	struct vertex **verts[3];
	struct faceuse *fu;
	struct loopuse *lu;
	struct fast_fus *fus;
	fastf_t area;
	plane_t pl;
d2220 1
a2220 38
	if( debug )
		bu_log( "make_fast_fu: ( %f %f %f )\n\t( %f %f %f )\n\t( %f %f %f )\n" ,
			V3ARGS( grid_pts[pt1] ), V3ARGS( grid_pts[pt2] ), V3ARGS( grid_pts[pt3] ) );

	verts[0] = &grid_pts[pt1].v;
	verts[1] = &grid_pts[pt2].v;
	verts[2] = &grid_pts[pt3].v;

	if( !m )
	{
		m = nmg_mm();
		NMG_CK_MODEL( m );
		r = nmg_mrsv( m );
		NMG_CK_REGION( r );
		s = BU_LIST_FIRST( shell , &r->s_hd );
	}

	if( debug )
		bu_log( "\tm = x%x\n" , m );

	fu = nmg_cmface( s , verts , 3 );
	if( !fu )
	{
		bu_log( "make_fast_fu: nmg_cmface failed\n" );
		bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
		return;
	}

	if( debug )
		bu_log( "\tfu = x%x\n" , fu );

	lu = BU_LIST_FIRST( loopuse , &fu->lu_hd );
	nmg_vertex_gv( grid_pts[pt1].v , grid_pts[pt1] );
	nmg_vertex_gv( grid_pts[pt2].v , grid_pts[pt2] );
	nmg_vertex_gv( grid_pts[pt3].v , grid_pts[pt3] );

	area = nmg_loop_plane_area( lu , pl );
	if( area <= 0.0 )
d2222 1
a2222 3
		(void)nmg_kfu( fu );
		bu_log( "make_fast_fu: ignoring degenerate face\n" );
		bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
d2226 2
a2227 2
	nmg_face_g( fu , pl );
	nmg_loop_g( lu->l_p , &tol );
a2228 1
	/* save faceuse and thickness info for plate mode */
a2229 13
		Add_fu( fu, thick, pos, pt1, pt2, pt3, element_id );

	if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in make_fast_fu\n" );
}

static int
Check_for_dup_face( pt1, pt2, pt3 )
int pt1, pt2, pt3;
{
	struct nmgregion *tmp_r;

	if( !grid_pts[pt1].v || !grid_pts[pt2].v || !grid_pts[pt3].v )
d2231 1
a2231 9
		/* at least one vertex has not been used before */
		return( 0 );
	}

	for( BU_LIST_FOR( tmp_r, nmgregion, &m->r_hd ) )
	{
		struct shell *tmp_s;

		for( BU_LIST_FOR( tmp_s, shell, &tmp_r->s_hd ) )
d2233 2
a2234 38
			struct faceuse *fu;

			for( BU_LIST_FOR( fu, faceuse, &tmp_s->fu_hd ) )
			{
				struct loopuse *lu;

				if( fu->orientation != OT_SAME )
					continue;

				for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
				{
					struct edgeuse *eu;
					int found=0;
					int vert_count=0;

					if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
						continue;

					for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
					{
						struct vertex *v;

						v = eu->vu_p->v_p;

						vert_count++;
						if( v == grid_pts[pt1].v ||
						    v == grid_pts[pt2].v ||
						    v == grid_pts[pt3].v )
								found++;
					}

					if( vert_count == found )
					{
						Add_dup( fu );
						return( 1 );
					}
				}
			}
a2237 10
	return( 0 );
}
#endif

void
Add_bot_face( pt1, pt2, pt3, thick, pos )
int pt1, pt2, pt3;
fastf_t thick;
int pos;
{
d2250 10
a2259 2
	thickness[face_count] = thick;
	facemode[face_count] = pos;
a2302 7
	if( pt1 == pt2 || pt2 == pt3 || pt1 == pt3 )
	{
		bu_log( "do_tri: ignoring degenerate CTRI element\n" );
		bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
		return;
	}

a2312 9
		if( pos == 0 )	/* use default */
			pos = POS_FRONT;

		if( pos != POS_CENTER && pos != POS_FRONT )
		{
			bu_log( "do_tri: illegal postion parameter (%d), must be one or two\n" , pos );
			bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
			return;
		}
d2441 1
a2441 1
	if( mode == 1 )
a2566 109
#if 0
struct model *
inside_arb( pts , thick )
int pts[8];
fastf_t thick;
{
	int i;
	struct model *m1;
	struct nmgregion *r1;
	struct shell *s1;
	struct faceuse *fu;
	struct vertex **verts[4];
	struct bu_ptbl faces;

	bu_ptbl_init( &faces , 64, " &faces ");

	m1 = nmg_mm();
	r1 = nmg_mrsv( m1 );
	s1 = BU_LIST_FIRST( shell , &r1->s_hd );
	NMG_CK_SHELL( s1 );

	verts[0] = &grid_pts[pts[0]].v;
	verts[1] = &grid_pts[pts[1]].v;
	verts[2] = &grid_pts[pts[2]].v;
	verts[3] = &grid_pts[pts[3]].v;

	fu = nmg_cmface( s1 , verts , 4 );
	bu_ptbl_ins( &faces , (long *)fu );

	verts[0] = &grid_pts[pts[4]].v;
	verts[1] = &grid_pts[pts[5]].v;
	verts[2] = &grid_pts[pts[6]].v;
	verts[3] = &grid_pts[pts[7]].v;

	fu = nmg_cmface( s1 , verts , 4 );
	bu_ptbl_ins( &faces , (long *)fu );

	verts[0] = &grid_pts[pts[0]].v;
	verts[1] = &grid_pts[pts[1]].v;
	verts[2] = &grid_pts[pts[5]].v;
	verts[3] = &grid_pts[pts[4]].v;

	fu = nmg_cmface( s1 , verts , 4 );
	bu_ptbl_ins( &faces , (long *)fu );

	verts[0] = &grid_pts[pts[1]].v;
	verts[1] = &grid_pts[pts[5]].v;
	verts[2] = &grid_pts[pts[6]].v;
	verts[3] = &grid_pts[pts[2]].v;

	fu = nmg_cmface( s1 , verts , 4 );
	bu_ptbl_ins( &faces , (long *)fu );

	verts[0] = &grid_pts[pts[2]].v;
	verts[1] = &grid_pts[pts[6]].v;
	verts[2] = &grid_pts[pts[7]].v;
	verts[3] = &grid_pts[pts[3]].v;

	fu = nmg_cmface( s1 , verts , 4 );
	bu_ptbl_ins( &faces , (long *)fu );

	verts[0] = &grid_pts[pts[0]].v;
	verts[1] = &grid_pts[pts[4]].v;
	verts[2] = &grid_pts[pts[7]].v;
	verts[3] = &grid_pts[pts[3]].v;

	fu = nmg_cmface( s1 , verts , 4 );
	bu_ptbl_ins( &faces , (long *)fu );

	for( i=0 ; i<8 ; i++ )
		nmg_vertex_gv( grid_pts[pts[i]].v , grid_pts[pts[i]] );

	i = 0;
	while( i < BU_PTBL_END( &faces ) )
	{
		struct loopuse *lu;
		fastf_t area;
		plane_t pl;

		fu = (struct faceuse *)BU_PTBL_GET( &faces , i );
		NMG_CK_FACEUSE( fu );

		lu = BU_LIST_FIRST( loopuse , &fu->lu_hd );
		NMG_CK_LOOPUSE( lu );

		area = nmg_loop_plane_area( lu , pl );

		if( area <= 0.0 )
		{
			nmg_kfu( fu );
			bu_ptbl_rm( &faces , (long *)fu );
		}
		else
		{
			nmg_face_g( fu , pl );
			i++;
		}
	}

	nmg_gluefaces( (struct faceuse **)BU_PTBL_BASEADDR( &faces) , BU_PTBL_END( &faces ), &tol );
	bu_ptbl_free( &faces );

	nmg_fix_normals( s1 , &tol );

	if( nmg_extrude_shell( s1 , thick , 0 , 0 , &tol ) == (struct shell *)NULL )
	{
		nmg_km( m1 );
		m1 = (struct model *)NULL;
	}
a2567 3
	return( m1 );
}
#endif
d2584 3
d2599 9
a2641 6
	for( i=0 ; i<8 ; i++ )
		VMOVE( points[i] , grid_pts[pts[i]] );

	make_solid_name( name , CHEX1 , element_id , comp_id , group_id , 0 );
	mk_arb8( fdout , name , &points[0][X] );

d2647 3
a2649 1
	if( mode == PLATE_MODE )
d2651 4
a2654 1
		struct model *m1;
d2656 2
a2657 8
		strncpy( field , &line[56] , 8 );
		thick = atof( field ) * 25.4;
		if( thick <= 0.0 )
		{
			bu_log( "do_hex1: illegal thickness (%f), skipping CHEX1 element\n" , thick );
			bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
			return;
		}
d2659 2
a2660 2
		strncpy( field , &line[64] , 8 );
		pos = atoi( field );
d2662 6
a2667 13
		if( pos == 0 )	/* use default */
			pos = POS_FRONT;

		if( pos != POS_CENTER && pos != POS_FRONT )
		{
			bu_log( "do_hex1: illegal postion parameter (%d), must be 1 or 2, skipping CHEX1 element\n" , pos );
			bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
			return;
		}

		/* get inside arb */
#if 0
		m1 = inside_arb( pts , thick );
d2669 2
a2670 8
		if( m1 == (struct model *)NULL )
		{
			bu_log( "do_hex1: Could not find inside for CHEX1 element\n" , pos );
			bu_log( "\tLeaving CHEX1 element solid\n" );
			bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
			MK_REGION( fdout , &head , group_id , comp_id , element_id , CHEX1 )
			return;
		}
d2672 1
a2672 4
		make_solid_name( name , CHEX1 , element_id , comp_id , group_id , 1 );
		nmg_rebound( m1 , &tol );
		mk_nmg( fdout , name , m1 );
		fflush( fdout );
a2673 7
		if( mk_addmember( name , &head , WMOP_SUBTRACT ) == (struct wmember *)NULL )
			rt_bomb( "CHEX1: mk_addmember failed\n" );

		nmg_km( m1 );
#endif

	}
a2995 10
	/* Initialze tolerance struct */
#if 0
        tol.magic = BN_TOL_MAGIC;
        tol.dist = 0.005;
        tol.dist_sq = tol.dist * tol.dist;
        tol.perp = 1e-6;
        tol.para = 1 - tol.perp;

	max_cos = cos( MIN_ANG*bn_pi/180.0 );
#endif
@


11.26
log
@Corrected usage message.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.25 1999/11/15 13:34:11 jra Exp $";
a5828 2

	printf( "make_bot_object with %d faces\n", face_count );
@


11.25
log
@
Mods to use the new BOT solid.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.24 1999/09/22 15:30:31 jra Exp $";
d99 1
a99 3
static char	*usage="Usage:\n\tfast4-g [-dnwp] [-c component_list] [-o plot_file] [-a min_angle] [-x RT_DEBUG_FLAG] [-X NMG_DEBUG_FLAG] [-D distance] [-P cosine] fastgen4_bulk_data_file output.g\n\
	a - set minimum allowed angle (degrees) between adjacent faces in PLATE mode\n\
		components with smaller angles will be converted using ARB6 solids\n\
d104 1
@


11.24
log
@Corrected handling of holes and converted sphere radius to mm
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.23 1999/06/03 21:54:19 mike Exp $";
a46 4
#define		MIN_ANG		5.0	/* 5 degrees, used in checking for acute angles
					 * between adjacent faces in PLATE-MODE
					 */

d69 1
a69 1
static int	nmgs=0;			/* Flag: >0 -> There are NMG's in current component */
a73 2
static int	polysolids=1;		/* Flag: >0 -> Build polysolids, not NMG's */
static fastf_t	max_cos=0.0;		/* cosine of minimum allowed angle between faces in PLATE mode components */
a75 2
static int	conv_count=0;		/* Count of components successfully converted to BRLCAD */
static int	second_chance=0;	/* Count of PLATE-MODE objects converted on second try */
a78 3
static int	try_count=0;		/* Counter for number of tries to build currect section */
static int	arb6_worked=0;		/* flag notifying of Make_arb6_obj() success */
static int	use_arb6=0;		/* flag indicating that all plate-mode should be converted as ARB6's */
d87 6
a92 9
static struct model	*m;		/* NMG model for surface elements */
static struct nmgregion	*r;		/* NMGregion */
static struct shell	*s;		/* NMG shell */
static struct bn_tol	tol;		/* Tolerance struct for NMG's */

static struct faceuse	**dup_fu;	/* NMG faceuses that were duplicates */
static int		dup_count=0;	/* number of faceuses in the dup_fu list */
static int		dup_size=0;	/* size of dup_fu array */
#define		DUP_BLOCK	64	/* Number of elements in initial dup_fu array */
a102 1
	n - produce NMG solids rather than polysolids\n\
a103 1
	p - convert all plate-mode components as ARB6 solids\n\
d106 2
a107 10
	x - set RT debug flag\n\
	X - set NMG debug flag\n\
	D - set tolerance distance (mm)\n\
	P - set tolerance for parallel test (cosine of angle)\n";

RT_EXTERN( fastf_t nmg_loop_plane_area , ( struct loopuse *lu , plane_t pl ) );
RT_EXTERN( struct shell *nmg_dup_shell , ( struct shell *s , long ***copy_tbl, struct bn_tol *tol ) );
RT_EXTERN( struct shell *nmg_extrude_shell , ( struct shell *s1 , fastf_t thick , int normal_ward , int approximate , struct bn_tol *tol ) );
RT_EXTERN( struct edgeuse *nmg_next_radial_eu , ( CONST struct edgeuse *eu , CONST struct shell *s , int wires ) );
RT_EXTERN( struct faceuse *nmg_mk_new_face_from_loop , ( struct loopuse *lu ) );
a108 2
RT_EXTERN( struct faceuse *nmg_mk_new_face_from_loop, ( struct loopuse *lu ) );
RT_EXTERN( void Fix_normals, ( struct shell *sh ) );
d130 1
d219 1
a219 30
struct fast_verts
{
	point_t pt;
	struct vertex *v;
} *grid_pts;

struct fast_fus
{
	struct faceuse *fu;
	fastf_t thick;
	int pos;
	int element;
	int pt1, pt2, pt3;
	struct fast_fus *next;
} *fus_root;

struct adjacent_faces
{
	struct faceuse *fu1,*fu2;
	struct edgeuse *eu1,*eu2;
	struct adjacent_faces *next;
} *adj_root;

struct elem_list
{
	int element;
	int no_pts;
	int pt[4];
	struct elem_list *next;
} *elem_root;
a222 2
#define NMG_PUSH( _ptr , _stack )       bu_ptbl_ins_unique( _stack , (long *) _ptr )

d262 4
a265 4
	pdv_3move( fd_plot, grid_pts[pt1].pt );
	pdv_3cont( fd_plot, grid_pts[pt2].pt );
	pdv_3cont( fd_plot, grid_pts[pt3].pt );
	pdv_3cont( fd_plot, grid_pts[pt1].pt );
d267 1
a267 1

d541 1
a541 1
							VSUB2( v0, grid_pts[elem->pt[0]].pt, grid_pts[elem->pt[1]].pt );
d544 1
a544 1
							VSUB2( v0, grid_pts[elem->pt[0]].pt, grid_pts[elem->pt[2]].pt );
d547 1
a547 1
							VSUB2( v0, grid_pts[elem->pt[1]].pt, grid_pts[elem->pt[2]].pt );
d550 1
a550 1
							VSUB2( v0, grid_pts[elem->pt[0]].pt, grid_pts[elem->pt[3]].pt );
d553 1
a553 1
							VSUB2( v0, grid_pts[elem->pt[1]].pt, grid_pts[elem->pt[3]].pt );
d556 1
a556 1
							VSUB2( v0, grid_pts[elem->pt[2]].pt, grid_pts[elem->pt[3]].pt );
d568 3
a570 3
							grid_pts[pt1].pt,
							grid_pts[pt2].pt,
							grid_pts[pt3].pt, &tol ) )
d574 3
a576 3
							grid_pts[elem->pt[0]].pt,
							grid_pts[elem->pt[1]].pt,
							grid_pts[elem->pt[2]].pt, &tol ) )
d629 1
a629 1
						VSUB2( v1, grid_pts[odd_pt].pt, grid_pts[match_pt].pt );
d638 1
a638 1
							VSUB2( v2, grid_pts[elem->pt[i]].pt, grid_pts[match_pt].pt );
d754 1
a754 1
						VSUB2( v0, grid_pts[elem->pt[0]].pt, grid_pts[elem->pt[1]].pt );
d757 1
a757 1
						VSUB2( v0, grid_pts[elem->pt[0]].pt, grid_pts[elem->pt[2]].pt );
d760 1
a760 1
						VSUB2( v0, grid_pts[elem->pt[1]].pt, grid_pts[elem->pt[2]].pt );
d763 1
a763 1
						VSUB2( v0, grid_pts[elem->pt[0]].pt, grid_pts[elem->pt[3]].pt );
d766 1
a766 1
						VSUB2( v0, grid_pts[elem->pt[1]].pt, grid_pts[elem->pt[3]].pt );
d769 1
a769 1
						VSUB2( v0, grid_pts[elem->pt[2]].pt, grid_pts[elem->pt[3]].pt );
d781 3
a783 3
						grid_pts[pt1].pt,
						grid_pts[pt2].pt,
						grid_pts[pt3].pt, &tol ) )
d787 3
a789 3
						grid_pts[elem->pt[0]].pt,
						grid_pts[elem->pt[1]].pt,
						grid_pts[elem->pt[2]].pt, &tol ) )
d842 1
a842 1
					VSUB2( v1, grid_pts[odd_pt].pt, grid_pts[match_pt].pt );
d851 1
a851 1
						VSUB2( v2, grid_pts[elem->pt[i]].pt, grid_pts[match_pt].pt );
d1051 1
a1051 1

d2231 1
a2231 1
		grid_pts = (struct fast_verts *)rt_realloc( (char *)grid_pts , grid_size * sizeof( struct fast_verts ) , "fast4-g: grid_pts" );
d2234 1
a2234 2
	VSET( grid_pts[grid_no].pt , x*25.4 , y*25.4 , z*25.4 );
	grid_pts[grid_no].v = (struct vertex *)NULL;
d2307 1
a2307 1
			mk_sph( fdout , name , grid_pts[pt_no].pt , sph_radius );
d2322 1
a2322 1
				mk_sph( fdout , name , grid_pts[pt_no].pt , sph_inner_radius );
d2490 1
a2490 1
	mk_sph( fdout , name , grid_pts[center_pt].pt , radius );
d2509 1
a2509 1
		mk_sph( fdout , name , grid_pts[center_pt].pt , inner_radius );
d2533 1
a2533 1

d4060 3
a4062 3
			VMOVE( pts[0], grid_pts[fus->pt1].pt )
			VMOVE( pts[1], grid_pts[fus->pt2].pt )
			VMOVE( pts[4], grid_pts[fus->pt3].pt )
d4122 1
a4122 1
	MK_REGION( fdout , &head , group_id , comp_id , nmgs , NMG )
a4520 6
	else if( mode == PLATE_MODE && (try_count || use_arb6) )
	{
		Make_arb6_obj();
		arb6_worked = 1;
		return(0);
	}
a4849 2
	try_count = 0;

a4877 11
	elem = elem_root;
	while( elem )
	{
		struct elem_list *tmp;

		tmp = elem;
		elem = elem->next;
		bu_free( (char *)tmp, "make_nmg_objects: elem" );
	}
	elem_root = (struct elem_list *)NULL;

d4895 1
a4895 1
	MK_REGION( fdout , &head , group_id , comp_id , nmgs , NMG )
d4902 1
d4999 1
a4999 1
	VSUB2( height , grid_pts[pt2].pt , grid_pts[pt1].pt );
d5002 1
a5002 1
	mk_rcc( fdout , name , grid_pts[pt1].pt , height , radius );
d5014 1
a5014 1
		mk_rcc( fdout , name , grid_pts[pt1].pt , height , radius-thick );
d5138 1
a5138 1
	VSUB2( height , grid_pts[pt2].pt , grid_pts[pt1].pt );
d5140 1
a5140 1
	mk_trc_h( fdout , outer_name , grid_pts[pt1].pt , height , r1 , r2 );
d5170 1
a5170 1
			VMOVE( base , grid_pts[pt1].pt );
d5176 1
a5176 1
			VJOIN1( base , grid_pts[pt1].pt , thick , height_dir );
d5194 1
a5194 1
			VMOVE( top , grid_pts[pt2].pt );
d5200 1
a5200 1
			VJOIN1( top , grid_pts[pt2].pt , -thick , height_dir );
d5330 1
a5330 1
	VSUB2( height , grid_pts[pt2].pt , grid_pts[pt1].pt );
d5333 1
a5333 1
	mk_trc_h( fdout , name , grid_pts[pt1].pt , height , ro1 , ro2 );
d5347 1
a5347 1
		mk_trc_h( fdout , name , grid_pts[pt1].pt , height , ri1 , ri2 );
d5495 1
a5495 1

d5512 1
a5512 1
			V3ARGS( grid_pts[pt1].pt ), V3ARGS( grid_pts[pt2].pt ), V3ARGS( grid_pts[pt3].pt ) );
d5542 3
a5544 3
	nmg_vertex_gv( grid_pts[pt1].v , grid_pts[pt1].pt );
	nmg_vertex_gv( grid_pts[pt2].v , grid_pts[pt2].pt );
	nmg_vertex_gv( grid_pts[pt3].v , grid_pts[pt3].pt );
d5627 25
d5668 2
a5669 2
	if( !nmgs )
		nmgs = element_id;
d5674 9
d5699 2
a5700 9
	/* check if this face has already been modelled (FASTGEN4 error) */
	if( Check_for_dup_face( pt1, pt2, pt3 ) )
	{
		bu_log( "Duplicate face in element %d, component %d, group %d\n" , element_id , comp_id , group_id );
		bu_log( "\t grid points %d %d %d\n", pt1, pt2, pt3 );
		bu_log( "\tthis face ignored\n" );
		return;
	}

a5704 6
		if( thick <= 0.0 )
		{
			bu_log( "do_tri: illegal thickness (%f), skipping CTRI element\n" , thick );
			bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
			return;
		}
a5719 1
	}
d5721 2
a5722 7
	overlap = Check_tri_overlap( element_id, pt1, pt2, pt3);
	if( overlap )
	{
		bu_log( "WARNING: CTRI element %d overlaps with existing element %d\n",
			element_id, overlap );
		bu_log( "\tCTRI element %d ignored\n", element_id );
		return;
d5727 2
a5728 2
	make_fast_fu( pt1 , pt2 , pt3 , element_id , thick , pos );
	Add_elem( element_id, 3, pt1, pt2, pt3, -1 );
a5737 2
	int overlap;
	int skipped=0;
d5745 2
a5746 2
	if( !nmgs )
		nmgs = element_id;
d5751 9
a5775 6
		if( thick <= 0.0 )
		{
			bu_log( "do_quad: illegal thickness (%f), skipping CQUAD element\n" , thick );
			bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
			return;
		}
d5791 2
a5792 91
	overlap = Check_quad_overlap( element_id, pt1, pt2, pt3, pt4 );
	if( overlap > 0 )
	{
		bu_log( "WARNING: CQUAD element %d overlaps with existing CQUAD element %d\n",
			element_id, overlap );
		bu_log( "\tCQUAD element %d ignored\n", element_id );
		(void)Check_for_dup_face( pt1, pt2, pt3 );
		(void)Check_for_dup_face( pt1, pt3, pt4 );
		return;
	}
	else if( overlap < 0 )
	{
		int i;

		i = pt1;
		pt1 = pt2;
		pt2 = pt3;
		pt3 = pt4;
		pt4 = i;
	}

	if( pt1 == pt2 || pt2 == pt3 || pt1 == pt3 )
	{
		bu_log( "do_quad: ignoring degenerate triangular face in CQUAD element\n" );
		bu_log( "\t\t%d %d %d\n", pt1, pt2, pt3 );
		bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
		skipped = 1;
	}
	else if( Check_for_dup_face( pt1, pt2, pt3 ) )
	{
		bu_log( "Duplicate face in element %d, component %d, group %d\n" , element_id , comp_id , group_id );
		bu_log( "\t grid points %d %d %d\n", pt1, pt2, pt3 );
		bu_log( "\tthis face ignored\n" );
		skipped = 1;
	}
	else
	{
		overlap = Check_tri_overlap( element_id, pt1, pt2, pt3 );
		if( overlap )
		{
			bu_log( "WARNING: CQUAD element %d overlaps with existing element %d\n",
				element_id, overlap );
			bu_log( "\tPart of CQUAD element %d ignored\n", element_id );
			skipped = 1;
		}
		else
		{
			if( do_plot )
				plot_tri( pt1, pt2, pt3 );
			make_fast_fu( pt1 , pt2 , pt3 , element_id , thick , pos );
		}
	}

	if( pt1 == pt3 || pt3 == pt4 || pt1 == pt4 )
	{
		bu_log( "do_quad: ignoring degenerate triangular face in CQUAD element\n" );
		bu_log( "\t\t%d %d %d\n", pt1, pt3, pt4 );
		bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
		skipped += 2;
	}
	else if( Check_for_dup_face( pt1, pt3, pt4 ) )
	{
		bu_log( "Duplicate face in element %d, component %d, group %d\n" , element_id , comp_id , group_id );
		bu_log( "\t grid points %d %d %d\n", pt1, pt3, pt4 );
		bu_log( "\tthis face ignored\n" );
		skipped += 2;
	}
	else
	{
		overlap = Check_tri_overlap( element_id, pt1, pt3, pt4 );
		if( overlap )
		{
			bu_log( "WARNING: CQUAD element %d overlaps with existing element %d\n",
				element_id, overlap );
			bu_log( "\tPart of CQUAD element %d ignored\n", element_id );
			skipped += 2;
		}
		else
		{
			if( do_plot )
				plot_tri( pt1, pt3, pt4 );
			make_fast_fu( pt1 , pt3 , pt4 , element_id , thick , pos );
		}
	}

	if( !skipped )
		Add_elem( element_id, 4, pt1, pt2, pt3, pt4 );
	else if( skipped == 1 )
		Add_elem( element_id, 3, pt1, pt3, pt4, -1 );
	else if( skipped == 2 )
		Add_elem( element_id, 3, pt1, pt2, pt3, -1 );
a5812 1
/*	cleanup from previous component and start a new one */
d5814 1
a5814 2
do_section( final )
int final;
d5816 8
d5825 5
a5829 4
	static int	old_region_id;

	if( debug )
		bu_log( "do_section: %s\n" , line );
d5831 1
a5831 2
	prev_sect = curr_sect;
	curr_sect = curr_offset;
d5833 1
a5833 1
	if( pass )
d5835 7
a5841 2
		if( try_count )
			region_id = old_region_id;
d5843 1
a5843 4
		if( region_id && !skip_region( region_id ) )
		{
			if( !try_count )
				comp_count++;
d5845 2
a5846 7
			if( nmgs )
			{
			    if( (BU_SETJUMP) || make_nmg_objects() )
			    {
				struct fast_fus *fus;
				struct adjacent_faces *adj;
			    	struct elem_list *elem;
d5848 13
a5860 2
				bu_log( "***********component %s, group #%d, component #%d failed\n",
					name_name, group_id , comp_id );
d5862 1
a5862 3
				if( m )
				{
					nmg_km( m );
d5864 3
a5866 2
					if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
						bu_log( "ERROR: bu_mem_barriercheck failed in Do_section after nmg_km()\n" );
d5868 5
a5872 4
					m = (struct model *)NULL;
					r = (struct nmgregion *)NULL;
					s = (struct shell *)NULL;
				}
d5874 2
a5875 2
				if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
					bu_log( "ERROR: bu_mem_barriercheck failed in Do_section before freeing fus list\n" );
d5877 2
a5878 5
				/* clear lists */
				fus = fus_root;
				while( fus )
				{
					struct fast_fus *tmp;
d5880 2
a5881 5
					tmp = fus;
					fus = fus->next;
					bu_free( (char *)tmp , "Do_section: fus" );
				}
				fus_root = (struct fast_fus *)NULL;
d5883 7
a5889 2
				if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
					bu_log( "ERROR: bu_mem_barriercheck failed in Do_section before freeing adj_face list\n" );
d5891 1
a5891 4
				adj = adj_root;
				while( adj )
				{
					struct adjacent_faces *tmp;
d5893 2
a5894 5
					tmp = adj;
					adj = adj->next;
					bu_free( (char *)tmp , "Do_section: adj" );
				}
				adj_root = (struct adjacent_faces *)NULL;
d5896 2
a5897 4
				elem = elem_root;
				while( elem )
				{
					struct elem_list *tmp;
d5899 5
a5903 16
					tmp = elem;
					elem = elem->next;
					bu_free( (char *)tmp, "Do_section: elem" );
				}
				elem_root = (struct elem_list *)NULL;

			    	dup_count = 0;

				if( rt_g.debug&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
					bu_log( "ERROR: bu_mem_barriercheck failed in Do_section after freeing adj_face list\n" );

				/* If a plate-mode component failed, try again using arb6's */
				if( mode == PLATE_MODE )
				{
					/* increment try counter */
					try_count++;
d5905 2
a5906 20
					if( try_count == 1 )
					{
						if( fseek( fdin , prev_sect , SEEK_SET ) )
						{
							bu_log( "Cannot seek in input file, not retrying group %d, comnponent %d\n",
								group_id , comp_id );
						}
						else
						{
							bu_log( "Retrying group %d, component %d\n",
								group_id , comp_id );
							(void)getline();
							old_region_id = region_id;
						}
					}
				}
				conv_count--;
			    }
			    BU_UNSETJUMP;
			}
a5908 8
			if( arb6_worked )
			{
				second_chance++;
				try_count = 0;
				arb6_worked = 0;
			}
			else
				conv_count++;
d5914 1
a5914 1
	else if( nmgs )
d5918 1
a5918 1
		make_region_name( name , group_id , comp_id , nmgs , NMG );
d5970 2
a5971 1
		nmgs = 0;
d5974 1
a5974 1

d6044 1
a6044 1
		nmg_vertex_gv( grid_pts[pts[i]].v , grid_pts[pts[i]].pt );
d6086 1
a6086 1

d6150 1
a6150 1
		VMOVE( points[i] , grid_pts[pts[i]].pt );
d6187 1
d6208 1
d6278 1
a6278 1
		VMOVE( points[i] , grid_pts[pts[i]].pt );
d6303 1
a6303 1
		bu_log( "\n\nProcess_input( pass = %d ), try = %d\n" , pass_number , try_count );
a6363 3
	if( try_count )
		return( 1 );

d6534 1
d6542 1
a6542 1

a6553 6
			case 'p':	/* convert plate-mode componnets as ARB6's */
				use_arb6 = 1;
				break;
			case 'a':	/* minimum angle */
				max_cos = cos( atof( optarg )*bn_pi/180.0 );
				break;
a6556 3
			case 'n':
				polysolids = 0;
				break;
a6563 4
			case 'X':
				sscanf( optarg, "%x", &nmg_debug );
				rt_g.NMG_debug = nmg_debug;
				break;
a6566 11
			case 'D':
				tol.dist = atof( optarg );
				bu_log( "tolerance distance set to %f\n" , tol.dist );
				tol.dist_sq = tol.dist * tol.dist;
				break;
			case 'P':
				tol.perp = atof( optarg );
				bu_log( "tolerance perpendicular set to %f\n" , tol.perp );
				tol.para = 1.0 - tol.perp;
				bu_log( "tolerance parallel set to %f\n" , tol.para );
				break;
d6615 1
a6615 1
	grid_pts = (struct fast_verts *)bu_malloc( grid_size * sizeof( struct fast_verts ) , "fast4-g: grid_pts" );
a6623 10
	fus_root = (struct fast_fus *)NULL;

	adj_root = (struct adjacent_faces *)NULL;

	elem_root = (struct elem_list *)NULL;

	dup_count = 0;
	dup_fu = (struct faceuse **)bu_calloc( DUP_BLOCK, sizeof( struct faceuse *), "dup_fu" );
	dup_size = DUP_BLOCK;

a6628 4
	m = (struct model *)NULL;
	r = (struct nmgregion *)NULL;
	s = (struct shell *)NULL;

d6656 1
a6656 3
	bu_log( "%d components converted out of %d attempted\n" , conv_count , comp_count );
	bu_log( "\t%d rejections or failures converted on second try (as a group of ARB6 solids)\n", second_chance );
	bu_log( "\tFor a total of %d components converted\n" , conv_count+second_chance );
@


11.23
log
@
sed4
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.22 1999/06/03 13:38:54 jra Exp $";
d96 1
d236 1
d241 3
d279 35
d2073 4
a2076 1
		add_to_series( name , region_id );
d2107 3
d2526 1
a2526 1
	thick = atof( field );
d2529 1
a2529 1
	radius = atof( field );
d5435 2
a5436 1
Add_holes( gr , comp , ptr )
d5448 1
d5458 1
d5465 1
a5465 1
	if( hole_ptr->group == gr && hole_ptr->component == comp )
d5479 10
a5488 7

	hole_ptr->next = (struct holes *)bu_malloc( sizeof( struct holes ) , "Add_holes: hole_ptr->next" );
	hole_ptr = hole_ptr->next;
	hole_ptr->group = gr;
	hole_ptr->component = comp;
	hole_ptr->holes = ptr;
	hole_ptr->next = (struct holes *)NULL;
d5492 2
a5493 1
do_hole_wall()
d5551 1
a5551 1
	Add_holes( group , comp , list_start );
d6500 1
a6500 1
			do_hole_wall();
d6502 1
a6502 1
			do_hole_wall();
d6850 2
@


11.22
log
@Subtract_holes() call was missing from do_hex2()
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.21 1999/05/26 23:02:17 jra Exp $";
d96 1
a96 1
static struct nmg_ptbl stack;		/* Stack for traversing name_tree */
d100 1
a100 1
static struct rt_tol	tol;		/* Tolerance struct for NMG's */
d128 1
a128 1
RT_EXTERN( struct shell *nmg_extrude_shell , ( struct shell *s1 , fastf_t thick , int normal_ward , int approximate , struct rt_tol *tol ) );
d167 2
a168 2
#define	PUSH( ptr )	nmg_tbl( &stack , TBL_INS , (long *)ptr )
#define POP( structure , ptr )	{ if( NMG_TBL_END( &stack ) == 0 ) \
d172 2
a173 2
			  	ptr = (struct structure *)NMG_TBL_GET( &stack , NMG_TBL_END( &stack )-1 ); \
			  	nmg_tbl( &stack , TBL_RM , (long *)ptr ); \
d207 1
a207 1
			rt_log( "ERROR: Null name_tree pointer, file=%s, line=%d\n", __FILE__, __LINE__ );\
d209 1
a209 1
			rt_log( "ERROR: bad name_tree pointer (x%x), file=%s, line=%d\n", ptr, __FILE__, __LINE__ );\
d467 1
a467 1
		elem_root = (struct elem_list *)rt_malloc( sizeof( struct elem_list ), "Add_elem: elem_root" );
d476 1
a476 1
		elem->next = (struct elem_list *)rt_malloc( sizeof( struct elem_list ), "Add_elem: elem" );
d1046 1
a1046 1
		fus_root = (struct fast_fus *)rt_malloc( sizeof( struct fast_fus ) , "fus_root" );
d1054 1
a1054 1
		fus->next = (struct fast_fus *)rt_malloc( sizeof( struct fast_fus ) , "fus" );
d1076 1
a1076 1
	nmg_tbl( &stack , TBL_RST , (long *)NULL );
d1131 1
a1131 1
			int_list = (int *)rt_malloc( INT_LIST_BLOCK*sizeof( int ) , "insert_id: int_list" );
d1140 2
a1141 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in insert_int\n" );
d1147 1
a1147 1
CONST struct rt_tol	*tmp_tol;
d1164 1
a1164 1
	flags1 = (char *)rt_calloc( sizeof(char), m->maxindex * 2,
d1166 1
a1166 1
	flags2 = (char *)rt_calloc( sizeof(char), m->maxindex * 2,
d1170 1
a1170 1
	for( RT_LIST_FOR( fu1, faceuse, &s->fu_hd ) )  {
d1173 1
a1173 1
		if( RT_LIST_NEXT_IS_HEAD(fu1, &s->fu_hd) )  break;
d1186 3
a1188 3
		for( fu2 = RT_LIST_NEXT(faceuse, &fu1->l);
		     RT_LIST_NOT_HEAD(fu2, &s->fu_hd);
		     fu2 = RT_LIST_NEXT(faceuse,&fu2->l)
d1215 1
a1215 1
				 *  Can't just use RT_VECT_ARE_PARALLEL here,
d1231 1
a1231 1
				prev_fu = RT_LIST_PREV(faceuse, &fu2->l);
d1233 1
a1233 1
				if( RT_LIST_IS_HEAD(prev_fu, &s->fu_hd) )
d1242 2
a1243 2
						rt_log( "Merging coplanar faces:\n" );
						rt_log( "plane = ( %f %f %f %f )\n" , V4ARGS( fu1->f_p->g.plane_p->N ) );
d1245 1
a1245 1
						rt_log( "plane = ( %f %f %f %f )\n" , V4ARGS( fu2->f_p->g.plane_p->N ) );
d1262 1
a1262 1
				for (RT_LIST_FOR(lu, loopuse, &fu1->lu_hd))
d1267 2
a1268 2
	rt_free( (char *)flags1, "tmp_shell_coplanar_face_merge flags1[]" );
	rt_free( (char *)flags2, "tmp_shell_coplanar_face_merge flags2[]" );
d1271 1
a1271 1
		rt_log("tmp_shell_coplanar_face_merge(s=x%x, tol=x%x, simplify=%d)\n",
d1274 2
a1275 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in tmp_shell_coplanar_face_merge\n" );
d1288 1
a1288 1
		rt_log( "Subtract_holes( comp_id=%d, group_id=%d )\n" , comp_id , group_id );
d1316 1
a1316 1
					rt_log( "ERROR: Can't find holes to subtract for group %d, component %d\n" , group_id , comp_id );
d1320 1
a1320 1
				nmg_tbl( &stack , TBL_RST , (long *)NULL );
d1345 2
a1346 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in subtract_holes\n" );
d1359 1
a1359 1
		rt_log( "Holes for Group %d, Component %d:\n" , hole_ptr->group, hole_ptr->component );
d1363 1
a1363 1
			rt_log( "\tgroup %d component %d\n" , list_ptr->group, list_ptr->component );
d1375 1
a1375 1
	nmg_tbl( &stack , TBL_RST , (long *)NULL );
d1377 1
a1377 1
	rt_log( "\nNames in ident order:\n" );
d1390 1
a1390 1
		rt_log( "%s %d %d\n" , ptr->name , ptr->region_id , ptr->element_id );
d1394 1
a1394 1
	rt_log( "\tAlphabetical list of names:\n" );
d1407 1
a1407 1
		rt_log( "%s\n" , ptr->name );
d1632 3
a1634 3
		rt_free( (char *)ptr , "Delete_name: ptr" );
		if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
			rt_log( "ERROR: rt_mem_barriercheck failed in Delete_name\n" );
d1708 1
a1708 1
		rt_log( "name (%s) deleted from name tree, but not found in ident tree!!\n" , name );
d1714 1
a1714 1
		rt_log( "name (%s) is root of ident tree, but not name tree!!\n" , name );
d1745 3
a1747 3
	rt_free( (char *)ptr , "Delete_name: ptr" );
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in Delete_name\n" );
d1765 1
a1765 1
		rt_log( "Insert_name: %s already in name tree\n" , name );
d1769 1
a1769 1
	new_ptr = (struct name_tree *)rt_malloc( sizeof( struct name_tree ) , "Insert_name: new_ptr" );
d1792 1
a1792 1
			rt_log( "Insert_name: ptr->nright not null\n" );
d1801 1
a1801 1
			rt_log( "Insert_name: ptr->nleft not null\n" );
d1806 2
a1807 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in Insert_name\n" );
d1822 1
a1822 1
		rt_log( "Insert_region_name( name=%s, reg_id=%d, el_id=%d\n" , name, reg_id, el_id );
d1832 1
a1832 1
		rt_log( "Insert_region_name: name %s ident %d element %d\n\tfound name is %d\n\tfound ident is %d\n",
d1839 1
a1839 1
	new_ptr = (struct name_tree *)rt_malloc( sizeof( struct name_tree ) , "Insert_region_name: new_ptr" );
d1860 1
a1860 1
				rt_log( "Insert_region_name: nptr_model->nright not null\n" );
d1869 1
a1869 1
				rt_log( "Insert_region_name: nptr_model->nleft not null\n" );
d1885 1
a1885 1
				rt_log( "Insert_region_name: rptr_model->rright not null\n" );
d1894 1
a1894 1
				rt_log( "Insert_region_name: rptr_model->rleft not null\n" );
d1901 2
a1902 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in Insert_region_name\n" );
d1918 1
a1918 1
		rt_log( "find_region_name( g_id=%d, c_id=%d, el_id=%d ), reg_id=%d\n" , g_id, c_id, el_id, reg_id );
d1958 2
a1959 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in make_unique_name\n" );
d1969 1
a1969 1
		rt_log( "add_to_series: region (%s) not added, illegal group number %d, region_id=$d\n" ,
d1975 1
a1975 1
		rt_log( "add_to_series: mk_addmember failed for region %s\n" , name );
d1985 2
a1986 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in make_comp_group\n" );
d1988 1
a1988 1
	RT_LIST_INIT( &g_head.l );
d1990 1
a1990 1
	nmg_tbl( &stack , TBL_RST , (long *)NULL );
d2008 1
a2008 1
				rt_log( "make_comp_group: Could not add %s to group for ident %d\n" , ptr->name , ptr->region_id );
d2016 1
a2016 1
	if( RT_LIST_NON_EMPTY( &g_head.l ) )
d2027 1
a2027 1
				rt_log( "Creating default name (%s) for group %d component %d\n",
d2044 1
a2044 1
		rt_log( "do_groups\n" );
d2046 1
a2046 1
	RT_LIST_INIT( &head_all.l );
d2052 1
a2052 1
		if( RT_LIST_IS_EMPTY( &group_head[group_no].l ) )
d2059 1
a2059 1
			rt_log( "do_groups: mk_addmember failed to add %s to group all\n" , name );
d2062 1
a2062 1
	if( RT_LIST_NON_EMPTY( &head_all.l ) )
d2080 1
a2080 1
		rt_log( "do_name: %s\n" , line );
d2087 2
a2088 2
		rt_log( "$NAME card for group %d in section for group %d ignored\n" , g_id , group_id );
		rt_log( "%s\n" , line );
d2097 2
a2098 2
		rt_log( "$NAME card for component %d in section for component %d ignored\n" , c_id , comp_id );
		rt_log( "%s\n" , line );
d2138 2
a2139 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in do_name\n" );
d2156 1
a2156 1
		rt_log( "make_region_name( g_id=%d, c_id=%d, element_id=%d, type=%c )\n" , g_id, c_id, element_id, type );
d2217 2
a2218 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed at start of do_grid\n" );
d2225 1
a2225 1
		rt_log( "ERROR: grid id number = %d\n" , grid_no );
d2249 2
a2250 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed at end of do_grid\n" );
d2262 1
a2262 1
		rt_log( "make_cline_regions\n" );
d2264 1
a2264 1
	RT_LIST_INIT( &head.l );
d2282 1
a2282 1
		struct nmg_ptbl lines;
d2286 1
a2286 1
		nmg_tbl( &lines , TBL_INIT , (long *)NULL );
d2305 1
a2305 1
				nmg_tbl( &lines , TBL_INS , (long *)cline_ptr );
d2311 1
a2311 1
		if( NMG_TBL_END( &lines ) > 1 )
d2323 2
a2324 2
				rt_log( "make_cline_regions: mk_addmember failed for outer sphere %s\n" , name );
				nmg_tbl( &lines , TBL_FREE , (long *)NULL );
d2337 2
a2338 2
					rt_log( "make_cline_regions: mk_addmember failed for outer sphere %s\n" , name );
					nmg_tbl( &lines , TBL_FREE , (long *)NULL );
d2344 1
a2344 1
			for( line_no=0 ; line_no < NMG_TBL_END( &lines ) ; line_no++ )
d2346 1
a2346 1
				cline_ptr = (struct cline *)NMG_TBL_GET( &lines , line_no );
d2351 2
a2352 2
					rt_log( "make_cline_regions: mk_addmember failed for line at joint %s\n" , name );
					nmg_tbl( &lines , TBL_FREE , (long *)NULL );
d2361 1
a2361 1
			if( RT_LIST_NON_EMPTY( &head.l ) )
d2377 1
a2377 1
		for( line_no=0 ; line_no < NMG_TBL_END( &lines ) ; line_no++ )
d2380 1
a2380 1
			cline_ptr = (struct cline *)NMG_TBL_GET( &lines , line_no ) ;
d2390 1
a2390 1
				rt_log( "make_cline_regions: mk_addmember failed for outer solid %s\n" , name );
d2401 1
a2401 1
					rt_log( "make_cline_regions: mk_addmember failed for inner solid %s\n" , name );
d2407 1
a2407 1
			for( i=0 ; i < NMG_TBL_END( &lines ) ; i++ )
d2411 1
a2411 1
				ptr2 = (struct cline *)NMG_TBL_GET( &lines , i );
d2419 1
a2419 1
						rt_log( "make_cline_regions: mk_addmember failed for inner solid %s\n" , name );
d2431 1
a2431 1
		nmg_tbl( &lines , TBL_FREE , (long *)NULL );
d2445 1
a2445 1
		rt_free( (char *)ptr , "make_cline_regions: cline_ptr" );
d2451 2
a2452 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in make_cline_regions\n" );
d2486 2
a2487 2
		rt_log( "do_sphere: illegal radius (%f), skipping sphere\n" , radius );
		rt_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
d2493 2
a2494 2
		rt_log( "do_sphere: illegal grid number for center point %d, skipping sphere\n" , center_pt );
		rt_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
d2498 1
a2498 1
	RT_LIST_INIT( &sphere_region.l );
d2505 1
a2505 1
		rt_log( "do_sphere: Error in adding %s to sphere region\n" , name );
d2514 2
a2515 2
			rt_log( "do_sphere: illegal thickness (%f), skipping inner sphere\n" , thick );
			rt_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
d2524 1
a2524 1
			rt_log( "do_sphere: Error in subtracting %s from sphere region\n" , name );
d2549 1
a2549 1
	struct nmg_ptbl verts;
d2553 1
a2553 1
		rt_log( "Check_normals\n" );
d2555 1
a2555 1
	nmg_tbl( &verts , TBL_INIT , (long *)NULL );
d2562 1
a2562 1
	for( RT_LIST_FOR( s1 , shell , &r->s_hd ) )
d2575 1
a2575 1
		for( i=0 ; i<NMG_TBL_END( &verts ) ; i++ )
d2577 1
a2577 1
			v = (struct vertex *)NMG_TBL_GET( &verts , i );
d2581 1
a2581 1
		VSCALE( shell_center , shell_center , (fastf_t)(NMG_TBL_END( &verts ) ) );
d2583 1
a2583 1
		nmg_tbl( &verts , TBL_RST , (long *)NULL );
d2586 1
a2586 1
		for( RT_LIST_FOR( fu , faceuse , &s1->fu_hd ) )
d2600 1
a2600 1
			lu = RT_LIST_FIRST( loopuse , &fu->lu_hd );
d2602 1
a2602 1
			eu = RT_LIST_FIRST( edgeuse , &lu->down_hd );
d2612 1
a2612 1
			if( RT_VECT_ARE_PERP( dot , &tol ) )
d2627 2
a2628 2
	s1 = RT_LIST_FIRST( shell , &r->s_hd );
	while( RT_LIST_NOT_HEAD( s1 , &r->s_hd ) )
d2632 1
a2632 1
		next_s = RT_LIST_PNEXT( shell , &s1->l );
d2645 1
a2645 1
	nmg_tbl( &verts , TBL_FREE , (long *)NULL );
d2704 2
a2705 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in sort_fus_by_thickness\n" );
d2715 1
a2715 1
	struct nmg_ptbl list;
d2718 1
a2718 1
	nmg_tbl( &list , TBL_INIT , (long *)NULL );
d2720 1
a2720 1
	flags = (int *)rt_calloc( m->maxindex , sizeof( int ) , "Recalc_edge_g: flags" );
d2725 1
a2725 1
	for( i=0 ; i<NMG_TBL_END( &list ) ; i++ )
d2729 1
a2729 1
		eu = (struct edgeuse *)NMG_TBL_GET( &list , i );
d2741 1
a2741 1
	for( i=0 ; i<NMG_TBL_END( &list ) ; i++ )
d2745 1
a2745 1
		eu = (struct edgeuse *)NMG_TBL_GET( &list , i );
d2756 1
a2756 1
	rt_free( (char *)flags , "Recalc_edge_g: flags" );
d2758 1
a2758 1
	nmg_tbl( &list , TBL_FREE , (long *)NULL );
d2760 2
a2761 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in Recalc_edge_g\n" );
d2771 1
a2771 1
	flags = (int *)rt_calloc( m->maxindex , sizeof( int ) , "Recalc_face_g: flags " );
d2773 1
a2773 1
	for( RT_LIST_FOR( fu , faceuse , &new_s->fu_hd ) )
d2791 1
a2791 1
				rt_log( "Recalculating geometry for face x%x fg=x%x\n", f, fg );
d2796 1
a2796 1
				rt_log( "New geometry is ( %g %g %g %g )\n", V4ARGS( fu->f_p->g.plane_p->N ) );
d2801 1
a2801 1
	rt_free( (char *)flags , "Recalc_face_g: flags" );
d2803 2
a2804 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in Recalc_face_g\n" );
d2813 1
a2813 1
	struct nmg_ptbl verts;
d2818 1
a2818 1
	flags = (long *)rt_calloc( m->maxindex , sizeof( long ) , "Adjust_vertices: flags" );
d2821 1
a2821 1
		rt_log( "Adjust_vertices( s=x%x, thick = %g )\n", new_s, thick );
d2824 1
a2824 1
	for( RT_LIST_FOR( fu , faceuse , &new_s->fu_hd ) )
d2838 1
a2838 1
				rt_log( "Moving face_g x%x ( %f %f %f %f ) from face x%x" ,
d2842 1
a2842 1
				rt_log( "\tflip = %d\n" , fu->f_p->flip );
d2849 1
a2849 1
				rt_log( " to (%f %f %f %f)\n", V4ARGS( fu->f_p->g.plane_p->N ) );
d2853 1
a2853 1
	rt_free( (char *)flags , "Adjust_vertices: flags" );
d2859 1
a2859 1
	for( vert_no = 0 ; vert_no < NMG_TBL_END( &verts ) ; vert_no++ )
d2863 1
a2863 1
		new_v = (struct vertex *)NMG_TBL_GET( &verts , vert_no );
d2867 1
a2867 1
			rt_log( "\tMoving vertex x%x from ( %g %g %g ) ", new_v, V3ARGS( new_v->vg_p->coord ) );
d2871 1
a2871 1
			rt_log( "Adjust_vertices: Failed to calculate new vertex at v=x%x was ( %f %f %f )\n",
d2873 1
a2873 1
			rt_log( "\tgroup id %d, component id %d\n" , group_id , comp_id );
d2878 1
a2878 1
			rt_log( "to ( %g %g %g )\n", V3ARGS( new_v->vg_p->coord ) );
d2881 1
a2881 1
	nmg_tbl( &verts , TBL_FREE , (long *)NULL );
d2886 2
a2887 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in Adjust_vertices\n" );
d2925 1
a2925 1
	for( RT_LIST_FOR( vu1 , vertexuse , &vu->v_p->vu_hd ) )
d2948 2
a2949 2
	tmp_vu = RT_LIST_FIRST( vertexuse , &old_v->vu_hd );
	while( RT_LIST_NOT_HEAD( tmp_vu , &old_v->vu_hd ) )
d2953 1
a2953 1
		next_vu = RT_LIST_PNEXT( vertexuse , tmp_vu );
d2965 1
a2965 1
	struct nmg_ptbl faces;
d2970 1
a2970 1
	nmg_tbl( &faces , TBL_INIT , (long *)NULL );
d2972 1
a2972 1
	for( RT_LIST_FOR( fu , faceuse , &new_s->fu_hd ) )
d2979 1
a2979 1
		nmg_tbl( &faces , TBL_INS , (long *)fu );
d2981 1
a2981 1
	nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ), &tol );
d2983 1
a2983 1
	nmg_tbl( &faces , TBL_FREE , (long *)NULL );
d2985 2
a2986 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in Glue_shell_faces\n" );
d3005 1
a3005 1
	r = RT_LIST_FIRST( nmgregion, &m->r_hd );
d3008 1
a3008 1
	s = RT_LIST_LAST( shell, &r->s_hd );
d3020 1
a3020 1
	if( RT_LIST_IS_EMPTY( &new_s->fu_hd ) )
d3066 1
a3066 1
	for( RT_LIST_FOR( fu , faceuse , &new_s->fu_hd ) )
d3073 1
a3073 1
		for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d3077 1
a3077 1
			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d3080 1
a3080 1
			for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d3098 1
a3098 1
					adj_root = (struct adjacent_faces *)rt_malloc(
d3108 1
a3108 1
					adj->next = (struct adjacent_faces *)rt_malloc(
d3174 2
a3175 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in Get_shell\n" );
d3205 1
a3205 1
		lu = RT_LIST_FIRST( loopuse , &new_fu->lu_hd );
d3209 2
a3210 2
			rt_log( "Cannot calculate plane equation for new face: \n" );
			rt_log( "\t( %f %f %f ), ( %f %f %f ), ( %f %f %f )\n",
d3236 1
a3236 1
		lu = RT_LIST_FIRST( loopuse , &new_fu->lu_hd );
d3240 2
a3241 2
			rt_log( "Cannot calculate plane equation for new face: \n" );
			rt_log( "\t( %f %f %f ), ( %f %f %f ), ( %f %f %f )\n",
d3253 2
a3254 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in Build_connecting_face\n" );
d3339 1
a3339 1
		(void) rt_dist_pt3_lseg3( &dist, pca, verts[0]->vg_p->coord,
d3343 1
a3343 1
		(void) rt_dist_pt3_lseg3( &dist, pca, verts[0]->vg_p->coord,
d3377 1
a3377 1
			(void) rt_dist_pt3_lseg3( &dist, pca, verts[0]->vg_p->coord,
d3381 1
a3381 1
			(void) rt_dist_pt3_lseg3( &dist, pca, verts[0]->vg_p->coord,
d3420 2
a3421 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in Reunite_face\n" );
d3455 1
a3455 1
		rt_log( "Connect_at_adj_edges: Called with non dangling edge!!\n" );
d3468 1
a3468 1
	for( RT_LIST_FOR( vu, vertexuse, &v1b->vu_hd ) )
d3485 1
a3485 1
	for( RT_LIST_FOR( vu, vertexuse, &v1c->vu_hd ) )
d3517 1
a3517 1
	for( RT_LIST_FOR( vu, vertexuse, &v2b->vu_hd ) )
d3534 1
a3534 1
	for( RT_LIST_FOR( vu, vertexuse, &v2c->vu_hd ) )
d3554 1
a3554 1
		rt_log( "Connect_at_adj_edges: Could not find vertices for adjacent edges\n" );
d3561 1
a3561 1
		rt_log( "Connect_at_adj_edges: Could not find eu2 corresponding to eu1\n" );
d3597 1
a3597 1
		lu = RT_LIST_FIRST( loopuse , &fu->lu_hd );
d3601 2
a3602 2
			rt_log( "Cannot calculate plane equation for new face: \n" );
			rt_log( "\t( %f %f %f ), ( %f %f %f ), ( %f %f %f )\n",
d3628 1
a3628 1
		lu = RT_LIST_FIRST( loopuse , &fu->lu_hd );
d3632 2
a3633 2
			rt_log( "Cannot calculate plane equation for new face: \n" );
			rt_log( "\t( %f %f %f ), ( %f %f %f ), ( %f %f %f )\n",
d3709 1
a3709 1
		rt_log( "Extrude_faces:\n" );
d3713 1
a3713 1
		rt_log( "\tComponent has %d unique thicknesses\n", num_thicks );
d3715 1
a3715 1
	thicks = (fastf_t *)rt_calloc( num_thicks , sizeof( fastf_t ) , "Extrude_faces: thicks" );
d3739 2
a3740 2
	r = RT_LIST_FIRST( nmgregion, &m->r_hd );
	s = RT_LIST_FIRST( shell, &r->s_hd );
d3752 1
a3752 1
	for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
d3755 1
a3755 1
		for( RT_LIST_FOR( s, shell, &r->s_hd ) )
d3760 2
a3761 2
			if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
				rt_log( "ERROR: rt_mem_barriercheck failed in make_nmg_objects (after fix_normals)\n" );
d3773 1
a3773 1
	shells = (struct shell **)rt_calloc( num_thicks*shell_count*2 ,
d3777 1
a3777 1
	dup_shells = (struct shell **)rt_calloc( num_thicks*shell_count*2 ,
d3781 1
a3781 1
	source_shells = (struct shell **)rt_calloc( shell_count,
d3786 3
a3788 3
	r = RT_LIST_FIRST( nmgregion, &m->r_hd );
	source_shells[0] = RT_LIST_FIRST( shell, &r->s_hd );
	for( RT_LIST_FOR( s1, shell, &r->s_hd ) )
d3810 4
a3813 4
			rt_log( "Extrude_faces: ERROR: too many shells!!!\n" );
			rt_free( (char *)shells, "Extrude_faces: shells" );
			rt_free( (char *)dup_shells, "Extrude_faces: dup_shells" );
			rt_free( (char *)source_shells, "Extrude_faces: source_shells" );
d3842 1
a3842 1
					rt_log( "Shell thickness = %g, center position = %d, source shell = x%x:\n",
d3867 4
a3870 4
			rt_free( (char *)thicks , "Extrude_faces: thicks" );
			rt_free( (char *)shells , "Extrude_faces: shells" );
			rt_free( (char *)dup_shells , "Extrude_faces: dup_shells" );
			rt_free( (char *)source_shells, "Extrude_faces: source_shells" );
d3878 1
a3878 1
	dup_tbl = (long **)rt_calloc( m->maxindex , sizeof( long *) , "Extrude_faces: dup_tbl" );
d3914 6
a3919 6
				rt_free( (char *)thicks , "Extrude_faces: thicks" );
				rt_free( (char *)shells , "Extrude_faces: shells" );
				rt_free( (char *)dup_shells , "Extrude_faces: dup_shells" );
				rt_free( (char *)dup_tbl , "Extrude_faces: dup_tbl" );
				rt_free( (char *)trans_tbl , "Extrude_faces: trans_tbl" );
				rt_free( (char *)source_shells, "Extrude_faces: source_shells" );
d3926 7
a3932 7
				rt_log( "Extrude_faces: Failed to connect shells\n" );
				rt_free( (char *)thicks , "Extrude_faces: thicks" );
				rt_free( (char *)shells , "Extrude_faces: shells" );
				rt_free( (char *)dup_shells , "Extrude_faces: dup_shells" );
				rt_free( (char *)dup_tbl , "Extrude_faces: dup_tbl" );
				rt_free( (char *)trans_tbl , "Extrude_faces: trans_tbl" );
				rt_free( (char *)source_shells, "Extrude_faces: source_shells" );
d3935 1
a3935 1
			rt_free( (char *)trans_tbl , "Extrude_faces: trans_tbl" );
d3940 1
a3940 1
	for( RT_LIST_FOR( tmp_r, nmgregion, &m->r_hd ) )
d3944 2
a3945 2
		s = RT_LIST_FIRST( shell, &tmp_r->s_hd );
		while( RT_LIST_NOT_HEAD( &s->l, &tmp_r->s_hd ) )
d3947 2
a3948 2
			next_s = RT_LIST_PNEXT( shell, &s->l );
			if( RT_LIST_IS_EMPTY( &s->fu_hd ) )
d3962 1
a3962 1
	for( RT_LIST_FOR( tmp_r, nmgregion, &m->r_hd ) )
d3964 1
a3964 1
		for( RT_LIST_FOR( s , shell, &tmp_r->s_hd ) )
d3971 5
a3975 5
	rt_free( (char *)thicks , "Extrude_faces: thicks" );
	rt_free( (char *)shells , "Extrude_faces: shells" );
	rt_free( (char *)dup_shells , "Extrude_faces: dup_shells" );
	rt_free( (char *)dup_tbl , "Extrude_faces: dup_tbl" );
	rt_free( (char *)source_shells, "Extrude_faces: source_shells" );
d3979 2
a3980 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in Extrude_faces\n" );
d4004 1
a4004 1
	RT_LIST_INIT( &arb6_head.l );
d4025 1
a4025 1
			rt_log( "Make_arb6_obj: face has no OT_SAME use (fu=x%x)\n" , fu );
d4029 2
a4030 2
		lu = RT_LIST_FIRST( loopuse , &fu->lu_hd );
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d4032 1
a4032 1
			rt_log( "Make_arb6_obj: Failed (loop without edgeuses)\n" );
d4043 1
a4043 1
			eu = RT_LIST_FIRST( edgeuse , &lu->down_hd );
d4051 1
a4051 1
			eu = RT_LIST_PNEXT( edgeuse , eu );
d4059 1
a4059 1
			eu = RT_LIST_PNEXT( edgeuse , eu );
d4095 1
a4095 1
			rt_log( "Make_arb6_obj: Failed to add %s to member list\n" , arb6_name );
d4113 1
a4113 1
		rt_free( (char *)tmp , "make_nmg_objects: fus" );
d4122 1
a4122 1
	RT_LIST_INIT( &head.l );
d4126 1
a4126 1
		rt_log( "make_nmg_objects: mk_addmember failed\n" , name );
d4135 2
a4136 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in make_arb6_obj\n" );
d4155 1
a4155 1
	struct nmg_ptbl verts;
d4162 1
a4162 1
	nmg_tbl( &verts, TBL_INIT, (long *)NULL );
d4165 1
a4165 1
		rt_log( "Fix_normals( sh = x%x )\n",sh );
d4169 1
a4169 1
	fu = RT_LIST_FIRST( faceuse, &sh->fu_hd );
d4173 1
a4173 1
	for( i=0 ; i<NMG_TBL_END( &verts ) ; i++ )
d4177 1
a4177 1
		v = (struct vertex *)NMG_TBL_GET( &verts, i );
d4181 1
a4181 1
	VSCALE( centroid, centroid, (fastf_t)(NMG_TBL_END( &verts ) ) )
d4184 1
a4184 1
	mat_zero( matrix );
d4187 1
a4187 1
	one_over_vertex_count = 1.0/(double)(NMG_TBL_END( &verts ));
d4189 1
a4189 1
	for( i=0 ; i<NMG_TBL_END( &verts ) ; i++ )
d4194 1
a4194 1
		v = (struct vertex *)NMG_TBL_GET( &verts , i );
d4222 1
a4222 1
		mat_inv( inverse , matrix );
d4251 2
a4252 2
		v0 = (struct vertex *)NMG_TBL_GET( &verts , 0 );
		for( i=1 ; i<NMG_TBL_END( &verts ) ; i++ )
d4254 1
a4254 1
			v = (struct vertex *)NMG_TBL_GET( &verts , i );
d4294 1
a4294 1
			rt_log( "Fix_normals: Cannot calculate plane for fu x%x\n" , fu );
d4296 1
a4296 1
			rt_log( "%d verts\n" , NMG_TBL_END( &verts ) );
d4300 1
a4300 1
	nmg_tbl( &verts , TBL_FREE , (long *)NULL );
d4302 1
a4302 1
	for( RT_LIST_FOR( fu , faceuse , &sh->fu_hd ) )
d4311 1
a4311 1
		for( RT_LIST_FOR( fu1 , faceuse , &sh->fu_hd ) )
d4336 1
a4336 1
	fu = RT_LIST_FIRST( faceuse, &sh->fu_hd );
d4340 1
a4340 1
	flags = (long *)rt_calloc( m->maxindex , sizeof( long ) , "patch-g: flags" );
d4359 2
a4360 2
			lu = RT_LIST_FIRST( loopuse , &fu->lu_hd );
			eu = RT_LIST_FIRST( edgeuse , &lu->down_hd );
d4381 1
a4381 1
		for( RT_LIST_FOR( fu1 , faceuse , &sh->fu_hd ) )
d4391 1
a4391 1
						rt_log( "\t\tMissed some faces on the first try\n" );
d4450 1
a4450 1
	struct nmg_ptbl faces;
d4458 1
a4458 1
	if( !m ||  RT_LIST_IS_EMPTY( &s->fu_hd ) )
d4470 1
a4470 1
		rt_log( "***********component %s, group #%d, component #%d is empty, skipping\n",
d4491 1
a4491 1
	nmg_tbl( &faces , TBL_INIT , (long *)NULL );
d4493 1
a4493 1
	for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
d4495 1
a4495 1
		for( RT_LIST_FOR( s, shell, &r->s_hd ) )
d4499 2
a4500 2
			nmg_tbl( &faces, TBL_RST, (long *)NULL );
			for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
d4507 1
a4507 1
				nmg_tbl( &faces , TBL_INS , (long *)fu );
d4511 1
a4511 1
			nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ), &tol );
d4523 1
a4523 1
		for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
d4525 1
a4525 1
			for( RT_LIST_FOR( s, shell, &r->s_hd ) )
d4545 1
a4545 1
			rt_log( "\tExtrude faces\n" );
d4551 2
a4552 2
		if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
			rt_log( "ERROR: rt_mem_barriercheck failed in make_nmg_objects (before triangulation)\n" );
d4560 1
a4560 1
		for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
d4562 1
a4562 1
			for( RT_LIST_FOR( s, shell, &r->s_hd ) )
d4564 1
a4564 1
				for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )
d4572 3
a4574 3
					lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
					next_lu = RT_LIST_PNEXT( loopuse, &lu->l );
					while( RT_LIST_NOT_HEAD( &next_lu->l, &fu->lu_hd ) )
d4581 1
a4581 1
						next_lu = RT_LIST_PNEXT( loopuse, &lu->l );
d4585 1
a4585 1
							rt_log( "make_nmg_objects: found loop with orientation (%s) after triangulation\n",
d4605 2
a4606 2
		if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
			rt_log( "ERROR: rt_mem_barriercheck failed in make_nmg_objects (after triangulation)\n" );
d4609 1
a4609 1
			rt_log( "extrude faces\n" );
d4613 1
a4613 1
			nmg_tbl( &faces , TBL_FREE , (long *)NULL );
d4620 2
a4621 2
			rt_log( "Failed to Extrude group_id = %d, component_id = %d\n" , group_id , comp_id );
			nmg_tbl( &faces , TBL_FREE , (long *)NULL );
d4628 2
a4629 2
		if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
			rt_log( "ERROR: rt_mem_barriercheck failed in make_nmg_objects (after extrusion)\n" );
d4632 1
a4632 1
		for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
d4637 2
a4638 2
			s = RT_LIST_FIRST( shell, &r->s_hd );
			while( RT_LIST_NOT_HEAD( &s->l, &r->s_hd ) )
d4642 2
a4643 2
				next_shell = RT_LIST_PNEXT( shell, &s->l );
				nmg_tbl( &faces , TBL_RST , (long *)NULL );
d4645 1
a4645 1
				for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
d4652 1
a4652 1
					nmg_tbl( &faces , TBL_INS , (long *)fu );
d4654 1
a4654 1
				if( NMG_TBL_END( &faces ) )
d4656 1
a4656 1
					nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ), &tol );
d4668 1
a4668 1
						rt_log( "***********component %s, group #%d, component #%d is empty, skipping\n",
d4674 1
a4674 1
						nmg_tbl( &faces, TBL_FREE, (long *)NULL );
d4682 2
a4683 2
		if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
			rt_log( "ERROR: rt_mem_barriercheck failed in make_nmg_objects (after making table of faceuses)\n" );
d4686 1
a4686 1
	nmg_tbl( &faces , TBL_FREE , (long *)NULL );
d4688 2
a4689 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in make_nmg_objects (after TBL_FREE of faces)\n" );
d4694 2
a4695 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in make_nmg_objects (after rebound)\n" );
d4698 1
a4698 1
	for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
d4700 1
a4700 1
		for( RT_LIST_FOR( s, shell, &r->s_hd ) )
d4709 1
a4709 1
			rt_log( "Coplanar face merge\n" );
d4711 1
a4711 1
		for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
d4713 1
a4713 1
			for( RT_LIST_FOR( s, shell, &r->s_hd ) )
d4719 2
a4720 2
		if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
			rt_log( "ERROR: rt_mem_barriercheck failed in make_nmg_objects (after tmp_shell_coplanar_face_merge)\n" );
d4722 1
a4722 1
		for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
d4724 1
a4724 1
			for( RT_LIST_FOR( s, shell, &r->s_hd ) )
d4740 2
a4741 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in make_nmg_objects (after model_fuse)\n" );
d4745 2
a4746 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in make_nmg_objects (after make_nmg_name)\n" );
d4755 1
a4755 1
		RT_LIST_INIT( &tmp_head.l );
d4757 1
a4757 1
		for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
d4760 1
a4760 1
			for( RT_LIST_FOR( s, shell, &r->s_hd ) )
d4790 1
a4790 1
		for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
d4793 1
a4793 1
			for( RT_LIST_FOR( s, shell, &r->s_hd ) )
d4820 1
a4820 1
		for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
d4823 1
a4823 1
			for( RT_LIST_FOR( s, shell, &r->s_hd ) )
d4835 1
a4835 1
					rt_log( "Final shell is not closed\n" );
d4842 1
a4842 1
			rt_log( "model fuse\n" );
d4846 1
a4846 1
		for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
d4849 1
a4849 1
			for( RT_LIST_FOR( s, shell, &r->s_hd ) )
d4857 2
a4858 2
		if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
			rt_log( "ERROR: rt_mem_barriercheck failed in make_nmg_objects (before mk_nmg)\n" );
d4863 2
a4864 2
		if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
			rt_log( "ERROR: rt_mem_barriercheck failed in make_nmg_objects (after mk_nmg)\n" );
d4882 1
a4882 1
		rt_free( (char *)tmp , "make_nmg_objects: fus" );
d4893 1
a4893 1
		rt_free( (char *)tmp , "make_nmg_objects: adj" );
d4904 1
a4904 1
		rt_free( (char *)tmp, "make_nmg_objects: elem" );
d4914 1
a4914 1
	RT_LIST_INIT( &head.l );
d4918 1
a4918 1
		rt_log( "make_nmg_objects: mk_addmember failed\n" , name );
d4927 2
a4928 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in make_nmg_obj\n" );
d4953 1
a4953 1
	cline_ptr = (struct cline *)rt_malloc( sizeof( struct cline ) , "Add_to_clines: cline_ptr" );
d4970 2
a4971 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in Add_to_clines\n" );
d4985 1
a4985 1
		rt_log( "do_cline: %s\n" , line );
d4994 2
a4995 2
		rt_log( "Illegal grid point (%d) in CLINE, skipping\n", pt1 );
		rt_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
d5003 2
a5004 2
		rt_log( "Illegal grid point in CLINE (%d), skipping\n", pt2 );
		rt_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
d5010 2
a5011 2
		rt_log( "Ilegal grid points in CLINE ( %d and %d ), skipping\n", pt1 , pt2 );
		rt_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
d5035 3
a5037 3
		rt_log( "ERROR: CLINE thickness (%f) greater than radius (%f)\n", thick, radius );
		rt_log( "\tnot making inner cylinder\n" );
		rt_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
d5071 2
a5072 2
			rt_log( "Unexpected EOF while reading continuation card for CCONE1\n" );
			rt_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
d5096 2
a5097 2
		rt_log( "Unexpected EOF while reading continuation card for CCONE1\n" );
		rt_log( "\tgroup_id = %d, comp_id = %d, element_id = %d, c1 = %d\n",
d5107 2
a5108 2
		rt_log( "WARNING: CCONE1 continuation flags disagree, %d vs %d\n" , c1 , c2 );
		rt_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
d5123 2
a5124 2
		rt_log( "ERROR: CCONE1 has illegal radii, %f and %f\n" , r1/25.4 , r2/25.4 );
		rt_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
d5126 1
a5126 1
		rt_log( "\tCCONE1 solid ignored\n" );
d5134 2
a5135 2
			rt_log( "ERROR: Plate mode CCONE1 has illegal thickness (%f)\n" , thick/25.4 );
			rt_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
d5137 1
a5137 1
			rt_log( "\tCCONE1 solid ignored\n" );
d5143 2
a5144 2
			rt_log( "ERROR: Plate mode CCONE1 has too large thickness (%f)\n" , thick/25.4 );
			rt_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
d5146 1
a5146 1
			rt_log( "\tCCONE1 solid ignored\n" );
d5153 2
a5154 2
		rt_log( "ERROR: CCONE1 has illegal grid points ( %d and %d)\n" , pt1 , pt2 );
		rt_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
d5156 1
a5156 1
		rt_log( "\tCCONE1 solid ignored\n" );
d5171 1
a5171 1
	RT_LIST_INIT( &r_head.l );
d5246 2
a5247 2
			rt_log( "ERROR: CCONE1 height (%f) too small for thickness (%f)\n" , length/25.4 , thick/25.4 );
			rt_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
d5249 1
a5249 1
			rt_log( "\tCCONE1 inner solid ignored\n" );
d5288 2
a5289 2
			rt_log( "Unexpected EOF while reading continuation card for CCONE1\n" );
			rt_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
d5310 2
a5311 2
		rt_log( "Unexpected EOF while reading continuation card for CCONE2\n" );
		rt_log( "\tgroup_id = %d, comp_id = %d, element_id = %d, c1 = %d\n",
d5321 2
a5322 2
		rt_log( "WARNING: CCONE2 continuation flags disagree, %d vs %d\n" , c1 , c2 );
		rt_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
d5337 2
a5338 2
		rt_log( "ERROR: CCONE2 has same endpoints %d and %d\n", pt1, pt2 );
		rt_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
d5345 2
a5346 2
		rt_log( "ERROR: CCONE2 has illegal radii %f %f %f %f\n" , ro1, ro2, ri1, ri2 );
		rt_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
d5357 1
a5357 1
	RT_LIST_INIT( &r_head.l );
d5398 1
a5398 1
		hole_root = (struct holes *)rt_malloc( sizeof( struct holes ) , "Add_holes: hole_root" );
d5431 1
a5431 1
	hole_ptr->next = (struct holes *)rt_malloc( sizeof( struct holes ) , "Add_holes: hole_ptr->next" );
d5453 1
a5453 1
		rt_log( "do_hole_wall: %s\n" , line );
d5482 1
a5482 1
			list_ptr->next = (struct hole_list *)rt_malloc( sizeof( struct hole_list ) , "do_hole_wall: list_ptr" );
d5487 1
a5487 1
			list_ptr = (struct hole_list *)rt_malloc( sizeof( struct hole_list ) , "do_hole_wall: list_ptr" );
d5533 1
a5533 1
		rt_log( "make_fast_fu: ( %f %f %f )\n\t( %f %f %f )\n\t( %f %f %f )\n" ,
d5546 1
a5546 1
		s = RT_LIST_FIRST( shell , &r->s_hd );
d5550 1
a5550 1
		rt_log( "\tm = x%x\n" , m );
d5555 2
a5556 2
		rt_log( "make_fast_fu: nmg_cmface failed\n" );
		rt_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
d5561 1
a5561 1
		rt_log( "\tfu = x%x\n" , fu );
d5563 1
a5563 1
	lu = RT_LIST_FIRST( loopuse , &fu->lu_hd );
d5572 2
a5573 2
		rt_log( "make_fast_fu: ignoring degenerate face\n" );
		rt_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
d5584 2
a5585 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in make_fast_fu\n" );
d5600 1
a5600 1
	for( RT_LIST_FOR( tmp_r, nmgregion, &m->r_hd ) )
d5604 1
a5604 1
		for( RT_LIST_FOR( tmp_s, shell, &tmp_r->s_hd ) )
d5608 1
a5608 1
			for( RT_LIST_FOR( fu, faceuse, &tmp_s->fu_hd ) )
d5615 1
a5615 1
				for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
d5621 1
a5621 1
					if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d5624 1
a5624 1
					for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d5660 1
a5660 1
		rt_log( "do_tri: %s\n" , line );
d5682 2
a5683 2
		rt_log( "do_tri: ignoring degenerate CTRI element\n" );
		rt_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
d5690 3
a5692 3
		rt_log( "Duplicate face in element %d, component %d, group %d\n" , element_id , comp_id , group_id );
		rt_log( "\t grid points %d %d %d\n", pt1, pt2, pt3 );
		rt_log( "\tthis face ignored\n" );
d5702 2
a5703 2
			rt_log( "do_tri: illegal thickness (%f), skipping CTRI element\n" , thick );
			rt_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
d5715 2
a5716 2
			rt_log( "do_tri: illegal postion parameter (%d), must be one or two\n" , pos );
			rt_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
d5720 1
a5720 1
			rt_log( "\tplate mode: thickness = %f\n" , thick );
d5752 1
a5752 1
		rt_log( "do_quad: %s\n" , line );
d5778 2
a5779 2
			rt_log( "do_quad: illegal thickness (%f), skipping CQUAD element\n" , thick );
			rt_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
d5791 2
a5792 2
			rt_log( "do_quad: illegal postion parameter (%d), must be one or two\n" , pos );
			rt_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
d5820 3
a5822 3
		rt_log( "do_quad: ignoring degenerate triangular face in CQUAD element\n" );
		rt_log( "\t\t%d %d %d\n", pt1, pt2, pt3 );
		rt_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
d5827 3
a5829 3
		rt_log( "Duplicate face in element %d, component %d, group %d\n" , element_id , comp_id , group_id );
		rt_log( "\t grid points %d %d %d\n", pt1, pt2, pt3 );
		rt_log( "\tthis face ignored\n" );
d5852 3
a5854 3
		rt_log( "do_quad: ignoring degenerate triangular face in CQUAD element\n" );
		rt_log( "\t\t%d %d %d\n", pt1, pt3, pt4 );
		rt_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
d5859 3
a5861 3
		rt_log( "Duplicate face in element %d, component %d, group %d\n" , element_id , comp_id , group_id );
		rt_log( "\t grid points %d %d %d\n", pt1, pt3, pt4 );
		rt_log( "\tthis face ignored\n" );
d5917 1
a5917 1
		rt_log( "do_section: %s\n" , line );
d5934 1
a5934 1
			    if( (RT_SETJUMP) || make_nmg_objects() )
d5940 1
a5940 1
				rt_log( "***********component %s, group #%d, component #%d failed\n",
d5947 2
a5948 2
					if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
						rt_log( "ERROR: rt_mem_barriercheck failed in Do_section after nmg_km()\n" );
d5955 2
a5956 2
				if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
					rt_log( "ERROR: rt_mem_barriercheck failed in Do_section before freeing fus list\n" );
d5966 1
a5966 1
					rt_free( (char *)tmp , "Do_section: fus" );
d5970 2
a5971 2
				if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
					rt_log( "ERROR: rt_mem_barriercheck failed in Do_section before freeing adj_face list\n" );
d5980 1
a5980 1
					rt_free( (char *)tmp , "Do_section: adj" );
d5991 1
a5991 1
					rt_free( (char *)tmp, "Do_section: elem" );
d5997 2
a5998 2
				if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
					rt_log( "ERROR: rt_mem_barriercheck failed in Do_section after freeing adj_face list\n" );
d6010 1
a6010 1
							rt_log( "Cannot seek in input file, not retrying group %d, comnponent %d\n",
d6015 1
a6015 1
							rt_log( "Retrying group %d, component %d\n",
d6024 1
a6024 1
			    RT_UNSETJUMP;
d6076 1
a6076 1
			rt_log( "Making component %s, group #%d, component #%d\n",
d6081 1
a6081 1
			rt_log( "Illegal component id number %d, changed to 999\n" , comp_id );
d6089 1
a6089 1
			rt_log( "Illegal mode (%d) for group %d component %d, using volume mode\n",
d6112 1
a6112 1
	struct nmg_ptbl faces;
d6114 1
a6114 1
	nmg_tbl( &faces , TBL_INIT , (long *)NULL );
d6118 1
a6118 1
	s1 = RT_LIST_FIRST( shell , &r1->s_hd );
d6127 1
a6127 1
	nmg_tbl( &faces , TBL_INS , (long *)fu );
d6135 1
a6135 1
	nmg_tbl( &faces , TBL_INS , (long *)fu );
d6143 1
a6143 1
	nmg_tbl( &faces , TBL_INS , (long *)fu );
d6151 1
a6151 1
	nmg_tbl( &faces , TBL_INS , (long *)fu );
d6159 1
a6159 1
	nmg_tbl( &faces , TBL_INS , (long *)fu );
d6167 1
a6167 1
	nmg_tbl( &faces , TBL_INS , (long *)fu );
d6173 1
a6173 1
	while( i < NMG_TBL_END( &faces ) )
d6179 1
a6179 1
		fu = (struct faceuse *)NMG_TBL_GET( &faces , i );
d6182 1
a6182 1
		lu = RT_LIST_FIRST( loopuse , &fu->lu_hd );
d6190 1
a6190 1
			nmg_tbl( &faces , TBL_RM , (long *)fu );
d6199 2
a6200 2
	nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ), &tol );
	nmg_tbl( &faces , TBL_FREE , (long *)NULL );
d6233 2
a6234 2
			rt_log( "Unexpected EOF while reading continuation card for CHEX1\n" );
			rt_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
d6252 2
a6253 2
		rt_log( "Unexpected EOF while reading continuation card for CHEX1\n" );
		rt_log( "\tgroup_id = %d, comp_id = %d, element_id = %d, c1 = %d\n",
d6263 2
a6264 2
		rt_log( "Continuation card numbers do not match for CHEX1 element (%d vs %d)\n", cont1 , cont2 );
		rt_log( "\tskipping CHEX1 element: group_id = %d, comp_id = %d, element_id = %d\n",
d6281 1
a6281 1
	RT_LIST_INIT( &head.l );
d6294 2
a6295 2
			rt_log( "do_hex1: illegal thickness (%f), skipping CHEX1 element\n" , thick );
			rt_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
d6307 2
a6308 2
			rt_log( "do_hex1: illegal postion parameter (%d), must be 1 or 2, skipping CHEX1 element\n" , pos );
			rt_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
d6317 3
a6319 3
			rt_log( "do_hex1: Could not find inside for CHEX1 element\n" , pos );
			rt_log( "\tLeaving CHEX1 element solid\n" );
			rt_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
d6337 2
a6338 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in Do_hex1\n" );
d6359 2
a6360 2
			rt_log( "Unexpected EOF while reading continuation card for CHEX2\n" );
			rt_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
d6378 2
a6379 2
		rt_log( "Unexpected EOF while reading continuation card for CHEX2\n" );
		rt_log( "\tgroup_id = %d, comp_id = %d, element_id = %d, c1 = %d\n",
d6389 2
a6390 2
		rt_log( "Continuation card numbers do not match for CHEX2 element (%d vs %d)\n", cont1 , cont2 );
		rt_log( "\tskipping CHEX2 element: group_id = %d, comp_id = %d, element_id = %d\n",
d6407 1
a6407 1
	RT_LIST_INIT( &head.l );
d6417 2
a6418 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in Do_hex2\n" );
d6427 2
a6428 2
		rt_log( "\n\nProcess_input( pass = %d ), try = %d\n" , pass_number , try_count );
/*	rt_prmem( "At start of Process_input:" );	*/
d6432 1
a6432 1
		rt_log( "Process_input: illegal pass number %d\n" , pass_number );
d6480 1
a6480 1
			rt_log( "ERROR: skipping unrecognized data type\n%s\n" , line );
d6493 1
a6493 1
		rt_log( "At pass %d:\n" , pass );
d6661 1
a6661 1
        tol.magic = RT_TOL_MAGIC;
d6708 1
a6708 1
				rt_log( "tolerance distance set to %f\n" , tol.dist );
d6713 1
a6713 1
				rt_log( "tolerance perpendicular set to %f\n" , tol.perp );
d6715 1
a6715 1
				rt_log( "tolerance parallel set to %f\n" , tol.para );
d6731 1
a6731 1
		rt_log( "Cannot open FASTGEN4 file (%s)\n" , argv[optind] );
d6738 1
a6738 1
		rt_log( "Cannot open file for output (%s)\n" , argv[optind+1] );
d6755 2
a6756 2
		rt_printb( "librt rt_g.debug", rt_g.debug, DEBUG_FORMAT );
		rt_log("\n");
d6760 2
a6761 2
		rt_printb( "librt rt_g.NMG_debug", rt_g.NMG_debug, NMG_DEBUG_FORMAT );
		rt_log("\n");
d6765 1
a6765 1
	grid_pts = (struct fast_verts *)rt_malloc( grid_size * sizeof( struct fast_verts ) , "fast4-g: grid_pts" );
d6781 1
a6781 1
	dup_fu = (struct faceuse **)rt_calloc( DUP_BLOCK, sizeof( struct faceuse *), "dup_fu" );
d6793 1
a6793 1
	nmg_tbl( &stack , TBL_INIT , (long *)NULL );
d6796 1
a6796 1
		RT_LIST_INIT( &group_head[i].l );
d6818 3
a6820 3
	rt_log( "%d components converted out of %d attempted\n" , conv_count , comp_count );
	rt_log( "\t%d rejections or failures converted on second try (as a group of ARB6 solids)\n", second_chance );
	rt_log( "\tFor a total of %d components converted\n" , conv_count+second_chance );
@


11.21
log
@Fixed a bug in do_ccone2()
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.20 1999/05/26 19:20:00 jra Exp $";
a6354 3
	if( !nmgs )
		nmgs = element_id;

d6411 3
@


11.20
log
@Corrected part of the post-processing
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.19 1999/05/25 20:23:00 jra Exp $";
a5356 6
	if( ri1 < SQRT_SMALL_FASTF )
		ri1 = SQRT_SMALL_FASTF;

	if( ri2 < SQRT_SMALL_FASTF )
		ri2 = SQRT_SMALL_FASTF;

d5367 7
a5373 2
	make_solid_name( name , CCONE2 , element_id , comp_id , group_id , 1 );
	mk_trc_h( fdout , name , grid_pts[pt1].pt , height , ri1 , ri2 );
d5375 6
a5380 2
	if( mk_addmember( name , &r_head , WMOP_SUBTRACT ) == (struct wmember *)NULL )
		rt_bomb( "mk_addmember failed!\n" );
@


11.19
log
@Added -o -p and -c options
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.18 1999/05/25 14:18:43 jra Exp $";
d6555 3
a6557 2
		bu_log( "%s is not a combination!!!!\n", dp2->d_namep );
		bu_bomb( "Expecting a combination!!!!\n" );
a6594 1
	/* make a list of all the regions to be modified */
@


11.18
log
@Added -p   option
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.17 1999/05/24 17:33:07 jra Exp $";
d55 2
d60 1
d89 5
a93 1
static int	use_arb6=0;		/* flag indicating tha all plate-mode should be converted as ARB6's */
d112 1
a112 1
static char	*usage="Usage:\n\tfast4-g [-dnwp] [-a min_angle] [-x RT_DEBUG_FLAG] [-X NMG_DEBUG_FLAG] [-D distance] [-P cosine] fastgen4_bulk_data_file output.g\n\
d119 2
d274 10
d5729 2
d5840 3
d5844 1
d5872 3
d5876 1
d5887 18
d5924 1
a5924 1
		if( region_id )
d6053 19
a6081 2
		region_id = group_id * 1000 + comp_id;

d6497 151
d6654 2
d6666 1
a6666 1
	while( (c=getopt( argc , argv , "pa:dnwx:b:X:D:P:" ) ) != EOF )
d6670 7
d6739 10
d6810 4
@


11.17
log
@Now uses original facets for second try ARB6 solids
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.16 1999/05/17 20:36:40 jra Exp $";
d86 1
d105 1
a105 1
static char	*usage="Usage:\n\tfast4-g [-dnw] [-a min_angle] [-x RT_DEBUG_FLAG] [-X NMG_DEBUG_FLAG] [-D distance] [-P cosine] fastgen4_bulk_data_file output.g\n\
d111 1
d4513 1
a4513 1
	else if( mode == PLATE_MODE && try_count )
d6449 1
a6449 1
	while( (c=getopt( argc , argv , "a:dnwx:b:X:D:P:" ) ) != EOF )
d6453 3
@


11.16
log
@Repaired some problems created be a previous change
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.15 1999/05/12 20:35:28 jra Exp $";
d240 1
d1014 1
a1014 1
Add_fu( fu, thick, pos, element_no )
d1018 1
d1041 3
d4017 20
a4036 7
		eu = RT_LIST_FIRST( edgeuse , &lu->down_hd );
		NMG_CK_EDGEUSE( eu );
		v = eu->vu_p->v_p;
		NMG_CK_VERTEX( v );
		vg = v->vg_p;
		NMG_CK_VERTEX_G( vg );
		VMOVE( pts[0] , vg->coord );
d4038 26
a4063 7
		eu = RT_LIST_PNEXT( edgeuse , eu );
		NMG_CK_EDGEUSE( eu );
		v = eu->vu_p->v_p;
		NMG_CK_VERTEX( v );
		vg = v->vg_p;
		NMG_CK_VERTEX_G( vg );
		VMOVE( pts[1] , vg->coord );
d4065 2
a4066 13
		eu = RT_LIST_PNEXT( edgeuse , eu );
		NMG_CK_EDGEUSE( eu );
		v = eu->vu_p->v_p;
		NMG_CK_VERTEX( v );
		vg = v->vg_p;
		NMG_CK_VERTEX_G( vg );
		VMOVE( pts[4] , vg->coord );
		VMOVE( pts[5] , pts[4] );

		VJOIN1( pts[3] , pts[0] , fus->thick , normal );
		VJOIN1( pts[2] , pts[1] , fus->thick , normal );
		VJOIN1( pts[6] , pts[4] , fus->thick , normal );
		VMOVE( pts[7] , pts[6] );
d4578 1
a4578 1
						Add_fu( new_fu, fus->thick, fus->pos, fus->element );
d5558 1
a5558 1
		Add_fu( fu, thick, pos, element_id );
@


11.15
log
@Added some debugging and modified make_nmg_objects() to build regions with no intervening groups if possible.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.14 1998/10/19 20:08:33 jra Exp $";
d4659 4
a4662 2
	if( debug )
		rt_log( "Coplanar face merge\n" );
d4664 1
a4664 3
	for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
	{
		for( RT_LIST_FOR( s, shell, &r->s_hd ) )
d4666 4
a4669 1
			tmp_shell_coplanar_face_merge( s , &tol , 0 );
a4670 1
	}
d4672 2
a4673 2
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in make_nmg_objects (after tmp_shell_coplanar_face_merge)\n" );
d4675 1
a4675 3
	for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
	{
		for( RT_LIST_FOR( s, shell, &r->s_hd ) )
d4677 4
a4680 1
			Recalc_face_g( s );
a4742 2
		/* count number of shells in this component */
		count = 0;
d4748 1
a4748 3
				count++;
			}
		}
d4750 1
a4750 8
		if( count > 1 )
		{
			for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
			{
				NMG_CK_REGION( r );
				for( RT_LIST_FOR( s, shell, &r->s_hd ) )
				{
					int tmp_id;
d4752 3
a4754 1
					NMG_CK_SHELL( s );
d4756 2
a4757 6
					count = Unbreak_shell_edges( s );
					if( debug )
						bu_log( "%d edges mended by Unbreak_shell_edges()\n", count );

					if( debug )
						nmg_pr_s_briefly( s, "" );
d4759 6
a4764 21
					sol_count++;
					tmp_id = group_id * 1000 + comp_id;
					sprintf( tmp_name, "s.%d.%d", tmp_id, sol_count );
					make_unique_name( tmp_name );
					write_shell_as_polysolid( fdout , tmp_name , s );
					mk_addmember( tmp_name, &tmp_head, WMOP_UNION );
				}
			}
			mk_lcomb( fdout, name, &tmp_head, 0, (char *)NULL, (char *)NULL, (unsigned char *)NULL, 0 );
		}
		else
		{
			r = RT_LIST_FIRST( nmgregion,  &m->r_hd );
			s = RT_LIST_FIRST( shell,  &r->s_hd );
			count = 0;
			for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )
			{
				NMG_CK_FACEUSE( fu );
				if( fu->orientation != OT_SAME )
					continue;
				count++;
a4765 1
			write_shell_as_polysolid( fdout , name , s );
d4767 1
@


11.14
log
@Fixed a memory leak.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.13 1998/10/16 00:36:53 jra Exp $";
a261 1

d2812 1
a2812 1
				rt_log( "Moving face_g x%x ( %f %f %f %f ) from face x%x\n" ,
d2822 2
d4450 2
d4462 2
d4542 2
a4543 1

d4740 2
d4747 12
a4758 1
				int tmp_id;
d4760 1
a4760 1
				NMG_CK_SHELL( s );
d4762 3
a4764 3
				count = Unbreak_shell_edges( s );
				if( debug )
					bu_log( "%d edges mended by Unbreak_shell_edges()\n", count );
d4766 2
a4767 2
				if( debug )
					nmg_pr_s_briefly( s, "" );
d4769 21
a4789 6
				sol_count++;
				tmp_id = group_id * 1000 + comp_id;
				sprintf( tmp_name, "s.%d.%d", tmp_id, sol_count );
				make_unique_name( tmp_name );
				write_shell_as_polysolid( fdout , tmp_name , s );
				mk_addmember( tmp_name, &tmp_head, WMOP_UNION );
d4791 1
a4792 1
		mk_lcomb( fdout, name, &tmp_head, 0, (char *)NULL, (char *)NULL, (unsigned char *)NULL, 0 );
d6446 1
a6446 1
	while( (c=getopt( argc , argv , "a:dnwx:X:D:P:" ) ) != EOF )
d6470 3
d6489 3
@


11.13
log
@Added check for correct number of edge uses.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.12 1998/07/27 12:34:24 jra Exp $";
d4394 2
@


11.12
log
@rt_realloc() needed a (char *) arg.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /c/CVS/brlcad/conv/fast4-g.c,v 11.11 1997/07/11 15:00:29 jra Exp $";
d4349 39
d4389 5
d4463 3
@


11.11
log
@Numerous improvements funded by JTCG.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/fast4-g.c,v 11.10 1997/06/04 19:11:35 jra Exp jra $";
d1006 1
a1006 1
		dup_fu = (struct faceuse **)bu_realloc( dup_fu, dup_size, "realloc dup_fu" );
@


11.10
log
@removed -p option (polysolids are now the default)
improved handling of multiple surfaces by decomposing shell
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/fast4-g.c,v 11.9 1997/05/28 18:06:20 jra Exp jra $";
d47 4
d76 1
d94 5
d104 3
a106 1
static char	*usage="Usage:\n\tfast4-g [-dw] [-x RT_DEBUG_FLAG] [-X NMG_DEBUG_FLAG] [-D distance] [-P cosine] fastgen4_bulk_data_file output.g\n\
d108 1
d122 1
d239 1
d250 13
d284 729
d1014 1
a1014 1
Add_fu( fu, thick, pos )
d1018 1
d1024 1
a1024 1
		fus_root = (struct fast_fus *)rt_malloc( sizeof( struct fast_fus ) , "Do_tri: fus_root" );
d1032 1
a1032 1
		fus->next = (struct fast_fus *)rt_malloc( sizeof( struct fast_fus ) , "Do_tri: fus" );
d1040 1
d2708 4
d2713 1
d3722 20
a3741 1
		nmg_stash_model_to_file( "shell.g", m, "shell" );
d3759 1
a3911 4
#if 0
	/* And kill the original shell */
	if( RT_LIST_NON_EMPTY( &s->fu_hd ) )
		rt_log( "Original shell should be empty, but it is not!!!\n" );
a3912 3
	nmg_ks( s );
	s = (struct shell *)NULL;
#else
d3927 1
a3927 1
#endif
a3943 43
#if 0
	s = (struct shell *)NULL;

	/* Now reunite adjacent faces that were seperated in "Get_shell" */
	Reunite_faces( dup_tbl );

	/* Merge all shells back */
	s1 = (struct shell *)NULL;
	s2 = (struct shell *)NULL;
	for( thick_no=0 ; thick_no<num_thicks ; thick_no++ )
	{
		for( center=1 ; center<3 ; center++ )
		{
			if( shells[ thick_no*2 + center - 1 ] == (struct shell *)NULL )
				continue;

			if( s1 == (struct shell *)NULL )
			{
				s1 = shells[ thick_no*2 + center - 1 ];
				s2 = dup_shells[ thick_no*2 + center - 1 ];
			}
			else
			{
				nmg_js( s1 , shells[ thick_no*2 + center - 1 ] , &tol );
				nmg_js( s2 , dup_shells[ thick_no*2 + center - 1 ] , &tol );
			}
		}
	}
	Glue_shell_faces( s1 );
	Glue_shell_faces( s2 );

	if( debug )
	{
		nmg_rebound( m, &tol );
		nmg_stash_model_to_file( "error1.g", m, "unconnected shells" );
	}

	/* Now combine the final two */
	if( debug )
		rt_log( "Close shell\n" );
	if( nmg_open_shells_connect( s1 , s2 , dup_tbl , &tol ) )
		rt_bomb( "Extrude_faces: Could not connect plate mode shells.\n" );
#endif
a3951 5
#if 0
	s = s1;
	Glue_shell_faces( s );
#endif

d3973 3
d4041 1
a4041 1
		sprintf( arb6_name , "arb%d.%d.%d" , group_id , comp_id , arb_count );
a4091 265
Check_face_g( s )
struct shell *s;
{
	struct faceuse *fu;
	struct face *f;
	struct face_g_plane *fg;

	for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
	{
		NMG_CK_FACEUSE( fu );
		f = fu->f_p;
		NMG_CK_FACE( f );
		fg = f->g.plane_p;
		NMG_CK_FACE_G_PLANE( fg );
	}
}

int
Check_radials( s_p, max_use_count )
struct shell *s_p;
int max_use_count;
{
	struct nmg_ptbl edgeuses;
	struct nmg_ptbl uses;
	struct edgeuse *eu1;
	double *angles=NULL;
	int i;
	int radials_ok=1;
	int *flags;
	int use_count;

	NMG_CK_SHELL( s_p );

	if( debug )
		rt_log( "Check_radials( s_p=x%x, max_use_count=%d )\n", s_p, max_use_count );

	nmg_edgeuse_tabulate( &edgeuses , &s_p->l.magic );
	flags = (int *)rt_calloc( NMG_TBL_END( &edgeuses ) , sizeof( int ) , "Check_radials: flags" );

	nmg_tbl( &uses , TBL_INIT , (long *)NULL );

	for( i=0 ; i<NMG_TBL_END( &edgeuses ) ; i++ )
	{
		int j;
		struct faceuse *fu;

		if( flags[i] )
			continue;

		eu1 = (struct edgeuse *)NMG_TBL_GET( &edgeuses , i );
		NMG_CK_EDGEUSE( eu1 );

		fu = nmg_find_fu_of_eu( eu1 );
		NMG_CK_FACEUSE( fu );
		if( fu->orientation != OT_SAME )
		{
			flags[i] = 1;
			continue;
		}

		use_count = 1;
		nmg_tbl( &uses , TBL_RST , (long *)NULL );
		nmg_tbl( &uses , TBL_INS , (long *)eu1 );

		flags[i] = 1;

		for( j=i+1 ; j<NMG_TBL_END( &edgeuses ) ; j++ )
		{
			struct edgeuse *eu2;

			if( flags[j] )
				continue;

			eu2 = (struct edgeuse *)NMG_TBL_GET( &edgeuses , j );
			NMG_CK_EDGEUSE( eu2 );

			fu = nmg_find_fu_of_eu( eu2 );
			NMG_CK_FACEUSE( fu );
			if( fu->orientation != OT_SAME )
			{
				flags[j] = 1;
				continue;
			}

			if( eu2->e_p == eu1->e_p )
				flags[j] = 1;
			else if( eu1->vu_p->v_p == eu2->vu_p->v_p &&
			    eu1->eumate_p->vu_p->v_p == eu2->eumate_p->vu_p->v_p )
				flags[j] = 1;
			else if( eu1->vu_p->v_p == eu2->eumate_p->vu_p->v_p &&
			    eu1->eumate_p->vu_p->v_p == eu2->vu_p->v_p )
				flags[j] = 1;


			if( flags[j] )
			{
				use_count++;
				nmg_tbl( &uses , TBL_INS , (long *)eu2 );
			}
		}

		if( max_use_count )
		{

			if( use_count > max_use_count )
			{
				if( debug )
					rt_log( "\tUse_count=%d > max_use_count=%d\n",
							use_count, max_use_count );
				radials_ok = 0;
				break;
			}
		}
		

		if( !max_use_count && use_count%2 )
		{
			if( debug )
				rt_log( "use_count (%d), not even )\n", use_count );
			radials_ok = 0;
			break;
		}

		if( !max_use_count && use_count != 2 )
		{
			struct edgeuse *eu,*prev_eu;
			vect_t xvec,yvec,zvec;
			vect_t eu_dir,prev_eu_dir;
			double ang;
			int done=0;
			int use_no=0;

			radials_ok = 0;
			angles = (double *)rt_calloc( use_count , sizeof( double ) , "Check_radials: angles" );

			/* Check if radial orientation is O.K. */
			if( debug )
				rt_log( "\tChecking radial orientation\n" );

			eu = (struct edgeuse *)NMG_TBL_GET( &uses , 0 );
			NMG_CK_EDGEUSE( eu );
			fu = nmg_find_fu_of_eu( eu );
			NMG_CK_FACEUSE( fu );
			if( fu->orientation != OT_SAME )
				rt_bomb( "Check_radials: fu not OT_SAME\n" );
			
			nmg_eu_2vecs_perp( xvec, yvec, zvec, eu, &tol );

			for( use_no=0 ; use_no<use_count ; use_no++ )
			{
				vect_t norm_jra;

				eu = (struct edgeuse *)NMG_TBL_GET( &uses , use_no );
				NMG_CK_EDGEUSE( eu );
				fu = nmg_find_fu_of_eu( eu );
				NMG_CK_FACEUSE( fu );
				if( fu->orientation != OT_SAME )
					rt_bomb( "Check_radials: fu not OT_SAME\n" );

				NMG_GET_FU_NORMAL( norm_jra, fu );			
				angles[use_no] = nmg_measure_fu_angle( eu, xvec, yvec, zvec );
				if( debug )
				{
					rt_log( "\tangles[%d] = %g (%g)\n", use_no, angles[use_no], angles[use_no]*180/rt_pi );
					rt_log( "\t\tfu normal = ( %g %g %g )\n", V3ARGS( norm_jra ) );
				}
			}

			ang = (-MAX_FASTF);
			prev_eu = (struct edgeuse *)NULL;

			while( !done )
			{
				double tmp_ang;
				int tmp_use;

				tmp_use = (-1);
				tmp_ang = MAX_FASTF;
				for( use_no=0 ; use_no<use_count ; use_no++ )
				{
					if( angles[use_no] > ang && angles[use_no] < tmp_ang )
					{
						tmp_use = use_no;
						tmp_ang = angles[use_no];
					}
				}

				if( tmp_use == (-1) )
				{
					int first_use;
					double first_ang=MAX_FASTF;

					/* Find eu with smallest angle */
					for( use_no=0 ; use_no<use_count ; use_no++ )
					{
						if( angles[use_no] < first_ang )
						{
							first_use = use_no;
							first_ang = angles[use_no];
						}
					}

					/* one last check between last eu and first */
					eu = (struct edgeuse *)NMG_TBL_GET( &uses , first_use );
					VSUB2( eu_dir , eu->vu_p->v_p->vg_p->coord , eu->eumate_p->vu_p->v_p->vg_p->coord );
					if( VDOT( eu_dir, prev_eu_dir ) > 0.0 )
						radials_ok = 0;
					else
						radials_ok = 1;

					done = 1;
				}

				if( !done )
				{
					use_no = tmp_use;

					if( !prev_eu )
					{
						prev_eu = (struct edgeuse *)NMG_TBL_GET( &uses , use_no );
						ang = angles[use_no];
						VSUB2( prev_eu_dir , prev_eu->vu_p->v_p->vg_p->coord , prev_eu->eumate_p->vu_p->v_p->vg_p->coord );
					}
					else
					{
						eu = (struct edgeuse *)NMG_TBL_GET( &uses , use_no );
						VSUB2( eu_dir , eu->vu_p->v_p->vg_p->coord , eu->eumate_p->vu_p->v_p->vg_p->coord );
						if( VDOT( eu_dir, prev_eu_dir ) > 0.0 )
						{
							radials_ok = 0;
							goto out;
						}

						ang = angles[use_no];
						prev_eu = eu;
						VMOVE( prev_eu_dir , eu_dir );
					}
				}
			}
			rt_free( (char *)angles , "Check_radials: angles" );
			angles = (double *)NULL;
		}
	}

out:
	if( angles )
		rt_free( (char *)angles , "Check_radials: angles" );
	
	nmg_tbl( &edgeuses , TBL_FREE , (long *)NULL );
	nmg_tbl( &uses , TBL_FREE , (long *)NULL );
	rt_free( (char *)flags , "Check_radials: flags" );

	if( !radials_ok )
	{
		rt_log( "Check_radials: bad radials at edge from ( %g %g %g ) to ( %g %g %g )\n",
			V3ARGS( eu1->vu_p->v_p->vg_p->coord ), V3ARGS( eu1->eumate_p->vu_p->v_p->vg_p->coord ) );
		rt_log( "\tUse count = %d\n" , use_count );
		if( debug )
			nmg_stash_model_to_file( "bad_radials.g", m, "bad radials" );
	}

	return( !radials_ok );
}

void
d4359 1
d4419 3
d4429 1
d4497 1
a4497 1
						Add_fu( new_fu, fus->thick, fus->pos );
d4507 1
a4507 1
			rt_log( "Fix normals\n" );
d4509 1
a4509 1
		for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
d4511 3
a4513 9
			NMG_CK_REGION( r )
			for( RT_LIST_FOR( s, shell, &r->s_hd ) )
			{
				NMG_CK_SHELL( s );
				Fix_normals( s );

				if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
					rt_log( "ERROR: rt_mem_barriercheck failed in make_nmg_objects (after fix_normals)\n" );
			}
a4515 3
		if( debug )
			rt_log( "extrude faces\n" );

a4525 3
		if(debug)
			nmg_stash_model_to_file( "extruded.g" , m, "extruded" );

d4648 1
d4658 1
d4667 4
d4672 2
a4674 5
				sol_count++;
				sprintf( tmp_name, "s.%d", sol_count );
				make_unique_name( tmp_name );
				write_shell_as_polysolid( fdout , tmp_name , s );
				mk_addmember( tmp_name, &tmp_head, WMOP_UNION );
d4677 8
a4684 6
		mk_lcomb( fdout, name, &tmp_head, 0, (char *)NULL, (char *)NULL, (unsigned char *)NULL, 0 );
	}
	else
	{
#if 0
		/* Check radial orientation around all edges */
d4690 2
d4694 13
a4706 5
				if( Check_radials( s, 0 ) )
				{
					rt_log( "Shell has bad radial edge orientation\n" );
					return( 1 );
				}
d4709 4
a4712 1
#endif
d4792 13
d5474 1
a5474 1
		Add_fu( fu, thick, pos );
d5530 2
d5533 1
d5549 1
d5615 9
d5625 1
d5635 2
d5687 21
d5713 1
d5720 1
d5723 12
a5734 1
		make_fast_fu( pt1 , pt2 , pt3 , element_id , thick , pos );
d5741 1
d5748 1
d5751 19
a5769 1
		make_fast_fu( pt1 , pt3 , pt4 , element_id , thick , pos );
d5795 1
a5795 2
			rt_log( "Making component %s, group #%d, component #%d\n",
					name_name, group_id , comp_id );
d5802 1
d5848 13
d5920 4
d6361 3
a6363 1
	while( (c=getopt( argc , argv , "dwx:X:D:P:" ) ) != EOF )
d6367 3
d6373 3
d6446 6
d6483 1
a6483 1
	rt_log( "\t%d failures converted on second try (as a group of ARB6 solids)\n", second_chance );
@


11.9
log
@Added rt_bomb() protection.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/fast4-g.c,v 11.8 1997/03/05 20:00:14 jra Exp jra $";
d71 1
a71 1
static int	polysolids=0;		/* Flag: >0 -> Build polysolids, not NMG's */
d94 1
a94 1
static char	*usage="Usage:\n\tfast4-g [-dwp] [-x RT_DEBUG_FLAG] [-X NMG_DEBUG_FLAG] [-D distance] [-P cosine] fastgen4_bulk_data_file output.g\n\
a96 1
	p - make polysolids rather than NMG solids\n\
d108 1
d235 49
a2094 3
	/* and recalculate edge geometry */
	Recalc_edge_g( new_s );

d2163 1
a2163 1
		if( nmg_find_s_of_vu( tmp_vu ) != new_s )
d2199 1
a2199 1
Get_shell( thick , center )
d2202 1
a2203 1
	struct fast_fus *fus;
d2206 5
d2212 2
d2223 2
a2224 2
		if( fus->thick == thick && fus->pos == center )
			nmg_mv_fu_between_shells( new_s , s , fus->fu );
d2233 34
d2268 8
a2275 1
	else
d2277 4
a2280 1
		nmg_kvu( new_s->vu_p );
d2282 1
a2282 2
		/* disconnect faceuses from those not in this shell */
		for( RT_LIST_FOR( fu , faceuse , &new_s->fu_hd ) )
d2284 1
a2284 1
			struct loopuse *lu;
d2286 1
a2286 1
			if( fu->orientation != OT_SAME )
d2289 1
a2289 1
			for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d2291 5
a2295 1
				struct edgeuse *eu;
d2297 4
a2300 2
				if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
					continue;
d2302 11
a2312 1
				for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d2314 2
a2315 29
					struct edgeuse *eu_radial;
					struct vertex *v1,*v2;
					struct edgeuse *new_eu;
					struct adjacent_faces *adj;
					struct faceuse *fu2;

					/* Check if this edge has a use outside this shell */
					if( (eu_radial = Use_of_eu_outside_shell( eu )) ==
							(struct edgeuse *)NULL )
								continue;

					/* Two adjacent faces here will be seperated
					 * put them on the list to be reunited later
					 */
					if( adj_root == (struct adjacent_faces *)NULL )
					{
						adj_root = (struct adjacent_faces *)rt_malloc(
							sizeof( struct adjacent_faces ),
							"Get_shell: adj_root" );
						adj = adj_root;
					}
					else
					{
						adj = adj_root;
						while( adj->next )
							adj = adj->next;
						adj->next = (struct adjacent_faces *)rt_malloc(
							sizeof( struct adjacent_faces ),
							"Get_shell: adj_next" );
d2317 8
a2324 4
					}
					adj->next = (struct adjacent_faces *)NULL;
					adj->fu1 = fu;
					adj->eu1 = eu;
d2326 8
a2333 8
					fu2 = nmg_find_fu_of_eu( eu_radial );
					if( fu2->orientation != OT_SAME )
					{
						fu2 = fu2->fumate_p;
						eu_radial = eu_radial->eumate_p;
					}
					adj->fu2 = fu2;
					adj->eu2 = eu_radial;
d2335 2
a2336 2
					/* unglue the edge */
					nmg_unglueedge( eu );
d2338 11
a2348 4
					/* make a new edge */
					v1 = (struct vertex *)NULL;
					v2 = (struct vertex *)NULL;
					new_eu = nmg_me( v1 , v2 , new_s );
d2350 9
a2358 2
					/* assign same geometry to this new edge */
					nmg_vertex_gv( new_eu->vu_p->v_p ,
d2360 2
a2361 1
					nmg_vertex_gv( new_eu->eumate_p->vu_p->v_p ,
d2363 5
d2369 7
a2375 17
					/* move the original edge vu's to the new vertices */
					/* Also move any other vu's of these
					 * vertices in new_s to the new shell
					 */
					if( vu_used_outside_shell( eu->vu_p ) )
						Move_vus_in_s_to_newv( eu->vu_p , new_s , new_eu->vu_p->v_p );

					if( vu_used_outside_shell( eu->eumate_p->vu_p ) )
						Move_vus_in_s_to_newv( eu->eumate_p->vu_p , new_s ,
								new_eu->eumate_p->vu_p->v_p );

					/* kill the new edge,
					 * I only wanted it for its vertices.
					 */
					nmg_keu( new_eu );
					break;
				}
a2377 1
		Glue_shell_faces( new_s );
d2379 3
d2901 1
a2901 1
	struct nmgregion *r;
d2903 1
a2903 1
	struct shell **shells,**dup_shells;
d2909 2
d2913 2
a2919 2
/*	Check_normals();	*/

d2927 2
d2938 3
d2944 8
d2956 2
d2959 1
d2961 4
a2964 2
	/* make array of shells, each with unique combination of "center postion" and thickness */
	shells = (struct shell **)rt_calloc( num_thicks*2 , sizeof( struct shell *) , "Extrude_faces: shells" );
d2967 39
a3005 1
	dup_shells = (struct shell **)rt_calloc( num_thicks*2 , sizeof( struct shell *) , "Extrude_faces: dup_shells" );
d3008 1
d3013 4
a3016 2
			shells[ thick_no*2 + center - 1 ] = Get_shell( thicks[thick_no] , center );
			if( debug )
d3018 16
a3033 3
				rt_log( "Shell thickness = %g, center position = %d:\n",
					thicks[thick_no], center );
				nmg_pr_s_briefly( shells[ thick_no*2 + center - 1 ], " " );
d3044 7
a3050 1
		if( shells[ thick_no*2 + center - 1 ] == (struct shell *)NULL )
d3054 1
a3054 1
		if( Adjust_vertices( shells[ thick_no*2 + center - 1 ] , (fastf_t)(thicks[thick_no]/2.0) ) )
d3059 1
d3062 1
d3074 5
d3081 3
a3083 1
			if( shells[ thick_no*2 + center - 1 ] == (struct shell *)NULL )
d3086 2
a3087 2
			dup_shells[thick_no*2+center-1] = nmg_dup_shell( shells[thick_no*2+center-1],
									&trans_tbl, &tol );
d3097 1
a3097 1
			Glue_shell_faces( dup_shells[ thick_no*2 + center - 1 ] );
d3099 1
a3099 1
			nmg_invert_shell( dup_shells[ thick_no*2 + center - 1 ] , &tol );
d3101 1
a3101 1
			if( Adjust_vertices( dup_shells[ thick_no*2 + center - 1 ] , thicks[thick_no] ) )
d3108 1
d3111 2
a3112 2
			if( nmg_open_shells_connect( shells[thick_no*2 + center - 1 ],
						dup_shells[ thick_no*2 + center - 1 ],
d3121 1
d3125 1
d3128 1
a3128 1

d3135 11
d3147 4
d3158 1
a3158 1
	for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
d3160 1
a3160 1
		for( RT_LIST_FOR( s , shell, &r->s_hd ) )
d3173 1
a3173 1
	/* Merge all shells into just two */
d3214 1
a3954 2
				if( debug )
					nmg_pr_s_briefly( s, " " );
d3981 6
d3991 1
a3991 1
				if( Check_radials( s , 2 ) )
d3993 34
a4026 4
					rt_log( "Failed to Extrude group_id = %d, component_id = %d\n" , group_id , comp_id );
					nmg_tbl( &faces , TBL_FREE , (long *)NULL );
					failed = 1;
					goto out;
a4030 5
		/* make all faces triangular
		 * nmg_break_long_edges may have made non-triangular faces
		 */
		nmg_triangulate_model( m , &tol );

d4039 1
d4042 1
a4042 1

d4061 5
d4069 1
d4072 5
a4076 1
			for( RT_LIST_FOR( s, shell, &r->s_hd ) )
d4078 3
d4092 25
a4116 1
				nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ), &tol );
a4122 3
		if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
			rt_log( "ERROR: rt_mem_barriercheck failed in make_nmg_objects (after gluefaces)\n" );

d4956 1
a4956 1
		rt_log( "do_tri: nmg_cmface failed\n" );
d4973 1
a4973 1
		rt_log( "do_tri: ignoring degenerate CTRI element\n" );
d4983 19
d5003 3
a5005 1
		if( !fus_root )
d5007 35
a5041 2
			fus_root = (struct fast_fus *)rt_malloc( sizeof( struct fast_fus ) , "Do_tri: fus_root" );
			fus = fus_root;
d5043 1
a5043 8
		else
		{
			fus = fus_root;
			while( fus->next )
				fus = fus->next;
			fus->next = (struct fast_fus *)rt_malloc( sizeof( struct fast_fus ) , "Do_tri: fus" );
			fus = fus->next;
		}
d5045 1
a5045 7
		fus->next = (struct fast_fus *)NULL;
		fus->fu = fu;
		fus->thick = thick;
		fus->pos = pos;
	}
	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
		rt_log( "ERROR: rt_mem_barriercheck failed in make_fast_fu\n" );
d5084 9
d5180 1
a5180 1
	if( pt1 != pt2 && pt2 != pt3 && pt1 != pt3 )
d5182 12
d5195 5
a5199 1
		make_fast_fu( pt1 , pt2 , pt3 , element_id , thick , pos );
d5201 1
a5201 2

	if( pt1 != pt3 && pt3 != pt4 && pt1 != pt4 )
d5203 5
a5207 1

a5208 1
	}
d5783 1
a5783 1
	while( (c=getopt( argc , argv , "dwpx:X:D:P:" ) ) != EOF )
a5792 3
			case 'p':	/* polysolids */
				polysolids = 1;
				break;
a5812 1
				rt_log( "Unrecognized option (%c)\n" , c );
@


11.8
log
@removed include of db.h
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/fast4-g.c,v 11.7 1996/10/25 15:56:26 jra Exp jra $";
d4895 1
a4895 1
			if( nmgs && make_nmg_objects() )
d4897 2
a4932 7
					rt_log( "ERROR: rt_mem_barriercheck failed in Do_section before freeing cline list\n" );

				if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
					rt_log( "ERROR: rt_mem_barriercheck failed in Do_section before freeing shell list\n" );


				if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
d4972 2
a4973 1

@


11.7
log
@Mod to include tolerance arg to nmg_gluefaces().
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/fast4-g.c,v 11.6 1996/10/08 19:34:51 jra Exp jra $";
a38 1
#include "db.h"
d46 2
@


11.6
log
@Improved handling of CCONE1 elements.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/fast4-g.c,v 11.5 1996/07/12 13:20:17 jra Exp jra $";
d103 1
a103 1
RT_EXTERN( struct shell *nmg_dup_shell , ( struct shell *s , long ***copy_tbl ) );
d2143 1
a2143 1
	nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ) );
d2896 1
a2896 1
									&trans_tbl );
d3735 1
a3735 1
			nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ) );
d3839 1
a3839 1
				nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ) );
d5130 1
a5130 1
	nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ) );
@


11.5
log
@Minor MOds for IRIX 6.2
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/fast4-g.c,v 11.4 1995/10/19 17:09:17 jra Exp jra $";
d4314 3
d4321 1
d4323 2
d4327 2
a4328 1
			inner_r1 = r1 - thick;
d4333 2
a4334 1
			inner_r1 = r1 + thick * (r2 - r1)/length - thick;
d4338 1
a4338 1
		if( inner_r1 < SQRT_SMALL_FASTF )
d4342 1
d4344 1
a4344 3
			dist_to_new_base = length * ( thick + inner_r1 - r1)/(r2 - r1);

			VJOIN1( base , grid_pts[pt1].pt , dist_to_new_base , height_dir );
d4346 2
d4351 2
a4352 1
			inner_r2 = r2 - thick;
d4357 2
a4358 1
			inner_r2 = r1 + (length - thick)*(r2 - r1)/length - thick;
d4362 1
a4362 1
		if( inner_r2 < SQRT_SMALL_FASTF )
d4366 1
d4368 1
a4368 3
			dist_to_new_top = length * ( thick + inner_r1 - r1)/(r2 - r1);

			VJOIN1( top , grid_pts[pt1].pt , dist_to_new_top , height );
d4370 2
@


11.4
log
@Checkpoint.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/fast4-g.c,v 11.3 95/01/17 10:56:22 jra Exp $";
d71 1
a226 8
struct shell_list
{
	struct shell *s;
	fastf_t thick;
	int pos;
	struct shell_list *next;
} *shell_root;

d1981 3
d2025 3
d2035 3
d2160 2
d2163 1
d2838 3
d2895 1
a2895 1
			dup_shells[ thick_no*2 + center - 1 ] = nmg_dup_shell( shells[thick_no*2+center-1],
a2904 1
			rt_free( (char *)trans_tbl , "Extrude_faces: trans_tbl" );
d2916 13
d2931 1
d2957 2
d3000 1
a3000 1

d3007 2
d3011 1
d3183 3
d3256 3
d3267 2
d3286 3
d3300 2
d3304 6
d3311 5
d3414 261
a3706 5
	/* FASTGEN modellers don't always put vertices in the middle of edges where
	 * another edge ends
	 */
	(void)nmg_break_long_edges( s , &tol );

d3713 6
d3721 1
a3721 1
	for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
d3723 6
a3728 1
		NMG_CK_FACEUSE( fu );
d3730 2
a3731 2
		if( fu->orientation != OT_SAME )
			continue;
d3733 4
a3736 1
		nmg_tbl( &faces , TBL_INS , (long *)fu );
d3739 13
a3751 5
	nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ) );

	nmg_fix_normals( s , &tol );

	if( mode == PLATE_MODE && try_count )
d3773 1
a3773 1
		if( Check_radials( s , 2 ) )
d3775 10
a3784 4
			rt_log( "Failed to Extrude group_id = %d, component_id = %d\n" , group_id , comp_id );
			nmg_tbl( &faces , TBL_FREE , (long *)NULL );
			failed = 1;
			goto out;
d3796 15
d3824 5
a3828 1
		nmg_tbl( &faces , TBL_RST , (long *)NULL );
d3830 3
a3832 3
		for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
		{
			NMG_CK_FACEUSE( fu );
d3834 2
a3835 2
			if( fu->orientation != OT_SAME )
				continue;
d3837 4
a3840 1
			nmg_tbl( &faces , TBL_INS , (long *)fu );
a3845 2
		nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ) );

a3848 8
		if( debug )
			rt_log( "Fix normals\n" );

		nmg_fix_normals( s , &tol );

		if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
			rt_log( "ERROR: rt_mem_barriercheck failed in make_nmg_objects (after fix_normals)\n" );

d3861 2
a3862 1
	if( debug && mode != PLATE_MODE )
d3864 4
a3867 5
		char name[NAMESIZE+1];

		sprintf( name , "shell.%d.%d" , group_id , comp_id );
		mk_nmg( fdout , name , m );
		fflush( fdout );
a3869 3
	/*  Make sure faces are within tolerance */
	nmg_make_faces_within_tol( s, &tol );

d3873 7
a3879 1
	tmp_shell_coplanar_face_merge( s , &tol , 0 );
d3884 16
a3899 1
	Recalc_face_g( s );
d3911 30
a3940 4
		/* XXXX Need a decompose shell, write out each shell as a polysolid
		 * and combine them into one object as "name"
		 */
		write_shell_as_polysolid( fdout , name , s );
d3944 1
d3946 1
a3946 1
		if( Check_radials( s, 0 ) )
d3948 11
a3958 2
			rt_log( "Shell has bad radial edge orientation\n" );
			return( 1 );
d3960 1
d3963 1
a3963 1
		if( nmg_ck_closed_surf( s , &tol ) )
d3965 17
a3981 2
			rt_log( "Final shell is not closed\n" );
			return( 1 );
d3989 10
a3998 1
		nmg_simplify_shell( s );
d4658 1
d4660 1
a4884 1
				struct shell_list *shell_ptr;
a4922 10
				shell_ptr = shell_root;
				while( shell_ptr )
				{
					struct shell_list *tmp;

					tmp = shell_ptr;
					shell_ptr = shell_ptr->next;
					rt_free( (char *)tmp , "Do_section: shell_ptr" );
				}
				shell_root = (struct shell_list *)NULL;
@


11.3
log
@Mods to CHeck_radials.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/fast4-g.c,v 11.2 95/01/13 16:21:24 jra Exp $";
d2224 1
a2224 1
							"Get_shell: adj_root" );
d2360 40
d2404 1
d2406 3
d2410 1
a2410 1
	/* maybe ther's nothing to do */
d2422 1
d2425 57
d2483 6
d2526 265
d2794 1
d2812 2
d2843 1
d2845 7
d2921 17
d2966 6
d2982 2
d2990 6
d3357 2
d3524 3
d3556 2
d3559 1
d3563 2
d3566 1
d4942 4
a4945 1
	while( getline() )
d4986 3
@


11.2
log
@Fixed a minor bug
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/fast4-g.c,v 11.1 95/01/04 09:59:27 mike Rel4_4 Locker: jra $";
d2727 1
a2727 1
Check_radials( s_p )
d2729 1
d2807 1
a2807 1
		if( use_count%2 )
d2809 11
d2823 2
a2824 1
		if( use_count != 2 )
d3028 8
d3135 1
a3135 1
		if( Check_radials( s ) )
@


11.1
log
@Release_4.4
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/fast4-g.c,v 1.20 95/01/03 09:49:16 jra Exp $";
d1957 3
d1961 6
d2708 18
d2733 1
a2815 1
			double *angles;
d2822 1
d2861 21
a2882 1
					radials_ok = 1;
d2900 4
a2903 1
							break;
d2912 1
d2916 4
a3096 16
		rt_log( "ERROR: rt_mem_barriercheck failed in make_nmg_objects (after Recalc_face_g)\n" );

	/* Check if a valid closed shell has been produced */
	if( nmg_ck_closed_surf( s , &tol ) )
		return( 1 );

	/* Check radial orientation around all edges */
	if( Check_radials( s ) )
		return( 1 );

	if( debug )
		rt_log( "model fuse\n" );

	nmg_model_fuse( m , &tol );

	if( rt_g.debug&DEBUG_MEM_FULL &&  rt_mem_barriercheck() )
d3113 13
d4588 1
@


1.20
log
@Removed a CONST.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/fast4-g.c,v 1.19 94/12/09 16:21:43 jra Exp Locker: jra $";
@


1.19
log
@Fixed to avoid rt_bomb on failed volume mode components.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /n/wolf/m/cad/conv/RCS/fast4-g.c,v 1.18 94/12/02 16:27:19 jra Exp $";
d2352 1
a2352 1
CONST long **tbl;
@


1.18
log
@Removed unreferenced variable.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /n/wolf/m/cad/conv/RCS/fast4-g.c,v 1.17 94/12/02 16:24:55 jra Exp Locker: jra $";
d2472 6
a2477 1
			rt_bomb( "Failure in Adjusting vertices\n" );
d2511 7
a2517 1
				rt_bomb( "Failure in Adjust vertices\n" );
d3048 1
a3048 1
	if( mode == PLATE_MODE && Check_radials( s ) )
d3936 2
d3946 3
d4043 1
d4047 1
d4623 1
@


1.17
log
@Modified to do re-tries without RT_SETJMP.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/fast4-g.c,v 1.16 94/12/01 11:16:44 jra Exp Locker: jra $";
a3941 1
				struct cline *cline_ptr;
@


1.16
log
@Minor fixes (needed calls to nmg_rebound).
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/fast4-g.c,v 1.15 94/11/08 16:14:57 jra Exp Locker: jra $";
d78 1
d176 9
d187 1
d242 48
d303 4
a306 1
		int_list = (int *)rt_realloc( (char *)int_list , (int_list_length + INT_LIST_BLOCK)*sizeof( int ) , "insert_id: int_list" );
d312 3
d447 2
d518 2
d626 7
d634 43
d724 1
a724 1
struct name_tree *root;
d733 1
a733 1
	ptr = root;
d777 2
a778 2
			root = ptr->nright;
			ptr2 = root;
d783 1
a783 1
			ptr2 = root;
d788 1
a788 1
		else
d790 2
a791 2
			root = ptr->nleft;
			ptr2 = root;
d795 1
a795 1
			ptr2 = root;
d800 5
a804 1

d806 2
a808 1

d842 1
a842 1
	ptr = root;
d918 4
d952 1
d979 2
d1021 1
d1073 3
d1121 1
a1121 1
		if( len + append_len <= NAMESIZE )
d1124 1
d1126 2
d1131 2
d1158 3
d1301 1
a1301 1
		strncpy( name_name , tmp_name , NAMESIZE+1 );
d1303 2
a1304 1
		strncpy( name_name , &tmp_name[len-NAMESIZE] , NAMESIZE+1 );
d1311 2
d1390 3
d1422 2
d1451 1
a1451 1
	for( sph_no=0 ; sph_no < int_list_length ; sph_no++ )
d1546 1
a1546 1
				Delete_name( name_root , bad_name );
d1607 1
a1607 1
	int_list_length = 0;
d1624 3
d1877 3
d1927 3
d1961 3
d2037 3
d2135 3
d2267 3
d2346 2
a2347 1

d2405 2
d2558 3
d2683 3
d2688 180
a2867 1
void
d2878 3
a2880 2
	if( !m )
		return;
d2882 17
d2929 2
a2930 1
		return;
d2944 4
d2953 3
d2967 3
d2982 3
d2987 3
d2994 4
d3001 3
d3007 3
d3023 4
d3029 11
d3045 3
d3050 3
d3064 3
d3069 3
d3105 1
a3105 1
		return;
d3121 4
d3163 3
d3779 2
d3939 1
a3939 1
			if( RT_SETJUMP )
a3945 1
				RT_UNSETJUMP;
d3948 1
d3952 4
d3961 2
a3962 3
				/* reset debug flags to what the user requested */
				rt_g.NMG_debug = nmg_debug;
				rt_g.debug = rt_debug;
d3976 2
a3977 4
				cline_ptr = cline_root;
				while( cline_ptr )
				{
					struct cline *tmp;
d3979 2
a3980 5
					tmp = cline_ptr;
					cline_ptr = cline_ptr->next;
					rt_free( (char *)tmp , "Do_section: cline_ptr" );
				}
				cline_root = (struct cline *)NULL;
d3993 3
d4007 3
d4027 1
a4027 2
							if( !final )
								(void)getline();
d4031 1
d4033 8
d4042 1
a4042 4
			{
				make_nmg_objects();
				make_cline_regions();
				make_comp_group();
a4043 10
				if( try_count )
				{
					second_chance++;
					try_count = 0;
				}
				else
					conv_count++;

				RT_UNSETJUMP;
			}
d4322 3
d4402 3
d4412 1
a4412 1
/*	if( debug ) */
d4547 11
@


1.15
log
@Mods for Irix 6.0
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /n/wolf/m/cad/conv/RCS/fast4-g.c,v 1.14 1994/11/01 09:34:22 jra Exp jra $";
d1761 2
a1762 1
			nmg_edge_g( eu );
d2555 1
d3871 1
@


1.14
log
@Changed call to mk_lrcomb to agree with prototype.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/fast4-g.c,v 1.13 94/10/19 22:03:33 mike Exp Locker: jra $";
d85 6
a106 7
static char	*mode_str[3]=		/* mode strings */
{
	"unknown mode",
	"plate mode",
	"volume mode"
};

d231 22
a969 1
	struct name_tree *ptr;
d979 1
a979 1
	ptr = Search_names( name_root , name , &found );
d991 1
a991 1
		ptr = Search_names( name_root , name , &found );
a999 4
	int group_no;

	group_no = reg_id / 1000;

a1177 1
	int found;
a1178 1
	struct name_tree *ptr;
a1278 1
	struct nmg_ptbl points;
a1286 1
	nmg_tbl( &points , TBL_INIT , (long *)NULL );
d1293 2
a1294 2
		nmg_tbl( &points , TBL_INS_UNIQUE , (long *)cline_ptr->pt1 );
		nmg_tbl( &points , TBL_INS_UNIQUE , (long *)cline_ptr->pt2 );
d1300 1
a1300 1
	for( sph_no=0 ; sph_no < NMG_TBL_END( &points ) ; sph_no++ )
d1310 1
a1310 1
		pt_no = (int)NMG_TBL_GET( &points , sph_no );
d1456 1
a1456 1
	nmg_tbl( &points , TBL_FREE , (long *)NULL );
a1567 1
	struct nmgregion *r1;
a2180 1
	struct vertex *verts[3];
a2290 2
		struct shell *s2;

a2307 1
			struct faceuse *fu;
d2381 2
d2470 1
a2470 1
out:	nmg_km( m );
d2616 1
a2616 1
	Recalc_face_g( s , &tol );
a2813 1
	char reg_name[NAMESIZE+1];
d2825 2
a2826 2
			rt_log( "\tgroup_id = %d, comp_id = %d, element_id = %d, c1 = %d\n",
				group_id, comp_id, element_id , c1 );
d3030 2
a3031 2
			rt_log( "\tgroup_id = %d, comp_id = %d, element_id = %d, c1 = %d\n",
				group_id, comp_id, element_id , c1 );
d3778 2
a3779 2
			rt_log( "\tgroup_id = %d, comp_id = %d, element_id = %d, c1 = %d\n",
				group_id, comp_id, element_id , cont1 );
d3903 2
a3904 2
			rt_log( "\tgroup_id = %d, comp_id = %d, element_id = %d, c1 = %d\n",
				group_id, comp_id, element_id , cont1 );
@


1.13
log
@Changed mk_arb8().
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/fast4-g.c,v 1.12 94/09/22 13:12:53 jra Exp Locker: mike $";
d137 1
a137 1
					(char *)NULL, (char *)NULL, (char *)NULL, r_id, 0, 0, 0, 0 ); \
@


1.12
log
@Fixed bug in Recalc_edge_geometry due to new nmg_edge() routine.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/fast4-g.c,v 1.11 94/09/21 04:30:22 mike Exp Locker: jra $";
d2453 1
a2453 1
		mk_arb8( fdout , arb6_name , pts );
d3815 1
a3815 1
	mk_arb8( fdout , name , points );
d3940 1
a3940 1
	mk_arb8( fdout , name , points );
@


1.11
log
@A quick conversion over to the new NMG data structures.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/fast4-g.c,v 1.10 94/09/21 04:20:45 mike Exp Locker: mike $";
d1729 1
d1732 11
a1743 1
		struct edge_g_lseg	*eg;
d1748 2
a1749 4
		eg = eu->g.lseg_p;
		NMG_CK_EDGE_G_LSEG( eg );

		if( NMG_INDEX_TEST_AND_SET( flags , eg ) )
d1751 2
@


1.10
log
@JRA added some PLATE_MODE checks, and some improvements to the
sphere handling.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /n/wolf/m/cad/conv/RCS/fast4-g.c,v 1.9 94/08/10 23:52:07 gdurf Exp Locker: jra $";
d245 2
a246 2
	struct face_g	*fg1;
	struct face_g	*fg2;
d266 2
a267 2
		fg1 = f1->fg_p;
		NMG_CK_FACE_G(fg1);
d285 2
a286 2
			fg2 = f2->fg_p;
			NMG_CK_FACE_G(fg2);
d330 1
a330 1
						rt_log( "plane = ( %f %f %f %f )\n" , V4ARGS( fu1->f_p->fg_p->N ) );
d332 1
a332 1
						rt_log( "plane = ( %f %f %f %f )\n" , V4ARGS( fu2->f_p->fg_p->N ) );
d1720 1
a1720 1
	struct nmg_ptbl edges;
d1723 1
a1723 1
	nmg_tbl( &edges , TBL_INIT , (long *)NULL );
d1727 1
a1727 1
	nmg_edge_tabulate( &edges , &new_s->l.magic );
d1729 1
a1729 1
	for( i=0 ; i<NMG_TBL_END( &edges ) ; i++ )
d1731 2
a1732 2
		struct edge *e;
		struct edge_g *eg;
d1734 2
a1735 2
		e = (struct edge *)NMG_TBL_GET( &edges , i );
		NMG_CK_EDGE( e );
d1737 2
a1738 2
		eg = e->eg_p;
		NMG_CK_EDGE_G( eg );
d1741 1
a1741 1
			nmg_edge_g( e );
d1746 1
a1746 1
	nmg_tbl( &edges , TBL_FREE , (long *)NULL );
d1761 1
a1761 1
		struct face_g *fg;
d1770 2
a1771 2
		fg = f->fg_p;
		NMG_CK_FACE_G( fg );
d1796 1
a1796 1
		struct face_g *fg_p;
d1800 2
a1801 2
		fg_p = fu->f_p->fg_p;
		NMG_CK_FACE_G( fg_p );
d1809 3
a1811 1
					fu->f_p->fg_p, V4ARGS( fu->f_p->fg_p->N ) , fu->f_p );
@


1.9
log
@Factored ifdefs
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/fast4-g.c,v 1.8 1994/07/15 15:59:17 jra Exp gdurf $";
d1516 1
a1516 2
	inner_radius = radius - thick;
	if( thick > 0.0 && inner_radius <= 0.0 )
d1518 7
a1524 4
		rt_log( "do_sphere: illegal thickness (%f), skipping inner sphere\n" , thick );
		rt_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
		return;
	}
d1526 2
a1527 2
	make_solid_name( name , CSPHERE , element_id , comp_id , group_id , 1 );
	mk_sph( fdout , name , grid_pts[center_pt].pt , inner_radius );
d1529 5
a1533 4
	if( mk_addmember( name , &sphere_region , WMOP_SUBTRACT ) == (struct wmember *)NULL )
	{
		rt_log( "do_sphere: Error in subtracting %s from sphere region\n" , name );
		rt_bomb( "do_sphere" );
@


1.8
log
@Working version with retries for failed PLATE-MODE objects.
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/fast4-g.c,v 1.7 94/07/14 12:31:57 jra Exp Locker: jra $";
d27 2
d31 1
d33 5
a46 4

extern int errno;
extern int optind,opterr;
extern char *optarg;
@


1.7
log
@Checkpoint
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/fast4-g.c,v 1.6 94/07/13 13:43:26 jra Exp Locker: jra $";
d69 5
d177 2
a178 2
				 * == 0 -> component name
				 */
d797 1
d863 1
d1014 1
a1014 1
		if(ptr->region_id == region_id && ptr->element_id )
d1021 1
a1169 3
		if( !pass )
			rt_log( "make_region_name: Name for region with g_id=%d, c_id=%d, el_id=%d, and type %c already exists (%s)\n",
				g_id, c_id, element_id, type , tmp_name );
d2268 1
a2268 15
		{
			/* debugging: write an NMG of the outer shell named "name.BAD" */
			char bad[NAMESIZE+1];

			sprintf( bad , "BAD.%d.%d" , group_id , comp_id );
			mk_nmg( fdout , bad , m );
			fflush( fdout );
			rt_log( "Extrude_faces: Could not extrude shell x%x.\n\tBAD shell written as %s\n" , shells[ thick_no*2 + center - 1 ] , bad );
			nmg_km( m );
			m = (struct model *)NULL;
			r = (struct nmgregion*)NULL;
			s = (struct shell *)NULL;
			rt_free( (char *)dup_tbl , "Extrude_faces: copy_tbl" );
			return( 1 );
		}
d2303 1
a2303 15
			{
				/* debugging: write an NMG of the outer shell named "name.BAD" */
				char bad[NAMESIZE+1];

				sprintf( bad , "BAD.%d.%d" , group_id , comp_id );
				mk_nmg( fdout , bad , m );
				fflush( fdout );
				rt_log( "Extrude_faces: Could not extrude shell x%x.\n\tBAD shell written as %s\n" , shells[ thick_no*2 + center - 1 ] , bad );
				nmg_km( m );
				m = (struct model *)NULL;
				r = (struct nmgregion*)NULL;
				s = (struct shell *)NULL;
				rt_free( (char *)dup_tbl , "Extrude_faces: copy_tbl" );
				return( 1 );
			}
d2346 1
a2346 3
	{
		/* debugging: write an NMG of the outer shell named "name.BAD" */
		char bad[NAMESIZE+1];
a2347 10
		sprintf( bad , "BAD.%d.%d" , group_id , comp_id );
		mk_nmg( fdout , bad , m );
		fflush( fdout );
		rt_log( "Extrude_faces: Could not connect plate mode shells.\n\tBAD shell written as %s\n" , bad );
		nmg_km( m );
		m = (struct model *)NULL;
		rt_free( (char *)dup_tbl , "Extrude_faces: copy_tbl" );
		return( 1 );
	}

d2357 121
d2518 1
a2518 1
	if( mode == PLATE_MODE )
d2520 5
d2611 2
d3457 3
d3464 2
a3465 1
			comp_count++;
d3534 23
d3563 9
a3571 1
				conv_count++;
d3930 1
a3930 1
void
d3936 1
a3936 1
		rt_log( "\n\nProcess_input( pass = %d )\n" , pass_number );
d3947 1
a3949 1

d3987 2
d3991 3
d3999 2
d4108 1
a4108 1
	Process_input( 1 );
d4117 1
@


1.6
log
@working version
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/fast4-g.c,v 1.5 94/06/27 10:49:25 jra Exp Locker: jra $";
d90 1
a353 1
#if 0
a354 98
Rm_doubly_defined_faces( new_s )
struct shell *new_s;
{
	struct faceuse *fu1;

	NMG_CK_SHELL( new_s );

	fu1 = RT_LIST_FIRST( faceuse , &new_s->fu_hd ) );
	while( RT_LIST_NOT_HEAD( fu1 , &new_s->fu_hd ) )
	{
		plane_t pl1;
		struct faceuse *next_fu1;
		struct faceuse *fu2;

		NMG_CK_FACEUSE( fu1 );

		if( fu1->orientation != OT_SAME )
		{
			fu1 = RT_LIST_PNEXT( faceuse , fu1 );
			continue;
		}

		next_fu1 = RT_LIST_PNEXT( faceuse , fu1 );

		NMG_GET_FU_PLANE( pl1 , fu1 );
		fu2 = next_fu1;
		while(  RT_LIST_NOT_HEAD( fu2 , &new_s->fu_hd ) )
		{
			plane_t pl2;
			struct faceuse *next_fu2;
			fastf_t dot;

			NMG_CK_FACEUSE( fu2 );

			if( fu2->orientation != OT_SAME )
			{
				fu2 = RT_LIST_PNEXT( faceuse , fu2 );
				continue;
			}

			next_fu2 = RT_LIST_PNEXT( fu2 );

			NMG_GET_FU_PLANE( pl2 , fu2 );

			dot = VDOT( pl1 , pl2 );
			if( !RT_VECT_ARE_PARALLEL( dot , &tol )
			{
				fu2 = next_fu2;
				continue;
			}

			if( dot > 0.0 && !NEAR_ZERO( pl1[3] - pl2[3] , tol.dist ) ||
			    dot < 0.0 && !NEAR_ZERO( pl1[3] + pl2[3] , tol.dist ) )
			{
				fu2 = next_fu2;
				continue;
			}

			/* fu1 and fu2 are coplanar
			 * now check if any loops are doubly defined
			 */

			for( RT_LIST_FOR( lu , loopuse , &fu2->lu_hd ) )
			{
				struct fu_pt_info *pt_info;
				int in_fu1=1;

				if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
					continue;

				for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
				{
					if( nmg_class_pt_f( eu->vu_p->v_p->vg_p->coord , fu1 , &tol == NMG_CLASS_AoutB )
					{
						in_fu1 = 0;
						break;
					}
				}

				if( in_fu1 )
				{
					/* This loop in fu2 is also in fu1
					 * this occurs where two solid objects have
					 * been described adjacent to each other, with
					 * the intervening face described twice
					 */
				}
			}

			fu2 = next_fu2;
		}

		fu1 = next_fu1;
	}
}
#endif

void
a1749 5
		struct loopuse *lu;
		plane_t pl;
		vect_t norm;
		fastf_t dist=0.0;
		int pl_count=0;
d1762 2
a1763 4
		{
			struct faceuse *fu1;
			struct face *f1;
			int first=1;
d1765 1
a1765 78
			VSET( norm , 0.0 , 0.0 , 0.0 );

			for( RT_LIST_FOR( f1 , face , &fg->f_hd ) )
			{
				fu1 = f1->fu_p;
				if( fu1->orientation != OT_SAME )
					fu1 = fu1->fumate_p;
				if( fu1->orientation != OT_SAME )
					rt_bomb( "Recalc_face_g: face has no OT_SAME use\n" );

				for( RT_LIST_FOR( lu , loopuse , &fu1->lu_hd ) )
				{
					fastf_t area;

					if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
						continue;

					area = nmg_loop_plane_area( lu , pl );

					if( area > 0.0 )
					{
						if( lu->orientation != OT_SAME )
							HREVERSE( pl , pl );

						if( first )
							first = 0;
						else
						{
							if( VDOT( norm , pl ) < 0.0 )
								HREVERSE( pl , pl );
						}

						VADD2( norm , norm , pl );
						dist += pl[3];
						pl_count++;
					}
				}
			}
			if( !pl_count )
			{
				rt_log( "Recalc_face_g: Cannot recalculate plane for faceuse (x%x):\n" , fu );
				nmg_pr_fu_briefly( fu , (char *)NULL );
				continue;
			}
			else if( pl_count == 1 )
			{
				VMOVE( pl , norm );
				pl[3] = dist;
			}
			else if( pl_count > 1 )
			{
				VUNITIZE( norm );
				VMOVE( pl , norm );
				pl[3] = dist/(fastf_t)pl_count;
			}

			if( debug )
				rt_log( "Recalc_face_g: fu x%x fg x%x was ( %f %f %f %f )\n\tnow ( %f %f %f %f )\n",
					fu , fg , V4ARGS( fu->f_p->fg_p->N ) , V4ARGS( pl ) );

			nmg_face_g( fu , pl );

			if( nmg_ck_fg_verts( fu , fu->f_p , &tol ) )
			{
				for( RT_LIST_FOR( f1 , face , &fg->f_hd ) )
				{
					fu1 = f1->fu_p;
					if( fu1->orientation != OT_SAME )
						fu1 = fu1->fumate_p;

					rt_log( "fu x%x, mate=x%x\n" , fu1 , fu1->fumate_p );
					nmg_pr_fu_briefly( fu1 , (char *)NULL );
				}
				rt_bomb( "Recalc_face_g: made a bad face\n" );
			}

		}
	}
@


1.5
log
@checkpoint
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1993 by the United States Army
d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/fast4-g.c,v 1.4 94/05/03 13:08:31 jra Exp Locker: jra $";
d64 5
a74 1
static struct shell	*s2;		/* NMG shell extruded from 's' for plate mode */
d76 8
a83 1
static char	*usage="Usage:\n\tfast4-g [-d] [-w] fastgen4_bulk_data_file output.g\n";
d87 1
a87 1
RT_EXTERN( struct shell *nmg_extrude_shell , ( struct shell *s1 , fastf_t thick , int normal_ward , struct rt_tol *tol ) );
d200 1
a200 1
	struct faceuse *fu,*fu2;
d206 1
a206 4
void
nmg_fix_parallel_faces( s1 , tol )
struct shell *s1;
CONST struct rt_tol *tol;
d208 5
a212 4
	int edge_no;
	struct nmg_ptbl tab;
	struct nmg_ptbl edges;
	char shell_name[NAMESIZE+1];
d214 6
a219 1
	rt_log( "nmg_fix_parallel_faces\n" );
d221 16
a236 2
	NMG_CK_SHELL( s1 );
	RT_CK_TOL( tol );
d238 7
a244 2
	/* get list of edges in this shell */
	nmg_edge_tabulate( &tab, &s1->l.magic );
d246 3
a248 1
	nmg_tbl( &edges , TBL_INIT , (long *)NULL );
d250 5
a254 2
	sprintf( shell_name , "shell.%d.%d" , group_id , comp_id );
	mk_nmg( fdout , shell_name , m );
d256 3
a258 7
	/* look at each edge */
	for( edge_no = 0 ; edge_no < NMG_TBL_END( &tab ) ; edge_no++ )
	{
		struct edge *e;
		struct edgeuse *eu;
		struct faceuse *fu1,*fu2;
		plane_t pl1,pl2;
d260 9
a268 1
		e = (struct edge *)NMG_TBL_GET( &tab , edge_no );
d270 4
a273 3
		/* does this edge border two parallel but distinct planes ?? */
		eu = e->eu_p;
		NMG_CK_EDGEUSE( eu );
d275 2
a276 10
		fu1 = nmg_find_fu_of_eu( eu );
		if( fu1->orientation != OT_SAME )
			fu1 = fu1->fumate_p;
		if( fu1->orientation != OT_SAME )
		{
			rt_log( "nmg_fix_parallel_faces: fu x%x has no OT_SAME side\n" , fu1 );
			nmg_tbl( &tab , TBL_FREE , (long *)NULL );
			nmg_tbl( &edges , TBL_FREE , (long *)NULL );
			return;
		}
d278 2
a279 13
		/* get radial face */
		eu = nmg_next_radial_eu( eu , s1 , 0 );
		NMG_CK_EDGEUSE( eu );
		fu2 = nmg_find_fu_of_eu( eu );
		if( fu2->orientation != OT_SAME )
			fu2 = fu2->fumate_p;
		if( fu2->orientation != OT_SAME )
		{
			rt_log( "nmg_fix_parallel_faces: fu x%x has no OT_SAME side\n" , fu2 );
			nmg_tbl( &tab , TBL_FREE , (long *)NULL );
			nmg_tbl( &edges , TBL_FREE , (long *)NULL );
			return;
		}
d281 4
a284 3
		/* if faces are the same, no problem */
		if( fu2->f_p == fu1->f_p )
			continue;
d286 3
a288 3
		/* check planes of these two faces */
		NMG_GET_FU_PLANE( pl1 , fu1 );
		NMG_GET_FU_PLANE( pl2 , fu2 );
d290 8
a297 3
		/* if planes intersect, no problem */
		if( rt_coplanar( pl1 , pl2 , tol ) != ( -1) )
			continue;
d299 8
a306 10
		/* if we get here, then the planes of the two faces
		 * adjoining this edge are parallel, but distinct
		 * i.e., there is no intersection.
		 * Add this edge to the list of problem edges
		 */
		rt_log( "( %f %f %f ) to ( %f %f %f )\n" , V3ARGS( eu->vu_p->v_p->vg_p->coord ),
							   V3ARGS( eu->eumate_p->vu_p->v_p->vg_p->coord ) );
		rt_log( "\t( %f %f %f %f ) and ( %f %f %f %f)\n" , V4ARGS( pl1 ) , V4ARGS( pl2 ) );
		nmg_tbl( &edges , TBL_INS , (long *)e );
	}
d308 6
a313 2
	/* The original list of all edges in the shell is no longer needed */
	nmg_tbl( &tab , TBL_FREE , (long *)NULL );
d315 14
a328 9
	/* The edge list (edges) now has only edges
	 * between faces that are parallel, but distinct (they don't intersect )
	 */
	if( NMG_TBL_END( &edges ) == 0 )
	{
		/* nothing to do */
		nmg_tbl( &edges , TBL_FREE , (long *)NULL );
		return;
	}
d330 2
a331 3
	/* Now build faces to connect non_intersecting faces that
	 * are supposed to share an edge
	 */
d333 5
a337 14
	for( edge_no=0 ; edge_no < NMG_TBL_END( &edges ) ; edge_no++ )
	{
		struct edge *e;
		struct edgeuse *eu1,*eu2;
		struct faceuse *fu1,*fu2,*new_fu;
		struct loopuse *new_lu,*lu;
		struct edgeuse *eu_prev,*eu_next;
		struct edgeuse *new_eu;
		struct vertexuse *vu1,*vu2;
		struct vertex *v;
		plane_t pl1,pl2,new_pl;
		point_t pt;
		vect_t eu_dir;
		fastf_t dist_to_plane;
d339 7
a345 2
		e = (struct edge *)NMG_TBL_GET( &edges , edge_no );
		NMG_CK_EDGE( e );
d347 5
a351 2
		eu1 = e->eu_p;
		NMG_CK_EDGEUSE( eu1 );
a352 1

d354 5
d360 1
a360 2
		fu1 = nmg_find_fu_of_eu( eu1 );
		NMG_CK_FACEUSE( fu1 );
d362 6
a367 1
		NMG_GET_FU_PLANE( pl1 , fu1 );
d369 1
a369 2
		eu2 = nmg_next_radial_eu( eu1 , s1 , 0 );
		NMG_CK_EDGEUSE( eu2 );
d371 1
a371 6
		fu2 = nmg_find_fu_of_eu( eu2 );
		NMG_CK_FACEUSE( fu2 );

		NMG_GET_FU_PLANE( pl2 , fu2 );

		if( rt_coplanar( pl1 , pl2 , tol ) != ( -1) )
d373 2
a374 3
			/* something went very wrong!!!! */
			rt_log( "nmg_fix_parallel_faces: non-intersecting planes intersect!!!\n" );
			rt_bomb( "nmg_fix_parallel_faces\n" );
d377 1
a377 3
		/* split the edges before and after eu1 */
		eu_prev = RT_LIST_PPREV_CIRC( edgeuse , &eu1->l );
		NMG_CK_EDGEUSE( eu_prev );
d379 7
a385 7
		/* get the mate for the next edgeuse after "eu" so that
		 * both eu_prev and eu_next are edgeuses terminating
		 * at the endpoints of eu
		 */
		eu_next = RT_LIST_PNEXT_CIRC( edgeuse , &eu1->l );
		NMG_CK_EDGEUSE( eu_next );
		eu_next = eu_next->eumate_p;
d387 1
a387 3
		/* first, split eu_prev */
		new_eu = nmg_esplit( (struct vertex *)NULL , eu_prev );
		vu1 = new_eu->vu_p;
d389 5
a393 4
		/* for safety, go ahead and assign some geometry */
		dist_to_plane = DIST_PT_PLANE( eu1->vu_p->v_p->vg_p->coord , pl1 );
		VJOIN1( pt , eu1->vu_p->v_p->vg_p->coord , -dist_to_plane , pl1 );
		nmg_vertex_gv( vu1->v_p , pt );
d395 1
a395 3
		/* now split eu_next */
		new_eu = nmg_esplit( (struct vertex *)NULL , eu_next );
		vu2 = new_eu->vu_p;
d397 1
a397 4
		/* again, assign some geometry */
		dist_to_plane = DIST_PT_PLANE( eu1->eumate_p->vu_p->v_p->vg_p->coord , pl1 );
		VJOIN1( pt , eu1->eumate_p->vu_p->v_p->vg_p->coord , -dist_to_plane , pl1 );
		nmg_vertex_gv( vu2->v_p , pt );
d399 6
a404 2
		/* cut the loop in fu1 at the two new vertices */
		new_lu = nmg_cut_loop( vu1 , vu2 );
d406 6
a411 5
		/* find the loop with eu1 in it, that's the new loop */
		new_lu = eu1->up.lu_p;
		NMG_CK_LOOPUSE( new_lu );
		new_lu->orientation = OT_SAME;
		new_lu->lumate_p->orientation = OT_SAME;
d413 3
a415 6
		/* re-orient the OT_UNSPEC loops created by nmg_cut_loop
		 * first move all the vertices to the plane of fu1
		 */
		for( RT_LIST_FOR( lu , loopuse , &fu1->lu_hd ) )
		{
			struct edgeuse *eu_tmp;
d417 1
a417 4
			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
				continue;

			for( RT_LIST_FOR( eu_tmp , edgeuse , &lu->down_hd ) )
d419 2
a420 1
				struct vertex *v_tmp;
d422 1
a422 3
				v_tmp = eu_tmp->vu_p->v_p;
				dist_to_plane = DIST_PT_PLANE( v_tmp->vg_p->coord , pl1 );
				if( NEAR_ZERO( dist_to_plane , tol->dist ) )
d425 17
a441 1
				VJOIN1( v_tmp->vg_p->coord , v_tmp->vg_p->coord , -dist_to_plane , pl1 );
a442 1
		}
d444 1
a444 7
		/* now re-orient the loops */
		for( RT_LIST_FOR( lu , loopuse , &fu1->lu_hd ) )
		{
			if( lu->orientation != OT_UNSPEC )
				continue;

			nmg_lu_reorient( lu , tol );
d447 1
a447 12
		/* break this new loop into a face of its own */
		new_fu = nmg_mk_new_face_from_loop( new_lu );

		/* calculate a plane perpendicular to pl1 through vu1 */
		VSUB2( eu_dir , vu2->v_p->vg_p->coord , vu1->v_p->vg_p->coord );
		VCROSS( new_pl , pl1 , eu_dir );
		VUNITIZE( new_pl );
		new_pl[H] = VDOT( new_pl , vu1->v_p->vg_p->coord );

		/* assign this plane to the new face */
		nmg_face_g( new_fu , new_pl );
#endif
a448 2

	nmg_tbl( &edges , TBL_FREE , (long *)NULL );
d450 1
d1033 50
a1166 20
add_to_series( name , reg_id )
char *name;
int reg_id;
{
	int group_no;

	group_no = reg_id / 1000;

	if( group_id < 0 || group_id > 10 )
	{
		rt_log( "add_to_series: region (%s) not added, illegal group number %d, region_id=$d\n" ,
			name , group_id , reg_id );
		return;
	}

	if( mk_addmember( name , &group_head[group_id] , WMOP_UNION ) == (struct wmember *)NULL )
		rt_log( "add_to_series: mk_addmember failed for region %s\n" , name );
}

void
a1239 30
make_unique_name( name )
char *name;
{
	struct name_tree *ptr;
	char append[10];
	int append_len;
	int len;
	int found;

	/* make a unique name from what we got off the $NAME card */

	len = strlen( name );

	ptr = Search_names( name_root , name , &found );
	while( found )
	{
		sprintf( append , "_%d" , name_count );
		name_count++;
		append_len = strlen( append );

		if( len + append_len <= NAMESIZE )
			strcat( name , append );
		else
			strcpy( &name[NAMESIZE-append_len] , append );

		ptr = Search_names( name_root , name , &found );
	}
}

void
d1281 1
a1281 1
make_solid_name( name , type , element_id , c_id , g_id , inner )
d1289 1
a1289 1
	get_solid_name( name , type , element_id , c_id , g_id , inner );
d1291 3
a1293 1
	Insert_name( &name_root , name );
d1297 1
a1297 1
get_solid_name( name , type , element_id , c_id , g_id , inner )
d1305 1
a1305 1
	int reg_id;
d1307 1
a1307 3
	reg_id = g_id * 1000 + c_id;

	sprintf( name , "%d.%d.%c%d" , reg_id , element_id , type , inner );
d1741 3
a1743 2
void
Extrude_faces()
d1745 4
a1748 5
	struct fast_fus *fus;
	struct nmg_ptbl verts;
	int i;
	int centers=0;
	long **trans_tbl;
d1750 34
a1783 2
	if( debug )
		rt_log( "Extrude_faces:\n" );
a1784 4
	Check_normals();

	nmg_tbl( &verts , TBL_INIT , (long *)NULL );

d1786 2
d1790 1
a1790 1
		if( fus->pos == POS_CENTER )
d1792 2
a1793 2
			centers = 1;
			break;
d1798 18
a1815 1
	if( centers )
d1817 2
a1818 3
		/* must extrude twice
		 * first extrude normalward
		 */
d1820 2
a1821 2
		if( debug )
			rt_log( "\tCenter postion:\n" );
d1823 2
a1824 2
		/* rebound the region */
		nmg_rebound( m , &tol );
d1826 39
a1864 2
		fus = fus_root;
		while( fus )
d1866 3
a1868 2
			struct faceuse *fu;
			struct face_g *fg;
d1870 3
a1872 1
			if( fus->pos == POS_CENTER )
d1874 5
a1878 4
				fu = fus->fu;
				NMG_CK_FACEUSE( fu );
				fg = fu->f_p->fg_p;
				NMG_CK_FACE_G( fg );
d1880 27
a1906 4
				if( fu->f_p->flip )
					fg->N[3] -= fus->thick/2.0;
				else
					fg->N[3] += fus->thick/2.0;
d1908 17
d1926 20
a1945 1
			fus = fus->next;
d1947 2
d1950 10
a1959 1
		nmg_fix_parallel_faces( s , &tol );
d1961 1
a1961 2
		if( debug )
			rt_log( "\t\ttabulate vertices\n" );
d1963 4
a1966 2
		/* adjust all vertices */
		nmg_vertex_tabulate( &verts , &s->l.magic );
d1968 7
a1974 3
		if( debug )
			rt_log( "\t\tadjust vertex geometry\n" );
		for( i=0 ; i<NMG_TBL_END( &verts ) ; i++ )
d1976 1
a1976 4
			struct vertex *v;

			v = (struct vertex *)NMG_TBL_GET( &verts , i );
			if( nmg_in_vert( v , &tol ) )
d1978 3
a1980 1
				rt_log( "Extrude_faces: Could not find new vertex for extruded face\n" );
d1982 4
a1986 1
		nmg_tbl( &verts , TBL_RST , (long *)NULL );
d1989 1
a1989 1
	/* extrude faces anti-normalward */
d1991 2
a1992 4
	if( debug )
		rt_log( "\tDuplicate shell\n" );
	/* first duplicate the plate mode faceuses */
	s2 = nmg_dup_shell( s , &trans_tbl );
d1994 4
a1997 2
	if( debug )
		rt_log( "\t\told shell was x%x duplicate is x%x\n" , s , s2 );
d1999 128
a2126 1
	/* now move the face planes */
a2129 3
		struct faceuse *fu;
		struct face_g *fg;

d2131 2
d2134 2
a2135 1
		fu = NMG_INDEX_GETP( faceuse , trans_tbl , fus->fu );
d2137 11
a2147 1
		if( debug )
d2149 1
a2149 3
			rt_log( "fu x%x in s translates to fu x%x in s2\n" , fus->fu , fu );
			rt_log( "\tfu2 = x%x\n\tthick = %f\n\tpos = %d\n", fus->fu2, fus->thick, fus->pos );
		}
d2151 4
a2154 4
		if( !fu )
		{
			fus = fus_root;
			while( fus )
d2156 1
a2156 1
				struct shell *tmp_s1,*tmp_s2;
d2158 2
a2159 5
				tmp_s1 = fus->fu->s_p;
				if( fu )
					tmp_s2 = fu->s_p;
				else
					tmp_s2 = (struct shell *)NULL;
d2161 77
a2237 4
				fu = NMG_INDEX_GETP( faceuse , trans_tbl , fus->fu );
				rt_log( "fus_fu=x%x, orientation = %d, shell=x%x, fu2 = x%x, pos= %d, thick = %f, fu = x%x, shell = x%x\n" ,
					fus->fu , fus->fu->orientation , tmp_s1 , fus->fu2 , fus->pos , fus->thick , fu , tmp_s2 );
				fus = fus->next;
a2238 1
			rt_bomb( "NULL FU\n" );
d2240 2
d2243 2
a2244 3
		NMG_CK_FACEUSE( fu );
		fg = fu->f_p->fg_p;
		NMG_CK_FACE_G( fg );
d2246 36
a2281 2
		if( fu->f_p->flip )
			fg->N[3] += fus->thick;
d2283 5
a2287 1
			fg->N[3] -= fus->thick;
d2289 29
a2317 1
		fus = fus->next;
d2320 1
a2320 2
	/* rebound the region */
	nmg_rebound( m , &tol );
d2322 7
a2328 1
	nmg_shell_coplanar_face_merge( s2 , &tol , 0 );
d2330 3
a2332 2
	/* now reverse normals for entire shell */
	nmg_invert_shell( s2 , &tol );
d2334 2
a2335 1
	nmg_fix_parallel_faces( s2 , &tol );
d2337 1
a2337 2
	/* adjust all vertices */
	nmg_vertex_tabulate( &verts , &s2->l.magic );
d2339 2
a2340 1
	for( i=0 ; i<NMG_TBL_END( &verts ) ; i++ )
d2342 2
a2343 1
		struct vertex *v;
d2345 2
a2346 2
		v = (struct vertex *)NMG_TBL_GET( &verts , i );
		if( nmg_in_vert( v , &tol ) )
d2348 9
a2356 1
			rt_log( "Extrude_faces: Could not find new vertex for extruded face\n" );
d2358 19
d2378 1
a2378 1
	nmg_tbl( &verts , TBL_FREE , (long *)NULL );
d2380 26
a2405 1
	if( nmg_ck_closed_surf( s , &tol ) )
d2407 1
a2407 1
		if( !nmg_ck_closed_surf( s2 , &tol ) )
d2409 3
a2411 3
			rt_log( "Extrude_faces: shell is not closed, calling nmg_close_shell\n" );

			nmg_close_shell( s2 );
d2413 2
d2416 14
a2429 2
		/* now merge the inside and outside shells */
		nmg_js( s , s2 , &tol );
d2431 6
a2436 1
	else
d2438 7
a2444 1
		if( nmg_ck_closed_surf( s2 , &tol ) )
d2446 13
a2458 2
			rt_log( "Extrude_faces: one shell is closed, other isn't!!\n" );
			nmg_js( s , s2 , &tol );
d2460 10
a2469 1
		else
d2471 38
a2508 2
			/* connect the boundaries of the two open shells */
			nmg_open_shells_connect( s , s2 , trans_tbl , &tol );
d2512 59
a2570 1
	rt_free( (char *)trans_tbl , "Extrude_faces: trans_tbl" );
d2579 1
d2581 1
d2587 4
a2590 1
	rt_log( "make_nmg_objects:\n\tfuse vertices\n" );
d2592 4
a2595 1
	/* first fuse vertices in model */
a2609 2
	rt_log( "\tglue faces\n" );

a2611 2
	rt_log( "\tfix normals\n" );

d2617 3
d2621 8
a2628 2
		Extrude_faces();
	}
d2630 2
a2631 4
	/* fuse vertices in model again */
	if( debug )
		rt_log( "\tfuse vertices again\n" );
	(void)nmg_model_vertex_fuse( m , &tol );
d2633 7
a2639 1
	nmg_tbl( &faces , TBL_RST , (long *)NULL );
d2641 1
a2641 3
	for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
	{
		NMG_CK_FACEUSE( fu );
d2643 3
a2645 2
		if( fu->orientation != OT_SAME )
			continue;
d2647 2
a2648 2
		nmg_tbl( &faces , TBL_INS , (long *)fu );
	}
d2650 2
a2651 3
	if( debug )
		rt_log( "\tglue faces again\n" );
	nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ) );
d2653 7
d2662 2
a2663 3
	if( debug )
		rt_log( "\tcoplanr face merge\n" );
	nmg_shell_coplanar_face_merge( s , &tol , 0 );
d2665 3
a2667 3
	if( debug )
		rt_log( "\tsimplify shell\n" );
	nmg_simplify_shell( s );
d2669 5
a2673 1
	/* recompute the bounding boxes */
d2675 1
a2675 2
		rt_log( "\tcaclulate bounding box\n" );
	nmg_region_a( s->r_p , &tol );
d2677 3
d2681 1
a2681 1
		nmg_pr_s_briefly( s , (char *)NULL );
d2683 2
d2687 10
a2696 1
	mk_nmg( fdout , name , m );
d2698 3
a2700 1
	nmg_km( m );
d2702 2
d2705 2
a2716 1

d2719 14
d2746 1
d2752 1
a2752 1
	if( !pass )
a3317 66
do_tri()
{
	int element_id;
	int pt1,pt2,pt3;
	fastf_t thick;
	int pos;

	if( debug )
		rt_log( "do_tri: %s\n" , line );

	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );

	if( !nmgs )
		nmgs = element_id;

	if( !pass )
		return;

	strncpy( field , &line[24] , 8 );
	pt1 = atoi( field );

	strncpy( field , &line[32] , 8 );
	pt2 = atoi( field );

	strncpy( field , &line[40] , 8 );
	pt3 = atoi( field );

	if( pt1 == pt2 || pt2 == pt3 || pt1 == pt3 )
	{
		rt_log( "do_tri: ignoring degenerate CTRI element\n" );
		rt_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
		return;
	}

	if( mode == PLATE_MODE )
	{
		strncpy( field , &line[56] , 8 );
		thick = atof( field ) * 25.4;
		if( thick <= 0.0 )
		{
			rt_log( "do_tri: illegal thickness (%f), skipping CTRI element\n" , thick );
			rt_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
			return;
		}

		strncpy( field , &line[64] , 8 );
		pos = atoi( field );

		if( pos == 0 )	/* use default */
			pos = POS_FRONT;

		if( pos != POS_CENTER && pos != POS_FRONT )
		{
			rt_log( "do_tri: illegal postion parameter (%d), must be one or two\n" , pos );
			rt_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
			return;
		}
		if( debug )
			rt_log( "\tplate mode: thickness = %f\n" , thick );
	}

	make_fast_fu( pt1 , pt2 , pt3 , element_id , thick , pos );
}

void
d3332 1
a3332 1
		rt_log( "make_fast_fu: ( %f %f %f ) - ( %f %f %f ) - ( %f %f %f )\n" ,
d3375 1
d3402 66
d3478 3
d3503 1
a3503 1
		if( thick < 0.0 )
d3550 1
d3553 75
a3627 3
			make_nmg_objects();
			make_cline_regions();
			make_comp_group();
d3774 1
a3774 1
	if( nmg_extrude_shell( s1 , thick , 0 , &tol ) == (struct shell *)NULL )
d3896 1
d3989 3
a3991 2
	if( debug )
		rt_log( "\n\nProcess_inmput( pass = %d )\n" , pass_number );
d4057 8
a4064 1
	while( (c=getopt( argc , argv , "dw" ) ) != EOF )
d4074 21
d4131 2
d4136 1
a4136 6
	/* Initialze tolerance struct */
        tol.magic = RT_TOL_MAGIC;
        tol.dist = 0.005;
        tol.dist_sq = tol.dist * tol.dist;
        tol.perp = 1e-6;
        tol.para = 1 - tol.perp;
d4151 4
d4162 2
@


1.4
log
@Working version without CHEX2 elements (CHEX1 converts to NMG's)
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/fast4-g.c,v 1.3 94/04/18 14:06:20 jra Exp Locker: jra $";
d41 2
d52 2
a53 2
static int	group_id;		/* Group identification number from SECTION card */
static int	comp_id;		/* Component identification number from SECTION card */
d62 2
d72 1
d76 3
d196 234
d438 3
d907 3
d998 3
d1053 3
d1070 3
d1126 3
d1231 3
d1336 3
d1621 1
d1623 3
d1629 1
d1632 2
a1633 1
	for( RT_LIST_FOR( r1 , nmgregion , &m->r_hd ) )
d1635 4
a1638 1
		struct shell *s1;
d1640 1
a1640 1
		NMG_CK_REGION( r1 );
d1642 5
a1646 2
		/* Calculate center of shell */
		for( RT_LIST_FOR( s1 , shell , &r1->s_hd ) )
d1648 3
a1650 4
			struct vertex *v;
			point_t shell_center;
			struct faceuse *fu;
			int i;
d1652 1
a1652 1
			NMG_CK_SHELL( s1 );
d1654 1
a1654 1
			VSET( shell_center , 0.0 , 0.0 , 0.0 );
d1656 8
a1663 1
			nmg_vertex_tabulate( &verts , &s1->l.magic );
d1665 1
a1665 5
			for( i=0 ; i<NMG_TBL_END( &verts ) ; i++ )
			{
				v = (struct vertex *)NMG_TBL_GET( &verts , i );
				VADD2( shell_center , shell_center , v->vg_p->coord );
			}
d1667 2
a1668 1
			VSCALE( shell_center , shell_center , (fastf_t)(NMG_TBL_END( &verts ) ) );
d1670 5
a1674 1
			nmg_tbl( &verts , TBL_RST , (long *)NULL );
d1676 1
a1676 8
			/* check if outward normal points away from center */
			for( RT_LIST_FOR( fu , faceuse , &s1->fu_hd ) )
			{
				vect_t norm;
				vect_t to_center;
				struct loopuse *lu;
				struct edgeuse *eu;
				fastf_t dot;
d1678 1
a1678 1
				NMG_CK_FACEUSE( fu );
d1680 1
a1680 2
				if( fu->orientation != OT_SAME )
					continue;
d1682 6
a1687 5
				NMG_GET_FU_NORMAL( norm , fu );
				lu = RT_LIST_FIRST( loopuse , &fu->lu_hd );
				NMG_CK_LOOPUSE( lu );
				eu = RT_LIST_FIRST( edgeuse , &lu->down_hd );
				NMG_CK_EDGEUSE( eu );
d1689 8
a1696 1
				v = eu->vu_p->v_p;
d1698 4
a1701 1
				NMG_CK_VERTEX( v );
d1703 1
a1703 1
				VSUB2( to_center , shell_center , v->vg_p->coord )
d1705 5
a1709 6
				dot = VDOT( to_center , norm );
				if( RT_VECT_ARE_PERP( dot , &tol ) )
				{
					/* shell center is on face, probably only one face */
					continue;
				}
d1711 3
a1713 6
				if( dot > 0.0 )
				{
					/* outward normal points inward */
				}
			}
		}
d1727 3
d1750 7
d1771 1
a1771 1
					fg->N[3] -= fus->thick;
d1773 1
a1773 1
					fg->N[3] += fus->thick;
d1779 5
d1785 1
a1785 1
		nmg_vertex_tabulate( &verts , &s2->l.magic );
d1787 2
d1804 2
d1809 3
d1819 2
d1822 28
d1862 5
d1870 2
d1912 2
d1928 2
d1945 2
d1949 2
d1954 3
d1958 1
d1961 2
d1977 2
d1983 3
d1987 2
a1988 1
	nmg_shell_coplanar_face_merge( s , &tol , 0 );
d1992 2
d1996 2
a1997 1
	nmg_pr_s_briefly( s , (char *)NULL );
d2082 3
d2536 3
d2610 3
d2661 2
d2682 4
d2697 3
d2708 3
d2717 1
a2717 1
	if( area < 0.0 )
d2824 3
d2831 2
d2837 1
a2837 1
		if( final ) /* The ENDATA card has been found */
d2879 112
d2994 1
d2996 1
d3002 1
a3006 3
	if( !nmgs )
		nmgs = element_id;

d3053 11
d3066 2
a3088 1
	}
d3090 2
a3091 3
	for( i=0 ; i<NHEX_FACES ; i++ )
		make_fast_fu( pts[hex_faces[i][0]] , pts[hex_faces[i][1]] , pts[hex_faces[i][2]] ,
			element_id , thick , pos );
d3093 19
d3121 3
d3177 12
a3188 1
	/* XXX Need some code here */
d3196 3
d3249 5
a3253 2
	rt_log( "At pass %d:\n" , pass );
	List_names();
d3261 1
d3263 1
a3263 1
	if( argc != 3 )
d3265 13
a3277 2
		rt_log( "Usage: %s fastgen4_file brlcad_file.g\n" , argv[0] );
		exit( 1 );
d3280 4
a3283 1
	if( (fdin=fopen( argv[1] , "r" )) == (FILE *)NULL )
d3285 1
a3285 1
		rt_log( "Cannot open FASTGEN4 file (%s)\n" , argv[1] );
d3290 1
a3290 1
	if( (fdout=fopen( argv[2] , "w" )) == (FILE *)NULL )
d3292 1
a3292 1
		rt_log( "Cannot open file for output (%s)\n" , argv[2] );
d3320 2
d3337 2
a3338 1
	List_holes();
@


1.3
log
@Working version without Surface entities
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/fast4-g.c,v 1.2 94/04/15 16:10:03 jra Exp Locker: jra $";
a46 1
static point_t	*grid_pts;		/* Points from GRID cards */
d59 3
a61 2
static struct cline	*cline_last_ptr; /* Pointer to last element in linked list of clines */
static struct wmember group_head[11];	/* Lists of regions for groups */
d63 5
d69 3
d82 3
d98 1
d121 16
d150 4
a153 1
	int element_id;
d156 1
a156 1
} *sect_name_root,*model_name_root;
d173 14
d208 1
a208 1
				ptr = model_name_root;
a274 28
Free_tree()
{
	struct name_tree *ptr;
	struct name_tree *tmp_ptr;

	nmg_tbl( &stack , TBL_RST , (long *)NULL );

	ptr = sect_name_root;
	while( 1 )
	{
		while( ptr )
		{
			PUSH( ptr );
			ptr = ptr->nleft;
		}
		POP( name_tree , ptr );
		if( !ptr )
			break;

		tmp_ptr = ptr;
		ptr = ptr->nright;
		rt_free( (char *)tmp_ptr , "Free_tree: ptr" );
	}

	sect_name_root = (struct name_tree *)NULL;
}

void
d281 2
a282 2
	rt_log( "\nNames for current section in alphabetical order:\n" );
	ptr = sect_name_root;
a287 17
			ptr = ptr->nleft;
		}
		POP( name_tree , ptr );
		if( !ptr )
			break;

		rt_log( "%s %d %d\n" , ptr->name , ptr->region_id , ptr->element_id );
		ptr = ptr->nright;
	}

	rt_log( "\nNames for current section in ident order:\n" );
	ptr = sect_name_root;
	while( 1 )
	{
		while( ptr )
		{
			PUSH( ptr );
d298 2
a299 2
	rt_log( "\tAlphabetical list of all names used in this model:\n" );
	ptr = model_name_root;
a596 8
Delete_name_everywhere( name )
char *name;
{
	Delete_name( sect_name_root , name );
	Delete_name( model_name_root , name );
}

void
a657 1
	struct name_tree *nptr_sect,*rptr_sect;
d662 2
a663 2
	rptr_model = Search_ident( model_name_root , reg_id , el_id , &foundr );
	nptr_model = Search_names( model_name_root , name , &foundn );
a675 65
	/* Add to tree for this section */
	new_ptr = (struct name_tree *)rt_malloc( sizeof( struct name_tree ) , "Insert_region_name: new_ptr" );
	new_ptr->rleft = (struct name_tree *)NULL;
	new_ptr->rright = (struct name_tree *)NULL;
	new_ptr->nleft = (struct name_tree *)NULL;
	new_ptr->nright = (struct name_tree *)NULL;
	new_ptr->region_id = reg_id;
	new_ptr->element_id = el_id;
	strncpy( new_ptr->name , name , NAMESIZE+1 );

	if( !sect_name_root )
		sect_name_root = new_ptr;
	else
	{
		rptr_sect = Search_ident( sect_name_root , reg_id , el_id , &foundr );
		nptr_sect = Search_names( sect_name_root , name , &foundn );

		diff = strncmp( name , nptr_sect->name , NAMESIZE );

		if( diff > 0 )
		{
			if( nptr_sect->nright )
			{
				rt_log( "Insert_region_name: nptr_sect->nright not null\n" );
				rt_bomb( "\tCannot insert new node\n" );
			}
			nptr_sect->nright = new_ptr;
		}
		else
		{
			if( nptr_sect->nleft )
			{
				rt_log( "Insert_region_name( %s, reg_id=%d, el_id=%d: nptr_sect->nleft not null\n" , name , reg_id , el_id );
				List_names();
				rt_bomb( "\tCannot insert new node\n" );
			}
			nptr_sect->nleft = new_ptr;
		}


		diff = reg_id - rptr_sect->region_id;

		if( diff == 0 )
			diff = el_id - rptr_sect->element_id;

		if( diff > 0 )
		{
			if( rptr_sect->rright )
			{
				rt_log( "Insert_region_name: rptr_sect->rright not null\n" );
				rt_bomb( "\tCannot insert new node\n" );
			}
			rptr_sect->rright = new_ptr;
		}
		else
		{
			if( rptr_sect->rleft )
			{
				rt_log( "Insert_region_name: rptr_sect->rleft not null\n" );
				rt_bomb( "\tCannot insert new node\n" );
			}
			rptr_sect->rleft = new_ptr;
		}
	}

d686 2
a687 2
	if( !model_name_root )
		model_name_root = new_ptr;
d750 1
a750 1
	ptr = Search_ident( model_name_root , reg_id , el_id , &found );
d769 1
a769 1
	ptr = sect_name_root;
d781 1
a781 1
		if( ptr->element_id )
d802 1
a802 1
			Insert_name( &model_name_root , name );
d940 1
a940 1
	ptr = Search_names( model_name_root , name , &found );
d952 1
a952 1
		ptr = Search_names( model_name_root , name , &found );
d1005 1
a1005 1
	Insert_name( &model_name_root , name );
d1054 1
a1054 1
		grid_pts = (point_t *)rt_realloc( (char *)grid_pts , grid_size * sizeof( point_t ) , "fast4-g: grid_pts" );
d1057 3
a1059 1
	VSET( grid_pts[grid_no] , x*25.4 , y*25.4 , z*25.4 );
a1082 1

d1127 2
a1128 2
			Insert_name( &model_name_root , name );
			mk_sph( fdout , name , grid_pts[pt_no] , sph_radius );
d1142 2
a1143 2
				Insert_name( &model_name_root , name );
				mk_sph( fdout , name , grid_pts[pt_no] , sph_inner_radius );
d1183 1
a1183 1
				Delete_name_everywhere( bad_name );
d1308 1
a1308 1
	mk_sph( fdout , name , grid_pts[center_pt] , radius );
d1325 1
a1325 1
	mk_sph( fdout , name , grid_pts[center_pt] , inner_radius );
a1338 1
/*	cleanup from previous component and start a new one */
d1340 3
a1342 2
do_section( final )
int final;
d1344 1
d1346 16
a1361 1
	if( pass )
d1363 6
a1368 2
		make_cline_regions();
		if( final )
d1370 59
a1428 3
			make_comp_group();
			List_names();
			Free_tree();
d1432 17
a1448 1
	if( !final )
d1450 7
a1456 2
		strncpy( field , &line[8] , 8 );
		group_id = atoi( field );
d1458 10
a1467 2
		strncpy( field , &line[16] , 8 );
		comp_id = atoi( field );
d1469 20
a1488 1
		if( comp_id > 999 )
d1490 7
a1496 2
			rt_log( "Illegal component id number %d, changed to 999\n" , comp_id );
			comp_id = 999;
d1498 2
d1501 1
a1501 1
		region_id = group_id * 1000 + comp_id;
d1503 35
a1537 3
		strncpy( field , &line[24] , 8 );
		mode = atoi( field );
		if( mode != 1 && mode != 2 )
d1539 1
a1539 3
			rt_log( "Illegal mode (%d) for group %d component %d, using volume mode\n",
				mode, group_id, comp_id );
			mode = 2;
d1541 2
d1544 11
a1554 2
		if( pass )
			name_name[0] = '\0';
d1556 13
d1572 97
d1757 1
a1757 1
	VSUB2( height , grid_pts[pt2] , grid_pts[pt1] );
d1760 1
a1760 1
	mk_rcc( fdout , name , grid_pts[pt1] , height , radius );
d1772 1
a1772 1
		mk_rcc( fdout , name , grid_pts[pt1] , height , radius-thick );
d1897 1
a1897 1
	VSUB2( height , grid_pts[pt2] , grid_pts[pt1] );
d1899 1
a1899 1
	mk_trc_h( fdout , outer_name , grid_pts[pt1] , height , r1 , r2 );
d1922 1
a1922 1
			VMOVE( base , grid_pts[pt1] );
d1927 1
a1927 1
			VJOIN1( base , grid_pts[pt1] , thick , height_dir );
d1937 1
a1937 1
			VJOIN1( base , grid_pts[pt1] , dist_to_new_base , height_dir );
d1943 1
a1943 1
			VMOVE( top , grid_pts[pt2] );
d1948 1
a1948 1
			VJOIN1( top , grid_pts[pt2] , -thick , height_dir );
d1958 1
a1958 1
			VJOIN1( top , grid_pts[pt1] , dist_to_new_top , height );
d2083 1
a2083 1
	VSUB2( height , grid_pts[pt2] , grid_pts[pt1] );
d2086 1
a2086 1
	mk_trc_h( fdout , name , grid_pts[pt1] , height , ro1 , ro2 );
d2092 1
a2092 1
	mk_trc_h( fdout , name , grid_pts[pt1] , height , ri1 , ri2 );
d2218 2
d2231 413
d2654 1
d2676 1
a2676 1
			rt_log( "\tchex1\n" );
d2678 1
a2678 1
			rt_log( "\tchex2\n" );
d2680 1
a2680 1
			rt_log( "\tctri\n" );
d2682 1
a2682 1
			rt_log( "\tcquad\n" );
d2729 1
a2729 1
	grid_pts = (point_t *)rt_malloc( grid_size * sizeof( point_t ) , "fast4-g: grid_pts" );
d2734 1
a2734 2
	sect_name_root = (struct name_tree *)NULL;
	model_name_root = (struct name_tree *)NULL;
d2738 2
d2742 9
@


1.2
log
@Converted to a two pass process inorder to have all region names available
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/fast4-g.c,v 1.1 94/04/15 14:41:39 jra Exp Locker: jra $";
d92 1
a92 1
				char name[NAMESIZE]; \
d404 1
a404 1
Insert_name( root , name )
d408 201
d614 1
a614 1
	ptr = Search_names( root , name , &found );
d624 1
a624 2
	strncpy( new_ptr->name , name , NAMESIZE );
	new_ptr->name[NAMESIZE] = '\0';
d632 1
a632 1
	if( !root )
d634 1
a634 1
		root = new_ptr;
d693 1
a693 2
	strncpy( new_ptr->name , name , NAMESIZE );
	new_ptr->name[NAMESIZE] = '\0';
d717 2
a718 1
				rt_log( "Insert_region_name: nptr_sect->nleft not null\n" );
d758 1
a758 2
	strncpy( new_ptr->name , name , NAMESIZE );
	new_ptr->name[NAMESIZE] = '\0';
d812 20
d855 1
a855 1
		if( mk_addmember( ptr->name , &g_head , WMOP_UNION ) == (struct wmember *)NULL )
d857 5
a861 2
			rt_log( "make_comp_group: Could not add %s to group for ident %d\n" , ptr->name , ptr->region_id );
			break;
d868 4
a871 2
		if( name_name[0] )
			strcpy( name , name_name );
d876 1
a876 1
			Insert_name( model_name_root , name );
d894 1
a894 1
		char name[NAMESIZE];
d989 1
a989 1
		strncpy( name_name , tmp_name , NAMESIZE );
d991 1
a991 1
		strncpy( name_name , &tmp_name[len-NAMESIZE] , NAMESIZE );
d995 1
a995 1
	Insert_name( model_name_root , name_name );
a999 21
char *
find_region_name( g_id , c_id , el_id , type )
int g_id;
int c_id;
int el_id;
char type;
{
	struct name_tree *ptr;
	int reg_id;
	int found;

	reg_id = g_id * 1000 + c_id;

	ptr = Search_ident( model_name_root , reg_id , el_id , &found );

	if( found )
		return( ptr->name );
	else
		return( (char *)NULL );
}

d1045 1
a1045 1
	tmp_name = find_region_name( g_id , c_id , element_id , type );
d1051 1
a1051 1
		strncpy( name , tmp_name , NAMESIZE );
d1057 1
a1057 1
		strncpy( name , name_name , NAMESIZE );
d1079 1
a1079 1
	Insert_name( model_name_root , name );
d1142 1
a1142 1
	char name[NAMESIZE];
d1200 1
a1200 1
			Insert_name( model_name_root , name );
d1215 1
a1215 1
				Insert_name( model_name_root , name );
d1247 3
d1251 8
d1344 1
a1344 1
	char name[NAMESIZE];
d1421 6
a1426 3
		make_comp_group();
		List_names();
		Free_tree();
d1454 2
a1455 1
		name_name[0] = '\0';
d1505 1
a1505 1
	char name[NAMESIZE];
a1509 6
	if( !pass )
	{
		make_region_name( name , group_id , comp_id , element_id , CLINE );
		return;
	}

d1512 1
a1512 1
	if( pt1 < 1 || pt1 > max_grid_no )
d1521 1
a1521 1
	if( pt2 < 1 || pt2 > max_grid_no )
d1535 7
d1946 1
a1946 1
do_hole()
d1985 1
a1985 1
			list_ptr->next = (struct hole_list *)rt_malloc( sizeof( struct hole_list ) , "do_hole: list_ptr" );
d1990 1
a1990 1
			list_ptr = (struct hole_list *)rt_malloc( sizeof( struct hole_list ) , "do_hole: list_ptr" );
d2037 1
a2037 1
			do_hole();
d2039 1
a2039 1
			rt_log( "\twall\n" );
d2072 3
@


1.1
log
@Initial revision
@
text
@d24 1
a24 1
static char RCSid[] = "$Header: /m/cad/conv/RCS/tankill-g.c,v 1.6 94/03/18 12:47:30 jra Exp $";
d59 1
d716 3
d845 3
a847 2
		rt_log( "make_region_name: Name for region with g_id=%d, c_id=%d, el_id=%d, and type %c already exists (%s)\n",
			g_id, c_id, element_id, type , tmp_name );
d901 3
d1136 6
d1204 7
a1210 4
	make_cline_regions();
	make_comp_group();
	List_names();
	Free_tree();
d1244 3
a1247 1

d1292 6
d1368 13
d1401 1
a1401 1
		rt_bomb( "CCONE2\n" );
d1573 13
d1736 3
d1800 55
d1900 1
a1900 2
	while( getline() )
	{
d1902 3
a1904 38
		if( !strncmp( line , "VEHICLE" , 7 ) )
			do_vehicle();
		else if( !strncmp( line , "HOLE" , 4 ) )
			do_hole();
		else if( !strncmp( line , "WALL" , 4 ) )
			rt_log( "\twall\n" );
		else if( !strncmp( line , "SECTION" , 7 ) )
			do_section( 0 );
		else if( !strncmp( line , "$NAME" , 5 ) )
			do_name();
		else if( !strncmp( line , "$COMMENT" , 8 ) )
			;
		else if( !strncmp( line , "GRID" , 4 ) )
			do_grid();
		else if( !strncmp( line , "CLINE" , 5 ) )
			do_cline();
		else if( !strncmp( line , "CHEX1" , 5 ) )
			rt_log( "\tchex1\n" );
		else if( !strncmp( line , "CHEX2" , 5 ) )
			rt_log( "\tchex2\n" );
		else if( !strncmp( line , "CTRI" , 4 ) )
			rt_log( "\tctri\n" );
		else if( !strncmp( line , "CQUAD" , 5 ) )
			rt_log( "\tcquad\n" );
		else if( !strncmp( line , "CCONE1" , 6 ) )
			do_ccone1();
		else if( !strncmp( line , "CCONE2" , 6 ) )
			do_ccone2();
		else if( !strncmp( line , "CSPHERE" , 7 ) )
			do_sphere();
		else if( !strncmp( line , "ENDDATA" , 7 ) )
		{
			do_section( 1 );
			break;
		}
		else
			rt_log( "ERROR: skipping unrecognized data type\n%s\n" , line );
	}
@
