head	14.5;
access;
symbols
	rel-7-10-4:14.5
	STABLE:14.5.0.2
	stable-branch:14.1
	rel-7-10-2:14.5
	rel-7-10-0:14.4
	rel-7-8-4:14.3
	rel-7-8-2:14.3
	rel-7-8-0:14.3
	trimnurbs-branch:14.3.0.2
	help:14.3
	temp_tag:14.3
	bobWinPort-20051223-freeze:14.2
	postmerge-20051223-bobWinPort:14.3
	premerge-20051223-bobWinPort:14.3
	rel-7-6-6:14.3
	rel-7-6-4:14.3
	rel-7-6-2:14.2
	rel-7-6-branch:14.2.0.6
	rel-7-6-0:14.2
	rel-7-4-2:14.2
	rel-7-4-branch:14.2.0.4
	bobWinPort:14.2.0.2
	rel-7-4-0:14.2
	rel-7-2-6:14.1
	rel-7-2-4:14.1
	rel-7-2-2:14.1
	rel-7-2-0:14.1
	rel-7-0-4:14.1
	rel-7-0-2:14.1
	rel-7-0-1:14.1
	opensource-post:14.1
	opensource-pre:1.3
	rel-7-0-branch:1.1.0.2
	rel-7-0:1.1;
locks; strict;
comment	@# @;


14.5
date	2007.06.20.05.08.28;	author poolio;	state Exp;
branches;
next	14.4;

14.4
date	2007.01.27.01.41.28;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2005.10.23.04.44.25;	author brlcad;	state Exp;
branches;
next	14.2;

14.2
date	2005.07.06.21.33.58;	author dtremenak;	state Exp;
branches
	14.2.6.1;
next	14.1;

14.1
date	2004.11.16.19.42.08;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.12.23.53.27;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.06.01.59.34;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.18.21.18.32;	author morrison;	state Exp;
branches;
next	;

14.2.6.1
date	2005.11.13.13.46.08;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.5
log
@CVS moved from cvs.sf.net to brlcad.cvs.sf.net
@
text
@BRL-CAD Concurrent Versions System Policy and Guidelines
========================================================

The document includes a set of requirements and recommended procedures
for how to effectively use CVS with this project.  Included are
details on checking code in and out, effective use of commit messages,
tag naming conventions, branch management, making releases, and more.
Basic knowledge of CVS, its capabilities, and to a lesser extent its
limitations are beyond the scope of this document.  See the CVS
website and the "References" section for more information.  That said,
the following general rules should always be adhered to:

1. Code committed against HEAD should at least be tested and compile
   for the developer committing changes.  "Don't break it."

2. There is a STABLE branch that may only have code committed against
   it that a) compiles on all relevant platforms, b) does not
   detrimentally degrade performance, and c) runs correctly passing
   available validation tests.

3. Branches should be used for experimental work that would otherwise
   leave HEAD in an inconsistent, non-compiling, or untestable state.
   Branches are not merged into HEAD until the code has been tested
   for correct and proper functionality.

4. Commit and update frequently.  Large or complicated changes should
   be broken up into smaller succint commits as best possible to make
   reviewing easier.  Commit working code early and commit often.

5. Be consistent and informative.  Tags need to follow a consistent
   naming convention.  Commit messages need to be informative.  Source
   code changes should follow existing style and be usefully
   commented.


TABLE OF CONTENTS
-----------------
    Introduction
    Table of Contents
    Overview
    Checking out sources
	from HEAD
	from STABLE
	from a branch/revision
    Checking in sources
	commit messages
	to HEAD
	to STABLE
	to a branch/revision
    Tag naming convention
	for releases
	for branches
    Making a release
	creating a maintenance branch
	applying release patches
    Merging a branch
	merging a branch into HEAD
	merging HEAD into a branch
    Making a branch
    Usage Tips
    References


OVERVIEW
--------

    Code organizational sanity and consistency are of paramount
    importance.  As CVS can both help and hinder efforts to keep the
    sources organized, the policy and guidelines outlined herein
    overview the manner in which CVS should be used with this project.

    This CVS policy and guidelines document should be used in
    combination with a developer's guide that covers other aspects of
    code contributions and developer behavior such as how and where to
    provide patches, what coding styles should be used, and how to
    make releases.  Likewise, exact semantics of testing policy,
    requirements for migrating code from HEAD to STABLE, basic CVS
    usage, and release policy are outside the scope of this document.

    The intent of this document is to cover the broad aspects of how
    CVS is to be organized and used.  This includes branch management,
    tag naming conventions, checking sources in and out, and other
    relevent usage policy.

    CVS branches should be used to separate out the various types of
    source code revisions.  These include:

	1) current or "active" sources
	2) stable sources
	3) releases
	4) experimental sources

    The CVS HEAD is for active development.  A separate STABLE branch
    exists to hold a revision of the sources that is validated and
    tested across platforms.  Releases should only made off of stable
    revisions of the source code.  When a release is made, a
    maintenance branch may and should exist for making patch releases.
    Finally, various experimental and developer undertakings that may
    benefit by being isolated from changes to HEAD or STABLE, or would
    likewise be distruptive to normal HEAD functionality, may live on
    a branch of their own.

    It's very important that the main CVS HEAD revision be a "mostly"
    stable code base so that at any given time users may download the
    latest sources, get the source code to compile with minimal
    effort, and have the core components mostly function as expected.
    See the "Checking in sources to HEAD" section for more details.

    Some users and developers will need from time to time to obtain a
    relatively recent version of the sources that is certain or at
    least expected to "work".  This is what the STABLE branch is for.
    See the "Checking in sources to STABLE" section for more
    information.


CHECKING OUT SOURCES
--------------------

    There are two basic ways to check out the sources: anonymously or
    as a developer.  Developers have full read-write access to the
    source code.  Anonymous users have read-only access; and the
    version of the sources checked out may actually lag the most
    recent commits by several hours.

    Regardless of whether the sources are being checked out by a
    developer or anonymously, CVS_RSH should be set to "ssh".

    Anonymous users will need to login first:

	cvs -d :pserver:anonymous@@brlcad.brlcad.cvs.sf.net:/cvsroot/brlcad login

    Once logged in, the access method for anonymous users will be via
    :pserver: (provide an empty password if prompted).  Developers
    will checkout using the default implicit :ext: method and will
    need to provide an authorized username.  Be sure to use the "-P"
    checkout option to remove (prune) empty directories.  The "-z9"
    global CVS option is encouraged to minimze network utilization.


    FROM HEAD:

    As anonymous:
	cvs -z9 -d :pserver:anonymous@@brlcad.cvs.sf.net:/cvsroot/brlcad checkout -P brlcad

    As a developer:
	cvs -z9 -d <username>@@brlcad.cvs.sf.net:/cvsroot/brlcad checkout -P brlcad


    FROM STABLE:

    Checking out from STABLE is like checking out from any specific
    revision or branch -- provide the tag name upon checkout:

    As anonymous:
	cvs -z9 -d :pserver:anonymous@@brlcad.cvs.sf.net:/cvsroot/brlcad checkout -P -r STABLE brlcad

    As a developer:
	cvs -z9 -d <username>@@brlcad.cvs.sf.net:/cvsroot/brlcad checkout -P -r STABLE brlcad


    FROM A BRANCH/REVISION:

    The process for checking out a given revision number is pretty
    much a matter of knowing which revision tag name is desired, and
    then checking out with that symbolic tag name:

    As anonymous:
	cvs -z9 -d :pserver:anonymous@@brlcad.cvs.sf.net:/cvsroot/brlcad checkout -P -r <tagname> brlcad

    As a developer:
	cvs -z9 -d <username>@@brlcad.cvs.sf.net:/cvsroot/brlcad checkout -P -r <tagname> brlcad

    If the tag names are not known, you can check out HEAD or STABLE
    and perform a "cvs log" on any file to see the known tag names:

	cd brlcad
	cvs status -v README

    Once you find the revision or branch tag name in question, you can
    "cvs update" to that revision:

	cvs -z9 update -r <tagname>

    See the CVS manual documentation for more information.


CHECKING IN SOURCES
-------------------

    Commit access is generally provided on a case-by-case basis as the
    need arises after careful consideration of the individual's
    ability to follow the project's coding style, follow this CVS
    commit policy, and work productively with the other developers.
    If you have to ask for commit access, you probably won't get it.
    So don't ask.  Provide patches and interact with the existing
    developers.

    If you are given commit access, you are expected to
    read and follow this policy and its guidelines as well as the
    developer's guide.


    COMMIT MESSAGES:

    When code is committed to CVS, a commit message should be provided
    that appropriately describes the change in a succinct and useful
    manner.  It's important to remember that CVS commit comments are
    stored per-file.  Care should be taken to not be vague,
    undescriptive, or ambiguous often tailoring commit messages to
    individual files even if the change was made as part of a larger
    modification.

    While the comments need to be descriptive and informative, they
    should also be as short and to the point as possible.  The CVS
    commit comments are not the appropriate place for legal
    disclaimers, usage documentation, extensive debugging details,
    business politics, or mini novels of who/what/when/where/why.

    They should be no more than a few lines long at most, normally
    only consisting of a short single-line statement.  CVS commit
    comments are for documenting changes so that other developers may
    derive a clue about what the change was without necessarily
    needing to look at the actual source differences.

    Instead of making generic statements about fixing or improving the
    source code, succinctly describe the change in a manner that may
    be useful for someone else reading the comment that is not
    familiar with the change.  If the changes are merely formatting or
    whitespace adjustments, a simple commit message of "ws" or "M-x
    indent-region" is generally understood and sufficient.

    If a file is being moved/renamed, the comment should include both
    where the file is moved from and where it was moved to in the
    message, e.g. "moved from librt/bool.c to src/librt/bool.c".


    TO HEAD:

    It's very important that the main CVS HEAD revision be a "mostly"
    stable code base so that at any given time users may download the
    latest source, get it to compile with minimal effort, and have the
    core components mostly function as expected.  HEAD is where active
    development takes places, so this necessarily means that there may
    be small windows of opportunity where the sources do not compile,
    but those should not persist.  Likewise, since the developers
    potentially and often have specific or relatively independent
    development efforts, the CVS commits of one developer should be
    made in a means that will have limited or understood impact on
    other developers.

    This minimally means that CVS commits need to at least work for
    the developer committing the changes.  If it's discovered that the
    changes break other major supported platforms, the broken state
    should not be allowed to linger.  Effort and arrangements need to
    be made to either resolve the problem promptly or the changes
    should be reverted.


    TO STABLE:

    Code being committed to STABLE require special attention and just
    a little more detail in their commit messages.

    Some users and developers will need from time to time to obtain a
    relatively recent version of the sources but a version that is
    certain or at least expected to "work".  This shall be known as
    the STABLE branch.  For code to make it to the STABLE branch, it
    needs to pass several criteria and commits should be well
    documented indicating the nature, purpose, and impact of the
    change.  These criteria include the following:

    a) Compiles -- The code must compile on all supported platforms.
       This generally requires coordination with other developers if
       access to other platforms is limited.

    b) Improves -- Without reasonable justification, the changes must
       not degrade performance, be inconsistent in style or behavior
       of the sources, or break support for existing functionality.

    c) Passes -- The changes must successfully pass any available
       validation tests.  If the tests are flawed or simply require
       modification, justification and explanation should be provided
       along with fixes to the tests before submitting code that would
       otherwise not pass validation.


    TO A BRANCH/REVISION:

    Checking in code to a branch other than STABLE generally do not
    necessarily need to follow the same requirements of compiling
    cleaning or "working" until those changes are merged back in to
    either STABLE or HEAD unless the branch is a release maintenance
    branch.  Release maintenance branches generally follow the same
    commit rules as checking into HEAD.

    As it's not possible to commit against a non-branch checkout (such
    as a release tag export like "rel-7-0"), changes to a revision
    that is otherwise immutable can still be made by performing a
    "diff" against a clean checkout of that same revision (unmodified)
    and then applying the patch to a maintenance branch or to the CVS
    HEAD.  See the "Applying release patches" under "Making a release"
    for examples.


TAG NAMING CONVENTIONS
----------------------
    <keyword>[-<revision>][-<date>][-<comment>]

    <keyword> ::= { rel, ansi, jra, sean, ppc, ... }

	The <keyword> is normally something short and concise.  For
	release tags, it is "rel".  Other branch keywords may indicate
	functionality, developers, etc.

    <revision> ::= <major>[-<minor>[-<patch>]]  (e.g., 6-0-2 and 5-2)

	The <revision> numbering convention is fairly standard and
	common practice:

	<major> is the major revision number and changes relatively
		infrequently.  Major releases contain significant
		architectural changes and are not generally backwards
		compatible with existing code or data to some extent.
		They may require data and/or code to be converted in
		order to upgrade.

	<minor> is the minor revision number a usually changes on a
		fairly regular basis.  As new features are added and
		releases are made, the minor revision number changes
		to reflect those additions.  Odd minor numbers
		indicate a developer revision.  Even minor numbers
		indicate a release revision.  Minor releases may or
		may not be backwards compatible.

	<patch> is the patch revision number and is used to make bug
		fixes on an as-needed basis.  These changes are not
		usually as extensively tested as minor and major
		releases, but they should always be backwards
		compatible.

    <date> := YYYYMMDD (e.g., 20021231)

	When creating tags, the date a tag is made is sometimes noted
	and useful or even recommended.  The format of the date is
	YYYYMMDD and should correspond to tag creation dates.  Branch
	and release tags should not include a date in the tag name.

    <comment>

	For branches the comment is "branch".  For releases, it is
	left blank.  For other miscellaneous tags, the comment is up
	to the person tagging.

    Note that hyphens (-) are used, not underscores.  Periods (.) are
    never used because they upset CVS's branch naming.

    Tag names (including branches) should be in lower case only.
    Upper case is reserved for HEAD and STABLE.

    Non-branch tags are used for 1) marking a release, 2) merging
    branches, and 3) miscellaneous tags (e.g., to remember a specific
    starting or stopping point).


    FOR RELEASES:

	Release tags are used to indicate a revision of the source
	code that was made publicly available.  It should match the
	sources released, bugs and all, so that proper and useful
	diffs may be made.  The format for release tags is:

	rel-<revision>

	    <revision> ::= <major>-<minor>[-<patch>]

	    The revision number should match the version reported by
	    the source code.

	Examples: rel-6-0 rel-7-2-5


    FOR BRANCHES:

	Branches are symbolic tags that are used to denote and allow
	separate isolated revisions of code.  The following format
	should be used for branch tags:

	<keyword>[-<revision>]-branch

	    <keyword> ::= describes the purpose of the branch.

	    If the branch is a maintenance branch, the keyword should
	    match the revision's keyword and revision.

	Examples: rel-7-0-branch ansi-branch photonmap-branch


    FORMAT FOR MERGES:

	When joining a branch that has a large set of changes into
	HEAD, there should be a tag before and after the merge.  When
	joining HEAD into a branch, tagging is optional. Joins into
	head should be tagged, though.

	On HEAD before the merge, use the following tag format:

	    premerge[-<revision>][-<date>]-<comment>

	    Example: premerge-20040404-ansi

	On HEAD after the merge, use the following tag format:

	    postmerge[-<revision>][-<date>]-<comment>

	    Example: postmerge-20040315-windows

	The <comment> should be a simple identifying keyword.  The
	branch keyword being merged suffices quite well.  A date is
	preferred.

	If development on a particular branch is considered "final",
	it should be marked with a "freeze" tag on the branch:

	    <keyword>[-<revision>][-<date>]-freeze

	    Example: windows-20040315-freeze

	If applying patches directly to the CVS HEAD where there is
	potential to need to revert the changes, using "pre" and
	"post" as the tag comment is appropriate.

	    <keyword>[-<revision>][-<date>]-pre
	    <keyword>[-<revision>][-<date>]-post

	    Examples: hartley-6-0-pre ctj-4-5-post offsite-5-3-pre


    FORMAT FOR MISCELLANEOUS TAGS:

	For everything else, the basic structure of the tags still
	applies.  Lower case, dash-separated, and hopefully succintly
	informative tag names should be used.  Dates are highly
	recommended as CVS tags are not associated by date, but rather
	to the individual revision of a file.

	<keyword>[-<revision>][-<date>][-<comment>]

    When in doubt, tag.  It's easy to remove or rename tags, but it
    can be rather complicated to create one after the fact.


MAKING A RELEASE
----------------

    Making a release is generally a matter of making sure that all
    desired code changes are committed and well tested.  Code
    committed to HEAD should be well tested by performing any
    validation steps required to migrate those changes to STABLE.
    Once HEAD is verified, it may be joined into STABLE, which should
    likewise be thoroughly tested.

    Once all the code is verified, the release should be tagged:

	cvs tag rel-<revision>

    Revision numbers should follow a numbering convention consistent
    with the developer guidelines.  Minor and patch revision numbers
    that are odd numbered are used to denote developer revisions of
    the source code.  Release tags should use even numbers for the
    minor and patch revision numbers.  See the "Tag naming convention"
    section for more details.


    CREATING A MAINTENANCE BRANCH:

    If minor maintenance is expected to continue or development on
    HEAD needs to continue in an incompatible manner, a maintenance
    branch should be made:

	cvs rtag -r rel-<revision> -b rel-<revision>-branch

    That will create a branch named rel-<revision>-branch anchored at
    the same revision of the sources as rel-<revision>.


    APPLYING RELEASE PATCHES:

    In general, unified diff patches should be requested from people
    providing patches whenever possible.  For people working with a
    cvs checkout, generating a diff is generally a simple matter of
    running:

	cvs diff -u > my.patch

    This will create a unified diff patch file called "my.patch" that
    is trivially applied to a checkout using the patch command:

	patch -p0 < my.patch

    Assuming there have not been overlapping/conflicting changes,
    patch should say on the first attempt that all chunks were
    successfully applied.  If not, there will be reject files that
    will have changes that need to be manually reviewed and resolved..

    Users who are perhaps working off of a source tarball instead of a
    CVS checkout can fairly easily generate a unified diff patch by
    comparing their modified tree against an unmodified source tree:

	diff -u brlcad brlcad.modified > my.patch

    In this example, brlcad is an unmodified top-level source
    directory and "brlcad.modified" is a top-level source directory
    that has been modified.  That same patch file may then be applied
    to a checkout and commited to CVS.

    If there is an active maintenance branch that a patch was started
    from, it is generally easier to apply the patch to the maintenance
    branch first and then join the maintenance branch into HEAD per
    the usual means to join branch changes into HEAD instead of
    merging directly into the CVS HEAD.  HEAD will have often changed
    too significantly and may result in patch being unable to resolve
    chunks.  See the patch manual documentation for more details.

    Failing any of the above, patches may also be applied manually.
    This is often even desireable to become more familiar with the
    changes being made providing an opportunity for a healthy peer
    review.


MERGING A BRANCH
----------------
    CVS branches can be both very useful or difficult.  Proper usage
    of branches generally requires a firm understanding of CVS
    otherwise complications and mistakes are bound to happen as there
    are several usage pitfalls.  Following the directions shown below
    should help avoid the pitfalls and assist in making effective use
    of a CVS branch.

    Regardless if the branch is a maintenance branch or the STABLE
    branch, the fundamental "action" in performing a merge is called a
    CVS join.  You can join code commited to one branch revision into
    another branch revision by passing the "-j" option to the cvs
    update command.  It's important to note that joins occur from code
    that is already committed.

    Once the code is joined, it may be committed to CVS.  If you have
    changes on a branch that have not yet been commited, they should
    first be commited before attempting the join.


    MERGING A BRANCH INTO HEAD:

    Merging branches in CVS is generally a matter of "joining" in the
    changes from one the branch revision into another branch revision.
    HEAD can itself be considered a branch.  If, for example, you have
    a maintenance branch named "rel-7-0-branch" that has had changes
    applied to it and you wish to apply those same changes to HEAD you
    would checkout HEAD:

	  cvs -z9 -d <CVSROOT> checkout -kk -P brlcad

    The join the changes from the desired branch:

	  cvs update -kk -dP
	  cvs tag premerge-<revision>-<date>-<comment>
	  cvs update -kk -dP -j rel-7-0-branch
	  [ resolve conflicts & test ]
	  cvs commit
	  cvs tag postmerge-<revision>-<date>-<comment>

    The comment should contain or be the keyword of the branch being
    merged in.  For example, "premerge-20040315-windows" indicates a
    merge that occured on March 15th, 2004, from the windows-branch.

    If there are any conflicts, they would of course need to be
    manually resolved.  Once any conflicts are resolved and the
    sources are tested for functionality, the changes could then be
    commited to HEAD.  Be careful to notice any file additions or
    deletions as CVS, generally speaking, will not manage those for
    you until they are committed.

    In both the checkout and the join update, the -kk flag was used to
    cause CVS to not expand the CVS variables such as \$Revision\$ and
    \$Id\$.  If those keyword variables are expanded, you're likely to
    have many conflicts depending on time-stamps.

    If the branch being checked in an extensive set of changes,
    testing is essential.  It is also a good idea to warn other
    developers of what you are planning to do.  You should indicate
    what parts of the system will be affected and coordinate in detail
    with other developers as appropriate.


    MERGING HEAD INTO A BRANCH:

    Merging changes from HEAD into a branch (such as STABLE) is not
    really any different than the scenario described for merging a
    branch into HEAD.  Again, HEAD itself can be simply considered a
    branch too.  For example with an existing branch checkout:

	cvs update -kk
	cvs update -kk -j HEAD
	[resolve conflicts & test ]
	cvs commit

    The important step to realize is that your working checkout needs
    to be the revision you want to join changes into.  When in doubt,
    commit all your changes to the appropriate branch, delete all your
    sources, and checkout fresh.  "cvs status README" will tell you
    what revision you have checked out.  It will be listed as a
    "Sticky Tag".


MAKING A BRANCH
---------------
    Making a branch is a matter of using the "-b" option when tagging.
    Branch tags are special symbolic CVS tags that allow for isolated
    changes and controlled merging of modifications.

    CASE 1: You have no checked out source code revision:

	If you want to use the latest sources on the CVS HEAD as the
	starting point for your branch:

	    cvs rtag -b <keyword>-branch brlcad
	    cvs checkout -r <keyword>-branch brlcad

	If you want to use some other tag as the starting point for
	your branch:

	    cvs rtag -b -r <tag> <keyword>-branch brlcad
	    cvs checkout -r <keyword>-branch brlcad

    CASE 2: You have a checked out revision with all changes committed
    and you want to tag it and start using it as a branch:

	cvs tag -b <keyword>-branch
	cvs update -dP -r <keyword>-branch

    CVS will denote the tag as a "sticky" tag to indicate which
    version is currently checked out.  You can verify this by using
    'cvs status', for example:

	cvs status README

    To see all tags that have been set for a particular file in
    addition to checkout status, use the "-v" status option:

	cvs status -v README

    or via the generally more detailed file log:

	cvs log README


USAGE TIPS
----------
    0) Checkout with the -P option to prune empty directories:

       cvs checkout -P brlcad

    1) Be sure to perform an "update -dP" to check for new directories
       from time to time and to prune empty ones.

       cvs update -dP

    2) Update and commit frequently.  Frequent updates are a good
       thing.  Perform them often to minimize conflicts.

    4) A convenient way to check what files have been modified when
       you are certain that you've not added files:

       cvs -q update | grep -v \?

       That performs a quiet update (the directory tree isn't output)
       and ignores lines that have a question mark (normally build
       files).

    3) To avoid having to specify the repository for a checkout, you
       can set your CVSROOT environment variable to the location of
       the repository:

       For anonymous users:
	   export CVSROOT=:pserver:anonymous@@brlcad.cvs.sf.net:/cvsroot/brlcad

       For developers with accounts:
	   export CVSROOT=<username>@@brlcad.cvs.sf.net:/cvsroot/brlcad

    5) CVS does not manage directories so care must be taken when
       creating new directories or moving things around.  Do NOT add
       directories that include non-static information as part of the
       directory name.  Examples include adding directories that
       include a version in their name (e.g. libtcl8), indicate age
       (e.g. newRt), or contain other volatile data.

    6) If you need to move a directory, rethink why and try not to.
       If you still need to move a directory, .. try to find another
       way to cope.  If you still REALLY need to move a directory, a
       little find scripting can make it easy.  In case you didn't get
       the hint DO NOT MOVE/RENAME DIRECTORIES unless there's a _very_
       good reason.  This implictly means that extra care and thought
       should be made when naming new directories to be added to the
       repository.

    7) It is possible to move directories using a little find
       scripting.  Assuming you've not got build files cluttering
       things up and are ready to simply move files to a new location
       in CVS, an otherwise complicated task becomes mostly simple
       with a few find scripts.  Here is an example where a directory
       ./foo/ is moved to a new location ./src/foo2/:

       cd foo
       # copy the files to their new home
       find . -type d -not -name CVS -exec mkdir -p ../src/foo2/{} \;
       find . -type f -not -regex '.*/CVS/.*' -exec cp -p {} ../src/foo2/{} \;
       cd ../src
       # add the new directories to cvs
       find foo2 -type d -not -name CVS -exec cvs add {} \;
       find foo2 -type f -not -regex '.*/CVS/.*' -exec cvs add {} \;
       # commit the new sources
       cvs commit -m "moved from foo to src/foo" foo2
       cd ..
       # delete the old source subtree
       find foo -type f -not -regex '.*/CVS/.*' -exec rm {} \;
       find foo -type d -not -name CVS -exec rm -f {} \; -exec cvs delete {} \;
       cvs commit -m "moved from foo to src/foo" foo
       cvs update -P foo

       If you don't have CVS keys set up and have too many files to
       move, each find script could be passed to xargs so that only a
       single password is prompted instead of one per file.  Since
       moving/renamed directories in CVS is "bad", though, that's left
       as an exercise to the reader.

    8) When renaming files, be sure to indicate both where the file
       was moved from and where it was moved to and/or the name before
       the move and the name after the move.  Do this both on
       committing the file deletion and on committing the file
       addition.  This way, people reading the file's log will know
       where to find the rest of the file's history.

    9) If experiencing trouble consolidating conflicts that involve
       CVS "$" variables, set the keyword sticky flag which will tell
       CVS to not perform the keyword variable expansions.  Perform a
       "cvs update -kk" and the conflicts should go away.

   10) Denote binary files as binary in CVS via the
       CVSROOT/cvswrappers administrative file or via the "-kb" option
       when adding files.  In the CVSROOT/cvswrappers file, the
       following line would denote files ending in ".pix" as binary:

       *.pix -k 'b'

       You can likewise denote arbitrary files as binary via the "-kb"
       option on commit:

       cvs add -kb new_file_name_here

       If the file has already been added to CVS, it may be
       administratively marked as a binary file after the fact using
       the "cvs admin" command:

       cvs admin -kb some_existing_file
       cvs update -A some_existing_file


REFERENCES
----------
    This CVS policy and guidelines document was in part derived off
    some of the principal ideas of other projects' usage of CVS such
    as the Linux Documentation Project, the XFree86 DRI project, Zope,
    FreeBSD, and AT&T's SML/NJ among others.

Version Management with CVS
https://www.cvshome.org/docs/manual/

CVS Best Practices
http://www.magic-cauldron.com/cm/cvs-bestpractices/index.html

XFree86 Direct Rendering Infrastructure CvsPolicy
http://dri.sourceforge.net/cgi-bin/moin.cgi/CvsPolicy
http://dri.sourceforge.net/doc/cvspolicy.txt

Zope
http://dev.zope.org/CVS/ZopeReleasePolicy

FreeBSD
http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/cvs-tags.html

AT&T SML/NJ
http://www.smlnj.org/DEV/policy.html
http://cm.bell-labs.com/cm/cs/what/smlnj/DEV/policy.html

---
This document was initially written in 2002 and later almost
completely rewritten in 2004 by Christopher Sean Morrison.
@


14.4
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d130 1
a130 1
	cvs -d :pserver:anonymous@@cvs.sf.net:/cvsroot/brlcad login
d143 1
a143 1
	cvs -z9 -d :pserver:anonymous@@cvs.sf.net:/cvsroot/brlcad checkout -P brlcad
d146 1
a146 1
	cvs -z9 -d <username>@@cvs.sf.net:/cvsroot/brlcad checkout -P brlcad
d155 1
a155 1
	cvs -z9 -d :pserver:anonymous@@cvs.sf.net:/cvsroot/brlcad checkout -P -r STABLE brlcad
d158 1
a158 1
	cvs -z9 -d <username>@@cvs.sf.net:/cvsroot/brlcad checkout -P -r STABLE brlcad
d168 1
a168 1
	cvs -z9 -d :pserver:anonymous@@cvs.sf.net:/cvsroot/brlcad checkout -P -r <tagname> brlcad
d171 1
a171 1
	cvs -z9 -d <username>@@cvs.sf.net:/cvsroot/brlcad checkout -P -r <tagname> brlcad
d684 1
a684 1
	   export CVSROOT=:pserver:anonymous@@cvs.sf.net:/cvsroot/brlcad
d687 1
a687 1
	   export CVSROOT=<username>@@cvs.sf.net:/cvsroot/brlcad
@


14.3
log
@trailing ws
@
text
@d46 1
a46 1
        commit messages
d143 1
a143 1
        cvs -z9 -d :pserver:anonymous@@cvs.sf.net:/cvsroot/brlcad checkout -P brlcad
d311 3
a313 3
        The <keyword> is normally something short and concise.  For
        release tags, it is "rel".  Other branch keywords may indicate
        functionality, developers, etc.
d317 2
a318 2
        The <revision> numbering convention is fairly standard and
        common practice:
d320 20
a339 20
        <major> is the major revision number and changes relatively
                infrequently.  Major releases contain significant
                architectural changes and are not generally backwards
                compatible with existing code or data to some extent.
                They may require data and/or code to be converted in
                order to upgrade.

        <minor> is the minor revision number a usually changes on a
                fairly regular basis.  As new features are added and
                releases are made, the minor revision number changes
                to reflect those additions.  Odd minor numbers
                indicate a developer revision.  Even minor numbers
                indicate a release revision.  Minor releases may or
                may not be backwards compatible.

        <patch> is the patch revision number and is used to make bug
                fixes on an as-needed basis.  These changes are not
                usually as extensively tested as minor and major
                releases, but they should always be backwards
                compatible.
d343 4
a346 4
        When creating tags, the date a tag is made is sometimes noted
        and useful or even recommended.  The format of the date is
        YYYYMMDD and should correspond to tag creation dates.  Branch
        and release tags should not include a date in the tag name.
d350 3
a352 3
        For branches the comment is "branch".  For releases, it is
        left blank.  For other miscellaneous tags, the comment is up
        to the person tagging.
d372 1
a372 1
        rel-<revision>
d384 1
a384 1
        Branches are symbolic tags that are used to denote and allow
d405 1
a405 1
        On HEAD before the merge, use the following tag format:
d407 1
a407 1
            premerge[-<revision>][-<date>]-<comment>
d411 1
a411 1
        On HEAD after the merge, use the following tag format:
d413 1
a413 1
            postmerge[-<revision>][-<date>]-<comment>
d446 1
a446 1
        <keyword>[-<revision>][-<date>][-<comment>]
d622 2
a623 2
        If you want to use the latest sources on the CVS HEAD as the
        starting point for your branch:
d625 2
a626 2
            cvs rtag -b <keyword>-branch brlcad
            cvs checkout -r <keyword>-branch brlcad
d628 2
a629 2
        If you want to use some other tag as the starting point for
        your branch:
d631 2
a632 2
            cvs rtag -b -r <tag> <keyword>-branch brlcad
            cvs checkout -r <keyword>-branch brlcad
d637 2
a638 2
        cvs tag -b <keyword>-branch
        cvs update -dP -r <keyword>-branch
d644 1
a644 1
        cvs status README
d649 1
a649 1
        cvs status -v README
d684 1
a684 1
           export CVSROOT=:pserver:anonymous@@cvs.sf.net:/cvsroot/brlcad
d687 1
a687 1
           export CVSROOT=<username>@@cvs.sf.net:/cvsroot/brlcad
@


14.2
log
@doc nitpicks - "it's" is not the possessive form, can't have a vast majority of two exclusive styles, typos
@
text
@d166 1
a166 1
    
d237 2
a238 2
    TO HEAD: 
    
d342 1
a342 1
        
d349 1
a349 1
        
d415 1
a415 1
	    Example: postmerge-20040315-windows 
d434 1
a434 1
	    
d445 1
a445 1
    
d586 1
a586 1
    
d784 1
a784 1
Zope 
d794 1
a794 1
--- 
@


14.2.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d166 1
a166 1

d237 2
a238 2
    TO HEAD:

d342 1
a342 1

d349 1
a349 1

d415 1
a415 1
	    Example: postmerge-20040315-windows
d434 1
a434 1

d445 1
a445 1

d586 1
a586 1

d784 1
a784 1
Zope
d794 1
a794 1
---
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d8 1
a8 1
Basic knowledge of CVS, it's capabilities, and to a lesser extent it's
d137 1
a137 1
    global CVS option is encouranged to minimze network utilization.
d199 1
a199 1
    read and follow this policy and it's guidelines as well as the
@


1.3
log
@after letting the major edits settle for a few days, a revisted review reveals several necessary changes.  of note are to checkout/update using -z9, the exact format of HEAD merge tags (was wrong), usage of status -v, fixed example of merging a branch, added example of merging HEAD into a branch, emphasis of checkout -P, binary flag on binary files, and a slew of engrish rewordings.
@
text
@@


1.2
log
@massive rewrite of the CVS policy and guidelines.  dealing with the existence of a STABLE branch is now integral, requirements to maintain separate development branches is removed for practicality, there is now a table of contents, much more information in general, and complete reorganization of sections.
@
text
@d7 5
a11 2
tag naming conventions, branch management, making releases , and more.
The following general rules should always be adhered to:
d13 1
a13 1
1. Code committed against HEAD should at least compile and be tested
d24 1
a24 1
   for correct proper functionality.
d26 3
a28 3
4. Commit and update frequently.  Infrequent commits result in
   conflicts and/or lengthy diffs and are complicated to review
   effectively.
d31 3
a33 1
   naming convention.  Commit messages need to be informative.
d69 2
a70 2
    sources organized, the policy and guidelines covered overview the
    manner in which CVS should be used with this project.
d72 12
a83 3
    Basic knowledge of CVS, it's capabilities, and to a lesser extent
    it's limitations are beyond the scope of this document.  See the
    CVS website and the "References" section for more information.
d85 2
a86 2
    That said, CVS branches should be used to separate out the various
    kinds of source code.  These include:
d95 1
a95 1
    tested across platforms.  Releases are only made off of stable
d97 5
a101 4
    maintenance branch may exist for making patch releases.  Finally,
    various experimental and developer undertakings that may benefit
    from being isolated from changes to HEAD or STABLE may live on a
    branch of their own as well.
d105 3
a107 3
    latest source, get it to compile with minimal effort, and have the
    core components mostly function as expected.  See the "Checking in
    sources to HEAD" section for more details.
d110 4
a113 4
    relatively recent version of the sources but a version that is
    certain or at least expected to "work".  This is what the STABLE
    branch is for.  See the "Checking in sources to STABLE" section
    for more information.
d121 6
a126 6
    latest sources.  Anonymous users have read-only access and the
    version of the checkout sources may lag the actual latest by
    several hours.  For either access method, CVS_RSH should be set to
    "ssh".  As BRL-CAD has a long complicated history with several
    directory reorganizations, be sure to use the "-P" prune option
    regardless of the checkout method.
d132 6
a137 4
    Once logged in, the CVSROOT for anonymous users will be via CVS's
    :pserver: method (provide an empty password if prompted).
    Developers will checkout using the default implicit :ext: method,
    and provide your username.
d151 1
a151 1
    Checking out from stable is like checking out from any specific
d165 1
a165 1
    then checking out with that tag name:
d177 1
a177 1
	cvs log README
d189 12
a200 8
    Commit access is generally given consideration on a case-by-case
    basis after careful consideration of the individual's ability to
    follow the project's coding style, follow this CVS commit policy,
    and work productively with the other developers.  If you have to
    ask for commit access, you probably won't get it.  So don't ask.
    If you are given commit access, you are expected to read and
    follow this policy and it's guidelines as well as the developer's
    guide.
d205 2
a206 2
    When code is committed to CVS, a messages should be provided that
    appropriately describes the change in a succinct and useful
d216 2
a217 2
    disclaimers, usage documentation, extensive debugging details, or
    mini novels of who/what/when/where/why.
d221 2
a222 2
    comments are only for documenting changes so that other developers
    may derive a clue about what the change was without necessarily
d225 6
a230 3
    If the changes are merely formatting or whitespace adjustments, a
    simple commit message of "ws" or "M-x indent-region" is generally
    understood and sufficient.
d272 1
a272 1
    a) Compiles -- The code must compile on ALL supported platforms.
d278 2
a279 3
       of the sources, or break support for any existing
       functionality.
	   
d281 4
a284 4
       validation tests.  If the tests are inadequate, flawed, or
       simply require modifications, justification and explanations
       should be provided along with fixes to the tests before
       submitting code that would otherwise not pass.
d290 13
a302 11
    necessarily follow the same requirements of compiling cleaning or
    "working" until those changes are merged back in to either STABLE
    or HEAD unless the branch is a release maintenance branch.
    Release maintenance branches generally follow the same commit
    rules as checking into HEAD.

    It's not possible to commit against a non-branch checkout (such as
    a release tag like "rel-7-0").  Edits to a non-editable release
    revision can still be applied by performing a diff against a clean
    checkout of that same revision tag and then applying the patch to
    a maintenance branch or to HEAD.
d307 1
a307 1
    <keyword>-<revision>[-<date>][-<comment>]
d346 1
a346 1
        tags should not include a date in the tag name.
d350 3
a352 3
        For branches the comment is "branch", for patches the comment
        is "patches".  For releases, it is left blank.  For other
        miscellaneous tags, the comment is up to the person tagging.
d368 3
a370 2
	code that was made publicly available.  It should match what
	was released, bugs and all.
d395 1
a395 1
	Examples: rel-7-0-branch ansi-6-0-branch photonmap-branch
d400 4
a403 3
	When joining a branch into HEAD, there should be a tag before
	and after the merge.  When joining in HEAD into a branch,
	tagging is optional. Joins into head should be tagged, though.
d407 3
a409 1
            <keyword>[-<revision>]-<date>-premerge
d413 7
a419 1
            <keyword>[-<revision>]-<date>-merged
d424 1
a424 1
	    <keyword>[-<revision>]-<date>-branch-freeze
d426 10
a435 2
	Examples: ansi-6-0-20040404-premerge ansi-6-0-20040405-merged
		  windows-6-0-20040315-freeze photonmap-branch-freeze
d441 1
a441 1
	applies.  Lower case, dash-separated, and hopefully
d444 1
a444 1
	to the individual revision of a file at the time specified.
d454 1
d456 4
a459 2
    desired code changes are committed to HEAD and well tested.  Once
    HEAD is verified, it may be joined into STABLE, which should
d462 1
a462 1
    Once all the code is verified, then the release should be tagged:
d466 7
d476 3
a478 3
    If minor maintenance is expected to continue and head need to
    continue development in an incompatible way, a maintenance branch
    should be made as well:
d503 1
a503 1
    will have changes that need to be manually merged.
d512 16
a527 11
    directory and brlcad.modified is a modified top-level source
    directory.  That same patch file may then be applied to a checkout
    and commited to CVS.

    If there is an active maintenance branch close to the patch, it is
    generally easier to apply the patch to the maintenance branch
    first and then join the maintenance branch into HEAD as usual
    instead of merging directly into HEAD.  HEAD will have often
    changed too significantly and may result in patch being unable to
    resolve chunks.  See the patch manual documentation for more
    details.
d543 1
a543 1
    update command.  It's important to note that joins occur on code
d546 3
a548 2
    If you have changes that have not yet been commited to CVS, they
    should first be commited.  Then the join may occur.
d565 1
a565 1
	  cvs tag <keyword>-<revision>-<date>-premerge
d567 1
a567 1
	  [ resolve conflicts ]
d569 5
a573 1
	  cvs tag <keyword>-<revision>-<date>-merged
d576 5
a580 4
    manually resolved.  Once any conflicts are resolved, the changes
    could then be commited to HEAD.  Be careful to notice any file
    additions or deletions as CVS will not manage those for you
    generally speaking.
d599 6
a604 1
    branch too.
d610 2
a611 1
    what revision you have checked out.
d616 3
a618 2
    Making a branch is a simple matter of using the "-b" option when
    tagging.  Branch tags are special symbolic CVS tags that
d622 2
a623 2
        If you want to use the main HEAD as the anchor for your
        branch:
d625 2
a626 2
            cvs rtag -b <keyword>-<revision>-branch brlcad
            cvs checkout -r <keyword>-<revision>-branch brlcad
d628 2
a629 2
        If you want to use some other tag as the anchor for your
        branch:
d631 2
a632 2
            cvs rtag -b -r <tag> <keyword>-<revision>-branch brlcad
            cvs checkout -r <keyword>-<revision>-branch brlcad
d634 2
a635 2
    CASE 2: You have a checked out revision, and you want to tag it
    and start using it as a branch:
d637 2
a638 2
        cvs tag -b <keyword>-<revision>-branch
        cvs update -r <keyword>-<revision>-branch
d640 3
a642 2
    This makes the <keyword>-<revision>-branch tag sticky.  You can
    verify this by using 'cvs status', for example:
d646 2
a647 1
    To see all tags for a particular file:
d650 3
a652 1
    or
d658 1
a658 11
    0) To avoid having to specify the repository for a checkout, and
       to quell CVS warnings, you can set your CVSROOT environment
       variable to the location of the repository:

       For anonymous users:
           export CVSROOT=:pserver:anonymous@@cvs.sf.net:/cvsroot/brlcad

       For developers with accounts:
           export CVSROOT=<username>@@cvs.sf.net:/cvsroot/brlcad

    1) Checkout with the -P option to prune empty directories:
d662 2
a663 2
    2) Be sure to perform an "update -d" to check for new directories
       from time to time.
d665 1
a665 1
       cvs update -d
d667 1
a667 1
    3) Update and commit frequently.  Frequent updates are a good
d670 2
a671 2
    4) Nice easy way to check what files have been modified if you are
       certain that you've not added any files:
d679 10
d693 2
a694 2
       include a version in their name (e.g. libtcl8) or indicate age
       (e.g. newRt).
d701 3
a703 1
       good reason.
d707 4
a710 4
       things up, and are ready to simply move your files to a new
       location in CVS, an otherwise complicated task becomes mostly
       simple with a few find scripts.  Here is an example where a
       directory ./foo/ is moved to a new location ./src/foo2/:
d737 1
a737 1
       the move and the name after the move.  Do this both on the
d747 19
d791 1
a791 1
http://www.smlnj.org//DEV/policy.html
@


1.1
log
@cvs usage file moved to doc/ and renamed to cvs.txt
@
text
@d1 2
a2 1
PROPOSAL
d4 53
a56 1
        The following is a proposal for a set of guidelines
a57 1
The BRL-CAD Concurrent Versions System Policy and Guidelines
d59 34
d94 5
a99 1
OVERVIEW
d101 20
a120 2
    There are several development guidelines which all developers are
    expected to observe:
a121 2
    1. All code development is to be done on CVS branches, not the
       trunk.
d123 1
a123 2
    2. Branches are not merged into the trunk until the code has been
       well tested.
d125 2
a126 1
    3. CVS tags follow a consistant naming convention.
d128 2
a129 2
    4. Merges to the trunk must be timed so that they cooperate with
       scheduled releases.
d132 1
a132 1
INTRODUCTION
d134 2
a135 6
    Since the BRL-CAD developers potentially have specific independant
    development projects, it's imperative that the check-ins which one
    developer commits does not interfere with the work of the others.
    Also, it's very important that the main BRL-CAD trunk be a stable
    code base so that users can download and use it successfully at
    any time.
d137 2
a138 3
    For these reasons, most code development should be done on
    branches.  Individual branches may be periodically synced with the
    main trunk over time.  
d140 2
a141 3
    We do make exceptions to this rule, however, when making one or
    two-line bug fixes.  It seems overkill to make a branch in order
    to commit a trivial bug fix.
a142 3
    If you feel you *must* work off of the trunk for simplicity, all
    commits should be extensively tested by hand across all supported
    platforms before being committed to the tree.
d144 1
a144 3
    In addition to maintaining a stable tree, branches are also
    useful/used to track patches after a release and to test
    experimental changes.
d146 6
a151 5
    Finally, as BRL-CAD release schedules are set, developers will
    need to merge development branches, as appropriate back into the
    main trunk.  Appropriate testing, of course, needs to happen prior
    to commits for those as well.  The rest of this document explains
    in detail how branches and CVS tags are to be managed.
d153 2
d156 2
d159 2
a160 1
HOW TO CHECK OUT THE MAIN TRUNK
d162 2
d165 1
a165 1
    FROM CAD:
d167 1
a167 1
    cvs -d /c/CVS checkout brlcad
d170 10
a179 1
    FROM ELSEWHERE:
a180 2
    export CVS_RSH=ssh 
    cvs -z3 -dusername@@cad.arl.army.mil:/c/CVS checkout brlcad
d182 1
a182 1
    (replace "username" with you cad account name, of course)
d184 7
d192 5
d198 5
a202 1
HOW TO CHECK OUT A BRANCH
d204 3
a206 1
    cvs checkout -r <keyword>-<revision>-branch brlcad
d208 70
d281 2
d284 1
a284 3
    <keyword>-<revision>-<date>-<comment>

    <keyword> ::= { ansi, jra, sean, ppc, ibm, ... }
d288 1
a288 1
        function, persons, etc.
d292 2
a293 2
        The <revision> naming convention is fairly standard and common
        practice:
d295 1
a295 1
        <major> is the major revision number and changes very
d297 4
a300 10
                architectural changes and are not necessarily
                backwards compatible with existing code or data.  They
                may require data and/or code to be converted in order
                to upgrade.

                Major releases usually go through an alpha release
                where glaring problems are resolved and features are
                polished.  A lengthy beta period usually follows where
                no new features are added.  Subsequent beta releases
                may be made until the code base is deemed stable.
d303 6
a308 5
                fairly regular basis.  As new features are added, the
                minor revision number changes to reflect those
                additions.  Minor releases may or may not be preceeded
                by alpha and/or beta releases, depending on the extent
                of changes being made.
d318 4
a321 4
        When creating tags, the date a tag is made is noted.  The
        format of the date is YYYYMMDD and should correspond to tag
        creation dates.  Subsequent tags that are based off of dated
        tags should use the original date.
a328 1

d330 1
a330 3
    never used because they upset CVS's branch naming.  The revision
    should match the most relevant release tag that the branch is
    based off of. 
d332 2
d335 3
a338 1
BRANCH TAG NAMING SCHEME
d340 1
a340 3
    Branches are symbolic tags that are used to anchor a branch as a
    specific tree revision.  We'll use the following format for branch
    tags:
d342 3
a344 1
    <keyword>-<revision>-branch
d346 1
d348 1
a348 1
NON-BRANCH TAG NAMING SCHEME
d350 2
a351 4
    We use non-branch tags for three things:
        1) marking a release
        2) merging branches
        3) miscellaneous tags (e.g., to remember a specific stopping point)
d353 1
a354 1
    FORMAT FOR MAKING A RELEASE:
d356 1
a356 1
        rel-<revision>-<date>
d358 3
a360 1
        <revision> ::= major-minor[-<patch>]  (e.g., 6-0 and 6-0-2a)
d362 1
a362 1
        <date> ::= <year><month><day>   (e.g., 19991206)
d364 1
d366 2
a367 1
    FORMAT FOR MAKING A PATCH RELEASE:
d369 1
a369 1
        rel-<revision>-<date>-patches
d374 3
a376 1
        On the branch, BEFORE THE MERGE, use the following tag:
d378 1
a378 1
            <keyword>-<revision>-<date>
d380 1
a380 1
        On the main trunk, AFTER THE MERGE, use the following tag:
d382 1
a382 1
            <keyword>-<revision>-<date>-merge
d384 1
d386 2
a387 3
    FORMAT FOR MISCELLANEOUS TAGS:
    
        <keyword>-<revision>-<date>-<comment>
d389 1
d391 2
a393 1
HOW TO TAG A RELEASE
d395 1
a395 2
    0) Merge in any branches and hanging updates that need to be committed to
       the base trunk on a HEAD revision checkout.
d397 5
a401 7
    1) Test the release on multiple architectures.  Run the benchmarks
       for speed and consistency comparisons.  Run the regression
       suite.  Manually test, fix, and retest, by hand as necessary.

    2) Tag the release:

        cvs tag rel-<revision>-<date>
d403 1
d405 2
a407 11
HOW TO PATCH A RELEASE

    0) Create a patch branch off of the release tag to work with:

            cvs rtag -b -r rel-<revision>-<date> rel-<revision>-<date>-patches brlcad
            cvs checkout -b rel-<revision>-<date>-patches brlcad

    1) Make source modifications and patches as needed.  Test, fix,
       and retest as needed.

    2) Commit changes to the patch branch:
d409 6
a414 2
        cvs update -dP
        cvs commit
d416 1
a416 3
    3) Commit changes to the main trunk manually. Patch branches are
       never merged back into the main trunk as it is not desireable
       to merge the main trunk into the patch branch first.
d418 1
a418 3
       If the patch branch contains any undesireable code (e.g., temp
       bug fixes) or any code not appropriate for the main trunk, the
       desired code must be added to a main branch checkout by hand.
a419 7
       Otherwise, the patch branch, in its entirety, may be merged
       back into the main trunk via:
       
        cvs update -A
        [ test extensively ]
        cvs commit
        cvs tag rel-<revision>-<date>-patches-merge
d421 1
d423 3
d427 1
a427 1
HOW TO MAKE A BRANCH
d429 2
a430 1
    CASE 1: You have no checked out trees.
a431 1
        If you want to use the main trunk as the anchor for your branch:
d433 1
a433 2
            cvs rtag -b <keyword>-<revision>-branch brlcad
            cvs checkout -b <keyword>-<revision>-branch brlcad
d435 4
a438 1
        If you want to use some other tag as the anchor for your branch:
d440 1
a440 2
            cvs rtag -b -r <tag> <keyword>-<revision>-branch brlcad
            cvs checkout -b <keyword>-<revision>-branch brlcad
d442 2
a443 2
    CASE 2: You have a checked out revision, and you want to tag it and start
    using it as a branch:
d445 1
a445 3
        cd <root-of-your-checked-out-tree>
        cvs tag -b <keyword>-<revision>-branch
        cvs update -r <keyword>-<revision>-branch
d447 4
a450 2
    This makes the <keyword>-<revision>-branch tag sticky.  You can verify
    this by using 'cvs status', for example, do this:
d452 3
a454 1
        cvs status Makefile
d456 1
a456 3
    or

        cvs status -v Makefile
d458 4
d463 7
a470 1
HOW TO MERGE THE TRUNK INTO YOUR BRANCH
d472 8
a479 3
    Before you merge your code into the trunk you should first merge
    the latest trunk code into your branch.  After merged code has been
    tested on your branch, merging into the trunk should be simple.
d481 6
a486 1
    0) Be sure all the changes on your branch are checked in.
d488 2
a489 1
    1) Tag your branch with a 'freeze' tag:
a490 1
        cvs tag <keyword>-<revision>-<date>-freeze
d492 1
a492 1
    2) Merge from the trunk:
d494 6
a499 1
        cvs update -d -j HEAD
d501 1
a501 1
    3) Resolve any conflicts from the merge.
d503 1
a503 1
    4) Recompile and build your branch.  Test it.
d505 6
a510 1
    5) Check in your changes from the merge.
d512 5
a516 1
    6) Tag your branch with a pre head-merge tag:
d518 4
a521 1
        cvs tag <keyword>-<revision>-<date>-merge
d523 5
d530 1
a530 1
HOW TO MERGE YOUR BRANCH TO THE MAIN TRUNK
d532 4
a535 4
    0) Be sure your <keyword>-<revision>-<date>-merge tag (on the branch) is up
       to date (i.e., in case you changed some files from between the time you
       merged the trunk onto the branch until you merged the branch onto the
       trunk).
d537 5
a541 1
       You can make the tag with:
a542 1
        cvs tag <keyword>-<revision>-<date>
d544 4
a547 1
    1) Revert your working tree to the main trunk:
d549 1
a549 1
        cvs update -A
d551 2
a552 2
       [Alternatively, you can just check out a new copy of the main
       trunk.]
d554 2
a555 1
    2) Merge in the changes from your branch:
d557 2
a558 1
        cvs update -j <keyword>-<revision>-branch
d560 2
a561 1
    3) Test your merged tree
d563 2
a564 1
    4) Check in your merged tree to the main branch;
d566 2
a567 1
        cvs commit -m 'Merged <keyword>-<revision>'
d569 2
a570 1
    5) Tag your merge so we can find it again:
d572 1
a572 1
        cvs tag <keyword>-<revision>-<date>-merge
d574 1
d576 3
a578 4
    Say you keep hacking on your branch after the merge to test a few extra 
    things and you want to merge again.  You get the main trunk checked
    out, as in step (1), then you merge only those changes between your
    last merge and the most recent revision in your branch:
a579 2
        cvs update -j <keyword>-<revision>-<date>
                   -j <keyword>-<revision>-branch
d581 3
a583 11
    If the branch being checked in an extensive set of changes,
    testing (step 3) is essential.  It is also a good idea to warn
    other developers of what you are planning to do.  You should
    indicate what parts of the system will be affected and coordinate
    in detail with other developers as appropriate.
    


USEFUL ADVICE

    0) To avoid having to specify the repository in each command, and
d587 2
a588 9
       FROM CAD:

          export CVSROOT=/c/CVS

       FROM ELSEWHERE:

          export CVSROOT=username@@cad.arl.army.mil:/c/CVS

    1) It is useful to have a ~/.cvsrc file with the following:
d590 2
a591 3
        $ cat ~/.cvsrc
        update -d -P
        checktout -P
d593 1
a593 10
       The -P switch tells CVS to prune empty directories.  The -d
       switch tells CVS to add new directories that may have been
       created in the repository since the last update.

    2) Frequent updates are a good thing.  Perform them often to
       minimize conflicts.

    3) Once a branch is merged back into the trunk, it is usually a
       good idea to consider the branch dead.  Create a new branch off
       of the merge tag to start again.
d595 74
d672 5
d678 2
a679 4
    This CVS policy was derived off of other projects such as the
    Linux Documentation Project, the XFree86 DRI project, Zope, FreeBSD, 
    and AT&T's SML/NJ among others.

d684 2
a685 1
XFree86 DRI
d692 1
a692 1
http://www.linuxsecurity.com/articles/vendors_products_article-3004.html
d695 1
d698 3
a700 3



@

