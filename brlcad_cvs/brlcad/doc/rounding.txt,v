head	14.2;
access;
symbols
	rel-7-10-4:14.2
	STABLE:14.2.0.2
	stable-branch:14.1
	rel-7-10-2:14.2
	rel-7-10-0:14.2
	rel-7-8-4:14.1
	rel-7-8-2:14.1
	rel-7-8-0:14.1
	trimnurbs-branch:14.1.0.8
	help:14.1
	temp_tag:14.1
	bobWinPort-20051223-freeze:14.1
	postmerge-20051223-bobWinPort:14.1
	premerge-20051223-bobWinPort:14.1
	rel-7-6-6:14.1
	rel-7-6-4:14.1
	rel-7-6-2:14.1
	rel-7-6-branch:14.1.0.6
	rel-7-6-0:14.1
	rel-7-4-2:14.1
	rel-7-4-branch:14.1.0.4
	bobWinPort:14.1.0.2
	rel-7-4-0:14.1
	rel-7-2-6:14.1
	rel-7-2-4:14.1
	rel-7-2-2:14.1
	rel-7-2-0:14.1
	rel-7-0-4:14.1
	rel-7-0-2:14.1
	rel-7-0-1:14.1
	opensource-post:14.1
	opensource-pre:1.1
	rel-7-0-branch:1.1.0.2
	rel-7-0:1.1;
locks; strict;
comment	@# @;


14.2
date	2007.01.27.01.41.28;	author brlcad;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.08;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.18.21.20.38;	author morrison;	state Exp;
branches;
next	;


desc
@@


14.2
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@Date:     Wed, 3 Feb 88 23:39:04 EST
From:     Mike Muuss (SECAD) <mike@@XXX.XXX>

This evening I have been working on a program which compares floating
point numbers over the network (part of something much bigger).

I encountered a rather perplexing phenomenon.  The Cray-2 and XMP
seem to give very slightly different answers for floating point
divisions.  I would have expected them to give the same answers.

For example, the calcuation 196.0 / 112.0 gives "1.75" on both
machines, but differing by one bit, ie:

XMP	4001E00000000000
Cray-2	4001DFFFFFFFFFFF
	^__^
	exp

It looks like the XMP is rounding UP, and the Cray-2 is rounding DOWN.

This is easy to check for yourself with this C program:

main()  {
	double f;
	f = 196.0 / 112.0;
	printf("f = %g, x%x\n", f, f );
}

Here is the output:

bob> c
f = 1.75, x4001dfffffffffff

patton> c
f = 1.75, x4001e00000000000

ISSUES

*)  Is this behavior intrinsic to the "hardware" (repirocal) divide
units, or is the rounding behavior programmable?

*)  For this particular calcuation, the LSB behavior is not significant.
However, for some iterative calculations, the LSB behavior may be
significant.  It would be useful to understand why the two Crays give
differing results.  I can live with a difference, as long as I know
what to expect.  However, if the difference can be resolved, that
would be even better.

	Best,
	 -Mike
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d16 1
a16 1
        ^__^
a50 1

@


1.1
log
@rename the text files from .doc to a .txt extension.  reserve .doc extension for groff files
@
text
@@

