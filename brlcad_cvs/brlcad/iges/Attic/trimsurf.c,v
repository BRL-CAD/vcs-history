head	11.23;
access;
symbols
	ansi-20040405-merged:11.21.4.1
	postmerge-20040405-ansi:11.22
	premerge-20040404-ansi:11.22
	postmerge-autoconf:11.22
	autoconf-freeze:11.21.12.2
	premerge-autoconf:11.22
	ansi-20040316-freeze:11.21
	postmerge-20040315-windows:11.22
	premerge-20040315-windows:11.22
	windows-20040315-freeze:11.21.6.1
	autoconf-20031203:11.21
	autoconf-20031202:11.21
	autoconf-branch:11.21.0.12
	phong-branch:11.21.0.10
	photonmap-branch:11.21.0.8
	rel-6-1-DP:11.21
	windows-branch:11.21.0.6
	rel-6-0-2:11.21
	ansi-branch:11.21.0.4
	rel-6-0-1-branch:11.21.0.2
	hartley-6-0-post:11.21
	hartley-6-0-pre:11.21
	rel-6-0-1:11.21
	rel-6-0:11.21
	rel-5-4:11.17.2.1
	offsite-5-3-pre:11.19
	rel-5-3:11.17.2.1
	rel-5-2:11.17
	rel-5-1-branch:11.17.0.2
	rel-5-1:11.17
	rel-5-0:11.15
	rel-5-0-beta:11.15
	rel-4-5:11.14
	ctj-4-5-post:11.12
	ctj-4-5-pre:11.12
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.23
date	2004.05.24.04.01.09;	author morrison;	state dead;
branches;
next	11.22;

11.22
date	2004.02.02.17.39.05;	author morrison;	state Exp;
branches;
next	11.21;

11.21
date	2001.08.08.20.25.12;	author jra;	state Exp;
branches
	11.21.4.1
	11.21.6.1
	11.21.12.1;
next	11.20;

11.20
date	2001.05.17.20.05.03;	author morrison;	state Exp;
branches;
next	11.19;

11.19
date	2001.02.06.15.13.43;	author jra;	state Exp;
branches;
next	11.18;

11.18
date	2000.08.24.04.10.49;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	2000.03.29.18.42.51;	author mike;	state Exp;
branches
	11.17.2.1;
next	11.16;

11.16
date	2000.01.05.14.16.09;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	98.05.12.18.31.27;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	97.09.18.20.35.54;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	97.09.09.13.46.34;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	97.01.08.03.00.34;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	96.07.15.19.19.47;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	95.12.08.17.49.39;	author jra;	state Exp;
branches;
next	11.9;

11.9
date	95.12.05.22.02.45;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	95.12.04.19.35.47;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	95.12.01.15.47.52;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	95.11.30.15.38.47;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	95.11.28.21.35.45;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	95.06.29.14.43.48;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.06.29.11.55.27;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.06.28.15.24.34;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.08.16;	author mike;	state Rel4_4;
branches;
next	1.4;

1.4
date	94.11.04.15.56.25;	author jra;	state Exp;
branches;
next	1.3;

1.3
date	94.11.04.14.37.19;	author jra;	state Exp;
branches;
next	1.2;

1.2
date	94.10.14.16.04.21;	author jra;	state Exp;
branches;
next	1.1;

1.1
date	94.10.04.17.59.38;	author jra;	state Exp;
branches;
next	;

11.17.2.1
date	2001.01.24.13.35.51;	author jra;	state Exp;
branches;
next	;

11.21.4.1
date	2004.03.17.21.16.34;	author morrison;	state Exp;
branches;
next	;

11.21.6.1
date	2004.03.11.23.41.16;	author morrison;	state Exp;
branches;
next	;

11.21.12.1
date	2004.02.12.19.41.40;	author erikg;	state Exp;
branches;
next	11.21.12.2;

11.21.12.2
date	2004.03.15.14.06.13;	author erikg;	state Exp;
branches;
next	;


desc
@Module to convert IGES trimmed surfaces to BRL-CAD TNURBS.
@


11.23
log
@moved to src/iges/
@
text
@/*
 *  Authors -
 *	John R. Anderson
 *
 *  Source -
 *	SLAD/BVLD/VMB
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1994-2004 by the United States Army
 *	in all countries except the USA. All rights reserved.
 */

/*	This routine loops through all the directory entries and calls
	appropriate routines to convert trimmed surface entities to BRLCAD
	NMG TNURBS	*/

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/iges/trimsurf.c,v 11.22 2004/02/02 17:39:05 morrison Exp $ (BRL)";
#endif

#include "./iges_struct.h"
#include "./iges_extern.h"
#include "../librt/debug.h"

/* translations to get knot vectors in first quadrant */
static fastf_t u_translation=0.0;
static fastf_t v_translation=0.0;

#define UV_TOL  1.0e-6

#define CTL_INDEX(_i,_j)	((_i * n_cols + _j) * ncoords)

struct snurb_hit
{
	struct bu_list l;
	fastf_t dist;
	point_t pt;
	vect_t norm;
	struct face *f;
};

struct face_g_snurb *
Get_nurb_surf( entityno, m )
int entityno;
struct model *m;
{
	struct face_g_snurb *srf;
	point_t pt;
	int entity_type;
	int i;
	int rational;
	int ncoords;
	int n_rows,n_cols,u_order,v_order;
	int n_u,n_v;
	int pt_type;
	double a;

	/* Acquiring Data */

	if( dir[entityno]->param <= pstart )
	{
		bu_log( "Illegal parameter pointer for entity D%07d (%s)\n" ,
				dir[entityno]->direct , dir[entityno]->name );
		return( (struct face_g_snurb *)NULL );
	}

	Readrec( dir[entityno]->param );
	Readint( &entity_type , "" );
	if( entity_type != 128 )
	{
		bu_log( "Only B-Spline surfaces allowed for faces (found type %d)\n", entity_type );
		return( (struct face_g_snurb *)NULL );
	}
	Readint( &i , "" );
	n_cols = i+1;
	Readint( &i , "" );
	n_rows = i+1;
	Readint( &i , "" );
	u_order = i+1;
	Readint ( &i , "" );
	v_order = i+1;
	Readint( &i , "" );
	Readint( &i , "" );
	Readint( &i , "" );
	rational = !i;

	ncoords = 3+rational;
	pt_type = RT_NURB_MAKE_PT_TYPE( ncoords , RT_NURB_PT_XYZ , rational );
	Readint( &i , "" );
	Readint( &i , "" );

	n_u = n_cols+u_order;
	n_v = n_rows+v_order;
	if( !m )
		srf = rt_nurb_new_snurb( u_order, v_order, n_u, n_v, n_rows, n_cols, pt_type, (struct resource *)NULL );
	else
	{
		int pnum;

		GET_FACE_G_SNURB( srf, m );
		BU_LIST_INIT( &srf->l );
		BU_LIST_INIT( &srf->f_hd );
		srf->l.magic = NMG_FACE_G_SNURB_MAGIC;
		srf->order[0] = u_order;
		srf->order[1] = v_order;
		srf->dir = RT_NURB_SPLIT_ROW;
		srf->u.magic = NMG_KNOT_VECTOR_MAGIC;
		srf->v.magic = NMG_KNOT_VECTOR_MAGIC;
		srf->u.k_size = n_u;
		srf->v.k_size = n_v;
		srf->u.knots = (fastf_t *) bu_malloc ( 
			n_u * sizeof (fastf_t ), "Get_nurb_surf: u kv knot values");
		srf->v.knots = (fastf_t *) bu_malloc ( 
			n_v * sizeof (fastf_t ), "Get_nurb_surf: v kv knot values");

		srf->s_size[0] = n_rows;
		srf->s_size[1] = n_cols;
		srf->pt_type = pt_type;

		pnum = sizeof (fastf_t) * n_rows * n_cols * RT_NURB_EXTRACT_COORDS(pt_type);
		srf->ctl_points = ( fastf_t *) bu_malloc( 
			pnum, "Get_nurb_surf: control mesh points");

	}
	NMG_CK_FACE_G_SNURB( srf );

	/* Read knot vectors */
	for( i=0 ; i<n_u ; i++ )
	{
		Readdbl( &a , "" );
		srf->u.knots[i] = a;
	}
	for( i=0 ; i<n_v ; i++ )
	{
		Readdbl( &a , "" );
		srf->v.knots[i] = a;
	}

	/* Insure that knot values are non-negative */
	if( srf->v.knots[0] < 0.0 )
	{
		v_translation = (-srf->v.knots[0]);
		for( i=0 ; i<n_v ; i++ )
			srf->v.knots[i] += v_translation;
	}
	else
		v_translation = 0.0;

	if( srf->u.knots[0] < 0.0 )
	{
		u_translation = (-srf->u.knots[0]);
		for( i=0 ; i<n_u ; i++ )
			srf->u.knots[i] += u_translation;
	}
	else
		u_translation = 0.0;

	/* Read weights */
	for( i=0 ; i<n_cols*n_rows ; i++ )
	{
		Readdbl( &a , "" );
		if( rational )
			srf->ctl_points[i*ncoords + 3] = a;
	}

	/* Read control points */
	for( i=0 ; i<n_cols*n_rows ; i++ )
	{
			Readcnv( &a , "" );
			if( rational )
				pt[X] = a*srf->ctl_points[i*ncoords+3];
			else
				pt[X] = a;
			Readcnv( &a , "" );
			if( rational )
				pt[Y] = a*srf->ctl_points[i*ncoords+3];
			else
				pt[Y] = a;
			Readcnv( &a , "" );
			if( rational )
				pt[Z] = a*srf->ctl_points[i*ncoords+3];
			else
				pt[Z] = a;

			/* apply transformation */
			MAT4X3PNT( &srf->ctl_points[i*ncoords], *dir[entityno]->rot, pt );
	}

	Readdbl( &a , "" );
	Readdbl( &a , "" );
	Readdbl( &a , "" );
	Readdbl( &a , "" );

	return( srf );
}

void
Assign_cnurb_to_eu( eu, crv )
struct edgeuse *eu;
struct edge_g_cnurb *crv;
{
	fastf_t *ctl_points;
	fastf_t *knots;
	int ncoords;
	int i;

	NMG_CK_EDGEUSE( eu );
	NMG_CK_CNURB( crv );

	ncoords = RT_NURB_EXTRACT_COORDS( crv->pt_type );

	ctl_points = (fastf_t *)bu_calloc( ncoords*crv->c_size, sizeof( fastf_t ),
			"Assign_cnurb_to_eu: ctl_points" );

	for( i=0 ; i<crv->c_size ; i++ )
		VMOVEN( &ctl_points[i*ncoords], &crv->ctl_points[i*ncoords], ncoords )

	knots = (fastf_t *)bu_calloc( crv->k.k_size, sizeof( fastf_t ),
			"Assign_cnurb_to_eu: knots" );

	for( i=0 ; i<crv->k.k_size; i++ )
		knots[i] = crv->k.knots[i];

	nmg_edge_g_cnurb( eu, crv->order, crv->k.k_size, knots, crv->c_size,
			crv->pt_type, ctl_points );
}

struct edge_g_cnurb *
Get_cnurb( entity_no )
int entity_no;
{
	struct edge_g_cnurb *crv;
	point_t pt,pt2;
	int entity_type;
	int num_pts;
	int degree;
	int i;
	int planar;
	int rational;
	int pt_type;
	int ncoords;
	double a;
	double x,y,z;

	if( dir[entity_no]->param <= pstart )
	{
		bu_log( "Get_cnurb: Illegal parameter pointer for entity D%07d (%s)\n" ,
				dir[entity_no]->direct , dir[entity_no]->name );
		return( (struct edge_g_cnurb *)NULL );
	}

	Readrec( dir[entity_no]->param );
	Readint( &entity_type , "" );

	if( entity_type != 126 )
	{
		bu_log( "Get_cnurb: Was expecting spline curve, got type %d\n" , entity_type );
		return( (struct edge_g_cnurb *)NULL );
	}

	Readint( &i , "" );
	num_pts = i+1;
	Readint( &degree , "" );

	/* properties */
	Readint( &planar , "" );
	Readint( &i, "" );	/* open or closed */
	Readint( &i, "" );	/* polynomial */
	rational = !i;
	Readint( &i, "" );	/* periodic */

	if( rational )
	{
		ncoords = 3;
		pt_type = RT_NURB_MAKE_PT_TYPE( ncoords, RT_NURB_PT_UV, RT_NURB_PT_RATIONAL );
	}
	else
	{
		ncoords = 2;
		pt_type = RT_NURB_MAKE_PT_TYPE( ncoords, RT_NURB_PT_UV, RT_NURB_PT_NONRAT );
	}

	crv = rt_nurb_new_cnurb( degree+1, num_pts+degree+1, num_pts, pt_type );
	/* knot vector */
	for( i=0 ; i<num_pts+degree+1 ; i++ )
	{
		Readdbl( &a , "" );
		crv->k.knots[i] = a;
	}

	/* weights */
	for( i=0 ; i<num_pts ; i++ )
	{
		Readdbl( &a , "" );
		if( rational )
			crv->ctl_points[i*ncoords+2] = a;
	}

	/* control points */
	for( i=0 ; i<num_pts ; i++ )
	{
		if( dir[entity_no]->status & 500 )
		{
			Readdbl( &x , "" );
			Readdbl( &y , "" );
			Readdbl( &z , "" );
		}
		else
		{
			Readcnv( &x , "" );
			Readcnv( &y , "" );
			Readcnv( &z , "" );
		}
		if( rational )
		{
			pt[X] = (x + u_translation) * crv->ctl_points[i*ncoords+2];
			pt[Y] = (y + v_translation) * crv->ctl_points[i*ncoords+2];
		}
		else
		{
			pt[X] = x + u_translation;
			pt[Y] = y + v_translation;
		}
		pt[Z] = z;

		/* apply transformation */
		MAT4X3PNT( pt2, *dir[entity_no]->rot, pt );
		crv->ctl_points[i*ncoords] = pt2[X];
		crv->ctl_points[i*ncoords+1] = pt2[Y];
	}
	return( crv );
}

void
Assign_vu_geom( vu, u, v, srf )
struct vertexuse *vu;
fastf_t u,v;
struct face_g_snurb *srf;
{
	point_t uvw;
	hpoint_t pt_on_srf;
	struct vertexuse *vu1;
	int moved=0;

	NMG_CK_VERTEXUSE( vu );
	NMG_CK_SNURB( srf );

	VSETALLN( pt_on_srf, 0.0, 4 )

	if( u < srf->u.knots[0] || v < srf->v.knots[0] ||
		u > srf->u.knots[srf->u.k_size-1] || v > srf->v.knots[srf->v.k_size-1] )
	{
		bu_log( "WARNING: UV point outside of domain of surface!!!:\n" );
		bu_log( "\tUV = (%g %g)\n", u, v );
		bu_log( "\tsrf domain: (%g %g) <-> (%g %g)\n",
			srf->u.knots[0], srf->v.knots[0],
			srf->u.knots[srf->u.k_size-1], srf->v.knots[srf->v.k_size-1] );

		if( u < srf->u.knots[0] )
			u = srf->u.knots[0];
		if( v < srf->v.knots[0] )
			v = srf->v.knots[0];
		if( u > srf->u.knots[srf->u.k_size-1] )
			u = srf->u.knots[srf->u.k_size-1];
		if( v > srf->v.knots[srf->v.k_size-1] )
			v = srf->v.knots[srf->v.k_size-1];

		moved = 1;
	}

	rt_nurb_s_eval( srf, u, v, pt_on_srf );
	if( RT_NURB_IS_PT_RATIONAL( srf->pt_type ) )
	{
		fastf_t scale;

		scale = 1.0/pt_on_srf[3];
		VSCALE( pt_on_srf, pt_on_srf, scale );
	}
	if( moved )
	{
		bu_log( "\tMoving VU geom to (%g %g %g) new UV = (%g %g)\n",
			V3ARGS( pt_on_srf ), u, v );
	}

	nmg_vertex_gv( vu->v_p, pt_on_srf );
	/* XXXXX Need w coord!!!!! */
	VSET( uvw, u, v, 1.0 );

	for( BU_LIST_FOR( vu1, vertexuse, &vu->v_p->vu_hd ) )
		nmg_vertexuse_a_cnurb( vu1, uvw );
}

void
Add_trim_curve( entity_no, lu, srf )
int entity_no;
struct loopuse *lu;
struct face_g_snurb *srf;
{
	int entity_type;
	struct edge_g_cnurb *crv;
	struct edgeuse *eu;
	struct edgeuse *new_eu;
	struct vertex *vp;
	double x,y,z;
	point_t pt, pt2;
	int ncoords;
	int i;

	NMG_CK_LOOPUSE( lu );
	NMG_CK_SNURB( srf );

	if( dir[entity_no]->param <= pstart )
	{
		bu_log( "Illegal parameter pointer for entity D%07d (%s)\n" ,
				dir[entity_no]->direct , dir[entity_no]->name );
		return;
	}

	Readrec( dir[entity_no]->param );
	Readint( &entity_type , "" );

	switch( entity_type )
	{
		case 102:	/* composite curve */
			{
				int curve_count;
				int *curve_list;

				Readint( &curve_count , "" );
				curve_list = (int *)bu_calloc( curve_count , sizeof( int ),
						"Add_trim_curve: curve_list" );

				for( i=0 ; i<curve_count ; i++ )
					Readint( &curve_list[i] , "" );

				for( i=0 ; i<curve_count ; i++ )
					Add_trim_curve( (curve_list[i]-1)/2, lu, srf );

				bu_free( (char *)curve_list , "Add_trim_curve: curve_list" );
			}
			break;
		case 110:	/* line */
			/* get start point */
			Readdbl( &x , "" );
			Readdbl( &y , "" );
			Readdbl( &z , "" );
			VSET( pt, x + u_translation, y + v_translation, z )

			/* apply transformation */
			MAT4X3PNT( pt2, *dir[entity_no]->rot, pt )

			/* Split last edge in loop */
			eu = BU_LIST_LAST( edgeuse, &lu->down_hd );
			new_eu = nmg_eusplit( (struct vertex *)NULL, eu, 0 );
			vp = eu->vu_p->v_p;

			/* if old edge doesn't have vertex geometry, assign some */
			if( !vp->vg_p )
				Assign_vu_geom( eu->vu_p, pt2[X], pt2[Y], srf );

			/* read terminate point */
			Readdbl( &x , "" );
			Readdbl( &y , "" );
			Readdbl( &z , "" );
			VSET( pt, x + u_translation, y + v_translation, z )

			/* apply transformation */
			MAT4X3PNT( pt2, *dir[entity_no]->rot, pt )

			Assign_vu_geom( new_eu->vu_p, pt2[X], pt2[Y], srf );

			/* assign edge geometry */
			nmg_edge_g_cnurb_plinear( eu );
			break;
		case 100:	/* circular arc */
			{
				struct edge_g_cnurb *crv;
				point_t center, start, end;

				/* read Arc center start and end points */
				Readcnv( &z , "" );	/* common Z-coord */
				Readcnv( &x , "" );	/* center */
				Readcnv( &y , "" );	/* center */
				VSET( center, y+u_translation, x+v_translation, z )

				Readcnv( &x , "" );	/* start */
				Readcnv( &y , "" );	/* start */
				VSET( start, y+u_translation, x+v_translation, z )

				Readcnv( &x , "" );	/* end */
				Readcnv( &y , "" );	/* end */
				VSET( end, y+u_translation, x+v_translation, z )

				/* build edge_g_cnurb arc */
				crv = rt_arc2d_to_cnurb( center, start, end, RT_NURB_PT_UV, &tol );

				/* apply transformation to control points */
				for( i=0 ; i<crv->c_size ; i++ )
				{
					V2MOVE( pt2, &crv->ctl_points[i*3] )
					pt2[Z] = z;
					MAT4X3PNT( pt, *dir[entity_no]->rot, pt2 )
					V2MOVE( &crv->ctl_points[i*3], pt );
				}

				/* add a new edge to loop */
				eu = BU_LIST_LAST( edgeuse, &lu->down_hd );
				new_eu = nmg_eusplit( (struct vertex *)NULL, eu, 0 );
				vp = eu->vu_p->v_p;

				/* if old edge doesn't have vertex geometry, assign some */
				if( !vp->vg_p )
					Assign_vu_geom( eu->vu_p,
						crv->ctl_points[0], crv->ctl_points[1], srf );

				/* Assign geometry to new vertex */
				Assign_vu_geom( new_eu->vu_p,
						crv->ctl_points[(crv->c_size-1)*3],
						crv->ctl_points[(crv->c_size-1)*3 + 1],
						srf );

				/* Assign edge geometry */
				Assign_cnurb_to_eu( eu, crv );

				rt_nurb_free_cnurb( crv );
			}
			break;

		case 104:	/* conic arc */
			bu_log( "Conic Arc not yet handled as a trimming curve\n" );
			break;

		case 126:	/* spline curve */
			/* Get spline curve */
			crv = Get_cnurb( entity_no );

			ncoords = RT_NURB_EXTRACT_COORDS( crv->pt_type );

			/* add a new edge to loop */
			eu = BU_LIST_LAST( edgeuse, &lu->down_hd );
			new_eu = nmg_eusplit( (struct vertex *)NULL, eu, 0 );
			vp = eu->vu_p->v_p;

			/* if old edge doesn't have vertex geometry, assign some */
			if( !vp->vg_p )
			{
				Assign_vu_geom( eu->vu_p, crv->ctl_points[0],
					crv->ctl_points[1], srf );
			}

			/* Assign geometry to new vertex */
			Assign_vu_geom( new_eu->vu_p, crv->ctl_points[(crv->c_size-1)*ncoords],
					crv->ctl_points[(crv->c_size-1)*ncoords+1], srf );

			/* Assign edge geometry */
			Assign_cnurb_to_eu( eu, crv );

			rt_nurb_free_cnurb( crv );
			break;
		default:
			bu_log( "Curves of type %d are not yet handled for trimmed surfaces\n", entity_type );
			break;
	}
}

struct loopuse *
Make_trim_loop( entity_no, orientation, srf, fu )
int entity_no;
int orientation;
struct face_g_snurb *srf;
struct faceuse *fu;
{
	struct loopuse *lu;
	struct edgeuse *eu;
	struct edgeuse *new_eu;
	struct vertexuse *vu;
	struct vertex *vp;
	int entity_type;
	int ncoords;
	double x,y,z;
	fastf_t u,v;
	int i;

	NMG_CK_SNURB( srf );
	NMG_CK_FACEUSE( fu );

	if( dir[entity_no]->param <= pstart )
	{
		bu_log( "Illegal parameter pointer for entity D%07d (%s)\n" ,
				dir[entity_no]->direct , dir[entity_no]->name );
		return( (struct loopuse *)NULL );
	}

	Readrec( dir[entity_no]->param );
	Readint( &entity_type , "" );

	lu = nmg_mlv( &fu->l.magic, (struct vertex *)NULL, orientation );
	vu = BU_LIST_FIRST(vertexuse, &lu->down_hd);
	eu = nmg_meonvu(vu);

	switch( entity_type )
	{
		case 102:	/* composite curve */
			{
				int curve_count;
				int *curve_list;

				Readint( &curve_count , "" );
				curve_list = (int *)bu_calloc( curve_count , sizeof( int ),
						"Make_trim_loop: curve_list" );

				for( i=0 ; i<curve_count ; i++ )
					Readint( &curve_list[i] , "" );

				for( i=0 ; i<curve_count ; i++ )
					Add_trim_curve( (curve_list[i]-1)/2, lu, srf );

				bu_free( (char *)curve_list , "Make_trim_loop: curve_list" );

				/* if last EU is zero length, kill it */
				eu = BU_LIST_LAST( edgeuse, &lu->down_hd );
				if( bn_dist_pt3_pt3( eu->vu_p->v_p->vg_p->coord, eu->eumate_p->vu_p->v_p->vg_p->coord ) < tol.dist )
					nmg_keu( eu );
				else
				{
					bu_log( "ERROR: composite trimming curve is not closed!!!!\n" );
					bu_log( "\ttrim curve is entity #%d, parameters at line #%d\n",
						entity_no, dir[entity_no]->param );
					bu_log( "\tThis is likely to result in failure to convert (core dump)\n" );
				}
			}
			break;
		case 100:	/* circular arc (must be full cirle here) */
			{
				struct edge_g_cnurb *crv;
				struct edge_g_cnurb *crv1,*crv2;
				point_t center, start, end;
				struct bu_list curv_hd;

				/* read Arc center start and end points */
				Readcnv( &z , "" );	/* common Z-coord */
				Readcnv( &x , "" );	/* center */
				Readcnv( &y , "" );	/* center */
				VSET( center, x+u_translation, y+v_translation, z )

				Readcnv( &x , "" );	/* start */
				Readcnv( &y , "" );	/* start */
				VSET( start, x+u_translation, y+v_translation, z )

				Readcnv( &x , "" );	/* end */
				Readcnv( &y , "" );	/* end */
				VSET( end, x+u_translation, y+v_translation, z )

				/* build edge_g_cnurb circle */
				crv = rt_arc2d_to_cnurb( center, start, end, RT_NURB_PT_UV, &tol );

				/* split circle into two pieces */
				BU_LIST_INIT( &curv_hd );
				rt_nurb_c_split( &curv_hd, crv );
				crv1 = BU_LIST_FIRST( edge_g_cnurb, &curv_hd );
				crv2 = BU_LIST_LAST( edge_g_cnurb, &curv_hd );

				/* Split last edge in loop */
				eu = BU_LIST_LAST( edgeuse, &lu->down_hd );
				new_eu = nmg_eusplit( (struct vertex *)NULL, eu, 0 );
				vp = eu->vu_p->v_p;

				/* if old edge doesn't have vertex geometry, assign some */
				if( !vp->vg_p )
				{
					u = crv1->ctl_points[0]/crv1->ctl_points[2];
					v = crv1->ctl_points[1]/crv1->ctl_points[2];
					Assign_vu_geom( eu->vu_p, u, v, srf );
				}

				vp = new_eu->vu_p->v_p;
				if( !vp->vg_p )
				{
					/* Assign geometry to new_eu vertex */
					u = crv2->ctl_points[0]/crv2->ctl_points[2];
					v = crv2->ctl_points[1]/crv2->ctl_points[2];
					Assign_vu_geom( new_eu->vu_p, u, v, srf );
				}

				/* Assign edge geometry */
				Assign_cnurb_to_eu( eu, crv1 );
				Assign_cnurb_to_eu( new_eu, crv2 );

				rt_nurb_free_cnurb( crv );
				rt_nurb_free_cnurb( crv1 );
				rt_nurb_free_cnurb( crv2 );
			}
			break;

		case 104:	/* conic arc */
			bu_log( "Conic Arc not yet handled as a trimming curve\n" );
			break;

		case 126:	/* spline curve (must be closed loop) */
			{
				struct edge_g_cnurb *crv;
				struct edge_g_cnurb *crv1,*crv2;
				struct bu_list curv_hd;

				/* Get spline curve */
				crv = Get_cnurb( entity_no );

				ncoords = RT_NURB_EXTRACT_COORDS( crv->pt_type );

				/* split circle into two pieces */
				BU_LIST_INIT( &curv_hd );
				rt_nurb_c_split( &curv_hd, crv );
				crv1 = BU_LIST_FIRST( edge_g_cnurb, &curv_hd );
				crv2 = BU_LIST_LAST( edge_g_cnurb, &curv_hd );
				/* Split last edge in loop */
				eu = BU_LIST_LAST( edgeuse, &lu->down_hd );
				new_eu = nmg_eusplit( (struct vertex *)NULL, eu, 0 );
				vp = eu->vu_p->v_p;

				/* if old edge doesn't have vertex geometry, assign some */
				if( !vp->vg_p )
				{
					/* XXX Don't divied out rational coord */
					if( RT_NURB_IS_PT_RATIONAL( crv1->pt_type ) )
					{
						u = crv1->ctl_points[0]/crv1->ctl_points[ncoords-1];
						v = crv1->ctl_points[1]/crv1->ctl_points[ncoords-1];
					}
					else
					{
						u = crv1->ctl_points[0];
						v = crv1->ctl_points[1];
					}
					Assign_vu_geom( eu->vu_p, u, v, srf );
				}

				/* Assign geometry to new_eu vertex */
				vp = new_eu->vu_p->v_p;
				if( !vp->vg_p )
				{
					if( RT_NURB_IS_PT_RATIONAL( crv2->pt_type ) )
					{
						u = crv2->ctl_points[0]/crv2->ctl_points[ncoords-1];
						v = crv2->ctl_points[1]/crv2->ctl_points[ncoords-1];
					}
					else
					{
						u = crv2->ctl_points[0];
						v = crv2->ctl_points[1];
					}
					Assign_vu_geom( new_eu->vu_p, u, v, srf );
				}

				/* Assign edge geometry */
				Assign_cnurb_to_eu( eu, crv1 );
				Assign_cnurb_to_eu( new_eu, crv2 );

				rt_nurb_free_cnurb( crv );
				rt_nurb_free_cnurb( crv1 );
				rt_nurb_free_cnurb( crv2 );
			}
			break;
		default:
			bu_log( "Curves of type %d are not yet handled for trimmed surfaces\n", entity_type );
			break;
	}
	return( lu );
}

struct loopuse *
Make_loop( entity_no, orientation, on_surf_de, srf, fu )
int entity_no;
int orientation;
int on_surf_de;
struct face_g_snurb *srf;
struct faceuse *fu;
{
	struct loopuse *lu;
	int entity_type;
	int surf_de,param_curve_de,model_curve_de;
	int i;

	NMG_CK_SNURB( srf );
	NMG_CK_FACEUSE( fu );

	/* Acquiring Data */
	if( dir[entity_no]->param <= pstart )
	{
		bu_log( "Illegal parameter pointer for entity D%07d (%s)\n" ,
				dir[entity_no]->direct , dir[entity_no]->name );
		return(0);
	}

	Readrec( dir[entity_no]->param );
	Readint( &entity_type , "" );
	if( entity_type != 142 )
	{
		bu_log( "Expected Curve on a Parametric Surface, found %s\n" , iges_type( entity_type ) );
		return( 0 );
	}
	Readint( &i , "" );
	Readint( &surf_de , "" );
	if( surf_de != on_surf_de )
		bu_log( "Curve is on surface at DE %d, should be on surface at DE %d\n", surf_de, on_surf_de );

	Readint( &param_curve_de , "" );
	Readint( &model_curve_de , "" );

	lu = Make_trim_loop( (param_curve_de-1)/2, orientation, srf, fu );

	return( lu );
}

struct loopuse *
Make_default_loop( srf, fu )
struct face_g_snurb *srf;
struct faceuse *fu;
{
	struct loopuse *lu;
	struct edgeuse *eu;
	struct vertexuse *vu;
	fastf_t *knots;
	fastf_t u=0,v=0;
	fastf_t *ctl_points;
	int edge_no=0;
	int pt_type;
	int ncoords;
	int planar=0;
	int i;

	NMG_CK_FACEUSE( fu );
	NMG_CK_SNURB( srf );

	pt_type = RT_NURB_MAKE_PT_TYPE( 2, RT_NURB_PT_UV, RT_NURB_PT_NONRAT );
	ncoords = RT_NURB_EXTRACT_COORDS( srf->pt_type );

	if( srf->order[0] < 3 && srf->order[1] < 3 )
		planar = 1;

	lu = nmg_mlv( &fu->l.magic, (struct vertex *)NULL, OT_SAME );
	vu = BU_LIST_FIRST(vertexuse, &lu->down_hd);
	eu = nmg_meonvu(vu);
	for( i=0 ; i<3 ; i++ )
		(void)nmg_eusplit( (struct vertex *)NULL, eu, 0 );


	/* assign vertex geometry */
	for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
	{
		int u_index=0,v_index=0;

		NMG_CK_EDGEUSE( eu );
		vu = eu->vu_p;
		NMG_CK_VERTEXUSE( vu );
		switch( edge_no )
		{
			case 0:
				u_index = 0;
				v_index = 0;
				u = srf->u.knots[0];
				v = srf->v.knots[0];
				break;
			case 1:
				u_index = srf->s_size[0] - 1;
				v_index = 0;
				u = srf->u.knots[srf->u.k_size - 1];
				v = srf->v.knots[0];
				break;
			case 2:
				u_index = srf->s_size[0] - 1;
				v_index = srf->s_size[1] - 1;
				u = srf->u.knots[srf->u.k_size - 1];
				v = srf->v.knots[srf->v.k_size - 1];
				break;
			case 3:
				u_index = 0;
				v_index = srf->s_size[0] - 1;
				u = srf->u.knots[0];
				v = srf->v.knots[srf->v.k_size - 1];
				break;
		}
		nmg_vertex_gv( vu->v_p, &srf->ctl_points[(u_index*srf->s_size[1] + v_index)*ncoords] );
		Assign_vu_geom( vu, u, v, srf );
		edge_no++;
	}

	/* assign edge geometry */
	edge_no = 0;
	for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
	{
		NMG_CK_EDGEUSE( eu );
		vu = eu->vu_p;
		NMG_CK_VERTEXUSE( vu );
		if( planar )
			nmg_edge_g( eu );
		else
		{
			ctl_points = (fastf_t *)bu_calloc( sizeof( fastf_t ), 4, "ctl_points" );
			switch( edge_no )
			{
				case 0:
					ctl_points[0] = 0.0;
					ctl_points[1] = 0.0;
					ctl_points[2] = 1.0;
					ctl_points[3] = 0.0;
					break;
				case 1:
					ctl_points[0] = 1.0;
					ctl_points[1] = 0.0;
					ctl_points[2] = 1.0;
					ctl_points[3] = 1.0;
					break;
				case 2:
					ctl_points[0] = 1.0;
					ctl_points[1] = 1.0;
					ctl_points[2] = 0.0;
					ctl_points[3] = 1.0;
					break;
				case 3:
					ctl_points[0] = 0.0;
					ctl_points[1] = 1.0;
					ctl_points[2] = 0.0;
					ctl_points[3] = 0.0;
					break;
			}
			knots = (fastf_t *)bu_calloc( sizeof( fastf_t ), 4, "knots" );
			knots[0] = 0.0;
			knots[1] = 0.0;
			knots[2] = 1.0;
			knots[3] = 1.0;
			nmg_edge_g_cnurb( eu, 2, 4, knots, 2, pt_type, ctl_points );
		}
		edge_no++;
	}

	return( lu );
}

void
Assign_surface_to_fu( fu, srf )
struct faceuse *fu;
struct face_g_snurb *srf;
{
	struct face *f;

	NMG_CK_FACEUSE( fu );
	NMG_CK_SNURB( srf );

	f = fu->f_p;
	NMG_CK_FACE( f );

	if( f->g.snurb_p )
		rt_bomb( "Assign_surface_to_fu: fu already has geometry\n" );

	fu->orientation = OT_SAME;
	fu->fumate_p->orientation = OT_OPPOSITE;
		
	f->g.snurb_p = srf;
	f->flip = 0;
	BU_LIST_APPEND( &srf->f_hd, &f->l );
}

struct faceuse *
trim_surf( entityno , s )
int entityno;
struct shell *s;
{
	struct model *m;
	struct face_g_snurb *srf;
	struct faceuse *fu;
	struct loopuse *lu;
	struct loopuse *kill_lu;
	struct vertex *verts[3];
	int entity_type;
	int surf_de;
	int has_outer_boundary,inner_loop_count,outer_loop;
	int *inner_loop=NULL;
	int i;
	int lu_uv_orient;

	NMG_CK_SHELL( s );

	m = nmg_find_model( &s->l.magic );
	NMG_CK_MODEL( m );

	if( bu_debug & BU_DEBUG_MEM_CHECK )
	{
		bu_log( "barriercheck at start of trim_surf():\n" );
		bu_mem_barriercheck();
	}

	/* Acquiring Data */
	if( dir[entityno]->param <= pstart )
	{
		bu_log( "Illegal parameter pointer for entity D%07d (%s)\n" ,
				dir[entityno]->direct , dir[entityno]->name );
		return(0);
	}

	Readrec( dir[entityno]->param );
	Readint( &entity_type , "" );
	if( entity_type != 144 )
	{
		bu_log( "Expected Trimmed Surface Entity found type %d\n" );
		return( (struct faceuse *)NULL );
	}
	Readint( &surf_de , "" );
	Readint( &has_outer_boundary , "" );
	Readint( &inner_loop_count , "" );
	Readint( &outer_loop , "" );
	if( inner_loop_count )
	{
		inner_loop = (int *)bu_calloc( inner_loop_count , sizeof( int ) , "trim_surf: innerloop" );
		for( i=0 ; i<inner_loop_count ; i++ )
			Readint( &inner_loop[i] , "" );
	}

	if( (srf=Get_nurb_surf( (surf_de-1)/2, m )) == (struct face_g_snurb *)NULL )
	{
		if( inner_loop_count )
			bu_free( (char *)inner_loop , "trim_surf: inner_loop" );
		return( (struct faceuse *)NULL );
	}

	/* Make a face (with a loop to be destroted later)
	 * because loop routines insist that face and face geometry
	 * must already be assigned
	 */
	for( i=0 ; i<3 ; i++ )
		verts[i] = (struct vertex *)NULL;

	if( bu_debug & BU_DEBUG_MEM_CHECK )
	{
		bu_log( "barriercheck before making face:\n" );
		bu_mem_barriercheck();
	}

	fu = nmg_cface( s, verts, 3 );
	Assign_surface_to_fu( fu, srf );

	kill_lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );

	if( !has_outer_boundary )
	{
		if( bu_debug & BU_DEBUG_MEM_CHECK )
		{
			bu_log( "barriercheck before making default loop():\n" );
			bu_mem_barriercheck();
		}

		lu = Make_default_loop( srf, fu);
	}
	else
	{
		if( bu_debug & BU_DEBUG_MEM_CHECK )
		{
			bu_log( "barriercheck before Make_loop():\n" );
			bu_mem_barriercheck();
		}

		lu = Make_loop( (outer_loop-1)/2, OT_SAME, surf_de, srf, fu );
	}

	if( bu_debug & BU_DEBUG_MEM_CHECK )
	{
		bu_log( "barriercheck after making loop:\n" );
		bu_mem_barriercheck();
	}


	(void)nmg_klu( kill_lu );

	/* first loop is an outer loop, orientation must be OT_SAME */
	if( bu_debug & BU_DEBUG_MEM_CHECK )
	{
		bu_log( "barriercheck before nmg_snurb_calc_lu_uv_orient(():\n" );
		bu_mem_barriercheck();
		bu_log( "check complete!!!\n" );
	}

	lu_uv_orient = nmg_snurb_calc_lu_uv_orient( lu );
	if( bu_debug & BU_DEBUG_MEM_CHECK )
	{
		bu_log( "barriercheck after nmg_snurb_calc_lu_uv_orient(():\n" );
		bu_mem_barriercheck();
	}
	if( lu_uv_orient == OT_SAME )
		nmg_set_lu_orientation( lu, 0 );
	else
	{
		nmg_reverse_face( fu );
		nmg_set_lu_orientation( lu, 0 );
	}

	for( i=0 ; i<inner_loop_count ; i++ )
	{
		lu = Make_loop( (inner_loop[i]-1)/2, OT_OPPOSITE, surf_de, srf, fu );

		/* These loops must all be OT_OPPOSITE */
		lu_uv_orient = nmg_snurb_calc_lu_uv_orient( lu );
		if( (lu_uv_orient == OT_OPPOSITE && !fu->f_p->flip) ||
		    (lu_uv_orient == OT_SAME && fu->f_p->flip) )
				continue;

		/* loop is in wrong direction, exchange lu and lu_mate */
		BU_LIST_DEQUEUE( &lu->l );
		BU_LIST_DEQUEUE( &lu->lumate_p->l );
		BU_LIST_APPEND( &fu->lu_hd , &lu->lumate_p->l );
		lu->lumate_p->up.fu_p = fu;
		BU_LIST_APPEND( &fu->fumate_p->lu_hd , &lu->l );
		lu->up.fu_p = fu->fumate_p;
	}

	if( inner_loop_count )	
		bu_free( (char *)inner_loop , "trim_surf: inner_loop" );

	NMG_CK_FACE_G_SNURB( fu->f_p->g.snurb_p );

	return( fu );
}

int
uv_in_fu( u, v, fu )
fastf_t u, v;
struct faceuse *fu;
{
	int ot_sames, ot_opps;
	struct loopuse *lu;

	/* check if point is in face (trimming curves) */
	ot_sames = 0;
	ot_opps = 0;

	for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
	{
		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		if( lu->orientation == OT_SAME )
			ot_sames += nmg_uv_in_lu( u, v, lu );
		else if( lu->orientation == OT_OPPOSITE )
			ot_opps += nmg_uv_in_lu( u, v, lu );
		else
		{
			bu_log( "isect_ray_snurb_face: lu orientation = %s!!\n",
				nmg_orientation( lu->orientation ) );
			bu_bomb( "isect_ray_snurb_face: bad lu orientation\n" );
		}
	}

	if( ot_sames == 0 || ot_opps == ot_sames )
	{
		/* not a hit */
		return( 0 );
	}
	else
	{
		/* this is a hit */
		return( 1 );
	}
}

/* find all the intersections of fu along line through "mid_pt",
 * in direction "ray_dir". Place hits on "hit_list"
 */
void
find_intersections( fu, mid_pt, ray_dir, hit_list )
struct faceuse *fu;
point_t mid_pt;
vect_t ray_dir;
struct bu_list *hit_list;
{
	plane_t pl1, pl2;
	struct bu_list bezier;
	struct face *f;
	struct face_g_snurb *fg;

	NMG_CK_FACEUSE( fu );

	f = fu->f_p;

	if( *f->g.magic_p != NMG_FACE_G_SNURB_MAGIC )
		bu_bomb( "ERROR: find_intersections(): face is not a TNURB surface!!!!\n" );

	fg = f->g.snurb_p;

	bn_vec_ortho( pl2, ray_dir );
	VCROSS( pl1, pl2, ray_dir );
	pl1[3] = VDOT( mid_pt, pl1 );
	pl2[3] = VDOT( mid_pt, pl2 );

	BU_LIST_INIT( &bezier );

	rt_nurb_bezier( &bezier, fg, (struct resource *)NULL );
	while( BU_LIST_NON_EMPTY( &bezier ) )
	{
		struct face_g_snurb *srf;
		struct rt_nurb_uv_hit *hp;

		srf = BU_LIST_FIRST( face_g_snurb,  &bezier );
		BU_LIST_DEQUEUE( &srf->l );

		hp = rt_nurb_intersect( srf, pl1, pl2, UV_TOL, (struct resource *)NULL );
		/* process each hit point */
		while( hp != (struct rt_nurb_uv_hit *)NULL )
		{
			struct rt_nurb_uv_hit *next;
			struct snurb_hit *myhit;
			vect_t to_hit;
			fastf_t homo_hit[4];

			next = hp->next;

			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				bu_log( "\tintersect snurb surface at uv=(%g %g)\n", hp->u, hp->v );

			/* check if point is in face (trimming curves) */
			if( !uv_in_fu( hp->u, hp->v, fu ) )
			{
				/* not a hit */

				if (rt_g.NMG_debug & DEBUG_RT_ISECT)
					bu_log( "\tNot a hit\n" );

				bu_free( (char *)hp, "nurb_uv_hit" );
				hp = next;
				continue;
			}

			myhit = (struct snurb_hit *)bu_malloc( sizeof( struct snurb_hit ), "myhit" );
			myhit->f = f;

			/* calculate actual hit point (x y z) */
			rt_nurb_s_eval( srf, hp->u, hp->v, homo_hit );
			if( RT_NURB_IS_PT_RATIONAL( srf->pt_type ) )
			{
				fastf_t inv_homo;

				inv_homo = 1.0/homo_hit[3];
				VSCALE( myhit->pt, homo_hit, inv_homo )
			}
			else
				VMOVE( myhit->pt, homo_hit )

			VSUB2( to_hit, myhit->pt, mid_pt );
			myhit->dist = VDOT( to_hit, ray_dir );

			/* get surface normal */
			rt_nurb_s_norm( srf, hp->u, hp->v, myhit->norm );

			/* may need to reverse it */
			if( f->flip )
				VREVERSE( myhit->norm, myhit->norm )

			/* add hit to list */
			if( BU_LIST_IS_EMPTY( hit_list ) )
				BU_LIST_APPEND( hit_list, &myhit->l )
			else
			{
				struct snurb_hit *tmp;

				for( BU_LIST_FOR( tmp, snurb_hit, hit_list ) )
				{
					if( tmp->dist >= myhit->dist )
					{
						BU_LIST_INSERT( &tmp->l, &myhit->l );
						break;
					}
				}
				if( myhit->l.forw == (struct bu_list *)0 )
					BU_LIST_INSERT( hit_list, &myhit->l )
			}

			bu_free( (char *)hp, "nurb_uv_hit" );
			hp = next;
		}
		rt_nurb_free_snurb( srf, (struct resource *)NULL );
	}
}

/* adjust flip flag on faces using hit list data */
void
adjust_flips( hit_list, ray_dir )
struct bu_list *hit_list;
vect_t ray_dir;
{
	struct snurb_hit *hit;
	int enter=0;
	fastf_t prev_dist=(-MAX_FASTF);

	for( BU_LIST_FOR( hit, snurb_hit, hit_list ) )
	{
		fastf_t dot;

		if( !NEAR_ZERO( hit->dist - prev_dist, tol.dist ) )
			enter = !enter;

		dot = VDOT( hit->norm, ray_dir );

		if( (enter && dot > 0.0) || (!enter && dot < 0.0) )
		{
			struct snurb_hit *tmp;

			/* reverse this face */
			hit->f->flip = !(hit->f->flip);
			for( BU_LIST_FOR( tmp, snurb_hit, hit_list ) )
			{
				if( tmp->f == hit->f )
				{
					VREVERSE( tmp->norm, tmp->norm )
				}
			}
		}

		prev_dist = hit->dist;
	}
}

/* Find a uv point that is actually in the face */
int
Find_uv_in_fu( u_in, v_in, fu )
fastf_t *u_in, *v_in;
struct faceuse *fu;
{
	struct face *f;
	struct face_g_snurb *fg;
	struct loopuse *lu;
	fastf_t umin, umax, vmin, vmax;
	fastf_t u, v;
	int i;

	NMG_CK_FACEUSE( fu );

	f = fu->f_p;

	if( *f->g.magic_p != NMG_FACE_G_SNURB_MAGIC )
		return( 1 );

	fg = f->g.snurb_p;

	umin = fg->u.knots[0];
	umax = fg->u.knots[fg->u.k_size-1];
	vmin = fg->v.knots[0];
	vmax = fg->v.knots[fg->v.k_size-1];

	/* first try the center of the uv-plane */
	u = (umin + umax)/2.0;
	v = (vmin + vmax)/2.0;

	if( uv_in_fu( u, v, fu ) )
	{
		*u_in = u;
		*v_in = v;
		return( 0 );
	}

	/* no luck, try a few points along the diagonals of the UV plane */
	for( i=0 ; i<10 ; i++ )
	{
		u = umin + (umax - umin)*(double)(i + 1)/11.0;
		v = vmin + (vmax - vmin)*(double)(i + 1)/11.0;

		if( uv_in_fu( u, v, fu ) )
		{
			*u_in = u;
			*v_in = v;
			return( 0 );
		}
	}

	/* try other diagonal */
	for( i=0 ; i<10 ; i++ )
	{
		u = umin + (umax - umin)*(double)(i + 1)/11.0;
		v = vmax - (vmax - vmin)*(double)(i + 1)/11.0;

		if( uv_in_fu( u, v, fu ) )
		{
			*u_in = u;
			*v_in = v;
			return( 0 );
		}
	}

	/* last resort, look at loops */
	for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
	{
		struct edgeuse *eu;

		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
		{
			struct edge_g_cnurb *eg;

			if( *eu->g.magic_p != NMG_EDGE_G_CNURB_MAGIC )
				continue;

			eg = eu->g.cnurb_p;

			if(RT_NURB_IS_PT_RATIONAL( eg->pt_type ) )
			{
				u = eu->vu_p->a.cnurb_p->param[0] / eu->vu_p->a.cnurb_p->param[2];
				v = eu->vu_p->a.cnurb_p->param[1] / eu->vu_p->a.cnurb_p->param[2];
			}
			else
			{
				u = eu->vu_p->a.cnurb_p->param[0];
				v = eu->vu_p->a.cnurb_p->param[1];
			}

			if( uv_in_fu( u, v, fu ) )
			{
				*u_in = u;
				*v_in = v;
				return( 0 );
			}
		}
	}

	return( 1 );
}

/* find an xyz pt that s actually in the face
 * and the surface normal at that point
 */
int
Find_pt_in_fu( fu, pt, norm, hit_list )
struct faceuse *fu;
point_t pt;
vect_t norm;
struct bu_list *hit_list;
{
	struct face *f;
	struct face_g_snurb *fg;
	fastf_t u, v;
	fastf_t homo_hit[4];

	NMG_CK_FACEUSE( fu );

	f = fu->f_p;

	if( *f->g.magic_p != NMG_FACE_G_SNURB_MAGIC )
		return( 1 );

	fg = f->g.snurb_p;

	if( Find_uv_in_fu( &u, &v, fu ) )
		return( 1 );

	/* calculate actual hit point (x y z) */
	rt_nurb_s_eval( fg, u, v, homo_hit );
	if( RT_NURB_IS_PT_RATIONAL( fg->pt_type ) )
	{
		fastf_t inv_homo;

		inv_homo = 1.0/homo_hit[3];
		VSCALE( pt, homo_hit, inv_homo )
	}
	else
		VMOVE( pt, homo_hit )

	/* get surface normal */
	rt_nurb_s_norm( fg, u, v, norm );

	/* may need to reverse it */
	if( f->flip )
		VREVERSE( norm, norm )

	return( 0 );
}

void
Convtrimsurfs()
{

	int i,convsurf=0,totsurfs=0;
	struct model *m;
	struct nmgregion *r;
	struct shell *s;
	struct faceuse *fu;
	struct bu_list hit_list;

	bu_log( "\n\nConverting Trimmed Surface entities:\n" );

	if( RT_G_DEBUG & DEBUG_MEM_FULL )
		bu_mem_barriercheck();

	m = nmg_mm();
	r = nmg_mrsv( m );
	s = BU_LIST_FIRST( shell , &r->s_hd );

	for( i=0 ; i<totentities ; i++ )
	{
		if( dir[i]->type == 144 )
		{
			if( RT_G_DEBUG & DEBUG_MEM_FULL )
				bu_mem_barriercheck();

			totsurfs++;
			fu = trim_surf( i , s );
			if( fu )
			{
				nmg_face_bb( fu->f_p , &tol );
				convsurf++;
			}
			if( RT_G_DEBUG & DEBUG_MEM_FULL )
				bu_mem_barriercheck();

		}
	}

	nmg_rebound( m, &tol );

	bu_log( "\n\t%d surfaces converted, adusting surface normals....\n", convsurf );

	/* do some raytracing to get face orientations correct */
	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
	{
		struct faceuse *fu2;
		point_t mid_pt;
		vect_t ray_dir;

		if( fu->orientation != OT_SAME )
			continue;

		BU_LIST_INIT( &hit_list );
		if( Find_pt_in_fu( fu, mid_pt, ray_dir ) )
		{
			bu_log( "Convtrimsurfs: Cannot find a point in fu (x%x)\n", fu );
			nmg_pr_fu( fu, " " );
			bu_bomb( "Convtrimsurfs: Cannot find a point in fu\n" );
		}

		/* find intersections with all the faces
		 * must include current fu since there
		 * may be more than one intersection
		 */
		for( BU_LIST_FOR( fu2, faceuse, &s->fu_hd ) )
		{
			if( fu2->orientation != OT_SAME )
				continue;

			find_intersections( fu2, mid_pt, ray_dir, &hit_list );
		}

		adjust_flips( &hit_list, ray_dir );

		while( BU_LIST_NON_EMPTY( &hit_list ) )
		{
			struct snurb_hit *myhit;

			myhit = BU_LIST_FIRST( snurb_hit, &hit_list );
			BU_LIST_DEQUEUE( &myhit->l );

			bu_free( (char *)myhit, "myhit" );
		}

	}

	bu_log( "Converted %d Trimmed Sufaces successfully out of %d total Trimmed Sufaces\n" , convsurf , totsurfs );

	if( RT_G_DEBUG & DEBUG_MEM_FULL )
		bu_mem_barriercheck();

	if( convsurf )
	{
		(void)nmg_model_vertex_fuse( m, &tol );

		if( curr_file->obj_name )
			mk_nmg( fdout , curr_file->obj_name , m );
		else
			mk_nmg( fdout , "Trimmed_surf" , m );
	}
	if( RT_G_DEBUG & DEBUG_MEM_FULL )
		bu_mem_barriercheck();


	nmg_km( m );

	if( RT_G_DEBUG & DEBUG_MEM_FULL )
		bu_mem_barriercheck();

}
@


11.22
log
@update copyright to include span through 2003
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/iges/trimsurf.c,v 11.21 2001/08/08 20:25:12 jra Exp $ (BRL)";
@


11.21
log
@Lint
@
text
@d11 1
a11 1
 *	This software is Copyright (C) 1994 by the United States Army
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/iges/trimsurf.c,v 11.20 2001/05/17 20:05:03 morrison Exp $ (BRL)";
@


11.21.4.1
log
@sync branch with HEAD
@
text
@d11 1
a11 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.21.6.1
log
@sync to HEAD...
@
text
@d11 1
a11 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/iges/trimsurf.c,v 11.22 2004/02/02 17:39:05 morrison Exp $ (BRL)";
@


11.21.12.1
log
@merge from HEAD
@
text
@d11 1
a11 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/iges/trimsurf.c,v 11.22 2004/02/02 17:39:05 morrison Exp $ (BRL)";
@


11.21.12.2
log
@merge from head
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/iges/trimsurf.c,v 11.21.12.1 2004/02/12 19:41:40 erikg Exp $ (BRL)";
@


11.20
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/iges/trimsurf.c,v 11.19 2001/02/06 15:13:43 jra Exp $ (BRL)";
d825 1
a825 1
	fastf_t u,v;
d852 1
a852 1
		int u_index,v_index;
d979 1
a979 1
	int *inner_loop;
@


11.19
log
@Mods to get IGES working with new database format (v5)
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/iges/trimsurf.c,v 11.18 2000/08/24 04:10:49 mike Exp $ (BRL)";
d1489 1
a1489 1
	if( rt_g.debug & DEBUG_MEM_FULL )
d1500 1
a1500 1
			if( rt_g.debug & DEBUG_MEM_FULL )
d1510 1
a1510 1
			if( rt_g.debug & DEBUG_MEM_FULL )
d1566 1
a1566 1
	if( rt_g.debug & DEBUG_MEM_FULL )
d1578 1
a1578 1
	if( rt_g.debug & DEBUG_MEM_FULL )
d1584 1
a1584 1
	if( rt_g.debug & DEBUG_MEM_FULL )
@


11.18
log
@
mk_addmember
RCSid
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/iges/trimsurf.c,v 11.17 2000/03/29 18:42:51 mike Exp $ (BRL)";
d1022 2
a1023 1
		bu_free( (char *)inner_loop , "trim_surf: inner_loop" );
@


11.17
log
@
Converted from Release 4 names to know about libbu and libbn
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/iges/trimsurf.c,v 11.16 2000/01/05 14:16:09 jra Exp $ (BRL)";
@


11.17.2.1
log
@A minor bug fix (was freeing memory that hadn't been malooced)
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/iges/trimsurf.c,v 11.17 2000/03/29 18:42:51 mike Exp $ (BRL)";
d1022 1
a1022 2
		if( inner_loop_count )
			bu_free( (char *)inner_loop , "trim_surf: inner_loop" );
@


11.16
log
@Eliminated some unused variables
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/iges/trimsurf.c,v 11.15 1998/05/12 18:31:27 jra Exp $ (BRL)";
d64 1
a64 1
		rt_log( "Illegal parameter pointer for entity D%07d (%s)\n" ,
d73 1
a73 1
		rt_log( "Only B-Spline surfaces allowed for faces (found type %d)\n", entity_type );
d103 2
a104 2
		RT_LIST_INIT( &srf->l );
		RT_LIST_INIT( &srf->f_hd );
d113 1
a113 1
		srf->u.knots = (fastf_t *) rt_malloc ( 
d115 1
a115 1
		srf->v.knots = (fastf_t *) rt_malloc ( 
d123 1
a123 1
		srf->ctl_points = ( fastf_t *) rt_malloc( 
d214 1
a214 1
	ctl_points = (fastf_t *)rt_calloc( ncoords*crv->c_size, sizeof( fastf_t ),
d220 1
a220 1
	knots = (fastf_t *)rt_calloc( crv->k.k_size, sizeof( fastf_t ),
d249 1
a249 1
		rt_log( "Get_cnurb: Illegal parameter pointer for entity D%07d (%s)\n" ,
d259 1
a259 1
		rt_log( "Get_cnurb: Was expecting spline curve, got type %d\n" , entity_type );
d391 1
a391 1
	for( RT_LIST_FOR( vu1, vertexuse, &vu->v_p->vu_hd ) )
d416 1
a416 1
		rt_log( "Illegal parameter pointer for entity D%07d (%s)\n" ,
d432 1
a432 1
				curve_list = (int *)rt_calloc( curve_count , sizeof( int ),
d441 1
a441 1
				rt_free( (char *)curve_list , "Add_trim_curve: curve_list" );
d455 1
a455 1
			eu = RT_LIST_LAST( edgeuse, &lu->down_hd );
d509 1
a509 1
				eu = RT_LIST_LAST( edgeuse, &lu->down_hd );
d532 1
a532 1
			rt_log( "Conic Arc not yet handled as a trimming curve\n" );
d542 1
a542 1
			eu = RT_LIST_LAST( edgeuse, &lu->down_hd );
d563 1
a563 1
			rt_log( "Curves of type %d are not yet handled for trimmed surfaces\n", entity_type );
d591 1
a591 1
		rt_log( "Illegal parameter pointer for entity D%07d (%s)\n" ,
d600 1
a600 1
	vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
d611 1
a611 1
				curve_list = (int *)rt_calloc( curve_count , sizeof( int ),
d620 1
a620 1
				rt_free( (char *)curve_list , "Make_trim_loop: curve_list" );
d623 1
a623 1
				eu = RT_LIST_LAST( edgeuse, &lu->down_hd );
d640 1
a640 1
				struct rt_list curv_hd;
d660 1
a660 1
				RT_LIST_INIT( &curv_hd );
d662 2
a663 2
				crv1 = RT_LIST_FIRST( edge_g_cnurb, &curv_hd );
				crv2 = RT_LIST_LAST( edge_g_cnurb, &curv_hd );
d666 1
a666 1
				eu = RT_LIST_LAST( edgeuse, &lu->down_hd );
d698 1
a698 1
			rt_log( "Conic Arc not yet handled as a trimming curve\n" );
d705 1
a705 1
				struct rt_list curv_hd;
d713 1
a713 1
				RT_LIST_INIT( &curv_hd );
d715 2
a716 2
				crv1 = RT_LIST_FIRST( edge_g_cnurb, &curv_hd );
				crv2 = RT_LIST_LAST( edge_g_cnurb, &curv_hd );
d718 1
a718 1
				eu = RT_LIST_LAST( edgeuse, &lu->down_hd );
d766 1
a766 1
			rt_log( "Curves of type %d are not yet handled for trimmed surfaces\n", entity_type );
d791 1
a791 1
		rt_log( "Illegal parameter pointer for entity D%07d (%s)\n" ,
d800 1
a800 1
		rt_log( "Expected Curve on a Parametric Surface, found %s\n" , iges_type( entity_type ) );
d806 1
a806 1
		rt_log( "Curve is on surface at DE %d, should be on surface at DE %d\n", surf_de, on_surf_de );
d843 1
a843 1
	vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
d850 1
a850 1
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d891 1
a891 1
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d962 1
a962 1
	RT_LIST_APPEND( &srf->f_hd, &f->l );
d997 1
a997 1
		rt_log( "Illegal parameter pointer for entity D%07d (%s)\n" ,
d1006 1
a1006 1
		rt_log( "Expected Trimmed Surface Entity found type %d\n" );
d1015 1
a1015 1
		inner_loop = (int *)rt_calloc( inner_loop_count , sizeof( int ) , "trim_surf: innerloop" );
d1022 1
a1022 1
		rt_free( (char *)inner_loop , "trim_surf: inner_loop" );
d1042 1
a1042 1
	kill_lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
d1107 3
a1109 3
		RT_LIST_DEQUEUE( &lu->l );
		RT_LIST_DEQUEUE( &lu->lumate_p->l );
		RT_LIST_APPEND( &fu->lu_hd , &lu->lumate_p->l );
d1111 1
a1111 1
		RT_LIST_APPEND( &fu->fumate_p->lu_hd , &lu->l );
d1116 1
a1116 1
		rt_free( (char *)inner_loop , "trim_surf: inner_loop" );
d1486 1
a1486 1
	rt_log( "\n\nConverting Trimmed Surface entities:\n" );
d1489 1
a1489 1
		rt_mem_barriercheck();
d1493 1
a1493 1
	s = RT_LIST_FIRST( shell , &r->s_hd );
d1500 1
a1500 1
				rt_mem_barriercheck();
d1510 1
a1510 1
				rt_mem_barriercheck();
d1563 1
a1563 1
	rt_log( "Converted %d Trimmed Sufaces successfully out of %d total Trimmed Sufaces\n" , convsurf , totsurfs );
d1566 1
a1566 1
		rt_mem_barriercheck();
d1578 1
a1578 1
		rt_mem_barriercheck();
d1584 1
a1584 1
		rt_mem_barriercheck();
@


11.15
log
@Fixed some bugs.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/iges/RCS/trimsurf.c,v 11.14 1997/09/18 20:35:54 jra Exp jra $ (BRL)";
d52 1
a52 3
	int i,j;
	int num_knots;
	int num_pts;
a57 2
	fastf_t u_min,u_max;
	fastf_t v_min,v_max;
a191 1
	u_min = a;
a192 1
	u_max = a;
a193 1
	v_min = a;
a194 1
	v_max = a;
d239 1
a239 1
	int i,j;
a406 1
	fastf_t u,v;
a574 1
	struct edge_g_cnurb *crv;
a579 2
	point_t pt_on_srf;
	vect_t uvw;
a820 1
	struct shell *s;
a973 1
	struct loopuse *lumate;
a974 1
	struct nurb_verts *nurb_v;
a977 4
	int nverts;
	int u_order,v_order,n_u,n_v,n_rows,n_cols,pt_type;
	fastf_t *ukv,*vkv,*mesh,u_min,u_max,v_min,v_max;
	int coords;
a1024 1
	coords = RT_NURB_EXTRACT_COORDS( srf->pt_type );
a1211 2
			int ot_sames, ot_opps;
			struct loopuse *lu;
a1483 1
	struct bu_list bezier;
@


11.14
log
@Mod for pmalloc.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/iges/RCS/trimsurf.c,v 11.13 1997/09/09 13:46:34 jra Exp jra $ (BRL)";
a293 1

d309 1
a309 1
	/* vertices */
a340 1

a569 1

d633 2
d636 9
a644 1
				nmg_keu( eu );
d837 3
a839 3
	struct vertex *v[4];
	fastf_t knots[4];
	fastf_t ctl_points[4];
d861 2
a862 4
	knots[0] = 0.0;
	knots[1] = 0.0;
	knots[2] = 1.0;
	knots[3] = 1.0;
d875 2
a876 4
				ctl_points[0] = 0.0;
				ctl_points[1] = 0.0;
				ctl_points[2] = 1.0;
				ctl_points[3] = 0.0;
d881 2
a882 4
				ctl_points[0] = 0.0;
				ctl_points[1] = 1.0;
				ctl_points[2] = 1.0;
				ctl_points[3] = 1.0;
d887 2
a888 4
				ctl_points[0] = 1.0;
				ctl_points[1] = 1.0;
				ctl_points[2] = 0.0;
				ctl_points[3] = 1.0;
d893 2
a894 4
				ctl_points[0] = 0.0;
				ctl_points[1] = 1.0;
				ctl_points[2] = 0.0;
				ctl_points[3] = 0.0;
d898 11
d912 34
d947 1
d1007 6
d1052 7
d1065 7
d1073 1
d1075 7
d1083 7
d1091 1
d1095 7
d1103 5
d1556 1
@


11.13
log
@Added capability to adjust face flip flag using TNURB raytracing.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/iges/RCS/trimsurf.c,v 11.12 1997/01/08 03:00:34 mike Exp $ (BRL)";
d101 1
a101 1
		srf = rt_nurb_new_snurb( u_order, v_order, n_u, n_v, n_rows, n_cols, pt_type );
d1124 1
a1124 1
	rt_nurb_bezier( &bezier, fg );
d1133 1
a1133 1
		hp = rt_nurb_intersect( srf, pl1, pl2, UV_TOL );
d1209 1
a1209 1
		rt_nurb_free_snurb( srf );
@


11.12
log
@Changed to use relative path on #include
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/iges/RCS/trimsurf.c,v 11.11 1996/07/15 19:19:47 jra Exp mike $ (BRL)";
d31 2
d35 9
d355 1
d362 21
d391 5
a645 1
rt_log( "Full circle\n" );
a712 1
rt_log( "CLosed loop spline curve\n" );
d1052 354
d1415 2
d1445 47
@


11.11
log
@Minor Mods for IRIX 6.2
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/iges/RCS/trimsurf.c,v 11.10 1995/12/08 17:49:39 jra Exp jra $ (BRL)";
d25 1
a25 1
#include "/m/cad/librt/debug.h"
@


11.10
log
@Mods to get trimmed surfaces with subfigures working.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/iges/RCS/trimsurf.c,v 11.9 1995/12/05 22:02:45 jra Exp jra $ (BRL)";
d360 1
d694 1
d809 1
a809 1
	if( srf->order[0] < 3 && srf->order[2] < 3 )
@


11.9
log
@Checkpoint in mods for handling assemblies (subfigures).
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/iges/RCS/trimsurf.c,v 11.8 1995/12/04 19:35:47 jra Exp jra $ (BRL)";
d25 1
d1026 3
d1037 3
d1047 3
d1055 14
a1068 1
	(void)nmg_model_vertex_fuse( m, &tol );
a1069 4
	if( curr_file->obj_name )
		mk_nmg( fdout , curr_file->obj_name , m );
	else
		mk_nmg( fdout , "Trimmed_surf" , m );
d1072 4
@


11.8
log
@Mods for new SNURB struct.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/iges/RCS/trimsurf.c,v 11.7 1995/12/01 15:47:52 mike Exp jra $ (BRL)";
d1047 2
a1048 2
	if( solid_name )
		mk_nmg( fdout , solid_name , m );
@


11.7
log
@LIBNURBS has been converted over to using t-NURBS NMG data structures
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/iges/RCS/trimsurf.c,v 11.6 1995/11/30 15:38:47 jra Exp $ (BRL)";
d33 1
a33 1
Get_nurb_surf( entityno )
d35 1
d88 29
a116 1
	srf = rt_nurb_new_snurb( u_order, v_order, n_u, n_v, n_rows, n_cols, pt_type );
d118 3
d446 1
a446 3
			nmg_edge_g_cnurb( eu, 2, 0, (fastf_t *)NULL, 2,
				RT_NURB_MAKE_PT_TYPE( 2, RT_NURB_PT_UV, RT_NURB_PT_NONRAT),
				 (fastf_t *)NULL );
d877 1
a877 5
	fastf_t *ukv;
	fastf_t *vkv;
	fastf_t *mesh;
	int ncoords;
	int i;
d882 2
a883 9
	ncoords = RT_NURB_EXTRACT_COORDS( srf->pt_type );

	ukv = (fastf_t *)rt_calloc( srf->u.k_size, sizeof( fastf_t ), "Assign_surface_to_fu: ukv" );
	for( i=0 ; i<srf->u.k_size ; i++ )
		ukv[i] = srf->u.knots[i];

	vkv = (fastf_t *)rt_calloc( srf->v.k_size, sizeof( fastf_t ), "Assign_surface_to_fu: vkv" );
	for( i=0 ; i<srf->v.k_size ; i++ )
		vkv[i] = srf->v.knots[i];
d885 2
a886 2
	mesh = (fastf_t *)rt_calloc( srf->s_size[0]*srf->s_size[1]*ncoords, sizeof( fastf_t ),
		"Assign_surface_to_fu: mesh" );
d888 6
a893 5
	for( i=0 ; i<srf->s_size[0]*srf->s_size[1]*ncoords ; i++ )
		mesh[i] = srf->ctl_points[i];

	nmg_face_g_snurb( fu, srf->order[0], srf->order[1], srf->u.k_size, srf->v.k_size,
			ukv, vkv, srf->s_size[0], srf->s_size[1], srf->pt_type, mesh );
d901 1
d918 1
d922 3
d951 1
a951 1
	if( (srf=Get_nurb_surf( (surf_de-1)/2 )) == (struct face_g_snurb *)NULL )
d966 1
d976 10
d987 1
d990 14
a1003 1
	rt_nurb_free_snurb( srf );
d1008 2
d1042 1
a1042 1
	Orient_loops( r );
@


11.6
log
@Added call to Orient_loops() for trimmed surfaces.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/iges/RCS/trimsurf.c,v 11.5 1995/11/28 21:35:45 jra Exp jra $ (BRL)";
d32 1
a32 1
struct snurb *
d36 1
a36 1
	struct snurb *srf;
d45 1
a45 1
	int n_u_knots,n_v_knots;
d57 1
a57 1
		return( (struct snurb *)NULL );
d65 1
a65 1
		return( (struct snurb *)NULL );
d85 3
a87 3
	n_u_knots = n_cols+u_order;
	n_v_knots = n_rows+v_order;
	srf = rt_nurb_new_snurb( u_order, v_order, n_u_knots, n_v_knots, n_rows, n_cols, pt_type );
d90 1
a90 1
	for( i=0 ; i<n_u_knots ; i++ )
d93 1
a93 1
		srf->u_knots.knots[i] = a;
d95 1
a95 1
	for( i=0 ; i<n_v_knots ; i++ )
d98 1
a98 1
		srf->v_knots.knots[i] = a;
d102 1
a102 1
	if( srf->v_knots.knots[0] < 0.0 )
d104 3
a106 3
		v_translation = (-srf->v_knots.knots[0]);
		for( i=0 ; i<n_v_knots ; i++ )
			srf->v_knots.knots[i] += v_translation;
d111 1
a111 1
	if( srf->u_knots.knots[0] < 0.0 )
d113 3
a115 3
		u_translation = (-srf->u_knots.knots[0]);
		for( i=0 ; i<n_u_knots ; i++ )
			srf->u_knots.knots[i] += u_translation;
d166 1
a166 1
struct cnurb *crv;
d184 1
a184 1
	knots = (fastf_t *)rt_calloc( crv->knot.k_size, sizeof( fastf_t ),
d187 2
a188 2
	for( i=0 ; i<crv->knot.k_size; i++ )
		knots[i] = crv->knot.knots[i];
d190 1
a190 1
	nmg_edge_g_cnurb( eu, crv->order, crv->knot.k_size, knots, crv->c_size,
d194 1
a194 1
struct cnurb *
d198 1
a198 1
	struct cnurb *crv;
d215 1
a215 1
		return( (struct cnurb *)NULL );
d224 1
a224 1
		return( (struct cnurb *)NULL );
d255 1
a255 1
		crv->knot.knots[i] = a;
d306 1
a306 1
struct snurb *srf;
d337 1
a337 1
struct snurb *srf;
d340 1
a340 1
	struct cnurb *crv;
d420 1
a420 1
				struct cnurb *crv;
d437 1
a437 1
				/* build cnurb arc */
d514 1
a514 1
struct snurb *srf;
d517 1
a517 1
	struct cnurb *crv;
d572 2
a573 2
				struct cnurb *crv;
				struct cnurb *crv1,*crv2;
d592 1
a592 1
				/* build cnurb circle */
d598 2
a599 2
				crv1 = RT_LIST_FIRST( cnurb, &curv_hd );
				crv2 = RT_LIST_LAST( cnurb, &curv_hd );
d639 2
a640 2
				struct cnurb *crv;
				struct cnurb *crv1,*crv2;
d652 2
a653 2
				crv1 = RT_LIST_FIRST( cnurb, &curv_hd );
				crv2 = RT_LIST_LAST( cnurb, &curv_hd );
d713 1
a713 1
struct snurb *srf;
d754 1
a754 1
struct snurb *srf;
d845 1
a845 1
struct snurb *srf;
d858 7
a864 7
	ukv = (fastf_t *)rt_calloc( srf->u_knots.k_size, sizeof( fastf_t ), "Assign_surface_to_fu: ukv" );
	for( i=0 ; i<srf->u_knots.k_size ; i++ )
		ukv[i] = srf->u_knots.knots[i];

	vkv = (fastf_t *)rt_calloc( srf->v_knots.k_size, sizeof( fastf_t ), "Assign_surface_to_fu: vkv" );
	for( i=0 ; i<srf->v_knots.k_size ; i++ )
		vkv[i] = srf->v_knots.knots[i];
d872 1
a872 1
	nmg_face_g_snurb( fu, srf->order[0], srf->order[1], srf->u_knots.k_size, srf->v_knots.k_size,
d881 1
a881 1
	struct snurb *srf;
d891 1
a891 1
	int u_order,v_order,n_u_knots,n_v_knots,n_rows,n_cols,pt_type;
d926 1
a926 1
	if( (srf=Get_nurb_surf( (surf_de-1)/2 )) == (struct snurb *)NULL )
@


11.5
log
@Mods to handle TNURB BREP. Also added RT_EXTERNS to iges_struct.h.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/iges/RCS/trimsurf.c,v 11.4 1995/06/29 14:43:48 jra Exp jra $ (BRL)";
d990 1
@


11.4
log
@Working version (circle trimcurves still don't work).
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/iges/RCS/trimsurf.c,v 11.3 1995/06/29 11:55:27 jra Exp jra $ (BRL)";
a22 8
#include "conf.h"

#include <stdio.h>
#include "machine.h"
#include "vmath.h"
#include "nmg.h"
#include "raytrace.h"
#include "nurb.h"
a24 1
#include "wdb.h"
a29 2
RT_EXTERN( struct cnurb *rt_arc2d_to_cnurb, ( point_t center, point_t start, point_t end, int pt_type, struct rt_tol *tol ) );

d37 1
d133 1
a133 1
				srf->ctl_points[i*ncoords] = a*srf->ctl_points[i*ncoords+3];
d135 1
a135 1
				srf->ctl_points[i*ncoords] = a;
d138 1
a138 1
				srf->ctl_points[i*ncoords+1] = a*srf->ctl_points[i*ncoords+3];
d140 1
a140 1
				srf->ctl_points[i*ncoords+1] = a;
d143 1
a143 1
				srf->ctl_points[i*ncoords+2] = a*srf->ctl_points[i*ncoords+3];
d145 4
a148 1
				srf->ctl_points[i*ncoords+2] = a;
d199 1
d283 2
a284 2
			crv->ctl_points[i*ncoords] = (x + u_translation) * crv->ctl_points[i*ncoords+2];
			crv->ctl_points[i*ncoords+1] = (y + v_translation) * crv->ctl_points[i*ncoords+2];
d288 2
a289 2
			crv->ctl_points[i*ncoords] = x + u_translation;
			crv->ctl_points[i*ncoords+1] = y + v_translation;
d291 6
d346 1
d388 4
d400 1
a400 5
			{
				u = x + u_translation;
				v = y + v_translation;
				Assign_vu_geom( eu->vu_p, u, v, srf );
			}
d406 4
d411 1
a411 4
			/* assign geometry to vertex of new edgeuse */
			u = x + u_translation;
			v = y + v_translation;
			Assign_vu_geom( new_eu->vu_p, u, v, srf );
d440 9
d456 2
a457 5
				{
					u = start[X];
					v = start[Y];
					Assign_vu_geom( eu->vu_p, u, v, srf );
				}
d460 4
a463 3
				u = end[X];
				v = end[Y];
				Assign_vu_geom( new_eu->vu_p, u, v, srf );
d570 1
a570 33
		case 110:	/* line */

			/* get sart point */
			Readdbl( &x , "" );
			Readdbl( &y , "" );
			Readdbl( &z , "" );

			vp = eu->vu_p->v_p;

			/* if old edge doesn't have vertex geometry, assign some */
			if( !vp->vg_p )
			{
				u = x + u_translation;
				v = y + v_translation;
				Assign_vu_geom( eu->vu_p, u, v, srf );
			}

			/* read terminate point */
			Readdbl( &x , "" );
			Readdbl( &y , "" );
			Readdbl( &z , "" );

			/* assign geometry to vertex of eu mate */
			u = x + u_translation;
			v = y + v_translation;
			Assign_vu_geom( eu->eumate_p->vu_p, u, v, srf );

			/* assign edge geometry */
			nmg_edge_g_cnurb( eu, 2, 0, (fastf_t *)NULL, 2,
				RT_NURB_MAKE_PT_TYPE( 3, RT_NURB_PT_UV, RT_NURB_PT_RATIONAL),
				 (fastf_t *)NULL );
			break;
		case 100:	/* circular arc */
d573 1
d575 2
d582 1
a582 1
				VSET( center, y+u_translation, x+v_translation, z )
d586 1
a586 1
				VSET( start, y+u_translation, x+v_translation, z )
d590 1
a590 1
				VSET( end, y+u_translation, x+v_translation, z )
d592 1
a592 1
				/* build cnurb arc */
d595 9
d609 2
a610 2
					u = start[X];
					v = start[Y];
d614 1
a614 1
				vp = eu->eumate_p->vu_p->v_p;
d617 4
a620 4
					/* Assign geometry to eu mate vertex */
					u = end[X];
					v = end[Y];
					Assign_vu_geom( eu->eumate_p->vu_p, u, v, srf );
d624 2
a625 1
				Assign_cnurb_to_eu( eu, crv );
d628 2
d637 5
a641 3
		case 126:	/* spline curve */
			/* Get spline curve */
			crv = Get_cnurb( entity_no );
d643 15
a657 1
			ncoords = RT_NURB_EXTRACT_COORDS( crv->pt_type );
d659 15
a673 1
			vp = eu->vu_p->v_p;
d675 16
a690 4
			/* if old edge doesn't have vertex geometry, assign some */
			if( !vp->vg_p )
				Assign_vu_geom( eu->vu_p, crv->ctl_points[0],
					crv->ctl_points[1], srf );
d692 3
a694 5
			/* Assign geometry to eu mate vertex */
			vp = eu->eumate_p->vu_p->v_p;
			if( !vp->vg_p )
				Assign_vu_geom( eu->eumate_p->vu_p, crv->ctl_points[(crv->c_size-1)*ncoords],
					crv->ctl_points[(crv->c_size-1)*ncoords+1], srf );
d696 4
a699 5
			/* Assign edge geometry */
			Assign_cnurb_to_eu( eu, crv );

			rt_nurb_free_cnurb( crv );

d736 1
a736 1
		rt_log( "Expected Curve on a Parametric Surface, found entity type %d\n" , entity_type );
d994 5
a998 1
	mk_nmg( fdout , "Trimmed_surf" , m );
@


11.3
log
@Another checkpoint.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/iges/RCS/trimsurf.c,v 11.2 1995/06/28 15:24:34 jra Exp $ (BRL)";
a59 1
rt_log( "Get_nurb_surf( %d )\n" , entityno );
d78 2
a81 2
	n_cols = i+1;
	Readint( &i , "" );
d89 1
a89 4
if( rational )
rt_log( "\tSurface is rational\n" );
else
rt_log( "\tSurface is not rational\n" );
d100 1
a100 1
	for( i=0 ; i<n_v_knots ; i++ )
d103 1
a103 1
		srf->v_knots.knots[i] = a;
d105 1
a105 1
	for( i=0 ; i<n_u_knots ; i++ )
d108 1
a108 1
		srf->u_knots.knots[i] = a;
d130 11
a140 11
rt_log( "\t translations are %g and %g\n" , u_translation, v_translation );
	for( j=0 ; j<n_cols ; j++ )
		for( i=0 ; i<n_rows ; i++ )
		{
			Readdbl( &a , "" );
			if( rational )
				srf->ctl_points[CTL_INDEX(i,j)+3] = a;
		}
	for( j=0 ; j<n_cols ; j++ )
		for( i=0 ; i<n_rows ; i++ )
		{
d143 1
a143 1
				srf->ctl_points[CTL_INDEX(i,j)] = a*srf->ctl_points[CTL_INDEX(i,j)+3];
d145 1
a145 1
				srf->ctl_points[CTL_INDEX(i,j)] = a;
d148 1
a148 1
				srf->ctl_points[CTL_INDEX(i,j)+1] = a*srf->ctl_points[CTL_INDEX(i,j)+3];
d150 1
a150 1
				srf->ctl_points[CTL_INDEX(i,j)+1] = a;
d153 1
a153 1
				srf->ctl_points[CTL_INDEX(i,j)+2] = a*srf->ctl_points[CTL_INDEX(i,j)+3];
d155 3
a157 2
				srf->ctl_points[CTL_INDEX(i,j)+2] = a;
		}
a215 1
rt_log( "Get_cnurb( %d )\n" ,  entity_no );
a241 4
if( rational )
rt_log( "\tCurve is rational\n") ;
else
rt_log( "\tCurve is not rational\n") ;
d289 2
a290 2
			crv->ctl_points[i*ncoords] = (y + u_translation) * crv->ctl_points[i*ncoords+2];
			crv->ctl_points[i*ncoords+1] = (x + v_translation) * crv->ctl_points[i*ncoords+2];
d294 2
a295 2
			crv->ctl_points[i*ncoords] = y + u_translation;
			crv->ctl_points[i*ncoords+1] = x + v_translation;
a316 2
rt_log( "In Assign_vu_geom( vu, %g, %g, srf )\n", u, v );

a317 1
rt_log( "rt_nurb_s_eval gives ( %g %g %g %g )\n" , V4ARGS( pt_on_srf ) );
a323 1
rt_log( "After scaling: ( %g %g %g )\n", V3ARGS( pt_on_srf ) );
d325 1
a348 2
rt_log( "in Add_trim_curve, entity_no = %d\n", entity_no );

a367 1
rt_log( "\tComposite curve\n" );
d369 1
a369 1
				Readint( &curve_count , "Curve Count: " );
d374 1
a374 1
					Readint( &curve_list[i] , "\t Curve: " );
a382 1
rt_log( "\tLines\n" );
d384 3
a386 3
			Readdbl( &x , "X: " );
			Readdbl( &y , "Y: " );
			Readdbl( &z , "Z: " );
d396 2
a397 3
				u = y + u_translation;
				v = x + v_translation;
rt_log( "\t\tstart point at ( %g %g ) translated to ( %g %g )\n", x, y, u, v );
d402 3
a404 3
			Readdbl( &x , "X: " );
			Readdbl( &y , "Y: " );
			Readdbl( &z , "Z: " );
d407 2
a408 3
			u = y + u_translation;
			v = x + v_translation;
rt_log( "\t\tend point at ( %g %g ) translated to ( %g %g )\n", x, y, u, v );
a419 1
rt_log( "In Add_trim_curve; ARC:\n" );
a436 2
rt_log( "\t ARC:\n" );
rt_nurb_c_print( crv );
a438 1
rt_log( "split eu\n" );
a445 1
rt_log( "Assign geometry to start of eu\n" );
a451 1
rt_log( "Assign geometry to end of eu\n" );
a456 1
rt_log( "Assign crv geometry to eu\n" );
a468 1
rt_log( "\tSpline curve\n" );
a469 1
rt_nurb_c_print( crv );
d472 1
a472 1
rt_log( "split eu \n" );
a480 1
rt_log( "Assign geometry to start of eu\n" );
a485 1
rt_log( "Assign geometry to end of eu\n" );
a489 1
rt_log( "Assign crv geometry to eu\n" );
a521 2
rt_log( "In Make_trim_loop, entity_no = %d\n", entity_no );

a544 1
rt_log( "Composite curve\n" );
d546 1
a546 1
				Readint( &curve_count , "Curve Count: " );
d551 1
a551 1
					Readint( &curve_list[i] , "\tCurve: " );
d557 2
a567 3
			/* Split last edge in loop */
			eu = RT_LIST_LAST( edgeuse, &lu->down_hd );
			new_eu = nmg_eusplit( (struct vertex *)NULL, eu, 0 );
d573 2
a574 2
				u = y + u_translation;
				v = x + v_translation;
d583 4
a586 4
			/* assign geometry to vertex of new edgeuse */
			u = y + u_translation;
			v = x + v_translation;
			Assign_vu_geom( new_eu->vu_p, u, v, srf );
a614 3
				/* add a new edge to loop */
				eu = RT_LIST_LAST( edgeuse, &lu->down_hd );
				new_eu = nmg_eusplit( (struct vertex *)NULL, eu, 0 );
d625 8
a632 4
				/* Assign geometry to new vertex */
				u = end[X];
				v = end[Y];
				Assign_vu_geom( new_eu->vu_p, u, v, srf );
a650 3
			/* add a new edge to loop */
			eu = RT_LIST_LAST( edgeuse, &lu->down_hd );
			new_eu = nmg_eusplit( (struct vertex *)NULL, eu, 0 );
d656 1
a656 1
					crv->ctl_points[1], v, srf );
d658 4
a661 2
			/* Assign geometry to new vertex */
			Assign_vu_geom( new_eu->vu_p, crv->ctl_points[(crv->c_size-1)*ncoords],
a673 2
	eu = RT_LIST_LAST( edgeuse, &lu->down_hd );
	nmg_keu( eu );
a689 2
rt_log( "In Make_loop, entity_no = %d:\n", entity_no );

d717 1
a717 1
nmg_pr_lu_briefly( lu, " " );
a865 1
rt_log( "trim_surf( %d )\n", entityno );
a876 1
rt_log( "in trim_surf\n" );
a900 2
rt_log( "In Trim_surf:\n" );
rt_nurb_s_print( " " , srf );
a912 2
	{
rt_log( "\tCalling Make_default_loop\n" );
a913 1
	}
a914 2
	{
rt_log( "\tCalling Make_loop\n" );
a915 1
	}
a941 2
rt_g.NMG_debug = 1;

a960 1
/*	(void)nmg_model_fuse( m , &tol ); */
a961 3

nmg_vmodel( m );
nmg_pr_m( m );
@


11.2
log
@Checkpoint.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/iges/RCS/trimsurf.c,v 11.1 1995/01/04 10:08:16 mike Rel4_4 jra $ (BRL)";
d90 4
d134 1
d146 4
a149 1
			srf->ctl_points[CTL_INDEX(i,j)] = a;
d151 4
a154 1
			srf->ctl_points[CTL_INDEX(i,j)+1] = a;
d156 4
a159 1
			srf->ctl_points[CTL_INDEX(i,j)+2] = a;
d246 4
d295 10
a304 2
		crv->ctl_points[i*ncoords] = y + u_translation;
		crv->ctl_points[i*ncoords+1] = x + v_translation;
d317 1
a317 1
	point_t pt_on_srf;
d323 4
d328 9
d1010 2
a1011 1
	(void)nmg_model_fuse( m , &tol );
@


11.1
log
@Release_4.4
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/iges/RCS/trimsurf.c,v 1.4 94/11/04 15:56:25 jra Exp $ (BRL)";
d35 11
a45 1
struct nurb_verts
d47 111
a157 4
	point_t pt;
	vect_t uvw;
	struct vertex *v;
};
d160 33
a192 6
set_edge_vertices_m( fu , nverts , nurb_v , vert_count , entityno )
struct faceuse *fu;
int nverts;
struct nurb_verts *nurb_v;
int *vert_count;
int entityno;
d194 1
d196 8
a203 1
	int i;
d205 56
a260 1
	point_t pt;
d262 2
a263 1
	if( dir[entityno]->param <= pstart )
d265 14
a278 3
		printf( "Illegal parameter pointer for entity D%07d (%s)\n" ,
				dir[entityno]->direct , dir[entityno]->name );
		return;
d281 49
a329 1
	if( *vert_count == nverts-1 )
d331 1
d333 1
a333 1
	Readrec( dir[entityno]->param );
d335 1
d338 1
a338 1
		case 102:
d342 1
d344 4
a347 2
				Readint( &curve_count , "" );
				curve_list = (int *)rt_calloc( curve_count , sizeof( int ) , "set_edge_vertices_m: curve_list" );
d349 2
a350 1
					Readint( &curve_list[i] , "" );
d352 3
a354 2
					set_edge_vertices_m( fu , nverts , nurb_v , vert_count , (curve_list[i]-1)/2 );
				rt_free( (char *)curve_list , "set_edge_vertices_m: curve_list" );
d357 14
a370 5
		case 110:
			Readcnv( &x , "" );
			Readcnv( &y , "" );
			Readcnv( &z , "" );
			if( *vert_count == 0 )
d372 4
a375 3
				VSET( pt , x , y , z );
				MAT4X3PNT( nurb_v[0].pt , *dir[entityno]->rot , pt );
				nmg_vertex_gv( nurb_v[0].v , nurb_v[0].pt );
d377 16
a392 7
			Readcnv( &x , "" );
			Readcnv( &y , "" );
			Readcnv( &z , "" );
			(*vert_count)++;
			VSET( pt , x , y , z )
			MAT4X3PNT( nurb_v[*vert_count].pt , *dir[entityno]->rot , pt );
			nmg_vertex_gv( nurb_v[*vert_count].v , nurb_v[*vert_count].pt );
d394 1
a394 7
		case 100:
			Readcnv( &z , "" );
			Readcnv( &x , "" );
			Readcnv( &y , "" );
			Readcnv( &x , "" );
			Readcnv( &y , "" );
			if( *vert_count == 0 )
d396 49
a444 3
				VSET( pt , x , y , z );
				MAT4X3PNT( nurb_v[0].pt , *dir[entityno]->rot , pt );
				nmg_vertex_gv( nurb_v[0].v , nurb_v[0].pt );
d446 4
a449 6
			Readcnv( &x , "" );
			Readcnv( &y , "" );
			(*vert_count)++;
			VSET( pt , x , y , z );
			MAT4X3PNT( nurb_v[*vert_count].pt , *dir[entityno]->rot , pt );
			nmg_vertex_gv( nurb_v[*vert_count].v , nurb_v[*vert_count].pt );
a450 8
		case 104:
			/* Skip conic coefficients */
			Readdbl( &x , "" );
			Readdbl( &x , "" );
			Readdbl( &x , "" );
			Readdbl( &x , "" );
			Readdbl( &x , "" );
			Readdbl( &x , "" );
d452 12
a463 2
			/* common z coord */
			Readcnv( &z , "" );
d465 2
a466 3
			Readcnv( &x , "" );
			Readcnv( &y , "" );
			if( *vert_count == 0 )
d468 3
a470 3
				VSET( pt , x , y , z );
				MAT4X3PNT( nurb_v[0].pt , *dir[entityno]->rot , pt );
				nmg_vertex_gv( nurb_v[0].v , nurb_v[0].pt );
d472 9
a480 40
			Readcnv( &x , "" );
			Readcnv( &y , "" );
			(*vert_count)++;
			VSET( pt , x , y , z );
			MAT4X3PNT( nurb_v[*vert_count].pt , *dir[entityno]->rot , pt );
			nmg_vertex_gv( nurb_v[*vert_count].v , nurb_v[*vert_count].pt );
			break;
		case 126:
			{
				int num_pts;
				int degree;
				int j;
				double a;

				Readint( &i , "" );
				num_pts = i+1;
				Readint( &degree , "" );

				/* skip properties */
				for( i=0 ; i<4 ; i++ )
					Readint( &j , "" );

				/* skip knot vector */
				for( i=0 ; i<num_pts+degree+1 ; i++ )
					Readdbl( &a , "" );

				/* skip weights */
				for( i=0 ; i<num_pts ; i++ )
					Readdbl( &a , "" );

				/* get first vertex */
				Readcnv( &x , "" );
				Readcnv( &y , "" );
				Readcnv( &z , "" );
				if( *vert_count == 0 )
				{
					VSET( pt , x , y , z );
					MAT4X3PNT( nurb_v[0].pt , *dir[entityno]->rot , pt );
					nmg_vertex_gv( nurb_v[0].v , nurb_v[0].pt );
				}
d482 1
a482 7
				/* skip to last vertex */
				for( i=1 ; i<num_pts-1 ; i++ )
				{
					Readdbl( &x , "" );
					Readdbl( &y , "" );
					Readdbl( &z , "" );
				}
a483 9
				/* get last vertex */
				Readcnv( &x , "" );
				Readcnv( &y , "" );
				Readcnv( &z , "" );
				(*vert_count)++;
				VSET( pt , x , y , z );
				MAT4X3PNT( nurb_v[*vert_count].pt , *dir[entityno]->rot , pt );
				nmg_vertex_gv( nurb_v[*vert_count].v , nurb_v[*vert_count].pt );
			}
d486 1
a486 1
			printf( "Curves of type %d are not yet handled for trimmed surfaces\n" , entity_type );
d491 5
a495 2
void
set_edge_vertices_p( fu, nverts, nurb_v, vert_count, u_min, u_max, v_min, v_max, entityno )
a496 5
int nverts;
struct nurb_verts *nurb_v;
int *vert_count;
fastf_t u_min,u_max,v_min,v_max;
int entityno;
d498 8
d507 3
d511 5
a515 5
	double x,y,z;
	struct vertexuse *vu;
	struct edgeuse *eu;
	struct loopuse *lu;
	point_t pt;
d517 1
a517 1
	if( dir[entityno]->param <= pstart )
d519 3
a521 3
		printf( "Illegal parameter pointer for entity D%07d (%s)\n" ,
				dir[entityno]->direct , dir[entityno]->name );
		return;
d524 6
a529 2
	if( *vert_count == nverts-1 )
		return;
a530 2
	Readrec( dir[entityno]->param );
	Readint( &entity_type , "" );
d533 1
a533 1
		case 102:
d537 5
a542 2
				Readint( &curve_count , "" );
				curve_list = (int *)rt_calloc( curve_count , sizeof( int ) , "set_edge_vertices_m: curve_list" );
d544 2
a545 1
					Readint( &curve_list[i] , "" );
d547 3
a549 3
					set_edge_vertices_p( fu, nverts, nurb_v, vert_count,
						u_min, u_max, v_min, v_max, (curve_list[i]-1)/2 );
				rt_free( (char *)curve_list , "set_edge_vertices_p: curve_list" );
d552 3
a554 1
		case 110:
d558 8
a565 1
			if( *vert_count == 0 )
d567 3
a569 4
				VSET( pt , (x-u_min)/(u_max-u_min) , (y-v_min)/(v_max-v_min) , z );
				MAT4X3PNT( nurb_v[0].uvw , *dir[entityno]->rot , pt );
				for( RT_LIST_FOR( vu , vertexuse , &nurb_v[0].v->vu_hd ) )
					nmg_vertexuse_a_cnurb( vu , nurb_v[0].uvw );
d571 2
d576 12
a587 6
			(*vert_count)++;
			VSET( pt , (x-u_min)/(u_max-u_min) , (y-v_min)/(v_max-v_min) , z );
			MAT4X3PNT( nurb_v[*vert_count].uvw , *dir[entityno]->rot , pt );
			for( RT_LIST_FOR( vu , vertexuse , &nurb_v[*vert_count].v->vu_hd ) )
				nmg_vertexuse_a_cnurb( vu , nurb_v[*vert_count].uvw );
			for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d589 27
a615 1
				for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d617 3
a619 5
					if( (eu->vu_p->v_p == nurb_v[*vert_count].v &&
					    eu->eumate_p->vu_p->v_p == nurb_v[*vert_count-1].v ) ||
					    (eu->vu_p->v_p == nurb_v[*vert_count-1].v &&
					    eu->eumate_p->vu_p->v_p == nurb_v[*vert_count].v ) )
							nmg_edge_g_cnurb_plinear( eu );
d621 10
d633 3
a635 3
		case 100:
		case 104:
			printf( "Circular or conic arc edges not yet handled for trimmed surfaces\n" );
d637 11
a647 40
		case 126:
			{
				int num_pts;
				int num_knots;
				int degree;
				int rational;
				int coords;
				int pt_type;
				fastf_t *kv;
				fastf_t knot_min,knot_max;
				fastf_t *points;
				int j;
				double a;

				Readint( &i , "" );
				num_pts = i+1;
				Readint( &degree , "" );

				/* properties */
				Readint( &j , "" );
				Readint( &j , "" );
				Readint( &j , "" );
				rational = !j;
				Readint( &j , "" );

				pt_type = RT_NURB_MAKE_PT_TYPE( 3+rational , 2 , rational );
				coords = RT_NURB_EXTRACT_COORDS( pt_type );

				/* knot vector */
				num_knots = num_pts + degree + 1;
				kv = (fastf_t *)rt_calloc( num_knots , sizeof( fastf_t ) , "set_edge_vertices_p: kv" );
				knot_min = MAX_FASTF;
				knot_max = (-knot_min);
				for( i=0 ; i<num_knots ; i++ )
				{
					Readdbl( &a , "" );
					kv[i] = a;
					V_MIN( knot_min , kv[i] );
					V_MAX( knot_max , kv[i] );
				}
d649 4
a652 9
				/* normalize knot vector */
				for( i=0 ; i<num_knots ; i++ )
				{
					kv[i] = (kv[i] - knot_min)/(knot_max - knot_min);
					if( kv[i] < 0.0 )
						kv[i] = 0.0;
					if( kv[i] > 1.0 )
						kv[i] = 1.0;
				}
d654 3
a656 8
				points = (fastf_t *)rt_calloc( num_pts*coords , sizeof( fastf_t ) , "set_edge_vertices_p: points" );
				/* weights */
				for( i=0 ; i<num_pts ; i++ )
				{
					Readdbl( &a , "" );
					if( rational )
						points[i*coords+3] = a;
				}
d658 2
a659 12
				/* get first vertex */
				Readdbl( &x , "" );
				Readdbl( &y , "" );
				Readdbl( &z , "" );
				VSET( pt , (x-u_min)/(u_max-u_min) , (y-v_min)/(v_max-v_min) , z );
				MAT4X3PNT( &points[0] , *dir[entityno]->rot , pt );
				if( *vert_count == 0 )
				{
					VMOVE( nurb_v[0].uvw , &points[0] )
					for( RT_LIST_FOR( vu , vertexuse , &nurb_v[0].v->vu_hd ) )
						nmg_vertexuse_a_cnurb( vu , nurb_v[0].uvw );
				}
d661 1
a661 10
				/* middle vertices */
				for( i=1 ; i<num_pts-1 ; i++ )
				{
					Readdbl( &x , "" );
					Readdbl( &y , "" );
					Readdbl( &z , "" );
					VSET( pt , (x-u_min)/(u_max-u_min) , (y-v_min)/(v_max-v_min) , z );
					MAT4X3PNT( &points[i*coords] , *dir[entityno]->rot , pt );
					VSET( &points[i*coords] , x , y , z );
				}
a662 24
				/* get last vertex */
				Readdbl( &x , "" );
				Readdbl( &y , "" );
				Readdbl( &z , "" );
				VSET( pt , (x-u_min)/(u_max-u_min) , (y-v_min)/(v_max-v_min) , z );
				MAT4X3PNT( &points[num_pts-1] , *dir[entityno]->rot , pt );

				(*vert_count)++;
				VMOVE( nurb_v[*vert_count].uvw , &points[num_pts-1] );
				for( RT_LIST_FOR( vu , vertexuse , &nurb_v[*vert_count].v->vu_hd ) )
					nmg_vertexuse_a_cnurb( vu , nurb_v[*vert_count].uvw );
				for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
				{
					for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
					{
						if( (eu->vu_p->v_p == nurb_v[*vert_count].v &&
						    eu->eumate_p->vu_p->v_p == nurb_v[*vert_count-1].v ) ||
						    (eu->vu_p->v_p == nurb_v[*vert_count-1].v &&
						    eu->eumate_p->vu_p->v_p == nurb_v[*vert_count].v ) )
								nmg_edge_g_cnurb( eu, degree+1, num_knots,
									kv, num_pts, pt_type, points );
					}
				}
			}
d665 1
a665 1
			printf( "Curve type %d not handled for trimmed surfaces yet\n" , entity_type );
d668 3
d673 6
a678 2
void
Set_loop_vertices( fu , nverts , nurb_v , pcurve , mcurve, u_min, u_max, v_min, v_max )
a679 24
int nverts;
struct nurb_verts *nurb_v;
int pcurve,mcurve;
fastf_t u_min,u_max,v_min,v_max;
{
	int vert_count;

	/* first do model coordinates */
	vert_count = 0;
	set_edge_vertices_m( fu , nverts , nurb_v , &vert_count , mcurve );

	/* now do parametric space */
	vert_count = 0;
	set_edge_vertices_p( fu , nverts , nurb_v , &vert_count, u_min, u_max, v_min, v_max , pcurve );
}

void
Set_vertices( fu , nverts , nurb_v , on_surf_de , entityno , u_min , u_max , v_min , v_max )
struct faceuse *fu;
int nverts;
struct nurb_verts *nurb_v;
int on_surf_de;
int entityno;
fastf_t u_min,u_max,v_min,v_max;
d681 1
d683 1
a683 2
	int surf_de;
	int param_curve_de,model_curve_de;
d686 5
d692 1
a692 2

	if( dir[entityno]->param <= pstart )
d694 3
a696 3
		printf( "Illegal parameter pointer for entity D%07d (%s)\n" ,
				dir[entityno]->direct , dir[entityno]->name );
		return;
d699 1
a699 1
	Readrec( dir[entityno]->param );
d703 2
a704 2
		printf( "Expected Curve on a Paremetric Surface, found entity type %d\n" , entity_type );
		return;
d709 1
a709 1
		printf( "Curve is on surface at DE %d, should be on surface at DE %d\n", surf_de, on_surf_de );
d714 3
a716 1
	Set_loop_vertices( fu , nverts , nurb_v , (param_curve_de-1)/2 , (model_curve_de-1)/2, u_min, u_max, v_min, v_max );
d719 4
a722 3
int
Count_verts( entityno )
int entityno;
d724 11
a734 4
	int entity_type;
	int vert_count=0;
	int curve_count;
	int *comp_curve_des;
d737 2
a738 8
	/* Acquiring Data */

	if( dir[entityno]->param <= pstart )
	{
		printf( "Illegal parameter pointer for entity D%07d (%s)\n" ,
				dir[entityno]->direct , dir[entityno]->name );
		return(0);
	}
d740 2
a741 2
	Readrec( dir[entityno]->param );
	Readint( &entity_type , "" );
d743 2
a744 12
	switch( entity_type )
	{
		case 110:
		case 100:
		case 126:
			vert_count = 1;
			break;
		case 102:
			Readint( &curve_count , "" );
			comp_curve_des = (int *)rt_calloc( curve_count , sizeof( int ) , "Count_verts: comp_curve_des" );
			for( i=0 ; i<curve_count ; i++ )
				Readint( &comp_curve_des[i] , "" );
d746 58
a803 3
			for( i=0 ; i<curve_count ; i++ )
				vert_count += Count_verts( (comp_curve_des[i]-1)/2 );
			break;
d806 1
a806 1
	return( vert_count );
d809 4
a812 4
int
Get_curve_verts( entityno, on_surf_de , nurb_v )
int entityno;
struct nurb_verts **nurb_v;
d814 4
a817 2
	int entity_type;
	int vert_count=0;
a818 22
	int surf_de,param_curve_de,model_curve_de;

	/* Acquiring Data */

	if( dir[entityno]->param <= pstart )
	{
		printf( "Illegal parameter pointer for entity D%07d (%s)\n" ,
				dir[entityno]->direct , dir[entityno]->name );
		return(0);
	}

	Readrec( dir[entityno]->param );
	Readint( &entity_type , "" );
	if( entity_type != 142 )
	{
		printf( "Expected Curve on a Paremetric Surface, found entity type %d\n" , entity_type );
		return( 0 );
	}
	Readint( &i , "" );
	Readint( &surf_de , "" );
	if( surf_de != on_surf_de )
		printf( "Curve is on surface at DE %d, should be on surface at DE %d\n", surf_de, on_surf_de );
d820 2
a821 9
	Readint( &param_curve_de , "" );
	Readint( &model_curve_de , "" );

	vert_count = Count_verts( (model_curve_de-1)/2 );

	(*nurb_v) = (struct nurb_verts *)rt_calloc( vert_count , sizeof( struct nurb_verts ) , "Get_curve_verts: (*nurb_v)" );

	return( vert_count );
}
d823 1
a823 13
int
Get_nurb_surf( entityno, u_order, v_order, n_u_knots, n_v_knots, ukv, vkv, u_min, u_max, v_min, v_max, n_rows, n_cols, pt_type, mesh )
int entityno;
int *u_order,*v_order,*n_u_knots,*n_v_knots,*n_rows,*n_cols,*pt_type;
fastf_t **ukv,**vkv,**mesh;
fastf_t *u_min,*u_max,*v_min,*v_max;
{
	int entity_type;
	int i;
	int num_knots;
	int num_pts;
	int rational;
	double a;
d825 3
a827 1
	/* Acquiring Data */
d829 3
a831 6
	if( dir[entityno]->param <= pstart )
	{
		printf( "Illegal parameter pointer for entity D%07d (%s)\n" ,
				dir[entityno]->direct , dir[entityno]->name );
		return(0);
	}
d833 2
a834 61
	Readrec( dir[entityno]->param );
	Readint( &entity_type , "" );
	if( entity_type != 128 )
	{
		printf( "Only B-Spline surfaces allowed for faces (found type %d)\n", entity_type );
		return( 1 );
	}
	Readint( &i , "" );
	*n_rows = i+1;
	Readint( &i , "" );
	*n_cols = i+1;
	Readint( &i , "" );
	*u_order = i+1;
	Readint ( &i , "" );
	*v_order = i+1;
	Readint( &i , "" );
	Readint( &i , "" );
	Readint( &i , "" );
	rational = !i;
	*pt_type = RT_NURB_MAKE_PT_TYPE( 3+rational , 2 , rational );
	Readint( &i , "" );
	Readint( &i , "" );
	*n_u_knots = (*n_rows)+(*u_order);
	*ukv = (fastf_t *)rt_calloc( *n_u_knots , sizeof( fastf_t ) , "Get_nurb_surf: *ukv" );
	for( i=0 ; i<*n_u_knots ; i++ )
	{
		Readdbl( &a , "" );
		(*ukv)[i] = a;
	}
	*n_v_knots = (*n_cols)+(*v_order);
	(*vkv) = (fastf_t *)rt_calloc( *n_v_knots , sizeof( fastf_t ) , "Get_nurb_surf: *vkv" );
	for( i=0 ; i<*n_v_knots ; i++ )
	{
		Readdbl( &a , "" );
		(*vkv)[i] = a;
	}
	num_pts = (*n_rows)*(*n_cols);
	*mesh = (fastf_t *)rt_calloc( num_pts*(3+rational) , sizeof( fastf_t ) , "Get_nurb_surf: *mesh" );
	for( i=0 ; i<num_pts ; i++ )
	{
		Readdbl( &a , "" );
		if( rational )
			(*mesh)[i*4+3] = a;
	}
	for( i=0 ; i<num_pts ; i++ )
	{
		Readcnv( &a , "" );
		(*mesh)[i*(3+rational)] = a;
		Readcnv( &a , "" );
		(*mesh)[i*(3+rational)+1] = a;
		Readcnv( &a , "" );
		(*mesh)[i*(3+rational)+2] = a;
	}
	Readdbl( &a , "" );
	*u_min = a;
	Readdbl( &a , "" );
	*u_max = a;
	Readdbl( &a , "" );
	*v_min = a;
	Readdbl( &a , "" );
	*v_max = a;
d836 2
a837 12
	if( *u_min != 0.0 || *u_max != 1.0 )
	{
		num_knots = (*n_rows)+(*u_order);
		for( i=0 ; i<num_knots ; i++ )
			(*ukv)[i] = ((*ukv)[i]-(*u_min))/(*u_max-(*u_min));
	}
	if( *v_min != 0.0 || *v_max != 1.0 )
	{
		num_knots = (*n_cols)+(*v_order);
		for( i=0 ; i<num_knots ; i++ )
			(*vkv)[i] = ((*vkv)[i]-(*v_min))/(*v_max-(*v_min));
	}
d839 2
a840 1
	return( 0 );
d848 1
d850 3
d854 2
a855 2
	struct vertex ***verts;
	int sol_num;
d864 3
a868 1

d871 1
a871 1
		printf( "Illegal parameter pointer for entity D%07d (%s)\n" ,
d876 1
d878 2
a879 2
	Readint( &sol_num , "" );
	if( sol_num != 144 )
d881 1
a881 1
		printf( "Expected Trimmed Surface Entity found type %d\n" );
d895 1
a895 2
	if( Get_nurb_surf( (surf_de-1)/2, &u_order, &v_order, &n_u_knots, &n_v_knots, &ukv, &vkv,
				&u_min, &u_max, &v_min, &v_max, &n_rows, &n_cols, &pt_type, &mesh ) )
d900 13
a912 1
	coords = RT_NURB_EXTRACT_COORDS( pt_type );
d916 2
a917 2
		nverts = 4;
		nurb_v = (struct nurb_verts *)rt_calloc( nverts , sizeof( struct nurb_verts ) , "trim_surf: nurb_v " );
a919 4
		nverts = Get_curve_verts( (outer_loop-1)/2 , surf_de , &nurb_v );

	verts = (struct vertex ***)rt_calloc( nverts , sizeof( struct vertex **) , "trim_surf: verts" );
	if( has_outer_boundary )
d921 2
a922 2
		for( i=0 ; i<nverts ; i++ )
			verts[i] = &nurb_v[i].v;
d925 1
a925 2
	fu = nmg_cmface( s , verts , nverts );
	nmg_face_g_snurb( fu, u_order, v_order, n_u_knots, n_v_knots, ukv, vkv, n_rows, n_cols, pt_type, mesh );
d927 2
a928 3
	if( !has_outer_boundary )
	{
		struct vertexuse *vu;
d930 1
a930 26
		VMOVE( nurb_v[0].pt , &mesh[0] );
		nmg_vertex_gv( nurb_v[0].v , nurb_v[0].pt );
		VSET( nurb_v[0].uvw , 0, 0, 0 );
		for( RT_LIST_FOR( vu , vertexuse , &nurb_v[0].v->vu_hd ) )
			nmg_vertexuse_a_cnurb( vu , nurb_v[0].uvw );

		VMOVE( nurb_v[1].pt , &mesh[(n_rows-1)*coords] );
		nmg_vertex_gv( nurb_v[1].v , nurb_v[1].pt );
		VSET( nurb_v[1].uvw , 1, 0, 0 );
		for( RT_LIST_FOR( vu , vertexuse , &nurb_v[1].v->vu_hd ) )
			nmg_vertexuse_a_cnurb( vu , nurb_v[1].uvw );

		VMOVE( nurb_v[2].pt , &mesh[(n_rows-1)*(n_cols-1)*coords] );
		nmg_vertex_gv( nurb_v[2].v , nurb_v[2].pt );
		VSET( nurb_v[2].uvw , 1, 1, 0 );
		for( RT_LIST_FOR( vu , vertexuse , &nurb_v[2].v->vu_hd ) )
			nmg_vertexuse_a_cnurb( vu , nurb_v[2].uvw );

		VMOVE( nurb_v[3].pt , &mesh[((n_rows-1)*(n_cols-2)+1)*coords] );
		nmg_vertex_gv( nurb_v[3].v , nurb_v[3].pt );
		VSET( nurb_v[3].uvw , 0, 1, 0 );
		for( RT_LIST_FOR( vu , vertexuse , &nurb_v[3].v->vu_hd ) )
			nmg_vertexuse_a_cnurb( vu , nurb_v[3].uvw );
	}
	else
		Set_vertices( fu , nverts , nurb_v , surf_de , (outer_loop-1)/2 , u_min , u_max , v_min , v_max );
d948 1
a948 1
	printf( "\n\nConverting Trimmed Surface entities:\n" );
d950 2
d969 1
a969 1
	printf( "Converted %d Trimmed Sufaces successfully out of %d total Trimmed Sufaces\n" , convsurf , totsurfs );
d972 3
@


1.4
log
@Normalized knot vectors for parameter curves and corrected number of knots.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/iges/RCS/trimsurf.c,v 1.3 94/11/04 14:37:19 jra Exp Locker: jra $ (BRL)";
@


1.3
log
@Removed excess debug prints, normalized uv parameters for vertexuse_a.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/iges/RCS/trimsurf.c,v 1.2 94/10/14 16:04:21 jra Exp $ (BRL)";
d163 1
a163 1
				for( i=0 ; i<num_pts+degree ; i++ )
d295 1
d315 1
a315 1
				num_knots = num_pts + degree;
d317 2
d323 2
d327 10
d376 1
@


1.2
log
@Removed automatic aggregate initialization.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/iges/RCS/trimsurf.c,v 1.1 94/10/04 17:59:38 jra Exp Locker: jra $ (BRL)";
a53 1
printf( "Setting edge vertices in model space: vert_count=%d\n" , *vert_count );
d74 1
a74 1
				Readint( &curve_count , "Number of curves: " );
d77 1
a77 1
					Readint( &curve_list[i] , "\tCurve DE: " );
d84 3
a86 3
			Readdbl( &x , "X1: " );
			Readdbl( &y , "Y1: " );
			Readdbl( &z , "Z1: " );
d93 3
a95 3
			Readdbl( &x , "X2: " );
			Readdbl( &y , "Y2: " );
			Readdbl( &z , "Z2: " );
d102 5
a106 5
			Readdbl( &z , "Z: " );
			Readdbl( &x , "X arc center: " );
			Readdbl( &y , "Y arc center: " );
			Readdbl( &x , "X1: " );
			Readdbl( &y , "Y1: " );
d113 2
a114 2
			Readdbl( &x , "X2: " );
			Readdbl( &y , "Y2: " );
d120 27
d154 1
a154 1
				Readint( &i , "Upper index for sum: " );
d156 1
a156 1
				Readint( &degree , "Degree: " );
d171 3
a173 3
				Readdbl( &x , "X1: " );
				Readdbl( &y , "Y1: " );
				Readdbl( &z , "Z1: " );
d184 3
a186 3
					Readdbl( &x , "XMIDDLE: " );
					Readdbl( &y , "YMIDDLE: " );
					Readdbl( &z , "ZMIDDLE: " );
d190 3
a192 3
				Readdbl( &x , "X2: " );
				Readdbl( &y , "Y2: " );
				Readdbl( &z , "Z2: " );
d199 3
d206 1
a206 1
set_edge_vertices_p( fu , nverts , nurb_v , vert_count , entityno )
d211 1
a220 1
printf( "Setting edge vertices in parameter space: (vert_count=%d)\n" , *vert_count );
d241 1
a241 1
				Readint( &curve_count , "Number of curves: " );
d244 1
a244 1
					Readint( &curve_list[i] , "\tCurve DE: " );
d246 3
a248 2
					set_edge_vertices_p( fu , nverts , nurb_v , vert_count , (curve_list[i]-1)/2 );
				rt_free( (char *)curve_list , "set_edge_vertices_m: curve_list" );
d252 3
a254 3
			Readdbl( &x , "U1: " );
			Readdbl( &y , "V1: " );
			Readdbl( &z , "W1: " );
d257 1
a257 1
				VSET( pt , x , y , z );
d262 3
a264 3
			Readdbl( &x , "U2: " );
			Readdbl( &y , "V2: " );
			Readdbl( &z , "W2: " );
d266 1
a266 1
			VSET( pt , x , y , z );
d283 2
a284 75
			{
				fastf_t kv[8];
				fastf_t pts[5*4];
				fastf_t pts1[5*4];
				fastf_t radius;
				fastf_t cx,cy,x1,y1;
				fastf_t ang1,ang2;
				fastf_t fact1=1.048816;
				vect_t tangent;
				int pt_type;

				/* don't use automatic aggregate initialization (Ultrix) */
				kv[0] = 0.0;
				kv[1] = 0.0;
				kv[2] = 0.0;
				kv[3] = 1.0;
				kv[4] = 2.0;
				kv[5] = 3.0;
				kv[6] = 3.0;
				kv[7] = 3.0;

				pt_type = RT_NURB_MAKE_PT_TYPE( 4 , 2 , 1 );

				Readdbl( &z , "W: " );
				Readdbl( &cx , "U arc center: " );
				Readdbl( &cy , "V arc center: " );
				Readdbl( &x1 , "U1: " );
				Readdbl( &y1 , "V1: " );
				if( *vert_count == 0 )
				{
					VSET( pt , x , y , z );
					MAT4X3PNT( nurb_v[0].uvw , *dir[entityno]->rot , pt );
					for( RT_LIST_FOR( vu , vertexuse , &nurb_v[0].v->vu_hd ) )
						nmg_vertexuse_a_cnurb( vu , nurb_v[0].uvw );
				}
				Readdbl( &x , "U2: " );
				Readdbl( &y , "V2: " );
				(*vert_count)++;
				VSET( pt , x , y , z );
				MAT4X3PNT( nurb_v[*vert_count].uvw , *dir[entityno]->rot , pt );
				for( RT_LIST_FOR( vu , vertexuse , &nurb_v[*vert_count].v->vu_hd ) )
					nmg_vertexuse_a_cnurb( vu , nurb_v[*vert_count].uvw );

				radius = sqrt( (x-cx)*(x-cx) + (y-cy)*(y-cy) );
				VSET( &pts[0] , x1 , y1 , z );
				VSET( &pts[4*4] , x , y , z );
				ang1 = atan2( y1-cy , x1-cx );
				ang2 = atan2( y-cy , x-cx );
				while( ang2 <= ang1 )
					ang2 += rt_twopi;
				VSET( &pts[2*4] , cx + fact1*radius*cos( 0.5*(ang1+ang2) ) , cy + fact1*radius*sin( 0.5*(ang1+ang2) ) , 0.0 );
				VSET( tangent , -sin( ang1 ) , cos( ang1 ) , 0.0 );
				VJOIN1( &pts[1*4] , &pts[0] , 0.5*sqrt(2.0)*radius , tangent );
				VSET( tangent , sin( ang2 ) , -cos( ang2 ) , 0.0 );
				VJOIN1( &pts[3*4] , &pts[4*4] , 0.5*sqrt(2.0)*radius , tangent );
				for( i=0 ; i<5 ; i++ )
					pts[i*4+3] = 1.0;
				pts[2*4+3] = 2.0;
				for( i=0 ; i<5 ; i++ )
				{
					pts1[i*4+3] = pts[i*4+3];
					MAT4X3PNT( &pts1[i*4] , *dir[entityno]->rot , &pts[i*4] );
				}
				for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
				{
					for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
					{
						if( (eu->vu_p->v_p == nurb_v[*vert_count].v &&
						    eu->eumate_p->vu_p->v_p == nurb_v[*vert_count-1].v ) ||
						    (eu->vu_p->v_p == nurb_v[*vert_count-1].v &&
						    eu->eumate_p->vu_p->v_p == nurb_v[*vert_count].v ) )
								nmg_edge_g_cnurb( eu, 3, 8, kv, 5, pt_type, pts1  );
					}
				}
			}
d299 1
a299 1
				Readint( &i , "Upper index for sum: " );
d301 1
a301 1
				Readint( &degree , "Degree: " );
d332 4
a335 4
				Readdbl( &x , "U1: " );
				Readdbl( &y , "V1: " );
				Readdbl( &z , "W1: " );
				VSET( pt , x , y , z );
d347 4
a350 4
					Readdbl( &x , "UMIDDLE: " );
					Readdbl( &y , "VMIDDLE: " );
					Readdbl( &z , "WMIDDLE: " );
					VSET( pt , x , y , z );
d356 4
a359 4
				Readdbl( &x , "U2: " );
				Readdbl( &y , "V2: " );
				Readdbl( &z , "W2: " );
				VSET( pt , x , y , z );
d379 3
d386 1
a386 1
Set_loop_vertices( fu , nverts , nurb_v , pcurve , mcurve )
d391 1
d401 1
a401 1
	set_edge_vertices_p( fu , nverts , nurb_v , &vert_count , pcurve );
d405 1
a405 1
Set_vertices( fu , nverts , nurb_v , on_surf_de , entityno )
d411 1
d434 2
a435 2
	Readint( &i , "Curve created by method %d: " );
	Readint( &surf_de , "Curve is on surface %d: " );
d439 2
a440 2
	Readint( &param_curve_de , "Parametric Curve DE: " );
	Readint( &model_curve_de , "Model Curve DE: " );
d442 1
a442 1
	Set_loop_vertices( fu , nverts , nurb_v , (param_curve_de-1)/2 , (model_curve_de-1)/2 );
d475 1
a475 1
			Readint( &curve_count , "Number of curves on composite: " );
d478 1
a478 1
				Readint( &comp_curve_des[i] , "\tCurve DE: " );
d514 2
a515 2
	Readint( &i , "Curve created by method %d: " );
	Readint( &surf_de , "Curve is on surface %d: " );
d519 2
a520 2
	Readint( &param_curve_de , "Parametric Curve DE: " );
	Readint( &model_curve_de , "Model Curve DE: " );
d530 1
a530 1
Get_nurb_surf( entityno, u_order, v_order, n_u_knots, n_v_knots, ukv, vkv, n_rows, n_cols, pt_type, mesh )
d534 1
a541 1
	fastf_t u_min,u_max,v_min,v_max;
d556 1
a556 1
		rt_log( "Only B-Spline surfaces allowed for faces (found type %d)\n", entity_type );
d559 1
a559 1
	Readint( &i , "Upper index of first Sum: " );
d561 1
a561 1
	Readint( &i , "Upper index of second sum: " );
d563 1
a563 1
	Readint( &i , "Degree in first direction: " );
d565 1
a565 1
	Readint ( &i , "Degree in second direction: " );
d567 3
a569 3
	Readint( &i , "Closed in first direction: " );
	Readint( &i , "Closed in second direction: " );
	Readint( &i , "Polynomial: " );
d572 2
a573 2
	Readint( &i , "Periodic in first direction: " );
	Readint( &i , "Periodic in second direction: " );
d578 1
a578 1
		Readdbl( &a , "U_knot Vector: " );
d585 1
a585 1
		Readdbl( &a , "V_knot Vector: " );
d592 1
a592 1
		Readdbl( &a , "Weight: " );
d598 1
a598 1
		Readdbl( &a , "X: " );
d600 1
a600 1
		Readdbl( &a , "Y: " );
d602 1
a602 1
		Readdbl( &a , "Z: " );
d605 8
a612 8
	Readdbl( &a , "u_min: " );
	u_min = a;
	Readdbl( &a , "u_max: " );
	u_max = a;
	Readdbl( &a , "v_min: " );
	v_min = a;
	Readdbl( &a , "v_max: " );
	v_max = a;
d614 1
a614 1
	if( u_min != 0.0 || u_max != 1.0 )
d618 1
a618 1
			(*ukv)[i] = ((*ukv)[i]-u_min)/(u_max-u_min);
d620 1
a620 1
	if( v_min != 0.0 || v_max != 1.0 )
d624 1
a624 1
			(*vkv)[i] = ((*vkv)[i]-v_min)/(v_max-v_min);
d642 1
a642 1
	fastf_t *ukv,*vkv,*mesh;
d664 4
a667 4
	Readint( &surf_de , "Surface DE = " );
	Readint( &has_outer_boundary , "Has outer boundary = " );
	Readint( &inner_loop_count , "Inner loops = " );
	Readint( &outer_loop , "Outer loop = " );
d672 1
a672 1
			Readint( &inner_loop[i] , "\tInner loop = " );
d676 1
a676 1
				&n_rows, &n_cols, &pt_type, &mesh ) )
a684 1
printf( "No outer boundary use rectangle\n" );
d689 1
a689 2
		nverts = Get_curve_verts( (outer_loop-1)/2 , entityno*2+1 , &nurb_v );
printf( "Outer boundary has %d vertices\n" , nverts );
a694 1
		{
a695 2
printf( "pt ( %f %f %f ) vertex pointer x%x\n" , V3ARGS( nurb_v[i].pt ) , verts[i] );
		}
d697 1
a698 30
printf( "Made faceuse x%x\n" , fu );
printf( "Calling nmg_face_g_snurb:\n" ) ;
printf( "\tu_order = %d, v_order = %d, num_u_knots = %d, num_v_knots = %d\n" , u_order,v_order,n_u_knots,n_v_knots );
printf( "\tU knots:\n" );
for( i=0 ; i<n_u_knots ; i++ )
	printf( "\t\t%f\n" , ukv[i] );
printf( "\tV knots:\n" );
for( i=0 ; i<n_v_knots ; i++ )
	printf( "\t\t%f\n" , vkv[i] );
printf( "\tControl mesh is %dX%d (%d coords per point):\n" , n_rows,n_cols,coords );
for( i=0 ; i<n_rows ; i++ )
{
	int j;

	printf( "\t\tRow %d:\n\t\t\t" , i );
	for( j=0 ; j<n_cols ; j++ )
	{
		if( coords == 3 )
			printf( " ( %f, %f, %f)" , V3ARGS( &mesh[i*n_cols*3+j*3] ) );
		else if( coords ==4 )
			printf( " ( %f, %f, %f, %f)" , V4ARGS( &mesh[i*n_cols*4+j*4] ) );
		else
		{
			printf( "Coords = %d!!!!!!\n" , coords );
			exit( 1 );
		}
		
	}
	putchar( '\n' );
}
d730 1
a730 1
		Set_vertices( fu , nverts , nurb_v , surf_de , (outer_loop-1)/2 );
d734 1
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/iges/RCS/main.c,v 11.5 94/08/26 09:05:19 jra Exp Locker: jra $ (BRL)";
d254 1
a254 1
				fastf_t kv[8]={0.0,0.0,0.0,1.0,2.0,3.0,3.0,3.0};
d263 10
@
