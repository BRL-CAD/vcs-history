head	11.20;
access;
symbols
	ansi-20040405-merged:11.18.4.1
	postmerge-20040405-ansi:11.19
	premerge-20040404-ansi:11.19
	postmerge-autoconf:11.19
	autoconf-freeze:11.18.12.1
	premerge-autoconf:11.19
	ansi-20040316-freeze:11.18
	postmerge-20040315-windows:11.19
	premerge-20040315-windows:11.19
	windows-20040315-freeze:11.18.6.1
	autoconf-20031203:11.18
	autoconf-20031202:11.18
	autoconf-branch:11.18.0.12
	phong-branch:11.18.0.10
	photonmap-branch:11.18.0.8
	rel-6-1-DP:11.18
	windows-branch:11.18.0.6
	rel-6-0-2:11.18
	ansi-branch:11.18.0.4
	rel-6-0-1-branch:11.18.0.2
	hartley-6-0-post:11.18
	hartley-6-0-pre:11.18
	rel-6-0-1:11.18
	rel-6-0:11.17
	rel-5-4:11.14
	offsite-5-3-pre:11.16
	rel-5-3:11.14
	rel-5-2:11.14
	rel-5-1-branch:11.14.0.2
	rel-5-1:11.14
	rel-5-0:11.13
	rel-5-0-beta:11.13
	rel-4-5:11.13
	ctj-4-5-post:11.13
	ctj-4-5-pre:11.13
	rel-4-4:11.8
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.20
date	2004.05.24.04.01.09;	author morrison;	state dead;
branches;
next	11.19;

11.19
date	2004.02.02.17.39.05;	author morrison;	state Exp;
branches;
next	11.18;

11.18
date	2002.05.17.12.49.27;	author morrison;	state Exp;
branches
	11.18.4.1
	11.18.6.1
	11.18.12.1;
next	11.17;

11.17
date	2001.05.16.21.37.49;	author morrison;	state Exp;
branches;
next	11.16;

11.16
date	2001.02.06.15.13.42;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	2000.08.24.04.10.49;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	2000.03.29.18.42.49;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	96.07.15.19.19.47;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	95.12.06.13.25.06;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	95.12.05.22.02.45;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	95.11.28.21.35.45;	author jra;	state Exp;
branches;
next	11.9;

11.9
date	95.06.28.15.23.43;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	95.01.04.10.08.10;	author mike;	state Rel4_4;
branches;
next	11.7;

11.7
date	94.11.08.14.50.21;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	94.10.21.20.15.16;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	94.10.19.23.53.18;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	94.08.22.19.31.56;	author gdurf;	state Exp;
branches;
next	11.3;

11.3
date	94.06.06.13.59.41;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	94.01.07.15.15.59;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	93.06.28.10.15.42;	author jra;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.45.32;	author mike;	state Rel4_0;
branches;
next	1.6;

1.6
date	91.08.29.23.10.58;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	91.07.03.03.23.06;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	91.06.17.22.03.14;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	91.06.14.08.06.58;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	91.06.12.20.08.01;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	91.06.12.19.59.42;	author mike;	state Exp;
branches;
next	;

11.18.4.1
date	2004.03.17.21.16.34;	author morrison;	state Exp;
branches;
next	;

11.18.6.1
date	2004.03.11.23.41.16;	author morrison;	state Exp;
branches;
next	;

11.18.12.1
date	2004.02.12.19.41.40;	author erikg;	state Exp;
branches;
next	;


desc
@IGES converter
@


11.20
log
@moved to src/iges/
@
text
@/*
 *  Authors -
 *	John R. Anderson
 *	Susanne L. Muuss
 *	Earl P. Weaver
 *
 *  Source -
 *	VLD/ASB Building 1065
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 */
/*				SOLID OF REVOLUTION	*/

#include "./iges_struct.h"
#include "./iges_extern.h"

void Addsub();

#ifdef M_PI
#define PI M_PI
#else
#define	PI	3.14159265358979
#endif

struct subtracts
{
	char *name;
	int index;
	struct subtracts *next;
};

struct trclist
{
	point_t base,top;
	fastf_t r1,r2;
	int op; /* 0 => union, 1=> subtract */
	int index;
	char name[NAMESIZE];
	struct subtracts *subtr;
	struct trclist *next,*prev;
};

int
revolve( entityno )
int entityno;
{ 
	struct wmember	head;			/* For region */
	char		*trcform="rev.%d.%d";	/* Format for creating TRC names */
	int		sol_num;		/* IGES solid type number */
	point_t		pt;			/* Point on axis of revolution */
	vect_t		adir;			/* Direction of axis of revolution */
	int		curve;			/* Pointer to driectory entry for curve */
	fastf_t		fract;			/* Fraction of circle for rotation (0 < fract <= 1.0) */
	vect_t		v1;			/* Vector from "pt" to any point along curve */
	fastf_t		h;			/* height of "TRC" */
	int		npts;			/* Number of points used to approximate curve */
	struct ptlist	*curv_pts,*ptr;		/* Pointer to a linked list of npts points along curve */
	int		ntrcs;			/* number of "TRC" solids used */
	vect_t		tmp;			/* temporary storage for a vector */
	struct trclist	*trcs,*trcptr,*ptr2;	/* Pointers to linked list of TRC`s */
	fastf_t		r2;			/* TRC radius */
	fastf_t		hmax,hmin;		/* Max and Min distances along axis of rotation */
	fastf_t		rmax;			/* Max radius */
	int		cutop = Intersect;	/* Operator for cutting solid */
	char		cutname[NAMESIZE];	/* Name for cutting solid */
	struct subtracts *subp;
	int		i;

	BU_LIST_INIT( &head.l );

	/* Default values */
	VSET( adir , 0.0 , 0.0 , 1.0 );
	VSET( pt , 0.0 , 0.0 , 0.0 );
	fract = 1.0;

	/* Acquire data */

	if( dir[entityno]->param <= pstart )
	{
		bu_log( "Illegal parameter pointer for entity D%07d (%s)\n" ,
				dir[entityno]->direct , dir[entityno]->name );
		return(0);
	}
	Readrec( dir[entityno]->param );
	Readint( &sol_num , "" );

	/* Read pointer to directory entry for curve to be extruded */

	Readint( &curve , "" );

	/* Convert this to a "dir" index */

	curve = (curve-1)/2;

	Readflt( &fract , "" );
	Readflt( &pt[X] , "" );
	Readflt( &pt[Y] , "" );
	Readflt( &pt[Z] , "" );
	Readflt( &adir[X] , "" );
	Readflt( &adir[Y] , "" );
	Readflt( &adir[Z] , "" );

	/* just to be safe */
	VUNITIZE( adir );

	if( fract <= 0.0 || fract > 1.0 )
	{
		bu_log( "Illegal parameters for entity D%07d (%s)\n" ,
			dir[entityno]->direct , dir[entityno]->name );
		return( 0 );
	}

	dir[entityno]->referenced = 1;

	/* Get the curve in the form of a series of straight line segments */

	npts = Getcurve( curve , &curv_pts );
	if( npts == 0 )
	{
		bu_log( "Could not get points along curve for revovling\n" );
		bu_log( "Illegal parameters for entity D%07d (%s)\n" ,
			dir[entityno]->direct , dir[entityno]->name );
		return( 0 );
	}

/* Construct a linked list of TRC's */
	ntrcs = 0;
	trcs = NULL;
	ptr = curv_pts;

	/* Calculate radius at start of curve */
	VSUB2( v1 , ptr->pt , pt );
	VCROSS( tmp , v1 , adir );
	r2 = MAGNITUDE( tmp );
	if( r2 < TOL )
		r2 = TOL;
	rmax = r2;
	hmax = VDOT( v1 , adir );
	hmin = hmax;

	trcptr = NULL;
	while( ptr->next != NULL )
	{
		struct trclist *prev;
		fastf_t h1;

		if( trcs == NULL )
		{
			trcs = (struct trclist *)bu_malloc( sizeof( struct trclist ),
				"Revolve: trcs" );
			trcptr = trcs;
			prev = NULL;
		}
		else if( trcptr->name[0] != '\0' )
		{
			trcptr->next = (struct trclist *)bu_malloc( sizeof( struct trclist ),
				"Revolve: trcptr->next" );
			prev = trcptr;
			trcptr = trcptr->next;
		}
		else  prev = NULL;
		trcptr->next = NULL;
		trcptr->prev = prev;
		trcptr->op = 0;
		trcptr->subtr = NULL;
		trcptr->name[0] = '\0';

		/* Calculate base point of TRC */
		VSUB2( v1 , ptr->pt , pt );
		VJOIN1( trcptr->base , pt , VDOT( v1 , adir ) , adir );

		/* Height along axis of rotation */
		h1 = VDOT( v1 , adir );
		if( h1 < hmin )
			hmin = h1;
		if( h1 > hmax )
			hmax = h1;

		/* Radius at base is top radius from previous TRC */
		trcptr->r1 = r2;

		/* Calculate new top radius */
		VSUB2( v1 , ptr->next->pt , pt );
		VCROSS( tmp , v1 , adir );
		trcptr->r2 = MAGNITUDE( tmp );
		if( trcptr->r2 < TOL )
			trcptr->r2 = TOL;
		r2 = trcptr->r2;
		if( r2 > rmax )
			rmax = r2;

		/* Calculate height of TRC */
		VSUB2( v1 , ptr->next->pt , pt );
		VJOIN1( trcptr->top , pt , VDOT( v1 , adir ) , adir );
		VSUB2( v1 , trcptr->top , trcptr->base );
		h = MAGNITUDE( v1 );
		/* If height is zero, don't make a TRC */
		if( NEAR_ZERO( h , TOL ) )
		{
			ptr = ptr->next;
			continue;
		}

		/* Make a name for the TRC */
		sprintf( trcptr->name , trcform , entityno , ntrcs );

		/* Make the TRC */
		if( mk_trc_top( fdout, trcptr->name, trcptr->base,
		    trcptr->top, trcptr->r1, trcptr->r2 ) < 0 )  {
			bu_log( "Unable to write TRC for entity D%07d (%s)\n" ,
				dir[entityno]->direct , dir[entityno]->name );
			return( 0 );
		}

		/* Count 'em */
		ntrcs++;
		ptr = ptr->next;
	}

	/* Eliminate last struct if not used */
	if( trcptr->name[0] == '\0' )
	{
		trcptr->prev->next = NULL;
		bu_free( (char *)trcptr, "Revolve: trcptr" );
	}

	if( dir[entityno]->form == 1 ) /* curve closed on itself */
	{
		trcptr = trcs;
		while( trcptr != NULL )
		{
			fastf_t hb1,ht1,hb2,ht2; /* distance from "pt" to bottom and top of TRC's */
			fastf_t	rtmp;	/* interpolated radii for TRC */
			fastf_t tmpp;	/* temp storage */

			/* Calculate distances to top and base */
			VSUB2( tmp , trcptr->base , pt );
			hb1 = MAGNITUDE( tmp );
			VSUB2( tmp , trcptr->top , pt );
			ht1 = MAGNITUDE( tmp );
			/* Make sure distance to base is smaller */
			if( ht1 < hb1 )
			{
				tmpp = ht1;
				ht1 = hb1;
				hb1 = tmpp;
			}

			/* Check every TRC against this one */
			ptr2 = trcs;
			while( ptr2 != NULL )
			{
				if( ptr2 == trcptr ) /* but not itself */
					ptr2 = ptr2->next;
				else
				{
					/* Calculate heights */
					VSUB2( tmp , ptr2->base , pt );
					hb2 = MAGNITUDE( tmp );
					VSUB2( tmp , ptr2->top , pt );
					ht2 = MAGNITUDE( tmp );
					/* and order them */
					if( ht2 < hb2 )
					{
						tmpp = ht2;
						ht2 = hb2;
						hb2 = tmpp;
					}
					if( hb2 < ht1 && hb2 > hb1 )
					{
						/* These TRC's overlap */
						/* Calculate radius at hb2 */
						rtmp = trcptr->r1 + (trcptr->r2 - trcptr->r1)*(hb2-hb1)/(ht1-hb1);
						if( rtmp > ptr2->r1 )
						{
							/* ptr2 must be an inside solid, so subtract it */
							Addsub( trcptr , ptr2 );
							ptr2->op = 1;
						}
						else if( rtmp < ptr2->r1 )
						{
							/* trcptr must be an inside solid */
							Addsub( ptr2 , trcptr );
							trcptr->op = 1;
						}
					}
					else if( ht2 < ht1 && ht2 > hb1 )
					{
						/* These TRC's overlap */
						/* Calculate radius at ht2 */
						rtmp = trcptr->r1 + (trcptr->r2 - trcptr->r1)*(ht2-hb1)/(ht1-hb1);
						if( rtmp > ptr2->r2 )
						{
							/* ptr2 must be an inside solid, so subtract it */
							Addsub( trcptr , ptr2 );
							ptr2->op = 1;
						}
						else if( rtmp < ptr2->r1 )
						{
							/* trcptr must be an inside solid */
							Addsub( ptr2 , trcptr );
							trcptr->op = 1;
						}
					}
					ptr2 = ptr2->next;
				}
			}
			trcptr = trcptr->next;
		}
	}

	if( fract < 1.0 )
	{
		/* Must calculate a cutting solid */
		vect_t pdir,enddir,startdir;
		fastf_t len,theta;
		point_t pts[8];

		/* Calculate direction from axis to curve */
		len = 0.0;
		ptr = curv_pts;
		while( len == 0.0 )
		{
			VSUB2( pdir , ptr->pt , pt );
			VJOIN1( startdir , pdir , -VDOT( pdir , adir ) , adir );
			len = MAGNITUDE( startdir );
			ptr = ptr->next;
		}
		VUNITIZE( startdir );

		/* Calculate direction towards solid from axis */
		VCROSS( pdir , adir , startdir );
		VUNITIZE( pdir );

		if( fract < 0.5 )
		{
			theta = 2.0*PI*fract;
			cutop = Intersect;
		}
		else if( fract > 0.5 )
		{
			theta = (-2.0*PI*(1.0-fract));
			cutop = Subtract;
		}
		else
		{
			/* XXX fract == 0.5, a dangerous comparison (roundoff) */
			theta = PI;
			cutop = Intersect;
			/* Construct vertices for cutting solid */
			VJOIN2( pts[0] , pt , hmin , adir , rmax , startdir );
			VJOIN1( pts[1] , pts[0] , (-2.0*rmax) , startdir );
			VJOIN1( pts[2] , pts[1] , rmax , pdir );
			VJOIN1( pts[3] , pts[0] , rmax , pdir );
			for( i=0 ; i<4 ; i++ )
			{
				VJOIN1( pts[i+4] , pts[i] , (hmax-hmin) , adir );
			}
		}
		if( fract != 0.5 )
		{
			/* Calculate direction to end of revolve */
			VSCALE( enddir , startdir , cos( theta ) );
			VJOIN1( enddir , enddir , sin( theta ) , pdir );
			VUNITIZE( enddir );

			/* Calculate required length of a side */
			len = rmax/cos( theta/4.0 );

			/* Construct vertices for cutting solid */
				/* Point at bottom center of revolution */
			VJOIN1( pts[0] , pt , hmin , adir );
				/* Point at bottom on curve */
			VJOIN1( pts[1] , pts[0] , len , startdir );
				/* Point at bottom at end of revolution */
			VJOIN1( pts[3] , pts[0] , len , enddir );
				/* Calculate direction to pts[2] */
			VADD2( enddir , enddir , startdir );
			VUNITIZE( enddir );
				/* Calculate pts[2] */
			VJOIN1( pts[2] , pts[0] , len , enddir );

			/* Calculate top vertices */
			for( i=0 ; i<4 ; i++ )
			{
				VJOIN1( pts[i+4] , pts[i] , (hmax-hmin) , adir );
			}
		}

		/* Make the BRLCAD solid */
		if( mk_arb8( fdout , cutname , &pts[0][X] ) < 0 )  {
			bu_log( "Unable to write ARB8 for entity D%07d (%s)\n" ,
				dir[entityno]->direct , dir[entityno]->name );
			return( 0 );
		}
	}

	/* Build region */
	trcptr = trcs;
	while( trcptr != NULL )
	{
		/* Union together all the TRC's that are not subtracts */
		if( trcptr->op != 1 )
		{
			(void)mk_addmember( trcptr->name , &head.l, NULL, operator[Union] );

			if( fract < 1.0 )
			{
				/* include cutting solid */
				(void)mk_addmember( cutname , &head.l, NULL, operator[cutop] );
			}

			subp = trcptr->subtr;
			/* Subtract the inside TRC's */
			while( subp != NULL )
			{
				(void)mk_addmember( subp->name , &head.l, NULL, operator[Subtract] );
				subp = subp->next;
			}
		}
		trcptr = trcptr->next;
	}

	/* Make the object */
	if( mk_lcomb( fdout , dir[entityno]->name , &head , 0 ,
	    (char *)0 , (char *)0 , (unsigned char *)0 , 0 ) < 0 )  {
		bu_log( "Unable to make combination for entity D%07d (%s)\n" ,
			dir[entityno]->direct , dir[entityno]->name );
		return( 0 );
	}


	/* Free the TRC structures */
	trcptr = trcs;
	while( trcptr != NULL )
	{
		bu_free( (char *)trcptr, "Revolve: trcptr" );
		trcptr = trcptr->next;
	}
	return( 1 );
}

/* Routine to add a name to the list of subtractions */
void
Addsub( trc , ptr )
struct trclist *trc,*ptr;
{
	struct subtracts *subp;

	if( trc->subtr == NULL )
	{
		trc->subtr = (struct subtracts *)bu_malloc( sizeof( struct subtracts ),
			"Revolve: trc->subtr" );
		subp = trc->subtr;
	}
	else
	{
		subp = trc->subtr;
		while( subp->next != NULL )
			subp = subp->next;
		subp->next = (struct subtracts *)bu_malloc( sizeof( struct subtracts ),
			"Revolve: subp->next" );
		subp = subp->next;
	}

	subp->next = NULL;
	subp->name = ptr->name;
	subp->index = ptr->index;
}

@


11.19
log
@update copyright to include span through 2003
@
text
@@


11.18
log
@added matrix parameter to mk_addmember()
@
text
@d13 1
a13 1
 *	This software is Copyright (C) 1990 by the United States Army.
@


11.18.4.1
log
@sync branch with HEAD
@
text
@d13 1
a13 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
@


11.18.6.1
log
@sync to HEAD...
@
text
@d13 1
a13 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
@


11.18.12.1
log
@merge from HEAD
@
text
@d13 1
a13 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
@


11.17
log
@PRODUCTION optimizations
@
text
@d409 1
a409 1
			(void)mk_addmember( trcptr->name , &head.l, operator[Union] );
d414 1
a414 1
				(void)mk_addmember( cutname , &head.l, operator[cutop] );
d421 1
a421 1
				(void)mk_addmember( subp->name , &head.l, operator[Subtract] );
@


11.16
log
@Mods to get IGES working with new database format (v5)
@
text
@d145 1
@


11.15
log
@
mk_addmember
RCSid
@
text
@d47 1
@


11.14
log
@
Converted from Release 4 names to know about libbu and libbn
@
text
@d407 1
a407 1
			(void)mk_addmember( trcptr->name , &head, operator[Union] );
d412 1
a412 1
				(void)mk_addmember( cutname , &head, operator[cutop] );
d419 1
a419 1
				(void)mk_addmember( subp->name , &head, operator[Subtract] );
@


11.13
log
@Minor Mods for IRIX 6.2
@
text
@d72 1
a72 1
	RT_LIST_INIT( &head.l );
d83 1
a83 1
		rt_log( "Illegal parameter pointer for entity D%07d (%s)\n" ,
d111 1
a111 1
		rt_log( "Illegal parameters for entity D%07d (%s)\n" ,
d123 2
a124 2
		rt_log( "Could not get points along curve for revovling\n" );
		rt_log( "Illegal parameters for entity D%07d (%s)\n" ,
d151 1
a151 1
			trcs = (struct trclist *)rt_malloc( sizeof( struct trclist ),
d158 1
a158 1
			trcptr->next = (struct trclist *)rt_malloc( sizeof( struct trclist ),
d212 1
a212 1
			rt_log( "Unable to write TRC for entity D%07d (%s)\n" ,
d226 1
a226 1
		rt_free( (char *)trcptr, "Revolve: trcptr" );
d394 1
a394 1
			rt_log( "Unable to write ARB8 for entity D%07d (%s)\n" ,
d429 1
a429 1
		rt_log( "Unable to make combination for entity D%07d (%s)\n" ,
d439 1
a439 1
		rt_free( (char *)trcptr, "Revolve: trcptr" );
d454 1
a454 1
		trc->subtr = (struct subtracts *)rt_malloc( sizeof( struct subtracts ),
d463 1
a463 1
		subp->next = (struct subtracts *)rt_malloc( sizeof( struct subtracts ),
@


11.12
log
@All logging done via rt_log
@
text
@d21 2
d446 1
@


11.11
log
@Checkpoint in mods for handling assemblies (subfigures).
@
text
@d81 1
a81 1
		printf( "Illegal parameter pointer for entity D%07d (%s)\n" ,
d109 1
a109 1
		printf( "Illegal parameters for entity D%07d (%s)\n" ,
d121 2
a122 2
		printf( "Could not get points along curve for revovling\n" );
		printf( "Illegal parameters for entity D%07d (%s)\n" ,
d210 1
a210 1
			printf( "Unable to write TRC for entity D%07d (%s)\n" ,
d392 1
a392 1
			printf( "Unable to write ARB8 for entity D%07d (%s)\n" ,
d427 1
a427 1
		printf( "Unable to make combination for entity D%07d (%s)\n" ,
@


11.10
log
@Mods to handle TNURB BREP. Also added RT_EXTERNS to iges_struct.h.
@
text
@d40 1
a40 1
	char name[NAMELEN];
d66 1
a66 1
	char		cutname[NAMELEN];	/* Name for cutting solid */
@


11.9
log
@Converted to use rt_malloc family.
@
text
@a17 15

#include "conf.h"

#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <math.h>
#include <errno.h>

#include "machine.h"
#include "vmath.h"
#include "wdb.h"
@


11.8
log
@Release_4.4
@
text
@d164 2
a165 1
			trcs = (struct trclist *)malloc( sizeof( struct trclist ) );
d171 2
a172 1
			trcptr->next = (struct trclist *)malloc( sizeof( struct trclist ) );
d239 1
a239 1
		free( trcptr );
d452 1
a452 1
		free( trcptr );
d466 2
a467 1
		trc->subtr = (struct subtracts *)malloc( sizeof( struct subtracts ) );
d475 2
a476 1
		subp->next = (struct subtracts *)malloc( sizeof( struct subtracts ) );
@


11.7
log
@Mods for Irix 6.
@
text
@@


11.6
log
@rgb is now unsigned char
@
text
@d63 1
a63 1

d77 1
a77 5
	fastf_t		r1,r2;			/* TRC radius */
	point_t		base,top;		/* To protect stuff from "mk_trc" */
	struct reglist	*regptr;		/* Store region for later reference */
	struct node	*nodeptr,*tmpnode,*tree; /* Pointer to tree structure under regptr */
	int		oldarraylen;		/* number of elements in "dir" array before realloc */
a82 1
	char		*ch;
a83 1
	struct wmember head,*wmem;
d418 1
a418 1
			wmem = mk_addmember( trcptr->name , &head, operator[Union] );
d423 1
a423 1
				wmem = mk_addmember( cutname , &head, operator[cutop] );
d430 1
a430 1
				wmem = mk_addmember( subp->name , &head, operator[Subtract] );
@


11.5
log
@Fixed invocation of mk_arb8() without needing to use funky cast.
@
text
@d444 2
a445 1
	if( mk_lcomb( fdout , dir[entityno]->name , &head , 0 , (char *)0 , (char *)0 , (char *)0 , 0 ) < 0 )  {
@


11.4
log
@Factored ifdefs
@
text
@d410 1
a410 1
		if( mk_arb8( fdout , cutname , (CONST point_t *)pts ) < 0 )  {
@


11.3
log
@Fixed bug in building region from TRC's.
@
text
@d19 2
d22 3
a24 1
#ifdef BSD
a25 2
#else
#include <string.h>
d28 2
d36 3
d40 1
a40 1
extern int errno;
@


11.2
log
@Modified header files
@
text
@d281 1
a281 1
					if( hb2 <= ht1 && hb2 >= hb1 )
d292 6
d299 1
a299 1
					else if( ht2 <= ht1 && ht2 >= hb1 )
d309 6
@


11.1
log
@Major Upgrade to IGES 5.1
@
text
@a27 1
#include "rtlist.h"
@


10.1
log
@Release_4.0
@
text
@@


1.6
log
@string.h
@
text
@@


1.5
log
@ANSI lint
@
text
@d20 1
d22 3
@


1.4
log
@Was making wrong kind of trc
@
text
@d74 1
a74 1
	int		cutop;			/* Operator for cutting solid */
d170 1
d342 1
a342 1
		else if( fract == 0.5 )
d344 2
d388 1
a388 1
		if( mk_arb8( fdout , cutname , pts ) < 0 )  {
@


1.3
log
@Changed for more modern LIBWDB
@
text
@a214 7
		/* Protect my variables from mk_trc */
		VMOVE( base , trcptr->base );
		VMOVE( top , trcptr->top );
		r1 = trcptr->r1;
		r2 = trcptr->r2;
		ch = trcptr->name;

d216 2
a217 1
		if( mk_trc( fdout , ch , base , top , r1 , r2 ) < 0 )  {
@


1.2
log
@RT LIST
@
text
@d223 5
a227 1
		mk_trc( fdout , ch , base , top , r1 , r2 );
d391 5
a395 1
		mk_arb8( fdout , cutname , pts );
d405 1
a405 2
			wmem = mk_addmember( trcptr->name , &head );
			wmem->wm_op = operator[Union];
d410 1
a410 2
				wmem = mk_addmember( cutname , &head );
				wmem->wm_op = operator[cutop];
d417 1
a417 2
				wmem = mk_addmember( subp->name , &head );
				wmem->wm_op = operator[Subtract];
d425 6
a430 1
	mk_lcomb( fdout , dir[entityno]->name , &head , 0 , (char *)0 , (char *)0 , (char *)0 , 0 );
@


1.1
log
@Initial revision
@
text
@d21 5
d28 1
a28 2
#include "wdb.h"
#include <math.h>
d81 1
a81 3
	head.wm_forw = &head;
	head.wm_back = &head;

@
