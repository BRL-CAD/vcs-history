head	11.11;
access;
symbols
	ansi-20040405-merged:11.9.4.1
	postmerge-20040405-ansi:11.10
	premerge-20040404-ansi:11.10
	postmerge-autoconf:11.10
	autoconf-freeze:11.9.12.1
	premerge-autoconf:11.10
	ansi-20040316-freeze:11.9
	postmerge-20040315-windows:11.10
	premerge-20040315-windows:11.10
	windows-20040315-freeze:11.9.6.1
	autoconf-20031203:11.9
	autoconf-20031202:11.9
	autoconf-branch:11.9.0.12
	phong-branch:11.9.0.10
	photonmap-branch:11.9.0.8
	rel-6-1-DP:11.9
	windows-branch:11.9.0.6
	rel-6-0-2:11.9
	ansi-branch:11.9.0.4
	rel-6-0-1-branch:11.9.0.2
	hartley-6-0-post:11.9
	hartley-6-0-pre:11.9
	rel-6-0-1:11.9
	rel-6-0:11.8
	rel-5-4:11.6
	offsite-5-3-pre:11.8
	rel-5-3:11.6
	rel-5-2:11.6
	rel-5-1-branch:11.6.0.2
	rel-5-1:11.6
	rel-5-0:11.5
	rel-5-0-beta:11.5
	rel-4-5:11.4
	ctj-4-5-post:11.4
	ctj-4-5-pre:11.4
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.11
date	2004.05.24.04.01.07;	author morrison;	state dead;
branches;
next	11.10;

11.10
date	2004.02.02.17.39.04;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2002.05.17.12.49.27;	author morrison;	state Exp;
branches
	11.9.4.1
	11.9.6.1
	11.9.12.1;
next	11.8;

11.8
date	2001.02.06.15.13.42;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	2000.08.24.04.10.46;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	2000.03.29.18.42.41;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	99.02.12.15.03.48;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	95.12.06.13.25.06;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.11.28.21.35.45;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.06.28.15.23.43;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.07.33;	author mike;	state Rel4_4;
branches;
next	1.8;

1.8
date	94.11.08.14.50.00;	author jra;	state Exp;
branches;
next	1.7;

1.7
date	94.10.14.10.54.06;	author jra;	state Exp;
branches;
next	1.6;

1.6
date	94.10.11.20.03.15;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	94.08.22.19.31.41;	author gdurf;	state Exp;
branches;
next	1.4;

1.4
date	94.08.22.18.33.51;	author gdurf;	state Exp;
branches;
next	1.3;

1.3
date	94.01.14.16.13.06;	author jra;	state Exp;
branches;
next	1.2;

1.2
date	94.01.14.15.44.14;	author jra;	state Exp;
branches;
next	1.1;

1.1
date	94.01.14.14.14.23;	author jra;	state Exp;
branches;
next	;

11.9.4.1
date	2004.03.17.21.16.30;	author morrison;	state Exp;
branches;
next	;

11.9.6.1
date	2004.03.11.23.41.13;	author morrison;	state Exp;
branches;
next	;

11.9.12.1
date	2004.02.12.19.41.38;	author erikg;	state Exp;
branches;
next	;


desc
@Code to convert IGES drawings to NMG wire edges
@


11.11
log
@moved to src/iges/
@
text
@/*	Routine to convert IGES drawings to wire edges in
 *	BRLCAD NMG structures.
 *
 *  Author -
 *	John R. Anderson
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1994-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */

#include "./iges_struct.h"
#include "./iges_extern.h"

struct views_visible
{
	int de;
	int no_of_views;
	int *view_de;
};

static char *default_drawing_name="iges_drawing";

struct bu_list free_hd;

void
Getstrg( str , id )
char **str;
char *id;
{
	int i=(-1),length=0,done=0,lencard;
	char num[80];

	if( card[counter] == eof ) /* This is an empty field */
	{
		counter++;
		return;
	}
	else if( card[counter] == eor ) /* Up against the end of record */
		return;

	if( card[72] == 'P' )
		lencard = PARAMLEN;
	else
		lencard = CARDLEN;

	if( counter > lencard )
		Readrec( ++currec );

	if( *id != '\0' )
		bu_log( "%s" , id );

	while( !done )
	{
		while( (num[++i] = card[counter++]) != 'H' &&
				counter <= lencard);
		if( counter > lencard )
			Readrec( ++currec );
		if( num[i] == 'H' )
			done = 1;
	}
	num[++i] = '\0';
	length = atoi( num );

	if( length < 1 )
		(*str) = NULL;
	else
		(*str) = (char *)bu_malloc( sizeof( char ) * length + 1, "Getstrg: str" );
	for( i=0 ; i<length ; i++ )
	{
		if( counter > lencard )
			Readrec( ++currec );
		(*str)[i] = card[counter];
		if( *id != '\0' )
			bu_log( "%c", card[counter] );
		counter++;
	}
	(*str)[length] = '\0';
	if( *id != '\0' )
		bu_log( "%c", '\n' );

	while( card[counter] != eof && card[counter] != eor )
	{
		if( counter < lencard )
			counter++;
		else
			Readrec( ++currec );
	}

	if( card[counter] == eof )
	{
		counter++;
		if( counter > lencard )
			Readrec( ++ currec );
	}
}

void
Note_to_vlist( entno , vhead )
int entno;
struct bu_list *vhead;
{
	int entity_type;
	int nstrings=0;
	int i;

	if(BU_LIST_UNINITIALIZED(&free_hd)) BU_LIST_INIT(&free_hd);

	Readrec( dir[entno]->param );
	Readint( &entity_type , "" );
	if( entity_type != 212 )
	{
		bu_log( "Expected General Note entity data at P%07d, got type %d\n" , dir[entno]->param , entity_type );
		return;
	}

	Readint( &nstrings , "" );
	for( i=0 ; i<nstrings ; i++ )
	{
		int str_len=0;
		fastf_t width=0.0,height=0.0;
		int font_code=1;
		fastf_t slant_ang;
		fastf_t rot_ang=0.0;
		int mirror=0;
		int internal_rot=0;
		double local_scale;
		char one_char[2];
		point_t loc,tmp;
		char *str;

		Readint( &str_len , "" );
		Readcnv( &width , "" );
		Readcnv( &height , "" );
		Readint( &font_code , "" );	/* not currently used */
		slant_ang = bn_halfpi;
		Readflt( &slant_ang , "" );	/* not currently used */
		Readflt( &rot_ang , "" );
		Readint( &mirror , "" );	/* not currently used */
		Readint( &internal_rot , "" );
		Readcnv( &tmp[X] , "" );
		Readcnv( &tmp[Y] , "" );
		Readcnv( &tmp[Z] , "" );
		Getstrg( &str , "" );

		/* apply any tranform */
		MAT4X3PNT( loc , *dir[entno]->rot , tmp );


		local_scale = width/str_len;
		if( height < local_scale )
			local_scale = height;

		if( local_scale < height )
			loc[Y] += (height - local_scale)/2.0;

		if( local_scale*str_len < width )
			loc[X] += (width - (local_scale*str_len))/2.0;

		if( internal_rot )	/* vertical text */
		{
			/* handle vertical text, one character at a time */
			int j;
			double tmp_x,tmp_y;
			double xdel,ydel;

			xdel = local_scale * sin( rot_ang );
			ydel = local_scale * cos( rot_ang );

			tmp_y = loc[Y];
			tmp_x = loc[X];
			one_char[1] = '\0';

			for( j=0 ; j<str_len ; j++ )
			{
				tmp_x += xdel;
				tmp_y -= ydel;
				one_char[0] = str[j];

				bn_vlist_2string( vhead , &free_hd , one_char ,
					tmp_x , tmp_y , local_scale,
					(double)(rot_ang*180.0*bn_invpi) );
			}
		}
		else
			bn_vlist_2string( vhead, &free_hd , str ,
				(double)loc[X] , (double)loc[Y] , local_scale,
				(double)(rot_ang*180.0*bn_invpi) );

		bu_free( str, "Note_to_vlist: str" );
	}
}

void
Get_plane( pl , entno )
plane_t pl;
int entno;
{
	int entity_type;
	int i;

	Readrec( dir[entno]->param );
	Readint( &entity_type , "" );
	if( entity_type != 108 )
	{
		bu_log( "Expected Plane entity data at P%07d, got type %d\n" , dir[entno]->param , entity_type );
		return;
	}

	for( i=0 ; i<4 ; i++ )
		Readflt( &pl[i] , "" );
}

void
Curve_to_vlist( vhead , ptlist )
struct bu_list *vhead;
struct ptlist *ptlist;
{
	struct ptlist *ptr;

	if( ptlist == NULL )
		return;

	if( ptlist->next == NULL )
		return;

	ptr = ptlist;

	RT_ADD_VLIST( vhead , ptr->pt , BN_VLIST_LINE_MOVE );

	ptr = ptr->next;
	while( ptr != NULL )
	{
		RT_ADD_VLIST( vhead , ptr->pt , BN_VLIST_LINE_DRAW );
		ptr = ptr->next;
	}
}

void
Leader_to_vlist( entno , vhead )
int entno;
struct bu_list *vhead;
{
	int entity_type;
	int npts,i;
	point_t tmp,tmp2,tmp3,center;
	vect_t v1,v2,v3;
	fastf_t a,b,c;

	Readrec( dir[entno]->param );
	Readint( &entity_type , "" );
	if( entity_type != 214 )
	{
		bu_log( "Expected Leader (Arrow) entity data at P%07d, got type %d\n" , dir[entno]->param , entity_type );
		return;
	}

	Readint( &npts , "" );
	Readcnv( &a , "" );
	Readcnv( &b , "" );
	Readcnv( &v1[2] , "" );
	Readcnv( &v1[0] , "" );
	Readcnv( &v1[1] , "" );
	v2[2] = v1[2];
	Readcnv( &v2[0] , "" );
	Readcnv( &v2[1] , "" );
	VMOVE( center , v1 );
	if( dir[entno]->form == 5 || dir[entno]->form == 6 )
	{
		/* need to move v1 towards v2 by distance "a" */
		VSUB2( v3 , v2 , v1 );
		VUNITIZE( v3 );
		VJOIN1( v1 , v1 , a , v3 );
	}
	MAT4X3PNT( tmp2 , *dir[entno]->rot , v1 );
	RT_ADD_VLIST( vhead , tmp2 , BN_VLIST_LINE_MOVE );
	MAT4X3PNT( tmp , *dir[entno]->rot , v2 );
	RT_ADD_VLIST( vhead , tmp , BN_VLIST_LINE_DRAW );

	for( i=1 ; i<npts ; i++ )
	{
		Readcnv( &v3[0] , "" );
		Readcnv( &v3[1] , "" );
		MAT4X3PNT( tmp , *dir[entno]->rot , v3 );
		RT_ADD_VLIST( vhead , tmp , BN_VLIST_LINE_DRAW );
	}
	switch( dir[entno]->form )
	{
	  default:
	  case 1:	
	  case 2:
	  case 3:
	  case 11:
		/* Create unit vector parallel to leader */
		v3[0] = v2[0] - v1[0];
		v3[1] = v2[1] - v1[1];
		v3[2] = 0.0;
		VUNITIZE( v3 );

		/* Draw one side of arrow head */
		RT_ADD_VLIST( vhead , tmp2 , BN_VLIST_LINE_MOVE );
		v2[0] = v1[0] + a*v3[0] - b*v3[1];
		v2[1] = v1[1] + a*v3[1] + b*v3[0];
		v2[2] = v1[2];
		MAT4X3PNT( tmp , *dir[entno]->rot , v2 );
		RT_ADD_VLIST( vhead , tmp , BN_VLIST_LINE_DRAW );

		/* Now draw other side of arrow head */
		RT_ADD_VLIST( vhead , tmp2 , BN_VLIST_LINE_MOVE );
		v2[0] = v1[0] + a*v3[0] + b*v3[1];
		v2[1] = v1[1] + a*v3[1] - b*v3[0];
		MAT4X3PNT( tmp , *dir[entno]->rot , v2 );
		RT_ADD_VLIST( vhead , tmp , BN_VLIST_LINE_DRAW );
		break;
	  case 4:
		break;
	  case 5:
	  case 6:
		{
			fastf_t delta,cosdel,sindel,rx,ry;

			delta = bn_pi/10.0;
			cosdel = cos( delta );
			sindel = sin( delta );
			RT_ADD_VLIST( vhead , tmp2 , BN_VLIST_LINE_MOVE );
			VMOVE( tmp , v1 );
			for( i=0 ; i<20 ; i++ )
			{
				rx = tmp[X] - center[X];
				ry = tmp[Y] - center[Y];
				tmp[X] = center[X] + rx*cosdel - ry*sindel;
				tmp[Y] = center[Y] + rx*sindel + ry*cosdel;
				MAT4X3PNT( tmp2 , *dir[entno]->rot , tmp );
				RT_ADD_VLIST( vhead , tmp2 , BN_VLIST_LINE_DRAW );
			}
		}
		break;
	  case 7:
	  case 8:
		/* Create unit vector parallel to leader */
		v3[0] = v2[0] - v1[0];
		v3[1] = v2[1] - v1[1];
		v3[2] = 0.0;
		c = sqrt( v3[0]*v3[0] + v3[1]*v3[1] );
		v3[0] = v3[0]/c;
		v3[1] = v3[1]/c;
		/* Create unit vector perp. to leader */
		v2[0] = v3[1];
		v2[1] = (-v3[0]);
		RT_ADD_VLIST( vhead , tmp2 , BN_VLIST_LINE_MOVE );
		tmp[0] = v1[0] + v2[0]*b/2.0;
		tmp[1] = v1[1] + v2[1]*b/2.0;
		tmp[2] = v1[2];
		MAT4X3PNT( tmp3 , *dir[entno]->rot , tmp );
		RT_ADD_VLIST( vhead , tmp3 , BN_VLIST_LINE_DRAW );
		tmp[0] += v3[0]*a;
		tmp[1] += v3[1]*a;
		MAT4X3PNT( tmp3 , *dir[entno]->rot , tmp );
		RT_ADD_VLIST( vhead , tmp3 , BN_VLIST_LINE_DRAW );
		tmp[0] -= v2[0]*b;
		tmp[1] -= v2[1]*b;
		MAT4X3PNT( tmp3 , *dir[entno]->rot , tmp );
		RT_ADD_VLIST( vhead , tmp3 , BN_VLIST_LINE_DRAW );
		tmp[0] -= v3[0]*a;
		tmp[1] -= v3[1]*a;
		MAT4X3PNT( tmp3 , *dir[entno]->rot , tmp );
		RT_ADD_VLIST( vhead , tmp3 , BN_VLIST_LINE_DRAW );
		RT_ADD_VLIST( vhead , tmp2 , BN_VLIST_LINE_DRAW );
		break;
	  case 9:
	  case 10:
		/* Create unit vector parallel to leader */
		v3[0] = v2[0] - v1[0];
		v3[1] = v2[1] - v1[1];
		v3[2] = 0.0;
		VUNITIZE( v3 );

		/* Create unit vector perp. to leader */
		v2[0] = v3[1];
		v2[1] = (-v3[0]);

		tmp[0] = v1[0] + v2[0]*b/2.0 + v3[0]*a/2.0;
		tmp[1] = v1[1] + v2[1]*b/2.0 + v3[1]*a/2.0;
		tmp[2] = v1[2];
		MAT4X3PNT( tmp3 , *dir[entno]->rot , tmp );
		RT_ADD_VLIST( vhead , tmp3 , BN_VLIST_LINE_MOVE );
		tmp[0] -= v3[0]*a + v2[0]*b;
		tmp[1] -= v3[1]*a + v2[1]*b;
		MAT4X3PNT( tmp3 , *dir[entno]->rot , tmp );
		RT_ADD_VLIST( vhead , tmp3 , BN_VLIST_LINE_DRAW );
		break;
	}
}

void
Draw_entities( m , view_number , de_list , no_of_des , x , y , ang , local_scale , clip , xform )
struct model *m;
int view_number;
int de_list[];
int no_of_des;
fastf_t x , y , local_scale , ang;
plane_t clip[6];
mat_t *xform;
{
	struct bu_list vhead;
	struct bn_vlist *vp;
	struct ptlist *pts,*ptr;
	struct nmgregion *r;
	struct shell *s;
	int npts;
	int entno;
	int i;
	fastf_t sina,cosa;

	NMG_CK_MODEL( m );

	r = nmg_mrsv( m );
	s = BU_LIST_FIRST( shell , &r->s_hd );

	BU_LIST_INIT( &vhead );
	BU_LIST_INIT( &rt_g.rtg_vlfree );

	sina = sin( ang );
	cosa = cos( ang );

	for( entno=0 ; entno<totentities ; entno++ )
	{
		int status;

		status = (dir[entno]->status/10000)%100;

		/* only draw those entities that are independent and belong to this view */
		if( status && status != 2 ) /* not independent */
			continue;

		if( dir[entno]->view ) /* this entitiy doesn't always get drawn */
		{
			int do_entity=0;

			/* look for its view entity on the list */
			for( i=0 ; i<no_of_des ; i++ )
			{
				if( dir[entno]->view == de_list[i] )
				{
					/* found it, so we do this entity */
					do_entity = 1;
					break;
				}
			}
			if( !do_entity )
				continue;
		}

		switch( dir[entno]->type )
		{
			case 212:   /* "general note" entity (text) */
				Note_to_vlist( entno , &vhead );
				break;
			case 214:	/* leader (arrow) */
				Leader_to_vlist( entno , &vhead );
				break;
			default:
				npts = Getcurve( entno , &pts );
				if( npts > 1 )
					Curve_to_vlist( &vhead , pts );

				/* free list of points */
				ptr = pts;
				while( ptr != NULL )
				{
					struct ptlist *tmp_ptr;

					tmp_ptr = ptr->next;
					bu_free( (char *)ptr, "Draw_entities: ptr" );
					ptr = tmp_ptr;;
				}
				break;
		}

		/* rotate, scale, clip, etc, ect, etc... */
		for( BU_LIST_FOR( vp , bn_vlist , &vhead ) )
		{
			register int nused = vp->nused;

			for( i=0 ; i<nused ; i++ )
			{
				point_t tmp_pt;

				/* Model to view transform */
				if( xform )
					MAT4X3PNT( tmp_pt , *xform , vp->pt[i] )
				else
					VMOVE( tmp_pt , vp->pt[i] );

				/* XXXX should do clipping here */

				/* project to XY plane */
				if( do_projection )
					vp->pt[i][Z] = 0.0;

				/* scale, rotate, and translate */
				if( ang == 0.0 )
				{
					vp->pt[i][X] = local_scale * tmp_pt[X] + x;
					vp->pt[i][Y] = local_scale * tmp_pt[Y] + y;
					if( !do_projection )
						vp->pt[i][Z] = local_scale * tmp_pt[Z];
				}
				else
				{
					vp->pt[i][X] = local_scale*(cosa*tmp_pt[X] - sina*tmp_pt[Y]) + x;
					vp->pt[i][Y] = local_scale*(sina*tmp_pt[X] + cosa*tmp_pt[Y]) + y;
					if( !do_projection )
						vp->pt[i][Z] = local_scale * tmp_pt[Z];
				}
			}
		}

		/* Convert to BRLCAD wire edges */
		nmg_vlist_to_wire_edges( s , &vhead );
		RT_FREE_VLIST( &vhead );
	}
}

struct views_visible *
Get_views_visible( entno )
int entno;
{
	int entity_type;
	int no_of_views;
	int no_of_entities;
	int i,j,junk;
	struct views_visible *vv;

	if( dir[entno]->form != 3 && dir[entno]->form != 4 )
	{
		bu_log( "Get_views_visible called for wrong form of Associatitivity entity\n");
		return( (struct views_visible *)NULL );
	}

	Readrec( dir[entno]->param );
	Readint( &entity_type , "" );
	if( entity_type != 402 )
	{
		bu_log( "Expected Views Visible entity data at P%07d, got type %d\n" , dir[entno]->param , entity_type );
		return( (struct views_visible *)NULL );
	}

	Readint( &no_of_views , "" );
	Readint( &no_of_entities , "" );
	vv = (struct views_visible *)bu_malloc( sizeof( struct views_visible ) , "Get_views_visible: vv" );
	vv->de = entno * 2 + 1;
	vv->no_of_views = no_of_views;
	vv->view_de = (int *)bu_calloc( no_of_views , sizeof( int ) , "Get_views_visible: vv->view_de" );
	for( i=0 ; i<no_of_views ; i++ )
	{
		Readint( &vv->view_de[i] , "" );
		if( dir[entno]->form == 3 )
			continue;

		/* skip extra stuff in form 4 */
		for( j=0 ; j<4 ; j++ )
			Readint( &junk , "" );
	}

	return( vv );
}

void
Do_view( m , view_vis_list , entno , x , y , ang )
struct model *m;
struct bu_ptbl *view_vis_list;
int entno;
fastf_t x,y,ang;
{
	int view_de;
	int entity_type;
	struct views_visible *vv;
	int vv_count=0;
	int *de_list;			/* list of possible view field entries for this view */
	int no_of_des;			/* length of above list */
	int view_number;
	fastf_t local_scale=1.0;
	int clip_de[6];
	plane_t clip[6];
	mat_t *xform;
	int i,j;

	view_de = entno * 2 + 1;

	Readrec( dir[entno]->param );
	Readint( &entity_type , "" );
	if( entity_type != 410 )
	{
		bu_log( "Expected View entity data at P%07d, got type %d\n" , dir[entno]->param , entity_type );
		return;
	}

	Readint( &view_number , "\tView number: " );
	Readflt( &local_scale , "" );

	for( i=0 ; i<6 ; i++ )
	{
		clip_de[i] = 0;
		Readint( &clip_de[i] , "" );
		clip_de[i] = (clip_de[i] - 1)/2;
	}

	xform = dir[entno]->rot;

	for( i=0 ; i<6 ; i++ )
	{
		for( j=0 ; j<4 ; j++ )
			clip[i][j] = 0.0;
	}

	for( i=0 ; i<6 ; i++ )
	{
		if( clip_de[i] )
			Get_plane( clip[i] , clip_de[i] );
		else
		{
			clip[i][3] = MAX_FASTF;
			switch( i )
			{
				case 0:
					clip[i][0] = (-1.0);
					break;
				case 1:
					clip[i][1] = 1.0;
					break;
				case 2:
					clip[i][0] = 1.0;
					break;
				case 3:
					clip[i][1] = (-1.0);
					break;
				case 4:
					clip[i][2] = (-1.0);
					break;
				case 5:
					clip[i][2] = 1.0;
					break;
			}
		}
	}

	for( i=0 ; i<BU_PTBL_END( view_vis_list ) ; i++ )
	{
		vv = (struct views_visible *)BU_PTBL_GET( view_vis_list , i );
		for( j=0 ; j<vv->no_of_views ; j++ )
		{
			if( vv->view_de[j] == view_de )
			{
				vv_count++;
				break;
			}
		}
	}

	no_of_des = vv_count + 1;
	de_list = (int *)bu_calloc( no_of_des , sizeof( int ) , "Do_view: de_list" );
	de_list[0] = view_de;
	vv_count=0;
	for( i=0 ; i<BU_PTBL_END( view_vis_list ) ; i++ )
	{
		vv = (struct views_visible *)BU_PTBL_GET( view_vis_list , i );
		for( j=0 ; j<vv->no_of_views ; j++ )
		{
			if( vv->view_de[j] == view_de )
			{
				vv_count++;
				de_list[vv_count] = vv->view_de[j];
				break;
			}
		}
	}

	Draw_entities( m , view_number , de_list , no_of_des , x , y , ang , (fastf_t)local_scale , clip , xform );

	bu_free( (char *)de_list , "Do_view: de_list" );
}

void
Get_drawing( entno , view_vis_list )
int entno;
struct bu_ptbl *view_vis_list;
{
	int entity_type;
	int no_of_views;
	int *view_entno;
	int i;
	fastf_t *x,*y,*ang;
	struct wmember headp;

	BU_LIST_INIT( &headp.l );

	Readrec( dir[entno]->param );
	Readint( &entity_type , "" );
	if( entity_type != 404 )
	{
		bu_log( "Expected Drawing entity data at P%07d, got type %d\n" , dir[entno]->param , entity_type );
		return;
	}
	Readint( &no_of_views , "" );
	view_entno = (int *)bu_calloc( no_of_views , sizeof( int ) , "Get_drawing: view_entno" );
	x = (fastf_t *)bu_calloc( no_of_views , sizeof( fastf_t ) , "Get_drawing: x" );
	y = (fastf_t *)bu_calloc( no_of_views , sizeof( fastf_t ) , "Get_drawing: y" );
	ang = (fastf_t *)bu_calloc( no_of_views , sizeof( fastf_t ) , "Get_drawing: ang" );
	for( i=0 ; i<no_of_views ; i++ )
	{
		Readint( &view_entno[i] , "" );
		view_entno[i] = (view_entno[i] - 1)/2;
		Readflt( &x[i] , "" );
		Readflt( &y[i] , "" );
		if( dir[i]->form == 1 )
			Readflt( &ang[i] , "" );
		else
			ang[i] = 0.0;
	}

	for( i=0 ; i<no_of_views ; i++ )
	{
		struct model *m;
		struct nmgregion *r;
		struct shell *s;

		m = nmg_mm();

		Do_view( m , view_vis_list , view_entno[i] , (fastf_t)x[i] , (fastf_t)y[i] , (fastf_t)ang[i] );

		/* write the view to the BRLCAD file if the model is not empty */
		NMG_CK_MODEL( m );
		r = BU_LIST_FIRST( nmgregion , &m->r_hd );
		if( BU_LIST_NOT_HEAD( &r->l , &m->r_hd ) )
		{
			NMG_CK_REGION( r );
			s = BU_LIST_FIRST( shell , &r->s_hd );
			if( BU_LIST_NOT_HEAD( &s->l , &r->s_hd ) )
			{
				if( BU_LIST_NON_EMPTY( &s->eu_hd ) )
				{
					nmg_rebound( m , &tol );
					mk_nmg( fdout , dir[view_entno[i]]->name , m );
					(void)mk_addmember( dir[view_entno[i]]->name , &headp.l , NULL, WMOP_UNION );
				}
			}
		}
	}

	(void)mk_lfcomb( fdout , dir[entno]->name , &headp , 0 )

/*	if( no_of_views )
	{
		bu_free( (char *)view_entno , "Get_drawing: view_entno" );
		bu_free( (char *)x , "Get_drawing: x" );
		bu_free( (char *)y , "Get_drawing: y" );
		bu_free( (char *)ang , "Get_drawing: ang" );
	}
*/
}

void
Conv_drawings()
{
	int i;
	int tot_drawings=0;
	int tot_views=0;
	struct views_visible *vv;
	struct model *m;
	struct nmgregion *r;
	struct shell *s;
	struct bu_ptbl view_vis_list;

	bu_log( "\n\nConverting drawing entities:\n" );

	bu_ptbl_init( &view_vis_list , 64, " &view_vis_list ");

	for( i=0 ; i<totentities ; i++ )
	{
		if( dir[i]->type != 402 )
			continue;

		if( dir[i]->form != 3 && dir[i]->form != 4 )
			continue;

		vv = Get_views_visible( i );
		if( vv )
			bu_ptbl_ins( &view_vis_list , (long *)vv );
			
	}

	for( i=0 ; i<totentities ; i++ )
	{
		if( dir[i]->type == 404 )
			tot_drawings++;
	}

	if( tot_drawings )
	{
		/* Convert each drawing */
		for( i=0 ; i<totentities ; i++ )
		{
			if( dir[i]->type == 404 )
				Get_drawing( i , &view_vis_list );
		}

		/* free views visible list */
		for( i=0 ; i<BU_PTBL_END( &view_vis_list ) ; i++ )
		{
			vv = (struct views_visible *)BU_PTBL_GET( &view_vis_list , i );
			bu_free( (char *)vv->view_de , "Conv_drawings: vv->view_de" );
			bu_free( (char *)vv , "Conv_drawings: vv" );
		}
		bu_ptbl_free( &view_vis_list );
		return;
	}
	bu_log( "\nNo drawings entities\n" );

	/* no drawing entities, so look for view entities */
	for( i=0 ; i<totentities ; i++ )
	{
		if( dir[i]->type == 410 )
			tot_views++;
	}

	if( tot_views )
	{
		struct wmember headp;

		BU_LIST_INIT( &headp.l );
		/* Convert each view */
		for( i=0 ; i<totentities ; i++ )
		{
			if( dir[i]->type == 410 )
			{
				m = nmg_mm();

				Do_view( m , &view_vis_list , i , 0.0 , 0.0 , 0.0 );

				/* write the drawing to the BRLCAD file if the model is not empty */
				r = BU_LIST_FIRST( nmgregion , &m->r_hd );
				if( BU_LIST_NOT_HEAD( &r->l , &m->r_hd ) )
				{
					NMG_CK_REGION( r );
					s = BU_LIST_FIRST( shell , &r->s_hd );
					if( BU_LIST_NOT_HEAD( &s->l , &r->s_hd ) )
					{
						if( BU_LIST_NON_EMPTY( &s->eu_hd ) )
						{
							nmg_rebound( m , &tol );
							mk_nmg( fdout , dir[i]->name , m );
							(void)mk_addmember( dir[i]->name , &headp.l , NULL, WMOP_UNION );
						}
					}
				}
			}
		}
		(void)mk_lfcomb( fdout , default_drawing_name , &headp , 0 )

		/* free views visible list */
		for( i=0 ; i<BU_PTBL_END( &view_vis_list ) ; i++ )
		{
			vv = (struct views_visible *)BU_PTBL_GET( &view_vis_list , i );
			bu_free( (char *)vv->view_de , "Conv_drawings: vv->view_de" );
			bu_free( (char *)vv , "Conv_drawings: vv" );
		}
		bu_ptbl_free( &view_vis_list );

		return;
	}
	bu_log( "No view entities\n" );

	/* no drawings or views, just convert all independent lines, arcs, etc */
	m = nmg_mm();

	Draw_entities( m , 0 , (int *)NULL , 0 , 0.0 , 0.0 , 0.0 , 1.0 , (plane_t *)NULL , (mat_t *)NULL );

	/* write the drawing to the BRLCAD file if the model is not empty */
	r = BU_LIST_FIRST( nmgregion , &m->r_hd );
	if( BU_LIST_NOT_HEAD( &r->l , &m->r_hd ) )
	{
		NMG_CK_REGION( r );
		s = BU_LIST_FIRST( shell , &r->s_hd );
		if( BU_LIST_NOT_HEAD( &s->l , &r->s_hd ) )
		{
			if( BU_LIST_NON_EMPTY( &s->eu_hd ) )
			{
				nmg_rebound( m , &tol );
				mk_nmg( fdout , default_drawing_name , m );
			}
		}
	}

	/* free views visible list */
	for( i=0 ; i<BU_PTBL_END( &view_vis_list ) ; i++ )
	{
		vv = (struct views_visible *)BU_PTBL_GET( &view_vis_list , i );
		bu_free( (char *)vv->view_de , "Conv_drawings: vv->view_de" );
		bu_free( (char *)vv , "Conv_drawings: vv" );
	}
	bu_ptbl_free( &view_vis_list );
}
@


11.10
log
@update copyright to include span through 2003
@
text
@@


11.9
log
@added matrix parameter to mk_addmember()
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1994 by the United States Army
@


11.9.4.1
log
@sync branch with HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
@


11.9.6.1
log
@sync to HEAD...
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
@


11.9.12.1
log
@merge from HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
@


11.8
log
@Mods to get IGES working with new database format (v5)
@
text
@d754 1
a754 1
					(void)mk_addmember( dir[view_entno[i]]->name , &headp.l , WMOP_UNION );
d862 1
a862 1
							(void)mk_addmember( dir[i]->name , &headp.l , WMOP_UNION );
@


11.7
log
@
mk_addmember
RCSid
@
text
@a208 1
	float tmp;
d220 1
a220 4
	{
		Readflt( &tmp , "" );
		pl[i] = tmp;
	}
d702 1
a702 1
	float *x,*y,*ang;
d716 3
a718 3
	x = (float *)bu_calloc( no_of_views , sizeof( float ) , "Get_drawing: x" );
	y = (float *)bu_calloc( no_of_views , sizeof( float ) , "Get_drawing: y" );
	ang = (float *)bu_calloc( no_of_views , sizeof( float ) , "Get_drawing: ang" );
a757 3

		/* Get rid of the model */
		nmg_km( m );
a865 3

				/* Get rid of the model */
				nmg_km( m );
a902 3

	/* Get rid of the model */
	nmg_km( m );
@


11.6
log
@
Converted from Release 4 names to know about libbu and libbn
@
text
@d758 1
a758 1
					(void)mk_addmember( dir[view_entno[i]]->name , &headp , WMOP_UNION );
d869 1
a869 1
							(void)mk_addmember( dir[i]->name , &headp , WMOP_UNION );
@


11.5
log
@Fixed a bug in readflt.c and added -3 option.
@
text
@d33 2
d60 1
a60 1
		rt_log( "%s" , id );
d77 1
a77 1
		(*str) = (char *)rt_malloc( sizeof( char ) * length + 1, "Getstrg: str" );
d84 1
a84 1
			rt_log( "%c", card[counter] );
d89 1
a89 1
		rt_log( "%c", '\n' );
d110 1
a110 1
struct rt_list *vhead;
d116 2
d122 1
a122 1
		rt_log( "Expected General Note entity data at P%07d, got type %d\n" , dir[entno]->param , entity_type );
d145 1
a145 1
		slant_ang = rt_halfpi;
d189 3
a191 2
				rt_vlist_2string( vhead , one_char , tmp_x , tmp_y , local_scale,
					(double)(rot_ang*180.0*rt_invpi) );
d195 3
a197 2
			rt_vlist_2string( vhead , str , (double)loc[X] , (double)loc[Y] , local_scale,
				(double)(rot_ang*180.0*rt_invpi) );
d199 1
a199 1
		rt_free( str, "Note_to_vlist: str" );
d216 1
a216 1
		rt_log( "Expected Plane entity data at P%07d, got type %d\n" , dir[entno]->param , entity_type );
d229 1
a229 1
struct rt_list *vhead;
d242 1
a242 1
	RT_ADD_VLIST( vhead , ptr->pt , RT_VLIST_LINE_MOVE );
d247 1
a247 1
		RT_ADD_VLIST( vhead , ptr->pt , RT_VLIST_LINE_DRAW );
d255 1
a255 1
struct rt_list *vhead;
d267 1
a267 1
		rt_log( "Expected Leader (Arrow) entity data at P%07d, got type %d\n" , dir[entno]->param , entity_type );
d289 1
a289 1
	RT_ADD_VLIST( vhead , tmp2 , RT_VLIST_LINE_MOVE );
d291 1
a291 1
	RT_ADD_VLIST( vhead , tmp , RT_VLIST_LINE_DRAW );
d298 1
a298 1
		RT_ADD_VLIST( vhead , tmp , RT_VLIST_LINE_DRAW );
d314 1
a314 1
		RT_ADD_VLIST( vhead , tmp2 , RT_VLIST_LINE_MOVE );
d319 1
a319 1
		RT_ADD_VLIST( vhead , tmp , RT_VLIST_LINE_DRAW );
d322 1
a322 1
		RT_ADD_VLIST( vhead , tmp2 , RT_VLIST_LINE_MOVE );
d326 1
a326 1
		RT_ADD_VLIST( vhead , tmp , RT_VLIST_LINE_DRAW );
d335 1
a335 1
			delta = rt_pi/10.0;
d338 1
a338 1
			RT_ADD_VLIST( vhead , tmp2 , RT_VLIST_LINE_MOVE );
d347 1
a347 1
				RT_ADD_VLIST( vhead , tmp2 , RT_VLIST_LINE_DRAW );
d363 1
a363 1
		RT_ADD_VLIST( vhead , tmp2 , RT_VLIST_LINE_MOVE );
d368 1
a368 1
		RT_ADD_VLIST( vhead , tmp3 , RT_VLIST_LINE_DRAW );
d372 1
a372 1
		RT_ADD_VLIST( vhead , tmp3 , RT_VLIST_LINE_DRAW );
d376 1
a376 1
		RT_ADD_VLIST( vhead , tmp3 , RT_VLIST_LINE_DRAW );
d380 2
a381 2
		RT_ADD_VLIST( vhead , tmp3 , RT_VLIST_LINE_DRAW );
		RT_ADD_VLIST( vhead , tmp2 , RT_VLIST_LINE_DRAW );
d399 1
a399 1
		RT_ADD_VLIST( vhead , tmp3 , RT_VLIST_LINE_MOVE );
d403 1
a403 1
		RT_ADD_VLIST( vhead , tmp3 , RT_VLIST_LINE_DRAW );
d418 2
a419 2
	struct rt_list vhead;
	struct rt_vlist *vp;
d431 1
a431 1
	s = RT_LIST_FIRST( shell , &r->s_hd );
d433 2
a434 2
	RT_LIST_INIT( &vhead );
	RT_LIST_INIT( &rt_g.rtg_vlfree );
d487 1
a487 1
					rt_free( (char *)ptr, "Draw_entities: ptr" );
d494 1
a494 1
		for( RT_LIST_FOR( vp , rt_vlist , &vhead ) )
d550 1
a550 1
		rt_log( "Get_views_visible called for wrong form of Associatitivity entity\n");
d558 1
a558 1
		rt_log( "Expected Views Visible entity data at P%07d, got type %d\n" , dir[entno]->param , entity_type );
d564 1
a564 1
	vv = (struct views_visible *)rt_malloc( sizeof( struct views_visible ) , "Get_views_visible: vv" );
d567 1
a567 1
	vv->view_de = (int *)rt_calloc( no_of_views , sizeof( int ) , "Get_views_visible: vv->view_de" );
d585 1
a585 1
struct nmg_ptbl *view_vis_list;
d608 1
a608 1
		rt_log( "Expected View entity data at P%07d, got type %d\n" , dir[entno]->param , entity_type );
d661 1
a661 1
	for( i=0 ; i<NMG_TBL_END( view_vis_list ) ; i++ )
d663 1
a663 1
		vv = (struct views_visible *)NMG_TBL_GET( view_vis_list , i );
d675 1
a675 1
	de_list = (int *)rt_calloc( no_of_des , sizeof( int ) , "Do_view: de_list" );
d678 1
a678 1
	for( i=0 ; i<NMG_TBL_END( view_vis_list ) ; i++ )
d680 1
a680 1
		vv = (struct views_visible *)NMG_TBL_GET( view_vis_list , i );
d694 1
a694 1
	rt_free( (char *)de_list , "Do_view: de_list" );
d700 1
a700 1
struct nmg_ptbl *view_vis_list;
d709 1
a709 1
	RT_LIST_INIT( &headp.l );
d715 1
a715 1
		rt_log( "Expected Drawing entity data at P%07d, got type %d\n" , dir[entno]->param , entity_type );
d719 4
a722 4
	view_entno = (int *)rt_calloc( no_of_views , sizeof( int ) , "Get_drawing: view_entno" );
	x = (float *)rt_calloc( no_of_views , sizeof( float ) , "Get_drawing: x" );
	y = (float *)rt_calloc( no_of_views , sizeof( float ) , "Get_drawing: y" );
	ang = (float *)rt_calloc( no_of_views , sizeof( float ) , "Get_drawing: ang" );
d747 2
a748 2
		r = RT_LIST_FIRST( nmgregion , &m->r_hd );
		if( RT_LIST_NOT_HEAD( &r->l , &m->r_hd ) )
d751 2
a752 2
			s = RT_LIST_FIRST( shell , &r->s_hd );
			if( RT_LIST_NOT_HEAD( &s->l , &r->s_hd ) )
d754 1
a754 1
				if( RT_LIST_NON_EMPTY( &s->eu_hd ) )
d771 4
a774 4
		rt_free( (char *)view_entno , "Get_drawing: view_entno" );
		rt_free( (char *)x , "Get_drawing: x" );
		rt_free( (char *)y , "Get_drawing: y" );
		rt_free( (char *)ang , "Get_drawing: ang" );
d789 1
a789 1
	struct nmg_ptbl view_vis_list;
d791 1
a791 1
	rt_log( "\n\nConverting drawing entities:\n" );
d793 1
a793 1
	nmg_tbl( &view_vis_list , TBL_INIT , NULL );
d805 1
a805 1
			nmg_tbl( &view_vis_list , TBL_INS , (long *)vv );
d825 1
a825 1
		for( i=0 ; i<NMG_TBL_END( &view_vis_list ) ; i++ )
d827 3
a829 3
			vv = (struct views_visible *)NMG_TBL_GET( &view_vis_list , i );
			rt_free( (char *)vv->view_de , "Conv_drawings: vv->view_de" );
			rt_free( (char *)vv , "Conv_drawings: vv" );
d831 1
a831 1
		nmg_tbl( &view_vis_list , TBL_FREE , NULL );
d834 1
a834 1
	rt_log( "\nNo drawings entities\n" );
d847 1
a847 1
		RT_LIST_INIT( &headp.l );
d858 2
a859 2
				r = RT_LIST_FIRST( nmgregion , &m->r_hd );
				if( RT_LIST_NOT_HEAD( &r->l , &m->r_hd ) )
d862 2
a863 2
					s = RT_LIST_FIRST( shell , &r->s_hd );
					if( RT_LIST_NOT_HEAD( &s->l , &r->s_hd ) )
d865 1
a865 1
						if( RT_LIST_NON_EMPTY( &s->eu_hd ) )
d881 1
a881 1
		for( i=0 ; i<NMG_TBL_END( &view_vis_list ) ; i++ )
d883 3
a885 3
			vv = (struct views_visible *)NMG_TBL_GET( &view_vis_list , i );
			rt_free( (char *)vv->view_de , "Conv_drawings: vv->view_de" );
			rt_free( (char *)vv , "Conv_drawings: vv" );
d887 1
a887 1
		nmg_tbl( &view_vis_list , TBL_FREE , NULL );
d891 1
a891 1
	rt_log( "No view entities\n" );
d899 2
a900 2
	r = RT_LIST_FIRST( nmgregion , &m->r_hd );
	if( RT_LIST_NOT_HEAD( &r->l , &m->r_hd ) )
d903 2
a904 2
		s = RT_LIST_FIRST( shell , &r->s_hd );
		if( RT_LIST_NOT_HEAD( &s->l , &r->s_hd ) )
d906 1
a906 1
			if( RT_LIST_NON_EMPTY( &s->eu_hd ) )
d918 1
a918 1
	for( i=0 ; i<NMG_TBL_END( &view_vis_list ) ; i++ )
d920 3
a922 3
		vv = (struct views_visible *)NMG_TBL_GET( &view_vis_list , i );
		rt_free( (char *)vv->view_de , "Conv_drawings: vv->view_de" );
		rt_free( (char *)vv , "Conv_drawings: vv" );
d924 1
a924 1
	nmg_tbl( &view_vis_list , TBL_FREE , NULL );
@


11.4
log
@All logging done via rt_log
@
text
@d132 1
a132 1
		double scale;
d155 3
a157 3
		scale = width/str_len;
		if( height < scale )
			scale = height;
d159 2
a160 2
		if( scale < height )
			loc[Y] += (height - scale)/2.0;
d162 2
a163 2
		if( scale*str_len < width )
			loc[X] += (width - (scale*str_len))/2.0;
d172 2
a173 2
			xdel = scale * sin( rot_ang );
			ydel = scale * cos( rot_ang );
d185 1
a185 1
				rt_vlist_2string( vhead , one_char , tmp_x , tmp_y , scale,
d190 1
a190 1
			rt_vlist_2string( vhead , str , (double)loc[X] , (double)loc[Y] , scale,
d403 1
a403 1
Draw_entities( m , view_number , de_list , no_of_des , x , y , ang , scale , clip , xform )
d408 1
a408 1
fastf_t x , y , scale , ang;
d435 4
d440 1
a440 1
		if( (dir[entno]->status/10000)%100 ) /* not independent */
d505 2
a506 1
				vp->pt[i][Z] = 0.0;
d511 4
a514 2
					vp->pt[i][X] = scale * tmp_pt[X] + x;
					vp->pt[i][Y] = scale * tmp_pt[Y] + y;
d518 4
a521 2
					vp->pt[i][X] = scale*(cosa*tmp_pt[X] - sina*tmp_pt[Y]) + x;
					vp->pt[i][Y] = scale*(sina*tmp_pt[X] + cosa*tmp_pt[Y]) + y;
d590 1
a590 1
	float scale=1.0;
d607 1
a607 1
	Readflt( &scale , "" );
d686 1
a686 1
	Draw_entities( m , view_number , de_list , no_of_des , x , y , ang , (fastf_t)scale , clip , xform );
@


11.3
log
@Mods to handle TNURB BREP. Also added RT_EXTERNS to iges_struct.h.
@
text
@d58 1
a58 1
		printf( "%s" , id );
d82 1
a82 1
			putchar( card[counter] );
d87 1
a87 1
		putchar( '\n' );
d776 1
a776 1
	printf( "\n\nConverting drawing entities:\n" );
d819 1
a819 1
	printf( "\nNo drawings entities\n" );
d876 1
a876 1
	printf( "No view entities\n" );
@


11.2
log
@Converted to use rt_malloc family.
@
text
@a20 7
#include "conf.h"

#include <stdio.h>
#include <math.h>

#include "machine.h"
#include "vmath.h"
a22 2
#include "raytrace.h"
#include "wdb.h"
@


11.1
log
@Release_4.4
@
text
@d84 1
a84 1
		(*str) = (char *)malloc( sizeof( char ) * length + 1 );
d202 1
a202 1
		free( str );
d486 1
a486 1
					free( ptr );
@


1.8
log
@Mods for Irix 6.
@
text
@@


1.7
log
@Added checks for nonempty wire edge list in shell before outputting NMG model.
@
text
@a39 1
static struct nmg_ptbl view_vis_list;
a140 1
		fastf_t x=0.0,y=0.0,z=0.0;
d230 1
a230 1
int
d238 1
a238 1
		return( 0 );
d241 1
a241 1
		return( 0 );
a261 1
	int nsegs;
a747 2
				struct wmember *wm;

d752 1
a752 1
					wm = mk_addmember( dir[view_entno[i]]->name , &headp , WMOP_UNION );
a858 2
						struct wmember *wm;

d863 1
a863 1
							wm = mk_addmember( dir[i]->name , &headp , WMOP_UNION );
@


1.6
log
@cosa was not being initialized, it was being subtracted!
Call the trig routines all the time, so the variables have good values in them.
@
text
@d753 6
a758 2
				mk_nmg( fdout , dir[view_entno[i]]->name , m );
				wm = mk_addmember( dir[view_entno[i]]->name , &headp , WMOP_UNION );
d866 6
a871 2
						mk_nmg( fdout , dir[i]->name , m );
						wm = mk_addmember( dir[i]->name , &headp , WMOP_UNION );
d906 7
a912 1
			mk_nmg( fdout , default_drawing_name , m );
@


1.5
log
@Factored ifdefs
@
text
@d442 2
a443 5
	if( ang != 0.0 )
	{
		sina = sin( ang );
		cosa - cos( ang );
	}
@


1.4
log
@Changes by jra
@
text
@d20 3
d25 1
@


1.3
log
@Fixed bug in vertical text
@
text
@d141 1
d153 3
a155 3
		Readcnv( &x , "" );
		Readcnv( &y , "" );
		Readcnv( &z , "" );		/* not currently used */
d158 4
d167 1
a167 1
			y += (height - scale)/2.0;
d170 1
a170 1
			x += (width - (scale*str_len))/2.0;
d182 2
a183 2
			tmp_y = y;
			tmp_x = x;
d197 1
a197 1
			rt_vlist_2string( vhead , str , (double)x , (double)y , scale,
d254 157
d468 1
a468 3
		if( dir[entno]->type == 212 )   /* this is a "general note" entity (text) */
			Note_to_vlist( entno , &vhead );
		else
d470 16
a485 9
			npts = Getcurve( entno , &pts );
			if( npts > 1 )
				Curve_to_vlist( &vhead , pts );

			/* free list of points */
			ptr = pts;
			while( ptr != NULL )
			{
				struct ptlist *tmp_ptr;
d487 5
a491 4
				tmp_ptr = ptr->next;
				free( ptr );
				ptr = tmp_ptr;;
			}
a496 1
			register int i;
d499 1
a499 1
			for( i=0 ; i>nused ; i++ )
d752 2
a753 2
				mk_nmg( fdout , dir[i]->name , m );
				wm = mk_addmember( dir[i]->name , &headp , WMOP_UNION );
d763 8
a770 4
	rt_free( (char *)view_entno , "Get_drawing: view_entno" );
	rt_free( (char *)x , "Get_drawing: x" );
	rt_free( (char *)y , "Get_drawing: y" );
	rt_free( (char *)ang , "Get_drawing: ang" );
@


1.2
log
@Added vertical text.
@
text
@d151 1
a151 1
		Readint( &internal_rot , "" );	/* not currently used */
d174 2
a175 2
			xdel = scale * sin( rot_angle );
			ydel = sclae * cos( rot_angle );
d181 1
a181 1
			for( j=0 ; i<str_len ; j++ )
a182 2
				double tmp_x,tmp_y;

d186 1
@


1.1
log
@Initial revision
@
text
@d134 2
a135 2
		float slant_ang;
		float rot_ang=0.0;
d167 28
a194 1
		rt_vlist_2string( vhead , str , (double)x , (double)y , scale , (double)(rot_ang*180.0*rt_invpi) );
@
