head	11.18;
access;
symbols
	ansi-20040405-merged:11.16.4.1
	postmerge-20040405-ansi:11.17
	premerge-20040404-ansi:11.17
	postmerge-autoconf:11.17
	autoconf-freeze:11.16.12.1
	premerge-autoconf:11.17
	ansi-20040316-freeze:11.16
	postmerge-20040315-windows:11.17
	premerge-20040315-windows:11.17
	windows-20040315-freeze:11.16.6.1
	autoconf-20031203:11.16
	autoconf-20031202:11.16
	autoconf-branch:11.16.0.12
	phong-branch:11.16.0.10
	photonmap-branch:11.16.0.8
	rel-6-1-DP:11.16
	windows-branch:11.16.0.6
	rel-6-0-2:11.16
	ansi-branch:11.16.0.4
	rel-6-0-1-branch:11.16.0.2
	hartley-6-0-post:11.16
	hartley-6-0-pre:11.16
	rel-6-0-1:11.16
	rel-6-0:11.15
	rel-5-4:11.12
	offsite-5-3-pre:11.14
	rel-5-3:11.12
	rel-5-2:11.12
	rel-5-1-branch:11.12.0.2
	rel-5-1:11.12
	rel-5-0:11.11
	rel-5-0-beta:11.11
	rel-4-5:11.11
	ctj-4-5-post:11.11
	ctj-4-5-pre:11.11
	rel-4-4:11.6
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.18
date	2004.05.24.04.01.07;	author morrison;	state dead;
branches;
next	11.17;

11.17
date	2004.02.02.17.39.04;	author morrison;	state Exp;
branches;
next	11.16;

11.16
date	2002.05.17.12.49.27;	author morrison;	state Exp;
branches
	11.16.4.1
	11.16.6.1
	11.16.12.1;
next	11.15;

11.15
date	2001.11.05.21.20.05;	author morrison;	state Exp;
branches;
next	11.14;

11.14
date	2001.02.06.15.13.42;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	2000.08.24.04.10.47;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	2000.03.29.18.42.42;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	97.03.06.20.24.39;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	96.07.15.19.19.47;	author jra;	state Exp;
branches;
next	11.9;

11.9
date	95.12.06.13.25.06;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	95.11.28.21.35.45;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	95.06.28.15.23.43;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	95.01.04.10.07.34;	author mike;	state Rel4_4;
branches;
next	11.5;

11.5
date	94.11.08.14.50.02;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	94.10.21.20.15.22;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	94.08.22.18.34.51;	author gdurf;	state Exp;
branches;
next	11.2;

11.2
date	94.01.07.15.17.33;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	93.06.28.10.00.21;	author jra;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.45.10;	author mike;	state Rel4_0;
branches;
next	1.2;

1.2
date	91.06.12.20.27.37;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	91.06.12.19.59.10;	author mike;	state Exp;
branches;
next	;

11.16.4.1
date	2004.03.17.21.16.30;	author morrison;	state Exp;
branches;
next	;

11.16.6.1
date	2004.03.11.23.41.13;	author morrison;	state Exp;
branches;
next	;

11.16.12.1
date	2004.02.12.19.41.38;	author erikg;	state Exp;
branches;
next	;


desc
@IGES converter
@


11.18
log
@moved to src/iges/
@
text
@/*
 *  Authors -
 *	John R. Anderson
 *	Susanne L. Muuss
 *	Earl P. Weaver
 *
 *  Source -
 *	VLD/ASB Building 1065
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 */

#include "./iges_struct.h"
#include "./iges_extern.h"

void
Convinst()
{

	int			i,j,k;
	int			type;
	int			pointer;
	int			conv=0;
	int			totinst=0;
	int			no_of_assoc=0;
	int			no_of_props=0;
	int			att_de=0;
	struct brlcad_att	brl_att;
	mat_t			*rot;

	for( i=0 ; i<totentities ; i++ )
	{
		if( dir[i]->type != 430 ) /* This is not an instance */
			continue;

		totinst++;

		/* read parameters */
		if( dir[i]->param <= pstart )
		{
			bu_log( "Illegal parameter pointer for entity D%07d (%s)\n" ,
					dir[i]->direct , dir[i]->name );
			continue;
		}
		Readrec( dir[i]->param );
		Readint( &type , "" );
		Readint( &pointer , "" );

		/* convert pointer to a "dir" index */
		pointer = (pointer - 1)/2;
		if( pointer < 0 || pointer >= totentities )
		{
			bu_log( "Primitive instance D%07d (%s) does not point to a legal primitive\n",
				dir[i]->direct , dir[i]->name );
			continue;
		}

		/* skip over the associativities */
		Readint( &no_of_assoc , "" );
		for( k=0 ; k<no_of_assoc ; k++ )
			Readint( &j , "" );

		/* get property entity DE's */
		att_de = 0;
		Readint( &no_of_props , "" );
		for( k=0 ; k<no_of_props ; k++ )
		{
			Readint( &j , "" );
			if( dir[(j-1)/2]->type == 422 &&
				 dir[(j-1)/2]->referenced == brlcad_att_de )
			{
				/* this is one of our attribute instances */
				att_de = j;
			}
		}

		bzero( &brl_att, sizeof( struct brlcad_att ) );
		Read_att( att_de , &brl_att );

		if( att_de )
		{
			/* This is actually a region or a group with just one member */
			unsigned char *rgb;
			struct wmember head;

			BU_LIST_INIT( &head.l );
			(void)mk_addmember( dir[pointer]->name , &head.l , NULL, WMOP_INTERSECT );

			/* Make the object */
			if( dir[i]->colorp != 0 )
				rgb = (unsigned char*)dir[i]->rgb;
			else
				rgb = (unsigned char *)0;

			mk_lrcomb( fdout , 
				dir[i]->name,		/* name */
				&head,			/* members */
				brl_att.region_flag,	/* region flag */
				brl_att.material_name,	/* material name */
				brl_att.material_params, /* material parameters */
				rgb,			/* color */
				brl_att.ident,		/* ident */
				brl_att.air_code,	/* air code */
				brl_att.material_code,	/* GIFT material */
				brl_att.los_density,	/* los density */
				brl_att.inherit );	/* inherit */

		}
		else
		{
			/* copy pointed to object info to replace instance entity */
			dir[i]->type = dir[pointer]->type;
			dir[i]->form = dir[pointer]->form;
			dir[i]->param = dir[pointer]->param;
			dir[i]->name = dir[pointer]->name;

			/* increment reference count for pointed to entity */
			dir[pointer]->referenced++;

			/* fix up transformation matrix if needed */
			if( dir[i]->trans == 0 && dir[pointer]->trans == 0 )
			{
				continue;	/* nothing to do */
			}
			else if( dir[i]->trans == 0 )
			{
				dir[i]->trans = dir[pointer]->trans;	/* same as instanced */
			}
			else if( dir[i]->trans != 0 )
			{
				/* this instance refers to a transformation entity
				   but the original instanced object does too,
				   these matrices need to be combined */

				rot = (mat_t *)bu_malloc( sizeof( mat_t ), "Convinst: rot" );
				Matmult( *(dir[i]->rot) , *(dir[pointer]->rot) , *rot );
				dir[i]->rot = rot;
			}
		}
		conv++;
	}

	bu_log( "\nConverted %d solid instances out of %d total instances\n" , conv , totinst );
}
@


11.17
log
@update copyright to include span through 2003
@
text
@@


11.16
log
@added matrix parameter to mk_addmember()
@
text
@d13 1
a13 1
 *	This software is Copyright (C) 1990 by the United States Army.
@


11.16.4.1
log
@sync branch with HEAD
@
text
@d13 1
a13 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
@


11.16.6.1
log
@sync to HEAD...
@
text
@d13 1
a13 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
@


11.16.12.1
log
@merge from HEAD
@
text
@d13 1
a13 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
@


11.15
log
@Solid to Primitive naming convention conversions
@
text
@d91 1
a91 1
			(void)mk_addmember( dir[pointer]->name , &head.l , WMOP_INTERSECT );
@


11.14
log
@Mods to get IGES working with new database format (v5)
@
text
@d57 1
a57 1
			bu_log( "Solid instance D%07d (%s) does not point to a legal solid\n",
@


11.13
log
@
mk_addmember
RCSid
@
text
@d140 1
a140 1
				Matmult( *(dir[i]->rot) , dir[pointer]->rot , rot );
@


11.12
log
@
Converted from Release 4 names to know about libbu and libbn
@
text
@d91 1
a91 1
			(void)mk_addmember( dir[pointer]->name , &head , WMOP_INTERSECT );
@


11.11
log
@Converted to use combination import/export.
@
text
@d45 1
a45 1
			rt_log( "Illegal parameter pointer for entity D%07d (%s)\n" ,
d57 1
a57 1
			rt_log( "Solid instance D%07d (%s) does not point to a legal solid\n",
d90 1
a90 1
			RT_LIST_INIT( &head.l );
d139 1
a139 1
				rot = (mat_t *)rt_malloc( sizeof( mat_t ), "Convinst: rot" );
d147 1
a147 1
	rt_log( "\nConverted %d solid instances out of %d total instances\n" , conv , totinst );
@


11.10
log
@Minor Mods for IRIX 6.2
@
text
@d68 1
d81 1
d119 1
a126 1
				rt_log( "Instance and pointed to object both have no xforms\n" );
a131 1
				rt_log( "use pointed to object's xform\n" );
a137 2

				rt_log( "Must do a concatonation\n" );
@


11.9
log
@All logging done via rt_log
@
text
@d20 1
@


11.8
log
@Mods to handle TNURB BREP. Also added RT_EXTERNS to iges_struct.h.
@
text
@d44 1
a44 1
			printf( "Illegal parameter pointer for entity D%07d (%s)\n" ,
d56 1
a56 1
			printf( "Solid instance D%07d (%s) does not point to a legal solid\n",
d147 1
a147 1
	printf( "\nConverted %d solid instances out of %d total instances\n" , conv , totinst );
@


11.7
log
@Converted to use rt_malloc family.
@
text
@a16 5
#include "conf.h"

#include <stdio.h>
#include "machine.h"
#include "vmath.h"
a18 1
#include "wdb.h"
@


11.6
log
@Release_4.4
@
text
@d145 1
a145 1
				rot = (mat_t *)malloc( sizeof( mat_t ) );
@


11.5
log
@Mods for Irix 6.
@
text
@@


11.4
log
@rgb is now unsigned char
@
text
@d90 1
a91 2
			struct wmember *wmem;
			unsigned char *rgb;
d94 1
a94 1
			wmem = mk_addmember( dir[pointer]->name , &head , WMOP_INTERSECT );
@


11.3
log
@Added include of conf.h
@
text
@d92 1
a92 1
			char *rgb;
d99 1
a99 1
				rgb = (char*)dir[i]->rgb;
d101 1
a101 1
				rgb = (char *)0;
@


11.2
log
@Modified header files
@
text
@d17 2
@


11.1
log
@Major Upgrade to IGES 5.1
@
text
@d32 2
a33 2
	int			no_of_assoc;
	int			no_of_props;
d94 1
d127 2
d130 1
d132 1
d134 2
d142 2
d145 1
a145 1
				Matmult( rot , *(dir[i]->rot) , dir[pointer]->rot );
@


10.1
log
@Release_4.0
@
text
@d27 10
a36 2
	int i,type,pointer,conv=0,totinst=0;
	mat_t *rot;
d57 1
a57 1
		pointer = (-pointer - 1)/2;
a63 1
		
d65 4
a68 4
		/* copy pointed to object info to replace instance entity */
		dir[i]->type = dir[pointer]->type;
		dir[i]->form = dir[pointer]->form;
		dir[i]->param = dir[pointer]->param;
d70 12
a81 2
		/* increment reference count for pointed to entity */
		dir[pointer]->referenced++;
d83 3
a85 6
		/* fix up transformation matrix if needed */
		if( dir[i]->trans == 0 && dir[pointer]->trans == 0 )
			continue;	/* nothing to do */
		else if( dir[i]->trans == 0 )
			dir[i]->trans = dir[pointer]->trans;	/* same as instanced */
		else if( dir[i]->trans != 0 )
d87 4
a90 3
			/* this instance refers to a transformation entity
			   but the original instanced object does too,
			   these matrices need to be combined */
d92 47
a138 3
			rot = (mat_t *)malloc( sizeof( mat_t ) );
			Matmult( rot , *(dir[i]->rot) , dir[pointer]->rot );
			dir[i]->rot = rot;
@


1.2
log
@Modified for Release 4.0
@
text
@@


1.1
log
@Initial revision
@
text
@d18 2
@
