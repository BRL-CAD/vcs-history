head	11.17;
access;
symbols
	ansi-20040405-merged:11.14.4.1
	postmerge-20040405-ansi:11.15
	premerge-20040404-ansi:11.15
	postmerge-autoconf:11.15
	autoconf-freeze:11.14.12.2
	premerge-autoconf:11.15
	ansi-20040316-freeze:11.14
	postmerge-20040315-windows:11.15
	premerge-20040315-windows:11.15
	windows-20040315-freeze:11.14.6.1
	autoconf-20031203:11.14
	autoconf-20031202:11.14
	autoconf-branch:11.14.0.12
	phong-branch:11.14.0.10
	photonmap-branch:11.14.0.8
	rel-6-1-DP:11.14
	windows-branch:11.14.0.6
	rel-6-0-2:11.14
	ansi-branch:11.14.0.4
	rel-6-0-1-branch:11.14.0.2
	hartley-6-0-post:11.14
	hartley-6-0-pre:11.14
	rel-6-0-1:11.14
	rel-6-0:11.14
	rel-5-4:11.7.2.1
	offsite-5-3-pre:11.12
	rel-5-3:11.7.2.1
	rel-5-2:11.7
	rel-5-1-branch:11.7.0.2
	rel-5-1:11.7
	rel-5-0:11.4
	rel-5-0-beta:11.4
	rel-4-5:11.4
	ctj-4-5-post:11.4
	ctj-4-5-pre:11.4
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.17
date	2004.05.24.04.01.08;	author morrison;	state dead;
branches;
next	11.16;

11.16
date	2004.05.10.15.30.42;	author erikg;	state Exp;
branches;
next	11.15;

11.15
date	2004.02.02.17.39.05;	author morrison;	state Exp;
branches;
next	11.14;

11.14
date	2001.11.05.21.20.05;	author morrison;	state Exp;
branches
	11.14.4.1
	11.14.6.1
	11.14.12.1;
next	11.13;

11.13
date	2001.08.08.20.25.12;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	2001.02.06.15.13.42;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	2000.10.27.20.21.51;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	2000.09.08.05.56.37;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	2000.08.24.04.59.42;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	2000.08.24.04.10.48;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	2000.03.29.18.42.45;	author mike;	state Exp;
branches
	11.7.2.1;
next	11.6;

11.6
date	2000.01.05.14.16.08;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	99.10.04.18.39.09;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	97.03.06.20.24.39;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	96.12.31.17.44.26;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.12.06.13.25.06;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.07.49;	author mike;	state Rel4_4;
branches;
next	1.15;

1.15
date	94.11.08.14.50.12;	author jra;	state Exp;
branches;
next	1.14;

1.14
date	94.11.03.10.50.54;	author jra;	state Exp;
branches;
next	1.13;

1.13
date	94.10.19.13.58.25;	author jra;	state Exp;
branches;
next	1.12;

1.12
date	94.09.26.15.41.23;	author jra;	state Exp;
branches;
next	1.11;

1.11
date	94.09.02.00.47.48;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	94.08.26.13.49.16;	author jra;	state Exp;
branches;
next	1.9;

1.9
date	94.08.26.10.39.36;	author jra;	state Exp;
branches;
next	1.8;

1.8
date	94.08.24.09.19.00;	author jra;	state Exp;
branches;
next	1.7;

1.7
date	94.08.22.19.31.48;	author gdurf;	state Exp;
branches;
next	1.6;

1.6
date	94.05.05.10.01.17;	author jra;	state Exp;
branches;
next	1.5;

1.5
date	94.01.07.15.15.41;	author jra;	state Exp;
branches;
next	1.4;

1.4
date	94.01.04.10.59.38;	author jra;	state Exp;
branches;
next	1.3;

1.3
date	93.09.24.10.04.19;	author jra;	state Exp;
branches;
next	1.2;

1.2
date	93.08.18.09.13.47;	author jra;	state Exp;
branches;
next	1.1;

1.1
date	93.08.18.08.50.27;	author jra;	state Exp;
branches;
next	;

11.7.2.1
date	2000.10.27.20.16.17;	author jra;	state Exp;
branches;
next	;

11.14.4.1
date	2004.03.17.21.16.32;	author morrison;	state Exp;
branches;
next	;

11.14.6.1
date	2004.03.11.23.41.14;	author morrison;	state Exp;
branches;
next	;

11.14.12.1
date	2004.02.12.19.41.39;	author erikg;	state Exp;
branches;
next	11.14.12.2;

11.14.12.2
date	2004.03.15.14.06.12;	author erikg;	state Exp;
branches;
next	;


desc
@Code to support the brlcad-to-IGES converter
@


11.17
log
@moved to src/iges/
@
text
@/*
 *			I G E S . C
 *
 *  Code to support the g-iges converter
 *
 *  Author -
 *	John R. Anderson
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *      This software is Copyright (C) 1993-2004 by the United States Army.
 *      All rights reserved.
 */

/*	Yet to do:
 *

 *		Utilize the IGES Right Angle Wedge entity (may not be worth the effort):
 *			1. arb_is_raw()
 *			2. raw_to_iges()
 *			3. modify arb_to_iges to use above
 *
 *		How to handle half-space solids????
 * 
 *		How to handle xforms with scale factors?????
 */

#ifndef lint
static const char RCSid[] = "$Header: /n/xoff/cvs/brlcad/iges/iges.c,v 11.16 2004/05/10 15:30:42 erikg Exp $";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <ctype.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "rtlist.h"
#include "rtstring.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "../iges/iges.h"
#include "../librt/debug.h"

/* define defaulted entry for directory entry array */
#define	DEFAULT	(-99999)

extern int	verbose;
static int	solids_to_nmg=0;/* Count of solids that were converted to nmg's in CSG mode */
static int	dir_seq=0;	/* IGES file directory section sequence number */
static int	param_seq=0;	/* IGES file parameter section sequence number */
static int	start_len=0;	/* Length of Start Section */
static int	global_len=0;	/* Length of Global Section */
static int	attribute_de;	/* DE of attribute definition entity */
static char	*global_form="%-72.72s%c%07d\n"; /* format for global section */
static char	*param_form="%-64.64s %7d%c%07d\n"; /* format for parameter section */
static char	*att_string="BRLCAD attribute definition:material name,material parameters,region flag,ident number,air code,material code (GIFT),los density,inheritance";
static struct bn_tol tol;	/* tolerances */
static struct rt_tess_tol ttol;	/* tolerances */
static struct db_i *dbip=NULL;
static char	*unknown="Unknown";
static int	unknown_count=0;
static int	de_pointer_number;
extern char	**independent;
extern int	no_of_indeps;
extern int	solid_is_brep;
extern int	comb_form;
extern int	do_nurbs;
extern int	mode;

BU_EXTERN( int write_freeform, ( FILE *fp, char s[], int de, char c ) );
BU_EXTERN( int write_dir_entry, ( FILE *fp, int entry[] ) );
BU_EXTERN( int write_vertex_list, ( struct nmgregion *r, struct bu_ptbl *vtab, FILE *fp_dir, FILE *fp_param ) );
BU_EXTERN( int write_edge_list, ( struct nmgregion *r, int vert_de, struct bu_ptbl *etab, struct bu_ptbl *vtab, FILE *fp_dir, FILE *fp_param ) );
BU_EXTERN( int write_shell_face_loop, ( char *name, struct nmgregion *r, int dependent, int edge_de, struct bu_ptbl *etab, int vert_de, struct bu_ptbl *vtab, FILE *fp_dir, FILE *fp_param ) );
BU_EXTERN( int write_solid_assembly, ( char *name, int de_list[], int length, int dependent, FILE *fp_dir, FILE *fp_param ) );
BU_EXTERN( int write_planar_nurb, ( struct faceuse *fu, vect_t u_dir, vect_t v_dir, fastf_t *u_max, fastf_t *v_max, point_t base_pt, FILE *fp_dir, FILE *fp_param ) );
BU_EXTERN( int write_name_entity, ( char *name, FILE *fp_dir, FILE *fp_param ) );
BU_EXTERN( int write_att_entity, ( struct iges_properties *props, FILE *fp_dir, FILE *fp_param ) );
BU_EXTERN( int nmg_to_iges, ( struct rt_db_internal *ip, char *name, FILE *fp_dir, FILE *fp_param ) );

#define		NO_OF_TYPES	31
static int	type_count[NO_OF_TYPES][2]={
			{ 106 , 0 },	/* Copious Data */
			{ 110 , 0 },	/* Line */
			{ 116 , 0 },	/* Point */
			{ 123 , 0 },	/* Direction */
			{ 124 , 0 },	/* Transformation Matrix */
			{ 126 , 0 },	/* Rational B-spline Curve */
			{ 128 , 0 },	/* Rational B-spline Surface */
			{ 142 , 0 },	/* Curve on a Parametric Surface */
			{ 144 , 0 },	/* Trimmed Surface */
			{ 150 , 0 },	/* Block */
			{ 152 , 0 },	/* Right Angle Wedge */
			{ 154 , 0 },	/* Right Circular Cylinder */
			{ 156 , 0 },	/* Right Circular Cone Frustum */
			{ 158 , 0 },	/* Sphere */
			{ 160 , 0 },	/* Torus */
			{ 164 , 0 },	/* Solid of Linear Extrusion */
			{ 168 , 0 },	/* Ellipsoid */
			{ 180 , 0 },	/* Boolean Tree */
			{ 184 , 0 },	/* Solid Assembly */
			{ 186 , 0 },	/* Manifold Solid BREP Object */
			{ 190 , 0 },	/* Plane Surface */
			{ 314 , 0 },	/* Color */
			{ 322 , 0 },	/* Attribute Table Definition */
			{ 406 , 0 },	/* Property Entity */
			{ 422 , 0 },	/* Attribute Table Instance */
			{ 430 , 0 },	/* Solid Instance */
			{ 502 , 0 },	/* Vertex List */
			{ 504 , 0 },	/* Edge List */
			{ 508 , 0 },	/* Loop */
			{ 510 , 0 },	/* Face */
			{ 514 , 0 }	/* Shell */
		};

static char	*type_label[NO_OF_TYPES]={
			"CopiusDa",
			"Line",
			"Point",
			"Directin",
			"Matrix",
			"B-spline",
			"NURB",
			"TrimCurv",
			"TrimSurf",
			"Block",
			"RA Wedge",
			"RC Cylin",
			"RC Frust",
			"Sphere",
			"Torus",
			"Extruson",
			"Ellipsod",
			"BoolTree",
			"Assembly",
			"BREP Obj",
			"PlaneSur",
			"Color",
			"Att Def",
			"Property",
			"Att Inst",
			"SolInst",
			"VertList",
			"EdgeList",
			"Loop",
			"Face",
			"Shell"
		};

static char	*type_name[NO_OF_TYPES]={
			"Copious Data",
			"Line",
			"Point",
			"Direction",
			"Transformation Matrix",
			"Rational B_spline Curve",
			"NURB Surface",
			"Curve on a Parametric Surface",
			"Trimmed Surface",
			"Block",
			"Right Angle Wedge",
			"Right Circular Cylinder",
			"Right Circular Cone Frustum",
			"Sphere",
			"Torus",
			"Linear Sketch Extrusion",
			"Ellipsoid",
			"Boolean Tree",
			"Assembly Primitive",
			"Manifold Boundary Representation",
			"Plane Surface",
			"Color Definition",
			"Attribute Table Definition",
			"Property Entity",
			"Attribute Table Instance",
			"Primitive Instance",
			"Vertex List",
			"Edge List",
			"Loop",
			"Face",
			"Shell"
		};

static unsigned char colortab[9][4]={
	{ 0 , 217 , 217 , 217 }, /* index 0 actually represents an undefined color */
	{ 1 ,   0 ,   0 ,   0 },
	{ 2 , 255 ,   0 ,   0 },
	{ 3 ,   0 , 255 ,   0 },
	{ 4 ,   0 ,   0 , 255 },
	{ 5 , 255 , 255 ,   0 },
	{ 6 , 255 ,   0 , 255 },
	{ 7 ,   0 , 255 , 255 },
	{ 8 , 255 , 255 , 255 }};


void
nmg_to_winged_edge( r )
struct nmgregion *r;
{
	struct shell *s;

	NMG_CK_REGION( r );

	for( BU_LIST_FOR( s , shell , &r->s_hd ) )
	{
		struct faceuse *fu;

		NMG_CK_SHELL( s );
		for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
		{
			struct loopuse *lu;

			NMG_CK_FACEUSE( fu );
			if( fu->orientation != OT_SAME )
				continue;

			for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
			{
				struct edgeuse *eu1,*eu2;

				NMG_CK_LOOPUSE( lu );
				if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
					continue;

				for( BU_LIST_FOR( eu1 , edgeuse , &lu->down_hd ) )
				{
					struct edgeuse *eu_new;
					struct vertex *v1=NULL,*v2=NULL;

					NMG_CK_EDGEUSE( eu1 );
					if( eu1->radial_p == eu1->eumate_p )
						continue;	/* dangling edge (?warning?) */

					if( eu1->radial_p->eumate_p->radial_p == eu1->eumate_p )
						continue;	/* winged edge */

					/* this edge has more than two radial faces
					 * find the other face from this shell
					 */
					eu2 = eu1->radial_p;
					while( eu2 != eu1 && eu2 != eu1->eumate_p
						&& nmg_find_s_of_eu( eu2 ) != s )
							eu2 = eu2->eumate_p->radial_p;

					/* unglue edge eu1 */
					nmg_unglueedge( eu1 );

					/* Make a new edge */
					eu_new = nmg_me( v1 , v2 , s );

					/* Give the endpoints the same coordinates as the originbal edge */
					nmg_vertex_gv( eu_new->vu_p->v_p , eu1->vu_p->v_p->vg_p->coord );
					nmg_vertex_gv( eu_new->eumate_p->vu_p->v_p , eu1->eumate_p->vu_p->v_p->vg_p->coord );

					/* Move edgeuses to the new vertices */
					nmg_movevu( eu1->vu_p , eu_new->vu_p->v_p );
					nmg_movevu( eu1->eumate_p->vu_p , eu_new->eumate_p->vu_p->v_p );

					/* kill the new edge (I only wanted it for its vertices) */
					if( nmg_keu( eu_new ) )
						rt_bomb( "nmg_to_winged_edge: Can't happen nmg_keu resulted in empty shell!!!!\n" );

					/* move the other edgeuse to the same edge */
					if( eu2 == eu1 || eu2 == eu1->eumate_p )
						bu_log( "nmg_to_winged_edge: couldn't find second radial face for eu x%x in shell x%x\n" , eu1 , s );
					else
						nmg_moveeu( eu1 , eu2 );
				}
			}
		}
	}
}

void
get_props( props , comb )
struct iges_properties *props;
struct rt_comb_internal *comb;
{
	char *endp;

	RT_CK_COMB( comb );

	endp = strchr( bu_vls_addr(&comb->shader), ' ' );
	bzero( props->material_name, 32 );
	bzero( props->material_params, 60 );
	if( endp )  {
		int	len;
		len = endp - bu_vls_addr(&comb->shader);
		if( len > 31 ) len = 31;
		strncpy( props->material_name, bu_vls_addr(&comb->shader), len );
		strncpy( props->material_params, endp+1, 59 );
	} else {
		strncpy( props->material_name, bu_vls_addr(&comb->shader), 31 );
		props->material_params[0] = '\0';
	}
	if( comb->region_flag )
	{
		props->region_flag = 'R';
		props->ident = comb->region_id;
		props->air_code = comb->aircode;
		props->material_code = comb->GIFTmater;
		props->los_density = comb->los;
	}
	props->color_defined = ( comb->rgb_valid ? 1 : 0 );
	if( props->color_defined )
	{
		props->color[0] = comb->rgb[0];
		props->color[1] = comb->rgb[1];
		props->color[2] = comb->rgb[2];
	}
	else
	{
		props->color[0] = 0;
		props->color[1] = 0;
		props->color[2] = 0;
	}
	props->inherit = ( comb->inherit ? 1 : 0 );
}

int
lookup_props( props , name )
struct iges_properties *props;
char *name;
{
	struct directory *dp;
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;
	int id;

	strcpy( props->name, name );
	props->material_name[0] = '\0';
	props->material_params[0] = '\0';
	props->region_flag = ' ';
	props->ident = 0;
	props->air_code = 0;
	props->material_code = 0;
	props->los_density = 0;
	props->color[0] = 0;
	props->color[1] = 0;
	props->color[2] = 0;

	if( name == NULL )
		return( 1 );

	dp  = db_lookup( dbip , name , 1 );
	if( dp == DIR_NULL )
		return( 1 );

	if( !(dp->d_flags & DIR_COMB) )
		return( 1 );

	id = rt_db_get_internal( &intern, dp, dbip, (matp_t)NULL , &rt_uniresource);

	if( id < 0 )
	{
		rt_db_free_internal( &intern , &rt_uniresource);
		bu_log( "Could not get internal form of %s\n", dp->d_namep );
		return( 1 );
	}

	if( id != ID_COMBINATION )
	{
		rt_db_free_internal( &intern , &rt_uniresource);
		bu_log( "Directory/Database mismatch!!!! is %s a combination or not???\n", dp->d_namep );
		return( 1 );
	}

	comb = (struct rt_comb_internal *)intern.idb_ptr;
	RT_CK_COMB( comb );

	get_props( props , comb );
	rt_db_free_internal( &intern , &rt_uniresource);
	return( 0 );
}

int
write_color_entity( color , fp_dir , fp_param )
unsigned char color[3];
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	int			i;
	float			c[3];

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
	        dir_entry[i] = DEFAULT;

	/* convert colors to percents */
	for( i=0 ; i<3 ; i++ )
		c[i] = (float)color[i]/2.55;

	bu_vls_printf( &str , "314,%g,%g,%g;" , c[0] , c[1] , c[2] );

	dir_entry[1] = 314;
	dir_entry[2] = param_seq + 1;
	dir_entry[8] = 0;
	dir_entry[9] = 10201;
	dir_entry[11] = 314;
	dir_entry[15] = 0;
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );
}

int
get_color( color , fp_dir , fp_param )
unsigned char color[3];
FILE *fp_dir,*fp_param;
{
	int color_de;

	for( color_de=0 ; color_de < 9 ; color_de++ )
	{
		if( color[0] == colortab[color_de][1] &&
		    color[1] == colortab[color_de][2] &&
		    color[2] == colortab[color_de][3] )
			break;
	}

	if( color_de == 9 )
		color_de = (-write_color_entity( color , fp_dir , fp_param ));

	return( color_de );
}

int
write_attribute_definition( fp_dir , fp_param )
FILE *fp_dir,*fp_param;
{
	struct bu_vls str;
	int dir_entry[21];
	int i;

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	/* start with parameter data */
	bu_vls_printf( &str , "322,%dH%s,5001,9" , strlen( att_string ) , att_string );
	bu_vls_printf( &str , ",1,3,1" ); /* material name */
	bu_vls_printf( &str , ",2,3,1" ); /* material parameters */
	bu_vls_printf( &str , ",3,6,1" ); /* region flag (logical value) */
	bu_vls_printf( &str , ",4,1,1" ); /* ident number */
	bu_vls_printf( &str , ",5,1,1" ); /* air code number */
	bu_vls_printf( &str , ",6,1,1" ); /* material code number */
	bu_vls_printf( &str , ",7,1,1" ); /* los density (X100) */
	bu_vls_printf( &str , ",8,1,1" ); /* inheritance */
	bu_vls_printf( &str , ",9,6,1;" ); /* color_defined (logical value) */


	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] =  write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	/* write directory entry for line entity */
	dir_entry[1] = 322;
	dir_entry[8] = 0;
	dir_entry[9] = 10201;
	dir_entry[11] = 322;
	dir_entry[15] = 0;

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );
	
}

void
iges_init( set_tol , set_ttol , set_verbose , dbip_set )
struct bn_tol *set_tol;
struct rt_tess_tol *set_ttol;
int set_verbose;
struct db_i *dbip_set;
{
	BN_CK_TOL( set_tol );
	RT_CK_TESS_TOL( set_ttol );
	tol = (*set_tol);
	ttol = (*set_ttol);
	verbose = set_verbose;
	dbip = dbip_set;

	dir_seq = 0;
	param_seq = 0;
	start_len = 0;
	global_len = 0;
}

void
Print_stats( fp )
FILE *fp;
{
	int i;
	int total_entities=0;

	fprintf( fp , "Wrote the following numbers and type of entities:\n" );
	for( i=0 ; i<NO_OF_TYPES ; i++ )
		if( type_count[i][1] > 0 )
		{
			total_entities += type_count[i][1];
			fprintf( fp , "\t%d - %s\n" , type_count[i][1] , type_name[i] );
		}

	fprintf( fp , "Total of %d entities written\n" , total_entities );

	if( solids_to_nmg )
		fprintf( fp , "%d solids converted to NMG's before exporting to IGES\n" , solids_to_nmg );
}

int
write_dir_entry( fp , entry )
FILE *fp;
int entry[];
{
	int i,j,type_index;
	char *label;

	for( type_index=0; type_index<NO_OF_TYPES ; type_index++ )
		if( type_count[type_index][0] == entry[1] )
			break;
	if( type_index == NO_OF_TYPES )
	{
		bu_log( "Writing directory entry for an unknown entity type (%d)\n" , entry[1] );
		label = unknown;
		unknown_count++;
		entry[19] = unknown_count;
	}
	else
	{
		label = type_label[type_index];
		type_count[type_index][1]++;
		entry[19] = type_count[type_index][1];
	}

	entry[10] = dir_seq + 1;
	entry[20] = dir_seq + 2;

	for( j=0 ; j<2 ; j++ )
	{

		for( i=j*10+1 ; i<(j+1)*10 ; i++ )
		{
			if( i == 18 )
				fprintf( fp , "%8.8s" , label );
			else if( entry[i] == DEFAULT )
				fprintf( fp , "        " );
			else if( i == 9 )
				fprintf( fp , "%08d" , entry[i] );
			else
				fprintf( fp , "%8d" , entry[i] );
		}
		fprintf( fp , "D%07d\n" , entry[(j+1)*10] );
	}

	dir_seq += 2;
	return( dir_seq - 1 );
}

int
write_freeform(
FILE *fp,	/* output file */
char s[],	/* the string to be output (must not contain any NL's) */
int de,		/* the directory entry # that this belongs to (ignored for Global section) */
char c)		/* 'G' for global section
		 * 'P' for parameter section
		 * 'S' for start section */

{
	int paramlen;
	int start_seq;
	int str_len;
	int line_start=0;
	int line_end=0;
	int *seq_no;
	int remaining_chars=0;
	int i;

	if( c == 'P' )
	{
		seq_no = &param_seq;
		paramlen = 64;
	}
	else if( c == 'G' )
	{
		seq_no = &global_len;
		paramlen = 72;
	}
	else if( c == 'S' )
	{
		seq_no = &start_len;
		paramlen = 72;
	}
	else
	{
		bu_log( "Bad section character passed to 'write_freeform' (%c)\n" , c );
		exit( 1 );
	}

	str_len = strlen( s );
	start_seq = (*seq_no);


	/* the start section is just one big string, so just print in pieces if necessary */
	if( c == 'S' )
	{
		line_start = 0;
		while( line_start < str_len )
		{
			(*seq_no)++;
			fprintf( fp , global_form , &s[line_start] , c , *seq_no );
			line_start += paramlen;
		}
		return( *seq_no - start_seq );
	}

	/* Just print any string that will fit */
	if( str_len <= paramlen )
	{
		(*seq_no)++;
		if( c == 'P' )
			fprintf( fp , param_form , s , de , c , *seq_no );
		else
			fprintf( fp , global_form , s , c , *seq_no );
		return( *seq_no - start_seq );
	}
	else /* break string into lines */
	{
		int curr_loc=0;
		int field_start=0;

		while( 1 )
		{
			line_end = line_start + paramlen - 1;
			curr_loc = line_start;
			if( line_end >= str_len ) /* write the last line and break */
			{
				(*seq_no)++;
				if( c == 'P' )
					fprintf( fp , param_form , &s[line_start] , de , c , *seq_no );
				else
					fprintf( fp , global_form , &s[line_start] , c , *seq_no );
				break;
			}
			else /* find the end of this line */
			{
				/* cannot extend numbers across lines,
				 * but character strings may. The only way
				 * to be sure is to interpret the entire string */

				if( remaining_chars >= paramlen )
				{
					/* just print more of the string */
					(*seq_no)++;
					if( c == 'P' )
						fprintf( fp , param_form , &s[line_start] , de , c , *seq_no );
					else
						fprintf( fp , global_form , &s[line_start] , c , *seq_no );
					remaining_chars -= paramlen;
				}
				else
				{
					int done=0;

					while( !done )
					{
						char num[81];
						int j=0;

						/* skip over any remainder of a string */
						if( remaining_chars )
						{
							curr_loc = line_start + remaining_chars;
							remaining_chars = 0;
						}
						field_start = curr_loc;

						if( s[curr_loc] == ',' || s[curr_loc] == ';' )
						{
							/* empty field */
							curr_loc++;
						}
						else
						{
							while( isdigit(s[curr_loc]) )
								num[j++] = s[curr_loc++];
							num[j] = '\0';

							if( s[curr_loc] == 'H' )
							{
								/* This is a string */
								int len;

								len = atoi( num );

								/* skip over the 'H' */
								curr_loc++;

								if( curr_loc + len >= line_end )
								{
									/* break this line in a string */
									(*seq_no)++;
									if( c == 'P' )
										fprintf( fp , param_form , &s[line_start] , de , c , *seq_no );
									else
										fprintf( fp , global_form , &s[line_start] , c , *seq_no );
									remaining_chars = curr_loc + len - line_end;
									done = 1;
								}
								else
									curr_loc += len + 1;
							}
							else
							{
								/* this is not a string and cannot be continued to next line */

								/* find end of this field */
								while( curr_loc < str_len && s[curr_loc] != ',' && s[curr_loc] != ';' )
								{
									curr_loc++;
								}

								if( s[curr_loc] == ',' || s[curr_loc] == ';' )
									curr_loc++;

								if( curr_loc > line_end )
								{
									/* end of line must be at start of this field */

									line_end = field_start-1;
									for( i=line_start ; i<=line_end ; i++ )
										fputc( s[i] , fp );

									/* fill out line with blanks */
									for( i=0 ; i<paramlen-(line_end-line_start+1) ; i++ )
										fputc( ' ' , fp );
									if( c == 'P' )
										fprintf( fp , " %7d" , de );
									/* add columns 73 through 80 */
									(*seq_no)++;
									fprintf( fp , "%c%07d\n" , c , *seq_no );
									done = 1;
								}
							}
						}
					}
				}
			}
			line_start = line_end + 1;
		}
		return( *seq_no - start_seq );
	}
}

void
w_start_global(
	FILE *fp_dir,
	FILE *fp_param,
	const char *db_name,
	const char *prog_name,
	const char *output_file,
	const char *id,
	const char *version)
{
	struct bu_vls str;
	time_t now;
	struct tm *timep;
	struct stat db_stat;

	bu_vls_init( &str );

	/* Write Start Section */
	bu_vls_printf( &str , "This IGES file created by %s from the database %s." , prog_name , db_name );
	(void)write_freeform( fp_dir , bu_vls_addr( &str ) , 0 , 'S' );
	bu_vls_free( &str );

	/* Write Global Section */
	bu_vls_printf( &str , ",,%dH%s" , strlen( db_name ), db_name);

	if( output_file == NULL )
		bu_vls_printf( &str , ",7Hstd_out," );
	else
		bu_vls_printf( &str , ",%dH%s" , strlen( output_file ) , output_file );

	bu_vls_printf( &str , ",%dH%s,%dH%s,32,38,6,308,15,%dH%s,1.0,2,2HMM,,1.0" ,
		strlen( version ) , version ,
		strlen( id ) , id,
		strlen( db_name ) , db_name );

	(void)time( &now );
	timep = localtime( &now );
	bu_vls_printf( &str , ",15H%04d%02d%02d.%02d%02d%02d",
		timep->tm_year+1900,
		timep->tm_mon + 1,
		timep->tm_mday,
		timep->tm_hour,
		timep->tm_min,
		timep->tm_sec );

	bu_vls_printf( &str , ",%g,100000.0,7HUnknown,7HUnknown,9,0" ,
		RT_LEN_TOL );

	if( stat( db_name , &db_stat ) )
	{
		bu_log( "Cannot stat %s\n" , db_name );
		perror( prog_name );
		bu_vls_strcat( &str , ",15H00000101.000000;" );
	}
	else
	{
		timep = localtime( &db_stat.st_mtime );
		bu_vls_printf( &str , ",15H%04d%02d%02d.%02d%02d%02d;",
			timep->tm_year+1900,
			timep->tm_mon + 1,
			timep->tm_mday,
			timep->tm_hour,
			timep->tm_min,
			timep->tm_sec );
	}

	(void)write_freeform( fp_dir , bu_vls_addr( &str ) , 0 , 'G' );

	/* write attribute definition entity */

	if( mode != TRIMMED_SURF_MODE )
		attribute_de = write_attribute_definition( fp_dir ,  fp_param );

	bu_vls_free( &str );
}


int
nmgregion_to_iges( name , r , dependent , fp_dir , fp_param )
char *name;
struct nmgregion *r;
int dependent;
FILE *fp_dir,*fp_param;
{
	struct nmgregion	*new_r;		/* temporary nmgregion */
	struct shell		*s_new;		/* shell made by nmg_mrsv */
	struct bu_ptbl		vtab;		/* vertex table */
	struct bu_ptbl		etab;		/* edge table */
	struct bu_ptbl		**shells;	/* array of tables of shells */
	int			*brep_de;	/* Directory entry sequence # for BREP Object(s) */
	int			vert_de;	/* Directory entry sequence # for vertex list */
	int			edge_de;	/* Directory entry sequence # for edge list */
	int			outer_shell_count; /* number of outer shells in nmgregion */
	int			face_count=0;	/* number of faces in nmgregion */
	int			i;

	NMG_CK_REGION( r );

	{
		struct shell *s;
		for( BU_LIST_FOR( s , shell , &r->s_hd ) )
		{
			struct faceuse *fu;

			for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
			{
				struct loopuse *lu;

				if( fu->orientation != OT_SAME )
					continue;

				face_count++;

				for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
				{
					struct edgeuse *eu;

					if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
						continue;

					for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
					{
						struct vertex *v;

						v = eu->vu_p->v_p;
						NMG_CK_VERTEX( v );
						if( !v->vg_p )
							bu_log( "vertex with no geometry!!\n" );
					}
				}
			}
		}
	}

	if( face_count == 0 )
		return( 0 );

	/* Find outer shells and void shells and their associations */
	outer_shell_count = nmg_find_outer_and_void_shells( r , &shells , &tol );

	brep_de = (int *)bu_calloc( outer_shell_count , sizeof( int ) , "nmgregion_to_iges: brep_de" );

	for( i=0 ; i<outer_shell_count ; i++ )
	{
		int j;
		int tmp_dependent;
		struct shell *s;
		char *tmp_name;

		if( outer_shell_count == 1 )
		{
			new_r = r;
			s_new = NULL;
			tmp_name = name;
			tmp_dependent = dependent;
		}
		else
		{
			new_r = nmg_mrsv( r->m_p );
			s_new = BU_LIST_FIRST( shell , &new_r->s_hd );
			tmp_name = NULL;
			tmp_dependent = 1;

			for( j=BU_PTBL_END( shells[i] )-1 ; j >= 0  ; j-- )
			{
				s = (struct shell *)BU_PTBL_GET( shells[i] , j );
				nmg_mv_shell_to_region( s , new_r );
			}
			(void)nmg_ks( s_new );
		}


		/* Make the vertex list entity */
		vert_de = write_vertex_list( new_r , &vtab , fp_dir , fp_param );

		/* Make the edge list entity */
		edge_de = write_edge_list( new_r , vert_de , &etab , &vtab , fp_dir , fp_param );

		/* Make the face, loop, shell entities */
		brep_de[i] = write_shell_face_loop( tmp_name , new_r , tmp_dependent , edge_de , &etab , vert_de , &vtab , fp_dir , fp_param );

		/* Clear the tables */
		(void)bu_ptbl_reset( &vtab );
		(void)bu_ptbl_reset( &etab );

		if( outer_shell_count != 1 )
			(void)nmg_kr( new_r );
	}

	/* Free the tables */
	(void)bu_ptbl_free( &vtab );
	(void)bu_ptbl_free( &etab );

	if( outer_shell_count != 1 )
		return( write_solid_assembly( name, brep_de , outer_shell_count , dependent , fp_dir , fp_param ) );
	else
		return( brep_de[0] );
}

int
verts_to_copious_data( pts , vert_count , pt_size , fp_dir , fp_param )
point_t *pts;
int vert_count;
int pt_size;
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	int			i;

	if( vert_count < 2 )
		return( 0 );

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	bu_vls_printf( &str , "106,%d,%d" , pt_size-1 , vert_count+1 );
	if( pt_size == 2 )
	{
		bu_vls_printf( &str , ",0.0" );
		for( i=0 ; i<vert_count ; i++ )
			bu_vls_printf( &str , ",%f,%f" , pts[i][0] , pts[i][1] );
		bu_vls_printf( &str , ",%f,%f" , pts[0][0] , pts[0][1] );
	}
	else if( pt_size == 3 )
	{
		for( i=0 ; i<vert_count ; i++ )
			bu_vls_printf( &str , ",%f,%f,%f" , V3ARGS( pts[i] ) );
		bu_vls_printf( &str , ",%f,%f,%f" , V3ARGS( pts[0] ) );
	}

	bu_vls_strcat( &str , ";" );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );

	/* write directory entry for vertex list entity */
	dir_entry[1] = 106;
	dir_entry[8] = 0;
	if( pt_size == 2 )
	{
		dir_entry[9] = 10500;
		dir_entry[15] = 63;
	}
	else
	{
		dir_entry[9] = 10000;
		dir_entry[15] = 12;
	}
	dir_entry[11] = 106;


	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ));
}

int
nmg_loop_to_tcurve( lu , surf_de , u_dir , v_dir , u_max , v_max , base_pt , fp_dir , fp_param )
struct loopuse *lu;
int surf_de;
vect_t u_dir,v_dir;
fastf_t u_max,v_max;
point_t base_pt;
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	struct edgeuse		*eu;
	int			vert_count=0;
	point_t			*model_pts;
	point_t			*param_pts;
	int			i;

	NMG_CK_LOOPUSE( lu );

	if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
		return( 0 );

	/* count vertices */
	for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
		vert_count++;

	if( vert_count < 3 )
		return( 0 );

	/* Allocate memory for points */
	model_pts = (point_t *)bu_calloc( vert_count , sizeof( point_t ) , "nmg_loop_to_tcurve: model_pts" );
	param_pts = (point_t *)bu_calloc( vert_count , sizeof( point_t ) , "nmg_loop_to_tcurve: param_pts" );

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	bu_vls_printf( &str , "142,0,%d" , surf_de );

	i = 0;
	for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
	{
		struct vertex_g *vg;
		vect_t from_base;
		fastf_t u,v;

		NMG_CK_EDGEUSE( eu );
		NMG_CK_VERTEXUSE( eu->vu_p );
		NMG_CK_VERTEX( eu->vu_p->v_p );
		NMG_CK_VERTEX_G( eu->vu_p->v_p->vg_p );
		vg = eu->vu_p->v_p->vg_p;

		if( i >= vert_count )
			rt_bomb( "nmg_loop_to_tcurve: too many vertices in loop!!!!\n" );

		VMOVE( model_pts[i] , vg->coord );

		VSUB2( from_base , vg->coord , base_pt );
		u = VDOT( u_dir , from_base )/u_max;
		v = VDOT( v_dir , from_base )/v_max;
		if( u < 0.0 )
			u = 0.0;
		if( u > 1.0 )
			u = 1.0;
		if( v < 0.0 )
			v = 0.0;
		if( v > 1.0 )
			v = 1.0;
		VSET( param_pts[i] , u , v , 0.0 );

		i++;
	}

	bu_vls_printf( &str , ",%d" , verts_to_copious_data( param_pts , vert_count , 2 , fp_dir , fp_param ) );
	bu_vls_printf( &str , ",%d,0;" , verts_to_copious_data( model_pts , vert_count , 3 , fp_dir , fp_param ));

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );

	/* write directory entry for vertex list entity */
	dir_entry[1] = 142;
	dir_entry[8] = 0;
	dir_entry[9] = 10500;
	dir_entry[11] = 142;
	dir_entry[15] = 0;


	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ));
}

void
nmg_fu_to_tsurf( fu , fp_dir , fp_param )
struct faceuse *fu;
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	struct loopuse		*lu;
	int			surf_de;
	vect_t			u_dir,v_dir;
	fastf_t			u_max,v_max;
	point_t			base_pt;
	int			loop_count=0;
	int			*curve_de;
	int			i;

	NMG_CK_FACEUSE( fu );

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	/* count loops */
	for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
	{
		NMG_CK_LOOPUSE( lu );

		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		loop_count++;
	}

	if( loop_count < 1 )	/* nothing to output */
		return;

	/* write underlying surface */
	surf_de = write_planar_nurb( fu , u_dir , v_dir , &u_max , &v_max , base_pt , fp_dir , fp_param );

	/* allocate space to hold DE for each trimming curve */
	curve_de = (int *)bu_calloc( loop_count , sizeof( int ) , "nmg_fu_to_tsurf: curve_de" );

	i = (-1);
	for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
	{
		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		curve_de[++i] = nmg_loop_to_tcurve( lu , surf_de , u_dir , v_dir , u_max , v_max , base_pt , fp_dir , fp_param );
	}

	bu_vls_printf( &str , "144,%d,0,%d" , surf_de , loop_count-1 );
	for( i=0 ; i<loop_count ; i++ )
		bu_vls_printf( &str , ",%d" , curve_de[i] );
	bu_vls_strcat( &str , ";" );

	bu_free( (char *)curve_de , "nmg_fu_to_tsurf: curve_de" );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );

	/* write directory entry for vertex list entity */
	dir_entry[1] = 144;
	dir_entry[8] = 0;
	dir_entry[9] = 0;
	dir_entry[11] = 144;
	dir_entry[15] = 0;

	bu_vls_free( &str );

	(void)write_dir_entry( fp_dir , dir_entry );

}

int nmgregion_to_tsurf( name , r , fp_dir , fp_param )
char *name;
struct nmgregion *r;
FILE *fp_dir,*fp_param;
{
	struct shell *s;

	NMG_CK_REGION( r );

	for( BU_LIST_FOR( s , shell , &r->s_hd ) )
	{
		struct faceuse *fu;

		NMG_CK_SHELL( s );
		for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
		{
			NMG_CK_FACEUSE( fu );

			if( fu->orientation != OT_SAME )
				continue;

			nmg_fu_to_tsurf( fu , fp_dir , fp_param );
		}
	}

	return( -1 );
}

int
write_vertex_list( r , vtab , fp_dir , fp_param )
struct nmgregion *r;
struct bu_ptbl *vtab;   /* vertex table */
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	int			i;

	NMG_CK_REGION( r );

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	/* Built list of vertex structs */
	nmg_vertex_tabulate( vtab, &r->l.magic );

	/* write parameter data for vertex list entity */
	bu_vls_printf( &str , "502,%d" , BU_PTBL_END( vtab  ) );

	for( i=0 ; i<BU_PTBL_END( vtab ) ; i++ ) {
		struct vertex                   *v;
		register struct vertex_g        *vg;

		v = (struct vertex *)BU_PTBL_GET(vtab,i);
		NMG_CK_VERTEX(v);
		vg = v->vg_p;
if( !vg )
	bu_log( "No geometry for vertex x%x #%d in table\n" , v , i );
		NMG_CK_VERTEX_G(vg);
		bu_vls_printf( &str, ",%g,%g,%g",
			vg->coord[X],
			vg->coord[Y],
			vg->coord[Z] );
	}
	bu_vls_strcat( &str , ";" );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );

	/* write directory entry for vertex list entity */
	dir_entry[1] = 502;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 502;
	dir_entry[15] = 1;


	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ));
}

int
write_line_entity( start_vg , end_vg , fp_dir , fp_param )
struct vertex_g	*start_vg;
struct vertex_g	*end_vg;
FILE *fp_dir,*fp_param;
{
	struct bu_vls str;
	int dir_entry[21];
	int i;

	NMG_CK_VERTEX_G( start_vg );
	NMG_CK_VERTEX_G( end_vg );

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	/* start with parameter data */
	bu_vls_printf( &str , "110,%g,%g,%g,%g,%g,%g;" ,
			start_vg->coord[X],
			start_vg->coord[Y],
			start_vg->coord[Z],
			end_vg->coord[X],
			end_vg->coord[Y],
			end_vg->coord[Z] );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] =  write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	/* write directory entry for line entity */
	dir_entry[1] = 110;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 110;
	dir_entry[15] = 0;

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );
}

int
write_linear_bspline( start_vg , end_vg , fp_dir , fp_param )
struct vertex_g	*start_vg;
struct vertex_g	*end_vg;
FILE *fp_dir,*fp_param;
{
	struct bu_vls str;
	int dir_entry[21];
	int i;

	NMG_CK_VERTEX_G( start_vg );
	NMG_CK_VERTEX_G( end_vg );

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	/* start with parameter data */
	bu_vls_printf( &str , "126,1,1,0,0,1,0,0.,0.,1.,1.,1.,1.,%g,%g,%g,%g,%g,%g,0.,1.;" ,
			start_vg->coord[X],
			start_vg->coord[Y],
			start_vg->coord[Z],
			end_vg->coord[X],
			end_vg->coord[Y],
			end_vg->coord[Z] );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] =  write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	/* write directory entry for line entity */
	dir_entry[1] = 126;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 126;
	dir_entry[15] = 1;

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );
}

int
write_edge_list( r , vert_de , etab , vtab , fp_dir , fp_param )
struct nmgregion *r;
int vert_de;		/* DE# for vertex list */
struct bu_ptbl *etab;	/* edge table */
struct bu_ptbl *vtab;	/* vertex table (already filled in) */
FILE *fp_dir,*fp_param;
{
	struct bu_vls str;
	int dir_entry[21];
	int i;

	NMG_CK_REGION( r );

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	/* Build list of edge structures */
	nmg_edge_tabulate( etab , &r->l.magic );

	bu_vls_printf( &str , "504,%d" , BU_PTBL_END( etab ) );

	/* write parameter data for edge list entity */
	for( i=0 ; i<BU_PTBL_END( etab ) ; i++ )
	{
		struct edge			*e;
		struct edgeuse			*eu;
		struct vertexuse		*vu;
		struct vertex			*start_v,*end_v;
		struct vertex_g			*start_vg,*end_vg;
		int				line_de; /* directory entry # for line entity */

		e = (struct edge *)BU_PTBL_GET(etab,i);
		NMG_CK_EDGE(e);
		eu = e->eu_p;
		NMG_CK_EDGEUSE(eu);
		vu = eu->vu_p;
		NMG_CK_VERTEXUSE(vu);
		start_v = vu->v_p;
		NMG_CK_VERTEX(start_v);
		start_vg = start_v->vg_p;
		NMG_CK_VERTEX_G(start_vg);
		vu = eu->eumate_p->vu_p;
		NMG_CK_VERTEXUSE(vu);
		end_v = vu->v_p;
		NMG_CK_VERTEX(end_v);
		end_vg = end_v->vg_p;
		NMG_CK_VERTEX_G(end_vg);
		if( do_nurbs )
			line_de = write_linear_bspline( start_vg , end_vg , fp_dir , fp_param );
		else
			line_de = write_line_entity( start_vg , end_vg , fp_dir , fp_param );
		bu_vls_printf( &str , ",%d,%d,%d,%d,%d",
			line_de,
			vert_de , bu_ptbl_locate( vtab , (long *)start_v ) + 1,
			vert_de , bu_ptbl_locate( vtab , (long *)end_v ) + 1 );
	}
	bu_vls_strcat( &str , ";" );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	/* write directory entry for edge list entity */
	dir_entry[1] = 504;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 504;
	dir_entry[15] = 1;

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );
}

int
write_point_entity( pt , fp_dir , fp_param )
point_t pt;
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	int			i;

	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	bu_vls_init( &str );

	bu_vls_printf( &str , "116,%g,%g,%g,0;" ,
		pt[X],
		pt[Y],
		pt[Z] );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	dir_entry[1] = 116;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 116;
	dir_entry[15] = 0;

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );
}

int
write_direction_entity( pt , fp_dir , fp_param )
point_t pt;
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	int			i;

	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	bu_vls_init( &str );

	bu_vls_printf( &str , "123,%g,%g,%g;" ,
		pt[X],
		pt[Y],
		pt[Z] );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	dir_entry[1] = 123;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 123;
	dir_entry[15] = 0;

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );
}

int
write_plane_entity( plane , fp_dir , fp_param )
plane_t plane;
FILE *fp_dir,*fp_param;
{
	struct bu_vls	str;
	point_t		pt_on_plane;	/* a point on the plane */
	int		dir_entry[21];
	int		i;

	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	bu_vls_init( &str );

	VSCALE( pt_on_plane , plane , plane[3] );

	bu_vls_printf( &str , "190,%d,%d;" ,
		write_point_entity( pt_on_plane , fp_dir , fp_param ),
		write_direction_entity( plane , fp_dir , fp_param ) );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	dir_entry[1] = 190;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 190;
	dir_entry[15] = 0;

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );
	
}

int
write_planar_nurb( fu , u_dir , v_dir , u_max , v_max , base_pt , fp_dir , fp_param )
struct faceuse *fu;
vect_t u_dir,v_dir;	/* output */
fastf_t *u_max,*v_max;	/* output */
point_t base_pt;	/* output ( point at u,v==0 ) */
FILE *fp_dir;
FILE *fp_param;
{
	struct loopuse		*lu;
	struct edgeuse		*eu,*eu_next;
	struct vertex_g		*vg,*vg_next;
	point_t			ctl_pt;
	fastf_t			umin,umax,vmin,vmax;
	struct bu_vls   	str;
	int           	 	dir_entry[21];
	int             	i;

	NMG_CK_FACEUSE( fu );

	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	bu_vls_init( &str );

	/* create direction vectors in u and v directions in plane */
	lu = BU_LIST_FIRST( loopuse , &fu->lu_hd );
	NMG_CK_LOOPUSE( lu );
	while( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC &&
				BU_LIST_NOT_HEAD( lu , &fu->lu_hd ) )
	{
		lu = BU_LIST_PNEXT( loopuse , lu );
		NMG_CK_LOOPUSE( lu );
	}
	if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
	{
		bu_log( "Write_planar_nurb: could not find a loop (with edges) in face\n" );
		return( 0 );
	}

	eu = BU_LIST_FIRST( edgeuse , &lu->down_hd );
	NMG_CK_EDGEUSE( eu );
		vg = eu->vu_p->v_p->vg_p;
	NMG_CK_VERTEX_G( vg );
	eu_next = BU_LIST_PNEXT( edgeuse , eu );
	NMG_CK_EDGEUSE( eu_next );
	vg_next = eu_next->vu_p->v_p->vg_p;
	NMG_CK_VERTEX_G( vg_next );

	VSUB2( u_dir , vg_next->coord , vg->coord );
	VUNITIZE( u_dir );
	VCROSS( v_dir , fu->f_p->g.plane_p->N , u_dir );
	VUNITIZE( v_dir );

	/* find the max and min distances from vg along u_dir and v_dir in the face */
	umin = MAX_FASTF;
	vmin = MAX_FASTF;
	umax = (-umin);
	vmax = (-vmin);

	for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
	{
		NMG_CK_LOOPUSE( lu );
		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
		{
			vect_t	tmp_vect;
			fastf_t	distu,distv;

			NMG_CK_EDGEUSE( eu );

			VSUB2( tmp_vect , eu->vu_p->v_p->vg_p->coord , vg->coord );
			distu = VDOT( tmp_vect , u_dir );
			V_MIN( umin , distu );
			V_MAX( umax , distu );
			distv = VDOT( tmp_vect , v_dir );
			V_MIN( vmin , distv );
			V_MAX( vmax , distv );
		}
	}

	*u_max = umax - umin;
	*v_max = vmax - vmin;

	/* Put preliminary stuff for planar nurb in string */
	bu_vls_printf( &str , "128,1,1,1,1,0,0,1,0,0,0.,0.,1.,1.,0.,0.,1.,1.,1.,1.,1.,1." );

	/* Now put control points in string */
	VJOIN2( ctl_pt , vg->coord , umin , u_dir , vmin , v_dir );
	VMOVE( base_pt , ctl_pt );
	bu_vls_printf( &str , ",%g,%g,%g" , V3ARGS( ctl_pt ) );
	VJOIN1( ctl_pt , ctl_pt , umax-umin , u_dir );
	bu_vls_printf( &str , ",%g,%g,%g" , V3ARGS( ctl_pt ) );
	VJOIN2( ctl_pt , vg->coord , umin , u_dir , vmax , v_dir );
	bu_vls_printf( &str , ",%g,%g,%g" , V3ARGS( ctl_pt ) );
	VJOIN1( ctl_pt , ctl_pt , umax-umin , u_dir );
	bu_vls_printf( &str , ",%g,%g,%g" , V3ARGS( ctl_pt ) );

	/* Now put parameter ranges last */
	bu_vls_printf( &str , ",0.,1.,0.,1.;" );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	dir_entry[1] = 128;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 128;
	dir_entry[15] = 1;

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );

}

int
write_shell_face_loop( name , r , dependent , edge_de , etab , vert_de , vtab , fp_dir , fp_param )
char *name;
struct nmgregion *r;
int dependent;
int edge_de;		/* directory entry # for edge list */
struct bu_ptbl *etab;	/* Table of edge pointers */
int vert_de;		/* directory entry # for vertex list */
struct bu_ptbl *vtab;	/* Table of vertex pointers */
FILE *fp_dir,*fp_param;
{
	struct edgeuse		*eu;
	struct faceuse		*fu;
	struct loopuse		*lu;
	struct shell		*s;
	struct vertex		*v;
	struct bu_vls		str;
	struct iges_properties	props;
	int			*shell_list;
	int			i;
	int			shell_count=0;
	int			dir_entry[21];
	int			name_de;
	int			prop_de;
	int			color_de=DEFAULT;

	NMG_CK_REGION( r );

	bu_vls_init( &str );

	/* count the shells */
	for( BU_LIST_FOR( s , shell , &r->s_hd ) )
		shell_count++;

	/* make space for the list of shell DE's */
	shell_list = (int *)bu_calloc( shell_count , sizeof( int ) , "write_shell_face_loop: shell_list" );

	shell_count = 0;
	for( BU_LIST_FOR( s , shell , &r->s_hd ) )
	{
		int	*face_list;
		int	face_count=0;


		/* Count faces */
		for (BU_LIST_FOR(fu, faceuse, &s->fu_hd))
		{
			NMG_CK_FACEUSE(fu);
			if (fu->orientation != OT_SAME)
				continue;
			face_count++;
		}
		face_list = (int *)bu_calloc( face_count , sizeof( int ) , "face_list" );
		face_count = 0;

		/* Shell is made of faces. */
		for (BU_LIST_FOR(fu, faceuse, &s->fu_hd))
		{
			int	*loop_list;
			int	loop_count=0;
			int	exterior_loop=(-1);	/* index of outer loop (in loop_list) */
			int	outer_loop_flag=1;	/* IGES flag to indicate a selected outer loop */

			if (fu->orientation != OT_SAME)
				continue;

			/* Count loops */
			for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd))
			{
				NMG_CK_LOOPUSE(lu);
				if( lu->orientation == OT_SAME )
					exterior_loop = loop_count;
				loop_count++;
			}
			loop_list = (int *)bu_calloc( loop_count , sizeof( int ) , "loop_list" );

			loop_count = 0;
			for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd))
			{
				int		edge_count=0;

				/* Count edges */
				if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC)
				{
					for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd))
					{
						NMG_CK_EDGEUSE(eu);
						NMG_CK_EDGE(eu->e_p);
						NMG_CK_VERTEXUSE(eu->vu_p);
						NMG_CK_VERTEX(eu->vu_p->v_p);
						NMG_CK_VERTEX_G(eu->vu_p->v_p->vg_p);
						edge_count++;
					}
				}
				else if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC)
				{
		  			v = BU_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p;
					NMG_CK_VERTEX(v);
					NMG_CK_VERTEX_G(v->vg_p);
		  			edge_count++;
				}
				else
					bu_log("write_shell_face_loop: loopuse mess up! (1)\n");

				bu_vls_printf( &str , "508,%d" , edge_count );

				if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC)
				{
					for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd))
					{
						int orientation;
						struct edge *e;
						struct edgeuse *eu_tab;

						e = eu->e_p;
						eu_tab = e->eu_p;
						if( eu_tab->vu_p->v_p == eu->vu_p->v_p )
							orientation = 1;
						else
							orientation = 0;

						bu_vls_printf( &str , ",0,%d,%d,%d,0",
							edge_de ,
							bu_ptbl_locate( etab , (long *)(e)) + 1,
							orientation );

						edge_count++;
					}
				}
				else if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC)
				{
		  			v = BU_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p;
					bu_vls_printf( &str , ",1,%d,%d,1,0",
						vert_de,
						bu_ptbl_locate( vtab , (long *)v )+1 );
				} else
					bu_log("write_shell_face_loop: loopuse mess up! (2)\n");

				bu_vls_strcat( &str , ";" );

				/* write loop entry */
				/* initialize directory entry */
				for( i=0 ; i<21 ; i++ )
					dir_entry[i] = DEFAULT;

				/* remember where parameter data is going */
				dir_entry[2] = param_seq + 1;

				/* get parameter line count */
				dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

				/* write directory entry for loop entity */
				dir_entry[1] = 508;
				dir_entry[8] = 0;
				dir_entry[9] = 10001;
				dir_entry[11] = 508;
				dir_entry[15] = 1;
				loop_list[loop_count++] = write_dir_entry( fp_dir , dir_entry );

				bu_vls_free( &str );

			}

			if( exterior_loop < 0 )
			{
				bu_log( "No outside loop found for face\n" );
				outer_loop_flag = 0;
			}
			else if( exterior_loop != 0 ) /* move outside loop to start of list */
			{
				int tmp;

				tmp = loop_list[0];
				loop_list[0] = loop_list[exterior_loop];
				loop_list[exterior_loop] = tmp;
			}

			if( do_nurbs )
			{
				vect_t u_dir,v_dir;
				point_t base_pt;
				fastf_t u_max,v_max;

				bu_vls_printf( &str , "510,%d,%d,%d" ,
					write_planar_nurb( fu , u_dir , v_dir , &u_max , &v_max , base_pt , fp_dir , fp_param ),
					loop_count,
					outer_loop_flag );
			}
			else
				bu_vls_printf( &str , "510,%d,%d,%d" ,
					write_plane_entity( fu->f_p->g.plane_p->N , fp_dir , fp_param ),
					loop_count,
					outer_loop_flag );

			for( i=0 ; i<loop_count ; i++ )
				bu_vls_printf( &str , ",%d" , loop_list[i] );

			bu_vls_strcat( &str , ";" );

			for( i=0 ; i<21 ; i++ )
				dir_entry[i] = DEFAULT;

			dir_entry[1] = 510;
			dir_entry[2] = param_seq + 1;
			dir_entry[8] = 0;
			dir_entry[9] = 10001;
			dir_entry[11] = 510;
			dir_entry[15] = 1;
			dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

			face_list[face_count++] = write_dir_entry( fp_dir , dir_entry );;

			bu_free( (char *)loop_list , "loop list" );
			bu_vls_free( &str );
		}

		/* write shell entity */
		bu_vls_printf( &str , "514,%d" , face_count );
		for( i=0 ; i<face_count ; i++ )
			bu_vls_printf( &str , ",%d,1" , face_list[i] );
		bu_vls_strcat( &str , ";" );

		/* initialize directory entry */
		for( i=0 ; i<21 ; i++ )
			dir_entry[i] = DEFAULT;

		dir_entry[1] = 514;
		dir_entry[2] = param_seq + 1;
		dir_entry[8] = 0;
		dir_entry[9] = 10001;
		dir_entry[11] = 514;
		dir_entry[15] = 1;
		dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

		shell_list[shell_count++] = write_dir_entry( fp_dir , dir_entry );

		bu_free( (char *)face_list , "face list" );
		bu_vls_free( &str );
	}

	/* write BREP object entity */

	/* write name entity */
	if( name != NULL )
		name_de = write_name_entity( name , fp_dir , fp_param );
	else
		name_de = 0;

	/* write color and attributes entities, if appropriate */
	if( !name || lookup_props( &props , name ) )
	{
		prop_de = 0;
		color_de = 0;
	}
	else
	{
		prop_de = write_att_entity( &props , fp_dir , fp_param );
		if( props.color_defined )
			color_de = get_color( props.color , fp_dir , fp_param );
	}

	/* Put outer shell in BREP object first */
	bu_vls_printf( &str , "186,%d,1,%d" , shell_list[0] , shell_count-1 );

	/* Add all other shells */
	for( i=1 ; i<shell_count ; i++ )
	{
			bu_vls_printf( &str , ",%d,1" , shell_list[i] );
	}

	if( prop_de || name_de )
	{
		if( prop_de && name_de )
			bu_vls_strcat( &str , ",0,2" );
		else
			bu_vls_printf( &str , ",0,1" );
		if( prop_de )
			bu_vls_printf( &str , ",%d" , prop_de );
		if( name_de )
			bu_vls_printf( &str , ",%d" , name_de );

	}

	bu_vls_strcat( &str , ";"  );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	dir_entry[1] = 186;
	dir_entry[2] = param_seq + 1;
	dir_entry[8] = 0;
	if( dependent )
		dir_entry[9] = 10001;
	else
		dir_entry[9] = 1;
	dir_entry[11] = 186;
	dir_entry[13] = color_de;
	dir_entry[15] = 0;
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	bu_free( (char *)shell_list , "shell list" );
	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );
}

void
w_terminate( fp )
FILE *fp;
{
	fprintf( fp , "S%07dG%07dD%07dP%07d%40.40sT0000001\n" , start_len , global_len , dir_seq , param_seq , " " );
}

int
arb_is_rpp( arb )
struct rt_arb_internal *arb;
{
	vect_t v0,v1,v2;
	int i;

	RT_ARB_CK_MAGIC( arb );

	/* for an rpp, all the height edge vectors must be equal,
	   all the width edge vectors must be equal, all the
	   depth edge vectors must be equal, and at least one
	   vertex must have three right angles */

	/* check the height vectors */
	VSUB2( v0 , arb->pt[4] , arb->pt[0] );
	for( i=5 ; i<8 ; i++ )
	{
		VSUB2( v1 , arb->pt[i] , arb->pt[i-4] );
		if( !VAPPROXEQUAL( v0 , v1 , tol.dist ) )
			return( 0 );
	}

	/* check the width vectors */
	VSUB2( v0 , arb->pt[1] , arb->pt[0] );
	VSUB2( v1 , arb->pt[2] , arb->pt[3] );
	if( !VAPPROXEQUAL( v0 , v1 , tol.dist ) )
			return( 0 );
	VSUB2( v1 , arb->pt[6] , arb->pt[7] );
	if( !VAPPROXEQUAL( v0 , v1 , tol.dist ) )
			return( 0 );
	VSUB2( v1 , arb->pt[5] , arb->pt[4] );
	if( !VAPPROXEQUAL( v0 , v1 , tol.dist ) )
			return( 0 );

	/* check the depth vectors */
	VSUB2( v0 , arb->pt[3] , arb->pt[0] );
	VSUB2( v1 , arb->pt[2] , arb->pt[1] );
	if( !VAPPROXEQUAL( v0 , v1 , tol.dist ) )
			return( 0 );
	VSUB2( v1 , arb->pt[6] , arb->pt[5] );
	if( !VAPPROXEQUAL( v0 , v1 , tol.dist ) )
			return( 0 );
	VSUB2( v1 , arb->pt[7] , arb->pt[4] );
	if( !VAPPROXEQUAL( v0 , v1 , tol.dist ) )
			return( 0 );

	/* check for a right angle corner */
	VSUB2( v0 , arb->pt[3] , arb->pt[0] );
	VSUB2( v1 , arb->pt[1] , arb->pt[0] );
	VSUB2( v2 , arb->pt[4] , arb->pt[0] );
	VUNITIZE( v0 );
	VUNITIZE( v1 );
	VUNITIZE( v2 );
	if( !BN_VECT_ARE_PERP( VDOT( v0 , v1 ) , &tol ) )
		return( 0 );
	if( !BN_VECT_ARE_PERP( VDOT( v0 , v2 ) , &tol ) )
		return( 0 );
	if( !BN_VECT_ARE_PERP( VDOT( v1 , v2 ) , &tol ) )
		return( 0 );

	return( 1 );
}

int
write_name_entity( name , fp_dir , fp_param )
char *name;
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	int			i;
	int			name_len;

	name_len = strlen( name );
	if( !name_len )
		return( 0 );

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	/* write parameter data into a string */
	if( name_len >= NAMESIZE )
		bu_vls_printf( &str , "406,1,16H%16.16s;" , name );
	else
		bu_vls_printf( &str , "406,1,%dH%s;" , strlen( name ) , name );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );
	bu_vls_free( &str );

	/* write directory entry for name property entity */
	dir_entry[1] = 406;
	dir_entry[8] = 0;
	dir_entry[9] = 1010301;
	dir_entry[11] = 406;
	dir_entry[15] = 15;
	return( write_dir_entry( fp_dir , dir_entry ));
}

int
tor_to_iges( ip , name , fp_dir , fp_param )
struct rt_db_internal *ip;
char *name;
FILE *fp_dir,*fp_param;
{
	struct rt_tor_internal	*tor;
	struct bu_vls		str;
	int			dir_entry[21];
	int			name_de;
	int			i;

	if( ip->idb_type != ID_TOR )
		bu_log( "tor_to_iges called for non-torus (type=%d)\n" , ip->idb_type );

	tor = (struct rt_tor_internal *)ip->idb_ptr;

	RT_TOR_CK_MAGIC( tor );

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	/* write a name entity for this solid */
	name_de = write_name_entity( name , fp_dir , fp_param );

	/* write parameter data into a string */
	bu_vls_printf( &str , "160,%g,%g,%g,%g,%g,%g,%g,%g,0,1,%d;",
		tor->r_a,
		tor->r_h,
		tor->v[X] , tor->v[Y] , tor->v[Z],
		tor->h[X] , tor->h[Y] , tor->h[Z],
		name_de );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );
	bu_vls_free( &str );

	/* write directory entry for torus entity */
	dir_entry[1] = 160;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 160;
	dir_entry[15] = 0;
	return( write_dir_entry( fp_dir , dir_entry ));

}

int
sph_to_iges( ip , name , fp_dir , fp_param )
char *name;
struct rt_db_internal *ip;
FILE *fp_dir,*fp_param;
{
	struct rt_ell_internal	*sph;
	struct bu_vls		str;
	double			radius;
	int			dir_entry[21];
	int			name_de;
	int			i;

	if( ip->idb_type != ID_SPH )
		bu_log( "sph_to_iges called for non-sph (type=%d)\n" , ip->idb_type );

	sph = (struct rt_ell_internal *)ip->idb_ptr;

	RT_ELL_CK_MAGIC( sph );

	/* write name entity */
	name_de = write_name_entity( name , fp_dir , fp_param );

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	radius = MAGNITUDE( sph->a );

	/* write parameter data into a string */
	bu_vls_printf( &str , "158,%g,%g,%g,%g,0,1,%d;",
		radius,
		sph->v[X] , sph->v[Y] , sph->v[Z] ,
		name_de );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );
	bu_vls_free( &str );

	/* write directory entry for sphere entity */
	dir_entry[1] = 158;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 158;
	dir_entry[15] = 0;
	return( write_dir_entry( fp_dir , dir_entry ));

}

int
ell_to_iges( ip , name , fp_dir , fp_param )
char *name;
struct rt_db_internal *ip;
FILE *fp_dir,*fp_param;
{
	struct rt_ell_internal	*ell;
	struct bu_vls		str;
	double			radius_a;
	double			radius_b;
	double			radius_c;
	vect_t			a_dir;
	vect_t			b_dir;
	vect_t			c_dir;
	int			dir_entry[21];
	int			name_de;
	int			i;

	if( ip->idb_type != ID_ELL )
		bu_log( "ell_to_iges called for non-ell (type=%d)\n" , ip->idb_type );

	ell = (struct rt_ell_internal *)ip->idb_ptr;

	RT_ELL_CK_MAGIC( ell );

	/* write name entity */
	name_de = write_name_entity( name , fp_dir , fp_param );

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	radius_a = MAGNITUDE( ell->a );
	radius_b = MAGNITUDE( ell->b );
	radius_c = MAGNITUDE( ell->c );

	VMOVE( a_dir , ell->a );
	VMOVE( b_dir , ell->b );
	VMOVE( c_dir , ell->c );

	VUNITIZE( a_dir );
	VUNITIZE( b_dir );
	VUNITIZE( c_dir );

	/* write parameter data into a string */
	bu_vls_printf( &str , "168,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,0,1,%d;",
		radius_a , radius_b , radius_c ,
		ell->v[X] , ell->v[Y] , ell->v[Z] ,
		a_dir[X] , a_dir[Y] , a_dir[Z] ,
		c_dir[X] , c_dir[Y] , c_dir[Z] ,
		name_de );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );
	bu_vls_free( &str );

	/* write directory entry for ellipsoid entity */
	dir_entry[1] = 168;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 168;
	dir_entry[15] = 0;
	return( write_dir_entry( fp_dir , dir_entry ));

}
int
rpp_to_iges( ip , name , fp_dir , fp_param )
char *name;
struct rt_db_internal *ip;
FILE *fp_dir,*fp_param;
{
	struct rt_arb_internal	*arb;
	struct bu_vls		str;
	double			length_a;
	double			length_b;
	double			length_c;
	vect_t			a_dir;
	vect_t			b_dir;
	vect_t			c_dir;
	vect_t			tmp_dir;
	int			dir_entry[21];
	int			name_de;
	int			i;

	if( ip->idb_type != ID_ARB8 )
		bu_log( "rpp_to_iges called for non-arb (type=%d)\n" , ip->idb_type );

	arb = (struct rt_arb_internal *)ip->idb_ptr;

	RT_ARB_CK_MAGIC( arb );

	/* write name entity */
	name_de = write_name_entity( name , fp_dir , fp_param );

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	VSUB2( a_dir , arb->pt[1] , arb->pt[0] );
	VSUB2( b_dir , arb->pt[3] , arb->pt[0] );
	VSUB2( c_dir , arb->pt[4] , arb->pt[0] );

	length_a = MAGNITUDE( a_dir );
	length_b = MAGNITUDE( b_dir );
	length_c = MAGNITUDE( c_dir );

	VUNITIZE( a_dir );
	VUNITIZE( b_dir );
	VUNITIZE( c_dir );

	/* c_dir cross a_dir must give b_dir for IGES */
	VCROSS( tmp_dir , c_dir , a_dir );
	if( VDOT( b_dir , tmp_dir ) < 0.0 )
	{
		/* not a right-handed system, so exchange a_dir with c_dir */
		double tmp_length;

		VMOVE( tmp_dir , a_dir );
		VMOVE( a_dir , c_dir );
		VMOVE( c_dir , tmp_dir );
		tmp_length = length_a;
		length_a = length_c;
		length_c = tmp_length;
	}

	/* write parameter data into a string */
	bu_vls_printf( &str , "150,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,0,1,%d;",
		length_a , length_b , length_c ,
		arb->pt[0][X] , arb->pt[0][Y] , arb->pt[0][Z] ,
		a_dir[X] , a_dir[Y] , a_dir[Z] ,
		c_dir[X] , c_dir[Y] , c_dir[Z] ,
		name_de );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );
	bu_vls_free( &str );

	/* write directory entry for block entity */
	dir_entry[1] = 150;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 150;
	dir_entry[15] = 0;
	return( write_dir_entry( fp_dir , dir_entry ));
}

int
arb_to_iges( ip , name , fp_dir , fp_param )
char *name;
struct rt_db_internal *ip;
FILE *fp_dir,*fp_param;
{
	struct rt_arb_internal *arb;

	if( ip->idb_type != ID_ARB8 )
	{
		bu_log( "arb_to_iges called for non-arb (type=%d)\n" , ip->idb_type );
		return( 0 );
	}

	arb = (struct rt_arb_internal *)ip->idb_ptr;

	RT_ARB_CK_MAGIC( arb );

	if( arb_is_rpp( arb ) )
		return( rpp_to_iges( ip , name , fp_dir , fp_param ) );
	else
		return( nmg_to_iges( ip , name , fp_dir , fp_param ) );
}

int
tgc_to_iges( ip , name , fp_dir , fp_param )
char *name;
struct rt_db_internal *ip;
FILE *fp_dir,*fp_param;
{
	struct rt_tgc_internal	*tgc;
	fastf_t			h_len,a_len,b_len,c_len,d_len;
	vect_t			h_dir,a_dir,b_dir;
	int			iges_type;
	struct bu_vls		str;
	int			dir_entry[21];
	int			name_de;
	int			i;

	if( ip->idb_type != ID_TGC )
	{
		bu_log( "tgc_to_iges called for non-tgc (type=%d)\n" , ip->idb_type );
                return( 0 );
	}

	tgc = (struct rt_tgc_internal *)ip->idb_ptr;

        RT_TGC_CK_MAGIC( tgc );

	h_len = MAGNITUDE( tgc->h );
	a_len = MAGNITUDE( tgc->a );
	b_len = MAGNITUDE( tgc->b );
	c_len = MAGNITUDE( tgc->c );
	d_len = MAGNITUDE( tgc->d );

	/* Use VSCALE rather than VUNITIZE, since we have
	   already done the sqrt */

	VMOVE( h_dir , tgc->h );
	VSCALE( h_dir , h_dir , 1.0/h_len );

	VMOVE( a_dir , tgc->a );
	VSCALE( a_dir , a_dir , 1.0/a_len );

	VMOVE( b_dir , tgc->b );
	VSCALE( b_dir , b_dir , 1.0/b_len );

	if( !BN_VECT_ARE_PERP( VDOT( h_dir , a_dir ) , &tol ) ||
	    !BN_VECT_ARE_PERP( VDOT( h_dir , b_dir ) , &tol ) )
	{
		/* this is not an rcc or a trc */
		return( nmg_to_iges( ip , name , fp_dir , fp_param ));
	}

	if( NEAR_ZERO( a_len-b_len , tol.dist ) &&
	    NEAR_ZERO( c_len-d_len , tol.dist ) )
	{
		/* this tgc is either an rcc or a trc */

		/* write name entity */
		name_de = write_name_entity( name , fp_dir , fp_param );

		bu_vls_init( &str );

		/* initialize directory entry */
		for( i=0 ; i<21 ; i++ )
			dir_entry[i] = DEFAULT;

		if( NEAR_ZERO( a_len-c_len , tol.dist ) )
		{
			/* its an rcc */
			iges_type = 154;
			bu_vls_printf( &str , "154,%g,%g,%g,%g,%g,%g,%g,%g" ,
				h_len , a_len ,
				tgc->v[X] , tgc->v[Y] , tgc->v[Z] ,
				h_dir[X] , h_dir[Y] , h_dir[Z] );
		}
		else
		{
			/* its a trc */

			fastf_t bigger_r,smaller_r;
			vect_t base;

			iges_type = 156;
			if( a_len > c_len )
			{
				bigger_r = a_len;
				smaller_r = c_len;
				VMOVE( base , tgc->v );
			}
			else
			{
				bigger_r = c_len;
				smaller_r = a_len;
				VADD2( base , tgc->v , tgc->h );
				VREVERSE( h_dir , h_dir );
			}
			bu_vls_printf( &str , "156,%g,%g,%g,%g,%g,%g,%g,%g,%g" ,
				h_len , bigger_r , smaller_r ,
				base[X] , base[Y] , base[Z] ,
				h_dir[X] , h_dir[Y] , h_dir[Z] );
		}

		bu_vls_printf( &str , ",0,1,%d;" , name_de );

		/* remember where parameter data is going */
		dir_entry[2] = param_seq + 1;

		/* get parameter line count */
		dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );
		bu_vls_free( &str );

		/* fill in directory entry */
		dir_entry[1] = iges_type;
		dir_entry[8] = 0;
		dir_entry[9] = 10001;
		dir_entry[11] = iges_type;
		dir_entry[15] = 0;

		return( write_dir_entry( fp_dir , dir_entry ));
	}
	else
		return( nmg_to_iges( ip , name , fp_dir , fp_param ));
}

int
write_tree_of_unions( name, de_list , length , dependent , fp_dir , fp_param )
char *name;
int de_list[];
int length;
int dependent;
FILE *fp_dir;
FILE *fp_param;
{
	struct bu_vls		str;
	struct iges_properties	props;
	int			dir_entry[21];
	int			name_de;
	int			prop_de;
	int			color_de=DEFAULT;
	int			i;

	bu_vls_init( &str );

	/* write name entity */
	if( name != NULL )
		name_de = write_name_entity( name , fp_dir , fp_param );
	else
		name_de = 0;

	/* write color and attributes entities, if appropriate */
	if( lookup_props( &props , name ) )
	{
		prop_de = 0;
		color_de = 0;
	}
	else
	{
		prop_de = write_att_entity( &props , fp_dir , fp_param );
		if( props.color_defined )
			color_de = get_color( props.color , fp_dir , fp_param );
	}

	/* write parameter data into a string */
	bu_vls_printf( &str , "180,%d,%d" , 2*length-1 , -de_list[0] );
	for( i=1 ; i<length ; i++ )
		bu_vls_printf( &str , ",%d,1" , -de_list[i] );

	if( prop_de || name_de )
	{
		if( prop_de && name_de )
			bu_vls_strcat( &str , ",0,2" );
		else
			bu_vls_printf( &str , ",0,1" );
		if( prop_de )
			bu_vls_printf( &str , ",%d" , prop_de );
		if( name_de )
			bu_vls_printf( &str , ",%d" , name_de );

	}

	bu_vls_strcat( &str , ";"  );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	dir_entry[1] = 180;
	dir_entry[2] = param_seq + 1;
	dir_entry[8] = 0;
	if( dependent )
		dir_entry[9] = 10001;
	else
		dir_entry[9] = 1;
	dir_entry[11] = 180;
	dir_entry[13] = color_de;
	dir_entry[15] = 0;
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );
}

int
write_solid_assembly( name, de_list , length , dependent , fp_dir , fp_param )
char *name;
int de_list[];
int length;
int dependent;
FILE *fp_dir;
FILE *fp_param;
{
	struct bu_vls		str;
	struct iges_properties	props;
	int			dir_entry[21];
	int			name_de;
	int			prop_de;
	int			color_de=DEFAULT;
	int			i;

	bu_vls_init( &str );

	/* write name entity */
	if( name != NULL )
		name_de = write_name_entity( name , fp_dir , fp_param );
	else
		name_de = 0;

	/* write color and attributes entities, if appropriate */
	if( lookup_props( &props , name ) )
	{
		prop_de = 0;
		color_de = 0;
	}
	else
	{
		prop_de = write_att_entity( &props , fp_dir , fp_param );
		if( props.color_defined )
			color_de = get_color( props.color , fp_dir , fp_param );
	}

	/* write parameter data into a string */
	bu_vls_printf( &str , "184,%d" , length );
	for( i=0 ; i<length ; i++ )
		bu_vls_printf( &str , ",%d" , de_list[i] );
	for( i=0 ; i<length ; i++ )
		bu_vls_printf( &str , ",0" );

	if( prop_de || name_de )
	{
		if( prop_de && name_de )
			bu_vls_strcat( &str , ",0,2" );
		else
			bu_vls_printf( &str , ",0,1" );
		if( prop_de )
			bu_vls_printf( &str , ",%d" , prop_de );
		if( name_de )
			bu_vls_printf( &str , ",%d" , name_de );

	}

	bu_vls_strcat( &str , ";"  );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	dir_entry[1] = 184;
	dir_entry[2] = param_seq + 1;
	dir_entry[8] = 0;
	if( dependent )
		dir_entry[9] = 10001;
	else
		dir_entry[9] = 1;
	dir_entry[11] = 184;
	dir_entry[13] = color_de;
	dir_entry[15] = 0;
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );
}

int
nmg_to_iges( ip , name , fp_dir , fp_param )
struct rt_db_internal *ip;
char *name;
FILE *fp_dir,*fp_param;
{
	struct model *model;
	struct nmgregion *r;
	int region_count;
	int *region_de;
	int brep_de;
	int dependent;
	int i;

	RT_CK_DB_INTERNAL( ip );

	dependent = 1;
	for( i=0 ; i<no_of_indeps ; i++ )
	{
		if( !strncmp( name , independent[i] , NAMESIZE ) )
		{
			dependent = 0;
			break;
		}
	}

	solid_is_brep = 1;
	comb_form = 1;
	if( ip->idb_type == ID_NMG )
	{
		model = (struct model *)ip->idb_ptr;
		NMG_CK_MODEL( model );

		/* count the number of nmgregions */
		region_count = 0;
		for( BU_LIST_FOR( r , nmgregion , &model->r_hd ) )
		{
			NMG_CK_REGION( r );
			region_count++;
		}

		if( region_count == 0 )
			return( 0 );
		else if( region_count == 1 )
			return( nmgregion_to_iges( name , BU_LIST_FIRST( nmgregion , &model->r_hd ) ,
				dependent , fp_dir , fp_param ) );
		else
		{
			/* make a boolean tree unioning all the regions */

			/* space to save the iges location of each nmgregion */
			region_de = (int *)bu_calloc( region_count , sizeof( int ) , "nmg_to_iges" );

			/* loop through all nmgregions in the model */
			region_count = 0;
			for( BU_LIST_FOR( r , nmgregion , &model->r_hd ) )
				region_de[region_count++] = nmgregion_to_iges( (char *)NULL , r , 1 ,
						fp_dir , fp_param );

			/* now make the boolean tree */
			brep_de = write_tree_of_unions( name , region_de , region_count ,
						dependent , fp_dir , fp_param );

			bu_free( (char *)region_de , "nmg_to_iges" );
			return( brep_de );
		}
	}
	else
	{
		if( ip->idb_type == ID_BOT )
		{
			struct rt_bot_internal *bot=(struct rt_bot_internal *)ip->idb_ptr;
			if( bot->mode != RT_BOT_SOLID )
			{
				bu_log( "%s is a plate mode primitive, and cannot be converted to IGES format!!!\n", name );
				return( 0 );
			}
		}
		model = nmg_mm();
		if( rt_functab[ip->idb_type].ft_tessellate( &r , model , ip , &ttol , &tol ) )
		{
			nmg_km( model );
			return( 0 );
		}
		else
		{
			solids_to_nmg++;
			brep_de =  nmgregion_to_iges( name , r , dependent , fp_dir , fp_param );
			nmg_km( model );
			return( brep_de );
		}
	}
}

int
null_to_iges( ip , name , fp_dir , fp_param )
struct rt_db_internal *ip;
char *name;
FILE *fp_dir,*fp_param;
{
	return( 0 );
}

int
write_xform_entity( mat , fp_dir , fp_param )
mat_t mat;
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	int			i;

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
	        dir_entry[i] = DEFAULT;

	/* write parameter data into a string */
	bu_vls_strcpy( &str , "124"  );
	for( i=0 ; i<12 ; i++ )
	{
		bu_vls_printf( &str , ",%g" , mat[i] );
	}
	bu_vls_strcat( &str , ";" );

	dir_entry[1] = 124;
	dir_entry[2] = param_seq + 1;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 124;
	dir_entry[15] = 0;
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );
}

int
write_solid_instance( orig_de , mat , fp_dir , fp_param )
int orig_de;
mat_t mat;
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	int			i;

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
	        dir_entry[i] = DEFAULT;

	/* write the transformation matrix and make the link */
	dir_entry[7] = write_xform_entity( mat , fp_dir , fp_param );

	/* write parameter data into a string */
	bu_vls_printf( &str , "430,%d;" , orig_de );

	dir_entry[1] = 430;
	dir_entry[2] = param_seq + 1;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 430;
	dir_entry[15] = solid_is_brep ? 1 : 0;
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );
}

int
write_att_entity( props , fp_dir , fp_param )
struct iges_properties *props;
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	int			str_len;
	int			i;

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	/* write parameter data into a string */
	bu_vls_strcpy( &str , "422" );

	/* material name */
	str_len = strlen( props->material_name );
	if( str_len )
		bu_vls_printf( &str , ",%dH%s" , str_len , props->material_name );
	else
		bu_vls_strcat( &str , "," );

	/* material parameters */
	str_len = strlen( props->material_params );
	if( str_len )
		bu_vls_printf( &str , ",%dH%s" , str_len , props->material_params );
	else
		bu_vls_strcat( &str , "," );

	/* region flag */
	if( props->region_flag == 'R' )
		bu_vls_strcat( &str , ",1" );
	else
		bu_vls_strcat( &str , ",0" );

	/* ident number, air code, material code, los density */
	bu_vls_printf( &str , ",%d,%d,%d,%d,%d,%d;" ,
		props->ident ,
		props->air_code ,
		props->material_code ,
		props->los_density,
		props->inherit,
		props->color_defined );

	dir_entry[1] = 422;
	dir_entry[2] = param_seq + 1;
	dir_entry[3] = (-attribute_de);
	dir_entry[8] = 0;
	dir_entry[9] = 10301;
	dir_entry[11] = 422;
	dir_entry[15] = 0;
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );
}

/*
 *	Write a region or group of only one member as a solid instance
 *
 */
int
short_comb_to_iges( props , dependent , de_pointers , fp_dir , fp_param )
struct iges_properties *props;
int dependent;
int de_pointers[];
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	int			name_de;
	int			props_de;
	int			color_de=DEFAULT;
	int			status=1;
	int			i;

	/* if member has not been converted, don't try to write the tree */
	if( de_pointers[0] == 0  )
		return( 0 );

	if( dependent )
		status = 10001;

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	/* write name entity */
	name_de = write_name_entity( props->name , fp_dir , fp_param );

	/* write attributes entity */
	props_de = write_att_entity( props , fp_dir , fp_param );

	/* get color */
	if( props->color_defined )
		color_de = get_color( props->color , fp_dir , fp_param );
	else
		color_de = 0;

	/* write parameter data into a string */
	bu_vls_printf( &str , "430,%d" , de_pointers[0] );

	if( props_de || name_de )
	{
		if( props_de && name_de )
			bu_vls_strcat( &str , ",0,2" );
		else
			bu_vls_printf( &str , ",0,1" );
		if( props_de )
			bu_vls_printf( &str , ",%d" , props_de );
		if( name_de )
			bu_vls_printf( &str , ",%d" , name_de );

	}
	bu_vls_strcat( &str , ";" );

	dir_entry[1] = 430;
	dir_entry[2] = param_seq + 1;
	dir_entry[8] = 0;
	dir_entry[9] = status;
	dir_entry[11] = 430;
	dir_entry[13] = color_de;
	dir_entry[15] = comb_form;
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );

}

int
count_non_union_ops( tp )
union tree *tp;
{
	int count=0;

	RT_CK_TREE( tp );

	switch( tp->tr_op )
	{
		case OP_INTERSECT:
		case OP_SUBTRACT:
			count++;
		case OP_UNION:
			count += count_non_union_ops( tp->tr_b.tb_left );
			count += count_non_union_ops( tp->tr_b.tb_right );
			break;
		default:
			break;
	}

	return( count );
}

void
igs_tree( str, tp, length, de_pointers )
struct bu_vls *str;
union tree *tp;
int length;
int *de_pointers;
{
	RT_CK_TREE( tp );
	BU_CK_VLS( str );

	switch( tp->tr_op )
	{
		case OP_UNION:
			igs_tree( str, tp->tr_b.tb_left, length, de_pointers );
			igs_tree( str, tp->tr_b.tb_right, length, de_pointers );
			bu_vls_strcat( str, ",1" );
			break;
		case OP_INTERSECT:
			igs_tree( str, tp->tr_b.tb_left, length, de_pointers );
			igs_tree( str, tp->tr_b.tb_right, length, de_pointers );
			bu_vls_strcat( str, ",2" );
			break;
		case OP_SUBTRACT:
			igs_tree( str, tp->tr_b.tb_left, length, de_pointers );
			igs_tree( str, tp->tr_b.tb_right, length, de_pointers );
			bu_vls_strcat( str, ",3" );
			break;
		case OP_DB_LEAF:
			bu_vls_printf( str, ",%d", -de_pointers[de_pointer_number] );
			de_pointer_number++;
			break;
		default:
			bu_log( "Unrecognized operation in combination!!\n" );
			break;
	}
}

void
write_igs_tree( str, comb, length, de_pointers )
struct bu_vls *str;
struct rt_comb_internal *comb;
int length;
int *de_pointers;
{
	BU_CK_VLS( str );
	RT_CK_COMB( comb );

	bu_vls_printf( str , "180,%d", 2*length-1 );

	de_pointer_number = 0;
	igs_tree( str, comb->tree, length, de_pointers );
}

int
tree_to_iges( comb , length , dependent , props , de_pointers , fp_dir , fp_param )
struct rt_comb_internal *comb;
int length,dependent;
struct iges_properties *props;
int de_pointers[];
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	int			actual_length=0;
	int			name_de;
	int			props_de;
	int			color_de=DEFAULT;
	int			non_union_count=0;
	int			status=1;
	int			entity_type;
	int			i;

	RT_CK_COMB( comb );

	/* if any part of this tree has not been converted, don't try to write the tree */
	for( i=0 ; i<length ; i++ )
	{
		if( de_pointers[i] )
			actual_length++;
	}
	if( actual_length != length )
		return( 0 );

	if( dependent )
		status = 10001;

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	/* write name entity */
	name_de = write_name_entity( props->name , fp_dir , fp_param );

	/* write attributes entity */
	props_de = write_att_entity( props , fp_dir , fp_param );

	/* get color */
	if( props->color_defined )
		color_de = get_color( props->color , fp_dir , fp_param );
	else
		color_de = 0;

	non_union_count = count_non_union_ops( comb->tree );

	if( mode == CSG_MODE || non_union_count )
	{
		/* write the combination as a Boolean tree */
		entity_type = 180;
		write_igs_tree( &str, comb, length, de_pointers );
	}
	else
	{
		/* write the combination as a solid assembly */
		entity_type = 184;

		bu_vls_printf( &str , "%d,%d" , entity_type , length );
		for( i=0 ; i<length ; i++ )
			bu_vls_printf( &str , ",%d" , de_pointers[i] );
		for( i=0 ; i<length ; i++ )
			bu_vls_strcat( &str , ",0" );
	}

	if( props_de || name_de )
	{
		if( props_de && name_de )
			bu_vls_strcat( &str , ",0,2" );
		else
			bu_vls_printf( &str , ",0,1" );
		if( props_de )
			bu_vls_printf( &str , ",%d" , props_de );
		if( name_de )
			bu_vls_printf( &str , ",%d" , name_de );

	}
	bu_vls_strcat( &str , ";" );

	dir_entry[1] = entity_type;
	dir_entry[2] = param_seq + 1;
	dir_entry[8] = 0;
	dir_entry[9] = status;
	dir_entry[11] = entity_type;
	dir_entry[13] = color_de;
	dir_entry[15] = comb_form;
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );

}

int
comb_to_iges( comb , length , dependent , props , de_pointers , fp_dir , fp_param )
struct rt_comb_internal *comb;
int length,dependent;
struct iges_properties *props;
int de_pointers[];
FILE *fp_dir,*fp_param;
{
	RT_CK_COMB( comb );

	if( length == 1 )
		return( short_comb_to_iges( props , dependent , de_pointers , fp_dir , fp_param ) );
	else
		return( tree_to_iges( comb , length , dependent , props , de_pointers , fp_dir , fp_param ) );
}
@


11.16
log
@change conf.h to a wrapped config.h
@
text
@d32 1
a32 1
static const char RCSid[] = "$Header: /cvs/brlcad/iges/iges.c,v 11.15 2004/02/02 17:39:05 morrison Exp $";
@


11.15
log
@update copyright to include span through 2003
@
text
@d32 1
a32 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/iges/iges.c,v 11.14 2001/11/05 21:20:05 morrison Exp $";
d35 5
a39 1
#include "conf.h"
@


11.14
log
@Solid to Primitive naming convention conversions
@
text
@d14 1
a14 1
 *      This software is Copyright (C) 1993 by the United States Army.
d32 1
a32 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/iges/iges.c,v 11.13 2001/08/08 20:25:12 jra Exp $";
@


11.14.4.1
log
@sync branch with HEAD
@
text
@d14 1
a14 1
 *      This software is Copyright (C) 1993-2004 by the United States Army.
d32 1
a32 1
static const char RCSid[] = "$Header$";
@


11.14.6.1
log
@sync to HEAD...
@
text
@d14 1
a14 1
 *      This software is Copyright (C) 1993-2004 by the United States Army.
d32 1
a32 1
static const char RCSid[] = "$Header: /n/cad/c/CVS/brlcad/iges/iges.c,v 11.15 2004/02/02 17:39:05 morrison Exp $";
@


11.14.12.1
log
@merge from HEAD
@
text
@d14 1
a14 1
 *      This software is Copyright (C) 1993-2004 by the United States Army.
d32 1
a32 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/iges/iges.c,v 11.15 2004/02/02 17:39:05 morrison Exp $";
@


11.14.12.2
log
@merge from head
@
text
@d32 1
a32 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/iges/iges.c,v 11.14.12.1 2004/02/12 19:41:39 erikg Exp $";
@


11.13
log
@Lint
@
text
@d32 1
a32 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/iges/iges.c,v 11.12 2001/02/06 15:13:42 jra Exp $";
d181 1
a181 1
			"Solid of Linear Extrusion",
d184 2
a185 2
			"Solid Assembly",
			"Manifold Solid BREP Object",
d191 1
a191 1
			"Solid Instance",
d2772 1
a2772 1
				bu_log( "Solid %s is a plate mode solid, and cannot be converted to IGES format!!!\n", name );
@


11.12
log
@Mods to get IGES working with new database format (v5)
@
text
@d32 1
a32 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/iges/iges.c,v 11.11 2000/10/27 20:21:51 jra Exp $";
d584 5
a588 5
write_freeform( fp , s , de , c )
FILE *fp;	/* output file */
char s[];	/* the string to be output (must not contain any NL's) */
int de;		/* the directory entry # that this belongs to (ignored for Global section) */
char c;		/* 'G' for global section
d591 1
@


11.11
log
@Some mods to fail gracefully when using plate mode BOTs
@
text
@d32 1
a32 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/iges/iges.c,v 11.10 2000/09/08 05:56:37 mike Exp $";
d44 1
d84 11
@


11.10
log
@
Tree routines need resource pointer.
@
text
@d32 1
a32 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/iges/iges.c,v 11.9 2000/08/24 04:59:42 mike Exp $";
d858 1
d876 2
d899 3
d1945 1
a1945 1
	if( lookup_props( &props , name ) )
d2754 9
@


11.9
log
@
lint.
@
text
@d32 1
a32 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/iges/iges.c,v 11.8 2000/08/24 04:10:48 mike Exp $";
d355 1
a355 1
	id = rt_db_get_internal( &intern, dp, dbip, (matp_t)NULL );
d359 1
a359 1
		rt_db_free_internal( &intern );
d366 1
a366 1
		rt_db_free_internal( &intern );
d375 1
a375 1
	rt_db_free_internal( &intern );
@


11.8
log
@
mk_addmember
RCSid
@
text
@d32 1
a32 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/iges/iges.c,v 11.7 2000/03/29 18:42:45 mike Exp $";
d766 8
a773 7
w_start_global(fp_dir , fp_param , db_name , prog_name , output_file , id , version )
FILE *fp_dir,*fp_param;
char *db_name;
char *prog_name;
char *output_file;
char *id;
char *version;
@


11.7
log
@
Converted from Release 4 names to know about libbu and libbn
@
text
@d32 1
a32 1
static char RCSid[] = "$Header: /c/CVS/brlcad/iges/iges.c,v 11.6 2000/01/05 14:16:08 jra Exp $";
@


11.7.2.1
log
@Some mods to fail gracefully when using plate mode BOTs
@
text
@d32 1
a32 1
static char RCSid[] = "$Header: /c/CVS/brlcad/iges/iges.c,v 11.7 2000/03/29 18:42:45 mike Exp $";
a856 1
	int			face_count=0;	/* number of shells in nmgregion */
a873 1
				face_count++;
a893 2
	if( face_count == 0 )
		return( 0 );
d1938 1
a1938 1
	if( !name || lookup_props( &props , name ) )
a2746 9
		if( ip->idb_type == ID_BOT )
		{
			struct rt_bot_internal *bot=(struct rt_bot_internal *)ip->idb_ptr;
			if( bot->mode != RT_BOT_SOLID )
			{
				bu_log( "Solid %s is a plate mode solid, and cannot be converted to IGES format!!!\n", name );
				return( 0 );
			}
		}
@


11.6
log
@Eliminated some unused variables
@
text
@d32 1
a32 1
static char RCSid[] = "$Header: /c/CVS/brlcad/iges/iges.c,v 11.5 1999/10/04 18:39:09 jra Exp $";
d71 1
a71 1
static struct rt_tol tol;	/* tolerances */
a83 2
RT_EXTERN( struct face *nmg_find_top_face , (struct shell *s , long *flags ) );

d207 1
a207 1
	for( RT_LIST_FOR( s , shell , &r->s_hd ) )
d212 1
a212 1
		for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
d220 1
a220 1
			for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d225 1
a225 1
				if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d228 1
a228 1
				for( RT_LIST_FOR( eu1 , edgeuse , &lu->down_hd ) )
d268 1
a268 1
						rt_log( "nmg_to_winged_edge: couldn't find second radial face for eu x%x in shell x%x\n" , eu1 , s );
d384 1
a384 1
	struct rt_vls		str;
d389 1
a389 1
	rt_vls_init( &str );
d399 1
a399 1
	rt_vls_printf( &str , "314,%g,%g,%g;" , c[0] , c[1] , c[2] );
d407 1
a407 1
	dir_entry[14] = write_freeform( fp_param , rt_vls_addr( &str ) , dir_seq+1 , 'P' );
d409 1
a409 1
	rt_vls_free( &str );
d439 1
a439 1
	struct rt_vls str;
d443 1
a443 1
	rt_vls_init( &str );
d450 10
a459 10
	rt_vls_printf( &str , "322,%dH%s,5001,9" , strlen( att_string ) , att_string );
	rt_vls_printf( &str , ",1,3,1" ); /* material name */
	rt_vls_printf( &str , ",2,3,1" ); /* material parameters */
	rt_vls_printf( &str , ",3,6,1" ); /* region flag (logical value) */
	rt_vls_printf( &str , ",4,1,1" ); /* ident number */
	rt_vls_printf( &str , ",5,1,1" ); /* air code number */
	rt_vls_printf( &str , ",6,1,1" ); /* material code number */
	rt_vls_printf( &str , ",7,1,1" ); /* los density (X100) */
	rt_vls_printf( &str , ",8,1,1" ); /* inheritance */
	rt_vls_printf( &str , ",9,6,1;" ); /* color_defined (logical value) */
d466 1
a466 1
	dir_entry[14] =  write_freeform( fp_param , rt_vls_addr( &str ) , dir_seq+1 , 'P' );
d475 1
a475 1
	rt_vls_free( &str );
d483 1
a483 1
struct rt_tol *set_tol;
d488 1
a488 1
	RT_CK_TOL( set_tol );
d535 1
a535 1
		rt_log( "Writing directory entry for an unknown entity type (%d)\n" , entry[1] );
d606 1
a606 1
		rt_log( "Bad section character passed to 'write_freeform' (%c)\n" , c );
d774 1
a774 1
	struct rt_vls str;
d779 1
a779 1
	rt_vls_init( &str );
d782 3
a784 3
	rt_vls_printf( &str , "This IGES file created by %s from the database %s." , prog_name , db_name );
	(void)write_freeform( fp_dir , rt_vls_addr( &str ) , 0 , 'S' );
	rt_vls_free( &str );
d787 1
a787 1
	rt_vls_printf( &str , ",,%dH%s" , strlen( db_name ), db_name);
d790 1
a790 1
		rt_vls_printf( &str , ",7Hstd_out," );
d792 1
a792 1
		rt_vls_printf( &str , ",%dH%s" , strlen( output_file ) , output_file );
d794 1
a794 1
	rt_vls_printf( &str , ",%dH%s,%dH%s,32,38,6,308,15,%dH%s,1.0,2,2HMM,,1.0" ,
d801 1
a801 1
	rt_vls_printf( &str , ",15H%04d%02d%02d.%02d%02d%02d",
d809 1
a809 1
	rt_vls_printf( &str , ",%g,100000.0,7HUnknown,7HUnknown,9,0" ,
d814 1
a814 1
		rt_log( "Cannot stat %s\n" , db_name );
d816 1
a816 1
		rt_vls_strcat( &str , ",15H00000101.000000;" );
d821 1
a821 1
		rt_vls_printf( &str , ",15H%04d%02d%02d.%02d%02d%02d;",
d830 1
a830 1
	(void)write_freeform( fp_dir , rt_vls_addr( &str ) , 0 , 'G' );
d837 1
a837 1
	rt_vls_free( &str );
d850 3
a852 3
	struct nmg_ptbl		vtab;		/* vertex table */
	struct nmg_ptbl		etab;		/* edge table */
	struct nmg_ptbl		**shells;	/* array of tables of shells */
d863 1
a863 1
		for( RT_LIST_FOR( s , shell , &r->s_hd ) )
d867 1
a867 1
			for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
d874 1
a874 1
				for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d878 1
a878 1
					if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d881 1
a881 1
					for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d888 1
a888 1
							rt_log( "vertex with no geometry!!\n" );
d898 1
a898 1
	brep_de = (int *)rt_calloc( outer_shell_count , sizeof( int ) , "nmgregion_to_iges: brep_de" );
d917 1
a917 1
			s_new = RT_LIST_FIRST( shell , &new_r->s_hd );
d921 1
a921 1
			for( j=NMG_TBL_END( shells[i] )-1 ; j >= 0  ; j-- )
d923 1
a923 1
				s = (struct shell *)NMG_TBL_GET( shells[i] , j );
d940 2
a941 2
		(void)nmg_tbl( &vtab , TBL_RST , 0 );
		(void)nmg_tbl( &etab , TBL_RST , 0 );
d948 2
a949 2
	(void)nmg_tbl( &vtab , TBL_FREE , 0 );
	(void)nmg_tbl( &etab , TBL_FREE , 0 );
d964 1
a964 1
	struct rt_vls		str;
d971 1
a971 1
	rt_vls_init( &str );
d977 1
a977 1
	rt_vls_printf( &str , "106,%d,%d" , pt_size-1 , vert_count+1 );
d980 1
a980 1
		rt_vls_printf( &str , ",0.0" );
d982 2
a983 2
			rt_vls_printf( &str , ",%f,%f" , pts[i][0] , pts[i][1] );
		rt_vls_printf( &str , ",%f,%f" , pts[0][0] , pts[0][1] );
d988 2
a989 2
			rt_vls_printf( &str , ",%f,%f,%f" , V3ARGS( pts[i] ) );
		rt_vls_printf( &str , ",%f,%f,%f" , V3ARGS( pts[0] ) );
d992 1
a992 1
	rt_vls_strcat( &str , ";" );
d998 1
a998 1
	dir_entry[14] = write_freeform( fp_param , rt_vls_addr( &str ), dir_seq+1 , 'P' );
d1016 1
a1016 1
	rt_vls_free( &str );
d1030 1
a1030 1
	struct rt_vls		str;
d1040 1
a1040 1
	if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d1044 1
a1044 1
	for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d1051 2
a1052 2
	model_pts = (point_t *)rt_calloc( vert_count , sizeof( point_t ) , "nmg_loop_to_tcurve: model_pts" );
	param_pts = (point_t *)rt_calloc( vert_count , sizeof( point_t ) , "nmg_loop_to_tcurve: param_pts" );
d1054 1
a1054 1
	rt_vls_init( &str );
d1060 1
a1060 1
	rt_vls_printf( &str , "142,0,%d" , surf_de );
d1063 1
a1063 1
	for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d1096 2
a1097 2
	rt_vls_printf( &str , ",%d" , verts_to_copious_data( param_pts , vert_count , 2 , fp_dir , fp_param ) );
	rt_vls_printf( &str , ",%d,0;" , verts_to_copious_data( model_pts , vert_count , 3 , fp_dir , fp_param ));
d1103 1
a1103 1
	dir_entry[14] = write_freeform( fp_param , rt_vls_addr( &str ), dir_seq+1 , 'P' );
d1113 1
a1113 1
	rt_vls_free( &str );
d1123 1
a1123 1
	struct rt_vls		str;
d1136 1
a1136 1
	rt_vls_init( &str );
d1143 1
a1143 1
	for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d1147 1
a1147 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d1160 1
a1160 1
	curve_de = (int *)rt_calloc( loop_count , sizeof( int ) , "nmg_fu_to_tsurf: curve_de" );
d1163 1
a1163 1
	for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d1165 1
a1165 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d1171 1
a1171 1
	rt_vls_printf( &str , "144,%d,0,%d" , surf_de , loop_count-1 );
d1173 2
a1174 2
		rt_vls_printf( &str , ",%d" , curve_de[i] );
	rt_vls_strcat( &str , ";" );
d1176 1
a1176 1
	rt_free( (char *)curve_de , "nmg_fu_to_tsurf: curve_de" );
d1182 1
a1182 1
	dir_entry[14] = write_freeform( fp_param , rt_vls_addr( &str ), dir_seq+1 , 'P' );
d1191 1
a1191 1
	rt_vls_free( &str );
d1206 1
a1206 1
	for( RT_LIST_FOR( s , shell , &r->s_hd ) )
d1211 1
a1211 1
		for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
d1228 1
a1228 1
struct nmg_ptbl *vtab;   /* vertex table */
d1231 1
a1231 1
	struct rt_vls		str;
d1237 1
a1237 1
	rt_vls_init( &str );
d1247 1
a1247 1
	rt_vls_printf( &str , "502,%d" , NMG_TBL_END( vtab  ) );
d1249 1
a1249 1
	for( i=0 ; i<NMG_TBL_END( vtab ) ; i++ ) {
d1253 1
a1253 1
		v = (struct vertex *)NMG_TBL_GET(vtab,i);
d1257 1
a1257 1
	rt_log( "No geometry for vertex x%x #%d in table\n" , v , i );
d1259 1
a1259 1
		rt_vls_printf( &str, ",%g,%g,%g",
d1264 1
a1264 1
	rt_vls_strcat( &str , ";" );
d1270 1
a1270 1
	dir_entry[14] = write_freeform( fp_param , rt_vls_addr( &str ), dir_seq+1 , 'P' );
d1280 1
a1280 1
	rt_vls_free( &str );
d1291 1
a1291 1
	struct rt_vls str;
d1298 1
a1298 1
	rt_vls_init( &str );
d1305 1
a1305 1
	rt_vls_printf( &str , "110,%g,%g,%g,%g,%g,%g;" ,
d1317 1
a1317 1
	dir_entry[14] =  write_freeform( fp_param , rt_vls_addr( &str ) , dir_seq+1 , 'P' );
d1326 1
a1326 1
	rt_vls_free( &str );
d1337 1
a1337 1
	struct rt_vls str;
d1344 1
a1344 1
	rt_vls_init( &str );
d1351 1
a1351 1
	rt_vls_printf( &str , "126,1,1,0,0,1,0,0.,0.,1.,1.,1.,1.,%g,%g,%g,%g,%g,%g,0.,1.;" ,
d1363 1
a1363 1
	dir_entry[14] =  write_freeform( fp_param , rt_vls_addr( &str ) , dir_seq+1 , 'P' );
d1372 1
a1372 1
	rt_vls_free( &str );
d1381 2
a1382 2
struct nmg_ptbl *etab;	/* edge table */
struct nmg_ptbl *vtab;	/* vertex table (already filled in) */
d1385 1
a1385 1
	struct rt_vls str;
d1391 1
a1391 1
	rt_vls_init( &str );
d1400 1
a1400 1
	rt_vls_printf( &str , "504,%d" , NMG_TBL_END( etab ) );
d1403 1
a1403 1
	for( i=0 ; i<NMG_TBL_END( etab ) ; i++ )
d1412 1
a1412 1
		e = (struct edge *)NMG_TBL_GET(etab,i);
d1432 1
a1432 1
		rt_vls_printf( &str , ",%d,%d,%d,%d,%d",
d1434 2
a1435 2
			vert_de , nmg_tbl( vtab , TBL_LOC , (long *)start_v ) + 1,
			vert_de , nmg_tbl( vtab , TBL_LOC , (long *)end_v ) + 1 );
d1437 1
a1437 1
	rt_vls_strcat( &str , ";" );
d1443 1
a1443 1
	dir_entry[14] = write_freeform( fp_param , rt_vls_addr( &str ) , dir_seq+1 , 'P' );
d1452 1
a1452 1
	rt_vls_free( &str );
d1462 1
a1462 1
	struct rt_vls		str;
d1469 1
a1469 1
	rt_vls_init( &str );
d1471 1
a1471 1
	rt_vls_printf( &str , "116,%g,%g,%g,0;" ,
d1480 1
a1480 1
	dir_entry[14] = write_freeform( fp_param , rt_vls_addr( &str ) , dir_seq+1 , 'P' );
d1488 1
a1488 1
	rt_vls_free( &str );
d1498 1
a1498 1
	struct rt_vls		str;
d1505 1
a1505 1
	rt_vls_init( &str );
d1507 1
a1507 1
	rt_vls_printf( &str , "123,%g,%g,%g;" ,
d1516 1
a1516 1
	dir_entry[14] = write_freeform( fp_param , rt_vls_addr( &str ) , dir_seq+1 , 'P' );
d1524 1
a1524 1
	rt_vls_free( &str );
d1534 1
a1534 1
	struct rt_vls	str;
d1542 1
a1542 1
	rt_vls_init( &str );
d1546 1
a1546 1
	rt_vls_printf( &str , "190,%d,%d;" ,
d1554 1
a1554 1
	dir_entry[14] = write_freeform( fp_param , rt_vls_addr( &str ) , dir_seq+1 , 'P' );
d1562 1
a1562 1
	rt_vls_free( &str );
d1582 1
a1582 1
	struct rt_vls   	str;
d1591 1
a1591 1
	rt_vls_init( &str );
d1594 1
a1594 1
	lu = RT_LIST_FIRST( loopuse , &fu->lu_hd );
d1596 2
a1597 2
	while( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC &&
				RT_LIST_NOT_HEAD( lu , &fu->lu_hd ) )
d1599 1
a1599 1
		lu = RT_LIST_PNEXT( loopuse , lu );
d1602 1
a1602 1
	if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d1604 1
a1604 1
		rt_log( "Write_planar_nurb: could not find a loop (with edges) in face\n" );
d1608 1
a1608 1
	eu = RT_LIST_FIRST( edgeuse , &lu->down_hd );
d1612 1
a1612 1
	eu_next = RT_LIST_PNEXT( edgeuse , eu );
d1628 1
a1628 1
	for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d1631 1
a1631 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d1634 1
a1634 1
		for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d1655 1
a1655 1
	rt_vls_printf( &str , "128,1,1,1,1,0,0,1,0,0,0.,0.,1.,1.,0.,0.,1.,1.,1.,1.,1.,1." );
d1660 1
a1660 1
	rt_vls_printf( &str , ",%g,%g,%g" , V3ARGS( ctl_pt ) );
d1662 1
a1662 1
	rt_vls_printf( &str , ",%g,%g,%g" , V3ARGS( ctl_pt ) );
d1664 1
a1664 1
	rt_vls_printf( &str , ",%g,%g,%g" , V3ARGS( ctl_pt ) );
d1666 1
a1666 1
	rt_vls_printf( &str , ",%g,%g,%g" , V3ARGS( ctl_pt ) );
d1669 1
a1669 1
	rt_vls_printf( &str , ",0.,1.,0.,1.;" );
d1675 1
a1675 1
	dir_entry[14] = write_freeform( fp_param , rt_vls_addr( &str ) , dir_seq+1 , 'P' );
d1683 1
a1683 1
	rt_vls_free( &str );
d1695 1
a1695 1
struct nmg_ptbl *etab;	/* Table of edge pointers */
d1697 1
a1697 1
struct nmg_ptbl *vtab;	/* Table of vertex pointers */
d1705 1
a1705 1
	struct rt_vls		str;
d1717 1
a1717 1
	rt_vls_init( &str );
d1720 1
a1720 1
	for( RT_LIST_FOR( s , shell , &r->s_hd ) )
d1724 1
a1724 1
	shell_list = (int *)rt_calloc( shell_count , sizeof( int ) , "write_shell_face_loop: shell_list" );
d1727 1
a1727 1
	for( RT_LIST_FOR( s , shell , &r->s_hd ) )
d1734 1
a1734 1
		for (RT_LIST_FOR(fu, faceuse, &s->fu_hd))
d1741 1
a1741 1
		face_list = (int *)rt_calloc( face_count , sizeof( int ) , "face_list" );
d1745 1
a1745 1
		for (RT_LIST_FOR(fu, faceuse, &s->fu_hd))
d1756 1
a1756 1
			for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd))
d1763 1
a1763 1
			loop_list = (int *)rt_calloc( loop_count , sizeof( int ) , "loop_list" );
d1766 1
a1766 1
			for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd))
d1771 1
a1771 1
				if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC)
d1773 1
a1773 1
					for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd))
d1783 1
a1783 1
				else if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC)
d1785 1
a1785 1
		  			v = RT_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p;
d1791 1
a1791 1
					rt_log("write_shell_face_loop: loopuse mess up! (1)\n");
d1793 1
a1793 1
				rt_vls_printf( &str , "508,%d" , edge_count );
d1795 1
a1795 1
				if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC)
d1797 1
a1797 1
					for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd))
d1810 1
a1810 1
						rt_vls_printf( &str , ",0,%d,%d,%d,0",
d1812 1
a1812 1
							nmg_tbl( etab , TBL_LOC , (long *)(e)) + 1,
d1818 1
a1818 1
				else if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC)
d1820 2
a1821 2
		  			v = RT_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p;
					rt_vls_printf( &str , ",1,%d,%d,1,0",
d1823 1
a1823 1
						nmg_tbl( vtab , TBL_LOC , (long *)v )+1 );
d1825 1
a1825 1
					rt_log("write_shell_face_loop: loopuse mess up! (2)\n");
d1827 1
a1827 1
				rt_vls_strcat( &str , ";" );
d1838 1
a1838 1
				dir_entry[14] = write_freeform( fp_param , rt_vls_addr( &str ) , dir_seq+1 , 'P' );
d1848 1
a1848 1
				rt_vls_free( &str );
d1854 1
a1854 1
				rt_log( "No outside loop found for face\n" );
d1872 1
a1872 1
				rt_vls_printf( &str , "510,%d,%d,%d" ,
d1878 1
a1878 1
				rt_vls_printf( &str , "510,%d,%d,%d" ,
d1884 1
a1884 1
				rt_vls_printf( &str , ",%d" , loop_list[i] );
d1886 1
a1886 1
			rt_vls_strcat( &str , ";" );
d1897 1
a1897 1
			dir_entry[14] = write_freeform( fp_param , rt_vls_addr( &str ) , dir_seq+1 , 'P' );
d1901 2
a1902 2
			rt_free( (char *)loop_list , "loop list" );
			rt_vls_free( &str );
d1906 1
a1906 1
		rt_vls_printf( &str , "514,%d" , face_count );
d1908 2
a1909 2
			rt_vls_printf( &str , ",%d,1" , face_list[i] );
		rt_vls_strcat( &str , ";" );
d1921 1
a1921 1
		dir_entry[14] = write_freeform( fp_param , rt_vls_addr( &str ) , dir_seq+1 , 'P' );
d1925 2
a1926 2
		rt_free( (char *)face_list , "face list" );
		rt_vls_free( &str );
d1951 1
a1951 1
	rt_vls_printf( &str , "186,%d,1,%d" , shell_list[0] , shell_count-1 );
d1956 1
a1956 1
			rt_vls_printf( &str , ",%d,1" , shell_list[i] );
d1962 1
a1962 1
			rt_vls_strcat( &str , ",0,2" );
d1964 1
a1964 1
			rt_vls_printf( &str , ",0,1" );
d1966 1
a1966 1
			rt_vls_printf( &str , ",%d" , prop_de );
d1968 1
a1968 1
			rt_vls_printf( &str , ",%d" , name_de );
d1972 1
a1972 1
	rt_vls_strcat( &str , ";"  );
d1988 1
a1988 1
	dir_entry[14] = write_freeform( fp_param , rt_vls_addr( &str ) , dir_seq+1 , 'P' );
d1990 2
a1991 2
	rt_free( (char *)shell_list , "shell list" );
	rt_vls_free( &str );
d2057 1
a2057 1
	if( !RT_VECT_ARE_PERP( VDOT( v0 , v1 ) , &tol ) )
d2059 1
a2059 1
	if( !RT_VECT_ARE_PERP( VDOT( v0 , v2 ) , &tol ) )
d2061 1
a2061 1
	if( !RT_VECT_ARE_PERP( VDOT( v1 , v2 ) , &tol ) )
d2072 1
a2072 1
	struct rt_vls		str;
d2081 1
a2081 1
	rt_vls_init( &str );
d2089 1
a2089 1
		rt_vls_printf( &str , "406,1,16H%16.16s;" , name );
d2091 1
a2091 1
		rt_vls_printf( &str , "406,1,%dH%s;" , strlen( name ) , name );
d2097 2
a2098 2
	dir_entry[14] = write_freeform( fp_param , rt_vls_addr( &str ), dir_seq+1 , 'P' );
	rt_vls_free( &str );
d2116 1
a2116 1
	struct rt_vls		str;
d2122 1
a2122 1
		rt_log( "tor_to_iges called for non-torus (type=%d)\n" , ip->idb_type );
d2128 1
a2128 1
	rt_vls_init( &str );
d2138 1
a2138 1
	rt_vls_printf( &str , "160,%g,%g,%g,%g,%g,%g,%g,%g,0,1,%d;",
d2149 2
a2150 2
	dir_entry[14] = write_freeform( fp_param , rt_vls_addr( &str ), dir_seq+1 , 'P' );
	rt_vls_free( &str );
d2169 1
a2169 1
	struct rt_vls		str;
d2176 1
a2176 1
		rt_log( "sph_to_iges called for non-sph (type=%d)\n" , ip->idb_type );
d2185 1
a2185 1
	rt_vls_init( &str );
d2194 1
a2194 1
	rt_vls_printf( &str , "158,%g,%g,%g,%g,0,1,%d;",
d2203 2
a2204 2
	dir_entry[14] = write_freeform( fp_param , rt_vls_addr( &str ), dir_seq+1 , 'P' );
	rt_vls_free( &str );
d2223 1
a2223 1
	struct rt_vls		str;
d2235 1
a2235 1
		rt_log( "ell_to_iges called for non-ell (type=%d)\n" , ip->idb_type );
d2244 1
a2244 1
	rt_vls_init( &str );
d2263 1
a2263 1
	rt_vls_printf( &str , "168,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,0,1,%d;",
d2274 2
a2275 2
	dir_entry[14] = write_freeform( fp_param , rt_vls_addr( &str ), dir_seq+1 , 'P' );
	rt_vls_free( &str );
d2293 1
a2293 1
	struct rt_vls		str;
d2306 1
a2306 1
		rt_log( "rpp_to_iges called for non-arb (type=%d)\n" , ip->idb_type );
d2315 1
a2315 1
	rt_vls_init( &str );
d2349 1
a2349 1
	rt_vls_printf( &str , "150,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,0,1,%d;",
d2360 2
a2361 2
	dir_entry[14] = write_freeform( fp_param , rt_vls_addr( &str ), dir_seq+1 , 'P' );
	rt_vls_free( &str );
d2382 1
a2382 1
		rt_log( "arb_to_iges called for non-arb (type=%d)\n" , ip->idb_type );
d2406 1
a2406 1
	struct rt_vls		str;
d2413 1
a2413 1
		rt_log( "tgc_to_iges called for non-tgc (type=%d)\n" , ip->idb_type );
d2439 2
a2440 2
	if( !RT_VECT_ARE_PERP( VDOT( h_dir , a_dir ) , &tol ) ||
	    !RT_VECT_ARE_PERP( VDOT( h_dir , b_dir ) , &tol ) )
d2454 1
a2454 1
		rt_vls_init( &str );
d2464 1
a2464 1
			rt_vls_printf( &str , "154,%g,%g,%g,%g,%g,%g,%g,%g" ,
d2490 1
a2490 1
			rt_vls_printf( &str , "156,%g,%g,%g,%g,%g,%g,%g,%g,%g" ,
d2496 1
a2496 1
		rt_vls_printf( &str , ",0,1,%d;" , name_de );
d2502 2
a2503 2
		dir_entry[14] = write_freeform( fp_param , rt_vls_addr( &str ), dir_seq+1 , 'P' );
		rt_vls_free( &str );
d2527 1
a2527 1
	struct rt_vls		str;
d2535 1
a2535 1
	rt_vls_init( &str );
d2557 1
a2557 1
	rt_vls_printf( &str , "180,%d,%d" , 2*length-1 , -de_list[0] );
d2559 1
a2559 1
		rt_vls_printf( &str , ",%d,1" , -de_list[i] );
d2564 1
a2564 1
			rt_vls_strcat( &str , ",0,2" );
d2566 1
a2566 1
			rt_vls_printf( &str , ",0,1" );
d2568 1
a2568 1
			rt_vls_printf( &str , ",%d" , prop_de );
d2570 1
a2570 1
			rt_vls_printf( &str , ",%d" , name_de );
d2574 1
a2574 1
	rt_vls_strcat( &str , ";"  );
d2590 1
a2590 1
	dir_entry[14] = write_freeform( fp_param , rt_vls_addr( &str ) , dir_seq+1 , 'P' );
d2592 1
a2592 1
	rt_vls_free( &str );
d2606 1
a2606 1
	struct rt_vls		str;
d2614 1
a2614 1
	rt_vls_init( &str );
d2636 1
a2636 1
	rt_vls_printf( &str , "184,%d" , length );
d2638 1
a2638 1
		rt_vls_printf( &str , ",%d" , de_list[i] );
d2640 1
a2640 1
		rt_vls_printf( &str , ",0" );
d2645 1
a2645 1
			rt_vls_strcat( &str , ",0,2" );
d2647 1
a2647 1
			rt_vls_printf( &str , ",0,1" );
d2649 1
a2649 1
			rt_vls_printf( &str , ",%d" , prop_de );
d2651 1
a2651 1
			rt_vls_printf( &str , ",%d" , name_de );
d2655 1
a2655 1
	rt_vls_strcat( &str , ";"  );
d2671 1
a2671 1
	dir_entry[14] = write_freeform( fp_param , rt_vls_addr( &str ) , dir_seq+1 , 'P' );
d2673 1
a2673 1
	rt_vls_free( &str );
d2713 1
a2713 1
		for( RT_LIST_FOR( r , nmgregion , &model->r_hd ) )
d2722 1
a2722 1
			return( nmgregion_to_iges( name , RT_LIST_FIRST( nmgregion , &model->r_hd ) ,
d2729 1
a2729 1
			region_de = (int *)rt_calloc( region_count , sizeof( int ) , "nmg_to_iges" );
d2733 1
a2733 1
			for( RT_LIST_FOR( r , nmgregion , &model->r_hd ) )
d2741 1
a2741 1
			rt_free( (char *)region_de , "nmg_to_iges" );
d2777 1
a2777 1
	struct rt_vls		str;
d2781 1
a2781 1
	rt_vls_init( &str );
d2788 1
a2788 1
	rt_vls_strcpy( &str , "124"  );
d2791 1
a2791 1
		rt_vls_printf( &str , ",%g" , mat[i] );
d2793 1
a2793 1
	rt_vls_strcat( &str , ";" );
d2801 1
a2801 1
	dir_entry[14] = write_freeform( fp_param , rt_vls_addr( &str ) , dir_seq+1 , 'P' );
d2803 1
a2803 1
	rt_vls_free( &str );
d2814 1
a2814 1
	struct rt_vls		str;
d2818 1
a2818 1
	rt_vls_init( &str );
d2828 1
a2828 1
	rt_vls_printf( &str , "430,%d;" , orig_de );
d2836 1
a2836 1
	dir_entry[14] = write_freeform( fp_param , rt_vls_addr( &str ) , dir_seq+1 , 'P' );
d2838 1
a2838 1
	rt_vls_free( &str );
d2848 1
a2848 1
	struct rt_vls		str;
d2853 1
a2853 1
	rt_vls_init( &str );
d2860 1
a2860 1
	rt_vls_strcpy( &str , "422" );
d2865 1
a2865 1
		rt_vls_printf( &str , ",%dH%s" , str_len , props->material_name );
d2867 1
a2867 1
		rt_vls_strcat( &str , "," );
d2872 1
a2872 1
		rt_vls_printf( &str , ",%dH%s" , str_len , props->material_params );
d2874 1
a2874 1
		rt_vls_strcat( &str , "," );
d2878 1
a2878 1
		rt_vls_strcat( &str , ",1" );
d2880 1
a2880 1
		rt_vls_strcat( &str , ",0" );
d2883 1
a2883 1
	rt_vls_printf( &str , ",%d,%d,%d,%d,%d,%d;" ,
d2898 1
a2898 1
	dir_entry[14] = write_freeform( fp_param , rt_vls_addr( &str ) , dir_seq+1 , 'P' );
d2900 1
a2900 1
	rt_vls_free( &str );
d2916 1
a2916 1
	struct rt_vls		str;
d2931 1
a2931 1
	rt_vls_init( &str );
d2950 1
a2950 1
	rt_vls_printf( &str , "430,%d" , de_pointers[0] );
d2955 1
a2955 1
			rt_vls_strcat( &str , ",0,2" );
d2957 1
a2957 1
			rt_vls_printf( &str , ",0,1" );
d2959 1
a2959 1
			rt_vls_printf( &str , ",%d" , props_de );
d2961 1
a2961 1
			rt_vls_printf( &str , ",%d" , name_de );
d2964 1
a2964 1
	rt_vls_strcat( &str , ";" );
d2973 1
a2973 1
	dir_entry[14] = write_freeform( fp_param , rt_vls_addr( &str ) , dir_seq+1 , 'P' );
d2975 1
a2975 1
	rt_vls_free( &str );
d3020 1
a3020 1
			rt_vls_strcat( str, ",1" );
d3025 1
a3025 1
			rt_vls_strcat( str, ",2" );
d3030 1
a3030 1
			rt_vls_strcat( str, ",3" );
d3033 1
a3033 1
			rt_vls_printf( str, ",%d", -de_pointers[de_pointer_number] );
d3052 1
a3052 1
	rt_vls_printf( str , "180,%d", 2*length-1 );
d3066 1
a3066 1
	struct rt_vls		str;
d3091 1
a3091 1
	rt_vls_init( &str );
d3122 1
a3122 1
		rt_vls_printf( &str , "%d,%d" , entity_type , length );
d3124 1
a3124 1
			rt_vls_printf( &str , ",%d" , de_pointers[i] );
d3126 1
a3126 1
			rt_vls_strcat( &str , ",0" );
d3132 1
a3132 1
			rt_vls_strcat( &str , ",0,2" );
d3134 1
a3134 1
			rt_vls_printf( &str , ",0,1" );
d3136 1
a3136 1
			rt_vls_printf( &str , ",%d" , props_de );
d3138 1
a3138 1
			rt_vls_printf( &str , ",%d" , name_de );
d3141 1
a3141 1
	rt_vls_strcat( &str , ";" );
d3150 1
a3150 1
	dir_entry[14] = write_freeform( fp_param , rt_vls_addr( &str ) , dir_seq+1 , 'P' );
d3152 1
a3152 1
	rt_vls_free( &str );
@


11.5
log
@Y2K update
@
text
@d32 1
a32 1
static char RCSid[] = "$Header: /c/CVS/brlcad/iges/iges.c,v 11.4 1997/03/06 20:24:39 jra Exp $";
a3073 1
	int			union_count=0;
@


11.4
log
@Converted to use combination import/export.
@
text
@d32 1
a32 1
static char RCSid[] = "$Header: /m/cad/iges/RCS/iges.c,v 11.3 1996/12/31 17:44:26 jra Exp jra $";
d289 2
d294 1
a294 1
		if( len > 32 ) len = 32;
d296 1
a296 1
		strncpy( props->material_params, endp+1, 60 );
d298 1
a298 1
		strncpy( props->material_name, bu_vls_addr(&comb->shader), 32 );
d803 2
a804 2
	rt_vls_printf( &str , ",13H%02d%02d%02d.%02d%02d%02d",
		timep->tm_year,
d818 1
a818 1
		rt_vls_strcat( &str , ",13H000101.000000;" );
d823 2
a824 2
		rt_vls_printf( &str , ",13H%02d%02d%02d.%02d%02d%02d;",
			timep->tm_year,
@


11.3
log
@Some initialization needed.
@
text
@d32 1
a32 1
static char RCSid[] = "$Header: /m/cad/iges/RCS/iges.c,v 11.2 1995/12/06 13:25:06 jra Exp jra $";
a47 1
#include "db.h"
d76 1
d280 1
a280 1
get_props( props , rp )
d282 1
a282 1
union record *rp;
d284 1
d286 22
a307 9
	strcpy( props->name , rp->c.c_name );
	strcpy( props->material_name , rp->c.c_matname );
	strcpy( props->material_params , rp->c.c_matparm );
	props->region_flag = rp->c.c_flags;
	props->ident = rp->c.c_regionid;
	props->air_code = rp->c.c_aircode;
	props->material_code = rp->c.c_material;
	props->los_density = rp->c.c_los;
	props->color_defined = (rp->c.c_override ? 1 : 0 );
d310 3
a312 3
		props->color[0] = rp->c.c_rgb[0];
		props->color[1] = rp->c.c_rgb[1];
		props->color[2] = rp->c.c_rgb[2];
d320 1
a320 1
	props->inherit = ( rp->c.c_inherit ? 1 : 0 );
a327 1
	union record rp;
d329 3
d333 1
a333 1
	props->name[0] = '\0';
d355 10
a364 1
	if( db_get( dbip , dp , &rp , 0 , 1 ) )
d366 2
a367 1
		rt_log( "Couldn't get record for %s\n" , name );
d371 5
a375 1
	get_props( props , &rp );
a2772 22
matrix_is_identity( mat )
dbfloat_t mat[16];
{
	int i;

	for( i=0 ; i<ELEMENTS_PER_MAT ; i++ )
	{
		if( i == 0 || i == 5 || i == 10 || i == 15 )
		{
			if( mat[i] != 1.0 )
				return( 0 );
		}
		else
		{
			if( mat[i] != 0.0 )
				return( 0 );
		}
	}
	return( 1 );
}

int
d2774 1
a2774 1
dbfloat_t mat[16];
d2811 1
a2811 1
dbfloat_t mat[16];
d2982 79
a3060 2
tree_to_iges( rp , length , dependent , props , de_pointers , fp_dir , fp_param )
union record rp[];
d3078 2
d3110 1
a3110 5
	for( i=1 ; i<length ; i++ )
	{
		if( rp[i+1].M.m_relation != UNION )
			non_union_count++;
	}
d3116 1
a3116 20

		rt_vls_printf( &str , "%d,%d,%d" , entity_type , 2*length-1 , -de_pointers[0] );
		for( i=1 ; i<length ; i++ )
		{
			switch( rp[i+1].M.m_relation )
			{
			case UNION:
				rt_vls_printf( &str , ",%d" , -de_pointers[i] );
				union_count++;
				break;
			case INTERSECT:
				rt_vls_printf( &str , ",%d,2" , -de_pointers[i] );
				break;
			case SUBTRACT:
				rt_vls_printf( &str , ",%d,3" , -de_pointers[i] );
				break;
			}
		}
		for( i=0 ; i<union_count ; i++ )
			rt_vls_strcat( &str , ",1" );
d3160 2
a3161 2
comb_to_iges( rp , length , dependent , props , de_pointers , fp_dir , fp_param )
union record rp[];
d3167 2
d3172 1
a3172 1
		return( tree_to_iges( rp , length , dependent , props , de_pointers , fp_dir , fp_param ) );
@


11.2
log
@All logging done via rt_log
@
text
@d32 1
a32 1
static char RCSid[] = "$Header: /m/cad/iges/RCS/iges.c,v 11.1 1995/01/04 10:07:49 mike Rel4_4 jra $";
d464 5
@


11.1
log
@Release_4.4
@
text
@d32 1
a32 1
static char RCSid[] = "$Header: /m/cad/iges/RCS/iges.c,v 1.15 94/11/08 14:50:12 jra Exp $";
d500 1
a500 1
		fprintf( stderr , "Writing directory entry for an unknown entity type (%d)\n" , entry[1] );
d571 1
a571 1
		fprintf( stderr , "Bad section character passed to 'write_freeform' (%c)\n" , c );
d779 1
a779 1
		fprintf( stderr , "Cannot stat %s\n" , db_name );
d1819 1
a1819 1
				fprintf( stderr , "No outside loop found for face\n" );
@


1.15
log
@Mods for Irix 6.
@
text
@d32 1
a32 1
static char RCSid[] = "$Header: /n/wolf/m/cad/iges/RCS/iges.c,v 1.14 1994/11/03 10:50:54 jra Exp jra $";
@


1.14
log
@Removed nmg_find_outer_and_void_shells (moved to nmg_misc.c in librt).
@
text
@d32 1
a32 1
static char RCSid[] = "$Header: /m/cad/iges/RCS/iges.c,v 1.13 94/10/19 13:58:25 jra Exp Locker: jra $";
d62 1
a63 1
static int	verbose=0;
a76 1
static int	brep_count=0;
d237 1
a237 1
						continue;	/* dangling edge (?warning?) *?
a493 1
	int subscript;
a1351 1
	int edge_de;
d1371 1
a1371 1
		struct edgeuse			*eu,*eum;
a1671 1
	struct nmg_ptbl		**shells;
d1972 1
a1972 1
	vect_t v0,v1,v2,v3;
a1973 1
	int is_rpp=1;
d2741 1
a2741 1
	int i,j;
a2766 1
	int			j;
a2907 1
	int			union_count=0;
@


1.13
log
@Added some NMG_CK's.
@
text
@d32 1
a32 1
static char RCSid[] = "$Header: /m/cad/iges/RCS/iges.c,v 1.12 94/09/26 15:41:23 jra Exp Locker: jra $";
a61 6
/* macro to determine if one bounding box is within another */
#define V3RPP1_IN_RPP2( _lo1 , _hi1 , _lo2 , _hi2 )	( \
	(_lo1)[X] >= (_lo2)[X] && (_hi1)[X] <= (_hi2)[X] && \
	(_lo1)[Y] >= (_lo2)[Y] && (_hi1)[Y] <= (_hi2)[Y] && \
	(_lo1)[Z] >= (_lo2)[Z] && (_hi1)[Z] <= (_hi2)[Z] )

a200 6
struct top_face
{
	struct shell *s;
	struct face *f;
	vect_t normal;
};
a277 265
}

static void
nmg_assoc_void_shells( r , shells , ttol )
CONST struct nmgregion *r;
struct nmg_ptbl *shells;
CONST struct rt_tol *ttol;
{
	struct shell *outer_shell,*void_s,*s;
	struct faceuse *fu;
	struct loopuse *lu;
	struct edgeuse *eu;
	struct face *ext_f;
	long *flags;
	struct top_face *top_faces;
	int total_shells=0;
	int i;

	NMG_CK_REGION( r );
	NMG_CK_PTBL( shells );
	RT_CK_TOL( ttol );

	outer_shell = (struct shell *)NMG_TBL_GET( shells , 0 );
	NMG_CK_SHELL( outer_shell );

	/* count shells in region */
	for( RT_LIST_FOR( s , shell , &r->s_hd ) )
		total_shells++;

	/* make an array of shells and top faces */
	top_faces = (struct top_face *)rt_calloc( total_shells , sizeof( struct top_face ) , "nmg_assoc_void_shells: top_faces" );

	/* make flags array for use by "nmg_find_top_face" */
	flags = (long *)rt_calloc( r->m_p->maxindex , sizeof( long ) , "nmg_find_outer_and_void_shells: flags" );

	top_faces[0].s = outer_shell;
	top_faces[0].f = nmg_find_top_face( outer_shell , flags );
	ext_f = top_faces[0].f;
	fu = top_faces[0].f->fu_p;
	if( fu->orientation != OT_SAME )
		fu = fu->fumate_p;
	NMG_GET_FU_NORMAL( top_faces[0].normal , fu );

	/* fill in top_faces array */
	i = 0;
	for( RT_LIST_FOR( s , shell , &r->s_hd ) )
	{
		if( s == outer_shell )
			continue;

		top_faces[++i].s = s;
		top_faces[i].f = nmg_find_top_face( s , flags );
		fu = top_faces[i].f->fu_p;
		if( fu->orientation != OT_SAME )
			fu = fu->fumate_p;
		NMG_GET_FU_NORMAL( top_faces[i].normal , fu );
	}

	/* look for voids */
	for( RT_LIST_FOR( void_s , shell , &r->s_hd ) )
	{
		struct face *void_f;
		int wrong_void=0;
		vect_t normal;

		if( void_s == outer_shell )
			continue;

		NMG_CK_SHELL( void_s );

		void_f = (struct face *)NULL;
		for( i=0 ; i<total_shells ; i++ )
		{
			if( top_faces[i].s == void_s )
			{
				void_f = top_faces[i].f;
				VMOVE( normal , top_faces[i].normal );
				break;
			}
		}
		if( void_f == (struct face *)NULL )
			rt_bomb( "nmg_assoc_void_shells: no top face for a shell\n" );

		if( normal[Z] < 0.0  )
		{
			/* this is a void shell */
			struct face *int_f;
			struct shell *test_s;
			int breakout=0;
			int not_in_this_shell=0;

			/* this is a void shell
			 * but does it belong with outer_shell */
			if( !V3RPP1_IN_RPP2( void_s->sa_p->min_pt , void_s->sa_p->max_pt , outer_shell->sa_p->min_pt , outer_shell->sa_p->max_pt ) )
			{
				continue;
			}

			for( RT_LIST_FOR( fu , faceuse , &void_s->fu_hd ) )
			{
				for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
				{
					if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
						continue;
					for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
					{
						int class;

						class = nmg_class_pt_s( eu->vu_p->v_p->vg_p->coord , outer_shell , ttol );

						if( class == NMG_CLASS_AoutB )
						{
							breakout = 1;
							not_in_this_shell = 1;
							break;
						}
					}
					if( breakout )
						break;
				}
				if( breakout )
					break;
			}

			if( not_in_this_shell )
				continue;

			int_f = (struct face *)NULL;
			for( i=0 ; i<total_shells ; i++ )
			{
				if( top_faces[i].s == void_s )
				{
					int_f = top_faces[i].f;
					break;
				}
			}
			if( int_f == (struct face *)NULL )
				rt_bomb( "nmg_assoc_void_shells: no top face for a shell\n" );

			/* Make sure there are no other external shells between these two */
			for( RT_LIST_FOR( test_s , shell , &r->s_hd ) )
			{
				vect_t test_norm;
				struct face *test_f;

				test_f = (struct face *)NULL;
				for( i=0 ; i<total_shells ; i++ )
				{
					if( top_faces[i].s == test_s )
					{
						test_f = top_faces[i].f;
						VMOVE( test_norm , top_faces[i].normal );
						break;
					}
				}
				if( test_f == (struct face *)NULL )
					rt_bomb( "nmg_assoc_void_shells: no top face for a shell\n" );

				if( test_norm[Z] > 0.0 )
				{
					if( !V3RPP1_IN_RPP2( void_s->sa_p->min_pt , void_s->sa_p->max_pt , test_s->sa_p->min_pt , test_s->sa_p->max_pt ) )
						continue;

					if( test_f->max_pt[Z] > int_f->max_pt[Z]
					    && test_f->max_pt[Z] < ext_f->max_pt[Z] )
					{
						wrong_void = 1;
						break;
					}
				}
			}
			if( wrong_void )
			{
				continue;
			}

			/* This void shell belongs with shell outer_s 
			 * add it to the list of shells */
			nmg_tbl( shells , TBL_INS , (long *)void_s );
		}
	}
	rt_free( (char *)flags , "nmg_assoc_void_shells: flags" );
}

int
nmg_find_outer_and_void_shells( r , shells , tol )
struct nmgregion *r;
struct nmg_ptbl ***shells;
CONST struct rt_tol *tol;
{
	struct nmg_ptbl *outer_shells;
	struct shell *s;
	int i;
	int total_shells=0;
	int outer_shell_count;
	int re_bound=0;
	long *flags;

	NMG_CK_REGION( r );
	RT_CK_TOL( tol );

	/* Decompose shells */
	outer_shells = (struct nmg_ptbl *)rt_malloc( sizeof( struct nmg_ptbl ) , "nmg_find_outer_and_void_shells: outer_shells" );
	nmg_tbl( outer_shells , TBL_INIT , NULL );
	for (RT_LIST_FOR(s, shell, &r->s_hd))
	{
		NMG_CK_SHELL( s );
		nmg_tbl( outer_shells , TBL_INS , (long *)s );
	}
	for( i=0 ; i<NMG_TBL_END( outer_shells ) ; i++ )
	{
		s = (struct shell *)NMG_TBL_GET( outer_shells , i );
		if( nmg_decompose_shell( s , tol ) > 1 )
			re_bound = 1;
	}
	nmg_tbl( outer_shells , TBL_RST , NULL );

	if( re_bound )
		nmg_region_a( r , tol );

	for (RT_LIST_FOR(s, shell, &r->s_hd))
		total_shells++;

	flags = (long *)rt_calloc( r->m_p->maxindex , sizeof( long ) , "nmg_find_outer_and_void_shells: flags" );

	for( RT_LIST_FOR( s , shell , &r->s_hd ) )
	{
		struct face *f;
		struct faceuse *fu;
		vect_t normal;

		f = nmg_find_top_face( s , flags );
		fu = f->fu_p;
		if( fu->orientation != OT_SAME )
			fu = fu->fumate_p;
		if( fu->orientation != OT_SAME )
			rt_bomb( "nmg_find_outer_and_void_shells: Neither faceuse nor mate have OT_SAME orient\n" );

		NMG_GET_FU_NORMAL( normal , fu );
		if( normal[Z] > 0.0 )
		{
			nmg_tbl( outer_shells , TBL_INS , (long *)s );	/* outer shell */
		}
	}

	/* outer_shells is now a list of all the outer shells in the region */
	outer_shell_count = NMG_TBL_END( outer_shells );

	*shells = (struct nmg_ptbl **)rt_calloc( NMG_TBL_END( outer_shells ) , sizeof( struct nmg_ptbl *) ,
			"nmg_find_outer_and_void_shells: shells" );
	for( i=0 ; i<NMG_TBL_END( outer_shells ) ; i++ )
	{
		(*shells)[i] = (struct nmg_ptbl *)rt_malloc( sizeof( struct nmg_ptbl ) , 
			"nmg_find_outer_and_void_shells: shells[]" );

		nmg_tbl( (*shells)[i] , TBL_INIT , NULL );
		NMG_CK_PTBL( (*shells)[i] );
		nmg_tbl( (*shells)[i] , TBL_INS , (long *)NMG_TBL_GET( outer_shells , i ) );
		if( outer_shell_count != total_shells ) /* must be some void shells */
			nmg_assoc_void_shells( r , (*shells)[i] , tol );
	}

	rt_free( (char *)flags , "nmg_find_outer_and_void_shells: flags" );
	nmg_tbl( outer_shells , TBL_FREE , NULL );
	return( outer_shell_count );
@


1.12
log
@Added -t option for trimmed surface mode.
@
text
@d32 1
a32 1
static char RCSid[] = "$Header: /m/cad/iges/RCS/iges.c,v 1.11 94/09/02 00:47:48 mike Exp Locker: jra $";
d226 1
d231 1
d239 1
d248 1
d1479 1
d1539 3
d1585 3
d1634 2
d2938 2
@


1.11
log
@Changed to new NMG face geometry pointers.
@
text
@d32 1
a32 1
static char RCSid[] = "$Header: /m/cad/iges/RCS/iges.c,v 1.10 94/08/26 13:49:16 jra Exp Locker: mike $";
d93 1
a93 1
#define		NO_OF_TYPES	28
d95 1
d102 2
d129 1
d136 2
d163 1
d170 2
d1006 1
a1006 1
w_start_global(fp_dir ,  fp_param , db_name , prog_name , output_file , id , version )
d1072 1
a1072 1
	/* write attribute definition  entity */
d1074 2
a1075 1
	attribute_de = write_attribute_definition( fp_dir ,  fp_param );
d1198 268
d1801 1
a1801 1
write_planar_nurb( fu , fp_dir , fp_param )
d1803 3
a1814 2
	vect_t			u_dir;
	vect_t			v_dir;
d1842 1
a1842 1
	vg = eu->vu_p->v_p->vg_p;
d1883 3
d1891 1
d2100 5
d2106 1
a2106 1
					write_planar_nurb( fu , fp_dir , fp_param ),
d2109 1
@


1.10
log
@changed include to reflect dir ame change to iges
@
text
@d32 1
a32 1
static char RCSid[] = "$Header: /m/cad/iges/RCS/iges.c,v 1.9 94/08/26 10:39:36 jra Exp Locker: jra $";
d1572 1
a1572 1
	VCROSS( v_dir , fu->f_p->fg_p->N , u_dir );
d1823 1
a1823 1
					write_plane_entity( fu->f_p->fg_p->N , fp_dir , fp_param ),
@


1.9
log
@Cleanup.
@
text
@d32 1
a32 1
static char RCSid[] = "$Header: /m/cad/iges-g/RCS/iges.c,v 1.8 94/08/24 09:19:00 jra Exp Locker: jra $";
d56 1
a56 1
#include "../iges-g/iges.h"
@


1.8
log
@fixed bug in get_color
@
text
@d1 1
a1 1
	/*
d20 1
a20 3
 *		Fix handling of shells (IGES expects an outer shell plus one
 *			or more  void shells)
 *
d32 1
a32 1
static char RCSid[] = "$Header: /n/wolf/m/cad/iges-g/RCS/iges.c,v 1.7 94/08/22 19:31:48 gdurf Exp Locker: jra $";
d84 2
a244 1
rt_log( "nmg_to_winged_edge: Ungluing an edge\n" );
a300 1
rt_log( "Looking for voids in shell x%x\n" , outer_shell );
a318 1
rt_log( "shell x%x, top_face = x%x , normal = ( %g %g %g )\n" , top_faces[0].s , top_faces[0].f , V3ARGS( top_faces[0].normal ) );
a332 1
rt_log( "shell x%x, top_face = x%x , normal = ( %g %g %g )\n" , top_faces[i].s , top_faces[i].f , V3ARGS( top_faces[i].normal ) );
a344 2
rt_log( "\t\tChecking shell x%x as possible void\n" , void_s );

a358 1
rt_log( "\t\t\tnormal = ( %g %g %g )\n" , V3ARGS( normal ) );
a366 1
rt_log( "\t\t\tIt is a void shell...\n" );
a371 1
rt_log( "\t\t\t\tNot for this external shell (bounding boxes not within one another)\n" );
a388 1
rt_log( "\t\t\tNot for this external shell (point on void shell is outside external shell)\n" );
a449 1
rt_log( "\t\t\t\tWrong void\n" );
a455 1
rt_log( "\t\t\t\tMarked this Shell (x%x) as void inside shell x%x\n" , void_s , outer_shell );
a518 1
rt_log( "Shell x%x is an outer shell\n" , s );
a519 2
		else
rt_log( "Shell x%x is a void shell\n" , s );
a1127 17
	/* debugging loop */
	for( i=0 ; i<outer_shell_count ; i++ )
	{
		struct shell *s;
		int j;

		s = (struct shell *)NMG_TBL_GET( shells[i] , 0 );
		rt_log( "Outer shell x%x has the following void shells:\n" , s );
		NMG_CK_SHELL( s );
		for( j=1 ; j<NMG_TBL_END( shells[i] ) ; j++ )
		{
			s = (struct shell *)NMG_TBL_GET( shells[i] , j );
			rt_log( "\tx%x\n" , s );
			NMG_CK_SHELL( s );
		}
	}

a1138 1
rt_log( "only one outer shell, no new region created\n" );
a1149 1
rt_log( "For outer shell #%d new_r = x%x\n" , i , new_r );
a1153 1
rt_log( "Moving shell x%x to region x%x\n" , s , new_r );
a1160 1
rt_log( "writing vertex list for region x%x\n" , new_r );
a1163 1
rt_log( "writing edge list for region x%x\n" , new_r );
a1181 2
{
rt_log( "Writing solid assembly\n" );
a1182 1
}
d2634 2
d2637 10
d2665 2
a2666 1
			return( nmgregion_to_iges( name , RT_LIST_FIRST( nmgregion , &model->r_hd ) , fp_dir , fp_param ) );
d2677 2
a2678 1
				region_de[region_count++] = nmgregion_to_iges( (char *)NULL , r , fp_dir , fp_param );
d2681 2
a2682 1
			brep_de = write_tree_of_unions( name , region_de , region_count , fp_dir , fp_param );
d2699 1
a2699 1
			brep_de =  nmgregion_to_iges( name , r , fp_dir , fp_param );
@


1.7
log
@Factored ifdefs
@
text
@d34 1
a34 1
static char RCSid[] = "$Header: /m/cad/iges-g/RCS/iges.c,v 1.6 1994/05/05 10:01:17 jra Exp gdurf $";
a670 2
rt_log( "get_color: %d %d %d\n" , V3ARGS( color ) );

d680 1
a680 2
		color_de = (-write_color_entity( color ));
rt_log( "\tcolor_de = %d\n" , color_de );
@


1.6
log
@Corrected error in default color_de
@
text
@d34 1
a34 1
static char RCSid[] = "$Header: /m/cad/iges-g/RCS/iges.c,v 1.5 94/01/07 15:15:41 jra Exp Locker: jra $";
d37 2
d41 1
d43 3
@


1.5
log
@Modified header files
@
text
@d34 1
a34 1
static char RCSid[] = "$Header: /m/cad/iges-g/RCS/iges.c,v 1.4 94/01/04 10:59:38 jra Exp Locker: jra $";
d312 2
d473 1
a473 1
	struct nmg_ptbl outer_shells;
d485 2
a486 1
	nmg_tbl( &outer_shells , TBL_INIT , NULL );
d490 1
a490 1
		nmg_tbl( &outer_shells , TBL_INS , (long *)s );
d492 1
a492 1
	for( i=0 ; i<NMG_TBL_END( &outer_shells ) ; i++ )
d494 2
a495 2
		s = (struct shell *)NMG_TBL_GET( &outer_shells , i );
		if( nmg_decompose_shell( s ) )
d498 1
a498 1
	nmg_tbl( &outer_shells , TBL_RST , NULL );
d524 1
a524 1
			nmg_tbl( &outer_shells , TBL_INS , (long *)s );	/* outer shell */
d532 1
a532 9
	outer_shell_count = NMG_TBL_END( &outer_shells );
	if( outer_shell_count == total_shells )
	{
		/* there are no void shells */
		*shells = (struct nmg_ptbl **)rt_malloc(  sizeof( struct nmg_ptbl *) ,
			"nmg_find_outer_and_void_shells: shells" );
		**shells = &outer_shells; /* return the list of outer shells */
		return( outer_shell_count );		/* no void shells */
	}
d534 1
a534 1
	*shells = (struct nmg_ptbl **)rt_calloc( NMG_TBL_END( &outer_shells ) , sizeof( struct nmg_ptbl *) ,
d536 1
a536 1
	for( i=0 ; i<NMG_TBL_END( &outer_shells ) ; i++ )
d543 3
a545 2
		nmg_tbl( (*shells)[i] , TBL_INS , (long *)NMG_TBL_GET( &outer_shells , i ) );
		nmg_assoc_void_shells( r , (*shells)[i] , tol );
d549 1
a549 1
	nmg_tbl( &outer_shells , TBL_FREE , NULL );
d665 2
d677 1
a1180 1
		}
d1182 3
a1184 3
		for( j=NMG_TBL_END( shells[i] )-1 ; j >= 0  ; j-- )
		{
			s = (struct shell *)NMG_TBL_GET( shells[i] , j );
d1186 3
a1188 1
			nmg_mv_shell_to_region( s , new_r );
a1189 2
		if( s_new )
			(void)nmg_ks( s_new );
d1191 1
d1216 2
d1219 1
d1389 1
a1389 1
	nmg_region_edge_list( etab , r );
d1700 1
a1700 1
	int			color_de;
d2514 1
a2514 1
	int			color_de;
d2593 1
a2593 1
	int			color_de;
d2908 1
a2908 1
	int			color_de;
d2983 1
a2983 1
	int			color_de;
@


1.4
log
@Checkpoint
@
text
@d1 1
a1 1
/*
d34 1
a34 1
static char RCSid[] = "$Header: /m/cad/iges-g/RCS/iges.c,v 1.3 93/09/24 10:04:19 jra Exp Locker: jra $";
d47 2
d58 6
d77 7
d85 2
a180 7
static char	*unknown="Unknown";
static int	unknown_count=0;
extern int	solid_is_brep;
extern int	comb_form;
extern int	do_nurbs;
extern struct db_i	*dbip;

d192 7
d200 358
d607 3
d652 1
a652 1
	dir_entry[9] = 201;
d719 1
a719 1
	dir_entry[9] = 201;
d1085 1
a1085 1
nmgregion_to_iges( name , r , fp_dir , fp_param )
d1088 1
d1091 2
d1095 2
a1096 1
	int			brep_de;	/* Directory entry sequence # for BREP Object */
d1099 2
d1102 1
a1102 2
	/* Make the vertex list entity */
	vert_de = write_vertex_list( r , &vtab , fp_dir , fp_param );
d1104 5
a1108 2
	/* Make the edge list entity */
	edge_de = write_edge_list( r , vert_de , &etab , &vtab , fp_dir , fp_param );
d1110 3
a1112 2
	/* Make the face, loop, shell entities */
	brep_de = write_shell_face_loop( name , r , edge_de , &etab , vert_de , &vtab , fp_dir , fp_param );
d1114 98
d1216 4
a1219 1
	return( brep_de );
d1252 2
d1674 1
a1674 1
write_shell_face_loop( name , r , edge_de , etab , vert_de , vtab , fp_dir , fp_param )
d1677 1
d1691 1
a1691 1
	int			outer_shell;
d1704 2
a1705 11
	/* Decompose shells */
	for (RT_LIST_FOR(s, shell, &r->s_hd))
	{
		NMG_CK_SHELL( s );
		(void)nmg_decompose_shell( s );
	}

	/* Count shells */
	for (RT_LIST_FOR(s, shell, &r->s_hd))
	{
		NMG_CK_SHELL( s );
a1706 2
	}
	shell_list = (int *)rt_calloc( shell_count , sizeof( int ) , "shell_list" );
d1708 2
a1709 4
	if( shell_count > 1 )
	{
		/* determine outer shell by picking shell with biggest bounding box */
		double diagonal_length;
a1710 25
		diagonal_length = 0.0;
		outer_shell = (-1);
		shell_count = 0;
		nmg_region_a( r , &tol );
		for (RT_LIST_FOR(s, shell, &r->s_hd))
		{
			struct shell_a *sa;
			double tmp_length;
			vect_t diagonal;

			sa = s->sa_p;
			NMG_CK_SHELL_A( sa );
			VSUB2( diagonal , sa->max_pt , sa->min_pt );
			tmp_length = MAGSQ( diagonal );
			if( tmp_length > diagonal_length )
			{
				diagonal_length = tmp_length;
				outer_shell = shell_count;
			}
			shell_count++;
		}
		if( outer_shell == (-1) )
			rt_bomb( "write_shell_face_loop: couldn`t find outer shell\n" );
	}

d1712 1
a1712 1
	for (RT_LIST_FOR(s, shell, &r->s_hd))
d1717 1
d1930 1
a1930 1
	rt_vls_printf( &str , "186,%d,1,%d" , shell_list[outer_shell] , shell_count-1 );
d1933 1
a1933 1
	for( i=0 ; i<shell_count ; i++ )
a1934 1
		if( i != outer_shell )
d1960 4
a1963 1
	dir_entry[9] = 1;
d2080 1
a2080 1
	/* write directory entry for vertex list entity */
d2132 1
a2132 1
	/* write directory entry for vertex list entity */
d2186 1
a2186 1
	/* write directory entry for vertex list entity */
d2257 1
a2257 1
	/* write directory entry for vertex list entity */
d2343 1
a2343 1
	/* write directory entry for vertex list entity */
d2499 1
a2499 1
write_tree_of_unions( name, de_list , length , fp_dir , fp_param )
d2503 1
d2508 1
d2511 2
a2516 4
	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

d2518 4
a2521 1
	name_de = write_name_entity( name , fp_dir , fp_param );
d2523 13
a2539 1
	rt_vls_printf( &str , ",0,1,%d;" , name_de );
d2541 19
d2563 4
a2566 1
	dir_entry[9] = 10001;
d2568 1
d2578 81
d2881 1
a2881 1
	dir_entry[9] = 10001;
d2983 1
d2985 1
a3017 2
	/* write parameter data into a string */
	rt_vls_printf( &str , "180,%d,%d" , 2*length-1 , -de_pointers[0] );
d3020 11
a3030 1
		switch( rp[i+1].M.m_relation )
d3032 13
a3044 10
		case UNION:
			rt_vls_printf( &str , ",%d" , -de_pointers[i] );
			union_count++;
			break;
		case INTERSECT:
			rt_vls_printf( &str , ",%d,2" , -de_pointers[i] );
			break;
		case SUBTRACT:
			rt_vls_printf( &str , ",%d,3" , -de_pointers[i] );
			break;
d3046 2
d3049 4
a3052 2
	for( i=0 ; i<union_count ; i++ )
		rt_vls_strcat( &str , ",1" );
d3054 7
d3075 1
a3075 1
	dir_entry[1] = 180;
d3079 1
a3079 1
	dir_entry[11] = 180;
@


1.3
log
@Added support for planar nurbs
@
text
@d34 1
a34 1
static char RCSid[] = "$Header: /m/cad/iges-g/RCS/iges.c,v 1.2 93/08/18 09:13:47 jra Exp Locker: jra $";
d752 1
a752 1
	nmg_region_vertex_list( vtab, r );
d1200 1
d1209 2
d1213 6
d1228 30
d1475 2
a1476 2
	/* XXX ASSUMES THAT FIRST SHELL IS THE OUTER SHELL XXX */
	rt_vls_printf( &str , "186,%d,1,%d" , shell_list[0] , shell_count-1 );
d1478 6
a1483 3
	/* XXX ASSUMES THAT ANY ADDITIONAL SHELLS ARE VOID SHELLS (WRONG!!!!) XXX */
	for( i=1 ; i<shell_count ; i++ )
		rt_vls_printf( &str , "%d,1" , shell_list[i] );
@


1.2
log
@slight mods for installation in cad tree
@
text
@d34 1
a34 1
static char RCSid[] = "$Header: /n/wolf/m/cad/iges-g/RCS/iges.c,v 1.1 93/08/18 08:50:27 jra Exp Locker: jra $";
d70 1
a70 1
#define		NO_OF_TYPES	26
d76 2
d107 2
d138 2
d168 1
d344 3
d785 3
d828 3
d835 43
d927 4
a930 1
		line_de = write_line_entity( start_vg , end_vg , fp_dir , fp_param );
d950 3
d986 3
d1022 3
d1060 3
d1068 116
d1332 1
a1332 1
				/* write directory entry for line entity */
d1358 10
a1367 4
			rt_vls_printf( &str , "510,%d,%d,%d" ,
				write_plane_entity( fu->f_p->fg_p->N , fp_dir , fp_param ),
				loop_count,
				outer_loop_flag );
d1536 3
d1782 1
d1814 15
@


1.1
log
@Initial revision
@
text
@d34 1
a34 1
static char RCSid[] = "$Header: /n/wolf/vld/jra/SOURCE/g-iges/RCS/iges.c,v 1.6 93/08/18 08:40:10 jra Exp $";
d50 1
a50 1
#include "iges.h"
@
