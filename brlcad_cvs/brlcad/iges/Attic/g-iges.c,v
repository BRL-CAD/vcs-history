head	11.30;
access;
symbols
	ansi-20040405-merged:11.25.4.1
	postmerge-20040405-ansi:11.28
	premerge-20040404-ansi:11.28
	postmerge-autoconf:11.28
	autoconf-freeze:11.27.6.2
	premerge-autoconf:11.28
	ansi-20040316-freeze:11.25
	postmerge-20040315-windows:11.28
	premerge-20040315-windows:11.28
	windows-20040315-freeze:11.25.6.1
	autoconf-20031203:11.27
	autoconf-20031202:11.27
	autoconf-branch:11.27.0.6
	phong-branch:11.27.0.4
	photonmap-branch:11.27.0.2
	rel-6-1-DP:11.25
	windows-branch:11.25.0.6
	rel-6-0-2:11.25
	ansi-branch:11.25.0.4
	rel-6-0-1-branch:11.25.0.2
	hartley-6-0-post:11.25
	hartley-6-0-pre:11.25
	rel-6-0-1:11.25
	rel-6-0:11.25
	rel-5-4:11.13.2.2
	offsite-5-3-pre:11.20
	rel-5-3:11.13.2.1
	rel-5-2:11.13
	rel-5-1-branch:11.13.0.2
	rel-5-1:11.13
	rel-5-0:11.7
	rel-5-0-beta:11.7
	rel-4-5:11.6
	ctj-4-5-post:11.6
	ctj-4-5-pre:11.6
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.30
date	2004.05.24.04.01.08;	author morrison;	state dead;
branches;
next	11.29;

11.29
date	2004.05.10.15.30.42;	author erikg;	state Exp;
branches;
next	11.28;

11.28
date	2004.03.03.21.31.47;	author morrison;	state Exp;
branches;
next	11.27;

11.27
date	2003.04.02.15.31.15;	author jra;	state Exp;
branches
	11.27.6.1;
next	11.26;

11.26
date	2003.02.24.14.10.07;	author jra;	state Exp;
branches;
next	11.25;

11.25
date	2001.08.08.20.25.12;	author jra;	state Exp;
branches
	11.25.4.1
	11.25.6.1;
next	11.24;

11.24
date	2001.05.17.20.05.03;	author morrison;	state Exp;
branches;
next	11.23;

11.23
date	2001.04.05.19.35.18;	author morrison;	state Exp;
branches;
next	11.22;

11.22
date	2001.03.31.01.56.39;	author morrison;	state Exp;
branches;
next	11.21;

11.21
date	2001.03.29.21.37.46;	author jra;	state Exp;
branches;
next	11.20;

11.20
date	2001.02.06.15.13.42;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	2000.10.27.20.31.21;	author jra;	state Exp;
branches;
next	11.18;

11.18
date	2000.10.20.20.29.54;	author jra;	state Exp;
branches;
next	11.17;

11.17
date	2000.09.08.05.56.37;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	2000.08.24.04.59.41;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	2000.08.24.04.10.47;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	2000.08.01.12.51.45;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	2000.03.29.18.42.44;	author mike;	state Exp;
branches
	11.13.2.1;
next	11.12;

11.12
date	2000.01.05.14.16.08;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	2000.01.04.17.58.20;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	99.12.29.23.23.29;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	99.12.29.21.09.37;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	99.10.04.18.39.09;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	98.05.29.14.29.03;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	97.03.06.20.24.39;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	97.01.08.15.06.53;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	95.12.06.13.25.06;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.03.07.16.28.46;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.02.22.05.36.01;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.07.43;	author mike;	state Rel4_4;
branches;
next	1.13;

1.13
date	94.12.08.17.37.22;	author jra;	state Exp;
branches;
next	1.12;

1.12
date	94.11.08.14.50.05;	author jra;	state Exp;
branches;
next	1.11;

1.11
date	94.11.03.10.50.26;	author jra;	state Exp;
branches;
next	1.10;

1.10
date	94.09.26.15.40.37;	author jra;	state Exp;
branches;
next	1.9;

1.9
date	94.09.26.11.09.50;	author jra;	state Exp;
branches;
next	1.8;

1.8
date	94.08.26.13.48.49;	author jra;	state Exp;
branches;
next	1.7;

1.7
date	94.08.26.10.40.36;	author jra;	state Exp;
branches;
next	1.6;

1.6
date	94.08.22.19.31.44;	author gdurf;	state Exp;
branches;
next	1.5;

1.5
date	94.01.07.15.16.19;	author jra;	state Exp;
branches;
next	1.4;

1.4
date	93.09.24.10.04.48;	author jra;	state Exp;
branches;
next	1.3;

1.3
date	93.08.25.15.10.15;	author jra;	state Exp;
branches;
next	1.2;

1.2
date	93.08.18.09.12.54;	author jra;	state Exp;
branches;
next	1.1;

1.1
date	93.08.18.08.49.43;	author jra;	state Exp;
branches;
next	;

11.13.2.1
date	2000.10.27.20.27.45;	author jra;	state Exp;
branches;
next	11.13.2.2;

11.13.2.2
date	2001.03.29.21.37.27;	author jra;	state Exp;
branches;
next	;

11.25.4.1
date	2004.03.17.21.16.31;	author morrison;	state Exp;
branches;
next	;

11.25.6.1
date	2004.03.11.23.41.14;	author morrison;	state Exp;
branches;
next	;

11.27.6.1
date	2004.03.10.13.19.44;	author erikg;	state Exp;
branches;
next	11.27.6.2;

11.27.6.2
date	2004.03.15.14.06.12;	author erikg;	state Exp;
branches;
next	;


desc
@Code to convert BRLCAD model to IGES 5.1 format
@


11.30
log
@moved to src/iges/
@
text
@/*
 *			G - I G E S . C
 *
 *  Program to convert a BRL-CAD model (in a .g file) to an IGES BREP file
 *  or an IGES CSG file
 *
 *  Authors -
 *	John R. Anderson
 *	Michael J. Markowski
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimitied.
 *
 *  Some stupid secret codes:
 *	dp->d_uses - contains the negative of the DE number for the object
 *		     non-negative means it hasn't been written to the IGES file
 *	dp->d_nref - contains a one if the object is written to the IGES file as a BREP,
 *		     zero otherwise.
 */

static const char RCSid[] = "$Header: /n/xoff/cvs/brlcad/iges/g-iges.c,v 11.29 2004/05/10 15:30:42 erikg Exp $";
static const char RCSrev[] = "$Revision: 11.29 $";

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



extern char	version[];

#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "rtlist.h"
#include "rtstring.h"
#include "nmg.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "../iges/iges.h"
#include "../librt/debug.h"
#include <sys/types.h>
#include <sys/stat.h>

#define	CP_BUF_SIZE	1024	/* size of buffer for file copy */
#define SUFFIX_LEN	10	/* max size of suffix for 'part' files (-m option) */

BU_EXTERN( union tree *do_nmg_region_end , (struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data));
void w_start_global(
	FILE *fp_dir,
	FILE *fp_param,
	const char *db_name,
	const char *prog_name,
	const char *output_file,
	const char *id,
	const char *version);
BU_EXTERN( void w_terminate , (FILE *fp) );
BU_EXTERN( void write_edge_list , (struct nmgregion *r , int vert_de , struct bu_ptbl *etab , struct bu_ptbl *vtab , FILE *fp_dir , FILE *fp_param ) );
BU_EXTERN( void write_vertex_list , ( struct nmgregion *r , struct bu_ptbl *vtab , FILE *fp_dir , FILE *fp_param ) );
BU_EXTERN( void nmg_region_edge_list , ( struct bu_ptbl *tab , struct nmgregion *r ) );
BU_EXTERN( int nmgregion_to_iges , ( char *name , struct nmgregion *r , int dependent , FILE *fp_dir , FILE *fp_param ) );
BU_EXTERN( int write_shell_face_loop , ( struct nmgregion *r , int edge_de , struct bu_ptbl *etab , int vert_de , struct bu_ptbl *vtab , FILE *fp_dir , FILE *fp_param ) );
BU_EXTERN( void csg_comb_func , ( struct db_i *dbip , struct directory *dp , genptr_t ptr ) );
BU_EXTERN( void csg_leaf_func , ( struct db_i *dbip , struct directory *dp , genptr_t ptr ) );
BU_EXTERN( void set_iges_tolerances , ( struct bn_tol *set_tol , struct rt_tess_tol *set_ttol ) );
BU_EXTERN( void count_refs , ( struct db_i *dbip , struct directory *dp , genptr_t ptr ) );
BU_EXTERN( int nmgregion_to_tsurf , ( char *name, struct nmgregion *r, FILE *fp_dir, FILE *fp_param ) );
BU_EXTERN( int write_solid_instance , ( int orig_de, mat_t mat, FILE *fp_dir, FILE *fp_param ) );
BU_EXTERN( void get_props , ( struct iges_properties *props, struct rt_comb_internal *comb ) );
BU_EXTERN( int comb_to_iges , ( struct rt_comb_internal *comb, int length, int dependent, struct iges_properties *props, int de_pointers[], FILE *fp_dir, FILE *fp_param ) );

static char usage[] = "Usage: %s [-f|t|m] [-v] [-s] [-xX lvl] [-a abs_tol] [-r rel_tol] [-n norm_tol] [-d dist_tol] [-o output_file] brlcad_db.g object(s)\n\
	options:\n\
		f - convert each region to facetted BREP before output\n\
		t - produce a file of trimmed surfaces (experimental)\n\
		m - produces a seperate IGES file for each region,\n\
			implies -t, -o gives directory for output IGES file\n\
		s - produce NURBS for faces of any BREP objects\n\
		v - verbose\n\
		a - absolute tolerance for tessellation (mm)\n\
		r - relative tolerance for tessellation\n\
		n - normal tolerance for tessellation\n\
		d - distance tolerance (mm) (minimum distance between distinct points)\n\
		x - librt debug flag\n\
		X - nmg debug flag\n\
		o - file to receive IGES output (or directory when '-m' option is used)\n\
	The f and t options are mutually exclusive. If neither is specified,\n\
	the default output is a CSG file to the maximum extent possible\n";

int		verbose=0;
static char	*db_name;	/* name of the BRL-CAD database */
static char	*prog_name;	/* name of this program as it was invoked */
static int	multi_file=0;	/* Flag to indicate output of seperate IGES file for each region */
static int	NMG_debug;	/* saved arg of -X, for longjmp handling */
static int	scale_error=0;	/* Count indicating how many scaled objects were encountered */
static int	solid_error=0;	/* Count indicating how many solids were not converted */
static int	comb_error=0;	/* Count indicating  how many combinations were not converted */
static int	ncpu = 1;	/* Number of processors */
static char	*output_file = NULL;	/* output filename */
static FILE	*fp_dir;	/* IGES start, global, and directory sections */
static FILE	*fp_param;	/* IGES parameter section */
static struct rt_tess_tol	ttol;
static struct bn_tol		tol;
static struct model		*the_model;
struct db_i		*dbip;

static struct db_tree_state	tree_state;	/* includes tol & model */

/* function table for converting solids to iges */
BU_EXTERN( int null_to_iges , ( struct rt_db_internal *ip , char *name , FILE *fp_dir , FILE *fp_param ));
BU_EXTERN( int arb_to_iges , ( struct rt_db_internal *ip , char *name , FILE *fp_dir , FILE *fp_param ));
BU_EXTERN( int ell_to_iges , ( struct rt_db_internal *ip , char *name , FILE *fp_dir , FILE *fp_param ));
BU_EXTERN( int sph_to_iges , ( struct rt_db_internal *ip , char *name , FILE *fp_dir , FILE *fp_param ));
BU_EXTERN( int tor_to_iges , ( struct rt_db_internal *ip , char *name , FILE *fp_dir , FILE *fp_param ));
BU_EXTERN( int tgc_to_iges , ( struct rt_db_internal *ip , char *name , FILE *fp_dir , FILE *fp_param ));
BU_EXTERN( int nmg_to_iges , ( struct rt_db_internal *ip , char *name , FILE *fp_dir , FILE *fp_param ));
BU_EXTERN( void iges_init , ( struct bn_tol *set_tol, struct rt_tess_tol *set_ttol, int set_verbose, struct db_i *dbip_set ) );
BU_EXTERN( void Print_stats , ( FILE *fp ) );

struct iges_functab
{
	int (*do_iges_write) RT_ARGS(( struct rt_db_internal *ip , char *name , FILE *fp_dir , FILE *fp_param ));
};

struct iges_functab iges_write[ID_MAXIMUM+1]={
	{null_to_iges},	/* ID_NULL */
	{tor_to_iges}, 	/* ID_TOR */
	{tgc_to_iges},	/* ID_TGC */
	{ell_to_iges},	/* ID_ELL */
	{arb_to_iges},	/* ID_ARB8 */
	{nmg_to_iges},	/* ID_ARS */
	{nmg_to_iges},	/* ID_HALF */
	{nmg_to_iges},	/* ID_REC */
	{nmg_to_iges},	/* ID_POLY */
	{nmg_to_iges},	/* ID_BSPLINE */
	{sph_to_iges},	/* ID_SPH */
	{nmg_to_iges},	/* ID_NMG */
	{null_to_iges},	/* ID_EBM */
	{null_to_iges},	/* ID_VOL */
	{nmg_to_iges},	/* ID_ARBN */
	{nmg_to_iges},	/* ID_PIPE */
	{null_to_iges},	/* ID_PARTICLE */
	{null_to_iges},	/* ID_RPC */
	{null_to_iges},	/* ID_RHC */
	{null_to_iges},	/* ID_EPA */
	{null_to_iges},	/* ID_EHY */
	{null_to_iges},	/* ID_ETO */
	{null_to_iges},	/* ID_GRIP */
	{null_to_iges},	/* ID_JOINT */
	{nmg_to_iges},	/* ID_HF */
	{nmg_to_iges},	/* ID_DSP */
	{null_to_iges},	/* ID_SKETCH */
	{nmg_to_iges},	/* ID_EXTRUDE */
	{null_to_iges},	/* ID_SUBMODEL */
	{nmg_to_iges},	/* ID_CLINE */
	{nmg_to_iges}	/* ID_BOT */
};

static int	regions_tried = 0;
static int	regions_done = 0;
int		mode=CSG_MODE;	/* indicates which type of IGES file is desired */
int		solid_is_brep;
int		comb_form;
char		**independent;
int		no_of_indeps=0;
int		do_nurbs=0;

/*
 *			M A I N
 */
int
main(argc, argv)
int	argc;
char	*argv[];
{
	int			i, ret;
	register int		c;
	double			percent;
	char			copy_buffer[CP_BUF_SIZE];
	struct directory	*dp;

	port_setlinebuf( stderr );

	bu_log( "%s", version+5);
	bu_log( "Please direct bug reports to <acst@@arl.army.mil>\n\n" );

	tree_state = rt_initial_tree_state;	/* struct copy */
	tree_state.ts_tol = &tol;
	tree_state.ts_ttol = &ttol;
	tree_state.ts_m = &the_model;

	ttol.magic = RT_TESS_TOL_MAGIC;
	/* Defaults, updated by command line options. */
	ttol.abs = 0.0;
	ttol.rel = 0.01;
	ttol.norm = 0.0;

	/* XXX These need to be improved */
	tol.magic = BN_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;

	the_model = nmg_mm();
	BU_LIST_INIT( &rt_g.rtg_vlfree );	/* for vlist macros */

	rt_init_resource( &rt_uniresource, 0, NULL );

	prog_name = argv[0];

	/* Get command line arguments. */
	while ((c = getopt(argc, argv, "ftsmd:a:n:o:p:r:vx:P:X:")) != EOF) {
		switch (c) {
		case 'f':		/* Select facetized output */
			mode = FACET_MODE;
			multi_file = 0;
			break;
		case 't':
			mode = TRIMMED_SURF_MODE;
			multi_file = 0;
			break;
		case 's':		/* Select NURB output */
			do_nurbs = 1;
			break;
		case 'a':		/* Absolute tolerance. */
			ttol.abs = atof(optarg);
			break;
		case 'n':		/* Surface normal tolerance. */
			ttol.norm = atof(optarg);
			break;
		case 'o':		/* Output file name. */
			output_file = optarg;
			break;
		case 'r':		/* Relative tolerance. */
			ttol.rel = atof(optarg);
			break;
		case 'd':		/* distance tolerance */
			tol.dist = atof( optarg );
			tol.dist_sq = tol.dist * tol.dist;
			break;
		case 'm':		/* multi-file mode */
			multi_file = 1;
			mode = TRIMMED_SURF_MODE;
			break;
		case 'v':
			verbose++;
			break;
		case 'P':
			ncpu = atoi( optarg );
			rt_g.debug = 1;	/* XXX DEBUG_ALLRAYS -- to get core dumps */
			break;
		case 'x':
			sscanf( optarg, "%x", (unsigned int *)&rt_g.debug );
			break;
		case 'X':
			sscanf( optarg, "%x", (unsigned int *)&rt_g.NMG_debug );
			NMG_debug = rt_g.NMG_debug;
			break;
		default:
			bu_log( usage, argv[0]);
			exit(1);
			break;
		}
	}

	if (optind+1 >= argc) {
		bu_log( usage, argv[0]);
		exit(1);
	}

	/* Open brl-cad database */
	argc -= optind;
	argv += optind;
	db_name = argv[0];
	if ((dbip = db_open(db_name, "r")) == DBI_NULL) {
		perror("g-iges");
		exit(1);
	}

	/* Scan the database */
	db_dirbuild( dbip );

	if( !multi_file )
	{
		/* let the IGES routines know the selected tolerances and the database pointer */
		iges_init( &tol , &ttol , verbose , dbip );

		/* Open the output file */
		if( output_file == NULL )
			fp_dir = stdout;
		else {
			if( (fp_dir=fopen( output_file , "w" )) == NULL ) {
				bu_log( "Cannot open output file: %s\n" , output_file );
				perror( output_file );
				exit( 1 );
			}
		}

		/* Open the temporary file for the parameter section */
		if( (fp_param=tmpfile()) == NULL ) {
			bu_log( "Cannot open temporary file\n" );
			perror( "g-iges" );
			exit( 1 );
		}

		/* Write start and global sections of the IGES file */
		w_start_global( fp_dir , fp_param , argv[0] , prog_name , output_file , RCSid , RCSrev );
	}
	else
	{
		struct stat stat_ptr;

		if( stat( output_file, &stat_ptr ) )
		{
			bu_log( "Cannot determine status of %s\n", output_file );
			perror( prog_name );
			exit( 1 );
		}

		if( !(stat_ptr.st_mode & S_IFDIR) )
		{
			bu_log( "-o option must provide a directory, %s is not a directory\n", output_file );
			exit( 1 );
		}
	}

	/* Count object references */
/*	for( i=1 ; i<argc ; i++ )
	{
		dp = db_lookup( dbip , argv[i] , 1 );
		db_functree( dbip , dp , count_refs , 0 , NULL );
	}	*/

	/* tree tops must have independent status, so we need to remember them */
	independent = (argv+1);
	no_of_indeps = argc-1;

	if( mode == FACET_MODE )
	{
		/* Walk indicated tree(s).  Each region will be output
		 * as a single manifold solid BREP object */

		ret = db_walk_tree(dbip, argc-1, (const char **)(argv+1),
			ncpu,
			&tree_state,
			0,			/* take all regions */
			do_nmg_region_end,
			nmg_booltree_leaf_tess,
			(genptr_t)NULL);	/* in librt/nmg_bool.c */

		if( ret )
			rt_bomb( "g-iges: Could not facetize anything!!!" );

		if( !multi_file )
		{
			/* Now walk the same trees again, but only output groups */
			for( i=1 ; i<argc ; i++ )
			{
				char *ptr;

				ptr = strrchr( argv[i], '/' );
				if( ptr != NULL ) {
					ptr++;
				} else {
					ptr = argv[i];
				}
				dp = db_lookup( dbip , ptr , 1 );
				db_functree( dbip , dp , csg_comb_func , 0 , &rt_uniresource , NULL );
			}
		}
	}
	else if( mode == CSG_MODE )
	{
		/* Walk indicated tree(s). Each combination and solid will be output
		 * as a CSG object, unless there is no IGES equivalent (then the
		 * solid will be tessellated and output as a BREP object) */

		for( i=1 ; i<argc ; i++ )
		{
			dp = db_lookup( dbip , argv[i] , 1 );
			db_functree( dbip , dp , csg_comb_func , csg_leaf_func , &rt_uniresource , NULL );
		}
	}
	else if( mode == TRIMMED_SURF_MODE )
	{
		/* Walk the indicated tree(s). Each region is output as a collection
		 * of trimmed NURBS */

		ret = db_walk_tree(dbip, argc-1, (const char **)(argv+1),
			ncpu,
			&tree_state,
			0,			/* take all regions */
			do_nmg_region_end,
			nmg_booltree_leaf_tess,
			(genptr_t)NULL);	/* in librt/nmg_bool.c */

		if( ret )
			rt_bomb( "g-iges: Could not facetize anything!!!" );

	}

	if( !multi_file )
	{
		/* Copy the parameter section from the temporary file to the output file */
		if( (fseek( fp_param , (long) 0 , 0 )) ) {
			bu_log( "Cannot seek to start of temporary file\n" );
			perror( "g-iges" );
			exit( 1 );
		}

		while( (i=fread( copy_buffer , 1 , CP_BUF_SIZE , fp_param )) )
			if( fwrite( copy_buffer , 1 , i , fp_dir ) != i ) {
				bu_log( "Error in copying parameter data to %s\n" , output_file );
				perror( "g-iges" );
				exit( 1 );
			}

		/* Write the terminate section */
		w_terminate( fp_dir );
	}

	/* Print some statistics */
	Print_stats( stdout );

	/* report on the success rate for facetizing regions */
	if( mode == FACET_MODE || mode == TRIMMED_SURF_MODE )
	{
		percent = 0;
		if(regions_tried>0)  percent = ((double)regions_done * 100) / regions_tried;
		bu_log("Tried %d regions, %d converted to nmg's successfully.  %g%%\n",
			regions_tried, regions_done, percent);
	}

	/* re-iterate warnings */
	if( scale_error || solid_error || comb_error )
		bu_log( "WARNING: the IGES file produced has errors:\n" );
	if( scale_error )
		bu_log( "\t%d scaled objects found, written to IGES file without being scaled\n" , scale_error );
	if( solid_error )
		bu_log( "\t%d solids were not converted to IGES format\n" , solid_error );
	if( comb_error )
		bu_log( "\t%d combinations were not converted to IGES format\n" , comb_error );

	return( 0 );
}

/*
*			D O _ N M G _ R E G I O N _ E N D
*
*  Called from db_walk_tree().
*
*  This routine must be prepared to run in parallel.
*/
union tree *
do_nmg_region_end(tsp, pathp, curtree, client_data)
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
{
	union tree		*result;
	struct nmgregion	*r;
	struct bu_list		vhead;
	struct directory	*dp;
	int 			dependent;
	int			i;

	RT_CK_TESS_TOL(tsp->ts_ttol);
	BN_CK_TOL(tsp->ts_tol);
	NMG_CK_MODEL(*tsp->ts_m);

	BU_LIST_INIT(&vhead);

	if (RT_G_DEBUG&DEBUG_TREEWALK || verbose) {
		char	*sofar = db_path_to_string(pathp);
		bu_log("\ndo_nmg_region_end(%d %d%%) %s\n",
			regions_tried,
			regions_tried>0 ? (regions_done * 100) / regions_tried : 0,
			sofar);
		bu_free(sofar, "path string");
	}

	if (curtree->tr_op == OP_NOP)
		return  curtree;

	regions_tried++;
	/* Begin rt_bomb() protection */
	if( BU_SETJUMP )  {
		char *sofar;

		/* Error, bail out */
		BU_UNSETJUMP;		/* Relinquish the protection */

		sofar = db_path_to_string(pathp);
		bu_log( "FAILED: Cannot convert %s!!!\n", sofar );
		bu_free( sofar, "path string" );

		/* Sometimes the NMG library adds debugging bits when
		 * it detects an internal error, before rt_bomb().
		 */
		rt_g.NMG_debug = NMG_debug;	/* restore mode */

		/* Release the tree memory & input regions */
		db_free_tree(curtree, &rt_uniresource);		/* Does an nmg_kr() */

		/* Get rid of (m)any other intermediate structures */
		if( (*tsp->ts_m)->magic != -1L )
			nmg_km(*tsp->ts_m);
	
		/* Now, make a new, clean model structure for next pass. */
		*tsp->ts_m = nmg_mm();
		goto out;
	}
	if( verbose )
		bu_log( "\ndoing boolean tree evaluate...\n" );
	(void)nmg_model_fuse(*tsp->ts_m, tsp->ts_tol);
	result = nmg_booltree_evaluate(curtree, tsp->ts_tol, &rt_uniresource);	/* librt/nmg_bool.c */

	if( result )
		r = result->tr_d.td_r;
	else
		r = (struct nmgregion *)NULL;

	if( verbose )
		bu_log( "\nfinished boolean tree evaluate...\n" );
	BU_UNSETJUMP;		/* Relinquish the protection */
	regions_done++;
	if (r != 0) {

		dp = DB_FULL_PATH_CUR_DIR(pathp);

		if( multi_file )
		{
			/* Open the output file */
			if( output_file == NULL )
				fp_dir = stdout;
			else {
				char *multi_name;
				int len;
				int unique=0;
				struct stat stat_ptr;
				char suffix[SUFFIX_LEN+1];

				/* construct a unique file name */
				len = strlen( output_file ) + strlen( dp->d_namep ) + 6 + SUFFIX_LEN;
				multi_name = bu_malloc( sizeof( char )*len, "multi_name" );
				strcpy( multi_name, output_file );
				strcat( multi_name, "/" );
				strcat( multi_name, dp->d_namep );
				strcat( multi_name, ".igs" );
				strcpy( suffix, "a" );
				suffix[0]--;
				while( !unique )
				{
					int i;

					if( stat( multi_name, &stat_ptr ) )
					{
						unique = 1;
						break;
					}

					/* not unique, try adding a suffix */
					len = strlen( suffix );
					i = len - 1;;
					suffix[i]++;
					while( suffix[i] > 'z' && i > 0 )
					{
						suffix[i] = 'a';
						i--;
						suffix[i]++;
					}

					if( suffix[0] > 'z' && len < SUFFIX_LEN )
					{
						for( i=0 ; i<=len ; i++ )
							suffix[i] = 'a';
					}
					else if( suffix[0] > 'z' && len >= SUFFIX_LEN )
					{
						bu_log( "Cannot create a unique filename,\n" );
						bu_log( "too many files with the same name (%s)\n", dp->d_namep );
						exit( 1 );
					}
					strcpy( multi_name, output_file );
					strcat( multi_name, "/" );
					strcat( multi_name, dp->d_namep );
					strcat( multi_name, suffix );
					strcat( multi_name, ".igs" );
				}
				if( (fp_dir=fopen( multi_name , "w" )) == NULL ) {
					bu_log( "Cannot open output file: %s\n" , multi_name );
					perror( "g-iges" );
					exit( 1 );
				}
			}

			/* Open the temporary file for the parameter section */
			if( (fp_param=tmpfile()) == NULL ) {
				bu_log( "Cannot open temporary file\n" );
				perror( "g-iges" );
				exit( 1 );
			}

			/* let the IGES routines know the selected tolerances and the database pointer */
			iges_init( &tol , &ttol , verbose , dbip );

			/* Write start and global sections of the IGES file */
			w_start_global( fp_dir , fp_param , db_name , prog_name , output_file , RCSid , RCSrev );
		}

		if( mode == FACET_MODE )
		{
			dependent = 1;
			for( i=0 ; i<no_of_indeps ; i++ )
			{
				if( !strncmp( dp->d_namep , independent[i] , NAMESIZE ) )
				{
					dependent = 0;
					break;
				}
			}

			dp->d_uses = (-nmgregion_to_iges( dp->d_namep , r , dependent , fp_dir , fp_param ));
		}
		else if( mode == TRIMMED_SURF_MODE )
			dp->d_uses = (-nmgregion_to_tsurf( dp->d_namep , r , fp_dir , fp_param ));

		/* NMG region is no longer necessary */
		nmg_kr(r);

		if( multi_file )
		{
			char copy_buffer[CP_BUF_SIZE];

			/* Copy the parameter section from the temporary file to the output file */
			if( (fseek( fp_param , (long) 0 , 0 )) ) {
				bu_log( "Cannot seek to start of temporary file\n" );
				perror( "g-iges" );
				exit( 1 );
			}

			while( (i=fread( copy_buffer , 1 , CP_BUF_SIZE , fp_param )) )
				if( fwrite( copy_buffer , 1 , i , fp_dir ) != i ) {
					bu_log( "Error in copying parameter data to %s\n" , output_file );
					perror( "g-iges" );
					exit( 1 );
				}

			/* Write the terminate section */
			w_terminate( fp_dir );
			fclose( fp_dir );
			fclose( fp_param );
		}
	}

	/*
	 *  Dispose of original tree, so that all associated dynamic
	 *  memory is released now, not at the end of all regions.
	 *  A return of TREE_NULL from this routine signals an error,
	 *  so we need to cons up an OP_NOP node to return.
	 */
	db_free_tree(curtree, &rt_uniresource);		/* Does an nmg_kr() */

out:
	BU_GETUNION(curtree, tree);
	curtree->magic = RT_TREE_MAGIC;
	curtree->tr_op = OP_NOP;
	return(curtree);
}

static int de_pointer_number;

int
get_de_pointers( tp, dp, de_len, de_pointers )
union tree *tp;
struct directory *dp;
int de_len;
int *de_pointers;
{
	RT_CK_TREE( tp );
	RT_CK_DIR( dp );

	switch( tp->tr_op )
	{
		case OP_UNION:
		case OP_SUBTRACT:
		case OP_INTERSECT:
			get_de_pointers( tp->tr_b.tb_left, dp, de_len, de_pointers );
			get_de_pointers( tp->tr_b.tb_right, dp, de_len, de_pointers );
			break;
		case OP_DB_LEAF:
		{
			struct directory *dp_M;

			dp_M = db_lookup( dbip , tp->tr_l.tl_name , LOOKUP_NOISY );
			if( dp_M == DIR_NULL )
				return( 1 );

			if( dp_M->d_uses >= 0 )
			{
				bu_log( "g-iges: member (%s) in combination (%s) has not been written to iges file\n" , dp_M->d_namep , dp->d_namep );
				de_pointers[de_pointer_number++] = 0;
				return( 1 );
			}

			if( tp->tr_l.tl_mat && !bn_mat_is_identity( tp->tr_l.tl_mat ) )
			{
				/* write a solid instance entity for this member
					with a pointer to the new matrix */

				if( !NEAR_ZERO( tp->tr_l.tl_mat[15] - 1.0 , tol.dist ) )
				{
					/* scale factor is not 1.0, IGES can't handle it.
					   go ahead and write the solid instance anyway,
					   but warn the user twice */
					bu_log( "g-iges: WARNING!! member (%s) of combination (%s) is scaled, IGES cannot handle this\n" , dp_M->d_namep , dp->d_namep );
					scale_error++;
				}
				de_pointers[de_pointer_number++] = write_solid_instance( -dp_M->d_uses , tp->tr_l.tl_mat , fp_dir , fp_param );
			}
			else
				de_pointers[de_pointer_number++] = (-dp_M->d_uses);
			if( dp_M->d_nref )
				comb_form = 1;
			}
			break;
		default:
			bu_log( "Unrecognized operator in combination!!\n" );
			return( 1 );
	}
	return( 0 );
}

void
csg_comb_func( dbip , dp , ptr )
struct db_i *dbip;
struct directory *dp;
genptr_t	ptr;
{
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;
	struct iges_properties props;
	int comb_len;
	int i;
	int dependent=1;
	int *de_pointers;
	int id;

	/* when this is called in facet mode, we only want groups */
	if( mode == FACET_MODE && (dp->d_flags & DIR_REGION ) )
		return;

	/* check if already written */
	if( dp->d_uses < 0 )
		return;

	for( i=0 ; i<no_of_indeps ; i++ )
	{
		if( !strncmp( dp->d_namep , independent[i] , NAMESIZE ) )
		{
			dependent = 0;
			break;
		}
	}

	id = rt_db_get_internal( &intern, dp, dbip, (matp_t)NULL , &rt_uniresource);
	if( id < 0 )
		return;
	if( id != ID_COMBINATION )
	{
		bu_log( "Directory/Database mismatch!!!! is %s a combination or not????\n", dp->d_namep );
		return;
	}

	comb = (struct rt_comb_internal *)intern.idb_ptr;
	RT_CK_COMB( comb );

	if( verbose )
		bu_log( "Combination - %s\n" , dp->d_namep );

	if( !comb->tree )
	{
		bu_log( "Warning: empty combination (%s)\n" , dp->d_namep );
		dp->d_uses = 0;
		return;
	}
	comb_len = db_tree_nleaves( comb->tree );
	de_pointers = (int *)bu_calloc( comb_len , sizeof( int ) , "csg_comb_func" );

	comb_form = 0;

	de_pointer_number = 0;
	if( get_de_pointers( comb->tree, dp, comb_len, de_pointers ) )
	{
		bu_log( "Error in combination %s\n", dp->d_namep );
	        bu_free( (char *)de_pointers , "csg_comb_func de_pointers" );
		rt_db_free_internal( &intern , &rt_uniresource);
		return;
	}

	strcpy( props.name, dp->d_namep );
	props.material_name[0] = '\0';
	props.material_params[0] = '\0';
	props.region_flag = ' ';
	props.ident = 0;
	props.air_code = 0;
	props.material_code = 0;
	props.los_density = 0;
	props.color[0] = 0;
	props.color[1] = 0;
	props.color[2] = 0;
	get_props( &props , comb );

	dp->d_uses = (-comb_to_iges( comb , comb_len , dependent , &props , de_pointers , fp_dir , fp_param ) );

	if( !dp->d_uses )
	{
		comb_error++;
		bu_log( "g-iges: combination (%s) not written to iges file\n" , dp->d_namep );
	}

	rt_db_free_internal( &intern , &rt_uniresource);
        bu_free( (char *)de_pointers , "csg_comb_func de_pointers" );

}

void
csg_leaf_func( dbip , dp , ptr )
struct db_i *dbip;
struct directory *dp;
genptr_t ptr;
{
	struct rt_db_internal	ip;

	/* if this solid has already been output, don't do it again */
	if( dp->d_uses < 0 )
		return;

	if( verbose )
		bu_log( "solid - %s\n" , dp->d_namep );

	if( rt_db_get_internal( &ip, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
		bu_log( "Error in import" );

	solid_is_brep = 0;
	dp->d_uses = (-iges_write[ip.idb_type].do_iges_write( &ip , dp->d_namep , fp_dir , fp_param ));

	if( !dp->d_uses )
	{
		bu_log( "g-iges: failed to translate %s to IGES format\n" , dp->d_namep );
		solid_error++;
	}

	if( solid_is_brep )
		dp->d_nref = 1;
	else
		dp->d_nref = 0;

	rt_db_free_internal( &ip, &rt_uniresource );
}

void
incr_refs( dbip, comb, tp, user_ptr1, user_ptr2, user_ptr3 )
struct db_i		*dbip;
struct rt_comb_internal	*comb;
union tree		*tp;
genptr_t		user_ptr1,user_ptr2,user_ptr3;
{
	struct directory *dp;

	RT_CK_COMB( comb );
	RT_CK_DBI( dbip );
	RT_CK_TREE( tp );

	if( (dp=db_lookup( dbip, tp->tr_l.tl_name, LOOKUP_NOISY )) == DIR_NULL )
		return;

	dp->d_nref++;
}

void
count_refs( dbip , dp , ptr )
struct db_i *dbip;
struct directory *dp;
genptr_t ptr;
{
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;
	int id;

	if( !(dp->d_flags & DIR_COMB) )
		return;

	id = rt_db_get_internal( &intern, dp, dbip, (matp_t)NULL , &rt_uniresource);
	if( id < 0 )
	{
		bu_log( "Cannot get internal form of %s\n", dp->d_namep );
		return;
	}

	comb = (struct rt_comb_internal *)intern.idb_ptr;
	RT_CK_COMB( comb );

	if( !comb->tree )
	{
		bu_log( "Warning: empty combination (%s)\n" , dp->d_namep );
		dp->d_uses = 0;
		return;
	}

	comb_form = 0;

	db_tree_funcleaf( dbip, comb, comb->tree, incr_refs,
		(genptr_t)NULL, (genptr_t)NULL, (genptr_t)NULL );

}
@


11.29
log
@change conf.h to a wrapped config.h
@
text
@d25 2
a26 2
static const char RCSid[] = "$Header: /cvs/brlcad/iges/g-iges.c,v 11.28 2004/03/03 21:31:47 morrison Exp $";
static const char RCSrev[] = "$Revision: 11.28 $";
@


11.28
log
@the rcs vars are actually used, so not conditional on lint
@
text
@d25 7
a31 2
static const char RCSid[] = "$Header: /c/CVS/brlcad/iges/g-iges.c,v 11.27 2003/04/02 15:31:15 jra Exp $";
static const char RCSrev[] = "$Revision: 11.27 $";
a32 1
#include "conf.h"
@


11.27
log
@Eliominated an unused variable
@
text
@d25 2
a26 4
#ifndef lint
static const char RCSid[] = "$Header: /c/CVS/brlcad/iges/g-iges.c,v 11.26 2003/02/24 14:10:07 jra Exp $";
static const char RCSrev[] = "$Revision: 11.26 $";
#endif
@


11.27.6.1
log
@merge from head
@
text
@d25 4
a28 2
static const char RCSid[] = "$Header: /c/CVS/brlcad/iges/g-iges.c,v 11.28 2004/03/03 21:31:47 morrison Exp $";
static const char RCSrev[] = "$Revision: 11.28 $";
@


11.27.6.2
log
@merge from head
@
text
@d25 2
a26 2
static const char RCSid[] = "$Header: /c/CVS/brlcad/iges/g-iges.c,v 11.27.6.1 2004/03/10 13:19:44 erikg Exp $";
static const char RCSrev[] = "$Revision: 11.27.6.1 $";
@


11.26
log
@Now handles paths passed to it on command line
@
text
@d26 2
a27 2
static const char RCSid[] = "$Header: /c/CVS/brlcad/iges/g-iges.c,v 11.25 2001/08/08 20:25:12 jra Exp $";
static const char RCSrev[] = "$Revision: 11.25 $";
a114 1
static mat_t			identity_mat;
a195 2

	MAT_IDN( identity_mat );
@


11.25
log
@Lint
@
text
@d26 2
a27 2
static const char RCSid[] = "$Header: /c/CVS/brlcad/iges/g-iges.c,v 11.24 2001/05/17 20:05:03 morrison Exp $";
static const char RCSrev[] = "$Revision: 11.24 $";
d373 9
a381 1
				dp = db_lookup( dbip , argv[i] , 1 );
@


11.25.4.1
log
@sync branch with HEAD
@
text
@d25 4
a28 2
static const char RCSid[] = "$Header$";
static const char RCSrev[] = "$Revision$";
d115 1
d198 2
d373 1
a373 9
				char *ptr;

				ptr = strrchr( argv[i], '/' );
				if( ptr != NULL ) {
					ptr++;
				} else {
					ptr = argv[i];
				}
				dp = db_lookup( dbip , ptr , 1 );
@


11.25.6.1
log
@sync to HEAD...
@
text
@d25 4
a28 2
static const char RCSid[] = "$Header: /n/cad/c/CVS/brlcad/iges/g-iges.c,v 11.28 2004/03/03 21:31:47 morrison Exp $";
static const char RCSrev[] = "$Revision: 11.28 $";
d115 1
d198 2
d373 1
a373 9
				char *ptr;

				ptr = strrchr( argv[i], '/' );
				if( ptr != NULL ) {
					ptr++;
				} else {
					ptr = argv[i];
				}
				dp = db_lookup( dbip , ptr , 1 );
@


11.24
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d26 2
a27 2
static const char RCSid[] = "$Header: /c/CVS/brlcad/iges/g-iges.c,v 11.23 2001/04/05 19:35:18 morrison Exp $";
static const char RCSrev[] = "$Revision: 11.23 $";
d267 1
a267 1
			sscanf( optarg, "%x", &rt_g.debug );
d270 1
a270 1
			sscanf( optarg, "%x", &rt_g.NMG_debug );
@


11.23
log
@updated SIGNED to signed
updated CONST to const
@
text
@d26 2
a27 2
static const char RCSid[] = "$Header: /c/CVS/brlcad/iges/g-iges.c,v 11.22 2001/03/31 01:56:39 morrison Exp $";
static const char RCSrev[] = "$Revision: 11.22 $";
d480 1
a480 1
	if (rt_g.debug&DEBUG_TREEWALK || verbose) {
@


11.22
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d26 2
a27 2
static const char RCSid[] = "$Header: /c/CVS/brlcad/iges/g-iges.c,v 11.21 2001/03/29 21:37:46 jra Exp $";
static const char RCSrev[] = "$Revision: 11.21 $";
d357 1
a357 1
		ret = db_walk_tree(dbip, argc-1, (CONST char **)(argv+1),
d395 1
a395 1
		ret = db_walk_tree(dbip, argc-1, (CONST char **)(argv+1),
@


11.21
log
@Now prints a message when it fails to convert a region.
@
text
@d26 2
a27 2
static const char RCSid[] = "$Header: /c/CVS/brlcad/iges/g-iges.c,v 11.20 2001/02/06 15:13:42 jra Exp $";
static const char RCSrev[] = "$Revision: 11.20 $";
d198 1
a198 1
	bn_mat_idn( identity_mat );
@


11.20
log
@Mods to get IGES working with new database format (v5)
@
text
@d26 2
a27 2
static const char RCSid[] = "$Header: /c/CVS/brlcad/iges/g-iges.c,v 11.19 2000/10/27 20:31:21 jra Exp $";
static const char RCSrev[] = "$Revision: 11.19 $";
d495 2
d499 4
@


11.19
log
@Added newer solids
@
text
@d26 2
a27 2
static const char RCSid[] = "$Header: /c/CVS/brlcad/iges/g-iges.c,v 11.18 2000/10/20 20:29:54 jra Exp $";
static const char RCSrev[] = "$Revision: 11.18 $";
d77 4
d128 2
d137 31
a167 31
	null_to_iges,	/* ID_NULL */
	tor_to_iges, 	/* ID_TOR */
	tgc_to_iges,	/* ID_TGC */
	ell_to_iges,	/* ID_ELL */
	arb_to_iges,	/* ID_ARB8 */
	nmg_to_iges,	/* ID_ARS */
	nmg_to_iges,	/* ID_HALF */
	nmg_to_iges,	/* ID_REC */
	nmg_to_iges,	/* ID_POLY */
	nmg_to_iges,	/* ID_BSPLINE */
	sph_to_iges,	/* ID_SPH */
	nmg_to_iges,	/* ID_NMG */
	null_to_iges,	/* ID_EBM */
	null_to_iges,	/* ID_VOL */
	nmg_to_iges,	/* ID_ARBN */
	nmg_to_iges,	/* ID_PIPE */
	null_to_iges,	/* ID_PARTICLE */
	null_to_iges,	/* ID_RPC */
	null_to_iges,	/* ID_RHC */
	null_to_iges,	/* ID_EPA */
	null_to_iges,	/* ID_EHY */
	null_to_iges,	/* ID_ETO */
	null_to_iges,	/* ID_GRIP */
	null_to_iges,	/* ID_JOINT */
	nmg_to_iges,	/* ID_HF */
	nmg_to_iges,	/* ID_DSP */
	null_to_iges,	/* ID_SKETCH */
	nmg_to_iges,	/* ID_EXTRUDE */
	null_to_iges,	/* ID_SUBMODEL */
	nmg_to_iges,	/* ID_CLINE */
	nmg_to_iges	/* ID_BOT */
d449 2
a833 1
	struct bu_external	ep;
a834 1
	int			id;
a841 2
	if( db_get_external( &ep , dp , dbip ) )
		bu_log( "Error return from db_get_external for %s\n" , dp->d_namep );
d843 1
a843 3
	id = rt_id_solid( &ep );

	if( rt_functab[id].ft_import( &ip , &ep , identity_mat, dbip, &rt_uniresource ) )
d847 1
a847 1
	dp->d_uses = (-iges_write[id].do_iges_write( &ip , dp->d_namep , fp_dir , fp_param ));
d859 2
@


11.18
log
@Added resource struct pointers to db_functree() calls
@
text
@d26 2
a27 2
static const char RCSid[] = "$Header: /c/CVS/brlcad/iges/g-iges.c,v 11.17 2000/09/08 05:56:37 mike Exp $";
static const char RCSrev[] = "$Revision: 11.17 $";
d149 1
d153 9
@


11.17
log
@
Tree routines need resource pointer.
@
text
@d26 2
a27 2
static const char RCSid[] = "$Header: /c/CVS/brlcad/iges/g-iges.c,v 11.16 2000/08/24 04:59:41 mike Exp $";
static const char RCSrev[] = "$Revision: 11.16 $";
d358 1
a358 1
				db_functree( dbip , dp , csg_comb_func , 0 , NULL );
d371 1
a371 1
			db_functree( dbip , dp , csg_comb_func , csg_leaf_func , NULL );
@


11.16
log
@
lint.
@
text
@d26 2
a27 2
static const char RCSid[] = "$Header: /c/CVS/brlcad/iges/g-iges.c,v 11.15 2000/08/24 04:10:47 mike Exp $";
static const char RCSrev[] = "$Revision: 11.15 $";
d180 1
a180 1
	bu_log( "Please direct bug reports to <jra@@brl.mil>\n\n" );
d205 2
d486 1
a486 1
		db_free_tree(curtree);		/* Does an nmg_kr() */
d499 1
a499 1
	result = nmg_booltree_evaluate(curtree, tsp->ts_tol);	/* librt/nmg_bool.c */
d645 1
a645 1
	db_free_tree(curtree);		/* Does an nmg_kr() */
d749 1
a749 1
	id = rt_db_get_internal( &intern, dp, dbip, (matp_t)NULL );
d780 1
a780 1
		rt_db_free_internal( &intern );
d805 1
a805 1
	rt_db_free_internal( &intern );
d831 1
a831 1
	if( rt_functab[id].ft_import( &ip , &ep , identity_mat, dbip ) )
d881 1
a881 1
	id = rt_db_get_internal( &intern, dp, dbip, (matp_t)NULL );
@


11.15
log
@
mk_addmember
RCSid
@
text
@d26 2
a27 2
static const char RCSid[] = "$Header: /c/CVS/brlcad/iges/g-iges.c,v 11.14 2000/08/01 12:51:45 jra Exp $";
static const char RCSrev[] = "$Revision: 11.14 $";
d59 8
a66 1
BU_EXTERN( void w_start_global , (FILE *fp_dir , FILE *fp_param , char *db_name , char *prog_name , char *output_file , char *id , char *version ));
@


11.14
log
@Switched to using db_dirbuild() rather than db_scan()
@
text
@d26 2
a27 2
static char RCSid[] = "$Header: /c/CVS/brlcad/iges/g-iges.c,v 11.13 2000/03/29 18:42:44 mike Exp $";
static char RCSrev[] = "$Revision: 11.13 $";
@


11.13
log
@
Converted from Release 4 names to know about libbu and libbn
@
text
@d26 2
a27 2
static char RCSid[] = "$Header: /c/CVS/brlcad/iges/g-iges.c,v 11.12 2000/01/05 14:16:08 jra Exp $";
static char RCSrev[] = "$Revision: 11.12 $";
d270 1
a270 1
	db_scan(dbip, (int (*)())db_diradd, 1, NULL);
@


11.13.2.1
log
@Added newer solids
@
text
@d26 2
a27 2
static char RCSid[] = "$Header: /c/CVS/brlcad/iges/g-iges.c,v 11.13 2000/03/29 18:42:44 mike Exp $";
static char RCSrev[] = "$Revision: 11.13 $";
a141 1
	null_to_iges,	/* ID_RHC */
a144 9
	null_to_iges,	/* ID_GRIP */
	null_to_iges,	/* ID_JOINT */
	nmg_to_iges,	/* ID_HF */
	nmg_to_iges,	/* ID_DSP */
	null_to_iges,	/* ID_SKETCH */
	nmg_to_iges,	/* ID_EXTRUDE */
	null_to_iges,	/* ID_SUBMODEL */
	nmg_to_iges,	/* ID_CLINE */
	nmg_to_iges	/* ID_BOT */
@


11.13.2.2
log
@Now prints a message when it fails to convert a region.
@
text
@d26 2
a27 2
static char RCSid[] = "$Header: /c/CVS/brlcad/iges/g-iges.c,v 11.13.2.1 2000/10/27 20:27:45 jra Exp $";
static char RCSrev[] = "$Revision: 11.13.2.1 $";
a477 2
		char	*sofar;

a479 4

		sofar = db_path_to_string(pathp);
		bu_log( "FAILED: Cannot convert %s!!!\n", sofar );
		bu_free( sofar, "path string" );
@


11.12
log
@Eliminated some unused variables
@
text
@d26 2
a27 2
static char RCSid[] = "$Header: /c/CVS/brlcad/iges/g-iges.c,v 11.11 2000/01/04 17:58:20 bparker Exp $";
static char RCSrev[] = "$Revision: 11.11 $";
d58 12
a69 12
RT_EXTERN( union tree *do_nmg_region_end , (struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data));
RT_EXTERN( void w_start_global , (FILE *fp_dir , FILE *fp_param , char *db_name , char *prog_name , char *output_file , char *id , char *version ));
RT_EXTERN( void w_terminate , (FILE *fp) );
RT_EXTERN( void write_edge_list , (struct nmgregion *r , int vert_de , struct nmg_ptbl *etab , struct nmg_ptbl *vtab , FILE *fp_dir , FILE *fp_param ) );
RT_EXTERN( void write_vertex_list , ( struct nmgregion *r , struct nmg_ptbl *vtab , FILE *fp_dir , FILE *fp_param ) );
RT_EXTERN( void nmg_region_edge_list , ( struct nmg_ptbl *tab , struct nmgregion *r ) );
RT_EXTERN( int nmgregion_to_iges , ( char *name , struct nmgregion *r , int dependent , FILE *fp_dir , FILE *fp_param ) );
RT_EXTERN( int write_shell_face_loop , ( struct nmgregion *r , int edge_de , struct nmg_ptbl *etab , int vert_de , struct nmg_ptbl *vtab , FILE *fp_dir , FILE *fp_param ) );
RT_EXTERN( void csg_comb_func , ( struct db_i *dbip , struct directory *dp , genptr_t ptr ) );
RT_EXTERN( void csg_leaf_func , ( struct db_i *dbip , struct directory *dp , genptr_t ptr ) );
RT_EXTERN( void set_iges_tolerances , ( struct rt_tol *set_tol , struct rt_tess_tol *set_ttol ) );
RT_EXTERN( void count_refs , ( struct db_i *dbip , struct directory *dp , genptr_t ptr ) );
d102 1
a102 1
static struct rt_tol		tol;
d110 7
a116 7
RT_EXTERN( int null_to_iges , ( struct rt_db_internal *ip , char *name , FILE *fp_dir , FILE *fp_param ));
RT_EXTERN( int arb_to_iges , ( struct rt_db_internal *ip , char *name , FILE *fp_dir , FILE *fp_param ));
RT_EXTERN( int ell_to_iges , ( struct rt_db_internal *ip , char *name , FILE *fp_dir , FILE *fp_param ));
RT_EXTERN( int sph_to_iges , ( struct rt_db_internal *ip , char *name , FILE *fp_dir , FILE *fp_param ));
RT_EXTERN( int tor_to_iges , ( struct rt_db_internal *ip , char *name , FILE *fp_dir , FILE *fp_param ));
RT_EXTERN( int tgc_to_iges , ( struct rt_db_internal *ip , char *name , FILE *fp_dir , FILE *fp_param ));
RT_EXTERN( int nmg_to_iges , ( struct rt_db_internal *ip , char *name , FILE *fp_dir , FILE *fp_param ));
d172 2
a173 2
	rt_log( "%s", version+5);
	rt_log( "Please direct bug reports to <jra@@brl.mil>\n\n" );
d175 1
a175 1
	mat_idn( identity_mat );
d189 1
a189 1
	tol.magic = RT_TOL_MAGIC;
d196 1
a196 1
	RT_LIST_INIT( &rt_g.rtg_vlfree );	/* for vlist macros */
d249 1
a249 1
			rt_log( usage, argv[0]);
d256 1
a256 1
		rt_log( usage, argv[0]);
d282 1
a282 1
				rt_log( "Cannot open output file: %s\n" , output_file );
d290 1
a290 1
			rt_log( "Cannot open temporary file\n" );
d304 1
a304 1
			rt_log( "Cannot determine status of %s\n", output_file );
d311 1
a311 1
			rt_log( "-o option must provide a directory, %s is not a directory\n", output_file );
d387 1
a387 1
			rt_log( "Cannot seek to start of temporary file\n" );
d394 1
a394 1
				rt_log( "Error in copying parameter data to %s\n" , output_file );
d411 1
a411 1
		rt_log("Tried %d regions, %d converted to nmg's successfully.  %g%%\n",
d417 1
a417 1
		rt_log( "WARNING: the IGES file produced has errors:\n" );
d419 1
a419 1
		rt_log( "\t%d scaled objects found, written to IGES file without being scaled\n" , scale_error );
d421 1
a421 1
		rt_log( "\t%d solids were not converted to IGES format\n" , solid_error );
d423 1
a423 1
		rt_log( "\t%d combinations were not converted to IGES format\n" , comb_error );
d442 1
a442 1
	struct rt_list		vhead;
d448 1
a448 1
	RT_CK_TOL(tsp->ts_tol);
d451 1
a451 1
	RT_LIST_INIT(&vhead);
d455 1
a455 1
		rt_log("\ndo_nmg_region_end(%d %d%%) %s\n",
d459 1
a459 1
		rt_free(sofar, "path string");
d467 1
a467 1
	if( RT_SETJUMP )  {
d469 1
a469 1
		RT_UNSETJUMP;		/* Relinquish the protection */
d488 1
a488 1
		rt_log( "\ndoing boolean tree evaluate...\n" );
d498 2
a499 2
		rt_log( "\nfinished boolean tree evaluate...\n" );
	RT_UNSETJUMP;		/* Relinquish the protection */
d519 1
a519 1
				multi_name = rt_malloc( sizeof( char )*len, "multi_name" );
d554 2
a555 2
						rt_log( "Cannot create a unique filename,\n" );
						rt_log( "too many files with the same name (%s)\n", dp->d_namep );
d565 1
a565 1
					rt_log( "Cannot open output file: %s\n" , multi_name );
d573 1
a573 1
				rt_log( "Cannot open temporary file\n" );
d611 1
a611 1
				rt_log( "Cannot seek to start of temporary file\n" );
d618 1
a618 1
					rt_log( "Error in copying parameter data to %s\n" , output_file );
d639 1
a639 1
	GETUNION(curtree, tree);
d675 1
a675 1
				rt_log( "g-iges: member (%s) in combination (%s) has not been written to iges file\n" , dp_M->d_namep , dp->d_namep );
d690 1
a690 1
					rt_log( "g-iges: WARNING!! member (%s) of combination (%s) is scaled, IGES cannot handle this\n" , dp_M->d_namep , dp->d_namep );
d753 1
a753 1
		rt_log( "Combination - %s\n" , dp->d_namep );
d757 1
a757 1
		rt_log( "Warning: empty combination (%s)\n" , dp->d_namep );
d762 1
a762 1
	de_pointers = (int *)rt_calloc( comb_len , sizeof( int ) , "csg_comb_func" );
d770 1
a770 1
	        rt_free( (char *)de_pointers , "csg_comb_func de_pointers" );
d793 1
a793 1
		rt_log( "g-iges: combination (%s) not written to iges file\n" , dp->d_namep );
d797 1
a797 1
        rt_free( (char *)de_pointers , "csg_comb_func de_pointers" );
d807 1
a807 1
	struct rt_external	ep;
d816 1
a816 1
		rt_log( "solid - %s\n" , dp->d_namep );
d818 1
a818 1
		rt_log( "Error return from db_get_external for %s\n" , dp->d_namep );
d823 1
a823 1
		rt_log( "Error in import" );
d830 1
a830 1
		rt_log( "g-iges: failed to translate %s to IGES format\n" , dp->d_namep );
d884 1
a884 1
		rt_log( "Warning: empty combination (%s)\n" , dp->d_namep );
@


11.11
log
@*- add client_data to db_walk_tree
@
text
@d26 2
a27 2
static char RCSid[] = "$Header: /c/CVS/brlcad/iges/g-iges.c,v 11.10 1999/12/29 23:23:29 mike Exp $";
static char RCSrev[] = "$Revision: 11.10 $";
a715 1
	struct directory *dp_M;
@


11.10
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d26 2
a27 2
static char RCSid[] = "$Header: /c/CVS/brlcad/iges/g-iges.c,v 11.9 1999/12/29 21:09:37 mike Exp $";
static char RCSrev[] = "$Revision: 11.9 $";
d58 1
a58 1
RT_EXTERN( union tree *do_nmg_region_end , (struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree));
d337 2
a338 1
			nmg_booltree_leaf_tess);	/* in librt/nmg_bool.c */
d375 2
a376 1
			nmg_booltree_leaf_tess);	/* in librt/nmg_bool.c */
d434 1
a434 1
do_nmg_region_end(tsp, pathp, curtree)
d438 1
@


11.9
log
@Added client_data pointer to db_functree() to eliminate use of
global variables.
@
text
@d26 2
a27 2
static char RCSid[] = "$Header: /c/CVS/brlcad/iges/g-iges.c,v 11.8 1999/10/04 18:39:09 jra Exp $";
static char RCSrev[] = "$Revision: 11.8 $";
d270 1
a270 1
	db_scan(dbip, (int (*)())db_diradd, 1);
@


11.8
log
@Y2K update
@
text
@d26 2
a27 2
static char RCSid[] = "$Header: /c/CVS/brlcad/iges/g-iges.c,v 11.7 1998/05/29 14:29:03 jra Exp $";
static char RCSrev[] = "$Revision: 11.7 $";
d66 2
a67 2
RT_EXTERN( void csg_comb_func , ( struct db_i *dbip , struct directory *dp ) );
RT_EXTERN( void csg_leaf_func , ( struct db_i *dbip , struct directory *dp ) );
d69 1
a69 1
RT_EXTERN( void count_refs , ( struct db_i *dbip , struct directory *dp ) );
d320 1
a320 1
		db_functree( dbip , dp , count_refs , 0 );
d333 1
a333 1
			1,			/* ncpu */
d348 1
a348 1
				db_functree( dbip , dp , csg_comb_func , 0 );
d361 1
a361 1
			db_functree( dbip , dp , csg_comb_func , csg_leaf_func );
d370 1
a370 1
			1,			/* ncpu */
d706 1
a706 1
csg_comb_func( dbip , dp )
d709 1
d800 1
a800 1
csg_leaf_func( dbip , dp )
d803 1
d858 1
a858 1
count_refs( dbip , dp )
d861 1
@


11.7
log
@Updated call to ft_import.
@
text
@d26 2
a27 2
static char RCSid[] = "$Header: /m/cad/iges/RCS/g-iges.c,v 11.6 1997/03/06 20:24:39 jra Exp jra $";
static char RCSrev[] = "$Revision: 11.6 $";
d677 1
a677 1
			if( !bn_mat_is_identity( tp->tr_l.tl_mat ) )
@


11.6
log
@Converted to use combination import/export.
@
text
@d26 2
a27 2
static char RCSid[] = "$Header: /m/cad/iges/RCS/g-iges.c,v 11.5 1997/01/08 15:06:53 jra Exp jra $";
static char RCSrev[] = "$Revision: 11.5 $";
d818 1
a818 1
	if( rt_functab[id].ft_import( &ip , &ep , identity_mat ) )
@


11.5
log
@Added distance tolerance and multi-file mode.
@
text
@d26 2
a27 2
static char RCSid[] = "$Header: /m/cad/iges/RCS/g-iges.c,v 11.4 1995/12/06 13:25:06 jra Exp $";
static char RCSrev[] = "$Revision: 11.4 $";
a42 1
#include "db.h"
d642 63
d710 2
a711 1
	union record *rp;
d718 1
d737 11
a747 2
	if( (rp = db_getmrec( dbip, dp )) == (union record *)0 )
                return;
d752 1
a752 2
	comb_len = dp->d_len - 1;
	if( comb_len == 0 )
d758 1
d763 2
a764 1
	for( i=1 ; i<dp->d_len ; i++ )
d766 4
a769 30
		dp_M = db_lookup( dbip , rp[i].M.m_instname , 1 );
		if( dp_M == DIR_NULL )
			continue;

		if( dp_M->d_uses >= 0 )
		{
			rt_log( "g-iges: member (%s) in combination (%s) has not been written to iges file\n" , dp_M->d_namep , dp->d_namep );
			de_pointers[i-1] = 0;
			continue;
		}

		if( !matrix_is_identity( rp[i].M.m_mat ) )
		{
			/* write a solid instance entity for this member
				with a pointer to the new matrix */

			if( !NEAR_ZERO( rp[i].M.m_mat[15] - 1.0 , tol.dist ) )
			{
				/* scale factor is not 1.0, IGES can't handle it.
				   go ahead and write the solid instance anyway,
				   but warn the user twice */
				rt_log( "g-iges: WARNING!! member (%s) of combination (%s) is scaled, IGES cannot handle this\n" , rp[i].M.m_instname , rp[0].c.c_name );
				scale_error++;
			}
			de_pointers[i-1] = write_solid_instance( -dp_M->d_uses , rp[i].M.m_mat , fp_dir , fp_param );
		}
		else
			de_pointers[i-1] = (-dp_M->d_uses);
		if( dp_M->d_nref )
			comb_form = 1;
d772 12
a783 1
	get_props( &props , rp );
d785 1
a785 1
	dp->d_uses = (-comb_to_iges( rp , comb_len , dependent , &props , de_pointers , fp_dir , fp_param ) );
d793 1
a793 1
        rt_free( (char *)rp , "csg_comb_func record[]" );
d837 19
d860 13
a872 4
	union record *rp;
	struct directory *dp_M;
	int comb_len;
	int i;
d874 2
a875 2
	if( (rp = db_getmrec( dbip, dp )) == (union record *)0 )
                return;
d877 1
a877 2
	comb_len = dp->d_len - 1;
	if( comb_len == 0 )
d886 2
a887 5
	for( i=1 ; i<dp->d_len ; i++ )
	{
		dp_M = db_lookup( dbip , rp[i].M.m_instname , 1 );
		if( dp_M == DIR_NULL )
			continue;
a888 2
		dp_M->d_nref++;
	}
@


11.4
log
@All logging done via rt_log
@
text
@d26 2
a27 2
static char RCSid[] = "$Header: /m/cad/iges/RCS/g-iges.c,v 11.3 1995/03/07 16:28:46 jra Exp jra $";
static char RCSrev[] = "$Revision: 11.3 $";
d53 2
d57 1
d72 1
a72 1
static char usage[] = "Usage: %s [-f|t] [-v] [-s] [-xX lvl] [-a abs_tol] [-r rel_tol] [-n norm_tol] [-o output_file] brlcad_db.g object(s)\n\
d76 2
d80 1
a80 1
		a - absolute tolerance for tessellation\n\
d83 1
d86 1
a86 1
		o - file to receive IGES output\n\
d91 3
a167 1
	char			*prog_name;
d202 1
a202 1
	while ((c = getopt(argc, argv, "ftsa:n:o:p:r:vx:P:X:")) != EOF) {
d206 1
d210 1
d227 8
d264 2
a265 1
	if ((dbip = db_open(argv[0], "r")) == DBI_NULL) {
d270 22
a291 6
	/* Open the output file */
	if( output_file == NULL )
		fp_dir = stdout;
	else {
		if( (fp_dir=fopen( output_file , "w" )) == NULL ) {
			rt_log( "Cannot open output file: %s\n" , output_file );
a294 1
	}
d296 2
a297 5
	/* Open the temporary file for the parameter section */
	if( (fp_param=tmpfile()) == NULL ) {
		rt_log( "Cannot open temporary file\n" );
		perror( "g-iges" );
		exit( 1 );
d299 3
d303 6
a308 2
	/* Scan the database */
	db_scan(dbip, (int (*)())db_diradd, 1);
d310 6
a315 5
	/* let the IGES routines know the selected tolerances and the database pointer */
	iges_init( &tol , &ttol , verbose , dbip );

	/* Write start and global sections of the IGES file */
	w_start_global( fp_dir , fp_param , argv[0] , prog_name , output_file , RCSid , RCSrev );
d343 1
a343 2
		/* Now walk the same trees again, but only output groups */
		for( i=1 ; i<argc ; i++ )
d345 6
a350 2
			dp = db_lookup( dbip , argv[i] , 1 );
			db_functree( dbip , dp , csg_comb_func , 0 );
d382 5
a386 10
	/* Copy the parameter section from the temporary file to the output file */
	if( (fseek( fp_param , (long) 0 , 0 )) ) {
		rt_log( "Cannot seek to start of temporary file\n" );
		perror( "g-iges" );
		exit( 1 );
	}

	while( (i=fread( copy_buffer , 1 , CP_BUF_SIZE , fp_param )) )
		if( fwrite( copy_buffer , 1 , i , fp_dir ) != i ) {
			rt_log( "Error in copying parameter data to %s\n" , output_file );
d391 10
a400 2
	/* Write the terminate section */
	w_terminate( fp_dir );
d503 80
d602 24
@


11.3
log
@Mod to account for new return of nmg_booltree_evaluate().
@
text
@d26 2
a27 2
static char RCSid[] = "$Header: /m/cad/iges/RCS/g-iges.c,v 11.2 1995/02/22 05:36:01 mike Exp $";
static char RCSrev[] = "$Revision: 11.2 $";
d165 2
a166 2
	printf( "%s", version+5);
	printf( "Please direct bug reports to <jra@@brl.mil>\n\n" );
d232 1
a232 1
			fprintf(stderr, usage, argv[0]);
d239 1
a239 1
		fprintf(stderr, usage, argv[0]);
d256 1
a256 1
			fprintf( stderr , "Cannot open output file: %s\n" , output_file );
d264 1
a264 1
		fprintf( stderr , "Cannot open temporary file\n" );
d342 1
a342 1
		fprintf( stderr , "Cannot seek to start of temporary file\n" );
d349 1
a349 1
			fprintf( stderr , "Error in copying parameter data to %s\n" , output_file );
d365 1
a365 1
		printf("Tried %d regions, %d converted to nmg's successfully.  %g%%\n",
d371 1
a371 1
		fprintf( stderr , "WARNING: the IGES file produced has errors:\n" );
d373 1
a373 1
		fprintf( stderr , "\t%d scaled objects found, written to IGES file without being scaled\n" , scale_error );
d375 1
a375 1
		fprintf( stderr , "\t%d solids were not converted to IGES format\n" , solid_error );
d377 1
a377 1
		fprintf( stderr , "\t%d combinations were not converted to IGES format\n" , comb_error );
d582 1
a582 1
		fprintf( stderr , "g-iges: combination (%s) not written to iges file\n" , dp->d_namep );
@


11.2
log
@nmg_model_fuse() is still accounting for 25% of the runtime.  In order
to correct this, it is necessary for me to make calling nmg_model_fuse()
a pre-condition of calling nmg_booltree_evaluate().  That way it's done
exactly once per region.
@
text
@d26 2
a27 2
static char RCSid[] = "$Header: /m/cad/iges/RCS/g-iges.c,v 11.1 1995/01/04 10:07:43 mike Rel4_4 mike $";
static char RCSrev[] = "$Revision: 11.1 $";
d393 1
d443 7
a449 1
	r = nmg_booltree_evaluate(curtree, tsp->ts_tol);	/* librt/nmg_bool.c */
@


11.1
log
@Release_4.4
@
text
@d26 2
a27 2
static char RCSid[] = "$Header: /m/cad/iges/RCS/g-iges.c,v 1.13 94/12/08 17:37:22 jra Exp $";
static char RCSrev[] = "$Revision: 1.13 $";
d441 1
@


1.13
log
@Mod for CRAY2
@
text
@d26 2
a27 2
static char RCSid[] = "$Header: /n/wolf/m/cad/iges/RCS/g-iges.c,v 1.12 94/11/08 14:50:05 jra Exp Locker: jra $";
static char RCSrev[] = "$Revision: 1.12 $";
@


1.12
log
@Mods for Irix 6.
@
text
@d26 2
a27 2
static char RCSid[] = "$Header: /n/wolf/m/cad/iges/RCS/g-iges.c,v 1.11 1994/11/03 10:50:26 jra Exp jra $";
static char RCSrev[] = "$Revision: 1.11 $";
d419 1
a419 1
	if( ncpu == 1 && RT_SETJUMP )  {
@


1.11
log
@Updated usage message and removed -c option.
@
text
@d26 2
a27 2
static char RCSid[] = "$Header: /m/cad/iges/RCS/g-iges.c,v 1.10 94/09/26 15:40:37 jra Exp Locker: jra $";
static char RCSrev[] = "$Revision: 1.10 $";
d84 1
a85 1
static int	verbose=0;
a89 4
static int	dir_seq=0;	/* IGES file directory section sequence number */
static int	param_seq=0;	/* IGES file parameter section sequence number */
static int	vert_de;	/* IGES file directory entry for the vertex list */
static int	edge_de;	/* IGES file directory entry for the edge list */
a588 1
	struct rt_arb_internal	*arb;
a626 1
	struct iges_properties props;
@


1.10
log
@Added -t option for trimmed surface mode.
@
text
@d26 2
a27 2
static char RCSid[] = "$Header: /m/cad/iges/RCS/g-iges.c,v 1.9 94/09/26 11:09:50 jra Exp Locker: jra $";
static char RCSrev[] = "$Revision: 1.9 $";
d69 1
a69 1
static char usage[] = "Usage: %s [-f|c|t] [-v] [-s] [-xX lvl] [-a abs_tol] [-r rel_tol] [-n norm_tol] [-o output_file] brlcad_db.g object(s)\n\
d72 1
a72 2
		c - produce a CSG file to the maximum extent possible\n\
		t - produce a file of trimmed surfaces\n\
d80 3
a82 1
		o - file to receive IGES output\n";
d198 1
a198 1
	while ((c = getopt(argc, argv, "fctsa:n:o:p:r:vx:P:X:")) != EOF) {
a201 3
			break;
		case 'c':		/* Select CSG output */
			mode = CSG_MODE;
@


1.9
log
@Added curtree->magic = RT_TREE_MAGIC to do_nmg_region_end.
@
text
@d26 2
a27 2
static char RCSid[] = "$Header: /m/cad/iges/RCS/g-iges.c,v 1.8 94/08/26 13:48:49 jra Exp $";
static char RCSrev[] = "$Revision: 1.8 $";
d69 1
a69 1
static char usage[] = "Usage: %s [-f|c] [-v] [-s] [-xX lvl] [-a abs_tol] [-r rel_tol] [-n norm_tol] [-o output_file] brlcad_db.g object(s)\n\
d73 1
d197 1
a197 1
	while ((c = getopt(argc, argv, "fcsa:n:o:p:r:vx:P:X:")) != EOF) {
d205 3
d329 4
d334 12
d367 1
a367 1
	if( mode == FACET_MODE )
d456 1
a456 2
		dependent = 1;
		for( i=0 ; i<no_of_indeps ; i++ )
d458 2
a459 1
			if( !strncmp( dp->d_namep , independent[i] , NAMESIZE ) )
d461 5
a465 2
				dependent = 0;
				break;
d467 2
d470 2
a471 2

		dp->d_uses = (-nmgregion_to_iges( dp->d_namep , r , dependent , fp_dir , fp_param ));
@


1.8
log
@Changed include to reflect dir name change to iges.
@
text
@d26 2
a27 2
static char RCSid[] = "$Header: /m/cad/iges/RCS/g-iges.c,v 1.7 94/08/26 10:40:36 jra Exp Locker: jra $";
static char RCSrev[] = "$Revision: 1.7 $";
d462 1
@


1.7
log
@Cleanup.
@
text
@d26 2
a27 2
static char RCSid[] = "$Header: /m/cad/iges-g/RCS/g-iges.c,v 1.6 94/08/22 19:31:44 gdurf Exp Locker: jra $";
static char RCSrev[] = "$Revision: 1.6 $";
d51 1
a51 1
#include "../iges-g/iges.h"
@


1.6
log
@Factored ifdefs
@
text
@d26 2
a27 2
static char RCSid[] = "$Header: /m/cad/iges-g/RCS/g-iges.c,v 1.5 1994/01/07 15:16:19 jra Exp gdurf $";
static char RCSrev[] = "$Revision: 1.5 $";
d74 7
a80 1
		v - verbose\n";
@


1.5
log
@Modified header files
@
text
@d26 2
a27 2
static char RCSid[] = "$Header: /n/wolf/m/cad/iges-g/RCS/g-iges.c,v 1.4 93/09/24 10:04:48 jra Exp Locker: jra $";
static char RCSrev[] = "$Revision: 1.4 $";
d30 2
d36 1
d38 4
d159 1
a159 12
#ifdef BSD
	setlinebuf( stderr );
#else
#	if defined( SYSV ) && !defined( sgi ) && !defined(CRAY2) && \
	 !defined(n16)
		(void) setvbuf( stderr, (char *) NULL, _IOLBF, BUFSIZ );
#	endif
#	if defined(sgi) && defined(mips)
		if( setlinebuf( stderr ) != 0 )
			perror("setlinebuf(stderr)");
#	endif
#endif
@


1.4
log
@Added support for planar nurbs
@
text
@d26 2
a27 2
static char RCSid[] = "$Header: /m/cad/iges-g/RCS/g-iges.c,v 1.3 93/08/25 15:10:15 jra Exp $";
static char RCSrev[] = "$Revision: 1.3 $";
d39 2
d42 1
a43 1
#include "raytrace.h"
a48 3
#define	FACET_MODE	1
#define	CSG_MODE	2

d55 1
a55 1
RT_EXTERN( int nmgregion_to_iges , ( char *name , struct nmgregion *r , FILE *fp_dir , FILE *fp_param ) );
a69 1
static int	mode=CSG_MODE;	/* indicates which type of IGES file is desired */
d130 1
d371 2
a372 1
union tree *do_nmg_region_end(tsp, pathp, curtree)
d380 2
d434 11
a444 1
		dp->d_uses = (-nmgregion_to_iges( dp->d_namep , r , fp_dir , fp_param ));
@


1.3
log
@Use RCS revision number for version.
@
text
@d26 2
a27 2
static char RCSid[] = "$Header: /m/cad/iges-g/RCS/g-iges.c,v 1.2 93/08/18 09:12:54 jra Exp Locker: jra $";
static char RCSrev[] = "$Revision$";
d63 6
a68 1
static char	usage[] = "Usage: %s [-f|c] [-v] [-xX lvl] [-a abs_tol] [-r rel_tol] [-n norm_tol] [-o output_file] brlcad_db.g object(s)\n";
d136 1
d195 1
a195 1
	while ((c = getopt(argc, argv, "fca:n:o:p:r:vx:P:X:")) != EOF) {
d202 3
@


1.2
log
@slight mods for installation in cad tree
@
text
@d26 2
a27 1
static char RCSid[] = "$Header: /n/wolf/m/cad/iges-g/RCS/g-iges.c,v 1.1 93/08/18 08:49:43 jra Exp Locker: jra $";
d268 1
a268 1
	w_start_global( fp_dir , fp_param , argv[0] , prog_name , output_file , RCSid , version );
@


1.1
log
@Initial revision
@
text
@d26 1
a26 1
static char RCSid[] = "$Header: /n/wolf/vld/jra/SOURCE/g-iges/RCS/g-iges.c,v 1.4 93/08/18 08:40:22 jra Exp $";
d29 1
a29 1
static char *version="1.00";
d41 1
a41 1
#include "iges.h"
d158 4
@
