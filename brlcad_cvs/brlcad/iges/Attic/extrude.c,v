head	11.12;
access;
symbols
	ansi-20040405-merged:11.10.4.1
	postmerge-20040405-ansi:11.11
	premerge-20040404-ansi:11.11
	postmerge-autoconf:11.11
	autoconf-freeze:11.10.12.1
	premerge-autoconf:11.11
	ansi-20040316-freeze:11.10
	postmerge-20040315-windows:11.11
	premerge-20040315-windows:11.11
	windows-20040315-freeze:11.10.6.1
	autoconf-20031203:11.10
	autoconf-20031202:11.10
	autoconf-branch:11.10.0.12
	phong-branch:11.10.0.10
	photonmap-branch:11.10.0.8
	rel-6-1-DP:11.10
	windows-branch:11.10.0.6
	rel-6-0-2:11.10
	ansi-branch:11.10.0.4
	rel-6-0-1-branch:11.10.0.2
	hartley-6-0-post:11.10
	hartley-6-0-pre:11.10
	rel-6-0-1:11.10
	rel-6-0:11.10
	rel-5-4:11.9
	offsite-5-3-pre:11.10
	rel-5-3:11.9
	rel-5-2:11.9
	rel-5-1-branch:11.9.0.2
	rel-5-1:11.9
	rel-5-0:11.7
	rel-5-0-beta:11.7
	rel-4-5:11.7
	ctj-4-5-post:11.7
	ctj-4-5-pre:11.7
	rel-4-4:11.4
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.12
date	2004.05.24.04.01.08;	author morrison;	state dead;
branches;
next	11.11;

11.11
date	2004.02.02.17.39.04;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2001.02.06.15.13.42;	author jra;	state Exp;
branches
	11.10.4.1
	11.10.6.1
	11.10.12.1;
next	11.9;

11.9
date	2000.03.29.18.42.44;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	2000.01.05.14.16.08;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	96.10.28.21.23.05;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	95.12.06.13.25.06;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	95.11.28.21.35.45;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	95.01.04.10.07.40;	author mike;	state Rel4_4;
branches;
next	11.3;

11.3
date	94.11.08.14.50.03;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	94.08.22.18.45.17;	author gdurf;	state Exp;
branches;
next	11.1;

11.1
date	93.06.28.10.01.08;	author jra;	state Exp;
branches;
next	10.2;

10.2
date	93.06.03.09.51.55;	author jra;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.45.17;	author mike;	state Rel4_0;
branches;
next	1.5;

1.5
date	91.08.29.23.12.58;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	91.08.29.23.12.01;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	91.06.23.03.55.40;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	91.06.12.20.27.45;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	91.06.12.19.59.20;	author mike;	state Exp;
branches;
next	;

11.10.4.1
date	2004.03.17.21.16.31;	author morrison;	state Exp;
branches;
next	;

11.10.6.1
date	2004.03.11.23.41.14;	author morrison;	state Exp;
branches;
next	;

11.10.12.1
date	2004.02.12.19.41.38;	author erikg;	state Exp;
branches;
next	;


desc
@IGES converter
@


11.12
log
@moved to src/iges/
@
text
@/*
 *  Authors -
 *	John R. Anderson
 *	Susanne L. Muuss
 *	Earl P. Weaver
 *
 *  Source -
 *	VLD/ASB Building 1065
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 */
#include "./iges_struct.h"
#include "./iges_extern.h"

int
extrude( entityno )
int entityno;
{ 

	fastf_t		length;			/* extrusion length */
	vect_t		edir;			/* a unit vector (direction of extrusion */
	vect_t		evect;			/* Scaled vector for extrusion */
	int		sol_num;		/* IGES solid type number */
	int		curve;			/* pointer to directory entry for base curve */
	struct ptlist	*curv_pts;		/* List of points along curve */
	int		i;

	/* Default values */
	VSET( edir , 0.0 , 0.0 , 1.0 );


	/* Acquiring Data */

	if( dir[entityno]->param <= pstart )
	{
		bu_log( "Illegal parameter pointer for entity D%07d (%s)\n" ,
				dir[entityno]->direct , dir[entityno]->name );
		return(0);
	}
	Readrec( dir[entityno]->param );
	Readint( &sol_num , "" );

	/* Read pointer to directory entry for curve to be extruded */

	Readint( &curve , "" );

	/* Convert this to a "dir" index */

	curve = (curve-1)/2;

	Readcnv( &length , "" );
	Readflt( &edir[X] , "" );
	Readflt( &edir[Y] , "" );
	Readflt( &edir[Z] , "" );

	if( length <= 0.0 )
	{
		bu_log( "Illegal parameters for entity D%07d (%s)\n" ,
				dir[entityno]->direct , dir[entityno]->name );
		return(0);
	}

	/*
	 * Unitize direction vector
	 */

	VUNITIZE(edir);

	/* Scale vector */

	VSCALE(evect , edir, length);

	/* Switch based on type of curve to be extruded */

	switch( dir[curve]->type )
	{
		case 100:	/* circular arc */
			return( Extrudcirc( entityno , curve , evect ) );
		case 104:	/* conic arc */
			return( Extrudcon( entityno , curve , evect ) );
		case 102:	/* composite curve */
		case 106:	/* copius data */
		case 112:	/* parametric spline */
		case 126:	/* B-spline */
		{
			int npts;
			struct model *m;
			struct nmgregion *r;
			struct shell *s;
			struct faceuse *fu;
			struct loopuse *lu;
			struct edgeuse *eu;
			struct ptlist *pt_ptr;

			npts = Getcurve( curve , &curv_pts );
			if( npts < 3 )
				return( 0 );


			m = nmg_mm();
			r = nmg_mrsv( m );
			s = BU_LIST_FIRST( shell, &r->s_hd );

			fu = nmg_cface( s, (struct vertex **)NULL, npts-1 );
			pt_ptr = curv_pts;
			lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );
			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
			{
				struct vertex *v;

				v = eu->vu_p->v_p;
				nmg_vertex_gv( v, pt_ptr->pt );
				pt_ptr = pt_ptr->next;
			}

			if( nmg_calc_face_g( fu ) )
			{
				bu_log( "Extrude: Failed to calculate face geometry\n" );
				nmg_km( m );
				bu_free( (char *)curv_pts, "curve_pts" );
				return( 0 );
			}

			if( nmg_extrude_face( fu, evect , &tol ) )
			{
				bu_log( "Extrude: extrusion failed\n" );
				nmg_km( m );
				bu_free( (char *)curv_pts, "curve_pts" );
				return( 0 );
			}

			write_shell_as_polysolid( fdout, dir[entityno]->name, s );
			nmg_km( m );
			bu_free( (char *)curv_pts, "curve_pts" );

			return( 1 );
		}
		default:
			i = (-1);
			while( dir[curve]->type != typecount[++i].type && i < ntypes );
			bu_log( "Extrusions of %s are not allowed\n" , typecount[i].name );
			break;
	}
	return( 0 );
		

}
@


11.11
log
@update copyright to include span through 2003
@
text
@@


11.10
log
@Mods to get IGES working with new database format (v5)
@
text
@d13 1
a13 1
 *	This software is Copyright (C) 1990 by the United States Army.
@


11.10.4.1
log
@sync branch with HEAD
@
text
@d13 1
a13 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
@


11.10.6.1
log
@sync to HEAD...
@
text
@d13 1
a13 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
@


11.10.12.1
log
@merge from HEAD
@
text
@d13 1
a13 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
@


11.9
log
@
Converted from Release 4 names to know about libbu and libbn
@
text
@d19 1
@


11.8
log
@Eliminated some unused variables
@
text
@d39 1
a39 1
		rt_log( "Illegal parameter pointer for entity D%07d (%s)\n" ,
d61 1
a61 1
		rt_log( "Illegal parameters for entity D%07d (%s)\n" ,
d121 1
a121 1
				rt_log( "Extrude: Failed to calculate face geometry\n" );
d123 1
a123 1
				rt_free( (char *)curv_pts, "curve_pts" );
d129 1
a129 1
				rt_log( "Extrude: extrusion failed\n" );
d131 1
a131 1
				rt_free( (char *)curv_pts, "curve_pts" );
d137 1
a137 1
			rt_free( (char *)curv_pts, "curve_pts" );
d144 1
a144 1
			rt_log( "Extrusions of %s are not allowed\n" , typecount[i].name );
@


11.7
log
@Modified to use NMG's.
@
text
@a28 1
	point_t		crvmin,crvmax;		/* Bounding box for curve */
@


11.6
log
@All logging done via rt_log
@
text
@d90 8
a97 9
			int npts,done,nverts;
			/* normal_order indicates how to calculate
			   outward normals:
				1 => (pt->next - pt) X extrude_vector
				2 => opposite direction		*/
			int normal_order;
			struct ptlist *ptr,*ptr2;
			vect_t v1,v2,v3;
			point_t verts[4],tmpv[4];
d100 1
a100 1
			if( npts == 0 )
d103 9
a111 8
			/* Find bounding box for curve */
			crvmin[X] = INFINITY;
			crvmin[Y] = INFINITY;
			crvmin[Z] = INFINITY;
			for( i=0 ; i<3 ; i++ )
				crvmax[i] = (-crvmin[i]);
			ptr = curv_pts;
			while( ptr != NULL )
d113 5
a117 2
				VMINMAX( crvmin , crvmax , ptr->pt );
				ptr = ptr->next;
d120 1
a120 4
			ptr = curv_pts;
			while( ptr->pt[X] != crvmin[X] )
				ptr = ptr->next;
			if( ptr->next != NULL )
d122 4
a125 1
				VSUB2( v1 , ptr->pt , ptr->next->pt );
d127 2
a128 1
			else
d130 4
a133 1
				VSUB2( v1 , ptr->pt , curv_pts->pt );
a134 31
			VCROSS( v2 , v1 , edir );
			if( v2[X] < 0.0 )
				normal_order = 1;
			else
				normal_order = 2;

			/* Make polysolid header */
			mk_polysolid( fdout , dir[entityno]->name );

			/* loop through curve constructing sides
				each piece will be a 4 sided rectangle */
			ptr = curv_pts;
			while( ptr->next != NULL )
			{
				if( normal_order == 2 )
				{
					VMOVE( verts[0] , ptr->pt );
					VMOVE( verts[1] , ptr->next->pt );
					VADD2( verts[2] , verts[1] , evect );
					VADD2( verts[3] , verts[0] , evect );
				}
				else
				{
					VMOVE( verts[0] , ptr->next->pt );
					VMOVE( verts[1] , ptr->pt );
					VADD2( verts[2] , verts[1] , evect );
					VADD2( verts[3] , verts[0] , evect );
				}
				mk_fpoly( fdout , 4 , verts );
				ptr = ptr->next;
			}
d136 3
a138 1
			/* make top and bottom polygons */
a139 62
			ptr = curv_pts;
			ptr2 = ptr;
			while( ptr2->next != NULL )
				ptr2 = ptr2->next;
			if( SAMEPT( ptr2->pt , ptr->pt ) )
				ptr2 = ptr2->prev;
			done = 0;
			while( !done )
			{
				nverts = 4;
				/* Make Bottom polygon */
				VMOVE( verts[0] , ptr->pt );
				VMOVE( verts[1] , ptr2->pt );
				if( SAMEPT( ptr->next->pt , ptr2->prev->pt ) )
				{
					nverts = 3;
					VMOVE( verts[2] , ptr->next->pt );
					done = 1;
				}
				else
				{
					VMOVE( verts[2] , ptr2->prev->pt );
					VMOVE( verts[3] , ptr->next->pt );
				}

				VSUB2( v1 , verts[1] , verts[0] );
				VSUB2( v2 , verts[2] , verts[1] );
				VCROSS( v3 , v1 , v2 );
				if( VDOT( v3 , edir ) > 0.0 )
				{
					for( i=0 ; i<nverts ; i++ )
					{
						VMOVE( tmpv[i] , verts[nverts-1-i] );
					}
					for( i=0 ; i<nverts ; i++ )
					{
						VMOVE( verts[i] , tmpv[i] );
					}
				}
				mk_fpoly( fdout , nverts , verts );

				/* Make corresponding top polygon */
				for( i=0 ; i<nverts ; i++ )
				{
					VADD2( verts[i] , verts[i] , evect );
				}
				for( i=0 ; i<nverts ; i++ )
				{
					VMOVE( tmpv[i] , verts[nverts-1-i] );
				}
				for( i=0 ; i<nverts ; i++ )
				{
					VMOVE( verts[i] , tmpv[i] );
				}
				mk_fpoly( fdout , nverts , verts );
				ptr = ptr->next;
				ptr2 = ptr2->prev;
				if( SAMEPT( ptr->pt , ptr2->pt ) )
					done = 1;
				if( SAMEPT( ptr->next->pt , ptr2->pt ) )
					done = 1;
			}
@


11.5
log
@Mods to handle TNURB BREP. Also added RT_EXTERNS to iges_struct.h.
@
text
@d40 1
a40 1
		printf( "Illegal parameter pointer for entity D%07d (%s)\n" ,
d62 1
a62 1
		printf( "Illegal parameters for entity D%07d (%s)\n" ,
d229 1
a229 1
			printf( "Extrusions of %s are not allowed\n" , typecount[i].name );
@


11.4
log
@Release_4.4
@
text
@a15 12
#include "conf.h"

#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "machine.h"
#include "vmath.h"
#include "wdb.h"
#include "raytrace.h"
@


11.3
log
@Mods for Irix 6.
@
text
@@


11.2
log
@Factored ifdefs
@
text
@a94 1
			break;
a96 1
			break;
a236 1
			break;
@


11.1
log
@Major Upgrade to IGES 5.1
@
text
@d16 2
d19 3
a21 1
#ifdef BSD
a22 2
#else
#include <string.h>
@


10.2
log
@modification for new typecount struct
@
text
@@


10.1
log
@Release_4.0
@
text
@d241 2
a242 2
			while( dir[curve]->type != typecount[++i][0] && i < ntypes );
			printf( "Extrusions of %s are not allowed\n" , types[i] );
@


1.5
log
@string.h
@
text
@@


1.4
log
@JRA fix for normals on polysolid.
@
text
@d17 1
d19 3
@


1.3
log
@Changed struct directory to struct iges_directory, to
avoid conflict with raytrace.h
INFINITY now defined in raytrace.h
 
 
@
text
@d150 1
a150 1
				if( normal_order == 1 )
d196 1
a196 1
				VSUB2( v2 , verts[1] , verts[2] );
@


1.2
log
@Modified for Release 4.0
@
text
@d17 1
d20 2
a21 1
#include <strings.h>
a23 1
#include "wdb.h"
@


1.1
log
@Initial revision
@
text
@d17 2
@
