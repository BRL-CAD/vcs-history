head	11.15;
access;
symbols
	ansi-20040405-merged:11.13.4.1
	postmerge-20040405-ansi:11.14
	premerge-20040404-ansi:11.14
	postmerge-autoconf:11.14
	autoconf-freeze:11.13.12.1
	premerge-autoconf:11.14
	ansi-20040316-freeze:11.13
	postmerge-20040315-windows:11.14
	premerge-20040315-windows:11.14
	windows-20040315-freeze:11.13.6.1
	autoconf-20031203:11.13
	autoconf-20031202:11.13
	autoconf-branch:11.13.0.12
	phong-branch:11.13.0.10
	photonmap-branch:11.13.0.8
	rel-6-1-DP:11.13
	windows-branch:11.13.0.6
	rel-6-0-2:11.13
	ansi-branch:11.13.0.4
	rel-6-0-1-branch:11.13.0.2
	hartley-6-0-post:11.13
	hartley-6-0-pre:11.13
	rel-6-0-1:11.13
	rel-6-0:11.13
	rel-5-4:11.11
	offsite-5-3-pre:11.13
	rel-5-3:11.11
	rel-5-2:11.11
	rel-5-1-branch:11.11.0.2
	rel-5-1:11.11
	rel-5-0:11.10
	rel-5-0-beta:11.10
	rel-4-5:11.10
	ctj-4-5-post:11.9
	ctj-4-5-pre:11.9
	rel-4-4:11.6
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.15
date	2004.05.24.04.01.09;	author morrison;	state dead;
branches;
next	11.14;

11.14
date	2004.02.02.17.39.05;	author morrison;	state Exp;
branches;
next	11.13;

11.13
date	2001.02.06.15.13.42;	author jra;	state Exp;
branches
	11.13.4.1
	11.13.6.1
	11.13.12.1;
next	11.12;

11.12
date	2000.07.20.15.35.26;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	2000.03.29.18.42.51;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	97.09.18.20.35.19;	author jra;	state Exp;
branches;
next	11.9;

11.9
date	95.12.06.13.25.06;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	95.12.01.15.47.52;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	95.11.28.21.35.45;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	95.01.04.10.08.13;	author mike;	state Rel4_4;
branches;
next	11.5;

11.5
date	94.11.08.14.50.22;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	94.08.22.19.31.57;	author gdurf;	state Exp;
branches;
next	11.3;

11.3
date	94.05.06.11.00.15;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	94.01.07.15.15.33;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	93.06.28.10.37.50;	author jra;	state Exp;
branches;
next	10.4;

10.4
date	93.06.07.15.04.35;	author jra;	state Exp;
branches;
next	10.3;

10.3
date	93.06.07.13.10.57;	author jra;	state Exp;
branches;
next	10.2;

10.2
date	92.05.29.01.34.49;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.45.34;	author mike;	state Rel4_0;
branches;
next	1.3;

1.3
date	91.06.23.03.54.45;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	91.06.12.20.27.59;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	91.06.12.19.59.46;	author mike;	state Exp;
branches;
next	;

11.13.4.1
date	2004.03.17.21.16.34;	author morrison;	state Exp;
branches;
next	;

11.13.6.1
date	2004.03.11.23.41.16;	author morrison;	state Exp;
branches;
next	;

11.13.12.1
date	2004.02.12.19.41.40;	author erikg;	state Exp;
branches;
next	;


desc
@IGES converter
@


11.15
log
@moved to src/iges/
@
text
@/*
 *  Authors -
 *	Phil Dykstra
 *	John R. Anderson
 *
 *  Source -
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 */

#include "./iges_struct.h"
#include "./iges_extern.h"

#define	PATCH_COUNT	1

int
spline( entityno, b_patch )
int entityno;
struct face_g_snurb **b_patch;
{
	int	k1;	/* upper index of first sum */
	int	k2;	/* upper index of second sum */
	int	m1;	/* degree of 1st set of basis functions */
	int	m2;	/* degree of 2nd set of basis functions */
	int	prop1;	/* !0 if closed in first direction */
	int	prop2;	/* !0 if closed in second direction */
	int	prop3;	/* !0 if polynomial (else rational) */
	int	prop4;	/* !0 if periodic in first direction */
	int	prop5;	/* !0 if periodic in second direction */
	int	sol_num; /* IGES solid type number */
	int	n1, n2;
	int	i, j, k;
	int	count=0;
	fastf_t	min_knot;
	fastf_t max_wt;

	/* Acquiring Data */

	if( dir[entityno]->param <= pstart )
	{
		bu_log( "Illegal parameter pointer for entity D%07d (%s)\n" ,
				dir[entityno]->direct , dir[entityno]->name );
		return(0);
	}

	Readrec( dir[entityno]->param );
	Readint( &sol_num , "" );
	Readint( &k1 , "" );
	Readint( &k2 , "" );
	Readint( &m1 , "" );
	Readint( &m2 , "" );
	Readint( &prop1 , "" );
	Readint( &prop2 , "" );
	Readint( &prop3 , "" );
	Readint( &prop4 , "" );
	Readint( &prop5 , "" );

	n1 = k1 - m1 + 1;
	n2 = k2 - m2 + 1;

	/*  spl_new: Creates a spline surface data structure
	 *	u_order		(e.g. cubic = order 4)
	 *	v_order
	 *	num_u	(e.g. num control points + order)
	 *	num_v
	 *	num_rows	num control points in V direction
	 *	num_cols	num control points in U direction
	 *	point_size	number of values in a point (e.g. 3 or 4)
	 */
	(*b_patch) = rt_nurb_new_snurb(
		m1+1, m2+1,
		n1+2*m1+1, n2+2*m2+1,
		k2+1, k1+1, RT_NURB_MAKE_PT_TYPE( 4 , 2 , 0 ), (struct resource *)NULL );

	/* U knot vector */
	min_knot = 0.0;
	for (i = 0; i <= n1+2*m1; i++)
	{
		Readdbl( &(*b_patch)->u.knots[i] , "" );
		if( (*b_patch)->u.knots[i] < min_knot )
			min_knot = (*b_patch)->u.knots[i];
	}

	if( min_knot < 0.0 )
	{
		for (i = 0; i <= n1+2*m1; i++)
		{
			(*b_patch)->u.knots[i] -= min_knot;
		}
	}

	min_knot = 0.0;
	/* V knot vector */
	for (i = 0; i <= n2+2*m2; i++)
	{
		Readdbl( &(*b_patch)->v.knots[i] , "" );
		if( (*b_patch)->v.knots[i] < min_knot )
			min_knot = (*b_patch)->v.knots[i];
	}
	if( min_knot < 0.0 )
	{
		for (i = 0; i <= n1+2*m1; i++)
		{
			(*b_patch)->v.knots[i] -= min_knot;
		}
	}


	/* weights */
	max_wt = 0.0;
	count = 0;
	for( i=0 ; i<=k2 ; i++ )
	{
		for( j=0 ; j<= k1 ; j++ )
		{
			Readdbl( &(*b_patch)->ctl_points[ count*4 + 3 ] , "" );
			if( (*b_patch)->ctl_points[ count*4 + 3 ] > max_wt )
				max_wt = (*b_patch)->ctl_points[ count*4 + 3 ];
			count++;
		}
	}

	/* control points */
	count = 0;
	for (i = 0; i <= k2; i++)
	{
		for (j = 0; j <= k1; j++)
		{
			Readcnv( &(*b_patch)->ctl_points[ count*4 ] , "" );
			Readcnv( &(*b_patch)->ctl_points[ count*4 + 1 ] , "" );
			Readcnv( &(*b_patch)->ctl_points[ count*4 + 2 ] , "" );
			count++;
		}
	}

	/* apply weights */
	count = 0;
	for (i = 0; i <= k2; i++)
	{
		for (j = 0; j <= k1; j++)
		{
			for( k=0 ; k<3 ; k++ )
				(*b_patch)->ctl_points[ count*4 + k ] *= (*b_patch)->ctl_points[ count*4 + 3];
			count++;
		}
	}

	return( 1 );
}
@


11.14
log
@update copyright to include span through 2003
@
text
@@


11.13
log
@Mods to get IGES working with new database format (v5)
@
text
@d11 1
a11 1
 *	This software is Copyright (C) 1990 by the United States Army.
@


11.13.4.1
log
@sync branch with HEAD
@
text
@d11 1
a11 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
@


11.13.6.1
log
@sync to HEAD...
@
text
@d11 1
a11 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
@


11.13.12.1
log
@merge from HEAD
@
text
@d11 1
a11 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
@


11.12
log
@Converted to using wdb_fopen()
@
text
@d20 1
d23 1
a23 1
struct face_g_snurb *b_patch;
d74 1
a74 1
	b_patch = rt_nurb_new_snurb(
d83 3
a85 3
		Readdbl( &b_patch->u.knots[i] , "" );
		if( b_patch->u.knots[i] < min_knot )
			min_knot = b_patch->u.knots[i];
d92 1
a92 1
			b_patch->u.knots[i] -= min_knot;
d100 3
a102 3
		Readdbl( &b_patch->v.knots[i] , "" );
		if( b_patch->v.knots[i] < min_knot )
			min_knot = b_patch->v.knots[i];
d108 1
a108 1
			b_patch->v.knots[i] -= min_knot;
d120 3
a122 3
			Readdbl( &b_patch->ctl_points[ count*4 + 3 ] , "" );
			if( b_patch->ctl_points[ count*4 + 3 ] > max_wt )
				max_wt = b_patch->ctl_points[ count*4 + 3 ];
d133 3
a135 3
			Readcnv( &b_patch->ctl_points[ count*4 ] , "" );
			Readcnv( &b_patch->ctl_points[ count*4 + 1 ] , "" );
			Readcnv( &b_patch->ctl_points[ count*4 + 2 ] , "" );
d147 1
a147 1
				b_patch->ctl_points[ count*4 + k ] *= b_patch->ctl_points[ count*4 + 3];
@


11.11
log
@
Converted from Release 4 names to know about libbu and libbn
@
text
@d20 1
a20 1
spline( entityno )
d22 1
a38 1
	struct face_g_snurb *b_patch;
a149 5



	/* Output the the b_spline through the libwdb interface */
	mk_bsurf(fdout, b_patch);
@


11.10
log
@Mod for pmalloc.
@
text
@d44 1
a44 1
		rt_log( "Illegal parameter pointer for entity D%07d (%s)\n" ,
@


11.9
log
@All logging done via rt_log
@
text
@d76 1
a76 1
		k2+1, k1+1, RT_NURB_MAKE_PT_TYPE( 4 , 2 , 0 ) );
@


11.8
log
@LIBNURBS has been converted over to using t-NURBS NMG data structures
@
text
@d44 1
a44 1
		printf( "Illegal parameter pointer for entity D%07d (%s)\n" ,
@


11.7
log
@Mods to handle TNURB BREP. Also added RT_EXTERNS to iges_struct.h.
@
text
@d38 1
a38 1
	struct snurb *b_patch;
d67 2
a68 2
	 *	num_u_knots	(e.g. num control points + order)
	 *	num_v_knots
d82 3
a84 3
		Readdbl( &b_patch->u_knots.knots[i] , "" );
		if( b_patch->u_knots.knots[i] < min_knot )
			min_knot = b_patch->u_knots.knots[i];
d91 1
a91 1
			b_patch->u_knots.knots[i] -= min_knot;
d99 3
a101 3
		Readdbl( &b_patch->v_knots.knots[i] , "" );
		if( b_patch->v_knots.knots[i] < min_knot )
			min_knot = b_patch->v_knots.knots[i];
d107 1
a107 1
			b_patch->v_knots.knots[i] -= min_knot;
@


11.6
log
@Release_4.4
@
text
@a14 8
#include "conf.h"

#include <stdio.h>
#include <math.h>

#include "machine.h"		/* BRL-CAD specific machine data types */
#include "vmath.h"		/* BRL-CAD Vector macros */
#include "nurb.h"
a16 1
#include "wdb.h"
d34 1
a34 1
	int	i, j;
d138 14
@


11.5
log
@Mods for Irix 6.
@
text
@@


11.4
log
@Factored ifdefs
@
text
@d42 1
a42 1
	int	n1, n2, a, b, c;
a71 3
	a = n1 + 2 * m1;
	b = n2 + 2 * m2;
	c = (k1 + 1)*(k2 + 1);
a146 22

#if 0
	/* normalize */
	if( max_wt > 1.0 )
	{
		count = 0;
		for( i=0 ; i<=k2 ; i++ )
		{
			for( j=0 ; j<=k1 ; j++ )
			{
				int k;

				if( b_patch->ctl_points[ count*4 + 3 ] == max_wt )
				{
					for( k=0 ; k<4 ; k++ )
						b_patch->ctl_points[ count*4 + k ] = b_patch->ctl_points[ count*4 + k ]/max_wt;
				}
				count++;
			}
		}
	}
#endif
@


11.3
log
@Reworked spline conversion
@
text
@d15 2
a17 2
#include "machine.h"
#include "vmath.h"
d19 1
@


11.2
log
@Modified header files
@
text
@a39 1
	fastf_t *params; /* Surface parameters */
d43 3
a45 1
	fastf_t	*dp;
a74 6
	/* Allocate space for the parameters */
	params =(fastf_t *)calloc( 15+a+b+4*c , sizeof(fastf_t ) );

	for( i=10 ; i<15+a+b+4*c ; i++ )
		Readcnv( &params[i] , "" );

d90 6
a95 2
	for (i = 0; i <= n1+2*m1; i++) {
		b_patch->u_knots.knots[i] = params[10+i];
d98 9
d108 5
a112 2
	for (i = 0; i <= n2+2*m2; i++) {
		b_patch->v_knots.knots[i] = params[11+a+i];
d114 7
d122 15
d138 9
a146 16
	dp = b_patch->ctl_points;
	for (i = 0; i <= k2; i++) {
		for (j = 0; j <= k1; j++) {
			fastf_t	x, y, z, w;
			w = params[12+a+b + i*(k1+1) + j];
			x = params[12+a+b+c + (i*(k1+1) + j)*3];
			y = params[13+a+b+c + (i*(k1+1) + j)*3];
			z = params[14+a+b+c + (i*(k1+1) + j)*3];
			/* Why were these mutiplied by 1000??? */
/*			x *= 1000 * w;
			y *= 1000 * w;
			z *= 1000 * w;	*/
			*dp++ = x;
			*dp++ = y;
			*dp++ = z;
			*dp++ = w;
d150 22
a174 2
	/* Free some memory */
	free( params );
@


11.1
log
@Major Upgrade to IGES 5.1
@
text
@d113 2
a114 1
			x *= 1000 * w;
d116 1
a116 1
			z *= 1000 * w;
@


10.4
log
@Corrected call to rt_nurb_new_snurb to use RT_NURB_MAKE_PT_TYPE
@
text
@@


10.3
log
@Corrected call to rt_nurb_new_snurb to use MAKE_PT_TYPE
@
text
@d92 1
a92 1
		k2+1, k1+1, MAKE_PT_TYPE( 4 , 2 , 0 ) );
@


10.2
log
@Modified for new data structures
@
text
@d92 1
a92 1
		k2+1, k1+1, 4);
@


10.1
log
@Release_4.0
@
text
@d96 1
a96 1
		b_patch->u_knots->knots[i] = params[10+i];
d101 1
a101 1
		b_patch->v_knots->knots[i] = params[11+a+i];
d105 1
a105 1
	dp = b_patch->mesh->ctl_points;
@


1.3
log
@Modified to use new LIBNURB interface for libwdb.
@
text
@@


1.2
log
@Modified for Release 4.0
@
text
@d21 1
a21 1
#include "./b_spline.h"		/* BRL-CAD Spline data structures */
a42 1

d45 1
a45 1
	struct b_spline *b_patch;
d89 1
a89 1
	b_patch = (struct b_spline *) spl_new(
d96 1
a96 1
		b_patch->u_kv->knots[i] = params[10+i];
d101 1
a101 1
		b_patch->v_kv->knots[i] = params[11+a+i];
d105 1
a105 1
	dp = b_patch->ctl_mesh->mesh;
@


1.1
log
@Initial revision
@
text
@d16 2
@
