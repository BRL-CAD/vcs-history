head	11.8;
access;
symbols
	ansi-20040405-merged:11.5.2.1
	postmerge-20040405-ansi:11.6
	premerge-20040404-ansi:11.5
	postmerge-autoconf:11.5
	autoconf-freeze:11.5
	premerge-autoconf:11.5
	ansi-20040316-freeze:11.5.2.1
	postmerge-20040315-windows:11.5
	premerge-20040315-windows:11.5
	windows-20040315-freeze:11.5
	autoconf-20031203:11.5
	autoconf-20031202:11.5
	autoconf-branch:11.5.0.10
	phong-branch:11.5.0.8
	photonmap-branch:11.5.0.6
	rel-6-1-DP:11.5
	windows-branch:11.5.0.4
	rel-6-0-2:11.3
	ansi-branch:11.5.0.2
	rel-6-0-1-branch:11.3.0.2
	hartley-6-0-post:11.4
	hartley-6-0-pre:11.3
	rel-6-0-1:11.3
	rel-6-0:11.3
	rel-5-4:11.1
	offsite-5-3-pre:11.3
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.8
date	2004.05.24.04.01.40;	author morrison;	state dead;
branches;
next	11.7;

11.7
date	2004.05.10.15.30.42;	author erikg;	state Exp;
branches;
next	11.6;

11.6
date	2004.04.05.07.47.59;	author morrison;	state Exp;
branches;
next	11.5;

11.5
date	2002.08.20.17.07.30;	author jra;	state Exp;
branches
	11.5.2.1;
next	11.4;

11.4
date	2002.08.15.20.54.43;	author hartley;	state Exp;
branches;
next	11.3;

11.3
date	2000.08.24.23.09.00;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	2000.08.24.23.07.42;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.21.52;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.23.17.59.09;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.53.19;	author mike;	state Rel4_0;
branches;
next	2.4;

2.4
date	91.08.30.00.26.43;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	91.01.03.23.01.09;	author cjohnson;	state Exp;
branches;
next	2.2;

2.2
date	90.04.13.03.09.03;	author cjohnson;	state Exp;
branches;
next	2.1;

2.1
date	90.04.13.01.23.12;	author cjohnson;	state Rel;
branches;
next	1.2;

1.2
date	90.04.13.00.46.54;	author cjohnson;	state Exp;
branches;
next	1.1;

1.1
date	90.04.13.00.31.49;	author cjohnson;	state Exp;
branches;
next	;

11.5.2.1
date	2002.09.19.18.00.58;	author morrison;	state Exp;
branches;
next	;


desc
@Edge detecter used to sharpen images before being displayed.
@


11.8
log
@moved to src/halftone/
@
text
@#ifndef lint
static const char RCSid[] = "$Header: /n/xoff/cvs/brlcad/halftone/sharpen.c,v 11.7 2004/05/10 15:30:42 erikg Exp $";
#endif
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>

#include "machine.h"
#include "externs.h"			/* For malloc */

extern int Debug;
extern double Beta;
/*	sharpen	- return a sharpened tone mapped buffer.
 *
 * Entry:
 *	buf	- buffer to place bytes.
 *	size	- size of element
 *	num	- number of elements to read.
 *	file	- file to read from.
 *	Map	- tone scale mapping.
 *
 * Exit:
 *	returns 0 on EOF
 *		number of byes read otherwise.
 *
 * Uses:
 *	Debug	- Current debug level.
 *	Beta	- sharpening value.
 *
 * Calls:
 *	None.
 *
 * Method:
 *	if no sharpening just read a line tone scale and return.
 *	if first time called get space for processing and do setup.
 *	if first line then
 *		only use cur and next lines
 *	else if last line then
 *		only use cur and last lines
 *	else
 *		use last cur and next lines
 *	endif
 *
 * Author:
 *	Christopher T. Johnson
 *
 * $Log: sharpen.c,v $
 * Revision 11.7  2004/05/10 15:30:42  erikg
 * change conf.h to a wrapped config.h
 *
 * Revision 11.6  2004/04/05 07:47:59  morrison
 * merge of ansi-6-0-branch into HEAD
 *
 * Revision 11.5.2.1  2002/09/19 18:00:58  morrison
 * Initial ANSIfication
 *
 * Revision 11.5  2002/08/20 17:07:30  jra
 * Restoration of entire source tree to Pre-Hartley state
 *
 * Revision 11.3  2000/08/24 23:09:00  mike
 *
 * lint
 *
 * Revision 11.2  2000/08/24 23:07:42  mike
 *
 * lint
 *
 * Revision 11.1  1995/01/04  10:21:52  mike
 * Release_4.4
 *
 * Revision 10.2  94/08/23  17:59:09  gdurf
 * Added includes of conf.h, machine.h, externs.h for malloc
 * 
 * Revision 10.1  1991/10/12  06:53:19  mike
 * Release_4.0
 *
 * Revision 2.4  91/08/30  00:26:43  mike
 * Stardent ANSI C
 * 
 * Revision 2.3  91/01/03  23:01:09  cjohnson
 * Added range checking, to limit values to 0..255
 * 
 * Revision 2.2  90/04/13  03:09:03  cjohnson
 * Back off code to reduce number of floating point multiblies.
 * 
 * Revision 2.1  90/04/13  01:23:12  cjohnson
 * First Relese.
 * 
 * Revision 1.2  90/04/13  00:46:54  cjohnson
 * Clean up comments.
 * Fix error on second line.
 * 
 * Revision 1.1  90/04/13  00:31:49  cjohnson
 * Initial revision
 * 
 * 
 */
int
sharpen(unsigned char *buf, int size, int num, FILE *file, unsigned char *Map)
{
	static unsigned char *last,*cur=0,*next;
	static int linelen;
	int result;
	register int newvalue;
	register  int i,value;

/*
 *	if no sharpening going on then just read from the file and exit.
 */
	if (Beta == 0.0) {
		result = fread(buf, size, num, file);
		if (!result) return(result);
		for (i=0; i<size*num; i++) {
			buf[i] = Map[buf[i]];
		}
		return(result);
	}

/*
 *	if we are sharpening we depend on the pixel size being one char.
 */
	if (size != 1) {
		fprintf(stderr, "sharpen: size != 1.\n");
		exit(2);
	}

/*
 *	if this is the first time we have been called then get some
 *	space to load pixels into and read first and second line of
 *	the file.
 */
	if (!cur) {
		linelen=num;
		last = 0;
		cur  = (unsigned char *)malloc(linelen);
		next = (unsigned char *)malloc(linelen);
		result = fread(cur, 1, linelen, file);
		for (i=0; i<linelen;i++) cur[i] = Map[cur[i]];
		if (!result) return(result);	/* nothing there! */
		result = fread(next, 1, linelen, file);
		if (!result) {
			free(next);
			next = 0;
		} else {
			for (i=0; i<linelen;i++) cur[i] = Map[cur[i]];
		}
	} else {
		unsigned char *tmp;

		if (linelen != num) {
			fprintf(stderr,"sharpen: buffer size changed!\n");
			exit(2);
		}
/*
 *		rotate the buffers.
 */
		tmp=last;
		last=cur;
		cur=next;
		next=tmp;
		result=fread(next, 1, linelen, file);
/*
 *		if at EOF then free up a buffer and set next to NULL
 *		to flag EOF for the next time we are called.
 */
		if (!result) {
			free(next);
			next = 0;
		} else {
			for (i=0; i<linelen;i++) cur[i] = Map[cur[i]];
		}
	}
/*
 *	if cur is NULL then we are at EOF.  Memory leak here as
 *	we don't free last.
 */
	if (!cur) return(0);

/*
 * Value is the following Laplacian filter kernel:
 *		0.25
 *	0.25	-1.0	0.25
 *		0.25
 *
 * Thus value is zero in constant value areas and none zero on
 * edges.
 *
 * Page 335 of Digital Halftoning defines
 *	J     [n] = J[n] - Beta*Laplacian_filter[n]*J[n]
 *	 sharp
 *
 * J, J     , Laplacian_filter[n] are all in the range 0.0 to 1.0
 *     sharp
 *
 * The folowing is done in mostly interger mode, there is only one
 * floating point multiply done.
 */

/*
 *	if first line
 */
	if (!last) {
		i=0;
		value=next[i] + cur[i+1] - cur[i]*2;
		newvalue = cur[i] - Beta*value*((int)cur[i])/(255*2);
		buf[i] = (newvalue < 0) ? 0 : (newvalue > 255) ? 
		    255: newvalue;
		for (; i < linelen-1; i++) {
			value = next[i] + cur[i-1] + cur[i+1] - cur[i]*3;
			newvalue = cur[i] - Beta*value*((int)cur[i])/(255*3);
			buf[i] = (newvalue < 0) ? 0 : (newvalue > 255) ? 
			    255: newvalue;
		}
		value=next[i] + cur[i-1] - cur[i]*2;
		newvalue = cur[i] - Beta*value*((int)cur[i])/(255*2);
		buf[i] = (newvalue < 0) ? 0 : (newvalue > 255) ? 
		    255: newvalue;

/*
 *		first time through so we will need this buffer space
 *		the next time through.
 */
		last  = (unsigned char *)malloc(linelen);
/*
 *	if last line
 */
	} else if (!next) {
		i=0;
		value=last[i] + cur[i+1] - cur[i]*2;
		newvalue = cur[i] - Beta*value*((int)cur[i])/(255*2);
		buf[i] = (newvalue < 0) ? 0 : (newvalue > 255) ? 
		    255: newvalue;
		for (; i < linelen-1; i++) {
			value = last[i] + cur[i-1] + cur[i+1] - cur[i]*3;
			newvalue = cur[i] - Beta*value*((int)cur[i])/(255*3);
			buf[i] = (newvalue < 0) ? 0 : (newvalue > 255) ? 
			    255: newvalue;
		}
		value=last[i] + cur[i-1] - cur[i]*2;
		newvalue = cur[i] - Beta*value*((int)cur[i])/(255*2);
		buf[i] = (newvalue < 0) ? 0 : (newvalue > 255) ? 
		    255: newvalue;
/*
 *	all other lines.
 */
	} else {
		i=0;
		value=last[i] + next[i] + cur[i+1] - cur[i]*3;
		newvalue = cur[i] - Beta*value*((int)cur[i])/(255*3);
		buf[i] = (newvalue < 0) ? 0 : (newvalue > 255) ? 
		    255: newvalue;
		for (; i < linelen-1; i++) {
			value = last[i] + next[i] + cur[i-1] + cur[i+1]
			     - cur[i]*4;
			newvalue = cur[i] - Beta*value*((int)cur[i])/(255*4);
			buf[i] = (newvalue < 0) ? 0 : (newvalue > 255) ? 
			    255: newvalue;
		}
		value=last[i] + next[i] + cur[i-1] - cur[i]*3;
		newvalue = cur[i] - Beta*value*((int)cur[i])/(255*3);
		buf[i] = (newvalue < 0) ? 0 : (newvalue > 255) ? 
		    255: newvalue;
	}
	return(linelen);
}
@


11.7
log
@change conf.h to a wrapped config.h
@
text
@d2 1
a2 1
static const char RCSid[] = "$Header: /cvs/brlcad/halftone/sharpen.c,v 11.6 2004/04/05 07:47:59 morrison Exp $";
d52 3
@


11.6
log
@merge of ansi-6-0-branch into HEAD
@
text
@d2 1
a2 1
static const char RCSid[] = "$Header$";
d4 5
a8 1
#include "conf.h"
d51 4
a54 1
 * $Log$
@


11.5
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d2 1
a2 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/halftone/sharpen.c,v 11.3 2000/08/24 23:09:00 mike Exp $";
d47 7
a53 1
 * $Log: sharpen.c,v $
d93 1
a93 6
sharpen(buf,size,num,file,Map)
unsigned char *buf;
int  size;
int  num;
FILE *file;
unsigned char *Map;
@


11.5.2.1
log
@Initial ANSIfication
@
text
@d2 1
a2 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/halftone/sharpen.c,v 11.5 2002/08/20 17:07:30 jra Exp $";
a47 3
 * Revision 11.5  2002/08/20 17:07:30  jra
 * Restoration of entire source tree to Pre-Hartley state
 *
d87 6
a92 1
sharpen(unsigned char *buf, int size, int num, FILE *file, unsigned char *Map)
@


11.4
log
@Converted from K&R to ANSI C - RFH
@
text
@d87 6
a92 1
sharpen(unsigned char *buf, int size, int num, FILE *file, unsigned char *Map)
@


11.3
log
@
lint
@
text
@d2 1
a2 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/halftone/sharpen.c,v 11.2 2000/08/24 23:07:42 mike Exp $";
d48 4
d87 1
a87 6
sharpen(buf,size,num,file,Map)
unsigned char *buf;
int  size;
int  num;
FILE *file;
unsigned char *Map;
@


11.2
log
@
lint
@
text
@d2 1
a2 1
static char rcsid[] = "$Header: /c/CVS/brlcad/halftone/sharpen.c,v 11.1 1995/01/04 10:21:52 mike Rel4_4 $";
d48 4
@


11.1
log
@Release_4.4
@
text
@d2 1
a2 1
static char rcsid[] = "$Header: /m/cad/halftone/RCS/sharpen.c,v 10.2 94/08/23 17:59:09 gdurf Exp $";
d47 4
a50 1
 * $Log:	sharpen.c,v $
@


10.2
log
@Added includes of conf.h, machine.h, externs.h for malloc
@
text
@d2 1
a2 1
static char rcsid[] = "$Header: /m/cad/halftone/RCS/sharpen.c,v 10.1 1991/10/12 06:53:19 mike Rel4_0 gdurf $";
d47 4
a50 1
 * $Log: sharpen.c,v $
@


10.1
log
@Release_4.0
@
text
@d2 1
a2 1
static char rcsid[] = "$Header: /m/cad/halftone/RCS/sharpen.c,v 2.4 91/08/30 00:26:43 mike Exp $";
d4 2
d7 4
d47 4
a50 1
 * $Log:	sharpen.c,v $
@


2.4
log
@Stardent ANSI C
@
text
@d2 1
a2 1
static char rcsid[] = "$Header: /m/cad/halftone/RCS/sharpen.c,v 2.3 91/01/03 23:01:09 cjohnson Exp $";
d42 3
@


2.3
log
@Added range checking, to limit values to 0..255
@
text
@d2 1
a2 1
static char rcsid[] = "$Header: /m/cad/halftone/RCS/sharpen.c,v 2.2 90/04/13 03:09:03 cjohnson Exp $";
d42 3
d172 1
a172 1
		newvalue = cur[i] - Beta*value*cur[i]/(255*2);
d177 1
a177 1
			newvalue = cur[i] - Beta*value*cur[i]/(255*3);
d182 1
a182 1
		newvalue = cur[i] - Beta*value*cur[i]/(255*2);
d197 1
a197 1
		newvalue = cur[i] - Beta*value*cur[i]/(255*2);
d202 1
a202 1
			newvalue = cur[i] - Beta*value*cur[i]/(255*3);
d207 1
a207 1
		newvalue = cur[i] - Beta*value*cur[i]/(255*2);
d216 1
a216 1
		newvalue = cur[i] - Beta*value*cur[i]/(255*3);
d222 1
a222 1
			newvalue = cur[i] - Beta*value*cur[i]/(255*4);
d227 1
a227 1
		newvalue = cur[i] - Beta*value*cur[i]/(255*3);
@


2.2
log
@Back off code to reduce number of floating point multiblies.
@
text
@d2 1
a2 1
static char rcsid[] = "$Header: sharpen.c,v 2.1 90/04/13 01:23:12 cjohnson Locked $";
d42 3
d68 1
a68 1

d169 3
a171 1
		buf[i] = cur[i] - Beta*value*cur[i]/(255*2);
d174 3
a176 1
			buf[i] = cur[i] - Beta*value*cur[i]/(255*3);
d179 4
a182 1
		buf[i] = cur[i] - Beta*value*cur[i]/(255*2);
d194 3
a196 1
		buf[i] = cur[i] - Beta*value*cur[i]/(255*2);
d199 3
a201 1
			buf[i] = cur[i] - Beta*value*cur[i]/(255*3);
d204 3
a206 1
		buf[i] = cur[i] - Beta*value*cur[i]/(255*2);
d213 3
a215 1
		buf[i] = cur[i] - Beta*value*cur[i]/(255*3);
d219 3
a221 1
			buf[i] = cur[i] - Beta*value*cur[i]/(255*4);
d224 3
a226 1
		buf[i] = cur[i] - Beta*value*cur[i]/(255*3);
@


2.1
log
@First Relese.
@
text
@d2 1
a2 1
static char rcsid[] = "$Header: sharpen.c,v 1.2 90/04/13 00:46:54 cjohnson Locked $";
d42 3
d166 1
a166 1
		buf[i] = cur[i] - Beta*(value*cur[i]/(255*2));
d169 1
a169 1
			buf[i] = cur[i] - Beta*(value*cur[i]/(255*3));
d172 1
a172 1
		buf[i] = cur[i] - Beta*(value*cur[i]/(255*2));
d184 1
a184 1
		buf[i] = cur[i] - Beta*(value*cur[i]/(255*2));
d187 1
a187 1
			buf[i] = cur[i] - Beta*(value*cur[i]/(255*3));
d190 1
a190 1
		buf[i] = cur[i] - Beta*(value*cur[i]/(255*2));
d197 1
a197 1
		buf[i] = cur[i] - Beta*(value*cur[i]/(255*3));
d201 1
a201 1
			buf[i] = cur[i] - Beta*(value*cur[i]/(255*4));
d204 1
a204 1
		buf[i] = cur[i] - Beta*(value*cur[i]/(255*3));
@


1.2
log
@Clean up comments.
Fix error on second line.
@
text
@d2 1
a2 1
static char rcsid[] = "$Header: sharpen.c,v 1.1 90/04/13 00:31:49 cjohnson Locked $";
d42 4
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
static char rcsid[] = "$Header: tone_simple.c,v 1.5 90/04/11 15:26:23 cjohnson Exp $";
d7 1
a7 1
/*	sharpen	an image.
d17 2
a18 1
 *	returns pointer to buf or NULL
d25 1
a25 1
 *	Random	- return a random number between -0.5 and 0.5;
d28 9
a36 1
 *	straight-forward.
d39 1
a39 1
 *	Christopher T. Johnson	- 90/03/21
d41 3
a43 1
 * $Log$
d45 1
d55 1
a55 1
	static unsigned char *last=0,*cur,*next;
d86 1
a86 1
	if (!last) {
d128 2
a129 1
 *	if cur is NULL then we are at EOF.
d133 23
d159 1
a159 1
		buf[i] = cur[i] - Beta*value*cur[i]/(255*2);
d162 1
a162 1
			buf[i] = cur[i] - Beta*value*cur[i]/(255*3);
d165 5
a169 1
		buf[i] = cur[i] - Beta*value*cur[i]/(255*2);
d171 3
d177 1
a177 1
		buf[i] = cur[i] - Beta*value*cur[i]/(255*2);
d180 1
a180 1
			buf[i] = cur[i] - Beta*value*cur[i]/(255*3);
d183 4
a186 1
		buf[i] = cur[i] - Beta*value*cur[i]/(255*2);
d189 2
a190 2
		value=last[i] +next[i] + cur[i+1] - cur[i]*3;
		buf[i] = cur[i] - Beta*value*cur[i]/(255*3);
d194 1
a194 1
			buf[i] = cur[i] - Beta*value*cur[i]/(255*4);
d197 1
a197 1
		buf[i] = cur[i] - Beta*value*cur[i]/(255*3);
@
