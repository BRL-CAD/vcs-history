head	11.13;
access;
symbols
	ansi-20040405-merged:11.9.2.2
	postmerge-20040405-ansi:11.11
	premerge-20040404-ansi:11.10
	postmerge-autoconf:11.10
	autoconf-freeze:11.10
	premerge-autoconf:11.10
	postmerge-20040315-windows:11.10
	premerge-20040315-windows:11.10
	windows-20040315-freeze:11.9.4.1
	autoconf-20031203:11.10
	autoconf-20031202:11.10
	autoconf-branch:11.10.0.2
	phong-branch:11.9.0.8
	photonmap-branch:11.9.0.6
	rel-6-1-DP:11.9
	windows-branch:11.9.0.4
	rel-6-0-2:11.7
	ansi-branch:11.9.0.2
	rel-6-0-1-branch:11.7.0.2
	hartley-6-0-post:11.8
	hartley-6-0-pre:11.7
	rel-6-0-1:11.7
	rel-6-0:11.6
	rel-5-4:11.2
	offsite-5-3-pre:11.5
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.13
date	2004.05.21.17.47.20;	author morrison;	state dead;
branches;
next	11.12;

11.12
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.11;

11.11
date	2004.04.05.07.39.54;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2003.09.27.00.58.23;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2002.08.20.17.08.29;	author jra;	state Exp;
branches
	11.9.2.1
	11.9.4.1;
next	11.8;

11.8
date	2002.08.15.20.55.42;	author hartley;	state Exp;
branches;
next	11.7;

11.7
date	2002.05.17.12.55.43;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	2001.10.17.07.40.05;	author morrison;	state Exp;
branches;
next	11.5;

11.5
date	2000.08.24.04.01.05;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	2000.07.12.21.58.31;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	2000.07.12.03.59.20;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	2000.03.29.18.29.26;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.06.39;	author mike;	state Rel4_4;
branches;
next	1.4;

1.4
date	94.11.14.22.20.25;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	94.08.09.19.39.16;	author gdurf;	state Exp;
branches;
next	1.2;

1.2
date	92.09.17.09.47.54;	author scoates;	state Exp;
branches;
next	1.1;

1.1
date	92.09.15.10.05.27;	author scoates;	state Exp;
branches;
next	;

11.9.2.1
date	2002.09.19.18.02.09;	author morrison;	state Exp;
branches;
next	11.9.2.2;

11.9.2.2
date	2004.03.17.21.22.07;	author morrison;	state Exp;
branches;
next	;

11.9.4.1
date	2004.03.11.23.46.48;	author morrison;	state Exp;
branches;
next	;


desc
@Program to create a data base of wiring or fuel lines.
@


11.13
log
@moved to src/mk/
@
text
@
/*  File:  mk_wire.c  */
/*  S.Coates - 15 September 1992  */
/*  To compile for use separately:  */
/*  cc mk_wire.c /usr/brlcad/lib/libwdb.a /usr/brlcad/lib/librt.a  */
/*	-lmpc -lm -o mk_wire  */

/*  This is a program to create wiring or fuel lines.  The user  */
/*  Enters only the coordinates of the endpoints and the radius  */
/*  of the lines.  */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <math.h>

#include "machine.h"
#include "db.h"
#include "vmath.h"
#include "raytrace.h"
#include "wdb.h"

#define MAXWIRESEG 10		/*  Maximum number of segments.  The  */
				/*  maximum may be no greater then 100  */
				/*  because of the way the name of the  */
				/*  segments is found.  */

int
main(int argc, char **argv)
{							/*  START # 1  */
   struct rt_wdb *fpw;		/*  File to be created.  */
   char filemged[26];		/*  Mged file name.  */
   double numseg;		/*  Number of segments.  */
   double strtpt[MAXWIRESEG][3];	/*  Start point of segment.  */
   double endpt[MAXWIRESEG][3];	/*  End point of segment.  */
   double strtrad[MAXWIRESEG];	/*  Radius at starting point of segment.  */
   double endrad[MAXWIRESEG];	/*  Radius at ending point of segment.  */

   char solcyl[8],regcyl[8];	/*  Solid & region name for cylinder (cone).  */
   char solsph[8],regsph[8];	/*  Solid & region name for sphere.  */
   char solsub1[8],solsub2[8];	/*  Solids that are subtracted.  */
   char group[6];		/*  Group name.  */

   point_t bs;			/*  Base of cone.  */
   vect_t dir;			/*  Direction of cone.  */
   fastf_t ht;			/*  Height of cone.  */
   fastf_t rdc1;		/*  Radius 1 of cone.  */
   fastf_t rdc2;		/*  Radius 2 of cone.  */
   point_t cent;		/*  Center of sphere.  */
   fastf_t rds;			/*  Radius of sphere.  */
   struct wmember comb;		/*  Used to make regions.  */
   struct wmember comb1;	/*  Used to make groups.  */

   int i;			/*  Loop counters.  */
   double r;			/*  Temporary variables.  */
   char temp[10];		/*  Temporary char string.  */
   char temp1[10];		/*  Temporary char string.  */

   /*  Set up solid, region, & group names.  */
   solcyl[0] = 's';
   solcyl[1] = '.';
   solcyl[2] = 'w';
   solcyl[3] = 'r';
   solcyl[4] = 'c';
   solcyl[5] = '#';
   solcyl[6] = '#';
   solcyl[7] = '\0';

   regcyl[0] = 'r';
   regcyl[1] = '.';
   regcyl[2] = 'w';
   regcyl[3] = 'r';
   regcyl[4] = 'c';
   regcyl[5] = '#';
   regcyl[6] = '#';
   regcyl[7] = '\0';

   solsph[0] = 's';
   solsph[1] = '.';
   solsph[2] = 'w';
   solsph[3] = 'r';
   solsph[4] = 's';
   solsph[5] = '#';
   solsph[6] = '#';
   solsph[7] = '\0';

   regsph[0] = 'r';
   regsph[1] = '.';
   regsph[2] = 'w';
   regsph[3] = 'r';
   regsph[4] = 's';
   regsph[5] = '#';
   regsph[6] = '#';
   regsph[7] = '\0';

   group[0] = 'w';
   group[1] = 'i';
   group[2] = 'r';
   group[3] = 'e';
   group[4] = 's';
   group[5] = '\0';

   solsub1[0] = 's';
   solsub1[1] = '.';
   solsub1[2] = 'w';
   solsub1[3] = 'r';
   solsub1[4] = 'c';
   solsub1[5] = '#';
   solsub1[6] = '#';
   solsub1[7] = '\0';

   solsub2[0] = 's';
   solsub2[1] = '.';
   solsub2[2] = 'w';
   solsub2[3] = 'r';
   solsub2[4] = 'c';
   solsub2[5] = '#';
   solsub2[6] = '#';
   solsub2[7] = '\0';

   /*  Find name of mged file to be created.  */
   (void)printf("Enter mged file name (25 char max).\n\t");
   (void)fflush(stdout);
   (void)scanf("%s",filemged);

   /*  Find the number of segments.  */
   (void)printf("Enter the number of segments (maximum of %d).\n\t",
	MAXWIRESEG);
   (void)fflush(stdout);
   (void)scanf("%lf",&numseg);

   /*  Check that the number of segments is less than or equal to the  */
   /*  maximum.  */
   while(numseg > MAXWIRESEG)
   {
	(void)printf("The maximum number of segments is %d.  Enter the\n",
		MAXWIRESEG);
	(void)printf("number of segments.\n\t");
	(void)fflush(stdout);
	(void)scanf("%lf",&numseg);
   }

   /*  Enter starting & ending points of segments & radi.  */
   for(i=0; i<numseg; i++)
   {							/*  START # 2  */
	if(i == 0)
	{						/*  START # 3  */
	   (void)printf("Enter starting point of segment # %d.\n\t",(i+1));
	   (void)fflush(stdout);
	   (void)scanf("%lf %lf %lf",&strtpt[i][0],&strtpt[i][1],
		&strtpt[i][2]);
	   (void)printf("Enter radius at the starting point of ");
	   (void)printf("segment # %d.\n\t",(i+1));
	   (void)fflush(stdout);
	   (void)scanf("%lf",&strtrad[i]);
	   (void)printf("Enter ending point of segment # %d.\n\t",(i+1));
	   (void)fflush(stdout);
	   (void)scanf("%lf %lf %lf",&endpt[i][0],&endpt[i][1],&endpt[i][2]);
	   (void)printf("Enter radius at the ending point of ");
	   (void)printf("segment # %d.\n\t",(i+1));
	   (void)fflush(stdout);
	   (void)scanf("%lf",&endrad[i]);
	}						/*  END # 3  */

	else
	{						/*  START # 4  */
	   strtpt[i][0] = endpt[i - 1][0];
	   strtpt[i][1] = endpt[i - 1][1];
	   strtpt[i][2] = endpt[i - 1][2];
	   strtrad[i] = endrad[i - 1];
	   (void)printf("Enter ending point of segment # %d.\n\t",(i+1));
	   (void)fflush(stdout);
	   (void)scanf("%lf %lf %lf",&endpt[i][0],&endpt[i][1],&endpt[i][2]);
	   (void)printf("Enter radius at the ending point of ");
	   (void)printf("segment # %d.\n\t",(i+1));
	   (void)fflush(stdout);
	   (void)scanf("%lf",&endrad[i]);
	}						/*  END # 4  */
   }							/*  END # 2  */

   /*  Print out all info.  */
   (void)printf("\n\nmged file created:  %s\n",filemged);
   (void)fflush(stdout);

   /*  Print out coordinates of segments.  */
   for(i=0; i<numseg; i++)
   {							/*  START # 5  */
	(void)printf("Segment # %d:  ",(i+1));
	(void)printf("(%f,%f,%f)", strtpt[i][0],strtpt[i][1],strtpt[i][2]);
        (void)printf(" %f\n", strtrad[i]);
	(void)printf("              ");
	(void)printf("(%f,%f,%f)", endpt[i][0],endpt[i][1],endpt[i][2]);
	(void)printf("%f\n",endrad[i]);
	(void)fflush(stdout);
   }							/*  END # 5  */

   /*  Open mged file.  */
   fpw = wdb_fopen(filemged);

   /*  Write ident record.  */
   mk_id(fpw,"Wiring");

   /*  Create solids.  */

   /*  Create solid for each segment.  */
   for(i=0; i<numseg; i++)
   {							/*  START # 10  */
	/*  Base of cone.  */
	bs[0] = (fastf_t)strtpt[i][0];
	bs[1] = (fastf_t)strtpt[i][1];
	bs[2] = (fastf_t)strtpt[i][2];

	/*  Direction of cone (unit vector).  */
	r = (endpt[i][0] - strtpt[i][0]) * (endpt[i][0] - strtpt[i][0])
	  + (endpt[i][1] - strtpt[i][1]) * (endpt[i][1] - strtpt[i][1])
	  + (endpt[i][2] - strtpt[i][2]) * (endpt[i][2] - strtpt[i][2]);
	r = sqrt(r);
	dir[0] = (fastf_t)( (endpt[i][0] - strtpt[i][0]) / r);
	dir[1] = (fastf_t)( (endpt[i][1] - strtpt[i][1]) / r);
	dir[2] = (fastf_t)( (endpt[i][2] - strtpt[i][2]) / r);

	/*  Height of cone.  */
	ht = (fastf_t)r;

	/*  Radius 1 of cone.  */
	rdc1 = (fastf_t)strtrad[i];

	/*  Radius 2 of cone.  */
	rdc2 = (fastf_t)endrad[i];

	/*  Fill in correct number in solid name.  */
	(void)sprintf(temp,"%d",i);
	if(i < 10)
	{						/*  START # 11  */
	   solcyl[5] = '0';
	   solcyl[6] = temp[0];
	}						/*  END # 11  */
	else if( (10 <= i) || (i < 100) )
	{						/*  START # 12  */
	   solcyl[5] = temp[0];
	   solcyl[6] = temp[1];
	}						/*  END # 12  */
	else
	{						/*  START # 13  */
	   (void)printf("** ERROR ** i = %d\n",i);
	   (void)fflush(stdout);
	}						/*  END # 13  */

	/*  Make cylinder.  */
	mk_cone(fpw,solcyl,bs,dir,ht,rdc1,rdc2);

   }							/*  END # 10  */

   /*  Create solid for each sphere.  */
   for(i=1; i<numseg; i++)

   /*  Sphere 0 does not exist since there is one less sphere  */
   /*  than segment.  */

   {							/*  START # 20  */
	/*  Center of sphere.  */
	cent[0] = (fastf_t)strtpt[i][0];
	cent[1] = (fastf_t)strtpt[i][1];
	cent[2] = (fastf_t)strtpt[i][2];

	/*  Radius of sphere.  */
	rds = (fastf_t)strtrad[i];

	/*  Fill in correct number in solid name.  */
	(void)sprintf(temp,"%d",i);
	if(i < 10)
	{						/*  START # 21  */
	   solsph[5] = '0';
	   solsph[6] = temp[0];
	}						/*  END # 21  */
	else if( (10 <= i) || (i < 100) )
	{						/*  START # 22  */
	   solsph[5] = temp[0];
	   solsph[6] = temp[1];
	}						/*  END # 22  */
	else
	{						/*  START # 23  */
	   (void)printf("** ERROR ** i = %d\n",i);
	   (void)fflush(stdout);
	}						/*  END # 23  */

	/*  Make sphere.  */
	mk_sph(fpw,solsph,cent,rds);
   }							/*  END # 20  */

   /*  Create regions.  */

   /*  Initialize list.  */
   BU_LIST_INIT(&comb.l);

   /*  Create region for each segment.  */

   for(i=0; i<numseg; i++)
   {							/*  START # 30  */
	/*  Fill in correct number in region & solid names.  */
	(void)sprintf(temp,"%d",i);
	(void)sprintf(temp1,"%d",(i+1));

	if(i < 10)
	{						/*  START # 31  */
	   solcyl[5] = '0';
	   solcyl[6] = temp[0];
	   regcyl[5] = '0';
	   regcyl[6] = temp[0];

	   if(i < (numseg - 1) )
	   {						/*  START # 32  */
		if( (i + 1) < 10)
		{					/*  START # 33  */
		   solsub1[5] = '0';
		   solsub1[6] = temp1[0];
		}					/*  END # 33  */
		else
		{					/*  START # 34  */
		   solsub1[5] = temp1[0];
		   solsub1[6] = temp1[1];
		}					/*  END # 34  */
	   }						/*  END # 32  */
	}						/*  END # 31  */

	else if( (10 <= i) || (i < 100) )
	{						/*  START # 35  */
	   solcyl[5] = temp[0];
	   solcyl[6] = temp[1];
	   regcyl[5] = temp[0];
	   regcyl[6] = temp[1];

	   if(i < (numseg - 1) )
	   {						/*  START # 36  */
		solsub1[5] = temp1[0];
		solsub1[6] = temp1[1];
	   }						/*  END # 36  */
	}						/*  END # 35  */

	else
	{						/*  START # 37  */
	   (void)printf("** ERROR ** i = %d\n",i);
	   (void)fflush(stdout);
	}						/*  END # 37  */

	(void)mk_addmember(solcyl,&comb.l, NULL, WMOP_INTERSECT);

	if(i < (numseg - 1) )
	{						/*  START # 38  */
	   (void)mk_addmember(solsub1,&comb.l, NULL, WMOP_SUBTRACT);
	}						/*  END # 38  */

	mk_lfcomb(fpw,regcyl,&comb,1);
   }							/*  END # 30  */

   /*  Create region for each sphere.  */
   for(i=1; i<numseg; i++)
   {							/*  START # 40  */
	/*  Fill in correct region & solid names.  */
	(void)sprintf(temp,"%d",i);
	(void)sprintf(temp1,"%d",(i - 1));

	if(i < 10)
	{						/*  START # 41  */
	   solsph[5] = '0';
	   solsph[6] = temp[0];
	   regsph[5] = '0';
	   regsph[6] = temp[0];
	   solsub1[5] = '0';
	   solsub1[6] = temp1[0];
	   solsub2[5] = '0';
	   solsub2[6] = temp[0];
	}						/*  END # 41  */

	else if( (10 <= i) || (i < 100) )
	{						/*  START # 42  */
	   solsph[5] = temp[0];
	   solsph[6] = temp[1];
	   regsph[5] = temp[0];
	   regsph[6] = temp[1];
	   solsub1[5] = temp1[0];
	   solsub1[6] = temp1[1];
	   solsub2[5] = temp[0];
	   solsub2[6] = temp[1];
	}						/*  END # 42  */

	else
	{						/*  START # 43  */
	   (void)printf("** ERROR ** i = %d\n",i);
	   (void)fflush(stdout);
	}						/*  END # 43  */

	(void)mk_addmember(solsph,&comb.l, NULL, WMOP_INTERSECT);
	(void)mk_addmember(solsub1,&comb.l, NULL, WMOP_SUBTRACT);
	(void)mk_addmember(solsub2,&comb.l, NULL, WMOP_SUBTRACT);

	mk_lfcomb(fpw,regsph,&comb,1);
   }							/*  END # 40  */

   /*  Create group.  */

   /*  Initialize list.  */
   BU_LIST_INIT(&comb1.l);

   for(i=0; i<numseg; i++)
   {							/*  START # 50  */
	(void)sprintf(temp,"%d",i);

	if(i < 10)
	{						/*  START # 51  */
	   regcyl[5] = '0';
	   regcyl[6] = temp[0];
	   if(i != 0)
	   {						/*  START # 52  */
		regsph[5] = '0';
		regsph[6] = temp[0];
	   }						/*  END # 52  */
	}						/*  END # 51  */

	else if( (10 <= i) || (i < 100) )
	{						/*  START # 53  */
	   regcyl[5] = temp[0];
	   regcyl[6] = temp[1];
	   regsph[5] = temp[0];
	   regsph[6] = temp[1];
	}						/*  END # 53  */

	else
	{						/*  START # 54  */
	   (void)printf("** ERROR ** i = %d\n",i);
	   (void)fflush(stdout);
	}						/*  END # 54  */

	(void)mk_addmember(regcyl,&comb1.l, NULL, WMOP_UNION);
	if(i != 0)(void)mk_addmember(regsph,&comb1.l, NULL, WMOP_UNION);
   }							/*  END # 50  */

   mk_lfcomb(fpw,group,&comb1,0);
   wdb_close(fpw);
   return 0;
}							/*  END # 1  */
@


11.12
log
@change conf.h to a wrapped config.h
@
text
@@


11.11
log
@merge of ansi-6-0-branch into HEAD
@
text
@d12 5
a16 1
#include "conf.h"
@


11.10
log
@renamed the MAXSEG #define as it conflicts with an AIX symbol
@
text
@d37 1
a37 5
main(argc,argv)

int argc;
char *argv[];

@


11.9
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d31 1
a31 1
#define MAXSEG 10		/*  Maximum number of segments.  The  */
d46 4
a49 4
   double strtpt[MAXSEG][3];	/*  Start point of segment.  */
   double endpt[MAXSEG][3];	/*  End point of segment.  */
   double strtrad[MAXSEG];	/*  Radius at starting point of segment.  */
   double endrad[MAXSEG];	/*  Radius at ending point of segment.  */
d140 1
a140 1
	MAXSEG);
d146 1
a146 1
   while(numseg > MAXSEG)
d149 1
a149 1
		MAXSEG);
@


11.9.4.1
log
@sync to HEAD...
@
text
@d31 1
a31 1
#define MAXWIRESEG 10		/*  Maximum number of segments.  The  */
d46 4
a49 4
   double strtpt[MAXWIRESEG][3];	/*  Start point of segment.  */
   double endpt[MAXWIRESEG][3];	/*  End point of segment.  */
   double strtrad[MAXWIRESEG];	/*  Radius at starting point of segment.  */
   double endrad[MAXWIRESEG];	/*  Radius at ending point of segment.  */
d140 1
a140 1
	MAXWIRESEG);
d146 1
a146 1
   while(numseg > MAXWIRESEG)
d149 1
a149 1
		MAXWIRESEG);
@


11.9.2.1
log
@Initial ANSIfication
@
text
@d37 5
a41 1
main(int argc, char **argv)
@


11.9.2.2
log
@sync branch with HEAD
@
text
@d31 1
a31 1
#define MAXWIRESEG 10		/*  Maximum number of segments.  The  */
d42 4
a45 4
   double strtpt[MAXWIRESEG][3];	/*  Start point of segment.  */
   double endpt[MAXWIRESEG][3];	/*  End point of segment.  */
   double strtrad[MAXWIRESEG];	/*  Radius at starting point of segment.  */
   double endrad[MAXWIRESEG];	/*  Radius at ending point of segment.  */
d136 1
a136 1
	MAXWIRESEG);
d142 1
a142 1
   while(numseg > MAXWIRESEG)
d145 1
a145 1
		MAXWIRESEG);
@


11.8
log
@Converted from K&R to ANSI C - RFH
@
text
@d37 5
a41 1
main(int argc, char **argv)
@


11.7
log
@added matrix parameter to mk_addmember()
@
text
@d37 1
a37 5
main(argc,argv)

int argc;
char *argv[];

@


11.6
log
@Mac OS X warning and error fixes for non-production build
@
text
@d358 1
a358 1
	(void)mk_addmember(solcyl,&comb.l,WMOP_INTERSECT);
d362 1
a362 1
	   (void)mk_addmember(solsub1,&comb.l,WMOP_SUBTRACT);
d405 3
a407 3
	(void)mk_addmember(solsph,&comb.l,WMOP_INTERSECT);
	(void)mk_addmember(solsub1,&comb.l,WMOP_SUBTRACT);
	(void)mk_addmember(solsub2,&comb.l,WMOP_SUBTRACT);
d446 2
a447 2
	(void)mk_addmember(regcyl,&comb1.l,WMOP_UNION);
	if(i != 0)(void)mk_addmember(regsph,&comb1.l,WMOP_UNION);
@


11.5
log
@
mk_addmember
@
text
@d201 2
a202 2
	(void)printf("(%f,%f,%f) %f\n",
		strtpt[i][0],strtpt[i][1],strtpt[i][2],strtrad[i]);
d204 2
a205 2
	(void)printf("(%f,%f,%f) %f\n",
		endpt[i][0],endpt[i][1],endpt[i][2],endrad[i]);
@


11.4
log
@
Converted to use new version of LIBWDB.
@
text
@d358 1
a358 1
	(void)mk_addmember(solcyl,&comb,WMOP_INTERSECT);
d362 1
a362 1
	   (void)mk_addmember(solsub1,&comb,WMOP_SUBTRACT);
d405 3
a407 3
	(void)mk_addmember(solsph,&comb,WMOP_INTERSECT);
	(void)mk_addmember(solsub1,&comb,WMOP_SUBTRACT);
	(void)mk_addmember(solsub2,&comb,WMOP_SUBTRACT);
d446 2
a447 2
	(void)mk_addmember(regcyl,&comb1,WMOP_UNION);
	if(i != 0)(void)mk_addmember(regsph,&comb1,WMOP_UNION);
@


11.3
log
@
Now need raytrace.h for wdb.h
@
text
@d43 1
a43 1
   FILE *fpw;			/*  File to be created.  */
d210 1
a210 1
   fpw = fopen(filemged,"w");
d451 1
@


11.2
log
@
RT_LIST to BU_LIST
@
text
@d28 1
@


11.1
log
@Release_4.4
@
text
@d305 1
a305 1
   RT_LIST_INIT(&comb.l);
d414 1
a414 1
   RT_LIST_INIT(&comb1.l);
@


1.4
log
@Irix 6
@
text
@@


1.3
log
@Added include of conf.h
,.
@
text
@d65 2
a66 2
   int i,j,k;			/*  Loop counters.  */
   double r,s,t;		/*  Temporary variables.  */
@


1.2
log
@Remove path name from include statements.
@
text
@d12 2
d15 1
d17 2
d20 3
d35 1
d450 1
a450 1

@


1.1
log
@Initial revision
@
text
@d17 4
a20 4
#include "/usr/brlcad/include/machine.h"
#include "/usr/brlcad/include/db.h"
#include "/usr/brlcad/include/vmath.h"
#include "/usr/brlcad/include/wdb.h"
@
