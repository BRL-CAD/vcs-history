head	11.22;
access;
symbols
	ansi-20040405-merged:11.19.4.1
	postmerge-20040405-ansi:11.20
	premerge-20040404-ansi:11.20
	postmerge-autoconf:11.20
	autoconf-freeze:11.19.12.1
	premerge-autoconf:11.20
	postmerge-20040315-windows:11.20
	premerge-20040315-windows:11.19
	windows-20040315-freeze:11.19.6.2
	autoconf-20031203:11.19
	autoconf-20031202:11.19
	autoconf-branch:11.19.0.12
	phong-branch:11.19.0.10
	photonmap-branch:11.19.0.8
	rel-6-1-DP:11.19
	windows-branch:11.19.0.6
	rel-6-0-2:11.19
	ansi-branch:11.19.0.4
	rel-6-0-1-branch:11.19.0.2
	hartley-6-0-post:11.19
	hartley-6-0-pre:11.19
	rel-6-0-1:11.19
	rel-6-0:11.18
	rel-5-4:11.13
	offsite-5-3-pre:11.14
	rel-5-3:11.13
	rel-5-2:11.13
	rel-5-1-branch:11.13.0.2
	rel-5-1:11.13
	rel-5-0:11.7
	rel-5-0-beta:11.7
	rel-4-5:11.3
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.22
date	2004.05.21.17.47.07;	author morrison;	state dead;
branches;
next	11.21;

11.21
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.20;

11.20
date	2004.03.16.21.24.36;	author morrison;	state Exp;
branches;
next	11.19;

11.19
date	2002.05.08.13.55.38;	author jra;	state Exp;
branches
	11.19.4.1
	11.19.6.1
	11.19.12.1;
next	11.18;

11.18
date	2002.02.19.21.42.39;	author butler;	state Exp;
branches;
next	11.17;

11.17
date	2001.12.05.14.54.57;	author bparker;	state Exp;
branches;
next	11.16;

11.16
date	2001.08.09.19.58.22;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	2001.05.17.20.05.40;	author morrison;	state Exp;
branches;
next	11.14;

11.14
date	2000.08.24.23.10.00;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	2000.05.22.15.57.54;	author pjt;	state Exp;
branches;
next	11.12;

11.12
date	2000.02.22.16.47.10;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	2000.01.31.16.22.28;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	2000.01.07.04.38.08;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	99.11.10.14.17.18;	author pjt;	state Exp;
branches;
next	11.8;

11.8
date	99.11.08.20.26.44;	author pjt;	state Exp;
branches;
next	11.7;

11.7
date	99.03.29.17.17.58;	author pjt;	state Exp;
branches;
next	11.6;

11.6
date	98.12.29.03.31.34;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	98.12.09.17.55.12;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	98.04.21.15.45.32;	author pjt;	state Exp;
branches;
next	11.3;

11.3
date	97.12.05.20.56.02;	author pjt;	state Exp;
branches;
next	11.2;

11.2
date	97.12.04.18.54.12;	author pjt;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.22.13;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.08.24.14.05.42;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.04.05.10.47.54;	author pjt;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.53.28;	author mike;	state Rel4_0;
branches;
next	1.16;

1.16
date	91.07.29.10.52.52;	author pjt;	state Exp;
branches;
next	1.15;

1.15
date	91.07.24.11.19.58;	author pjt;	state Exp;
branches;
next	1.14;

1.14
date	91.07.23.14.48.16;	author pjt;	state Exp;
branches;
next	1.13;

1.13
date	91.07.18.16.15.17;	author pjt;	state Exp;
branches;
next	1.12;

1.12
date	91.07.18.14.46.51;	author pjt;	state Exp;
branches;
next	1.11;

1.11
date	91.07.18.00.22.02;	author butler;	state Exp;
branches;
next	1.10;

1.10
date	91.07.06.05.08.26;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	91.07.02.23.51.15;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	91.06.18.12.29.47;	author pjt;	state Exp;
branches;
next	1.7;

1.7
date	91.03.01.16.13.30;	author pjt;	state Exp;
branches;
next	1.6;

1.6
date	91.02.25.16.18.02;	author pjt;	state Exp;
branches;
next	1.5;

1.5
date	91.02.21.16.12.23;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	91.02.15.16.02.20;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	91.02.14.09.22.32;	author pjt;	state Exp;
branches;
next	1.2;

1.2
date	91.02.14.08.49.40;	author pjt;	state Exp;
branches;
next	1.1;

1.1
date	91.02.11.09.55.32;	author pjt;	state Exp;
branches;
next	;

11.19.4.1
date	2004.03.17.21.22.07;	author morrison;	state Exp;
branches;
next	;

11.19.6.1
date	2002.09.26.23.04.14;	author morrison;	state Exp;
branches;
next	11.19.6.2;

11.19.6.2
date	2004.03.12.17.40.59;	author morrison;	state Exp;
branches;
next	;

11.19.12.1
date	2004.03.18.18.10.31;	author erikg;	state Exp;
branches;
next	;


desc
@NIRT for BRL-CAD
@


11.22
log
@moved to src/nirt/
@
text
@/*      COMMAND.C       */ 
#ifndef lint
static const char RCSid[] = "$Header: /n/xoff/cvs/brlcad/nirt/command.c,v 11.21 2004/05/10 15:30:49 erikg Exp $";
#endif

/*	INCLUDES	*/
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <ctype.h>
#if USE_STRING_H
# include <string.h>
#else
# include <strings.h>
#endif

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "externs.h"
#include "../librt/debug.h"
#include "./nirt.h"
#include "./usrfmt.h"

char		local_u_name[64];
double		base2local;		/* from db_i struct, not fastf_t */
double		local2base;		/* from db_i struct, not fastf_t */

extern fastf_t			bsphere_diameter;
extern int			do_backout;
extern int			silent_flag;
extern struct application	ap;
extern struct rt_i		*rti_tab[];	/* For use w/ and w/o air */
extern struct resource		res_tab[];	/* For use w/ and w/o air */
extern com_table		ComTab[];
extern outval			ValTab[];
extern int			overlap_claims;
extern char			*ocname[];
extern int			nirt_debug;
extern int			rt_bot_minpieces;	/* grom g_bot.c */

void		printusage();
void		do_rt_gettrees();

void
bot_minpieces(char *buffer, com_table *ctp )
{
	int new_value;
	int i=0;

	while (isspace(*(buffer+i)))
		++i;
	if (*(buffer+i) == '\0')     /* display current rt_bot_minpieces */
	{
		bu_log( "rt_bot_minpieces = %d\n", rt_bot_minpieces );
		return;
	}

	new_value = atoi( buffer );

	if( new_value < 0 ) {
		bu_log( "Error: rt_bot_minpieces cannot be less than 0\n" );
		return;
	}

	if( new_value != rt_bot_minpieces ) {
		rt_bot_minpieces = new_value;
		need_prep = 1;
	}
}

void az_el(buffer, ctp)
char			*buffer;
com_table		*ctp;
{
	extern int 	str_dbl();  /* function to convert  string to  double */
	int 		i = 0;      /* current position on the *buffer        */
	int		rc = 0;     /* the return code value from str_dbl()   */
	double		az;
	double  	el;

	while (isspace(*(buffer+i)))
		++i;
	if (*(buffer+i) == '\0')     /* display current az and el values */
	{
		bu_log("(az, el) = (%4.2f, %4.2f)\n",
		    azimuth(), elevation());
		return;
	}
	if ((rc = str_dbl(buffer+i, &az)) == 0)  /* get az value */
	{
		com_usage(ctp);
		return;
	}
	if (abs(az) > 360)       /* check for valid az value */
	{
		bu_log("Error:  |azimuth| <= 360\n"); 
		return;
	}
	i += rc; 
	while (isspace(*(buffer+i)))
		++i;
	if ((rc = str_dbl(buffer+i, &el)) == 0)  /* get el value */
	{
		com_usage(ctp);
		return;
	}
	if (abs(el) > 90)       /* check for valid el value */
	{
		bu_log("Error:  |elevation| <= 90\n"); 
		return;
	}
	i += rc; 
	if (*(buffer+i) != '\0')  /* check for garbage at the end of the line */
	{
		com_usage(ctp);
		return;
	}
	azimuth() = az;     
	elevation() = el;
	ae2dir();
}

void sh_esc (buffer)
char	*buffer;
{
  static char	*shell = "";
  static char	*last_cmd = "";

  while (isspace(*buffer)) {
    ++buffer;
  }

  if (*buffer == '!') {
    (void) system(last_cmd);
  } else if (*buffer) {
    (void) system(buffer);
    last_cmd = buffer;
  } else {
    if ((*shell == '\0') && (shell = getenv("SHELL")) == 0) {
#ifndef WIN32
      shell = DFLT_SHELL;
#else
      shell = "cmd.exe";
#endif
    }
    (void) system(shell);
  }
}

void grid_coor(buffer, ctp)
char			*buffer;
com_table		*ctp;
{
	extern int 	str_dbl();  /* function to convert  string to  double */
	int 		i = 0;
	int		rc = 0;    /* the return code value from str_dbl() */
	vect_t	        Gr;

	while (isspace(*(buffer+i)))
		++i;
	if (*(buffer+i) == '\0')    /* display current grid coordinates */
	{
		bu_log("(h,v,d) = (%4.2f, %4.2f, %4.2f)\n",
			grid(HORZ) * base2local,
			grid(VERT) * base2local,
			grid(DIST) * base2local);
		return;
	}
	if ((rc = str_dbl(buffer+i, &Gr[HORZ])) == 0) /* get horz coor */
	{
		com_usage(ctp);
		return;
	}
	i += rc; 
	while (isspace(*(buffer+i)))
		++i;
	if ((rc = str_dbl(buffer+i, &Gr[VERT])) == 0) /* get vert coor */
	{
		com_usage(ctp);
		return;
	}
	i += rc; 
	while (isspace(*(buffer+i)))
		++i;
	if (*(buffer+i) == '\0')   /* if there is no dist coor, set default */
	{
		grid(HORZ) = Gr[HORZ] * local2base;
		grid(VERT) = Gr[VERT] * local2base;
		grid2targ();
		return;
	}
	if ((rc = str_dbl(buffer+i, &Gr[DIST])) == 0) /* set dist coor */
	{
		com_usage(ctp);
		return;
	}
	i += rc; 
	if (*(buffer+i) != '\0') /* check for garbage at the end of the line */
	{
		com_usage(ctp);
		return;
	}
	grid(HORZ) = Gr[HORZ] * local2base;
	grid(VERT) = Gr[VERT] * local2base;
	grid(DIST) = Gr[DIST] * local2base;
	grid2targ();
}

void target_coor(buffer, ctp)
char			*buffer;
com_table		*ctp;
{
	extern int 	str_dbl();  /* function to convert string to double */
	int 		i = 0;
	int		rc = 0;     /* the return code value from str_dbl() */
	vect_t		Tar;	    /* Target x, y and z          	    */

	while (isspace(*(buffer+i)))
		++i;
	if (*(buffer+i) == '\0')         /* display current target coors */
	{
		bu_log("(x,y,z) = (%4.2f, %4.2f, %4.2f)\n",
			    target(X) * base2local,
			    target(Y) * base2local,
			    target(Z) * base2local);
		return;
	}
	if ((rc = str_dbl(buffer+i, &Tar[X])) == 0)  /* get target x coor */
	{
		com_usage(ctp);
		return;
	}
	i += rc; 
	while (isspace(*(buffer+i)))
		++i;
	if ((rc = str_dbl(buffer+i, &Tar[Y])) == 0)  /* get target y coor */
	{
		com_usage(ctp);
		return;
	}
	i += rc; 
	while (isspace(*(buffer+i)))
		++i;
	if ((rc = str_dbl(buffer+i, &Tar[Z])) == 0)    /* get target z coor */
	{
		com_usage(ctp);
		return;
	}
	i += rc; 
	if (*(buffer+i) != '\0') /* check for garbage at the end of the line */
	{
		com_usage(ctp);
		return;
	}
	target(X) = Tar[X] * local2base;
	target(Y) = Tar[Y] * local2base;
	target(Z) = Tar[Z] * local2base;
	targ2grid();
}	


void dir_vect(buffer, ctp)
char			*buffer;
com_table		*ctp;
{
	extern int 	str_dbl();  /* function to convert  string to  double */
	int 		i = 0;
	int		rc = 0;    /* the return code value from str_dbl() */
	vect_t		Dir;	   /* Direction vector x, y and z          */

	while (isspace(*(buffer+i)))
		++i;
	if (*(buffer+i) == '\0')         /* display current direct coors */
	{
		bu_log("(x,y,z) = (%4.2f, %4.2f, %4.2f)\n",
			    direct(X), direct(Y), direct(Z));
		return;
	}
	if ((rc = str_dbl(buffer+i, &Dir[X])) == 0)  /* get direct x coor */
	{
		com_usage(ctp);
		return;
        }
	i += rc; 
	while (isspace(*(buffer+i)))
		++i;
	if ((rc = str_dbl(buffer+i, &Dir[Y])) == 0)  /* get direct y coor */
	{
		com_usage(ctp);
		return;
	}
	i += rc; 
	while (isspace(*(buffer+i)))
		++i;
	if ((rc = str_dbl(buffer+i, &Dir[Z])) == 0)    /* get direct z coor */
	{
		com_usage(ctp);
		return;
	}
	i += rc; 
	if (*(buffer+i) != '\0') /* check for garbage at the end of the line */
	{
		com_usage(ctp);
		return;
	}
	VUNITIZE( Dir );
	direct(X) = Dir[X];
	direct(Y) = Dir[Y];
	direct(Z) = Dir[Z];
        dir2ae();
}

void quit()
{
	if (silent_flag != SILENT_YES)
	    (void) fputs("Quitting...\n", stdout);
	exit (0);
}

void show_menu(buffer)
char	*buffer;
{
	com_table	*ctp;

	for (ctp = ComTab; ctp -> com_name; ++ctp)
	    (void) bu_log("%*s %s\n", -14, ctp -> com_name, ctp -> com_desc);
}

void shoot(buffer, ctp)
char			*buffer;
int			ctp;
{
    int		i;

    extern void	init_ovlp();

    if (need_prep) {
	if (rtip) rt_clean(rtip);
	do_rt_gettrees(rtip, NULL, NULL);
    }



    if (do_backout)
    {
	backout();
#if 0
	do_backout = 0;
#endif
    }

    for (i = 0; i < 3; ++i)
    {
	ap.a_ray.r_pt[i] = target(i);
	ap.a_ray.r_dir[i] = direct(i);
    }

    init_ovlp();
    (void) rt_shootray( &ap );
}

void use_air(buffer, ctp)

char			*buffer;
com_table		*ctp;

{
    int			new_use = 0;      /* current position on the *buffer */
    char		response[128];
    char		*rp = response;
    char		db_title[TITLE_LEN+1];	/* title from MGED database */
    struct rt_i		*rtip;

    extern char	*db_name;		/* Name of MGED database file */

    while (isspace(*buffer))
	    ++buffer;
    if (*buffer == '\0')     /* display current value of use_of_air */
    {
	bu_log("use_air = %d\n", ap.a_rt_i -> useair);
	return;
    }
    if (!isdigit(*buffer))
    {
	com_usage(ctp);
	return;
    }
    while (isdigit(*buffer))
    {
	new_use *= 10;
	new_use += *buffer++ - '0';
    }
    if (new_use && (new_use != 1))
    {
	bu_log("Warning: useair=%d specified, will set to 1\n",
	    new_use);
	new_use = 1;
    }
    if (rti_tab[new_use] == RTI_NULL)
    {
	bu_log(" Air %s in the current directory of database objects.\n",
	    new_use ? "is not included" : "is included");
	bu_log(
	    " To set useair=%d requires building/prepping another directory.\n",
	    new_use);
	bu_log(" Do you want to do that now (y|n)[n]? ");
	fgets(response, sizeof(response), stdin);
	while ((*rp == ' ') || (*rp == '\t'))
	    ++rp;
	if ((*rp != 'y') && (*rp != 'Y'))
	{
	    bu_log("useair remains %d\n", ap.a_rt_i -> useair);
	    return;
	}
	bu_log("Building the directory...");
	if ((rtip = rt_dirbuild( db_name , db_title, TITLE_LEN )) == RTI_NULL)
	{
	    bu_log("Could not load file %s\n", db_name);
	    printusage();
	    exit(1);
	}
	rti_tab[new_use] = rtip;
	rtip -> useair = new_use;
	rtip -> rti_save_overlaps = (overlap_claims > 0);

	bu_log("Prepping the geometry...");
	do_rt_gettrees(rtip, NULL, 0);
    }
    ap.a_rt_i = rti_tab[new_use];
    ap.a_resource = &res_tab[new_use];
    set_diameter(ap.a_rt_i);
}

void nirt_units (buffer, ctp)

char		*buffer;
com_table	*ctp;

{
    double		tmp_dbl;
    int			i = 0;      /* current position on the *buffer */
    extern struct rt_i	*rtip;

    double		mk_cvt_factor();

    while (isspace(*(buffer+i)))
	    ++i;
    if (*(buffer+i) == '\0')     /* display current destination */
    {
	bu_log("units = '%s'\n", local_u_name);
	return;
    }
    
    if (strcmp(buffer + i, "?") == 0)
    {
	com_usage(ctp);
	return;
    }
    else if (strcmp(buffer + i, "default") == 0)
    {
	base2local = rtip -> rti_dbip -> dbi_base2local;
	local2base = rtip -> rti_dbip -> dbi_local2base;
	strncpy(local_u_name, bu_units_string(base2local), 64);
    }
    else
    {
	if ((tmp_dbl = bu_units_conversion(buffer + i)) == 0.0)
	{
	    bu_log("Invalid unit specification: '%s'\n", buffer + i);
	    return;
	}
	strncpy(local_u_name, buffer + i, 64);
	local2base = tmp_dbl;
	base2local = 1.0 / tmp_dbl;
    }
}

void do_overlap_claims (buffer, ctp)

char		*buffer;
com_table	*ctp;

{
    int			i = 0;      /* current position on the *buffer */
    int			j;
    double		mk_cvt_factor();

    while (isspace(*(buffer+i)))
	    ++i;
    if (*(buffer+i) == '\0')     /* display current destination */
    {
	bu_log("overlap_claims = '%s'\n", ocname[overlap_claims]);
	return;
    }
    
    if (strcmp(buffer + i, "?") == 0)
    {
	com_usage(ctp);
	return;
    }
    for (j = OVLP_RESOLVE; j <= OVLP_RETAIN; ++j)
    {
	char	numeral[4];
	int	k;

	sprintf(numeral, "%d", j);
	if ((strcmp(buffer + i, ocname[j]) == 0)
	  || (strcmp(buffer + i, numeral) == 0))
	{
	    overlap_claims = j;
	    for (k = 0; k < 2; ++k)
		if (rti_tab[k] != RTI_NULL)
		    rti_tab[k] -> rti_save_overlaps = (j > 0);
	    return;
	}
    }

    bu_log("Invalid overlap_claims specification: '%s'\n", buffer + i);
}

void
cm_attr(buffer, ctp)
char		*buffer;
com_table	*ctp;
{
    while (isascii(*buffer) && isspace(*buffer)) buffer++;

    if (strlen(buffer) == 0) {
	com_usage(ctp);
	return;
    }

    if (! strncmp(buffer, "-p", 2) ) {
	attrib_print();
	return;
    }

    if (! strncmp(buffer, "-f", 2) ) {
	attrib_flush();
	return;
    }

    attrib_add(buffer);
}


void
cm_debug(buffer, ctp)
char		*buffer;
com_table	*ctp;
{
	register char	*cp = buffer;

	/* This is really icky -- should have argc, argv interface */
	while( *cp && isascii(*cp) && isspace(*cp) )  cp++;
	if (*cp == '\0')
	{
	    /* display current value */
	    bu_printb( "debug ", nirt_debug, DEBUG_FMT );
	    bu_log("\n");
	    return;
	}

	/* Set a new value */
	if (sscanf( cp, "%x", (unsigned int *)&nirt_debug ) == 1)
	{
	    bu_printb( "debug ", nirt_debug, DEBUG_FMT );
	    bu_log("\n");
	}
	else
	    com_usage(ctp);
}

void
cm_libdebug(buffer, ctp)
char		*buffer;
com_table	*ctp;
{
	register char	*cp = buffer;

	/* This is really icky -- should have argc, argv interface */
	while( *cp && isascii(*cp) && isspace(*cp) )  cp++;
	if (*cp == '\0')
	{
	    /* display current value */
	    bu_printb( "libdebug ", RT_G_DEBUG, RT_DEBUG_FMT );
	    bu_log("\n");
	    return;
	}

	/* Set a new value */
	if (sscanf( cp, "%x", (unsigned int *)&rt_g.debug ) == 1)
	{
	    bu_printb( "libdebug ", RT_G_DEBUG, RT_DEBUG_FMT );
	    bu_log("\n");
	}
	else
	    com_usage(ctp);
}

void backout(buffer, ctp)
char			*buffer;
int			ctp;
{
    int		i;

    int		(*phc)();	/* Previous hit callback */
    int		(*pmc)();	/* Previous miss callback */
    int		(*poc)();	/* Previous overlap callback */
    int		if_bhit();	/* Backout hit callback */
    int		if_bmiss();	/* Backout miss callback */
    int		if_boverlap();	/* Backout overlap callback */
    /*
     *	Record previous callbacks
     */
    phc = ap.a_hit;
    pmc = ap.a_miss;
    poc = ap.a_overlap;

    /*
     *	Prepare to fire the backing-out ray
     */
    for (i = 0; i < 3; ++i)
    {
	ap.a_ray.r_pt[i] = target(i);
	ap.a_ray.r_dir[i] = -direct(i);
    }
    ap.a_hit = if_bhit;
    ap.a_miss = if_bmiss;
    ap.a_overlap = if_boverlap;
    if (nirt_debug & DEBUG_BACKOUT)
	bu_log("Backing out from (%g %g %g) via (%g %g %g)\n",
	       ap.a_ray.r_pt[0] * base2local,
	       ap.a_ray.r_pt[1] * base2local,
	       ap.a_ray.r_pt[2] * base2local,
	       V3ARGS(ap.a_ray.r_dir));

    (void) rt_shootray( &ap );

    /*
     *	Reset the callbacks the way we found them
     */
    ap.a_hit = phc;
    ap.a_miss = pmc;
    ap.a_overlap = poc;
}
@


11.21
log
@change conf.h to a wrapped config.h
@
text
@d3 1
a3 1
static const char RCSid[] = "$Header: /cvs/brlcad/nirt/command.c,v 11.20 2004/03/16 21:24:36 morrison Exp $";
@


11.20
log
@merge of windows-6-0-branch into head
@
text
@d3 1
a3 1
static const char RCSid[] = "$Header$";
d7 5
a11 1
#include "conf.h"
@


11.19
log
@Added support for rt_bot_minpieces
@
text
@d3 1
a3 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/command.c,v 11.18 2002/02/19 21:42:39 butler Exp $";
d127 2
a128 2
	static char	*shell = "";
	static char	*last_cmd = "";
d130 19
a148 15
	while (isspace(*buffer))
	    ++buffer;
	if (*buffer == '!')
	    (void) system(last_cmd);
	else if (*buffer)
	{
	    (void) system(buffer);
	    last_cmd = buffer;
	}
	else
	{
	    if ((*shell == '\0') && (shell = getenv("SHELL")) == 0)
		shell = DFLT_SHELL;
	    (void) system(shell);
	}
@


11.19.12.1
log
@merge from head
@
text
@d3 1
a3 1
static const char RCSid[] = "$Header$";
d127 2
a128 2
  static char	*shell = "";
  static char	*last_cmd = "";
d130 15
a144 19
  while (isspace(*buffer)) {
    ++buffer;
  }

  if (*buffer == '!') {
    (void) system(last_cmd);
  } else if (*buffer) {
    (void) system(buffer);
    last_cmd = buffer;
  } else {
    if ((*shell == '\0') && (shell = getenv("SHELL")) == 0) {
#ifndef WIN32
      shell = DFLT_SHELL;
#else
      shell = "cmd.exe";
#endif
    }
    (void) system(shell);
  }
@


11.19.4.1
log
@sync branch with HEAD
@
text
@d3 1
a3 1
static const char RCSid[] = "$Header$";
d127 2
a128 2
  static char	*shell = "";
  static char	*last_cmd = "";
d130 15
a144 19
  while (isspace(*buffer)) {
    ++buffer;
  }

  if (*buffer == '!') {
    (void) system(last_cmd);
  } else if (*buffer) {
    (void) system(buffer);
    last_cmd = buffer;
  } else {
    if ((*shell == '\0') && (shell = getenv("SHELL")) == 0) {
#ifndef WIN32
      shell = DFLT_SHELL;
#else
      shell = "cmd.exe";
#endif
    }
    (void) system(shell);
  }
@


11.19.6.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d3 1
a3 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/command.c,v 11.19 2002/05/08 13:55:38 jra Exp $";
d142 2
a143 5
#ifndef WIN32
		shell = DFLT_SHELL
#else
		shell = "cmd.exe";
#endif	    (void) system(shell);
@


11.19.6.2
log
@reformat and readd missing semicolon
@
text
@d3 1
a3 1
static const char RCSid[] = "$Header$";
d127 2
a128 2
  static char	*shell = "";
  static char	*last_cmd = "";
d130 12
a141 11
  while (isspace(*buffer)) {
    ++buffer;
  }

  if (*buffer == '!') {
    (void) system(last_cmd);
  } else if (*buffer) {
    (void) system(buffer);
    last_cmd = buffer;
  } else {
    if ((*shell == '\0') && (shell = getenv("SHELL")) == 0) {
d143 1
a143 1
      shell = DFLT_SHELL;
d145 3
a147 5
      shell = "cmd.exe";
#endif
    }
    (void) system(shell);
  }
@


11.18
log
@Added support for printing attributes
@
text
@d3 1
a3 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/command.c,v 11.17 2001/12/05 14:54:57 bparker Exp $";
d40 1
d44 27
@


11.17
log
@*- no longer resetting do_backout in the shoot() routine
@
text
@d3 1
a3 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/command.c,v 11.16 2001/08/09 19:58:22 jra Exp $";
d306 7
d489 26
@


11.16
log
@lint
@
text
@d3 1
a3 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/command.c,v 11.15 2001/05/17 20:05:40 morrison Exp $";
d309 1
d311 1
@


11.15
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d3 1
a3 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/command.c,v 11.14 2000/08/24 23:10:00 mike Exp $";
d41 3
a443 1
    double		tmp_dbl;
a445 2
    extern struct rt_i	*rtip;

d499 1
a499 1
	if (sscanf( cp, "%x", &nirt_debug ) == 1)
d526 1
a526 1
	if (sscanf( cp, "%x", &rt_g.debug ) == 1)
@


11.14
log
@
lint
@
text
@d3 1
a3 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/command.c,v 11.13 2000/05/22 15:57:54 pjt Exp $";
d520 1
a520 1
	    bu_printb( "libdebug ", rt_g.debug, RT_DEBUG_FMT );
d528 1
a528 1
	    bu_printb( "libdebug ", rt_g.debug, RT_DEBUG_FMT );
@


11.13
log
@Added support for overlap claimants
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/command.c,v 11.12 2000/02/22 16:47:10 jra Exp $";
@


11.12
log
@
Corrected bug in backout command (needed an overlap handler of its own).
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/command.c,v 11.11 2000/01/31 16:22:28 jra Exp $";
d37 2
d292 1
a292 1
	    (void) bu_log("%*s %s\n", -10, ctp -> com_name, ctp -> com_desc);
d381 1
d433 46
@


11.11
log
@Eliminated some unused variables
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/command.c,v 11.10 2000/01/07 04:38:08 mike Exp $";
d494 1
d497 1
a497 2


d503 1
d515 1
d530 1
@


11.10
log
@
Eliminated dbi_localunit
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/command.c,v 11.9 1999/11/10 14:17:18 pjt Exp $";
a490 2
    point_t	point;
    vect_t	direction;
@


11.9
log
@In order to silence the compile warnings,
no longer redefine DEBUG_FORMAT (defined by ../librt/debug.h).
Instead, pass RT_DEBUG_FMT for libdebug, and DEBUG_FMT for debug.
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/command.c,v 11.8 1999/11/08 20:26:44 pjt Exp $";
a24 4
char		*local_unit[] = {
		    "none", "mm", "um", "cm", "m", "km",
		    "in", "ft", "yd", "mi", "unknown"
		};
a414 2
	strncpy(local_u_name, local_unit[rtip -> rti_dbip -> dbi_localunit],
	    64);
d417 1
d421 1
a421 1
	if ((tmp_dbl = mk_cvt_factor(buffer + i)) == 0.0)
a429 91
}
static struct cvt_tab {
	double	val;
	char	name[32];
} mk_cvt_tab[] = {
	1.0e-7,		"angstrom",
	1.0e-7,		"angstroms",
	1.0e-7,		"decinanometer",
	1.0e-7,		"decinanometers",
	1.0e-6,		"nm",
	1.0e-6,		"nanometer",
	1.0e-6,		"nanometers",
	1.0e-3,		"micron",
	1.0e-3,		"microns",
	1.0e-3,		"micrometer",
	1.0e-3,		"micrometers",
	1.0,		"mm",
	1.0,		"millimeter",
	1.0,		"millimeters",
	10.0,		"cm",
	10.0,		"centimeter",
	10.0,		"centimeters",
	1000.0,		"m",
	1000.0,		"meter",
	1000.0,		"meters",
	1000000.0,	"km",
	1000000.0,	"kilometer",
	1000000.0,	"kilometers",
	25.4,		"in",
	25.4,		"inche",
	25.4,		"inches",
	304.8,		"ft",
	304.8,		"foot",
	304.8,		"feet",
	456.2,		"cubit",
	456.2,		"cubits",
	914.4,		"yd",
	914.4,		"yard",
	914.4,		"yards",
	5029.2,		"rd",
	5029.2,		"rod",
	5029.2,		"rods",
	1609344.0,	"mi",
	1609344.0,	"mile",
	1609344.0,	"miles",
	1852000.0,	"nmile",
	1852000.0,	"nautical mile",
	0.0,		"",			/* LAST ENTRY */
};

/*
 *			M K _ C V T _ F A C T O R
 *
 *  Given a string representation of a unit of distance (eg, "feet"),
 *  return the number which will convert that unit into milimeters.
 *
 *  Returns -
 *	0.0	error
 *	>0.0	success
 */
double
mk_cvt_factor(str)
char	*str;
{
	register char	*ip, *op;
	register int	c;
	register struct cvt_tab	*tp;
	char		ubuf[64];

	if( strlen(str) >= sizeof(ubuf)-1 )  str[sizeof(ubuf)-1] = '\0';

	/* Copy the given string, making it lower case */
	ip = str;
	op = ubuf;
	while( (c = *ip++) )  {
		if( !isascii(c) )
			*op++ = '_';
		else if( isupper(c) )
			*op++ = tolower(c);
		else
			*op++ = c;
	}
	*op = '\0';

	/* Search for this string in the table */
	for( tp=mk_cvt_tab; tp->name[0]; tp++ )  {
		if( ubuf[0] != tp->name[0] )  continue;
		if( strcmp( ubuf, tp->name ) != 0 )  continue;
		return( tp->val );
	}
	return(0.0);		/* Unable to find it */
@


11.8
log
@1. Fixed (nonfatal) unit-printout bug that merely announced wrong
    model units
2. Added 'debug' command
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/command.c,v 11.7 1999/03/29 17:17:58 pjt Exp $";
d540 1
a540 1
	    bu_printb( "debug ", nirt_debug, DEBUG_FORMAT );
d548 1
a548 1
	    bu_printb( "debug ", nirt_debug, DEBUG_FORMAT );
d567 1
a567 1
	    bu_printb( "libdebug ", rt_g.debug, RT_DEBUG_FORMAT );
d575 1
a575 1
	    bu_printb( "libdebug ", rt_g.debug, RT_DEBUG_FORMAT );
@


11.7
log
@Replaced separate calls of rt_gettree() for each object
with a single call of rt_gettrees() for all objects.
This runs faster and allows elimination of struct nirt_obj
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/command.c,v 11.6 1998/12/29 03:31:34 mike Exp $";
d26 1
a26 1
		    "none", "um", "mm", "cm", "m", "km",
d529 27
d567 1
a567 1
	    rt_printb( "libdebug ", rt_g.debug, DEBUG_FORMAT );
d575 1
a575 1
	    rt_printb( "libdebug ", rt_g.debug, DEBUG_FORMAT );
@


11.6
log
@Fixed gets()
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/command.c,v 11.5 1998/12/09 17:55:12 bparker Exp $";
a38 1
extern struct nirt_obj		object_list;
a331 1
    struct nirt_obj	*op;
d374 1
a374 1
	bu_log("Building the directory...");fflush(stderr);
d384 2
a385 3
	bu_log("Prepping the geometry...");fflush(stderr);
	for (op = &object_list; op -> obj_next != NULL; op = op -> obj_next)
	    do_rt_gettree( rtip, op -> obj_name, 0);
@


11.5
log
@*- spew out debug info in local units
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/command.c,v 11.4 1998/04/21 15:45:32 pjt Exp $";
d368 1
a368 1
	gets(response);
@


11.4
log
@Added the new local units (i.e., um, km, yd, mi) to local_unit[]
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/command.c,v 11.3 1997/12/05 20:56:02 pjt Exp $";
d590 4
a593 1
	    V3ARGS(ap.a_ray.r_pt), V3ARGS(ap.a_ray.r_dir));
@


11.3
log
@Fixed backout().  It now fires a backing-out ray
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /n/vapor/m/cad/nirt/RCS/command.c,v 11.2 1997/12/04 18:54:12 pjt Exp $";
d26 2
a27 1
		    "none", "mm", "cm", "m", "in", "ft", "unknown"
@


11.2
log
@1) Implemented -b option
2) Fixed bug in show_menu() caused by switch from fprintf() to bu_log()
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/command.c,v 11.1 95/01/04 10:22:13 mike Rel4_4 $";
d41 1
d565 4
a568 1
    double	dist_default();  /* computes grid[DIST] default val*/
d570 28
a597 3
    targ2grid();
    grid(DIST) = bsphere_diameter;
    grid2targ();
@


11.1
log
@Release_4.4
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/command.c,v 10.3 94/08/24 14:05:42 gdurf Exp $";
d33 1
d56 1
a56 1
		rt_log("(az, el) = (%4.2f, %4.2f)\n",
d67 1
a67 1
		rt_log("Error:  |azimuth| <= 360\n"); 
d80 1
a80 1
		rt_log("Error:  |elevation| <= 90\n"); 
d130 1
a130 1
		rt_log("(h,v,d) = (%4.2f, %4.2f, %4.2f)\n",
d189 1
a189 1
		rt_log("(x,y,z) = (%4.2f, %4.2f, %4.2f)\n",
d242 1
a242 1
		rt_log("(x,y,z) = (%4.2f, %4.2f, %4.2f)\n",
d293 1
a293 1
	    (void) rt_log("%-10s %s\n", ctp -> com_name, ctp -> com_desc);
d304 6
d339 1
a339 1
	rt_log("use_air = %d\n", ap.a_rt_i -> useair);
d354 1
a354 1
	rt_log("Warning: useair=%d specified, will set to 1\n",
d360 1
a360 1
	rt_log(" Air %s in the current directory of database objects.\n",
d362 1
a362 1
	rt_log(
d365 1
a365 1
	rt_log(" Do you want to do that now (y|n)[n]? ");
d371 1
a371 1
	    rt_log("useair remains %d\n", ap.a_rt_i -> useair);
d374 1
a374 4
#if 0
	rt_log("Building the directory...");fflush(stdout);
#endif
	rt_log("Building the directory...");fflush(stderr);
d377 1
a377 1
	    rt_log("Could not load file %s\n", db_name);
d384 1
a384 4
#if 0
	rt_log("\nPrepping the geometry...");fflush(stdout);
#endif
	rt_log("Prepping the geometry...");fflush(stderr);
d409 1
a409 1
	rt_log("units = '%s'\n", local_u_name);
d429 1
a429 1
	    rt_log("Invalid unit specification: '%s'\n", buffer + i);
d542 1
a542 1
	    rt_log("\n");
d550 1
a550 1
	    rt_log("\n");
@


10.3
log
@Factored ifdefs
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/command.c,v 10.2 1994/04/05 10:47:54 pjt Exp gdurf $";
@


10.2
log
@implemented -v command-line option and enhanced silent_flag
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/command.c,v 10.1 91/10/12 06:53:28 mike Rel4_0 $";
d7 3
d11 3
a13 1
#if BSD
a14 2
#else
# include <string.h>
d16 1
a16 1
#include <stdio.h>
@


10.1
log
@Release_4.0
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/command.c,v 1.16 91/07/29 10:52:52 pjt Exp $";
d278 1
a278 1
	if (! silent_flag)
@


1.16
log
@Added initializing call of targ2grid()
in backout().
This because the command sequence "xyz", "ae", "backout"
backed in the desired direction, but from the wrong point.
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/command.c,v 1.15 91/07/24 11:19:58 pjt Exp $";
@


1.15
log
@Implemented short (non-verbose) mode
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/command.c,v 1.14 91/07/23 14:48:16 pjt Exp $";
d562 1
@


1.14
log
@void set_radius() became void set_diameter()
and fastf_t bsphere_radius became fastf_t bsphere_diameter
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/command.c,v 1.13 91/07/18 16:15:17 pjt Exp $";
d30 1
d278 2
a279 1
	(void) fputs("Quitting...\n", stdout);
@


1.13
log
@Switched from dist_def.c approach
to bsphere.c
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/command.c,v 1.12 91/07/18 14:46:51 pjt Exp $";
d29 1
a29 1
extern fastf_t			bsphere_radius;
d384 1
a384 1
    set_radius(ap.a_rt_i);
d560 1
a560 1
    grid(DIST) = 2 * bsphere_radius;
@


1.12
log
@Added the backout command
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/command.c,v 1.11 91/07/18 00:22:02 butler Exp $";
d29 1
d384 1
d560 1
a560 1
    grid(DIST) = dist_default();     /* extreme of the target */
@


1.11
log
@substituted rt_log for (f)printf, rt_malloc for malloc.
plugged memory leak with regard to dest_string.
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/command.c,v 1.10 91/07/06 05:08:26 mike Exp $";
a149 1
		dist_default();
d546 14
@


1.10
log
@On older BSD systems, must use <strings.h>, not <string.h>
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/command.c,v 1.9 91/07/02 23:51:15 mike Exp $";
d50 1
a50 1
		printf("(az, el) = (%4.2f, %4.2f)\n",
d61 1
a61 1
		fprintf(stderr, "Error:  |azimuth| <= 360\n"); 
d74 1
a74 1
		fprintf(stderr, "Error:  |elevation| <= 90\n"); 
d124 1
a124 1
		printf("(h,v,d) = (%4.2f, %4.2f, %4.2f)\n",
d184 1
a184 1
		printf("(x,y,z) = (%4.2f, %4.2f, %4.2f)\n",
d237 1
a237 1
		printf("(x,y,z) = (%4.2f, %4.2f, %4.2f)\n",
d287 1
a287 1
	    (void) printf("%-10s %s\n", ctp -> com_name, ctp -> com_desc);
d303 1
d327 1
a327 1
	printf("use_air = %d\n", ap.a_rt_i -> useair);
d342 1
a342 2
	fprintf(stderr,
	    "Warning: useair=%d specified, will set to 1\n",
d348 1
a348 1
	printf(" Air %s in the current directory of database objects.\n",
d350 1
a350 1
	printf(
d353 1
a353 1
	printf(" Do you want to do that now (y|n)[n]? ");
d359 1
a359 1
	    printf("useair remains %d\n", ap.a_rt_i -> useair);
d363 1
a363 1
	printf("Building the directory...");fflush(stdout);
d365 1
a365 1
	fprintf(stderr, "Building the directory...");fflush(stderr);
d368 1
a368 2
	    fflush(stdout);
	    fprintf(stderr, "Could not load file %s\n", db_name);
d376 1
a376 1
	printf("\nPrepping the geometry...");fflush(stdout);
d378 1
a378 1
	fprintf(stderr, "Prepping the geometry...");fflush(stderr);
d402 1
a402 1
	printf("units = '%s'\n", local_u_name);
d422 1
a422 1
	    fprintf(stderr, "Invalid unit specification: '%s'\n", buffer + i);
@


1.9
log
@Added externs.h, for getenv()
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/command.c,v 1.8 91/06/18 12:29:47 pjt Exp $";
d8 5
a12 1
#include <string.h>
@


1.8
log
@Only do a getenv("SHELL") once,
not each time user escapes to shell.
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/command.c,v 1.7 91/03/01 16:13:30 pjt Exp $";
d10 4
a13 3
#include <machine.h>
#include <vmath.h>
#include <raytrace.h>
@


1.7
log
@Added extern struct resource res_tab[] analogous to
      extern struct rt_i     rti_tab[]
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/command.c,v 1.6 91/02/25 16:18:02 pjt Exp $";
d86 1
a86 1
	char		*shell;
d98 6
a103 3
	else if ((shell = getenv("SHELL")) == 0)
	    shell = DFLT_SHELL;
	(void) system(shell);
d287 1
@


1.6
log
@Hacked the libdebug command to behave more like the existing commands.
I'd like to get the behavior of a modified rt_printb(), if it's
worth it.
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/command.c,v 1.5 91/02/21 16:12:23 mike Exp $";
d26 1
a373 1
	/* XXX ap.a_resource needs to be set here */
d375 1
@


1.5
log
@Added "libdebug" command, to allow rt_g.debug to be set interactively,
like -x command on command line.
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/command.c,v 1.4 91/02/15 16:02:20 mike Exp $";
d522 6
a527 5
	if( *cp == '\0' )  {
		/* display current value */
		rt_printb( "librt rt_g.debug", rt_g.debug, DEBUG_FORMAT );
		rt_log("\n");
		return;
d531 7
a537 3
	sscanf( cp, "%x", &rt_g.debug );
	rt_printb( "librt rt_g.debug", rt_g.debug, DEBUG_FORMAT );
	rt_log("\n");
@


1.4
log
@Converted to Cake
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/command.c,v 1.3 91/02/14 09:22:32 pjt Exp $";
d13 1
a87 2
	char		*getenv();

d373 1
d511 22
@


1.3
log
@
Attempt to add $Header$ to file.
@
text
@d3 1
a3 1
static char RCSid[] = "$Header$";
d13 2
a14 2
#include "nirt.h"
#include "usrfmt.h"
@


1.2
log
@Finished implementing the function use_air().
@
text
@d2 3
@


1.1
log
@Initial revision
@
text
@d22 1
d301 6
a306 1
    int		new_use = 0;      /* current position on the *buffer        */
d308 2
d312 1
a312 1
    if (*buffer == '\0')     /* display current use_air value */
d327 45
a371 1
    ap.a_rt_i = rti_tab[new_use != 0];
@
