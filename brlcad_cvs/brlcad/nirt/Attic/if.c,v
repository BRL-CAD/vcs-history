head	11.21;
access;
symbols
	ansi-20040405-merged:11.18.2.1
	postmerge-20040405-ansi:11.19
	premerge-20040404-ansi:11.18
	postmerge-autoconf:11.18
	autoconf-freeze:11.18
	premerge-autoconf:11.18
	postmerge-20040315-windows:11.18
	premerge-20040315-windows:11.18
	windows-20040315-freeze:11.18
	autoconf-20031203:11.18
	autoconf-20031202:11.18
	autoconf-branch:11.18.0.10
	phong-branch:11.18.0.8
	photonmap-branch:11.18.0.6
	rel-6-1-DP:11.18
	windows-branch:11.18.0.4
	rel-6-0-2:11.16
	ansi-branch:11.18.0.2
	rel-6-0-1-branch:11.16.0.2
	hartley-6-0-post:11.17
	hartley-6-0-pre:11.16
	rel-6-0-1:11.16
	rel-6-0:11.16
	rel-5-4:11.10.2.1
	offsite-5-3-pre:11.12
	rel-5-3:11.10.2.1
	rel-5-2:11.10
	rel-5-1-branch:11.10.0.2
	rel-5-1:11.10
	rel-5-0:11.5
	rel-5-0-beta:11.5
	rel-4-5:11.3
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.21
date	2004.05.21.17.47.08;	author morrison;	state dead;
branches;
next	11.20;

11.20
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.19;

11.19
date	2004.04.05.07.39.41;	author morrison;	state Exp;
branches;
next	11.18;

11.18
date	2002.08.20.17.08.30;	author jra;	state Exp;
branches
	11.18.2.1;
next	11.17;

11.17
date	2002.08.15.20.55.43;	author hartley;	state Exp;
branches;
next	11.16;

11.16
date	2002.02.20.21.06.21;	author butler;	state Exp;
branches;
next	11.15;

11.15
date	2002.02.19.21.42.39;	author butler;	state Exp;
branches;
next	11.14;

11.14
date	2001.12.13.19.14.30;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	2001.08.09.19.58.22;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	2001.01.05.19.11.08;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	2000.08.24.23.10.00;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	2000.05.22.15.57.26;	author pjt;	state Exp;
branches
	11.10.2.1;
next	11.9;

11.9
date	2000.02.22.16.47.10;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	2000.01.31.16.22.28;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	99.11.08.20.25.49;	author pjt;	state Exp;
branches;
next	11.6;

11.6
date	99.10.07.18.50.27;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	98.12.09.17.59.29;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	98.03.27.07.41.30;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	97.12.05.20.56.11;	author pjt;	state Exp;
branches;
next	11.2;

11.2
date	97.02.07.15.04.50;	author pjt;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.22.15;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.12.21.10.28.44;	author pjt;	state Exp;
branches;
next	10.2;

10.2
date	94.08.24.14.06.11;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.53.30;	author mike;	state Rel4_0;
branches;
next	1.9;

1.9
date	91.08.29.14.17.26;	author pjt;	state Exp;
branches;
next	1.8;

1.8
date	91.07.30.11.04.52;	author pjt;	state Exp;
branches;
next	1.7;

1.7
date	91.07.18.00.23.03;	author butler;	state Exp;
branches;
next	1.6;

1.6
date	91.07.03.01.14.51;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	91.03.15.08.35.09;	author pjt;	state Exp;
branches;
next	1.4;

1.4
date	91.02.15.16.02.29;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	91.02.14.09.29.13;	author pjt;	state Exp;
branches;
next	1.2;

1.2
date	91.02.14.08.58.12;	author pjt;	state Exp;
branches;
next	1.1;

1.1
date	91.02.11.09.55.53;	author pjt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	91.02.14.09.24.53;	author pjt;	state Exp;
branches;
next	;

11.10.2.1
date	2001.01.05.19.10.42;	author jra;	state Exp;
branches;
next	;

11.18.2.1
date	2002.09.19.18.02.10;	author morrison;	state Exp;
branches;
next	;


desc
@@


11.21
log
@moved to src/nirt/
@
text
@/*      IF.C            */
#ifndef lint
static const char RCSid[] = "$Header: /n/xoff/cvs/brlcad/nirt/if.c,v 11.20 2004/05/10 15:30:49 erikg Exp $";
#endif

/*	INCLUDES	*/
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "./nirt.h"
#include "./usrfmt.h"

extern outval		ValTab[];
extern int		nirt_debug;
extern int		overlap_claims;
extern double		base2local;
extern double		local2base;
overlap			ovlp_list;

overlap			*find_ovlp(struct partition *pp);
void			del_ovlp(overlap *op);
void			init_ovlp(void);

extern int	rt_defoverlap( struct application *ap, struct partition *pp, struct region *reg1, struct region *reg2, struct partition *pheadp );
	

int if_hit(struct application *ap, struct partition *part_head, struct seg *finished_segs)
{
    struct partition	*part;
    char		*basename(char *string);
    fastf_t		ar = azimuth() * deg2rad;
    fastf_t		er = elevation() * deg2rad;
    int			i;
    int			part_nm = 0;
    overlap		*ovp;	/* the overlap record for this partition */
    point_t		inormal;
    point_t		onormal;
    struct bu_vls	claimant_list;	/* Names of the claiming regions */
    int			need_to_free = 0;	/* Clean up the bu_vls? */
    fastf_t		get_obliq(fastf_t *ray, fastf_t *normal);
    struct bu_vls       *vls;
    struct bu_vls       attr_vls;
    struct bu_mro **attr_values;

    report(FMT_RAY);
    report(FMT_HEAD);
    if (overlap_claims == OVLP_REBUILD_FASTGEN)
	rt_rebuild_overlaps(part_head, ap, 1);
    else if (overlap_claims == OVLP_REBUILD_ALL)
	rt_rebuild_overlaps(part_head, ap, 0);
#if 0
    rt_pr_partitions( ap->a_rt_i, part_head, " ...At top of for loop:" );
#endif
    for (part = part_head -> pt_forw; part != part_head; part = part -> pt_forw)
    {
	++part_nm;

	RT_HIT_NORMAL( inormal, part->pt_inhit, part->pt_inseg->seg_stp,
		&ap->a_ray, part->pt_inflip );
	RT_HIT_NORMAL( onormal, part->pt_outhit, part->pt_outseg->seg_stp,
		&ap->a_ray, part->pt_outflip );

	/* Update the output values */
	/*
	 *	WARNING -
	 *		  target, grid, direct, az, and el
	 *		  should be updated by the functions
	 *		  in command.c as well
	 */
	for (i = 0; i < 3; ++i)
	{
	    r_entry(i) = part-> pt_inhit -> hit_point[i];
	    r_exit(i) = part-> pt_outhit -> hit_point[i];
	    n_entry(i) = inormal[i];
	    n_exit(i) = onormal[i];
	}
	if (nirt_debug & DEBUG_HITS)
	{
	    bu_log("Partition %d entry: (%g, %g, %g) exit: (%g, %g, %g)\n",
		part_nm, r_entry(X), r_entry(Y), r_entry(Z),
			 r_exit(X),  r_exit(Y),  r_exit(Z));
	}

	r_entry(D) = r_entry(X) * cos(er) * cos(ar)
		    + r_entry(Y) * cos(er) * sin(ar)
		    + r_entry(Z) * sin(er);
	r_exit(D) = r_exit(X) * cos(er) * cos(ar)
		    + r_exit(Y) * cos(er) * sin(ar)
		    + r_exit(Z) * sin(er);
	n_entry(D) = n_entry(X) * cos(er) * cos(ar)
		    + n_entry(Y) * cos(er) * sin(ar)
		    + n_entry(Z) * sin(er);
	n_entry(H) = n_entry(X) * (-sin(ar))
		    + n_entry(Y) * cos(ar);
	n_entry(V) = n_entry(X) * (-sin(er)) * cos(ar)
		    + n_entry(Y) * (-sin(er)) * sin(ar)
		    + n_entry(Z) * cos(er);
	n_exit(D) = n_exit(X) * cos(er) * cos(ar)
		    + n_exit(Y) * cos(er) * sin(ar)
		    + n_exit(Z) * sin(er);
	n_exit(H) = n_exit(X) * (-sin(ar))
		    + n_exit(Y) * cos(ar);
	n_exit(V) = n_exit(X) * (-sin(er)) * cos(ar)
		    + n_exit(Y) * (-sin(er)) * sin(ar)
		    + n_exit(Z) * cos(er);
	ValTab[VTI_LOS].value.fval = r_entry(D) - r_exit(D);
	ValTab[VTI_SLOS].value.fval = 0.01 * ValTab[VTI_LOS].value.fval *
	    part -> pt_regionp -> reg_los;
	ValTab[VTI_PATH_NAME].value.sval =
	    (char *)(part -> pt_regionp -> reg_name);
	ValTab[VTI_REG_NAME].value.sval =
	    basename(part -> pt_regionp -> reg_name);
	ValTab[VTI_REG_ID].value.ival = part -> pt_regionp -> reg_regionid;
	ValTab[VTI_SURF_NUM_IN].value.ival = part -> pt_inhit -> hit_surfno;
	ValTab[VTI_SURF_NUM_OUT].value.ival = part -> pt_outhit -> hit_surfno;
	ValTab[VTI_OBLIQ_IN].value.fval =
	    get_obliq(ap -> a_ray.r_dir, inormal);
	ValTab[VTI_OBLIQ_OUT].value.fval =
	    get_obliq(ap -> a_ray.r_dir, onormal);
#if 0
	if (*(part -> pt_overlap_reg) == REGION_NULL)
#else
	if (part -> pt_overlap_reg == 0)
#endif
	{
	    ValTab[VTI_CLAIMANT_COUNT].value.ival = 1;
	    ValTab[VTI_CLAIMANT_LIST].value.sval =
	    ValTab[VTI_CLAIMANT_LISTN].value.sval =
		basename(part -> pt_regionp -> reg_name);
	}
	else
	{
	    struct region	**rpp;
	    char		*cp;

	    bu_vls_init(&claimant_list);
	    ValTab[VTI_CLAIMANT_COUNT].value.ival = 0;
	    for (rpp = part -> pt_overlap_reg; *rpp != REGION_NULL; ++rpp)
	    {
		if (ValTab[VTI_CLAIMANT_COUNT].value.ival++)
		    bu_vls_strcat(&claimant_list, " ");
		bu_vls_strcat(&claimant_list, basename((*rpp) -> reg_name));
	    }
	    ValTab[VTI_CLAIMANT_LIST].value.sval =
		bu_vls_addr(&claimant_list);
	    ValTab[VTI_CLAIMANT_LISTN].value.sval =
		bu_vls_strdup(&claimant_list);
	    for (cp = ValTab[VTI_CLAIMANT_LISTN].value.sval;
		*cp != '\0'; ++cp)
		if (*cp == ' ')
		    *cp = '\n';
	    need_to_free = 1;
	}

	/* format up the attribute strings into a single string */
	bu_vls_init(&attr_vls);
	attr_values = part->pt_regionp->attr_values;
	for (i=0 ; i < a_tab.attrib_use ; i++) {

	    BU_CK_MRO(attr_values[i]);
	    vls = &attr_values[i]->string_rep;

	    if (bu_vls_strlen(vls) > 0) {
		/* XXX only print attributes that actually were set */
		bu_vls_printf(&attr_vls, "%s=%S ", a_tab.attrib[i], vls);
	    }
	}

	ValTab[VTI_ATTRIBUTES].value.sval = bu_vls_addr(&attr_vls);

	/* Do the printing for this partition */
	report(FMT_PART);

	if (need_to_free)
	{
	    bu_vls_free(&claimant_list);
	    bu_free(ValTab[VTI_CLAIMANT_LISTN].value.sval,
		"returned by bu_vls_strdup");
	    need_to_free = 0;
	}

	while ((ovp = find_ovlp(part)) != OVERLAP_NULL)
	{
	    ValTab[VTI_OV_REG1_NAME].value.sval =
		basename(ovp -> reg1 -> reg_name);
	    ValTab[VTI_OV_REG1_ID].value.ival = ovp -> reg1 -> reg_regionid;
	    ValTab[VTI_OV_REG2_NAME].value.sval =
		basename(ovp -> reg2 -> reg_name);
	    ValTab[VTI_OV_REG2_ID].value.ival = ovp -> reg2 -> reg_regionid;
	    ValTab[VTI_OV_SOL_IN].value.sval =
		(char *)(part -> pt_inseg -> seg_stp -> st_dp -> d_namep);
	    ValTab[VTI_OV_SOL_OUT].value.sval =
		(char *)(part -> pt_outseg -> seg_stp -> st_dp -> d_namep);
	    for (i = 0; i < 3; ++i)
	    {
		ov_entry(i) = ovp -> in_point[i];
		ov_exit(i) = ovp -> out_point[i];
	    }
	    ov_entry(D) = target(D) - ovp -> in_dist;
	    ov_exit(D) = target(D) - ovp -> out_dist;
	    ValTab[VTI_OV_LOS].value.fval = ov_entry(D) - ov_exit(D);
	    report(FMT_OVLP);
	    del_ovlp(ovp);
	}
    }
    report(FMT_FOOT);
    if (ovlp_list.forw != &ovlp_list)
    {
	fprintf(stderr, "Previously unreported overlaps.  Shouldn't happen\n");
    	ovp = ovlp_list.forw;
    	while( ovp != &ovlp_list )
    	{
		bu_log( " OVERLAP:\n\t%s %s (%g %g %g) %g\n",ovp -> reg1 -> reg_name, ovp -> reg2 -> reg_name, V3ARGS( ovp->in_point ), ovp->out_dist - ovp->in_dist );
    	    ovp = ovp->forw;
    	}
    }

    bu_vls_free(&attr_vls);


    return( HIT );
}

int if_miss(void)
{ 
    report(FMT_RAY);
    report(FMT_MISS);
    return ( MISS );
}

/*
 *			I F _ O V E R L A P
 *
 *  Default handler for overlaps in rt_boolfinal().
 *  Returns -
 *	 0	to eliminate partition with overlap entirely
 *	!0	to retain partition in output list
 *
 *	Stolen out of:	spark.brl.mil:/m/cad/librt/bool.c
 *	Stolen by:	Paul Tanenbaum
 *	Date stolen:	29 March 1990
 */
int
if_overlap(register struct application *ap, register struct partition *pp, struct region *reg1, struct region *reg2, struct partition *InputHdp)
{
    overlap	*new_ovlp;

    /* N. B. rt_malloc() only returns on successful allocation */
    new_ovlp = (overlap *) rt_malloc(sizeof(overlap), "new_ovlp");

    new_ovlp -> ap = ap;
    new_ovlp -> pp = pp;
    new_ovlp -> reg1 = reg1;
    new_ovlp -> reg2 = reg2;
    new_ovlp -> in_dist = pp -> pt_inhit -> hit_dist;
    new_ovlp -> out_dist = pp -> pt_outhit -> hit_dist;
    VJOIN1(new_ovlp -> in_point, ap->a_ray.r_pt, pp->pt_inhit->hit_dist,
	ap->a_ray.r_dir );
    VJOIN1(new_ovlp -> out_point, ap->a_ray.r_pt, pp->pt_outhit->hit_dist,
	ap->a_ray.r_dir );

    /* Insert the new overlap into the list of overlaps */
    new_ovlp -> forw = ovlp_list.forw;
    new_ovlp -> backw = &ovlp_list;
    new_ovlp -> forw -> backw = new_ovlp;
    ovlp_list.forw = new_ovlp;

    /* Match current BRL-CAD default behavior */
    return( rt_defoverlap (ap, pp, reg1, reg2, InputHdp ) );
}

/*
 *
 *		The callbacks used by backup()
 *
 */
int if_bhit(struct application *ap, struct partition *part_head, struct seg *finished_segs)
{
    struct partition	*part;
    vect_t		dir;
    point_t		point;
    int			i;

    if ((part = part_head -> pt_back) == part_head)
    {
	bu_log("if_bhit() got empty partition list.  Shouldn't happen\n");
	exit (1);
    }

    /* calculate exit point */
    VJOIN1(part->pt_outhit->hit_point, ap->a_ray.r_pt, part->pt_outhit->hit_dist, ap->a_ray.r_dir);

    if (nirt_debug & DEBUG_BACKOUT)
    {
	bu_log("Backmost region is '%s'\n", part->pt_regionp->reg_name);
	bu_log("Backout ray exits at (%g %g %g)\n",
	       part->pt_outhit->hit_point[0] * base2local,
	       part->pt_outhit->hit_point[1] * base2local,
	       part->pt_outhit->hit_point[2] * base2local);
    }

    for (i = 0; i < 3; ++i)
	dir[i] = -direct(i);
    VJOIN1(point, part -> pt_outhit -> hit_point, BACKOUT_DIST, dir);

    if (nirt_debug & DEBUG_BACKOUT)
	bu_log("Point %g beyond is (%g %g %g)\n",
	       BACKOUT_DIST,
	       point[0] * base2local,
	       point[1] * base2local,
	       point[2] * base2local);

    for (i = 0; i < 3; ++i)
	target(i) = point[i];
    targ2grid();

    return( HIT );
}

int if_bmiss(void)
{ 
    return ( MISS );
}

fastf_t get_obliq (fastf_t *ray, fastf_t *normal)
{
    double	cos_obl;
    fastf_t	obliquity;

    cos_obl = abs(VDOT(ray, normal) * MAGNITUDE(normal) / MAGNITUDE(ray));
    if (cos_obl < 1.001)
    { 
	if (cos_obl > 1)
		cos_obl = 1;
	obliquity = acos(cos_obl);
    }
    else
    {
	fflush(stdout);
	fprintf (stderr, "Error:  cos(obliquity) > 1\n");
    	obliquity = 0;
	exit(1);
    }

    /* convert obliquity to degrees */
    obliquity = abs(obliquity * 180/PI); 
    if (obliquity > 90 && obliquity <= 180)
	    obliquity = 180 - obliquity;
    else if (obliquity > 180 && obliquity <= 270)
	    obliquity = obliquity - 180;
    else if (obliquity > 270 && obliquity <= 360)
	    obliquity = 360 - obliquity;
    
    return (obliquity);
}

overlap *find_ovlp (struct partition *pp)
{
    overlap	*op;

    for (op = ovlp_list.forw; op != &ovlp_list; op = op -> forw)
    {
	if (((pp -> pt_inhit -> hit_dist <= op -> in_dist)
	    && (op -> in_dist <= pp -> pt_outhit -> hit_dist)) ||
	    ((pp -> pt_inhit -> hit_dist <= op -> out_dist)
	    && (op -> in_dist <= pp -> pt_outhit -> hit_dist)))
	    break;
    }
    return ((op == &ovlp_list) ? OVERLAP_NULL : op);
}

void del_ovlp (overlap *op)
{
    op -> forw -> backw = op -> backw;
    op -> backw -> forw = op -> forw;
    rt_free((char *)op, "free op in del_ovlp");
}

void init_ovlp(void)
{
    ovlp_list.forw = ovlp_list.backw = &ovlp_list;
}

int
if_boverlap(register struct application *ap, register struct partition *pp, struct region *reg1, struct region *reg2)
{
	return 1;
}
@


11.20
log
@change conf.h to a wrapped config.h
@
text
@d3 1
a3 1
static const char RCSid[] = "$Header: /cvs/brlcad/nirt/if.c,v 11.19 2004/04/05 07:39:41 morrison Exp $";
@


11.19
log
@merge of ansi-6-0-branch into HEAD
@
text
@d3 1
a3 1
static const char RCSid[] = "$Header$";
d7 5
a11 1
#include "conf.h"
@


11.18
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d3 1
a3 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/if.c,v 11.16 2002/02/20 21:06:21 butler Exp $";
d25 3
a27 3
overlap			*find_ovlp();
void			del_ovlp();
void			init_ovlp();
d32 1
a32 4
int if_hit(ap, part_head, finished_segs)
struct application	*ap;
struct partition 	*part_head;
struct seg		*finished_segs;
d35 1
a35 1
    char		*basename();
d45 1
a45 1
    fastf_t		get_obliq();
d229 1
a229 1
int if_miss()
d249 1
a249 7
if_overlap( ap, pp, reg1, reg2, InputHdp )
register struct application	*ap;
register struct partition	*pp;
struct region			*reg1;
struct region			*reg2;
struct partition		*InputHdp;

d282 1
a282 4
int if_bhit(ap, part_head, finished_segs)
struct application	*ap;
struct partition 	*part_head;
struct seg		*finished_segs;
d325 1
a325 1
int if_bmiss()
d330 1
a330 5
fastf_t get_obliq (ray, normal)

vect_t	ray;
vect_t	normal;

d362 1
a362 4
overlap *find_ovlp (pp)

struct partition	*pp;

d377 1
a377 4
void del_ovlp (op)

overlap	*op;

d384 1
a384 1
void init_ovlp()
d390 1
a390 6
if_boverlap( ap, pp, reg1, reg2 )
register struct application     *ap;
register struct partition       *pp;
struct region                   *reg1;
struct region                   *reg2;

@


11.18.2.1
log
@Initial ANSIfication
@
text
@d3 1
a3 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/if.c,v 11.18 2002/08/20 17:08:30 jra Exp $";
d25 3
a27 3
overlap			*find_ovlp(struct partition *pp);
void			del_ovlp(overlap *op);
void			init_ovlp(void);
d32 4
a35 1
int if_hit(struct application *ap, struct partition *part_head, struct seg *finished_segs)
d38 1
a38 1
    char		*basename(char *string);
d48 1
a48 1
    fastf_t		get_obliq(fastf_t *ray, fastf_t *normal);
d232 1
a232 1
int if_miss(void)
d252 7
a258 1
if_overlap(register struct application *ap, register struct partition *pp, struct region *reg1, struct region *reg2, struct partition *InputHdp)
d291 4
a294 1
int if_bhit(struct application *ap, struct partition *part_head, struct seg *finished_segs)
d337 1
a337 1
int if_bmiss(void)
d342 5
a346 1
fastf_t get_obliq (fastf_t *ray, fastf_t *normal)
d378 4
a381 1
overlap *find_ovlp (struct partition *pp)
d396 4
a399 1
void del_ovlp (overlap *op)
d406 1
a406 1
void init_ovlp(void)
d412 6
a417 1
if_boverlap(register struct application *ap, register struct partition *pp, struct region *reg1, struct region *reg2)
@


11.17
log
@Converted from K&R to ANSI C - RFH
@
text
@d25 3
a27 3
overlap			*find_ovlp(struct partition *pp);
void			del_ovlp(overlap *op);
void			init_ovlp(void);
d32 4
a35 1
int if_hit(struct application *ap, struct partition *part_head, struct seg *finished_segs)
d38 1
a38 1
    char		*basename(char *string);
d48 1
a48 1
    fastf_t		get_obliq(fastf_t *ray, fastf_t *normal);
d232 1
a232 1
int if_miss(void)
d252 7
a258 1
if_overlap(register struct application *ap, register struct partition *pp, struct region *reg1, struct region *reg2, struct partition *InputHdp)
d291 4
a294 1
int if_bhit(struct application *ap, struct partition *part_head, struct seg *finished_segs)
d337 1
a337 1
int if_bmiss(void)
d342 5
a346 1
fastf_t get_obliq (fastf_t *ray, fastf_t *normal)
d378 4
a381 1
overlap *find_ovlp (struct partition *pp)
d396 4
a399 1
void del_ovlp (overlap *op)
d406 1
a406 1
void init_ovlp(void)
d412 6
a417 1
if_boverlap(register struct application *ap, register struct partition *pp, struct region *reg1, struct region *reg2)
@


11.16
log
@A nicer implementation that uses the string format for the "attributes" value
@
text
@d3 1
a3 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/if.c,v 11.15 2002/02/19 21:42:39 butler Exp $";
d25 3
a27 3
overlap			*find_ovlp();
void			del_ovlp();
void			init_ovlp();
d32 1
a32 4
int if_hit(ap, part_head, finished_segs)
struct application	*ap;
struct partition 	*part_head;
struct seg		*finished_segs;
d35 1
a35 1
    char		*basename();
d45 1
a45 1
    fastf_t		get_obliq();
d229 1
a229 1
int if_miss()
d249 1
a249 7
if_overlap( ap, pp, reg1, reg2, InputHdp )
register struct application	*ap;
register struct partition	*pp;
struct region			*reg1;
struct region			*reg2;
struct partition		*InputHdp;

d282 1
a282 4
int if_bhit(ap, part_head, finished_segs)
struct application	*ap;
struct partition 	*part_head;
struct seg		*finished_segs;
d325 1
a325 1
int if_bmiss()
d330 1
a330 5
fastf_t get_obliq (ray, normal)

vect_t	ray;
vect_t	normal;

d362 1
a362 4
overlap *find_ovlp (pp)

struct partition	*pp;

d377 1
a377 4
void del_ovlp (op)

overlap	*op;

d384 1
a384 1
void init_ovlp()
d390 1
a390 6
if_boverlap( ap, pp, reg1, reg2 )
register struct application     *ap;
register struct partition       *pp;
struct region                   *reg1;
struct region                   *reg2;

@


11.15
log
@Added support for printing attributes
@
text
@d3 1
a3 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/if.c,v 11.14 2001/12/13 19:14:30 jra Exp $";
d49 3
a51 10

#if 0
    avs = (struct bu_attribute_value_set *)ap->a_uptr;
int
db5_get_attributes( ap->a_rt_i->rti_dbip
		    avs,
		    part->pt_inseg->seg_stp->stp_dp
		    part->pt_regionp
		    const struct directory *dp )
#endif
d163 13
a175 1
	ValTab[VTI_ATTRIBUTES].value.sval = (char *)part->pt_regionp;
d177 1
d225 4
@


11.14
log
@The NIRT overlap handler now calls rt_defoverlap() to insure consistent behavior with the rest of BRL-CAD
@
text
@d3 1
a3 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/if.c,v 11.13 2001/08/09 19:58:22 jra Exp $";
a47 1

d50 9
d169 3
@


11.13
log
@lint
@
text
@d3 1
a3 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/if.c,v 11.12 2001/01/05 19:11:08 jra Exp $";
d29 3
d231 1
a231 1
if_overlap( ap, pp, reg1, reg2 )
d236 1
d261 2
a262 3
    /* Match BRL-CAD 4.4's accidental behavior: take lower bit */
    if( reg1->reg_bit < reg2->reg_bit )  return 1;
    else return 2;
@


11.12
log
@if_hit() now prints ALL overlaps for a given partition
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/if.c,v 11.10 2000/05/22 15:57:26 pjt Exp $";
d227 1
d387 1
@


11.11
log
@
lint
@
text
@d3 1
a3 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/if.c,v 11.10 2000/05/22 15:57:26 pjt Exp $";
d170 1
a170 1
	if ((ovp = find_ovlp(part)) != OVERLAP_NULL)
d196 1
d198 7
@


11.10
log
@1. Added support for overlap claimants
2. Switched sense of return code of if_overlap to return indication
    of region with lower index into Regions[].  Had been higher.
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/if.c,v 11.9 2000/02/22 16:47:10 jra Exp $";
@


11.10.2.1
log
@if_hit() now prints ALL overlaps for a given partition
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/if.c,v 11.10 2000/05/22 15:57:26 pjt Exp $";
d170 1
a170 1
	while ((ovp = find_ovlp(part)) != OVERLAP_NULL)
a195 1
    {
a196 7
    	ovp = ovlp_list.forw;
    	while( ovp != &ovlp_list )
    	{
		bu_log( " OVERLAP:\n\t%s %s (%g %g %g) %g\n",ovp -> reg1 -> reg_name, ovp -> reg2 -> reg_name, V3ARGS( ovp->in_point ), ovp->out_dist - ovp->in_dist );
    	    ovp = ovp->forw;
    	}
    }
@


11.9
log
@
Corrected bug in backout command (needed an overlap handler of its own).
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/if.c,v 11.8 2000/01/31 16:22:28 jra Exp $";
d20 1
d43 2
d51 7
d124 34
d162 8
d248 2
a249 2
    /* Match BRL-CAD 4.4's accidental behavior: take higher bit */
    if( reg1->reg_bit > reg2->reg_bit )  return 1;
@


11.8
log
@Eliminated some unused variables
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/if.c,v 11.7 1999/11/08 20:25:49 pjt Exp $";
d324 10
@


11.7
log
@Added DEBUG_HITS flag
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/if.c,v 11.6 1999/10/07 18:50:27 mike Exp $";
a36 1
    fastf_t		los;
a213 1
    point_t		onormal;
@


11.6
log
@
Match BRL-CAD 4.4's accidental behavior: take higher bit number
when resolving overlaps.
Don't just say "take first arg" without examining what it points at!
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/if.c,v 11.5 1998/12/09 17:59:29 bparker Exp $";
d39 1
d51 2
d72 7
@


11.5
log
@*- add parameter to if_hit and if_bhit --- currently unused
*- calculate outhit point in if_bhit
*- spew debug info in local units
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/if.c,v 11.4 1998/03/27 07:41:30 mike Exp $";
d187 3
a189 1
    return(1);
@


11.4
log
@Changed from RT_HIT_NORM() to RT_HIT_NORMAL() and local vars.
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/if.c,v 11.3 1997/12/05 20:56:11 pjt Exp mike $";
d20 2
a21 1

d28 1
a28 1
int if_hit(ap, part_head)
d31 1
d195 1
a195 1
int if_bhit(ap, part_head)
d198 1
d203 1
d212 3
d219 3
a221 1
	    V3ARGS(part -> pt_outhit -> hit_point));
d230 4
a233 1
	    BACKOUT_DIST, V3ARGS(point));
@


11.3
log
@Implemented backout callbacks
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/if.c,v 11.2 1997/02/07 15:04:50 pjt Exp $";
d38 2
d48 4
a51 2
	RT_HIT_NORM( part->pt_inhit, part->pt_inseg->seg_stp, &ap->a_ray );
	RT_HIT_NORM( part->pt_outhit, part->pt_outseg->seg_stp, &ap->a_ray );
d64 2
a65 2
	    n_entry(i) = part -> pt_inhit -> hit_normal[i];
	    n_exit(i) = part -> pt_outhit -> hit_normal[i];
d100 1
a100 1
	    get_obliq(ap -> a_ray.r_dir, part -> pt_inhit -> hit_normal);
d102 1
a102 1
	    get_obliq(ap -> a_ray.r_dir, part -> pt_outhit -> hit_normal);
a206 1
    RT_HIT_NORM( part->pt_outhit, part->pt_outseg->seg_stp, &ap->a_ray );
@


11.2
log
@Added output items for entry- and exit-surface numbers
for the entry and exit solids of each partition
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/if.c,v 11.1 95/01/04 10:22:15 mike Rel4_4 $";
d19 2
d182 48
@


11.1
log
@Release_4.4
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/if.c,v 10.3 94/12/21 10:28:44 pjt Exp $";
d91 2
@


10.3
log
@Added output item for scaled LOS for each partition
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/if.c,v 10.2 1994/08/24 14:06:11 gdurf Exp $";
@


10.2
log
@Added include of conf.h
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/if.c,v 10.1 1991/10/12 06:53:30 mike Rel4_0 gdurf $";
d84 2
@


10.1
log
@Release_4.0
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/if.c,v 1.9 91/08/29 14:17:26 pjt Exp $";
d7 2
d11 4
a14 3
#include <machine.h>
#include <vmath.h>
#include <raytrace.h>
@


1.9
log
@Added output items for entry and exit normals
for each partition.
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/if.c,v 1.8 91/07/30 11:04:52 pjt Exp $";
@


1.8
log
@Removed check of value returned by rt_malloc(),
since it only returns on successful allocation.
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/if.c,v 1.7 91/07/18 00:23:03 butler Exp $";
d55 2
d64 16
@


1.7
log
@substituted rt_log for (f)printf, rt_malloc for malloc.
plugged memory leak with regard to dest_string.
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/if.c,v 1.6 91/07/03 01:14:51 mike Exp $";
d134 2
a135 7
    if ((new_ovlp = (overlap *) rt_malloc(sizeof(overlap), "new_ovlp"))
        == OVERLAP_NULL)
    {
	fflush(stdout);
	fprintf(stderr, "if_overlap(): Ran out of memory\n");
	exit(1);
    }
@


1.6
log
@ANSI lint
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/if.c,v 1.5 91/03/15 08:35:09 pjt Exp $";
d134 2
a135 1
    if ((new_ovlp = (overlap *) malloc(sizeof(overlap))) == OVERLAP_NULL)
d223 1
a223 1
    free(op);
@


1.5
log
@Added path_name output item
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/if.c,v 1.4 91/02/15 16:02:29 mike Exp $";
d63 2
a64 1
	ValTab[VTI_PATH_NAME].value.sval = part -> pt_regionp -> reg_name;
d85 1
a85 1
		part -> pt_inseg -> seg_stp -> st_name;
d87 1
a87 1
		part -> pt_outseg -> seg_stp -> st_name;
d181 1
@


1.4
log
@Converted to Cake
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/if.c,v 1.3 91/02/14 09:29:13 pjt Exp $";
d63 1
@


1.3
log
@Attempt to add $Header$ to file.
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: if.c,v 1.1.1.1 91/02/14 09:24:53 pjt Exp $";
d12 2
a13 2
#include "nirt.h"
#include "usrfmt.h"
@


1.2
log
@Attempts to track down and eradicate the "Previously unreported overlaps.
Shouldn't happen" bug...
 1. Added code to compare successive overlaps and merge them if
    they share reg1's and reg2's and out_dist of one is in_dist
    of the other.  BTW, if this step is not gratuitous, then
    the comparison should be done in the other order, first comparing
    in_dist and out_dist, and only then doing the more expensive
    calls to strcmp().
2.  Add some diagnostic print stmts to pring out the entire overlap list
    at the end of each call to if_overlap().
@
text
@d2 3
a99 3
    {
	overlap	*op;

a100 6
	for (op = ovlp_list.forw; op != &ovlp_list; op = op -> forw)
	    fprintf(stderr, "... '%s'--'%s' (%g, %g)\n",
		    op -> reg1 -> reg_name,
		    op -> reg2 -> reg_name,
		    op -> in_dist, op -> out_dist);
    }
a110 2
#include <string.h>

a131 15
    /* If two overlaps have the same reg1 and reg2 and the
     * out_dist of one is the in_dist of the other,
     * then combine the two overlaps into one.
     */
    if ((ovlp_list.forw && ovlp_list.forw -> reg1)
	&& ((strcmp(ovlp_list.forw -> reg1 -> reg_name, reg1 -> reg_name) == 0)
    	&&  (strcmp(ovlp_list.forw -> reg2 -> reg_name, reg2 -> reg_name) == 0))
	&& (ovlp_list.forw -> out_dist ==  pp -> pt_inhit -> hit_dist))
    {
	ovlp_list.forw -> out_dist == pp -> pt_outhit -> hit_dist;
	VJOIN1(ovlp_list.forw -> out_point, ap->a_ray.r_pt,
	    pp->pt_outhit->hit_dist, ap->a_ray.r_dir);
	return (1);
    }

a154 9
    { overlap	*op;
    fprintf(stderr, "if_overlap(%d, '%s', '%s') done... the list is now\n",
	pp, reg1 -> reg_name, reg2 -> reg_name);
    for (op = ovlp_list.forw; op != &ovlp_list; op = op -> forw)
	fprintf(stderr, "... '%s'--'%s' (%g, %g)\n",
		op -> reg1 -> reg_name,
		op -> reg2 -> reg_name,
		op -> in_dist, op -> out_dist);
    }
@


1.1
log
@Initial revision
@
text
@d97 3
d101 6
d117 2
d140 15
d178 9
@


1.1.1.1
log
@Attempt to add $Header$ to file.
@
text
@a1 3
#ifndef lint
static char RCSid[] = "$Header$";
#endif
@
