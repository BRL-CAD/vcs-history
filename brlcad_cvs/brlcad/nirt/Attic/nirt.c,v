head	11.28;
access;
symbols
	ansi-20040405-merged:11.24.2.2
	postmerge-20040405-ansi:11.26
	premerge-20040404-ansi:11.25
	postmerge-autoconf:11.25
	autoconf-freeze:11.24.10.1
	premerge-autoconf:11.25
	postmerge-20040315-windows:11.25
	premerge-20040315-windows:11.24
	windows-20040315-freeze:11.24.4.1
	autoconf-20031203:11.24
	autoconf-20031202:11.24
	autoconf-branch:11.24.0.10
	phong-branch:11.24.0.8
	photonmap-branch:11.24.0.6
	rel-6-1-DP:11.24
	windows-branch:11.24.0.4
	rel-6-0-2:11.22
	ansi-branch:11.24.0.2
	rel-6-0-1-branch:11.22.0.2
	hartley-6-0-post:11.23
	hartley-6-0-pre:11.22
	rel-6-0-1:11.22
	rel-6-0:11.20
	rel-5-4:11.12
	offsite-5-3-pre:11.15
	rel-5-3:11.12
	rel-5-2:11.12
	rel-5-1-branch:11.12.0.2
	rel-5-1:11.12
	rel-5-0:11.6
	rel-5-0-beta:11.6
	rel-4-5:11.5
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.28
date	2004.05.21.17.47.08;	author morrison;	state dead;
branches;
next	11.27;

11.27
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.26;

11.26
date	2004.04.05.07.39.41;	author morrison;	state Exp;
branches;
next	11.25;

11.25
date	2004.03.16.21.24.36;	author morrison;	state Exp;
branches;
next	11.24;

11.24
date	2002.08.20.17.08.30;	author jra;	state Exp;
branches
	11.24.2.1
	11.24.4.1
	11.24.10.1;
next	11.23;

11.23
date	2002.08.15.20.55.44;	author hartley;	state Exp;
branches;
next	11.22;

11.22
date	2002.05.08.15.32.20;	author jra;	state Exp;
branches;
next	11.21;

11.21
date	2002.05.08.13.55.38;	author jra;	state Exp;
branches;
next	11.20;

11.20
date	2002.02.20.21.06.21;	author butler;	state Exp;
branches;
next	11.19;

11.19
date	2002.02.19.21.45.54;	author butler;	state Exp;
branches;
next	11.18;

11.18
date	2002.02.19.21.42.39;	author butler;	state Exp;
branches;
next	11.17;

11.17
date	2001.11.14.14.43.10;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	2001.08.09.19.58.22;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	2001.01.15.21.32.41;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	2000.09.21.02.57.17;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	2000.08.24.23.10.01;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	2000.06.09.13.19.45;	author pjt;	state Exp;
branches;
next	11.11;

11.11
date	2000.05.22.15.52.54;	author pjt;	state Exp;
branches;
next	11.10;

11.10
date	2000.02.15.18.49.22;	author jra;	state Exp;
branches;
next	11.9;

11.9
date	2000.01.31.16.22.28;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	2000.01.07.04.38.09;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	99.11.08.20.25.23;	author pjt;	state Exp;
branches;
next	11.6;

11.6
date	99.03.29.17.17.58;	author pjt;	state Exp;
branches;
next	11.5;

11.5
date	97.12.11.19.09.41;	author pjt;	state Exp;
branches;
next	11.4;

11.4
date	97.12.08.18.55.04;	author pjt;	state Exp;
branches;
next	11.3;

11.3
date	97.12.05.20.56.21;	author pjt;	state Exp;
branches;
next	11.2;

11.2
date	97.12.04.18.54.52;	author pjt;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.22.17;	author mike;	state Rel4_4;
branches;
next	10.4;

10.4
date	94.08.24.14.06.28;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	94.08.24.14.00.18;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.04.05.10.47.56;	author pjt;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.53.32;	author mike;	state Rel4_0;
branches;
next	1.17;

1.17
date	91.08.29.14.16.39;	author pjt;	state Exp;
branches;
next	1.16;

1.16
date	91.07.30.12.40.22;	author pjt;	state Exp;
branches;
next	1.15;

1.15
date	91.07.24.11.20.00;	author pjt;	state Exp;
branches;
next	1.14;

1.14
date	91.07.23.14.48.18;	author pjt;	state Exp;
branches;
next	1.13;

1.13
date	91.07.18.16.16.00;	author pjt;	state Exp;
branches;
next	1.12;

1.12
date	91.07.18.14.46.38;	author pjt;	state Exp;
branches;
next	1.11;

1.11
date	91.07.18.00.23.06;	author butler;	state Exp;
branches;
next	1.10;

1.10
date	91.07.06.05.08.49;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	91.06.18.12.25.56;	author pjt;	state Exp;
branches;
next	1.8;

1.8
date	91.03.01.16.12.55;	author pjt;	state Exp;
branches;
next	1.7;

1.7
date	91.02.25.16.18.53;	author pjt;	state Exp;
branches;
next	1.6;

1.6
date	91.02.21.16.11.24;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	91.02.15.16.02.30;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	91.02.14.09.43.17;	author pjt;	state Exp;
branches;
next	1.3;

1.3
date	91.02.14.09.12.59;	author pjt;	state Exp;
branches;
next	1.2;

1.2
date	91.02.14.08.39.00;	author pjt;	state Exp;
branches;
next	1.1;

1.1
date	91.02.11.09.57.41;	author pjt;	state Exp;
branches;
next	;

11.24.2.1
date	2002.09.19.18.02.10;	author morrison;	state Exp;
branches;
next	11.24.2.2;

11.24.2.2
date	2004.03.17.21.22.07;	author morrison;	state Exp;
branches;
next	;

11.24.4.1
date	2002.09.26.23.04.14;	author morrison;	state Exp;
branches;
next	;

11.24.10.1
date	2004.03.18.18.10.31;	author erikg;	state Exp;
branches;
next	;


desc
@@


11.28
log
@moved to src/nirt/
@
text
@/*                        NIRT
 *
 *       This program is an Interactive Ray-Tracer
 *       
 *
 *       Written by:  Natalie L. Barker <barker@@brl>
 *                    U.S. Army Ballistic Research Laboratory
 *
 *       Date:  Jan 90 -
 * 
 *       To compile:  /bin/cc -I/usr/include/brlcad nirt.c 
 *                    /usr/brlcad/lib/librt.a -lm -o nirt
 *
 *       To run:  nirt [-options] file.g object[s] 
 *
 *       Help menu:  nirt -?
 *
 */
#ifndef lint
static const char RCSid[] = "$Header: /n/xoff/cvs/brlcad/nirt/nirt.c,v 11.27 2004/05/10 15:30:49 erikg Exp $";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <ctype.h>
#if USE_STRING_H
# include <string.h>
#else
# include <strings.h>
#endif
#include <math.h>

#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "./nirt.h"
#include "./usrfmt.h"

#ifdef WIN32
#include <fcntl.h>
#endif



extern int	rt_bot_minpieces;	/* from g_bot.c */

extern char	version[];		/* from vers.c */
extern void	cm_libdebug();
extern void	cm_debug();
extern void	cm_attr();

char		*db_name;	/* the name of the BRL-CAD geometry file */
com_table	ComTab[] =
		{
		    { "attr", cm_attr, "select attributes", "<-f(flush) | -p(print) | attribute_name>" },
		    { "ae", az_el, "set/query azimuth and elevation", 
			"azimuth elevation" },
		    { "dir", dir_vect, "set/query direction vector", 
			"x-component y-component z-component" },
		    { "hv", grid_coor, "set/query gridplane coordinates",
			"horz vert [dist]" },
		    { "xyz", target_coor, "set/query target coordinates", 
			"X Y Z" },
		    { "s", shoot, "shoot a ray at the target" },
		    { "backout", backout, "back out of model" },
		    { "useair", use_air, "set/query use of air",
			"<0|1|2|...>" },
		    { "units", nirt_units, "set/query local units",
			"<mm|cm|m|in|ft>" },
		    { "overlap_claims", do_overlap_claims,
			"set/query overlap rebuilding/retention",
			"<0|1|2|3>" },
		    { "fmt", format_output, "set/query output formats",
			"{rhpfmo} format item item ..." },
		    { "dest", direct_output, "set/query output destination",
			"file/pipe" },
		    { "statefile", state_file,
			"set/query name of state file", "file" },
		    { "dump", dump_state,
			"write current state of NIRT to the state file" },
		    { "load", load_state,
			"read new state for NIRT from the state file" },
		    { "print", print_item, "query an output item",
			"item" },
		    { "bot_minpieces", bot_minpieces,
		      "Get/Set value for rt_bot_minpieces (0 means do not use pieces, default is 32)",
		      "min_pieces" },
		    { "libdebug", cm_libdebug,
			"set/query librt debug flags", "hex_flag_value" },
		    { "debug", cm_debug,
			"set/query nirt debug flags", "hex_flag_value" },
		    { "!", sh_esc, "escape to the shell" },
		    { "q", quit, "quit" },
		    { "?", show_menu, "display this help menu" },
		    { (char *)NULL, NULL, (char *)NULL, (char *)NULL }
		};
int		do_backout = 0;			/* Backout before shooting? */
int		overlap_claims = OVLP_RESOLVE;	/* Rebuild/retain overlaps? */
char		*ocname[4];
int		silent_flag = SILENT_UNSET;	/* Refrain from babbling? */
int		nirt_debug = 0;			/* Control of diagnostics */

/* Parallel structures needed for operation w/ and w/o air */
struct rt_i		*rti_tab[2];
struct rt_i		*rtip;
struct resource		res_tab;

struct application	ap;


int need_prep = 1;
attr_table a_tab;

void
attrib_print(void)
{
    int i;

    for (i=0 ; i < a_tab.attrib_use ; i++) {
	bu_log("\"%s\"\n", a_tab.attrib[i]);
    }

}

void
attrib_flush(void)
{
    int i;
    /* flush the list of desired attributs */

    a_tab.attrib_use = 0;
    for (i=0 ; i < a_tab.attrib_use; i++ )
	bu_free(a_tab.attrib[i], "strdup");

    return;
}

void
attrib_add(char *a)
{
    char *p;

    if (!a) {
	bu_log("attrib_add null arg\n");
	return; /* null char ptr */
    }

    p = strtok(a, "\t ");
    while (p) {

	/* make sure we have space */
	if (!a_tab.attrib || a_tab.attrib_use >= (a_tab.attrib_cnt-1)) {
	    a_tab.attrib_cnt += 16;
	    a_tab.attrib = bu_realloc(a_tab.attrib, 
				      a_tab.attrib_cnt * sizeof(char *),
				      "attrib_tab");
	}

	/* add the attribute name(s) */
    	a_tab.attrib[a_tab.attrib_use] = bu_strdup(p);
	/* bu_log("attrib[%d]=\"%s\"\n", attrib_use, attrib[attrib_use]); */
	a_tab.attrib[++a_tab.attrib_use] = (char *)NULL;

	p = strtok((char *)NULL, "\t ");
	need_prep = 1;
    }

}











struct script_rec
{
    struct bu_list	l;
    int			sr_type;	/* Direct or indirect */
    struct bu_vls	sr_script;	/* Literal or file name */
};
#define	SCRIPT_REC_NULL	((struct script_rec *) 0)
#define SCRIPT_REC_MAGIC	0x73637270
#define	sr_magic		l.magic

static void enqueue_script (struct bu_list *qp, int type, char *string)

              	    
   		     
    		        	/* Literal or file name */

{
    struct script_rec	*srp;

    BU_CK_LIST_HEAD(qp);

    srp = (struct script_rec *)
	    bu_malloc(sizeof(struct script_rec), "script record");
    srp -> sr_magic = SCRIPT_REC_MAGIC;
    srp -> sr_type = type;
    bu_vls_init(&(srp -> sr_script));
    bu_vls_strcat(&(srp -> sr_script), string);

    BU_LIST_INSERT(qp, &(srp -> l));
}

static void show_scripts (struct bu_list *sl, char *text)

              	    
    		      		/* for title line */

{
    int			i;
    struct script_rec	*srp;

    BU_CK_LIST_HEAD(sl);

    i = 0;
    bu_log("- - - - - - - The command-line scripts %s\n");
    for (BU_LIST_FOR(srp, script_rec, sl))
    {
	BU_CKMAG(srp, SCRIPT_REC_MAGIC, "script record");

	bu_log("%d. script %s '%s'\n",
	    ++i,
	    (srp -> sr_type == READING_STRING) ? "string" :
	    (srp -> sr_type == READING_FILE) ? "file" : "???",
	    bu_vls_addr(&(srp -> sr_script)));
    }
    bu_log("- - - - - - - - - - - - - - - - - - - - - - - - - -\n");
}

static void free_script (struct script_rec *srp)
{
    BU_CKMAG(srp, SCRIPT_REC_MAGIC, "script record");

    bu_vls_free(&(srp -> sr_script));
    bu_free((genptr_t) srp, "script record");
}

static void run_scripts (struct bu_list *sl)
{
    struct script_rec	*srp;
    char		*cp;
    FILE		*fPtr;

    if (nirt_debug & DEBUG_SCRIPTS)
	show_scripts(sl, "before running them");
    while (BU_LIST_WHILE(srp, script_rec, sl))
    {
	BU_LIST_DEQUEUE(&(srp -> l));
	BU_CKMAG(srp, SCRIPT_REC_MAGIC, "script record");
	cp = bu_vls_addr(&(srp -> sr_script));
	if (nirt_debug & DEBUG_SCRIPTS)
	    bu_log("  Attempting to run %s '%s'\n",
		(srp -> sr_type == READING_STRING) ? "literal" :
		(srp -> sr_type == READING_FILE) ? "file" : "???",
		cp);
	switch (srp -> sr_type)
	{
	    case READING_STRING:
		interact(READING_STRING, cp);
		break;
	    case READING_FILE:
		if ((fPtr = fopen(cp, "r")) == NULL)
		    bu_log("Cannot open script file '%s'\n", cp);
		else
		{
		    interact(READING_FILE, fPtr);
		    fclose(fPtr);
		}
		break;
	    default:
		bu_log("%s:%d: script of type %d.  This shouldn't happen\n",
		    __FILE__, __LINE__, srp -> sr_type);
		exit (1);
	}
	free_script(srp);
    }
    if (nirt_debug & DEBUG_SCRIPTS)
	show_scripts(sl, "after running them");
}

int
main (int argc, char **argv)
{
    char                db_title[TITLE_LEN+1];/* title from MGED file      */
    const char		*tmp_str;
    extern char		local_u_name[];
    extern double	base2local;
    extern double	local2base;
    FILE		*fPtr;
    int			Ch;		/* Option name */
    int			mat_flag = 0;	/* Read matrix from stdin? */
    int			use_of_air = 0;
    char		ocastring[1024];
    struct bu_list	script_list;	/* For -e and -f options */
    struct script_rec	*srp;
    extern outval	ValTab[];
    extern int 		optind;		/* index from getopt(3C) */
    extern char		*optarg;	/* argument from getopt(3C) */

    /* FUNCTIONS */
    int                    if_overlap(register struct application *ap, register struct partition *pp, struct region *reg1, struct region *reg2, struct partition *InputHdp);    /* routine if you overlap         */
    int             	   if_hit(struct application *ap, struct partition *part_head, struct seg *finished_segs);        /* routine if you hit target      */
    int             	   if_miss(void);       /* routine if you miss target     */
    void                   do_rt_gettrees(struct rt_i *rtip, char **object_name, int nm_objects);
    void                   printusage(void);
    void		   grid2targ(void);
    void		   targ2grid(void);
    void		   ae2dir(void);
    void		   dir2ae(void);
    void	           set_diameter(struct rt_i *rtip);
    int	           	   str_dbl(char *buf, double *Result);	
    void		   az_el();
    void		   sh_esc();
    void		   grid_coor();
    void		   target_coor();
    void		   dir_vect();
    void		   backout();
    void		   quit();
    void		   show_menu();
    void		   print_item(char *buffer, com_table *ctp);
    void		   shoot();

	#ifdef WIN32
	_fmode = _O_BINARY;
	#endif


    BU_LIST_INIT(&script_list);

    ocname[OVLP_RESOLVE] = "resolve";
    ocname[OVLP_REBUILD_FASTGEN] = "rebuild_fastgen";
    ocname[OVLP_REBUILD_ALL] = "rebuild_all";
    ocname[OVLP_RETAIN] = "retain";
    *ocastring = '\0';

    /* Handle command-line options */
    while ((Ch = getopt(argc, argv, OPT_STRING)) != EOF)
        switch (Ch)
        {
	    case 'A':
		attrib_add(optarg);
		break;
	    case 'B':
		rt_bot_minpieces = atoi( optarg );
		break;
	    case 'b':
		do_backout = 1;
		break;
	    case 'E':
		if (nirt_debug & DEBUG_SCRIPTS)
		    show_scripts(&script_list, "before erasure");
		while (BU_LIST_WHILE(srp, script_rec, &script_list))
		{
		    BU_LIST_DEQUEUE(&(srp -> l));
		    free_script(srp);
		}
		if (nirt_debug & DEBUG_SCRIPTS)
		    show_scripts(&script_list, "after erasure");
		break;
	    case 'e':
		enqueue_script(&script_list, READING_STRING, optarg);
		if (nirt_debug & DEBUG_SCRIPTS)
		    show_scripts(&script_list, "after enqueueing a literal");
		break;
	    case 'f':
		enqueue_script(&script_list, READING_FILE, optarg);
		if (nirt_debug & DEBUG_SCRIPTS)
		    show_scripts(&script_list, "after enqueueing a file name");
		break;
	    case 'M':
		mat_flag = 1;
		break;
	    case 'O':
		sscanf(optarg, "%s", ocastring);
		break;
	    case 's':
		silent_flag = SILENT_YES;	/* Positively yes */
		break;
	    case 'v':
		silent_flag = SILENT_NO;	/* Positively no */
		break;
            case 'x':
		sscanf( optarg, "%x", (unsigned int *)&rt_g.debug );
		break;
            case 'X':
		sscanf( optarg, "%x", (unsigned int *)&nirt_debug );
		break;
            case 'u':
                if (sscanf(optarg, "%d", &use_of_air) != 1)
                {
                    (void) fprintf(stderr,
                        "Illegal use-air specification: '%s'\n", optarg);
                    exit (1);
                }
                break;
            case '?':
	    default:
                printusage();
                exit (Ch != '?');
        }
    if (argc - optind < 2)
    {
	printusage();
	exit (1);
    }
    if (isatty(0))
    {
	if (silent_flag != SILENT_YES)
	    silent_flag = SILENT_NO;
    }
    else	/* stdin is not a TTY */
    {
	if (silent_flag != SILENT_NO)
	    silent_flag = SILENT_YES;
    }
    if (silent_flag != SILENT_YES)
	(void) fputs(version + 5, stdout);	/* skip @@(#) */

    if (use_of_air && (use_of_air != 1))
    {
	fprintf(stderr,
	    "Warning: useair=%d specified, will set to 1\n", use_of_air);
	use_of_air = 1;
    }

    switch (*ocastring)
    {
	case '\0':
	    overlap_claims = OVLP_RESOLVE;
	    break;
	case '0':
	case '1':
	case '2':
	case '3':
	    if (ocastring[1] == '\0')
		sscanf(ocastring, "%d", &overlap_claims);
	    else
	    {
		(void) fprintf(stderr,
		    "Illegal overlap_claims specification: '%s'\n", ocastring);
		exit (1);
	    }
	    break;
	case 'r':
	    if (strcmp(ocastring, "resolve") == 0)
		overlap_claims = OVLP_RESOLVE;
	    else if (strcmp(ocastring, "rebuild_fastgen") == 0)
		overlap_claims = OVLP_REBUILD_FASTGEN;
	    else if (strcmp(ocastring, "rebuild_all") == 0)
		overlap_claims = OVLP_REBUILD_ALL;
	    else if (strcmp(ocastring, "retain") == 0)
		overlap_claims = OVLP_RETAIN;
	    else
	    {
		(void) fprintf(stderr,
		    "Illegal overlap_claims specification: '%s'\n", ocastring);
		exit (1);
	    }
	    break;
	default:
	    (void) fprintf(stderr,
		"Illegal overlap_claims specification: '%s'\n", ocastring);
	    exit (1);
    }

    db_name = argv[optind];

    /* build directory for target object */
    if (silent_flag != SILENT_YES)
    {
	printf("Database file:  '%s'\n", db_name);
	printf("Building the directory...");
    }
    if ((rtip = rt_dirbuild( db_name , db_title, TITLE_LEN )) == RTI_NULL)
    {
	fflush(stdout);
	fprintf(stderr, "Could not load file %s\n", db_name);
	exit(1);
    }
    rti_tab[use_of_air] = rtip;
    rti_tab[1 - use_of_air] = RTI_NULL;
    rtip -> useair = use_of_air;
    rtip -> rti_save_overlaps = (overlap_claims > 0);

    ++optind;
    do_rt_gettrees (rtip, argv + optind, argc - optind);

    /* Initialize the table of resource structures */
    rt_init_resource( &res_tab, 0, rtip );

    /* initialization of the application structure */
    ap.a_hit = if_hit;        /* branch to if_hit routine            */
    ap.a_miss = if_miss;      /* branch to if_miss routine           */
    ap.a_overlap = if_overlap;/* branch to if_overlap routine        */
    ap.a_logoverlap = rt_silent_logoverlap;
    ap.a_onehit = 0;          /* continue through shotline after hit */
    ap.a_resource = &res_tab;
    ap.a_purpose = "NIRT ray";
    ap.a_rt_i = rtip;         /* rt_i pointer                        */
    ap.a_zero1 = 0;           /* sanity check, sayth raytrace.h      */
    ap.a_zero2 = 0;           /* sanity check, sayth raytrace.h      */
    ap.a_uptr = (genptr_t)a_tab.attrib;

    /* initialize variables */
    azimuth() = 0.0;
    elevation() = 0.0;
    direct(X) = -1.0; 
    direct(Y) = 0.0;
    direct(Z) = 0.0;
    grid(HORZ) = 0.0;
    grid(VERT) = 0.0;
    grid(DIST) = 0.0;
    grid2targ();
    set_diameter(rtip);

    /* initialize the output specification */
    default_ospec();

    /* initialize NIRT's local units */
    base2local = rtip -> rti_dbip -> dbi_base2local;
    local2base = rtip -> rti_dbip -> dbi_local2base;
    tmp_str = bu_units_string(local2base);
    if( tmp_str ) {
	    strncpy(local_u_name, bu_units_string(local2base), 64);
    } else {
	    strcpy( local_u_name, "Unknown units" );
    }

    if (silent_flag != SILENT_YES)
    {
	printf("Database title: '%s'\n", db_title);
	printf("Database units: '%s'\n", local_u_name);
	printf("model_min = (%g, %g, %g)    model_max = (%g, %g, %g)\n",
	    rtip -> mdl_min[X] * base2local,
	    rtip -> mdl_min[Y] * base2local,
	    rtip -> mdl_min[Z] * base2local,
	    rtip -> mdl_max[X] * base2local,
	    rtip -> mdl_max[Y] * base2local,
	    rtip -> mdl_max[Z] * base2local);
    }

    /* Run the run-time configuration file, if it exists */
    if ((fPtr = fopenrc()) != NULL)
    {
	interact(READING_FILE, fPtr);
	fclose(fPtr);
    }

    /*	Run all scripts specified on the command line */
    run_scripts(&script_list);

    /* Perform the user interface */
    if (mat_flag)
    {
	read_mat();
	exit (0);
    }
    else
	interact(READING_FILE, stdin);
    return 0;
}
 
char	usage[] = "\
Usage: 'nirt [options] model.g objects...'\n\
Options:\n\
 -b        back out of geometry before first shot\n\
 -B n      set rt_bot_minpieces=n\n\
 -e script run script before interacting\n\
 -f sfile  run script sfile before interacting\n\
 -M        read matrix, cmds on stdin\n\
 -O action handle overlap claims via action\n\
 -s        run in short (non-verbose) mode\n\
 -u n      set use_air=n (default 0)\n\
 -v        run in verbose mode\n\
 -x v      set librt(3) diagnostic flag=v\n\
 -X v      set nirt diagnostic flag=v\n\
";

void printusage(void)
{
    (void) fputs(usage, stderr);
}

void
do_rt_gettrees (struct rt_i *rtip, char **object_name, int nm_objects)
{
    static char	**prev_names = 0;
    static int	prev_nm = 0;

    if (object_name == NULL)
    {
	if ((object_name = prev_names) == 0)
	{
	    bu_log("%s:%d: This shouldn't happen\n", __FILE__, __LINE__);
	    exit (1);
	}
	nm_objects = prev_nm;
    }
    if (prev_names == 0)
    {
	prev_names = object_name;
	prev_nm = nm_objects;
    }

    if (silent_flag != SILENT_YES) {
	    printf("\nGet trees...");
	    fflush(stdout);
    }

    if (rt_gettrees_and_attrs(rtip, (const char **)a_tab.attrib, nm_objects, (const char **) object_name, 1))
    {
	fflush(stdout);
	fprintf(stderr, "rt_gettrees() failed\n");
	exit (1);
    }

    if( need_prep ) {
	    if (silent_flag != SILENT_YES) {
		    printf("\nPrepping the geometry...");
		    fflush(stdout);
	    }
	    rt_prep( rtip );
	    need_prep = 0;
    }

    if (silent_flag != SILENT_YES)
    {
	int	i;

	printf("\n%s", (nm_objects == 1) ? "Object" : "Objects");
	for (i = 0; i < nm_objects; ++i)
	    printf(" '%s'", object_name[i]);
	printf(" processed\n");
    }


}
@


11.27
log
@change conf.h to a wrapped config.h
@
text
@d20 1
a20 1
static const char RCSid[] = "$Header: /cvs/brlcad/nirt/nirt.c,v 11.26 2004/04/05 07:39:41 morrison Exp $";
@


11.26
log
@merge of ansi-6-0-branch into HEAD
@
text
@d20 1
a20 1
static const char RCSid[] = "$Header$";
d23 5
a27 1
#include "conf.h"
@


11.25
log
@merge of windows-6-0-branch into head
@
text
@d129 1
a129 1
attrib_flush()
d193 1
a193 1
static void enqueue_script (qp, type, string)
d195 3
a197 3
struct bu_list	*qp;
int		type;
char		*string;	/* Literal or file name */
d214 1
a214 1
static void show_scripts (sl, text)
d216 2
a217 2
struct bu_list	*sl;
char		*text;		/* for title line */
d240 1
a240 4
static void free_script (srp)

struct script_rec	*srp;

d248 1
a248 4
static void run_scripts (sl)

struct bu_list	*sl;

d292 1
a292 3
main (argc, argv)
int argc;
char **argv;
d311 11
a321 11
    int                    if_overlap();    /* routine if you overlap         */
    int             	   if_hit();        /* routine if you hit target      */
    int             	   if_miss();       /* routine if you miss target     */
    void                   do_rt_gettrees();
    void                   printusage();
    void		   grid2targ();
    void		   targ2grid();
    void		   ae2dir();
    void		   dir2ae();
    void	           set_diameter();
    int	           	   str_dbl();	
d330 1
a330 1
    void		   print_item();
d589 1
a589 1
void printusage() 
d595 1
a595 5
do_rt_gettrees (rtip, object_name, nm_objects)
struct rt_i	*rtip;
char		*object_name[];
int		nm_objects;

@


11.24
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d20 1
a20 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/nirt.c,v 11.22 2002/05/08 15:32:20 jra Exp $";
d42 5
d340 5
@


11.24.10.1
log
@merge from head
@
text
@d20 1
a20 1
static const char RCSid[] = "$Header$";
a41 5
#ifdef WIN32
#include <fcntl.h>
#endif


a334 5

	#ifdef WIN32
	_fmode = _O_BINARY;
	#endif

@


11.24.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d20 1
a20 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/nirt.c,v 11.24 2002/08/20 17:08:30 jra Exp $";
a41 5
#ifdef WIN32
#include <fcntl.h>
#endif


a334 5

	#ifdef WIN32
	_fmode = _O_BINARY;
	#endif

@


11.24.2.1
log
@Initial ANSIfication
@
text
@d20 1
a20 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/nirt.c,v 11.24 2002/08/20 17:08:30 jra Exp $";
d124 1
a124 1
attrib_flush(void)
d188 1
a188 1
static void enqueue_script (struct bu_list *qp, int type, char *string)
d190 3
a192 3
              	    
   		     
    		        	/* Literal or file name */
d209 1
a209 1
static void show_scripts (struct bu_list *sl, char *text)
d211 2
a212 2
              	    
    		      		/* for title line */
d235 4
a238 1
static void free_script (struct script_rec *srp)
d246 4
a249 1
static void run_scripts (struct bu_list *sl)
d293 3
a295 1
main (int argc, char **argv)
d314 11
a324 11
    int                    if_overlap(register struct application *ap, register struct partition *pp, struct region *reg1, struct region *reg2, struct partition *InputHdp);    /* routine if you overlap         */
    int             	   if_hit(struct application *ap, struct partition *part_head, struct seg *finished_segs);        /* routine if you hit target      */
    int             	   if_miss(void);       /* routine if you miss target     */
    void                   do_rt_gettrees(struct rt_i *rtip, char **object_name, int nm_objects);
    void                   printusage(void);
    void		   grid2targ(void);
    void		   targ2grid(void);
    void		   ae2dir(void);
    void		   dir2ae(void);
    void	           set_diameter(struct rt_i *rtip);
    int	           	   str_dbl(char *buf, double *Result);	
d333 1
a333 1
    void		   print_item(char *buffer, com_table *ctp);
d587 1
a587 1
void printusage(void)
d593 5
a597 1
do_rt_gettrees (struct rt_i *rtip, char **object_name, int nm_objects)
@


11.24.2.2
log
@sync branch with HEAD
@
text
@d20 1
a20 1
static const char RCSid[] = "$Header$";
a41 5
#ifdef WIN32
#include <fcntl.h>
#endif


a326 5

	#ifdef WIN32
	_fmode = _O_BINARY;
	#endif

@


11.23
log
@Converted from K&R to ANSI C - RFH
@
text
@d124 1
a124 1
attrib_flush(void)
d188 1
a188 1
static void enqueue_script (struct bu_list *qp, int type, char *string)
d190 3
a192 3
              	    
   		     
    		        	/* Literal or file name */
d209 1
a209 1
static void show_scripts (struct bu_list *sl, char *text)
d211 2
a212 2
              	    
    		      		/* for title line */
d235 4
a238 1
static void free_script (struct script_rec *srp)
d246 4
a249 1
static void run_scripts (struct bu_list *sl)
d293 3
a295 1
main (int argc, char **argv)
d314 11
a324 11
    int                    if_overlap(register struct application *ap, register struct partition *pp, struct region *reg1, struct region *reg2, struct partition *InputHdp);    /* routine if you overlap         */
    int             	   if_hit(struct application *ap, struct partition *part_head, struct seg *finished_segs);        /* routine if you hit target      */
    int             	   if_miss(void);       /* routine if you miss target     */
    void                   do_rt_gettrees(struct rt_i *rtip, char **object_name, int nm_objects);
    void                   printusage(void);
    void		   grid2targ(void);
    void		   targ2grid(void);
    void		   ae2dir(void);
    void		   dir2ae(void);
    void	           set_diameter(struct rt_i *rtip);
    int	           	   str_dbl(char *buf, double *Result);	
d333 1
a333 1
    void		   print_item(char *buffer, com_table *ctp);
d587 1
a587 1
void printusage(void)
d593 5
a597 1
do_rt_gettrees (struct rt_i *rtip, char **object_name, int nm_objects)
@


11.22
log
@Minor changes to the logging messages
@
text
@d20 1
a20 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/nirt.c,v 11.21 2002/05/08 13:55:38 jra Exp $";
d124 1
a124 1
attrib_flush()
d188 1
a188 1
static void enqueue_script (qp, type, string)
d190 3
a192 3
struct bu_list	*qp;
int		type;
char		*string;	/* Literal or file name */
d209 1
a209 1
static void show_scripts (sl, text)
d211 2
a212 2
struct bu_list	*sl;
char		*text;		/* for title line */
d235 1
a235 4
static void free_script (srp)

struct script_rec	*srp;

d243 1
a243 4
static void run_scripts (sl)

struct bu_list	*sl;

d287 1
a287 3
main (argc, argv)
int argc;
char **argv;
d306 11
a316 11
    int                    if_overlap();    /* routine if you overlap         */
    int             	   if_hit();        /* routine if you hit target      */
    int             	   if_miss();       /* routine if you miss target     */
    void                   do_rt_gettrees();
    void                   printusage();
    void		   grid2targ();
    void		   targ2grid();
    void		   ae2dir();
    void		   dir2ae();
    void	           set_diameter();
    int	           	   str_dbl();	
d325 1
a325 1
    void		   print_item();
d579 1
a579 1
void printusage() 
d585 1
a585 5
do_rt_gettrees (rtip, object_name, nm_objects)
struct rt_i	*rtip;
char		*object_name[];
int		nm_objects;

@


11.21
log
@Added support for rt_bot_minpieces
@
text
@d20 1
a20 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/nirt.c,v 11.20 2002/02/20 21:06:21 butler Exp $";
a492 2
    if (silent_flag != SILENT_YES)
	printf("\nPrepping the geometry...");
d616 6
d630 4
@


11.20
log
@A nicer implementation that uses the string format for the "attributes" value
@
text
@d20 1
a20 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/nirt.c,v 11.19 2002/02/19 21:45:54 butler Exp $";
d43 1
a43 1

d83 3
d351 3
a513 2
    rt_prep( rtip );

d577 1
d624 6
@


11.19
log
@Removed some lint fuzz
@
text
@d20 1
a20 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/nirt.c,v 11.18 2002/02/19 21:42:39 butler Exp $";
d107 1
a107 3
int attrib_use;
int attrib_cnt;
char **attrib;
d114 2
a115 2
    for (i=0 ; i < attrib_use ; i++) {
	bu_log("\"%s\"\n", attrib[i]);
d126 3
a128 3
    attrib_use = 0;
    for (i=0 ; i < attrib_use; i++ )
	bu_free(attrib[i], "strdup");
d147 5
a151 4
	if (!attrib || attrib_use >= (attrib_cnt-1)) {
	    attrib_cnt += 16;
	    attrib = bu_realloc(attrib, attrib_cnt * sizeof(char *),
				"attrib_tab");
d155 1
a155 1
    	attrib[attrib_use] = bu_strdup(p);
d157 1
a157 1
	attrib[++attrib_use] = (char *)NULL;
d506 1
a506 1
    ap.a_uptr = (genptr_t)attrib;
d613 1
a613 1
    if (rt_gettrees_and_attrs(rtip, (const char **)attrib, nm_objects, (const char **) object_name, 1))
@


11.18
log
@Added support for printing attributes
@
text
@d20 1
a20 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/nirt.c,v 11.17 2001/11/14 14:43:10 jra Exp $";
d614 1
a614 1
    if (rt_gettrees_and_attrs(rtip, attrib, nm_objects, (const char **) object_name, 1))
@


11.17
log
@Minor mods to handle unrecognized units
@
text
@d20 1
a20 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/nirt.c,v 11.16 2001/08/09 19:58:22 jra Exp $";
d42 3
d48 1
d53 1
d105 71
d346 3
d492 1
a492 1
 
d507 1
d614 1
a614 1
    if (rt_gettrees (rtip, nm_objects, (const char **) object_name, 1))
d629 2
@


11.16
log
@lint
@
text
@d20 1
a20 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/nirt.c,v 11.15 2001/01/15 21:32:41 jra Exp $";
d220 1
d449 6
a454 1
    strncpy(local_u_name, bu_units_string(local2base), 64);
@


11.15
log
@Nirt doesn't need two resource structures.
@
text
@d20 1
a20 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/nirt.c,v 11.14 2000/09/21 02:57:17 mike Exp $";
d85 1
a85 1
		    { 0 }
a219 1
    extern char		*local_unit[];
d306 1
a306 1
		sscanf( optarg, "%x", &rt_g.debug );
d309 1
a309 1
		sscanf( optarg, "%x", &nirt_debug );
d504 2
a505 2
void do_rt_gettrees (rtip, object_name, nm_objects)

@


11.14
log
@
Called rt_init_resource() rather than attempting hokey inline initialization.
@
text
@d20 1
a20 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/nirt.c,v 11.13 2000/08/24 23:10:01 mike Exp $";
d96 1
a96 1
struct resource		res_tab[2];
d415 1
a415 2
    rt_init_resource( &res_tab[use_of_air], 0, rtip );
    rt_init_resource( &res_tab[1-use_of_air], 1, rtip );
d423 1
a423 1
    ap.a_resource = &res_tab[use_of_air];
@


11.13
log
@
lint
@
text
@d20 1
a20 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/nirt.c,v 11.12 2000/06/09 13:19:45 pjt Exp $";
d415 2
a416 2
    res_tab[use_of_air].re_magic =
	(res_tab[1 - use_of_air].re_magic = RESOURCE_MAGIC);
@


11.12
log
@Initialize ocastring and remove diagnostic print
@
text
@d20 1
a20 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/nirt.c,v 11.11 2000/05/22 15:52:54 pjt Exp $";
d214 1
d483 1
@


11.11
log
@Added support for overlap claimants
@
text
@d20 1
a20 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/nirt.c,v 11.10 2000/02/15 18:49:22 jra Exp $";
d263 1
a387 1
    printf("... overlap_claims = %d ...\n", overlap_claims);
@


11.10
log
@Code in main to get units name was using base2local instead of local2base
@
text
@d20 1
a20 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/nirt.c,v 11.9 2000/01/31 16:22:28 jra Exp $";
d46 1
a46 1
char		*db_name;	/* the name of the MGED file      */
d63 3
d88 2
d227 1
d259 5
d295 3
d347 42
d406 1
d421 1
d491 1
@


11.9
log
@Eliminated some unused variables
@
text
@d20 1
a20 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/nirt.c,v 11.8 2000/01/07 04:38:09 mike Exp $";
d391 1
a391 1
    strncpy(local_u_name, bu_units_string(base2local), 64);
@


11.8
log
@
Eliminated dbi_localunit
@
text
@d20 1
a20 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/nirt.c,v 11.7 1999/11/08 20:25:23 pjt Exp $";
a213 1
    char		*sp;
a218 1
    int                 i;               /* counter                       */
a221 1
    outval		*vtp;
@


11.7
log
@Added 'debug' command
@
text
@d20 1
a20 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/nirt.c,v 11.6 1999/03/29 17:17:58 pjt Exp $";
a391 1
    strncpy(local_u_name, local_unit[rtip -> rti_dbip -> dbi_localunit], 64);
d394 1
@


11.6
log
@Replaced separate calls of rt_gettree() for each object
with a single call of rt_gettrees() for all objects.
This runs faster and allows elimination of struct nirt_obj
@
text
@d20 1
a20 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/nirt.c,v 11.5 1997/12/11 19:09:41 pjt Exp $";
d44 1
d77 2
@


11.5
log
@1. The -e and -f options now accumulate
2. Implemented the -E option
@
text
@d20 1
a20 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/nirt.c,v 11.4 1997/12/08 18:55:04 pjt Exp $";
a90 1
struct nirt_obj		object_list = {"", 0};
d232 1
a232 1
    void                   do_rt_gettree();
d353 2
a354 2
    while (++optind < argc)    /* prepare the objects that are to be included */
	do_rt_gettree( rtip, argv[optind], 1 );
d445 6
a450 4
void do_rt_gettree(rip, object_name, save)
struct rt_i	*rip;
char 		*object_name;
int		save;		/* Add object_name to object_list? */
d452 2
a453 1
    static struct nirt_obj	*op = &object_list;
d455 1
a455 8
    if (rt_gettree( rip, object_name ) == -1)
    {
	fflush(stdout);
	fprintf (stderr, "rt_gettree() could not preprocess object '%s'\n", 
	    object_name);
	exit(1);
    }
    if (save)
d457 1
a457 1
	if (op == NULL)
d459 1
a459 1
	    fputs("Ran out of memory\n", stderr);
d462 6
a467 6
	op -> obj_name = object_name;
	op -> obj_next = (struct nirt_obj *)
				rt_malloc(sizeof(struct nirt_obj), "obj_next");
	op = op -> obj_next;
	if (op != NULL)
	    op -> obj_next = NULL;
d469 6
d476 8
a483 1
	printf("\nObject '%s' processed\n", object_name);
@


11.4
log
@Implemented the -e option
@
text
@d20 1
a20 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/nirt.c,v 11.3 1997/12/05 20:56:21 pjt Exp pjt $";
d93 114
a211 2
    char		sfile_name[1024];
    struct bu_vls	script;
d223 2
a232 1
    void                   interact();      /* handle user interaction        */
d252 1
a252 2
    *sfile_name = '\0';
    bu_vls_init(&script);
d261 11
d273 3
a275 2
		bu_vls_strcat(&script, optarg);
		*sfile_name = '\0';
d278 3
a280 7
		if (strlen(optarg) < 1024)
		{
		    sscanf( optarg, "%s", sfile_name );
		    bu_vls_trunc(&script, 0);
		}
		else
		    bu_log("Name of script file '%s' too long!\n", optarg);
d414 2
a415 11
    /*	Run any script specified on the command line */
    if (*(sp = bu_vls_addr(&script)) != '\0')
	interact(READING_STRING, sp);
    else if (*sfile_name != '\0')
	if ((fPtr = fopen(sfile_name, "r")) == NULL)
	    bu_log("Cannot open script file '%s'\n", sfile_name);
	else
	{
	    interact(READING_FILE, fPtr);
	    fclose(fPtr);
	}
@


11.3
log
@1. Added -X option for nirt's own diagnostics
2. Added -f sfile option
@
text
@d20 1
a20 1
static char RCSid[] = "$Header: /n/vapor/m/cad/nirt/RCS/nirt.c,v 11.2 1997/12/04 18:54:52 pjt Exp $";
a22 1
/*	INCLUDES	*/
d35 2
d99 2
d140 1
d149 4
d155 1
d157 2
d290 1
a290 1
	interact(fPtr);
d294 4
a297 2
    /*	Run any script file specified on the command line */
    if (*sfile_name != '\0')
d302 1
a302 1
	    interact(fPtr);
d313 1
a313 1
	interact(stdin);
d319 9
a327 8
 -b       back out of geometry before first shot\n\
 -f sfile run script sfile before interacting\n\
 -M       read matrix, cmds on stdin\n\
 -s       run in short (non-verbose) mode\n\
 -u n     set use_air=n (default 0)\n\
 -v       run in verbose mode\n\
 -x v     set librt(3) diagnostic flag=v\n\
 -X v     set nirt diagnostic flag=v\n\
@


11.2
log
@Implemented -b option
@
text
@d20 1
a20 1
static char RCSid[] = "$Header: /n/vapor/m/cad/nirt/RCS/nirt.c,v 11.1 1995/01/04 10:22:17 mike Rel4_4 pjt $";
d82 1
d97 1
d136 2
d145 6
d163 3
a262 7
    /* Run the run-time configuration file, if it exists */
    if ((fPtr = fopenrc()) != NULL)
    {
	interact(fPtr);
	fclose(fPtr);
    }

d276 17
d306 8
a313 6
 -b      back out of geometry before first shot\n\
 -M      read matrix, cmds on stdin\n\
 -s      run in short (non-verbose) mode\n\
 -u n    set use_air=n (default 0)\n\
 -v      run in verbose mode\n\
 -x v    set librt(3) diagnostic flag=v\n\
@


11.1
log
@Release_4.4
@
text
@d20 1
a20 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/nirt.c,v 10.4 94/08/24 14:06:28 gdurf Exp $";
d56 1
a56 1
		    { "backout", backout, "Back out of model" },
d80 1
d138 3
d283 1
a289 5
#if 0
char	usage[] = "\
Usage: 'nirt [-u n] [-x f] model.g objects...'\n\
";
#endif
@


10.4
log
@Factored ifdefs
@
text
@d20 1
a20 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/nirt.c,v 10.3 1994/08/24 14:00:18 gdurf Exp gdurf $";
@


10.3
log
@Changes by pjt
@
text
@d20 1
a20 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/nirt.c,v 10.2 94/04/05 10:47:56 pjt Exp $";
d24 3
d28 3
a30 1
#if BSD
a31 2
#else
# include <string.h>
a32 1
#include <stdio.h>
d34 4
a37 3
#include <machine.h>
#include <vmath.h>
#include <raytrace.h>
@


10.2
log
@implemented -v command-line option and enhanced silent_flag
@
text
@d20 1
a20 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/nirt.c,v 10.1 91/10/12 06:53:32 mike Rel4_0 Locker: pjt $";
a166 1
	{
a167 2
	    (void) fputs(version + 5, stdout);	/* skip @@(#) */
	}
d174 2
@


10.1
log
@Release_4.0
@
text
@d20 1
a20 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/nirt.c,v 1.17 91/08/29 14:16:39 pjt Exp $";
d77 1
a77 1
int		silent_flag = 0;	/* Refrain from babbling? */
d138 1
a138 1
		silent_flag = 1;
d140 3
d166 3
a168 1
	if (! silent_flag)
d170 1
d172 5
a176 2
    else
	silent_flag = 1;
d187 1
a187 1
    if (! silent_flag)
d202 1
a202 1
    if (! silent_flag)
d251 1
a251 1
    if (! silent_flag)
d280 1
d322 1
a322 1
    if (! silent_flag)
@


1.17
log
@Deleted a call to printusage()
@
text
@d20 1
a20 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/nirt.c,v 1.16 91/07/30 12:40:22 pjt Exp $";
@


1.16
log
@Added printout of char version[]
to identify the software when it's run interactive (and not silent)
@
text
@d20 1
a20 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/nirt.c,v 1.15 91/07/24 11:20:00 pjt Exp $";
a295 1
	printusage();
@


1.15
log
@Implemented short (non-verbose) mode
@
text
@d20 1
a20 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/nirt.c,v 1.14 91/07/23 14:48:18 pjt Exp $";
d38 1
d161 8
a175 2
    if (! isatty(0))
	silent_flag = 1;
@


1.14
log
@void set_radius() became void set_diameter()
and fastf_t bsphere_radius became fastf_t bsphere_diameter
@
text
@d20 1
a20 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/nirt.c,v 1.13 91/07/18 16:16:00 pjt Exp $";
d76 1
d136 3
d167 2
d171 5
a175 2
    printf("Database file:  '%s'\n", db_name);
    printf("Building the directory...");
a183 1
    putchar('\n');
d186 2
a187 1
    printf("Prepping the geometry...");
d235 12
a246 9
    printf("Database title: '%s'\n", db_title);
    printf("Database units: '%s'\n", local_u_name);
    printf("model_min = (%g, %g, %g)    model_max = (%g, %g, %g)\n",
	rtip -> mdl_min[X] * base2local,
	rtip -> mdl_min[Y] * base2local,
	rtip -> mdl_min[Z] * base2local,
	rtip -> mdl_max[X] * base2local,
	rtip -> mdl_max[Y] * base2local,
	rtip -> mdl_max[Z] * base2local);
d262 1
d264 1
a264 1
 -x f    set diagnostic flag=n\n\
d306 2
a307 2
    putchar('\n');
    printf("Object '%s' processed\n", object_name);
@


1.13
log
@Switched from dist_def.c approach
to bsphere.c
@
text
@d20 1
a20 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/nirt.c,v 1.12 91/07/18 14:46:38 pjt Exp $";
d115 1
a115 1
    void	           set_radius();
d209 1
a209 1
    set_radius(rtip);
@


1.12
log
@Added the backout command
@
text
@d20 1
a20 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/nirt.c,v 1.11 91/07/18 00:23:06 butler Exp $";
d115 1
a115 1
    double	           dist_default();  /* computes grid[DIST] default val*/
a205 1
    grid(DIST) = dist_default();     /* extreme of the target */
d209 1
@


1.11
log
@substituted rt_log for (f)printf, rt_malloc for malloc.
plugged memory leak with regard to dest_string.
@
text
@d20 1
a20 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/nirt.c,v 1.10 91/07/06 05:08:49 mike Exp $";
d52 1
d122 1
@


1.10
log
@On older BSD systems, must use <strings.h>, not <string.h>
@
text
@d20 1
a20 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/nirt.c,v 1.9 91/06/18 12:25:56 pjt Exp $";
d285 2
a286 1
	op -> obj_next = (struct nirt_obj *) malloc(sizeof(struct nirt_obj));
@


1.9
log
@Added support for -M option
@
text
@d20 1
a20 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/nirt.c,v 1.8 91/03/01 16:12:55 pjt Exp $";
d25 5
a29 1
#include <string.h>
@


1.8
log
@Added struct resource res_tab[2] analogous to struct rt_i rti_tab[2]
@
text
@d20 1
a20 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/nirt.c,v 1.7 91/02/25 16:18:53 pjt Exp $";
d92 1
d126 3
d231 7
a237 1
    interact(stdin);
a239 1
#if 0
d243 3
a245 1
 -u n    specifies use of air (default 0)\n\
d247 1
a247 1
#endif
d251 1
@


1.7
log
@Modified the usage line and the command menu to fully integrate
the libdebug command that Mike added.
@
text
@d20 1
a20 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/nirt.c,v 1.6 91/02/21 16:11:24 mike Exp $";
d72 5
a76 2
struct rt_i	*rtip;
struct rt_i	*rti_tab[2];	/* For use w/ and w/o air */
d172 4
d181 1
a181 1
    ap.a_resource = 0;
@


1.6
log
@added -x flag
@
text
@d20 1
a20 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/nirt.c,v 1.5 91/02/15 16:02:30 mike Exp $";
d64 2
a65 2
		    { "libdebug", cm_libdebug, "set librt debug flags",
		    	"hexadecimal flag value" },
d231 1
a231 1
Usage: 'nirt [-u n] model.g objects...'\n\
@


1.5
log
@Converted to Cake
@
text
@d20 1
a20 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/nirt.c,v 1.4 91/02/14 09:43:17 pjt Exp $";
d34 2
d64 2
a81 1
    char		*optstring = OPT_STRING; /* To control getopt(3C) */
d119 1
a119 1
    while ((Ch = getopt(argc, argv, optstring)) != EOF)
d122 3
d175 1
@


1.4
log
@Had to add a semicolon after the declaration static char RCSid[] !
@
text
@d20 1
a20 1
static char RCSid[] = "$Header: nirt.c,v 1.3 91/02/14 09:12:59 pjt Exp $";
d31 2
a32 2
#include "nirt.h"
#include "usrfmt.h"
d251 1
a251 1
	    fputs("Ran out of memory\n");
@


1.3
log
@Attempt to add Header info to the file.
@
text
@d20 1
a20 1
static char RCSid[] = "$Header$:"
@


1.2
log
@1. Added useair command and -u command-line option.
2. Replaced roll-your-own command-line syntax handling with
   use of GETOPT(3).
3. Added struct nirt_obj, the save parameter for do_rt_gettree(),
   and code in that function to maintain a linked list of nirt_obj's,
   one per call.  All this so that when we rt_dirbuild() and
   rt_gettree() again for the second rt_i (the different useair)
   we know what objects the user asked for on the command line.
@
text
@d19 3
@


1.1
log
@Initial revision
@
text
@d31 1
d43 2
d65 4
a68 3
char                     *progname;
struct rt_i              *rtip;           /* pointer to an rt_i structure   */
struct application       ap;
a73 1
    char                *db_name;        /* the name of the MGED file      */
d75 1
d82 2
d86 2
d112 18
a129 2
    progname = *argv++;
    if ((--argc < 2) || (strcmp(*argv, "-?") == 0))
d132 1
a132 1
	exit(1);
d134 7
a140 1
    db_name = *argv;
a148 1
	printusage();
d151 2
d154 1
a154 8
    /*
     *	Here useair is hardwired to 0.
     *	A command-line option should be added to allow the user to
     *	specify that he wants to use air.  Eventualy it would be
     *	nice to allow interactive toggling of useair, but that
     *	would require calling rt_gettree() and rt_prep() again!
     */
    rtip -> useair = 1;
d157 2
a158 2
    while (--argc > 0)    /* prepare the objects that are to be included */
	do_rt_gettree( rtip, *(++argv) );
d213 11
d226 1
a226 1
    fprintf (stderr, "Usage:   %s file.g object[s]\n", progname); 
d229 1
a229 1
void do_rt_gettree(rip, object_name)
d232 1
d234 2
a235 2
    /* All objects (groups and regions) which are to be included in the */
    /* description to be raytraced must be preprocessed with rt_gettree */
d243 13
@
