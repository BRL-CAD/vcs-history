head	11.17;
access;
symbols
	ansi-20040405-merged:11.14.2.1
	postmerge-20040405-ansi:11.15
	premerge-20040404-ansi:11.14
	postmerge-autoconf:11.14
	autoconf-freeze:11.14
	premerge-autoconf:11.14
	postmerge-20040315-windows:11.14
	premerge-20040315-windows:11.14
	windows-20040315-freeze:11.14
	autoconf-20031203:11.14
	autoconf-20031202:11.14
	autoconf-branch:11.14.0.10
	phong-branch:11.14.0.8
	photonmap-branch:11.14.0.6
	rel-6-1-DP:11.14
	windows-branch:11.14.0.4
	rel-6-0-2:11.12
	ansi-branch:11.14.0.2
	rel-6-0-1-branch:11.12.0.2
	hartley-6-0-post:11.13
	hartley-6-0-pre:11.12
	rel-6-0-1:11.12
	rel-6-0:11.12
	rel-5-4:11.6.2.1
	offsite-5-3-pre:11.8
	rel-5-3:11.6.2.1
	rel-5-2:11.6
	rel-5-1-branch:11.6.0.2
	rel-5-1:11.6
	rel-5-0:11.5
	rel-5-0-beta:11.5
	rel-4-5:11.5
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.17
date	2004.05.21.17.47.09;	author morrison;	state dead;
branches;
next	11.16;

11.16
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.15;

11.15
date	2004.04.05.07.39.41;	author morrison;	state Exp;
branches;
next	11.14;

11.14
date	2002.08.20.17.08.30;	author jra;	state Exp;
branches
	11.14.2.1;
next	11.13;

11.13
date	2002.08.15.20.55.44;	author hartley;	state Exp;
branches;
next	11.12;

11.12
date	2002.02.20.21.06.21;	author butler;	state Exp;
branches;
next	11.11;

11.11
date	2002.02.19.21.42.39;	author butler;	state Exp;
branches;
next	11.10;

11.10
date	2001.08.09.19.58.22;	author jra;	state Exp;
branches;
next	11.9;

11.9
date	2001.04.05.19.35.52;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2001.01.05.19.11.08;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	2000.08.24.23.10.01;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	2000.05.22.15.54.08;	author pjt;	state Exp;
branches
	11.6.2.1;
next	11.5;

11.5
date	97.12.11.19.09.56;	author pjt;	state Exp;
branches;
next	11.4;

11.4
date	97.12.08.18.55.17;	author pjt;	state Exp;
branches;
next	11.3;

11.3
date	97.02.07.15.04.50;	author pjt;	state Exp;
branches;
next	11.2;

11.2
date	96.08.30.19.10.03;	author pjt;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.22.18;	author mike;	state Rel4_4;
branches;
next	10.7;

10.7
date	94.12.30.18.36.45;	author gdurf;	state Exp;
branches;
next	10.6;

10.6
date	94.12.21.10.29.08;	author pjt;	state Exp;
branches;
next	10.5;

10.5
date	94.12.16.08.21.52;	author jra;	state Exp;
branches;
next	10.4;

10.4
date	94.10.14.17.25.39;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.08.24.14.01.22;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	92.03.16.22.25.54;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.53.33;	author mike;	state Rel4_0;
branches;
next	1.17;

1.17
date	91.08.29.14.17.24;	author pjt;	state Exp;
branches;
next	1.16;

1.16
date	91.07.30.11.05.17;	author pjt;	state Exp;
branches;
next	1.15;

1.15
date	91.07.30.10.41.33;	author pjt;	state Exp;
branches;
next	1.14;

1.14
date	91.07.25.12.54.04;	author pjt;	state Exp;
branches;
next	1.13;

1.13
date	91.07.18.14.23.15;	author pjt;	state Exp;
branches;
next	1.12;

1.12
date	91.07.18.00.23.10;	author butler;	state Exp;
branches;
next	1.11;

1.11
date	91.07.02.23.51.22;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	91.06.25.13.45.20;	author pjt;	state Exp;
branches;
next	1.9;

1.9
date	91.03.15.08.35.44;	author pjt;	state Exp;
branches;
next	1.8;

1.8
date	91.03.05.14.14.36;	author pjt;	state Exp;
branches;
next	1.7;

1.7
date	91.02.25.14.58.44;	author pjt;	state Exp;
branches;
next	1.6;

1.6
date	91.02.21.16.11.42;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	91.02.19.16.20.04;	author pjt;	state Exp;
branches;
next	1.4;

1.4
date	91.02.15.16.02.31;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	91.02.14.09.21.52;	author pjt;	state Exp;
branches;
next	1.2;

1.2
date	91.02.14.09.20.22;	author pjt;	state Exp;
branches;
next	1.1;

1.1
date	91.02.11.09.56.01;	author pjt;	state Exp;
branches;
next	;

11.6.2.1
date	2001.01.05.19.10.43;	author jra;	state Exp;
branches;
next	;

11.14.2.1
date	2002.09.19.18.02.10;	author morrison;	state Exp;
branches;
next	;


desc
@@


11.17
log
@moved to src/nirt/
@
text
@/*		P A R S E _ F M T . C
 *
 *	
 */
#ifndef lint
static const char RCSid[] = "$Header: /n/xoff/cvs/brlcad/nirt/parse_fmt.c,v 11.16 2004/05/10 15:30:49 erikg Exp $";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>

#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include <ctype.h>
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "externs.h"
#include "./nirt.h"
#include "./usrfmt.h"

/* The table of output values */
outval		ValTab[] =
		{
		    { 0, VTI_LITERAL },
		    { "x_orig", VTI_X_ORIG, OIT_FLOAT },
		    { "y_orig", VTI_Y_ORIG, OIT_FLOAT },
		    { "z_orig", VTI_Z_ORIG, OIT_FLOAT },
		    { "h", VTI_H, OIT_FLOAT },
		    { "v", VTI_V, OIT_FLOAT },
		    { "d_orig", VTI_D_ORIG, OIT_FLOAT },
		    { "x_dir", VTI_X_DIR, OIT_FNOUNIT },
		    { "y_dir", VTI_Y_DIR, OIT_FNOUNIT },
		    { "z_dir", VTI_Z_DIR, OIT_FNOUNIT },
		    { "a", VTI_A, OIT_FNOUNIT },
		    { "e", VTI_E, OIT_FNOUNIT },
		    { "x_in", VTI_X_IN, OIT_FLOAT },
		    { "y_in", VTI_Y_IN, OIT_FLOAT },
		    { "z_in", VTI_Z_IN, OIT_FLOAT },
		    { "d_in", VTI_D_IN, OIT_FLOAT },
		    { "x_out", VTI_X_OUT, OIT_FLOAT },
		    { "y_out", VTI_Y_OUT, OIT_FLOAT },
		    { "z_out", VTI_Z_OUT, OIT_FLOAT },
		    { "d_out", VTI_D_OUT, OIT_FLOAT },
		    { "los", VTI_LOS, OIT_FLOAT },
		    { "scaled_los", VTI_SLOS, OIT_FLOAT },
		    { "path_name", VTI_PATH_NAME, OIT_STRING },
		    { "reg_name", VTI_REG_NAME, OIT_STRING },
		    { "reg_id", VTI_REG_ID, OIT_INT },
		    { "obliq_in", VTI_OBLIQ_IN, OIT_FNOUNIT },
		    { "obliq_out", VTI_OBLIQ_OUT, OIT_FNOUNIT },
		    { "nm_x_in", VTI_NM_X_IN, OIT_FNOUNIT },
		    { "nm_y_in", VTI_NM_Y_IN, OIT_FNOUNIT },
		    { "nm_z_in", VTI_NM_Z_IN, OIT_FNOUNIT },
		    { "nm_d_in", VTI_NM_D_IN, OIT_FNOUNIT },
		    { "nm_h_in", VTI_NM_H_IN, OIT_FNOUNIT },
		    { "nm_v_in", VTI_NM_V_IN, OIT_FNOUNIT },
		    { "nm_x_out", VTI_NM_X_OUT, OIT_FNOUNIT },
		    { "nm_y_out", VTI_NM_Y_OUT, OIT_FNOUNIT },
		    { "nm_z_out", VTI_NM_Z_OUT, OIT_FNOUNIT },
		    { "nm_d_out", VTI_NM_D_OUT, OIT_FNOUNIT },
		    { "nm_h_out", VTI_NM_H_OUT, OIT_FNOUNIT },
		    { "nm_v_out", VTI_NM_V_OUT, OIT_FNOUNIT },
		    { "ov_reg1_name", VTI_OV_REG1_NAME, OIT_STRING },
		    { "ov_reg1_id", VTI_OV_REG1_ID, OIT_INT },
		    { "ov_reg2_name", VTI_OV_REG2_NAME, OIT_STRING },
		    { "ov_reg2_id", VTI_OV_REG2_ID, OIT_INT },
		    { "ov_sol_in", VTI_OV_SOL_IN, OIT_STRING },
		    { "ov_sol_out", VTI_OV_SOL_OUT, OIT_STRING },
		    { "ov_los", VTI_OV_LOS, OIT_FLOAT },
		    { "ov_x_in", VTI_OV_X_IN, OIT_FLOAT },
		    { "ov_y_in", VTI_OV_Y_IN, OIT_FLOAT },
		    { "ov_z_in", VTI_OV_Z_IN, OIT_FLOAT },
		    { "ov_d_in", VTI_OV_D_IN, OIT_FLOAT },
		    { "ov_x_out", VTI_OV_X_OUT, OIT_FLOAT },
		    { "ov_y_out", VTI_OV_Y_OUT, OIT_FLOAT },
		    { "ov_z_out", VTI_OV_Z_OUT, OIT_FLOAT },
		    { "ov_d_out", VTI_OV_D_OUT, OIT_FLOAT },
		    { "surf_num_in", VTI_SURF_NUM_IN, OIT_INT },
		    { "surf_num_out", VTI_SURF_NUM_OUT, OIT_INT },
		    { "claimant_count", VTI_CLAIMANT_COUNT, OIT_INT },
		    { "claimant_list", VTI_CLAIMANT_LIST, OIT_STRING },
		    { "claimant_listn", VTI_CLAIMANT_LISTN, OIT_STRING },
		    { "attributes", VTI_ATTRIBUTES, OIT_STRING },
		    { 0 }
		};
outitem		*oi_list[FMT_NONE];
static char	def_dest_string[] = "stdout";
char		*dest_string = def_dest_string;
static char	def_sf_name[] = DEF_SF_NAME;	
char		*sf_name = def_sf_name;		/* Name of state file */

FILE		*outf = (FILE *)NULL;
char		*def_fmt[] =
		{
		    "\"Origin (x y z) = (%.2f %.2f %.2f)  (h v d) = (%.2f %.2f %.2f)\nDirection (x y z) = (%.4f %.4f %.4f)  (az el) = (%.2f %.2f)\n\" x_orig y_orig z_orig h v d_orig x_dir y_dir z_dir a e",
		    "\"    Region Name               Entry (x y z)              LOS  Obliq_in Attrib\n\"",
		    "\"%-20s (%9.3f %9.3f %9.3f) %8.2f %8.3f %s\n\" reg_name x_in y_in z_in los obliq_in attributes",
		    "\"\"",
		    "\"You missed the target\n\"",
		    "\"OVERLAP: '%s' and '%s' xyz_in=(%g %g %g) los=%g\n\" ov_reg1_name ov_reg2_name ov_x_in ov_y_in ov_z_in ov_los"
		};

void				free_ospec(outitem *oil);

extern double			base2local;
extern struct application	ap;
extern char			local_u_name[];
extern int			overlap_claims;
extern char			*ocname[];

void 
format_output (char *buffer, com_table	*ctp)
{
    char	*bp = buffer;	/* was  + 1; */
    int		fmt_type = FMT_NONE;
    int		i;
    int		use_defaults = 0;

    void	parse_fmt(char *uoutspec, int outcom_type);
    void	show_ospec(outitem *oil);

    /* Handle no args, arg=='?', and obvious bad arg */
    if (*bp != '\0')
	++bp;
    while (isspace(*bp))
	++bp;
    switch (*bp)
    {
	case 'r':
	    fmt_type = FMT_RAY;
	    break;
	case 'h':
	    fmt_type = FMT_HEAD;
	    break;
	case 'p':
	    fmt_type = FMT_PART;
	    break;
	case 'f':
	    fmt_type = FMT_FOOT;
	    break;
	case 'm':
	    fmt_type = FMT_MISS;
	    break;
	case 'o':
	    fmt_type = FMT_OVLP;
	    break;
	default:
	    --bp;
	    break;
    }
    while (isspace(*++bp))
	;

    switch (*bp)
    {
	case '\0':     /* display current output specs */
	    if (fmt_type == FMT_NONE)
		fprintf(stderr, "Error: No output-statement type specified\n");
	    else
		show_ospec(oi_list[fmt_type]);
	    return;
	case '"':
	    if (fmt_type == FMT_NONE)
	    {
		fprintf(stderr, "Error: No output-statement type specified\n");
		return;
	    }
	    break;
	default:
	    if (strncmp(bp, "default", 7) == 0)
	    {
		use_defaults = 1;
		break;
	    }
	    fprintf(stderr, "Error: Illegal format specifiation: '%s'\n",
		buffer);
	    /* fall through here */
	case '?':
	    com_usage(ctp);
	    return;
    }

    if (use_defaults)
	if (fmt_type == FMT_NONE)
	    for (i = 0; i < FMT_NONE; ++i)
		parse_fmt(def_fmt[i], i);
	else
	    parse_fmt(def_fmt[fmt_type], fmt_type);
    else
	parse_fmt(bp, fmt_type);
}

void parse_fmt(char *uoutspec, int outcom_type)

    	          	/* The user's output specification (format & args) */
   	            	/* Type of output command */

{
    char	*of;		/* Format for current output item */
    char	*up;
    char	*mycopy;	/* Solely for handing to rt_free() */
    char	*uos;
    int		nm_cs;		/* Number of conversion specifications */
    outitem	*oil = OUTITEM_NULL;
    outitem	*oip;
    outitem	*prev_oip = OUTITEM_NULL;
    outval	*vtp;

    /* N.B. rt_malloc() only returns upon successful allocation */

    mycopy = uos = rt_malloc(strlen(uoutspec) + 1, "uos");
    strcpy(uos, uoutspec);
    /* Break up the format specification into pieces,
     * one per conversion specification (and, hopefully)
     * one per argument.
     */
    if (*uos != '"')
    {
	fprintf(stderr,
	    "parse_fmt sees first character `%c`.  Shouldn't happen.\n",
	    *uos);
	rt_free(mycopy, "Copy of user's output spec");
	return;
    }
    ++uos;
    while (*uos != '"')
    {
	nm_cs = 0;
	/* Allocate storage for the next item in the output list */
	oip = (outitem *) rt_malloc(sizeof(outitem), "output item");
	oip -> next = OUTITEM_NULL;

	for (up = uos; *uos != '"'; ++uos)
	{
		if (*uos == '%') {
			if (*(uos + 1) == '%')
				++uos;
			else if (nm_cs == 1)
				break;
			else /* nm_cs == 0 */
				++nm_cs;
		}
		if (*uos == '\\')
			if (*(uos + 1) == '"')
				++uos;
	}

	/* Allocate memory for and store the format.
	 * The code_nm field will be used at this point
	 * to record whether this format specification
	 * needs an output item or not (i.e. whether it
	 * contains 1 conversion spec vs. none)
	 */
    	oip->format = rt_malloc(uos - up + 1, "format");
	of = oip -> format;
	while (up != uos)
	{
	    if (*up == '\\')
		switch (*(up + 1))
		{
		    case 'n':
			*of++ = '\n';
			up += 2;
			break;
		    case '\042':
		    case '\047':
		    case '\134':
			*of++ = *(up + 1);
			up += 2;
			break;
		    default:
			*of++ = *up++;
			break;
		}
	    else
		*of++ = *up++;
	}
	*of = '\0';
	oip -> code_nm = nm_cs;

	if (prev_oip == OUTITEM_NULL)
	    oil = oip;
	else
	    prev_oip -> next = oip;
	prev_oip = oip;
    }
    
    /* Skip any garbage beyond the close quote */
    for (up = ++uos; (! isspace(*uos)) && (*uos != '\0'); ++uos)
	;
    if (up != uos)
    {
	*uos = '\0';
	fprintf(stderr,
	    "Warning: suffix '%s' after format specification ignored\n",
	    up);
    }

    /* Read in the list of objects to output */
    for (oip = oil; oip != OUTITEM_NULL; oip = oip -> next)
    {
	if (oip -> code_nm == 0)
	    continue;		/* outitem's format has no conversion spec */
	
	while (isspace(*uos))
	    ++uos;
	if (*uos == '\0')
	{
	    fprintf(stderr,
		"Error: Fewer output items than conversion specs\n");
	    rt_free(mycopy, "Copy of user's output spec");
	    return;
	}
	for (up = uos; (! isspace(*uos)) && (*uos != '\0'); ++uos)
	    ;

	if (*uos != '\0')
	    *uos++ = '\0';

	oip -> code_nm = 0;
	for (vtp = ValTab + 1; vtp -> name; ++vtp)
	    if (strcmp(vtp -> name, up) == 0)
	    {
		oip -> code_nm = vtp -> code_nm;
		break;
	    }

	if (vtp -> name == '\0')
	{
	    fprintf(stderr, "Error: Invalid output item '%s'\n", up);
	    rt_free(mycopy, "Copy of user's output spec");
	    return;
	}
    }

    while (isspace(*uos))
	++uos;
    if (*uos != '\0')
    {
	fprintf(stderr, "Error: More output items than conversion specs\n");
	fprintf( stderr, "Offending spec:\n\t%s\n", mycopy );
	rt_free(mycopy, "Copy of user's output spec");
	return;
    }

    check_conv_spec(oil);

    /* We are now satisfied that oil is a valid list of output items,
     * so it's time to install it as such
     */
    free_ospec(oi_list[outcom_type]);
    oi_list[outcom_type] = oil;

    rt_free(mycopy, "Copy of user's output spec");
}

void default_ospec (void)
{
    int	i;

    for (i = 0; i < FMT_NONE; ++i)
    {
	oi_list[i] = OUTITEM_NULL;
	parse_fmt(def_fmt[i], i);
    }
}

void show_ospec (outitem *oil)

       		     		/* List of output items */

{
    outitem	*oip;		/* Pointer into list of output items */
    char	*c;

    /* Display the format specification */
    printf("Format: \"");
    for (oip = oil; oip != OUTITEM_NULL; oip = oip -> next)
	for (c = oip -> format; *c != '\0'; ++c)
	    if (*c == '\n')
		printf("\\n");
	    else
		putchar(*c);
    printf("\"\n");

    /* Display the list of item names */
    printf("Item(s):");
    for (oip = oil; oip != OUTITEM_NULL; oip = oip -> next)
	if (ValTab[oip -> code_nm].name)
	    printf(" %s", ValTab[oip -> code_nm].name);
    printf("\n");
}


void report(int outcom_type)
{
    outitem	*oip;

    if ((outcom_type < 0) || (outcom_type >= FMT_NONE))
    {
	fprintf(stderr,
	    "Illegal output-statement type: %d.  Shouldn't happen\n",
	    outcom_type);
	return;
    }
    if( outf == (FILE *)NULL )  outf = stdout;
    for (oip = oi_list[outcom_type]; oip != OUTITEM_NULL; oip = oip -> next)
	switch (ValTab[oip -> code_nm].type)
	{
	    case OIT_INT:
		fprintf(outf, oip -> format, ValTab[oip -> code_nm].value.ival);
		break;
	    case OIT_FLOAT:
		fprintf(outf, oip -> format,
		    ValTab[oip -> code_nm].value.fval * base2local);
		break;
	    case OIT_FNOUNIT:
		fprintf(outf, oip -> format,
		    ValTab[oip -> code_nm].value.fval);
		break;
	    case OIT_STRING:
		fprintf(outf, oip -> format, ValTab[oip -> code_nm].value.sval);
		break;
	    default:
		fflush(stdout);
		fprintf(stderr, "Fatal: Invalid item type %d.  ",
		    ValTab[oip -> code_nm].type);
		fprintf(stderr, "This shouldn't happen\n");
		exit (1);
	}
    fflush(outf);
}

void print_item (char *buffer, com_table *ctp)
{
    char	*bp = buffer;
    char	*bp0;
    outval	*vtp;


    /* Handle no args, arg=='?', and obvious bad arg */
    if (*bp != '\0')
	++bp;
    while (isspace(*bp))
	++bp;
    switch (*bp)
    {
	case '\0':
	case '?':
	    com_usage(ctp);
	    return;
    }

    /* Read in the list of objects to output */
    while (*bp != '\0')
    {
	while (isspace(*bp))
	    ++bp;

	for (bp0 = bp; (! isspace(*bp)) && (*bp != '\0'); ++bp)
	    ;

	if (*bp != '\0')
	    *bp++ = '\0';

	for (vtp = ValTab + 1; vtp -> name; ++vtp)
	    if (strcmp(vtp -> name, bp0) == 0)
	    {
		switch (vtp -> type)
		{
		    case OIT_INT:
			printf("%d\n", vtp -> value.ival);
			break;
		    case OIT_FLOAT:
			printf("%g\n", vtp -> value.fval * base2local);
			break;
		    case OIT_FNOUNIT:
			printf("%g\n", vtp -> value.fval);
			break;
		    case OIT_STRING:
			printf("'%s'\n", vtp -> value.sval);
			break;
		    default:
			fflush(stdout);
			fprintf(stderr, "Fatal: Invalid item type %d.  ",
			    ValTab[vtp -> code_nm].type);
			fprintf(stderr, "This shouldn't happen\n");
			exit (1);
		}
		break;
	    }

	if (vtp -> name == '\0')
	{
	    fprintf(stderr, "Error: Invalid output item '%s'\n", bp0);
	    return;
	}
    }
}

FILE *fopenrc(void)
{
    char	*rc_file_name;
    char	*home;
    FILE	*fPtr;
    
    if ((fPtr = fopen(DEF_RCF_NAME, "r")) == NULL)
    {
	if ((home = getenv("HOME")) != NULL)
	{
	    rc_file_name = rt_malloc(strlen(home) + strlen(DEF_RCF_NAME) + 2,
	    			"rc_file_name");
	    sprintf(rc_file_name, "%s/%s", home, DEF_RCF_NAME);
	    fPtr = fopen(rc_file_name, "r");
	}
    }
    return (fPtr);
}

int check_conv_spec (outitem *oip)
{
    char	*cp;
    int		oi_type;
    int		warnings = 0;

    for ( ; oip != OUTITEM_NULL; oip = oip -> next)
    {
	for (cp = oip -> format; *cp != '\0'; ++cp)
		if (*cp == '%') {
			if (*(cp + 1) == '%')
				++cp;
			else
			{
				++cp;
				break;
			}
		}

	if (*cp == '\0')		/* Added 8 Jun 90 */
	    continue;

	/* Skip optional crud */
	if (*cp == '-')
	    ++cp;
	while (isdigit(*cp))
	    ++cp;
	if (*cp == '.')
	    ++cp;
	while (isdigit(*cp))
	    ++cp;

	oi_type = ValTab[oip -> code_nm].type;
	switch (*cp)
	{
	    case 'd':
	    case 'o':
	    case 'u':
	    case 'x':
		if (oi_type != OIT_INT)
		{
		    ++warnings;
		    fprintf(stderr,
			"Warning: Conversion type '%%%c' specified",
			*cp);
		    fprintf(stderr,
			" for item %s, which is %s\n",
			ValTab[oip -> code_nm].name, oit_name(oi_type));
		}
		break;
	    case 'f':
	    case 'e':
	    case 'E':
	    case 'g':
	    case 'G':
		if ((oi_type != OIT_FLOAT) && (oi_type != OIT_FNOUNIT))
		{
		    ++warnings;
		    fprintf(stderr,
			"Warning: Conversion type '%%%c' specified",
			*cp);
		    fprintf(stderr,
			" for item %s, which is %s\n",
			ValTab[oip -> code_nm].name, oit_name(oi_type));
		}
		break;
	    case 's':
		if (oi_type != OIT_STRING)
		{
		    ++warnings;
		    fprintf(stderr,
			"Warning: Conversion type '%%%c' specified",
			*cp);
		    fprintf(stderr,
			" for item %s, which is %s\n",
			ValTab[oip -> code_nm].name, oit_name(oi_type));
		}
		break;
	    case 'c':
		++warnings;
		fprintf(stderr,
		    "Warning: Conversion type '%%%c' specified", *cp);
		fprintf(stderr,
			" for item %s, which is a %s\n",
			ValTab[oip -> code_nm].name, oit_name(oi_type));
		break;
	    default:
		++warnings;
		fprintf(stderr,
		    "Warning: Unknown conversion type '%%%c'\n", *cp);
		break;
	}
    }
    return (warnings);
}

void direct_output(char *buffer, com_table *ctp)
{
    int 	i = 0;      /* current position on the *buffer        */
    FILE	*newf;
    static char	*new_dest;
#if !defined(HAVE_POPEN_DECL) && !defined(CRAY2)
    RT_EXTERN(FILE *popen, (const char *command, const char *type) );
#endif
    static FILE	*(*openfunc)() = 0;

    while (isspace(*(buffer+i)))
	    ++i;

    if (*(buffer+i) == '\0')     /* display current destination */
    {
	printf("destination = %s%s'\n",
	    (openfunc == popen) ? "'| " : "'", dest_string);
	return;
    }
    
    if (strcmp(buffer + i, "?") == 0)
    {
	com_usage(ctp);
	return;
    }

    if (strcmp(buffer + i, "default") == 0) {
	newf = stdout;
	new_dest = def_dest_string;
	openfunc = 0;
    } else {
	if (*(buffer + i) == '|') {
	    openfunc=popen;
	    ++i;
	} else
	    openfunc=fopen;

	new_dest = rt_malloc(strlen(buffer + i)+1,"new_dest");

	sprintf(new_dest, "%s", buffer + i);
	if ((newf = (*openfunc)(new_dest, "w")) == NULL) {
	    fprintf(stderr, "Cannot open %s '%s'\n",
		(openfunc == popen) ? "pipe" : "file", new_dest);
	    fprintf(stderr, "Destination remains = '%s'\n", dest_string);

	    rt_free(new_dest, "new(now old)dest");
	    return;
	}


    }

    /* Clean up from previous output destination */
    if (outf != (FILE *)NULL && outf != stdout)
	fclose(outf);

    if (dest_string != def_dest_string)
	rt_free(dest_string, "free dest_string");

    /* Establish the new destination */
    outf = newf;
    dest_string = new_dest;
}

void state_file(char *buffer, com_table *ctp)
{
    int 	i = 0;      /* current position on the *buffer        */
    static char	*new_name;

    while (isspace(*(buffer+i)))
	    ++i;
    if (*(buffer+i) == '\0')     /* display current state name */
    {
	printf("statefile = '%s'\n", sf_name);
	return;
    }
    
    if (strcmp(buffer + i, "?") == 0)
    {
	com_usage(ctp);
	return;
    }

    if (strcmp(buffer + i, "default") == 0)
	new_name = def_sf_name;
    else
    {
	new_name = rt_malloc(strlen(buffer + i)+1, "new_state_filename");
	sprintf(new_name, "%s", buffer + i);
    }

    /* Clean up from previous output destination */
    if (sf_name != def_sf_name)
	rt_free(sf_name, "new(now old)statefile");

    /* Establish the new destination */
    sf_name = new_name;
}

void dump_state(char *buffer, com_table *ctp)
{
    char	*c;
    static char	fmt_char[] = {'r', 'h', 'p', 'f', 'm', 'o'};
    FILE	*sfPtr;
    int		f;
    outitem	*oip;		/* Pointer into list of output items */

    if ((sfPtr = fopen(sf_name, "w")) == NULL)
    {
	fprintf(stderr, "Cannot open statefile '%s'\n", sf_name);
	return;
    }

    printf("Dumping NIRT state to file '%s'...", sf_name);
    fprintf(sfPtr, "%c file created by the dump command of nirt\n", CMT_CHAR);
    fprintf(sfPtr, "xyz %g %g %g\n", target(X), target(Y), target(Z));
    fprintf(sfPtr, "dir %g %g %g\n", direct(X), direct(Y), direct(Z));
    fprintf(sfPtr, "useair %d\n", ap.a_rt_i -> useair);
    fprintf(sfPtr, "units %s\n", local_u_name);
    if (strcmp(dest_string, "stdout") == 0)
	fputs("dest default\n", sfPtr);
    else
	fprintf(sfPtr, "dest %s\n", dest_string);
    fprintf(sfPtr, "overlap_claims %s\n", ocname[overlap_claims]);

    for (f = 0; f < FMT_NONE; ++f)
    {
	fprintf(sfPtr, "fmt %c \"", fmt_char[f]);
	/* Display the conversion specifications */
	for (oip = oi_list[f]; oip != OUTITEM_NULL; oip = oip -> next)
	    for (c = oip -> format; *c != '\0'; ++c)
		if (*c == '\n')
		    fprintf(sfPtr, "\\n");
		else
		    fputc(*c, sfPtr);
	fprintf(sfPtr, "\"");

	/* Display the item name */
	for (oip = oi_list[f]; oip != OUTITEM_NULL; oip = oip -> next)
	    if (ValTab[oip -> code_nm].name)
		fprintf(sfPtr, " %s", ValTab[oip -> code_nm].name);
	fprintf(sfPtr, "\n");
    }
    printf("\n");
    fclose(sfPtr);
}

void load_state(char *buffer, com_table *ctp)
{
    FILE	*sfPtr;

    if ((sfPtr = fopen(sf_name, "r")) == NULL)
    {
	fprintf(stderr, "Cannot open statefile '%s'\n", sf_name);
	return;
    }
    bu_log("Loading NIRT state from file '%s'...", sf_name);
    interact(READING_FILE, sfPtr);
    bu_log("\n");
    fclose(sfPtr);
}

void free_ospec (outitem *oil)

       		     		/* List of output items */

{
    outitem	*next = oil;	/* Pointer to next output item */
    outitem	*oip;		/* Pointer to output item to free */

    while (next != OUTITEM_NULL)
    {
	oip = next;
	next = oip -> next;
	rt_free(oip -> format, "outitem.format");
	if (oip != oil)
	    rt_free((char *) oip, "outitem");
    }
}
@


11.16
log
@change conf.h to a wrapped config.h
@
text
@d6 1
a6 1
static const char RCSid[] = "$Header: /cvs/brlcad/nirt/parse_fmt.c,v 11.15 2004/04/05 07:39:41 morrison Exp $";
@


11.15
log
@merge of ansi-6-0-branch into HEAD
@
text
@d6 1
a6 1
static const char RCSid[] = "$Header$";
d9 5
a13 1
#include "conf.h"
@


11.14
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d6 1
a6 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/parse_fmt.c,v 11.12 2002/02/20 21:06:21 butler Exp $";
d109 1
a109 1
void				free_ospec();
d125 2
a126 2
    void	parse_fmt();
    void	show_ospec();
d199 1
a199 1
void parse_fmt(uoutspec, outcom_type)
d201 2
a202 2
char	*uoutspec;	/* The user's output specification (format & args) */
int	outcom_type;	/* Type of output command */
d363 1
a363 1
void default_ospec ()
d374 1
a374 1
void show_ospec (oil)
d376 1
a376 1
outitem		*oil;		/* List of output items */
d401 1
a401 4
void report(outcom_type)

int	outcom_type;

d440 1
a440 5
void print_item (buffer, ctp)

char		*buffer;
com_table	*ctp;

d507 1
a507 1
FILE *fopenrc()
d526 1
a526 4
int check_conv_spec (oip)

outitem	*oip;

d622 1
a622 5
void direct_output(buffer, ctp)

char		*buffer;
com_table	*ctp;

d686 1
a686 5
void state_file(buffer, ctp)

char		*buffer;
com_table	*ctp;

d721 1
a721 5
void dump_state(buffer, ctp)

char		*buffer;
com_table	*ctp;

d769 1
a769 5
void load_state(buffer, ctp)

char		*buffer;
com_table	*ctp;

d784 1
a784 1
void free_ospec (oil)
d786 1
a786 1
outitem		*oil;		/* List of output items */
@


11.14.2.1
log
@Initial ANSIfication
@
text
@d6 1
a6 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/parse_fmt.c,v 11.14 2002/08/20 17:08:30 jra Exp $";
d109 1
a109 1
void				free_ospec(outitem *oil);
d125 2
a126 2
    void	parse_fmt(char *uoutspec, int outcom_type);
    void	show_ospec(outitem *oil);
d199 1
a199 1
void parse_fmt(char *uoutspec, int outcom_type)
d201 2
a202 2
    	          	/* The user's output specification (format & args) */
   	            	/* Type of output command */
d363 1
a363 1
void default_ospec (void)
d374 1
a374 1
void show_ospec (outitem *oil)
d376 1
a376 1
       		     		/* List of output items */
d401 4
a404 1
void report(int outcom_type)
d443 5
a447 1
void print_item (char *buffer, com_table *ctp)
d514 1
a514 1
FILE *fopenrc(void)
d533 4
a536 1
int check_conv_spec (outitem *oip)
d632 5
a636 1
void direct_output(char *buffer, com_table *ctp)
d700 5
a704 1
void state_file(char *buffer, com_table *ctp)
d739 5
a743 1
void dump_state(char *buffer, com_table *ctp)
d791 5
a795 1
void load_state(char *buffer, com_table *ctp)
d810 1
a810 1
void free_ospec (outitem *oil)
d812 1
a812 1
       		     		/* List of output items */
@


11.13
log
@Converted from K&R to ANSI C - RFH
@
text
@d109 1
a109 1
void				free_ospec(outitem *oil);
d125 2
a126 2
    void	parse_fmt(char *uoutspec, int outcom_type);
    void	show_ospec(outitem *oil);
d199 1
a199 1
void parse_fmt(char *uoutspec, int outcom_type)
d201 2
a202 2
    	          	/* The user's output specification (format & args) */
   	            	/* Type of output command */
d363 1
a363 1
void default_ospec (void)
d374 1
a374 1
void show_ospec (outitem *oil)
d376 1
a376 1
       		     		/* List of output items */
d401 4
a404 1
void report(int outcom_type)
d443 5
a447 1
void print_item (char *buffer, com_table *ctp)
d514 1
a514 1
FILE *fopenrc(void)
d533 4
a536 1
int check_conv_spec (outitem *oip)
d632 5
a636 1
void direct_output(char *buffer, com_table *ctp)
d700 5
a704 1
void state_file(char *buffer, com_table *ctp)
d739 5
a743 1
void dump_state(char *buffer, com_table *ctp)
d791 5
a795 1
void load_state(char *buffer, com_table *ctp)
d810 1
a810 1
void free_ospec (outitem *oil)
d812 1
a812 1
       		     		/* List of output items */
@


11.12
log
@A nicer implementation that uses the string format for the "attributes" value
@
text
@d6 1
a6 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/parse_fmt.c,v 11.11 2002/02/19 21:42:39 butler Exp $";
d109 1
a109 1
void				free_ospec();
d125 2
a126 2
    void	parse_fmt();
    void	show_ospec();
d199 1
a199 1
void parse_fmt(uoutspec, outcom_type)
d201 2
a202 2
char	*uoutspec;	/* The user's output specification (format & args) */
int	outcom_type;	/* Type of output command */
d363 1
a363 1
void default_ospec ()
d374 1
a374 1
void show_ospec (oil)
d376 1
a376 1
outitem		*oil;		/* List of output items */
d401 1
a401 4
void report(outcom_type)

int	outcom_type;

d440 1
a440 5
void print_item (buffer, ctp)

char		*buffer;
com_table	*ctp;

d507 1
a507 1
FILE *fopenrc()
d526 1
a526 4
int check_conv_spec (oip)

outitem	*oip;

d622 1
a622 5
void direct_output(buffer, ctp)

char		*buffer;
com_table	*ctp;

d686 1
a686 5
void state_file(buffer, ctp)

char		*buffer;
com_table	*ctp;

d721 1
a721 5
void dump_state(buffer, ctp)

char		*buffer;
com_table	*ctp;

d769 1
a769 5
void load_state(buffer, ctp)

char		*buffer;
com_table	*ctp;

d784 1
a784 1
void free_ospec (oil)
d786 1
a786 1
outitem		*oil;		/* List of output items */
@


11.11
log
@Added support for printing attributes
@
text
@d6 1
a6 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/parse_fmt.c,v 11.10 2001/08/09 19:58:22 jra Exp $";
d89 1
a89 1
		    { "attributes", VTI_ATTRIBUTES, OIT_ATTRIB },
d103 1
a103 1
		    "\"%-20s (%9.3f %9.3f %9.3f) %8.2f %8.3f %A\n\" reg_name x_in y_in z_in los obliq_in attributes",
a399 39
void
format_attributes(char *s)
{
    struct bu_mro **attr_vals;
    int i;
    char *p;
    struct bu_vls *vls;

    attr_vals = 
	((struct region *)ValTab[VTI_ATTRIBUTES].value.sval)->attr_values;

    if ( (p=strstr(s, "%A")) == NULL) return;

    /* if there was stuff before the %A in the fmt, print it */
    if (p != s) {
	*p = '\0';
	fprintf(outf, "%s", s);
    }
    p += 2;

    for (i=0 ; i < attrib_use ; i++) {
	BU_CK_MRO(attr_vals[i]);

	vls = &attr_vals[i]->string_rep;

	/* XXX only print attributes that actually were set */
	if (bu_vls_strlen(vls) > 0) {
	    fprintf(outf, "%s=\"%s\" ",
		    attrib[i], bu_vls_addr(vls));
	}
    }

    if (*p) {
	fprintf(outf, "%s", p);
    }
}



a432 12
	    case OIT_ATTRIB:
		switch (outcom_type) {
		case FMT_RAY: break;
		case FMT_FOOT: /* fallthrough */
		case FMT_HEAD: fprintf(outf, "Attributes"); break;
		case FMT_PART: format_attributes(oip->format); break;
		case FMT_MISS: break;
		case FMT_OVLP: break;
		case FMT_NONE: break;
		}

		break;
a620 2
		break;
	    case 'A':
@


11.10
log
@lint
@
text
@d6 1
a6 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/parse_fmt.c,v 11.9 2001/04/05 19:35:52 morrison Exp $";
d89 1
d102 2
a103 2
		    "\"    Region Name               Entry (x y z)              LOS  Obliq_in\n\"",
		    "\"%-20s (%9.3f %9.3f %9.3f) %8.2f %8.3f\n\" reg_name x_in y_in z_in los obliq_in",
d117 2
a118 5
void format_output (buffer, ctp)

char		*buffer;
com_table	*ctp;

d400 40
d472 12
d672 2
@


11.9
log
@updated SIGNED to signed
updated CONST to const
@
text
@d6 1
a6 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/parse_fmt.c,v 11.8 2001/01/05 19:11:08 jra Exp $";
d12 7
d243 11
a253 10
	    if (*uos == '%')
		if (*(uos + 1) == '%')
		    ++uos;
		else if (nm_cs == 1)
		    break;
		else /* nm_cs == 0 */
		    ++nm_cs;
	    if (*uos == '\\')
		if (*(uos + 1) == '"')
		    ++uos;
d546 8
a553 7
	    if (*cp == '%')
		if (*(cp + 1) == '%')
		    ++cp;
		else
		{
		    ++cp;
		    break;
@


11.8
log
@if_hit() now prints ALL overlaps for a given partition
@
text
@d6 1
a6 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/parse_fmt.c,v 11.6 2000/05/22 15:54:08 pjt Exp $";
d634 1
a634 1
    RT_EXTERN(FILE *popen, (CONST char *command, CONST char *type) );
@


11.7
log
@
lint
@
text
@d6 1
a6 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/parse_fmt.c,v 11.6 2000/05/22 15:54:08 pjt Exp $";
d341 1
@


11.6
log
@Added support for overlap claimants
@
text
@d6 1
a6 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/parse_fmt.c,v 11.5 1997/12/11 19:09:56 pjt Exp $";
@


11.6.2.1
log
@if_hit() now prints ALL overlaps for a given partition
@
text
@d6 1
a6 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/parse_fmt.c,v 11.6 2000/05/22 15:54:08 pjt Exp $";
a340 1
	fprintf( stderr, "Offending spec:\n\t%s\n", mycopy );
@


11.5
log
@Updated syntax of call to interact() within load_state().
@
text
@d6 1
a6 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/parse_fmt.c,v 11.4 1997/12/08 18:55:17 pjt Exp $";
d79 3
d106 2
d758 1
@


11.4
log
@Fixed the ability to get a double quote into a format string
@
text
@d6 1
a6 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/parse_fmt.c,v 11.3 1997/02/07 15:04:50 pjt Exp $";
d789 3
a791 3
    printf("Loading NIRT state from file '%s'...", sf_name);
    interact(sfPtr);
    printf("\n");
@


11.3
log
@Added output items for entry- and exit-surface numbers
for the entry and exit solids of each partition
@
text
@d6 1
a6 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/parse_fmt.c,v 11.2 1996/08/30 19:10:03 pjt Exp $";
d253 17
a269 5
	    if ((*up == '\\') && (*(up + 1) == 'n'))
	    {
		*of++ = '\n';
		up += 2;
	    }
@


11.2
log
@Change all the normal entries in ValTab from OIT_FLOAT
to OIT_FNOUNIT to fix bug that was converting normals
to local units
@
text
@d6 1
a6 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/parse_fmt.c,v 11.1 1995/01/04 10:22:18 mike Rel4_4 pjt $";
d77 2
@


11.1
log
@Release_4.4
@
text
@d6 1
a6 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/parse_fmt.c,v 10.7 94/12/30 18:36:45 gdurf Exp $";
d50 12
a61 12
		    { "nm_x_in", VTI_NM_X_IN, OIT_FLOAT },
		    { "nm_y_in", VTI_NM_Y_IN, OIT_FLOAT },
		    { "nm_z_in", VTI_NM_Z_IN, OIT_FLOAT },
		    { "nm_d_in", VTI_NM_D_IN, OIT_FLOAT },
		    { "nm_h_in", VTI_NM_H_IN, OIT_FLOAT },
		    { "nm_v_in", VTI_NM_V_IN, OIT_FLOAT },
		    { "nm_x_out", VTI_NM_X_OUT, OIT_FLOAT },
		    { "nm_y_out", VTI_NM_Y_OUT, OIT_FLOAT },
		    { "nm_z_out", VTI_NM_Z_OUT, OIT_FLOAT },
		    { "nm_d_out", VTI_NM_D_OUT, OIT_FLOAT },
		    { "nm_h_out", VTI_NM_H_OUT, OIT_FLOAT },
		    { "nm_v_out", VTI_NM_V_OUT, OIT_FLOAT },
@


10.7
log
@Fixed #ifdef around popen declaration
@
text
@d6 1
a6 1
static char RCSid[] = "$Header: /n/wolf/m/cad/nirt/RCS/parse_fmt.c,v 10.6 1994/12/21 10:29:08 pjt Exp gdurf $";
@


10.6
log
@Added output item for scaled LOS for each partition
@
text
@d6 1
a6 1
static char RCSid[] = "$Header: /n/wolf/m/cad/nirt/RCS/parse_fmt.c,v 10.5 94/12/16 08:21:52 jra Exp $";
d613 1
a613 1
#ifndef CRAY2
@


10.5
log
@CRAY2 doesn't like redefinition of popen.
@
text
@d6 1
a6 1
static char RCSid[] = "$Header: /n/wolf/m/cad/nirt/RCS/parse_fmt.c,v 10.4 94/10/14 17:25:39 mike Exp Locker: jra $";
d44 1
@


10.4
log
@Added extern of popen(), for SunOS 5 machines which don't.
@
text
@d6 1
a6 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/parse_fmt.c,v 10.3 94/08/24 14:01:22 gdurf Exp Locker: mike $";
d612 1
d614 1
@


10.3
log
@Added include of conf.h
@
text
@d6 1
a6 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/parse_fmt.c,v 10.2 1992/03/16 22:25:54 mike Exp gdurf $";
d612 1
a612 1

@


10.2
log
@IRIX 4.0.1
@
text
@d6 1
a6 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/parse_fmt.c,v 10.1 91/10/12 06:53:33 mike Rel4_0 Locker: mike $";
d8 2
@


10.1
log
@Release_4.0
@
text
@d6 1
a6 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/parse_fmt.c,v 1.17 91/08/29 14:17:24 pjt Exp $";
d82 1
a82 1
FILE		*outf = stdout;
d385 1
d656 1
a656 1
    if (outf != stdout)
@


1.17
log
@Added output items for entry and exit normals
for each partition.
@
text
@d6 1
a6 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/parse_fmt.c,v 1.16 91/07/30 11:05:17 pjt Exp $";
@


1.16
log
@Removed check of value returned by rt_malloc(),
since it only returns on successful allocation.
@
text
@d6 1
a6 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/parse_fmt.c,v 1.15 91/07/30 10:41:33 pjt Exp $";
d47 12
@


1.15
log
@1. Fixed linked list of outitems in parse_fmt().
   Code expected the list to be terminated by OUTITEM_NULL,
   but it forgot to set the pointer in newly created node.
2. Patched two memory leaks:
   - It now rt_frees char *uos (actually char *mycopy)
   - It now rt_frees the previous list of output items
     (using free_ospec()) before installing a new list.
@
text
@d6 1
a6 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/parse_fmt.c,v 1.14 91/07/25 12:54:04 pjt Exp $";
d188 2
d209 1
a209 7
	if  ((oip = (outitem *) rt_malloc(sizeof(outitem), "output item"))
		== OUTITEM_NULL)
	{
	    fflush(stdout);
	    fprintf(stderr, "parse_fmt(): Ran out of memory\n");
	    exit (1);
	}
d679 2
a680 1
    else {
@


1.14
log
@Corrected default fmt h, by swapping "LOS" and "Obliq_in"
to agree with what the fmt p was actually producing
@
text
@d6 1
a6 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/parse_fmt.c,v 1.13 91/07/18 14:23:15 pjt Exp $";
d80 4
a83 1
extern double	base2local;
d85 1
a85 1
extern char		local_u_name[];
d180 1
d188 1
a188 1
    uos = rt_malloc(strlen(uoutspec) + 1, "uos");
d199 1
d207 2
a208 1
	if  ((oip = getmem(outitem)) == OUTITEM_NULL)
d214 1
d281 1
d301 1
d311 1
d320 1
d323 1
a323 4
    /* NOTICE - The previous contents of oi_list[outcom_type] should be
     *		freed before oil is installed there.  We're
     *		currently wasting memory.
     */
d325 1
d331 2
d334 1
d764 18
@


1.13
log
@Added second argument, (char *) to call to rt_free()
@
text
@d6 1
a6 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/parse_fmt.c,v 1.12 91/07/18 00:23:10 butler Exp $";
d74 2
a75 2
		    "\"    Region Name               Entry (x y z)           Obliq_in  LOS\n\"",
		    "\"%-20s (%9.3f %9.3f %9.3f) %8.2f %7.3f\n\" reg_name x_in y_in z_in los obliq_in",
@


1.12
log
@substituted rt_log for (f)printf, rt_malloc for malloc.
plugged memory leak with regard to dest_string.
@
text
@d6 1
a6 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/parse_fmt.c,v 1.11 91/07/02 23:51:22 mike Exp $";
d678 1
a678 1
	rt_free(sf_name);
@


1.11
log
@Added externs.h, for getenv()
@
text
@d6 1
a6 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/parse_fmt.c,v 1.10 91/06/25 13:45:20 pjt Exp $";
d65 4
a68 2
char		*dest_string = "stdout";
char		*sf_name = DEF_SF_NAME;		/* Name of state file */
d184 1
a184 6
    if ((uos = malloc(strlen(uoutspec) + 1)) == NULL)
    {
	fflush(stdout);
	fprintf(stderr, "parse_fmt(): Ran out of memory\n");
	exit(1);
    }
d229 1
a229 6
	if ((oip -> format = malloc(uos - up + 1)) == NULL)
	{
	    fflush(stdout);
	    fprintf(stderr, "parse_fmt(): Ran out of memory\n");
	    exit(1);
	}
d473 2
a474 7
	    if ((rc_file_name =
		malloc(strlen(home) + strlen(DEF_RCF_NAME) + 1)) == NULL)
	    {
		fflush(stdout);
		fputs("fopenrc():  Ran out of memory\n", stderr);
		exit (1);
	    }
d594 1
d607 2
a608 2
    else if (strcmp(buffer + i, "default") == 0)
    {
d610 1
a610 1
	new_dest = "stdout";
d612 2
a613 5
    }
    else
    {
	if (*(buffer + i) == '|')
	{
d616 1
a616 2
	}
	else
d618 3
a620 6
	if ((new_dest = malloc(strlen(buffer + i))) == NULL)
	{
	    fflush(stdout);
	    fprintf(stderr, "direct_output(): Ran out of memory\n");
	    return;
	}
d622 1
a622 2
	if ((newf = (*openfunc)(new_dest, "w")) == NULL)
	{
d626 2
d630 2
a636 13
    /*
     * We were calling free(dest_string) at this point, since any destination
     * the user specifies explicitly (i.e., anything but "default") gets
     * a call to malloc().  However, this free was causing a memory fault
     * when you did several successive "dest default" commands at the
     * "nirt> " prompt.  I guess freeing memory that belongs to a
     * string constant is not such a bright idea.  Anyway, we should
     * probably be returning the malloced memory when appropriate,
     * but a few destination strings shouldnt' take up much room, and
     * there are other bigger mallocs elsewhere that are probably bigger
     * wasters of memory.
     *	PJT	25 Feb 91
     */
d638 3
d668 6
a673 7
    else if (strcmp(buffer + i, "default") == 0)
	new_name = DEF_SF_NAME;
    else if ((new_name = malloc(strlen(buffer + i))) == NULL)
    {
	fflush(stdout);
	fprintf(stderr, "direct_output(): Ran out of memory\n");
	return;
a674 2
    else
	sprintf(new_name, "%s", buffer + i);
d677 2
a678 2
    if (strcmp(sf_name, DEF_SF_NAME) != 0)
	free(sf_name);
@


1.10
log
@Changed default output formats
@
text
@d6 1
a6 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/parse_fmt.c,v 1.9 91/03/15 08:35:44 pjt Exp $";
d14 1
@


1.9
log
@Added path_name output item
@
text
@d6 1
a6 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/parse_fmt.c,v 1.8 91/03/05 14:14:36 pjt Exp $";
d70 3
a72 3
		    "\"Origin (x,y,z) = ( %.2f, %.2f, %.2f)  (h,v,d) = ( %.2f, %.2f, %.2f)\nDirection (x,y,z) = ( %.4f, %.4f, %.4f)  (az,el) = ( %.2f, %.2f)\n\" x_orig y_orig z_orig h v d_orig x_dir y_dir z_dir a e",
		    "\"REG_ID   LOS\n\"",
		    "\"%5d %8.2f\n\" reg_id los",
d75 1
a75 1
		    "\"OVERLAP: '%s' and '%s' xyz_in=(%g, %g, %g) los=%g\n\" ov_reg1_name ov_reg2_name ov_x_in ov_y_in ov_z_in ov_los"
@


1.8
log
@Fixed Cindy Dively's bug wherein dump_state() was writing
"useair=%d\n".  The '=' is now a blank.
@
text
@d6 1
a6 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/parse_fmt.c,v 1.7 91/02/25 14:58:44 pjt Exp $";
d41 1
@


1.7
log
@Removed the line

    free(dest_string)

from direct_output(), because dest_string is often the string constant
"default," and freeing it caused a memory fault.  I should go back
and do this right, so that dest_string DOES get freed when it
points to a MALLOCed string that's no longer needed.
@
text
@d6 1
a6 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/parse_fmt.c,v 1.6 91/02/21 16:11:42 mike Exp $";
d733 1
a733 1
    fprintf(sfPtr, "useair=%d\n", ap.a_rt_i -> useair);
@


1.6
log
@Fixed type errors in "useair" printing
@
text
@d6 1
a6 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/parse_fmt.c,v 1.5 91/02/19 16:20:04 pjt Exp $";
d651 13
a663 1
    free(dest_string);
@


1.5
log
@Added useair and units to the dump routine
@
text
@d6 1
a6 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/parse_fmt.c,v 1.4 91/02/15 16:02:31 mike Exp $";
d11 3
a179 2
    char	*malloc();

a473 2

    char	*getenv();
d721 1
a721 1
    fprintf(sfPtr, "useair %s\n", ap.a_rt_i -> useair);
@


1.4
log
@Converted to Cake
@
text
@d6 1
a6 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/parse_fmt.c,v 1.3 91/02/14 09:21:52 pjt Exp $";
d74 2
d720 1
d722 2
a723 1
    fprintf(sfPtr, "xyz %g %g %g\n", target(X), target(Y), target(Z));
@


1.3
log
@Attempt to add $Header$ to file.
@
text
@d6 1
a6 1
static char RCSid[] = "$Header$";
d11 2
a12 2
#include "nirt.h"
#include "usrfmt.h"
d482 1
a482 1
		fputs(stderr, "fopenrc():  Ran out of memory\n");
@


1.2
log
@Attempt to add $Header$ to file
@
text
@@


1.1
log
@Initial revision
@
text
@d5 3
@
