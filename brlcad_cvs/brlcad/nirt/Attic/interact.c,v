head	11.14;
access;
symbols
	ansi-20040405-merged:11.11.2.1
	postmerge-20040405-ansi:11.12
	premerge-20040404-ansi:11.11
	postmerge-autoconf:11.11
	autoconf-freeze:11.11
	premerge-autoconf:11.11
	postmerge-20040315-windows:11.11
	premerge-20040315-windows:11.11
	windows-20040315-freeze:11.11
	autoconf-20031203:11.11
	autoconf-20031202:11.11
	autoconf-branch:11.11.0.10
	phong-branch:11.11.0.8
	photonmap-branch:11.11.0.6
	rel-6-1-DP:11.11
	windows-branch:11.11.0.4
	rel-6-0-2:11.9
	ansi-branch:11.11.0.2
	rel-6-0-1-branch:11.9.0.2
	hartley-6-0-post:11.10
	hartley-6-0-pre:11.9
	rel-6-0-1:11.9
	rel-6-0:11.9
	rel-5-4:11.6.2.1
	offsite-5-3-pre:11.8
	rel-5-3:11.6.2.1
	rel-5-2:11.6
	rel-5-1-branch:11.6.0.2
	rel-5-1:11.6
	rel-5-0:11.5
	rel-5-0-beta:11.5
	rel-4-5:11.4
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.14
date	2004.05.21.17.47.08;	author morrison;	state dead;
branches;
next	11.13;

11.13
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.12;

11.12
date	2004.04.05.07.39.41;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2002.08.20.17.08.30;	author jra;	state Exp;
branches
	11.11.2.1;
next	11.10;

11.10
date	2002.08.15.20.55.44;	author hartley;	state Exp;
branches;
next	11.9;

11.9
date	2001.08.09.19.58.22;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	2001.01.05.19.11.08;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	2000.08.24.23.10.00;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	2000.01.31.16.22.28;	author jra;	state Exp;
branches
	11.6.2.1;
next	11.5;

11.5
date	98.09.14.15.59.21;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	97.12.11.19.09.49;	author pjt;	state Exp;
branches;
next	11.3;

11.3
date	97.12.08.18.56.06;	author pjt;	state Exp;
branches;
next	11.2;

11.2
date	97.06.18.13.35.19;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.22.16;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.08.24.14.06.22;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.04.05.10.47.52;	author pjt;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.53.30;	author mike;	state Rel4_0;
branches;
next	1.6;

1.6
date	91.08.30.21.42.57;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	91.07.24.11.19.30;	author pjt;	state Exp;
branches;
next	1.4;

1.4
date	91.07.06.05.08.48;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	91.02.15.16.02.29;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	91.02.14.09.18.23;	author pjt;	state Exp;
branches;
next	1.1;

1.1
date	91.02.11.09.55.55;	author pjt;	state Exp;
branches;
next	;

11.6.2.1
date	2001.01.05.19.10.43;	author jra;	state Exp;
branches;
next	;

11.11.2.1
date	2002.09.19.18.02.10;	author morrison;	state Exp;
branches;
next	;


desc
@@


11.14
log
@moved to src/nirt/
@
text
@/*      INTERACT.C      */
#ifndef lint
static const char RCSid[] = "$Header: /n/xoff/cvs/brlcad/nirt/interact.c,v 11.13 2004/05/10 15:30:49 erikg Exp $";
#endif

/*	INCLUDES	*/ 
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdlib.h>

#include <stdio.h>
#include <ctype.h>
#if USE_STRING_H
# include <string.h>
#else
# include <strings.h>
#endif

#include "machine.h"
#include "vmath.h"
#include "./nirt.h"
#include "./usrfmt.h"

extern int		nirt_debug;
extern com_table	ComTab[];
extern int		silent_flag;

extern void		bu_log(char *, ...);

static int sgetc (char *string)
{
    static char	*prev_string = 0;
    static char	*sp;
    static int	reported_EOS = 0;

    if (nirt_debug & DEBUG_INTERACT)
	bu_log("sgetc(%s) '%s' '%s'... ", string, prev_string, sp);

    if ((string == 0) || (string != prev_string))
    {
	sp = prev_string = string;
	reported_EOS = 0;
	if (nirt_debug & DEBUG_INTERACT)
	    bu_log("initializing\n");
	if (string == 0)
	    return (EOF);
    }
    if (*sp == '\0')
	if (reported_EOS)
	{
	    if (nirt_debug & DEBUG_INTERACT)
		bu_log("returning EOF\n");
	    return (EOF);
	}
	else
	{
	    reported_EOS = 1;
	    if (nirt_debug & DEBUG_INTERACT)
		bu_log("returning EOS\n");
	    return ('\0');
	}
    else
	if (nirt_debug & DEBUG_INTERACT)
	    bu_log("returning '%c' (o%o)\n", *sp, *sp);
	return ((int) *sp++);
}

/*	               I N T E R A C T ( )
 *
 *	Handle user interaction.  Interact() prompts on stdin
 *	for a key word, looks the key word up in the command table
 *	and, if it finds the key word, the command is executed.
 *
 */
void interact(int input_source, void *sPtr)
{
    int		Ch;		/* individual characters of the input line */
    int		Prev_ch=0;	/* previous character */
    char    	line_buffer[256];	/* line of text the user types   */
    int		i;		/* position on the line_buffer[]           */
    com_table	*ctp;		/* command table pointer		   */
    int		key_len;	/* the length of the key word             */
    int		in_cmt;		/* are we now within a comment? */
    int		more_on_line = 0;/* are we withing a multi-command line? */

#define	next_char(s)	(input_source == READING_FILE)		?	\
			    fgetc((FILE *) s)			:       \
			(input_source == READING_STRING)	?	\
			    sgetc((char *) s)			:	\
			(bu_log("next_char(%d) error.  Shouldn't happen\n", \
			    input_source), EOF)

    if (nirt_debug & DEBUG_INTERACT)
	bu_log("interact(%s, %x)...\n",
	    (input_source == READING_FILE) ? "READING_FILE" :
	    (input_source == READING_STRING) ? "READING_STRING" : "???",
	    sPtr);

    /*
     *	Prime the pump when reading from a string
     */
    if (input_source == READING_STRING)
	sgetc((char *)0);

    for (;;)
    {
	in_cmt = 0;
	key_len = 0;
	if ((input_source == READING_FILE) && (sPtr == stdin)
	 && (silent_flag != SILENT_YES) && (! more_on_line))
	    (void) fputs(NIRT_PROMPT, stdout);     

	more_on_line = 0;
	while (((Ch = next_char(sPtr)) == ' ') || (Ch == '\t'))
	    if (nirt_debug & DEBUG_INTERACT)
		bu_log("Skipping '%c'\n", Ch);
	if (Ch == '\n')
	    continue;
	for (i = 0; (Ch != '\n') && (i < 255); ++i)
	{
	    if (Ch == CMT_CHAR)
	    {
		if( Prev_ch == '\\' )
		    i--;
		else
		{
		    in_cmt = 1;
		    while (((Ch = next_char(sPtr)) != EOF) && (Ch != '\n'))
			;
		}
	    }
	    if (Ch == SEP_CHAR)
	    {
		more_on_line = 1;
		break;
	    }
	    else if (Ch == '\n')
		break;
	    if ((input_source == READING_STRING) && (Ch == '\0'))
		break;
	    if (Ch == EOF)
	    {
		if ((input_source == READING_FILE) && (sPtr == stdin))
		{
		    bu_log( "Unexpected EOF in input!!\n");
		    exit(1);
		}
		else
		    return;
	    }
	    if (key_len == 0 && (Ch == ' ' || Ch == '\t'))
		key_len = i;      /* length of key word */
	    line_buffer[i] = Ch;
	    Prev_ch = Ch;
	    if (nirt_debug & DEBUG_INTERACT)
		bu_log("line_buffer[%d] = '%c' (o%o)\n", i, Ch, Ch);
	    Ch = next_char(sPtr);
	}
	if (key_len == 0)      /* length of key word */ 
	{
	    if (in_cmt)
		continue;
	    key_len = i;
	}
	line_buffer[i] = '\0';

	if (nirt_debug & DEBUG_INTERACT)
	    bu_log("Line buffer contains '%s'\n", line_buffer);

	if ((ctp = get_comtab_ent(line_buffer, key_len)) == CT_NULL)
	{
	    line_buffer[key_len] = '\0';
	    fprintf(stderr, 
		"Invalid command name '%s'.  Enter '?' for help\n",
		line_buffer);
	}
	else
	    (*(ctp -> com_func)) (&line_buffer[key_len], ctp);
    }
}

com_table *get_comtab_ent (char *pattern, int pat_len)
{
    com_table	*ctp;
    int		len;

    for (ctp = ComTab; ctp -> com_name; ++ctp)
    {
	len = max(pat_len, (int)strlen(ctp -> com_name));
	if ((strncmp (pattern, ctp -> com_name, len)) == 0)
	    break;
    }
    return ((ctp -> com_name) ? ctp : CT_NULL);
}
@


11.13
log
@change conf.h to a wrapped config.h
@
text
@d3 1
a3 1
static const char RCSid[] = "$Header: /cvs/brlcad/nirt/interact.c,v 11.12 2004/04/05 07:39:41 morrison Exp $";
@


11.12
log
@merge of ansi-6-0-branch into HEAD
@
text
@d3 1
a3 1
static const char RCSid[] = "$Header$";
d7 5
a11 1
#include "conf.h"
@


11.11
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d3 1
a3 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/interact.c,v 11.9 2001/08/09 19:58:22 jra Exp $";
d28 1
a28 5
extern void		bu_log();

static int sgetc (string)

char	*string;
d30 1
d75 1
a75 5
void interact(input_source, sPtr)

int	input_source;
void	*sPtr;

d182 1
a182 5
com_table *get_comtab_ent (pattern, pat_len)

char	*pattern;
int	pat_len;

@


11.11.2.1
log
@Initial ANSIfication
@
text
@d3 1
a3 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/interact.c,v 11.11 2002/08/20 17:08:30 jra Exp $";
d28 5
a32 1
extern void		bu_log(char *, ...);
a33 1
static int sgetc (char *string)
d78 5
a82 1
void interact(int input_source, void *sPtr)
d189 5
a193 1
com_table *get_comtab_ent (char *pattern, int pat_len)
@


11.10
log
@Converted from K&R to ANSI C - RFH
@
text
@d28 5
a32 1
extern void		bu_log(char *, ...);
a33 1
static int sgetc (char *string)
d78 5
a82 1
void interact(int input_source, void *sPtr)
d189 5
a193 1
com_table *get_comtab_ent (char *pattern, int pat_len)
@


11.9
log
@lint
@
text
@d3 1
a3 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/interact.c,v 11.8 2001/01/05 19:11:08 jra Exp $";
d28 1
a28 5
extern void		bu_log();

static int sgetc (string)

char	*string;
d30 1
d75 1
a75 5
void interact(input_source, sPtr)

int	input_source;
void	*sPtr;

d182 1
a182 5
com_table *get_comtab_ent (pattern, pat_len)

char	*pattern;
int	pat_len;

@


11.8
log
@if_hit() now prints ALL overlaps for a given partition
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/interact.c,v 11.6 2000/01/31 16:22:28 jra Exp $";
d9 2
d28 2
d149 1
d157 1
@


11.7
log
@
lint
@
text
@d3 1
a3 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/nirt/interact.c,v 11.6 2000/01/31 16:22:28 jra Exp $";
d146 2
d149 1
@


11.6
log
@Eliminated some unused variables
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/interact.c,v 11.5 1998/09/14 15:59:21 bparker Exp $";
@


11.6.2.1
log
@if_hit() now prints ALL overlaps for a given partition
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/interact.c,v 11.6 2000/01/31 16:22:28 jra Exp $";
a145 2
		{
		    bu_log( "Unexpected EOF in input!!\n");
a146 1
		}
@


11.5
log
@*- fix typos
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /c/CVS/brlcad/nirt/interact.c,v 11.4 1997/12/11 19:09:49 pjt Exp $";
a85 1
    int		n;		/* how many chars to compare */
@


11.4
log
@Fixed bugs in sgetc(), so now interact() successfully reads from more than
one script string.
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/interact.c,v 11.3 1997/12/08 18:56:06 pjt Exp pjt $";
d107 1
a107 1
	sgetc(0);
@


11.3
log
@1. Implemented the -e option
2. Implemented the ; command separator
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/interact.c,v 11.2 1997/06/18 13:35:19 jra Exp $";
d38 2
a39 3
    if (string == 0)
	return (EOF);
    if (string != prev_string)
d41 6
d49 3
d53 1
d57 2
d90 6
a95 4
#define	next_char(s)	(input_source == READING_FILE) ? fgetc(s) :       \
			(input_source == READING_STRING) ? sgetc(s) :     \
			(bu_log("next_char() error.  Shouldn't happen\n"), \
			EOF)
d103 6
a141 2
	    {
		made_it();
a142 1
	    }
@


11.2
log
@Added capability to include '#' as '\#'
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/interact.c,v 11.1 1995/01/04 10:22:16 mike Rel4_4 jra $";
d22 1
d26 30
d63 1
a63 1
void interact(fPtr)
d65 2
a66 1
FILE	*fPtr;
d69 36
a104 10
	int		Ch;	/* individual characters of the input line */
	int		Prev_ch=0; /* previous character */
	char    	line_buffer[256]; /* line of text the user types   */
	int 		i;      /* position on the line_buffer[]           */
	com_table       *ctp;   /* command table pointer		   */
	int		key_len; /* the length of the key word             */
	int		n;	 /* how many chars to compare */
	int		in_cmt;	/* are we now within a comment? */

	for (EVER)
d106 5
a110 8
		in_cmt = 0;
		key_len = 0;
		if ((fPtr == stdin) && (silent_flag != SILENT_YES))
		    (void) fputs(NIRT_PROMPT, stdout);     
		while (((Ch = fgetc(fPtr)) == ' ') OR (Ch == '\t'));
		if (Ch == '\n')
			continue;
		for (i = 0; (Ch != '\n') AND (i < 255); ++i)
d112 3
a114 23
			if (Ch == CMT_CHAR)
			{
			    if( Prev_ch == '\\' )
				i--;
			    else
			    {
				    in_cmt = 1;
				    while (((Ch = fgetc(fPtr)) != EOF) && (Ch != '\n'))
					;
			    }
			}
			if (Ch == '\n')
			    break;
			if (Ch == EOF)
			    if (fPtr == stdin)
				exit(1);
			    else
				return;
		        if (key_len == 0 AND (Ch == ' ' OR Ch == '\t'))
				key_len = i;      /* length of key word */
			line_buffer[i] = Ch;
			Prev_ch = Ch;
			Ch = fgetc(fPtr);
d116 36
a151 7
		if (key_len == 0)      /* length of key word */ 
		{
		    if (in_cmt)
			continue;
		    key_len = i;
		}
		line_buffer[i] = '\0';
d153 10
a162 10
		if ((ctp = get_comtab_ent(line_buffer, key_len)) == CT_NULL)
		{
		    line_buffer[key_len] = '\0';
		    fprintf(stderr, 
			"Invalid command name '%s'.  Enter '?' for help\n",
			line_buffer);
		}
		else
		    (*(ctp -> com_func)) (&line_buffer[key_len], ctp);
        }
@


11.1
log
@Release_4.4
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/interact.c,v 10.3 94/08/24 14:06:22 gdurf Exp $";
d38 1
d59 8
a66 3
			    in_cmt = 1;
			    while (((Ch = fgetc(fPtr)) != EOF) && (Ch != '\n'))
				;
d78 1
@


10.3
log
@Factored ifdefs
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/interact.c,v 10.2 1994/04/05 10:47:52 pjt Exp gdurf $";
@


10.2
log
@implemented -v command-line option and enhanced silent_flag
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/interact.c,v 10.1 91/10/12 06:53:30 mike Rel4_0 Locker: pjt $";
d7 3
d11 3
a13 1
#if BSD
a14 2
#else
# include <string.h>
d16 3
a18 1
#include <stdio.h>
@


10.1
log
@Release_4.0
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/interact.c,v 1.6 91/08/30 21:42:57 mike Exp $";
d44 1
a44 1
		if ((fPtr == stdin) && (! silent_flag))
@


1.6
log
@ANSI C
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/interact.c,v 1.5 91/07/24 11:19:30 pjt Exp $";
@


1.5
log
@Implemented short (non-verbose) mode
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/interact.c,v 1.4 91/07/06 05:08:48 mike Exp $";
d100 1
a100 1
	len = max(pat_len, strlen(ctp -> com_name));
@


1.4
log
@On older BSD systems, must use <strings.h>, not <string.h>
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/interact.c,v 1.3 91/02/15 16:02:29 mike Exp $";
d18 1
d44 1
a44 1
		if (fPtr == stdin)
@


1.3
log
@Converted to Cake
@
text
@d3 1
a3 1
static char RCSid[] = "$Header: /m/cad/nirt/RCS/interact.c,v 1.2 91/02/14 09:18:23 pjt Exp $";
d8 5
a12 1
#include <string.h>
@


1.2
log
@Attempt to add $Header$ to file.
@
text
@d3 1
a3 1
static char RCSid[] = "$Header$";
d10 2
a11 2
#include "nirt.h"
#include "usrfmt.h"
@


1.1
log
@Initial revision
@
text
@d2 3
@
