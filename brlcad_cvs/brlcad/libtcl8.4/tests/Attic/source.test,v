head	1.4;
access;
symbols
	ansi-20040405-merged:1.3.4.1
	postmerge-20040405-ansi:1.3
	premerge-20040404-ansi:1.3
	postmerge-autoconf:1.3
	autoconf-freeze:1.1.6.4
	premerge-autoconf:1.3
	postmerge-20040315-windows:1.3
	premerge-20040315-windows:1.3
	windows-20040315-freeze:1.3.2.1
	autoconf-20031203:1.1.6.1
	autoconf-20031202:1.1
	autoconf-branch:1.1.0.6
	phong-branch:1.1.0.4
	photonmap-branch:1.1.0.2
	windows-branch:1.3.0.2
	ansi-branch:1.3.0.4;
locks; strict;
comment	@# @;


1.4
date	2004.05.21.18.04.55;	author morrison;	state dead;
branches;
next	1.3;

1.3
date	2004.03.04.19.47.20;	author morrison;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2003.11.07.14.54.45;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.13.19.18.37;	author jra;	state Exp;
branches
	1.1.6.1;
next	;

1.1.6.1
date	2003.12.03.16.24.50;	author erikg;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2004.02.12.18.56.44;	author erikg;	state Exp;
branches;
next	1.1.6.3;

1.1.6.3
date	2004.03.15.12.10.36;	author erikg;	state Exp;
branches;
next	1.1.6.4;

1.1.6.4
date	2004.03.15.14.01.30;	author erikg;	state Exp;
branches;
next	;

1.3.2.1
date	2004.03.12.09.59.22;	author morrison;	state Exp;
branches;
next	;

1.3.4.1
date	2004.03.17.21.20.05;	author morrison;	state Exp;
branches;
next	;


desc
@@


1.4
log
@moved from top-level to src/other/.
@
text
@# Commands covered:  source
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 1991-1993 The Regents of the University of California.
# Copyright (c) 1994-1996 Sun Microsystems, Inc.
# Copyright (c) 1998-2000 by Scriptics Corporation.
# Contributions from Don Porter, NIST, 2003.  (not subject to US copyright)
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: source.test,v 1.3 2004/03/04 19:47:20 morrison Exp $

if {[catch {package require tcltest 2.1}]} {
    puts stderr "Skipping tests in [info script]. tcltest 2.1 required."
    return
}

namespace eval ::tcl::test::source {
    namespace import ::tcltest::test
    namespace import ::tcltest::testConstraint
    namespace import ::tcltest::cleanupTests
    namespace import ::tcltest::makeFile
    namespace import ::tcltest::removeFile
    namespace import ::tcltest::customMatch

test source-1.1 {source command} -setup {
    set x "old x value"
    set y "old y value"
    set z "old z value"
    set sourcefile [makeFile {
	set x 22
	set y 33
	set z 44
    } source.file]
} -body {
    source $sourcefile
    list $x $y $z
} -cleanup {
    removeFile source.file
} -result {22 33 44}

test source-1.2 {source command} -setup {
    set sourcefile [makeFile {list result} source.file]
} -body {
    source $sourcefile
} -cleanup {
    removeFile source.file
} -result result

test source-1.3 {source command} -setup {
    set sourcefile [makeFile {} source.file]
    set fd [open $sourcefile w]
    fconfigure $fd -translation lf
    puts $fd "list a b c \\"
    puts $fd "d e f"
    close $fd
} -body {
    source $sourcefile
} -cleanup {
    removeFile source.file
} -result {a b c d e f}

proc ListGlobMatch {expected actual} {
    if {[llength $expected] != [llength $actual]} {
        return 0
    }
    foreach e $expected a $actual {
        if {![string match $e $a]} {
            return 0
        }
    }
    return 1
}
customMatch listGlob [namespace which ListGlobMatch]

test source-2.3 {source error conditions} -setup {
    set sourcefile [makeFile {
	set x 146
	error "error in sourced file"
	set y $x
    } source.file]
} -body {
    list [catch {source $sourcefile} msg] $msg $::errorInfo
} -cleanup {
    removeFile source.file
} -match listGlob -result [list 1 {error in sourced file} \
	{error in sourced file
    while executing
"error "error in sourced file""
    (file "*source.file" line 3)
    invoked from within
"source $sourcefile"}]

test source-2.4 {source error conditions} -setup {
    set sourcefile [makeFile {break} source.file]
} -body {
    source $sourcefile
} -cleanup {
    removeFile source.file
} -returnCodes break

test source-2.5 {source error conditions} -setup {
    set sourcefile [makeFile {continue} source.file]
} -body {
    source $sourcefile
} -cleanup {
    removeFile source.file
} -returnCodes continue

test source-2.6 {source error conditions} -setup {
    set sourcefile [makeFile {} _non_existent_]
    removeFile _non_existent_
} -body {
    list [catch {source $sourcefile} msg] $msg $::errorCode
} -match listGlob -result [list 1 \
	{couldn't read file "*_non_existent_": no such file or directory} \
	{POSIX ENOENT {no such file or directory}}]


test source-3.1 {return in middle of source file} -setup {
    set sourcefile [makeFile {
	set x new-x
	return allDone
	set y new-y
    } source.file]
} -body {
    set x old-x
    set y old-y
    set z [source $sourcefile]
    list $x $y $z
} -cleanup {
    removeFile source.file
} -result {new-x old-y allDone}

test source-3.2 {return with special code etc.} -setup {
    set sourcefile [makeFile {
	set x new-x
	return -code break "Silly result"
	set y new-y
    } source.file]
} -body {
   source $sourcefile
} -cleanup {
    removeFile source.file
} -returnCodes break -result {Silly result}

test source-3.3 {return with special code etc.} -setup {
    set sourcefile [makeFile {
	set x new-x
	return -code error "Simulated error"
	set y new-y
    } source.file]
} -body {
    list [catch {source $sourcefile} msg] $msg $::errorInfo $::errorCode
} -cleanup {
    removeFile source.file
} -result {1 {Simulated error} {Simulated error
    while executing
"source $sourcefile"} NONE}

test source-3.4 {return with special code etc.} -setup {
    set sourcefile [makeFile {
	set x new-x
	return -code error -errorinfo "Simulated errorInfo stuff"
	set y new-y
    } source.file]
} -body {
    list [catch {source $sourcefile} msg] $msg $::errorInfo $::errorCode
} -cleanup {
    removeFile source.file
} -result {1 {} {Simulated errorInfo stuff
    invoked from within
"source $sourcefile"} NONE}

test source-3.5 {return with special code etc.} -setup {
    set sourcefile [makeFile {
	set x new-x
	return -code error -errorinfo "Simulated errorInfo stuff" \
		-errorcode {a b c}
	set y new-y
    } source.file]
} -body {
    list [catch {source $sourcefile} msg] $msg $::errorInfo $::errorCode
} -cleanup {
    removeFile source.file
} -result {1 {} {Simulated errorInfo stuff
    invoked from within
"source $sourcefile"} {a b c}}


# Test for the Macintosh specfic features of the source command
test source-4.1 {source error conditions} -constraints macOnly -body {
    source -rsrc _no_exist_
} -result {The resource "_no_exist_" could not be loaded from application.} \
  -returnCodes error 

test source-4.2 {source error conditions} -constraints macOnly -body {
    source -rsrcid bad_id
} -returnCodes error -result {expected integer but got "bad_id"}

test source-4.3 {source error conditions} -constraints macOnly -body {
    source -rsrc rsrcName fileName extra
} -returnCodes error -result {wrong # args: should be "source fileName" or "source -rsrc name ?fileName?" or "source -rsrcid id ?fileName?" or "source -encoding name fileName"}

test source-4.4 {source error conditions} -constraints macOnly -body {
    source non_switch rsrcName
} -returnCodes error -result {bad argument: should be "source fileName" or "source -rsrc name ?fileName?" or "source -rsrcid id ?fileName?" or "source -encoding name fileName"}

test source-4.5 {source error conditions} -constraints macOnly -body {
    source -bad_switch argument
} -returnCodes error -result {bad argument: should be "source fileName" or "source -rsrc name ?fileName?" or "source -rsrcid id ?fileName?" or "source -encoding name fileName"}

 
testConstraint testWriteTextResource \
	[llength [info commands testWriteTextResource]]

test source-5.1 {source resource files} -constraints macOnly -setup {
    set sourcefile [makeFile {} bad_file]
    removeFile bad_file
} -body {
    source -rsrc rsrcName $sourcefile
} -returnCodes error -match glob -result {Error finding the file: "*bad_file".}

test source-5.2 {source resource files} -constraints macOnly -setup {
    set sourcefile [makeFile {return} source.file]
} -body {
    source -rsrc rsrcName $sourcefile
} -cleanup {
    removeFile source.file
} -returnCodes error -match glob \
  -result {Error reading the file: "*source.file".}

test source-5.3 {source resource files} -constraints {
    macOnly testWriteTextResource
} -setup {
    set msg2 unset
    set rsrcFile [makeFile {} rsrc.file]
    removeFile rsrc.file
    testWriteTextResource -rsrc rsrcName -file $rsrc.file {set msg2 ok; return}
} -body {
    set result [catch {source -rsrc rsrcName rsrc.file} msg]
    list $msg2 $result $msg
} -cleanup {
    removeFile rsrc.file
} -result [list ok 0 {}]

test source-5.4 {source resource files} -constraints {
    macOnly testWriteTextResource
} -setup {
    set msg2 unset
    set rsrsFile [makeFile {} rsrc.file]
    removeFile rsrc.file
    testWriteTextResource -rsrc fileRsrcName \
	    -file $rsrcFile {set msg2 ok; return}
} -body {
    source -rsrc fileRsrcName $rsrcFile
    set result [catch {source -rsrc fileRsrcName} msg]    
    list $msg2 $result $msg
} -cleanup {
    removeFile rsrc.file
} -result [list ok 1 {The resource "fileRsrcName" could not be loaded from application.}]

test source-5.5 {source resource files} -constraints {
    macOnly testWriteTextResource
} -setup {
    set msg2 unset
    set rsrcFile [makeFile {} rsrc.file]
    removeFile rsrc.file
    testWriteTextResource -rsrcid 200 \
	    -file $rsrcFile {set msg2 hello; set msg3 bye}
} -body {
    set result [catch {source -rsrcid 200 $rsrcFile} msg]
    list $msg2 $result $msg
} -cleanup {
    removeFile rsrc.file
} -result [list hello 0 bye]

test source-5.6 {source resource files} -constraints {
    macOnly testWriteTextResource
} -setup {
    set msg2 unset
    set rsrcFile [makeFile {} rsrc.file]
    removeFile rsrc.file
    testWriteTextResource -rsrcid 200 \
	    -file $rsrcFile {set msg2 hello; error bad; set msg3 bye}
} -body {
    set result [catch {source -rsrcid 200 rsrc.file} msg]
    list $msg2 $result $msg
} -cleanup {
    removeFile rsrc.file
} -result [list hello 1 bad]


test source-6.1 {source is binary ok} -setup {
    # Note [makeFile] writes in the system encoding.
    # [source] defaults to reading in the system encoding.
    set sourcefile [makeFile [list set x "a b\0c"] source.file]
} -body {
    set x {}
    source $sourcefile
    string length $x
} -cleanup {
    removeFile source.file
} -result 5

test source-6.2 {source skips everything after Ctrl-Z: Bug 2040} -setup {
    set sourcefile [makeFile "set x ab\32c" source.file]
} -body {
    set x {}
    source $sourcefile
    string length $x
} -cleanup {
    removeFile source.file
} -result 2

cleanupTests
}
namespace delete ::tcl::test::source
return
@


1.3
log
@Updated to tcl 8.4.6
@
text
@d15 1
a15 1
# RCS: @@(#) $Id: source.test,v 1.8.2.2 2004/02/25 23:38:17 dgp Exp $
@


1.3.4.1
log
@sync branch with HEAD
@
text
@d15 1
a15 1
# RCS: @@(#) $Id$
@


1.3.2.1
log
@merge from HEAD
@
text
@d15 1
a15 1
# RCS: @@(#) $Id$
@


1.2
log
@updated tcl to 8.4.4
@
text
@d10 1
d15 1
a15 1
# RCS: @@(#) $Id: source.test,v 1.8 2002/07/05 10:38:43 dkf Exp $
d17 3
a19 3
if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
d22 9
a30 2
set sourcefile [makeFile "" source.file]
test source-1.1 {source command} {
d34 1
a34 1
    makeFile {
d38 2
a39 1
    } source.file
d42 11
a52 7
} {22 33 44}
test source-1.2 {source command} {
    makeFile {list result} source.file
    source $sourcefile
} result
test source-1.3 {source command} {
    set y {\ }
d54 2
d58 1
a58 2
    puts -nonewline $fd "list a b c "
    puts $fd [string index $y 0]
d61 5
d67 12
a78 2
    source $sourcefile
} {a b c d e f}
d80 2
a81 2
test source-2.3 {source error conditions} {
    makeFile {
d85 7
a91 3
    } source.file
    list [catch {source $sourcefile} msg] $msg $errorInfo
} [list 1 {error in sourced file} "error in sourced file
d93 2
a94 2
\"error \"error in sourced file\"\"
    (file \"$sourcefile\" line 3)
d96 26
a121 12
\"source \$sourcefile\""]
test source-2.4 {source error conditions} {
    makeFile {break} source.file
    catch {source $sourcefile}
} 3
test source-2.5 {source error conditions} {
    makeFile {continue} source.file
    catch {source $sourcefile}
} 4
test source-2.6 {source error conditions} {
    normalizeMsg [list [catch {source _non_existent_} msg] $msg $errorCode]
} {1 {couldn't read file "_non_existent_": no such file or directory} {posix enoent {no such file or directory}}}
d123 3
a125 2
test source-3.1 {return in middle of source file} {
    makeFile {
d129 2
a130 1
    } source.file
d135 6
a140 3
} {new-x old-y allDone}
test source-3.2 {return with special code etc.} {
    makeFile {
d144 9
a152 5
    } source.file
    list [catch {source $sourcefile} msg] $msg
} {3 {Silly result}}
test source-3.3 {return with special code etc.} {
    makeFile {
d156 6
a161 3
    } source.file
    list [catch {source $sourcefile} msg] $msg $errorInfo $errorCode
} {1 {Simulated error} {Simulated error
d164 3
a166 2
test source-3.4 {return with special code etc.} {
    makeFile {
d170 6
a175 3
    } source.file
    list [catch {source $sourcefile} msg] $msg $errorInfo $errorCode
} {1 {} {Simulated errorInfo stuff
d178 3
a180 2
test source-3.5 {return with special code etc.} {
    makeFile {
d185 6
a190 3
    } source.file
    list [catch {source $sourcefile} msg] $msg $errorInfo $errorCode
} {1 {} {Simulated errorInfo stuff
d194 1
d196 49
a244 24
test source-4.1 {source error conditions} {macOnly} {
    list [catch {source -rsrc _no_exist_} msg] $msg
} [list 1 "The resource \"_no_exist_\" could not be loaded from application."]
test source-4.2 {source error conditions} {macOnly} {
    list [catch {source -rsrcid bad_id} msg] $msg
} [list 1 "expected integer but got \"bad_id\""]
test source-4.3 {source error conditions} {macOnly} {
    list [catch {source -rsrc rsrcName fileName extra} msg] $msg
} {1 {wrong # args: should be "source fileName" or "source -rsrc name ?fileName?" or "source -rsrcid id ?fileName?"}}
test source-4.4 {source error conditions} {macOnly} {
    list [catch {source non_switch rsrcName} msg] $msg
} {1 {bad argument: should be "source fileName" or "source -rsrc name ?fileName?" or "source -rsrcid id ?fileName?"}}
test source-4.5 {source error conditions} {macOnly} {
    list [catch {source -bad_switch argument} msg] $msg
} {1 {bad argument: should be "source fileName" or "source -rsrc name ?fileName?" or "source -rsrcid id ?fileName?"}}
test source-5.1 {source resource files} {macOnly} {
    list [catch {source -rsrc rsrcName bad_file} msg] $msg
} [list 1 "Error finding the file: \"bad_file\"."]
test source-5.2 {source resource files} {macOnly} {
    makeFile {return} source.file
    list [catch {source -rsrc rsrcName $sourcefile} msg] $msg
} [list 1 "Error reading the file: \"$sourcefile\"."]
test source-5.3 {source resource files} {macOnly} {
    testWriteTextResource -rsrc rsrcName -file rsrc.file {set msg2 ok; return}
d246 2
d249 13
d263 9
a271 6
} [list ok 0 {}]
test source-5.4 {source resource files} {macOnly} {
    catch {unset msg2}
    testWriteTextResource -rsrc fileRsrcName -file rsrc.file {set msg2 ok; return}
    source -rsrc fileRsrcName rsrc.file
    set result [catch {source -rsrc fileRsrcName} msg]    
d273 4
d278 13
a290 3
} [list ok 1 {The resource "fileRsrcName" could not be loaded from application.}]
test source-5.5 {source resource files} {macOnly} {
    testWriteTextResource -rsrcid 200 -file rsrc.file {set msg2 hello; set msg3 bye}
a291 1
    removeFile rsrc.file
d293 1
a293 4
} [list hello 0 bye]
test source-5.6 {source resource files} {macOnly} {
    testWriteTextResource -rsrcid 200 -file rsrc.file {set msg2 hello; error bad; set msg3 bye}
    set result [catch {source -rsrcid 200 rsrc.file} msg]
d295 2
a296 2
    list $msg2 $result $msg
} [list hello 1 bad]
d298 5
a302 1
test source-6.1 {source is binary ok} {
a303 1
    makeFile [list set x "a b\0c"] source.file
d306 7
a312 2
} 5
test source-6.2 {source skips everything after Ctrl-Z: Bug 2040} {
a313 1
    makeFile [list set x "ab\32c"] source.file
d316 3
a318 1
} 2
d320 3
a322 3
# cleanup
catch {::tcltest::removeFile source.file}
::tcltest::cleanupTests
@


1.1
log
@*** empty log message ***
@
text
@@


1.1.6.1
log
@updates from HEAD, part 1
@
text
@d14 1
a14 1
# RCS: @@(#) $Id: source.test,v 1.2 2003/11/07 14:54:45 morrison Exp $
@


1.1.6.2
log
@merge from HEAD
@
text
@@


1.1.6.3
log
@merge from head
@
text
@a9 1
# Contributions from Don Porter, NIST, 2003.  (not subject to US copyright)
d14 1
a14 1
# RCS: @@(#) $Id: source.test,v 1.3 2004/03/04 19:47:20 morrison Exp $
d16 3
a18 3
if {[catch {package require tcltest 2.1}]} {
    puts stderr "Skipping tests in [info script]. tcltest 2.1 required."
    return
d21 2
a22 9
namespace eval ::tcl::test::source {
    namespace import ::tcltest::test
    namespace import ::tcltest::testConstraint
    namespace import ::tcltest::cleanupTests
    namespace import ::tcltest::makeFile
    namespace import ::tcltest::removeFile
    namespace import ::tcltest::customMatch

test source-1.1 {source command} -setup {
d26 1
a26 1
    set sourcefile [makeFile {
d30 1
a30 2
    } source.file]
} -body {
d33 7
a39 11
} -cleanup {
    removeFile source.file
} -result {22 33 44}

test source-1.2 {source command} -setup {
    set sourcefile [makeFile {list result} source.file]
} -body {
    source $sourcefile
} -cleanup {
    removeFile source.file
} -result result
a40 2
test source-1.3 {source command} -setup {
    set sourcefile [makeFile {} source.file]
d43 2
a44 1
    puts $fd "list a b c \\"
d47 1
a47 1
} -body {
d49 1
a49 16
} -cleanup {
    removeFile source.file
} -result {a b c d e f}

proc ListGlobMatch {expected actual} {
    if {[llength $expected] != [llength $actual]} {
        return 0
    }
    foreach e $expected a $actual {
        if {![string match $e $a]} {
            return 0
        }
    }
    return 1
}
customMatch listGlob [namespace which ListGlobMatch]
d51 2
a52 2
test source-2.3 {source error conditions} -setup {
    set sourcefile [makeFile {
d56 3
a58 7
    } source.file]
} -body {
    list [catch {source $sourcefile} msg] $msg $::errorInfo
} -cleanup {
    removeFile source.file
} -match listGlob -result [list 1 {error in sourced file} \
	{error in sourced file
d60 2
a61 2
"error "error in sourced file""
    (file "*source.file" line 3)
d63 12
a74 26
"source $sourcefile"}]

test source-2.4 {source error conditions} -setup {
    set sourcefile [makeFile {break} source.file]
} -body {
    source $sourcefile
} -cleanup {
    removeFile source.file
} -returnCodes break

test source-2.5 {source error conditions} -setup {
    set sourcefile [makeFile {continue} source.file]
} -body {
    source $sourcefile
} -cleanup {
    removeFile source.file
} -returnCodes continue

test source-2.6 {source error conditions} -setup {
    set sourcefile [makeFile {} _non_existent_]
    removeFile _non_existent_
} -body {
    list [catch {source $sourcefile} msg] $msg $::errorCode
} -match listGlob -result [list 1 \
	{couldn't read file "*_non_existent_": no such file or directory} \
	{POSIX ENOENT {no such file or directory}}]
d76 2
a77 3

test source-3.1 {return in middle of source file} -setup {
    set sourcefile [makeFile {
d81 1
a81 2
    } source.file]
} -body {
d86 3
a88 6
} -cleanup {
    removeFile source.file
} -result {new-x old-y allDone}

test source-3.2 {return with special code etc.} -setup {
    set sourcefile [makeFile {
d92 5
a96 9
    } source.file]
} -body {
   source $sourcefile
} -cleanup {
    removeFile source.file
} -returnCodes break -result {Silly result}

test source-3.3 {return with special code etc.} -setup {
    set sourcefile [makeFile {
d100 3
a102 6
    } source.file]
} -body {
    list [catch {source $sourcefile} msg] $msg $::errorInfo $::errorCode
} -cleanup {
    removeFile source.file
} -result {1 {Simulated error} {Simulated error
d105 2
a106 3

test source-3.4 {return with special code etc.} -setup {
    set sourcefile [makeFile {
d110 3
a112 6
    } source.file]
} -body {
    list [catch {source $sourcefile} msg] $msg $::errorInfo $::errorCode
} -cleanup {
    removeFile source.file
} -result {1 {} {Simulated errorInfo stuff
d115 2
a116 3

test source-3.5 {return with special code etc.} -setup {
    set sourcefile [makeFile {
d121 3
a123 6
    } source.file]
} -body {
    list [catch {source $sourcefile} msg] $msg $::errorInfo $::errorCode
} -cleanup {
    removeFile source.file
} -result {1 {} {Simulated errorInfo stuff
a126 1

d128 25
a152 46
test source-4.1 {source error conditions} -constraints macOnly -body {
    source -rsrc _no_exist_
} -result {The resource "_no_exist_" could not be loaded from application.} \
  -returnCodes error 

test source-4.2 {source error conditions} -constraints macOnly -body {
    source -rsrcid bad_id
} -returnCodes error -result {expected integer but got "bad_id"}

test source-4.3 {source error conditions} -constraints macOnly -body {
    source -rsrc rsrcName fileName extra
} -returnCodes error -result {wrong # args: should be "source fileName" or "source -rsrc name ?fileName?" or "source -rsrcid id ?fileName?" or "source -encoding name fileName"}

test source-4.4 {source error conditions} -constraints macOnly -body {
    source non_switch rsrcName
} -returnCodes error -result {bad argument: should be "source fileName" or "source -rsrc name ?fileName?" or "source -rsrcid id ?fileName?" or "source -encoding name fileName"}

test source-4.5 {source error conditions} -constraints macOnly -body {
    source -bad_switch argument
} -returnCodes error -result {bad argument: should be "source fileName" or "source -rsrc name ?fileName?" or "source -rsrcid id ?fileName?" or "source -encoding name fileName"}

 
testConstraint testWriteTextResource \
	[llength [info commands testWriteTextResource]]

test source-5.1 {source resource files} -constraints macOnly -setup {
    set sourcefile [makeFile {} bad_file]
    removeFile bad_file
} -body {
    source -rsrc rsrcName $sourcefile
} -returnCodes error -match glob -result {Error finding the file: "*bad_file".}

test source-5.2 {source resource files} -constraints macOnly -setup {
    set sourcefile [makeFile {return} source.file]
} -body {
    source -rsrc rsrcName $sourcefile
} -cleanup {
    removeFile source.file
} -returnCodes error -match glob \
  -result {Error reading the file: "*source.file".}

test source-5.3 {source resource files} -constraints {
    macOnly testWriteTextResource
} -setup {
    set msg2 unset
    set rsrcFile [makeFile {} rsrc.file]
a153 3
    testWriteTextResource -rsrc rsrcName -file $rsrc.file {set msg2 ok; return}
} -body {
    set result [catch {source -rsrc rsrcName rsrc.file} msg]
d155 6
a160 9
} -cleanup {
    removeFile rsrc.file
} -result [list ok 0 {}]

test source-5.4 {source resource files} -constraints {
    macOnly testWriteTextResource
} -setup {
    set msg2 unset
    set rsrsFile [makeFile {} rsrc.file]
a161 5
    testWriteTextResource -rsrc fileRsrcName \
	    -file $rsrcFile {set msg2 ok; return}
} -body {
    source -rsrc fileRsrcName $rsrcFile
    set result [catch {source -rsrc fileRsrcName} msg]    
d163 4
a166 1
} -cleanup {
a167 12
} -result [list ok 1 {The resource "fileRsrcName" could not be loaded from application.}]

test source-5.5 {source resource files} -constraints {
    macOnly testWriteTextResource
} -setup {
    set msg2 unset
    set rsrcFile [makeFile {} rsrc.file]
    removeFile rsrc.file
    testWriteTextResource -rsrcid 200 \
	    -file $rsrcFile {set msg2 hello; set msg3 bye}
} -body {
    set result [catch {source -rsrcid 200 $rsrcFile} msg]
d169 4
a172 9
} -cleanup {
    removeFile rsrc.file
} -result [list hello 0 bye]

test source-5.6 {source resource files} -constraints {
    macOnly testWriteTextResource
} -setup {
    set msg2 unset
    set rsrcFile [makeFile {} rsrc.file]
a173 4
    testWriteTextResource -rsrcid 200 \
	    -file $rsrcFile {set msg2 hello; error bad; set msg3 bye}
} -body {
    set result [catch {source -rsrcid 200 rsrc.file} msg]
d175 1
a175 4
} -cleanup {
    removeFile rsrc.file
} -result [list hello 1 bad]

d177 1
a177 5
test source-6.1 {source is binary ok} -setup {
    # Note [makeFile] writes in the system encoding.
    # [source] defaults to reading in the system encoding.
    set sourcefile [makeFile [list set x "a b\0c"] source.file]
} -body {
d179 1
d182 2
a183 7
} -cleanup {
    removeFile source.file
} -result 5

test source-6.2 {source skips everything after Ctrl-Z: Bug 2040} -setup {
    set sourcefile [makeFile "set x ab\32c" source.file]
} -body {
d185 1
d188 1
a188 3
} -cleanup {
    removeFile source.file
} -result 2
d190 3
a192 3
cleanupTests
}
namespace delete ::tcl::test::source
@


1.1.6.4
log
@merge from head...
@
text
@d15 1
a15 1
# RCS: @@(#) $Id: source.test,v 1.1.6.3 2004/03/15 12:10:36 erikg Exp $
@


