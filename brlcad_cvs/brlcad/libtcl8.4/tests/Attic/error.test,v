head	1.4;
access;
symbols
	ansi-20040405-merged:1.3.4.1
	postmerge-20040405-ansi:1.3
	premerge-20040404-ansi:1.3
	postmerge-autoconf:1.3
	autoconf-freeze:1.1.6.4
	premerge-autoconf:1.3
	postmerge-20040315-windows:1.3
	premerge-20040315-windows:1.3
	windows-20040315-freeze:1.3.2.1
	autoconf-20031203:1.1.6.1
	autoconf-20031202:1.1
	autoconf-branch:1.1.0.6
	phong-branch:1.1.0.4
	photonmap-branch:1.1.0.2
	windows-branch:1.3.0.2
	ansi-branch:1.3.0.4;
locks; strict;
comment	@# @;


1.4
date	2004.05.21.18.04.39;	author morrison;	state dead;
branches;
next	1.3;

1.3
date	2004.03.04.19.47.14;	author morrison;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2003.11.07.14.54.43;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.13.19.18.26;	author jra;	state Exp;
branches
	1.1.6.1;
next	;

1.1.6.1
date	2003.12.03.16.24.43;	author erikg;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2004.02.12.18.56.36;	author erikg;	state Exp;
branches;
next	1.1.6.3;

1.1.6.3
date	2004.03.15.12.10.32;	author erikg;	state Exp;
branches;
next	1.1.6.4;

1.1.6.4
date	2004.03.15.14.01.24;	author erikg;	state Exp;
branches;
next	;

1.3.2.1
date	2004.03.12.09.59.12;	author morrison;	state Exp;
branches;
next	;

1.3.4.1
date	2004.03.17.21.19.55;	author morrison;	state Exp;
branches;
next	;


desc
@@


1.4
log
@moved from top-level to src/other/.
@
text
@# Commands covered:  error, catch
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 1991-1993 The Regents of the University of California.
# Copyright (c) 1994-1996 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: error.test,v 1.3 2004/03/04 19:47:14 morrison Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}

proc foo {} {
    global errorInfo
    set a [catch {format [error glorp2]} b]
    error {Human-generated}
}

proc foo2 {} {
    global errorInfo
    set a [catch {format [error glorp2]} b]
    error {Human-generated} $errorInfo
}

# Catch errors occurring in commands and errors from "error" command

test error-1.1 {simple errors from commands} {
    catch {format [string index]} b
} 1

test error-1.2 {simple errors from commands} {
    catch {format [string index]} b
    set b
} {wrong # args: should be "string index string charIndex"}

test error-1.3 {simple errors from commands} {
    catch {format [string index]} b
    set errorInfo
    # this used to return '... while executing ...', but
    # string index is fully compiled as of 8.4a3
} {wrong # args: should be "string index string charIndex"
    while executing
"string index"}

test error-1.4 {simple errors from commands} {
    catch {error glorp} b
} 1

test error-1.5 {simple errors from commands} {
    catch {error glorp} b
    set b
} glorp

test error-1.6 {simple errors from commands} {
    catch {catch a b c} b
} 1

test error-1.7 {simple errors from commands} {
    catch {catch a b c} b
    set b
} {wrong # args: should be "catch command ?varName?"}

test error-1.8 {simple errors from commands} {nonPortable} {
    # This test is non-portable: it generates a memory fault on
    # machines like DEC Alphas (infinite recursion overflows
    # stack?)

    proc p {} {
        uplevel 1 catch p error
    }
    p
} 0

# Check errors nested in procedures.  Also check the optional argument
# to "error" to generate a new error trace.

test error-2.1 {errors in nested procedures} {
    catch foo b
} 1

test error-2.2 {errors in nested procedures} {
    catch foo b
    set b
} {Human-generated}

test error-2.3 {errors in nested procedures} {
    catch foo b
    set errorInfo
} {Human-generated
    while executing
"error {Human-generated}"
    (procedure "foo" line 4)
    invoked from within
"foo"}

test error-2.4 {errors in nested procedures} {
    catch foo2 b
} 1

test error-2.5 {errors in nested procedures} {
    catch foo2 b
    set b
} {Human-generated}

test error-2.6 {errors in nested procedures} {
    catch foo2 b
    set errorInfo
} {glorp2
    while executing
"error glorp2"
    (procedure "foo2" line 3)
    invoked from within
"foo2"}

# Error conditions related to "catch".

test error-3.1 {errors in catch command} {
    list [catch {catch} msg] $msg
} {1 {wrong # args: should be "catch command ?varName?"}}
test error-3.2 {errors in catch command} {
    list [catch {catch a b c} msg] $msg
} {1 {wrong # args: should be "catch command ?varName?"}}
test error-3.3 {errors in catch command} {
    catch {unset a}
    set a(0) 22
    list [catch {catch {format 44} a} msg] $msg
} {1 {couldn't save command result in variable}}
catch {unset a}

# More tests related to errorInfo and errorCode

test error-4.1 {errorInfo and errorCode variables} {
    list [catch {error msg1 msg2 msg3} msg] $msg $errorInfo $errorCode
} {1 msg1 msg2 msg3}
test error-4.2 {errorInfo and errorCode variables} {
    list [catch {error msg1 {} msg3} msg] $msg $errorInfo $errorCode
} {1 msg1 {msg1
    while executing
"error msg1 {} msg3"} msg3}
test error-4.3 {errorInfo and errorCode variables} {
    list [catch {error msg1 {}} msg] $msg $errorInfo $errorCode
} {1 msg1 {msg1
    while executing
"error msg1 {}"} NONE}
test error-4.4 {errorInfo and errorCode variables} {
    set errorCode bogus
    list [catch {error msg1} msg] $msg $errorInfo $errorCode
} {1 msg1 {msg1
    while executing
"error msg1"} NONE}
test error-4.5 {errorInfo and errorCode variables} {
    set errorCode bogus
    list [catch {error msg1 msg2 {}} msg] $msg $errorInfo $errorCode
} {1 msg1 msg2 {}}

# Errors in error command itself

test error-5.1 {errors in error command} {
    list [catch {error} msg] $msg
} {1 {wrong # args: should be "error message ?errorInfo? ?errorCode?"}}
test error-5.2 {errors in error command} {
    list [catch {error a b c d} msg] $msg
} {1 {wrong # args: should be "error message ?errorInfo? ?errorCode?"}}

# Make sure that catch resets error information

test error-6.1 {catch must reset error state} {
    catch {error outer [catch {error inner inner.errorInfo inner.errorCode}]}
    list $errorCode $errorInfo
} {NONE 1}

# cleanup
catch {rename p ""}
::tcltest::cleanupTests
return 
@


1.3
log
@Updated to tcl 8.4.6
@
text
@d14 1
a14 1
# RCS: @@(#) $Id: error.test,v 1.9 2002/01/29 03:03:02 hobbs Exp $
@


1.3.4.1
log
@sync branch with HEAD
@
text
@d14 1
a14 1
# RCS: @@(#) $Id$
@


1.3.2.1
log
@merge from HEAD
@
text
@d14 1
a14 1
# RCS: @@(#) $Id$
@


1.2
log
@updated tcl to 8.4.4
@
text
@@


1.1
log
@*** empty log message ***
@
text
@@


1.1.6.1
log
@updates from HEAD, part 1
@
text
@d14 1
a14 1
# RCS: @@(#) $Id: error.test,v 1.2 2003/11/07 14:54:43 morrison Exp $
@


1.1.6.2
log
@merge from HEAD
@
text
@@


1.1.6.3
log
@merge from head
@
text
@d14 1
a14 1
# RCS: @@(#) $Id: error.test,v 1.3 2004/03/04 19:47:14 morrison Exp $
@


1.1.6.4
log
@merge from head...
@
text
@d14 1
a14 1
# RCS: @@(#) $Id: error.test,v 1.1.6.3 2004/03/15 12:10:32 erikg Exp $
@


