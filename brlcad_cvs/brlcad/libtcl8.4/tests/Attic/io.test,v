head	1.4;
access;
symbols
	ansi-20040405-merged:1.3.4.1
	postmerge-20040405-ansi:1.3
	premerge-20040404-ansi:1.3
	postmerge-autoconf:1.3
	autoconf-freeze:1.1.6.4
	premerge-autoconf:1.3
	postmerge-20040315-windows:1.3
	premerge-20040315-windows:1.3
	windows-20040315-freeze:1.3.2.1
	autoconf-20031203:1.1.6.1
	autoconf-20031202:1.1
	autoconf-branch:1.1.0.6
	phong-branch:1.1.0.4
	photonmap-branch:1.1.0.2
	windows-branch:1.3.0.2
	ansi-branch:1.3.0.4;
locks; strict;
comment	@# @;


1.4
date	2004.05.21.18.04.44;	author morrison;	state dead;
branches;
next	1.3;

1.3
date	2004.03.04.19.47.17;	author morrison;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2003.11.07.14.54.43;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.13.19.18.31;	author jra;	state Exp;
branches
	1.1.6.1;
next	;

1.1.6.1
date	2003.12.03.16.24.44;	author erikg;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2004.02.12.18.56.37;	author erikg;	state Exp;
branches;
next	1.1.6.3;

1.1.6.3
date	2004.03.15.12.10.33;	author erikg;	state Exp;
branches;
next	1.1.6.4;

1.1.6.4
date	2004.03.15.14.01.25;	author erikg;	state Exp;
branches;
next	;

1.3.2.1
date	2004.03.12.09.59.15;	author morrison;	state Exp;
branches;
next	;

1.3.4.1
date	2004.03.17.21.19.58;	author morrison;	state Exp;
branches;
next	;


desc
@@


1.4
log
@moved from top-level to src/other/.
@
text
@# Functionality covered: operation of all IO commands, and all procedures
# defined in generic/tclIO.c.
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 1991-1994 The Regents of the University of California.
# Copyright (c) 1994-1997 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: io.test,v 1.3 2004/03/04 19:47:17 morrison Exp $

if {[catch {package require tcltest 2}]} {
    puts stderr "Skipping tests in [info script].  tcltest 2 required."
    return
}
namespace eval ::tcl::test::io {

    namespace import ::tcltest::cleanupTests
    namespace import ::tcltest::interpreter
    namespace import ::tcltest::makeFile
    namespace import ::tcltest::removeFile
    namespace import ::tcltest::test
    namespace import ::tcltest::testConstraint
    namespace import ::tcltest::viewFile

testConstraint testchannel [llength [info commands testchannel]]
testConstraint exec [llength [info commands exec]]
testConstraint openpipe 1
testConstraint fileevent [llength [info commands fileevent]]
testConstraint fcopy [llength [info commands fcopy]]

# You need a *very* special environment to do some tests.  In
# particular, many file systems do not support large-files...
testConstraint largefileSupport 0

# set up a long data file for some of the following tests

set path(longfile) [makeFile {} longfile]
set f [open $path(longfile) w]
fconfigure $f -eofchar {} -translation lf
for { set i 0 } { $i < 100 } { incr i} {
    puts $f "#123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef
\#123456789abcdef01
\#"
    }
close $f

set path(cat) [makeFile {
    set f stdin
    if {$argv != ""} {
	set f [open [lindex $argv 0]]
    }
    fconfigure $f -encoding binary -translation lf -blocking 0 -eofchar \x1a
    fconfigure stdout -encoding binary -translation lf -buffering none
    fileevent $f readable "foo $f"
    proc foo {f} {
	set x [read $f]
	catch {puts -nonewline $x}
	if {[eof $f]} {
	    close $f
	    exit 0
	}
    }
    vwait forever
} cat]

set thisScript [file join [pwd] [info script]]

proc contents {file} {
    set f [open $file]
    fconfigure $f -translation binary
    set a [read $f]
    close $f
    return $a
}

test io-1.5 {Tcl_WriteChars: CheckChannelErrors} {emptyTest} {
    # no test, need to cause an async error.
} {}

set path(test1) [makeFile {} test1]

test io-1.6 {Tcl_WriteChars: WriteBytes} {
    set f [open $path(test1) w]
    fconfigure $f -encoding binary
    puts -nonewline $f "a\u4e4d\0"
    close $f
    contents $path(test1)
} "a\x4d\x00"
test io-1.7 {Tcl_WriteChars: WriteChars} {
    set f [open $path(test1) w]
    fconfigure $f -encoding shiftjis
    puts -nonewline $f "a\u4e4d\0"
    close $f
    contents $path(test1)
} "a\x93\xe1\x00"

set path(test2) [makeFile {} test2]

test io-1.8 {Tcl_WriteChars: WriteChars} {
    # This test written for SF bug #506297.
    #
    # Executing this test without the fix for the referenced bug
    # applied to tcl will cause tcl, more specifically WriteChars, to
    # go into an infinite loop.

    set f [open $path(test2) w] 
    fconfigure      $f -encoding iso2022-jp 
    puts -nonewline $f [format %s%c [string repeat " " 4] 12399] 
    close           $f 
    contents $path(test2)
} "    \x1b\$B\$O\x1b(B"

test io-2.1 {WriteBytes} {
    # loop until all bytes are written
    
    set f [open $path(test1) w]
    fconfigure $f  -encoding binary -buffersize 16 -translation crlf
    puts $f "abcdefghijklmnopqrstuvwxyz"
    close $f
    contents $path(test1)
} "abcdefghijklmnopqrstuvwxyz\r\n"
test io-2.2 {WriteBytes: savedLF > 0} {
    # After flushing buffer, there was a \n left over from the last
    # \n -> \r\n expansion.  It gets stuck at beginning of this buffer.

    set f [open $path(test1) w]
    fconfigure $f -encoding binary -buffersize 16 -translation crlf
    puts -nonewline $f "123456789012345\n12"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "123456789012345\r" "123456789012345\r\n12"]
test io-2.3 {WriteBytes: flush on line} {
    # Tcl "line" buffering has weird behavior: if current buffer contains
    # a \n, entire buffer gets flushed.  Logical behavior would be to flush
    # only up to the \n.
    
    set f [open $path(test1) w]
    fconfigure $f -encoding binary -buffering line -translation crlf
    puts -nonewline $f "\n12"
    set x [contents $path(test1)]
    close $f
    set x
} "\r\n12"
test io-2.4 {WriteBytes: reset sawLF after each buffer} {
    set f [open $path(test1) w]
     fconfigure $f -encoding binary -buffering line -translation lf \
	     -buffersize 16
    puts -nonewline $f "abcdefg\nhijklmnopqrstuvwxyz"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "abcdefg\nhijklmno" "abcdefg\nhijklmnopqrstuvwxyz"]

test io-3.1 {WriteChars: compatibility with WriteBytes} {
    # loop until all bytes are written
    
    set f [open $path(test1) w]
    fconfigure $f -encoding ascii -buffersize 16 -translation crlf
    puts $f "abcdefghijklmnopqrstuvwxyz"
    close $f
    contents $path(test1)
} "abcdefghijklmnopqrstuvwxyz\r\n"
test io-3.2 {WriteChars: compatibility with WriteBytes: savedLF > 0} {
    # After flushing buffer, there was a \n left over from the last
    # \n -> \r\n expansion.  It gets stuck at beginning of this buffer.

    set f [open $path(test1) w]
    fconfigure $f -encoding ascii -buffersize 16 -translation crlf
    puts -nonewline $f "123456789012345\n12"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "123456789012345\r" "123456789012345\r\n12"]
test io-3.3 {WriteChars: compatibility with WriteBytes: flush on line} {
    # Tcl "line" buffering has weird behavior: if current buffer contains
    # a \n, entire buffer gets flushed.  Logical behavior would be to flush
    # only up to the \n.
    
    set f [open $path(test1) w]
    fconfigure $f -encoding ascii -buffering line -translation crlf
    puts -nonewline $f "\n12"
    set x [contents $path(test1)]
    close $f
    set x
} "\r\n12"
test io-3.4 {WriteChars: loop over stage buffer} {
    # stage buffer maps to more than can be queued at once.

    set f [open $path(test1) w]
    fconfigure $f -encoding jis0208 -buffersize 16 
    puts -nonewline $f "\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "!)!)!)!)!)!)!)!)" "!)!)!)!)!)!)!)!)!)!)!)!)!)!)!)"]
test io-3.5 {WriteChars: saved != 0} {
    # Bytes produced by UtfToExternal from end of last channel buffer
    # had to be moved to beginning of next channel buffer to preserve
    # requested buffersize.

    set f [open $path(test1) w]
    fconfigure $f -encoding jis0208 -buffersize 17 
    puts -nonewline $f "\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "!)!)!)!)!)!)!)!)!" "!)!)!)!)!)!)!)!)!)!)!)!)!)!)!)"]
test io-3.6 {WriteChars: (stageRead + dstWrote == 0)} {
    # One incomplete UTF-8 character at end of staging buffer.  Backup
    # in src to the beginning of that UTF-8 character and try again.
    #
    # Translate the first 16 bytes, produce 14 bytes of output, 2 left over
    # (first two bytes of \uff21 in UTF-8).  Given those two bytes try
    # translating them again, find that no bytes are read produced, and break
    # to outer loop where those two bytes will have the remaining 4 bytes
    # (the last byte of \uff21 plus the all of \uff22) appended.

    set f [open $path(test1) w]
    fconfigure $f -encoding shiftjis -buffersize 16
    puts -nonewline $f "12345678901234\uff21\uff22"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "12345678901234\x82\x60" "12345678901234\x82\x60\x82\x61"]
test io-3.7 {WriteChars: (bufPtr->nextAdded > bufPtr->length)} {
    # When translating UTF-8 to external, the produced bytes went past end
    # of the channel buffer.  This is done purpose -- we then truncate the
    # bytes at the end of the partial character to preserve the requested
    # blocksize on flush.  The truncated bytes are moved to the beginning
    # of the next channel buffer.

    set f [open $path(test1) w]
    fconfigure $f -encoding jis0208 -buffersize 17 
    puts -nonewline $f "\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "!)!)!)!)!)!)!)!)!" "!)!)!)!)!)!)!)!)!)!)!)!)!)!)!)"]
test io-3.8 {WriteChars: reset sawLF after each buffer} {
    set f [open $path(test1) w]
    fconfigure $f -encoding ascii -buffering line -translation lf \
	     -buffersize 16
    puts -nonewline $f "abcdefg\nhijklmnopqrstuvwxyz"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "abcdefg\nhijklmno" "abcdefg\nhijklmnopqrstuvwxyz"]

test io-4.1 {TranslateOutputEOL: lf} {
    # search for \n

    set f [open $path(test1) w]
    fconfigure $f -buffering line -translation lf
    puts $f "abcde"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "abcde\n" "abcde\n"]
test io-4.2 {TranslateOutputEOL: cr} {
    # search for \n, replace with \r

    set f [open $path(test1) w]
    fconfigure $f -buffering line -translation cr
    puts $f "abcde"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "abcde\r" "abcde\r"]
test io-4.3 {TranslateOutputEOL: crlf} {
    # simple case: search for \n, replace with \r

    set f [open $path(test1) w]
    fconfigure $f -buffering line -translation crlf
    puts $f "abcde"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "abcde\r\n" "abcde\r\n"]
test io-4.4 {TranslateOutputEOL: crlf} {
    # keep storing more bytes in output buffer until output buffer is full.
    # We have 13 bytes initially that would turn into 18 bytes.  Fill
    # dest buffer while (dstEnd < dstMax).

    set f [open $path(test1) w]
    fconfigure $f -translation crlf -buffersize 16
    puts -nonewline $f "1234567\n\n\n\n\nA"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "1234567\r\n\r\n\r\n\r\n\r" "1234567\r\n\r\n\r\n\r\n\r\nA"]
test io-4.5 {TranslateOutputEOL: crlf} {
    # Check for overflow of the destination buffer

    set f [open $path(test1) w]
    fconfigure $f -translation crlf -buffersize 12
    puts -nonewline $f "12345678901\n456789012345678901234"
    close $f
    set x [contents $path(test1)]
} "12345678901\r\n456789012345678901234"

test io-5.1 {CheckFlush: not full} {
    set f [open $path(test1) w]
    fconfigure $f 
    puts -nonewline $f "12345678901234567890"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "" "12345678901234567890"]
test io-5.2 {CheckFlush: full} {
    set f [open $path(test1) w]
    fconfigure $f -buffersize 16
    puts -nonewline $f "12345678901234567890"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "1234567890123456" "12345678901234567890"]
test io-5.3 {CheckFlush: not line} {
    set f [open $path(test1) w]
    fconfigure $f -buffering line
    puts -nonewline $f "12345678901234567890"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "" "12345678901234567890"]
test io-5.4 {CheckFlush: line} {
    set f [open $path(test1) w]
    fconfigure $f -buffering line -translation lf -encoding ascii
    puts -nonewline $f "1234567890\n1234567890"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "1234567890\n1234567890" "1234567890\n1234567890"]
test io-5.5 {CheckFlush: none} {
    set f [open $path(test1) w]
    fconfigure $f -buffering none
    puts -nonewline $f "1234567890"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "1234567890" "1234567890"]

test io-6.1 {Tcl_GetsObj: working} {
    set f [open $path(test1) w]
    puts $f "foo\nboo"
    close $f
    set f [open $path(test1)]
    set x [gets $f]
    close $f
    set x
} {foo}
test io-6.2 {Tcl_GetsObj: CheckChannelErrors() != 0} {
    # no test, need to cause an async error.
} {}
test io-6.3 {Tcl_GetsObj: how many have we used?} {
    # if (bufPtr != NULL) {oldRemoved = bufPtr->nextRemoved}

    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    puts $f "abc\ndefg"
    close $f
    set f [open $path(test1)]
    set x [list [tell $f] [gets $f line] [tell $f] [gets $f line] $line]
    close $f
    set x
} {0 3 5 4 defg}
test io-6.4 {Tcl_GetsObj: encoding == NULL} {
    set f [open $path(test1) w]
    fconfigure $f -translation binary
    puts $f "\x81\u1234\0"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation binary
    set x [list [gets $f line] $line]
    close $f
    set x
} [list 3 "\x81\x34\x00"]
test io-6.5 {Tcl_GetsObj: encoding != NULL} {
    set f [open $path(test1) w]
    fconfigure $f -translation binary
    puts $f "\x88\xea\x92\x9a"
    close $f
    set f [open $path(test1)]
    fconfigure $f -encoding shiftjis
    set x [list [gets $f line] $line]
    close $f
    set x
} [list 2 "\u4e00\u4e01"]
set a "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"
append a $a
append a $a
test io-6.6 {Tcl_GetsObj: loop test} {
    # if (dst >= dstEnd) 

    set f [open $path(test1) w]
    puts $f $a
    puts $f hi
    close $f
    set f [open $path(test1)]
    set x [list [gets $f line] $line]
    close $f
    set x
} [list 256 $a]
test io-6.7 {Tcl_GetsObj: error in input} {stdio openpipe} {
    # if (FilterInputBytes(chanPtr, &gs) != 0)

    set f [open "|[list [interpreter] cat]" w+]
    puts -nonewline $f "hi\nwould"
    flush $f
    gets $f
    fconfigure $f -blocking 0
    set x [gets $f line]
    close $f
    set x
} {-1}
test io-6.8 {Tcl_GetsObj: remember if EOF is seen} {
    set f [open $path(test1) w]
    puts $f "abcdef\x1aghijk\nwombat"
    close $f
    set f [open $path(test1)]
    fconfigure $f -eofchar \x1a
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {6 abcdef -1 {}}
test io-6.9 {Tcl_GetsObj: remember if EOF is seen} {
    set f [open $path(test1) w]
    puts $f "abcdefghijk\nwom\u001abat"
    close $f
    set f [open $path(test1)]
    fconfigure $f -eofchar \x1a
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {11 abcdefghijk 3 wom}

# Comprehensive tests

test io-6.10 {Tcl_GetsObj: lf mode: no chars} {
    set f [open $path(test1) w]
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation lf
    set x [list [gets $f line] $line]
    close $f
    set x
} {-1 {}}
test io-6.11 {Tcl_GetsObj: lf mode: lone \n} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "\n"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation lf
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {0 {} -1 {}}
test io-6.12 {Tcl_GetsObj: lf mode: lone \r} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "\r"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation lf
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 1 "\r" -1 ""]
test io-6.13 {Tcl_GetsObj: lf mode: 1 char} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f a
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation lf
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {1 a -1 {}}
test io-6.14 {Tcl_GetsObj: lf mode: 1 char followed by EOL} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "a\n"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation lf
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {1 a -1 {}}
test io-6.15 {Tcl_GetsObj: lf mode: several chars} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\nefgh\rijkl\r\nmnop"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation lf
    set x [list [gets $f line] $line [gets $f line] $line [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 4 "abcd" 10 "efgh\rijkl\r" 4 "mnop" -1 ""]
test io-6.16 {Tcl_GetsObj: cr mode: no chars} {
    set f [open $path(test1) w]
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation cr
    set x [list [gets $f line] $line]
    close $f
    set x
} {-1 {}}
test io-6.17 {Tcl_GetsObj: cr mode: lone \n} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "\n"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation cr
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 1 "\n" -1 ""]
test io-6.18 {Tcl_GetsObj: cr mode: lone \r} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "\r"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation cr
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {0 {} -1 {}}
test io-6.19 {Tcl_GetsObj: cr mode: 1 char} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f a
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation cr
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {1 a -1 {}}
test io-6.20 {Tcl_GetsObj: cr mode: 1 char followed by EOL} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "a\r"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation cr
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {1 a -1 {}}
test io-6.21 {Tcl_GetsObj: cr mode: several chars} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\nefgh\rijkl\r\nmnop"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation cr
    set x [list [gets $f line] $line [gets $f line] $line [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 9 "abcd\nefgh" 4 "ijkl" 5 "\nmnop" -1 ""]
test io-6.22 {Tcl_GetsObj: crlf mode: no chars} {
    set f [open $path(test1) w]
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf
    set x [list [gets $f line] $line]
    close $f
    set x
} {-1 {}}
test io-6.23 {Tcl_GetsObj: crlf mode: lone \n} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "\n"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 1 "\n" -1 ""]
test io-6.24 {Tcl_GetsObj: crlf mode: lone \r} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "\r"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 1 "\r" -1 ""]
test io-6.25 {Tcl_GetsObj: crlf mode: \r\r} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "\r\r"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 2 "\r\r" -1 ""]
test io-6.26 {Tcl_GetsObj: crlf mode: \r\n} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "\r\n"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 0 "" -1 ""]
test io-6.27 {Tcl_GetsObj: crlf mode: 1 char} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f a
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {1 a -1 {}}
test io-6.28 {Tcl_GetsObj: crlf mode: 1 char followed by EOL} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "a\r\n"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {1 a -1 {}}
test io-6.29 {Tcl_GetsObj: crlf mode: several chars} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\nefgh\rijkl\r\nmnop"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf
    set x [list [gets $f line] $line [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 14 "abcd\nefgh\rijkl" 4 "mnop" -1 ""]
test io-6.30 {Tcl_GetsObj: crlf mode: buffer exhausted} {testchannel} {
    # if (eol >= dstEnd)

    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "123456789012345\r\nabcdefghijklmnoprstuvwxyz"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf -buffersize 16
    set x [list [gets $f line] $line [testchannel inputbuffered $f]]
    close $f
    set x
} [list 15 "123456789012345" 15]
test io-6.31 {Tcl_GetsObj: crlf mode: buffer exhausted, blocked} {stdio testchannel openpipe fileevent} {
    # (FilterInputBytes() != 0)

    set f [open "|[list [interpreter] $path(cat)]" w+]
    fconfigure $f -translation {crlf lf} -buffering none
    puts -nonewline $f "bbbbbbbbbbbbbb\r\n123456789012345\r"
    fconfigure $f -buffersize 16
    set x [gets $f]
    fconfigure $f -blocking 0
    lappend x [gets $f line] $line [fblocked $f] [testchannel inputbuffered $f]
    close $f
    set x
} [list "bbbbbbbbbbbbbb" -1 "" 1 16]
test io-6.32 {Tcl_GetsObj: crlf mode: buffer exhausted, more data} {testchannel} {
    # not (FilterInputBytes() != 0)

    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "123456789012345\r\n123"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf -buffersize 16
    set x [list [gets $f line] $line [tell $f] [testchannel inputbuffered $f]]
    close $f
    set x
} [list 15 "123456789012345" 17 3]
test io-6.33 {Tcl_GetsObj: crlf mode: buffer exhausted, at eof} {
    # eol still equals dstEnd
    
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "123456789012345\r"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf -buffersize 16
    set x [list [gets $f line] $line [eof $f]]
    close $f
    set x
} [list 16 "123456789012345\r" 1]
test io-6.34 {Tcl_GetsObj: crlf mode: buffer exhausted, not followed by \n} {
    # not (*eol == '\n') 
    
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "123456789012345\rabcd\r\nefg"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf -buffersize 16
    set x [list [gets $f line] $line [tell $f]]
    close $f
    set x
} [list 20 "123456789012345\rabcd" 22]
test io-6.35 {Tcl_GetsObj: auto mode: no chars} {
    set f [open $path(test1) w]
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto
    set x [list [gets $f line] $line]
    close $f
    set x
} {-1 {}}
test io-6.36 {Tcl_GetsObj: auto mode: lone \n} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "\n"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 0 "" -1 ""]
test io-6.37 {Tcl_GetsObj: auto mode: lone \r} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "\r"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 0 "" -1 ""]
test io-6.38 {Tcl_GetsObj: auto mode: \r\r} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "\r\r"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto
    set x [list [gets $f line] $line [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 0 "" 0 "" -1 ""]
test io-6.39 {Tcl_GetsObj: auto mode: \r\n} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "\r\n"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 0 "" -1 ""]
test io-6.40 {Tcl_GetsObj: auto mode: 1 char} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f a
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {1 a -1 {}}
test io-6.41 {Tcl_GetsObj: auto mode: 1 char followed by EOL} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "a\r\n"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {1 a -1 {}}
test io-6.42 {Tcl_GetsObj: auto mode: several chars} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\nefgh\rijkl\r\nmnop"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto
    set x [list [gets $f line] $line [gets $f line] $line]
    lappend x [gets $f line] $line [gets $f line] $line [gets $f line] $line
    close $f
    set x
} [list 4 "abcd" 4 "efgh" 4 "ijkl" 4 "mnop" -1 ""]
test io-6.43 {Tcl_GetsObj: input saw cr} {stdio testchannel openpipe fileevent} {
    # if (chanPtr->flags & INPUT_SAW_CR)

    set f [open "|[list [interpreter] $path(cat)]" w+]
    fconfigure $f -translation {auto lf} -buffering none
    puts -nonewline $f "bbbbbbbbbbbbbbb\n123456789abcdef\r"
    fconfigure $f -buffersize 16
    set x [list [gets $f]]
    fconfigure $f -blocking 0
    lappend x [gets $f line] $line [testchannel queuedcr $f] 
    fconfigure $f -blocking 1
    puts -nonewline $f "\nabcd\refg\x1a"
    lappend x [gets $f line] $line [testchannel queuedcr $f]
    lappend x [gets $f line] $line
    close $f
    set x
} [list "bbbbbbbbbbbbbbb" 15 "123456789abcdef" 1 4 "abcd" 0 3 "efg"]
test io-6.44 {Tcl_GetsObj: input saw cr, not followed by cr} {stdio testchannel openpipe fileevent} {
    # not (*eol == '\n') 

    set f [open "|[list [interpreter] $path(cat)]" w+]
    fconfigure $f -translation {auto lf} -buffering none
    puts -nonewline $f "bbbbbbbbbbbbbbb\n123456789abcdef\r"
    fconfigure $f -buffersize 16
    set x [list [gets $f]]
    fconfigure $f -blocking 0
    lappend x [gets $f line] $line [testchannel queuedcr $f] 
    fconfigure $f -blocking 1
    puts -nonewline $f "abcd\refg\x1a"
    lappend x [gets $f line] $line [testchannel queuedcr $f]
    lappend x [gets $f line] $line
    close $f
    set x
} [list "bbbbbbbbbbbbbbb" 15 "123456789abcdef" 1 4 "abcd" 0 3 "efg"]
test io-6.45 {Tcl_GetsObj: input saw cr, skip right number of bytes} {stdio testchannel openpipe fileevent} {
    # Tcl_ExternalToUtf()

    set f [open "|[list [interpreter] $path(cat)]" w+]
    fconfigure $f -translation {auto lf} -buffering none
    fconfigure $f -encoding unicode
    puts -nonewline $f "bbbbbbbbbbbbbbb\n123456789abcdef\r"
    fconfigure $f -buffersize 16
    gets $f
    fconfigure $f -blocking 0
    set x [list [gets $f line] $line [testchannel queuedcr $f]]
    fconfigure $f -blocking 1
    puts -nonewline $f "\nabcd\refg"
    lappend x [gets $f line] $line [testchannel queuedcr $f]
    close $f
    set x
} [list 15 "123456789abcdef" 1 4 "abcd" 0]
test io-6.46 {Tcl_GetsObj: input saw cr, followed by just \n should give eof} {stdio testchannel openpipe fileevent} {
    # memmove()

    set f [open "|[list [interpreter] $path(cat)]" w+]
    fconfigure $f -translation {auto lf} -buffering none
    puts -nonewline $f "bbbbbbbbbbbbbbb\n123456789abcdef\r"
    fconfigure $f -buffersize 16
    gets $f
    fconfigure $f -blocking 0
    set x [list [gets $f line] $line [testchannel queuedcr $f]]
    fconfigure $f -blocking 1
    puts -nonewline $f "\n\x1a"
    lappend x [gets $f line] $line [testchannel queuedcr $f]
    close $f
    set x
} [list 15 "123456789abcdef" 1 -1 "" 0]
test io-6.47 {Tcl_GetsObj: auto mode: \r at end of buffer, peek for \n} {testchannel} {
    # (eol == dstEnd)

    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "123456789012345\r\nabcdefghijklmnopq"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto -buffersize 16
    set x [list [gets $f] [testchannel inputbuffered $f]]
    close $f
    set x
} [list "123456789012345" 15]    
test io-6.48 {Tcl_GetsObj: auto mode: \r at end of buffer, no more avail} {testchannel} {
    # PeekAhead() did not get any, so (eol >= dstEnd)
    
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "123456789012345\r"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto -buffersize 16
    set x [list [gets $f] [testchannel queuedcr $f]]
    close $f
    set x
} [list "123456789012345" 1]
test io-6.49 {Tcl_GetsObj: auto mode: \r followed by \n} {testchannel} {
    # if (*eol == '\n') {skip++}
    
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "123456\r\n78901"
    close $f
    set f [open $path(test1)]
    set x [list [gets $f] [testchannel queuedcr $f] [tell $f] [gets $f]]
    close $f
    set x
} [list "123456" 0 8 "78901"]
test io-6.50 {Tcl_GetsObj: auto mode: \r not followed by \n} {testchannel} {
    # not (*eol == '\n') 
    
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "123456\r78901"
    close $f
    set f [open $path(test1)]
    set x [list [gets $f] [testchannel queuedcr $f] [tell $f] [gets $f]]
    close $f
    set x
} [list "123456" 0 7 "78901"]
test io-6.51 {Tcl_GetsObj: auto mode: \n} {
    # else if (*eol == '\n') {goto gotoeol;}
    
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "123456\n78901"
    close $f
    set f [open $path(test1)]
    set x [list [gets $f] [tell $f] [gets $f]]
    close $f
    set x
} [list "123456" 7 "78901"]
test io-6.52 {Tcl_GetsObj: saw EOF character} {testchannel} {
    # if (eof != NULL)

    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "123456\x1ak9012345\r"
    close $f
    set f [open $path(test1)]
    fconfigure $f -eofchar \x1a
    set x [list [gets $f] [testchannel queuedcr $f] [tell $f] [gets $f]]
    close $f
    set x
} [list "123456" 0 6 ""]
test io-6.53 {Tcl_GetsObj: device EOF} {
    # didn't produce any bytes

    set f [open $path(test1) w]
    close $f
    set f [open $path(test1)]
    set x [list [gets $f line] $line [eof $f]]
    close $f
    set x
} {-1 {} 1}
test io-6.54 {Tcl_GetsObj: device EOF} {
    # got some bytes before EOF.

    set f [open $path(test1) w]
    puts -nonewline $f abc
    close $f
    set f [open $path(test1)]
    set x [list [gets $f line] $line [eof $f]]
    close $f
    set x
} {3 abc 1}
test io-6.55 {Tcl_GetsObj: overconverted} {
    # Tcl_ExternalToUtf(), make sure state updated

    set f [open $path(test1) w]
    fconfigure $f -encoding iso2022-jp
    puts $f "there\u4e00ok\n\u4e01more bytes\nhere"
    close $f
    set f [open $path(test1)]
    fconfigure $f -encoding iso2022-jp
    set x [list [gets $f line] $line [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 8 "there\u4e00ok" 11 "\u4e01more bytes" 4 "here"]
test io-6.56 {Tcl_GetsObj: incomplete lines should disable file events} {stdio openpipe fileevent} {
    update
    set f [open "|[list [interpreter] $path(cat)]" w+]
    fconfigure $f -buffering none
    puts -nonewline $f "foobar"
    fconfigure $f -blocking 0
    variable x {}
    after 500 [namespace code { lappend x timeout }]
    fileevent $f readable [namespace code { lappend x [gets $f] }]
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
    fconfigure $f -blocking 1
    puts -nonewline $f "baz\n"
    after 500 [namespace code { lappend x timeout }]
    fconfigure $f -blocking 0
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
    close $f
    set x
} {{} timeout foobarbaz timeout}

test io-7.1 {FilterInputBytes: split up character at end of buffer} {
    # (result == TCL_CONVERT_MULTIBYTE)

    set f [open $path(test1) w]
    fconfigure $f -encoding shiftjis
    puts $f "1234567890123\uff10\uff11\uff12\uff13\uff14\nend"
    close $f
    set f [open $path(test1)]
    fconfigure $f -encoding shiftjis -buffersize 16
    set x [gets $f]
    close $f
    set x
} "1234567890123\uff10\uff11\uff12\uff13\uff14"
test io-7.2 {FilterInputBytes: split up character in middle of buffer} {
    # (bufPtr->nextAdded < bufPtr->bufLength)
    
    set f [open $path(test1) w]
    fconfigure $f -encoding binary
    puts -nonewline $f "1234567890\n123\x82\x4f\x82\x50\x82"
    close $f
    set f [open $path(test1)]
    fconfigure $f -encoding shiftjis
    set x [list [gets $f line] $line [eof $f]]
    close $f
    set x
} [list 10 "1234567890" 0]
test io-7.3 {FilterInputBytes: split up character at EOF} {testchannel} {
    set f [open $path(test1) w]
    fconfigure $f -encoding binary
    puts -nonewline $f "1234567890123\x82\x4f\x82\x50\x82"
    close $f
    set f [open $path(test1)]
    fconfigure $f -encoding shiftjis
    set x [list [gets $f line] $line]
    lappend x [tell $f] [testchannel inputbuffered $f] [eof $f]
    lappend x [gets $f line] $line
    close $f
    set x
} [list 15 "1234567890123\uff10\uff11" 18 0 1 -1 ""]
test io-7.4 {FilterInputBytes: recover from split up character} {stdio openpipe fileevent} {
    set f [open "|[list [interpreter] $path(cat)]" w+]
    fconfigure $f -encoding binary -buffering none
    puts -nonewline $f "1234567890123\x82\x4f\x82\x50\x82"
    fconfigure $f -encoding shiftjis -blocking 0
    fileevent $f read [namespace code "ready $f"]
    variable x {}
    proc ready {f} {
	variable x
	lappend x [gets $f line] $line [fblocked $f]
    }
    vwait [namespace which -variable x]
    fconfigure $f -encoding binary -blocking 1
    puts $f "\x51\x82\x52"
    fconfigure $f -encoding shiftjis
    vwait [namespace which -variable x]
    close $f
    set x
} [list -1 "" 1 17 "1234567890123\uff10\uff11\uff12\uff13" 0]

test io-8.1 {PeekAhead: only go to device if no more cached data} {testchannel} {
    # (bufPtr->nextPtr == NULL)

    set f [open $path(test1) w]
    fconfigure $f -encoding ascii -translation lf
    puts -nonewline $f "123456789012345\r\n2345678"
    close $f
    set f [open $path(test1)]
    fconfigure $f -encoding ascii -translation auto -buffersize 16
    # here
    gets $f
    set x [testchannel inputbuffered $f]
    close $f
    set x
} "7"
test io-8.2 {PeekAhead: only go to device if no more cached data} {stdio testchannel openpipe fileevent} {
    # not (bufPtr->nextPtr == NULL)

    set f [open "|[list [interpreter] $path(cat)]" w+]
    fconfigure $f -translation lf -encoding ascii -buffering none
    puts -nonewline $f "123456789012345\r\nbcdefghijklmnopqrstuvwxyz"
    variable x {}
    fileevent $f read [namespace code "ready $f"]
    proc ready {f} {
	variable x
	lappend x [gets $f line] $line [testchannel inputbuffered $f]
    }
    fconfigure $f -encoding unicode -buffersize 16 -blocking 0
    vwait [namespace which -variable x]
    fconfigure $f -translation auto -encoding ascii -blocking 1
    # here
    vwait [namespace which -variable x]
    close $f
    set x
} [list -1 "" 42 15 "123456789012345" 25]
test io-8.3 {PeekAhead: no cached data available} {stdio testchannel openpipe fileevent} {
    # (bytesLeft == 0)

    set f [open "|[list [interpreter] $path(cat)]" w+]
    fconfigure $f -translation {auto binary}
    puts -nonewline $f "abcdefghijklmno\r"
    flush $f
    set x [list [gets $f line] $line [testchannel queuedcr $f]]
    close $f
    set x
} [list 15 "abcdefghijklmno" 1]
set a "123456789012345678901234567890"
append a "123456789012345678901234567890"
append a "1234567890123456789012345678901"
test io-8.4 {PeekAhead: cached data available in this buffer} {
    # not (bytesLeft == 0)

    set f [open $path(test1) w+]
    fconfigure $f -translation binary
    puts $f "${a}\r\nabcdef"
    close $f
    set f [open $path(test1)]
    fconfigure $f -encoding binary -translation auto

    # "${a}\r" was converted in one operation (because ENCODING_LINESIZE
    # is 30).  To check if "\n" follows, calls PeekAhead and determines
    # that cached data is available in buffer w/o having to call driver.

    set x [gets $f]
    close $f
    set x    
} $a
unset a
test io-8.5 {PeekAhead: don't peek if last read was short} {stdio testchannel openpipe fileevent} {
    # (bufPtr->nextAdded < bufPtr->length)

    set f [open "|[list [interpreter] $path(cat)]" w+]
    fconfigure $f -translation {auto binary}
    puts -nonewline $f "abcdefghijklmno\r"
    flush $f
    # here
    set x [list [gets $f line] $line [testchannel queuedcr $f]]
    close $f
    set x
} {15 abcdefghijklmno 1}
test io-8.6 {PeekAhead: change to non-blocking mode} {stdio testchannel openpipe fileevent} {
    # ((chanPtr->flags & CHANNEL_NONBLOCKING) == 0) 

    set f [open "|[list [interpreter] $path(cat)]" w+]
    fconfigure $f -translation {auto binary} -buffersize 16
    puts -nonewline $f "abcdefghijklmno\r"
    flush $f
    # here
    set x [list [gets $f line] $line [testchannel queuedcr $f]]
    close $f
    set x
} {15 abcdefghijklmno 1}
test io-8.7 {PeekAhead: cleanup} {stdio testchannel openpipe fileevent} {
    # Make sure bytes are removed from buffer.

    set f [open "|[list [interpreter] $path(cat)]" w+]
    fconfigure $f -translation {auto binary} -buffering none
    puts -nonewline $f "abcdefghijklmno\r"
    # here
    set x [list [gets $f line] $line [testchannel queuedcr $f]]
    puts -nonewline $f "\x1a"
    lappend x [gets $f line] $line
    close $f
    set x
} {15 abcdefghijklmno 1 -1 {}}
    

test io-9.1 {CommonGetsCleanup} {
} {}

test io-10.1 {Tcl_ReadChars: CheckChannelErrors} {
    # no test, need to cause an async error.
} {}
test io-10.2 {Tcl_ReadChars: loop until enough copied} {
    # one time
    # for (copied = 0; (unsigned) toRead > 0; )

    set f [open $path(test1) w]
    puts $f abcdefghijklmnop
    close $f

    set f [open $path(test1)]
    set x [read $f 5]
    close $f
    set x
} {abcde}
test io-10.3 {Tcl_ReadChars: loop until enough copied} {
    # multiple times
    # for (copied = 0; (unsigned) toRead > 0; )

    set f [open $path(test1) w]
    puts $f abcdefghijklmnopqrstuvwxyz
    close $f

    set f [open $path(test1)]
    fconfigure $f -buffersize 16
    # here
    set x [read $f 19]
    close $f
    set x
} {abcdefghijklmnopqrs}
test io-10.4 {Tcl_ReadChars: no more in channel buffer} {
    # (copiedNow < 0)

    set f [open $path(test1) w]
    puts -nonewline $f abcdefghijkl
    close $f

    set f [open $path(test1)]
    # here
    set x [read $f 1000]
    close $f
    set x
} {abcdefghijkl}
test io-10.5 {Tcl_ReadChars: stop on EOF} {
    # (chanPtr->flags & CHANNEL_EOF)

    set f [open $path(test1) w]
    puts -nonewline $f abcdefghijkl
    close $f

    set f [open $path(test1)]
    # here
    set x [read $f 1000]
    close $f
    set x
} {abcdefghijkl}

test io-11.1 {ReadBytes: want to read a lot} {
    # ((unsigned) toRead > (unsigned) srcLen)

    set f [open $path(test1) w]
    puts -nonewline $f abcdefghijkl
    close $f
    set f [open $path(test1)]
    fconfigure $f -encoding binary
    # here
    set x [read $f 1000]
    close $f
    set x
} {abcdefghijkl}
test io-11.2 {ReadBytes: want to read all} {
    # ((unsigned) toRead > (unsigned) srcLen)

    set f [open $path(test1) w]
    puts -nonewline $f abcdefghijkl
    close $f
    set f [open $path(test1)]
    fconfigure $f -encoding binary
    # here
    set x [read $f]
    close $f
    set x
} {abcdefghijkl}
test io-11.3 {ReadBytes: allocate more space} {
    # (toRead > length - offset - 1)

    set f [open $path(test1) w]
    puts -nonewline $f abcdefghijklmnopqrstuvwxyz
    close $f
    set f [open $path(test1)]
    fconfigure $f -buffersize 16 -encoding binary
    # here
    set x [read $f]
    close $f
    set x
} {abcdefghijklmnopqrstuvwxyz}
test io-11.4 {ReadBytes: EOF char found} {
    # (TranslateInputEOL() != 0)

    set f [open $path(test1) w]
    puts $f abcdefghijklmnopqrstuvwxyz
    close $f
    set f [open $path(test1)]
    fconfigure $f -eofchar m -encoding binary
    # here
    set x [list [read $f] [eof $f] [read $f] [eof $f]]
    close $f
    set x
} [list "abcdefghijkl" 1 "" 1]
    
test io-12.1 {ReadChars: want to read a lot} {
    # ((unsigned) toRead > (unsigned) srcLen)

    set f [open $path(test1) w]
    puts -nonewline $f abcdefghijkl
    close $f
    set f [open $path(test1)]
    # here
    set x [read $f 1000]
    close $f
    set x
} {abcdefghijkl}
test io-12.2 {ReadChars: want to read all} {
    # ((unsigned) toRead > (unsigned) srcLen)

    set f [open $path(test1) w]
    puts -nonewline $f abcdefghijkl
    close $f
    set f [open $path(test1)]
    # here
    set x [read $f]
    close $f
    set x
} {abcdefghijkl}
test io-12.3 {ReadChars: allocate more space} {
    # (toRead > length - offset - 1)

    set f [open $path(test1) w]
    puts -nonewline $f abcdefghijklmnopqrstuvwxyz
    close $f
    set f [open $path(test1)]
    fconfigure $f -buffersize 16
    # here
    set x [read $f]
    close $f
    set x
} {abcdefghijklmnopqrstuvwxyz}
test io-12.4 {ReadChars: split-up char} {stdio testchannel openpipe fileevent} {
    # (srcRead == 0)

    set f [open "|[list [interpreter] $path(cat)]" w+]
    fconfigure $f -encoding binary -buffering none -buffersize 16
    puts -nonewline $f "123456789012345\x96"
    fconfigure $f -encoding shiftjis -blocking 0

    fileevent $f read [namespace code "ready $f"]
    proc ready {f} {
	variable x
	lappend x [read $f] [testchannel inputbuffered $f]
    }
    variable x {}

    fconfigure $f -encoding shiftjis
    vwait [namespace which -variable x]
    fconfigure $f -encoding binary -blocking 1
    puts -nonewline $f "\x7b"
    after 500			;# Give the cat process time to catch up
    fconfigure $f -encoding shiftjis -blocking 0
    vwait [namespace which -variable x]
    close $f
    set x
} [list "123456789012345" 1 "\u672c" 0]
test io-12.5 {ReadChars: fileevents on partial characters} {stdio openpipe fileevent} {
    set path(test1) [makeFile {
	fconfigure stdout -encoding binary -buffering none
	gets stdin; puts -nonewline "\xe7"
	gets stdin; puts -nonewline "\x89"
	gets stdin; puts -nonewline "\xa6"
    } test1]
    set f [open "|[list [interpreter] $path(test1)]" r+]
    fileevent $f readable [namespace code {
	lappend x [read $f]
	if {[eof $f]} {
	    lappend x eof
	}
    }]
    puts $f "go1"
    flush $f
    fconfigure $f -blocking 0 -encoding utf-8
    variable x {}
    vwait [namespace which -variable x]
    after 500 [namespace code { lappend x timeout }]
    vwait [namespace which -variable x]
    puts $f "go2"
    flush $f
    vwait [namespace which -variable x]
    after 500 [namespace code { lappend x timeout }]
    vwait [namespace which -variable x]
    puts $f "go3"
    flush $f
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
    lappend x [catch {close $f} msg] $msg
    set x
} "{} timeout {} timeout \u7266 {} eof 0 {}"

test io-13.1 {TranslateInputEOL: cr mode} {} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\rdef\r"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation cr
    set x [read $f]
    close $f
    set x
} "abcd\ndef\n"
test io-13.2 {TranslateInputEOL: crlf mode} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\r\ndef\r\n"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf
    set x [read $f]
    close $f
    set x
} "abcd\ndef\n"
test io-13.3 {TranslateInputEOL: crlf mode: naked cr} {
    # (src >= srcMax) 

    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\r\ndef\r"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf
    set x [read $f]
    close $f
    set x
} "abcd\ndef\r"
test io-13.4 {TranslateInputEOL: crlf mode: cr followed by not \n} {
    # (src >= srcMax) 

    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\r\ndef\rfgh"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf
    set x [read $f]
    close $f
    set x
} "abcd\ndef\rfgh"
test io-13.5 {TranslateInputEOL: crlf mode: naked lf} {
    # (src >= srcMax) 

    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\r\ndef\nfgh"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf
    set x [read $f]
    close $f
    set x
} "abcd\ndef\nfgh"
test io-13.6 {TranslateInputEOL: auto mode: saw cr in last segment} {stdio testchannel openpipe fileevent} {
    # (chanPtr->flags & INPUT_SAW_CR)
    # This test may fail on slower machines.

    set f [open "|[list [interpreter] $path(cat)]" w+]
    fconfigure $f -blocking 0 -buffering none -translation {auto lf}

    fileevent $f read [namespace code "ready $f"]
    proc ready {f} {
	variable x
	lappend x [read $f] [testchannel queuedcr $f]
    }
    variable x {}
    variable y {}

    puts -nonewline $f "abcdefghj\r"
    after 500 [namespace code {set y ok}]
    vwait [namespace which -variable y]

    puts -nonewline $f "\n01234"
    after 500 [namespace code {set y ok}]
    vwait [namespace which -variable y]

    close $f
    set x
} [list "abcdefghj\n" 1 "01234" 0]
test io-13.7 {TranslateInputEOL: auto mode: naked \r} {testchannel openpipe} {
    # (src >= srcMax)

    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\r"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto
    set x [list [read $f] [testchannel queuedcr $f]]
    close $f
    set x
} [list "abcd\n" 1]
test io-13.8 {TranslateInputEOL: auto mode: \r\n} {
    # (*src == '\n')

    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\r\ndef"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto
    set x [read $f]
    close $f
    set x
} "abcd\ndef"
test io-13.9 {TranslateInputEOL: auto mode: \r followed by not \n} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\rdef"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto
    set x [read $f]
    close $f
    set x
} "abcd\ndef"
test io-13.10 {TranslateInputEOL: auto mode: \n} {
    # not (*src == '\r') 

    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\ndef"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto
    set x [read $f]
    close $f
    set x
} "abcd\ndef"
test io-13.11 {TranslateInputEOL: EOF char} {
    # (*chanPtr->inEofChar != '\0')

    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\ndefgh"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto -eofchar e
    set x [read $f]
    close $f
    set x
} "abcd\nd"
test io-13.12 {TranslateInputEOL: find EOF char in src} {
    # (*chanPtr->inEofChar != '\0')

    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "\r\n\r\n\r\nab\r\n\r\ndef\r\n\r\n\r\n"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto -eofchar e
    set x [read $f]
    close $f
    set x
} "\n\n\nab\n\nd"
    
# Test standard handle management. The functions tested are
# Tcl_SetStdChannel and Tcl_GetStdChannel. Incidentally we are
# also testing channel table management.

if {[info commands testchannel] != ""} {
    if {$tcl_platform(platform) == "macintosh"} {
	set consoleFileNames [list console0 console1 console2]
    } else {
	set consoleFileNames [lsort [testchannel open]]
    }
} else {
    # just to avoid an error
    set consoleFileNames [list]
}

test io-14.1 {Tcl_SetStdChannel and Tcl_GetStdChannel} {testchannel} {
    set l ""
    lappend l [fconfigure stdin -buffering]
    lappend l [fconfigure stdout -buffering]
    lappend l [fconfigure stderr -buffering]
    lappend l [lsort [testchannel open]]
    set l
} [list line line none $consoleFileNames]
test io-14.2 {Tcl_SetStdChannel and Tcl_GetStdChannel} {
    interp create x
    set l ""
    lappend l [x eval {fconfigure stdin -buffering}]
    lappend l [x eval {fconfigure stdout -buffering}]
    lappend l [x eval {fconfigure stderr -buffering}]
    interp delete x
    set l
} {line line none}

set path(test3) [makeFile {} test3]

test io-14.3 {Tcl_SetStdChannel & Tcl_GetStdChannel} {exec openpipe} {
    set f [open $path(test1) w]
    puts -nonewline $f {
	close stdin
	close stdout
	close stderr
	set f  [}
    puts $f [list open $path(test1) r]]
    puts $f "set f2 \[[list open $path(test2) w]]"
    puts $f "set f3 \[[list open $path(test3) w]]"
    puts $f {	puts stdout [gets stdin]
	puts stdout out
	puts stderr err
	close $f
	close $f2
	close $f3
    }
    close $f
    set result [exec [interpreter] $path(test1)]
    set f  [open $path(test2) r]
    set f2 [open $path(test3) r]
    lappend result [read $f] [read $f2]
    close $f
    close $f2
    set result
} {{
out
} {err
}}
# This test relies on the fact that the smallest available fd is used first.
test io-14.4 {Tcl_SetStdChannel & Tcl_GetStdChannel} {exec unixOnly} {
    set f [open $path(test1) w]
    puts -nonewline $f { close stdin
	close stdout
	close stderr
	set f  [}
    puts $f [list open $path(test1) r]]
    puts $f "set f2 \[[list open $path(test2) w]]"
    puts $f "set f3 \[[list open $path(test3) w]]"
    puts $f {	puts stdout [gets stdin]
	puts stdout $f2
	puts stderr $f3
	close $f
	close $f2
	close $f3
    }
    close $f
    set result [exec [interpreter] $path(test1)]
    set f  [open $path(test2) r]
    set f2 [open $path(test3) r]
    lappend result [read $f] [read $f2]
    close $f
    close $f2
    set result
} {{ close stdin
file1
} {file2
}}
catch {interp delete z}
test io-14.5 {Tcl_GetChannel: stdio name translation} {
    interp create z
    eof stdin
    catch {z eval flush stdin} msg1
    catch {z eval close stdin} msg2
    catch {z eval flush stdin} msg3
    set result [list $msg1 $msg2 $msg3]
    interp delete z
    set result
} {{channel "stdin" wasn't opened for writing} {} {can not find channel named "stdin"}}
test io-14.6 {Tcl_GetChannel: stdio name translation} {
    interp create z
    eof stdout
    catch {z eval flush stdout} msg1
    catch {z eval close stdout} msg2
    catch {z eval flush stdout} msg3
    set result [list $msg1 $msg2 $msg3]
    interp delete z
    set result
} {{} {} {can not find channel named "stdout"}}
test io-14.7 {Tcl_GetChannel: stdio name translation} {
    interp create z
    eof stderr
    catch {z eval flush stderr} msg1
    catch {z eval close stderr} msg2
    catch {z eval flush stderr} msg3
    set result [list $msg1 $msg2 $msg3]
    interp delete z
    set result
} {{} {} {can not find channel named "stderr"}}

set path(script) [makeFile {} script]

test io-14.8 {reuse of stdio special channels} {stdio openpipe} {
    file delete $path(script)
    file delete $path(test1)
    set f [open $path(script) w]
    puts -nonewline $f {
	close stderr
	set f [}
    puts $f [list open $path(test1) w]]
    puts -nonewline $f {
	puts stderr hello
	close $f
	set f [}
    puts $f [list open $path(test1) r]]
    puts $f {
	puts [gets $f]
    }
    close $f
    set f [open "|[list [interpreter] $path(script)]" r]
    set c [gets $f]
    close $f
    set c
} hello

test io-14.9 {reuse of stdio special channels} {stdio openpipe fileevent} {
    file delete $path(script)
    file delete $path(test1)
    set f [open $path(script) w]
    puts $f {
        array set path [lindex $argv 0]
	set f [open $path(test1) w]
	puts $f hello
	close $f
	close stderr
	set f [open "|[list [info nameofexecutable] $path(cat) $path(test1)]" r]
	puts [gets $f]
    }
    close $f
    set f [open "|[list [interpreter] $path(script) [array get path]]" r]
    set c [gets $f]
    close $f
    set c
} hello

test io-15.1 {Tcl_CreateCloseHandler} {
} {}

test io-16.1 {Tcl_DeleteCloseHandler} {
} {}

# Test channel table management. The functions tested are
# GetChannelTable, DeleteChannelTable, Tcl_RegisterChannel,
# Tcl_UnregisterChannel, Tcl_GetChannel and Tcl_CreateChannel.
#
# These functions use "eof stdin" to ensure that the standard
# channels are added to the channel table of the interpreter.

test io-17.1 {GetChannelTable, DeleteChannelTable on std handles} {testchannel} {
    set l1 [testchannel refcount stdin]
    eof stdin
    interp create x
    set l ""
    lappend l [expr [testchannel refcount stdin] - $l1]
    x eval {eof stdin}
    lappend l [expr [testchannel refcount stdin] - $l1]
    interp delete x
    lappend l [expr [testchannel refcount stdin] - $l1]
    set l
} {0 1 0}
test io-17.2 {GetChannelTable, DeleteChannelTable on std handles} {testchannel} {
    set l1 [testchannel refcount stdout]
    eof stdin
    interp create x
    set l ""
    lappend l [expr [testchannel refcount stdout] - $l1]
    x eval {eof stdout}
    lappend l [expr [testchannel refcount stdout] - $l1]
    interp delete x
    lappend l [expr [testchannel refcount stdout] - $l1]
    set l
} {0 1 0}
test io-17.3 {GetChannelTable, DeleteChannelTable on std handles} {testchannel} {
    set l1 [testchannel refcount stderr]
    eof stdin
    interp create x
    set l ""
    lappend l [expr [testchannel refcount stderr] - $l1]
    x eval {eof stderr}
    lappend l [expr [testchannel refcount stderr] - $l1]
    interp delete x
    lappend l [expr [testchannel refcount stderr] - $l1]
    set l
} {0 1 0}

test io-18.1 {Tcl_RegisterChannel, Tcl_UnregisterChannel} {testchannel} {
    file delete $path(test1)
    set l ""
    set f [open $path(test1) w]
    lappend l [lindex [testchannel info $f] 15]
    close $f
    if {[catch {lindex [testchannel info $f] 15} msg]} {
	lappend l $msg
    } else {
	lappend l "very broken: $f found after being closed"
    }
    string compare [string tolower $l] \
	[list 1 [format "can not find channel named \"%s\"" $f]]
} 0
test io-18.2 {Tcl_RegisterChannel, Tcl_UnregisterChannel} {testchannel} {
    file delete $path(test1)
    set l ""
    set f [open $path(test1) w]
    lappend l [lindex [testchannel info $f] 15]
    interp create x
    interp share "" $f x
    lappend l [lindex [testchannel info $f] 15]
    x eval close $f
    lappend l [lindex [testchannel info $f] 15]
    interp delete x
    lappend l [lindex [testchannel info $f] 15]
    close $f
    if {[catch {lindex [testchannel info $f] 15} msg]} {
	lappend l $msg
    } else {
	lappend l "very broken: $f found after being closed"
    }
    string compare [string tolower $l] \
	[list 1 2 1 1 [format "can not find channel named \"%s\"" $f]]
} 0
test io-18.3 {Tcl_RegisterChannel, Tcl_UnregisterChannel} {testchannel} {
    file delete $path(test1)
    set l ""
    set f [open $path(test1) w]
    lappend l [lindex [testchannel info $f] 15]
    interp create x
    interp share "" $f x
    lappend l [lindex [testchannel info $f] 15]
    interp delete x
    lappend l [lindex [testchannel info $f] 15]
    close $f
    if {[catch {lindex [testchannel info $f] 15} msg]} {
	lappend l $msg
    } else {
	lappend l "very broken: $f found after being closed"
    }
    string compare [string tolower $l] \
	[list 1 2 1 [format "can not find channel named \"%s\"" $f]]
} 0

test io-19.1 {Tcl_GetChannel->Tcl_GetStdChannel, standard handles} {
    eof stdin
} 0
test io-19.2 {testing Tcl_GetChannel, user opened handle} {
    file delete $path(test1)
    set f [open $path(test1) w]
    set x [eof $f]
    close $f
    set x
} 0
test io-19.3 {Tcl_GetChannel, channel not found} {
    list [catch {eof file34} msg] $msg
} {1 {can not find channel named "file34"}}
test io-19.4 {Tcl_CreateChannel, insertion into channel table} {testchannel} {
    file delete $path(test1)
    set f [open $path(test1) w]
    set l ""
    lappend l [eof $f]
    close $f
    if {[catch {lindex [testchannel info $f] 15} msg]} {
	lappend l $msg
    } else {
	lappend l "very broken: $f found after being closed"
    }
    string compare [string tolower $l] \
	[list 0 [format "can not find channel named \"%s\"" $f]]
} 0

test io-20.1 {Tcl_CreateChannel: initial settings} {
	set a [open $path(test2) w]
    set old [encoding system]
    encoding system ascii
    set f [open $path(test1) w]
    set x [fconfigure $f -encoding]
    close $f
    encoding system $old
	close $a
    set x
} {ascii}    
test io-20.2 {Tcl_CreateChannel: initial settings} {pcOnly} {
    set f [open $path(test1) w+]
    set x [list [fconfigure $f -eofchar] [fconfigure $f -translation]]
    close $f
    set x
} [list [list \x1a ""] {auto crlf}]
test io-20.3 {Tcl_CreateChannel: initial settings} {unixOnly} {
    set f [open $path(test1) w+]
    set x [list [fconfigure $f -eofchar] [fconfigure $f -translation]]
    close $f
    set x
} {{{} {}} {auto lf}}
test io-20.4 {Tcl_CreateChannel: initial settings} {macOnly} {
    set f [open $path(test1) w+]
    set x [list [fconfigure $f -eofchar] [fconfigure $f -translation]]
    close $f
    set x
} {{{} {}} {auto cr}}

set path(stdout) [makeFile {} stdout]

test io-20.5 {Tcl_CreateChannel: install channel in empty slot} {stdio openpipe} {
    set f [open $path(script) w]
    puts -nonewline $f {
	close stdout
	set f1 [}
    puts $f [list open $path(stdout) w]]
    puts $f {
	fconfigure $f1 -buffersize 777
	puts stderr [fconfigure stdout -buffersize]
    }
    close $f
    set f [open "|[list [interpreter] $path(script)]"]
    catch {close $f} msg
    set msg
} {777}
	
test io-21.1 {CloseChannelsOnExit} {
} {}
    
# Test management of attributes associated with a channel, such as
# its default translation, its name and type, etc. The functions
# tested in this group are Tcl_GetChannelName,
# Tcl_GetChannelType and Tcl_GetChannelFile. Tcl_GetChannelInstanceData
# not tested because files do not use the instance data.

test io-22.1 {Tcl_GetChannelMode} {
    # Not used anywhere in Tcl.
} {}

test io-23.1 {Tcl_GetChannelName} {testchannel} {
    file delete $path(test1)
    set f [open $path(test1) w]
    set n [testchannel name $f]
    close $f
    string compare $n $f
} 0

test io-24.1 {Tcl_GetChannelType} {testchannel} {
    file delete $path(test1)
    set f [open $path(test1) w]
    set t [testchannel type $f]
    close $f
    string compare $t file
} 0

test io-25.1 {Tcl_GetChannelHandle, input} {testchannel} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf -eofchar {}
    puts $f "1234567890\n098765432"
    close $f
    set f [open $path(test1) r]
    gets $f
    set l ""
    lappend l [testchannel inputbuffered $f]
    lappend l [tell $f]
    close $f
    set l
} {10 11}
test io-25.2 {Tcl_GetChannelHandle, output} {testchannel} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts $f hello
    set l ""
    lappend l [testchannel outputbuffered $f]
    lappend l [tell $f]
    flush $f
    lappend l [testchannel outputbuffered $f]
    lappend l [tell $f]
    close $f
    file delete $path(test1)
    set l
} {6 6 0 6}

test io-26.1 {Tcl_GetChannelInstanceData} {stdio openpipe} {
    # "pid" command uses Tcl_GetChannelInstanceData
    # Don't care what pid is (but must be a number), just want to exercise it.

    set f [open "|[list [interpreter] << exit]"]
    expr [pid $f]
    close $f
} {}    

# Test flushing. The functions tested here are FlushChannel.

test io-27.1 {FlushChannel, no output buffered} {
    file delete $path(test1)
    set f [open $path(test1) w]
    flush $f
    set s [file size $path(test1)]
    close $f
    set s
} 0
test io-27.2 {FlushChannel, some output buffered} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf -eofchar {}
    set l ""
    puts $f hello
    lappend l [file size $path(test1)]
    flush $f
    lappend l [file size $path(test1)]
    close $f
    lappend l [file size $path(test1)]
    set l
} {0 6 6}
test io-27.3 {FlushChannel, implicit flush on close} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf -eofchar {}
    set l ""
    puts $f hello
    lappend l [file size $path(test1)]
    close $f
    lappend l [file size $path(test1)]
    set l
} {0 6}
test io-27.4 {FlushChannel, implicit flush when buffer fills} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf -eofchar {}
    fconfigure $f -buffersize 60
    set l ""
    lappend l [file size $path(test1)]
    for {set i 0} {$i < 12} {incr i} {
	puts $f hello
    }
    lappend l [file size $path(test1)]
    flush $f
    lappend l [file size $path(test1)]
    close $f
    set l
} {0 60 72}
test io-27.5 {FlushChannel, implicit flush when buffer fills and on close} \
	{unixOrPc} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf -buffersize 60 -eofchar {}
    set l ""
    lappend l [file size $path(test1)]
    for {set i 0} {$i < 12} {incr i} {
	puts $f hello
    }
    lappend l [file size $path(test1)]
    close $f
    lappend l [file size $path(test1)]
    set l
} {0 60 72}

set path(pipe)   [makeFile {} pipe]
set path(output) [makeFile {} output]

test io-27.6 {FlushChannel, async flushing, async close} \
	{stdio asyncPipeClose openpipe} {
    file delete $path(pipe)
    file delete $path(output)
    set f [open $path(pipe) w]
    puts $f "set f \[[list open $path(output) w]]"
    puts $f {
	fconfigure $f -translation lf -buffering none -eofchar {}
	while {![eof stdin]} {
	    after 20
	    puts -nonewline $f [read stdin 1024]
	}
	close $f
    }
    close $f
    set x 01234567890123456789012345678901
    for {set i 0} {$i < 11} {incr i} {
        set x "$x$x"
    }
    set f [open $path(output) w]
    close $f
    set f [open "|[list [interpreter] $path(pipe)]" w]
    fconfigure $f -blocking off
    puts -nonewline $f $x
    close $f
    set counter 0
    while {([file size $path(output)] < 65536) && ($counter < 1000)} {
        incr counter
        after 20
        update
    }
    if {$counter == 1000} {
        set result "file size only [file size $path(output)]"
    } else {
        set result ok
    }
} ok

# Tests closing a channel. The functions tested are CloseChannel and Tcl_Close.

test io-28.1 {CloseChannel called when all references are dropped} {testchannel} {
    file delete $path(test1)
    set f [open $path(test1) w]
    interp create x
    interp share "" $f x
    set l ""
    lappend l [testchannel refcount $f]
    x eval close $f
    interp delete x
    lappend l [testchannel refcount $f]
    close $f
    set l
} {2 1}
test io-28.2 {CloseChannel called when all references are dropped} {
    file delete $path(test1)
    set f [open $path(test1) w]
    interp create x
    interp share "" $f x
    puts -nonewline $f abc
    close $f
    x eval puts $f def
    x eval close $f
    interp delete x
    set f [open $path(test1) r]
    set l [gets $f]
    close $f
    set l
} abcdef
test io-28.3 {CloseChannel, not called before output queue is empty} \
	{stdio asyncPipeClose nonPortable openpipe} {
    file delete $path(pipe)
    file delete $path(output)
    set f [open $path(pipe) w]
    puts $f {

	# Need to not have eof char appended on close, because the other
	# side of the pipe already closed, so that writing would cause an
	# error "invalid file".

	fconfigure stdout -eofchar {}
	fconfigure stderr -eofchar {}

	set f [open $path(output) w]
	fconfigure $f -translation lf -buffering none
	for {set x 0} {$x < 20} {incr x} {
	    after 20
	    puts -nonewline $f [read stdin 1024]
	}
	close $f
    }
    close $f
    set x 01234567890123456789012345678901
    for {set i 0} {$i < 11} {incr i} {
        set x "$x$x"
    }
    set f [open $path(output) w]
    close $f
    set f [open "|[list [interpreter] pipe]" r+]
    fconfigure $f -blocking off -eofchar {}

    puts -nonewline $f $x
    close $f
    set counter 0
    while {([file size $path(output)] < 20480) && ($counter < 1000)} {
        incr counter
        after 20
        update
    }
    if {$counter == 1000} {
        set result probably_broken
    } else {
        set result ok
    }
} ok
test io-28.4 {Tcl_Close} {testchannel} {
    file delete $path(test1)
    set l ""
    lappend l [lsort [testchannel open]]
    set f [open $path(test1) w]
    lappend l [lsort [testchannel open]]
    close $f
    lappend l [lsort [testchannel open]]
    set x [list $consoleFileNames \
		[lsort [eval list $consoleFileNames $f]] \
		$consoleFileNames]
    string compare $l $x
} 0
test io-28.5 {Tcl_Close vs standard handles} {stdio unixOnly testchannel openpipe} {
    file delete $path(script)
    set f [open $path(script) w]
    puts $f {
	close stdin
	puts [testchannel open]
    }
    close $f
    set f [open "|[list [interpreter] $path(script)]" r]
    set l [gets $f]
    close $f
    set l
} {file1 file2}

test io-29.1 {Tcl_WriteChars, channel not writable} {
    list [catch {puts stdin hello} msg] $msg
} {1 {channel "stdin" wasn't opened for writing}}
test io-29.2 {Tcl_WriteChars, empty string} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -eofchar {}
    puts -nonewline $f ""
    close $f
    file size $path(test1)
} 0
test io-29.3 {Tcl_WriteChars, nonempty string} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -eofchar {}
    puts -nonewline $f hello
    close $f
    file size $path(test1)
} 5
test io-29.4 {Tcl_WriteChars, buffering in full buffering mode} {testchannel} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf -buffering full -eofchar {}
    puts $f hello
    set l ""
    lappend l [testchannel outputbuffered $f]
    lappend l [file size $path(test1)]
    flush $f
    lappend l [testchannel outputbuffered $f]
    lappend l [file size $path(test1)]
    close $f
    set l
} {6 0 0 6}
test io-29.5 {Tcl_WriteChars, buffering in line buffering mode} {testchannel} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf -buffering line -eofchar {}
    puts -nonewline $f hello
    set l ""
    lappend l [testchannel outputbuffered $f]
    lappend l [file size $path(test1)]
    puts $f hello
    lappend l [testchannel outputbuffered $f]
    lappend l [file size $path(test1)]
    close $f
    set l
} {5 0 0 11}
test io-29.6 {Tcl_WriteChars, buffering in no buffering mode} {testchannel} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf -buffering none -eofchar {}
    puts -nonewline $f hello
    set l ""
    lappend l [testchannel outputbuffered $f]
    lappend l [file size $path(test1)]
    puts $f hello
    lappend l [testchannel outputbuffered $f]
    lappend l [file size $path(test1)]
    close $f
    set l
} {0 5 0 11}

test io-29.7 {Tcl_Flush, full buffering} {testchannel} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf -buffering full -eofchar {}
    puts -nonewline $f hello
    set l ""
    lappend l [testchannel outputbuffered $f]
    lappend l [file size $path(test1)]
    puts $f hello
    lappend l [testchannel outputbuffered $f]
    lappend l [file size $path(test1)]
    flush $f
    lappend l [testchannel outputbuffered $f]
    lappend l [file size $path(test1)]
    close $f
    set l
} {5 0 11 0 0 11}
test io-29.8 {Tcl_Flush, full buffering} {testchannel} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf -buffering line
    puts -nonewline $f hello
    set l ""
    lappend l [testchannel outputbuffered $f]
    lappend l [file size $path(test1)]
    flush $f
    lappend l [testchannel outputbuffered $f]
    lappend l [file size $path(test1)]
    puts $f hello
    lappend l [testchannel outputbuffered $f]
    lappend l [file size $path(test1)]
    flush $f
    lappend l [testchannel outputbuffered $f]
    lappend l [file size $path(test1)]
    close $f
    set l
} {5 0 0 5 0 11 0 11}
test io-29.9 {Tcl_Flush, channel not writable} {
    list [catch {flush stdin} msg] $msg
} {1 {channel "stdin" wasn't opened for writing}}
test io-29.10 {Tcl_WriteChars, looping and buffering} {
    file delete $path(test1)
    set f1 [open $path(test1) w]
    fconfigure $f1 -translation lf -eofchar {}
    set f2 [open $path(longfile) r]
    for {set x 0} {$x < 10} {incr x} {
	puts $f1 [gets $f2]
    }
    close $f2
    close $f1
    file size $path(test1)
} 387
test io-29.11 {Tcl_WriteChars, no newline, implicit flush} {
    file delete $path(test1)
    set f1 [open $path(test1) w]
    fconfigure $f1 -eofchar {}
    set f2 [open $path(longfile) r]
    for {set x 0} {$x < 10} {incr x} {
	puts -nonewline $f1 [gets $f2]
    }
    close $f1
    close $f2
    file size $path(test1)
} 377
test io-29.12 {Tcl_WriteChars on a pipe} {stdio openpipe} {
    file delete $path(test1)
    file delete $path(pipe)
    set f1 [open $path(pipe) w]
    puts $f1 "set f1 \[[list open $path(longfile) r]]"
    puts $f1 {
	for {set x 0} {$x < 10} {incr x} {
	    puts [gets $f1]
	}
    }
    close $f1
    set f1 [open "|[list [interpreter] $path(pipe)]" r]
    set f2 [open $path(longfile) r]
    set y ok
    for {set x 0} {$x < 10} {incr x} {
	set l1 [gets $f1]
	set l2 [gets $f2]
	if {"$l1" != "$l2"} {
	    set y broken
	}
    }
    close $f1
    close $f2
    set y
} ok
test io-29.13 {Tcl_WriteChars to a pipe, line buffered} {stdio openpipe} {
    file delete $path(test1)
    file delete $path(pipe)
    set f1 [open $path(pipe) w]
    puts $f1 {
	puts [gets stdin]
	puts [gets stdin]
    }
    close $f1
    set y ok
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
    fconfigure $f1 -buffering line
    set f2 [open $path(longfile) r]
    set line [gets $f2]
    puts $f1 $line
    set backline [gets $f1]
    if {"$line" != "$backline"} {
	set y broken
    }
    set line [gets $f2]
    puts $f1 $line
    set backline [gets $f1]
    if {"$line" != "$backline"} {
	set y broken
    }
    close $f1
    close $f2
    set y
} ok
test io-29.14 {Tcl_WriteChars, buffering and implicit flush at close} {
    file delete $path(test3)
    set f [open $path(test3) w]
    puts -nonewline $f "Text1"
    puts -nonewline $f " Text 2"
    puts $f " Text 3"
    close $f
    set f [open $path(test3) r]
    set x [gets $f]
    close $f
    set x
} {Text1 Text 2 Text 3}
test io-29.15 {Tcl_Flush, channel not open for writing} {
    file delete $path(test1)
    set fd [open $path(test1) w]
    close $fd
    set fd [open $path(test1) r]
    set x [list [catch {flush $fd} msg] $msg]
    close $fd
    string compare $x \
	[list 1 "channel \"$fd\" wasn't opened for writing"]
} 0
test io-29.16 {Tcl_Flush on pipe opened only for reading} {stdio openpipe} {
    set fd [open "|[list [interpreter] cat longfile]" r]
    set x [list [catch {flush $fd} msg] $msg]
    catch {close $fd}
    string compare $x \
	[list 1 "channel \"$fd\" wasn't opened for writing"]
} 0
test io-29.17 {Tcl_WriteChars buffers, then Tcl_Flush flushes} {
    file delete $path(test1)
    set f1 [open $path(test1) w]
    fconfigure $f1 -translation lf
    puts $f1 hello
    puts $f1 hello
    puts $f1 hello
    flush $f1
    set x [file size $path(test1)]
    close $f1
    set x
} 18
test io-29.18 {Tcl_WriteChars and Tcl_Flush intermixed} {
    file delete $path(test1)
    set x ""
    set f1 [open $path(test1) w]
    fconfigure $f1 -translation lf
    puts $f1 hello
    puts $f1 hello
    puts $f1 hello
    flush $f1
    lappend x [file size $path(test1)]
    puts $f1 hello
    flush $f1
    lappend x [file size $path(test1)]
    puts $f1 hello
    flush $f1
    lappend x [file size $path(test1)]
    close $f1
    set x
} {18 24 30}
test io-29.19 {Explicit and implicit flushes} {
    file delete $path(test1)
    set f1 [open $path(test1) w]
    fconfigure $f1 -translation lf -eofchar {}
    set x ""
    puts $f1 hello
    puts $f1 hello
    puts $f1 hello
    flush $f1
    lappend x [file size $path(test1)]
    puts $f1 hello
    flush $f1
    lappend x [file size $path(test1)]
    puts $f1 hello
    close $f1
    lappend x [file size $path(test1)]
    set x
} {18 24 30}
test io-29.20 {Implicit flush when buffer is full} {
    file delete $path(test1)
    set f1 [open $path(test1) w]
    fconfigure $f1 -translation lf -eofchar {}
    set line "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    for {set x 0} {$x < 100} {incr x} {
      puts $f1 $line
    }
    set z ""
    lappend z [file size $path(test1)]
    for {set x 0} {$x < 100} {incr x} {
	puts $f1 $line
    }
    lappend z [file size $path(test1)]
    close $f1
    lappend z [file size $path(test1)]
    set z
} {4096 12288 12600}
test io-29.21 {Tcl_Flush to pipe} {stdio openpipe} {
    file delete $path(pipe)
    set f1 [open $path(pipe) w]
    puts $f1 {set x [read stdin 6]}
    puts $f1 {set cnt [string length $x]}
    puts $f1 {puts "read $cnt characters"}
    close $f1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
    puts $f1 hello
    flush $f1
    set x [gets $f1]
    catch {close $f1}
    set x
} "read 6 characters"
test io-29.22 {Tcl_Flush called at other end of pipe} {stdio openpipe} {
    file delete $path(pipe)
    set f1 [open $path(pipe) w]
    puts $f1 {
	fconfigure stdout -buffering full
	puts hello
	puts hello
	flush stdout
	gets stdin
	puts bye
	flush stdout
    }
    close $f1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
    set x ""
    lappend x [gets $f1]
    lappend x [gets $f1]
    puts $f1 hello
    flush $f1
    lappend x [gets $f1]
    close $f1
    set x
} {hello hello bye}
test io-29.23 {Tcl_Flush and line buffering at end of pipe} {stdio openpipe} {
    file delete $path(pipe)
    set f1 [open $path(pipe) w]
    puts $f1 {
	puts hello
	puts hello
	gets stdin
	puts bye
    }
    close $f1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
    set x ""
    lappend x [gets $f1]
    lappend x [gets $f1]
    puts $f1 hello
    flush $f1
    lappend x [gets $f1]
    close $f1
    set x
} {hello hello bye}
test io-29.24 {Tcl_WriteChars and Tcl_Flush move end of file} {
    set f [open $path(test3) w]
    puts $f "Line 1"
    puts $f "Line 2"
    set f2 [open $path(test3)]
    set x {}
    lappend x [read -nonewline $f2]
    close $f2
    flush $f
    set f2 [open $path(test3)]
    lappend x [read -nonewline $f2]
    close $f2
    close $f
    set x
} "{} {Line 1\nLine 2}"
test io-29.25 {Implicit flush with Tcl_Flush to command pipelines} {stdio openpipe fileevent} {
    file delete $path(test3)
    set f [open "|[list [interpreter] $path(cat) | [interpreter] $path(cat) > $path(test3)]" w]
    puts $f "Line 1"
    puts $f "Line 2"
    close $f
    after 100
    set f [open $path(test3) r]
    set x [read $f]
    close $f
    set x
} "Line 1\nLine 2\n"
test io-29.26 {Tcl_Flush, Tcl_Write on bidirectional pipelines} {stdio unixExecs openpipe} {
    set f [open "|[list cat -u]" r+]
    puts $f "Line1"
    flush $f
    set x [gets $f]
    close $f
    set x
} {Line1}
test io-29.27 {Tcl_Flush on closed pipeline} {stdio openpipe} {
    file delete $path(pipe)
    set f [open $path(pipe) w]
    puts $f {exit}
    close $f
    set f [open "|[list [interpreter] $path(pipe)]" r+]
    gets $f
    puts $f output
    after 50
    #
    # The flush below will get a SIGPIPE. This is an expected part of
    # test and indicates that the test operates correctly. If you run
    # this test under a debugger, the signal will by intercepted unless
    # you disable the debugger's signal interception.
    #
    if {[catch {flush $f} msg]} {
	set x [list 1 $msg $errorCode]
	catch {close $f}
    } else {
	if {[catch {close $f} msg]} {
	    set x [list 1 $msg $errorCode]
	} else {
	    set x {this was supposed to fail and did not}
	}
    }
    regsub {".*":} $x {"":} x
    string tolower $x
} {1 {error flushing "": broken pipe} {posix epipe {broken pipe}}}
test io-29.28 {Tcl_WriteChars, lf mode} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf -eofchar {}
    puts $f hello\nthere\nand\nhere
    flush $f
    set s [file size $path(test1)]
    close $f
    set s
} 21
test io-29.29 {Tcl_WriteChars, cr mode} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation cr -eofchar {}
    puts $f hello\nthere\nand\nhere
    close $f
    file size $path(test1)
} 21
test io-29.30 {Tcl_WriteChars, crlf mode} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation crlf -eofchar {}
    puts $f hello\nthere\nand\nhere
    close $f
    file size $path(test1)
} 25
test io-29.31 {Tcl_WriteChars, background flush} {stdio openpipe} {
    file delete $path(pipe)
    file delete $path(output)
    set f [open $path(pipe) w]
    puts $f "set f \[[list open $path(output)  w]]"
    puts $f {fconfigure $f -translation lf}
    set x [list while {![eof stdin]}]
    set x "$x {"
    puts $f $x
    puts $f {  puts -nonewline $f [read stdin 4096]}
    puts $f {  flush $f}
    puts $f "}"
    puts $f {close $f}
    close $f
    set x 01234567890123456789012345678901
    for {set i 0} {$i < 11} {incr i} {
	set x "$x$x"
    }
    set f [open $path(output) w]
    close $f
    set f [open "|[list [interpreter] $path(pipe)]" r+]
    fconfigure $f -blocking off
    puts -nonewline $f $x
    close $f
    set counter 0
    while {([file size $path(output)] < 65536) && ($counter < 1000)} {
	incr counter
	after 5
	update
    }
    if {$counter == 1000} {
	set result "file size only [file size $path(output)]"
    } else {
	set result ok
    }
} ok
test io-29.32 {Tcl_WriteChars, background flush to slow reader} \
	{stdio asyncPipeClose openpipe} {
    file delete $path(pipe)
    file delete $path(output)
    set f [open $path(pipe) w]
    puts $f "set f \[[list open $path(output) w]]"
    puts $f {fconfigure $f -translation lf}
    set x [list while {![eof stdin]}]
    set x "$x \{"
    puts $f $x
    puts $f {  after 20}
    puts $f {  puts -nonewline $f [read stdin 1024]}
    puts $f {  flush $f}
    puts $f "\}"
    puts $f {close $f}
    close $f
    set x 01234567890123456789012345678901
    for {set i 0} {$i < 11} {incr i} {
	set x "$x$x"
    }
    set f [open $path(output) w]
    close $f
    set f [open "|[list [interpreter] $path(pipe)]" r+]
    fconfigure $f -blocking off
    puts -nonewline $f $x
    close $f
    set counter 0
    while {([file size $path(output)] < 65536) && ($counter < 1000)} {
	incr counter
	after 20
	update
    }
    if {$counter == 1000} {
	set result "file size only [file size $path(output)]"
    } else {
	set result ok
    }
} ok
test io-29.33 {Tcl_Flush, implicit flush on exit} {exec} {
    set f [open $path(script) w]
    puts $f "set f \[[list open $path(test1) w]]"
    puts $f {fconfigure $f -translation lf
	puts $f hello
	puts $f bye
	puts $f strange
    }
    close $f
    exec [interpreter] $path(script)
    set f [open $path(test1) r]
    set r [read $f]
    close $f
    set r
} "hello\nbye\nstrange\n"
test io-29.34 {Tcl_Close, async flush on close, using sockets} {socket tempNotMac fileevent} {
    set c 0
    variable x running
    set l abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz
    proc writelots {s l} {
	for {set i 0} {$i < 2000} {incr i} {
	    puts $s $l
	}
    }
    proc accept {s a p} {
	variable x
	fileevent $s readable [namespace code [list readit $s]]
	fconfigure $s -blocking off
	set x accepted
    }
    proc readit {s} {
	variable c
	variable x
	set l [gets $s]
	
	if {[eof $s]} {
	    close $s
	    set x done
	} elseif {([string length $l] > 0) || ![fblocked $s]} {
	    incr c
	}
    }
    set ss [socket -server [namespace code accept] 0]
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    vwait [namespace which -variable x]
    fconfigure $cs -blocking off
    writelots $cs $l
    close $cs
    close $ss
    vwait [namespace which -variable x]
    set c
} 2000
test io-29.35 {Tcl_Close vs fileevent vs multiple interpreters} {socket tempNotMac fileevent} {
    # On Mac, this test screws up sockets such that subsequent tests using port 2828 
    # either cause errors or panic().
     
    catch {interp delete x}
    catch {interp delete y}
    interp create x
    interp create y
    set s [socket -server [namespace code accept] 0]
    proc accept {s a p} {
	puts $s hello
	close $s
    }
    set c [socket [info hostname] [lindex [fconfigure $s -sockname] 2]]
    interp share {} $c x
    interp share {} $c y
    close $c
    x eval {
	proc readit {s} {
	    gets $s
	    if {[eof $s]} {
		close $s
	    }
	}
    }
    y eval {
	proc readit {s} {
	    gets $s
	    if {[eof $s]} {
		close $s
	    }
	}
    }
    x eval "fileevent $c readable \{readit $c\}"
    y eval "fileevent $c readable \{readit $c\}"
    y eval [list close $c]
    update
    close $s
    interp delete x
    interp delete y
} ""

# Test end of line translations. Procedures tested are Tcl_Write, Tcl_Read.

test io-30.1 {Tcl_Write lf, Tcl_Read lf} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation lf
    set x [read $f]
    close $f
    set x
} "hello\nthere\nand\nhere\n"
test io-30.2 {Tcl_Write lf, Tcl_Read cr} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation cr
    set x [read $f]
    close $f
    set x
} "hello\nthere\nand\nhere\n"
test io-30.3 {Tcl_Write lf, Tcl_Read crlf} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation crlf
    set x [read $f]
    close $f
    set x
} "hello\nthere\nand\nhere\n"
test io-30.4 {Tcl_Write cr, Tcl_Read cr} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation cr
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation cr
    set x [read $f]
    close $f
    set x
} "hello\nthere\nand\nhere\n"
test io-30.5 {Tcl_Write cr, Tcl_Read lf} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation cr
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation lf
    set x [read $f]
    close $f
    set x
} "hello\rthere\rand\rhere\r"
test io-30.6 {Tcl_Write cr, Tcl_Read crlf} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation cr
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation crlf
    set x [read $f]
    close $f
    set x 
} "hello\rthere\rand\rhere\r"
test io-30.7 {Tcl_Write crlf, Tcl_Read crlf} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation crlf
    set x [read $f]
    close $f
    set x
} "hello\nthere\nand\nhere\n"
test io-30.8 {Tcl_Write crlf, Tcl_Read lf} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation lf
    set x [read $f]
    close $f
    set x
} "hello\r\nthere\r\nand\r\nhere\r\n"
test io-30.9 {Tcl_Write crlf, Tcl_Read cr} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation cr
    set x [read $f]
    close $f
    set x
} "hello\n\nthere\n\nand\n\nhere\n\n"
test io-30.10 {Tcl_Write lf, Tcl_Read auto} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    set c [read $f]
    set x [fconfigure $f -translation]
    close $f
    list $c $x
} {{hello
there
and
here
} auto}
test io-30.11 {Tcl_Write cr, Tcl_Read auto} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation cr
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    set c [read $f]
    set x [fconfigure $f -translation]
    close $f
    list $c $x
} {{hello
there
and
here
} auto}
test io-30.12 {Tcl_Write crlf, Tcl_Read auto} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    set c [read $f]
    set x [fconfigure $f -translation]
    close $f
    list $c $x
} {{hello
there
and
here
} auto}

test io-30.13 {Tcl_Write crlf on block boundary, Tcl_Read auto} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    set line "123456789ABCDE"	;# 14 char plus crlf
    puts -nonewline $f x	;# shift crlf across block boundary
    for {set i 0} {$i < 700} {incr i} {
	puts $f $line
    }
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation auto
    set c [read $f]
    close $f
    string length $c
} [expr 700*15+1]

test io-30.14 {Tcl_Write crlf on block boundary, Tcl_Read crlf} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    set line "123456789ABCDE"	;# 14 char plus crlf
    puts -nonewline $f x	;# shift crlf across block boundary
    for {set i 0} {$i < 700} {incr i} {
	puts $f $line
    }
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation crlf
    set c [read $f]
    close $f
    string length $c
} [expr 700*15+1]

test io-30.15 {Tcl_Write mixed, Tcl_Read auto} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts $f hello\nthere\nand\rhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation auto
    set c [read $f]
    close $f
    set c
} {hello
there
and
here
}
test io-30.16 {Tcl_Write ^Z at end, Tcl_Read auto} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f hello\nthere\nand\rhere\n\x1a
    close $f
    set f [open $path(test1) r]
    fconfigure $f -eofchar \x1a -translation auto
    set c [read $f]
    close $f
    set c
} {hello
there
and
here
}
test io-30.17 {Tcl_Write, implicit ^Z at end, Tcl_Read auto} {pcOnly} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -eofchar \x1a -translation lf
    puts $f hello\nthere\nand\rhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -eofchar \x1a -translation auto
    set c [read $f]
    close $f
    set c
} {hello
there
and
here
}
test io-30.18 {Tcl_Write, ^Z in middle, Tcl_Read auto} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    set s [format "abc\ndef\n%cghi\nqrs" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -eofchar \x1a -translation auto
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {abc def 0 {} 1 {} 1}
test io-30.19 {Tcl_Write, ^Z no newline in middle, Tcl_Read auto} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    set s [format "abc\ndef\n%cghi\nqrs" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -eofchar \x1a -translation auto
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {abc def 0 {} 1 {} 1}
test io-30.20 {Tcl_Write, ^Z in middle ignored, Tcl_Read lf} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf -eofchar {}
    set s [format "abc\ndef\n%cghi\nqrs" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation lf -eofchar {}
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} "abc def 0 \x1aghi 0 qrs 0 {} 1"
test io-30.21 {Tcl_Write, ^Z in middle ignored, Tcl_Read cr} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf -eofchar {}
    set s [format "abc\ndef\n%cghi\nqrs" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation cr -eofchar {}
    set l ""
    set x [gets $f]
    lappend l [string compare $x "abc\ndef\n\x1aghi\nqrs\n"]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {0 1 {} 1}
test io-30.22 {Tcl_Write, ^Z in middle ignored, Tcl_Read crlf} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf -eofchar {}
    set s [format "abc\ndef\n%cghi\nqrs" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation crlf -eofchar {}
    set l ""
    set x [gets $f]
    lappend l [string compare $x "abc\ndef\n\x1aghi\nqrs\n"]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {0 1 {} 1}
test io-30.23 {Tcl_Write lf, ^Z in middle, Tcl_Read auto} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    set c [format abc\ndef\n%cqrs\ntuv 26]
    puts $f $c
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation auto -eofchar \x1a
    set c [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $e
} {8 1}
test io-30.24 {Tcl_Write lf, ^Z in middle, Tcl_Read lf} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    set c [format abc\ndef\n%cqrs\ntuv 26]
    puts $f $c
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation lf -eofchar \x1a
    set c [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $e
} {8 1}
test io-30.25 {Tcl_Write cr, ^Z in middle, Tcl_Read auto} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation cr
    set c [format abc\ndef\n%cqrs\ntuv 26]
    puts $f $c
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation auto -eofchar \x1a
    set c [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $e
} {8 1}
test io-30.26 {Tcl_Write cr, ^Z in middle, Tcl_Read cr} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation cr
    set c [format abc\ndef\n%cqrs\ntuv 26]
    puts $f $c
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation cr -eofchar \x1a
    set c [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $e
} {8 1}
test io-30.27 {Tcl_Write crlf, ^Z in middle, Tcl_Read auto} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    set c [format abc\ndef\n%cqrs\ntuv 26]
    puts $f $c
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation auto -eofchar \x1a
    set c [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $e
} {8 1}
test io-30.28 {Tcl_Write crlf, ^Z in middle, Tcl_Read crlf} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    set c [format abc\ndef\n%cqrs\ntuv 26]
    puts $f $c
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation crlf -eofchar \x1a
    set c [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $e
} {8 1}

# Test end of line translations. Functions tested are Tcl_Write and Tcl_Gets.

test io-31.1 {Tcl_Write lf, Tcl_Gets auto} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    set l ""
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    close $f
    set l
} {hello 6 auto there 12 auto}
test io-31.2 {Tcl_Write cr, Tcl_Gets auto} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation cr
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    set l ""
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    close $f
    set l
} {hello 6 auto there 12 auto}
test io-31.3 {Tcl_Write crlf, Tcl_Gets auto} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    set l ""
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    close $f
    set l
} {hello 7 auto there 14 auto}
test io-31.4 {Tcl_Write lf, Tcl_Gets lf} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation lf
    set l ""
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    close $f
    set l
} {hello 6 lf there 12 lf}
test io-31.5 {Tcl_Write lf, Tcl_Gets cr} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation cr
    set l ""
    lappend l [string length [gets $f]]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    close $f
    set l
} {21 21 cr 1 {} 21 cr 1}
test io-31.6 {Tcl_Write lf, Tcl_Gets crlf} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation crlf
    set l ""
    lappend l [string length [gets $f]]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    close $f
    set l
} {21 21 crlf 1 {} 21 crlf 1}
test io-31.7 {Tcl_Write cr, Tcl_Gets cr} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation cr
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation cr
    set l ""
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    close $f
    set l
} {hello 6 cr 0 there 12 cr 0}
test io-31.8 {Tcl_Write cr, Tcl_Gets lf} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation cr
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation lf
    set l ""
    lappend l [string length [gets $f]]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    close $f
    set l
} {21 21 lf 1 {} 21 lf 1}
test io-31.9 {Tcl_Write cr, Tcl_Gets crlf} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation cr
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation crlf
    set l ""
    lappend l [string length [gets $f]]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    close $f
    set l
} {21 21 crlf 1 {} 21 crlf 1}
test io-31.10 {Tcl_Write crlf, Tcl_Gets crlf} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation crlf
    set l ""
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    close $f
    set l
} {hello 7 crlf 0 there 14 crlf 0}
test io-31.11 {Tcl_Write crlf, Tcl_Gets cr} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation cr
    set l ""
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    lappend l [string length [gets $f]]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    close $f
    set l
} {hello 6 cr 0 6 13 cr 0}
test io-31.12 {Tcl_Write crlf, Tcl_Gets lf} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation lf
    set l ""
    lappend l [string length [gets $f]]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    lappend l [string length [gets $f]]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    close $f
    set l
} {6 7 lf 0 6 14 lf 0}
test io-31.13 {binary mode is synonym of lf mode} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation binary
    set x [fconfigure $f -translation]
    close $f
    set x
} lf
#
# Test io-9.14 has been removed because "auto" output translation mode is
# not supoprted.
#
test io-31.14 {Tcl_Write mixed, Tcl_Gets auto} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts $f hello\nthere\rand\r\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation auto
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {hello there and here 0 {} 1}
test io-31.15 {Tcl_Write mixed, Tcl_Gets auto} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f hello\nthere\rand\r\nhere\r
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation auto
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {hello there and here 0 {} 1}
test io-31.16 {Tcl_Write mixed, Tcl_Gets auto} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f hello\nthere\rand\r\nhere\n
    close $f
    set f [open $path(test1) r]
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {hello there and here 0 {} 1}
test io-31.17 {Tcl_Write mixed, Tcl_Gets auto} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f hello\nthere\rand\r\nhere\r\n
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation auto
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {hello there and here 0 {} 1}
test io-31.18 {Tcl_Write ^Z at end, Tcl_Gets auto} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    set s [format "hello\nthere\nand\rhere\n\%c" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -eofchar \x1a -translation auto
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {hello there and here 0 {} 1}
test io-31.19 {Tcl_Write, implicit ^Z at end, Tcl_Gets auto} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -eofchar \x1a -translation lf
    puts $f hello\nthere\nand\rhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -eofchar \x1a -translation auto
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {hello there and here 0 {} 1}
test io-31.20 {Tcl_Write, ^Z in middle, Tcl_Gets auto, eofChar} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -eofchar \x1a
    fconfigure $f -translation auto
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {abc def 0 {} 1}
test io-31.21 {Tcl_Write, no newline ^Z in middle, Tcl_Gets auto, eofChar} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -eofchar \x1a -translation auto
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {abc def 0 {} 1}
test io-31.22 {Tcl_Write, ^Z in middle ignored, Tcl_Gets lf} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf -eofchar {}
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation lf -eofchar {}
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} "abc def 0 \x1aqrs 0 tuv 0 {} 1"
test io-31.23 {Tcl_Write, ^Z in middle ignored, Tcl_Gets cr} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation cr -eofchar {}
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation cr -eofchar {}
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} "abc def 0 \x1aqrs 0 tuv 0 {} 1"
test io-31.24 {Tcl_Write, ^Z in middle ignored, Tcl_Gets crlf} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation crlf -eofchar {}
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation crlf -eofchar {}
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} "abc def 0 \x1aqrs 0 tuv 0 {} 1"
test io-31.25 {Tcl_Write lf, ^Z in middle, Tcl_Gets auto} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation auto -eofchar \x1a
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {abc def 0 {} 1}
test io-31.26 {Tcl_Write lf, ^Z in middle, Tcl_Gets lf} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation lf -eofchar \x1a
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {abc def 0 {} 1}
test io-31.27 {Tcl_Write cr, ^Z in middle, Tcl_Gets auto} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation cr -eofchar {}
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation auto -eofchar \x1a
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {abc def 0 {} 1}
test io-31.28 {Tcl_Write cr, ^Z in middle, Tcl_Gets cr} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation cr -eofchar {}
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation cr -eofchar \x1a
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {abc def 0 {} 1}
test io-31.29 {Tcl_Write crlf, ^Z in middle, Tcl_Gets auto} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation crlf -eofchar {}
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation auto -eofchar \x1a
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {abc def 0 {} 1}
test io-31.30 {Tcl_Write crlf, ^Z in middle, Tcl_Gets crlf} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation crlf -eofchar {}
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation crlf -eofchar \x1a
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {abc def 0 {} 1}
test io-31.31 {Tcl_Write crlf on block boundary, Tcl_Gets crlf} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    set line "123456789ABCDE"	;# 14 char plus crlf
    puts -nonewline $f x	;# shift crlf across block boundary
    for {set i 0} {$i < 700} {incr i} {
	puts $f $line
    }
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation crlf 
    set c ""
    while {[gets $f line] >= 0} {
	append c $line\n
    }
    close $f
    string length $c
} [expr 700*15+1]
test io-31.32 {Tcl_Write crlf on block boundary, Tcl_Gets auto} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    set line "123456789ABCDE"	;# 14 char plus crlf
    puts -nonewline $f x	;# shift crlf across block boundary
    for {set i 0} {$i < 700} {incr i} {
	puts $f $line
    }
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation auto
    set c ""
    while {[gets $f line] >= 0} {
	append c $line\n
    }
    close $f
    string length $c
} [expr 700*15+1]


# Test Tcl_Read and buffering.

test io-32.1 {Tcl_Read, channel not readable} {
    list [catch {read stdout} msg] $msg
} {1 {channel "stdout" wasn't opened for reading}}
test io-32.2 {Tcl_Read, zero byte count} {
    read stdin 0
} ""
test io-32.3 {Tcl_Read, negative byte count} {
    set f [open $path(longfile) r]
    set l [list [catch {read $f -1} msg] $msg]
    close $f
    set l
} {1 {bad argument "-1": should be "nonewline"}}
test io-32.4 {Tcl_Read, positive byte count} {
    set f [open $path(longfile) r]
    set x [read $f 1024]
    set s [string length $x]
    unset x
    close $f
    set s
} 1024
test io-32.5 {Tcl_Read, multiple buffers} {
    set f [open $path(longfile) r]
    fconfigure $f -buffersize 100
    set x [read $f 1024]
    set s [string length $x]
    unset x
    close $f
    set s
} 1024
test io-32.6 {Tcl_Read, very large read} {
    set f1 [open $path(longfile) r]
    set z [read $f1 1000000]
    close $f1
    set l [string length $z]
    set x ok
    set z [file size $path(longfile)]
    if {$z != $l} {
	set x broken
    }
    set x
} ok
test io-32.7 {Tcl_Read, nonblocking, file} {nonBlockFiles} {
    set f1 [open $path(longfile) r]
    fconfigure $f1 -blocking off
    set z [read $f1 20]
    close $f1
    set l [string length $z]
    set x ok
    if {$l != 20} {
	set x broken
    }
    set x
} ok
test io-32.8 {Tcl_Read, nonblocking, file} {nonBlockFiles} {
    set f1 [open $path(longfile) r]
    fconfigure $f1 -blocking off
    set z [read $f1 1000000]
    close $f1
    set x ok
    set l [string length $z]
    set z [file size $path(longfile)]
    if {$z != $l} {
	set x broken
    }
    set x
} ok
test io-32.9 {Tcl_Read, read to end of file} {
    set f1 [open $path(longfile) r]
    set z [read $f1]
    close $f1
    set l [string length $z]
    set x ok
    set z [file size $path(longfile)]
    if {$z != $l} {
	set x broken
    }
    set x
} ok
test io-32.10 {Tcl_Read from a pipe} {stdio openpipe} {
    file delete $path(pipe)
    set f1 [open $path(pipe) w]
    puts $f1 {puts [gets stdin]}
    close $f1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
    puts $f1 hello
    flush $f1
    set x [read $f1]
    close $f1
    set x
} "hello\n"
test io-32.11 {Tcl_Read from a pipe} {stdio openpipe} {
    file delete $path(pipe)
    set f1 [open $path(pipe) w]
    puts $f1 {puts [gets stdin]}
    puts $f1 {puts [gets stdin]}
    close $f1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
    puts $f1 hello
    flush $f1
    set x ""
    lappend x [read $f1 6]
    puts $f1 hello
    flush $f1
    lappend x [read $f1]
    close $f1
    set x
} {{hello
} {hello
}}
test io-32.12 {Tcl_Read, -nonewline} {
    file delete $path(test1)
    set f1 [open $path(test1) w]
    puts $f1 hello
    puts $f1 bye
    close $f1
    set f1 [open $path(test1) r]
    set c [read -nonewline $f1]
    close $f1
    set c
} {hello
bye}
test io-32.13 {Tcl_Read, -nonewline} {
    file delete $path(test1)
    set f1 [open $path(test1) w]
    puts $f1 hello
    puts $f1 bye
    close $f1
    set f1 [open $path(test1) r]
    set c [read -nonewline $f1]
    close $f1
    list [string length $c] $c
} {9 {hello
bye}}
test io-32.14 {Tcl_Read, reading in small chunks} {
    file delete $path(test1)
    set f [open $path(test1) w]
    puts $f "Two lines: this one"
    puts $f "and this one"
    close $f
    set f [open $path(test1)]
    set x [list [read $f 1] [read $f 2] [read $f]]
    close $f
    set x
} {T wo { lines: this one
and this one
}}
test io-32.15 {Tcl_Read, asking for more input than available} {
    file delete $path(test1)
    set f [open $path(test1) w]
    puts $f "Two lines: this one"
    puts $f "and this one"
    close $f
    set f [open $path(test1)]
    set x [read $f 100]
    close $f
    set x
} {Two lines: this one
and this one
}
test io-32.16 {Tcl_Read, read to end of file with -nonewline} {
    file delete $path(test1)
    set f [open $path(test1) w]
    puts $f "Two lines: this one"
    puts $f "and this one"
    close $f
    set f [open $path(test1)]
    set x [read -nonewline $f]
    close $f
    set x
} {Two lines: this one
and this one}

# Test Tcl_Gets.

test io-33.1 {Tcl_Gets, reading what was written} {
    file delete $path(test1)
    set f1 [open $path(test1) w]
    set y "first line"
    puts $f1 $y
    close $f1
    set f1 [open $path(test1) r]
    set x [gets $f1]
    set z ok
    if {"$x" != "$y"} {
	set z broken
    }
    close $f1
    set z
} ok
test io-33.2 {Tcl_Gets into variable} {
    set f1 [open $path(longfile) r]
    set c [gets $f1 x]
    set l [string length x]
    set z ok
    if {$l != $l} {
	set z broken
    }
    close $f1
    set z
} ok
test io-33.3 {Tcl_Gets from pipe} {stdio openpipe} {
    file delete $path(pipe)
    set f1 [open $path(pipe) w]
    puts $f1 {puts [gets stdin]}
    close $f1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
    puts $f1 hello
    flush $f1
    set x [gets $f1]
    close $f1
    set z ok
    if {"$x" != "hello"} {
	set z broken
    }
    set z
} ok
test io-33.4 {Tcl_Gets with long line} {
    file delete $path(test3)
    set f [open $path(test3) w]
    puts -nonewline $f "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    puts -nonewline $f "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    puts -nonewline $f "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    puts -nonewline $f "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    puts $f "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    close $f
    set f [open $path(test3)]
    set x [gets $f]
    close $f
    set x
} {abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ}
test io-33.5 {Tcl_Gets with long line} {
    set f [open $path(test3)]
    set x [gets $f y]
    close $f
    list $x $y
} {260 abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ}
test io-33.6 {Tcl_Gets and end of file} {
    file delete $path(test3)
    set f [open $path(test3) w]
    puts -nonewline $f "Test1\nTest2"
    close $f
    set f [open $path(test3)]
    set x {}
    set y {}
    lappend x [gets $f y] $y
    set y {}
    lappend x [gets $f y] $y
    set y {}
    lappend x [gets $f y] $y
    close $f
    set x
} {5 Test1 5 Test2 -1 {}}
test io-33.7 {Tcl_Gets and bad variable} {
    set f [open $path(test3) w]
    puts $f "Line 1"
    puts $f "Line 2"
    close $f
    catch {unset x}
    set x 24
    set f [open $path(test3) r]
    set result [list [catch {gets $f x(0)} msg] $msg]
    close $f
    set result
} {1 {can't set "x(0)": variable isn't array}}
test io-33.8 {Tcl_Gets, exercising double buffering} {
    set f [open $path(test3) w]
    fconfigure $f -translation lf -eofchar {}
    set x ""
    for {set y 0} {$y < 99} {incr y} {set x "a$x"}
    for {set y 0} {$y < 100} {incr y} {puts $f $x}
    close $f
    set f [open $path(test3) r]
    fconfigure $f -translation lf
    for {set y 0} {$y < 100} {incr y} {gets $f}
    close $f
    set y
} 100
test io-33.9 {Tcl_Gets, exercising double buffering} {
    set f [open $path(test3) w]
    fconfigure $f -translation lf -eofchar {}
    set x ""
    for {set y 0} {$y < 99} {incr y} {set x "a$x"}
    for {set y 0} {$y < 200} {incr y} {puts $f $x}
    close $f
    set f [open $path(test3) r]
    fconfigure $f -translation lf
    for {set y 0} {$y < 200} {incr y} {gets $f}
    close $f
    set y
} 200
test io-33.10 {Tcl_Gets, exercising double buffering} {
    set f [open $path(test3) w]
    fconfigure $f -translation lf -eofchar {}
    set x ""
    for {set y 0} {$y < 99} {incr y} {set x "a$x"}
    for {set y 0} {$y < 300} {incr y} {puts $f $x}
    close $f
    set f [open $path(test3) r]
    fconfigure $f -translation lf
    for {set y 0} {$y < 300} {incr y} {gets $f}
    close $f
    set y
} 300

# Test Tcl_Seek and Tcl_Tell.

test io-34.1 {Tcl_Seek to current position at start of file} {
    set f1 [open $path(longfile) r]
    seek $f1 0 current
    set c [tell $f1]
    close $f1
    set c
} 0
test io-34.2 {Tcl_Seek to offset from start} {
    file delete $path(test1)
    set f1 [open $path(test1) w]
    fconfigure $f1 -translation lf -eofchar {}
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    close $f1
    set f1 [open $path(test1) r]
    seek $f1 10 start
    set c [tell $f1]
    close $f1
    set c
} 10
test io-34.3 {Tcl_Seek to end of file} {
    file delete $path(test1)
    set f1 [open $path(test1) w]
    fconfigure $f1 -translation lf -eofchar {}
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    close $f1
    set f1 [open $path(test1) r]
    seek $f1 0 end
    set c [tell $f1]
    close $f1
    set c
} 54
test io-34.4 {Tcl_Seek to offset from end of file} {
    file delete $path(test1)
    set f1 [open $path(test1) w]
    fconfigure $f1 -translation lf -eofchar {}
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    close $f1
    set f1 [open $path(test1) r]
    seek $f1 -10 end
    set c [tell $f1]
    close $f1
    set c
} 44
test io-34.5 {Tcl_Seek to offset from current position} {
    file delete $path(test1)
    set f1 [open $path(test1) w]
    fconfigure $f1 -translation lf -eofchar {}
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    close $f1
    set f1 [open $path(test1) r]
    seek $f1 10 current
    seek $f1 10 current
    set c [tell $f1]
    close $f1
    set c
} 20
test io-34.6 {Tcl_Seek to offset from end of file} {
    file delete $path(test1)
    set f1 [open $path(test1) w]
    fconfigure $f1 -translation lf -eofchar {}
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    close $f1
    set f1 [open $path(test1) r]
    seek $f1 -10 end
    set c [tell $f1]
    set r [read $f1]
    close $f1
    list $c $r
} {44 {rstuvwxyz
}}
test io-34.7 {Tcl_Seek to offset from end of file, then to current position} {
    file delete $path(test1)
    set f1 [open $path(test1) w]
    fconfigure $f1 -translation lf -eofchar {}
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    close $f1
    set f1 [open $path(test1) r]
    seek $f1 -10 end
    set c1 [tell $f1]
    set r1 [read $f1 5]
    seek $f1 0 current
    set c2 [tell $f1]
    close $f1
    list $c1 $r1 $c2
} {44 rstuv 49}
test io-34.8 {Tcl_Seek on pipes: not supported} {stdio openpipe} {
    set f1 [open "|[list [interpreter]]" r+]
    set x [list [catch {seek $f1 0 current} msg] $msg]
    close $f1
    regsub {".*":} $x {"":} x
    string tolower $x
} {1 {error during seek on "": invalid argument}}
test io-34.9 {Tcl_Seek, testing buffered input flushing} {
    file delete $path(test3)
    set f [open $path(test3) w]
    fconfigure $f -eofchar {}
    puts -nonewline $f "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    close $f
    set f [open $path(test3) RDWR]
    set x [read $f 1]
    seek $f 3
    lappend x [read $f 1]
    seek $f 0 start
    lappend x [read $f 1]
    seek $f 10 current
    lappend x [read $f 1]
    seek $f -2 end
    lappend x [read $f 1]
    seek $f 50 end
    lappend x [read $f 1]
    seek $f 1
    lappend x [read $f 1]
    close $f
    set x
} {a d a l Y {} b}

set path(test3) [makeFile {} test3]

test io-34.10 {Tcl_Seek testing flushing of buffered input} {
    set f [open $path(test3) w]
    fconfigure $f -translation lf
    puts $f xyz\n123
    close $f
    set f [open $path(test3) r+]
    fconfigure $f -translation lf
    set x [gets $f]
    seek $f 0 current
    puts $f 456
    close $f
    list $x [viewFile test3]
} "xyz {xyz
456}"
test io-34.11 {Tcl_Seek testing flushing of buffered output} {
    set f [open $path(test3) w]
    puts $f xyz\n123
    close $f
    set f [open $path(test3) w+]
    puts $f xyzzy
    seek $f 2
    set x [gets $f]
    close $f
    list $x [viewFile test3]
} "zzy xyzzy"
test io-34.12 {Tcl_Seek testing combination of write, seek back and read} {
    set f [open $path(test3) w]
    fconfigure $f -translation lf -eofchar {}
    puts $f xyz\n123
    close $f
    set f [open $path(test3) a+]
    fconfigure $f -translation lf -eofchar {}
    puts $f xyzzy
    flush $f
    set x [tell $f]
    seek $f -4 cur
    set y [gets $f]
    close $f
    list $x [viewFile test3] $y
} {14 {xyz
123
xyzzy} zzy}
test io-34.13 {Tcl_Tell at start of file} {
    file delete $path(test1)
    set f1 [open $path(test1) w]
    set p [tell $f1]
    close $f1
    set p
} 0
test io-34.14 {Tcl_Tell after seek to end of file} {
    file delete $path(test1)
    set f1 [open $path(test1) w]
    fconfigure $f1 -translation lf -eofchar {}
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    close $f1
    set f1 [open $path(test1) r]
    seek $f1 0 end
    set c1 [tell $f1]
    close $f1
    set c1
} 54
test io-34.15 {Tcl_Tell combined with seeking} {
    file delete $path(test1)
    set f1 [open $path(test1) w]
    fconfigure $f1 -translation lf -eofchar {}
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    close $f1
    set f1 [open $path(test1) r]
    seek $f1 10 start
    set c1 [tell $f1]
    seek $f1 10 current
    set c2 [tell $f1]
    close $f1
    list $c1 $c2
} {10 20}
test io-34.16 {Tcl_tell on pipe: always -1} {stdio openpipe} {
    set f1 [open "|[list [interpreter]]" r+]
    set c [tell $f1]
    close $f1
    set c
} -1
test io-34.17 {Tcl_Tell on pipe: always -1} {stdio openpipe} {
    set f1 [open "|[list [interpreter]]" r+]
    puts $f1 {puts hello}
    flush $f1
    set c [tell $f1]
    gets $f1
    close $f1
    set c
} -1
test io-34.18 {Tcl_Tell combined with seeking and reading} {
    file delete $path(test2)
    set f [open $path(test2) w]
    fconfigure $f -translation lf -eofchar {}
    puts -nonewline $f "line1\nline2\nline3\nline4\nline5\n"
    close $f
    set f [open $path(test2)]
    fconfigure $f -translation lf
    set x [tell $f]
    read $f 3
    lappend x [tell $f]
    seek $f 2
    lappend x [tell $f]
    seek $f 10 current
    lappend x [tell $f]
    seek $f 0 end
    lappend x [tell $f]
    close $f
    set x
} {0 3 2 12 30}
test io-34.19 {Tcl_Tell combined with opening in append mode} {
    set f [open $path(test3) w]
    fconfigure $f -translation lf -eofchar {}
    puts $f "abcdefghijklmnopqrstuvwxyz"
    puts $f "abcdefghijklmnopqrstuvwxyz"
    close $f
    set f [open $path(test3) a]
    set c [tell $f]
    close $f
    set c
} 54
test io-34.20 {Tcl_Tell combined with writing} {
    set f [open $path(test3) w]
    set l ""
    seek $f 29 start
    lappend l [tell $f]
    puts -nonewline $f a
    seek $f 39 start
    lappend l [tell $f]
    puts -nonewline $f a
    lappend l [tell $f]
    seek $f 407 end
    lappend l [tell $f]
    close $f
    set l
} {29 39 40 447}
test io-34.21 {Tcl_Seek and Tcl_Tell on large files} {largefileSupport} {
    file delete $path(test3)
    set f [open $path(test3) w]
    fconfigure $f -encoding binary
    set l ""
    lappend l [tell $f]
    puts -nonewline $f abcdef
    lappend l [tell $f]
    flush $f
    lappend l [tell $f]
    # 4GB offset!
    seek $f 0x100000000
    lappend l [tell $f]
    puts -nonewline $f abcdef
    lappend l [tell $f]
    close $f
    lappend l [file size $f]
    # truncate...
    close [open $path(test3) w]
    lappend l [file size $f]
    set l
} {0 6 6 4294967296 4294967302 4294967302 0}

# Test Tcl_Eof

test io-35.1 {Tcl_Eof} {
    file delete $path(test1)
    set f [open $path(test1) w]
    puts $f hello
    puts $f hello
    close $f
    set f [open $path(test1)]
    set x [eof $f]
    lappend x [eof $f]
    gets $f
    lappend x [eof $f]
    gets $f
    lappend x [eof $f]
    gets $f
    lappend x [eof $f]
    lappend x [eof $f]
    close $f
    set x
} {0 0 0 0 1 1}
test io-35.2 {Tcl_Eof with pipe} {stdio openpipe} {
    file delete $path(pipe)
    set f1 [open $path(pipe) w]
    puts $f1 {gets stdin}
    puts $f1 {puts hello}
    close $f1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
    puts $f1 hello
    set x [eof $f1]
    flush $f1
    lappend x [eof $f1]
    gets $f1
    lappend x [eof $f1]
    gets $f1
    lappend x [eof $f1]
    close $f1
    set x
} {0 0 0 1}
test io-35.3 {Tcl_Eof with pipe} {stdio openpipe} {
    file delete $path(pipe)
    set f1 [open $path(pipe) w]
    puts $f1 {gets stdin}
    puts $f1 {puts hello}
    close $f1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
    puts $f1 hello
    set x [eof $f1]
    flush $f1
    lappend x [eof $f1]
    gets $f1
    lappend x [eof $f1]
    gets $f1
    lappend x [eof $f1]
    gets $f1
    lappend x [eof $f1]
    gets $f1
    lappend x [eof $f1]
    close $f1
    set x
} {0 0 0 1 1 1}
test io-35.4 {Tcl_Eof, eof detection on nonblocking file} {nonBlockFiles} {
    file delete $path(test1)
    set f [open $path(test1) w]
    close $f
    set f [open $path(test1) r]
    fconfigure $f -blocking off
    set l ""
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {{} 1}
test io-35.5 {Tcl_Eof, eof detection on nonblocking pipe} {stdio openpipe} {
    file delete $path(pipe)
    set f [open $path(pipe) w]
    puts $f {
	exit
    }
    close $f
    set f [open "|[list [interpreter] $path(pipe)]" r]
    set l ""
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {{} 1}
test io-35.6 {Tcl_Eof, eof char, lf write, auto read} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf -eofchar \x1a
    puts $f abc\ndef
    close $f
    set s [file size $path(test1)]
    set f [open $path(test1) r]
    fconfigure $f -translation auto -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $s $l $e
} {9 8 1}
test io-35.7 {Tcl_Eof, eof char, lf write, lf read} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf -eofchar \x1a
    puts $f abc\ndef
    close $f
    set s [file size $path(test1)]
    set f [open $path(test1) r]
    fconfigure $f -translation lf -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $s $l $e
} {9 8 1}
test io-35.8 {Tcl_Eof, eof char, cr write, auto read} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation cr -eofchar \x1a
    puts $f abc\ndef
    close $f
    set s [file size $path(test1)]
    set f [open $path(test1) r]
    fconfigure $f -translation auto -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $s $l $e
} {9 8 1}
test io-35.9 {Tcl_Eof, eof char, cr write, cr read} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation cr -eofchar \x1a
    puts $f abc\ndef
    close $f
    set s [file size $path(test1)]
    set f [open $path(test1) r]
    fconfigure $f -translation cr -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $s $l $e
} {9 8 1}
test io-35.10 {Tcl_Eof, eof char, crlf write, auto read} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation crlf -eofchar \x1a
    puts $f abc\ndef
    close $f
    set s [file size $path(test1)]
    set f [open $path(test1) r]
    fconfigure $f -translation auto -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $s $l $e
} {11 8 1}
test io-35.11 {Tcl_Eof, eof char, crlf write, crlf read} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation crlf -eofchar \x1a
    puts $f abc\ndef
    close $f
    set s [file size $path(test1)]
    set f [open $path(test1) r]
    fconfigure $f -translation crlf -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $s $l $e
} {11 8 1}
test io-35.12 {Tcl_Eof, eof char in middle, lf write, auto read} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf -eofchar {}
    set i [format abc\ndef\n%cqrs\nuvw 26]
    puts $f $i
    close $f
    set c [file size $path(test1)]
    set f [open $path(test1) r]
    fconfigure $f -translation auto -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $l $e
} {17 8 1}
test io-35.13 {Tcl_Eof, eof char in middle, lf write, lf read} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf -eofchar {}
    set i [format abc\ndef\n%cqrs\nuvw 26]
    puts $f $i
    close $f
    set c [file size $path(test1)]
    set f [open $path(test1) r]
    fconfigure $f -translation lf -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $l $e
} {17 8 1}
test io-35.14 {Tcl_Eof, eof char in middle, cr write, auto read} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation cr -eofchar {}
    set i [format abc\ndef\n%cqrs\nuvw 26]
    puts $f $i
    close $f
    set c [file size $path(test1)]
    set f [open $path(test1) r]
    fconfigure $f -translation auto -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $l $e
} {17 8 1}
test io-35.15 {Tcl_Eof, eof char in middle, cr write, cr read} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation cr -eofchar {}
    set i [format abc\ndef\n%cqrs\nuvw 26]
    puts $f $i
    close $f
    set c [file size $path(test1)]
    set f [open $path(test1) r]
    fconfigure $f -translation cr -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $l $e
} {17 8 1}
test io-35.16 {Tcl_Eof, eof char in middle, crlf write, auto read} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation crlf -eofchar {}
    set i [format abc\ndef\n%cqrs\nuvw 26]
    puts $f $i
    close $f
    set c [file size $path(test1)]
    set f [open $path(test1) r]
    fconfigure $f -translation auto -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $l $e
} {21 8 1}
test io-35.17 {Tcl_Eof, eof char in middle, crlf write, crlf read} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation crlf -eofchar {}
    set i [format abc\ndef\n%cqrs\nuvw 26]
    puts $f $i
    close $f
    set c [file size $path(test1)]
    set f [open $path(test1) r]
    fconfigure $f -translation crlf -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $l $e
} {21 8 1}

# Test Tcl_InputBlocked

test io-36.1 {Tcl_InputBlocked on nonblocking pipe} {stdio openpipe} {
    set f1 [open "|[list [interpreter]]" r+]
    puts $f1 {puts hello_from_pipe}
    flush $f1
    gets $f1
    fconfigure $f1 -blocking off -buffering full
    puts $f1 {puts hello}
    set x ""
    lappend x [gets $f1]
    lappend x [fblocked $f1]
    flush $f1
    after 200
    lappend x [gets $f1]
    lappend x [fblocked $f1]
    lappend x [gets $f1]
    lappend x [fblocked $f1]
    close $f1
    set x
} {{} 1 hello 0 {} 1}
test io-36.2 {Tcl_InputBlocked on blocking pipe} {stdio openpipe} {
    set f1 [open "|[list [interpreter]]" r+]
    fconfigure $f1 -buffering line
    puts $f1 {puts hello_from_pipe}
    set x ""
    lappend x [gets $f1]
    lappend x [fblocked $f1]
    puts $f1 {exit}
    lappend x [gets $f1]
    lappend x [fblocked $f1]
    lappend x [eof $f1]
    close $f1
    set x
} {hello_from_pipe 0 {} 0 1}
test io-36.3 {Tcl_InputBlocked vs files, short read} {
    file delete $path(test1)
    set f [open $path(test1) w]
    puts $f abcdefghijklmnop
    close $f
    set f [open $path(test1) r]
    set l ""
    lappend l [fblocked $f]
    lappend l [read $f 3]
    lappend l [fblocked $f]
    lappend l [read -nonewline $f]
    lappend l [fblocked $f]
    lappend l [eof $f]
    close $f
    set l
} {0 abc 0 defghijklmnop 0 1}
test io-36.4 {Tcl_InputBlocked vs files, event driven read} {fileevent} {
    proc in {f} {
        variable l
        variable x
	lappend l [read $f 3]
	if {[eof $f]} {lappend l eof; close $f; set x done}
    }
    file delete $path(test1)
    set f [open $path(test1) w]
    puts $f abcdefghijklmnop
    close $f
    set f [open $path(test1) r]
    set l ""
    fileevent $f readable [namespace code [list in $f]]
    variable x
    vwait [namespace which -variable x]
    set l
} {abc def ghi jkl mno {p
} eof}
test io-36.5 {Tcl_InputBlocked vs files, short read, nonblocking} {nonBlockFiles} {
    file delete $path(test1)
    set f [open $path(test1) w]
    puts $f abcdefghijklmnop
    close $f
    set f [open $path(test1) r]
    fconfigure $f -blocking off
    set l ""
    lappend l [fblocked $f]
    lappend l [read $f 3]
    lappend l [fblocked $f]
    lappend l [read -nonewline $f]
    lappend l [fblocked $f]
    lappend l [eof $f]
    close $f
    set l
} {0 abc 0 defghijklmnop 0 1}
test io-36.6 {Tcl_InputBlocked vs files, event driven read} {nonBlockFiles fileevent} {
    proc in {f} {
        variable l
        variable x
	lappend l [read $f 3]
	if {[eof $f]} {lappend l eof; close $f; set x done}
    }
    file delete $path(test1)
    set f [open $path(test1) w]
    puts $f abcdefghijklmnop
    close $f
    set f [open $path(test1) r]
    fconfigure $f -blocking off
    set l ""
    fileevent $f readable [namespace code [list in $f]]
    variable x
    vwait [namespace which -variable x]
    set l
} {abc def ghi jkl mno {p
} eof}

# Test Tcl_InputBuffered

test io-37.1 {Tcl_InputBuffered} {testchannel} {
    set f [open $path(longfile) r]
    fconfigure $f -buffersize 4096
    read $f 3
    set l ""
    lappend l [testchannel inputbuffered $f]
    lappend l [tell $f]
    close $f
    set l
} {4093 3}
test io-37.2 {Tcl_InputBuffered, test input flushing on seek} {testchannel} {
    set f [open $path(longfile) r]
    fconfigure $f -buffersize 4096
    read $f 3
    set l ""
    lappend l [testchannel inputbuffered $f]
    lappend l [tell $f]
    seek $f 0 current
    lappend l [testchannel inputbuffered $f]
    lappend l [tell $f]
    close $f
    set l
} {4093 3 0 3}

# Test Tcl_SetChannelBufferSize, Tcl_GetChannelBufferSize

test io-38.1 {Tcl_GetChannelBufferSize, default buffer size} {
    set f [open $path(longfile) r]
    set s [fconfigure $f -buffersize]
    close $f
    set s
} 4096
test io-38.2 {Tcl_SetChannelBufferSize, Tcl_GetChannelBufferSize} {
    set f [open $path(longfile) r]
    set l ""
    lappend l [fconfigure $f -buffersize]
    fconfigure $f -buffersize 10000
    lappend l [fconfigure $f -buffersize]
    fconfigure $f -buffersize 1
    lappend l [fconfigure $f -buffersize]
    fconfigure $f -buffersize -1
    lappend l [fconfigure $f -buffersize]
    fconfigure $f -buffersize 0
    lappend l [fconfigure $f -buffersize]
    fconfigure $f -buffersize 100000
    lappend l [fconfigure $f -buffersize]
    fconfigure $f -buffersize 10000000
    lappend l [fconfigure $f -buffersize]
    close $f
    set l
} {4096 10000 4096 4096 4096 100000 4096}

test io-38.3 {Tcl_SetChannelBufferSize, changing buffersize between reads} {
    # This test crashes the interp if Bug #427196 is not fixed

    set chan [open [info script] r]
    fconfigure $chan -buffersize 10
    set var [read $chan 2]
    fconfigure $chan -buffersize 32
    append var [read $chan]
    close $chan
} {}

# Test Tcl_SetChannelOption, Tcl_GetChannelOption

test io-39.1 {Tcl_GetChannelOption} {
    file delete $path(test1)
    set f1 [open $path(test1) w]
    set x [fconfigure $f1 -blocking]
    close $f1
    set x
} 1
#
# Test 17.2 was removed.
#
test io-39.2 {Tcl_GetChannelOption} {
    file delete $path(test1)
    set f1 [open $path(test1) w]
    set x [fconfigure $f1 -buffering]
    close $f1
    set x
} full
test io-39.3 {Tcl_GetChannelOption} {
    file delete $path(test1)
    set f1 [open $path(test1) w]
    fconfigure $f1 -buffering line
    set x [fconfigure $f1 -buffering]
    close $f1
    set x
} line
test io-39.4 {Tcl_GetChannelOption, Tcl_SetChannelOption} {
    file delete $path(test1)
    set f1 [open $path(test1) w]
    set l ""
    lappend l [fconfigure $f1 -buffering]
    fconfigure $f1 -buffering line
    lappend l [fconfigure $f1 -buffering]
    fconfigure $f1 -buffering none
    lappend l [fconfigure $f1 -buffering]
    fconfigure $f1 -buffering line
    lappend l [fconfigure $f1 -buffering]
    fconfigure $f1 -buffering full
    lappend l [fconfigure $f1 -buffering]
    close $f1
    set l
} {full line none line full}
test io-39.5 {Tcl_GetChannelOption, invariance} {
    file delete $path(test1)
    set f1 [open $path(test1) w]
    set l ""
    lappend l [fconfigure $f1 -buffering]
    lappend l [list [catch {fconfigure $f1 -buffering green} msg] $msg]
    lappend l [fconfigure $f1 -buffering]
    close $f1
    set l
} {full {1 {bad value for -buffering: must be one of full, line, or none}} full}
test io-39.6 {Tcl_SetChannelOption, multiple options} {
    file delete $path(test1)
    set f1 [open $path(test1) w]
    fconfigure $f1 -translation lf -buffering line
    puts $f1 hello
    puts $f1 bye
    set x [file size $path(test1)]
    close $f1
    set x
} 10
test io-39.7 {Tcl_SetChannelOption, buffering, translation} {
    file delete $path(test1)
    set f1 [open $path(test1) w]
    fconfigure $f1 -translation lf
    puts $f1 hello
    puts $f1 bye
    set x ""
    fconfigure $f1 -buffering line
    lappend x [file size $path(test1)]
    puts $f1 really_bye
    lappend x [file size $path(test1)]
    close $f1
    set x
} {0 21}
test io-39.8 {Tcl_SetChannelOption, different buffering options} {
    file delete $path(test1)
    set f1 [open $path(test1) w]
    set l ""
    fconfigure $f1 -translation lf -buffering none -eofchar {}
    puts -nonewline $f1 hello
    lappend l [file size $path(test1)]
    puts -nonewline $f1 hello
    lappend l [file size $path(test1)]
    fconfigure $f1 -buffering full
    puts -nonewline $f1 hello
    lappend l [file size $path(test1)]
    fconfigure $f1 -buffering none
    lappend l [file size $path(test1)]
    puts -nonewline $f1 hello
    lappend l [file size $path(test1)]
    close $f1
    lappend l [file size $path(test1)]
    set l
} {5 10 10 10 20 20}
test io-39.9 {Tcl_SetChannelOption, blocking mode} {nonBlockFiles} {
    file delete $path(test1)
    set f1 [open $path(test1) w]
    close $f1
    set f1 [open $path(test1) r]
    set x ""
    lappend x [fconfigure $f1 -blocking]
    fconfigure $f1 -blocking off
    lappend x [fconfigure $f1 -blocking]
    lappend x [gets $f1]
    lappend x [read $f1 1000]
    lappend x [fblocked $f1]
    lappend x [eof $f1]
    close $f1
    set x
} {1 0 {} {} 0 1}
test io-39.10 {Tcl_SetChannelOption, blocking mode} {stdio openpipe} {
    file delete $path(pipe)
    set f1 [open $path(pipe) w]
    puts $f1 {
	gets stdin
	after 100
	puts hi
	gets stdin
    }
    close $f1
    set x ""
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
    fconfigure $f1 -blocking off -buffering line
    lappend x [fconfigure $f1 -blocking]
    lappend x [gets $f1]
    lappend x [fblocked $f1]
    fconfigure $f1 -blocking on
    puts $f1 hello
    fconfigure $f1 -blocking off
    lappend x [gets $f1]
    lappend x [fblocked $f1]
    fconfigure $f1 -blocking on
    puts $f1 bye
    fconfigure $f1 -blocking off
    lappend x [gets $f1]
    lappend x [fblocked $f1]
    fconfigure $f1 -blocking on
    lappend x [fconfigure $f1 -blocking]
    lappend x [gets $f1]
    lappend x [fblocked $f1]
    lappend x [eof $f1]
    lappend x [gets $f1]
    lappend x [eof $f1]
    close $f1
    set x
} {0 {} 1 {} 1 {} 1 1 hi 0 0 {} 1}
test io-39.11 {Tcl_SetChannelOption, Tcl_GetChannelOption, buffer size} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -buffersize -10
    set x [fconfigure $f -buffersize]
    close $f
    set x
} 4096
test io-39.12 {Tcl_SetChannelOption, Tcl_GetChannelOption buffer size} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -buffersize 10000000
    set x [fconfigure $f -buffersize]
    close $f
    set x
} 4096
test io-39.13 {Tcl_SetChannelOption, Tcl_GetChannelOption, buffer size} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -buffersize 40000
    set x [fconfigure $f -buffersize]
    close $f
    set x
} 40000
test io-39.14 {Tcl_SetChannelOption: -encoding, binary & utf-8} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -encoding {} 
    puts -nonewline $f \xe7\x89\xa6
    close $f
    set f [open $path(test1) r]
    fconfigure $f -encoding utf-8
    set x [read $f]
    close $f
    set x
} \u7266
test io-39.15 {Tcl_SetChannelOption: -encoding, binary & utf-8} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -encoding binary
    puts -nonewline $f \xe7\x89\xa6
    close $f
    set f [open $path(test1) r]
    fconfigure $f -encoding utf-8
    set x [read $f]
    close $f
    set x
} \u7266
test io-39.16 {Tcl_SetChannelOption: -encoding, errors} {
    file delete $path(test1)
    set f [open $path(test1) w]
    set result [list [catch {fconfigure $f -encoding foobar} msg] $msg]
    close $f
    set result
} {1 {unknown encoding "foobar"}}
test io-39.17 {Tcl_SetChannelOption: -encoding, clearing CHANNEL_NEED_MORE_DATA} {stdio openpipe fileevent} {
    set f [open "|[list [interpreter] $path(cat)]" r+]
    fconfigure $f -encoding binary
    puts -nonewline $f "\xe7"
    flush $f
    fconfigure $f -encoding utf-8 -blocking 0
    variable x {}
    fileevent $f readable [namespace code { lappend x [read $f] }]
    vwait [namespace which -variable x]
    after 300 [namespace code { lappend x timeout }]
    vwait [namespace which -variable x]
    fconfigure $f -encoding utf-8
    vwait [namespace which -variable x]
    after 300 [namespace code { lappend x timeout }]
    vwait [namespace which -variable x]
    fconfigure $f -encoding binary
    vwait [namespace which -variable x]
    after 300 [namespace code { lappend x timeout }]
    vwait [namespace which -variable x]
    close $f
    set x
} "{} timeout {} timeout \xe7 timeout"

test io-39.18 {Tcl_SetChannelOption, setting read mode independently} \
	{socket} {
    proc accept {s a p} {close $s}
    set s1 [socket -server [namespace code accept] 0]
    set port [lindex [fconfigure $s1 -sockname] 2]
    set s2 [socket 127.0.0.1 $port]
    update
    fconfigure $s2 -translation {auto lf}
    set modes [fconfigure $s2 -translation]
    close $s1
    close $s2
    set modes
} {auto lf}
test io-39.19 {Tcl_SetChannelOption, setting read mode independently} \
	{socket} {
    proc accept {s a p} {close $s}
    set s1 [socket -server [namespace code accept] 0]
    set port [lindex [fconfigure $s1 -sockname] 2]
    set s2 [socket 127.0.0.1 $port]
    update
    fconfigure $s2 -translation {auto crlf}
    set modes [fconfigure $s2 -translation]
    close $s1
    close $s2
    set modes
} {auto crlf}
test io-39.20 {Tcl_SetChannelOption, setting read mode independently} \
	{socket} {
    proc accept {s a p} {close $s}
    set s1 [socket -server [namespace code accept] 0]
    set port [lindex [fconfigure $s1 -sockname] 2]
    set s2 [socket 127.0.0.1 $port]
    update
    fconfigure $s2 -translation {auto cr}
    set modes [fconfigure $s2 -translation]
    close $s1
    close $s2
    set modes
} {auto cr}
test io-39.21 {Tcl_SetChannelOption, setting read mode independently} \
	{socket} {
    proc accept {s a p} {close $s}
    set s1 [socket -server [namespace code accept] 0]
    set port [lindex [fconfigure $s1 -sockname] 2]
    set s2 [socket 127.0.0.1 $port]
    update
    fconfigure $s2 -translation {auto auto}
    set modes [fconfigure $s2 -translation]
    close $s1
    close $s2
    set modes
} {auto crlf}

test io-39.22 {Tcl_SetChannelOption, invariance} {unixOnly} {
    file delete $path(test1)
    set f1 [open $path(test1) w+]
    set l ""
    lappend l [fconfigure $f1 -eofchar]
    fconfigure $f1 -eofchar {ON GO}
    lappend l [fconfigure $f1 -eofchar]
    fconfigure $f1 -eofchar D
    lappend l [fconfigure $f1 -eofchar]
    close $f1
    set l
} {{{} {}} {O G} {D D}}

test io-39.22a {Tcl_SetChannelOption, invariance} {
    file delete $path(test1)
    set f1 [open $path(test1) w+]
    set l [list]
    fconfigure $f1 -eofchar {ON GO}
    lappend l [fconfigure $f1 -eofchar]
    fconfigure $f1 -eofchar D
    lappend l [fconfigure $f1 -eofchar]
    lappend l [list [catch {fconfigure $f1 -eofchar {1 2 3}} msg] $msg]
    close $f1
    set l
} {{O G} {D D} {1 {bad value for -eofchar: should be a list of zero, one, or two elements}}}


test io-39.23 {Tcl_GetChannelOption, server socket is not readable or
        writeable, it should still have valid -eofchar and -translation options } {
    set l [list]
    set sock [socket -server [namespace code accept] 0]
    lappend l [fconfigure $sock -eofchar] [fconfigure $sock -translation]
    close $sock
    set l
} {{{}} auto}
test io-39.24 {Tcl_SetChannelOption, server socket is not readable or
        writable so we can't change -eofchar or -translation } {
    set l [list]
    set sock [socket -server [namespace code accept] 0]
    fconfigure $sock -eofchar D -translation lf
    lappend l [fconfigure $sock -eofchar] [fconfigure $sock -translation]
    close $sock
    set l
} {{{}} auto}

test io-40.1 {POSIX open access modes: RDWR} {
    file delete $path(test3)
    set f [open $path(test3) w]
    puts $f xyzzy
    close $f
    set f [open $path(test3) RDWR]
    puts -nonewline $f "ab"
    seek $f 0 current
    set x [gets $f]
    close $f
    set f [open $path(test3) r]
    lappend x [gets $f]
    close $f
    set x
} {zzy abzzy}
test io-40.2 {POSIX open access modes: CREAT} {unixOnly} {
    file delete $path(test3)
    set f [open $path(test3) {WRONLY CREAT} 0600]
    file stat $path(test3) stats
    set x [format "0%o" [expr $stats(mode)&0777]]
    puts $f "line 1"
    close $f
    set f [open $path(test3) r]
    lappend x [gets $f]
    close $f
    set x
} {0600 {line 1}}

# some tests can only be run is umask is 2
# if "umask" cannot be run, the tests will be skipped.
catch {testConstraint umask2 [expr {[exec umask] == 2}]}

test io-40.3 {POSIX open access modes: CREAT} {unixOnly umask2} {
    # This test only works if your umask is 2, like ouster's.
    file delete $path(test3)
    set f [open $path(test3) {WRONLY CREAT}]
    close $f
    file stat test3 stats
    format "0%o" [expr $stats(mode)&0777]
} 0664
test io-40.4 {POSIX open access modes: CREAT} {
    file delete $path(test3)
    set f [open $path(test3) w]
    fconfigure $f -eofchar {}
    puts $f xyzzy
    close $f
    set f [open $path(test3) {WRONLY CREAT}]
    fconfigure $f -eofchar {}
    puts -nonewline $f "ab"
    close $f
    set f [open $path(test3) r]
    set x [gets $f]
    close $f
    set x
} abzzy
test io-40.5 {POSIX open access modes: APPEND} {
    file delete $path(test3)
    set f [open $path(test3) w]
    fconfigure $f -translation lf -eofchar {}
    puts $f xyzzy
    close $f
    set f [open $path(test3) {WRONLY APPEND}]
    fconfigure $f -translation lf
    puts $f "new line"
    seek $f 0
    puts $f "abc"
    close $f
    set f [open $path(test3) r]
    fconfigure $f -translation lf
    set x ""
    seek $f 6 current
    lappend x [gets $f]
    lappend x [gets $f]
    close $f
    set x
} {{new line} abc}
test io-40.6 {POSIX open access modes: EXCL} -match regexp -body {
    file delete $path(test3)
    set f [open $path(test3) w]
    puts $f xyzzy
    close $f
    open $path(test3) {WRONLY CREAT EXCL}
} -returnCodes error -result {(?i)couldn't open ".*test3": file (already )?exists}
test io-40.7 {POSIX open access modes: EXCL} {
    file delete $path(test3)
    set f [open $path(test3) {WRONLY CREAT EXCL}]
    fconfigure $f -eofchar {}
    puts $f "A test line"
    close $f
    viewFile test3
} {A test line}
test io-40.8 {POSIX open access modes: TRUNC} {
    file delete $path(test3)
    set f [open $path(test3) w]
    puts $f xyzzy
    close $f
    set f [open $path(test3) {WRONLY TRUNC}]
    puts $f abc
    close $f
    set f [open $path(test3) r]
    set x [gets $f]
    close $f
    set x
} abc
test io-40.9 {POSIX open access modes: NONBLOCK} {nonPortable macOrUnix} {
    file delete $path(test3)
    set f [open $path(test3) {WRONLY NONBLOCK CREAT}]
    puts $f "NONBLOCK test"
    close $f
    set f [open $path(test3) r]
    set x [gets $f]
    close $f
    set x
} {NONBLOCK test}
test io-40.10 {POSIX open access modes: RDONLY} {
    set f [open $path(test1) w]
    puts $f "two lines: this one"
    puts $f "and this"
    close $f
    set f [open $path(test1) RDONLY]
    set x [list [gets $f] [catch {puts $f Test} msg] $msg]
    close $f
    string compare [string tolower $x] \
	[list {two lines: this one} 1 \
		[format "channel \"%s\" wasn't opened for writing" $f]]
} 0
test io-40.11 {POSIX open access modes: RDONLY} -match regexp -body {
    file delete $path(test3)
    open $path(test3) RDONLY
} -returnCodes error -result {(?i)couldn't open ".*test3": no such file or directory}
test io-40.12 {POSIX open access modes: WRONLY} -match regexp -body {
    file delete $path(test3)
    open $path(test3) WRONLY
} -returnCodes error -result {(?i)couldn't open ".*test3": no such file or directory}
test io-40.13 {POSIX open access modes: WRONLY} {
    makeFile xyzzy test3
    set f [open $path(test3) WRONLY]
    fconfigure $f -eofchar {}
    puts -nonewline $f "ab"
    seek $f 0 current
    set x [list [catch {gets $f} msg] $msg]
    close $f
    lappend x [viewFile test3]
    string compare [string tolower $x] \
	[list 1 "channel \"$f\" wasn't opened for reading" abzzy]
} 0
test io-40.14 {POSIX open access modes: RDWR} -match regexp -body {
    file delete $path(test3)
    open $path(test3) RDWR
} -returnCodes error -result {(?i)couldn't open ".*test3": no such file or directory}
test io-40.15 {POSIX open access modes: RDWR} {
    makeFile xyzzy test3
    set f [open $path(test3) RDWR]
    puts -nonewline $f "ab"
    seek $f 0 current
    set x [gets $f]
    close $f
    lappend x [viewFile test3]
} {zzy abzzy}
if {![file exists ~/_test_] && [file writable ~]} {
    test io-40.16 {tilde substitution in open} -setup {
	makeFile {Some text} _test_ ~
    } -body {
	file exists [file join $env(HOME) _test_]
    } -cleanup {
	removeFile _test_ ~
    } -result 1
}
test io-40.17 {tilde substitution in open} {
    set home $env(HOME)
    unset env(HOME)
    set x [list [catch {open ~/foo} msg] $msg]
    set env(HOME) $home
    set x
} {1 {couldn't find HOME environment variable to expand path}}

test io-41.1 {Tcl_FileeventCmd: errors} {fileevent} {
    list [catch {fileevent foo} msg] $msg
} {1 {wrong # args: should be "fileevent channelId event ?script?"}}
test io-41.2 {Tcl_FileeventCmd: errors} {fileevent} {
    list [catch {fileevent foo bar baz q} msg] $msg
} {1 {wrong # args: should be "fileevent channelId event ?script?"}}
test io-41.3 {Tcl_FileeventCmd: errors} {fileevent} {
    list [catch {fileevent gorp readable} msg] $msg
} {1 {can not find channel named "gorp"}}
test io-41.4 {Tcl_FileeventCmd: errors} {fileevent} {
    list [catch {fileevent gorp writable} msg] $msg
} {1 {can not find channel named "gorp"}}
test io-41.5 {Tcl_FileeventCmd: errors} {fileevent} {
    list [catch {fileevent gorp who-knows} msg] $msg
} {1 {bad event name "who-knows": must be readable or writable}}

#
# Test fileevent on a file
#

set path(foo) [makeFile {} foo]
set f [open $path(foo) w+]

test io-42.1 {Tcl_FileeventCmd: creating, deleting, querying} {fileevent} {
    list [fileevent $f readable] [fileevent $f writable]
} {{} {}}
test io-42.2 {Tcl_FileeventCmd: replacing} {fileevent} {
    set result {}
    fileevent $f r "first script"
    lappend result [fileevent $f readable]
    fileevent $f r "new script"
    lappend result [fileevent $f readable]
    fileevent $f r "yet another"
    lappend result [fileevent $f readable]
    fileevent $f r ""
    lappend result [fileevent $f readable]
} {{first script} {new script} {yet another} {}}
test io-42.3 {Tcl_FileeventCmd: replacing, with NULL chars in script} {fileevent} {
    set result {}
    fileevent $f r "first scr\0ipt"
    lappend result [string length [fileevent $f readable]]
    fileevent $f r "new scr\0ipt"
    lappend result [string length [fileevent $f readable]]
    fileevent $f r "yet ano\0ther"
    lappend result [string length [fileevent $f readable]]
    fileevent $f r ""
    lappend result [fileevent $f readable]
} {13 11 12 {}}

#
# Test fileevent on a pipe
#
if {[testConstraint openpipe]} {
catch {set f2 [open "|[list cat -u]" r+]}
catch {set f3 [open "|[list cat -u]" r+]}
}

test io-43.1 {Tcl_FileeventCmd: creating, deleting, querying} {stdio unixExecs fileevent} {
    set result {}
    fileevent $f readable "script 1"
    lappend result [fileevent $f readable] [fileevent $f writable]
    fileevent $f writable "write script"
    lappend result [fileevent $f readable] [fileevent $f writable]
    fileevent $f readable {}
    lappend result [fileevent $f readable] [fileevent $f writable]
    fileevent $f writable {}
    lappend result [fileevent $f readable] [fileevent $f writable]
} {{script 1} {} {script 1} {write script} {} {write script} {} {}}
test io-43.2 {Tcl_FileeventCmd: deleting when many present} {stdio unixExecs fileevent} {
    set result {}
    lappend result [fileevent $f r] [fileevent $f2 r] [fileevent $f3 r]
    fileevent $f r "read f"
    fileevent $f2 r "read f2"
    fileevent $f3 r "read f3"
    lappend result [fileevent $f r] [fileevent $f2 r] [fileevent $f3 r]
    fileevent $f2 r {}
    lappend result [fileevent $f r] [fileevent $f2 r] [fileevent $f3 r]
    fileevent $f3 r {}
    lappend result [fileevent $f r] [fileevent $f2 r] [fileevent $f3 r]
    fileevent $f r {}
    lappend result [fileevent $f r] [fileevent $f2 r] [fileevent $f3 r]
} {{} {} {} {read f} {read f2} {read f3} {read f} {} {read f3} {read f} {} {} {} {} {}}

test io-44.1 {FileEventProc procedure: normal read event} {stdio unixExecs fileevent} {
    fileevent $f2 readable [namespace code {
	set x [gets $f2]; fileevent $f2 readable {}
    }]
    puts $f2 text; flush $f2
    variable x initial
    vwait [namespace which -variable x]
    set x
} {text}
test io-44.2 {FileEventProc procedure: error in read event} {stdio unixExecs fileevent} {
    proc ::bgerror args "set [namespace which -variable x] \$args"
    fileevent $f2 readable {error bogus}
    puts $f2 text; flush $f2
    variable x initial
    vwait [namespace which -variable x]
    rename ::bgerror {}
    list $x [fileevent $f2 readable]
} {bogus {}}
test io-44.3 {FileEventProc procedure: normal write event} {stdio unixExecs fileevent} {
    fileevent $f2 writable [namespace code {
	lappend x "triggered"
	incr count -1
	if {$count <= 0} {
	    fileevent $f2 writable {}
	}
    }]
    variable x initial
    set count 3
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
    set x
} {initial triggered triggered triggered}
test io-44.4 {FileEventProc procedure: eror in write event} {stdio unixExecs fileevent} {
    proc ::bgerror args "set [namespace which -variable x] \$args"
    fileevent $f2 writable {error bad-write}
    variable x initial
    vwait [namespace which -variable x]
    rename ::bgerror {}
    list $x [fileevent $f2 writable]
} {bad-write {}}
test io-44.5 {FileEventProc procedure: end of file} {stdio unixExecs openpipe fileevent} {
    set f4 [open "|[list [interpreter] $path(cat) << foo]" r]
    fileevent $f4 readable [namespace code {
	if {[gets $f4 line] < 0} {
	    lappend x eof
	    fileevent $f4 readable {}
	} else {
	    lappend x $line
	}
    }]
    variable x initial
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
    close $f4
    set x
} {initial foo eof}

catch {close $f2}
catch {close $f3}


close $f
makeFile "foo bar" foo
test io-45.1 {DeleteFileEvent, cleanup on close} {fileevent} {
    set f [open $path(foo) r]
    fileevent $f readable [namespace code {
	lappend x "binding triggered: \"[gets $f]\""
	fileevent $f readable {}
    }]
    close $f
    set x initial
    after 100 [namespace code { set y done }]
    variable y
    vwait [namespace which -variable y]
    set x
} {initial}
test io-45.2 {DeleteFileEvent, cleanup on close} {fileevent} {
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    fileevent $f readable [namespace code {
	    lappend x "f triggered: \"[gets $f]\""
	    fileevent $f readable {}
	}]
    fileevent $f2 readable [namespace code {
	lappend x "f2 triggered: \"[gets $f2]\""
	fileevent $f2 readable {}
    }]
    close $f
    variable x initial
    vwait [namespace which -variable x]
    close $f2
    set x
} {initial {f2 triggered: "foo bar"}}
test io-45.3 {DeleteFileEvent, cleanup on close} {fileevent} {
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    set f3 [open $path(foo) r]
    fileevent $f readable {f script}
    fileevent $f2 readable {f2 script}
    fileevent $f3 readable {f3 script}
    set x {}
    close $f2
    lappend x [catch {fileevent $f readable} msg] $msg \
	    [catch {fileevent $f2 readable}] \
	    [catch {fileevent $f3 readable} msg] $msg
    close $f3
    lappend x [catch {fileevent $f readable} msg] $msg \
	    [catch {fileevent $f2 readable}] \
	    [catch {fileevent $f3 readable}]
    close $f
    lappend x [catch {fileevent $f readable}] \
	    [catch {fileevent $f2 readable}] \
	    [catch {fileevent $f3 readable}]
} {0 {f script} 1 0 {f3 script} 0 {f script} 1 1 1 1 1}

# Execute these tests only if the "testfevent" command is present.
testConstraint testfevent [llength [info commands testfevent]]

test io-46.1 {Tcl event loop vs multiple interpreters} {testfevent fileevent} {
    testfevent create
    set script "set f \[[list open $path(foo) r]]\n"
    append script {
	set x "no event"
	fileevent $f readable [namespace code {
	    set x "f triggered: [gets $f]"
	    fileevent $f readable {}
	}]
    }
    testfevent cmd $script
    after 1	;# We must delay because Windows takes a little time to notice
    update
    testfevent cmd {close $f}
    list [testfevent cmd {set x}] [testfevent cmd {info commands after}]
} {{f triggered: foo bar} after}
test io-46.2 {Tcl event loop vs multiple interpreters} testfevent {
    testfevent create
    testfevent cmd {
        variable x 0
        after 100 {set x triggered}
        vwait [namespace which -variable x]
        set x
    }
} {triggered}
test io-46.3 {Tcl event loop vs multiple interpreters} testfevent {
    testfevent create
    testfevent cmd {
        set x 0
        after 10 {lappend x timer}
        after 30
        set result $x
        update idletasks
        lappend result $x
        update
        lappend result $x
    }
} {0 0 {0 timer}}

test io-47.1 {fileevent vs multiple interpreters} {testfevent fileevent} {
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    set f3 [open $path(foo) r]
    fileevent $f readable {script 1}
    testfevent create
    testfevent share $f2
    testfevent cmd "fileevent $f2 readable {script 2}"
    fileevent $f3 readable {sript 3}
    set x {}
    lappend x [fileevent $f2 readable]
    testfevent delete
    lappend x [fileevent $f readable] [fileevent $f2 readable] \
        [fileevent $f3 readable]
    close $f
    close $f2
    close $f3
    set x
} {{} {script 1} {} {sript 3}}
test io-47.2 {deleting fileevent on interpreter delete} {testfevent fileevent} {
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    set f3 [open $path(foo) r]
    set f4 [open $path(foo) r]
    fileevent $f readable {script 1}
    testfevent create
    testfevent share $f2
    testfevent share $f3
    testfevent cmd "fileevent $f2 readable {script 2}
        fileevent $f3 readable {script 3}"
    fileevent $f4 readable {script 4}
    testfevent delete
    set x [list [fileevent $f readable] [fileevent $f2 readable] \
                [fileevent $f3 readable] [fileevent $f4 readable]]
    close $f
    close $f2
    close $f3
    close $f4
    set x
} {{script 1} {} {} {script 4}}
test io-47.3 {deleting fileevent on interpreter delete} {testfevent fileevent} {
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    set f3 [open $path(foo) r]
    set f4 [open $path(foo) r]
    testfevent create
    testfevent share $f3
    testfevent share $f4
    fileevent $f readable {script 1}
    fileevent $f2 readable {script 2}
    testfevent cmd "fileevent $f3 readable {script 3}
      fileevent $f4 readable {script 4}"
    testfevent delete
    set x [list [fileevent $f readable] [fileevent $f2 readable] \
                [fileevent $f3 readable] [fileevent $f4 readable]]
    close $f
    close $f2
    close $f3
    close $f4
    set x
} {{script 1} {script 2} {} {}}
test io-47.4 {file events on shared files and multiple interpreters} {testfevent fileevent} {
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    testfevent create
    testfevent share $f
    testfevent cmd "fileevent $f readable {script 1}"
    fileevent $f readable {script 2}
    fileevent $f2 readable {script 3}
    set x [list [fileevent $f2 readable] \
                [testfevent cmd "fileevent $f readable"] \
                [fileevent $f readable]]
    testfevent delete
    close $f
    close $f2
    set x
} {{script 3} {script 1} {script 2}}
test io-47.5 {file events on shared files, deleting file events} {testfevent fileevent} {
    set f [open $path(foo) r]
    testfevent create
    testfevent share $f
    testfevent cmd "fileevent $f readable {script 1}"
    fileevent $f readable {script 2}
    testfevent cmd "fileevent $f readable {}"
    set x [list [testfevent cmd "fileevent $f readable"] \
                [fileevent $f readable]]
    testfevent delete
    close $f
    set x
} {{} {script 2}}
test io-47.6 {file events on shared files, deleting file events} {testfevent fileevent} {
    set f [open $path(foo) r]
    testfevent create
    testfevent share $f
    testfevent cmd "fileevent $f readable {script 1}"
    fileevent $f readable {script 2}
    fileevent $f readable {}
    set x [list [testfevent cmd "fileevent $f readable"] \
                [fileevent $f readable]]
    testfevent delete
    close $f
    set x
} {{script 1} {}}

set path(bar) [makeFile {} bar]

test io-48.1 {testing readability conditions} {fileevent} {
    set f [open $path(bar) w]
    puts $f abcdefg
    puts $f abcdefg
    puts $f abcdefg
    puts $f abcdefg
    puts $f abcdefg
    close $f
    set f [open $path(bar) r]
    fileevent $f readable [namespace code [list consume $f]]
    proc consume {f} {
	variable l
	variable x
	lappend l called
	if {[eof $f]} {
	    close $f
	    set x done
	} else {
	    gets $f
	}
    }
    set l ""
    variable x not_done
    vwait [namespace which -variable x]
    list $x $l
} {done {called called called called called called called}}
test io-48.2 {testing readability conditions} {nonBlockFiles fileevent} {
    set f [open $path(bar) w]
    puts $f abcdefg
    puts $f abcdefg
    puts $f abcdefg
    puts $f abcdefg
    puts $f abcdefg
    close $f
    set f [open $path(bar) r]
    fileevent $f readable [namespace code [list consume $f]]
    fconfigure $f -blocking off
    proc consume {f} {
	variable x
	variable l
	lappend l called
	if {[eof $f]} {
	    close $f
	    set x done
	} else {
	    gets $f
	}
    }
    set l ""
    variable x not_done
    vwait [namespace which -variable x]
    list $x $l
} {done {called called called called called called called}}

set path(my_script) [makeFile {} my_script]

test io-48.3 {testing readability conditions} {stdio unixOnly nonBlockFiles openpipe fileevent} {
    set f [open $path(bar) w]
    puts $f abcdefg
    puts $f abcdefg
    puts $f abcdefg
    puts $f abcdefg
    puts $f abcdefg
    close $f
    set f [open $path(my_script) w]
    puts $f {
	proc copy_slowly {f} {
	    while {![eof $f]} {
		puts [gets $f]
		after 200
	    }
	    close $f
	}
    }
    close $f
    set f [open "|[list [interpreter]]" r+]
    fileevent  $f readable [namespace code [list consume $f]]
    fconfigure $f -buffering line
    fconfigure $f -blocking off
    proc consume {f} {
	variable l
	variable x
	if {[eof $f]} {
	    set x done
	} else {
	    gets $f
	    lappend l [fblocked $f]
	    gets $f
	    lappend l [fblocked $f]
	}
    }
    set l ""
    variable x not_done
    puts $f [list source $path(my_script)]
    puts $f "set f \[[list open $path(bar) r]]"
    puts $f {copy_slowly $f}
    puts $f {exit}
    vwait [namespace which -variable x]
    close $f
    list $x $l
} {done {0 1 0 1 0 1 0 1 0 1 0 1 0 0}}
test io-48.4 {lf write, testing readability, ^Z termination, auto read mode} {fileevent} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    set c [format "abc\ndef\n%c" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	variable l
	variable c
	variable x
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open $path(test1) r]
    fconfigure $f -translation auto -eofchar \x1a
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
    list $c $l
} {3 {abc def {}}}
test io-48.5 {lf write, testing readability, ^Z in middle, auto read mode} {fileevent} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    set c [format "abc\ndef\n%cfoo\nbar\n" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	variable l
	variable x
	variable c
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open $path(test1) r]
    fconfigure $f -eofchar \x1a -translation auto
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
    list $c $l
} {3 {abc def {}}}
test io-48.6 {cr write, testing readability, ^Z termination, auto read mode} {fileevent} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation cr
    set c [format "abc\ndef\n%c" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	variable l
	variable x
	variable c
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open $path(test1) r]
    fconfigure $f -translation auto -eofchar \x1a
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
    list $c $l
} {3 {abc def {}}}
test io-48.7 {cr write, testing readability, ^Z in middle, auto read mode} {fileevent} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation cr
    set c [format "abc\ndef\n%cfoo\nbar\n" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	variable l
	variable c
	variable x
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open $path(test1) r]
    fconfigure $f -eofchar \x1a -translation auto
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
    list $c $l
} {3 {abc def {}}}
test io-48.8 {crlf write, testing readability, ^Z termination, auto read mode} {fileevent} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    set c [format "abc\ndef\n%c" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	variable l
	variable x
	variable c
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open $path(test1) r]
    fconfigure $f -translation auto -eofchar \x1a
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
    list $c $l
} {3 {abc def {}}}
test io-48.9 {crlf write, testing readability, ^Z in middle, auto read mode} {fileevent} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    set c [format "abc\ndef\n%cfoo\nbar\n" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	variable l
	variable c
	variable x
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open $path(test1) r]
    fconfigure $f -eofchar \x1a -translation auto
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
    list $c $l
} {3 {abc def {}}}
test io-48.10 {lf write, testing readability, ^Z in middle, lf read mode} {fileevent} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    set c [format "abc\ndef\n%cfoo\nbar\n" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	variable l
	variable c
	variable x
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open $path(test1) r]
    fconfigure $f -eofchar \x1a -translation lf
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
    list $c $l
} {3 {abc def {}}}
test io-48.11 {lf write, testing readability, ^Z termination, lf read mode} {fileevent} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    set c [format "abc\ndef\n%c" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	variable l
	variable x
	variable c
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open $path(test1) r]
    fconfigure $f -translation lf -eofchar \x1a
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
    list $c $l
} {3 {abc def {}}}
test io-48.12 {cr write, testing readability, ^Z in middle, cr read mode} {fileevent} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation cr
    set c [format "abc\ndef\n%cfoo\nbar\n" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	variable l
	variable x
	variable c
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open $path(test1) r]
    fconfigure $f -eofchar \x1a -translation cr
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
    list $c $l
} {3 {abc def {}}}
test io-48.13 {cr write, testing readability, ^Z termination, cr read mode} {fileevent} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation cr
    set c [format "abc\ndef\n%c" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	variable c
	variable x
	variable l
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open $path(test1) r]
    fconfigure $f -translation cr -eofchar \x1a
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
    list $c $l
} {3 {abc def {}}}
test io-48.14 {crlf write, testing readability, ^Z in middle, crlf read mode} {fileevent} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    set c [format "abc\ndef\n%cfoo\nbar\n" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	variable c
	variable x
	variable l
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open $path(test1) r]
    fconfigure $f -eofchar \x1a -translation crlf
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
    list $c $l
} {3 {abc def {}}}
test io-48.15 {crlf write, testing readability, ^Z termi, crlf read mode} {fileevent} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    set c [format "abc\ndef\n%c" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	variable c
	variable x
	variable l
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open $path(test1) r]
    fconfigure $f -translation crlf -eofchar \x1a
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
    list $c $l
} {3 {abc def {}}}

test io-49.1 {testing crlf reading, leftover cr disgorgment} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "a\rb\rc\r\n"
    close $f
    set f [open $path(test1) r]
    set l ""
    lappend l [file size $path(test1)]
    fconfigure $f -translation crlf
    lappend l [read $f 1]
    lappend l [tell $f]
    lappend l [read $f 1]
    lappend l [tell $f]
    lappend l [read $f 1]
    lappend l [tell $f]
    lappend l [read $f 1]
    lappend l [tell $f]
    lappend l [read $f 1]
    lappend l [tell $f]
    lappend l [read $f 1]
    lappend l [tell $f]
    lappend l [eof $f]
    lappend l [read $f 1]
    lappend l [eof $f]
    close $f
    set l
} "7 a 1 [list \r] 2 b 3 [list \r] 4 c 5 {
} 7 0 {} 1"
test io-49.2 {testing crlf reading, leftover cr disgorgment} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "a\rb\rc\r\n"
    close $f
    set f [open $path(test1) r]
    set l ""
    lappend l [file size $path(test1)]
    fconfigure $f -translation crlf
    lappend l [read $f 2]
    lappend l [tell $f]
    lappend l [read $f 2]
    lappend l [tell $f]
    lappend l [read $f 2]
    lappend l [tell $f]
    lappend l [eof $f]
    lappend l [read $f 2]
    lappend l [tell $f]
    lappend l [eof $f]
    close $f
    set l
} "7 [list a\r] 2 [list b\r] 4 [list c\n] 7 0 {} 7 1"
test io-49.3 {testing crlf reading, leftover cr disgorgment} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "a\rb\rc\r\n"
    close $f
    set f [open $path(test1) r]
    set l ""
    lappend l [file size $path(test1)]
    fconfigure $f -translation crlf
    lappend l [read $f 3]
    lappend l [tell $f]
    lappend l [read $f 3]
    lappend l [tell $f]
    lappend l [eof $f]
    lappend l [read $f 3]
    lappend l [tell $f]
    lappend l [eof $f]
    close $f
    set l
} "7 [list a\rb] 3 [list \rc\n] 7 0 {} 7 1"
test io-49.4 {testing crlf reading, leftover cr disgorgment} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "a\rb\rc\r\n"
    close $f
    set f [open $path(test1) r]
    set l ""
    lappend l [file size $path(test1)]
    fconfigure $f -translation crlf
    lappend l [read $f 3]
    lappend l [tell $f]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [eof $f]
    close $f
    set l
} "7 [list a\rb] 3 [list \rc] 7 0 {} 7 1"
test io-49.5 {testing crlf reading, leftover cr disgorgment} {
    file delete $path(test1)
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "a\rb\rc\r\n"
    close $f
    set f [open $path(test1) r]
    set l ""
    lappend l [file size $path(test1)]
    fconfigure $f -translation crlf
    lappend l [set x [gets $f]]
    lappend l [tell $f]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [eof $f]
    close $f
    set l
} [list 7 a\rb\rc 7 {} 7 1]
    
testConstraint testchannelevent [llength [info commands testchannelevent]]
test io-50.1 {testing handler deletion} {testchannelevent} {
    file delete $path(test1)
    set f [open $path(test1) w]
    close $f
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list delhandler $f]]
    proc delhandler {f} {
	variable z
	set z called
	testchannelevent $f delete 0
    }
    set z not_called
    update
    close $f
    set z
} called
test io-50.2 {testing handler deletion with multiple handlers} {testchannelevent} {
    file delete $path(test1)
    set f [open $path(test1) w]
    close $f
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list delhandler $f 1]]
    testchannelevent $f add readable [namespace code [list delhandler $f 0]]
    proc delhandler {f i} {
	variable z
	lappend z "called delhandler $f $i"
	testchannelevent $f delete 0
    }
    set z ""
    update
    close $f
    string compare [string tolower $z] \
	[list [list called delhandler $f 0] [list called delhandler $f 1]]
} 0
test io-50.3 {testing handler deletion with multiple handlers} {testchannelevent} {
    file delete $path(test1)
    set f [open $path(test1) w]
    close $f
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list notcalled $f 1]]
    testchannelevent $f add readable [namespace code [list delhandler $f 0]]
    set z ""
    proc notcalled {f i} {
	variable z
	lappend z "notcalled was called!! $f $i"
    }
    proc delhandler {f i} {
	variable z
	testchannelevent $f delete 1
	lappend z "delhandler $f $i called"
	testchannelevent $f delete 0
	lappend z "delhandler $f $i deleted myself"
    }
    set z ""
    update
    close $f
    string compare [string tolower $z] \
	[list [list delhandler $f 0 called] \
	      [list delhandler $f 0 deleted myself]]
} 0
test io-50.4 {testing handler deletion vs reentrant calls} {testchannelevent} {
    file delete $path(test1)
    set f [open $path(test1) w]
    close $f
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list delrecursive $f]]
    proc delrecursive {f} {
	variable z
	variable u
	if {"$u" == "recursive"} {
	    testchannelevent $f delete 0
	    lappend z "delrecursive deleting recursive"
	} else {
	    lappend z "delrecursive calling recursive"
	    set u recursive
	    update
	}
    }
    set u toplevel
    set z ""
    update
    close $f
    string compare [string tolower $z] \
	{{delrecursive calling recursive} {delrecursive deleting recursive}}
} 0
test io-50.5 {testing handler deletion vs reentrant calls} {testchannelevent} {
    file delete $path(test1)
    set f [open $path(test1) w]
    close $f
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list notcalled $f]]
    testchannelevent $f add readable [namespace code [list del $f]]
    proc notcalled {f} {
	variable z
	lappend z "notcalled was called!! $f"
    }
    proc del {f} {
	variable u
	variable z
	if {"$u" == "recursive"} {
	    testchannelevent $f delete 1
	    testchannelevent $f delete 0
	    lappend z "del deleted notcalled"
	    lappend z "del deleted myself"
	} else {
	    set u recursive
	    lappend z "del calling recursive"
	    update
	    lappend z "del after update"
	}
    }
    set z ""
    set u toplevel
    update
    close $f
    string compare [string tolower $z] \
	[list {del calling recursive} {del deleted notcalled} \
	      {del deleted myself} {del after update}]
} 0
test io-50.6 {testing handler deletion vs reentrant calls} {testchannelevent} {
    file delete $path(test1)
    set f [open $path(test1) w]
    close $f
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list second $f]]
    testchannelevent $f add readable [namespace code [list first $f]]
    proc first {f} {
	variable u
	variable z
	if {"$u" == "toplevel"} {
	    lappend z "first called"
	    set u first
	    update
	    lappend z "first after update"
	} else {
	    lappend z "first called not toplevel"
	}
    }
    proc second {f} {
	variable u
	variable z
	if {"$u" == "first"} {
	    lappend z "second called, first time"
	    set u second
	    testchannelevent $f delete 0
	} elseif {"$u" == "second"} {
	    lappend z "second called, second time"
	    testchannelevent $f delete 0
	} else {
	    lappend z "second called, cannot happen!"
	    testchannelevent $f removeall
	}
    }
    set z ""
    set u toplevel
    update
    close $f
    string compare [string tolower $z] \
	[list {first called} {first called not toplevel} \
	      {second called, first time} {second called, second time} \
	      {first after update}]
} 0

test io-51.1 {Test old socket deletion on Macintosh} {socket} {
    set x 0
    set result ""
    proc accept {s a p} {
	variable x
	variable wait
	fconfigure $s -blocking off
	puts $s "sock[incr x]"
	close $s
	set wait done
    }
    set ss [socket -server [namespace code accept] 0]
    variable wait ""
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    vwait [namespace which -variable wait]
    lappend result [gets $cs]
    close $cs

    set wait ""
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    vwait [namespace which -variable wait]
    lappend result [gets $cs]
    close $cs

    set wait ""
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    vwait [namespace which -variable wait]
    lappend result [gets $cs]
    close $cs

    set wait ""
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    vwait [namespace which -variable wait]
    lappend result [gets $cs]
    close $cs
    close $ss
    set result
} {sock1 sock2 sock3 sock4}

test io-52.1 {TclCopyChannel} {fcopy} {
    file delete $path(test1)
    set f1 [open $thisScript]
    set f2 [open $path(test1) w]
    fcopy $f1 $f2 -command { # }
    catch { fcopy $f1 $f2 } msg
    close $f1
    close $f2
    string compare $msg "channel \"$f1\" is busy"
} {0}
test io-52.2 {TclCopyChannel} {fcopy} {
    file delete $path(test1)
    set f1 [open $thisScript]
    set f2 [open $path(test1) w]
    set f3 [open $thisScript]
    fcopy $f1 $f2 -command { # }
    catch { fcopy $f3 $f2 } msg
    close $f1
    close $f2
    close $f3
    string compare $msg "channel \"$f2\" is busy"
} {0}
test io-52.3 {TclCopyChannel} {fcopy} {
    file delete $path(test1)
    set f1 [open $thisScript]
    set f2 [open $path(test1) w]
    fconfigure $f1 -translation lf -blocking 0
    fconfigure $f2 -translation cr -blocking 0
    set s0 [fcopy $f1 $f2]
    set result [list [fconfigure $f1 -blocking] [fconfigure $f2 -blocking]]
    close $f1
    close $f2
    set s1 [file size $thisScript]
    set s2 [file size $path(test1)]
    if {("$s1" == "$s2") && ($s0 == $s1)} {
        lappend result ok
    }
    set result
} {0 0 ok}
test io-52.4 {TclCopyChannel} {fcopy} {
    file delete $path(test1)
    set f1 [open $thisScript]
    set f2 [open $path(test1) w]
    fconfigure $f1 -translation lf -blocking 0
    fconfigure $f2 -translation cr -blocking 0
    fcopy $f1 $f2 -size 40
    set result [list [fconfigure $f1 -blocking] [fconfigure $f2 -blocking]]
    close $f1
    close $f2
    lappend result [file size $path(test1)]
} {0 0 40}
test io-52.5 {TclCopyChannel} {fcopy} {
    file delete $path(test1)
    set f1 [open $thisScript]
    set f2 [open $path(test1) w]
    fconfigure $f1 -translation lf -blocking 0
    fconfigure $f2 -translation lf -blocking 0
    fcopy $f1 $f2 -size -1
    set result [list [fconfigure $f1 -blocking] [fconfigure $f2 -blocking]]
    close $f1
    close $f2
    set s1 [file size $thisScript]
    set s2 [file size $path(test1)]
    if {"$s1" == "$s2"} {
        lappend result ok
    }
    set result
} {0 0 ok}
test io-52.6 {TclCopyChannel} {fcopy} {
    file delete $path(test1)
    set f1 [open $thisScript]
    set f2 [open $path(test1) w]
    fconfigure $f1 -translation lf -blocking 0
    fconfigure $f2 -translation lf -blocking 0
    set s0 [fcopy $f1 $f2 -size [expr [file size $thisScript] + 5]]
    set result [list [fconfigure $f1 -blocking] [fconfigure $f2 -blocking]]
    close $f1
    close $f2
    set s1 [file size $thisScript]
    set s2 [file size $path(test1)]
    if {("$s1" == "$s2") && ($s0 == $s1)} {
        lappend result ok
    }
    set result
} {0 0 ok}
test io-52.7 {TclCopyChannel} {fcopy} {
    file delete $path(test1)
    set f1 [open $thisScript]
    set f2 [open $path(test1) w]
    fconfigure $f1 -translation lf -blocking 0
    fconfigure $f2 -translation lf -blocking 0
    fcopy $f1 $f2
    set result [list [fconfigure $f1 -blocking] [fconfigure $f2 -blocking]]
    set s1 [file size $thisScript]
    set s2 [file size $path(test1)]
    close $f1
    close $f2
    if {"$s1" == "$s2"} {
        lappend result ok
    }
    set result
} {0 0 ok}
test io-52.8 {TclCopyChannel} {stdio openpipe fcopy} {
    file delete $path(test1)
    file delete $path(pipe)
    set f1 [open $path(pipe) w]
    fconfigure $f1 -translation lf
    puts $f1 "
	puts ready
	gets stdin
	set f1 \[open [list $thisScript] r\]
	fconfigure \$f1 -translation lf
	puts \[read \$f1 100\]
	close \$f1
    "
    close $f1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
    fconfigure $f1 -translation lf
    gets $f1
    puts $f1 ready
    flush $f1
    set f2 [open $path(test1) w]
    fconfigure $f2 -translation lf
    set s0 [fcopy $f1 $f2 -size 40]
    catch {close $f1}
    close $f2
    list $s0 [file size $path(test1)]
} {40 40}

# Empty files, to register them with the test facility
set path(kyrillic.txt)   [makeFile {} kyrillic.txt]
set path(utf8-fcopy.txt) [makeFile {} utf8-fcopy.txt]
set path(utf8-rp.txt)    [makeFile {} utf8-rp.txt]

# Create kyrillic file, use lf translation to avoid os eol issues
set out [open $path(kyrillic.txt) w]
fconfigure $out -encoding koi8-r -translation lf
puts       $out "\u0410\u0410"
close      $out

test io-52.9 {TclCopyChannel & encodings} {fcopy} {
    # Copy kyrillic to UTF-8, using fcopy.

    set in  [open $path(kyrillic.txt) r]
    set out [open $path(utf8-fcopy.txt) w]

    fconfigure $in  -encoding koi8-r -translation lf
    fconfigure $out -encoding utf-8 -translation lf

    fcopy $in $out
    close $in
    close $out

    # Do the same again, but differently (read/puts).

    set in  [open $path(kyrillic.txt) r]
    set out [open $path(utf8-rp.txt) w]

    fconfigure $in  -encoding koi8-r -translation lf
    fconfigure $out -encoding utf-8 -translation lf

    puts -nonewline $out [read $in]

    close $in
    close $out

    list [file size $path(kyrillic.txt)] \
	    [file size $path(utf8-fcopy.txt)] \
	    [file size $path(utf8-rp.txt)]
} {3 5 5}

test io-52.10 {TclCopyChannel & encodings} {fcopy} {
    # encoding to binary (=> implies that the
    # internal utf-8 is written)

    set in  [open $path(kyrillic.txt) r]
    set out [open $path(utf8-fcopy.txt) w]

    fconfigure $in  -encoding koi8-r -translation lf
    # -translation binary is also -encoding binary
    fconfigure $out -translation binary

    fcopy $in $out
    close $in
    close $out

    file size $path(utf8-fcopy.txt)
} 5

test io-52.11 {TclCopyChannel & encodings} {fcopy} {
    # binary to encoding => the input has to be
    # in utf-8 to make sense to the encoder

    set in  [open $path(utf8-fcopy.txt) r]
    set out [open $path(kyrillic.txt) w]

    # -translation binary is also -encoding binary
    fconfigure $in  -translation binary
    fconfigure $out -encoding koi8-r -translation lf

    fcopy $in $out
    close $in
    close $out

    file size $path(kyrillic.txt)
} 3

test io-53.1 {CopyData} {fcopy} {
    file delete $path(test1)
    set f1 [open $thisScript]
    set f2 [open $path(test1) w]
    fconfigure $f1 -translation lf -blocking 0
    fconfigure $f2 -translation cr -blocking 0
    fcopy $f1 $f2 -size 0
    set result [list [fconfigure $f1 -blocking] [fconfigure $f2 -blocking]]
    close $f1
    close $f2
    lappend result [file size $path(test1)]
} {0 0 0}
test io-53.2 {CopyData} {fcopy} {
    file delete $path(test1)
    set f1 [open $thisScript]
    set f2 [open $path(test1) w]
    fconfigure $f1 -translation lf -blocking 0
    fconfigure $f2 -translation cr -blocking 0
    fcopy $f1 $f2 -command [namespace code {set s0}]
    set result [list [fconfigure $f1 -blocking] [fconfigure $f2 -blocking]]
    variable s0
    vwait [namespace which -variable s0]
    close $f1
    close $f2
    set s1 [file size $thisScript]
    set s2 [file size $path(test1)]
    if {("$s1" == "$s2") && ($s0 == $s1)} {
        lappend result ok
    }
    set result
} {0 0 ok}
test io-53.3 {CopyData: background read underflow} {stdio unixOnly openpipe fcopy} {
    file delete $path(test1)
    file delete $path(pipe)
    set f1 [open $path(pipe) w]
    puts -nonewline $f1 {
	puts ready
	flush stdout				;# Don't assume line buffered!
	fcopy stdin stdout -command { set x }
	vwait x
	set f [}
    puts $f1 [list open $path(test1) w]]
    puts $f1 {
	fconfigure $f -translation lf
	puts $f "done"
	close $f
    }
    close $f1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
    set result [gets $f1]
    puts $f1 line1
    flush $f1
    lappend result [gets $f1]
    puts $f1 line2
    flush $f1
    lappend result [gets $f1]
    close $f1
    after 500
    set f [open $path(test1)]
    lappend result [read $f]
    close $f
    set result
} "ready line1 line2 {done\n}"
test io-53.4 {CopyData: background write overflow} {stdio unixOnly openpipe fileevent fcopy} {
    set big bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n
    variable x
    for {set x 0} {$x < 12} {incr x} {
	append big $big
    }
    file delete $path(test1)
    file delete $path(pipe)
    set f1 [open $path(pipe) w]
    puts $f1 {
	puts ready
	fcopy stdin stdout -command { set x }
	vwait x
	set f [open $path(test1) w]
	fconfigure $f -translation lf
	puts $f "done"
	close $f
    }
    close $f1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
    set result [gets $f1]
    fconfigure $f1 -blocking 0
    puts $f1 $big
    flush $f1
    after 500
    set result ""
    fileevent $f1 read [namespace code {
	append result [read $f1 1024]
	if {[string length $result] >= [string length $big]} {
	    set x done
	}
    }]
    vwait [namespace which -variable x]
    close $f1
    set big {}
    set x
} done
set result {}

proc FcopyTestAccept {sock args} {
    after 1000 "close $sock"
}
proc FcopyTestDone {bytes {error {}}} {
    variable fcopyTestDone
    if {[string length $error]} {
	set fcopyTestDone 1
    } else {
	set fcopyTestDone 0
    }
}

test io-53.5 {CopyData: error during fcopy} {socket fcopy} {
    variable fcopyTestDone
    set listen [socket -server [namespace code FcopyTestAccept] 0]
    set in [open $thisScript]	;# 126 K
    set out [socket 127.0.0.1 [lindex [fconfigure $listen -sockname] 2]]
    catch {unset fcopyTestDone}
    close $listen	;# This means the socket open never really succeeds
    fcopy $in $out -command [namespace code FcopyTestDone]
    variable fcopyTestDone
    if ![info exists fcopyTestDone] {
	vwait [namespace which -variable fcopyTestDone]		;# The error occurs here in the b.g.
    }
    close $in
    close $out
    set fcopyTestDone	;# 1 for error condition
} 1
test io-53.6 {CopyData: error during fcopy} {stdio openpipe fcopy} {
    variable fcopyTestDone
    file delete $path(pipe)
    file delete $path(test1)
    catch {unset fcopyTestDone}
    set f1 [open $path(pipe) w]
    puts $f1 "exit 1"
    close $f1
    set in [open "|[list [interpreter] $path(pipe)]" r+]
    set out [open $path(test1) w]
    fcopy $in $out -command [namespace code FcopyTestDone]
    variable fcopyTestDone
    if ![info exists fcopyTestDone] {
	vwait [namespace which -variable fcopyTestDone]
    }
    catch {close $in}
    close $out
    set fcopyTestDone	;# 0 for plain end of file
} {0}

proc doFcopy {in out {bytes 0} {error {}}} {
    variable fcopyTestDone
    variable fcopyTestCount
    incr fcopyTestCount $bytes
    if {[string length $error]} {
	    set fcopyTestDone 1
    } elseif {[eof $in]} {
	    set fcopyTestDone 0
    } else {
        # Delay next fcopy to wait for size>0 input bytes
        after 100 [list 
            fcopy $in $out -size 1000 \
		    -command [namespace code [list doFcopy $in $out]]
        ]
    }
}

test io-53.7 {CopyData: Flooding fcopy from pipe} {stdio openpipe fcopy} {
    variable fcopyTestDone
    file delete $path(pipe)
    catch {unset fcopyTestDone}
    set fcopyTestCount 0
    set f1 [open $path(pipe) w]
    puts $f1 {
	# Write  10 bytes / 10 msec
	proc Write {count} {
	    puts -nonewline "1234567890"
	    if {[incr count -1]} {
	        after 10 [list Write $count]
	    } else {
	        set ::ready 1
	    }
	}
	fconfigure stdout -buffering none
	Write 345 ;# 3450 bytes ~3.45 sec
	vwait ready
	exit 0
    }
    close $f1
    set in [open "|[list [interpreter] $path(pipe) &]" r+]
    set out [open $path(test1) w]
    doFcopy $in $out
    variable fcopyTestDone
    if ![info exists fcopyTestDone] {
	vwait [namespace which -variable fcopyTestDone]
    }
    catch {close $in}
    close $out
    # -1=error 0=script error N=number of bytes
    expr ($fcopyTestDone == 0) ? $fcopyTestCount : -1
} {3450}

test io-54.1 {Recursive channel events} {socket fileevent} {
    # This test checks to see if file events are delivered during recursive
    # event loops when there is buffered data on the channel.

    proc accept {s a p} {
	variable as
	fconfigure $s -translation lf
	puts $s "line 1\nline2\nline3"
	flush $s
	set as $s
    }
    proc readit {s next} {
	variable x
	variable result
	lappend result $next
	if {$next == 1} {
	    fileevent $s readable [namespace code [list readit $s 2]]
	    vwait [namespace which -variable x]
	}
	incr x
    }
    set ss [socket -server [namespace code accept] 0]

    # We need to delay on some systems until the creation of the
    # server socket completes.

    set done 0
    for {set i 0} {$i < 10} {incr i} {
	if {![catch {set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]}]} {
	    set done 1
	    break
	}
	after 100
    }
    if {$done == 0} {
	close $ss
	error "failed to connect to server"
    }
    variable result {}
    variable x 0
    variable as
    vwait [namespace which -variable as]
    fconfigure $cs -translation lf
    lappend result [gets $cs]
    fconfigure $cs -blocking off
    fileevent $cs readable [namespace code [list readit $cs 1]]
    set a [after 2000 [namespace code { set x failure }]]
    vwait [namespace which -variable x]
    after cancel $a
    close $as
    close $ss
    close $cs
    list $result $x
} {{{line 1} 1 2} 2}
test io-54.2 {Testing for busy-wait in recursive channel events} {socket fileevent} {
    set accept {}
    set after {}
    variable s [socket -server [namespace code accept] 0]
    proc accept {s a p} {
	variable counter
	variable accept

	set accept $s
	set counter 0
	fconfigure $s -blocking off -buffering line -translation lf
	fileevent $s readable [namespace code "doit $s"]
    }
    proc doit {s} {
	variable counter
	variable after

	incr counter
	set l [gets $s]
	if {"$l" == ""} {
	    fileevent $s readable [namespace code "doit1 $s"]
	    set after [after 1000 [namespace code newline]]
	}
    }
    proc doit1 {s} {
	variable counter
	variable accept

	incr counter
	set l [gets $s]
	close $s
	set accept {}
    }
    proc producer {} {
	variable s
	variable writer

	set writer [socket 127.0.0.1 [lindex [fconfigure $s -sockname] 2]]
	fconfigure $writer -buffering line
	puts -nonewline $writer hello
	flush $writer
    }
    proc newline {} {
	variable done
	variable writer

	puts $writer hello
	flush $writer
	set done 1
    }
    producer
    variable done
    vwait [namespace which -variable done]
    close $writer
    close $s
    after cancel $after
    if {$accept != {}} {close $accept}
    set counter
} 1

set path(fooBar) [makeFile {} fooBar]

test io-55.1 {ChannelEventScriptInvoker: deletion} {fileevent} {
    variable x
    proc eventScript {fd} {
	variable x
	close $fd
	error "planned error"
	set x whoops
    }
    proc ::bgerror {args} "set [namespace which -variable x] got_error"
    set f [open $path(fooBar) w]
    fileevent $f writable [namespace code [list eventScript $f]]
    variable x not_done
    vwait [namespace which -variable x]
    set x
} {got_error}

test io-56.1 {ChannelTimerProc} {testchannelevent} {
    set f [open $path(fooBar) w]
    puts $f "this is a test"
    close $f
    set f [open $path(fooBar) r]
    testchannelevent $f add readable [namespace code {
	read $f 1
	incr x
    }]
    variable x 0
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
    set result $x
    testchannelevent $f set 0 none
    after idle [namespace code {set y done}]
    variable y
    vwait [namespace which -variable y]
    close $f
    lappend result $y
} {2 done}

test io-57.1 {buffered data and file events, gets} {fileevent} {
    proc accept {sock args} {
	variable s2
	set s2 $sock
    }
    set server [socket -server [namespace code accept] 0]
    set s [socket 127.0.0.1 [lindex [fconfigure $server -sockname] 2]]
    variable s2
    vwait [namespace which -variable s2]
    update
    fileevent $s2 readable [namespace code {lappend result readable}]
    puts $s "12\n34567890"
    flush $s
    variable result [gets $s2]
    after 1000 [namespace code {lappend result timer}]
    vwait [namespace which -variable result]
    lappend result [gets $s2]
    vwait [namespace which -variable result]
    close $s
    close $s2
    close $server
    set result
} {12 readable 34567890 timer}
test io-57.2 {buffered data and file events, read} {fileevent} {
    proc accept {sock args} {
	variable s2
	set s2 $sock
    }
    set server [socket -server [namespace code accept] 0]
    set s [socket 127.0.0.1 [lindex [fconfigure $server -sockname] 2]]
    variable s2
    vwait [namespace which -variable s2]
    update
    fileevent $s2 readable [namespace code {lappend result readable}]
    puts -nonewline $s "1234567890"
    flush $s
    variable result [read $s2 1]
    after 1000 [namespace code {lappend result timer}]
    vwait [namespace which -variable result]
    lappend result [read $s2 9]
    vwait [namespace which -variable result]
    close $s
    close $s2
    close $server
    set result
} {1 readable 234567890 timer}
        
test io-58.1 {Tcl_NotifyChannel and error when closing} {stdio unixOrPc openpipe fileevent} {
    set out [open $path(script) w]
    puts $out {
	puts "normal message from pipe"
	puts stderr "error message from pipe"
	exit 1
    }
    proc readit {pipe} {
	variable x
	variable result
	if {[eof $pipe]} {
	    set x [catch {close $pipe} line]
	    lappend result catch $line
	} else {
	    gets $pipe line
	    lappend result gets $line
	}
    }
    close $out
    set pipe [open "|[list [interpreter] $path(script)]" r]
    fileevent $pipe readable [namespace code [list readit $pipe]]
    variable x ""
    set result ""
    vwait [namespace which -variable x]
    list $x $result
} {1 {gets {normal message from pipe} gets {} catch {error message from pipe}}}


testConstraint testmainthread [llength [info commands testmainthread]]
test io-59.1 {Thread reference of channels} {testmainthread testchannel} {
    # TIP #10
    # More complicated tests (like that the reference changes as a
    # channel is moved from thread to thread) can be done only in the
    # extension which fully implements the moving of channels between
    # threads, i.e. 'Threads'. Or we have to extend [testthread] as well.

    set f [open $path(longfile) r]
    set result [testchannel mthread $f]
    close $f
    string equal $result [testmainthread]
} {1}


test io-60.1 {writing illegal utf sequences} {openpipe fileevent} {
    # This test will hang in older revisions of the core.

    set out [open $path(script) w]
    puts $out {
	puts [encoding convertfrom identity \xe2]
	exit 1
    }
    proc readit {pipe} {
	variable x
	variable result
	if {[eof $pipe]} {
	    set x [catch {close $pipe} line]
	    lappend result catch $line
	} else {
	    gets $pipe line
	    lappend result gets $line
	}
    }
    close $out
    set pipe [open "|[list [interpreter] $path(script)]" r]
    fileevent $pipe readable [namespace code [list readit $pipe]]
    variable x ""
    set result ""
    vwait [namespace which -variable x]

    # cut of the remainder of the error stack, especially the filename
    set result [lreplace $result 3 3 [lindex [split [lindex $result 3] \n] 0]]
    list $x $result
} {1 {gets {} catch {error writing "stdout": invalid argument}}}




# cleanup
foreach file [list fooBar longfile script output test1 pipe my_script foo \
	bar test2 test3 cat stdout kyrillic.txt utf8-fcopy.txt utf8-rp.txt] {
    removeFile $file
}
cleanupTests
}
namespace delete ::tcl::test::io
return
@


1.3
log
@Updated to tcl 8.4.6
@
text
@d15 1
a15 1
# RCS: @@(#) $Id: io.test,v 1.40.2.3 2004/02/25 23:38:16 dgp Exp $
@


1.3.4.1
log
@sync branch with HEAD
@
text
@d15 1
a15 1
# RCS: @@(#) $Id$
@


1.3.2.1
log
@merge from HEAD
@
text
@d15 1
a15 1
# RCS: @@(#) $Id$
@


1.2
log
@updated tcl to 8.4.4
@
text
@d15 1
a15 1
# RCS: @@(#) $Id: io.test,v 1.40 2003/02/25 22:03:38 andreas_kupries Exp $
d33 3
a40 3
removeFile test1
removeFile pipe

d410 1
a410 1
test io-6.7 {Tcl_GetsObj: error in input} {stdio} {
d672 1
a672 1
test io-6.31 {Tcl_GetsObj: crlf mode: buffer exhausted, blocked} {stdio testchannel} {
d811 1
a811 1
test io-6.43 {Tcl_GetsObj: input saw cr} {stdio testchannel} {
d828 1
a828 1
test io-6.44 {Tcl_GetsObj: input saw cr, not followed by cr} {stdio testchannel} {
d845 1
a845 1
test io-6.45 {Tcl_GetsObj: input saw cr, skip right number of bytes} {stdio testchannel} {
d862 1
a862 1
test io-6.46 {Tcl_GetsObj: input saw cr, followed by just \n should give eof} {stdio testchannel} {
d987 1
a987 1
test io-6.56 {Tcl_GetsObj: incomplete lines should disable file events} {stdio} {
d1047 1
a1047 1
test io-7.4 {FilterInputBytes: recover from split up character} {stdio} {
d1082 1
a1082 1
test io-8.2 {PeekAhead: only go to device if no more cached data} {stdio testchannel} {
d1102 1
a1102 1
test io-8.3 {PeekAhead: no cached data available} {stdio testchannel} {
d1135 1
a1135 1
test io-8.5 {PeekAhead: don't peek if last read was short} {stdio testchannel} {
d1147 1
a1147 1
test io-8.6 {PeekAhead: change to non-blocking mode} {stdio testchannel} {
d1159 1
a1159 1
test io-8.7 {PeekAhead: cleanup} {stdio testchannel} {
d1325 1
a1325 1
test io-12.4 {ReadChars: split-up char} {stdio testchannel} {
d1350 1
a1350 1
test io-12.5 {ReadChars: fileevents on partial characters} {stdio} {
d1445 1
a1445 1
test io-13.6 {TranslateInputEOL: auto mode: saw cr in last segment} {stdio testchannel} {
d1471 1
a1471 1
test io-13.7 {TranslateInputEOL: auto mode: naked \r} {testchannel} {
d1583 1
a1583 1
test io-14.3 {Tcl_SetStdChannel & Tcl_GetStdChannel} {exec} {
d1585 1
a1585 1
    puts $f [format {
d1589 5
a1593 4
	set f  [open "%s" r]
	set f2 [open "%s" w]
	set f3 [open "%s" w]
	puts stdout [gets stdin]
d1599 1
a1599 1
    } $path(test1) $path(test2) $path(test3)]
d1615 1
a1615 1
    puts $f [format { close stdin
d1618 5
a1622 4
	set f  [open "%s" r]
	set f2 [open "%s" w]
	set f3 [open "%s" w]
	puts stdout [gets stdin]
d1628 1
a1628 1
    } $path(test1) $path(test2) $path(test3)]
d1675 3
a1677 3
test io-14.8 {reuse of stdio special channels} {stdio} {
    removeFile script
    removeFile test1
d1679 1
a1679 1
    puts $f [format {
d1681 3
a1683 1
	set f [open "%s" w]
d1686 3
a1688 1
	set f [open "%s" r]
d1690 1
a1690 1
    } $path(test1) $path(test1)]
d1698 3
a1700 3
test io-14.9 {reuse of stdio special channels} {stdio} {
    removeFile script
    removeFile test1
d1769 1
a1769 1
    removeFile test1
d1783 1
a1783 1
    removeFile test1
d1804 1
a1804 1
    removeFile test1
d1827 1
a1827 1
    removeFile test1
d1837 1
a1837 1
    removeFile test1
d1883 1
a1883 1
test io-20.5 {Tcl_CreateChannel: install channel in empty slot} {stdio} {
d1885 1
a1885 1
    puts $f [format {
d1887 3
a1889 1
	set f1 [open "%s" w]
d1892 1
a1892 1
    } $path(stdout)]
d1913 1
a1913 1
    removeFile test1
d1921 1
a1921 1
    removeFile test1
d1942 1
a1942 1
    removeFile test1
d1953 1
a1953 1
    removeFile test1
d1957 1
a1957 1
test io-26.1 {Tcl_GetChannelInstanceData} {stdio} {
d1969 1
a1969 1
    removeFile test1
d1977 1
a1977 1
    removeFile test1
d1990 1
a1990 1
    removeFile test1
d2001 1
a2001 1
    removeFile test1
d2018 1
a2018 1
    removeFile test1
d2036 3
a2038 3
	{stdio asyncPipeClose } {
    removeFile pipe
    removeFile output
d2040 2
a2041 2
    puts $f [format {
	set f [open "%s" w]
d2048 1
a2048 1
    } $path(output)]
d2076 1
a2076 1
    removeFile test1
d2089 1
a2089 1
    removeFile test1
d2104 3
a2106 3
	{stdio asyncPipeClose nonPortable} {
    removeFile pipe
    removeFile output
d2150 1
a2150 1
    removeFile test1
d2162 2
a2163 2
test io-28.5 {Tcl_Close vs standard handles} {stdio unixOnly testchannel} {
    removeFile script
d2180 1
a2180 1
    removeFile test1
d2188 1
a2188 1
    removeFile test1
d2196 1
a2196 1
    removeFile test1
d2210 1
a2210 1
    removeFile test1
d2224 1
a2224 1
    removeFile test1
d2239 1
a2239 1
    removeFile test1
d2256 1
a2256 1
    removeFile test1
d2279 1
a2279 1
    removeFile test1
d2291 1
a2291 1
    removeFile test1
d2302 3
a2304 3
test io-29.12 {Tcl_WriteChars on a pipe} {stdio} {
    removeFile test1
    removeFile pipe
d2306 2
a2307 2
    puts $f1 [format {
	set f1 [open "%s" r]
d2311 1
a2311 1
    } $path(longfile)]
d2327 3
a2329 3
test io-29.13 {Tcl_WriteChars to a pipe, line buffered} {stdio} {
    removeFile test1
    removeFile pipe
d2357 1
a2357 1
    removeFile test3
d2369 1
a2369 1
    removeFile test1
d2378 1
a2378 1
test io-29.16 {Tcl_Flush on pipe opened only for reading} {stdio} {
d2386 1
a2386 1
    removeFile test1
d2398 1
a2398 1
    removeFile test1
d2417 1
a2417 1
    removeFile test1
d2435 1
a2435 1
    removeFile test1
d2452 2
a2453 2
test io-29.21 {Tcl_Flush to pipe} {stdio} {
    removeFile pipe
d2466 2
a2467 2
test io-29.22 {Tcl_Flush called at other end of pipe} {stdio} {
    removeFile pipe
d2489 2
a2490 2
test io-29.23 {Tcl_Flush and line buffering at end of pipe} {stdio} {
    removeFile pipe
d2524 2
a2525 2
test io-29.25 {Implicit flush with Tcl_Flush to command pipelines} {stdio} {
    removeFile test3
d2536 1
a2536 1
test io-29.26 {Tcl_Flush, Tcl_Write on bidirectional pipelines} {stdio unixExecs} {
d2544 2
a2545 2
test io-29.27 {Tcl_Flush on closed pipeline} {stdio} {
    removeFile pipe
d2573 1
a2573 1
    removeFile test1
d2583 1
a2583 1
    removeFile test1
d2591 1
a2591 1
    removeFile test1
d2598 3
a2600 3
test io-29.31 {Tcl_WriteChars, background flush} {stdio} {
    removeFile pipe
    removeFile output
d2602 1
a2602 1
    puts $f [format {set f [open "%s" w]} $path(output)]
d2635 3
a2637 3
	{stdio asyncPipeClose} {
    catch {removeFile pipe}
    catch {removeFile output}
d2639 1
a2639 1
    puts $f [format {set f [open {%s} w]} $path(output)]
d2674 2
a2675 3
    puts $f [format {
	set f [open "%s" w]
	fconfigure $f -translation lf
d2679 1
a2679 1
    } $path(test1)]
d2687 1
a2687 1
test io-29.34 {Tcl_Close, async flush on close, using sockets} {socket tempNotMac} {
d2724 1
a2724 1
test io-29.35 {Tcl_Close vs fileevent vs multiple interpreters} {socket tempNotMac} {
d2769 1
a2769 1
    removeFile test1
d2781 1
a2781 1
    removeFile test1
d2793 1
a2793 1
    removeFile test1
d2805 1
a2805 1
    removeFile test1
d2817 1
a2817 1
    removeFile test1
d2829 1
a2829 1
    removeFile test1
d2841 1
a2841 1
    removeFile test1
d2853 1
a2853 1
    removeFile test1
d2865 1
a2865 1
    removeFile test1
d2877 1
a2877 1
    removeFile test1
d2893 1
a2893 1
    removeFile test1
d2909 1
a2909 1
    removeFile test1
d2926 1
a2926 1
    removeFile test1
d2943 1
a2943 1
    removeFile test1
d2960 1
a2960 1
    removeFile test1
d2976 1
a2976 1
    removeFile test1
d2992 1
a2992 1
    removeFile test1
d3008 1
a3008 1
    removeFile test1
d3028 1
a3028 1
    removeFile test1
d3048 1
a3048 1
    removeFile test1
d3070 1
a3070 1
    removeFile test1
d3088 1
a3088 1
    removeFile test1
d3106 1
a3106 1
    removeFile test1
d3120 1
a3120 1
    removeFile test1
d3134 1
a3134 1
    removeFile test1
d3148 1
a3148 1
    removeFile test1
d3162 1
a3162 1
    removeFile test1
d3176 1
a3176 1
    removeFile test1
d3193 1
a3193 1
    removeFile test1
d3210 1
a3210 1
    removeFile test1
d3227 1
a3227 1
    removeFile test1
d3244 1
a3244 1
    removeFile test1
d3262 1
a3262 1
    removeFile test1
d3282 1
a3282 1
    removeFile test1
d3302 1
a3302 1
    removeFile test1
d3322 1
a3322 1
    removeFile test1
d3342 1
a3342 1
    removeFile test1
d3362 1
a3362 1
    removeFile test1
d3382 1
a3382 1
    removeFile test1
d3402 1
a3402 1
    removeFile test1
d3422 1
a3422 1
    removeFile test1
d3434 1
a3434 1
    removeFile test1
d3453 1
a3453 1
    removeFile test1
d3472 1
a3472 1
    removeFile test1
d3490 1
a3490 1
    removeFile test1
d3509 1
a3509 1
    removeFile test1
d3529 1
a3529 1
    removeFile test1
d3548 1
a3548 1
    removeFile test1
d3567 1
a3567 1
    removeFile test1
d3585 1
a3585 1
    removeFile test1
d3607 1
a3607 1
    removeFile test1
d3629 1
a3629 1
    removeFile test1
d3651 1
a3651 1
    removeFile test1
d3669 1
a3669 1
    removeFile test1
d3687 1
a3687 1
    removeFile test1
d3705 1
a3705 1
    removeFile test1
d3723 1
a3723 1
    removeFile test1
d3741 1
a3741 1
    removeFile test1
d3759 1
a3759 1
    removeFile test1
d3778 1
a3778 1
    removeFile test1
d3878 2
a3879 2
test io-32.10 {Tcl_Read from a pipe} {stdio} {
    removeFile pipe
d3890 2
a3891 2
test io-32.11 {Tcl_Read from a pipe} {stdio} {
    removeFile pipe
d3910 1
a3910 1
    removeFile test1
d3922 1
a3922 1
    removeFile test1
d3934 1
a3934 1
    removeFile test1
d3947 1
a3947 1
    removeFile test1
d3960 1
a3960 1
    removeFile test1
d3975 1
a3975 1
    removeFile test1
d4000 2
a4001 2
test io-33.3 {Tcl_Gets from pipe} {stdio} {
    removeFile pipe
d4017 1
a4017 1
    removeFile test3
d4037 1
a4037 1
    removeFile test3
d4114 1
a4114 1
    removeFile test1
d4127 1
a4127 1
    removeFile test1
d4140 1
a4140 1
    removeFile test1
d4153 1
a4153 1
    removeFile test1
d4167 1
a4167 1
    removeFile test1
d4182 1
a4182 1
    removeFile test1
d4197 1
a4197 1
test io-34.8 {Tcl_Seek on pipes: not supported} {stdio} {
d4205 1
a4205 1
    removeFile test3
d4273 1
a4273 1
    removeFile test1
d4280 1
a4280 1
    removeFile test1
d4293 1
a4293 1
    removeFile test1
d4307 1
a4307 1
test io-34.16 {Tcl_tell on pipe: always -1} {stdio} {
d4313 1
a4313 1
test io-34.17 {Tcl_Tell on pipe: always -1} {stdio} {
d4323 1
a4323 1
    removeFile test2
d4369 1
a4369 1
    removeFile test3
d4394 1
a4394 1
    removeFile test1
d4412 2
a4413 2
test io-35.2 {Tcl_Eof with pipe} {stdio} {
    removeFile pipe
d4430 2
a4431 2
test io-35.3 {Tcl_Eof with pipe} {stdio} {
    removeFile pipe
d4453 1
a4453 1
    removeFile test1
d4464 2
a4465 2
test io-35.5 {Tcl_Eof, eof detection on nonblocking pipe} {stdio} {
    removeFile pipe
d4479 1
a4479 1
    removeFile test1
d4493 1
a4493 1
    removeFile test1
d4507 1
a4507 1
    removeFile test1
d4521 1
a4521 1
    removeFile test1
d4535 1
a4535 1
    removeFile test1
d4549 1
a4549 1
    removeFile test1
d4563 1
a4563 1
    removeFile test1
d4578 1
a4578 1
    removeFile test1
d4593 1
a4593 1
    removeFile test1
d4608 1
a4608 1
    removeFile test1
d4623 1
a4623 1
    removeFile test1
d4638 1
a4638 1
    removeFile test1
d4655 1
a4655 1
test io-36.1 {Tcl_InputBlocked on nonblocking pipe} {stdio} {
d4674 1
a4674 1
test io-36.2 {Tcl_InputBlocked on blocking pipe} {stdio} {
d4689 1
a4689 1
    removeFile test1
d4704 1
a4704 1
test io-36.4 {Tcl_InputBlocked vs files, event driven read} {
d4711 1
a4711 1
    removeFile test1
d4724 1
a4724 1
    removeFile test1
d4740 1
a4740 1
test io-36.6 {Tcl_InputBlocked vs files, event driven read} {nonBlockFiles} {
d4747 1
a4747 1
    removeFile test1
d4829 1
a4829 1
    removeFile test1
d4839 1
a4839 1
    removeFile test1
d4846 1
a4846 1
    removeFile test1
d4854 1
a4854 1
    removeFile test1
d4870 1
a4870 1
    removeFile test1
d4880 1
a4880 1
    removeFile test1
d4890 1
a4890 1
    removeFile test1
d4904 1
a4904 1
    removeFile test1
d4924 1
a4924 1
    removeFile test1
d4939 2
a4940 2
test io-39.10 {Tcl_SetChannelOption, blocking mode} {stdio} {
    removeFile pipe
d4976 1
a4976 1
    removeFile test1
d4984 1
a4984 1
    removeFile test1
d4992 1
a4992 1
    removeFile test1
d5000 1
a5000 1
    removeFile test1
d5012 1
a5012 1
    removeFile test1
d5024 1
a5024 1
    removeFile test1
d5030 1
a5030 1
test io-39.17 {Tcl_SetChannelOption: -encoding, clearing CHANNEL_NEED_MORE_DATA} {stdio} {
d5107 1
a5107 1
    removeFile test1
d5120 1
a5120 1
    removeFile test1
d5152 1
a5152 1
    removeFile test3
d5167 1
a5167 1
    removeFile test3
d5185 1
a5185 1
    removeFile test3
d5192 1
a5192 1
    removeFile test3
d5207 1
a5207 1
    removeFile test3
d5227 2
a5228 2
test io-40.6 {POSIX open access modes: EXCL} {
    removeFile test3
d5232 2
a5233 5
    set msg [list [catch {open $path(test3) {WRONLY CREAT EXCL}} msg] $msg]
    regsub " already " $msg " " msg
    regsub [file join {} $path(test3)] $msg "test3" msg
    string tolower $msg
} {1 {couldn't open "test3": file exists}}
d5235 1
a5235 1
    removeFile test3
d5243 1
a5243 1
    removeFile test3
d5256 1
a5256 1
    removeFile test3
d5277 8
a5284 12
test io-40.11 {POSIX open access modes: RDONLY} {
    removeFile test3
    set msg [list [catch {open $path(test3) RDONLY} msg] $msg]
    regsub [file join {} $path(test3)] $msg "test3" msg
	string tolower $msg
} {1 {couldn't open "test3": no such file or directory}}
test io-40.12 {POSIX open access modes: WRONLY} {
    removeFile test3
    set msg [list [catch {open $path(test3) WRONLY} msg] $msg]
    regsub [file join {} $path(test3)] $msg "test3" msg
	string tolower $msg
} {1 {couldn't open "test3": no such file or directory}}
d5297 4
a5300 6
test io-40.14 {POSIX open access modes: RDWR} {
    removeFile test3
    set msg [list [catch {open $path(test3) RDWR} msg] $msg]
    regsub [file join {} $path(test3)] $msg "test3" msg
	string tolower $msg
} {1 {couldn't open "test3": no such file or directory}}
d5311 7
a5317 8
    test io-40.16 {tilde substitution in open} {
	set f [open ~/_test_ w]
	puts $f "Some text"
	close $f
	set x [file exists [file join $env(HOME) _test_]]
	removeFile [file join $env(HOME) _test_]
	set x
    } 1
d5327 1
a5327 1
test io-41.1 {Tcl_FileeventCmd: errors} {
d5330 1
a5330 1
test io-41.2 {Tcl_FileeventCmd: errors} {
d5333 1
a5333 1
test io-41.3 {Tcl_FileeventCmd: errors} {
d5336 1
a5336 1
test io-41.4 {Tcl_FileeventCmd: errors} {
d5339 1
a5339 1
test io-41.5 {Tcl_FileeventCmd: errors} {
d5350 1
a5350 1
test io-42.1 {Tcl_FileeventCmd: creating, deleting, querying} {
d5353 1
a5353 1
test io-42.2 {Tcl_FileeventCmd: replacing} {
d5364 1
a5364 1
test io-42.3 {Tcl_FileeventCmd: replacing, with NULL chars in script} {
d5379 1
a5379 1

d5382 1
d5384 1
a5384 1
test io-43.1 {Tcl_FileeventCmd: creating, deleting, querying} {stdio unixExecs} {
d5395 1
a5395 1
test io-43.2 {Tcl_FileeventCmd: deleting when many present} {stdio unixExecs} {
d5410 1
a5410 1
test io-44.1 {FileEventProc procedure: normal read event} {stdio unixExecs} {
d5419 1
a5419 1
test io-44.2 {FileEventProc procedure: error in read event} {stdio unixExecs} {
d5428 1
a5428 1
test io-44.3 {FileEventProc procedure: normal write event} {stdio unixExecs} {
d5443 1
a5443 1
test io-44.4 {FileEventProc procedure: eror in write event} {stdio unixExecs} {
d5451 1
a5451 1
test io-44.5 {FileEventProc procedure: end of file} {stdio unixExecs} {
d5474 1
a5474 1
test io-45.1 {DeleteFileEvent, cleanup on close} {
d5487 1
a5487 1
test io-45.2 {DeleteFileEvent, cleanup on close} {
d5504 1
a5504 1
test io-45.3 {DeleteFileEvent, cleanup on close} {
d5529 1
a5529 1
test io-46.1 {Tcl event loop vs multiple interpreters} {testfevent} {
d5531 2
a5532 2
    testfevent cmd [format {
	set f [open {%s} r]
d5538 2
a5539 1
    } $path(foo)]
d5568 1
a5568 1
test io-47.1 {fileevent vs multiple interpreters} testfevent {
d5587 1
a5587 1
test io-47.2 {deleting fileevent on interpreter delete} testfevent {
d5608 1
a5608 1
test io-47.3 {deleting fileevent on interpreter delete} testfevent {
d5629 1
a5629 1
test io-47.4 {file events on shared files and multiple interpreters} testfevent {
d5645 1
a5645 1
test io-47.5 {file events on shared files, deleting file events} testfevent {
d5658 1
a5658 1
test io-47.6 {file events on shared files, deleting file events} testfevent {
d5674 1
a5674 1
test io-48.1 {testing readability conditions} {
d5700 1
a5700 1
test io-48.2 {testing readability conditions} {nonBlockFiles} {
d5730 1
a5730 1
test io-48.3 {testing readability conditions} {stdio unixOnly nonBlockFiles} {
d5767 2
a5768 2
    puts $f [format {source {%s}}         $path(my_script)]
    puts $f [format {set f [open {%s} r]} $path(bar)]
d5775 2
a5776 2
test io-48.4 {lf write, testing readability, ^Z termination, auto read mode} {
    removeFile test1
d5803 2
a5804 2
test io-48.5 {lf write, testing readability, ^Z in middle, auto read mode} {
    removeFile test1
d5831 2
a5832 2
test io-48.6 {cr write, testing readability, ^Z termination, auto read mode} {
    removeFile test1
d5859 2
a5860 2
test io-48.7 {cr write, testing readability, ^Z in middle, auto read mode} {
    removeFile test1
d5887 2
a5888 2
test io-48.8 {crlf write, testing readability, ^Z termination, auto read mode} {
    removeFile test1
d5915 2
a5916 2
test io-48.9 {crlf write, testing readability, ^Z in middle, auto read mode} {
    removeFile test1
d5943 2
a5944 2
test io-48.10 {lf write, testing readability, ^Z in middle, lf read mode} {
    removeFile test1
d5971 2
a5972 2
test io-48.11 {lf write, testing readability, ^Z termination, lf read mode} {
    removeFile test1
d5999 2
a6000 2
test io-48.12 {cr write, testing readability, ^Z in middle, cr read mode} {
    removeFile test1
d6027 2
a6028 2
test io-48.13 {cr write, testing readability, ^Z termination, cr read mode} {
    removeFile test1
d6055 2
a6056 2
test io-48.14 {crlf write, testing readability, ^Z in middle, crlf read mode} {
    removeFile test1
d6083 2
a6084 2
test io-48.15 {crlf write, testing readability, ^Z termi, crlf read mode} {
    removeFile test1
d6113 1
a6113 1
    removeFile test1
d6142 1
a6142 1
    removeFile test1
d6165 1
a6165 1
    removeFile test1
d6186 1
a6186 1
    removeFile test1
d6207 1
a6207 1
    removeFile test1
d6227 1
a6227 1
    removeFile test1
d6243 1
a6243 1
    removeFile test1
d6261 1
a6261 1
    removeFile test1
d6287 1
a6287 1
    removeFile test1
d6312 1
a6312 1
    removeFile test1
d6346 1
a6346 1
    removeFile test1
d6428 2
a6429 2
test io-52.1 {TclCopyChannel} {
    removeFile test1
d6438 2
a6439 2
test io-52.2 {TclCopyChannel} {
    removeFile test1
d6450 2
a6451 2
test io-52.3 {TclCopyChannel} {
    removeFile test1
d6467 2
a6468 2
test io-52.4 {TclCopyChannel} {
    removeFile test1
d6479 2
a6480 2
test io-52.5 {TclCopyChannel} {
    removeFile test1
d6496 2
a6497 2
test io-52.6 {TclCopyChannel} {
    removeFile test1
d6513 2
a6514 2
test io-52.7 {TclCopyChannel} {
    removeFile test1
d6530 3
a6532 3
test io-52.8 {TclCopyChannel} {stdio} {
    removeFile test1
    removeFile pipe
d6568 1
a6568 1
test io-52.9 {TclCopyChannel & encodings} {
d6599 1
a6599 1
test io-52.10 {TclCopyChannel & encodings} {
d6617 1
a6617 1
test io-52.11 {TclCopyChannel & encodings} {
d6635 2
a6636 3

test io-53.1 {CopyData} {
    removeFile test1
d6647 2
a6648 2
test io-53.2 {CopyData} {
    removeFile test1
d6666 3
a6668 3
test io-53.3 {CopyData: background read underflow} {stdio unixOnly} {
    removeFile test1
    removeFile pipe
d6670 1
a6670 1
    puts $f1 [format {
d6675 3
a6677 1
	set f [open "%s" w]
d6681 1
a6681 1
    } $path(test1)]
d6698 1
a6698 1
test io-53.4 {CopyData: background write overflow} {stdio unixOnly} {
d6704 2
a6705 2
    removeFile test1
    removeFile pipe
d6749 1
a6749 1
test io-53.5 {CopyData: error during fcopy} {socket} {
d6765 1
a6765 1
test io-53.6 {CopyData: error during fcopy} {stdio} {
d6767 2
a6768 2
    removeFile pipe
    removeFile test1
d6802 1
a6802 1
test io-53.7 {CopyData: Flooding fcopy from pipe} {stdio} {
d6804 1
a6804 2
    removeFile pipe
    removeFile test1
d6837 1
a6837 1
test io-54.1 {Recursive channel events} {socket} {
d6891 1
a6891 1
test io-54.2 {Testing for busy-wait in recursive channel events} {socket} {
d6953 1
a6953 1
test io-55.1 {ChannelEventScriptInvoker: deletion} {
d6990 1
a6990 1
test io-57.1 {buffered data and file events, gets} {
d7013 1
a7013 1
test io-57.2 {buffered data and file events, read} {
d7037 1
a7037 1
test io-58.1 {Tcl_NotifyChannel and error when closing} {stdio unixOrPc} {
d7080 1
a7080 1
test io-60.1 {writing illegal utf sequences} {
d7116 1
a7116 1
	bar test2 test3 cat stdout] {
@


1.1
log
@*** empty log message ***
@
text
@@


1.1.6.1
log
@updates from HEAD, part 1
@
text
@d15 1
a15 1
# RCS: @@(#) $Id: io.test,v 1.2 2003/11/07 14:54:43 morrison Exp $
@


1.1.6.2
log
@merge from HEAD
@
text
@@


1.1.6.3
log
@merge from head
@
text
@d15 1
a15 1
# RCS: @@(#) $Id: io.test,v 1.3 2004/03/04 19:47:17 morrison Exp $
a32 3
testConstraint openpipe 1
testConstraint fileevent [llength [info commands fileevent]]
testConstraint fcopy [llength [info commands fcopy]]
d38 3
d410 1
a410 1
test io-6.7 {Tcl_GetsObj: error in input} {stdio openpipe} {
d672 1
a672 1
test io-6.31 {Tcl_GetsObj: crlf mode: buffer exhausted, blocked} {stdio testchannel openpipe fileevent} {
d811 1
a811 1
test io-6.43 {Tcl_GetsObj: input saw cr} {stdio testchannel openpipe fileevent} {
d828 1
a828 1
test io-6.44 {Tcl_GetsObj: input saw cr, not followed by cr} {stdio testchannel openpipe fileevent} {
d845 1
a845 1
test io-6.45 {Tcl_GetsObj: input saw cr, skip right number of bytes} {stdio testchannel openpipe fileevent} {
d862 1
a862 1
test io-6.46 {Tcl_GetsObj: input saw cr, followed by just \n should give eof} {stdio testchannel openpipe fileevent} {
d987 1
a987 1
test io-6.56 {Tcl_GetsObj: incomplete lines should disable file events} {stdio openpipe fileevent} {
d1047 1
a1047 1
test io-7.4 {FilterInputBytes: recover from split up character} {stdio openpipe fileevent} {
d1082 1
a1082 1
test io-8.2 {PeekAhead: only go to device if no more cached data} {stdio testchannel openpipe fileevent} {
d1102 1
a1102 1
test io-8.3 {PeekAhead: no cached data available} {stdio testchannel openpipe fileevent} {
d1135 1
a1135 1
test io-8.5 {PeekAhead: don't peek if last read was short} {stdio testchannel openpipe fileevent} {
d1147 1
a1147 1
test io-8.6 {PeekAhead: change to non-blocking mode} {stdio testchannel openpipe fileevent} {
d1159 1
a1159 1
test io-8.7 {PeekAhead: cleanup} {stdio testchannel openpipe fileevent} {
d1325 1
a1325 1
test io-12.4 {ReadChars: split-up char} {stdio testchannel openpipe fileevent} {
d1350 1
a1350 1
test io-12.5 {ReadChars: fileevents on partial characters} {stdio openpipe fileevent} {
d1445 1
a1445 1
test io-13.6 {TranslateInputEOL: auto mode: saw cr in last segment} {stdio testchannel openpipe fileevent} {
d1471 1
a1471 1
test io-13.7 {TranslateInputEOL: auto mode: naked \r} {testchannel openpipe} {
d1583 1
a1583 1
test io-14.3 {Tcl_SetStdChannel & Tcl_GetStdChannel} {exec openpipe} {
d1585 1
a1585 1
    puts -nonewline $f {
d1589 4
a1592 5
	set f  [}
    puts $f [list open $path(test1) r]]
    puts $f "set f2 \[[list open $path(test2) w]]"
    puts $f "set f3 \[[list open $path(test3) w]]"
    puts $f {	puts stdout [gets stdin]
d1598 1
a1598 1
    }
d1614 1
a1614 1
    puts -nonewline $f { close stdin
d1617 4
a1620 5
	set f  [}
    puts $f [list open $path(test1) r]]
    puts $f "set f2 \[[list open $path(test2) w]]"
    puts $f "set f3 \[[list open $path(test3) w]]"
    puts $f {	puts stdout [gets stdin]
d1626 1
a1626 1
    }
d1673 3
a1675 3
test io-14.8 {reuse of stdio special channels} {stdio openpipe} {
    file delete $path(script)
    file delete $path(test1)
d1677 1
a1677 1
    puts -nonewline $f {
d1679 1
a1679 3
	set f [}
    puts $f [list open $path(test1) w]]
    puts -nonewline $f {
d1682 1
a1682 3
	set f [}
    puts $f [list open $path(test1) r]]
    puts $f {
d1684 1
a1684 1
    }
d1692 3
a1694 3
test io-14.9 {reuse of stdio special channels} {stdio openpipe fileevent} {
    file delete $path(script)
    file delete $path(test1)
d1763 1
a1763 1
    file delete $path(test1)
d1777 1
a1777 1
    file delete $path(test1)
d1798 1
a1798 1
    file delete $path(test1)
d1821 1
a1821 1
    file delete $path(test1)
d1831 1
a1831 1
    file delete $path(test1)
d1877 1
a1877 1
test io-20.5 {Tcl_CreateChannel: install channel in empty slot} {stdio openpipe} {
d1879 1
a1879 1
    puts -nonewline $f {
d1881 1
a1881 3
	set f1 [}
    puts $f [list open $path(stdout) w]]
    puts $f {
d1884 1
a1884 1
    }
d1905 1
a1905 1
    file delete $path(test1)
d1913 1
a1913 1
    file delete $path(test1)
d1934 1
a1934 1
    file delete $path(test1)
d1945 1
a1945 1
    file delete $path(test1)
d1949 1
a1949 1
test io-26.1 {Tcl_GetChannelInstanceData} {stdio openpipe} {
d1961 1
a1961 1
    file delete $path(test1)
d1969 1
a1969 1
    file delete $path(test1)
d1982 1
a1982 1
    file delete $path(test1)
d1993 1
a1993 1
    file delete $path(test1)
d2010 1
a2010 1
    file delete $path(test1)
d2028 3
a2030 3
	{stdio asyncPipeClose openpipe} {
    file delete $path(pipe)
    file delete $path(output)
d2032 2
a2033 2
    puts $f "set f \[[list open $path(output) w]]"
    puts $f {
d2040 1
a2040 1
    }
d2068 1
a2068 1
    file delete $path(test1)
d2081 1
a2081 1
    file delete $path(test1)
d2096 3
a2098 3
	{stdio asyncPipeClose nonPortable openpipe} {
    file delete $path(pipe)
    file delete $path(output)
d2142 1
a2142 1
    file delete $path(test1)
d2154 2
a2155 2
test io-28.5 {Tcl_Close vs standard handles} {stdio unixOnly testchannel openpipe} {
    file delete $path(script)
d2172 1
a2172 1
    file delete $path(test1)
d2180 1
a2180 1
    file delete $path(test1)
d2188 1
a2188 1
    file delete $path(test1)
d2202 1
a2202 1
    file delete $path(test1)
d2216 1
a2216 1
    file delete $path(test1)
d2231 1
a2231 1
    file delete $path(test1)
d2248 1
a2248 1
    file delete $path(test1)
d2271 1
a2271 1
    file delete $path(test1)
d2283 1
a2283 1
    file delete $path(test1)
d2294 3
a2296 3
test io-29.12 {Tcl_WriteChars on a pipe} {stdio openpipe} {
    file delete $path(test1)
    file delete $path(pipe)
d2298 2
a2299 2
    puts $f1 "set f1 \[[list open $path(longfile) r]]"
    puts $f1 {
d2303 1
a2303 1
    }
d2319 3
a2321 3
test io-29.13 {Tcl_WriteChars to a pipe, line buffered} {stdio openpipe} {
    file delete $path(test1)
    file delete $path(pipe)
d2349 1
a2349 1
    file delete $path(test3)
d2361 1
a2361 1
    file delete $path(test1)
d2370 1
a2370 1
test io-29.16 {Tcl_Flush on pipe opened only for reading} {stdio openpipe} {
d2378 1
a2378 1
    file delete $path(test1)
d2390 1
a2390 1
    file delete $path(test1)
d2409 1
a2409 1
    file delete $path(test1)
d2427 1
a2427 1
    file delete $path(test1)
d2444 2
a2445 2
test io-29.21 {Tcl_Flush to pipe} {stdio openpipe} {
    file delete $path(pipe)
d2458 2
a2459 2
test io-29.22 {Tcl_Flush called at other end of pipe} {stdio openpipe} {
    file delete $path(pipe)
d2481 2
a2482 2
test io-29.23 {Tcl_Flush and line buffering at end of pipe} {stdio openpipe} {
    file delete $path(pipe)
d2516 2
a2517 2
test io-29.25 {Implicit flush with Tcl_Flush to command pipelines} {stdio openpipe fileevent} {
    file delete $path(test3)
d2528 1
a2528 1
test io-29.26 {Tcl_Flush, Tcl_Write on bidirectional pipelines} {stdio unixExecs openpipe} {
d2536 2
a2537 2
test io-29.27 {Tcl_Flush on closed pipeline} {stdio openpipe} {
    file delete $path(pipe)
d2565 1
a2565 1
    file delete $path(test1)
d2575 1
a2575 1
    file delete $path(test1)
d2583 1
a2583 1
    file delete $path(test1)
d2590 3
a2592 3
test io-29.31 {Tcl_WriteChars, background flush} {stdio openpipe} {
    file delete $path(pipe)
    file delete $path(output)
d2594 1
a2594 1
    puts $f "set f \[[list open $path(output)  w]]"
d2627 3
a2629 3
	{stdio asyncPipeClose openpipe} {
    file delete $path(pipe)
    file delete $path(output)
d2631 1
a2631 1
    puts $f "set f \[[list open $path(output) w]]"
d2666 3
a2668 2
    puts $f "set f \[[list open $path(test1) w]]"
    puts $f {fconfigure $f -translation lf
d2672 1
a2672 1
    }
d2680 1
a2680 1
test io-29.34 {Tcl_Close, async flush on close, using sockets} {socket tempNotMac fileevent} {
d2717 1
a2717 1
test io-29.35 {Tcl_Close vs fileevent vs multiple interpreters} {socket tempNotMac fileevent} {
d2762 1
a2762 1
    file delete $path(test1)
d2774 1
a2774 1
    file delete $path(test1)
d2786 1
a2786 1
    file delete $path(test1)
d2798 1
a2798 1
    file delete $path(test1)
d2810 1
a2810 1
    file delete $path(test1)
d2822 1
a2822 1
    file delete $path(test1)
d2834 1
a2834 1
    file delete $path(test1)
d2846 1
a2846 1
    file delete $path(test1)
d2858 1
a2858 1
    file delete $path(test1)
d2870 1
a2870 1
    file delete $path(test1)
d2886 1
a2886 1
    file delete $path(test1)
d2902 1
a2902 1
    file delete $path(test1)
d2919 1
a2919 1
    file delete $path(test1)
d2936 1
a2936 1
    file delete $path(test1)
d2953 1
a2953 1
    file delete $path(test1)
d2969 1
a2969 1
    file delete $path(test1)
d2985 1
a2985 1
    file delete $path(test1)
d3001 1
a3001 1
    file delete $path(test1)
d3021 1
a3021 1
    file delete $path(test1)
d3041 1
a3041 1
    file delete $path(test1)
d3063 1
a3063 1
    file delete $path(test1)
d3081 1
a3081 1
    file delete $path(test1)
d3099 1
a3099 1
    file delete $path(test1)
d3113 1
a3113 1
    file delete $path(test1)
d3127 1
a3127 1
    file delete $path(test1)
d3141 1
a3141 1
    file delete $path(test1)
d3155 1
a3155 1
    file delete $path(test1)
d3169 1
a3169 1
    file delete $path(test1)
d3186 1
a3186 1
    file delete $path(test1)
d3203 1
a3203 1
    file delete $path(test1)
d3220 1
a3220 1
    file delete $path(test1)
d3237 1
a3237 1
    file delete $path(test1)
d3255 1
a3255 1
    file delete $path(test1)
d3275 1
a3275 1
    file delete $path(test1)
d3295 1
a3295 1
    file delete $path(test1)
d3315 1
a3315 1
    file delete $path(test1)
d3335 1
a3335 1
    file delete $path(test1)
d3355 1
a3355 1
    file delete $path(test1)
d3375 1
a3375 1
    file delete $path(test1)
d3395 1
a3395 1
    file delete $path(test1)
d3415 1
a3415 1
    file delete $path(test1)
d3427 1
a3427 1
    file delete $path(test1)
d3446 1
a3446 1
    file delete $path(test1)
d3465 1
a3465 1
    file delete $path(test1)
d3483 1
a3483 1
    file delete $path(test1)
d3502 1
a3502 1
    file delete $path(test1)
d3522 1
a3522 1
    file delete $path(test1)
d3541 1
a3541 1
    file delete $path(test1)
d3560 1
a3560 1
    file delete $path(test1)
d3578 1
a3578 1
    file delete $path(test1)
d3600 1
a3600 1
    file delete $path(test1)
d3622 1
a3622 1
    file delete $path(test1)
d3644 1
a3644 1
    file delete $path(test1)
d3662 1
a3662 1
    file delete $path(test1)
d3680 1
a3680 1
    file delete $path(test1)
d3698 1
a3698 1
    file delete $path(test1)
d3716 1
a3716 1
    file delete $path(test1)
d3734 1
a3734 1
    file delete $path(test1)
d3752 1
a3752 1
    file delete $path(test1)
d3771 1
a3771 1
    file delete $path(test1)
d3871 2
a3872 2
test io-32.10 {Tcl_Read from a pipe} {stdio openpipe} {
    file delete $path(pipe)
d3883 2
a3884 2
test io-32.11 {Tcl_Read from a pipe} {stdio openpipe} {
    file delete $path(pipe)
d3903 1
a3903 1
    file delete $path(test1)
d3915 1
a3915 1
    file delete $path(test1)
d3927 1
a3927 1
    file delete $path(test1)
d3940 1
a3940 1
    file delete $path(test1)
d3953 1
a3953 1
    file delete $path(test1)
d3968 1
a3968 1
    file delete $path(test1)
d3993 2
a3994 2
test io-33.3 {Tcl_Gets from pipe} {stdio openpipe} {
    file delete $path(pipe)
d4010 1
a4010 1
    file delete $path(test3)
d4030 1
a4030 1
    file delete $path(test3)
d4107 1
a4107 1
    file delete $path(test1)
d4120 1
a4120 1
    file delete $path(test1)
d4133 1
a4133 1
    file delete $path(test1)
d4146 1
a4146 1
    file delete $path(test1)
d4160 1
a4160 1
    file delete $path(test1)
d4175 1
a4175 1
    file delete $path(test1)
d4190 1
a4190 1
test io-34.8 {Tcl_Seek on pipes: not supported} {stdio openpipe} {
d4198 1
a4198 1
    file delete $path(test3)
d4266 1
a4266 1
    file delete $path(test1)
d4273 1
a4273 1
    file delete $path(test1)
d4286 1
a4286 1
    file delete $path(test1)
d4300 1
a4300 1
test io-34.16 {Tcl_tell on pipe: always -1} {stdio openpipe} {
d4306 1
a4306 1
test io-34.17 {Tcl_Tell on pipe: always -1} {stdio openpipe} {
d4316 1
a4316 1
    file delete $path(test2)
d4362 1
a4362 1
    file delete $path(test3)
d4387 1
a4387 1
    file delete $path(test1)
d4405 2
a4406 2
test io-35.2 {Tcl_Eof with pipe} {stdio openpipe} {
    file delete $path(pipe)
d4423 2
a4424 2
test io-35.3 {Tcl_Eof with pipe} {stdio openpipe} {
    file delete $path(pipe)
d4446 1
a4446 1
    file delete $path(test1)
d4457 2
a4458 2
test io-35.5 {Tcl_Eof, eof detection on nonblocking pipe} {stdio openpipe} {
    file delete $path(pipe)
d4472 1
a4472 1
    file delete $path(test1)
d4486 1
a4486 1
    file delete $path(test1)
d4500 1
a4500 1
    file delete $path(test1)
d4514 1
a4514 1
    file delete $path(test1)
d4528 1
a4528 1
    file delete $path(test1)
d4542 1
a4542 1
    file delete $path(test1)
d4556 1
a4556 1
    file delete $path(test1)
d4571 1
a4571 1
    file delete $path(test1)
d4586 1
a4586 1
    file delete $path(test1)
d4601 1
a4601 1
    file delete $path(test1)
d4616 1
a4616 1
    file delete $path(test1)
d4631 1
a4631 1
    file delete $path(test1)
d4648 1
a4648 1
test io-36.1 {Tcl_InputBlocked on nonblocking pipe} {stdio openpipe} {
d4667 1
a4667 1
test io-36.2 {Tcl_InputBlocked on blocking pipe} {stdio openpipe} {
d4682 1
a4682 1
    file delete $path(test1)
d4697 1
a4697 1
test io-36.4 {Tcl_InputBlocked vs files, event driven read} {fileevent} {
d4704 1
a4704 1
    file delete $path(test1)
d4717 1
a4717 1
    file delete $path(test1)
d4733 1
a4733 1
test io-36.6 {Tcl_InputBlocked vs files, event driven read} {nonBlockFiles fileevent} {
d4740 1
a4740 1
    file delete $path(test1)
d4822 1
a4822 1
    file delete $path(test1)
d4832 1
a4832 1
    file delete $path(test1)
d4839 1
a4839 1
    file delete $path(test1)
d4847 1
a4847 1
    file delete $path(test1)
d4863 1
a4863 1
    file delete $path(test1)
d4873 1
a4873 1
    file delete $path(test1)
d4883 1
a4883 1
    file delete $path(test1)
d4897 1
a4897 1
    file delete $path(test1)
d4917 1
a4917 1
    file delete $path(test1)
d4932 2
a4933 2
test io-39.10 {Tcl_SetChannelOption, blocking mode} {stdio openpipe} {
    file delete $path(pipe)
d4969 1
a4969 1
    file delete $path(test1)
d4977 1
a4977 1
    file delete $path(test1)
d4985 1
a4985 1
    file delete $path(test1)
d4993 1
a4993 1
    file delete $path(test1)
d5005 1
a5005 1
    file delete $path(test1)
d5017 1
a5017 1
    file delete $path(test1)
d5023 1
a5023 1
test io-39.17 {Tcl_SetChannelOption: -encoding, clearing CHANNEL_NEED_MORE_DATA} {stdio openpipe fileevent} {
d5100 1
a5100 1
    file delete $path(test1)
d5113 1
a5113 1
    file delete $path(test1)
d5145 1
a5145 1
    file delete $path(test3)
d5160 1
a5160 1
    file delete $path(test3)
d5178 1
a5178 1
    file delete $path(test3)
d5185 1
a5185 1
    file delete $path(test3)
d5200 1
a5200 1
    file delete $path(test3)
d5220 2
a5221 2
test io-40.6 {POSIX open access modes: EXCL} -match regexp -body {
    file delete $path(test3)
d5225 5
a5229 2
    open $path(test3) {WRONLY CREAT EXCL}
} -returnCodes error -result {(?i)couldn't open ".*test3": file (already )?exists}
d5231 1
a5231 1
    file delete $path(test3)
d5239 1
a5239 1
    file delete $path(test3)
d5252 1
a5252 1
    file delete $path(test3)
d5273 12
a5284 8
test io-40.11 {POSIX open access modes: RDONLY} -match regexp -body {
    file delete $path(test3)
    open $path(test3) RDONLY
} -returnCodes error -result {(?i)couldn't open ".*test3": no such file or directory}
test io-40.12 {POSIX open access modes: WRONLY} -match regexp -body {
    file delete $path(test3)
    open $path(test3) WRONLY
} -returnCodes error -result {(?i)couldn't open ".*test3": no such file or directory}
d5297 6
a5302 4
test io-40.14 {POSIX open access modes: RDWR} -match regexp -body {
    file delete $path(test3)
    open $path(test3) RDWR
} -returnCodes error -result {(?i)couldn't open ".*test3": no such file or directory}
d5313 8
a5320 7
    test io-40.16 {tilde substitution in open} -setup {
	makeFile {Some text} _test_ ~
    } -body {
	file exists [file join $env(HOME) _test_]
    } -cleanup {
	removeFile _test_ ~
    } -result 1
d5330 1
a5330 1
test io-41.1 {Tcl_FileeventCmd: errors} {fileevent} {
d5333 1
a5333 1
test io-41.2 {Tcl_FileeventCmd: errors} {fileevent} {
d5336 1
a5336 1
test io-41.3 {Tcl_FileeventCmd: errors} {fileevent} {
d5339 1
a5339 1
test io-41.4 {Tcl_FileeventCmd: errors} {fileevent} {
d5342 1
a5342 1
test io-41.5 {Tcl_FileeventCmd: errors} {fileevent} {
d5353 1
a5353 1
test io-42.1 {Tcl_FileeventCmd: creating, deleting, querying} {fileevent} {
d5356 1
a5356 1
test io-42.2 {Tcl_FileeventCmd: replacing} {fileevent} {
d5367 1
a5367 1
test io-42.3 {Tcl_FileeventCmd: replacing, with NULL chars in script} {fileevent} {
d5382 1
a5382 1
if {[testConstraint openpipe]} {
a5384 1
}
d5386 1
a5386 1
test io-43.1 {Tcl_FileeventCmd: creating, deleting, querying} {stdio unixExecs fileevent} {
d5397 1
a5397 1
test io-43.2 {Tcl_FileeventCmd: deleting when many present} {stdio unixExecs fileevent} {
d5412 1
a5412 1
test io-44.1 {FileEventProc procedure: normal read event} {stdio unixExecs fileevent} {
d5421 1
a5421 1
test io-44.2 {FileEventProc procedure: error in read event} {stdio unixExecs fileevent} {
d5430 1
a5430 1
test io-44.3 {FileEventProc procedure: normal write event} {stdio unixExecs fileevent} {
d5445 1
a5445 1
test io-44.4 {FileEventProc procedure: eror in write event} {stdio unixExecs fileevent} {
d5453 1
a5453 1
test io-44.5 {FileEventProc procedure: end of file} {stdio unixExecs openpipe fileevent} {
d5476 1
a5476 1
test io-45.1 {DeleteFileEvent, cleanup on close} {fileevent} {
d5489 1
a5489 1
test io-45.2 {DeleteFileEvent, cleanup on close} {fileevent} {
d5506 1
a5506 1
test io-45.3 {DeleteFileEvent, cleanup on close} {fileevent} {
d5531 1
a5531 1
test io-46.1 {Tcl event loop vs multiple interpreters} {testfevent fileevent} {
d5533 2
a5534 2
    set script "set f \[[list open $path(foo) r]]\n"
    append script {
d5540 1
a5540 2
    }
    testfevent cmd $script
d5569 1
a5569 1
test io-47.1 {fileevent vs multiple interpreters} {testfevent fileevent} {
d5588 1
a5588 1
test io-47.2 {deleting fileevent on interpreter delete} {testfevent fileevent} {
d5609 1
a5609 1
test io-47.3 {deleting fileevent on interpreter delete} {testfevent fileevent} {
d5630 1
a5630 1
test io-47.4 {file events on shared files and multiple interpreters} {testfevent fileevent} {
d5646 1
a5646 1
test io-47.5 {file events on shared files, deleting file events} {testfevent fileevent} {
d5659 1
a5659 1
test io-47.6 {file events on shared files, deleting file events} {testfevent fileevent} {
d5675 1
a5675 1
test io-48.1 {testing readability conditions} {fileevent} {
d5701 1
a5701 1
test io-48.2 {testing readability conditions} {nonBlockFiles fileevent} {
d5731 1
a5731 1
test io-48.3 {testing readability conditions} {stdio unixOnly nonBlockFiles openpipe fileevent} {
d5768 2
a5769 2
    puts $f [list source $path(my_script)]
    puts $f "set f \[[list open $path(bar) r]]"
d5776 2
a5777 2
test io-48.4 {lf write, testing readability, ^Z termination, auto read mode} {fileevent} {
    file delete $path(test1)
d5804 2
a5805 2
test io-48.5 {lf write, testing readability, ^Z in middle, auto read mode} {fileevent} {
    file delete $path(test1)
d5832 2
a5833 2
test io-48.6 {cr write, testing readability, ^Z termination, auto read mode} {fileevent} {
    file delete $path(test1)
d5860 2
a5861 2
test io-48.7 {cr write, testing readability, ^Z in middle, auto read mode} {fileevent} {
    file delete $path(test1)
d5888 2
a5889 2
test io-48.8 {crlf write, testing readability, ^Z termination, auto read mode} {fileevent} {
    file delete $path(test1)
d5916 2
a5917 2
test io-48.9 {crlf write, testing readability, ^Z in middle, auto read mode} {fileevent} {
    file delete $path(test1)
d5944 2
a5945 2
test io-48.10 {lf write, testing readability, ^Z in middle, lf read mode} {fileevent} {
    file delete $path(test1)
d5972 2
a5973 2
test io-48.11 {lf write, testing readability, ^Z termination, lf read mode} {fileevent} {
    file delete $path(test1)
d6000 2
a6001 2
test io-48.12 {cr write, testing readability, ^Z in middle, cr read mode} {fileevent} {
    file delete $path(test1)
d6028 2
a6029 2
test io-48.13 {cr write, testing readability, ^Z termination, cr read mode} {fileevent} {
    file delete $path(test1)
d6056 2
a6057 2
test io-48.14 {crlf write, testing readability, ^Z in middle, crlf read mode} {fileevent} {
    file delete $path(test1)
d6084 2
a6085 2
test io-48.15 {crlf write, testing readability, ^Z termi, crlf read mode} {fileevent} {
    file delete $path(test1)
d6114 1
a6114 1
    file delete $path(test1)
d6143 1
a6143 1
    file delete $path(test1)
d6166 1
a6166 1
    file delete $path(test1)
d6187 1
a6187 1
    file delete $path(test1)
d6208 1
a6208 1
    file delete $path(test1)
d6228 1
a6228 1
    file delete $path(test1)
d6244 1
a6244 1
    file delete $path(test1)
d6262 1
a6262 1
    file delete $path(test1)
d6288 1
a6288 1
    file delete $path(test1)
d6313 1
a6313 1
    file delete $path(test1)
d6347 1
a6347 1
    file delete $path(test1)
d6429 2
a6430 2
test io-52.1 {TclCopyChannel} {fcopy} {
    file delete $path(test1)
d6439 2
a6440 2
test io-52.2 {TclCopyChannel} {fcopy} {
    file delete $path(test1)
d6451 2
a6452 2
test io-52.3 {TclCopyChannel} {fcopy} {
    file delete $path(test1)
d6468 2
a6469 2
test io-52.4 {TclCopyChannel} {fcopy} {
    file delete $path(test1)
d6480 2
a6481 2
test io-52.5 {TclCopyChannel} {fcopy} {
    file delete $path(test1)
d6497 2
a6498 2
test io-52.6 {TclCopyChannel} {fcopy} {
    file delete $path(test1)
d6514 2
a6515 2
test io-52.7 {TclCopyChannel} {fcopy} {
    file delete $path(test1)
d6531 3
a6533 3
test io-52.8 {TclCopyChannel} {stdio openpipe fcopy} {
    file delete $path(test1)
    file delete $path(pipe)
d6569 1
a6569 1
test io-52.9 {TclCopyChannel & encodings} {fcopy} {
d6600 1
a6600 1
test io-52.10 {TclCopyChannel & encodings} {fcopy} {
d6618 1
a6618 1
test io-52.11 {TclCopyChannel & encodings} {fcopy} {
d6636 3
a6638 2
test io-53.1 {CopyData} {fcopy} {
    file delete $path(test1)
d6649 2
a6650 2
test io-53.2 {CopyData} {fcopy} {
    file delete $path(test1)
d6668 3
a6670 3
test io-53.3 {CopyData: background read underflow} {stdio unixOnly openpipe fcopy} {
    file delete $path(test1)
    file delete $path(pipe)
d6672 1
a6672 1
    puts -nonewline $f1 {
d6677 1
a6677 3
	set f [}
    puts $f1 [list open $path(test1) w]]
    puts $f1 {
d6681 1
a6681 1
    }
d6698 1
a6698 1
test io-53.4 {CopyData: background write overflow} {stdio unixOnly openpipe fileevent fcopy} {
d6704 2
a6705 2
    file delete $path(test1)
    file delete $path(pipe)
d6749 1
a6749 1
test io-53.5 {CopyData: error during fcopy} {socket fcopy} {
d6765 1
a6765 1
test io-53.6 {CopyData: error during fcopy} {stdio openpipe fcopy} {
d6767 2
a6768 2
    file delete $path(pipe)
    file delete $path(test1)
d6802 1
a6802 1
test io-53.7 {CopyData: Flooding fcopy from pipe} {stdio openpipe fcopy} {
d6804 2
a6805 1
    file delete $path(pipe)
d6838 1
a6838 1
test io-54.1 {Recursive channel events} {socket fileevent} {
d6892 1
a6892 1
test io-54.2 {Testing for busy-wait in recursive channel events} {socket fileevent} {
d6954 1
a6954 1
test io-55.1 {ChannelEventScriptInvoker: deletion} {fileevent} {
d6991 1
a6991 1
test io-57.1 {buffered data and file events, gets} {fileevent} {
d7014 1
a7014 1
test io-57.2 {buffered data and file events, read} {fileevent} {
d7038 1
a7038 1
test io-58.1 {Tcl_NotifyChannel and error when closing} {stdio unixOrPc openpipe fileevent} {
d7081 1
a7081 1
test io-60.1 {writing illegal utf sequences} {openpipe fileevent} {
d7117 1
a7117 1
	bar test2 test3 cat stdout kyrillic.txt utf8-fcopy.txt utf8-rp.txt] {
@


1.1.6.4
log
@merge from head...
@
text
@d15 1
a15 1
# RCS: @@(#) $Id: io.test,v 1.1.6.3 2004/03/15 12:10:33 erikg Exp $
@


