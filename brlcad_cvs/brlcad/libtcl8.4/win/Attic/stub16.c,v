head	1.4;
access;
symbols
	ansi-20040405-merged:1.3.4.1
	postmerge-20040405-ansi:1.3
	premerge-20040404-ansi:1.3
	postmerge-autoconf:1.3
	autoconf-freeze:1.1.6.4
	premerge-autoconf:1.3
	postmerge-20040315-windows:1.3
	premerge-20040315-windows:1.3
	windows-20040315-freeze:1.3.2.1
	autoconf-20031203:1.1.6.1
	autoconf-20031202:1.1
	autoconf-branch:1.1.0.6
	phong-branch:1.1.0.4
	photonmap-branch:1.1.0.2
	windows-branch:1.3.0.2
	ansi-branch:1.3.0.4;
locks; strict;
comment	@ * @;


1.4
date	2004.05.21.18.05.18;	author morrison;	state dead;
branches;
next	1.3;

1.3
date	2004.03.04.19.47.24;	author morrison;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2003.11.07.14.54.50;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.13.19.18.50;	author jra;	state Exp;
branches
	1.1.6.1;
next	;

1.1.6.1
date	2003.12.03.16.24.56;	author erikg;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2004.02.12.18.50.49;	author erikg;	state Exp;
branches;
next	1.1.6.3;

1.1.6.3
date	2004.03.15.12.07.31;	author erikg;	state Exp;
branches;
next	1.1.6.4;

1.1.6.4
date	2004.03.15.14.01.36;	author erikg;	state Exp;
branches;
next	;

1.3.2.1
date	2004.03.12.09.59.34;	author morrison;	state Exp;
branches;
next	;

1.3.4.1
date	2004.03.17.21.20.17;	author morrison;	state Exp;
branches;
next	;


desc
@@


1.4
log
@moved from top-level to src/other/.
@
text
@/* 
 * stub16.c 
 *
 *	A helper program used for running 16-bit DOS applications under
 *	Windows 95.
 *
 * Copyright (c) 1996 by Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: stub16.c,v 1.3 2004/03/04 19:47:24 morrison Exp $
 */

#define STRICT

#include <windows.h>
#include <stdio.h>

static HANDLE		CreateTempFile(void);

/*
 *---------------------------------------------------------------------------
 *
 * main
 *
 *	Entry point for the 32-bit console mode app used by Windows 95 to
 *	help run the 16-bit program specified on the command line.
 *
 *	1. EOF on a pipe that connects a detached 16-bit process and a
 *	32-bit process is never seen.  So, this process runs the 16-bit
 *	process _attached_, and then it is run detached from the calling
 *	32-bit process.  
 * 
 *	2. If a 16-bit process blocks reading from or writing to a pipe,
 *	it never wakes up, and eventually brings the whole system down
 *	with it if you try to kill the process.  This app simulates
 *	pipes.  If any of the stdio handles is a pipe, this program
 *	accumulates information into temp files and forwards it to or
 *	from the DOS application as appropriate.  This means that this
 *	program must receive EOF from a stdin pipe before it will actually
 *	start the DOS app, and the DOS app must finish generating stdout
 *	or stderr before the data will be sent to the next stage of the
 *	pipe.  If the stdio handles are not pipes, no accumulation occurs
 *	and the data is passed straight through to and from the DOS
 *	application.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The child process is created and this process waits for it to
 *	complete.
 *
 *---------------------------------------------------------------------------
 */

int
main()
{
    DWORD dwRead, dwWrite;
    char *cmdLine;
    HANDLE hStdInput, hStdOutput, hStdError;
    HANDLE hFileInput, hFileOutput, hFileError;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    char buf[8192];
    DWORD result;

    hFileInput = INVALID_HANDLE_VALUE;
    hFileOutput = INVALID_HANDLE_VALUE;
    hFileError = INVALID_HANDLE_VALUE;
    result = 1;

    /*
     * Don't get command line from argc, argv, because the command line
     * tokenizer will have stripped off all the escape sequences needed
     * for quotes and backslashes, and then we'd have to put them all
     * back in again.  Get the raw command line and parse off what we
     * want ourselves.  The command line should be of the form:
     *
     * stub16.exe program arg1 arg2 ...
     */

    cmdLine = strchr(GetCommandLine(), ' ');
    if (cmdLine == NULL) {
	return 1;
    }
    cmdLine++;

    hStdInput = GetStdHandle(STD_INPUT_HANDLE);
    hStdOutput = GetStdHandle(STD_OUTPUT_HANDLE);
    hStdError = GetStdHandle(STD_ERROR_HANDLE);

    if (GetFileType(hStdInput) == FILE_TYPE_PIPE) {
	hFileInput = CreateTempFile();
	if (hFileInput == INVALID_HANDLE_VALUE) {
	    goto cleanup;
	}
	while (ReadFile(hStdInput, buf, sizeof(buf), &dwRead, NULL) != FALSE) {
	    if (dwRead == 0) {
		break;
	    }
	    if (WriteFile(hFileInput, buf, dwRead, &dwWrite, NULL) == FALSE) {
		goto cleanup;
	    }
	}
	SetFilePointer(hFileInput, 0, 0, FILE_BEGIN);
	SetStdHandle(STD_INPUT_HANDLE, hFileInput);
    }
    if (GetFileType(hStdOutput) == FILE_TYPE_PIPE) {
	hFileOutput = CreateTempFile();
	if (hFileOutput == INVALID_HANDLE_VALUE) {
	    goto cleanup;
	}
	SetStdHandle(STD_OUTPUT_HANDLE, hFileOutput);
    }
    if (GetFileType(hStdError) == FILE_TYPE_PIPE) {
	hFileError = CreateTempFile();
	if (hFileError == INVALID_HANDLE_VALUE) {
	    goto cleanup;
	}
	SetStdHandle(STD_ERROR_HANDLE, hFileError);
    }

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    if (CreateProcess(NULL, cmdLine, NULL, NULL, TRUE, 0, NULL, NULL, &si, 
	    &pi) == FALSE) {
	goto cleanup;
    }

    WaitForInputIdle(pi.hProcess, 5000);
    WaitForSingleObject(pi.hProcess, INFINITE);
    GetExitCodeProcess(pi.hProcess, &result);
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    if (hFileOutput != INVALID_HANDLE_VALUE) {
	SetFilePointer(hFileOutput, 0, 0, FILE_BEGIN);
	while (ReadFile(hFileOutput, buf, sizeof(buf), &dwRead, NULL) != FALSE) {
	    if (dwRead == 0) {
		break;
	    }
	    if (WriteFile(hStdOutput, buf, dwRead, &dwWrite, NULL) == FALSE) {
		break;
	    }
	}
    }
    if (hFileError != INVALID_HANDLE_VALUE) {
	SetFilePointer(hFileError, 0, 0, FILE_BEGIN);
	while (ReadFile(hFileError, buf, sizeof(buf), &dwRead, NULL) != FALSE) {
	    if (dwRead == 0) {
		break;
	    }
	    if (WriteFile(hStdError, buf, dwRead, &dwWrite, NULL) == FALSE) {
		break;
	    }
	}
    }

cleanup:
    if (hFileInput != INVALID_HANDLE_VALUE) {
	CloseHandle(hFileInput);
    }
    if (hFileOutput != INVALID_HANDLE_VALUE) {
	CloseHandle(hFileOutput);
    }
    if (hFileError != INVALID_HANDLE_VALUE) {
	CloseHandle(hFileError);
    }
    CloseHandle(hStdInput);
    CloseHandle(hStdOutput);
    CloseHandle(hStdError);
    ExitProcess(result);
    return 1;
}

static HANDLE
CreateTempFile()
{
    char name[MAX_PATH];
    SECURITY_ATTRIBUTES sa;

    if (GetTempPath(sizeof(name), name) == 0) {
	return INVALID_HANDLE_VALUE;
    }
    if (GetTempFileName(name, "tcl", 0, name) == 0) {
	return INVALID_HANDLE_VALUE;
    }

    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = TRUE;
    return CreateFile(name, GENERIC_READ | GENERIC_WRITE, 0, &sa, 
	    CREATE_ALWAYS, FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE,
	    NULL);
}
@


1.3
log
@Updated to tcl 8.4.6
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: stub16.c,v 1.4 1999/04/21 21:50:34 rjohnson Exp $
@


1.3.4.1
log
@sync branch with HEAD
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id$
@


1.3.2.1
log
@merge from HEAD
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id$
@


1.2
log
@updated tcl to 8.4.4
@
text
@@


1.1
log
@*** empty log message ***
@
text
@@


1.1.6.1
log
@updates from HEAD, part 1
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: stub16.c,v 1.2 2003/11/07 14:54:50 morrison Exp $
@


1.1.6.2
log
@merge from HEAD
@
text
@@


1.1.6.3
log
@merge from head
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: stub16.c,v 1.3 2004/03/04 19:47:24 morrison Exp $
@


1.1.6.4
log
@merge from head...
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: stub16.c,v 1.1.6.3 2004/03/15 12:07:31 erikg Exp $
@


