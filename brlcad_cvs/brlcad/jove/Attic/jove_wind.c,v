head	11.6;
access;
symbols
	ansi-20040405-merged:11.5
	postmerge-20040405-ansi:11.5
	premerge-20040404-ansi:11.5
	postmerge-autoconf:11.5
	autoconf-freeze:11.5
	premerge-autoconf:11.5
	ansi-20040316-freeze:11.5
	postmerge-20040315-windows:11.5
	premerge-20040315-windows:11.5
	windows-20040315-freeze:11.5
	autoconf-20031203:11.5
	autoconf-20031202:11.5
	autoconf-branch:11.5.0.12
	phong-branch:11.5.0.10
	photonmap-branch:11.5.0.8
	rel-6-1-DP:11.5
	windows-branch:11.5.0.6
	rel-6-0-2:11.5
	ansi-branch:11.5.0.4
	rel-6-0-1-branch:11.5.0.2
	hartley-6-0-post:11.5
	hartley-6-0-pre:11.5
	rel-6-0-1:11.5
	rel-6-0:11.5
	rel-5-4:11.4
	offsite-5-3-pre:11.5
	rel-5-3:11.4
	rel-5-2:11.4
	rel-5-1-branch:11.4.0.2
	rel-5-1:11.4
	rel-5-0:11.4
	rel-5-0-beta:11.4
	rel-4-5:11.3
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:2.0
	rel-3-0:2.0
	rel-2-3:2.0
	rel-2-0:2.0
	rel-1-24:2.0
	rel-1-20:2.0
	rel-1-10:2.0
	rt-2:2.0
	rt:1.2;
locks; strict;
comment	@ * @;


11.6
date	2004.05.21.17.48.34;	author morrison;	state dead;
branches;
next	11.5;

11.5
date	2000.08.24.23.12.25;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	98.06.17.03.11.32;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	97.01.03.17.42.17;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.06.21.03.46.08;	author gwyn;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.35.25;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	93.10.26.05.25.22;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.54.07;	author mike;	state Rel4_0;
branches;
next	2.4;

2.4
date	91.09.23.03.15.30;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	91.08.30.19.17.49;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	91.08.30.18.11.09;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	91.08.30.17.54.41;	author mike;	state Exp;
branches;
next	2.0;

2.0
date	84.12.26.16.49.18;	author dpk;	state Exp;
branches;
next	1.2;

1.2
date	83.12.16.00.09.58;	author dpk;	state BRL;
branches;
next	1.1;

1.1
date	83.12.16.00.09.54;	author dpk;	state Exp;
branches;
next	;


desc
@Jove is an EMACS like screen editor which will fit on 11's and Vaxen
@


11.6
log
@moved to src/other/jove/
@
text
@/*
 *			J O V E _ W I N D . C
 *
 * $Revision: 11.5 $
 *
 * $Log: jove_wind.c,v $
 * Revision 11.5  2000/08/24 23:12:25  mike
 *
 * lint, RCSid
 *
 * Revision 11.4  1998/06/17  03:11:32  mike
 * getwind() didn't zero the malloc()'ed structure.
 *
 * Revision 11.3  1997/01/03 17:42:17  jra
 * Mods for Irix 6.2
 *
 * Revision 11.2  1995/06/21  03:46:08  gwyn
 * Eliminated trailing blanks.
 *
 * Revision 11.1  95/01/04  10:35:25  mike
 * Release_4.4
 *
 * Revision 10.2  93/10/26  05:25:22  mike
 * ANSI C
 *
 * Revision 10.1  91/10/12  06:54:07  mike
 * Release_4.0
 *
 * Revision 2.4  91/09/23  03:15:30  mike
 * two  return / return(expr) warnings
 *
 * Revision 2.3  91/08/30  19:17:49  mike
 * Stardent ANSI lint
 *
 * Revision 2.2  91/08/30  18:11:09  mike
 * Made explicit that termcap.h to be used is the local version
 *
 * Revision 2.1  91/08/30  17:54:41  mike
 * Changed #include directives to distinguish between local and system header
 * files.
 *
 * Revision 2.0  84/12/26  16:49:18  dpk
 * System as distributed to Berkeley 26 Dec 84
 *
 * Revision 1.2  83/12/16  00:09:58  dpk
 * Added distinctive RCS header
 *
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/jove/jove_wind.c,v 11.5 2000/08/24 23:12:25 mike Exp $";
#endif

/*
   Jonathan Payne at Lincoln-Sudbury Regional High School 5-25-83

   jove_wind.c

   This creates/deletes/divides/grows/shrinks windows.  */

#include "./jove.h"
#include "./termcap.h"

char	onlyone[] = "You only have one window!";
char	toosmall[] = "too small";

void	winit();
void	PrevWindow();
void	SetWind();

/* First line in a window */
int
FLine(w)
WINDOW	*w;
{
	WINDOW	*wp = fwind;
	int	lineno = -1;

	do {
		if (wp == w)
			return lineno + 1;
		lineno += wp->w_height;
		wp = wp->w_next;
	} while (wp != fwind);
	complain("WINDOW?");
	/* NOTREACHED */
	return 0;
}

void
initwinds(b)
BUFFER	*b;
{
	WINDOW	*wp = fwind;

	do {
		if (wp->w_bufp == b) {
			SetTop(wp, (wp->w_line = b->b_dot));
			zero_wind(wp);
		}
		wp = wp->w_next;
	} while (wp != fwind);
}

/* Return last window on the screen */

WINDOW *
lastwind()
{
	WINDOW *wp = fwind;

	do {
		if (wp->w_next == fwind)
			return wp;
		wp = wp->w_next;
	} while (wp != fwind);
	return fwind;
}

WINDOW *

getwind()
{
	WINDOW	*wp;

	wp = (WINDOW *)emalloc(sizeof (WINDOW));
	memset( (char *)wp, '\0', sizeof (WINDOW) );
	return wp;
}

/* Delete `wp' from the screen.  If it is the only window left
 * on the screen, then complain via error.  It gives its body
 * to the next window if there is one, otherwise the previous
 * window gets the body.  Resets link list and fwind if necessary.
 */

void
del_wind(wp)
WINDOW	*wp;
{
	WINDOW	*last = lastwind(),
		*prev = wp->w_prev;

	if (wp->w_next == wp)
		complain(onlyone);

	wp->w_prev->w_next = wp->w_next;
	wp->w_next->w_prev = wp->w_prev;

	if (fwind == wp) {
		fwind = wp->w_next;
		fwind->w_height += wp->w_height;
	} else if (wp == last)
		last->w_prev->w_height += wp->w_height;
	else
		prev->w_height += wp->w_height;
	if (curwind == wp)
		SetWind(prev);
	free((char *) wp);
}

/* Divide the `wp'.  Complains if `wp' is too small to be split.
 * It returns the new window
 */

WINDOW *
div_wind(wp)
WINDOW	*wp;
{
	WINDOW	*new;

	if (wp->w_height < 4)
		complain(toosmall);

	new = getwind();
	new->w_offset = 0;
	new->w_numlines = 0;
	/* Reset the window bounds */
	new->w_height = (wp->w_height / 2);
	wp->w_height -= new->w_height;

	/* Set the lines such that w_line is the center in each window */
	new->w_line = wp->w_line;
	new->w_bufp = wp->w_bufp;
	new->w_top = prev_line(new->w_line, HALF(new));

	/* Link the new window into the list */
	new->w_prev = wp;
	new->w_next = wp->w_next;
	new->w_next->w_prev = new;
	wp->w_next = new;
	return new;
}

/* Return one window previous to `wp'.  If at the first window
 * on screen, then go to the last window
 */

WINDOW *
prev_wind(wp)
WINDOW	*wp;
{
	return wp->w_prev;
}

/* Next window from `wp' */

WINDOW *
next_wind(wp)
WINDOW	*wp;
{
	return wp->w_next;
}

/* Initialze the first window setting the bounds to the size of the
 * screen.  There is no buffer with this window.  See parse for the
 * setting of this window.
 */
void
winit()
{
	curwind = fwind = getwind();

	curwind->w_line = curwind->w_top = (LINE *) 0;
	curwind->w_char = 0;
	curwind->w_next = curwind->w_prev = fwind;
	curwind->w_height = LI - 1;
}

/* Change window into the previous window.  curwind becomes the new
 * window
 */
void
PrevWindow()
{
	WINDOW	*new = prev_wind(curwind);

	if (new == curwind)
		complain(onlyone);
	SetWind(new);
}

/* Make new the current window */
void
SetWind(new)
WINDOW	*new;
{
	if (new == curwind)
		return;
	curwind->w_line = curline;
	curwind->w_char = curchar;
	curwind->w_bufp = curbuf;
	SetBuf(new->w_bufp);
	if (!inlist(new->w_bufp->b_zero, new->w_line)) {
		new->w_line = curline;
		new->w_char = curchar;
	}
	DotTo(new->w_line, new->w_char);
	if (curchar > (int)strlen(linebuf))
		new->w_char = curchar = strlen(linebuf);
	curwind = new;
}

/* Delete the current window if it isn't the only one left */

void
DelCurWindow()
{
	del_wind(curwind);
}

/* Return the number of windows being displayed right now */

numwindows()
{
	WINDOW	*wp = fwind;
	int	num = 0;

	do {
		num++;
		wp = wp->w_next;
	} while (wp != fwind);
	return num;
}

void
WindFind()
{
	char	*fname = ask((char *) 0, FuncName());
	BUFFER	*buf;

	if (buf = file_exists(fname))
		pop_wind(buf->b_name, 0);
	else {
		if (numwindows() == 1)
			curwind = div_wind(curwind);
		else
			curwind = next_wind(curwind);
		SetBuf(do_find(curwind, fname));
	}
}

/* Go into one window mode by deleting all the other windows */

void
OneWindow()
{
	while (curwind->w_next != curwind)
		del_wind(curwind->w_next);
}

/* Look for a window containing a buffer whose name is `name' */

WINDOW *
windlook(name)
char	*name;
{
	BUFFER	*bp = (BUFFER *) buf_exists(name);
	WINDOW	*wp = fwind;

	if (bp == 0)
		return 0;
	do {
		if (wp->w_bufp == bp)
			return wp;
		wp = wp->w_next;
	} while (wp != fwind);
	return 0;
}

/* Change window into the next window.  curwind becomes the new
 * window
 */

void
NextWindow()
{
	WINDOW	*new = next_wind(curwind);

	if (new == curwind)
		complain(onlyone);
	SetWind(new);
}

/* Scroll the next window */

void
PageNWind()
{
	if (numwindows() == 1)
		complain(onlyone);
	NextWindow();
	NextPage();
	PrevWindow();
}

/* Put a window with the buffer `name' in it.  Erase the buffer if
 * `clobber' is non-zero.
 */

void
pop_wind(name, clobber)
char	*name;
{
	WINDOW	*wp;
	BUFFER	*newb;

	if ((wp = windlook(name)) == 0) {
		if (numwindows() == 1)
			SplitWind();
		else
			PrevWindow();
	} else
		SetWind(wp);

	newb = do_select((WINDOW *) 0, name);
	if (clobber)
		initlist(newb);
	tiewind(curwind, newb);
	SetBuf(newb);
}

void
GrowWindow()
{
	WindSize(curwind, abs(exp));
}

void
ShrWindow()
{
	WindSize(curwind, -abs(exp));
}

/* Change the size of the window by inc.  First arg is the window,
 * second is the increment.
 */

void
WindSize(w, inc)
register WINDOW	*w;
{
	if (numwindows() == 1)
		complain(onlyone);

	if (inc < 0) {	/* Shrinking this window */
		if (w->w_height + inc < 2)
			complain(toosmall);
		w->w_height += inc;
		w->w_prev->w_height -= inc;
	} else
		WindSize(w->w_next, -inc);
}

/* Set the topline of the window, calculating its number in the buffer.
 * This is for numbering the lines only.
 */

void
SetTop(w, line)
WINDOW	*w;
register LINE	*line;
{
	register LINE	*lp = w->w_bufp->b_zero;
	register int	num = 0;

	w->w_top = line;
	if (w->w_numlines)
		while (lp) {
			num++;
			if (line == lp)
				break;
			lp = lp->l_next;
		}
	w->w_topnum = num;
}

void
WNumLines()
{
	zero_wind(curwind);
	/* So the redisplay will know to update the screen even if it
	 * looks like there are no differences.
	 */

	curwind->w_numlines = !curwind->w_numlines;
	SetTop(curwind, curwind->w_top);
}

void
zero_wind(wp)
register WINDOW	*wp;
{
	register int	i,
			upper;

	upper = FLine(wp);
	for (i = 0; i < wp->w_height; i++)
		oimage[upper + i].Line = (LINE *) -1;
}

/* Return the line number that `line' occupies in `windes' */

in_window(windes, line)
register WINDOW	*windes;
register LINE	*line;
{
	register int	i;
	LINE	*top = windes->w_top;

	for (i = 0; top && i < windes->w_height - 1; i++, top = top->l_next)
		if (top == line)
			return FLine(windes) + i;
	return -1;
}
@


11.5
log
@
lint, RCSid
@
text
@d4 1
a4 1
 * $Revision: 11.4 $
d7 4
d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/jove/jove_wind.c,v 11.4 1998/06/17 03:11:32 mike Exp $";
@


11.4
log
@getwind() didn't zero the malloc()'ed structure.
@
text
@d4 1
a4 1
 * $Revision: 11.3 $
d7 3
d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_wind.c,v 11.3 1997/01/03 17:42:17 jra Exp mike $";
@


11.3
log
@Mods for Irix 6.2
@
text
@d4 1
a4 1
 * $Revision: 11.2 $
d7 3
d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_wind.c,v 11.2 1995/06/21 03:46:08 gwyn Exp jra $";
d119 1
@


11.2
log
@Eliminated trailing blanks.
@
text
@d4 1
a4 1
 * $Revision: 11.1 $
d6 4
a9 1
 * $Log:	jove_wind.c,v $
d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_wind.c,v 11.1 95/01/04 10:35:25 mike Rel4_4 $";
d79 1
d125 1
d254 1
d274 1
d293 1
d323 1
d335 1
d349 1
d371 1
d377 1
d387 1
d407 1
d426 1
d438 1
@


11.1
log
@Release_4.4
@
text
@d2 1
a2 1
 *			J O V E _ W I N D . C 
d4 1
a4 1
 * $Revision: 10.2 $
d7 3
d12 1
a12 1
 * 
d15 1
a15 1
 * 
d18 1
a18 1
 * 
d21 1
a21 1
 * 
d24 1
a24 1
 * 
d28 1
a28 1
 * 
d31 1
a31 1
 * 
d34 1
a34 1
 * 
d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_wind.c,v 10.2 93/10/26 05:25:22 mike Exp $";
d110 1
a110 1
	
d132 1
a132 1
	
@


10.2
log
@ANSI C
@
text
@d4 1
a4 1
 * $Revision: 10.1 $
d7 3
d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_wind.c,v 10.1 91/10/12 06:54:07 mike Rel4_0 Locker: mike $";
@


10.1
log
@Release_4.0
@
text
@d4 1
a4 1
 * $Revision: 2.4 $
d7 3
d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_wind.c,v 2.4 91/09/23 03:15:30 mike Exp $";
d47 4
d52 1
a52 1

d196 1
a196 1

d210 1
a210 1

d221 1
a221 1

@


2.4
log
@two  return / return(expr) warnings
@
text
@d4 1
a4 1
 * $Revision: 2.3 $
d7 3
d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_wind.c,v 2.3 91/08/30 19:17:49 mike Exp $";
@


2.3
log
@Stardent ANSI lint
@
text
@d4 1
a4 1
 * $Revision: 2.2 $
d7 3
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_wind.c,v 2.2 91/08/30 18:11:09 mike Exp $";
d57 1
d86 1
a86 1
    /* NOTREACHED */
@


2.2
log
@Made explicit that termcap.h to be used is the local version
@
text
@d4 1
a4 1
 * $Revision: 2.1 $
d7 3
d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_wind.c,v 2.1 91/08/30 17:54:41 mike Exp $";
d222 1
a222 1
	if (curchar > strlen(linebuf))
@


2.1
log
@Changed #include directives to distinguish between local and system header
files.
@
text
@d4 1
a4 1
 * $Revision: 2.0 $
d7 4
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: jove_wind.c,v 2.0 84/12/26 16:49:18 dpk Exp $";
d30 1
a30 1
#include <termcap.h>
@


2.0
log
@System as distributed to Berkeley 26 Dec 84
@
text
@d4 1
a4 1
 * $Revision: 1.2 $
d7 3
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: jove_wind.c,v 1.2 83/12/16 00:09:58 dpk BRL $";
d25 2
a26 2
#include "jove.h"
#include "termcap.h"
@


1.2
log
@Added distinctive RCS header
@
text
@d4 1
a4 1
 * $Revision$
d6 4
a9 1
 * $Log$
d12 1
a12 1
static char RCSid[] = "@@(#)$Header$";
@


1.1
log
@Original 4.2 Distribution Source
@
text
@d2 11
@
