head	11.5;
access;
symbols
	ansi-20040405-merged:11.4
	postmerge-20040405-ansi:11.4
	premerge-20040404-ansi:11.4
	postmerge-autoconf:11.4
	autoconf-freeze:11.4
	premerge-autoconf:11.4
	ansi-20040316-freeze:11.4
	postmerge-20040315-windows:11.4
	premerge-20040315-windows:11.4
	windows-20040315-freeze:11.4
	autoconf-20031203:11.4
	autoconf-20031202:11.4
	autoconf-branch:11.4.0.12
	phong-branch:11.4.0.10
	photonmap-branch:11.4.0.8
	rel-6-1-DP:11.4
	windows-branch:11.4.0.6
	rel-6-0-2:11.4
	ansi-branch:11.4.0.4
	rel-6-0-1-branch:11.4.0.2
	hartley-6-0-post:11.4
	hartley-6-0-pre:11.4
	rel-6-0-1:11.4
	rel-6-0:11.4
	rel-5-4:11.3
	offsite-5-3-pre:11.4
	rel-5-3:11.3
	rel-5-2:11.3
	rel-5-1-branch:11.3.0.2
	rel-5-1:11.3
	rel-5-0:11.3
	rel-5-0-beta:11.3
	rel-4-5:11.3
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:2.2
	rel-3-0:2.2
	rel-2-3:2.2
	rel-2-0:2.2
	rel-1-24:2.2
	rel-1-20:2.1
	rel-1-10:2.1
	rt-2:2.0
	rt:1.2;
locks; strict;
comment	@ * @;


11.5
date	2004.05.21.17.48.32;	author morrison;	state dead;
branches;
next	11.4;

11.4
date	2000.08.24.23.12.23;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	97.01.03.17.42.17;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.06.21.03.40.53;	author gwyn;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.35.13;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	93.10.26.06.06.44;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	93.10.26.03.45.31;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.53.57;	author mike;	state Rel4_0;
branches;
next	2.6;

2.6
date	91.09.23.03.08.17;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	91.08.30.18.59.47;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	91.08.30.17.54.32;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	91.08.30.17.49.05;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	87.04.14.20.18.43;	author dpk;	state BRL;
branches;
next	2.1;

2.1
date	86.04.13.22.02.57;	author gwyn;	state Exp;
branches;
next	2.0;

2.0
date	84.12.26.16.46.04;	author dpk;	state Exp;
branches;
next	1.2;

1.2
date	83.12.16.00.07.57;	author dpk;	state BRL;
branches;
next	1.1;

1.1
date	83.12.16.00.07.53;	author dpk;	state Exp;
branches;
next	;


desc
@Jove is an EMACS like screen editor which will fit on 11's and Vaxen
@


11.5
log
@moved to src/other/jove/
@
text
@/*
 *			J O V E _ E X T E N D . C
 *
 * $Revision: 11.4 $
 *
 * $Log: jove_extend.c,v $
 * Revision 11.4  2000/08/24 23:12:23  mike
 *
 * lint, RCSid
 *
 * Revision 11.3  1997/01/03  17:42:17  jra
 * Mods for Irix 6.2
 *
 * Revision 11.2  1995/06/21  03:40:53  gwyn
 * Eliminated trailing blanks.
 * RunEdit() now returns null pointer upon ^G abort; was nonportable (char*)-1.
 * Findcom is now an array rather than pointer to (unmodifiable) string literal.
 * Must cast 0 when used as null pointer constant in argument list.
 *
 * Revision 11.1  95/01/04  10:35:13  mike
 * Release_4.4
 *
 * Revision 10.3  93/10/26  06:06:44  mike
 * Changed getchar() to jgetchar() to avoid stdio.h conflict.
 *
 * Revision 10.2  93/10/26  03:45:31  mike
 * ANSI C
 *
 * Revision 10.1  91/10/12  06:53:57  mike
 * Release_4.0
 *
 * Revision 2.6  91/09/23  03:08:17  mike
 * Eliminated return / return(expr) warning
 *
 * Revision 2.5  91/08/30  18:59:47  mike
 * Modifications for clean compilation on the XMP
 *
 * Revision 2.4  91/08/30  17:54:32  mike
 * Changed #include directives to distinguish between local and system header
 * files.
 *
 * Revision 2.3  91/08/30  17:49:05  mike
 * Paul Stay mods for ANSI C
 *
 * Revision 2.2  87/04/14  20:18:43  dpk
 * Fixed casting on RunEdit call
 *
 * Revision 2.1  86/04/13  22:02:57  gwyn
 * fixed getchar type bug
 *
 * Revision 2.0  84/12/26  16:46:04  dpk
 * System as distributed to Berkeley 26 Dec 84
 *
 * Revision 1.2  83/12/16  00:07:57  dpk
 * Added distinctive RCS header
 *
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/jove/jove_extend.c,v 11.4 2000/08/24 23:12:23 mike Exp $";
#endif

/*
   Jonathan Payne at Lincoln-Sudbury Regional High School 4-19-83

   jove_extend.c

   This contains the TENEX style command completion routine and
   various random routines.  This is not well organized...use the
   tags feature of jove to find your way around...  */

#include "./jove.h"

int	InJoverc = 0;

extern char	Findcom[];
extern int	getch(),
		jgetchar();

void		BindSomething();
void		DoKeyDesc();

min(a, b)
{
	return a < b ? a : b;
}

void
BindAKey()
{
	BindSomething(functions);
}

void
BindMac()
{
	BindSomething(macros);
}

void
BindSomething(funcs)
struct function	*funcs;
{
	char	*prompt;
	int	c,
		command;

	prompt = FuncName();
	command = findcom(funcs, prompt);
	s_mess("%s%s ", prompt, funcs[command].f_name);
	Asking = strlen(mesgbuf);
	if ((c = (*Getchar)()) == EOF)
		return;
	s_mess("%s%s %c%s", prompt, funcs[command].f_name, c,
				(c == '\033' || c == CTL('X')) ? "-" : "");
	Asking = strlen(mesgbuf);
	if (c != '\033' && c != CTL('X'))
		mainmap[c] = &funcs[command];
	else {
		int	next = (*Getchar)();

		if (next == EOF)
			return;
		ignore(sprintf(&mesgbuf[strlen(mesgbuf)], "%c", next));
		if (c == CTL('X'))
			pref2map[next] = &funcs[command];
		else
			pref1map[next] = &funcs[command];
	}
	Asking = 0;
}

void
UnBound()
{
	Beep();
}

/* Describe key */

extern int	EscPrefix(),
		CtlxPrefix();

void
KeyDesc()
{
	int	key;

	s_mess(FuncName());
	UpdateMesg();
	key = jgetchar();
	if (mainmap[key]->f.Func == EscPrefix)
		DoKeyDesc(pref1map, key);
	else if (mainmap[key]->f.Func == CtlxPrefix)
		DoKeyDesc(pref2map, key);
	else if (mainmap[key]->f.Func)
		s_mess("%c is bound to %s", key, mainmap[key]->f_name);
	else
		s_mess("%c is unbound", key);
}

void
DoKeyDesc(map, key)
struct function	**map;
{
	int	c;

	s_mess("%s%c-", FuncName(), key);
	UpdateMesg();
	c = jgetchar();
	s_mess("%s%c-%c", FuncName(), key, c);
	if (map[c] == 0)
		s_mess("%c-%c is unbound", key, c);
	else
		s_mess("%c-%c is bound to %s", key, c, map[c]->f_name);
	return;
}

void
DescCom()
{
	int	com;
	struct function	*fp;
	WINDOW	*savewp = curwind;

	com = findcom(functions, FuncName());
	if (com < 0)
		complain("No such command");
	fp = &functions[com];
	ignore(UnixToBuf("Command Description", 0, exp_p == 0,
					Findcom,
					"describe",
					fp->f_name, (char *)0));
	message("Done");
	SetWind(savewp);
}

void
Beep()
{
	extern int	errormsg;

	message("");
	rbell();		/* Ring the bell (or flash) */
	errormsg = 0;
}

void
Apropos()
{
	register struct function	*fp;
	char	*ans;

	ans = ask((char *) 0, "Apropos (keyword) ");
	if (UseBuffers) {
		TellWBuffers("Apropos", 0);
		SetScratch(curwind->w_bufp);
	} else
		TellWScreen(0);
	for (fp = functions; fp->f_name; fp++)
		if (sindex(ans, fp->f_name))
			ignore(DoTell(fp->f_name));

	for (fp = variables; fp->f_name; fp++)
		if (sindex(ans, fp->f_name))
			ignore(DoTell(fp->f_name));

	for (fp = macros; fp->f_name; fp++)
		if (sindex(ans, fp->f_name))
			ignore(DoTell(fp->f_name));

	if (UseBuffers) {
		Bof();		/* Go to the beginning of the file */
		NotModified();
	}
	StopTelling();
}

sindex(pattern, string)
register char	*pattern,
		*string;
{
	register int	len = strlen(pattern);

	while (*string) {
		if (*pattern == *string && strncmp(pattern, string, len) == 0)
			return 1;
		string++;
	}
	return 0;
}

void
Extend()
{
	int	command;

	command = findcom(functions, ": ");
	if (command >= 0)
		ExecFunc(&functions[command], !InJoverc);
}

AskInt(prompt)
char	*prompt;
{
	char	*val = ask((char *) 0, prompt);
	int	value;

	if (strcmp(val, "on") == 0)
		value = 1;
	else if (strcmp(val, "off") == 0)
		value = 0;
	else
		value = atoi(val);
	return value;
}

void
PrVar()
{
	int	var;

	var = findcom(variables, FuncName());
	if (var < 0)
		return;
	s_mess("%s is set to %d", variables[var].f_name,
				  *(variables[var].f.Var));
}

void
SetVar()
{
	int	command,
		value;
	static char	tmp[70];

	strcpy(tmp, ": set ");
	command = findcom(variables, tmp);
	if (command < 0)
		return;
	ignore(sprintf(&tmp[strlen(tmp)], "%s ", variables[command].f_name));
	value = AskInt(tmp);
	*(variables[command].f.Var) = value;
	setfuncs(globflags);
}

int
findcom(possible, prompt)
struct function possible[];
char	*prompt;
{
	char	response[132],
		*cp,
		*begin;
	int	c;
	int	minmatch,
		command,
		i,
		lastmatch,
		numfound,
		length,
		exactmatch;

	strcpy(response, prompt);
	message(response);
	Asking = strlen(prompt);
	begin = response + Asking;
	cp = begin;
	*cp = 0;

	while (c = (*Getchar)()) {
		switch (c) {
		case EOF:
			break;

		case CTL('U'):
			cp = begin;
			*cp = 0;
			break;

		case '\r':
		case '\n':
			command = match(possible, begin);
			if (command >= 0) {
				Asking = 0;
				return command;
			}
			if (cp == begin) {
				Asking = 0;
				return EOF;
			}
			rbell();
			if (InJoverc)
				return EOF;
			break;

		case '\033':		/* Try to complete command */
		case ' ':
			minmatch = 1000;
			numfound = 0;
			exactmatch = lastmatch = -1;
			length = strlen(begin);
			for (i = 0; possible[i].f_name; i++)
				if (numcomp(possible[i].f_name, begin) >=
							length) {
					if (numfound)
						minmatch = min(minmatch, numcomp(possible[lastmatch].f_name, possible[i].f_name));
					else
						minmatch = strlen(possible[i].f_name);
					lastmatch = i;
					if (!strcmp(begin, possible[i].f_name))
						exactmatch = i;
					numfound++;
				}
			if (lastmatch >= 0) {
				strncpy(begin, possible[lastmatch].f_name, minmatch);
				begin[minmatch] = '\0';
				cp = &begin[minmatch];
				if (numfound == 1 || exactmatch != -1) {
					if (c == '\033') {
						message(response);
						UpdateMesg();
					}
					Asking = 0;
					return (numfound == 1) ? lastmatch :
							exactmatch;
				} else if (c == '\033')
					rbell();
			} else {
				rbell();
				if (InJoverc)
					return EOF;
			}
			break;

		case '?':
			if (InJoverc)
				return EOF;
			if (UseBuffers) {
				TellWBuffers("Help", 1);
				SetScratch(curwind->w_bufp);
			} else
				TellWScreen(0);
			length = strlen(begin);
			for (i = 0; possible[i].f_name; i++)
				if (numcomp(possible[i].f_name, begin) >= length) {
					int	what = DoTell(possible[i].f_name);

					if (what == ABORT)
						goto abort;
					if (what == STOP)
						break;
				}

			if (UseBuffers)
				Bof();
			StopTelling();
			break;

		default:
			if ((cp = RunEdit(c, begin, cp, (char *) 0, Getchar)) == (char *)0)
abort:
				if (InJoverc)
					return EOF;
				else
					complain("Aborted");
		}
		Asking = cp - response;		/* Wonderful! */
		message(response);
	}
	return EOF;
}

numcomp(s1, s2)
register char	*s1, *s2;
{
	register int	i;

	for (i = 0; s1[i] || s2[i]; i++)
		if (s1[i] != s2[i])
			break;
	return i;
}

match(choices, what)
struct function	choices[];
char	*what;
{
	int	len,
		i,
		found = 0,
		save = -1,
		exactmatch = -1;

	len = strlen(what);
	for (i = 0; choices[i].f_name; i++)
		if (strncmp(what, choices[i].f_name, len) == 0) {
			if (strcmp(what, choices[i].f_name) == 0)
				exactmatch = i;
			save = i;
			found++;	/* Found one. */
		}

	if (found == 0)
		save = -1;
	else if (found > 1) {
		if (exactmatch != -1)
			save = exactmatch;
		else
			save = -1;
	}

	return save;
}

void
Source()
{
	char	*com = ask((char *) 0, FuncName());

	if (joverc(com) == -1)
		complain(IOerr("read", com));
}

joverc(file)
char	*file;
{
	if ((Input = open(file, 0)) == -1) {
		Input = 0;
		return -1;
	}

	InJoverc = 1;
	Getchar = jgetchar;
	while (Ungetc(jgetchar()) != EOF)
		Extend();
	InJoverc = 0;
	Getchar = getch;
	ignore(close(Input));
	Input = 0;
	Asking = 0;
	message("");
	return 1;
}

void
BufPos()
{
	register LINE	*lp = curbuf->b_zero;
	register int	i = 1;
	int	dotline;

	for (i = 1; lp != 0; i++, lp = lp->l_next)
		if (lp == curline)
			dotline = i;

	s_mess("\"%s\" line %d of %d, column %d",
		filename(curbuf), dotline, i, curchar);
}

extern char	quots[];

void
SetQchars()
{
	char	*chars = ask((char *) 0, FuncName());

	strncpy(quots, chars, 10);	/* Hope that they were reasonable characters */
}
@


11.4
log
@
lint, RCSid
@
text
@d4 1
a4 1
 * $Revision: 11.3 $
d7 4
d59 1
a59 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/jove/jove_extend.c,v 11.3 1997/01/03 17:42:17 jra Exp $";
@


11.3
log
@Mods for Irix 6.2
@
text
@d4 1
a4 1
 * $Revision: 11.2 $
d7 3
d55 1
a55 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_extend.c,v 11.2 1995/06/21 03:40:53 gwyn Exp jra $";
@


11.2
log
@Eliminated trailing blanks.
RunEdit() now returns null pointer upon ^G abort; was nonportable (char*)-1.
Findcom is now an array rather than pointer to (unmodifiable) string literal.
Must cast 0 when used as null pointer constant in argument list.
@
text
@d4 1
a4 1
 * $Revision: 11.1 $
d6 7
a12 1
 * $Log:	jove_extend.c,v $
d52 1
a52 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_extend.c,v 11.1 95/01/04 10:35:13 mike Rel4_4 $";
d80 1
d86 1
d125 1
d136 1
d171 1
d190 1
d200 1
d245 1
d468 1
d498 1
d515 1
@


11.1
log
@Release_4.4
@
text
@d2 1
a2 1
 *			J O V E _ E X T E N D . C 
d4 1
a4 1
 * $Revision: 10.3 $
d7 3
d12 1
a12 1
 * 
d15 1
a15 1
 * 
d18 1
a18 1
 * 
d21 1
a21 1
 * 
d24 1
a24 1
 * 
d28 1
a28 1
 * 
d31 1
a31 1
 * 
d34 1
a34 1
 * 
d37 1
a37 1
 * 
d40 1
a40 1
 * 
d43 1
a43 1
 * 
d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_extend.c,v 10.3 93/10/26 06:06:44 mike Exp $";
d51 1
a51 1
  
d62 1
a62 1
extern char	*Findcom;
d160 1
a160 1
		
d174 1
a174 1
					fp->f_name, 0));
d254 1
a254 1
}	
d284 1
a284 1
			
d293 1
a293 1
	int	c;	/* DAG -- was char */
d399 1
a399 1
			if ((cp = RunEdit(c, begin, cp, (char *) 0, Getchar)) == (char *)-1)
d450 1
a450 1
			
@


10.3
log
@Changed getchar() to jgetchar() to avoid stdio.h conflict.
@
text
@d4 1
a4 1
 * $Revision: 10.2 $
d7 3
d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_extend.c,v 10.2 93/10/26 03:45:31 mike Exp Locker: mike $";
@


10.2
log
@ANSI C
@
text
@d4 1
a4 1
 * $Revision: 10.1 $
d7 3
d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_extend.c,v 10.1 91/10/12 06:53:57 mike Rel4_0 Locker: mike $";
d58 1
a58 1
		getchar();
d127 1
a127 1
	key = getchar();
d146 1
a146 1
	c = getchar();
d465 2
a466 2
	Getchar = getchar;
	while (Ungetc(getchar()) != EOF)
@


10.1
log
@Release_4.0
@
text
@d4 1
a4 1
 * $Revision: 2.6 $
d7 3
d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_extend.c,v 2.6 91/09/23 03:08:17 mike Exp $";
d57 3
d75 1
d135 1
d247 1
d259 1
@


2.6
log
@Eliminated return / return(expr) warning
@
text
@d4 1
a4 1
 * $Revision: 2.5 $
d7 3
d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_extend.c,v 2.5 91/08/30 18:59:47 mike Exp $";
@


2.5
log
@Modifications for clean compilation on the XMP
@
text
@d4 1
a4 1
 * $Revision: 2.4 $
d7 3
d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_extend.c,v 2.4 91/08/30 17:54:32 mike Exp $";
d263 1
d290 1
a290 1
			return EOF;
d387 1
a387 1
	/* NOTREACHED */
@


2.4
log
@Changed #include directives to distinguish between local and system header
files.
@
text
@d4 1
a4 1
 * $Revision: 2.3 $
d7 4
d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_extend.c,v 2.3 91/08/30 17:49:05 mike Exp $";
d404 1
a404 1
		save,
@


2.3
log
@Paul Stay mods for ANSI C
@
text
@d4 1
a4 1
 * $Revision: 2.2 $
d7 3
d24 1
a24 1
static char RCSid[] = "@@(#)$Header: jove_extend.c,v 2.2 87/04/14 20:18:43 dpk BRL $";
d36 1
a36 1
#include "jove.h"
@


2.2
log
@Fixed casting on RunEdit call
@
text
@d4 1
a4 1
 * $Revision: 2.1 $
d7 3
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: jove_extend.c,v 2.1 86/04/13 22:02:57 dpk Locked $";
d70 1
a70 1
				(c == '\033' || c == CTL(X)) ? "-" : "");
d72 1
a72 1
	if (c != '\033' && c != CTL(X))
d80 1
a80 1
		if (c == CTL(X))
d281 1
a281 1
		case CTL(U):
@


2.1
log
@fixed getchar type bug
@
text
@d4 1
a4 1
 * $Revision: 2.0 $
d7 3
d18 1
a18 1
static char RCSid[] = "@@(#)$Header: jove_extend.c,v 2.0 84/12/26 16:46:04 dpk Exp $";
d363 1
a363 1
			if ((int)(cp = RunEdit(c, begin, cp, (char *) 0, Getchar)) == -1)
@


2.0
log
@System as distributed to Berkeley 26 Dec 84
@
text
@d4 1
a4 1
 * $Revision: 1.2 $
d7 3
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: jove_extend.c,v 1.2 83/12/16 00:07:57 dpk BRL $";
d253 2
a254 2
		*begin,
		c;
@


1.2
log
@Added distinctive RCS header
@
text
@d4 1
a4 1
 * $Revision$
d6 4
a9 1
 * $Log$
d12 1
a12 1
static char RCSid[] = "@@(#)$Header$";
d28 1
d133 1
a133 1
					FINDCOM,
d157 1
a157 1
		curwind->w_bufp->b_type = SCRATCHBUF;
d337 1
a337 1
				curwind->w_bufp->b_type = SCRATCHBUF;
d420 2
a421 2
joverc(filename)
char	*filename;
d423 1
a423 1
	if ((Input = open(filename, 0)) == -1) {
d445 1
d447 6
a452 3
	for (i = 1; lp != 0 && lp != curline; i++, lp = lp->l_next)
		;
	s_mess("line %d, column %d", i, curchar);
@


1.1
log
@Original 4.2 Distribution Source
@
text
@d2 11
@
