head	11.6;
access;
symbols
	ansi-20040405-merged:11.5
	postmerge-20040405-ansi:11.5
	premerge-20040404-ansi:11.5
	postmerge-autoconf:11.5
	autoconf-freeze:11.5
	premerge-autoconf:11.5
	ansi-20040316-freeze:11.5
	postmerge-20040315-windows:11.5
	premerge-20040315-windows:11.5
	windows-20040315-freeze:11.5
	autoconf-20031203:11.5
	autoconf-20031202:11.5
	autoconf-branch:11.5.0.12
	phong-branch:11.5.0.10
	photonmap-branch:11.5.0.8
	rel-6-1-DP:11.5
	windows-branch:11.5.0.6
	rel-6-0-2:11.5
	ansi-branch:11.5.0.4
	rel-6-0-1-branch:11.5.0.2
	hartley-6-0-post:11.5
	hartley-6-0-pre:11.5
	rel-6-0-1:11.5
	rel-6-0:11.5
	rel-5-4:11.4
	offsite-5-3-pre:11.5
	rel-5-3:11.4
	rel-5-2:11.4
	rel-5-1-branch:11.4.0.2
	rel-5-1:11.4
	rel-5-0:11.4
	rel-5-0-beta:11.4
	rel-4-5:11.3
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:2.3
	rel-3-0:2.3
	rel-2-3:2.3
	rel-2-0:2.3
	rel-1-24:2.3
	rel-1-20:2.1
	rel-1-10:2.1
	rt-2:2.1
	rt:1.2;
locks; strict;
comment	@ * @;


11.6
date	2004.05.21.17.48.33;	author morrison;	state dead;
branches;
next	11.5;

11.5
date	2000.08.24.23.12.24;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	98.08.23.01.33.56;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	97.01.03.17.42.17;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.06.21.03.43.41;	author gwyn;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.35.18;	author mike;	state Rel4_4;
branches;
next	10.4;

10.4
date	95.01.04.08.43.58;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	93.10.26.06.05.57;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	93.10.26.06.01.52;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.54.02;	author mike;	state Rel4_0;
branches;
next	2.6;

2.6
date	91.08.30.18.59.49;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	91.08.30.17.54.37;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	91.08.30.17.49.12;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	87.04.14.22.46.43;	author dpk;	state BRL;
branches;
next	2.2;

2.2
date	87.04.14.20.19.12;	author dpk;	state BRL;
branches;
next	2.1;

2.1
date	84.12.31.16.43.09;	author dpk;	state Exp;
branches;
next	2.0;

2.0
date	84.12.26.16.47.08;	author dpk;	state Exp;
branches;
next	1.2;

1.2
date	83.12.16.00.09.03;	author dpk;	state BRL;
branches;
next	1.1;

1.1
date	83.12.16.00.08.56;	author dpk;	state Exp;
branches;
next	;


desc
@Jove is an EMACS like screen editor which will fit on 11's and Vaxen
@


11.6
log
@moved to src/other/jove/
@
text
@/*
 *			J O V E _ M I S C . C
 *
 * $Revision: 11.5 $
 *
 * $Log: jove_misc.c,v $
 * Revision 11.5  2000/08/24 23:12:24  mike
 *
 * lint, RCSid
 *
 * Revision 11.4  1998/08/23  01:33:56  mike
 * Added support for page up and page down keys on PC-style keyboards.
 *
 * Revision 11.3  1997/01/03  17:42:17  jra
 * Mods for Irix 6.2
 *
 * Revision 11.2  1995/06/21  03:43:41  gwyn
 * Eliminated trailing blanks.
 * RunEdit() now returns null pointer upon ^G abort; was nonportable (char*)-1.
 * Fixed varargs functions, using VA_* macros.
 * Use LBSIZE instead of hard-wired 100.
 *
 * Revision 11.1  95/01/04  10:35:18  mike
 * Release_4.4
 *
 * Revision 10.4  95/01/04  08:43:58  mike
 * "../jove/jove_misc.c", line 234: value of void expression used
 * on VAX
 *
 * Revision 10.3  93/10/26  06:05:57  mike
 * ANSI C
 *
 * Revision 10.2  93/10/26  06:01:52  mike
 * Changed getchar() to jgetchar() to prevent stdio.h conflict
 *
 * Revision 10.1  91/10/12  06:54:02  mike
 * Release_4.0
 *
 * Revision 2.6  91/08/30  18:59:49  mike
 * Modifications for clean compilation on the XMP
 *
 * Revision 2.5  91/08/30  17:54:37  mike
 * Changed #include directives to distinguish between local and system header
 * files.
 *
 * Revision 2.4  91/08/30  17:49:12  mike
 * Paul Stay mods for ANSI C
 *
 * Revision 2.3  87/04/14  22:46:43  dpk
 * Fixed bug in paragraph justification.
 *
 * Revision 2.2  87/04/14  20:19:12  dpk
 * Fixed casting on RunEdit call
 *
 * Revision 2.1  84/12/31  16:43:09  dpk
 * Make CTL(Y)==CTL(R) in RunEdit() (command line editor)
 *
 * Revision 2.0  84/12/26  16:47:08  dpk
 * System as distributed to Berkeley 26 Dec 84
 *
 * Revision 1.2  83/12/16  00:09:03  dpk
 * Added distinctive RCS header
 *
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/jove/jove_misc.c,v 11.5 2000/08/24 23:12:24 mike Exp $";
#endif

/*
   Jonathan Payne at Lincoln-Sudbury Regional High School 5-25-83

   jove_meta.c

   Various commands that are (by default) invoked by ESC-key.
   Not a very good name since the ESC key can be rebound...  */

#include "./jove.h"

#include <ctype.h>
#include <signal.h>

void	EscPrefix();
void	CopyRegion();
void	GoLine();
void	CtlxPrefix();
void	DelBlnkLines();

void	Eos();
void	to_word();
void	ForWord();
void	BackWord();
void	Eow();
void	Bow();
void	DOTsave();
void	CapChar();

void
PrefAbort(str)
char	*str;
{
	s_mess("%s aborted", str);
	rbell();
}

void
Unknown(pref, c)
char	pref,
	c;
{
	s_mess("%c-%c unbound", pref, c);
	rbell();
}

Upper(c)
register int	c;
{
	return (islower(c) ? toupper(c) : c);
}

void
FourTime()
{
	exp_p = 1;
	exp *= 4;
	this_cmd = ARG_CMD;
}

int	FastPrompt = 0;
static char	*StrToShow;
static int	siged = 0;
void
slowpoke(num)
int	num;
{
	s_mess("%s", StrToShow);
	UpdateMesg();
	siged++;
}

waitfor(sec, str)
char	*str;
{
	int	c;

	siged = 0;
	StrToShow = str;
	signal(SIGALRM, slowpoke);
	ignore(alarm((unsigned) sec));
	c = (*Getchar)();	/* The read will be restarted
				   with the new signal mechanism */
	if (!siged)		/* If we didn't get signaled ... */
		alarm(0);	/* we have to turn it off ouselves */
	s_mess("%s%c", str, c);
	return c;
}

void
EscPrefix()
{
	register int	c, i, sign;
	struct function	*mp;
	int	invokingchar = LastKeyStruck;

	if (FastPrompt)
	{
		s_mess("M-");
		c = (*Getchar)();
		s_mess("M-%c", c);
	} else
		c = waitfor(2, "M-");

	if (c == CTL('G')) {
		PrefAbort("Prefix-1");
		return;
	}

	if (c == '-' || (c >= '0' && c <= '9')) {
		s_mess("M-%c", c);
		sign = c == '-' ? -1 : 1;
		if (sign == 1)
			i = c - '0';
		else
			i = 0;
		for (;;) {
			c = (*Getchar)();
			if (c >= '0' && c <= '9')
				i = i * 10 + (c - '0');
			else {
				exp_p = 1;
				exp = i * sign;
				peekc = c;
				this_cmd = ARG_CMD;
				return;
			}
			s_mess("M-%d", i);
		}
	}

	mp = pref1map[c];
	if (mp == 0)
		Unknown(invokingchar, c);
	else
		ExecFunc(mp, 0);
}

/*
 * Save a region.  A pretend kill.
 */
void
CopyRegion()
{
	LINE	*nl;
	MARK	*mp;
	int	status,
		mod = IsModified(curbuf);

	mp = CurMark();

	if (mp->m_line == curline && mp->m_char == curchar)
		complain((char *) 0);

	killptr = ((killptr + 1) % NUMKILLS);
	if (killbuf[killptr])
		lfreelist(killbuf[killptr]);
	nl = killbuf[killptr] = nbufline();
	nl->l_dline = putline("");
	nl->l_next = nl->l_prev = 0;

	status = inorder(mp->m_line, mp->m_char, curline, curchar);
	if (status == -1)
		return;

	if (status)
		ignore(DoYank(mp->m_line, mp->m_char, curline, curchar,
				nl, 0, (BUFFER *) 0));
	else
		ignore(DoYank(curline, curchar, mp->m_line, mp->m_char,
				nl, 0, (BUFFER *) 0));
	if (mod)
		curbuf->b_status |= B_MODIFIED;
	else
		curbuf->b_status &= ~B_MODIFIED;
}

void
DelNWord()
{
	dword(1);
}

void
DelPWord()
{
	dword(0);
}

void
dword(forward)
{
	BUFLOC	savedot;

	DOTsave(&savedot);
	if(forward) ForWord();
	else	BackWord();
	reg_kill(savedot.p_line, savedot.p_char, curline, curchar, !forward);
}

void
UppWord()
{
	case_word(1);
}

void
LowWord()
{
	case_word(0);
}

void
ToIndent()
{
	register char	*cp, c;

	for (cp = linebuf; c = *cp; cp++)
		if (c != ' ' && c != '\t')
			break;
	curchar = cp - linebuf;
}

void
GoLine()
{
	if (exp_p == 0)
		return;
	SetLine(next_line(curbuf->b_zero, exp - 1));
}

int	RMargin = RMARGIN;

void
VtKeys()
{
	int	c = getch();

	switch (c) {
	case 'A':
		PrevLine();
		break;

	case 'B':
		NextLine();
		break;

	case 'D':
		BackChar();
		break;

	case 'C':
		ForChar();
		break;

	case '5':			/* page up */
		PrevPage();
		(void)getch();		/* eat the "~" */
		break;

	case '6':			/* page down */
		NextPage();
		(void)getch();		/* eat the "~" */
		break;

	default:
		complain("Unknown command ESC-[-%c", c);
	}
}

void
Justify()
{
	BUFLOC	*bp;
	LINE	*start,
		*end;
	char	*ParaStr = "^\\.\\|^$";

	bp = dosearch(ParaStr, -1, 1);	/* Beginning of paragraph */
	if (bp)		/* Not the tab case */
		start = bp->p_line->l_next;
	else
		start = curbuf->b_zero;
	bp = dosearch(ParaStr, 1, 1);		/* End of paragraph */
	if (bp)
		end = bp->p_line;
	else
		end = curbuf->b_dol;
	DoJustify(start, end, 0);
}

extern int	diffnum;

void
DoJustify(l1, l2, scrunch)		/* Justify text */
LINE	*l1,
	*l2;
{
	int	d1 = 0,
		d2 = 1,
		goal,
		nlines,			/* Number of lines to justify
					 * so we know when we are done.
					 */
		curcol;
	char	*cp;
	MARK	*savedot = MakeMark(curline, curchar);

	fixorder(&l1, &d1, &l2, &d2);	/* l1/c1 will be before l2/c2 */
	nlines = diffnum;
	SetLine(l1);

	if (lastp(l2) && !blnkp(getline(l2->l_dline, genbuf)))
		nlines++;

	while (nlines) {	/* One line at a time */
		goal = RMargin - (RMargin / 10);
		Eol();	/* End of line */
		if ((curcol = calc_pos(linebuf, curchar)) == 0) {
			if (curline->l_next == 0)
				break;
			SetLine(curline->l_next);	/* Skip blank lines */
			nlines--;
		} else if (curcol < goal) {
			if (nlines == 1)
				break;
			DelWtSpace();	/* No white space at the end of the line */
			DelNChar();	/* Delete carraige return */
			nlines--;
			Insert(' ');
		} else if (curcol > RMargin) {
			do {
				/* curchar - 2 because curchar is the null,
				 * curchar - 1 is the space (if there is
				 * one there.
				 */
				cp = StrIndex(-1, linebuf, curchar - 2, ' ');
				if (cp == 0)
					break;
				curchar = cp - linebuf;
				curcol = calc_pos(linebuf, curchar);
			} while (curcol > RMargin);
			if (cp) {
				DelWtSpace();
				LineInsert();
				if (scrunch && TwoBlank()) {
					Eol();
					DelNChar();
				}
			} else {
				if (curline->l_next == 0)
					break;
				SetLine(curline->l_next);
				nlines--;
			}
		} else {
			if (curline->l_next == 0)
				break;
			SetLine(curline->l_next);
			nlines--;
		}
	}
	ToMark(savedot);	/* Back to where we were */
	DelMark(savedot);	/* Free up the mark */
	this_cmd = 0;		/* So everything is under control */
}

void
ChrToOct()
{
	int	c = getch();

	ins_str(sprint("\\%03o", c));
}

char *
StrIndex(dir, buf, charpos, what)
char	*buf,
	what;
{
	char	*cp = &buf[charpos],
		c = '\0';

	if (dir > 0) {
		while (c = *cp++)
			if (c == what)
				return (cp - 1);
	} else {
		while (cp >= buf && (c = *cp--))
			if (c == what)
				return (cp + 1);
	}
	return 0;
}

void
StrLength()
{
	static char	inquotes[] = "Where are the quotes?";
	char	*first = StrIndex(-1, linebuf, curchar, '"');
	char	*last = StrIndex(1, linebuf, curchar, '"');
	char	c;
	int	numchars = 0;

	if (first == 0 || last == 0)
		complain(inquotes);
	first++;
	while (first < last) {
		c = *first++;
		if (c == '\\') {
			int	num;

			if (*first < '0' || *first > '9')
				++first;
			else {
				num = 3;
				while (num-- && (c = *first++) >= '0' &&
						c <= '9' && first < last)
					;
			}
		}
		numchars++;
	}
	s_mess("%d characters", numchars);
}

void
SplitWind()
{
	curwind = div_wind(curwind);
}

LINE *
lastline(lp)
register LINE	*lp;
{
	while (lp->l_next)
		lp = lp->l_next;
	return lp;
}

/* Transpos cur_char with cur_char - 1 */

void
TransChar()
{
	char	c;

	if (curchar == 0)
		complain((char *) 0);	/* BEEP */
	c = linebuf[curchar - 1];
	exp = 1;
	DelPChar();
	if (eolp()) {
		BackChar();
		Insert(c);
		ForChar();
	} else {
		ForChar();
		Insert(c);
		BackChar();
	}
}

void
SetLine(line)
register LINE	*line;
{
	DotTo(line, 0);
}

void
UpScroll()
{
	SetTop(curwind, next_line(curwind->w_top, exp));
	if (in_window(curwind, curline) == -1)
		SetLine(next_line(curwind->w_top, HALF(curwind)));
}

void
DownScroll()
{
	SetTop(curwind, prev_line(curwind->w_top, exp));
	if (in_window(curwind, curline) == -1)
		SetLine(next_line(curwind->w_top, HALF(curwind)));
}

void
Leave()
{
	BUFFER	*bp;

	if (RecDepth == 0)
		for (bp = world; bp; bp = bp->b_next)
			if (bp->b_zero && IsModified(bp) && !IsScratch(bp)) {
				confirm("Modified buffers exist.  Leave anyway? ");
				break;
			}
	longjmp(mainjmp, QUIT);
}

void
KillEOL()
{
	LINE	*line2;
	int	char2;

	if (exp_p) {
		line2 = next_line(curline, exp);
		if (line2 == curline)
			char2 = length(curline);
		else
			char2 = 0;
	} else if (linebuf[curchar] == '\0') {
		line2 = next_line(curline, 1);
		if (line2 == curline)
			char2 = length(curline);
		else
			char2 = 0;
	} else {
		line2 = curline;
		char2 = length(curline);
	}
	reg_kill(curline, curchar, line2, char2, 0);
}

void
CtlxPrefix()
{
	struct function	*fp;
	int	c,
		invokingchar = LastKeyStruck;

	if (FastPrompt)
	{
		s_mess("C-X ");
		c = (*Getchar)();
		s_mess("C-X %c", c);
	} else
		c = waitfor(2, "C-X ");

	if (c == CTL('G')) {
		PrefAbort("Prefix-2");
		return;
	}
	fp = pref2map[c];
	if (fp == 0)
		Unknown(invokingchar, c);
	else
		ExecFunc(fp, 0);
}

void
Yank()
{
	LINE	*line,
		*lp;
	BUFLOC	*dot;

	if (killbuf[killptr] == 0)
		complain("Nothing to yank!");
	lsave();
	this_cmd = YANKCMD;
	line = killbuf[killptr];
	lp = lastline(line);
	dot = DoYank(line, 0, lp, length(lp), curline, curchar, curbuf);
	SetMark();
	SetDot(dot);
}

static int	NumArg = 1;

GetFour(InputFunc)
int	(*InputFunc)();
{
	register int	c;

	do {
		NumArg *= 4;
	} while ((c = (*InputFunc)()) == CTL('U'));
	return c;
}

GetArg(InputFunc)
int	(*InputFunc)();
{
	register int	c,
			i = 0;

	if (!isdigit(c = (*InputFunc)()))
		return (c | 0200);

	do
		i = i * 10 + (c - '0');
	while ((c = getch()) >= '0' && c <= '9');
	NumArg = i;
	return c;
}

char *
jumpup(cp)
char	*cp;
{
	while (*cp && !isword(*cp))
		cp++;
	while (*cp && isword(*cp))
		cp++;
	return cp;
}

char *
backup(string, cp)
char	*string, *cp;
{
	while (cp > string && !isword(*(cp - 1)))
		cp--;
	while (cp > string && isword(*(cp - 1)))
		cp--;
	return cp;
}

#define ASKSIZE	132

char *
RunEdit(c, begin, cp, def, HowToRead)
register int	c;
register char	*begin;
register char	*cp;
char	*def;
int	(*HowToRead)();
{
	char	*tcp;

	switch (c) {
	case CTL('@@'):
		break;

	case CTL('A'):
		cp = begin;
		break;

	case CTL('B'):
		if (cp > begin)
			--cp;
		break;

	case CTL('D'):
		if (!*cp)
			break;
		cp++;
		goto delchar;

	case CTL('E'):
		while (*cp)
			cp++;
		break;

	case CTL('F'):
		if (*cp)
			cp++;
		break;

	case CTL('G'):
		return (char *) 0;

	case CTL('K'):
		*cp = '\0';
		break;

	case CTL('N'):
	case CTL('P'):
		ArgIns(begin, c == CTL('N'));
		cp = begin + strlen(begin);
		break;

	case '\177':
	case CTL('H'):
delchar:
		if (cp == begin)
			break;
		strcpy(cp - 1, cp);
		cp--;
		break;

	case META('\177'):	/* Delete previous word */
	case CTL('W'):
	    {
		char	*bp = backup(begin, cp);

		strcpy(bp, cp);
		cp = bp;
	    }
		break;

	case META('D'):
	case META('d'):
		strcpy(cp, jumpup(cp));
		break;		/* Pretty neat huh */

	case META('B'):
	case META('b'):
		cp = backup(begin, cp);
		break;

	case META('F'):
	case META('f'):
		cp = jumpup(cp);
		break;

	case CTL('Y'):
	case CTL('R'):
		if (!def || !*def) {
			rbell();
			break;
		}
		tcp = def;
		while (c = *tcp++) {
			insert(c, begin, cp - begin, 1, LBSIZE);
			cp++;
		}
		break;

	case CTL('^'):
	case CTL('Q'):
		c = (*HowToRead)();
		/* Fall into... */

	default:
		if (c & 0200)
			rbell();
		else {
			insert(c, begin, cp - begin, 1, ASKSIZE);
			cp++;
		}
	}
	return cp;
}

NoMacGetc()
{
	int	c;

	redisplay();
	if ((c = jgetchar()) == EOF)
		finish(SIGHUP);
	return c & 0177;
}

extern int	Interactive;

/* VARARGS */

char *
ask(VA_T(char *def) VA_T(const char *fmt) VA_ALIST)
	VA_DCL
{
	VA_D(char	*def)
	VA_D(char	*fmt)
	VA_LIST(ap)
	static char	string[ASKSIZE];
	char	*cp,
		*begin;	/* Beginning of real text */
	int	c;
	extern int	(*Getchar)();
	int	(*HowToRead)() = Interactive ? NoMacGetc : Getchar;

	VA_START(ap, fmt)
	VA_I(ap, char *, def)
	VA_I(ap, char *, fmt)
	vsprintf(string, fmt, ap);
	VA_END(ap)
	message(string);
	Asking = strlen(string);	/* Entirely for redisplay */
	begin = string + Asking;
	cp = begin;
	*cp = '\0';

	while ((c = (*HowToRead)()) != '\r' && c != '\n') {
		NumArg = 1;	/* If not otherwise specified */
		if (c == '\033')	/* Maybe a number */
			c = GetArg(HowToRead);
		else if (c == CTL('U'))
			c = GetFour(HowToRead);
		if (c == '\033')	/* Again */
			c = (*HowToRead)() | 0200;
		while (NumArg-- > 0)
			if ((cp = RunEdit(c, begin, cp, def, HowToRead)) == (char *)0)
				complain("Aborted");

		/* Show the change */
		message(string);
		Asking = cp - string;
	}
	Asking = 0;
	if (cp == begin && *cp == '\0')	/* Nothing was typed */
		if (def == 0)
			complain("No default");
		else
			return def;
	return begin;
}

void
YankPop()
{
	LINE	*line,
		*last;
	MARK	*mp = CurMark();
	BUFLOC	*dot;

	if (last_cmd != YANKCMD)
		complain("Yank something first!");

	lfreelist(reg_delete(mp->m_line, mp->m_char, curline, curchar));

	/* Now must find a recently killed region. */

	killptr--;
	for (;;) {
		if (killptr < 0)
			killptr = NUMKILLS - 1;
		if (killbuf[killptr])
			break;
		killptr--;
	}

	this_cmd = YANKCMD;

	line = killbuf[killptr];
	last = lastline(line);
	dot = DoYank(line, 0, last, length(last), curline, curchar, curbuf);
	MarkSet(CurMark(), curline, curchar);
	SetDot(dot);
}

void
WtModBuf()
{
	int	askp = exp_p;
	BUFFER	*oldb = curbuf,
		*bp;
	char	*yorn,
		name[LBSIZE];

	for (bp = world; bp; bp = bp->b_next) {
		if (bp->b_zero == 0 || !IsModified(bp) || IsScratch(bp))
			continue;
		SetBuf(bp);	/* Make this current buffer */
		if (Crashing) {
			strcpy(name, curbuf->b_name);
			insert('_', name, 0, 1, LBSIZE);
		} else {
			if (curbuf->b_fname == 0)
				setfname(curbuf, ask((char *) 0, "No file.  File to use: "));
			strcpy(name, curbuf->b_fname);
		}
		if (askp) {
			yorn = ask((char *) 0, "Write %s? ", curbuf->b_fname);
			if (*yorn != 'Y' && *yorn != 'y')
				continue;
		}
		file_write(name, 0);
		SetUnmodified(curbuf);
	}
	SetBuf(oldb);
}

void
NotModified()
{
	SetUnmodified(curbuf);
}

void
ArgIns(at, next)
char	*at;
{
	int	inc = next ? 1 : -1;

	if (*(argvp + inc) == 0)
		inc = 0;
	argvp += inc;
	strcpy(at, *argvp);
}

blnkp(buf)
register char	*buf;
{
	register char	c;

	while ((c = *buf++) && (c == ' ' || c == '\t'))
		;
	return c == 0;	/* It's zero if we got to the end of the line */
}

void
DelBlnkLines()
{
	exp = 1;
	if (!blnkp(linebuf) && !eolp())
		return;
	while (blnkp(linebuf) && curline->l_prev)
		SetLine(curline->l_prev);

	Eol();
	DelWtSpace();
	NextLine();
	while (blnkp(linebuf) && !eobp()) {
		DelWtSpace();
		DelNChar();
	}
	DelWtSpace();
}

int line_pos;

LINE *
next_line(line, num)
register LINE	*line;
register int	num;
{
	register int	i;

	if (line)
		for (i = 0; i < num && line->l_next; i++, line = line->l_next)
			;

	return line;
}

LINE *
prev_line(line, num)
register LINE	*line;
register int	num;
{
	register int	i;

	if (line)
		for (i = 0; i < num && line->l_prev; i++, line = line->l_prev)
			;

	return line;
}

void
ForChar()
{
	register int	num = exp;

	exp = 1;
	while (num--) {
		if (eolp()) {			/* Go to the next line */
			if (curline->l_next == 0)
				break;
			SetLine(curline->l_next);
		} else
			curchar++;
	}
}

void
BackChar()
{
	register int	num = exp;

	exp = 1;
	while (num--) {
		if (bolp()) {
			if (curline->l_prev == 0)
				break;
			SetLine(curline->l_prev);
			Eol();
		} else
			--curchar;
	}
}

void
NextLine()
{
	if (lastp(curline))
		OutOfBounds();
	down_line(1);
}

void
PrevLine()
{
	if (firstp(curline))
		OutOfBounds();
	down_line(0);
}

void
OutOfBounds()
{
	complain("");
}

void
down_line(down)
{
	LINE	*(*func)() = down ? next_line : prev_line;
	LINE	*line;

	line = (*func)(curline, exp);

	this_cmd = LINE_CMD;

	if (last_cmd != LINE_CMD)
		line_pos = calc_pos(linebuf, curchar);

	SetLine(line);		/* Curline is in linebuf now */
	curchar = how_far(curline, line_pos);
}

/* Returns what cur_char should be for that pos. */

how_far(line, ypos)
LINE	*line;
{
	register char	*pp;
	char	*base;
	register int	cur_char;
	char	c;
	register int	y;

	base = pp = getcptr(line, genbuf);

	cur_char = 0;
	y = 0;

	while (c = *pp++) {
		if (y >= ypos)
			return cur_char;
		if (c == 0177)
			y++;
		else if (c < ' ') {
			if (c == 011)
				y += ((tabstop - y % tabstop) - 1);
			else
				y++;
		}
		y++;
		cur_char++;
	}

	return pp - base - 1;
}

void
Bol()
{
	curchar = 0;
}

void
Eol()
{
	curchar += strlen(&linebuf[curchar]);
}

void
DotTo(line, col)
LINE	*line;
{
	BUFLOC	bp;

	bp.p_line = line;
	bp.p_char = col;
	SetDot(&bp);
}

/* If bp->p_line is != current line, then save current line.  Then set dot
   to bp->p_line, and if they weren't equal get that line into linebuf  */

void
SetDot(bp)
register BUFLOC	*bp;
{
	register int	notequal = bp->p_line != curline;

	if (notequal)
		lsave();
	curline = bp->p_line;
	curchar = bp->p_char;
	if (notequal)
		getDOT();
}

void
Eof()
{
	SetMark();
	SetLine(curbuf->b_dol);
	Eol();
}

void
Bof()
{
	SetMark();
	SetLine(curbuf->b_zero);
}

char	REsent[] = "[?.!]\"  *\\|[.?!]  *\\|[.?!][\"]*$";

void
Bos()
{
	int	num = exp;
	BUFLOC	*bp,
		save;

	exp = 1;
	while (num--) {
onceagain:
		bp = dosearch(REsent, -1, 1);
		DOTsave(&save);
		if (bp == 0) {
			Bof();
			break;
		}
		SetDot(bp);
		to_word(1);
		if (curline == save.p_line && curchar == save.p_char) {
			SetDot(bp);
			goto onceagain;
		}
	}
}

void
Eos()
{
	int	num = exp;
	BUFLOC	*bp;

	exp = 1;
	while (num-- && (bp = dosearch(REsent, 1, 1)))
		SetDot(bp);
	if (bp == 0)
		Eof();
	else
		to_word(1);
}

int
length(line)
register LINE	*line;
{
	register char	*base,
			*cp;

	base = cp = getcptr(line, genbuf);

	while (*cp++)
		;
	return cp - base - 1;
}

int
isword(c)
register char	c;
{
	return isalpha(c) || isdigit(c);
}

void
to_word(dir)
{
	register char	c;

	if (dir > 0) {
		while ((c = linebuf[curchar]) != 0 && !isword(c))
			curchar++;
		if (eolp()) {
			if (curline->l_next == 0)
				return;
			SetLine(curline->l_next);
			to_word(dir);
			return;
		}
	} else {
		while (!bolp() && (c = linebuf[curchar - 1], !isword(c)))
			--curchar;
		if (bolp()) {
			if (curline->l_prev == 0)
				return;
			SetLine(curline->l_prev);
			Eol();
			to_word(dir);
		}
	}
}

void
ForWord()
{
	register char	c;
	register int	num = exp;

	exp = 1;
	while (--num >= 0) {
		to_word(1);
		while ((c = linebuf[curchar]) != 0 && isword(c))
			curchar++;
		if (eobp())
			break;
	}
	this_cmd = 0;	/* Semi kludge to stop some unfavorable behavior */
}

void
BackWord()
{
	register int	num = exp;
	register char	c;

	exp = 1;
	while (--num >= 0) {
		to_word(-1);
		while (!bolp() && (c = linebuf[curchar - 1], isword(c)))
			--curchar;
		if (bobp())
			break;
	}
	this_cmd = 0;
}

/* End of window */

void
Eow()
{
	SetLine(next_line(curwind->w_top, SIZE(curwind) - 1 -
			min(SIZE(curwind) - 1, exp - 1)));
	if (!exp_p)
		Eol();
}

/* Beginning of window */

void
Bow()
{
	SetLine(next_line(curwind->w_top, min(SIZE(curwind) - 1, exp - 1)));
}

/*
   Jonathan Payne at Lincoln-Sudbury Regional High School 5-25-83

   jove_case.c

   contains case case-region and case-word functions.  */

void
DOTsave(buf)
BUFLOC *buf;
{
	buf->p_line = curline;
	buf->p_char = curchar;
}

void
CapChar()
{
	register int	num = exp;

	exp = 1;
	while (num--) {
		upper(&linebuf[curchar]);	/* Cap this word. */
		SetModified(curbuf);	/* Or else lsave won't do anything */
		makedirty(curline);
		if (eolp()) {			/* Go to the next line */
			if (curline->l_next == 0)
				break;
			SetLine(curline->l_next);
		} else
			curchar++;
	}
}

void
CapWord()
{
	int num = exp;

	exp = 1;	/* So all the commands are done once */

	while (num--) {
		to_word(1);	/* Go to the beginning of the next word. */
		if (eobp())
			break;
		upper(&linebuf[curchar]);	/* Cap this word. */
		SetModified(curbuf);	/* Or else lsave won't do anything */
		makedirty(curline);
		curchar++;
		while (!eolp() && isword(linebuf[curchar])) {
			lower(&linebuf[curchar]);
			curchar++;
		}
	}
}

void
case_word(up)
{
	BUFLOC bp;

	DOTsave(&bp);
	ForWord();	/* Go to end of the region */
	case_reg(bp.p_line, bp.p_char, curline, curchar, up);
}

void
upper(c)
register char	*c;
{
	if (*c >= 'a' && *c <= 'z')
		*c -= 040;
}

void
lower(c)
register char	*c;
{
	if (*c >= 'A' && *c <= 'Z')
		*c += 040;
}

void
case_reg(line1, char1, line2, char2, up)
LINE	*line1,
	*line2;
{
	char lbuf[LBSIZE];

	SetModified(curbuf);
	fixorder(&line1, &char1, &line2, &char2);
	lsave();
	ignore(getline(line1->l_dline, lbuf));
	for (;;) {
		if (line1 == line2 && char1 == char2)
			break;
		if (lbuf[char1] == '\0') {
			char1 = 0;
			line1->l_dline = putline(lbuf);
			makedirty(line1);
			if (lastp(line1))
				break;
			line1 = line1->l_next;
			ignore(getline(line1->l_dline, lbuf));
			continue;
		}
		if (up)
			upper(&lbuf[char1]);
		else
			lower(&lbuf[char1]);
		char1++;
	}
	line1->l_dline = putline(lbuf);
	makedirty(line1);
	getDOT();
}

void
CasRegLower()
{
	CaseReg(0);
}

void
CasRegUpper()
{
	CaseReg(1);
}

void
CaseReg(up)
{
	register MARK	*mp = CurMark();

	case_reg(curline, curchar, mp->m_line, mp->m_char, up);
}
@


11.5
log
@
lint, RCSid
@
text
@d4 1
a4 1
 * $Revision: 11.4 $
d7 4
d66 1
a66 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/jove/jove_misc.c,v 11.4 1998/08/23 01:33:56 mike Exp $";
@


11.4
log
@Added support for page up and page down keys on PC-style keyboards.
@
text
@d4 1
a4 1
 * $Revision: 11.3 $
d7 3
d62 1
a62 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/jove/jove_misc.c,v 11.3 1997/01/03 17:42:17 jra Exp $";
@


11.3
log
@Mods for Irix 6.2
@
text
@d4 1
a4 1
 * $Revision: 11.2 $
d7 3
d59 1
a59 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_misc.c,v 11.2 1995/06/21 03:43:41 gwyn Exp jra $";
d314 10
@


11.2
log
@Eliminated trailing blanks.
RunEdit() now returns null pointer upon ^G abort; was nonportable (char*)-1.
Fixed varargs functions, using VA_* macros.
Use LBSIZE instead of hard-wired 100.
@
text
@d4 1
a4 1
 * $Revision: 11.1 $
d6 7
a12 1
 * $Log:	jove_misc.c,v $
d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_misc.c,v 11.1 95/01/04 10:35:18 mike Rel4_4 $";
d87 1
d95 1
d110 1
d235 1
d241 1
d247 1
d258 1
d264 1
d270 1
d291 1
d318 1
d341 1
d415 1
d443 1
d474 1
d491 1
d512 1
d519 1
d527 1
d535 1
d549 1
d600 1
d618 1
a618 1
static	NumArg = 1;
d850 1
d883 1
d915 1
d921 1
d992 1
d1008 1
d1025 1
d1033 1
d1041 1
d1047 1
d1098 1
d1104 1
d1110 1
d1124 1
d1138 1
d1146 1
d1155 1
d1331 1
d1353 1
d1363 1
d1371 1
d1379 1
d1414 1
d1420 1
d1426 1
@


11.1
log
@Release_4.4
@
text
@d2 1
a2 1
 *			J O V E _ M I S C . C 
d4 1
a4 1
 * $Revision: 10.4 $
d7 3
d13 1
a13 1
 * 
d16 1
a16 1
 * 
d19 1
a19 1
 * 
d22 1
a22 1
 * 
d25 1
a25 1
 * 
d29 1
a29 1
 * 
d32 1
a32 1
 * 
d35 1
a35 1
 * 
d38 1
a38 1
 * 
d41 1
a41 1
 * 
d44 1
a44 1
 * 
d47 1
a47 1
 * 
d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_misc.c,v 10.4 95/01/04 08:43:58 mike Exp $";
d55 1
a55 1
  
d220 1
a220 1
	if (mod)		
d683 1
a683 1
		return (char *) -1;
d770 1
a770 1
/* VARARGS2 */
d773 2
a774 3
ask(def, fmt, aa, bb, cc)
char	*def, *fmt;
char	*aa, *bb, *cc;
d776 3
d786 5
a790 1
	sprintf(string, fmt, aa, bb, cc);
d806 1
a806 1
			if ((cp = RunEdit(c, begin, cp, def, HowToRead)) == (char *)-1)
d857 2
a858 2
	BUFFER	*oldb = curbuf,	
		*bp;		
d860 1
a860 1
		name[100];
d868 1
a868 1
			insert('_', name, 0, 1, 100);
@


10.4
log
@"../jove/jove_misc.c", line 234: value of void expression used
on VAX
@
text
@d4 1
a4 1
 * $Revision: 10.3 $
d7 4
d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_misc.c,v 10.3 93/10/26 06:05:57 mike Exp Locker: mike $";
@


10.3
log
@ANSI C
@
text
@d4 1
a4 1
 * $Revision: 10.2 $
d7 3
d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_misc.c,v 10.2 93/10/26 06:01:52 mike Exp Locker: mike $";
d234 2
a235 1
	forward ? ForWord() : BackWord();
@


10.2
log
@Changed getchar() to jgetchar() to prevent stdio.h conflict
@
text
@d4 1
a4 1
 * $Revision: 10.1 $
d7 3
d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_misc.c,v 10.1 91/10/12 06:54:02 mike Rel4_0 Locker: mike $";
d56 15
d128 1
d180 1
a180 1

d255 1
d536 1
d894 1
d1118 1
d1133 1
d1147 1
d1154 1
d1182 1
d1199 1
d1218 1
d1229 1
d1242 1
d1250 1
@


10.1
log
@Release_4.0
@
text
@d4 1
a4 1
 * $Revision: 2.6 $
d7 3
d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_misc.c,v 2.6 91/08/30 18:59:49 mike Exp $";
d731 1
a731 1
	if ((c = getchar()) == EOF)
@


2.6
log
@Modifications for clean compilation on the XMP
@
text
@d4 1
a4 1
 * $Revision: 2.5 $
d7 3
d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_misc.c,v 2.5 91/08/30 17:54:37 mike Exp $";
@


2.5
log
@Changed #include directives to distinguish between local and system header
files.
@
text
@d4 1
a4 1
 * $Revision: 2.4 $
d7 4
d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_misc.c,v 2.4 91/08/30 17:49:12 mike Exp $";
d79 2
a80 1
slowpoke()
d373 1
a373 1
		c;
@


2.4
log
@Paul Stay mods for ANSI C
@
text
@d4 1
a4 1
 * $Revision: 2.3 $
d7 3
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: jove_misc.c,v 2.3 87/04/14 22:46:43 dpk BRL $";
d38 1
a38 1
#include "jove.h"
@


2.3
log
@Fixed bug in paragraph justification.
@
text
@d4 1
a4 1
 * $Revision: 2.2 $
d7 3
d24 1
a24 1
static char RCSid[] = "@@(#)$Header: jove_misc.c,v 2.2 87/04/14 20:19:12 dpk BRL $";
d71 1
a71 1

d110 1
a110 1
	if (c == CTL(G)) {
d516 1
a516 1
	if (c == CTL(G)) {
d553 1
a553 1
	} while ((c = (*InputFunc)()) == CTL(U));
d608 1
a608 1
	case CTL(@@):
d611 1
a611 1
	case CTL(A):
d615 1
a615 1
	case CTL(B):
d620 1
a620 1
	case CTL(D):
d626 1
a626 1
	case CTL(E):
d631 1
a631 1
	case CTL(F):
d636 1
a636 1
	case CTL(G):
d639 1
a639 1
	case CTL(K):
d643 3
a645 3
	case CTL(N):
	case CTL(P):
		ArgIns(begin, c == CTL(N));
d650 1
a650 1
	case CTL(H):
d658 2
a659 2
	case META(\177):	/* Delete previous word */
	case CTL(W):
d668 2
a669 2
	case META(D):
	case META(d):
d673 2
a674 2
	case META(B):
	case META(b):
d678 2
a679 2
	case META(F):
	case META(f):
d683 2
a684 2
	case CTL(Y):
	case CTL(R):
d696 2
a697 2
	case CTL(^):
	case CTL(Q):
d749 1
a749 1
		else if (c == CTL(U))
@


2.2
log
@Fixed casting on RunEdit call
@
text
@d4 1
a4 1
 * $Revision: 2.1 $
d7 3
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: jove_misc.c,v 2.1 84/12/31 16:43:09 dpk Locked $";
d301 2
d332 2
d338 2
@


2.1
log
@Make CTL(Y)==CTL(R) in RunEdit() (command line editor)
@
text
@d4 1
a4 1
 * $Revision: 2.0 $
d7 3
d18 1
a18 1
static char RCSid[] = "@@(#)$Header: jove_misc.c,v 2.0 84/12/26 16:47:08 dpk Exp $";
d742 1
a742 1
			if ((int)(cp = RunEdit(c, begin, cp, def, HowToRead)) == -1)
@


2.0
log
@System as distributed to Berkeley 26 Dec 84
@
text
@d4 1
a4 1
 * $Revision: 1.2 $
d7 3
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: jove_misc.c,v 1.2 83/12/16 00:09:03 dpk BRL $";
d668 1
@


1.2
log
@Added distinctive RCS header
@
text
@d4 1
a4 1
 * $Revision$
d6 4
a9 1
 * $Log$
d12 1
a12 1
static char RCSid[] = "@@(#)$Header$";
a73 1
#ifdef MENLO_JCL
a74 3
#else
	signal(SIGALRM, slowpoke);
#endif
d104 1
d121 1
d141 1
a141 1
		mod = curbuf->b_modified;
d165 4
a168 1
	curbuf->b_modified = mod;
d217 2
a244 2
int	RMargin = RMARGIN;

d453 1
a453 2
			if ((bp->b_zero) && IsModified(bp) &&
					(bp->b_type != SCRATCHBUF)) {
d528 2
a529 2
GetFour(Input)
int	(*Input)();
d535 1
a535 1
	} while ((c = (*Input)()) == CTL(U));
d539 2
a540 2
GetArg(Input)
int	(*Input)();
d545 1
a545 1
	if (!isdigit(c = (*Input)()))
d582 2
a583 2
register char	*begin,
		*cp;
d643 1
a643 1
		char	*tcp = backup(begin, cp);
d645 2
a646 2
		strcpy(tcp, cp);
		cp = tcp;
d708 3
a710 3
ask(def, fmt, args)
char	*def,
	*fmt;
d719 1
a719 1
	format(string, fmt, &args);
d792 1
a792 2
		if (bp->b_zero == 0 || !IsModified(bp) ||
					bp->b_type == SCRATCHBUF)
d1184 18
@


1.1
log
@Original 4.2 Distribution Source
@
text
@d2 11
@
