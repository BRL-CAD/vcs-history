head	11.5;
access;
symbols
	ansi-20040405-merged:11.4
	postmerge-20040405-ansi:11.4
	premerge-20040404-ansi:11.4
	postmerge-autoconf:11.4
	autoconf-freeze:11.4
	premerge-autoconf:11.4
	ansi-20040316-freeze:11.4
	postmerge-20040315-windows:11.4
	premerge-20040315-windows:11.4
	windows-20040315-freeze:11.4
	autoconf-20031203:11.4
	autoconf-20031202:11.4
	autoconf-branch:11.4.0.12
	phong-branch:11.4.0.10
	photonmap-branch:11.4.0.8
	rel-6-1-DP:11.4
	windows-branch:11.4.0.6
	rel-6-0-2:11.4
	ansi-branch:11.4.0.4
	rel-6-0-1-branch:11.4.0.2
	hartley-6-0-post:11.4
	hartley-6-0-pre:11.4
	rel-6-0-1:11.4
	rel-6-0:11.4
	rel-5-4:11.3
	offsite-5-3-pre:11.4
	rel-5-3:11.3
	rel-5-2:11.3
	rel-5-1-branch:11.3.0.2
	rel-5-1:11.3
	rel-5-0:11.3
	rel-5-0-beta:11.3
	rel-4-5:11.3
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:2.2
	rel-3-0:2.2
	rel-2-3:2.2
	rel-2-0:2.2
	rel-1-24:2.2
	rel-1-20:2.1
	rel-1-10:2.1
	rt-2:2.0
	rt:1.2;
locks; strict;
comment	@ * @;


11.5
date	2004.05.21.17.48.33;	author morrison;	state dead;
branches;
next	11.4;

11.4
date	2000.08.24.23.12.24;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	97.01.03.17.42.17;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.06.21.03.43.58;	author gwyn;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.35.19;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.12.21.22.04.46;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	93.10.26.05.57.41;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.54.03;	author mike;	state Rel4_0;
branches;
next	2.10;

2.10
date	91.09.23.03.16.45;	author mike;	state Exp;
branches;
next	2.9;

2.9
date	91.09.23.02.58.55;	author mike;	state Exp;
branches;
next	2.8;

2.8
date	91.08.30.19.41.59;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	91.08.30.19.14.21;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	91.08.30.18.59.50;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	91.08.30.18.46.08;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	91.08.30.17.54.37;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	91.08.30.17.49.13;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	87.04.14.20.11.25;	author dpk;	state BRL;
branches;
next	2.1;

2.1
date	86.04.06.06.20.27;	author gwyn;	state Exp;
branches;
next	2.0;

2.0
date	84.12.26.16.47.33;	author dpk;	state Exp;
branches;
next	1.3;

1.3
date	84.07.12.15.04.39;	author dpk;	state Exp;
branches;
next	1.2;

1.2
date	83.12.16.00.09.16;	author dpk;	state BRL;
branches;
next	1.1;

1.1
date	83.12.16.00.09.12;	author dpk;	state Exp;
branches;
next	;


desc
@Jove is an EMACS like screen editor which will fit on 11's and Vaxen
@


11.5
log
@moved to src/other/jove/
@
text
@/*
 *			J O V E _ P R O C . C
 *
 * $Revision: 11.4 $
 *
 * $Log: jove_proc.c,v $
 * Revision 11.4  2000/08/24 23:12:24  mike
 *
 * lint, RCSid
 *
 * Revision 11.3  1997/01/03  17:42:17  jra
 * Mods for Irix 6.2
 *
 * Revision 11.2  1995/06/21  03:43:58  gwyn
 * Eliminated trailing blanks.
 * Use tempnam() where available.
 * Process buffer temp file was mode 644, now 600.
 * ProcTmp, cerrfmt, lerrfmt are now arrays rather than string literal pointers.
 * Use LBSIZE instead of hard-wired 100.
 * Fixed all the pseudo-varargs functions, using VA_* macros.
 * SIGTSTP branch had same code as other branch!
 * Must cast 0 when used as null pointer constant in argument list.
 * Improved child status return.
 * Added check for too many arguments to UNIX command.
 * Create pipe in privacy mode.
 *
 * Revision 11.1  95/01/04  10:35:19  mike
 * Release_4.4
 *
 * Revision 10.3  94/12/21  22:04:46  mike
 * Eliminated "statement not reached" warning.
 *
 * Revision 10.2  93/10/26  05:57:41  mike
 * ANSI C
 *
 * Revision 10.1  91/10/12  06:54:03  mike
 * Release_4.0
 *
 * Revision 2.10  91/09/23  03:16:45  mike
 * Eliminated return / return(expr) warning.
 * Removed some dead code
 *
 * Revision 2.9  91/09/23  02:58:55  mike
 * gldav() is not a BSD system call.
 *
 * Revision 2.8  91/08/30  19:41:59  mike
 * Added ^Xe to run cake, like ^X^E runs make.
 *
 * Revision 2.7  91/08/30  19:14:21  mike
 * Modified to successfully parse C compiler errors, even on more modern
 * compilers, and on the oddball CRAYs.
 *
 * Revision 2.6  91/08/30  18:59:50  mike
 * Modifications for clean compilation on the XMP
 *
 * Revision 2.5  91/08/30  18:46:08  mike
 * Changed from BSD index/rindex nomenclature to SYSV strchr/strrchr.
 *
 * Revision 2.4  91/08/30  17:54:37  mike
 * Changed #include directives to distinguish between local and system header
 * files.
 *
 * Revision 2.3  91/08/30  17:49:13  mike
 * Paul Stay mods for ANSI C
 *
 * Revision 2.2  87/04/14  20:11:25  dpk
 * Added hack for supporting CRAY.
 *
 * Revision 2.1  86/04/06  06:20:27  gwyn
 * SpellCom was using sprintf return value, non-portable.
 *
 * Revision 2.0  84/12/26  16:47:33  dpk
 * System as distributed to Berkeley 26 Dec 84
 *
 * Revision 1.2  83/12/16  00:09:16  dpk
 * Added distinctive RCS header
 *
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/jove/jove_proc.c,v 11.4 2000/08/24 23:12:24 mike Exp $";
#endif

/*
   Jonathan Payne at Lincoln-Sudbury Regional High School 5-25-83

   jove_proc.c

   This file contains procedures to handle the shell to buffer commands
   and buffer to shell commands.  It isn't especially neat, but I think
   it is understandable. */

#include "./jove.h"

#include <signal.h>

extern	char cerrfmt[];
extern	char lerrfmt[];

struct error {
	BUFFER		*er_buf;	/* Buffer error is in */
	LINE		*er_mess;	/* Actual error message */
	LINE		*er_text;	/* Actual error */
	int		er_char;	/* char pos of error */
	struct error	*er_next;	/* List of error */
};

struct error	*thiserror = 0,
		*errorlist = 0;
BUFFER		*thisbuf = 0;	/* Buffer that error parsing took place */

int	MakeAll = 0,		/* Not make -k */
	WtOnMk = 1;		/* Write the modified files when we make */

extern char	*StdShell;
extern char	ProcTmp[];

void		SpParse();

/* Add an error to the end of the list of errors.  This is used for
 * parse-C/LINT-errors and for the spell-buffer command
 */

struct error *
AddError(newerror, errline, buf, line, charpos)
struct error	*newerror;
LINE	*errline,
	*line;
BUFFER	*buf;
{
	if (newerror) {
		newerror->er_next = (struct error *)
				emalloc(sizeof (struct error));
		newerror = newerror->er_next;
	} else
		thiserror = newerror = errorlist = (struct error *)
				emalloc(sizeof (struct error));
	newerror->er_buf = buf;
	newerror->er_text = line;
	newerror->er_char = charpos;
	newerror->er_next = 0;
	newerror->er_mess = errline;
	return newerror;
}

/* Returns the num'th line in buffer `b' */

LINE *
LineAt(num, b)
register int	num;
BUFFER	 *b;
{
	register LINE	*lp = b->b_zero;

	while (--num > 0 && lp)
		lp = lp->l_next;
	return lp;
}

void
CParse()
{
	ErrParse(cerrfmt);
}

void
LintParse()
{
	ErrParse(lerrfmt);
}

/* Parse for C/LINT errors in the current buffer.  Set up for the next-error
   command. */

void
ErrParse(fmtstr)
char	*fmtstr;
{
	BUFLOC	*bp;
	char	fname[LBSIZE],
		lineno[10];
	struct error	*ep = 0;
	BUFFER	*buf;

	Bof();
	if (errorlist)
		ErrFree();
	thisbuf = curbuf;
	/* Find a line with a number on it */
	while (bp = dosearch(fmtstr, 1, 1)) {
		SetDot(bp);
		putmatch(1, fname, sizeof fname);
		putmatch(2, lineno, sizeof lineno);
		buf = do_find((WINDOW *) 0, fname);
		ep = AddError(ep, curline, buf, LineAt(atoi(lineno), buf), 0);
	}
}

/* Send the buffer to the spell program (for some reason, writing the
   file and running spell on that file caused spell to just sit there!)
   and then go find each occurrence of the mispelled words that the user
   says to go find.  Check out SpParse() */

void
SpellCom()
{
	WINDOW	*errwind,
		*savewind;
	char	command[LBSIZE];

	savewind = curwind;
	exp_p = 1;
	if (IsModified(curbuf))
		SaveFile();
	ignore(sprintf(command, "spell %s", curbuf->b_fname));
	ignore(UnixToBuf("Spell", 1, !exp_p, "/bin/sh", "sh", "-c",
			command, (char *)0));
	NotModified();
	Bof();		/* Beginning of (error messages) file */
	errwind = curwind;
	if (linebuf[0]) {
		SpParse(errwind, savewind);
		if (thiserror)
			NextError();
		message("Go get 'em");
	} else {
		message("No errors");
		SetWind(savewind);
	}
}

/* There is one word per line in the current buffer.  Read that word
   and ask the user whether he wants us to search for it (if it is a
   big buffer he may not want to if he thinks it is spelled correctly). */
void
SpParse(err, buf)
WINDOW	*err,
	*buf;
{
	BUFLOC	*bp;
	char	string[LBSIZE], ans = '\0';
	struct error	*newerr = 0;

	if (errorlist)
		ErrFree();
	thisbuf = err->w_bufp;
	for (;;) {
		SetWind(err);
		if (linebuf[0] == 0)
			goto nextword;
		s_mess("Is \"%s\" misspelled (Y or N)? ", linebuf);
		ignore(sprintf(string, "\\b%s\\b", linebuf));
		SetWind(buf);		/* Paper buffer */
		Bof();
		switch (ans = Upper(getch())) {
		case ' ':
		case '\n':
		case '\r':
			ans = 'N';
		case 'Y':
		case 'y':
		case 'N':
		case 'n':
			break;
		case '\07':
			return;
		default:
			rbell();
			continue;
		}
		if (ans == 'Y') {	/* Not correct */
			while (bp = dosearch(string, 1, 1)) {
				SetDot(bp);
				newerr = AddError(newerr,
				    thisbuf->b_dot, buf->w_bufp,
				    curline, curchar);
			}
		}

nextword:
		SetWind(err);	/* Back to error window to move to
				   the next word */
		if (eobp())
			break;
		if (ans == 'N') {	/* Delete the word ... */
			Bol();
			DoTimes(KillEOL, 1);	/* by deleting the line */
		} else {
			if (lastp(curline))
				break;
			else
				SetLine(curline->l_next);
		}
	}
}

/* Free up all the errors */

void
ErrFree()
{
	register struct error	*ep;

	for (ep = errorlist; ep; ep = ep->er_next)
		free((char *) ep);
	errorlist = thiserror = 0;
}

/* Go the the next error, if there is one.  Put the error buffer in
   one window and the buffer with the error in another window.
   It checks to make sure that the error actually exists. */

void
NextError()
{
	register int	i = exp;

	while (--i >= 0)
		DoNextErr();
}

void
DoNextErr()
{
	/* Make sure we haven't deleted the line with the actual error
	   by accident. */

	while (errorlist && thiserror) {
		if (inlist(thiserror->er_buf->b_zero, thiserror->er_text))
			break;
		thiserror = thiserror->er_next;
	}
	if (errorlist == 0 || thiserror == 0)
		complain("No errors");

	pop_wind(thisbuf->b_name, 0);
	SetLine(thiserror->er_mess);
	SetTop(curwind, (curwind->w_line = thiserror->er_mess));
	pop_wind(thiserror->er_buf->b_name, 0);
	DotTo(thiserror->er_text, thiserror->er_char);
	thiserror = thiserror->er_next;
}

/* Run make, first writing all the modified buffers (if the WtOnMk flag is
 * non-zero), parse the errors, and go the first error.
 */

void
MakeErrors()
{
	WINDOW	*old = curwind;
	int	status;
	char	*what;
	char	*null = "";

	what = ask(null, FuncName());
	if (what == null)
		what = 0;
	if (WtOnMk)
		WtModBuf();
	if (MakeAll)
		status = UnixToBuf("make", 1, 1, "make", "Make", "-k", what, (char *)0);
	else
		status = UnixToBuf("make", 1, 1, "make", "Make", what, (char *)0);
	com_finish(status, "make");
	if (errorlist)
		ErrFree();

	if (status)
		ErrParse(cerrfmt);

	if (thiserror)
		NextError();
	else
		SetWind(old);
}

/*
 *			C A K E E R R O R S
 *
 *  Run cake, first writing all the modified buffers (if the WtOnMk flag is
 *  non-zero), parse the errors, and go the first error.
 *  BRL Addition, Mike Muuss, 30-Aug-91.
 */
void
CakeErrors()
{
	WINDOW	*old = curwind;
	int	status;
	char	*what;
	char	*null = "";

	what = ask(null, FuncName());
	if (what == null)
		what = 0;
	if (WtOnMk)
		WtModBuf();
	if (MakeAll)
		status = UnixToBuf("cake", 1, 1, "cake", "cake", "-k", what, (char *)0);
	else
		status = UnixToBuf("cake", 1, 1, "cake", "cake", what, (char *)0);
	com_finish(status, "cake");
	if (errorlist)
		ErrFree();

	if (status)
		ErrParse(cerrfmt);

	if (thiserror)
		NextError();
	else
		SetWind(old);
}

/*
 *  Make a buffer name given the command `command', i.e. "fgrep -n foo *.c"
 *  will return the buffer name "fgrep".
 */
char *
MakeName(command)
char	*command;
{
	static char	bufname[50];
	char	*cp = bufname, c;

	while ((c = *command++) && (c == ' ' || c == '\t'))
		;
	do
		*cp++ = c;
	while ((c = *command++) && (c != ' ' && c != '\t'));
	*cp = 0;
	cp = strrchr(bufname, '/');
	if (cp)
		strcpy(bufname, cp + 1);
	return bufname;
}

static char	ShcomBuf[LBSIZE] = {0};	/* I hope ??? */

void
ShToBuf()
{
	char	bufname[LBSIZE];

	strcpy(bufname, ask((char *) 0, "Buffer: "));
	DoShell(bufname, ask(ShcomBuf, "Command: "));
}

void
ShellCom()
{
	strcpy(ShcomBuf, ask(ShcomBuf, FuncName()));
	DoShell(MakeName(ShcomBuf), ShcomBuf);
}

/* Run the shell command into `bufname'.  Empty the buffer except when we
   give a numeric argument, in which case it inserts the output at the
   current position in the buffer.  */

void
DoShell(bufname, command)
char	*bufname,
	*command;
{
	WINDOW	*savewp = curwind;
	int	status;

	exp = 1;
	status = UnixToBuf(bufname, 1, !exp_p, StdShell, "shell", "-c",
			command, (char *)0);
	com_finish(status, command);
	SetWind(savewp);
}

void
com_finish(status, com)
char	*com;
{
	s_mess("\"%s\" completed %ssuccessfully", com, status ? "un" : "");
}

void
dopipe(p)
int	p[];
{
	if (pipe(p) == -1)
		complain("Cannot pipe");
}

void
PipeClose(p)
int	p[];
{
	ignore(close(p[0]));
	ignore(close(p[1]));
}

/* Run the command to bufname, erase the buffer if clobber is non-zero,
 * and redisplay if disp is non-zero.
 */

/* VARARGS */

int
UnixToBuf(VA_T(char *bufname) VA_T(int disp) VA_T(int clobber)
	VA_T(const char *func) VA_ALIST)
	VA_DCL
{
	VA_D(char	*bufname)
	VA_D(int	disp)
	VA_D(int	clobber)
	VA_D(char	*func)
	VA_LIST(ap)
	char	*args[ALSIZE],
		**argp;
	int	p[2],
		pid;
	char	buff[LBSIZE];
	extern int	ninbuf;

	message("Starting up...");
	VA_START(ap, func)
	VA_I(ap, char *, bufname)
	VA_I(ap, int, disp)
	VA_I(ap, int, clobber)
	VA_I(ap, char *, func)
	for (argp = args; argp - args < ALSIZE; ++argp)
		if ((*argp = VA_ARG(ap, char *)) == (char *)0)
			break;
	VA_END(ap)
	if (argp - args == ALSIZE)
		complain("Too many arguments");
	pop_wind(bufname, clobber);
	if (disp)
		redisplay();
	if (clobber)
		SetScratch(curbuf);
	exp = 1;

	ttyset(0);
	dopipe(p);
	pid = fork();
	if (pid == -1) {
		PipeClose(p);
		complain("Cannot fork");
	}
	if (pid == 0) {
		ignorf(signal(SIGINT, SIG_DFL));
		ignore(close(1));
		ignore(close(2));
		ignore(dup(p[1]));
		ignore(dup(p[1]));
		PipeClose(p);
		execvp(func, args);
		ignore(write(1, "Execvp failed", 12));
		_exit(1);
	} else {
		int	status;
		char	*mess;

		ignore(close(p[1]));
		io = p[0];
		while (getfline(buff) != EOF) {
			ins_str(buff);
			LineInsert();
			if (ninbuf <= 0) {
				mess = "Chugging along...";
				message(mess);
				redisplay();
			}
		}
		UpdateMesg();
		IOclose();
		while (wait(&status) != pid)
			;
		ttyset(1);
		return status;
	}
	return 0;
}

/* Send a region to shell.  Now we can beautify C and sort programs */

void
RegToShell()
{
	char	com[LBSIZE];
	MARK	*m = CurMark();

	strcpy(com, ask((char *) 0, FuncName()));
	if (!exp_p) {
		exp_p = 1;	/* So it doesn't delete the region */
		exp = 0;
	}
	if (inorder(m->m_line, m->m_char, curline, curchar))
		RegToUnix(curbuf->b_name, 1, m->m_line, m->m_char,
					curline, curchar, com);
	else
		RegToUnix(curbuf->b_name, 1, curline, curchar, m->m_line,
					m->m_char, com);
	message("Done");
}

/* Writes the region to a tmp file and then run the command with input
   from that file */

void
RegToUnix(bufname, replace, line1, char1, line2, char2, func)
char	*bufname;
LINE	*line1,
	*line2;
char	*func;
{
#if HAS_TEMPNAM
	/* Honor $TMPDIR in user's environment */
	char	*fname = tempnam((char *)NULL, "jovep");
#else
	char	*fname = mktemp(ProcTmp);
#endif
	char	com[LBSIZE];

	if ((io = creat(fname, 0600)) == -1)
		complain(IOerr("create", fname));
	putreg(line1, char1, line2, char2);
	IOclose();
	if (replace)
		DelReg();
	ignore(sprintf(com, "%s < %s", func, fname));
	ignore(UnixToBuf(bufname, 0, 0, StdShell, "shell", "-c", com, (char *)0));
	ignore(unlink(fname));
}
@


11.4
log
@
lint, RCSid
@
text
@d4 1
a4 1
 * $Revision: 11.3 $
d7 4
d80 1
a80 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/jove/jove_proc.c,v 11.3 1997/01/03 17:42:17 jra Exp $";
@


11.3
log
@Mods for Irix 6.2
@
text
@d4 1
a4 1
 * $Revision: 11.2 $
d7 3
d76 1
a76 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_proc.c,v 11.2 1995/06/21 03:43:58 gwyn Exp jra $";
@


11.2
log
@Eliminated trailing blanks.
Use tempnam() where available.
Process buffer temp file was mode 644, now 600.
ProcTmp, cerrfmt, lerrfmt are now arrays rather than string literal pointers.
Use LBSIZE instead of hard-wired 100.
Fixed all the pseudo-varargs functions, using VA_* macros.
SIGTSTP branch had same code as other branch!
Must cast 0 when used as null pointer constant in argument list.
Improved child status return.
Added check for too many arguments to UNIX command.
Create pipe in privacy mode.
@
text
@d4 1
a4 1
 * $Revision: 11.1 $
d6 14
a19 1
 * $Log:	jove_proc.c,v $
d73 1
a73 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_proc.c,v 11.1 95/01/04 10:35:19 mike Rel4_4 $";
d152 1
d158 1
d167 1
d196 1
d291 1
d305 1
d314 1
d340 1
d377 1
d432 1
d441 1
d452 1
d467 1
d474 1
d482 1
d576 1
d599 1
@


11.1
log
@Release_4.4
@
text
@d2 1
a2 1
 *			J O V E _ P R O C . C 
d4 1
a4 1
 * $Revision: 10.3 $
d7 3
d12 1
a12 1
 * 
d15 1
a15 1
 * 
d18 1
a18 1
 * 
d22 1
a22 1
 * 
d25 1
a25 1
 * 
d28 1
a28 1
 * 
d32 1
a32 1
 * 
d35 1
a35 1
 * 
d38 1
a38 1
 * 
d42 1
a42 1
 * 
d45 1
a45 1
 * 
d48 1
a48 1
 * 
d51 1
a51 1
 * 
d54 1
a54 1
 * 
d57 1
a57 1
 * 
d60 1
a60 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_proc.c,v 10.3 94/12/21 22:04:46 mike Exp $";
d65 1
a65 1
  
d76 2
a77 2
extern	char *cerrfmt;
extern	char *lerrfmt;
d95 1
a95 1
extern char	*ProcTmp;
d156 1
a156 1
	char	fname[100],
d160 1
a160 1
	
d175 1
a175 1
/* Send the buffer to the spell program (for some reason, writing the 
d184 1
a184 1
	char	command[100];
d190 1
a190 2

	ignore(sprintf(command, "spell %s", curbuf->b_fname));	/* DAG */
d192 1
a192 1
			command, 0));	/* DAG -- don't use sprintf return value */
d216 1
a216 1
	char	string[100], ans = '\0';
d249 1
a249 1
				newerr = AddError(newerr, 
d254 1
a254 1
			
d333 1
a333 1
		status = UnixToBuf("make", 1, 1, "make", "Make", "-k", what, 0);
d335 1
a335 1
		status = UnixToBuf("make", 1, 1, "make", "Make", what, 0);
d369 1
a369 1
		status = UnixToBuf("cake", 1, 1, "cake", "cake", "-k", what, 0);
d371 1
a371 1
		status = UnixToBuf("cake", 1, 1, "cake", "cake", what, 0);
d408 1
a408 1
static char	ShcomBuf[100] = {0};	/* I hope ??? */
d412 1
a412 1
	char	bufname[100];
d437 1
a437 1
			command, 0);
d466 1
a466 1
/* VARARGS3 */
d468 12
a479 8
#if defined(CRAY)
UnixToBuf(bufname, disp, clobber, func, a1, a2, a3, a4, a5, a6)
#else
UnixToBuf(bufname, disp, clobber, func, args)
#endif
char	*bufname,
	*func;
{
a483 1
	int	status = 0;
d486 11
d499 1
a499 1
		redisplay();		
a511 3
#ifdef SIGTSTP
		ignorf(signal(SIGINT, SIG_DFL));
#else
a512 1
#endif
d518 3
a520 7
#if defined(CRAY)
		execlp(func, a1, a2, a3, a4, a5, a6, (char *)0);
#else
		execvp(func, (char **) &args);
#endif
		ignore(write(1, "Execl failed", 12));
		exit(1);
d522 1
d541 1
d543 1
a543 1
	return status;
d550 1
a550 1
	char	com[100];
d576 4
d581 2
a582 1
	char	com[100];
d584 1
a584 1
	if ((io = creat(fname, 0644)) == -1)
d591 1
a591 1
	ignore(UnixToBuf(bufname, 0, 0, StdShell, "shell", "-c", com, 0));
@


10.3
log
@Eliminated "statement not reached" warning.
@
text
@d4 1
a4 1
 * $Revision: 10.2 $
d7 3
d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_proc.c,v 10.2 93/10/26 05:57:41 mike Exp Locker: mike $";
@


10.2
log
@ANSI C
@
text
@d4 1
a4 1
 * $Revision: 10.1 $
d7 3
d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_proc.c,v 10.1 91/10/12 06:54:03 mike Rel4_0 Locker: mike $";
d475 1
a510 1
		int	status;
a528 1
		return status;
d530 1
a530 1
	return 0;
@


10.1
log
@Release_4.0
@
text
@d4 1
a4 1
 * $Revision: 2.10 $
d7 3
d51 1
a51 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_proc.c,v 2.10 91/09/23 03:16:45 mike Exp $";
d88 2
d202 1
a202 1

@


2.10
log
@Eliminated return / return(expr) warning.
Removed some dead code
@
text
@d4 1
a4 1
 * $Revision: 2.9 $
d7 4
d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_proc.c,v 2.9 91/09/23 02:58:55 mike Exp $";
@


2.9
log
@gldav() is not a BSD system call.
@
text
@d4 1
a4 1
 * $Revision: 2.8 $
d7 3
d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_proc.c,v 2.8 91/08/30 19:41:59 mike Exp $";
a506 1
#ifdef VMUNIX			/* No easy way to find out */
a507 20
#else
#ifdef 0
				/* Needs gldav() to get load average */
				{
					short	avg[3];
					double	theavg;

					ignore(gldav(avg));
					theavg = (double) avg[0] / 256;
					if (theavg < 1.0)
					    mess = "Screaming along...";
					else if (theavg < 3.0)
					    mess = "Chugging along...";
					else
					    mess = "Crawling along...";
				}
#else
				mess = "Chugging along...";
#endif
#endif
d519 1
@


2.8
log
@Added ^Xe to run cake, like ^X^E runs make.
@
text
@d4 1
a4 1
 * $Revision: 2.7 $
d7 3
d41 1
a41 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_proc.c,v 2.7 91/08/30 19:14:21 mike Exp $";
d507 2
a508 1
#ifdef JOBCONTROL
@


2.7
log
@Modified to successfully parse C compiler errors, even on more modern
compilers, and on the oddball CRAYs.
@
text
@d4 1
a4 1
 * $Revision: 2.6 $
d7 4
d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_proc.c,v 2.6 91/08/30 18:59:50 mike Exp $";
d314 36
@


2.6
log
@Modifications for clean compilation on the XMP
@
text
@d4 1
a4 1
 * $Revision: 2.5 $
d7 3
d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_proc.c,v 2.5 91/08/30 18:46:08 mike Exp $";
a313 1
#ifndef VMUNIX
a314 3
#else
		ErrParse(lerrfmt);
#endif
@


2.5
log
@Changed from BSD index/rindex nomenclature to SYSV strchr/strrchr.
@
text
@d4 1
a4 1
 * $Revision: 2.4 $
d7 3
d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_proc.c,v 2.4 91/08/30 17:54:37 mike Exp $";
d186 1
a186 1
	char	string[100], ans;
@


2.4
log
@Changed #include directives to distinguish between local and system header
files.
@
text
@d4 1
a4 1
 * $Revision: 2.3 $
d7 4
d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_proc.c,v 2.3 91/08/30 17:49:13 mike Exp $";
d337 1
a337 1
	cp = rindex(bufname, '/');
@


2.3
log
@Paul Stay mods for ANSI C
@
text
@d4 1
a4 1
 * $Revision: 2.2 $
d7 3
d24 1
a24 1
static char RCSid[] = "@@(#)$Header: jove_proc.c,v 2.2 87/04/14 20:11:25 dpk BRL $";
d36 1
a36 1
#include "jove.h"
@


2.2
log
@Added hack for supporting CRAY.
@
text
@d4 1
a4 1
 * $Revision: 2.1 $
d7 3
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: jove_proc.c,v 2.1 86/04/06 06:20:27 dpk Locked $";
d305 1
a305 1
#endif VMUNIX
d471 2
a472 2
#endif JOBCONTROL
#endif VMUNIX
a483 1
	return 0;
@


2.1
log
@SpellCom was using sprintf return value, non-portable.
@
text
@d4 1
a4 1
 * $Revision: 2.0 $
d7 3
d18 1
a18 1
static char RCSid[] = "@@(#)$Header: jove_proc.c,v 2.0 84/12/26 16:47:33 dpk Exp $";
d393 3
d397 1
d432 3
d436 1
@


2.0
log
@System as distributed to Berkeley 26 Dec 84
@
text
@d4 1
a4 1
 * $Revision: 1.2 $
d7 3
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: jove_proc.c,v 1.2 83/12/16 00:09:16 dpk BRL $";
d144 1
d146 1
a146 1
			sprintf(command, "spell %s", curbuf->b_fname), 0));
@


1.3
log
@Prior to spell fix.
@
text
@d28 2
a29 4
char	*cerrfmt = "\\([^:]*\\):\\([0-9][0-9]*\\):";
	/* C error scanf format string for errors of the form
	 * filename:linenum: error message
	 */
a30 5
char	*lerrfmt = "\"\\([^:]*\\)\", line \\([0-9][0-9]*\\):";
	/* Lint error for errors of the form
	 * "filename", line linenum: error message.
	 */

d47 1
d166 1
a166 2
	char	string[100],
		ans;
a171 1
	SetWind(err);
d173 1
d180 16
a195 4
		do
			ans = getch();
		while ((ans = Upper(ans)) != 'Y' && ans != 'N');

a415 4
/*********
**		ignore(close(0));
**		ignore(open("/dev/null", 0));
**********/
d423 1
a423 1
		_exit(1);
a424 7
#ifndef NOINTR
#ifdef SIGTSTP
		int	(*oldquit)() = signal(SIGINT, SIG_IGN);
#else
		int	(*oldquit)() = signal(SIGINT, SIG_IGN);
#endif
#endif NOINTR
d437 1
a437 1
#ifdef MENLO_JCL
d453 1
a453 1
#endif MENLO_JCL
a460 7
#ifndef NOINTR
#ifdef SIGTSTP
		ignorf(signal(SIGINT, oldquit));
#else
		ignorf(signal(SIGINT, oldquit));
#endif
#endif NOINTR
d499 1
a499 1
	char	*fname = mktemp(TMPFILE);
@


1.2
log
@Added distinctive RCS header
@
text
@d4 1
a4 1
 * $Revision$
d6 4
a9 1
 * $Log$
d12 1
a12 1
static char RCSid[] = "@@(#)$Header$";
d269 2
d272 3
d278 1
a278 1
		status = UnixToBuf("make", 1, 1, "/bin/make", "Make", "-k", 0);
d280 1
a280 1
		status = UnixToBuf("make", 1, 1, "/bin/make", "Make", 0);
d298 4
a301 3
/* Make a buffer name given the command `command', i.e. "fgrep -n foo *.c"
   will return the buffer name "fgrep".  */

d395 1
a395 1
		curbuf->b_type = SCRATCHBUF;
d411 4
a414 2
		ignore(close(0));
		ignore(open("/dev/null", 0));
d420 1
a420 1
		execv(func, (char **) &args);
@


1.1
log
@Original 4.2 Distribution Source
@
text
@d2 11
@
