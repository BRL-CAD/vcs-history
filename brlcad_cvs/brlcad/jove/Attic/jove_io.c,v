head	11.6;
access;
symbols
	ansi-20040405-merged:11.5
	postmerge-20040405-ansi:11.5
	premerge-20040404-ansi:11.5
	postmerge-autoconf:11.5
	autoconf-freeze:11.5
	premerge-autoconf:11.5
	ansi-20040316-freeze:11.5
	postmerge-20040315-windows:11.5
	premerge-20040315-windows:11.5
	windows-20040315-freeze:11.5
	autoconf-20031203:11.5
	autoconf-20031202:11.5
	autoconf-branch:11.5.0.12
	phong-branch:11.5.0.10
	photonmap-branch:11.5.0.8
	rel-6-1-DP:11.5
	windows-branch:11.5.0.6
	rel-6-0-2:11.5
	ansi-branch:11.5.0.4
	rel-6-0-1-branch:11.5.0.2
	hartley-6-0-post:11.5
	hartley-6-0-pre:11.5
	rel-6-0-1:11.5
	rel-6-0:11.5
	rel-5-4:11.4
	offsite-5-3-pre:11.5
	rel-5-3:11.4
	rel-5-2:11.4
	rel-5-1-branch:11.4.0.2
	rel-5-1:11.4
	rel-5-0:11.4
	rel-5-0-beta:11.4
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:2.2
	rel-3-0:2.2
	rel-2-3:2.2
	rel-2-0:2.2
	rel-1-24:2.2
	rel-1-20:2.1
	rel-1-10:2.1
	rt-2:2.0
	rt:1.3;
locks; strict;
comment	@ * @;


11.6
date	2004.05.21.17.48.33;	author morrison;	state dead;
branches;
next	11.5;

11.5
date	2000.08.24.23.12.23;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	99.05.13.19.54.41;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	99.01.12.03.05.25;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.06.21.03.41.51;	author gwyn;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.35.15;	author mike;	state Rel4_4;
branches;
next	10.5;

10.5
date	95.01.03.21.35.28;	author butler;	state Exp;
branches;
next	10.4;

10.4
date	94.09.17.04.57.35;	author butler;	state Exp;
branches;
next	10.3;

10.3
date	93.10.26.06.31.25;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.01.31.16.56.12;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.54.00;	author mike;	state Rel4_0;
branches;
next	2.11;

2.11
date	91.08.30.22.56.06;	author mike;	state Exp;
branches;
next	2.10;

2.10
date	91.08.30.22.37.07;	author mike;	state Exp;
branches;
next	2.9;

2.9
date	91.08.30.20.29.44;	author mike;	state Exp;
branches;
next	2.8;

2.8
date	91.08.30.19.34.16;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	91.08.30.19.17.44;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	91.08.30.18.46.05;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	91.08.30.18.11.04;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	91.08.30.17.54.34;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	91.08.30.17.49.08;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	87.04.14.20.27.17;	author dpk;	state BRL;
branches;
next	2.1;

2.1
date	86.09.23.22.28.40;	author mike;	state Exp;
branches;
next	2.0;

2.0
date	84.12.26.16.46.34;	author dpk;	state Exp;
branches;
next	1.3;

1.3
date	84.03.20.22.29.18;	author dpk;	state BRL;
branches;
next	1.2;

1.2
date	83.12.16.00.08.33;	author dpk;	state BRL;
branches
	1.2.1.1;
next	1.1;

1.1
date	83.12.16.00.08.28;	author dpk;	state Exp;
branches;
next	;

1.2.1.1
date	84.03.20.22.36.11;	author dpk;	state BRL;
branches;
next	;


desc
@Jove is an EMACS like screen editor which will fit on 11's and Vaxen
@


11.6
log
@moved to src/other/jove/
@
text
@/*
 *			J O V E _ I O . C
 *
 * $Revision: 11.5 $
 *
 * $Log: jove_io.c,v $
 * Revision 11.5  2000/08/24 23:12:23  mike
 *
 * lint, RCSid
 *
 * Revision 11.4  1999/05/13  19:54:41  jra
 * Linux "stat" corrupts its args on failure!!!!!
 *
 * Revision 11.3  1999/01/12  03:05:25  mike
 * Recognize file suffixes for C++ code as well as C code.
 *
 * Revision 11.2  1995/06/21  03:41:51  gwyn
 * Eliminated trailing blanks.
 * TempFile is now an array.
 * Improved use of tempnam().
 * Changed memcpy calls back to bcopy.  (Fixed confusing use of SYSV vs. SYS5.)
 * Use LBSIZE instead of hard-wired 100.
 *
 * Revision 11.1  95/01/04  10:35:15  mike
 * Release_4.4
 *
 * Revision 10.5  95/01/03  21:35:28  butler
 * lseek takes an off_t as its second arg under BSDI and NetBSD
 *
 * Revision 10.4  1994/09/17  04:57:35  butler
 * changed all calls to bcopy to be memcpy instead.  Useful for Solaris 5.2
 *
 * Revision 10.3  1993/10/26  06:31:25  mike
 * Modified to use tempnam(), so that $TMPDIR from user's environment
 * will be honored if set
 *
 * Revision 10.2  92/01/31  16:56:12  mike
 * Must do chown() *after* close(), so that on NFS clients, we don't
 * loose write permission on the file before we write any data into it.
 *
 * Revision 10.1  91/10/12  06:54:00  mike
 * Release_4.0
 *
 * Revision 2.11  91/08/30  22:56:06  mike
 * __CRAY1 too
 *
 * Revision 2.10  91/08/30  22:37:07  mike
 * Fixed in-core buffering to operate on the array subscripts, rather than
 * a (char *) pointer, as this is more portable, and avoids CRAY problems.
 * In addition, turned off the in-core buffering on CRAY1 (and X and Y)
 * systems, as it consumes an extra 256 Kbytes, which on smaller Crays
 * isn't worth it.  Their I/O is plenty fast, and memory is usually tight.
 *
 * Revision 2.9  91/08/30  20:29:44  mike
 * Added extern int read().
 *
 * Revision 2.8  91/08/30  19:34:16  mike
 * Changed VMUNIX to !defined(pdp11)
 *
 * Revision 2.7  91/08/30  19:17:44  mike
 * Stardent ANSI lint
 *
 * Revision 2.6  91/08/30  18:46:05  mike
 * Changed from BSD index/rindex nomenclature to SYSV strchr/strrchr.
 *
 * Revision 2.5  91/08/30  18:11:04  mike
 * Made explicit that termcap.h to be used is the local version
 *
 * Revision 2.4  91/08/30  17:54:34  mike
 * Changed #include directives to distinguish between local and system header
 * files.
 *
 * Revision 2.3  91/08/30  17:49:08  mike
 * Paul Stay mods for ANSI C
 *
 * Revision 2.2  87/04/14  20:27:17  dpk
 * Commented out the bcopy routine.  Will use memcpy for bcopy.
 *
 * Revision 2.1  86/09/23  22:28:40  mike
 * Externs now declared properly.
 * I/O fixes for SysV
 *
 * Revision 2.1  86/09/23  22:26:37  mike
 * Externs now declared properly.
 * I/O fixes for SysV
 *
 * Revision 2.0  84/12/26  16:46:34  dpk
 * System as distributed to Berkeley 26 Dec 84
 *
 *
 * Revision 1.3  84/03/20  22:29:18  dpk
 * Improved file handling, fixed "Free line in list" loop
 *
 * Revision 1.2  83/12/16  00:08:33  dpk
 * Added distinctive RCS header
 *
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/jove/jove_io.c,v 11.5 2000/08/24 23:12:23 mike Exp $";
#endif

/*
   Jonathan Payne at Lincoln-Sudbury Regional High School 5-25-83

   Commands to read/write files/regions.  */

#include <stdio.h>
#include "./jove.h"
#include "./termcap.h"

#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>

extern	int errno;
extern	int Dfltmode;
extern	char TempFile[];

int	BackupFiles = SAVE_NO;

char	*WERROR	= "Write error";
long	count = 0;
int	nlines = 0;

char	iobuff[LBSIZE],
	*nextip;
int	ninbuf;

/**** Shared with jove_screen.c ****/
char	ibuff1[BSIZ],	/* Holds block `iblock1' of the tmp file */
	ibuff2[BSIZ],	/*   "     "   `iblock2' of the tmp file */
	obuff[BSIZ];	/* Holds the last block of the tmp file */
int	ichng1,		/* ibuff1 should be written to its
			 * blocks when it is used to read
			 * another block.
			 */
	ichng2,		/* "" */
	iblock1,	/* Block number of ibuff1 */
	iblock2,	/*		   ibuff2 */
	oblock,		/* 		   obuff  */
	nleft,		/* Number of good characters left in current block */
	hitin2,		/* Last read was in ibuff2 */
	tmpfd;
disk_line	tline;		/* Pointer to end of tmp file */

char	*tfname;

extern int	read(), write();

void	dofread();
void	DoWriteReg();
void	file_write();
void	setcmode();
void	dolseek();
void	blkio();
void	lsave();
void	getDOT();
void	SavLine();

/***********************************/

void
IOclose()
{
	if (io > 0)
		ignore(close(io)), io = -1;
	nextip = iobuff;
	ninbuf = 0;
}

/* This reads a line from the input file into buf. */

int
getfline(buf)
char	*buf;
{
	register int	c;
	register char	*lp,
			*fp;

	lp = buf;
	*lp = '\0';
	fp = nextip;
	do {
		if (--ninbuf < 0) {
			ninbuf = read(io, iobuff, LBSIZE) - 1;
			fp = iobuff;
			if (ninbuf < 0) {
				*lp = '\0';
				IOclose();
				return EOF;
			}
		}
		c = *fp++;
		if (c == '\0')
			continue;
		if (lp >= &buf[LBSIZE - 1]) {
			message("Line to long...");
			redisplay();
			IOclose();
			return EOF;
		}

		*lp++ = c;
		count++;
	} while (c != '\n');
	*--lp = 0;
	nextip = fp;
	return 0;
}

/* Write the region from line1/char1 to line2/char2 to the open
   fildes `io'.  */

int	EndWNewline = 1;

void
putreg(line1, char1, line2, char2)
LINE	*line1,
	*line2;
{
	int n;
	register char *fp, *lp;
	register int	nib;

	count = nlines = 0;
	nib = LBSIZE;
	fp = iobuff;
	lsave();	/* Need this! */

	while (line1 != line2->l_next) {
		lp = getline(line1->l_dline, linebuf) + char1;
		if (line1 == line2)
			linebuf[char2] = '\0';
		for (;;) {
			if (--nib < 0) {
				n = fp - iobuff;
				if (write(io, iobuff, n) != n)
					goto werror;
				nib = LBSIZE-1;
				count += n;
				fp = iobuff;
			}
			if ((*fp++ = *lp++) == 0) {
				if (line1 != line2) {
					nlines++;
					fp[-1] = '\n';
				} else
					fp--;	/* Don't write the NULL!! */
				break;
			}
		}
		line1 = line1->l_next;
		char1 = 0;
	}
	n = fp - iobuff;

	if (write(io, iobuff, n) != n)
		goto werror;
	count += n;
	getDOT();		/* What ever was in linebuf */
	IOclose();
	return;
werror:
	error(WERROR);
	/* NOTREACHED */
}

char *
IOerr(err, file)
char	*err, *file;
{
	return sprint("Couldn't %s \"%s\"", err, file);
}

void
read_file(file)
char	*file;
{
	BUFLOC	save;

	setcmode();

	io = open(file, 0);
	if (io == -1) {
		curbuf->b_ino = -1;
		s_mess(IOerr("open", file));
		return;
	}
	DOTsave(&save);
	set_ino(curbuf);
	dofread(file);
	SetDot(&save);
	getDOT();
	IOclose();
	if (access (file, 02))
		SetReadOnly(curbuf);
}

void
FileMess(file, lines, chars)
char	*file;
long	chars;
{
	s_mess("\"%s\" %d lines %ld characters", file, lines, chars);
}

void
dofread(file)
char	*file;
{
	char	end[LBSIZE];
	int	xeof = 0;

	lsave();
	nlines = 0;
	count = 0L;
	s_mess("\"%s\"", file);
	UpdateMesg();
	ignore(getline(curline->l_dline, end));
	strcpy(genbuf, end);
	strcpy(end, &end[curchar]);
	if ((xeof = getfline(linebuf)) == 0)
		linecopy(genbuf, curchar, linebuf);

	curline->l_dline = putline(genbuf);
	if (!xeof) do {
		xeof = getfline(linebuf);
		nlines++;
		curline = listput(curbuf, curline);
		curline->l_dline = putline(linebuf) | DIRTY;
	} while (!xeof);

	linecopy(linebuf, (curchar = strlen(linebuf)), end);
	curline->l_dline = putline(linebuf);
	FileMess(file, nlines, count);
}

void
bufname(bp)
BUFFER	*bp;
{
	char	tmp[LBSIZE],
		tmp1[LBSIZE],
		*cp;
	int	try = 1;

	if ((cp = bp->b_fname) == 0)
		complain("No file name");

	if (*cp == '.')
		++cp;
	strcpy(tmp, cp);
	cp = strrchr(tmp, '/');
	if (cp)
		strncpy(tmp, &cp[1], sizeof tmp);

	strcpy(tmp1, tmp);
	while (buf_exists(tmp)) {
		ignore(sprintf(tmp, "%s[%d]", tmp1, try));
		try++;
	}
	setbname(bp, tmp);
}

void
SaveFile()
{
	if (IsModified(curbuf)) {
		file_write(curbuf->b_fname, 0);
		SetUnmodified(curbuf);
	} else
		message("No changes need be written");
}

void
filemunge(fname)
char	*fname;
{
	struct stat	stbuf;

	if (stat(fname, &stbuf))
		return;
	if ((stbuf.st_ino != curbuf->b_ino
	   || stbuf.st_dev != curbuf->b_dev)
	  && (stbuf.st_mode & S_IFMT) != S_IFCHR)
		confirm("\"%s\" already exist; are you sure? ", fname);
}

void
WrtReg()
{
	DoWriteReg(0);
}

void
AppReg()
{
	DoWriteReg(1);
}

void
DoWriteReg(app)
{
	char	fname[LBSIZE];
	MARK	*mp = CurMark();

	/* Won't get here if there isn't a mark */
	strcpy(fname, ask((char *)0, FuncName()));

	if (!app)
		filemunge(fname);
	if (app) {
		io = open(fname, 1);	/* Writing */
		if (io == -1)
			io = creat(fname, Dfltmode);
		else
			dolseek(io, 0L, 2);
	} else
		io = creat(fname, Dfltmode);
	if (io == -1)
		complain(IOerr("create", fname));

	s_mess("\"%s\"", fname);
	UpdateMesg();			/* Update mesg line */
	if (inorder(mp->m_line, mp->m_char, curline, curchar))
		putreg(mp->m_line, mp->m_char, curline, curchar);
	else
		putreg(curline, curchar, mp->m_line, mp->m_char);
	FileMess(fname, nlines, count);
	IOclose();
}

void
WriteFile()
{
	char	*fname,
		fnamebuf[LBSIZE];

	fname = ask(curbuf->b_fname, FuncName());
	strncpy(fnamebuf, fname, sizeof fnamebuf);

	filemunge(fnamebuf);
	setfname(curbuf, fnamebuf);
	set_ino(curbuf);
	file_write(curbuf->b_fname, exp_p);
	SetUnmodified(curbuf);
}

char	*SaveName();

void
file_write(fname, app)
char	*fname;
{
	struct stat	inode;
	register int	exists;
	register int	linked;
	int		saveit = 0;
	int		overwrite = 0;
	int		do_chown = 0;

	if (fname == 0 || *fname == '\0')
		complain("I need a file name");

	io = -1;
	inode.st_mode = Dfltmode;
	inode.st_nlink = 1;
	inode.st_uid = getuid();
	inode.st_gid = getgid();
	exists = !stat(fname, &inode);
	if( !exists )
	{
		/* Linux "stat" corrupts its args on failure */
		inode.st_mode = Dfltmode;
		inode.st_nlink = 1;
		inode.st_uid = getuid();
		inode.st_gid = getgid();
	}
	linked = (inode.st_nlink > 1);

	if (IsReadOnly(curbuf) && exists) {
		register char *yorn;

		yorn = ask ("Y", "%s is read-only, recreate? (yes) ", fname);
		if (*yorn == 'N' || *yorn == 'n')
			complain ("File save aborted.");
		if (unlink(fname) != 0)
			complain ("Cannot unlink %s", fname);
	}

	if (app) {
		/*  Appending to a file  */
		io = open(fname, 1);	/* Writing */
		if (io == -1)
			io = creat(fname, Dfltmode);
		else
			dolseek(io, 0L, 2);
	} else {
		register char	*yorn;

		if (linked) {
			yorn = ask("Y", "%s has links, overwrite? (yes) ", fname);
			overwrite = (*yorn == 'Y' || *yorn == 'y');
		}
		if (exists && BackupFiles == SAVE_ASK) {
			yorn = ask("N", "Create backup file %s~ (no) ", fname);
			saveit = (*yorn == 'Y' || *yorn == 'y');
		}

		/* Write in a whole new file */
		s_mess("\"%s\"", fname);
		if (exists && (saveit || BackupFiles == SAVE_ALWAYS)) {
			register char *savefile;

			savefile = SaveName(fname);
		 	unlink (savefile);
		   	if (linked && overwrite) {
		   		/*  We need to "cp" the file  */
		   		s_mess("\"%s\" [No backup with overwrite]", fname);
		   	} else {
			 	if (link (fname, savefile))
			   		s_mess("\"%s\" [No backup possible]", fname);
			 	else
		 			unlink (fname);
		 	}
			free (savefile);
		}
		io = creat(fname, inode.st_mode&07777);
		do_chown = 1;
	}
	if (io == -1)
		complain(IOerr("create", fname));

	ClrReadOnly(curbuf);
	if (access(fname, 02))
		SetReadOnly(curbuf);

	UpdateMesg();		/* Update mesg line */
	if (EndWNewline) {	/* Make sure file ends with a newline */
		BUFLOC	save;

		DOTsave(&save);
		Eof();
		if (length(curline))	/* Not a blank line */
			DoTimes(LineInsert, 1);	/* Make it blank */
		SetDot(&save);
	}
	putreg(curbuf->b_zero, 0, curbuf->b_dol, length(curbuf->b_dol));
	FileMess(fname, nlines, count);
	IOclose();
	if( do_chown )  {
		/*  This will fail on all but USG systems, ignore it.
		 *  Must be done *after* close, so that on NFS clients,
		 *  we don't loose write permission on the file before
		 *  we write any data into it...
		 */
		chown (fname, inode.st_uid, inode.st_gid);
	}
}

char *
SaveName (fname)
char *fname;
{
	register int	len = strlen(fname);
	register char *cp;

#ifndef V4_2BSD
	if (cp = strrchr(fname, '/'))
		cp++;
	else
		cp = fname;

	if ( (int)strlen(cp) > 13)
		complain("Cannot make backup name; \"%s\" too long", cp);
#endif
	cp = emalloc (len+2);
	strncpy (cp, fname, len);
	cp[len] = '~';
	cp[len+1] = 0;
	return (cp);
}

void
initlist(bp)
BUFFER	*bp;
{
	lfreelist(bp->b_zero);
	ignore(listput(bp, (LINE *) 0));		/* First line in buffer */

	bp->b_dot->l_dline = putline("") | DIRTY;
	bp->b_char = 0;
	AllMarkSet(bp, bp->b_dot, 0);
	if (bp == curbuf)  {
		getDOT();
	}
	initwinds(bp);
}

void
setcmode()
{
	register int	len;
	register char	*name = curbuf->b_fname;

	if( !name )  return;
	len = strlen(name);

	if (len < 2 || IsDisabled(globflags, CMODE))
		return;

	/* Find trailing dot, if any */
	while( --len >= 0 )  {
		if(name[len] == '.') break;
	}
	if( len < 0 )  return;
	name += len+1;		/* Now points at char after the dot */

	/* Compare against known names for C and C++ code */
	if( name[1] == '\0' )  {
		switch(name[0]) {
		case 'C':
		case 'c':
		case 'h':
		case 'H':
			OnFlag(globflags, CMODE);
			return;
		}
	}
	else if(
		strcmp( name, "cxx" ) == 0 ||
		strcmp( name, "cpp" ) == 0 ||
		strcmp( name, "CC" ) == 0 ||
		strcmp( name, "c++" ) == 0 ||
		strcmp( name, "hh" ) == 0 ||
		strcmp( name, "hpp" ) == 0 ||
		strcmp( name, "hxx" ) == 0 ||
		strcmp( name, "h++" ) == 0
	)
		OnFlag(globflags, CMODE);
}

void
ReadFile()
{
	char	*fname;

	if (IsModified(curbuf))
		confirm("%s modified, shall I read anyway? ", filename(curbuf));

	fname = ask(curbuf->b_fname, FuncName());
	SetUnmodified(curbuf);
	setfname(curbuf, fname);
	initlist(curbuf);
	read_file(curbuf->b_fname);
}

void
InsFile()
{
	char	*fname;

	fname = ask(curbuf->b_fname, FuncName());
	read_file(fname);
	SetModified(curbuf);
}

void
dolseek(fd, offset, whence)
#if defined(__bsdi__) || defined(__NetBSD__)
off_t	offset;
#else
long	offset;
#endif
{
	if (lseek(fd, offset, whence) == -1)
		complain("lseek failed");
}

/*
   Jonathan Payne at Lincoln-Sudbury Regional High School 5-25-83

   Much of this code was lifted from VI (ex_temp.c).  These functions
   deal with (put/get)ing lines in/from the tmp file.  */

#include "./jove_temp.h"

int	DOLsave = 0;	/* Do Lsave flag.  If lines aren't being save
			   when you think they should have been, this
			   flag is probably not being set, or is being
			   cleared before lsave() was called. */

void
tmpinit()
{
#if HAS_TEMPNAM
	/* Honor $TMPDIR in user's environment */
	tfname = tempnam((char *)NULL, "jovet");
#else
	tfname = mktemp(TempFile);
#endif
	tline = 2;
	iblock1 = oblock = iblock2 = -1;
	hitin2 = ichng1 = ichng2 = 0;
	ignore(close(creat(tfname, 0600)));
	tmpfd = open(tfname, 2);
	ignore(unlink(tfname));
	if (tmpfd == -1) {
		putstr(sprint("%s?\n", tfname));
		finish(0);
	}
}

/* Get a line at `tl' in the tmp file into `buf' which should be LBSIZE
   long. */

char *
getline(tl, buf)
disk_line	tl;
char	*buf;
{
	register char	*bp,
			*lp;
	register int	nl;

	lp = buf;
	bp = getblock(tl, READ);
	nl = nleft;
	tl &= ~OFFMSK;
	while (*lp++ = *bp++) {
		if (--nl == 0) {
			/* += INCRMT moves tl to the next block in
			   the tmp file. */
			bp = getblock(tl += INCRMT, READ);
			nl = nleft;
		}
	}

	return buf;
}

/* Put `buf' and return the disk address */

disk_line
putline(buf)
char	*buf;
{
	register char	*bp,
			*lp;
	register disk_line	nl;
	disk_line	tl;

	lp = buf;
	tl = tline;
	bp = getblock(tl, WRITE);
	nl = nleft;
	tl &= ~OFFMSK;
	while (*bp = *lp++) {
		if (*bp++ == '\n') {
			*--bp = 0;
			break;
		}
		if (--nl == 0) {
			bp = getblock(tl += INCRMT, WRITE);
			nl = nleft;
		}
	}
	nl = tline;
	tline += (((lp - buf) + BNDRY - 1) >> SHFT) & 077776;
	return nl | DIRTY;	/* So it will be redisplayed */
}

/* Get a block which contains at least part of the line with the address
 * atl.  Returns a pointer to the block and sets the global variable
 * nleft (number of good characters left in the buffer)
 */

char *
getblock(atl, iof)
disk_line	atl;
{
	register int	bno,
			off;

	if (atl == 0)
		finish (1);			/* Panic */
	bno = (atl >> OFFBTS) & BLKMSK;
	off = (atl << SHFT) & LBTMSK;
	if (bno >= NMBLKS)
		error("Tmp file too large.  Get help");
	nleft = BSIZ - off;
	if (bno == iblock1) {
		ichng1 |= iof;
		return ibuff1 + off;
	}
	if (bno == iblock2) {
		ichng2 |= iof;
		return ibuff2 + off;
	}
	if (bno == oblock)
		return obuff + off;
	if (iof == READ) {
		if (hitin2 == 0) {
			if (ichng2)
				blkio(iblock2, ibuff2, write);
			ichng2 = 0;
			iblock2 = bno;
			blkio(bno, ibuff2, read);
			hitin2 = 1;
			return (ibuff2 + off);
		}
		hitin2 = 0;
		if (ichng1)
			blkio(iblock1, ibuff1, write);
		ichng1 = 0;
		iblock1 = bno;
		blkio(bno, ibuff1, read);
		return (ibuff1 + off);
	}
	if (oblock >= 0)
		blkio(oblock, obuff, write);
	oblock = bno;
	return obuff + off;
}

#if !defined(pdp11) && !defined(CRAY1) & !defined(__CRAY1)
/* Cache the first 64 disk blocks of temp file in memory, and block align */
#define	INCORB	64
char	incorb[(INCORB+1)*BSIZ];
#define	pageround(a)	((a) & ~(BSIZ-1))
#endif

void
blkio(b, buf, iofcn)
short	b;
char	*buf;
int	(*iofcn)();
{
	extern int read();

#ifdef INCORB
	if (b < INCORB) {
		if (iofcn == read) {
			bcopy(&incorb[pageround((b+1)*BSIZ)], buf, BSIZ);
			return;
		}
		bcopy(buf, &incorb[pageround((b+1)*BSIZ)], BSIZ);
		return;
	}
#endif
	ignore(lseek(tmpfd, (long) (unsigned) b * (long)BSIZ, 0));
	if ((*iofcn)(tmpfd, buf, BSIZ) != BSIZ)
		error("IO error");
}

#ifdef notdef
/* block copy from from to to, count bytes */
bcopy(from, to, count)
	register char *from, *to;
	register int count;
{
	while ((--count) >= 0)
		*to++ = *from++;
}
#endif

/*
 * Save the current contents of linebuf, if it has changed.
 */
void
lsave()
{
	char	tmp[LBSIZE];

	if (curbuf == 0 || !DOLsave)	/* Nothing modified recently */
		return;

	if (!strcmp(linebuf, getline(curline->l_dline, tmp)))
		return;		/* They are the same. */
	SavLine(curline, linebuf);	/* Put linebuf on the disk */
	DOLsave = 0;
}

void
getDOT()
{
	ignore(getline(curline->l_dline, linebuf));
}

void
SavLine(addr, buf)
LINE	*addr;
char	*buf;
{
	addr->l_dline = putline(buf);
}
@


11.5
log
@
lint, RCSid
@
text
@d4 1
a4 1
 * $Revision: 11.4 $
d7 4
d99 1
a99 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/jove/jove_io.c,v 11.4 1999/05/13 19:54:41 jra Exp $";
@


11.4
log
@Linux "stat" corrupts its args on failure!!!!!
@
text
@d4 1
a4 1
 * $Revision: 11.3 $
d7 3
d95 1
a95 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/jove/jove_io.c,v 11.3 1999/01/12 03:05:25 mike Exp $";
@


11.3
log
@Recognize file suffixes for C++ code as well as C code.
@
text
@d4 1
a4 1
 * $Revision: 11.2 $
d7 3
d92 1
a92 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/jove/jove_io.c,v 11.2 1995/06/21 03:41:51 gwyn Exp $";
d465 8
@


11.2
log
@Eliminated trailing blanks.
TempFile is now an array.
Improved use of tempnam().
Changed memcpy calls back to bcopy.  (Fixed confusing use of SYSV vs. SYS5.)
Use LBSIZE instead of hard-wired 100.
@
text
@d4 9
a12 1
 * $Revision: 11.1 $
a13 1
 * $Log:	jove_io.c,v $
d89 1
a89 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_io.c,v 11.1 95/01/04 10:35:15 mike Rel4_4 $";
d587 1
d589 2
a590 1
	len = curbuf->b_fname ? strlen(curbuf->b_fname) : 0;
d594 29
a622 1
	if (curbuf->b_fname[--len] == 'c' && curbuf->b_fname[--len] == '.')
@


11.1
log
@Release_4.4
@
text
@d2 1
a2 1
 *			J O V E _ I O . C 
d4 1
a4 1
 * $Revision: 10.5 $
d7 3
d12 1
a12 1
 * 
d23 1
a23 1
 * 
d26 1
a26 1
 * 
d29 1
a29 1
 * 
d36 1
a36 1
 * 
d39 1
a39 1
 * 
d42 1
a42 1
 * 
d45 1
a45 1
 * 
d48 1
a48 1
 * 
d51 1
a51 1
 * 
d55 1
a55 1
 * 
d58 1
a58 1
 * 
d61 1
a61 1
 * 
d65 1
a65 1
 * 
d69 1
a69 1
 * 
a71 1
 * 
d73 1
d76 1
a76 1
 * 
d79 1
a79 1
 * 
d82 1
a82 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_io.c,v 10.5 95/01/03 21:35:28 butler Exp $";
d87 1
a87 1
  
d100 1
a100 1
extern	char *TempFile;
d326 2
a327 2
	char	tmp[100],
		tmp1[100],
d333 1
a333 1
		
d369 1
a369 1
	  && (stbuf.st_mode & S_IFMT) != S_IFCHR) 
d388 1
a388 1
	char	fname[100];
d402 1
a402 1
	} else 
d421 1
a421 1
		fnamebuf[100];
d523 1
a523 1
	}		
d566 1
a566 1
	
d582 1
a582 1
	
d628 1
a628 1
  
d642 1
a642 1
#if defined(L_tmpnam)	/* From modern stdio.h */
d644 1
a644 1
	tfname = (char *) tempnam(NULL, "jove");
d790 1
a790 1
			memcpy(buf, &incorb[pageround((b+1)*BSIZ)], BSIZ);
d793 1
a793 1
		memcpy(&incorb[pageround((b+1)*BSIZ)], buf, BSIZ);
d811 1
a811 1
#endif 
@


10.5
log
@lseek takes an off_t as its second arg under BSDI and NetBSD
@
text
@d4 1
a4 1
 * $Revision: 10.4 $
d6 4
a9 1
 * $Log: jove_io.c,v $
d79 1
a79 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_io.c,v 10.4 1994/09/17 04:57:35 butler Exp butler $";
@


10.4
log
@changed all calls to bcopy to be memcpy instead.  Useful for Solaris 5.2
@
text
@d4 1
a4 1
 * $Revision: 10.3 $
d7 3
d76 1
a76 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_io.c,v 10.3 1993/10/26 06:31:25 mike Exp butler $";
d610 3
d614 1
@


10.3
log
@Modified to use tempnam(), so that $TMPDIR from user's environment
will be honored if set
@
text
@d4 1
a4 1
 * $Revision: 10.2 $
d6 5
a10 1
 * $Log:	jove_io.c,v $
d73 1
a73 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_io.c,v 10.2 92/01/31 16:56:12 mike Exp Locker: mike $";
d777 1
a777 1
			bcopy(&incorb[pageround((b+1)*BSIZ)], buf, BSIZ);
d780 1
a780 1
		bcopy(buf, &incorb[pageround((b+1)*BSIZ)], BSIZ);
@


10.2
log
@Must do chown() *after* close(), so that on NFS clients, we don't
loose write permission on the file before we write any data into it.
@
text
@d4 1
a4 1
 * $Revision: 10.1 $
d7 4
d69 1
a69 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_io.c,v 10.1 91/10/12 06:54:00 mike Rel4_0 Locker: mike $";
d77 1
d118 12
d132 1
d143 1
d187 1
d246 1
d270 1
d278 1
d309 1
d336 1
d346 1
d360 1
d366 1
d372 1
d404 1
d422 1
d547 1
d563 1
d576 1
d591 1
d601 1
d622 1
d625 3
a627 2
#ifdef SYS5_SGI
	tfname = (char *) xtempnam(NULL, TempFile);
a710 2
	extern int	read(),
			write();
d762 1
d799 1
a799 1

d813 1
d819 1
@


10.1
log
@Release_4.0
@
text
@d4 1
a4 1
 * $Revision: 2.11 $
d7 3
d65 1
a65 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_io.c,v 2.11 91/08/30 22:56:06 mike Exp $";
d400 1
d461 1
a461 3

		/*  This will fail on all but USG systems, ignore it  */
		chown (fname, inode.st_uid, inode.st_gid);
d483 8
@


2.11
log
@__CRAY1 too
@
text
@d4 1
a4 1
 * $Revision: 2.10 $
d7 3
d62 1
a62 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_io.c,v 2.10 91/08/30 22:37:07 mike Exp $";
@


2.10
log
@Fixed in-core buffering to operate on the array subscripts, rather than
a (char *) pointer, as this is more portable, and avoids CRAY problems.
In addition, turned off the in-core buffering on CRAY1 (and X and Y)
systems, as it consumes an extra 256 Kbytes, which on smaller Crays
isn't worth it.  Their I/O is plenty fast, and memory is usually tight.
@
text
@d4 1
a4 1
 * $Revision: 2.9 $
d7 7
d59 1
a59 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_io.c,v 2.9 91/08/30 20:29:44 mike Exp $";
d706 1
a706 1
#if !defined(pdp11) && !defined(CRAY1)
@


2.9
log
@Added extern int read().
@
text
@d4 1
a4 1
 * $Revision: 2.8 $
d7 3
d52 1
a52 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_io.c,v 2.8 91/08/30 19:34:16 mike Exp $";
d699 2
a700 2
#if !defined(pdp11)
/* Cache the first 64 disk blocks of temp file in memory */
d702 2
a703 2
char	incorb[INCORB+1][BSIZ];
#define	pagrnd(a)	((char *)(((int)a)&~(BSIZ-1)))
d716 1
a716 1
			bcopy(pagrnd(incorb[b+1]), buf, BSIZ);
d719 1
a719 1
		bcopy(buf, pagrnd(incorb[b+1]), BSIZ);
@


2.8
log
@Changed VMUNIX to !defined(pdp11)
@
text
@d4 1
a4 1
 * $Revision: 2.7 $
d7 3
d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_io.c,v 2.7 91/08/30 19:17:44 mike Exp $";
d697 1
a697 1
/* Cache 64 disk blocks in memory */
d708 1
@


2.7
log
@Stardent ANSI lint
@
text
@d4 1
a4 1
 * $Revision: 2.6 $
d7 3
d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_io.c,v 2.6 91/08/30 18:46:05 mike Exp $";
d693 2
a694 1
#ifdef	VMUNIX
d706 1
a706 1
#ifdef VMUNIX
@


2.6
log
@Changed from BSD index/rindex nomenclature to SYSV strchr/strrchr.
@
text
@d4 1
a4 1
 * $Revision: 2.5 $
d7 3
d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_io.c,v 2.5 91/08/30 18:11:04 mike Exp $";
d477 1
a477 1
	if (strlen(cp) > 13)
@


2.5
log
@Made explicit that termcap.h to be used is the local version
@
text
@d4 1
a4 1
 * $Revision: 2.4 $
d7 3
d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_io.c,v 2.4 91/08/30 17:54:34 mike Exp $";
d275 1
a275 1
	cp = rindex(tmp, '/');
d469 1
a469 1
	if (cp = rindex(fname, '/'))
@


2.4
log
@Changed #include directives to distinguish between local and system header
files.
@
text
@d4 1
a4 1
 * $Revision: 2.3 $
d7 4
d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_io.c,v 2.3 91/08/30 17:49:08 mike Exp $";
d46 1
a46 1
#include <termcap.h>
@


2.3
log
@Paul Stay mods for ANSI C
@
text
@d4 1
a4 1
 * $Revision: 2.2 $
d7 3
d33 1
a33 1
static char RCSid[] = "@@(#)$Header: jove_io.c,v 2.2 87/04/14 20:27:17 dpk BRL $";
d41 2
a42 2
#include "jove.h"
#include "termcap.h"
d540 1
a540 1
#include "jove_temp.h"
@


2.2
log
@Commented out the bcopy routine.  Will use memcpy for bcopy.
@
text
@d4 1
a4 1
 * $Revision: 2.1 $
d7 3
d30 1
a30 1
static char RCSid[] = "@@(#)$Header: jove_io.c,v 2.1 86/09/23 22:28:40 dpk Locked $";
d466 1
a466 1
#endif V4_2BSD
d546 3
d550 1
d713 1
a713 1
#endif notdef
@


2.1
log
@Externs now declared properly.
I/O fixes for SysV
@
text
@d7 4
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: jove_io.c,v 2.1 86/09/23 22:26:37 mike Exp $";
d697 1
a697 1
#ifdef SYS5
d706 1
a706 1
#endif
@


2.0
log
@System as distributed to Berkeley 26 Dec 84
@
text
@d4 1
a4 1
 * $Revision: 1.3 $
d7 7
d23 1
a23 1
static char RCSid[] = "@@(#)$Header: jove_io.c,v 1.3 84/03/20 22:29:18 dpk BRL $";
d52 21
d476 1
a476 1
	if (bp == curbuf)
d478 1
d693 1
a693 1
#ifndef VMUNIX
d702 1
a702 1
#endif VMUNIX
@


1.3
log
@Improved file handling, fixed "Free line in list" loop
@
text
@d4 1
a4 1
 * $Revision: 1.2 $
d7 4
d16 1
a16 1
static char RCSid[] = "@@(#)$Header: jove_io.c,v 1.2 83/12/16 00:08:33 dpk BRL $";
d27 1
d31 4
d107 1
a107 1
	nib = 512;
d120 1
a120 1
				nib = 511;
d183 1
a183 1
	s_mess("\"%s\" %d lines %D characters", file, lines, chars);
d287 1
a287 1
			io = creat(fname, 0644);
d291 1
a291 1
		io = creat(fname, 0644);
d320 2
d335 1
a335 1
	inode.st_mode = DFLTMODE;
d337 2
d342 1
a342 1
	if (access (fname, 02) != 0) {
d348 2
d356 1
a356 1
			io = creat(fname, DFLTMODE);
d366 1
a366 1
		if (BackupFiles == SAVE_ASK) {
d376 1
a376 2
			savefile = malloc(strlen(fname) + 2);
		 	sprintf (savefile, "%s~", fname);
d383 1
a383 1
			   		s_mess("\"%s\" [No backup made]", fname);
a388 2
		if (!overwrite)
			unlink(fname);
d390 3
d397 4
d416 23
d510 1
a510 1
	tfname = mktemp(TMPFILE);
d516 1
d602 1
a602 1
	nleft = BUFSIZ - off;
d639 2
a640 2
char	incorb[INCORB+1][BUFSIZ];
#define	pagrnd(a)	((char *)(((int)a)&~(BUFSIZ-1)))
d652 1
a652 1
			bcopy(pagrnd(incorb[b+1]), buf, BUFSIZ);
d655 1
a655 1
		bcopy(buf, pagrnd(incorb[b+1]), BUFSIZ);
d659 2
a660 2
	ignore(lseek(tmpfd, (long) (unsigned) b * BUFSIZ, 0));
	if ((*iofcn)(tmpfd, buf, BUFSIZ) != BUFSIZ)
d664 1
a664 2
#ifdef VMUNIX

a665 1

a666 8
#ifdef vax
	char *from, *to;
	int count;
{

	asm("	movc3	12(ap),*4(ap),*8(ap)");
}
#else
a672 1
#endif
@


1.2
log
@Added distinctive RCS header
@
text
@d4 1
a4 1
 * $Revision$
d6 4
a9 1
 * $Log$
d12 1
a12 1
static char RCSid[] = "@@(#)$Header$";
d26 1
a26 1
int	BackupFiles;
d166 2
d249 3
a251 1
	if (stbuf.st_ino != curbuf->b_ino && (stbuf.st_mode & S_IFMT) != S_IFCHR) 
d318 1
d329 8
d349 1
a349 2
			if (*yorn == 'N' || *yorn == 'n')
				linked = 0;
d353 1
a353 2
			if (*yorn == 'Y' || *yorn == 'y')
				saveit++;
d364 1
a364 1
		   	if (linked) {
d373 1
d375 3
a377 1
		io = creat(fname, DFLTMODE);
d554 1
a554 1
		complain("Free line in list!!!");
@


1.2.1.1
log
@BMD70 version of 20 March 84
@
text
@d4 1
a4 1
 * $Revision: 1.2 $
d6 1
a6 4
 * $Log:	jove_io.c,v $
 * Revision 1.2  83/12/16  00:08:33  dpk
 * Added distinctive RCS header
 * 
d9 1
a9 1
static char RCSid[] = "@@(#)$Header: jove_io.c,v 1.2 83/12/16 00:08:33 dpk BRL $";
a19 1
#include <errno.h>
d23 1
a23 1
extern	int errno;
a24 2
int	BackupFiles = SAVE_NO;

a162 2
	if (access (file, 02))
		SetReadOnly(curbuf);
d244 1
a244 3
	if ((stbuf.st_ino != curbuf->b_ino
	   || stbuf.st_dev != curbuf->b_dev)
	  && (stbuf.st_mode & S_IFMT) != S_IFCHR) 
d271 1
a271 1
			io = creat(fname, DFLTMODE);
d275 1
a275 1
		io = creat(fname, DFLTMODE);
a310 1
	int		overwrite = 0;
a317 2
	inode.st_uid = getuid();
	inode.st_gid = getgid();
a320 10
	if (access (fname, 02) != 0 && errno == EPERM) {
		register char *yorn;

		yorn = ask ("Y", "%s is read-only, recreate? (yes) ", fname);
		if (*yorn == 'N' || *yorn == 'n')
			complain ("File save aborted.");
		if (unlink(fname) != 0)
			complain ("Cannot unlink %s", fname);
	}

d333 2
a334 1
			overwrite = (*yorn == 'Y' || *yorn == 'y');
d336 1
a336 1
		if (exists && BackupFiles == SAVE_ASK) {
d338 2
a339 1
			saveit = (*yorn == 'Y' || *yorn == 'y');
d347 1
a347 2
			if ((savefile = malloc(strlen(fname) + 2)) == NULL)
				complain ("savefile malloc error");
d350 1
a350 1
		   	if (linked && overwrite) {
d355 1
a355 1
			   		s_mess("\"%s\" [No backup possible]", fname);
a358 1
			free (savefile);
d360 1
a360 4
		io = creat(fname, inode.st_mode&07777);

		/*  This will fail on all but USG systems, ignore it  */
		chown (fname, inode.st_uid, inode.st_gid);
d537 1
a537 1
		finish (1);			/* Panic */
@


1.1
log
@Original 4.2 Distribution Source
@
text
@d2 11
@
