head	11.8;
access;
symbols
	ansi-20040405-merged:11.7
	postmerge-20040405-ansi:11.7
	premerge-20040404-ansi:11.7
	postmerge-autoconf:11.7
	autoconf-freeze:11.7
	premerge-autoconf:11.7
	ansi-20040316-freeze:11.7
	postmerge-20040315-windows:11.7
	premerge-20040315-windows:11.7
	windows-20040315-freeze:11.7
	autoconf-20031203:11.7
	autoconf-20031202:11.7
	autoconf-branch:11.7.0.12
	phong-branch:11.7.0.10
	photonmap-branch:11.7.0.8
	rel-6-1-DP:11.7
	windows-branch:11.7.0.6
	rel-6-0-2:11.7
	ansi-branch:11.7.0.4
	rel-6-0-1-branch:11.7.0.2
	hartley-6-0-post:11.7
	hartley-6-0-pre:11.7
	rel-6-0-1:11.7
	rel-6-0:11.7
	rel-5-4:11.6
	offsite-5-3-pre:11.7
	rel-5-3:11.6
	rel-5-2:11.6
	rel-5-1-branch:11.6.0.2
	rel-5-1:11.6
	rel-5-0:11.6
	rel-5-0-beta:11.6
	rel-4-5:11.6
	ctj-4-5-post:11.5
	ctj-4-5-pre:11.5
	rel-4-4:11.3
	rel-4-0:10.1
	rel-3-5:2.11
	rel-3-0:2.11
	rel-2-3:2.11
	rel-2-0:2.9
	rel-1-24:2.9
	rel-1-20:2.7
	rel-1-10:2.7
	rt-2:2.2
	rt:1.3;
locks; strict;
comment	@ * @;


11.8
date	2004.05.21.17.48.33;	author morrison;	state dead;
branches;
next	11.7;

11.7
date	2000.08.24.23.12.23;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	97.07.16.02.31.25;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	97.01.03.17.42.17;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	95.06.21.03.42.30;	author gwyn;	state Exp;
branches;
next	11.3;

11.3
date	95.01.04.23.26.50;	author mike;	state Rel4_4;
branches;
next	11.2;

11.2
date	95.01.04.20.09.00;	author stay;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.35.17;	author mike;	state Rel4_4;
branches;
next	10.13;

10.13
date	94.12.29.23.02.59;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	94.12.14.15.33.54;	author jra;	state Exp;
branches;
next	10.11;

10.11
date	94.10.14.17.29.25;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	94.09.22.18.53.54;	author butler;	state Exp;
branches;
next	10.9;

10.9
date	94.09.17.04.57.35;	author butler;	state Exp;
branches;
next	10.8;

10.8
date	93.12.10.05.50.57;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	93.12.10.05.35.40;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	93.10.26.06.32.59;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	93.10.26.06.01.51;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	93.10.26.05.42.22;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	93.10.26.03.38.55;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	93.04.01.04.25.24;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.54.00;	author mike;	state Rel4_0;
branches;
next	2.16;

2.16
date	91.08.30.20.24.48;	author mike;	state Exp;
branches;
next	2.15;

2.15
date	91.08.30.19.28.59;	author mike;	state Exp;
branches;
next	2.14;

2.14
date	91.08.30.18.11.05;	author mike;	state Exp;
branches;
next	2.13;

2.13
date	91.08.30.17.54.35;	author mike;	state Exp;
branches;
next	2.12;

2.12
date	91.08.30.17.49.09;	author mike;	state Exp;
branches;
next	2.11;

2.11
date	87.09.16.21.28.40;	author mike;	state Exp;
branches;
next	2.10;

2.10
date	87.09.10.00.23.01;	author mike;	state Exp;
branches;
next	2.9;

2.9
date	87.05.05.21.04.12;	author dpk;	state BRL;
branches;
next	2.8;

2.8
date	87.04.14.20.14.21;	author dpk;	state BRL;
branches;
next	2.7;

2.7
date	86.09.23.22.28.52;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	86.04.11.09.09.51;	author gwyn;	state Exp;
branches;
next	2.5;

2.5
date	86.04.06.06.28.48;	author gwyn;	state Exp;
branches;
next	2.4;

2.4
date	86.01.17.13.23.37;	author gwyn;	state Exp;
branches;
next	2.3;

2.3
date	86.01.11.03.01.51;	author gwyn;	state Exp;
branches;
next	2.2;

2.2
date	85.05.14.01.44.41;	author dpk;	state Exp;
branches;
next	2.1;

2.1
date	85.01.17.23.58.24;	author dpk;	state Exp;
branches;
next	2.0;

2.0
date	84.12.26.16.46.45;	author dpk;	state Exp;
branches;
next	1.3;

1.3
date	84.03.20.22.27.17;	author dpk;	state BRL;
branches;
next	1.2;

1.2
date	83.12.16.00.08.44;	author dpk;	state BRL;
branches;
next	1.1;

1.1
date	83.12.16.00.08.39;	author dpk;	state Exp;
branches;
next	;


desc
@Jove is an EMACS like screen editor which will fit on 11's and Vaxen
@


11.8
log
@moved to src/other/jove/
@
text
@/*
 *			J O V E _ M A I N . C
 *
 * $Revision: 11.7 $
 *
 * $Log: jove_main.c,v $
 * Revision 11.7  2000/08/24 23:12:23  mike
 *
 * lint, RCSid
 *
 * Revision 11.6  1997/07/16  02:31:25  mike
 * Changed from HAS_TERMIOS to HAVE_TERMIOS_H
 *
 * Revision 11.5  1997/01/03  17:42:17  jra
 * Mods for Irix 6.2
 *
 * Revision 11.4  1995/06/21  03:42:30  gwyn
 * Eliminated trailing blanks.
 * BinShell, version, Joverc are now arrays rather than string literal pointers.
 * Changed memcpy calls back to bcopy.  (Fixed confusing use of SYSV vs. SYS5.)
 * Fixed varargs functions, using VA_* macros.
 * Fixed usage of FNDELAY, which is obsolete.
 * Improved use of conditionals dealing with system variations.
 * Made reset of SIGINT handler independent of SIGTSTP.
 *
 * Revision 11.3  95/01/04  23:26:50  mike
 * Irix 5.3 fix
 *
 * Revision 11.2  1995/01/04  20:09:00  stay
 * Fixed for Irix 5.3 which no longer declares
 * FNDELAY for POSIX_SOURCE
 *
 * Revision 11.1  1995/01/04  10:35:17  mike
 * Release_4.4
 *
 * Revision 10.13  94/12/29  23:02:59  mike
 * Bug #158.  Eliminated ^V doubling on DEC Alpha, and Solaris.
 *
 * Revision 10.12  94/12/14  15:33:54  jra
 * Cray also needs file.h included.
 *
 * Revision 10.11  94/10/14  17:29:25  mike
 * SunOS 5.2
 *
 * Revision 10.10  94/09/22  18:53:54  butler
 * Added ifdef needed for Solaris
 *
 * Revision 10.9  1994/09/17  04:57:35  butler
 * changed all calls to bcopy to be memcpy instead.  Useful for Solaris 5.2
 *
 * Revision 10.8  1993/12/10  05:50:57  mike
 * tchars should be defined only on old-style BSD systems.
 *
 * Revision 10.7  93/12/10  05:35:40  mike
 * Additional POSIX support
 *
 * Revision 10.6  93/10/26  06:32:59  mike
 * Changed printf() to jprintf() so that all modules could safely
 * use stdio.h
 *
 * Revision 10.5  93/10/26  06:01:51  mike
 * Changed getchar() to jgetchar() to prevent stdio.h conflict
 *
 * Revision 10.4  93/10/26  05:42:22  mike
 * POSIX
 *
 * Revision 10.3  93/10/26  03:38:55  mike
 * termios stuff
 *
 * Revision 10.2  93/04/01  04:25:24  mike
 * Arg to FIONREAD is an "int", not a "long" these days.
 *
 * Revision 10.1  91/10/12  06:54:00  mike
 * Release_4.0
 *
 * Revision 2.16  91/08/30  20:24:48  mike
 * Added !defined(SYS5) protection around some BSD ioctls
 *
 * Revision 2.15  91/08/30  19:28:59  mike
 * Added BRL-specific identification
 *
 * Revision 2.14  91/08/30  18:11:05  mike
 * Made explicit that termcap.h to be used is the local version
 *
 * Revision 2.13  91/08/30  17:54:35  mike
 * Changed #include directives to distinguish between local and system header
 * files.
 *
 * Revision 2.12  91/08/30  17:49:09  mike
 * Paul Stay mods for ANSI C
 *
 * Revision 2.11  87/09/16  21:28:40  mike
 * Hopefully, the Final Word on the SysV "poll" for input
 * code.
 *
 * Revision 2.10  87/09/10  00:23:01  mike
 * Hopefully, the fix for the "scramble the input" bug on the Crays
 * and other SysV machines.
 *
 * Revision 2.9  87/05/05  21:04:12  dpk
 * Simplified getchar code. Now all systems use the read loop
 *
 * Revision 2.8  87/04/14  20:14:21  dpk
 * Added SIGHUP fix.
 *
 * Revision 2.7  86/09/23  22:28:52  mike
 * Externs now declared properly.
 * I/O fixes for SysV
 *
 * Revision 2.7  86/09/23  22:26:46  mike
 * Externs now declared properly.
 * I/O fixes for SysV
 *
 * Revision 2.6  86/04/11  09:09:51  gwyn
 * last mod was incomplete
 *
 * Revision 2.5  86/04/06  06:28:48  gwyn
 * Fixed endless loop on joverc under System V.
 *
 * Revision 2.4  86/01/17  13:23:37  gwyn
 * fixed SYS5 terminal mode setup
 *
 * Revision 2.3  86/01/11  03:01:51  gwyn
 * fixed window size code
 *
 * Revision 2.2  85/05/14  01:44:41  dpk
 * Added changes to support System V (conditional on SYS5)
 *
 * Revision 2.1  85/01/17  23:58:24  dpk
 *
 *
 * Revision 2.0  84/12/26  16:46:45  dpk
 * System as distributed to Berkeley 26 Dec 84
 *
 * Revision 1.3  84/03/20  22:27:17  dpk
 * Added better termcap handling
 *
 * Revision 1.2  83/12/16  00:08:44  dpk
 * Added distinctive RCS header
 *
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/jove/jove_main.c,v 11.7 2000/08/24 23:12:23 mike Exp $";
#endif

/*
   Jonathan Payne at Lincoln-Sudbury Regional High School 4-19-83

   jove_main.c

   Contains the main loop, initializations, getch routine... */

#include "./jove.h"
#include "./termcap.h"

#include <signal.h>
#if HAVE_TERMIOS_H
#  if !defined(_XOPEN_SOURCE)
#	define _XOPEN_SOURCE 1	/* to get TAB3, etc */
#  endif
# include <termios.h>
# include <fcntl.h>
#else
# ifndef SYS5
#  include <sgtty.h>
# else
#  include <termio.h>
#  include <fcntl.h>
# endif
#endif
#include <errno.h>

extern char	version[];
extern char	BinShell[];
extern char	Joverc[];
#if !defined(__STDC__) && !defined(_POSIX_SOURCE)	/* i.e. fairly old UNIX */
extern int	errno;
#endif

void		DoKeys();

#if defined(TIOCSLTC) && !defined(SYS5)
struct ltchars	ls1, ls2;
#endif

#if defined(TIOCSETC) && !defined(SYS5)
struct tchars	tc1, tc2;	/* only on old-style BSD */
#endif

int	errormsg;

int	iniargc;
char	**iniargv;
char	*StdShell;


/***** Global storage declarations *****/
int	BufSize;
int	origflags[NFLAGS],
	globflags[NFLAGS];
char	genbuf[LBSIZE];		/* Scatch pad */
int	peekc,
	io,		/* File descriptor for reading and writing files */
	exp,
	exp_p,
	this_cmd,
	last_cmd,
	RecDepth;
jmp_buf	mainjmp;
WINDOW	*fwind,		/* First window in list */
	*curwind;	/* Current window */
BUFFER	*world,			/* First buffer */
	*curbuf;		/* Pointer into world for current buffer */
int
	Crashing;		/* We are in the middle of crashing */

int
	Input,		/* What the current input is */
	InputPending,
 	killptr,	/* Index into killbuf */
	CanScroll,	/* Can this terminal scroll? */
	Asking;		/* Are we on read a string from the terminal? */
char	**argvp;
char	linebuf[LBSIZE];
LINE	*killbuf[NUMKILLS];	/* Array of pointers to killed stuff */
int	(*Getchar)();
struct function	*mainmap[0200],
		*pref1map[0200],
		*pref2map[0200],
		*LastFunc;
int	LastKeyStruck;
/***************************************/

void
finish(code)
{
	if (code == SIGINT) {
		char	c;

		ignorf(signal(code, finish));
		message("Quit? ");
		UpdateMesg();
		ignore(read(0, &c, 1));
		message("");
		if ((c & 0377) != 'y') {
			redisplay();
			return;
		}
	}
	if (code) {
		if (code == SIGHUP)
			ignorf(signal(code, SIG_IGN));	/* A little privacy */
		if (!Crashing) {
			putstr("Writing modified JOVE buffers...");
			Crashing++;
			exp_p = 0;
			WtModBuf();
		} else
			putstr("Complete lossage!");
	}
	ttyset(0);
	Placur(LI - 1, 0);
	putpad(CE, 1);
	if (KE)
		putpad(KE, 1);
	if (VE)
		putpad(VE, 1);
	if (TE)
		putpad(TE, 1);
	flusho();

	byebye(code);
}

#define NTOBUF	256		/* Should never get that far ahead */
static char	smbuf[NTOBUF],
		*bp = smbuf;
static int	nchars = 0;

Ungetc(c)
register int	c;
{
	if (c == EOF || nchars >= NTOBUF)
		return EOF;
	*--bp = c;
	nchars++;
	return c;
}

jgetchar()
{
	if (nchars <= 0) {
		/*
		 *  This loop will retry the read if it is interrupted
		 *  by an alarm signal.  (Like VMUNIX...)
		 */
		do {
			nchars = read(Input, smbuf, sizeof smbuf);
#ifdef SYS5
		} while ((nchars == 0 && Input == 0)
			 || (nchars < 0 && errno == EINTR));
#else
		} while (nchars < 0 && errno == EINTR);
#endif
		if(nchars <= 0) {
			if (Input)
				return EOF;
			finish(0);
		}
		bp = smbuf;
		InputPending = nchars > 1;
	}
	nchars--;
	return *bp++;
}

/* Returns non-zero if a character waiting */
charp()
{	if (Input)
		return 0;
	if (nchars > 0)
		return 1;			/* Quick check */
	else {
#ifdef BRLUNIX
		static struct sg_brl gttyBuf;

		gtty( 0, &gttyBuf );
		if( gttyBuf.sg_xflags & INWAIT )
			return( 1 );
		else
			return( 0 );
#else
#ifdef FIONREAD
		int c = 0;

		if (ioctl(0, FIONREAD, (char *) &c) == -1)
			c = 0;
#else
#if defined(SYS5) || HAVE_TERMIOS_H
		int c, flags;

		/* Since VMIN=1, we need to be able to poll for input
		 * here.  Yes, the 4-syscalls to do it are costly,
		 * but not as costly as the infinite loop when VMIN=0!
		 * Have to be careful, as we actually read in the
		 * characters here, to see if there are any.
		 */
		flags = fcntl( Input, F_GETFL, 0);
#  if HAVE_TERMIOS_H
		(void)fcntl( Input, F_SETFL, flags|O_NONBLOCK );
#  else
		(void)fcntl( Input, F_SETFL, flags|O_NDELAY );
#  endif
		c = &smbuf[NTOBUF] - bp - nchars;	/* space left */
		if( c < 0 )  c = 0;
		c = read(Input, bp+nchars, c );
		if (c > 0)
			nchars += c;
		(void)fcntl( Input, F_SETFL, flags );
#else
		int c;

		if (ioctl(0, TIOCEMPTY, (char *) &c) == -1)
			c = 0;
#endif
#endif
		return (c > 0);
#endif
	}
}


void
ResetTerm()
{
	if (TI)
		putpad(TI, 1);
	if (VS)
		putpad(VS, 1);
	if (KS)
		putpad(KS, 1);
	ttyset(1);
}

void
UnsetTerm()
{
	ttyset(0);
	Placur(LI - 1, 0);
	if (KE)
		putpad(KE, 1);
	if (VE)
		putpad(VE, 1);
	if (TE)
		putpad(TE, 1);
	flusho();
}

void
PauseJove()
{
#ifdef SIGTSTP
	UnsetTerm();
	ignore(kill(0, SIGTSTP));
	ResetTerm();
	ClAndRedraw();
#else
	RunShell( 0 );
	ClAndRedraw();
#endif
}

#define	DOCOMMAND	1		/* Must be non-zero */

void
SubShell()
{
	register char yorn;

	do {
		Placur(LI - 1, 0);
		putstr("\rCommand line? ");
		RunShell( DOCOMMAND );
		putstr("Continue? ");
		flusho();
		yorn = jgetchar();
	} while (yorn != '\r' && yorn != '\n' && yorn != ' '
		 && yorn != 'y' && yorn != 'Y');
	ClAndRedraw();
}

void
RunShell(prompt)
register int	prompt;
{
	register int	pid;

	UnsetTerm();

	switch (pid = fork()) {
	case -1:
		complain("Fork failed");

	case 0:
		signal(SIGTERM, SIG_DFL);
		signal(SIGINT, SIG_DFL);

		if( prompt == DOCOMMAND )
			execl(StdShell, "shell", "-t", 0);
		else
			execl(StdShell, "shell", 0);
		message("Execl failed");
		byebye(1);

	default:
		while (wait(0) != pid)
			;
	}

	ResetTerm();
}

int	OKXonXoff = 0;		/* ^S and ^Q initially DON'T work */

#ifndef	BRLUNIX
# if HAVE_TERMIOS_H
struct termios	oldtty, newtty;
# else
#  if defined(SYS5)
struct termio	oldtty, newtty;
#  else
struct sgttyb	oldtty, newtty;
#  endif
# endif
#else
struct sg_brl	oldtty, newtty;
#endif

void
ttsetup() {
#ifndef BRLUNIX
#  if HAVE_TERMIOS_H
	if (tcgetattr( 0, &oldtty ) < 0) {
#  else
#    if defined(SYS5)
	if (ioctl (0, TCGETA, &oldtty) < 0) {
#    else
	if (ioctl(0, TIOCGETP, (char *) &oldtty) == -1) {
#    endif
#  endif	/* HAVE_TERMIOS_H */
#else
	if (gtty(0, &oldtty) < 0) {
#endif
		putstr("Input not a terminal");
		byebye(1);
	}

	/* One time setup of "raw mode" stty struct */
	newtty = oldtty;
#ifndef BRLUNIX
#if !defined(SYS5) && !HAVE_TERMIOS_H
	newtty.sg_flags &= ~(ECHO | CRMOD);
	newtty.sg_flags |= CBREAK;
#else
	newtty.c_iflag &= ~(INLCR|ICRNL);
	newtty.c_lflag &= ~(ISIG|ICANON|ECHO);

	/* Not all exist in POSIX.  If not there, no need to clear them. */
#	if defined(OLCUC)
		newtty.c_oflag &= ~(OLCUC);
#	endif
#	if defined(ONLCR)
		newtty.c_oflag &= ~(ONLCR);
#	endif
#	if defined(OCRNL)
		newtty.c_oflag &= ~(OCRNL);
#	endif
#	if defined(ONOCR)
		newtty.c_oflag &= ~(ONOCR);
#	endif
#	if defined(ONLRET)
		newtty.c_oflag &= ~(ONLRET);
#	endif
#	if defined(OFILL)
		newtty.c_oflag &= ~(OFILL);
#	endif

#	if defined(IEXTEN)
		newtty.c_lflag &= ~(IEXTEN);	/* (Solaris) Eliminate ^V doubling */
#	endif

	/* VMIN = 0 causes us to loop in jgetchar() */
	newtty.c_cc[VMIN] = 1;
	newtty.c_cc[VTIME] = 0;
#	if defined(VLNEXT)
		newtty.c_cc[VLNEXT] = 0;	/* (Alpha) Eliminate ^V doubling */
#	endif
#	if defined(LNEXT)
		newtty.c_cc[LNEXT] = 0;		/* (Solaris) Eliminate ^V doubling */
#	endif
#endif
#else
	newtty.sg_flags &= ~(ECHO | CRMOD);
	newtty.sg_flags |= CBREAK;

	/* VT100 Kludge: leave STALL on for flow control if DC3DC1 (Yuck.) */
	newtty.sg_xflags &= ~((newtty.sg_xflags&DC3DC1 ? 0 : STALL) | PAGE);
#endif
}

void
ReInitTTY()
{
	ttyset(0);	/* Back to original settings */
	ttinit();
}

void
ttsize()
{
#ifdef TIOCGWINSZ
	struct winsize win;

	if (ioctl (0, TIOCGWINSZ, &win) == 0) {
		if (win.ws_col)
			CO = win.ws_col;
		if (win.ws_row)
			LI = win.ws_row;
	}
#else
#ifdef BTL_BLIT
#include <sys/jioctl.h>
	struct jwinsize jwin;

	if (ioctl (0, JWINSIZE, &jwin) == 0) {
		if (jwin.bytesx)
			CO = jwin.bytesx;
		if (jwin.bytesy)
			LI = jwin.bytesy;
	}
#endif
#endif
}

void
ttinit()
{
#if defined(TIOCSLTC) && !defined(SYS5)
	ioctl(0, TIOCGLTC, (char *) &ls1);
	ls2 = ls1;
	ls2.t_suspc = (char) -1;
	ls2.t_dsuspc = (char) -1;
	ls2.t_flushc = (char) -1;
	ls2.t_lnextc = (char) -1;
#endif

	/* Change interrupt and quit. */
#if defined(TIOCSETC) && !defined(SYS5)
	ioctl(0, TIOCGETC, (char *) &tc1);
	tc2 = tc1;
	tc2.t_intrc = (char) -1;
	tc2.t_quitc = (char) -1;
	if (OKXonXoff) {
		tc2.t_stopc = (char) -1;
		tc2.t_startc = (char) -1;
	}
#endif
	ttyset(1);

	/* Go into cbreak, and -echo and -CRMOD */

	ignorf(signal(SIGHUP, finish));
	ignorf(signal(SIGINT, SIG_IGN));
	ignorf(signal(SIGQUIT, SIG_IGN));
#if defined(SIGBUS)
	ignorf(signal(SIGBUS, finish));
#endif
	ignorf(signal(SIGSEGV, finish));
	ignorf(signal(SIGPIPE, finish));
	ignorf(signal(SIGTERM, SIG_IGN));
}

/* If "n" is zero, reset to orignal modes */
#ifndef BRLUNIX
void
ttyset(n)
{
#if HAVE_TERMIOS_H
	struct termios	tty;
#else
# if defined(SYS5)
	struct termio	tty;
# else
	struct sgttyb	tty;
# endif
#endif

	if (n)
		tty = newtty;
	else
		tty = oldtty;

#if HAVE_TERMIOS_H
	if (tcsetattr( 0, TCSANOW, &tty) == -1)
#else
#  if !defined(SYS5)
	if (ioctl(0, TIOCSETN, (char *) &tty) == -1)
#  else
	if (ioctl (0, TCSETAW, (char *) &tty) == -1)
#  endif
#endif
	{
		putstr("ioctl error?");
		byebye(1);
	}
#if defined(TIOCSETC) && !defined(SYS5)
	ioctl(0, TIOCSETC, n == 0 ? (char *) &tc1 : (char *) &tc2);
#endif
#if defined(TIOCSLTC) && !defined(SYS5)
	ioctl(0, TIOCSLTC, n == 0 ? (char *) &ls1 : (char *) &ls2);
#endif
}
#else	/* BRLUNIX */
void
ttyset(n)
{
	struct sg_brl	tty;

	if (n)
		tty = newtty;
	else
		tty = oldtty;

	if (stty(0, (char *) &tty) < 0)
	{
		putstr("stty error?");
		byebye(1);
	}
}
#endif

/* NOSTRICT */

char *
emalloc(size)
{
	register char	*ptr;

	if (ptr = malloc((unsigned) size))  {
		return ptr;
	}
	GCchunks();
	if (ptr = malloc((unsigned) size))  {
		return ptr;
	}
	error("out of memory");
	/* NOTREACHED */
	return (char *)NULL;
}

void
dispatch(c)
register int	c;
{
	register struct function	*fp;

	fp = mainmap[c];
	if (fp == 0) {
		rbell();
		exp = 1;
		exp_p = errormsg = 0;
		message("");
		return;
	}
	ExecFunc(fp, 0);
}

int
getch()
{
	register int	c;

	if (stackp >= 0 && macstack[stackp]->Flags & EXECUTE)
		c = MacGetc();
	else {
		redisplay();
		if ((c = jgetchar()) == EOF)  {
			finish(SIGHUP);
		}
		c &= 0177;
		if (KeyMacro.Flags & DEFINE)
			MacPutc(c);
	}
	LastKeyStruck = c;
	return c;
}

void
parse(argc, argv)
register char	*argv[];
{
	BUFFER	*firstbuf = 0;
	BUFFER	*secondbuf = 0;
	register char	c;

	s_mess("Jonathan's Own Version of Emacs  (ARL %s)", version);

	*argv = (char *) 0;
	argvp = argv + 1;

	while (argc > 1) {
		if (argv[1][0] == '-') {
			if (argv[1][1] == 't') {
				++argv;
				--argc;
				exp_p = 1;
				find_tag(argv[1]);
			}
		} else if (argv[1][0] == '+' &&
					(c = argv[1][1]) >= '0' && c <= '9') {
			++argv;
			--argc;
			SetBuf(do_find(curwind, argv[1]));
			SetLine(next_line(curline, atoi(&argv[0][1]) - 1));
		} else {
			SetBuf(do_find(curwind, argv[1]));
		}

		if (!firstbuf)
			firstbuf = curbuf;
		else if (!secondbuf)
			secondbuf = curbuf;

		++argv;
		--argc;
	}

	if (secondbuf) {
		curwind = div_wind(curwind);
		SetBuf(secondbuf);
		PrevWindow();
	}
	if (firstbuf)
		SetBuf(firstbuf);
}

#ifdef lint
Ignore(a)
	char *a;
{

	a = a;
}

Ignorf(a)
	int (*a)();
{

	a = a;
}
#endif

/* VARARGS */

void
error(VA_T(const char *fmt) VA_ALIST)
	VA_DCL
{
	VA_D(char *fmt)
	VA_LIST(ap)

	VA_START(ap, fmt)
	VA_I(ap, char *, fmt)
	if (fmt) {
		vsprintf(mesgbuf, fmt, ap);
		UpdMesg++;
	}
	VA_END(ap)
	rbell();
	longjmp(mainjmp, ERROR);
}

/* VARARGS */

void
complain(VA_T(const char *fmt) VA_ALIST)
	VA_DCL
{
	VA_D(char *fmt)
	VA_LIST(ap)

	VA_START(ap, fmt)
	VA_I(ap, char *, fmt)
	if (fmt) {
		vsprintf(mesgbuf, fmt, ap);
		UpdMesg++;
	}
	VA_END(ap)
	rbell();	/* Always ring the bell now */
	longjmp(mainjmp, COMPLAIN);
}

/* VARARGS */

void
confirm(VA_T(const char *fmt) VA_ALIST)
	VA_DCL
{
	VA_D(char *fmt)
	VA_LIST(ap)
	char *yorn;

	VA_START(ap, fmt)
	VA_I(ap, char *, fmt)
	vsprintf(mesgbuf, fmt, ap);
	VA_END(ap)
	yorn = ask((char *)0, mesgbuf);
	if (*yorn != 'Y' && *yorn != 'y')
		longjmp(mainjmp, COMPLAIN);
}

void
byebye(status)
{
	flusho();
	exit(status);
}

void
Recurse()
{
	RecDepth++;
	DoKeys(0);
	RecDepth--;
}

read_ch()
{
	int	c;

	if ((c = peekc) != -1) {
		peekc = -1;
		return c;
	}
	return getch();
}

void
DoKeys(first)
{
	register int	c;
	jmp_buf	savejmp;

	bcopy((char *) mainjmp, (char *) savejmp, sizeof savejmp);

	switch( setjmp(mainjmp) ) {
	case 0:
		if (first)
			parse(iniargc, iniargv);
		break;

	case QUIT:
		bcopy((char *) savejmp, (char *) mainjmp, sizeof mainjmp);
		return;

	case ERROR:
		getDOT();	/* God knows what state linebuf was in */

	case COMPLAIN:
		IOclose();
		Getchar = getch;
		if (Input) {
			ignore(close(Input));
			Input = 0;	/* Terminal has control now */
		}
		errormsg++;
		FixMacros();
		Asking = 0;		/* Not anymore we ain't */
		redisplay();
		break;
	}

	this_cmd = last_cmd = 0;

	for (;;) {
		exp = 1;
		exp_p = 0;
		last_cmd = this_cmd;
cont:
		this_cmd = 0;
		c = read_ch();
		if (c == -1)
			continue;
		else if (c < -1)
			break;
	 	dispatch(c);
		if (this_cmd == ARG_CMD)
			goto cont;
	}
}


main(argc, argv)
char	*argv[];
{
	extern char searchbuf[];
	char	*home;

	peekc = -1;
	killptr = errormsg = 0;
	curbuf = world = (BUFFER *) 0;

	iniargc = argc;
	iniargv = argv;

	searchbuf[0] = '\0';
	InputPending = 0;
	Asking = 0;
	Crashing = 0;
	Input = 0;		/* Terminal? */
	RecDepth = 0;		/* Top level */
	Getchar = getch;

	if( setjmp(mainjmp) )  {
		jprintf("Pre-error: \"%s\"; tell system support\n", mesgbuf);
		finish(0);
	}

	getTERM();
	ttsize();
	ttsetup();
	InitCM();
	CanScroll = ((AL && DL) || CS);
	settout();
	make_scr();	/* Do this before making zero, allocates memory */
	tmpinit();	/* Init temp file */
	MacInit();	/* Initialize Macros */
	InitFuncs();	/* Initialize functions and variables */
	InitBindings();	/* Everyday EMACS commands */
	winit();	/* Initialize window */

	noflags(origflags);
	curbuf = do_select(curwind, Mainbuf);

	if ((StdShell = getenv("SHELL")) == 0)
		StdShell = BinShell;
	ignore(joverc(Joverc));
	if (home = getenv("HOME"))
		ignore(joverc(sprint("%s/.joverc", home)));

	ttinit();	/* Initialize terminal (after ~/.joverc) */

	if (TI)
		putpad(TI, 1);
	if (VS)
		putpad(VS, 1);
	if (KS)
		putpad(KS, 1);
	putpad(CL, 1);

	bcopy(curbuf->b_flags, origflags, NFLAGS*sizeof(int));
	/* All new buffers will have these flags when created. */
	RedrawDisplay();	/* Start the redisplay process */
	DoKeys(1);
	finish(0);
}
@


11.7
log
@
lint, RCSid
@
text
@d4 1
a4 1
 * $Revision: 11.6 $
d7 4
d143 1
a143 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/jove/jove_main.c,v 11.6 1997/07/16 02:31:25 mike Exp $";
@


11.6
log
@Changed from HAS_TERMIOS to HAVE_TERMIOS_H
@
text
@d4 1
a4 1
 * $Revision: 11.5 $
d7 3
d139 1
a139 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_main.c,v 11.5 1997/01/03 17:42:17 jra Exp mike $";
@


11.5
log
@Mods for Irix 6.2
@
text
@d4 1
a4 1
 * $Revision: 11.4 $
d7 3
d136 1
a136 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_main.c,v 11.4 1995/06/21 03:42:30 gwyn Exp jra $";
d150 1
a150 1
#if HAS_TERMIOS
d332 1
a332 1
#if defined(SYS5) || HAS_TERMIOS
d342 1
a342 1
#  if HAS_TERMIOS
d459 1
a459 1
# if HAS_TERMIOS
d475 1
a475 1
#  if HAS_TERMIOS
d483 1
a483 1
#  endif	/* HAS_TERMIOS */
d494 1
a494 1
#if !defined(SYS5) && !HAS_TERMIOS
d621 1
a621 1
#if HAS_TERMIOS
d636 1
a636 1
#if HAS_TERMIOS
@


11.4
log
@Eliminated trailing blanks.
BinShell, version, Joverc are now arrays rather than string literal pointers.
Changed memcpy calls back to bcopy.  (Fixed confusing use of SYSV vs. SYS5.)
Fixed varargs functions, using VA_* macros.
Fixed usage of FNDELAY, which is obsolete.
Improved use of conditionals dealing with system variations.
Made reset of SIGINT handler independent of SIGTSTP.
@
text
@d4 1
a4 1
 * $Revision: 11.3 $
d6 10
a15 1
 * $Log:	jove_main.c,v $
d133 1
a133 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_main.c,v 11.3 95/01/04 23:26:50 mike Rel4_4 $";
d363 1
d375 1
d389 1
d405 1
d422 1
d469 1
d541 1
d548 1
d575 1
d615 1
d654 1
d852 1
d859 1
@


11.3
log
@Irix 5.3 fix
@
text
@d2 1
a2 1
 *			J O V E _ M A I N . C 
d4 1
a4 1
 * $Revision: 11.2 $
d6 4
a9 1
 * $Log: jove_main.c,v $
d19 1
a19 1
 * 
d22 1
a22 1
 * 
d25 1
a25 1
 * 
d28 1
a28 1
 * 
d37 1
a37 1
 * 
d41 1
a41 1
 * 
d44 1
a44 1
 * 
d47 1
a47 1
 * 
d50 1
a50 1
 * 
d53 1
a53 1
 * 
d56 1
a56 1
 * 
d59 1
a59 1
 * 
d62 1
a62 1
 * 
d65 1
a65 1
 * 
d69 1
a69 1
 * 
d72 1
a72 1
 * 
d76 1
a76 1
 * 
d80 1
a80 1
 * 
d83 1
a83 1
 * 
d86 1
a86 1
 * 
d90 1
a90 1
 * 
d94 1
a94 1
 * 
d97 1
a97 1
 * 
d100 1
a100 1
 * 
d103 1
a103 1
 * 
d106 1
a106 1
 * 
d109 1
a109 1
 * 
d111 2
a112 2
 * 
 * 
d115 1
a115 1
 * 
d118 1
a118 1
 * 
d121 1
a121 1
 * 
d124 1
a124 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/jove/RCS/jove_main.c,v 11.2 1995/01/04 20:09:00 stay Exp $";
a143 3
# if defined(sun) || defined(sparc) || defined(__sparc) || defined(cray)
#   include <sys/file.h>  /* Solaris and UNICOS need this for FNDELAY */
# endif
d154 5
a158 3
				/* IRIX 5.x needs FNDELAY defined */
#if IRIX >= 5
#include <sys/file.h>
a160 7
extern char	*version;
extern char	*BinShell;
extern char	*Joverc;
extern int	errno;

extern char	*sprint();

a162 4
#ifndef	BRLUNIX			/* this is not found on a BRL pdp-11.	*/
/***** #include <sys/ioctl.h> *****/
#endif

d165 1
a165 1
#endif 
d167 1
a167 1
#if !defined(SYS5) && !defined(HAS_TERMIOS)
a220 1
#ifndef SIGTSTP			/* Job stopping in other words */
a221 1
#endif
d281 1
a281 1
		} while ((nchars == 0 && Input == 0)	/* DAG -- added Input test */
d313 1
a313 1
#else 
d320 1
a320 1
#if defined(SYS5) || defined(HAS_TERMIOS)
d330 2
a331 2
#  if defined(HAS_TERMIOS)
		(void)fcntl( Input, F_SETFL, flags|FNDELAY );
d442 1
a442 1
# if defined(HAS_TERMIOS)
d457 1
a457 1
#  if defined(HAS_TERMIOS)
d476 1
a476 1
#if !defined(SYS5) && !defined(HAS_TERMIOS)
a482 1
	/* DAG -- bug fix (was missing) */
d569 2
a570 2
	/* Change interupt and quit. */
#if defined(TIOCGETC) && !defined(SYS5)
d599 1
a599 1
#if defined(HAS_TERMIOS)
d614 1
a614 1
#if defined(HAS_TERMIOS)
d617 1
a617 1
#  if !defined(SYS5) && !defined(HAS_TERMIOS)
d634 1
a634 1
#else
d773 1
a773 1
/* VARARGS1 */
d775 3
a777 3
error(fmt, a, b, c, d)
char	*fmt;
char	*a, *b, *c, *d;
d779 5
d785 1
a785 1
		sprintf(mesgbuf, fmt, a, b, c, d);
d788 1
d793 1
a793 1
/* VARARGS1 */
d795 3
a797 3
complain(fmt, a, b, c, d)
char	*fmt;
char	*a, *b, *c, *d;
d799 5
d805 1
a805 1
		sprintf(mesgbuf, fmt, a, b, c, d);
d808 1
d813 1
a813 1
/* VARARGS1 */
d815 3
a817 3
confirm(fmt, a, b, c, d)
char	*fmt;
char	*a, *b, *c, *d;
d819 2
d823 4
a826 1
	sprintf(mesgbuf, fmt, a, b, c, d);
d862 1
a862 1
	memcpy((char *) savejmp, (char *) mainjmp, sizeof savejmp);
d871 1
a871 1
		memcpy((char *) mainjmp, (char *) savejmp, sizeof mainjmp);
d969 1
a969 1
	memcpy(origflags, curbuf->b_flags, NFLAGS*sizeof(int));
@


11.2
log
@Fixed for Irix 5.3 which no longer declares
FNDELAY for POSIX_SOURCE
@
text
@d4 1
a4 1
 * $Revision: 11.1 $
d7 4
d121 1
a121 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_main.c,v 11.1 1995/01/04 10:35:17 mike Rel4_4 stay $";
@


11.1
log
@Release_4.4
@
text
@d4 1
a4 1
 * $Revision: 10.13 $
d6 4
a9 1
 * $Log:	jove_main.c,v $
d117 1
a117 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_main.c,v 10.13 94/12/29 23:02:59 mike Exp $";
d149 5
@


10.13
log
@Bug #158.  Eliminated ^V doubling on DEC Alpha, and Solaris.
@
text
@d4 1
a4 1
 * $Revision: 10.12 $
d7 3
d114 1
a114 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_main.c,v 10.12 94/12/14 15:33:54 jra Exp Locker: mike $";
@


10.12
log
@Cray also needs file.h included.
@
text
@d4 1
a4 1
 * $Revision: 10.11 $
d7 3
d111 1
a111 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/jove/RCS/jove_main.c,v 10.11 94/10/14 17:29:25 mike Exp Locker: jra $";
d500 4
d507 6
@


10.11
log
@SunOS 5.2
@
text
@d4 1
a4 1
 * $Revision: 10.10 $
d7 3
d108 1
a108 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_main.c,v 10.10 94/09/22 18:53:54 butler Exp Locker: mike $";
d128 2
a129 2
# if defined(sun) || defined(sparc) || defined(__sparc)
#   include <sys/file.h>  /* Solaris needs this for FNDELAY */
@


10.10
log
@Added ifdef needed for Solaris
@
text
@d4 1
a4 1
 * $Revision: 10.9 $
d6 4
a9 1
 * $Log: jove_main.c,v $
d105 1
a105 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_main.c,v 10.9 1994/09/17 04:57:35 butler Exp butler $";
d125 2
a126 2
# if defined(sun) && defined(sparc)
#   include <sys/file.h>  /* Solaris needs this */
@


10.9
log
@changed all calls to bcopy to be memcpy instead.  Useful for Solaris 5.2
@
text
@d4 1
a4 1
 * $Revision: 10.8 $
d7 3
d102 1
a102 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_main.c,v 10.8 1993/12/10 05:50:57 mike Exp butler $";
d122 3
@


10.8
log
@tchars should be defined only on old-style BSD systems.
@
text
@d4 1
a4 1
 * $Revision: 10.7 $
d6 4
a9 1
 * $Log:	jove_main.c,v $
d99 1
a99 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_main.c,v 10.7 93/12/10 05:35:40 mike Exp Locker: mike $";
d817 1
a817 1
	bcopy((char *) mainjmp, (char *) savejmp, sizeof savejmp);
d826 1
a826 1
		bcopy((char *) savejmp, (char *) mainjmp, sizeof mainjmp);
d924 1
a924 1
	bcopy(curbuf->b_flags, origflags, NFLAGS*sizeof(int));
@


10.7
log
@Additional POSIX support
@
text
@d4 1
a4 1
 * $Revision: 10.6 $
d7 3
d96 1
a96 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_main.c,v 10.6 93/10/26 06:32:59 mike Exp Locker: mike $";
d143 2
a144 2
#if !defined(SYS5)
struct tchars	tc1, tc2;
@


10.6
log
@Changed printf() to jprintf() so that all modules could safely
use stdio.h
@
text
@d4 1
a4 1
 * $Revision: 10.5 $
d7 4
d93 1
a93 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_main.c,v 10.5 93/10/26 06:01:51 mike Exp Locker: mike $";
d457 22
a478 1
	newtty.c_oflag &= ~(OLCUC|ONLCR|OCRNL|ONOCR|ONLRET|OFILL);	/* DAG -- bug fix (was missing) */
@


10.5
log
@Changed getchar() to jgetchar() to prevent stdio.h conflict
@
text
@d4 1
a4 1
 * $Revision: 10.4 $
d7 3
d89 1
a89 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_main.c,v 10.4 93/10/26 05:42:22 mike Exp Locker: mike $";
d857 1
a857 1
		printf("Pre-error: \"%s\"; tell system support\n", mesgbuf);
@


10.4
log
@POSIX
@
text
@d4 1
a4 1
 * $Revision: 10.3 $
d7 3
d86 1
a86 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_main.c,v 10.3 93/10/26 03:38:55 mike Exp Locker: mike $";
d239 1
a239 1
getchar()
d371 1
a371 1
		yorn = getchar();
d451 1
a451 1
	/* VMIN = 0 causes us to loop in getchar() */
d635 1
a635 1
		if ((c = getchar()) == EOF)  {
@


10.3
log
@termios stuff
@
text
@d4 1
a4 1
 * $Revision: 10.2 $
d7 3
d83 1
a83 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_main.c,v 10.2 93/04/01 04:25:24 mike Exp Locker: mike $";
d98 3
d120 2
d295 3
d299 1
d408 1
a408 1
struct termio	oldtty, newtty;
d422 4
a425 1
#if defined(SYS5) || defined(HAS_TERMIOS)
d427 1
a427 1
#else
d429 2
a430 1
#endif
d522 1
d524 1
d535 1
a535 1
	struct termio	tty;
d549 4
a552 1
#if !defined(SYS5) && !defined(HAS_TERMIOS)
d554 1
a554 1
#else
d556 1
d606 1
d623 1
d643 1
d774 1
@


10.2
log
@Arg to FIONREAD is an "int", not a "long" these days.
@
text
@d4 1
a4 1
 * $Revision: 10.1 $
d7 3
d80 1
a80 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_main.c,v 10.1 91/10/12 06:54:00 mike Rel4_0 Locker: mike $";
d94 3
a96 2
#ifndef SYS5
#include <sgtty.h>
d98 7
a104 3
#include <termio.h>
#include <fcntl.h>
#endif 
d277 1
a277 1
#ifdef SYS5
d395 1
a395 1
#ifdef SYS5
d397 4
a400 1
#else
d402 2
a403 1
#endif
d410 1
a410 1
#ifdef SYS5
d425 1
a425 1
#ifndef SYS5
d516 1
a516 1
#ifdef SYS5
d519 3
d523 1
d531 1
a531 1
#ifndef SYS5
d626 1
a626 1
	s_mess("Jonathan's Own Version of Emacs  (BRL %s)", version);
@


10.1
log
@Release_4.0
@
text
@d4 1
a4 1
 * $Revision: 2.16 $
d7 3
d77 1
a77 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_main.c,v 2.16 91/08/30 20:24:48 mike Exp $";
d264 1
a264 1
		long c;
@


2.16
log
@Added !defined(SYS5) protection around some BSD ioctls
@
text
@d4 1
a4 1
 * $Revision: 2.15 $
d7 3
d74 1
a74 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_main.c,v 2.15 91/08/30 19:28:59 mike Exp $";
@


2.15
log
@Added BRL-specific identification
@
text
@d4 1
a4 1
 * $Revision: 2.14 $
d7 3
d71 1
a71 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_main.c,v 2.14 91/08/30 18:11:05 mike Exp $";
d104 1
a104 1
#ifdef TIOCSLTC
d108 1
a108 1
#ifndef SYS5
d461 1
a461 1
#ifdef TIOCSLTC
d471 1
a471 1
#ifdef TIOCGETC
d518 1
a518 1
#ifdef TIOCSETC
d521 1
a521 1
#ifdef TIOCSLTC
d772 2
@


2.14
log
@Made explicit that termcap.h to be used is the local version
@
text
@d4 1
a4 1
 * $Revision: 2.13 $
d7 3
d68 1
a68 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_main.c,v 2.13 91/08/30 17:54:35 mike Exp $";
d556 1
d601 1
a601 1
	s_mess("Jonathan's Own Version of Emacs  (%s)", version);
@


2.13
log
@Changed #include directives to distinguish between local and system header
files.
@
text
@d4 1
a4 1
 * $Revision: 2.12 $
d7 4
d65 1
a65 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_main.c,v 2.12 91/08/30 17:49:09 mike Exp $";
d76 1
a76 1
#include <termcap.h>
@


2.12
log
@Paul Stay mods for ANSI C
@
text
@d4 1
a4 1
 * $Revision: 2.11 $
d7 3
d61 1
a61 1
static char RCSid[] = "@@(#)$Header: jove_main.c,v 2.11 87/09/16 21:28:40 mike Exp $";
d71 2
a72 2
#include "jove.h"
#include "termcap.h"
@


2.11
log
@Hopefully, the Final Word on the SysV "poll" for input
code.
@
text
@d4 1
a4 1
 * $Revision: 2.10 $
d7 4
d58 1
a58 1
static char RCSid[] = "@@(#)$Header: jove_main.c,v 2.10 87/09/10 00:23:01 mike Locked $";
d77 1
a77 1
#endif SYS5
d89 1
a89 1
#endif BRLUNIX
d93 1
a93 1
#endif TIOCSLTC
d97 1
a97 1
#endif SYS5
d105 1
d143 1
d215 1
a215 1
#endif SYS5
d243 1
a243 1
#else BRLUNIX
d267 1
a267 1
#else SYS5
d272 2
a273 2
#endif SYS5
#endif FIONREAD
d275 1
a275 1
#endif BRLUNIX
d370 1
a370 1
#else SYS5
d372 1
a372 1
#endif SYS5
d381 1
a381 1
#else SYS5
d383 1
a383 1
#endif SYS5
d386 1
a386 1
#endif BRLUNIX
d397 1
a397 1
#else SYS5
d404 1
a404 1
#endif SYS5
d467 1
a467 1
#endif TIOCGETC
d489 1
a489 1
#endif SYS5
d500 1
a500 1
#endif SYS5
d507 1
a507 1
#endif TIOCSETC
@


2.10
log
@Hopefully, the fix for the "scramble the input" bug on the Crays
and other SysV machines.
@
text
@d4 1
a4 1
 * $Revision: 2.9 $
d7 4
d54 1
a54 1
static char RCSid[] = "@@(#)$Header: jove_main.c,v 2.9 87/05/05 21:04:12 mike Locked $";
a196 1
	char buf[128];
d250 2
d255 3
a257 1
		c = read(Input, smbuf+nchars, sizeof(smbuf)-nchars);
@


2.9
log
@Simplified getchar code. Now all systems use the read loop
@
text
@d4 1
a4 1
 * $Revision: 2.8 $
d7 3
d50 1
a50 1
static char RCSid[] = "@@(#)$Header: jove_main.c,v 2.8 87/04/14 20:14:21 dpk Locked $";
d176 1
a176 1
#define NTOBUF	20		/* Should never get that far ahead */
d250 1
a250 1
		c = read(Input, smbuf, sizeof smbuf);
d252 1
a252 1
			nchars = c;
@


2.8
log
@Added SIGHUP fix.
@
text
@d4 1
a4 1
 * $Revision: 2.7 $
d7 3
d47 1
a47 1
static char RCSid[] = "@@(#)$Header: jove_main.c,v 2.7 86/09/23 22:28:52 dpk Locked $";
a191 3
#ifdef JOBCONTROL
		nchars = read(Input, smbuf, sizeof smbuf);
#else
a197 4
#ifdef never
sprintf(buf,"getchar() nchars=%d\n", nchars);
write(2,buf,strlen(buf));
#endif
a203 2
#endif JOBCONTROL

@


2.7
log
@Externs now declared properly.
I/O fixes for SysV
@
text
@d7 4
d44 1
a44 1
static char RCSid[] = "@@(#)$Header: jove_main.c,v 2.7 86/09/23 22:26:46 mike Exp $";
d146 2
@


2.6
log
@last mod was incomplete
@
text
@d4 1
a4 1
 * $Revision: 2.5 $
d7 7
d40 1
a40 1
static char RCSid[] = "@@(#)$Header: jove_main.c,v 2.5 86/04/06 06:28:48 gwyn Exp $";
d58 1
d70 1
a70 1
#include <sys/ioctl.h>
d87 37
d181 1
d192 4
d239 1
a239 1
		int c;
d241 6
d250 1
d385 2
a386 1
	newtty.c_cc[VMIN] = 0;
d521 1
a521 1
	if (ptr = malloc((unsigned) size))
d523 1
d525 1
a525 1
	if (ptr = malloc((unsigned) size))
d527 1
a547 2
int	LastKeyStruck;

d556 1
a556 1
		if ((c = getchar()) == EOF)
d558 1
d704 1
a704 1
	switch (setjmp(mainjmp)) {
a747 1
int	Crashing = 0;
d770 1
a770 1
	if (setjmp(mainjmp)) {
@


2.5
log
@Fixed endless loop on joverc under System V.
@
text
@d4 1
a4 1
 * $Revision: 2.4 $
d7 3
d33 1
a33 1
static char RCSid[] = "@@(#)$Header: jove_main.c,v 2.4 86/01/17 13:23:37 gwyn Exp $";
a153 1
#ifndef SYS5
a154 3
#else
		if(nchars < 0) {
#endif SYS5
@


2.4
log
@fixed SYS5 terminal mode setup
@
text
@d4 1
a4 1
 * $Revision: 2.3 $
d7 3
d30 1
a30 1
static char RCSid[] = "@@(#)$Header: jove_main.c,v 2.3 86/01/11 03:01:51 gwyn Exp $";
d144 2
a145 1
		} while (nchars == 0 || (nchars < 0 && errno == EINTR));
@


2.3
log
@fixed window size code
@
text
@d4 1
a4 1
 * $Revision: 2.2 $
d7 3
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: jove_main.c,v 2.2 85/05/14 01:44:41 dpk Exp $";
d324 1
@


2.2
log
@Added changes to support System V (conditional on SYS5)
@
text
@d4 1
a4 1
 * $Revision: 2.1 $
d7 3
d24 1
a24 1
static char RCSid[] = "@@(#)$Header: jove_main.c,v 2.1 85/01/17 23:58:24 dpk Exp $";
d345 4
a348 4
		if (win.col)
			CO = win.col;
		if (win.row)
			LI = win.row;
d350 1
a350 1
#else TIOCGWINSZ
d357 1
a357 1
			CO = win.bytesx;
d359 1
a359 1
			LI = win.bytesy;
d361 2
a362 2
#endif BTL_BLIT
#endif TIOCGWINSZ
@


2.1
log
@
@
text
@d4 1
a4 1
 * $Revision: 2.0 $
d7 3
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: jove_main.c,v 2.0 84/12/26 16:46:45 dpk Exp $";
d35 1
d37 3
d57 1
d59 1
d134 3
d138 1
d141 1
d143 3
d177 1
d179 1
d182 6
a188 1
#endif
d190 2
d286 3
d290 1
d297 3
d301 1
d312 1
d315 6
d374 1
d383 1
d401 3
d405 1
d412 1
d414 3
d421 1
d423 1
@


2.0
log
@System as distributed to Berkeley 26 Dec 84
@
text
@d4 1
a4 1
 * $Revision: 1.3 $
d7 3
d18 1
a18 1
static char RCSid[] = "@@(#)$Header: jove_main.c,v 1.3 84/03/20 22:27:17 dpk BRL $";
d295 26
d655 1
d660 1
a660 1
	make_scr();	/* Do this before making zero */
@


1.3
log
@Added better termcap handling
@
text
@d4 1
a4 1
 * $Revision: 1.2 $
d7 3
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: jove_main.c,v 1.2 83/12/16 00:08:44 dpk BRL $";
a25 1

a27 4
#ifndef	BRLUNIX			/* this is not found on a BRL pdp-11.	*/
#include <sys/ioctl.h>
#endif

d32 11
d44 2
a45 3
struct ltchars	ls1,
		ls2;
#endif
d47 1
a47 2
struct tchars	tc1,
		tc2;
a54 3
extern char	*tfname;
extern int	errno;

a56 6
	int	Crashit = code && (code != LOGOEXIT);

#ifdef LSRHS_KLUDGERY
	if (Crashit)
		setdump(1);
#endif
d72 1
a72 1
	if (Crashit) {
d82 2
a89 2
	Placur(LI - 1, 0);
	putpad(CE, 1);
d91 2
a92 8
#ifdef LSRHS_KLUDGERY
	if (CS)
		deal_with_scroll();
#endif
	ignore(unlink(tfname));
	if (Crashit)
		abort();
	exit(code);
d113 1
a113 1
#ifdef MENLO_JCL
d123 1
a123 1
#endif MENLO_JCL
a170 4
	if (IF)
		dumpIF(IF);
	if (IS)
		putpad(IS, 1);
d183 1
a189 1
	Placur(LI - 1, 0);
d244 1
a244 1
		_exit(1);
a246 3
#ifndef NOINTR
		signal(SIGINT, SIG_IGN);
#endif
a248 3
#ifndef NOINTR
		signal(SIGINT, finish);
#endif
d269 1
a269 1
		exit(1);
a305 3
#ifndef NOINTR
	tc2.t_intrc = '\035';
#else
a306 1
#endif
a315 1
#ifdef SIGTSTP			/* New signal mechanism */
a316 3
#ifndef NOINTR
	ignorf(signal(SIGINT, finish));
#else
a317 1
#endif NOINTR
a322 13
#else
	ignorf(signal(SIGHUP, finish));
#ifndef NOINTR
	ignorf(signal(SIGINT, finish));
#else
	ignorf(signal(SIGINT, SIG_IGN));
#endif NOINTR
	ignorf(signal(SIGQUIT, SIG_IGN));
	ignorf(signal(SIGBUS, finish));
	ignorf(signal(SIGSEGV, finish));
	ignorf(signal(SIGPIPE, finish));
	ignorf(signal(SIGTERM, SIG_IGN));
#endif
d339 1
a339 1
		exit(1);
d359 1
a359 1
		exit(1);
a363 11
#ifdef LSRHS_KLUDGERY
deal_with_scroll()
{
	char	*pp;

	pp = getenv("SCROLL");
	if (!pp || !strcmp(pp, "smooth"))
		putstr("\033[?4h");	/* Put in smooth scroll. */
}
#endif

d423 1
a423 1
	message("Jonathan's Own Version of Emacs");
a463 9
copy_n(f, t, n)
register int	*f,
		*t,
		n;
{
	while (n--)
		*f++ = *t++;
}

d482 1
a482 1
error(fmt, args)
d484 1
d487 1
a487 1
		format(mesgbuf, fmt, &args);
d496 1
a496 1
complain(fmt, args)
d498 1
d501 1
a501 1
		format(mesgbuf, fmt, &args);
d510 1
a510 1
confirm(fmt, args)
d512 1
d516 1
a516 1
	format(mesgbuf, fmt, &args);
d522 1
a522 2
#ifndef PROFILE
exit(status)
d525 1
a525 1
	_exit(status);
a526 1
#endif
d551 1
a551 1
	copynchar((char *) savejmp, (char *) mainjmp, sizeof savejmp);
d560 1
a560 1
		copynchar((char *) mainjmp, (char *) savejmp, sizeof mainjmp);
d641 2
a642 2
		StdShell = STDSHELL;
	ignore(joverc(JOVERC));
a647 4
	if (IF)
		dumpIF(IF);
	if (IS)
		putpad(IS, 1);
d656 1
a656 1
	copy_n(origflags, curbuf->b_flags, NFLAGS);
a660 14
}

dumpIF(file)
register char	*file;
{
	char	buf[100];
	register int	fd;
	register int	count;

	if ((fd = open(file)) < 0)
		return;
	while ((count = read(fd, buf, 100)) > 0)
		write (1, buf, count);
	return;
@


1.2
log
@Added distinctive RCS header
@
text
@d4 1
a4 1
 * $Revision$
d6 4
a9 1
 * $Log$
d12 1
a12 1
static char RCSid[] = "@@(#)$Header$";
d84 2
d88 2
d109 1
a109 1
int	c;
d179 2
d183 2
d187 2
d195 2
d199 2
d420 1
a420 1
	char	*ptr;
d434 1
a434 1
	struct function	*fp;
d451 1
a451 1
	int	c;
d468 1
a468 1
char	*argv[];
d472 1
a472 1
	char	c;
d607 1
a607 1
	int	c;
d704 1
d707 2
a708 1
	putpad(CL, 1);
d711 2
d715 3
d724 14
@


1.1
log
@Original 4.2 Distribution Source
@
text
@d2 11
@
