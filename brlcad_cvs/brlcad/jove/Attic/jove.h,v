head	11.8;
access;
symbols
	ansi-20040405-merged:11.5.6.1
	postmerge-20040405-ansi:11.7
	premerge-20040404-ansi:11.7
	postmerge-autoconf:11.7
	autoconf-freeze:11.6.2.3
	premerge-autoconf:11.7
	ansi-20040316-freeze:11.5
	postmerge-20040315-windows:11.7
	premerge-20040315-windows:11.7
	windows-20040315-freeze:11.5.8.1
	autoconf-20031203:11.6
	autoconf-20031202:11.6
	autoconf-branch:11.6.0.2
	phong-branch:11.5.0.12
	photonmap-branch:11.5.0.10
	rel-6-1-DP:11.5
	windows-branch:11.5.0.8
	rel-6-0-2:11.5
	ansi-branch:11.5.0.6
	rel-6-0-1-branch:11.5.0.4
	hartley-6-0-post:11.5
	hartley-6-0-pre:11.5
	rel-6-0-1:11.5
	rel-6-0:11.5
	rel-5-4:11.5
	offsite-5-3-pre:11.5
	rel-5-3:11.5
	rel-5-2:11.5
	rel-5-1-branch:11.5.0.2
	rel-5-1:11.5
	rel-5-0:11.5
	rel-5-0-beta:11.5
	rel-4-5:11.4
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:2.4
	rel-3-0:2.4
	rel-2-3:2.4
	rel-2-0:2.3
	rel-1-24:2.3
	rel-1-20:2.1
	rel-1-10:2.1
	rt-2:2.0
	rt:1.2;
locks; strict;
comment	@ * @;


11.8
date	2004.05.21.17.48.31;	author morrison;	state dead;
branches;
next	11.7;

11.7
date	2003.12.30.13.27.41;	author erikg;	state Exp;
branches;
next	11.6;

11.6
date	2003.09.27.00.24.08;	author morrison;	state Exp;
branches
	11.6.2.1;
next	11.5;

11.5
date	98.06.17.03.23.54;	author mike;	state Exp;
branches
	11.5.6.1
	11.5.8.1;
next	11.4;

11.4
date	97.07.16.02.31.25;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	97.01.03.17.42.17;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.06.21.03.38.14;	author gwyn;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.35.07;	author mike;	state Rel4_4;
branches;
next	10.7;

10.7
date	95.01.03.21.34.33;	author butler;	state Exp;
branches;
next	10.6;

10.6
date	94.12.15.12.20.34;	author jra;	state Exp;
branches;
next	10.5;

10.5
date	94.12.15.12.17.34;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	93.12.10.04.20.38;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	93.10.26.06.32.04;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	93.10.26.05.15.33;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.53.53;	author mike;	state Rel4_0;
branches;
next	2.9;

2.9
date	91.09.23.03.44.00;	author mike;	state Exp;
branches;
next	2.8;

2.8
date	91.08.31.01.23.54;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	91.08.30.20.19.16;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	91.08.30.18.45.44;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	91.08.30.17.40.15;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	87.09.09.22.49.11;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	87.04.14.21.27.52;	author dpk;	state BRL;
branches;
next	2.2;

2.2
date	87.04.14.20.47.47;	author dpk;	state BRL;
branches;
next	2.1;

2.1
date	86.09.23.22.28.20;	author mike;	state Exp;
branches;
next	2.0;

2.0
date	84.12.26.16.49.52;	author dpk;	state Exp;
branches;
next	1.2;

1.2
date	83.12.16.00.10.14;	author dpk;	state BRL;
branches;
next	1.1;

1.1
date	83.12.16.00.10.10;	author dpk;	state Exp;
branches;
next	;

11.5.6.1
date	2004.03.17.21.16.41;	author morrison;	state Exp;
branches;
next	;

11.5.8.1
date	2004.03.11.23.41.32;	author morrison;	state Exp;
branches;
next	;

11.6.2.1
date	2003.12.30.13.28.57;	author erikg;	state Exp;
branches;
next	11.6.2.2;

11.6.2.2
date	2004.02.12.19.45.35;	author erikg;	state Exp;
branches;
next	11.6.2.3;

11.6.2.3
date	2004.03.15.14.06.15;	author erikg;	state Exp;
branches;
next	;


desc
@Jove is an EMACS like screen editor which will fit on 11's and Vaxen
@


11.8
log
@moved to src/other/jove/
@
text
@/*
 *			J O V E . H
 *
 * $Header: /n/xoff/cvs/brlcad/jove/jove.h,v 11.7 2003/12/30 13:27:41 erikg Exp $
 *
 */
/* jove.h header file to be included by EVERYONE */
#include <stdio.h>

#ifdef SYSV
# define SYS5	1
#endif

/*
 *  Some very common BSD --> SYSV conversion aids
 */
#if defined(SYS5) && !defined(bcopy)
/* IMPORTANT -- bcopy macro must not be invoked with overlapping source and destination! */
#	define bcopy(from,to,count)	memcpy( to, from, count )
#endif

#if defined(BSD) && !defined(SYS5) && (BSD <= 43)
#	define strchr(sp,c)	index(sp,c)
#	define strrchr(sp,c)	rindex(sp,c)
	extern char *index();
	extern char *rindex();
#endif

#ifndef HAVE_TERMIOS_H
#if (defined(BSD) && BSD >= 44) || defined(_POSIX_SOURCE)
#	define HAVE_TERMIOS_H	1
#else
#	define HAVE_TERMIOS_H	0
#endif
#endif

#include <setjmp.h>

#if defined(BSD) && !defined(SYS5) && (BSD <= 43)
#include <strings.h>
#else
#include <string.h>
#endif

/*
 *  DAG's portable support for functions taking variable number of arguments
 *
 *  Usage example:
 *
 *	extern int Advise(VA_T(const char *) VA_T(int) VA_DOTS);
 *
 *	#include <stdio.h>
 *	int Advise(VA_T(const char *format) VA_T(int verbose) VA_ALIST)
 *		VA_DCL
 *	{
 *		VA_D(char *format)		// note absence of "const"
 *		VA_D(int verbose)
 *		VA_LIST(ap)
 *		int verbosity, status;
 *		// end of declarations
 *		VA_START(ap, verbose)
 *		VA_I(ap, char *, format)	// note absence of "const"
 *		VA_I(ap, int, verbose)
 *		verbosity = verbose? VA_ARG(ap, int): 0;
 *		status = verbosity > 0? vfprintf(stderr, format, ap) > 0: 1;
 *		VA_END(ap)
 *		return status;
 *	}
 */
#ifdef __STDC__
#include <stdarg.h>
#define	VA_T(t)		t,
#define	VA_DOTS		...
#define	VA_ALIST	...
#define	VA_D(d)         /* nothing */
#define	VA_DCL		/* nothing */
#define	VA_LIST(ap)	va_list ap;
#define	VA_START(ap,A0)	va_start(ap,A0);
#define	VA_I(ap,T,Ai)	/* nothing */
#define	VA_ARG(ap,T)	va_arg(ap,T)
#define	VA_END(ap)	va_end(ap);
#else
#include <varargs.h>
#define	VA_T(t)		/* nothing */
#define	VA_DOTS		/* nothing */
#define	VA_ALIST	va_alist
#define	VA_D(d)		d;
#define	VA_DCL		va_dcl
#define	VA_LIST(ap)	va_list ap;
#define	VA_START(ap,A0)	va_start(ap);
#define	VA_I(ap,T,Ai)	Ai = va_arg(ap,T);
#define	VA_ARG(ap,T)	va_arg(ap,T)
#define	VA_END(ap)	va_end(ap);
#endif

#ifdef __convex__
#define	HAS_TEMPNAM	0	/* No tempnam()! */
#endif

#ifndef	HAS_TEMPNAM
#ifdef	L_tmpnam		/* From modern stdio.h */
#define	HAS_TEMPNAM	1
#else
#define	HAS_TEMPNAM	0
#endif
#endif

#if HAS_TEMPNAM
extern char	*tempnam();
#endif

/* The following is tailorable */
#if !defined(pdp11)

typedef	long	disk_line;
#define BSIZ	4096

#else

typedef	short	disk_line;
#define BSIZ	512

#endif

#ifndef NULL
# define NULL	0
#endif

#define OKAY	0		/* Return codes for when telling */
#define ABORT	1
#define STOP	2

#define LOGOEXIT	30	/* Sounds like a nice number.  Exit non-zero,
				 * but finish doesn't crash with a core dump.
				 * Logo checks for non-zero to check to see
				 * if it should abort the editing
				 */

#define NFUNCS		130
#define NMACROS		52	/* One for each letter???? VI mode for JF */
#define NVARS		20

#define FUNCTION	1
#define VARIABLE	2
#define MACRO		3

#define DEFINE		1
#define EXECUTE		2

#define	LBSIZE		BSIZ	/* Same as a logical disk block */
#define	ESIZE		128
#define	GBSIZE		256
#define	ALSIZE		(LBSIZE / sizeof(char *))	/* argument list max */

#define RMARGIN		72	/* Default right margin */

#define flusho()	flushout(-1, &termout)
#define Placur(l, c)	if ((l) != CapLine || (c) != CapCol) DoPlacur(l, c)

#define CTL(c)		((c) & 037)
#define META(c)		((c) | 0200)

#define	rbell()		(RingBell++)
#define	eolp()		(linebuf[curchar] == '\0')
#define bolp()		(curchar == 0)
#define	lastp(line)	((line) == curbuf->b_dol)
#define	firstp(line)	((line) == curbuf->b_zero)
#define eobp()		(lastp(curline) && eolp())
#define bobp()		(firstp(curline) && bolp())
#define HALF(wp)	(((wp)->w_height - 1) / 2)
#define SIZE(wp)	((wp)->w_height - 1)
#define makedirty(line)	line->l_dline |= DIRTY
#define IsModified(b)	((b)->b_status & B_MODIFIED)
#define	IsScratch(b)	((b)->b_status & B_SCRATCH)
#define	SetScratch(b)	((b)->b_status |= B_SCRATCH)
#define	ClrScratch(b)	((b)->b_status &= ~B_SCRATCH)
#define	IsReadOnly(b)	((b)->b_status & B_READONLY)
#define	SetReadOnly(b)	((b)->b_status |= B_READONLY);
#define	ClrReadOnly(b)	((b)->b_status &= ~B_READONLY);

#define DoTimes(f, n)	exp_p = 1, exp = (n), f()

extern int	BufSize;
extern int	CheckTime,
		errormsg;

/* This procedure allows redisplay to be aborted if the buffer is
 * ready to be flushed, and there are some characters waiting
 */

#define outchar(c) Putc(c, (&termout))
/* #define Putc(x,p) (--(p)->io_cnt>=0 ?  ((void)(*(p)->io_ptr++=(unsigned)(x))):flushout(x, p) ) */
#define Putc(x,p)	{ if( --(p)->io_cnt >= 0 ) \
				(*(p)->io_ptr++=(unsigned)(x)); \
			  else \
				flushout(x, p); \
			}

/*
 * C doesn't have a (void) cast, so we have to fake it for lint's sake.
 */
#ifdef lint
#	define	ignore(a)	Ignore((char *) (a))
#	define	ignorf(a)	Ignorf((int (*) ()) (a))
#else
#	define	ignore(a)	a
#	define	ignorf(a)	a
#endif

#define ARG_CMD		1
#define LINE_CMD	2
#define KILLCMD		3	/* So we can merge kills */
#define YANKCMD		4

/* Buffer type */

#define SCRATCHBUF	1
#define NORMALBUF	2

#define OnFlag(flags,f)		(flags[f] = 1)
#define OffFlag(flags,f)	(flags[f] = 0)
#define	IsFlagSet(flags,f)	(flags[f] > 0)	/* negative disables */
#define IsDisabled(flags,f)	(flags[f] < 0)

/* Buffer flags */

#define TEXTFILL	0	/* Text fill mode */
#define OVERWRITE	1	/* Over write mode */
#define CMODE		2	/* C mode */
#define MAGIC		3	/* If set allow pattern matching searching */
#define CASEIND		4	/* Case independent search */
#define MATCHING	5	/* In show matching mode */
#define AUTOIND		6	/* Indent same as previous line after return */
#define NFLAGS		7	/* DON'T FORGET THIS! */

extern int	origflags[NFLAGS],
	globflags[NFLAGS];

#define FIRSTCALL	0
#define ERROR		1
#define COMPLAIN	2	/* Do the error without a getDOT */
#define QUIT		3	/* Leave this level of recusion */

extern	char	*Mainbuf;
extern	int	RingBell;

extern char	genbuf[LBSIZE];		/* Scatch pad */
extern int	peekc,
	io,		/* File descriptor for reading and writing files */
	exp,
	exp_p,
	this_cmd,
	last_cmd,
	RecDepth;

#define	READ	0
#define	WRITE	1

extern jmp_buf	mainjmp;

typedef struct window	WINDOW;
typedef struct position	BUFLOC;
typedef struct mark	MARK;
typedef struct buffer	BUFFER;
typedef struct line	LINE;
typedef struct iobuf	IOBUF;

typedef int	(*FUNC)();

/* Pseudo-Standary library struct _iobuf */
struct iobuf {
	char	*io_ptr;
	int	io_cnt;
	char	*io_base;
	short	io_flag;
	char	io_file;
};

struct line {
	LINE	*l_prev,	/* Pointer to prev */
		*l_next;	/* Pointer to next */
	disk_line	l_dline;	/* Pointer to disk location */
};

struct window {
	WINDOW	*w_prev,	/* Circular list */
		*w_next;
	BUFFER	*w_bufp;	/* Buffer associated with this window */
	LINE	*w_top,		/* The top line */
		*w_line;	/* The current line */
	int	w_char,
		w_height,	/* Height of the window */
		w_topnum,	/* Line number of the topline */
		w_offset,	/* Printing offset for the current line */
		w_numlines,	/* Should we number lines in this window? */
		w_dotcol,	/* find_pos sets this */
		w_dotline,	/* UpdateWindow sets this */
		w_flags;
};

extern WINDOW	*fwind,		/* First window in list */
	*curwind;	/* Current window */

struct position {
	LINE	*p_line;	/* In the array */
	int	p_char;		/* Char pos */
};

struct mark {
	LINE	*m_line;
	int	m_char;		/* Char pos of the mark */
	MARK	*m_next;	/* List of marks */
};

struct buffer {
	char	*b_name,		/* Buffer name */
		*b_fname;		/* File name associated with buffer */
	int	b_ino;			/* Inode of file name */
	int	b_dev;			/* Device on which inode lives */
	LINE	*b_zero,		/* Pointer to first line in list */
		*b_dot,			/* Current line */
		*b_dol;			/* Last line in list */
	int	b_char;			/* Current character in line */

#define NMARKS	16			/* Number of marks in the ring */

	MARK	*b_markring[NMARKS],	/* New marks are pushed saved here */
		*b_marks;		/* All the marks for this buffer */
	int	b_themark;		/* Current mark */
	char	b_status;		/* Status flags (B_MODIFIED, etc.) */
#define	B_MODIFIED	01		/* Buffer has been modified */
#define	B_READONLY	02		/* File is readonly */
#define	B_SCRATCH	04		/* Buffer is a scratch buffer */

	int	b_flags[NFLAGS];
	BUFFER	*b_next;		/* Next buffer in chain */
};

extern BUFFER	*world,			/* First buffer */
	*curbuf;		/* Pointer into world for current buffer */

#define NUMKILLS	10	/* Number of kills saved in the kill ring */

#define DIRTY		01
#define MODELINE	02

struct scrimage {
	int	StartCol,	/* Physical column start */
		Sflags;		/* DIRTY or MODELINE */
	LINE	*Line;		/* Which buffer line */
	WINDOW	*Window;	/* Window that contains this line */
};

extern struct scrimage
	*nimage,
	*oimage;		/* See jove_screen.c */

extern IOBUF	termout;

extern int
	OKXonXoff,		/* Disable start/stop characters */
	VisBell,
	phystab,
	tabstop,		/* Expand tabs to this number of spaces */
	RMargin,		/* Right margin */
	MakeAll,		/* Should we make -k or just make */
	ScrollStep,		/* How should we scroll */
	Crashing,		/* We are in the middle of crashing */
	WtOnMk,			/* Write files on compile-it command */
	UseBuffers,		/* Use a buffer during list-buffers */
	BackupFiles,		/* Controls creation of backup files */
	FastPrompt,		/* Have C-X and M- prompt immediatly */
	EndWNewline;		/* End files with a blank line */

extern int	InputPending,	/* Non-zero if there is input waiting to
			   be processed. */
	Input,		/* What the current input is */
 	killptr,	/* Index into killbuf */
	CanScroll,	/* Can this terminal scroll? */
	Asking;		/* Are we on read a string from the terminal? */

extern char	**argvp;

#define curline		curbuf->b_dot
#define curchar		curbuf->b_char
#define curmark		curbuf->b_markring[curbuf->b_themark]

extern char	linebuf[LBSIZE];
extern LINE	*killbuf[NUMKILLS];	/* Array of pointers to killed stuff */

extern char	mesgbuf[];

struct screenline {
	char	*s_line,
		*s_length;
};			/* The screen */

struct macro {
	int	MacLength,	/* Length of macro so we can use ^@@ */
		MacBuflen,	/* Memory allocated for it */
		Offset,		/* Index into body for defining and running */
		Flags,		/* Defining/running this macro? */
		Ntimes;		/* Number of times to run this macro */
	char	*Name;		/* Pointer to macro's name */
	char	*Body;		/* Actual body of the macro */
};

struct function {
	char	*f_name;
	union {
		int	(*Func)();	/* This is a built in function */
		int	*Var;		/* Variable */
		struct macro	*Macro;	/* Macro */
	} f;
	char	f_type;
};

extern int	(*Getchar)();

extern struct function	*mainmap[0200],
		*pref1map[0200],
		*pref2map[0200],
		*LastFunc;

extern int	LastKeyStruck;

extern struct function	functions[],
			macros[],
			variables[];

extern struct macro	*macstack[],
			KeyMacro;
extern int	stackp;

extern int	CapLine,
		CapCol;

extern int	UpdModLine,	/* Whether we want to update the mode line */
		UpdMesg;	/* Update the message line */

/* Under BSDI's BSD/OS lseek returns an off_t
 * which is a quad_t or "long long".
 * It is also delcared in <sys/types.h>
 */
#if defined(BSD) && BSD <= 43
extern long	lseek();
#endif

extern disk_line	putline();

extern LINE
	*next_line(),
	*prev_line(),
	*nbufline(),
	*reg_delete(),
	*lastline(),
	*listput();

extern char
	*FuncName(),
	*filename(),
	*getblock(),
	*IOerr(),
	*bufmod(),
#if !defined(__sp3__)
	*index(),
#endif
	*RunEdit(),
	*getline(),
	*getblock(),
	*malloc(),
	*emalloc(),
	*mktemp(),
	*place(),
	*realloc(),
	*getright(),
	*getcptr(),
#if !defined(__sp3__)
	*rindex(),
#endif
	*getenv(),
	*tgoto(),
	*StrIndex();

extern BUFLOC
	*dosearch(),
	*DoYank(),
	*m_paren();

extern MARK	*CurMark(),
		*MakeMark();

extern WINDOW
	*windlook(),
	*next_wind(),
	*div_wind();

extern BUFFER
	*do_find(),
	*do_select(),
	*mak_buf(),
	*buf_exists(),
	*file_exists();

extern int	jgetchar();

extern char	*ask(VA_T(char *) VA_T(const char *) VA_DOTS);
extern void	error(VA_T(const char *) VA_DOTS);
extern void	complain(VA_T(const char *) VA_DOTS);
extern void	confirm(VA_T(const char *) VA_DOTS);
extern char	*sprint(VA_T(const char *) VA_DOTS);
extern void	s_mess(VA_T(const char *) VA_DOTS);
extern void	jprintf(VA_T(const char *) VA_DOTS);
extern int	UnixToBuf(VA_T(char *) VA_T(int) VA_T(int) VA_T(const char *)
			VA_DOTS);

extern void b_format(),
	tiewind(),
	set_ino(),
	setfname(),
	setbname(),
	FindMatch(),
	del_char(),
	InsChar(),
	DelChar(),
	do_cl_eol(),
	UpdateLine(),
	CalcScroll(),
	CalcTop(),
	UpdateMesg(),
	Beep(),
	ReadMacs(),
	WriteMacs(),
	SetMacro(),
	MacNolen(),
	NameMac(),	
	DoMacro(),
	ExecMacro(),
	Forget(),
	Remember(),
	InitBindings(),
	lfreereg(),
	OpenLine(),
	Insert(),
	insert(),
	whitesp(),
	byebye(),
	ttyset(),
	ttinit(),
	RunShell(),
	PtToMark(),
	MarkSet(),
	DoDelMark(),
	CaseReg(),
	case_reg(),
	lower(),
	upper(),
	case_word(),
	SetDot(),
	DotTo(),
	Eol(),
	down_line(),
	OutOfBounds(),
	PrevLine(),
	NextLine(),
	BackChar(),
	ForChar(),
	ArgIns(),
	SetLine(),
	DoJustify(),
	dword(),
	RegToUnix(),
	com_finish(),
	DoShell(),
	DoNextErr(),
	NextError(),
	ErrFree(),
	ErrParse(),
	IncSearch(),
	dosub(),
	compsub(),
	substitute(),
	search(),
	replace(),
	UpMotion(),
	DownMotion(),
	BackMotion(),
	ForMotion(),
	ForTab(),
	flushout(),
	TERMINFOfix(),
	zero_wind(),
	SetTop(),
	WindSize(),
	pop_wind(),
	v_clear();

#define	SAVE_NO		0
#define	SAVE_ASK	1
#define	SAVE_ALWAYS	2

#ifdef CRAY2
/* Common SYSV definitions not supported on the CRAY2 */
#define SIGBUS  SIGPRE
#define SIGSEGV SIGORE

#define VQUIT   1
#define VERASE  2
#define VKILL   3
#define VMIN    4
#define VTIME   5
#define	INLCR	0000100
#define ICRNL   0000400
#define IUCLC   0001000
#define	OLCUC	0000002
#define	ONLCR	0000004
#define	OCRNL	0000010
#define	ONOCR	0000020
#define	ONLRET	0000040
#define	OFILL	0000100
#define TABDLY  0014000
#define TAB3    0014000
#define CBAUD   0000017

#define	ISIG	0000001		/* line disc. 0 modes */
#endif
@


11.7
log
@should make sure 'BSD' is defined before checking its value...
@
text
@d4 1
a4 1
 * $Header: /c/CVS/brlcad/jove/jove.h,v 11.6 2003/09/27 00:24:08 morrison Exp $
@


11.6
log
@jove fix for aix; index() and rindex() happen to have slightly different types do not do the #define trickery
@
text
@d4 1
a4 1
 * $Header: /c/CVS/brlcad/jove/jove.h,v 11.5 1998/06/17 03:23:54 mike Exp $
d445 1
a445 1
#if BSD <= 43
@


11.6.2.1
log
@update from HEAD
@
text
@d4 1
a4 1
 * $Header: /c/CVS/brlcad/jove/jove.h,v 11.7 2003/12/30 13:27:41 erikg Exp $
d445 1
a445 1
#if defined(BSD) && BSD <= 43
@


11.6.2.2
log
@merge from HEAD
@
text
@@


11.6.2.3
log
@merge from head
@
text
@d4 1
a4 1
 * $Header: /c/CVS/brlcad/jove/jove.h,v 11.6.2.2 2004/02/12 19:45:35 erikg Exp $
@


11.5
log
@Don't need to define lseek() on more modern systems.
@
text
@d4 1
a4 1
 * $Header: /m/cad/jove/RCS/jove.h,v 11.4 1997/07/16 02:31:25 mike Exp $
d465 1
d467 1
d478 1
d480 1
@


11.5.6.1
log
@sync branch with HEAD
@
text
@d4 1
a4 1
 * $Header$
d445 1
a445 1
#if defined(BSD) && BSD <= 43
a464 1
#if !defined(__sp3__)
a465 1
#endif
a475 1
#if !defined(__sp3__)
a476 1
#endif
@


11.5.8.1
log
@sync to HEAD...
@
text
@d4 1
a4 1
 * $Header: /n/cad/c/CVS/brlcad/jove/jove.h,v 11.7 2003/12/30 13:27:41 erikg Exp $
d445 1
a445 1
#if defined(BSD) && BSD <= 43
a464 1
#if !defined(__sp3__)
a465 1
#endif
a475 1
#if !defined(__sp3__)
a476 1
#endif
@


11.4
log
@Changed from HAS_TERMIOS to HAVE_TERMIOS_H
@
text
@d4 1
a4 1
 * $Header: /m/cad/jove/RCS/jove.h,v 11.3 1997/01/03 17:42:17 jra Exp mike $
d445 1
a445 1
#if !defined(__bsdi__) && !defined(__NetBSD__)
@


11.3
log
@Mods for Irix 6.2
@
text
@d4 1
a4 1
 * $Header: /m/cad/jove/RCS/jove.h,v 11.2 1995/06/21 03:38:14 gwyn Exp jra $
d29 1
a29 1
#ifndef HAS_TERMIOS
d31 1
a31 1
#	define HAS_TERMIOS	1
d33 1
a33 1
#	define HAS_TERMIOS	0
@


11.2
log
@Eliminated trailing blanks.
Improved use of tempnam().
Memset()/bzero() was unused.
Changed memcpy calls back to bcopy.
Fixed confusing use of SYSV vs. SYS5 macros.
Defined ALSIZE parameter (maximum arguments to a UNIX subcommand).
Fully parenthesized macros.
Defined VA_* macros and declared all varargs functions.
Improved usage of HAS_TERMIOS.
USE_STRING_H was unused.
@
text
@d4 1
a4 1
 * $Header: /m/cad/jove/RCS/jove.h,v 11.1 95/01/04 10:35:07 mike Rel4_4 $
d192 6
a197 1
#define Putc(x,p) (--(p)->io_cnt>=0 ? ((int)(*(p)->io_ptr++=(unsigned)(x))):flushout(x, p))
d512 81
@


11.1
log
@Release_4.4
@
text
@d2 1
a2 1
 *			J O V E . H 
d4 1
a4 1
 * $Header: /m/cad/jove/RCS/jove.h,v 10.7 95/01/03 21:34:33 butler Exp $
a13 4
#ifdef SYSV
#	define	USE_STRING_H	1	/* use <string.h>, not <strings.h> */
#endif

d17 2
a18 2
#if defined(SYSV) && !defined(bzero)
#	define bzero(str,n)		memset( str, '\0', n )
d22 1
a22 1
#if defined(BSD) && !defined(SYSV) && (BSD <= 43)
d29 2
a30 1
#if defined(__STDC__) || (BSD >= 44) || defined(_POSIX_SOURCE)
d32 3
d39 1
a39 1
#ifdef BSD
d45 51
d97 13
a109 1
#define tempnam(x, y) tmpnam(x)		/* No tempnam()! */
d153 1
d158 1
a158 1
#define Placur(l, c)	if (l != CapLine || c != CapCol) DoPlacur(l, c) 
d160 2
a161 2
#define CTL(c)		(   c & 037)
#define META(c)		(   c | 0200)
d166 2
a167 2
#define	lastp(line)	(line == curbuf->b_dol)
#define	firstp(line)	(line == curbuf->b_zero)
d170 2
a171 2
#define HALF(wp)	((wp->w_height - 1) / 2)
#define SIZE(wp)	(wp->w_height - 1)
d173 7
a179 7
#define IsModified(b)	(b->b_status & B_MODIFIED)
#define	IsScratch(b)	(b->b_status & B_SCRATCH)
#define	SetScratch(b)	(b->b_status |= B_SCRATCH)
#define	ClrScratch(b)	(b->b_status &= ~B_SCRATCH)
#define	IsReadOnly(b)	(b->b_status & B_READONLY)
#define	SetReadOnly(b)	(b->b_status |= B_READONLY);
#define	ClrReadOnly(b)	(b->b_status &= ~B_READONLY);
d181 1
a181 1
#define DoTimes(f, n)	exp_p = 1, exp = n, f()
d437 1
a437 1
 * which is a quad_t or "long long".  
a460 1
	*ask(),
a473 1
	*sprint(),
d497 10
@


10.7
log
@lseek is defined in sys/types.h under BSDI and NetBSD
@
text
@d4 1
a4 1
 * $Header: /m/cad/jove/RCS/jove.h,v 10.6 1994/12/15 12:20:34 jra Exp butler $
@


10.6
log
@removed some redefinitions not needed for CRAY2
@
text
@d4 1
a4 1
 * $Header: /n/wolf/m/cad/jove/RCS/jove.h,v 10.5 94/12/15 12:17:34 gdurf Exp Locker: jra $
d372 5
d378 1
@


10.5
log
@All done
@
text
@d4 1
a4 1
 * $Header: /m/cad/jove/RCS/jove.h,v 10.4 1993/12/10 04:20:38 mike Exp gdurf $
a435 1
#define SIGIOT  SIGHWE
a457 1
#define TCSETAW TCSETA
@


10.4
log
@Added next_wind().
@
text
@d4 1
a4 1
 * $Header: /m/cad/jove/RCS/jove.h,v 10.3 93/10/26 06:32:04 mike Exp Locker: mike $
d43 4
@


10.3
log
@getchar() changed into jgetchar().
printf() changed into jprintf().
Now everyone can safely use stdio.h
@
text
@d4 1
a4 1
 * $Header: /m/cad/jove/RCS/jove.h,v 10.2 93/10/26 05:15:33 mike Exp Locker: mike $
d414 1
@


10.2
log
@Added HAS_TERMIOS flag
@
text
@d4 1
a4 1
 * $Header: /m/cad/jove/RCS/jove.h,v 10.1 91/10/12 06:53:53 mike Rel4_0 Locker: mike $
d8 1
a57 2
#define EOF	-1

a383 1
	*sprintf(),
d422 2
@


10.1
log
@Release_4.0
@
text
@d4 1
a4 1
 * $Header: /m/cad/jove/RCS/jove.h,v 2.9 91/09/23 03:44:00 mike Exp $
d6 1
a6 1

d30 4
@


2.9
log
@Moved mapping for SYSV to SYS5 to top of file.
@
text
@d4 1
a4 1
 * $Header: /m/cad/jove/RCS/jove.h,v 2.8 91/08/31 01:23:54 mike Exp $
@


2.8
log
@Only define NULL if not previously defined
@
text
@d4 1
a4 1
 * $Header: /m/cad/jove/RCS/jove.h,v 2.7 91/08/30 20:19:16 mike Exp $
d10 4
a37 4
#endif

#ifdef SYSV
# define SYS5	1
@


2.7
log
@Since <string.h> / <strings.h> are included, no need to declare
strcpy.
@
text
@d4 1
a4 1
 * $Header: /m/cad/jove/RCS/jove.h,v 2.6 91/08/30 18:45:44 mike Exp $
d54 4
a57 1
#define NULL	0
@


2.6
log
@Changed from BSD index/rindex nomenclature to SYSV strchr/strrchr.
@
text
@d4 1
a4 1
 * $Header$
a378 1
	*strcpy(),
@


2.5
log
@Paul Stay fixes.  No symbols after #else,
changed meaning of CTL and META macros
@
text
@d4 1
a4 1
 * $Revision: 2.4 $
a5 26
 * $Log:	jove.h,v $
 * Revision 2.4  87/09/09  22:49:11  mike
 * Added missing definitions for CRAY-2 to make things compile.
 * This is the same strategy that Cray used to get VI to work, so...
 * 
 * Revision 2.3  87/04/14  21:27:52  dpk
 * SYSV to SYS5.
 * 
 * Revision 2.2  87/04/14  20:47:47  dpk
 * Changes for CRAY compatability.
 * 
 * Revision 2.1  86/09/23  22:28:20  mike
 * Externs now declared properly.
 * I/O fixes for SysV
 * 
 * Revision 2.1  86/09/23  22:26:10  mike
 * Externs now declared properly.
 * I/O fixes for SysV
 * 
 * Revision 2.0  84/12/26  16:49:52  dpk
 * System as distributed to Berkeley 26 Dec 84
 * 
 * Revision 1.2  83/12/16  00:10:14  dpk
 * Added distinctive RCS header
 * 
 */
d9 19
d30 4
a33 2
#ifdef SYS5
#define	bcopy(f, t, c)	memcpy((t), (f), (c))
d36 4
d41 1
a41 1
#if defined(VMUNIX) || defined(CRAY)
@


2.4
log
@Added missing definitions for CRAY-2 to make things compile.
This is the same strategy that Cray used to get VI to work, so...
@
text
@d4 1
a4 1
 * $Revision: 2.3 $
d7 4
d47 1
a47 1
#else VMUNIX
d52 1
a52 1
#endif VMUNIX
d87 2
a88 2
#define CTL(c)		('c' & 037)
#define META(c)		('c' | 0200)
d450 1
a450 1
#endif CRAY2
@


2.3
log
@SYSV to SYS5.
@
text
@d4 1
a4 1
 * $Revision: 2.2 $
d7 3
d419 28
@


2.2
log
@Changes for CRAY compatability.
@
text
@d4 1
a4 1
 * $Revision: 2.1 $
d7 3
d30 1
a30 1
#ifdef SYSV
@


2.1
log
@Externs now declared properly.
I/O fixes for SysV
@
text
@d7 4
d27 4
d32 1
a32 1
#ifdef VMUNIX
@


2.0
log
@System as distributed to Berkeley 26 Dec 84
@
text
@d4 1
a4 1
 * $Revision: 1.2 $
d7 7
d92 1
a92 1
int	BufSize;
d140 1
a140 1
int	origflags[NFLAGS],
d151 2
a152 2
char	genbuf[LBSIZE];		/* Scatch pad */
int	peekc,
d163 1
a163 1
jmp_buf	mainjmp;
d205 1
a205 1
WINDOW	*fwind,		/* First window in list */
d243 1
a243 1
BUFFER	*world,			/* First buffer */
d279 1
a279 1
int	InputPending,	/* Non-zero if there is input waiting to
d286 1
a286 1
char	**argvp;
d292 2
a293 2
char	linebuf[LBSIZE];
LINE	*killbuf[NUMKILLS];	/* Array of pointers to killed stuff */
d322 1
a322 1
int	(*Getchar)();
d324 1
a324 1
struct function	*mainmap[0200],
@


1.2
log
@Added distinctive RCS header
@
text
@d4 1
a4 1
 * $Revision$
d6 4
a9 1
 * $Log$
d16 2
a17 1
#include "jove_tune.h"
d19 10
d53 1
a53 1
#define	LBSIZE		BUFSIZ	/* Same as a logical disk block */
d65 1
d75 7
a81 1
#define IsModified(b)	(b->b_modified)
d141 2
a142 1
extern char	*Mainbuf;
d167 1
a167 6
/* Standary library struct _iobuf */

/* This should look exactly like struct _iobuf (FILE) in stdio because
   _doprnt knows about FILE.  Ideally _doprnt should be written in C
   so as to make it portable ... */

a168 1
#ifndef VMUNIX
a173 7
#else
	int	io_cnt;
	char	*io_ptr;
	char	*io_base;
	short	io_flag;
	char	io_file;
#endif
d216 1
d227 5
a231 2
	char	b_type,			/* Scratch? */
		b_modified;
a238 3
/* Max terminal lines */
#define MAXNLINES	66	/* Change it if you want to! */

a393 2

int	(*sigset())();		/* Sigset returns a pointer to a procedure */
@


1.1
log
@Original 4.2 Distribution Source
@
text
@d1 8
@
