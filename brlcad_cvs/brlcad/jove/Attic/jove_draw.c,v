head	11.6;
access;
symbols
	ansi-20040405-merged:11.5
	postmerge-20040405-ansi:11.5
	premerge-20040404-ansi:11.5
	postmerge-autoconf:11.5
	autoconf-freeze:11.5
	premerge-autoconf:11.5
	ansi-20040316-freeze:11.5
	postmerge-20040315-windows:11.5
	premerge-20040315-windows:11.5
	windows-20040315-freeze:11.5
	autoconf-20031203:11.5
	autoconf-20031202:11.5
	autoconf-branch:11.5.0.12
	phong-branch:11.5.0.10
	photonmap-branch:11.5.0.8
	rel-6-1-DP:11.5
	windows-branch:11.5.0.6
	rel-6-0-2:11.5
	ansi-branch:11.5.0.4
	rel-6-0-1-branch:11.5.0.2
	hartley-6-0-post:11.5
	hartley-6-0-pre:11.5
	rel-6-0-1:11.5
	rel-6-0:11.5
	rel-5-4:11.3
	offsite-5-3-pre:11.5
	rel-5-3:11.3
	rel-5-2:11.3
	rel-5-1-branch:11.3.0.2
	rel-5-1:11.3
	rel-5-0:11.3
	rel-5-0-beta:11.3
	rel-4-5:11.3
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:2.0
	rel-3-0:2.0
	rel-2-3:2.0
	rel-2-0:2.0
	rel-1-24:2.0
	rel-1-20:2.0
	rel-1-10:2.0
	rt-2:2.0
	rt:1.2;
locks; strict;
comment	@ * @;


11.6
date	2004.05.21.17.48.32;	author morrison;	state dead;
branches;
next	11.5;

11.5
date	2000.08.25.03.19.49;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	2000.08.24.23.12.22;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	97.01.03.17.42.17;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.06.21.03.40.22;	author gwyn;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.35.12;	author mike;	state Rel4_4;
branches;
next	10.4;

10.4
date	93.10.26.06.33.04;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	93.10.26.06.01.39;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	93.10.26.03.44.16;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.53.57;	author mike;	state Rel4_0;
branches;
next	2.4;

2.4
date	91.08.30.18.59.46;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	91.08.30.18.11.00;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	91.08.30.17.54.31;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	91.08.30.17.49.04;	author mike;	state Exp;
branches;
next	2.0;

2.0
date	84.12.26.16.45.54;	author dpk;	state Exp;
branches;
next	1.2;

1.2
date	83.12.16.00.07.48;	author dpk;	state BRL;
branches;
next	1.1;

1.1
date	83.12.16.00.07.44;	author dpk;	state Exp;
branches;
next	;


desc
@Jove is an EMACS like screen editor which will fit on 11's and Vaxen
@


11.6
log
@moved to src/other/jove/
@
text
@/*
 *			J O V E _ D R A W . C
 *
 * $Revision: 11.5 $
 *
 * $Log: jove_draw.c,v $
 * Revision 11.5  2000/08/25 03:19:49  mike
 *
 * Lint
 *
 * Revision 11.4  2000/08/24 23:12:22  mike
 *
 * lint, RCSid
 *
 * Revision 11.3  1997/01/03  17:42:17  jra
 * Mods for Irix 6.2
 *
 * Revision 11.2  1995/06/21  03:40:22  gwyn
 * Eliminated trailing blanks.
 * Eliminated blank line at EOF.
 * Use LBSIZE instead of hard-wired 100.
 * Fixed varargs functions, using VA_* macros.
 *
 * Revision 11.1  95/01/04  10:35:12  mike
 * Release_4.4
 *
 * Revision 10.4  93/10/26  06:33:04  mike
 * Changed printf() to jprintf() so that all modules could safely
 * use stdio.h
 *
 * Revision 10.3  93/10/26  06:01:39  mike
 * Changed getchar() to jgetchar() to prevent stdio.h conflict
 *
 * Revision 10.2  93/10/26  03:44:16  mike
 * ANSI C
 *
 * Revision 10.1  91/10/12  06:53:57  mike
 * Release_4.0
 *
 * Revision 2.4  91/08/30  18:59:46  mike
 * Modifications for clean compilation on the XMP
 *
 * Revision 2.3  91/08/30  18:11:00  mike
 * Made explicit that termcap.h to be used is the local version
 *
 * Revision 2.2  91/08/30  17:54:31  mike
 * Changed #include directives to distinguish between local and system header
 * files.
 *
 * Revision 2.1  91/08/30  17:49:04  mike
 * Paul Stay mods for ANSI C
 *
 * Revision 2.0  84/12/26  16:45:54  dpk
 * System as distributed to Berkeley 26 Dec 84
 *
 * Revision 1.2  83/12/16  00:07:48  dpk
 * Added distinctive RCS header
 *
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/jove/jove_draw.c,v 11.5 2000/08/25 03:19:49 mike Exp $";
#endif

/*
   Jonathan Payne at Lincoln-Sudbury Regional High School 4-19-83

   jove_draw.c

   This contains, among other things, the modeline formatting, and the
   message routines (for prompting).  */

#include "./jove.h"

#include "./termcap.h"

void	message();

char mesgbuf[LBSIZE];

char *
bufmod(bp)
BUFFER	*bp;
{
	if (IsModified(bp))
		return "* ";
	return "";
}

/*
 * Find_pos returns the position on the line, that c_char represents
 * in line.
 */

find_pos(line, c_char)
LINE	*line;
{
	register char	*lp;
	char	buf[LBSIZE];

	if (line == curline)
		lp = linebuf;
	else
		lp = getcptr(line, buf);
	return calc_pos(lp, c_char);
}

calc_pos(lp, c_char)
register char	*lp;
register int	c_char;
{
	register int	pos = 0;
	register char	c = 0;

	while ((--c_char >= 0) && (c = *lp++)) {
		if (c == '\t')
			pos += (tabstop - (pos % tabstop));
		else if (c == '\177' || c < ' ')
			pos += 2;
		else
			pos++;
 	}
	return pos;
}

static char	sp_line[LBSIZE];

/* VARARGS */

char *
sprint(VA_T(const char *fmt) VA_ALIST)
	VA_DCL
{
	VA_D(char *fmt)
	VA_LIST(ap)

	VA_START(ap, fmt)
	VA_I(ap, char *, fmt)
	vsprintf(sp_line, fmt, ap);
	VA_END(ap)
	return sp_line;
}

/* VARARGS */

void
s_mess(VA_T(const char *fmt) VA_ALIST)
	VA_DCL
{
	VA_D(char *fmt)
	VA_LIST(ap)

	if (Input)
		return;
	VA_START(ap, fmt)
	VA_I(ap, char *, fmt)
	vsprintf(mesgbuf, fmt, ap);
	VA_END(ap)
	message(mesgbuf);
}

/* VARARGS */

void
jprintf(VA_T(const char *fmt) VA_ALIST)
	VA_DCL
{
	VA_D(char *fmt)
	VA_LIST(ap)

	VA_START(ap, fmt)
	VA_I(ap, char *, fmt)
	vsprintf(sp_line, fmt, ap);
	putstr (sp_line);
	VA_END(ap)
}

/*
 * message prints the null terminated string onto the bottom line of the
 * terminal.
 */
void
message(str)
char	*str;
{
	if (Input)
		return;
	UpdMesg++;
	errormsg = 0;
	if (str != mesgbuf)
		strncpy(mesgbuf, str, sizeof mesgbuf);
}

/*
 * This prints all the information about the current mode, and the
 * current filename.
 */

#define strcop(lp,str)		for (--lp, pp = str; (*lp++ = *pp++); )

void
ModeLine(w)
WINDOW	*w;
{
	int	lineno = FLine(w) + SIZE(w),
		i;
	char	line[512];

	int	*flags = w->w_bufp->b_flags;

	register char	*lp = line + 1,		/* Pay attention to this! */
			*pp;
	static char	*modenames[] = {
		"TE-",
		"OV-",
		"C-",
		"RE-",
		"CIS-",
		"SM-",
		"AI-"
	};

	strcop(lp, "--- JOVE (");

	for (i = 0; i < NFLAGS; i++)
		if (IsFlagSet(flags, i))
			strcop(lp, modenames[i]);

	if (*(lp - 2) == '(')
		strcop(lp, "NORMAL) ");
	else {
		lp--;	/* Back over the '-' */
		strcop(lp, ") ");
	}
	strcop(lp, sprint("%d: %s", bufnumber(w->w_bufp), w->w_bufp->b_name));
	pp = w->w_bufp->b_fname ? sprint(" \"%s\" ", w->w_bufp->b_fname) : " [No file] ";
	strcop(lp, pp);
	if (IsModified(w->w_bufp))
		strcop(lp, "* ");
	if (IsReadOnly(w->w_bufp))
		strcop(lp, "[readonly] ");
	--lp;			/* strcop leaves lp after the null */
	i = CO - 2 - (2 * SG);	/* 2 space pad plus padding for magic cookies */
	while (lp < &line[i])
		*lp++ = '-';
	*lp = 0;

	i_set(lineno, 0);
	Placur(lineno, 0);
	if( SO ) putpad( SO, 1 );	/* Put mode line in standout */
	if (swrite(line))
		do_cl_eol(lineno);
	if( SO )
		putpad( SE, 1 );
}

bufnumber( cb )
BUFFER	*cb;		/* Current Buffer.	*/
{
    int		i;	/* Buffer Count.	*/
    BUFFER	*bp;	/* Pointer into buffer list..	*/

    for (i=1, bp=world;	bp; bp=bp->b_next) {
    	if (bp->b_zero == 0)
    	    continue;
	if (bp == cb)
	    return i;
	++i;
    }
    return -1;
}

void
RedrawDisplay()
{
	LINE	*newtop = prev_line(curwind->w_line, exp_p ?
				exp : HALF(curwind));

	if (newtop == curwind->w_top)
		v_clear(FLine(curwind), FLine(curwind) + SIZE(curwind));
	else
		SetTop(curwind, newtop);
}

void
v_clear(line1, line2)
register int	line1,
		line2;
{
	while (line1 <= line2) {
		i_set(line1, 0);
		cl_eol();
		oimage[line1].Line = nimage[line1].Line = 0;
		line1++;
	}
}

void
ClAndRedraw()
{
	cl_scr();
}

void
NextPage()
{
	LINE	*newline;

	if (exp_p)
		UpScroll();
	else {
		newline = next_line(curwind->w_top, max(1, SIZE(curwind) - 1));
		DotTo(newline, 0);
		if (in_window(curwind, curwind->w_bufp->b_dol) == -1)
			SetTop(curwind, newline);
		curwind->w_line = newline;
	}
}

void
PrevPage()
{
	LINE	*newline;

	if (exp_p)
		DownScroll();
	else {
		newline = prev_line(curwind->w_top, max(1, SIZE(curwind) - 1));
		DotTo(newline, 0);
		SetTop(curwind, curline);
		curwind->w_line = curwind->w_top;
	}
}


/* Jonathan Payne at Lincoln-Sudbury Regional High School 5-25-83

   interface.c

   contains the procedures to HELP the user by creating buffers with
   information in them, or temporarily writing over the user's text. */


#include "./termcap.h"

static WINDOW	*LastW;		/* Save old window here so we can return */

static int	Gobble,
		Wrapped,
		StartNo,
		LineNo;		/* Line number we have reached (if we are NOT
				   using buffers.  This way is MUCH easier since
				   all we have to do is zero out the oimage line
				   pointer and let redisplay() notice the change
				   and fix it. */

static int	WhichKind;	/* Buffers or screen? */

int	UseBuffers = 0;		/* Don't create buffers by default. It may
				   be useful sometimes to making listings */

#define WITHSCREEN	1
#define WITHBUFFER	2

/* Tell With Buffers sets everything up so that we can clean up after
   ourselves when we are told to. */

void
TellWBuffers(bname, clobber)
char	*bname;
{
	WhichKind = WITHBUFFER;		/* So we know how to clean up */
	LastW = curwind;
	pop_wind(bname, clobber);	/* This creates the window and
					   makes it the current window. */
}

/* Tell With Screen.  If gobble is non-zero we DON'T ungetc characters as
   they are typed  e.g. --more-- or at the end of the list. */

void
TellWScreen(gobble)
{
	WhichKind = WITHSCREEN;
	StartNo = LineNo = FLine(curwind);	/* Much easier, see what I mean! */
	Wrapped = 0;
	Gobble = gobble;
}

/* DoTell ... don't keep the user in suspense!

   Takes a string as an argument and displays it correctly, i.e. if we are
   using buffers simply insert the string into the buffer adding a newline.
   Otherwise we swrite the line and change oimage */

DoTell(string)
char	*string;
{
	if (WhichKind == WITHBUFFER) {
		exp = 1;
		ins_str(string);
		LineInsert();
		return OKAY;
	}

	if (LineNo == StartNo + curwind->w_height - 1) {
		int	c;

		Wrapped++;		/* We wrapped ... see StopTelling */
		LineNo = StartNo;
		message("--more--");
		UpdateMesg();
		switch (c = jgetchar()) {
		case ' ':
			break;

		case CTL('G'):
		case '\177':
			if (!Gobble)
				ignore(Ungetc(c));
			return ABORT;

		default:
			if (Gobble == 0)
				ignore(Ungetc(c));
			return STOP;
		}
		message("");
		UpdateMesg();
	}
	i_set(LineNo, 0);
	ignore(swrite(string));
	cl_eol();
	oimage[LineNo].Line = (LINE *) -1;
	LineNo++;
	flusho();
	return OKAY;
}

void
StopTelling()
{
	if (WhichKind == WITHBUFFER) {
		NotModified();
		SetWind(LastW);
		LastW = 0;
	} else {
		int	c;

		ignore(DoTell("----------"));
		c = jgetchar();
		if (c != ' ' && Gobble == 0)
			ignore(Ungetc(c));
	}
}
@


11.5
log
@
Lint
@
text
@d4 1
a4 1
 * $Revision: 11.4 $
d7 4
d61 1
a61 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/jove/jove_draw.c,v 11.4 2000/08/24 23:12:22 mike Exp $";
@


11.4
log
@
lint, RCSid
@
text
@d4 1
a4 1
 * $Revision: 11.3 $
d7 4
d57 1
a57 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/jove/jove_draw.c,v 11.3 1997/01/03 17:42:17 jra Exp $";
a340 1
static char	*BufToUse;	/* Buffer to pop to if we are using buffers */
a341 2
static BUFFER	*LastB;		/* Buffer that used to be in LastW (in case it
				   isn't when we're done. */
a367 1
	BufToUse = bname;
a368 1
	LastB = curbuf;
@


11.3
log
@Mods for Irix 6.2
@
text
@d4 1
a4 1
 * $Revision: 11.2 $
d7 3
d53 1
a53 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_draw.c,v 11.2 1995/06/21 03:40:22 gwyn Exp jra $";
@


11.2
log
@Eliminated trailing blanks.
Eliminated blank line at EOF.
Use LBSIZE instead of hard-wired 100.
Fixed varargs functions, using VA_* macros.
@
text
@d4 1
a4 1
 * $Revision: 11.1 $
d6 7
a12 1
 * $Log:	jove_draw.c,v $
d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_draw.c,v 11.1 95/01/04 10:35:12 mike Rel4_4 $";
d189 1
d261 1
d273 1
d286 1
d292 1
d308 1
d359 1
d374 1
d433 1
@


11.1
log
@Release_4.4
@
text
@d2 1
a2 1
 *			J O V E _ D R A W . C 
d4 1
a4 1
 * $Revision: 10.4 $
d7 3
d13 1
a13 1
 * 
d16 1
a16 1
 * 
d19 1
a19 1
 * 
d22 1
a22 1
 * 
d25 1
a25 1
 * 
d28 1
a28 1
 * 
d32 1
a32 1
 * 
d35 1
a35 1
 * 
d38 1
a38 1
 * 
d41 1
a41 1
 * 
d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_draw.c,v 10.4 93/10/26 06:33:04 mike Exp $";
d49 1
a49 1
  
d61 1
a61 1
char mesgbuf[100];
d108 4
d113 2
a114 3
sprint(fmt, a, b, c, d, e)
char	*fmt;
char	*a, *b, *c, *d, *e;
d116 2
a117 1
	static char line[256];
d119 5
a123 2
	sprintf(line, fmt, a, b, c, d, e);
	return line;
d126 2
d129 2
a130 3
s_mess(fmt, a, b, c, d)
char	*fmt;
char	*a, *b, *c, *d;
d132 3
d137 4
a140 1
	sprintf(mesgbuf, fmt, a, b, c, d);
d144 5
a148 3
jprintf(fmt, a, b, c, d)
char	*fmt;
char	*a, *b, *c, *d;
d150 8
a157 1
	putstr (sprint(fmt, a, b, c, d));
d370 1
a370 1
   
a433 1

@


10.4
log
@Changed printf() to jprintf() so that all modules could safely
use stdio.h
@
text
@d4 1
a4 1
 * $Revision: 10.3 $
d7 4
d41 1
a41 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_draw.c,v 10.3 93/10/26 06:01:39 mike Exp Locker: mike $";
@


10.3
log
@Changed getchar() to jgetchar() to prevent stdio.h conflict
@
text
@d4 1
a4 1
 * $Revision: 10.2 $
d7 3
d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_draw.c,v 10.2 93/10/26 03:44:16 mike Exp Locker: mike $";
d106 1
a106 1
	static char line[160];
d123 1
a123 1
printf(fmt, a, b, c, d)
@


10.2
log
@ANSI C
@
text
@d4 1
a4 1
 * $Revision: 10.1 $
d7 3
d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_draw.c,v 10.1 91/10/12 06:53:57 mike Rel4_0 Locker: mike $";
d359 1
a359 1
		switch (c = getchar()) {
d396 1
a396 1
		c = getchar();
@


10.1
log
@Release_4.0
@
text
@d4 1
a4 1
 * $Revision: 2.4 $
d7 3
d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_draw.c,v 2.4 91/08/30 18:59:46 mike Exp $";
d46 2
d106 1
d128 1
@


2.4
log
@Modifications for clean compilation on the XMP
@
text
@d4 1
a4 1
 * $Revision: 2.3 $
d7 3
d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_draw.c,v 2.3 91/08/30 18:11:00 mike Exp $";
@


2.3
log
@Made explicit that termcap.h to be used is the local version
@
text
@d4 1
a4 1
 * $Revision: 2.2 $
d7 3
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_draw.c,v 2.2 91/08/30 17:54:31 mike Exp $";
d74 1
a74 1
	register char	c;
@


2.2
log
@Changed #include directives to distinguish between local and system header
files.
@
text
@d4 1
a4 1
 * $Revision: 2.1 $
d7 4
d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_draw.c,v 2.1 91/08/30 17:49:04 mike Exp $";
d35 1
a35 1
#include <termcap.h>
d271 1
a271 1
#include <termcap.h>
@


2.1
log
@Paul Stay mods for ANSI C
@
text
@d4 1
a4 1
 * $Revision: 2.0 $
d7 3
d18 1
a18 1
static char RCSid[] = "@@(#)$Header: jove_draw.c,v 2.0 84/12/26 16:45:54 dpk Exp $";
d29 1
a29 1
#include "jove.h"
d31 1
a31 1
#include "termcap.h"
d267 1
a267 1
#include "termcap.h"
@


2.0
log
@System as distributed to Berkeley 26 Dec 84
@
text
@d4 1
a4 1
 * $Revision: 1.2 $
d7 3
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: jove_draw.c,v 1.2 83/12/16 00:07:48 dpk BRL $";
d132 1
a132 1
	char	line[132];
d340 1
a340 1
		case CTL(G):
@


1.2
log
@Added distinctive RCS header
@
text
@d4 1
a4 1
 * $Revision$
d6 4
a9 1
 * $Log$
d12 1
a12 1
static char RCSid[] = "@@(#)$Header$";
d74 28
a105 1

a132 1
	char	*printf();			/* Forward reference */
d145 1
a145 1
	i_set(lineno, 0);
a146 10
#ifdef INCONSISTENT
	if (w->w_next != fwind)
		strcop(lp, "--- ");
	else
		strcop(lp, "    ");
#endif
	strcop(lp, "--- ");

	strcop(lp, "JOVE (");

d162 6
a167 6
	--lp;	/* strcop leaves lp after the null */
#ifdef INCONSISTENT
	if (w->w_next != fwind)
#endif
		while (lp < &line[CO - 2])
			*lp++ = '-';
d169 3
d175 2
a176 1
	if( SO ) putpad( SE, 1 );
d186 2
d190 1
a190 2
	if (bp->b_zero != 0)
	    ++i;
a251 96
int	VisBell = 0;	/* If set, use visible bell if available */
int	RingBell = 0;	/* So if we have a lot of errors ...
			   ring the bell only ONCE */

rbell()
{
	RingBell++;
}

/* Jonathan Payne at Lincoln-Sudbury Regional High School 5-25-83

   format.c

   contains procedures that call _doprnt */

/* VARARGS2 */

format(buf, fmt, args)
char	*buf,
	*fmt;
int	*args;
{
	IOBUF	strbuf;

	strbuf.io_flag = 0;
	strbuf.io_base = strbuf.io_ptr = buf;
	strbuf.io_cnt = 32767;
	_doprnt(fmt, args, &strbuf);
	Putc('\0', &strbuf);
}

/* VARARGS1 */

char *
sprint(fmt, args)
char	*fmt;
{
	static char line[100];

	format(line, fmt, &args);
	return line;
}

/* VARARGS1 */

char *
printf(fmt, args)
char	*fmt;
{
	_doprnt(fmt, &args, &termout);
}

/* VARARGS2 */

char *
sprintf(str, fmt, args)
char	*str,
	*fmt;
{
	format(str, fmt, &args);
	return str;
}

/* VARARGS1 */

s_mess(fmt, args)
char	*fmt;
{
	if (Input)
		return;
	format(mesgbuf, fmt, &args);
	message(mesgbuf);
}

_strout(string, count, adjust, file, fillch)
register char *string;
register int count;
int adjust;
register IOBUF	*file;
{

	while (adjust < 0) {
		if (*string=='-' && fillch=='0') {
			Putc(*string++, file);
			count--;
		}
		Putc(fillch, file);
		adjust++;
	}
	while (--count >= 0)
		Putc(*string++, file);
	while (adjust) {
		Putc(fillch, file);
		adjust--;
	}
}
@


1.1
log
@Original 4.2 Distribution Source
@
text
@d2 11
@
