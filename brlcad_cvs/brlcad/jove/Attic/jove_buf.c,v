head	11.5;
access;
symbols
	ansi-20040405-merged:11.4
	postmerge-20040405-ansi:11.4
	premerge-20040404-ansi:11.4
	postmerge-autoconf:11.4
	autoconf-freeze:11.4
	premerge-autoconf:11.4
	ansi-20040316-freeze:11.4
	postmerge-20040315-windows:11.4
	premerge-20040315-windows:11.4
	windows-20040315-freeze:11.4
	autoconf-20031203:11.4
	autoconf-20031202:11.4
	autoconf-branch:11.4.0.12
	phong-branch:11.4.0.10
	photonmap-branch:11.4.0.8
	rel-6-1-DP:11.4
	windows-branch:11.4.0.6
	rel-6-0-2:11.4
	ansi-branch:11.4.0.4
	rel-6-0-1-branch:11.4.0.2
	hartley-6-0-post:11.4
	hartley-6-0-pre:11.4
	rel-6-0-1:11.4
	rel-6-0:11.4
	rel-5-4:11.3
	offsite-5-3-pre:11.4
	rel-5-3:11.3
	rel-5-2:11.3
	rel-5-1-branch:11.3.0.2
	rel-5-1:11.3
	rel-5-0:11.3
	rel-5-0-beta:11.3
	rel-4-5:11.3
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:2.0
	rel-3-0:2.0
	rel-2-3:2.0
	rel-2-0:2.0
	rel-1-24:2.0
	rel-1-20:2.0
	rel-1-10:2.0
	rt-2:2.0
	rt:1.2;
locks; strict;
comment	@ * @;


11.5
date	2004.05.21.17.48.31;	author morrison;	state dead;
branches;
next	11.4;

11.4
date	2000.08.24.23.12.22;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	97.01.03.13.32.22;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.06.21.03.38.49;	author gwyn;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.35.08;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.09.17.04.57.35;	author butler;	state Exp;
branches;
next	10.2;

10.2
date	93.10.26.03.40.29;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.53.54;	author mike;	state Rel4_0;
branches;
next	2.3;

2.3
date	91.08.30.18.59.33;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	91.08.30.17.54.09;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	91.08.30.17.48.53;	author mike;	state Exp;
branches;
next	2.0;

2.0
date	84.12.26.16.45.00;	author dpk;	state Exp;
branches;
next	1.2;

1.2
date	83.12.16.00.07.12;	author dpk;	state BRL;
branches;
next	1.1;

1.1
date	83.12.16.00.07.08;	author dpk;	state Exp;
branches;
next	;


desc
@Jove is an EMACS like screen editor which will fit on 11's and Vaxen
@


11.5
log
@moved to src/other/jove/
@
text
@/*
 *			J O V E _ B U F . C
 *
 * $Revision: 11.4 $
 *
 * $Log: jove_buf.c,v $
 * Revision 11.4  2000/08/24 23:12:22  mike
 *
 * lint, RCSid
 *
 * Revision 11.3  1997/01/03  13:32:22  jra
 * Mods for Irix 6.2.
 *
 * Revision 11.2  1995/06/21  03:38:49  gwyn
 * Eliminated trailing blanks.
 * Changed memcpy calls back to bcopy.
 *
 * Revision 11.1  95/01/04  10:35:08  mike
 * Release_4.4
 *
 * Revision 10.3  94/09/17  04:57:35  butler
 * changed all calls to bcopy to be memcpy instead.  Useful for Solaris 5.2
 *
 * Revision 10.2  1993/10/26  03:40:29  mike
 * ANSI C
 *
 * Revision 10.1  91/10/12  06:53:54  mike
 * Release_4.0
 *
 * Revision 2.3  91/08/30  18:59:33  mike
 * Modifications for clean compilation on the XMP
 *
 * Revision 2.2  91/08/30  17:54:09  mike
 * Changed #include directives to distinguish between local and system header
 * files.
 *
 * Revision 2.1  91/08/30  17:48:53  mike
 * Paul Stay mods for ANSI C
 *
 * Revision 2.0  84/12/26  16:45:00  dpk
 * System as distributed to Berkeley 26 Dec 84
 *
 * Revision 1.2  83/12/16  00:07:12  dpk
 * Added distinctive RCS header
 *
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/jove/jove_buf.c,v 11.4 2000/08/24 23:12:22 mike Exp $";
#endif

/* Jonathan Payne at Lincoln-Sudbury Regional High School 5-25-83

   jove_buf.c

   Contains commands that deal with creating, selecting, killing and
   listing buffers.  (And find-file) */

#include "./jove.h"

#include <sys/types.h>
#include <sys/stat.h>

char	*Mainbuf = "Main";

int	flen,
	blen;
BUFFER	*lastbuf = 0;	/* Last buffer we were in so we have a default
			 * buffer during a select buffer.
			 */
void	SetBuf();

char *
filename(bp)
BUFFER	*bp;
{
	return bp->b_fname ? bp->b_fname : "[No file]";
}

char *
itoa(num)
{
	static char	line[10];

	sprintf(line, "%d", num);
	return line;
}

int
AllInts(str)
register char	*str;
{
	register char	c;

	while ((c = *str++) >= '0' && c <= '9')
		;
	return c == 0;
}

BUFFER *
buf_exists(name)
char	*name;
{
	BUFFER	*bp;
	int	n = 0;

	if (name == 0)
		return 0;

	for (bp = world; bp; bp = bp->b_next)
		if (bp->b_zero != 0 && bp->b_name != 0 &&
					strcmp(bp->b_name, name) == 0)
			return bp;

	/* Doesn't match any names.  Try for a buffer number */

	if (AllInts(name) && (n = atoi(name)) > 0) {
		for (bp = world; bp; bp = bp->b_next) {
			if (bp == 0)
				break;
			if (bp->b_zero == 0)
				continue;
			if (--n == 0)
				return (bp);
		}
		return bp;
	}

	return 0;
}

BUFFER *
file_exists(fname)
char	*fname;
{
	struct stat	stbuf;
	BUFFER	*bp;

	if (fname) {
		if (stat(fname, &stbuf) == -1)
			stbuf.st_ino = -1;
		for (bp = world; bp; bp = bp->b_next) {
			if (bp->b_zero == 0)
				continue;
			if ((bp->b_ino != -1)
			  && (bp->b_ino == stbuf.st_ino)
			  && (bp->b_dev == stbuf.st_dev))
				return bp;
			if (bp->b_fname == 0)
				continue;
			if (strcmp(bp->b_fname, fname) == 0)
				return bp;
		}
	}
	return 0;
}

int
max(a, b)
int a, b;
{
	return a > b ? a : b;
}

BUFFER *
findbuf()
{
	BUFFER	*bp,
		*lastbp;

	lastbp = 0;
	for (bp = world; bp; lastbp = bp, bp = bp->b_next)
		if (bp->b_zero == 0)
			break;
	if (bp == 0) {
		bp = (BUFFER *) emalloc(sizeof (BUFFER));
		if (lastbp)
			lastbp->b_next = bp;
		else
			world = bp;
		bp->b_zero = 0;
		bp->b_next = 0;
	}
	return bp;
}

extern int
	OverWrite(),
	TextInsert(),
	SelfInsert(),
	DoParen(),
	CTab(),
	LineAI(),
	Newline();

void
setfuncs(flags)
int	*flags;
{
	UpdModLine++;	/* Kludge ... but speeds things up considerably */
	bcopy(flags, curbuf->b_flags, NFLAGS*sizeof(int));

	if (IsFlagSet(flags, OVERWRITE))
		BindInserts(OverWrite);
	else if (IsFlagSet(flags, TEXTFILL))
		BindInserts(TextInsert);
	else
		BindInserts(SelfInsert);
	if (IsFlagSet(flags, CMODE) || IsFlagSet(flags, MATCHING)) {
		BindFunc(mainmap, '}', DoParen);
		BindFunc(mainmap, ')', DoParen);
	} else {
		BindFunc(mainmap, '}', SelfInsert);
		BindFunc(mainmap, ')', SelfInsert);
	}
	if (IsFlagSet(flags, CMODE))
		BindFunc(mainmap, CTL('I'), CTab);
	else
		BindFunc(mainmap, CTL('I'), SelfInsert);
	if (IsFlagSet(flags, AUTOIND))
		BindFunc(mainmap, CTL('M'), LineAI);
	else
		BindFunc(mainmap, CTL('M'), Newline);
}

void
noflags(f)
register int	*f;
{
	register int	i = NFLAGS;

	while (i--)
		*f++ = 0;
}

void
setflags(buf)
BUFFER	*buf;
{
	bcopy(origflags, buf->b_flags, NFLAGS*sizeof(int));
	SetUnmodified(buf);
	ClrScratch(buf);	/* Normal until proven SCRATCHBUF */
}

BUFFER *
mak_buf(fname, bname)
char	*fname,
	*bname;
{
	register BUFFER	*freebuf;
	register int	i;

	freebuf = buf_exists(bname);
	if (!freebuf) {
		freebuf = findbuf();
		freebuf->b_fname = freebuf->b_name = 0;
		setbname(freebuf, bname);
		setfname(freebuf, fname);
		set_ino(freebuf);
		freebuf->b_marks = 0;
		freebuf->b_themark = 0;		/* Index into markring */
		freebuf->b_status = 0;
		for (i = 0; i < NMARKS; i++)
			freebuf->b_markring[i] = 0;
		/* No marks yet */
		setflags(freebuf);
		freebuf->b_zero = 0;
		initlist(freebuf);
	}
	return freebuf;
}

char *
ralloc(obj, size)
char	*obj;
size_t size;
{
	char	*new;
	if (obj)
		new = realloc(obj, (unsigned) size);
	else
		new = 0;
	if (new == 0 || !obj)
		new = emalloc(size);
	if (new == 0)
		error("No memory in ralloc");
	return new;
}

void
setbname(bp, name)
BUFFER	*bp;
char	*name;
{
	UpdModLine++;	/* Kludge ... but speeds things up considerably */
	if (name) {
		bp->b_name = ralloc(bp->b_name, strlen(name) + 1);
		strcpy(bp->b_name, name);
	} else
		bp->b_name = 0;
}

void
setfname(bp, name)
BUFFER	*bp;
char	*name;
{
	UpdModLine++;	/* Kludge ... but speeds things up considerably */
	if (name) {
		bp->b_fname = ralloc(bp->b_fname, strlen(name) + 1);
		strcpy(bp->b_fname, name);
	} else
		bp->b_fname = 0;
}

void
set_ino(bp)
BUFFER	*bp;
{
	struct stat	stbuf;

	if (bp->b_fname && stat(bp->b_fname, &stbuf) == -1)
		bp->b_ino = -1;
	else {
		bp->b_ino = stbuf.st_ino;
		bp->b_dev = stbuf.st_dev;
	}
}

/* Find the file `fname' into buf and put in in window `wp' */

BUFFER *
do_find(wp, fname)
WINDOW	*wp;
char	*fname;
{
	BUFFER	*oldb = curbuf,
		*bp;

	oldb = curbuf;
	bp = file_exists(fname);
	if (bp == 0) {
		bp = mak_buf(fname, (char *) 0);
		bufname(bp);
		SetBuf(bp);
		read_file(bp->b_fname);
		SetBuf(oldb);
	}
	if (wp)
		tiewind(wp, bp);
	return bp;
}

void
tiewind(wp, bp)
WINDOW	*wp;
BUFFER	*bp;
{
	wp->w_line = bp->b_dot;
	wp->w_char = bp->b_char;
	if (wp->w_bufp != bp) {
		wp->w_bufp = bp;
		CalcTop(wp);
	}
}

void
FindFile()
{
	char	*name;

	name = ask(curbuf->b_fname, FuncName());
	lastbuf = curbuf;
	SetBuf(do_find(curwind, name));
}

void
SetBuf(newbuf)
BUFFER	*newbuf;
{
	if (newbuf == curbuf)
		return;
	lastbuf = curbuf;
	bcopy(globflags, curbuf->b_flags, NFLAGS*sizeof(int));
	lsave();
	curbuf = newbuf;
	getDOT();
	bcopy(curbuf->b_flags, globflags, NFLAGS*sizeof(int));
	setfuncs(curbuf->b_flags);
}

void
SelBuf()
{
	char	*bname;

	bname = ask(lastbuf ? lastbuf->b_name : 0, FuncName());
	SetBuf(do_select(curwind, bname));
}

BUFFER *
do_select(wp, name)
WINDOW	*wp;
char	*name;
{
	BUFFER	*new;

	new = mak_buf((char *) 0, name);
	if (wp)
		tiewind(wp, new);
	return new;
}

void
defb_wind(bp)
BUFFER *bp;
{
	WINDOW	*wp = fwind;

	do {
		if (wp->w_bufp == bp) {
			if (bp == curbuf)
				ignore(do_select(wp, Mainbuf));
			else {
				WINDOW	*save = wp->w_next;

				del_wind(wp);
				wp = save->w_prev;
			}
		}
		wp = wp->w_next;
	} while (wp != fwind);
}

BUFFER *
AskBuf(prompt)
char	*prompt;
{
	register BUFFER	*delbuf;
	register char	*bname;

	bname = ask(curbuf->b_name, prompt);
	delbuf = buf_exists(bname);
	if (delbuf == 0) {
		complain("%s: no such buffer", bname);
		return delbuf;
	}

	/* You cannot delete "Main" */
	if (strcmp(delbuf->b_name, Mainbuf) == 0) {
		complain("You may not delete %s", Mainbuf);
		return 0;
	}
	if (IsModified(delbuf))
		confirm("%s modified, are you sure? ", bname);
	return delbuf;
}

void
BufErase()
{
	BUFFER	*delbuf;

	if (delbuf = AskBuf(FuncName()))
		initlist(delbuf);
	SetUnmodified(delbuf);
}

void
BufKill()
{
	BUFFER	*delbuf;

	if ((delbuf = AskBuf(FuncName())) == 0)
		return;
	defb_wind(delbuf);			/* Erase the windows */
	if (curbuf == delbuf)
		SetBuf(curwind->w_bufp);
	lfreelist(delbuf->b_zero);
	delbuf->b_zero = 0;
	delbuf->b_name = (char *)(-1);
	delbuf->b_fname = (char *)(-1);
	delbuf->b_ino = (-1);
	if (delbuf == lastbuf)
		lastbuf = curbuf;
	UpdModLine++;				/* Update buffer numbers */
}

void
BufList()
{
	char	format[40];
	int	bcount = 1;		/* To give each buffer a number */
	BUFFER	*bp;
	int	what;

	b_format(format);

	if (UseBuffers) {
		TellWBuffers("Buffer list", 0);
		SetScratch(curwind->w_bufp);
	} else
		TellWScreen(0);

	ignore(DoTell(sprint(format, "NO", "Buffer-type", "File-name", "Buffer-name", "")));
	ignore(DoTell(sprint(format, "--", "-----------", "---------", "-----------", "")));
	for (bp = world; bp; bp = bp->b_next) {
		if (bp->b_zero == 0)
			continue;
		what = DoTell(sprint(format, itoa(bcount++),
					IsScratch(bp) ?	"SCRATCH" : "FILE",
					filename(bp),
					bp->b_name,
					bufmod(bp)));
		if (what == ABORT || what == STOP)
			break;
	}
	if (UseBuffers) {
		Bof();		/* Go to the beginning of the file */
		NotModified();
	}
	StopTelling();
}

void
b_format(fmt)
char	*fmt;
{
	BUFFER	*bp;

	flen = 9;
	blen = 11;

	for (bp = world; bp; bp = bp->b_next) {
		if (bp->b_zero == 0)
			continue;
		flen = max(flen, (int)(bp->b_fname ? strlen(bp->b_fname) : 0));
		blen = max(blen, (int)strlen(bp->b_name));
	}
	ignore(sprintf(fmt, " %%-4s %%-11s  %%-%ds   %%-%ds  %%s", flen, blen));
}
@


11.4
log
@
lint, RCSid
@
text
@d4 1
a4 1
 * $Revision: 11.3 $
d7 4
d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/jove/jove_buf.c,v 11.3 1997/01/03 13:32:22 jra Exp $";
@


11.3
log
@Mods for Irix 6.2.
@
text
@d4 1
a4 1
 * $Revision: 11.2 $
d7 3
d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_buf.c,v 11.2 1995/06/21 03:38:49 gwyn Exp jra $";
d84 1
d153 1
@


11.2
log
@Eliminated trailing blanks.
Changed memcpy calls back to bcopy.
@
text
@d4 1
a4 1
 * $Revision: 11.1 $
d6 5
a10 1
 * $Log:	jove_buf.c,v $
d41 1
a41 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_buf.c,v 11.1 95/01/04 10:35:08 mike Rel4_4 $";
d186 1
d216 1
d226 1
d266 1
d280 1
d293 1
d306 1
d344 1
d357 1
d382 1
d404 1
d449 1
d479 1
d515 1
d527 2
a528 2
		flen = max(flen, (bp->b_fname ? strlen(bp->b_fname) : 0));
		blen = max(blen, strlen(bp->b_name));
@


11.1
log
@Release_4.4
@
text
@d2 1
a2 1
 *			J O V E _ B U F . C 
d4 1
a4 1
 * $Revision: 10.3 $
d7 3
d12 1
a12 1
 * 
d18 1
a18 1
 * 
d21 1
a21 1
 * 
d25 1
a25 1
 * 
d28 1
a28 1
 * 
d31 1
a31 1
 * 
d34 1
a34 1
 * 
d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_buf.c,v 10.3 94/09/17 04:57:35 butler Exp $";
d43 1
a43 1
   
d186 1
a186 1
	memcpy(curbuf->b_flags, flags, NFLAGS*sizeof(int));
d223 1
a223 1
	memcpy(buf->b_flags, origflags, NFLAGS*sizeof(int));
d361 1
a361 1
	memcpy(curbuf->b_flags, globflags, NFLAGS*sizeof(int));
d365 1
a365 1
	memcpy( globflags, curbuf->b_flags, NFLAGS*sizeof(int));
d367 1
a367 1
}	
d405 1
a405 1
		}				
@


10.3
log
@changed all calls to bcopy to be memcpy instead.  Useful for Solaris 5.2
@
text
@d4 1
a4 1
 * $Revision: 10.2 $
d6 4
a9 1
 * $Log: jove_buf.c,v $
d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_buf.c,v 10.2 1993/10/26 03:40:29 mike Exp butler $";
@


10.2
log
@ANSI C
@
text
@d4 1
a4 1
 * $Revision: 10.1 $
d6 4
a9 1
 * $Log:	jove_buf.c,v $
d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_buf.c,v 10.1 91/10/12 06:53:54 mike Rel4_0 Locker: mike $";
d180 1
a180 1
	bcopy(flags, curbuf->b_flags, NFLAGS*sizeof(int));
d217 1
a217 1
	bcopy(origflags, buf->b_flags, NFLAGS*sizeof(int));
d355 1
a355 1
	bcopy(globflags, curbuf->b_flags, NFLAGS*sizeof(int));
d359 1
a359 1
	bcopy(curbuf->b_flags, globflags, NFLAGS*sizeof(int));
@


10.1
log
@Release_4.0
@
text
@d4 1
a4 1
 * $Revision: 2.3 $
d7 3
d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_buf.c,v 2.3 91/08/30 18:59:33 mike Exp $";
d50 1
d345 1
d434 1
@


2.3
log
@Modifications for clean compilation on the XMP
@
text
@d4 1
a4 1
 * $Revision: 2.2 $
d7 3
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_buf.c,v 2.2 91/08/30 17:54:09 mike Exp $";
@


2.2
log
@Changed #include directives to distinguish between local and system header
files.
@
text
@d4 1
a4 1
 * $Revision: 2.1 $
d7 4
d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_buf.c,v 2.1 91/08/30 17:48:53 mike Exp $";
d76 1
a76 1
	int	n;
d247 2
@


2.1
log
@Paul Stay mods for ANSI C
@
text
@d4 1
a4 1
 * $Revision: 2.0 $
d7 3
d18 1
a18 1
static char RCSid[] = "@@(#)$Header: jove_buf.c,v 2.0 84/12/26 16:45:00 dpk Exp $";
d28 1
a28 1
#include "jove.h"
@


2.0
log
@System as distributed to Berkeley 26 Dec 84
@
text
@d4 1
a4 1
 * $Revision: 1.2 $
d7 3
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: jove_buf.c,v 1.2 83/12/16 00:07:12 dpk BRL $";
d179 1
a179 1
		BindFunc(mainmap, CTL(I), CTab);
d181 1
a181 1
		BindFunc(mainmap, CTL(I), SelfInsert);
d183 1
a183 1
		BindFunc(mainmap, CTL(M), LineAI);
d185 1
a185 1
		BindFunc(mainmap, CTL(M), Newline);
@


1.2
log
@Added distinctive RCS header
@
text
@d4 1
a4 1
 * $Revision$
d6 4
a9 1
 * $Log$
d12 1
a12 1
static char RCSid[] = "@@(#)$Header$";
d47 2
a48 1
	return sprintf(line,"%d", num);
d79 1
a79 1
		for (bp = world; n - 1 > 0; ) {
d84 2
a85 2
			bp = bp->b_next;
			--n;
d106 3
a108 2
/****** What is this?   BUG??? (next two lines) **********/
			if ((bp->b_ino != -1) && (bp->b_ino == stbuf.st_ino))
d160 1
a160 1
	copy_n(curbuf->b_flags, flags, NFLAGS);
d197 1
a197 1
	copy_n(buf->b_flags, origflags, NFLAGS);
d199 1
a199 1
	buf->b_type = NORMALBUF;	/* Normal until proven SCRATCHBUF */
d219 1
d275 1
a275 1
	else
d277 2
d332 1
a332 1
	copy_n(curbuf->b_flags, globflags, NFLAGS);
d336 1
a336 1
	copy_n(globflags, curbuf->b_flags, NFLAGS);
a344 1
	lastbuf = curbuf;
d385 2
a386 2
	BUFFER	*delbuf;
	char	*bname;
a388 2
	if (strcmp(bname, Mainbuf) == 0)
		return 0;
d390 1
a390 1
	if (delbuf == 0)
d392 9
a400 1
	if (delbuf->b_modified)
d420 1
a420 1
	defb_wind(delbuf);
d425 3
d430 1
d444 1
a444 1
		curwind->w_bufp->b_type = SCRATCHBUF;
d454 1
a454 2
					bp->b_type == SCRATCHBUF ?
						"SCRATCH" : "FILE",
d477 2
@


1.1
log
@Original 4.2 Distribution Source
@
text
@d1 11
@
