head	11.6;
access;
symbols
	ansi-20040405-merged:11.5
	postmerge-20040405-ansi:11.5
	premerge-20040404-ansi:11.5
	postmerge-autoconf:11.5
	autoconf-freeze:11.5
	premerge-autoconf:11.5
	ansi-20040316-freeze:11.5
	postmerge-20040315-windows:11.5
	premerge-20040315-windows:11.5
	windows-20040315-freeze:11.5
	autoconf-20031203:11.5
	autoconf-20031202:11.5
	autoconf-branch:11.5.0.12
	phong-branch:11.5.0.10
	photonmap-branch:11.5.0.8
	rel-6-1-DP:11.5
	windows-branch:11.5.0.6
	rel-6-0-2:11.5
	ansi-branch:11.5.0.4
	rel-6-0-1-branch:11.5.0.2
	hartley-6-0-post:11.5
	hartley-6-0-pre:11.5
	rel-6-0-1:11.5
	rel-6-0:11.5
	rel-5-4:11.4
	offsite-5-3-pre:11.5
	rel-5-3:11.4
	rel-5-2:11.4
	rel-5-1-branch:11.4.0.2
	rel-5-1:11.4
	rel-5-0:11.4
	rel-5-0-beta:11.4
	rel-4-5:11.3
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:2.0
	rel-3-0:2.0
	rel-2-3:2.0
	rel-2-0:2.0
	rel-1-24:2.0
	rel-1-20:2.0
	rel-1-10:2.0
	rt-2:2.0
	rt:1.2;
locks; strict;
comment	@ * @;


11.6
date	2004.05.21.17.48.32;	author morrison;	state dead;
branches;
next	11.5;

11.5
date	2000.08.24.23.12.23;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	98.08.23.00.45.53;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	97.01.03.17.42.17;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.06.21.03.41.04;	author gwyn;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.35.13;	author mike;	state Rel4_4;
branches;
next	10.4;

10.4
date	94.09.17.04.57.35;	author butler;	state Exp;
branches;
next	10.3;

10.3
date	93.12.10.04.25.54;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	93.10.26.03.47.08;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.53.58;	author mike;	state Rel4_0;
branches;
next	2.3;

2.3
date	91.08.30.19.41.36;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	91.08.30.17.54.33;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	91.08.30.17.49.06;	author mike;	state Exp;
branches;
next	2.0;

2.0
date	84.12.26.16.46.12;	author dpk;	state Exp;
branches;
next	1.2;

1.2
date	83.12.16.00.08.08;	author dpk;	state BRL;
branches;
next	1.1;

1.1
date	83.12.16.00.08.01;	author dpk;	state Exp;
branches;
next	;


desc
@Jove is an EMACS like screen editor which will fit on 11's and Vaxen
@


11.6
log
@moved to src/other/jove/
@
text
@/*
 *			J O V E _ F U N C S . C
 *
 * $Revision: 11.5 $
 *
 * $Log: jove_funcs.c,v $
 * Revision 11.5  2000/08/24 23:12:23  mike
 *
 * lint, RCSid
 *
 * Revision 11.4  1998/08/23  00:45:53  mike
 * xterm arrow keys use a different prefix than the regular vt100 ones.
 * Handle it.
 *
 * Revision 11.3  1997/01/03  17:42:17  jra
 * Mods for Irix 6.2
 *
 * Revision 11.2  1995/06/21  03:41:04  gwyn
 * Eliminated trailing blanks.
 * WriteMacs() now uses Dfltmode instead of hard-wired 0644.
 * Changed memcpy calls back to bcopy.
 *
 * Revision 11.1  95/01/04  10:35:13  mike
 * Release_4.4
 *
 * Revision 10.4  94/09/17  04:57:35  butler
 * changed all calls to bcopy to be memcpy instead.  Useful for Solaris 5.2
 *
 * Revision 10.3  1993/12/10  04:25:54  mike
 * Added FindCursorTag(), bound to M-t.
 *
 * Revision 10.2  93/10/26  03:47:08  mike
 * ANSI C
 *
 * Revision 10.1  91/10/12  06:53:58  mike
 * Release_4.0
 *
 * Revision 2.3  91/08/30  19:41:36  mike
 * Added ^Xe to run cake, like ^X^E runs make.
 *
 * Revision 2.2  91/08/30  17:54:33  mike
 * Changed #include directives to distinguish between local and system header
 * files.
 *
 * Revision 2.1  91/08/30  17:49:06  mike
 * Paul Stay mods for ANSI C
 *
 * Revision 2.0  84/12/26  16:46:12  dpk
 * System as distributed to Berkeley 26 Dec 84
 *
 * Revision 1.2  83/12/16  00:08:08  dpk
 * Added distinctive RCS header
 *
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/jove/jove_funcs.c,v 11.5 2000/08/24 23:12:23 mike Exp $";
#endif

/*
   Jonathan Payne at Lincoln-Sudbury Regional High School 4-19-83

   jove_funcs.c

   This is like the second half of jove_extend.c.  It was divided
   because the file was taking too long to compile ...
 */
#include "./jove.h"

extern	int Dfltmode;

static int	nfuncs = 0,
		nmacros = 0,
		nvars = 0;

struct function	functions[NFUNCS],	/* Wired functions */
		macros[NMACROS],	/* Macros */
		variables[NVARS];	/* Variables */

void
tmany(str)
char	*str;
{
	complain("too many %s", str);
}

void
DefFunc(name, func)
char	*name;
int	(*func)();
{
	if (nfuncs >= NFUNCS)
		tmany("functions");
	functions[nfuncs].f_name = name;
	functions[nfuncs].f.Func = func;
	functions[nfuncs].f_type = FUNCTION;
	nfuncs++;
}

void
DefVar(name, varptr)
char	*name;
int	*varptr;
{
	if (nvars >= NVARS)
		tmany("variables");
	variables[nvars].f_name = name;
	variables[nvars].f.Var = varptr;
	variables[nvars].f_type = VARIABLE;
	nvars++;
}

void
DefMac(name, macptr)
char	*name;
struct macro	*macptr;
{
	register int	i;

	for (i = 0; i < nmacros; i++)
		if (strcmp(macros[i].f_name, name) == 0) {
			macros[i].f.Macro = macptr;
			return;
		}

	if (nmacros > NVARS)
		tmany("macros");
	macros[nmacros].f_name = name;
	macros[nmacros].f.Macro = macptr;
	macros[nmacros].f_type = MACRO;
	nmacros++;
}

extern int
	EscPrefix(),
	CtlxPrefix(),
	AppReg(),
	Apropos(),
	Bparen(),
	BackWord(),
	Bof(),
	Bol(),
	Bos(),
	Bow(),
	BindAKey(),
	BindMac(),
	BufPos(),
	UnBound(),
	CasRegLower(),
	CasRegUpper(),
	CapChar(),
	CapWord(),
	LowWord(),
	UppWord(),
	ChrToOct(),
	ClAndRedraw(),
	MakeErrors(),
	CakeErrors(),
	CopyRegion(),
	CTab(),
	DelBlnkLines(),
	DelNChar(),
	DelNWord(),
	OneWindow(),
	DelPChar(),
	DelPWord(),
	DelReg(),
	DelWtSpace(),
	DelCurWindow(),
	KeyDesc(),
	DescCom(),
	Eof(),
	Eos(),
	Eow(),
	BufErase(),
	Extend(),
	RunMacro(),
	Leave(),
	RegToShell(),
	FindFile(),
	WindFind(),
	FindTag(),
	FindCursorTag(),
	ToIndent(),
	Fparen(),
	ForWord(),
	FourTime(),
	GoLine(),
	GrowWindow(),
	IncFSearch(),
	IncRSearch(),
	InsFile(),
	Justify(),
	BufKill(),
	KillEOL(),
	BufList(),
	NotModified(),
	Newline(),
	LineAI(),
	NextPage(),
	NextWindow(),
	OverWrite(),
	PopMark(),
	PageNWind(),
	DoParen(),
	CParse(),
	LintParse(),
	PauseJove(),	/* Same as SubShell if no Job-Control */
	SubShell(),
	PrevPage(),
	PrevWindow(),
	QRepSearch(),
	QuotChar(),
	ReadFile(),
	RedrawDisplay(),
	ReInitTTY(),
	RepSearch(),
	DownScroll(),
	UpScroll(),
	ForSearch(),
	RevSearch(),
	SelBuf(),
	SelfInsert(),
	SetVar(),
	SetMark(),
	ShellCom(),
	ShToBuf(),
	ShrWindow(),
	Source(),
	SpellCom(),
	SplitWind(),
	StrLength(),
	TextInsert(),
	TransChar(),
	UnBound(),
	VtKeys(),
	SaveFile(),
	WtModBuf(),
	WriteFile(),
	WrtReg(),
	Yank(),
	YankPop(),
	PrVar(),
	SetQchars(),
	WNumLines();

void
InitFuncs()
{
	DefFunc("Prefix-1", EscPrefix);
	DefFunc("Prefix-2", CtlxPrefix);
	DefFunc("append-region", AppReg);
	DefFunc("apropos", Apropos);
	DefFunc("backward-char", (int (*)())BackChar);
	DefFunc("backward-paren", Bparen);
	DefFunc("backward-word", BackWord);
	DefFunc("beginning-of-file", Bof);
	DefFunc("beginning-of-line", Bol);
	DefFunc("beginning-of-sentence", Bos);
	DefFunc("beginning-of-window", Bow);
	DefFunc("bind-to-key", BindAKey);
	DefFunc("bind-macro-to-key", BindMac);
	DefFunc("buffer-position", BufPos);
	DefFunc("case-char-upper", CapChar);
	DefFunc("case-region-lower", CasRegLower);
	DefFunc("case-region-upper", CasRegUpper);
	DefFunc("case-word-capitalize", CapWord);
	DefFunc("case-word-lower", LowWord);
	DefFunc("case-word-upper", UppWord);
	DefFunc("char-to-octal-insert", ChrToOct);
	DefFunc("clear-and-redraw", ClAndRedraw);
	DefFunc("make", MakeErrors);
	DefFunc("cake", CakeErrors);
	DefFunc("copy-region", CopyRegion);
	DefFunc("c-tab", CTab);
	DefFunc("delete-blank-lines-around-point", DelBlnkLines);
	DefFunc("delete-next-char", DelNChar);
	DefFunc("delete-next-word", DelNWord);
	DefFunc("delete-other-windows", OneWindow);
	DefFunc("delete-previous-char", DelPChar);
	DefFunc("delete-previous-word", DelPWord);
	DefFunc("delete-to-killbuffer", DelReg);
	DefFunc("delete-white-space", DelWtSpace);
	DefFunc("delete-current-window", DelCurWindow);
	DefFunc("describe-key", KeyDesc);
	DefFunc("describe-command", DescCom);
	DefFunc("end-of-file", Eof);
	DefFunc("end-of-line", (int (*)())Eol);
	DefFunc("end-of-sentence", Eos);
	DefFunc("end-of-window", Eow);
	DefFunc("erase-buffer", BufErase);
	DefFunc("exchange-point-and-mark", (int (*)())PtToMark);
	DefFunc("execute-extended-command", Extend);
	DefFunc("execute-keyboard-macro", (int (*)())ExecMacro);
	DefFunc("execute-macro", RunMacro);
	DefFunc("exit-jove", Leave);
	DefFunc("filter-region", RegToShell);
	DefFunc("find-file", FindFile);
	DefFunc("find-file-in-other-window", WindFind);
	DefFunc("find-tag", FindTag);
	DefFunc("find-cursor-tag", FindCursorTag);
	DefFunc("first-non-blank", ToIndent);
	DefFunc("forward-char", (int (*)())ForChar);
	DefFunc("forward-paren", Fparen);
	DefFunc("forward-word", ForWord);
	DefFunc("four-times", FourTime);
	DefFunc("goto-line", GoLine);
	DefFunc("grow-window", GrowWindow);
	DefFunc("i-search-forward", IncFSearch);
	DefFunc("i-search-reverse", IncRSearch);
	DefFunc("insert-file", InsFile);
	DefFunc("init-bindings", (int (*)())InitBindings);
	DefFunc("justify-paragraph", Justify);
	DefFunc("kill-buffer", BufKill);
	DefFunc("kill-to-end-of-line", KillEOL);
	DefFunc("list-buffers", BufList);
	DefFunc("make-buffer-unmodified", NotModified);
	DefFunc("name-keyboard-macro", (int (*)())NameMac);
	DefFunc("newline", Newline);
	DefFunc("newline-and-backup", (int (*)())OpenLine);
	DefFunc("newline-and-indent", LineAI);
	DefFunc("next-error", (int (*)())NextError);
	DefFunc("next-line", (int (*)())NextLine);
	DefFunc("next-page", NextPage);
	DefFunc("next-window", NextWindow);
	DefFunc("number-lines-in-window", WNumLines);
	DefFunc("replace-char", OverWrite);
	DefFunc("page-next-window", PageNWind);
	DefFunc("paren-flash", DoParen);
	DefFunc("parse-C-errors", CParse);
	DefFunc("parse-LINT-errors", LintParse);
	DefFunc("pause-jove", PauseJove);
	DefFunc("pop-mark", PopMark);
	DefFunc("previous-line", (int (*)())PrevLine);
	DefFunc("previous-page", PrevPage);
	DefFunc("previous-window", PrevWindow);
	DefFunc("print", PrVar);
	DefFunc("query-replace-search", QRepSearch);
	DefFunc("quote-char", QuotChar);
	DefFunc("read-file", ReadFile);
	DefFunc("read-macros-from-file", (int (*)())ReadMacs);
	DefFunc("redraw-display", RedrawDisplay);
	DefFunc("reinitialize-terminal", ReInitTTY);
	DefFunc("replace-search", RepSearch);
	DefFunc("ring-the-bell", (int (*)())Beep);
	DefFunc("scroll-down", DownScroll);
	DefFunc("scroll-up", UpScroll);
	DefFunc("search-forward", ForSearch);
	DefFunc("search-reverse", RevSearch);
	DefFunc("select-buffer", SelBuf);
	DefFunc("self-insert", SelfInsert);
	DefFunc("set", SetVar);
	DefFunc("set-mark", SetMark);
	DefFunc("set-quote-characters", SetQchars);
	DefFunc("shell-command", ShellCom);
	DefFunc("shell-command-to-buffer", ShToBuf);
	DefFunc("shrink-window", ShrWindow);
	DefFunc("source", Source);
	DefFunc("spell-buffer", SpellCom);
	DefFunc("split-current-window", SplitWind);
	DefFunc("start-remembering", (int (*)())Remember);
	DefFunc("stop-remembering", (int (*)())Forget);		/* Not bad */
	DefFunc("string-length", StrLength);
	DefFunc("sub-shell", SubShell);
	DefFunc("suspend-jove", PauseJove);
	DefFunc("text-insert", TextInsert);
	DefFunc("transpose-chars", TransChar);
	DefFunc("unbound", UnBound);
	DefFunc("vt100-arrow-keys", VtKeys);
	DefFunc("write-current-file", SaveFile);
	DefFunc("write-macros-to-file", (int (*)())WriteMacs);
	DefFunc("write-modified-files", WtModBuf);
	DefFunc("write-named-file", WriteFile);
	DefFunc("write-region", WrtReg);
	DefFunc("yank", Yank);
	DefFunc("yank-pop", YankPop);
	DefFunc((char *) 0, (int (*)()) 0);

	DefVar("allow-^S-and-^Q", &OKXonXoff);
	DefVar("auto-indent", &globflags[AUTOIND]);
	DefVar("backup-files", &BackupFiles);
	DefVar("c-mode", &globflags[CMODE]);
	DefVar("case-independent-search", &globflags[CASEIND]);
	DefVar("fast-prompt", &FastPrompt);
	DefVar("files-should-end-with-newline", &EndWNewline);
	DefVar("internal-tabstop", &tabstop);
	DefVar("make-all-at-once", &MakeAll);
	DefVar("over-write", &globflags[OVERWRITE]);
	DefVar("physical-tabstop", &phystab);
	DefVar("regular-expressions", &globflags[MAGIC]);
	DefVar("right-margin", &RMargin);
	DefVar("show-match", &globflags[MATCHING]);
	DefVar("scroll-step", &ScrollStep);
	DefVar("text-fill", &globflags[TEXTFILL]);
	DefVar("use-temporary-buffers", &UseBuffers);
	DefVar("visible-bell", &VisBell);
	DefVar("write-files-on-make", &WtOnMk);
	DefVar((char *) 0, (int *) 0);
}


struct function *
FindFunc(func)
register int 	(*func)();
{
	register struct function	*fp;

  	for (fp = functions; fp->f_name; fp++)
		if (fp->f_type == FUNCTION && fp->f.Func == func)
			return fp;
	return 0;
}

void
BindFunc(map, letter, func)
struct function	*map[];
int	(*func)();
{
	static struct function	*fp = 0;

	if (!fp || fp->f.Func != func)
		fp = FindFunc(func);
	map[letter] = fp;
}

void
ZeroMap(map)
struct function	*map[];
{
	int	i;

	for (i = 0; i < 0200; i++)
		map[i] = 0;
}

void
BindInserts(func)
FUNC	func;
{
	register int	i;

	for (i = ' '; i < 0177; i++)
		BindFunc(mainmap, i, func);
	BindFunc(mainmap, CTL('I'), func);
}

void
InitBindings()
{
	/* Most just insert themselves */
	BindInserts(SelfInsert);

	BindFunc(mainmap, CTL('@@'), SetMark);
	BindFunc(mainmap, CTL('A'), Bol);
	BindFunc(mainmap, CTL('B'), (int (*)())BackChar);
	BindFunc(mainmap, CTL('C'), CapChar);
	BindFunc(mainmap, CTL('D'), DelNChar);
	BindFunc(mainmap, CTL('E'), (int (*)())Eol);
	BindFunc(mainmap, CTL('F'), (int (*)())ForChar);
	BindFunc(mainmap, CTL('G'), (int (*)())Beep);
	BindFunc(mainmap, CTL('H'), DelPChar);
	BindFunc(mainmap, CTL('I'), CTab);
	BindFunc(mainmap, CTL('J'), LineAI);
	BindFunc(mainmap, CTL('K'), KillEOL);
	BindFunc(mainmap, CTL('L'), ClAndRedraw);
	BindFunc(mainmap, CTL('M'), Newline);
	BindFunc(mainmap, CTL('N'), (int (*)())NextLine);
	BindFunc(mainmap, CTL('O'), (int (*)())OpenLine);
	BindFunc(mainmap, CTL('P'), (int (*)())PrevLine);
	BindFunc(mainmap, CTL('Q'), QuotChar);
	BindFunc(mainmap, CTL('^'), QuotChar);
	BindFunc(mainmap, CTL('R'), IncRSearch);
	BindFunc(mainmap, CTL('S'), IncFSearch);
	BindFunc(mainmap, CTL('\\'), IncFSearch);
	BindFunc(mainmap, CTL('T'), TransChar);
	BindFunc(mainmap, CTL('U'), FourTime);
	BindFunc(mainmap, CTL('V'), NextPage);
	BindFunc(mainmap, CTL('W'), DelPWord);
	BindFunc(mainmap, CTL('X'), CtlxPrefix);
	BindFunc(mainmap, CTL('Y'), Yank);
	BindFunc(mainmap, CTL('Z'), UpScroll);
	BindFunc(mainmap, CTL('['), EscPrefix);
	BindFunc(mainmap, ')', DoParen);
	BindFunc(mainmap, '}', DoParen);
	BindFunc(mainmap, '\177', DelPChar);

	/* Escape Prefix */

	BindFunc(pref1map, CTL('B'), Bparen);
	BindFunc(pref1map, CTL('E'), RepSearch);
	BindFunc(pref1map, CTL('F'), Fparen);
	BindFunc(pref1map, CTL('H'), DelPWord);
	BindFunc(pref1map, CTL('L'), RedrawDisplay);
	BindFunc(pref1map, CTL('V'), PageNWind);
	BindFunc(pref1map, '<', Bof);
	BindFunc(pref1map, '>', Eof);
	BindFunc(pref1map, '?', DescCom);
	BindFunc(pref1map, 'a', Bos);
	BindFunc(pref1map, 'A', Bos);
	BindFunc(pref1map, 'B', BackWord);
	BindFunc(pref1map, 'b', BackWord);
	BindFunc(pref1map, 'C', CapWord);
	BindFunc(pref1map, 'c', CapWord);
	BindFunc(pref1map, 'D', DelNWord);
	BindFunc(pref1map, 'd', DelNWord);
	BindFunc(pref1map, 'E', Eos);
	BindFunc(pref1map, 'e', Eos);
	BindFunc(pref1map, 'F', ForWord);
	BindFunc(pref1map, 'f', ForWord);
	BindFunc(pref1map, 'G', GoLine);
	BindFunc(pref1map, 'g', GoLine);
	BindFunc(pref1map, 'H', Apropos);
	BindFunc(pref1map, 'h', Apropos);
	BindFunc(pref1map, 'J', Justify);
	BindFunc(pref1map, 'j', Justify);
	BindFunc(pref1map, 'L', LowWord);
	BindFunc(pref1map, 'l', LowWord);
	BindFunc(pref1map, 'M', ToIndent);
	BindFunc(pref1map, 'm', ToIndent);
	BindFunc(pref1map, 'P', PauseJove);
	BindFunc(pref1map, 'p', PauseJove);
	BindFunc(pref1map, 'Q', QRepSearch);
	BindFunc(pref1map, 'q', QRepSearch);
	BindFunc(pref1map, 'R', RevSearch);
	BindFunc(pref1map, 'r', RevSearch);
	BindFunc(pref1map, 'S', ForSearch);
	BindFunc(pref1map, 's', ForSearch);
	BindFunc(pref1map, 'T', FindCursorTag);
	BindFunc(pref1map, 't', FindCursorTag);
	BindFunc(pref1map, 'U', UppWord);
	BindFunc(pref1map, 'u', UppWord);
	BindFunc(pref1map, 'V', PrevPage);
	BindFunc(pref1map, 'v', PrevPage);
	BindFunc(pref1map, 'W', CopyRegion);
	BindFunc(pref1map, 'w', CopyRegion);
	BindFunc(pref1map, 'X', Extend);
	BindFunc(pref1map, 'x', Extend);
	BindFunc(pref1map, 'Y', YankPop);
	BindFunc(pref1map, 'y', YankPop);
	BindFunc(pref1map, 'Z', DownScroll);
	BindFunc(pref1map, 'z', DownScroll);
	BindFunc(pref1map, '[', VtKeys);	/* Vt100 arrows */
	BindFunc(pref1map, 'O', VtKeys);	/* xterm "application" arrow keys */
	BindFunc(pref1map, '!', SubShell);
	BindFunc(pref1map, '\177', DelPWord);
	BindFunc(pref1map, '\\', DelWtSpace);
	BindFunc(pref1map, '~', NotModified);
	BindFunc(pref1map, '.', Eow);
	BindFunc(pref1map, ',', Bow);

	/* CTLX' 'prefix */

	ZeroMap(pref2map);
	BindFunc(pref2map, CTL('B'), BufList);
	BindFunc(pref2map, CTL('C'), Leave);
	BindFunc(pref2map, CTL('E'), MakeErrors);
	BindFunc(pref2map, CTL('F'), FindFile);
	BindFunc(pref2map, CTL('I'), InsFile);
	BindFunc(pref2map, CTL('K'), DelReg);
	BindFunc(pref2map, CTL('L'), CasRegLower);
	BindFunc(pref2map, CTL('M'), WtModBuf);
	BindFunc(pref2map, CTL('N'), (int (*)())NextError);
	BindFunc(pref2map, CTL('O'), DelBlnkLines);
	BindFunc(pref2map, CTL('R'), ReadFile);
	BindFunc(pref2map, CTL('S'), SaveFile);
	BindFunc(pref2map, CTL('T'), FindTag);
	BindFunc(pref2map, CTL('U'), CasRegUpper);
	BindFunc(pref2map, CTL('V'), FindFile);
	BindFunc(pref2map, CTL('W'), WriteFile);
	BindFunc(pref2map, CTL('X'), (int (*)())PtToMark);
	BindFunc(pref2map, CTL('\\'), SaveFile);
	BindFunc(pref2map, '?', KeyDesc);
	BindFunc(pref2map, '1', OneWindow);
	BindFunc(pref2map, '2', SplitWind);
	BindFunc(pref2map, '4', WindFind);
	BindFunc(pref2map, 'B', SelBuf);
	BindFunc(pref2map, 'b', SelBuf);
	BindFunc(pref2map, 'c', StrLength);
	BindFunc(pref2map, 'C', StrLength);
	BindFunc(pref2map, 'D', DelCurWindow);
	BindFunc(pref2map, 'd', DelCurWindow);
	BindFunc(pref2map, 'e', CakeErrors);
	BindFunc(pref2map, 'K', BufKill);
	BindFunc(pref2map, 'k', BufKill);
	BindFunc(pref2map, 'N', NextWindow);
	BindFunc(pref2map, 'n', NextWindow);
	BindFunc(pref2map, 'O', PrevWindow);
	BindFunc(pref2map, 'o', PrevWindow);
	BindFunc(pref2map, 'P', PrevWindow);
	BindFunc(pref2map, 'p', PrevWindow);
	BindFunc(pref2map, 'T', FindTag);
	BindFunc(pref2map, 't', FindTag);
	BindFunc(pref2map, '!', ShellCom);
	BindFunc(pref2map, '^', GrowWindow);
}

char *
FuncName()
{
	static char	func[60];

	sprintf(func, ": %s ", LastFunc->f_name);
	return func;
}

int	Interactive;	/* True when we invoke with the command handler? */

void
ExecFunc(fp, interactive)
struct function	*fp;
{
	int	bindinteract = Interactive;

	Interactive = interactive;
	LastFunc = fp;
	switch (fp->f_type) {
	case MACRO:
		DoMacro(fp->f.Macro);
		break;

	case FUNCTION:
		if (fp->f.Func)
			(*fp->f.Func)();
	}
	Interactive = bindinteract;
}

/* Can only define the keyboard macro.  IT can be renamed to another
 * macro.  If the keyboard macro is renamed, we make a copy of it.
 * The keyboard macro is ALWAYS the keyboard macro.
 *
 * We can't define or run the same macro recursively.  Each macro has
 * a bit saying whether or not it is currently being executed/defined.
 */

struct macro	KeyMacro;	/* Macro used for defining */

struct macro	*macstack[NMACROS];
int	stackp = 0;

char	*rem = "remember";

void
FixMacros()
{
	register int	i;
	struct macro	*mp;

	for (i = 0; macstack[i]; i++) {
		mp = macstack[i];
		macstack[i] = 0;
		mp->Flags = mp->Offset = 0;
	}
	stackp = -1;
	KeyMacro.Flags = KeyMacro.Offset = 0;
}

void
MacErr(name1, name2)
char	*name1,
	*name2;
{
	KeyMacro.Flags = 0;
	MacNolen(&KeyMacro);
	complain("Can't %s recursively; no longer %sing", name1, name2);
}

void
Remember()
{
	if (KeyMacro.Flags & DEFINE)
		MacErr(rem, rem);
	KeyMacro.Flags |= DEFINE;
	MacNolen(&KeyMacro);
	message("Remembering...");
}

/* Is `c' a prefix character */

PrefChar(c)
{
	return (mainmap[c]->f.Func == EscPrefix ||
			mainmap[c]->f.Func == CtlxPrefix);
}

void
Forget()
{
	char	*cp;
	struct macro	*m = &KeyMacro;

	if (m->Flags & DEFINE) {
		message("Keyboard macro defined");
		m->Flags &= ~DEFINE;
		cp = &m->Body[m->MacLength - 2];
		if (PrefChar(*cp))
			m->MacLength -= 2;
		else if (functions[*++cp].f.Func == (int (*)())Forget)
			m->MacLength--;
	}
}

void
ExecMacro()
{
	DoMacro(&KeyMacro);
}

void
DoMacro(mac)
struct macro	*mac;
{
	if (mac->Flags & DEFINE)
		MacErr("define", rem);
	if (mac->Flags & EXECUTE)
		MacErr("execute", "execut");
	if (++stackp >= NMACROS)
		complain("The impossible with macros just happened");
	macstack[stackp] = mac;
	mac->Offset = 0;
	mac->Ntimes = exp;
	mac->Flags |= EXECUTE;
}

char *
copystr(str)
char	*str;
{
	char	*val = emalloc(strlen(str) + 1);

	strcpy(val, str);
	return val;
}

struct macro *
macexists(name)
char	*name;
{
	register int	i;

	for (i = 0; i < nmacros; i++)
		if (strcmp(macros[i].f.Macro->Name, name) == 0)
			return macros[i].f.Macro;
	return 0;
}

void
NameMac()
{
	char	*name;
	struct macro	*m;

	if (KeyMacro.MacLength == 0)
		complain("Define it first!");
	if (KeyMacro.Flags & (DEFINE | EXECUTE))
		complain("Can't name while defining/executing");
	if ((m = macexists(name = ask((char *) 0, FuncName()))) == 0)
		m = (struct macro *) emalloc(sizeof *m);
	else {
		if (strcmp(name, KeyMacro.Name) == 0)
			complain("Can't name it that!");
		free(m->Name);
		free(m->Body);
	}
	name = copystr(name);
	*m = KeyMacro;				/* Copy the keyboard macro */
	m->Body = emalloc(m->MacBuflen);
	bcopy(KeyMacro.Body, m->Body, m->MacLength);
	m->Ntimes = m->Flags = m->Offset = 0;	/* At the beginning */
	m->Name = name;
	DefMac(name, m);
}

void
MacInit()
{
	SetMacro(&KeyMacro, "keyboard-macro");
	FixMacros();
}

void
MacNolen(m)
struct macro	*m;
{
	m->MacLength = m->Offset = 0;
}

void
SetMacro(m, name)
struct macro	*m;
char	*name;
{
	DefMac(name, m);	/* Try this before mallocing memory */
	MacNolen(m);
	m->Name = name;
	m->MacBuflen = 16;
	m->Body = emalloc(m->MacBuflen);
	m->Ntimes = m->Flags = 0;
}

void
MacPutc(c)
int	c;
{
	if (KeyMacro.MacLength >= KeyMacro.MacBuflen) {
		KeyMacro.Body = realloc(KeyMacro.Body, (unsigned) KeyMacro.MacLength + 16);
		if (KeyMacro.Body == 0)
			MacErr("malloc", rem);
		KeyMacro.MacBuflen += 16;
	}
	KeyMacro.Body[KeyMacro.Offset++] = c;
	KeyMacro.MacLength++;
}

MacGetc()
{
	if (macstack[stackp]->Offset == macstack[stackp]->MacLength) {
		macstack[stackp]->Offset = 0;
		if (--macstack[stackp]->Ntimes == 0) {
			macstack[stackp]->Flags &= ~EXECUTE;
			stackp--;
		}
		return (*Getchar)();
	}
	return macstack[stackp]->Body[macstack[stackp]->Offset++];
}

int
RunMacro()
{
	int	com;

	com = findcom(macros, FuncName());
	if (com < 0)
		return 0;
	DoMacro(macros[com].f.Macro);
	return 0;
}

void
WriteMacs()
{
	struct function	*mp;
	struct macro	*m;
	int	macfd,
		namelen;
	char	*file;

	file = ask((char *) 0, FuncName());
	if ((macfd = creat(file, Dfltmode)) == -1)
		complain(IOerr("create", file));
	/* Don't write the keyboard macro which is always the first */
	for (mp = &macros[1]; mp < &macros[NMACROS]; mp++) {
		m = mp->f.Macro;
		if (m == 0 || m->MacLength == 0)
			continue;
		ignore(write(macfd, (char *) &m->MacLength, sizeof m->MacLength));
		namelen = strlen(m->Name) + 1;	/* Including the null */
		ignore(write(macfd, (char *) &namelen, sizeof namelen));
		ignore(write(macfd, m->Name, namelen));
		ignore(write(macfd, m->Body, m->MacLength));
	}
	ignore(close(macfd));
}

void
ReadMacs()
{
	char	*file;
	struct macro	*m;
	int	macfd,
		namelen,
		bodylen;

	file = ask((char *) 0, FuncName());
	if ((macfd = open(file, 0)) == -1)
		complain(IOerr("open", file));

	while (nmacros < NMACROS) {
		if (read(macfd, (char *) &bodylen, sizeof m->MacLength) == 0)
			break;
		m = (struct macro *) emalloc (sizeof *m);
		m->MacLength = bodylen;
		m->MacBuflen = (m->MacLength + 16) & ~017;
		ignore(read(macfd, (char *) &namelen, sizeof namelen));
		m->Name = emalloc(namelen);
		ignore(read(macfd, m->Name, namelen));
		m->Body = emalloc(m->MacBuflen);
		ignore(read(macfd, m->Body, m->MacLength));
		DefMac(m->Name, m);
	}
	ignore(close(macfd));
}
@


11.5
log
@
lint, RCSid
@
text
@d4 1
a4 1
 * $Revision: 11.4 $
d7 4
d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/jove/jove_funcs.c,v 11.4 1998/08/23 00:45:53 mike Exp $";
@


11.4
log
@xterm arrow keys use a different prefix than the regular vt100 ones.
Handle it.
@
text
@d4 1
a4 1
 * $Revision: 11.3 $
d7 4
d52 1
a52 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/jove/jove_funcs.c,v 11.3 1997/01/03 17:42:17 jra Exp $";
@


11.3
log
@Mods for Irix 6.2
@
text
@d4 1
a4 1
 * $Revision: 11.2 $
d7 3
d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_funcs.c,v 11.2 1995/06/21 03:41:04 gwyn Exp $";
d534 1
@


11.2
log
@Eliminated trailing blanks.
WriteMacs() now uses Dfltmode instead of hard-wired 0644.
Changed memcpy calls back to bcopy.
@
text
@d4 1
a4 1
 * $Revision: 11.1 $
d6 6
a11 1
 * $Log:	jove_funcs.c,v $
d45 1
a45 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_funcs.c,v 11.1 95/01/04 10:35:13 mike Rel4_4 $";
d68 1
d75 1
d88 1
a126 1
	BackChar(),
a160 1
	Eol(),
a163 1
	PtToMark(),
a164 1
	ExecMacro(),
a172 1
	ForChar(),
a180 1
	InitBindings(),
a185 1
	NameMac(),
a186 1
	OpenLine(),
a187 2
	NextError(),
	NextLine(),
a197 1
	PrevLine(),
a202 1
	ReadMacs(),
a205 1
	Beep(),
a219 2
	Remember(),
	Forget(),
a227 1
	WriteMacs(),
d235 1
d242 1
a242 1
	DefFunc("backward-char", BackChar);
d276 1
a276 1
	DefFunc("end-of-line", Eol);
d280 1
a280 1
	DefFunc("exchange-point-and-mark", PtToMark);
d282 1
a282 1
	DefFunc("execute-keyboard-macro", ExecMacro);
d291 1
a291 1
	DefFunc("forward-char", ForChar);
d300 1
a300 1
	DefFunc("init-bindings", InitBindings);
d306 1
a306 1
	DefFunc("name-keyboard-macro", NameMac);
d308 1
a308 1
	DefFunc("newline-and-backup", OpenLine);
d310 2
a311 2
	DefFunc("next-error", NextError);
	DefFunc("next-line", NextLine);
d322 1
a322 1
	DefFunc("previous-line", PrevLine);
d329 1
a329 1
	DefFunc("read-macros-from-file", ReadMacs);
d333 1
a333 1
	DefFunc("ring-the-bell", Beep);
d349 2
a350 2
	DefFunc("start-remembering", Remember);
	DefFunc("stop-remembering", Forget);		/* Not bad */
d359 1
a359 1
	DefFunc("write-macros-to-file", WriteMacs);
d402 1
d414 1
d424 1
d435 1
d443 1
a443 1
	BindFunc(mainmap, CTL('B'), BackChar);
d446 3
a448 3
	BindFunc(mainmap, CTL('E'), Eol);
	BindFunc(mainmap, CTL('F'), ForChar);
	BindFunc(mainmap, CTL('G'), Beep);
d455 3
a457 3
	BindFunc(mainmap, CTL('N'), NextLine);
	BindFunc(mainmap, CTL('O'), OpenLine);
	BindFunc(mainmap, CTL('P'), PrevLine);
d549 1
a549 1
	BindFunc(pref2map, CTL('N'), NextError);
d557 1
a557 1
	BindFunc(pref2map, CTL('X'), PtToMark);
d595 1
d630 1
d645 1
d655 1
d673 1
d685 1
a685 1
		else if (functions[*++cp].f.Func == Forget)
d690 1
d696 1
d734 1
d761 1
d768 1
d775 1
d788 1
d827 1
d853 1
@


11.1
log
@Release_4.4
@
text
@d2 1
a2 1
 *			J O V E _ F U N C S . C 
d4 1
a4 1
 * $Revision: 10.4 $
d7 3
d12 1
a12 1
 * 
d18 1
a18 1
 * 
d21 1
a21 1
 * 
d24 1
a24 1
 * 
d28 1
a28 1
 * 
d31 1
a31 1
 * 
d34 1
a34 1
 * 
d37 1
a37 1
 * 
d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_funcs.c,v 10.4 94/09/17 04:57:35 butler Exp $";
d49 1
a49 1
   because the file was taking too long to compile ... 
d53 2
d466 1
a466 1
	BindFunc(mainmap, CTL('T'), TransChar);	
d620 2
a621 2
 * 
 * We can't define or run the same macro recursively.  Each macro has 
d750 1
a750 1
	memcpy(m->Body, KeyMacro.Body, m->MacLength);
d754 1
a754 1
}	
d778 1
a778 1
}	
d827 1
a827 1
	if ((macfd = creat(file, 0644)) == -1)
@


10.4
log
@changed all calls to bcopy to be memcpy instead.  Useful for Solaris 5.2
@
text
@d4 1
a4 1
 * $Revision: 10.3 $
d6 4
a9 1
 * $Log: jove_funcs.c,v $
d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_funcs.c,v 10.3 1993/12/10 04:25:54 mike Exp butler $";
@


10.3
log
@Added FindCursorTag(), bound to M-t.
@
text
@d4 1
a4 1
 * $Revision: 10.2 $
d6 4
a9 1
 * $Log:	jove_funcs.c,v $
d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_funcs.c,v 10.2 93/10/26 03:47:08 mike Exp Locker: mike $";
d742 1
a742 1
	bcopy(KeyMacro.Body, m->Body, m->MacLength);
@


10.2
log
@ANSI C
@
text
@d4 1
a4 1
 * $Revision: 10.1 $
d7 3
d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_funcs.c,v 10.1 91/10/12 06:53:58 mike Rel4_0 Locker: mike $";
d156 1
d285 1
d508 2
@


10.1
log
@Release_4.0
@
text
@d4 1
a4 1
 * $Revision: 2.3 $
d7 3
d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_funcs.c,v 2.3 91/08/30 19:41:36 mike Exp $";
a31 30
 *			jove_funcs.c
 *
 * $Revision: 2.3 $
 *
 * $Log:	jove_funcs.c,v $
 * Revision 2.3  91/08/30  19:41:36  mike
 * Added ^Xe to run cake, like ^X^E runs make.
 * 
 * Revision 2.2  91/08/30  17:54:33  mike
 * Changed #include directives to distinguish between local and system header
 * files.
 * 
 * Revision 2.1  91/08/30  17:49:06  mike
 * Paul Stay mods for ANSI C
 * 
 * Revision 2.0  84/12/26  16:46:12  dpk
 * System as distributed to Berkeley 26 Dec 84
 * 
 * Revision 1.2  83/12/16  00:08:08  dpk
 * Added distinctive RCS header
 * 
 * Revision 1.1  83/12/16  00:08:01  dpk
 * Original 4.2 Distribution Source
 * 
 * Revision 1.2  83/12/02  00:22:28  dpk
 * Fixed botch of incremental search modification (mapping)
 * 
 */

/*
d79 1
d788 1
d795 1
a795 1
		return;
d797 1
@


2.3
log
@Added ^Xe to run cake, like ^X^E runs make.
@
text
@d4 1
a4 1
 * $Revision: 2.2 $
d7 3
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_funcs.c,v 2.2 91/08/30 17:54:33 mike Exp $";
d31 1
a31 1
 * $Revision: 2.2 $
d34 3
@


2.2
log
@Changed #include directives to distinguish between local and system header
files.
@
text
@d4 1
a4 1
 * $Revision: 2.1 $
d7 4
d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/jove/RCS/jove_funcs.c,v 2.1 91/08/30 17:49:06 mike Exp $";
d28 1
a28 1
 * $Revision: 2.1 $
d31 4
d145 1
d273 1
d574 1
@


2.1
log
@Paul Stay mods for ANSI C
@
text
@d4 1
a4 1
 * $Revision: 2.0 $
d7 3
d18 1
a18 1
static char RCSid[] = "@@(#)$Header: jove_funcs.c,v 2.0 84/12/26 16:46:12 dpk Exp $";
d24 1
a24 1
 * $Revision: 2.0 $
d27 3
d52 1
a52 1
#include "jove.h"
@


2.0
log
@System as distributed to Berkeley 26 Dec 84
@
text
@d4 1
a4 1
 * $Revision: 1.2 $
d7 3
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: jove_funcs.c,v 1.2 83/12/16 00:08:08 dpk BRL $";
d21 1
a21 1
 * $Revision: 1.2 $
d24 3
d382 1
a382 1
};
d384 1
d424 1
a424 1
	BindFunc(mainmap, CTL(I), func);
d432 30
a461 30
	BindFunc(mainmap, CTL(@@), SetMark);
	BindFunc(mainmap, CTL(A), Bol);
	BindFunc(mainmap, CTL(B), BackChar);
	BindFunc(mainmap, CTL(C), CapChar);
	BindFunc(mainmap, CTL(D), DelNChar);
	BindFunc(mainmap, CTL(E), Eol);
	BindFunc(mainmap, CTL(F), ForChar);
	BindFunc(mainmap, CTL(G), Beep);
	BindFunc(mainmap, CTL(H), DelPChar);
	BindFunc(mainmap, CTL(I), CTab);
	BindFunc(mainmap, CTL(J), LineAI);
	BindFunc(mainmap, CTL(K), KillEOL);
	BindFunc(mainmap, CTL(L), ClAndRedraw);
	BindFunc(mainmap, CTL(M), Newline);
	BindFunc(mainmap, CTL(N), NextLine);
	BindFunc(mainmap, CTL(O), OpenLine);
	BindFunc(mainmap, CTL(P), PrevLine);
	BindFunc(mainmap, CTL(Q), QuotChar);
	BindFunc(mainmap, CTL(^), QuotChar);
	BindFunc(mainmap, CTL(R), IncRSearch);
	BindFunc(mainmap, CTL(S), IncFSearch);
	BindFunc(mainmap, CTL(\\), IncFSearch);
	BindFunc(mainmap, CTL(T), TransChar);	
	BindFunc(mainmap, CTL(U), FourTime);
	BindFunc(mainmap, CTL(V), NextPage);
	BindFunc(mainmap, CTL(W), DelPWord);
	BindFunc(mainmap, CTL(X), CtlxPrefix);
	BindFunc(mainmap, CTL(Y), Yank);
	BindFunc(mainmap, CTL(Z), UpScroll);
	BindFunc(mainmap, CTL([), EscPrefix);
d468 6
a473 6
	BindFunc(pref1map, CTL(B), Bparen);
	BindFunc(pref1map, CTL(E), RepSearch);
	BindFunc(pref1map, CTL(F), Fparen);
	BindFunc(pref1map, CTL(H), DelPWord);
	BindFunc(pref1map, CTL(L), RedrawDisplay);
	BindFunc(pref1map, CTL(V), PageNWind);
d527 1
a527 1
	/* CTLX prefix */
d530 18
a547 18
	BindFunc(pref2map, CTL(B), BufList);
	BindFunc(pref2map, CTL(C), Leave);
	BindFunc(pref2map, CTL(E), MakeErrors);
	BindFunc(pref2map, CTL(F), FindFile);
	BindFunc(pref2map, CTL(I), InsFile);
	BindFunc(pref2map, CTL(K), DelReg);
	BindFunc(pref2map, CTL(L), CasRegLower);
	BindFunc(pref2map, CTL(M), WtModBuf);
	BindFunc(pref2map, CTL(N), NextError);
	BindFunc(pref2map, CTL(O), DelBlnkLines);
	BindFunc(pref2map, CTL(R), ReadFile);
	BindFunc(pref2map, CTL(S), SaveFile);
	BindFunc(pref2map, CTL(T), FindTag);
	BindFunc(pref2map, CTL(U), CasRegUpper);
	BindFunc(pref2map, CTL(V), FindFile);
	BindFunc(pref2map, CTL(W), WriteFile);
	BindFunc(pref2map, CTL(X), PtToMark);
	BindFunc(pref2map, CTL(\\), SaveFile);
@


1.2
log
@Added distinctive RCS header
@
text
@d4 1
a4 1
 * $Revision$
d6 4
a9 1
 * $Log$
d12 1
a12 1
static char RCSid[] = "@@(#)$Header$";
d18 1
a18 1
 * $Revision: 1.1 $
d21 3
d118 1
d243 1
d428 1
a428 1
	BindFunc(mainmap, CTL(C), UnBound);
a436 3
#ifndef BRL
	BindFunc(mainmap, CTL(L), RedrawDisplay);
#else
a437 1
#endif
a443 4
#ifndef BRL
	BindFunc(mainmap, CTL(R), RevSearch);
	BindFunc(mainmap, CTL(S), ForSearch);
#else
d446 1
a446 2
#endif
	BindFunc(mainmap, CTL(\\), ForSearch);
a449 3
#ifndef BRL
	BindFunc(mainmap, CTL(W), DelReg);
#else
a450 1
#endif BRL
a461 1
#ifdef BRL
a462 1
#endif BRL
a463 1
#ifdef BRL
a464 4
#endif BRL
#ifndef BRL
	BindFunc(pref1map, CTL(L), ClAndRedraw);
#else
a465 1
#endif BRL
a483 1
#ifdef BRL
a485 1
#endif BRL
a491 1
#ifdef BRL
a493 1
#endif BRL
a495 4
#ifndef BRL
	BindFunc(pref1map, 'R', RepSearch);
	BindFunc(pref1map, 'r', RepSearch);
#else
a499 1
#endif BRL
a527 1
#ifdef BRL
a528 1
#endif BRL
a534 1
#ifdef BRL
a535 1
#endif BRL
a536 1
#ifdef BRL
a537 1
#endif
a558 1
#ifndef BRL
a560 1
#endif
d570 2
a571 1
	return sprintf(func, ": %s ", LastFunc->f_name);
d728 1
a728 1
	copynchar(m->Body, KeyMacro.Body, m->MacLength);
a732 9

copynchar(t, f, len)
register char	*t,
		*f;
register int	len;
{
	while (len--)
		*t++ = *f++;
}
@


1.1
log
@Original 4.2 Distribution Source
@
text
@d2 11
d15 1
a15 1
 * $Revision: 1.2 $
d18 3
@
