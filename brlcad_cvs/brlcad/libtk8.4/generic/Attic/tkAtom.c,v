head	1.4;
access;
symbols
	ansi-20040405-merged:1.3.4.1
	postmerge-20040405-ansi:1.3
	premerge-20040404-ansi:1.3
	postmerge-autoconf:1.3
	autoconf-freeze:1.1.6.3
	premerge-autoconf:1.3
	postmerge-20040315-windows:1.3
	premerge-20040315-windows:1.3
	windows-20040315-freeze:1.3.2.1
	autoconf-20031203:1.1.6.1
	autoconf-20031202:1.1
	autoconf-branch:1.1.0.6
	phong-branch:1.1.0.4
	photonmap-branch:1.1.0.2
	windows-branch:1.3.0.2
	ansi-branch:1.3.0.4;
locks; strict;
comment	@ * @;


1.4
date	2004.05.21.18.00.28;	author morrison;	state dead;
branches;
next	1.3;

1.3
date	2004.03.04.19.49.08;	author morrison;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2003.11.07.14.58.10;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.13.20.04.01;	author jra;	state Exp;
branches
	1.1.6.1;
next	;

1.1.6.1
date	2003.12.03.16.25.09;	author erikg;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2004.02.12.19.02.32;	author erikg;	state Exp;
branches;
next	1.1.6.3;

1.1.6.3
date	2004.03.15.13.57.32;	author erikg;	state Exp;
branches;
next	;

1.3.2.1
date	2004.03.12.09.59.56;	author morrison;	state Exp;
branches;
next	;

1.3.4.1
date	2004.03.17.21.20.41;	author morrison;	state Exp;
branches;
next	;


desc
@@


1.4
log
@moved from top-level to src/other/.
@
text
@/* 
 * tkAtom.c --
 *
 *	This file manages a cache of X Atoms in order to avoid
 *	interactions with the X server.  It's much like the Xmu
 *	routines, except it has a cleaner interface (caller
 *	doesn't have to provide permanent storage for atom names,
 *	for example).
 *
 * Copyright (c) 1990-1994 The Regents of the University of California.
 * Copyright (c) 1994 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkAtom.c,v 1.3 2004/03/04 19:49:08 morrison Exp $
 */

#include "tkPort.h"
#include "tkInt.h"

/*
 * The following are a list of the predefined atom strings.
 * They should match those found in xatom.h
 */

static char * atomNameArray[] = {
    "PRIMARY",		"SECONDARY",		"ARC",
    "ATOM",		"BITMAP",		"CARDINAL",
    "COLORMAP",		"CURSOR",		"CUT_BUFFER0",
    "CUT_BUFFER1",	"CUT_BUFFER2",		"CUT_BUFFER3",
    "CUT_BUFFER4",	"CUT_BUFFER5",		"CUT_BUFFER6",
    "CUT_BUFFER7",	"DRAWABLE",		"FONT",
    "INTEGER",		"PIXMAP",		"POINT",
    "RECTANGLE",	"RESOURCE_MANAGER",	"RGB_COLOR_MAP",
    "RGB_BEST_MAP",	"RGB_BLUE_MAP",		"RGB_DEFAULT_MAP",
    "RGB_GRAY_MAP",	"RGB_GREEN_MAP",	"RGB_RED_MAP",
    "STRING",		"VISUALID",		"WINDOW",
    "WM_COMMAND",	"WM_HINTS",		"WM_CLIENT_MACHINE",
    "WM_ICON_NAME",	"WM_ICON_SIZE",		"WM_NAME",
    "WM_NORMAL_HINTS",	"WM_SIZE_HINTS",	"WM_ZOOM_HINTS",
    "MIN_SPACE",	"NORM_SPACE",		"MAX_SPACE",
    "END_SPACE",	"SUPERSCRIPT_X",	"SUPERSCRIPT_Y",
    "SUBSCRIPT_X",	"SUBSCRIPT_Y",		"UNDERLINE_POSITION",
    "UNDERLINE_THICKNESS", "STRIKEOUT_ASCENT",	"STRIKEOUT_DESCENT",
    "ITALIC_ANGLE",	"X_HEIGHT",		"QUAD_WIDTH",
    "WEIGHT",		"POINT_SIZE",		"RESOLUTION",
    "COPYRIGHT",	"NOTICE",		"FONT_NAME",
    "FAMILY_NAME",	"FULL_NAME",		"CAP_HEIGHT",
    "WM_CLASS",		"WM_TRANSIENT_FOR",
    (char *) NULL
};

/*
 * Forward references to procedures defined in this file:
 */

static void	AtomInit _ANSI_ARGS_((TkDisplay *dispPtr));

/*
 *--------------------------------------------------------------
 *
 * Tk_InternAtom --
 *
 *	Given a string, produce the equivalent X atom.  This
 *	procedure is equivalent to XInternAtom, except that it
 *	keeps a local cache of atoms.  Once a name is known,
 *	the server need not be contacted again for that name.
 *
 * Results:
 *	The return value is the Atom corresponding to name.
 *
 * Side effects:
 *	A new entry may be added to the local atom cache.
 *
 *--------------------------------------------------------------
 */

Atom
Tk_InternAtom(tkwin, name)
    Tk_Window tkwin;		/* Window token;  map name to atom
				 * for this window's display. */
    CONST char *name;		/* Name to turn into atom. */
{
    register TkDisplay *dispPtr;
    register Tcl_HashEntry *hPtr;
    int new;

    dispPtr = ((TkWindow *) tkwin)->dispPtr;
    if (!dispPtr->atomInit) {
	AtomInit(dispPtr);
    }

    hPtr = Tcl_CreateHashEntry(&dispPtr->nameTable, name, &new);
    if (new) {
	Tcl_HashEntry *hPtr2;
	Atom atom;

	atom = XInternAtom(dispPtr->display, name, False);
	Tcl_SetHashValue(hPtr, atom);
	hPtr2 = Tcl_CreateHashEntry(&dispPtr->atomTable, (char *) atom,
		&new);
	Tcl_SetHashValue(hPtr2, Tcl_GetHashKey(&dispPtr->nameTable, hPtr));
    }
    return (Atom) Tcl_GetHashValue(hPtr);
}

/*
 *--------------------------------------------------------------
 *
 * Tk_GetAtomName --
 *
 *	This procedure is equivalent to XGetAtomName except that
 *	it uses the local atom cache to avoid contacting the
 *	server.
 *
 * Results:
 *	The return value is a character string corresponding to
 *	the atom given by "atom".  This string's storage space
 *	is static:  it need not be freed by the caller, and should
 *	not be modified by the caller.  If "atom" doesn't exist
 *	on tkwin's display, then the string "?bad atom?" is returned.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

CONST char *
Tk_GetAtomName(tkwin, atom)
    Tk_Window tkwin;		/* Window token;  map atom to name
				 * relative to this window's
				 * display. */
    Atom atom;			/* Atom whose name is wanted. */
{
    register TkDisplay *dispPtr;
    register Tcl_HashEntry *hPtr;

    dispPtr = ((TkWindow *) tkwin)->dispPtr;
    if (!dispPtr->atomInit) {
	AtomInit(dispPtr);
    }

    hPtr = Tcl_FindHashEntry(&dispPtr->atomTable, (char *) atom);
    if (hPtr == NULL) {
	char *name;
	Tk_ErrorHandler handler;
	int new, mustFree;

	handler= Tk_CreateErrorHandler(dispPtr->display, BadAtom,
		-1, -1, (Tk_ErrorProc *) NULL, (ClientData) NULL);
	name = XGetAtomName(dispPtr->display, atom);
	mustFree = 1;
	if (name == NULL) {
	    name = "?bad atom?";
	    mustFree = 0;
	}
	Tk_DeleteErrorHandler(handler);
	hPtr = Tcl_CreateHashEntry(&dispPtr->nameTable, (char *) name,
		&new);
	Tcl_SetHashValue(hPtr, atom);
	if (mustFree) {
	    XFree(name);
	}
	name = Tcl_GetHashKey(&dispPtr->nameTable, hPtr);
	hPtr = Tcl_CreateHashEntry(&dispPtr->atomTable, (char *) atom,
		&new);
	Tcl_SetHashValue(hPtr, name);
    }
    return Tcl_GetHashValue(hPtr);
}

/*
 *--------------------------------------------------------------
 *
 * AtomInit --
 *
 *	Initialize atom-related information for a display.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Tables get initialized, etc. etc..
 *
 *--------------------------------------------------------------
 */

static void
AtomInit(dispPtr)
    register TkDisplay *dispPtr;	/* Display to initialize. */
{
    Tcl_HashEntry *hPtr;
    Atom atom;

    dispPtr->atomInit = 1;
    Tcl_InitHashTable(&dispPtr->nameTable, TCL_STRING_KEYS);
    Tcl_InitHashTable(&dispPtr->atomTable, TCL_ONE_WORD_KEYS);

    for (atom = 1; atom <= XA_LAST_PREDEFINED; atom++) {
	hPtr = Tcl_FindHashEntry(&dispPtr->atomTable, (char *) atom);
	if (hPtr == NULL) {
	    char *name;
	    int new;

	    name = atomNameArray[atom - 1];
	    hPtr = Tcl_CreateHashEntry(&dispPtr->nameTable, (char *) name,
		&new);
	    Tcl_SetHashValue(hPtr, atom);
	    name = Tcl_GetHashKey(&dispPtr->nameTable, hPtr);
	    hPtr = Tcl_CreateHashEntry(&dispPtr->atomTable, (char *) atom,
		&new);
	    Tcl_SetHashValue(hPtr, name);
	}
    }
}
@


1.3
log
@Updated to tk 8.4.6
@
text
@d16 1
a16 1
 * RCS: @@(#) $Id: tkAtom.c,v 1.3 2002/08/05 04:30:38 dgp Exp $
@


1.3.4.1
log
@sync branch with HEAD
@
text
@d16 1
a16 1
 * RCS: @@(#) $Id$
@


1.3.2.1
log
@merge from HEAD
@
text
@d16 1
a16 1
 * RCS: @@(#) $Id$
@


1.2
log
@updated tk to 8.4.4
@
text
@@


1.1
log
@*** empty log message ***
@
text
@@


1.1.6.1
log
@updates from HEAD, part 1
@
text
@d16 1
a16 1
 * RCS: @@(#) $Id: tkAtom.c,v 1.2 2003/11/07 14:58:10 morrison Exp $
@


1.1.6.2
log
@merge from HEAD
@
text
@@


1.1.6.3
log
@merge from head
@
text
@d16 1
a16 1
 * RCS: @@(#) $Id: tkAtom.c,v 1.1.6.2 2004/02/12 19:02:32 erikg Exp $
@


