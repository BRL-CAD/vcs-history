head	1.13;
access;
symbols
	ansi-20040405-merged:1.9.2.2
	postmerge-20040405-ansi:1.11
	premerge-20040404-ansi:1.10
	postmerge-autoconf:1.10
	autoconf-freeze:1.9.10.1
	premerge-autoconf:1.10
	ansi-20040316-freeze:1.9.2.1
	postmerge-20040315-windows:1.10
	premerge-20040315-windows:1.10
	windows-20040315-freeze:1.9.4.1
	autoconf-20031203:1.9
	autoconf-20031202:1.9
	autoconf-branch:1.9.0.10
	phong-branch:1.9.0.8
	photonmap-branch:1.9.0.6
	rel-6-1-DP:1.9
	windows-branch:1.9.0.4
	rel-6-0-2:1.7
	ansi-branch:1.9.0.2
	rel-6-0-1-branch:1.7.0.2
	hartley-6-0-post:1.8
	hartley-6-0-pre:1.7
	rel-6-0-1:1.7
	rel-6-0:1.7
	rel-5-4:1.2.2.2
	offsite-5-3-pre:1.3
	rel-5-3:1.2.2.2
	rel-5-2:1.2.2.2
	rel-5-1-branch:1.2.0.2;
locks; strict;
comment	@ * @;


1.13
date	2004.05.24.04.18.40;	author morrison;	state dead;
branches;
next	1.12;

1.12
date	2004.05.10.15.30.41;	author erikg;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.05.07.50.06;	author morrison;	state Exp;
branches;
next	1.10;

1.10
date	2004.02.02.17.38.58;	author morrison;	state Exp;
branches;
next	1.9;

1.9
date	2002.08.20.17.07.19;	author jra;	state Exp;
branches
	1.9.2.1
	1.9.4.1
	1.9.10.1;
next	1.8;

1.8
date	2002.08.15.20.54.32;	author hartley;	state Exp;
branches;
next	1.7;

1.7
date	2001.04.18.22.21.31;	author bparker;	state Exp;
branches;
next	1.6;

1.6
date	2001.04.17.20.37.36;	author bparker;	state Exp;
branches;
next	1.5;

1.5
date	2001.04.12.18.18.14;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.19.22.19.17;	author butler;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.06.20.40.07;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.16.17.52.05;	author bparker;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2000.08.16.17.29.02;	author bparker;	state Exp;
branches;
next	;

1.2.2.1
date	2000.08.16.18.00.43;	author bparker;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2000.09.11.19.52.55;	author jra;	state Exp;
branches;
next	;

1.9.2.1
date	2002.09.19.18.00.33;	author morrison;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2004.03.17.21.15.51;	author morrison;	state Exp;
branches;
next	;

1.9.4.1
date	2004.03.11.23.40.27;	author morrison;	state Exp;
branches;
next	;

1.9.10.1
date	2004.02.12.18.39.43;	author erikg;	state Exp;
branches;
next	;


desc
@@


1.13
log
@moved to src/bwish/
@
text
@/*
 *				I N P U T . C
 *
 * Input handling routines. Some of this code was borrowed from mged/ged.c
 * and modified for use in this application.
 *
 *  Author -
 *	  Robert G. Parker
 *
 *  Authors of mged/ged.c -
 *	Michael John Muuss
 *	Charles M Kennedy
 *	Douglas A Gwyn
 *	Bob Suckling
 *	Gary Steven Moss
 *	Earl P Weaver
 *	Phil Dykstra
 *	Bob Parker
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" license agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1998-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 *
 */

#include <time.h>
#if defined(IRIX) && IRIX == 5
#define _BSD_COMPAT
#endif
#include <sys/time.h>
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include "tcl.h"

#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <ctype.h>

#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "libtermio.h"

#define CTRL_A      1
#define CTRL_B      2
#define CTRL_D      4
#define CTRL_E      5
#define CTRL_F      6
#define CTRL_K      11
#define CTRL_L      12
#define CTRL_N      14
#define CTRL_P      16
#define CTRL_T      20
#define CTRL_U      21
#define CTRL_W      '\027'
#define ESC         27
#define BACKSPACE   '\b'
#define DELETE      127
#ifdef BWISH
#define PROMPT "\rbwish> "
#else
#define PROMPT "\rbtclsh> "
#endif

#define SPACES "                                                                                                                                                                                                                                                                                                           "

/* defined in tcl.c */
extern void Cad_Exit(int status);

/* defined in cmd.c */
extern struct bu_vls *history_prev(void);
extern struct bu_vls *history_next(void);
extern void history_record(struct bu_vls *cmdp, struct timeval *start, struct timeval *finish, int status);

/* defined in main.c */
extern Tcl_Interp *interp;

HIDDEN void inputHandler(ClientData clientData, int mask);
HIDDEN void processChar(char ch);
HIDDEN void insert_prompt(void);
HIDDEN void insert_char(char ch);
HIDDEN void insert_beep(void);

HIDDEN struct bu_vls input_str;
HIDDEN struct bu_vls input_str_prefix;
HIDDEN int input_str_index;
HIDDEN struct bu_vls scratchline;
HIDDEN struct bu_vls prompt;

void
initInput(void)
{
	bu_vls_init(&input_str);
	bu_vls_init(&input_str_prefix);
	bu_vls_init(&scratchline);
	bu_vls_init(&prompt);
	input_str_index = 0;

	Tcl_CreateFileHandler(STDIN_FILENO, TCL_READABLE,
			      inputHandler, (ClientData)STDIN_FILENO);

	bu_vls_strcpy(&prompt, PROMPT);
	save_Tty(fileno(stdin));
	set_Cbreak(fileno(stdin));
	clr_Echo(fileno(stdin));
	insert_prompt();
}

HIDDEN void
inputHandler(ClientData clientData, int mask)
{
	int count;
	char ch;
	long fd;
	char buf[4096];
	int index;

	fd = (long)clientData;

	count = read((int)fd, (void *)buf, 4096);

	if (count <= 0 && feof(stdin))
		Cad_Exit(TCL_OK);

	/* Process everything in buf */
	for (index = 0, ch = buf[index]; index < count; ch = buf[++index])
		processChar(ch);
}

/* Process character */
HIDDEN void
processChar(char ch)
{
	struct bu_vls *vp;
	struct bu_vls temp;
	static int escaped = 0;
	static int bracketed = 0;
	static int freshline = 1;

	/* ANSI arrow keys */
	if (escaped && bracketed) {
		if (ch == 'A') ch = CTRL_P;
		if (ch == 'B') ch = CTRL_N;
		if (ch == 'C') ch = CTRL_F;
		if (ch == 'D') ch = CTRL_B;
		escaped = bracketed = 0;
	}

	switch (ch) {
	case ESC:           /* Used for building up ANSI arrow keys */
		escaped = 1;
		break;
	case '\n':          /* Carriage return or line feed */
	case '\r':
		bu_log("\n");   /* Display newline */

		bu_vls_printf(&input_str_prefix, "%s%S\n",
			      bu_vls_strlen(&input_str_prefix) > 0 ? " " : "",
			      &input_str);

		/* If this forms a complete command (as far as the Tcl parser is
		   concerned) then execute it. */
		if (Tcl_CommandComplete(bu_vls_addr(&input_str_prefix))) {
			int status;
			struct timeval start, finish;

			reset_Tty(fileno(stdin));
			gettimeofday(&start, (struct timezone *)NULL);
			status = Tcl_Eval(interp, bu_vls_addr(&input_str_prefix));
			gettimeofday(&finish, (struct timezone *)NULL);
			if (strlen(interp->result))
				bu_log("%s\n", interp->result);

			history_record(&input_str_prefix, &start, &finish, status);
			bu_vls_trunc(&input_str_prefix, 0);
			bu_vls_trunc(&input_str, 0);
			set_Cbreak(fileno(stdin)); /* Back to single-character mode */
			clr_Echo(fileno(stdin));

			/* reset prompt */
			bu_vls_strcpy(&prompt, PROMPT);

		} else {
			bu_vls_trunc(&input_str, 0);
			bu_vls_strcpy(&prompt, "\r? ");
		}
		insert_prompt();
		input_str_index = 0;
		freshline = 1;
		escaped = bracketed = 0;
		break;
	case BACKSPACE:
	case DELETE:
		if (input_str_index <= 0) {
			insert_beep();
			break;
		}

		if (input_str_index == bu_vls_strlen(&input_str)) {
			bu_log("\b \b");
			bu_vls_trunc(&input_str, bu_vls_strlen(&input_str)-1);
		} else {
			bu_vls_init(&temp);
			bu_vls_strcat(&temp, bu_vls_addr(&input_str)+input_str_index);
			bu_vls_trunc(&input_str, input_str_index-1);
			bu_log("\b%S ", &temp);
			insert_prompt();
			bu_log("%S", &input_str);
			bu_vls_vlscat(&input_str, &temp);
			bu_vls_free(&temp);
		}
		--input_str_index;
		escaped = bracketed = 0;
		break;
	case CTRL_A:                    /* Go to beginning of line */
		insert_prompt();
		input_str_index = 0;
		escaped = bracketed = 0;
		break;
	case CTRL_E:                    /* Go to end of line */
		if (input_str_index < bu_vls_strlen(&input_str)) {
			bu_log("%s", bu_vls_addr(&input_str)+input_str_index);
			input_str_index = bu_vls_strlen(&input_str);
		}
		escaped = bracketed = 0;
		break;
	case CTRL_D:                    /* Delete character at cursor */
		if (input_str_index == bu_vls_strlen(&input_str)) {
			insert_beep(); /* Beep if at end of input string */
			break;
		}
		bu_vls_init(&temp);
		bu_vls_strcat(&temp, bu_vls_addr(&input_str)+input_str_index+1);
		bu_vls_trunc(&input_str, input_str_index);
		bu_log("%S ", &temp);
		insert_prompt();
		bu_log("%S", &input_str);
		bu_vls_vlscat(&input_str, &temp);
		bu_vls_free(&temp);
		escaped = bracketed = 0;
		break;
	case CTRL_U:                   /* Delete whole line */
		insert_prompt();
		bu_log("%*s", bu_vls_strlen(&input_str), SPACES);
		insert_prompt();
		bu_vls_trunc(&input_str, 0);
		input_str_index = 0;
		escaped = bracketed = 0;
		break;
	case CTRL_K:                    /* Delete to end of line */
		bu_log("%*s", bu_vls_strlen(&input_str)-input_str_index, SPACES);
		bu_vls_trunc(&input_str, input_str_index);
		insert_prompt();
		bu_log("%S", &input_str);
		escaped = bracketed = 0;
		break;
	case CTRL_L:                   /* Redraw line */
		bu_log("\n");
		insert_prompt();
		bu_log("%S", &input_str);
		if (input_str_index == bu_vls_strlen(&input_str))
			break;
		insert_prompt();
		bu_log("%*S", input_str_index, &input_str);
		escaped = bracketed = 0;
		break;
	case CTRL_B:                   /* Back one character */
		if (input_str_index == 0) {
			insert_beep();
			break;
		}
		--input_str_index;
		bu_log("\b"); /* hopefully non-destructive! */
		escaped = bracketed = 0;
		break;
	case CTRL_F:                   /* Forward one character */
		if (input_str_index == bu_vls_strlen(&input_str)) {
			insert_beep();
			break;
		}
    
		bu_log("%c", bu_vls_addr(&input_str)[input_str_index]);
		++input_str_index;
		escaped = bracketed = 0;
		break;
	case CTRL_T:                  /* Transpose characters */
		if (input_str_index == 0) {
			insert_beep();
			break;
		}
		if (input_str_index == bu_vls_strlen(&input_str)) {
			bu_log("\b");
			--input_str_index;
		}
		ch = bu_vls_addr(&input_str)[input_str_index];
		bu_vls_addr(&input_str)[input_str_index] =
			bu_vls_addr(&input_str)[input_str_index - 1];
		bu_vls_addr(&input_str)[input_str_index - 1] = ch;
		bu_log("\b%*s", 2, bu_vls_addr(&input_str)+input_str_index-1);
		++input_str_index;
		escaped = bracketed = 0;
		break;
	case CTRL_N:                  /* Next history command */
	case CTRL_P:                  /* Last history command */
#if 1
		/* Work the history routines to get the right string */
		if (freshline) {
			if (ch == CTRL_P) {
				vp = history_prev();
				if (vp == NULL) {
					insert_beep();
					break;
				}
				bu_vls_trunc(&scratchline, 0);
				bu_vls_vlscat(&scratchline, &input_str);
				freshline = 0;
			} else {
				insert_beep();
				break;
			}
		} else {
			if (ch == CTRL_P) {
				vp = history_prev();
				if (vp == NULL) {
					insert_beep();
					break;
				}
			} else {
				vp = history_next();
				if (vp == NULL) {
					vp = &scratchline;
					freshline = 1;
				}
			}
		}
		insert_prompt();
		bu_log("%*s", bu_vls_strlen(&input_str), SPACES);
		insert_prompt();
		bu_vls_trunc(&input_str, 0);
		bu_vls_vlscat(&input_str, vp);
		if (bu_vls_addr(&input_str)[bu_vls_strlen(&input_str)-1] == '\n')
			bu_vls_trunc(&input_str, bu_vls_strlen(&input_str)-1); /* del \n */
		bu_log("%S", &input_str);
		input_str_index = bu_vls_strlen(&input_str);
		escaped = bracketed = 0;
#endif
		break;
	case CTRL_W:                   /* backward-delete-word */
		{
			char *start;
			char *curr;
			int len;
      
			start = bu_vls_addr(&input_str);
			curr = start + input_str_index - 1;
      
			/* skip spaces */
			while(curr > start && *curr == ' ')
				--curr;
      
			/* find next space */
			while(curr > start && *curr != ' ')
				--curr;
      
			bu_vls_init(&temp);
			bu_vls_strcat(&temp, start+input_str_index);
      
			if(curr == start)
				input_str_index = 0;
			else
				input_str_index = curr - start + 1;
      
			len = bu_vls_strlen(&input_str);
			bu_vls_trunc(&input_str, input_str_index);
			insert_prompt();
			bu_log("%S%S%*s", &input_str, &temp, len - input_str_index, SPACES);
			insert_prompt();
			bu_log("%S", &input_str);
			bu_vls_vlscat(&input_str, &temp);
			bu_vls_free(&temp);
		}
  
		escaped = bracketed = 0;
		break;
	case 'd':
		if (escaped) {                /* delete-word */
			char *start;
			char *curr;
			int i;

			start = bu_vls_addr(&input_str);
			curr = start + input_str_index;

			/* skip spaces */
			while(*curr != '\0' && *curr == ' ')
				++curr;

			/* find next space */
			while(*curr != '\0' && *curr != ' ')
				++curr;

			i = curr - start;
			bu_vls_init(&temp);
			bu_vls_strcat(&temp, curr);
			bu_vls_trunc(&input_str, input_str_index);
			insert_prompt();
			bu_log("%S%S%*s", &input_str, &temp, i - input_str_index, SPACES);
			insert_prompt();
			bu_log("%S", &input_str);
			bu_vls_vlscat(&input_str, &temp);
			bu_vls_free(&temp);
		}else
			insert_char(ch);

		escaped = bracketed = 0;
		break;
	case 'f':
		if (escaped) {                /* forward-word */
			char *start;
			char *curr;

			start = bu_vls_addr(&input_str);
			curr = start + input_str_index;

			/* skip spaces */
			while(*curr != '\0' && *curr == ' ')
				++curr;

			/* find next space */
			while(*curr != '\0' && *curr != ' ')
				++curr;

			input_str_index = curr - start;
			bu_vls_init(&temp);
			bu_vls_strcat(&temp, start+input_str_index);
			bu_vls_trunc(&input_str, input_str_index);
			insert_prompt();
			bu_log("%S", &input_str);
			bu_vls_vlscat(&input_str, &temp);
			bu_vls_free(&temp);
		}else
			insert_char(ch);

		escaped = bracketed = 0;
		break;
	case 'b':
		if (escaped) {                /* backward-word */
			char *start;
			char *curr;

			start = bu_vls_addr(&input_str);
			curr = start + input_str_index - 1;

			/* skip spaces */
			while(curr > start && *curr == ' ')
				--curr;

			/* find next space */
			while(curr > start && *curr != ' ')
				--curr;

			if(curr == start)
				input_str_index = 0;
			else
				input_str_index = curr - start + 1;

			bu_vls_init(&temp);
			bu_vls_strcat(&temp, start+input_str_index);
			bu_vls_trunc(&input_str, input_str_index);
			insert_prompt();
			bu_log("%S", &input_str);
			bu_vls_vlscat(&input_str, &temp);
			bu_vls_free(&temp);
		}else
			insert_char(ch);

		escaped = bracketed = 0;
		break;
	case '[':
		if (escaped) {
			bracketed = 1;
			break;
		}
		/* Fall through if not escaped! */
	default:
		if (!isprint(ch))
			break;

		insert_char(ch);
		escaped = bracketed = 0;
		break;
	}
}

HIDDEN void
insert_prompt(void)
{
	bu_log("%S", &prompt);
}

HIDDEN void
insert_char(char ch)
{
	if (input_str_index == bu_vls_strlen(&input_str)) {
		bu_log("%c", (int)ch);
		bu_vls_putc(&input_str, (int)ch);
		++input_str_index;
	} else {
		struct bu_vls temp;

		bu_vls_init(&temp);
		bu_vls_strcat(&temp, bu_vls_addr(&input_str)+input_str_index);
		bu_vls_trunc(&input_str, input_str_index);
		bu_log("%c%S", (int)ch, &temp);
		insert_prompt();
		bu_vls_putc(&input_str, (int)ch);
		bu_log("%S", &input_str);
		bu_vls_vlscat(&input_str, &temp);
		++input_str_index;
		bu_vls_free(&temp);
	}
}

HIDDEN void
insert_beep(void)
{
	bu_log("%c", 7);
}
@


1.12
log
@change conf.h to a wrapped config.h
@
text
@@


1.11
log
@merge of ansi-6-0-branch into HEAD
@
text
@d40 5
a44 1
#include "conf.h"
@


1.10
log
@update copyright to include span through 2003
@
text
@d79 1
a79 1
extern void Cad_Exit();
d82 3
a84 3
extern struct bu_vls *history_prev();
extern struct bu_vls *history_next();
extern void history_record();
d89 5
a93 5
HIDDEN void inputHandler();
HIDDEN void processChar();
HIDDEN void insert_prompt();
HIDDEN void insert_char();
HIDDEN void insert_beep();
d102 1
a102 1
initInput()
d121 1
a121 3
inputHandler(clientData, mask)
     ClientData clientData;
     int mask;
d143 1
a143 2
processChar(ch)
     char ch;
d507 1
a507 1
insert_prompt()
d513 1
a513 2
insert_char(ch)
     char ch;
d536 1
a536 1
insert_beep()
@


1.9
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d30 1
a30 1
 *	This software is Copyright (C) 1998 by the United States Army
@


1.9.4.1
log
@sync to HEAD...
@
text
@d30 1
a30 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
@


1.9.10.1
log
@merge from HEAD
@
text
@d30 1
a30 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
@


1.9.2.1
log
@Initial ANSIfication
@
text
@d79 1
a79 1
extern void Cad_Exit(int status);
d82 3
a84 3
extern struct bu_vls *history_prev(void);
extern struct bu_vls *history_next(void);
extern void history_record(struct bu_vls *cmdp, struct timeval *start, struct timeval *finish, int status);
d89 5
a93 5
HIDDEN void inputHandler(ClientData clientData, int mask);
HIDDEN void processChar(char ch);
HIDDEN void insert_prompt(void);
HIDDEN void insert_char(char ch);
HIDDEN void insert_beep(void);
d102 1
a102 1
initInput(void)
d121 3
a123 1
inputHandler(ClientData clientData, int mask)
d145 2
a146 1
processChar(char ch)
d510 1
a510 1
insert_prompt(void)
d516 2
a517 1
insert_char(char ch)
d540 1
a540 1
insert_beep(void)
@


1.9.2.2
log
@sync branch with HEAD
@
text
@d30 1
a30 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
@


1.8
log
@Converted from K&R to ANSI C - RFH
@
text
@d79 1
a79 1
extern void Cad_Exit(int status);
d82 3
a84 3
extern struct bu_vls *history_prev(void);
extern struct bu_vls *history_next(void);
extern void history_record(struct bu_vls *cmdp, struct timeval *start, struct timeval *finish, int status);
d89 5
a93 5
HIDDEN void inputHandler(ClientData clientData, int mask);
HIDDEN void processChar(char ch);
HIDDEN void insert_prompt(void);
HIDDEN void insert_char(char ch);
HIDDEN void insert_beep(void);
d102 1
a102 1
initInput(void)
d121 3
a123 1
inputHandler(ClientData clientData, int mask)
d145 2
a146 1
processChar(char ch)
d510 1
a510 1
insert_prompt(void)
d516 2
a517 1
insert_char(char ch)
d540 1
a540 1
insert_beep(void)
@


1.7
log
@*- use Cad_Exit() instead quit()
@
text
@d79 1
a79 1
extern void Cad_Exit();
d82 3
a84 3
extern struct bu_vls *history_prev();
extern struct bu_vls *history_next();
extern void history_record();
d89 5
a93 5
HIDDEN void inputHandler();
HIDDEN void processChar();
HIDDEN void insert_prompt();
HIDDEN void insert_char();
HIDDEN void insert_beep();
d102 1
a102 1
initInput()
d121 1
a121 3
inputHandler(clientData, mask)
     ClientData clientData;
     int mask;
d143 1
a143 2
processChar(ch)
     char ch;
d507 1
a507 1
insert_prompt()
d513 1
a513 2
insert_char(ch)
     char ch;
d536 1
a536 1
insert_beep()
@


1.6
log
@*- mods to use in both BWISH and BTCLSH
@
text
@d78 3
a83 1
extern void quit();
d86 1
a86 1
/* defined in bwish.c */
d136 1
a136 1
		quit(0);
@


1.5
log
@*- remove more warnings
@
text
@d70 1
d72 3
@


1.4
log
@patches to merge 5.3 into 6.0
@
text
@d43 7
d74 1
a74 1
extern void quit();
d77 4
@


1.3
log
@
lint
@
text
@d35 4
a38 2
#include <stdio.h>
#include <ctype.h>
a39 1
#include <time.h>
@


1.2
log
@replace cwish with bwish
@
text
@d35 2
d45 1
@


1.2.2.1
log
@moved from cwish
@
text
@@


1.2.2.2
log
@Hack to get "struct timeval" defined under IRIX 5.3
@
text
@d35 1
a36 4
#if defined(IRIX) && IRIX == 5
#define _BSD_COMPAT
#endif
#include <sys/time.h>
@


1.1
log
@everything is from the old cwish
@
text
@d59 1
a59 1
#define PROMPT "\rcwish> "
@

