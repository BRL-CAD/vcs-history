head	11.15;
access;
symbols
	ansi-20040405-merged:11.10.2.3
	postmerge-20040405-ansi:11.13
	premerge-20040404-ansi:11.12
	postmerge-autoconf:11.12
	autoconf-freeze:11.10.10.3
	premerge-autoconf:11.12
	ansi-20040316-freeze:11.10.2.1
	postmerge-20040315-windows:11.12
	premerge-20040315-windows:11.11
	windows-20040315-freeze:11.10.4.2
	autoconf-20031203:11.10
	autoconf-20031202:11.10
	autoconf-branch:11.10.0.10
	phong-branch:11.10.0.8
	photonmap-branch:11.10.0.6
	rel-6-1-DP:11.10
	windows-branch:11.10.0.4
	rel-6-0-2:11.8
	ansi-branch:11.10.0.2
	rel-6-0-1-branch:11.8.0.2
	hartley-6-0-post:11.9
	hartley-6-0-pre:11.8
	rel-6-0-1:11.8
	rel-6-0:11.8
	rel-5-4:11.6
	offsite-5-3-pre:11.7
	rel-5-3:11.6
	rel-5-2:11.6
	rel-5-1-branch:11.6.0.2
	rel-5-1:11.6
	rel-5-0:11.6
	rel-5-0-beta:11.5
	rel-4-5:11.4
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.4
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.15
date	2004.05.21.18.07.28;	author morrison;	state dead;
branches;
next	11.14;

11.14
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	11.13;

11.13
date	2004.04.05.07.51.26;	author morrison;	state Exp;
branches;
next	11.12;

11.12
date	2004.03.16.20.01.51;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2004.03.03.21.29.54;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2002.08.20.17.07.54;	author jra;	state Exp;
branches
	11.10.2.1
	11.10.4.1
	11.10.10.1;
next	11.9;

11.9
date	2002.08.15.20.55.06;	author hartley;	state Exp;
branches;
next	11.8;

11.8
date	2001.10.17.07.40.03;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2000.07.12.00.43.53;	author cjohnson;	state Exp;
branches;
next	11.6;

11.6
date	99.06.25.18.44.50;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	98.06.28.03.12.20;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	97.11.18.07.18.37;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	97.09.22.02.52.05;	author butler;	state Exp;
branches;
next	11.2;

11.2
date	96.07.11.14.54.32;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.51.47;	author mike;	state Rel4_4;
branches;
next	10.12;

10.12
date	95.01.03.21.57.25;	author mike;	state Exp;
branches;
next	10.11;

10.11
date	94.12.30.13.39.59;	author stay;	state Exp;
branches;
next	10.10;

10.10
date	94.12.23.14.47.13;	author jra;	state Exp;
branches;
next	10.9;

10.9
date	94.12.19.16.13.47;	author jra;	state Exp;
branches;
next	10.8;

10.8
date	94.11.08.23.12.53;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.11.04.04.57.49;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.09.01.05.46.33;	author gdurf;	state Exp;
branches;
next	10.5;

10.5
date	94.08.25.15.52.35;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	93.10.22.20.59.33;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	93.05.20.21.44.47;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.05.23.14.54.22;	author butler;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.36.54;	author mike;	state Rel4_0;
branches;
next	9.22;

9.22
date	91.10.11.08.25.51;	author butler;	state Exp;
branches;
next	9.21;

9.21
date	91.09.26.05.31.38;	author phil;	state Exp;
branches;
next	9.20;

9.20
date	91.09.21.00.57.40;	author mike;	state Exp;
branches;
next	9.19;

9.19
date	91.08.31.02.54.42;	author mike;	state Exp;
branches;
next	9.18;

9.18
date	91.07.19.02.17.11;	author mike;	state Exp;
branches;
next	9.17;

9.17
date	91.07.06.02.27.35;	author mike;	state Exp;
branches;
next	9.16;

9.16
date	91.06.12.21.04.11;	author mike;	state Exp;
branches;
next	9.15;

9.15
date	91.01.04.22.49.47;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	91.01.04.22.48.35;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	90.09.27.22.18.17;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	89.11.23.03.53.57;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	89.11.15.02.50.49;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	89.11.15.01.12.20;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	89.11.03.13.42.41;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	89.10.23.01.52.03;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	89.10.21.00.41.13;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	89.10.17.16.43.28;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	89.10.12.17.07.18;	author phil;	state Exp;
branches;
next	9.4;

9.4
date	89.08.18.22.34.10;	author phil;	state Exp;
branches;
next	9.3;

9.3
date	89.06.06.02.27.39;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.05.25.00.22.29;	author mike;	state Rel3_6;
branches;
next	9.1;

9.1
date	89.05.19.05.46.35;	author mike;	state Rel3_5;
branches;
next	8.9;

8.9
date	89.05.12.20.19.35;	author mike;	state Exp;
branches;
next	8.8;

8.8
date	89.05.07.22.49.38;	author mike;	state Exp;
branches;
next	8.7;

8.7
date	89.04.28.07.09.37;	author mike;	state Exp;
branches;
next	8.6;

8.6
date	89.04.28.05.49.13;	author mike;	state Exp;
branches;
next	8.5;

8.5
date	89.04.28.05.18.49;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	89.04.28.05.04.53;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.04.28.02.39.13;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	89.02.14.04.59.15;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.25.49;	author mike;	state Rel3_0;
branches;
next	7.5;

7.5
date	88.09.17.06.59.43;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.09.17.06.02.41;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.09.10.04.09.18;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.01.15.08.12.26;	author stay;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.25.05;	author mike;	state Rel;
branches;
next	6.3;

6.3
date	87.09.02.19.14.46;	author mike;	state Exp;
branches;
next	6.2;

6.2
date	87.08.10.01.04.10;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.50.19;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.21.50.06;	author mike;	state Rel;
branches;
next	4.7;

4.7
date	87.06.08.09.44.17;	author mike;	state Exp;
branches;
next	4.6;

4.6
date	87.05.28.06.10.32;	author mike;	state Exp;
branches;
next	4.5;

4.5
date	87.04.09.06.27.41;	author mike;	state Exp;
branches;
next	4.4;

4.4
date	87.02.12.22.05.23;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.02.11.03.58.47;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.11.02.24.15;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.02.49.08;	author mike;	state Rel1;
branches;
next	1.18;

1.18
date	86.12.19.02.00.19;	author phil;	state Exp;
branches;
next	1.17;

1.17
date	86.12.09.22.49.55;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	86.11.14.21.50.08;	author phil;	state Exp;
branches;
next	1.15;

1.15
date	86.10.30.18.31.03;	author phil;	state Exp;
branches;
next	1.14;

1.14
date	86.10.27.04.05.08;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	86.10.24.06.37.42;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	86.10.24.05.20.17;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	86.10.24.04.22.55;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	86.10.24.03.05.28;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	86.10.24.01.28.29;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	86.10.23.20.28.03;	author phil;	state Exp;
branches;
next	1.7;

1.7
date	86.10.22.23.29.52;	author phil;	state Exp;
branches;
next	1.6;

1.6
date	86.10.22.22.05.32;	author phil;	state Exp;
branches;
next	1.5;

1.5
date	86.10.22.21.13.56;	author phil;	state Exp;
branches;
next	1.4;

1.4
date	86.10.22.02.06.12;	author phil;	state Exp;
branches;
next	1.3;

1.3
date	86.10.14.22.11.09;	author phil;	state Exp;
branches;
next	1.2;

1.2
date	86.10.14.21.48.30;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.10.02.02.18.35;	author mike;	state Exp;
branches;
next	;

11.10.2.1
date	2002.09.19.18.01.28;	author morrison;	state Exp;
branches;
next	11.10.2.2;

11.10.2.2
date	2004.03.17.21.18.34;	author morrison;	state Exp;
branches;
next	11.10.2.3;

11.10.2.3
date	2004.04.02.16.08.08;	author morrison;	state Exp;
branches;
next	;

11.10.4.1
date	2002.09.26.23.04.00;	author morrison;	state Exp;
branches;
next	11.10.4.2;

11.10.4.2
date	2004.03.11.23.43.14;	author morrison;	state Exp;
branches;
next	;

11.10.10.1
date	2004.03.10.13.19.10;	author erikg;	state Exp;
branches;
next	11.10.10.2;

11.10.10.2
date	2004.03.15.14.07.14;	author erikg;	state Exp;
branches;
next	11.10.10.3;

11.10.10.3
date	2004.03.18.15.15.54;	author erikg;	state Exp;
branches;
next	;


desc
@PKG package
@


11.15
log
@moved to src/
@
text
@/*
 *			P K G . C
 *
 *  Routines to manage multiplexing and de-multiplexing synchronous
 *  and asynchronous messages across stream connections.
 *
 *  Functions -
 *	pkg_gshort	Get a 16-bit short from a char[2] array
 *	pkg_glong	Get a 32-bit long from a char[4] array
 *	pkg_pshort	Put a 16-bit short into a char[2] array
 *	pkg_plong	Put a 32-bit long into a char[4] array
 *	pkg_open	Open a network connection to a host/server
 *	pkg_transerver	Become a transient network server
 *	pkg_permserver	Create a network server, and listen for connection
 *	pkg_getclient	As permanent network server, accept a new connection
 *	pkg_close	Close a network connection
 *	pkg_send	Send a message on the connection
 *	pkg_2send	Send a two part message on the connection
 *	pkg_stream	Send a message that doesn't need a push
 *	pkg_flush	Empty the stream buffer of any queued messages
 *	pkg_waitfor	Wait for a specific msg, user buf, processing others
 *	pkg_bwaitfor	Wait for specific msg, malloc buf, processing others
 *	pkg_block	Wait until a full message has been read
 *
 *  Authors -
 *	Michael John Muuss
 *	Charles M. Kennedy
 *	Phillip Dykstra
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimitied.
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libpkg/pkg.c,v 11.14 2004/05/10 15:30:45 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <ctype.h>		/* used by inet_addr() routine, below */
#ifndef WIN32
#undef BSD	/* /usr/include/sys/param.h redefines this */
#include <sys/param.h>
#include <sys/time.h>
#endif
#if !defined(vax)
#include <time.h>
#endif
#ifndef WIN32
#include <sys/socket.h>
#include <sys/ioctl.h>		/* for FIONBIO */
#include <netinet/in.h>		/* for htons(), etc */
#include <netdb.h>
#include <netinet/tcp.h>	/* for TCP_NODELAY sockopt */
#include <arpa/inet.h>		/* for inet_addr() */
#undef LITTLE_ENDIAN		/* defined in netinet/{ip.h,tcp.h} */
#else
#include <io.h>
#include <process.h>
#include <winsock.h>
#endif

#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"

/* Not all systems with "BSD Networking" include UNIX Domain sockets */
#ifdef HAVE_UNIX_DOMAIN_SOCKETS
# include <sys/un.h>		/* UNIX Domain sockets */
#endif

#ifdef n16
/* Encore multimax */
# include <sys/h/socket.h>
# include <sys/ioctl.h>
# include <sys/netinet/in.h>
# include <sys/aux/netdb.h>
# include <sys/netinet/tcp.h>
#endif

#ifdef HAVE_WRITEV
# include <sys/uio.h>		/* for struct iovec (writev) */
#endif

#include <errno.h>
#include "pkg.h"

#if defined(__stardent)
/* <sys/byteorder.h> seems to be wrong, and this is a LITTLE_ENDIAN machine */
#	undef	htons
#	define	htons(x)	((((x)&0xFF)<<8)|(((x)>>8)&0xFF))
#	undef	htonl
#	define	htonl(x)	( \
	((((x)    )&0xFF)<<24) | \
	((((x)>> 8)&0xFF)<<16) | \
	((((x)>>16)&0xFF)<< 8) | \
	((((x)>>24)&0xFF)    )   )
#endif

int pkg_nochecking = 0;	/* set to disable extra checking for input */
int pkg_permport = 0;	/* TCP port that pkg_permserver() is listening on XXX */

/* Internal Functions */
static struct pkg_conn *pkg_makeconn(int fd, struct pkg_switch *switchp, void (*errlog) (/* ??? */));
static void pkg_errlog(char *s);
static void pkg_perror(void (*errlog) (/* ??? */), char *s);
static int pkg_dispatch(register struct pkg_conn *pc);
static int pkg_gethdr(register struct pkg_conn *pc, char *buf);

#define MAX_ERRBUF_SIZE 80
static char errbuf[MAX_ERRBUF_SIZE];
static FILE	*pkg_debug;
static void	pkg_ck_debug(void);
static void	pkg_timestamp(void);
static void	pkg_checkin(register struct pkg_conn *pc, int nodelay);

int pkg_inget(register struct pkg_conn *, char *, int);

#define PKG_CK(p)	{if(p==PKC_NULL||p->pkc_magic!=PKG_MAGIC) {\
			sprintf(errbuf,"%s: bad pointer x%lx line %d\n",__FILE__, (long)(p), __LINE__);\
			pkg_errlog(errbuf);abort();}}

#define	MAXQLEN	512	/* largest packet we will queue on stream */

/* A macro for logging a string message when the debug file is open */
#if 1
#define DMSG(s) if(pkg_debug) { \
	pkg_timestamp(); fprintf(pkg_debug,s); fflush(pkg_debug);}
#else
#define DMSG(s)	/**/
#endif

/*
 * Routines to insert/extract short/long's into char arrays,
 * independend of machine byte order and word-alignment.
 */

/*
 *			P K G _ G S H O R T
 */
unsigned short
pkg_gshort(unsigned char *msgp)
{
	register unsigned char *p = (unsigned char *) msgp;
#ifdef vax
	/*
	 * vax compiler doesn't put shorts in registers
	 */
	register unsigned long u;
#else
	register unsigned short u;
#endif

	u = *p++ << 8;
	return ((unsigned short)(u | *p));
}

/*
 *			P K G _ G L O N G
 */
unsigned long
pkg_glong(unsigned char *msgp)
{
	register unsigned char *p = (unsigned char *) msgp;
	register unsigned long u;

	u = *p++; u <<= 8;
	u |= *p++; u <<= 8;
	u |= *p++; u <<= 8;
	return (u | *p);
}

/*
 *			P K G _ P S H O R T
 */
char *
pkg_pshort(unsigned char *msgp, short unsigned int s)
{

	msgp[1] = s;
	msgp[0] = s >> 8;
	return((char *)msgp+2);
}

/*
 *			P K G _ P L O N G
 */
char *
pkg_plong(unsigned char *msgp, long unsigned int l)
{

	msgp[3] = l;
	msgp[2] = (l >>= 8);
	msgp[1] = (l >>= 8);
	msgp[0] = l >> 8;
	return((char *)msgp+4);
}

/*
 *			P K G _ O P E N
 *
 *  We are a client.  Make a connection to the server.
 *
 *  Returns PKC_ERROR on error.
 */
struct pkg_conn *
pkg_open(char *host, char *service, char *protocol, char *uname, char *passwd, struct pkg_switch *switchp, void (*errlog) (/* ??? */))
{
	struct sockaddr_in sinme;		/* Client */
	struct sockaddr_in sinhim;		/* Server */
#ifdef HAVE_UNIX_DOMAIN_SOCKETS
	struct sockaddr_un sunhim;		/* Server, UNIX Domain */
#endif
	register struct hostent *hp;
	register int netfd;
	struct	sockaddr *addr;			/* UNIX or INET addr */
	int	addrlen;			/* length of address */

	pkg_ck_debug();
	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_open(%s, %s, %s, %s, (passwd), switchp=x%lx, errlog=x%lx)\n",
			host, service, protocol, uname,
			(long)switchp, (long)errlog );
		fflush(pkg_debug);
	}

	/* Check for default error handler */
	if( errlog == NULL )
		errlog = pkg_errlog;

	bzero((char *)&sinhim, sizeof(sinhim));
	bzero((char *)&sinme, sizeof(sinme));

#ifdef HAVE_UNIX_DOMAIN_SOCKETS
	if( host == NULL || strlen(host) == 0 || strcmp(host,"unix") == 0 ) {
		/* UNIX Domain socket, port = pathname */
		sunhim.sun_family = AF_UNIX;
		strncpy( sunhim.sun_path, service, sizeof(sunhim.sun_path) );
		addr = (struct sockaddr *) &sunhim;
		addrlen = strlen(sunhim.sun_path) + 2;
		goto ready;
	}
#endif

	/* Determine port for service */
	if( atoi(service) > 0 )  {
		sinhim.sin_port = htons((unsigned short)atoi(service));
	} else {
		register struct servent *sp;
		if( (sp = getservbyname( service, "tcp" )) == NULL )  {
			sprintf(errbuf,"pkg_open(%s,%s): unknown service\n",
				host, service );
			errlog(errbuf);
			return(PKC_ERROR);
		}
		sinhim.sin_port = sp->s_port;
	}

	/* Get InterNet address */
	if( atoi( host ) > 0 )  {
		/* Numeric */
		sinhim.sin_family = AF_INET;
		sinhim.sin_addr.s_addr = inet_addr(host);
	} else {
		if( (hp = gethostbyname(host)) == NULL )  {
			sprintf(errbuf,"pkg_open(%s,%s): unknown host\n",
				host, service );
			errlog(errbuf);
			return(PKC_ERROR);
		}
		sinhim.sin_family = hp->h_addrtype;
		bcopy(hp->h_addr, (char *)&sinhim.sin_addr, hp->h_length);
	}
	addr = (struct sockaddr *) &sinhim;
	addrlen = sizeof(struct sockaddr_in);

ready:
	if( (netfd = socket(addr->sa_family, SOCK_STREAM, 0)) < 0 )  {
		pkg_perror( errlog, "pkg_open:  client socket" );
		return(PKC_ERROR);
	}

#if defined(TCP_NODELAY)
	/* SunOS 3.x defines it but doesn't support it! */
	if( addr->sa_family == AF_INET ) {
		int	on = 1;
		if( setsockopt( netfd, IPPROTO_TCP, TCP_NODELAY,
		    (char *)&on, sizeof(on) ) < 0 )  {
			pkg_perror( errlog, "pkg_open: setsockopt TCP_NODELAY" );
		}
	}
#endif

	if( connect(netfd, addr, addrlen) < 0 )  {
		pkg_perror( errlog, "pkg_open: client connect" );
		close(netfd);
		return(PKC_ERROR);
	}
	return( pkg_makeconn(netfd, switchp, errlog) );
}

/*
 *  			P K G _ T R A N S E R V E R
 *  
 *  Become a one-time server on the open connection.
 *  A client has already called and we have already answered.
 *  This will be a servers starting condition if he was created
 *  by a process like the UNIX inetd.
 *
 *  Returns PKC_ERROR or a pointer to a pkg_conn structure.
 */
struct pkg_conn *
pkg_transerver(struct pkg_switch *switchp, void (*errlog) (/* ??? */))
{
	pkg_ck_debug();
	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_transerver(switchp=x%lx, errlog=x%lx)\n",
			(long)switchp, (long)errlog );
		fflush(pkg_debug);
	}

	/*
	 * XXX - Somehow the system has to know what connection
	 * was accepted, it's protocol, etc.  For UNIX/inetd
	 * we use stdin.
	 */
	return( pkg_makeconn( fileno(stdin), switchp, errlog ) );
}

/*
 *  			P K G _ P E R M S E R V E R
 *  
 *  We are now going to be a server for the indicated service.
 *  Hang a LISTEN, and return the fd to select() on waiting for
 *  new connections.
 *
 *  Returns fd to listen on (>=0), -1 on error.
 */
int
pkg_permserver(char *service, char *protocol, int backlog, void (*errlog) (/* ??? */))
{
	struct sockaddr_in sinme;
#ifdef HAVE_UNIX_DOMAIN_SOCKETS
	struct sockaddr_un sunme;		/* UNIX Domain */
#endif
	register struct servent *sp;
	struct	sockaddr *addr;			/* UNIX or INET addr */
	int	addrlen;			/* length of address */
	int	pkg_listenfd;
	int	on = 1;

	pkg_ck_debug();
	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_permserver(%s, %s, backlog=%d, errlog=x%lx\n",
			service, protocol, backlog, (long)errlog );
		fflush(pkg_debug);
	}

	/* Check for default error handler */
	if( errlog == NULL )
		errlog = pkg_errlog;

	bzero((char *)&sinme, sizeof(sinme));

#ifdef HAVE_UNIX_DOMAIN_SOCKETS
	if( service != NULL && service[0] == '/' ) {
		/* UNIX Domain socket */
		strncpy( sunme.sun_path, service, sizeof(sunme.sun_path) );
		sunme.sun_family = AF_UNIX;
		addr = (struct sockaddr *) &sunme;
		addrlen = strlen(sunme.sun_path) + 2;
		goto ready;
	}
#endif
	/* Determine port for service */
	if( atoi(service) > 0 )  {
		sinme.sin_port = htons((unsigned short)atoi(service));
	} else {
		if( (sp = getservbyname( service, "tcp" )) == NULL )  {
			sprintf(errbuf,
				"pkg_permserver(%s,%d): unknown service\n",
				service, backlog );
			errlog(errbuf);
			return(-1);
		}
		sinme.sin_port = sp->s_port;
	}
	pkg_permport = sinme.sin_port;		/* XXX -- needs formal I/F */
	sinme.sin_family = AF_INET;
	addr = (struct sockaddr *) &sinme;
	addrlen = sizeof(struct sockaddr_in);

ready:
	if( (pkg_listenfd = socket(addr->sa_family, SOCK_STREAM, 0)) < 0 )  {
		pkg_perror( errlog, "pkg_permserver:  socket" );
		return(-1);
	}

	if( addr->sa_family == AF_INET ) {
		if( setsockopt( pkg_listenfd, SOL_SOCKET, SO_REUSEADDR,
		    (char *)&on, sizeof(on) ) < 0 )  {
			pkg_perror( errlog, "pkg_permserver: setsockopt SO_REUSEADDR" );
		}
#if defined(TCP_NODELAY)
		/* SunOS 3.x defines it but doesn't support it! */
		if( setsockopt( pkg_listenfd, IPPROTO_TCP, TCP_NODELAY,
		    (char *)&on, sizeof(on) ) < 0 )  {
			pkg_perror( errlog, "pkg_permserver: setsockopt TCP_NODELAY" );
		}
#endif
	}

	if( bind(pkg_listenfd, addr, addrlen) < 0 )  {
		pkg_perror( errlog, "pkg_permserver: bind" );
		close(pkg_listenfd);
		return(-1);
	}

	if( backlog > 5 )  backlog = 5;
	if( listen(pkg_listenfd, backlog) < 0 )  {
		pkg_perror( errlog, "pkg_permserver:  listen" );
		close(pkg_listenfd);
		return(-1);
	}
	return(pkg_listenfd);
}

/*
 *			P K G _ G E T C L I E N T
 *
 *  Given an fd with a listen outstanding, accept the connection.
 *  When poll == 0, accept is allowed to block.
 *  When poll != 0, accept will not block.
 *
 *  Returns -
 *	>0		ptr to pkg_conn block of new connection
 *	PKC_NULL	accept would block, try again later
 *	PKC_ERROR	fatal error
 */
struct pkg_conn *
pkg_getclient(int fd, struct pkg_switch *switchp, void (*errlog) (/* ??? */), int nodelay)
{
	struct sockaddr_in from;
	register int s2;
	unsigned int fromlen = sizeof (from);
	auto int onoff;

	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_getclient(fd=%d, switchp=x%lx, errlog=x%lx, nodelay=%d)\n",
			fd, (long)switchp, (long)errlog, nodelay );
		fflush(pkg_debug);
	}

	/* Check for default error handler */
	if( errlog == NULL )
		errlog = pkg_errlog;

#ifdef FIONBIO
	if(nodelay)  {
		onoff = 1;
#ifdef WIN32
		if( ioctlsocket(fd, FIONBIO, &onoff) < 0 )
			pkg_perror( errlog, "pkg_getclient: FIONBIO 1" );
#else
		if( ioctl(fd, FIONBIO, &onoff) < 0 )
			pkg_perror( errlog, "pkg_getclient: FIONBIO 1" );
#endif
	}
#endif
	do  {
		s2 = accept(fd, (struct sockaddr *)&from, &fromlen);
		if (s2 < 0) {
			if(errno == EINTR)
				continue;
#ifdef WIN32
			if(errno == WSAEWOULDBLOCK)
				return(PKC_NULL);
#else
			if(errno == EWOULDBLOCK)
				return(PKC_NULL);
#endif
			pkg_perror( errlog, "pkg_getclient: accept" );
			return(PKC_ERROR);
		}
	}  while( s2 < 0);
#ifdef FIONBIO
	if(nodelay)  {		
		onoff = 0;
		#ifdef WIN32
		if( ioctlsocket(fd, FIONBIO, &onoff) < 0 )
			pkg_perror( errlog, "pkg_getclient: FIONBIO 2" );
		if( ioctlsocket(s2, FIONBIO, &onoff) < 0 )
			pkg_perror( errlog, "pkg_getclient: FIONBIO 3");
#else
		if( ioctl(fd, FIONBIO, &onoff) < 0 )
			pkg_perror( errlog, "pkg_getclient: FIONBIO 2" );
		if( ioctl(s2, FIONBIO, &onoff) < 0 )
			pkg_perror( errlog, "pkg_getclient: FIONBIO 3");
#endif
	}
#endif

	return( pkg_makeconn(s2, switchp, errlog) );
}

/*
 *			P K G _ M A K E C O N N
 *
 *  Internal.
 *  Malloc and initialize a pkg_conn structure.
 *  We have already connected to a client or server on the given
 *  file descriptor.
 *
 *  Returns -
 *	>0		ptr to pkg_conn block of new connection
 *	PKC_ERROR	fatal error
 */
static
struct pkg_conn *
pkg_makeconn(int fd, struct pkg_switch *switchp, void (*errlog) (/* ??? */))
{
	register struct pkg_conn *pc;

	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_makeconn(fd=%d, switchp=x%lx, errlog=x%lx)\n",
			fd, (long)switchp, (long)errlog );
		fflush(pkg_debug);
	}

	/* Check for default error handler */
	if( errlog == NULL )
		errlog = pkg_errlog;

	if( (pc = (struct pkg_conn *)malloc(sizeof(struct pkg_conn)))==PKC_NULL )  {
		pkg_perror(errlog, "pkg_makeconn: malloc failure\n" );
		return(PKC_ERROR);
	}
	bzero( (char *)pc, sizeof(struct pkg_conn) );
	pc->pkc_magic = PKG_MAGIC;
	pc->pkc_fd = fd;
	pc->pkc_switch = switchp;
	pc->pkc_errlog = errlog;
	pc->pkc_left = -1;
	pc->pkc_buf = (char *)0;
	pc->pkc_curpos = (char *)0;
	pc->pkc_strpos = 0;
	pc->pkc_incur = pc->pkc_inend = 0;
	return(pc);
}

/*
 *  			P K G _ C L O S E
 *  
 *  Gracefully release the connection block and close the connection.
 */
void
pkg_close(register struct pkg_conn *pc)
{
	PKG_CK(pc);
	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_close(pc=x%lx) fd=%d\n",
			(long)pc, pc->pkc_fd );
		fflush(pkg_debug);
	}

	/* Flush any queued stream output first. */
	if( pc->pkc_strpos > 0 )  {
		(void)pkg_flush( pc );
	}

	if( pc->pkc_buf != (char *)0 )  {
		sprintf(errbuf,"pkg_close(x%lx):  partial input pkg discarded, buf=x%lx\n",
			(long)pc, (long)(pc->pkc_buf));
		pc->pkc_errlog(errbuf);
		(void)free( pc->pkc_buf );
	}
	if( pc->pkc_inbuf != (char *)0 )  {
		(void)free( pc->pkc_inbuf );
		pc->pkc_inbuf = (char *)0;
		pc->pkc_inlen = 0;
	}
	(void)close(pc->pkc_fd);
	pc->pkc_fd = -1;		/* safety */
	pc->pkc_buf = (char *)0;	/* safety */
	pc->pkc_magic = 0;		/* safety */
	(void)free( (char *)pc );
}

#if 0
/*
 *			P K G _ M R E A D
 *
 * Internal.
 * This function performs the function of a read(II) but will
 * call read(II) multiple times in order to get the requested
 * number of characters.  This can be necessary because pipes
 * and network connections don't deliver data with the same
 * grouping as it is written with.  Written by Robert S. Miles, BRL.
 *
 *  Superceeded by pkg_inget() in this version.
 *  This code is retained because of it's general usefulness.
 */
static int
pkg_mread(pc, bufp, n)
struct pkg_conn *pc;
register char	*bufp;
int	n;
{
	int fd;
	register int	count = 0;
	register int	nread;

	fd = pc->pkc_fd;
	do {
		nread = read(fd, bufp, (unsigned)n-count);
		if(nread < 0)  {
			pkg_perror(pc->pkc_errlog, "pkg_mread");
			return(-1);
		}
		if(nread == 0)
			return((int)count);
		count += (unsigned)nread;
		bufp += nread;
	 } while(count < n);

	return((int)count);
}
#endif

/*
 *  			P K G _ S E N D
 *
 *  Send the user's data, prefaced with an identifying header which
 *  contains a message type value.  All header fields are exchanged
 *  in "network order".
 *
 *  Note that the whole message (header + data) should be transmitted
 *  by TCP with only one TCP_PUSH at the end, due to the use of writev().
 *
 *  Returns number of bytes of user data actually sent.
 */
int
pkg_send(int type, char *buf, int len, register struct pkg_conn *pc)
{
#ifdef HAVE_WRITEV
	static struct iovec cmdvec[2];
#endif
	static struct pkg_header hdr;
	register int i;

	PKG_CK(pc);
	if( len < 0 )  len=0;

	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_send(type=%d, buf=x%lx, len=%d, pc=x%lx)\n",
			 type, (long)buf, len, (long)pc );
		fflush(pkg_debug);
	}

	/* Check for any pending input, no delay */
	/* Input may be read, but not acted upon, to prevent deep recursion */
	pkg_checkin( pc, 1 );

	/* Flush any queued stream output first. */
	if( pc->pkc_strpos > 0 )  {
		/*
		 * Buffered output is already queued, and needs to be
		 * flushed before sending this one.  If this pkg will
		 * also fit in the buffer, add it to the stream, and
		 * then send the whole thing with one flush.
		 * Otherwise, just flush, and proceed.
		 */
		if( len <= MAXQLEN && len <= PKG_STREAMLEN -
		    sizeof(struct pkg_header) - pc->pkc_strpos )  {
			(void)pkg_stream( type, buf, len, pc );
			return( (pkg_flush(pc) < 0) ? -1 : len );
		}
		if( pkg_flush( pc ) < 0 )
			return(-1);	/* assumes 2nd write would fail too */
	}

	pkg_pshort( hdr.pkh_magic, PKG_MAGIC );
	pkg_pshort( hdr.pkh_type, type );	/* should see if valid type */
	pkg_plong( hdr.pkh_len, (unsigned long)len );

#ifdef HAVE_WRITEV
	cmdvec[0].iov_base = (caddr_t)&hdr;
	cmdvec[0].iov_len = sizeof(hdr);
	cmdvec[1].iov_base = (caddr_t)buf;
	cmdvec[1].iov_len = len;

	/*
	 * TODO:  set this FD to NONBIO.  If not all output got sent,
	 * loop in select() waiting for capacity to go out, and
	 * reading input as well.  Prevents deadlocking.
	 */
	if( (i = writev( pc->pkc_fd, cmdvec, (len>0)?2:1 )) != len+sizeof(hdr) )  {
		if( i < 0 )  {
			pkg_perror(pc->pkc_errlog, "pkg_send: writev");
			return(-1);
		}
		sprintf(errbuf,"pkg_send of %d+%d, wrote %d\n",
			(int)sizeof(hdr), len, i);
		(pc->pkc_errlog)(errbuf);
		return(i-sizeof(hdr));	/* amount of user data sent */
	}
#else
	/*
	 *  On the assumption that buffer copying is less expensive than
	 *  having this transmission broken into two network packets
	 *  (with TCP, each with a "push" bit set),
	 *  merge it all into one buffer here, unless size is enormous.
	 */
	if( len + sizeof(hdr) <= 16*1024 )  {
		char	tbuf[16*1024];

		bcopy( (char *)&hdr, tbuf, sizeof(hdr) );
		if( len > 0 )
			bcopy( buf, tbuf+sizeof(hdr), len );
		if( (i = write( pc->pkc_fd, tbuf, len+sizeof(hdr) )) != len+sizeof(hdr) )  {
			if( i < 0 )  {
				if( errno == EBADF )  return(-1);
				pkg_perror(pc->pkc_errlog, "pkg_send: tbuf write");
				return(-1);
			}
			sprintf(errbuf,"pkg_send of %d, wrote %d\n",
				len, i-(int)sizeof(hdr) );
			(pc->pkc_errlog)(errbuf);
			return(i-sizeof(hdr));	/* amount of user data sent */
		}
		return(len);
	}
	/* Send them separately */
	if( (i = write( pc->pkc_fd, (char *)&hdr, sizeof(hdr) )) != sizeof(hdr) )  {
		if( i < 0 )  {
			if( errno == EBADF )  return(-1);
			pkg_perror(pc->pkc_errlog, "pkg_send: header write");
			return(-1);
		}
		sprintf(errbuf,"pkg_send header of %d, wrote %d\n",
			(int)sizeof(hdr), i);
		(pc->pkc_errlog)(errbuf);
		return(-1);		/* amount of user data sent */
	}
	if( len <= 0 )  return(0);
	if( (i = write( pc->pkc_fd, buf, len )) != len )  {
		if( i < 0 )  {
			if( errno == EBADF )  return(-1);
			pkg_perror(pc->pkc_errlog, "pkg_send: write");
			return(-1);
		}
		sprintf(errbuf,"pkg_send of %d, wrote %d\n", len, i);
		(pc->pkc_errlog)(errbuf);
		return(i);		/* amount of user data sent */
	}
#endif
	return(len);
}

/*
 *			P K G _ 2 S E N D
 *
 *  Exactly like pkg_send, except user's data is located in
 *  two disjoint buffers, rather than one.
 *  Fiendishly useful!
 */
int
pkg_2send(int type, char *buf1, int len1, char *buf2, int len2, register struct pkg_conn *pc)
{
#ifdef HAVE_WRITEV
	static struct iovec cmdvec[3];
#endif
	static struct pkg_header hdr;
	register int i;

	PKG_CK(pc);
	if( len1 < 0 )  len1=0;
	if( len2 < 0 )  len2=0;

	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_send2(type=%d, buf1=x%lx, len1=%d, buf2=x%lx, len2=%d, pc=x%lx)\n",
			 type, (long)buf1, len1, (long)buf2, len2, (long)pc );
		fflush(pkg_debug);
	}

	/* Check for any pending input, no delay */
	/* Input may be read, but not acted upon, to prevent deep recursion */
	pkg_checkin( pc, 1 );

	/* Flush any queued stream output first. */
	if( pc->pkc_strpos > 0 )  {
		if( pkg_flush( pc ) < 0 )
			return(-1);	/* assumes 2nd write would fail too */
	}

	pkg_pshort( hdr.pkh_magic, PKG_MAGIC );
	pkg_pshort( hdr.pkh_type, type );	/* should see if valid type */
	pkg_plong( hdr.pkh_len, (unsigned long)(len1+len2) );

#ifdef HAVE_WRITEV
	cmdvec[0].iov_base = (caddr_t)&hdr;
	cmdvec[0].iov_len = sizeof(hdr);
	cmdvec[1].iov_base = (caddr_t)buf1;
	cmdvec[1].iov_len = len1;
	cmdvec[2].iov_base = (caddr_t)buf2;
	cmdvec[2].iov_len = len2;

	/*
	 * TODO:  set this FD to NONBIO.  If not all output got sent,
	 * loop in select() waiting for capacity to go out, and
	 * reading input as well.  Prevents deadlocking.
	 */
	if( (i = writev(pc->pkc_fd, cmdvec, 3)) != len1+len2+sizeof(hdr) )  {
		if( i < 0 )  {
			pkg_perror(pc->pkc_errlog, "pkg_2send: writev");
			sprintf( errbuf,
				"pkg_send2(type=%d, buf1=x%x, len1=%d, buf2=x%x, len2=%d, pc=x%x)\n",
				 type, (unsigned int)buf1, len1, 
				 (unsigned int)buf2, len2, (unsigned int)pc );
			(pc->pkc_errlog)(errbuf);
			return(-1);
		}
		sprintf(errbuf,"pkg_2send of %d+%d+%d, wrote %d\n",
			(int)sizeof(hdr), len1, len2, i);
		(pc->pkc_errlog)(errbuf);
		return(i-sizeof(hdr));	/* amount of user data sent */
	}
#else
	/*
	 *  On the assumption that buffer copying is less expensive than
	 *  having this transmission broken into two network packets
	 *  (with TCP, each with a "push" bit set),
	 *  merge it all into one buffer here, unless size is enormous.
	 */
	if( len1 + len2 + sizeof(hdr) <= 16*1024 )  {
		char	tbuf[16*1024];

		bcopy( (char *)&hdr, tbuf, sizeof(hdr) );
		if( len1 > 0 )
			bcopy( buf1, tbuf+sizeof(hdr), len1 );
		if( len2 > 0 )
			bcopy( buf2, tbuf+sizeof(hdr)+len1, len2 );
		if( (i = write( pc->pkc_fd, tbuf, len1+len2+sizeof(hdr) )) != len1+len2+sizeof(hdr) )  {
			if( i < 0 )  {
				if( errno == EBADF )  return(-1);
				pkg_perror(pc->pkc_errlog, "pkg_2send: tbuf write");
				return(-1);
			}
			sprintf(errbuf,"pkg_2send of %d+%d, wrote %d\n",
				len1, len2, i-(int)sizeof(hdr) );
			(pc->pkc_errlog)(errbuf);
			return(i-sizeof(hdr));	/* amount of user data sent */
		}
		return(len1+len2);
	}
	/* Send it in three pieces */
	if( (i = write( pc->pkc_fd, (char *)&hdr, sizeof(hdr) )) != sizeof(hdr) )  {
		if( i < 0 )  {
			if( errno == EBADF )  return(-1);
			pkg_perror(pc->pkc_errlog, "pkg_2send: header write");
			sprintf(errbuf, "pkg_2send write(%d, x%lx, %d) ret=%d\n",
				pc->pkc_fd, (long)&hdr, (int)sizeof(hdr), i );
			(pc->pkc_errlog)(errbuf);
			return(-1);
		}
		sprintf(errbuf,"pkg_2send of %d+%d+%d, wrote header=%d\n",
			(int)sizeof(hdr), len1, len2, i );
		(pc->pkc_errlog)(errbuf);
		return(-1);		/* amount of user data sent */
	}
	if( (i = write( pc->pkc_fd, buf1, len1 )) != len1 )  {
		if( i < 0 )  {
			if( errno == EBADF )  return(-1);
			pkg_perror(pc->pkc_errlog, "pkg_2send: write buf1");
			sprintf(errbuf, "pkg_2send write(%d, x%lx, %d) ret=%d\n",
				pc->pkc_fd, (long)buf1, len1, i );
			(pc->pkc_errlog)(errbuf);
			return(-1);
		}
		sprintf(errbuf,"pkg_2send of %d+%d+%d, wrote len1=%d\n",
			(int)sizeof(hdr), len1, len2, i );
		(pc->pkc_errlog)(errbuf);
		return(i);		/* amount of user data sent */
	}
	if( len2 <= 0 )  return(i);
	if( (i = write( pc->pkc_fd, buf2, len2 )) != len2 )  {
		if( i < 0 )  {
			if( errno == EBADF )  return(-1);
			pkg_perror(pc->pkc_errlog, "pkg_2send: write buf2");
			sprintf(errbuf, "pkg_2send write(%d, x%lx, %d) ret=%d\n",
				pc->pkc_fd, (long)buf2, len2, i );
			(pc->pkc_errlog)(errbuf);
			return(-1);
		}
		sprintf(errbuf,"pkg_2send of %d+%d+%d, wrote len2=%d\n",
			(int)sizeof(hdr), len1, len2, i );
		(pc->pkc_errlog)(errbuf);
		return(len1+i);		/* amount of user data sent */
	}
#endif
	return(len1+len2);
}

/*
 *  			P K G _ S T R E A M
 *
 *  Exactly like pkg_send except no "push" is necessary here.
 *  If the packet is sufficiently small (MAXQLEN) it will be placed
 *  in the pkc_stream buffer (after flushing this buffer if there
 *  insufficient room).  If it is larger than this limit, it is sent
 *  via pkg_send (who will do a pkg_flush if there is already data in
 *  the stream queue).
 *
 *  Returns number of bytes of user data actually sent (or queued).
 */
int
pkg_stream(int type, char *buf, int len, register struct pkg_conn *pc)
{
	static struct pkg_header hdr;

	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_stream(type=%d, buf=x%lx, len=%d, pc=x%lx)\n",
			 type, (long)buf, len, (long)pc );
		fflush(pkg_debug);
	}

	if( len > MAXQLEN )
		return( pkg_send(type, buf, len, pc) );

	if( len > PKG_STREAMLEN - sizeof(struct pkg_header) - pc->pkc_strpos )
		pkg_flush( pc );

	/* Queue it */
	pkg_pshort( hdr.pkh_magic, PKG_MAGIC );
	pkg_pshort( hdr.pkh_type, type );	/* should see if valid type */
	pkg_plong( hdr.pkh_len, (unsigned long)len );

	bcopy( (char *)&hdr, &(pc->pkc_stream[pc->pkc_strpos]),
		sizeof(struct pkg_header) );
	pc->pkc_strpos += sizeof(struct pkg_header);
	bcopy( buf, &(pc->pkc_stream[pc->pkc_strpos]), len );
	pc->pkc_strpos += len;

	return( len + sizeof(struct pkg_header) );
}

/*
 *  			P K G _ F L U S H
 *
 *  Flush any pending data in the pkc_stream buffer.
 *
 *  Returns < 0 on failure, else number of bytes sent.
 */
int
pkg_flush(register struct pkg_conn *pc)
{
	register int	i;

	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_flush( pc=x%lx )\n",
			(long)pc );
		fflush(pkg_debug);
	}

	if( pc->pkc_strpos <= 0 ) {
		pc->pkc_strpos = 0;	/* sanity for < 0 */
		return( 0 );
	}

	if( (i = write(pc->pkc_fd,pc->pkc_stream,pc->pkc_strpos)) != pc->pkc_strpos )  {
		if( i < 0 ) {
			if( errno == EBADF )  return(-1);
			pkg_perror(pc->pkc_errlog, "pkg_flush: write");
			return(-1);
		}
		sprintf(errbuf,"pkg_flush of %d, wrote %d\n",
			pc->pkc_strpos, i);
		(pc->pkc_errlog)(errbuf);
		pc->pkc_strpos -= i;
		/* copy leftovers to front of stream */
		bcopy(pc->pkc_stream + i, pc->pkc_stream, pc->pkc_strpos);
		return( i );	/* amount of user data sent */
	}
	pc->pkc_strpos = 0;
	return( i );
}

/*
 *  			P K G _ W A I T F O R
 *
 *  This routine implements a blocking read on the network connection
 *  until a message of 'type' type is received.  This can be useful for
 *  implementing the synchronous portions of a query/reply exchange.
 *  All messages of any other type are processed by pkg_block().
 *
 *  Returns the length of the message actually received, or -1 on error.
 */
int
pkg_waitfor(int type, char *buf, int len, register struct pkg_conn *pc)
{
	register int i;

	PKG_CK(pc);
	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_waitfor(type=%d, buf=x%lx, len=%d, pc=x%lx)\n",
			type, (long)buf, len, (long)pc );
		fflush(pkg_debug);
	}
again:
	if( pc->pkc_left >= 0 )  {
		/* Finish up remainder of partially received message */
		if( pkg_block( pc ) < 0 )
			return(-1);
	}

	if( pc->pkc_buf != (char *)0 )  {
		pc->pkc_errlog("pkg_waitfor:  buffer clash\n");
		return(-1);
	}
	if( pkg_gethdr( pc, buf ) < 0 )  return(-1);
	if( pc->pkc_type != type )  {
		/* A message of some other type has unexpectedly arrived. */
		if( pc->pkc_len > 0 )  {
			if( (pc->pkc_buf = (char *)malloc(pc->pkc_len+2)) == NULL )  {
				pkg_perror(pc->pkc_errlog, "pkg_waitfor: malloc failed");
				return(-1);
			}
			pc->pkc_curpos = pc->pkc_buf;
		}
		goto again;
	}
	pc->pkc_left = -1;
	if( pc->pkc_len == 0 )
		return(0);

	/* See if incomming message is larger than user's buffer */
	if( pc->pkc_len > len )  {
		register char *bp;
		int excess;
		sprintf(errbuf,
			"pkg_waitfor:  message %ld exceeds buffer %d\n",
			pc->pkc_len, len );
		(pc->pkc_errlog)(errbuf);
		if( (i = pkg_inget( pc, buf, len )) != len )  {
			sprintf(errbuf,
				"pkg_waitfor:  pkg_inget %d gave %d\n", len, i );
			(pc->pkc_errlog)(errbuf);
			return(-1);
		}
		excess = pc->pkc_len - len;	/* size of excess message */
		if( (bp = (char *)malloc(excess)) == NULL )  {
			pkg_perror(pc->pkc_errlog, "pkg_waitfor: excess message, malloc failed");
			return(-1);
		}
		if( (i = pkg_inget( pc, bp, excess )) != excess )  {
			sprintf(errbuf,
				"pkg_waitfor: pkg_inget of excess, %d gave %d\n",
				excess, i );
			(pc->pkc_errlog)(errbuf);
			(void)free(bp);
			return(-1);
		}
		(void)free(bp);
		return(len);		/* truncated, but OK */
	}

	/* Read the whole message into the users buffer */
	if( (i = pkg_inget( pc, buf, pc->pkc_len )) != pc->pkc_len )  {
		sprintf(errbuf,
			"pkg_waitfor:  pkg_inget %ld gave %d\n",
			pc->pkc_len, i );
		(pc->pkc_errlog)(errbuf);
		return(-1);
	}
	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_waitfor() message type=%d arrived\n", type);
		fflush(pkg_debug);
	}
	pc->pkc_buf = (char *)0;
	pc->pkc_curpos = (char *)0;
	pc->pkc_left = -1;		/* safety */
	return( pc->pkc_len );
}

/*
 *  			P K G _ B W A I T F O R
 *
 *  This routine implements a blocking read on the network connection
 *  until a message of 'type' type is received.  This can be useful for
 *  implementing the synchronous portions of a query/reply exchange.
 *  All messages of any other type are processed by pkg_block().
 *
 *  The buffer to contain the actual message is acquired via malloc(),
 *  and the caller must free it.
 *
 *  Returns pointer to message buffer, or NULL.
 */
char *
pkg_bwaitfor(int type, register struct pkg_conn *pc)
{
	register int i;
	register char *tmpbuf;

	PKG_CK(pc);
	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_bwaitfor(type=%d, pc=x%lx)\n",
			type, (long)pc );
		fflush(pkg_debug);
	}
	do  {
		/* Finish any unsolicited msg */
		if( pc->pkc_left >= 0 )
			if( pkg_block(pc) < 0 )
				return((char *)0);
		if( pc->pkc_buf != (char *)0 )  {
			pc->pkc_errlog("pkg_bwaitfor:  buffer clash\n");
			return((char *)0);
		}
		if( pkg_gethdr( pc, (char *)0 ) < 0 )
			return((char *)0);
	}  while( pc->pkc_type != type );

	pc->pkc_left = -1;
	if( pc->pkc_len == 0 )
		return((char *)0);

	/* Read the whole message into the dynamic buffer */
	if( (i = pkg_inget( pc, pc->pkc_buf, pc->pkc_len )) != pc->pkc_len )  {
		sprintf(errbuf,
			"pkg_bwaitfor:  pkg_inget %ld gave %d\n", pc->pkc_len, i );
		(pc->pkc_errlog)(errbuf);
	}
	tmpbuf = pc->pkc_buf;
	pc->pkc_buf = (char *)0;
	pc->pkc_curpos = (char *)0;
	pc->pkc_left = -1;		/* safety */
	/* User must free the buffer */
	return( tmpbuf );
}

/*
 *  			P K G _ P R O C E S S
 *
 *
 *  This routine should be called to process all PKGs that are
 *  stored in the internal buffer pkc_inbuf.  This routine does
 *  no I/O, and is used in a "polling" paradigm.
 *
 *  Only after pkg_process() has been called on all PKG connections
 *  should the user process suspend itself in a select() operation,
 *  otherwise packages that have been read into the internal buffer
 *  will remain unprocessed, potentially forever.
 *
 *  If an error code is returned, then select() must NOT be called
 *  until pkg_process has been called again.
 *
 *  A plausable code sample might be:
 *
 *	for(;;)  {
 *		if( pkg_process( pc ) < 0 )  {
 *			printf("pkg_process error encountered\n");
 *			continue;
 *		}
 *		if( bsdselect( pc->pkc_fd, 99, 0 ) != 0 )  {
 *			if( pkg_suckin( pc ) <= 0 )  {
 *				printf("pkg_suckin error or EOF\n");
 *				break;
 *			}
 *		}
 *		if( pkg_process( pc ) < 0 )  {
 *			printf("pkg_process error encountered\n");
 *			continue;
 *		}
 *		do_other_stuff();
 *	}
 *
 *  Note that the first call to pkg_process() handles all buffered packages
 *  before a potentially long delay in select().
 *  The second call to pkg_process() handles any new packages obtained
 *  either directly by pkg_suckin() or as a byproduct of a handler.
 *  This double checking is absolutely necessary, because
 *  the use of pkg_send() or other pkg routines either in the actual
 *  handlers or in do_other_stuff() can cause pkg_suckin() to be
 *  called to bring in more packages.
 *
 *  Returns -
 *	<0	some internal error encountered; DO NOT call select() next.
 *	 0	All ok, no packages processed
 *	>0	All ok, return is # of packages processed (for the curious)
 */
int
pkg_process(register struct pkg_conn *pc)
{
	register int	len;
	register int	available;
	register int	errcnt;
	register int	ret;
	int		goodcnt;

	goodcnt = 0;

	PKG_CK(pc);
	/* This loop exists only to cut off "hard" errors */
	for( errcnt=0; errcnt < 500; )  {
		available = pc->pkc_inend - pc->pkc_incur;	/* amt in input buf */
		if( pkg_debug )  {
			if( pc->pkc_left < 0 )  {
				sprintf(errbuf, "awaiting new header");
			} else if( pc->pkc_left > 0 )  {
				sprintf(errbuf, "need more data");
			} else {
				sprintf(errbuf, "pkg is all here");
			}
			pkg_timestamp();
			fprintf( pkg_debug,
				"pkg_process(pc=x%lx) pkc_left=%d %s (avail=%d)\n",
				(long)pc, pc->pkc_left, errbuf, available );
			fflush(pkg_debug);
		}
		if( pc->pkc_left < 0 )  {
			/*
			 *  Need to get a new PKG header.
			 *  Do so ONLY if the full header is already in the
			 *  internal buffer, to prevent blocking in pkg_gethdr().
			 */
			if( available < sizeof(struct pkg_header) )
				break;

			if( pkg_gethdr( pc, (char *)0 ) < 0 )  {
				DMSG("pkg_gethdr < 0\n");
				errcnt++;
				continue;
			}

			if( pc->pkc_left < 0 )  {
				/* pkg_gethdr() didn't get a header */
				DMSG("pkc_left still < 0 after pkg_gethdr()\n");
				errcnt++;
				continue;
			}
		}
		/*
		 *  Now pkc_left >= 0, implying header has been obtained.
		 *  Find amount still available in input buffer.
		 */
		available = pc->pkc_inend - pc->pkc_incur;

		/* copy what is here already, and dispatch when all here */
		if( pc->pkc_left > 0 )  {
			if( available <= 0 )  break;

			/* Sanity check -- buffer must be allocated by now */
			if( pc->pkc_curpos == 0 )  {
				DMSG("curpos=0\n");
				errcnt++;
				continue;
			}

			if( available > pc->pkc_left )  {
				/* There is more in input buf than just this pkg */
				len = pc->pkc_left; /* trim to amt needed */
			} else {
				/* Take all that there is */
				len = available;
			}
			len = pkg_inget( pc, pc->pkc_curpos, len );
			pc->pkc_curpos += len;
			pc->pkc_left -= len;
			if( pc->pkc_left > 0 )  {
				/*
				 *  Input buffer is exhausted, but more
				 *  data is needed to finish this package.
				 */
				break;
			}
		}

		if( pc->pkc_left != 0 )  {
			/* Somehow, a full PKG has not yet been obtained */
			DMSG("pkc_left != 0\n");
			errcnt++;
			continue;
		}

		/* Now, pkc_left == 0, dispatch the message */
		if( pkg_dispatch(pc) <= 0 )  {
			/* something bad happened */
			DMSG("pkg_dispatch failed\n");
			errcnt++;
		} else {
			/* it worked */
			goodcnt++;
		}
	}

	if( errcnt > 0 )  {
		ret = -errcnt;
	} else {
		ret = goodcnt;
	}

	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_process() ret=%d, pkc_left=%d, errcnt=%d, goodcnt=%d\n",
			ret, pc->pkc_left, errcnt, goodcnt);
		fflush(pkg_debug);
	}
	return( ret );
}

/*
 *			P K G _ D I S P A T C H
 *
 *  Internal.
 *  Given that a whole message has arrived, send it to the appropriate
 *  User Handler, or else grouse.
 *  Returns -1 on fatal error, 0 on no handler, 1 if all's well.
 */
static int
pkg_dispatch(register struct pkg_conn *pc)
{
	register int i;

	PKG_CK(pc);
	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_dispatch(pc=x%lx) type=%d, buf=x%lx, len=%ld\n",
			(long)pc, pc->pkc_type, (long)(pc->pkc_buf), pc->pkc_len );
		fflush(pkg_debug);
	}
	if( pc->pkc_left != 0 )  return(-1);

	/* Whole message received, process it via switchout table */
	for( i=0; pc->pkc_switch[i].pks_handler != NULL; i++ )  {
		register char *tempbuf;

		if( pc->pkc_switch[i].pks_type != pc->pkc_type )
			continue;
		/*
		 * NOTICE:  User Handler must free() message buffer!
		 * WARNING:  Handler may recurse back to pkg_suckin() --
		 * reset all connection state variables first!
		 */
		tempbuf = pc->pkc_buf;
		pc->pkc_buf = (char *)0;
		pc->pkc_curpos = (char *)0;
		pc->pkc_left = -1;		/* safety */
		/* pc->pkc_type, pc->pkc_len are preserved for handler */
		pc->pkc_switch[i].pks_handler(pc, tempbuf);
		return(1);
	}
	sprintf(errbuf,"pkg_dispatch:  no handler for message type %d, len %ld\n",
		pc->pkc_type, pc->pkc_len );
	(pc->pkc_errlog)(errbuf);
	(void)free(pc->pkc_buf);
	pc->pkc_buf = (char *)0;
	pc->pkc_curpos = (char *)0;
	pc->pkc_left = -1;		/* safety */
	return(0);
}
/*
 *			P K G _ G E T H D R
 *
 *  Internal.
 *  Get header from a new message.
 *  Returns:
 *	1	when there is some message to go look at
 *	-1	on fatal errors
 */
static int
pkg_gethdr(register struct pkg_conn *pc, char *buf)
{
	register int i;

	PKG_CK(pc);
	if( pc->pkc_left >= 0 )  return(1);	/* go get it! */

	/*
	 *  At message boundary, read new header.
	 *  This will block until the new header arrives (feature).
	 */
	if( (i = pkg_inget( pc, (char *)&(pc->pkc_hdr),
	    sizeof(struct pkg_header) )) != sizeof(struct pkg_header) )  {
		if(i > 0) {
			sprintf(errbuf,"pkg_gethdr: header read of %d?\n", i);
			(pc->pkc_errlog)(errbuf);
		}
		return(-1);
	}
	while( pkg_gshort(pc->pkc_hdr.pkh_magic) != PKG_MAGIC )  {
		int	c;
		c = *((unsigned char *)&pc->pkc_hdr);
		if( isascii(c) && isprint(c) )  {
			sprintf(errbuf,
				"pkg_gethdr: skipping noise x%x %c\n",
				c, c );
		} else {
			sprintf(errbuf,
				"pkg_gethdr: skipping noise x%x\n",
				c );
		}
		(pc->pkc_errlog)(errbuf);
		/* Slide over one byte and try again */
		bcopy( ((char *)&pc->pkc_hdr)+1, (char *)&pc->pkc_hdr, sizeof(struct pkg_header)-1);
		if( (i=pkg_inget( pc,
		    ((char *)&pc->pkc_hdr)+sizeof(struct pkg_header)-1,
		    1 )) != 1 )  {
			sprintf(errbuf,"pkg_gethdr: hdr read=%d?\n",i);
		    	(pc->pkc_errlog)(errbuf);
			return(-1);
		}
	}
	pc->pkc_type = pkg_gshort(pc->pkc_hdr.pkh_type);	/* host order */
	pc->pkc_len = pkg_glong(pc->pkc_hdr.pkh_len);
	if( pc->pkc_len < 0 )  pc->pkc_len = 0;
	pc->pkc_buf = (char *)0;
	pc->pkc_left = pc->pkc_len;
	if( pc->pkc_left == 0 )  return(1);		/* msg here, no data */

	if( buf )  {
		pc->pkc_buf = buf;
	} else {
		/* Prepare to read message into dynamic buffer */
		if( (pc->pkc_buf = (char *)malloc(pc->pkc_len+2)) == NULL )  {
			pkg_perror(pc->pkc_errlog, "pkg_gethdr: malloc fail");
			return(-1);
		}
	}
	pc->pkc_curpos = pc->pkc_buf;
	return(1);			/* something ready */
}

/*
 *  			P K G _ B L O C K
 *  
 *  This routine blocks, waiting for one complete message to arrive from
 *  the network.  The actual handling of the message is done with
 *  pkg_dispatch(), which invokes the user-supplied message handler.
 *
 *  This routine can be used in a loop to pass the time while waiting
 *  for a flag to be changed by the arrival of an asynchronous message,
 *  or for the arrival of a message of uncertain type.
 *
 *  The companion routine is pkg_process(), which does not block.
 *  
 *  Control returns to the caller after one full message is processed.
 *  Returns -1 on error, etc.
 */
int
pkg_block(register struct pkg_conn *pc)
{
	PKG_CK(pc);
	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_block(pc=x%lx)\n",
			(long)pc );
		fflush(pkg_debug);
	}

	/* If no read operation going now, start one. */
	if( pc->pkc_left < 0 )  {
		if( pkg_gethdr( pc, (char *)0 ) < 0 )  return(-1);
		/* Now pkc_left >= 0 */
	}

	/* Read the rest of the message, blocking if necessary */
	if( pc->pkc_left > 0 )  {
		if( pkg_inget( pc, pc->pkc_curpos, pc->pkc_left ) != pc->pkc_left )  {
			pc->pkc_left = -1;
			return(-1);
		}
		pc->pkc_left = 0;
	}

	/* Now, pkc_left == 0, dispatch the message */
	return( pkg_dispatch(pc) );
}


/*
 *			P K G _ P E R R O R
 *
 *  Produce a perror on the error logging output.
 */
static void
pkg_perror(void (*errlog) (/* ??? */), char *s)
{

#if HAVE_STRERROR_R
	int ret = 0;
	sprintf( errbuf, "%s: ", s);
	if ((errno >= 0) && (strlen(errbuf) < MAX_ERRBUF_SIZE)) {
	       	ret = strerror_r(errno, errbuf+strlen(errbuf), MAX_ERRBUF_SIZE-strlen(errbuf));
		if (ret != 0) {
			sprintf(errbuf, "%s: errno=%d\n", s, errno);
		}
#else
	if ( errno >= 0 && errno < sys_nerr ) {
		sprintf( errbuf, "%s: %s\n", s, sys_errlist[errno] );
#endif
		errlog( errbuf );
	} else {
		sprintf( errbuf, "%s: errno=%d\n", s, errno );
		errlog( errbuf );
	}
}

/*
 *			P K G _ E R R L O G
 *
 *  Default error logger.  Writes to stderr.
 */
static void
pkg_errlog(char *s)
{
	if( pkg_debug )  {
		pkg_timestamp();
		fputs( s, pkg_debug );
		fflush(pkg_debug);
	}
	fputs( s, stderr );
}

/*
 *			P K G _ C K _ D E B U G
 */
static void
pkg_ck_debug(void)
{
	char	*place;
	char	buf[128];

	if( pkg_debug )  return;
	if( (place = (char *)getenv("LIBPKG_DEBUG")) == (char *)0 )  {
		sprintf( buf, "/tmp/pkg.log" );
		place = buf;
	}
	/* Named file must exist and be writeable */
	if( access( place, 2 ) < 0 )  return;
	if( (pkg_debug = fopen( place, "a" )) == NULL )  return;

	/* Log version number of this code */
	pkg_timestamp();
#ifndef lint
	fprintf( pkg_debug, "pkg_ck_debug %s\n", RCSid );
#endif
}

/*
 *			P K G _ T I M E S T A M P
 *
 *  Output a timestamp to the log, suitable for starting each line with.
 */
static void
pkg_timestamp(void)
{
	time_t		now;
	struct tm	*tmp;

	if( !pkg_debug )  return;
	(void)time( &now );
	tmp = localtime( &now );
	fprintf(pkg_debug, "%2.2d/%2.2d %2.2d:%2.2d:%2.2d [%5d] ",
		tmp->tm_mon+1, tmp->tm_mday,
		tmp->tm_hour, tmp->tm_min, tmp->tm_sec,
		getpid() );
	/* Don't fflush here, wait for rest of line */
}

/*
 *			P K G _ S U C K I N
 *
 *  Suck all data from the operating system into the internal buffer.
 *  This is done with large buffers, to maximize the efficiency of the
 *  data transfer from kernel to user.
 *
 *  It is expected that the read() system call will return as much
 *  data as the kernel has, UP TO the size indicated.
 *  The only time the read() may be expected to block is when the
 *  kernel does not have any data at all.
 *  Thus, it is wise to call call this routine only if:
 *	a)  select() has indicated the presence of data, or
 *	b)  blocking is acceptable.
 *
 *  This routine is the only place where data is taken off the network.
 *  All input is appended to the internal buffer for later processing.
 *
 *  Subscripting was used for pkc_incur/pkc_inend to avoid having to
 *  recompute pointers after a realloc().
 *
 *  Returns -
 *	-1	on error
 *	 0	on EOF
 *	 1	success
 */
int
pkg_suckin(register struct pkg_conn *pc)
{
	int	avail;
	int	got;
	int	ret;

	got = 0;
	PKG_CK(pc);

	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_suckin() incur=%d, inend=%d, inlen=%d\n",
			pc->pkc_incur, pc->pkc_inend, pc->pkc_inlen );
		fflush(pkg_debug);
	}

	/* If no buffer allocated yet, get one */
	if( pc->pkc_inbuf == (char *)0 || pc->pkc_inlen <= 0 )  {
		pc->pkc_inlen = PKG_STREAMLEN;
		if( (pc->pkc_inbuf = (char *)malloc(pc->pkc_inlen)) == (char *)0 )  {
			pc->pkc_errlog("pkg_suckin malloc failure\n");
			pc->pkc_inlen = 0;
			ret = -1;
			goto out;
		}
		pc->pkc_incur = pc->pkc_inend = 0;
	}

	if( pc->pkc_incur >= pc->pkc_inend )  {
		/* Reset to beginning of buffer */
		pc->pkc_incur = pc->pkc_inend = 0;
	}

	/* If cur point is near end of buffer, recopy data to buffer front */
	if( pc->pkc_incur >= (pc->pkc_inlen * 7) / 8 )  {
		register int	ammount;

		ammount = pc->pkc_inend - pc->pkc_incur;
		/* This copy can not overlap itself, because of 7/8 above */
		bcopy( &pc->pkc_inbuf[pc->pkc_incur],
			pc->pkc_inbuf, ammount );
		pc->pkc_incur = 0;
		pc->pkc_inend = ammount;
	}

	/* If remaining buffer space is small, make buffer bigger */
	avail = pc->pkc_inlen - pc->pkc_inend;
	if( avail < 10 * sizeof(struct pkg_header) )  {
		pc->pkc_inlen <<= 1;
		if( pkg_debug)  {
			pkg_timestamp();
			fprintf(pkg_debug,
				"pkg_suckin: realloc inbuf to %d\n",
				pc->pkc_inlen );
			fflush(pkg_debug);
		}
		if( (pc->pkc_inbuf = (char *)realloc(pc->pkc_inbuf, pc->pkc_inlen)) == (char *)0 )  {
			pc->pkc_errlog("pkg_suckin realloc failure\n");
			pc->pkc_inlen = 0;
			ret = -1;
			goto out;
		}
		/* since the input buffer has grown, lets update avail */
		avail = pc->pkc_inlen - pc->pkc_inend;
	}

	/* Take as much as the system will give us, up to buffer size */
	if( (got = read( pc->pkc_fd, &pc->pkc_inbuf[pc->pkc_inend], avail )) <= 0 )  {
		if( got == 0 )  {
			if( pkg_debug )  {
				pkg_timestamp();
				fprintf(pkg_debug,
					"pkg_suckin: fd=%d, read for %d returned 0\n",
					avail, pc->pkc_fd );
				fflush(pkg_debug);
			}
			ret = 0;	/* EOF */
			goto out;
		}
		pkg_perror(pc->pkc_errlog, "pkg_suckin: read");
		sprintf(errbuf, "pkg_suckin: read(%d, x%lx, %d) ret=%d inbuf=x%lx, inend=%d\n",
			pc->pkc_fd, (long)(&pc->pkc_inbuf[pc->pkc_inend]), avail,
			got,
			(long)(pc->pkc_inbuf), pc->pkc_inend );
		(pc->pkc_errlog)(errbuf);
		ret = -1;
		goto out;
	}
	if( got > avail )  {
		pc->pkc_errlog("pkg_suckin:  read more bytes than desired\n");
		got = avail;
	}
	pc->pkc_inend += got;
	ret = 1;
out:
	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_suckin() ret=%d, got %d, total=%d\n",
			ret, got, pc->pkc_inend - pc->pkc_incur );
		fflush(pkg_debug);
	}
	return(ret);
}

/*
 *			P K G _ C H E C K I N
 *
 *  This routine is called whenever it is necessary to see if there
 *  is more input that can be read.
 *  If input is available, it is read into pkc_inbuf[].
 *  If nodelay is set, poll without waiting.
 */
static void
pkg_checkin(register struct pkg_conn *pc, int nodelay)
{
	struct timeval	tv;
	fd_set		bits;
	register int	i, j;
	extern int	errno;

	/* Check socket for unexpected input */
	tv.tv_sec = 0;
	if( nodelay )
		tv.tv_usec = 0;		/* poll -- no waiting */
	else
		tv.tv_usec = 20000;	/* 20 ms */

	FD_ZERO(&bits);
	FD_SET(pc->pkc_fd, &bits);
	i = select( pc->pkc_fd+1, &bits, (fd_set *)0, (fd_set *)0, &tv );
	if( pkg_debug )  {
		pkg_timestamp();
		fprintf(pkg_debug,
			"pkg_checkin: select on fd %d returned %d\n",
			pc->pkc_fd,
			i );
		fflush(pkg_debug);
	}
	if( i > 0 )  {
		for( j = 0; j < FD_SETSIZE; j++ ) 
			if( FD_ISSET( j, &bits ) ) break;
			
		if( j < FD_SETSIZE )  {
			/* Some fd is ready for I/O */
			(void)pkg_suckin(pc);
		} else {
			/* Odd condition, bits! */
			sprintf(errbuf,
				"pkg_checkin: select returned %d, bits=0\n",
				i );
			(pc->pkc_errlog)(errbuf);
		}
	} else if( i < 0 )  {
		/* Error condition */
		if( errno != EINTR && errno != EBADF )
			pkg_perror(pc->pkc_errlog, "pkg_checkin: select");
	}
}

/*
 *			P K G _ I N G E T
 *
 *  A functional replacement for mread(), through the
 *  first level input buffer.
 *  This will block if the required number of bytes are not available.
 *  The number of bytes actually transferred is returned.
 */
int
pkg_inget(register struct pkg_conn *pc, char *buf, int count)
{
	register int	len;
	register int	todo = count;

	while( todo > 0 )  {
		
		while( (len = pc->pkc_inend - pc->pkc_incur) <= 0 )  {
			/* This can block */
			if( pkg_suckin( pc ) < 1 )
				return( count - todo );
		}
		/* Input Buffer has some data in it, move to caller's buffer */
		if( len > todo )  len = todo;
		bcopy( &pc->pkc_inbuf[pc->pkc_incur], buf, len );
		pc->pkc_incur += len;
		buf += len;
		todo -= len;
	}
	return( count );
}
@


11.14
log
@change conf.h to a wrapped config.h
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/libpkg/pkg.c,v 11.13 2004/04/05 07:51:26 morrison Exp $ (BRL)";
@


11.13
log
@merge of ansi-6-0-branch into HEAD
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d42 5
a46 1
#include "conf.h"
@


11.12
log
@merge of windows-6-0-branch into head
@
text
@d114 5
a118 5
static struct pkg_conn *pkg_makeconn();
static void pkg_errlog();
static void pkg_perror();
static int pkg_dispatch();
static int pkg_gethdr();
d120 2
a121 1
static char errbuf[80];
d123 3
a125 3
static void	pkg_ck_debug();
static void	pkg_timestamp();
static void	pkg_checkin();
d152 1
a152 2
pkg_gshort(msgp)
unsigned char *msgp;
d172 1
a172 2
pkg_glong(msgp)
unsigned char *msgp;
d187 1
a187 3
pkg_pshort(msgp, s)
unsigned char *msgp;
unsigned short s;
d199 1
a199 3
pkg_plong(msgp, l)
unsigned char *msgp;
unsigned long l;
d217 1
a217 8
pkg_open( host, service, protocol, uname, passwd, switchp, errlog )
char *host;
char *service;
char *protocol;
char *uname;
char *passwd;
struct pkg_switch *switchp;
void (*errlog)();
d325 1
a325 3
pkg_transerver( switchp, errlog )
struct pkg_switch *switchp;
void (*errlog)();
d354 1
a354 5
pkg_permserver( service, protocol, backlog, errlog )
char *service;
char *protocol;
int backlog;
void (*errlog)();
d457 1
a457 3
pkg_getclient(fd, switchp, errlog, nodelay)
struct pkg_switch *switchp;
void (*errlog)();
d461 1
a461 1
	auto int fromlen = sizeof (from);
d499 2
a500 1
#endif			pkg_perror( errlog, "pkg_getclient: accept" );
d538 1
a538 3
pkg_makeconn(fd, switchp, errlog)
struct pkg_switch *switchp;
void (*errlog)();
d577 1
a577 2
pkg_close(pc)
register struct pkg_conn *pc;
d665 1
a665 5
pkg_send( type, buf, len, pc )
int type;
char *buf;
int len;
register struct pkg_conn *pc;
d792 1
a792 5
pkg_2send( type, buf1, len1, buf2, len2, pc )
int type;
char *buf1, *buf2;
int len1, len2;
register struct pkg_conn *pc;
d943 1
a943 5
pkg_stream( type, buf, len, pc )
int type;
char *buf;
int len;
register struct pkg_conn *pc;
d983 1
a983 2
pkg_flush( pc )
register struct pkg_conn *pc;
d1029 1
a1029 5
pkg_waitfor( type, buf, len, pc )
int type;
char *buf;
int len;
register struct pkg_conn *pc;
d1133 1
a1133 3
pkg_bwaitfor( type, pc )
int type;
register struct pkg_conn *pc;
d1228 1
a1228 2
pkg_process(pc)
register struct pkg_conn *pc;
d1357 1
a1357 2
pkg_dispatch(pc)
register struct pkg_conn *pc;
d1409 1
a1409 3
pkg_gethdr( pc, buf )
register struct pkg_conn *pc;
char *buf;
d1488 1
a1488 2
pkg_block(pc)
register struct pkg_conn *pc;
d1525 1
a1525 3
pkg_perror( errlog, s )
void (*errlog)();
char *s;
d1527 11
a1537 1
	if( errno >= 0 && errno < sys_nerr ) {
d1539 1
d1553 1
a1553 2
pkg_errlog( s )
char *s;
d1567 1
a1567 1
pkg_ck_debug()
d1594 1
a1594 1
pkg_timestamp()
d1636 1
a1636 2
pkg_suckin(pc)
register struct pkg_conn	*pc;
d1751 1
a1751 3
pkg_checkin(pc, nodelay)
register struct pkg_conn	*pc;
int		nodelay;
d1806 1
a1806 4
pkg_inget( pc, buf, count )
register struct pkg_conn	*pc;
char		*buf;
int		count;
@


11.11
log
@protect the rcsid variable if it is not available
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libpkg/pkg.c,v 11.10 2002/08/20 17:07:54 jra Exp $ (BRL)";
d46 1
d50 1
d54 1
d62 5
d499 4
d505 1
d513 4
d519 1
a519 1
			pkg_perror( errlog, "pkg_getclient: accept" );
d526 6
d536 1
@


11.10
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libpkg/pkg.c,v 11.8 2001/10/17 07:40:03 morrison Exp $ (BRL)";
d1597 1
d1599 1
@


11.10.10.1
log
@merge from head
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libpkg/pkg.c,v 11.11 2004/03/03 21:29:54 morrison Exp $ (BRL)";
a1596 1
#ifndef lint
a1597 1
#endif
@


11.10.10.2
log
@merge from head
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libpkg/pkg.c,v 11.10.10.1 2004/03/10 13:19:10 erikg Exp $ (BRL)";
@


11.10.10.3
log
@update from head
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libpkg/pkg.c,v 11.10.10.2 2004/03/15 14:07:14 erikg Exp $ (BRL)";
a45 1
#ifndef WIN32
a48 1
#endif
a51 1
#ifndef WIN32
a58 5
#else
#include <io.h>
#include <process.h>
#include <winsock.h>
#endif
a490 4
#ifdef WIN32
		if( ioctlsocket(fd, FIONBIO, &onoff) < 0 )
			pkg_perror( errlog, "pkg_getclient: FIONBIO 1" );
#else
a492 1
#endif
a499 4
#ifdef WIN32
			if(errno == WSAEWOULDBLOCK)
				return(PKC_NULL);
#else
d502 1
a502 1
#endif			pkg_perror( errlog, "pkg_getclient: accept" );
a508 6
		#ifdef WIN32
		if( ioctlsocket(fd, FIONBIO, &onoff) < 0 )
			pkg_perror( errlog, "pkg_getclient: FIONBIO 2" );
		if( ioctlsocket(s2, FIONBIO, &onoff) < 0 )
			pkg_perror( errlog, "pkg_getclient: FIONBIO 3");
#else
a512 1
#endif
@


11.10.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libpkg/pkg.c,v 11.10 2002/08/20 17:07:54 jra Exp $ (BRL)";
a45 1
#ifndef WIN32
a48 1
#endif
a51 1
#ifndef WIN32
a58 5
#else
#include <io.h>
#include <process.h>
#include <winsock.h>
#endif
a490 4
#ifdef WIN32
		if( ioctlsocket(fd, FIONBIO, &onoff) < 0 )
			pkg_perror( errlog, "pkg_getclient: FIONBIO 1" );
#else
a492 1
#endif
a499 4
#ifdef WIN32
			if(errno == WSAEWOULDBLOCK)
				return(PKC_NULL);
#else
d502 1
a502 1
#endif			pkg_perror( errlog, "pkg_getclient: accept" );
a508 6
		#ifdef WIN32
		if( ioctlsocket(fd, FIONBIO, &onoff) < 0 )
			pkg_perror( errlog, "pkg_getclient: FIONBIO 2" );
		if( ioctlsocket(s2, FIONBIO, &onoff) < 0 )
			pkg_perror( errlog, "pkg_getclient: FIONBIO 3");
#else
a512 1
#endif
@


11.10.4.2
log
@sync to HEAD...
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libpkg/pkg.c,v 11.10.4.1 2002/09/26 23:04:00 morrison Exp $ (BRL)";
a1620 1
#ifndef lint
a1621 1
#endif
@


11.10.2.1
log
@Initial ANSIfication
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libpkg/pkg.c,v 11.10 2002/08/20 17:07:54 jra Exp $ (BRL)";
d106 5
a110 5
static struct pkg_conn *pkg_makeconn(int fd, struct pkg_switch *switchp, void (*errlog) (/* ??? */));
static void pkg_errlog(char *s);
static void pkg_perror(void (*errlog) (/* ??? */), char *s);
static int pkg_dispatch(register struct pkg_conn *pc);
static int pkg_gethdr(register struct pkg_conn *pc, char *buf);
d114 3
a116 3
static void	pkg_ck_debug(void);
static void	pkg_timestamp(void);
static void	pkg_checkin(register struct pkg_conn *pc, int nodelay);
d143 2
a144 1
pkg_gshort(unsigned char *msgp)
d164 2
a165 1
pkg_glong(unsigned char *msgp)
d180 3
a182 1
pkg_pshort(unsigned char *msgp, short unsigned int s)
d194 3
a196 1
pkg_plong(unsigned char *msgp, long unsigned int l)
d214 8
a221 1
pkg_open(char *host, char *service, char *protocol, char *uname, char *passwd, struct pkg_switch *switchp, void (*errlog) (/* ??? */))
d329 3
a331 1
pkg_transerver(struct pkg_switch *switchp, void (*errlog) (/* ??? */))
d360 5
a364 1
pkg_permserver(char *service, char *protocol, int backlog, void (*errlog) (/* ??? */))
d467 3
a469 1
pkg_getclient(int fd, struct pkg_switch *switchp, void (*errlog) (/* ??? */), int nodelay)
d473 1
a473 1
	unsigned int fromlen = sizeof (from);
d533 3
a535 1
pkg_makeconn(int fd, struct pkg_switch *switchp, void (*errlog) (/* ??? */))
d574 2
a575 1
pkg_close(register struct pkg_conn *pc)
d663 5
a667 1
pkg_send(int type, char *buf, int len, register struct pkg_conn *pc)
d794 5
a798 1
pkg_2send(int type, char *buf1, int len1, char *buf2, int len2, register struct pkg_conn *pc)
d949 5
a953 1
pkg_stream(int type, char *buf, int len, register struct pkg_conn *pc)
d993 2
a994 1
pkg_flush(register struct pkg_conn *pc)
d1040 5
a1044 1
pkg_waitfor(int type, char *buf, int len, register struct pkg_conn *pc)
d1148 3
a1150 1
pkg_bwaitfor(int type, register struct pkg_conn *pc)
d1245 2
a1246 1
pkg_process(register struct pkg_conn *pc)
d1375 2
a1376 1
pkg_dispatch(register struct pkg_conn *pc)
d1428 3
a1430 1
pkg_gethdr(register struct pkg_conn *pc, char *buf)
d1509 2
a1510 1
pkg_block(register struct pkg_conn *pc)
d1547 3
a1549 1
pkg_perror(void (*errlog) (/* ??? */), char *s)
d1566 2
a1567 1
pkg_errlog(char *s)
d1581 1
a1581 1
pkg_ck_debug(void)
d1606 1
a1606 1
pkg_timestamp(void)
d1648 2
a1649 1
pkg_suckin(register struct pkg_conn *pc)
d1764 3
a1766 1
pkg_checkin(register struct pkg_conn *pc, int nodelay)
d1821 4
a1824 1
pkg_inget(register struct pkg_conn *pc, char *buf, int count)
@


11.10.2.2
log
@sync branch with HEAD
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
a45 1
#ifndef WIN32
a48 1
#endif
a51 1
#ifndef WIN32
a58 5
#else
#include <io.h>
#include <process.h>
#include <winsock.h>
#endif
a469 4
#ifdef WIN32
		if( ioctlsocket(fd, FIONBIO, &onoff) < 0 )
			pkg_perror( errlog, "pkg_getclient: FIONBIO 1" );
#else
a471 1
#endif
a478 4
#ifdef WIN32
			if(errno == WSAEWOULDBLOCK)
				return(PKC_NULL);
#else
d481 1
a481 1
#endif			pkg_perror( errlog, "pkg_getclient: accept" );
a487 6
		#ifdef WIN32
		if( ioctlsocket(fd, FIONBIO, &onoff) < 0 )
			pkg_perror( errlog, "pkg_getclient: FIONBIO 2" );
		if( ioctlsocket(s2, FIONBIO, &onoff) < 0 )
			pkg_perror( errlog, "pkg_getclient: FIONBIO 3");
#else
a491 1
#endif
a1545 1
#ifndef lint
a1546 1
#endif
@


11.10.2.3
log
@convert old sys_errlist[] to strerror_r(), quell warnings
@
text
@d120 1
a120 2
#define MAX_ERRBUF_SIZE 80
static char errbuf[MAX_ERRBUF_SIZE];
d498 1
a498 2
#endif
			pkg_perror( errlog, "pkg_getclient: accept" );
d1525 1
a1525 11

#if HAVE_STRERROR_R
	int ret = 0;
	sprintf( errbuf, "%s: ", s);
	if ((errno >= 0) && (strlen(errbuf) < MAX_ERRBUF_SIZE)) {
	       	ret = strerror_r(errno, errbuf+strlen(errbuf), MAX_ERRBUF_SIZE-strlen(errbuf));
		if (ret != 0) {
			sprintf(errbuf, "%s: errno=%d\n", s, errno);
		}
#else
	if ( errno >= 0 && errno < sys_nerr ) {
a1526 1
#endif
@


11.9
log
@Converted from K&R to ANSI C - RFH
@
text
@d106 5
a110 5
static struct pkg_conn *pkg_makeconn(int fd, struct pkg_switch *switchp, void (*errlog) (/* ??? */));
static void pkg_errlog(char *s);
static void pkg_perror(void (*errlog) (/* ??? */), char *s);
static int pkg_dispatch(register struct pkg_conn *pc);
static int pkg_gethdr(register struct pkg_conn *pc, char *buf);
d114 3
a116 3
static void	pkg_ck_debug(void);
static void	pkg_timestamp(void);
static void	pkg_checkin(register struct pkg_conn *pc, int nodelay);
d143 2
a144 1
pkg_gshort(unsigned char *msgp)
d164 2
a165 1
pkg_glong(unsigned char *msgp)
d180 3
a182 1
pkg_pshort(unsigned char *msgp, short unsigned int s)
d194 3
a196 1
pkg_plong(unsigned char *msgp, long unsigned int l)
d214 8
a221 1
pkg_open(char *host, char *service, char *protocol, char *uname, char *passwd, struct pkg_switch *switchp, void (*errlog) (/* ??? */))
d329 3
a331 1
pkg_transerver(struct pkg_switch *switchp, void (*errlog) (/* ??? */))
d360 5
a364 1
pkg_permserver(char *service, char *protocol, int backlog, void (*errlog) (/* ??? */))
d467 3
a469 1
pkg_getclient(int fd, struct pkg_switch *switchp, void (*errlog) (/* ??? */), int nodelay)
d473 1
a473 1
	unsigned int fromlen = sizeof (from);
d533 3
a535 1
pkg_makeconn(int fd, struct pkg_switch *switchp, void (*errlog) (/* ??? */))
d574 2
a575 1
pkg_close(register struct pkg_conn *pc)
d663 5
a667 1
pkg_send(int type, char *buf, int len, register struct pkg_conn *pc)
d794 5
a798 1
pkg_2send(int type, char *buf1, int len1, char *buf2, int len2, register struct pkg_conn *pc)
d949 5
a953 1
pkg_stream(int type, char *buf, int len, register struct pkg_conn *pc)
d993 2
a994 1
pkg_flush(register struct pkg_conn *pc)
d1040 5
a1044 1
pkg_waitfor(int type, char *buf, int len, register struct pkg_conn *pc)
d1148 3
a1150 1
pkg_bwaitfor(int type, register struct pkg_conn *pc)
d1245 2
a1246 1
pkg_process(register struct pkg_conn *pc)
d1375 2
a1376 1
pkg_dispatch(register struct pkg_conn *pc)
d1428 3
a1430 1
pkg_gethdr(register struct pkg_conn *pc, char *buf)
d1509 2
a1510 1
pkg_block(register struct pkg_conn *pc)
d1547 3
a1549 1
pkg_perror(void (*errlog) (/* ??? */), char *s)
d1566 2
a1567 1
pkg_errlog(char *s)
d1581 1
a1581 1
pkg_ck_debug(void)
d1606 1
a1606 1
pkg_timestamp(void)
d1648 2
a1649 1
pkg_suckin(register struct pkg_conn *pc)
d1764 3
a1766 1
pkg_checkin(register struct pkg_conn *pc, int nodelay)
d1821 4
a1824 1
pkg_inget(register struct pkg_conn *pc, char *buf, int count)
@


11.8
log
@Mac OS X warning and error fixes for non-production build
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libpkg/pkg.c,v 11.7 2000/07/12 00:43:53 cjohnson Exp $ (BRL)";
d106 5
a110 5
static struct pkg_conn *pkg_makeconn();
static void pkg_errlog();
static void pkg_perror();
static int pkg_dispatch();
static int pkg_gethdr();
d114 3
a116 3
static void	pkg_ck_debug();
static void	pkg_timestamp();
static void	pkg_checkin();
d143 1
a143 2
pkg_gshort(msgp)
unsigned char *msgp;
d163 1
a163 2
pkg_glong(msgp)
unsigned char *msgp;
d178 1
a178 3
pkg_pshort(msgp, s)
unsigned char *msgp;
unsigned short s;
d190 1
a190 3
pkg_plong(msgp, l)
unsigned char *msgp;
unsigned long l;
d208 1
a208 8
pkg_open( host, service, protocol, uname, passwd, switchp, errlog )
char *host;
char *service;
char *protocol;
char *uname;
char *passwd;
struct pkg_switch *switchp;
void (*errlog)();
d316 1
a316 3
pkg_transerver( switchp, errlog )
struct pkg_switch *switchp;
void (*errlog)();
d345 1
a345 5
pkg_permserver( service, protocol, backlog, errlog )
char *service;
char *protocol;
int backlog;
void (*errlog)();
d448 1
a448 3
pkg_getclient(fd, switchp, errlog, nodelay)
struct pkg_switch *switchp;
void (*errlog)();
d452 1
a452 1
	auto int fromlen = sizeof (from);
d512 1
a512 3
pkg_makeconn(fd, switchp, errlog)
struct pkg_switch *switchp;
void (*errlog)();
d551 1
a551 2
pkg_close(pc)
register struct pkg_conn *pc;
d639 1
a639 5
pkg_send( type, buf, len, pc )
int type;
char *buf;
int len;
register struct pkg_conn *pc;
d766 1
a766 5
pkg_2send( type, buf1, len1, buf2, len2, pc )
int type;
char *buf1, *buf2;
int len1, len2;
register struct pkg_conn *pc;
d917 1
a917 5
pkg_stream( type, buf, len, pc )
int type;
char *buf;
int len;
register struct pkg_conn *pc;
d957 1
a957 2
pkg_flush( pc )
register struct pkg_conn *pc;
d1003 1
a1003 5
pkg_waitfor( type, buf, len, pc )
int type;
char *buf;
int len;
register struct pkg_conn *pc;
d1107 1
a1107 3
pkg_bwaitfor( type, pc )
int type;
register struct pkg_conn *pc;
d1202 1
a1202 2
pkg_process(pc)
register struct pkg_conn *pc;
d1331 1
a1331 2
pkg_dispatch(pc)
register struct pkg_conn *pc;
d1383 1
a1383 3
pkg_gethdr( pc, buf )
register struct pkg_conn *pc;
char *buf;
d1462 1
a1462 2
pkg_block(pc)
register struct pkg_conn *pc;
d1499 1
a1499 3
pkg_perror( errlog, s )
void (*errlog)();
char *s;
d1516 1
a1516 2
pkg_errlog( s )
char *s;
d1530 1
a1530 1
pkg_ck_debug()
d1555 1
a1555 1
pkg_timestamp()
d1597 1
a1597 2
pkg_suckin(pc)
register struct pkg_conn	*pc;
d1712 1
a1712 3
pkg_checkin(pc, nodelay)
register struct pkg_conn	*pc;
int		nodelay;
d1767 1
a1767 4
pkg_inget( pc, buf, count )
register struct pkg_conn	*pc;
char		*buf;
int		count;
@


11.7
log
@LINT from gcc -Wall
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libpkg/pkg.c,v 11.6 1999/06/25 18:44:50 mike Exp $ (BRL)";
d729 1
a729 1
			sizeof(hdr), len, i);
d856 1
a856 1
			sizeof(hdr), len1, len2, i);
@


11.6
log
@
Fixed warnings on FreeBSD
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libpkg/pkg.c,v 11.5 1998/06/28 03:12:20 mike Exp $ (BRL)";
d57 1
d60 6
d118 2
d850 2
a851 1
				 type, buf1, len1, buf2, len2, pc );
d1441 1
a1441 1
	if( (i = pkg_inget( pc, &(pc->pkc_hdr),
@


11.5
log
@Eliminated warning messages on IRIX64.
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libpkg/pkg.c,v 11.4 1997/11/18 07:18:37 mike Exp $ (BRL)";
d46 1
a73 2
# define BSD 42
# undef SYSV
@


11.4
log
@Added improved error reporting
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /m/cad/libpkg/RCS/pkg.c,v 11.4 1997/11/18 06:42:01 mike Exp $ (BRL)";
d113 1
a113 1
			sprintf(errbuf,"%s: bad pointer x%x line %d\n",__FILE__, p, __LINE__);\
d229 1
a229 1
			"pkg_open(%s, %s, %s, %s, (passwd), switchp=x%x, errlog=x%x)\n",
d231 1
a231 1
			switchp, errlog );
d329 2
a330 2
			"pkg_transerver(switchp=x%x, errlog=x%x)\n",
			switchp, errlog );
d372 2
a373 2
			"pkg_permserver(%s, %s, backlog=%d, errlog=x%x\n",
			service, protocol, backlog, errlog );
d471 2
a472 2
			"pkg_getclient(fd=%d, switchp=x%x, errlog=x%x, nodelay=%d)\n",
			fd, switchp, errlog, nodelay );
d534 2
a535 2
			"pkg_makeconn(fd=%d, switchp=x%x, errlog=x%x)\n",
			fd, switchp, errlog );
d573 2
a574 2
			"pkg_close(pc=x%x) fd=%d\n",
			pc, pc->pkc_fd );
d584 2
a585 2
		sprintf(errbuf,"pkg_close(x%x):  partial input pkg discarded, buf=x%x\n",
			pc, pc->pkc_buf);
d673 2
a674 2
			"pkg_send(type=%d, buf=x%x, len=%d, pc=x%x)\n",
			 type, buf, len, pc );
d745 1
a745 1
				len, i-sizeof(hdr) );
d758 2
a759 1
		sprintf(errbuf,"pkg_send header of %d, wrote %d\n", sizeof(hdr), i);
d805 2
a806 2
			"pkg_send2(type=%d, buf1=x%x, len1=%d, buf2=x%x, len2=%d, pc=x%x)\n",
			 type, buf1, len1, buf2, len2, pc );
d873 1
a873 1
				len1, len2, i-sizeof(hdr) );
d884 2
a885 2
			sprintf(errbuf, "pkg_2send write(%d, x%x, %d) ret=%d\n",
				pc->pkc_fd, &hdr, sizeof(hdr), i );
d890 1
a890 1
			sizeof(hdr), len1, len2, i );
d898 2
a899 2
			sprintf(errbuf, "pkg_2send write(%d, x%x, %d) ret=%d\n",
				pc->pkc_fd, buf1, len1, i );
d904 1
a904 1
			sizeof(hdr), len1, len2, i );
d913 2
a914 2
			sprintf(errbuf, "pkg_2send write(%d, x%x, %d) ret=%d\n",
				pc->pkc_fd, buf2, len2, i );
d919 1
a919 1
			sizeof(hdr), len1, len2, i );
d951 2
a952 2
			"pkg_stream(type=%d, buf=x%x, len=%d, pc=x%x)\n",
			 type, buf, len, pc );
d992 2
a993 2
			"pkg_flush( pc=x%x )\n",
			pc );
d1043 2
a1044 2
			"pkg_waitfor(type=%d, buf=x%x, len=%d, pc=x%x)\n",
			type, buf, len, pc );
d1079 1
a1079 1
			"pkg_waitfor:  message %d exceeds buffer %d\n",
d1108 2
a1109 1
			"pkg_waitfor:  pkg_inget %d gave %d\n", pc->pkc_len, i );
d1150 2
a1151 2
			"pkg_bwaitfor(type=%d, pc=x%x)\n",
			type, pc );
d1174 1
a1174 1
			"pkg_bwaitfor:  pkg_inget %d gave %d\n", pc->pkc_len, i );
d1261 2
a1262 2
				"pkg_process(pc=x%x) pkc_left=%d %s (avail=%d)\n",
				pc, pc->pkc_left, errbuf, available );
d1375 2
a1376 2
			"pkg_dispatch(pc=x%x) type=%d, buf=x%x, len=%d\n",
			pc, pc->pkc_type, pc->pkc_buf, pc->pkc_len );
d1400 1
a1400 1
	sprintf(errbuf,"pkg_dispatch:  no handler for message type %d, len %d\n",
d1507 2
a1508 2
			"pkg_block(pc=x%x)\n",
			pc );
d1721 2
a1722 2
		sprintf(errbuf, "pkg_suckin: read(%d, x%x, %d) ret=%d inbuf=x%x, inend=%d\n",
			pc->pkc_fd, &pc->pkc_inbuf[pc->pkc_inend], avail,
d1724 1
a1724 1
			pc->pkc_inbuf, pc->pkc_inend );
@


11.3
log
@not our fault.
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /m/cad/libpkg/RCS/pkg.c,v 11.2 1996/07/11 14:54:32 jra Exp bparker $ (BRL)";
d839 4
@


11.2
log
@Minor mods for IRIX 6.2
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /m/cad/libpkg/RCS/pkg.c,v 11.1 1995/01/04 09:51:47 mike Rel4_4 jra $ (BRL)";
d1007 2
d1669 1
a1669 1
	if( pc->pkc_incur >= (pc->pkc_inlen * 8) / 7 )  {
d1697 2
@


11.1
log
@Release_4.4
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /m/cad/libpkg/RCS/pkg.c,v 10.12 95/01/03 21:57:25 mike Exp $ (BRL)";
d702 1
a702 1
	pkg_plong( hdr.pkh_len, len );
d821 1
a821 1
	pkg_plong( hdr.pkh_len, len1+len2 );
d960 1
a960 1
	pkg_plong( hdr.pkh_len, len );
@


10.12
log
@Fix from Chris Johnson for Bug #272, fixing memory leak.
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /m/cad/libpkg/RCS/pkg.c,v 10.11 94/12/30 13:39:59 stay Exp Locker: mike $ (BRL)";
@


10.11
log
@The vax included time.h in sys/time.h which caused
compilation errors.
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/libpkg/RCS/pkg.c,v 10.10 1994/12/23 14:47:13 jra Exp stay $ (BRL)";
d588 5
@


10.10
log
@args for pkg_gshort and pkg_glong changed to unsigned.
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /m/cad/libpkg/RCS/pkg.c,v 10.9 94/12/19 16:13:47 jra Exp Locker: jra $ (BRL)";
d48 1
d50 1
@


10.9
log
@Mods for CRAY.
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/libpkg/RCS/pkg.c,v 10.8 94/11/08 23:12:53 mike Exp Locker: jra $ (BRL)";
d134 1
a134 1
	char *msgp;
d155 1
a155 1
	char *msgp;
@


10.8
log
@Fixed problem with conversion to fd_set
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /m/cad/libpkg/RCS/pkg.c,v 10.7 94/11/04 04:57:49 mike Exp Locker: mike $ (BRL)";
d171 2
a172 2
register char *msgp;
register unsigned short s;
d177 1
a177 1
	return(msgp+2);
d185 2
a186 2
register char *msgp;
register unsigned long l;
d193 1
a193 1
	return(msgp+4);
@


10.7
log
@Irix 6 lint
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /m/cad/libpkg/RCS/pkg.c,v 10.6 94/09/01 05:46:33 gdurf Exp Locker: mike $ (BRL)";
d1769 2
a1770 1
		if( j >= FD_SETSIZE )  {   /* No fd's in bits! */
d1773 1
a1773 1
			/* Odd condition */
@


10.6
log
@Removed extern declration that is more properly handled in externs.h
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /m/cad/libpkg/RCS/pkg.c,v 10.5 1994/08/25 15:52:35 gdurf Exp gdurf $ (BRL)";
a100 1
static int pkg_mread();
d594 1
d633 1
a787 2
	struct timeval tv;
	long bits;
d1584 1
a1584 1
	long		now;
a1585 1
	register char	*cp;
a1626 1
	int	waste;
@


10.5
log
@Factored ifdefs
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /m/cad/libpkg/RCS/pkg.c,v 10.4 1993/10/22 20:59:33 mike Exp gdurf $ (BRL)";
d56 2
a57 2
#include "machine.h"		/* Can safely be removed for non-BRLCAD use */
#include "externs.h"		/* Can safely be removed for non-BRLCAD use */
a1516 2
extern int sys_nerr;
extern char *sys_errlist[];
@


10.4
log
@IRIX 5.0.1 port
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /m/cad/libpkg/RCS/pkg.c,v 10.3 93/05/20 21:44:47 mike Exp Locker: mike $ (BRL)";
d42 2
a44 2
#define _BSD_TYPES		/* Needed for IRIX 5.0.1 */
#include <sys/types.h>
d46 3
a48 11

#if defined(sgi) && !defined(mips)
# define IP2			/* Bypass horrible bug in netinet/tcp.h */
#endif

#ifdef BSD
/* 4.2BSD, 4.3BSD network stuff */
#if defined(__bsdi__)
# include <sys/param.h>	/* needed to pick up #define for BYTE_ORDER */
#endif

d60 2
a61 4
#  if !defined(sgi) && !defined(i386)
#	define HAS_UNIX_DOMAIN_SOCKETS
#	include <sys/un.h>		/* UNIX Domain sockets */
#  endif
d75 1
a75 27
/*
 *  The situation with sys/time.h and time.h is crazy.
 *  We need sys/time.h for struct timeval,
 *  and time.h for struct tm.
 *
 *  on BSD (and SGI 4D), sys/time.h includes time.h,
 *  on the XMP (UNICOS 3 & 4), time.h includes sys/time.h [non-STDC only],
 *  on the Cray-2, there is no automatic including.
 *
 *  Note that on many SYSV machines, the Cakefile has to set BSD
 */
#if BSD && !SYSV
#  include <sys/time.h>		/* includes <time.h> */
#else
#    if CRAY1 && !__STDC__
#	include <time.h>	/* includes <sys/time.h> */
#    else
#	include <sys/time.h>
#	include <time.h>
#    endif
#endif

#if defined(BSD) && !defined(CRAY) && !defined(mips) && !defined(n16) && !defined(i386)
#define	HAS_WRITEV
#endif

#ifdef HAS_WRITEV
a81 5
#if defined(SYSV) && !defined(bzero)
#	define bzero(str,n)		memset( str, '\0', n )
#	define bcopy(from,to,count)	memcpy( to, from, count )
#endif

a93 8
#if !__STDC__ && !USE_PROTOTYPES
extern char	*getenv();
extern char	*malloc();
extern char	*realloc();
extern void	perror();
#endif
extern int errno;

d216 1
a216 1
#ifdef HAS_UNIX_DOMAIN_SOCKETS
d241 1
a241 1
#ifdef HAS_UNIX_DOMAIN_SOCKETS
a255 1
#ifdef BSD
a263 1
#endif
a271 1
#ifdef BSD
a279 1
#endif
a283 1
#ifdef BSD
d290 1
a290 1
#if BSD >= 43 && defined(TCP_NODELAY)
a305 1
#endif
d358 1
a358 1
#ifdef HAS_UNIX_DOMAIN_SOCKETS
d382 1
a382 1
#ifdef HAS_UNIX_DOMAIN_SOCKETS
a395 1
#ifdef BSD
a403 1
#endif
a409 1
#ifdef BSD
d421 1
a421 1
#if BSD >= 43 && defined(TCP_NODELAY)
a441 1
#endif
a461 1
#ifdef BSD
a486 1
#if __STDC__
a487 3
#else
		s2 = accept(fd, (char *)&from, &fromlen);
#endif
a507 1
#endif
d653 1
a653 1
#ifdef HAS_WRITEV
d696 1
a696 1
#ifdef HAS_WRITEV
d783 1
a783 1
#ifdef HAS_WRITEV
d817 1
a817 1
#ifdef HAS_WRITEV
d1748 2
a1749 2
	long		bits;
	register int	i;
d1758 4
a1761 2
	bits = 1 << pc->pkc_fd;
	i = select( pc->pkc_fd+1, &bits, (char *)0, (char *)0, &tv );
d1765 1
a1765 1
			"pkg_checkin: select on fd %d returned %d, bits=x%x\n",
d1767 1
a1767 1
			i, bits );
d1771 4
a1774 1
		if( bits != 0 )  {
@


10.3
log
@convex to __STDC__
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /m/cad/libpkg/RCS/pkg.c,v 10.2 92/05/23 14:54:22 butler Exp Locker: mike $ (BRL)";
d43 1
@


10.2
log
@added conditionals to allow to compile under BSDI386
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /m/cad/libpkg/RCS/pkg.c,v 10.1 91/10/12 06:36:54 mike Rel4_0 Locker: butler $ (BRL)";
d546 1
a546 1
#if defined(__convexc__)
@


10.1
log
@Release_4.0
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /m/cad/libpkg/RCS/pkg.c,v 9.22 91/10/11 08:25:51 butler Exp $ (BRL)";
d52 4
@


9.22
log
@cast arguments to accept() to appropriate types for Convex
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /m/cad/libpkg/RCS/pkg.c,v 9.21 91/09/26 05:31:38 phil Exp Locker: butler $ (BRL)";
@


9.21
log
@i386 doesn't have WRITEV or Unix domain sockets.
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /m/cad/libpkg/RCS/pkg.c,v 9.20 91/09/21 00:57:40 mike Exp Locker: phil $ (BRL)";
d542 3
d546 1
@


9.20
log
@If the caller forcibly closes our file descriptor unbeknownst to the
library, just silently error off.

This is necessary to silence "pkg_checkin: select: Bad file number"
messages making it into syslog on SGI 4d lingering framebuffer's
accessed through fbserv when the shmdet() failes.  Ugh.
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /m/cad/libpkg/RCS/pkg.c,v 9.19 91/08/31 02:54:42 mike Exp $ (BRL)";
d63 1
a63 1
#  ifndef sgi
d102 1
a102 1
#if defined(BSD) && !defined(CRAY) && !defined(mips) && !defined(n16)
@


9.19
log
@Port to Stardent.  No FIONBIO, and htons() and htonl() don't work.
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /m/cad/libpkg/RCS/pkg.c,v 9.18 91/07/19 02:17:11 mike Exp $ (BRL)";
d788 1
d802 1
d813 1
d913 1
d927 1
d941 1
d956 1
d1049 1
d1836 1
a1836 1
		if( errno != EINTR )
@


9.18
log
@Fix for horrible bug on 3d
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /m/cad/libpkg/RCS/pkg.c,v 9.17 91/07/06 02:27:35 mike Exp $ (BRL)";
d118 12
d534 1
d540 1
d552 1
d560 1
@


9.17
log
@The 4.3BSD "tahoe" header files netinet/ip.h and netinet/tcp.h
define the symbol LITTLE_ENDIAN, as does our h/machine.h.
Since this file does not need it, just #undef it.
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /m/cad/libpkg/RCS/pkg.c,v 9.16 91/06/12 21:04:11 mike Exp $ (BRL)";
d45 4
@


9.16
log
@lint
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /m/cad/libpkg/RCS/pkg.c,v 9.15 91/01/04 22:49:47 mike Exp $ (BRL)";
d53 1
@


9.15
log
@On systems that don't have a real WRITEV system call
(such as the SGI 4d), if the amount of data to be sent is less than
16k, just copy it all together into a local buffer,
rather than using multiple sys-write calls.
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /m/cad/libpkg/RCS/pkg.c,v 9.13 90/09/27 22:18:17 mike Exp $ (BRL)";
d54 3
d113 1
a113 1
#if !__STDC__
@


9.14
log
@Improved pkg_perror()  in case where errno is out of bounds.
Improved "skipping noise" message to only print printable characters.
@
text
@d750 25
d870 53
a922 3
	/* Assume all succeed if last one does */
	(void)write( pc->pkc_fd, (char *)&hdr, sizeof(hdr) );
	i = write( pc->pkc_fd, buf1, len1 );
d926 4
a929 1
			pkg_perror(pc->pkc_errlog, "pkg_2send: write2");
d932 2
a933 1
		sprintf(errbuf,"pkg_2send of %d, wrote %d+%d\n", len2, len1, i);
d981 2
a982 1
	bcopy( &hdr, &(pc->pkc_stream[pc->pkc_strpos]), sizeof(struct pkg_header) );
@


9.13
log
@Encore multimax hacking
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 9.12 89/11/23 03:53:57 mike Exp $ (BRL)";
d1371 11
a1381 3
		sprintf(errbuf,"pkg_gethdr: skipping noise x%x %c\n",
			*((unsigned char *)&pc->pkc_hdr),
			*((unsigned char *)&pc->pkc_hdr) );
d1477 4
a1480 2
	} else
		errlog( s );
@


9.12
log
@Need to clear out the pkg_conn structure before using it (sigh).
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 9.11 89/11/15 02:50:49 mike Locked $ (BRL)";
d61 11
d86 1
a86 1
#  if CRAY1 && !__STDC__
d88 1
a88 1
#  else
d91 1
a91 1
#  endif
d94 1
a94 1
#if defined(BSD) && !defined(CRAY) && !defined(mips)
@


9.11
log
@Improved comment describing use of pkg_process().
Changed pkg_suckin() debugging to have 2 prints;
one at routine entry, and one with return code and progress report.
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 9.10 89/11/15 01:12:20 mike Exp $ (BRL)";
d567 1
d1632 5
@


9.10
log
@pkg_get() has been removed.  In it's place, use pkg_process() to
process packages already read into the receive buffer, and
pkg_suckin() to accept more data from the kernel.
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 9.9 89/11/03 13:42:41 mike Locked $ (BRL)";
d1132 5
d1139 9
d1233 4
a1236 2
				/* Input buffer must now be exhausted */
				DMSG("more data needed to finish this PKG\n");
d1254 1
a1254 1
			DMSG("pkg_dispatch worked\n");
d1268 1
a1268 1
			"pkg_process() returns %d, pkc_left=%d, errcnt=%d, goodcnt=%d\n",
d1556 1
d1558 1
d1561 8
d1575 2
a1576 1
			return(-1);
d1612 2
a1613 1
			return(-1);
d1627 2
a1628 1
			return(0);	/* EOF */
d1631 2
a1632 1
		return(-1);
d1639 2
d1644 2
a1645 2
			"pkg_suckin(pc=x%x) incur=%d, inend=%d, inlen=%d\n",
			pc, pc->pkc_incur, pc->pkc_inend, pc->pkc_inlen );
d1648 1
a1648 1
	return(1);
@


9.9
log
@This version no longer has support for SGI_EXCELAN.
This version works fine on UNICOS 5.0 on the Cray;
support for Cray's OLDTCP stuff has been removed, so
no back-porting to UNICOS 4 or earlier.
@
text
@a22 1
 *	pkg_get		Read bytes from connection, assembling message
d39 1
a39 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 9.8 89/10/23 01:52:03 mike Locked $ (BRL)";
d125 2
a126 2
			sprintf(errbuf,"pkg: bad pointer x%x\n",p);\
			(p->pkc_errlog)(errbuf);abort();}}
d132 2
a133 1
#define DMSG(s) if(pkg_debug){pkg_timestamp();fprintf(pkg_debug,s);fflush(pkg_debug);}
d624 3
d945 1
a945 2
 *  All messages of any other type are processed by pkg_get() and
 *  handed off to the handler for that type message in pkg_switch[].
d967 2
a968 1
	if( pc->pkc_left >= 0 )
d971 1
d992 2
d1001 1
a1001 1
		if( (i = pkg_mread( pc, buf, len )) != len )  {
d1003 1
a1003 1
				"pkg_waitfor:  pkg_mread %d gave %d\n", len, i );
d1012 1
a1012 1
		if( (i = pkg_mread( pc, bp, excess )) != excess )  {
d1014 1
a1014 1
				"pkg_waitfor: pkg_mread of excess, %d gave %d\n",
d1049 2
a1050 2
 *  All messages of any other type are processed by pkg_get() and
 *  handed off to the handler for that type message in pkg_switch[].
d1104 1
a1104 1
 *  			P K G _ G E T
a1105 3
 *  This routine should be called whenever select() indicates that there
 *  is data waiting on the network connection and the user's program is
 *  not blocking on the arrival of a particular message type.
d1107 3
a1109 2
 *  As portions of the message body arrive, they are read and stored.
 *  When the entire message body has been read, it is dispatched.
d1111 4
a1114 3
 *  If this routine is called when there is no message already being
 *  assembled, and there is no input on the network connection, it will
 *  block, waiting for the arrival of the header.
d1116 2
a1117 1
 *  The companion routine is pkg_block(), which does one full message.
d1119 19
a1137 3
 *  Returns -1 on error, 0 if more data comming, 1 if user handler called.
 *  The user handler is responsible for calling free()
 *  on the message buffer when finished with it.
d1140 1
a1140 1
pkg_get(pc)
d1145 1
d1147 1
d1149 2
a1150 1
top:
d1152 17
a1168 1
	if( pkg_debug )  {
d1170 7
a1176 26
			sprintf(errbuf, "awaiting new header");
		} else if( pc->pkc_left > 0 )  {
			sprintf(errbuf, "more data to come");
		} else {
			sprintf(errbuf, "all here");
		}
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_get(pc=x%x) pkc_left=%d %s\n",
			pc, pc->pkc_left, errbuf );
		fflush(pkg_debug);
	}
	if( pc->pkc_left < 0 )  {
		if( pkg_gethdr( pc, (char *)0 ) < 0 )  {
			DMSG("pkg_gethdr < 0\n");
			ret = -1;
			goto out;
		}
	}
	if( pc->pkc_left < 0 )  {
		/* pkg_gethdr() didn't get a header */
		DMSG("pkc_left < 0 after pkg_gethdr\n");
		ret = -3;
		goto out;
	}
	/* Now pkc_left >= 0 */
d1178 5
d1184 6
a1189 8
	/* copy what is here already, and dispatch when all here */
	if( pc->pkc_left > 0 )  {
		/* Sanity check -- user buffer should be allocated */
		if( pc->pkc_curpos == 0 )  {
			DMSG("curpos=0\n");
			(pc->pkc_errlog)("pkg_get: curpos=0");
			ret = -9;
			goto out;
a1190 1

d1192 2
a1193 2
		 * Header has been seen, stop briefly to
		 * see if any more of the message body has arrived yet
d1195 1
a1195 1
		pkg_checkin( pc, 0 );
d1197 5
a1201 18
		available = pc->pkc_inend - pc->pkc_incur;	/* amt in input buf */
		if( available > pc->pkc_left )  {
			/* There is more in input buf than just this pkg */
			len = pc->pkc_left; /* trim to amt needed */
		} else {
			/* Take all that there is */
			len = available;
		}
		if( pkg_debug )  {
			pkg_timestamp();
			fprintf( pkg_debug,
				"pkg_get() taking %d, %d more in inbuf\n",
				len, available-len);
fprintf(pkg_debug, "pkg_get() pkc_buf=x%x, pkc_curpos=x%x\n",
pc->pkc_buf, pc->pkc_curpos);
			fflush(pkg_debug);
		}
		if( len > 0 )  {
d1203 3
a1205 3
				DMSG("len>0, curpos==0\n");
				ret = -99;
				goto out;
d1207 9
a1215 3
			bcopy( &pc->pkc_inbuf[pc->pkc_incur],
				pc->pkc_curpos, len );
			pc->pkc_incur += len;
d1218 5
a1222 1
			DMSG("bcopy done\n");
d1224 6
a1229 5
		if( pc->pkc_left > 0 )  {
			/* more is on the way */
			DMSG("more is on the way\n");
			ret = 0;
			goto out;
d1231 10
d1243 4
a1246 4
	if( pc->pkc_left != 0 )  {
		DMSG("pkc_left != 0\n");
		ret = -5;
		goto out;
a1247 9
	/* Now, pkc_left == 0, dispatch the message */
	len = pkg_dispatch(pc);
	if( len <= 0 )  {
		/* something bad happened */
		DMSG("pkg_dispatch failed\n");
		ret = -2;
		goto out;
	}
	DMSG("pkg_dispatch worked\n");
a1248 9
	/* If a full header of another pkg is here, process it too */
	len = pc->pkc_inend - pc->pkc_incur;	/* amt in input buf */
	if( len >= sizeof(struct pkg_header) )  goto top;

	/* Indicate that user handler was called */
	DMSG("indicating success\n");
	ret = 1;
	/* Fall through */
out:
d1252 2
a1253 2
			"pkg_get() returns %d, pkc_left=%d\n",
			ret, pc->pkc_left);
d1291 1
a1291 1
		 * WARNING:  Handler may recurse back to pkg_get() --
d1298 1
a1298 1
		/* pc->pkc_type, pc->pkc_len are preserved */
d1302 1
a1302 1
	sprintf(errbuf,"pkg_get:  no handler for message type %d, len %d\n",
d1382 1
a1382 1
 *  pkg_get(), which invokes the user-supplied message handler.
d1388 1
a1388 1
 *  The companion routine is pkg_get(), which does not block.
d1509 12
@


9.8
log
@Lots of additional debugging, sanity checks.
The problem turned out to be the flag pkg_nochecking,
which was always a bad idea, and now should no longer
be needed due to the new double input-buffer scheme.
When set, pkg_suckin() might NEVER get called to
receive a final fragment.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 9.7 89/10/21 00:41:13 mike Locked $ (BRL)";
a91 8
#ifdef SGI_EXCELAN
# include <EXOS/exos/misc.h>
# include <EXOS/sys/socket.h>
# include <EXOS/netinet/in.h>
# include <sys/time.h>		/* for struct timeval */
# define select	bsdselect	/* bloody GL2 select() conflict */
#endif

a233 1
	unsigned long addr_tmp;
a278 4
#ifdef SGI_EXCELAN
		/* What routine does SGI give for this one? */
		sinhim.sin_port = htons(5558);	/* mfb service!! XXX */
#endif
a284 4
#if CRAY && OLDTCP
		addr_tmp = inet_addr(host);
		sinhim.sin_addr = addr_tmp;
#else
a285 1
#endif
d295 1
a295 6
		bcopy(hp->h_addr, (char *)&addr_tmp, hp->h_length);
#		if CRAY && OLDTCP
			sinhim.sin_addr = addr_tmp;
#		else
			sinhim.sin_addr.s_addr = addr_tmp;
#		endif
a296 9
#ifdef SGI_EXCELAN
		char **hostp = &host;
		if((sinhim.sin_addr.s_addr = rhost(&hostp)) == -1) {
			sprintf(errbuf,"pkg_open(%s,%s): unknown host\n",
				host, service );
			errlog(errbuf);
			return(PKC_ERROR);
		}
#endif
a324 15
#ifdef SGI_EXCELAN
	sinme.sin_family = AF_INET;
	sinme.sin_port = 0;		/* let kernel pick it */
	if( (netfd = socket(SOCK_STREAM, 0, &sinme, 0)) <= 0 )  {
		pkg_perror( errlog, "pkg_open:  client socket" );
		return(PKC_ERROR);
	}

	if( connect(netfd, (char *)&sinhim) < 0 )  {
		pkg_perror( errlog, "pkg_open: client connect" );
		close(netfd);
		return(PKC_ERROR);
	}
#endif

a379 3
#ifdef SGI_EXCELAN
	struct sockaddr_in sinhim;		/* Server */
#endif
a424 4
#ifdef SGI_EXCELAN
		/* What routine does SGI give for this one? */
		sinme.sin_port = htons(5558);	/* mfb service!! XXX */
#endif
a464 7
#ifdef SGI_EXCELAN
	if( (pkg_listenfd = socket(SOCK_STREAM,0,&sinme,SO_ACCEPTCONN|SO_KEEPALIVE)) < 0 )  {
		pkg_perror( errlog, "pkg_permserver:  socket" );
		close(pkg_listenfd);
		return(-1);
	}
#endif
a528 12
#ifdef SGI_EXCELAN
	struct sockaddr_in from;

	/* block until someone tries to connect */
	if(accept(fd, &from) < 0){
		pkg_perror( errlog, "pkg_getclient:  accept" );
		return(PKC_ERROR);
	}

	/* Hopefully, once-only XXX */
	return( pkg_makeconn(fd, switchp, errlog) );
#endif
a1447 1
#ifdef SGI_EXCELAN
a1448 110
 *			B S D S E L E C T
 *
 *  Not only is the calling sequence different, but
 *  it conflicts with naming in the GL2 library, so
 *  select can't be used!
 */
#undef select
int
bsdselect( nfd, a, b, c, tvp )
int nfd;
long *a, *b, *c;
struct timeval *tvp;
{
/**	return( select( nfd, a, b, tvp->tv_usec ); **/
	return(0);
}
#endif

#ifdef SGI_EXCELAN
/*
 * Internet address interpretation routine.
 * All the network library routines call this
 * routine to interpret entries in the data bases
 * which are expected to be an address.
 * The value returned is in network order.
 */
u_long
inet_addr(cp)
	register char *cp;
{
	register u_long val, base, n;
	register char c;
	u_long parts[4], *pp = parts;

again:
	/*
	 * Collect number up to ``.''.
	 * Values are specified as for C:
	 * 0x=hex, 0=octal, other=decimal.
	 */
	val = 0; base = 10;
	if (*cp == '0')
		base = 8, cp++;
	if (*cp == 'x' || *cp == 'X')
		base = 16, cp++;
	while (c = *cp) {
		if (isdigit(c)) {
			val = (val * base) + (c - '0');
			cp++;
			continue;
		}
		if (base == 16 && isxdigit(c)) {
			val = (val << 4) + (c + 10 - (islower(c) ? 'a' : 'A'));
			cp++;
			continue;
		}
		break;
	}
	if (*cp == '.') {
		/*
		 * Internet format:
		 *	a.b.c.d
		 *	a.b.c	(with c treated as 16-bits)
		 *	a.b	(with b treated as 24 bits)
		 */
		if (pp >= parts + 4)
			return (-1);
		*pp++ = val, cp++;
		goto again;
	}
	/*
	 * Check for trailing characters.
	 */
	if (*cp && !isspace(*cp))
		return (-1);
	*pp++ = val;
	/*
	 * Concoct the address according to
	 * the number of parts specified.
	 */
	n = pp - parts;
	switch (n) {

	case 1:				/* a -- 32 bits */
		val = parts[0];
		break;

	case 2:				/* a.b -- 8.24 bits */
		val = (parts[0] << 24) | (parts[1] & 0xffffff);
		break;

	case 3:				/* a.b.c -- 8.8.16 bits */
		val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
			(parts[2] & 0xffff);
		break;

	case 4:				/* a.b.c.d -- 8.8.8.8 bits */
		val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
		      ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);
		break;

	default:
		return (-1);
	}
	val = htonl(val);
	return (val);
}
#endif

/*
a1609 6

#if 0
	/* XXX Setting this flag will lead to handing applications! */
	if( pkg_nochecking )
		return;
#endif
@


9.7
log
@Changed pkg_close() error message to use sprintf(),
and to free the dyanmic buffer.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 9.6 89/10/17 16:43:28 mike Locked $ (BRL)";
d139 7
d761 1
d866 1
d1195 2
a1196 1
	int		ret;
d1198 1
d1201 7
d1210 2
a1211 2
			"pkg_get(pc=x%x)\n",
			pc );
a1213 1
top:
d1215 5
a1219 2
		if( pkg_gethdr( pc, (char *)0 ) < 0 )  return(-1);
		/* Now pkc_left >= 0 */
d1221 7
d1229 1
d1232 8
d1246 2
a1247 2
		len = pc->pkc_inend - pc->pkc_incur;	/* amt in input buf */
		if( len > pc->pkc_left )  {
a1248 7
			if( pkg_debug )  {
				pkg_timestamp();
				fprintf( pkg_debug,
					"pkg_get(pc=x%x) taking %d, %d more in buffer\n",
					pc, pc->pkc_left, len-pc->pkc_left );
				fflush(pkg_debug);
			}
d1250 3
d1254 9
d1264 5
d1274 1
d1276 6
a1281 2
		if( pc->pkc_left > 0 )
			return(0);		/* more is on the way */
d1284 5
d1290 8
a1297 2
	ret = pkg_dispatch(pc);
	if( ret <= 0 )  return(ret);		/* something bad happened */
d1299 1
d1302 14
a1315 1
	return( 1 );				/* user handler called */
d1649 4
d1733 7
d1749 10
a1758 1
		if( got == 0 )  return(0);	/* EOF */
d1793 1
d1795 2
d1799 1
d1809 23
a1831 2
	if( i > 0 && bits )
		(void)pkg_suckin(pc);
@


9.6
log
@SGI does not have UNIX domain sockets
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 9.5 89/10/12 17:07:18 mike Locked $ (BRL)";
d669 1
a669 1
		pc->pkc_errlog("pkg_close(x%x):  buf=x%x clash\n",
d671 2
d1042 1
a1042 1
				pkg_perror(pc->pkc_errlog, "pkg_waitfor: malloc");
d1067 1
a1067 1
			pkg_perror(pc->pkc_errlog, "pkg_waitfor: excess malloc");
d1352 1
a1352 1
			pkg_perror(pc->pkc_errlog, "pkg_gethdr: malloc");
@


9.5
log
@TCP_NODELAY and Unix Domain sockets (host = "unix", service = filename)
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 9.4 89/08/18 22:34:10 phil Locked $ (BRL)";
d54 6
a59 1
#include <sys/un.h>		/* UNIX Domain sockets */
d230 1
a230 1
#ifdef BSD
d256 1
a256 1
#ifdef BSD
d417 1
a417 1
#ifdef BSD
d444 1
a444 1
#ifdef BSD
@


9.4
log
@close file descriptor we opened if bind or listen fails
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 9.3 89/06/06 02:27:39 phil Locked $ (BRL)";
d53 2
d225 3
d231 2
d251 11
a315 1

d318 2
d322 2
a323 1
	if( (netfd = socket(sinhim.sin_family, SOCK_STREAM, 0)) < 0 )  {
a326 1
	sinme.sin_port = 0;		/* let kernel pick it */
d328 8
a335 4
	if( bind(netfd, (char *)&sinme, sizeof(sinme)) < 0 )  {
		pkg_perror( errlog, "pkg_open: bind" );
		close(netfd);
		return(PKC_ERROR);
d337 1
d339 1
a339 1
	if( connect(netfd, (char *)&sinhim, sizeof(sinhim)) < 0 )  {
d412 3
d419 2
d439 10
d470 2
d474 2
a475 1
	if( (pkg_listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0 )  {
d480 12
a491 3
	if( setsockopt( pkg_listenfd, SOL_SOCKET, SO_REUSEADDR,
	    (char *)&on, sizeof(on) ) < 0 )  {
		pkg_perror( errlog, "pkg_permserver: setsockopt SO_REUSEADDR" );
d494 1
a494 1
	if( bind(pkg_listenfd, &sinme, sizeof(sinme)) < 0 )  {
@


9.3
log
@Changed for ANSI C on the XMP
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 9.2 89/05/25 00:22:29 mike Rel3_6 $ (BRL)";
d311 1
d317 1
d331 1
d445 1
d452 1
d459 1
@


9.2
log
@Fixed problem with pkg_get() not checking to see if more packages
were waiting in input buffer.  Since caller was using select(),
nothing more would come from UNIX, yet the package would be trapped
in the input buffer.  RTSRV fix.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 9.1 89/05/19 05:46:35 mike Locked $ (BRL)";
d61 1
a61 1
 *  on the XMP (UNICOS 3 & 4), time.h includes sys/time.h,
d69 1
a69 1
#  if CRAY1
@


9.1
log
@Release_3.5
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 8.9 89/05/12 20:19:35 mike Exp $ (BRL)";
d1122 1
d1132 1
d1147 11
a1157 1
		if( len > pc->pkc_left )  len = pc->pkc_left; /* amt wanted */
d1170 6
a1175 1
	return( pkg_dispatch(pc) );
d1320 1
a1320 1
			"pkg_block( pc=x%x )\n",
d1607 7
@


8.9
log
@CRAY's cease to be broken in UNICOS 5.0
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 8.8 89/05/07 22:49:38 mike Locked $ (BRL)";
@


8.8
log
@Modified to compile on Cray-2 SCC (STDC)
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 8.7 89/04/28 07:09:37 mike Locked $ (BRL)";
d268 1
a268 1
#ifdef CRAY
d284 1
a284 1
#		ifdef CRAY
@


8.7
log
@Made pkg_checkin static void
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 8.6 89/04/28 05:49:13 mike Locked $ (BRL)";
d977 1
a977 1
			if( (pc->pkc_buf = malloc(pc->pkc_len+2)) == NULL )  {
d1002 1
a1002 1
		if( (bp = malloc(excess)) == NULL )  {
d1270 1
a1270 1
		if( (pc->pkc_buf = malloc(pc->pkc_len+2)) == NULL )  {
d1485 1
a1485 1
	if( (place = getenv("LIBPKG_DEBUG")) == (char *)0 )  {
d1543 1
a1543 1
		if( (pc->pkc_inbuf = malloc(pc->pkc_inlen)) == (char *)0 )  {
d1572 1
a1572 1
		if( (pc->pkc_inbuf = realloc(pc->pkc_inbuf, pc->pkc_inlen)) == (char *)0 )  {
@


8.6
log
@Added code to move input buffer start position back to front
of the buffer (with a bcopy, which is cheaper than the sys-calls
it replaces), to reduce memory use.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 8.5 89/04/28 05:18:49 mike Locked $ (BRL)";
d124 1
d1601 1
@


8.5
log
@Debugging code cleaned up
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 8.4 89/04/28 05:04:53 mike Locked $ (BRL)";
d1533 1
d1555 12
d1569 1
a1569 1
	if( avail < 2 * sizeof(struct pkg_header) )  {
@


8.4
log
@This version has a separate input buffer.
Now, input messages can be read, but NOT processed,
before starting a transmission.
This was a critical error in the previous version.
(Some debugging left in).
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 8.3 89/04/28 02:39:13 mike Locked $ (BRL)";
d102 1
d1474 3
d1480 3
a1482 4
	char	place[128];
	sprintf( place, "/usr/tmp/pkg.%d", getpid() );
/*#define PLACE	"/usr/tmp/pkg.log"*/
#define PLACE	place
d1484 7
a1490 2
/*	if( access( PLACE, 2 ) < 0 )  return; */
	if( (pkg_debug = fopen( PLACE, "a" )) == NULL )  return;
@


8.3
log
@Added debug logging.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 8.2 89/02/14 04:59:15 mike Locked $ (BRL)";
d101 5
a105 2
extern char *malloc();
extern void perror();
d577 1
a673 2
	struct timeval tv;
	long bits;
d687 2
a688 5
	/* Finish any partially read message */
	do  {
		if( pc->pkc_left > 0 )
			if( pkg_block(pc) < 0 )
				return(-1);
a689 12
		if( pkg_nochecking )
			continue;
		/* Check socket for unexpected input */
		tv.tv_sec = 0;
		tv.tv_usec = 0;		/* poll -- no waiting */
		bits = 1 << pc->pkc_fd;
		i = select( pc->pkc_fd+1, &bits, (char *)0, (char *)0, &tv );
		if( i > 0 && bits )
			if( pkg_block(pc) < 0 )
				return(-1);
	} while( pc->pkc_left > 0 );

d791 2
a792 5
	/* Finish any partially read message */
	do  {
		if( pc->pkc_left > 0 )
			if( pkg_block(pc) < 0 )
				return(-1);
a793 12
		if( pkg_nochecking )
			continue;
		/* Check socket for unexpected input */
		tv.tv_sec = 0;
		tv.tv_usec = 0;		/* poll -- no waiting */
		bits = 1 << pc->pkc_fd;
		i = select( pc->pkc_fd+1, &bits, (char *)0, (char *)0, &tv );
		if( i > 0 && bits )
			if( pkg_block(pc) < 0 )
				return(-1);
	} while( pc->pkc_left > 0 );

d1017 1
a1017 1
	if( (i = pkg_mread( pc, buf, pc->pkc_len )) != pc->pkc_len )  {
d1019 1
a1019 1
			"pkg_waitfor:  pkg_mread %d gave %d\n", pc->pkc_len, i );
d1082 1
a1082 1
	if( (i = pkg_mread( pc, pc->pkc_buf, pc->pkc_len )) != pc->pkc_len )  {
d1084 1
a1084 1
			"pkg_bwaitfor:  pkg_mread %d gave %d\n", pc->pkc_len, i );
d1101 1
d1103 1
a1103 2
 *  When the entire message body has been read, it is handed to the
 *  user-provided message handler for that type message, from pkg_switch[].
d1109 2
d1119 1
a1119 3
	register int i;
	struct timeval tv;
	auto long bits;
d1131 1
a1131 9
		if( pc->pkc_left == 0 )  return( pkg_dispatch(pc) );

		/* See if any message body has arrived yet */
		tv.tv_sec = 0;
		tv.tv_usec = 20000;	/* 20 ms */
		bits = (1<<pc->pkc_fd);
		i = select( pc->pkc_fd+1, (char *)&bits, (char *)0, (char *)0, &tv );
		if( i <= 0 )  return(0);	/* timed out */
		if( !bits )  return(0);		/* no input */
d1134 1
a1134 1
	/* read however much is here already, and remember our position */
d1136 14
a1149 4
		if( (i = read( pc->pkc_fd, pc->pkc_curpos, pc->pkc_left )) <= 0 )  {
			pc->pkc_left = -1;
			pkg_perror(pc->pkc_errlog, "pkg_get: read");
			return(-1);
a1150 2
		pc->pkc_curpos += i;
		pc->pkc_left -= i;
d1155 1
d1234 1
a1234 1
	if( (i = pkg_mread( pc, &(pc->pkc_hdr),
d1249 1
a1249 1
		if( (i=read( pc->pkc_fd,
d1287 2
a1304 1
	if( pc->pkc_left == 0 )  return( pkg_dispatch(pc) );
d1306 1
a1306 1
	/* If no read outstanding, start one. */
d1309 1
a1309 1
		if( pc->pkc_left <= 0 )  return( pkg_dispatch(pc) );
d1312 7
a1318 4
	/* Read the rest of the message, blocking in read() */
	if( pc->pkc_left > 0 && pkg_mread( pc, pc->pkc_curpos, pc->pkc_left ) != pc->pkc_left )  {
		pc->pkc_left = -1;
		return(-1);
d1320 2
a1321 1
	pc->pkc_left = 0;
d1505 129
@


8.2
log
@For perm servers, set SO_REUSEADDR (on BSD systems)
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 8.1 88/10/05 00:25:49 mike Locked $ (BRL)";
a52 1
#include <sys/time.h>		/* for struct timeval */
d55 22
d117 3
d222 10
d346 9
d387 9
d478 8
d550 8
d587 17
a605 2
	if( pc->pkc_buf != (char *)0 )
		fprintf(stderr, "pkg_close(x%x):  buffer clash\n", pc->pkc_buf);
d677 8
d747 9
a755 1
	(void)write( pc->pkc_fd, (char *)&hdr, sizeof(hdr) );
d796 8
d894 8
d934 8
d983 7
d996 1
a996 1
		fprintf( stderr, "pkg_waitfor:  buffer clash\n");
d1051 6
d1085 7
d1098 1
a1098 1
			fprintf( stderr, "pkg_bwaitfor:  buffer clash\n");
d1150 7
d1201 7
d1323 7
d1376 5
d1494 34
@


8.1
log
@Release_3.0
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 7.5 88/09/17 06:59:43 mike Exp $ (BRL)";
d341 2
a342 1
	int pkg_listenfd;
d376 5
@


7.5
log
@cray-->CRAY
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 7.4 88/09/17 06:02:41 mike Locked $ (BRL)";
@


7.4
log
@Added pkg_permport as an intermediate step.  Its for remrt.
Added ability to give pkg_permserver() a numeric service.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 7.3 88/09/10 04:09:18 mike Locked $ (BRL)";
d229 1
a229 1
#ifdef cray
d245 6
a250 6
#ifdef cray
		sinhim.sin_addr = addr_tmp;
#else
		sinhim.sin_addr.s_addr = addr_tmp;
#endif cray
#endif BSD
@


7.3
log
@Added #define for bzero() and bcopy() on SYSV
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 7.2 88/01/15 08:12:26 mike Locked $ (BRL)";
d56 1
a56 1
#if defined(BSD) && !defined(cray) && !defined(mips)
d61 1
a61 1
#include <sys/uio.h>		/* for struct iovec (writev) */
d65 5
a69 5
#include <EXOS/exos/misc.h>
#include <EXOS/sys/socket.h>
#include <EXOS/netinet/in.h>
#include <sys/time.h>		/* for struct timeval */
#define select	bsdselect	/* bloody GL2 select() conflict */
d85 1
d350 3
d354 8
a361 7
	if( (sp = getservbyname( service, "tcp" )) == NULL )  {
		sprintf(errbuf,"pkg_permserver(%s,%d): unknown service\n",
			service, backlog );
		errlog(errbuf);
		return(-1);
	}
	sinme.sin_port = sp->s_port;
a362 1
	sinme.sin_family = AF_INET;
d364 2
a365 2
	/* What routine does SGI give for this one? */
	sinme.sin_port = htons(5558);	/* mfb service!! XXX */
d367 3
@


7.2
log
@add defined mips (SGI 4d) since writev doesnt exist
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 7.1 87/11/02 23:25:05 stay Locked $ (BRL)";
d73 1
d75 4
a78 1
#include "pkg.h"
@


7.1
log
@Release 2.3
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 6.3 87/09/02 19:14:46 mike Exp $ (BRL)";
d56 1
a56 1
#if defined(BSD) && !defined(cray)
@


6.3
log
@Fixed non-Cray error in numeric host addresses.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 6.2 87/08/10 01:04:10 mike Locked $ (BRL)";
@


6.2
log
@When writing no bytes, avoid doing the sys-call.
On the Cray-2, it returns an error.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 6.1 87/07/11 07:50:19 mike Locked $ (BRL)";
d228 1
a228 1
		sinhim.sin_addr.s_addr = addr_tmp;
@


6.1
log
@Release 2.0
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 5.1 87/06/24 21:50:06 mike Rel $ (BRL)";
d640 1
d734 2
a735 1
	(void)write( pc->pkc_fd, buf1, len1 );
@


5.1
log
@Release 1.24
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 4.7 87/06/08 09:44:17 mike Exp $ (BRL)";
@


4.7
log
@Made public domain
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 4.6 87/05/28 06:10:32 mike Locked $ (BRL)";
@


4.6
log
@Fixed problem with pkc_buf not being cleared sometimes.
@
text
@d36 2
a37 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1985 by the United States Army.
 *	All rights reserved.
d40 1
a40 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 4.5 87/04/09 06:27:41 mike Locked $ (BRL)";
@


4.5
log
@Fixed error messages to match new routine names.
@
text
@d41 1
a41 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 4.4 87/02/12 22:05:23 mike Locked $ (BRL)";
d505 2
a506 2
	if( pc->pkc_buf )
		(void)free(pc->pkc_buf);
d847 4
d903 3
d917 2
a918 1
 *  The buffer to contain the actual message is acquired via malloc().
d928 1
d936 4
d954 6
a959 1
	return( pc->pkc_buf );
@


4.4
log
@Release 1.20 -- First Formal Release
@
text
@d41 1
a41 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 4.3 87/02/11 03:58:47 mike Exp $ (BRL)";
d348 1
a348 1
		sprintf(errbuf,"pkg_initserver(%s,%d): unknown service\n",
d363 1
a363 1
		pkg_perror( errlog, "pkg_initserver:  socket" );
d368 1
a368 1
		pkg_perror( errlog, "pkg_initserver: bind" );
d374 1
a374 1
		pkg_perror( errlog, "pkg_initserver:  listen" );
d380 1
a380 1
		pkg_perror( errlog, "pkg_initserver:  socket" );
@


4.3
log
@Converted to specification of pkg headers as char arrays,
to accomodate the Cray.
@
text
@d41 1
a41 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 4.2 87/02/11 02:24:15 mike Locked $ (BRL)";
@


4.2
log
@Initial attempt at separating writev() from BSD, for Cray.
@
text
@d8 4
d41 1
a41 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 4.1 86/12/29 02:49:08 mike Rel1 $ (BRL)";
d100 72
a191 1
#ifdef cray
a192 3
#else
	struct in_addr addr_tmp;
#endif
d225 1
d228 3
d241 1
d243 4
a246 1
#endif
d614 3
a616 3
	hdr.pkg_magic = htons(PKG_MAGIC);
	hdr.pkg_type = htons(type);	/* should see if it's a valid type */
	hdr.pkg_len = htonl(len);
d704 3
a706 3
	hdr.pkg_magic = htons(PKG_MAGIC);
	hdr.pkg_type = htons(type);	/* should see if it's a valid type */
	hdr.pkg_len = htonl(len1+len2);
d776 3
a778 3
	hdr.pkg_magic = htons(PKG_MAGIC);
	hdr.pkg_type = htons(type);
	hdr.pkg_len = htonl(len);
d848 1
a848 1
	if( pc->pkc_hdr.pkg_type != type )  {
d850 2
a851 2
		if( pc->pkc_hdr.pkg_len > 0 )  {
			if( (pc->pkc_buf = malloc(pc->pkc_hdr.pkg_len+2)) == NULL )  {
d860 1
a860 1
	if( pc->pkc_hdr.pkg_len == 0 )
d862 1
a862 1
	if( pc->pkc_hdr.pkg_len > len )  {
d867 1
a867 1
			pc->pkc_hdr.pkg_len, len );
d875 1
a875 1
		excess = pc->pkc_hdr.pkg_len - len;	/* size of excess message */
d893 1
a893 1
	if( (i = pkg_mread( pc, buf, pc->pkc_hdr.pkg_len )) != pc->pkc_hdr.pkg_len )  {
d895 1
a895 1
			"pkg_waitfor:  pkg_mread %d gave %d\n", pc->pkc_hdr.pkg_len, i );
d899 1
a899 1
	return( pc->pkc_hdr.pkg_len );
d929 1
a929 1
	}  while( pc->pkc_hdr.pkg_type != type );
d932 1
a932 1
	if( pc->pkc_hdr.pkg_len == 0 )
d936 1
a936 1
	if( (i = pkg_mread( pc, pc->pkc_buf, pc->pkc_hdr.pkg_len )) != pc->pkc_hdr.pkg_len )  {
d938 1
a938 1
			"pkg_bwaitfor:  pkg_mread %d gave %d\n", pc->pkc_hdr.pkg_len, i );
d1021 1
a1021 1
		if( pc->pkc_switch[i].pks_type != pc->pkc_hdr.pkg_type )
d1032 1
a1032 1
		/* pc->pkc_hdr.pkg_type, pc->pkc_hdr.pkg_len are preserved */
d1037 1
a1037 1
		pc->pkc_hdr.pkg_type, pc->pkc_hdr.pkg_len );
d1076 1
a1076 1
	while( pc->pkc_hdr.pkg_magic != htons(PKG_MAGIC ) )  {
d1091 3
a1093 3
	pc->pkc_hdr.pkg_type = ntohs(pc->pkc_hdr.pkg_type);	/* host order */
	pc->pkc_hdr.pkg_len = ntohl(pc->pkc_hdr.pkg_len);
	if( pc->pkc_hdr.pkg_len < 0 )  pc->pkc_hdr.pkg_len = 0;
d1095 1
a1095 1
	pc->pkc_left = pc->pkc_hdr.pkg_len;
d1102 1
a1102 1
		if( (pc->pkc_buf = malloc(pc->pkc_hdr.pkg_len+2)) == NULL )  {
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 1.18 86/12/19 02:00:19 phil Exp $ (BRL)";
d53 5
a57 1
#ifdef BSD
d116 5
d153 2
a154 1
		sinhim.sin_addr.s_addr = inet_addr(host);
d164 2
a165 1
		bcopy(hp->h_addr, (char *)&sinhim.sin_addr, hp->h_length);
d487 1
a487 1
#ifdef BSD
d538 1
a538 1
#ifdef BSD
d588 1
a588 1
#ifdef BSD
d628 1
a628 1
#ifdef BSD
@


1.18
log
@initserver became transerver
added transerver, made makeconn static
added uname, passwd, to open
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 1.17 86/12/09 22:49:55 phil Locked $ (BRL)";
@


1.17
log
@Added more error checking around malloc() calls.
@
text
@d8 4
a11 4
 *	pkg_open	Open a network connection to a host
 *	pkg_initserver	Create a network server, and listen for connection
 *	pkg_getclient	As network server, accept a new connection
 *	pkg_makeconn	Make a pkg_conn structure
d37 1
a37 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 1.16 86/11/14 21:50:08 mike Locked $ (BRL)";
d76 1
d99 1
a99 1
pkg_open( host, service, switchp, errlog )
d102 3
d203 1
a203 1
 *  			P K G _ I N I T S E R V E R
d205 23
d235 1
a235 1
pkg_initserver( service, backlog, errlog )
d237 1
d359 1
a359 1
	return( pkg_makeconn( fd, switchp, errlog) );
d366 1
d368 2
a369 3
 *  Assumes a client has already been accepted on the given file
 *  descriptor.  This is the case with processes spawned by inetd,
 *  or those comming from pkg_getclient.
d375 1
@


1.16
log
@added pkg_2send to header.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 1.15 86/10/30 18:31:03 phil Locked $ (BRL)";
d359 1
a359 1
		errlog( "pkg_makeconn: malloc failure\n" );
d731 4
a734 1
			pc->pkc_buf = malloc(pc->pkc_hdr.pkg_len+2);
d756 4
a759 1
		bp = malloc(excess);
d982 4
a985 1
		pc->pkc_buf = malloc(pc->pkc_hdr.pkg_len+2);
@


1.15
log
@make pkg_close free pkg_conn struct!
@
text
@d14 1
d37 1
a37 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 1.14 86/10/27 04:05:08 phil Locked $ (BRL)";
@


1.14
log
@Fixed SGI bug, added pkg_nochecking flag for use in parallel environments.
@
text
@d36 1
a36 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 1.13 86/10/24 06:37:42 mike Locked $ (BRL)";
d387 2
a388 1
	(void)free(pc->pkc_buf);
@


1.13
log
@Somewhat working version for SGI.
@
text
@d24 1
d36 1
a36 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 1.11 86/10/24 04:22:55 mike Locked $ (BRL)";
d72 2
d153 1
a153 1
		if((sinhim.sin_addr.s_addr = rhost(&hostp)) < 0) {
d462 2
d564 2
@


1.12
log
@Fixed typos in non-BSD writes.
@
text
@a13 1
 *	pkg_2send	Send a message combined from two buffers
d60 1
d232 1
a462 1
#ifdef BSD
a463 4
#endif
#ifdef SGI_EXCELAN
		i = select( pc->pkc_fd+1, &bits, (char *)0, tv.tv_usec );
#endif
a562 1
#ifdef BSD
a563 4
#endif
#ifdef SGI_EXCELAN
		i = select( pc->pkc_fd+1, &bits, (char *)0, tv.tv_usec );
#endif
a843 1
#ifdef BSD
a844 4
#endif
#ifdef SGI_EXCELAN
		i = select( pc->pkc_fd+1, (char *)&bits, (char *)0, &tv );
#endif
a1008 1
#ifdef BSD
a1010 1
#endif
a1021 1
#ifdef BSD
a1026 3
#else
	errlog( s );
#endif BSD
d1040 20
@


1.11
log
@Added pkg_2send() routine.
@
text
@d14 1
d36 1
a36 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 1.9 86/10/24 01:28:29 mike Exp $ (BRL)";
d317 1
d612 1
d614 1
a614 9
	if( (i = write( pc->pkc_fd, buf1, len1 )) != len1 )  {
		if( i < 0 )  {
			pkg_perror(pc->pkc_errlog, "pkg_2send: write");
			return(-1);
		}
		sprintf(errbuf,"pkg_2send of %d, wrote %d\n", len, i);
		(pc->pkc_errlog)(errbuf);
		return(i);		/* amount of user data sent */
	}
@


1.10
log
@Version where pkg_open works on SGI, if host address is given
in numeric (dotted quad) form.
@
text
@a257 7

	/* wait until someone tries to connect */
	/* XXX not quite right semantics! */
	if(accept(pkg_listenfd,&sinhim) < 0){
		pkg_perror( errlog, "pkg_initserver:  accept" );
		return(-1);
	}
d316 7
d527 104
@


1.9
log
@First pass at version with SGI Excelan stuff.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 1.8 86/10/23 20:28:03 mike Locked $ (BRL)";
d177 1
d464 1
a464 1
		i = select( pc->pkc_fd+1, &bits, (char *)0, &tv );
@


1.8
log
@Added pkg_stream, pkg_flush.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 1.7 86/10/22 23:29:52 phil Locked $ (BRL)";
d40 4
a44 1
#include <sys/uio.h>		/* for struct iovec */
d49 13
d115 1
d124 5
d137 1
d146 11
d159 1
d175 7
d183 6
d208 3
d221 1
d228 6
d235 1
a235 1
	sinme.sin_port = sp->s_port;
d251 14
d285 1
d320 5
d438 1
d440 1
a441 2
	register int i;
#ifdef never
d444 1
a444 1
#endif
d449 1
a449 9
	/*
	 * Flush any queued stream output
	 * XXX - If len < MAXQLEN we may wish to queue this one
	 * also and THEN flush the whole business.  This would
	 * also cover the writev problem for small packets.
	 */
	if( pc->pkc_strpos > 0 )
		pkg_flush( pc );

a450 1
		/* Finish any partially read message */
d454 2
a455 2
#ifdef never
		/* Check socket for more input */
d457 3
a459 2
		tv.tv_usec = 0;		/* poll */
		bits = 1<<pc->pkc_fd;
d461 4
a467 1
#endif
d470 18
d492 1
d505 1
a505 1
			pkg_perror(pc->pkc_errlog, "pkg_send: write");
d513 12
d753 1
d755 4
d960 91
@


1.7
log
@Made pkg_open return PKC_ERROR instead of NULL, and made
it use the common pkg_makeconn code.
@
text
@d11 1
a11 1
 *	pkg_makeconn	Make a pkg_conn structure.
d14 2
d35 1
a35 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 1.6 86/10/22 22:05:32 phil Locked $ (BRL)";
d67 2
d283 1
d371 9
d413 1
a413 1
			perror("pkg_send: write");
d425 73
d658 1
a658 1
			perror("pkg_get: read");
@


1.6
log
@Added pkg_makeconn function.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 1.5 86/10/22 21:13:56 phil Locked $ (BRL)";
d70 1
a70 1
 *  Returns PKC_NULL on error.
a82 1
	register struct pkg_conn *pc;
d100 1
a100 1
			return(PKC_NULL);
d115 1
a115 1
			return(PKC_NULL);
d123 1
a123 1
		return(PKC_NULL);
d129 1
a129 1
		return(PKC_NULL);
d134 1
a134 1
		return(PKC_NULL);
a135 11
	if( (pc = (struct pkg_conn *)malloc(sizeof(struct pkg_conn)))==PKC_NULL )  {
		errlog( "pkg_open: malloc failure\n" );
		return(PKC_NULL);
	}
	pc->pkc_magic = PKG_MAGIC;
	pc->pkc_fd = netfd;
	pc->pkc_switch = switchp;
	pc->pkc_errlog = errlog;
	pc->pkc_left = -1;
	pc->pkc_buf = (char *)0;
	pc->pkc_curpos = (char *)0;
d137 1
a137 1
	return(pc);
a254 1
 *	PKC_NULL	accept would block, try again later
@


1.5
log
@Added per connection error logging.
@
text
@d11 1
d33 1
a33 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 1.4 86/10/22 02:06:12 phil Locked $ (BRL)";
a224 1
	register struct pkg_conn *pc;
d253 28
d282 1
a282 1
		errlog( "pkg_getclient: malloc failure\n" );
d286 1
a286 1
	pc->pkc_fd = s2;
@


1.4
log
@Added per connection pkg_switch.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 1.3 86/10/14 22:11:09 phil Locked $ (BRL)";
d51 9
d61 2
a62 1
			fprintf(stderr,"pkg: bad pointer x%x\n",p);abort();}}
d72 1
a72 1
pkg_open( host, service, switchp )
d76 1
d84 4
d92 2
a93 2
	if( (sinhim.sin_port = atoi(service)) > 0 )  {
		sinhim.sin_port = htons(sinhim.sin_port);
d97 1
a97 1
			fprintf(stderr,"pkg_open(%s,%s): unknown service\n",
d99 1
d112 1
a112 1
			fprintf(stderr,"pkg_open(%s,%s): unknown host\n",
d114 1
d122 1
a122 1
		perror("pkg_open:  client socket");
d128 1
a128 1
		perror("pkg_open: bind");
d132 2
a133 2
	if( connect(netfd, (char *)&sinhim, sizeof(sinhim), 0) < 0 )  {
		perror("pkg_open: client connect");
d137 1
a137 1
		fprintf(stderr,"pkg_open: malloc failure\n");
d143 1
d161 1
a161 1
pkg_initserver( service, backlog )
d164 1
d170 4
d178 1
a178 1
		fprintf(stderr,"pkg_initserver(%s,%d): unknown service\n",
d180 1
d186 1
a186 1
		perror("pkg_initserver:  socket");
d191 1
a191 1
		perror("pkg_initserver: bind");
d197 1
a197 1
		perror("pkg_initserver:  listen");
d216 1
a216 1
pkg_getclient(fd, switchp, nodelay)
d218 1
d226 4
d233 1
a233 1
			perror("pkg_getclient: FIONBIO 1");
d242 1
a242 1
			perror("pkg_getclient: accept");
d249 1
a249 1
			perror("pkg_getclient: FIONBIO 2");
d251 1
a251 1
			perror("pkg_getclient: FIONBIO 3");
d254 1
a254 1
		fprintf(stderr,"pkg_getclient: malloc failure\n");
d260 1
d288 1
d295 3
a297 3
int
pkg_mread(fd, bufp, n)
int fd;
d301 1
d305 1
d309 1
a309 1
			perror("pkg_mread");
d342 2
d346 1
a346 1
	register int i;
d387 1
a387 1
		fprintf(stderr,"pkg_send of %d+%d, wrote %d\n",
d389 1
d436 1
a436 1
		fprintf(stderr,
d439 3
a441 2
		if( (i = pkg_mread( pc->pkc_fd, buf, len )) != len )  {
			fprintf(stderr,
d443 1
d448 2
a449 2
		if( (i = pkg_mread( pc->pkc_fd, bp, excess )) != excess )  {
			fprintf(stderr,
d452 1
d461 2
a462 2
	if( (i = pkg_mread( pc->pkc_fd, buf, pc->pkc_hdr.pkg_len )) != pc->pkc_hdr.pkg_len )  {
		fprintf(stderr,
d464 1
d504 2
a505 2
	if( (i = pkg_mread( pc->pkc_fd, pc->pkc_buf, pc->pkc_hdr.pkg_len )) != pc->pkc_hdr.pkg_len )  {
		fprintf(stderr,
d507 1
d571 1
d576 1
a576 1
int
d604 1
a604 1
	fprintf(stderr,"pkg_get:  no handler for message type %d, len %d\n",
d606 1
d616 1
d622 1
a622 1
int
d636 1
a636 1
	if( (i = pkg_mread( pc->pkc_fd, &(pc->pkc_hdr),
d638 4
a641 2
		if(i > 0)
			fprintf(stderr,"pkg_gethdr: header read of %d?\n", i);
d645 1
a645 1
		fprintf(stderr,"pkg_gethdr: skipping noise x%x %c\n",
d648 1
d654 2
a655 1
			fprintf(stderr,"pkg_gethdr: hdr read=%d?\n",i);
a693 2
	register int i;

d704 1
a704 1
	if( pc->pkc_left > 0 && pkg_mread( pc->pkc_fd, pc->pkc_curpos, pc->pkc_left ) != pc->pkc_left )  {
d710 38
@


1.3
log
@New version (from ADDCOMPE sources)
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 1.1 86/09/19 17:58:25 phil Exp $ (BRL)";
d45 1
a45 1
#include "../h/pkg.h"
d62 1
a62 1
pkg_open( host, service )
d65 1
d125 1
d192 2
a193 1
pkg_getclient(fd, nodelay)
d230 1
d544 1
a544 1
	for( i=0; i < pkg_swlen; i++ )  {
d547 1
a547 1
		if( pkg_switch[i].pks_type != pc->pkc_hdr.pkg_type )
d559 1
a559 1
		pkg_switch[i].pks_handler(pc, tempbuf);
d599 3
a601 1
		fprintf(stderr,"pkg_gethdr: skipping noise\n");
@


1.2
log
@Extra printing.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: pkg.c,v 1.1 86/10/02 02:18:35 mike Locked $ (BRL)";
d45 1
a45 1
#include "./pkg.h"
d48 1
d51 2
a52 10
/*
 *  Format of the message header as it is transmitted over the network
 *  connection.  Internet network order is used.
 */
#define PKG_MAGIC	0x41FE
struct pkg_header {
	unsigned short	pkg_magic;		/* Ident */
	unsigned short	pkg_type;		/* Message Type */
	long		pkg_len;		/* Byte count of remainder */
};
d59 1
a59 1
 *  Returns fd (>=0) if connected, -1 on error.
d61 1
a61 1
int
d69 2
a70 2
	int netfd;
	int port;
d81 1
a81 1
			fb_log( "pkg_open(%s,%s): unknown service\n",
d83 1
a83 1
			return(-1);
d95 1
a95 1
			fb_log( "pkg_open(%s,%s): unknown host\n",
d97 1
a97 1
			return(-1);
d104 2
a105 2
		fb_log( "pkg_open : client socket failure.\n" );
		return(-1);
d109 3
a111 3
	if( bind(netfd, &sinme, sizeof(sinme)) < 0 )  {
		fb_log( "pkg_open : bind failure.\n" );
		return(-1);
d114 3
a116 3
	if( connect(netfd, &sinhim, sizeof(sinhim), 0) < 0 )  {
		fb_log( "pkg_open : client connect failure.\n" );
		return(-1);
d118 11
a128 1
	return(netfd);
a130 2
static int pkg_listenfd;

d153 1
a153 1
		fb_log( "pkg_initserver(%s,%d): unknown service\n",
d160 1
a160 1
		fb_log( "pkg_initserver : socket failure.\n" );
d165 1
a165 1
		fb_log( "pkg_initserver : bind failure.\n" );
d171 1
a171 1
		fb_log( "pkg_initserver : listen failure.\n" );
d180 1
a180 2
 *  Given an fd with a listen outstanding, accept the connection
 *  and return the connection's fd.
d185 3
a187 3
 *	>=0	fd of newly accepted connection
 *	-1	accept would block, try again later
 *	-2	fatal error
d189 1
a189 1
int
d196 1
d201 1
a201 1
			fb_log( "pkg_getclient : FIONBIO 1 failed.\n" );
d209 3
a211 3
				return(-1);
			fb_log( "pkg_getclient : accept failed.\n" );
			return(-2);
d217 1
a217 1
			fb_log( "pkg_getclient : FIONBIO 2 failed.\n" );
d219 1
a219 1
			fb_log( "pkg_getclient : FIONBIO 3 failed.\n" );
d221 10
a230 1
	return(s2);
d236 1
a236 1
 *  Gracefully release the connection.
d239 2
a240 1
pkg_close(fd)
d242 7
a248 1
	(void)close(fd);
d264 1
a264 1
unsigned	n;
d266 2
a267 2
	register unsigned	count = 0;
	register int		nread;
d270 1
a270 1
		nread = read(fd, bufp, n-count);
d272 1
a272 1
			fb_log( "pkg_mread : read failed.\n" );
a283 6
 int pkg_left = -1;	/* number of bytes pkg_get still expects */
/* negative -> read new header, 0 -> it's all here, >0 -> more to come */
static char *pkg_buf;		/* start of dynamic buffer for pkg_get */
static char *pkg_curpos;	/* pkg_get current position in pkg_buf */
static struct pkg_header hdr;	/* hdr of cur msg, pkg_waitfor/pkg_get */

d297 1
a297 1
pkg_send( type, buf, len, fd )
d301 1
a301 1
int fd;
d309 1
d314 2
a315 2
		if( pkg_left > 0 )
			if( pkg_block(fd) < 0 )
d321 2
a322 2
		bits = 1<<fd;
		i = select( fd+1, &bits, (char *)0, (char *)0, &tv );
d324 1
a324 1
			if( pkg_block(fd) < 0 )
d327 1
a327 1
	} while( pkg_left > 0 );
d343 1
a343 1
	if( (i = writev( fd, cmdvec, (len>0)?2:1 )) != len+sizeof(hdr) )  {
d345 1
a345 1
			fb_log( "pkg_send : write failed.\n" );
d348 2
a349 1
		fb_log( "pkg_send of %d+%d, wrote %d\n", sizeof(hdr), len, i );
a363 3
 *  NOTE that this routine and pkg_get() share lots of state via
 *  4 external (static) variables.
 *
d367 1
a367 1
pkg_waitfor( type, buf, len, fd )
d371 1
a371 1
int fd;
d374 2
a375 1
/*	fb_log( "pkg_waitfor(%d,%d,%d,%d)\n", type, buf, len, fd );*/
d377 2
a378 2
	if( pkg_left >= 0 )
		if( pkg_block( fd ) < 0 )
d381 2
a382 2
	if( pkg_gethdr( fd, buf ) < 0 )  return(-1);
	if( hdr.pkg_type != type )  {
d384 3
a386 3
		if( hdr.pkg_len > 0 )  {
			pkg_buf = malloc(hdr.pkg_len+2);
			pkg_curpos = pkg_buf;
d390 2
a391 2
	pkg_left = -1;
	if( hdr.pkg_len == 0 )
d393 1
a393 1
	if( hdr.pkg_len > len )  {
d396 6
a401 4
		fb_log( "pkg_waitfor:  message %d exceeds buffer %d\n",
			hdr.pkg_len, len );
		if( (i = pkg_mread( fd, buf, len )) != len )  {
			fb_log( "pkg_waitfor:  pkg_mread %d gave %d\n", len, i );
d404 1
a404 1
		excess = hdr.pkg_len - len;	/* size of excess message */
d406 3
a408 2
		if( (i = pkg_mread( fd, bp, excess )) != excess )  {
			fb_log( "pkg_waitfor: pkg_mread of excess, %d gave %d\n",
d418 3
a420 2
	if( (i = pkg_mread( fd, buf, hdr.pkg_len )) != hdr.pkg_len )  {
		fb_log( "pkg_waitfor:  pkg_mread %d gave %d\n", hdr.pkg_len, i );
d423 1
a423 1
	return( hdr.pkg_len );
a435 3
 *  NOTE that this routine and pkg_get() share lots of state via
 *  4 external (static) variables.
 *
d439 1
a439 1
pkg_bwaitfor( type, fd )
d441 1
a441 1
int fd;
d445 1
d448 2
a449 2
		if( pkg_left >= 0 )
			if( pkg_block(fd) < 0 )
d451 1
a451 1
		if( pkg_gethdr( fd, (char *)0 ) < 0 )
d453 1
a453 1
	}  while( hdr.pkg_type != type );
d455 2
a456 2
	pkg_left = -1;
	if( hdr.pkg_len == 0 )
d460 3
a462 2
	if( (i = pkg_mread( fd, pkg_buf, hdr.pkg_len )) != hdr.pkg_len )  {
		fb_log( "pkg_bwaitfor:  pkg_mread %d gave %d\n", hdr.pkg_len, i );
d464 1
a464 1
	return( pkg_buf );
a480 3
 *  NOTE that this routine and pkg_waitfor() share lots of state via
 *  4 external (static) variables.
 *
d486 2
a487 1
pkg_get(fd)
d493 4
a496 2
	if( pkg_left < 0 )  {
		if( pkg_gethdr( fd, (char *)0 ) < 0 )  return(-1);
d501 2
a502 2
		bits = (1<<fd);
		i = select( fd+1, &bits, (char *)0, (char *)0, &tv );
d508 4
a511 4
	if( pkg_left > 0 )  {
		if( (i = read( fd, pkg_curpos, pkg_left )) < 0 )  {
			pkg_left = -1;
			fb_log( "pkg_get : read failed.\n" );
d514 3
a516 3
		pkg_curpos += i;
		pkg_left -= i;
		if( pkg_left > 0 )
d520 1
a520 1
	return( pkg_dispatch() );
d531 2
a532 1
pkg_dispatch()
d536 2
a537 1
	if( pkg_left != 0 )  return(-1);
d543 1
a543 1
		if( pkg_switch[i].pks_type != hdr.pkg_type )
d548 1
a548 1
		 * reset all global state variables first!
d550 6
a555 5
		tempbuf = pkg_buf;
		pkg_buf = (char *)0;
		pkg_curpos = (char *)0;
		pkg_left = -1;		/* safety */
		pkg_switch[i].pks_handler(hdr.pkg_type, tempbuf, hdr.pkg_len);
d558 6
a563 6
	fb_log( "pkg_get:  no handler for message type %d, len %d\n",
		hdr.pkg_type, hdr.pkg_len );
	(void)free(pkg_buf);
	pkg_buf = (char *)0;
	pkg_curpos = (char *)0;
	pkg_left = -1;		/* safety */
d575 2
a576 1
pkg_gethdr( fd, buf )
d581 2
a582 1
	if( pkg_left >= 0 )  return(1);	/* go get it! */
d588 2
a589 1
	if( (i = pkg_mread( fd, &hdr, sizeof(hdr) )) != sizeof(hdr) )  {
d591 1
a591 1
			fb_log( "pkg_gethdr: header read of %d?\n", i);
d594 2
a595 4
	while( hdr.pkg_magic != htons(PKG_MAGIC ) )  {
		fb_log("pkg_gethdr: skipping noise x%x %c\n",
			*((unsigned char *)&hdr),
			*((unsigned char *)&hdr) );
d597 5
a601 3
		bcopy( ((char *)&hdr)+1, (char *)&hdr, sizeof(hdr)-1);
		if( (i=read( fd, ((char *)&hdr)+sizeof(hdr)-1, 1 )) != 1 )  {
			fb_log("pkg_gethdr: hdr read=%d?\n",i);
d605 6
a610 6
	hdr.pkg_type = ntohs(hdr.pkg_type);	/* host order */
	hdr.pkg_len = ntohl(hdr.pkg_len);
	if( hdr.pkg_len < 0 )  hdr.pkg_len = 0;
	pkg_buf = (char *)0;
	pkg_left = hdr.pkg_len;
	if( pkg_left == 0 )  return(1);		/* msg here, no data */
d613 1
a613 1
		pkg_buf = buf;
d616 1
a616 1
		pkg_buf = malloc(hdr.pkg_len+2);
d618 1
a618 1
	pkg_curpos = pkg_buf;
d637 2
a638 1
pkg_block(fd)
d642 2
a643 1
	if( pkg_left == 0 )  return( pkg_dispatch() );
d646 3
a648 3
	if( pkg_left < 0 )  {
		if( pkg_gethdr( fd, (char *)0 ) < 0 )  return(-1);
		if( pkg_left <= 0 )  return( pkg_dispatch() );
d652 2
a653 2
	if( pkg_left > 0 && pkg_mread( fd, pkg_curpos, pkg_left ) != pkg_left )  {
		pkg_left = -1;
d656 2
a657 72
	pkg_left = 0;
	return( pkg_dispatch() );
}


/*
 *  			R A W _ P K G _ S E N D
 *
 *  Send an iovec list of "raw packets", i.e. user is responsible
 *   for putting on magic headers, network byte order, etc.
 *
 *  Note that the whole message should be transmitted by
 *  TCP with only one TCP_PUSH at the end, due to the use of writev().
 *
 *  Returns number of bytes of user data actually sent.
 */
int
raw_pkg_send( buf, len, fd )
struct iovec buf[];
int len;
int fd;
{
	struct timeval tv;
	long bits;
	register int i;
	int start;

	if( len < 0 )  len=0;

	do  {
		/* Finish any partially read message */
		if( pkg_left > 0 )
			if( pkg_block(fd) < 0 )
				return(-1);
#ifdef never
		/* Check socket for more input */
		tv.tv_sec = 0;
		tv.tv_usec = 0;		/* poll */
		bits = 1<<fd;
		i = select( fd+1, &bits, (char *)0, (char *)0, &tv );
		if( i > 0 && bits )
			if( pkg_block(fd) < 0 )
				return(-1);
#endif
	} while( pkg_left > 0 );

#ifdef NEVER
	hdr.pkg_magic = htons(PKG_MAGIC);
	hdr.pkg_type = htons(type);	/* should see if it's a valid type */
	hdr.pkg_len = htonl(len);

	cmdvec[0].iov_base = (caddr_t)&hdr;
	cmdvec[0].iov_len = sizeof(hdr);
	cmdvec[1].iov_base = (caddr_t)buf;
	cmdvec[1].iov_len = len;
#endif NEVER

	/*
	 * TODO:  set this FD to NONBIO.  If not all output got sent,
	 * loop in select() waiting for capacity to go out, and
	 * reading input as well.  Prevents deadlocking.
	 */
	start = 0;
	while( len > 0 ) {
		if( (i = writev( fd, &buf[start], (len>8?8:len) )) < 0 )  {
			fb_log( "pkg_send : write failed.\n" );
			return(-1);
		}
		len -= 8;
		start += 8;
	}
	return(len);
@


1.1
log
@Initial revision
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d575 3
a577 1
		fb_log("pkg_gethdr: skipping noise\n");
@
