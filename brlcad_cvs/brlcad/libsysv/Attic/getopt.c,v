head	11.4;
access;
symbols
	ansi-20040405-merged:11.2
	postmerge-20040405-ansi:11.2
	premerge-20040404-ansi:11.2
	postmerge-autoconf:11.2
	autoconf-freeze:11.2
	premerge-autoconf:11.2
	ansi-20040316-freeze:11.2
	postmerge-20040315-windows:11.2
	premerge-20040315-windows:11.2
	windows-20040315-freeze:11.2
	autoconf-20031203:11.2
	autoconf-20031202:11.2
	autoconf-branch:11.2.0.12
	phong-branch:11.2.0.10
	photonmap-branch:11.2.0.8
	rel-6-1-DP:11.2
	windows-branch:11.2.0.6
	rel-6-0-2:11.2
	ansi-branch:11.2.0.4
	rel-6-0-1-branch:11.2.0.2
	hartley-6-0-post:11.2
	hartley-6-0-pre:11.2
	rel-6-0-1:11.2
	rel-6-0:11.2
	rel-5-4:11.1
	offsite-5-3-pre:11.1
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.4
date	2004.05.21.18.07.36;	author morrison;	state dead;
branches;
next	11.3;

11.3
date	2004.05.10.15.30.47;	author erikg;	state Exp;
branches;
next	11.2;

11.2
date	2001.04.20.22.30.01;	author morrison;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.50.58;	author mike;	state Rel4_4;
branches;
next	10.7;

10.7
date	94.12.08.20.37.22;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.12.08.19.56.43;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.12.01.19.15.15;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.10.18.16.09.02;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.09.01.05.50.17;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.08.12.18.47.09;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.36.19;	author mike;	state Rel4_0;
branches;
next	9.4;

9.4
date	91.09.23.15.31.12;	author butler;	state Exp;
branches;
next	9.3;

9.3
date	91.09.09.16.46.12;	author butler;	state Exp;
branches;
next	9.2;

9.2
date	90.05.04.03.52.45;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.45.29;	author mike;	state Rel3_5;
branches;
next	8.4;

8.4
date	89.04.14.15.25.26;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.02.10.23.02.53;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	89.01.25.05.30.42;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.25.01;	author mike;	state Rel3_0;
branches;
next	7.1;

7.1
date	87.11.02.23.23.19;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.07.49.00;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.21.48.05;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.12.22.01.25;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.02.47.28;	author mike;	state Rel1;
branches;
next	1.3;

1.3
date	86.11.18.21.25.50;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.10.11.03.51.29;	author phil;	state Exp;
branches;
next	1.1;

1.1
date	86.08.13.03.15.30;	author mike;	state Exp;
branches;
next	;


desc
@@


11.4
log
@moved to src/
@
text
@/*
 *			G E T O P T . C
 *
 *  Important note -
 *	If getopt() it going to be used more than once, it is necessary
 *	to reinitialize optind=1 before beginning on the next argument list.
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimitied.
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libsysv/getopt.c,v 11.3 2004/05/10 15:30:47 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#if defined(HAVE_GETOPT)
#ifndef lint
char getopt_dummy;   /* some systems can't handle empty object modules */
#else
#endif
#else

#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"

/*
 * get option letter from argument vector
 */

#if defined(__convexc__)
/* brain dead Convex compiler/loader won't let us redefine a variable declared
 * and initialized in their library, despite the fact that we don't even use
 * that module of their library!
 */
extern int opterr;            /* set to zero to suppress errors */
extern int optind;            /* index into parent argv vector */
#else
int	opterr = 1;		/* set to zero to suppress errors */
int	optind = 1;		/* index into parent argv vector */
#endif
int	optopt;			/* character checked for validity */
char	*optarg;		/* argument associated with option */

#define BADCH	(int)'?'
#define EMSG	""
#define tell(s)	if(opterr)  { \
		fputs(*nargv,stderr);fputs(s,stderr); \
		fputc(optopt,stderr);fputc('\n',stderr); \
	} return(BADCH);

int
getopt(nargc,nargv,ostr)
int	nargc;
#if defined(linux)
char	* const nargv[];
const char *ostr;
#else
char	*nargv[];
char	*ostr;
#endif
{
	static char	*place = EMSG;	/* option letter processing */
	register char	*oli;		/* option letter list index */

	if(*place=='\0') {			/* update scanning pointer */
		if(optind >= nargc || *(place = nargv[optind]) != '-' ||
		   !*++place)  {
		   	place = EMSG;
			return(EOF);
		}
		if (*place == '-') {	/* found "--" */
			place = EMSG;
			++optind;
			return(EOF);
		}
	}				/* option letter okay? */
	if ((optopt = (int)*place++) == (int)':' || !(oli = strchr(ostr,optopt))) {
		if(*place == '\0') {
			++optind;
			place = EMSG;
		}
		tell(": illegal option -- ");
	}
	if (*++oli != ':') {		/* don't need argument */
		optarg = NULL;
		if (*place == '\0') {
			++optind;
			place = EMSG;
		}
	}
	else {				/* need an argument */
		if (*place) optarg = place;	/* no white space */
		else if (nargc <= ++optind) {	/* no arg */
			place = EMSG;
			tell(": option requires an argument -- ");
		}
	 	else optarg = nargv[optind];	/* white space */
		place = EMSG;
		++optind;
	}
	return(optopt);			/* dump back option letter */
}

#endif
@


11.3
log
@change conf.h to a wrapped config.h
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/libsysv/getopt.c,v 11.2 2001/04/20 22:30:01 morrison Exp $ (BRL)";
@


11.2
log
@CONST to const
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libsysv/getopt.c,v 11.1 1995/01/04 09:50:58 mike Rel4_4 $ (BRL)";
d15 5
a19 1
#include "conf.h"
@


11.1
log
@Release_4.4
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: /m/cad/libsysv/RCS/getopt.c,v 10.7 94/12/08 20:37:22 mike Exp $ (BRL)";
d63 2
a64 2
char	* CONST nargv[];
CONST char *ostr;
@


10.7
log
@Different systems define getopt() args differently.
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: /m/cad/libsysv/RCS/getopt.c,v 10.6 94/12/08 19:56:43 mike Exp Locker: mike $ (BRL)";
@


10.6
log
@The proper definition of getopt().
Inspired by Linux.
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: /m/cad/libsysv/RCS/getopt.c,v 10.5 94/12/01 19:15:15 mike Exp Locker: mike $ (BRL)";
d62 1
d65 4
@


10.5
log
@Added string(s).h
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: /m/cad/libsysv/RCS/getopt.c,v 10.4 94/10/18 16:09:02 mike Exp Locker: mike $ (BRL)";
d59 1
d62 2
a63 2
char	**nargv,
	*ostr;
@


10.4
log
@index() is now strchr()
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: /m/cad/libsysv/RCS/getopt.c,v 10.3 94/09/01 05:50:17 gdurf Exp Locker: mike $ (BRL)";
d25 5
@


10.3
log
@Added wrapper for systems who already have getopt
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: /m/cad/libsysv/RCS/getopt.c,v 10.2 1994/08/12 18:47:09 gdurf Exp gdurf $ (BRL)";
d74 1
a74 1
	if ((optopt = (int)*place++) == (int)':' || !(oli = index(ostr,optopt))) {
@


10.2
log
@Added include of conf.h
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: /m/cad/libsysv/RCS/getopt.c,v 10.1 1991/10/12 06:36:19 mike Rel4_0 gdurf $ (BRL)";
d17 7
d100 2
@


10.1
log
@Release_4.0
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: /m/cad/libsysv/RCS/getopt.c,v 9.4 91/09/23 15:31:12 butler Exp $ (BRL)";
d15 2
d19 2
a20 6
#if defined(SYSV) || defined(CRAY)
#define index(s, c)	strchr(s, c)
extern char	*strchr();
#else
extern char	*index();
#endif
d31 2
a32 2
extern int opterr;		/* set to zero to suppress errors */
extern int optind;		/* index into parent argv vector */
@


9.4
log
@added check to see if we're on Convex.  If so, we can't have globally
defined initialized variables that have the same name as a globally defined
initialized variable in one of their libraries.  Despite the fact that we
don't use that module from their library.
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: /m/cad/libsysv/RCS/getopt.c,v 9.3 91/09/09 16:46:12 butler Exp $ (BRL)";
@


9.3
log
@made CRAY look like SYSV
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: /m/cad/libsysv/RCS/getopt.c,v 9.2 90/05/04 03:52:45 mike Exp $ (BRL)";
d27 9
d38 1
@


9.2
log
@Documented how to call more than once.
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: getopt.c,v 9.1 89/05/19 05:45:29 mike Locked $ (BRL)";
d17 1
a17 1
#ifdef SYSV
@


9.1
log
@Release_3.5
@
text
@d3 4
d12 1
a12 1
static char RCSid[] = "@@(#)$Header: getopt.c,v 8.4 89/04/14 15:25:26 mike Exp $ (BRL)";
@


8.4
log
@Implemented "opterr" flag
@
text
@d8 1
a8 1
static char RCSid[] = "@@(#)$Header: getopt.c,v 8.3 89/02/10 23:02:53 mike Locked $ (BRL)";
@


8.3
log
@index/strchr for SYSV
@
text
@d8 1
a8 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d23 3
a25 3
int	opterr = 1,		/* useless, never set or used */
	optind = 1,		/* index into parent argv vector */
	optopt;			/* character checked for validity */
d30 4
a33 2
#define tell(s)	fputs(*nargv,stderr);fputs(s,stderr); \
		fputc(optopt,stderr);fputc('\n',stderr);return(BADCH);
@


8.2
log
@Fixed for serial re-entrancy.
@
text
@d1 9
d13 7
a39 1
	char	*index();
@


8.1
log
@Release_3.0
@
text
@d26 6
a31 2
	if(!*place) {			/* update scanning pointer */
		if(optind >= nargc || *(place = nargv[optind]) != '-' || !*++place) return(EOF);
d33 1
d39 4
a42 1
		if(!*place) ++optind;
d47 4
a50 1
		if (!*place) ++optind;
@


7.1
log
@Release 2.3
@
text
@@


6.1
log
@Release 2.0
@
text
@@


5.1
log
@Release 1.24
@
text
@@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@@


1.3
log
@True public-domain version.
@
text
@@


1.2
log
@Added BSD #ifdef
@
text
@a0 12
/*	@@(#)getopt.c	1.5	*/
/*	3.0 SID #	1.2	*/
/*LINTLIBRARY*/
#define NULL	(char *)0
#define EOF	(-1)
#define ERR(s, c)	if(opterr){\
	extern int strlen(), write();\
	char errbuf[2];\
	errbuf[0] = c; errbuf[1] = '\n';\
	(void) write(2, argv[0], (unsigned)strlen(argv[0]));\
	(void) write(2, s, (unsigned)strlen(s));\
	(void) write(2, errbuf, 2);}
d2 1
a2 5
extern int strcmp();
#ifdef BSD
#define strchr index
#endif BSD
extern char *strchr();
d4 7
a10 4
int	opterr = 1;
int	optind = 1;
int	optopt;
char	*optarg;
d12 9
a20 4
int
getopt(argc, argv, opts)
int	argc;
char	**argv, *opts;
d22 3
a24 3
	static int sp = 1;
	register int c;
	register char *cp;
d26 4
a29 3
	if(sp == 1)
		if(optind >= argc ||
		   argv[optind][0] != '-' || argv[optind][1] == '\0')
a30 3
		else if(strcmp(argv[optind], "--") == 0) {
			optind++;
			return(EOF);
d32 4
a35 8
	optopt = c = argv[optind][sp];
	if(c == ':' || (cp=strchr(opts, c)) == NULL) {
		ERR(": illegal option -- ", c);
		if(argv[optind][++sp] == '\0') {
			optind++;
			sp = 1;
		}
		return('?');
d37 1
a37 15
	if(*++cp == ':') {
		if(argv[optind][sp+1] != '\0')
			optarg = &argv[optind++][sp+1];
		else if(++optind >= argc) {
			ERR(": option requires an argument -- ", c);
			sp = 1;
			return('?');
		} else
			optarg = argv[optind++];
		sp = 1;
	} else {
		if(argv[optind][++sp] == '\0') {
			sp = 1;
			optind++;
		}
d39 1
d41 11
a51 1
	return(c);
@


1.1
log
@Initial revision
@
text
@d15 3
@
