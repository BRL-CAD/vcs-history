head	11.19;
access;
symbols
	ansi-20040405-merged:11.17.2.1
	postmerge-20040405-ansi:11.18
	premerge-20040404-ansi:11.17
	postmerge-autoconf:11.17
	autoconf-freeze:11.17
	premerge-autoconf:11.17
	postmerge-20040315-windows:11.17
	premerge-20040315-windows:11.17
	windows-20040315-freeze:11.17
	autoconf-20031203:11.17
	autoconf-20031202:11.17
	autoconf-branch:11.17.0.10
	phong-branch:11.17.0.8
	photonmap-branch:11.17.0.6
	rel-6-1-DP:11.17
	windows-branch:11.17.0.4
	rel-6-0-2:11.15
	ansi-branch:11.17.0.2
	rel-6-0-1-branch:11.15.0.2
	hartley-6-0-post:11.16
	hartley-6-0-pre:11.15
	rel-6-0-1:11.15
	rel-6-0:11.15
	rel-5-4:11.8
	offsite-5-3-pre:11.12
	rel-5-3:11.8
	rel-5-2:11.8
	rel-5-1-branch:11.8.0.2
	rel-5-1:11.8
	rel-5-0:11.5
	rel-5-0-beta:11.5
	rel-4-5:11.4
	ctj-4-5-post:11.4
	ctj-4-5-pre:11.4
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.19
date	2004.05.21.17.46.53;	author morrison;	state dead;
branches;
next	11.18;

11.18
date	2004.04.05.07.38.59;	author morrison;	state Exp;
branches;
next	11.17;

11.17
date	2002.08.20.17.08.32;	author jra;	state Exp;
branches
	11.17.2.1;
next	11.16;

11.16
date	2002.08.15.20.55.45;	author hartley;	state Exp;
branches;
next	11.15;

11.15
date	2001.08.22.13.19.59;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	2001.05.17.20.05.46;	author morrison;	state Exp;
branches;
next	11.13;

11.13
date	2001.04.05.19.35.58;	author morrison;	state Exp;
branches;
next	11.12;

11.12
date	2000.09.08.05.57.14;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	2000.09.01.02.43.47;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	2000.08.24.23.07.03;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	2000.08.01.12.55.22;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	2000.01.31.16.19.46;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	2000.01.04.17.58.21;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	99.12.29.23.23.40;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	99.05.10.21.45.52;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	97.01.02.21.45.23;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	96.08.27.05.57.20;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.02.22.05.56.55;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.21.44;	author mike;	state Rel4_4;
branches;
next	1.2;

1.2
date	94.12.08.18.06.43;	author jra;	state Exp;
branches;
next	1.1;

1.1
date	93.05.21.01.02.24;	author gdurf;	state Exp;
branches;
next	;

11.17.2.1
date	2002.09.19.18.02.11;	author morrison;	state Exp;
branches;
next	;


desc
@Template
@


11.19
log
@moved to src/off/
@
text
@/*
 *			G - O F F . C
 *
 *  Program to convert a BRL-CAD model (in a .g file) to an OFF file
 *  by calling on the NMG booleans.
 *  Inspired by Michael J. Markowski's g-jack.c converter.
 *
 *  Author
 *	Glenn Durfee
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimitied.
 */

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/off/g-off.c,v 11.18 2004/04/05 07:38:59 morrison Exp $ (BRL)";
#endif

#include <stdio.h>
#include <math.h>
#include <string.h>
#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "plot3.h"

RT_EXTERN(union tree *do_region_end, (struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data));


static char	usage[] = "Usage: %s [-v] [-d] [-xX lvl] [-a abs_tol] [-r rel_tol] [-n norm_tol] [-p prefix] brlcad_db.g object(s)\n";

static int	NMG_debug;	/* saved arg of -X, for longjmp handling */
static int	verbose;
static int	debug_plots;	/* Make debugging plots */
static int	ncpu = 1;	/* Number of processors */
static char	*prefix = NULL;	/* output filename prefix. */
static FILE	*fp_fig;	/* Jack Figure file. */
static struct db_i		*dbip;
static struct rt_vls		base_seg;
static struct rt_tess_tol	ttol;
static struct rt_tol		tol;
static struct model		*the_model;

static struct db_tree_state	jack_tree_state;	/* includes tol & model */

static int	regions_tried = 0;
static int	regions_done = 0;

static void nmg_to_psurf(struct nmgregion *r, FILE *fp_psurf);
static void jack_faces(struct nmgregion *r, FILE *fp_psurf, int *map);

/*
 *			M A I N
 */
int
main(int argc, char **argv)
{
	char		*dot, *fig_file;
	register int	c;
	double		percent;

#ifdef BSD
	setlinebuf( stderr );
#else
#	if defined( SYSV ) && !defined( sgi ) && !defined(CRAY2) && \
	 !defined(n16)
		(void) setvbuf( stderr, (char *) NULL, _IOLBF, BUFSIZ );
#	endif
#	if defined(sgi) && defined(mips)
		if( setlinebuf( stderr ) != 0 )
			perror("setlinebuf(stderr)");
#	endif
#endif

	jack_tree_state = rt_initial_tree_state;	/* struct copy */
	jack_tree_state.ts_tol = &tol;
	jack_tree_state.ts_ttol = &ttol;
	jack_tree_state.ts_m = &the_model;

	ttol.magic = RT_TESS_TOL_MAGIC;
	/* Defaults, updated by command line options. */
	ttol.abs = 0.0;
	ttol.rel = 0.01;
	ttol.norm = 0.0;

	/* XXX These need to be improved */
	tol.magic = RT_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;

	rt_init_resource( &rt_uniresource, 0, NULL );

	the_model = nmg_mm();
	RT_LIST_INIT( &rt_g.rtg_vlfree );	/* for vlist macros */

	/* Get command line arguments. */
	while ((c = getopt(argc, argv, "a:dn:p:r:vx:P:X:")) != EOF) {
		switch (c) {
		case 'a':		/* Absolute tolerance. */
			ttol.abs = atof(optarg);
			break;
		case 'd':
			debug_plots = 1;
			break;
		case 'n':		/* Surface normal tolerance. */
			ttol.norm = atof(optarg);
			break;
		case 'p':		/* Prefix for Jack file names. */
			prefix = optarg;
			break;
		case 'r':		/* Relative tolerance. */
			ttol.rel = atof(optarg);
			break;
		case 'v':
			verbose++;
			break;
		case 'P':
			ncpu = atoi( optarg );
			rt_g.debug = 1;	/* XXX DEBUG_ALLRAYS -- to get core dumps */
			break;
		case 'x':
			sscanf( optarg, "%x", (unsigned int *)&rt_g.debug );
			break;
		case 'X':
			sscanf( optarg, "%x", (unsigned int *)&rt_g.NMG_debug );
			NMG_debug = rt_g.NMG_debug;
			break;
		default:
			fprintf(stderr, usage, argv[0]);
			exit(1);
			break;
		}
	}

	if (optind+1 >= argc) {
		fprintf(stderr, usage, argv[0]);
		exit(1);
	}

	/* Open brl-cad database */
	argc -= optind;
	argv += optind;
	if ((dbip = db_open(argv[0], "r")) == DBI_NULL) {
		perror(argv[0]);
		exit(1);
	}
	db_dirbuild(dbip);

	/* Create .fig file name and open it. */
	fig_file = rt_malloc(sizeof(prefix) + sizeof(argv[0] + 4), "st");
	/* Ignore leading path name. */
	if ((dot = strrchr(argv[0], '/')) != (char *)NULL) {
		if (prefix)
			strcat(strcpy(fig_file, prefix), 1 + dot);
		else
			strcpy(fig_file, 1 + dot);
	} else {
		if (prefix)
			strcat(strcpy(fig_file, prefix), argv[0]);
		else
			strcpy(fig_file, argv[0]);
	}

	/* Get rid of any file name extension (probably .g). */
	if ((dot = strrchr(fig_file, '.')) != (char *)NULL)
		*dot = (char)NULL;
	strcat(fig_file, ".fig");	/* Add required Jack suffix. */

	if ((fp_fig = fopen(fig_file, "w")) == NULL)
		perror(fig_file);
	fprintf(fp_fig, "figure {\n");
	rt_vls_init(&base_seg);		/* .fig figure file's main segment. */

	/* Walk indicated tree(s).  Each region will be output separately */
	(void)db_walk_tree(dbip, argc-1, (const char **)(argv+1),
		1,			/* ncpu */
		&jack_tree_state,
		0,			/* take all regions */
		do_region_end,
		nmg_booltree_leaf_tess,
		(genptr_t)NULL);	/* in librt/nmg_bool.c */

	fprintf(fp_fig, "\troot=%s_seg.base;\n", rt_vls_addr(&base_seg));
	fprintf(fp_fig, "}\n");
	fclose(fp_fig);
	rt_free(fig_file, "st");
	rt_vls_free(&base_seg);

	percent = 0;
	if(regions_tried>0)  percent = ((double)regions_done * 100) / regions_tried;
	printf("Tried %d regions, %d converted successfully.  %g%%\n",
		regions_tried, regions_done, percent);

	return 0;
}

/*
*			D O _ R E G I O N _ E N D
*
*  Called from db_walk_tree().
*
*  This routine must be prepared to run in parallel.
*/
union tree *do_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
{
	extern FILE		*fp_fig;
	union tree		*ret_tree;
	struct nmgregion	*r;
	struct rt_list		vhead;

	RT_CK_TESS_TOL(tsp->ts_ttol);
	RT_CK_TOL(tsp->ts_tol);
	NMG_CK_MODEL(*tsp->ts_m);

	RT_LIST_INIT(&vhead);

	if (RT_G_DEBUG&DEBUG_TREEWALK || verbose) {
		char	*sofar = db_path_to_string(pathp);
		rt_log("\ndo_region_end(%d %d%%) %s\n",
			regions_tried,
			regions_tried>0 ? (regions_done * 100) / regions_tried : 0,
			sofar);
		rt_free(sofar, "path string");
	}

	if (curtree->tr_op == OP_NOP)
		return  curtree;

	regions_tried++;
	/* Begin rt_bomb() protection */
	if( ncpu == 1 ) {
		if( RT_SETJUMP )  {
			/* Error, bail out */
			RT_UNSETJUMP;		/* Relinquish the protection */

			/* Sometimes the NMG library adds debugging bits when
			 * it detects an internal error, before rt_bomb().
			 */
			rt_g.NMG_debug = NMG_debug;	/* restore mode */

			/* Release the tree memory & input regions */
			db_free_tree(curtree, &rt_uniresource);		/* Does an nmg_kr() */

			/* Get rid of (m)any other intermediate structures */
			if( (*tsp->ts_m)->magic != -1L )
				nmg_km(*tsp->ts_m);

			/* Now, make a new, clean model structure for next pass. */
			*tsp->ts_m = nmg_mm();
			goto out;
		}
	}
	(void)nmg_model_fuse(*tsp->ts_m, tsp->ts_tol);
	ret_tree = nmg_booltree_evaluate(curtree, tsp->ts_tol, &rt_uniresource);	/* librt/nmg_bool.c */
	RT_UNSETJUMP;		/* Relinquish the protection */
	if( ret_tree )
		r = ret_tree->tr_d.td_r;
	else
		r = (struct nmgregion *)NULL;
	regions_done++;
	if (r != 0) {
		FILE	*fp_psurf;
		int	i;
		struct rt_vls	file_base;
		struct rt_vls	file;

		rt_vls_init(&file_base);
		rt_vls_init(&file);
		rt_vls_strcpy(&file_base, prefix);
		rt_vls_strcat(&file_base, DB_FULL_PATH_CUR_DIR(pathp)->d_namep);
		/* Dots confuse Jack's Peabody language.  Change to '_'. */
		for (i = 0; i < file_base.vls_len; i++)
			if (file_base.vls_str[i] == '.')
				file_base.vls_str[i] = '_';

		/* Write color attribute to .fig figure file. */
		if (tsp->ts_mater.ma_color_valid != 0) {
			fprintf(fp_fig, "\tattribute %s {\n",
				rt_vls_addr(&file_base));
			fprintf(fp_fig, "\t\trgb = (%f, %f, %f);\n",
				V3ARGS(tsp->ts_mater.ma_color));
			fprintf(fp_fig, "\t\tambient = 0.18;\n");
			fprintf(fp_fig, "\t\tdiffuse = 0.72;\n");
			fprintf(fp_fig, "\t}\n");
		}

		/* Write segment attributes to .fig figure file. */
		fprintf(fp_fig, "\tsegment %s_seg {\n", rt_vls_addr(&file_base));
		fprintf(fp_fig, "\t\tpsurf=\"%s.pss\";\n", rt_vls_addr(&file_base));
		if (tsp->ts_mater.ma_color_valid != 0)
			fprintf(fp_fig,
				"\t\tattribute=%s;\n", rt_vls_addr(&file_base));
		fprintf(fp_fig, "\t\tsite base->location=trans(0,0,0);\n");
		fprintf(fp_fig, "\t}\n");

		if( rt_vls_strlen(&base_seg) <= 0 )  {
			rt_vls_vlscat( &base_seg, &file_base );
		} else {
			fprintf(fp_fig, "\tjoint %s_jt {\n",
				rt_vls_addr(&file_base));
			fprintf(fp_fig,
				"\t\tconnect %s_seg.base to %s_seg.base;\n",
				rt_vls_addr(&file_base),
				rt_vls_addr(&base_seg) );
			fprintf(fp_fig, "\t}\n");
		}

		rt_vls_vlscat(&file, &file_base);
		rt_vls_strcat(&file, ".pss");	/* Required Jack suffix. */

		/* Write psurf to .pss file. */
		if ((fp_psurf = fopen(rt_vls_addr(&file), "w")) == NULL)
			perror(rt_vls_addr(&file));
		else {
			nmg_to_psurf(r, fp_psurf);
			fclose(fp_psurf);
			if(verbose) rt_log("*** Wrote %s\n", rt_vls_addr(&file));
		}
		rt_vls_free(&file);

		/* Also write as UNIX-plot file, if desired */
		if( debug_plots )  {
			FILE	*fp;
			rt_vls_vlscat(&file, &file_base);
			rt_vls_strcat(&file, ".pl");

			if ((fp = fopen(rt_vls_addr(&file), "w")) == NULL)
				perror(rt_vls_addr(&file));
			else {
				struct rt_list	vhead;
				pl_color( fp,
					(int)(tsp->ts_mater.ma_color[0] * 255),
					(int)(tsp->ts_mater.ma_color[1] * 255),
					(int)(tsp->ts_mater.ma_color[2] * 255) );
				/* nmg_pl_r( fp, r ); */
				RT_LIST_INIT( &vhead );
				nmg_r_to_vlist( &vhead, r, 0 );
				rt_vlist_to_uplot( fp, &vhead );
				fclose(fp);
				if(verbose) rt_log("*** Wrote %s\n", rt_vls_addr(&file));
			}
			rt_vls_free(&file);
		}

		/* NMG region is no longer necessary */
		nmg_kr(r);
	}

	/*
	 *  Dispose of original tree, so that all associated dynamic
	 *  memory is released now, not at the end of all regions.
	 *  A return of TREE_NULL from this routine signals an error,
	 *  so we need to cons up an OP_NOP node to return.
	 */
	db_free_tree(curtree, &rt_uniresource);		/* Does an nmg_kr() */

out:
	GETUNION(curtree, tree);
	curtree->tr_op = OP_NOP;
	return(curtree);
}

/*
*	N M G _ T O _ P S U R F
*
*	Convert an nmg region into Jack format.  This routine makes a
*	list of unique vertices and writes them to the ascii Jack
*	data base file.  Then a routine to generate the face vertex
*	data is called.
*/

static void
nmg_to_psurf(struct nmgregion *r, FILE *fp_psurf)
                    		/* NMG region to be converted. */
    		          	/* Jack format file to write vertex list to. */
{
	int			i;
	int			*map;	/* map from v->index to Jack vert # */
	struct nmg_ptbl		vtab;	/* vertex table */

	map = (int *)rt_calloc(r->m_p->maxindex, sizeof(int *), "Jack vert map");

	/* Built list of vertex structs */
	nmg_vertex_tabulate( &vtab, &r->l.magic );

	/* XXX What to do if 0 vertices?  */

	/* Print list of unique vertices and convert from mm to cm. */
	for (i = 0; i < NMG_TBL_END(&vtab); i++)  {
		struct vertex			*v;
		register struct vertex_g	*vg;
		v = (struct vertex *)NMG_TBL_GET(&vtab,i);
		NMG_CK_VERTEX(v);
		vg = v->vg_p;
		NMG_CK_VERTEX_G(vg);
		NMG_INDEX_ASSIGN( map, v, i+1 );  /* map[v->index] = i+1 */
		fprintf(fp_psurf, "%f\t%f\t%f\n",
			vg->coord[X] / 10.,
			vg->coord[Y] / 10.,
			vg->coord[Z] / 10.);
	}
	fprintf(fp_psurf, ";;\n");

	jack_faces(r, fp_psurf, map);

	nmg_tbl( &vtab, TBL_FREE, 0 );
	rt_free( (char *)map, "Jack vert map" );
}


/*
*	J A C K _ F A C E S
*
*	Continues the conversion of an nmg into Jack format.  Before
*	this routine is called, a list of unique vertices has been
*	stored in a heap.  Using this heap and the nmg structure, a
*	list of face vertices is written to the Jack data base file.
*/
static void
jack_faces(struct nmgregion *r, FILE *fp_psurf, int *map)
                    		/* NMG region to be converted. */
    		          	/* Jack format file to write face vertices to. */
   		     
{
	struct edgeuse		*eu;
	struct faceuse		*fu;
	struct loopuse		*lu;
	struct shell		*s;
	struct vertex		*v;

	for (RT_LIST_FOR(s, shell, &r->s_hd)) {
		/* Shell is made of faces. */
		for (RT_LIST_FOR(fu, faceuse, &s->fu_hd)) {
			NMG_CK_FACEUSE(fu);
			if (fu->orientation != OT_SAME)
				continue;
			for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
				NMG_CK_LOOPUSE(lu);
				if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC) {
					for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
						NMG_CK_EDGEUSE(eu);
						NMG_CK_EDGE(eu->e_p);
						NMG_CK_VERTEXUSE(eu->vu_p);
						NMG_CK_VERTEX(eu->vu_p->v_p);
						NMG_CK_VERTEX_G(eu->vu_p->v_p->vg_p);
		    				fprintf(fp_psurf, "%d ", NMG_INDEX_GET(map,eu->vu_p->v_p));
					}
				} else if (RT_LIST_FIRST_MAGIC(&lu->down_hd)
		  			== NMG_VERTEXUSE_MAGIC) {
		  			v = RT_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p;
					NMG_CK_VERTEX(v);
					NMG_CK_VERTEX_G(v->vg_p);
		  			fprintf(fp_psurf, "%d ", NMG_INDEX_GET(map,v));
				} else
					rt_log("jack_faces: loopuse mess up! (1)\n");
				fprintf(fp_psurf, ";\n");
			}
		}

		/* Shell contains loops. */
		for (RT_LIST_FOR(lu, loopuse, &s->lu_hd)) {
			NMG_CK_LOOPUSE(lu);
			if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC) {
				for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
					NMG_CK_EDGEUSE(eu);
					NMG_CK_EDGE(eu->e_p);
					NMG_CK_VERTEXUSE(eu->vu_p);
					NMG_CK_VERTEX(eu->vu_p->v_p);
					NMG_CK_VERTEX_G(eu->vu_p->v_p->vg_p);
		  			fprintf(fp_psurf, "%d ", NMG_INDEX_GET(map,eu->vu_p->v_p));
				}
			} else if (RT_LIST_FIRST_MAGIC(&lu->down_hd)
				== NMG_VERTEXUSE_MAGIC) {
				v = RT_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p;
				NMG_CK_VERTEX(v);
				NMG_CK_VERTEX_G(v->vg_p);
				fprintf(fp_psurf, "%d ", NMG_INDEX_GET(map,v));
			} else
				rt_log("jack_faces: loopuse mess up! (1)\n");
			fprintf(fp_psurf, ";\n");
		}

		/* Shell contains edges. */
		for (RT_LIST_FOR(eu, edgeuse, &s->eu_hd)) {
			NMG_CK_EDGEUSE(eu);
			NMG_CK_EDGE(eu->e_p);
			NMG_CK_VERTEXUSE(eu->vu_p);
			NMG_CK_VERTEX(eu->vu_p->v_p);
			NMG_CK_VERTEX_G(eu->vu_p->v_p->vg_p);
			fprintf(fp_psurf, "%d ", NMG_INDEX_GET(map,eu->vu_p->v_p));
		}
		if (RT_LIST_FIRST_MAGIC(&s->eu_hd) == NMG_EDGEUSE_MAGIC)
			fprintf(fp_psurf, ";\n");

		/* Shell contains a single vertex. */
		if (s->vu_p) {
			NMG_CK_VERTEXUSE(s->vu_p);
			NMG_CK_VERTEX(s->vu_p->v_p);
			NMG_CK_VERTEX_G(s->vu_p->v_p->vg_p);
			fprintf(fp_psurf, "%d;\n", NMG_INDEX_GET(map,s->vu_p->v_p));
		}

		if (RT_LIST_IS_EMPTY(&s->fu_hd) &&
			RT_LIST_IS_EMPTY(&s->lu_hd) &&
			RT_LIST_IS_EMPTY(&s->eu_hd) && !s->vu_p) {
			rt_log("WARNING jack_faces: empty shell\n");
		}

	}
	fprintf(fp_psurf, ";;\n");
}
@


11.18
log
@merge of ansi-6-0-branch into HEAD
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.17
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/off/g-off.c,v 11.15 2001/08/22 13:19:59 jra Exp $ (BRL)";
d57 2
a58 2
static void nmg_to_psurf();
static void jack_faces();
d64 1
a64 3
main(argc, argv)
int	argc;
char	*argv[];
d214 1
a214 5
union tree *do_region_end(tsp, pathp, curtree, client_data)
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
d383 3
a385 3
nmg_to_psurf(r, fp_psurf)
struct nmgregion *r;		/* NMG region to be converted. */
FILE		*fp_psurf;	/* Jack format file to write vertex list to. */
d430 4
a433 4
jack_faces(r, fp_psurf, map)
struct nmgregion *r;		/* NMG region to be converted. */
FILE		*fp_psurf;	/* Jack format file to write face vertices to. */
int		*map;
@


11.17.2.1
log
@Initial ANSIfication
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/off/g-off.c,v 11.17 2002/08/20 17:08:32 jra Exp $ (BRL)";
d57 2
a58 2
static void nmg_to_psurf(struct nmgregion *r, FILE *fp_psurf);
static void jack_faces(struct nmgregion *r, FILE *fp_psurf, int *map);
d64 3
a66 1
main(int argc, char **argv)
d216 5
a220 1
union tree *do_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
d389 3
a391 3
nmg_to_psurf(struct nmgregion *r, FILE *fp_psurf)
                    		/* NMG region to be converted. */
    		          	/* Jack format file to write vertex list to. */
d436 4
a439 4
jack_faces(struct nmgregion *r, FILE *fp_psurf, int *map)
                    		/* NMG region to be converted. */
    		          	/* Jack format file to write face vertices to. */
   		     
@


11.16
log
@Converted from K&R to ANSI C - RFH
@
text
@d57 2
a58 2
static void nmg_to_psurf(struct nmgregion *r, FILE *fp_psurf);
static void jack_faces(struct nmgregion *r, FILE *fp_psurf, int *map);
d64 3
a66 1
main(int argc, char **argv)
d216 5
a220 1
union tree *do_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
d389 3
a391 3
nmg_to_psurf(struct nmgregion *r, FILE *fp_psurf)
                    		/* NMG region to be converted. */
    		          	/* Jack format file to write vertex list to. */
d436 4
a439 4
jack_faces(struct nmgregion *r, FILE *fp_psurf, int *map)
                    		/* NMG region to be converted. */
    		          	/* Jack format file to write face vertices to. */
   		     
@


11.15
log
@lint
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/off/g-off.c,v 11.14 2001/05/17 20:05:46 morrison Exp $ (BRL)";
d57 2
a58 2
static void nmg_to_psurf();
static void jack_faces();
d64 1
a64 3
main(argc, argv)
int	argc;
char	*argv[];
d214 1
a214 5
union tree *do_region_end(tsp, pathp, curtree, client_data)
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
d383 3
a385 3
nmg_to_psurf(r, fp_psurf)
struct nmgregion *r;		/* NMG region to be converted. */
FILE		*fp_psurf;	/* Jack format file to write vertex list to. */
d430 4
a433 4
jack_faces(r, fp_psurf, map)
struct nmgregion *r;		/* NMG region to be converted. */
FILE		*fp_psurf;	/* Jack format file to write face vertices to. */
int		*map;
@


11.14
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/off/g-off.c,v 11.13 2001/04/05 19:35:58 morrison Exp $ (BRL)";
d134 1
a134 1
			sscanf( optarg, "%x", &rt_g.debug );
d137 1
a137 1
			sscanf( optarg, "%x", &rt_g.NMG_debug );
@


11.13
log
@updated SIGNED to signed
updated CONST to const
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/off/g-off.c,v 11.12 2000/09/08 05:57:14 mike Exp $ (BRL)";
d233 1
a233 1
	if (rt_g.debug&DEBUG_TREEWALK || verbose) {
@


11.12
log
@
Tree routines need resource pointer
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/off/g-off.c,v 11.11 2000/09/01 02:43:47 mike Exp $ (BRL)";
d187 1
a187 1
	(void)db_walk_tree(dbip, argc-1, (CONST char **)(argv+1),
@


11.11
log
@
Headers
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/off/g-off.c,v 11.10 2000/08/24 23:07:03 mike Exp $ (BRL)";
d103 2
d258 1
a258 1
			db_free_tree(curtree);		/* Does an nmg_kr() */
d270 1
a270 1
	ret_tree = nmg_booltree_evaluate(curtree, tsp->ts_tol);	/* librt/nmg_bool.c */
d371 1
a371 1
	db_free_tree(curtree);		/* Does an nmg_kr() */
@


11.10
log
@
RCSid
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/off/g-off.c,v 11.9 2000/08/01 12:55:22 jra Exp $ (BRL)";
d28 1
d33 1
a33 1
#include "../librt/debug.h"
@


11.9
log
@Replaced db_scan() with db_dirbuild()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/off/g-off.c,v 11.8 2000/01/31 16:19:46 jra Exp $ (BRL)";
@


11.8
log
@Eliminated some unused variables
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/off/g-off.c,v 11.7 2000/01/04 17:58:21 bparker Exp $ (BRL)";
d156 1
a156 1
	db_scan(dbip, (int (*)())db_diradd, 1, NULL);
@


11.7
log
@*- add client_data to db_walk_tree
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/off/g-off.c,v 11.6 1999/12/29 23:23:40 mike Exp $ (BRL)";
a67 1
	int		i;
@


11.6
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/off/g-off.c,v 11.5 1999/05/10 21:45:52 mike Exp $ (BRL)";
d34 1
a34 1
RT_EXTERN(union tree *do_region_end, (struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree));
d190 2
a191 1
		nmg_booltree_leaf_tess);	/* in librt/nmg_bool.c */
d214 1
a214 1
union tree *do_region_end(tsp, pathp, curtree)
d218 1
@


11.5
log
@ma_override to ma_color_valid
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/off/g-off.c,v 11.4 1997/01/02 21:45:23 jra Exp $ (BRL)";
d68 1
a68 1
	int		i, ret;
d157 1
a157 1
	db_scan(dbip, (int (*)())db_diradd, 1);
d185 1
a185 1
	ret = db_walk_tree(dbip, argc-1, (CONST char **)(argv+1),
@


11.4
log
@Minor mods for Irix 6.2.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/off/RCS/g-off.c,v 11.3 1996/08/27 05:57:20 mike Exp jra $ (BRL)";
d289 1
a289 1
		if (tsp->ts_mater.ma_override != 0) {
d302 1
a302 1
		if (tsp->ts_mater.ma_override != 0)
@


11.3
log
@Upgraded to latest NMG library
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/off/RCS/g-off.c,v 11.2 1995/02/22 05:56:55 mike Exp mike $ (BRL)";
d56 3
d384 1
a384 1
int
d431 1
@


11.2
log
@nmg_model_fuse() is still accounting for 25% of the runtime.  In order
to correct this, it is necessary for me to make calling nmg_model_fuse()
a pre-condition of calling nmg_booltree_evaluate().  That way it's done
exactly once per region.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/off/RCS/g-off.c,v 11.1 1995/01/04 10:21:44 mike Rel4_4 mike $ (BRL)";
d216 1
d263 1
a263 1
	r = nmg_booltree_evaluate(curtree, tsp->ts_tol);	/* librt/nmg_bool.c */
d265 4
d393 1
a393 1
	nmg_region_vertex_list( &vtab, r );
@


11.1
log
@Release_4.4
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/off/RCS/g-off.c,v 1.2 94/12/08 18:06:43 jra Exp $ (BRL)";
d261 1
@


1.2
log
@MOd for CRAY2.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/off/RCS/g-off.c,v 1.1 93/05/21 01:02:24 gdurf Exp Locker: jra $ (BRL)";
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.18 93/04/03 05:00:32 mike Exp $ (BRL)";
d239 4
a242 3
	if( ncpu == 1 && RT_SETJUMP )  {
		/* Error, bail out */
		RT_UNSETJUMP;		/* Relinquish the protection */
d244 4
a247 4
		/* Sometimes the NMG library adds debugging bits when
		 * it detects an internal error, before rt_bomb().
		 */
		rt_g.NMG_debug = NMG_debug;	/* restore mode */
d249 2
a250 2
		/* Release the tree memory & input regions */
		db_free_tree(curtree);		/* Does an nmg_kr() */
d252 8
a259 7
		/* Get rid of (m)any other intermediate structures */
		if( (*tsp->ts_m)->magic != -1L )
			nmg_km(*tsp->ts_m);
	
		/* Now, make a new, clean model structure for next pass. */
		*tsp->ts_m = nmg_mm();
		goto out;
@
