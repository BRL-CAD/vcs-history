head	11.13;
access;
symbols
	ansi-20040405-merged:11.11.2.1
	postmerge-20040405-ansi:11.12
	premerge-20040404-ansi:11.11
	postmerge-autoconf:11.11
	autoconf-freeze:11.11
	premerge-autoconf:11.11
	postmerge-20040315-windows:11.11
	premerge-20040315-windows:11.11
	windows-20040315-freeze:11.11
	autoconf-20031203:11.11
	autoconf-20031202:11.11
	autoconf-branch:11.11.0.10
	phong-branch:11.11.0.8
	photonmap-branch:11.11.0.6
	rel-6-1-DP:11.11
	windows-branch:11.11.0.4
	rel-6-0-2:11.9
	ansi-branch:11.11.0.2
	rel-6-0-1-branch:11.9.0.2
	hartley-6-0-post:11.10
	hartley-6-0-pre:11.9
	rel-6-0-1:11.9
	rel-6-0:11.9
	rel-5-4:11.6
	offsite-5-3-pre:11.8
	rel-5-3:11.6
	rel-5-2:11.6
	rel-5-1-branch:11.6.0.2
	rel-5-1:11.6
	rel-5-0:11.4
	rel-5-0-beta:11.4
	rel-4-5:11.3
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.13
date	2004.05.21.17.46.53;	author morrison;	state dead;
branches;
next	11.12;

11.12
date	2004.04.05.07.38.59;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2002.08.20.17.08.32;	author jra;	state Exp;
branches
	11.11.2.1;
next	11.10;

11.10
date	2002.08.15.20.55.45;	author hartley;	state Exp;
branches;
next	11.9;

11.9
date	2001.08.22.13.19.59;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	2000.09.01.02.42.51;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	2000.08.24.23.07.03;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	2000.02.01.13.34.18;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	2000.01.31.16.19.46;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	98.09.14.15.59.21;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	97.01.02.21.41.49;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	96.12.31.17.52.33;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.21.44;	author mike;	state Rel4_4;
branches;
next	1.5;

1.5
date	94.12.01.19.12.01;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	94.11.22.15.33.32;	author jra;	state Exp;
branches;
next	1.3;

1.3
date	94.11.07.10.53.49;	author jra;	state Exp;
branches;
next	1.2;

1.2
date	93.07.23.18.08.50;	author gdurf;	state Exp;
branches;
next	1.1;

1.1
date	93.05.21.01.02.45;	author gdurf;	state Exp;
branches;
next	;

11.11.2.1
date	2002.09.19.18.02.11;	author morrison;	state Exp;
branches;
next	;


desc
@Working.
@


11.13
log
@moved to src/off/
@
text
@/*
 *		O F F - G . C
 *
 *  Program to convert from Digital Equipment Corporation's OFF
 *  (Object File Format) to BRL-CAD NMG objects.
 *  Inspired by Mike Markowski's jack-g Jack to NMG converter.
 *
 *  Author -
 *	Glenn Edward Durfee
 *
 *  Source -
 *	The U.S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited
 *
 */

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/off/off-g.c,v 11.12 2004/04/05 07:38:59 morrison Exp $ (BRL)";
#endif

#include <stdio.h>
#include <string.h>
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "nmg.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "wdb.h"

static struct bn_tol tol;

/*
 *         R E A D _ F A C E S 
 *
 * Reads the geometry from the the geometry file and creates the appropriate
 *  vertices and faces.
 */

int read_faces(struct model *m, FILE *fgeom)
{
	int 		   nverts, nfaces, nedges;
	register int 	   i, j, fail=0;
	fastf_t 	  *pts;		
	struct vertex 	 **verts;
	struct faceuse 	 **outfaceuses;
	struct nmgregion  *r;
	struct shell 	  *s;

		/* Get numbers of vertices and faces, and grab the appropriate amount of memory */
	if (fscanf(fgeom, "%d %d %d", &nverts, &nfaces, &nedges) != 3)
		rt_bomb("Cannot read number of vertices, faces, edges.\n");

	pts = (fastf_t *) rt_malloc(sizeof(fastf_t) * 3 * nverts, "points list");
	verts = (struct vertex **) rt_malloc(sizeof(struct vertex *) * nverts, "vertices");
	outfaceuses = (struct faceuse **) rt_malloc(sizeof(struct faceuse *) * nfaces, "faceuses");

		/* Read in vertex geometry, store in geometry list */		
	for (i = 0; i < nverts; i++) {
		if (fscanf(fgeom, "%lf %lf %lf", &pts[3*i], &pts[3*i+1], &pts[3*i+2]) != 3)
			rt_bomb("Not enough data points in geometry file.\n");

		verts[i] = (struct vertex *) 0;
		fscanf(fgeom, "%*[^\n]");
	}

	r = nmg_mrsv(m);		/* Make region, empty shell, vertex. */
	s = RT_LIST_FIRST(shell, &r->s_hd);


	for (i = 0; i < nfaces; i++) {		/* Read in each of the faces */
		struct vertex **vlist;
		int *pinds;

		if (fscanf(fgeom, "%d", &nedges) != 1) {
			fprintf(stderr, "Not enough faces in geometry file.\n");
			exit(1);
		}
					/* Grab memory for list for this face. */		
		vlist = (struct vertex **) rt_malloc(sizeof(struct vertex *) * nedges, "vertex list");
		pinds = (int *) rt_malloc(sizeof(int) * nedges, "point indicies");

		for (j = 0; j < nedges; j++) {			/* Read list of point indicies. */
			if (fscanf(fgeom, "%d", &pinds[j]) != 1) {
				fprintf(stderr, "Not enough points on face.\n");
				exit(1);
			}
			vlist[j] = verts[pinds[j]-1];
		}

		outfaceuses[i] = nmg_cface(s, vlist, nedges);	/* Create face. */
		NMG_CK_FACEUSE(outfaceuses[i]);

		for (j = 0; j < nedges; j++)		/* Save (possibly) newly created vertex structs. */
			verts[pinds[j]-1] = vlist[j];
		
		fscanf(fgeom, "%*[^\n]");

		rt_free((char *)vlist, "vertext list");
		rt_free((char *)pinds, "point indicies");
	}

	for (i = 0; i < nverts; i++)
		if (verts[i] != 0)
			nmg_vertex_gv(verts[i], &pts[3*i]);
		else
			fprintf(stderr, "Warning: vertex %d unused.\n", i+1);

	for (i = 0; i < nfaces; i++) {
		plane_t pl;

		fprintf(stderr, "planeeqning face %d.\n", i);
		if( nmg_loop_plane_area( RT_LIST_FIRST( loopuse , &outfaceuses[i]->lu_hd ) , pl ) < 0.0 )
			fail = 1;
		else
			nmg_face_g( outfaceuses[i] , pl );

	}

	if (fail) return (-1);

	nmg_gluefaces(outfaceuses, nfaces, &tol);
	nmg_region_a(r, &tol);

	rt_free((char *)pts, "points list");
	return (0);
}
		



int off2nmg(FILE *fpin, struct rt_wdb *fpout)
{
	char title[64], geom_fname[64];
	char rname[67], sname[67];
	char buf[200], buf2[200];

	FILE *fgeom;
	struct model *m;

	title[0] = geom_fname[0] = '\0';

	fgets(buf, sizeof(buf), fpin);
	while (!feof(fpin)) {				/* Retrieve the important data */
		if (sscanf(buf, "name %[^\n]s", buf2) > 0)
			strncpy(title, buf2, sizeof(title));
/*		if (sscanf(buf, "author %[^\n]s", buf2) > 0)
			strncpy(author, buf2, sizeof(author));
*/		if (sscanf(buf, "geometry %[^\n]s", buf2) > 0) {
			char dtype[40], format[40];
			if (sscanf(buf2, "%s %s %s", dtype, format, geom_fname) != 3)
				rt_bomb("Incomplete geometry field in input file.");
			if (strcmp(dtype, "indexed_poly") != 0)
				rt_bomb("Unknown geometry data type. Must be \"indexed_poly\".");
		}
		fgets(buf, sizeof(buf), fpin);
	}

	if (strlen(title) < (unsigned)1) 
		fprintf(stderr, "Warning: no title\n");

	if (strlen(geom_fname) < (unsigned)1)
		rt_bomb("Error: no geometry filename.");

	if ((fgeom = fopen(geom_fname, "r")) == NULL) {
		fprintf(stderr, "off2nmg: cannot open %s (geometry description) for reading\n",
			geom_fname);
		exit(1);
	}

	m = nmg_mm();
	read_faces(m, fgeom);
	fclose(fgeom);	
	
	strcpy(sname, "s.");	strcat(sname, title);
	strcpy(rname, "r.");	strcat(rname, title);

	mk_id(fpout, title);
	mk_nmg(fpout, sname, m);
	mk_comb1(fpout, rname, sname, 1);

	nmg_km(m);
	return (0);
}
		

int main(int argc, char **argv)
{
	FILE *fpin;
	struct rt_wdb *fpout;

	tol.magic = RT_TOL_MAGIC;	/* Copied from proc-db/nmgmodel.c */
	tol.dist = 0.01;
	tol.dist_sq = 0.01 * 0.01;
	tol.perp = 0.001;
	tol.para = 0.999;

	/* Get filenames and open the files. */
	if (argc != 3)  {
		fprintf(stderr, "Usage: off-g file.off file.g\n");
		return 2;
	}
	if ((fpin = fopen(argv[1], "rt")) == NULL) {
		fprintf(stderr, "%s: cannot open %s for reading\n",
			argv[0], argv[1]);
		return (1);
	}
	if ((fpout = wdb_fopen(argv[2])) == NULL) {
		fprintf(stderr, "%s: cannot create %s\n",
			argv[0], argv[2]);
		return (1);
	}

				
	off2nmg(fpin, fpout);

	fclose(fpin);
	wdb_close(fpout);

	return (0);
}
@


11.12
log
@merge of ansi-6-0-branch into HEAD
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.11
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/off/off-g.c,v 11.9 2001/08/22 13:19:59 jra Exp $ (BRL)";
d44 1
a44 3
int read_faces(m, fgeom)
struct model *m;
FILE *fgeom;	
d136 1
a136 3
int off2nmg(fpin, fpout)
FILE *fpin;
struct rt_wdb *fpout;
d191 1
a191 3
int main(argc, argv)
int argc;
char **argv;
@


11.11.2.1
log
@Initial ANSIfication
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/off/off-g.c,v 11.11 2002/08/20 17:08:32 jra Exp $ (BRL)";
d44 3
a46 1
int read_faces(struct model *m, FILE *fgeom)
d138 3
a140 1
int off2nmg(FILE *fpin, struct rt_wdb *fpout)
d195 3
a197 1
int main(int argc, char **argv)
@


11.10
log
@Converted from K&R to ANSI C - RFH
@
text
@d44 3
a46 1
int read_faces(struct model *m, FILE *fgeom)
d138 3
a140 1
int off2nmg(FILE *fpin, struct rt_wdb *fpout)
d195 3
a197 1
int main(int argc, char **argv)
@


11.9
log
@lint
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/off/off-g.c,v 11.8 2000/09/01 02:42:51 mike Exp $ (BRL)";
d44 1
a44 3
int read_faces(m, fgeom)
struct model *m;
FILE *fgeom;	
d136 1
a136 3
int off2nmg(fpin, fpout)
FILE *fpin;
struct rt_wdb *fpout;
d191 1
a191 3
int main(argc, argv)
int argc;
char **argv;
@


11.8
log
@
Changed to new libwdb.
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/off/off-g.c,v 11.7 2000/08/24 23:07:03 mike Exp $ (BRL)";
d49 1
a49 1
	register int 	   i, j, fail;
@


11.7
log
@
RCSid
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/off/off-g.c,v 11.6 2000/02/01 13:34:18 jra Exp $ (BRL)";
d27 1
d29 1
d33 1
a33 1
#include "rtlist.h"
d139 2
a140 1
FILE *fpin, *fpout;
d199 2
a200 1
	FILE *fpin, *fpout;
d209 13
a221 21
	if (argc < 2) {
		fpin = stdin;
		fpout = stdout;
	} else if (argc < 3) {
		if ((fpin = fopen(argv[1], "rt")) == NULL) {
			fprintf(stderr, "%s: cannot open %s for reading\n",
				argv[0], argv[1]);
			return (1);
		}
		fpout = stdout;
	} else if (argc < 4) {
		if ((fpin = fopen(argv[1], "rt")) == NULL) {
			fprintf(stderr, "%s: cannot open %s for reading\n",
				argv[0], argv[1]);
			return (1);
		}
		if ((fpout = fopen(argv[2], "a")) == NULL) {
			fprintf(stderr, "%s: cannot open %s for appending\n",
				argv[0], argv[2]);
			return (1);
		}
d228 1
a228 1
	fclose(fpout);
@


11.6
log
@Oops, accidentally removed a comma in that last checkin
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/off/off-g.c,v 11.5 2000/01/31 16:19:46 jra Exp $ (BRL)";
@


11.5
log
@Eliminated some unused variables
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/off/off-g.c,v 11.4 1998/09/14 15:59:21 bparker Exp $ (BRL)";
d139 1
a139 1
	char title[64] geom_fname[64];
@


11.4
log
@*- fix typos
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/off/off-g.c,v 11.3 1997/01/02 21:41:49 jra Exp $ (BRL)";
d139 1
a139 1
	char title[64], author[64], geom_fname[64];
d146 1
a146 1
	title[0] = author[0] = geom_fname[0] = '\0';
a196 1
	char title[64], buf[200], *bp;
@


11.3
log
@Added newline at end of file.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/off/RCS/off-g.c,v 11.2 1996/12/31 17:52:33 jra Exp jra $ (BRL)";
d171 2
a172 1
		fprintf(stderr, "%s: cannot open %s (geometry description) for reading\n", geom_fname);
@


11.2
log
@changed rt_tol to bn_tol, made tolerance global, added tolerance to nmg_gluefaces() call.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/off/RCS/off-g.c,v 11.1 1995/01/04 10:21:44 mike Rel4_4 jra $ (BRL)";
d235 1
a235 1
}@


11.1
log
@Release_4.4
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/off/RCS/off-g.c,v 1.5 94/12/01 19:12:01 mike Exp $ (BRL)";
d33 2
a52 1
	struct rt_tol 	   tol;
a112 6
	tol.magic = RT_TOL_MAGIC;	/* Copied from proc-db/nmgmodel.c */
	tol.dist = 0.01;
	tol.dist_sq = 0.01 * 0.01;
	tol.perp = 0.001;
	tol.para = 0.999;

d126 1
a126 1
	nmg_gluefaces(outfaceuses, nfaces);
d197 6
@


1.5
log
@Solaris ANSI lint
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/off/RCS/off-g.c,v 1.4 94/11/22 15:33:32 jra Exp Locker: mike $ (BRL)";
@


1.4
log
@Replaced call to nmg_fu_planeeqn with nmg_loop_plane_area.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/off/RCS/off-g.c,v 1.3 94/11/07 10:53:49 jra Exp Locker: jra $ (BRL)";
d169 1
a169 1
	if (strlen(title) < 1) 
d172 1
a172 1
	if (strlen(geom_fname) < 1)
@


1.3
log
@Added tolerance arg to nmg_region_a call.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/off/RCS/off-g.c,v 1.2 93/07/23 18:08:50 gdurf Exp Locker: jra $ (BRL)";
d119 2
d122 1
a122 1
		if (nmg_fu_planeeqn(outfaceuses[i], &tol) < 0)
d124 3
@


1.2
log
@Works
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/off/RCS/off-g.c,v 1.1 1993/05/21 01:02:45 gdurf Exp gdurf $ (BRL)";
d127 1
a127 1
	nmg_region_a(r);
@


1.1
log
@Initial revision
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/off/RCS/off.c,v 1.1 1993/04/13 21:34:13 gdurf Exp gdurf $ (BRL)";
d54 3
a56 1
	fscanf(fgeom, "%d %d %d", &nverts, &nfaces, &nedges);
d63 3
a65 4
		if (fscanf(fgeom, "%lf %lf %lf", &pts[3*i], &pts[3*i+1], &pts[3*i+2]) != 3) {
			fprintf(stderr, "Not enough data points in geometry file.\n");
			exit(1);
		}
d95 1
d114 1
a114 1
	tol.dist_sq = 0.0001;
d118 2
a119 1
	for (i = 0; i < nfaces; i++)
d122 1
d215 1
a215 1
		if ((fpout == fopen(argv[2], "a")) == NULL) {
@
