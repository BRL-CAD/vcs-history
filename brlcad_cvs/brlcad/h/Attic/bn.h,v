head	1.74;
access;
symbols
	ansi-20040405-merged:1.69.2.2
	postmerge-20040405-ansi:1.73
	premerge-20040404-ansi:1.72
	postmerge-autoconf:1.72
	autoconf-freeze:1.72
	premerge-autoconf:1.72
	ansi-20040316-freeze:1.69.2.1
	postmerge-20040315-windows:1.72
	premerge-20040315-windows:1.72
	windows-20040315-freeze:1.69.4.1
	autoconf-20031203:1.72
	autoconf-20031202:1.72
	autoconf-branch:1.72.0.6
	phong-branch:1.72.0.4
	photonmap-branch:1.72.0.2
	rel-6-1-DP:1.69
	windows-branch:1.69.0.4
	rel-6-0-2:1.67
	ansi-branch:1.69.0.2
	rel-6-0-1-branch:1.67.0.2
	hartley-6-0-post:1.68
	hartley-6-0-pre:1.67
	rel-6-0-1:1.67
	rel-6-0:1.67
	rel-5-4:1.43
	offsite-5-3-pre:1.57
	rel-5-3:1.43
	rel-5-2:1.43
	rel-5-1-branch:1.43.0.2
	rel-5-1:1.43
	rel-5-0:1.32
	rel-5-0-beta:1.29
	rel-4-5:1.21
	ctj-4-5-post:1.19
	ctj-4-5-pre:1.19;
locks; strict;
comment	@ * @;


1.74
date	2004.05.24.04.11.51;	author morrison;	state dead;
branches;
next	1.73;

1.73
date	2004.04.05.09.31.16;	author morrison;	state Exp;
branches;
next	1.72;

1.72
date	2003.03.26.20.18.41;	author jra;	state Exp;
branches;
next	1.71;

1.71
date	2002.11.01.18.01.44;	author jra;	state Exp;
branches;
next	1.70;

1.70
date	2002.11.01.16.20.35;	author jra;	state Exp;
branches;
next	1.69;

1.69
date	2002.08.20.17.07.29;	author jra;	state Exp;
branches
	1.69.2.1
	1.69.4.1;
next	1.68;

1.68
date	2002.08.15.20.54.42;	author hartley;	state Exp;
branches;
next	1.67;

1.67
date	2002.02.28.01.02.31;	author butler;	state Exp;
branches;
next	1.66;

1.66
date	2001.08.11.13.11.40;	author butler;	state Exp;
branches;
next	1.65;

1.65
date	2001.06.01.16.45.54;	author bparker;	state Exp;
branches;
next	1.64;

1.64
date	2001.05.16.21.37.43;	author morrison;	state Exp;
branches;
next	1.63;

1.63
date	2001.04.05.19.35.06;	author morrison;	state Exp;
branches;
next	1.62;

1.62
date	2001.04.02.21.37.52;	author morrison;	state Exp;
branches;
next	1.61;

1.61
date	2001.03.31.01.56.33;	author morrison;	state Exp;
branches;
next	1.60;

1.60
date	2001.03.29.21.49.58;	author morrison;	state Exp;
branches;
next	1.59;

1.59
date	2001.03.29.21.47.33;	author morrison;	state Exp;
branches;
next	1.58;

1.58
date	2001.03.29.13.26.32;	author morrison;	state Exp;
branches;
next	1.57;

1.57
date	2001.01.16.21.11.22;	author cjohnson;	state Exp;
branches;
next	1.56;

1.56
date	2000.10.24.18.25.29;	author mike;	state Exp;
branches;
next	1.55;

1.55
date	2000.10.24.18.02.29;	author mike;	state Exp;
branches;
next	1.54;

1.54
date	2000.10.24.14.45.50;	author mike;	state Exp;
branches;
next	1.53;

1.53
date	2000.09.26.13.45.36;	author jra;	state Exp;
branches;
next	1.52;

1.52
date	2000.09.07.03.01.05;	author mike;	state Exp;
branches;
next	1.51;

1.51
date	2000.08.24.03.58.01;	author mike;	state Exp;
branches;
next	1.50;

1.50
date	2000.08.21.02.06.59;	author butler;	state Exp;
branches;
next	1.49;

1.49
date	2000.08.17.02.32.43;	author mike;	state Exp;
branches;
next	1.48;

1.48
date	2000.08.10.13.06.47;	author jra;	state Exp;
branches;
next	1.47;

1.47
date	2000.07.25.16.38.31;	author butler;	state Exp;
branches;
next	1.46;

1.46
date	2000.07.11.23.53.49;	author mike;	state Exp;
branches;
next	1.45;

1.45
date	2000.07.07.05.50.44;	author cjohnson;	state Exp;
branches;
next	1.44;

1.44
date	2000.06.28.20.33.44;	author mike;	state Exp;
branches;
next	1.43;

1.43
date	2000.04.12.02.10.32;	author mike;	state Exp;
branches;
next	1.42;

1.42
date	2000.03.29.02.06.59;	author mike;	state Exp;
branches;
next	1.41;

1.41
date	2000.03.15.22.50.53;	author butler;	state Exp;
branches;
next	1.40;

1.40
date	2000.03.13.03.29.43;	author butler;	state Exp;
branches;
next	1.39;

1.39
date	2000.02.14.18.51.56;	author mike;	state Exp;
branches;
next	1.38;

1.38
date	2000.02.03.06.32.12;	author butler;	state Exp;
branches;
next	1.37;

1.37
date	2000.01.20.22.04.07;	author mike;	state Exp;
branches;
next	1.36;

1.36
date	2000.01.07.20.36.54;	author mike;	state Exp;
branches;
next	1.35;

1.35
date	99.12.01.13.28.25;	author bparker;	state Exp;
branches;
next	1.34;

1.34
date	99.10.30.03.06.23;	author butler;	state Exp;
branches;
next	1.33;

1.33
date	99.10.04.17.57.07;	author butler;	state Exp;
branches;
next	1.32;

1.32
date	99.07.02.21.24.43;	author mike;	state Exp;
branches;
next	1.31;

1.31
date	99.07.02.19.12.08;	author mike;	state Exp;
branches;
next	1.30;

1.30
date	99.07.02.19.04.07;	author mike;	state Exp;
branches;
next	1.29;

1.29
date	99.05.27.21.51.34;	author mike;	state Exp;
branches;
next	1.28;

1.28
date	99.05.27.20.10.32;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	99.01.13.08.00.30;	author butler;	state Exp;
branches;
next	1.26;

1.26
date	99.01.12.07.14.42;	author morrison;	state Exp;
branches;
next	1.25;

1.25
date	99.01.12.05.51.17;	author morrison;	state Exp;
branches;
next	1.24;

1.24
date	98.12.11.20.49.25;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	98.12.11.20.40.07;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	98.07.09.05.25.16;	author butler;	state Exp;
branches;
next	1.21;

1.21
date	98.02.12.15.43.20;	author jra;	state Exp;
branches;
next	1.20;

1.20
date	97.11.10.17.32.18;	author butler;	state Exp;
branches;
next	1.19;

1.19
date	97.07.23.07.02.56;	author gdurf;	state Exp;
branches;
next	1.18;

1.18
date	97.02.10.20.59.24;	author butler;	state Exp;
branches;
next	1.17;

1.17
date	97.02.10.20.58.43;	author butler;	state Exp;
branches;
next	1.16;

1.16
date	97.01.08.03.41.23;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	97.01.02.13.24.43;	author jra;	state Exp;
branches;
next	1.14;

1.14
date	96.12.31.00.20.31;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	96.10.02.23.46.23;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	96.10.02.23.43.27;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	96.10.02.23.20.24;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	96.09.27.08.17.04;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	96.09.20.00.21.46;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	96.09.20.00.19.32;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	96.09.14.03.40.53;	author butler;	state Exp;
branches;
next	1.6;

1.6
date	96.09.11.08.43.03;	author butler;	state Exp;
branches;
next	1.5;

1.5
date	96.08.31.11.03.07;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	96.08.31.08.59.58;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	96.08.31.08.58.45;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	96.08.30.22.47.23;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	96.08.30.22.45.27;	author mike;	state Exp;
branches;
next	;

1.69.2.1
date	2002.09.19.18.00.56;	author morrison;	state Exp;
branches;
next	1.69.2.2;

1.69.2.2
date	2004.03.17.21.16.10;	author morrison;	state Exp;
branches;
next	;

1.69.4.1
date	2004.03.11.23.40.46;	author morrison;	state Exp;
branches;
next	;


desc
@BRL-CAD Numerical Libary, Header file
@


1.74
log
@moved/renamed from top-level h/ to top-level include/
@
text
@/*
 *			B N . H
 *
 *  Header file for the BRL-CAD Numerical Computation Library, LIBBN.
 *
 *  The library provides a broad assortment of numerical algorithms
 *  and computational routines, including random number generation,
 *  vector math, matrix math, quaternion math, complex math,
 *  synthetic division, root finding, etc.
 *
 *  This header file depends on vmath.h
 *  This header file depends on bu.h and LIBBU;  it is safe to use
 *  bu.h macros (e.g. BU_EXTERN) here.
 *
 *  ??Should complex.h and plane.h and polyno.h get absorbed in here??
 *	??absorbed/included??
 *
 *
 *  Authors -
 *	Michael John Muuss
 *	Lee A Butler
 *	Douglas A Gwyn
 *	Jeff Hanes
 *
 *  Modifications & Additions -
 *      Christopher Sean Morrison
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
 *
 *  Include Sequencing -
 *	#include "conf.h"
 *	#include <stdio.h>
 *	#include <math.h>
 *	#include "machine.h"	/_* For fastf_t definition on this machine *_/
 *	#include "bu.h"
 *	#include "vmath.h"
 *	#include "bn.h"
 *
 *  Libraries Used -
 *	-lm -lc
 *
 *  $Header: /n/xoff/cvs/brlcad/h/bn.h,v 1.73 2004/04/05 09:31:16 morrison Exp $
 */

#ifndef SEEN_BN_H
#define SEEN_BN_H seen
#ifdef __cplusplus
extern "C" {
#endif

#define BN_H_VERSION	"@@(#)$Header: /n/xoff/cvs/brlcad/h/bn.h,v 1.73 2004/04/05 09:31:16 morrison Exp $ (BRL)"

#define BN_AZIMUTH 0
#define BN_ELEVATION 1
#define BN_TWIST 2

/*			B N _ T O L
 *
 *  A handy way of passing around the tolerance information needed to
 *  perform approximate floating-point calculations on geometry.
 *
 *  dist & dist_sq establish the distance tolerance.
 *
 *	If two points are closer together than dist, then they are to
 *	be considered the same point.
 *	For example:
 *		point_t	a,b;
 *		vect_t	diff;
 *		VSUB2( diff, a, b );
 *		if( MAGNITUDE(diff) < tol->dist )	a & b are the same.
 *	or, more efficiently:
 *		if( MAQSQ(diff) < tol->dist_sq )
 *
 *  perp & para establish the angular tolerance.
 *
 *	If two rays emanate from the same point, and their dot product
 *	is nearly one, then the two rays are the same, while if their
 *	dot product is nearly zero, then they are perpendicular.
 *	For example:
 *		vect_t	a,b;
 *		if( fabs(VDOT(a,b)) >= tol->para )	a & b are parallel
 *		if( fabs(VDOT(a,b)) <= tol->perp )	a & b are perpendicular
 *
 *  Note:
 *	tol->dist_sq = tol->dist * tol->dist;
 *	tol->para = 1 - tol->perp;
 */
struct bn_tol {
	unsigned long	magic;
	double		dist;			/* >= 0 */
	double		dist_sq;		/* dist * dist */
	double		perp;			/* nearly 0 */
	double		para;			/* nearly 1 */
};
#define BN_TOL_MAGIC	0x98c734bb
#define BN_CK_TOL(_p)	BU_CKMAG(_p, BN_TOL_MAGIC, "bn_tol")

#define	BN_VECT_ARE_PARALLEL(_dot,_tol)		\
	(((_dot) < 0) ? ((-(_dot))>=(_tol)->para) : ((_dot) >= (_tol)->para))
#define BN_VECT_ARE_PERP(_dot,_tol)		\
	(((_dot) < 0) ? ((-(_dot))<=(_tol)->perp) : ((_dot) <= (_tol)->perp))

#define BN_APPROXEQUAL(_a, _b, _tol) (fabs( (_a) - (_b) ) <= _tol->dist)

/* asize.c */
BU_EXTERN(int			bn_common_file_size, (int *width,
						      int *height,
						      const char *filename,
						      int pixel_size));
BU_EXTERN(int			bn_common_name_size, (int *width,
						      int *height,
						      char *name));
BU_EXTERN(int			bn_common_image_size, (int *width,
						      int *height,
						      int num_pixels));

/*----------------------------------------------------------------------*/
/* anim.c */
/* XXX These should all have bn_ prefixes */
void anim_v_permute(mat_t m);
void anim_v_unpermute(mat_t m);
void anim_tran(mat_t m);
int anim_mat2zyx(const mat_t viewrot, vect_t angle);
int anim_mat2ypr(mat_t viewrot, vect_t angle);
int anim_mat2quat(quat_t quat, const mat_t viewrot);
void anim_ypr2mat(mat_t m, const vect_t a);
void anim_ypr2vmat(mat_t m, const vect_t a);
void anim_y_p_r2mat(mat_t m, double y, double p, double r);
void anim_dy_p_r2mat(mat_t m, double y, double p, double r);
void anim_dy_p_r2vmat(mat_t m, double yaw, double pch, double rll);
void anim_x_y_z2mat(mat_t m, double x, double y, double z);
void anim_dx_y_z2mat(mat_t m, double x, double y, double z);
void anim_zyx2mat(mat_t m, const vect_t a);
void anim_z_y_x2mat(mat_t m, double x, double y, double z);
void anim_dz_y_x2mat(mat_t m, double x, double y, double z);
void anim_quat2mat(mat_t m, const quat_t qq);
void anim_dir2mat(mat_t m, const vect_t d, const vect_t d2);
void anim_dirn2mat(mat_t m, const vect_t dx, const vect_t dn);
int anim_steer_mat(mat_t  mat, vect_t point, int end);
void anim_add_trans(mat_t m, const vect_t post, const vect_t pre);
void anim_rotatez(fastf_t a, vect_t d);
void anim_mat_print(FILE *fp, const mat_t m, int s_colon);
void anim_mat_printf(
	FILE *fp,
	const mat_t m,
	const char *formstr,
	const char *linestr,
	const char *endstr);
void anim_view_rev(mat_t m);


/*----------------------------------------------------------------------*/
/* bn_tcl.c */
int bn_decode_mat(mat_t m, const char *str);
int bn_decode_quat(quat_t q, const char *str);
int bn_decode_vect( vect_t v, const char *str );
int bn_decode_hvect(hvect_t v, const char *str);
void bn_encode_mat(struct bu_vls *vp, const mat_t m);
void bn_encode_quat(struct bu_vls *vp, const quat_t q);
void bn_encode_vect(struct bu_vls *vp, const vect_t v);
void bn_encode_hvect(struct bu_vls *vp, const hvect_t v);

/* The presence of Tcl_Interp as an arg prevents giving arg list */
extern void bn_tcl_setup();
extern int Bn_Init();
extern void bn_tcl_mat_print();


/*----------------------------------------------------------------------*/
/* complex.c */
/*
 *  Complex numbers
 */

/* "complex number" data type: */
typedef struct bn_complex {
	double		re;		/* real part */
	double		im;		/* imaginary part */
}  bn_complex_t;

/* functions that are efficiently done as macros: */

#define	bn_cx_copy( ap, bp )		{*(ap) = *(bp);}
#define	bn_cx_neg( cp )			{ (cp)->re = -((cp)->re);(cp)->im = -((cp)->im);}
#define	bn_cx_real( cp )		(cp)->re
#define	bn_cx_imag( cp )		(cp)->im

#define bn_cx_add( ap, bp )		{ (ap)->re += (bp)->re; (ap)->im += (bp)->im;}
#define bn_cx_ampl( cp )		hypot( (cp)->re, (cp)->im )
#define bn_cx_amplsq( cp )		( (cp)->re * (cp)->re + (cp)->im * (cp)->im )
#define bn_cx_conj( cp )		{ (cp)->im = -(cp)->im; }
#define bn_cx_cons( cp, r, i )		{ (cp)->re = r; (cp)->im = i; }
#define bn_cx_phas( cp )		atan2( (cp)->im, (cp)->re )
#define bn_cx_scal( cp, s )		{ (cp)->re *= (s); (cp)->im *= (s); }
#define bn_cx_sub( ap, bp )		{ (ap)->re -= (bp)->re; (ap)->im -= (bp)->im;}

#define bn_cx_mul( ap, bp )	 	\
	{ FAST fastf_t a__re, b__re; \
	(ap)->re = ((a__re=(ap)->re)*(b__re=(bp)->re)) - (ap)->im*(bp)->im; \
	(ap)->im = a__re*(bp)->im + (ap)->im*b__re; }

/* Output variable "ap" is different from input variables "bp" or "cp" */
#define bn_cx_mul2( ap, bp, cp )	{ \
	(ap)->re = (cp)->re * (bp)->re - (cp)->im * (bp)->im; \
	(ap)->im = (cp)->re * (bp)->im + (cp)->im * (bp)->re; }

BU_EXTERN(void			bn_cx_div, (bn_complex_t *ap, const bn_complex_t *bp) );
BU_EXTERN(void			bn_cx_sqrt, (bn_complex_t *op, const bn_complex_t *ip) );

/*----------------------------------------------------------------------*/
/* mat.c */
/*
 * 4x4 Matrix math
 */
extern const mat_t 	bn_mat_identity;

BU_EXTERN(void		bn_mat_print, (const char *title, const mat_t m));
BU_EXTERN(void		bn_mat_print_guts, (const char *title, const mat_t m, char *buf));
BU_EXTERN(double	bn_atan2, (double x, double y));

#if 0 /* deprecated for macros below (which were deprecated for vmath.h) */
BU_EXTERN(void		bn_mat_zero, (mat_t m));
BU_EXTERN(void		bn_mat_idn, (mat_t m));
BU_EXTERN(void		bn_mat_copy, (register mat_t dest,register const mat_t src));
#else
#define bn_mat_zero( _m )	{ \
	bu_log("%s:%d bn_mat_zero() is deprecated, use MAT_ZERO()\n", \
			__FILE__, __LINE__); \
	(_m)[0] = (_m)[1] = (_m)[2] = (_m)[3] = \
	(_m)[4] = (_m)[5] = (_m)[6] = (_m)[7] = \
	(_m)[8] = (_m)[9] = (_m)[10] = (_m)[11] = \
	(_m)[12] = (_m)[13] = (_m)[14] = (_m)[15] = 0.0; }
  /*
#define	bn_mat_zero( _m )	(void)memset( (void *)_m, 0, sizeof(mat_t))
  */
#define bn_mat_idn( _m )	{ \
	bu_log("%s:%d bn_mat_idn() is deprecated, use MAT_IDN()\n", \
			__FILE__, __LINE__); \
	(_m)[1] = (_m)[2] = (_m)[3] = (_m)[4] = \
	(_m)[6] = (_m)[7] = (_m)[8] = (_m)[9] = \
	(_m)[11] = (_m)[12] = (_m)[13] = (_m)[14] = 0.0; \
	(_m)[0] = (_m)[5] = (_m)[10] = (_m)[15] = 1.0; }
  /*
#define bn_mat_idn( _m )	(void)memcpy( (void *)_m, (const void *)bn_mat_identity, sizeof(mat_t))
  */

#define bn_mat_copy( _d, _s )	{ \
	bu_log("%s:%d bn_mat_copy() is deprecated, use MAT_COPY()\n", \
			__FILE__, __LINE__); \
	(_d)[0] = (_s)[0];\
	(_d)[1] = (_s)[1];\
	(_d)[2] = (_s)[2];\
	(_d)[3] = (_s)[3];\
	(_d)[4] = (_s)[4];\
	(_d)[5] = (_s)[5];\
	(_d)[6] = (_s)[6];\
	(_d)[7] = (_s)[7];\
	(_d)[8] = (_s)[8];\
	(_d)[9] = (_s)[9];\
	(_d)[10] = (_s)[10];\
	(_d)[11] = (_s)[11];\
	(_d)[12] = (_s)[12];\
	(_d)[13] = (_s)[13];\
	(_d)[14] = (_s)[14];\
	(_d)[15] = (_s)[15]; }
  /*
#define bn_mat_copy(_d,_s)	(void)memcpy( (void *)_d, (const void *)(_s), sizeof(mat_t))
  */
#endif /* deprecated */

BU_EXTERN(void		bn_mat_mul, (register mat_t o, register const mat_t a,
					register const mat_t b));
BU_EXTERN(void		bn_mat_mul2, (register const mat_t i, register mat_t o));
BU_EXTERN(void		bn_mat_mul3, (mat_t o, const mat_t a, const mat_t b,
					const mat_t c));
void			bn_mat_mul4(
				mat_t		o,
				const mat_t	a,
				const mat_t	b,
				const mat_t	c,
				const mat_t	d);
BU_EXTERN(void		bn_matXvec, (register hvect_t ov,
					register const mat_t im,
					register const hvect_t iv));
BU_EXTERN(void		bn_mat_inv, (register mat_t output, const mat_t input));
BU_EXTERN(void		bn_vtoh_move, (register vect_t h, 
					register const vect_t v));
BU_EXTERN(void		bn_htov_move, (register vect_t v, 
					register const vect_t h));
BU_EXTERN(void		bn_mat_trn, (mat_t om, register const mat_t im));
BU_EXTERN(void		bn_mat_ae, (register mat_t m, double azimuth,
					double elev));
BU_EXTERN(void		bn_ae_vec, (fastf_t *azp, fastf_t *elp, 
					const vect_t v));
BU_EXTERN(void 		bn_aet_vec, ( fastf_t *az, fastf_t *el, 
					fastf_t *twist, vect_t vec_ae,
					vect_t vec_twist, fastf_t accuracy));

BU_EXTERN(void		bn_mat_angles, (register mat_t mat, double alpha,
					double beta, double ggamma ));
BU_EXTERN(void		bn_mat_angles_rad, (register mat_t mat, double alpha,
					    double beta, double ggamma ));

BU_EXTERN(void		bn_eigen2x2, ( fastf_t	*val1, fastf_t *val2,
					vect_t	vec1, vect_t vec2, fastf_t a,
					fastf_t b, fastf_t c) );

BU_EXTERN(void		bn_vec_perp, (vect_t new_vec, const vect_t old_vec));
BU_EXTERN(void		bn_mat_fromto, ( mat_t m, const vect_t from,
					const vect_t to));
BU_EXTERN(void		bn_mat_xrot, (mat_t m, double sinx, double cosx));
BU_EXTERN(void		bn_mat_yrot, (mat_t m, double siny, double cosy));
BU_EXTERN(void		bn_mat_zrot, (mat_t m, double sinz, double cosz));
BU_EXTERN(void		bn_mat_lookat, (mat_t rot, const vect_t dir, int yflip));
BU_EXTERN(void		bn_vec_ortho, (register vect_t out, 
					register const vect_t in));
BU_EXTERN(int		bn_mat_scale_about_pt, (mat_t mat, const point_t pt,
					const double scale));
BU_EXTERN(void		bn_mat_xform_about_pt, (mat_t mat, 
					const mat_t xform,
					const point_t pt));
BU_EXTERN(int		bn_mat_is_equal, (const mat_t a, const mat_t b, 
					const struct bn_tol *tol));
BU_EXTERN(int		bn_mat_is_identity, (const mat_t m));
BU_EXTERN(void		bn_mat_arb_rot, ( mat_t m, const point_t pt,
					const vect_t dir, const fastf_t ang));
BU_EXTERN(matp_t	bn_mat_dup, (const mat_t in));
BU_EXTERN(int		bn_mat_ck, (const char *title, const mat_t m));
BU_EXTERN(fastf_t	bn_mat_det3, (const mat_t m));
BU_EXTERN(fastf_t	bn_mat_determinant, (const mat_t m));

BU_EXTERN(int		bn_mat_is_non_unif, (const mat_t m));
/*----------------------------------------------------------------------*/
/* msr.c */
/*
 * Define data structures and constants for the "MSR" random number package.
 *
 * Also define a set of macros to access the random number tables
 * and to limit the area/volume that a set of random numbers inhabit.
 */

#define BN_UNIF_MAGIC	12481632
#define BN_GAUSS_MAGIC 512256128

#define BN_CK_UNIF(_p) BU_CKMAG(_p, BN_UNIF_MAGIC, "bn_unif")
#define BN_CK_GAUSS(_p) BU_CKMAG(_p, BN_GAUSS_MAGIC, "bn_gauss")

struct bn_unif {
	long	magic;
	long	msr_seed;
	int	msr_double_ptr;
	double	*msr_doubles;
	int	msr_long_ptr;
	long	*msr_longs;
};
/*
 * NOTE!!! The order of msr_gauss and msr_unif MUST match in the
 * first three entries as msr_gauss is passed as a msr_unif in
 * msr_gauss_fill.
 */
struct bn_gauss {
	long	magic;
	long	msr_gauss_seed;
	int	msr_gauss_dbl_ptr;
	double	*msr_gauss_doubles;
	int	msr_gauss_ptr;
	double	*msr_gausses;
};

BU_EXTERN(struct bn_unif *	bn_unif_init, (long setseed, int method));
BU_EXTERN(void			bn_unif_free, (struct bn_unif *p));
BU_EXTERN(long			bn_unif_long_fill, (struct bn_unif *p));
BU_EXTERN(double		bn_unif_double_fill, (struct bn_unif *p));
BU_EXTERN(struct bn_gauss *	bn_gauss_init, (long setseed, int method));
BU_EXTERN(void			bn_gauss_free, (struct bn_gauss *p));
BU_EXTERN(double		bn_gauss_fill, (struct bn_gauss *p));

#define	BN_UNIF_LONG(_p)	\
	 (((_p)->msr_long_ptr ) ? \
		(_p)->msr_longs[--(_p)->msr_long_ptr] : \
		bn_unif_long_fill(_p))
#define BN_UNIF_DOUBLE(_p)	\
	(((_p)->msr_double_ptr) ? \
		(_p)->msr_doubles[--(_p)->msr_double_ptr] : \
		bn_unif_double_fill(_p))

#define BN_UNIF_CIRCLE(_p,_x,_y,_r) { \
	do { \
		(_x) = 2.0*BN_UNIF_DOUBLE((_p)); \
		(_y) = 2.0*BN_UNIF_DOUBLE((_p)); \
		(_r) = (_x)*(_x)+(_y)*(_y); \
	} while ((_r) >= 1.0);  }

#define	BN_UNIF_SPHERE(_p,_x,_y,_z,_r) { \
	do { \
		(_x) = 2.0*BN_UNIF_DOUBLE(_p); \
		(_y) = 2.0*BN_UNIF_DOUBLE(_p); \
		(_z) = 2.0*BN_UNIF_DOUBLE(_p); \
		(_r) = (_x)*(_x)+(_y)*(_y)+(_z)*(_z);\
	} while ((_r) >= 1.0) }

#define	BN_GAUSS_DOUBLE(_p)	\
	(((_p)->msr_gauss_ptr) ? \
		(_p)->msr_gausses[--(_p)->msr_gauss_ptr] : \
		bn_gauss_fill(_p))


/*----------------------------------------------------------------------*/
/* noise.c */
/*
 * fractal noise support
 */

BU_EXTERN(void		bn_noise_init, () );
BU_EXTERN(double	bn_noise_perlin, (point_t pt) );
/* XXX Why isn't the result listed first? */
BU_EXTERN(void		bn_noise_vec, (point_t point, point_t result) );
BU_EXTERN(double	bn_noise_fbm, (point_t point, double h_val,
				double lacunarity, double octaves) );
BU_EXTERN(double	bn_noise_turb, (point_t point, double h_val,
				double lacunarity, double octaves ) );
BU_EXTERN(double	bn_noise_mf, (point_t point, double h_val,
				double lacunarity, double octaves,
				double offset) );
BU_EXTERN(double	bn_noise_ridged, (point_t point, double h_val,
				double lacunarity, double octaves,
				double offset) );

/*----------------------------------------------------------------------*/
/* plane.c */
/*
 * Plane/line/point calculations
 */


extern int bn_distsq_line3_line3(fastf_t dist[3],
				 point_t P,
				 vect_t d,
				 point_t Q,
				 vect_t e,
				 point_t pt1,
				 point_t pt2);

BU_EXTERN(int		bn_dist_pt3_lseg3, (fastf_t *dist, point_t pca,
				const point_t a, const point_t b,
				const point_t p, const struct bn_tol *tol));
BU_EXTERN(int		bn_3pts_collinear, ( point_t a, point_t b, point_t c,
				const struct bn_tol *tol));
BU_EXTERN(int		bn_pt3_pt3_equal, ( const point_t a, const point_t b,
				const struct bn_tol *tol));
BU_EXTERN(int		bn_dist_pt2_lseg2, ( fastf_t *dist_sq, 
				fastf_t pca[2], const point_t a,
				const point_t b, const point_t p,
				const struct bn_tol *tol));
BU_EXTERN(int		bn_isect_lseg3_lseg3, ( fastf_t *dist,
				const point_t p, const vect_t pdir,
				const point_t q, const vect_t qdir,
				const struct bn_tol *tol));
BU_EXTERN(int		bn_isect_line3_line3, (fastf_t *t, fastf_t *u, 	
				const point_t p, const vect_t d,
				const point_t a, const vect_t c,
				const struct bn_tol *tol));
BU_EXTERN(int		bn_2line3_colinear, ( const point_t p1,
				const vect_t d1, const point_t p2,
				const vect_t d2, double range,
				const struct bn_tol *tol));
BU_EXTERN(int		bn_isect_pt2_lseg2, ( fastf_t *dist, const point_t a,
				const point_t b, const point_t p,
				const struct bn_tol *tol));
BU_EXTERN(int		bn_isect_line2_lseg2, (fastf_t *dist, const point_t p,
				const vect_t d, const point_t a,
				const vect_t c, const struct bn_tol *tol));
BU_EXTERN(int		bn_isect_lseg2_lseg2, (fastf_t *dist, const point_t p,
				const vect_t pdir, const point_t q,
				const vect_t qdir, const struct bn_tol *tol));
BU_EXTERN(int		bn_isect_line2_line2, ( fastf_t *dist,
				const point_t p, const vect_t d,
				const point_t a, const vect_t c,
				const struct bn_tol *tol));
BU_EXTERN(double	bn_dist_pt3_pt3, (const point_t a, const point_t b));
BU_EXTERN(int		bn_3pts_distinct, (const point_t a, const point_t b,
				const point_t c, const struct bn_tol *tol) );
BU_EXTERN(int		bn_mk_plane_3pts, (plane_t plane, const point_t a,
				const point_t b, const point_t c,
				const struct bn_tol *tol) );
BU_EXTERN(int		bn_mkpoint_3planes, (point_t pt, const plane_t a,
				const plane_t b, const plane_t c) );
BU_EXTERN(int		bn_isect_line3_plane, (fastf_t *dist,
				const point_t pt,
				const vect_t dir,
				const plane_t plane,
				const struct bn_tol *tol) );
BU_EXTERN(int		bn_isect_2planes, (point_t pt, vect_t dir,
				const plane_t a, const plane_t b,
				const vect_t rpp_min,
				const struct bn_tol *tol) );
BU_EXTERN(int		bn_isect_2lines, (fastf_t *t, fastf_t *u,
				const point_t p, const vect_t d, 
				const point_t a, const vect_t c,
				const struct bn_tol *tol) );
BU_EXTERN(int		bn_isect_line_lseg, (fastf_t *t, const point_t p,
				const vect_t d, const point_t a,
				const point_t b, const struct bn_tol *tol) );
BU_EXTERN(double	bn_dist_line3_pt3, (const point_t pt,
				const vect_t dir, const point_t a) );
BU_EXTERN(double	bn_distsq_line3_pt3, (const point_t pt,
				const vect_t dir, const point_t a));
BU_EXTERN(double	bn_dist_line_origin, (const point_t pt,
				const vect_t dir) );
BU_EXTERN(double	bn_dist_line2_point2, (const point_t pt,
				const vect_t dir, const point_t a));
BU_EXTERN(double	bn_distsq_line2_point2, (const point_t pt,
				const vect_t dir, const point_t a));
BU_EXTERN(double	bn_area_of_triangle, (const point_t a,
				const point_t b, const point_t c) );
BU_EXTERN(int		bn_isect_pt_lseg, (fastf_t *dist, const point_t a,
				const point_t b, const point_t p,
				const struct bn_tol *tol) );
BU_EXTERN(double	bn_dist_pt_lseg, (point_t pca, const point_t a,
				const point_t b, const point_t p,
				const struct bn_tol *tol) );
BU_EXTERN(void		bn_rotate_bbox, (point_t omin, point_t omax,
				const mat_t mat, const point_t imin,
				const point_t imax));
BU_EXTERN(void		bn_rotate_plane, (plane_t oplane, const mat_t mat,
				const plane_t iplane));
BU_EXTERN(int		bn_coplanar, (const plane_t a, const plane_t b,
				const struct bn_tol *tol));
BU_EXTERN(double	bn_angle_measure, (vect_t vec, const vect_t x_dir,
				const vect_t y_dir));
BU_EXTERN(double	bn_dist_pt3_along_line3, (const point_t	p,
				const vect_t d, const point_t x));
BU_EXTERN(double	bn_dist_pt2_along_line2, (const point_t p,
				const vect_t d, const point_t x));
BU_EXTERN(int		bn_between, (double left, double mid,
				double right, const struct bn_tol *tol));
int bn_does_ray_isect_tri(
	const point_t pt,
	const vect_t dir,
	const point_t V,
	const point_t A,
	const point_t B,
	point_t	inter);
BU_EXTERN(int		bn_hlf_class, (const plane_t half_eqn,
				       const vect_t min, const vect_t max,
				       const struct bn_tol *tol));

#define BN_CLASSIFY_UNIMPLEMENTED	0x0000
#define BN_CLASSIFY_OVERLAPPING		0x0002
#define BN_CLASSIFY_INSIDE		0x0001
#define BN_CLASSIFY_OUTSIDE		0x0003

BU_EXTERN(int			bn_isect_planes, (point_t pt,
				const plane_t planes[], const int pl_count));

/*----------------------------------------------------------------------*/
/* poly.c */
/*
 *  Polynomial data type
 */

			/* This could be larger, or even dynamic... */
#define BN_MAX_POLY_DEGREE	4	/* Maximum Poly Order */
typedef  struct bn_poly {
	long		magic;
	int		dgr;
	double		cf[BN_MAX_POLY_DEGREE+1];
}  bn_poly_t;
#define BN_POLY_MAGIC	0x506f4c79	/* 'PoLy' */
#define BN_CK_POLY(_p)	BU_CKMAG(_p, BN_POLY_MAGIC, "struct bn_poly")
#define BN_POLY_NULL	((struct bn_poly *)NULL)

BU_EXTERN(struct bn_poly *	bn_poly_mul, (struct bn_poly *product,
				const struct bn_poly *m1, const struct bn_poly *m2));
BU_EXTERN(struct bn_poly *	bn_poly_scale, (struct bn_poly *eqn,
				double factor));
BU_EXTERN(struct bn_poly *	bn_poly_add, (struct bn_poly *sum,
				const struct bn_poly *poly1, const struct bn_poly *poly2));
BU_EXTERN(struct bn_poly *	bn_poly_sub, (struct bn_poly *diff,
				const struct bn_poly	*poly1,
				const struct bn_poly	*poly2));
BU_EXTERN(void			bn_poly_synthetic_division, (
				struct bn_poly *quo, struct bn_poly *rem,
				const struct bn_poly	*dvdend,
				const struct bn_poly	*dvsor));
BU_EXTERN(int			bn_poly_quadratic_roots, (
				struct bn_complex	roots[],
				const struct bn_poly	*quadrat));
BU_EXTERN(int			bn_poly_cubic_roots, (
				struct bn_complex	roots[],
				const struct bn_poly	*eqn));
BU_EXTERN(int			bn_poly_quartic_roots, (
				struct bn_complex	roots[],
				const struct bn_poly	*eqn));
BU_EXTERN(void			bn_pr_poly, (const char *title,
				const struct bn_poly	*eqn));
BU_EXTERN(void			bn_pr_roots, (const char *title,
				const struct bn_complex	roots[], int n));

/*----------------------------------------------------------------------*/
/* qmath.c */
/*
 * Quaternion support 
 */

BU_EXTERN(void quat_mat2quat, (quat_t quat, const mat_t mat));
BU_EXTERN(void quat_quat2mat, (mat_t mat, const quat_t quat));
BU_EXTERN(double quat_distance, (const quat_t q1, const quat_t q2));
BU_EXTERN(void quat_double, (quat_t qout, const quat_t q1, const quat_t q2));
BU_EXTERN(void quat_bisect, (quat_t qout, const quat_t q1, const quat_t q2));
BU_EXTERN(void quat_slerp, (quat_t qout, const quat_t q1, const quat_t q2, double f));
BU_EXTERN(void quat_sberp, (quat_t qout, const quat_t q1, const quat_t qa, const quat_t qb,
			    const quat_t q2, double f));
BU_EXTERN(void quat_make_nearest, (quat_t q1, const quat_t q2));
BU_EXTERN(void quat_print, (const char *title, const quat_t quat));
BU_EXTERN(void quat_exp, (quat_t out, const quat_t in));
BU_EXTERN(void quat_log, (quat_t out, const quat_t in));
/*----------------------------------------------------------------------*/
/* rand.c */

/*  A supply of fast pseudo-random numbers from table in bn/rand.c.
 *  The values are in the range 0..1
 *
 * Usage:
 *	unsigned idx;
 *	float f;
 *
 *	BN_RANDSEED( idx, integer_seed );
 *
 *	while (NEED_MORE_RAND_NUMBERS) {
 *		f = BN_RANDOM( idx );
 *	}
 *
 * Note that the values from bn_rand_half() become all 0.0 when the benchmark
 * flag is set (bn_rand_halftab is set to all 0's).  The numbers from 
 * bn_rand_table do not change, because the procedural noise would cease to
 * exist.
 */
#define BN_RAND_TABSIZE 4096
#define BN_RAND_TABMASK 0xfff
#define BN_RANDSEED( _i, _seed )  _i = ((unsigned)_seed) % BN_RAND_TABSIZE
extern const float bn_rand_table[BN_RAND_TABSIZE];

/* BN_RANDOM always gives numbers between 0.0 and 1.0 */
#define BN_RANDOM( _i )	bn_rand_table[ _i = (_i+1) % BN_RAND_TABSIZE ]

/* BN_RANDHALF always gives numbers between -0.5 and 0.5 */
#define BN_RANDHALF( _i ) (bn_rand_table[ _i = (_i+1) % BN_RAND_TABSIZE ]-0.5)
#define BN_RANDHALF_INIT(_p) _p = bn_rand_table

/* XXX This should move to compat4 */
/* #define rand_half bn_rand_half */
/* #define rand_init bn_rand_init */
/* #define rand0to1  bn_rand0to1 */

/* random numbers between -0.5 and 0.5, except when benchmark flag is set, 
 * when this becomes a constant 0.0
 */
#define BN_RANDHALFTABSIZE	16535	/* Powers of two give streaking */
extern int bn_randhalftabsize;
extern float bn_rand_halftab[BN_RANDHALFTABSIZE];

#define bn_rand_half(_p)	\
	( (++(_p) >= &bn_rand_halftab[bn_randhalftabsize] || \
	     (_p) < bn_rand_halftab) ? \
		*((_p) = bn_rand_halftab) : *(_p))

#define bn_rand_init(_p, _seed)	\
	(_p) = &bn_rand_halftab[ \
		(int)( \
		      (bn_rand_halftab[(_seed)%bn_randhalftabsize] + 0.5) * \
		      (bn_randhalftabsize-1) ) ]

/* random numbers 0..1 except when benchmarking, when this is always 0.5 */
#define bn_rand0to1(_q)	(bn_rand_half(_q)+0.5)

#define	BN_SINTABSIZE		2048
extern double bn_sin_scale;
#define bn_tab_sin(_a)	(((_a) > 0) ? \
	( bn_sin_table[(int)((0.5+ (_a)*bn_sin_scale))&(BN_SINTABSIZE-1)] ) :\
	(-bn_sin_table[(int)((0.5- (_a)*bn_sin_scale))&(BN_SINTABSIZE-1)] ) )
extern const float bn_sin_table[BN_SINTABSIZE];

extern void bn_mathtab_constant();



/*----------------------------------------------------------------------*/
/* wavelet.c */

#define CK_POW_2(dimen) { register unsigned long j; register int ok;\
	for (ok=0, j=0 ; j < sizeof(unsigned long) * 8 ; j++) { \
		if ( (1<<j) == dimen) { ok = 1;  break; } \
	} \
	if ( ! ok ) { \
		bu_log("%s:%d value %d should be power of 2 (2^%d)\n", \
			__FILE__, __LINE__, dimen, j); \
		bu_bomb("CK_POW_2"); \
		}\
}

BU_EXTERN(void	bn_wlt_haar_1d_double_decompose, (double *tbuf, double *buf, \
			unsigned long dimen, unsigned long depth, \
			unsigned long limit ));
BU_EXTERN(void	bn_wlt_haar_1d_double_reconstruct, (double *tbuf, double *buf, \
			unsigned long dimen, unsigned long depth, \
			unsigned long subimage_size, unsigned long limit ));

BU_EXTERN(void	bn_wlt_haar_1d_float_decompose, (float *tbuf, float *buf, \
			unsigned long dimen, unsigned long depth, \
			unsigned long limit ));
BU_EXTERN(void	bn_wlt_haar_1d_float_reconstruct, (float *tbuf, float *buf, \
			unsigned long dimen, unsigned long depth, \
			unsigned long subimage_size, unsigned long limit ));

BU_EXTERN(void	bn_wlt_haar_1d_char_decompose, (char *tbuf, char *buf, \
			unsigned long dimen, unsigned long depth, \
			unsigned long limit ));
BU_EXTERN(void	bn_wlt_haar_1d_char_reconstruct, (char *tbuf, char *buf, \
			unsigned long dimen, unsigned long depth, \
			unsigned long subimage_size, unsigned long limit ));

BU_EXTERN(void	bn_wlt_haar_1d_short_decompose, (short *tbuf, short *buf, \
			unsigned long dimen, unsigned long depth, \
			unsigned long limit ));
BU_EXTERN(void	bn_wlt_haar_1d_short_reconstruct, (short *tbuf, short *buf, \
			unsigned long dimen, unsigned long depth, \
			unsigned long subimage_size, unsigned long limit ));

BU_EXTERN(void	bn_wlt_haar_1d_int_decompose, (int *tbuf, int *buf, \
			unsigned long dimen, unsigned long depth, \
			unsigned long limit ));
BU_EXTERN(void	bn_wlt_haar_1d_int_reconstruct, (int *tbuf, int *buf, \
			unsigned long dimen, unsigned long depth, \
			unsigned long subimage_size, unsigned long limit ));

BU_EXTERN(void	bn_wlt_haar_1d_long_decompose, (long *tbuf, long *buf, \
			unsigned long dimen, unsigned long depth, \
			unsigned long limit ));
BU_EXTERN(void	bn_wlt_haar_1d_long_reconstruct, (long *tbuf, long *buf, \
			unsigned long dimen, unsigned long depth, \
			unsigned long subimage_size, unsigned long limit ));



BU_EXTERN(void	bn_wlt_haar_2d_double_decompose, (double *tbuf, double *buf, \
			unsigned long dimen, unsigned long depth, \
			unsigned long limit ));
BU_EXTERN(void	bn_wlt_haar_2d_double_reconstruct, (double *tbuf, double *buf, \
			unsigned long dimen, unsigned long depth, \
			unsigned long subimage_size, unsigned long limit ));

BU_EXTERN(void	bn_wlt_haar_2d_float_decompose, (float *tbuf, float *buf, \
			unsigned long dimen, unsigned long depth, \
			unsigned long limit ));
BU_EXTERN(void	bn_wlt_haar_2d_float_reconstruct, (float *tbuf, float *buf, \
			unsigned long dimen, unsigned long depth, \
			unsigned long subimage_size, unsigned long limit ));

BU_EXTERN(void	bn_wlt_haar_2d_char_decompose, (char *tbuf, char *buf, \
			unsigned long dimen, unsigned long depth, \
			unsigned long limit ));
BU_EXTERN(void	bn_wlt_haar_2d_char_reconstruct, (char *tbuf, char *buf, \
			unsigned long dimen, unsigned long depth, \
			unsigned long subimage_size, unsigned long limit ));

BU_EXTERN(void	bn_wlt_haar_2d_short_decompose, (short *tbuf, short *buf, \
			unsigned long dimen, unsigned long depth, \
			unsigned long limit ));
BU_EXTERN(void	bn_wlt_haar_2d_short_reconstruct, (short *tbuf, short *buf, \
			unsigned long dimen, unsigned long depth, \
			unsigned long subimage_size, unsigned long limit ));

BU_EXTERN(void	bn_wlt_haar_2d_int_decompose, (int *tbuf, int *buf, \
			unsigned long dimen, unsigned long depth, \
			unsigned long limit ));
BU_EXTERN(void	bn_wlt_haar_2d_int_reconstruct, (int *tbuf, int *buf, \
			unsigned long dimen, unsigned long depth, \
			unsigned long subimage_size, unsigned long limit ));

BU_EXTERN(void	bn_wlt_haar_2d_long_decompose, (long *tbuf, long *buf, \
			unsigned long dimen, unsigned long depth, \
			unsigned long limit ));
BU_EXTERN(void	bn_wlt_haar_2d_long_reconstruct, (long *tbuf, long *buf, \
			unsigned long dimen, unsigned long depth, \
			unsigned long subimage_size, unsigned long limit ));



BU_EXTERN(void	bn_wlt_haar_2d_double_decompose2, (double *tbuf, double *buf, \
			unsigned long dimen, unsigned long width, \
			unsigned long height, unsigned long limit ));
BU_EXTERN(void	bn_wlt_haar_2d_double_reconstruct2, (double *tbuf, double *buf, \
			unsigned long dimen, unsigned long width, \
			unsigned long height, unsigned long subimage_size, \
                        unsigned long limit ));

BU_EXTERN(void	bn_wlt_haar_2d_float_decompose2, (float *tbuf, float *buf, \
			unsigned long dimen, unsigned long width, \
			unsigned long height, unsigned long limit ));
BU_EXTERN(void	bn_wlt_haar_2d_float_reconstruct2, (float *tbuf, float *buf, \
			unsigned long dimen, unsigned long width, \
			unsigned long height, unsigned long subimage_size, \
                        unsigned long limit ));

BU_EXTERN(void	bn_wlt_haar_2d_char_decompose2, (char *tbuf, char *buf, \
			unsigned long dimen, unsigned long width, \
			unsigned long height, unsigned long limit ));
BU_EXTERN(void	bn_wlt_haar_2d_char_reconstruct2, (char *tbuf, char *buf, \
			unsigned long dimen, unsigned long width, \
			unsigned long height, unsigned long subimage_size, \
                        unsigned long limit ));

BU_EXTERN(void	bn_wlt_haar_2d_short_decompose2, (short *tbuf, short *buf, \
			unsigned long dimen, unsigned long width, \
			unsigned long height, unsigned long limit ));
BU_EXTERN(void	bn_wlt_haar_2d_short_reconstruct2, (short *tbuf, short *buf, \
			unsigned long dimen, unsigned long width, \
			unsigned long height, unsigned long subimage_size, \
		        unsigned long limit ));

BU_EXTERN(void	bn_wlt_haar_2d_int_decompose2, (int *tbuf, int *buf, \
			unsigned long dimen, unsigned long width, \
			unsigned long height, unsigned long limit ));
BU_EXTERN(void	bn_wlt_haar_2d_int_reconstruct2, (int *tbuf, int *buf, \
			unsigned long dimen, unsigned long width, \
			unsigned long height, unsigned long subimage_size, \
                        unsigned long limit ));

BU_EXTERN(void	bn_wlt_haar_2d_long_decompose2, (long *tbuf, long *buf, \
			unsigned long dimen, unsigned long width, \
			unsigned long height, unsigned long limit ));
BU_EXTERN(void	bn_wlt_haar_2d_long_reconstruct2, (long *tbuf, long *buf, \
			unsigned long dimen, unsigned long width, \
			unsigned long height, unsigned long subimage_size, \
			unsigned long limit ));


/*----------------------------------------------------------------------*/
/* const.c */
extern const double bn_pi;
extern const double bn_twopi;
extern const double bn_halfpi;
extern const double bn_invpi;
extern const double bn_inv2pi;
extern const double bn_inv255;
extern const double bn_degtorad;
extern const double bn_radtodeg;

/*----------------------------------------------------------------------*/
/* tabdata.c */
/*
 *			T A B D A T A
 *
 *  Data structures to assist with
 *  recording many sets of data sampled along the same set of independent
 *  variables.
 *  The overall notion is that each sample should be
 *  as compact as possible (an array of measurements),
 *  with all the context stored in one place.
 *
 *  These structures and support routines apply to
 *  any measured "curve" or "function" or "table" with one independent
 *  variable and one or more scalar dependent variable(s).
 *
 *  The context is kept in an 'bn_table' structure, and
 *  the data for one particular sample are kept in an 'bn_tabdata'
 *  structure.
 *
 *  The contents of the sample in val[j] are interpreted
 *  in the interval (wavel[j]..wavel[j+1]).
 *  This value could be power, albedo, absorption, refractive index,
 *  or any other wavelength-specific parameter.
 *
 *  For example, if the val[] array contains power values, then
 *  val[j] contains the integral of the power from wavel[j] to wavel[j+1]
 *
 *  As an exmple, assume nwave=2, wavel[0]=500, wavel[1]=600, wavel[2]=700.
 *  Then val[0] would contain data for the 500 to 600nm interval,
 *  and val[1] would contain data for the 600 to 700nm interval.
 *  There would be no storage allocated for val[2] -- don't use it!
 *  There are several interpretations of this:
 *	1)  val[j] stores the total (integral, area) value for the interval, or
 *	2)  val[j] stores the average value across the interval.
 *
 *  The intervals need not be uniformly spaced; it is acceptable to
 *  increase wavelength sampling density around "important" frequencies.
 *
 *  See Also -
 *	h/spectrum.h, spectrum.c
 */
struct bn_table {
	long		magic;
	int		nx;
	fastf_t		x[1];	/* array of nx+1 wavelengths, dynamically sized */
};
#define BN_TABLE_MAGIC	0x53706374
#define BN_CK_TABLE(_p)	BU_CKMAG(_p, BN_TABLE_MAGIC, "bn_table")
#define BN_TABLE_NULL	((struct bn_table *)NULL)

/* Gets an bn_table, with x[] having size _nx+1 */
#ifndef NO_BOMBING_MACROS
#  define BN_GET_TABLE(_table, _nx)  { \
	if( (_nx) < 1 )  bu_bomb("RT_GET_TABLE() _nx < 1\n"); \
	_table = (struct bn_table *)bu_calloc( 1, \
		sizeof(struct bn_table) + sizeof(fastf_t)*(_nx), \
		"struct bn_table" ); \
	_table->magic = BN_TABLE_MAGIC; \
	_table->nx = (_nx);  }
#else
#  define BN_GET_TABLE(_table, _nx)  { \
	_table = (struct bn_table *)bu_calloc( 1, \
		sizeof(struct bn_table) + sizeof(fastf_t)*(_nx), \
		"struct bn_table" ); \
	_table->magic = BN_TABLE_MAGIC; \
	_table->nx = (_nx);  }
#endif

struct bn_tabdata {
	long		magic;
	int		ny;
	const struct bn_table *table;	/* Up pointer to definition of X axis */
	fastf_t		y[1];		/* array of ny samples, dynamically sized */
};
#define BN_TABDATA_MAGIC	0x53736d70
#define BN_CK_TABDATA(_p)	BU_CKMAG(_p, BN_TABDATA_MAGIC, "bn_tabdata")
#define BN_TABDATA_NULL		((struct bn_tabdata *)NULL)

#define BN_SIZEOF_TABDATA_Y(_tabdata)	sizeof(fastf_t)*((_tabdata)->ny)
#define BN_SIZEOF_TABDATA(_table)	( sizeof(struct bn_tabdata) + \
			sizeof(fastf_t)*((_table)->nx-1) )

/* Gets an bn_tabdata, with y[] having size _ny */
#define BN_GET_TABDATA(_data, _table)  { \
	BN_CK_TABLE(_table);\
	_data = (struct bn_tabdata *)bu_calloc( 1, \
		BN_SIZEOF_TABDATA(_table), "struct bn_tabdata" ); \
	_data->magic = BN_TABDATA_MAGIC; \
	_data->ny = (_table)->nx; \
	_data->table = (_table); }

/*
 * Routines
 */

BU_EXTERN( void			bn_table_free, (struct bn_table	*tabp));
BU_EXTERN( void			bn_tabdata_free, (struct bn_tabdata *data));
BU_EXTERN( void			bn_ck_table, (const struct bn_table *tabp));
BU_EXTERN( struct bn_table	*bn_table_make_uniform, (int num, double first,
					double last));
BU_EXTERN( void			bn_tabdata_add, (struct bn_tabdata *out,
					const struct bn_tabdata *in1,
					const struct bn_tabdata *in2));
BU_EXTERN( void			bn_tabdata_mul, (struct bn_tabdata *out,
					const struct bn_tabdata *in1,
					const struct bn_tabdata *in2));
BU_EXTERN( void			bn_tabdata_mul3, (struct bn_tabdata *out,
					const struct bn_tabdata	*in1,
					const struct bn_tabdata	*in2,
					const struct bn_tabdata	*in3));
BU_EXTERN( void			bn_tabdata_incr_mul3_scale,
					(struct bn_tabdata *out,
					const struct bn_tabdata	*in1,
					const struct bn_tabdata	*in2,
					const struct bn_tabdata	*in3,
					double scale));
BU_EXTERN( void			bn_tabdata_incr_mul2_scale,
					(struct bn_tabdata *out,
					const struct bn_tabdata	*in1,
					const struct bn_tabdata	*in2,
					double scale));
BU_EXTERN( void			bn_tabdata_scale, (struct bn_tabdata *out,
					const struct bn_tabdata *in1,
					double scale));
BU_EXTERN( void			bn_table_scale, (struct bn_table *tabp,
					double scale));
BU_EXTERN( void			bn_tabdata_join1, (struct bn_tabdata *out,
					const struct bn_tabdata *in1,
					double scale,
					const struct bn_tabdata *in2));
BU_EXTERN( void			bn_tabdata_join2, (struct bn_tabdata *out,
					const struct bn_tabdata *in1,
					double scale2,
					const struct bn_tabdata *in2,
					double scale3,
					const struct bn_tabdata *in3));
BU_EXTERN( void			bn_tabdata_blend2, (struct bn_tabdata *out,
					double scale1,
					const struct bn_tabdata *in1,
					double scale2,
					const struct bn_tabdata *in2));
BU_EXTERN( void			bn_tabdata_blend3, (struct bn_tabdata *out,
					double scale1,
					const struct bn_tabdata *in1,
					double scale2,
					const struct bn_tabdata *in2,
					double scale3,
					const struct bn_tabdata *in3));
BU_EXTERN( double		bn_tabdata_area1, (const struct bn_tabdata *in));
BU_EXTERN( double		bn_tabdata_area2, (const struct bn_tabdata *in));
BU_EXTERN( double		bn_tabdata_mul_area1, (const struct bn_tabdata *in1,
					const struct bn_tabdata	*in2));
BU_EXTERN( double		bn_tabdata_mul_area2, (const struct bn_tabdata *in1,
					const struct bn_tabdata	*in2));
BU_EXTERN( fastf_t		bn_table_lin_interp, (const struct bn_tabdata *samp,
					double wl));
BU_EXTERN( struct bn_tabdata	*bn_tabdata_resample_max, (
					const struct bn_table *newtable,
					const struct bn_tabdata *olddata));
BU_EXTERN( struct bn_tabdata	*bn_tabdata_resample_avg, (
					const struct bn_table *newtable,
					const struct bn_tabdata *olddata));
BU_EXTERN( int			bn_table_write, (const char *filename,
					const struct bn_table *tabp));
BU_EXTERN( struct bn_table	*bn_table_read, (const char *filename));
BU_EXTERN( void			bn_pr_table, (const char *title,
					const struct bn_table *tabp));
BU_EXTERN( void			bn_pr_tabdata, (const char *title,
					const struct bn_tabdata	*data));
BU_EXTERN( int			bn_print_table_and_tabdata, (const char *filename,
					const struct bn_tabdata *data));
BU_EXTERN( struct bn_tabdata	*bn_read_table_and_tabdata, (
					const char *filename));
BU_EXTERN( struct bn_tabdata	*bn_tabdata_binary_read, (const char *filename,
					int num,
					const struct bn_table *tabp));
BU_EXTERN( struct bn_tabdata	*bn_tabdata_malloc_array, (
					const struct bn_table *tabp,
					int num));
BU_EXTERN( void			bn_tabdata_copy, (struct bn_tabdata *out,
					const struct bn_tabdata *in));
BU_EXTERN(struct bn_tabdata	*bn_tabdata_dup, (const struct bn_tabdata *in));
BU_EXTERN(struct bn_tabdata	*bn_tabdata_get_constval, (double val,
					const struct bn_table	*tabp));
BU_EXTERN(void			bn_tabdata_constval, (struct bn_tabdata	*data, double val));
BU_EXTERN( void			bn_tabdata_to_tcl, (struct bu_vls *vp,
					const struct bn_tabdata	*data));
BU_EXTERN(struct bn_tabdata	*bn_tabdata_from_array, (const double *array));
BU_EXTERN( void			bn_tabdata_freq_shift, (struct bn_tabdata *out,
					const struct bn_tabdata *in,
					double offset));
BU_EXTERN( int			bn_table_interval_num_samples,
					(const struct bn_table *tabp,
					double	low, double	hi));
BU_EXTERN( int			bn_table_delete_sample_pts,
					(struct bn_table *tabp,
					int	i, int	j));
BU_EXTERN(struct bn_table	*bn_table_merge2, (const struct bn_table *a,
				const struct bn_table *b));
BU_EXTERN(struct bn_tabdata	*bn_tabdata_mk_linear_filter,
					(const struct bn_table *spectrum,
					double lower_wavelen, double upper_wavelen));

/*----------------------------------------------------------------------*/
/* vlist.c */
/*
 *			B N _ V L I S T
 *
 *  Definitions for handling lists of vectors (really verticies, or points)
 *  and polygons in 3-space.
 *  Intented for common handling of wireframe display information,
 *  in the full resolution that is calculated in.
 *
 *  On 32-bit machines, BN_VLIST_CHUNK of 35 results in bn_vlist structures
 *  just less than 1k bytes.
 *
 *  The head of the doubly linked list can be just a "struct bu_list" head.
 *
 *  To visit all the elements in the vlist:
 *	for( BU_LIST_FOR( vp, rt_vlist, hp ) )  {
 *		register int	i;
 *		register int	nused = vp->nused;
 *		register int	*cmd = vp->cmd;
 *		register point_t *pt = vp->pt;
 *		for( i = 0; i < nused; i++,cmd++,pt++ )  {
 *			access( *cmd, *pt );
 *			access( vp->cmd[i], vp->pt[i] );
 *		}
 *	}
 */
#define BN_VLIST_CHUNK	35		/* 32-bit mach => just less than 1k */
struct bn_vlist  {
	struct bu_list	l;			/* magic, forw, back */
	int		nused;			/* elements 0..nused active */
	int		cmd[BN_VLIST_CHUNK];	/* VL_CMD_* */
	point_t		pt[BN_VLIST_CHUNK];	/* associated 3-point/vect */
};
#define BN_VLIST_NULL	((struct bn_vlist *)0)
#define BN_VLIST_MAGIC	0x98237474
#define BN_CK_VLIST(_p) BU_CKMAG((_p), BN_VLIST_MAGIC, "bn_vlist")
#define BN_CK_VLIST_TCL(_interp,_p) BU_CKMAG_TCL(_interp,(_p), BN_VLIST_MAGIC, "bn_vlist")

/* Values for cmd[] */
#define BN_VLIST_LINE_MOVE	0
#define BN_VLIST_LINE_DRAW	1
#define BN_VLIST_POLY_START	2	/* pt[] has surface normal */
#define BN_VLIST_POLY_MOVE	3	/* move to first poly vertex */
#define BN_VLIST_POLY_DRAW	4	/* subsequent poly vertex */
#define BN_VLIST_POLY_END	5	/* last vert (repeats 1st), draw poly */
#define BN_VLIST_POLY_VERTNORM	6	/* per-vertex normal, for interpoloation */

/*
 *  Applications that are going to use BN_ADD_VLIST and BN_GET_VLIST
 *  are required to execute this macro once, on their _free_hd:
 *		BU_LIST_INIT( &_free_hd );
 *
 * Note that BN_GET_VLIST and BN_FREE_VLIST are non-PARALLEL.
 */
#define BN_GET_VLIST(_free_hd,p) {\
		(p) = BU_LIST_FIRST( bn_vlist, (_free_hd) ); \
		if( BU_LIST_IS_HEAD( (p), (_free_hd) ) )  { \
			(p) = (struct bn_vlist *)bu_malloc(sizeof(struct bn_vlist), "bn_vlist"); \
			(p)->l.magic = BN_VLIST_MAGIC; \
		} else { \
			BU_LIST_DEQUEUE( &((p)->l) ); \
		} \
		(p)->nused = 0; \
	}

/* Place an entire chain of bn_vlist structs on the freelist _free_hd */
#define BN_FREE_VLIST(_free_hd,hd)	{ \
	BU_CK_LIST_HEAD( (hd) ); \
	BU_LIST_APPEND_LIST( (_free_hd), (hd) ); \
	}

#define BN_ADD_VLIST(_free_hd,_dest_hd,pnt,draw)  { \
	register struct bn_vlist *_vp; \
	BU_CK_LIST_HEAD( _dest_hd ); \
	_vp = BU_LIST_LAST( bn_vlist, (_dest_hd) ); \
	if( BU_LIST_IS_HEAD( _vp, (_dest_hd) ) || _vp->nused >= BN_VLIST_CHUNK )  { \
		BN_GET_VLIST(_free_hd, _vp); \
		BU_LIST_INSERT( (_dest_hd), &(_vp->l) ); \
	} \
	VMOVE( _vp->pt[_vp->nused], (pnt) ); \
	_vp->cmd[_vp->nused++] = (draw); \
	}

/*
 *			B N _ V L B L O C K
 *
 *  For plotting, a way of separating plots into separate color vlists:
 *  blocks of vlists, each with an associated color.
 */
struct bn_vlblock {
	long		magic;
	int		nused;
	int		max;
	long		*rgb;		/* rgb[max] variable size array */
	struct bu_list	*head;		/* head[max] variable size array */
	struct bu_list	*free_vlist_hd;	/* where to get/put free vlists */
};
#define BN_VLBLOCK_MAGIC	0x981bd112
#define BN_CK_VLBLOCK(_p)	BU_CKMAG((_p), BN_VLBLOCK_MAGIC, "bn_vlblock")

BU_EXTERN(void	bn_vlist_3string, (struct bu_list *vhead,
				struct bu_list *free_hd, const char *string,
				const point_t origin, const mat_t rot,
				double scale));
BU_EXTERN(void	bn_vlist_2string, (struct bu_list *vhead,
				struct bu_list *free_hd, const char *string,
				double x, double y, double scale, double theta));


/*----------------------------------------------------------------------*/
/* vert_tree.c */
/*
 * vertex tree support
 */
/* packaging structure
 * holds all the required info for a single vertex tree
 */
struct vert_root {
	long magic;
	int tree_type;			/* vertices or vertices with normals */
	union vert_tree *the_tree;	/* the actual vertex tree */
	fastf_t *the_array;		/* the array of vertices */
	unsigned long curr_vert;	/* the number of vertices currently in the array */
	unsigned long max_vert;		/* the current maximum capacity of the array */
};

#define TREE_TYPE_VERTS			1
#define TREE_TYPE_VERTS_AND_NORMS	2

#define VERT_BLOCK 512			/* number of vertices to malloc per call when building the array */

#define VERT_TREE_MAGIC	0x56455254	/* "VERT" */
#define BN_CK_VERT_TREE(_p)	BU_CKMAG(_p, VERT_TREE_MAGIC, "vert_tree")

extern struct vert_root *create_vert_tree();
extern struct vert_root *create_vert_tree_w_norms();
extern void free_vert_tree( struct vert_root *tree_root );
extern int Add_vert( double x, double y, double z, struct vert_root *tree_root, fastf_t local_tol_sq );
extern int Add_vert_and_norm( double x, double y, double z,
			      double nx, double ny, double nz,
			      struct vert_root *tree_root,
			      fastf_t local_tol_sq );
extern void clean_vert_tree( struct vert_root *tree_root );

/*----------------------------------------------------------------------*/
/* vectfont.c */
extern void tp_setup();


/*----------------------------------------------------------------------*/
/* vers.c (created by the Cakefile) */
extern const char		bn_version[];
/*----------------------------------------------------------------------*/

#ifdef __cplusplus
}
#endif
#endif /* SEEN_BN_H */
@


1.73
log
@merge of ansi-6-0-branch into HEAD
@
text
@d47 1
a47 1
 *  $Header$
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header$ (BRL)"
@


1.72
log
@Added capability to handle normals to vert_tree code
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.71 2002/11/01 18:01:44 jra Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.71 2002/11/01 18:01:44 jra Exp $ (BRL)"
d420 1
a420 1
BU_EXTERN(double	bn_noise_perlin, (const point_t pt) );
d422 1
a422 1
BU_EXTERN(void		bn_noise_vec, (const point_t point, point_t result) );
@


1.71
log
@Add_vert() now takes doubles instead of floats
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.70 2002/11/01 16:20:35 jra Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.70 2002/11/01 16:20:35 jra Exp $ (BRL)"
d1179 1
d1186 3
d1195 1
d1198 4
@


1.70
log
@Added support for vertex binary search trees
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.69 2002/08/20 17:07:29 jra Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.69 2002/08/20 17:07:29 jra Exp $ (BRL)"
d1192 1
a1192 1
extern int Add_vert( float x, float y, float z, struct vert_root *tree_root, fastf_t local_tol_sq );
@


1.69
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.67 2002/02/28 01:02:31 butler Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.67 2002/02/28 01:02:31 butler Exp $ (BRL)"
d1167 27
@


1.69.4.1
log
@sync to HEAD...
@
text
@d47 1
a47 1
 *  $Header: /n/cad/c/CVS/brlcad/h/bn.h,v 1.72 2003/03/26 20:18:41 jra Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /n/cad/c/CVS/brlcad/h/bn.h,v 1.72 2003/03/26 20:18:41 jra Exp $ (BRL)"
a1166 36


/*----------------------------------------------------------------------*/
/* vert_tree.c */
/*
 * vertex tree support
 */
/* packaging structure
 * holds all the required info for a single vertex tree
 */
struct vert_root {
	long magic;
	int tree_type;			/* vertices or vertices with normals */
	union vert_tree *the_tree;	/* the actual vertex tree */
	fastf_t *the_array;		/* the array of vertices */
	unsigned long curr_vert;	/* the number of vertices currently in the array */
	unsigned long max_vert;		/* the current maximum capacity of the array */
};

#define TREE_TYPE_VERTS			1
#define TREE_TYPE_VERTS_AND_NORMS	2

#define VERT_BLOCK 512			/* number of vertices to malloc per call when building the array */

#define VERT_TREE_MAGIC	0x56455254	/* "VERT" */
#define BN_CK_VERT_TREE(_p)	BU_CKMAG(_p, VERT_TREE_MAGIC, "vert_tree")

extern struct vert_root *create_vert_tree();
extern struct vert_root *create_vert_tree_w_norms();
extern void free_vert_tree( struct vert_root *tree_root );
extern int Add_vert( double x, double y, double z, struct vert_root *tree_root, fastf_t local_tol_sq );
extern int Add_vert_and_norm( double x, double y, double z,
			      double nx, double ny, double nz,
			      struct vert_root *tree_root,
			      fastf_t local_tol_sq );
extern void clean_vert_tree( struct vert_root *tree_root );
@


1.69.2.1
log
@Initial ANSIfication
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.69 2002/08/20 17:07:29 jra Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.69 2002/08/20 17:07:29 jra Exp $ (BRL)"
d420 1
a420 1
BU_EXTERN(double	bn_noise_perlin, (point_t pt) );
d422 1
a422 1
BU_EXTERN(void		bn_noise_vec, (point_t point, point_t result) );
@


1.69.2.2
log
@sync branch with HEAD
@
text
@d47 1
a47 1
 *  $Header$
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header$ (BRL)"
a1166 36


/*----------------------------------------------------------------------*/
/* vert_tree.c */
/*
 * vertex tree support
 */
/* packaging structure
 * holds all the required info for a single vertex tree
 */
struct vert_root {
	long magic;
	int tree_type;			/* vertices or vertices with normals */
	union vert_tree *the_tree;	/* the actual vertex tree */
	fastf_t *the_array;		/* the array of vertices */
	unsigned long curr_vert;	/* the number of vertices currently in the array */
	unsigned long max_vert;		/* the current maximum capacity of the array */
};

#define TREE_TYPE_VERTS			1
#define TREE_TYPE_VERTS_AND_NORMS	2

#define VERT_BLOCK 512			/* number of vertices to malloc per call when building the array */

#define VERT_TREE_MAGIC	0x56455254	/* "VERT" */
#define BN_CK_VERT_TREE(_p)	BU_CKMAG(_p, VERT_TREE_MAGIC, "vert_tree")

extern struct vert_root *create_vert_tree();
extern struct vert_root *create_vert_tree_w_norms();
extern void free_vert_tree( struct vert_root *tree_root );
extern int Add_vert( double x, double y, double z, struct vert_root *tree_root, fastf_t local_tol_sq );
extern int Add_vert_and_norm( double x, double y, double z,
			      double nx, double ny, double nz,
			      struct vert_root *tree_root,
			      fastf_t local_tol_sq );
extern void clean_vert_tree( struct vert_root *tree_root );
@


1.68
log
@Converted from K&R to ANSI C - RFH
@
text
@d420 1
a420 1
BU_EXTERN(double	bn_noise_perlin, (point_t pt) );
d422 1
a422 1
BU_EXTERN(void		bn_noise_vec, (point_t point, point_t result) );
@


1.67
log
@added bn_mat_is_non_unif()
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.66 2001/08/11 13:11:40 butler Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.66 2001/08/11 13:11:40 butler Exp $ (BRL)"
d420 1
a420 1
BU_EXTERN(double	bn_noise_perlin, (const point_t pt) );
d422 1
a422 1
BU_EXTERN(void		bn_noise_vec, (const point_t point, point_t result) );
@


1.66
log
@misc compiler warning changes
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.65 2001/06/01 16:45:54 bparker Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.65 2001/06/01 16:45:54 bparker Exp $ (BRL)"
d337 1
@


1.65
log
@*- defined BN_AZIMUTH, BN_ELEVATION and BN_TWIST
*- declared bn_tcl_mat_print, bn_mat_print_guts
   and bn_mat_angles_rad
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.64 2001/05/16 21:37:43 morrison Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.64 2001/05/16 21:37:43 morrison Exp $ (BRL)"
d689 1
@


1.64
log
@PRODUCTION optimizations
included a section in conf.h that controls how most optimization settings are used
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.63 2001/04/05 19:35:06 morrison Exp $
d56 5
a60 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.63 2001/04/05 19:35:06 morrison Exp $ (BRL)"
d171 1
d223 1
d306 2
@


1.63
log
@updated SIGNED to signed
updated CONST to const
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.62 2001/04/02 21:37:52 morrison Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.62 2001/04/02 21:37:52 morrison Exp $ (BRL)"
d694 1
a694 1
	} \
d897 2
a898 1
#define BN_GET_TABLE(_table, _nx)  { \
d905 8
a912 1

@


1.62
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.61 2001/03/31 01:56:33 morrison Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.61 2001/03/31 01:56:33 morrison Exp $ (BRL)"
d109 1
a109 1
						      CONST char *filename,
d207 2
a208 2
BU_EXTERN(void			bn_cx_div, (bn_complex_t *ap, CONST bn_complex_t *bp) );
BU_EXTERN(void			bn_cx_sqrt, (bn_complex_t *op, CONST bn_complex_t *ip) );
d215 1
a215 1
extern CONST mat_t 	bn_mat_identity;
d217 1
a217 1
BU_EXTERN(void		bn_mat_print, (CONST char *title, CONST mat_t m));
d223 1
a223 1
BU_EXTERN(void		bn_mat_copy, (register mat_t dest,register CONST mat_t src));
d243 1
a243 1
#define bn_mat_idn( _m )	(void)memcpy( (void *)_m, (CONST void *)bn_mat_identity, sizeof(mat_t))
d266 1
a266 1
#define bn_mat_copy(_d,_s)	(void)memcpy( (void *)_d, (CONST void *)(_s), sizeof(mat_t))
d270 5
a274 5
BU_EXTERN(void		bn_mat_mul, (register mat_t o, register CONST mat_t a,
					register CONST mat_t b));
BU_EXTERN(void		bn_mat_mul2, (register CONST mat_t i, register mat_t o));
BU_EXTERN(void		bn_mat_mul3, (mat_t o, CONST mat_t a, CONST mat_t b,
					CONST mat_t c));
d282 3
a284 3
					register CONST mat_t im,
					register CONST hvect_t iv));
BU_EXTERN(void		bn_mat_inv, (register mat_t output, CONST mat_t input));
d286 1
a286 1
					register CONST vect_t v));
d288 2
a289 2
					register CONST vect_t h));
BU_EXTERN(void		bn_mat_trn, (mat_t om, register CONST mat_t im));
d293 1
a293 1
					CONST vect_t v));
d305 3
a307 3
BU_EXTERN(void		bn_vec_perp, (vect_t new_vec, CONST vect_t old_vec));
BU_EXTERN(void		bn_mat_fromto, ( mat_t m, CONST vect_t from,
					CONST vect_t to));
d311 1
a311 1
BU_EXTERN(void		bn_mat_lookat, (mat_t rot, CONST vect_t dir, int yflip));
d313 3
a315 3
					register CONST vect_t in));
BU_EXTERN(int		bn_mat_scale_about_pt, (mat_t mat, CONST point_t pt,
					CONST double scale));
d317 11
a327 11
					CONST mat_t xform,
					CONST point_t pt));
BU_EXTERN(int		bn_mat_is_equal, (CONST mat_t a, CONST mat_t b, 
					CONST struct bn_tol *tol));
BU_EXTERN(int		bn_mat_is_identity, (CONST mat_t m));
BU_EXTERN(void		bn_mat_arb_rot, ( mat_t m, CONST point_t pt,
					CONST vect_t dir, CONST fastf_t ang));
BU_EXTERN(matp_t	bn_mat_dup, (CONST mat_t in));
BU_EXTERN(int		bn_mat_ck, (CONST char *title, CONST mat_t m));
BU_EXTERN(fastf_t	bn_mat_det3, (CONST mat_t m));
BU_EXTERN(fastf_t	bn_mat_determinant, (CONST mat_t m));
d411 1
a411 1
BU_EXTERN(double	bn_noise_perlin, (CONST point_t pt) );
d413 1
a413 1
BU_EXTERN(void		bn_noise_vec, (CONST point_t point, point_t result) );
d441 2
a442 2
				CONST point_t a, CONST point_t b,
				CONST point_t p, CONST struct bn_tol *tol));
d444 3
a446 3
				CONST struct bn_tol *tol));
BU_EXTERN(int		bn_pt3_pt3_equal, ( CONST point_t a, CONST point_t b,
				CONST struct bn_tol *tol));
d448 3
a450 3
				fastf_t pca[2], CONST point_t a,
				CONST point_t b, CONST point_t p,
				CONST struct bn_tol *tol));
d452 3
a454 3
				CONST point_t p, CONST vect_t pdir,
				CONST point_t q, CONST vect_t qdir,
				CONST struct bn_tol *tol));
d456 16
a471 16
				CONST point_t p, CONST vect_t d,
				CONST point_t a, CONST vect_t c,
				CONST struct bn_tol *tol));
BU_EXTERN(int		bn_2line3_colinear, ( CONST point_t p1,
				CONST vect_t d1, CONST point_t p2,
				CONST vect_t d2, double range,
				CONST struct bn_tol *tol));
BU_EXTERN(int		bn_isect_pt2_lseg2, ( fastf_t *dist, CONST point_t a,
				CONST point_t b, CONST point_t p,
				CONST struct bn_tol *tol));
BU_EXTERN(int		bn_isect_line2_lseg2, (fastf_t *dist, CONST point_t p,
				CONST vect_t d, CONST point_t a,
				CONST vect_t c, CONST struct bn_tol *tol));
BU_EXTERN(int		bn_isect_lseg2_lseg2, (fastf_t *dist, CONST point_t p,
				CONST vect_t pdir, CONST point_t q,
				CONST vect_t qdir, CONST struct bn_tol *tol));
d473 11
a483 11
				CONST point_t p, CONST vect_t d,
				CONST point_t a, CONST vect_t c,
				CONST struct bn_tol *tol));
BU_EXTERN(double	bn_dist_pt3_pt3, (CONST point_t a, CONST point_t b));
BU_EXTERN(int		bn_3pts_distinct, (CONST point_t a, CONST point_t b,
				CONST point_t c, CONST struct bn_tol *tol) );
BU_EXTERN(int		bn_mk_plane_3pts, (plane_t plane, CONST point_t a,
				CONST point_t b, CONST point_t c,
				CONST struct bn_tol *tol) );
BU_EXTERN(int		bn_mkpoint_3planes, (point_t pt, CONST plane_t a,
				CONST plane_t b, CONST plane_t c) );
d485 4
a488 4
				CONST point_t pt,
				CONST vect_t dir,
				CONST plane_t plane,
				CONST struct bn_tol *tol) );
d490 3
a492 3
				CONST plane_t a, CONST plane_t b,
				CONST vect_t rpp_min,
				CONST struct bn_tol *tol) );
d494 24
a517 24
				CONST point_t p, CONST vect_t d, 
				CONST point_t a, CONST vect_t c,
				CONST struct bn_tol *tol) );
BU_EXTERN(int		bn_isect_line_lseg, (fastf_t *t, CONST point_t p,
				CONST vect_t d, CONST point_t a,
				CONST point_t b, CONST struct bn_tol *tol) );
BU_EXTERN(double	bn_dist_line3_pt3, (CONST point_t pt,
				CONST vect_t dir, CONST point_t a) );
BU_EXTERN(double	bn_distsq_line3_pt3, (CONST point_t pt,
				CONST vect_t dir, CONST point_t a));
BU_EXTERN(double	bn_dist_line_origin, (CONST point_t pt,
				CONST vect_t dir) );
BU_EXTERN(double	bn_dist_line2_point2, (CONST point_t pt,
				CONST vect_t dir, CONST point_t a));
BU_EXTERN(double	bn_distsq_line2_point2, (CONST point_t pt,
				CONST vect_t dir, CONST point_t a));
BU_EXTERN(double	bn_area_of_triangle, (CONST point_t a,
				CONST point_t b, CONST point_t c) );
BU_EXTERN(int		bn_isect_pt_lseg, (fastf_t *dist, CONST point_t a,
				CONST point_t b, CONST point_t p,
				CONST struct bn_tol *tol) );
BU_EXTERN(double	bn_dist_pt_lseg, (point_t pca, CONST point_t a,
				CONST point_t b, CONST point_t p,
				CONST struct bn_tol *tol) );
d519 12
a530 12
				CONST mat_t mat, CONST point_t imin,
				CONST point_t imax));
BU_EXTERN(void		bn_rotate_plane, (plane_t oplane, CONST mat_t mat,
				CONST plane_t iplane));
BU_EXTERN(int		bn_coplanar, (CONST plane_t a, CONST plane_t b,
				CONST struct bn_tol *tol));
BU_EXTERN(double	bn_angle_measure, (vect_t vec, CONST vect_t x_dir,
				CONST vect_t y_dir));
BU_EXTERN(double	bn_dist_pt3_along_line3, (CONST point_t	p,
				CONST vect_t d, CONST point_t x));
BU_EXTERN(double	bn_dist_pt2_along_line2, (CONST point_t p,
				CONST vect_t d, CONST point_t x));
d532 1
a532 1
				double right, CONST struct bn_tol *tol));
d540 3
a542 3
BU_EXTERN(int		bn_hlf_class, (CONST plane_t half_eqn,
				       CONST vect_t min, CONST vect_t max,
				       CONST struct bn_tol *tol));
d550 1
a550 1
				CONST plane_t planes[], CONST int pl_count));
d570 1
a570 1
				CONST struct bn_poly *m1, CONST struct bn_poly *m2));
d574 1
a574 1
				CONST struct bn_poly *poly1, CONST struct bn_poly *poly2));
d576 2
a577 2
				CONST struct bn_poly	*poly1,
				CONST struct bn_poly	*poly2));
d580 2
a581 2
				CONST struct bn_poly	*dvdend,
				CONST struct bn_poly	*dvsor));
d584 1
a584 1
				CONST struct bn_poly	*quadrat));
d587 1
a587 1
				CONST struct bn_poly	*eqn));
d590 5
a594 5
				CONST struct bn_poly	*eqn));
BU_EXTERN(void			bn_pr_poly, (CONST char *title,
				CONST struct bn_poly	*eqn));
BU_EXTERN(void			bn_pr_roots, (CONST char *title,
				CONST struct bn_complex	roots[], int n));
d602 12
a613 12
BU_EXTERN(void quat_mat2quat, (quat_t quat, CONST mat_t mat));
BU_EXTERN(void quat_quat2mat, (mat_t mat, CONST quat_t quat));
BU_EXTERN(double quat_distance, (CONST quat_t q1, CONST quat_t q2));
BU_EXTERN(void quat_double, (quat_t qout, CONST quat_t q1, CONST quat_t q2));
BU_EXTERN(void quat_bisect, (quat_t qout, CONST quat_t q1, CONST quat_t q2));
BU_EXTERN(void quat_slerp, (quat_t qout, CONST quat_t q1, CONST quat_t q2, double f));
BU_EXTERN(void quat_sberp, (quat_t qout, CONST quat_t q1, CONST quat_t qa, CONST quat_t qb,
			    CONST quat_t q2, double f));
BU_EXTERN(void quat_make_nearest, (quat_t q1, CONST quat_t q2));
BU_EXTERN(void quat_print, (CONST char *title, CONST quat_t quat));
BU_EXTERN(void quat_exp, (quat_t out, CONST quat_t in));
BU_EXTERN(void quat_log, (quat_t out, CONST quat_t in));
d638 1
a638 1
extern CONST float bn_rand_table[BN_RAND_TABSIZE];
d678 1
a678 1
extern CONST float bn_sin_table[BN_SINTABSIZE];
d836 8
a843 8
extern CONST double bn_pi;
extern CONST double bn_twopi;
extern CONST double bn_halfpi;
extern CONST double bn_invpi;
extern CONST double bn_inv2pi;
extern CONST double bn_inv255;
extern CONST double bn_degtorad;
extern CONST double bn_radtodeg;
d909 1
a909 1
	CONST struct bn_table *table;	/* Up pointer to definition of X axis */
d935 1
a935 1
BU_EXTERN( void			bn_ck_table, (CONST struct bn_table *tabp));
d939 2
a940 2
					CONST struct bn_tabdata *in1,
					CONST struct bn_tabdata *in2));
d942 2
a943 2
					CONST struct bn_tabdata *in1,
					CONST struct bn_tabdata *in2));
d945 3
a947 3
					CONST struct bn_tabdata	*in1,
					CONST struct bn_tabdata	*in2,
					CONST struct bn_tabdata	*in3));
d950 3
a952 3
					CONST struct bn_tabdata	*in1,
					CONST struct bn_tabdata	*in2,
					CONST struct bn_tabdata	*in3,
d956 2
a957 2
					CONST struct bn_tabdata	*in1,
					CONST struct bn_tabdata	*in2,
d960 1
a960 1
					CONST struct bn_tabdata *in1,
d965 1
a965 1
					CONST struct bn_tabdata *in1,
d967 1
a967 1
					CONST struct bn_tabdata *in2));
d969 1
a969 1
					CONST struct bn_tabdata *in1,
d971 1
a971 1
					CONST struct bn_tabdata *in2,
d973 1
a973 1
					CONST struct bn_tabdata *in3));
d976 1
a976 1
					CONST struct bn_tabdata *in1,
d978 1
a978 1
					CONST struct bn_tabdata *in2));
d981 1
a981 1
					CONST struct bn_tabdata *in1,
d983 1
a983 1
					CONST struct bn_tabdata *in2,
d985 8
a992 8
					CONST struct bn_tabdata *in3));
BU_EXTERN( double		bn_tabdata_area1, (CONST struct bn_tabdata *in));
BU_EXTERN( double		bn_tabdata_area2, (CONST struct bn_tabdata *in));
BU_EXTERN( double		bn_tabdata_mul_area1, (CONST struct bn_tabdata *in1,
					CONST struct bn_tabdata	*in2));
BU_EXTERN( double		bn_tabdata_mul_area2, (CONST struct bn_tabdata *in1,
					CONST struct bn_tabdata	*in2));
BU_EXTERN( fastf_t		bn_table_lin_interp, (CONST struct bn_tabdata *samp,
d995 2
a996 2
					CONST struct bn_table *newtable,
					CONST struct bn_tabdata *olddata));
d998 11
a1008 11
					CONST struct bn_table *newtable,
					CONST struct bn_tabdata *olddata));
BU_EXTERN( int			bn_table_write, (CONST char *filename,
					CONST struct bn_table *tabp));
BU_EXTERN( struct bn_table	*bn_table_read, (CONST char *filename));
BU_EXTERN( void			bn_pr_table, (CONST char *title,
					CONST struct bn_table *tabp));
BU_EXTERN( void			bn_pr_tabdata, (CONST char *title,
					CONST struct bn_tabdata	*data));
BU_EXTERN( int			bn_print_table_and_tabdata, (CONST char *filename,
					CONST struct bn_tabdata *data));
d1010 2
a1011 2
					CONST char *filename));
BU_EXTERN( struct bn_tabdata	*bn_tabdata_binary_read, (CONST char *filename,
d1013 1
a1013 1
					CONST struct bn_table *tabp));
d1015 1
a1015 1
					CONST struct bn_table *tabp,
d1018 2
a1019 2
					CONST struct bn_tabdata *in));
BU_EXTERN(struct bn_tabdata	*bn_tabdata_dup, (CONST struct bn_tabdata *in));
d1021 1
a1021 1
					CONST struct bn_table	*tabp));
d1024 2
a1025 2
					CONST struct bn_tabdata	*data));
BU_EXTERN(struct bn_tabdata	*bn_tabdata_from_array, (CONST double *array));
d1027 1
a1027 1
					CONST struct bn_tabdata *in,
d1030 1
a1030 1
					(CONST struct bn_table *tabp,
d1035 2
a1036 2
BU_EXTERN(struct bn_table	*bn_table_merge2, (CONST struct bn_table *a,
				CONST struct bn_table *b));
d1038 1
a1038 1
					(CONST struct bn_table *spectrum,
d1143 2
a1144 2
				struct bu_list *free_hd, CONST char *string,
				CONST point_t origin, CONST mat_t rot,
d1147 1
a1147 1
				struct bu_list *free_hd, CONST char *string,
d1157 1
a1157 1
extern CONST char		bn_version[];
@


1.61
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.60 2001/03/29 21:49:58 morrison Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.60 2001/03/29 21:49:58 morrison Exp $ (BRL)"
a241 1

d245 21
d267 1
@


1.60
log
@boo ...typo
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.59 2001/03/29 21:47:33 morrison Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.59 2001/03/29 21:47:33 morrison Exp $ (BRL)"
d220 1
a220 1
#if 0 /* deprecated for macros below */
d226 2
d236 2
@


1.59
log
@typo (boo) _m vs m
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.58 2001/03/29 13:26:32 morrison Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.58 2001/03/29 13:26:32 morrison Exp $ (BRL)"
d234 4
a237 4
	(m)[1] = (m)[2] = (m)[3] = (m)[4] = \
	(m)[6] = (m)[7] = (m)[8] = (m)[9] = \
	(m)[11] = (m)[12] = (m)[13] = (m)[14] = 0.0; \
	(m)[0] = (m)[5] = (m)[10] = (m)[15] = 1.0; }
@


1.58
log
@added performance modified versions of the identity and zero'ing matrix functions/macros in h/vmath.h and h/bn.h

all tests to date showed that there was no considerable increase in code size, and all compilers tested (gcc and irix cc on linux, irix, and freebsd) showed up to 6X speed increase and outperformed the alternatives regardless of optimization used.
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.57 2001/01/16 21:11:22 cjohnson Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.57 2001/01/16 21:11:22 cjohnson Exp $ (BRL)"
d226 4
a229 4
	(m)[0] = (m)[1] = (m)[2] = (m)[3] = \
	(m)[4] = (m)[5] = (m)[6] = (m)[7] = \
	(m)[8] = (m)[9] = (m)[10] = (m)[11] = \
	(m)[12] = (m)[13] = (m)[14] = (m)[15] = 0.0; }
@


1.57
log
@Add a const in front the file name passed in.
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.56 2000/10/24 18:25:29 mike Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.56 2000/10/24 18:25:29 mike Exp $ (BRL)"
d225 6
d232 8
d241 1
@


1.56
log
@
Added bn_does_ray_isect_tri() to bn.h
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.55 2000/10/24 18:02:29 mike Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.55 2000/10/24 18:02:29 mike Exp $ (BRL)"
d109 1
a109 1
						      char *filename,
@


1.55
log
@
Added declarations for anim_* routines to h/bn.h
XXX These should have had a bn_ prefix!
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.54 2000/10/24 14:45:50 mike Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.54 2000/10/24 14:45:50 mike Exp $ (BRL)"
d493 7
@


1.54
log
@
Added Tcl externs
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.53 2000/09/26 13:45:36 jra Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.53 2000/09/26 13:45:36 jra Exp $ (BRL)"
d117 35
@


1.53
log
@Eliminated prototypes of non-existent routines: bn_decode_plane() and bn_decode_tol()
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.52 2000/09/07 03:01:05 mike Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.52 2000/09/07 03:01:05 mike Exp $ (BRL)"
d128 4
@


1.52
log
@
Added extern
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.51 2000/08/24 03:58:01 mike Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.51 2000/08/24 03:58:01 mike Exp $ (BRL)"
a120 1
int bn_decode_tol(struct bn_tol *tol, const char *str);
a123 1
int bn_decode_plane(plane_t v, const char *str);
@


1.51
log
@
Fixed typo in routine name.
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.50 2000/08/21 02:06:59 butler Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.50 2000/08/21 02:06:59 butler Exp $ (BRL)"
d198 6
@


1.50
log
@Massive amounts of compiler warnings eliminated on Linux
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.49 2000/08/17 02:32:43 mike Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.49 2000/08/17 02:32:43 mike Exp $ (BRL)"
d114 1
a114 1
BU_EXTERN(int			bn_common_image_zie, (int *width,
@


1.49
log
@
Added externs for new functions.
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.48 2000/08/10 13:06:47 jra Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.48 2000/08/10 13:06:47 jra Exp $ (BRL)"
d348 8
@


1.48
log
@Eliminated duplicate prototype for bn_decode_quat()
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.47 2000/07/25 16:38:31 butler Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.47 2000/07/25 16:38:31 butler Exp $ (BRL)"
d846 15
d870 11
d905 4
d925 2
d928 9
@


1.47
log
@Added rtprivate.h for rt internal debug info an externs
Extra externs in bn.h and raytrace.h
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.46 2000/07/11 23:53:49 mike Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.46 2000/07/11 23:53:49 mike Exp $ (BRL)"
a121 1
int bn_decode_quat(quat_t q, const char *str);
@


1.46
log
@
Added Tcl interfaces.
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.45 2000/07/07 05:50:44 cjohnson Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.45 2000/07/07 05:50:44 cjohnson Exp $ (BRL)"
a575 1

d583 1
@


1.45
log
@Add function declearations for asize.c
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.44 2000/06/28 20:33:44 mike Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.44 2000/06/28 20:33:44 mike Exp $ (BRL)"
d117 15
@


1.44
log
@
Added helpful comment.
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.43 2000/04/12 02:10:32 mike Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.43 2000/04/12 02:10:32 mike Exp $ (BRL)"
d105 12
@


1.43
log
@
NT port, missing externs.
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.42 2000/03/29 02:06:59 mike Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.42 2000/03/29 02:06:59 mike Exp $ (BRL)"
d85 3
@


1.42
log
@
Imported bn_isect_planes from nmg_misc.c
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.41 2000/03/15 22:50:53 butler Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.41 2000/03/15 22:50:53 butler Exp $ (BRL)"
d207 2
d213 3
a215 2
BU_EXTERN(int		bn_mat_is_equal, (CONST mat_t a, CONST mat_t b, 
					CONST struct bn_tol *tol));
@


1.41
log
@Changed "long" to "unsigned long" so initializer would work on Solaris
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.40 2000/03/13 03:29:43 butler Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.40 2000/03/13 03:29:43 butler Exp $ (BRL)"
d418 3
@


1.40
log
@Added ridged noise function
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.39 2000/02/14 18:51:56 mike Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.39 2000/02/14 18:51:56 mike Exp $ (BRL)"
d87 1
a87 1
	long		magic;
@


1.39
log
@
Added declaration for bn_mat_mul3
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.38 2000/02/03 06:32:12 butler Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.38 2000/02/03 06:32:12 butler Exp $ (BRL)"
d303 6
@


1.38
log
@Made the table used by bn_rand_half much larger to reduce aliasing.
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.37 2000/01/20 22:04:07 mike Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.37 2000/01/20 22:04:07 mike Exp $ (BRL)"
d167 2
@


1.37
log
@
Added new routine to tabdata.c
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.36 2000/01/07 20:36:54 mike Exp $
d56 1
a56 2
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.36 2000/01/07 20:36:54 mike Exp $ (BRL)"

a475 1

d488 5
d496 2
a497 1
#define BN_RANDSEED( _i, _seed )        _i = ((unsigned)_seed) % BN_RAND_TABSIZE
d499 1
a499 1
/* BN_RANDOM gives numbers between 0.0 and 1.0 */
d502 1
a502 1
/* BN_RANDHALF gives numbers between -0.5 and 0.5 */
d511 7
d519 2
a520 1
	( (++(_p) >= &bn_rand_halftab[BN_RANDHALFTABSIZE] || (_p) < bn_rand_halftab) ? \
d524 4
a527 2
	(_p) = &bn_rand_halftab[(int)((bn_rand_halftab[(_seed)%BN_RANDHALFTABSIZE] + \
		0.5)*(BN_RANDHALFTABSIZE-1))]
d529 1
d532 2
d538 1
a538 3

#define BN_RANDHALFTABSIZE	2047	/* Powers of two give streaking */
#define	BN_SINTABSIZE		2048
a540 3
extern float bn_rand_halftab[BN_RANDHALFTABSIZE];
extern CONST float bn_sin_table[BN_SINTABSIZE];
extern CONST float bn_rand_table[BN_RAND_TABSIZE];
@


1.36
log
@
Added CONST
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.35 1999/12/01 13:28:25 bparker Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.35 1999/12/01 13:28:25 bparker Exp $ (BRL)"
d843 3
@


1.35
log
@*- added BN_CK_VLIST_TCL
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.34 1999/10/30 03:06:23 butler Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.34 1999/10/30 03:06:23 butler Exp $ (BRL)"
d462 12
a473 12
BU_EXTERN(void quat_mat2quat, (quat_t quat, mat_t mat));
BU_EXTERN(void quat_quat2mat, (mat_t mat, quat_t quat));
BU_EXTERN(double quat_distance, (quat_t q1, quat_t q2));
BU_EXTERN(void quat_double, (quat_t qout, quat_t q1, quat_t q2));
BU_EXTERN(void quat_bisect, (quat_t qout, quat_t q1, quat_t q2));
BU_EXTERN(void quat_slerp, (quat_t qout, quat_t q1, quat_t q2, double f));
BU_EXTERN(void quat_sberp, (quat_t qout, quat_t q1, quat_t qa, quat_t qb,
			    quat_t q2, double f));
BU_EXTERN(void quat_make_nearest, (quat_t q1, quat_t q2));
BU_EXTERN(void quat_print, (char *title, quat_t quat));
BU_EXTERN(void quat_exp, (quat_t out, quat_t in));
BU_EXTERN(void quat_log, (quat_t out, quat_t in));
d953 3
@


1.34
log
@Moved mathtab/rand_half from rt into libbn
Expanded structparse to include description and default
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.33 1999/10/04 17:57:07 butler Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.33 1999/10/04 17:57:07 butler Exp $ (BRL)"
d881 1
@


1.33
log
@

Added macro for randhalf
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.32 1999/07/02 21:24:43 mike Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.32 1999/07/02 21:24:43 mike Exp $ (BRL)"
d500 1
d502 26
@


1.32
log
@
Eliminated dependence on compat4.h
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.31 1999/07/02 19:12:08 mike Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.31 1999/07/02 19:12:08 mike Exp $ (BRL)"
d494 2
d497 4
@


1.31
log
@
Removed dependency on compat4.h
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.30 1999/07/02 19:04:07 mike Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.30 1999/07/02 19:04:07 mike Exp $ (BRL)"
d225 2
a226 2
#define BN_CK_UNIF(_p) RT_CKMAG(_p, BN_UNIF_MAGIC, "bn_unif")
#define BN_CK_GAUSS(_p) RT_CKMAG(_p, BN_GAUSS_MAGIC, "bn_gauss")
d707 1
a707 1
#define BN_CK_TABLE(_p)	RT_CKMAG(_p, BN_TABLE_MAGIC, "bn_table")
d727 1
a727 1
#define BN_CK_TABDATA(_p)	RT_CKMAG(_p, BN_TABDATA_MAGIC, "bn_tabdata")
@


1.30
log
@
Oops, a symbol didn't get it's prefix converted to BN_!
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.29 1999/05/27 21:51:34 mike Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.29 1999/05/27 21:51:34 mike Exp $ (BRL)"
d869 1
a869 1
			(p)->l.magic = RT_VLIST_MAGIC; \
@


1.29
log
@
Moved librt/font.c to libbn/font.c
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.28 1999/05/27 20:10:32 mike Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.28 1999/05/27 20:10:32 mike Exp $ (BRL)"
d842 2
a843 2
	int		cmd[RT_VLIST_CHUNK];	/* VL_CMD_* */
	point_t		pt[RT_VLIST_CHUNK];	/* associated 3-point/vect */
d886 1
a886 1
	if( BU_LIST_IS_HEAD( _vp, (_dest_hd) ) || _vp->nused >= RT_VLIST_CHUNK )  { \
@


1.28
log
@
Moved vlist and vlblock from raytrace.h to bn.h
(can't be bu.h because it uses vmath.h)
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.27 1999/01/13 08:00:30 butler Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.27 1999/01/13 08:00:30 butler Exp $ (BRL)"
d906 1
d910 9
@


1.27
log
@Merged Chris's name changes and the 2d reconstruction stuff together
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.26 1999/01/12 07:14:42 morrison Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.26 1999/01/12 07:14:42 morrison Exp $ (BRL)"
d810 100
@


1.26
log
@updated the names of the functions to include the _haar for the
wavelet function definitions
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.25 1999/01/12 05:51:17 morrison Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.25 1999/01/12 05:51:17 morrison Exp $ (BRL)"
d500 10
a645 12


#define CK_POW_2(dimen) { register unsigned long j; register int ok; \
                          for (ok=0, j=0 ; j < sizeof(unsigned long) * 8 ; j++) { \
                            if ( (1<<j) == dimen) { ok = 1;  break; } \
                          } \
                          if ( ! ok ) { \
                            bu_log("%s:%d Dimension %d should be power of 2 (%d)\n", \
                                   __FILE__, __LINE__, dimen, j); \
                            bu_bomb("CK_POW_2"); \
                          } \
                        }
@


1.25
log
@modified wavelet info section for bn.h to move a #define from the source
file to the header
@
text
@d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.24 1998/12/11 20:49:25 mike Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.24 1998/12/11 20:49:25 mike Exp $ (BRL)"
d501 1
a501 1
BU_EXTERN(void	bn_wlt_1d_double_decompose, (double *tbuf, double *buf, \
d504 1
a504 1
BU_EXTERN(void	bn_wlt_1d_double_reconstruct, (double *tbuf, double *buf, \
d508 1
a508 1
BU_EXTERN(void	bn_wlt_1d_float_decompose, (float *tbuf, float *buf, \
d511 1
a511 1
BU_EXTERN(void	bn_wlt_1d_float_reconstruct, (float *tbuf, float *buf, \
d515 1
a515 1
BU_EXTERN(void	bn_wlt_1d_char_decompose, (char *tbuf, char *buf, \
d518 1
a518 1
BU_EXTERN(void	bn_wlt_1d_char_reconstruct, (char *tbuf, char *buf, \
d522 1
a522 1
BU_EXTERN(void	bn_wlt_1d_short_decompose, (short *tbuf, short *buf, \
d525 1
a525 1
BU_EXTERN(void	bn_wlt_1d_short_reconstruct, (short *tbuf, short *buf, \
d529 1
a529 1
BU_EXTERN(void	bn_wlt_1d_int_decompose, (int *tbuf, int *buf, \
d532 1
a532 1
BU_EXTERN(void	bn_wlt_1d_int_reconstruct, (int *tbuf, int *buf, \
d536 1
a536 1
BU_EXTERN(void	bn_wlt_1d_long_decompose, (long *tbuf, long *buf, \
d539 1
a539 1
BU_EXTERN(void	bn_wlt_1d_long_reconstruct, (long *tbuf, long *buf, \
d542 94
@


1.24
log
@Oops, got carried away.  It's bu_bomb(), not bn_bomb().
Doesn't show up until you actually use the macro, though. :-(
@
text
@d24 3
d47 1
a47 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.23 1998/12/11 20:40:07 mike Exp $
d56 1
a56 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.23 1998/12/11 20:40:07 mike Exp $ (BRL)"
d501 2
a502 2
BU_EXTERN(void	bn_wlt_1d_double_decompose, (double *tbuf, double *buf,
			unsigned long dimen, unsigned long depth,
d504 2
a505 2
BU_EXTERN(void	bn_wlt_1d_double_reconstruct, (double *tbuf, double *buf, 
			unsigned long dimen, unsigned long depth, 
d508 2
a509 2
BU_EXTERN(void	bn_wlt_1d_float_decompose, (float *tbuf, float *buf,
			unsigned long dimen, unsigned long depth,
d511 2
a512 2
BU_EXTERN(void	bn_wlt_1d_float_reconstruct, (float *tbuf, float *buf, 
			unsigned long dimen, unsigned long depth, 
d515 2
a516 2
BU_EXTERN(void	bn_wlt_1d_char_decompose, (char *tbuf, char *buf,
			unsigned long dimen, unsigned long depth,
d518 2
a519 2
BU_EXTERN(void	bn_wlt_1d_char_reconstruct, (char *tbuf, char *buf, 
			unsigned long dimen, unsigned long depth, 
d522 2
a523 2
BU_EXTERN(void	bn_wlt_1d_short_decompose, (short *tbuf, short *buf,
			unsigned long dimen, unsigned long depth,
d525 2
a526 2
BU_EXTERN(void	bn_wlt_1d_short_reconstruct, (short *tbuf, short *buf, 
			unsigned long dimen, unsigned long depth, 
d529 2
a530 2
BU_EXTERN(void	bn_wlt_1d_int_decompose, (int *tbuf, int *buf,
			unsigned long dimen, unsigned long depth,
d532 2
a533 2
BU_EXTERN(void	bn_wlt_1d_int_reconstruct, (int *tbuf, int *buf, 
			unsigned long dimen, unsigned long depth, 
d536 2
a537 2
BU_EXTERN(void	bn_wlt_1d_long_decompose, (long *tbuf, long *buf,
			unsigned long dimen, unsigned long depth,
d539 2
a540 2
BU_EXTERN(void	bn_wlt_1d_long_reconstruct, (long *tbuf, long *buf, 
			unsigned long dimen, unsigned long depth, 
d542 13
@


1.23
log
@tabdata.c moved from librt to libbn, routine names changed accordingly.
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.22 1998/07/09 05:25:16 butler Exp $
d53 1
a53 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.22 1998/07/09 05:25:16 butler Exp $ (BRL)"
d604 1
a604 1
	if( (_nx) < 1 )  bn_bomb("RT_GET_TABLE() _nx < 1\n"); \
@


1.22
log
@Modifications to BN_RANDOM package to keep idx/seed from overflowing table
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/bn.h,v 1.21 1998/02/12 15:43:20 jra Exp $
d53 1
a53 1
#define BN_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bn.h,v 1.21 1998/02/12 15:43:20 jra Exp $ (BRL)"
d139 3
d426 27
a540 9
/*
 *  Declarations of external functions in LIBBN.
 *  Source file names listed alphabetically.
 */

/* complex.c */
BU_EXTERN(void			bn_cx_div, (bn_complex_t *ap, CONST bn_complex_t *bp) );
BU_EXTERN(void			bn_cx_sqrt, (bn_complex_t *op, CONST bn_complex_t *ip) );

d551 151
a701 27
/* poly.c */
BU_EXTERN(struct bn_poly *	bn_poly_mul, (struct bn_poly *product,
				CONST struct bn_poly *m1, CONST struct bn_poly *m2));
BU_EXTERN(struct bn_poly *	bn_poly_scale, (struct bn_poly *eqn,
				double factor));
BU_EXTERN(struct bn_poly *	bn_poly_add, (struct bn_poly *sum,
				CONST struct bn_poly *poly1, CONST struct bn_poly *poly2));
BU_EXTERN(struct bn_poly *	bn_poly_sub, (struct bn_poly *diff,
				CONST struct bn_poly	*poly1,
				CONST struct bn_poly	*poly2));
BU_EXTERN(void			bn_poly_synthetic_division, (
				struct bn_poly *quo, struct bn_poly *rem,
				CONST struct bn_poly	*dvdend,
				CONST struct bn_poly	*dvsor));
BU_EXTERN(int			bn_poly_quadratic_roots, (
				struct bn_complex	roots[],
				CONST struct bn_poly	*quadrat));
BU_EXTERN(int			bn_poly_cubic_roots, (
				struct bn_complex	roots[],
				CONST struct bn_poly	*eqn));
BU_EXTERN(int			bn_poly_quartic_roots, (
				struct bn_complex	roots[],
				CONST struct bn_poly	*eqn));
BU_EXTERN(void			bn_pr_poly, (CONST char *title,
				CONST struct bn_poly	*eqn));
BU_EXTERN(void			bn_pr_roots, (CONST char *title,
				CONST struct bn_complex	roots[], int n));
d703 1
d706 1
@


1.21
log
@declaration of bn_vec_perp() uses a C++ reserved word.
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/bn.h,v 1.20 1997/11/10 17:32:18 butler Exp jra $
d53 1
a53 1
#define BN_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bn.h,v 1.20 1997/11/10 17:32:18 butler Exp jra $ (BRL)"
d449 1
a449 1
 *	int idx;
d460 1
a460 1
#define BN_RANDSEED( _i, _seed )        _i = _seed % BN_RAND_TABSIZE
@


1.20
log
@added BN_APPROXEQUAL macro
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/bn.h,v 1.19 1997/07/23 07:02:56 gdurf Exp butler $
d53 1
a53 1
#define BN_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bn.h,v 1.19 1997/07/23 07:02:56 gdurf Exp butler $ (BRL)"
d186 1
a186 1
BU_EXTERN(void		bn_vec_perp, (vect_t new, CONST vect_t	old));
@


1.19
log
@Added constants for CLASSIFY and bn_hlf_class extern
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/bn.h,v 1.18 1997/02/10 20:59:24 butler Exp gdurf $
d53 1
a53 1
#define BN_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bn.h,v 1.18 1997/02/10 20:59:24 butler Exp gdurf $ (BRL)"
d99 1
a99 1

@


1.18
log
@oops corrected
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/bn.h,v 1.17 1997/02/10 20:58:43 butler Exp butler $
d53 1
a53 1
#define BN_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bn.h,v 1.17 1997/02/10 20:58:43 butler Exp butler $ (BRL)"
d397 8
a404 3



@


1.17
log
@adde bn_gauss_free() and bn_unif_free()
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/bn.h,v 1.16 1997/01/08 03:41:23 mike Exp butler $
d53 1
a53 1
#define BN_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bn.h,v 1.16 1997/01/08 03:41:23 mike Exp butler $ (BRL)"
d245 1
a245 1
BU_EXTERN(struct bn_unif *	bn_unif_free, (struct bn_unif *p));
d249 1
a249 1
BU_EXTERN(double		bn_gauss_free, (struct bn_gauss *p));
@


1.16
log
@Changed to bn_mat_identity
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/bn.h,v 1.15 1997/01/02 13:24:43 jra Exp mike $
d53 1
a53 1
#define BN_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bn.h,v 1.15 1997/01/02 13:24:43 jra Exp mike $ (BRL)"
d245 1
d249 1
@


1.15
log
@Corrected declaration of bn_matXvec().
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/bn.h,v 1.14 1996/12/31 00:20:31 mike Exp jra $
d53 1
a53 1
#define BN_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bn.h,v 1.14 1996/12/31 00:20:31 mike Exp jra $ (BRL)"
d155 2
a156 2
#define bn_mat_idn( _m )	(void)memcpy( (void *)_m, mat_identity, sizeof(mat_t))
#define bn_mat_copy(_d,_s)	(void)memcpy( (void *)_d, _s, sizeof(mat_t))
@


1.14
log
@Added proper bn_ prefix for all libbn/mat.c routines
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/bn.h,v 1.13 1996/10/02 23:46:23 mike Exp mike $
d53 1
a53 1
#define BN_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bn.h,v 1.13 1996/10/02 23:46:23 mike Exp mike $ (BRL)"
d164 1
a164 1
					register hvect_t iv));
@


1.13
log
@Typo.
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/bn.h,v 1.12 1996/10/02 23:43:27 mike Exp mike $
d53 1
a53 1
#define BN_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bn.h,v 1.12 1996/10/02 23:43:27 mike Exp mike $ (BRL)"
d144 1
d146 2
a147 1
/* XXX Why aren't these bn_mat_whatever ?? */
a148 5
extern CONST mat_t mat_identity;

BU_EXTERN(void		mat_print, (CONST char *title, CONST mat_t m));
BU_EXTERN(double	mat_atan2, (double x, double y));

d150 3
a152 3
BU_EXTERN(void		mat_zero, (mat_t m));
BU_EXTERN(void		mat_idn, (mat_t m));
BU_EXTERN(void		mat_copy, (register mat_t dest,register CONST mat_t src));
d154 3
a156 3
#define	mat_zero( _m )	(void)memset( (void *)_m, 0, sizeof(mat_t))
#define mat_idn( _m )	(void)memcpy( (void *)_m, mat_identity, sizeof(mat_t))
#define mat_copy(_d,_s)	(void)memcpy( (void *)_d, _s, sizeof(mat_t))
d159 1
a159 1
BU_EXTERN(void		mat_mul, (register mat_t o, register CONST mat_t a,
d161 2
a162 2
BU_EXTERN(void		mat_mul2, (register CONST mat_t i, register mat_t o));
BU_EXTERN(void		mat_Xvec, (register hvect_t ov,
d165 2
a166 2
BU_EXTERN(void		mat_inv, (register mat_t output, CONST mat_t input));
BU_EXTERN(void		mat_vtoh_move, (register vect_t h, 
d168 1
a168 1
BU_EXTERN(void		mat_htov_move, (register vect_t v, 
d170 2
a171 2
BU_EXTERN(void		mat_trn, (mat_t om, register CONST mat_t im));
BU_EXTERN(void		mat_ae, (register mat_t	m, double azimuth,
d173 1
a173 1
BU_EXTERN(void		mat_ae_vec, (fastf_t *azp, fastf_t *elp, 
d175 1
a175 1
BU_EXTERN(void 		mat_aet_vec, ( fastf_t *az, fastf_t *el, 
d179 1
a179 1
BU_EXTERN(void		mat_angles, (register mat_t mat, double alpha,
d182 1
a182 1
BU_EXTERN(void		mat_eigen2x2, ( fastf_t	*val1, fastf_t *val2,
d186 2
a187 2
BU_EXTERN(void		mat_vec_perp, (vect_t new, CONST vect_t	old));
BU_EXTERN(void		mat_fromto, ( mat_t m, CONST vect_t from,
d189 5
a193 5
BU_EXTERN(void		mat_xrot, (mat_t m, double sinx, double cosx));
BU_EXTERN(void		mat_yrot, (mat_t m, double siny, double cosy));
BU_EXTERN(void		mat_zrot, (mat_t m, double sinz, double cosz));
BU_EXTERN(void		mat_lookat, (mat_t rot, CONST vect_t dir, int yflip));
BU_EXTERN(void		mat_vec_ortho, (register vect_t out, 
d195 1
a195 1
BU_EXTERN(int		mat_scale_about_pt, (mat_t mat, CONST point_t pt,
d197 1
a197 1
BU_EXTERN(void		mat_xform_about_pt, (mat_t mat, 
d200 2
a201 2
BU_EXTERN(int		mat_is_identity, (CONST mat_t m));
BU_EXTERN(void		mat_arb_rot, ( mat_t m, CONST point_t pt,
d203 2
a204 2
BU_EXTERN(matp_t	mat_dup, (CONST mat_t	in));
BU_EXTERN(int		mat_is_equal, (CONST mat_t a, CONST mat_t b, 
@


1.12
log
@Fixed typo.
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/bn.h,v 1.11 1996/10/02 23:20:24 mike Exp mike $
d53 1
a53 1
#define BN_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bn.h,v 1.11 1996/10/02 23:20:24 mike Exp mike $ (BRL)"
d222 2
a223 2
#define BN_CK_UNIF(_p) RT_CKMAG(_p, BN_UNIF_MAGIC, "msr_unif")
#define BN_CK_GAUSS(_p) RT_CKMAG(_p, BN_GAUSS_MAGIC, "msr_gauss")
@


1.11
log
@Added MSR macros
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/bn.h,v 1.10 1996/09/27 08:17:04 mike Exp $
d53 1
a53 1
#define BN_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bn.h,v 1.10 1996/09/27 08:17:04 mike Exp $ (BRL)"
d278 2
a279 2
	(((_p)->bn_gauss_ptr) ? \
		(_p)->msr_gausses[--(_p)->bn_gauss_ptr] : \
@


1.10
log
@Moved externs for const.c from raytrace.h
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/bn.h,v 1.9 1996/09/20 00:21:46 mike Exp mike $
d53 1
a53 1
#define BN_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bn.h,v 1.9 1996/09/20 00:21:46 mike Exp mike $ (BRL)"
d145 2
d209 73
@


1.9
log
@Type mismatch on plane.c
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/bn.h,v 1.8 1996/09/20 00:19:32 mike Exp mike $
d53 1
a53 1
#define BN_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bn.h,v 1.8 1996/09/20 00:19:32 mike Exp mike $ (BRL)"
d440 10
@


1.8
log
@Fixed ANSI error with bn_noise_vec()
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/bn.h,v 1.7 1996/09/14 03:40:53 butler Exp mike $
d53 1
a53 1
#define BN_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bn.h,v 1.7 1996/09/14 03:40:53 butler Exp mike $ (BRL)"
d239 1
a239 1
				point_t b, point_t p,
@


1.7
log
@tokens for future semaphore support
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/bn.h,v 1.6 1996/09/11 08:43:03 butler Exp butler $
d53 1
a53 1
#define BN_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bn.h,v 1.6 1996/09/11 08:43:03 butler Exp butler $ (BRL)"
d216 2
a217 1
BU_EXTERN(void		bn_noise_vec, (point_t point, point_t result) );
@


1.6
log
@changes to libbn
@
text
@d16 1
d18 1
d44 1
a44 1
 *  $Header: /m/cad/h/RCS/bn.h,v 1.5 1996/08/31 11:03:07 mike Exp butler $
d53 1
a53 3
#define BN_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bn.h,v 1.5 1996/08/31 11:03:07 mike Exp butler $ (BRL)"


d56 1
a56 1
/*			R T _ T O L
d141 3
a143 1

d145 1
d149 2
d153 7
a159 2
BU_EXTERN(void		mat_copy, (register mat_t dest,
					register CONST mat_t src));
d208 13
d223 104
d345 3
d379 1
@


1.5
log
@poly.c
@
text
@d42 1
a42 1
 *  $Header: /m/cad/h/RCS/bn.h,v 1.4 1996/08/31 08:59:58 mike Exp $
d51 1
a51 1
#define BN_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bn.h,v 1.4 1996/08/31 08:59:58 mike Exp $ (BRL)"
d53 48
d140 60
d215 83
@


1.4
log
@placeholder for poly.c
@
text
@d42 1
a42 1
 *  $Header: /m/cad/h/RCS/bn.h,v 1.3 1996/08/31 08:58:45 mike Exp mike $
d51 1
a51 1
#define BN_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bn.h,v 1.3 1996/08/31 08:58:45 mike Exp mike $ (BRL)"
d93 3
d97 10
d117 28
@


1.3
log
@Added complex numbers.
@
text
@d21 1
d42 1
a42 1
 *  $Header: /m/cad/h/RCS/bn.h,v 1.2 1996/08/30 22:47:23 mike Exp mike $
d51 1
a51 1
#define BN_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bn.h,v 1.2 1996/08/30 22:47:23 mike Exp mike $ (BRL)"
d54 1
d90 4
@


1.2
log
@Added bn_version
@
text
@d12 3
a14 1
 *  This header file depends on bu.h and LIBBU
d17 1
a17 1
 *  Author -
d19 2
d41 1
a41 1
 *  $Header: /m/cad/h/RCS/bn.h,v 1.1 1996/08/30 22:45:27 mike Exp mike $
a43 9
#ifndef SEEN_RTLIST_H
# include "rtlist.h"
#endif


#ifndef SEEN_COMPAT4_H
# include "compat4.h"
#endif

d50 1
a50 1
#define BN_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bn.h,v 1.1 1996/08/30 22:45:27 mike Exp mike $ (BRL)"
d52 4
d57 5
d63 26
d94 4
@


1.1
log
@Initial revision
@
text
@d37 1
a37 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.9 1996/08/30 00:13:55 butler Exp mike $
d55 1
a55 1
#define BN_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.9 1996/08/30 00:13:55 butler Exp mike $ (BRL)"
d59 5
d65 2
@
