head	11.14;
access;
symbols
	ansi-20040405-merged:11.12.4.1
	postmerge-20040405-ansi:11.13
	premerge-20040404-ansi:11.12
	postmerge-autoconf:11.12
	autoconf-freeze:11.12
	premerge-autoconf:11.12
	ansi-20040316-freeze:11.12
	postmerge-20040315-windows:11.12
	premerge-20040315-windows:11.12
	windows-20040315-freeze:11.12
	autoconf-20031203:11.12
	autoconf-20031202:11.12
	autoconf-branch:11.12.0.12
	phong-branch:11.12.0.10
	photonmap-branch:11.12.0.8
	rel-6-1-DP:11.12
	windows-branch:11.12.0.6
	rel-6-0-2:11.12
	ansi-branch:11.12.0.4
	rel-6-0-1-branch:11.12.0.2
	hartley-6-0-post:11.12
	hartley-6-0-pre:11.12
	rel-6-0-1:11.12
	rel-6-0:11.12
	rel-5-4:11.11
	offsite-5-3-pre:11.11
	rel-5-3:11.11
	rel-5-2:11.11
	rel-5-1-branch:11.11.0.2
	rel-5-1:11.11
	rel-5-0:11.11
	rel-5-0-beta:11.10
	rel-4-5:11.10
	ctj-4-5-post:11.10
	ctj-4-5-pre:11.10
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.14
date	2004.05.24.04.11.52;	author morrison;	state dead;
branches;
next	11.13;

11.13
date	2004.04.05.09.31.17;	author morrison;	state Exp;
branches;
next	11.12;

11.12
date	2001.04.05.19.35.07;	author morrison;	state Exp;
branches
	11.12.4.1;
next	11.11;

11.11
date	99.06.03.02.16.16;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	97.07.15.19.50.06;	author gdurf;	state Exp;
branches;
next	11.9;

11.9
date	96.09.20.00.26.47;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	96.08.28.05.41.06;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	96.05.10.18.34.36;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	95.12.02.03.01.35;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	95.12.01.02.41.17;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.11.29.23.49.47;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.11.29.23.48.56;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.02.16.03.45.09;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.48.25;	author mike;	state Rel4_4;
branches;
next	10.51;

10.51
date	94.12.28.21.17.15;	author butler;	state Exp;
branches;
next	10.50;

10.50
date	94.12.23.18.51.21;	author mike;	state Exp;
branches;
next	10.49;

10.49
date	94.12.05.19.05.19;	author butler;	state Exp;
branches;
next	10.48;

10.48
date	94.09.21.03.49.26;	author mike;	state Exp;
branches;
next	10.47;

10.47
date	94.09.21.03.31.51;	author mike;	state Exp;
branches;
next	10.46;

10.46
date	94.09.21.00.08.28;	author mike;	state Exp;
branches;
next	10.45;

10.45
date	94.09.16.20.43.38;	author mike;	state Exp;
branches;
next	10.44;

10.44
date	94.09.16.19.42.40;	author mike;	state Exp;
branches;
next	10.43;

10.43
date	94.09.16.19.31.41;	author mike;	state Exp;
branches;
next	10.42;

10.42
date	94.09.10.04.35.29;	author mike;	state Exp;
branches;
next	10.41;

10.41
date	94.09.03.03.02.02;	author mike;	state Exp;
branches;
next	10.40;

10.40
date	94.09.02.19.06.58;	author mike;	state Exp;
branches;
next	10.39;

10.39
date	94.09.02.18.00.41;	author mike;	state Exp;
branches;
next	10.38;

10.38
date	94.09.02.01.13.54;	author mike;	state Exp;
branches;
next	10.37;

10.37
date	94.09.02.00.41.02;	author mike;	state Exp;
branches;
next	10.36;

10.36
date	94.08.31.04.13.32;	author mike;	state Exp;
branches;
next	10.35;

10.35
date	94.08.31.04.11.36;	author mike;	state Exp;
branches;
next	10.34;

10.34
date	94.08.27.04.34.33;	author mike;	state Exp;
branches;
next	10.33;

10.33
date	94.08.27.01.33.17;	author mike;	state Exp;
branches;
next	10.32;

10.32
date	94.08.22.20.08.26;	author butler;	state Exp;
branches;
next	10.31;

10.31
date	94.08.22.19.43.32;	author butler;	state Exp;
branches;
next	10.30;

10.30
date	94.05.24.17.27.35;	author butler;	state Exp;
branches;
next	10.29;

10.29
date	94.04.20.20.41.52;	author mike;	state Exp;
branches;
next	10.28;

10.28
date	94.03.18.18.35.32;	author butler;	state Exp;
branches;
next	10.27;

10.27
date	94.01.14.03.11.00;	author mike;	state Exp;
branches;
next	10.26;

10.26
date	94.01.14.02.32.23;	author mike;	state Exp;
branches;
next	10.25;

10.25
date	94.01.06.19.15.46;	author butler;	state Exp;
branches;
next	10.24;

10.24
date	93.12.27.22.46.05;	author mike;	state Exp;
branches;
next	10.23;

10.23
date	93.12.23.05.37.02;	author mike;	state Exp;
branches;
next	10.22;

10.22
date	93.12.10.05.15.03;	author mike;	state Exp;
branches;
next	10.21;

10.21
date	93.12.06.21.36.02;	author mike;	state Exp;
branches;
next	10.20;

10.20
date	93.12.03.03.35.58;	author mike;	state Exp;
branches;
next	10.19;

10.19
date	93.11.18.01.36.53;	author mike;	state Exp;
branches;
next	10.18;

10.18
date	93.10.02.01.07.57;	author butler;	state Exp;
branches;
next	10.17;

10.17
date	93.09.01.16.32.34;	author butler;	state Exp;
branches;
next	10.16;

10.16
date	93.07.20.15.23.35;	author mike;	state Exp;
branches;
next	10.15;

10.15
date	93.07.20.15.20.01;	author mike;	state Exp;
branches;
next	10.14;

10.14
date	93.06.04.16.32.13;	author butler;	state Exp;
branches;
next	10.13;

10.13
date	93.05.15.00.00.56;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	93.04.07.06.14.47;	author mike;	state Exp;
branches;
next	10.11;

10.11
date	93.04.03.01.12.14;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	93.04.02.02.59.10;	author butler;	state Exp;
branches;
next	10.9;

10.9
date	93.04.01.05.11.12;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	93.03.23.21.37.14;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	93.03.03.01.47.55;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	93.03.02.22.13.02;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	93.02.19.02.00.44;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.10.06.23.11.12;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.07.23.04.56.59;	author butler;	state Exp;
branches;
next	10.2;

10.2
date	92.06.01.16.20.27;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.35.24;	author mike;	state Rel4_0;
branches;
next	1.50;

1.50
date	91.06.22.20.09.09;	author butler;	state Exp;
branches;
next	1.49;

1.49
date	91.06.14.04.31.52;	author butler;	state Exp;
branches;
next	1.48;

1.48
date	91.06.12.20.59.57;	author mike;	state Exp;
branches;
next	1.47;

1.47
date	91.06.12.20.37.23;	author mike;	state Exp;
branches;
next	1.46;

1.46
date	91.06.12.20.29.51;	author butler;	state Exp;
branches;
next	1.45;

1.45
date	91.06.03.19.24.51;	author mike;	state Exp;
branches;
next	1.44;

1.44
date	91.05.25.03.26.43;	author mike;	state Exp;
branches;
next	1.43;

1.43
date	91.05.22.23.50.40;	author mike;	state Exp;
branches;
next	1.42;

1.42
date	91.05.18.02.43.50;	author mike;	state Exp;
branches;
next	1.41;

1.41
date	91.05.17.19.49.41;	author butler;	state Exp;
branches;
next	1.40;

1.40
date	91.03.28.01.00.45;	author mike;	state Exp;
branches;
next	1.39;

1.39
date	91.03.28.00.16.34;	author mike;	state Exp;
branches;
next	1.38;

1.38
date	91.03.02.00.17.00;	author mike;	state Exp;
branches;
next	1.37;

1.37
date	91.03.01.22.41.24;	author mike;	state Exp;
branches;
next	1.36;

1.36
date	91.03.01.19.46.57;	author mike;	state Exp;
branches;
next	1.35;

1.35
date	91.02.08.02.50.10;	author mike;	state Exp;
branches;
next	1.34;

1.34
date	91.02.07.21.15.25;	author mike;	state Exp;
branches;
next	1.33;

1.33
date	91.02.07.20.31.20;	author mike;	state Exp;
branches;
next	1.32;

1.32
date	91.02.07.19.40.50;	author mike;	state Exp;
branches;
next	1.31;

1.31
date	91.02.07.00.13.08;	author mike;	state Exp;
branches;
next	1.30;

1.30
date	91.01.12.07.26.27;	author mike;	state Exp;
branches;
next	1.29;

1.29
date	90.12.10.17.19.03;	author cjohnson;	state Exp;
branches;
next	1.28;

1.28
date	90.12.08.03.00.18;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	90.10.05.23.22.26;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	90.06.29.06.58.20;	author butler;	state Exp;
branches;
next	1.25;

1.25
date	90.05.31.00.11.10;	author butler;	state Exp;
branches;
next	1.24;

1.24
date	90.05.25.01.27.22;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	90.05.24.23.21.53;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	90.05.24.20.05.44;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	90.05.24.19.00.55;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	90.05.24.18.14.32;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	90.05.24.02.13.49;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	90.05.23.21.48.35;	author butler;	state Exp;
branches;
next	1.17;

1.17
date	90.05.23.20.53.10;	author butler;	state Exp;
branches;
next	1.16;

1.16
date	90.05.23.00.25.28;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	90.05.23.00.23.27;	author butler;	state Exp;
branches;
next	1.14;

1.14
date	90.05.21.11.51.15;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	90.05.18.07.04.38;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	90.05.18.03.43.43;	author butler;	state Exp;
branches;
next	1.11;

1.11
date	90.05.18.03.04.24;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	90.05.18.02.59.09;	author butler;	state Exp;
branches;
next	1.9;

1.9
date	90.05.13.09.00.19;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	90.05.12.09.12.16;	author butler;	state Exp;
branches;
next	1.7;

1.7
date	90.05.09.01.06.16;	author butler;	state Exp;
branches;
next	1.6;

1.6
date	90.03.14.22.38.20;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	90.02.27.20.52.08;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	89.12.29.21.46.41;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	89.12.22.03.16.57;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	89.12.09.02.28.08;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	89.10.10.15.48.42;	author mike;	state Exp;
branches;
next	;

11.12.4.1
date	2004.04.04.20.59.05;	author morrison;	state Exp;
branches;
next	;


desc
@Non-Manifold Geometry data structures
@


11.14
log
@moved/renamed from top-level h/ to top-level include/
@
text
@/*
 *			N M G . H
 *
 *  Authors -
 *	Lee A. Butler
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimitied.
 *
 *  Definition of data structures for "Non-Manifold Geometry Modelling."
 *  Developed from "Non-Manifold Geometric Boundary Modeling" by 
 *  Kevin Weiler, 5/7/87 (SIGGraph 1989 Course #20 Notes)
 *
 *  Include Sequencing -
 *	#include <stdio.h>
 *	#include <math.h>
 *	#include "machine.h"	/_* For fastf_t definition on this machine *_/
 *	#include "vmath.h"	/_* For vect_t definition *_/
 *	#include "rtlist.h"	/_* OPTIONAL, auto-included by raytrace.h *_/
 *	#include "rtstring.h"	/_* OPTIONAL, auto-included by raytrace.h *_/
 *	#include "nmg.h"
 *	#include "raytrace.h"
 *	#include "nurb.h"	/_* OPTIONAL, follows raytrace.h when used *_/
 *
 *  Libraries Used -
 *	LIBRT LIBRT_LIBES -lm -lc
 *
 *  $Header: /n/xoff/cvs/brlcad/h/nmg.h,v 11.13 2004/04/05 09:31:17 morrison Exp $
 */
#ifndef NMG_H
#define NMG_H seen

/* make sure all the prerequisite include files have been included
 */
#ifndef MACHINE_H
#include "machine.h"
#endif

#ifndef VMATH_H
#include "vmath.h"
#endif

#ifndef SEEN_RTLIST_H
#include "rtlist.h"
#endif

#ifndef SEEN_COMPAT4_H
#include "compat4.h"
#endif

#ifndef SEEN_BU_H
#include "bu.h"
#endif

#ifndef NULL
#define NULL 0
#endif

#define	NMG_EXTERN(type_and_name,args)	RT_EXTERN(type_and_name,args)


#define DEBUG_PL_ANIM	0x00000001	/* 1 mged: animated evaluation */
#define DEBUG_PL_SLOW	0x00000002	/* 2 mged: add delays to animation */
#define DEBUG_GRAPHCL	0x00000004	/* 3 mged: graphic classification */
#define DEBUG_PL_LOOP	0x00000008	/* 4 loop class (needs GRAPHCL) */
#define DEBUG_PLOTEM	0x00000010	/* 5 make plots in debugged routines (needs other flags set too) */
#define DEBUG_POLYSECT	0x00000020	/* 6 nmg_inter: face intersection */
#define DEBUG_VERIFY	0x00000040	/* 7 nmg_vshell() frequently, verify health */
#define DEBUG_BOOL	0x00000080	/* 8 nmg_bool:  */
#define DEBUG_CLASSIFY	0x00000100	/* 9 nmg_class: */
#define DEBUG_BOOLEVAL	0x00000200	/* 10 nmg_eval: what to retain */
#define DEBUG_BASIC	0x00000400	/* 013 nmg_mk.c and nmg_mod.c routines */
#define DEBUG_MESH	0x00000800	/* 12 nmg_mesh: describe edge search */
#define DEBUG_MESH_EU	0x00001000	/* 13 nmg_mesh: list edges meshed */
#define DEBUG_POLYTO	0x00002000	/* 14 nmg_misc: polytonmg */
#define DEBUG_LABEL_PTS 0x00004000	/* 15 label points in plot files */
/***#define DEBUG_INS	0x00008000	/_* 16 bu_ptbl table insert */
#define DEBUG_NMGRT	0x00010000	/* 17 ray tracing */
#define DEBUG_FINDEU	0x00020000	/* 18 nmg_mod: nmg_findeu() */
#define DEBUG_CMFACE	0x00040000	/* 19 nmg_mod: nmg_cmface() */
#define DEBUG_CUTLOOP	0x00080000	/* 024 nmg_mod: nmg_cut_loop */
#define DEBUG_VU_SORT	0x00100000	/* 025 nmg_fcut: coincident vu sort */
#define DEBUG_FCUT	0x00200000	/* 026 nmg_fcut: face cutter */
#define DEBUG_RT_SEGS	0x00400000	/* 027 nmg_rt_segs: */
#define DEBUG_RT_ISECT	0x00800000	/* 028 nmg_rt_isect: */
#define DEBUG_TRI	0x01000000	/* 029 nmg_tri */
#define DEBUG_PT_FU	0x02000000	/* 029 nmg_pt_fu */
#define DEBUG_MANIF	0x04000000	/* 029 nmg_manif */
#define NMG_DEBUG_FORMAT \
"\020\033MANIF\032PTFU\031TRIANG\030RT_ISECT\
\027RT_SEGS\026FCUT\025VU_SORT\024CUTLOOP\023CMFACE\022FINDEU\021RT_ISECT\020(FREE)\
\017LABEL_PTS\016POLYTO\015MESH_EU\014MESH\013BASIC\012BOOLEVAL\011CLASSIFY\
\010BOOL\7VERIFY\6POLYSECT\5PLOTEM\4PL_LOOP\3GRAPHCL\2PL_SLOW\1PL_ANIM"

/*
 *  Macros for providing function prototypes, regardless of whether
 *  the compiler understands them or not.
 *  It is vital that the argument list given for "args" be enclosed
 *  in parens.
 *  The setting of USE_PROTOTYPES is done in machine.h
 */
#if USE_PROTOTYPES
#	define	NMG_ARGS(args)			args
#else
#	define	NMG_ARGS(args)			()
#endif

/* Boolean operations */
#define NMG_BOOL_SUB 1		/* subtraction */
#define NMG_BOOL_ADD 2		/* addition/union */
#define NMG_BOOL_ISECT 4	/* intsersection */

/* Boolean classifications */
#define NMG_CLASS_Unknown	-1
#define NMG_CLASS_AinB		0
#define NMG_CLASS_AonBshared	1
#define NMG_CLASS_AonBanti	2
#define NMG_CLASS_AoutB		3
#define NMG_CLASS_BinA		4
#define NMG_CLASS_BonAshared	5
#define NMG_CLASS_BonAanti	6
#define NMG_CLASS_BoutA		7

/* orientations available.  All topological elements are orientable. */
#define OT_NONE     0    /* no orientation (error) */
#define OT_SAME     1    /* orientation same */
#define OT_OPPOSITE 2    /* orientation opposite */
#define OT_UNSPEC   3    /* orientation unspecified */
#define OT_BOOLPLACE 4   /* object is intermediate data for boolean ops */

/*
 *  Magic Numbers.
 */
#define NMG_MODEL_MAGIC 	0x12121212
#define NMG_REGION_MAGIC	0x23232323
#define NMG_REGION_A_MAGIC	0x696e6720
#define NMG_SHELL_MAGIC 	0x71077345	/* shell oil */
#define NMG_SHELL_A_MAGIC	0x65207761
#define NMG_FACE_MAGIC		0x45454545
#define NMG_FACE_G_PLANE_MAGIC	0x726b6e65
#define NMG_FACE_G_SNURB_MAGIC	0x736e7262	/* was RT_SNURB_MAGIC */
#define NMG_FACEUSE_MAGIC	0x56565656
#define NMG_LOOP_MAGIC		0x67676767
#define NMG_LOOP_G_MAGIC	0x6420224c
#define NMG_LOOPUSE_MAGIC	0x78787878
#define NMG_EDGE_MAGIC		0x33333333
#define NMG_EDGE_G_LSEG_MAGIC	0x6c696768
#define NMG_EDGE_G_CNURB_MAGIC	0x636e7262	/* was RT_CNURB_MAGIC */
#define NMG_EDGEUSE_MAGIC	0x90909090
#define NMG_EDGEUSE2_MAGIC	0x91919191	/* used in eu->l2.magic */
#define NMG_VERTEX_MAGIC	0x00123123
#define NMG_VERTEX_G_MAGIC	0x72737707
#define NMG_VERTEXUSE_MAGIC	0x12341234
#define NMG_VERTEXUSE_A_PLANE_MAGIC	0x69676874
#define NMG_VERTEXUSE_A_CNURB_MAGIC	0x20416e64
#define NMG_KNOT_VECTOR_MAGIC	0x6b6e6f74	/* aka RT_KNOT_VECTOR_MAGIC */

/* macros to check/validate a structure pointer
 */
#define NMG_CKMAG(_ptr, _magic, _str)	BU_CKMAG(_ptr,_magic,_str)
#define NMG_CK2MAG(_ptr, _magic1, _magic2, _str)	\
	if( !(_ptr) || (*((long *)(_ptr)) != (_magic1) && *((long *)(_ptr)) != (_magic2) ) )  { \
		bu_badmagic( (long *)(_ptr), _magic1, _str, __FILE__, __LINE__ ); \
	}

#define NMG_CK_MODEL(_p)	NMG_CKMAG(_p, NMG_MODEL_MAGIC, "model")
#define NMG_CK_REGION(_p)	NMG_CKMAG(_p, NMG_REGION_MAGIC, "region")
#define NMG_CK_REGION_A(_p)	NMG_CKMAG(_p, NMG_REGION_A_MAGIC, "region_a")
#define NMG_CK_SHELL(_p)	NMG_CKMAG(_p, NMG_SHELL_MAGIC, "shell")
#define NMG_CK_SHELL_A(_p)	NMG_CKMAG(_p, NMG_SHELL_A_MAGIC, "shell_a")
#define NMG_CK_FACE(_p)		NMG_CKMAG(_p, NMG_FACE_MAGIC, "face")
#define NMG_CK_FACE_G_PLANE(_p)	NMG_CKMAG(_p, NMG_FACE_G_PLANE_MAGIC, "face_g_plane")
#define NMG_CK_FACE_G_SNURB(_p)	NMG_CKMAG(_p, NMG_FACE_G_SNURB_MAGIC, "face_g_snurb")
#define NMG_CK_FACE_G_EITHER(_p)	NMG_CK2MAG(_p, NMG_FACE_G_PLANE_MAGIC, NMG_FACE_G_SNURB_MAGIC, "face_g_plane|face_g_snurb")
#define NMG_CK_FACEUSE(_p)	NMG_CKMAG(_p, NMG_FACEUSE_MAGIC, "faceuse")
#define NMG_CK_LOOP(_p)		NMG_CKMAG(_p, NMG_LOOP_MAGIC, "loop")
#define NMG_CK_LOOP_G(_p)	NMG_CKMAG(_p, NMG_LOOP_G_MAGIC, "loop_g")
#define NMG_CK_LOOPUSE(_p)	NMG_CKMAG(_p, NMG_LOOPUSE_MAGIC, "loopuse")
#define NMG_CK_EDGE(_p)		NMG_CKMAG(_p, NMG_EDGE_MAGIC, "edge")
#define NMG_CK_EDGE_G_LSEG(_p)	NMG_CKMAG(_p, NMG_EDGE_G_LSEG_MAGIC, "edge_g_lseg")
#define NMG_CK_EDGE_G_CNURB(_p)	NMG_CKMAG(_p, NMG_EDGE_G_CNURB_MAGIC, "edge_g_cnurb")
#define NMG_CK_EDGE_G_EITHER(_p)	NMG_CK2MAG(_p, NMG_EDGE_G_LSEG_MAGIC, NMG_EDGE_G_CNURB_MAGIC, "edge_g_lseg|edge_g_cnurb")
#define NMG_CK_EDGEUSE(_p)	NMG_CKMAG(_p, NMG_EDGEUSE_MAGIC, "edgeuse")
#define NMG_CK_VERTEX(_p)	NMG_CKMAG(_p, NMG_VERTEX_MAGIC, "vertex")
#define NMG_CK_VERTEX_G(_p)	NMG_CKMAG(_p, NMG_VERTEX_G_MAGIC, "vertex_g")
#define NMG_CK_VERTEXUSE(_p)	NMG_CKMAG(_p, NMG_VERTEXUSE_MAGIC, "vertexuse")
#define NMG_CK_VERTEXUSE_A_PLANE(_p)	NMG_CKMAG(_p, NMG_VERTEXUSE_A_PLANE_MAGIC, "vertexuse_a_plane")
#define NMG_CK_VERTEXUSE_A_CNURB(_p)	NMG_CKMAG(_p, NMG_VERTEXUSE_A_CNURB_MAGIC, "vertexuse_a_cnurb")
#define NMG_CK_VERTEXUSE_A_EITHER(_p)	NMG_CK2MAG(_p, NMG_VERTEXUSE_A_PLANE_MAGIC, NMG_VERTEXUSE_A_CNURB_MAGIC, "vertexuse_a_plane|vertexuse_a_cnurb")
#define NMG_CK_LIST(_p)		BU_CKMAG(_p, BU_LIST_HEAD_MAGIC, "bu_list")

/* Used only in nmg_mod.c */
#define NMG_TEST_EDGEUSE(_p) \
	if (!(_p)->l.forw || !(_p)->l.back || !(_p)->eumate_p || \
	    !(_p)->radial_p || !(_p)->e_p || !(_p)->vu_p || \
	    !(_p)->up.magic_p ) { \
		bu_log("in %s at %d Bad edgeuse member pointer\n",\
			 __FILE__, __LINE__);  nmg_pr_eu(_p, (char *)NULL); \
			rt_bomb("Null pointer\n"); \
	} else if ((_p)->vu_p->up.eu_p != (_p) || \
	(_p)->eumate_p->vu_p->up.eu_p != (_p)->eumate_p) {\
	    	bu_log("in %s at %d edgeuse lost vertexuse\n",\
	    		 __FILE__, __LINE__); rt_bomb("bye");}

/*
 *			K N O T _ V E C T O R
 *
 *  Definition of a knot vector.
 *  Not found independently, but used in the cnurb and snurb structures.
 *  (Exactly the same as the definition in nurb.h)
 */
struct knot_vector {
	int		magic;
	int		k_size;		/* knot vector size */
	fastf_t		* knots;	/* pointer to knot vector  */
};
#define RT_KNOT_VECTOR_MAGIC	NMG_KNOT_VECTOR_MAGIC	/* nurb.h compat */

/*
 *	N O T I C E !
 *
 *	We rely on the fact that the first long in a struct is the magic
 *	number (which is used to identify the struct type).
 *	This may be either a long, or an rt_list structure, which
 *	starts with a magic number.
 *
 *	To these ends, there is a standard ordering for fields in "object-use"
 *	structures.  That ordering is:
 *		1) magic number, or rt_list structure
 *		2) pointer to parent
 *		5) pointer to mate
 *		6) pointer to geometry
 *		7) pointer to attributes
 *		8) pointer to child(ren)
 */


/*
 *			M O D E L
 */
struct model {
	long			magic;
	struct bu_list		r_hd;	/* list of regions */
	long			index;	/* struct # in this model */
	long			maxindex; /* # of structs so far */
};

/*
 *			R E G I O N
 */
struct nmgregion {
	struct bu_list		l;	/* regions, in model's r_hd list */
	struct model   		*m_p;	/* owning model */
	struct nmgregion_a	*ra_p;	/* attributes */
	struct bu_list		s_hd;	/* list of shells in region */
	long			index;	/* struct # in this model */
};

struct nmgregion_a {
	long			magic;
	point_t			min_pt;	/* minimums of bounding box */
	point_t			max_pt;	/* maximums of bounding box */
	long			index;	/* struct # in this model */
};

/*
 *			S H E L L
 *
 *  When a shell encloses volume, it's done entirely by the list of faceuses.
 *
 *  The wire loopuses (each of which heads a list of edges) define a
 *  set of connected line segments which form a closed path, but do not
 *  enclose either volume or surface area.
 *
 *  The wire edgeuses are disconnected line segments.
 *  There is a special interpetation to the eu_hd list of wire edgeuses.
 *  Unlike edgeuses seen in loops, the eu_hd list contains eu1, eu1mate,
 *  eu2, eu2mate, ..., where each edgeuse and it's mate comprise a
 *  *non-connected* "wire" edge which starts at eu1->vu_p->v_p and ends
 *  at eu1mate->vu_p->v_p.  There is no relationship between the pairs
 *  of edgeuses at all, other than that they all live on the same linked
 *  list.
 */
struct shell {
	struct bu_list		l;	/* shells, in region's s_hd list */
	struct nmgregion	*r_p;	/* owning region */
	struct shell_a		*sa_p;	/* attribs */

	struct bu_list		fu_hd;	/* list of face uses in shell */
	struct bu_list		lu_hd;	/* wire loopuses (edge groups) */
	struct bu_list		eu_hd;	/* wire list (shell has wires) */
	struct vertexuse	*vu_p;	/* internal ptr to single vertexuse */
	long			index;	/* struct # in this model */
};

struct shell_a {
	long			magic;
	point_t			min_pt;	/* minimums of bounding box */
	point_t			max_pt;	/* maximums of bounding box */
	long			index;	/* struct # in this model */
};

/*
 *			F A C E
 *
 *  Note: there will always be exactly two faceuse's using a face.
 *  To find them, go up fu_p for one, then across fumate_p to other.
 */
struct face {
	struct bu_list		l;	/* faces in face_g's f_hd list */
	struct faceuse		*fu_p;	/* Ptr up to one use of this face */
	union {
		long		    *magic_p;	
		struct face_g_plane *plane_p;
		struct face_g_snurb *snurb_p;
	} g;				/* geometry */
	int			flip;	/* !0 ==> flip normal of fg */
	/* These might be better stored in a face_a (not faceuse_a!) */
	/* These are not stored on disk */
	point_t			min_pt;	/* minimums of bounding box */
	point_t			max_pt;	/* maximums of bounding box */
	long			index;	/* struct # in this model */
};

struct face_g_plane {
	long			magic;
	struct bu_list		f_hd;	/* list of faces sharing this surface */
	plane_t			N;	/* Plane equation (incl normal) */
	long			index;	/* struct # in this model */
};

struct face_g_snurb {
	/* NOTICE:  l.forw & l.back *not* stored in database.  For LIBNURB internal use only. */
	struct bu_list		l;
	struct bu_list		f_hd;	/* list of faces sharing this surface */
	int			order[2]; /* surface order [0] = u, [1] = v */
	struct knot_vector	u;	/* surface knot vectors */
	struct knot_vector	v;	/* surface knot vectors */
	/* surface control points */
	int			s_size[2]; /* mesh size, u,v */
	int			pt_type; /* surface point type */
	fastf_t			*ctl_points; /* array [size[0]*size[1]] */
	/* START OF ITEMS VALID IN-MEMORY ONLY -- NOT STORED ON DISK */
	int			dir;	/* direction of last refinement */
	point_t			min_pt;	/* min corner of bounding box */
	point_t			max_pt;	/* max corner of bounding box */
	/*   END OF ITEMS VALID IN-MEMORY ONLY -- NOT STORED ON DISK */
	long			index;	/* struct # in this model */
};

struct faceuse {
	struct bu_list		l;	/* fu's, in shell's fu_hd list */
	struct shell		*s_p;	/* owning shell */
	struct faceuse		*fumate_p;    /* opposite side of face */
	int			orientation;  /* rel to face geom defn */
	int			outside; /* RESERVED for future:  See Lee Butler */
	struct face		*f_p;	/* face definition and attributes */
	struct bu_list		lu_hd;	/* list of loops in face-use */
	long			index;	/* struct # in this model */
};

/* Returns a 3-tuple (vect_t), given faceuse and state of flip flags */
#define NMG_GET_FU_NORMAL(_N, _fu)	{ \
	register const struct faceuse	*_fu1 = (_fu); \
	register const struct face_g_plane	*_fg; \
	NMG_CK_FACEUSE(_fu1); \
	NMG_CK_FACE(_fu1->f_p); \
	_fg = _fu1->f_p->g.plane_p; \
	NMG_CK_FACE_G_PLANE(_fg); \
	if( (_fu1->orientation != OT_SAME) != (_fu1->f_p->flip != 0) )  { \
		VREVERSE( _N, _fg->N); \
	} else { \
		VMOVE( _N, _fg->N ); \
	} }

/* Returns a 4-tuple (plane_t), given faceuse and state of flip flags */
#define NMG_GET_FU_PLANE(_N, _fu)	{ \
	register const struct faceuse	*_fu1 = (_fu); \
	register const struct face_g_plane	*_fg; \
	NMG_CK_FACEUSE(_fu1); \
	NMG_CK_FACE(_fu1->f_p); \
	_fg = _fu1->f_p->g.plane_p; \
	NMG_CK_FACE_G_PLANE(_fg); \
	if( (_fu1->orientation != OT_SAME) != (_fu1->f_p->flip != 0) )  { \
		HREVERSE( _N, _fg->N); \
	} else { \
		HMOVE( _N, _fg->N ); \
	} }

/*
 *			L O O P
 *
 *  To find all the uses of this loop, use lu_p for one loopuse,
 *  then go down and find an edge,
 *  then wander around either eumate_p or radial_p from there.
 *
 *  Normally, down_hd heads a doubly linked list of edgeuses.
 *  But, before using it, check BU_LIST_FIRST_MAGIC(&lu->down_hd)
 *  for the magic number type.
 *  If this is a self-loop on a single vertexuse, then get the vertex pointer
 *  with vu = BU_LIST_FIRST(vertexuse, &lu->down_hd)
 *
 *  This is an especially dangerous storage efficiency measure ("hack"),
 *  because the list that the vertexuse structure belongs to is headed,
 *  not by a superior element type, but by the vertex structure.
 *  When a loopuse needs to point down to a vertexuse, rip off the
 *  forw pointer.  Take careful note that this is just a pointer,
 *  **not** the head of a linked list (single, double, or otherwise)!
 *  Exercise great care!
 *
 *  The edges of an exterior (OT_SAME) loop occur in counter-clockwise
 *  order, as viewed from the normalward side (outside).
 */
#define RT_LIST_SET_DOWN_TO_VERT(_hp,_vu)	{ \
	(_hp)->forw = &((_vu)->l); (_hp)->back = (struct bu_list *)NULL; }

struct loop {
	long			magic;
	struct loopuse		*lu_p;	/* Ptr to one use of this loop */
	struct loop_g		*lg_p;  /* Geometry */
	long			index;	/* struct # in this model */
};

struct loop_g {
	long			magic;
	point_t			min_pt;	/* minimums of bounding box */
	point_t			max_pt;	/* maximums of bounding box */
	long			index;	/* struct # in this model */
};

struct loopuse {
	struct bu_list		l;	/* lu's, in fu's lu_hd, or shell's lu_hd */
	union {
		struct faceuse  *fu_p;	/* owning face-use */
		struct shell	*s_p;
		long		*magic_p;
	} up;
	struct loopuse		*lumate_p; /* loopuse on other side of face */
	int			orientation;  /* OT_SAME=outside loop */
	struct loop		*l_p;	/* loop definition and attributes */
	struct bu_list		down_hd; /* eu list or vu pointer */
	long			index;	/* struct # in this model */
};

/*
 *			E D G E
 *
 *  To find all edgeuses of an edge, use eu_p to get an arbitrary edgeuse,
 *  then wander around either eumate_p or radial_p from there.
 *
 *  Only the first vertex of an edge is kept in an edgeuse (eu->vu_p).
 *  The other vertex can be found by either eu->eumate_p->vu_p or
 *  by BU_LIST_PNEXT_CIRC(edgeuse,eu)->vu_p.  Note that the first
 *  form gives a vertexuse in the faceuse of *opposite* orientation,
 *  while the second form gives a vertexuse in the faceuse of the correct
 *  orientation.  If going on to the vertex (vu_p->v_p), both forms
 *  are identical.
 *
 *  An edge_g_lseg structure represents a line in 3-space.  All edges on that
 *  line should share the same edge_g.
 *
 *  An edge occupies the range eu->param to eu->eumate_p->param in it's
 *  geometry's parameter space.  (cnurbs only)
 */
struct edge {
	long			magic;
	struct edgeuse		*eu_p;	/* Ptr to one use of this edge */
	long			is_real;/* artifact or modeled edge (from tessellator) */
	long			index;	/* struct # in this model */
};

/*
 *  IMPORTANT:  First two items in edge_g_lseg and edge_g_cnurb must be
 *  identical structure, so pointers are puns for both.
 *  eu_hd2 list must be in same place for both.
 */
struct edge_g_lseg {
	struct bu_list		l;	/* NOTICE:  l.forw & l.back *not* stored in database.  For alignment only. */
	struct bu_list		eu_hd2;	/* heads l2 list of edgeuses on this line */
	point_t			e_pt;	/* parametric equation of the line */
	vect_t			e_dir;
	long			index;	/* struct # in this model */
};

/*
 *  The ctl_points on this curve are (u,v) values on the face's surface.
 *  As a storage and performance efficiency measure, if order <= 0,
 *  then the cnurb is a straight line segment in parameter space,
 *  and the k.knots and ctl_points pointers will be NULL.
 *  In this case, the vertexuse_a_cnurb's at both ends of the edgeuse define
 *  the path through parameter space.
 */
struct edge_g_cnurb {
	struct bu_list		l;	/* NOTICE:  l.forw & l.back *not* stored in database.  For LIBNURB internal use only. */
	struct bu_list		eu_hd2;	/* heads l2 list of edgeuses on this curve */
	int			order;	/* Curve Order */
	struct knot_vector	k;	/* curve knot vector */
	/* curve control polygon */
	int			c_size;	/* number of ctl points */
	int			pt_type;/* curve point type */
	fastf_t			*ctl_points; /* array [c_size] */
	long			index;	/* struct # in this model */
};

struct edgeuse {
	struct bu_list		l;	/* cw/ccw edges in loop or wire edges in shell */
	struct bu_list		l2;	/* member of edge_g's eu_hd2 list */
	union {
		struct loopuse	*lu_p;
		struct shell	*s_p;
		long	        *magic_p; /* for those times when we're not sure */
	} up;
	struct edgeuse		*eumate_p;  /* eu on other face or other end of wire*/
	struct edgeuse		*radial_p;  /* eu on radially adj. fu (null if wire)*/
	struct edge		*e_p;	    /* edge definition and attributes */
	int	  		orientation;/* compared to geom (null if wire) */
	struct vertexuse	*vu_p;	    /* first vu of eu in this orient */
	union {
		long		    *magic_p;
		struct edge_g_lseg  *lseg_p;
		struct edge_g_cnurb *cnurb_p;
	} g;				/* geometry */
	/* (u,v,w) param[] of vu is found in vu_p->vua_p->param */
	long			index;	/* struct # in this model */
};

/*
 *			V E R T E X
 *
 *  The vertex and vertexuse structures are connected in a way different
 *  from the superior kinds of topology elements.
 *  The vertex structure heads a linked list that all vertexuse's
 *  that use the vertex are linked onto.
 */
struct vertex {
	long			magic;
	struct bu_list		vu_hd;	/* heads list of vu's of this vertex */
	struct vertex_g		*vg_p;	/* geometry */
	long			index;	/* struct # in this model */
};

struct vertex_g {
	long			magic;
	point_t			coord;	/* coordinates of vertex in space */
	long			index;	/* struct # in this model */
};

struct vertexuse {
	struct bu_list		l;	/* list of all vu's on a vertex */
	union {
		struct shell	*s_p;	/* no fu's or eu's on shell */
		struct loopuse	*lu_p;	/* loopuse contains single vertex */
		struct edgeuse	*eu_p;	/* eu causing this vu */
		long		*magic_p; /* for those times when we're not sure */
	} up;
	struct vertex		*v_p;	/* vertex definition and attributes */
	union {
		long				*magic_p;
		struct vertexuse_a_plane	*plane_p;
		struct vertexuse_a_cnurb	*cnurb_p;
	} a;				/* Attributes */
	long			index;	/* struct # in this model */
};

struct vertexuse_a_plane {
	long			magic;
	vect_t			N;	/* (opt) surface Normal at vertexuse */
	long			index;	/* struct # in this model */
};

struct vertexuse_a_cnurb {
	long			magic;
	fastf_t			param[3]; /* (u,v,w) of vu on eu's cnurb */
	long			index;	/* struct # in this model */
};

/*
 * storage allocation and de-allocation support
 *  Primarily used by nmg_mk.c
 */

#define NMG_GETSTRUCT(p,str)	BU_GETSTRUCT(p,str)


#if __STDC__ && !defined(alliant) && !defined(apollo)
# define NMG_FREESTRUCT(ptr, str) \
	{ bzero((char *)(ptr), sizeof(struct str)); \
	  bu_free((char *)(ptr), "freestruct " #str); }
#else
# define NMG_FREESTRUCT(ptr, str) \
	{ bzero((char *)(ptr), sizeof(struct str)); \
	  bu_free((char *)(ptr), "freestruct str"); }
#endif

#if defined(SYSV) && !defined(bzero) && !defined(HAVE_BZERO)
#	define bzero(str,n)		memset( str, '\0', n )
#	define bcopy(from,to,count)	memcpy( to, from, count )
#endif
/*
 *  Macros to create and destroy storage for the NMG data structures.
 *  Since nmg_mk.c and g_nmg.c are the only source file which should perform
 *  these most fundamental operations, the macros do not belong in nmg.h
 *  In particular, application code should NEVER do these things.
 *  Any need to do so should be handled by extending nmg_mk.c
 */
#define NMG_INCR_INDEX(_p,_m)	\
	NMG_CK_MODEL(_m); (_p)->index = ((_m)->maxindex)++

#define GET_REGION(p,m)	    {NMG_GETSTRUCT(p, nmgregion); NMG_INCR_INDEX(p,m);}
#define GET_REGION_A(p,m)   {NMG_GETSTRUCT(p, nmgregion_a); NMG_INCR_INDEX(p,m);}
#define GET_SHELL(p,m)	    {NMG_GETSTRUCT(p, shell); NMG_INCR_INDEX(p,m);}
#define GET_SHELL_A(p,m)    {NMG_GETSTRUCT(p, shell_a); NMG_INCR_INDEX(p,m);}
#define GET_FACE(p,m)	    {NMG_GETSTRUCT(p, face); NMG_INCR_INDEX(p,m);}
#define GET_FACE_G_PLANE(p,m) {NMG_GETSTRUCT(p, face_g_plane); NMG_INCR_INDEX(p,m);}
#define GET_FACE_G_SNURB(p,m) {NMG_GETSTRUCT(p, face_g_snurb); NMG_INCR_INDEX(p,m);}
#define GET_FACEUSE(p,m)    {NMG_GETSTRUCT(p, faceuse); NMG_INCR_INDEX(p,m);}
#define GET_LOOP(p,m)	    {NMG_GETSTRUCT(p, loop); NMG_INCR_INDEX(p,m);}
#define GET_LOOP_G(p,m)	    {NMG_GETSTRUCT(p, loop_g); NMG_INCR_INDEX(p,m);}
#define GET_LOOPUSE(p,m)    {NMG_GETSTRUCT(p, loopuse); NMG_INCR_INDEX(p,m);}
#define GET_EDGE(p,m)	    {NMG_GETSTRUCT(p, edge); NMG_INCR_INDEX(p,m);}
#define GET_EDGE_G_LSEG(p,m)  {NMG_GETSTRUCT(p, edge_g_lseg); NMG_INCR_INDEX(p,m);}
#define GET_EDGE_G_CNURB(p,m) {NMG_GETSTRUCT(p, edge_g_cnurb); NMG_INCR_INDEX(p,m);}
#define GET_EDGEUSE(p,m)    {NMG_GETSTRUCT(p, edgeuse); NMG_INCR_INDEX(p,m);}
#define GET_VERTEX(p,m)	    {NMG_GETSTRUCT(p, vertex); NMG_INCR_INDEX(p,m);}
#define GET_VERTEX_G(p,m)   {NMG_GETSTRUCT(p, vertex_g); NMG_INCR_INDEX(p,m);}
#define GET_VERTEXUSE(p,m)  {NMG_GETSTRUCT(p, vertexuse); NMG_INCR_INDEX(p,m);}
#define GET_VERTEXUSE_A_PLANE(p,m) {NMG_GETSTRUCT(p, vertexuse_a_plane); NMG_INCR_INDEX(p,m);}
#define GET_VERTEXUSE_A_CNURB(p,m) {NMG_GETSTRUCT(p, vertexuse_a_cnurb); NMG_INCR_INDEX(p,m);}

#define FREE_MODEL(p)	    NMG_FREESTRUCT(p, model)
#define FREE_REGION(p)	    NMG_FREESTRUCT(p, nmgregion)
#define FREE_REGION_A(p)    NMG_FREESTRUCT(p, nmgregion_a)
#define FREE_SHELL(p)	    NMG_FREESTRUCT(p, shell)
#define FREE_SHELL_A(p)	    NMG_FREESTRUCT(p, shell_a)
#define FREE_FACE(p)	    NMG_FREESTRUCT(p, face)
#define FREE_FACE_G_PLANE(p) NMG_FREESTRUCT(p, face_g_plane)
#define FREE_FACE_G_SNURB(p) NMG_FREESTRUCT(p, face_g_snurb)
#define FREE_FACEUSE(p)	    NMG_FREESTRUCT(p, faceuse)
#define FREE_LOOP(p)	    NMG_FREESTRUCT(p, loop)
#define FREE_LOOP_G(p)	    NMG_FREESTRUCT(p, loop_g)
#define FREE_LOOPUSE(p)	    NMG_FREESTRUCT(p, loopuse)
#define FREE_LOOPUSE_A(p)   NMG_FREESTRUCT(p, loopuse_a)
#define FREE_EDGE(p)	    NMG_FREESTRUCT(p, edge)
#define FREE_EDGE_G_LSEG(p)  NMG_FREESTRUCT(p, edge_g_lseg)
#define FREE_EDGE_G_CNURB(p) NMG_FREESTRUCT(p, edge_g_cnurb)
#define FREE_EDGEUSE(p)	    NMG_FREESTRUCT(p, edgeuse)
#define FREE_VERTEX(p)	    NMG_FREESTRUCT(p, vertex)
#define FREE_VERTEX_G(p)    NMG_FREESTRUCT(p, vertex_g)
#define FREE_VERTEXUSE(p)   NMG_FREESTRUCT(p, vertexuse)
#define FREE_VERTEXUSE_A_PLANE(p) NMG_FREESTRUCT(p, vertexuse_a_plane)
#define FREE_VERTEXUSE_A_CNURB(p) NMG_FREESTRUCT(p, vertexuse_a_cnurb)

/* Do two edgeuses share the same two vertices? If yes, eu's should be joined. */
#define NMG_ARE_EUS_ADJACENT(_eu1,_eu2)	(  \
	( (_eu1)->vu_p->v_p == (_eu2)->vu_p->v_p &&   \
	  (_eu1)->eumate_p->vu_p->v_p == (_eu2)->eumate_p->vu_p->v_p )  ||  \
	( (_eu1)->vu_p->v_p == (_eu2)->eumate_p->vu_p->v_p &&  \
	  (_eu1)->eumate_p->vu_p->v_p == (_eu2)->vu_p->v_p ) )

/* Compat: Used in nmg_misc.c and nmg_mod.c */
#define EDGESADJ(_e1, _e2) NMG_ARE_EUS_ADJACENT(_e1,_e2)

/* Print a plane equation. */
#define PLPRINT(_s, _pl) bu_log("%s %gx + %gy + %gz = %g\n", (_s), \
	(_pl)[0], (_pl)[1], (_pl)[2], (_pl)[3])


/* values for the "allhits" argument to mg_class_pt_fu_except() */
#define NMG_FPI_FIRST	0	/* return after finding first touch */
#define NMG_FPI_PERGEOM	1	/* find all touches,
				 *  call user funcs once for each
				 * geometry element touched
				 */
#define NMG_FPI_PERUSE	2	/* find all touches,
				 *  call user funcs once for each
				 * use of geom elements touched
				 */


struct nmg_boolstruct {
	struct bu_ptbl	ilist;		/* vertexuses on intersection line */
	fastf_t		tol;
	point_t		pt;		/* line of intersection */
	vect_t		dir;
	int		coplanar;
	char		*vertlist;
	int		vlsize;
	struct model	*model;
};

#define PREEXIST 1
#define NEWEXIST 2


#define VU_PREEXISTS(_bs, _vu) { chkidxlist((_bs), (_vu)); \
	(_bs)->vertlist[(_vu)->index] = PREEXIST; }

#define VU_NEW(_bs, _vu) { chkidxlist((_bs), (_vu)); \
	(_bs)->vertlist[(_vu)->index] = NEWEXIST; }


struct nmg_struct_counts {
	/* Actual structure counts (Xuse, then X) */
	long	model;
	long	region;
	long	region_a;
	long	shell;
	long	shell_a;
	long	faceuse;
	long	face;
	long	face_g_plane;
	long	face_g_snurb;
	long	loopuse;
	long	loop;
	long	loop_g;
	long	edgeuse;
	long	edge;
	long	edge_g_lseg;
	long	edge_g_cnurb;
	long	vertexuse;
	long	vertexuse_a_plane;
	long	vertexuse_a_cnurb;
	long	vertex;
	long	vertex_g;
	/* Abstractions */
	long	max_structs;
	long	face_loops;
	long	face_edges;
	long	face_lone_verts;
	long	wire_loops;
	long	wire_loop_edges;
	long	wire_edges;
	long	wire_lone_verts;
	long	shells_of_lone_vert;
};

/*
 *  For use with tables subscripted by NMG structure "index" values,
 *  traditional test and set macros.
 *  A value of zero indicates unset, a value of one indicates set.
 *  test-and-set returns TRUE if value was unset;  in the process,
 *  value has become set.  This is often used to detect the first
 *  time an item is used, so an alternative name is given, for clarity.
 *  Note that the somewhat simpler auto-increment form
 *	( (tab)[(p)->index]++ == 0 )
 *  is not used, to avoid the possibility of integer overflow from
 *  repeated test-and-set operations on one item.
 */
#define NMG_INDEX_VALUE(_tab,_index)	((_tab)[_index])
#define NMG_INDEX_TEST(_tab,_p)		( (_tab)[(_p)->index] )
#define NMG_INDEX_SET(_tab,_p)		{(_tab)[(_p)->index] = 1;}
#define NMG_INDEX_CLEAR(_tab,_p)	{(_tab)[(_p)->index] = 0;}
#define NMG_INDEX_TEST_AND_SET(_tab,_p)	\
	( (_tab)[(_p)->index] == 0 ? ((_tab)[(_p)->index] = 1) : 0 )
#define NMG_INDEX_IS_SET(_tab,_p)	NMG_INDEX_TEST(_tab,_p)
#define NMG_INDEX_FIRST_TIME(_tab,_p)	NMG_INDEX_TEST_AND_SET(_tab,_p)
#define NMG_INDEX_ASSIGN(_tab,_p,_val)	{(_tab)[(_p)->index] = _val;}
#define NMG_INDEX_GET(_tab,_p)		((_tab)[(_p)->index])
#define NMG_INDEX_GETP(_ty,_tab,_p)	((struct _ty *)((_tab)[(_p)->index]))
#define NMG_INDEX_OR(_tab,_p,_val)	{(_tab)[(_p)->index] |= _val;}
#define NMG_INDEX_AND(_tab,_p,_val)	{(_tab)[(_p)->index] &= _val;}
#define NMG_INDEX_RETURN_IF_SET_ELSE_SET(_tab,_index)	\
	{ if( (_tab)[_index] )  return; \
	  else (_tab)[_index] = 1; }

/* flags for manifold-ness */
#define NMG_3MANIFOLD	16
#define NMG_2MANIFOLD	4
#define NMG_1MANIFOLD	2
#define NMG_0MANIFOLD	1
#if 0
# define NMG_DANGLING	8 /* NMG_2MANIFOLD + 4th bit for special cond */
#endif

#define NMG_SET_MANIFOLD(_t,_p,_v) NMG_INDEX_OR(_t, _p, _v)
#define NMG_MANIFOLDS(_t, _p)	   NMG_INDEX_VALUE(_t, (_p)->index)
#define NMG_CP_MANIFOLD(_t, _p, _q) (_t)[(_p)->index] = (_t)[(_q)->index]

/*
 *  Bit-parameters for nmg_lu_to_vlist() poly_markers code.
 */
#define NMG_VLIST_STYLE_VECTOR			0
#define NMG_VLIST_STYLE_POLYGON			1
#define NMG_VLIST_STYLE_VISUALIZE_NORMALS	2
#define NMG_VLIST_STYLE_USE_VU_NORMALS		4
#define NMG_VLIST_STYLE_NO_SURFACES		8

/*
 *  Function table, for use with nmg_visit()
 *  Indended to have same generally the organization as nmg_struct_counts.
 *  The handler's args are long* to allow generic handlers to be written,
 *  in which case the magic number at long* specifies the object type.
 *
 *  The "vis_" prefix means the handler is visited only once.
 *  The "bef_" and "aft_" prefixes are called (respectively) before
 *  and after recursing into subsidiary structures.
 *  The 3rd arg is 0 for a "bef_" call, and 1 for an "aft_" call,
 *  to allow generic handlers to be written, if desired.
 */
struct nmg_visit_handlers {
	void	(*bef_model) NMG_ARGS((long *, genptr_t, int));
	void	(*aft_model) NMG_ARGS((long *, genptr_t, int));

	void	(*bef_region) NMG_ARGS((long *, genptr_t, int));
	void	(*aft_region) NMG_ARGS((long *, genptr_t, int));

	void	(*vis_region_a) NMG_ARGS((long *, genptr_t, int));

	void	(*bef_shell) NMG_ARGS((long *, genptr_t, int));
	void	(*aft_shell) NMG_ARGS((long *, genptr_t, int));

	void	(*vis_shell_a) NMG_ARGS((long *, genptr_t, int));

	void	(*bef_faceuse) NMG_ARGS((long *, genptr_t, int));
	void	(*aft_faceuse) NMG_ARGS((long *, genptr_t, int));

	void	(*vis_face) NMG_ARGS((long *, genptr_t, int));
	void	(*vis_face_g) NMG_ARGS((long *, genptr_t, int));

	void	(*bef_loopuse) NMG_ARGS((long *, genptr_t, int));
	void	(*aft_loopuse) NMG_ARGS((long *, genptr_t, int));

	void	(*vis_loop) NMG_ARGS((long *, genptr_t, int));
	void	(*vis_loop_g) NMG_ARGS((long *, genptr_t, int));

	void	(*bef_edgeuse) NMG_ARGS((long *, genptr_t, int));
	void	(*aft_edgeuse) NMG_ARGS((long *, genptr_t, int));

	void	(*vis_edge) NMG_ARGS((long *, genptr_t, int));
	void	(*vis_edge_g) NMG_ARGS((long *, genptr_t, int));

	void	(*bef_vertexuse) NMG_ARGS((long *, genptr_t, int));
	void	(*aft_vertexuse) NMG_ARGS((long *, genptr_t, int));

	void	(*vis_vertexuse_a) NMG_ARGS((long *, genptr_t, int));
	void	(*vis_vertex) NMG_ARGS((long *, genptr_t, int));
	void	(*vis_vertex_g) NMG_ARGS((long *, genptr_t, int));
};

extern const struct nmg_visit_handlers nmg_visit_handlers_null;

#endif
@


11.13
log
@merge of ansi-6-0-branch into HEAD
@
text
@d33 1
a33 1
 *  $Header$
@


11.12
log
@updated SIGNED to signed
updated CONST to const
@
text
@d33 1
a33 1
 *  $Header: /c/CVS/brlcad/h/nmg.h,v 11.11 1999/06/03 02:16:16 mike Exp $
d590 1
a590 1
#if __STDC__ && !alliant && !apollo
@


11.12.4.1
log
@quell warnings
@
text
@d33 1
a33 1
 *  $Header: /n/cad/c/CVS/brlcad/h/nmg.h,v 11.12 2001/04/05 19:35:07 morrison Exp $
d590 1
a590 1
#if __STDC__ && !defined(alliant) && !defined(apollo)
@


11.11
log
@
sed4
@
text
@d33 1
a33 1
 *  $Header: /c/CVS/brlcad/h/nmg.h,v 11.10 1997/07/15 19:50:06 gdurf Exp $
d369 2
a370 2
	register CONST struct faceuse	*_fu1 = (_fu); \
	register CONST struct face_g_plane	*_fg; \
d383 2
a384 2
	register CONST struct faceuse	*_fu1 = (_fu); \
	register CONST struct face_g_plane	*_fg; \
d845 1
a845 1
extern CONST struct nmg_visit_handlers nmg_visit_handlers_null;
@


11.10
log
@Added HAVE_BZERO
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 11.9 1996/09/20 00:26:47 mike Exp gdurf $
d82 1
a82 1
/***#define DEBUG_INS	0x00008000	/_* 16 nmg_tbl table insert */
d165 1
a165 4
#define NMG_CKMAG(_ptr, _magic, _str)	\
	if( !(_ptr) || *((long *)(_ptr)) != (_magic) )  { \
		rt_badmagic( (long *)(_ptr), _magic, _str, __FILE__, __LINE__ ); \
	}
d168 1
a168 1
		rt_badmagic( (long *)(_ptr), _magic1, _str, __FILE__, __LINE__ ); \
d195 1
a195 1
#define NMG_CK_LIST(_p)		NMG_CKMAG(_p, RT_LIST_HEAD_MAGIC, "rt_list")
d202 1
a202 1
		rt_log("in %s at %d Bad edgeuse member pointer\n",\
d207 1
a207 1
	    	rt_log("in %s at %d edgeuse lost vertexuse\n",\
d248 1
a248 1
	struct rt_list		r_hd;	/* list of regions */
d257 1
a257 1
	struct rt_list		l;	/* regions, in model's r_hd list */
d260 1
a260 1
	struct rt_list		s_hd;	/* list of shells in region */
d290 1
a290 1
	struct rt_list		l;	/* shells, in region's s_hd list */
d294 3
a296 3
	struct rt_list		fu_hd;	/* list of face uses in shell */
	struct rt_list		lu_hd;	/* wire loopuses (edge groups) */
	struct rt_list		eu_hd;	/* wire list (shell has wires) */
d315 1
a315 1
	struct rt_list		l;	/* faces in face_g's f_hd list */
d332 1
a332 1
	struct rt_list		f_hd;	/* list of faces sharing this surface */
d339 2
a340 2
	struct rt_list		l;
	struct rt_list		f_hd;	/* list of faces sharing this surface */
d357 1
a357 1
	struct rt_list		l;	/* fu's, in shell's fu_hd list */
d363 1
a363 1
	struct rt_list		lu_hd;	/* list of loops in face-use */
d403 1
a403 1
 *  But, before using it, check RT_LIST_FIRST_MAGIC(&lu->down_hd)
d406 1
a406 1
 *  with vu = RT_LIST_FIRST(vertexuse, &lu->down_hd)
d420 1
a420 1
	(_hp)->forw = &((_vu)->l); (_hp)->back = (struct rt_list *)NULL; }
d437 1
a437 1
	struct rt_list		l;	/* lu's, in fu's lu_hd, or shell's lu_hd */
d446 1
a446 1
	struct rt_list		down_hd; /* eu list or vu pointer */
d458 1
a458 1
 *  by RT_LIST_PNEXT_CIRC(edgeuse,eu)->vu_p.  Note that the first
d483 2
a484 2
	struct rt_list		l;	/* NOTICE:  l.forw & l.back *not* stored in database.  For alignment only. */
	struct rt_list		eu_hd2;	/* heads l2 list of edgeuses on this line */
d499 2
a500 2
	struct rt_list		l;	/* NOTICE:  l.forw & l.back *not* stored in database.  For LIBNURB internal use only. */
	struct rt_list		eu_hd2;	/* heads l2 list of edgeuses on this curve */
d511 2
a512 2
	struct rt_list		l;	/* cw/ccw edges in loop or wire edges in shell */
	struct rt_list		l2;	/* member of edge_g's eu_hd2 list */
d542 1
a542 1
	struct rt_list		vu_hd;	/* heads list of vu's of this vertex */
d554 1
a554 1
	struct rt_list		l;	/* list of all vu's on a vertex */
d587 2
a588 7
#if __STDC__ && !alliant && !apollo
#   define NMG_GETSTRUCT(p,str) \
	p = (struct str *)rt_calloc(1,sizeof(struct str), "getstruct " #str)
#else
#   define NMG_GETSTRUCT(p,str) \
	p = (struct str *)rt_calloc(1,sizeof(struct str), "getstruct str")
#endif
d593 1
a593 1
	  rt_free((char *)(ptr), "freestruct " #str); }
d597 1
a597 1
	  rt_free((char *)(ptr), "freestruct str"); }
d669 1
a669 1
#define PLPRINT(_s, _pl) rt_log("%s %gx + %gy + %gz = %g\n", (_s), \
@


11.9
log
@non-ANSI comment.
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 11.8 1996/08/28 05:41:06 mike Exp mike $
d608 1
a608 1
#if defined(SYSV) && !defined(bzero)
@


11.8
log
@Moved nmg_tbl() off into bu.h / LIBBU
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 11.7 1996/05/10 18:34:36 jra Exp mike $
d82 1
a82 1
/***#define DEBUG_INS	0x00008000	/* 16 nmg_tbl table insert */
@


11.7
log
@Added TBL_ZERO for nmg_tbl().
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 11.6 1995/12/02 03:01:35 mike Exp jra $
d52 8
d82 1
a82 1
#define DEBUG_INS	0x00008000	/* 16 nmg_tbl table insert */
d96 1
a96 1
\027RT_SEGS\026FCUT\025VU_SORT\024CUTLOOP\023CMFACE\022FINDEU\021RT_ISECT\020TBL_INS\
a135 26


/* support for pointer tables.  Our table is currently un-ordered, and is
 * merely a list of objects.  The support routine nmg_tbl manipulates the
 * list structure for you.  Objects to be referenced (inserted, deleted,
 * searched for) are passed as a "pointer to long" to the support routine.
 */
#define TBL_INIT 0	/* initialize list pointer struct & get storage */
#define TBL_INS	 1	/* insert an item (long *) into a list */
#define TBL_LOC  2	/* locate a (long *) in an existing list */
#define TBL_FREE 3	/* deallocate buffer associated with a list */
#define TBL_RST	 4	/* empty a list, but keep storage on hand */
#define TBL_CAT  5	/* catenate one list onto another */
#define TBL_RM	 6	/* remove all occurrences of an item from a list */
#define TBL_INS_UNIQUE	 7	/* insert item into list, if not present */
#define TBL_ZERO 8	/* replace all occurrences of an item by 0 */

struct nmg_ptbl {
	long	magic;	/* magic */
	int	end;	/* index into buffer of first available location */
	int	blen;	/* # of (long *)'s worth of storage at *buffer */
	long  **buffer;	/* data storage area */
};
#define NMG_PTBL_MAGIC		0x7074626c		/* "ptbl" */
#define NMG_CK_PTBL(_p)		NMG_CKMAG(_p, NMG_PTBL_MAGIC, "nmg_ptbl")

a136 11
 *  For those routines that have to "peek" into the ptbl a little bit.
 *  A handy way to visit all the elements of the list is:
 *	for( eup = (struct edgeuse **)NMG_TBL_LASTADDR(&eutab);
 *	     eup >= (struct edgeuse **)NMG_TBL_BASEADDR(&eutab); eup-- )  {
 */
#define NMG_TBL_BASEADDR(p)	((p)->buffer)
#define NMG_TBL_LASTADDR(p)	((p)->buffer + (p)->end - 1)
#define NMG_TBL_END(p)		((p)->end)
#define NMG_TBL_GET(p,i)	((p)->buffer[(i)])

/*
d694 1
a694 1
	struct nmg_ptbl	ilist;		/* vertexuses on intersection line */
@


11.6
log
@edge_g_lseg and edge_g_cnurb need to have exactly the same structure
for the first 2 elements, to permit walking the eu_hd2 list.
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 11.5 1995/12/01 02:41:17 mike Exp $
d143 1
@


11.5
log
@LIBNURB data structures have been fully merged withNMG data structures.
@
text
@d33 1
a33 1
 *  $Header: /n/wolf/m/cad/h/RCS/nmg.h,v 11.2 1995/02/16 03:45:09 mike Exp butler $
a172 1
#define NMG_FACE_G_MAGIC	bogus_nmg_face_g_magic;
a175 1
#define NMG_FACEUSE_A_MAGIC	bogus_nmg_faceuse_a_magic;
a178 1
#define NMG_LOOPUSE_A_MAGIC	bogus_nmg_loopuse_a_magic;
a179 1
#define NMG_EDGE_G_MAGIC	bogus_nmg_edge_g_magic;
a183 1
#define NMG_EDGEUSE_A_MAGIC	bogus_nmg_edgeuse_a_magic;
a186 1
#define NMG_VERTEXUSE_A_MAGIC	bogus_nmg_vertexuse_a_magic;
a207 1
#define NMG_CK_FACE_G(_p)	bogus_ck_face_g;
a211 1
#define NMG_CK_FACEUSE_A(_p)	bogus_ck_faceuse_a;
a214 1
#define NMG_CK_LOOPUSE_A(_p)	bogus_ck_loopuse_a;
a215 1
#define NMG_CK_EDGE_G(_p)	bogus_ck_edge_g;
a219 1
#define NMG_CK_EDGEUSE_A(_p)	bogus_ck_edgeuse_a;
a222 1
#define NMG_CK_VERTEXUSE_A(_p)	bogus_ck_vertexuse_a;
d508 5
a512 1
#define edge_g			BOGUS_edge_g_lseg;
d514 1
a514 1
	long			magic;
d530 1
a530 2
	/* NOTICE:  l.forw & l.back *not* stored in database.  For LIBNURB internal use only. */
	struct rt_list		l;
a649 1
#define GET_MODEL_A(p,m)    bogus_get_model_a;
a654 1
#define GET_FACE_G(p,m)	    bogus_get_face_g;
a657 1
#define GET_FACEUSE_A(p,m)  bogus_get_faceuse_a;
a660 1
#define GET_LOOPUSE_A(p,m)  bogus_get_loopuse_a;
a661 1
#define GET_EDGE_G(p,m)	    bogus_get_edge_g;
a664 1
#define GET_EDGEUSE_A(p,m)  bogus_get_edgeuse_a;
a667 1
#define GET_VERTEXUSE_A(p,m) bogus_get_vertexuse_a;
a671 1
#define FREE_MODEL_A(p)	    bogus_free_model_a;
a676 1
#define FREE_FACE_G(p)	    bogus_free_face_g;
a679 1
#define FREE_FACEUSE_A(p)   bogus_free_faceuse_a;
a684 1
#define FREE_EDGE_G(p)	    bogus_free_edge_g;
a687 1
#define FREE_EDGEUSE_A(p)   bogus_free_edgeuse_a;
a690 1
#define FREE_VERTEXUSE_A(p) bogus_free_vertexuse_a;
@


11.4
log
@Added new define
@
text
@d381 2
a382 1
	long			magic;
d393 2
d538 2
a539 1
	long			magic;
@


11.3
log
@Lee added stuff from the T80 effort
@
text
@d845 1
@


11.2
log
@Added "dir", for Stay's t-NURBS.
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 11.1 95/01/04 09:48:25 mike Rel4_4 Locker: mike $
a725 39

/* Faceuse/pt classification structure.
 *  This is what gets returned by nmg_class_pt_fu_except()
 *  It gets built from the arguments to the function and by performing
 *  the point/faceuse classification.
 *
 *  Note:  The calling routine is responsible for calling rt_free() on
 *	the "tbl" element and the structure as a whole.
 */
struct fu_pt_info {
	long			magic;
	CONST struct rt_tol	*tol;
	CONST struct faceuse	*fu_p;
	char		*tbl;		/* processed element status table */
	plane_t		norm;		/* surface normal for face(use) */
	pointp_t	pt;		/* pt in plane of face to classify */
	int		pt_class;	/* current point classification */
	void		(*eu_func)();	/* call w/eu when pt on edgeuse */
	void		(*vu_func)();	/* call w/vu when pt on vertexuse */
	char		*priv;		/* private data for [ev]u_func */
	int		allhits;	/* find first/all touches. */
	fastf_t		dist_in_plane;	/* dist in plane (elem -> plane_pt) */
	long		*closest;	/* ptr to elem w/ min(dist_in_plane)*/
	point_t		pca;
	int		PCA_loc;	/* is PCA at an edge-span,
					 *  edge-vertex, or vertex?
					 */
};

#define NMG_FPI_MAGIC 0x66706900 /* fpi\0 */
#define NMG_CK_FPI(_fpi)	NMG_CKMAG(_fpi, NMG_FPI_MAGIC, "fu_pt_info")
#define NMG_FPI_FREE( _fpi ) { \
 (void)rt_free( (char *)(_fpi->tbl), "nmg_class_pt_fu_except() proc tbl" ); \
 (void)rt_free( (char *)(_fpi), "struct fu_pt_info" ); }

/* values for fu_pt_info->tbl entries */
#define NMG_FPI_VIRGIN	0
#define NMG_FPI_MISSED	-2
#define NMG_FPI_TOUCHED	2
@


11.1
log
@Release_4.4
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.51 94/12/28 21:17:15 butler Exp $
d390 3
@


10.51
log
@added DEBUG_MANIF
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.50 94/12/23 18:51:21 mike Exp $
@


10.50
log
@Spelled out the args to nmg_lu_to_vlist().
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.49 94/12/05 19:05:19 butler Exp Locker: mike $
d85 1
d87 1
a87 1
"\020\031TRIANG\030RT_ISECT\
@


10.49
log
@added pca to pt_fu_info structure
added DEBUG_PT_FU flag
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.48 94/09/21 03:49:26 mike Exp Locker: butler $
d872 8
@


10.48
log
@Eliminated model_a structure
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.47 94/09/21 03:31:51 mike Exp Locker: mike $
d84 1
d745 1
@


10.47
log
@Removed model's "manifolds" pointer.
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.46 94/09/21 00:08:28 mike Exp Locker: mike $
a165 1
#define NMG_MODEL_A_MAGIC	0x68652062
a206 1
#define NMG_CK_MODEL_A(_p)	NMG_CKMAG(_p, NMG_MODEL_A_MAGIC, "model_a")
a288 1
	struct model_a		*ma_p;
a293 5
struct model_a {
	long			magic;
	long			index;	/* struct # in this model */
};

d650 1
a650 1
#define GET_MODEL_A(p,m)    {NMG_GETSTRUCT(p, model_a); NMG_INCR_INDEX(p,m);}
d679 1
a679 1
#define FREE_MODEL_A(p)	    NMG_FREESTRUCT(p, model_a)
a796 1
	long	model_a;
a885 2

	void	(*vis_model_a) NMG_ARGS((long *, genptr_t, int));
@


10.46
log
@nmg.h is now the place where knot vectors are defined.
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.45 94/09/16 20:43:38 mike Exp Locker: mike $
a293 1
	char			*manifolds; /*  structure 1-3manifold table */
@


10.45
log
@Removed edge_g crutch.
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.44 94/09/16 19:42:40 mike Exp Locker: mike $
a259 1
#ifndef NURB_H
a263 2
/* XXX This does not belong here! Eliminate from here and nurb.h */
	long		index;		/* struct # in this model */
d265 1
a265 1
#endif
@


10.44
log
@Moved RT_LIST_MAIN_PTR into rtlist.h
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.43 94/09/16 19:31:41 mike Exp Locker: mike $
a366 1
#define edge_g			edge_g_lseg	/* compat */
d524 1
@


10.43
log
@Added NMG_CK2MAG() macro, and three NMG_CK_{face_g,edge_g,vertexuse_a}_BOTH
macros.
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.42 94/09/10 04:35:29 mike Exp Locker: mike $
d533 8
a540 2
/* The ctl_points on this curve are (u,v) values on the face's surface */
/* If order <= 0, cnurb is straight line seg in param space, with null knots and ctl_points */
a551 14

/* XXX move to rtlist.h */
/*
 *  When a structure of type '_type' contains more than one rt_list structure
 *  within it (such as the NMG edgeuse), this macro can be used to convert
 *  a pointer '_ptr2' to a "midway" rt_list structure (an element called
 *  '_name2' in structure '_type') back into a pointer to the overall
 *  enclosing structure.  For example:
 *		eu = RT_LIST_MAIN_PTR( edgeuse, midway, l2 );
 *
 *  eu1 = RT_LIST_MAIN_PTR(edgeuse, RT_LIST_FIRST(rt_list, &eg1->eu_hd2), l2);
 */  
#define RT_LIST_MAIN_PTR(_type, _ptr2, _name2)	\
	((struct _type *)(((char *)(_ptr2)) - offsetof(struct _type, _name2.magic)))
@


10.42
log
@Converted NMG data structures to have edge_g pointer in edgeuse, not edge.
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.41 94/09/03 03:02:02 mike Exp Locker: mike $
d202 4
d215 3
a217 2
#define NMG_CK_FACE_G_PLANE(_p)	NMG_CKMAG(_p, NMG_FACE_G_PLANE_MAGIC, "face_g plane")
#define NMG_CK_FACE_G_SNURB(_p)	NMG_CKMAG(_p, NMG_FACE_G_SNURB_MAGIC, "face_g snurb")
d228 1
d236 2
a237 1
#define NMG_CK_VERTEXUSE_A_CNURB(_p)	NMG_CKMAG(_p, NMG_VERTEXUSE_A_CNURB_MAGIC, "vertexuse_a_cnurb_plane")
d265 1
@


10.41
log
@Snapshot of non-working intermediate stage in edge_g evolution.
@
text
@a0 1
#define OLD_NMG	1	/* Tags Mike's changes */
d4 1
a4 1
 *  Author -
d6 1
d12 2
a13 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1993 by the United States Army.
 *	All rights reserved.
d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.40 94/09/02 19:06:58 mike Exp Locker: mike $
d384 1
a384 1
	struct rt_list		l;	/* magic, forw */
d387 2
a388 2
	struct knot_vector	u_knots;/* surface knot vectors */
	struct knot_vector	v_knots;/* surface knot vectors */
a400 1
#if !OLD_NMG
a401 1
#endif
a512 3
#if OLD_NMG
	struct edge_g		*eg_p;  /* geometry */
#endif
a518 3
#if 0
	long			usage;	/* # of uses of this geometry */
#else
a519 1
#endif
d531 1
a531 1
	struct knot_vector	knot;	/* curve knot vector */
d547 2
a565 1
#if !OLD_NMG
a571 1
#endif
a822 3
#if OLD_NMG
	long	edge_g;
#else
a824 1
#endif
@


10.40
log
@vertexuse_a is now vertexuse_a_plane and vertexuse_a_cnurb
@
text
@d34 1
a34 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.39 94/09/02 18:00:41 mike Exp Locker: mike $
d183 1
a183 1
#define NMG_EDGE_G_MAGIC	0x6c696768
d221 1
a221 1
#define NMG_CK_EDGE_G(_p)	NMG_CKMAG(_p, NMG_EDGE_G_MAGIC, "edge_g")
a513 1
#if OLD_NMG
a514 3
#else
	struct rt_list		l;
#endif
d525 1
a525 1
#if OLD_NMG
d528 1
a528 1
	struct rt_list		e_hd;	/* heads list of edges on this line */
a534 1
/* !OLD_NMG */
d539 1
a539 1
	struct rt_list		e_hd;	/* heads list of edges on this curve */
d549 12
d563 1
d688 1
a688 1
#define GET_EDGE_G(p,m)	    {NMG_GETSTRUCT(p, edge_g); (p)->usage = 1; NMG_INCR_INDEX(p,m);}
d717 1
a717 1
#define FREE_EDGE_G(p)	    if (--((p)->usage) <= 0)  NMG_FREESTRUCT(p, edge_g)
@


10.39
log
@faceuse_a, loopuse_a, and edgeuse_a have been eliminated.
@
text
@d34 1
a34 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.38 94/09/02 01:13:54 mike Exp Locker: mike $
d192 1
a192 1
#define NMG_VERTEXUSE_A_MAGIC	0x69676874
d229 1
a229 1
#define NMG_CK_VERTEXUSE_A(_p)	NMG_CKMAG(_p, NMG_VERTEXUSE_A_MAGIC, "vertexuse_a")
a360 1
#define vertexuse_a		vertexuse_a_plane	/* compat */
d607 5
a611 1
	struct vertexuse_a	*vua_p;	/* Attributes */
d615 1
a615 2
/* vertexuse_a_plane */
struct vertexuse_a {
d688 1
a688 1
#define GET_VERTEXUSE_A(p,m) {NMG_GETSTRUCT(p, vertexuse_a); NMG_INCR_INDEX(p,m);}
d717 1
a717 1
#define FREE_VERTEXUSE_A(p) NMG_FREESTRUCT(p, vertexuse_a)
@


10.38
log
@More fallout from face_g changes.
@
text
@d34 1
a34 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.37 94/09/02 00:41:02 mike Exp Locker: mike $
d177 1
a177 1
#define NMG_FACEUSE_A_MAGIC	0x20476f64
d181 1
a181 1
#define NMG_LOOPUSE_A_MAGIC	0x68657265
d188 1
a188 1
#define NMG_EDGEUSE_A_MAGIC	0x20416e64
d193 2
d215 1
a215 1
#define NMG_CK_FACEUSE_A(_p)	NMG_CKMAG(_p, NMG_FACEUSE_A_MAGIC, "faceuse_a")
d219 1
a219 1
#define NMG_CK_LOOPUSE_A(_p)	NMG_CKMAG(_p, NMG_LOOPUSE_A_MAGIC, "loopuse_a")
d225 1
a225 1
#define NMG_CK_EDGEUSE_A(_p)	NMG_CKMAG(_p, NMG_EDGEUSE_A_MAGIC, "edgeuse_a")
d230 2
a406 3
#if OLD_NMG
	struct faceuse_a	*fua_p;	/* attributess */
#endif
a410 7
#if OLD_NMG
struct faceuse_a {
	long			magic;
	long			index;	/* struct # in this model */
};
#endif

a489 1
	struct loopuse_a	*lua_p;	/* attributes */
a493 5
struct loopuse_a {
	long			magic;
	long			index;	/* struct # in this model */
};

a564 3
#if OLD_NMG
	struct edgeuse_a	*eua_p;	    /* link to (parametric space) geom */
#endif
a577 7
#if OLD_NMG
struct edgeuse_a {
	long			magic;
	long			index;	/* struct # in this model */
};
#endif

a618 1
#if !OLD_NMG
a623 1
#endif
d672 1
a672 1
#define GET_FACEUSE_A(p,m)  {NMG_GETSTRUCT(p, faceuse_a); NMG_INCR_INDEX(p,m);}
d676 1
a676 1
#define GET_LOOPUSE_A(p,m)  {NMG_GETSTRUCT(p, loopuse_a); NMG_INCR_INDEX(p,m);}
d682 1
a682 1
#define GET_EDGEUSE_A(p,m)  {NMG_GETSTRUCT(p, edgeuse_a); NMG_INCR_INDEX(p,m);}
d687 2
d701 1
a701 1
#define FREE_FACEUSE_A(p)   NMG_FREESTRUCT(p, faceuse_a)
d711 1
a711 1
#define FREE_EDGEUSE_A(p)   NMG_FREESTRUCT(p, edgeuse_a)
d716 2
a814 1
	long	faceuse_a;
a818 1
	long	loopuse_a;
a821 1
	long	edgeuse_a;
d830 2
a831 1
	long	vertexuse_a;
a918 1
	void	(*vis_faceuse_a) NMG_ARGS((long *, genptr_t, int));
a924 1
	void	(*vis_loopuse_a) NMG_ARGS((long *, genptr_t, int));
a930 1
	void	(*vis_edgeuse_a) NMG_ARGS((long *, genptr_t, int));
@


10.37
log
@Changed to new face geometry structures.
@
text
@d34 1
a34 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.36 94/08/31 04:13:32 mike Exp Locker: mike $
a380 1
/* !OLD_NMG */
a836 3
#if OLD_NMG
	long	face_g;		/* face_g_plane */
#else
a838 1
#endif
@


10.36
log
@Added vertexuse_a_plane
@
text
@d34 1
a34 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.35 94/08/31 04:11:36 mike Exp Locker: mike $
d166 1
a166 1
#define NMG_MODEL_MAGIC 	12121212
d168 1
a168 1
#define NMG_REGION_MAGIC	23232323
d170 1
a170 1
#define NMG_SHELL_MAGIC 	71077345	/* shell oil */
d172 2
a173 2
#define NMG_FACE_MAGIC		45454545
#define NMG_FACE_G_MAGIC	0x726b6e65
d176 1
a176 1
#define NMG_FACEUSE_MAGIC	56565656
d178 1
a178 1
#define NMG_LOOP_MAGIC		67676767
d180 1
a180 1
#define NMG_LOOPUSE_MAGIC	78787878
d182 1
a182 1
#define NMG_EDGE_MAGIC		33333333
d186 2
a187 1
#define NMG_EDGEUSE_MAGIC	90909090
d189 3
a191 3
#define NMG_VERTEX_MAGIC	123123
#define NMG_VERTEX_G_MAGIC	727737707
#define NMG_VERTEXUSE_MAGIC	12341234
d209 1
a209 1
#define NMG_CK_FACE_G(_p)	NMG_CKMAG(_p, NMG_FACE_G_MAGIC, "face_g")
a355 1
#define face_g			face_g_plane	/* compat */
a360 3
#if OLD_NMG
	struct face_g		*fg_p;	/* geometry */
#else
a365 1
#endif
d421 1
a421 1
	register CONST struct face_g	*_fg; \
d424 2
a425 2
	_fg = _fu1->f_p->fg_p; \
	NMG_CK_FACE_G(_fg); \
d435 1
a435 1
	register CONST struct face_g	*_fg; \
d438 2
a439 2
	_fg = _fu1->f_p->fg_p; \
	NMG_CK_FACE_G(_fg); \
d693 1
a693 1
#define GET_FACE_G(p,m)	    {NMG_GETSTRUCT(p, face_g); NMG_INCR_INDEX(p,m);}
d720 1
a720 1
#define FREE_FACE_G(p)	    NMG_FREESTRUCT(p, face_g)
d839 1
a839 1
	long	face_g;
@


10.35
log
@Fixed problem with cnurb geometry being in edge, rather than edgeuse.
Moved param[] to vertexuse_a_cnurb
@
text
@d34 1
a34 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.34 94/08/27 04:34:33 mike Exp Locker: mike $
d357 1
d639 1
@


10.34
log
@Added cnurb and snurb data structures, but they are not used yet.
Marked various proposed changes with OLD_NMG and !OLD_NMG flags.
@
text
@d34 1
a34 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.33 94/08/27 01:33:17 mike Exp Locker: mike $
a538 6
#else
	union {
		long		    *magic_p;
		struct edge_g_lseg  *lseg_p;
		struct edge_g_cnurb *cnurb_p;
	} g;				/* geometry */
d558 1
d587 6
a592 1
	fastf_t			param;	/* parametric dist of starting vert */
d644 7
@


10.33
log
@Lee added nmg_visit_handlers_null extern
@
text
@d1 1
d34 1
a34 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.32 94/08/22 20:08:26 butler Exp Locker: butler $
d174 2
d184 2
d192 1
d209 2
d219 2
d243 16
d355 2
d360 1
d362 7
d377 1
a377 1
struct face_g {
a380 5
#if 0
/* XXX This moves to struct face */
	point_t			min_pt;	/* minimums of bounding box */
	point_t			max_pt;	/* maximums of bounding box */
#endif
d384 14
d403 3
d407 1
d409 1
d414 1
d419 1
d523 6
d531 1
d533 3
d537 1
d539 8
a546 1
	long			is_real;/* artifact or modeled edge */
d550 1
a550 1
struct edge_g {
d552 1
d554 4
a557 1
	point_t			e_pt;	/* parametric equation of the edge */
d562 14
d586 3
a588 1
	struct edgeuse_a	*eua_p;	    /* parametric space geom */
d591 3
d597 1
d602 1
d689 2
d699 2
d716 2
d726 2
d833 1
d835 4
d846 1
d848 4
@


10.32
log
@fixed FPI_FREE macro
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.31 94/08/22 19:43:32 butler Exp Locker: butler $
d853 2
@


10.31
log
@added NMG_FPI_FREE() macro
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.30 94/05/24 17:27:35 butler Exp Locker: butler $
d676 3
a678 2
#define NMG_FPI_FREE( _fpi ) {	(void)rt_free( (char *)_fpi->tbl ); \
				(void)rt_free( (char *)_fpi ); }
@


10.30
log
@added definitions of structures used in nmg_class_pt_fu_except()
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.29 94/04/20 20:41:52 mike Exp Locker: butler $
d676 2
@


10.29
log
@Added NMG_TBL_LASTADDR, NMG_ARE_EUS_ADJACENT (new name for EDGESADJ)
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.28 94/03/18 18:35:32 butler Exp Locker: mike $
d645 47
@


10.28
log
@added NMG_CLASS_Unknown
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.27 1994/01/14 03:11:00 mike Exp butler $
d59 3
a61 3
#define DEBUG_PL_ANIM	0x00000001	/* 1 mged animated evaluation */
#define DEBUG_PL_SLOW	0x00000002	/* 2 add delays to animation */
#define DEBUG_GRAPHCL	0x00000004	/* 3 graphic classification */
d120 1
a120 1
#define OT_NONE     0    /* no orientation */
d151 6
a156 1
/* For those routines that have to "peek" a little */
d158 1
d219 1
a219 7
#define NMG_TEST_LOOPUSE(_p) \
	if (!(_p)->up.magic_p || !(_p)->l.forw || !(_p)->l.back || \
	    !(_p)->l_p || !(_p)->lumate_p || !(_p)->down.magic_p) { \
		rt_log("at %d in %s BAD loopuse member pointer\n", \
			__LINE__, __FILE__); nmg_pr_lu(_p, (char *)NULL); \
			rt_bomb("Null pointer\n"); }

d579 2
a580 2
 *  Since nmg_mk.c is the only source file which should perform these
 *  most fundamental operations, the macros do not belong in nmg.h
d632 6
a637 5
/* two edges share same vertices */
#define EDGESADJ(_e1, _e2) (((_e1)->vu_p->v_p == (_e2)->vu_p->v_p && \
		 (_e1)->eumate_p->vu_p->v_p == (_e2)->eumate_p->vu_p->v_p) || \
		 ((_e1)->vu_p->v_p == (_e2)->eumate_p->vu_p->v_p && \
		 (_e1)->eumate_p->vu_p->v_p == (_e2)->vu_p->v_p ) )
d639 4
a642 2
/* Used by nmg_class.c */
#define EUPRINT(_s, _eu)	nmg_euprint( (_s), (_eu) )
@


10.27
log
@Added new macro
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.26 94/01/14 02:32:23 mike Exp Locker: mike $
d109 1
@


10.26
log
@Added DEBUG_BASIC for nmg_mk.c and nmg_mod.c routines to use.
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.25 94/01/06 19:15:46 butler Exp Locker: mike $
d726 3
@


10.25
log
@Added debug flag for traingulation
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.24 93/12/27 22:46:05 mike Exp Locker: butler $
d69 1
a69 1
#define DEBUG_UNUSED	0x00000400	/* 11 UNUSED */
d87 1
a87 1
\017LABEL_PTS\016POLYTO\015MESH_EU\014MESH\013GRAZING\012BOOLEVAL\011CLASSIFY\
@


10.24
log
@Moved bounding box for faces from struct face_g to struct face.
Necessary because face geometry is now shared by multiple faces
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.23 93/12/23 05:37:02 mike Exp Locker: mike $
d83 1
d85 3
a87 3
"\020\030RT_ISECT\027RT_SEGS\026FCUT\025VU_SORT\024CUTLOOP\023CMFACE\022FINDEU\021RT_ISECT\020TBL_INS\
\017LABEL_PTS\016POLYTO\015MESH_EU\
\014MESH\013GRAZING\012BOOLEVAL\011CLASSIFY\
@


10.23
log
@Prepare to move faceuse bounding boxes to faceuse_a
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.22 93/12/10 05:15:03 mike Exp Locker: mike $
d332 4
d343 2
a344 2
#if 1
/* XXX This moves to faceuse_a */
a363 2
	point_t			min_pt;	/* minimums of bounding box */
	point_t			max_pt;	/* maximums of bounding box */
@


10.22
log
@Added CONST to registers for NMG_GET_FU_NORMAL() and NMG_GET_FU_PLANE().
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.21 93/12/06 21:36:02 mike Exp Locker: mike $
d339 2
d343 1
d360 2
@


10.21
log
@NMG_GET_FU_PLANE() had a missing minus sign.
Replaced with a call to HREVERSE().
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.20 93/12/03 03:35:58 mike Exp Locker: mike $
d362 2
a363 2
	register struct faceuse	*_fu1 = (_fu); \
	register struct face_g	*_fg; \
d376 2
a377 2
	register struct faceuse	*_fu1 = (_fu); \
	register struct face_g	*_fg; \
@


10.20
log
@Supplemented NMG_GET_FU_NORMAL() with NMG_GET_FU_PLANE().
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.19 93/11/18 01:36:53 mike Exp Locker: mike $
d383 1
a383 2
		VREVERSE( _N, _fg->N); \
		(_N)[3] = _fg->N[3]; \
@


10.19
log
@face_g structs now have a list (head) of face structs that refer to them.
@
text
@d33 1
a33 1
 *  $Header: /n/wolf/m/cad/h/RCS/nmg.h,v 10.18 93/10/02 01:07:57 butler Exp $
d360 1
d362 8
a369 4
	NMG_CK_FACEUSE(_fu); \
	if( (fu->orientation != OT_SAME) != (fu->f_p->flip != 0) )  { \
		VREVERSE(_N, fu->f_p->fg_p->N); \
		_N[3] = fu->f_p->fg_p->N[3]; \
d371 16
a386 1
		HMOVE( _N, fu->f_p->fg_p->N ); \
@


10.18
log
@Added DEBUG_RT_SEGS, DEBUG_RT_ISECT, and added them to the
bit-vector text string.
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.17 93/09/01 16:32:34 butler Exp Locker: butler $
d328 1
a328 1
	long	   		magic;
d331 1
d337 1
d359 9
@


10.17
log
@moved definition of struct nmg_specific to nmg_rt.h
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.16 93/07/20 15:23:35 mike Exp Locker: butler $
d75 1
a75 1
#define DEBUG_NMGRT     0x00010000	/* 17 ray tracing */
d81 2
a82 1

d84 3
a86 4
"\020\026FCUT\025VU_SORT\024CUTLOOP\023CMFACE\022FINDEU\021NMGRT\020TBL_INS\
\017LABEL_PTS\016POLYTO\015MESH_EU\014MESH\
\013GRAZING\
\012BOOLEVAL\011CLASSIFY\
@


10.16
log
@Another nested comment.
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.15 93/07/20 15:20:01 mike Exp Locker: mike $
a603 9

/* This is the solid information specific to an nmg solid */
struct nmg_specific {
	int		nmg_smagic;
	vect_t		nmg_V;	/* */
	struct model	*nmg_model;
	vect_t		nmg_invdir;
	int		nmg_emagic;
};
@


10.15
log
@Eliminated nested comment warning
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.14 93/06/04 16:32:13 butler Exp Locker: mike $
d703 3
a705 1
/* #define NMG_DANGLING	8 /* NMG_2MANIFOLD + 4th bit for special cond */
@


10.14
log
@MODEL_SEEN functionality is folded in with NMG_H definition
@
text
@d22 4
a25 4
 *	#include "machine.h"	/* For fastf_t definition on this machine *_/
 *	#include "vmath.h"	/* For vect_t definition *_/
 *	#include "rtlist.h"	/* OPTIONAL, auto-included by raytrace.h *_/
 *	#include "rtstring.h"	/* OPTIONAL, auto-included by raytrace.h *_/
d28 1
a28 1
 *	#include "nurb.h"	/* OPTIONAL, follows raytrace.h when used *_/
d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.13 93/05/15 00:00:56 mike Exp Locker: butler $
@


10.13
log
@Shuffled some debug bits, added NMG_INDEX_CLEAR
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.12 93/04/07 06:14:47 mike Exp Locker: mike $
a251 2
#if !defined(MODEL_DEFINED)
#define MODEL_DEFINED
a259 1
#endif /* !MODEL_DEFINED */
a268 2
#if !defined(NMGREGION_DEFINED)
#define NMGREGION_DEFINED
a275 1
#endif /* !NMGREGION_DEFINED */
@


10.12
log
@Added NMG_VERIFY
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.11 93/04/03 01:12:14 mike Exp Locker: mike $
d61 3
a63 3

#define DEBUG_PLOTEM	0x00000008	/* 4 make plots in debugged routines (needs other flags set too) */
#define DEBUG_CUTLOOP	0x00000010	/* 5 nmg_mod: nmg_cut_loop */
d78 1
a78 1
#define DEBUG_GRAPHCL	0x00080000	/* 20 graphic classification */
d83 1
a83 1
"\020\026FCUT\025VU_SORT\024GRAPHCL\023CMFACE\022FINDEU\021NMGRT\020TBL_INS\
d87 1
a87 1
\010BOOL\7VERIFY\6POLYSECT\5CUTLOOP\4PLOTEM\3XXX\2PL_SLOW\1PL_ANIM"
d693 1
@


10.11
log
@Added 2 new macros:  NMG_INDEX_GET and NMG_INDEX_GETP
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.10 93/04/02 02:59:10 butler Exp Locker: mike $
d62 1
d65 1
a65 1
#define DEBUG_PLOTEM	0x00000040	/* 7 make plots in debugged routined */
d87 1
a87 1
\010BOOL\7PLOTEM\6POLYSECT\5CUTLOOP\4XXX\3XXX\2PL_SLOW\1PL_ANIM"
@


10.10
log
@migrated definition of nmg specific solid information structure from
g_nmg.c
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/nmg.h,v 10.9 93/04/01 05:11:12 mike Exp Locker: butler $
d697 2
@


10.9
log
@Added #include sequencing
Added nmg_ptbl magic number
@
text
@d33 1
a33 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.26 93/04/01 03:56:07 mike Exp $
d609 9
@


10.8
log
@Added better description of lists headed by the shell.
Updated comments on DEBUG_xxx macros.
@
text
@d8 1
a8 2
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
d12 1
a12 1
 *	This software is Copyright (C) 1989 by the United States Army.
d19 15
a33 9
 *  Note -
 *	Any program that uses this header file must also include
 *	these other header files, in this order:
 *		<stdio.h>
 *		<math.h>
 *		"machine.h"
 *		"vmath.h"
 *		"nmg.h"		(This file)
 *		"raytrace.h"
d140 1
d145 2
@


10.7
log
@Added back in the GET_LOOP FREE_LOOP stuff, as it crops up
in g_nmg.c too.  (oops).
Removed some macros that are no longer being used.
@
text
@d57 10
a66 10
#define DEBUG_CUTLOOP	0x00000010	/* 5 cutting loops in two */
#define DEBUG_POLYSECT	0x00000020	/* 6 combine() */
#define DEBUG_PLOTEM	0x00000040	/* 7 combine() */
#define DEBUG_BOOL	0x00000080	/* 8 combine() */
#define DEBUG_CLASSIFY	0x00000100	/* 9 combine() */
#define DEBUG_BOOLEVAL	0x00000200	/* 10 boolean evaluation steps */
#define DEBUG_GRAZING	0x00000400	/* 11 combine() */
#define DEBUG_MESH	0x00000800	/* 12 combine() */
#define DEBUG_MESH_EU	0x00001000	/* 13 combine() */
#define DEBUG_POLYTO	0x00002000	/* 14 combine() */
d70 2
a71 2
#define DEBUG_FINDEU	0x00020000	/* 18 findeu (find edge[use]) */
#define DEBUG_CMFACE	0x00040000	/* 19 nmg_cmface() */
d283 15
d305 1
a305 1
	struct rt_list		lu_hd;	/* loop uses (edge groups) in shell */
@


10.6
log
@Moved GET_struct and FREE_struct off into nmg_mk.c,
which is the only module that is allowed to create and destroy
fundamental structures.
@
text
@a185 12
/*
#define NMG_CK_FACE_G(_p)	{ \
NMG_CKMAG(_p, NMG_FACE_G_MAGIC, "face_g") \
if ( (_p)->N[X] == 0.0 && (_p)->N[Y] == 0.0 && (_p)->N[Z] == 0.0 && \
(_p)->N[H] != 0.0) { \
rt_log( \
"ERROR: in file %s, line %d\nbad NMG plane equation %fX + %fY + %fZ = %f\n", \
__FILE__, __LINE__, \
(_p)->N[X], (_p)->N[Y], (_p)->N[Z], (_p)->N[H]); \
rt_bomb("Bad NMG geometry\n"); \
} }
*/
d520 9
d530 21
a550 2
/* compare value to min/max and do appropriate assignments */
#define MINMAX(_a, _b, _c) { if (_a < _b) _b = _a; if (_a > _c) _c = _a; }
d552 22
a573 4
/* compare two extents and if they overlap, return non-zero */
#define NMG_EXTENT_OVERLAP(_l1, _h1, _l2, _h2) \
    (! ((_l1)[0] > (_h2)[0] || (_l1)[1] > (_h2)[1] || (_l1)[2] > (_h2)[2] || \
	(_l2)[0] > (_h1)[0] || (_l2)[1] > (_h1)[1] || (_l2)[2] > (_h1)[2]) )
d581 1
a581 11
/* Minimum distance from a point to a plane */
#define NMG_DIST_PT_PLANE(_pt, _pl) (VDOT(_pt, _pl) - (_pl)[H])
/*#define NMG_DIST_PT_PLANE(_pt, _pl) pnt_pln_dist(_pt, _pl) */

#ifndef MAXVAL
# define MAXVAL(_a, _b) ((_a) > (_b) ? (_a) : (_b))
#endif
#ifndef MINVAL
# define MINVAL(_a, _b) ((_a) < (_b) ? (_a) : (_b))
#endif

@


10.5
log
@Improved commenting
Added nmg_visit_handlers structure
@
text
@d507 1
a517 25
#define NMG_INCR_INDEX(_p,_m)	\
	NMG_CK_MODEL(_m); (_p)->index = ((_m)->maxindex)++

#define GET_MODEL_A(p,m)    {NMG_GETSTRUCT(p, model_a); NMG_INCR_INDEX(p,m);}
#define GET_REGION(p,m)	    {NMG_GETSTRUCT(p, nmgregion); NMG_INCR_INDEX(p,m);}
#define GET_REGION_A(p,m)   {NMG_GETSTRUCT(p, nmgregion_a); NMG_INCR_INDEX(p,m);}
#define GET_SHELL(p,m)	    {NMG_GETSTRUCT(p, shell); NMG_INCR_INDEX(p,m);}
#define GET_SHELL_A(p,m)    {NMG_GETSTRUCT(p, shell_a); NMG_INCR_INDEX(p,m);}
#define GET_FACE(p,m)	    {NMG_GETSTRUCT(p, face); NMG_INCR_INDEX(p,m);}
#define GET_FACE_G(p,m)	    {NMG_GETSTRUCT(p, face_g); NMG_INCR_INDEX(p,m);}
#define GET_FACEUSE(p,m)    {NMG_GETSTRUCT(p, faceuse); NMG_INCR_INDEX(p,m);}
#define GET_FACEUSE_A(p,m)  {NMG_GETSTRUCT(p, faceuse_a); NMG_INCR_INDEX(p,m);}
#define GET_LOOP(p,m)	    {NMG_GETSTRUCT(p, loop); NMG_INCR_INDEX(p,m);}
#define GET_LOOP_G(p,m)	    {NMG_GETSTRUCT(p, loop_g); NMG_INCR_INDEX(p,m);}
#define GET_LOOPUSE(p,m)    {NMG_GETSTRUCT(p, loopuse); NMG_INCR_INDEX(p,m);}
#define GET_LOOPUSE_A(p,m)  {NMG_GETSTRUCT(p, loopuse_a); NMG_INCR_INDEX(p,m);}
#define GET_EDGE(p,m)	    {NMG_GETSTRUCT(p, edge); NMG_INCR_INDEX(p,m);}
#define GET_EDGE_G(p,m)	    {NMG_GETSTRUCT(p, edge_g); (p)->usage = 1; NMG_INCR_INDEX(p,m);}
#define GET_EDGEUSE(p,m)    {NMG_GETSTRUCT(p, edgeuse); NMG_INCR_INDEX(p,m);}
#define GET_EDGEUSE_A(p,m)  {NMG_GETSTRUCT(p, edgeuse_a); NMG_INCR_INDEX(p,m);}
#define GET_VERTEX(p,m)	    {NMG_GETSTRUCT(p, vertex); NMG_INCR_INDEX(p,m);}
#define GET_VERTEX_G(p,m)   {NMG_GETSTRUCT(p, vertex_g); NMG_INCR_INDEX(p,m);}
#define GET_VERTEXUSE(p,m)  {NMG_GETSTRUCT(p, vertexuse); NMG_INCR_INDEX(p,m);}
#define GET_VERTEXUSE_A(p,m) {NMG_GETSTRUCT(p, vertexuse_a); NMG_INCR_INDEX(p,m);}

d519 1
a519 1
# define FREESTRUCT(ptr, str) \
d523 1
a523 1
# define FREESTRUCT(ptr, str) \
a526 23

#define FREE_MODEL(p)	    FREESTRUCT(p, model)
#define FREE_MODEL_A(p)	    FREESTRUCT(p, model_a)
#define FREE_REGION(p)	    FREESTRUCT(p, nmgregion)
#define FREE_REGION_A(p)    FREESTRUCT(p, nmgregion_a)
#define FREE_SHELL(p)	    FREESTRUCT(p, shell)
#define FREE_SHELL_A(p)	    FREESTRUCT(p, shell_a)
#define FREE_FACE(p)	    FREESTRUCT(p, face)
#define FREE_FACE_G(p)	    FREESTRUCT(p, face_g)
#define FREE_FACEUSE(p)	    FREESTRUCT(p, faceuse)
#define FREE_FACEUSE_A(p)   FREESTRUCT(p, faceuse_a)
#define FREE_LOOP(p)	    FREESTRUCT(p, loop)
#define FREE_LOOP_G(p)	    FREESTRUCT(p, loop_g)
#define FREE_LOOPUSE(p)	    FREESTRUCT(p, loopuse)
#define FREE_LOOPUSE_A(p)   FREESTRUCT(p, loopuse_a)
#define FREE_EDGE(p)	    FREESTRUCT(p, edge)
#define FREE_EDGE_G(p)	    if (--((p)->usage) <= 0)  FREESTRUCT(p, edge_g)
#define FREE_EDGEUSE(p)	    FREESTRUCT(p, edgeuse)
#define FREE_EDGEUSE_A(p)   FREESTRUCT(p, edgeuse_a)
#define FREE_VERTEX(p)	    FREESTRUCT(p, vertex)
#define FREE_VERTEX_G(p)    FREESTRUCT(p, vertex_g)
#define FREE_VERTEXUSE(p)   FREESTRUCT(p, vertexuse)
#define FREE_VERTEXUSE_A(p) FREESTRUCT(p, vertexuse_a)
@


10.4
log
@Eliminated the obsolete DEBUG_COMBINE,
replaced with DEBUG_VU_SORT and DEBUG_FCUT.
@
text
@d83 13
d416 1
a416 1
 *  To find all the uses of this edge, use eu_p for one edge,
d418 8
d701 57
@


10.3
log
@Changed bit assignments for debugging, added DEBUG_GRAPHCL
@
text
@a56 1
#define DEBUG_COMBINE	0x00000008	/* 4 combine() */
a69 1

d73 3
d77 1
a77 1
"\020\024GRAPHCL\023CMFACE\022FINDEU\021NMGRT\020TBL_INS\
d81 1
a81 1
\010BOOL\7PLOTEM\6POLYSECT\5CUTLOOP\4COMBINE\3XXX\2PL_SLOW\1PL_ANIM"
@


10.2
log
@In order to reduce the size of executables, changed CKMAG macros to
call the subroutine rt_badmagic() when a problem is encountered,
rather than having all the code inline for every check.
@
text
@d56 1
a70 2
#define DEBUG_FINDEU	0x00100000	/* 21 findeu (find edge[use]) */
#define DEBUG_CMFACE	0x00200000	/* 22 nmg_cmface() */
d72 3
d76 1
a76 1
"\020\026CMFACE\025FINDEU\021NMGRT\020TBL_INS\
@


10.1
log
@Release_4.0
@
text
@d158 2
a159 10
	if( !(_ptr) )  { \
		rt_log("ERROR: NMG null %s ptr, file %s, line %d\n", \
			_str, __FILE__, __LINE__ ); \
		rt_bomb("NULL NMG pointer"); \
	} else if( *((long *)(_ptr)) != (_magic) )  { \
		rt_log("ERROR: NMG bad %s ptr x%x, s/b x%x, was %s(x%x), file %s, line %d\n", \
			_str, _ptr, _magic, \
			rt_identify_magic( *((long *)(_ptr)) ), \
			*((long *)(_ptr)), __FILE__, __LINE__ ); \
		rt_bomb("Bad NMG pointer"); \
@


1.50
log
@Added "is_real" flag to edge.
Added e_pt and e_dir to edge_g.
@
text
@@


1.49
log
@Changed dangling and 3manifold
@
text
@d415 1
d421 3
d518 1
a518 1
#define GET_EDGE_G(p,m)	    {NMG_GETSTRUCT(p, edge_g); NMG_INCR_INDEX(p,m);}
d551 1
a551 1
#define FREE_EDGE_G(p)	    FREESTRUCT(p, edge_g)
@


1.48
log
@comment
@
text
@d672 1
a672 1
#define NMG_3MANIFOLD	0	/* zero, not eight */
d676 1
a676 1
#define NMG_DANGLING	8 /* NMG_2MANIFOLD + 4th bit for special cond */
@


1.47
log
@Moved NMG subroutine declarations from nmg.h to raytrace.h,
to avoid circularity in defining types of args to the functions.
@
text
@d21 8
a28 1
 *	Any program that uses this header file must also include <stdio.h>
@


1.46
log
@added pointer to table "manifolds" in model structure to hold pointer to
index table storing 0/1/2/3-manifold status for elements.  Also added
macros for manipulating MANIFOLD-edness flags
@
text
@d44 1
a44 11
/*
 *  A macro for providing function prototypes, regardless of whether
 *  the compiler understands them or not.
 *  It is vital that the argument list given for "args" be enclosed
 *  in parens.
 */
#if USE_PROTOTYPES
#	define	NMG_EXTERN(type_and_name,args)	extern type_and_name args
#else
#	define	NMG_EXTERN(type_and_name,args)	extern type_and_name()
#endif
d46 1
a480 3
NMG_EXTERN(char *rt_malloc, (unsigned int cnt, char *str) );
NMG_EXTERN(char *rt_calloc,(unsigned nelem, unsigned elsize, char *str));
NMG_EXTERN(void rt_free, (char *ptr, char *str) );
a673 192


/************************************************************************
 *									*
 *			Support Function Declarations			*
 *									*
 ************************************************************************/

/* From file nmg_mk.c */
NMG_EXTERN(struct model		*nmg_find_model, (long *magic_p) );
NMG_EXTERN(struct model		*nmg_mm, () );
NMG_EXTERN(struct model		*nmg_mmr, () );
NMG_EXTERN(struct nmgregion	*nmg_mrsv, (struct model *m) );
NMG_EXTERN(struct shell 	*nmg_msv, (struct nmgregion *r_p) );
NMG_EXTERN(struct vertexuse	*nmg_mvu, (struct vertex *v, long *upptr) );
NMG_EXTERN(struct vertexuse	*nmg_mvvu, (long *upptr) );
NMG_EXTERN(struct edgeuse	*nmg_me, (struct vertex *v1, struct vertex *v2, struct shell *s) );
NMG_EXTERN(struct edgeuse	*nmg_meonvu, (struct vertexuse *vu) );
NMG_EXTERN(struct loopuse	*nmg_ml, (struct shell *s) );
NMG_EXTERN(void			nmg_movevu, (struct vertexuse *vu, struct vertex *v) );
NMG_EXTERN(void			nmg_kvu, (struct vertexuse *vu) );
NMG_EXTERN(void			nmg_kfu, (struct faceuse *fu1) );
NMG_EXTERN(void			nmg_klu, (struct loopuse *lu1) );
NMG_EXTERN(struct faceuse	*nmg_mf, (struct loopuse *lu1) );
NMG_EXTERN(void			nmg_keu, (struct edgeuse *eu) );
NMG_EXTERN(void			nmg_ks, (struct shell *s) );
NMG_EXTERN(void			nmg_kr, (struct nmgregion *r) );
NMG_EXTERN(void			nmg_km, (struct model *m) );
NMG_EXTERN(void			nmg_vertex_gv, (struct vertex *v, pointp_t pt) );
NMG_EXTERN(void			nmg_loop_g, (struct loop *l) );
NMG_EXTERN(void			nmg_face_g, (struct faceuse *fu, plane_t p) );
NMG_EXTERN(void			nmg_face_bb, (struct face *f) );
NMG_EXTERN(void			nmg_shell_a, (struct shell *s) );
NMG_EXTERN(void			nmg_region_a, (struct nmgregion *r) );
NMG_EXTERN(struct loopuse	*nmg_mlv, (long *magic, struct vertex *v, int orientation) );
NMG_EXTERN(int			nmg_demote_lu, (struct loopuse *lu) );
NMG_EXTERN(void			nmg_ensure_vertex, (struct vertex *v,
				struct shell *s) );
NMG_EXTERN(int			nmg_demote_eu, (struct edgeuse *eu) );
/* nmg_eu_sq */

/* From nmg_mod.c */
NMG_EXTERN(int			nmg_fu_planeeqn, (struct faceuse *fu, CONST struct rt_tol *tol) );
NMG_EXTERN(struct faceuse	*nmg_cface, (struct shell *s, struct vertex **vt,	int n) );
NMG_EXTERN(struct faceuse	*nmg_cmface, (struct shell *s, struct vertex **vt[], int n) );
NMG_EXTERN(struct edgeuse	*nmg_eusplit, (struct vertex *v, struct edgeuse *oldeu) );
NMG_EXTERN(void			nmg_moveeu, (struct edgeuse *eudst, struct edgeuse *eusrc) );
NMG_EXTERN(void			nmg_unglueedge, (struct edgeuse *eu) );
NMG_EXTERN(void			nmg_jv, (struct vertex *v1, struct vertex *v2) );
NMG_EXTERN(void 		nmg_moveltof, (struct faceuse *fu, struct shell *s) );
NMG_EXTERN(struct edge		*nmg_esplit, (struct vertex *v, struct edge *e) );
NMG_EXTERN(struct edgeuse	*nmg_eins, (struct edgeuse *eu) );
NMG_EXTERN(struct vertexuse	*nmg_find_vu_in_face, (CONST point_t pt, struct faceuse *fu, CONST struct rt_tol *tol) );
NMG_EXTERN(void			nmg_gluefaces, (struct faceuse *fulist[], int n) );
NMG_EXTERN(struct edgeuse	*nmg_findeu, (struct vertex *v1, struct vertex *v2, struct shell *s, struct edgeuse *eup) );
NMG_EXTERN(void			nmg_jl, (struct loopuse *lu, struct edgeuse *eu) );
NMG_EXTERN(void			nmg_simplify_loop, (struct loopuse *lu) );
NMG_EXTERN(void			nmg_kill_snakes, (struct loopuse *lu) );
NMG_EXTERN(void			nmg_simplify_face, (struct faceuse *fu) );
NMG_EXTERN(void			nmg_simplify_shell, (struct shell *s) );
NMG_EXTERN(void			nmg_ck_lueu, (struct loopuse *lu, char *s) );
NMG_EXTERN(void			nmg_cut_loop, (struct vertexuse *vu1, struct vertexuse *vu2) );
NMG_EXTERN(struct loopuse	*nmg_split_lu_at_vu, (struct loopuse *lu, struct vertexuse *vu) );
NMG_EXTERN(void			nmg_split_touchingloops, (struct loopuse *lu) );
NMG_EXTERN(void			nmg_ck_list, (struct rt_list *hd, CONST char *str) );
NMG_EXTERN(void			nmg_move_fu_fu, (struct faceuse *dest, struct faceuse *src) );

/* From nmg_misc.c */
NMG_EXTERN(int			nmg_tbl, (struct nmg_ptbl *b, int func, long *p) );
NMG_EXTERN(int			nmg_in_or_ref, (struct vertexuse *vu, struct nmg_ptbl *b) );
NMG_EXTERN(void			nmg_pr_orient, (int orientation, char *h) );
NMG_EXTERN(void			nmg_pr_m, (struct model *m) );
NMG_EXTERN(void			nmg_pr_r, (struct nmgregion *r, char *h) );
NMG_EXTERN(void			nmg_pr_sa, (struct shell_a *sa, char *h) );
NMG_EXTERN(void			nmg_pr_lg, (struct loop_g *lg, char *h) );
NMG_EXTERN(void			nmg_pr_fg, (struct face_g *fg, char *h) );
NMG_EXTERN(void			nmg_pr_s, (struct shell *s, char *h) );
NMG_EXTERN(void			nmg_pr_f, (struct face *f, char *h) );
NMG_EXTERN(void			nmg_pr_fu, (struct faceuse *fu, char *h) );
NMG_EXTERN(void			nmg_pr_l, (struct loop *l, char *h) );
NMG_EXTERN(void			nmg_pr_lu, (struct loopuse *lu, char *h) );
NMG_EXTERN(void			nmg_pr_e, (struct edge *e, char *h) );
NMG_EXTERN(void			nmg_pr_eu, (struct edgeuse *eu, char *h) );
NMG_EXTERN(void			nmg_pr_vg, (struct vertex_g *vg, char *h) );
NMG_EXTERN(void			nmg_pr_v, (struct vertex *v, char *h) );
NMG_EXTERN(void			nmg_pr_vu, (struct vertexuse *vu, char *h) );
/* static nmg_check_radial */
NMG_EXTERN(int			nmg_ck_closed_surf, (struct shell *s) );
NMG_EXTERN(int			nmg_ck_closed_region, (struct nmgregion *r) );
NMG_EXTERN(struct shell		*nmg_polytonmg, (FILE *fp, struct nmgregion *r, CONST struct rt_tol *tol) );
NMG_EXTERN(struct loopuse	*nmg_lu_of_vu, (struct vertexuse *vu) );
NMG_EXTERN(struct shell		*nmg_lups, (struct loopuse *lu) );
NMG_EXTERN(struct shell		*nmg_eups, (struct edgeuse *eu) );
NMG_EXTERN(struct edgeuse	*nmg_faceradial, (struct edgeuse *eu) );
NMG_EXTERN(int			nmg_manifold_face, (struct faceuse *fu) );
NMG_EXTERN(void			nmg_euprint, (char *str, struct edgeuse *eu) );
NMG_EXTERN(char 		*nmg_manifolds, (struct model *m) );
NMG_EXTERN(char 		*nmg_shell_manifolds, (struct shell *sp, char *tbl) );
NMG_EXTERN(struct edgeuse	*nmg_radial_face_edge_in_shell, (struct edgeuse *eu) );
/* g_nmg.c */

/* nmg_class.c */
NMG_EXTERN(int			nmg_pt_hitmis_f, (point_t pt, struct faceuse *fu, CONST struct rt_tol *tol, long *novote) );

/* From nmg_plot.c */
NMG_EXTERN(struct rt_vlblock *	rt_vlblock_init, () );
NMG_EXTERN(void			rt_vlblock_free, (struct rt_vlblock *vbp) );
NMG_EXTERN(struct rt_list *	rt_vlblock_find, (struct rt_vlblock *vbp,
				int r, int g, int b) );
/* add nmg_xxx_to_vlist routines here */
NMG_EXTERN(void			nmg_pl_v, (FILE	*fp, struct vertex *v,
				long *b) );
NMG_EXTERN(void			nmg_pl_e, (FILE *fp, struct edge *e,
				long *b, int red, int green, int blue) );
NMG_EXTERN(void			nmg_pl_eu, (FILE *fp, struct edgeuse *eu,
				long *b, int red, int green, int blue) );
NMG_EXTERN(void			nmg_pl_lu, (FILE *fp, struct loopuse *fu, 
				long *b, int red, int green, int blue) );
NMG_EXTERN(void			nmg_pl_fu, (FILE *fp, struct faceuse *fu,
				long *b, int red, int green, int blue ) );
NMG_EXTERN(void			nmg_pl_s, (FILE *fp, struct shell *s) );
NMG_EXTERN(void			nmg_pl_r, (FILE *fp, struct nmgregion *r) );
NMG_EXTERN(void			nmg_pl_m, (FILE *fp, struct model *m) );
NMG_EXTERN(void			nmg_vlblock_v, (struct rt_vlblock *vbp,
				struct vertex *v, long *tab) );
NMG_EXTERN(void			nmg_vlblock_e, (struct rt_vlblock *vbp,
				struct edge *e, long *tab,
				int red, int green, int blue, int fancy) );
NMG_EXTERN(void			nmg_vlblock_eu, (struct rt_vlblock *vbp,
				struct edgeuse *eu, long *tab,
				int red, int green, int blue, int fancy) );
NMG_EXTERN(void			nmg_vlblock_lu, (struct rt_vlblock *vbp,
				struct loopuse *lu, long *tab,
				int red, int green, int blue, int fancy) );
NMG_EXTERN(void			nmg_vlblock_fu, (struct rt_vlblock *vbp,
				struct faceuse *fu, long *tab, int fancy) );
NMG_EXTERN(void			nmg_vlblock_s, (struct rt_vlblock *vbp,
				struct shell *s, int fancy) );
NMG_EXTERN(void			nmg_vlblock_r, (struct rt_vlblock *vbp,
				struct nmgregion *r, int fancy) );
NMG_EXTERN(void			nmg_vlblock_m, (struct rt_vlblock *vbp,
				struct model *m, int fancy) );
NMG_EXTERN(void			nmg_pl_around_edge, (FILE *fd,
				long *b, struct edgeuse *eu) );
NMG_EXTERN(void			nmg_pl_edges_in_2_shells, (FILE *fd,
				long *b, struct edgeuse *eu) );
NMG_EXTERN(void			nmg_pl_isect, (char *filename,
				struct shell *s) );
NMG_EXTERN(void			nmg_pl_comb_fu, (int num1, int num2,
				struct faceuse *fu1) );
NMG_EXTERN(void			nmg_pl_2fu, (char *str, int num,
				struct faceuse *fu1, struct faceuse *fu2,
				int show_mates) );

/* from nmg_mesh.c */
NMG_EXTERN(void			nmg_mesh_faces, (struct faceuse *fu1,
				struct faceuse *fu2) );

/* from nmg_bool.c */
NMG_EXTERN(struct nmgregion	*nmg_do_bool, (struct nmgregion *s1,
				struct nmgregion *s2,
				CONST int oper, CONST struct rt_tol *tol) );
NMG_EXTERN(void			nmg_shell_coplanar_face_merge,
				(struct shell *s, CONST struct rt_tol *tol,
				CONST int simplify) );

/* from nmg_class.c */
NMG_EXTERN(void			nmg_class_shells, (struct shell *sA,
				struct shell *sB, long *classlist[4],
				CONST struct rt_tol *tol) );

/* from nmg_comb.c */
NMG_EXTERN(void			nmg_ck_lueu, (struct loopuse *cklu, char *s) );
NMG_EXTERN(void			nmg_face_combine, (struct nmg_ptbl *b,
				struct faceuse *fu1, struct faceuse *fu2,
				point_t pt, vect_t dir) );

#define nmg_mev(_v, _u)	nmg_me((_v), (struct vertex *)NULL, (_u))

/* From nmg_inter.c */
NMG_EXTERN(void			nmg_crackshells, (struct shell *s1, struct shell *s2, CONST struct rt_tol *tol) );

/* From nmg_index.c */
NMG_EXTERN(int			nmg_index_of_struct, (long *p) );
NMG_EXTERN(void			nmg_m_reindex, (struct model *m) );
NMG_EXTERN(void			nmg_pr_struct_counts, 
				(struct nmg_struct_counts *ctr, char *str) );
NMG_EXTERN(long			**nmg_m_struct_count,
				(struct nmg_struct_counts *ctr,
				struct model *m) );

/* From nmg_rt.c */
@


1.45
log
@CONST fiddlign
@
text
@d104 2
d256 1
d672 3
d676 6
d683 5
d782 3
a784 1

@


1.44
log
@Added DEBUG_PL_SLOW
@
text
@d721 1
a721 1
NMG_EXTERN(struct vertexuse	*nmg_find_vu_in_face, (point_t pt, struct faceuse *fu, CONST struct rt_tol *tol) );
d733 1
a733 1
NMG_EXTERN(void			nmg_ck_list, (CONST struct rt_list *hd, CONST char *str) );
@


1.43
log
@Added declarations
@
text
@d57 1
a57 2
#define DEBUG_FINDEU	0x00000002	/* 2 findeu (find edge[use]) */
#define DEBUG_CMFACE	0x00000004	/* 3 nmg_cmface() */
d71 3
a73 1
#define DEBUG_NMGRT     0x00010000	/* ray tracing */
d76 2
a77 1
"\021\021NMGRAYTR\020TBL_INS\017LABEL_PTS\016POLYTO\015MESH_EU\014MESH\
d80 1
a80 1
\010BOOL\7PLOTEM\6POLYSECT\5CUTLOOP\4COMBINE\3CMFACE\2FINDEU\1PL_ANIM"
@


1.42
log
@Added declarations, and new args
@
text
@d703 2
d732 1
d827 8
a834 2
NMG_EXTERN(void			nmg_ensure_vertex, (struct vertex *v,
				struct shell *s) );
@


1.41
log
@Added routines
@
text
@a683 1
NMG_EXTERN(void			nmg_ck_list, (struct rt_list *hd, char *str) );
d701 9
a713 1
NMG_EXTERN(struct loopuse	*nmg_mlv, (long *magic, struct vertex *v, int orientation) );
a714 1
NMG_EXTERN(struct faceuse	*nmg_cface, (struct shell *s, struct vertex **vt,	int n) );
d717 1
a717 1
NMG_EXTERN(struct vertexuse	*nmg_find_vu_in_face, (point_t pt, struct faceuse *fu, fastf_t tol) );
a719 1
NMG_EXTERN(struct faceuse	*nmg_cmface, (struct shell *s, struct vertex **vt[], int n) );
d722 1
a722 1
/* kill_snakes */
d725 5
a729 3
NMG_EXTERN(int			nmg_demote_lu, (struct loopuse *lu) );
NMG_EXTERN(int			nmg_demote_eu, (struct edgeuse *eu) );
/* nmg_eu_sq */
d753 1
a753 2
/* XXX needs new name */
NMG_EXTERN(struct shell		*polytonmg, (FILE *fd, struct nmgregion *r) );
d764 1
a764 1
NMG_EXTERN(int			nmg_pt_hitmis_f, (point_t pt, struct faceuse *fu, fastf_t tol, long *novote) );
d823 1
a823 1
				int oper, fastf_t tol) );
d835 3
d846 3
@


1.40
log
@Extended parameter list to nmg_face_combine
@
text
@d72 1
d75 2
a76 1
"\020\020TBL_INS\017LABEL_PTS\016POLYTO\015MESH_EU\014MESH\013GRAZING\
d754 5
@


1.39
log
@Noted that exterior loops go CCW.
@
text
@d817 2
a818 1
				struct faceuse *fu1, struct faceuse *fu2) );
@


1.38
log
@Added more function prototypes.
All the plotting routines changed to using flags arrays
instead of nmg_ptbl's
@
text
@d359 3
@


1.37
log
@Added macros to deal with arrays of flags subscripted by
NMG structure index values.
@
text
@d741 2
a742 1
/* polytonmg */
d751 48
a798 27
/* rt_vlblock_init, et.al. */
NMG_EXTERN(void		nmg_pl_fu, (FILE *fp, struct faceuse *fu,
					struct nmg_ptbl *b, int red,
					int green, int blue ) );
NMG_EXTERN(void		nmg_pl_lu, (FILE *fp, struct loopuse *fu, 
					struct nmg_ptbl *b, int red,
					int green, int blue) );
NMG_EXTERN(void		nmg_pl_eu, (FILE *fp, struct edgeuse *eu,
					struct nmg_ptbl *b, int red,
					int green, int blue) );
NMG_EXTERN(void		nmg_pl_e, (FILE *fp, struct edge *e,
					struct nmg_ptbl *b, int red,
					int green, int blue) );
NMG_EXTERN(void		nmg_pl_s, (FILE *fp, struct shell *s) );
NMG_EXTERN(void		nmg_pl_r, (FILE *fp, struct nmgregion *r) );
NMG_EXTERN(void		nmg_pl_m, (FILE *fp, struct model *m) );
NMG_EXTERN(void		nmg_mesh_faces, (struct faceuse *fu1, struct faceuse *fu2) );
NMG_EXTERN(void		nmg_isect_faces, (struct faceuse *fu1, struct faceuse *fu2) );
NMG_EXTERN(struct nmgregion	*nmg_do_bool, (struct nmgregion *s1, struct nmgregion *s2, int oper, fastf_t tol) );
NMG_EXTERN(void		nmg_ensure_vertex, (struct vertex *v, struct shell *s) );
NMG_EXTERN(void		nmg_m_to_g, (FILE *fp, struct model *m) );
NMG_EXTERN(void		nmg_r_to_g, (FILE *fp, struct nmgregion *r) );
NMG_EXTERN(void		nmg_s_to_g, (FILE *fp, struct shell *s, unsigned char rgb[]) );
NMG_EXTERN(struct shell	*polytonmg, (FILE *fd, struct nmgregion *r) );
NMG_EXTERN(void		nmg_pr_orient, (int orientation, char *h) );
NMG_EXTERN(void		nmg_ck_lueu, (struct loopuse *cklu, char *s) );
NMG_EXTERN(void		nmg_evu, (struct edgeuse *eu) );
d800 16
d819 7
a825 6
NMG_EXTERN(void		nmg_m_reindex, (struct model *m));
NMG_EXTERN(void		nmg_pr_struct_counts, (struct nmg_struct_counts	*ctr,
			char *str));
NMG_EXTERN(long		**nmg_m_struct_count, (struct nmg_struct_counts *ctr,
			struct model *m));

@


1.36
log
@Added test-and-set macros.
@
text
@d56 1
a56 1
#define DEBUG_INS	0x00000001	/* 1 nmg_tbl table insert */
d71 1
a71 1
#define DEBUG_PL_ANIM	0x00008000	/* 16 mged animate plotting */
d74 1
a74 1
"\020\020PL_ANIM\017LABEL_PTS\016POLYTO\015MESH_EU\014MESH\013GRAZING\
d76 1
a76 1
\010BOOL\7PLOTEM\6POLYSECT\5CUTLOOP\4COMBINE\3CMFACE\2FINDEU\1TBL_INS"
d655 7
a661 5
#define NMG_INDEX_TEST(tab,p)	( (tab)[(p)->index] )
#define NMG_INDEX_SET(tab,p)	(tab)[(p)->index] = 1
#define NMG_INDEX_TEST_AND_SET(tab,p)	\
	( (tab)[(p)->index] == 0 ? ((tab)[(p)->index] = 1) : 0 )
#define NMG_INDEX_FIRST_TIME(tab,p)	NMG_INDEX_TEST_AND_SET(tab,p)
@


1.35
log
@Orientation is now an integer, not a character
@
text
@d643 18
@


1.34
log
@order change
@
text
@d94 5
a98 5
#define OT_NONE     '\0'    /* no orientation */
#define OT_SAME     '\1'    /* orientation same */
#define OT_OPPOSITE '\2'    /* orientation opposite */
#define OT_UNSPEC   '\3'    /* orientation unspecified */
#define OT_BOOLPLACE '\4'   /* object is intermediate data for boolean ops */
a316 1
	unsigned		ref_cnt;
d327 1
a327 1
	char			orientation;  /* rel to face geom defn */
d385 1
a385 1
	char			orientation;  /* OT_SAME=outside loop */
d426 1
a426 1
	char	  		orientation;/* compared to geom (null if wire) */
@


1.33
log
@Changed from NMG_LIST stuff to RT_LIST, as defined in rtlist.h
@
text
@d609 1
a609 1
	/* Actual structure counts */
d616 2
a619 2
	long	faceuse;
	long	faceuse_a;
@


1.32
log
@Type change
@
text
@d36 4
a149 1
#define NMG_LIST_MAGIC		0x8d45a6c8
d161 1
a161 1
			nmg_identify_magic( *((long *)(_ptr)) ), \
d200 1
a200 1
#define NMG_CK_LIST(_p)		NMG_CKMAG(_p, NMG_LIST_MAGIC, "nmg_list")
a220 45

/************************************************************************
 *									*
 *			Doubly-linked list support			*
 *									*
 ************************************************************************/

struct nmg_list  {
	long		magic;
	struct nmg_list	*forw;		/* "forward", "next" */
	struct nmg_list	*back;		/* "back", "last" */
};

/* These macros all expect pointers to nmg_list structures */

/* Insert "new" item in front of "old" item.  Often, "old" is the head. */
/* To put the new item at the tail of the list, insert before the head */
#define NMG_LIST_INSERT(old,new)	{ \
	(new)->back = (old)->back; \
	(old)->back = (new); \
	(new)->forw = (old); \
	(new)->back->forw = (new);  }

/* Append "new" item after "old" item.  Often, "old" is the head. */
/* To put the new item at the head of the list, append after the head */
#define NMG_LIST_APPEND(old,new)	{ \
	(new)->forw = (old)->forw; \
	(new)->back = (old); \
	(old)->forw = (new); \
	(new)->forw->back = (new);  }

/* Dequeue "cur" item from anywhere in doubly-linked list */
#define NMG_LIST_DEQUEUE(cur)	{ \
	(cur)->forw->back = (cur)->back; \
	(cur)->back->forw = (cur)->forw; \
	(cur)->forw = (cur)->back = (struct nmg_list *)NULL; }

/* Test if a doubly linked list is empty, given head pointer */
#define NMG_LIST_IS_EMPTY(hp)	((hp)->forw == (hp))
#define NMG_LIST_NON_EMPTY(hp)	((hp)->forw != (hp))

#define NMG_LIST_INIT(hp)	{ \
	(hp)->forw = (hp)->back = (hp); \
	(hp)->magic = NMG_LIST_MAGIC;	/* sanity */ }

d222 1
a222 53
 *  Macros for walking a linked list, where the first element of
 *  some application structure is an nmg_list structure.
 *  Thus, the pointer to the nmg_list struct is a "pun" for the
 *  application structure as well.
 */
/* Return re-cast pointer to first element on list.
 * No checking is performed to see if list is empty.
 */
#define NMG_LIST_LAST(structure,hp)	\
	((struct structure *)((hp)->back))
#define NMG_LIST_FIRST(structure,hp)	\
	((struct structure *)((hp)->forw))
#define NMG_LIST_NEXT(structure,hp)	\
	((struct structure *)((hp)->forw))
#define NMG_LIST_MORE(p,structure,hp)	\
	((p) != (struct structure *)(hp))
#define NMG_LIST_PNEXT(structure,p)	\
	((struct structure *)(((struct nmg_list *)(p))->forw))
#define NMG_LIST_PLAST(structure,p)	\
	((struct structure *)(((struct nmg_list *)(p))->back))

#define NMG_LIST_PNEXT_PNEXT(structure,p)	\
	((struct structure *)(((struct nmg_list *)(p))->forw->forw))
#define NMG_LIST_PNEXT_PLAST(structure,p)	\
	((struct structure *)(((struct nmg_list *)(p))->forw->back))
#define NMG_LIST_PLAST_PNEXT(structure,p)	\
	((struct structure *)(((struct nmg_list *)(p))->back->forw))
#define NMG_LIST_PLAST_PLAST(structure,p)	\
	((struct structure *)(((struct nmg_list *)(p))->back->back))

/* Intended as innards for a for() loop to visit all nodes on list */
#define NMG_LIST(p,structure,hp)	\
	(p)=NMG_LIST_FIRST(structure,hp); \
	NMG_LIST_MORE(p,structure,hp); \
	(p)=NMG_LIST_PNEXT(structure,p)

/* Return the magic number of the first (or last) item on a list */
#define NMG_LIST_FIRST_MAGIC(hp)	((hp)->forw->magic)
#define NMG_LIST_LAST_MAGIC(hp)		((hp)->back->magic)

/* Return pointer to circular next element; ie, ignoring the list head */
#define NMG_LIST_PNEXT_CIRC(structure,p)	\
	((NMG_LIST_FIRST_MAGIC((struct nmg_list *)(p)) == NMG_LIST_MAGIC) ? \
		NMG_LIST_PNEXT_PNEXT(structure,(struct nmg_list *)(p)) : \
		NMG_LIST_PNEXT(structure,p) )

/* Return pointer to circular last element; ie, ignoring the list head */
#define NMG_LIST_PLAST_CIRC(structure,p)	\
	((NMG_LIST_LAST_MAGIC((struct nmg_list *)(p)) == NMG_LIST_MAGIC) ? \
		NMG_LIST_PLAST_PLAST(structure,(struct nmg_list *)(p)) : \
		NMG_LIST_PLAST(structure,p) )

/*	W A R N I N G !
d226 1
a226 1
 *	This may be either a long, or an nmg_list structure, which
d231 1
a231 1
 *		1) magic number, or nmg_list structure
d248 1
a248 1
	struct nmg_list		r_hd;	/* list of regions */
d265 1
a265 1
	struct nmg_list		l;	/* regions, in model's r_hd list */
d268 1
a268 1
	struct nmg_list		s_hd;	/* list of shells in region */
d284 1
a284 1
	struct nmg_list		l;	/* shells, in region's s_hd list */
d288 3
a290 3
	struct nmg_list		fu_hd;	/* list of face uses in shell */
	struct nmg_list		lu_hd;	/* loop uses (edge groups) in shell */
	struct nmg_list		eu_hd;	/* wire list (shell has wires) */
d325 1
a325 1
	struct nmg_list		l;	/* fu's, in shell's fu_hd list */
d331 1
a331 1
	struct nmg_list		lu_hd;	/* list of loops in face-use */
d348 1
a348 1
 *  But, before using it, check NMG_LIST_FIRST_MAGIC(&lu->down_hd)
d351 1
a351 1
 *  with vu = NMG_LIST_FIRST(vertexuse, &lu->down_hd)
d361 2
a362 2
#define NMG_LIST_SET_DOWN_TO_VERT(_hp,_vu)	{ \
	(_hp)->forw = &((_vu)->l); (_hp)->back = (struct nmg_list *)NULL; }
d379 1
a379 1
	struct nmg_list		l;	/* lu's, in fu's lu_hd, or shell's lu_hd */
d389 1
a389 1
	struct nmg_list		down_hd; /* eu list or vu pointer */
d417 1
a417 1
	struct nmg_list		l;	/* cw/ccw edges in loop or wire edges in shell */
d447 1
a447 1
	struct nmg_list		vu_hd;	/* heads list of vu's of this vertex */
d459 1
a459 1
	struct nmg_list		l;	/* list of all vu's on a vertex */
d660 1
a660 1
NMG_EXTERN(void			nmg_ck_list, (struct nmg_list *hd, char *str) );
a700 1
NMG_EXTERN(char			*nmg_identify_magic, (long magic) );
@


1.31
log
@Added nmg_struct_counts
@
text
@d860 1
a860 1
NMG_EXTERN(void		nmg_m_struct_count, (struct nmg_struct_counts *ctr,
@


1.30
log
@Changed to USE_PROTOTYPES
@
text
@d1 2
a2 1
/*			N M G . H
d702 35
d738 1
d855 7
@


1.29
log
@Add tests and defines for MODEL_DEFINED and NMGREGION_DEFINED
@
text
@d39 12
d336 1
a336 1
#if !defined(MODEL_DEFINED) || !defined(__STDC__)
d345 1
a345 1
#endif /* !MODEL_DEFINED || !__STDC__ */
d355 1
a355 1
#if !defined(NMGREGION_DEFINED) || !defined(__STDC__)
d364 1
a364 1
#endif /* !NMGREGION_DEFINED || !__STDC__ */
d574 4
a578 1
    extern char *rt_calloc(unsigned nelem, unsigned elsize, char *str);
a581 1
    extern char *rt_calloc();
a706 12

/*
 *  A macro for providing function prototypes, regardless of whether
 *  the compiler understands them or not.
 *  It is vital that the argument list given for "args" be enclosed
 *  in parens.
 */
#if __STDC__
#	define	NMG_EXTERN(type_and_name,args)	extern type_and_name args
#else
#	define	NMG_EXTERN(type_and_name,args)	extern type_and_name()
#endif
@


1.28
log
@Reorganized declarations to be in same order as in source code.
Added some additional routines.
@
text
@d324 2
d333 1
d343 2
d352 1
@


1.27
log
@Another STDC bit of polish.
@
text
@d654 1
a654 1
#define EUPRINT(_s, _eu)	euprint( (_s), (_eu) )
d700 3
d704 1
a704 2
NMG_EXTERN(struct model		*nmg_mm, () );
NMG_EXTERN(struct model		*nmg_find_model, (long *magic_p) );
a705 1
NMG_EXTERN(struct nmgregion	*nmg_mrsv, (struct model *m) );
d709 1
a710 1
NMG_EXTERN(struct edgeuse	*nmg_eins, (struct edgeuse *eu) );
d712 19
d732 1
a732 1
NMG_EXTERN(struct faceuse	*nmg_mf, (struct loopuse *lu1) );
d734 5
d740 42
a781 36
NMG_EXTERN(struct edgeuse	*nmg_eusplit, (struct vertex *v, struct edgeuse *oldeu) );
NMG_EXTERN(struct edge	*nmg_esplit, (struct vertex *v, struct edge *e) );
NMG_EXTERN(char		*nmg_identify_magic, (long magic) );
NMG_EXTERN(int		nmg_tbl, (struct nmg_ptbl *b, int func, long *p) );
NMG_EXTERN(void		nmg_movevu, (struct vertexuse *vu, struct vertex *v) );
NMG_EXTERN(void		nmg_kfu, (struct faceuse *fu1) );
NMG_EXTERN(void		nmg_klu, (struct loopuse *lu1) );
NMG_EXTERN(void		nmg_evu, (struct edgeuse *eu) );
NMG_EXTERN(void		nmg_kvu, (struct vertexuse *vu) );
NMG_EXTERN(void		nmg_keu, (struct edgeuse *eu) );
NMG_EXTERN(void		nmg_ks, (struct shell *s) );
NMG_EXTERN(void		nmg_kr, (struct nmgregion *r) );
NMG_EXTERN(void		nmg_km, (struct model *m) );
NMG_EXTERN(void		nmg_pr_m, (struct model *m) );
NMG_EXTERN(void		nmg_pr_r, (struct nmgregion *r, char *h) );
NMG_EXTERN(void		nmg_pr_s, (struct shell *s, char *h) );
NMG_EXTERN(void		nmg_pr_fg, (struct face_g *fg, char *h) );
NMG_EXTERN(void		nmg_pr_f, (struct face *f, char *h) );
NMG_EXTERN(void		nmg_pr_fu, (struct faceuse *fu, char *h) );
NMG_EXTERN(void		nmg_pr_l, (struct loop *l, char *h) );
NMG_EXTERN(void		nmg_pr_lu, (struct loopuse *lu, char *h) );
NMG_EXTERN(void		nmg_pr_e, (struct edge *e, char *h) );
NMG_EXTERN(void		nmg_pr_eu, (struct edgeuse *eu, char *h) );
NMG_EXTERN(void		nmg_pr_vg, (struct vertex_g *vg, char *h) );
NMG_EXTERN(void		nmg_pr_v, (struct vertex *v, char *h) );
NMG_EXTERN(void		nmg_pr_vu, (struct vertexuse *vu, char *h) );
NMG_EXTERN(void		nmg_unglueedge, (struct edgeuse *eu) );
NMG_EXTERN(void		nmg_moveeu, (struct edgeuse *eudst, struct edgeuse *eusrc) );
NMG_EXTERN(void 		nmg_moveltof, (struct faceuse *fu, struct shell *s) );
NMG_EXTERN(void		nmg_face_g, (struct faceuse *fu, plane_t p) );
NMG_EXTERN(void		nmg_face_bb, (struct face *f) );
NMG_EXTERN(void		nmg_vertex_gv, (struct vertex *v, pointp_t pt) );
NMG_EXTERN(void		nmg_loop_g, (struct loop *l) );
NMG_EXTERN(void		nmg_shell_a, (struct shell *s) );
NMG_EXTERN(void		nmg_jv, (struct vertex *v1, struct vertex *v2) );
NMG_EXTERN(void		nmg_moveltof, (struct faceuse *fu, struct shell *s) );
a796 1
NMG_EXTERN(struct vertexuse	*nmg_find_vu_in_face, (point_t pt, struct faceuse *fu, fastf_t tol) );
d800 1
a800 1
NMG_EXTERN(int		nmg_ck_closed_surf, (struct shell *s) );
a805 4
NMG_EXTERN(int		nmg_manifold_face, (struct faceuse *fu) );
NMG_EXTERN(int		nmg_demote_eu, (struct edgeuse *eu) );
NMG_EXTERN(int		nmg_demote_lu, (struct loopuse *lu) );
NMG_EXTERN(void		nmg_region_a, (struct nmgregion *r) );
d807 1
a807 4
NMG_EXTERN(void		nmg_jl, (struct loopuse *lu, struct edgeuse *eu) );
NMG_EXTERN(void		nmg_simplify_loop, (struct loopuse *lu) );
NMG_EXTERN(void		nmg_simplify_face, (struct faceuse *fu) );
NMG_EXTERN(void		nmg_simplify_shell, (struct shell *s) );
@


1.26
log
@Added EUPRINT, PLPRINT, nmg_boolstruct
@
text
@d554 1
a554 1
 * model storage allocation and de-allocation support
a555 2
extern char *rt_calloc();

d557 1
d561 1
@


1.25
log
@changed declaration fro nmg_pl_fu to include color parameters
@
text
@d654 28
@


1.24
log
@Added nmg_find_model
@
text
@d724 2
a725 1
					struct nmg_ptbl *b ) );
@


1.23
log
@Added index numbers to all structs,
modified GET_xxx() macros to take model pointers.
@
text
@d674 1
@


1.22
log
@Added some NMG_TBL wrappers
@
text
@d328 2
d334 1
d345 1
d352 1
d367 1
d374 1
d387 1
d396 1
d407 1
d412 1
d443 1
d450 1
d465 1
d470 1
d483 1
d488 1
d504 1
d509 1
d524 1
d530 1
d543 1
d549 1
d566 24
a589 22
#define GET_MODEL(p)	    NMG_GETSTRUCT(p, model)
#define GET_MODEL_A(p)	    NMG_GETSTRUCT(p, model_a)
#define GET_REGION(p)	    NMG_GETSTRUCT(p, nmgregion)
#define GET_REGION_A(p)     NMG_GETSTRUCT(p, nmgregion_a)
#define GET_SHELL(p)	    NMG_GETSTRUCT(p, shell)
#define GET_SHELL_A(p)	    NMG_GETSTRUCT(p, shell_a)
#define GET_FACE(p)	    NMG_GETSTRUCT(p, face)
#define GET_FACE_G(p)	    NMG_GETSTRUCT(p, face_g)
#define GET_FACEUSE(p)	    NMG_GETSTRUCT(p, faceuse)
#define GET_FACEUSE_A(p)    NMG_GETSTRUCT(p, faceuse_a)
#define GET_LOOP(p)	    NMG_GETSTRUCT(p, loop)
#define GET_LOOP_G(p)	    NMG_GETSTRUCT(p, loop_g)
#define GET_LOOPUSE(p)	    NMG_GETSTRUCT(p, loopuse)
#define GET_LOOPUSE_A(p)    NMG_GETSTRUCT(p, loopuse_a)
#define GET_EDGE(p)	    NMG_GETSTRUCT(p, edge)
#define GET_EDGE_G(p)	    NMG_GETSTRUCT(p, edge_g)
#define GET_EDGEUSE(p)	    NMG_GETSTRUCT(p, edgeuse)
#define GET_EDGEUSE_A(p)    NMG_GETSTRUCT(p, edgeuse_a)
#define GET_VERTEX(p)	    NMG_GETSTRUCT(p, vertex)
#define GET_VERTEX_G(p)     NMG_GETSTRUCT(p, vertex_g)
#define GET_VERTEXUSE(p)    NMG_GETSTRUCT(p, vertexuse)
#define GET_VERTEXUSE_A(p)  NMG_GETSTRUCT(p, vertexuse_a)
@


1.21
log
@Fixed a few extern declarations.
@
text
@d103 4
a106 1

@


1.20
log
@Converted to using NMG_EXTERN for function extern declarations.
@
text
@d95 1
d654 1
a654 1
NMG_EXTERN(struct loopuse	*nmg_mlv, (long *magic, struct vertex *v, char orientation) );
d694 2
a695 3
NMG_EXTERN(void		nmg_pl_fu, (FILE *fp, struct faceuse *fu, 
					struct nmg_ptbl *b, unsigned char R,
					unsigned char G, unsigned char B) );
d697 8
a704 5
					struct nmg_ptbl *b, unsigned char R,
					unsigned char G, unsigned char B) );
NMG_EXTERN(void		nmg_pl_eu, (FILE *fp, struct edgeuse *eu, 
					struct nmg_ptbl *b, unsigned char R,
					unsigned char G, unsigned char B) );
d717 1
a717 1
NMG_EXTERN(void		nmg_pr_orient, (char o, char *h) );
@


1.19
log
@Corrected bad prototype.
@
text
@d617 1
a617 3
/* Believe it or not, not every system has these macros somewhere
 * in the include files
 */
d625 6
d632 4
a635 2
 *  Support Function Declarations
 *
d638 56
a693 50
extern struct model	*nmg_mmr();
extern struct model	*nmg_mm();
extern struct shell 	*nmg_msv(struct nmgregion *r_p);
extern struct nmgregion	*nmg_mrsv(struct model *m);
extern struct vertexuse	*nmg_mvu(struct vertex *v, long *upptr);
extern struct vertexuse	*nmg_mvvu(long *upptr);
extern struct edgeuse	*nmg_me(struct vertex *v1, struct vertex *v2, struct shell *s);
extern struct edgeuse	*nmg_meonvu(struct vertexuse *vu);
extern struct edgeuse	*nmg_eins(struct edgeuse *eu);
extern struct loopuse	*nmg_ml(struct shell *s);
extern struct loopuse	*nmg_mlv(long *magic, struct vertex *v, char orientation);
extern struct faceuse	*nmg_mf(struct loopuse *lu1);
extern struct faceuse	*nmg_cface(struct shell *s, struct vertex **vt,	int n);
extern struct faceuse	*nmg_cmface(struct shell *s, struct vertex **vt[], int n);
extern struct edgeuse	*nmg_eusplit(struct vertex *v, struct edgeuse *oldeu);
extern struct edge	*nmg_esplit(struct vertex *v, struct edge *e);
extern char		*nmg_identify_magic(long magic);
extern int		nmg_tbl(struct nmg_ptbl *b, int func, long *p);
extern void		nmg_movevu(struct vertexuse *vu, struct vertex *v);
extern void		nmg_kfu(struct faceuse *fu1);
extern void		nmg_klu(struct loopuse *lu1);
extern void		nmg_evu(struct edgeuse *eu);
extern void		nmg_kvu(struct vertexuse *vu);
extern void		nmg_ks(struct shell *s);
extern void		nmg_kr(struct nmgregion *r);
extern void		nmg_km(struct model *m);
extern void		nmg_pr_m(struct model *m);
extern void		nmg_pr_r(struct nmgregion *r, char *h);
extern void		nmg_pr_s(struct shell *s, char *h);
extern void		nmg_pr_fg(struct face_g *fg, char *h);
extern void		nmg_pr_f(struct face *f, char *h);
extern void		nmg_pr_fu(struct faceuse *fu, char *h);
extern void		nmg_pr_l(struct loop *l, char *h);
extern void		nmg_pr_lu(struct loopuse *lu, char *h);
extern void		nmg_pr_e(struct edge *e, char *h);
extern void		nmg_pr_eu(struct edgeuse *eu, char *h);
extern void		nmg_pr_vg(struct vertex_g *vg, char *h);
extern void		nmg_pr_v(struct vertex *v, char *h);
extern void		nmg_pr_vu(struct vertexuse *vu, char *h);
extern void		nmg_unglueedge(struct edgeuse *eu);
extern void		nmg_moveeu(struct edgeuse *eudst, struct edgeuse *eusrc);
extern void 		nmg_moveltof(struct faceuse *fu, struct shell *s);
extern void		nmg_face_g(struct faceuse *fu, plane_t p);
extern void		nmg_face_bb(struct face *f);
extern void		nmg_vertex_gv(struct vertex *v, pointp_t pt);
extern void		nmg_loop_g(struct loop *l);
extern void		nmg_shell_a(struct shell *s);
extern void		nmg_jv(struct vertex *v1, struct vertex *v2);
extern void		nmg_moveltof(struct faceuse *fu, struct shell *s);
extern void		nmg_pl_fu(FILE *fp, struct faceuse *fu, 
d695 2
a696 2
					unsigned char G, unsigned char B);
extern void		nmg_pl_lu(FILE *fp, struct loopuse *fu, 
d698 2
a699 2
					unsigned char G, unsigned char B);
extern void		nmg_pl_eu(FILE *fp, struct edgeuse *eu, 
d701 23
a723 23
					unsigned char G, unsigned char B);
extern void		nmg_pl_s(FILE *fp, struct shell *s);
extern void		nmg_pl_r(FILE *fp, struct nmgregion *r);
extern void		nmg_pl_m(FILE *fp, struct model *m);
extern struct vertexuse	*nmg_find_vu_in_face(point_t pt, struct faceuse *fu, fastf_t tol);
extern void		nmg_mesh_faces(struct faceuse *fu1, struct faceuse *fu2);
extern void		nmg_isect_faces(struct faceuse *fu1, struct faceuse *fu2);
extern struct nmgregion	*nmg_do_bool(struct nmgregion *s1, struct nmgregion *s2, int oper, fastf_t tol);
extern int		nmg_ck_closed_surf(struct shell *s);
extern void		nmg_m_to_g(FILE *fp, struct model *m);
extern void		nmg_r_to_g(FILE *fp, struct nmgregion *r);
extern void		nmg_s_to_g(FILE *fp, struct shell *s, unsigned char rgb[]);
extern struct shell	*polytonmg(FILE *fd, struct nmgregion *r);
extern void		nmg_pr_orient(char o, char *h);
extern int		nmg_manifold_face(struct faceuse *fu);
extern int		nmg_demote_eu(struct edgeuse *eu);
extern int		nmg_demote_lu(struct loopuse *lu);
extern void		nmg_region_a(struct nmgregion *r);
extern void		nmg_ck_lueu(struct loopuse *cklu, char *s);
extern void		nmg_jl(struct loopuse *lu, struct edgeuse *eu);
extern void		nmg_simplify_loop(struct loopuse *lu);
extern void		nmg_simplify_face(struct faceuse *fu);
extern void		nmg_simplify_shell(struct shell *s);
a724 78
#else
extern struct model	*nmg_mmr();
extern struct model	*nmg_mm();
extern struct shell 	*nmg_msv();
extern struct nmgregion	*nmg_mrsv();
extern struct vertexuse	*nmg_mvu();
extern struct vertexuse	*nmg_mvvu();
extern struct edgeuse	*nmg_me();
extern struct edgeuse	*nmg_meonvu();
extern struct edgeuse	*nmg_eins();
extern struct loopuse	*nmg_ml();
extern struct loopuse	*nmg_mlv();
extern struct faceuse	*nmg_mf();
extern struct faceuse	*nmg_cface();
extern struct faceuse	*nmg_cmface();
extern struct edgeuse	*nmg_eusplit();
extern struct edge	*nmg_esplit();
extern char		*nmg_identify_magic();
extern int		nmg_tbl();
extern void		nmg_movevu();
extern void		nmg_kfu();
extern void		nmg_klu();
extern void		nmg_keu();
extern void		nmg_kvu();
extern void		nmg_ks();
extern void		nmg_kr();
extern void		nmg_km();
extern void		nmg_pr_m();
extern void		nmg_pr_r();
extern void		nmg_pr_s();
extern void		nmg_pr_fg();
extern void		nmg_pr_f();
extern void		nmg_pr_fu();
extern void		nmg_pr_l();
extern void		nmg_pr_lu();
extern void		nmg_pr_e();
extern void		nmg_pr_eu();
extern void		nmg_pr_vg();
extern void		nmg_pr_v();
extern void		nmg_pr_vu();
extern void		nmg_unglueedge();
extern void		nmg_moveeu();
extern void 		nmg_moveltof();
extern void		nmg_face_g();
extern void		nmg_face_bb();
extern void		nmg_vertex_gv();
extern void		nmg_loop_g();
extern void		nmg_shell_a();
extern void		nmg_jv();
extern void		nmg_moveltof();
extern void		nmg_pl_s();
extern void		nmg_pl_r();
extern void		nmg_pl_m();
extern void		nmg_pl_fu();
extern void		nmg_pl_lu();
extern void		nmg_pl_eu();
extern struct vertexuse	*nmg_find_vu_in_face();
extern void		nmg_mesh_faces();
extern void		nmg_isect_faces();
extern struct nmgregion	*nmg_do_bool();
extern int		nmg_ck_closed_surf();
extern void		nmg_m_to_g();
extern void		nmg_r_to_g();
extern void		nmg_s_to_g();
extern struct shell	*polytonmg();
extern void		nmg_pr_orient();
extern void		nmg_pl_isect();
extern int		nmg_manifold_face();
extern int		nmg_demote_eu();
extern int		nmg_demote_lu();
extern void		nmg_region_a();
extern void		nmg_ck_lueu();
extern void		nmg_jl();
extern void		nmg_simplify_loop();
extern void		nmg_simplify_face();
extern void		nmg_simplify_shell();

#endif
@


1.18
log
@added nmg_simplify_shell
./
@
text
@d696 1
a696 1
extern struct nmgregion	*nmg_do_bool(struct shell *s1, struct shell *s2, int oper, fastf_t tol);
@


1.17
log
@added declarations for nmg_simplify_loop, nmg_simplify_face, nmg_jl
@
text
@d711 1
d788 1
@


1.16
log
@Added DEBUG_PL_ANIM
@
text
@d708 3
d784 3
@


1.15
log
@Fixed ck_lueu
@
text
@d53 2
a54 1
#define DEBUG_LABEL_PTS 0x00004000	/* label points in plot files */
d57 1
a57 1
"\020\017LABEL_PTS\016POLYTO\015MESH_EU\014MESH\013GRAZING\
@


1.14
log
@Fixed function prototypes
@
text
@d706 1
d779 1
@


1.13
log
@Fixed bug in NMG_LIST_PNEXT_CIRC.
@
text
@d641 1
a641 1
extern struct loopuse	*nmg_mlv(long *magic, struct vertex *v);
d700 1
a700 1
extern struct shell	*polytonmg(FILE *fd, struct nmgregion *r, point_t min, point_t max);
@


1.12
log
@added extern for nmg_region_a()
@
text
@d289 1
a289 1
		NMG_LIST_FIRST(structure,(struct nmg_list *)(p)) : \
d295 1
a295 1
		NMG_LIST_LAST(structure,(struct nmg_list *)(p)) : \
@


1.11
log
@Revised for new doubly linked lists.
@
text
@d705 1
d777 1
@


1.10
log
@added external declarations for nmg_demote_eu, nmg_demote_lu, nmg_manifold_face
@
text
@d128 1
d137 1
a137 1
	} else if( (_ptr)->magic != (_magic) )  { \
d140 2
a141 2
			nmg_identify_magic( (_ptr)->magic ), \
			 (_ptr)->magic, __FILE__, __LINE__ ); \
d179 1
d182 1
a182 1
	if (!(_p)->up.magic_p || !(_p)->next || !(_p)->last || \
d189 1
a189 1
	if (!(_p)->next || !(_p)->last || !(_p)->eumate_p || \
d200 98
d300 4
a303 4
 *	We rely on the fact that the first object in a struct is the magic
 *	number (which we use to identify the struct type).  It is also
 *	important that the next/last fields have the same offset in all
 *	structs that have them.
d307 1
a307 1
 *		1) magic number
a308 2
 *		3) pointer to next
 *		4) pointer to last
d315 3
a317 1
/*  M O D E L
d320 3
a322 3
    long		magic;
    struct model_a	*ma_p;
    struct nmgregion	*r_p;		/* list of regions in model space */
d326 1
a326 1
	long magic;
d329 2
a330 1
/*  R E G I O N
d333 4
a336 6
    long	    magic;
    struct model    *m_p;	/* owning model */
    struct nmgregion *next,
		    *last;	/* regions in model list of regions */
    struct nmgregion_a *ra_p;	/* attributes */
    struct shell    *s_p;	/* list of shells in region */
d340 3
a342 3
	long	magic;
	point_t	min_pt;	/* minimums of bounding box */
	point_t	max_pt;	/* maximums of bounding box */
d345 2
a346 1
/*  S H E L L
d349 3
a351 5
    long	    magic;
    struct nmgregion   *r_p;	    /* owning region */
    struct shell    *next,
		    *last;	    /* shells in region's list of shells */
    struct shell_a  *sa_p;	    /* attribs */
d353 4
a356 4
    struct faceuse	    *fu_p;  /* list of face uses in shell */
    struct loopuse	    *lu_p;  /* loop uses (edge groups) in shell */
    struct edgeuse	    *eu_p;  /* wire list (shell has wires) */
    struct vertexuse    *vu_p;  /* shell is single vertex */
d360 3
a362 3
    long	magic;
    point_t	min_pt;	/* minimums of bounding box */
    point_t	max_pt;	/* maximums of bounding box */
d365 5
a369 1
/*  F A C E
d372 3
a374 3
    long	    magic;
    struct faceuse  *fu_p;  /* list of uses of this face. use fu mate field */
    struct face_g   *fg_p;  /* geometry */
d378 5
a382 5
    long	magic;
    unsigned	ref_cnt;
    plane_t	N;	/* Surface Normal (N[0]x + N[1]y + N[2]z + N[3] = 0)*/
    point_t	min_pt;	/* minimums of bounding box */
    point_t	max_pt;	/* maximums of bounding box */
d385 8
a392 10
struct faceuse { /* Note: there will always be exactly two uses of a face */
    long	    magic;
    struct shell    *s_p;	    /* owning shell */
    struct faceuse  *next,
		    *last,	    /* fu's in shell's list of fu's */
		    *fumate_p;	    /* opposite side of face */
    char	    orientation;    /* compared to face geom definition */
    struct face     *f_p;	    /* face definition and attributes */
    struct faceuse_a *fua_p;	    /* attributess */
    struct loopuse  *lu_p;	    /* list of loops in face-use */
d396 1
a396 1
    long    magic;
d399 20
a418 1
/*  L O O P
d420 3
d424 3
a426 4
    long	    magic;
    struct loopuse  *lu_p;  /* list of uses of this loop. -
					use eu_mate eulu fields */
    struct loop_g   *lg_p;  /* Geoometry */
d430 3
a432 3
    long    magic;
    point_t	min_pt;	/* minimums of bounding box */
    point_t	max_pt;	/* maximums of bounding box */
d436 11
a446 17
    long	    magic;
    union {
	struct faceuse  *fu_p;	    /* owning face-use */
	struct shell	*s_p;
	long		*magic_p;
    } up;
    struct loopuse  *next,
		    *last,	    /* lu's in fu's list of lu's */
		    *lumate_p;	    /* loopuse on other side of face */
    char	    orientation;    /* OT_SAME=outside loop */
    struct loop     *l_p;	    /* loop definition and attributes */
    struct loopuse_a *lua_p;	    /* attributes */
    union {
	struct edgeuse	    *eu_p;  /* list of eu's in lu */
	struct vertexuse    *vu_p; /* loop is a single vertex */
	long		    *magic_p; /* for those times when we're not sure */
    } down;
d450 1
a450 1
    long    magic;
d453 5
a457 1
/*  E D G E
d460 3
a462 4
    long	    magic;
    struct edgeuse  *eu_p;  /* list of uses of this edge -
				    use eu radial/mate fields */
    struct edge_g   *eg_p;  /* geometry */
d466 1
a466 1
    long    magic;
d470 12
a481 14
    long		magic;
    union {
	struct loopuse	*lu_p;
	struct shell	*s_p;
	long	        *magic_p; /* for those times when we're not sure */
    } up;
    struct edgeuse	*next,	    /* either clockwise/ccw edges in loop */
    			*last,	    /* or list of edges/faces in shell */
    			*eumate_p,  /* eu on other face or other end of wire*/
		  	*radial_p;  /* eu on radially adj. fu (null if wire)*/
    struct edge 	*e_p;	    /* edge definition and attributes */
    struct edgeuse_a	*eua_p;	    /* parametric space geom */
    char	  	orientation;/* compared to geom (null if wire) */
    struct vertexuse	*vu_p;	    /* starting vu of eu in this orient */
d485 1
a485 1
    long    magic;
d488 7
a494 1
/*  V E R T E X
d497 3
a499 4
    long		magic;
    struct vertexuse	*vu_p;	/* list of uses of this vertex - 
					    use vu_next fields */
    struct vertex_g	*vg_p;	/* geometry */
d503 2
a504 2
    long	magic;
    point_t	coord;	/* coordinates of vertex in space */
d508 9
a516 11
    long		magic;
    union {
	struct shell	*s_p;	/* no fu's or eu's on shell */
	struct loopuse	*lu_p;	/* loopuse contains single vertex */
	struct edgeuse	*eu_p;	/* eu causing this vu */
	long		*magic_p; /* for those times when we're not sure */
    } up;
    struct vertexuse	*next,   /* list of all vu's of vertex */
			*last;
    struct vertex	*v_p;	    /* vertex definition and attributes */
    struct vertexuse_a	*vua_p;     /* Attributes */
d520 2
a521 2
    long	magic;
    vect_t	N;	/* optional surface Normal at vertexuse */
a597 22

/* insert a node into the head of a doubly linked list */
#define DLLINS(_listp, _nodep) {\
	if (_listp) { /* link node into existing list */ \
		_nodep->next = _listp; _nodep->last = _listp->last; \
		_listp->last->next = _nodep; _listp->last = _nodep; \
	} else { /* make node the entire list */\
		_nodep->next = _nodep->last = _nodep; \
	} \
	_listp = _nodep; }

/* remove a node from a doubly linked list and put it's pointer in nodep.
 * we leave the next and last pointers of the extracted node pointing to the
 * node.  If it was the last node in the list, we don't actually remove it, 
 * but we do still copy the pointer.
 */
#define DLLRM(_listp, _nodep) if (( (_nodep)=(_listp) ) != (_listp)->next) { \
				(_listp) = (_listp)->next; \
				(_nodep)->next->last = (_nodep)->last; \
				(_nodep)->last->next = (_nodep)->next; \
				(_nodep)->next = (_nodep)->last = (_nodep); }

@


1.9
log
@DEBUG_SUBTRACT -> DEBUG_BOOLEVAL
@
text
@d547 1
a547 1
extern struct faceuse	*nmg_cmface(struct shell *s, struct vertex **vt, int n);
d602 1
a602 1
extern void		nmg_s_to_g(FILE *fp, struct shell *s, RGBpixel rgb);
d605 3
d676 3
@


1.8
log
@added classifier constants
@
text
@d48 1
a48 1
#define DEBUG_SUBTRACT	0x00000200	/* 10 combine() */
d57 1
a57 1
\012SUBTRACT\011CLASSIFY\
@


1.7
log
@New debugging flags
@
text
@d65 10
@


1.6
log
@Added nmg_mm, changed args on nmg_cface, nmg_cmface, nmg_do_bool.
@
text
@d38 22
d70 1
a71 1

d508 1
a508 1

d585 1
a585 1
extern struct vertexuse	*nmg_find_vu_in_face(point_t pt, struct faceuse *fu);
d588 2
a589 2
extern struct nmgregion	*nmg_do_bool(struct shell *s1, struct shell *s2, int oper);
extern void		nmg_ck_closed_surf(struct shell *s);
d656 1
a656 1
extern void		nmg_ck_closed_surf();
@


1.5
log
@Changes to support the beginings of boolean operations.
Sort of a "Debug release #2"
@
text
@a40 1
#define NMG_BOOL_XOR 3		/* exclusive or */
d210 2
d503 1
d514 2
a515 1
extern struct faceuse	*nmg_cface(struct shell *s, struct vertex **vt,	unsigned n);
d566 1
a566 1
extern struct shell	*nmg_do_bool(struct shell *s1, struct shell *s2, int oper);
d576 1
d588 1
d633 1
a633 1
extern struct shell	*nmg_do_bool();
@


1.4
log
@Fixed various minor __STDC__ nits.
@
text
@d22 2
a23 2
#ifndef FACET_H
#define FACET_H seen
d25 10
d38 5
d44 1
d51 4
a54 2
/*
 * support for pointer tables
d56 7
a62 4
#define TBL_INIT 0
#define TBL_INS	 1
#define TBL_LOC  2
#define TBL_FREE 3
d65 3
a67 2
	int next, blen;
	long **buffer;
d79 1
a79 1
#define NMG_SHELL_MAGIC 	34343434
d89 1
a89 1
#define NMG_EDGE_MAGIC		89898989
d98 2
d120 4
a123 1
#define NMG_CK_FACE_G(_p)	{NMG_CKMAG(_p, NMG_FACE_G_MAGIC, "face_g") \
d125 2
a126 1
	(_p)->N[H] != 0.0) { rt_log( \
d128 5
a132 3
	__FILE__, __LINE__, (_p)->N[X], (_p)->N[Y], (_p)->N[Z], (_p)->N[H]); \
	rt_bomb("Bad NMG geometry\n"); \
     } }
d148 6
d155 12
d244 1
a263 1
    int     flip;	/* (Flip/don't Flip) face normal */
d291 1
a350 1
    char	orientation;	/* for classification purposes */
a441 15
struct walker_tbl {
	int     pre_post;       /* pre-process or post process nodes */
#define PREPROCESS -1
#define POSTPROCESS 1
	int     (*fmodel)();
	int     (*fregion)();
	int     (*fshell)();
        int     (*ffaceuse)();
        int     (*floopuse)();
        int     (*fedgeuse)();
        int     (*fvertexuse)();
};



d489 2
a490 2
#ifndef max
# define max(_a, _b) ((_a) > (_b) ? (_a) : (_b))
d492 2
a493 2
#ifndef min
# define min(_a, _b) ((_a) < (_b) ? (_a) : (_b))
d548 9
d560 3
a562 1

d564 6
d622 6
a627 1

d629 7
@


1.3
log
@Rudimentary face/loop partitioning (for future boolean use) accomplished
@
text
@d18 3
d248 1
a248 1
	long		    *magic_p /* for those times when we're not sure */
d274 1
a274 1
	long	        *magic_p /* for those times when we're not sure */
d311 1
a311 1
	long		*magic_p /* for those times when we're not sure */
d469 1
a469 1
extern struct shell 	*nmg_msv(struct region *r_p);
d473 1
a473 1
extern struct edgeuse	*nmg_me(struct vertex *v1, *v2, struct shell *s);
d483 1
a483 1
extern int		nmg_tbl(nmg_ptbl *b, int func, long **p);
d492 1
a492 1
extern void		nmg_pr_m(struct model *m, char *h);
d506 1
a506 1
extern void		nmg_moveeu(struct edgeuse *eudst, *eusrc);
d508 1
a508 1
extern void		nmg_face_g(struct faceuse *fu);
d511 3
a513 3
extern void		nmg_loop_g(loop *l);
extern void		nmg_shell_a(shell *s);
extern void		nmg_jv(struct vertex *v1, *v2);
d515 3
a517 3
extern void		nmg_pl_s(FILE fp, struct shell *s);
extern void		nmg_pl_r(FILE fp, struct nmgregion *r);
extern void		nmg_pl_m(FILE fp, struct model *m);
d519 1
a519 1
extern struct shell	*nmg_do_bool(struct shell *s1, *s2, int oper);
@


1.2
log
@Major improvements
@
text
@d3 12
d26 1
a26 1
#define OT_UNSPEC   '\0'    /* orientation unspecified */
d29 1
a31 1

d93 7
a99 1
#define NMG_CK_FACE_G(_p)	NMG_CKMAG(_p, NMG_FACE_G_MAGIC, "face_g")
d437 3
a439 2
#define NMG_EXTENT_OVERLAP(_a, _b) (!(_a[0] > _b[1] || _a[1] < _b[0] || \
	_a[2] > _b[3] || _a[3] < _b[2] || _a[4] > _b[5] || _a[5] < _b[4]) )
d441 5
d447 13
a465 1
extern struct nmgregion	*nmg_mr(struct model *m);
d467 1
d472 1
d474 1
a474 1
extern struct loopuse	*nmg_mlv(struct shell *s);
d476 5
a480 2
extern struct edgeuse	*nmg_esplit(struct vertex *v, struct edgeuse *oldeu);
extern char		*nmg_identify(long magic);
d487 2
d503 1
a503 1
extern void		nmg_glueedge(struct edge *e1, *e2);
d505 10
d516 2
a519 1
extern struct nmgregion	*nmg_mr();
d521 1
d526 1
d530 5
a534 2
extern struct edgeuse	*nmg_esplit();
extern char		*nmg_identify();
d541 2
d557 1
a557 1
extern void		nmg_glueedge();
d559 12
@


1.1
log
@Initial revision
@
text
@d1 1
a1 2
/*
 *			N M G . H
a2 2
 *	PRELIMINARY VERSION
 *
a5 13
 *
 *  Author -
 *	Lee A. Butler
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimitied.
 *
 *  $Header$
a6 1

d10 4
d18 2
d21 1
a21 1
 *  ptr types
d23 4
a26 5
#define PTR_SHELL   5
#define PTR_FACEUSE 4
#define PTR_LOOPUSE 3
#define PTR_EDGEUSE 2
#define PTR_VERTEXUSE	1
d28 7
d45 1
a45 1
#define NMG_FACE_A_MAGIC	0x726b6e65
d49 1
a49 1
#define NMG_LOOP_A_MAGIC	0x6420224c
d69 2
a70 2
			nmg_identify_magic( (_ptr)->magic ), (_ptr)->magic, \
			__FILE__, __LINE__ ); \
d81 1
a81 1
#define NMG_CK_FACE_A(_p)	NMG_CKMAG(_p, NMG_FACE_A_MAGIC, "face_a")
d85 1
a85 1
#define NMG_CK_LOOP_A(_p)	NMG_CKMAG(_p, NMG_LOOP_A_MAGIC, "loop_a")
d98 19
d120 3
a122 3
    long	    magic;
    struct nmgregion   *r_p;		/* list of regions in model space */
    struct model_a  *ma_p;
d136 1
a137 1
    struct nmgregion_a *ra_p;	/* attributes */
d152 5
a156 5
    char	    downptr_type;
    union {
	struct faceuse	    *fu_p;  /* list of face uses in shell */
	struct vertexuse    *vu_p;  /* shell is single vertex */
    } downptr;
d160 3
a162 1
	long	magic;
d174 4
a177 2
    long    magic;
    double  N[3];	/* Surface Normal */
a185 1
    struct loopuse  *lu_p;	    /* list of loops in face-use */
d189 1
d208 2
d214 5
a218 1
    struct faceuse  *fu_p;	    /* owning face-use */
d224 5
a228 1
    struct edgeuse  *eu_p;	    /* list of eu's in lu */
d250 9
a258 5
    struct vertexuse	*vu_p;	    /* starting vu of eu in this orient */
    struct edgeuse	*eumate_p,  /* eu on other face or other end of wire*/
		  	*eu_radial_p,/* eu on radially adjacent fu */
    			*lueu_cw_p, /* clockwise/counter-clockwise..*/
		  	*lueu_ccw_p;/* eu's in lu's ordered eu list */
d261 2
a262 2
    char	  	orientation;/* compared to geom */
    struct loopuse	*lu_p;	    /* owning loop */
d279 3
a281 2
    long    magic;
    double  coord[3];	    /* coordinates of vertex in space */
d286 6
a295 5
    char		upptr_type; /* selects pointer type in union upptr */
    union {
	struct shell	*s_p;	/* no fu's or eu's on shell */
	struct edgeuse	*eu_p;	/* eu causing this vu */
    } upptr;
d299 2
a300 1
    long	    magic;
d303 1
d305 1
a305 2
 *  Support Function Return codes
 *
d307 1
a307 4
#define SUCCESS		0
#define ALLOC_FAIL	1	/* memory allocation failed */
#define PARAM_ERROR	2	/* function parameter error */
#define NOT_EMPTY	3	/* structure free might cause memory leak */
d309 3
a311 4
extern char *malloc();
#ifdef DEBUG
#define NMG_GETSTRUCT(ptr, str) \
 ( ((ptr)=(struct str *)nmg_malloc(sizeof(struct str))) == (struct str *)NULL )
d313 2
a314 2
#define NMG_GETSTRUCT(ptr, str) \
 ( ((ptr)=(struct str *)malloc(sizeof(struct str))) == (struct str *)NULL )
d340 4
a343 4
#ifdef DEBUG
#define FREESTRUCT(ptr, str) \
	{fprintf(stderr, "free(%8x) (%8x)->magic %d\n", ptr, ptr, ptr->magic); \
	bzero((char *)(ptr), sizeof(struct str)); free((char *)(ptr)); }
d345 3
a347 2
#define FREESTRUCT(ptr, str) \
	{ bzero((char *)(ptr), sizeof(struct str)); free((char *)(ptr)); }
a385 31
/*
 *  Support Function Declarations
 *
 */
extern struct model * nmg_mkmodel();	/* Make Model & initial region */
extern int nmg_mkregion();	/* make new region, shell, vertex in model */
extern int nmg_mkshell();	/* Make Shell, Vertex */
extern int nmg_mkface1();	/* Promote shell vertex to face */
extern int nmg_mkfaceN();	/* Make face from/on existing vertex */
extern int nmg_newfacev();	/* Make new vertex on edge */
extern int nmg_insfacev();	/* insert existing vertex on edge */
extern int nmg_wmodel();	/* walk model tree */
extern int nmg_wregion();	/* walk region tree */
extern int nmg_wshell();	/* walk shell tree */
extern int nmg_wfaceuse();	/* walk faceuse tree */
extern int nmg_wloopuse();	/* walk loopuse tree */
extern int nmg_wedgeuse();	/* walk edgeuse tree */
extern int nmg_wvertexuse();	/* walk vertexuse */
extern int nmg_vertex_g();	/* associate geometry with vertex */
extern void nmg_movevu();	/* move vertexuse to new vertex */
extern void nmg_kvu();
extern void nmg_keu();
extern void nmg_klu();
extern void nmg_kfu();
extern void nmg_kshell();
extern void nmg_kregion();
extern void nmg_kmodel();
extern void nmg_jv();		/* join vertexes */
extern int nmg_dupface();
extern int nmg_splitface();
extern char	*nmg_identify_magic();	/* describe kind of magic */
d387 1
d393 5
a397 5
/* insert a node into a doubly linked list */
#define DLLINS(listp, nodep) {\
	if (listp) { /* link node into existing list */ \
		nodep->next = listp; nodep->last = listp->last; \
		listp->last->next = nodep; listp->last = nodep; \
d399 1
a399 1
		nodep->next = nodep->last = nodep; \
d401 100
a500 1
	listp = nodep; }
@
