head	11.11;
access;
symbols
	ansi-20040405-merged:11.9.4.1
	postmerge-20040405-ansi:11.10
	premerge-20040404-ansi:11.10
	postmerge-autoconf:11.10
	autoconf-freeze:11.9.12.2
	premerge-autoconf:11.10
	ansi-20040316-freeze:11.9
	postmerge-20040315-windows:11.10
	premerge-20040315-windows:11.10
	windows-20040315-freeze:11.9.6.1
	autoconf-20031203:11.9
	autoconf-20031202:11.9
	autoconf-branch:11.9.0.12
	phong-branch:11.9.0.10
	photonmap-branch:11.9.0.8
	rel-6-1-DP:11.9
	windows-branch:11.9.0.6
	rel-6-0-2:11.9
	ansi-branch:11.9.0.4
	rel-6-0-1-branch:11.9.0.2
	hartley-6-0-post:11.9
	hartley-6-0-pre:11.9
	rel-6-0-1:11.9
	rel-6-0:11.9
	rel-5-4:11.6
	offsite-5-3-pre:11.6
	rel-5-3:11.6
	rel-5-2:11.6
	rel-5-1-branch:11.6.0.2
	rel-5-1:11.6
	rel-5-0:11.5
	rel-5-0-beta:11.4
	rel-4-5:11.4
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.11
date	2004.05.24.04.11.53;	author morrison;	state dead;
branches;
next	11.10;

11.10
date	2004.02.02.17.39.02;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2001.04.27.14.50.59;	author jra;	state Exp;
branches
	11.9.4.1
	11.9.6.1
	11.9.12.1;
next	11.8;

11.8
date	2001.04.25.13.44.40;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	2001.04.05.19.35.07;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	99.11.24.22.55.18;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	99.07.02.19.15.16;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	97.09.18.20.34.13;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	96.07.10.20.16.35;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.12.01.02.41.17;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.48.28;	author mike;	state Rel4_4;
branches;
next	10.18;

10.18
date	94.12.27.15.20.28;	author stay;	state Exp;
branches;
next	10.17;

10.17
date	94.12.27.15.00.00;	author stay;	state Exp;
branches;
next	10.16;

10.16
date	94.11.08.05.12.38;	author mike;	state Exp;
branches;
next	10.15;

10.15
date	94.11.08.01.25.49;	author mike;	state Exp;
branches;
next	10.14;

10.14
date	94.09.20.23.58.33;	author mike;	state Exp;
branches;
next	10.13;

10.13
date	94.09.13.21.03.00;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	94.08.25.14.56.05;	author gdurf;	state Exp;
branches;
next	10.11;

10.11
date	92.06.03.23.22.20;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	92.06.03.01.30.53;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	92.06.02.23.26.21;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	92.06.02.22.44.42;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	92.05.29.01.17.21;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	92.05.29.00.51.30;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	92.05.28.22.10.11;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.05.27.16.56.04;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.05.23.18.04.49;	author butler;	state Exp;
branches;
next	10.2;

10.2
date	92.04.13.10.21.55;	author stay;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.35.27;	author mike;	state Rel4_0;
branches;
next	1.6;

1.6
date	91.08.30.20.36.04;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	91.07.03.02.19.56;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	91.07.01.06.34.44;	author stay;	state Exp;
branches;
next	1.3;

1.3
date	91.06.23.03.43.19;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	91.06.23.03.04.46;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	91.06.14.09.55.57;	author stay;	state Exp;
branches;
next	;

11.9.4.1
date	2004.03.17.21.16.12;	author morrison;	state Exp;
branches;
next	;

11.9.6.1
date	2004.03.11.23.40.46;	author morrison;	state Exp;
branches;
next	;

11.9.12.1
date	2004.02.12.18.32.35;	author erikg;	state Exp;
branches;
next	11.9.12.2;

11.9.12.2
date	2004.03.15.14.06.10;	author erikg;	state Exp;
branches;
next	;


desc
@Initial version of nurb.h which is now in the header directory.
@


11.11
log
@moved/renamed from top-level h/ to top-level include/
@
text
@/*
 *			N U R B . H
 *
 *  Function -
 *	Define surface and curve structures for
 * 	Non Rational Uniform B-Spline (NURB) 
 *	curves and surfaces. 
 *
 *  Author -
 *	Paul Randal Stay
 * 
 *  Source -
 * 	SECAD/VLD Computing Consortium, Bldg 394
 *	The U.S. Army Ballistic Research Laboratory
 * 	Aberdeen Proving Ground, Maryland 21005
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1991-2004 by the United States Army.
 *	All rights reserved.
 *
 *  $Header: /n/xoff/cvs/brlcad/h/nurb.h,v 11.10 2004/02/02 17:39:02 morrison Exp $
 */

#ifndef NURB_H
#define NURB_H seen

/* make sure all the prerequisite include files have been included
 */
#ifndef MACHINE_H
# include "machine.h"
#endif

#ifndef VMATH_H
# include "vmath.h"
#endif

#ifndef NMG_H
# include "nmg.h"
#endif

#ifndef RAYTRACE_H
# include "raytrace.h"
#endif

/* Define parametric directions for splitting. */

#define RT_NURB_SPLIT_ROW 0
#define RT_NURB_SPLIT_COL 1
#define RT_NURB_SPLIT_FLAT 2

/* Definition of NURB point types and coordinates 
 * Bit:	  8765 4321 0
 *       |nnnn|tttt|h
 *			h     - 1 if Homogeneous
 *			tttt  - point type
 *				1 = XY 
 *				2 = XYZ
 *				3 = UV
 *				4 = Random data
 *				5 = Projected surface
 *			nnnnn - number of coordinates per point
 *				includes the rational coordinate
 */

/* point types */
#define RT_NURB_PT_XY 	1			/* x,y coordintes */
#define RT_NURB_PT_XYZ	2			/* x,y,z coordinates */
#define RT_NURB_PT_UV	3			/* trim u,v parameter space */
#define RT_NURB_PT_DATA 4			/* random data */
#define RT_NURB_PT_PROJ	5			/* Projected Surface */

#define RT_NURB_PT_RATIONAL	1
#define RT_NURB_PT_NONRAT 	0

#define RT_NURB_MAKE_PT_TYPE(n,t,h)	((n<<5) | (t<<1) | h)
#define RT_NURB_EXTRACT_COORDS(pt)	(pt>>5)
#define RT_NURB_EXTRACT_PT_TYPE(pt)		((pt>>1) & 0x0f)
#define RT_NURB_IS_PT_RATIONAL(pt)		(pt & 0x1)
#define RT_NURB_STRIDE(pt)		(RT_NURB_EXTRACT_COORDS(pt) * sizeof( fastf_t))

/* macros to check/validate a structure pointer
 */
#define NMG_CK_KNOT(_p)		BU_CKMAG(_p, RT_KNOT_VECTOR_MAGIC, "knot_vector")
#define NMG_CK_CNURB(_p)	BU_CKMAG(_p, RT_CNURB_MAGIC, "cnurb")
#define NMG_CK_SNURB(_p)	BU_CKMAG(_p, RT_SNURB_MAGIC, "snurb")

#define GET_CNURB(p/*,m*/) 		{BU_GETSTRUCT(p, edge_g_cnurb); \
	/* NMG_INCR_INDEX(p,m); */ \
	BU_LIST_INIT( &(p)->l ); (p)->l.magic = NMG_EDGE_G_CNURB_MAGIC; }
#define GET_SNURB(p/*,m*/) 		{BU_GETSTRUCT(p, face_g_snurb); \
	/* NMG_INCR_INDEX(p,m); */ \
	BU_LIST_INIT( &(p)->l ); (p)->l.magic = NMG_FACE_G_SNURB_MAGIC; }

#define RT_CNURB_MAGIC	0x636e7262

#define RT_SNURB_MAGIC	0x736e7262

/* ----- Internal structures ----- */

struct rt_nurb_poly {
	struct rt_nurb_poly * next;
	point_t		ply[3];		/* Vertices */
	fastf_t		uv[3][2];	/* U,V parametric values */
};

struct rt_nurb_uv_hit {
	struct rt_nurb_uv_hit * next;
	int		sub;
	fastf_t		u;
	fastf_t		v;
};


struct oslo_mat {
	struct oslo_mat * next;
	int		offset;
	int		osize;
	fastf_t		* o_vec;
};

#if !defined(MAX)
# define MAX(i,j)    ( (i) > (j) ? (i) : (j) )
#endif
#if !defined(MIN)
# define MIN(i,j)    ( (i) < (j) ? (i) : (j) )
#endif

/* --- new way */

struct bezier_2d_list {
	struct bu_list	l;
	point2d_t	*ctl;
};

/* nurb_basis.c */
BU_EXTERN(fastf_t rt_nurb_basis_eval, (struct knot_vector *knts, int interval,
			int order, fastf_t mu));

/* nurb_bezier.c */
BU_EXTERN(int rt_nurb_bezier, (struct bu_list *bezier_hd,
			const struct face_g_snurb * srf, struct resource *res));
BU_EXTERN(int rt_bez_check, (const struct face_g_snurb * srf));

/* nurb_bound.c */
BU_EXTERN(int rt_nurb_s_bound, (struct face_g_snurb *srf, point_t bmin, point_t bmax));
BU_EXTERN(int rt_nurb_c_bound, (struct edge_g_cnurb *crv, point_t bmin, point_t bmax));
BU_EXTERN(int rt_nurb_s_check, (struct face_g_snurb *srf));
BU_EXTERN(int rt_nurb_c_check, (struct edge_g_cnurb *crv));

/* nurb_copy.c */
BU_EXTERN(struct face_g_snurb *rt_nurb_scopy, (const struct face_g_snurb *srf, struct resource *res));

/* nurb_diff.c */
BU_EXTERN(struct face_g_snurb *rt_nurb_s_diff, (const struct face_g_snurb *srf, int dir));
BU_EXTERN(struct edge_g_cnurb *rt_nurb_c_diff, (const struct edge_g_cnurb *crv));
BU_EXTERN(void rt_nurb_mesh_diff, (int order, const fastf_t *o_pts,
			fastf_t *n_pts,
			const fastf_t *knots, int o_stride, int n_stride,
			int o_size, int pt_type));

/* nurb_eval.c */
BU_EXTERN(void rt_nurb_s_eval, (const struct face_g_snurb *srf, fastf_t u, fastf_t v, fastf_t * final_value));
BU_EXTERN(void rt_nurb_c_eval, (const struct edge_g_cnurb *crv, fastf_t param, fastf_t * final_value));
BU_EXTERN(fastf_t *rt_nurb_eval_crv, (fastf_t *crv, int order,
			fastf_t param,
			const struct knot_vector *k_vec, int k_index, int coords));
BU_EXTERN(void rt_nurb_pr_crv, (fastf_t *crv, int c_size, int coords));

/* nurb_flat.c */
BU_EXTERN(int rt_nurb_s_flat, (struct face_g_snurb *srf, fastf_t epsilon));
BU_EXTERN(fastf_t rt_nurb_crv_flat, (fastf_t *crv, int	size, int pt_type));

/* nurb_knot.c */
BU_EXTERN(void rt_nurb_kvknot, (struct knot_vector *new_knots, int order,
			fastf_t lower, fastf_t upper, int num, struct resource *res));
BU_EXTERN(void rt_nurb_kvmult, (struct knot_vector *new_kv,
			const struct knot_vector *kv,
			int num, fastf_t val, struct resource *res));
BU_EXTERN(void rt_nurb_kvgen, (struct knot_vector *kv,
			fastf_t lower, fastf_t upper, int num, struct resource *res));
BU_EXTERN(void rt_nurb_kvmerge, (struct knot_vector *new_knots,
			const struct knot_vector *kv1,
			const struct knot_vector *kv2, struct resource *res));
BU_EXTERN(int rt_nurb_kvcheck, (fastf_t val, const struct knot_vector *kv));
BU_EXTERN(void rt_nurb_kvextract, (struct knot_vector *new_kv,
			const struct knot_vector *kv,
			int lower, int upper, struct resource *res));
BU_EXTERN(void rt_nurb_kvcopy, (struct knot_vector *new_kv,
			const struct knot_vector *old_kv, struct resource *res));
BU_EXTERN(void rt_nurb_kvnorm, (struct knot_vector *kv));
BU_EXTERN(int rt_knot_index, (const struct knot_vector *kv, fastf_t k_value,
			int order));
BU_EXTERN(void rt_nurb_gen_knot_vector, (struct knot_vector *new_knots,
			int order, fastf_t lower, fastf_t upper, struct resource *res));

/* nurb_norm.c */
BU_EXTERN(void rt_nurb_s_norm, (struct face_g_snurb *srf, fastf_t u, fastf_t v, fastf_t * norm));

/* nurb_c2.c */
BU_EXTERN(void rt_nurb_curvature, (struct curvature *cvp,
			const struct face_g_snurb *srf, fastf_t u, fastf_t v));

/* nurb_plot.c */
BU_EXTERN(void rt_nurb_plot_snurb, (FILE *fp, const struct face_g_snurb *srf));
BU_EXTERN(void rt_nurb_plot_cnurb, (FILE *fp, const struct edge_g_cnurb *crv));
BU_EXTERN(void rt_nurb_s_plot, (const struct face_g_snurb *srf) );

/* nurb_interp.c */
BU_EXTERN(void rt_nurb_cinterp, (struct edge_g_cnurb *crv, int order,
			const fastf_t *data, int n));
BU_EXTERN(void rt_nurb_sinterp, (struct face_g_snurb *srf, int order,
			const fastf_t *data, int ymax, int xmax));

/* nurb_poly.c */
BU_EXTERN(struct rt_nurb_poly *rt_nurb_to_poly, (struct face_g_snurb *srf));
BU_EXTERN(struct rt_nurb_poly *rt_nurb_mk_poly,
			(fastf_t *v1, fastf_t *v2, fastf_t *v3,
			fastf_t uv1[2], fastf_t uv2[2], fastf_t uv3[2]));

/* nurb_ray.c */
BU_EXTERN(struct face_g_snurb *rt_nurb_project_srf, (const struct face_g_snurb *srf,
			plane_t plane1, plane_t plane2, struct resource *res));
BU_EXTERN(void rt_nurb_clip_srf, (const struct face_g_snurb *srf,
			int dir, fastf_t *min, fastf_t *max));
BU_EXTERN(struct face_g_snurb *rt_nurb_region_from_srf, (const struct face_g_snurb *srf,
			int dir, fastf_t param1, fastf_t param2, struct resource *res));
BU_EXTERN(struct rt_nurb_uv_hit *rt_nurb_intersect, (const struct face_g_snurb * srf,
			plane_t plane1, plane_t plane2, double uv_tol, struct resource *res));

/* nurb_refine.c */
BU_EXTERN(struct face_g_snurb *rt_nurb_s_refine, (const struct face_g_snurb *srf,
			int dir, struct knot_vector *kv, struct resource *res));
BU_EXTERN(struct edge_g_cnurb *rt_nurb_c_refine, (const struct edge_g_cnurb * crv,
			struct knot_vector *kv));

/* nurb_solve.c */
BU_EXTERN(void rt_nurb_solve, (fastf_t *mat_1, fastf_t *mat_2,
			fastf_t *solution, int dim, int coords));
BU_EXTERN(void rt_nurb_doolittle, (fastf_t *mat_1, fastf_t *mat_2,
			int row, int coords));
BU_EXTERN(void rt_nurb_forw_solve, (const fastf_t *lu, const fastf_t *b,
			fastf_t *y, int n));
BU_EXTERN(void rt_nurb_back_solve, (const fastf_t *lu, const fastf_t *y,
			fastf_t *x, int n));
BU_EXTERN(void rt_nurb_p_mat, (const fastf_t * mat, int dim));

/* nurb_split.c */
BU_EXTERN(void rt_nurb_s_split, (struct bu_list *split_hd, const struct face_g_snurb *srf,
			int dir, struct resource *res));
BU_EXTERN(void rt_nurb_c_split, (struct bu_list *split_hd, const struct edge_g_cnurb *crv));

/* nurb_util.c */
BU_EXTERN(struct face_g_snurb *rt_nurb_new_snurb, (int u_order, int v_order,
			int n_u_knots, int n_v_knots,
			int n_rows, int n_cols, int pt_type, struct resource *res));
BU_EXTERN(struct edge_g_cnurb *rt_nurb_new_cnurb, (int order, int n_knots,
			int n_pts, int pt_type));
BU_EXTERN(void rt_nurb_free_snurb, (struct face_g_snurb *srf, struct resource *res));
BU_EXTERN(void rt_nurb_free_cnurb, (struct edge_g_cnurb * crv));
BU_EXTERN(void rt_nurb_c_print, (const struct edge_g_cnurb *crv));
BU_EXTERN(void rt_nurb_s_print, (char *c, const struct face_g_snurb *srf));
BU_EXTERN(void rt_nurb_pr_kv, (const struct knot_vector *kv));
BU_EXTERN(void rt_nurb_pr_mesh, (const struct face_g_snurb *m));
BU_EXTERN(void rt_nurb_print_pt_type, (int c));

/* nurb_xsplit.c */
BU_EXTERN(struct face_g_snurb *rt_nurb_s_xsplit, (struct face_g_snurb *srf,
			fastf_t param, int dir));
BU_EXTERN(struct edge_g_cnurb *rt_nurb_c_xsplit, (struct edge_g_cnurb *crv, fastf_t param));

/* oslo_calc.c */
BU_EXTERN(struct oslo_mat *rt_nurb_calc_oslo, (int order,
			const struct knot_vector *tau_kv,
			struct knot_vector *t_kv, struct resource *res));
BU_EXTERN(void rt_nurb_pr_oslo, (struct oslo_mat *om));
BU_EXTERN(void rt_nurb_free_oslo, (struct oslo_mat *om, struct resource *res));

/* oslo_map.c */
BU_EXTERN(void rt_nurb_map_oslo, (struct oslo_mat *oslo,
			fastf_t *old_pts, fastf_t *new_pts,
			int o_stride, int n_stride,
			int lower, int upper, int pt_type));

/* bezier_2d_isect.c */
BU_EXTERN( int CrossingCount, (point2d_t *V, int degree, point2d_t ray_start,
			       point2d_t ray_dir, point2d_t ray_perp ) );
BU_EXTERN( int ControlPolygonFlatEnough, (point2d_t *V, int degree, fastf_t epsilon ) );
BU_EXTERN( void Bezier, (point2d_t *V, int degree, double t,
			 point2d_t *Left, point2d_t *Right, point2d_t eval_pt, point2d_t normal ) );
BU_EXTERN( int FindRoots, (point2d_t *w, int degree, point2d_t **intercept, point2d_t **normal,
			   point2d_t ray_start, point2d_t ray_dir, point2d_t ray_perp,
			   int depth, fastf_t epsilon) );
BU_EXTERN( struct bezier_2d_list *subdivide_bezier, (struct bezier_2d_list *bezier_hd, int degree,
							fastf_t epsilon, int depth) );
#endif

@


11.10
log
@update copyright to include span through 2003
@
text
@d21 1
a21 1
 *  $Header: /c/CVS/brlcad/h/nurb.h,v 11.9 2001/04/27 14:50:59 jra Exp $
@


11.9
log
@Added normal calculations to Bezier curves
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1991 by the United States Army.
d21 1
a21 1
 *  $Header: /c/CVS/brlcad/h/nurb.h,v 11.8 2001/04/25 13:44:40 jra Exp $
@


11.9.4.1
log
@sync branch with HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1991-2004 by the United States Army.
d21 1
a21 1
 *  $Header$
@


11.9.6.1
log
@sync to HEAD...
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1991-2004 by the United States Army.
d21 1
a21 1
 *  $Header: /n/cad/c/CVS/brlcad/h/nurb.h,v 11.10 2004/02/02 17:39:02 morrison Exp $
@


11.9.12.1
log
@merge from HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1991-2004 by the United States Army.
d21 1
a21 1
 *  $Header: /c/CVS/brlcad/h/nurb.h,v 11.10 2004/02/02 17:39:02 morrison Exp $
@


11.9.12.2
log
@merge from head
@
text
@d21 1
a21 1
 *  $Header: /c/CVS/brlcad/h/nurb.h,v 11.9.12.1 2004/02/12 18:32:35 erikg Exp $
@


11.8
log
@Additions for bezier curves
@
text
@d21 1
a21 1
 *  $Header: /c/CVS/brlcad/h/nurb.h,v 11.7 2001/04/05 19:35:07 morrison Exp $
d289 2
a290 2
			 point2d_t *Left, point2d_t *Right, point2d_t eval_pt ) );
BU_EXTERN( int FindRoots, (point2d_t *w, int degree, point2d_t **intercept,
@


11.7
log
@updated SIGNED to signed
updated CONST to const
@
text
@d21 1
a21 1
 *  $Header: /c/CVS/brlcad/h/nurb.h,v 11.6 1999/11/24 22:55:18 mike Exp $
d130 5
d284 11
d296 1
@


11.6
log
@
Fixed possible re-define of MAX()
@
text
@d21 1
a21 1
 *  $Header: /c/CVS/brlcad/h/nurb.h,v 11.5 1999/07/02 19:15:16 mike Exp $
d136 2
a137 2
			CONST struct face_g_snurb * srf, struct resource *res));
BU_EXTERN(int rt_bez_check, (CONST struct face_g_snurb * srf));
d146 1
a146 1
BU_EXTERN(struct face_g_snurb *rt_nurb_scopy, (CONST struct face_g_snurb *srf, struct resource *res));
d149 3
a151 3
BU_EXTERN(struct face_g_snurb *rt_nurb_s_diff, (CONST struct face_g_snurb *srf, int dir));
BU_EXTERN(struct edge_g_cnurb *rt_nurb_c_diff, (CONST struct edge_g_cnurb *crv));
BU_EXTERN(void rt_nurb_mesh_diff, (int order, CONST fastf_t *o_pts,
d153 1
a153 1
			CONST fastf_t *knots, int o_stride, int n_stride,
d157 2
a158 2
BU_EXTERN(void rt_nurb_s_eval, (CONST struct face_g_snurb *srf, fastf_t u, fastf_t v, fastf_t * final_value));
BU_EXTERN(void rt_nurb_c_eval, (CONST struct edge_g_cnurb *crv, fastf_t param, fastf_t * final_value));
d161 1
a161 1
			CONST struct knot_vector *k_vec, int k_index, int coords));
d172 1
a172 1
			CONST struct knot_vector *kv,
d177 3
a179 3
			CONST struct knot_vector *kv1,
			CONST struct knot_vector *kv2, struct resource *res));
BU_EXTERN(int rt_nurb_kvcheck, (fastf_t val, CONST struct knot_vector *kv));
d181 1
a181 1
			CONST struct knot_vector *kv,
d184 1
a184 1
			CONST struct knot_vector *old_kv, struct resource *res));
d186 1
a186 1
BU_EXTERN(int rt_knot_index, (CONST struct knot_vector *kv, fastf_t k_value,
d196 1
a196 1
			CONST struct face_g_snurb *srf, fastf_t u, fastf_t v));
d199 3
a201 3
BU_EXTERN(void rt_nurb_plot_snurb, (FILE *fp, CONST struct face_g_snurb *srf));
BU_EXTERN(void rt_nurb_plot_cnurb, (FILE *fp, CONST struct edge_g_cnurb *crv));
BU_EXTERN(void rt_nurb_s_plot, (CONST struct face_g_snurb *srf) );
d205 1
a205 1
			CONST fastf_t *data, int n));
d207 1
a207 1
			CONST fastf_t *data, int ymax, int xmax));
d216 1
a216 1
BU_EXTERN(struct face_g_snurb *rt_nurb_project_srf, (CONST struct face_g_snurb *srf,
d218 1
a218 1
BU_EXTERN(void rt_nurb_clip_srf, (CONST struct face_g_snurb *srf,
d220 1
a220 1
BU_EXTERN(struct face_g_snurb *rt_nurb_region_from_srf, (CONST struct face_g_snurb *srf,
d222 1
a222 1
BU_EXTERN(struct rt_nurb_uv_hit *rt_nurb_intersect, (CONST struct face_g_snurb * srf,
d226 1
a226 1
BU_EXTERN(struct face_g_snurb *rt_nurb_s_refine, (CONST struct face_g_snurb *srf,
d228 1
a228 1
BU_EXTERN(struct edge_g_cnurb *rt_nurb_c_refine, (CONST struct edge_g_cnurb * crv,
d236 1
a236 1
BU_EXTERN(void rt_nurb_forw_solve, (CONST fastf_t *lu, CONST fastf_t *b,
d238 1
a238 1
BU_EXTERN(void rt_nurb_back_solve, (CONST fastf_t *lu, CONST fastf_t *y,
d240 1
a240 1
BU_EXTERN(void rt_nurb_p_mat, (CONST fastf_t * mat, int dim));
d243 1
a243 1
BU_EXTERN(void rt_nurb_s_split, (struct bu_list *split_hd, CONST struct face_g_snurb *srf,
d245 1
a245 1
BU_EXTERN(void rt_nurb_c_split, (struct bu_list *split_hd, CONST struct edge_g_cnurb *crv));
d255 4
a258 4
BU_EXTERN(void rt_nurb_c_print, (CONST struct edge_g_cnurb *crv));
BU_EXTERN(void rt_nurb_s_print, (char *c, CONST struct face_g_snurb *srf));
BU_EXTERN(void rt_nurb_pr_kv, (CONST struct knot_vector *kv));
BU_EXTERN(void rt_nurb_pr_mesh, (CONST struct face_g_snurb *m));
d268 1
a268 1
			CONST struct knot_vector *tau_kv,
@


11.5
log
@
Removed dependency on compat4.h
@
text
@d21 1
a21 1
 *  $Header: /c/CVS/brlcad/h/nurb.h,v 11.4 1997/09/18 20:34:13 jra Exp $
d83 3
a85 3
#define NMG_CK_KNOT(_p)		NMG_CKMAG(_p, RT_KNOT_VECTOR_MAGIC, "knot_vector")
#define NMG_CK_CNURB(_p)	NMG_CKMAG(_p, RT_CNURB_MAGIC, "cnurb")
#define NMG_CK_SNURB(_p)	NMG_CKMAG(_p, RT_SNURB_MAGIC, "snurb")
d121 6
a126 2
#define MAX(i,j)    ( (i) > (j) ? (i) : (j) )
#define MIN(i,j)    ( (i) < (j) ? (i) : (j) )
@


11.4
log
@Mods for addition of pmalloc.
@
text
@d21 1
a21 1
 *  $Header: /m/cad/h/RCS/nurb.h,v 11.3 1996/07/10 20:16:35 jra Exp jra $
d87 1
a87 1
#define GET_CNURB(p/*,m*/) 		{NMG_GETSTRUCT(p, edge_g_cnurb); \
d89 2
a90 2
	RT_LIST_INIT( &(p)->l ); (p)->l.magic = NMG_EDGE_G_CNURB_MAGIC; }
#define GET_SNURB(p/*,m*/) 		{NMG_GETSTRUCT(p, face_g_snurb); \
d92 1
a92 1
	RT_LIST_INIT( &(p)->l ); (p)->l.magic = NMG_FACE_G_SNURB_MAGIC; }
d127 1
a127 1
RT_EXTERN(fastf_t rt_nurb_basis_eval, (struct knot_vector *knts, int interval,
d131 1
a131 1
RT_EXTERN(int rt_nurb_bezier, (struct rt_list *bezier_hd,
d133 1
a133 1
RT_EXTERN(int rt_bez_check, (CONST struct face_g_snurb * srf));
d136 4
a139 4
RT_EXTERN(int rt_nurb_s_bound, (struct face_g_snurb *srf, point_t bmin, point_t bmax));
RT_EXTERN(int rt_nurb_c_bound, (struct edge_g_cnurb *crv, point_t bmin, point_t bmax));
RT_EXTERN(int rt_nurb_s_check, (struct face_g_snurb *srf));
RT_EXTERN(int rt_nurb_c_check, (struct edge_g_cnurb *crv));
d142 1
a142 1
RT_EXTERN(struct face_g_snurb *rt_nurb_scopy, (CONST struct face_g_snurb *srf, struct resource *res));
d145 3
a147 3
RT_EXTERN(struct face_g_snurb *rt_nurb_s_diff, (CONST struct face_g_snurb *srf, int dir));
RT_EXTERN(struct edge_g_cnurb *rt_nurb_c_diff, (CONST struct edge_g_cnurb *crv));
RT_EXTERN(void rt_nurb_mesh_diff, (int order, CONST fastf_t *o_pts,
d153 3
a155 3
RT_EXTERN(void rt_nurb_s_eval, (CONST struct face_g_snurb *srf, fastf_t u, fastf_t v, fastf_t * final_value));
RT_EXTERN(void rt_nurb_c_eval, (CONST struct edge_g_cnurb *crv, fastf_t param, fastf_t * final_value));
RT_EXTERN(fastf_t *rt_nurb_eval_crv, (fastf_t *crv, int order,
d158 1
a158 1
RT_EXTERN(void rt_nurb_pr_crv, (fastf_t *crv, int c_size, int coords));
d161 2
a162 2
RT_EXTERN(int rt_nurb_s_flat, (struct face_g_snurb *srf, fastf_t epsilon));
RT_EXTERN(fastf_t rt_nurb_crv_flat, (fastf_t *crv, int	size, int pt_type));
d165 1
a165 1
RT_EXTERN(void rt_nurb_kvknot, (struct knot_vector *new_knots, int order,
d167 1
a167 1
RT_EXTERN(void rt_nurb_kvmult, (struct knot_vector *new_kv,
d170 1
a170 1
RT_EXTERN(void rt_nurb_kvgen, (struct knot_vector *kv,
d172 1
a172 1
RT_EXTERN(void rt_nurb_kvmerge, (struct knot_vector *new_knots,
d175 2
a176 2
RT_EXTERN(int rt_nurb_kvcheck, (fastf_t val, CONST struct knot_vector *kv));
RT_EXTERN(void rt_nurb_kvextract, (struct knot_vector *new_kv,
d179 1
a179 1
RT_EXTERN(void rt_nurb_kvcopy, (struct knot_vector *new_kv,
d181 2
a182 2
RT_EXTERN(void rt_nurb_kvnorm, (struct knot_vector *kv));
RT_EXTERN(int rt_knot_index, (CONST struct knot_vector *kv, fastf_t k_value,
d184 1
a184 1
RT_EXTERN(void rt_nurb_gen_knot_vector, (struct knot_vector *new_knots,
d188 1
a188 1
RT_EXTERN(void rt_nurb_s_norm, (struct face_g_snurb *srf, fastf_t u, fastf_t v, fastf_t * norm));
d191 1
a191 1
RT_EXTERN(void rt_nurb_curvature, (struct curvature *cvp,
d195 3
a197 3
RT_EXTERN(void rt_nurb_plot_snurb, (FILE *fp, CONST struct face_g_snurb *srf));
RT_EXTERN(void rt_nurb_plot_cnurb, (FILE *fp, CONST struct edge_g_cnurb *crv));
RT_EXTERN(void rt_nurb_s_plot, (CONST struct face_g_snurb *srf) );
d200 1
a200 1
RT_EXTERN(void rt_nurb_cinterp, (struct edge_g_cnurb *crv, int order,
d202 1
a202 1
RT_EXTERN(void rt_nurb_sinterp, (struct face_g_snurb *srf, int order,
d206 2
a207 2
RT_EXTERN(struct rt_nurb_poly *rt_nurb_to_poly, (struct face_g_snurb *srf));
RT_EXTERN(struct rt_nurb_poly *rt_nurb_mk_poly,
d212 1
a212 1
RT_EXTERN(struct face_g_snurb *rt_nurb_project_srf, (CONST struct face_g_snurb *srf,
d214 1
a214 1
RT_EXTERN(void rt_nurb_clip_srf, (CONST struct face_g_snurb *srf,
d216 1
a216 1
RT_EXTERN(struct face_g_snurb *rt_nurb_region_from_srf, (CONST struct face_g_snurb *srf,
d218 1
a218 1
RT_EXTERN(struct rt_nurb_uv_hit *rt_nurb_intersect, (CONST struct face_g_snurb * srf,
d222 1
a222 1
RT_EXTERN(struct face_g_snurb *rt_nurb_s_refine, (CONST struct face_g_snurb *srf,
d224 1
a224 1
RT_EXTERN(struct edge_g_cnurb *rt_nurb_c_refine, (CONST struct edge_g_cnurb * crv,
d228 1
a228 1
RT_EXTERN(void rt_nurb_solve, (fastf_t *mat_1, fastf_t *mat_2,
d230 1
a230 1
RT_EXTERN(void rt_nurb_doolittle, (fastf_t *mat_1, fastf_t *mat_2,
d232 1
a232 1
RT_EXTERN(void rt_nurb_forw_solve, (CONST fastf_t *lu, CONST fastf_t *b,
d234 1
a234 1
RT_EXTERN(void rt_nurb_back_solve, (CONST fastf_t *lu, CONST fastf_t *y,
d236 1
a236 1
RT_EXTERN(void rt_nurb_p_mat, (CONST fastf_t * mat, int dim));
d239 1
a239 1
RT_EXTERN(void rt_nurb_s_split, (struct rt_list *split_hd, CONST struct face_g_snurb *srf,
d241 1
a241 1
RT_EXTERN(void rt_nurb_c_split, (struct rt_list *split_hd, CONST struct edge_g_cnurb *crv));
d244 1
a244 1
RT_EXTERN(struct face_g_snurb *rt_nurb_new_snurb, (int u_order, int v_order,
d247 1
a247 1
RT_EXTERN(struct edge_g_cnurb *rt_nurb_new_cnurb, (int order, int n_knots,
d249 7
a255 7
RT_EXTERN(void rt_nurb_free_snurb, (struct face_g_snurb *srf, struct resource *res));
RT_EXTERN(void rt_nurb_free_cnurb, (struct edge_g_cnurb * crv));
RT_EXTERN(void rt_nurb_c_print, (CONST struct edge_g_cnurb *crv));
RT_EXTERN(void rt_nurb_s_print, (char *c, CONST struct face_g_snurb *srf));
RT_EXTERN(void rt_nurb_pr_kv, (CONST struct knot_vector *kv));
RT_EXTERN(void rt_nurb_pr_mesh, (CONST struct face_g_snurb *m));
RT_EXTERN(void rt_nurb_print_pt_type, (int c));
d258 1
a258 1
RT_EXTERN(struct face_g_snurb *rt_nurb_s_xsplit, (struct face_g_snurb *srf,
d260 1
a260 1
RT_EXTERN(struct edge_g_cnurb *rt_nurb_c_xsplit, (struct edge_g_cnurb *crv, fastf_t param));
d263 1
a263 1
RT_EXTERN(struct oslo_mat *rt_nurb_calc_oslo, (int order,
d266 2
a267 2
RT_EXTERN(void rt_nurb_pr_oslo, (struct oslo_mat *om));
RT_EXTERN(void rt_nurb_free_oslo, (struct oslo_mat *om, struct resource *res));
d270 1
a270 1
RT_EXTERN(void rt_nurb_map_oslo, (struct oslo_mat *oslo,
@


11.3
log
@changed declaration of rt_nurb_p_mat() to void.
@
text
@d21 1
a21 1
 *  $Header: /m/cad/h/RCS/nurb.h,v 11.2 1995/12/01 02:41:17 mike Exp jra $
d132 1
a132 1
			CONST struct face_g_snurb * srf));
d142 1
a142 1
RT_EXTERN(struct face_g_snurb *rt_nurb_scopy, (CONST struct face_g_snurb *srf));
d166 1
a166 1
			fastf_t lower, fastf_t upper, int num));
d169 1
a169 1
			int num, fastf_t val));
d171 1
a171 1
			fastf_t lower, fastf_t upper, int num));
d174 1
a174 1
			CONST struct knot_vector *kv2));
d178 1
a178 1
			int lower, int upper));
d180 1
a180 1
			CONST struct knot_vector *old_kv));
d185 1
a185 1
			int order, fastf_t lower, fastf_t upper));
d213 1
a213 1
			plane_t plane1, plane_t plane2));
d217 1
a217 1
			int dir, fastf_t param1, fastf_t param2));
d219 1
a219 1
			plane_t plane1, plane_t plane2, double uv_tol));
d223 1
a223 1
			int dir, struct knot_vector *kv));
d239 2
a240 1
RT_EXTERN(void rt_nurb_s_split, (struct rt_list *split_hd, CONST struct face_g_snurb *srf, int dir));
d246 1
a246 1
			int n_rows, int n_cols, int pt_type));
d249 1
a249 1
RT_EXTERN(void rt_nurb_free_snurb, (struct face_g_snurb *srf));
d265 1
a265 1
			struct knot_vector *t_kv));
d267 1
a267 1
RT_EXTERN(void rt_nurb_free_oslo, (struct oslo_mat *om));
@


11.2
log
@LIBNURB data structures have been fully merged withNMG data structures.
@
text
@d21 1
a21 1
 *  $Header: /m/cad/h/RCS/nurb.h,v 11.1 95/01/04 09:48:28 mike Rel4_4 $
d236 1
a236 1
RT_EXTERN(int rt_nurb_p_mat, (CONST fastf_t * mat, int dim));
@


11.1
log
@Release_4.4
@
text
@d21 1
a21 1
 *  $Header: /m/cad/h/RCS/nurb.h,v 10.18 94/12/27 15:20:28 stay Exp $
d87 1
a87 1
#define GET_CNURB(p/*,m*/) 		{NMG_GETSTRUCT(p, cnurb); \
d89 2
a90 2
	RT_LIST_INIT( &(p)->l ); (p)->l.magic = RT_CNURB_MAGIC; }
#define GET_SNURB(p/*,m*/) 		{NMG_GETSTRUCT(p, snurb); \
d92 1
a92 1
	RT_LIST_INIT( &(p)->l ); (p)->l.magic = RT_SNURB_MAGIC; }
a93 13
/* ----- The actual data structures for curves and surfaces ----- */

struct cnurb {
	struct rt_list	l;		/* magic, forw */
	int		order;		/* Curve Order */
	struct knot_vector knot;	/* curve knot vector */
	/* curve control polygon */
	int		c_size;		/* number of ctl points */
	int		pt_type;	/* curve point type */
	fastf_t		* ctl_points;	/* array [c_size] */
	long		index;		/* struct # in this model */
};

a95 15
struct snurb {
	struct rt_list	l;		/* magic, forw */
	int		order[2];	/* surface order [0] = u, [1] = v */
	int		dir;		/* last direction of refinement */
	struct knot_vector u_knots;	/* surface knot vectors */
	struct knot_vector v_knots;	/* surface knot vectors */
	/* surface control points */
	int		s_size[2];	/* mesh size, u,v */
	int		pt_type;	/* surface point type */
	fastf_t		* ctl_points; 	/* array [size[0]*size[1]] */
	point_t		min_pt;		/* minimums of bounding box */
	point_t		max_pt;		/* maximums of bounding box */
	long		index;		/* struct # in this model */
};

d124 2
d132 2
a133 2
			CONST struct snurb * srf));
RT_EXTERN(int rt_bez_check, (CONST struct snurb * srf));
d136 4
a139 4
RT_EXTERN(int rt_nurb_s_bound, (struct snurb *srf, point_t bmin, point_t bmax));
RT_EXTERN(int rt_nurb_c_bound, (struct cnurb *crv, point_t bmin, point_t bmax));
RT_EXTERN(int rt_nurb_s_check, (struct snurb *srf));
RT_EXTERN(int rt_nurb_c_check, (struct cnurb *crv));
d142 1
a142 1
RT_EXTERN(struct snurb *rt_nurb_scopy, (CONST struct snurb *srf));
d145 2
a146 2
RT_EXTERN(struct snurb *rt_nurb_s_diff, (CONST struct snurb *srf, int dir));
RT_EXTERN(struct cnurb *rt_nurb_c_diff, (CONST struct cnurb *crv));
d153 2
a154 2
RT_EXTERN(void rt_nurb_s_eval, (CONST struct snurb *srf, fastf_t u, fastf_t v, fastf_t * final_value));
RT_EXTERN(void rt_nurb_c_eval, (CONST struct cnurb *crv, fastf_t param, fastf_t * final_value));
d161 1
a161 1
RT_EXTERN(int rt_nurb_s_flat, (struct snurb *srf, fastf_t epsilon));
d188 1
a188 1
RT_EXTERN(void rt_nurb_s_norm, (struct snurb *srf, fastf_t u, fastf_t v, fastf_t * norm));
d192 1
a192 1
			CONST struct snurb *srf, fastf_t u, fastf_t v));
d195 3
a197 3
RT_EXTERN(void rt_nurb_plot_snurb, (FILE *fp, CONST struct snurb *srf));
RT_EXTERN(void rt_nurb_plot_cnurb, (FILE *fp, CONST struct cnurb *crv));
RT_EXTERN(void rt_nurb_s_plot, (CONST struct snurb *srf) );
d200 1
a200 1
RT_EXTERN(void rt_nurb_cinterp, (struct cnurb *crv, int order,
d202 1
a202 1
RT_EXTERN(void rt_nurb_sinterp, (struct snurb *srf, int order,
d206 1
a206 1
RT_EXTERN(struct rt_nurb_poly *rt_nurb_to_poly, (struct snurb *srf));
d212 1
a212 1
RT_EXTERN(struct snurb *rt_nurb_project_srf, (CONST struct snurb *srf,
d214 1
a214 1
RT_EXTERN(void rt_nurb_clip_srf, (CONST struct snurb *srf,
d216 1
a216 1
RT_EXTERN(struct snurb *rt_nurb_region_from_srf, (CONST struct snurb *srf,
d218 1
a218 1
RT_EXTERN(struct rt_nurb_uv_hit *rt_nurb_intersect, (CONST struct snurb * srf,
d222 1
a222 1
RT_EXTERN(struct snurb *rt_nurb_s_refine, (CONST struct snurb *srf,
d224 1
a224 1
RT_EXTERN(struct cnurb *rt_nurb_c_refine, (CONST struct cnurb * crv,
d239 2
a240 2
RT_EXTERN(void rt_nurb_s_split, (struct rt_list *split_hd, CONST struct snurb *srf, int dir));
RT_EXTERN(void rt_nurb_c_split, (struct rt_list *split_hd, CONST struct cnurb *crv));
d243 1
a243 1
RT_EXTERN(struct snurb *rt_nurb_new_snurb, (int u_order, int v_order,
d246 1
a246 1
RT_EXTERN(struct cnurb *rt_nurb_new_cnurb, (int order, int n_knots,
d248 4
a251 4
RT_EXTERN(void rt_nurb_free_snurb, (struct snurb *srf));
RT_EXTERN(void rt_nurb_free_cnurb, (struct cnurb * crv));
RT_EXTERN(void rt_nurb_c_print, (CONST struct cnurb *crv));
RT_EXTERN(void rt_nurb_s_print, (char *c, CONST struct snurb *srf));
d253 1
a253 1
RT_EXTERN(void rt_nurb_pr_mesh, (CONST struct snurb *m));
d257 1
a257 1
RT_EXTERN(struct snurb *rt_nurb_s_xsplit, (struct snurb *srf,
d259 1
a259 1
RT_EXTERN(struct cnurb *rt_nurb_c_xsplit, (struct cnurb *crv, fastf_t param));
a272 1

@


10.18
log
@fixed nurb_norm parameters
@
text
@d21 1
a21 1
 *  $Header: /n/wolf/m/cad/h/RCS/nurb.h,v 10.17 1994/12/27 15:00:00 stay Exp stay $
@


10.17
log
@fixed prototype calls to rt_nurb_s_eval and rt_nurb_c_eval
@
text
@d21 1
a21 1
 *  $Header: /n/wolf/m/cad/h/RCS/nurb.h,v 10.16 1994/11/08 05:12:38 mike Exp stay $
d214 1
a214 1
RT_EXTERN(fastf_t *rt_nurb_s_norm, (struct snurb *srf, fastf_t u, fastf_t v));
@


10.16
log
@Added new externs.
@
text
@d21 1
a21 1
 *  $Header: /m/cad/h/RCS/nurb.h,v 10.15 94/11/08 01:25:49 mike Exp Locker: mike $
d179 2
a180 2
RT_EXTERN(fastf_t *rt_nurb_s_eval, (CONST struct snurb *srf, fastf_t u, fastf_t v));
RT_EXTERN(fastf_t *rt_nurb_c_eval, (CONST struct cnurb *crv, fastf_t param));
@


10.15
log
@Some CONST routines
@
text
@d21 1
a21 1
 *  $Header: /m/cad/h/RCS/nurb.h,v 10.14 94/09/20 23:58:33 mike Exp Locker: mike $
d221 9
a229 1
RT_EXTERN(void rt_nurb_s_plot, (struct snurb *srf) );
@


10.14
log
@Knot vector definition moved to nmg.h
Now auto-includes nmg.h
@
text
@d21 1
a21 1
 *  $Header: /m/cad/h/RCS/nurb.h,v 10.13 94/09/13 21:03:00 mike Exp Locker: mike $
d250 5
a254 3
RT_EXTERN(void rt_nurb_forw_solve, (fastf_t *lu, fastf_t *b, fastf_t *y, int n));
RT_EXTERN(void rt_nurb_back_solve, (fastf_t *lu, fastf_t *y, fastf_t *x, int n));
RT_EXTERN(int rt_nurb_p_mat, (fastf_t * mat, int dim));
@


10.13
log
@Added #ifndef
@
text
@d21 1
a21 1
 *  $Header: /m/cad/h/RCS/nurb.h,v 10.12 94/08/25 14:56:05 gdurf Exp Locker: mike $
d37 4
a86 2
#define GET_KNOT_VECTOR(p/*,m*/)    {NMG_GETSTRUCT(p, knot_vector); \
	/* NMG_INCR_INDEX(p,m); */ }
a92 11

/* Definition of a knot vector */
#ifndef NMG_H
struct knot_vector {
	int		magic;
	int		k_size;		/* knot vector size */
	fastf_t		* knots;	/* pointer to knot vector  */
	long		index;		/* struct # in this model */
};
#endif
#define RT_KNOT_VECTOR_MAGIC	0x6b6e6f74
@


10.12
log
@Removed extra include
@
text
@d21 1
a21 1
 *  $Header: /m/cad/h/RCS/nurb.h,v 10.11 1992/06/03 23:22:20 mike Exp gdurf $
d93 1
a93 1

d100 1
a100 1

@


10.11
log
@Added min/max to snurb
@
text
@d21 1
a21 1
 *  $Header: /m/cad/h/RCS/nurb.h,v 10.10 92/06/03 01:30:53 mike Exp Locker: mike $
a37 1
# include <stdio.h>
@


10.10
log
@Eliminated APX_EQ, made epsilon values explicit
@
text
@d21 1
a21 1
 *  $Header: /m/cad/h/RCS/nurb.h,v 10.9 92/06/02 23:26:21 mike Exp Locker: mike $
d129 2
@


10.9
log
@Changed calling sequence of rt_nurb_curvature.
@
text
@d21 1
a21 1
 *  $Header: /m/cad/h/RCS/nurb.h,v 10.8 92/06/02 22:44:42 mike Exp Locker: mike $
a156 2
#define EPSILON 0.0001
#define APX_EQ(x,y)    (fabs(x - y) < EPSILON)
@


10.8
log
@Changed to rt_list structs.
Plus, CONSTs and such
@
text
@d21 1
a21 1
 *  $Header: /m/cad/h/RCS/nurb.h,v 10.7 92/05/29 01:17:21 mike Exp Locker: mike $
d227 2
a228 1
RT_EXTERN(struct curvature *rt_nurb_curvature, (struct snurb *srf, fastf_t u, fastf_t v));
@


10.7
log
@Control polygon/mesh is now just part of the cnurb/snurb structures,
rather than being a separate structure of it's own.
@
text
@d21 1
a21 1
 *  $Header: /m/cad/h/RCS/nurb.h,v 10.6 92/05/29 00:51:30 mike Exp Locker: mike $
d78 15
d99 1
d107 1
a107 2
	int		magic;
	struct cnurb	* next;		/* next curve in list */
d114 1
d120 1
a120 2
	int		magic;
	struct snurb	* next;		/* next surface */
d129 1
d142 6
d149 1
d167 3
a169 2
RT_EXTERN(struct snurb *rt_nurb_bezier, (struct snurb * srf));
RT_EXTERN(int rt_bez_check, (struct snurb * srf));
d178 1
a178 1
RT_EXTERN(struct snurb *rt_nurb_scopy, (struct snurb *srf));
d181 5
a185 4
RT_EXTERN(struct snurb *rt_nurb_s_diff, (struct snurb *srf, int	dir));
RT_EXTERN(struct cnurb *rt_nurb_c_diff, (struct cnurb *crv));
RT_EXTERN(void rt_nurb_mesh_diff, (int order, fastf_t *o_pts, fastf_t *n_pts,
			fastf_t *knots, int o_stride, int n_stride,
d189 5
a193 4
RT_EXTERN(fastf_t *rt_nurb_s_eval, (struct snurb *srf, fastf_t u, fastf_t v));
RT_EXTERN(fastf_t *rt_nurb_c_eval, (struct cnurb *crv, fastf_t param));
RT_EXTERN(fastf_t *rt_nurb_eval_crv, (fastf_t *crv, int order, fastf_t param,
			struct knot_vector *k_vec, int k_index, int coords));
d239 1
a239 1
RT_EXTERN(struct snurb *rt_nurb_project_srf, (struct snurb *srf,
d241 1
a241 1
RT_EXTERN(void rt_nurb_clip_srf, (struct snurb *srf,
d243 1
a243 1
RT_EXTERN(struct snurb *rt_nurb_region_from_srf, (struct snurb *srf,
d245 2
d249 1
a249 1
RT_EXTERN(struct snurb *rt_nurb_s_refine, (struct snurb *srf,
d251 1
a251 1
RT_EXTERN(struct cnurb *rt_nurb_c_refine, (struct cnurb * crv,
d264 2
a265 2
RT_EXTERN(struct snurb *rt_nurb_s_split, (struct snurb * srf, int dir));
RT_EXTERN(struct cnurb *rt_nurb_c_split, (struct cnurb * crv));
d275 4
a278 4
RT_EXTERN(void rt_nurb_c_print, (struct cnurb *crv));
RT_EXTERN(void rt_nurb_s_print, (char *c, struct snurb *srf));
RT_EXTERN(void rt_nurb_pr_kv, (struct knot_vector *kv));
RT_EXTERN(void rt_nurb_pr_mesh, (struct snurb *m));
d288 2
a289 1
			struct knot_vector *tau_kv, struct knot_vector *t_kv));
@


10.6
log
@Data structure revisions:  mesh and knots are no longer pointers,
but in-place structures.
@
text
@d21 1
a21 1
 *  $Header: /m/cad/h/RCS/nurb.h,v 10.5 92/05/28 22:10:11 mike Exp Locker: mike $
d78 2
d81 3
a83 2
	int	k_size;			/* knot vector size */
	fastf_t * knots;		/* pointer to knot vector  */
d86 1
a86 5
struct c_mesh {
	int	c_size;			/* number of ctl points */
	int	pt_type;		/* curve point type */
	fastf_t * ctl_points;  		/* array [c_size] */
};
d88 1
a88 5
struct s_mesh {
	int	s_size[2];		/* mesh size, u,v */
	int	pt_type;		/* surface point type */
	fastf_t * ctl_points; 		/* array [size[0]*size[1]] */
};
d91 1
d95 4
a98 1
	struct c_mesh	mesh;		/* curve control polygon */
d101 2
d104 1
d110 4
a113 1
	struct s_mesh	mesh;		/* surface control points */
d116 2
d204 1
d250 1
a250 1
RT_EXTERN(void rt_nurb_pr_mesh, (struct s_mesh *m));
@


10.5
log
@Expanded names of manifest constants
@
text
@d21 1
a21 1
 *  $Header: /m/cad/h/RCS/nurb.h,v 10.4 92/05/27 16:56:04 mike Exp Locker: mike $
d64 1
a64 1
#define RT_NURB_RT_NURB_PT_XYZ	2			/* x,y,z coordinates */
d98 2
a99 2
	struct knot_vector * knot;	/* curve knot vector */
	struct c_mesh	* mesh;		/* curve control polygon */
d106 3
a108 3
	struct knot_vector * u_knots;	/* surface knot vectors */
	struct knot_vector * v_knots;	/* surface knot vectors */
	struct s_mesh	* mesh;		/* surface control points */
d168 1
a168 1
RT_EXTERN(struct knot_vector *rt_nurb_kvknot, (int order,
d170 2
a171 1
RT_EXTERN(struct knot_vector *rt_nurb_kvmult, (struct knot_vector *kv,
d173 8
a180 6
RT_EXTERN(struct knot_vector *rt_nurb_kvgen, (fastf_t lower, fastf_t upper,
			int num));
RT_EXTERN(struct knot_vector *rt_nurb_kvmerge, (struct knot_vector *kv1,
			struct knot_vector *kv2));
RT_EXTERN(int rt_nurb_kvcheck, (fastf_t val, struct knot_vector *kv));
RT_EXTERN(struct knot_vector *rt_nurb_kvextract, (struct knot_vector *kv,
d182 2
a183 1
RT_EXTERN(struct knot_vector *rt_nurb_kvcopy, (struct knot_vector *old_kv));
d185 1
a185 1
RT_EXTERN(int rt_knot_index, (struct knot_vector *kv, fastf_t k_value,
d187 2
a188 2
RT_EXTERN(struct knot_vector *rt_nurb_gen_knot_vector, (int order,
			fastf_t lower, fastf_t upper));
@


10.4
log
@Minor indentation and name changes.
@
text
@d21 1
a21 1
 *  $Header: /m/cad/h/RCS/nurb.h,v 10.3 92/05/23 18:04:49 butler Exp Locker: mike $
d44 3
a46 3
#define ROW 0
#define COL 1
#define FLAT 2
d63 5
a67 5
#define PT_XY 	1			/* x,y coordintes */
#define PT_XYZ	2			/* x,y,z coordinates */
#define PT_UV	3			/* trim u,v parameter space */
#define PT_DATA 4			/* random data */
#define PT_PROJ	5			/* Projected Surface */
d69 2
a70 2
#define RAT	1
#define NONRAT  0
d72 5
a76 5
#define MAKE_PT_TYPE(n,t,h)	((n<<5) | (t<<1) | h)
#define EXTRACT_COORDS(pt)	(pt>>5)
#define EXTRACT_PT_TYPE(pt)		((pt>>1) & 0x0f)
#define EXTRACT_RAT(pt)		(pt & 0x1)
#define STRIDE(pt)		(EXTRACT_COORDS(pt) * sizeof( fastf_t))
@


10.3
log
@changed extern of rt_nurb_curvature() to reflect proper return type
@
text
@d21 1
a21 1
 *  $Header: /m/cad/h/RCS/nurb.h,v 10.2 92/04/13 10:21:55 stay Exp Locker: butler $
d79 1
a79 1
	int k_size;			/* knot vector size */
d84 3
a86 3
	int c_size;		/* number of ctl points */
	int pt_type;		/* curve point type */
	fastf_t * ctl_points;   /* floating point values from machine.h */
d90 3
a92 3
	int s_size[2];		/* mesh size */
	int pt_type;		/* surface point type */
	fastf_t * ctl_points;   /* floating point values from machine.h */
d96 2
a97 2
	struct cnurb * next;		/* next curve in list */
	int order;			/* Curve Order */
d99 1
a99 1
	struct c_mesh * mesh;		/* curve control polygon */
d103 3
a105 4
	struct snurb * next;		/* next surface */
	struct cnurb * trim;		/* surface trimming curves */
	int order[2];			/* surface order [0] = u, [1] = v */
	short dir;			/* last direction of refinement */
d108 1
a108 1
	struct s_mesh * mesh;		/* surface control points */
d111 2
d115 2
a116 2
	point_t ply[3];			/* Vertices */
	fastf_t uv[3][2];		/* U,V parametric values */
d122 3
a124 3
	int offset;
	int osize;
	fastf_t * o_vec;
a130 1
#define SPL_INFINIT	(1.0e20)
d152 1
a152 2
/* XXX Needs new name */
RT_EXTERN(int internal_mesh_diff, (int order, fastf_t *o_pts, fastf_t *n_pts,
d159 1
a159 2
/* XXX Needs new name */
RT_EXTERN(fastf_t *internal_eval_crv, (fastf_t *crv, int order, fastf_t param,
d161 1
a161 1
RT_EXTERN(void internal_pr_crv, (fastf_t *crv, int c_size, int coords));
d165 1
a165 1
RT_EXTERN(fastf_t internal_crv_flat, (fastf_t *crv, int	size, int pt_type));
@


10.2
log
@added nurb_curvature routines for ansiposix definition
@
text
@d21 1
a21 1
 *  $Header: /m/cad/h/RCS/nurb.h,v 10.1 91/10/12 06:35:27 mike Rel4_0 Locker: stay $
d192 1
a192 1
RT_EXTERN(fastf_t *rt_nurb_curvature, (struct snurb *srf, fastf_t u, fastf_t v));
@


10.1
log
@Release_4.0
@
text
@d21 1
a21 1
 *  $Header: /m/cad/h/RCS/nurb.h,v 1.6 91/08/30 20:36:04 mike Exp $
d190 3
@


1.6
log
@rt_nurb_clip_srf() now returns void
@
text
@d21 1
a21 1
 *  $Header: /m/cad/h/RCS/nurb.h,v 1.5 91/07/03 02:19:56 mike Exp $
@


1.5
log
@Moved Homogeneous vector macros from nurb.h to vmath.h
@
text
@d21 1
a21 1
 *  $Header: /m/cad/h/RCS/nurb.h,v 1.4 91/07/01 06:34:44 stay Exp $
d202 1
a202 1
RT_EXTERN(struct s_mesh *rt_nurb_clip_srf, (struct snurb *srf,
@


1.4
log
@added some homogeneous HV calls.
@
text
@d21 1
a21 1
 *  $Header: /m/cad/h/RCS/nurb.h,v 1.3 91/06/23 03:43:19 mike Exp $
a130 18
/* These  are used for homogeneous coordinates */

#define HVMOVE( a, b)       \
	(a)[0] = (b)[0];\
	(a)[1] = (b)[1];\
	(a)[2] = (b)[2];\
	(a)[3] = (b)[3];

#define HVJOIN1( a, b, c, d) \
	(a)[0] = (b)[0] + (c) * (d)[0]; \
	(a)[1] = (b)[1] + (c) * (d)[1]; \
	(a)[2] = (b)[2] + (c) * (d)[2]; \
	(a)[3] = (b)[3] + (c) * (d)[3];

#define HVSCALE( a, b, c )    (a)[0] = (b)[0] * (c);\
	(a)[1] = (b)[1] * (c);\
	(a)[2] = (b)[2] * (c);\
	(a)[3] = (b)[3] * (c);
@


1.3
log
@Added function prototypes
@
text
@d21 1
a21 1
 *  $Header: /m/cad/h/RCS/nurb.h,v 1.2 91/06/23 03:04:46 mike Exp $
d131 18
@


1.2
log
@Shuffled #includes around
@
text
@d21 1
a21 1
 *  $Header: /m/cad/h/RCS/nurb.h,v 1.1 91/06/14 09:55:57 stay Exp $
a29 1
# include <stdio.h>
d38 1
d132 3
a134 9
struct knot_vector * rt_nurb_kvknot();
struct knot_vector * rt_nurb_kvmult();
struct knot_vector * rt_nurb_kvgen();
struct knot_vector * rt_nurb_kvmerge();
struct knot_vector * rt_nurb_kvextract();
struct knot_vector * rt_nurb_kvcopy();
int rt_nurb_kvcheck();
void rt_nurb_kvnorm();
int rt_knot_index();
d136 3
d140 117
a256 4
fastf_t rt_nurb_basis_eval();
struct oslo_mat * rt_nurb_calc_oslo();
void rt_nurb_pr_oslo();
void rt_nurb_map_oslo();
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	   N U R B . H
d18 1
a18 1
 *	This software is Copyright (C) 1986 by the United States Army.
d21 1
a21 1
 *  $Header: /m/cad/libnurb/nurb.h,v 1.2 91/05/18 02:42:14 stay Exp $
a23 5
#ifndef RAYTRACE_H
# include <stdio.h>
# include "raytrace.h"
#endif

d30 2
a31 1
#include "machine.h"
d35 5
a39 1
#include "vmath.h"
@
