head	11.7;
access;
symbols
	ansi-20040405-merged:11.6
	postmerge-20040405-ansi:11.6
	premerge-20040404-ansi:11.6
	postmerge-autoconf:11.6
	autoconf-freeze:11.6
	premerge-autoconf:11.6
	ansi-20040316-freeze:11.6
	postmerge-20040315-windows:11.6
	premerge-20040315-windows:11.6
	windows-20040315-freeze:11.6
	autoconf-20031203:11.6
	autoconf-20031202:11.6
	autoconf-branch:11.6.0.14
	phong-branch:11.6.0.12
	photonmap-branch:11.6.0.10
	rel-6-1-DP:11.6
	windows-branch:11.6.0.8
	rel-6-0-2:11.6
	ansi-branch:11.6.0.6
	rel-6-0-1-branch:11.6.0.4
	hartley-6-0-post:11.6
	hartley-6-0-pre:11.6
	rel-6-0-1:11.6
	rel-6-0:11.6
	rel-5-4:11.6
	offsite-5-3-pre:11.6
	rel-5-3:11.6
	rel-5-2:11.6
	rel-5-1-branch:11.6.0.2
	rel-5-1:11.6
	rel-5-0:11.6
	rel-5-0-beta:11.6
	rel-4-5:11.6
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.7
date	2004.05.24.04.11.53;	author morrison;	state dead;
branches;
next	11.6;

11.6
date	98.01.29.07.52.24;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	95.09.22.02.34.26;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.09.22.02.33.01;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.09.07.22.36.48;	author butler;	state Exp;
branches;
next	11.2;

11.2
date	95.09.07.21.43.16;	author butler;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.48.43;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.11.05.01.53.52;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.05.02.16.21.34;	author cjohnson;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.35.37;	author mike;	state Rel4_0;
branches;
next	1.8;

1.8
date	91.08.27.00.43.49;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	91.06.29.21.08.26;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	91.06.13.07.04.42;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	91.05.31.23.42.14;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	90.12.08.07.29.01;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	90.12.08.07.09.53;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	90.11.22.06.56.40;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	90.11.11.02.39.28;	author mike;	state Exp;
branches;
next	;


desc
@Definitions and macros for the RT variable length string routines.
@


11.7
log
@moved/renamed from top-level h/ to top-level include/
@
text
@/*
 *  RTSTRING.H has been absorbed into BU.H
 *  The data type is now "struct bu_vls".
 *  Compatability macros are provided in "compat4.h"
 *	-Mike
 */
#include "compat4.h"
@


11.6
log
@rtstring is a stub, the real meat has moved to bu.h
@
text
@@


11.5
log
@Another CONST
@
text
@d2 4
a5 17
 *			R T S T R I N G . H
 *
 *  Definitions and macros for the RT variable length string routines.
 *
 *  Author -
 *	Michael John Muuss
 *
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Status -
 *      Public Domain, Distribution Unlimitied.
 *
 *  $Header: /n/wolf/m/cad/h/RCS/rtstring.h,v 11.4 1995/09/22 02:33:01 mike Exp mike $
d7 1
a7 78

#ifndef SEEN_RTSTRING_H
#define SEEN_RTSTRING_H yes
/*
 *  Macros for providing function prototypes, regardless of whether
 *  the compiler understands them or not.
 *  It is vital that the argument list given for "args" be enclosed
 *  in parens.
 */
#if __STDC__ || defined(USE_PROTOTYPES)
#       define  RT_VLS_EXTERN(type_and_name,args)  extern type_and_name args
#       define  RT_VLS_ARGS(args)                  args
#else
#       define  RT_VLS_EXTERN(type_and_name,args)  extern type_and_name()
#       define  RT_VLS_ARGS(args)                  ()
#endif

struct rt_vls  {
	long	vls_magic;
	char	*vls_str;	/* Dynamic memory for buffer */
	int	vls_offset;	/* Offset into vls_str where data is good */
	int	vls_len;	/* Length, not counting the null */
	int	vls_max;
};
#define RT_VLS_MAGIC		0x89333bbb

#define RT_VLS_CHECK(_vp) { if ( !(_vp) || (_vp)->vls_magic != RT_VLS_MAGIC) { \
				fprintf(stderr, \
				"in %s at line %d RT_VLS_CHECK fails\n", \
				__FILE__, __LINE__); \
				rt_vls_bomb("RT_VLS_CHECK", _vp); }}

/*
 *			R T _ V L S _ A D D R
 *
 *  Used to get a pointer to a vls string.
 *  This macro is obsolete, and just referrs to the subroutine.
 */
#define RT_VLS_ADDR(_vp)	rt_vls_addr(_vp)

/*
 *			R T _ V L S _ I N I T
 *
 *  Used to initialize VLS string structures.
 *  This macro is obsolete, and just referrs to the subroutine.
 */
#define RT_VLS_INIT(_vp)	rt_vls_init(_vp)

/*
 *  Subroutine declarations
 */
RT_VLS_EXTERN(void rt_vls_init, (struct rt_vls *vp) );
RT_VLS_EXTERN(struct rt_vls* rt_vls_vlsinit, () );
RT_VLS_EXTERN(char *rt_vls_addr, (CONST struct rt_vls *vp) );
RT_VLS_EXTERN(char *rt_vls_strdup, (CONST struct rt_vls *vp) );
RT_VLS_EXTERN(char *rt_vls_strgrab, (struct rt_vls *vp) );
RT_VLS_EXTERN(void rt_vls_extend, (struct rt_vls *vp, int extra) );
RT_VLS_EXTERN(int rt_vls_strlen, (CONST struct rt_vls *vp) );
RT_VLS_EXTERN(void rt_vls_trunc, (struct rt_vls *vp, int len) );
RT_VLS_EXTERN(void rt_vls_nibble, (struct rt_vls *vp, int len) );
RT_VLS_EXTERN(void rt_vls_free, (struct rt_vls *vp) );
RT_VLS_EXTERN(void rt_vls_vlsfree, (struct rt_vls *vp) );
RT_VLS_EXTERN(void rt_vls_strcpy, (struct rt_vls *vp, CONST char *s) );
RT_VLS_EXTERN(void rt_vls_strncpy, (struct rt_vls *vp, CONST char *s, int n) );
RT_VLS_EXTERN(void rt_vls_strcat, (struct rt_vls *vp, CONST char *s) );
RT_VLS_EXTERN(void rt_vls_strncat, (struct rt_vls *vp, CONST char *s, int n) );
RT_VLS_EXTERN(void rt_vls_vlscat, (struct rt_vls *dest, CONST struct rt_vls *src) );
RT_VLS_EXTERN(void rt_vls_vlscatzap, (struct rt_vls *dest, struct rt_vls *src) );
RT_VLS_EXTERN(void rt_vls_from_argv, (struct rt_vls *vp, int argc, char **argv) );
RT_VLS_EXTERN(void rt_vls_bomb, (CONST char *str, CONST struct rt_vls *badp) );
RT_VLS_EXTERN(void rt_vls_fwrite, (FILE *fp, CONST struct rt_vls *vp) );
RT_VLS_EXTERN(int rt_vls_gets, (struct rt_vls *vp, FILE *fp) );
RT_VLS_EXTERN(void rt_vls_putc, (struct rt_vls *vp, int c) );
RT_VLS_EXTERN(void rt_vls_printf, (struct rt_vls *vls, char *fmt, ... ) );
RT_VLS_EXTERN(void rt_vls_blkset, (struct rt_vls *vp, int len, int ch) );


#endif /* SEEN_RTSTRING_H */
@


11.4
log
@Added rt_vls_strgrab
@
text
@d18 1
a18 1
 *  $Header: /n/wolf/m/cad/h/RCS/rtstring.h,v 11.3 1995/09/07 22:36:48 butler Exp mike $
d73 1
a73 1
RT_VLS_EXTERN(char *rt_vls_addr, (struct rt_vls *vp) );
@


11.3
log
@added rt_vls_strdup(), rt_vls_vlsinit(), rt_vls_vlsfree()
@
text
@d18 1
a18 1
 *  $Header: /m/cad/h/RCS/rtstring.h,v 11.2 1995/09/07 21:43:16 butler Exp butler $
d74 2
a75 1
RT_VLS_EXTERN(char *rt_vls_strdup, (struct rt_vls *vp) );
@


11.2
log
@breaking Pauls lock.
@
text
@d18 1
a18 1
 *  $Header: /m/cad/h/RCS/rtstring.h,v 11.1 95/01/04 09:48:43 mike Rel4_4 $
d72 1
d74 1
d80 1
@


11.1
log
@Release_4.4
@
text
@d18 1
a18 1
 *  $Header: /m/cad/h/RCS/rtstring.h,v 10.3 94/11/05 01:53:52 mike Exp $
d90 1
@


10.3
log
@Irix 6 really needs VARARGS functions to have prototypes.
@
text
@d18 1
a18 1
 *  $Header: /m/cad/h/RCS/rtstring.h,v 10.2 94/05/02 16:21:34 cjohnson Exp Locker: mike $
@


10.2
log
@Add rt_vls_nibble to take text off the start of a vls string.
Changed data structure to have an "offset" ability.
@
text
@d18 1
a18 1
 *  $Header: /m/cad/h/RCS/rtstring.h,v 10.1 1991/10/12 06:35:37 mike Rel4_0 cjohnson $
d88 3
@


10.1
log
@Release_4.0
@
text
@d18 1
a18 1
 *  $Header: /m/cad/h/RCS/rtstring.h,v 1.8 91/08/27 00:43:49 mike Exp $
d40 1
d76 1
@


1.8
log
@Added rt_vls_gets
@
text
@d18 1
a18 1
 *  $Header: /m/cad/h/RCS/rtstring.h,v 1.7 91/06/29 21:08:26 mike Exp $
@


1.7
log
@lint
@
text
@d18 1
a18 1
 *  $Header: /m/cad/h/RCS/rtstring.h,v 1.6 91/06/13 07:04:42 mike Exp $
d85 1
@


1.6
log
@Added rt_vls_fwrite().
CONSTs
@
text
@d18 1
a18 1
 *  $Header: /m/cad/h/RCS/rtstring.h,v 1.5 91/05/31 23:42:14 mike Exp $
d71 1
a71 1
RT_VLS_EXTERN(char *rt_vls_addr, (CONST struct rt_vls *vp) );
@


1.5
log
@Added USE_PROTOTYPES flag.
@
text
@d18 1
a18 1
 *  $Header: /m/cad/h/RCS/rtstring.h,v 1.4 90/12/08 07:29:01 mike Exp $
d71 1
a71 1
RT_VLS_EXTERN(char *rt_vls_addr, (struct rt_vls *vp) );
d73 1
a73 1
RT_VLS_EXTERN(int rt_vls_strlen, (struct rt_vls *vp) );
d76 5
a80 5
RT_VLS_EXTERN(void rt_vls_strcpy, (struct rt_vls *vp, char *s) );
RT_VLS_EXTERN(void rt_vls_strncpy, (struct rt_vls *vp, char *s, int n) );
RT_VLS_EXTERN(void rt_vls_strcat, (struct rt_vls *vp, char *s) );
RT_VLS_EXTERN(void rt_vls_strncat, (struct rt_vls *vp, char *s, int n) );
RT_VLS_EXTERN(void rt_vls_vlscat, (struct rt_vls *dest, struct rt_vls *src) );
d83 2
a84 1
RT_VLS_EXTERN(void rt_vls_bomb, (char *str, struct rt_vls *badp) );
@


1.4
log
@Improved checking macro slightly.
Added more extern definitions.
RT_VLS_ADDR() is now a subroutine also.
@
text
@d18 1
a18 1
 *  $Header: /m/cad/h/RCS/rtstring.h,v 1.3 90/12/08 07:09:53 butler Exp $
d29 1
a29 1
#if __STDC__
@


1.3
log
@Added VLS_CHECK macro
@
text
@d18 1
a18 1
 *  $Header: /m/cad/h/RCS/rtstring.h,v 1.2 90/11/22 06:56:40 mike Exp $
d45 1
a45 1
#define RT_VLS_CHECK(_vls_p) { if (_vls_p->vls_magic != RT_VLS_MAGIC) { \
d48 2
a49 1
				__FILE__, __LINE__); abort(); }}
d51 7
a57 2
/* This macro is used to get a pointer to the current vls string */
#define RT_VLS_ADDR(_vp)	((_vp)->vls_str)
d71 2
a72 1
RT_VLS_EXTERN(void rt_vls_bomb, (char *str, struct rt_vls *badp) );
a75 1
RT_VLS_EXTERN(void rt_vls_extend, (struct rt_vls *vp, int extra) );
d77 1
d79 1
d82 2
@


1.2
log
@RT_VLS_INIT() macro now just points to a subroutine,
because the initialization got more complicated.
@
text
@d18 1
a18 1
 *  $Header: /m/cad/h/RCS/rtstring.h,v 1.1 90/11/11 02:39:28 mike Exp $
d44 5
@


1.1
log
@Initial revision
@
text
@d18 1
a18 1
 *  $Header: /m/cad/h/RCS/rtlist.h,v 1.4 90/11/10 19:20:32 mike Exp $
d51 2
a52 1
 *  Used to initialize strings for which storage has already been obtained.
d54 1
a54 4
#define RT_VLS_INIT(_vp)		{ \
	(_vp)->vls_magic = RT_VLS_MAGIC; \
	(_vp)->vls_str = (char *)0; \
	(_vp)->vls_len = (_vp)->vls_max = 0; }
d59 1
@
