head	11.3;
access;
symbols
	ansi-20040405-merged:11.2
	postmerge-20040405-ansi:11.2
	premerge-20040404-ansi:11.2
	postmerge-autoconf:11.2
	autoconf-freeze:11.2
	premerge-autoconf:11.2
	ansi-20040316-freeze:11.2
	postmerge-20040315-windows:11.2
	premerge-20040315-windows:11.2
	windows-20040315-freeze:11.2
	autoconf-20031203:11.2
	autoconf-20031202:11.2
	autoconf-branch:11.2.0.14
	phong-branch:11.2.0.12
	photonmap-branch:11.2.0.10
	rel-6-1-DP:11.2
	windows-branch:11.2.0.8
	rel-6-0-2:11.2
	ansi-branch:11.2.0.6
	rel-6-0-1-branch:11.2.0.4
	hartley-6-0-post:11.2
	hartley-6-0-pre:11.2
	rel-6-0-1:11.2
	rel-6-0:11.2
	rel-5-4:11.2
	offsite-5-3-pre:11.2
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.2
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.3
date	2004.05.24.04.11.53;	author morrison;	state dead;
branches;
next	11.2;

11.2
date	98.01.29.07.45.45;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.48.42;	author mike;	state Rel4_4;
branches;
next	10.7;

10.7
date	94.09.16.19.42.32;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.06.22.03.13.00;	author butler;	state Exp;
branches;
next	10.5;

10.5
date	93.06.16.20.21.23;	author butler;	state Exp;
branches;
next	10.4;

10.4
date	93.04.01.13.41.22;	author pjt;	state Exp;
branches;
next	10.3;

10.3
date	93.03.02.17.36.53;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.10.15.14.27.34;	author butler;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.35.36;	author mike;	state Rel4_0;
branches;
next	1.6;

1.6
date	91.01.28.23.48.49;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	90.12.05.20.04.10;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	90.11.10.19.20.32;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	90.10.17.23.13.23;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	90.10.17.16.50.25;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	90.10.15.23.20.16;	author mike;	state Exp;
branches;
next	;


desc
@Doubly linked list macros
@


11.3
log
@moved/renamed from top-level h/ to top-level include/
@
text
@/*
 *  RTLIST.H has been absorbed into BU.H
 *  The data tye is now "struct bu_list".
 *  Compatibility macros are provided in "compat4.h"
 *	-Mike
 */
#include "compat4.h"
@


11.2
log
@This is now a stub, the real meat has moved to bu.h
@
text
@@


11.1
log
@Release_4.4
@
text
@d2 4
a5 18
 *			R T L I S T . H
 *
 *  A set of general-purpose doubly-linked list macros.
 *  Used throughout LIBRT, but also valuable for general use.
 *
 *  Authors -
 *	Michael John Muuss
 *	Lee A. Butler
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimitied.
 *
 *  $Header: /m/cad/h/RCS/rtlist.h,v 10.7 94/09/16 19:42:32 mike Exp $
d7 1
a7 271

#ifndef SEEN_RTLIST_H
#define SEEN_RTLIST_H yes


/************************************************************************
 *									*
 *			Doubly-linked list support			*
 *									*
 *  These macros assume that all user-provided structures will have	*
 *  a "struct rt_list" as their first element (often named "l" [ell]).	*
 *  Thus, a pointer to the rt_list struct is a "pun" for the		*
 *  user-provided structure as well, and the pointers can be converted	*
 *  back and forth safely with type casts.				*
 *									*
 *  Furthermore, the head of the linked list is usually			*
 *  a full instance of the user-provided structure			*
 *  (although the storage-conscious programmer could make the head	*
 *  just an rt_list structure, with careful type casting).		*
 *  This makes results in a doubly-linked circular list, with the head	*
 *  having the same shape as all the list members.			*
 *  The application is free to make use of this symmetry and store	*
 *  data values in the head, or the extra storage in the head can	*
 *  be ignored.								*
 *									*
 *  Where a macro expects an argument "p", it should be a pointer to	*
 *  a user-provided structure.						*
 *									*
 *  Where a macro expects an argument "hp", it should be a pointer to	*
 *  a "struct rt_list" located in the list head, e.g., &(head.l).	*
 *									*
 *  Where a macro expects an argument "old", "new", or "cur", it should	*
 *  be a pointer to the "struct rt_list" located either			*
 *  in a user-provided structure, e.g. &((p)->l),			*
 *  or for the case of "old" it may also be in the list head, e.g.	*
 *	RT_LIST_INSERT( &(head.l), &((p)->l) );				*
 *									*
 *  Dequeueing the head of a list is a valid and			*
 *  well defined operation which should be performed with caution.	*
 *  Unless a pointer to some other element of the list is retained	*
 *  by the application, the rest of the linked list can no longer be	*
 *  referred to.							*
 *									*
 *  The "magic" field of the list header must be set to the constant	*
 *  RT_LIST_HEAD_MAGIC, but the "magic" field of all list members	*
 *  should be established by user code, to identify the type of		*
 *  structure that the rt_list structure is embedded in.		*
 *  It is permissible for one list to contain an arbitrarily mixed	*
 *  set of user "magic" numbers, as long as the head is properly marked.*
 *									*
 *  There is a dual set of terminology used in some of the macros:	*
 *	FIRST / LAST	from the point of view of the list head		*
 *	NEXT / PREV	from the point of view of a list member		*
 *	forw / back	the actual pointer names			*
 *									*
 ************************************************************************/

struct rt_list {
	long		magic;
	struct rt_list	*forw;		/* "forward", "next" */
	struct rt_list	*back;		/* "back", "last" */
};
#define RT_LIST_HEAD_MAGIC	0x01016580	/* Magic num for list head */
#define RT_LIST_NULL	((struct rt_list *)0)


/*
 *  Insert "new" item in front of "old" item.  Often, "old" is the head.
 *  To put the new item at the tail of the list, insert before the head, e.g.
 *	RT_LIST_INSERT( &(head.l), &((p)->l) );
 */
#define RT_LIST_INSERT(old,new)	{ \
	(new)->back = (old)->back; \
	(old)->back = (new); \
	(new)->forw = (old); \
	(new)->back->forw = (new);  }

/*
 *  Append "new" item after "old" item.  Often, "old" is the head.
 *  To put the new item at the head of the list, append after the head, e.g.
 *	RT_LIST_APPEND( &(head.l), &((p)->l) );
 */
#define RT_LIST_APPEND(old,new)	{ \
	(new)->forw = (old)->forw; \
	(new)->back = (old); \
	(old)->forw = (new); \
	(new)->forw->back = (new);  }

/* Dequeue "cur" item from anywhere in doubly-linked list */
#define RT_LIST_DEQUEUE(cur)	{ \
	(cur)->forw->back = (cur)->back; \
	(cur)->back->forw = (cur)->forw; \
	(cur)->forw = (cur)->back = RT_LIST_NULL;  /* sanity */ }

/*
 *  The Stack Discipline
 *
 *  RT_LIST_PUSH places p at the tail of hp.
 *  RT_LIST_POP  sets p to last element in hp's list (else NULL)
 *		  and, if p is non-null, dequeues it.
 */
#define RT_LIST_PUSH(hp,p)					\
	RT_LIST_APPEND(hp, (struct rt_list *)(p))

#define RT_LIST_POP(structure,hp,p)				\
	if (RT_LIST_NON_EMPTY(hp))				\
	{							\
	    (p) = ((struct structure *)((hp)->forw));		\
	    RT_LIST_DEQUEUE((struct rt_list *)(p));		\
	}							\
	else							\
	     (p) = (struct structure *) 0
/*
 *  "Bulk transfer" all elements from the list headed by src_hd
 *  onto the list headed by dest_hd, without examining every element
 *  in the list.  src_hd is left with a valid but empty list.
 *  
 *  RT_LIST_INSERT_LIST places src_hd elements at head of dest_hd list,
 *  RT_LIST_APPEND_LIST places src_hd elements at end of dest_hd list.
 */
#define RT_LIST_INSERT_LIST(dest_hp,src_hp) \
	if( RT_LIST_NON_EMPTY(src_hp) )  { \
		register struct rt_list	*_first = (src_hp)->forw; \
		register struct rt_list	*_last = (src_hp)->back; \
		(dest_hp)->forw->back = _last; \
		_last->forw = (dest_hp)->forw; \
		(dest_hp)->forw = _first; \
		_first->back = (dest_hp); \
		(src_hp)->forw = (src_hp)->back = (src_hp); \
	}

#define RT_LIST_APPEND_LIST(dest_hp,src_hp) \
	if( RT_LIST_NON_EMPTY(src_hp) )  {\
		register struct rt_list	*_first = (src_hp)->forw; \
		register struct rt_list	*_last = (src_hp)->back; \
		_first->back = (dest_hp)->back; \
		(dest_hp)->back->forw = _first; \
		(dest_hp)->back = _last; \
		_last->forw = (dest_hp); \
		(src_hp)->forw = (src_hp)->back = (src_hp); \
	}

/* Test if a doubly linked list is empty, given head pointer */
#define RT_LIST_IS_EMPTY(hp)	((hp)->forw == (hp))
#define RT_LIST_NON_EMPTY(hp)	((hp)->forw != (hp))
#define RT_LIST_IS_CLEAR(hp)	((hp)->magic == 0 && \
			(hp)->forw == RT_LIST_NULL && \
			(hp)->back == RT_LIST_NULL)

/* Handle list initialization */
#define	RT_LIST_UNINITIALIZED(hp)	((hp)->forw == RT_LIST_NULL)
#define RT_LIST_INIT(hp)	{ \
	(hp)->forw = (hp)->back = (hp); \
	(hp)->magic = RT_LIST_HEAD_MAGIC;	/* used by circ. macros */ }
#define RT_LIST_MAGIC_SET(hp,val)	{(hp)->magic = (val);}
#define RT_LIST_MAGIC_OK(hp,val)	((hp)->magic == (val))
#define RT_LIST_MAGIC_WRONG(hp,val)	((hp)->magic != (val))

/* Return re-cast pointer to first element on list.
 * No checking is performed to see if list is empty.
 */
#define RT_LIST_LAST(structure,hp)	\
	((struct structure *)((hp)->back))
#define RT_LIST_PREV(structure,hp)	\
	((struct structure *)((hp)->back))
#define RT_LIST_FIRST(structure,hp)	\
	((struct structure *)((hp)->forw))
#define RT_LIST_NEXT(structure,hp)	\
	((struct structure *)((hp)->forw))

/* Boolean test to see if current list element is the head */
#define RT_LIST_IS_HEAD(p,hp)	\
	(((struct rt_list *)(p)) == (hp))
#define RT_LIST_NOT_HEAD(p,hp)	\
	(((struct rt_list *)(p)) != (hp))
#define RT_CK_LIST_HEAD( _p )	RT_CKMAG( (_p), RT_LIST_HEAD_MAGIC, "rt_list")

/* Boolean test to see if the next list element is the head */
#define RT_LIST_NEXT_IS_HEAD(p,hp)	\
	(((struct rt_list *)(p))->forw == (hp))
#define RT_LIST_NEXT_NOT_HEAD(p,hp)	\
	(((struct rt_list *)(p))->forw != (hp))

/*
 *  Intended as innards for a for() loop to visit all nodes on list, e.g.:
 *	for( RT_LIST_FOR( p, structure, hp ) )  {
 *		work_on( p );
 *	}
 */
#define RT_LIST_FOR(p,structure,hp)	\
	(p)=RT_LIST_FIRST(structure,hp); \
	RT_LIST_NOT_HEAD(p,hp); \
	(p)=RT_LIST_PNEXT(structure,p)
/*
 *  Intended as innards for a for() loop to visit elements of two lists
 *	in tandem, e.g.:
 *	    for (RT_LIST_FOR2(p1, p2, structure, hp1, hp2) ) {
 *		    process( p1, p2 );
 *	    }
 */
#define	RT_LIST_FOR2(p1,p2,structure,hp1,hp2)				\
		(p1)=RT_LIST_FIRST(structure,hp1),			\
		(p2)=RT_LIST_FIRST(structure,hp2);			\
		RT_LIST_NOT_HEAD((struct rt_list *)(p1),(hp1)) &&	\
		RT_LIST_NOT_HEAD((struct rt_list *)(p2),(hp2));		\
		(p1)=RT_LIST_NEXT(structure,(struct rt_list *)(p1)),	\
		(p2)=RT_LIST_NEXT(structure,(struct rt_list *)(p2))

/*
 *  Innards for a while() loop that constantly picks off the first element.
 *  Useful mostly for a loop that will dequeue every list element, e.g.:
 *	while( RT_LIST_WHILE(p, structure, hp) )  {
 *		RT_LIST_DEQUEUE( &(p->l) );
 *		free( (char *)p );
 *	}
 */
#define RT_LIST_WHILE(p,structure,hp)	\
	(((p)=(struct structure *)((hp)->forw)) != (struct structure *)(hp))

/* Return the magic number of the first (or last) item on a list */
#define RT_LIST_FIRST_MAGIC(hp)		((hp)->forw->magic)
#define RT_LIST_LAST_MAGIC(hp)		((hp)->back->magic)

/* Return pointer to next (or previous) element, which may be the head */
#define RT_LIST_PNEXT(structure,p)	\
	((struct structure *)(((struct rt_list *)(p))->forw))
#define RT_LIST_PLAST(structure,p)	\
	((struct structure *)(((struct rt_list *)(p))->back))

/* Return pointer two links away, which may include the head */
#define RT_LIST_PNEXT_PNEXT(structure,p)	\
	((struct structure *)(((struct rt_list *)(p))->forw->forw))
#define RT_LIST_PNEXT_PLAST(structure,p)	\
	((struct structure *)(((struct rt_list *)(p))->forw->back))
#define RT_LIST_PLAST_PNEXT(structure,p)	\
	((struct structure *)(((struct rt_list *)(p))->back->forw))
#define RT_LIST_PLAST_PLAST(structure,p)	\
	((struct structure *)(((struct rt_list *)(p))->back->back))

/* Return pointer to circular next element; ie, ignoring the list head */
#define RT_LIST_PNEXT_CIRC(structure,p)	\
	((RT_LIST_FIRST_MAGIC((struct rt_list *)(p)) == RT_LIST_HEAD_MAGIC) ? \
		RT_LIST_PNEXT_PNEXT(structure,(struct rt_list *)(p)) : \
		RT_LIST_PNEXT(structure,p) )

/* Return pointer to circular last element; ie, ignoring the list head */
#define RT_LIST_PPREV_CIRC(structure,p)	\
	((RT_LIST_LAST_MAGIC((struct rt_list *)(p)) == RT_LIST_HEAD_MAGIC) ? \
		RT_LIST_PLAST_PLAST(structure,(struct rt_list *)(p)) : \
		RT_LIST_PLAST(structure,p) )

/* compat */
#define RT_LIST_PLAST_CIRC(structure,p)	RT_LIST_PPREV_CIRC(structure,p)

/*
 *  Support for membership on multiple linked lists.
 *
 *  When a structure of type '_type' contains more than one rt_list structure
 *  within it (such as the NMG edgeuse), this macro can be used to convert
 *  a pointer '_ptr2' to a "midway" rt_list structure (an element called
 *  '_name2' in structure '_type') back into a pointer to the overall
 *  enclosing structure.  Examples:
 *
 *  eu = RT_LIST_MAIN_PTR( edgeuse, midway, l2 );
 *
 *  eu1 = RT_LIST_MAIN_PTR(edgeuse, RT_LIST_FIRST(rt_list, &eg1->eu_hd2), l2);
 */  
#define RT_LIST_MAIN_PTR(_type, _ptr2, _name2)	\
	((struct _type *)(((char *)(_ptr2)) - offsetof(struct _type, _name2.magic)))

#endif /* SEEN_RTLIST_H */
@


10.7
log
@Added RT_LIST_MAIN_PTR
@
text
@d19 1
a19 1
 *  $Header: /m/cad/h/RCS/rtlist.h,v 10.6 94/06/22 03:13:00 butler Exp Locker: mike $
@


10.6
log
@added RT_CK_LIST_HEAD() macro
@
text
@d19 1
a19 1
 *  $Header: /m/cad/h/RCS/rtlist.h,v 10.5 1993/06/16 20:21:23 butler Exp butler $
d274 16
@


10.5
log
@added RT_LIST_IS_CLEAR() macro
@
text
@d19 1
a19 1
 *  $Header: /m/cad/h/RCS/rtlist.h,v 10.4 93/04/01 13:41:22 pjt Exp Locker: butler $
d78 1
a78 1
struct rt_list  {
d196 1
@


10.4
log
@Added macros RT_LIST_PUSH, RT_LIST_POP, and RT_LIST_FOR2
@
text
@d19 1
a19 1
 *  $Header: /m/cad/h/RCS/rtlist.h,v 10.3 93/03/02 17:36:53 mike Exp Locker: pjt $
d166 3
@


10.3
log
@Revised per code review suggestions
@
text
@d19 1
a19 1
 *  $Header: /m/cad/h/RCS/rtlist.h,v 10.2 92/10/15 14:27:34 butler Exp Locker: mike $
d116 18
d210 14
@


10.2
log
@Added RT_LIST_MAGIC_OK() macro
@
text
@d19 1
a19 1
 *  $Header: /m/cad/h/RCS/rtlist.h,v 10.1 91/10/12 06:35:36 mike Rel4_0 Locker: butler $
d64 12
d116 6
a121 4
 *  "Bulk transfer" all elements attached to list headed by src
 *  the list headed by dest, without examining every element in the list.
 *  RT_LIST_INSERT_LIST places src elements at head of dest list,
 *  RT_LIST_APPEND_LIST places src elements at end of dest list.
d123 9
a131 9
#define RT_LIST_INSERT_LIST(dest,src) \
	if( RT_LIST_NON_EMPTY(src) )  { \
		register struct rt_list	*_first = (src)->forw; \
		register struct rt_list	*_last = (src)->back; \
		(dest)->forw->back = _last; \
		_last->forw = (dest)->forw; \
		(dest)->forw = _first; \
		_first->back = (dest); \
		(src)->forw = (src)->back = (src); \
d134 9
a142 9
#define RT_LIST_APPEND_LIST(dest,src) \
	if( RT_LIST_NON_EMPTY(src) )  {\
		register struct rt_list	*_first = (src)->forw; \
		register struct rt_list	*_last = (src)->back; \
		_first->back = (dest)->back; \
		(dest)->back->forw = _first; \
		(dest)->back = _last; \
		_last->forw = (dest); \
		(src)->forw = (src)->back = (src); \
a203 4
/* compat */
#define RT_LIST(p,structure,hp)		RT_LIST_FOR(p,structure,hp)
#define RT_LIST_LOOP(p,structure,hp)	RT_LIST_WHILE(p,structure,hp)

d231 1
a231 1
#define RT_LIST_PLAST_CIRC(structure,p)	\
d236 2
@


10.1
log
@Release_4.0
@
text
@d19 1
a19 1
 *  $Header: /m/cad/h/RCS/rtlist.h,v 1.6 91/01/28 23:48:49 mike Exp $
d141 1
@


1.6
log
@Added macros to move entire linked lists from one head to another.
@
text
@d19 1
a19 1
 *  $Header: /m/cad/h/RCS/rtlist.h,v 1.6 91/01/28 23:01:00 mike Exp $
@


1.5
log
@added curly braces around RT_LIST_MAGIC_SET expansion
@
text
@d19 1
a19 1
 *  $Header: /m/cad/h/RCS/rtlist.h,v 1.4 90/11/10 19:20:32 mike Exp $
d102 28
@


1.4
log
@Added some macros for dealing with magic numbers.
@
text
@d19 1
a19 1
 *  $Header: /m/cad/h/RCS/rtlist.h,v 1.3 90/10/17 23:13:23 mike Exp $
d112 1
a112 1
#define RT_LIST_MAGIC_SET(hp,val)	(hp)->magic = (val);
@


1.3
log
@Clarified FOR and WHILE macros
@
text
@d19 1
a19 1
 *  $Header: /m/cad/h/RCS/rtlist.h,v 1.2 90/10/17 16:50:25 mike Exp $
d71 1
a71 1
#define RT_LIST_MAGIC	0x01016580
d107 2
d111 3
a113 1
	(hp)->magic = RT_LIST_MAGIC;	/* sanity */ }
d120 2
d187 1
a187 1
	((RT_LIST_FIRST_MAGIC((struct rt_list *)(p)) == RT_LIST_MAGIC) ? \
d193 1
a193 1
	((RT_LIST_LAST_MAGIC((struct rt_list *)(p)) == RT_LIST_MAGIC) ? \
@


1.2
log
@Added lots of comments, and a few more macros.
@
text
@d19 1
a19 1
 *  $Header: /m/cad/h/RCS/rtlist.h,v 1.1 90/10/15 23:20:16 mike Exp $
d135 1
a135 1
 *	for( RT_LIST( p, structure, hp ) )  {
d139 1
a139 1
#define RT_LIST(p,structure,hp)	\
d147 1
a147 1
 *	while( RT_LIST_LOOP(p, structure, hp) )  {
d152 1
a152 1
#define RT_LIST_LOOP(p,structure,hp)	\
d154 4
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
 *  $Header$
d30 34
a73 1
/* These macros all expect pointers to rt_list structures */
d75 5
a79 2
/* Insert "new" item in front of "old" item.  Often, "old" is the head. */
/* To put the new item at the tail of the list, insert before the head */
d86 5
a90 2
/* Append "new" item after "old" item.  Often, "old" is the head. */
/* To put the new item at the head of the list, append after the head */
d101 1
a101 1
	(cur)->forw = (cur)->back = (struct rt_list *)NULL; }
a110 6
/*
 *  Macros for walking a linked list, where the first element of
 *  some application structure is an rt_list structure.
 *  Thus, the pointer to the rt_list struct is a "pun" for the
 *  application structure as well.
 */
d120 40
a159 2
#define RT_LIST_MORE(p,structure,hp)	\
	((p) != (struct structure *)(hp))
d165 1
a173 14

/* Intended as innards for a for() loop to visit all nodes on list */
#define RT_LIST(p,structure,hp)	\
	(p)=RT_LIST_FIRST(structure,hp); \
	RT_LIST_MORE(p,structure,hp); \
	(p)=RT_LIST_PNEXT(structure,p)

/* Innards for a while() loop that picks off first elements */
#define RT_LIST_LOOP(p,structure,hp)	\
	(((p)=(struct structure *)((hp)->forw)) != (struct structure *)(hp))

/* Return the magic number of the first (or last) item on a list */
#define RT_LIST_FIRST_MAGIC(hp)		((hp)->forw->magic)
#define RT_LIST_LAST_MAGIC(hp)		((hp)->back->magic)
@
