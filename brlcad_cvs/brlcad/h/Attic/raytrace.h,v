head	11.357;
access;
symbols
	ansi-20040405-merged:11.340.2.5
	postmerge-20040405-ansi:11.352
	premerge-20040404-ansi:11.351
	postmerge-autoconf:11.351
	autoconf-freeze:11.346.4.5
	premerge-autoconf:11.351
	ansi-20040316-freeze:11.340.2.2
	postmerge-20040315-windows:11.351
	premerge-20040315-windows:11.350
	windows-20040315-freeze:11.340.4.2
	autoconf-20031203:11.346.4.1
	autoconf-20031202:11.346
	autoconf-branch:11.346.0.4
	phong-branch:11.346.0.2
	photonmap-branch:11.345.0.2
	rel-6-1-DP:11.342
	windows-branch:11.340.0.4
	rel-6-0-2:11.337
	ansi-branch:11.340.0.2
	rel-6-0-1-branch:11.337.0.2
	hartley-6-0-post:11.339
	hartley-6-0-pre:11.338
	rel-6-0-1:11.337
	rel-6-0:11.335
	rel-5-4:11.229.2.5
	offsite-5-3-pre:11.290
	rel-5-3:11.229.2.5
	rel-5-2:11.229
	rel-5-1-branch:11.229.0.2
	rel-5-1:11.229
	rel-5-0:11.116
	rel-5-0-beta:11.112
	rel-4-5:11.88
	ctj-4-5-post:11.82
	ctj-4-5-pre:11.81
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.3
	rel-1-10:4.1
	rt-2:2.1
	rt:1.1;
locks; strict;
comment	@ * @;


11.357
date	2004.05.24.04.11.53;	author morrison;	state dead;
branches;
next	11.356;

11.356
date	2004.05.10.15.25.26;	author morrison;	state Exp;
branches;
next	11.355;

11.355
date	2004.05.05.14.20.26;	author morrison;	state Exp;
branches;
next	11.354;

11.354
date	2004.04.06.23.58.49;	author morrison;	state Exp;
branches;
next	11.353;

11.353
date	2004.04.05.10.51.04;	author morrison;	state Exp;
branches;
next	11.352;

11.352
date	2004.04.05.09.31.17;	author morrison;	state Exp;
branches;
next	11.351;

11.351
date	2004.03.16.14.10.47;	author morrison;	state Exp;
branches;
next	11.350;

11.350
date	2004.03.03.21.45.30;	author morrison;	state Exp;
branches;
next	11.349;

11.349
date	2004.02.03.21.44.57;	author jra;	state Exp;
branches;
next	11.348;

11.348
date	2004.02.02.17.39.02;	author morrison;	state Exp;
branches;
next	11.347;

11.347
date	2003.10.29.18.00.33;	author jra;	state Exp;
branches;
next	11.346;

11.346
date	2003.08.02.23.17.25;	author butler;	state Exp;
branches
	11.346.4.1;
next	11.345;

11.345
date	2003.04.07.17.46.40;	author jra;	state Exp;
branches
	11.345.2.1;
next	11.344;

11.344
date	2003.01.31.13.32.51;	author jra;	state Exp;
branches;
next	11.343;

11.343
date	2003.01.20.02.04.03;	author jra;	state Exp;
branches;
next	11.342;

11.342
date	2002.10.21.02.52.50;	author morrison;	state Exp;
branches;
next	11.341;

11.341
date	2002.09.30.14.02.52;	author jra;	state Exp;
branches;
next	11.340;

11.340
date	2002.08.20.17.07.30;	author jra;	state Exp;
branches
	11.340.2.1
	11.340.4.1;
next	11.339;

11.339
date	2002.08.15.20.54.42;	author hartley;	state Exp;
branches;
next	11.338;

11.338
date	2002.08.15.13.49.36;	author jra;	state Exp;
branches;
next	11.337;

11.337
date	2002.07.16.02.17.10;	author jra;	state Exp;
branches;
next	11.336;

11.336
date	2002.06.19.20.07.44;	author butler;	state Exp;
branches;
next	11.335;

11.335
date	2002.02.25.15.21.39;	author jra;	state Exp;
branches;
next	11.334;

11.334
date	2002.02.22.16.08.01;	author jra;	state Exp;
branches;
next	11.333;

11.333
date	2002.02.05.03.12.27;	author jra;	state Exp;
branches;
next	11.332;

11.332
date	2002.01.22.19.01.31;	author jra;	state Exp;
branches;
next	11.331;

11.331
date	2001.12.27.15.17.48;	author jra;	state Exp;
branches;
next	11.330;

11.330
date	2001.12.13.19.32.35;	author jra;	state Exp;
branches;
next	11.329;

11.329
date	2001.12.08.21.09.50;	author jra;	state Exp;
branches;
next	11.328;

11.328
date	2001.11.27.17.47.22;	author bparker;	state Exp;
branches;
next	11.327;

11.327
date	2001.11.26.19.37.44;	author butler;	state Exp;
branches;
next	11.326;

11.326
date	2001.11.15.22.03.30;	author bparker;	state Exp;
branches;
next	11.325;

11.325
date	2001.11.09.20.40.02;	author bparker;	state Exp;
branches;
next	11.324;

11.324
date	2001.11.08.22.04.17;	author butler;	state Exp;
branches;
next	11.323;

11.323
date	2001.11.07.19.35.37;	author butler;	state Exp;
branches;
next	11.322;

11.322
date	2001.11.02.04.58.38;	author butler;	state Exp;
branches;
next	11.321;

11.321
date	2001.11.02.01.54.12;	author butler;	state Exp;
branches;
next	11.320;

11.320
date	2001.11.01.21.39.33;	author bparker;	state Exp;
branches;
next	11.319;

11.319
date	2001.10.04.21.56.48;	author bparker;	state Exp;
branches;
next	11.318;

11.318
date	2001.09.07.17.07.40;	author bparker;	state Exp;
branches;
next	11.317;

11.317
date	2001.08.14.18.24.25;	author bparker;	state Exp;
branches;
next	11.316;

11.316
date	2001.08.02.17.44.58;	author jra;	state Exp;
branches;
next	11.315;

11.315
date	2001.06.22.20.40.53;	author jra;	state Exp;
branches;
next	11.314;

11.314
date	2001.06.18.19.25.09;	author bparker;	state Exp;
branches;
next	11.313;

11.313
date	2001.06.06.16.46.07;	author bparker;	state Exp;
branches;
next	11.312;

11.312
date	2001.06.05.15.49.17;	author bparker;	state Exp;
branches;
next	11.311;

11.311
date	2001.06.01.16.55.35;	author bparker;	state Exp;
branches;
next	11.310;

11.310
date	2001.05.17.20.04.55;	author morrison;	state Exp;
branches;
next	11.309;

11.309
date	2001.05.17.19.01.04;	author jra;	state Exp;
branches;
next	11.308;

11.308
date	2001.05.16.21.37.43;	author morrison;	state Exp;
branches;
next	11.307;

11.307
date	2001.05.14.01.46.19;	author jra;	state Exp;
branches;
next	11.306;

11.306
date	2001.05.11.15.24.58;	author jra;	state Exp;
branches;
next	11.305;

11.305
date	2001.05.08.20.04.50;	author jra;	state Exp;
branches;
next	11.304;

11.304
date	2001.05.04.14.47.33;	author bparker;	state Exp;
branches;
next	11.303;

11.303
date	2001.04.25.13.44.40;	author jra;	state Exp;
branches;
next	11.302;

11.302
date	2001.04.20.19.52.36;	author bparker;	state Exp;
branches;
next	11.301;

11.301
date	2001.04.15.02.21.10;	author jra;	state Exp;
branches;
next	11.300;

11.300
date	2001.04.05.19.35.07;	author morrison;	state Exp;
branches;
next	11.299;

11.299
date	2001.04.02.18.09.19;	author jra;	state Exp;
branches;
next	11.298;

11.298
date	2001.03.23.22.33.46;	author butler;	state Exp;
branches;
next	11.297;

11.297
date	2001.03.23.22.05.18;	author jra;	state Exp;
branches;
next	11.296;

11.296
date	2001.03.22.20.15.37;	author bparker;	state Exp;
branches;
next	11.295;

11.295
date	2001.03.22.19.37.25;	author jra;	state Exp;
branches;
next	11.294;

11.294
date	2001.03.21.19.02.00;	author pjt;	state Exp;
branches;
next	11.293;

11.293
date	2001.03.20.21.56.01;	author pjt;	state Exp;
branches;
next	11.292;

11.292
date	2001.03.20.16.09.05;	author jra;	state Exp;
branches;
next	11.291;

11.291
date	2001.03.19.22.19.25;	author butler;	state Exp;
branches;
next	11.290;

11.290
date	2001.03.16.14.42.44;	author jra;	state Exp;
branches;
next	11.289;

11.289
date	2001.03.09.15.08.35;	author bparker;	state Exp;
branches;
next	11.288;

11.288
date	2001.01.29.18.18.08;	author jra;	state Exp;
branches;
next	11.287;

11.287
date	2000.11.19.16.28.30;	author butler;	state Exp;
branches;
next	11.286;

11.286
date	2000.11.14.21.13.49;	author jra;	state Exp;
branches;
next	11.285;

11.285
date	2000.11.01.20.37.34;	author mike;	state Exp;
branches;
next	11.284;

11.284
date	2000.11.01.06.22.28;	author mike;	state Exp;
branches;
next	11.283;

11.283
date	2000.10.30.21.23.25;	author mike;	state Exp;
branches;
next	11.282;

11.282
date	2000.10.24.18.51.34;	author mike;	state Exp;
branches;
next	11.281;

11.281
date	2000.10.24.18.47.33;	author mike;	state Exp;
branches;
next	11.280;

11.280
date	2000.10.24.18.42.32;	author mike;	state Exp;
branches;
next	11.279;

11.279
date	2000.10.24.18.38.41;	author mike;	state Exp;
branches;
next	11.278;

11.278
date	2000.10.24.18.29.35;	author mike;	state Exp;
branches;
next	11.277;

11.277
date	2000.10.24.18.22.37;	author mike;	state Exp;
branches;
next	11.276;

11.276
date	2000.10.24.18.17.43;	author mike;	state Exp;
branches;
next	11.275;

11.275
date	2000.10.24.18.11.08;	author mike;	state Exp;
branches;
next	11.274;

11.274
date	2000.10.24.18.09.36;	author mike;	state Exp;
branches;
next	11.273;

11.273
date	2000.10.24.14.36.28;	author mike;	state Exp;
branches;
next	11.272;

11.272
date	2000.10.20.20.28.43;	author jra;	state Exp;
branches;
next	11.271;

11.271
date	2000.10.20.05.08.32;	author mike;	state Exp;
branches;
next	11.270;

11.270
date	2000.10.19.21.27.18;	author mike;	state Exp;
branches;
next	11.269;

11.269
date	2000.10.19.04.31.04;	author mike;	state Exp;
branches;
next	11.268;

11.268
date	2000.09.09.04.37.55;	author mike;	state Exp;
branches;
next	11.267;

11.267
date	2000.09.09.04.30.44;	author mike;	state Exp;
branches;
next	11.266;

11.266
date	2000.09.08.05.54.37;	author mike;	state Exp;
branches;
next	11.265;

11.265
date	2000.09.07.01.55.30;	author mike;	state Exp;
branches;
next	11.264;

11.264
date	2000.09.01.02.53.02;	author mike;	state Exp;
branches;
next	11.263;

11.263
date	2000.08.29.22.08.28;	author mike;	state Exp;
branches;
next	11.262;

11.262
date	2000.08.29.21.54.28;	author mike;	state Exp;
branches;
next	11.261;

11.261
date	2000.08.29.21.50.26;	author mike;	state Exp;
branches;
next	11.260;

11.260
date	2000.08.29.04.03.10;	author mike;	state Exp;
branches;
next	11.259;

11.259
date	2000.08.29.03.58.08;	author mike;	state Exp;
branches;
next	11.258;

11.258
date	2000.08.29.03.23.03;	author cjohnson;	state Exp;
branches;
next	11.257;

11.257
date	2000.08.24.03.13.36;	author mike;	state Exp;
branches;
next	11.256;

11.256
date	2000.08.24.03.12.18;	author mike;	state Exp;
branches;
next	11.255;

11.255
date	2000.08.24.01.50.07;	author mike;	state Exp;
branches;
next	11.254;

11.254
date	2000.08.23.05.56.28;	author mike;	state Exp;
branches;
next	11.253;

11.253
date	2000.08.22.06.48.46;	author mike;	state Exp;
branches;
next	11.252;

11.252
date	2000.08.21.02.06.59;	author butler;	state Exp;
branches;
next	11.251;

11.251
date	2000.08.19.22.01.15;	author butler;	state Exp;
branches;
next	11.250;

11.250
date	2000.07.29.23.23.04;	author mike;	state Exp;
branches;
next	11.249;

11.249
date	2000.07.25.22.40.48;	author mike;	state Exp;
branches;
next	11.248;

11.248
date	2000.07.25.16.38.31;	author butler;	state Exp;
branches;
next	11.247;

11.247
date	2000.07.24.22.22.10;	author mike;	state Exp;
branches;
next	11.246;

11.246
date	2000.07.24.19.27.30;	author mike;	state Exp;
branches;
next	11.245;

11.245
date	2000.07.13.02.35.32;	author cjohnson;	state Exp;
branches;
next	11.244;

11.244
date	2000.07.13.01.13.00;	author mike;	state Exp;
branches;
next	11.243;

11.243
date	2000.07.12.21.55.23;	author mike;	state Exp;
branches;
next	11.242;

11.242
date	2000.07.12.02.11.27;	author mike;	state Exp;
branches;
next	11.241;

11.241
date	2000.07.12.00.37.20;	author mike;	state Exp;
branches;
next	11.240;

11.240
date	2000.07.12.00.13.45;	author mike;	state Exp;
branches;
next	11.239;

11.239
date	2000.07.12.00.07.52;	author cjohnson;	state Exp;
branches;
next	11.238;

11.238
date	2000.07.11.23.16.44;	author mike;	state Exp;
branches;
next	11.237;

11.237
date	2000.07.07.17.52.44;	author bparker;	state Exp;
branches;
next	11.236;

11.236
date	2000.06.30.20.15.53;	author pjt;	state Exp;
branches;
next	11.235;

11.235
date	2000.06.30.15.29.05;	author pjt;	state Exp;
branches;
next	11.234;

11.234
date	2000.06.29.15.56.29;	author mike;	state Exp;
branches;
next	11.233;

11.233
date	2000.06.28.18.08.04;	author mike;	state Exp;
branches;
next	11.232;

11.232
date	2000.06.28.18.03.39;	author mike;	state Exp;
branches;
next	11.231;

11.231
date	2000.06.27.17.36.08;	author mike;	state Exp;
branches;
next	11.230;

11.230
date	2000.06.26.17.46.41;	author mike;	state Exp;
branches;
next	11.229;

11.229
date	2000.06.23.03.31.54;	author mike;	state Exp;
branches
	11.229.2.1;
next	11.228;

11.228
date	2000.05.24.00.58.42;	author mike;	state Exp;
branches;
next	11.227;

11.227
date	2000.05.23.19.35.44;	author mike;	state Exp;
branches;
next	11.226;

11.226
date	2000.05.22.00.04.07;	author mike;	state Exp;
branches;
next	11.225;

11.225
date	2000.05.18.21.01.36;	author mike;	state Exp;
branches;
next	11.224;

11.224
date	2000.05.18.19.56.21;	author mike;	state Exp;
branches;
next	11.223;

11.223
date	2000.05.17.04.08.53;	author mike;	state Exp;
branches;
next	11.222;

11.222
date	2000.05.16.23.45.03;	author mike;	state Exp;
branches;
next	11.221;

11.221
date	2000.05.11.03.22.00;	author mike;	state Exp;
branches;
next	11.220;

11.220
date	2000.05.09.20.44.03;	author mike;	state Exp;
branches;
next	11.219;

11.219
date	2000.05.08.20.44.25;	author mike;	state Exp;
branches;
next	11.218;

11.218
date	2000.05.02.01.38.28;	author mike;	state Exp;
branches;
next	11.217;

11.217
date	2000.04.24.16.40.28;	author mike;	state Exp;
branches;
next	11.216;

11.216
date	2000.04.20.02.57.12;	author mike;	state Exp;
branches;
next	11.215;

11.215
date	2000.04.15.02.04.58;	author mike;	state Exp;
branches;
next	11.214;

11.214
date	2000.04.14.03.40.38;	author mike;	state Exp;
branches;
next	11.213;

11.213
date	2000.04.13.20.34.39;	author mike;	state Exp;
branches;
next	11.212;

11.212
date	2000.04.12.01.44.01;	author mike;	state Exp;
branches;
next	11.211;

11.211
date	2000.04.01.03.30.39;	author mike;	state Exp;
branches;
next	11.210;

11.210
date	2000.04.01.03.16.00;	author mike;	state Exp;
branches;
next	11.209;

11.209
date	2000.04.01.03.00.56;	author mike;	state Exp;
branches;
next	11.208;

11.208
date	2000.04.01.02.18.55;	author mike;	state Exp;
branches;
next	11.207;

11.207
date	2000.04.01.01.52.43;	author mike;	state Exp;
branches;
next	11.206;

11.206
date	2000.04.01.01.43.51;	author mike;	state Exp;
branches;
next	11.205;

11.205
date	2000.04.01.01.39.16;	author mike;	state Exp;
branches;
next	11.204;

11.204
date	2000.04.01.01.34.19;	author mike;	state Exp;
branches;
next	11.203;

11.203
date	2000.04.01.01.17.51;	author mike;	state Exp;
branches;
next	11.202;

11.202
date	2000.03.29.18.55.22;	author mike;	state Exp;
branches;
next	11.201;

11.201
date	2000.03.29.02.54.06;	author mike;	state Exp;
branches;
next	11.200;

11.200
date	2000.03.29.02.36.02;	author mike;	state Exp;
branches;
next	11.199;

11.199
date	2000.03.29.01.48.48;	author mike;	state Exp;
branches;
next	11.198;

11.198
date	2000.03.29.01.43.01;	author mike;	state Exp;
branches;
next	11.197;

11.197
date	2000.03.29.01.36.57;	author mike;	state Exp;
branches;
next	11.196;

11.196
date	2000.03.29.01.17.25;	author mike;	state Exp;
branches;
next	11.195;

11.195
date	2000.03.28.22.40.09;	author mike;	state Exp;
branches;
next	11.194;

11.194
date	2000.03.28.22.06.15;	author mike;	state Exp;
branches;
next	11.193;

11.193
date	2000.03.28.21.25.12;	author mike;	state Exp;
branches;
next	11.192;

11.192
date	2000.03.28.20.50.49;	author mike;	state Exp;
branches;
next	11.191;

11.191
date	2000.03.28.02.17.59;	author mike;	state Exp;
branches;
next	11.190;

11.190
date	2000.03.28.01.52.31;	author mike;	state Exp;
branches;
next	11.189;

11.189
date	2000.03.16.13.39.27;	author jra;	state Exp;
branches;
next	11.188;

11.188
date	2000.03.15.22.49.11;	author butler;	state Exp;
branches;
next	11.187;

11.187
date	2000.03.07.02.13.48;	author mike;	state Exp;
branches;
next	11.186;

11.186
date	2000.03.04.05.27.10;	author mike;	state Exp;
branches;
next	11.185;

11.185
date	2000.03.04.05.23.44;	author mike;	state Exp;
branches;
next	11.184;

11.184
date	2000.03.04.05.18.51;	author mike;	state Exp;
branches;
next	11.183;

11.183
date	2000.03.03.01.50.59;	author mike;	state Exp;
branches;
next	11.182;

11.182
date	2000.03.03.01.00.17;	author mike;	state Exp;
branches;
next	11.181;

11.181
date	2000.03.02.14.40.28;	author jra;	state Exp;
branches;
next	11.180;

11.180
date	2000.03.02.03.50.46;	author mike;	state Exp;
branches;
next	11.179;

11.179
date	2000.02.29.20.33.27;	author mike;	state Exp;
branches;
next	11.178;

11.178
date	2000.02.18.17.49.22;	author bparker;	state Exp;
branches;
next	11.177;

11.177
date	2000.02.10.05.06.30;	author mike;	state Exp;
branches;
next	11.176;

11.176
date	2000.02.02.20.11.22;	author mike;	state Exp;
branches;
next	11.175;

11.175
date	2000.02.02.02.45.44;	author mike;	state Exp;
branches;
next	11.174;

11.174
date	2000.02.02.02.08.36;	author mike;	state Exp;
branches;
next	11.173;

11.173
date	2000.02.02.01.23.32;	author mike;	state Exp;
branches;
next	11.172;

11.172
date	2000.02.01.20.08.43;	author mike;	state Exp;
branches;
next	11.171;

11.171
date	2000.01.21.15.05.35;	author jra;	state Exp;
branches;
next	11.170;

11.170
date	2000.01.14.22.43.33;	author mike;	state Exp;
branches;
next	11.169;

11.169
date	2000.01.11.21.34.44;	author mike;	state Exp;
branches;
next	11.168;

11.168
date	2000.01.07.19.48.02;	author mike;	state Exp;
branches;
next	11.167;

11.167
date	2000.01.07.04.20.15;	author mike;	state Exp;
branches;
next	11.166;

11.166
date	2000.01.06.16.15.45;	author bparker;	state Exp;
branches;
next	11.165;

11.165
date	2000.01.06.04.42.11;	author mike;	state Exp;
branches;
next	11.164;

11.164
date	2000.01.04.17.58.20;	author bparker;	state Exp;
branches;
next	11.163;

11.163
date	2000.01.04.15.15.21;	author bparker;	state Exp;
branches;
next	11.162;

11.162
date	2000.01.03.21.41.28;	author bparker;	state Exp;
branches;
next	11.161;

11.161
date	2000.01.03.15.26.20;	author bparker;	state Exp;
branches;
next	11.160;

11.160
date	99.12.30.05.26.17;	author mike;	state Exp;
branches;
next	11.159;

11.159
date	99.12.30.04.56.56;	author mike;	state Exp;
branches;
next	11.158;

11.158
date	99.12.29.23.23.07;	author mike;	state Exp;
branches;
next	11.157;

11.157
date	99.12.29.22.37.16;	author mike;	state Exp;
branches;
next	11.156;

11.156
date	99.12.29.21.09.32;	author mike;	state Exp;
branches;
next	11.155;

11.155
date	99.12.29.14.18.22;	author bparker;	state Exp;
branches;
next	11.154;

11.154
date	99.12.27.20.58.16;	author bparker;	state Exp;
branches;
next	11.153;

11.153
date	99.12.23.06.25.29;	author mike;	state Exp;
branches;
next	11.152;

11.152
date	99.12.23.05.56.12;	author mike;	state Exp;
branches;
next	11.151;

11.151
date	99.12.22.04.55.29;	author mike;	state Exp;
branches;
next	11.150;

11.150
date	99.12.21.16.54.44;	author bparker;	state Exp;
branches;
next	11.149;

11.149
date	99.12.18.00.57.50;	author mike;	state Exp;
branches;
next	11.148;

11.148
date	99.12.18.00.55.58;	author mike;	state Exp;
branches;
next	11.147;

11.147
date	99.12.18.00.43.32;	author mike;	state Exp;
branches;
next	11.146;

11.146
date	99.12.07.03.32.06;	author mike;	state Exp;
branches;
next	11.145;

11.145
date	99.12.06.16.54.00;	author mike;	state Exp;
branches;
next	11.144;

11.144
date	99.12.06.16.39.45;	author mike;	state Exp;
branches;
next	11.143;

11.143
date	99.12.01.16.00.40;	author bparker;	state Exp;
branches;
next	11.142;

11.142
date	99.12.01.13.24.07;	author bparker;	state Exp;
branches;
next	11.141;

11.141
date	99.11.26.22.39.35;	author mike;	state Exp;
branches;
next	11.140;

11.140
date	99.11.26.22.29.27;	author mike;	state Exp;
branches;
next	11.139;

11.139
date	99.11.26.22.14.00;	author mike;	state Exp;
branches;
next	11.138;

11.138
date	99.11.26.22.02.37;	author mike;	state Exp;
branches;
next	11.137;

11.137
date	99.11.26.21.45.42;	author mike;	state Exp;
branches;
next	11.136;

11.136
date	99.11.26.20.49.46;	author mike;	state Exp;
branches;
next	11.135;

11.135
date	99.11.24.22.38.42;	author mike;	state Exp;
branches;
next	11.134;

11.134
date	99.11.24.22.37.41;	author mike;	state Exp;
branches;
next	11.133;

11.133
date	99.11.19.01.28.04;	author mike;	state Exp;
branches;
next	11.132;

11.132
date	99.11.18.03.21.51;	author mike;	state Exp;
branches;
next	11.131;

11.131
date	99.11.17.04.39.34;	author mike;	state Exp;
branches;
next	11.130;

11.130
date	99.11.17.03.44.51;	author mike;	state Exp;
branches;
next	11.129;

11.129
date	99.11.17.02.41.27;	author mike;	state Exp;
branches;
next	11.128;

11.128
date	99.11.16.22.31.40;	author mike;	state Exp;
branches;
next	11.127;

11.127
date	99.11.12.21.19.46;	author mike;	state Exp;
branches;
next	11.126;

11.126
date	99.11.12.20.54.38;	author mike;	state Exp;
branches;
next	11.125;

11.125
date	99.11.11.04.18.41;	author mike;	state Exp;
branches;
next	11.124;

11.124
date	99.11.08.15.22.23;	author jra;	state Exp;
branches;
next	11.123;

11.123
date	99.11.02.02.40.27;	author mike;	state Exp;
branches;
next	11.122;

11.122
date	99.10.30.03.52.19;	author mike;	state Exp;
branches;
next	11.121;

11.121
date	99.10.29.17.23.49;	author bparker;	state Exp;
branches;
next	11.120;

11.120
date	99.10.28.17.44.40;	author bparker;	state Exp;
branches;
next	11.119;

11.119
date	99.10.28.03.33.30;	author mike;	state Exp;
branches;
next	11.118;

11.118
date	99.10.19.20.51.27;	author jra;	state Exp;
branches;
next	11.117;

11.117
date	99.10.12.13.58.12;	author jra;	state Exp;
branches;
next	11.116;

11.116
date	99.08.16.14.46.59;	author bparker;	state Exp;
branches;
next	11.115;

11.115
date	99.07.14.02.15.21;	author mike;	state Exp;
branches;
next	11.114;

11.114
date	99.06.03.02.10.30;	author mike;	state Exp;
branches;
next	11.113;

11.113
date	99.06.03.01.11.06;	author mike;	state Exp;
branches;
next	11.112;

11.112
date	99.05.27.20.10.33;	author mike;	state Exp;
branches;
next	11.111;

11.111
date	99.05.10.21.27.51;	author mike;	state Exp;
branches;
next	11.110;

11.110
date	99.05.10.15.49.49;	author mike;	state Exp;
branches;
next	11.109;

11.109
date	99.01.27.01.07.08;	author butler;	state Exp;
branches;
next	11.108;

11.108
date	99.01.25.05.29.56;	author butler;	state Exp;
branches;
next	11.107;

11.107
date	98.12.17.04.19.08;	author mike;	state Exp;
branches;
next	11.106;

11.106
date	98.12.11.20.53.54;	author mike;	state Exp;
branches;
next	11.105;

11.105
date	98.11.17.22.17.43;	author mike;	state Exp;
branches;
next	11.104;

11.104
date	98.11.17.22.06.54;	author mike;	state Exp;
branches;
next	11.103;

11.103
date	98.09.14.15.59.14;	author bparker;	state Exp;
branches;
next	11.102;

11.102
date	98.08.10.18.20.22;	author mike;	state Exp;
branches;
next	11.101;

11.101
date	98.08.10.17.50.49;	author mike;	state Exp;
branches;
next	11.100;

11.100
date	98.05.12.17.24.08;	author mike;	state Exp;
branches;
next	11.99;

11.99
date	98.04.15.05.52.53;	author mike;	state Exp;
branches;
next	11.98;

11.98
date	98.04.15.04.28.09;	author mike;	state Exp;
branches;
next	11.97;

11.97
date	98.04.10.17.25.22;	author jra;	state Exp;
branches;
next	11.96;

11.96
date	98.04.10.17.18.53;	author jra;	state Exp;
branches;
next	11.95;

11.95
date	98.04.03.00.23.13;	author mike;	state Exp;
branches;
next	11.94;

11.94
date	98.03.26.07.00.43;	author mike;	state Exp;
branches;
next	11.93;

11.93
date	98.03.24.05.39.47;	author mike;	state Exp;
branches;
next	11.92;

11.92
date	98.03.24.05.36.31;	author mike;	state Exp;
branches;
next	11.91;

11.91
date	98.03.19.11.38.10;	author mike;	state Exp;
branches;
next	11.90;

11.90
date	98.03.19.11.32.47;	author mike;	state Exp;
branches;
next	11.89;

11.89
date	98.02.23.16.31.37;	author jra;	state Exp;
branches;
next	11.88;

11.88
date	98.01.09.08.38.43;	author mike;	state Exp;
branches;
next	11.87;

11.87
date	97.12.16.08.14.30;	author mike;	state Exp;
branches;
next	11.86;

11.86
date	97.12.16.00.54.10;	author mike;	state Exp;
branches;
next	11.85;

11.85
date	97.12.16.00.47.26;	author mike;	state Exp;
branches;
next	11.84;

11.84
date	97.10.06.15.25.39;	author mike;	state Exp;
branches;
next	11.83;

11.83
date	97.09.18.20.34.13;	author jra;	state Exp;
branches;
next	11.82;

11.82
date	97.09.02.17.54.12;	author gdurf;	state Exp;
branches;
next	11.81;

11.81
date	97.07.23.06.55.13;	author gdurf;	state Exp;
branches;
next	11.80;

11.80
date	97.07.15.13.16.03;	author gdurf;	state Exp;
branches;
next	11.79;

11.79
date	97.07.15.13.07.30;	author gdurf;	state Exp;
branches;
next	11.78;

11.78
date	97.07.08.15.32.14;	author gdurf;	state Exp;
branches;
next	11.77;

11.77
date	97.07.07.13.11.42;	author gdurf;	state Exp;
branches;
next	11.76;

11.76
date	97.06.25.04.42.00;	author mike;	state Exp;
branches;
next	11.75;

11.75
date	97.06.20.01.49.38;	author gdurf;	state Exp;
branches;
next	11.74;

11.74
date	97.06.17.20.40.44;	author gdurf;	state Exp;
branches;
next	11.73;

11.73
date	97.06.13.02.49.16;	author gdurf;	state Exp;
branches;
next	11.72;

11.72
date	97.05.22.09.47.55;	author butler;	state Exp;
branches;
next	11.71;

11.71
date	97.05.19.17.04.58;	author butler;	state Exp;
branches;
next	11.70;

11.70
date	97.04.25.05.59.40;	author butler;	state Exp;
branches;
next	11.69;

11.69
date	97.04.01.20.12.42;	author butler;	state Exp;
branches;
next	11.68;

11.68
date	97.02.20.21.00.55;	author jra;	state Exp;
branches;
next	11.67;

11.67
date	97.02.05.03.37.20;	author mike;	state Exp;
branches;
next	11.66;

11.66
date	97.01.09.20.16.57;	author jra;	state Exp;
branches;
next	11.65;

11.65
date	97.01.09.17.10.24;	author jra;	state Exp;
branches;
next	11.64;

11.64
date	97.01.09.16.12.40;	author jra;	state Exp;
branches;
next	11.63;

11.63
date	96.12.04.02.49.37;	author mike;	state Exp;
branches;
next	11.62;

11.62
date	96.12.03.04.21.11;	author mike;	state Exp;
branches;
next	11.61;

11.61
date	96.10.31.13.16.37;	author pjt;	state Exp;
branches;
next	11.60;

11.60
date	96.10.21.18.49.42;	author jra;	state Exp;
branches;
next	11.59;

11.59
date	96.10.19.06.26.01;	author mike;	state Exp;
branches;
next	11.58;

11.58
date	96.10.16.02.35.06;	author mike;	state Exp;
branches;
next	11.57;

11.57
date	96.10.05.09.12.34;	author mike;	state Exp;
branches;
next	11.56;

11.56
date	96.09.27.08.19.09;	author mike;	state Exp;
branches;
next	11.55;

11.55
date	96.09.27.06.39.03;	author mike;	state Exp;
branches;
next	11.54;

11.54
date	96.09.27.06.16.56;	author butler;	state Exp;
branches;
next	11.53;

11.53
date	96.09.27.04.04.57;	author butler;	state Exp;
branches;
next	11.52;

11.52
date	96.09.14.03.40.53;	author butler;	state Exp;
branches;
next	11.51;

11.51
date	96.09.11.08.43.03;	author butler;	state Exp;
branches;
next	11.50;

11.50
date	96.08.31.08.44.53;	author mike;	state Exp;
branches;
next	11.49;

11.49
date	96.08.31.07.00.09;	author mike;	state Exp;
branches;
next	11.48;

11.48
date	96.08.31.06.06.13;	author mike;	state Exp;
branches;
next	11.47;

11.47
date	96.08.31.04.07.13;	author mike;	state Exp;
branches;
next	11.46;

11.46
date	96.08.31.03.14.42;	author mike;	state Exp;
branches;
next	11.45;

11.45
date	96.08.31.02.19.23;	author mike;	state Exp;
branches;
next	11.44;

11.44
date	96.08.30.00.14.00;	author butler;	state Exp;
branches;
next	11.43;

11.43
date	96.08.29.06.02.41;	author mike;	state Exp;
branches;
next	11.42;

11.42
date	96.08.28.10.04.47;	author mike;	state Exp;
branches;
next	11.41;

11.41
date	96.08.28.04.04.56;	author mike;	state Exp;
branches;
next	11.40;

11.40
date	96.08.28.02.36.53;	author mike;	state Exp;
branches;
next	11.39;

11.39
date	96.08.13.16.43.26;	author butler;	state Exp;
branches;
next	11.38;

11.38
date	96.07.30.18.48.47;	author butler;	state Exp;
branches;
next	11.37;

11.37
date	96.07.02.05.43.49;	author mike;	state Exp;
branches;
next	11.36;

11.36
date	96.06.12.13.35.40;	author jra;	state Exp;
branches;
next	11.35;

11.35
date	96.05.14.14.16.51;	author jra;	state Exp;
branches;
next	11.34;

11.34
date	96.03.29.21.51.14;	author mike;	state Exp;
branches;
next	11.33;

11.33
date	96.03.28.14.26.25;	author jra;	state Exp;
branches;
next	11.32;

11.32
date	96.03.16.23.55.00;	author jra;	state Exp;
branches;
next	11.31;

11.31
date	96.03.05.21.23.51;	author jra;	state Exp;
branches;
next	11.30;

11.30
date	96.01.04.23.41.49;	author butler;	state Exp;
branches;
next	11.29;

11.29
date	95.12.23.01.55.37;	author butler;	state Exp;
branches;
next	11.28;

11.28
date	95.12.14.15.25.10;	author pjt;	state Exp;
branches;
next	11.27;

11.27
date	95.12.06.17.35.14;	author pjt;	state Exp;
branches;
next	11.26;

11.26
date	95.11.29.02.31.52;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	95.11.29.02.13.26;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	95.11.07.23.19.39;	author adam;	state Exp;
branches;
next	11.23;

11.23
date	95.09.06.13.13.23;	author jra;	state Exp;
branches;
next	11.22;

11.22
date	95.07.27.18.28.27;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	95.07.18.02.48.11;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	95.07.05.16.27.27;	author gdurf;	state Exp;
branches;
next	11.19;

11.19
date	95.07.03.13.30.26;	author gdurf;	state Exp;
branches;
next	11.18;

11.18
date	95.07.03.13.26.02;	author gdurf;	state Exp;
branches;
next	11.17;

11.17
date	95.06.21.15.05.09;	author gdurf;	state Exp;
branches;
next	11.16;

11.16
date	95.06.20.16.45.39;	author gdurf;	state Exp;
branches;
next	11.15;

11.15
date	95.06.20.15.20.10;	author butler;	state Exp;
branches;
next	11.14;

11.14
date	95.06.20.15.00.15;	author butler;	state Exp;
branches;
next	11.13;

11.13
date	95.06.20.13.35.59;	author gdurf;	state Exp;
branches;
next	11.12;

11.12
date	95.06.16.19.21.51;	author gdurf;	state Exp;
branches;
next	11.11;

11.11
date	95.06.16.17.55.26;	author pjt;	state Exp;
branches;
next	11.10;

11.10
date	95.06.16.17.18.53;	author pjt;	state Exp;
branches;
next	11.9;

11.9
date	95.06.15.01.33.45;	author gdurf;	state Exp;
branches;
next	11.8;

11.8
date	95.06.15.01.32.12;	author gdurf;	state Exp;
branches;
next	11.7;

11.7
date	95.05.26.08.35.37;	author butler;	state Exp;
branches;
next	11.6;

11.6
date	95.03.18.02.18.12;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	95.03.10.22.35.33;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.02.18.00.47.43;	author butler;	state Exp;
branches;
next	11.3;

11.3
date	95.02.16.23.55.17;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.02.16.03.43.40;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.48.32;	author mike;	state Rel4_4;
branches;
next	10.96;

10.96
date	94.12.30.00.01.34;	author mike;	state Exp;
branches;
next	10.95;

10.95
date	94.12.29.16.12.33;	author jra;	state Exp;
branches;
next	10.94;

10.94
date	94.12.27.16.38.51;	author mike;	state Exp;
branches;
next	10.93;

10.93
date	94.12.27.15.13.40;	author jra;	state Exp;
branches;
next	10.92;

10.92
date	94.12.16.17.23.01;	author mike;	state Exp;
branches;
next	10.91;

10.91
date	94.12.08.17.57.55;	author jra;	state Exp;
branches;
next	10.90;

10.90
date	94.11.08.03.13.39;	author mike;	state Exp;
branches;
next	10.89;

10.89
date	94.11.05.04.50.06;	author mike;	state Exp;
branches;
next	10.88;

10.88
date	94.11.05.03.24.07;	author mike;	state Exp;
branches;
next	10.87;

10.87
date	94.11.04.10.56.26;	author jra;	state Exp;
branches;
next	10.86;

10.86
date	94.11.04.05.49.18;	author mike;	state Exp;
branches;
next	10.85;

10.85
date	94.10.31.21.30.32;	author mike;	state Exp;
branches;
next	10.84;

10.84
date	94.10.31.20.11.10;	author butler;	state Exp;
branches;
next	10.83;

10.83
date	94.10.31.20.08.04;	author butler;	state Exp;
branches;
next	10.82;

10.82
date	94.10.28.21.48.14;	author mike;	state Exp;
branches;
next	10.81;

10.81
date	94.10.17.23.40.24;	author mike;	state Exp;
branches;
next	10.80;

10.80
date	94.09.29.20.53.46;	author mike;	state Exp;
branches;
next	10.79;

10.79
date	94.09.28.16.17.35;	author mike;	state Exp;
branches;
next	10.78;

10.78
date	94.09.21.03.31.33;	author mike;	state Exp;
branches;
next	10.77;

10.77
date	94.09.16.20.45.00;	author mike;	state Exp;
branches;
next	10.76;

10.76
date	94.09.16.20.21.36;	author mike;	state Exp;
branches;
next	10.75;

10.75
date	94.09.13.20.37.49;	author mike;	state Exp;
branches;
next	10.74;

10.74
date	94.09.10.04.35.00;	author mike;	state Exp;
branches;
next	10.73;

10.73
date	94.09.02.01.12.45;	author mike;	state Exp;
branches;
next	10.72;

10.72
date	94.09.01.05.44.29;	author gdurf;	state Exp;
branches;
next	10.71;

10.71
date	94.08.22.15.32.54;	author mike;	state Exp;
branches;
next	10.70;

10.70
date	94.08.09.23.03.22;	author mike;	state Exp;
branches;
next	10.69;

10.69
date	94.08.04.20.03.29;	author gdurf;	state Exp;
branches;
next	10.68;

10.68
date	94.07.01.23.35.45;	author mike;	state Exp;
branches;
next	10.67;

10.67
date	94.06.30.19.39.12;	author mike;	state Exp;
branches;
next	10.66;

10.66
date	94.06.23.22.42.24;	author butler;	state Exp;
branches;
next	10.65;

10.65
date	94.05.24.17.27.35;	author butler;	state Exp;
branches;
next	10.64;

10.64
date	94.05.10.08.15.26;	author mike;	state Exp;
branches;
next	10.63;

10.63
date	94.05.10.06.24.40;	author mike;	state Exp;
branches;
next	10.62;

10.62
date	94.05.09.23.16.28;	author mike;	state Exp;
branches;
next	10.61;

10.61
date	94.04.25.00.19.58;	author butler;	state Exp;
branches;
next	10.60;

10.60
date	94.04.24.23.38.25;	author butler;	state Exp;
branches;
next	10.59;

10.59
date	94.04.22.05.27.52;	author mike;	state Exp;
branches;
next	10.58;

10.58
date	94.04.19.02.41.12;	author butler;	state Exp;
branches;
next	10.57;

10.57
date	94.04.19.01.45.50;	author butler;	state Exp;
branches;
next	10.56;

10.56
date	94.04.05.04.23.17;	author cjohnson;	state Exp;
branches;
next	10.55;

10.55
date	94.04.05.02.14.15;	author cjohnson;	state Exp;
branches;
next	10.54;

10.54
date	94.03.31.23.37.48;	author cjohnson;	state Exp;
branches;
next	10.53;

10.53
date	94.03.22.19.17.55;	author mike;	state Exp;
branches;
next	10.52;

10.52
date	94.03.18.00.35.38;	author mike;	state Exp;
branches;
next	10.51;

10.51
date	94.03.12.01.41.42;	author butler;	state Exp;
branches;
next	10.50;

10.50
date	94.03.11.20.05.55;	author butler;	state Exp;
branches;
next	10.49;

10.49
date	94.03.04.18.15.13;	author cjohnson;	state Exp;
branches;
next	10.48;

10.48
date	94.02.24.06.41.30;	author butler;	state Exp;
branches;
next	10.47;

10.47
date	94.02.01.21.59.28;	author mike;	state Exp;
branches;
next	10.46;

10.46
date	94.01.25.09.45.51;	author mike;	state Exp;
branches;
next	10.45;

10.45
date	93.12.22.06.20.54;	author mike;	state Exp;
branches;
next	10.44;

10.44
date	93.11.18.02.19.34;	author butler;	state Exp;
branches;
next	10.43;

10.43
date	93.11.18.01.49.57;	author butler;	state Exp;
branches;
next	10.42;

10.42
date	93.11.18.01.37.46;	author mike;	state Exp;
branches;
next	10.41;

10.41
date	93.11.12.23.34.59;	author mike;	state Exp;
branches;
next	10.40;

10.40
date	93.11.10.04.03.36;	author cjohnson;	state Exp;
branches;
next	10.39;

10.39
date	93.11.09.20.59.22;	author cjohnson;	state Exp;
branches;
next	10.38;

10.38
date	93.10.22.22.26.43;	author mike;	state Exp;
branches;
next	10.37;

10.37
date	93.10.02.01.06.43;	author mike;	state Exp;
branches;
next	10.36;

10.36
date	93.10.01.20.29.13;	author butler;	state Exp;
branches;
next	10.35;

10.35
date	93.08.12.22.27.20;	author mike;	state Exp;
branches;
next	10.34;

10.34
date	93.07.20.21.16.43;	author mike;	state Exp;
branches;
next	10.33;

10.33
date	93.07.20.21.14.39;	author mike;	state Exp;
branches;
next	10.32;

10.32
date	93.06.04.16.32.43;	author butler;	state Exp;
branches;
next	10.31;

10.31
date	93.05.20.17.12.21;	author mike;	state Exp;
branches;
next	10.30;

10.30
date	93.04.03.04.38.18;	author mike;	state Exp;
branches;
next	10.29;

10.29
date	93.04.03.01.59.33;	author mike;	state Exp;
branches;
next	10.28;

10.28
date	93.04.02.23.45.23;	author mike;	state Exp;
branches;
next	10.27;

10.27
date	93.04.02.02.26.58;	author mike;	state Exp;
branches;
next	10.26;

10.26
date	93.04.01.03.56.07;	author mike;	state Exp;
branches;
next	10.25;

10.25
date	93.03.27.00.03.37;	author mike;	state Exp;
branches;
next	10.24;

10.24
date	93.03.26.23.39.45;	author mike;	state Exp;
branches;
next	10.23;

10.23
date	93.03.26.23.22.31;	author mike;	state Exp;
branches;
next	10.22;

10.22
date	93.03.26.22.15.14;	author mike;	state Exp;
branches;
next	10.21;

10.21
date	93.03.26.21.28.11;	author mike;	state Exp;
branches;
next	10.20;

10.20
date	93.03.26.18.23.59;	author mm;	state Exp;
branches;
next	10.19;

10.19
date	93.03.25.23.20.29;	author mike;	state Exp;
branches;
next	10.18;

10.18
date	93.03.24.03.19.46;	author mike;	state Exp;
branches;
next	10.17;

10.17
date	93.03.23.22.50.08;	author mike;	state Exp;
branches;
next	10.16;

10.16
date	93.03.20.04.09.33;	author mike;	state Exp;
branches;
next	10.15;

10.15
date	93.02.19.04.47.26;	author mike;	state Exp;
branches;
next	10.14;

10.14
date	92.11.17.00.17.40;	author mike;	state Exp;
branches;
next	10.13;

10.13
date	92.11.16.23.25.13;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	92.11.16.23.09.46;	author mike;	state Exp;
branches;
next	10.11;

10.11
date	92.11.11.00.24.22;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	92.10.27.17.58.14;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	92.10.27.16.54.38;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	92.10.13.15.57.20;	author mm;	state Exp;
branches;
next	10.7;

10.7
date	92.07.23.05.11.20;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	92.06.01.16.19.42;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	92.05.04.21.37.34;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.05.04.15.07.48;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.02.14.15.27.10;	author mmark;	state Exp;
branches;
next	10.2;

10.2
date	92.02.05.13.22.54;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.35.30;	author mike;	state Rel4_0;
branches;
next	9.95;

9.95
date	91.10.10.22.41.02;	author mike;	state Exp;
branches;
next	9.94;

9.94
date	91.10.01.02.41.21;	author mike;	state Exp;
branches;
next	9.93;

9.93
date	91.09.27.21.45.23;	author phil;	state Exp;
branches;
next	9.92;

9.92
date	91.08.28.00.24.13;	author mike;	state Exp;
branches;
next	9.91;

9.91
date	91.07.15.23.16.32;	author mike;	state Exp;
branches;
next	9.90;

9.90
date	91.07.05.21.39.51;	author mike;	state Exp;
branches;
next	9.89;

9.89
date	91.07.05.21.25.46;	author mike;	state Exp;
branches;
next	9.88;

9.88
date	91.07.01.03.28.53;	author mike;	state Exp;
branches;
next	9.87;

9.87
date	91.06.30.23.02.34;	author mike;	state Exp;
branches;
next	9.86;

9.86
date	91.06.30.22.08.46;	author mike;	state Exp;
branches;
next	9.85;

9.85
date	91.06.30.19.18.56;	author mike;	state Exp;
branches;
next	9.84;

9.84
date	91.06.29.23.36.27;	author mike;	state Exp;
branches;
next	9.83;

9.83
date	91.06.29.23.16.30;	author mike;	state Exp;
branches;
next	9.82;

9.82
date	91.06.29.22.13.33;	author mike;	state Exp;
branches;
next	9.81;

9.81
date	91.06.25.04.50.54;	author mike;	state Exp;
branches;
next	9.80;

9.80
date	91.06.23.00.06.40;	author mike;	state Exp;
branches;
next	9.79;

9.79
date	91.06.22.21.18.53;	author mike;	state Exp;
branches;
next	9.78;

9.78
date	91.06.22.20.53.09;	author mike;	state Exp;
branches;
next	9.77;

9.77
date	91.06.22.20.09.33;	author butler;	state Exp;
branches;
next	9.76;

9.76
date	91.06.14.03.40.04;	author mike;	state Exp;
branches;
next	9.75;

9.75
date	91.06.13.01.34.46;	author mike;	state Exp;
branches;
next	9.74;

9.74
date	91.06.12.20.39.07;	author mike;	state Exp;
branches;
next	9.73;

9.73
date	91.06.04.22.55.13;	author mike;	state Exp;
branches;
next	9.72;

9.72
date	91.05.23.10.34.58;	author jehunt;	state Exp;
branches;
next	9.71;

9.71
date	91.05.22.23.35.44;	author mike;	state Exp;
branches;
next	9.70;

9.70
date	91.05.18.02.44.13;	author mike;	state Exp;
branches;
next	9.69;

9.69
date	91.05.17.00.17.26;	author mike;	state Exp;
branches;
next	9.68;

9.68
date	91.05.16.23.22.23;	author mike;	state Exp;
branches;
next	9.67;

9.67
date	91.02.21.16.07.51;	author mike;	state Exp;
branches;
next	9.66;

9.66
date	91.02.17.19.59.31;	author mike;	state Exp;
branches;
next	9.65;

9.65
date	91.02.07.20.29.43;	author mike;	state Exp;
branches;
next	9.64;

9.64
date	91.02.04.18.28.29;	author mike;	state Exp;
branches;
next	9.63;

9.63
date	91.01.28.23.27.03;	author mike;	state Exp;
branches;
next	9.62;

9.62
date	91.01.26.03.17.23;	author mike;	state Exp;
branches;
next	9.61;

9.61
date	91.01.26.02.56.40;	author mike;	state Exp;
branches;
next	9.60;

9.60
date	91.01.25.22.36.28;	author cjohnson;	state Exp;
branches;
next	9.59;

9.59
date	91.01.25.21.17.25;	author mike;	state Exp;
branches;
next	9.58;

9.58
date	91.01.25.12.51.49;	author cjohnson;	state Exp;
branches;
next	9.57;

9.57
date	91.01.14.22.47.57;	author mike;	state Exp;
branches;
next	9.56;

9.56
date	91.01.14.22.43.11;	author mike;	state Exp;
branches;
next	9.55;

9.55
date	91.01.12.07.26.48;	author mike;	state Exp;
branches;
next	9.54;

9.54
date	91.01.12.04.36.30;	author butler;	state Exp;
branches;
next	9.53;

9.53
date	91.01.11.06.10.29;	author mike;	state Exp;
branches;
next	9.52;

9.52
date	91.01.11.06.04.32;	author mike;	state Exp;
branches;
next	9.51;

9.51
date	91.01.09.02.13.16;	author mike;	state Exp;
branches;
next	9.50;

9.50
date	91.01.09.01.52.43;	author mike;	state Exp;
branches;
next	9.49;

9.49
date	91.01.05.02.54.54;	author mike;	state Exp;
branches;
next	9.48;

9.48
date	91.01.05.02.54.26;	author mike;	state Exp;
branches;
next	9.47;

9.47
date	90.12.21.14.21.01;	author butler;	state Exp;
branches;
next	9.46;

9.46
date	90.12.10.19.36.29;	author mike;	state Exp;
branches;
next	9.45;

9.45
date	90.12.10.17.19.21;	author cjohnson;	state Exp;
branches;
next	9.44;

9.44
date	90.12.10.14.15.55;	author butler;	state Exp;
branches;
next	9.43;

9.43
date	90.12.08.04.45.24;	author mike;	state Exp;
branches;
next	9.42;

9.42
date	90.12.08.01.29.08;	author mike;	state Exp;
branches;
next	9.41;

9.41
date	90.12.07.05.28.46;	author mike;	state Exp;
branches;
next	9.40;

9.40
date	90.12.07.01.34.57;	author mike;	state Exp;
branches;
next	9.39;

9.39
date	90.12.05.05.55.17;	author mike;	state Exp;
branches;
next	9.38;

9.38
date	90.11.24.01.39.41;	author mike;	state Exp;
branches;
next	9.37;

9.37
date	90.11.12.18.17.33;	author mike;	state Exp;
branches;
next	9.36;

9.36
date	90.11.11.04.57.39;	author mike;	state Exp;
branches;
next	9.35;

9.35
date	90.11.02.03.07.02;	author mike;	state Exp;
branches;
next	9.34;

9.34
date	90.11.01.04.27.37;	author mike;	state Exp;
branches;
next	9.33;

9.33
date	90.10.15.23.20.28;	author mike;	state Exp;
branches;
next	9.32;

9.32
date	90.10.15.11.39.38;	author mike;	state Exp;
branches;
next	9.31;

9.31
date	90.10.11.02.18.48;	author mike;	state Exp;
branches;
next	9.30;

9.30
date	90.10.07.21.37.16;	author mike;	state Exp;
branches;
next	9.29;

9.29
date	90.10.06.02.39.05;	author mike;	state Exp;
branches;
next	9.28;

9.28
date	90.10.06.02.04.20;	author mike;	state Exp;
branches;
next	9.27;

9.27
date	90.10.04.20.58.23;	author mike;	state Exp;
branches;
next	9.26;

9.26
date	90.07.31.00.57.29;	author mike;	state Exp;
branches;
next	9.25;

9.25
date	90.06.07.02.16.30;	author mike;	state Exp;
branches;
next	9.24;

9.24
date	90.06.05.00.44.14;	author mike;	state Exp;
branches;
next	9.23;

9.23
date	90.05.24.18.06.51;	author mike;	state Exp;
branches;
next	9.22;

9.22
date	90.05.24.04.07.37;	author mike;	state Exp;
branches;
next	9.21;

9.21
date	90.05.24.01.12.20;	author mike;	state Exp;
branches;
next	9.20;

9.20
date	90.05.22.21.15.45;	author mike;	state Exp;
branches;
next	9.19;

9.19
date	90.05.22.21.07.29;	author butler;	state Exp;
branches;
next	9.18;

9.18
date	90.05.17.11.19.48;	author mike;	state Exp;
branches;
next	9.17;

9.17
date	90.05.16.06.52.41;	author butler;	state Exp;
branches;
next	9.16;

9.16
date	90.05.03.07.52.02;	author butler;	state Exp;
branches;
next	9.15;

9.15
date	90.05.02.23.00.10;	author butler;	state Exp;
branches;
next	9.14;

9.14
date	90.05.02.01.08.55;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	90.04.12.02.52.10;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	90.03.14.10.00.13;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	90.03.10.00.43.18;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	90.01.06.04.49.29;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	90.01.06.03.52.54;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	90.01.06.01.29.02;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	89.12.31.04.59.31;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	89.12.30.05.15.45;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	89.12.08.05.29.01;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	89.10.13.20.35.15;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	89.10.10.15.42.12;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.07.28.03.37.26;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.44.21;	author mike;	state Rel3_5;
branches;
next	8.24;

8.24
date	89.05.08.21.43.53;	author phil;	state Exp;
branches;
next	8.23;

8.23
date	89.04.30.20.44.55;	author mike;	state Exp;
branches;
next	8.22;

8.22
date	89.04.27.23.11.41;	author phil;	state Exp;
branches;
next	8.21;

8.21
date	89.04.27.04.09.13;	author mike;	state Exp;
branches;
next	8.20;

8.20
date	89.04.21.22.31.28;	author mike;	state Exp;
branches;
next	8.19;

8.19
date	89.04.14.03.02.33;	author mike;	state Exp;
branches;
next	8.18;

8.18
date	89.04.13.06.16.23;	author mike;	state Exp;
branches;
next	8.17;

8.17
date	89.04.06.20.43.07;	author mike;	state Exp;
branches;
next	8.16;

8.16
date	89.04.04.02.13.31;	author mike;	state Exp;
branches;
next	8.15;

8.15
date	89.03.15.15.25.10;	author mike;	state Exp;
branches;
next	8.14;

8.14
date	89.03.15.15.16.32;	author mike;	state Exp;
branches;
next	8.13;

8.13
date	89.02.27.02.06.35;	author phil;	state Exp;
branches;
next	8.12;

8.12
date	89.01.19.19.48.44;	author mike;	state Exp;
branches;
next	8.11;

8.11
date	89.01.11.07.58.36;	author mike;	state Exp;
branches;
next	8.10;

8.10
date	88.12.30.06.22.54;	author mike;	state Exp;
branches;
next	8.9;

8.9
date	88.12.30.00.10.07;	author mike;	state Exp;
branches;
next	8.8;

8.8
date	88.12.27.12.18.07;	author mike;	state Exp;
branches;
next	8.7;

8.7
date	88.12.15.01.34.18;	author phil;	state Exp;
branches;
next	8.6;

8.6
date	88.12.13.00.59.29;	author mike;	state Exp;
branches;
next	8.5;

8.5
date	88.12.10.02.47.44;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	88.12.06.15.18.03;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	88.12.05.22.24.37;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.10.06.02.54.47;	author mike;	state Rel3_0;
branches;
next	8.1;

8.1
date	88.10.05.00.24.30;	author mike;	state Rel3_0;
branches;
next	7.18;

7.18
date	88.09.17.07.46.33;	author mike;	state Exp;
branches;
next	7.17;

7.17
date	88.09.09.04.05.52;	author mike;	state Exp;
branches;
next	7.16;

7.16
date	88.09.02.19.55.45;	author phil;	state Exp;
branches;
next	7.15;

7.15
date	88.08.20.07.22.20;	author mike;	state Exp;
branches;
next	7.14;

7.14
date	88.08.19.03.25.25;	author mike;	state Exp;
branches;
next	7.13;

7.13
date	88.08.18.02.57.01;	author phil;	state Exp;
branches;
next	7.12;

7.12
date	88.07.14.20.08.17;	author mike;	state Exp;
branches;
next	7.11;

7.11
date	88.05.16.05.01.30;	author mike;	state Exp;
branches;
next	7.10;

7.10
date	88.05.16.01.38.20;	author mike;	state Exp;
branches;
next	7.9;

7.9
date	88.05.14.02.32.28;	author mike;	state Exp;
branches;
next	7.8;

7.8
date	88.05.14.01.31.32;	author mike;	state Exp;
branches;
next	7.7;

7.7
date	88.02.25.06.02.16;	author mike;	state Exp;
branches;
next	7.6;

7.6
date	88.02.05.03.22.30;	author mike;	state Exp;
branches;
next	7.5;

7.5
date	88.01.27.06.37.33;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.01.26.04.15.12;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.01.23.05.45.58;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.06.29.24;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.22.38;	author mike;	state Rel;
branches;
next	6.3;

6.3
date	87.09.10.07.09.26;	author mike;	state Exp;
branches;
next	6.2;

6.2
date	87.08.09.19.14.51;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.48.26;	author mike;	state Rel;
branches;
next	5.7;

5.7
date	87.07.10.04.50.44;	author mike;	state Exp;
branches;
next	5.6;

5.6
date	87.07.08.00.55.40;	author mike;	state Exp;
branches;
next	5.5;

5.5
date	87.06.27.03.43.01;	author mike;	state Exp;
branches;
next	5.4;

5.4
date	87.06.26.23.27.34;	author mike;	state Exp;
branches;
next	5.3;

5.3
date	87.06.26.22.31.38;	author mike;	state Exp;
branches;
next	5.2;

5.2
date	87.06.26.05.54.16;	author mike;	state Exp;
branches;
next	5.1;

5.1
date	87.06.24.21.47.22;	author mike;	state Rel;
branches;
next	4.8;

4.8
date	87.05.21.01.54.33;	author mike;	state Exp;
branches;
next	4.7;

4.7
date	87.04.28.00.25.21;	author phil;	state Exp;
branches;
next	4.6;

4.6
date	87.03.24.01.01.18;	author phil;	state Exp;
branches;
next	4.5;

4.5
date	87.03.23.23.34.42;	author mike;	state Exp;
branches;
next	4.4;

4.4
date	87.03.11.00.14.02;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.02.12.22.00.27;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.01.28.22.33.03;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.02.46.06;	author mike;	state Rel1;
branches;
next	3.13;

3.13
date	86.12.24.08.03.29;	author mike;	state Exp;
branches;
next	3.12;

3.12
date	86.12.18.16.53.48;	author mike;	state Exp;
branches;
next	3.11;

3.11
date	86.11.07.02.54.50;	author mike;	state Exp;
branches;
next	3.10;

3.10
date	86.10.27.22.17.48;	author mike;	state Exp;
branches;
next	3.9;

3.9
date	86.07.24.06.01.45;	author mike;	state Exp;
branches;
next	3.8;

3.8
date	86.07.24.01.38.26;	author mike;	state Exp;
branches;
next	3.7;

3.7
date	86.07.22.04.12.47;	author mike;	state Exp;
branches;
next	3.6;

3.6
date	86.07.22.03.44.54;	author mike;	state Exp;
branches;
next	3.5;

3.5
date	86.07.22.03.25.17;	author mike;	state Exp;
branches;
next	3.4;

3.4
date	86.07.19.04.37.04;	author mike;	state Exp;
branches;
next	3.3;

3.3
date	86.07.11.17.22.20;	author mike;	state Exp;
branches;
next	3.2;

3.2
date	86.07.11.01.30.07;	author mike;	state Exp;
branches;
next	3.1;

3.1
date	86.06.11.00.36.46;	author mike;	state Exp;
branches;
next	3.0;

3.0
date	86.06.10.01.33.09;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	85.09.18.01.26.52;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	85.09.14.05.30.53;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.09.11.23.54.08;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.09.06.02.25.46;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.08.31.06.02.07;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	85.07.30.05.51.16;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	85.06.05.00.25.32;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	85.06.04.23.23.43;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	85.05.29.00.13.14;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	85.05.28.21.30.49;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	85.03.25.17.43.55;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	85.03.25.11.43.51;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	85.02.07.19.19.11;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	85.02.06.21.28.42;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	84.11.30.04.03.44;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	84.11.29.07.00.00;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	84.11.24.02.57.55;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	84.11.24.02.49.27;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	84.11.23.20.53.28;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	84.11.20.20.13.45;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	84.11.16.06.23.38;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	84.10.19.01.37.14;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	84.10.16.23.03.39;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	84.08.21.01.14.52;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	84.05.02.05.08.33;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	84.05.01.06.38.13;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	84.04.26.05.38.50;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.04.18.02.19.00;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.04.02.16.41.03;	author mike;	state Exp;
branches;
next	;

11.229.2.1
date	2000.10.26.14.41.33;	author butler;	state Exp;
branches;
next	11.229.2.2;

11.229.2.2
date	2000.11.01.18.43.34;	author jra;	state Exp;
branches;
next	11.229.2.3;

11.229.2.3
date	2000.11.14.21.35.59;	author jra;	state Exp;
branches;
next	11.229.2.4;

11.229.2.4
date	2000.11.27.23.29.16;	author jra;	state Exp;
branches;
next	11.229.2.5;

11.229.2.5
date	2001.01.11.23.25.03;	author bparker;	state Exp;
branches;
next	;

11.340.2.1
date	2003.01.31.00.11.53;	author morrison;	state Exp;
branches;
next	11.340.2.2;

11.340.2.2
date	2003.02.11.03.21.08;	author morrison;	state Exp;
branches;
next	11.340.2.3;

11.340.2.3
date	2004.03.17.21.16.14;	author morrison;	state Exp;
branches;
next	11.340.2.4;

11.340.2.4
date	2004.04.04.20.59.05;	author morrison;	state Exp;
branches;
next	11.340.2.5;

11.340.2.5
date	2004.04.05.00.49.53;	author morrison;	state Exp;
branches;
next	;

11.340.4.1
date	2002.09.26.23.03.45;	author morrison;	state Exp;
branches;
next	11.340.4.2;

11.340.4.2
date	2004.03.11.23.40.47;	author morrison;	state Exp;
branches;
next	;

11.345.2.1
date	2003.08.26.13.59.18;	author justin;	state Exp;
branches;
next	;

11.346.4.1
date	2003.12.03.16.24.04;	author erikg;	state Exp;
branches;
next	11.346.4.2;

11.346.4.2
date	2004.02.12.18.32.36;	author erikg;	state Exp;
branches;
next	11.346.4.3;

11.346.4.3
date	2004.03.10.13.21.20;	author erikg;	state Exp;
branches;
next	11.346.4.4;

11.346.4.4
date	2004.03.15.14.06.10;	author erikg;	state Exp;
branches;
next	11.346.4.5;

11.346.4.5
date	2004.03.18.18.00.45;	author erikg;	state Exp;
branches;
next	;


desc
@All the data structures and manifest constants
necessary for interacting with the BRL-CAD LIBRT ray-tracing library.
@


11.357
log
@moved/renamed from top-level h/ to top-level include/
@
text
@/*
 *			R A Y T R A C E . H
 *
 *  All the data structures and manifest constants
 *  necessary for interacting with the BRL-CAD LIBRT ray-tracing library.
 *
 *  Note that this header file defines many internal data structures,
 *  as well as the library's external (interface) data structures.  These are
 *  provided for the convenience of applications builders.  However,
 *  the internal data structures are subject to change in each release.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005 USA
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1993-2004 by the United States Army.
 *	All rights reserved.
 *
 *  Include Sequencing -
 *	#include "conf.h"	/_* Must come before system <> includes *_/
 *	#ifdef USE_STRING_H	/_* OPTIONAL, for strcmp() etc. *_/
 *	#  include <string.h>
 *	#else
 *	#  include <strings.h>
 *	#endif
 *	#include <stdio.h>
 *	#include <math.h>
 *	#include "machine.h"	/_* For fastf_t definition on this machine *_/
 *	#include "externs.h"	/_* OPTIONAL, for defining syscalls *_/
 *	#include "bu.h"
 *	#include "vmath.h"	/_* For vect_t definition *_/
 *	#include "bn.h"
 *	#include "db.h"		/_* OPTIONAL, precedes raytrace.h when used *_/
 *	#include "nmg.h"	/_* OPTIONAL, precedes raytrace.h when used *_/
 *	#include "raytrace.h"
 *	#include "nurb.h"	/_* OPTIONAL, follows raytrace.h when used *_/
 *
 *  Libraries Used -
 *	LIBRT LIBRT_LIBES -lm -lc
 *
 *  $Header: /n/xoff/cvs/brlcad/h/raytrace.h,v 11.356 2004/05/10 15:25:26 morrison Exp $
 */

#ifndef RAYTRACE_H
#define RAYTRACE_H seen

/*
 *  Auto-include the BRL-CAD Utilities library, and compatability macros
 */
#include "bu.h"
#include "compat4.h"
#include "bn.h"
#include "db5.h"
#include "tcl.h"

#ifndef NMG_H
#include "nmg.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define RAYTRACE_H_VERSION	"@@(#)$Header: /n/xoff/cvs/brlcad/h/raytrace.h,v 11.356 2004/05/10 15:25:26 morrison Exp $ (BRL)"

/*
 *				D E B U G
 *  
 *  Each type of debugging support is independently controled,
 *  by a separate bit in the word RT_G_DEBUG
 *
 *  For programs based on the "RT" program, these flags follow
 *  the "-x" (lower case x) option.
 */
#define DEBUG_OFF	0	/* No debugging */

/* These definitions are each for one bit */

/* Options useful for debugging applications */
#define DEBUG_ALLRAYS	0x00000001	/* 1 Print calls to rt_shootray() */
#define DEBUG_ALLHITS	0x00000002	/* 2 Print partitions passed to a_hit() */
#define DEBUG_SHOOT	0x00000004	/* 3 Info about rt_shootray() processing */
#define DEBUG_INSTANCE	0x00000008	/* 4 regionid instance revectoring */

/* Options useful for debugging the database */
#define DEBUG_DB	0x00000010	/* 5 Database debugging */
#define DEBUG_SOLIDS	0x00000020	/* 6 Print prep'ed solids */
#define DEBUG_REGIONS	0x00000040	/* 7 Print regions & boolean trees */
#define DEBUG_ARB8	0x00000080	/* 8 Print voluminus ARB8 details */
#define DEBUG_SPLINE	0x00000100	/* 9 Splines */
#define DEBUG_ANIM	0x00000200	/* 10 Animation */
#define DEBUG_ANIM_FULL	0x00000400	/* 11 Animation matrices */
#define DEBUG_VOL	0x00000800	/* 12 Volume & opaque Binary solid */

/* Options useful for debugging the library */
#define DEBUG_ROOTS	0x00001000	/* 13 Print rootfinder details */
#define DEBUG_PARTITION	0x00002000	/* 14 Info about bool_weave() */
#define DEBUG_CUT	0x00004000	/* 15 Print space cutting statistics */
#define DEBUG_BOXING	0x00008000	/* 16 Object/box checking details */
#define DEBUG_MEM	0x00010000	/* 17 -->> BU_DEBUG_MEM_LOG */
#define DEBUG_MEM_FULL	0x00020000	/* 18 -->> BU_DEBUG_MEM_CHECK */
#define DEBUG_FDIFF	0x00040000	/* 19 bool/fdiff debugging */
#define DEBUG_PARALLEL	0x00080000	/* 20 -->> BU_DEBUG_PARALLEL */
#define DEBUG_CUTDETAIL	0x00100000	/* 21 Print space cutting details */
#define DEBUG_TREEWALK	0x00200000	/* 22 Database tree traversal */
#define DEBUG_TESTING	0x00400000	/* 23 One-shot debugging flag */
#define DEBUG_ADVANCE	0x00800000	/* 24 Cell-to-cell space partitioning */
#define DEBUG_MATH	0x01000000	/* 25 nmg math routines */

/* Options for debugging particular solids */
#define DEBUG_EBM	0x02000000	/* 26 Extruded bit-map solids */
#define DEBUG_HF	0x04000000	/* 27 Height Field solids */

/* Options which will cause the library to write binary debugging output */
#define DEBUG_PLOTSOLIDS 0x40000000	/* 31 plot all solids */
#define DEBUG_PLOTBOX	0x80000000	/* 32 Plot(3) bounding boxes and cuts */

/* Format string for bu_printb() */
#define DEBUG_FORMAT	\
"\020\040PLOTBOX\
\037PLOTSOLIDS\
\033HF\032EBM\031MATH\030ADVANCE\
\027TESTING\026TREEWALK\025CUTDETAIL\024PARALLEL\023FDIFF\022MEM_FULL\
\021MEM\020BOXING\017CUTTING\016PARTITION\015ROOTS\014VOL\
\013ANIM_FULL\012ANIM\011SPLINE\010ARB8\7REGIONS\6SOLIDS\5DB\
\4INSTANCE\3SHOOT\2ALLHITS\1ALLRAYS"

/*
 *  It is necessary to have a representation of 1.0/0.0, or "infinity"
 *  that fits within the dynamic range of the machine being used.
 *  This constant places an upper bound on the size object which
 *  can be represented in the model.
 */
#ifdef INFINITY
#	undef INFINITY
#endif

#if defined(vax) || (defined(sgi) && !defined(mips))
#	define INFINITY	(1.0e20)	/* VAX limit is 10**37 */
#else
#	define INFINITY	(1.0e40)	/* IBM limit is 10**75 */
#endif

#define	RT_BADNUM(n)	(!((n) >= -INFINITY && (n) <= INFINITY))
#define RT_BADVEC(v)	(RT_BADNUM((v)[X]) || RT_BADNUM((v)[Y]) || RT_BADNUM((v)[Z]))

/*
 *  Unfortunately, to prevent divide-by-zero, some tolerancing
 *  needs to be introduced.
 *
 *  RT_LEN_TOL is the shortest length, in mm, that can be stood
 *  as the dimensions of a primitive.
 *  Can probably become at least SMALL.
 *
 *  Dot products smaller than RT_DOT_TOL are considered to have
 *  a dot product of zero, i.e., the angle is effectively zero.
 *  This is used to check vectors that should be perpendicular.
 *  asin(0.1   ) = 5.73917 degrees
 *  asin(0.01  ) = 0.572967
 *  asin(0.001 ) = 0.0572958 degrees
 *  asin(0.0001) = 0.00572958 degrees
 *
 *  sin(0.01 degrees) = sin(0.000174 radians) = 0.000174533
 *
 *  Many TGCs at least, in existing databases, will fail the
 *  perpendicularity test if DOT_TOL is much smaller than 0.001,
 *  which establishes a 1/20th degree tolerance.
 *  The intent is to eliminate grossly bad primitives, not pick nits.
 *
 *  RT_PCOEF_TOL is a tolerance on polynomial coefficients to prevent
 *  the root finder from having heartburn.
 */
#define RT_LEN_TOL	(1.0e-8)
#define RT_DOT_TOL	(0.001)
#define RT_PCOEF_TOL	(1.0e-10)


/*
 *			R T _ T E S S _ T O L
 *
 *  Tessellation (geometric) tolerances,
 *  different beasts than the calcuation tolerance in bn_tol.
 */
struct rt_tess_tol  {
	long		magic;
	double		abs;			/* absolute dist tol */
	double		rel;			/* rel dist tol */
	double		norm;			/* normal tol */
};
#define RT_TESS_TOL_MAGIC	0xb9090dab
#define RT_CK_TESS_TOL(_p)	BU_CKMAG(_p, RT_TESS_TOL_MAGIC, "rt_tess_tol")

/*
 *  Macros for providing function prototypes, regardless of whether
 *  the compiler understands them or not.
 *  It is vital that the argument list given for "args" be enclosed
 *  in parens.
 *  The setting of USE_PROTOTYPES is done in machine.h
 *  XXX These have been replaced by BU_EXTERN() and BU_ARGS()
 */
#if USE_PROTOTYPES
#	define	RT_EXTERN(type_and_name,args)	extern type_and_name args
#	define	RT_ARGS(args)			args
#else
#	define	RT_EXTERN(type_and_name,args)	extern type_and_name()
#	define	RT_ARGS(args)			()
#endif

/*
 *			R T _ D B _ I N T E R N A L
 *
 *  A handle on the internal format of an MGED database object.
 */
struct rt_db_internal  {
	long		idb_magic;
	int		idb_major_type;
	int		idb_minor_type;		/* ID_xxx */
	const struct rt_functab *idb_meth;	/* for ft_ifree(), etc. */
	genptr_t	idb_ptr;
	struct bu_attribute_value_set idb_avs;
};
#define idb_type		idb_minor_type
#define RT_DB_INTERNAL_MAGIC	0x0dbbd867
#define RT_INIT_DB_INTERNAL(_p)	{(_p)->idb_magic = RT_DB_INTERNAL_MAGIC; \
	(_p)->idb_type = -1; (_p)->idb_ptr = GENPTR_NULL;\
	(_p)->idb_avs.magic = -1;}
#define RT_CK_DB_INTERNAL(_p)	BU_CKMAG(_p, RT_DB_INTERNAL_MAGIC, "rt_db_internal")

/*
 *			D B _ F U L L _ P A T H
 *
 *  For collecting paths through the database tree
 */
struct db_full_path {
	long		magic;
	int		fp_len;
	int		fp_maxlen;
	struct directory **fp_names;	/* array of dir pointers */
};
#define DB_FULL_PATH_POP(_pp)	{(_pp)->fp_len--;}
#define DB_FULL_PATH_CUR_DIR(_pp)	((_pp)->fp_names[(_pp)->fp_len-1])
#define DB_FULL_PATH_GET(_pp,_i)	((_pp)->fp_names[(_i)])
#define DB_FULL_PATH_MAGIC	0x64626670
#define RT_CK_FULL_PATH(_p)	BU_CKMAG(_p, DB_FULL_PATH_MAGIC, "db_full_path")

/*
 *			X R A Y
 *
 * All necessary information about a ray.
 * Not called just "ray" to prevent conflicts with VLD stuff.
 */
struct xray {
	long		magic;
	int		index;		/* Which ray of a bundle */
	point_t		r_pt;		/* Point at which ray starts */
	vect_t		r_dir;		/* Direction of ray (UNIT Length) */
	fastf_t		r_min;		/* entry dist to bounding sphere */
	fastf_t		r_max;		/* exit dist from bounding sphere */
};
#define RAY_NULL	((struct xray *)0)
#define RT_RAY_MAGIC	0x78726179	/* "xray" */
#define RT_CK_RAY(_p)	BU_CKMAG(_p,RT_RAY_MAGIC,"struct xray");

/*
 *			H I T
 *
 *  Information about where a ray hits the surface
 *
 * Important Note:  Surface Normals always point OUT of a solid.
 *
 *  Statement of intent:
 *	The hit_point and hit_normal elements will be removed from this
 *	structure, so as to separate the concept of the solid's normal
 *	at the hit point from the post-boolean normal at the hit point.
 */
struct hit {
	long		hit_magic;
	fastf_t		hit_dist;	/* dist from r_pt to hit_point */
	point_t		hit_point;	/* Intersection point */
	vect_t		hit_normal;	/* Surface Normal at hit_point */
	vect_t		hit_vpriv;	/* PRIVATE vector for xxx_*() */
	genptr_t	hit_private;	/* PRIVATE handle for xxx_shot() */
	int		hit_surfno;	/* solid-specific surface indicator */
	struct xray	*hit_rayp;	/* pointer to defining ray */
};
#define HIT_NULL	((struct hit *)0)
#define RT_HIT_MAGIC	0x20686974	/* " hit" */
#define RT_CK_HIT(_p)	BU_CKMAG(_p,RT_HIT_MAGIC,"struct hit")

/*
 * Old macro:
 *  Only the hit_dist field of pt_inhit and pt_outhit are valid
 *  when a_hit() is called;  to compute both hit_point and hit_normal,
 *  use RT_HIT_NORM() macro;  to compute just hit_point, use
 *  VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
 */
#define RT_HIT_NORM( _hitp, _stp, _unused )  { \
	RT_CK_HIT(_hitp); \
	RT_CK_SOLTAB(_stp); \
	(_stp)->st_meth->ft_norm(_hitp, _stp, (_hitp)->hit_rayp); }

/*
 *  New macro:  Compute normal into (_hitp)->hit_normal, but leave
 *  it un-flipped, as one hit may be shared between multiple partitions
 *  with different flip status.
 *  (Example:  box.r = box.s - sph.s; sph.r = sph.s)
 *  Return the post-boolean normal into caller-provided _normal vector.
 */
#define RT_HIT_NORMAL( _normal, _hitp, _stp, _unused, _flipflag )  { \
	RT_CK_HIT(_hitp); \
	RT_CK_SOLTAB(_stp); \
	RT_CK_FUNCTAB((_stp)->st_meth); \
	(_stp)->st_meth->ft_norm(_hitp, _stp, (_hitp)->hit_rayp); \
	if( _flipflag )  { \
		VREVERSE( _normal, (_hitp)->hit_normal ); \
	} else { \
		VMOVE( _normal, (_hitp)->hit_normal ); \
	} \
 }

/* A more powerful interface would be: */
/* RT_GET_NORMAL( _normal, _partition, inhit/outhit flag, ap ) */



/*
 *			C U R V A T U R E
 *
 *  Information about curvature of the surface at a hit point.
 *  The principal direction pdir has unit length and principal curvature c1.
 *  |c1| <= |c2|, i.e. c1 is the most nearly flat principle curvature.
 *  A POSITIVE curvature indicates that the surface bends TOWARD the
 *  (outward pointing) normal vector at that point.
 *  c1 and c2 are the inverse radii of curvature.
 *  The other principle direction is implied: pdir2 = normal x pdir1.
 */
struct curvature {
	vect_t		crv_pdir;	/* Principle direction */
	fastf_t		crv_c1;		/* curvature in principle dir */
	fastf_t		crv_c2;		/* curvature in other direction */
};
#define CURVE_NULL	((struct curvature *)0)

/*
 *  Use this macro after having computed the normal, to
 *  compute the curvature at a hit point.
 *
 *  In Release 4.4 and earlier, this was called RT_CURVE().
 *  When the extra argument was added the name was changed.
 */
#define RT_CURVATURE( _curvp, _hitp, _flipflag, _stp )  { \
	RT_CK_HIT(_hitp); \
	RT_CK_SOLTAB(_stp); \
	RT_CK_FUNCTAB((_stp)->st_meth); \
	(_stp)->st_meth->ft_curve( _curvp, _hitp, _stp ); \
	if( _flipflag )  { \
		(_curvp)->crv_c1 = - (_curvp)->crv_c1; \
		(_curvp)->crv_c2 = - (_curvp)->crv_c2; \
	} \
 }

/* A more powerful interface would be: */
/* RT_GET_CURVATURE(_curvp, _partition, inhit/outhit flag, ap) */

/*
 *			U V C O O R D
 *
 *  Mostly for texture mapping, information about parametric space.
 */
struct uvcoord {
	fastf_t		uv_u;		/* Range 0..1 */
	fastf_t		uv_v;		/* Range 0..1 */
	fastf_t		uv_du;		/* delta in u */
	fastf_t		uv_dv;		/* delta in v */
};
#define RT_HIT_UVCOORD( ap, _stp, _hitp, uvp )  { \
	RT_CK_HIT(_hitp); \
	RT_CK_SOLTAB(_stp); \
	RT_CK_FUNCTAB((_stp)->st_meth); \
	(_stp)->st_meth->ft_uv( ap, _stp, _hitp, uvp ); }

/* A more powerful interface would be: */
/* RT_GET_UVCOORD(_uvp, _partition, inhit/outhit flag, ap) */


/*
 *			S E G
 *
 * Intersection segment.
 *
 * Includes information about both endpoints of intersection.
 * Contains forward link to additional intersection segments
 * if the intersection spans multiple segments (eg, shooting
 * a ray through a torus).
 */
struct seg {
	struct bu_list	l;
	struct hit	seg_in;		/* IN information */
	struct hit	seg_out;	/* OUT information */
	struct soltab	*seg_stp;	/* pointer back to soltab */
};
#define RT_SEG_NULL	((struct seg *)0)
#define RT_SEG_MAGIC	0x98bcdef1

#define RT_CHECK_SEG(_p)	BU_CKMAG(_p, RT_SEG_MAGIC, "struct seg")
#define RT_CK_SEG(_p)		BU_CKMAG(_p, RT_SEG_MAGIC, "struct seg")

#define RT_GET_SEG(p,res)    { \
	while( !BU_LIST_WHILE((p),seg,&((res)->re_seg)) || !(p) ) \
		rt_get_seg(res); \
	BU_LIST_DEQUEUE( &((p)->l) ); \
	(p)->l.forw = (p)->l.back = BU_LIST_NULL; \
	(p)->seg_in.hit_magic = (p)->seg_out.hit_magic = RT_HIT_MAGIC; \
	res->re_segget++; }

#define RT_FREE_SEG(p,res)  { \
	RT_CHECK_SEG(p); \
	BU_LIST_INSERT( &((res)->re_seg), &((p)->l) ); \
	res->re_segfree++; }

/*  This could be
 *	BU_LIST_INSERT_LIST( &((_res)->re_seg), &((_segheadp)->l) )
 *  except for security of checking & counting each element this way.
 */
#define RT_FREE_SEG_LIST( _segheadp, _res )	{ \
	register struct seg *_a; \
	while( BU_LIST_WHILE( _a, seg, &((_segheadp)->l) ) )  { \
		BU_LIST_DEQUEUE( &(_a->l) ); \
		RT_FREE_SEG( _a, _res ); \
	} }

/*
 *  Macros to operate on Right Rectangular Parallelpipeds (RPPs).
 * XXX move to vmath.h?
 */
struct bound_rpp {
	point_t	min;
	point_t max;
};

#if 0
/*
 *  Compare two bounding RPPs;  return true if disjoint.
 */
#define RT_2RPP_DISJOINT(_l1, _h1, _l2, _h2) \
	V3RPP_DISJOINT(_l1, _h1, _l2, _h2)

/* Test for point being inside or on an RPP */
#define RT_POINT_IN_RPP(_pt, _min, _max)	\
	V3PT_IN_RPP(_pt, _min, _max)
#endif

/*
 *			S O L T A B
 *
 * Internal information used to keep track of solids in the model
 * Leaf name and Xform matrix are unique identifier.
 */
struct soltab {
	struct bu_list	l;		/* links, headed by rti_headsolid */
	struct bu_list	l2;		/* links, headed by st_dp->d_use_hd */
	const struct rt_functab *st_meth; /* pointer to per-solid methods */
	struct rt_i	*st_rtip;	/* "up" pointer to rt_i */
	long		st_uses;	/* Usage count, for instanced solids */
	int		st_id;		/* Solid ident */
	point_t		st_center;	/* Centroid of solid */
	fastf_t		st_aradius;	/* Radius of APPROXIMATING sphere */
	fastf_t		st_bradius;	/* Radius of BOUNDING sphere */
	genptr_t	st_specific;	/* -> ID-specific (private) struct */
	const struct directory *st_dp;	/* Directory entry of solid */
	point_t		st_min;		/* min X, Y, Z of bounding RPP */
	point_t		st_max;		/* max X, Y, Z of bounding RPP */
	long		st_bit;		/* solids bit vector index (const) */
	struct bu_ptbl	st_regions;	/* ptrs to regions using this solid (const) */
	matp_t		st_matp;	/* solid coords to model space, NULL=identity */
	struct db_full_path st_path;	/* path from region to leaf */
	/* Experimental stuff for accelerating "pieces" of solids */
	long		st_npieces;	/* # pieces used by this solid */
	long		st_piecestate_num; /* re_pieces[] subscript */
	struct bound_rpp *st_piece_rpps;/* bounding RPP of each piece of this solid */
};
#define st_name		st_dp->d_namep
#define RT_SOLTAB_NULL	((struct soltab *)0)
#define	SOLTAB_NULL	RT_SOLTAB_NULL	/* backwards compat */
#define RT_SOLTAB_MAGIC		0x92bfcde0	/* l.magic */
#define RT_SOLTAB2_MAGIC	0x92bfcde2	/* l2.magic */

#define RT_CHECK_SOLTAB(_p)	BU_CKMAG( _p, RT_SOLTAB_MAGIC, "struct soltab")
#define RT_CK_SOLTAB(_p)	BU_CKMAG( _p, RT_SOLTAB_MAGIC, "struct soltab")

/*
 *  Values for Solid ID.
 */
#define ID_NULL		0	/* Unused */
#define ID_TOR		1	/* Toroid */
#define ID_TGC		2	/* Generalized Truncated General Cone */
#define ID_ELL		3	/* Ellipsoid */
#define ID_ARB8		4	/* Generalized ARB.  V + 7 vectors */
#define ID_ARS		5	/* ARS */
#define ID_HALF		6	/* Half-space */
#define ID_REC		7	/* Right Elliptical Cylinder [TGC special] */
#define ID_POLY		8	/* Polygonal facted object */
#define ID_BSPLINE	9	/* B-spline object */
#define ID_SPH		10	/* Sphere */
#define	ID_NMG		11	/* n-Manifold Geometry solid */
#define ID_EBM		12	/* Extruded bitmap solid */
#define ID_VOL		13	/* 3-D Volume */
#define ID_ARBN		14	/* ARB with N faces */
#define ID_PIPE		15	/* Pipe (wire) solid */
#define ID_PARTICLE	16	/* Particle system solid */
#define ID_RPC		17	/* Right Parabolic Cylinder  */
#define ID_RHC		18	/* Right Hyperbolic Cylinder  */
#define ID_EPA		19	/* Elliptical Paraboloid  */
#define ID_EHY		20	/* Elliptical Hyperboloid  */
#define ID_ETO		21	/* Elliptical Torus  */
#define ID_GRIP		22	/* Pseudo Solid Grip */
#define ID_JOINT	23	/* Pseudo Solid/Region Joint */
#define ID_HF		24	/* Height Field */
#define ID_DSP		25	/* Displacement map */
#define	ID_SKETCH	26	/* 2D sketch */
#define	ID_EXTRUDE	27	/* Solid of extrusion */
#define ID_SUBMODEL	28	/* Instanced submodel */
#define	ID_CLINE	29	/* FASTGEN4 CLINE solid */
#define	ID_BOT		30	/* Bag o' triangles */

  /* Add a new primitive id above here (this is will break v5 format)
   * XXX must update the non-geometric object id's below XXX 
   */
#define	ID_MAX_SOLID	36	/* Maximum defined ID_xxx for solids */

/*
 *	Non-geometric objects
 */
#define ID_COMBINATION	31	/* Combination Record */
#define ID_BINEXPM	32	/* Experimental binary */
#define ID_BINUNIF	33	/* Uniform-array binary */
#define ID_BINMIME	34	/* MIME-typed binary */

/* XXX - superellipsoid should be 31, but is not v5 compatible */
#define ID_SUPERELL	35	/* Superquadratic ellipsoid */

#define ID_MAXIMUM	36	/* Maximum defined ID_xxx value */

/*
 *			M A T E R _ I N F O
 */
struct mater_info {
	float	ma_color[3];		/* explicit color:  0..1  */
	float	ma_temperature;		/* positive ==> degrees Kelvin */
	char	ma_color_valid;		/* non-0 ==> ma_color is non-default */
	char	ma_cinherit;		/* color: DB_INH_LOWER / DB_INH_HIGHER */
	char	ma_minherit;		/* mater: DB_INH_LOWER / DB_INH_HIGHER */
	char	*ma_shader;		/* shader name & parms */
};

/*
 *			R E G I O N
 *
 *  The region structure.
 */
struct region  {
	struct bu_list	l;		/* magic # and doubly linked list */
	const char	*reg_name;	/* Identifying string */
	union tree	*reg_treetop;	/* Pointer to boolean tree */
	int		reg_bit;	/* constant index into Regions[] */
	int		reg_regionid;	/* Region ID code.  If <=0, use reg_aircode */
	int		reg_aircode;	/* Region ID AIR code */
	int		reg_gmater;	/* GIFT Material code */
	int		reg_los;	/* equivalent LOS estimate ?? */
	struct mater_info reg_mater;	/* Real material information */
	genptr_t	reg_mfuncs;	/* User appl. funcs for material */
	genptr_t	reg_udata;	/* User appl. data for material */
	int		reg_transmit;	/* flag:  material transmits light */
	long		reg_instnum;	/* instance number, from d_uses */
	short		reg_all_unions;	/* 1=boolean tree is all unions */
	short		reg_is_fastgen;	/* FASTGEN-compatability mode? */
#define REGION_NON_FASTGEN	0
#define REGION_FASTGEN_PLATE	1
#define REGION_FASTGEN_VOLUME	2
	struct bu_mro	**attr_values;	/* Null terminated array of MRO structs
					 * Each containing a value for the corresponding
					 * attribute name passed to rt_gettrees_and_attrs() */
};
#define REGION_NULL	((struct region *)0)
#define RT_REGION_MAGIC	0xdffb8001
#define RT_CK_REGION(_p)	BU_CKMAG(_p,RT_REGION_MAGIC,"struct region")

/*
 *  			P A R T I T I O N
 *
 *  Partitions of a ray.  Passed from rt_shootray() into user's
 *  a_hit() function.
 *
 *  Not changed to a bu_list for backwards compatability, but
 *  you can iterate the whole list by writing:
 *	for( BU_LIST_FOR( pp, partition, (struct bu_list *)PartHeadp ) )
 */

struct partition {
	/* This can be thought of and operated on as a struct bu_list */
	long		pt_magic;		/* sanity check */
	struct partition *pt_forw;		/* forwards link */
	struct partition *pt_back;		/* backwards link */
	struct seg	*pt_inseg;		/* IN seg ptr (gives stp) */
	struct hit	*pt_inhit;		/* IN hit pointer */
	struct seg	*pt_outseg;		/* OUT seg pointer */
	struct hit	*pt_outhit;		/* OUT hit ptr */
	struct region	*pt_regionp;		/* ptr to containing region */
	char		pt_inflip;		/* flip inhit->hit_normal */
	char		pt_outflip;		/* flip outhit->hit_normal */
	struct region	**pt_overlap_reg;	/* NULL-terminated array of overlapping regions.  NULL if no overlap. */
	struct bu_ptbl	pt_seglist;		/* all segs in this partition */
};
#define PT_NULL		((struct partition *)0)
#define PT_MAGIC	0x87687681
#define PT_HD_MAGIC	0x87687680

#define RT_CHECK_PT(_p)	RT_CK_PT(_p)	/* compat */
#define RT_CK_PT(_p)	BU_CKMAG(_p,PT_MAGIC, "struct partition")
#define RT_CK_PARTITION(_p)	BU_CKMAG(_p,PT_MAGIC, "struct partition")
#define RT_CK_PT_HD(_p)	BU_CKMAG(_p,PT_HD_MAGIC, "struct partition list head")

/* Macros for copying only the essential "middle" part of a partition struct */
#define RT_PT_MIDDLE_START	pt_inseg		/* 1st elem to copy */
#define RT_PT_MIDDLE_END	pt_seglist.l.magic	/* copy up to this elem (non-inclusive) */
#define RT_PT_MIDDLE_LEN(p) \
	(((char *)&(p)->RT_PT_MIDDLE_END) - ((char *)&(p)->RT_PT_MIDDLE_START))

#define RT_DUP_PT(ip,new,old,res)	{ \
	GET_PT(ip,new,res); \
	memcpy((char *)(&(new)->RT_PT_MIDDLE_START), (char *)(&(old)->RT_PT_MIDDLE_START), RT_PT_MIDDLE_LEN(old) ); \
	(new)->pt_overlap_reg = NULL; \
	bu_ptbl_cat( &(new)->pt_seglist, &(old)->pt_seglist );  }

/* Clear out the pointers, empty the hit list */
#define GET_PT_INIT(ip,p,res)	{\
	GET_PT(ip,p,res); \
	memset( ((char *) &(p)->RT_PT_MIDDLE_START), 0, RT_PT_MIDDLE_LEN(p) ); }

#define GET_PT(ip,p,res)   { \
	if( BU_LIST_NON_EMPTY_P(p, partition, &res->re_parthead) )  { \
		BU_LIST_DEQUEUE((struct bu_list *)(p)); \
		bu_ptbl_reset( &(p)->pt_seglist ); \
	} else { \
		(p) = (struct partition *)bu_malloc(sizeof(struct partition), "struct partition"); \
		(p)->pt_magic = PT_MAGIC; \
		bu_ptbl_init( &(p)->pt_seglist, 42, "pt_seglist ptbl" ); \
		(res)->re_partlen++; \
	} \
	res->re_partget++; }

#define FREE_PT(p,res)  { \
	BU_LIST_APPEND( &(res->re_parthead), (struct bu_list *)(p) ); \
	if( (p)->pt_overlap_reg )  { \
		bu_free( (genptr_t)((p)->pt_overlap_reg), "pt_overlap_reg" );\
		(p)->pt_overlap_reg = NULL; \
	} \
	res->re_partfree++; }

#define RT_FREE_PT_LIST( _headp, _res )		{ \
		register struct partition *_pp, *_zap; \
		for( _pp = (_headp)->pt_forw; _pp != (_headp);  )  { \
			_zap = _pp; \
			_pp = _pp->pt_forw; \
			BU_LIST_DEQUEUE( (struct bu_list *)(_zap) ); \
			FREE_PT(_zap, _res); \
		} \
		(_headp)->pt_forw = (_headp)->pt_back = (_headp); \
	}

/* Insert "new" partition in front of "old" partition.  Note order change */
#define INSERT_PT(_new,_old)	BU_LIST_INSERT((struct bu_list *)_old,(struct bu_list *)_new)

/* Append "new" partition after "old" partition.  Note arg order change */
#define APPEND_PT(_new,_old)	BU_LIST_APPEND((struct bu_list *)_old,(struct bu_list *)_new)

/* Dequeue "cur" partition from doubly-linked list */
#define DEQUEUE_PT(_cur)	BU_LIST_DEQUEUE((struct bu_list *)_cur)

/*
 *			C U T
 *
 *  Structure for space subdivision.
 *
 *  cut_type is an integer for efficiency of access in rt_shootray()
 *  on non-word addressing machines.
 *
 *  If a solid has 'pieces', it will be listed either in bn_list (initially),
 *  or in bn_piecelist, but not both.
 */
union cutter  {
#define CUT_CUTNODE	1
#define CUT_BOXNODE	2
#define CUT_NUGRIDNODE	3
#define	CUT_MAXIMUM	3	
	int	cut_type;
	union cutter *cut_forw;		/* Freelist forward link */
	struct cutnode  {
		int	cn_type;
		int	cn_axis;	/* 0,1,2 = cut along X,Y,Z */
		fastf_t	cn_point;	/* cut through axis==point */
		union cutter *cn_l;	/* val < point */
		union cutter *cn_r;	/* val >= point */
	} cn;
	struct boxnode  {
		int	bn_type;
		fastf_t	bn_min[3];
		fastf_t	bn_max[3];
		struct soltab **bn_list; /* bn_list[bn_len] */
		int	bn_len;		/* # of solids in list */
		int	bn_maxlen;	/* # of ptrs allocated to list */
		struct rt_piecelist *bn_piecelist; /* [] solids with pieces */
		int	bn_piecelen;	/* # of piecelists used */
		int	bn_maxpiecelen; /* # of piecelists allocated */
	} bn;
	struct nugridnode {
		int	nu_type;
		struct nu_axis {
			fastf_t nu_spos;	/* cell start position */
			fastf_t	nu_epos;	/* cell end position */
			fastf_t	nu_width;	/* voxel size (end - start) */
		} *nu_axis[3];
		int	 nu_cells_per_axis[3]; /* number of slabs */
		int	 nu_stepsize[3];       /* number of cells to jump for one step in each axis */
		union cutter	*nu_grid;	 /* 3-D array of boxnodes */
	} nugn;
};

#define CUTTER_NULL	((union cutter *)0)

/*
 *			M E M _ M A P
 *
 *  These structures are used to manage internal resource maps.
 *  Typically these maps describe some kind of memory or file space.
 */
struct mem_map {
	struct mem_map	*m_nxtp;	/* Linking pointer to next element */
	unsigned	 m_size;	/* Size of this free element */
	unsigned long	 m_addr;	/* Address of start of this element */
};
#define MAP_NULL	((struct mem_map *) 0)


/*
 *  The directory is organized as forward linked lists hanging off of
 *  one of RT_DBNHASH headers in the db_i structure.
 */
#define	RT_DBNHASH		1024	/* size of hash table */

#if	((RT_DBNHASH)&((RT_DBNHASH)-1)) != 0
#define	RT_DBHASH(sum)	((unsigned)(sum) % (RT_DBNHASH))
#else
#define	RT_DBHASH(sum)	((unsigned)(sum) & ((RT_DBNHASH)-1))
#endif

/*
 *			D B _ I
 *
 *  One of these structures is used to describe each separate instance
 *  of a BRL-CAD model database ".g" file.
 *
 *  dbi_filepath is a C-style argv array of places to search when
 *  opening related files (such as data files for EBM solids or
 *  texture-maps).  The array and strings are all dynamically allocated.
 */
struct db_i  {
	long			dbi_magic;	/* magic number */
	/* THESE ELEMENTS ARE AVAILABLE FOR APPLICATIONS TO READ */
	char			*dbi_filename;	/* file name */
	int			dbi_read_only;	/* !0 => read only file */
	double			dbi_local2base;	/* local2mm */
	double			dbi_base2local;	/* unit conversion factors */
	char			*dbi_title;	/* title from IDENT rec */
	char			*const*dbi_filepath; /* search path for aux file opens (convenience var) */
	/* THESE ELEMENTS ARE FOR LIBRT ONLY, AND MAY CHANGE */
	struct directory	*dbi_Head[RT_DBNHASH];
	int			dbi_fd;		/* UNIX file descriptor */
	FILE			*dbi_fp;	/* STDIO file descriptor */
	long			dbi_eof;	/* End+1 pos after db_scan() */
	long			dbi_nrec;	/* # records after db_scan() */
	int			dbi_uses;	/* # of uses of this struct */
	struct mem_map		*dbi_freep;	/* map of free granules */
	genptr_t		dbi_inmem;	/* ptr to in-memory copy */
	struct animate		*dbi_anroot;	/* heads list of anim at root lvl */
	struct bu_mapped_file	*dbi_mf;	/* Only in read-only mode */
	struct bu_ptbl		dbi_clients;	/* List of rtip's using this db_i */
	int			dbi_version;	/* 4 or 5 */
	struct rt_wdb		*dbi_wdbp;	/* ptr back to containing rt_wdb */
};
#define DBI_NULL	((struct db_i *)0)
#define DBI_MAGIC	0x57204381

#define RT_CHECK_DBI(_p)		BU_CKMAG(_p,DBI_MAGIC,"struct db_i")
#define RT_CHECK_DBI_TCL(_interp,_p)	BU_CKMAG_TCL(_interp,_p,DBI_MAGIC,"struct db_i")
#define RT_CK_DBI(_p)			RT_CHECK_DBI(_p)
#define RT_CK_DBI_TCL(_interp,_p)	RT_CHECK_DBI_TCL(_interp,_p)

/*
 *			D I R E C T O R Y
 *
 *  One of these structures is allocated in memory to represent each
 *  named object in the database.
 *
 *  Note that a d_addr of RT_DIR_PHONY_ADDR (-1L) means that database
 *  storage has not been allocated yet.
 *
 *  Note that there is special handling for RT_DIR_INMEM "in memory" overrides.
 *
 *  Construction should be done only by using RT_GET_DIRECTORY()
 *  Destruction should be done only by using db_dirdelete().
 *
 *  Special note:  In order to reduce the overhead of calling bu_malloc()
 *  (really bu_strdup()) to stash the name in d_namep, we carry along
 *  enough storage for small names right in the structure itself (d_shortname).
 *  Thus, d_namep should never be assigned to directly, it should always
 *  be accessed using RT_DIR_SET_NAMEP() and RT_DIR_FREE_NAMEP().
 *
 *  The in-memory name of an object should only be changed using db_rename(),
 *  so that it can be requeued on the correct linked list, based on new hash.
 *  This should be followed by rt_db_put_internal() on the object to
 *  modify the on-disk name.
 */
struct directory  {
	long		d_magic;		/* Magic number */
	char		*d_namep;		/* pointer to name string */
	union {
		long	file_offset;		/* disk address in obj file */
		genptr_t ptr;			/* ptr to in-memory-only obj */
	} d_un;
	struct directory *d_forw;		/* link to next dir entry */
	struct animate	*d_animate;		/* link to animation */
	long		d_uses;			/* # uses, from instancing */
	long		d_len;			/* # of db granules used */
	long		d_nref;			/* # times ref'ed by COMBs */
	int		d_flags;		/* flags */
	unsigned char	d_major_type;		/* object major type */
	unsigned char 	d_minor_type;		/* object minor type */
	struct bu_list	d_use_hd;		/* heads list of uses (struct soltab l2) */
	char		d_shortname[16];	/* Stash short names locally */
};
#define DIR_NULL	((struct directory *)0)
#define RT_DIR_MAGIC	0x05551212		/* Directory assistance */
#define RT_CK_DIR(_dp)	BU_CKMAG(_dp, RT_DIR_MAGIC, "(librt)directory")

#define d_addr	d_un.file_offset
#define RT_DIR_PHONY_ADDR	(-1L)	/* Special marker for d_addr field */

#define DIR_SOLID	0x1		/* this name is a solid */
#define DIR_COMB	0x2		/* combination */
#define DIR_REGION	0x4		/* region */
#define DIR_HIDDEN	0x8		/* object name is hidden */
#define	DIR_NON_GEOM	0x10		/* object is not geometry (e.g. binary object) */
#define DIR_USED	0x80		/* One bit, used similar to d_nref */
#define RT_DIR_INMEM	0x100		/* object is in memory (only) */

/* Args to db_lookup() */
#define LOOKUP_NOISY	1
#define LOOKUP_QUIET	0

#define FOR_ALL_DIRECTORY_START(_dp,_dbip)	{ int _i; \
	for( _i = RT_DBNHASH-1; _i >= 0; _i-- )  { \
		for( (_dp) = (_dbip)->dbi_Head[_i]; (_dp); (_dp) = (_dp)->d_forw )  {

#define FOR_ALL_DIRECTORY_END	}}}

#define RT_DIR_SET_NAMEP(_dp,_name)	{ \
	if( strlen(_name) < sizeof((_dp)->d_shortname) )  {\
		strncpy( (_dp)->d_shortname, (_name), sizeof((_dp)->d_shortname) ); \
		(_dp)->d_namep = (_dp)->d_shortname; \
	} else { \
		(_dp)->d_namep = bu_strdup(_name); /* Calls bu_malloc() */ \
	} }

/* Use this macro to free the d_namep member, which is sometimes not dynamic. */
#define RT_DIR_FREE_NAMEP(_dp)	{ \
	if( (_dp)->d_namep != (_dp)->d_shortname )  \
		bu_free((_dp)->d_namep, "d_namep"); \
	(_dp)->d_namep = NULL; }

#if 1
/* The efficient way */
#define RT_GET_DIRECTORY(_p,_res)    { \
	while( ((_p) = (_res)->re_directory_hd) == NULL ) \
		db_get_directory(_res); \
	(_res)->re_directory_hd = (_p)->d_forw; \
	(_p)->d_forw = NULL; }
#else
/* XXX Conservative, for testing parallel problems with Ft. AP Hill */
#define RT_GET_DIRECTORY(_p,_res)    {BU_GETSTRUCT(_p, directory); \
	(_p)->d_magic = RT_DIR_MAGIC; \
	BU_LIST_INIT( &((_p)->d_use_hd) ); }
#endif

	

/*
 *			R T _ C O M B _ I N T E R N A L
 *
 *  In-memory format for database "combination" record (non-leaf node).
 *  (Regions and Groups are both a kind of Combination).
 *  Perhaps move to h/wdb.h or h/rtgeom.h?
 */
struct rt_comb_internal  {
	long		magic;
	union tree	*tree;		/* Leading to tree_db_leaf leaves */
	char		region_flag;	/* !0 ==> this COMB is a REGION */
	char		is_fastgen;	/* REGION_NON_FASTGEN/_PLATE/_VOLUME */
	/* Begin GIFT compatability */
	short		region_id;
	short		aircode;
	short		GIFTmater;
	short		los;
	/* End GIFT compatability */
	char		rgb_valid;	/* !0 ==> rgb[] has valid color */
	unsigned char	rgb[3];
	float		temperature;	/* > 0 ==> region temperature */
	struct bu_vls	shader;
	struct bu_vls	material;
	char		inherit;
};
#define RT_COMB_MAGIC	0x436f6d49	/* "ComI" */
#define RT_CHECK_COMB(_p)		BU_CKMAG( _p , RT_COMB_MAGIC , "rt_comb_internal" )
#define RT_CK_COMB(_p)			RT_CHECK_COMB(_p)
#define RT_CHECK_COMB_TCL(_interp,_p)	BU_CKMAG_TCL(interp,_p,RT_COMB_MAGIC, "rt_comb_internal" )
#define RT_CK_COMB_TCL(_interp,_p)	RT_CHECK_COMB_TCL(_interp,_p)

/*
 *			R T _ B I N U N I F _ I N T E R N A L
 *
 *  In-memory format for database uniform-array binary object.
 *  Perhaps move to h/wdb.h or h/rtgeom.h?
 */
struct rt_binunif_internal {
	long		magic;
	int		type;
	long		count;
	union		{
			    float		*flt;
			    double		*dbl;
			    char		*int8;
			    short		*int16;
			    int			*int32;
			    long		*int64;
			    unsigned char	*uint8;
			    unsigned short	*uint16;
			    unsigned int	*uint32;
			    unsigned long	*uint64;
	}		u;
};
#define RT_BINUNIF_INTERNAL_MAGIC	0x42696e55	/* "BinU" */
#define RT_CHECK_BINUNIF(_p)		BU_CKMAG( _p , RT_BINUNIF_INTERNAL_MAGIC , "rt_binunif_internal" )
#define RT_CK_BINUNIF(_p)		RT_CHECK_BINUNIF(_p)
#define RT_CHECK_BINUNIF_TCL(_interp,_p)	BU_CKMAG_TCL(interp,_p,RT_BINUNIF_MAGIC, "rt_binunif_internal" )
#define RT_CK_BINUNIF_TCL(_interp,_p)	RT_CHECK_BINUNIF_TCL(_interp,_p)

/*
 *			D B _ T R E E _ S T A T E
 *
 *  State for database tree walker db_walk_tree()
 *  and related user-provided handler routines.
 */
struct db_tree_state {
	long		magic;
	struct db_i	*ts_dbip;
	int		ts_sofar;		/* Flag bits */

	int		ts_regionid;	/* GIFT compat region ID code*/
	int		ts_aircode;	/* GIFT compat air code */
	int		ts_gmater;	/* GIFT compat material code */
	int		ts_los;		/* equivalent LOS estimate .. */
	struct mater_info ts_mater;	/* material properties */

			/* XXX ts_mat should be a matrix pointer, not a matrix */
	mat_t		ts_mat;		/* transform matrix */
	int		ts_is_fastgen;	/* REGION_NON_FASTGEN/_PLATE/_VOLUME */
	struct bu_attribute_value_set	ts_attrs;	/* attribute/value structure */

	int		ts_stop_at_regions;	/* else stop at solids */
	int		(*ts_region_start_func) BU_ARGS((
				struct db_tree_state * /*tsp*/,
				struct db_full_path * /*pathp*/,
				const struct rt_comb_internal * /* combp */,
				genptr_t client_data
			));
	union tree *	(*ts_region_end_func) BU_ARGS((
				struct db_tree_state * /*tsp*/,
				struct db_full_path * /*pathp*/,
				union tree * /*curtree*/,
				genptr_t client_data
			));
	union tree *	(*ts_leaf_func) BU_ARGS((
				struct db_tree_state * /*tsp*/,
				struct db_full_path * /*pathp*/,
				struct rt_db_internal * /*ip*/,
				genptr_t client_data
			));
	const struct rt_tess_tol *ts_ttol;	/* Tessellation tolerance */
	const struct bn_tol	*ts_tol;	/* Math tolerance */
#if defined(NMG_H)
	struct model		**ts_m;		/* ptr to ptr to NMG "model" */
#else
	genptr_t		*ts_m;		/* ptr to genptr */
#endif
	struct rt_i		*ts_rtip;	/* Helper for rt_gettrees() */
	struct resource		*ts_resp;	/* Per-CPU data */
};
#define TS_SOFAR_MINUS	1		/* Subtraction encountered above */
#define TS_SOFAR_INTER	2		/* Intersection encountered above */
#define TS_SOFAR_REGION	4		/* Region encountered above */

#define RT_DBTS_MAGIC	0x64627473	/* "dbts" */
#define RT_CK_DBTS(_p)	BU_CKMAG(_p, RT_DBTS_MAGIC, "db_tree_state")

/*
 *			C O M B I N E D _ T R E E _ S T A T E
 */
struct combined_tree_state {
	long			magic;
	struct db_tree_state	cts_s;
	struct db_full_path	cts_p;
};
#define RT_CTS_MAGIC	0x98989123
#define RT_CK_CTS(_p)	BU_CKMAG(_p, RT_CTS_MAGIC, "combined_tree_state")

/*
 *			T R E E
 *
 *  Binary trees representing the Boolean operations between solids.
 */
#define MKOP(x)		(x)

#define OP_SOLID	MKOP(1)		/* Leaf:  tr_stp -> solid */
#define OP_UNION	MKOP(2)		/* Binary: L union R */
#define OP_INTERSECT	MKOP(3)		/* Binary: L intersect R */
#define OP_SUBTRACT	MKOP(4)		/* Binary: L subtract R */
#define OP_XOR		MKOP(5)		/* Binary: L xor R, not both*/
#define OP_REGION	MKOP(6)		/* Leaf: tr_stp -> combined_tree_state */
#define OP_NOP		MKOP(7)		/* Leaf with no effect */
/* Internal to library routines */
#define OP_NOT		MKOP(8)		/* Unary:  not L */
#define OP_GUARD	MKOP(9)		/* Unary:  not L, or else! */
#define OP_XNOP		MKOP(10)	/* Unary:  L, mark region */
#define OP_NMG_TESS	MKOP(11)	/* Leaf: tr_stp -> nmgregion */
/* LIBWDB import/export interface to combinations */
#define OP_DB_LEAF	MKOP(12)	/* Leaf of combination, db fmt */
#define OP_FREE		MKOP(13)	/* Unary:  L has free chain */

union tree {
	long	magic;				/* First word: magic number */
	/* Second word is always OP code */
	struct tree_node {
		long		magic;
		int		tb_op;		/* non-leaf */
		struct region	*tb_regionp;	/* ptr to containing region */
		union tree	*tb_left;
		union tree	*tb_right;
	} tr_b;
	struct tree_leaf {
		long		magic;
		int		tu_op;		/* leaf, OP_SOLID */
		struct region	*tu_regionp;	/* ptr to containing region */
		struct soltab	*tu_stp;
	} tr_a;
	struct tree_cts {
		long		magic;
		int		tc_op;		/* leaf, OP_REGION */
		struct region	*tc_pad;	/* unused */
		struct combined_tree_state	*tc_ctsp;
	} tr_c;
	struct tree_nmgregion {
		long		magic;
		int		td_op;		/* leaf, OP_NMG_TESS */
		const char	*td_name;	/* If non-null, dynamic string describing heritage of this region */
#if defined(NMG_H)
		struct nmgregion *td_r;		/* ptr to NMG region */
#else
		genptr_t	td_r;
#endif
	} tr_d;
	struct tree_db_leaf  {
		long		magic;
		int		tl_op;		/* leaf, OP_DB_LEAF */
		matp_t		tl_mat;		/* xform matp, NULL ==> identity */
		char		*tl_name;	/* Name of this leaf (bu_strdup'ed) */
	} tr_l;
};
/* Things which are in the same place in both A & B structures */
#define tr_op		tr_a.tu_op
#define tr_regionp	tr_a.tu_regionp

#define TREE_NULL	((union tree *)0)
#define RT_TREE_MAGIC	0x91191191
#define RT_CK_TREE(_p)	BU_CKMAG(_p, RT_TREE_MAGIC, "union tree")


/*		R T _ T R E E _ A R R A Y
 *
 *	flattened version of the union tree
 */
struct rt_tree_array
{
	union tree	*tl_tree;
	int		tl_op;
};

#define TREE_LIST_NULL	((struct tree_list *)0)

/* Some dubious defines, to support the wdb_obj.c evolution */
#define RT_MAXARGS		9000
#define RT_MAXLINE		10240
#define RT_NAMESIZE		16

/*
 *			R T _ W D B
 *
 *  This data structure is at the core of the "LIBWDB" support for
 *  allowing application programs to read and write BRL-CAD databases.
 *  Many different access styles are supported.
 */
 
struct rt_wdb  {
	struct bu_list	l;
	int		type;
	struct db_i	*dbip;
	struct bu_vls	wdb_name;	/* database object name */
	struct db_tree_state	wdb_initial_tree_state;
	struct rt_tess_tol	wdb_ttol;
	struct bn_tol		wdb_tol;
	struct resource		*wdb_resp;

	/* variables for name prefixing */
	struct bu_vls	wdb_prestr;
	int		wdb_ncharadd;
	int		wdb_num_dups;

	/* default region ident codes for this particular database. */
	int		wdb_item_default;/* GIFT region ID */
	int		wdb_air_default;
	int		wdb_mat_default;/* GIFT material code */
	int		wdb_los_default;/* Line-of-sight estimate */
	struct bu_observer	wdb_observers;
	Tcl_Interp	*wdb_interp;
};

#define	RT_WDB_MAGIC			0x5f576462
#define RT_CHECK_WDB(_p)		BU_CKMAG(_p,RT_WDB_MAGIC,"rt_wdb")
#define RT_CHECK_WDB_TCL(_interp,_p)	BU_CKMAG_TCL(_interp,_p,RT_WDB_MAGIC,"rt_wdb")
#define RT_CK_WDB(_p)			RT_CHECK_WDB(_p)
#define RT_CK_WDB_TCL(_interp,_p)	RT_CHECK_WDB_TCL(_interp,_p)
#define RT_WDB_NULL		((struct rt_wdb *)NULL)
#define RT_WDB_TYPE_DB_DISK			2
#define RT_WDB_TYPE_DB_DISK_APPEND_ONLY		3
#define RT_WDB_TYPE_DB_INMEM			4
#define RT_WDB_TYPE_DB_INMEM_APPEND_ONLY	5

extern struct rt_wdb HeadWDB;		/* head of BRLCAD database object list */

/*
 * Carl's vdraw stuff.
 */
#define RT_VDRW_PREFIX		"_VDRW"
#define RT_VDRW_PREFIX_LEN	6
#define RT_VDRW_MAXNAME	31
#define RT_VDRW_DEF_COLOR	0xffff00
struct vd_curve {
	struct bu_list	l;
	char		vdc_name[RT_VDRW_MAXNAME+1]; 	/* name array */
	long		vdc_rgb;	/* color */
	struct bu_list	vdc_vhd;	/* head of list of vertices */
};
#define VD_CURVE_NULL		((struct vd_curve *)NULL)

/*
 * Used to keep track of forked rt's for possible future aborts.
 * Currently used in mged/rtif.c and librt/dg_obj.c
 */
struct run_rt {
	struct bu_list		l;
#ifdef WIN32
	HANDLE			fd;
	HANDLE			hProcess;
	DWORD			pid;

#ifdef TCL_OK
	Tcl_Channel		chan;
#else
	genptr_t chan;
#endif
#else
	int			fd;
	int			pid;
#endif	
	int			aborted;
};

/*
 *			D G _ O B J
 *
 * A drawable geometry object is associated with a database object
 * and is used to maintain lists of geometry that are ready for display.
 * This geometry can come from a Brl-Cad database or from vdraw commands.
 * The drawable geometry object is also capabable of raytracing geometry
 * that comes from a Brl-Cad database.
 */
struct dg_qray_color {
  unsigned char r;
  unsigned char g;
  unsigned char b;
};

struct dg_qray_fmt {
  char type;
  struct bu_vls fmt;
};

struct dg_obj {
	struct bu_list	l;
	struct bu_vls		dgo_name;	/* drawable geometry object name */
	struct rt_wdb		*dgo_wdbp;	/* associated database */
	struct bu_list		dgo_headSolid;	/* head of solid list */
	struct bu_list		dgo_headVDraw;	/* head of vdraw list */
	struct vd_curve		*dgo_currVHead;	/* current vdraw head */
	char			*dgo_rt_cmd[RT_MAXARGS];
	int			dgo_rt_cmd_len;
	struct bu_observer	dgo_observers;
	struct run_rt		dgo_headRunRt;	/* head of forked rt processes */
	struct bu_vls		dgo_qray_basename;	/* basename of query ray vlist */
	struct bu_vls		dgo_qray_script;	/* query ray script */
	char			dgo_qray_effects;	/* t for text, g for graphics or b for both */
	int			dgo_qray_cmd_echo;	/* 0 - don't echo command, 1 - echo command */
	struct dg_qray_fmt	*dgo_qray_fmts;
	struct dg_qray_color	dgo_qray_odd_color;
	struct dg_qray_color	dgo_qray_even_color;
	struct dg_qray_color	dgo_qray_void_color;
	struct dg_qray_color	dgo_qray_overlap_color;
	int			dgo_shaded_mode;	/* 1 - draw bots shaded by default */
};
extern struct dg_obj HeadDGObj;		/* head of drawable geometry object list */
#define RT_DGO_NULL		((struct dg_obj *)NULL)

/*
 *			V I E W _ O B J
 *
 * A view object maintains state for controlling a view.
 */
struct view_obj {
	struct bu_list	l;
	struct bu_vls		vo_name;		/* view object name/cmd */
	fastf_t			vo_scale;
	fastf_t			vo_size;		/* 2.0 * scale */
	fastf_t			vo_invSize;		/* 1.0 / size */
	fastf_t			vo_perspective;		/* perspective angle */
	fastf_t			vo_local2base;		/* scale local units to base units (i.e. mm) */
	fastf_t			vo_base2local;		/* scale base units (i.e. mm) to local units */
	vect_t			vo_aet;
	vect_t			vo_eye_pos;		/* eye position */
	vect_t			vo_keypoint;
	char			vo_coord;		/* coordinate system */
	char			vo_rotate_about;	/* indicates what point rotations are about */
	mat_t			vo_rotation;
	mat_t			vo_center;
	mat_t			vo_model2view;
	mat_t			vo_pmodel2view;
	mat_t			vo_view2model;
	mat_t			vo_pmat;		/* perspective matrix */
	struct bu_observer	vo_observers;
	void 			(*vo_callback)();	/* called in vo_update with vo_clientData and vop */
	genptr_t		vo_clientData;		/* passed to vo_callback */
	int			vo_zclip;
};
extern struct view_obj HeadViewObj;		/* head of view object list */
#define RT_VIEW_OBJ_NULL		((struct view_obj *)NULL)
#define RT_MINVIEWSIZE 0.0001
#define RT_MINVIEWSCALE 0.00005

/*
 *			A N I M A T E
 *
 *  Each one of these structures specifies an arc in the tree that
 *  is to be operated on for animation purposes.  More than one
 *  animation operation may be applied at any given arc.  The directory
 *  structure points to a linked list of animate structures
 *  (built by rt_anim_add()), and the operations are processed in the
 *  order given.
 */
struct anim_mat {
	int		anm_op;			/* ANM_RSTACK, ANM_RARC... */
	mat_t		anm_mat;		/* Matrix */
};
#define ANM_RSTACK	1			/* Replace stacked matrix */
#define ANM_RARC	2			/* Replace arc matrix */
#define ANM_LMUL	3			/* Left (root side) mul */
#define ANM_RMUL	4			/* Right (leaf side) mul */
#define ANM_RBOTH	5			/* Replace stack, arc=Idn */

struct rt_anim_property {
	long		magic;
	int		anp_op;			/* RT_ANP_REPLACE, etc */
	struct bu_vls	anp_shader;		/* Update string */
};
#define RT_ANP_REPLACE	1			/* Replace shader string */
#define RT_ANP_APPEND	2			/* Append to shader string */
#define RT_ANP_MAGIC	0x41507270		/* 'APrp' */
#define RT_CK_ANP(_p)	BU_CKMAG((_p), RT_ANP_MAGIC, "rt_anim_property")

struct rt_anim_color {
	int		anc_rgb[3];		/* New color */
};

struct animate {
	long		magic;			/* magic number */
	struct animate	*an_forw;		/* forward link */
	struct db_full_path an_path;		/* (sub)-path pattern */
	int		an_type;		/* AN_MATRIX, AN_COLOR... */
	union animate_specific {
		struct anim_mat		anu_m;
		struct rt_anim_property	anu_p;
		struct rt_anim_color	anu_c;
		float			anu_t;
	}		an_u;
};
#define RT_AN_MATRIX	1			/* Matrix animation */
#define RT_AN_MATERIAL	2			/* Material property anim */
#define RT_AN_COLOR	3			/* Material color anim */
#define RT_AN_SOLID	4			/* Solid parameter anim */
#define RT_AN_TEMPERATURE 5			/* Region temperature */

#define ANIM_NULL	((struct animate *)0)
#define ANIMATE_MAGIC	0x414e4963		/* 1095649635 */
#define RT_CK_ANIMATE(_p)	BU_CKMAG((_p), ANIMATE_MAGIC, "animate")

/*
 *			R T _ H T B L
 *
 *  Support for variable length arrays of "struct hit".
 *  Patterned after the libbu/ptbl.c idea.
 */
struct rt_htbl {
	struct bu_list	l;	/* linked list for caller's use */
	int		end;	/* index of first available location */
	int		blen;	/* # of struct's of storage at *hits */
	struct hit 	*hits;	/* hits[blen] data storage area */
};
#define RT_HTBL_MAGIC		0x6874626c		/* "htbl" */
#define RT_CK_HTBL(_p)		BU_CKMAG(_p, RT_HTBL_MAGIC, "rt_htbl")

/*
 *			R T _ P I E C E S T A T E
 *
 *  Holds onto memory re-used by rt_shootray() from shot to shot.
 *  One of these for each solid which uses pieces.
 *  There is a separate array of these for each cpu.
 *  Storage for the bit vectors is pre-allocated at prep time.
 *  The array is subscripted by st_piecestate_num.
 *  The bit vector is subscripted by values found in rt_piecelist pieces[].
 */
struct rt_piecestate  {
	long		magic;
	long		ray_seqno;	/* res_nshootray */
	struct soltab	*stp;
	struct bu_bitv	*shot;
	fastf_t		mindist;	/* dist ray enters solids bounding volume */
	fastf_t		maxdist;	/* dist ray leaves solids bounding volume */
	struct rt_htbl	htab;		/* accumulating hits here */
	const union cutter *cutp;		/* current bounding volume */
};
#define RT_PIECESTATE_MAGIC	0x70637374	/* pcst */
#define RT_CK_PIECESTATE(_p)	BU_CKMAG(_p, RT_PIECESTATE_MAGIC, "struct rt_piecestate")

/*
 *			R T _ P I E C E L I S T
 *
 *  For each space partitioning cell,
 *  there is one of these for each solid in that cell which uses pieces.
 *  Storage for the array is allocated at cut time, and never changes.
 *
 *  It is expected that the indices allocated by any solid range from
 *  0..(npieces-1).
 *
 *  The piece indices are used as a subscript into a solid-specific table,
 *  and also into the 'shot' bitv of the corresponding rt_piecestate.
 *
 *  The values (subscripts) in pieces[] are specific to a single solid (stp).
 */
struct rt_piecelist  {
	long		magic;
	long		npieces;	/* number of pieces in pieces[] array */
	long		*pieces;	/* pieces[npieces], piece indices */
	struct soltab	*stp;		/* ref back to solid */
};
#define RT_PIECELIST_MAGIC	0x70636c73	/* pcls */
#define RT_CK_PIECELIST(_p)	BU_CKMAG(_p, RT_PIECELIST_MAGIC, "struct rt_piecelist")

/* Used to set globals declared in g_bot.c */
#define RT_DEFAULT_MINPIECES		32
#define RT_DEFAULT_TRIS_PER_PIECE	4

/*
 *			R E S O U R C E
 *
 *  Per-CPU statistics and resources.
 *
 *  One of these structures is allocated per processor.
 *  To prevent excessive competition for free structures,
 *  memory is now allocated on a per-processor basis.
 *  The application structure a_resource element specifies
 *  the resource structure to be used;  if uniprocessing,
 *  a null a_resource pointer results in using the internal global
 *  structure (&rt_uniresource),
 *  making initial application development simpler.
 *
 *  Applications are responsible for calling rt_init_resource()
 *  for each resource structure before letting LIBRT use them.
 *
 *  Note that if multiple models are being used, the partition and bitv
 *  structures (which are variable length) will require there to be
 *  ncpus * nmodels resource structures, the selection of which will
 *  be the responsibility of the application.
 *
 *  Per-processor statistics are initially collected in here,
 *  and then posted to rt_i by rt_add_res_stats().
 */
struct resource {
	long		re_magic;	/* Magic number */
	int		re_cpu;		/* processor number, for ID */
	struct bu_list 	re_seg;		/* Head of segment freelist */
	struct bu_ptbl	re_seg_blocks;	/* Table of malloc'ed blocks of segs */
	long		re_seglen;
	long		re_segget;
	long		re_segfree;
	struct bu_list	re_parthead;	/* Head of freelist */
	long		re_partlen;
	long		re_partget;
	long		re_partfree;
	struct bu_list	re_solid_bitv;	/* head of freelist */
	struct bu_list	re_region_ptbl;	/* head of freelist */
	struct bu_list	re_nmgfree;	/* head of NMG hitmiss freelist */
	union tree	**re_boolstack;	/* Stack for rt_booleval() */
	long		re_boolslen;	/* # elements in re_boolstack[] */
	float		*re_randptr;	/* ptr into random number table */
	/* Statistics.  Only for examination by rt_add_res_stats() */
	long		re_nshootray;	/* Calls to rt_shootray() */
	long		re_nmiss_model;	/* Rays pruned by model RPP */
	/* Solid nshots = shot_hit + shot_miss */
	long		re_shots;	/* # calls to ft_shot() */
	long		re_shot_hit;	/* ft_shot() returned a miss */
	long		re_shot_miss;	/* ft_shot() returned a hit */
	/* Optimizations.  Rays not shot at solids */
	long		re_prune_solrpp;/* shot missed solid RPP, ft_shot skipped */
	long		re_ndup;	/* ft_shot() calls skipped for already-ft_shot() solids */
	long		re_nempty_cells; /* number of empty NUgrid cells passed through */
	/* Data for accelerating "pieces" of solids */
	struct rt_piecestate *re_pieces; /* array [rti_nsolids_with_pieces] */
	long		re_piece_ndup;	/* ft_piece_shot() calls skipped for already-ft_shot() solids */
	long		re_piece_shots;	/* # calls to ft_piece_shot() */
	long		re_piece_shot_hit;	/* ft_piece_shot() returned a miss */
	long		re_piece_shot_miss;	/* ft_piece_shot() returned a hit */
	struct bu_ptbl	re_pieces_pending; /* pieces with an odd hit pending */
	/* Per-processor cache of tree unions, to accelerate "tops" and treewalk */
	union tree	*re_tree_hd;  /* Head of free trees */
	long		re_tree_get;
	long		re_tree_malloc;
	long		re_tree_free;
	struct directory *re_directory_hd;
	struct bu_ptbl	re_directory_blocks;	/* Table of malloc'ed blocks */
};
extern struct resource	rt_uniresource;	/* default.  Defined in librt/shoot.c */
#define RESOURCE_NULL	((struct resource *)0)
#define RESOURCE_MAGIC	0x83651835
#define RT_RESOURCE_CHECK(_p)	BU_CKMAG(_p, RESOURCE_MAGIC, "struct resource")
#define RT_CK_RESOURCE(_p)	BU_CKMAG(_p, RESOURCE_MAGIC, "struct resource")

/* More malloc-efficient replacement for BU_GETUNION(tp, tree) */
#define RT_GET_TREE(_tp,_res)	{ \
	if( ((_tp) = (_res)->re_tree_hd) != TREE_NULL )  { \
		(_res)->re_tree_hd = (_tp)->tr_b.tb_left; \
		(_tp)->tr_b.tb_left = TREE_NULL; \
		(_res)->re_tree_get++; \
	} else { \
		GETUNION( _tp, tree ); \
		(_res)->re_tree_malloc++; \
	}\
	}
#define RT_FREE_TREE(_tp,_res)  { \
		(_tp)->tr_b.tb_left = (_res)->re_tree_hd; \
		(_tp)->tr_b.tb_right = TREE_NULL; \
		(_res)->re_tree_hd = (_tp); \
		(_tp)->tr_b.tb_op = OP_FREE; \
		(_res)->re_tree_free++; \
	}


/*			R T _ R E P R E P _ O B J _ L I S T
 *
 *	Structure used by the "reprep" routines
 */
struct rt_reprep_obj_list {
	int ntopobjs;		/* number of objects in the original call to gettrees */
	char **topobjs;		/* list of the above object names */
	int nunprepped;		/* number of objects to be unprepped and re-prepped */
	char **unprepped;	/* list of the above objects */
	/* Above here must be filled in by application */
	/* Below here is used by dynamic geometry routines, should be zeroed by application before use */
	struct bu_ptbl paths;	/* list of all paths from topobjs to unprepped objects */
	struct db_tree_state **tsp;	/* tree state used by tree walker in "reprep" routines */
	struct bu_ptbl unprep_regions;	/* list of region structures that will be "unprepped" */
	long old_nsolids;		/* rtip->nsolids before unprep */
	long old_nregions;		/* rtip->nregions before unprep */
	long nsolids_unprepped;		/* number of soltab structures eliminated by unprep */
	long nregions_unprepped;	/* number of region structures eliminated by unprep */
};




/*
 *			P I X E L _ E X T
 *
 *  This structure is intended to descrbe the area and/or volume represented
 *  by a ray.  In the case of the "rt" program it represents the extent in
 *  model coordinates of the prism behind the pixel being rendered.
 *
 *  The r_pt values of the rays indicate the dimensions and location in model
 *  space of the ray origin (usually the pixel to be rendered). 
 *  The r_dir vectors indicate the edges (and thus the shape) of the prism 
 *  which is formed from the projection of the pixel into space.
 */
#define CORNER_PTS 4
struct pixel_ext {
	unsigned long	magic;
	struct xray	corner[CORNER_PTS];
};
/* This should have had an RT_ prefix */
#define PIXEL_EXT_MAGIC 0x50787400	/* "Pxt" */
#define BU_CK_PIXEL_EXT(_p)	BU_CKMAG(_p, PIXEL_EXT_MAGIC, "struct pixel_ext")

/*
 *			A P P L I C A T I O N
 *
 *  This structure is the only parameter to rt_shootray().
 *  The entire structure should be zeroed (e.g. by memset(,0,) ) before it
 *  is used the first time.
 *
 *  When calling rt_shootray(), these fields are mandatory:
 *	a_ray.r_pt	Starting point of ray to be fired
 *	a_ray.r_dir	UNIT VECTOR with direction to fire in (dir cosines)
 *	a_hit()		Routine to call when something is hit
 *	a_miss()	Routine to call when ray misses everything
 *	a_rt_i		Must be set to the value returned by rt_dirbuild().
 *
 *  In addition, these fields are used by the library.  If they are
 *  set to zero, default behavior will be used.
 *	a_resource	Pointer to CPU-specific resources.  Multi-CPU only.
 *	a_overlap()	DEPRECATED, set a_multioverlap() instead.
 *			If non-null, this routine will be called to
 *			handle overlap conditions.  See librt/bool.c
 *			for calling sequence.
 *			Return of 0 eliminates partition with overlap entirely
 *			Return of !0 retains one partition in output
 *	a_multioverlap() Called when two or more regions overlap in a partition.
 *			Default behavior used if pointer not set.
 *			See librt/bool.c for calling sequence.
 *	a_level		Printed by librt on errors, but otherwise not used.
 *	a_x		Printed by librt on errors, but otherwise not used.
 *	a_y		Printed by librt on errors, but otherwise not used.
 *	a_purpose	Printed by librt on errors, but otherwise not used.
 *	a_rbeam		Used to compute beam coverage on geometry,
 *	a_diverge	for spline subdivision & many UV mappings.
 *
 *  Note that rt_shootray() returns the (int) return of the a_hit()/a_miss()
 *  function called, as well as placing it in a_return.
 *  A future "multiple rays at a time" interface will only provide a_return.
 *
 *  Note that the organization of this structure, and the details of
 *  the non-mandatory elements are subject to change in every release.
 *  Therefore, rather than using compile-time structure initialization,
 *  you should create a zeroed-out structure, and then assign the intended
 *  values at runtime.  A zeroed structure can be obtained at compile
 *  time with "static const struct application zero_ap;", or at run time
 *  by using "memset( (char *)ap, 0, sizeof(struct application) );" or
 *  bu_calloc( 1, sizeof(struct application), "application" );
 *  While this practice may not work on machines where "all bits off"
 *  does not signify a floating point zero, BRL-CAD does not support any
 *  such machines, so this is a moot issue.
 */
struct application  {
	long		a_magic;
	/* THESE ELEMENTS ARE MANDATORY */
	struct xray	a_ray;		/* Actual ray to be shot */
	int		(*a_hit)BU_ARGS( (struct application *, struct partition *, struct seg *));	/* called when shot hits model */
	int		(*a_miss)BU_ARGS( (struct application *));	/* called when shot misses */
	int		a_onehit;	/* flag to stop on first hit */
	fastf_t		a_ray_length;	/* distance from ray start to end intersections */
	struct rt_i	*a_rt_i;	/* this librt instance */
	int		a_zero1;	/* must be zero (sanity check) */
	/* THESE ELEMENTS ARE USED BY THE LIBRARY, BUT MAY BE LEFT ZERO */
	struct resource	*a_resource;	/* dynamic memory resources */
	int		(*a_overlap)();	/* DEPRECATED */
	void		(*a_multioverlap)BU_ARGS( (struct application *,	/* called to resolve overlaps */
						   struct partition *,
						   struct bu_ptbl *,
						   struct partition *) );
	void		(*a_logoverlap)BU_ARGS( (struct application *,	/* called to log overlaps */
						 const struct partition *,
						 const struct bu_ptbl *,
						 const struct partition *) );
	int		a_level;	/* recursion level (for printing) */
	int		a_x;		/* Screen X of ray, if applicable */
	int		a_y;		/* Screen Y of ray, if applicable */
	char		*a_purpose;	/* Debug string:  purpose of ray */
	fastf_t		a_rbeam;	/* initial beam radius (mm) */
	fastf_t		a_diverge;	/* slope of beam divergance/mm */
	int		a_return;	/* Return of a_hit()/a_miss() */
	int		a_no_booleans;	/* 1= partitions==segs, no booleans */
	char		**attrs;	/* null terminated list of attributes
					 * This list should be the same as passed to
					 * rt_gettrees_and_attrs() */
	/* THESE ELEMENTS ARE USED BY THE PROGRAM "rt" AND MAY BE USED BY */
	/* THE LIBRARY AT SOME FUTURE DATE */
	/* AT THIS TIME THEY MAY BE LEFT ZERO */
	struct pixel_ext *a_pixelext;	/* locations of pixel corners */
	/* THESE ELEMENTS ARE WRITTEN BY THE LIBRARY, AND MAY BE READ IN a_hit() */
	struct seg	*a_finished_segs_hdp;
	struct partition *a_Final_Part_hdp;
	vect_t		a_inv_dir;	/* filled in by rt_shootray(), inverse of ray direction cosines */
	/* THE FOLLOWING ELEMENTS ARE MAINLINE & APPLICATION SPECIFIC. */
	/* THEY ARE NEVER EXAMINED BY THE LIBRARY. */
	int		a_user;		/* application-specific value */
	genptr_t	a_uptr;		/* application-specific pointer */
	struct bn_tabdata *a_spectrum;	/* application-specific bn_tabdata prointer */
	fastf_t		a_color[3];	/* application-specific color */
	fastf_t		a_dist;		/* application-specific distance */
	vect_t		a_uvec;		/* application-specific vector */
	vect_t		a_vvec;		/* application-specific vector */
	fastf_t		a_refrac_index;	/* current index of refraction */
	fastf_t		a_cumlen;	/* cumulative length of ray */
	int		a_flag;		/* application-specific flag */
	int		a_zero2;	/* must be zero (sanity check) */
};
#define RT_AFN_NULL	((int (*)())0)
#define RT_AP_MAGIC	0x4170706c	/* "Appl" */
#define RT_CK_AP(_p)	BU_CKMAG(_p,RT_AP_MAGIC,"struct application")
#define RT_CK_APPLICATION(_p)	BU_CKMAG(_p,RT_AP_MAGIC,"struct application")
#define RT_CK_AP_TCL(_interp,_p)	BU_CKMAG_TCL(_interp,_p,RT_AP_MAGIC,"struct application")
#define RT_APPLICATION_INIT(_p)	{ \
		memset( (char *)(_p), 0, sizeof(struct application) ); \
		(_p)->a_magic = RT_AP_MAGIC; \
	}


#ifdef NO_BOMBING_MACROS
#  define RT_AP_CHECK(_ap)
#else
#  define RT_AP_CHECK(_ap)	\
	{if((_ap)->a_zero1||(_ap)->a_zero2) \
		rt_bomb("corrupt application struct"); }
#endif

/*
 *			R T _ G
 *
 *  Definitions for librt.a which are global to the library
 *  regardless of how many different models are being worked on
 */
struct rt_g {
	int		debug;		/* !0 for debug, see librt/debug.h */
	/* XXX rtg_parallel is not used by LIBRT any longer */
	int		rtg_parallel;	/* !0 = trying to use multi CPUs */
	struct bu_list	rtg_vlfree;	/* head of bn_vlist freelist */
	int		NMG_debug;	/* debug bits for NMG's see h/nmg.h */
	struct rt_wdb	rtg_headwdb;	/* head of database object list */
};
extern struct rt_g rt_g;

/* Normally set when in production mode, setting the RT_G_DEBUG define to 0
 * will allow chucks of code to poof away at compile time (since they are
 * truth-functionally constant (false))  This can boost raytrace performance
 * considerably (~10%).
 */
#ifdef NO_DEBUG_CHECKING
#	define	RT_G_DEBUG	0
#else
#	define	RT_G_DEBUG	rt_g.debug
#endif

/*
 *			S E M A P H O R E S
 *
 *  Definition of global parallel-processing semaphores.
 *
 * res_syscall is now	BU_SEM_SYSCALL
 */
#define RT_SEM_TREE0	(BU_SEM_LAST)
#define RT_SEM_TREE1	(RT_SEM_TREE0+1)
#define RT_SEM_TREE2	(RT_SEM_TREE1+1)
#define RT_SEM_TREE3	(RT_SEM_TREE2+1)
#define RT_SEM_WORKER	(RT_SEM_TREE3+1)
#define RT_SEM_STATS	(RT_SEM_WORKER+1)
#define RT_SEM_RESULTS	(RT_SEM_STATS+1)
#define RT_SEM_MODEL	(RT_SEM_RESULTS+1)

#define RT_SEM_LAST	(RT_SEM_MODEL+1)	/* Call bu_semaphore_init( RT_SEM_LAST ); */


/*
 *			R T _ I
 *
 *  Definitions for librt which are specific to the
 *  particular model being processed, one copy for each model.
 *  Initially, a pointer to this is returned from rt_dirbuild().
 *
 *  During gettree processing, the most time consuming step is
 *  searching the list of existing solids to see if a new solid is
 *  actually an identical instance of a previous solid.
 *  Therefore, the list has been divided into several lists.
 *  The same macros & hash value that accesses the dbi_Head[] array
 *  are used here.  The hash value is computed by db_dirhash().
 */
struct rt_i {
	long		rti_magic;	/* magic # for integrity check */
	/* THESE ITEMS ARE AVAILABLE FOR APPLICATIONS TO READ & MODIFY */
	int		useair;		/* 1="air" regions are retained while prepping */
	int		rti_save_overlaps; /* 1=fill in pt_overlap_reg, change boolweave behavior */
	int		rti_dont_instance; /* 1=Don't compress instances of solids into 1 while prepping */
	int		rti_hasty_prep;	/* 1=hasty prep, slower ray-trace */
	int		rti_nlights;	/* number of light sources */
	int		rti_prismtrace; /* add support for pixel prism trace */
	char		*rti_region_fix_file; /* rt_regionfix() file or NULL */
	int		rti_space_partition;  /* space partitioning method */
	int		rti_nugrid_dimlimit;  /* limit on nugrid dimensions */
	struct bn_tol	rti_tol;	/* Math tolerances for this model */
	struct rt_tess_tol rti_ttol;	/* Tessellation tolerance defaults */
	fastf_t		rti_max_beam_radius; /* Max threat radius for FASTGEN cline solid */
	/* THESE ITEMS ARE AVAILABLE FOR APPLICATIONS TO READ */
	point_t		mdl_min;	/* min corner of model bounding RPP */
	point_t		mdl_max;	/* max corner of model bounding RPP */
	point_t		rti_pmin;	/* for plotting, min RPP */
	point_t		rti_pmax;	/* for plotting, max RPP */
	double		rti_radius;	/* radius of model bounding sphere */
	struct db_i	*rti_dbip;	/* prt to Database instance struct */
	/* THESE ITEMS SHOULD BE CONSIDERED OPAQUE, AND SUBJECT TO CHANGE */
	int		needprep;	/* needs rt_prep */
	struct region	**Regions;	/* ptrs to regions [reg_bit] */
	struct bu_list	HeadRegion;	/* ptr of list of regions in model */
	genptr_t	Orca_hash_tbl;	/* Hash table in matrices for ORCA */
	struct bu_ptbl	delete_regs;	/* list of region pointers to delete after light_init() */
	/* Ray-tracing statistics */
	long		nregions;	/* total # of regions participating */
	long		nsolids;	/* total # of solids participating */
	long		rti_nrays;	/* # calls to rt_shootray() */
	long		nmiss_model;	/* rays missed model RPP */
	long		nshots;		/* # of calls to ft_shot() */
	long		nmiss;		/* solid ft_shot() returned a miss */
	long		nhits;		/* solid ft_shot() returned a hit */
	long		nmiss_tree;	/* shots missed sub-tree RPP */
	long		nmiss_solid;	/* shots missed solid RPP */
	long		ndup;		/* duplicate shots at a given solid */
	long		nempty_cells;	/* number of empty NUgrid cells */
	union cutter	rti_CutHead;	/* Head of cut tree */
	union cutter	rti_inf_box;	/* List of infinite solids */
	union cutter	*rti_CutFree;	/* cut Freelist */
	struct bu_ptbl	rti_busy_cutter_nodes; /* List of "cutter" mallocs */
	struct bu_ptbl	rti_cuts_waiting;
	int		rti_cut_maxlen;	/* max len RPP list in 1 cut bin */
	int		rti_ncut_by_type[CUT_MAXIMUM+1];	/* number of cuts by type */
	int		rti_cut_totobj;	/* # objs in all bins, total */
	int		rti_cut_maxdepth;/* max depth of cut tree */
	struct soltab	**rti_sol_by_type[ID_MAX_SOLID+1];
	int		rti_nsol_by_type[ID_MAX_SOLID+1];
	int		rti_maxsol_by_type;
	int		rti_air_discards;/* # of air regions discarded */
	struct bu_hist rti_hist_cellsize; /* occupancy of cut cells */
	struct bu_hist rti_hist_cell_pieces; /* solid pieces per cell */
	struct bu_hist rti_hist_cutdepth; /* depth of cut tree */
	struct soltab	**rti_Solids;	/* ptrs to soltab [st_bit] */
	struct bu_list	rti_solidheads[RT_DBNHASH]; /* active solid lists */
	struct bu_ptbl	rti_resources;	/* list of 'struct resource'es encountered */
	double		rti_nu_gfactor;	/* constant in numcells computation */
	int		rti_cutlen;	/* goal for # solids per boxnode */
	int		rti_cutdepth;	/* goal for depth of NUBSPT cut tree */
	/* Parameters required for rt_submodel */
	char		*rti_treetop;	/* bu_strduped, for rt_submodel rti's only */
	int		rti_uses;	/* for rt_submodel */
	/* Parameters for accelerating "pieces" of solids */
	int		rti_nsolids_with_pieces; /* #solids using pieces */
	/* Parameters for dynamic geometry */
	int		rti_add_to_new_solids_list;
	struct bu_ptbl	rti_new_solids;
};

#define RT_NU_GFACTOR_DEFAULT	1.5	 /* see rt_cut_it() for a description
					    of this */
	
#define RTI_NULL	((struct rt_i *)0)
#define RTI_MAGIC	0x99101658	/* magic # for integrity check */

#define RT_CHECK_RTI(_p)		BU_CKMAG(_p,RTI_MAGIC,"struct rt_i")
#define RT_CHECK_RTI_TCL(_interp,_p)	BU_CKMAG_TCL(_interp,_p,RTI_MAGIC,"struct rt_i")
#define RT_CK_RTI(_p)			RT_CHECK_RTI(_p)
#define RT_CK_RTI_TCL(_interp,_p)	RT_CHECK_RTI_TCL(_interp,_p)

#define	RT_PART_NUBSPT	0
#define RT_PART_NUGRID	1
	
/*
 *  Macros to painlessly visit all the active solids.  Serving suggestion:
 *
 *	RT_VISIT_ALL_SOLTABS_START( stp, rtip )  {
 *		rt_pr_soltab( stp );
 *	} RT_VISIT_ALL_SOLTABS_END
 */
#define RT_VISIT_ALL_SOLTABS_START(_s, _rti)	{ \
	register struct bu_list	*_head = &((_rti)->rti_solidheads[0]); \
	for( ; _head < &((_rti)->rti_solidheads[RT_DBNHASH]); _head++ ) \
		for( BU_LIST_FOR( _s, soltab, _head ) )  {

#define RT_VISIT_ALL_SOLTABS_END	} }

/*
 *  Applications that are going to use RT_ADD_VLIST and RT_GET_VLIST
 *  are required to execute this macro once, first:
 *		BU_LIST_INIT( &rt_g.rtg_vlfree );
 *
 * Note that RT_GET_VLIST and RT_FREE_VLIST are non-PARALLEL.
 */
#define RT_GET_VLIST(p)		BN_GET_VLIST(&rt_g.rtg_vlfree, p)

/* Place an entire chain of bn_vlist structs on the freelist */
#define RT_FREE_VLIST(hd)	BN_FREE_VLIST(&rt_g.rtg_vlfree, hd)

#define RT_ADD_VLIST(hd,pnt,draw)  BN_ADD_VLIST(&rt_g.rtg_vlfree,hd,pnt,draw)



/*
 *  Replacements for definitions from ../h/vmath.h
 */
#undef V2PRINT
#undef VPRINT
#undef HPRINT
#define V2PRINT(a,b)	bu_log("%s (%g, %g)\n", a, (b)[0], (b)[1] );
#define VPRINT(a,b)	bu_log("%s (%g, %g, %g)\n", a, (b)[0], (b)[1], (b)[2])
#define HPRINT(a,b)	bu_log("%s (%g, %g, %g, %g)\n", a, (b)[0], (b)[1], (b)[2], (b)[3])

/*
 *			C O M M A N D _ T A B
 *
 *  Table for driving generic command-parsing routines
 */
struct command_tab {
	char	*ct_cmd;
	char	*ct_parms;
	char	*ct_comment;
	int	(*ct_func)();
	int	ct_min;		/* min number of words in cmd */
	int	ct_max;		/* max number of words in cmd */
};

/*
 *			R T _ P O I N T _ L A B E L S
 *
 *  Used by MGED for labeling vertices of a solid.
 */
struct rt_point_labels {
	char	str[8];
	point_t	pt;
};

/*
 *			R T _ P T _ N O D E
 *
 *  Used by g_rpc.c and others to contain forward-linked lists of points.
 */
struct rt_pt_node {
	point_t			p;	/* a point */
	struct rt_pt_node	*next;	/* ptr to next pt */
};


/*
 *			L I N E _ S E G,  C A R C _ S E G,  N U R B _ S E G
 *	used by the sketch and solid of extrusion
 */

struct line_seg		/* line segment */
{
	long			magic;
	int			start, end;	/* indices into sketch's array of vertices */
};
#define CURVE_LSEG_MAGIC     0x6c736567		/* lseg */

struct carc_seg		/* circular arc segment */
{
	long			magic;
	int			start, end;	/* indices */
	fastf_t			radius;		/* radius < 0.0 -> full circle with start point on
						 * circle and "end" at center */
	int			center_is_left;	/* flag indicating where center of curvature is.
						 * If non-zero, then center is to left of vector
						 * from start to end */
	int			orientation;	/* 0 -> ccw, !0 -> cw */
	int			center;		/* index of vertex at center of arc (only used by rt_extrude_prep and rt_extrude_shot) */
};
#define CURVE_CARC_MAGIC     0x63617263		/* carc */

struct nurb_seg		/* NURB curve segment */
{
	long			magic;
	int			order;		/* order of NURB curve (degree - 1) */
	int			pt_type;	/* type of NURB curve */
	struct knot_vector	k;		/* knot vector for NURB curve */
	int			c_size;		/* number of control points */
	int			*ctl_points;	/* array of indicies for control points */
	fastf_t			*weights;	/* array of weights for control points (NULL if non_rational) */
};
#define CURVE_NURB_MAGIC     0x6e757262		/* nurb */

struct bezier_seg	/* Bezier curve segment */
{
	long			magic;
	int			degree;		/* degree of curve (number of control points - 1) */
	int			*ctl_points;	/* array of indices for control points */
};
#define CURVE_BEZIER_MAGIC	0x62657a69	/* bezi */

/*
 *			R T _ F U N C T A B
 *
 *  Object-oriented interface to BRL-CAD geometry.
 *
 *  These are the methods for a notional object class "brlcad_solid".
 *  The data for each instance is found separately in struct soltab.
 *  This table is indexed by ID_xxx value of particular solid
 *  found in st_id, or directly pointed at by st_meth.
 *
 *  This needs to be at the end of the raytrace.h header file,
 *  so that all the structure names are known.
 *  The "union record" and "struct nmgregion" pointers are problematic,
 *  so generic pointers are used when those header files have not yet
 *  been seen.
 *
 *  XXX On SGI, can not use identifiers in prototypes inside structure!
 */
struct rt_functab {
	long	magic;
	char	ft_name[16];
	char	ft_label[8];
	int	ft_use_rpp;
	int	(*ft_prep) BU_ARGS((struct soltab * /*stp*/,
			struct rt_db_internal * /*ip*/,
			struct rt_i * /*rtip*/ ));
	int 	(*ft_shot) BU_ARGS((struct soltab * /*stp*/,
			struct xray * /*rp*/,
			struct application * /*ap*/,	/* has resource */
			struct seg * /*seghead*/ ));
	void	(*ft_print) BU_ARGS((const struct soltab * /*stp*/));
	void	(*ft_norm) BU_ARGS((struct hit * /*hitp*/,
			struct soltab * /*stp*/,
			struct xray * /*rp*/));
	int 	(*ft_piece_shot) BU_ARGS((
			struct rt_piecestate * /*psp*/,
			struct rt_piecelist * /*plp*/,
			double /* dist_correction to apply to hit distances */,
			struct xray * /* ray transformed to be near cut cell */,
			struct application * /*ap*/,	/* has resource */
			struct seg * /*seghead*/));	/* used only for PLATE mode hits */
	void 	(*ft_piece_hitsegs) BU_ARGS((
			struct rt_piecestate * /*psp*/,
			struct seg * /*seghead*/,
			struct application * /*ap*/));	/* has resource */
	void	(*ft_uv) BU_ARGS((struct application * /*ap*/,	/* has resource */
			struct soltab * /*stp*/,
			struct hit * /*hitp*/,
			struct uvcoord * /*uvp*/));
	void	(*ft_curve) BU_ARGS((struct curvature * /*cvp*/,
			struct hit * /*hitp*/,
			struct soltab * /*stp*/));
	int	(*ft_classify) BU_ARGS((
			const struct soltab * /*stp*/,
			const vect_t /*min*/,
			const vect_t /*max*/,
			const struct bn_tol * /*tol*/));
	void	(*ft_free) BU_ARGS((struct soltab * /*stp*/));
	int	(*ft_plot) BU_ARGS((
			struct bu_list * /*vhead*/,
			struct rt_db_internal * /*ip*/,
			const struct rt_tess_tol * /*ttol*/,
			const struct bn_tol * /*tol*/));
	void	(*ft_vshot) BU_ARGS((struct soltab * /*stp*/[],
			struct xray *[] /*rp*/,
			struct seg [] /*segp*/, int /*n*/,
			struct application * /*ap*/ ));
#if defined(NMG_H)
	int	(*ft_tessellate) BU_ARGS((
			struct nmgregion ** /*r*/,
			struct model * /*m*/,
			struct rt_db_internal * /*ip*/,
			const struct rt_tess_tol * /*ttol*/,
			const struct bn_tol * /*tol*/));
	int	(*ft_tnurb) BU_ARGS((
			struct nmgregion ** /*r*/,
			struct model * /*m*/,
			struct rt_db_internal * /*ip*/,
			const struct bn_tol * /*tol*/));
#else
	int	(*ft_tessellate) BU_ARGS((
			genptr_t * /*r*/,
			genptr_t /*m*/,
			struct rt_db_internal * /*ip*/,
			const struct rt_tess_tol * /*ttol*/,
			const struct bn_tol * /*tol*/));
	int	(*ft_tnurb) BU_ARGS((
			genptr_t * /*r*/,
			genptr_t /*m*/,
			struct rt_db_internal * /*ip*/,
			const struct bn_tol * /*tol*/));
#endif
	int	(*ft_import5) BU_ARGS((struct rt_db_internal * /*ip*/,
			const struct bu_external * /*ep*/,
			const mat_t /*mat*/,
			const struct db_i * /*dbip*/,
			struct resource * /*resp*/,
			const int minor_type));
	int	(*ft_export5) BU_ARGS((struct bu_external * /*ep*/,
			const struct rt_db_internal * /*ip*/,
			double /*local2mm*/,
			const struct db_i * /*dbip*/,
			struct resource * /*resp*/,
			const int minor_type));
	int	(*ft_import) BU_ARGS((struct rt_db_internal * /*ip*/,
			const struct bu_external * /*ep*/,
			const mat_t /*mat*/,
			const struct db_i * /*dbip*/,
			struct resource * /*resp*/));
	int	(*ft_export) BU_ARGS((struct bu_external * /*ep*/,
			const struct rt_db_internal * /*ip*/,
			double /*local2mm*/,
			const struct db_i * /*dbip*/,
			struct resource * /*resp*/));
	void	(*ft_ifree) BU_ARGS((struct rt_db_internal * /*ip*/,
			struct resource * /*resp*/));
	int	(*ft_describe) BU_ARGS((struct bu_vls * /*str*/,
			const struct rt_db_internal * /*ip*/,
			int /*verbose*/,
			double /*mm2local*/,
			struct resource * /*resp*/,
			struct db_i *));
	int	(*ft_xform) BU_ARGS((struct rt_db_internal * /*op*/,
			const mat_t /*mat*/, struct rt_db_internal * /*ip*/,
			int /*free*/, struct db_i * /*dbip*/,
			struct resource * /*resp*/));
	const struct bu_structparse *ft_parsetab;	/* rt_xxx_parse */
	size_t	ft_internal_size;	/* sizeof(struct rt_xxx_internal) */
	unsigned long	ft_internal_magic;	/* RT_XXX_INTERNAL_MAGIC */
#if defined(TCL_OK)
	int	(*ft_tclget) BU_ARGS((Tcl_Interp *,
			const struct rt_db_internal *, const char *item));
	int	(*ft_tcladjust) BU_ARGS((Tcl_Interp *,
			struct rt_db_internal *,
			int /*argc*/, char ** /*argv*/,
			struct resource * /*resp*/));
	int	(*ft_tclform) BU_ARGS((const struct rt_functab *,
			Tcl_Interp *));
#else
	int	(*ft_tclget) BU_ARGS((genptr_t /*interp*/,
			const struct rt_db_internal *, const char *item));
	int	(*ft_tcladjust) BU_ARGS((genptr_t /*interp*/,
			struct rt_db_internal *,
			int /*argc*/, char ** /*argv*/,
			struct resource * /*resp*/));
	int	(*ft_tclform) BU_ARGS((const struct rt_functab *,
			genptr_t /*interp*/));
#endif
	void	(*ft_make) BU_ARGS((const struct rt_functab *,
			struct rt_db_internal *, double /*diameter*/));
};
extern const struct rt_functab rt_functab[];
extern const int rt_nfunctab;
#define RT_FUNCTAB_MAGIC		0x46754e63	/* FuNc */
#define RT_CK_FUNCTAB(_p)	BU_CKMAG(_p, RT_FUNCTAB_MAGIC, "functab" );

#define RT_CLASSIFY_UNIMPLEMENTED	BN_CLASSIFY_UNIMPLEMENTED
#define RT_CLASSIFY_INSIDE		BN_CLASSIFY_INSIDE
#define RT_CLASSIFY_OVERLAPPING		BN_CLASSIFY_OVERLAPPING
#define RT_CLASSIFY_OUTSIDE		BN_CLASSIFY_OUTSIDE

/*
 *			R T _ S H O O T R A Y _ S T A T U S
 *
 *  Internal to shoot.c and bundle.c
 */
struct rt_shootray_status {
	fastf_t			dist_corr;	/* correction distance */
	fastf_t			odist_corr;
	fastf_t			box_start;
	fastf_t			obox_start; 
	fastf_t			box_end;
	fastf_t			obox_end;
	fastf_t			model_start;
	fastf_t			model_end;
	struct xray		newray;		/* closer ray start */
	struct application	*ap;
	struct resource		*resp;
	vect_t			inv_dir;      /* inverses of ap->a_ray.r_dir */
	vect_t			abs_inv_dir;  /* absolute values of inv_dir */
	int			rstep[3];     /* -/0/+ dir of ray in axis */
	const union cutter	*lastcut, *lastcell;
	const union cutter	*curcut;
	point_t			curmin, curmax;
	int			igrid[3];     /* integer cell coordinates */
	vect_t			tv;	      /* next t intercept values */
	int			out_axis;     /* axis ray will leave through */
	struct rt_shootray_status	*old_status;
	int			box_num;	/* which cell along ray */
};

#define NUGRID_T_SETUP(_ax,_cval,_cno) \
	if( ssp->rstep[_ax] > 0 ) { \
		ssp->tv[_ax] = t0 + (nu_axis[_ax][_cno].nu_epos - _cval) * \
					    ssp->inv_dir[_ax]; \
	} else if( ssp->rstep[_ax] < 0 ) { \
		ssp->tv[_ax] = t0 + (nu_axis[_ax][_cno].nu_spos - _cval) * \
					    ssp->inv_dir[_ax]; \
	} else { \
		ssp->tv[_ax] = INFINITY; \
	}
#define NUGRID_T_ADV(_ax,_cno) \
	if( ssp->rstep[_ax] != 0 )  { \
		ssp->tv[_ax] += nu_axis[_ax][_cno].nu_width * \
			ssp->abs_inv_dir[_ax]; \
	}

#define BACKING_DIST	(-2.0)		/* mm to look behind start point */
#define OFFSET_DIST	0.01		/* mm to advance point into box */

/*********************************************************************************
 *	The following section is an exact copy of what was previously "nmg_rt.h" *
 *      (with minor changes to GET_HITMISS and NMG_FREE_HITLIST                  *
 *	moved here to use rt_g.rtg_nmgfree freelist for hitmiss structs.         *
 *********************************************************************************
 *			N M G _ R T . H
 *
 *  Author -
 *	Lee A. Butler
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1994-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 *
 *  $Header: /n/xoff/cvs/brlcad/h/raytrace.h,v 11.356 2004/05/10 15:25:26 morrison Exp $
 */

/* defining the following flag will improve NMG raytrace speed by eliminating some checking
 * Use with CAUTION!!! */
#define FAST_NMG	1

#define NMG_HIT_LIST	0
#define NMG_MISS_LIST	1
#define NMG_RT_HIT_MAGIC 0x48697400	/* "Hit" */
#define NMG_RT_HIT_SUB_MAGIC 0x48696d00	/* "Him" */
#define NMG_RT_MISS_MAGIC 0x4d697300	/* "Mis" */


/* These values are for the hitmiss "in_out" variable and indicate the
 * nature of the hit when known
 */
#define HMG_INBOUND_STATE(_hm) (((_hm)->in_out & 0x0f0) >> 4)
#define HMG_OUTBOUND_STATE(_hm) ((_hm)->in_out & 0x0f)


#define NMG_RAY_STATE_INSIDE	1
#define NMG_RAY_STATE_ON	2
#define NMG_RAY_STATE_OUTSIDE	4
#define NMG_RAY_STATE_ANY	8

#define HMG_HIT_IN_IN	0x11	/* hit internal structure */
#define HMG_HIT_IN_OUT	0x14	/* breaking out */
#define HMG_HIT_OUT_IN	0x41	/* breaking in */
#define HMG_HIT_OUT_OUT 0x44	/* edge/vertex graze */
#define HMG_HIT_IN_ON	0x12
#define HMG_HIT_ON_IN	0x21
#define HMG_HIT_ON_ON	0x22
#define HMG_HIT_OUT_ON	0x42
#define HMG_HIT_ON_OUT	0x24
#define HMG_HIT_ANY_ANY	0x88	/* hit on non-3-mainifold */

#define	NMG_VERT_ENTER 1
#define NMG_VERT_ENTER_LEAVE 0
#define NMG_VERT_LEAVE -1
#define NMG_VERT_UNKNOWN -2

#define NMG_HITMISS_SEG_IN 0x696e00	/* "in" */
#define NMG_HITMISS_SEG_OUT 0x6f757400	/* "out" */

struct hitmiss {
	struct bu_list	l;
	struct hit	hit;
	fastf_t		dist_in_plane;	/* distance from plane intersect */
	int		in_out;		/* status of ray as it transitions
					 * this hit point.
					 */
	long		*inbound_use;
	vect_t		inbound_norm;
	long		*outbound_use;
	vect_t		outbound_norm;
	int		start_stop;	/* is this a seg_in or seg_out */
	struct hitmiss	*other;		/* for keeping track of the other
					 * end of the segment when we know
					 * it
					 */
};

#define NMG_CK_HITMISS(hm) {\
	switch (hm->l.magic) { \
	case NMG_RT_HIT_MAGIC: \
	case NMG_RT_HIT_SUB_MAGIC: \
	case NMG_RT_MISS_MAGIC: \
		break; \
	case NMG_MISS_LIST: \
		bu_log("%s[%d]: struct hitmiss has  NMG_MISS_LIST magic #\n",\
			__FILE__, __LINE__); \
		rt_bomb("NMG_CK_HITMISS: going down in flames\n"); \
	case NMG_HIT_LIST: \
		bu_log("%s[%d]: struct hitmiss has  NMG_MISS_LIST magic #\n",\
			__FILE__, __LINE__); \
		rt_bomb("NMG_CK_HITMISS: going down in flames\n"); \
	default: \
		bu_log("%s[%d]: bad struct hitmiss magic: %d:(0x%08x)\n", \
			__FILE__, __LINE__, hm->l.magic, hm->l.magic); \
		rt_bomb("NMG_CK_HITMISS: going down in flames\n"); \
	}\
	if (!hm->hit.hit_private) { \
		bu_log("%s[%d]: NULL hit_private in hitmiss struct\n", \
			__FILE__, __LINE__); \
		rt_bomb("NMG_CK_HITMISS: going down in flames\n"); \
	} \
}

#define NMG_CK_HITMISS_LISTS(a_hit, rd) { \
    for (BU_LIST_FOR(a_hit, hitmiss, &rd->rd_hit)){NMG_CK_HITMISS(a_hit);} \
    for (BU_LIST_FOR(a_hit, hitmiss, &rd->rd_miss)){NMG_CK_HITMISS(a_hit);} }


/*	Ray Data structure
 *
 * A)	the hitmiss table has one element for each nmg structure in the
 *	nmgmodel.  The table keeps track of which elements have been
 *	processed before and which haven't.  Elements in this table
 *	will either be:
 *		(NULL)		item not previously processed
 *		hitmiss ptr	item previously processed
 *
 *	the 0th item in the array is a pointer to the head of the "hit"
 *	list.  The 1th item in the array is a pointer to the head of the
 *	"miss" list.
 *
 * B)	If plane_pt is non-null then we are currently processing a face
 *	intersection.  The plane_dist and ray_dist_to_plane are valid.
 *	The ray/edge intersector should check the distance from the plane
 *	intercept to the edge and update "plane_closest" if the current
 *	edge is closer to the intercept than the previous closest object.
 */
#define NMG_PCA_EDGE	1
#define NMG_PCA_EDGE_VERTEX 2
#define NMG_PCA_VERTEX 3
#define NMG_RAY_DATA_MAGIC 0x1651771
#define NMG_CK_RD(_rd) NMG_CKMAG(_rd, NMG_RAY_DATA_MAGIC, "ray data");
struct ray_data {
	long magic;
	struct model		*rd_m;
	char			*manifolds; /*  structure 1-3manifold table */
	vect_t			rd_invdir;
	struct xray		*rp;
	struct application	*ap;
	struct seg		*seghead;
	struct soltab 		*stp;
	const struct bn_tol	*tol;
	struct hitmiss	**hitmiss;	/* 1 struct hitmiss ptr per elem. */
	struct bu_list	rd_hit;		/* list of hit elements */
	struct bu_list	rd_miss;	/* list of missed/sub-hit elements */

/* The following are to support isect_ray_face() */

	/* plane_pt is the intercept point of the ray with the plane of the
	 * face.
	 */
	point_t	plane_pt;	/* ray/plane(face) intercept point */

	/* ray_dist_to_plane is the parametric distance along the ray from
	 * the ray origin (rd->rp->r_pt) to the ray/plane intercept point
	 */
	fastf_t		ray_dist_to_plane; /* ray parametric dist to plane */

	/* the "face_subhit" element is a boolean used by isect_ray_face
	 * and [e|v]u_touch_func to record the fact that the ray/(plane/face)
	 * intercept point was within tolerance of an edge/vertex of the face.
	 * In such instances, isect_ray_face does NOT need to generate a hit 
	 * point for the face, as the hit point for the edge/vertex will 
	 * suffice.
	 */
	int		face_subhit;	

	/* the "classifying_ray" flag indicates that this ray is being used to
	 * classify a point, so that the "eu_touch" and "vu_touch" functions
	 * should not be called.
	 */
	int		classifying_ray;
};


#ifdef FAST_NMG
#define GET_HITMISS(_p, _ap) { \
	(_p) = BU_LIST_FIRST( hitmiss, &((_ap)->a_resource->re_nmgfree) ); \
	if( BU_LIST_IS_HEAD( (_p), &((_ap)->a_resource->re_nmgfree ) ) ) \
		(_p) = (struct hitmiss *)bu_calloc(1, sizeof( struct hitmiss ), "hitmiss" ); \
	else \
		BU_LIST_DEQUEUE( &((_p)->l) ); \
	}

#define NMG_FREE_HITLIST(_p, _ap) { \
	BU_CK_LIST_HEAD( (_p) ); \
	BU_LIST_APPEND_LIST( &((_ap)->a_resource->re_nmgfree), (_p) ); \
	}
#else
#define GET_HITMISS(_p) { \
	char str[64]; \
	(void)sprintf(str, "GET_HITMISS %s %d", __FILE__, __LINE__); \
	(_p) = (struct hitmiss *)bu_calloc(1, sizeof(struct hitmiss), str); \
	}

#define FREE_HITMISS(_p) { \
	char str[64]; \
	(void)sprintf(str, "FREE_HITMISS %s %d", __FILE__, __LINE__); \
	(void)bu_free( (char *)_p,  str); \
	}

#define NMG_FREE_HITLIST(_p) { \
	struct hitmiss *_hit; \
	while ( BU_LIST_WHILE(_hit, hitmiss, _p)) { \
		NMG_CK_HITMISS(_hit); \
		BU_LIST_DEQUEUE( &_hit->l ); \
		FREE_HITMISS( _hit ); \
	} }

#endif

#define HIT 1	/* a hit on a face */
#define MISS 0	/* a miss on the face */


#ifdef NO_BOMBING_MACROS
#  define nmg_rt_bomb(rd, str)
#else
#  define nmg_rt_bomb(rd, str) { \
	bu_log("%s", str); \
	if (rt_g.NMG_debug & DEBUG_NMGRT) rt_bomb("End of diagnostics"); \
	BU_LIST_INIT(&rd->rd_hit); \
	BU_LIST_INIT(&rd->rd_miss); \
	rt_g.NMG_debug |= DEBUG_NMGRT; \
	nmg_isect_ray_model(rd); \
	(void) nmg_ray_segs(rd); \
	rt_bomb("Should have bombed before this\n"); }
#endif


struct nmg_radial {
	struct bu_list	l;
	struct edgeuse	*eu;
	struct faceuse	*fu;		/* Derrived from eu */
	struct shell	*s;		/* Derrived from eu */
	int		existing_flag;	/* !0 if this eu exists on dest edge */
	int		is_crack;	/* This eu is part of a crack. */
	int		is_outie;	/* This crack is an "outie" */
	int		needs_flip;	/* Insert eumate, not eu */
	fastf_t		ang;		/* angle, in radians.  0 to 2pi */
};
#define NMG_RADIAL_MAGIC	0x52614421	/* RaD! */
#define NMG_CK_RADIAL(_p)	NMG_CKMAG(_p, NMG_RADIAL_MAGIC, "nmg_radial")

struct nmg_inter_struct {
	long		magic;
	struct bu_ptbl	*l1;		/* vertexuses on the line of */
	struct bu_ptbl *l2;		/* intersection between planes */
	fastf_t		*mag1;		/* Distances along intersection line */
	fastf_t		*mag2;		/* for each vertexuse in l1 and l2. */
	int		mag_len;	/* Array size of mag1 and mag2 */
	struct shell	*s1;
	struct shell	*s2;
	struct faceuse	*fu1;		/* null if l1 comes from a wire */
	struct faceuse	*fu2;		/* null if l2 comes from a wire */
	struct bn_tol	tol;
	int		coplanar;	/* a flag */
	struct edge_g_lseg	*on_eg;		/* edge_g for line of intersection */
	point_t		pt;		/* 3D line of intersection */
	vect_t		dir;
	point_t		pt2d;		/* 2D projection of isect line */
	vect_t		dir2d;
	fastf_t		*vert2d;	/* Array of 2d vertex projections [index] */
	int		maxindex;	/* size of vert2d[] */
	mat_t		proj;		/* Matrix to project onto XY plane */
	const long	*twod;		/* ptr to face/edge of 2d projection */
};
#define NMG_INTER_STRUCT_MAGIC	0x99912120
#define NMG_CK_INTER_STRUCT(_p)	NMG_CKMAG(_p, NMG_INTER_STRUCT_MAGIC, "nmg_inter_struct")

/*****************************************************************
 *                                                               *
 *          Applications interface to the RT library             *
 *                                                               *
 *****************************************************************/
					/* Read named MGED db, build toc */
BU_EXTERN(struct rt_i *rt_dirbuild, (const char *filename, char *buf, int len) );
					/* Prepare for raytracing */
BU_EXTERN(struct rt_i *rt_new_rti, (struct db_i *dbip));
BU_EXTERN(void rt_free_rti, (struct rt_i *rtip));
BU_EXTERN(void rt_prep, (struct rt_i *rtip) );
BU_EXTERN(void rt_prep_parallel, (struct rt_i *rtip, int ncpu) );
					/* DEPRECATED, set a_logoverlap */
BU_EXTERN(int rt_overlap_quietly, (struct application *ap,
	struct partition *pp, struct region *reg1,
	struct region *reg2, struct partition *pheadp) );
BU_EXTERN(void rt_default_multioverlap, (struct application *ap,
	struct partition *pp, struct bu_ptbl *regiontable,
	struct partition *InputHdp));
BU_EXTERN(void rt_silent_logoverlap, (struct application *ap,
	const struct partition *pp, const struct bu_ptbl *regiontable,
	const struct partition *InputHdp));
BU_EXTERN(void rt_default_logoverlap, (struct application *ap,
	const struct partition *pp, const struct bu_ptbl *regiontable,
	const struct partition *InputHdp));
					/* Shoot a ray */
BU_EXTERN(int rt_shootray, (struct application *ap) );
					/* Get expr tree for object */
BU_EXTERN(const char *	rt_basename, (const char *str));
BU_EXTERN(void rt_free_soltab, (struct soltab   *stp));
BU_EXTERN(int rt_gettree, (struct rt_i *rtip, const char *node) );
BU_EXTERN(int rt_gettrees, (struct rt_i	*rtip,
	int argc, const char **argv, int ncpus));
BU_EXTERN(int rt_gettrees_and_attrs, (struct rt_i *rtip, const char **attrs,
				      int argc, const char **argv, int ncpus ) );
BU_EXTERN(int rt_gettrees_muves, (struct rt_i *rtip, const char **attrs,
				  int argc, const char **argv, int ncpus ) );
BU_EXTERN(int rt_load_attrs, ( struct rt_i *rtip, char **attrs ) );
					/* Print seg struct */
BU_EXTERN(void rt_pr_seg, (const struct seg *segp) );
					/* Print the partitions */
BU_EXTERN(void rt_pr_partitions, (const struct rt_i *rtip,
	const struct partition *phead, const char *title) );
					/* Find solid by leaf name */
BU_EXTERN(struct soltab *rt_find_solid, (const struct rt_i *rtip,
	const char *name) );
					/* Start the timer */
BU_EXTERN(void rt_prep_timer, (void) );
					/* Read timer, return time + str */
BU_EXTERN(double rt_get_timer, (struct bu_vls *vp, double *elapsed));
					/* Return CPU time, text, & wall clock time */
BU_EXTERN(double rt_read_timer, (char *str, int len) );
					/* Plot a solid */
int rt_plot_solid(
	FILE			*fp,
	struct rt_i		*rtip,
	const struct soltab	*stp,
	struct resource		*resp);
					/* Release storage assoc with rt_i */
BU_EXTERN(void rt_clean, (struct rt_i *rtip) );
BU_EXTERN(int rt_del_regtree, (struct rt_i *rtip, struct region *delregp, struct resource *resp));
					/* Check in-memory data structures */
BU_EXTERN(void rt_ck, (struct rt_i *rtip));
BU_EXTERN(void rt_pr_library_version, () );

/*****************************************************************
 *                                                               *
 *  Internal routines in the RT library.			 *
 *  These routines are *not* intended for Applications to use.	 *
 *  The interface to these routines may change significantly	 *
 *  from release to release of this software.			 *
 *                                                               *
 *****************************************************************/

					/* Weave segs into partitions */
BU_EXTERN(void rt_boolweave, (struct seg *out_hd, struct seg *in_hd,
	struct partition *PartHeadp, struct application *ap) );
					/* Eval booleans over partitions */
BU_EXTERN(int rt_boolfinal, (struct partition *InputHdp,
	struct partition *FinalHdp,
	fastf_t startdist, fastf_t enddist,
	struct bu_ptbl *regionbits, struct application *ap,
	const struct bu_bitv *solidbits) );

BU_EXTERN(void rt_grow_boolstack, (struct resource *res) );
					/* Approx Floating compare */
BU_EXTERN(int rt_fdiff, (double a, double b) );
					/* Relative Difference */
BU_EXTERN(double rt_reldiff, (double a, double b) );
					/* Print a soltab */
BU_EXTERN(void rt_pr_soltab, (const struct soltab *stp) );
					/* Print a region */
BU_EXTERN(void rt_pr_region, (const struct region *rp) );
					/* Print an expr tree */
BU_EXTERN(void rt_pr_tree, (const union tree *tp, int lvl) );
					/* Print value of tree for a partition */
BU_EXTERN(void rt_pr_tree_val, (const union tree *tp,
	const struct partition *partp, int pr_name, int lvl));
					/* Print a partition */
BU_EXTERN(void rt_pr_pt, (const struct rt_i *rtip, const struct partition *pp) );
					/* Print a bit vector */
BU_EXTERN(void rt_pr_hit, (const char *str, const struct hit *hitp) );
/* rt_fastf_float, rt_mat_dbmat, rt_dbmat_mat
 * declarations moved to h/db.h */
					/* storage obtainers */
BU_EXTERN(void rt_get_seg, (struct resource *res) );
BU_EXTERN(void rt_cut_it, (struct rt_i *rtip, int ncpu) );
					/* print cut node */
BU_EXTERN(void rt_pr_cut, (const union cutter *cutp, int lvl) );
					/* free a cut tree */
BU_EXTERN(void rt_fr_cut, (struct rt_i *rtip, union cutter *cutp) );
					/* regionid-driven color override */

/* bool.c */
extern void rt_rebuild_overlaps(struct partition	*PartHdp,
				struct application	*ap,
				int		rebuild_fastgen_plates_only);
int rt_partition_len( const struct partition *partheadp );


/* mater.c */

BU_EXTERN(void rt_region_color_map, (struct region *regp) );
					/* process ID_MATERIAL record */
void rt_color_addrec( int low, int hi, int r, int g, int b, long addr );
BU_EXTERN(void rt_color_free, () );
					/* extend a cut box */

/* cut.c */
extern void rt_pr_cut_info(const struct rt_i	*rtip,
			   const char		*str);
extern void remove_from_bsp( struct soltab *stp, union cutter *cutp, struct bn_tol *tol );
extern void insert_in_bsp( struct soltab *stp, union cutter *cutp );
extern void fill_out_bsp( struct rt_i *rtip, union cutter *cutp, struct resource *resp, fastf_t bb[6] );
BU_EXTERN(void rt_cut_extend, (union cutter *cutp, struct soltab *stp,
	const struct rt_i *rtip) );
					/* find RPP of one region */
BU_EXTERN(int rt_rpp_region, (struct rt_i *rtip, const char *reg_name,
	fastf_t *min_rpp, fastf_t *max_rpp) );
BU_EXTERN(void rt_bomb, (const char *s));
BU_EXTERN(int rt_in_rpp, (struct xray *rp, const fastf_t *invdir,
		const fastf_t *min, const fastf_t *max));
BU_EXTERN(const union cutter *rt_cell_n_on_ray, (struct application *ap, int n));
extern void rt_cut_clean(struct rt_i *rtip);

/* cmd.c */
char *rt_read_cmd( FILE *fp );	/* Read semi-colon terminated line */
int rt_split_cmd(char **argv, int lim, char *lp);
int rt_do_cmd(struct rt_i *rtip, char *lp, const struct command_tab *tp );  /* do cmd from string via cmd table */


/* The database library */

/* wdb.c */
struct rt_wdb *wdb_fopen( const char *filename );
struct rt_wdb *wdb_fopen_v( const char *filename, int version );
struct rt_wdb *wdb_dbopen( struct db_i *dbip, int mode );
int wdb_import(
	struct rt_wdb *wdbp,
	struct rt_db_internal *internp,
	const char *name,
	const mat_t mat );
int wdb_export_external(
	struct rt_wdb *wdbp,
	struct bu_external *ep,
	const char *name,
	int flags,
	unsigned char minor_type);
int wdb_put_internal(
	struct rt_wdb *wdbp,
	const char *name,
	struct rt_db_internal *ip,
	double local2mm );
int wdb_export(
	struct rt_wdb *wdbp,
	const char *name,
	genptr_t gp,
	int id,
	double local2mm );
void wdb_close( struct rt_wdb *wdbp );

/* db_anim.c */
extern struct animate  *db_parse_1anim(struct db_i     *dbip,
				       int             argc,
				       const char      **argv);

extern int db_parse_anim(struct db_i     *dbip,
			 int             argc,
			 const char              **argv);



BU_EXTERN(int db_add_anim, (struct db_i *dbip, struct animate *anp, int root) );
BU_EXTERN(int db_do_anim, (struct animate *anp, mat_t stack, mat_t arc,
	struct mater_info *materp) );
BU_EXTERN(void db_free_anim, (struct db_i *dbip) );
BU_EXTERN(void db_write_anim, (FILE *fop, struct animate *anp));
BU_EXTERN(struct animate	*db_parse_1anim, (struct db_i *dbip,
				int argc, const char **argv));
void			db_free_1anim( struct animate *anp );

/* db_path.c */
void db_full_path_init( struct db_full_path *pathp );
void db_add_node_to_full_path( struct db_full_path *pp, struct directory *dp );
void db_dup_full_path(struct db_full_path *newp,
	const struct db_full_path *oldp );
void db_extend_full_path( struct db_full_path *pathp, int incr );
void db_append_full_path( struct db_full_path *dest, const struct db_full_path *src );
void db_dup_path_tail(struct db_full_path	*newp,
			     const struct db_full_path	*oldp,
			     int			start);
char *db_path_to_string( const struct db_full_path *pp );
void db_path_to_vls( struct bu_vls *str, const struct db_full_path *pp );
void db_pr_full_path( const char *msg, const struct db_full_path *pathp );
int db_string_to_path(struct db_full_path *pp, const struct db_i *dbip, const char *str);
int db_argv_to_path(register struct db_full_path	*pp,
			   struct db_i			*dbip,
			   int				argc,
			   const char			*const*argv);
void db_free_full_path(struct db_full_path *pp);
int db_identical_full_paths( const struct db_full_path *a,
				const struct db_full_path *b );
int db_full_path_subset(
	const struct db_full_path *a,
	const struct db_full_path *b );
int db_full_path_search( const struct db_full_path *a,
	const struct directory *dp );


/* db_open.c */
extern void db_sync( struct db_i	*dbip );

					/* open an existing model database */
BU_EXTERN(struct db_i *db_open, ( const char *name, const char *mode ) );
					/* create a new model database */
struct db_i *db_create( const char *name, int version );
					/* close a model database */
BU_EXTERN(void db_close_client, (struct db_i *dbip, long *client));
BU_EXTERN(void db_close, ( struct db_i *dbip ) );
					/* dump a full copy of a database */
BU_EXTERN(int db_dump, (struct rt_wdb *wdbp, struct db_i *dbip));
BU_EXTERN(struct db_i *db_clone_dbi, (struct db_i *dbip, long *client));
/* db5_alloc.c */

extern int db5_write_free( struct db_i *dbip,
			   struct directory *dp,
			   long length );
extern int db5_realloc( struct db_i *dbip,
			struct directory *dp,
			struct bu_external *ep );

/* db5_io.c */
extern void db5_export_object3 (struct bu_external *out, 
		int				dli,
		const char			*name,
		const unsigned char		hidden,
		const struct bu_external	*attrib,
		const struct bu_external	*body,
		int				major,
		int				minor,
		int				a_zzz,
		int				b_zzz );
extern int rt_db_cvt_to_external5(struct bu_external *ext,
				  const char *name,
				  const struct rt_db_internal *ip,
				  double conv2mm,
				  struct db_i *dbip,
				  struct resource *resp,
				  const int major);

extern int db_wrap_v5_external( struct bu_external *ep, const char *name );

extern int rt_db_get_internal5(struct rt_db_internal	*ip,
			       const struct directory	*dp,
			       const struct db_i	*dbip,
			       const mat_t		mat,
			       struct resource		*resp);
extern int rt_db_put_internal5(struct directory	*dp,
			       struct db_i		*dbip,
			       struct rt_db_internal	*ip,
			       struct resource		*resp,
			       const int		major);

extern void db5_make_free_object_hdr( struct bu_external *ep, long length );
extern void db5_make_free_object( struct bu_external *ep, long length );
extern int db5_decode_signed(long			*lenp,
			     const unsigned char	*cp,
			     int			format);

extern int db5_decode_length(long			*lenp,
			     const unsigned char	*cp,
			     int			format);

extern int db5_select_length_encoding( long len );

extern void db5_import_color_table( char *cp );

extern int db5_import_attributes( struct bu_attribute_value_set *avs,
				  const struct bu_external *ap );

extern int db5_get_raw_internal_fp( struct db5_raw_internal	*rip,
				    FILE			*fp);

extern int db5_header_is_valid( const unsigned char *hp );
#define rt_fwrite_internal5	+++__deprecated_rt_fwrite_internal5__+++
BU_EXTERN(int db5_fwrite_ident, (FILE *, const char *, double));

extern int db5_put_color_table( struct db_i *dbip );
extern int db5_update_ident( struct db_i *dbip, const char *title, double local2mm );
extern int db_put_external5(struct bu_external *ep, struct directory *dp, struct db_i *dbip);
extern int db5_update_attributes( struct directory *dp, struct bu_attribute_value_set *avsp, struct db_i *dbip );
extern int db5_update_attribute( const char *obj_name, const char *aname, const char *value, struct db_i *dbip );
extern int db5_replace_attributes( struct directory *dp, struct bu_attribute_value_set *avsp, struct db_i *dbip );
extern int db5_get_attributes( const struct db_i *dbip, struct bu_attribute_value_set *avs, const struct directory *dp );

/* db_comb.c */
int db_tree_nleaves( const union tree *tp );
struct rt_tree_array *db_flatten_tree(
	struct rt_tree_array	*rt_tree_array,
	union tree		*tp,
	int			op,
	int			avail,
	struct resource		*resp);
int rt_comb_import4(
	struct rt_db_internal		*ip,
	const struct bu_external	*ep,
	const mat_t			matrix,		/* NULL if identity */
	const struct db_i		*dbip,
	struct resource			*resp);
int rt_comb_export4(
	struct bu_external		*ep,
	const struct rt_db_internal	*ip,
	double				local2mm,
	const struct db_i		*dbip,
	struct resource			*resp);
void db_tree_flatten_describe(
	struct bu_vls		*vls,
	const union tree	*tp,
	int			indented,
	int			lvl,
	double			mm2local,
	struct resource		*resp);
void db_tree_describe( 
	struct bu_vls		*vls,
	const union tree	*tp,
	int			indented,
	int			lvl,
	double			mm2local);
void db_comb_describe(
	struct bu_vls	*str,
	const struct rt_comb_internal	*comb,
	int		verbose,
	double		mm2local,
	struct resource	*resp);
void rt_comb_ifree( struct rt_db_internal *ip, struct resource *resp );
int rt_comb_describe(
	struct bu_vls	*str,
	const struct rt_db_internal *ip,
	int		verbose,
	double		mm2local,
	struct resource *resp,
	struct db_i *db_i);
void db_wrap_v4_external( struct bu_external *op, const char *name );
int db_ck_left_heavy_tree(
	const union tree	*tp,
	int			no_unions);
int db_ck_v4gift_tree( const union tree *tp );
union tree *db_mkbool_tree(
	struct rt_tree_array *rt_tree_array,
	int		howfar,
	struct resource	*resp);
union tree *db_mkgift_tree(
	struct rt_tree_array	*trees,
	int			subtreecount,
	struct resource		*resp);

/* g_tgc.c */
extern void rt_pt_sort(register fastf_t t[], int npts);

/* g_ell.c */
extern void rt_ell_16pts(register fastf_t *ov,
			 register fastf_t *V,
			 fastf_t *A,
			 fastf_t *B);


/* roots.c */
extern int rt_poly_roots(bn_poly_t *eqn, bn_complex_t roots[]);


/* db_io.c */
extern int db_write(struct db_i	*dbip,
		    const genptr_t	addr,
		    long		count,
		    long		offset);
extern int db_fwrite_external(FILE			*fp,
			      const char		*name,
			      struct bu_external	*ep);


/* It is normal to test for __STDC__ when using *_DEFINED tests but in
 * in this case "union record" is used for db_getmrec's return type.  This
 * requires that the "union_record *db_getmrec" be used whenever 
 * RECORD_DEFINED is defined.
 */
#if defined(RECORD_DEFINED)
					/* malloc & read records */
BU_EXTERN(union record *db_getmrec, ( const struct db_i *, const struct directory *dp ) );
					/* get several records from db */
BU_EXTERN(int db_get, (const struct db_i *, const struct directory *dp,
	union record *where, int offset, int len ) );
					/* put several records into db */
BU_EXTERN(int db_put, (struct db_i *, const struct directory *dp, union record *where,
	int offset, int len ) );
#else /* RECORD_DEFINED */
					/* malloc & read records */
BU_EXTERN(genptr_t db_getmrec, ( const struct db_i *, const struct directory *dp ) );
					/* get several records from db */
BU_EXTERN(int db_get, (const struct db_i *, const struct directory *dp,
	genptr_t where, int offset, int len ) );
					/* put several records into db */
BU_EXTERN(int db_put, ( const struct db_i *, const struct directory *dp,
	genptr_t where, int offset, int len ) );
#endif /* RECORD_DEFINED */
BU_EXTERN(int db_get_external, ( struct bu_external *ep,
	const struct directory *dp, const struct db_i *dbip ) );
BU_EXTERN(int db_put_external, ( struct bu_external *ep,
	struct directory *dp, struct db_i *dbip ) );
BU_EXTERN(void db_free_external, ( struct bu_external *ep ) );

/* db_scan.c */
					/* read db (to build directory) */
BU_EXTERN(int db_scan, ( struct db_i *,
	int (*handler)BU_ARGS((struct db_i *, const char *name, long addr,
	int nrec, int flags, genptr_t client_data)),
	int do_old_matter, genptr_t client_data ) );
					/* update db unit conversions */
#define db_ident(a,b,c)		+++error+++
int db_update_ident( struct db_i *dbip, const char *title, double local2mm );
int db_fwrite_ident( FILE *fp, const char *title, double local2mm );
BU_EXTERN(void db_conversions, ( struct db_i *, int units ) );
int db_v4_get_units_code( const char *str );

/* db5_scan.c */
extern int db_dirbuild( struct db_i *dbip );
extern struct directory *db5_diradd( struct db_i *dbip, const struct db5_raw_internal *rip, long laddr, genptr_t client_data );
extern int db_get_version( struct db_i *dbip );
extern int db5_scan( struct db_i *dbip, void (*handler)(struct db_i *,
				const struct db5_raw_internal *,
				long addr, genptr_t client_data ), genptr_t client_data );

/* db5_comb.c */
extern int rt_comb_import5( struct rt_db_internal   *ip,
        const struct bu_external *ep,
        const mat_t             mat,
        const struct db_i       *dbip,
        struct resource         *resp,
	const int		minor_type);

/* g_extrude.c */
extern int rt_extrude_import5(
	struct rt_db_internal		*ip,
	const struct bu_external	*ep,
	register const mat_t		mat,
	const struct db_i		*dbip,
	struct resource			*resp,
	const int			minor_type );


/* db_lookup.c */
extern int db_get_directory_size( const struct db_i	*dbip );
void db_ck_directory(const struct db_i *dbip);

extern void db_inmem(struct directory	*dp,
		     struct bu_external	*ext,
		     int		flags,
		     struct db_i	*dbip);

extern int db_is_directory_non_empty( const struct db_i	*dbip);

BU_EXTERN(int db_dirhash, (const char *str) );
BU_EXTERN(int db_dircheck,( struct db_i *dbip, struct bu_vls *ret_name,
			    int noisy, struct directory ***headp ) );
					/* convert name to directory ptr */
BU_EXTERN(struct directory *db_lookup,( const struct db_i *, const char *name, int noisy ) );
					/* lookup directory entries based on attributes */
BU_EXTERN( struct bu_ptbl *db_lookup_by_attr, (struct db_i *dbip, int dir_flags, struct bu_attribute_value_set *avs, int op ) );
					/* add entry to directory */
BU_EXTERN(struct directory *db_diradd, ( struct db_i *, const char *name, long laddr,
	int len, int flags, genptr_t ptr ) );
BU_EXTERN(struct directory *db_diradd5, (struct db_i *dbip, const char *name,
	   long					laddr,
	   unsigned char			major_type,
	   unsigned char 			minor_type,
	   unsigned char			name_hidden,
	   long					object_length,
	   struct bu_attribute_value_set	*avs));

					/* delete entry from directory */
BU_EXTERN(int db_dirdelete, ( struct db_i *, struct directory *dp ) );
BU_EXTERN(int db_fwrite_ident, (FILE *, const char *, double));
BU_EXTERN(void db_pr_dir, ( const struct db_i *dbip ) );
BU_EXTERN(int db_rename, ( struct db_i *, struct directory *, const char *newname) );


/* db_match.c */
extern void db_update_nref( struct db_i *dbip, struct resource *resp );

BU_EXTERN(int db_regexp_match, (const char *pattern, const char *string));
BU_EXTERN(int db_regexp_match_all, (struct bu_vls *dest, struct db_i *dbip, const char *pattern));

/* db_alloc.c */
extern int db_flags_internal( const struct rt_db_internal *intern);

					/* allocate "count" granules */
BU_EXTERN(int db_alloc, ( struct db_i *, struct directory *dp, int count ) );
					/* delete "recnum" from entry */
BU_EXTERN(int db_delrec, ( struct db_i *, struct directory *dp, int recnum ) );
					/* delete all granules assigned dp */
BU_EXTERN(int db_delete, ( struct db_i *, struct directory *dp ) );
					/* write FREE records from 'start' */
BU_EXTERN(int db_zapper, ( struct db_i *, struct directory *dp, int start ) );

/* db_tree.c */
void db_dup_db_tree_state(struct db_tree_state *otsp, const struct db_tree_state *itsp);
void db_free_db_tree_state( struct db_tree_state *tsp );
void db_init_db_tree_state( struct db_tree_state *tsp, struct db_i *dbip, struct resource *resp );
BU_EXTERN(struct combined_tree_state *db_new_combined_tree_state,
	(const struct db_tree_state *tsp, const struct db_full_path *pathp));
BU_EXTERN(struct combined_tree_state *db_dup_combined_tree_state,
	(const struct combined_tree_state *old));
BU_EXTERN(void db_free_combined_tree_state,
	(struct combined_tree_state *ctsp));
BU_EXTERN(void db_pr_tree_state, (const struct db_tree_state *tsp));
BU_EXTERN(void db_pr_combined_tree_state,
	(const struct combined_tree_state *ctsp));
BU_EXTERN(int db_apply_state_from_comb, (struct db_tree_state *tsp,
	const struct db_full_path *pathp, const struct rt_comb_internal *comb));
BU_EXTERN(int db_apply_state_from_memb, (struct db_tree_state *tsp,
	struct db_full_path *pathp, const union tree *tp));
int db_apply_state_from_one_member( struct db_tree_state *tsp,
	struct db_full_path *pathp, const char *cp, int sofar,
	const union tree *tp );
union tree *db_find_named_leaf( union tree *tp, const char *cp );
union tree *db_find_named_leafs_parent( int *side, union tree *tp, const char *cp );
void db_tree_del_lhs( union tree *tp, struct resource *resp );
void db_tree_del_rhs( union tree *tp, struct resource *resp );
int db_tree_del_dbleaf(union tree **tp, const char *cp, struct resource *resp);
void db_tree_mul_dbleaf( union tree *tp, const mat_t mat );
void db_tree_funcleaf(
	struct db_i		*dbip,
	struct rt_comb_internal	*comb,
	union tree		*comb_tree,
	void			(*leaf_func)(),
	genptr_t		user_ptr1,
	genptr_t		user_ptr2,
	genptr_t		user_ptr3 );
int
db_follow_path(
	struct db_tree_state		*tsp,
	struct db_full_path		*total_path,
	const struct db_full_path	*new_path,
	int				noisy,
	int				depth );
BU_EXTERN(int db_follow_path_for_state, (struct db_tree_state *tsp,
	struct db_full_path *pathp, const char *orig_str, int noisy));
BU_EXTERN(union tree *db_recurse, (struct db_tree_state	*tsp,
	struct db_full_path *pathp,
	struct combined_tree_state **region_start_statepp, genptr_t client_data));
union tree *db_dup_subtree( const union tree *tp, struct resource *resp );
void db_ck_tree( const union tree *tp );
void db_free_tree( union tree *tp, struct resource *resp );
void db_left_hvy_node( union tree *tp );
void db_non_union_push( union tree *tp, struct resource *resp );
int db_count_tree_nodes( const union tree *tp, int count );
int db_is_tree_all_unions( const union tree *tp );
int db_count_subtree_regions( const union tree *tp );
int db_tally_subtree_regions(
	union tree	*tp,
	union tree	**reg_trees,
	int		cur,
	int		lim,
	struct resource *resp);
BU_EXTERN(int db_walk_tree, (struct db_i *dbip, int argc, const char **argv,
	int ncpu, const struct db_tree_state *init_state,
	int (*reg_start_func) (
		struct db_tree_state * /*tsp*/,
		struct db_full_path * /*pathp*/,
		const struct rt_comb_internal * /* combp */,
		genptr_t client_data ),
	union tree * (*reg_end_func) (
		struct db_tree_state * /*tsp*/,
		struct db_full_path * /*pathp*/,
		union tree * /*curtree*/,
		genptr_t client_data ),
	union tree * (*leaf_func) (
		struct db_tree_state * /*tsp*/,
		struct db_full_path * /*pathp*/,
		struct rt_db_internal * /*ip*/,
		genptr_t client_data ),
	genptr_t client_data ));
int db_path_to_mat(
	struct db_i		*dbip,
	struct db_full_path	*pathp,
	mat_t			mat,		/* result */
	int			depth,		/* number of arcs */
	struct resource		*resp);
BU_EXTERN(void db_apply_anims, (struct db_full_path *pathp,
	struct directory *dp, mat_t stck, mat_t arc,
	struct mater_info *materp));
/* XXX db_shader_mat, should be called rt_shader_mat */
int db_region_mat(
	mat_t		m,		/* result */
	struct db_i	*dbip,
	const char	*name,
	struct resource *resp);
int db_shader_mat(
	mat_t			model_to_shader,	/* result */
	const struct rt_i	*rtip,
	const struct region	*rp,
	point_t			p_min,	/* input/output: shader/region min point */
	point_t			p_max,	/* input/output: shader/region max point */
	struct resource		*resp);

/* dir.c */
extern struct rt_i *rt_dirbuild( const char *filename, char *buf, int len );
int rt_db_get_internal(
	struct rt_db_internal	*ip,
	const struct directory	*dp,
	const struct db_i	*dbip,
	const mat_t		mat,
	struct resource		*resp);
int rt_db_put_internal(
	struct directory	*dp,
	struct db_i		*dbip,
	struct rt_db_internal	*ip,
	struct resource		*resp);
extern int rt_fwrite_internal( FILE *fp, const char *name, const struct rt_db_internal *ip, double conv2mm );
extern void rt_db_free_internal( struct rt_db_internal *ip, struct resource *resp );
int rt_db_lookup_internal (
	struct db_i *dbip,
	const char *obj_name,
	struct directory **dpp,
	struct rt_db_internal *ip,
	int noisy,
	struct resource *resp);
extern void rt_optim_tree(register union tree *tp,
			  struct resource *resp);
void db_get_directory(register struct resource *resp);

/* db_walk.c */
BU_EXTERN(void db_functree, (struct db_i *dbip, struct directory *dp,
	void (*comb_func)(struct db_i *, struct directory *, genptr_t),
	void (*leaf_func)(struct db_i *, struct directory *, genptr_t),
	struct resource *resp,
	genptr_t client_data));

/* g_arb.c */
int rt_arb_get_cgtype();		/* needs rt_arb_internal for arg list */
int rt_arb_std_type( const struct rt_db_internal *ip, const struct bn_tol *tol );
void rt_arb_centroid();			/* needs rt_arb_internal for arg list */
int rt_arb_calc_points();		/* needs wdb.h for arg list */
int rt_arb_3face_intersect(
	point_t			point,
	const plane_t		planes[6],
	int			type,		/* 4..8 */
	int			loc);

/* g_epa.c */
BU_EXTERN(void rt_ell, (fastf_t *ov, const fastf_t *V, const fastf_t *A,
			const fastf_t *B, int sides) );

/* g_pipe.c */
void rt_vls_pipept(
	struct bu_vls *vp,
	int seg_no,
	const struct rt_db_internal *ip,
	double mm2local);
void rt_pipept_print();		/* needs wdb_pipept for arg */
int rt_pipe_ck( const struct bu_list *headp );

/* g_rpc.c */
BU_EXTERN(int rt_mk_parabola, (struct rt_pt_node *pts, fastf_t r, fastf_t b, fastf_t dtol, fastf_t ntol));
BU_EXTERN(struct rt_pt_node *rt_ptalloc, () );

/* memalloc.c -- non PARALLEL routines */
BU_EXTERN(unsigned long rt_memalloc, (struct mem_map **pp, unsigned size) );
BU_EXTERN(struct mem_map * rt_memalloc_nosplit, (struct mem_map **pp, unsigned size) );
BU_EXTERN(unsigned long rt_memget, (struct mem_map **pp, unsigned int size,
	unsigned int place) );
BU_EXTERN(void rt_memfree, (struct mem_map **pp, unsigned size, unsigned long addr) );
BU_EXTERN(void rt_mempurge, (struct mem_map **pp) );
BU_EXTERN(void rt_memprint, (struct mem_map **pp) );
BU_EXTERN(void rt_memclose,() );

BU_EXTERN(struct bn_vlblock *rt_vlblock_init, () );
BU_EXTERN(void rt_vlblock_free, (struct bn_vlblock *vbp) );
BU_EXTERN(struct bu_list *rt_vlblock_find, (struct bn_vlblock *vbp,
	int r, int g, int b) );

/* g_ars.c */
BU_EXTERN(void rt_hitsort, (struct hit h[], int nh));

/* g_pg.c */
int rt_pg_to_bot( struct rt_db_internal *ip, const struct bn_tol *tol, struct resource *resp );
int rt_pg_plot(struct bu_list		*vhead,
	       struct rt_db_internal	*ip,
	       const struct rt_tess_tol *ttol,
	       const struct bn_tol		*tol); 
int rt_pg_plot_poly(struct bu_list		*vhead,
		    struct rt_db_internal	*ip,
		    const struct rt_tess_tol *ttol,
		    const struct bn_tol		*tol);

/* g_hf.c */
int rt_hf_to_dsp(struct rt_db_internal *db_intern, struct resource *resp);

/* g_dsp.c */
BU_EXTERN(int dsp_pos, (point_t out, struct soltab *stp, point_t p));

/* pr.c */
BU_EXTERN(void rt_pr_soltab, (const struct soltab *stp));
BU_EXTERN(void rt_pr_region, (const struct region *rp));
BU_EXTERN(void rt_pr_partitions, (const struct rt_i *rtip,
	const struct partition	*phead, const char *title));
BU_EXTERN(void rt_pr_pt_vls, (struct bu_vls *v,
	const struct rt_i *rtip, const struct partition *pp));
BU_EXTERN(void rt_pr_pt, (const struct rt_i *rtip, const struct partition *pp));
BU_EXTERN(void rt_pr_seg_vls, (struct bu_vls *, const struct seg *));
BU_EXTERN(void rt_pr_seg, (const struct seg *segp));
BU_EXTERN(void rt_pr_hit, (const char *str, const struct hit	*hitp));
BU_EXTERN(void rt_pr_hit_vls, (struct bu_vls *v, const char *str,
	const struct hit *hitp));
BU_EXTERN(void rt_pr_hitarray_vls, (struct bu_vls *v, const char *str,
	const struct hit *hitp, int count));
BU_EXTERN(void rt_pr_tree, (const union tree *tp, int lvl));
BU_EXTERN(void rt_pr_tree_vls, (struct bu_vls *vls, const union tree *tp));
BU_EXTERN(char *rt_pr_tree_str, (const union tree *tree));
BU_EXTERN(void rt_pr_tree_val, (const union tree *tp,
	const struct partition *partp, int pr_name, int lvl));
BU_EXTERN(void rt_pr_fallback_angle, (struct bu_vls *str, const char *prefix,
	const double angles[5]));
BU_EXTERN(void rt_find_fallback_angle, (double angles[5], const vect_t vec));
BU_EXTERN(void rt_pr_tol, (const struct bn_tol	*tol));

/* regionfix.c */
BU_EXTERN(void rt_regionfix, (struct rt_i *rtip));

/* table.c */
BU_EXTERN(int rt_id_solid, (struct bu_external *ep));
BU_EXTERN(const struct rt_functab *rt_get_functab_by_label, (const char *label));
int rt_generic_xform(
	struct rt_db_internal	*op,
	const mat_t		mat,
	struct rt_db_internal	*ip,
	int			avail,
	struct db_i		*dbip,
	struct resource		*resp);

void rt_nul_make(const struct rt_functab *ftp,
		 struct rt_db_internal *intern,
		 double diameter);

/* prep.c */
BU_EXTERN(void rt_plot_all_bboxes, (FILE *fp, struct rt_i *rtip));
void
rt_plot_all_solids(
	FILE		*fp,
	struct rt_i	*rtip,
	struct resource	*resp);
void rt_init_resource(
	struct resource *resp,
	int		cpu_num,
	struct rt_i	*rtip);
BU_EXTERN(void rt_clean_resource, (struct rt_i *rtip, struct resource *resp));
extern int rt_unprep( struct rt_i *rtip, struct rt_reprep_obj_list *objs, struct resource *resp );
extern int rt_reprep( struct rt_i *rtip, struct rt_reprep_obj_list *objs, struct resource *resp );
extern int re_prep_solids( struct rt_i *rtip, int num_solids, char **solid_names, struct resource *resp );
extern int rt_find_paths( struct db_i *dbip,
	       struct directory *start,
	       struct directory *end,
	       struct bu_ptbl *paths,
	       struct resource *resp );
extern struct bu_bitv *get_solidbitv( long nbits, struct resource *resp );

/* shoot.c */
BU_EXTERN(void rt_add_res_stats, (struct rt_i *rtip, struct resource *resp) );
					/* Tally stats into struct rt_i */
extern void rt_zero_res_stats( struct resource *resp );
extern void rt_res_pieces_clean(struct resource *resp,
			   struct rt_i *rtip);
extern void rt_res_pieces_init( struct resource *resp, struct rt_i *rtip );
extern void rt_vstub(struct soltab	       *stp[],
		     struct xray		*rp[],
		     struct  seg            segp[],
		     int		  	    n,
		     struct application	*ap);


/* tree.c */
extern int rt_bound_tree( const union tree	*tp,
			  vect_t		tree_min,
			  vect_t		tree_max);
int rt_tree_elim_nops(union tree *, struct resource *resp);


/* vlist.c */
/* XXX Has some stuff mixed in here that should go in LIBBN */
struct bn_vlblock *
bn_vlblock_init(
	struct bu_list	*free_vlist_hd,		/* where to get/put free vlists */
	int		max_ent);
BU_EXTERN(struct bn_vlblock *	rt_vlblock_init, () );
BU_EXTERN(void			rt_vlblock_free, (struct bn_vlblock *vbp) );
BU_EXTERN(struct bu_list *	rt_vlblock_find, (struct bn_vlblock *vbp,
				int r, int g, int b) );
int rt_ck_vlist( const struct bu_list *vhead );
void rt_vlist_copy( struct bu_list *dest, const struct bu_list *src );
void bn_vlist_cleanup( struct bu_list *hd );
BU_EXTERN(void			rt_vlist_cleanup, () );
void bn_vlist_rpp( struct bu_list *hd, const point_t minn, const point_t maxx );
BU_EXTERN(void			rt_vlist_export, (struct bu_vls *vls,
				struct bu_list *hp,
				const char *name));
BU_EXTERN(void			rt_vlist_import, (struct bu_list *hp,
				struct bu_vls *namevls,
				const unsigned char *buf));
BU_EXTERN(void			rt_plot_vlblock, (FILE *fp,
				const struct bn_vlblock	*vbp) );
BU_EXTERN(void			rt_vlist_to_uplot, (FILE *fp,
				const struct bu_list *vhead));
BU_EXTERN(int			rt_process_uplot_value,
				(struct bu_list **vhead, struct bn_vlblock *vbp,
				FILE *fp, int c, double char_size) );
BU_EXTERN(int			rt_uplot_to_vlist, (struct bn_vlblock *vbp,
				FILE *fp, double char_size) );
BU_EXTERN(void			rt_label_vlist_verts, (struct bn_vlblock *vbp,
				struct bu_list *src, mat_t mat,
				double sz, double mm2local) );

#ifdef SEEN_RTGEOM_H
/* g_sketch.c */
extern void rt_sketch_ifree( struct rt_db_internal	*ip );
extern int curve_to_vlist(struct bu_list		*vhead,
			  const struct rt_tess_tol	*ttol,
			  point_t			V,
			  vect_t			u_vec,
			  vect_t			v_vec,
			  struct rt_sketch_internal *sketch_ip,
			  struct curve			*crv);

extern int rt_check_curve( struct curve *crv,
			   struct rt_sketch_internal *skt,
			   int noisey);

extern void rt_curve_reverse_segment( long *lng );
extern void rt_curve_order_segments( struct curve *crv );

extern void rt_copy_curve(struct curve *crv_out, const struct curve *crv_in);

BU_EXTERN(int				rt_check_curve,
					(struct curve *crv,
					struct rt_sketch_internal *skt,
					int noisey));
BU_EXTERN(void				rt_curve_free, (struct curve *crv));
BU_EXTERN(void				rt_copy_curve,
					(struct curve *crv_out,
					const struct curve *crv_in));
BU_EXTERN(struct rt_sketch_internal	*rt_copy_sketch,
					(const struct rt_sketch_internal *sketch_ip));
BU_EXTERN(int				curve_to_tcl_list,
					(struct bu_vls *vls, struct curve *crv));
#endif

/* htbl.c */
BU_EXTERN(void			rt_htbl_init, (struct rt_htbl *b, int len, const char *str));
BU_EXTERN(void			rt_htbl_reset, (struct rt_htbl *b));
BU_EXTERN(void			rt_htbl_free, (struct rt_htbl *b));
BU_EXTERN(struct hit *		rt_htbl_get, (struct rt_htbl *b));

/************************************************************************
 *									*
 *			N M G Support Function Declarations		*
 *									*
 ************************************************************************/
#if defined(NMG_H)

/* From file nmg_mk.c */
/*	MAKE routines */
BU_EXTERN(struct model		*nmg_mm, () );
BU_EXTERN(struct model		*nmg_mmr, () );
BU_EXTERN(struct nmgregion	*nmg_mrsv, (struct model *m) );
BU_EXTERN(struct shell 		*nmg_msv, (struct nmgregion *r_p) );
BU_EXTERN(struct faceuse	*nmg_mf, (struct loopuse *lu1) );
BU_EXTERN(struct loopuse	*nmg_mlv, (long *magic, struct vertex *v, int orientation) );
BU_EXTERN(struct edgeuse	*nmg_me, (struct vertex *v1, struct vertex *v2, struct shell *s) );
BU_EXTERN(struct edgeuse	*nmg_meonvu, (struct vertexuse *vu) );
BU_EXTERN(struct loopuse	*nmg_ml, (struct shell *s) );
/*	KILL routines */
extern int nmg_keg( struct edgeuse	*eu);
BU_EXTERN(int			nmg_kvu, (struct vertexuse *vu) );
BU_EXTERN(int			nmg_kfu, (struct faceuse *fu1) );
BU_EXTERN(int			nmg_klu, (struct loopuse *lu1) );
BU_EXTERN(int			nmg_keu, (struct edgeuse *eu) );
BU_EXTERN(int			nmg_ks, (struct shell *s) );
BU_EXTERN(int			nmg_kr, (struct nmgregion *r) );
BU_EXTERN(void			nmg_km, (struct model *m) );
/*	Geometry and Attribute routines */
BU_EXTERN(void			nmg_vertex_gv, (struct vertex *v, const point_t pt) );
BU_EXTERN(void			nmg_vertex_g, (struct vertex *v, fastf_t x, fastf_t y, fastf_t z) );
BU_EXTERN(void			nmg_vertexuse_nv, (struct vertexuse *vu, const vect_t norm));
BU_EXTERN(void			nmg_vertexuse_a_cnurb, (struct vertexuse *vu, const fastf_t *uvw));
BU_EXTERN(void			nmg_edge_g, (struct edgeuse *eu) );
BU_EXTERN(void			nmg_edge_g_cnurb, (struct edgeuse *eu,
				int order, int n_knots, fastf_t *kv,
				int n_pts, int pt_type, fastf_t *points));
BU_EXTERN(void			nmg_edge_g_cnurb_plinear, (struct edgeuse *eu));
BU_EXTERN(int			nmg_use_edge_g, (struct edgeuse *eu, long *eg) );
BU_EXTERN(void			nmg_loop_g, (struct loop *l, const struct bn_tol *tol) );
BU_EXTERN(void			nmg_face_g, (struct faceuse *fu, const plane_t p) );
BU_EXTERN(void			nmg_face_new_g, (struct faceuse *fu, const plane_t pl));
BU_EXTERN(void			nmg_face_g_snurb, (struct faceuse *fu,
				int u_order, int v_order,
				int n_u_knots, int n_v_knots,
				fastf_t *ukv, fastf_t *vkv,
				int n_rows, int n_cols,
				int pt_type, fastf_t *mesh));
BU_EXTERN(void			nmg_face_bb, (struct face *f, const struct bn_tol *tol) );
BU_EXTERN(void			nmg_shell_a, (struct shell *s, const struct bn_tol *tol) );
BU_EXTERN(void			nmg_region_a, (struct nmgregion *r, const struct bn_tol *tol) );
/*	DEMOTE routines */
BU_EXTERN(int			nmg_demote_lu, (struct loopuse *lu) );
BU_EXTERN(int			nmg_demote_eu, (struct edgeuse *eu) );
/*	MODIFY routines */
BU_EXTERN(void			nmg_movevu, (struct vertexuse *vu, struct vertex *v) );
#define nmg_moveeu(a,b)		nmg_je(a,b)
BU_EXTERN(void			nmg_je, (struct edgeuse *eudst, struct edgeuse *eusrc) );
BU_EXTERN(void			nmg_unglueedge, (struct edgeuse *eu) );
BU_EXTERN(void			nmg_jv, (struct vertex *v1, struct vertex *v2) );
BU_EXTERN(void			nmg_jfg, (struct face *f1, struct face *f2));
BU_EXTERN(void			nmg_jeg, (struct edge_g_lseg *dest_eg,
				struct edge_g_lseg *src_eg) );

/* From nmg_mod.c */
/*	REGION Routines */
BU_EXTERN(void			nmg_merge_regions,
				(struct nmgregion *r1,
				struct nmgregion *r2,
				const struct bn_tol *tol));

/*	SHELL Routines */
BU_EXTERN(void			nmg_shell_coplanar_face_merge,
				(struct shell		*s,
				const struct bn_tol	*tol,
				const int		simplify));
BU_EXTERN(int			nmg_simplify_shell, (struct shell *s) );
BU_EXTERN(void			nmg_rm_redundancies, (struct shell *s, const struct bn_tol *tol ) );
BU_EXTERN(void			nmg_sanitize_s_lv, (struct shell *s,
				int orient) );
BU_EXTERN(void			nmg_s_split_touchingloops, (struct shell *s,
				const struct bn_tol *tol) );
BU_EXTERN(void			nmg_s_join_touchingloops,
				(struct shell		*s,
				const struct bn_tol	*tol));
BU_EXTERN(void			nmg_js,
				(struct shell	*s1, struct shell	*s2,
				const struct bn_tol	*tol));
BU_EXTERN(void			nmg_invert_shell,
				(struct shell		*s,
				const struct bn_tol	*tol));

/*	FACE Routines */
BU_EXTERN(struct faceuse	*nmg_cmface, (struct shell *s, struct vertex **vt[], int n) );
BU_EXTERN(struct faceuse	*nmg_cface, (struct shell *s, struct vertex **vt,	int n) );
BU_EXTERN(struct faceuse	*nmg_add_loop_to_face, (struct shell *s, struct faceuse *fu, struct vertex **verts, int n, int dir) );
BU_EXTERN(int			nmg_fu_planeeqn, (struct faceuse *fu, const struct bn_tol *tol) );
BU_EXTERN(void			nmg_gluefaces, (struct faceuse *fulist[], int n, const struct bn_tol *tol) );
BU_EXTERN(int			nmg_simplify_face, (struct faceuse *fu) );
BU_EXTERN(void			nmg_reverse_face, (struct faceuse *fu) );
BU_EXTERN(void			nmg_mv_fu_between_shells, (struct shell *dest,
				struct shell *src, struct faceuse *fu) );
BU_EXTERN(void			nmg_jf, (struct faceuse *dest_fu,
				struct faceuse *src_fu) );
BU_EXTERN(struct faceuse	*nmg_dup_face, (struct faceuse *fu, struct shell *s) );
/*	LOOP Routines */
BU_EXTERN(void			nmg_jl, (struct loopuse *lu, struct edgeuse *eu) );
BU_EXTERN(struct vertexuse	*nmg_join_2loops, (struct vertexuse *vu1, struct vertexuse *vu2) );
BU_EXTERN(struct vertexuse	*nmg_join_singvu_loop, (struct vertexuse *vu1, struct vertexuse *vu2) );
BU_EXTERN(struct vertexuse	*nmg_join_2singvu_loops, (struct vertexuse *vu1, struct vertexuse *vu2) );
BU_EXTERN(struct loopuse	*nmg_cut_loop, (struct vertexuse *vu1, struct vertexuse *vu2) );
BU_EXTERN(struct loopuse	*nmg_split_lu_at_vu, (struct loopuse *lu, struct vertexuse *vu) );
BU_EXTERN(struct vertexuse	*nmg_find_repeated_v_in_lu, (struct vertexuse	*vu));
BU_EXTERN(void			nmg_split_touchingloops, (struct loopuse *lu,
				const struct bn_tol *tol) );
BU_EXTERN(int			nmg_join_touchingloops, (struct loopuse *lu) );
BU_EXTERN(int			nmg_get_touching_jaunts,
				(const struct loopuse *lu,
				struct bu_ptbl *tbl,
				int *need_init));
BU_EXTERN(void			nmg_kill_accordions, (struct loopuse *lu));
BU_EXTERN(int			nmg_loop_split_at_touching_jaunt,
				(struct loopuse		*lu,
				const struct bn_tol	*tol));
BU_EXTERN(void			nmg_simplify_loop, (struct loopuse *lu) );
BU_EXTERN(int			nmg_kill_snakes, (struct loopuse *lu) );
BU_EXTERN(void			nmg_mv_lu_between_shells, (struct shell *dest,
				struct shell *src, struct loopuse *lu) );
BU_EXTERN(void	 		nmg_moveltof, (struct faceuse *fu, struct shell *s) );
BU_EXTERN(struct loopuse	*nmg_dup_loop, (struct loopuse *lu,
				long *parent, long **trans_tbl) );
BU_EXTERN(void			nmg_set_lu_orientation, (struct loopuse *lu, int is_opposite) );
BU_EXTERN(void			nmg_lu_reorient, (struct loopuse *lu ) );
/*	EDGE Routines */
BU_EXTERN(struct edgeuse	*nmg_eusplit, (struct vertex *v, struct edgeuse *oldeu, int share_geom) );
BU_EXTERN(struct edgeuse	*nmg_esplit, (struct vertex *v, struct edgeuse *eu, int share_geom) );
BU_EXTERN(struct edgeuse	*nmg_ebreak, (struct vertex *v, struct edgeuse *eu));
BU_EXTERN(struct edgeuse	*nmg_ebreaker, (struct vertex *v,
				struct edgeuse *eu, const struct bn_tol *tol));
BU_EXTERN(struct vertex		*nmg_e2break, (struct edgeuse *eu1, struct edgeuse *eu2) );
BU_EXTERN(int			nmg_unbreak_edge, (struct edgeuse *eu1_first));
BU_EXTERN(int			nmg_unbreak_shell_edge_unsafe,
				(struct edgeuse	*eu1_first));
BU_EXTERN(struct edgeuse	*nmg_eins, (struct edgeuse *eu) );
BU_EXTERN(void			nmg_mv_eu_between_shells, (struct shell *dest,
				struct shell *src, struct edgeuse *eu) );
/*	VERTEX Routines */
BU_EXTERN(void			nmg_mv_vu_between_shells, (struct shell *dest,
				struct shell *src, struct vertexuse *vu) );

/* From nmg_info.c */
	/* Model routines */
BU_EXTERN(struct model		*nmg_find_model, (const long *magic_p) );
BU_EXTERN(void			nmg_model_bb, (point_t min_pt, point_t max_pt, const struct model *m) );


	/* Shell routines */
BU_EXTERN(int			nmg_shell_is_empty, (const struct shell *s) );
BU_EXTERN(struct shell		*nmg_find_s_of_lu, (const struct loopuse *lu) );
BU_EXTERN(struct shell		*nmg_find_s_of_eu, (const struct edgeuse *eu) );
BU_EXTERN(struct shell		*nmg_find_s_of_vu, (const struct vertexuse *vu) );

	/* Face routines */
BU_EXTERN(struct faceuse	*nmg_find_fu_of_eu, (const struct edgeuse *eu));
BU_EXTERN(struct faceuse	*nmg_find_fu_of_lu, (const struct loopuse *lu));
BU_EXTERN(struct faceuse	*nmg_find_fu_of_vu, (const struct vertexuse *vu) );
BU_EXTERN(struct faceuse	*nmg_find_fu_with_fg_in_s, (const struct shell *s1,
				const struct faceuse *fu2));
BU_EXTERN(double		nmg_measure_fu_angle, (const struct edgeuse *eu,
				const vect_t xvec, const vect_t yvec,
				const vect_t zvec) );

	/* Loop routines */
BU_EXTERN(struct loopuse	*nmg_find_lu_of_vu, (const struct vertexuse *vu) );
BU_EXTERN(int			nmg_loop_is_a_crack, (const struct loopuse *lu) );
BU_EXTERN(int			nmg_loop_is_ccw, (const struct loopuse *lu,
				const plane_t norm, const struct bn_tol *tol) );
BU_EXTERN(const struct vertexuse *nmg_loop_touches_self, (const struct loopuse *lu));
BU_EXTERN(int			nmg_2lu_identical, (const struct edgeuse *eu1,
				const struct edgeuse *eu2));

	/* Edge routines */
BU_EXTERN(struct edgeuse	*nmg_find_matching_eu_in_s, (const struct edgeuse	*eu1,
				const struct shell	*s2));
BU_EXTERN(struct edgeuse	*nmg_findeu, (const struct vertex *v1, const struct vertex *v2,
				const struct shell *s, const struct edgeuse *eup,
				int dangling_only) );
BU_EXTERN(struct edgeuse	*nmg_find_eu_in_face, (const struct vertex *v1,
				const struct vertex *v2, const struct faceuse *fu,
				const struct edgeuse *eup, int dangling_only));
BU_EXTERN(struct edgeuse	*nmg_find_e, (const struct vertex *v1,
				const struct vertex *v2,
				const struct shell *s,
				const struct edge *ep));
BU_EXTERN(struct edgeuse	*nmg_find_eu_of_vu, (const struct vertexuse *vu) );
BU_EXTERN(struct edgeuse	*nmg_find_eu_with_vu_in_lu, (const struct loopuse *lu,
				const struct vertexuse *vu) );
BU_EXTERN(const struct edgeuse	*nmg_faceradial, (const struct edgeuse *eu) );
BU_EXTERN(const struct edgeuse	*nmg_radial_face_edge_in_shell, (const struct edgeuse *eu) );
BU_EXTERN(const struct edgeuse *nmg_find_edge_between_2fu, (const struct faceuse *fu1,
				const struct faceuse *fu2, const struct bn_tol *tol));
BU_EXTERN(struct edge		*nmg_find_e_nearest_pt2, (long *magic_p,
				const point_t pt2, const mat_t mat,
				const struct bn_tol *tol) );
BU_EXTERN(struct edgeuse	*nmg_find_matching_eu_in_s, (
				const struct edgeuse *eu1, const struct shell *s2));
BU_EXTERN(void			nmg_eu_2vecs_perp, (vect_t xvec, vect_t yvec,
				vect_t zvec, const struct edgeuse *eu,
				const struct bn_tol *tol) );
BU_EXTERN(int			nmg_find_eu_leftvec, (vect_t left,
				const struct edgeuse *eu) );
BU_EXTERN(int			nmg_find_eu_left_non_unit, (vect_t left,
				const struct edgeuse	*eu));
BU_EXTERN(struct edgeuse	*nmg_find_ot_same_eu_of_e,
				(const struct edge *e));

	/* Vertex routines */
BU_EXTERN(struct vertexuse	*nmg_find_v_in_face, (const struct vertex *,
				const struct faceuse *) );
BU_EXTERN(struct vertexuse	*nmg_find_v_in_shell, (const struct vertex *v,
				const struct shell *s, int edges_only));
BU_EXTERN(struct vertexuse	*nmg_find_pt_in_lu, (const struct loopuse *lu,
				const point_t pt, const struct bn_tol *tol));
BU_EXTERN(struct vertexuse	*nmg_find_pt_in_face, (const struct faceuse *fu,
				const point_t pt,
				const struct bn_tol *tol) );
BU_EXTERN(struct vertex		*nmg_find_pt_in_shell, (const struct shell *s,
				const point_t pt, const struct bn_tol *tol) );
BU_EXTERN(struct vertex		*nmg_find_pt_in_model, (const struct model *m,
				const point_t pt, const struct bn_tol *tol));
BU_EXTERN(int			nmg_is_vertex_in_edgelist, (const struct vertex *v,
				const struct bu_list *hd) );
BU_EXTERN(int			nmg_is_vertex_in_looplist, (const struct vertex *v,
				const struct bu_list *hd, int singletons) );
BU_EXTERN(struct vertexuse 	*nmg_is_vertex_in_face, (const struct vertex *v,
				const struct face *f));
BU_EXTERN(int			nmg_is_vertex_a_selfloop_in_shell, (const struct vertex *v,
				const struct shell *s) );
BU_EXTERN(int			nmg_is_vertex_in_facelist, (const struct vertex *v,
				const struct bu_list *hd) );
BU_EXTERN(int			nmg_is_edge_in_edgelist, (const struct edge *e,
				const struct bu_list *hd) );
BU_EXTERN(int			nmg_is_edge_in_looplist, (const struct edge *e,
				const struct bu_list *hd) );
BU_EXTERN(int			nmg_is_edge_in_facelist, (const struct edge *e,
				const struct bu_list *hd) );
BU_EXTERN(int			nmg_is_loop_in_facelist, (const struct loop *l,
				const struct bu_list *fu_hd) );

	/* Tabulation routines */
BU_EXTERN(void			nmg_vertex_tabulate, (struct bu_ptbl *tab,
				const long *magic_p));
BU_EXTERN(void			nmg_vertexuse_normal_tabulate, (struct bu_ptbl *tab,
				const long		*magic_p));
BU_EXTERN(void			nmg_edgeuse_tabulate, (struct bu_ptbl *tab,
				const long *magic_p));
BU_EXTERN(void			nmg_edge_tabulate, (struct bu_ptbl *tab,
				const long *magic_p));
BU_EXTERN(void			nmg_edge_g_tabulate, (struct bu_ptbl *tab,
				const long		*magic_p));
BU_EXTERN(void			nmg_face_tabulate, (struct bu_ptbl *tab,
				const long *magic_p));
BU_EXTERN(void			nmg_edgeuse_with_eg_tabulate, (struct bu_ptbl *tab,
				const struct edge_g_lseg *eg));
BU_EXTERN(void			nmg_edgeuse_on_line_tabulate,
				(struct bu_ptbl		*tab,
				const long		*magic_p,
				const point_t		pt,
				const vect_t		dir,
				const struct bn_tol	*tol));
BU_EXTERN(void			nmg_e_and_v_tabulate,
				(struct bu_ptbl		*eutab,
				struct bu_ptbl		*vtab,
				const long		*magic_p));
BU_EXTERN(int			nmg_2edgeuse_g_coincident,
				(const struct edgeuse	*eu1,
				const struct edgeuse	*eu2,
				const struct bn_tol	*tol));

/* From nmg_extrude.c */
BU_EXTERN(void			nmg_translate_face, (struct faceuse *fu,
				const vect_t		Vec,
				const struct bn_tol	*tol));
BU_EXTERN(int			nmg_extrude_face, (struct faceuse *fu,
				const vect_t Vec,
				const struct bn_tol	*tol));
BU_EXTERN(struct vertexuse	*nmg_find_vertex_in_lu, (const struct vertex *v,
				const struct loopuse *lu));
BU_EXTERN(void			nmg_fix_overlapping_loops, (struct shell *s,
				const struct bn_tol *tol));
BU_EXTERN(void			nmg_break_crossed_loops, (struct shell *is,
				const struct bn_tol *tol));
BU_EXTERN(struct shell		*nmg_extrude_cleanup, (struct shell *is,
				const int is_void,
				const struct bn_tol *tol));
BU_EXTERN(void			nmg_hollow_shell, (struct shell *s,
				const fastf_t thick,
				const int approximate,
				const struct bn_tol *tol));
BU_EXTERN(struct shell		*nmg_extrude_shell,
				(struct shell *s,
				const fastf_t dist,
				const int normal_ward,
				const int approximate,
				const struct bn_tol *tol));

/* From nmg_pr.c */
BU_EXTERN(char *		nmg_orientation, (int orientation) );
BU_EXTERN(void			nmg_pr_orient, (int orientation, const char *h) );
BU_EXTERN(void			nmg_pr_m, (const struct model *m) );
BU_EXTERN(void			nmg_pr_r, (const struct nmgregion *r, char *h) );
BU_EXTERN(void			nmg_pr_sa, (const struct shell_a *sa, char *h) );
BU_EXTERN(void			nmg_pr_lg, (const struct loop_g *lg, char *h) );
BU_EXTERN(void			nmg_pr_fg, (const long *magic, char *h) );
BU_EXTERN(void			nmg_pr_s, (const struct shell *s, char *h) );
BU_EXTERN(void 			nmg_pr_s_briefly, (const struct shell *s, char *h));
BU_EXTERN(void			nmg_pr_f, (const struct face *f, char *h) );
BU_EXTERN(void			nmg_pr_fu, (const struct faceuse *fu, char *h) );
BU_EXTERN(void			nmg_pr_fu_briefly, (const struct faceuse *fu,	char *h) );
BU_EXTERN(void			nmg_pr_l, (const struct loop *l, char *h) );
BU_EXTERN(void			nmg_pr_lu, (const struct loopuse *lu, char *h) );
BU_EXTERN(void			nmg_pr_lu_briefly, (const struct loopuse *lu, char *h) );
BU_EXTERN(void			nmg_pr_eg, (const long *eg, char *h) );
BU_EXTERN(void			nmg_pr_e, (const struct edge *e, char *h) );
BU_EXTERN(void			nmg_pr_eu, (const struct edgeuse *eu, char *h) );
BU_EXTERN(void			nmg_pr_eu_briefly, (const struct edgeuse *eu, char *h) );
BU_EXTERN(void 			nmg_pr_eu_endpoints, (const struct edgeuse *eu,
				char *h));
BU_EXTERN(void			nmg_pr_vg, (const struct vertex_g *vg, char *h) );
BU_EXTERN(void			nmg_pr_v, (const struct vertex *v, char *h) );
BU_EXTERN(void			nmg_pr_vu, (const struct vertexuse *vu, char *h) );
BU_EXTERN(void			nmg_pr_vu_briefly, (const struct vertexuse *vu, char *h) );
BU_EXTERN(void			nmg_pr_vua, (const long *magic_p, char *h) );
BU_EXTERN(void			nmg_euprint, (const char *str, const struct edgeuse *eu) );
BU_EXTERN(void			nmg_pr_ptbl, (const char *title,
				const struct bu_ptbl *tbl,
				int verbose));
BU_EXTERN(void			nmg_pr_ptbl_vert_list, (const char *str,
				const struct bu_ptbl *tbl,
				const fastf_t *mag));
BU_EXTERN(void			nmg_pr_one_eu_vecs,
				(const struct edgeuse	*eu,
				const vect_t		xvec,
				const vect_t		yvec,
				const vect_t		zvec,
				const struct bn_tol	*tol));
BU_EXTERN(void			nmg_pr_fu_around_eu_vecs,
				(const struct edgeuse	*eu,
				const vect_t		xvec,
				const vect_t		yvec,
				const vect_t		zvec,
				const struct bn_tol	*tol));
BU_EXTERN(void			nmg_pr_fu_around_eu, (const struct edgeuse *eu,
				const struct bn_tol	*tol));
BU_EXTERN(void			nmg_pl_lu_around_eu, (const struct edgeuse *eu));
BU_EXTERN(void			nmg_pr_fus_in_fg, (const long *fg_magic));

/* From nmg_misc.c */
extern struct rt_bot_internal *nmg_bot( struct shell *s,
					const struct bn_tol *tol);
extern int rt_dist_pt3_line3(fastf_t		*dist,
			     point_t		pca,
			     const point_t	a,
			     const point_t	p,
			     const vect_t	dir,
			     const struct bn_tol *tol);

extern int rt_dist_line3_line3(fastf_t dist[2],
		    const point_t p1,
		    const point_t p2,
		    const vect_t d1,
		    const vect_t d2,
			       const struct bn_tol *tol);

BU_EXTERN(int			nmg_snurb_calc_lu_uv_orient, (const struct loopuse *lu));
BU_EXTERN(void			nmg_snurb_fu_eval, (const struct faceuse *fu,
				const fastf_t u,
				const fastf_t v,
				point_t pt_on_srf));
BU_EXTERN(void			nmg_snurb_fu_get_norm,
				(const struct faceuse *fu,
				const fastf_t u,
				const fastf_t v,
				vect_t norm));
BU_EXTERN(void			nmg_snurb_fu_get_norm_at_vu,
				(const struct faceuse *fu,
				const struct vertexuse *vu,
				vect_t norm));
BU_EXTERN(void			nmg_find_zero_length_edges, (const struct model *m));
BU_EXTERN(struct face		*nmg_find_top_face_in_dir,
				(const struct shell *s,
				int dir, long *flags));
BU_EXTERN(struct face		*nmg_find_top_face,
				(const struct shell *s,
				int *dir, long *flags));
BU_EXTERN(int			nmg_find_outer_and_void_shells,
				(struct nmgregion *r,
				struct bu_ptbl ***shells,
				const struct bn_tol *tol));
BU_EXTERN(int			nmg_mark_edges_real, (const long *magic_p));
BU_EXTERN(void			nmg_tabulate_face_g_verts,
				(struct bu_ptbl *tab, const struct face_g_plane *fg));
BU_EXTERN(void			nmg_isect_shell_self,
				(struct shell *s, const struct bn_tol *tol));
BU_EXTERN(struct edgeuse	*nmg_next_radial_eu, (const struct edgeuse *eu,
				const struct shell *s, const int wires));
BU_EXTERN(struct edgeuse	*nmg_prev_radial_eu, (const struct edgeuse *eu,
				const struct shell *s, const int wires));
BU_EXTERN(int			nmg_radial_face_count,
				(const struct edgeuse *eu, const struct shell *s));
BU_EXTERN(int			nmg_check_closed_shell, (const struct shell *s,
				const struct bn_tol *tol));
BU_EXTERN(int			nmg_move_lu_between_fus, (struct faceuse *dest,
				struct faceuse *src, struct loopuse *lu));
BU_EXTERN(void			nmg_loop_plane_newell, (const struct loopuse *lu,
				plane_t pl));
BU_EXTERN(fastf_t		nmg_loop_plane_area, (const struct loopuse *lu,
				plane_t pl));
BU_EXTERN(int			nmg_calc_face_plane, (struct faceuse *fu_in,
				plane_t pl));
BU_EXTERN(int			nmg_calc_face_g, (struct faceuse *fu));
BU_EXTERN(fastf_t		nmg_faceuse_area, (const struct faceuse *fu));
BU_EXTERN(fastf_t		nmg_shell_area, (const struct shell *s));
BU_EXTERN(fastf_t		nmg_region_area, (const struct nmgregion *r));
BU_EXTERN(fastf_t		nmg_model_area, (const struct model *m));
/* Some stray rt_ plane functions here */
BU_EXTERN(void			nmg_purge_unwanted_intersection_points, (struct bu_ptbl *vert_list, fastf_t *mag, const struct faceuse *fu, const struct bn_tol *tol));
BU_EXTERN(int			nmg_in_or_ref, (struct vertexuse *vu, struct bu_ptbl *b) );
BU_EXTERN(void			nmg_rebound, (struct model *m, const struct bn_tol *tol) );
BU_EXTERN(void			nmg_count_shell_kids, (const struct model *m, unsigned long *total_wires, unsigned long *total_faces, unsigned long *total_points));
BU_EXTERN(void			nmg_close_shell, (struct shell *s, const struct bn_tol *tol));
BU_EXTERN(struct shell		*nmg_dup_shell , ( struct shell *s , long ***copy_tbl, const struct bn_tol *tol ) );
BU_EXTERN(struct edgeuse	*nmg_pop_eu, (struct bu_ptbl *stack));
BU_EXTERN(void			nmg_reverse_radials, (struct faceuse *fu, const struct bn_tol *tol));
BU_EXTERN(void			nmg_reverse_face_and_radials, (struct faceuse *fu, const struct bn_tol *tol));
BU_EXTERN(int			nmg_shell_is_void, (const struct shell *s));
BU_EXTERN(void			nmg_propagate_normals, (struct faceuse *fu_in,
				long *flags, const struct bn_tol *tol));
BU_EXTERN(void			nmg_connect_same_fu_orients, (struct shell *s));
BU_EXTERN(void			nmg_fix_decomposed_shell_normals, (struct shell *s, const struct bn_tol *tol));
BU_EXTERN(struct model		*nmg_mk_model_from_region, (struct nmgregion *r, int reindex));
BU_EXTERN(void			nmg_fix_normals, (struct shell *s_orig,
				const struct bn_tol *tol));
BU_EXTERN(int			nmg_break_long_edges, (struct shell *s,
				const struct bn_tol *tol));
BU_EXTERN(struct faceuse	*nmg_mk_new_face_from_loop, (struct loopuse *lu));
BU_EXTERN(int			nmg_split_loops_into_faces, (long *magic_p, const struct bn_tol	*tol));
BU_EXTERN(int			nmg_decompose_shell, (struct shell *s, const struct bn_tol *tol));
BU_EXTERN(void			nmg_stash_model_to_file, (const char *filename,
				const struct model *m, const char *title) );
BU_EXTERN(int			nmg_unbreak_region_edges, (long *magic_p));
/* rt_dist_pt3_line3 */
BU_EXTERN(int			nmg_mv_shell_to_region, (struct shell *s, struct nmgregion *r));
BU_EXTERN(int			nmg_find_isect_faces, (const struct vertex *new_v,
				struct bu_ptbl *faces,
				int *free_edges,
				const struct bn_tol *tol));
BU_EXTERN(int			nmg_simple_vertex_solve,
				(struct vertex *new_v, const struct bu_ptbl *faces,
				const struct bn_tol *tol));
BU_EXTERN(int			nmg_ck_vert_on_fus, (const struct vertex *v,
				const struct bn_tol *tol));
BU_EXTERN(void			nmg_make_faces_at_vert, (struct vertex *new_v,
				struct bu_ptbl *int_faces,
				const struct bn_tol *tol));
BU_EXTERN(void			nmg_kill_cracks_at_vertex, (const struct vertex *vp));
BU_EXTERN(int			nmg_complex_vertex_solve,
				(struct vertex *new_v,
				const struct bu_ptbl *faces,
				const int free_edges,
				const int approximate,
				const struct bn_tol *tol));
BU_EXTERN(int			nmg_bad_face_normals, (const struct shell *s,
				const struct bn_tol *tol));
BU_EXTERN(int			nmg_faces_are_radial,
				(const struct faceuse *fu1,
				const struct faceuse *fu2));
BU_EXTERN(int			nmg_move_edge_thru_pt, (struct edgeuse *mv_eu,
				const point_t pt, const struct bn_tol *tol));
BU_EXTERN(void			nmg_vlist_to_wire_edges, (struct shell *s,
				const struct bu_list *vhead));
BU_EXTERN(void			nmg_follow_free_edges_to_vertex,
				(const struct vertex *vpa,
				const struct vertex *vpb,
				struct bu_ptbl *bad_verts,
				const struct shell *s,
				const struct edgeuse *eu,
				struct bu_ptbl *verts,
				int *found));
BU_EXTERN(void			nmg_glue_face_in_shell,
				(const struct faceuse *fu,
				struct shell *s,
				const struct bn_tol *tol));
BU_EXTERN(int			nmg_open_shells_connect,
				(struct shell *dst,
				struct shell *src,
				const long **copy_tbl,
				const struct bn_tol *tol));
BU_EXTERN(int			nmg_in_vert,
				(struct vertex *new_v,
				const int approximate,
				const struct bn_tol *tol));
BU_EXTERN(void			nmg_mirror_model, (struct model *m));
BU_EXTERN(int			nmg_kill_cracks, (struct shell *s));
BU_EXTERN(int			nmg_kill_zero_length_edgeuses, (struct model *m));
BU_EXTERN(void			nmg_make_faces_within_tol, (struct shell *s,
				const struct bn_tol *tol));
BU_EXTERN(void			nmg_intersect_loops_self,
				(struct shell *s, const struct bn_tol *tol));
BU_EXTERN(struct edge_g_cnurb *rt_join_cnurbs, (struct bu_list *crv_head));
BU_EXTERN(struct edge_g_cnurb *rt_arc2d_to_cnurb,
				(point_t i_center,
				point_t i_start,
				point_t i_end,
				int point_type,
				const struct bn_tol *tol));
BU_EXTERN(int			nmg_break_edge_at_verts, (struct edge *e,
				struct bu_ptbl *verts, const struct bn_tol *tol));
BU_EXTERN( void nmg_isect_shell_self , ( struct shell *s , const struct bn_tol *tol ) );
BU_EXTERN(fastf_t		nmg_loop_plane_area , (const struct loopuse *lu , plane_t pl ) );
BU_EXTERN(int			nmg_break_edges, (long *magic_p,
				const struct bn_tol *tol));
BU_EXTERN(int			nmg_lu_is_convex, (struct loopuse *lu,
				const struct bn_tol *tol));
#ifdef SEEN_RTGEOM_H
BU_EXTERN(int			nmg_to_arb, (const struct model *m,
				struct rt_arb_internal *arb_int));
BU_EXTERN(int			nmg_to_tgc, (const struct model *m,
				struct rt_tgc_internal *tgc_int,
				const struct bn_tol *tol));
BU_EXTERN(int			nmg_to_poly, (const struct model *m,
				struct rt_pg_internal *poly_int,
				const struct bn_tol *tol));
struct rt_bot_internal		*nmg_bot( struct shell *s, const struct bn_tol *tol );
#endif

BU_EXTERN(int			nmg_simplify_shell_edges, (struct shell *s,
				const struct bn_tol *tol));
BU_EXTERN(int			nmg_edge_collapse, (struct model *m,
				const struct bn_tol *tol,
				const fastf_t tol_coll,
				const fastf_t min_angle));

/* g_bot.c */
int rt_bot_edge_in_list( const int v1, const int v2, const int edge_list[], const int edge_count );
int rt_bot_plot( struct bu_list		*vhead,
		 struct rt_db_internal	*ip,
		 const struct rt_tess_tol *ttol,
		 const struct bn_tol	*tol);
int rt_bot_plot_poly(struct bu_list		*vhead,
		     struct rt_db_internal	*ip,
		     const struct rt_tess_tol *ttol,
		     const struct bn_tol	*tol); 
#ifdef SEEN_RTGEOM_H
int rt_bot_find_v_nearest_pt2(
	const struct rt_bot_internal *bot,
	const point_t	pt2,
	const mat_t	mat);
int rt_bot_find_e_nearest_pt2(
	int *vert1,
	int *vert2,
	const struct rt_bot_internal *bot,
	const point_t	pt2,
	const mat_t	mat);
int rt_bot_vertex_fuse( struct rt_bot_internal *bot );
int rt_bot_face_fuse( struct rt_bot_internal *bot );
int rt_bot_condense( struct rt_bot_internal *bot );
int rt_smooth_bot( struct rt_bot_internal *bot, char *bot_name, struct db_i *dbip, fastf_t normal_tolerance_angle );

#endif
int rt_bot_same_orientation( const int *a, const int *b );

/* From nmg_tri.c */
extern void nmg_triangulate_shell(struct shell *s, const struct bn_tol  *tol);


BU_EXTERN(void			nmg_triangulate_model, (struct model *m, const struct bn_tol   *tol) );
BU_EXTERN(void			nmg_triangulate_fu, (struct faceuse *fu, const struct bn_tol   *tol) );

/* nmg_manif.c */
BU_EXTERN(int			nmg_dangling_face, (const struct faceuse *fu,
				const char *manifolds));
/* static paint_face */
/* static set_edge_sub_manifold */
/* static set_loop_sub_manifold */
/* static set_face_sub_manifold */
BU_EXTERN(char 			*nmg_shell_manifolds, (struct shell *sp, char *tbl) );
BU_EXTERN(char	 		*nmg_manifolds, (struct model *m) );

/* g_nmg.c */
extern int nmg_ray_segs(struct ray_data	*rd);

/* g_torus.c */
extern int rt_num_circular_segments(double maxerr, double radius);

/* tcl.c */
int rt_tcl_parse_ray( Tcl_Interp *interp, struct xray *rp, const char *const*argv );
void rt_tcl_pr_cutter( Tcl_Interp *interp, const union cutter *cutp );
int rt_tcl_cutter( ClientData clientData, Tcl_Interp *interp, int argc, const char *const*argv );
void rt_tcl_pr_hit( Tcl_Interp *interp, struct hit *hitp, const struct seg *segp, const struct xray	*rayp, int flipflag );
void rt_tcl_setup(Tcl_Interp *interp);
int Rt_Init(Tcl_Interp *interp);
void db_full_path_appendresult( Tcl_Interp *interp, const struct db_full_path *pp );
extern int tcl_obj_to_int_array(Tcl_Interp *interp,
				Tcl_Obj *list,
				int **array,
				int *array_len);


extern int tcl_obj_to_fastf_array(Tcl_Interp *interp,
				  Tcl_Obj *list,
				  fastf_t **array,
				  int *array_len);

extern int tcl_list_to_int_array(Tcl_Interp *interp,
				 char *char_list,
				 int **array,
				 int *array_len);

extern int tcl_list_to_fastf_array(Tcl_Interp *interp,
				   char *char_list,
				   fastf_t **array,
				   int *array_len);


/* g_rhc.c */
extern int rt_mk_hyperbola(struct rt_pt_node *pts,
			   fastf_t r,
			   fastf_t b,
			   fastf_t c,
			   fastf_t dtol,
			   fastf_t ntol);



/* nmg_class.c */
extern int nmg_classify_pt_loop(const point_t pt,
				const struct loopuse *lu,
				const struct bn_tol *tol);

extern int nmg_classify_s_vs_s( struct shell *s,
				struct shell *s2,
				const struct bn_tol *tol);

extern int nmg_classify_lu_lu(const struct loopuse *lu1,
			      const struct loopuse *lu2,
			      const struct bn_tol *tol);

BU_EXTERN(int			nmg_class_pt_f, (const point_t pt,
				const struct faceuse *fu,
				const struct bn_tol *tol) );
BU_EXTERN(int			nmg_class_pt_s, (const point_t pt,
				const struct shell *s,
				const int in_or_out_only,
				const struct bn_tol *tol) );

/* From nmg_pt_fu.c */
extern int nmg_eu_is_part_of_crack( const struct edgeuse *eu);

extern int nmg_class_pt_lu_except(point_t		pt,
				  const struct loopuse	*lu,
				  const struct edge		*e_p,
				  const struct bn_tol	*tol);

BU_EXTERN(int			nmg_class_pt_fu_except, (const point_t pt,
				const struct faceuse *fu,
				const struct loopuse *ignore_lu,
				void (*eu_func)(), void (*vu_func)(),
				const char *priv,
				const int call_on_hits,
				const int in_or_out_only,
				const struct bn_tol *tol) );

/* From nmg_plot.c */
BU_EXTERN(void			nmg_pl_shell, (FILE *fp, 
					     const struct shell *s,
					     int fancy));

BU_EXTERN(void			nmg_vu_to_vlist, (struct bu_list *vhead,
				const struct vertexuse	*vu));
BU_EXTERN(void			nmg_eu_to_vlist, (struct bu_list *vhead,
				const struct bu_list	*eu_hd));
BU_EXTERN(void			nmg_lu_to_vlist, (struct bu_list *vhead,
				const struct loopuse	*lu,
				int			poly_markers,
				const vectp_t		normal));
BU_EXTERN(void			nmg_snurb_fu_to_vlist,
				(struct bu_list		*vhead,
				const struct faceuse	*fu,
				int			poly_markers));
BU_EXTERN(void			nmg_s_to_vlist,
				(struct bu_list		*vhead,
				const struct shell	*s,
				int			poly_markers));
BU_EXTERN(void			nmg_r_to_vlist,
				(struct bu_list		*vhead,
				const struct nmgregion	*r,
				int			poly_markers));
BU_EXTERN(void			nmg_m_to_vlist,
				(struct bu_list	*vhead,
				struct model	*m,
				int		poly_markers));
BU_EXTERN(void			nmg_offset_eu_vert,
				(point_t			base,
				const struct edgeuse	*eu,
				const vect_t		face_normal,
				int			tip));
	/* plot */
BU_EXTERN(void			nmg_pl_v, (FILE	*fp, const struct vertex *v,
				long *b) );
BU_EXTERN(void			nmg_pl_e, (FILE *fp, const struct edge *e,
				long *b, int red, int green, int blue) );
BU_EXTERN(void			nmg_pl_eu, (FILE *fp, const struct edgeuse *eu,
				long *b, int red, int green, int blue) );
BU_EXTERN(void			nmg_pl_lu, (FILE *fp, const struct loopuse *fu, 
				long *b, int red, int green, int blue) );
BU_EXTERN(void			nmg_pl_fu, (FILE *fp, const struct faceuse *fu,
				long *b, int red, int green, int blue ) );
BU_EXTERN(void			nmg_pl_s, (FILE *fp, const struct shell *s) );
BU_EXTERN(void			nmg_pl_r, (FILE *fp, const struct nmgregion *r) );
BU_EXTERN(void			nmg_pl_m, (FILE *fp, const struct model *m) );
BU_EXTERN(void			nmg_vlblock_v, (struct bn_vlblock *vbp,
				const struct vertex *v, long *tab) );
BU_EXTERN(void			nmg_vlblock_e, (struct bn_vlblock *vbp,
				const struct edge *e, long *tab,
				int red, int green, int blue, int fancy) );
BU_EXTERN(void			nmg_vlblock_eu, (struct bn_vlblock *vbp,
				const struct edgeuse *eu, long *tab,
				int red, int green, int blue,
				int fancy, int loopnum) );
BU_EXTERN(void			nmg_vlblock_euleft,
				(struct bu_list			*vh,
				const struct edgeuse		*eu,
				const point_t			center,
				const mat_t			mat,
				const vect_t			xvec,
				const vect_t			yvec,
				double				len,
				const struct bn_tol		*tol));
BU_EXTERN(void			nmg_vlblock_around_eu,
				(struct bn_vlblock		*vbp,
				const struct edgeuse		*arg_eu,
				long				*tab,
				int				fancy,
				const struct bn_tol		*tol));
BU_EXTERN(void			nmg_vlblock_lu, (struct bn_vlblock *vbp,
				const struct loopuse *lu, long *tab,
				int red, int green, int blue,
				int fancy, int loopnum) );
BU_EXTERN(void			nmg_vlblock_fu, (struct bn_vlblock *vbp,
				const struct faceuse *fu, long *tab, int fancy) );
BU_EXTERN(void			nmg_vlblock_s, (struct bn_vlblock *vbp,
				const struct shell *s, int fancy) );
BU_EXTERN(void			nmg_vlblock_r, (struct bn_vlblock *vbp,
				const struct nmgregion *r, int fancy) );
BU_EXTERN(void			nmg_vlblock_m, (struct bn_vlblock *vbp,
				const struct model *m, int fancy) );
	/* visualization helper routines */
BU_EXTERN(void			nmg_pl_edges_in_2_shells,
				(struct bn_vlblock	*vbp,
				long			*b,
				const struct edgeuse	*eu,
				int			fancy,
				const struct bn_tol	*tol));
BU_EXTERN(void			nmg_pl_isect,
				(const char		*filename,
				const struct shell	*s,
				const struct bn_tol	*tol));
BU_EXTERN(void			nmg_pl_comb_fu, (int num1, int num2,
				const struct faceuse *fu1) );
BU_EXTERN(void			nmg_pl_2fu, (const char *str, int num,
				const struct faceuse *fu1, const struct faceuse *fu2,
				int show_mates) );
	/* graphical display of classifier results */
BU_EXTERN(void			nmg_show_broken_classifier_stuff,
				(long	*p,
				long	*classlist[4],
				int	all_new,
				int	fancy,
				const char	*a_string));
BU_EXTERN(void			nmg_face_plot, (const struct faceuse *fu) );
BU_EXTERN(void			nmg_2face_plot, (const struct faceuse *fu1,
				const struct faceuse *fu2) );
BU_EXTERN(void			nmg_face_lu_plot, (const struct loopuse *lu,
				const struct vertexuse *vu1, const struct vertexuse *vu2) );
BU_EXTERN(void			nmg_plot_lu_ray,
				(const struct loopuse		*lu,
				const struct vertexuse		*vu1,
				const struct vertexuse		*vu2,
				const vect_t			left));
BU_EXTERN(void			nmg_plot_ray_face,
				(const char *fname,
				point_t pt,
				const vect_t dir,
				const struct faceuse *fu));
BU_EXTERN(void			nmg_plot_lu_around_eu,
				(const char		*prefix,
				const struct edgeuse	*eu,
				const struct bn_tol	*tol));
BU_EXTERN(int			nmg_snurb_to_vlist,
				(struct bu_list			*vhead,
				const struct face_g_snurb	*fg,
				int				n_interior));
BU_EXTERN(void			nmg_cnurb_to_vlist, (struct bu_list *vhead,
				const struct edgeuse *eu,int n_interior,
				int cmd) );

/* nurb_util.c */
extern void
rt_nurb_clean_cnurb(struct edge_g_cnurb * crv);

/* nurb_knot.c */
extern int rt_nurb_knot_index(const struct knot_vector *kv,
			     fastf_t k_value,
			     int	order);

/* nurb_trim.c */
extern int nmg_uv_in_lu(const fastf_t u, const fastf_t v, 
			const struct loopuse *lu);


/* from nmg_mesh.c */
extern int nmg_mesh_two_faces(struct faceuse *fu1,
			      struct faceuse *fu2,
			      const struct bn_tol	*tol);

BU_EXTERN(void			nmg_radial_join_eu, (struct edgeuse *eu1,
				struct edgeuse *eu2, const struct bn_tol *tol));
BU_EXTERN(void			nmg_mesh_faces, (struct faceuse *fu1,
				struct faceuse *fu2, const struct bn_tol *tol) );
BU_EXTERN(int			nmg_mesh_face_shell, (struct faceuse *fu1,
				struct shell *s, const struct bn_tol *tol));
BU_EXTERN(int			nmg_mesh_shell_shell, (struct shell *s1,
				struct shell *s2, const struct bn_tol *tol));
BU_EXTERN(double		nmg_measure_fu_angle, (const struct edgeuse *eu,
				const vect_t xvec, const vect_t yvec,
				const vect_t zvec));

/* from nmg_bool.c */
BU_EXTERN(struct nmgregion	*nmg_do_bool, (struct nmgregion *s1,
				struct nmgregion *s2,
				const int oper, const struct bn_tol *tol) );
BU_EXTERN(void			nmg_shell_coplanar_face_merge,
				(struct shell *s, const struct bn_tol *tol,
				const int simplify) );
BU_EXTERN(int			nmg_two_region_vertex_fuse, (struct nmgregion *r1,
				struct nmgregion *r2, const struct bn_tol *tol));
BU_EXTERN(union tree		*nmg_booltree_leaf_tess, (struct db_tree_state *tsp,
				struct db_full_path *pathp,
				struct rt_db_internal *ip, genptr_t client_data));
BU_EXTERN(union tree		*nmg_booltree_leaf_tnurb, (struct db_tree_state *tsp,
				struct db_full_path *pathp,
				struct rt_db_internal *ip, genptr_t client_data));
BU_EXTERN(union tree		*nmg_booltree_evaluate, (union tree *tp,
				const struct bn_tol *tol, struct resource *resp));
int nmg_boolean( union tree *tp, struct model *m, const struct bn_tol *tol, struct resource *resp );

/* from nmg_class.c */
BU_EXTERN(void			nmg_class_shells, (struct shell *sA,
				struct shell *sB, long *classlist[4],
				const struct bn_tol *tol) );

/* from nmg_fcut.c */
/* static void ptbl_vsort */
BU_EXTERN(int			nmg_ck_vu_ptbl, (struct bu_ptbl	*p,
				struct faceuse	*fu));
BU_EXTERN(double		nmg_vu_angle_measure, (struct vertexuse	*vu,
				vect_t x_dir, vect_t y_dir, int assessment,
				int in) );
#if 0
BU_EXTERN(int			nmg_is_v_on_rs_list, (const struct nmg_ray_state *rs,
				const struct vertex		*v));
BU_EXTERN(int			nmg_assess_eu, (struct edgeuse *eu,
				int			forw,
				struct nmg_ray_state	*rs,
				int			pos));
BU_EXTERN(int			nmg_assess_vu, (struct nmg_ray_state	*rs,
				int			pos));
BU_EXTERN(void			nmg_pr_vu_stuff, (const struct nmg_vu_stuff *vs));
#endif
BU_EXTERN(int			nmg_wedge_class, (int	ass,			/* assessment of two edges forming wedge */
				double	a, double	b));
#if 0
BU_EXTERN(int			nmg_face_coincident_vu_sort,
				(struct nmg_ray_state	*rs,
				int			start,
				int			end));
#endif
BU_EXTERN(void			nmg_sanitize_fu, (struct faceuse	*fu));
#if 0
BU_EXTERN(void			nmg_face_rs_init,
				(struct nmg_ray_state	*rs,
				struct bu_ptbl	*b,
				struct faceuse	*fu1,
				struct faceuse	*fu2,
				point_t		pt,
				vect_t		dir,
				struct edge_g_lseg		*eg,
				const struct bn_tol	*tol));
BU_EXTERN(void			nmg_edge_geom_isect_line,
				(struct edgeuse		*eu,
				struct nmg_ray_state	*rs,
				const char		*reason));
#endif
BU_EXTERN(void			nmg_unlist_v,
				(struct bu_ptbl	*b,
				fastf_t *mag,
				struct vertex	*v));
#if 0
BU_EXTERN(int			nmg_onon_fix,
				(struct nmg_ray_state	*rs,
				struct bu_ptbl		*b,
				struct bu_ptbl		*ob,
				fastf_t			*mag,
				fastf_t			*omag));
#endif
BU_EXTERN(struct edge_g_lseg	*nmg_face_cutjoin, (
				struct bu_ptbl *b1, struct bu_ptbl *b2,
				fastf_t *mag1, fastf_t *mag2,
				struct faceuse *fu1, struct faceuse *fu2,
				point_t pt, vect_t dir,
				struct edge_g_lseg *eg,
				const struct bn_tol *tol) );
BU_EXTERN(void			nmg_fcut_face_2d,
				(struct bu_ptbl *vu_list,
				fastf_t *mag,
				struct faceuse *fu1,
				struct faceuse *fu2,
				struct bn_tol *tol));
BU_EXTERN(int			nmg_insert_vu_if_on_edge,
				(struct vertexuse *vu1,
				struct vertexuse *vu2,
				struct edgeuse *new_eu,
				struct bn_tol *tol));
/* nmg_face_state_transition */

#define nmg_mev(_v, _u)	nmg_me((_v), (struct vertex *)NULL, (_u))

/* From nmg_eval.c */
BU_EXTERN(void			nmg_ck_lu_orientation, (struct loopuse *lu,
				const struct bn_tol *tolp));
BU_EXTERN(const char		*nmg_class_name, (int class_no) );
BU_EXTERN(void			nmg_evaluate_boolean,
				(struct shell	*sA,
				struct shell	*sB,
				int		op,
				long		*classlist[8],
				const struct bn_tol	*tol));
#if 0
/* These can't be included because struct nmg_bool_state is in nmg_eval.c */
/* nmg_eval_shell */
/* nmg_eval_action */
/* nmg_eval_plot */
#endif


/* From nmg_rt_isect.c */
extern void nmg_rt_print_hitlist( struct hitmiss *hl );

extern void nmg_rt_print_hitmiss( struct hitmiss *a_hit);

extern int nmg_class_ray_vs_shell(struct xray *rp,
				  const struct shell *s,
				  const int in_or_out_only,
				  const struct bn_tol *tol);

BU_EXTERN(void nmg_isect_ray_model, (struct ray_data *rd) );

/* From nmg_rt_segs.c */
#if 0
/* Don't have "nmg_specific" */
BU_EXTERN(int nmg_ray_isect_segs, (struct soltab *stp,
					struct xray *rp,
					struct application *ap,
					struct seg *seghead,
					struct nmg_specific *nmg_spec) );
#endif

/* From nmg_ck.c */
BU_EXTERN(void			nmg_vvg, (const struct vertex_g *vg));
BU_EXTERN(void			nmg_vvertex, (const struct vertex *v,
				const struct vertexuse *vup));
BU_EXTERN(void			nmg_vvua, (const long *vua));
BU_EXTERN(void			nmg_vvu, (const struct vertexuse *vu,
				const long *up_magic_p));
BU_EXTERN(void			nmg_veg, (const long *eg));
BU_EXTERN(void			nmg_vedge, (const struct edge *e,
				const struct edgeuse *eup));
BU_EXTERN(void			nmg_veu, (const struct bu_list	*hp,
				const long *up_magic_p));
BU_EXTERN(void			nmg_vlg, (const struct loop_g *lg));
BU_EXTERN(void			nmg_vloop, (const struct loop *l,
				const struct loopuse *lup));
BU_EXTERN(void			nmg_vlu, (const struct bu_list	*hp,
				const long *up));
BU_EXTERN(void			nmg_vfg, (const struct face_g_plane *fg));
BU_EXTERN(void			nmg_vface, (const struct face *f,
				const struct faceuse *fup));
BU_EXTERN(void			nmg_vfu, (const struct bu_list	*hp,
				const struct shell *s));
BU_EXTERN(void			nmg_vshell, (const struct bu_list *hp,
				const struct nmgregion *r));
BU_EXTERN(void			nmg_vregion, (const struct bu_list *hp,
				const struct model *m));
BU_EXTERN(void			nmg_vmodel, (const struct model *m));

/* checking routines */
BU_EXTERN(void			nmg_ck_e, (const struct edgeuse *eu,
				const struct edge *e, const char *str));
BU_EXTERN(void			nmg_ck_vu, (const long *parent,
				const struct vertexuse *vu,
				const char *str));
BU_EXTERN(void			nmg_ck_eu, (const long *parent,
				const struct edgeuse *eu,
				const char *str));
BU_EXTERN(void			nmg_ck_lg, (const struct loop *l,
				const struct loop_g *lg,
				const char *str));
BU_EXTERN(void			nmg_ck_l, (const struct loopuse *lu,
				const struct loop *l,
				const char *str));
BU_EXTERN(void			nmg_ck_lu, (const long *parent,
				const struct loopuse *lu,
				const char *str));
BU_EXTERN(void			nmg_ck_fg, (const struct face *f,
				const struct face_g_plane *fg,
				const char *str));
BU_EXTERN(void			nmg_ck_f, (const struct faceuse *fu,
				const struct face *f,
				const char *str));
BU_EXTERN(void			nmg_ck_fu, (const struct shell *s,
				const struct faceuse *fu,
				const char *str));
BU_EXTERN(int			nmg_ck_eg_verts, (const struct edge_g_lseg *eg,
				const struct bn_tol *tol));
BU_EXTERN(int			nmg_ck_geometry, (const struct model *m,
				const struct bn_tol *tol));
BU_EXTERN(int			nmg_ck_face_worthless_edges, (const struct faceuse *fu));
BU_EXTERN(void			nmg_ck_lueu, (const struct loopuse *lu, const char *s) );
BU_EXTERN(int			nmg_check_radial, (const struct edgeuse *eu, const struct bn_tol *tol));
BU_EXTERN(int			nmg_eu_2s_orient_bad, (const struct edgeuse	*eu,
				const struct shell	*s1,
				const struct shell	*s2,
				const struct bn_tol	*tol));
BU_EXTERN(int			nmg_ck_closed_surf, (const struct shell *s, const struct bn_tol *tol) );
BU_EXTERN(int			nmg_ck_closed_region, (const struct nmgregion *r, const struct bn_tol *tol) );
BU_EXTERN(void			nmg_ck_v_in_2fus, (const struct vertex *vp,
				const struct faceuse *fu1, const struct faceuse *fu2,
				const struct bn_tol *tol));
BU_EXTERN(void			nmg_ck_vs_in_region, (const struct nmgregion *r,
				const struct bn_tol *tol));


/* From nmg_inter.c */
BU_EXTERN(struct vertexuse	*nmg_make_dualvu,
				(struct vertex *v,
				struct faceuse *fu,
				const struct bn_tol *tol));
BU_EXTERN(struct vertexuse	*nmg_enlist_vu, (struct nmg_inter_struct	*is,
				const struct vertexuse *vu,
				struct vertexuse *dualvu,
				fastf_t dist));
BU_EXTERN(void			nmg_isect2d_prep, (struct nmg_inter_struct *is,
				const long *assoc_use));
BU_EXTERN(void			nmg_isect2d_cleanup, (struct nmg_inter_struct *is));
BU_EXTERN(void			nmg_isect2d_final_cleanup, ());
BU_EXTERN(void			nmg_isect_vert2p_face2p, (struct nmg_inter_struct *is,
				struct vertexuse *vu1, struct faceuse *fu2));
BU_EXTERN(struct edgeuse	*nmg_break_eu_on_v, (struct edgeuse *eu1,
				struct vertex *v2, struct faceuse *fu,
				struct nmg_inter_struct *is));
BU_EXTERN(void			nmg_break_eg_on_v,
				(const struct edge_g_lseg	*eg,
				struct vertex		*v,
				const struct bn_tol	*tol));
BU_EXTERN(int			nmg_isect_2colinear_edge2p,
				(struct edgeuse	*eu1,
				struct edgeuse	*eu2,
				struct faceuse		*fu,
				struct nmg_inter_struct	*is,
				struct bu_ptbl		*l1,
				struct bu_ptbl		*l2));
BU_EXTERN(int			nmg_isect_edge2p_edge2p,
				(struct nmg_inter_struct	*is,
				struct edgeuse		*eu1,
				struct edgeuse		*eu2,
				struct faceuse		*fu1,
				struct faceuse		*fu2));
BU_EXTERN(int			nmg_isect_construct_nice_ray,
				(struct nmg_inter_struct	*is,
				struct faceuse		*fu2));
BU_EXTERN(void			nmg_enlist_one_vu,
				(struct nmg_inter_struct	*is,
				const struct vertexuse	*vu,
				fastf_t			dist));
BU_EXTERN(int			nmg_isect_line2_edge2p,
				(struct nmg_inter_struct	*is,
				struct bu_ptbl		*list,
				struct edgeuse		*eu1,
				struct faceuse		*fu1,
				struct faceuse		*fu2));
BU_EXTERN(void			nmg_isect_line2_vertex2,
				(struct nmg_inter_struct	*is,
				struct vertexuse	*vu1,
				struct faceuse		*fu1));
BU_EXTERN(int			nmg_isect_two_ptbls,
				(struct nmg_inter_struct		*is,
				const struct bu_ptbl		*t1,
				const struct bu_ptbl		*t2));
BU_EXTERN(struct edge_g_lseg	*nmg_find_eg_on_line,
				(const long		*magic_p,
				const point_t		pt,
				const vect_t		dir,
				const struct bn_tol	*tol));
BU_EXTERN(int 			nmg_k0eu, (struct vertex	*v));
BU_EXTERN(struct vertex		*nmg_repair_v_near_v,
				(struct vertex		*hit_v,
				struct vertex		*v,
				const struct edge_g_lseg	*eg1,
				const struct edge_g_lseg	*eg2,
				int			bomb,
				const struct bn_tol	*tol));
BU_EXTERN(struct vertex		*nmg_search_v_eg,
				(const struct edgeuse		*eu,
				int				second,
				const struct edge_g_lseg	*eg1,
				const struct edge_g_lseg	*eg2,
				struct vertex		*hit_v,
				const struct bn_tol		*tol));
BU_EXTERN(struct vertex		*nmg_common_v_2eg,
				(struct edge_g_lseg	*eg1,
				struct edge_g_lseg	*eg2,
				const struct bn_tol	*tol));
BU_EXTERN(int			nmg_is_vertex_on_inter,
				(struct vertex *v,
				struct faceuse *fu1,
				struct faceuse *fu2,
				struct nmg_inter_struct *is));
BU_EXTERN(void			nmg_isect_eu_verts,
				(struct edgeuse *eu,
				struct vertex_g *vg1,
				struct vertex_g *vg2,
				struct bu_ptbl *verts,
				struct bu_ptbl *inters,
				const struct bn_tol *tol));
BU_EXTERN(void			nmg_isect_eu_eu,
				(struct edgeuse *eu1,
				struct vertex_g *vg1a,
				struct vertex_g *vg1b,
				vect_t dir1,
				struct edgeuse *eu2,
				struct bu_ptbl *verts,
				struct bu_ptbl *inters,
				const struct bn_tol *tol));
BU_EXTERN(void			nmg_isect_eu_fu,
				(struct nmg_inter_struct *is,
				struct bu_ptbl		*verts,
				struct edgeuse		*eu,
				struct faceuse          *fu));
BU_EXTERN(void			nmg_isect_fu_jra,
				(struct nmg_inter_struct	*is,
				struct faceuse		*fu1,
				struct faceuse		*fu2,
				struct bu_ptbl		*eu1_list,
				struct bu_ptbl		*eu2_list));
BU_EXTERN(void			nmg_isect_line2_face2pNEW, (struct nmg_inter_struct *is,
				struct faceuse *fu1, struct faceuse *fu2,
				struct bu_ptbl *eu1_list,
				struct bu_ptbl *eu2_list));
BU_EXTERN(int			nmg_is_eu_on_line3,
				(const struct edgeuse	*eu,
				const point_t		pt,
				const vect_t		dir,
				const struct bn_tol	*tol));
BU_EXTERN(struct edge_g_lseg	*nmg_find_eg_between_2fg,
				(const struct faceuse	*ofu1,
				const struct faceuse	*fu2,
				const struct bn_tol	*tol));
BU_EXTERN(struct edgeuse	*nmg_does_fu_use_eg,
				(const struct faceuse	*fu1,
				const long		*eg));
BU_EXTERN(int			rt_line_on_plane,
				(const point_t	pt,
				const vect_t	dir,
				const plane_t	plane,
				const struct bn_tol	*tol));
BU_EXTERN(void			nmg_cut_lu_into_coplanar_and_non,
				(struct loopuse *lu,
				plane_t pl,
				struct nmg_inter_struct *is));
BU_EXTERN(void			nmg_check_radial_angles,
				(char *str,
				struct shell *s,
				const struct bn_tol *tol));
BU_EXTERN(int			nmg_faces_can_be_intersected,
				(struct nmg_inter_struct *bs,
				const struct faceuse *fu1,
				const struct faceuse *fu2,
				const struct bn_tol *tol));
BU_EXTERN(void			nmg_isect_two_generic_faces,
				(struct faceuse		*fu1,
				struct faceuse		*fu2,
				const struct bn_tol	*tol));
BU_EXTERN(void			nmg_crackshells, (struct shell *s1, struct shell *s2, const struct bn_tol *tol) );
BU_EXTERN(int			nmg_fu_touchingloops, (const struct faceuse *fu));


/* From nmg_index.c */
BU_EXTERN(int			nmg_index_of_struct, (const long *p) );
BU_EXTERN(void			nmg_m_set_high_bit, (struct model *m));
BU_EXTERN(void			nmg_m_reindex, (struct model *m, long newindex) );
BU_EXTERN(void			nmg_vls_struct_counts, (struct bu_vls *str,
				const struct nmg_struct_counts *ctr));
BU_EXTERN(void			nmg_pr_struct_counts, 
				(const struct nmg_struct_counts *ctr,
				const char *str) );
BU_EXTERN(long			**nmg_m_struct_count,
				(struct nmg_struct_counts *ctr,
				const struct model *m) );
BU_EXTERN(void			nmg_struct_counts,
				(const struct model	*m,
				const char		*str));
BU_EXTERN(void			nmg_merge_models, (struct model *m1,
							struct model *m2) );
BU_EXTERN(long			nmg_find_max_index, (const struct model *m));

/* From nmg_rt.c */

/* From rt_dspline.c */
BU_EXTERN(void			rt_dspline_matrix, (mat_t m,const char *type,
					const double	tension,
					const double	bias) );
BU_EXTERN(double		rt_dspline4, (mat_t m, double a, double b,
					double c, double d, double alpha) );
BU_EXTERN(void			rt_dspline4v, (double *pt, const mat_t m,
					const double *a, const double *b,
					const double *c, const double *d,
					const int depth, const double alpha) );
BU_EXTERN(void			rt_dspline_n, (double *r, const mat_t m,
					const double *knots, const int n,
					const int depth, const double alpha));

/* From nurb_bezier.c */
BU_EXTERN( int rt_nurb_bezier, (struct bu_list *bezier_hd,
		const struct face_g_snurb *orig_surf, struct resource *res));
BU_EXTERN(int rt_bez_check, (const struct face_g_snurb * srf));
BU_EXTERN(int nurb_crv_is_bezier, (const struct edge_g_cnurb *crv));
BU_EXTERN(void nurb_c_to_bezier, (struct bu_list *clist, struct edge_g_cnurb *crv));

/* From nurb_copy.c */
BU_EXTERN(struct face_g_snurb *rt_nurb_scopy, (const struct face_g_snurb * srf,
		struct resource *res));
BU_EXTERN(struct edge_g_cnurb *rt_nurb_crv_copy, (const struct edge_g_cnurb * crv));

/* From nmg_fuse.c */
BU_EXTERN(int			nmg_is_common_bigloop, (const struct face *f1,
				const struct face *f2));
BU_EXTERN(void			nmg_region_v_unique, (struct nmgregion *r1,
				const struct bn_tol *tol));
BU_EXTERN(int			nmg_ptbl_vfuse, (struct bu_ptbl *t,
				const struct bn_tol *tol));
BU_EXTERN(int			nmg_region_both_vfuse, (struct bu_ptbl *t1,
				struct bu_ptbl *t2, const struct bn_tol	*tol));
/* nmg_two_region_vertex_fuse replaced with nmg_model_vertex_fuse */
BU_EXTERN(int			nmg_model_vertex_fuse, (struct model *m,
				const struct bn_tol *tol));
BU_EXTERN(int			nmg_cnurb_is_linear, (const struct edge_g_cnurb *cnrb));
BU_EXTERN(int			nmg_snurb_is_planar, (const struct face_g_snurb *srf, const struct bn_tol *tol));
BU_EXTERN(void			nmg_eval_linear_trim_curve,
				(const struct face_g_snurb *snrb,
				const fastf_t uvw[3], point_t xyz));
BU_EXTERN(void			nmg_eval_trim_curve,
				(const struct edge_g_cnurb *cnrb,
				const struct face_g_snurb *snrb,
				const fastf_t t, point_t xyz));
/* nmg_split_trim */
BU_EXTERN(void			nmg_eval_trim_to_tol,
				(const struct edge_g_cnurb *cnrb,
				const struct face_g_snurb *snrb,
				const fastf_t t0, const fastf_t t1,
				struct bu_list *head,
				const struct bn_tol *tol));
/* nmg_split_linear_trim */
BU_EXTERN(void			nmg_eval_linear_trim_to_tol,
				(const struct edge_g_cnurb *cnrb,
				const struct face_g_snurb *snrb,
				const fastf_t uvw1[3],
				const fastf_t uvw2[3],
				struct bu_list *head,
				const struct bn_tol *tol));
BU_EXTERN(int			nmg_cnurb_lseg_coincident,
				(const struct edgeuse *eu1,
				const struct edge_g_cnurb *cnrb,
				const struct face_g_snurb *snrb,
				const point_t pt1,
				const point_t pt2,
				const struct bn_tol *tol));
BU_EXTERN(int			nmg_cnurb_is_on_crv,
				(const struct edgeuse *eu,
				const struct edge_g_cnurb *cnrb,
				const struct face_g_snurb *snrb,
				const struct bu_list *head,
				const struct bn_tol *tol));
BU_EXTERN(int			nmg_model_edge_fuse,
				(struct model *m, const struct bn_tol *tol));
BU_EXTERN(int			nmg_model_edge_g_fuse,
				(struct model		*m,
				const struct bn_tol	*tol));
BU_EXTERN(int			nmg_ck_fu_verts, (struct faceuse *fu1,
				struct face *f2,
				const struct bn_tol *tol));
BU_EXTERN(int			nmg_ck_fg_verts, (struct faceuse *fu1,
				struct face *f2, const struct bn_tol *tol));
BU_EXTERN(int			nmg_two_face_fuse, (struct face	*f1,
				struct face *f2,
				const struct bn_tol *tol));
BU_EXTERN(int			nmg_model_face_fuse, (struct model *m,
				const struct bn_tol *tol));
BU_EXTERN(int			nmg_break_all_es_on_v, (long *magic_p,
				struct vertex *v, const struct bn_tol *tol));
BU_EXTERN(int			nmg_model_break_e_on_v, (struct model *m,
				const struct bn_tol *tol));
BU_EXTERN(int			nmg_model_fuse, (struct model *m,
				const struct bn_tol *tol));

	/* radial routines */
BU_EXTERN(void			nmg_radial_sorted_list_insert,
				(struct bu_list *hd, struct nmg_radial *rad));
BU_EXTERN(void			nmg_radial_verify_pointers,
				(const struct bu_list *hd,
				const struct bn_tol *tol));
BU_EXTERN(void			nmg_radial_verify_monotone,
				(const struct bu_list	*hd,
				const struct bn_tol	*tol));
BU_EXTERN(void			nmg_insure_radial_list_is_increasing,
				(struct bu_list	*hd,
				fastf_t amin, fastf_t amax));
BU_EXTERN(void			nmg_radial_build_list,
				(struct bu_list		*hd,
				struct bu_ptbl		*shell_tbl,
				int			existing,
				struct edgeuse		*eu,
				const vect_t		xvec,
				const vect_t		yvec,
				const vect_t		zvec,
				const struct bn_tol	*tol));
BU_EXTERN(void			nmg_radial_merge_lists,
				(struct bu_list		*dest,
				struct bu_list		*src,
				const struct bn_tol	*tol));
BU_EXTERN(int			nmg_is_crack_outie,
				(const struct edgeuse	*eu,
				const struct bn_tol	*tol));
BU_EXTERN(struct nmg_radial	*nmg_find_radial_eu, (const struct bu_list *hd,
				const struct edgeuse *eu));
BU_EXTERN(const struct edgeuse	*nmg_find_next_use_of_2e_in_lu,
				(const struct edgeuse	*eu,
				const struct edge	*e1,
				const struct edge	*e2));
BU_EXTERN(void			nmg_radial_mark_cracks,
				(struct bu_list		*hd,
				const struct edge	*e1,
				const struct edge	*e2,
				const struct bn_tol	*tol));
BU_EXTERN(struct nmg_radial	*nmg_radial_find_an_original,
				(const struct bu_list	*hd,
				const struct shell	*s,
				const struct bn_tol	*tol));
BU_EXTERN(int			nmg_radial_mark_flips,
				(struct bu_list		*hd,
				const struct shell	*s,
				const struct bn_tol	*tol));
BU_EXTERN(int			nmg_radial_check_parity,
				(const struct bu_list	*hd,
				const struct bu_ptbl	*shells,
				const struct bn_tol	*tol));
BU_EXTERN(void			nmg_radial_implement_decisions,
				(struct bu_list		*hd,
				const struct bn_tol	*tol,
				struct edgeuse		*eu1,
				vect_t xvec, vect_t yvec, vect_t zvec));
BU_EXTERN(void			nmg_pr_radial, (const char *title,
				const struct nmg_radial	*rad));
BU_EXTERN(void			nmg_pr_radial_list, (const struct bu_list *hd,
				const struct bn_tol *tol));
BU_EXTERN(void			nmg_do_radial_flips, (struct bu_list *hd));
BU_EXTERN(void			nmg_do_radial_join, (struct bu_list *hd,
				struct edgeuse *eu1ref,
				vect_t xvec, vect_t yvec, vect_t zvec,
				const struct bn_tol *tol));
BU_EXTERN(void			nmg_radial_join_eu_NEW,
				(struct edgeuse *eu1, struct edgeuse *eu2,
				const struct bn_tol *tol));
BU_EXTERN(void			nmg_radial_exchange_marked,
				(struct bu_list		*hd,
				const struct bn_tol	*tol));
BU_EXTERN(void			nmg_s_radial_harmonize,
				(struct shell		*s,
				const struct bn_tol	*tol));
BU_EXTERN(int			nmg_eu_radial_check,
				(const struct edgeuse	*eu,
				const struct shell	*s,
				const struct bn_tol	*tol));
BU_EXTERN(void			nmg_s_radial_check,
				(struct shell		*s,
				const struct bn_tol	*tol));
BU_EXTERN(void			nmg_r_radial_check,
				(const struct nmgregion	*r,
				const struct bn_tol	*tol));


BU_EXTERN(struct edge_g_lseg	*nmg_pick_best_edge_g, (struct edgeuse *eu1,
				struct edgeuse *eu2, const struct bn_tol *tol));

/* nmg_visit.c */
BU_EXTERN(void			nmg_visit_vertex,
				(struct vertex			*v,
				const struct nmg_visit_handlers	*htab,
				genptr_t			*state));
BU_EXTERN(void			nmg_visit_vertexuse,
				(struct vertexuse		*vu,
				const struct nmg_visit_handlers	*htab,
				genptr_t			*state));
BU_EXTERN(void			nmg_visit_edge,
				(struct edge			*e,
				const struct nmg_visit_handlers	*htab,
				genptr_t			*state));
BU_EXTERN(void			nmg_visit_edgeuse,
				(struct edgeuse			*eu,
				const struct nmg_visit_handlers	*htab,
				genptr_t			*state));
BU_EXTERN(void			nmg_visit_loop,
				(struct loop			*l,
				const struct nmg_visit_handlers	*htab,
				genptr_t			*state));
BU_EXTERN(void			nmg_visit_loopuse,
				(struct loopuse			*lu,
				const struct nmg_visit_handlers	*htab,
				genptr_t			*state));
BU_EXTERN(void			nmg_visit_face,
				(struct face			*f,
				const struct nmg_visit_handlers	*htab,
				genptr_t			*state));
BU_EXTERN(void			nmg_visit_faceuse,
				(struct faceuse			*fu,
				const struct nmg_visit_handlers	*htab,
				genptr_t			*state));
BU_EXTERN(void			nmg_visit_shell,
				(struct shell			*s,
				const struct nmg_visit_handlers	*htab,
				genptr_t			*state));
BU_EXTERN(void			nmg_visit_region,
				(struct nmgregion		*r,
				const struct nmg_visit_handlers	*htab,
				genptr_t			*state));
BU_EXTERN(void			nmg_visit_model,
				(struct model			*model,
				const struct nmg_visit_handlers	*htab,
				genptr_t			*state));
BU_EXTERN(void			nmg_visit,
				(const long			*magicp,
				const struct nmg_visit_handlers	*htab,
				genptr_t			*state));

/* db5_types.c */
BU_EXTERN(int			db5_type_tag_from_major,
				(char				**tag,
				const int			major));

BU_EXTERN(int			db5_type_descrip_from_major,
				(char				**descrip,
				const int			major));

BU_EXTERN(int			db5_type_tag_from_codes,
				(char				**tag,
				const int			major,
				const int			minor));

BU_EXTERN(int			db5_type_descrip_from_codes,
				(char				**descrip,
				const int			major,
				const int			minor));

BU_EXTERN(int			db5_type_codes_from_tag,
				(int				*major,
				int				*minor,
				const char			*tag));

BU_EXTERN(int			db5_type_codes_from_descrip,
				(int				*major,
				int				*minor,
				const char			*descrip));

BU_EXTERN(size_t		db5_type_sizeof_h_binu,
				(const int			minor));

BU_EXTERN(size_t		db5_type_sizeof_n_binu,
				(const int			minor));

#endif

/* defined in wdb_obj.c */
BU_EXTERN(int	wdb_get_tcl,		(ClientData clientData, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_init_obj,		(Tcl_Interp *interp, struct rt_wdb *wdbp, char *oname));
BU_EXTERN(int	wdb_bot_face_sort_cmd,	(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_bot_decimate_cmd,	(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_close_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_reopen_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_match_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_get_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_put_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_adjust_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_form_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_tops_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_rt_gettrees_cmd,	(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_dump_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_dbip_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_ls_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_list_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_lt_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_pathlist_cmd,	(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_pathsum_cmd,	(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_expand_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_kill_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_killall_cmd,	(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_killtree_cmd,	(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_copy_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_move_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_move_all_cmd,	(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_concat_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_dup_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_group_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_remove_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_region_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_comb_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_find_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_which_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_title_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_tree_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_color_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_prcolor_cmd,	(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_tol_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_push_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_whatid_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_keep_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_cat_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_instance_cmd,	(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_observer_cmd,	(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_make_bb_cmd,	(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_make_name_cmd,	(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_units_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_hide_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_unhide_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_attr_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_summary_cmd,	(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_comb_std_cmd,	(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_nmg_collapse_cmd,	(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_nmg_simplify_cmd,	(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_shells_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_xpush_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_showmats_cmd,	(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_copyeval_cmd,	(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_version_cmd,	(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_binary_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_track_cmd,		(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	wdb_smooth_bot_cmd,	(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));

/* defined in dg_obj.c */
BU_EXTERN(void	dgo_autoview,		(struct dg_obj *dgop, struct view_obj *vop, Tcl_Interp *interp));
BU_EXTERN(int	dgo_autoview_cmd,	(struct dg_obj *dgop, struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	dgo_blast_cmd,		(struct dg_obj *dgop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	dgo_draw_cmd,		(struct dg_obj *dgop, Tcl_Interp *interp, int argc, char **argv, int kind));
BU_EXTERN(int	dgo_E_cmd,		(struct dg_obj *dgop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	dgo_erase_cmd,		(struct dg_obj *dgop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	dgo_erase_all_cmd,	(struct dg_obj *dgop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	dgo_get_autoview_cmd,	(struct dg_obj *dgop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	dgo_illum_cmd,		(struct dg_obj *dgop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	dgo_label_cmd,		(struct dg_obj *dgop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(struct dg_obj	*dgo_open_cmd,	(char *oname, struct rt_wdb *wdbp));
BU_EXTERN(int	dgo_overlay_cmd,	(struct dg_obj *dgop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	dgo_report_cmd,		(struct dg_obj *dgop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	dgo_rt_cmd,		(struct dg_obj *dgop, struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	dgo_rtabort_cmd,	(struct dg_obj *dgop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	dgo_rtcheck_cmd,	(struct dg_obj *dgop, struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	dgo_vdraw_cmd,		(struct dg_obj *dgop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	dgo_who_cmd,		(struct dg_obj *dgop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(void	dgo_zap_cmd,		(struct dg_obj *dgop, Tcl_Interp *interp));
BU_EXTERN(int	dgo_shaded_mode_cmd,	(struct dg_obj *dgop, Tcl_Interp *interp, int argc, char **argv));

extern void dgo_color_soltab();
extern void dgo_drawH_part2();
extern void dgo_eraseobjall_callback();
extern void dgo_eraseobjpath();
extern void dgo_impending_wdb_close();
extern int dgo_invent_solid();
extern void dgo_notify();
extern void dgo_zapall();

/* defined in bigE.c */
BU_EXTERN(int	dg_E_cmd,		(struct dg_obj *dgop, Tcl_Interp *interp, int argc, char **argv));

/* defined in view_obj.c */
BU_EXTERN(struct view_obj	*vo_open_cmd,		(char *oname));
BU_EXTERN(void	vo_center,		(struct view_obj *vop, Tcl_Interp *interp, point_t center));
BU_EXTERN(int	vo_center_cmd,		(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(void	vo_size,		(struct view_obj *vop, Tcl_Interp *interp, fastf_t size));
BU_EXTERN(int	vo_size_cmd,		(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	vo_invSize_cmd,		(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(void	vo_mat_aet,		(struct view_obj *vop));
BU_EXTERN(int	vo_zoom,		(struct view_obj *vop, Tcl_Interp *interp, fastf_t sf));
BU_EXTERN(int	vo_zoom_cmd,		(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	vo_orientation_cmd,	(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	vo_lookat_cmd,		(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(void	vo_setview,		(struct view_obj *vop, Tcl_Interp *interp, vect_t rvec));
BU_EXTERN(int	vo_setview_cmd,		(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	vo_eye_cmd,		(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	vo_eye_pos_cmd,		(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	vo_pmat_cmd,		(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	vo_perspective_cmd,	(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(void	vo_update,		(struct view_obj *vop, Tcl_Interp *interp, int oflag));
BU_EXTERN(int	vo_aet_cmd,		(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	vo_rmat_cmd,		(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	vo_model2view_cmd,	(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	vo_pmodel2view_cmd,	(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	vo_view2model_cmd,	(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	vo_pov_cmd,		(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	vo_units_cmd,		(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	vo_base2local_cmd,	(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	vo_local2base_cmd,	(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	vo_rot,			(struct view_obj *vop, Tcl_Interp *interp, char coord, char origin,
					 mat_t rmat, int (*func)()));
BU_EXTERN(int	vo_rot_cmd,		(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv, int (*func)()));
BU_EXTERN(int	vo_arot_cmd,		(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv, int (*func)()));
BU_EXTERN(int	vo_mrot_cmd,		(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv, int (*func)()));
BU_EXTERN(int	vo_tra,			(struct view_obj *vop, Tcl_Interp *interp, char coord, vect_t tvec,
					 int (*func)()));
BU_EXTERN(int	vo_tra_cmd,		(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv,
					 int (*func)()));
BU_EXTERN(int	vo_slew,		(struct view_obj *vop, Tcl_Interp *interp, vect_t svec));
BU_EXTERN(int	vo_slew_cmd,		(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	vo_observer_cmd,	(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	vo_coord_cmd,		(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	vo_rotate_about_cmd,	(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	vo_keypoint_cmd,	(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	vo_vrot_cmd,		(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv));
BU_EXTERN(int	vo_sca,			(struct view_obj *vop, Tcl_Interp *interp, fastf_t sf, int (*func)()));
BU_EXTERN(int	vo_sca_cmd,		(struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv, int (*func)()));

/*
 *  Constants provided and used by the RT library.
 */
extern const struct db_tree_state	rt_initial_tree_state;
extern const char   *rt_vlist_cmd_descriptions[];

/* vers.c (created by librt/Cakefile) */
extern const char   rt_version[];

#ifdef __cplusplus
}
#endif

#endif /* RAYTRACE_H */
@


11.356
log
@Bob Parker's view modifications, png framebuffer support, shaded drawing mode
@
text
@d45 1
a45 1
 *  $Header$
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header$ (BRL)"
d2164 1
a2164 1
 *  $Header$
@


11.355
log
@make the USE_SURVICE_MODS not compile-time-optional.  so that means the #if sections go bye bye.
@
text
@d4863 1
@


11.354
log
@unbreak the b0rk3n state
@
text
@a1240 1
#if defined(USE_SURVICE_MODS)
a1241 1
#endif
@


11.353
log
@max solid needs to be higher to reach the superell
@
text
@d530 1
a530 1
  /* Add a new primitive id above here
d533 1
a533 1
#define	ID_MAX_SOLID	37	/* Maximum defined ID_xxx for solids */
d538 4
a541 4
#define ID_COMBINATION	32	/* Combination Record */
#define ID_BINEXPM	33	/* Experimental binary */
#define ID_BINUNIF	34	/* Uniform-array binary */
#define ID_BINMIME	35	/* MIME-typed binary */
d544 1
a544 1
#define ID_SUPERELL	36	/* Superquadratic ellipsoid */
d546 1
a546 1
#define ID_MAXIMUM	37	/* Maximum defined ID_xxx value */
@


11.352
log
@merge of ansi-6-0-branch into HEAD
@
text
@d533 1
a533 1
#define	ID_MAX_SOLID	31	/* Maximum defined ID_xxx for solids */
@


11.351
log
@merge of windows-6-0-branch into head
@
text
@d529 5
a533 1
#define	ID_MAX_SOLID	30	/* Maximum defined ID_xxx for solids */
d538 9
a546 5
#define ID_COMBINATION	31	/* Combination Record */
#define ID_BINEXPM	32	/* Experimental binary */
#define ID_BINUNIF	33	/* Uniform-array binary */
#define ID_BINMIME	34	/* MIME-typed binary */
#define ID_MAXIMUM	35	/* Maximum defined ID_xxx value */
d1241 1
a1241 1
#if USE_SURVICE_MODS
d2743 1
a2743 1
	int			free,
d3177 1
a3177 1
	int			free,
@


11.350
log
@use the defines like everyone else
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.349 2004/02/03 21:44:57 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.349 2004/02/03 21:44:57 jra Exp $ (BRL)"
d1176 11
d1189 1
d2158 1
a2158 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.349 2004/02/03 21:44:57 jra Exp $
@


11.349
log
@Added declaration for rt_extrude_import5
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.348 2004/02/02 17:39:02 morrison Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.348 2004/02/02 17:39:02 morrison Exp $ (BRL)"
d2146 1
a2146 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.348 2004/02/02 17:39:02 morrison Exp $
d3955 3
a3957 4
void
extern nmg_pl_shell(FILE		*fp,
		    const struct shell	*s,
		    int			fancy);
@


11.348
log
@update copyright to include span through 2003
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.347 2003/10/29 18:00:33 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.347 2003/10/29 18:00:33 jra Exp $ (BRL)"
d2146 1
a2146 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.347 2003/10/29 18:00:33 jra Exp $
d2860 9
@


11.347
log
@modified declarations of remove_from_bsp() and insert_in_bsp().
Added declarations for get_solidbitv() and rt_zero_res_stats().
Added two fields to the rt_i structure for dynamic geometry
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1993 by the United States Army.
d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.346 2003/08/02 23:17:25 butler Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.346 2003/08/02 23:17:25 butler Exp $ (BRL)"
d2143 1
a2143 1
 *	This software is Copyright (C) 1994 by the United States Army
d2146 1
a2146 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.346 2003/08/02 23:17:25 butler Exp $
@


11.346
log
@Added signature for dsp_pos for querying relative locations to a DSP surface
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.345 2003/04/07 17:46:40 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.345 2003/04/07 17:46:40 jra Exp $ (BRL)"
d1489 2
d1773 3
d2146 1
a2146 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.345 2003/04/07 17:46:40 jra Exp $
d2533 2
a2534 2
extern void remove_from_bsp( struct soltab *stp, union cutter *cutp );
extern void insert_in_bsp( struct soltab *stp, union cutter *cutp, struct resource *resp, fastf_t bb[6] );
d3176 1
d3181 1
@


11.346.4.1
log
@updates from HEAD, part 1
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.347 2003/10/29 18:00:33 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.347 2003/10/29 18:00:33 jra Exp $ (BRL)"
a1488 2
	/* Above here must be filled in by application */
	/* Below here is used by dynamic geometry routines, should be zeroed by application before use */
a1770 3
	/* Parameters for dynamic geometry */
	int		rti_add_to_new_solids_list;
	struct bu_ptbl	rti_new_solids;
d2141 1
a2141 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.347 2003/10/29 18:00:33 jra Exp $
d2528 2
a2529 2
extern void remove_from_bsp( struct soltab *stp, union cutter *cutp, struct bn_tol *tol );
extern void insert_in_bsp( struct soltab *stp, union cutter *cutp );
a3170 1
extern struct bu_bitv *get_solidbitv( long nbits, struct resource *resp );
a3174 1
extern void rt_zero_res_stats( struct resource *resp );
@


11.346.4.2
log
@merge from HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1993-2004 by the United States Army.
d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.349 2004/02/03 21:44:57 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.349 2004/02/03 21:44:57 jra Exp $ (BRL)"
d2143 1
a2143 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d2146 1
a2146 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.349 2004/02/03 21:44:57 jra Exp $
a2859 9

/* g_extrude.c */
extern int rt_extrude_import5(
	struct rt_db_internal		*ip,
	const struct bu_external	*ep,
	register const mat_t		mat,
	const struct db_i		*dbip,
	struct resource			*resp,
	const int			minor_type );
@


11.346.4.3
log
@merge from head
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.350 2004/03/03 21:45:30 morrison Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.350 2004/03/03 21:45:30 morrison Exp $ (BRL)"
d2146 1
a2146 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.350 2004/03/03 21:45:30 morrison Exp $
d3955 4
a3958 3
BU_EXTERN(void			nmg_pl_shell, (FILE *fp, 
					     const struct shell *s,
					     int fancy));
@


11.346.4.4
log
@merge from head
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.346.4.3 2004/03/10 13:21:20 erikg Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.346.4.3 2004/03/10 13:21:20 erikg Exp $ (BRL)"
d2146 1
a2146 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.346.4.3 2004/03/10 13:21:20 erikg Exp $
@


11.346.4.5
log
@merge from head...
@
text
@d45 1
a45 1
 *  $Header$
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header$ (BRL)"
a1175 11
#ifdef WIN32
	HANDLE			fd;
	HANDLE			hProcess;
	DWORD			pid;

#ifdef TCL_OK
	Tcl_Channel		chan;
#else
	genptr_t chan;
#endif
#else
a1177 1
#endif	
d2146 1
a2146 1
 *  $Header$
@


11.345
log
@Added a bu_ptbl field to the rt_i structure (delete_regs). This table
holds a list of invisible light regions. After light_init() has been
called, references to these invisible regions will be removed by
eliminating refernces to them from all soltab structures.
So far this is only used by RT.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.344 2003/01/31 13:32:51 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.344 2003/01/31 13:32:51 jra Exp $ (BRL)"
d1584 8
a1591 2
	void		(*a_multioverlap)BU_ARGS( (struct application *, struct partition *, struct bu_ptbl *, struct partition *) );	/* called to resolve overlaps */
	void		(*a_logoverlap)BU_ARGS( (struct application *, const struct partition *, const struct bu_ptbl *, const struct partition *) );	/* called to log overlaps */
d2141 1
a2141 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.344 2003/01/31 13:32:51 jra Exp $
d3104 3
@


11.345.2.1
log
@updated for merging
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.346 2003/08/02 23:17:25 butler Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.346 2003/08/02 23:17:25 butler Exp $ (BRL)"
d1584 2
a1585 8
	void		(*a_multioverlap)BU_ARGS( (struct application *,	/* called to resolve overlaps */
						   struct partition *,
						   struct bu_ptbl *,
						   struct partition *) );
	void		(*a_logoverlap)BU_ARGS( (struct application *,	/* called to log overlaps */
						 const struct partition *,
						 const struct bu_ptbl *,
						 const struct partition *) );
d2135 1
a2135 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.346 2003/08/02 23:17:25 butler Exp $
a3097 3

/* g_dsp.c */
BU_EXTERN(int dsp_pos, (point_t out, struct soltab *stp, point_t p));
@


11.344
log
@Added wdb_smooth_bot_cmd() and rt_smooth_bot()
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.343 2003/01/20 02:04:03 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.343 2003/01/20 02:04:03 jra Exp $ (BRL)"
d1725 1
d2135 1
a2135 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.343 2003/01/20 02:04:03 jra Exp $
@


11.343
log
@Added "a_inv_dir" field to application structure, used by rt_pipe_shot()
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.342 2002/10/21 02:52:50 morrison Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.342 2002/10/21 02:52:50 morrison Exp $ (BRL)"
d2134 1
a2134 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.342 2002/10/21 02:52:50 morrison Exp $
d3822 2
d4820 1
@


11.342
log
@Added a check if the system defines INFINITY before us.  Since we can't trust it to be a floating point infinity, we undefine it.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.341 2002/09/30 14:02:52 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.341 2002/09/30 14:02:52 jra Exp $ (BRL)"
d1604 1
d2134 1
a2134 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.341 2002/09/30 14:02:52 jra Exp $
@


11.341
log
@Added support for dynamic geometry
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.340 2002/08/20 17:07:30 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.340 2002/08/20 17:07:30 jra Exp $ (BRL)"
d138 4
d2133 1
a2133 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.340 2002/08/20 17:07:30 jra Exp $
@


11.340
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.338 2002/08/15 13:49:36 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.338 2002/08/15 13:49:36 jra Exp $ (BRL)"
d705 2
a706 1
		int	bn_piecelen;	/* # of solids with pieces */
d1475 22
d2129 1
a2129 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.338 2002/08/15 13:49:36 jra Exp $
d2516 3
a2518 1

d3148 8
d3162 1
@


11.340.2.1
log
@Added initial stubbed support for a new primitive -- a superquadric ellipsoid.  The primitive may be created in mged, but it has the same guts as the ellipsoid
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.340 2002/08/20 17:07:30 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.340 2002/08/20 17:07:30 jra Exp $ (BRL)"
d525 1
a525 6
#define ID_SUPERELL	31	/* Superquadratic ellipsoid */

  /* Add a new primitive id above here
   * XXX must update the non-geometric object id's below XXX 
   */
#define	ID_MAX_SOLID	31	/* Maximum defined ID_xxx for solids */
d530 5
a534 5
#define ID_COMBINATION	32	/* Combination Record */
#define ID_BINEXPM	33	/* Experimental binary */
#define ID_BINUNIF	34	/* Uniform-array binary */
#define ID_BINMIME	35	/* MIME-typed binary */
#define ID_MAXIMUM	36	/* Maximum defined ID_xxx value */
d2106 1
a2106 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.340 2002/08/20 17:07:30 jra Exp $
@


11.340.2.2
log
@added check for infinity already being defined to quell warnings
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.340.2.1 2003/01/31 00:11:53 morrison Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.340.2.1 2003/01/31 00:11:53 morrison Exp $ (BRL)"
a137 3
#ifdef INFINITY
#	undef INFINITY
#endif
d2111 1
a2111 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.340.2.1 2003/01/31 00:11:53 morrison Exp $
@


11.340.2.3
log
@sync branch with HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1993-2004 by the United States Army.
d45 1
a45 1
 *  $Header$
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header$ (BRL)"
a140 1

d713 1
a713 2
		int	bn_piecelen;	/* # of piecelists used */
		int	bn_maxpiecelen; /* # of piecelists allocated */
a1178 11
#ifdef WIN32
	HANDLE			fd;
	HANDLE			hProcess;
	DWORD			pid;

#ifdef TCL_OK
	Tcl_Channel		chan;
#else
	genptr_t chan;
#endif
#else
a1180 1
#endif	
a1481 24

/*			R T _ R E P R E P _ O B J _ L I S T
 *
 *	Structure used by the "reprep" routines
 */
struct rt_reprep_obj_list {
	int ntopobjs;		/* number of objects in the original call to gettrees */
	char **topobjs;		/* list of the above object names */
	int nunprepped;		/* number of objects to be unprepped and re-prepped */
	char **unprepped;	/* list of the above objects */
	/* Above here must be filled in by application */
	/* Below here is used by dynamic geometry routines, should be zeroed by application before use */
	struct bu_ptbl paths;	/* list of all paths from topobjs to unprepped objects */
	struct db_tree_state **tsp;	/* tree state used by tree walker in "reprep" routines */
	struct bu_ptbl unprep_regions;	/* list of region structures that will be "unprepped" */
	long old_nsolids;		/* rtip->nsolids before unprep */
	long old_nregions;		/* rtip->nregions before unprep */
	long nsolids_unprepped;		/* number of soltab structures eliminated by unprep */
	long nregions_unprepped;	/* number of region structures eliminated by unprep */
};




d1565 2
a1566 8
	void		(*a_multioverlap)BU_ARGS( (struct application *,	/* called to resolve overlaps */
						   struct partition *,
						   struct bu_ptbl *,
						   struct partition *) );
	void		(*a_logoverlap)BU_ARGS( (struct application *,	/* called to log overlaps */
						 const struct partition *,
						 const struct bu_ptbl *,
						 const struct partition *) );
a1584 1
	vect_t		a_inv_dir;	/* filled in by rt_shootray(), inverse of ray direction cosines */
a1704 1
	struct bu_ptbl	delete_regs;	/* list of region pointers to delete after light_init() */
a1743 3
	/* Parameters for dynamic geometry */
	int		rti_add_to_new_solids_list;
	struct bu_ptbl	rti_new_solids;
d2111 1
a2111 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d2114 1
a2114 1
 *  $Header$
d2501 1
a2501 3
extern void remove_from_bsp( struct soltab *stp, union cutter *cutp, struct bn_tol *tol );
extern void insert_in_bsp( struct soltab *stp, union cutter *cutp );
extern void fill_out_bsp( struct rt_i *rtip, union cutter *cutp, struct resource *resp, fastf_t bb[6] );
a2826 9
/* g_extrude.c */
extern int rt_extrude_import5(
	struct rt_db_internal		*ip,
	const struct bu_external	*ep,
	register const mat_t		mat,
	const struct db_i		*dbip,
	struct resource			*resp,
	const int			minor_type );

a3075 3
/* g_dsp.c */
BU_EXTERN(int dsp_pos, (point_t out, struct soltab *stp, point_t p));

a3130 9
extern int rt_unprep( struct rt_i *rtip, struct rt_reprep_obj_list *objs, struct resource *resp );
extern int rt_reprep( struct rt_i *rtip, struct rt_reprep_obj_list *objs, struct resource *resp );
extern int re_prep_solids( struct rt_i *rtip, int num_solids, char **solid_names, struct resource *resp );
extern int rt_find_paths( struct db_i *dbip,
	       struct directory *start,
	       struct directory *end,
	       struct bu_ptbl *paths,
	       struct resource *resp );
extern struct bu_bitv *get_solidbitv( long nbits, struct resource *resp );
a3134 1
extern void rt_zero_res_stats( struct resource *resp );
a3136 1
extern void rt_res_pieces_init( struct resource *resp, struct rt_i *rtip );
a3790 2
int rt_smooth_bot( struct rt_bot_internal *bot, char *bot_name, struct db_i *dbip, fastf_t normal_tolerance_angle );

d3896 4
a3899 3
BU_EXTERN(void			nmg_pl_shell, (FILE *fp, 
					     const struct shell *s,
					     int fancy));
a4786 1
BU_EXTERN(int	wdb_smooth_bot_cmd,	(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
@


11.340.2.4
log
@quell warnings
@
text
@d45 1
a45 1
 *  $Header: /n/cad/c/CVS/brlcad/h/raytrace.h,v 11.340.2.3 2004/03/17 21:16:14 morrison Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /n/cad/c/CVS/brlcad/h/raytrace.h,v 11.340.2.3 2004/03/17 21:16:14 morrison Exp $ (BRL)"
d2163 1
a2163 1
 *  $Header: /n/cad/c/CVS/brlcad/h/raytrace.h,v 11.340.2.3 2004/03/17 21:16:14 morrison Exp $
d2740 1
a2740 1
	int			avail,
d3174 1
a3174 1
	int			avail,
@


11.340.2.5
log
@more quelling of lots of warnings
@
text
@d45 1
a45 1
 *  $Header: /n/cad/c/CVS/brlcad/h/raytrace.h,v 11.340.2.4 2004/04/04 20:59:05 morrison Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /n/cad/c/CVS/brlcad/h/raytrace.h,v 11.340.2.4 2004/04/04 20:59:05 morrison Exp $ (BRL)"
d1238 1
a1238 1
#if defined(USE_SURVICE_MODS)
d2163 1
a2163 1
 *  $Header: /n/cad/c/CVS/brlcad/h/raytrace.h,v 11.340.2.4 2004/04/04 20:59:05 morrison Exp $
@


11.340.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.340 2002/08/20 17:07:30 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.340 2002/08/20 17:07:30 jra Exp $ (BRL)"
a1170 11
#ifdef WIN32
	HANDLE			fd;
	HANDLE			hProcess;
	DWORD			pid;

#ifdef TCL_OK
	Tcl_Channel		chan;
#else
	genptr_t chan;
#endif
#else
a1172 1
#endif	
d2106 1
a2106 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.340 2002/08/20 17:07:30 jra Exp $
@


11.340.4.2
log
@sync to HEAD...
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1993-2004 by the United States Army.
d45 1
a45 1
 *  $Header: /n/cad/c/CVS/brlcad/h/raytrace.h,v 11.340.4.1 2002/09/26 23:03:45 morrison Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /n/cad/c/CVS/brlcad/h/raytrace.h,v 11.340.4.1 2002/09/26 23:03:45 morrison Exp $ (BRL)"
a137 4
#ifdef INFINITY
#	undef INFINITY
#endif

d705 1
a705 2
		int	bn_piecelen;	/* # of piecelists used */
		int	bn_maxpiecelen; /* # of piecelists allocated */
a1485 24

/*			R T _ R E P R E P _ O B J _ L I S T
 *
 *	Structure used by the "reprep" routines
 */
struct rt_reprep_obj_list {
	int ntopobjs;		/* number of objects in the original call to gettrees */
	char **topobjs;		/* list of the above object names */
	int nunprepped;		/* number of objects to be unprepped and re-prepped */
	char **unprepped;	/* list of the above objects */
	/* Above here must be filled in by application */
	/* Below here is used by dynamic geometry routines, should be zeroed by application before use */
	struct bu_ptbl paths;	/* list of all paths from topobjs to unprepped objects */
	struct db_tree_state **tsp;	/* tree state used by tree walker in "reprep" routines */
	struct bu_ptbl unprep_regions;	/* list of region structures that will be "unprepped" */
	long old_nsolids;		/* rtip->nsolids before unprep */
	long old_nregions;		/* rtip->nregions before unprep */
	long nsolids_unprepped;		/* number of soltab structures eliminated by unprep */
	long nregions_unprepped;	/* number of region structures eliminated by unprep */
};




d1569 2
a1570 8
	void		(*a_multioverlap)BU_ARGS( (struct application *,	/* called to resolve overlaps */
						   struct partition *,
						   struct bu_ptbl *,
						   struct partition *) );
	void		(*a_logoverlap)BU_ARGS( (struct application *,	/* called to log overlaps */
						 const struct partition *,
						 const struct bu_ptbl *,
						 const struct partition *) );
a1588 1
	vect_t		a_inv_dir;	/* filled in by rt_shootray(), inverse of ray direction cosines */
a1708 1
	struct bu_ptbl	delete_regs;	/* list of region pointers to delete after light_init() */
a1747 3
	/* Parameters for dynamic geometry */
	int		rti_add_to_new_solids_list;
	struct bu_ptbl	rti_new_solids;
d2115 1
a2115 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d2118 1
a2118 1
 *  $Header: /n/cad/c/CVS/brlcad/h/raytrace.h,v 11.340.4.1 2002/09/26 23:03:45 morrison Exp $
d2505 1
a2505 3
extern void remove_from_bsp( struct soltab *stp, union cutter *cutp, struct bn_tol *tol );
extern void insert_in_bsp( struct soltab *stp, union cutter *cutp );
extern void fill_out_bsp( struct rt_i *rtip, union cutter *cutp, struct resource *resp, fastf_t bb[6] );
a2830 9
/* g_extrude.c */
extern int rt_extrude_import5(
	struct rt_db_internal		*ip,
	const struct bu_external	*ep,
	register const mat_t		mat,
	const struct db_i		*dbip,
	struct resource			*resp,
	const int			minor_type );

a3079 3
/* g_dsp.c */
BU_EXTERN(int dsp_pos, (point_t out, struct soltab *stp, point_t p));

a3134 9
extern int rt_unprep( struct rt_i *rtip, struct rt_reprep_obj_list *objs, struct resource *resp );
extern int rt_reprep( struct rt_i *rtip, struct rt_reprep_obj_list *objs, struct resource *resp );
extern int re_prep_solids( struct rt_i *rtip, int num_solids, char **solid_names, struct resource *resp );
extern int rt_find_paths( struct db_i *dbip,
	       struct directory *start,
	       struct directory *end,
	       struct bu_ptbl *paths,
	       struct resource *resp );
extern struct bu_bitv *get_solidbitv( long nbits, struct resource *resp );
a3138 1
extern void rt_zero_res_stats( struct resource *resp );
a3140 1
extern void rt_res_pieces_init( struct resource *resp, struct rt_i *rtip );
a3794 2
int rt_smooth_bot( struct rt_bot_internal *bot, char *bot_name, struct db_i *dbip, fastf_t normal_tolerance_angle );

d3900 4
a3903 3
BU_EXTERN(void			nmg_pl_shell, (FILE *fp, 
					     const struct shell *s,
					     int fancy));
a4790 1
BU_EXTERN(int	wdb_smooth_bot_cmd,	(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
@


11.339
log
@Converted from K&R to ANSI C - RFH
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.337 2002/07/16 02:17:10 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.337 2002/07/16 02:17:10 jra Exp $ (BRL)"
d2106 1
a2106 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.337 2002/07/16 02:17:10 jra Exp $
d2826 2
a2827 1
		     int			flags);
@


11.338
log
@New declaration of db_inmem()
@
text
@d2826 1
a2826 2
		     int		flags,
		     struct db_i	*dbip);
@


11.337
log
@Added rt_curve_order_segments() and rt_curve_reverse_segment()
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.336 2002/06/19 20:07:44 butler Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.336 2002/06/19 20:07:44 butler Exp $ (BRL)"
d2106 1
a2106 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.336 2002/06/19 20:07:44 butler Exp $
d2826 2
a2827 1
		     int			flags);
@


11.336
log
@SURVICE mods
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.335 2002/02/25 15:21:39 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.335 2002/02/25 15:21:39 jra Exp $ (BRL)"
d2106 1
a2106 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.335 2002/02/25 15:21:39 jra Exp $
d3190 3
@


11.335
log
@Added a directory flag (dp->d_flags) for non-geometry database objects
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.334 2002/02/22 16:08:01 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.334 2002/02/22 16:08:01 jra Exp $ (BRL)"
d1216 3
d2106 1
a2106 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.334 2002/02/22 16:08:01 jra Exp $
d4796 1
@


11.334
log
@Added db_lookup_by_attr()
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.333 2002/02/05 03:12:27 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.333 2002/02/05 03:12:27 jra Exp $ (BRL)"
d844 1
d2103 1
a2103 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.333 2002/02/05 03:12:27 jra Exp $
@


11.333
log
@Mods to reflect change in "attr" routines (no separate "rm" routine)
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.332 2002/01/22 19:01:31 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.332 2002/01/22 19:01:31 jra Exp $ (BRL)"
d2102 1
a2102 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.332 2002/01/22 19:01:31 jra Exp $
d2831 2
@


11.332
log
@Added bot_decimate command (and support) to MGED
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.331 2001/12/27 15:17:48 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.331 2001/12/27 15:17:48 jra Exp $ (BRL)"
d2102 1
a2102 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.331 2001/12/27 15:17:48 jra Exp $
a4758 1
BU_EXTERN(int	wdb_attr_rm_cmd,	(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv));
@


11.331
log
@Eliminated duplicate delcaration of a function
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.330 2001/12/13 19:32:35 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.330 2001/12/13 19:32:35 jra Exp $ (BRL)"
d2102 1
a2102 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.330 2001/12/13 19:32:35 jra Exp $
d4710 1
@


11.330
log
@Added declaration of wdb_bot_face_sort_cmd()
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.329 2001/12/08 21:09:50 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.329 2001/12/08 21:09:50 jra Exp $ (BRL)"
d2102 1
a2102 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.329 2001/12/08 21:09:50 jra Exp $
a3769 1
int rt_bot_find_e_nearest_pt2();	/* needs rt_bot_internal for arg list */
@


11.329
log
@Added defines for default values for rt_bot_minpieces and rt_tris_per_piece
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.328 2001/11/27 17:47:22 bparker Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.328 2001/11/27 17:47:22 bparker Exp $ (BRL)"
d2102 1
a2102 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.328 2001/11/27 17:47:22 bparker Exp $
d4710 1
@


11.328
log
@*- add members to "struct dg_obj" in support
   of qray and nirt
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.327 2001/11/26 19:37:44 butler Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.327 2001/11/26 19:37:44 butler Exp $ (BRL)"
d1372 4
d2102 1
a2102 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.327 2001/11/26 19:37:44 butler Exp $
@


11.327
log
@moved bot_specific structure to its own header file called "bot.h" in librt
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.326 2001/11/15 22:03:30 bparker Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.326 2001/11/15 22:03:30 bparker Exp $ (BRL)"
d1184 11
d1206 9
d2098 1
a2098 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.326 2001/11/15 22:03:30 bparker Exp $
@


11.326
log
@*- declare wdb_binary_cmd
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.325 2001/11/09 20:40:02 bparker Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.325 2001/11/09 20:40:02 bparker Exp $ (BRL)"
d2078 1
a2078 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.325 2001/11/09 20:40:02 bparker Exp $
a3725 25
struct bot_specific
{
	unsigned char bot_mode;
	unsigned char bot_orientation;
	unsigned char bot_errmode;
	fastf_t *bot_thickness;
	struct bu_bitv *bot_facemode;
	struct tri_specific *bot_facelist;	/* head of linked list */
	struct tri_specific **bot_facearray;	/* head of face array */
};


void rt_bot_prep_pieces(struct bot_specific	*bot,
			struct soltab		*stp,
			int			ntri,
			const struct bn_tol	*tol);

extern int rt_botface(struct soltab	*stp,
		      struct bot_specific	*bot,
		      fastf_t		*ap,
		      fastf_t		*bp,
		      fastf_t		*cp,
		      int			face_no,
		      const struct bn_tol	*tol);

@


11.325
log
@*- added get_autoview command. This command returns
   the view center and size necessary to see all geometry.
   Currently, only mouse_shoot_ray uses this.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.324 2001/11/08 22:04:17 butler Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.324 2001/11/08 22:04:17 butler Exp $ (BRL)"
d2078 1
a2078 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.324 2001/11/08 22:04:17 butler Exp $
d4769 1
@


11.324
log
@Changes to "Keep" to require both databases be in the same format
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.323 2001/11/07 19:35:37 butler Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.323 2001/11/07 19:35:37 butler Exp $ (BRL)"
d2078 1
a2078 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.323 2001/11/07 19:35:37 butler Exp $
d4778 1
@


11.323
log
@Changes to have the ARS use the BOT ray intersection code.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.322 2001/11/02 04:58:38 butler Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.322 2001/11/02 04:58:38 butler Exp $ (BRL)"
d2078 1
a2078 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.322 2001/11/02 04:58:38 butler Exp $
d2487 1
@


11.322
log
@extern of rt_nul_make
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.321 2001/11/02 01:54:12 butler Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.321 2001/11/02 01:54:12 butler Exp $ (BRL)"
d2078 1
a2078 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.321 2001/11/02 01:54:12 butler Exp $
d3725 25
@


11.321
log
@changes to _describe() prototype in raytrace.h
Values for DSP cut type flags changed to make human editing easier.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.320 2001/11/01 21:39:33 bparker Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.320 2001/11/01 21:39:33 bparker Exp $ (BRL)"
d2078 1
a2078 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.320 2001/11/01 21:39:33 bparker Exp $
d3075 3
@


11.320
log
@*- added "struct db_i *" parameter to ft_describe
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.319 2001/10/04 21:56:48 bparker Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.319 2001/10/04 21:56:48 bparker Exp $ (BRL)"
d2078 1
a2078 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.319 2001/10/04 21:56:48 bparker Exp $
d2691 2
a2692 1
	struct resource *resp);
@


11.319
log
@*- add declaration for wdb_version_cmd
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.318 2001/09/07 17:07:40 bparker Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.318 2001/09/07 17:07:40 bparker Exp $ (BRL)"
d1965 2
a1966 1
			struct resource * /*resp*/));
d2078 1
a2078 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.318 2001/09/07 17:07:40 bparker Exp $
@


11.318
log
@*- added declaration for db5_update_attribute
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.317 2001/08/14 18:24:25 bparker Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.317 2001/08/14 18:24:25 bparker Exp $ (BRL)"
d2077 1
a2077 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.317 2001/08/14 18:24:25 bparker Exp $
d4737 1
@


11.317
log
@*- add member to view_obj (vo_zclip)
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.316 2001/08/02 17:44:58 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.316 2001/08/02 17:44:58 jra Exp $ (BRL)"
d2077 1
a2077 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.316 2001/08/02 17:44:58 jra Exp $
d2641 1
@


11.316
log
@Added db_diradd5()
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.315 2001/06/22 20:40:53 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.315 2001/06/22 20:40:53 jra Exp $ (BRL)"
d1227 1
d2077 1
a2077 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.315 2001/06/22 20:40:53 jra Exp $
@


11.315
log
@Added a pointer in rt_i for ORCA hash table
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.314 2001/06/18 19:25:09 bparker Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.314 2001/06/18 19:25:09 bparker Exp $ (BRL)"
d2076 1
a2076 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.314 2001/06/18 19:25:09 bparker Exp $
d2805 8
@


11.314
log
@*- declare wdb_attr_rm_cmd
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.313 2001/06/06 16:46:07 bparker Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.313 2001/06/06 16:46:07 bparker Exp $ (BRL)"
d1667 1
d2076 1
a2076 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.313 2001/06/06 16:46:07 bparker Exp $
d2367 1
a2367 1
BU_EXTERN(int rt_gettrees_muves, (struct rt_i *rtip, const char **attrs, Tcl_HashTable *tbl,
@


11.313
log
@*- add wdb_lt_cmd (i.e. lt command which
   returns a tcl list of {op obj} pairs)
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.312 2001/06/05 15:49:17 bparker Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.312 2001/06/05 15:49:17 bparker Exp $ (BRL)"
d2075 1
a2075 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.312 2001/06/05 15:49:17 bparker Exp $
d4717 1
@


11.312
log
@*- declare wdb_pathlist_cmd
*- change signature of vo_setview
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.311 2001/06/01 16:55:35 bparker Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.311 2001/06/01 16:55:35 bparker Exp $ (BRL)"
d2075 1
a2075 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.311 2001/06/01 16:55:35 bparker Exp $
d4682 1
@


11.311
log
@*- add member (wdb_interp) to "struct rt_wdb"
*- add members (vo_callback and vo_clientData) to "struct view_obj"
*- declare functions for the view object and
   the drawable geometry object
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.310 2001/05/17 20:04:55 morrison Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.310 2001/05/17 20:04:55 morrison Exp $ (BRL)"
d2075 1
a2075 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.310 2001/05/17 20:04:55 morrison Exp $
d4682 1
d4769 1
a4769 1
BU_EXTERN(void	vo_setview,		(struct view_obj *vop, Tcl_Interp *interp, double a1, double a2, double a3));
@


11.310
log
@rt_g.debug -> RT_G_DEBUG
Added a new PRODUCTION option of NO_DEBUG_CHECKING to not use the rt_g.debug facilities.  This performance boost gets us ~10% by defining RT_G_DEBUG to 0 in debug mode (and to rt_g.debug otherwise).
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.309 2001/05/17 19:01:04 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.309 2001/05/17 19:01:04 jra Exp $ (BRL)"
d1133 1
d1225 2
d1230 2
d2075 1
a2075 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.309 2001/05/17 19:01:04 jra Exp $
d4667 1
d4723 79
@


11.309
log
@Added rt_gettrees_muves() to do rt_gettrees() with ORCA stuff and attributes
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.308 2001/05/16 21:37:43 morrison Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.308 2001/05/16 21:37:43 morrison Exp $ (BRL)"
d74 1
a74 1
 *  by a separate bit in the word rt_g.debug
d1592 11
d2070 1
a2070 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.308 2001/05/16 21:37:43 morrison Exp $
@


11.308
log
@PRODUCTION optimizations
included a section in conf.h that controls how most optimization settings are used
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.307 2001/05/14 01:46:19 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.307 2001/05/14 01:46:19 jra Exp $ (BRL)"
d2059 1
a2059 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.307 2001/05/14 01:46:19 jra Exp $
d2350 2
@


11.307
log
@Added declaration for db5_replace_attributes()
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.306 2001/05/11 15:24:58 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.306 2001/05/11 15:24:58 jra Exp $ (BRL)"
d623 1
a623 1
	bcopy((char *)(&(old)->RT_PT_MIDDLE_START), (char *)(&(new)->RT_PT_MIDDLE_START), RT_PT_MIDDLE_LEN(old) ); \
d630 1
a630 1
	bzero( ((char *) &(p)->RT_PT_MIDDLE_START), RT_PT_MIDDLE_LEN(p) ); }
d1465 1
a1465 1
 *  The entire structure should be zeroed (e.g. by bzero() ) before it
d1504 1
a1504 1
 *  by using "bzero( (char *)ap, sizeof(struct application) );" or
d1563 1
a1563 1
		bzero( (char *)(_p), sizeof(struct application) ); \
d1567 5
a1571 1
#define RT_AP_CHECK(_ap)	\
d1574 1
d2059 1
a2059 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.306 2001/05/11 15:24:58 jra Exp $
d2260 4
a2263 1
#define nmg_rt_bomb(rd, str) { \
d2272 2
@


11.306
log
@Added declarations for rt_gettrees_and_attrs() and rt_load_attrs()
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.305 2001/05/08 20:04:50 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.305 2001/05/08 20:04:50 jra Exp $ (BRL)"
d2054 1
a2054 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.305 2001/05/08 20:04:50 jra Exp $
d2611 1
@


11.305
log
@Added support for MRO's (Multiply Represented Objects)
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.304 2001/05/04 14:47:33 bparker Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.304 2001/05/04 14:47:33 bparker Exp $ (BRL)"
d2054 1
a2054 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.304 2001/05/04 14:47:33 bparker Exp $
d2338 3
@


11.304
log
@*- add a few declarations for wdb_obj methods
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.303 2001/04/25 13:44:40 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.303 2001/04/25 13:44:40 jra Exp $ (BRL)"
d572 3
d967 1
d1533 3
d2054 1
a2054 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.303 2001/04/25 13:44:40 jra Exp $
@


11.303
log
@Additions for bezier curves
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.302 2001/04/20 19:52:36 bparker Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.302 2001/04/20 19:52:36 bparker Exp $ (BRL)"
d2047 1
a2047 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.302 2001/04/20 19:52:36 bparker Exp $
d4675 8
@


11.302
log
@*- declarations for wdb_obj methods (C API)
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.301 2001/04/15 02:21:10 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.301 2001/04/15 02:21:10 jra Exp $ (BRL)"
d1807 7
d2047 1
a2047 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.301 2001/04/15 02:21:10 jra Exp $
@


11.301
log
@Added declarations for db5_update_attributes() and db5_get_attributes()
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.300 2001/04/05 19:35:07 morrison Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.300 2001/04/05 19:35:07 morrison Exp $ (BRL)"
d2040 1
a2040 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.300 2001/04/05 19:35:07 morrison Exp $
d2751 2
d4619 49
@


11.300
log
@updated SIGNED to signed
updated CONST to const
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.299 2001/04/02 18:09:19 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.299 2001/04/02 18:09:19 jra Exp $ (BRL)"
d2040 1
a2040 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.299 2001/04/02 18:09:19 jra Exp $
d2593 2
@


11.299
log
@Lint
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.298 2001/03/23 22:33:46 butler Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.298 2001/03/23 22:33:46 butler Exp $ (BRL)"
d218 1
a218 1
	CONST struct rt_functab *idb_meth;	/* for ft_ifree(), etc. */
d462 1
a462 1
	CONST struct rt_functab *st_meth; /* pointer to per-solid methods */
d470 1
a470 1
	CONST struct directory *st_dp;	/* Directory entry of solid */
d555 1
a555 1
	CONST char	*reg_name;	/* Identifying string */
d763 1
a763 1
	char			*CONST*dbi_filepath; /* search path for aux file opens (convenience var) */
d969 1
a969 1
				CONST struct rt_comb_internal * /* combp */,
d984 2
a985 2
	CONST struct rt_tess_tol *ts_ttol;	/* Tessellation tolerance */
	CONST struct bn_tol	*ts_tol;	/* Math tolerance */
d1060 1
a1060 1
		CONST char	*td_name;	/* If non-null, dynamic string describing heritage of this region */
d1499 1
a1499 1
 *  time with "static CONST struct application zero_ap;", or at run time
d1520 1
a1520 1
	void		(*a_logoverlap)BU_ARGS( (struct application *, CONST struct partition *, CONST struct bu_ptbl *, CONST struct partition *) );	/* called to log overlaps */
d1838 1
a1838 1
	void	(*ft_print) BU_ARGS((CONST struct soltab * /*stp*/));
d1861 4
a1864 4
			CONST struct soltab * /*stp*/,
			CONST vect_t /*min*/,
			CONST vect_t /*max*/,
			CONST struct bn_tol * /*tol*/));
d1869 2
a1870 2
			CONST struct rt_tess_tol * /*ttol*/,
			CONST struct bn_tol * /*tol*/));
d1880 2
a1881 2
			CONST struct rt_tess_tol * /*ttol*/,
			CONST struct bn_tol * /*tol*/));
d1886 1
a1886 1
			CONST struct bn_tol * /*tol*/));
d1892 2
a1893 2
			CONST struct rt_tess_tol * /*ttol*/,
			CONST struct bn_tol * /*tol*/));
d1898 1
a1898 1
			CONST struct bn_tol * /*tol*/));
d1901 3
a1903 3
			CONST struct bu_external * /*ep*/,
			CONST mat_t /*mat*/,
			CONST struct db_i * /*dbip*/,
d1905 1
a1905 1
			CONST int minor_type));
d1907 1
a1907 1
			CONST struct rt_db_internal * /*ip*/,
d1909 1
a1909 1
			CONST struct db_i * /*dbip*/,
d1911 1
a1911 1
			CONST int minor_type));
d1913 3
a1915 3
			CONST struct bu_external * /*ep*/,
			CONST mat_t /*mat*/,
			CONST struct db_i * /*dbip*/,
d1918 1
a1918 1
			CONST struct rt_db_internal * /*ip*/,
d1920 1
a1920 1
			CONST struct db_i * /*dbip*/,
d1925 1
a1925 1
			CONST struct rt_db_internal * /*ip*/,
d1930 1
a1930 1
			CONST mat_t /*mat*/, struct rt_db_internal * /*ip*/,
d1933 1
a1933 1
	CONST struct bu_structparse *ft_parsetab;	/* rt_xxx_parse */
d1938 1
a1938 1
			CONST struct rt_db_internal *, CONST char *item));
d1943 1
a1943 1
	int	(*ft_tclform) BU_ARGS((CONST struct rt_functab *,
d1947 1
a1947 1
			CONST struct rt_db_internal *, CONST char *item));
d1952 1
a1952 1
	int	(*ft_tclform) BU_ARGS((CONST struct rt_functab *,
d1955 1
a1955 1
	void	(*ft_make) BU_ARGS((CONST struct rt_functab *,
d1958 2
a1959 2
extern CONST struct rt_functab rt_functab[];
extern CONST int rt_nfunctab;
d1988 2
a1989 2
	CONST union cutter	*lastcut, *lastcell;
	CONST union cutter	*curcut;
d2040 1
a2040 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.298 2001/03/23 22:33:46 butler Exp $
d2286 1
a2286 1
	CONST long	*twod;		/* ptr to face/edge of 2d projection */
d2297 1
a2297 1
BU_EXTERN(struct rt_i *rt_dirbuild, (CONST char *filename, char *buf, int len) );
d2311 2
a2312 2
	CONST struct partition *pp, CONST struct bu_ptbl *regiontable,
	CONST struct partition *InputHdp));
d2314 2
a2315 2
	CONST struct partition *pp, CONST struct bu_ptbl *regiontable,
	CONST struct partition *InputHdp));
d2319 1
a2319 1
BU_EXTERN(CONST char *	rt_basename, (CONST char *str));
d2321 1
a2321 1
BU_EXTERN(int rt_gettree, (struct rt_i *rtip, CONST char *node) );
d2323 1
a2323 1
	int argc, CONST char **argv, int ncpus));
d2325 1
a2325 1
BU_EXTERN(void rt_pr_seg, (CONST struct seg *segp) );
d2327 2
a2328 2
BU_EXTERN(void rt_pr_partitions, (CONST struct rt_i *rtip,
	CONST struct partition *phead, CONST char *title) );
d2330 2
a2331 2
BU_EXTERN(struct soltab *rt_find_solid, (CONST struct rt_i *rtip,
	CONST char *name) );
d2368 1
a2368 1
	CONST struct bu_bitv *solidbits) );
d2376 1
a2376 1
BU_EXTERN(void rt_pr_soltab, (CONST struct soltab *stp) );
d2378 1
a2378 1
BU_EXTERN(void rt_pr_region, (CONST struct region *rp) );
d2380 1
a2380 1
BU_EXTERN(void rt_pr_tree, (CONST union tree *tp, int lvl) );
d2382 2
a2383 2
BU_EXTERN(void rt_pr_tree_val, (CONST union tree *tp,
	CONST struct partition *partp, int pr_name, int lvl));
d2385 1
a2385 1
BU_EXTERN(void rt_pr_pt, (CONST struct rt_i *rtip, CONST struct partition *pp) );
d2387 1
a2387 1
BU_EXTERN(void rt_pr_hit, (CONST char *str, CONST struct hit *hitp) );
d2394 1
a2394 1
BU_EXTERN(void rt_pr_cut, (CONST union cutter *cutp, int lvl) );
d2419 1
a2419 1
	CONST struct rt_i *rtip) );
d2421 1
a2421 1
BU_EXTERN(int rt_rpp_region, (struct rt_i *rtip, CONST char *reg_name,
d2423 4
a2426 4
BU_EXTERN(void rt_bomb, (CONST char *s));
BU_EXTERN(int rt_in_rpp, (struct xray *rp, CONST fastf_t *invdir,
		CONST fastf_t *min, CONST fastf_t *max));
BU_EXTERN(CONST union cutter *rt_cell_n_on_ray, (struct application *ap, int n));
d2481 1
a2481 1
				int argc, CONST char **argv));
d2501 1
a2501 1
			   CONST char			*CONST*argv);
d2516 1
a2516 1
BU_EXTERN(struct db_i *db_open, ( CONST char *name, CONST char *mode ) );
d2518 1
a2518 1
struct db_i *db_create( CONST char *name, int version );
d2537 4
a2540 4
		CONST char			*name,
		CONST unsigned char		hidden,
		CONST struct bu_external	*attrib,
		CONST struct bu_external	*body,
d2551 1
a2551 1
				  CONST int major);
d2564 1
a2564 1
			       CONST int		major);
d2588 1
a2588 1
BU_EXTERN(int db5_fwrite_ident, (FILE *, CONST char *, double));
d2644 1
a2644 1
int db_ck_v4gift_tree( CONST union tree *tp );
d2674 1
a2674 1
			      CONST char		*name,
d2685 1
a2685 1
BU_EXTERN(union record *db_getmrec, ( CONST struct db_i *, CONST struct directory *dp ) );
d2687 1
a2687 1
BU_EXTERN(int db_get, (CONST struct db_i *, CONST struct directory *dp,
d2690 1
a2690 1
BU_EXTERN(int db_put, (struct db_i *, CONST struct directory *dp, union record *where,
d2694 1
a2694 1
BU_EXTERN(genptr_t db_getmrec, ( CONST struct db_i *, CONST struct directory *dp ) );
d2696 1
a2696 1
BU_EXTERN(int db_get, (CONST struct db_i *, CONST struct directory *dp,
d2699 1
a2699 1
BU_EXTERN(int db_put, ( CONST struct db_i *, CONST struct directory *dp,
d2703 1
a2703 1
	CONST struct directory *dp, CONST struct db_i *dbip ) );
d2711 1
a2711 1
	int (*handler)BU_ARGS((struct db_i *, CONST char *name, long addr,
d2748 1
a2748 1
BU_EXTERN(int db_dirhash, (CONST char *str) );
d2750 1
a2750 1
BU_EXTERN(struct directory *db_lookup,( CONST struct db_i *, CONST char *name, int noisy ) );
d2752 1
a2752 1
BU_EXTERN(struct directory *db_diradd, ( struct db_i *, CONST char *name, long laddr,
d2756 3
a2758 3
BU_EXTERN(int db_fwrite_ident, (FILE *, CONST char *, double));
BU_EXTERN(void db_pr_dir, ( CONST struct db_i *dbip ) );
BU_EXTERN(int db_rename, ( struct db_i *, struct directory *, CONST char *newname) );
d2764 2
a2765 2
BU_EXTERN(int db_regexp_match, (CONST char *pattern, CONST char *string));
BU_EXTERN(int db_regexp_match_all, (struct bu_vls *dest, struct db_i *dbip, CONST char *pattern));
d2784 1
a2784 1
	(CONST struct db_tree_state *tsp, CONST struct db_full_path *pathp));
d2786 1
a2786 1
	(CONST struct combined_tree_state *old));
d2789 1
a2789 1
BU_EXTERN(void db_pr_tree_state, (CONST struct db_tree_state *tsp));
d2791 1
a2791 1
	(CONST struct combined_tree_state *ctsp));
d2793 1
a2793 1
	CONST struct db_full_path *pathp, CONST struct rt_comb_internal *comb));
d2795 1
a2795 1
	struct db_full_path *pathp, CONST union tree *tp));
d2817 1
a2817 1
	CONST struct db_full_path	*new_path,
d2821 1
a2821 1
	struct db_full_path *pathp, CONST char *orig_str, int noisy));
d2839 2
a2840 2
BU_EXTERN(int db_walk_tree, (struct db_i *dbip, int argc, CONST char **argv,
	int ncpu, CONST struct db_tree_state *init_state,
d2844 1
a2844 1
		CONST struct rt_comb_internal * /* combp */,
d2925 2
a2926 2
BU_EXTERN(void rt_ell, (fastf_t *ov, CONST fastf_t *V, CONST fastf_t *A,
			CONST fastf_t *B, int sides) );
d2963 2
a2964 2
	       CONST struct rt_tess_tol *ttol,
	       CONST struct bn_tol		*tol); 
d2967 2
a2968 2
		    CONST struct rt_tess_tol *ttol,
		    CONST struct bn_tol		*tol);
d2974 4
a2977 4
BU_EXTERN(void rt_pr_soltab, (CONST struct soltab *stp));
BU_EXTERN(void rt_pr_region, (CONST struct region *rp));
BU_EXTERN(void rt_pr_partitions, (CONST struct rt_i *rtip,
	CONST struct partition	*phead, CONST char *title));
d2979 18
a2996 18
	CONST struct rt_i *rtip, CONST struct partition *pp));
BU_EXTERN(void rt_pr_pt, (CONST struct rt_i *rtip, CONST struct partition *pp));
BU_EXTERN(void rt_pr_seg_vls, (struct bu_vls *, CONST struct seg *));
BU_EXTERN(void rt_pr_seg, (CONST struct seg *segp));
BU_EXTERN(void rt_pr_hit, (CONST char *str, CONST struct hit	*hitp));
BU_EXTERN(void rt_pr_hit_vls, (struct bu_vls *v, CONST char *str,
	CONST struct hit *hitp));
BU_EXTERN(void rt_pr_hitarray_vls, (struct bu_vls *v, CONST char *str,
	CONST struct hit *hitp, int count));
BU_EXTERN(void rt_pr_tree, (CONST union tree *tp, int lvl));
BU_EXTERN(void rt_pr_tree_vls, (struct bu_vls *vls, CONST union tree *tp));
BU_EXTERN(char *rt_pr_tree_str, (CONST union tree *tree));
BU_EXTERN(void rt_pr_tree_val, (CONST union tree *tp,
	CONST struct partition *partp, int pr_name, int lvl));
BU_EXTERN(void rt_pr_fallback_angle, (struct bu_vls *str, CONST char *prefix,
	CONST double angles[5]));
BU_EXTERN(void rt_find_fallback_angle, (double angles[5], CONST vect_t vec));
BU_EXTERN(void rt_pr_tol, (CONST struct bn_tol	*tol));
d3003 1
a3003 1
BU_EXTERN(CONST struct rt_functab *rt_get_functab_by_label, (CONST char *label));
d3059 1
a3059 1
void bn_vlist_rpp( struct bu_list *hd, const point_t minn, CONST point_t maxx );
d3062 1
a3062 1
				CONST char *name));
d3065 1
a3065 1
				CONST unsigned char *buf));
d3067 1
a3067 1
				CONST struct bn_vlblock	*vbp) );
d3069 1
a3069 1
				CONST struct bu_list *vhead));
d3103 1
a3103 1
					CONST struct curve *crv_in));
d3105 1
a3105 1
					(CONST struct rt_sketch_internal *sketch_ip));
d3111 1
a3111 1
BU_EXTERN(void			rt_htbl_init, (struct rt_htbl *b, int len, CONST char *str));
d3144 1
a3144 1
BU_EXTERN(void			nmg_vertex_gv, (struct vertex *v, CONST point_t pt) );
d3146 2
a3147 2
BU_EXTERN(void			nmg_vertexuse_nv, (struct vertexuse *vu, CONST vect_t norm));
BU_EXTERN(void			nmg_vertexuse_a_cnurb, (struct vertexuse *vu, CONST fastf_t *uvw));
d3154 3
a3156 3
BU_EXTERN(void			nmg_loop_g, (struct loop *l, CONST struct bn_tol *tol) );
BU_EXTERN(void			nmg_face_g, (struct faceuse *fu, CONST plane_t p) );
BU_EXTERN(void			nmg_face_new_g, (struct faceuse *fu, CONST plane_t pl));
d3163 3
a3165 3
BU_EXTERN(void			nmg_face_bb, (struct face *f, CONST struct bn_tol *tol) );
BU_EXTERN(void			nmg_shell_a, (struct shell *s, CONST struct bn_tol *tol) );
BU_EXTERN(void			nmg_region_a, (struct nmgregion *r, CONST struct bn_tol *tol) );
d3184 1
a3184 1
				CONST struct bn_tol *tol));
d3189 2
a3190 2
				CONST struct bn_tol	*tol,
				CONST int		simplify));
d3192 1
a3192 1
BU_EXTERN(void			nmg_rm_redundancies, (struct shell *s, CONST struct bn_tol *tol ) );
d3196 1
a3196 1
				CONST struct bn_tol *tol) );
d3199 1
a3199 1
				CONST struct bn_tol	*tol));
d3202 1
a3202 1
				CONST struct bn_tol	*tol));
d3205 1
a3205 1
				CONST struct bn_tol	*tol));
d3211 2
a3212 2
BU_EXTERN(int			nmg_fu_planeeqn, (struct faceuse *fu, CONST struct bn_tol *tol) );
BU_EXTERN(void			nmg_gluefaces, (struct faceuse *fulist[], int n, CONST struct bn_tol *tol) );
d3229 1
a3229 1
				CONST struct bn_tol *tol) );
d3232 1
a3232 1
				(CONST struct loopuse *lu,
d3238 1
a3238 1
				CONST struct bn_tol	*tol));
d3253 1
a3253 1
				struct edgeuse *eu, CONST struct bn_tol *tol));
d3267 2
a3268 2
BU_EXTERN(struct model		*nmg_find_model, (CONST long *magic_p) );
BU_EXTERN(void			nmg_model_bb, (point_t min_pt, point_t max_pt, CONST struct model *m) );
d3272 4
a3275 4
BU_EXTERN(int			nmg_shell_is_empty, (CONST struct shell *s) );
BU_EXTERN(struct shell		*nmg_find_s_of_lu, (CONST struct loopuse *lu) );
BU_EXTERN(struct shell		*nmg_find_s_of_eu, (CONST struct edgeuse *eu) );
BU_EXTERN(struct shell		*nmg_find_s_of_vu, (CONST struct vertexuse *vu) );
d3278 8
a3285 8
BU_EXTERN(struct faceuse	*nmg_find_fu_of_eu, (CONST struct edgeuse *eu));
BU_EXTERN(struct faceuse	*nmg_find_fu_of_lu, (CONST struct loopuse *lu));
BU_EXTERN(struct faceuse	*nmg_find_fu_of_vu, (CONST struct vertexuse *vu) );
BU_EXTERN(struct faceuse	*nmg_find_fu_with_fg_in_s, (CONST struct shell *s1,
				CONST struct faceuse *fu2));
BU_EXTERN(double		nmg_measure_fu_angle, (CONST struct edgeuse *eu,
				CONST vect_t xvec, CONST vect_t yvec,
				CONST vect_t zvec) );
d3288 7
a3294 7
BU_EXTERN(struct loopuse	*nmg_find_lu_of_vu, (CONST struct vertexuse *vu) );
BU_EXTERN(int			nmg_loop_is_a_crack, (CONST struct loopuse *lu) );
BU_EXTERN(int			nmg_loop_is_ccw, (CONST struct loopuse *lu,
				CONST plane_t norm, CONST struct bn_tol *tol) );
BU_EXTERN(CONST struct vertexuse *nmg_loop_touches_self, (CONST struct loopuse *lu));
BU_EXTERN(int			nmg_2lu_identical, (CONST struct edgeuse *eu1,
				CONST struct edgeuse *eu2));
d3297 4
a3300 4
BU_EXTERN(struct edgeuse	*nmg_find_matching_eu_in_s, (CONST struct edgeuse	*eu1,
				CONST struct shell	*s2));
BU_EXTERN(struct edgeuse	*nmg_findeu, (CONST struct vertex *v1, CONST struct vertex *v2,
				CONST struct shell *s, CONST struct edgeuse *eup,
d3302 14
a3315 14
BU_EXTERN(struct edgeuse	*nmg_find_eu_in_face, (CONST struct vertex *v1,
				CONST struct vertex *v2, CONST struct faceuse *fu,
				CONST struct edgeuse *eup, int dangling_only));
BU_EXTERN(struct edgeuse	*nmg_find_e, (CONST struct vertex *v1,
				CONST struct vertex *v2,
				CONST struct shell *s,
				CONST struct edge *ep));
BU_EXTERN(struct edgeuse	*nmg_find_eu_of_vu, (CONST struct vertexuse *vu) );
BU_EXTERN(struct edgeuse	*nmg_find_eu_with_vu_in_lu, (CONST struct loopuse *lu,
				CONST struct vertexuse *vu) );
BU_EXTERN(CONST struct edgeuse	*nmg_faceradial, (CONST struct edgeuse *eu) );
BU_EXTERN(CONST struct edgeuse	*nmg_radial_face_edge_in_shell, (CONST struct edgeuse *eu) );
BU_EXTERN(CONST struct edgeuse *nmg_find_edge_between_2fu, (CONST struct faceuse *fu1,
				CONST struct faceuse *fu2, CONST struct bn_tol *tol));
d3317 2
a3318 2
				CONST point_t pt2, CONST mat_t mat,
				CONST struct bn_tol *tol) );
d3320 1
a3320 1
				CONST struct edgeuse *eu1, CONST struct shell *s2));
d3322 2
a3323 2
				vect_t zvec, CONST struct edgeuse *eu,
				CONST struct bn_tol *tol) );
d3325 1
a3325 1
				CONST struct edgeuse *eu) );
d3327 1
a3327 1
				CONST struct edgeuse	*eu));
d3329 1
a3329 1
				(CONST struct edge *e));
d3332 31
a3362 31
BU_EXTERN(struct vertexuse	*nmg_find_v_in_face, (CONST struct vertex *,
				CONST struct faceuse *) );
BU_EXTERN(struct vertexuse	*nmg_find_v_in_shell, (CONST struct vertex *v,
				CONST struct shell *s, int edges_only));
BU_EXTERN(struct vertexuse	*nmg_find_pt_in_lu, (CONST struct loopuse *lu,
				CONST point_t pt, CONST struct bn_tol *tol));
BU_EXTERN(struct vertexuse	*nmg_find_pt_in_face, (CONST struct faceuse *fu,
				CONST point_t pt,
				CONST struct bn_tol *tol) );
BU_EXTERN(struct vertex		*nmg_find_pt_in_shell, (CONST struct shell *s,
				CONST point_t pt, CONST struct bn_tol *tol) );
BU_EXTERN(struct vertex		*nmg_find_pt_in_model, (CONST struct model *m,
				CONST point_t pt, CONST struct bn_tol *tol));
BU_EXTERN(int			nmg_is_vertex_in_edgelist, (CONST struct vertex *v,
				CONST struct bu_list *hd) );
BU_EXTERN(int			nmg_is_vertex_in_looplist, (CONST struct vertex *v,
				CONST struct bu_list *hd, int singletons) );
BU_EXTERN(struct vertexuse 	*nmg_is_vertex_in_face, (CONST struct vertex *v,
				CONST struct face *f));
BU_EXTERN(int			nmg_is_vertex_a_selfloop_in_shell, (CONST struct vertex *v,
				CONST struct shell *s) );
BU_EXTERN(int			nmg_is_vertex_in_facelist, (CONST struct vertex *v,
				CONST struct bu_list *hd) );
BU_EXTERN(int			nmg_is_edge_in_edgelist, (CONST struct edge *e,
				CONST struct bu_list *hd) );
BU_EXTERN(int			nmg_is_edge_in_looplist, (CONST struct edge *e,
				CONST struct bu_list *hd) );
BU_EXTERN(int			nmg_is_edge_in_facelist, (CONST struct edge *e,
				CONST struct bu_list *hd) );
BU_EXTERN(int			nmg_is_loop_in_facelist, (CONST struct loop *l,
				CONST struct bu_list *fu_hd) );
d3366 1
a3366 1
				CONST long *magic_p));
d3368 1
a3368 1
				CONST long		*magic_p));
d3370 1
a3370 1
				CONST long *magic_p));
d3372 1
a3372 1
				CONST long *magic_p));
d3374 1
a3374 1
				CONST long		*magic_p));
d3376 1
a3376 1
				CONST long *magic_p));
d3378 1
a3378 1
				CONST struct edge_g_lseg *eg));
d3381 4
a3384 4
				CONST long		*magic_p,
				CONST point_t		pt,
				CONST vect_t		dir,
				CONST struct bn_tol	*tol));
d3388 1
a3388 1
				CONST long		*magic_p));
d3390 3
a3392 3
				(CONST struct edgeuse	*eu1,
				CONST struct edgeuse	*eu2,
				CONST struct bn_tol	*tol));
d3396 2
a3397 2
				CONST vect_t		Vec,
				CONST struct bn_tol	*tol));
d3399 4
a3402 4
				CONST vect_t Vec,
				CONST struct bn_tol	*tol));
BU_EXTERN(struct vertexuse	*nmg_find_vertex_in_lu, (CONST struct vertex *v,
				CONST struct loopuse *lu));
d3404 1
a3404 1
				CONST struct bn_tol *tol));
d3406 1
a3406 1
				CONST struct bn_tol *tol));
d3408 2
a3409 2
				CONST int is_void,
				CONST struct bn_tol *tol));
d3411 3
a3413 3
				CONST fastf_t thick,
				CONST int approximate,
				CONST struct bn_tol *tol));
d3416 4
a3419 4
				CONST fastf_t dist,
				CONST int normal_ward,
				CONST int approximate,
				CONST struct bn_tol *tol));
d3423 19
a3441 19
BU_EXTERN(void			nmg_pr_orient, (int orientation, CONST char *h) );
BU_EXTERN(void			nmg_pr_m, (CONST struct model *m) );
BU_EXTERN(void			nmg_pr_r, (CONST struct nmgregion *r, char *h) );
BU_EXTERN(void			nmg_pr_sa, (CONST struct shell_a *sa, char *h) );
BU_EXTERN(void			nmg_pr_lg, (CONST struct loop_g *lg, char *h) );
BU_EXTERN(void			nmg_pr_fg, (CONST long *magic, char *h) );
BU_EXTERN(void			nmg_pr_s, (CONST struct shell *s, char *h) );
BU_EXTERN(void 			nmg_pr_s_briefly, (CONST struct shell *s, char *h));
BU_EXTERN(void			nmg_pr_f, (CONST struct face *f, char *h) );
BU_EXTERN(void			nmg_pr_fu, (CONST struct faceuse *fu, char *h) );
BU_EXTERN(void			nmg_pr_fu_briefly, (CONST struct faceuse *fu,	char *h) );
BU_EXTERN(void			nmg_pr_l, (CONST struct loop *l, char *h) );
BU_EXTERN(void			nmg_pr_lu, (CONST struct loopuse *lu, char *h) );
BU_EXTERN(void			nmg_pr_lu_briefly, (CONST struct loopuse *lu, char *h) );
BU_EXTERN(void			nmg_pr_eg, (CONST long *eg, char *h) );
BU_EXTERN(void			nmg_pr_e, (CONST struct edge *e, char *h) );
BU_EXTERN(void			nmg_pr_eu, (CONST struct edgeuse *eu, char *h) );
BU_EXTERN(void			nmg_pr_eu_briefly, (CONST struct edgeuse *eu, char *h) );
BU_EXTERN(void 			nmg_pr_eu_endpoints, (CONST struct edgeuse *eu,
d3443 8
a3450 8
BU_EXTERN(void			nmg_pr_vg, (CONST struct vertex_g *vg, char *h) );
BU_EXTERN(void			nmg_pr_v, (CONST struct vertex *v, char *h) );
BU_EXTERN(void			nmg_pr_vu, (CONST struct vertexuse *vu, char *h) );
BU_EXTERN(void			nmg_pr_vu_briefly, (CONST struct vertexuse *vu, char *h) );
BU_EXTERN(void			nmg_pr_vua, (CONST long *magic_p, char *h) );
BU_EXTERN(void			nmg_euprint, (CONST char *str, CONST struct edgeuse *eu) );
BU_EXTERN(void			nmg_pr_ptbl, (CONST char *title,
				CONST struct bu_ptbl *tbl,
d3452 3
a3454 3
BU_EXTERN(void			nmg_pr_ptbl_vert_list, (CONST char *str,
				CONST struct bu_ptbl *tbl,
				CONST fastf_t *mag));
d3456 5
a3460 5
				(CONST struct edgeuse	*eu,
				CONST vect_t		xvec,
				CONST vect_t		yvec,
				CONST vect_t		zvec,
				CONST struct bn_tol	*tol));
d3462 9
a3470 9
				(CONST struct edgeuse	*eu,
				CONST vect_t		xvec,
				CONST vect_t		yvec,
				CONST vect_t		zvec,
				CONST struct bn_tol	*tol));
BU_EXTERN(void			nmg_pr_fu_around_eu, (CONST struct edgeuse *eu,
				CONST struct bn_tol	*tol));
BU_EXTERN(void			nmg_pl_lu_around_eu, (CONST struct edgeuse *eu));
BU_EXTERN(void			nmg_pr_fus_in_fg, (CONST long *fg_magic));
d3474 1
a3474 1
					CONST struct bn_tol *tol);
d3483 10
a3492 10
		    CONST point_t p1,
		    CONST point_t p2,
		    CONST vect_t d1,
		    CONST vect_t d2,
			       CONST struct bn_tol *tol);

BU_EXTERN(int			nmg_snurb_calc_lu_uv_orient, (CONST struct loopuse *lu));
BU_EXTERN(void			nmg_snurb_fu_eval, (CONST struct faceuse *fu,
				CONST fastf_t u,
				CONST fastf_t v,
d3495 3
a3497 3
				(CONST struct faceuse *fu,
				CONST fastf_t u,
				CONST fastf_t v,
d3500 2
a3501 2
				(CONST struct faceuse *fu,
				CONST struct vertexuse *vu,
d3503 1
a3503 1
BU_EXTERN(void			nmg_find_zero_length_edges, (CONST struct model *m));
d3505 1
a3505 1
				(CONST struct shell *s,
d3508 1
a3508 1
				(CONST struct shell *s,
d3513 2
a3514 2
				CONST struct bn_tol *tol));
BU_EXTERN(int			nmg_mark_edges_real, (CONST long *magic_p));
d3516 1
a3516 1
				(struct bu_ptbl *tab, CONST struct face_g_plane *fg));
d3518 5
a3522 5
				(struct shell *s, CONST struct bn_tol *tol));
BU_EXTERN(struct edgeuse	*nmg_next_radial_eu, (CONST struct edgeuse *eu,
				CONST struct shell *s, CONST int wires));
BU_EXTERN(struct edgeuse	*nmg_prev_radial_eu, (CONST struct edgeuse *eu,
				CONST struct shell *s, CONST int wires));
d3524 3
a3526 3
				(CONST struct edgeuse *eu, CONST struct shell *s));
BU_EXTERN(int			nmg_check_closed_shell, (CONST struct shell *s,
				CONST struct bn_tol *tol));
d3529 1
a3529 1
BU_EXTERN(void			nmg_loop_plane_newell, (CONST struct loopuse *lu,
d3531 1
a3531 1
BU_EXTERN(fastf_t		nmg_loop_plane_area, (CONST struct loopuse *lu,
d3536 4
a3539 4
BU_EXTERN(fastf_t		nmg_faceuse_area, (CONST struct faceuse *fu));
BU_EXTERN(fastf_t		nmg_shell_area, (CONST struct shell *s));
BU_EXTERN(fastf_t		nmg_region_area, (CONST struct nmgregion *r));
BU_EXTERN(fastf_t		nmg_model_area, (CONST struct model *m));
d3541 1
a3541 1
BU_EXTERN(void			nmg_purge_unwanted_intersection_points, (struct bu_ptbl *vert_list, fastf_t *mag, CONST struct faceuse *fu, CONST struct bn_tol *tol));
d3543 4
a3546 4
BU_EXTERN(void			nmg_rebound, (struct model *m, CONST struct bn_tol *tol) );
BU_EXTERN(void			nmg_count_shell_kids, (CONST struct model *m, unsigned long *total_wires, unsigned long *total_faces, unsigned long *total_points));
BU_EXTERN(void			nmg_close_shell, (struct shell *s, CONST struct bn_tol *tol));
BU_EXTERN(struct shell		*nmg_dup_shell , ( struct shell *s , long ***copy_tbl, CONST struct bn_tol *tol ) );
d3548 3
a3550 3
BU_EXTERN(void			nmg_reverse_radials, (struct faceuse *fu, CONST struct bn_tol *tol));
BU_EXTERN(void			nmg_reverse_face_and_radials, (struct faceuse *fu, CONST struct bn_tol *tol));
BU_EXTERN(int			nmg_shell_is_void, (CONST struct shell *s));
d3552 1
a3552 1
				long *flags, CONST struct bn_tol *tol));
d3554 1
a3554 1
BU_EXTERN(void			nmg_fix_decomposed_shell_normals, (struct shell *s, CONST struct bn_tol *tol));
d3557 1
a3557 1
				CONST struct bn_tol *tol));
d3559 1
a3559 1
				CONST struct bn_tol *tol));
d3561 4
a3564 4
BU_EXTERN(int			nmg_split_loops_into_faces, (long *magic_p, CONST struct bn_tol	*tol));
BU_EXTERN(int			nmg_decompose_shell, (struct shell *s, CONST struct bn_tol *tol));
BU_EXTERN(void			nmg_stash_model_to_file, (CONST char *filename,
				CONST struct model *m, CONST char *title) );
d3568 1
a3568 1
BU_EXTERN(int			nmg_find_isect_faces, (CONST struct vertex *new_v,
d3571 1
a3571 1
				CONST struct bn_tol *tol));
d3573 4
a3576 4
				(struct vertex *new_v, CONST struct bu_ptbl *faces,
				CONST struct bn_tol *tol));
BU_EXTERN(int			nmg_ck_vert_on_fus, (CONST struct vertex *v,
				CONST struct bn_tol *tol));
d3579 2
a3580 2
				CONST struct bn_tol *tol));
BU_EXTERN(void			nmg_kill_cracks_at_vertex, (CONST struct vertex *vp));
d3583 6
a3588 6
				CONST struct bu_ptbl *faces,
				CONST int free_edges,
				CONST int approximate,
				CONST struct bn_tol *tol));
BU_EXTERN(int			nmg_bad_face_normals, (CONST struct shell *s,
				CONST struct bn_tol *tol));
d3590 2
a3591 2
				(CONST struct faceuse *fu1,
				CONST struct faceuse *fu2));
d3593 1
a3593 1
				CONST point_t pt, CONST struct bn_tol *tol));
d3595 1
a3595 1
				CONST struct bu_list *vhead));
d3597 2
a3598 2
				(CONST struct vertex *vpa,
				CONST struct vertex *vpb,
d3600 2
a3601 2
				CONST struct shell *s,
				CONST struct edgeuse *eu,
d3605 1
a3605 1
				(CONST struct faceuse *fu,
d3607 1
a3607 1
				CONST struct bn_tol *tol));
d3611 2
a3612 2
				CONST long **copy_tbl,
				CONST struct bn_tol *tol));
d3615 2
a3616 2
				CONST int approximate,
				CONST struct bn_tol *tol));
d3621 1
a3621 1
				CONST struct bn_tol *tol));
d3623 1
a3623 1
				(struct shell *s, CONST struct bn_tol *tol));
d3630 1
a3630 1
				CONST struct bn_tol *tol));
d3632 3
a3634 3
				struct bu_ptbl *verts, CONST struct bn_tol *tol));
BU_EXTERN( void nmg_isect_shell_self , ( struct shell *s , CONST struct bn_tol *tol ) );
BU_EXTERN(fastf_t		nmg_loop_plane_area , (CONST struct loopuse *lu , plane_t pl ) );
d3636 1
a3636 1
				CONST struct bn_tol *tol));
d3638 1
a3638 1
				CONST struct bn_tol *tol));
d3640 1
a3640 1
BU_EXTERN(int			nmg_to_arb, (CONST struct model *m,
d3642 1
a3642 1
BU_EXTERN(int			nmg_to_tgc, (CONST struct model *m,
d3644 2
a3645 2
				CONST struct bn_tol *tol));
BU_EXTERN(int			nmg_to_poly, (CONST struct model *m,
d3647 1
a3647 1
				CONST struct bn_tol *tol));
d3652 1
a3652 1
				CONST struct bn_tol *tol));
d3654 3
a3656 3
				CONST struct bn_tol *tol,
				CONST fastf_t tol_coll,
				CONST fastf_t min_angle));
d3662 2
a3663 2
		 CONST struct rt_tess_tol *ttol,
		 CONST struct bn_tol	*tol);
d3666 2
a3667 2
		     CONST struct rt_tess_tol *ttol,
		     CONST struct bn_tol	*tol); 
d3690 2
a3691 2
BU_EXTERN(void			nmg_triangulate_model, (struct model *m, CONST struct bn_tol   *tol) );
BU_EXTERN(void			nmg_triangulate_fu, (struct faceuse *fu, CONST struct bn_tol   *tol) );
d3694 2
a3695 2
BU_EXTERN(int			nmg_dangling_face, (CONST struct faceuse *fu,
				CONST char *manifolds));
d3710 2
a3711 2
int rt_tcl_parse_ray( Tcl_Interp *interp, struct xray *rp, CONST char *CONST*argv );
void rt_tcl_pr_cutter( Tcl_Interp *interp, CONST union cutter *cutp );
d3762 7
a3768 7
BU_EXTERN(int			nmg_class_pt_f, (CONST point_t pt,
				CONST struct faceuse *fu,
				CONST struct bn_tol *tol) );
BU_EXTERN(int			nmg_class_pt_s, (CONST point_t pt,
				CONST struct shell *s,
				CONST int in_or_out_only,
				CONST struct bn_tol *tol) );
d3778 3
a3780 3
BU_EXTERN(int			nmg_class_pt_fu_except, (CONST point_t pt,
				CONST struct faceuse *fu,
				CONST struct loopuse *ignore_lu,
d3782 4
a3785 4
				CONST char *priv,
				CONST int call_on_hits,
				CONST int in_or_out_only,
				CONST struct bn_tol *tol) );
d3794 1
a3794 1
				CONST struct vertexuse	*vu));
d3796 1
a3796 1
				CONST struct bu_list	*eu_hd));
d3798 1
a3798 1
				CONST struct loopuse	*lu,
d3800 1
a3800 1
				CONST vectp_t		normal));
d3803 1
a3803 1
				CONST struct faceuse	*fu,
d3807 1
a3807 1
				CONST struct shell	*s,
d3811 1
a3811 1
				CONST struct nmgregion	*r,
d3819 2
a3820 2
				CONST struct edgeuse	*eu,
				CONST vect_t		face_normal,
d3823 1
a3823 1
BU_EXTERN(void			nmg_pl_v, (FILE	*fp, CONST struct vertex *v,
d3825 1
a3825 1
BU_EXTERN(void			nmg_pl_e, (FILE *fp, CONST struct edge *e,
d3827 1
a3827 1
BU_EXTERN(void			nmg_pl_eu, (FILE *fp, CONST struct edgeuse *eu,
d3829 1
a3829 1
BU_EXTERN(void			nmg_pl_lu, (FILE *fp, CONST struct loopuse *fu, 
d3831 1
a3831 1
BU_EXTERN(void			nmg_pl_fu, (FILE *fp, CONST struct faceuse *fu,
d3833 3
a3835 3
BU_EXTERN(void			nmg_pl_s, (FILE *fp, CONST struct shell *s) );
BU_EXTERN(void			nmg_pl_r, (FILE *fp, CONST struct nmgregion *r) );
BU_EXTERN(void			nmg_pl_m, (FILE *fp, CONST struct model *m) );
d3837 1
a3837 1
				CONST struct vertex *v, long *tab) );
d3839 1
a3839 1
				CONST struct edge *e, long *tab,
d3842 1
a3842 1
				CONST struct edgeuse *eu, long *tab,
d3847 5
a3851 5
				CONST struct edgeuse		*eu,
				CONST point_t			center,
				CONST mat_t			mat,
				CONST vect_t			xvec,
				CONST vect_t			yvec,
d3853 1
a3853 1
				CONST struct bn_tol		*tol));
d3856 1
a3856 1
				CONST struct edgeuse		*arg_eu,
d3859 1
a3859 1
				CONST struct bn_tol		*tol));
d3861 1
a3861 1
				CONST struct loopuse *lu, long *tab,
d3865 1
a3865 1
				CONST struct faceuse *fu, long *tab, int fancy) );
d3867 1
a3867 1
				CONST struct shell *s, int fancy) );
d3869 1
a3869 1
				CONST struct nmgregion *r, int fancy) );
d3871 1
a3871 1
				CONST struct model *m, int fancy) );
d3876 1
a3876 1
				CONST struct edgeuse	*eu,
d3878 1
a3878 1
				CONST struct bn_tol	*tol));
d3880 3
a3882 3
				(CONST char		*filename,
				CONST struct shell	*s,
				CONST struct bn_tol	*tol));
d3884 3
a3886 3
				CONST struct faceuse *fu1) );
BU_EXTERN(void			nmg_pl_2fu, (CONST char *str, int num,
				CONST struct faceuse *fu1, CONST struct faceuse *fu2,
d3894 6
a3899 6
				CONST char	*a_string));
BU_EXTERN(void			nmg_face_plot, (CONST struct faceuse *fu) );
BU_EXTERN(void			nmg_2face_plot, (CONST struct faceuse *fu1,
				CONST struct faceuse *fu2) );
BU_EXTERN(void			nmg_face_lu_plot, (CONST struct loopuse *lu,
				CONST struct vertexuse *vu1, CONST struct vertexuse *vu2) );
d3901 4
a3904 4
				(CONST struct loopuse		*lu,
				CONST struct vertexuse		*vu1,
				CONST struct vertexuse		*vu2,
				CONST vect_t			left));
d3906 1
a3906 1
				(CONST char *fname,
d3908 2
a3909 2
				CONST vect_t dir,
				CONST struct faceuse *fu));
d3911 3
a3913 3
				(CONST char		*prefix,
				CONST struct edgeuse	*eu,
				CONST struct bn_tol	*tol));
d3916 1
a3916 1
				CONST struct face_g_snurb	*fg,
d3919 1
a3919 1
				CONST struct edgeuse *eu,int n_interior,
d3942 1
a3942 1
				struct edgeuse *eu2, CONST struct bn_tol *tol));
d3944 1
a3944 1
				struct faceuse *fu2, CONST struct bn_tol *tol) );
d3946 1
a3946 1
				struct shell *s, CONST struct bn_tol *tol));
d3948 4
a3951 4
				struct shell *s2, CONST struct bn_tol *tol));
BU_EXTERN(double		nmg_measure_fu_angle, (CONST struct edgeuse *eu,
				CONST vect_t xvec, CONST vect_t yvec,
				CONST vect_t zvec));
d3956 1
a3956 1
				CONST int oper, CONST struct bn_tol *tol) );
d3958 2
a3959 2
				(struct shell *s, CONST struct bn_tol *tol,
				CONST int simplify) );
d3961 1
a3961 1
				struct nmgregion *r2, CONST struct bn_tol *tol));
d3969 1
a3969 1
				CONST struct bn_tol *tol, struct resource *resp));
d3975 1
a3975 1
				CONST struct bn_tol *tol) );
d3985 2
a3986 2
BU_EXTERN(int			nmg_is_v_on_rs_list, (CONST struct nmg_ray_state *rs,
				CONST struct vertex		*v));
d3993 1
a3993 1
BU_EXTERN(void			nmg_pr_vu_stuff, (CONST struct nmg_vu_stuff *vs));
d4013 1
a4013 1
				CONST struct bn_tol	*tol));
d4017 1
a4017 1
				CONST char		*reason));
d4037 1
a4037 1
				CONST struct bn_tol *tol) );
d4055 2
a4056 2
				CONST struct bn_tol *tolp));
BU_EXTERN(CONST char		*nmg_class_name, (int class_no) );
d4062 1
a4062 1
				CONST struct bn_tol	*tol));
d4094 26
a4119 26
BU_EXTERN(void			nmg_vvg, (CONST struct vertex_g *vg));
BU_EXTERN(void			nmg_vvertex, (CONST struct vertex *v,
				CONST struct vertexuse *vup));
BU_EXTERN(void			nmg_vvua, (CONST long *vua));
BU_EXTERN(void			nmg_vvu, (CONST struct vertexuse *vu,
				CONST long *up_magic_p));
BU_EXTERN(void			nmg_veg, (CONST long *eg));
BU_EXTERN(void			nmg_vedge, (CONST struct edge *e,
				CONST struct edgeuse *eup));
BU_EXTERN(void			nmg_veu, (CONST struct bu_list	*hp,
				CONST long *up_magic_p));
BU_EXTERN(void			nmg_vlg, (CONST struct loop_g *lg));
BU_EXTERN(void			nmg_vloop, (CONST struct loop *l,
				CONST struct loopuse *lup));
BU_EXTERN(void			nmg_vlu, (CONST struct bu_list	*hp,
				CONST long *up));
BU_EXTERN(void			nmg_vfg, (CONST struct face_g_plane *fg));
BU_EXTERN(void			nmg_vface, (CONST struct face *f,
				CONST struct faceuse *fup));
BU_EXTERN(void			nmg_vfu, (CONST struct bu_list	*hp,
				CONST struct shell *s));
BU_EXTERN(void			nmg_vshell, (CONST struct bu_list *hp,
				CONST struct nmgregion *r));
BU_EXTERN(void			nmg_vregion, (CONST struct bu_list *hp,
				CONST struct model *m));
BU_EXTERN(void			nmg_vmodel, (CONST struct model *m));
d4122 44
a4165 44
BU_EXTERN(void			nmg_ck_e, (CONST struct edgeuse *eu,
				CONST struct edge *e, CONST char *str));
BU_EXTERN(void			nmg_ck_vu, (CONST long *parent,
				CONST struct vertexuse *vu,
				CONST char *str));
BU_EXTERN(void			nmg_ck_eu, (CONST long *parent,
				CONST struct edgeuse *eu,
				CONST char *str));
BU_EXTERN(void			nmg_ck_lg, (CONST struct loop *l,
				CONST struct loop_g *lg,
				CONST char *str));
BU_EXTERN(void			nmg_ck_l, (CONST struct loopuse *lu,
				CONST struct loop *l,
				CONST char *str));
BU_EXTERN(void			nmg_ck_lu, (CONST long *parent,
				CONST struct loopuse *lu,
				CONST char *str));
BU_EXTERN(void			nmg_ck_fg, (CONST struct face *f,
				CONST struct face_g_plane *fg,
				CONST char *str));
BU_EXTERN(void			nmg_ck_f, (CONST struct faceuse *fu,
				CONST struct face *f,
				CONST char *str));
BU_EXTERN(void			nmg_ck_fu, (CONST struct shell *s,
				CONST struct faceuse *fu,
				CONST char *str));
BU_EXTERN(int			nmg_ck_eg_verts, (CONST struct edge_g_lseg *eg,
				CONST struct bn_tol *tol));
BU_EXTERN(int			nmg_ck_geometry, (CONST struct model *m,
				CONST struct bn_tol *tol));
BU_EXTERN(int			nmg_ck_face_worthless_edges, (CONST struct faceuse *fu));
BU_EXTERN(void			nmg_ck_lueu, (CONST struct loopuse *lu, CONST char *s) );
BU_EXTERN(int			nmg_check_radial, (CONST struct edgeuse *eu, CONST struct bn_tol *tol));
BU_EXTERN(int			nmg_eu_2s_orient_bad, (CONST struct edgeuse	*eu,
				CONST struct shell	*s1,
				CONST struct shell	*s2,
				CONST struct bn_tol	*tol));
BU_EXTERN(int			nmg_ck_closed_surf, (CONST struct shell *s, CONST struct bn_tol *tol) );
BU_EXTERN(int			nmg_ck_closed_region, (CONST struct nmgregion *r, CONST struct bn_tol *tol) );
BU_EXTERN(void			nmg_ck_v_in_2fus, (CONST struct vertex *vp,
				CONST struct faceuse *fu1, CONST struct faceuse *fu2,
				CONST struct bn_tol *tol));
BU_EXTERN(void			nmg_ck_vs_in_region, (CONST struct nmgregion *r,
				CONST struct bn_tol *tol));
d4172 1
a4172 1
				CONST struct bn_tol *tol));
d4174 1
a4174 1
				CONST struct vertexuse *vu,
d4178 1
a4178 1
				CONST long *assoc_use));
d4187 1
a4187 1
				(CONST struct edge_g_lseg	*eg,
d4189 1
a4189 1
				CONST struct bn_tol	*tol));
d4208 1
a4208 1
				CONST struct vertexuse	*vu,
d4222 2
a4223 2
				CONST struct bu_ptbl		*t1,
				CONST struct bu_ptbl		*t2));
d4225 4
a4228 4
				(CONST long		*magic_p,
				CONST point_t		pt,
				CONST vect_t		dir,
				CONST struct bn_tol	*tol));
d4233 2
a4234 2
				CONST struct edge_g_lseg	*eg1,
				CONST struct edge_g_lseg	*eg2,
d4236 1
a4236 1
				CONST struct bn_tol	*tol));
d4238 1
a4238 1
				(CONST struct edgeuse		*eu,
d4240 2
a4241 2
				CONST struct edge_g_lseg	*eg1,
				CONST struct edge_g_lseg	*eg2,
d4243 1
a4243 1
				CONST struct bn_tol		*tol));
d4247 1
a4247 1
				CONST struct bn_tol	*tol));
d4259 1
a4259 1
				CONST struct bn_tol *tol));
d4268 1
a4268 1
				CONST struct bn_tol *tol));
d4285 4
a4288 4
				(CONST struct edgeuse	*eu,
				CONST point_t		pt,
				CONST vect_t		dir,
				CONST struct bn_tol	*tol));
d4290 3
a4292 3
				(CONST struct faceuse	*ofu1,
				CONST struct faceuse	*fu2,
				CONST struct bn_tol	*tol));
d4294 2
a4295 2
				(CONST struct faceuse	*fu1,
				CONST long		*eg));
d4297 4
a4300 4
				(CONST point_t	pt,
				CONST vect_t	dir,
				CONST plane_t	plane,
				CONST struct bn_tol	*tol));
d4308 1
a4308 1
				CONST struct bn_tol *tol));
d4311 3
a4313 3
				CONST struct faceuse *fu1,
				CONST struct faceuse *fu2,
				CONST struct bn_tol *tol));
d4317 3
a4319 3
				CONST struct bn_tol	*tol));
BU_EXTERN(void			nmg_crackshells, (struct shell *s1, struct shell *s2, CONST struct bn_tol *tol) );
BU_EXTERN(int			nmg_fu_touchingloops, (CONST struct faceuse *fu));
d4323 1
a4323 1
BU_EXTERN(int			nmg_index_of_struct, (CONST long *p) );
d4327 1
a4327 1
				CONST struct nmg_struct_counts *ctr));
d4329 2
a4330 2
				(CONST struct nmg_struct_counts *ctr,
				CONST char *str) );
d4333 1
a4333 1
				CONST struct model *m) );
d4335 2
a4336 2
				(CONST struct model	*m,
				CONST char		*str));
d4339 1
a4339 1
BU_EXTERN(long			nmg_find_max_index, (CONST struct model *m));
d4344 3
a4346 3
BU_EXTERN(void			rt_dspline_matrix, (mat_t m,CONST char *type,
					CONST double	tension,
					CONST double	bias) );
d4349 7
a4355 7
BU_EXTERN(void			rt_dspline4v, (double *pt, CONST mat_t m,
					CONST double *a, CONST double *b,
					CONST double *c, CONST double *d,
					CONST int depth, CONST double alpha) );
BU_EXTERN(void			rt_dspline_n, (double *r, CONST mat_t m,
					CONST double *knots, CONST int n,
					CONST int depth, CONST double alpha));
d4359 3
a4361 3
		CONST struct face_g_snurb *orig_surf, struct resource *res));
BU_EXTERN(int rt_bez_check, (CONST struct face_g_snurb * srf));
BU_EXTERN(int nurb_crv_is_bezier, (CONST struct edge_g_cnurb *crv));
d4365 1
a4365 1
BU_EXTERN(struct face_g_snurb *rt_nurb_scopy, (CONST struct face_g_snurb * srf,
d4367 1
a4367 1
BU_EXTERN(struct edge_g_cnurb *rt_nurb_crv_copy, (CONST struct edge_g_cnurb * crv));
d4370 2
a4371 2
BU_EXTERN(int			nmg_is_common_bigloop, (CONST struct face *f1,
				CONST struct face *f2));
d4373 1
a4373 1
				CONST struct bn_tol *tol));
d4375 1
a4375 1
				CONST struct bn_tol *tol));
d4377 1
a4377 1
				struct bu_ptbl *t2, CONST struct bn_tol	*tol));
d4380 3
a4382 3
				CONST struct bn_tol *tol));
BU_EXTERN(int			nmg_cnurb_is_linear, (CONST struct edge_g_cnurb *cnrb));
BU_EXTERN(int			nmg_snurb_is_planar, (CONST struct face_g_snurb *srf, CONST struct bn_tol *tol));
d4384 2
a4385 2
				(CONST struct face_g_snurb *snrb,
				CONST fastf_t uvw[3], point_t xyz));
d4387 3
a4389 3
				(CONST struct edge_g_cnurb *cnrb,
				CONST struct face_g_snurb *snrb,
				CONST fastf_t t, point_t xyz));
d4392 3
a4394 3
				(CONST struct edge_g_cnurb *cnrb,
				CONST struct face_g_snurb *snrb,
				CONST fastf_t t0, CONST fastf_t t1,
d4396 1
a4396 1
				CONST struct bn_tol *tol));
d4399 4
a4402 4
				(CONST struct edge_g_cnurb *cnrb,
				CONST struct face_g_snurb *snrb,
				CONST fastf_t uvw1[3],
				CONST fastf_t uvw2[3],
d4404 1
a4404 1
				CONST struct bn_tol *tol));
d4406 6
a4411 6
				(CONST struct edgeuse *eu1,
				CONST struct edge_g_cnurb *cnrb,
				CONST struct face_g_snurb *snrb,
				CONST point_t pt1,
				CONST point_t pt2,
				CONST struct bn_tol *tol));
d4413 5
a4417 5
				(CONST struct edgeuse *eu,
				CONST struct edge_g_cnurb *cnrb,
				CONST struct face_g_snurb *snrb,
				CONST struct bu_list *head,
				CONST struct bn_tol *tol));
d4419 1
a4419 1
				(struct model *m, CONST struct bn_tol *tol));
d4422 1
a4422 1
				CONST struct bn_tol	*tol));
d4425 1
a4425 1
				CONST struct bn_tol *tol));
d4427 1
a4427 1
				struct face *f2, CONST struct bn_tol *tol));
d4430 1
a4430 1
				CONST struct bn_tol *tol));
d4432 1
a4432 1
				CONST struct bn_tol *tol));
d4434 1
a4434 1
				struct vertex *v, CONST struct bn_tol *tol));
d4436 1
a4436 1
				CONST struct bn_tol *tol));
d4438 1
a4438 1
				CONST struct bn_tol *tol));
d4444 2
a4445 2
				(CONST struct bu_list *hd,
				CONST struct bn_tol *tol));
d4447 2
a4448 2
				(CONST struct bu_list	*hd,
				CONST struct bn_tol	*tol));
d4457 4
a4460 4
				CONST vect_t		xvec,
				CONST vect_t		yvec,
				CONST vect_t		zvec,
				CONST struct bn_tol	*tol));
d4464 1
a4464 1
				CONST struct bn_tol	*tol));
d4466 8
a4473 8
				(CONST struct edgeuse	*eu,
				CONST struct bn_tol	*tol));
BU_EXTERN(struct nmg_radial	*nmg_find_radial_eu, (CONST struct bu_list *hd,
				CONST struct edgeuse *eu));
BU_EXTERN(CONST struct edgeuse	*nmg_find_next_use_of_2e_in_lu,
				(CONST struct edgeuse	*eu,
				CONST struct edge	*e1,
				CONST struct edge	*e2));
d4476 3
a4478 3
				CONST struct edge	*e1,
				CONST struct edge	*e2,
				CONST struct bn_tol	*tol));
d4480 3
a4482 3
				(CONST struct bu_list	*hd,
				CONST struct shell	*s,
				CONST struct bn_tol	*tol));
d4485 2
a4486 2
				CONST struct shell	*s,
				CONST struct bn_tol	*tol));
d4488 3
a4490 3
				(CONST struct bu_list	*hd,
				CONST struct bu_ptbl	*shells,
				CONST struct bn_tol	*tol));
d4493 1
a4493 1
				CONST struct bn_tol	*tol,
d4496 4
a4499 4
BU_EXTERN(void			nmg_pr_radial, (CONST char *title,
				CONST struct nmg_radial	*rad));
BU_EXTERN(void			nmg_pr_radial_list, (CONST struct bu_list *hd,
				CONST struct bn_tol *tol));
d4504 1
a4504 1
				CONST struct bn_tol *tol));
d4507 1
a4507 1
				CONST struct bn_tol *tol));
d4510 1
a4510 1
				CONST struct bn_tol	*tol));
d4513 1
a4513 1
				CONST struct bn_tol	*tol));
d4515 3
a4517 3
				(CONST struct edgeuse	*eu,
				CONST struct shell	*s,
				CONST struct bn_tol	*tol));
d4520 1
a4520 1
				CONST struct bn_tol	*tol));
d4522 2
a4523 2
				(CONST struct nmgregion	*r,
				CONST struct bn_tol	*tol));
d4527 1
a4527 1
				struct edgeuse *eu2, CONST struct bn_tol *tol));
d4532 1
a4532 1
				CONST struct nmg_visit_handlers	*htab,
d4536 1
a4536 1
				CONST struct nmg_visit_handlers	*htab,
d4540 1
a4540 1
				CONST struct nmg_visit_handlers	*htab,
d4544 1
a4544 1
				CONST struct nmg_visit_handlers	*htab,
d4548 1
a4548 1
				CONST struct nmg_visit_handlers	*htab,
d4552 1
a4552 1
				CONST struct nmg_visit_handlers	*htab,
d4556 1
a4556 1
				CONST struct nmg_visit_handlers	*htab,
d4560 1
a4560 1
				CONST struct nmg_visit_handlers	*htab,
d4564 1
a4564 1
				CONST struct nmg_visit_handlers	*htab,
d4568 1
a4568 1
				CONST struct nmg_visit_handlers	*htab,
d4572 1
a4572 1
				CONST struct nmg_visit_handlers	*htab,
d4575 2
a4576 2
				(CONST long			*magicp,
				CONST struct nmg_visit_handlers	*htab,
d4582 1
a4582 1
				CONST int			major));
d4586 1
a4586 1
				CONST int			major));
d4590 2
a4591 2
				CONST int			major,
				CONST int			minor));
d4595 2
a4596 2
				CONST int			major,
				CONST int			minor));
d4601 1
a4601 1
				CONST char			*tag));
d4606 1
a4606 1
				CONST char			*descrip));
d4609 1
a4609 1
				(CONST int			minor));
d4612 1
a4612 1
				(CONST int			minor));
d4619 1
a4619 1
extern CONST struct db_tree_state	rt_initial_tree_state;
d4623 1
a4623 1
extern CONST char   rt_version[];
@


11.298
log
@Changes to support new DSP primitive representation
@
text
@d45 1
a45 1
 *  $Header: /n/tgm/d/CVS/brlcad/h/raytrace.h,v 11.297 2001/03/23 22:05:18 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /n/tgm/d/CVS/brlcad/h/raytrace.h,v 11.297 2001/03/23 22:05:18 jra Exp $ (BRL)"
d2040 1
a2040 1
 *  $Header: /n/tgm/d/CVS/brlcad/h/raytrace.h,v 11.297 2001/03/23 22:05:18 jra Exp $
d2961 8
d3473 2
d3660 8
@


11.297
log
@Support for major and minor types in directory structure
@
text
@d45 1
a45 1
 *  $Header: /d/CVS/brlcad/h/raytrace.h,v 11.296 2001/03/22 20:15:37 bparker Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /d/CVS/brlcad/h/raytrace.h,v 11.296 2001/03/22 20:15:37 bparker Exp $ (BRL)"
d97 1
a97 1
#define DEBUG_VOL	0x00000800	/* 12 Volume solids */
d2040 1
a2040 1
 *  $Header: /d/CVS/brlcad/h/raytrace.h,v 11.296 2001/03/22 20:15:37 bparker Exp $
@


11.296
log
@*- in "struct db_i" add ptr back to containing rt_wdb
@
text
@d45 1
a45 1
 *  $Header: /d/CVS/brlcad/h/raytrace.h,v 11.295 2001/03/22 19:37:25 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /d/CVS/brlcad/h/raytrace.h,v 11.295 2001/03/22 19:37:25 jra Exp $ (BRL)"
d2040 1
a2040 1
 *  $Header: /d/CVS/brlcad/h/raytrace.h,v 11.295 2001/03/22 19:37:25 jra Exp $
d2449 2
a2450 1
	int flags );
@


11.295
log
@Added hidden flag for database objects
@
text
@d45 1
a45 1
 *  $Header: /d/CVS/brlcad/h/raytrace.h,v 11.294 2001/03/21 19:02:00 pjt Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /d/CVS/brlcad/h/raytrace.h,v 11.294 2001/03/21 19:02:00 pjt Exp $ (BRL)"
d777 1
d2040 1
a2040 1
 *  $Header: /d/CVS/brlcad/h/raytrace.h,v 11.294 2001/03/21 19:02:00 pjt Exp $
@


11.294
log
@struct rt_db_internal now has both idb_minor_type idb_major_type
@
text
@d45 1
a45 1
 *  $Header: /d/CVS/brlcad/h/raytrace.h,v 11.293 2001/03/20 21:56:01 pjt Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /d/CVS/brlcad/h/raytrace.h,v 11.293 2001/03/20 21:56:01 pjt Exp $ (BRL)"
d824 2
d839 1
d2039 1
a2039 1
 *  $Header: /d/CVS/brlcad/h/raytrace.h,v 11.293 2001/03/20 21:56:01 pjt Exp $
d2536 1
@


11.293
log
@Changed a whole lot of unsigned chars (i.e. major and minor types)
to ints
@
text
@d45 1
a45 1
 *  $Header: /d/CVS/brlcad/h/raytrace.h,v 11.292 2001/03/20 16:09:05 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /d/CVS/brlcad/h/raytrace.h,v 11.292 2001/03/20 16:09:05 jra Exp $ (BRL)"
d216 2
a217 1
	int		idb_type;		/* ID_xxx */
d222 1
d2036 1
a2036 1
 *  $Header: /d/CVS/brlcad/h/raytrace.h,v 11.292 2001/03/20 16:09:05 jra Exp $
@


11.292
log
@ft_import5() and ft_export5() now have a const int minor_type argument
@
text
@d45 1
a45 1
 *  $Header: /d/CVS/brlcad/h/raytrace.h,v 11.291 2001/03/19 22:19:25 butler Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /d/CVS/brlcad/h/raytrace.h,v 11.291 2001/03/19 22:19:25 butler Exp $ (BRL)"
d917 1
a917 1
	char		type;
d2034 1
a2034 1
 *  $Header: /d/CVS/brlcad/h/raytrace.h,v 11.291 2001/03/19 22:19:25 butler Exp $
d2542 2
a2543 1
				struct resource *resp);
d2551 1
a2551 1
				struct resource		*resp);
d2555 2
a2556 1
				struct resource		*resp);
d4556 1
a4556 1
				CONST unsigned char		major));
d4560 1
a4560 1
				CONST unsigned char		major));
d4564 2
a4565 2
				CONST unsigned char		major,
				CONST unsigned char		minor));
d4569 2
a4570 2
				CONST unsigned char		major,
				CONST unsigned char		minor));
d4573 2
a4574 2
				(unsigned char			*major,
				unsigned char			*minor,
d4578 2
a4579 2
				(unsigned char			*major,
				unsigned char			*minor,
d4583 1
a4583 1
				(CONST unsigned char		minor));
d4586 1
a4586 1
				(CONST unsigned char		minor));
@


11.291
log
@patches to merge 5.3 into 6.0
@
text
@d45 1
a45 1
 *  $Header: /d/CVS/brlcad/h/raytrace.h,v 11.290 2001/03/16 14:42:44 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /d/CVS/brlcad/h/raytrace.h,v 11.290 2001/03/16 14:42:44 jra Exp $ (BRL)"
d1898 2
a1899 1
			struct resource * /*resp*/));
d1904 2
a1905 1
			struct resource * /*resp*/));
d2034 1
a2034 1
 *  $Header: /d/CVS/brlcad/h/raytrace.h,v 11.290 2001/03/16 14:42:44 jra Exp $
d2724 2
a2725 1
        struct resource         *resp );
@


11.290
log
@The "wdb_prestr" field of "struct rt_wdb" is now a vls (for long names)
Added declaration for db5_scan().
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.289 2001/03/09 15:08:35 bparker Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.289 2001/03/09 15:08:35 bparker Exp $ (BRL)"
d652 1
d1154 11
d1183 1
d1541 1
d2032 1
a2032 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.289 2001/03/09 15:08:35 bparker Exp $
@


11.289
log
@*- add new members to struct view_obj -
       vo_coord, vo_keypoint, vo_rotate_about
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.288 2001/01/29 18:18:08 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.288 2001/01/29 18:18:08 jra Exp $ (BRL)"
d1112 1
a1112 1
	char		wdb_prestr[RT_NAMESIZE];
d2018 1
a2018 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.288 2001/01/29 18:18:08 jra Exp $
d2699 3
@


11.288
log
@Added some declarations for new functions
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.287 2000/11/19 16:28:30 butler Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.287 2000/11/19 16:28:30 butler Exp $ (BRL)"
d1191 3
d2018 1
a2018 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.287 2000/11/19 16:28:30 butler Exp $
@


11.287
log
@Removed some unnecessary symbols relating to partition structures.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.286 2000/11/14 21:13:49 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.286 2000/11/14 21:13:49 jra Exp $ (BRL)"
d2015 1
a2015 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.286 2000/11/14 21:13:49 jra Exp $
d2509 9
d2693 11
a2703 1
int db_dirbuild( struct db_i *dbip );
@


11.286
log
@Eliminated pmalloc (a failed experiment)
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.285 2000/11/01 20:37:34 mike Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.285 2000/11/01 20:37:34 mike Exp $ (BRL)"
d601 3
a603 5
#define RT_PT_NULL	((struct partition *)0)
#define RT_PT_MAGIC	0x87687681
#define PT_NULL		RT_PT_NULL
#define PT_MAGIC	RT_PT_MAGIC
#define PT_HD_MAGIC	BU_LIST_HEAD_MAGIC	/* was 0x87687680 */
d654 1
a654 1
		BU_LIST_INIT((struct bu_list *)(_headp)); \
d2015 1
a2015 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.285 2000/11/01 20:37:34 mike Exp $
@


11.285
log
@
db_create got version argument
@
text
@a1260 17
 *			R T _ Q E L E M
 *
 *	Structure for use by pmalloc()
 */
#define RT_PM_NBUCKETS        18

struct rt_qelem {
        struct rt_qelem *q_forw;
        struct rt_qelem *q_back;
};

struct rt_pm_res {
	struct rt_qelem buckets[RT_PM_NBUCKETS];
	struct rt_qelem adjhead;
};

/*
a1361 1
	struct rt_pm_res re_pmem;	/* for use by pmalloc() */
a3019 5

/* pmalloc.c */
BU_EXTERN(char *rt_pmalloc, (long nbytes, struct rt_pm_res *pmem));
BU_EXTERN(void rt_pfree, (char *mem, struct rt_pm_res *pmem));
BU_EXTERN(char *rt_prealloc, (char *mem, unsigned nbytes, struct rt_pm_res *pmem));
@


11.284
log
@
Needed seghead paramater to ft_piece_shot() to properly handle
PLATE-mode intersections, where one hit yeilds two hits
and a complete segment, all at once.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.283 2000/10/30 21:23:25 mike Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.283 2000/10/30 21:23:25 mike Exp $ (BRL)"
d2035 1
a2035 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.283 2000/10/30 21:23:25 mike Exp $
d2512 1
a2512 1
BU_EXTERN(struct db_i *db_create, ( CONST char *name ) );
@


11.283
log
@
Changed PT_HD_MAGIC to be BU_LIST_HEAD_MAGIC, so that bu_list
list validators will work on partition lists.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.282 2000/10/24 18:51:34 mike Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.282 2000/10/24 18:51:34 mike Exp $ (BRL)"
d1844 2
a1845 1
			struct application * /*ap*/));	/* has resource */
d2035 1
a2035 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.282 2000/10/24 18:51:34 mike Exp $
@


11.282
log
@
rt_bot_internal shuffle
@
text
@d601 5
a605 3
#define PT_NULL		((struct partition *)0)
#define PT_MAGIC	0x87687681
#define PT_HD_MAGIC	0x87687680
d656 1
a656 1
		(_headp)->pt_forw = (_headp)->pt_back = (_headp); \
@


11.281
log
@
Bot needs rtgeom.h too
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.280 2000/10/24 18:42:32 mike Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.280 2000/10/24 18:42:32 mike Exp $ (BRL)"
d2032 1
a2032 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.280 2000/10/24 18:42:32 mike Exp $
a3618 1
int rt_bot_find_v_nearest_pt2();	/* needs rt_bot_internal for arg list */
d3620 11
a3632 1
int rt_bot_same_orientation( const int *a, const int *b );
d3635 2
@


11.280
log
@
Added rt_arb_get_cgtype() to raytrace.h
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.279 2000/10/24 18:38:41 mike Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.279 2000/10/24 18:38:41 mike Exp $ (BRL)"
d2032 1
a2032 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.279 2000/10/24 18:38:41 mike Exp $
a3598 1

d3608 1
a3616 1
struct rt_bot_internal		*nmg_bot( struct shell *s, const struct bn_tol *tol );
@


11.279
log
@
Added rt_partition_len() to raytrace.h
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.278 2000/10/24 18:29:35 mike Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.278 2000/10/24 18:29:35 mike Exp $ (BRL)"
d2032 1
a2032 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.278 2000/10/24 18:29:35 mike Exp $
d2879 1
@


11.278
log
@
Added rt_pipept_print to raytrace.h
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.277 2000/10/24 18:22:37 mike Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.277 2000/10/24 18:22:37 mike Exp $ (BRL)"
d2032 1
a2032 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.277 2000/10/24 18:22:37 mike Exp $
d2395 1
@


11.277
log
@
Added pipe routine to raytrace.h
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.276 2000/10/24 18:17:43 mike Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.276 2000/10/24 18:17:43 mike Exp $ (BRL)"
d2032 1
a2032 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.276 2000/10/24 18:17:43 mike Exp $
d2897 1
@


11.276
log
@
More BoT function definitions
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.275 2000/10/24 18:11:08 mike Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.275 2000/10/24 18:11:08 mike Exp $ (BRL)"
d2032 1
a2032 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.275 2000/10/24 18:11:08 mike Exp $
d2892 5
@


11.275
log
@
Added extern from table.c to raytrace.h
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.274 2000/10/24 18:09:36 mike Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.274 2000/10/24 18:09:36 mike Exp $ (BRL)"
d2032 1
a2032 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.274 2000/10/24 18:09:36 mike Exp $
d2879 1
d3612 3
@


11.274
log
@
Added externs from g_arb.c to raytrace.h
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.273 2000/10/24 14:36:28 mike Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.273 2000/10/24 14:36:28 mike Exp $ (BRL)"
d2032 1
a2032 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.273 2000/10/24 14:36:28 mike Exp $
d2952 7
@


11.273
log
@
Added rt_bot_ prefix to all the BoT support routines,
and registered them in raytrace.h
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.272 2000/10/20 20:28:43 jra Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.272 2000/10/20 20:28:43 jra Exp $ (BRL)"
d2032 1
a2032 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.272 2000/10/20 20:28:43 jra Exp $
d2878 1
@


11.272
log
@Added resource structure to db_functree() args and to the rt_wdb structure
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.271 2000/10/20 05:08:32 mike Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.271 2000/10/20 05:08:32 mike Exp $ (BRL)"
d2032 1
a2032 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.271 2000/10/20 05:08:32 mike Exp $
d3603 4
a3606 2
extern int bot_vertex_fuse( struct rt_bot_internal *bot );
extern int bot_condense( struct rt_bot_internal *bot );
@


11.271
log
@
Moved DIR_USED from mged/rtif.c to h/raytrace.h
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.270 2000/10/19 21:27:18 mike Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.270 2000/10/19 21:27:18 mike Exp $ (BRL)"
d1109 1
d2032 1
a2032 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.270 2000/10/19 21:27:18 mike Exp $
d2874 1
@


11.270
log
@
Added DB_FULL_PATH_GET()
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.269 2000/10/19 04:31:04 mike Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.269 2000/10/19 04:31:04 mike Exp $ (BRL)"
d834 1
d2031 1
a2031 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.269 2000/10/19 04:31:04 mike Exp $
@


11.269
log
@
Added declarations for lots of new db_full_path routines in db_path.c
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.268 2000/09/09 04:37:55 mike Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.268 2000/09/09 04:37:55 mike Exp $ (BRL)"
d240 1
d2030 1
a2030 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.268 2000/09/09 04:37:55 mike Exp $
@


11.268
log
@
Fixed extern.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.267 2000/09/09 04:30:44 mike Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.267 2000/09/09 04:30:44 mike Exp $ (BRL)"
d859 2
d866 6
d2029 1
a2029 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.267 2000/09/09 04:30:44 mike Exp $
a2471 24
extern int db_argv_to_path(register struct db_full_path	*pp,
			   struct db_i			*dbip,
			   int				argc,
			   CONST char			*CONST*argv);

BU_EXTERN(void db_add_node_to_full_path, (struct db_full_path *pp,
	struct directory *dp) );
BU_EXTERN(void db_dup_full_path, (struct db_full_path *newp,
	CONST struct db_full_path *oldp) );
BU_EXTERN(char *db_path_to_string, (CONST struct db_full_path *pp) );
BU_EXTERN(void db_free_full_path, (struct db_full_path *pp) );
int db_region_mat(
	mat_t		m,		/* result */
	struct db_i	*dbip,
	const char	*name,
	struct resource *resp);
int db_shader_mat(
	mat_t			model_to_shader,	/* result */
	const struct rt_i	*rtip,
	const struct region	*rp,
	point_t			p_min,	/* input/output: shader/region min point */
	point_t			p_max,	/* input/output: shader/region max point */
	struct resource		*resp);
int db_string_to_path(struct db_full_path *pp, const struct db_i *dbip, const char *str);
d2473 4
d2478 1
a2478 1
extern void db_dup_path_tail(struct db_full_path	*newp,
d2481 16
d2828 12
@


11.267
log
@
Struct db_tree_state finally got a magic number. Added resource argument
to ft_describe(), db_region_mat(), db_shader_mat(),
db_init_db_tree_state(), and db_path_to_mat().
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.266 2000/09/08 05:54:37 mike Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.266 2000/09/08 05:54:37 mike Exp $ (BRL)"
d2021 1
a2021 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.266 2000/09/08 05:54:37 mike Exp $
d2576 1
a2576 1
	const matp_t			matrix,		/* NULL if identity */
@


11.266
log
@
Modified tree routines to take resource pointer.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.265 2000/09/07 01:55:30 mike Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.265 2000/09/07 01:55:30 mike Exp $ (BRL)"
d934 1
d944 1
d981 3
d1908 2
a1909 1
			double /*mm2local*/));
d2021 1
a2021 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.265 2000/09/07 01:55:30 mike Exp $
d2475 12
a2486 5
BU_EXTERN(int db_region_mat, (mat_t m, CONST struct db_i *dbip,
				CONST char *name) );
BU_EXTERN(int db_shader_mat, (mat_t model_to_shader, CONST struct rt_i *rtip,
				CONST struct region *rp, point_t p_min,
				point_t p_max) );
d2739 1
a2739 1
void db_init_db_tree_state( struct db_tree_state *tsp, struct db_i *dbip );
d2814 6
a2819 2
BU_EXTERN(int db_path_to_mat, (struct db_i *dbip, struct db_full_path *pathp,
	mat_t mat, int depth));
a2822 1
int db_region_mat( mat_t m, const struct db_i *dbip, const char *name );
@


11.265
log
@
Moved 2 routines from mged/edarb.c to librt/g_arb.c
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.264 2000/09/01 02:53:02 mike Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.264 2000/09/01 02:53:02 mike Exp $ (BRL)"
d784 22
d821 1
d844 21
d973 1
d1011 1
d1324 2
d1332 2
a1333 1
 *  structure, making initial application development simpler.
d1335 2
a1336 2
 *  Applications are responsible for filling the resource structure
 *  with zeros before letting librt use them.
d1376 1
a1376 1
	/* Experimental stuff for accelerating "pieces" of solids */
d1383 7
d1397 19
d1652 1
a1652 2
	/* Experimental stuff for rt_submodel */
/*	struct soltab	*rti_up;	/_* 'up' ptr for rt_submodel rti's only */
d1655 1
a1655 1
	/* Experimental stuff for accelerating "pieces" of solids */
d1815 1
a1815 1
			struct application * /*ap*/,
d1826 1
a1826 1
			struct application * /*ap*/));
d1830 2
a1831 2
			struct application * /*ap*/));
	void	(*ft_uv) BU_ARGS((struct application * /*ap*/,
d1881 2
a1882 1
			CONST struct db_i * /*dbip*/));
d1886 2
a1887 1
			CONST struct db_i * /*dbip*/));
d1891 2
a1892 1
			CONST struct db_i * /*dbip*/));
d1896 4
a1899 2
			CONST struct db_i * /*dbip*/));
	void	(*ft_ifree) BU_ARGS((struct rt_db_internal * /*ip*/));
d1906 2
a1907 1
			int /*free*/, struct db_i * /*dbip*/));
d1916 2
a1917 1
			int /*argc*/, char ** /*argv*/));
d1925 2
a1926 1
			int /*argc*/, char ** /*argv*/));
d2015 1
a2015 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.264 2000/09/01 02:53:02 mike Exp $
d2314 5
a2318 1
BU_EXTERN(int rt_plot_solid, (FILE *fp, struct rt_i *rtip, struct soltab *stp) );
d2321 1
a2321 1
BU_EXTERN(int rt_del_regtree, (struct rt_i *rtip, struct region *delregp));
d2509 2
a2510 1
				  struct db_i *dbip);
d2517 2
a2518 1
			       const mat_t		mat);
d2521 2
a2522 1
			       struct rt_db_internal	*ip);
d2545 1
a2545 1
BU_EXTERN(int rt_fwrite_internal5, (FILE *, CONST char *, struct rt_db_internal *, double));
d2558 2
a2559 1
	int			free);
d2564 2
a2565 1
	const struct db_i		*dbip);
d2570 2
a2571 1
	const struct db_i		*dbip);
d2577 2
a2578 1
	double			mm2local);
d2589 3
a2591 2
	double		mm2local);
void rt_comb_ifree( struct rt_db_internal *ip );
d2596 2
a2597 1
	double		mm2local);
d2605 2
a2606 1
	int		howfar);
d2610 1
a2610 1
	struct db_tree_state	*tsp);
d2684 1
d2706 1
a2706 1
extern void db_update_nref( struct db_i    *dbip);
d2745 3
a2747 3
void db_tree_del_lhs( union tree *tp );
void db_tree_del_rhs( union tree *tp );
int db_tree_del_dbleaf(union tree **tp, const char *cp);
d2769 1
a2769 1
BU_EXTERN(union tree *db_dup_subtree, (CONST union tree	*tp));
d2771 1
a2771 1
BU_EXTERN(void db_free_tree, (union tree *tp));
d2773 1
a2773 1
BU_EXTERN(void db_non_union_push, (union tree *tp));
d2776 7
a2782 3
BU_EXTERN(int db_count_subtree_regions, (CONST union tree *tp));
BU_EXTERN(int db_tally_subtree_regions, (union tree *tp,
	union tree **reg_trees, int cur, int lim));
d2811 11
a2821 5
BU_EXTERN(int rt_db_get_internal, (struct rt_db_internal *ip,
	CONST struct directory *dp,
	CONST struct db_i *dbip, CONST mat_t mat));
BU_EXTERN(int rt_db_put_internal, (struct directory *dp, struct db_i *dbip,
	struct rt_db_internal *ip));
d2823 8
a2830 4
extern void rt_db_free_internal( struct rt_db_internal *ip );
extern int rt_db_lookup_internal( struct db_i *dbip, const char *obj_name,
	struct directory **dpp, struct rt_db_internal *ip, int noisy );

d2833 1
d2879 1
a2879 1
int rt_pg_to_bot( struct rt_db_internal *ip, const struct bn_tol *tol );
d2882 1
a2882 1
int rt_hf_to_dsp(struct rt_db_internal *db_intern);
d2919 9
a2927 2
BU_EXTERN(void rt_plot_all_solids, (FILE *fp, struct rt_i *rtip));
BU_EXTERN(void rt_init_resource, (struct resource *resp, int cpu_num));
d2946 1
d3853 2
a3854 2
				CONST struct bn_tol *tol));
int nmg_boolean( union tree *tp, struct model *m, const struct bn_tol *tol );
@


11.264
log
@
Added cmd.c externs
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.263 2000/08/29 22:08:28 mike Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.263 2000/08/29 22:08:28 mike Exp $ (BRL)"
d1933 1
a1933 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.263 2000/08/29 22:08:28 mike Exp $
d2728 8
@


11.263
log
@
Improved comments for ft_piece_shot() arguments.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.262 2000/08/29 21:54:28 mike Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.262 2000/08/29 21:54:28 mike Exp $ (BRL)"
d1933 1
a1933 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.262 2000/08/29 21:54:28 mike Exp $
a2224 4

BU_EXTERN(char *rt_read_cmd, (FILE *fp) );	/* Read semi-colon terminated line */
					/* do cmd from string via cmd table */
BU_EXTERN(int rt_do_cmd, (struct rt_i *rtip, char *lp, struct command_tab *ctp) );
d2316 6
@


11.262
log
@
Provide rt_piecestate cutp variable.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.261 2000/08/29 21:50:26 mike Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.261 2000/08/29 21:50:26 mike Exp $ (BRL)"
d1750 2
a1751 2
			double /* dist_corr */,
			struct xray * /*rp*/,
d1933 1
a1933 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.261 2000/08/29 21:50:26 mike Exp $
@


11.261
log
@
Added cutp to rt_piecestate
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.260 2000/08/29 04:03:10 mike Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.260 2000/08/29 04:03:10 mike Exp $ (BRL)"
d1246 1
a1246 1
	union cutter	*cutp;		/* current bounding volume */
d1933 1
a1933 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.260 2000/08/29 04:03:10 mike Exp $
@


11.260
log
@
externs
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.259 2000/08/29 03:58:08 mike Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.259 2000/08/29 03:58:08 mike Exp $ (BRL)"
d1246 1
d1933 1
a1933 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.259 2000/08/29 03:58:08 mike Exp $
@


11.259
log
@
externs for librt/tcl.c
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.258 2000/08/29 03:23:03 cjohnson Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.258 2000/08/29 03:23:03 cjohnson Exp $ (BRL)"
d1932 1
a1932 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.258 2000/08/29 03:23:03 cjohnson Exp $
d3723 1
a3723 2
BU_EXTERN(void			nmg_region_v_unique, (struct nmgregion *r1,
				CONST struct bn_tol *tol));
@


11.258
log
@Increase the size of the db_lookup Hash Table.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.257 2000/08/24 03:13:36 mike Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.257 2000/08/24 03:13:36 mike Exp $ (BRL)"
d1932 1
a1932 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.257 2000/08/24 03:13:36 mike Exp $
d3463 7
@


11.257
log
@
Did the array twice
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.256 2000/08/24 03:12:18 mike Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.256 2000/08/24 03:12:18 mike Exp $ (BRL)"
d733 1
a733 1
#define	RT_DBNHASH		128	/* size of hash table */
d1932 1
a1932 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.256 2000/08/24 03:12:18 mike Exp $
@


11.256
log
@
librt/vlist.c externs
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.255 2000/08/24 01:50:07 mike Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.255 2000/08/24 01:50:07 mike Exp $ (BRL)"
d1932 1
a1932 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.255 2000/08/24 01:50:07 mike Exp $
a2827 1
const char *rt_vlist_cmd_descriptions[];
d4367 1
a4367 1
extern CONST char   *rt_vlist_cmd_descriptions[];
@


11.255
log
@
externs for db_comb.c
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.254 2000/08/23 05:56:28 mike Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.254 2000/08/23 05:56:28 mike Exp $ (BRL)"
d1932 1
a1932 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.254 2000/08/23 05:56:28 mike Exp $
d2819 5
d2828 4
d2833 1
d2844 3
a2851 3
BU_EXTERN(int			rt_process_uplot_value,
				(struct bu_list **vhead, struct bn_vlblock *vbp,
				FILE *fp, int c, double char_size) );
@


11.254
log
@
Added const
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.253 2000/08/22 06:48:46 mike Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.253 2000/08/22 06:48:46 mike Exp $ (BRL)"
d1932 1
a1932 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.253 2000/08/22 06:48:46 mike Exp $
d2461 51
a2511 8

struct rt_tree_array *db_flatten_tree(struct rt_tree_array	*rt_tree_array,
				      union tree		*tp,
				      int			op,
				      int			free);
extern int db_tree_nleaves( const union tree *tp );
extern void db_wrap_v4_external( struct bu_external *op, const char *name );
extern int db_ck_v4gift_tree( const union tree	*tp);
@


11.253
log
@
db_flatten_tree() got an additional argument, to prevent memory leaks.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.252 2000/08/21 02:06:59 butler Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.252 2000/08/21 02:06:59 butler Exp $ (BRL)"
d1932 1
a1932 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.252 2000/08/21 02:06:59 butler Exp $
d2059 1
a2059 1
	struct bn_tol		*tol;
@


11.252
log
@Massive amounts of compiler warnings eliminated on Linux
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.251 2000/08/19 22:01:15 butler Exp $
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.251 2000/08/19 22:01:15 butler Exp $ (BRL)"
d1932 1
a1932 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.251 2000/08/19 22:01:15 butler Exp $
d2464 2
a2465 6
				      int			op);

extern struct rt_tree_array * db_flatten_tree(
		      struct rt_tree_array	*rt_tree_array,
		      union tree		*tp,
		      int			op);
@


11.251
log
@Misc Compilation fixes
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.250 2000/07/29 23:23:04 mike Exp $
d57 2
d68 1
a68 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.250 2000/07/29 23:23:04 mike Exp $ (BRL)"
d1932 1
a1932 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.250 2000/07/29 23:23:04 mike Exp $
d2298 1
d2306 3
d2369 5
d2388 4
d2394 2
d2406 8
d2416 37
d2456 32
d2489 9
d2510 1
a2510 1
BU_EXTERN(int db_put, ( CONST struct db_i *, CONST struct directory *dp, union record *where,
d2545 8
d2567 2
d2573 2
a2679 1
/* db_comb.c */
d2766 7
d2811 15
d2865 1
d3203 7
d3387 4
d3392 3
d3409 37
d3448 12
d3469 7
d3486 5
d3620 14
d3635 4
d3771 9
@


11.250
log
@
Removed old v4 db_grow() and db_trunc() internal interfaces.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.249 2000/07/25 22:40:48 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.249 2000/07/25 22:40:48 mike Exp $ (BRL)"
d1930 1
a1930 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.249 2000/07/25 22:40:48 mike Exp $
d2288 6
@


11.249
log
@
libwdb additions for writing NMGs at BoTs.
Initial support for writing region-id-based-color table.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.248 2000/07/25 16:38:31 butler Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.248 2000/07/25 16:38:31 butler Exp $ (BRL)"
d1930 1
a1930 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.248 2000/07/25 16:38:31 butler Exp $
a2455 4
					/* grow by "count" granules */
BU_EXTERN(int db_grow, ( struct db_i *, struct directory *dp, int count ) );
					/* truncate by "count" */
BU_EXTERN(int db_trunc, ( struct db_i *, struct directory *dp, int count ) );
@


11.248
log
@Added rtprivate.h for rt internal debug info an externs
Extra externs in bn.h and raytrace.h
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.247 2000/07/24 22:22:10 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.247 2000/07/24 22:22:10 mike Exp $ (BRL)"
d1930 1
a1930 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.247 2000/07/24 22:22:10 mike Exp $
d3239 1
@


11.247
log
@
More new-libwdb-related cleanups
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.246 2000/07/24 19:27:30 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.246 2000/07/24 19:27:30 mike Exp $ (BRL)"
d1930 1
a1930 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.246 2000/07/24 19:27:30 mike Exp $
d2337 10
d2650 5
d3064 7
@


11.246
log
@
Changed mged/typin.c to start using libwdb interfaces.
Which means mged/ged.c now also opens a libwdb interface.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.245 2000/07/13 02:35:32 cjohnson Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.245 2000/07/13 02:35:32 cjohnson Exp $ (BRL)"
d1930 1
a1930 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.245 2000/07/13 02:35:32 cjohnson Exp $
d2565 2
a2566 1
/* g_pipe.c:  rt_pipe_ck() is declared in h/wdb.h because of arg type */
@


11.245
log
@LINT from gcc -Wall
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.244 2000/07/13 01:13:00 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.244 2000/07/13 01:13:00 mike Exp $ (BRL)"
d1930 1
a1930 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.244 2000/07/13 01:13:00 mike Exp $
d2564 2
@


11.244
log
@
Changed db_ident() to db_update_ident().
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.243 2000/07/12 21:55:23 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.243 2000/07/12 21:55:23 mike Exp $ (BRL)"
d1930 1
a1930 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.243 2000/07/12 21:55:23 mike Exp $
d2306 1
d2551 2
d2635 2
@


11.243
log
@
Improved wdb interface
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.242 2000/07/12 02:11:27 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.242 2000/07/12 02:11:27 mike Exp $ (BRL)"
d1930 1
a1930 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.242 2000/07/12 02:11:27 mike Exp $
d2415 3
d2419 1
@


11.242
log
@
Added wdb_version and multi-version support.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.241 2000/07/12 00:37:20 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.241 2000/07/12 00:37:20 mike Exp $ (BRL)"
d814 7
a1040 1
	FILE		*fp;
a1045 1
	int		wdb_version;	/* 4 or 5 */
a1065 1
#define RT_WDB_TYPE_FILE			1
d1930 1
a1930 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.241 2000/07/12 00:37:20 mike Exp $
d2310 24
a2333 2
BU_EXTERN(struct rt_wdb *wdb_dbopen, (struct db_i *dbip, int mode));
BU_EXTERN(struct rt_wdb *wdb_fopen, (CONST char *filename));
d2417 3
d2579 6
@


11.241
log
@
Changed template of rt_color_addrec()
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.240 2000/07/12 00:13:45 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.240 2000/07/12 00:13:45 mike Exp $ (BRL)"
d1040 1
d1926 1
a1926 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.240 2000/07/12 00:13:45 mike Exp $
@


11.240
log
@
Added externs for db_tree.c and db_path.c
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.239 2000/07/12 00:07:52 cjohnson Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.239 2000/07/12 00:07:52 cjohnson Exp $ (BRL)"
d1925 1
a1925 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.239 2000/07/12 00:07:52 cjohnson Exp $
d2283 2
d2287 1
a2287 1
BU_EXTERN(void rt_color_addrec, () );
d2290 2
@


11.239
log
@Add some external functions that libwdb references.  Part of -Wall LINT.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.238 2000/07/11 23:16:44 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.238 2000/07/11 23:16:44 mike Exp $ (BRL)"
d1925 1
a1925 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.238 2000/07/11 23:16:44 mike Exp $
d2326 1
a2326 1
int db_string_to_path(struct db_full_path *pp, struct db_i *dbip, CONST char *str);
d2419 3
d2435 24
d2465 1
d2467 1
d2469 2
d2497 2
a2498 3
BU_EXTERN(union tree		*db_find_named_leaf, (union tree *tp,
				CONST char *cp));
int db_tree_del_dbleaf(union tree **tp, const char *cp);
@


11.238
log
@
Added externs for new routines in librt/db_*.c
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.237 2000/07/07 17:52:44 bparker Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.237 2000/07/07 17:52:44 bparker Exp $ (BRL)"
d1925 1
a1925 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.237 2000/07/07 17:52:44 bparker Exp $
d2342 4
d2395 2
d2398 1
a2398 1
BU_EXTERN(void db_pr_dir, ( CONST struct db_i *dbip ) );
@


11.237
log
@Declare rt_memalloc_nosplit.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.236 2000/06/30 20:15:53 pjt Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.236 2000/06/30 20:15:53 pjt Exp $ (BRL)"
d1925 1
a1925 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.236 2000/06/30 20:15:53 pjt Exp $
d2310 3
d2326 4
d2460 3
@


11.236
log
@Added db5_type_sizeof_h_binu and db5_type_sizeof_n_binu
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.235 2000/06/30 15:29:05 pjt Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.235 2000/06/30 15:29:05 pjt Exp $ (BRL)"
d1925 1
a1925 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.235 2000/06/30 15:29:05 pjt Exp $
d2484 1
@


11.235
log
@1. Changed ID_MAXIMUM to ID_MAX_SOLID
2. Added stuff for bulk binary objects
3. Added prototypes from db5_types.c
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.234 2000/06/29 15:56:29 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.234 2000/06/29 15:56:29 mike Exp $ (BRL)"
d1925 1
a1925 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.234 2000/06/29 15:56:29 mike Exp $
d3943 6
@


11.234
log
@
added idb_avs
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.233 2000/06/28 18:08:04 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.233 2000/06/28 18:08:04 mike Exp $ (BRL)"
d520 1
a520 1
#define ID_COMBINATION	31	/* Combination Record (non-geometric) */
d522 8
a529 1
#define ID_MAXIMUM	31	/* Maximum defined ID_xxx value */
d846 29
d1556 2
a1557 2
	struct soltab	**rti_sol_by_type[ID_MAXIMUM+1];
	int		rti_nsol_by_type[ID_MAXIMUM+1];
d1925 1
a1925 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.233 2000/06/28 18:08:04 mike Exp $
d3914 29
@


11.233
log
@
Defined ID_COMBINATION as an actual number
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.232 2000/06/28 18:03:39 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.232 2000/06/28 18:03:39 mike Exp $ (BRL)"
d217 1
d221 2
a222 1
	(_p)->idb_type = -1; (_p)->idb_ptr = GENPTR_NULL;}
d1889 1
a1889 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.232 2000/06/28 18:03:39 mike Exp $
@


11.232
log
@
Added externs from dir.c to raytrace.h
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.231 2000/06/27 17:36:08 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.231 2000/06/27 17:36:08 mike Exp $ (BRL)"
d518 1
a518 1
#define ID_MAXIMUM	30	/* Maximum defined ID_xxx value */
d520 1
a520 1
#define ID_COMBINATION	(ID_MAXIMUM+1)	/* Combination Record (non-geometric) */
d1887 1
a1887 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.231 2000/06/27 17:36:08 mike Exp $
@


11.231
log
@
Modified calling sequence to leaf node callback for db_recurse()
and db_walk_tree().
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.230 2000/06/26 17:46:41 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.230 2000/06/26 17:46:41 mike Exp $ (BRL)"
d1887 1
a1887 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.230 2000/06/26 17:46:41 mike Exp $
d2417 1
d2423 4
@


11.230
log
@
Added import5 and export5 methods to the function table.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.229 2000/06/23 03:31:54 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.229 2000/06/23 03:31:54 mike Exp $ (BRL)"
d871 1
a871 2
				struct bu_external * /*ep*/,
				int /*id*/,
d1887 1
a1887 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.229 2000/06/23 03:31:54 mike Exp $
d2407 1
a2407 2
		struct bu_external * /*ep*/,
		int /*id*/,
d3265 1
a3265 1
				struct bu_external *ep, int id, genptr_t client_data));
d3268 1
a3268 1
				struct bu_external *ep, int id, genptr_t client_data));
@


11.229
log
@
Added extra field to indicate database version.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.228 2000/05/24 00:58:42 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.228 2000/05/24 00:58:42 mike Exp $ (BRL)"
d1759 8
d1888 1
a1888 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.228 2000/05/24 00:58:42 mike Exp $
@


11.229.2.1
log
@Fixed RT_FREE_PT_LIST to dequeue elements before adding them to the free list
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.229 2000/06/23 03:31:54 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.229 2000/06/23 03:31:54 mike Exp $ (BRL)"
a639 1
			BU_LIST_DEQUEUE( (struct bu_list *)(_zap) ); \
d1880 1
a1880 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.229 2000/06/23 03:31:54 mike Exp $
@


11.229.2.2
log
@Mike's changes to handle plate mode BOTS in renderings
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.229.2.1 2000/10/26 14:41:33 butler Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.229.2.1 2000/10/26 14:41:33 butler Exp $ (BRL)"
d1708 1
a1708 2
			struct application * /*ap*/,	/* has resource */
			struct seg * /*seghead*/));	/* used only for PLATE mode hits */
d1881 1
a1881 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.229.2.1 2000/10/26 14:41:33 butler Exp $
@


11.229.2.3
log
@Eliminated pmalloc (a failed experiment)
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.229.2.2 2000/11/01 18:43:34 jra Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.229.2.2 2000/11/01 18:43:34 jra Exp $ (BRL)"
d1154 17
d1268 1
d1882 1
a1882 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.229.2.2 2000/11/01 18:43:34 jra Exp $
d2519 5
@


11.229.2.4
log
@Added field "a_flag" to the application structure. First use is indicating
purpose in refraction and examined in colorview()
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.229.2.3 2000/11/14 21:35:59 jra Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.229.2.3 2000/11/14 21:35:59 jra Exp $ (BRL)"
a1389 1
	int		a_flag;		/* application-specific flag */
d1864 1
a1864 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.229.2.3 2000/11/14 21:35:59 jra Exp $
@


11.229.2.5
log
@*- The following mods support the dg_obj's rtabort command:
	- added "struct run_rt"
	- added dgo_headRunRt to "struct dg_obj"
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.229.2.4 2000/11/27 23:29:16 jra Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.229.2.4 2000/11/27 23:29:16 jra Exp $ (BRL)"
a1047 11
 * Used to keep track of forked rt's for possible future aborts.
 * Currently used in mged/rtif.c and librt/dg_obj.c
 */
struct run_rt {
	struct bu_list		l;
	int			fd;
	int			pid;
	int			aborted;
};

/*
a1065 1
	struct run_rt		dgo_headRunRt;	/* head of forked rt processes */
d1865 1
a1865 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.229.2.4 2000/11/27 23:29:16 jra Exp $
@


11.228
log
@
Revised how 'solid pieces' state is managed from cell to cell.
Added "struct rt_htbl" to collect up hit state.
Added new method to rt_functab, ft_piece_hitsegs.
Changed args to method ft_piece_shot (removed unnecessary args).
Added externs for htbl.c routines.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.227 2000/05/23 19:35:44 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.227 2000/05/23 19:35:44 mike Exp $ (BRL)"
d761 1
d1880 1
a1880 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.227 2000/05/23 19:35:44 mike Exp $
@


11.227
log
@
Added new module "htbl.c", with variable length arrarys of "struct hit".
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.226 2000/05/22 00:04:07 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.226 2000/05/22 00:04:07 mike Exp $ (BRL)"
d1198 3
a1200 2
	/* Marked as unused with oddhit.hit_dist >= INFINITY */
	struct hit	oddhit;
d1704 1
d1706 3
a1708 1
			struct application * /*ap*/,
d1710 1
a1710 1
			struct resource * /*resp*/));
d1834 1
d1879 1
a1879 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.226 2000/05/22 00:04:07 mike Exp $
d2538 5
@


11.226
log
@
Added re_pieces_pending ptbl
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.225 2000/05/18 21:01:36 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.225 2000/05/18 21:01:36 mike Exp $ (BRL)"
d1169 15
d1874 1
a1874 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.225 2000/05/18 21:01:36 mike Exp $
@


11.225
log
@
Added new TCL macro, RT_CK_AP_TCL().
Added extern for debug routine rt_cell_n_on_ray()
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.224 2000/05/18 19:56:21 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.224 2000/05/18 19:56:21 mike Exp $ (BRL)"
d1271 1
d1859 1
a1859 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.224 2000/05/18 19:56:21 mike Exp $
@


11.224
log
@
Added member rti_save_overlaps.
If 1, fill in pt_overlap_reg, and modify rt_boolweave()'s processing
of adjacent partitions from the same region in presence of an overlap.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.223 2000/05/17 04:08:53 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.223 2000/05/17 04:08:53 mike Exp $ (BRL)"
d1395 1
d1858 1
a1858 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.223 2000/05/17 04:08:53 mike Exp $
d2229 1
@


11.223
log
@
Added an additional histogram.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.222 2000/05/16 23:45:03 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.222 2000/05/16 23:45:03 mike Exp $ (BRL)"
d1457 1
d1857 1
a1857 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.222 2000/05/16 23:45:03 mike Exp $
@


11.222
log
@
Support for Fastgen plate/plate overlap.
Also supports other inquiries into overlaps.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.221 2000/05/11 03:22:00 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.221 2000/05/11 03:22:00 mike Exp $ (BRL)"
d1504 1
d1856 1
a1856 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.221 2000/05/11 03:22:00 mike Exp $
@


11.221
log
@
Corrected bad declaration for pieces support
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.220 2000/05/09 20:44:03 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.220 2000/05/09 20:44:03 mike Exp $ (BRL)"
d586 1
a587 1
	struct region	**pt_overlap_reg;	/* NULL-terminated array of overlapping regions.  NULL if no overlap. */
d607 1
d629 4
d1855 1
a1855 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.220 2000/05/09 20:44:03 mike Exp $
@


11.220
log
@Moved V3RPP_DISJOINT to vmath.h
Added struct bound_rpp
Added st_piece_rpps field
Changed some vect_t declarations to point_t to better suggest their use.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.219 2000/05/08 20:44:25 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.219 2000/05/08 20:44:25 mike Exp $ (BRL)"
d681 1
a681 1
		struct rt_piecelist **bn_piecelist; /* [] solids with pieces */
d1850 1
a1850 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.219 2000/05/08 20:44:25 mike Exp $
@


11.219
log
@
Added ft_piece_shot and associated stuff for solid pieces.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.218 2000/05/02 01:38:28 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.218 2000/05/02 01:38:28 mike Exp $ (BRL)"
d427 1
a427 1
 * XXX move to vmath.h
d429 4
d434 1
a436 1
 *  RPP 1 is defined by lo1, hi1, RPP 2 by lo2, hi2.
d439 1
a439 2
      ( (_l1)[X] > (_h2)[X] || (_l1)[Y] > (_h2)[Y] || (_l1)[2] > (_h2)[2] || \
	(_l2)[X] > (_h1)[X] || (_l2)[Y] > (_h1)[1] || (_l2)[2] > (_h1)[2] )
d443 2
a444 3
	( ( (_pt)[X] >= (_min)[X] && (_pt)[X] <= (_max)[X] ) &&  \
	  ( (_pt)[Y] >= (_min)[Y] && (_pt)[Y] <= (_max)[Y] ) &&  \
	  ( (_pt)[Z] >= (_min)[Z] && (_pt)[Z] <= (_max)[Z] ) )
d459 1
a459 1
	vect_t		st_center;	/* Centroid of solid */
d464 2
a465 2
	vect_t		st_min;		/* min X, Y, Z of bounding RPP */
	vect_t		st_max;		/* max X, Y, Z of bounding RPP */
d473 1
d1463 4
a1466 4
	vect_t		mdl_min;	/* min corner of model bounding RPP */
	vect_t		mdl_max;	/* max corner of model bounding RPP */
	vect_t		rti_pmin;	/* for plotting, min RPP */
	vect_t		rti_pmax;	/* for plotting, max RPP */
d1801 1
a1801 1
	vect_t			curmin, curmax;
d1850 1
a1850 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.218 2000/05/02 01:38:28 mike Exp $
@


11.218
log
@
rt_bomb is once again a LIBRT function, not a macro.
It does the same things, though.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.217 2000/04/24 16:40:28 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.217 2000/04/24 16:40:28 mike Exp $ (BRL)"
a655 1
XXX question: is bn_piecelist an array, or a bu_list, of struct rt_piecelist's?
d678 1
a678 1
		struct rt_piecelist *bn_piecelist; /* solids with pieces */
d1168 1
d1193 2
d1197 2
a1198 2
	struct bu_list	l;
	long		npieces;
d1259 4
d1642 8
a1649 3
 *  Object-oriented interface to geometry modules.
 *  Table is indexed by ID_xxx value of particular solid.
 *  This needs to be at the end of the header file,
d1651 3
a1653 1
 *  XXX the "union record" and "struct nmgregion" pointers are problematic.
d1673 7
d1847 1
a1847 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.217 2000/04/24 16:40:28 mike Exp $
@


11.217
log
@
More stuff for solid pieces.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.216 2000/04/20 02:57:12 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.216 2000/04/20 02:57:12 mike Exp $ (BRL)"
d1827 1
a1827 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.216 2000/04/20 02:57:12 mike Exp $
d1899 1
a1899 1
		rt_bomb("going down in flames\n"); \
d1903 1
a1903 1
		rt_bomb("going down in flames\n"); \
d1907 1
a1907 1
		rt_bomb("going down in flames\n"); \
d1912 1
a1912 1
		rt_bomb("going down in flames\n"); \
d2195 3
@


11.216
log
@
Added support for FASTGEN plate/plate overlap handling.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.215 2000/04/15 02:04:58 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.215 2000/04/15 02:04:58 mike Exp $ (BRL)"
d653 4
d676 1
a676 1
		struct soltab **bn_list;
d679 2
d1172 1
d1198 1
a1198 1
	struct soltab	*stp;
d1827 1
a1827 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.215 2000/04/15 02:04:58 mike Exp $
@


11.215
log
@
Solid pieces.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.214 2000/04/14 03:40:38 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.214 2000/04/14 03:40:38 mike Exp $ (BRL)"
d584 1
d1820 1
a1820 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.214 2000/04/14 03:40:38 mike Exp $
@


11.214
log
@
Preliminary datastructures for BoT acceleration.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.213 2000/04/13 20:34:39 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.213 2000/04/13 20:34:39 mike Exp $ (BRL)"
d1166 2
a1167 1
	struct bu_bitv	shot;
d1819 1
a1819 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.213 2000/04/13 20:34:39 mike Exp $
@


11.213
log
@
raytrace.h shouldn't always include MGED's solid.h!!!
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.212 2000/04/12 01:44:01 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.212 2000/04/12 01:44:01 mike Exp $ (BRL)"
d468 3
d1137 2
a1138 1
/*			Q E L E M
d1155 40
d1246 2
d1492 2
d1818 1
a1818 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.212 2000/04/12 01:44:01 mike Exp $
@


11.212
log
@
Externs for the sketch support
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.211 2000/04/01 03:30:39 mike Exp $
a56 1
#include "solid.h"
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.211 2000/04/01 03:30:39 mike Exp $ (BRL)"
d1041 1
a1041 1
	struct solid		dgo_headSolid;	/* head of solid list */
d1770 1
a1770 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.211 2000/04/01 03:30:39 mike Exp $
@


11.211
log
@
Added externs for nmg_plot.c to raytrace.h
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.210 2000/04/01 03:16:00 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.210 2000/04/01 03:16:00 mike Exp $ (BRL)"
d1771 1
a1771 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.210 2000/04/01 03:16:00 mike Exp $
d2409 16
@


11.210
log
@
Added externs from mng_fcut.c to raytrace.h
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.209 2000/04/01 03:00:56 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.209 2000/04/01 03:00:56 mike Exp $ (BRL)"
d1771 1
a1771 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.209 2000/04/01 03:00:56 mike Exp $
d2972 30
a3001 1
/* add nmg_xxx_to_vlist routines here */
d3024 15
d3051 11
a3061 4
BU_EXTERN(void			nmg_pl_around_edge, (FILE *fd,
				long *b, CONST struct edgeuse *eu) );
BU_EXTERN(void			nmg_pl_isect, (CONST char *filename,
				CONST struct shell *s, CONST struct bn_tol *tol) );
d3067 7
d3079 18
a3099 1

@


11.209
log
@
added externs from nmg_inter.c to raytrace.h
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.208 2000/04/01 02:18:55 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.208 2000/04/01 02:18:55 mike Exp $ (BRL)"
d1771 1
a1771 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.208 2000/04/01 02:18:55 mike Exp $
a3064 2
BU_EXTERN(void			nmg_set_lu_orientation, (struct loopuse	*lu,
				int is_opposite) );
d3066 2
d3071 47
d3125 12
@


11.208
log
@
CONSTing in nmg_visit*
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.207 2000/04/01 01:52:43 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.207 2000/04/01 01:52:43 mike Exp $ (BRL)"
d1771 1
a1771 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.207 2000/04/01 01:52:43 mike Exp $
d1996 26
d3188 149
d3338 2
@


11.207
log
@
added externs from nmg_mod.c to raytrace.h
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.206 2000/04/01 01:43:51 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.206 2000/04/01 01:43:51 mike Exp $ (BRL)"
d1771 1
a1771 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.206 2000/04/01 01:43:51 mike Exp $
d3374 1
a3374 1
				struct nmg_visit_handlers	*htab,
d3378 1
a3378 1
				struct nmg_visit_handlers	*htab,
d3382 1
a3382 1
				struct nmg_visit_handlers	*htab,
d3386 1
a3386 1
				struct nmg_visit_handlers	*htab,
d3390 1
a3390 1
				struct nmg_visit_handlers	*htab,
d3394 1
a3394 1
				struct nmg_visit_handlers	*htab,
d3398 1
a3398 1
				struct nmg_visit_handlers	*htab,
d3402 1
a3402 1
				struct nmg_visit_handlers	*htab,
d3406 1
a3406 1
				struct nmg_visit_handlers	*htab,
d3410 1
a3410 1
				struct nmg_visit_handlers	*htab,
d3414 1
a3414 1
				struct nmg_visit_handlers	*htab,
d3417 2
a3418 2
				(long				*magicp,
				struct nmg_visit_handlers	*htab,
@


11.206
log
@
added externs for nmg_index.c
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.205 2000/04/01 01:39:16 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.205 2000/04/01 01:39:16 mike Exp $ (BRL)"
d1771 1
a1771 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.205 2000/04/01 01:39:16 mike Exp $
d2448 6
d2455 4
d2465 10
d2495 1
d2499 8
d2523 3
@


11.205
log
@
added externs for nmg_visit.c to raytrace.h
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.204 2000/04/01 01:34:19 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.204 2000/04/01 01:34:19 mike Exp $ (BRL)"
d1771 1
a1771 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.204 2000/04/01 01:34:19 mike Exp $
d3133 2
a3134 1
BU_EXTERN(int			nmg_index_of_struct, (long *p) );
d3144 3
d3149 2
@


11.204
log
@
externs for nmg_fuse.c into raytrace.h
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.203 2000/04/01 01:17:51 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.203 2000/04/01 01:17:51 mike Exp $ (BRL)"
d1771 1
a1771 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.203 2000/04/01 01:17:51 mike Exp $
d3332 51
@


11.203
log
@
externs for nmg_info.c added to raytrace.h
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.202 2000/03/29 18:55:22 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.202 2000/03/29 18:55:22 mike Exp $ (BRL)"
d1771 1
a1771 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.202 2000/03/29 18:55:22 mike Exp $
d3182 1
d3194 1
d3201 15
d3224 3
d3244 1
d3253 19
d3278 22
d3304 5
d3314 3
@


11.202
log
@
externs
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.201 2000/03/29 02:54:06 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.201 2000/03/29 02:54:06 mike Exp $ (BRL)"
d1771 1
a1771 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.201 2000/03/29 02:54:06 mike Exp $
d2533 2
d2562 2
d2600 5
d2607 1
a2607 1
BU_EXTERN(void			nmg_vertex_tabulate, (struct bu_ptbl *tab,
d2609 2
d2613 12
@


11.201
log
@
const and extern for nmg_extrude.c
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.200 2000/03/29 02:36:02 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.200 2000/03/29 02:36:02 mike Exp $ (BRL)"
d1771 1
a1771 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.200 2000/03/29 02:36:02 mike Exp $
d3001 2
d3004 6
d3012 3
a3014 4
BU_EXTERN(void			nmg_eval_shell, (struct shell *s,
				struct nmg_bool_state *bs ) );
BU_EXTERN(void			nmg_eval_plot, (struct nmg_bool_state *bs,
				int num, int delay) );
@


11.200
log
@
externs and consts for nmg_misc.c
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.199 2000/03/29 01:48:48 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.199 2000/03/29 01:48:48 mike Exp $ (BRL)"
d1771 1
a1771 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.199 2000/03/29 01:48:48 mike Exp $
d2607 26
@


11.199
log
@
externs for nmg_pr.c
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.198 2000/03/29 01:43:01 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.198 2000/03/29 01:43:01 mike Exp $ (BRL)"
d1771 1
a1771 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.198 2000/03/29 01:43:01 mike Exp $
d2660 52
a2711 1
BU_EXTERN(int			bu_ptbl, (struct bu_ptbl *b, int func, long *p) );
d2716 18
d2736 11
a2746 1
BU_EXTERN(void			nmg_fix_normals, (struct shell *s_orig,
d2752 6
d2766 9
a2774 1
				struct bu_list *vhead));
d2779 5
d2793 2
d2796 6
d2804 2
d2807 1
a2807 1
				struct bn_tol *tol));
d2821 1
@


11.198
log
@
Moved nmg_ck_list* to bu_ck_list*
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.197 2000/03/29 01:36:57 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.197 2000/03/29 01:36:57 mike Exp $ (BRL)"
d1771 1
a1771 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.197 2000/03/29 01:36:57 mike Exp $
d2617 1
d2628 2
d2636 22
@


11.197
log
@
Added externs, tidied up CONST args
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.196 2000/03/29 01:17:25 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.196 2000/03/29 01:17:25 mike Exp $ (BRL)"
d1771 1
a1771 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.196 2000/03/29 01:17:25 mike Exp $
a2923 3
BU_EXTERN(void			nmg_ck_list, (struct bu_list *hd, CONST char *str) );
BU_EXTERN(void			nmg_ck_list_magic, (CONST struct bu_list *hd,
				CONST char *str, CONST long magic) );
@


11.196
log
@
Added externs, fixed messages.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.195 2000/03/28 22:40:09 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.195 2000/03/28 22:40:09 mike Exp $ (BRL)"
d1771 1
a1771 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.195 2000/03/28 22:40:09 mike Exp $
d2865 60
a2924 1
/* XXX many others here */
d2927 1
a2927 2
BU_EXTERN(void			nmg_ck_list, (struct bu_list *hd, CONST char *str) );
BU_EXTERN(void			nmg_ck_lueu, (struct loopuse *lu, char *s) );
d2929 4
d2938 3
d3062 2
a3063 2
				(struct edgeuse		*eu,
				struct shell		*s,
@


11.195
log
@
More externs
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.194 2000/03/28 22:06:15 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.194 2000/03/28 22:06:15 mike Exp $ (BRL)"
d1771 1
a1771 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.194 2000/03/28 22:06:15 mike Exp $
d2642 52
@


11.194
log
@
moved nmg_radial structure to raytrace.h
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.193 2000/03/28 21:25:12 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.193 2000/03/28 21:25:12 mike Exp $ (BRL)"
d1771 1
a1771 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.193 2000/03/28 21:25:12 mike Exp $
d2560 2
d2581 2
d2602 5
d2870 54
a2923 5
BU_EXTERN(struct vertexuse 	*nmg_is_vertex_in_face, (CONST struct vertex *v,
				CONST struct face *f));
BU_EXTERN(struct edge_g_lseg	*nmg_pick_best_edge_g, (struct edgeuse *eu1,
				struct edgeuse *eu2, CONST struct bn_tol *tol));
BU_EXTERN(void			nmg_pr_radial_list, (CONST struct bu_list *hd,
d2925 9
d2936 22
@


11.193
log
@
Prototypes for nurb_bezier moved to raytrace.h
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.192 2000/03/28 20:50:49 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.192 2000/03/28 20:50:49 mike Exp $ (BRL)"
d1771 1
a1771 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.192 2000/03/28 20:50:49 mike Exp $
d1982 13
a2854 1

d2860 9
a2868 1

@


11.192
log
@
Moved shootray_status to raytrace.h, added rt_ prefix
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.191 2000/03/28 02:17:59 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.191 2000/03/28 02:17:59 mike Exp $ (BRL)"
d1771 1
a1771 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.191 2000/03/28 02:17:59 mike Exp $
d2834 14
@


11.191
log
@
Added externs for rt_silent_logoverlap and rt_default_logoverlap.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.190 2000/03/28 01:52:31 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.190 2000/03/28 01:52:31 mike Exp $ (BRL)"
d1700 48
d1771 1
a1771 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.190 2000/03/28 01:52:31 mike Exp $
@


11.190
log
@
Added a_logoverlap()
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.189 2000/03/16 13:39:27 jra Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.189 2000/03/16 13:39:27 jra Exp $ (BRL)"
d1723 1
a1723 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.189 2000/03/16 13:39:27 jra Exp $
d1947 1
a1947 1
					/* Handle overlap w/o logging */
d1951 9
@


11.189
log
@Sketch solid can only have one curve now
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.188 2000/03/15 22:49:11 butler Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.188 2000/03/15 22:49:11 butler Exp $ (BRL)"
d1293 2
a1294 1
	void		(*a_multioverlap)BU_ARGS( (struct application *, struct partition *, struct bu_ptbl *, struct partition *) );	/* called when overlaps occur */
d1723 1
a1723 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.188 2000/03/15 22:49:11 butler Exp $
@


11.188
log
@Changed a couple "long" variables to "unsigned long" so that we can
set initializers with the high bit set.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.187 2000/03/07 02:13:48 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.187 2000/03/07 02:13:48 mike Exp $ (BRL)"
a1545 2
	int			curve_count;	/* number of curves using this segment */
	struct curve		**curves;	/* array of pointers to curves using this segment */
a1558 2
	int			curve_count;	/* number of curves using this segment */
	struct curve		**curves;	/* array of pointers to curves using this segment */
a1571 2
	int			curve_count;	/* number of curves using this segment */
	struct curve		**curves;	/* array of pointers to curves using this segment */
d1722 1
a1722 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.187 2000/03/07 02:13:48 mike Exp $
@


11.187
log
@
Solids don't get marked as FASTGEN, only regions.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.186 2000/03/04 05:27:10 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.186 2000/03/04 05:27:10 mike Exp $ (BRL)"
d1674 1
a1674 1
	long	ft_internal_magic;	/* RT_XXX_INTERNAL_MAGIC */
d1728 1
a1728 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.186 2000/03/04 05:27:10 mike Exp $
@


11.186
log
@
Moved ts_is_fastgen to just after ts_mat, to further ease changes
to existing initializations of this structure, e.g. in librt/tree.c
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.185 2000/03/04 05:23:44 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.185 2000/03/04 05:23:44 mike Exp $ (BRL)"
a468 1
	short		st_is_platemode;/* 1 = solid is FASTGEN plate mode */
d1728 1
a1728 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.185 2000/03/04 05:23:44 mike Exp $
@


11.185
log
@
Moved ts_is_fastgen flag to end of db_tree_state structure, so that
*_initial_tree_state initialized structures don't need to be changed.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.184 2000/03/04 05:18:51 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.184 2000/03/04 05:18:51 mike Exp $ (BRL)"
d837 1
a866 1
	int		ts_is_fastgen;	/* REGION_NON_FASTGEN/_PLATE/_VOLUME */
d1729 1
a1729 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.184 2000/03/04 05:18:51 mike Exp $
@


11.184
log
@
added FASTGEN-region support
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.183 2000/03/03 01:50:59 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.183 2000/03/03 01:50:59 mike Exp $ (BRL)"
a830 1
	int		ts_is_fastgen;	/* REGION_NON_FASTGEN/_PLATE/_VOLUME */
d866 1
d1729 1
a1729 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.183 2000/03/03 01:50:59 mike Exp $
@


11.183
log
@
Clarified declaration of callbacks.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.182 2000/03/03 01:00:17 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.182 2000/03/03 01:00:17 mike Exp $ (BRL)"
d548 6
a553 2
	int		reg_instnum;	/* instance number, from d_uses */
	int		reg_all_unions;	/* 1=boolean tree is all unions */
d800 1
d831 1
d1729 1
a1729 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.182 2000/03/03 01:00:17 mike Exp $
@


11.182
log
@
Added extra CONST to dbi_filepath to please GCC compilers.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.181 2000/03/02 14:40:28 jra Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.181 2000/03/02 14:40:28 jra Exp $ (BRL)"
d1723 1
a1723 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.181 2000/03/02 14:40:28 jra Exp $
d2178 1
a2178 1
	int (*reg_start_func) BU_ARGS((
d2182 2
a2183 2
		genptr_t client_data
	)), union tree * (*reg_end_func) BU_ARGS((
d2187 2
a2188 2
		genptr_t client_data
	)), union tree * (*leaf_func) BU_ARGS((
d2193 2
a2194 2
		genptr_t client_data
	)), genptr_t client_data ));
@


11.181
log
@Eliminated FGP solids and added CLINE solid
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.180 2000/03/02 03:50:46 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.180 2000/03/02 03:50:46 mike Exp $ (BRL)"
d729 1
a729 1
	char			**dbi_filepath;	/* search path for aux file opens (convenience var) */
d1723 1
a1723 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.180 2000/03/02 03:50:46 mike Exp $
@


11.180
log
@
Added dbi_filepath
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.179 2000/02/29 20:33:27 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.179 2000/02/29 20:33:27 mike Exp $ (BRL)"
d512 1
a512 1
#define	ID_FGP		29	/* FASTGEN4 plate mode solid */
d1723 1
a1723 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.179 2000/02/29 20:33:27 mike Exp $
@


11.179
log
@
Added rti_max_beam_radius,
an st_ fastgen flag,
and a real function prototype for db_walk_tree()
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.178 2000/02/18 17:49:22 bparker Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.178 2000/02/18 17:49:22 bparker Exp $ (BRL)"
d715 1
a715 1
 *  of a model database file.
d717 3
a719 2
 *  The contents of this structure are intended to be "opaque" to
 *  application programmers.
d723 8
a736 5
	double			dbi_local2base;	/* local2mm */
	double			dbi_base2local;	/* unit conversion factors */
	char			*dbi_title;	/* title from IDENT rec */
	char			*dbi_filename;	/* file name */
	int			dbi_read_only;	/* !0 => read only file */
d1723 1
a1723 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.178 2000/02/18 17:49:22 bparker Exp $
@


11.178
log
@*- add observer list to dg_obj, view_obj and rt_wdb
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.177 2000/02/10 05:06:30 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.177 2000/02/10 05:06:30 mike Exp $ (BRL)"
d456 1
a456 1
	int		st_uses;	/* Usage count, for instanced solids */
d465 1
a465 1
	int		st_bit;		/* solids bit vector index (const) */
d469 1
d1388 1
d1719 1
a1719 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.177 2000/02/10 05:06:30 mike Exp $
d2174 17
a2190 2
	int (*reg_start_func)(), union tree * (*reg_end_func)(),
	union tree * (*leaf_func)(), genptr_t client_data ));
@


11.177
log
@
Move rt_cutLen into rti_cutlen
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.176 2000/02/02 20:11:22 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.176 2000/02/02 20:11:22 mike Exp $ (BRL)"
d987 1
a1034 5
#if 0   /*XXX moved to rt_wdb */
	struct db_tree_state	dgo_initial_tree_state;
	struct rt_tess_tol	dgo_ttol;
	struct bn_tol		dgo_tol;
#endif
d1037 1
d1048 17
a1064 16
  struct bu_list	l;
  struct bu_vls		vo_name;		/* view object name/cmd */
  fastf_t		vo_scale;
  fastf_t		vo_size;		/* 2.0 * scale */
  fastf_t		vo_invSize;		/* 1.0 / size */
  fastf_t 		vo_perspective;		/* perspective angle */
  fastf_t		vo_local2base;		/* scale local units to base units (i.e. mm) */
  fastf_t		vo_base2local;		/* scale base units (i.e. mm) to local units */
  vect_t		vo_aet;
  vect_t		vo_eye_pos;		/* eye position */
  mat_t			vo_rotation;
  mat_t			vo_center;
  mat_t			vo_model2view;
  mat_t			vo_pmodel2view;
  mat_t			vo_view2model;
  mat_t			vo_pmat;		/* perspective matrix */
d1717 1
a1717 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.176 2000/02/02 20:11:22 mike Exp $
@


11.176
log
@
Fixed off-by-one error which wasted one semaphore.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.175 2000/02/02 02:45:44 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.175 2000/02/02 02:45:44 mike Exp $ (BRL)"
d1431 2
d1719 1
a1719 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.175 2000/02/02 02:45:44 mike Exp $
d2034 2
a2035 1
BU_EXTERN(void rt_cut_extend, (union cutter *cutp, struct soltab *stp) );
@


11.175
log
@
Fixed out-of-date comment on struct partition.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.174 2000/02/02 02:08:36 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.174 2000/02/02 02:08:36 mike Exp $ (BRL)"
d1350 1
a1350 1
#define RT_SEM_TREE0	(BU_SEM_LAST+1)
d1717 1
a1717 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.174 2000/02/02 02:08:36 mike Exp $
@


11.174
log
@
Retracted a_segs_only flag.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.173 2000/02/02 01:23:32 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.173 2000/02/02 01:23:32 mike Exp $ (BRL)"
d560 3
a562 6
 *  NOTE:  rt_get_pt allows enough storage at the end of the partition
 *  for a bit vector of "rt_i.nsolids" bits in length.
 *
 *  NOTE:  The number of solids in a model can change from frame to frame
 *  due to the effect of animations, so partition structures can be expected
 *  to change length over the course of a single application program.
d1717 1
a1717 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.173 2000/02/02 01:23:32 mike Exp $
@


11.173
log
@
Eliminated rti_nobool in favor of a_segs_only
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.172 2000/02/01 20:08:43 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.172 2000/02/01 20:08:43 mike Exp $ (BRL)"
a1296 1
	int		a_segs_only;	/* 1= no partitions, only seg list */
d1720 1
a1720 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.172 2000/02/01 20:08:43 mike Exp $
@


11.172
log
@
Added reg_all_unions flag
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.171 2000/01/21 15:05:35 jra Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.171 2000/01/21 15:05:35 jra Exp $ (BRL)"
d1297 1
a1385 1
	int		rti_nobool;	/* 1=find seg list only, no partitions */
d1721 1
a1721 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.171 2000/01/21 15:05:35 jra Exp $
@


11.171
log
@Added a "center" field to the struct carc_seg
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.170 2000/01/14 22:43:33 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.170 2000/01/14 22:43:33 mike Exp $ (BRL)"
d548 1
d1721 1
a1721 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.170 2000/01/14 22:43:33 mike Exp $
@


11.170
log
@
Changed two return types
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.169 2000/01/11 21:34:44 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.169 2000/01/11 21:34:44 mike Exp $ (BRL)"
d1555 1
d1720 1
a1720 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.169 2000/01/11 21:34:44 mike Exp $
@


11.169
log
@
Added DEBUG_PLOTSOLIDS
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.168 2000/01/07 19:48:02 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.168 2000/01/07 19:48:02 mike Exp $ (BRL)"
d1719 1
a1719 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.168 2000/01/07 19:48:02 mike Exp $
d2059 1
a2059 1
BU_EXTERN(void db_region_mat, (mat_t m, CONST struct db_i *dbip,
d2061 1
a2061 1
BU_EXTERN(void db_shader_mat, (mat_t model_to_shader, CONST struct rt_i *rtip,
@


11.168
log
@
Made default value for rti_space_partition be zero,
for ease of libwdb users.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.167 2000/01/07 04:20:15 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.167 2000/01/07 04:20:15 mike Exp $ (BRL)"
d118 1
d124 1
d1719 1
a1719 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.167 2000/01/07 04:20:15 mike Exp $
@


11.167
log
@
Eliminated dbi_localunit.  This is a v4 database anachronism.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.166 2000/01/06 16:15:45 bparker Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.166 2000/01/06 16:15:45 bparker Exp $ (BRL)"
d1449 2
a1450 2
#define RT_PART_NUGRID	0
#define	RT_PART_NUBSPT	1
d1717 1
a1717 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.166 2000/01/06 16:15:45 bparker Exp $
@


11.166
log
@*- move tolerance and tree state from dg_obj to rt_wdb
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.165 2000/01/06 04:42:11 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.165 2000/01/06 04:42:11 mike Exp $ (BRL)"
a725 1
	int			dbi_localunit;	/* unit currently in effect */
d727 1
a727 1
	double			dbi_local2base;
d1717 1
a1717 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.165 2000/01/06 04:42:11 mike Exp $
@


11.165
log
@
ft_xform really needed a dbip parameter so it could pass it along to
ft_export and ft_import

Also added extra members for submodel.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.164 2000/01/04 17:58:20 bparker Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.164 2000/01/04 17:58:20 bparker Exp $ (BRL)"
d974 3
d1035 1
d1039 1
d1718 1
a1718 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.164 2000/01/04 17:58:20 bparker Exp $
@


11.164
log
@*- add client_data to db_walk_tree
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.163 2000/01/04 15:15:21 bparker Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.163 2000/01/04 15:15:21 bparker Exp $ (BRL)"
d1428 4
a1431 1
	struct soltab	*rti_up;	/* 'up' ptr for rt_submodel rti's only */
d1656 1
a1656 1
			int /*free*/));
d1713 1
a1713 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.163 2000/01/04 15:15:21 bparker Exp $
@


11.163
log
@*- moved head of database object list to rt_g
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.162 2000/01/03 21:41:28 bparker Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.162 2000/01/03 21:41:28 bparker Exp $ (BRL)"
d833 2
a834 1
				CONST struct rt_comb_internal * /* combp */
d839 2
a840 1
				union tree * /*curtree*/
d846 2
a847 1
				int /*id*/
d1710 1
a1710 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.162 2000/01/03 21:41:28 bparker Exp $
d2155 1
a2155 1
	struct combined_tree_state **region_start_statepp));
d2165 1
a2165 1
	union tree * (*leaf_func)() ));
d2649 1
a2649 1
				struct bu_external *ep, int id));
d2652 1
a2652 1
				struct bu_external *ep, int id));
@


11.162
log
@*- merge "struct wdb_obj" into "struct rt_wdb"
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.161 2000/01/03 15:26:20 bparker Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.161 2000/01/03 15:26:20 bparker Exp $ (BRL)"
d1332 1
d1707 1
a1707 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.161 2000/01/03 15:26:20 bparker Exp $
@


11.161
log
@*- add members to dg_obj
*- add members to view_obj
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.160 1999/12/30 05:26:17 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.160 1999/12/30 05:26:17 mike Exp $ (BRL)"
d952 5
d966 1
a966 1
	long		magic;
d970 12
d996 1
a996 30
/* Some dubious defines, to support the wdb_obj.c evolution */
#define RT_MAXARGS		9000
#define RT_MAXLINE		10240
#define RT_NAMESIZE		16

/*
 *			W D B _ O B J
 *
 * A database object is used to interact with a Brl-Cad database.
 * This will eventually all migrate into the rt_wdb structure.
 * One application may have many of these open at one time.
 */
struct wdb_obj {
  struct bu_list	l;
  struct bu_vls		wdb_name;	/* database object name */
  struct rt_wdb		*wdb_wp;

  /* variables for name prefixing */
  char			wdb_prestr[RT_NAMESIZE];
  int			wdb_ncharadd;
  int			wdb_num_dups;

  /* default region ident codes for this particular database. */
  int			wdb_item_default;/* GIFT region ID */
  int			wdb_air_default;
  int			wdb_mat_default;/* GIFT material code */
  int			wdb_los_default;/* Line-of-sight estimate */
};
extern struct wdb_obj HeadWDBObj;		/* head of BRLCAD database object list */
#define RT_WDBO_NULL		((struct wdb_obj *)NULL)
d1025 1
a1025 1
	struct wdb_obj		*dgo_wdbop;	/* associated database */
d1706 1
a1706 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.160 1999/12/30 05:26:17 mike Exp $
@


11.160
log
@
Added additional fields to wdb_obj struct, to kill global variables.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.159 1999/12/30 04:56:56 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.159 1999/12/30 04:56:56 mike Exp $ (BRL)"
a811 118
 *			R T _ W D B
 *
 *  This data structure is at the core of the "LIBWDB" support for
 *  allowing application programs to read and write BRL-CAD databases.
 *  Many different access styles are supported.
 */
 
struct rt_wdb  {
	long		magic;
	int		type;
	FILE		*fp;
	struct db_i	*dbip;
};

#define	RT_WDB_MAGIC			0x5f576462
#define RT_CHECK_WDB(_p)		BU_CKMAG(_p,RT_WDB_MAGIC,"rt_wdb")
#define RT_CHECK_WDB_TCL(_interp,_p)	BU_CKMAG_TCL(_interp,_p,RT_WDB_MAGIC,"rt_wdb")
#define RT_CK_WDB(_p)			RT_CHECK_WDB(_p)
#define RT_CK_WDB_TCL(_interp,_p)	RT_CHECK_WDB_TCL(_interp,_p)
#define RT_WDB_NULL		((struct rt_wdb *)NULL)
#define RT_WDB_TYPE_FILE			1
#define RT_WDB_TYPE_DB_DISK			2
#define RT_WDB_TYPE_DB_DISK_APPEND_ONLY		3
#define RT_WDB_TYPE_DB_INMEM			4
#define RT_WDB_TYPE_DB_INMEM_APPEND_ONLY	5

/* Some dubious defines, to support the wdb_obj.c evolution */
#define RT_MAXARGS		9000
#define RT_MAXLINE		10240
#define RT_NAMESIZE		16

/*
 *			W D B _ O B J
 *
 * A database object is used to interact with a Brl-Cad database.
 * This will eventually all migrate into the rt_wdb structure.
 * One application may have many of these open at one time.
 */
struct wdb_obj {
  struct bu_list	l;
  struct bu_vls		wdb_name;	/* database object name */
  struct rt_wdb		*wdb_wp;

  /* variables for name prefixing */
  char			wdb_prestr[RT_NAMESIZE];
  int			wdb_ncharadd;
  int			wdb_num_dups;

  /* default region ident codes for this particular database. */
  int			wdb_item_default;/* GIFT region ID */
  int			wdb_air_default;
  int			wdb_mat_default;/* GIFT material code */
  int			wdb_los_default;/* Line-of-sight estimate */
};
extern struct wdb_obj HeadWDBObj;		/* head of BRLCAD database object list */
#define RT_WDBO_NULL		((struct wdb_obj *)NULL)

/*
 * Carl's vdraw stuff.
 */
#define RT_VDRW_PREFIX		"_VDRW"
#define RT_VDRW_PREFIX_LEN	6
#define RT_VDRW_MAXNAME	31
#define RT_VDRW_DEF_COLOR	0xffff00
struct vd_curve {
	struct bu_list	l;
	char		vdc_name[RT_VDRW_MAXNAME+1]; 	/* name array */
	long		vdc_rgb;	/* color */
	struct bu_list	vdc_vhd;	/* head of list of vertices */
};
#define VD_CURVE_NULL		((struct vd_curve *)NULL)

/*
 *			D G _ O B J
 *
 * A drawable geometry object is associated with a database object
 * and is used to maintain lists of geometry that are ready for display.
 * This geometry can come from a Brl-Cad database or from vdraw commands.
 * The drawable geometry object is also capabable of raytracing geometry
 * that comes from a Brl-Cad database.
 */
struct dg_obj {
	struct bu_list	l;
	struct bu_vls		dgo_name;	/* drawable geometry object name */
	struct wdb_obj		*dgo_wdbop;	/* associated database */
	struct solid		dgo_headSolid;	/* head of solid list */
	struct bu_list		dgo_headVDraw;	/* head of vdraw list */
	struct vd_curve		*dgo_currVHead;	/* current vdraw head */
	char			*dgo_rt_cmd[RT_MAXARGS];
	int			dgo_rt_cmd_len;
};
extern struct dg_obj HeadDGObj;		/* head of drawable geometry object list */
#define RT_DGO_NULL		((struct dg_obj *)NULL)

/*
 *			V I E W _ O B J
 *
 * A view object maintains state for controlling a view.
 */
struct view_obj {
  struct bu_list	l;
  struct bu_vls		vo_name;		/* view object name/cmd */
  fastf_t		vo_scale;
  fastf_t		vo_size;		/* 2.0 * scale */
  fastf_t		vo_invSize;		/* 1.0 / size */
  fastf_t 		vo_perspective;		/* perspective angle */
  vect_t		vo_aet;
  mat_t			vo_rotation;
  mat_t			vo_center;
  mat_t			vo_model2view;
  mat_t			vo_pmodel2view;
  mat_t			vo_view2model;
  mat_t			vo_pmat;		/* perspective matrix */
};
extern struct view_obj HeadViewObj;		/* head of view object list */
#define RT_VIEW_OBJ_NULL		((struct view_obj *)NULL)

/*
d953 124
d1718 1
a1718 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.159 1999/12/30 04:56:56 mike Exp $
@


11.159
log
@
Additional datastructures to support the submodel.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.158 1999/12/29 23:23:07 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.158 1999/12/29 23:23:07 mike Exp $ (BRL)"
d814 3
a816 1
 * XXX Somebody give me a descriptive comment
d838 5
d847 2
d854 11
a883 4
#define RT_MAXARGS		9000
#define RT_MAXLINE		10240
#define RT_NAMESIZE		16

d1712 1
a1712 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.158 1999/12/29 23:23:07 mike Exp $
@


11.158
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.157 1999/12/29 22:37:16 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.157 1999/12/29 22:37:16 mike Exp $ (BRL)"
d313 4
d354 3
d374 3
d737 1
d1696 1
a1696 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.157 1999/12/29 22:37:16 mike Exp $
d2047 1
d2049 4
@


11.157
log
@
New fields for g_sketch
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.156 1999/12/29 21:09:32 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.156 1999/12/29 21:09:32 mike Exp $ (BRL)"
d1685 1
a1685 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.156 1999/12/29 21:09:32 mike Exp $
d2070 4
a2073 1
BU_EXTERN(int db_scan, ( struct db_i *, int (*handler)(), int do_old_matter ) );
d2083 1
a2083 1
	int len, int flags ) );
@


11.156
log
@Added client_data pointer to db_functree() to eliminate use of
global variables.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.155 1999/12/29 14:18:22 bparker Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.155 1999/12/29 14:18:22 bparker Exp $ (BRL)"
d1496 2
a1497 2
 *			L I N E _ S E G
 *	used by the solid of extrusion
d1515 3
a1517 1

d1527 6
a1532 2
	int			start, end;	/* indices */
	struct edge_g_cnurb	cnurb;		/* NURB curve (some fields ignored) */
d1685 1
a1685 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.155 1999/12/29 14:18:22 bparker Exp $
@


11.155
log
@*- define RT_NAMESIZE
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.154 1999/12/27 20:58:16 bparker Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.154 1999/12/27 20:58:16 bparker Exp $ (BRL)"
d1679 1
a1679 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.154 1999/12/27 20:58:16 bparker Exp $
d2141 6
@


11.154
log
@*- struct vd_curve /* Carl's vdraw stuff */
*- struct dg_obj /* Drawable Geometry Object */
*- struct view_obj /* View Object */
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.153 1999/12/23 06:25:29 mike Exp $
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.153 1999/12/23 06:25:29 mike Exp $ (BRL)"
d855 1
d1679 1
a1679 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.153 1999/12/23 06:25:29 mike Exp $
@


11.153
log
@
Added new flag for g_submodel
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.152 1999/12/23 05:56:12 mike Exp $
d57 1
d67 1
a67 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.152 1999/12/23 05:56:12 mike Exp $ (BRL)"
d825 5
d832 1
a832 1
  struct bu_vls		wdb_name;	/* database name */
d835 65
d1678 1
a1678 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.152 1999/12/23 05:56:12 mike Exp $
@


11.152
log
@
Changed region structures over to using bu_list
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.151 1999/12/22 04:55:29 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.151 1999/12/22 04:55:29 mike Exp $ (BRL)"
d1281 1
d1607 1
a1607 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.151 1999/12/22 04:55:29 mike Exp $
@


11.151
log
@
Addition bu_mapped_file support.
db_open(,"r") now uses bu_open_mapped_file().
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.150 1999/12/21 16:54:44 bparker Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.150 1999/12/21 16:54:44 bparker Exp $ (BRL)"
d522 1
a522 1
	long		reg_magic;
a529 1
	struct region	*reg_forw;	/* linked list of all regions */
d1298 1
a1298 1
	struct region	*HeadRegion;	/* ptr of list of regions in model */
d1606 1
a1606 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.150 1999/12/21 16:54:44 bparker Exp $
@


11.150
log
@*- struct wdb_obj
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.149 1999/12/18 00:57:50 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.149 1999/12/18 00:57:50 mike Exp $ (BRL)"
d724 1
a724 2
	char			*dbi_inmem;	/* ptr to in-memory copy */
	char			*dbi_shmaddr;	/* ptr to memory-mapped file */
d726 1
d1607 1
a1607 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.149 1999/12/18 00:57:50 mike Exp $
@


11.149
log
@
Added rti_up for g_submodel.c
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.148 1999/12/18 00:55:58 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.148 1999/12/18 00:55:58 mike Exp $ (BRL)"
d825 6
d1607 1
a1607 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.148 1999/12/18 00:55:58 mike Exp $
@


11.148
log
@
Contents of librt/debug.h moved to h/raytrace.h so that app developers on
binary-only distributions could see the bit definitions,
and access the DEBUG_FORMAT string, etc.
Per suggestion of CTJ.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.147 1999/12/18 00:43:32 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.147 1999/12/18 00:43:32 mike Exp $ (BRL)"
d1325 1
d1601 1
a1601 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.147 1999/12/18 00:43:32 mike Exp $
@


11.147
log
@
Added definitions from nmg_isect_ray_model.c
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.146 1999/12/07 03:32:06 mike Exp $
d66 61
a126 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.146 1999/12/07 03:32:06 mike Exp $ (BRL)"
d1600 1
a1600 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.146 1999/12/07 03:32:06 mike Exp $
@


11.146
log
@
Fixed arg type.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.145 1999/12/06 16:54:00 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.145 1999/12/06 16:54:00 mike Exp $ (BRL)"
d1540 1
a1540 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.145 1999/12/06 16:54:00 mike Exp $
d1564 1
a2507 1
#if 0
d2511 3
a2513 1
BU_EXTERN(int			nmg_ray_isect_segs, (struct soltab *stp,
d2519 1
@


11.145
log
@
Changed rt_ars_hitsort() into rt_hitsort(), and made it a non-hidden
routine.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.144 1999/12/06 16:39:45 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.144 1999/12/06 16:39:45 mike Exp $ (BRL)"
d1540 1
a1540 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.144 1999/12/06 16:39:45 mike Exp $
d2131 1
a2131 1
BU_EXTERN(void			nmg_vertexuse_a_cnurb, (struct vertexuse *vu, CONST vect_t uvw));
@


11.144
log
@
Added rt_pr_hitarray_vls()
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.143 1999/12/01 16:00:40 bparker Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.143 1999/12/01 16:00:40 bparker Exp $ (BRL)"
d1540 1
a1540 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.143 1999/12/01 16:00:40 bparker Exp $
d2023 3
@


11.143
log
@*- another _TCL macro
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.142 1999/12/01 13:24:07 bparker Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.142 1999/12/01 13:24:07 bparker Exp $ (BRL)"
d1540 1
a1540 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.142 1999/12/01 13:24:07 bparker Exp $
d2037 2
@


11.142
log
@*- added a few _TCL macros
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.141 1999/11/26 22:39:35 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.141 1999/11/26 22:39:35 mike Exp $ (BRL)"
d735 4
a738 2
#define RT_CK_COMB(_p)		BU_CKMAG( _p , RT_COMB_MAGIC , "rt_comb_internal" )

d1540 1
a1540 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.141 1999/11/26 22:39:35 mike Exp $
@


11.141
log
@
More extern declarations
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.140 1999/11/26 22:29:27 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.140 1999/11/26 22:29:27 mike Exp $ (BRL)"
d671 4
a674 2
#define RT_CHECK_DBI(_p)	BU_CKMAG(_p,DBI_MAGIC,"struct db_i")
#define RT_CK_DBI(_p)		BU_CKMAG(_p,DBI_MAGIC,"struct db_i")
d752 4
a755 1
#define RT_CK_WDB(_p)		BU_CKMAG( _p , RT_WDB_MAGIC , "rt_wdb" )
d1271 4
a1274 2
#define RT_CHECK_RTI(_p)	BU_CKMAG(_p, RTI_MAGIC, "struct rt_i")
#define RT_CK_RTI(_p)		BU_CKMAG(_p, RTI_MAGIC, "struct rt_i")
d1538 1
a1538 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.140 1999/11/26 22:29:27 mike Exp $
@


11.140
log
@
Added externs for rt_pmalloc() et.al.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.139 1999/11/26 22:14:00 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.139 1999/11/26 22:14:00 mike Exp $ (BRL)"
d1531 1
a1531 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.139 1999/11/26 22:14:00 mike Exp $
d2016 10
a2025 1
BU_EXTERN(void rt_pr_tree_vls, (struct bu_vls *vls, CONST union tree *tp));
d2028 5
a2032 3
BU_EXTERN(void rt_pr_pt_vls, (struct bu_vls *v, CONST struct rt_i *rtip,
	CONST struct partition *pp));
BU_EXTERN(void bu_logindent_vls, (struct bu_vls	*v));
d2036 1
@


11.139
log
@
Added more function prototypes
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.138 1999/11/26 22:02:37 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.138 1999/11/26 22:02:37 mike Exp $ (BRL)"
d1531 1
a1531 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.138 1999/11/26 22:02:37 mike Exp $
d2068 5
@


11.138
log
@
More lint
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.137 1999/11/26 21:45:42 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.137 1999/11/26 21:45:42 mike Exp $ (BRL)"
d1531 1
a1531 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.137 1999/11/26 21:45:42 mike Exp $
d1985 5
a1989 3
BU_EXTERN(int rt_db_get_internal, (struct rt_db_internal *ip, struct directory *dp,
	struct db_i *dbip, CONST mat_t mat));

@


11.137
log
@
Lint cleanups
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.136 1999/11/26 20:49:46 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.136 1999/11/26 20:49:46 mike Exp $ (BRL)"
d1531 1
a1531 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.136 1999/11/26 20:49:46 mike Exp $
d1984 5
d2097 2
d2100 4
d2107 7
d2126 1
@


11.136
log
@
Added more externs.
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.135 1999/11/24 22:38:42 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.135 1999/11/24 22:38:42 mike Exp $ (BRL)"
d1337 11
d1469 1
a1469 1
			struct rt_db_internal * /*ip*/,
d1531 1
a1531 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.135 1999/11/24 22:38:42 mike Exp $
d1922 1
a1922 1
BU_EXTERN(struct directory *db_lookup,( struct db_i *, CONST char *name, int noisy ) );
d1985 8
@


11.135
log
@
Fixed nasty typo!
@
text
@d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.134 1999/11/24 22:37:41 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.134 1999/11/24 22:37:41 mike Exp $ (BRL)"
d1520 1
a1520 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.134 1999/11/24 22:37:41 mike Exp $
d1777 4
a1780 6
BU_EXTERN(void rt_add_res_stats, (struct rt_i *rtip, struct resource *resp) );
					/* Tally stats into struct rt_i */

/* The matrix math routines */

/* Routines from qmath.h */
d1832 1
d2000 3
d2011 6
@


11.134
log
@
Added comment on include sequencing
@
text
@d33 1
a33 1
 *	#include "externs.h"	/_* OPTIONAL, for defining syscalls */
d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.133 1999/11/19 01:28:04 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.133 1999/11/19 01:28:04 mike Exp $ (BRL)"
d1520 1
a1520 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.133 1999/11/19 01:28:04 mike Exp $
@


11.133
log
@
Added RT_APPLICATION_INIT() macro.
Added 4 new methods to rt_functab:
ft_tclget, ft_tcladjust, ft_tclform, and ft_make
@
text
@d33 1
d45 1
a45 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.132 1999/11/18 03:21:51 mike Exp $
d66 1
a66 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.132 1999/11/18 03:21:51 mike Exp $ (BRL)"
d1520 1
a1520 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.132 1999/11/18 03:21:51 mike Exp $
@


11.132
log
@
Added rt_get_functab_by_label() to table.c
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.131 1999/11/17 04:39:34 mike Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.131 1999/11/17 04:39:34 mike Exp $ (BRL)"
d1145 4
d1466 19
d1519 1
a1519 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.131 1999/11/17 04:39:34 mike Exp $
@


11.131
log
@
Added 3 new fields to rt_functab, in order to better support the TCL
interface to db get and db put.
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.130 1999/11/17 03:44:51 mike Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.130 1999/11/17 03:44:51 mike Exp $ (BRL)"
d1496 1
a1496 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.130 1999/11/17 03:44:51 mike Exp $
d1979 1
@


11.130
log
@
Added "label" field to rt_functab, made it CONST.
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.129 1999/11/17 02:41:27 mike Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.129 1999/11/17 02:41:27 mike Exp $ (BRL)"
d1459 3
d1496 1
a1496 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.129 1999/11/17 02:41:27 mike Exp $
@


11.129
log
@
Added idb_meth and st_meth pointers to allow direct access to per-solid
methods, C++ style.
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.128 1999/11/16 22:31:40 mike Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.128 1999/11/16 22:31:40 mike Exp $ (BRL)"
d152 1
a152 1
	struct rt_functab *idb_meth;		/* for ft_ifree(), etc. */
d380 1
a380 1
	struct rt_functab *st_meth;	/* pointer to per-solid methods */
d1382 2
a1383 1
	char	*ft_name;
d1460 2
a1461 2
extern struct rt_functab rt_functab[];
extern int rt_nfunctab;
d1493 1
a1493 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.128 1999/11/16 22:31:40 mike Exp $
@


11.128
log
@
RT_ARGS has been replaced by BU_ARGS
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.127 1999/11/12 21:19:46 mike Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.127 1999/11/12 21:19:46 mike Exp $ (BRL)"
d150 4
a153 3
	long	idb_magic;
	int	idb_type;		/* ID_xxx */
	genptr_t idb_ptr;
d227 1
a227 2
#define RT_HIT_NORM( _hitp, _stp, _rayp )  { \
	register int _id = (_stp)->st_id; \
d229 2
a230 6
	RT_CHECK_SOLTAB(_stp); \
	if( _id <= 0 || _id > ID_MAXIMUM ) { \
		bu_log("stp=x%x, id=%d. hitp=x%x, rayp=x%x\n", _stp, _id, _hitp, (_hitp)->hit_rayp); \
		rt_bomb("RT_HIT_NORM:  bad st_id");\
	} \
	rt_functab[_id].ft_norm(_hitp, _stp, (_hitp)->hit_rayp); }
d239 1
a239 1
#define RT_HIT_NORMAL( _normal, _hitp, _stp, _rayp, _flipflag )  { \
d241 3
a243 2
	RT_CHECK_SOLTAB(_stp); \
	rt_functab[(_stp)->st_id].ft_norm(_hitp, _stp, (_hitp)->hit_rayp); \
a277 1
	register int _id = (_stp)->st_id; \
d279 3
a281 6
	RT_CHECK_SOLTAB(_stp); \
	if( _id <= 0 || _id > ID_MAXIMUM )  { \
		bu_log("stp=x%x, id=%d.\n", _stp, _id); \
		rt_bomb("RT_CURVE:  bad st_id"); \
	} \
	rt_functab[_id].ft_curve( _curvp, _hitp, _stp ); \
a299 1
	register int _id = (_stp)->st_id; \
d301 3
a303 6
	RT_CHECK_SOLTAB(_stp); \
	if( _id <= 0 || _id > ID_MAXIMUM )  { \
		bu_log("stp=x%x, id=%d.\n", _stp, _id); \
		rt_bomb("RT_UVCOORD:  bad st_id"); \
	} \
	rt_functab[_id].ft_uv( ap, _stp, _hitp, uvp ); }
d380 1
d1381 1
d1461 2
d1492 1
a1492 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.127 1999/11/12 21:19:46 mike Exp $
@


11.127
log
@
Clarified comment on NORMAL calculation
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.126 1999/11/12 20:54:38 mike Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.126 1999/11/12 20:54:38 mike Exp $ (BRL)"
d134 1
d786 1
a786 1
	int		(*ts_region_start_func) RT_ARGS((
d791 1
a791 1
	union tree *	(*ts_region_end_func) RT_ARGS((
d796 1
a796 1
	union tree *	(*ts_leaf_func) RT_ARGS((
d1393 1
a1393 1
	int	(*ft_prep) RT_ARGS((struct soltab * /*stp*/,
d1396 1
a1396 1
	int 	(*ft_shot) RT_ARGS((struct soltab * /*stp*/,
d1400 2
a1401 2
	void	(*ft_print) RT_ARGS((CONST struct soltab * /*stp*/));
	void	(*ft_norm) RT_ARGS((struct hit * /*hitp*/,
d1404 1
a1404 1
	void	(*ft_uv) RT_ARGS((struct application * /*ap*/,
d1408 1
a1408 1
	void	(*ft_curve) RT_ARGS((struct curvature * /*cvp*/,
d1411 1
a1411 1
	int	(*ft_classify) RT_ARGS((
d1416 2
a1417 2
	void	(*ft_free) RT_ARGS((struct soltab * /*stp*/));
	int	(*ft_plot) RT_ARGS((
d1422 1
a1422 1
	void	(*ft_vshot) RT_ARGS((struct soltab * /*stp*/[],
d1427 1
a1427 1
	int	(*ft_tessellate) RT_ARGS((
d1433 1
a1433 1
	int	(*ft_tnurb) RT_ARGS((
d1439 1
a1439 1
	int	(*ft_tessellate) RT_ARGS((
d1445 1
a1445 1
	int	(*ft_tnurb) RT_ARGS((
d1451 1
a1451 1
	int	(*ft_import) RT_ARGS((struct rt_db_internal * /*ip*/,
d1455 1
a1455 1
	int	(*ft_export) RT_ARGS((struct bu_external * /*ep*/,
d1459 2
a1460 2
	void	(*ft_ifree) RT_ARGS((struct rt_db_internal * /*ip*/));
	int	(*ft_describe) RT_ARGS((struct bu_vls * /*str*/,
d1464 1
a1464 1
	int	(*ft_xform) RT_ARGS((struct rt_db_internal * /*op*/,
d1499 1
a1499 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.126 1999/11/12 20:54:38 mike Exp $
d1716 1
a1716 1
RT_EXTERN(struct rt_i *rt_dirbuild, (CONST char *filename, char *buf, int len) );
d1718 4
a1721 4
RT_EXTERN(struct rt_i *rt_new_rti, (struct db_i *dbip));
RT_EXTERN(void rt_free_rti, (struct rt_i *rtip));
RT_EXTERN(void rt_prep, (struct rt_i *rtip) );
RT_EXTERN(void rt_prep_parallel, (struct rt_i *rtip, int ncpu) );
d1723 1
a1723 1
RT_EXTERN(int rt_overlap_quietly, (struct application *ap,
d1727 1
a1727 1
RT_EXTERN(int rt_shootray, (struct application *ap) );
d1729 4
a1732 4
RT_EXTERN(CONST char *	rt_basename, (CONST char *str));
RT_EXTERN(void rt_free_soltab, (struct soltab   *stp));
RT_EXTERN(int rt_gettree, (struct rt_i *rtip, CONST char *node) );
RT_EXTERN(int rt_gettrees, (struct rt_i	*rtip,
d1735 1
a1735 1
RT_EXTERN(void rt_pr_seg, (CONST struct seg *segp) );
d1737 1
a1737 1
RT_EXTERN(void rt_pr_partitions, (CONST struct rt_i *rtip,
d1740 1
a1740 1
RT_EXTERN(struct soltab *rt_find_solid, (CONST struct rt_i *rtip,
d1743 1
a1743 1
RT_EXTERN(char *rt_read_cmd, (FILE *fp) );	/* Read semi-colon terminated line */
d1745 1
a1745 1
RT_EXTERN(int rt_do_cmd, (struct rt_i *rtip, char *lp, struct command_tab *ctp) );
d1747 1
a1747 1
RT_EXTERN(void rt_prep_timer, (void) );
d1749 1
a1749 1
RT_EXTERN(double rt_get_timer, (struct bu_vls *vp, double *elapsed));
d1751 1
a1751 1
RT_EXTERN(double rt_read_timer, (char *str, int len) );
d1753 1
a1753 1
RT_EXTERN(int rt_plot_solid, (FILE *fp, struct rt_i *rtip, struct soltab *stp) );
d1755 2
a1756 2
RT_EXTERN(void rt_clean, (struct rt_i *rtip) );
RT_EXTERN(void rt_add_res_stats, (struct rt_i *rtip, struct resource *resp) );
d1773 1
a1773 1
RT_EXTERN(void rt_boolweave, (struct seg *out_hd, struct seg *in_hd,
d1776 1
a1776 1
RT_EXTERN(int rt_boolfinal, (struct partition *InputHdp,
d1782 1
a1782 1
RT_EXTERN(void rt_grow_boolstack, (struct resource *res) );
d1784 1
a1784 1
RT_EXTERN(int rt_fdiff, (double a, double b) );
d1786 1
a1786 1
RT_EXTERN(double rt_reldiff, (double a, double b) );
d1788 1
a1788 1
RT_EXTERN(void rt_pr_soltab, (CONST struct soltab *stp) );
d1790 1
a1790 1
RT_EXTERN(void rt_pr_region, (CONST struct region *rp) );
d1792 1
a1792 1
RT_EXTERN(void rt_pr_tree, (CONST union tree *tp, int lvl) );
d1794 1
a1794 1
RT_EXTERN(void rt_pr_tree_val, (CONST union tree *tp,
d1797 1
a1797 1
RT_EXTERN(void rt_pr_pt, (CONST struct rt_i *rtip, CONST struct partition *pp) );
d1799 1
a1799 1
RT_EXTERN(void rt_pr_hit, (CONST char *str, CONST struct hit *hitp) );
d1803 2
a1804 2
RT_EXTERN(void rt_get_seg, (struct resource *res) );
RT_EXTERN(void rt_cut_it, (struct rt_i *rtip, int ncpu) );
d1806 1
a1806 1
RT_EXTERN(void rt_pr_cut, (CONST union cutter *cutp, int lvl) );
d1808 1
a1808 1
RT_EXTERN(void rt_fr_cut, (struct rt_i *rtip, union cutter *cutp) );
d1810 1
a1810 1
RT_EXTERN(void rt_region_color_map, (struct region *regp) );
d1812 1
a1812 1
RT_EXTERN(void rt_color_addrec, () );
d1814 1
a1814 1
RT_EXTERN(void rt_cut_extend, (union cutter *cutp, struct soltab *stp) );
d1816 1
a1816 1
RT_EXTERN(int rt_rpp_region, (struct rt_i *rtip, CONST char *reg_name,
d1822 2
a1823 2
RT_EXTERN(struct rt_wdb *wdb_dbopen, (struct db_i *dbip, int mode));
RT_EXTERN(struct rt_wdb *wdb_fopen, (CONST char *filename));
d1826 2
a1827 2
RT_EXTERN(int db_add_anim, (struct db_i *dbip, struct animate *anp, int root) );
RT_EXTERN(int db_do_anim, (struct animate *anp, mat_t stack, mat_t arc,
d1829 2
a1830 2
RT_EXTERN(void db_free_anim, (struct db_i *dbip) );
RT_EXTERN(void db_write_anim, (FILE *fop, struct animate *anp));
d1833 1
a1833 1
RT_EXTERN(void db_add_node_to_full_path, (struct db_full_path *pp,
d1835 1
a1835 1
RT_EXTERN(void db_dup_full_path, (struct db_full_path *newp,
d1837 3
a1839 3
RT_EXTERN(char *db_path_to_string, (CONST struct db_full_path *pp) );
RT_EXTERN(void db_free_full_path, (struct db_full_path *pp) );
RT_EXTERN(void db_region_mat, (mat_t m, CONST struct db_i *dbip,
d1841 1
a1841 1
RT_EXTERN(void db_shader_mat, (mat_t model_to_shader, CONST struct rt_i *rtip,
d1846 1
a1846 1
RT_EXTERN(struct db_i *db_open, ( CONST char *name, CONST char *mode ) );
d1848 1
a1848 1
RT_EXTERN(struct db_i *db_create, ( CONST char *name ) );
d1850 1
a1850 1
RT_EXTERN(void db_close, ( struct db_i *dbip ) );
d1859 1
a1859 1
RT_EXTERN(union record *db_getmrec, ( CONST struct db_i *, CONST struct directory *dp ) );
d1861 1
a1861 1
RT_EXTERN(int db_get, (CONST struct db_i *, CONST struct directory *dp,
d1864 1
a1864 1
RT_EXTERN(int db_put, ( CONST struct db_i *, CONST struct directory *dp, union record *where,
d1868 1
a1868 1
RT_EXTERN(genptr_t db_getmrec, ( CONST struct db_i *, CONST struct directory *dp ) );
d1870 1
a1870 1
RT_EXTERN(int db_get, (CONST struct db_i *, CONST struct directory *dp,
d1873 1
a1873 1
RT_EXTERN(int db_put, ( CONST struct db_i *, CONST struct directory *dp,
d1876 1
a1876 1
RT_EXTERN(int db_get_external, ( struct bu_external *ep,
d1878 1
a1878 1
RT_EXTERN(int db_put_external, ( struct bu_external *ep,
d1880 1
a1880 1
RT_EXTERN(void db_free_external, ( struct bu_external *ep ) );
d1884 1
a1884 1
RT_EXTERN(int db_scan, ( struct db_i *, int (*handler)(), int do_old_matter ) );
d1886 1
a1886 1
RT_EXTERN(void db_conversions, ( struct db_i *, int units ) );
d1889 1
a1889 1
RT_EXTERN(int db_dirhash, (CONST char *str) );
d1891 1
a1891 1
RT_EXTERN(struct directory *db_lookup,( struct db_i *, CONST char *name, int noisy ) );
d1893 1
a1893 1
RT_EXTERN(struct directory *db_diradd, ( struct db_i *, CONST char *name, long laddr,
d1896 3
a1898 3
RT_EXTERN(int db_dirdelete, ( struct db_i *, struct directory *dp ) );
RT_EXTERN(int db_rename, ( struct db_i *, struct directory *, CONST char *newname) );
RT_EXTERN(void db_pr_dir, ( CONST struct db_i *dbip ) );
d1901 2
a1902 2
RT_EXTERN(int db_regexp_match, (CONST char *pattern, CONST char *string));
RT_EXTERN(int db_regexp_match_all, (struct bu_vls *dest, struct db_i *dbip, CONST char *pattern));
d1906 1
a1906 1
RT_EXTERN(int db_alloc, ( struct db_i *, struct directory *dp, int count ) );
d1908 1
a1908 1
RT_EXTERN(int db_grow, ( struct db_i *, struct directory *dp, int count ) );
d1910 1
a1910 1
RT_EXTERN(int db_trunc, ( struct db_i *, struct directory *dp, int count ) );
d1912 1
a1912 1
RT_EXTERN(int db_delrec, ( struct db_i *, struct directory *dp, int recnum ) );
d1914 1
a1914 1
RT_EXTERN(int db_delete, ( struct db_i *, struct directory *dp ) );
d1916 1
a1916 1
RT_EXTERN(int db_zapper, ( struct db_i *, struct directory *dp, int start ) );
d1919 1
a1919 1
RT_EXTERN(struct combined_tree_state *db_new_combined_tree_state,
d1921 1
a1921 1
RT_EXTERN(struct combined_tree_state *db_dup_combined_tree_state,
d1923 1
a1923 1
RT_EXTERN(void db_free_combined_tree_state,
d1925 2
a1926 2
RT_EXTERN(void db_pr_tree_state, (CONST struct db_tree_state *tsp));
RT_EXTERN(void db_pr_combined_tree_state,
d1928 1
a1928 1
RT_EXTERN(int db_apply_state_from_comb, (struct db_tree_state *tsp,
d1930 1
a1930 1
RT_EXTERN(int db_apply_state_from_memb, (struct db_tree_state *tsp,
d1932 1
a1932 1
RT_EXTERN(int db_follow_path_for_state, (struct db_tree_state *tsp,
d1934 1
a1934 1
RT_EXTERN(union tree *db_recurse, (struct db_tree_state	*tsp,
d1937 5
a1941 5
RT_EXTERN(union tree *db_dup_subtree, (CONST union tree	*tp));
RT_EXTERN(void db_free_tree, (union tree *tp));
RT_EXTERN(void db_non_union_push, (union tree *tp));
RT_EXTERN(int db_count_subtree_regions, (CONST union tree *tp));
RT_EXTERN(int db_tally_subtree_regions, (union tree *tp,
d1943 1
a1943 1
RT_EXTERN(int db_walk_tree, (struct db_i *dbip, int argc, CONST char **argv,
d1947 1
a1947 1
RT_EXTERN(int db_path_to_mat, (struct db_i *dbip, struct db_full_path *pathp,
d1949 1
a1949 1
RT_EXTERN(void db_apply_anims, (struct db_full_path *pathp,
d1956 2
a1957 2
RT_EXTERN(unsigned long rt_memalloc, (struct mem_map **pp, unsigned size) );
RT_EXTERN(unsigned long rt_memget, (struct mem_map **pp, unsigned int size,
d1959 8
a1966 8
RT_EXTERN(void rt_memfree, (struct mem_map **pp, unsigned size, unsigned long addr) );
RT_EXTERN(void rt_mempurge, (struct mem_map **pp) );
RT_EXTERN(void rt_memprint, (struct mem_map **pp) );
RT_EXTERN(void rt_memclose,() );

RT_EXTERN(struct bn_vlblock *rt_vlblock_init, () );
RT_EXTERN(void rt_vlblock_free, (struct bn_vlblock *vbp) );
RT_EXTERN(struct bu_list *rt_vlblock_find, (struct bn_vlblock *vbp,
d1970 2
a1971 2
RT_EXTERN(void rt_pr_tree_vls, (struct bu_vls *vls, CONST union tree *tp));
RT_EXTERN(void rt_pr_hit_vls, (struct bu_vls *v, CONST char *str,
d1973 1
a1973 1
RT_EXTERN(void rt_pr_pt_vls, (struct bu_vls *v, CONST struct rt_i *rtip,
d1975 2
a1976 2
RT_EXTERN(void bu_logindent_vls, (struct bu_vls	*v));
RT_EXTERN(void rt_pr_fallback_angle, (struct bu_vls *str, CONST char *prefix,
d1978 1
a1978 1
RT_EXTERN(void rt_find_fallback_angle, (double angles[5], CONST vect_t vec));
d1981 1
a1981 1
RT_EXTERN(int rt_id_solid, (struct bu_external *ep));
d1985 2
a1986 2
RT_EXTERN(void rt_plot_all_bboxes, (FILE *fp, struct rt_i *rtip));
RT_EXTERN(void rt_plot_all_solids, (FILE *fp, struct rt_i *rtip));
d1989 3
a1991 3
RT_EXTERN(struct bn_vlblock *	rt_vlblock_init, () );
RT_EXTERN(void			rt_vlblock_free, (struct bn_vlblock *vbp) );
RT_EXTERN(struct bu_list *	rt_vlblock_find, (struct bn_vlblock *vbp,
d1993 2
a1994 2
RT_EXTERN(void			rt_vlist_cleanup, () );
RT_EXTERN(void			rt_vlist_export, (struct bu_vls *vls,
d1997 1
a1997 1
RT_EXTERN(void			rt_vlist_import, (struct bu_list *hp,
d2000 1
a2000 1
RT_EXTERN(void			rt_plot_vlblock, (FILE *fp,
d2002 1
a2002 1
RT_EXTERN(void			rt_vlist_to_uplot, (FILE *fp,
d2004 1
a2004 1
RT_EXTERN(int			rt_uplot_to_vlist, (struct bn_vlblock *vbp,
d2006 1
a2006 1
RT_EXTERN(void			rt_label_vlist_verts, (struct bn_vlblock *vbp,
d2009 1
a2009 1
RT_EXTERN(int			rt_process_uplot_value,
d2023 9
a2031 9
RT_EXTERN(struct model		*nmg_mm, () );
RT_EXTERN(struct model		*nmg_mmr, () );
RT_EXTERN(struct nmgregion	*nmg_mrsv, (struct model *m) );
RT_EXTERN(struct shell 		*nmg_msv, (struct nmgregion *r_p) );
RT_EXTERN(struct faceuse	*nmg_mf, (struct loopuse *lu1) );
RT_EXTERN(struct loopuse	*nmg_mlv, (long *magic, struct vertex *v, int orientation) );
RT_EXTERN(struct edgeuse	*nmg_me, (struct vertex *v1, struct vertex *v2, struct shell *s) );
RT_EXTERN(struct edgeuse	*nmg_meonvu, (struct vertexuse *vu) );
RT_EXTERN(struct loopuse	*nmg_ml, (struct shell *s) );
d2033 7
a2039 7
RT_EXTERN(int			nmg_kvu, (struct vertexuse *vu) );
RT_EXTERN(int			nmg_kfu, (struct faceuse *fu1) );
RT_EXTERN(int			nmg_klu, (struct loopuse *lu1) );
RT_EXTERN(int			nmg_keu, (struct edgeuse *eu) );
RT_EXTERN(int			nmg_ks, (struct shell *s) );
RT_EXTERN(int			nmg_kr, (struct nmgregion *r) );
RT_EXTERN(void			nmg_km, (struct model *m) );
d2041 9
a2049 9
RT_EXTERN(void			nmg_vertex_gv, (struct vertex *v, CONST point_t pt) );
RT_EXTERN(void			nmg_vertex_g, (struct vertex *v, fastf_t x, fastf_t y, fastf_t z) );
RT_EXTERN(void			nmg_edge_g, (struct edgeuse *eu) );
RT_EXTERN(int			nmg_use_edge_g, (struct edgeuse *eu, long *eg) );
RT_EXTERN(void			nmg_loop_g, (struct loop *l, CONST struct bn_tol *tol) );
RT_EXTERN(void			nmg_face_g, (struct faceuse *fu, CONST plane_t p) );
RT_EXTERN(void			nmg_face_bb, (struct face *f, CONST struct bn_tol *tol) );
RT_EXTERN(void			nmg_shell_a, (struct shell *s, CONST struct bn_tol *tol) );
RT_EXTERN(void			nmg_region_a, (struct nmgregion *r, CONST struct bn_tol *tol) );
d2051 2
a2052 2
RT_EXTERN(int			nmg_demote_lu, (struct loopuse *lu) );
RT_EXTERN(int			nmg_demote_eu, (struct edgeuse *eu) );
d2054 1
a2054 1
RT_EXTERN(void			nmg_movevu, (struct vertexuse *vu, struct vertex *v) );
d2056 4
a2059 4
RT_EXTERN(void			nmg_je, (struct edgeuse *eudst, struct edgeuse *eusrc) );
RT_EXTERN(void			nmg_unglueedge, (struct edgeuse *eu) );
RT_EXTERN(void			nmg_jv, (struct vertex *v1, struct vertex *v2) );
RT_EXTERN(void			nmg_jeg, (struct edge_g_lseg *dest_eg,
d2064 3
a2066 3
RT_EXTERN(int			nmg_simplify_shell, (struct shell *s) );
RT_EXTERN(void			nmg_rm_redundancies, (struct shell *s, CONST struct bn_tol *tol ) );
RT_EXTERN(void			nmg_sanitize_s_lv, (struct shell *s,
d2068 1
a2068 1
RT_EXTERN(void			nmg_s_split_touchingloops, (struct shell *s,
d2071 8
a2078 8
RT_EXTERN(struct faceuse	*nmg_cmface, (struct shell *s, struct vertex **vt[], int n) );
RT_EXTERN(struct faceuse	*nmg_cface, (struct shell *s, struct vertex **vt,	int n) );
RT_EXTERN(struct faceuse	*nmg_add_loop_to_face, (struct shell *s, struct faceuse *fu, struct vertex **verts, int n, int dir) );
RT_EXTERN(int			nmg_fu_planeeqn, (struct faceuse *fu, CONST struct bn_tol *tol) );
RT_EXTERN(void			nmg_gluefaces, (struct faceuse *fulist[], int n, CONST struct bn_tol *tol) );
RT_EXTERN(int			nmg_simplify_face, (struct faceuse *fu) );
RT_EXTERN(void			nmg_reverse_face, (struct faceuse *fu) );
RT_EXTERN(void			nmg_mv_fu_between_shells, (struct shell *dest,
d2080 1
a2080 1
RT_EXTERN(void			nmg_jf, (struct faceuse *dest_fu,
d2082 1
a2082 1
RT_EXTERN(struct faceuse	*nmg_dup_face, (struct faceuse *fu, struct shell *s) );
d2084 7
a2090 7
RT_EXTERN(void			nmg_jl, (struct loopuse *lu, struct edgeuse *eu) );
RT_EXTERN(struct vertexuse	*nmg_join_2loops, (struct vertexuse *vu1, struct vertexuse *vu2) );
RT_EXTERN(struct vertexuse	*nmg_join_singvu_loop, (struct vertexuse *vu1, struct vertexuse *vu2) );
RT_EXTERN(struct vertexuse	*nmg_join_2singvu_loops, (struct vertexuse *vu1, struct vertexuse *vu2) );
RT_EXTERN(struct loopuse	*nmg_cut_loop, (struct vertexuse *vu1, struct vertexuse *vu2) );
RT_EXTERN(struct loopuse	*nmg_split_lu_at_vu, (struct loopuse *lu, struct vertexuse *vu) );
RT_EXTERN(void			nmg_split_touchingloops, (struct loopuse *lu,
d2092 4
a2095 4
RT_EXTERN(int			nmg_join_touchingloops, (struct loopuse *lu) );
RT_EXTERN(void			nmg_simplify_loop, (struct loopuse *lu) );
RT_EXTERN(int			nmg_kill_snakes, (struct loopuse *lu) );
RT_EXTERN(void			nmg_mv_lu_between_shells, (struct shell *dest,
d2097 2
a2098 2
RT_EXTERN(void	 		nmg_moveltof, (struct faceuse *fu, struct shell *s) );
RT_EXTERN(struct loopuse	*nmg_dup_loop, (struct loopuse *lu,
d2100 2
a2101 2
RT_EXTERN(void			nmg_set_lu_orientation, (struct loopuse *lu, int is_opposite) );
RT_EXTERN(void			nmg_lu_reorient, (struct loopuse *lu ) );
d2103 4
a2106 4
RT_EXTERN(struct edgeuse	*nmg_eusplit, (struct vertex *v, struct edgeuse *oldeu, int share_geom) );
RT_EXTERN(struct edgeuse	*nmg_esplit, (struct vertex *v, struct edgeuse *eu, int share_geom) );
RT_EXTERN(struct edgeuse	*nmg_ebreak, (struct vertex *v, struct edgeuse *eu));
RT_EXTERN(struct edgeuse	*nmg_ebreaker, (struct vertex *v,
d2108 3
a2110 3
RT_EXTERN(struct vertex		*nmg_e2break, (struct edgeuse *eu1, struct edgeuse *eu2) );
RT_EXTERN(struct edgeuse	*nmg_eins, (struct edgeuse *eu) );
RT_EXTERN(void			nmg_mv_eu_between_shells, (struct shell *dest,
d2113 1
a2113 1
RT_EXTERN(void			nmg_mv_vu_between_shells, (struct shell *dest,
d2118 2
a2119 2
RT_EXTERN(struct model		*nmg_find_model, (CONST long *magic_p) );
RT_EXTERN(void			nmg_model_bb, (point_t min_pt, point_t max_pt, CONST struct model *m) );
d2123 4
a2126 4
RT_EXTERN(int			nmg_shell_is_empty, (CONST struct shell *s) );
RT_EXTERN(struct shell		*nmg_find_s_of_lu, (CONST struct loopuse *lu) );
RT_EXTERN(struct shell		*nmg_find_s_of_eu, (CONST struct edgeuse *eu) );
RT_EXTERN(struct shell		*nmg_find_s_of_vu, (CONST struct vertexuse *vu) );
d2129 4
a2132 4
RT_EXTERN(struct faceuse	*nmg_find_fu_of_eu, (CONST struct edgeuse *eu));
RT_EXTERN(struct faceuse	*nmg_find_fu_of_lu, (CONST struct loopuse *lu));
RT_EXTERN(struct faceuse	*nmg_find_fu_of_vu, (CONST struct vertexuse *vu) );
RT_EXTERN(struct faceuse	*nmg_find_fu_with_fg_in_s, (CONST struct shell *s1,
d2134 1
a2134 1
RT_EXTERN(double		nmg_measure_fu_angle, (CONST struct edgeuse *eu,
d2139 3
a2141 3
RT_EXTERN(struct loopuse	*nmg_find_lu_of_vu, (CONST struct vertexuse *vu) );
RT_EXTERN(int			nmg_loop_is_a_crack, (CONST struct loopuse *lu) );
RT_EXTERN(int			nmg_loop_is_ccw, (CONST struct loopuse *lu,
d2143 2
a2144 2
RT_EXTERN(CONST struct vertexuse *nmg_loop_touches_self, (CONST struct loopuse *lu));
RT_EXTERN(int			nmg_2lu_identical, (CONST struct edgeuse *eu1,
d2148 1
a2148 1
RT_EXTERN(struct edgeuse	*nmg_findeu, (CONST struct vertex *v1, CONST struct vertex *v2,
d2151 1
a2151 1
RT_EXTERN(struct edgeuse	*nmg_find_eu_in_face, (CONST struct vertex *v1,
d2154 1
a2154 1
RT_EXTERN(struct edgeuse	*nmg_find_e, (CONST struct vertex *v1,
d2158 2
a2159 2
RT_EXTERN(struct edgeuse	*nmg_find_eu_of_vu, (CONST struct vertexuse *vu) );
RT_EXTERN(struct edgeuse	*nmg_find_eu_with_vu_in_lu, (CONST struct loopuse *lu,
d2161 3
a2163 3
RT_EXTERN(CONST struct edgeuse	*nmg_faceradial, (CONST struct edgeuse *eu) );
RT_EXTERN(CONST struct edgeuse	*nmg_radial_face_edge_in_shell, (CONST struct edgeuse *eu) );
RT_EXTERN(CONST struct edgeuse *nmg_find_edge_between_2fu, (CONST struct faceuse *fu1,
d2165 1
a2165 1
RT_EXTERN(struct edge		*nmg_find_e_nearest_pt2, (long *magic_p,
d2168 1
a2168 1
RT_EXTERN(struct edgeuse	*nmg_find_matching_eu_in_s, (
d2170 1
a2170 1
RT_EXTERN(void			nmg_eu_2vecs_perp, (vect_t xvec, vect_t yvec,
d2173 1
a2173 1
RT_EXTERN(int			nmg_find_eu_leftvec, (vect_t left,
d2177 1
a2177 1
RT_EXTERN(struct vertexuse	*nmg_find_v_in_face, (CONST struct vertex *,
d2179 1
a2179 1
RT_EXTERN(struct vertexuse	*nmg_find_v_in_shell, (CONST struct vertex *v,
d2181 1
a2181 1
RT_EXTERN(struct vertexuse	*nmg_find_pt_in_lu, (CONST struct loopuse *lu,
d2183 1
a2183 1
RT_EXTERN(struct vertexuse	*nmg_find_pt_in_face, (CONST struct faceuse *fu,
d2186 1
a2186 1
RT_EXTERN(struct vertex		*nmg_find_pt_in_shell, (CONST struct shell *s,
d2188 1
a2188 1
RT_EXTERN(struct vertex		*nmg_find_pt_in_model, (CONST struct model *m,
d2190 1
a2190 1
RT_EXTERN(int			nmg_is_vertex_in_edgelist, (CONST struct vertex *v,
d2192 1
a2192 1
RT_EXTERN(int			nmg_is_vertex_in_looplist, (CONST struct vertex *v,
d2194 1
a2194 1
RT_EXTERN(int			nmg_is_vertex_a_selfloop_in_shell, (CONST struct vertex *v,
d2196 1
a2196 1
RT_EXTERN(int			nmg_is_vertex_in_facelist, (CONST struct vertex *v,
d2198 1
a2198 1
RT_EXTERN(int			nmg_is_edge_in_edgelist, (CONST struct edge *e,
d2200 1
a2200 1
RT_EXTERN(int			nmg_is_edge_in_looplist, (CONST struct edge *e,
d2202 1
a2202 1
RT_EXTERN(int			nmg_is_edge_in_facelist, (CONST struct edge *e,
d2204 1
a2204 1
RT_EXTERN(int			nmg_is_loop_in_facelist, (CONST struct loop *l,
d2207 1
a2207 1
RT_EXTERN(void			nmg_edgeuse_tabulate, (struct bu_ptbl *tab,
d2209 1
a2209 1
RT_EXTERN(void			nmg_vertex_tabulate, (struct bu_ptbl *tab,
d2211 1
a2211 1
RT_EXTERN(void			nmg_face_tabulate, (struct bu_ptbl *tab,
d2215 24
a2238 24
RT_EXTERN(char *		nmg_orientation, (int orientation) );
RT_EXTERN(void			nmg_pr_orient, (int orientation, CONST char *h) );
RT_EXTERN(void			nmg_pr_m, (CONST struct model *m) );
RT_EXTERN(void			nmg_pr_r, (CONST struct nmgregion *r, char *h) );
RT_EXTERN(void			nmg_pr_sa, (CONST struct shell_a *sa, char *h) );
RT_EXTERN(void			nmg_pr_lg, (CONST struct loop_g *lg, char *h) );
RT_EXTERN(void			nmg_pr_fg, (CONST long *magic, char *h) );
RT_EXTERN(void			nmg_pr_s, (CONST struct shell *s, char *h) );
RT_EXTERN(void			nmg_pr_f, (CONST struct face *f, char *h) );
RT_EXTERN(void			nmg_pr_fu, (CONST struct faceuse *fu, char *h) );
RT_EXTERN(void			nmg_pr_fu_briefly, (CONST struct faceuse *fu,	char *h) );
RT_EXTERN(void			nmg_pr_l, (CONST struct loop *l, char *h) );
RT_EXTERN(void			nmg_pr_lu, (CONST struct loopuse *lu, char *h) );
RT_EXTERN(void			nmg_pr_lu_briefly, (CONST struct loopuse *lu, char *h) );
RT_EXTERN(void			nmg_pr_eg, (CONST long *eg, char *h) );
RT_EXTERN(void			nmg_pr_e, (CONST struct edge *e, char *h) );
RT_EXTERN(void			nmg_pr_eu, (CONST struct edgeuse *eu, char *h) );
RT_EXTERN(void			nmg_pr_eu_briefly, (CONST struct edgeuse *eu, char *h) );
RT_EXTERN(void			nmg_pr_vg, (CONST struct vertex_g *vg, char *h) );
RT_EXTERN(void			nmg_pr_v, (CONST struct vertex *v, char *h) );
RT_EXTERN(void			nmg_pr_vu, (CONST struct vertexuse *vu, char *h) );
RT_EXTERN(void			nmg_pr_vu_briefly, (CONST struct vertexuse *vu, char *h) );
RT_EXTERN(void			nmg_pr_vua, (CONST long *magic_p, char *h) );
RT_EXTERN(void			nmg_euprint, (CONST char *str, CONST struct edgeuse *eu) );
d2241 6
a2246 6
RT_EXTERN(int			bu_ptbl, (struct bu_ptbl *b, int func, long *p) );
RT_EXTERN(void			nmg_purge_unwanted_intersection_points, (struct bu_ptbl *vert_list, fastf_t *mag, CONST struct faceuse *fu, CONST struct bn_tol *tol));
RT_EXTERN(int			nmg_in_or_ref, (struct vertexuse *vu, struct bu_ptbl *b) );
RT_EXTERN(void			nmg_rebound, (struct model *m, CONST struct bn_tol *tol) );
RT_EXTERN(void			nmg_count_shell_kids, (CONST struct model *m, unsigned long *total_wires, unsigned long *total_faces, unsigned long *total_points));
RT_EXTERN(void			nmg_stash_model_to_file, (CONST char *filename,
d2250 2
a2251 2
RT_EXTERN(void			nmg_triangulate_model, (struct model *m, CONST struct bn_tol   *tol) );
RT_EXTERN(void			nmg_triangulate_fu, (struct faceuse *fu, CONST struct bn_tol   *tol) );
d2254 1
a2254 1
RT_EXTERN(int			nmg_dangling_face, (CONST struct faceuse *fu,
d2260 2
a2261 2
RT_EXTERN(char 			*nmg_shell_manifolds, (struct shell *sp, char *tbl) );
RT_EXTERN(char	 		*nmg_manifolds, (struct model *m) );
d2266 1
a2266 1
RT_EXTERN(int			nmg_class_pt_f, (CONST point_t pt,
d2269 1
a2269 1
RT_EXTERN(int			nmg_class_pt_s, (CONST point_t pt,
d2275 1
a2275 1
RT_EXTERN(int			nmg_class_pt_fu_except, (CONST point_t pt,
d2286 1
a2286 1
RT_EXTERN(void			nmg_pl_v, (FILE	*fp, CONST struct vertex *v,
d2288 1
a2288 1
RT_EXTERN(void			nmg_pl_e, (FILE *fp, CONST struct edge *e,
d2290 1
a2290 1
RT_EXTERN(void			nmg_pl_eu, (FILE *fp, CONST struct edgeuse *eu,
d2292 1
a2292 1
RT_EXTERN(void			nmg_pl_lu, (FILE *fp, CONST struct loopuse *fu, 
d2294 1
a2294 1
RT_EXTERN(void			nmg_pl_fu, (FILE *fp, CONST struct faceuse *fu,
d2296 4
a2299 4
RT_EXTERN(void			nmg_pl_s, (FILE *fp, CONST struct shell *s) );
RT_EXTERN(void			nmg_pl_r, (FILE *fp, CONST struct nmgregion *r) );
RT_EXTERN(void			nmg_pl_m, (FILE *fp, CONST struct model *m) );
RT_EXTERN(void			nmg_vlblock_v, (struct bn_vlblock *vbp,
d2301 1
a2301 1
RT_EXTERN(void			nmg_vlblock_e, (struct bn_vlblock *vbp,
d2304 1
a2304 1
RT_EXTERN(void			nmg_vlblock_eu, (struct bn_vlblock *vbp,
d2308 1
a2308 1
RT_EXTERN(void			nmg_vlblock_lu, (struct bn_vlblock *vbp,
d2312 1
a2312 1
RT_EXTERN(void			nmg_vlblock_fu, (struct bn_vlblock *vbp,
d2314 1
a2314 1
RT_EXTERN(void			nmg_vlblock_s, (struct bn_vlblock *vbp,
d2316 1
a2316 1
RT_EXTERN(void			nmg_vlblock_r, (struct bn_vlblock *vbp,
d2318 1
a2318 1
RT_EXTERN(void			nmg_vlblock_m, (struct bn_vlblock *vbp,
d2320 1
a2320 1
RT_EXTERN(void			nmg_pl_around_edge, (FILE *fd,
d2322 1
a2322 1
RT_EXTERN(void			nmg_pl_isect, (CONST char *filename,
d2324 1
a2324 1
RT_EXTERN(void			nmg_pl_comb_fu, (int num1, int num2,
d2326 1
a2326 1
RT_EXTERN(void			nmg_pl_2fu, (CONST char *str, int num,
d2329 2
a2330 2
RT_EXTERN(void			nmg_face_plot, (CONST struct faceuse *fu) );
RT_EXTERN(void			nmg_2face_plot, (CONST struct faceuse *fu1,
d2332 1
a2332 1
RT_EXTERN(void			nmg_face_lu_plot, (CONST struct loopuse *lu,
d2334 1
a2334 1
RT_EXTERN(void			nmg_cnurb_to_vlist, (struct bu_list *vhead,
d2340 1
a2340 1
RT_EXTERN(void			nmg_radial_join_eu, (struct edgeuse *eu1,
d2342 1
a2342 1
RT_EXTERN(void			nmg_mesh_faces, (struct faceuse *fu1,
d2344 1
a2344 1
RT_EXTERN(int			nmg_mesh_face_shell, (struct faceuse *fu1,
d2346 1
a2346 1
RT_EXTERN(int			nmg_mesh_shell_shell, (struct shell *s1,
d2348 1
a2348 1
RT_EXTERN(double		nmg_measure_fu_angle, (CONST struct edgeuse *eu,
d2353 1
a2353 1
RT_EXTERN(struct nmgregion	*nmg_do_bool, (struct nmgregion *s1,
d2356 1
a2356 1
RT_EXTERN(void			nmg_shell_coplanar_face_merge,
d2359 1
a2359 1
RT_EXTERN(int			nmg_two_region_vertex_fuse, (struct nmgregion *r1,
d2361 1
a2361 1
RT_EXTERN(union tree		*nmg_booltree_leaf_tess, (struct db_tree_state *tsp,
d2364 1
a2364 1
RT_EXTERN(union tree		*nmg_booltree_leaf_tnurb, (struct db_tree_state *tsp,
d2367 1
a2367 1
RT_EXTERN(union tree		*nmg_booltree_evaluate, (union tree *tp,
d2369 1
a2369 1
RT_EXTERN(void			nmg_region_v_unique, (struct nmgregion *r1,
d2373 1
a2373 1
RT_EXTERN(void			nmg_class_shells, (struct shell *sA,
d2378 1
a2378 1
RT_EXTERN(void			nmg_set_lu_orientation, (struct loopuse	*lu,
d2381 1
a2381 1
RT_EXTERN(double		nmg_vu_angle_measure, (struct vertexuse	*vu,
d2384 1
a2384 1
RT_EXTERN(struct edge_g_lseg	*nmg_face_cutjoin, (
d2395 1
a2395 1
RT_EXTERN(CONST char		*nmg_class_name, (int class_no) );
d2398 1
a2398 1
RT_EXTERN(void			nmg_eval_shell, (struct shell *s,
d2400 1
a2400 1
RT_EXTERN(void			nmg_eval_plot, (struct nmg_bool_state *bs,
d2407 1
a2407 1
RT_EXTERN(void nmg_isect_ray_model, (struct ray_data *rd) );
d2410 1
a2410 1
RT_EXTERN(int			nmg_ray_isect_segs, (struct soltab *stp,
d2418 1
a2418 1
RT_EXTERN(void			nmg_ck_list_magic, (CONST struct bu_list *hd,
d2420 6
a2425 6
RT_EXTERN(void			nmg_ck_list, (struct bu_list *hd, CONST char *str) );
RT_EXTERN(void			nmg_ck_lueu, (struct loopuse *lu, char *s) );
RT_EXTERN(int			nmg_check_radial, (CONST struct edgeuse *eu, CONST struct bn_tol *tol));
RT_EXTERN(int			nmg_ck_closed_surf, (CONST struct shell *s, CONST struct bn_tol *tol) );
RT_EXTERN(int			nmg_ck_closed_region, (CONST struct nmgregion *r, CONST struct bn_tol *tol) );
RT_EXTERN(void			nmg_ck_v_in_2fus, (CONST struct vertex *vp,
d2430 1
a2430 1
RT_EXTERN(void			nmg_crackshells, (struct shell *s1, struct shell *s2, CONST struct bn_tol *tol) );
d2433 3
a2435 3
RT_EXTERN(int			nmg_index_of_struct, (long *p) );
RT_EXTERN(void			nmg_m_reindex, (struct model *m, long newindex) );
RT_EXTERN(void			nmg_vls_struct_counts, (struct bu_vls *str,
d2437 1
a2437 1
RT_EXTERN(void			nmg_pr_struct_counts, 
d2440 1
a2440 1
RT_EXTERN(long			**nmg_m_struct_count,
d2443 1
a2443 1
RT_EXTERN(void			nmg_merge_models, (struct model *m1,
d2448 1
a2448 1
RT_EXTERN(void			rt_dspline_matrix, (mat_t m,CONST char *type,
d2451 1
a2451 1
RT_EXTERN(double		rt_dspline4, (mat_t m, double a, double b,
d2453 1
a2453 1
RT_EXTERN(void			rt_dspline4v, (double *pt, CONST mat_t m,
d2457 1
a2457 1
RT_EXTERN(void			rt_dspline_n, (double *r, CONST mat_t m,
@


11.126
log
@
Changed from pt_solids_hit to pt_seglist; more general.
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.125 1999/11/11 04:18:41 mike Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.125 1999/11/11 04:18:41 mike Exp $ (BRL)"
d236 5
a240 2
 *  New macro:  Leave _hitp undisturbed, return post-boolean normal into
 *  caller-provided point.
d1498 1
a1498 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.125 1999/11/11 04:18:41 mike Exp $
@


11.125
log
@
Added rt_default_multioverlap() routine, and matching a_multioverlap()
in application structure.
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.124 1999/11/08 15:22:23 jra Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.124 1999/11/08 15:22:23 jra Exp $ (BRL)"
d512 1
a512 1
	struct bu_ptbl	pt_solids_hit;		/* all segs in this partition */
d525 1
a525 1
#define RT_PT_MIDDLE_END	pt_solids_hit.l.magic	/* copy up to this elem (non-inclusive) */
d532 1
a532 1
	bu_ptbl_cat( &(new)->pt_solids_hit, &(old)->pt_solids_hit );  }
d542 1
a542 1
		bu_ptbl_reset( &(p)->pt_solids_hit ); \
d546 1
a546 1
		bu_ptbl_init( &(p)->pt_solids_hit, 42, "pt_solids_hit ptbl" ); \
d1495 1
a1495 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.124 1999/11/08 15:22:23 jra Exp $
@


11.124
log
@
Added BOT solid.
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.123 1999/11/02 02:40:27 mike Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.123 1999/11/02 02:40:27 mike Exp $ (BRL)"
d520 1
d1073 2
a1074 1
 *	a_overlap()	If non-null, this routine will be called to
d1078 4
a1081 1
 *			Return of !0 retains one (random) partition in output
d1117 2
a1118 1
	int		(*a_overlap)();	/* called when overlaps occur */
d1150 1
d1495 1
a1495 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.123 1999/11/02 02:40:27 mike Exp $
@


11.123
log
@
Added ray bundle index variable
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.122 1999/10/30 03:52:19 mike Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.122 1999/10/30 03:52:19 mike Exp $ (BRL)"
a443 2

#if 0
a445 4
#else
/* XXX Temporarily changing back to 29 until "Bag o' triangles is completed */
#define ID_MAXIMUM	29	/* Maximum defined ID_xxx value */
#endif
d1488 1
a1488 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.122 1999/10/30 03:52:19 mike Exp $
@


11.122
log
@Added magic numbers for ray, hit, and application structures.
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.121 1999/10/29 17:23:49 bparker Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.121 1999/10/29 17:23:49 bparker Exp $ (BRL)"
d182 1
d1494 1
a1494 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.121 1999/10/29 17:23:49 bparker Exp $
@


11.121
log
@*- modify the rt_process_uplot_value declaration
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.120 1999/10/28 17:44:40 bparker Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.120 1999/10/28 17:44:40 bparker Exp $ (BRL)"
d181 1
d188 2
a189 1

d204 1
d214 2
d226 1
d239 1
d277 1
d303 1
d339 1
d1056 1
d1106 1
d1147 2
d1493 1
a1493 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.120 1999/10/28 17:44:40 bparker Exp $
@


11.120
log
@*- for the moment change ID_MAXIMUM back
   to 29 until "Bag o' triangles is completed
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.119 1999/10/28 03:33:30 mike Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.119 1999/10/28 03:33:30 mike Exp $ (BRL)"
d1479 1
a1479 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.119 1999/10/28 03:33:30 mike Exp $
d1990 1
a1990 1
				(struct bu_list *vhead, struct bn_vlblock *vbp,
@


11.119
log
@
Added hit_rayp
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.118 1999/10/19 20:51:27 jra Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.118 1999/10/19 20:51:27 jra Exp $ (BRL)"
d433 2
a435 1

d437 4
d1479 1
a1479 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.118 1999/10/19 20:51:27 jra Exp $
@


11.118
log
@Added basics for "Bag O' Triangles".
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.117 1999/10/12 13:58:12 jra Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.117 1999/10/12 13:58:12 jra Exp $ (BRL)"
d208 1
d223 1
a223 1
		bu_log("stp=x%x, id=%d. hitp=x%x, rayp=x%x\n", _stp, _id, _hitp, _rayp); \
d226 1
a226 1
	rt_functab[_id].ft_norm(_hitp, _stp, _rayp); }
d234 1
a234 1
	rt_functab[(_stp)->st_id].ft_norm(_hitp, _stp, _rayp); \
d1474 1
a1474 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.117 1999/10/12 13:58:12 jra Exp $
@


11.117
log
@Added fgp solid (FastGen Plate mode)
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.116 1999/08/16 14:46:59 bparker Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.116 1999/08/16 14:46:59 bparker Exp $ (BRL)"
d432 1
d434 1
a434 1
#define ID_MAXIMUM	29	/* Maximum defined ID_xxx value */
d1473 1
a1473 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.116 1999/08/16 14:46:59 bparker Exp $
@


11.116
log
@*- add declaration for rt_process_uplot_value()
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.115 1999/07/14 02:15:21 mike Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.115 1999/07/14 02:15:21 mike Exp $ (BRL)"
d431 1
d433 1
a433 1
#define ID_MAXIMUM	28	/* Maximum defined ID_xxx value */
d1472 1
a1472 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.115 1999/07/14 02:15:21 mike Exp $
@


11.115
log
@
Commented
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.114 1999/06/03 02:10:30 mike Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.114 1999/06/03 02:10:30 mike Exp $ (BRL)"
d1471 1
a1471 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.114 1999/06/03 02:10:30 mike Exp $
d1981 3
@


11.114
log
@
sed4
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.113 1999/06/03 01:11:06 mike Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.113 1999/06/03 01:11:06 mike Exp $ (BRL)"
d499 1
a499 1
	struct bu_ptbl	pt_solids_hit;
d1471 1
a1471 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.113 1999/06/03 01:11:06 mike Exp $
@


11.113
log
@
rt_assoc() became bu_association().  Nobody uses it.
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.112 1999/05/27 20:10:33 mike Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.112 1999/05/27 20:10:33 mike Exp $ (BRL)"
d719 2
a720 2
	struct rt_vls	shader;
	struct rt_vls	material;
d1081 1
a1081 1
 *  rt_calloc( 1, sizeof(struct application), "application" );
d1142 1
a1142 1
	struct bu_list	rtg_vlfree;	/* head of rt_vlist freelist */
d1471 1
a1471 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.112 1999/05/27 20:10:33 mike Exp $
d1516 1
a1516 1
	struct rt_list	l;
d1540 1
a1540 1
		rt_log("%s[%d]: struct hitmiss has  NMG_MISS_LIST magic #\n",\
d1544 1
a1544 1
		rt_log("%s[%d]: struct hitmiss has  NMG_MISS_LIST magic #\n",\
d1548 1
a1548 1
		rt_log("%s[%d]: bad struct hitmiss magic: %d:(0x%08x)\n", \
d1553 1
a1553 1
		rt_log("%s[%d]: NULL hit_private in hitmiss struct\n", \
d1560 2
a1561 2
    for (RT_LIST_FOR(a_hit, hitmiss, &rd->rd_hit)){NMG_CK_HITMISS(a_hit);} \
    for (RT_LIST_FOR(a_hit, hitmiss, &rd->rd_miss)){NMG_CK_HITMISS(a_hit);} }
d1597 1
a1597 1
	struct rt_tol		*tol;
d1599 2
a1600 2
	struct rt_list	rd_hit;		/* list of hit elements */
	struct rt_list	rd_miss;	/* list of missed/sub-hit elements */
d1635 1
a1635 1
		(_p) = (struct hitmiss *)rt_calloc(1, sizeof( struct hitmiss ), "hitmiss" ); \
d1648 1
a1648 1
	(_p) = (struct hitmiss *)rt_calloc(1, sizeof(struct hitmiss), str); \
d1654 1
a1654 1
	(void)rt_free( (char *)_p,  str); \
d1659 1
a1659 1
	while ( RT_LIST_WHILE(_hit, hitmiss, _p)) { \
d1661 1
a1661 1
		RT_LIST_DEQUEUE( &_hit->l ); \
d1672 1
a1672 1
	rt_log("%s", str); \
d1674 2
a1675 2
	RT_LIST_INIT(&rd->rd_hit); \
	RT_LIST_INIT(&rd->rd_miss); \
@


11.112
log
@
Moved vlist and vlblock from raytrace.h to bn.h
(can't be bu.h because it uses vmath.h)
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.111 1999/05/10 21:27:51 mike Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.111 1999/05/10 21:27:51 mike Exp $ (BRL)"
d1471 1
a1471 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.111 1999/05/10 21:27:51 mike Exp $
a1939 3

/* rtassoc.c */
RT_EXTERN(struct bu_vls *rt_assoc, (char *fname, char *value, int field_sep));
@


11.111
log
@Name change to reflect actual purpose of the variable.
ma_override to ma_color_valid
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.110 1999/05/10 15:49:49 mike Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.110 1999/05/10 15:49:49 mike Exp $ (BRL)"
a1263 46
 *			R T _ V L I S T
 *
 *  Definitions for handling lists of vectors (really verticies, or points)
 *  and polygons in 3-space.
 *  Intented for common handling of wireframe display information,
 *  in the full resolution that is calculated in.
 *
 *  On 32-bit machines, RT_VLIST_CHUNK of 35 results in rt_vlist structures
 *  just less than 1k bytes.
 *
 *  The head of the doubly linked list can be just a "struct bu_list" head.
 *
 *  To visit all the elements in the vlist:
 *	for( BU_LIST_FOR( vp, rt_vlist, hp ) )  {
 *		register int	i;
 *		register int	nused = vp->nused;
 *		register int	*cmd = vp->cmd;
 *		register point_t *pt = vp->pt;
 *		for( i = 0; i < nused; i++,cmd++,pt++ )  {
 *			access( *cmd, *pt );
 *			access( vp->cmd[i], vp->pt[i] );
 *		}
 *	}
 */
#define RT_VLIST_CHUNK	35		/* 32-bit mach => just less than 1k */
struct rt_vlist  {
	struct bu_list	l;			/* magic, forw, back */
	int		nused;			/* elements 0..nused active */
	int		cmd[RT_VLIST_CHUNK];	/* VL_CMD_* */
	point_t		pt[RT_VLIST_CHUNK];	/* associated 3-point/vect */
};
#define RT_VLIST_NULL	((struct rt_vlist *)0)
#define RT_VLIST_MAGIC	0x98237474
#define RT_CK_VLIST(_p) BU_CKMAG((_p), RT_VLIST_MAGIC, "rt_vlist")

/* Values for cmd[] */
#define RT_VLIST_LINE_MOVE	0
#define RT_VLIST_LINE_DRAW	1
#define RT_VLIST_POLY_START	2	/* pt[] has surface normal */
#define RT_VLIST_POLY_MOVE	3	/* move to first poly vertex */
#define RT_VLIST_POLY_DRAW	4	/* subsequent poly vertex */
#define RT_VLIST_POLY_END	5	/* last vert (repeats 1st), draw poly */
#define RT_VLIST_POLY_VERTNORM	6	/* per-vertex normal, for interpoloation */

/* XXX Note that RT_GET_VLIST and RT_FREE_VLIST are non-PARALLEL */
/*
d1267 2
d1270 4
a1273 10
#define RT_GET_VLIST(p) {\
		(p) = BU_LIST_FIRST( rt_vlist, &rt_g.rtg_vlfree ); \
		if( BU_LIST_IS_HEAD( (p), &rt_g.rtg_vlfree ) )  { \
			(p) = (struct rt_vlist *)rt_malloc(sizeof(struct rt_vlist), "rt_vlist"); \
			(p)->l.magic = RT_VLIST_MAGIC; \
		} else { \
			BU_LIST_DEQUEUE( &((p)->l) ); \
		} \
		(p)->nused = 0; \
	}
d1275 1
a1275 5
/* Place an entire chain of rt_vlist structs on the global freelist */
#define RT_FREE_VLIST(hd)	{ \
	BU_CK_LIST_HEAD( (hd) ); \
	BU_LIST_APPEND_LIST( &rt_g.rtg_vlfree, (hd) ); \
	}
a1276 11
#define RT_ADD_VLIST(hd,pnt,draw)  { \
	register struct rt_vlist *_vp; \
	BU_CK_LIST_HEAD( hd ); \
	_vp = BU_LIST_LAST( rt_vlist, (hd) ); \
	if( BU_LIST_IS_HEAD( _vp, (hd) ) || _vp->nused >= RT_VLIST_CHUNK )  { \
		RT_GET_VLIST(_vp); \
		BU_LIST_INSERT( (hd), &(_vp->l) ); \
	} \
	VMOVE( _vp->pt[_vp->nused], (pnt) ); \
	_vp->cmd[_vp->nused++] = (draw); \
	}
a1277 1
/* Macro BU_CK_LIST_HEAD() is defined in rtlist.h */
a1278 10
/* For NMG plotting, a way of separating vlists into colorer parts */
struct rt_vlblock {
	long		magic;
	int		nused;
	int		max;
	long		*rgb;		/* rgb[max] */
	struct bu_list	*head;		/* head[max] */
};
#define RT_VLBLOCK_MAGIC	0x981bd112
#define RT_CK_VLBLOCK(_p)	BU_CKMAG((_p), RT_VLBLOCK_MAGIC, "rt_vlblock")
d1471 1
a1471 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.110 1999/05/10 15:49:49 mike Exp $
d1936 3
a1938 3
RT_EXTERN(struct rt_vlblock *rt_vlblock_init, () );
RT_EXTERN(void rt_vlblock_free, (struct rt_vlblock *vbp) );
RT_EXTERN(struct bu_list *rt_vlblock_find, (struct rt_vlblock *vbp,
d1964 3
a1966 3
RT_EXTERN(struct rt_vlblock *	rt_vlblock_init, () );
RT_EXTERN(void			rt_vlblock_free, (struct rt_vlblock *vbp) );
RT_EXTERN(struct bu_list *	rt_vlblock_find, (struct rt_vlblock *vbp,
d1976 1
a1976 1
				CONST struct rt_vlblock	*vbp) );
d1979 1
a1979 1
RT_EXTERN(int			rt_uplot_to_vlist, (struct rt_vlblock *vbp,
d1981 1
a1981 1
RT_EXTERN(void			rt_label_vlist_verts, (struct rt_vlblock *vbp,
d2271 1
a2271 1
RT_EXTERN(void			nmg_vlblock_v, (struct rt_vlblock *vbp,
d2273 1
a2273 1
RT_EXTERN(void			nmg_vlblock_e, (struct rt_vlblock *vbp,
d2276 1
a2276 1
RT_EXTERN(void			nmg_vlblock_eu, (struct rt_vlblock *vbp,
d2280 1
a2280 1
RT_EXTERN(void			nmg_vlblock_lu, (struct rt_vlblock *vbp,
d2284 1
a2284 1
RT_EXTERN(void			nmg_vlblock_fu, (struct rt_vlblock *vbp,
d2286 1
a2286 1
RT_EXTERN(void			nmg_vlblock_s, (struct rt_vlblock *vbp,
d2288 1
a2288 1
RT_EXTERN(void			nmg_vlblock_r, (struct rt_vlblock *vbp,
d2290 1
a2290 1
RT_EXTERN(void			nmg_vlblock_m, (struct rt_vlblock *vbp,
@


11.110
log
@Needed extra arg in ts_region_start_func() for FASTGEN silliness.
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.109 1999/01/27 01:07:08 butler Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.109 1999/01/27 01:07:08 butler Exp $ (BRL)"
d442 1
a442 1
	char	ma_override;		/* non-0 ==> ma_color is valid */
d1547 1
a1547 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.109 1999/01/27 01:07:08 butler Exp $
@


11.109
log
@Because the library "librt" does not yet use the application struct member
"a_pixelext", a separate category was created in the comment section of the
application structure definition.  This distinguishes its status as something
the library does not currently use, but warns the programmer that this storage
has a defined meaning, and is not available for arbitrary purposes.
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.108 1999/01/25 05:29:56 butler Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.108 1999/01/25 05:29:56 butler Exp $ (BRL)"
d770 2
a771 1
				struct db_full_path * /*pathp*/
d1547 1
a1547 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.108 1999/01/25 05:29:56 butler Exp $
@


11.108
log
@Changes for prism tracing.
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.107 1998/12/17 04:19:08 mike Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.107 1998/12/17 04:19:08 mike Exp $ (BRL)"
a1095 1
	struct pixel_ext *a_pixelext;	/* locations of pixel corners */
d1105 4
d1546 1
a1546 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.107 1998/12/17 04:19:08 mike Exp $
@


11.107
log
@Regions now have an associated temperature
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.106 1998/12/11 20:53:54 mike Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.106 1998/12/11 20:53:54 mike Exp $ (BRL)"
d1021 20
d1096 1
d1183 1
d1543 1
a1543 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.106 1998/12/11 20:53:54 mike Exp $
@


11.106
log
@Drat, I missed some more rt_tabdata -> bn_tabdata changes.
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.105 1998/11/17 22:17:43 mike Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.105 1998/11/17 22:17:43 mike Exp $ (BRL)"
d441 1
d443 2
a444 2
	char	ma_cinherit;		/* DB_INH_LOWER / DB_INH_HIGHER */
	char	ma_minherit;		/* DB_INH_LOWER / DB_INH_HIGHER */
d718 1
d932 1
d939 1
d1521 1
a1521 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.105 1998/11/17 22:17:43 mike Exp $
@


11.105
log
@It's ok to have pointers to structures of unknown size, so I've declared
a_spectrum properly as struct rt_tabdata *, even though only a few files
will know about rt_tabdata.
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.104 1998/11/17 22:06:54 mike Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.104 1998/11/17 22:06:54 mike Exp $ (BRL)"
d1088 1
a1088 1
	struct rt_tabdata *a_spectrum;	/* application-specific rt_tabdata prointer */
d1517 1
a1517 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.104 1998/11/17 22:06:54 mike Exp $
@


11.104
log
@Added a_spectrum to application structure, because a_uptr was already
busy holding region pointers for reflect/refract code.
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.103 1998/09/14 15:59:14 bparker Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.103 1998/09/14 15:59:14 bparker Exp $ (BRL)"
d1088 1
a1088 1
	genptr_t	a_spectrum;	/* application-specific rt_tabdata prointer */
d1517 1
a1517 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.103 1998/09/14 15:59:14 bparker Exp $
@


11.103
log
@*- fix typos
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.102 1998/08/10 18:20:22 mike Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.102 1998/08/10 18:20:22 mike Exp $ (BRL)"
d1088 1
d1517 1
a1517 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.102 1998/08/10 18:20:22 mike Exp $
@


11.102
log
@Added extra extern.
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.101 1998/08/10 17:50:49 mike Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.101 1998/08/10 17:50:49 mike Exp $ (BRL)"
d1516 1
a1516 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.101 1998/08/10 17:50:49 mike Exp $
d1736 1
a1736 1
RT_EXTERN(void,	rt_free_rti(struct rt_i *rtip));
@


11.101
log
@Fixed arg type of rt_dirbuild
@
text
@d44 1
a44 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.100 1998/05/12 17:24:08 mike Exp $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/raytrace.h,v 11.100 1998/05/12 17:24:08 mike Exp $ (BRL)"
d1516 1
a1516 1
 *  $Header: /c/CVS/brlcad/h/raytrace.h,v 11.100 1998/05/12 17:24:08 mike Exp $
d1736 1
@


11.100
log
@db_open and db_create needed CONST args
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.99 1998/04/15 05:52:53 mike Exp mike $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.99 1998/04/15 05:52:53 mike Exp mike $ (BRL)"
d1516 1
a1516 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.99 1998/04/15 05:52:53 mike Exp mike $
d1733 1
a1733 1
RT_EXTERN(struct rt_i *rt_dirbuild, (char *filename, char *buf, int len) );
@


11.99
log
@Added two additional fields to application structure.
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.98 1998/04/15 04:28:09 mike Exp mike $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.98 1998/04/15 04:28:09 mike Exp mike $ (BRL)"
d1516 1
a1516 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.98 1998/04/15 04:28:09 mike Exp mike $
d1862 1
a1862 1
RT_EXTERN(struct db_i *db_open, ( char *name, char *mode ) );
d1864 1
a1864 1
RT_EXTERN(struct db_i *db_create, ( char *name ) );
@


11.98
log
@Added ts_rtip to eliminate global variable in rt_gettrees().
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.97 1998/04/10 17:25:22 jra Exp mike $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.97 1998/04/10 17:25:22 jra Exp mike $ (BRL)"
d1081 3
d1516 1
a1516 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.97 1998/04/10 17:25:22 jra Exp mike $
@


11.97
log
@Declaration of nmg_class_name() was using reserved C++ word "class".
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.96 1998/04/10 17:18:53 jra Exp jra $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.96 1998/04/10 17:18:53 jra Exp jra $ (BRL)"
d788 1
d1513 1
a1513 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.96 1998/04/10 17:18:53 jra Exp jra $
@


11.96
log
@deleted duplicate declaration of nmg_visit_handlers_null.
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.95 1998/04/03 00:23:13 mike Exp jra $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.95 1998/04/03 00:23:13 mike Exp jra $ (BRL)"
d1512 1
a1512 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.95 1998/04/03 00:23:13 mike Exp jra $
d2407 1
a2407 1
RT_EXTERN(CONST char		*nmg_class_name, (int class) );
@


11.95
log
@Added ID_SUBMODEL
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.94 1998/03/26 07:00:43 mike Exp mike $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.94 1998/03/26 07:00:43 mike Exp mike $ (BRL)"
d1512 1
a1512 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.94 1998/03/26 07:00:43 mike Exp mike $
a2482 4

#if defined(NMG_H)
extern CONST struct nmg_visit_handlers  nmg_visit_handlers_null;
#endif
@


11.94
log
@Added dbi_uses counter, rti_ttol default, and an obscure extern.
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.93 1998/03/24 05:39:47 mike Exp mike $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.93 1998/03/24 05:39:47 mike Exp mike $ (BRL)"
d430 1
d432 1
a432 1
#define ID_MAXIMUM	27	/* Maximum defined ID_xxx value */
d1512 1
a1512 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.93 1998/03/24 05:39:47 mike Exp mike $
@


11.93
log
@Added a_no_booleans, to support PJT's "solids_on_ray" capability.
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.92 1998/03/24 05:36:31 mike Exp mike $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.92 1998/03/24 05:36:31 mike Exp mike $ (BRL)"
d646 1
d1155 2
a1195 1
	struct bn_tol	rti_tol;	/* Tolerances for this model */
d1198 1
a1198 1
	double		 rti_nu_gfactor; /* constant in numcells computation */
d1511 1
a1511 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.92 1998/03/24 05:36:31 mike Exp mike $
d2429 2
@


11.92
log
@JRA mods to add new parameter to ft_import and ft_export.
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.91 1998/03/19 11:38:10 mike Exp jra $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.91 1998/03/19 11:38:10 mike Exp jra $ (BRL)"
d1077 1
d1509 1
a1509 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.91 1998/03/19 11:38:10 mike Exp jra $
@


11.91
log
@Added two new user-visible fields to struct rt_i
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.90 1998/03/19 11:32:47 mike Exp mike $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.90 1998/03/19 11:32:47 mike Exp mike $ (BRL)"
d1462 2
a1463 1
			CONST mat_t /*mat*/));
d1466 2
a1467 1
			double /*local2mm*/));
d1508 1
a1508 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.90 1998/03/19 11:32:47 mike Exp mike $
@


11.90
log
@JRA modifications to add 2D sketch "solids" and extruded solids.
Also changed to auto-include nmg.h, all the time.
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.89 1998/02/23 16:31:37 jra Exp jra $
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.89 1998/02/23 16:31:37 jra Exp jra $ (BRL)"
d1146 3
a1148 1
	int		useair;		/* "air" regions are used */
d1506 1
a1506 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.89 1998/02/23 16:31:37 jra Exp jra $
@


11.89
log
@Minor mod for C++
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.88 1998/01/09 08:38:43 mike Exp jra $
d57 4
d65 1
a65 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.88 1998/01/09 08:38:43 mike Exp jra $ (BRL)"
d428 2
d431 1
a431 1
#define ID_MAXIMUM	25	/* Maximum defined ID_xxx value */
d1061 2
a1062 7
#if defined ( __cplusplus )
	int		(*a_hit)( struct application *, struct partition *);	/* called when shot hits model */
	int		(*a_miss)( struct application *);	/* called when shot misses */
#else
	int		(*a_hit)();	/* called when shot hits model */
	int		(*a_miss)();	/* called when shot misses */
#endif
d1349 38
d1504 1
a1504 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.88 1998/01/09 08:38:43 mike Exp jra $
d2455 4
a2458 3
RT_EXTERN(void			rt_dspline4v, (double *pt, mat_t m, double *a,
					double *b, double *c, double *d,
					int depth, double alpha) );
@


11.88
log
@Changed calling sequence to rt_boolfinal()
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.87 1997/12/16 08:14:30 mike Exp mike $
d61 1
a61 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.87 1997/12/16 08:14:30 mike Exp mike $ (BRL)"
d1055 4
d1061 1
d1465 1
a1465 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.87 1997/12/16 08:14:30 mike Exp mike $
a1932 5

/* plane.c */
 
/* bn_cx_div, CxSqrt */
extern void bn_pr_roots();		/* print complex roots */
@


11.87
log
@semphores (res_syscall, etc.) no longer live in rt_g.
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.86 1997/12/16 00:54:10 mike Exp mike $
d61 1
a61 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.86 1997/12/16 00:54:10 mike Exp mike $ (BRL)"
d1460 1
a1460 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.86 1997/12/16 00:54:10 mike Exp mike $
d1739 2
a1740 1
	struct bu_ptbl *regionbits, struct application *ap) );
@


11.86
log
@Fixed typo
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.85 1997/12/16 00:47:26 mike Exp mike $
d61 1
a61 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.85 1997/12/16 00:47:26 mike Exp mike $ (BRL)"
d1096 2
a1097 2
	int		debug;		/* non-zero for debug, see debug.h */
	/*  Definitions necessary to interlock in a parallel environment */
a1098 5
	long		res_syscall;	/* lock on system calls */
	long		res_worker;	/* lock on work to do */
	long		res_stats;	/* lock on statistics */
	long		res_results;	/* lock on result buffer */
	long		res_model;	/* lock on model growth (splines) */
d1100 1
a1100 1
	int		NMG_debug;	/* debug bits for NMG's see nmg.h */
d1460 1
a1460 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.85 1997/12/16 00:47:26 mike Exp mike $
@


11.85
log
@Moved definitions for RT_SEM_xxx from compat4.h to raytrace.h
Added new symbol RT_SEM_LAST
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.84 1997/10/06 15:25:39 mike Exp mike $
d61 1
a61 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.84 1997/10/06 15:25:39 mike Exp mike $ (BRL)"
d1116 1
a1116 1
#define RT_SEM_TREE0	(RT_SEM_LAST+1)
d1120 1
a1120 1
#define RT_SEM_WORKER	(BU_SEM_TREE3+1)
d1465 1
a1465 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.84 1997/10/06 15:25:39 mike Exp mike $
@


11.84
log
@"qelem" conflicts with system structures.  Changed to "rt_qelem".
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.83 1997/09/18 20:34:13 jra Exp mike $
d61 1
a61 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.83 1997/09/18 20:34:13 jra Exp mike $ (BRL)"
d1110 19
d1465 1
a1465 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.83 1997/09/18 20:34:13 jra Exp mike $
@


11.83
log
@Mods for addition of pmalloc.
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.82 1997/09/02 17:54:12 gdurf Exp jra $
d61 1
a61 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.82 1997/09/02 17:54:12 gdurf Exp jra $ (BRL)"
d936 1
a936 1
#define NBUCKETS        18
d938 3
a940 3
struct qelem {
        struct qelem *q_forw;
        struct qelem *q_back;
d943 3
a945 3
struct pm_res {
	struct qelem buckets[NBUCKETS];
	struct qelem adjhead;
d1446 1
a1446 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.82 1997/09/02 17:54:12 gdurf Exp jra $
@


11.82
log
@Removed NUBSPTNODE as a cut type.
Added CUT_MAXIMUM constant for loops and such.
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.81 1997/07/23 06:55:13 gdurf Exp gdurf $
d61 1
a61 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.81 1997/07/23 06:55:13 gdurf Exp gdurf $ (BRL)"
d932 16
d985 1
d1446 1
a1446 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.81 1997/07/23 06:55:13 gdurf Exp gdurf $
@


11.81
log
@RT_CLASSIFY_... now defined in terms of BN_CLASSIFY_...
(perhaps there should be only one "CLASSIFY_..." set of defines?)
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.80 1997/07/15 13:16:03 gdurf Exp gdurf $
d61 1
a61 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.80 1997/07/15 13:16:03 gdurf Exp gdurf $ (BRL)"
d563 2
a564 2
#define CUT_NUBSPTNODE	3
#define CUT_NUGRIDNODE	4
a581 6
	struct nubsptnode {
		int	nu_type;
		fastf_t	nu_min[3];
		fastf_t	nu_max[3];
		union cutter *first_cut;
	} nubn;
d1113 1
d1143 1
a1143 1
	int		rti_ncut_by_type[5];	/* number of cuts by type */
d1429 1
a1429 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.80 1997/07/15 13:16:03 gdurf Exp gdurf $
@


11.80
log
@Added args to ft_classify
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.79 1997/07/15 13:07:30 gdurf Exp gdurf $
d61 1
a61 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.79 1997/07/15 13:07:30 gdurf Exp gdurf $ (BRL)"
d586 1
a586 1
		struct cutnode *first_cut;
d1148 1
a1148 1
	int		rti_cut_nbins;	/* number of cut bins (leaves) */
d1406 4
a1409 4
#define RT_CLASSIFY_UNIMPLEMENTED	0
#define RT_CLASSIFY_INSIDE		1
#define RT_CLASSIFY_OVERLAPPING		2
#define RT_CLASSIFY_OUTSIDE		3
d1434 1
a1434 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.79 1997/07/15 13:07:30 gdurf Exp gdurf $
@


11.79
log
@Added union cutter members for nugrid and nubspt.
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.78 1997/07/08 15:32:14 gdurf Exp gdurf $
d61 1
a61 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.78 1997/07/08 15:32:14 gdurf Exp gdurf $ (BRL)"
d1348 5
a1352 1
	int	(*ft_classify)();
d1434 1
a1434 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.78 1997/07/08 15:32:14 gdurf Exp gdurf $
@


11.78
log
@Added "rti_nu_gfactor" to rt_i.
This element controls the fineness of the NUgrid mesh by multiplying
the number of requested cells (n^(1/3)) by this factor.
It should default to something like 1.3 - 1.5 (this may need to be increased
if the function rt_advance_to_next_cell() is sped up.)
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.77 1997/07/07 13:11:42 gdurf Exp gdurf $
d61 1
a61 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.77 1997/07/07 13:11:42 gdurf Exp gdurf $ (BRL)"
d557 1
a557 1
 *  cn_type is an integer for efficiency of access in rt_shootray()
d563 2
d582 17
d600 1
a1160 4
	struct nu_axis	*rti_nu_axis[3];           /* arrays of slabs slicing space into cells */
	int		 rti_nu_cells_per_axis[3]; /* number of slabs */
	int		 rti_nu_stepsize[3];       /* number of cells to jump for one step in each axis */
	union cutter	*rti_nu_grid;	 /* array of boxnodes */
d1163 3
a1172 6
struct nu_axis {
	fastf_t		nu_spos;	/* cell start position */
	fastf_t		nu_epos;	/* cell end position */
	fastf_t		nu_width;	/* voxel size (end - start) */
};

d1402 5
d1430 1
a1430 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.77 1997/07/07 13:11:42 gdurf Exp gdurf $
@


11.77
log
@Added new accounting statistics for optimization
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.76 1997/06/25 04:42:00 mike Exp gdurf $
d61 1
a61 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.76 1997/06/25 04:42:00 mike Exp gdurf $ (BRL)"
d1144 2
a1145 1
	union cutter	*rti_nu_grid;		   /* array of boxnodes */
d1412 1
a1412 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.76 1997/06/25 04:42:00 mike Exp gdurf $
@


11.76
log
@Added extern definitions from wdb.c and nmg_mod.c
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.75 1997/06/20 01:49:38 gdurf Exp mike $
d61 1
a61 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.75 1997/06/20 01:49:38 gdurf Exp mike $ (BRL)"
d967 2
d1120 2
d1411 1
a1411 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.75 1997/06/20 01:49:38 gdurf Exp mike $
@


11.75
log
@Added rt_wdb structure
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.74 1997/06/17 20:40:44 gdurf Exp gdurf $
d61 1
a61 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.74 1997/06/17 20:40:44 gdurf Exp gdurf $ (BRL)"
d717 1
d721 3
a723 2
#define RT_WDB_TYPE_DB_INMEM			3
#define RT_WDB_TYPE_DB_INMEM_APPEND_ONLY	4
d1407 1
a1407 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.74 1997/06/17 20:40:44 gdurf Exp gdurf $
d2065 4
@


11.74
log
@Added extern for db_tcl_comb_describe
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.73 1997/06/13 02:49:16 gdurf Exp gdurf $
d61 1
a61 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.73 1997/06/13 02:49:16 gdurf Exp gdurf $ (BRL)"
d702 21
d1405 1
a1405 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.73 1997/06/13 02:49:16 gdurf Exp gdurf $
d1725 4
a1857 3
#ifdef _TCL
RT_EXTERN(int db_tcl_comb_describe, (Tcl_Interp *interp, struct rt_comb_internal *comb, CONST char *item));
#endif
@


11.73
log
@Added support for NUgrid
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.72 1997/05/22 09:47:55 butler Exp gdurf $
d61 1
a61 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.72 1997/05/22 09:47:55 butler Exp gdurf $ (BRL)"
d1384 1
a1384 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.72 1997/05/22 09:47:55 butler Exp gdurf $
d1779 4
d1833 3
a1835 1

@


11.72
log
@added dsp solid
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.71 1997/05/19 17:04:58 butler Exp butler $
d61 1
a61 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.71 1997/05/19 17:04:58 butler Exp butler $ (BRL)"
a582 1

d1073 1
d1114 4
d1119 1
d1126 9
d1384 1
a1384 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.71 1997/05/19 17:04:58 butler Exp butler $
@


11.71
log
@goodbye fbm solid
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.70 1997/04/25 05:59:40 butler Exp butler $
d61 1
a61 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.70 1997/04/25 05:59:40 butler Exp butler $ (BRL)"
d423 1
d425 1
a425 1
#define ID_MAXIMUM	24	/* Maximum defined ID_xxx value */
d1370 1
a1370 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.70 1997/04/25 05:59:40 butler Exp butler $
@


11.70
log
@added g_fbm.c support
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.69 1997/04/01 20:12:42 butler Exp butler $
d61 1
a61 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.69 1997/04/01 20:12:42 butler Exp butler $ (BRL)"
a422 2
#define ID_FBM		25	/* fBm sphere */
#define ID_MAXIMUM	25	/* Maximum defined ID_xxx value */
d424 2
d1369 1
a1369 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.69 1997/04/01 20:12:42 butler Exp butler $
@


11.69
log
@moved units.c from librt to libbu
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.68 1997/02/20 21:00:55 jra Exp butler $
d61 1
a61 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.68 1997/02/20 21:00:55 jra Exp butler $ (BRL)"
d423 2
a425 2
#define ID_MAXIMUM	24	/* Maximum defined ID_xxx value */

d1369 1
a1369 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.68 1997/02/20 21:00:55 jra Exp butler $
@


11.68
log
@Added rt_tree_array structure.
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.67 1997/02/05 03:37:20 mike Exp jra $
d61 1
a61 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.67 1997/02/05 03:37:20 mike Exp jra $ (BRL)"
d1369 1
a1369 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.67 1997/02/05 03:37:20 mike Exp jra $
a1851 4
/* units.c */
RT_EXTERN(double rt_units_conversion, (CONST char *str) );
RT_EXTERN(CONST char *rt_units_string, (CONST double mm) );
RT_EXTERN(double rt_mm_value, (CONST char *s) );
@


11.67
log
@Added support for in-memory-only database objects
@
text
@d44 1
a44 1
 *  $Header: /n/vapor/m/cad/h/RCS/raytrace.h,v 11.66 1997/01/09 20:16:57 jra Exp mike $
d61 1
a61 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /n/vapor/m/cad/h/RCS/raytrace.h,v 11.66 1997/01/09 20:16:57 jra Exp mike $ (BRL)"
d828 13
d1369 1
a1369 1
 *  $Header: /n/vapor/m/cad/h/RCS/raytrace.h,v 11.66 1997/01/09 20:16:57 jra Exp mike $
@


11.66
log
@Moved struct hitmiss freelist to resource structure.
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.65 1997/01/09 17:10:24 jra Exp jra $
d61 1
a61 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.65 1997/01/09 17:10:24 jra Exp jra $ (BRL)"
d648 4
a651 1
	long		d_addr;			/* disk address in obj file */
d664 1
d670 1
d1356 1
a1356 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.65 1997/01/09 17:10:24 jra Exp jra $
@


11.65
log
@changed #if to #ifdef
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.64 1997/01/09 16:12:40 jra Exp jra $
d61 1
a61 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.64 1997/01/09 16:12:40 jra Exp jra $ (BRL)"
d913 1
a1030 1
	struct bu_list	rtg_nmgfree;	/* head of NMG hitmiss freelist */
d1351 1
a1351 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.64 1997/01/09 16:12:40 jra Exp jra $
d1512 3
a1514 3
#define GET_HITMISS(_p) { \
	(_p) = BU_LIST_FIRST( hitmiss, &rt_g.rtg_nmgfree ); \
	if( BU_LIST_IS_HEAD( (_p), &rt_g.rtg_nmgfree ) ) \
d1520 1
a1520 1
#define NMG_FREE_HITLIST(_p) { \
d1522 1
a1522 1
	BU_LIST_APPEND_LIST( &rt_g.rtg_nmgfree, (_p) ); \
@


11.64
log
@Incorporated nmg_rt.h.
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.63 1996/12/04 02:49:37 mike Exp jra $
d61 1
a61 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.63 1996/12/04 02:49:37 mike Exp jra $ (BRL)"
d1351 1
a1351 1
 *  $Header: /m/cad/librt/RCS/nmg_rt.h,v 11.5 1997/01/07 22:58:23 jra Exp $
d1511 1
a1511 1
#if FAST_NMG
@


11.63
log
@Combined ma_matname and ma_matparm into a single string, ma_shader.
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.62 1996/12/03 04:21:11 mike Exp mike $
d61 1
a61 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.62 1996/12/03 04:21:11 mike Exp mike $ (BRL)"
d1030 1
d1327 233
@


11.62
log
@Fixed missing "conf.h" include in Include Sequencing comment.
@
text
@d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.61 1996/10/31 13:16:37 pjt Exp mike $
d61 1
a61 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.61 1996/10/31 13:16:37 pjt Exp mike $ (BRL)"
d436 1
a436 2
	char	*ma_matname;		/* Material name */
	char	*ma_matparm;		/* String Material parms */
d690 1
a690 2
	struct rt_vls	shader_name;
	struct rt_vls	shader_param;
d844 3
a846 4
	/* XXX magic */
	int		anp_op;			/* RT_ANP_RBOTH, etc */
	struct bu_vls	anp_matname;		/* Changes for material name */
	struct bu_vls	anp_matparam;		/* Changes for mat. params */
d848 4
a851 4
#define RT_ANP_RBOTH	1			/* Replace both material & params */
#define RT_ANP_RMATERIAL 2			/* Replace just material */
#define RT_ANP_RPARAM	3			/* Replace just params */
#define RT_ANP_APPEND	4			/* Append to params */
@


11.61
log
@Added a_dist member to application structure
@
text
@d24 6
d44 1
a44 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.60 1996/10/21 18:49:42 jra Exp pjt $
d61 1
a61 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.60 1996/10/21 18:49:42 jra Exp pjt $ (BRL)"
@


11.60
log
@Added tolerance arg to nmg_gluefaces() declaration.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.59 1996/10/19 06:26:01 mike Exp jra $
d55 1
a55 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.59 1996/10/19 06:26:01 mike Exp jra $ (BRL)"
d998 1
@


11.59
log
@Changed to reflect that ma_matparm is now a pointer, not an array.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.58 1996/10/16 02:35:06 mike Exp mike $
d55 1
a55 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.58 1996/10/16 02:35:06 mike Exp mike $ (BRL)"
d1689 1
a1689 1
RT_EXTERN(void			nmg_gluefaces, (struct faceuse *fulist[], int n) );
@


11.58
log
@db_io.c got more CONST args.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.57 1996/10/05 09:12:34 mike Exp mike $
d55 1
a55 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.57 1996/10/05 09:12:34 mike Exp mike $ (BRL)"
d430 2
a431 3
	/* XXX These should become (char *) to bu_strdup() */
	char	ma_matname[32];		/* Material name */
	char	ma_matparm[60];		/* String Material parms */
d691 1
a691 1
#define RT_CK_COMB(_p)		NMG_CKMAG( _p , RT_COMB_MAGIC , "rt_comb_internal" )
d1533 1
a1533 2
	CONST struct db_full_path *pathp, CONST struct bu_external *ep));
#if defined(DB_H)
d1535 1
a1535 2
	struct db_full_path *pathp, CONST struct member	*mp));
#endif
d1556 3
@


11.57
log
@Added rt_comb_internal
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.56 1996/09/27 08:19:09 mike Exp mike $
d55 1
a55 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.56 1996/09/27 08:19:09 mike Exp mike $ (BRL)"
d1468 1
a1468 1
RT_EXTERN(union record *db_getmrec, ( struct db_i *, CONST struct directory *dp ) );
d1470 1
a1470 1
RT_EXTERN(int db_get, (struct db_i *, CONST struct directory *dp,
d1473 1
a1473 1
RT_EXTERN(int db_put, ( struct db_i *, CONST struct directory *dp, union record *where,
d1477 1
a1477 1
RT_EXTERN(genptr_t db_getmrec, ( struct db_i *, CONST struct directory *dp ) );
d1479 1
a1479 1
RT_EXTERN(int db_get, (struct db_i *, CONST struct directory *dp,
d1482 1
a1482 1
RT_EXTERN(int db_put, ( struct db_i *, CONST struct directory *dp,
d1486 1
a1486 1
	CONST struct directory *dp, struct db_i *dbip ) );
@


11.56
log
@Converted over to bn.h bu.h definitions
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.55 1996/09/27 06:39:03 mike Exp $
d55 1
a55 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.55 1996/09/27 06:39:03 mike Exp $ (BRL)"
d666 27
@


11.55
log
@Added st_rtip, to prevent instancing of solids from other
instances of the model.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.54 1996/09/27 06:16:56 butler Exp mike $
d55 1
a55 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.54 1996/09/27 06:16:56 butler Exp mike $ (BRL)"
d116 1
a116 1
#define RT_CK_TESS_TOL(_p)	RT_CKMAG(_p, RT_TESS_TOL_MAGIC, "rt_tess_tol")
d146 1
a146 1
#define RT_CK_DB_INTERNAL(_p)	RT_CKMAG(_p, RT_DB_INTERNAL_MAGIC, "rt_db_internal")
d162 1
a162 1
#define RT_CK_FULL_PATH(_p)	RT_CKMAG(_p, DB_FULL_PATH_MAGIC, "db_full_path")
d212 1
a212 1
		rt_log("stp=x%x, id=%d. hitp=x%x, rayp=x%x\n", _stp, _id, _hitp, _rayp); \
d261 1
a261 1
		rt_log("stp=x%x, id=%d.\n", _stp, _id); \
d286 1
a286 1
		rt_log("stp=x%x, id=%d.\n", _stp, _id); \
d303 1
a303 1
	struct rt_list	l;
d311 2
a312 2
#define RT_CHECK_SEG(_p)	RT_CKMAG(_p, RT_SEG_MAGIC, "struct seg")
#define RT_CK_SEG(_p)		RT_CKMAG(_p, RT_SEG_MAGIC, "struct seg")
d315 1
a315 1
	while( !RT_LIST_WHILE((p),seg,&((res)->re_seg)) || !(p) ) \
d317 2
a318 2
	RT_LIST_DEQUEUE( &((p)->l) ); \
	(p)->l.forw = (p)->l.back = RT_LIST_NULL; \
d323 1
a323 1
	RT_LIST_INSERT( &((res)->re_seg), &((p)->l) ); \
d327 1
a327 1
 *	RT_LIST_INSERT_LIST( &((_res)->re_seg), &((_segheadp)->l) )
d332 2
a333 2
	while( RT_LIST_WHILE( _a, seg, &((_segheadp)->l) ) )  { \
		RT_LIST_DEQUEUE( &(_a->l) ); \
d363 2
a364 2
	struct rt_list	l;		/* links, headed by rti_headsolid */
	struct rt_list	l2;		/* links, headed by st_dp->d_use_hd */
d386 2
a387 2
#define RT_CHECK_SOLTAB(_p)	RT_CKMAG( _p, RT_SOLTAB_MAGIC, "struct soltab")
#define RT_CK_SOLTAB(_p)	RT_CKMAG( _p, RT_SOLTAB_MAGIC, "struct soltab")
d458 1
a458 1
#define RT_CK_REGION(_p)	RT_CKMAG(_p,RT_REGION_MAGIC,"struct region")
d475 1
a475 1
	/* This can be thought of and operated on as a struct rt_list */
d493 2
a494 2
#define RT_CK_PT(_p)	RT_CKMAG(_p,PT_MAGIC, "struct partition")
#define RT_CK_PT_HD(_p)	RT_CKMAG(_p,PT_HD_MAGIC, "struct partition list head")
d513 2
a514 2
	if( RT_LIST_NON_EMPTY_P(p, partition, &res->re_parthead) )  { \
		RT_LIST_DEQUEUE((struct rt_list *)(p)); \
d525 1
a525 1
	RT_LIST_APPEND( &(res->re_parthead), (struct rt_list *)(p) ); \
d539 1
a539 1
#define INSERT_PT(_new,_old)	RT_LIST_INSERT((struct rt_list *)_old,(struct rt_list *)_new)
d542 1
a542 1
#define APPEND_PT(_new,_old)	RT_LIST_APPEND((struct rt_list *)_old,(struct rt_list *)_new)
d545 1
a545 1
#define DEQUEUE_PT(_cur)	RT_LIST_DEQUEUE((struct rt_list *)_cur)
d635 2
a636 2
#define RT_CHECK_DBI(_p)	RT_CKMAG(_p,DBI_MAGIC,"struct db_i")
#define RT_CK_DBI(_p)		RT_CKMAG(_p,DBI_MAGIC,"struct db_i")
d651 1
a651 1
	struct rt_list	d_use_hd;		/* heads list of uses (struct soltab l2) */
d655 1
a655 1
#define RT_CK_DIR(_dp)	RT_CKMAG(_dp, RT_DIR_MAGIC, "(librt)directory")
d698 1
a698 1
				struct rt_external * /*ep*/,
d702 1
a702 1
	CONST struct rt_tol	*ts_tol;	/* Math tolerance */
d722 1
a722 1
#define RT_CK_CTS(_p)	RT_CKMAG(_p, RT_CTS_MAGIC, "combined_tree_state")
d782 1
a782 1
		char		*tl_name;	/* Name of this leaf (rt_strdup'ed) */
d791 1
a791 1
#define RT_CK_TREE(_p)	RT_CKMAG(_p, RT_TREE_MAGIC, "union tree")
d846 1
a846 1
#define RT_CK_ANIMATE(_p)	RT_CKMAG((_p), ANIMATE_MAGIC, "animate")
d873 1
a873 1
	struct rt_list 	re_seg;		/* Head of segment freelist */
d878 1
a878 1
	struct rt_list	re_parthead;	/* Head of freelist */
d882 2
a883 2
	struct rt_list	re_solid_bitv;	/* head of freelist */
	struct rt_list	re_region_ptbl;	/* head of freelist */
d900 2
a901 2
#define RT_RESOURCE_CHECK(_p)	RT_CKMAG(_p, RESOURCE_MAGIC, "struct resource")
#define RT_CK_RESOURCE(_p)	RT_CKMAG(_p, RESOURCE_MAGIC, "struct resource")
d999 1
a999 1
	struct rt_list	rtg_vlfree;	/* head of rt_vlist freelist */
d1058 2
a1059 2
	struct histogram rti_hist_cellsize; /* occupancy of cut cells */
	struct histogram rti_hist_cutdepth; /* depth of cut tree */
d1061 2
a1062 2
	struct rt_tol	rti_tol;	/* Tolerances for this model */
	struct rt_list	rti_solidheads[RT_DBNHASH]; /* active solid lists */
d1068 2
a1069 2
#define RT_CHECK_RTI(_p)	RT_CKMAG(_p, RTI_MAGIC, "struct rt_i")
#define RT_CK_RTI(_p)		RT_CKMAG(_p, RTI_MAGIC, "struct rt_i")
d1079 1
a1079 1
	register struct rt_list	*_head = &((_rti)->rti_solidheads[0]); \
d1081 1
a1081 1
		for( RT_LIST_FOR( _s, soltab, _head ) )  {
d1096 1
a1096 1
 *  The head of the doubly linked list can be just a "struct rt_list" head.
d1099 1
a1099 1
 *	for( RT_LIST_FOR( vp, rt_vlist, hp ) )  {
d1112 1
a1112 1
	struct rt_list	l;			/* magic, forw, back */
d1119 1
a1119 1
#define RT_CK_VLIST(_p) RT_CKMAG((_p), RT_VLIST_MAGIC, "rt_vlist")
d1134 1
a1134 1
 *		RT_LIST_INIT( &rt_g.rtg_vlfree );
d1137 2
a1138 2
		(p) = RT_LIST_FIRST( rt_vlist, &rt_g.rtg_vlfree ); \
		if( RT_LIST_IS_HEAD( (p), &rt_g.rtg_vlfree ) )  { \
d1142 1
a1142 1
			RT_LIST_DEQUEUE( &((p)->l) ); \
d1149 2
a1150 2
	RT_CK_LIST_HEAD( (hd) ); \
	RT_LIST_APPEND_LIST( &rt_g.rtg_vlfree, (hd) ); \
d1155 3
a1157 3
	RT_CK_LIST_HEAD( hd ); \
	_vp = RT_LIST_LAST( rt_vlist, (hd) ); \
	if( RT_LIST_IS_HEAD( _vp, (hd) ) || _vp->nused >= RT_VLIST_CHUNK )  { \
d1159 1
a1159 1
		RT_LIST_INSERT( (hd), &(_vp->l) ); \
d1165 1
a1165 1
/* Macro RT_CK_LIST_HEAD() is defined in rtlist.h */
d1173 1
a1173 1
	struct rt_list	*head;		/* head[max] */
d1176 1
a1176 1
#define RT_CK_VLBLOCK(_p)	RT_CKMAG((_p), RT_VLBLOCK_MAGIC, "rt_vlblock")
d1183 3
a1185 3
#define V2PRINT(a,b)	rt_log("%s (%g, %g)\n", a, (b)[0], (b)[1] );
#define VPRINT(a,b)	rt_log("%s (%g, %g, %g)\n", a, (b)[0], (b)[1], (b)[2])
#define HPRINT(a,b)	rt_log("%s (%g, %g, %g, %g)\n", a, (b)[0], (b)[1], (b)[2], (b)[3])
d1246 1
a1246 1
			struct rt_list * /*vhead*/,
d1249 1
a1249 1
			CONST struct rt_tol * /*tol*/));
d1260 1
a1260 1
			CONST struct rt_tol * /*tol*/));
d1265 1
a1265 1
			CONST struct rt_tol * /*tol*/));
d1272 1
a1272 1
			CONST struct rt_tol * /*tol*/));
d1277 1
a1277 1
			CONST struct rt_tol * /*tol*/));
d1280 1
a1280 1
			CONST struct rt_external * /*ep*/,
d1282 1
a1282 1
	int	(*ft_export) RT_ARGS((struct rt_external * /*ep*/,
d1458 1
a1458 1
RT_EXTERN(int db_get_external, ( struct rt_external *ep,
d1460 1
a1460 1
RT_EXTERN(int db_put_external, ( struct rt_external *ep,
d1462 1
a1462 1
RT_EXTERN(void db_free_external, ( struct rt_external *ep ) );
d1507 1
a1507 1
	CONST struct db_full_path *pathp, CONST struct rt_external *ep));
d1544 1
a1544 1
RT_EXTERN(struct rt_list *rt_vlblock_find, (struct rt_vlblock *vbp,
d1549 2
a1550 2
/* CxDiv, CxSqrt */
extern void rt_pr_roots();		/* print complex roots */
d1561 1
a1561 1
RT_EXTERN(void rt_logindent_vls, (struct bu_vls	*v));
d1567 1
a1567 1
RT_EXTERN(int rt_id_solid, (struct rt_external *ep));
d1581 1
a1581 1
RT_EXTERN(struct rt_list *	rt_vlblock_find, (struct rt_vlblock *vbp,
d1585 1
a1585 1
				struct rt_list *hp,
d1587 1
a1587 1
RT_EXTERN(void			rt_vlist_import, (struct rt_list *hp,
d1593 1
a1593 1
				CONST struct rt_list *vhead));
d1597 1
a1597 1
				struct rt_list *src, mat_t mat,
d1632 1
a1632 1
RT_EXTERN(void			nmg_loop_g, (struct loop *l, CONST struct rt_tol *tol) );
d1634 3
a1636 3
RT_EXTERN(void			nmg_face_bb, (struct face *f, CONST struct rt_tol *tol) );
RT_EXTERN(void			nmg_shell_a, (struct shell *s, CONST struct rt_tol *tol) );
RT_EXTERN(void			nmg_region_a, (struct nmgregion *r, CONST struct rt_tol *tol) );
d1652 1
a1652 1
RT_EXTERN(void			nmg_rm_redundancies, (struct shell *s, CONST struct rt_tol *tol ) );
d1656 1
a1656 1
				CONST struct rt_tol *tol) );
d1661 1
a1661 1
RT_EXTERN(int			nmg_fu_planeeqn, (struct faceuse *fu, CONST struct rt_tol *tol) );
d1678 1
a1678 1
				CONST struct rt_tol *tol) );
d1694 1
a1694 1
				struct edgeuse *eu, CONST struct rt_tol *tol));
d1729 1
a1729 1
				CONST plane_t norm, CONST struct rt_tol *tol) );
d1747 1
a1747 1
				CONST struct faceuse *fu2, CONST struct rt_tol *tol));
d1750 1
a1750 1
				CONST struct rt_tol *tol) );
d1755 1
a1755 1
				CONST struct rt_tol *tol) );
d1765 1
a1765 1
				CONST point_t pt, CONST struct rt_tol *tol));
d1768 1
a1768 1
				CONST struct rt_tol *tol) );
d1770 1
a1770 1
				CONST point_t pt, CONST struct rt_tol *tol) );
d1772 1
a1772 1
				CONST point_t pt, CONST struct rt_tol *tol));
d1774 1
a1774 1
				CONST struct rt_list *hd) );
d1776 1
a1776 1
				CONST struct rt_list *hd, int singletons) );
d1780 1
a1780 1
				CONST struct rt_list *hd) );
d1782 1
a1782 1
				CONST struct rt_list *hd) );
d1784 1
a1784 1
				CONST struct rt_list *hd) );
d1786 1
a1786 1
				CONST struct rt_list *hd) );
d1788 1
a1788 1
				CONST struct rt_list *fu_hd) );
d1790 1
a1790 1
RT_EXTERN(void			nmg_edgeuse_tabulate, (struct nmg_ptbl *tab,
d1792 1
a1792 1
RT_EXTERN(void			nmg_vertex_tabulate, (struct nmg_ptbl *tab,
d1794 1
a1794 1
RT_EXTERN(void			nmg_face_tabulate, (struct nmg_ptbl *tab,
d1824 4
a1827 4
RT_EXTERN(int			nmg_tbl, (struct nmg_ptbl *b, int func, long *p) );
RT_EXTERN(void			nmg_purge_unwanted_intersection_points, (struct nmg_ptbl *vert_list, fastf_t *mag, CONST struct faceuse *fu, CONST struct rt_tol *tol));
RT_EXTERN(int			nmg_in_or_ref, (struct vertexuse *vu, struct nmg_ptbl *b) );
RT_EXTERN(void			nmg_rebound, (struct model *m, CONST struct rt_tol *tol) );
d1833 2
a1834 2
RT_EXTERN(void			nmg_triangulate_model, (struct model *m, CONST struct rt_tol   *tol) );
RT_EXTERN(void			nmg_triangulate_fu, (struct faceuse *fu, CONST struct rt_tol   *tol) );
d1851 1
a1851 1
				CONST struct rt_tol *tol) );
d1855 1
a1855 1
				CONST struct rt_tol *tol) );
d1865 1
a1865 1
				CONST struct rt_tol *tol) );
d1906 1
a1906 1
				CONST struct shell *s, CONST struct rt_tol *tol) );
d1917 1
a1917 1
RT_EXTERN(void			nmg_cnurb_to_vlist, (struct rt_list *vhead,
d1924 1
a1924 1
				struct edgeuse *eu2, CONST struct rt_tol *tol));
d1926 1
a1926 1
				struct faceuse *fu2, CONST struct rt_tol *tol) );
d1928 1
a1928 1
				struct shell *s, CONST struct rt_tol *tol));
d1930 1
a1930 1
				struct shell *s2, CONST struct rt_tol *tol));
d1938 1
a1938 1
				CONST int oper, CONST struct rt_tol *tol) );
d1940 1
a1940 1
				(struct shell *s, CONST struct rt_tol *tol,
d1943 1
a1943 1
				struct nmgregion *r2, CONST struct rt_tol *tol));
d1946 1
a1946 1
				struct rt_external *ep, int id));
d1949 1
a1949 1
				struct rt_external *ep, int id));
d1951 1
a1951 1
				CONST struct rt_tol *tol));
d1953 1
a1953 1
				CONST struct rt_tol *tol));
d1958 1
a1958 1
				CONST struct rt_tol *tol) );
d1968 1
a1968 1
				struct nmg_ptbl *b1, struct nmg_ptbl *b2,
d1973 1
a1973 1
				CONST struct rt_tol *tol) );
d2001 1
a2001 1
RT_EXTERN(void			nmg_ck_list, (struct rt_list *hd, CONST char *str) );
d2003 3
a2005 3
RT_EXTERN(int			nmg_check_radial, (CONST struct edgeuse *eu, CONST struct rt_tol *tol));
RT_EXTERN(int			nmg_ck_closed_surf, (CONST struct shell *s, CONST struct rt_tol *tol) );
RT_EXTERN(int			nmg_ck_closed_region, (CONST struct nmgregion *r, CONST struct rt_tol *tol) );
d2008 1
a2008 1
				CONST struct rt_tol *tol));
d2011 1
a2011 1
RT_EXTERN(void			nmg_crackshells, (struct shell *s1, struct shell *s2, CONST struct rt_tol *tol) );
a2046 9
extern CONST double rt_pi;
extern CONST double rt_twopi;
extern CONST double rt_halfpi;
extern CONST double rt_invpi;
extern CONST double rt_inv2pi;
extern CONST double rt_inv255;
extern CONST double rt_degtorad;
extern CONST double rt_radtodeg;
extern CONST mat_t  rt_identity;
d2048 2
@


11.54
log
@More function prototypes
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.53 1996/09/27 04:04:57 butler Exp butler $
d55 1
a55 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.53 1996/09/27 04:04:57 butler Exp butler $ (BRL)"
d365 1
@


11.53
log
@added rt_new_rti() prototype
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.52 1996/09/14 03:40:53 butler Exp butler $
d55 1
a55 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.52 1996/09/14 03:40:53 butler Exp butler $ (BRL)"
d1315 2
d1401 1
a1401 1
RT_EXTERN(int rt_rpp_region, (struct rt_i *rtip, char *reg_name,
d1422 3
a1424 2
RT_EXTERN(void db_shader_mat, (mat_t model_to_shader, CONST struct db_i *dbip,
				CONST struct region *rp) );
@


11.52
log
@moved plane.c and noise.c into libbn
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.51 1996/09/11 08:43:03 butler Exp butler $
d55 1
a55 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.51 1996/09/11 08:43:03 butler Exp butler $ (BRL)"
d1305 1
@


11.51
log
@changes to libbn
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.50 1996/08/31 08:44:53 mike Exp butler $
d55 1
a55 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.50 1996/08/31 08:44:53 mike Exp butler $ (BRL)"
d107 1
a107 1
 *  different beasts than the calcuation tolerance in rt_tol.
a1296 18
/*  A supply of pseudo-random numbers (from table in snoise.c).  
 *  The values are in the range 0..1
 *
 * Usage:
 *	int idx;
 *	float f;
 *
 *	RT_RANDSEED( idx, integer_seed );
 *
 *	while (NEED_MORE_RAND_NUMBERS) {
 *		f = RT_RANDOM( idx );
 *	}
 */
#define RT_RAND_TABSIZE 4096
#define RT_RANDSEED( _i, _seed )        _i = _seed % RT_RAND_TABSIZE
#define RT_RANDOM( _i )         rt_rand_table[ _i = (_i+1) % RT_RAND_TABSIZE ]
extern CONST float rt_rand_table[RT_RAND_TABSIZE];

a1342 7
#define vtoh_move(_d,_s)	mat_vtoh_move(_d,_s)	/* compat */
#define htov_move(_d,_s)	mat_htov_move(_d,_s)
#define ae_vec(_az,_el,_vec)	mat_ae_vec(_az,_el,_vec)	/* compat */
#define eigen2x2(_val1,_val2,_vec1,_vec2,_a,_b,_c)	\
	mat_eigen2x2(_val1,_val2,_vec1,_vec2,_a,_b,_c)	/* compat */
#define vec_ortho(_d,_s)	mat_vec_ortho(_d,_s)	/* compat */
#define vec_perp(_d,_s)		mat_vec_perp(_d,_s)	/* compat */
a1343 1

d1543 1
a1543 50
RT_EXTERN(double rt_dist_pt3_pt3, (CONST point_t a, CONST point_t b));
RT_EXTERN(int rt_3pts_distinct, (CONST point_t a, CONST point_t b,
	CONST point_t c, CONST struct rt_tol *tol) );
RT_EXTERN(int rt_mk_plane_3pts, (plane_t plane, CONST point_t a,
	CONST point_t b, CONST point_t c, CONST struct rt_tol *tol) );
RT_EXTERN(int rt_mkpoint_3planes, (point_t pt, CONST plane_t a,
	CONST plane_t b, CONST plane_t c) );
RT_EXTERN(int rt_isect_line3_plane, (fastf_t *dist, CONST point_t pt,
	CONST vect_t dir, CONST plane_t plane, CONST struct rt_tol *tol) );
RT_EXTERN(int rt_isect_2planes, (point_t pt, vect_t dir, CONST plane_t a,
	CONST plane_t b, CONST vect_t rpp_min, CONST struct rt_tol *tol) );
RT_EXTERN(int rt_isect_2lines, (fastf_t *t, fastf_t *u, CONST point_t p,
	CONST vect_t d, CONST point_t a, CONST vect_t c,
	CONST struct rt_tol *tol) );
RT_EXTERN(int rt_isect_line_lseg, (fastf_t *t, CONST point_t p,
	CONST vect_t d, CONST point_t a, CONST point_t b,
	CONST struct rt_tol *tol) );
#define rt_dist_line_point(pt,dir,a)	rt_dist_line3_pt3(pt,dir,a)
RT_EXTERN(double		rt_dist_line3_pt3, (CONST point_t pt,
				CONST vect_t dir, CONST point_t a) );
RT_EXTERN(double		rt_distsq_line3_pt3, (CONST point_t pt,
				CONST vect_t dir, CONST point_t a));
RT_EXTERN(double		rt_dist_line_origin, (CONST point_t pt,
				CONST vect_t dir) );
RT_EXTERN(double		rt_dist_line2_point2, (CONST point_t pt,
				CONST vect_t dir, CONST point_t a));
RT_EXTERN(double		rt_distsq_line2_point2, (CONST point_t pt,
				CONST vect_t dir, CONST point_t a));
RT_EXTERN(double rt_area_of_triangle, (CONST point_t a, CONST point_t b,
	CONST point_t c) );
RT_EXTERN(int rt_isect_pt_lseg, (fastf_t *dist, CONST point_t a,
	CONST point_t b, CONST point_t p, CONST struct rt_tol *tol) );
RT_EXTERN(double rt_dist_pt_lseg, (point_t pca, CONST point_t a,
	CONST point_t b, CONST point_t p, CONST struct rt_tol *tol) );
RT_EXTERN(void rt_rotate_bbox, (point_t omin, point_t omax, CONST mat_t mat,
	CONST point_t imin, CONST point_t imax));
RT_EXTERN(void rt_rotate_plane, (plane_t oplane, CONST mat_t mat,
	CONST plane_t iplane));
RT_EXTERN(int rt_coplanar, (CONST plane_t a, CONST plane_t b,
	CONST struct rt_tol *tol));
RT_EXTERN(double		rt_angle_measure, (vect_t vec, CONST vect_t x_dir,
				CONST vect_t y_dir));
RT_EXTERN(double		rt_dist_pt3_along_line3, (CONST point_t	p,
				CONST vect_t d, CONST point_t x));
RT_EXTERN(double		rt_dist_pt2_along_line2, (CONST point_t p,
				CONST vect_t d, CONST point_t x));
RT_EXTERN(int			rt_between, (double left, double mid,
				double right, CONST struct rt_tol *tol));


a1593 13

/* snoise.c */
RT_EXTERN(double	noise_v, (point_t pt) );
RT_EXTERN(double	noise_vc, (point_t pt) );
RT_EXTERN(double	noise_g, (point_t pt) );
RT_EXTERN(double	noise_gv, (point_t pt) );
RT_EXTERN(double	noise_sc, (point_t pt) );
RT_EXTERN(void		noise_init, () );
RT_EXTERN(double	noise_perlin, (point_t pt) );
RT_EXTERN(void		noise_vec, (point_t point, point_t result) );
RT_EXTERN(double	noise_fbm, (point_t point, double h_val, double lacunarity, double octaves) );
RT_EXTERN(double	noise_turb, (point_t point, double h_val, double lacunarity, double octaves ) );

@


11.50
log
@bu_list and bu_hist moved to LIBBU
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.49 1996/08/31 07:00:09 mike Exp mike $
d55 1
a55 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.49 1996/08/31 07:00:09 mike Exp mike $ (BRL)"
a101 43
/*
 *			R T _ T O L
 *
 *  A handy way of passing around the tolerance information needed to
 *  perform approximate floating-point calculations on geometry.
 *
 *  dist & dist_sq establish the distance tolerance.
 *
 *	If two points are closer together than dist, then they are to
 *	be considered the same point.
 *	For example:
 *		point_t	a,b;
 *		vect_t	diff;
 *		VSUB2( diff, a, b );
 *		if( MAGNITUDE(diff) < tol->dist )	a & b are the same.
 *	or, more efficiently:
 *		if( MAQSQ(diff) < tol->dist_sq )
 *
 *  perp & para establish the angular tolerance.
 *
 *	If two rays emanate from the same point, and their dot product
 *	is nearly one, then the two rays are the same, while if their
 *	dot product is nearly zero, then they are perpendicular.
 *	For example:
 *		vect_t	a,b;
 *		if( fabs(VDOT(a,b)) >= tol->para )	a & b are parallel
 *		if( fabs(VDOT(a,b)) <= tol->perp )	a & b are perpendicular
 *
 */
struct rt_tol {
	long		magic;
	double		dist;			/* >= 0 */
	double		dist_sq;		/* dist * dist */
	double		perp;			/* nearly 0 */
	double		para;			/* nearly 1 */
};
#define RT_TOL_MAGIC	0x98c734bb
#define RT_CK_TOL(_p)	RT_CKMAG(_p, RT_TOL_MAGIC, "rt_tol")

#define	RT_VECT_ARE_PARALLEL(_dot,_tol)		\
	(((_dot) < 0) ? ((-(_dot))>=(_tol)->para) : ((_dot) >= (_tol)->para))
#define RT_VECT_ARE_PERP(_dot,_tol)		\
	(((_dot) < 0) ? ((-(_dot))<=(_tol)->perp) : ((_dot) <= (_tol)->perp))
a1360 9
RT_EXTERN(double mat_atan2, (double y, double x) );
RT_EXTERN(void mat_zero, (mat_t m) );
RT_EXTERN(void mat_idn, (mat_t m) );
RT_EXTERN(void mat_copy, (mat_t dest, CONST mat_t src) );
RT_EXTERN(void mat_mul, (mat_t dest, CONST mat_t a, CONST mat_t b) );
RT_EXTERN(void matXvec, (vect_t dest, CONST mat_t m, CONST vect_t src) );
RT_EXTERN(void mat_inv, (mat_t dest, CONST mat_t src) );
RT_EXTERN(void mat_vtoh_move, (hvect_t dest, CONST vect_t src) );
RT_EXTERN(void mat_htov_move, (vect_t dest, CONST hvect_t src) );
a1362 6
RT_EXTERN(void mat_print, (CONST char *title, CONST mat_t m) );
RT_EXTERN(void mat_trn, (mat_t dest, CONST mat_t src) );
RT_EXTERN(void mat_ae, (mat_t dest, double azimuth, double elev) );
RT_EXTERN(void mat_ae_vec, (fastf_t *azp, fastf_t *elp, CONST vect_t src) );
RT_EXTERN(void mat_aet_vec, (fastf_t *azp, fastf_t *elp, fastf_t *twistp,
			     vect_t vec_ae, vect_t vec_twist, fastf_t accuracy) );
a1363 3
RT_EXTERN(void mat_angles, (mat_t dest, double alpha, double beta, double ggamma) );
RT_EXTERN(void mat_eigen2x2, (fastf_t *val1, fastf_t *val2,
	vect_t vec1, vect_t vec2, double a, double b, double c) );
a1365 11
RT_EXTERN(void mat_fromto, (mat_t dest, CONST vect_t from, CONST vect_t to) );
RT_EXTERN(void mat_xrot, (mat_t dest, double sinx, double cosx) );
RT_EXTERN(void mat_yrot, (mat_t dest, double siny, double cosy) );
RT_EXTERN(void mat_zrot, (mat_t dest, double sinz, double cosz) );
RT_EXTERN(void mat_lookat, (mat_t dest, CONST vect_t dir, int yflip) );
RT_EXTERN(void mat_vec_ortho, (vect_t dest, CONST vect_t src) );
RT_EXTERN(void mat_vec_perp, (vect_t dest, CONST vect_t src) );
RT_EXTERN(int mat_scale_about_pt, (mat_t mat, CONST point_t pt, CONST double scale));
RT_EXTERN(void mat_xform_about_pt, (mat_t mat, CONST mat_t xform, CONST point_t pt));
RT_EXTERN(void mat_arb_rot, (mat_t mat, CONST point_t pt, CONST vect_t dir, CONST fastf_t ang));
RT_EXTERN(int rt_mat_is_equal, (CONST mat_t a, CONST mat_t b, CONST struct rt_tol *tol));
a1367 1
RT_EXTERN(matp_t mat_dup,	(CONST mat_t in) );
a1370 12
RT_EXTERN(void quat_mat2quat, (quat_t quat, mat_t mat));
RT_EXTERN(void quat_quat2mat, (mat_t mat, quat_t quat));
RT_EXTERN(double quat_distance, (quat_t q1, quat_t q2));
RT_EXTERN(void quat_double, (quat_t qout, quat_t q1, quat_t q2));
RT_EXTERN(void quat_bisect, (quat_t qout, quat_t q1, quat_t q2));
RT_EXTERN(void quat_slerp, (quat_t qout, quat_t q1, quat_t q2, double f));
RT_EXTERN(void quat_sberp, (quat_t qout, quat_t q1, quat_t qa, quat_t qb,
			    quat_t q2, double f));
RT_EXTERN(void quat_make_nearest, (quat_t q1, quat_t q2));
RT_EXTERN(void quat_print, (char *title, quat_t quat));
RT_EXTERN(void quat_exp, (quat_t out, quat_t in));
RT_EXTERN(void quat_log, (quat_t out, quat_t in));
@


11.49
log
@inout.c moved to LIBBU
@
text
@d27 1
d29 1
a29 1
 *	#include "rtlist.h"	/_* OPTIONAL, auto-included by raytrace.h *_/
d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.48 1996/08/31 06:06:13 mike Exp mike $
a40 4
#ifndef SEEN_RTLIST_H
# include "rtlist.h"
#endif

d49 1
d55 1
a55 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.48 1996/08/31 06:06:13 mike Exp mike $ (BRL)"
a176 17
 *			R T _ E X T E R N A L
 * 
 *  An "opaque" handle for holding onto objects,
 *  typically in some kind of external form that is not directly
 *  usable without passing through an "importation" function.
 */
struct rt_external  {
	long	ext_magic;
	int	ext_nbytes;
	genptr_t ext_buf;
};
#define RT_EXTERNAL_MAGIC	0x768dbbd0
#define RT_INIT_EXTERNAL(_p)	{(_p)->ext_magic = RT_EXTERNAL_MAGIC; \
	(_p)->ext_buf = GENPTR_NULL; (_p)->ext_nbytes = 0;}
#define RT_CK_EXTERNAL(_p)	RT_CKMAG(_p, RT_EXTERNAL_MAGIC, "rt_external")

/*
a553 4
/* XXX Move to rtlist.h */
#define RT_LIST_NON_EMPTY_P(p,structure,hp)	\
	(((p)=(struct structure *)((hp)->forw)) != (struct structure *)(hp))

a945 39
 *			S T R U C T P A R S E
 * -- was here
 */

/*
 *			R T _ I M E X P O R T
 */
struct rt_imexport  {
	char		im_fmt[4];		/* "l", "i", or "%f", etc */
	int		im_offset;		/* byte offset in struct */
	int		im_count;		/* # of repetitions */
};
#define RT_IMEXPORT_NULL	((struct rt_imexport *)0)

/*
 *			H I S T O G R A M
 */
struct histogram  {
	long		magic;
	fastf_t		hg_min;		/* minimum value */
	fastf_t		hg_max;		/* maximum value */
	fastf_t		hg_clumpsize;	/* (max-min+1)/nbins+1 */
	long		hg_nsamples;	/* total number of samples spread into histogram */
	long		hg_nbins;	/* # of bins in hg_bins[] */
	long		*hg_bins;	/* array of counters */
};
#define RT_HISTOGRAM_MAGIC	0x48697374	/* Hist */
#define RT_CK_HISTOGRAM(_p)	RT_CKMAG(_p, RT_HISTOGRAM_MAGIC, "struct histogram")
#define RT_HISTOGRAM_TALLY( _hp, _val )	{ \
	if( (_val) <= (_hp)->hg_min )  { \
		(_hp)->hg_bins[0]++; \
	} else if( (_val) >= (_hp)->hg_max )  { \
		(_hp)->hg_bins[(_hp)->hg_nbins]++; \
	} else { \
		(_hp)->hg_bins[(int)(((_val)-(_hp)->hg_min)/(_hp)->hg_clumpsize)]++; \
	} \
	(_hp)->hg_nsamples++;  }

/*
a1386 27
/**********************************************************************/
					/* Parse arbitrary data structure */
#if 0	/* Moved to bu.h */
RT_EXTERN(int rt_structparse, (CONST struct bu_vls *vls,
	CONST struct structparse *tab, char *base ) );
          /* Print arbitrary data structure for human consumption*/
RT_EXTERN(void rt_vls_item_print, (struct bu_vls *vp,
	CONST struct structparse *sp, CONST char *base ) );
          /* Print single element from data structure */
RT_EXTERN(void rt_vls_item_print_nc, (struct bu_vls *vp,
	CONST struct structparse *sp, CONST char *base ) );
          /* Print single element from data structure, without commas */
RT_EXTERN(int rt_vls_name_print, (struct bu_vls *vp,
	CONST struct structparse *parsetab, CONST char *name,
				    CONST char *base ) );
RT_EXTERN(int rt_vls_name_print_nc, (struct bu_vls *vp,
	CONST struct structparse *parsetab, CONST char *name,
				    CONST char *base ) );
          /* Print single element from data structure, chosen by name */
RT_EXTERN(void rt_structprint, (CONST char *title,
	CONST struct structparse *tab, CONST char *base ) );
		/* Print arbitrary data structure to vls for rt_structparse */
RT_EXTERN(void rt_vls_structprint, (struct bu_vls *vls,
	CONST struct structparse *tab, CONST char *base ) );
#endif
/**********************************************************************/

a1510 9

/* hist.c */
RT_EXTERN(void			rt_hist_free, (struct histogram *histp));
RT_EXTERN(void			rt_hist_init, (struct histogram *histp,
				fastf_t min, fastf_t max, int nbins));
RT_EXTERN(void			rt_hist_range, (struct histogram *hp,
				fastf_t low, fastf_t high));
RT_EXTERN(void			rt_hist_pr, (struct histogram *histp,
				CONST char *title));
@


11.48
log
@bu_mapped_file moved to LIBBU
@
text
@d37 1
a37 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.47 1996/08/31 04:07:13 mike Exp mike $
d57 1
a57 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.47 1996/08/31 04:07:13 mike Exp mike $ (BRL)"
a1829 12

/* inout.c */
RT_EXTERN( unsigned char *rt_plong, (unsigned char *msgp, unsigned long l) );
RT_EXTERN( unsigned char *rt_pshort, (unsigned char *msgp, int s));
RT_EXTERN( unsigned long rt_glong, (CONST unsigned char *msgp));
RT_EXTERN( unsigned short rt_gshort, (CONST unsigned char *msgp));
RT_EXTERN( int rt_struct_get, (struct rt_external *ext, FILE *fp));
RT_EXTERN( int rt_struct_put, (FILE *fp, CONST struct rt_external *ext));
RT_EXTERN( int rt_struct_import, (genptr_t base, CONST struct rt_imexport *imp,
				CONST struct rt_external *ext));
RT_EXTERN( int rt_struct_export, (struct rt_external *ext, CONST genptr_t base,
				CONST struct rt_imexport *imp));
@


11.47
log
@Changed calling sequence to bu_ptbl_init()
@
text
@d37 1
a37 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.46 1996/08/31 03:14:42 mike Exp mike $
d57 1
a57 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.46 1996/08/31 03:14:42 mike Exp mike $ (BRL)"
a1104 1
	struct rt_list	rtg_mapped_files; /* list of mapped files open */
a1315 18
 *			R T _ M A P P E D _ F I L E
 */
struct rt_mapped_file {
	struct rt_list	l;
	char		name[512];	/* Copy of file name */
	genptr_t	buf;		/* In-memory copy of file (may be mmapped) */
	long		buflen;		/* # bytes in 'buf' */
	int		is_mapped;	/* 1=mmap() used, 0=rt_malloc/fread */
	char		appl[32];	/* Tag for application using 'apbuf' */
	genptr_t	apbuf;		/* opt: application-specific buffer */
	long		apbuflen;	/* opt: application-specific buflen */
	/* XXX Needs date stamp, in case file is modified */
	int		uses;		/* # ptrs to this struct handed out */
};
#define RT_MAPPED_FILE_MAGIC	0x4d617066	/* Mapf */
#define RT_CK_MAPPED_FILE(_p)	RT_CKMAG(_p, RT_MAPPED_FILE_MAGIC, "rt_mapped_file")

/*
a1803 5

/* file.c */
RT_EXTERN(struct rt_mapped_file *rt_open_mapped_file, (CONST char *name,
				CONST char *appl));
RT_EXTERN(void			rt_close_mapped_file, (struct rt_mapped_file *mp));
@


11.46
log
@Added rti_resources ptbl, to allow tracking down all the per-cpu
memory resources.
@
text
@d37 1
a37 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.45 1996/08/31 02:19:23 mike Exp mike $
d57 1
a57 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.45 1996/08/31 02:19:23 mike Exp mike $ (BRL)"
d584 1
a584 1
		bu_ptbl_init( &(p)->pt_solids_hit, 42 ); \
@


11.45
log
@Moved CutFree into rt_i structure
@
text
@d37 1
a37 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.44 1996/08/30 00:14:00 butler Exp mike $
d57 1
a57 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.44 1996/08/30 00:14:00 butler Exp mike $ (BRL)"
d377 1
a377 1
	while( !RT_LIST_WHILE((p),seg,&((res)->re_seg.l)) || !(p) ) \
d385 1
a385 1
	RT_LIST_INSERT( &((res)->re_seg.l), &((p)->l) ); \
d389 1
a389 1
 *	RT_LIST_INSERT_LIST( &((_res)->re_seg.l), &((_segheadp)->l) )
a547 2
/**	int		pt_len;			/* rti_pt_bytes when created */
/**	bitv_t		pt_solhit[1];		/* VAR bit array:solids hit */
d938 2
a939 1
	struct seg 	re_seg;		/* Head of segment freelist */
d948 1
a948 1
	struct rt_list	re_region_bitv;	/* head of freelist */
a1105 1
	struct rt_list	rtg_resources;	/* list of 'struct resource'es in use */
d1168 1
@


11.44
log
@structparse moved to libbu
@
text
@d37 1
a37 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.43 1996/08/29 06:02:41 mike Exp butler $
d57 1
a57 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.43 1996/08/29 06:02:41 mike Exp butler $ (BRL)"
a1096 1
	union cutter	*rtg_CutFree;	/* cut Freelist */
d1154 3
a1156 1
/* XXX the bu_ptbl of cutter malloc()s should be here or in rt_g, not cut.c */
d1610 1
a1610 1
RT_EXTERN(void rt_fr_cut, (union cutter *cutp) );
@


11.43
log
@Expunged bit vector macros.
Converted partition pt_solhit bit vector into pt_solids_hit bu_ptbl.
@
text
@d37 1
a37 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.42 1996/08/28 10:04:47 mike Exp mike $
d57 1
a57 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.42 1996/08/28 10:04:47 mike Exp mike $ (BRL)"
d971 1
a971 9
 *
 *  Definitions and data structures needed for routines that assign values
 *  to elements of arbitrary data structures, the layout of which is
 *  described by tables of "structparse" structures.
 *
 *  The general problem of word-addressed hardware
 *  where (int *) and (char *) have different representations
 *  is handled in the parsing routines that use sp_offset,
 *  because of the limitations placed on compile-time initializers.
a972 17
#if __STDC__ && !defined(ipsc860)
#	define offsetofarray(_t, _m)	offsetof(_t, _m[0])
#else
#	if !defined(offsetof)
#		define offsetof(_t, _m)		(int)(&(((_t *)0)->_m))
#	endif
#	define offsetofarray(_t, _m)	(int)( (((_t *)0)->_m))
#endif

struct structparse {
	char		sp_fmt[4];		/* "i" or "%f", etc */
	long		sp_count;		/* number of elements */
	char		*sp_name;		/* Element's symbolic name */
	long		sp_offset;		/* Byte offset in struct */
	void		(*sp_hook)();		/* Optional hooked function, or indir ptr */
};
#define FUNC_NULL	((void (*)())0)
d1467 2
d1470 1
d1492 3
@


11.42
log
@st_regions is now a bu_ptbl, not a bitvector.
@
text
@d37 1
a37 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.41 1996/08/28 04:04:56 mike Exp mike $
d57 1
a57 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.41 1996/08/28 04:04:56 mike Exp mike $ (BRL)"
d491 1
a491 1
	/* XXX These should become bu_vls structures */
d536 1
a536 1
	/* This can be thought of as a struct rt_list */
d547 3
a549 2
	int		pt_len;			/* rti_pt_bytes when created */
	bitv_t		pt_solhit[1];		/* VAR bit array:solids hit */
d559 5
a563 2
#define COPY_PT(ip,out,in)	{ \
	bcopy((char *)in, (char *)out, ip->rti_pt_bytes); }
d565 6
a570 1
/* Initialize all the bits to FALSE, clear out structure */
d573 1
a573 3
	bzero( ((char *) (p)), (ip)->rti_pt_bytes ); \
	(p)->pt_len = (ip)->rti_pt_bytes; \
	(p)->pt_magic = PT_MAGIC; }
d575 4
d580 9
a588 5
	while( ((p) = (struct partition *)res->re_parthead.forw) == (struct partition *)&(res->re_parthead) || \
	    !(p) || (p)->pt_len != (ip)->rti_pt_bytes ) \
		rt_get_pt(ip, res); \
	(p)->pt_magic = PT_MAGIC; \
	RT_LIST_DEQUEUE((struct rt_list *)p); \
d592 2
a593 3
			RT_CHECK_PT(p); \
			RT_LIST_APPEND( &(res->re_parthead), (struct rt_list *)(p) ); \
			res->re_partfree++; }
a614 45
 *  Bit vectors
 */

/*
 *  Bit-string manipulators for arbitrarily long bit strings
 *  stored as an array of bitv_t's.
 *  BITV_SHIFT and BITV_MASK are defined in machine.h
 */
#define BITS2BYTES(nbits) (((nbits)+BITV_MASK)/8)	/* conservative */
#define BITTEST(lp,bit)	\
	((lp[bit>>BITV_SHIFT] & (((bitv_t)1)<<(bit&BITV_MASK)))?1:0)
#define BITSET(lp,bit)	\
	(lp[bit>>BITV_SHIFT] |= (((bitv_t)1)<<(bit&BITV_MASK)))
#define BITCLR(lp,bit)	\
	(lp[bit>>BITV_SHIFT] &= ~(((bitv_t)1)<<(bit&BITV_MASK)))
#define BITZERO(lp,nbits) bzero((char *)lp, BITS2BYTES(nbits))

#define RT_BITV_BITS2WORDS(_nb)	(((_nb)+BITV_MASK)>>BITV_SHIFT)

/*
 *  Macros to efficiently find all the bits set in a bit vector.
 *  Counts words down, counts bits in words going up, for speed & portability.
 *  It does not matter if the shift causes the sign bit to smear to the right.
 */
#define RT_BITV_LOOP_START(_bitv, _lim)	\
{ \
	register int		_b;	/* Current bit-in-word number */  \
	register bitv_t		_val;	/* Current word value */  \
	register int		_wd;	/* Current word number */  \
	for( _wd=RT_BITV_BITS2WORDS(_lim)-1; _wd>=0; _wd-- )  {  \
		_val = (_bitv)[_wd];  \
		for(_b=0; _val!=0 && _b < BITV_MASK+1; _b++, _val >>= 1 ) { \
			if( !(_val & 1) )  continue;

#define RT_BITV_LOOP_END	\
		} /* end for(_b) */ \
	} /* end for(_wd) */ \
} /* end block */

/* The two registers are combined when needed;  the assumption is
 * that "one" bits are relatively infrequent with respect to zero bits.
 */
#define RT_BITV_LOOP_INDEX	((_wd << BITV_SHIFT) | _b)

/*
d1180 1
a1180 2
	int		rti_pt_bytes;	/* length of partition struct */
	int		rti_bv_bytes;	/* length of BITV array */
a1618 2
RT_EXTERN(void rt_pr_bitv, (CONST char *str, CONST bitv_t *bv, int len) );
					/* Print a hit point */
a1623 5
RT_EXTERN(void rt_get_pt, (struct rt_i *rtip, struct resource *res) );
RT_EXTERN(void rt_get_bitv, (struct rt_i *rtip, struct resource *res) );
					/* malloc rounder */
RT_EXTERN(void rt_bitv_or, (bitv_t *out, bitv_t *in, int nbits) );
					/* space partitioning */
a1856 1
RT_EXTERN(void rt_pr_bitv_vls, (struct bu_vls *v, CONST bitv_t *bv, int len));
@


11.41
log
@Removed "bitv_elem" and associated macros.
Use bu_bitv structure instead.
@
text
@d37 1
a37 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.40 1996/08/28 02:36:53 mike Exp mike $
d57 1
a57 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.40 1996/08/28 02:36:53 mike Exp mike $ (BRL)"
d437 1
a437 2
	int		st_maxreg;	/* highest bit set in st_regions */
	bitv_t		*st_regions;	/* bit vect of region #'s (const) */
d1632 1
a1632 1
	struct bu_bitv *regionbits, struct application *ap) );
@


11.40
log
@Split numerous routines off into bu.h / LIBBU
@
text
@d37 1
a37 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.39 1996/08/13 16:43:26 butler Exp mike $
d57 1
a57 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.39 1996/08/13 16:43:26 butler Exp mike $ (BRL)"
a603 5
union bitv_elem {
	union bitv_elem	*be_next;
	bitv_t		be_v[2];
};
#define BITV_NULL	((union bitv_elem *)0)
a604 12
#define GET_BITV(ip,p,res)  { \
			while( ((p)=res->re_bitv) == BITV_NULL ) \
				rt_get_bitv(ip,res); \
			res->re_bitv = (p)->be_next; \
			p->be_next = BITV_NULL; \
			res->re_bitvget++; }

#define FREE_BITV(p,res)  { \
			(p)->be_next = res->re_bitv; \
			res->re_bitv = (p); \
			res->re_bitvfree++; }

d971 1
d980 2
a981 4
	union bitv_elem *re_bitv;	/* head of freelist */
	long		re_bitvlen;
	long		re_bitvget;
	long		re_bitvfree;
a983 1
	int		re_cpu;		/* processor number, for ID */
d1633 1
a1633 1
	bitv_t *regionbits, struct application *ap) );
@


11.39
log
@added RT_RANDOM() and support
@
text
@a28 1
 *	#include "rtstring.h"	/_* OPTIONAL, auto-included by raytrace.h *_/
d37 1
a37 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.38 1996/07/30 18:48:47 butler Exp butler $
a43 4
#ifndef SEEN_RTSTRING_H
# include "rtstring.h"
#endif

d47 5
a51 1
#include <setjmp.h>
d57 1
a57 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.38 1996/07/30 18:48:47 butler Exp butler $ (BRL)"
a59 18
 *  System library routines used by LIBRT.
 *  If header files are to be included, this should happen first,
 *  to prevent accidentally redefining important stuff.
 *
 *  A few non-ANSI systems have (and need) these headers anyway.
 */
#if HAVE_STDLIB_H || (sgi && mips) || (ultrix && mips)
/*	NOTE:  Nested includes, gets malloc(), offsetof(), etc */
#	include <stdlib.h>
#	include <stddef.h>
#else
extern char	*malloc();
extern char	*calloc();
extern char	*realloc();
/**extern void	free(); **/
#endif

/*
d149 4
a178 26
 * Handy memory allocator
 */

/* Acquire storage for a given struct, eg, GETSTRUCT(ptr,structname); */
#if __STDC__ && !alliant && !apollo
# define GETSTRUCT(_p,_str) \
	_p = (struct _str *)rt_calloc(1,sizeof(struct _str), #_str " (getstruct)" )
# define GETUNION(_p,_unn) \
	_p = (union _unn *)rt_calloc(1,sizeof(union _unn), #_unn " (getstruct)")
#else
# define GETSTRUCT(_p,_str) \
	_p = (struct _str *)rt_calloc(1,sizeof(struct _str), "_str (getstruct)")
# define GETUNION(_p,_unn) \
	_p = (union _unn *)rt_calloc(1,sizeof(union _unn), "_unn (getstruct)")
#endif

/*
 *  Macros to check and validate a structure pointer, given that
 *  the first entry in the structure is a magic number.
 */
#define RT_CKMAG(_ptr, _magic, _str)	\
	if( !(_ptr) || *((long *)(_ptr)) != (_magic) )  { \
		rt_badmagic( (long *)(_ptr), _magic, _str, __FILE__, __LINE__ ); \
	}

/*
d401 1
d492 1
a492 1
	/* XXX These should become rt_vls structures */
d932 2
a933 2
	struct rt_vls	anp_matname;		/* Changes for material name */
	struct rt_vls	anp_matparam;		/* Changes for mat. params */
a1181 1
	int		rtg_logindent;	/* rt_log() indentation level */
a1182 2
	int		rtg_setjmp_valid;/* !0 = rtg_jmpbuf is valid */
	jmp_buf		rtg_jmpbuf;	/* for RT_SETJMP. */
a1188 9
 *  Macros used for automatic restart capability in rt_bomb().
 * The return from this macro is the return from the setjmp().
 * It is 0 on the first pass through, and non-zero when
 * re-entered via a longjmp().
 */
#define RT_SETJUMP	setjmp((rt_g.rtg_setjmp_valid=1,rt_g.rtg_jmpbuf))
#define RT_UNSETJUMP	(rt_g.rtg_setjmp_valid=0)

/*
d1486 1
a1486 1
	int	(*ft_describe) RT_ARGS((struct rt_vls * /*str*/,
a1520 10

RT_EXTERN(void rt_bomb, (char *str) );	/* Fatal error */
RT_EXTERN(void rt_putchar, (int c) );	/* Log a character, no flushing */
#if __STDC__
RT_EXTERN(void rt_log, (char *, ... ) ); /* Log message */
RT_EXTERN(void rt_flog, (FILE *, char *, ... ) ); /* Log message */
#else
RT_EXTERN(void rt_log, () );		/* Log message */
RT_EXTERN(void rt_flog, () );		/* Log message */
#endif
a1541 2
RT_EXTERN(void rt_printb, (CONST char *s, unsigned long v, CONST char *bits) );
					/* Print a bit vector */
d1545 1
a1545 1
RT_EXTERN(int rt_structparse, (CONST struct rt_vls *vls,
d1548 1
a1548 1
RT_EXTERN(void rt_vls_item_print, (struct rt_vls *vp,
d1551 1
a1551 1
RT_EXTERN(void rt_vls_item_print_nc, (struct rt_vls *vp,
d1554 1
a1554 1
RT_EXTERN(int rt_vls_name_print, (struct rt_vls *vp,
d1557 1
a1557 1
RT_EXTERN(int rt_vls_name_print_nc, (struct rt_vls *vp,
d1564 1
a1564 1
RT_EXTERN(void rt_vls_structprint, (struct rt_vls *vls,
d1572 1
a1572 1
RT_EXTERN(double rt_get_timer, (struct rt_vls *vp, double *elapsed));
a1644 11
					/* visible malloc() */
RT_EXTERN(char *rt_malloc, (unsigned int cnt, CONST char *str) );
					/* visible free() */
RT_EXTERN(void rt_free, (char *ptr, CONST char *str) );
					/* visible realloc() */
RT_EXTERN(char *rt_realloc, (char *ptr, unsigned int cnt, CONST char *str) );
					/* visible calloc() */
RT_EXTERN(char *rt_calloc, (unsigned nelem, unsigned elsize, CONST char *str) );
					/* Duplicate str w/malloc */
RT_EXTERN(char *rt_strdup, (CONST char *cp) );

a1680 2
RT_EXTERN(int rt_byte_roundup, (int nbytes) );
					/* logical OR on bit vectors */
a1833 13

/* machine.c */
					/* change to new "nice" value */
RT_EXTERN(void rt_pri_set, ( int nval ) );
					/* get CPU time limit */
RT_EXTERN(int rt_cpuget, (void) );
					/* set CPU time limit */
RT_EXTERN(void rt_cpuset, (int sec) );
					/* find # of CPUs available */
RT_EXTERN(int rt_avail_cpus, (void) );
					/* run func in parallel */
RT_EXTERN(void rt_parallel, ( void (*func)(), int ncpu ) );

d1908 1
a1908 1
RT_EXTERN(struct rt_vls *rt_assoc, (char *fname, char *value, int field_sep));
d1911 2
a1912 2
RT_EXTERN(void rt_pr_tree_vls, (struct rt_vls *vls, CONST union tree *tp));
RT_EXTERN(void rt_pr_hit_vls, (struct rt_vls *v, CONST char *str,
d1914 1
a1914 1
RT_EXTERN(void rt_pr_pt_vls, (struct rt_vls *v, CONST struct rt_i *rtip,
d1916 3
a1918 3
RT_EXTERN(void rt_pr_bitv_vls, (struct rt_vls *v, CONST bitv_t *bv, int len));
RT_EXTERN(void rt_logindent_vls, (struct rt_vls	*v));
RT_EXTERN(void rt_pr_fallback_angle, (struct rt_vls *str, CONST char *prefix,
a1924 3
/* magic.c */
RT_EXTERN(char *rt_identify_magic, (long magic));

a1933 4
/* bomb.c */
RT_EXTERN(void rt_badmagic, (long *ptr, long magic, char *str,
	char *file, int line));

d1952 1
a1952 1
RT_EXTERN(void			rt_vlist_export, (struct rt_vls *vls,
d1956 1
a1956 1
				struct rt_vls *namevls,
d2397 1
a2397 1
RT_EXTERN(void			nmg_vls_struct_counts, (struct rt_vls *str,
@


11.38
log
@added extern for rt_mm_value()
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.37 1996/07/02 05:43:49 mike Exp butler $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.37 1996/07/02 05:43:49 mike Exp butler $ (BRL)"
d1548 19
@


11.37
log
@Added tree_db_leaf, for combination import/export code.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.36 1996/06/12 13:35:40 jra Exp mike $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.36 1996/06/12 13:35:40 jra Exp mike $ (BRL)"
d2002 1
@


11.36
log
@Added a_ray_length field to application structure.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.35 1996/05/14 14:16:51 jra Exp jra $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.35 1996/05/14 14:16:51 jra Exp jra $ (BRL)"
d522 1
d899 2
d934 6
d941 1
a941 1
/* Things which are in the same place in both structures */
d1664 1
a1664 1

@


11.35
log
@Modified declaration of nmg_lu_reorient() (doesn't need a tolerance).
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.34 1996/03/29 21:51:14 mike Exp jra $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.34 1996/03/29 21:51:14 mike Exp jra $ (BRL)"
d1166 1
@


11.34
log
@Added RT_HIT_NORMAL().
Changed RT_CURVE() to RT_CURVATURE(), to fix bug.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.33 1996/03/28 14:26:25 jra Exp mike $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.33 1996/03/28 14:26:25 jra Exp mike $ (BRL)"
d2136 1
a2136 2
RT_EXTERN(void			nmg_lu_reorient, (struct loopuse *lu,
				CONST struct rt_tol *tol) );
@


11.33
log
@Modified declaration of nmg_class_pt_fu_except().
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.32 1996/03/16 23:55:00 jra Exp jra $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.32 1996/03/16 23:55:00 jra Exp jra $ (BRL)"
d288 5
d304 15
d321 15
d356 3
d360 1
a360 1
#define RT_CURVE( _curvp, _hitp, _stp )  { \
d367 6
a372 1
	rt_functab[_id].ft_curve( _curvp, _hitp, _stp ); }
a566 5
 *  Only the hit_dist field of pt_inhit and pt_outhit are valid
 *  when a_hit() is called;  to compute both hit_point and hit_normal,
 *  use RT_HIT_NORM() macro;  to compute just hit_point, use
 *  VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
 *
a573 8
#define RT_HIT_NORM( _hitp, _stp, _rayp )  { \
	register int _id = (_stp)->st_id; \
	RT_CHECK_SOLTAB(_stp); \
	if( _id <= 0 || _id > ID_MAXIMUM ) { \
		rt_log("stp=x%x, id=%d. hitp=x%x, rayp=x%x\n", _stp, _id, _hitp, _rayp); \
		rt_bomb("RT_HIT_NORM:  bad st_id");\
	} \
	rt_functab[_id].ft_norm(_hitp, _stp, _rayp); }
@


11.32
log
@modified declaration of nmg_class_pt_s().
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.31 1996/03/05 21:23:51 jra Exp jra $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.31 1996/03/05 21:23:51 jra Exp jra $ (BRL)"
d2283 1
@


11.31
log
@Added a tolerance to nmg_rm_redundancies().
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.30 1996/01/04 23:41:49 butler Exp jra $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.30 1996/01/04 23:41:49 butler Exp jra $ (BRL)"
d2273 1
@


11.30
log
@added db_shader_mat()
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.29 1995/12/23 01:55:37 butler Exp butler $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.29 1995/12/23 01:55:37 butler Exp butler $ (BRL)"
d2070 1
a2070 1
RT_EXTERN(void			nmg_rm_redundancies, (struct shell *s ) );
@


11.29
log
@externs for rt_dspline.c
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.28 1995/12/14 15:25:10 pjt Exp butler $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.28 1995/12/14 15:25:10 pjt Exp butler $ (BRL)"
d1743 2
@


11.28
log
@Added declaration of rt_flog() to applications interface
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.27 1995/12/06 17:35:14 pjt Exp $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.27 1995/12/06 17:35:14 pjt Exp $ (BRL)"
d2442 13
@


11.27
log
@Added declaration of rt_overlap_quietly() to applications interface
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.26 1995/11/29 02:31:52 mike Exp pjt $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.26 1995/11/29 02:31:52 mike Exp pjt $ (BRL)"
d1519 1
d1522 1
@


11.26
log
@Fixed Adam's updates to GETSTRUCT and GETUNION
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.25 1995/11/29 02:13:26 mike Exp $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.25 1995/11/29 02:13:26 mike Exp $ (BRL)"
d1527 4
@


11.25
log
@Added ft_tnurb interface
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.24 1995/11/07 23:19:39 adam Exp $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.24 1995/11/07 23:19:39 adam Exp $ (BRL)"
d200 1
a200 1
	_p = (struct _str *)rt_calloc(1,sizeof(struct _str), _str #" (getstruct)" )
d202 1
a202 1
	_p = (union _unn *)rt_calloc(1,sizeof(union _unn), _unn #"(getstruct)")
@


11.24
log
@Changed format of GETSTRUCT log messages
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.23 1995/09/06 13:13:23 jra Exp adam $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.23 1995/09/06 13:13:23 jra Exp adam $ (BRL)"
d1473 5
d1485 5
d2354 3
@


11.23
log
@Modified declaration of nmg_purge_unwanted_intersection_points() to allow for
argument of distances along intersection ray.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.22 1995/07/27 18:28:27 mike Exp jra $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.22 1995/07/27 18:28:27 mike Exp jra $ (BRL)"
d200 1
a200 1
	_p = (struct _str *)rt_calloc(1,sizeof(struct _str), "getstruct " #_str)
d202 1
a202 1
	_p = (union _unn *)rt_calloc(1,sizeof(union _unn), "getstruct " #_unn)
d205 1
a205 1
	_p = (struct _str *)rt_calloc(1,sizeof(struct _str), "getstruct _str")
d207 1
a207 1
	_p = (union _unn *)rt_calloc(1,sizeof(union _unn), "getstruct _unn")
@


11.22
log
@Added st_path
Moved db_full_path towards top of file.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.22 1995/07/27 18:24:57 mike Exp $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.22 1995/07/27 18:24:57 mike Exp $ (BRL)"
d2226 1
a2226 1
RT_EXTERN(void			nmg_purge_unwanted_intersection_points, (struct nmg_ptbl *vert_list, CONST struct faceuse *fu, CONST struct rt_tol *tol));
d2365 1
@


11.21
log
@In ANSI C, you are not allowed to pass 'char' arguments to functions.
They need to be defined as 'int'.
Silly rule.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.20 1995/07/05 16:27:27 gdurf Exp mike $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.20 1995/07/05 16:27:27 gdurf Exp mike $ (BRL)"
d252 16
d437 1
a790 16

/*
 *			D B _ F U L L _ P A T H
 *
 *  For collecting paths through the database tree
 */
struct db_full_path {
	long		magic;
	int		fp_len;
	int		fp_maxlen;
	struct directory **fp_names;	/* array of dir pointers */
};
#define DB_FULL_PATH_POP(_pp)	{(_pp)->fp_len--;}
#define DB_FULL_PATH_CUR_DIR(_pp)	((_pp)->fp_names[(_pp)->fp_len-1])
#define DB_FULL_PATH_MAGIC	0x64626670
#define RT_CK_FULL_PATH(_p)	RT_CKMAG(_p, DB_FULL_PATH_MAGIC, "db_full_path")
@


11.20
log
@Added prototypes
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.19 1995/07/03 13:30:26 gdurf Exp gdurf $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.19 1995/07/03 13:30:26 gdurf Exp gdurf $ (BRL)"
d1920 1
a1920 1
RT_EXTERN(struct rt_vls *rt_assoc, (char *fname, char *value, char field_sep));
@


11.19
log
@Added prototypes for many mat_ functions
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.18 1995/07/03 13:26:02 gdurf Exp gdurf $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.18 1995/07/03 13:26:02 gdurf Exp gdurf $ (BRL)"
d1601 1
d1603 1
d1607 16
@


11.18
log
@Changes by pjt
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.17 1995/06/21 15:05:09 gdurf Exp pjt $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.17 1995/06/21 15:05:09 gdurf Exp pjt $ (BRL)"
d1586 2
d1590 1
a1590 1
RT_EXTERN(void eigen2x2, (fastf_t *val1, fastf_t *val2,
d1601 2
@


11.17
log
@no change
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.16 1995/06/20 16:45:39 gdurf Exp gdurf $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.16 1995/06/20 16:45:39 gdurf Exp gdurf $ (BRL)"
d1542 1
a1542 1
RT_EXTERN(void rt_vls_name_print, (struct rt_vls *vp,
d1545 1
a1545 1
RT_EXTERN(void rt_vls_name_print_nc, (struct rt_vls *vp,
d1897 2
@


11.16
log
@Added function prototype rt_vls_name_print_nc
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.15 1995/06/20 15:20:10 butler Exp gdurf $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.15 1995/06/20 15:20:10 butler Exp gdurf $ (BRL)"
d1535 1
a1535 1
		/* Print arbitrary data structure for human consumption*/
@


11.15
log
@fixed prototype for noise_init()
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.14 1995/06/20 15:00:15 butler Exp butler $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.14 1995/06/20 15:00:15 butler Exp butler $ (BRL)"
d1543 3
@


11.14
log
@added extern for noise_init()
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.13 1995/06/20 13:35:59 gdurf Exp butler $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.13 1995/06/20 13:35:59 gdurf Exp butler $ (BRL)"
d1965 1
a1965 1
RT_EXTERN(double	noise_init, () );
@


11.13
log
@Added new prototype
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.12 1995/06/16 19:21:51 gdurf Exp gdurf $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.12 1995/06/16 19:21:51 gdurf Exp gdurf $ (BRL)"
d1965 1
@


11.12
log
@Added function prototype
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.11 1995/06/16 17:55:26 pjt Exp gdurf $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.11 1995/06/16 17:55:26 pjt Exp gdurf $ (BRL)"
d1539 3
@


11.11
log
@Added extern declaration for rt_version
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.10 1995/06/16 17:18:53 pjt Exp pjt $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.10 1995/06/16 17:18:53 pjt Exp pjt $ (BRL)"
d1537 6
a1542 2
	CONST struct structparse *tab, CONST char *base ) );
          /* Print single element from data structure for Tcl consumption */
@


11.10
log
@PartHeadp now has it's own magic number.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.9 1995/06/15 01:33:45 gdurf Exp pjt $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.9 1995/06/15 01:33:45 gdurf Exp pjt $ (BRL)"
d2403 1
@


11.9
log
@Added prototype for rt_vls_item_print
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.8 1995/06/15 01:32:12 gdurf Exp gdurf $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.8 1995/06/15 01:32:12 gdurf Exp gdurf $ (BRL)"
d545 1
d547 1
a547 1
#define RT_CHECK_PT(_p)	RT_CKMAG(_p,PT_MAGIC, "struct partition")
d549 1
@


11.8
log
@Changes by butler
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.7 1995/05/26 08:35:37 butler Exp butler $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.7 1995/05/26 08:35:37 butler Exp butler $ (BRL)"
d1533 4
a1536 1
		/* Print arbitrary data structure for human consuption*/
@


11.7
log
@added prototypes for snoise.c
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.6 1995/03/18 02:18:12 mike Exp butler $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.6 1995/03/18 02:18:12 mike Exp butler $ (BRL)"
d1687 2
a1688 1

@


11.6
log
@Changed calling sequence.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.5 95/03/10 22:35:33 mike Exp Locker: mike $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.5 95/03/10 22:35:33 mike Exp Locker: mike $ (BRL)"
d1945 12
@


11.5
log
@Butler mod to nmg_class_pt_fu_except() calling sequence.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.4 1995/02/18 00:47:43 butler Exp butler $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.4 1995/02/18 00:47:43 butler Exp butler $ (BRL)"
d1513 1
d1647 1
a1647 1
RT_EXTERN(void rt_cut_it, (struct rt_i *rtip) );
@


11.4
log
@new version of nmg_class_pt_fu_except()
@
text
@d38 1
a38 1
 *  $Header: /n/wolf/m/cad/h/RCS/raytrace.h,v 11.3 1995/02/16 23:55:17 mike Exp butler $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /n/wolf/m/cad/h/RCS/raytrace.h,v 11.3 1995/02/16 23:55:17 mike Exp butler $ (BRL)"
d2203 1
a2203 1
RT_EXTERN(int			nmg_class_pt_fu_except, (point_t pt,
@


11.3
log
@Changed return type of nmg_booltree_evaluate()
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.2 95/02/16 03:43:40 mike Exp Locker: mike $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.2 95/02/16 03:43:40 mike Exp Locker: mike $ (BRL)"
d2203 1
a2203 1
RT_EXTERN(struct fu_pt_info *	nmg_class_pt_fu_except, (point_t pt,
d2207 2
a2208 1
				char *priv, CONST int allhits,
@


11.2
log
@Added td_name
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.1 95/01/04 09:48:32 mike Rel4_4 Locker: mike $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 11.1 95/01/04 09:48:32 mike Rel4_4 Locker: mike $ (BRL)"
d891 1
a891 1
		CONST char	*td_name;	/* If non-null, former name of this object.  Not to be freed. */
d2290 1
a2290 1
RT_EXTERN(struct nmgregion	*nmg_booltree_evaluate, (union tree *tp,
@


11.1
log
@Release_4.4
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.96 94/12/30 00:01:34 mike Exp $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.96 94/12/30 00:01:34 mike Exp $ (BRL)"
d891 1
a891 1
		struct region	*td_pad;	/* unused */
@


10.96
log
@Changed from __STDC__ to HAVE_STDLIB_H
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.95 94/12/29 16:12:33 jra Exp Locker: mike $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.95 94/12/29 16:12:33 jra Exp Locker: mike $ (BRL)"
@


10.95
log
@Added extern CONST char   *rt_vlist_cmd_descriptions[];
@
text
@d38 1
a38 1
 *  $Header: /n/wolf/m/cad/h/RCS/raytrace.h,v 10.94 94/12/27 16:38:51 mike Exp Locker: jra $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /n/wolf/m/cad/h/RCS/raytrace.h,v 10.94 94/12/27 16:38:51 mike Exp Locker: jra $ (BRL)"
d67 1
a67 1
#if __STDC__ || (sgi && mips) || (ultrix && mips)
@


10.94
log
@Bug 247.  Changed memalloc to rt_memalloc
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.93 94/12/27 15:13:40 jra Exp Locker: mike $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.93 94/12/27 15:13:40 jra Exp Locker: mike $ (BRL)"
d2382 1
@


10.93
log
@Changed declaration of rt_label_vlist_verts to include a "mm2local" arg.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.92 94/12/16 17:23:01 mike Exp Locker: jra $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.92 94/12/16 17:23:01 mike Exp Locker: jra $ (BRL)"
d1807 3
a1809 3
/* memalloc.c */
RT_EXTERN(unsigned long memalloc, (struct mem_map **pp, unsigned size) );
RT_EXTERN(unsigned long memget, (struct mem_map **pp, unsigned int size,
d1811 4
a1814 3
RT_EXTERN(void memfree, (struct mem_map **pp, unsigned size, unsigned long addr) );
RT_EXTERN(void mempurge, (struct mem_map **pp) );
RT_EXTERN(void memprint, (struct mem_map **pp) );
@


10.92
log
@GDurf added rt_putchar().
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.91 1994/12/08 17:57:55 jra Exp gdurf $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.91 1994/12/08 17:57:55 jra Exp gdurf $ (BRL)"
d1942 1
a1942 1
				double sz) );
@


10.91
log
@changed rt_g.rtg_jmpbuf to type jmp_buf and modified RT_SETJUMP for CRAY2,
RT_SETJUMP in an "if" must appear alone.
@
text
@d38 1
a38 1
 *  $Header: /n/wolf/m/cad/h/RCS/raytrace.h,v 10.90 94/11/08 03:13:39 mike Exp Locker: jra $
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /n/wolf/m/cad/h/RCS/raytrace.h,v 10.90 94/11/08 03:13:39 mike Exp Locker: jra $ (BRL)"
d1503 1
@


10.90
log
@Changed parallel semaphores from int to long.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.89 94/11/05 04:50:06 mike Exp Locker: mike $
d52 2
d58 1
a58 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.89 94/11/05 04:50:06 mike Exp Locker: mike $ (BRL)"
d1182 1
a1182 1
	long		rtg_jmpbuf[64];	/* for RT_SETJMP.  should be jmp_buf */
d1194 1
a1194 1
#define RT_SETJUMP	(rt_g.rtg_setjmp_valid=1,setjmp((int *)rt_g.rtg_jmpbuf))
@


10.89
log
@Magic must always be LONG, not int.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.88 94/11/05 03:24:07 mike Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.88 94/11/05 03:24:07 mike Exp Locker: mike $ (BRL)"
d1171 5
a1175 5
	int		res_syscall;	/* lock on system calls */
	int		res_worker;	/* lock on work to do */
	int		res_stats;	/* lock on statistics */
	int		res_results;	/* lock on result buffer */
	int		res_model;	/* lock on model growth (splines) */
d1180 1
a1180 1
	int		rtg_jmpbuf[64];	/* for RT_SETJMP.  should be jmp_buf */
d1182 1
@


10.88
log
@Irix 6
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.87 94/11/04 10:56:26 jra Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.87 94/11/04 10:56:26 jra Exp Locker: mike $ (BRL)"
d719 1
a719 1
	int			dbi_magic;	/* magic number */
d941 1
a941 1
	int	magic;				/* magic number */
@


10.87
log
@changed declaration of nmg_pr_eg nmg_pr_eg(CONST long *eg, char *h).
@
text
@d38 1
a38 1
 *  $Header: /n/wolf/m/cad/h/RCS/raytrace.h,v 10.86 94/11/04 05:49:18 mike Exp Locker: jra $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /n/wolf/m/cad/h/RCS/raytrace.h,v 10.86 94/11/04 05:49:18 mike Exp Locker: jra $ (BRL)"
d1041 1
a1041 1
	int		sp_offset;		/* Byte offset in struct */
@


10.86
log
@Irix 6 needs sp_count to be long, not int.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.85 94/10/31 21:30:32 mike Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.85 94/10/31 21:30:32 mike Exp Locker: mike $ (BRL)"
d2153 1
a2153 1
RT_EXTERN(void			nmg_pr_eg, (CONST struct edge_g_lseg *eg, char *h) );
@


10.85
log
@Changed histogram routines to using fastf_t instead of int for hg_min
and hg_max routines.
Fixes bug #155
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.84 94/10/31 20:11:10 butler Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.84 94/10/31 20:11:10 butler Exp Locker: mike $ (BRL)"
d1039 1
a1039 1
	int		sp_count;		/* number of elements */
@


10.84
log
@typo fix
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.83 1994/10/31 20:08:04 butler Exp butler $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.83 1994/10/31 20:08:04 butler Exp butler $ (BRL)"
d1060 6
a1065 5
	int		hg_min;		/* minimum value */
	int		hg_max;		/* maximum value */
	int		hg_nbins;	/* # of bins in hg_bins[] */
	int		hg_clumpsize;	/* (max-min+1)/nbins+1 */
	long		hg_nsamples;	/* total number of samples */
d1068 2
d1076 1
a1076 1
		(_hp)->hg_bins[((_val)-(_hp)->hg_min)/(_hp)->hg_clumpsize]++; \
d1656 9
@


10.83
log
@added extern for nmg_cnurb_to_vlist() (needed in nmg_plot.c)
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.82 1994/10/28 21:48:14 mike Exp butler $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.82 1994/10/28 21:48:14 mike Exp butler $ (BRL)"
d2243 1
a2243 1
RT_EXTERN(void			nmg_cnurb_to_vlist(struct rt_list *vhead,
d2245 1
a2245 1
				int cmd)
@


10.82
log
@Added rt_mapped_file support
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.81 94/10/17 23:40:24 mike Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.81 94/10/17 23:40:24 mike Exp Locker: mike $ (BRL)"
d2243 4
@


10.81
log
@Closes bug #139 from Bill Laut, port to DEC MIPS ULTRIX.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.80 94/09/29 20:53:46 mike Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.80 94/09/29 20:53:46 mike Exp Locker: mike $ (BRL)"
d1178 1
d1313 1
d1397 18
d1857 6
@


10.80
log
@struct directory d_use_hd element, and struct soltab "l2" element added.
This will permit rt_find_identical_solid() to run in linear time,
rather than O(nsolid**2)
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.79 94/09/28 16:17:35 mike Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.79 94/09/28 16:17:35 mike Exp Locker: mike $ (BRL)"
d62 2
d65 1
a65 1
#if (__STDC__ && !apollo) || (sgi && mips)
@


10.79
log
@Eliminated all 'short' variables.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.78 94/09/21 03:31:33 mike Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.78 94/09/21 03:31:33 mike Exp Locker: mike $ (BRL)"
d403 1
d421 2
a422 1
#define RT_SOLTAB_MAGIC	0x92bfcde0
d753 1
@


10.78
log
@Added arg to nmg_manifolds()
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.77 94/09/16 20:45:00 mike Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.77 94/09/16 20:45:00 mike Exp Locker: mike $ (BRL)"
d479 5
a483 5
	short		reg_bit;	/* constant index into Regions[] */
	short		reg_regionid;	/* Region ID code.  If <=0, use reg_aircode */
	short		reg_aircode;	/* Region ID AIR code */
	short		reg_gmater;	/* GIFT Material code */
	short		reg_los;	/* equivalent LOS estimate ?? */
d488 2
a489 2
	short		reg_transmit;	/* flag:  material transmits light */
	short		reg_instnum;	/* instance number, from d_uses */
d672 2
a673 2
		short	bn_len;		/* # of solids in list */
		short	bn_maxlen;	/* # of ptrs allocated to list */
d750 1
a750 1
	short		d_flags;		/* flags */
d911 1
a911 1
	short		anm_op;			/* ANM_RSTACK, ANM_RARC... */
d922 1
a922 1
	short		anp_op;			/* RT_ANP_RBOTH, etc */
d939 1
a939 1
	short		an_type;		/* AN_MATRIX, AN_COLOR... */
@


10.77
log
@nmg_move_eg() became nmg_jeg().
Removed edge_g crutch.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.76 94/09/16 20:21:36 mike Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.76 94/09/16 20:21:36 mike Exp Locker: mike $ (BRL)"
d2135 2
a2136 1
RT_EXTERN(int			nmg_dangling_face, (CONST struct faceuse *fu));
@


10.76
log
@Added RT_BADNUM() and RT_BADVEC(), some comments, and an extern.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.75 94/09/13 20:37:49 mike Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.75 94/09/13 20:37:49 mike Exp Locker: mike $ (BRL)"
d1943 2
a1996 1
RT_EXTERN(void			nmg_move_eg, (struct edge_g *old_eg, struct edge_g *new_eg) );
d2110 1
a2110 1
RT_EXTERN(void			nmg_pr_eg, (CONST struct edge_g *eg, char *h) );
d2254 1
a2254 1
RT_EXTERN(struct edge_g		*nmg_face_cutjoin, (
d2258 1
a2258 1
				struct edge_g *eg,
@


10.75
log
@Changed a return code.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.74 94/09/10 04:35:00 mike Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.74 94/09/10 04:35:00 mike Exp Locker: mike $ (BRL)"
d86 3
d1308 6
a1313 1
/* Note that RT_GET_VLIST and RT_FREE_VLIST are non-PARALLEL */
d1343 2
d2028 2
@


10.74
log
@Converted NMG data structures to have edge_g pointer in edgeuse, not edge.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.73 94/09/02 01:12:45 mike Exp $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.73 94/09/02 01:12:45 mike Exp $ (BRL)"
d1918 1
a1918 1
RT_EXTERN(void			nmg_use_edge_g, (struct edgeuse *eu, long *eg) );
@


10.73
log
@Fallout from NMG face_g change.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.72 94/09/01 05:44:29 gdurf Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.72 94/09/01 05:44:29 gdurf Exp Locker: mike $ (BRL)"
d1917 2
a1918 2
RT_EXTERN(void			nmg_edge_g, (struct edge *e) );
RT_EXTERN(void			nmg_use_edge_g, (struct edge *e, struct edge_g *eg) );
d1929 2
a1930 1
RT_EXTERN(void			nmg_moveeu, (struct edgeuse *eudst, struct edgeuse *eusrc) );
d1976 2
a1977 2
RT_EXTERN(struct edgeuse	*nmg_eusplit, (struct vertex *v, struct edgeuse *oldeu) );
RT_EXTERN(struct edgeuse	*nmg_esplit, (struct vertex *v, struct edgeuse *eu) );
d1985 1
a1985 1
RT_EXTERN(void			nmg_move_eg, (struct edge_g *old_eg, struct edge_g *new_eg, struct shell *s) );
d2105 1
@


10.72
log
@Made function declaration consistent with reality
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.71 1994/08/22 15:32:54 mike Exp gdurf $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.71 1994/08/22 15:32:54 mike Exp gdurf $ (BRL)"
d2088 1
a2088 1
RT_EXTERN(void			nmg_pr_fg, (CONST struct face_g *fg, char *h) );
d2287 2
d2290 2
a2291 1
				(CONST struct nmg_struct_counts *ctr, char *str) );
d2294 1
a2294 1
				struct model *m) );
@


10.71
log
@Added rt_get_timer()
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.70 94/08/09 23:03:22 mike Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.70 94/08/09 23:03:22 mike Exp Locker: mike $ (BRL)"
d2288 1
a2288 1
				(struct nmg_struct_counts *ctr, char *str) );
@


10.70
log
@Added ID_HF
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.69 94/08/04 20:03:29 gdurf Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.69 94/08/04 20:03:29 gdurf Exp Locker: mike $ (BRL)"
d1502 2
@


10.69
log
@added missing CONST modifierrr
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.68 1994/07/01 23:35:45 mike Exp gdurf $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.68 1994/07/01 23:35:45 mike Exp gdurf $ (BRL)"
d449 1
d451 1
a451 1
#define ID_MAXIMUM	23	/* Maximum defined ID_xxx value */
d1976 2
@


10.68
log
@externs.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.67 94/06/30 19:39:12 mike Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.67 94/06/30 19:39:12 mike Exp Locker: mike $ (BRL)"
d1524 1
a1524 1
RT_EXTERN(void mat_ae_vec, (fastf_t *azp, fastf_t *elp, vect_t src) );
@


10.67
log
@Changed calling sequence to nmg_face_cutjoin()
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.66 94/06/23 22:42:24 butler Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.66 94/06/23 22:42:24 butler Exp Locker: mike $ (BRL)"
d1767 1
d2025 2
a2026 1
RT_EXTERN(CONST struct edgeuse *nmg_find_edge_between_2fu, (CONST struct faceuse *fu1, CONST struct faceuse *fu2));
@


10.66
log
@added prototype for nmg_model_bb()
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.65 94/05/24 17:27:35 butler Exp Locker: butler $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.65 94/05/24 17:27:35 butler Exp Locker: butler $ (BRL)"
d2024 1
d2232 1
a2232 1
RT_EXTERN(void			nmg_face_cutjoin, (
d2236 1
@


10.65
log
@added extern for nmg_class_pt_fu_except()
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.64 1994/05/10 08:15:26 mike Exp butler $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.64 1994/05/10 08:15:26 mike Exp butler $ (BRL)"
d1986 2
@


10.64
log
@Added magic number to union tree, properly.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.63 94/05/10 06:24:40 mike Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.63 94/05/10 06:24:40 mike Exp Locker: mike $ (BRL)"
d2126 8
@


10.63
log
@Added magic number to union tree.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.62 94/05/09 23:16:28 mike Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.62 94/05/09 23:16:28 mike Exp Locker: mike $ (BRL)"
d856 2
a857 2
	long	magic;
	int	tr_op;		/* Operation */
d859 1
d866 1
d872 1
d878 1
d889 1
@


10.62
log
@Added st_uses
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.61 94/04/25 00:19:58 butler Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.61 94/04/25 00:19:58 butler Exp Locker: mike $ (BRL)"
d856 1
d888 2
@


10.61
log
@fixed nmg_m_reindex() and nmg_merge_models() prototypes
@
text
@d38 1
a38 1
 *  $Header: /n/wolf/m/cad/h/RCS/raytrace.h,v 10.60 94/04/24 23:38:25 butler Exp Locker: butler $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /n/wolf/m/cad/h/RCS/raytrace.h,v 10.60 94/04/24 23:38:25 butler Exp Locker: butler $ (BRL)"
d400 1
@


10.60
log
@added extra parameter to nmg_m_reindex() prototype
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.59 94/04/22 05:27:52 mike Exp Locker: butler $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.59 94/04/22 05:27:52 mike Exp Locker: butler $ (BRL)"
d2258 1
a2258 1
RT_EXTERN(void			nmg_m_reindex, (struct model *m, int newindex) );
d2264 2
a2265 1

@


10.59
log
@Added new routines from plane.c, and V2PRINT macro
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.58 94/04/19 02:41:12 butler Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.58 94/04/19 02:41:12 butler Exp Locker: mike $ (BRL)"
d2258 1
a2258 1
RT_EXTERN(void			nmg_m_reindex, (struct model *m) );
@


10.58
log
@fixed prototypes for nmg_vlblock_lu()
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.57 94/04/19 01:45:50 butler Exp Locker: butler $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.57 94/04/19 01:45:50 butler Exp Locker: butler $ (BRL)"
d1338 1
d1341 1
d1774 7
a1780 3
RT_EXTERN(double rt_dist_line_point, (CONST point_t pt, CONST vect_t dir,
	CONST point_t a) );
RT_EXTERN(double rt_dist_line_origin, (CONST point_t pt, CONST vect_t dir) );
d1799 6
@


10.57
log
@changed prototype of nmg_vlblock_eu() to match actual function
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.56 94/04/05 04:23:17 cjohnson Exp Locker: butler $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.56 94/04/05 04:23:17 cjohnson Exp Locker: butler $ (BRL)"
d2129 2
a2130 2
				int red, int green, int blue, int fancy,
				int loopnum) );
d2133 2
a2134 1
				int red, int green, int blue, int fancy) );
@


10.56
log
@more RT_EXTERNS for new routines.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.55 1994/04/05 02:14:15 cjohnson Exp cjohnson $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.55 1994/04/05 02:14:15 cjohnson Exp cjohnson $ (BRL)"
d2129 2
a2130 1
				int red, int green, int blue, int fancy) );
@


10.55
log
@Add RT_EXTERNs for new db_anim code.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.54 1994/03/31 23:37:48 cjohnson Exp cjohnson $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.54 1994/03/31 23:37:48 cjohnson Exp cjohnson $ (BRL)"
d1612 1
@


10.54
log
@Add magic number field to struct animate
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.53 1994/03/22 19:17:55 mike Exp cjohnson $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.53 1994/03/22 19:17:55 mike Exp cjohnson $ (BRL)"
d1722 5
@


10.53
log
@Added more externs,
shuffled a bunch of routines into vlist.c
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.52 94/03/18 00:35:38 mike Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.52 94/03/18 00:35:38 mike Exp Locker: mike $ (BRL)"
d923 1
a923 1
	/* XXX magic */
d939 2
@


10.52
log
@Lee modified VLIST macros to do stricter checking.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.51 1994/03/12 01:41:42 butler Exp butler $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.51 1994/03/12 01:41:42 butler Exp butler $ (BRL)"
a1814 1
RT_EXTERN(void rt_vlist_to_uplot, (FILE *fp, struct rt_list *vhead));
d1833 7
a1839 1
RT_EXTERN(void rt_vlist_export, (struct rt_vls *vls, struct rt_list *hp,
d1841 2
a1842 1
RT_EXTERN(void rt_vlist_import, (struct rt_list *hp, struct rt_vls *namevls,
d1844 9
d1854 1
d1970 3
d1998 5
a2099 4
RT_EXTERN(struct rt_vlblock *	rt_vlblock_init, () );
RT_EXTERN(void			rt_vlblock_free, (struct rt_vlblock *vbp) );
RT_EXTERN(struct rt_list *	rt_vlblock_find, (struct rt_vlblock *vbp,
				int r, int g, int b) );
d2136 1
a2136 1
				CONST struct shell *s) );
@


10.51
log
@Added magic number checking to the VLIST macros RT_ADD_VLIST() and
RT_FREE_VLIST()
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.50 1994/03/11 20:05:55 butler Exp butler $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.50 1994/03/11 20:05:55 butler Exp butler $ (BRL)"
d1307 1
a1307 1
	RT_CK_VLIST( (hd) ); \
d1312 3
a1314 2
	register struct rt_vlist *_vp = RT_LIST_LAST( rt_vlist, (hd) ); \
	RT_CK_VLIST(_vp); \
d1969 1
@


10.50
log
@added RT_CK_VLBLOCK and delete the prototype for nmg_lu_of_vu()
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.49 1994/03/04 18:15:13 cjohnson Exp butler $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.49 1994/03/04 18:15:13 cjohnson Exp butler $ (BRL)"
d1283 1
d1306 4
a1309 1
#define RT_FREE_VLIST(hd)	RT_LIST_APPEND_LIST( &rt_g.rtg_vlfree, (hd) )
d1313 1
d1331 1
a1331 1
#define RT_CK_VLBLOCK(_p)	RT_CKMAG(_p, RT_VLBLOCK_MAGIC, "rt_vlblock")
@


10.49
log
@Add grip and Joint pseudo solids.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.48 1994/02/24 06:41:30 butler Exp cjohnson $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.48 1994/02/24 06:41:30 butler Exp cjohnson $ (BRL)"
d1326 1
a1326 1

a1950 1
RT_EXTERN(struct loopuse	*nmg_lu_of_vu, (CONST struct vertexuse *vu) );
@


10.48
log
@Removed prototype for functions internal to nmg_plot.c
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.47 94/02/01 21:59:28 mike Exp Locker: butler $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.47 94/02/01 21:59:28 mike Exp Locker: butler $ (BRL)"
d446 2
d449 1
a449 1
#define ID_MAXIMUM	21	/* Maximum defined ID_xxx value */
@


10.47
log
@Changed calling sequence of nmg_split_touchingloops() to add tol.
Added nmg_join_touchingloops().
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.46 94/01/25 09:45:51 mike Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.46 94/01/25 09:45:51 mike Exp Locker: mike $ (BRL)"
a2105 2
				long *b, CONST struct edgeuse *eu) );
RT_EXTERN(void			nmg_pl_edges_in_2_shells, (FILE *fd,
@


10.46
log
@Updated a bunch of NMG function declarations.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.45 93/12/22 06:20:54 mike Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.45 93/12/22 06:20:54 mike Exp Locker: mike $ (BRL)"
d1904 3
a1906 1
RT_EXTERN(void			nmg_split_touchingloops, (struct loopuse *lu) );
@


10.45
log
@Changed calling sequence to nmg_lu_reorient(), added some more
function declarations.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.44 93/11/18 02:19:34 butler Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.44 93/11/18 02:19:34 butler Exp Locker: mike $ (BRL)"
d1759 4
d1929 1
d1932 1
d1934 3
a1936 3
RT_EXTERN(struct shell		*nmg_find_s_of_lu, (struct loopuse *lu) );
RT_EXTERN(struct shell		*nmg_find_s_of_eu, (struct edgeuse *eu) );
RT_EXTERN(struct shell		*nmg_find_s_of_vu, (struct vertexuse *vu) );
d1938 6
a1943 2
RT_EXTERN(struct faceuse	*nmg_find_fu_of_eu, (struct edgeuse *eu));
RT_EXTERN(struct faceuse	*nmg_find_fu_of_vu, (struct vertexuse *vu) );
d1945 3
a1947 2
RT_EXTERN(struct loopuse	*nmg_find_lu_of_vu, (struct vertexuse *vu) );
RT_EXTERN(struct loopuse	*nmg_lu_of_vu, (struct vertexuse *vu) );
d1951 1
d1953 1
d1957 3
d1963 6
a1968 1
RT_EXTERN(struct edgeuse	*nmg_radial_face_edge_in_shell, (struct edgeuse *eu) );
d1970 1
d1973 4
d1980 4
a1999 4
RT_EXTERN(struct vertex		*nmg_find_pt_in_shell, (CONST struct shell *s,
				CONST point_t pt, CONST struct rt_tol *tol) );
RT_EXTERN(struct faceuse	*nmg_find_fu_with_fg_in_s, (CONST struct shell *s1,
				CONST struct faceuse *fu2));
d2001 6
a2006 4
RT_EXTERN(void			nmg_region_vertex_list, (struct nmg_ptbl *tab,
				struct nmgregion *r));
RT_EXTERN(void			nmg_region_edge_list, (struct nmg_ptbl *tab,
				struct nmgregion *r));
@


10.44
log
@Changed tol arguments to triangulation routines to be CONST.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.43 93/11/18 01:49:57 butler Exp Locker: butler $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.43 93/11/18 01:49:57 butler Exp Locker: butler $ (BRL)"
d1876 4
d1910 1
a1910 1
				CONST plane_t norm, CONST struct rt_tol *tol) );
d1972 2
a2138 2
RT_EXTERN(void			nmg_lu_reorient, (struct loopuse *lu,
				CONST plane_t norm, CONST struct rt_tol *tol) );
@


10.43
log
@Added nmg_triangulate_model() and nmg_triangulate_fu() prototypes (from
nmg_tri.c)
@
text
@d38 1
a38 1
 *  $Header: /n/wolf/m/cad/h/RCS/raytrace.h,v 10.42 93/11/18 01:37:46 mike Exp Locker: butler $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /n/wolf/m/cad/h/RCS/raytrace.h,v 10.42 93/11/18 01:37:46 mike Exp Locker: butler $ (BRL)"
d2009 2
a2010 2
RT_EXTERN(void			nmg_triangulate_model, (struct model *m, struct rt_tol   *tol) );
RT_EXTERN(void			nmg_triangulate_fu, (struct faceuse *fu, struct rt_tol   *tol) );
@


10.42
log
@Bounding box routines all take rt_tol structs now.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.41 93/11/12 23:34:59 mike Exp $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.41 93/11/12 23:34:59 mike Exp $ (BRL)"
d2007 4
@


10.41
log
@ANSI lint, added some externs.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.40 93/11/10 04:03:36 cjohnson Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.40 93/11/10 04:03:36 cjohnson Exp Locker: mike $ (BRL)"
d1858 5
a1862 5
RT_EXTERN(void			nmg_loop_g, (struct loop *l) );
RT_EXTERN(void			nmg_face_g, (struct faceuse *fu, plane_t p) );
RT_EXTERN(void			nmg_face_bb, (struct face *f) );
RT_EXTERN(void			nmg_shell_a, (struct shell *s) );
RT_EXTERN(void			nmg_region_a, (struct nmgregion *r) );
d2003 1
a2003 1
RT_EXTERN(void			nmg_rebound, (struct model *m) );
@


10.40
log
@No need for the name to be passed to xform.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.39 1993/11/09 20:59:22 cjohnson Exp cjohnson $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.39 1993/11/09 20:59:22 cjohnson Exp cjohnson $ (BRL)"
d1428 1
a1428 1
			CONST int /*free*/));
d2091 3
d2109 2
d2196 4
@


10.39
log
@Add ft_xform to the function table to allow in memory transformations.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.38 1993/10/22 22:26:43 mike Exp cjohnson $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.38 1993/10/22 22:26:43 mike Exp cjohnson $ (BRL)"
d1428 1
a1428 1
			CONST int /*free*/, CONST char * /*name*/));
@


10.38
log
@nmg_eups() and nmg_lups() eliminated, in favor of
nmg_find_s_of_lu() and nmg_find_s_of_eu().
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.37 93/10/02 01:06:43 mike Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.37 93/10/02 01:06:43 mike Exp Locker: mike $ (BRL)"
d1426 3
@


10.37
log
@Corrected declaration of nmg_stash_model_to_file().
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.36 93/10/01 20:29:13 butler Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.36 93/10/01 20:29:13 butler Exp Locker: mike $ (BRL)"
d1921 3
a1923 2
RT_EXTERN(struct shell		*nmg_lups, (struct loopuse *lu) );
RT_EXTERN(struct shell		*nmg_eups, (struct edgeuse *eu) );
d1944 3
a1946 2
RT_EXTERN(struct vertexuse	*nmg_find_pt_in_face, (CONST point_t pt,
				CONST struct faceuse *fu, CONST struct rt_tol *tol) );
d2155 3
@


10.36
log
@Added externs for NMG ray-tracing support
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.35 93/08/12 22:27:20 mike Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.35 93/08/12 22:27:20 mike Exp Locker: mike $ (BRL)"
d1969 1
a1969 4
/* From nmg_misc.c */
RT_EXTERN(int			nmg_tbl, (struct nmg_ptbl *b, int func, long *p) );
RT_EXTERN(void			nmg_purge_unwanted_intersection_points, (struct nmg_ptbl *vert_list, CONST struct faceuse *fu, CONST struct rt_tol *tol));
RT_EXTERN(int			nmg_in_or_ref, (struct vertexuse *vu, struct nmg_ptbl *b) );
d1993 5
d2000 2
a2120 2
RT_EXTERN(void			nmg_stash_model_to_file, (CONST char *filename,
				struct model *m, CONST char *title) );
@


10.35
log
@Added CONST
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.34 93/07/20 21:16:43 mike Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.34 93/07/20 21:16:43 mike Exp Locker: mike $ (BRL)"
d1919 14
d1936 5
a1960 5
RT_EXTERN(struct edgeuse	*nmg_find_eu_with_vu_in_lu, (CONST struct loopuse *lu,
				CONST struct vertexuse *vu) );
RT_EXTERN(int			nmg_loop_is_a_crack, (CONST struct loopuse *lu) );
RT_EXTERN(int			nmg_loop_is_ccw, (CONST struct loopuse *lu,
				CONST plane_t norm, CONST struct rt_tol *tol) );
a1962 6
RT_EXTERN(int			nmg_shell_is_empty, (CONST struct shell *s) );
RT_EXTERN(struct loopuse	*nmg_lu_of_vu, (struct vertexuse *vu) );
RT_EXTERN(struct shell		*nmg_lups, (struct loopuse *lu) );
RT_EXTERN(struct shell		*nmg_eups, (struct edgeuse *eu) );
RT_EXTERN(CONST struct edgeuse	*nmg_faceradial, (CONST struct edgeuse *eu) );
RT_EXTERN(struct edgeuse	*nmg_radial_face_edge_in_shell, (struct edgeuse *eu) );
d1964 5
a1996 2
RT_EXTERN(struct faceuse	*nmg_find_fu_of_vu, (struct vertexuse *vu) );
RT_EXTERN(struct loopuse	*nmg_find_lu_of_vu, (struct vertexuse *vu) );
d2074 2
d2077 5
a2081 1
				struct faceuse *fu2) );
d2117 1
a2117 1
RT_EXTERN(void			nmg_stash_model_to_file, (char *filename,
d2134 2
a2136 3
RT_EXTERN(struct hitmiss *	nmg_isect_ray_model, (struct xray *rp,
					vect_t invdir, struct model *m,
					struct rt_tol *tol) );
d2143 1
a2143 1

d2148 3
a2150 3
RT_EXTERN(int			nmg_check_radial, (CONST struct edgeuse *eu));
RT_EXTERN(int			nmg_ck_closed_surf, (CONST struct shell *s) );
RT_EXTERN(int			nmg_ck_closed_region, (CONST struct nmgregion *r) );
@


10.34
log
@Made args to nmg_findeu() CONST
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.33 93/07/20 21:14:39 mike Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.33 93/07/20 21:14:39 mike Exp Locker: mike $ (BRL)"
d1768 2
a1769 2
RT_EXTERN(double		rt_angle_measure, (vect_t vec, vect_t x_dir,
				vect_t	y_dir));
@


10.33
log
@Comment within comment.
Made offsetofarray() squeeky clean, for ANSI compilers.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.32 93/06/04 16:32:43 butler Exp Locker: butler $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.32 93/06/04 16:32:43 butler Exp Locker: butler $ (BRL)"
d1919 2
a1920 2
RT_EXTERN(struct edgeuse	*nmg_findeu, (struct vertex *v1, struct vertex *v2,
				struct shell *s, struct edgeuse *eup,
@


10.32
log
@MODEL_SEEN functionality is folded in with NMG_H definition
@
text
@d26 6
a31 6
 *	#include "machine.h"	/* For fastf_t definition on this machine *_/
 *	#include "vmath.h"	/* For vect_t definition *_/
 *	#include "rtlist.h"	/* OPTIONAL, auto-included by raytrace.h *_/
 *	#include "rtstring.h"	/* OPTIONAL, auto-included by raytrace.h *_/
 *	#include "db.h"		/* OPTIONAL, precedes raytrace.h when used *_/
 *	#include "nmg.h"	/* OPTIONAL, precedes raytrace.h when used *_/
d33 1
a33 1
 *	#include "nurb.h"	/* OPTIONAL, follows raytrace.h when used *_/
d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.31 93/05/20 17:12:21 mike Exp Locker: butler $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.31 93/05/20 17:12:21 mike Exp Locker: butler $ (BRL)"
d1007 1
a1007 1
#	define offsetofarray(_t, _m)	offsetof(_t, _m)
d1984 2
@


10.31
log
@Changed rt_isect_ray_plane() to rt_isect_line3_plane().
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.30 93/04/03 04:38:18 mike Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.30 93/04/03 04:38:18 mike Exp Locker: mike $ (BRL)"
d811 1
a811 1
#if defined(MODEL_DEFINED)
d873 1
a873 1
#if defined(MODEL_DEFINED) && defined(NMGREGION_DEFINED)
d1400 1
a1400 1
#if defined(MODEL_DEFINED) && defined(NMGREGION_DEFINED)
d2112 13
@


10.30
log
@Added nmg_booltree_leaf_tess(), nmg_booltree_evaluate(),
nmg_two_region_vertex_fuse().
Changed tol arg to tesselators and plot routines to be CONST.
Added elements to db_full_path to support the nmg_booltree_*() routines.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.29 93/04/03 01:59:33 mike Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.29 93/04/03 01:59:33 mike Exp Locker: mike $ (BRL)"
d1743 2
a1744 2
RT_EXTERN(int rt_isect_ray_plane, (fastf_t *dist, CONST point_t pt,
	CONST vect_t dir, CONST plane_t plane) );
@


10.29
log
@nmg_mvu() and nmg_mvvu() are now static to nmg_mk.c
nmg_find_vu_in_face() has changed name to nmg_find_pt_in_face()
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.28 93/04/02 23:45:23 mike Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.28 93/04/02 23:45:23 mike Exp Locker: mike $ (BRL)"
d772 2
d809 7
d1395 1
a1395 1
			struct rt_tol * /*tol*/));
d1406 1
a1406 1
			struct rt_tol * /*tol*/));
d1413 1
a1413 1
			struct rt_tol * /*tol*/));
d2071 7
@


10.28
log
@nmg_kvu() also returns int now.
nmg_ensure_vertex() has gone away in favor of
nmg_is_vertex_a_selfloop_in_shell()
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.27 93/04/02 02:26:58 mike Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.27 93/04/02 02:26:58 mike Exp Locker: mike $ (BRL)"
a1829 2
RT_EXTERN(struct vertexuse	*nmg_mvu, (struct vertex *v, long *upptr) );
RT_EXTERN(struct vertexuse	*nmg_mvvu, (long *upptr) );
d1915 1
a1915 1
RT_EXTERN(struct vertexuse	*nmg_find_vu_in_face, (CONST point_t pt,
@


10.27
log
@Shuffled declarations for nmg_mk.c, added missing routines,
added return codes for most nmg_k*() routines.
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.26 93/04/01 03:56:07 mike Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.26 93/04/01 03:56:07 mike Exp Locker: mike $ (BRL)"
d1836 1
a1836 1
RT_EXTERN(void			nmg_kvu, (struct vertexuse *vu) );
a1858 2
RT_EXTERN(void			nmg_ensure_vertex, (struct vertex *v,
				struct shell *s) );
d1923 2
@


10.26
log
@Added #include sequencing
Added magic number for "struct directory".
A few db_() routines got CONST args
@
text
@d38 1
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.25 93/03/27 00:03:37 mike Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.25 93/03/27 00:03:37 mike Exp Locker: mike $ (BRL)"
d1823 1
a1823 1
RT_EXTERN(struct model		*nmg_find_model, (CONST long *magic_p) );
d1827 3
a1829 1
RT_EXTERN(struct shell 	*nmg_msv, (struct nmgregion *r_p) );
d1835 1
a1835 1
RT_EXTERN(void			nmg_movevu, (struct vertexuse *vu, struct vertex *v) );
d1837 2
a1838 3
RT_EXTERN(void			nmg_kfu, (struct faceuse *fu1) );
RT_EXTERN(void			nmg_klu, (struct loopuse *lu1) );
RT_EXTERN(struct faceuse	*nmg_mf, (struct loopuse *lu1) );
d1840 2
a1841 2
RT_EXTERN(void			nmg_ks, (struct shell *s) );
RT_EXTERN(void			nmg_kr, (struct nmgregion *r) );
d1843 2
a1844 1
RT_EXTERN(void			nmg_vertex_gv, (struct vertex *v, pointp_t pt) );
d1846 2
d1853 1
a1853 1
RT_EXTERN(struct loopuse	*nmg_mlv, (long *magic, struct vertex *v, int orientation) );
d1855 4
a1860 2
RT_EXTERN(int			nmg_demote_eu, (struct edgeuse *eu) );
RT_EXTERN(void			nmg_moveeu, (struct edgeuse *eudst, struct edgeuse *eusrc) );
d1913 1
@


10.25
log
@Most routines in nmg_misc.c get CONST arguments now.
@
text
@d8 1
a8 1
 *  as well as the external (interface) data structures.  These are
d10 1
a10 1
 *  the internal data structures are subject to change.
d16 2
a17 3
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
d20 1
a20 1
 *	This software is Copyright (C) 1985 by the United States Army.
d23 16
a38 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.24 93/03/26 23:39:45 mike Exp Locker: mike $
d56 1
a56 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.24 93/03/26 23:39:45 mike Exp Locker: mike $ (BRL)"
d735 1
d746 2
d765 1
d897 1
d912 1
d1265 1
a1265 1
	struct rt_list	l;
d1646 1
a1646 1
RT_EXTERN(struct directory *db_lookup,( struct db_i *, char *name, int noisy ) );
d1648 1
a1648 1
RT_EXTERN(struct directory *db_diradd, ( struct db_i *, char *name, long laddr,
d1652 3
@


10.24
log
@Changed nmg_eu_with_vu_in_lu to nmg_find_eu_with_vu_in_lu().
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.23 93/03/26 23:22:31 mike Exp Locker: mike $
d42 1
a42 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.23 93/03/26 23:22:31 mike Exp Locker: mike $ (BRL)"
d1921 1
a1921 1
RT_EXTERN(void			nmg_purge_unwanted_intersection_points, (struct nmg_ptbl *vert_list, struct faceuse *fu));
d1924 21
a1944 21
RT_EXTERN(void			nmg_pr_orient, (int orientation, char *h) );
RT_EXTERN(void			nmg_pr_m, (struct model *m) );
RT_EXTERN(void			nmg_pr_r, (struct nmgregion *r, char *h) );
RT_EXTERN(void			nmg_pr_sa, (struct shell_a *sa, char *h) );
RT_EXTERN(void			nmg_pr_lg, (struct loop_g *lg, char *h) );
RT_EXTERN(void			nmg_pr_fg, (struct face_g *fg, char *h) );
RT_EXTERN(void			nmg_pr_s, (struct shell *s, char *h) );
RT_EXTERN(void			nmg_pr_f, (struct face *f, char *h) );
RT_EXTERN(void			nmg_pr_fu, (struct faceuse *fu, char *h) );
RT_EXTERN(void			nmg_pr_fu_briefly, (struct faceuse *fu,	char *h) );
RT_EXTERN(void			nmg_pr_l, (struct loop *l, char *h) );
RT_EXTERN(void			nmg_pr_lu, (struct loopuse *lu, char *h) );
RT_EXTERN(void			nmg_pr_lu_briefly, (struct loopuse *lu, char *h) );
RT_EXTERN(void			nmg_pr_eg, (struct edge_g *eg, char *h) );
RT_EXTERN(void			nmg_pr_e, (struct edge *e, char *h) );
RT_EXTERN(void			nmg_pr_eu, (struct edgeuse *eu, char *h) );
RT_EXTERN(void			nmg_pr_eu_briefly, (struct edgeuse *eu, char *h) );
RT_EXTERN(void			nmg_pr_vg, (struct vertex_g *vg, char *h) );
RT_EXTERN(void			nmg_pr_v, (struct vertex *v, char *h) );
RT_EXTERN(void			nmg_pr_vu, (struct vertexuse *vu, char *h) );
RT_EXTERN(void			nmg_pr_vu_briefly, (struct vertexuse *vu, char *h) );
d1947 1
a1947 1
RT_EXTERN(void			nmg_count_shell_kids, (struct model *m, unsigned long *total_wires, unsigned long *total_faces, unsigned long *total_points));
@


10.23
log
@ Changed nmg_find_loop_in_facelist() et.al. to nmg_is_loop_in_facelist().
Shuffled some more routines around between modules.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.22 93/03/26 22:15:14 mike Exp Locker: mike $
d42 1
a42 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.22 93/03/26 22:15:14 mike Exp Locker: mike $ (BRL)"
d1905 1
a1905 1
RT_EXTERN(struct edgeuse	*nmg_eu_with_vu_in_lu, (CONST struct loopuse *lu,
@


10.22
log
@Noted reorganization of nmg_mod.c, nmg_info.c
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.21 93/03/26 21:28:11 mike Exp Locker: mike $
d42 1
a42 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.21 93/03/26 21:28:11 mike Exp Locker: mike $ (BRL)"
d1891 1
a1891 1
RT_EXTERN(int			nmg_find_vertex_in_edgelist, (CONST struct vertex *v,
d1893 1
a1893 1
RT_EXTERN(int			nmg_find_vertex_in_looplist, (CONST struct vertex *v,
d1895 1
a1895 1
RT_EXTERN(int			nmg_find_vertex_in_facelist, (CONST struct vertex *v,
d1897 1
a1897 1
RT_EXTERN(int			nmg_find_edge_in_edgelist, (CONST struct edge *e,
d1899 1
a1899 1
RT_EXTERN(int			nmg_find_edge_in_looplist, (CONST struct edge *e,
d1901 1
a1901 1
RT_EXTERN(int			nmg_find_edge_in_facelist, (CONST struct edge *e,
d1903 1
a1903 1
RT_EXTERN(int			nmg_find_loop_in_facelist, (CONST struct loop *l,
d1912 6
a1944 9
RT_EXTERN(int			nmg_check_radial, (struct edgeuse *eu));
RT_EXTERN(int			nmg_ck_closed_surf, (struct shell *s) );
RT_EXTERN(int			nmg_ck_closed_region, (struct nmgregion *r) );
RT_EXTERN(struct shell		*nmg_polytonmg, (FILE *fp, struct nmgregion *r, CONST struct rt_tol *tol) );
RT_EXTERN(struct loopuse	*nmg_lu_of_vu, (struct vertexuse *vu) );
RT_EXTERN(struct shell		*nmg_lups, (struct loopuse *lu) );
RT_EXTERN(struct shell		*nmg_eups, (struct edgeuse *eu) );
RT_EXTERN(CONST struct edgeuse	*nmg_faceradial, (CONST struct edgeuse *eu) );
RT_EXTERN(struct edgeuse	*nmg_radial_face_edge_in_shell, (struct edgeuse *eu) );
d2073 3
@


10.21
log
@Changed nmg_merge_2faces() to nmg_jf().
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.20 93/03/26 18:23:59 mm Exp Locker: mike $
d42 1
a42 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.20 93/03/26 18:23:59 mm Exp Locker: mike $ (BRL)"
d1831 3
a1833 1
/* nmg_eu_sq */
d1836 5
a1840 1
RT_EXTERN(int			nmg_fu_planeeqn, (struct faceuse *fu, CONST struct rt_tol *tol) );
d1843 28
a1870 2

RT_EXTERN(struct faceuse	*nmg_cmface, (struct shell *s, struct vertex **vt[], int n) );
a1871 4
RT_EXTERN(void			nmg_moveeu, (struct edgeuse *eudst, struct edgeuse *eusrc) );
RT_EXTERN(void			nmg_unglueedge, (struct edgeuse *eu) );
RT_EXTERN(void			nmg_jv, (struct vertex *v1, struct vertex *v2) );
RT_EXTERN(void	 		nmg_moveltof, (struct faceuse *fu, struct shell *s) );
d1876 11
d1905 2
a1906 32
RT_EXTERN(void			nmg_gluefaces, (struct faceuse *fulist[], int n) );
RT_EXTERN(struct edgeuse	*nmg_findeu, (struct vertex *v1, struct vertex *v2,
				struct shell *s, struct edgeuse *eup,
				int dangling_only) );
RT_EXTERN(void			nmg_jl, (struct loopuse *lu, struct edgeuse *eu) );
RT_EXTERN(struct vertexuse	*nmg_join_2loops, (struct vertexuse *vu1, struct vertexuse *vu2) );
RT_EXTERN(struct vertexuse	*nmg_join_singvu_loop, (struct vertexuse *vu1, struct vertexuse *vu2) );
RT_EXTERN(struct vertexuse	*nmg_join_2singvu_loops, (struct vertexuse *vu1, struct vertexuse *vu2) );
RT_EXTERN(void			nmg_simplify_loop, (struct loopuse *lu) );
RT_EXTERN(int			nmg_kill_snakes, (struct loopuse *lu) );
RT_EXTERN(int			nmg_simplify_face, (struct faceuse *fu) );
RT_EXTERN(void			nmg_simplify_shell, (struct shell *s) );
RT_EXTERN(struct loopuse	*nmg_cut_loop, (struct vertexuse *vu1, struct vertexuse *vu2) );
RT_EXTERN(struct loopuse	*nmg_split_lu_at_vu, (struct loopuse *lu, struct vertexuse *vu) );
RT_EXTERN(void			nmg_split_touchingloops, (struct loopuse *lu) );
RT_EXTERN(void			nmg_move_fu_fu, (struct faceuse *dest, struct faceuse *src) );
RT_EXTERN(void			nmg_reverse_face, (struct faceuse *fu) );
RT_EXTERN(void			nmg_mv_fu_between_shells, (struct shell *dest,
				struct shell *src, struct faceuse *fu) );
RT_EXTERN(void			nmg_mv_lu_between_shells, (struct shell *dest,
				struct shell *src, struct loopuse *lu) );
RT_EXTERN(void			nmg_mv_eu_between_shells, (struct shell *dest,
				struct shell *src, struct edgeuse *eu) );
RT_EXTERN(void			nmg_mv_vu_between_shells, (struct shell *dest,
				struct shell *src, struct vertexuse *vu) );
RT_EXTERN(void			nmg_jf, (struct faceuse *dest_fu,
				struct faceuse *src_fu) );
RT_EXTERN(struct edgeuse	*nmg_eu_with_vu_in_lu, (struct loopuse *lu, struct vertexuse *vu) );
RT_EXTERN(void			nmg_move_eg, (struct edge_g *old_eg, struct edge_g *new_eg, struct shell *s) );
RT_EXTERN(struct loopuse	*nmg_dup_loop, (struct loopuse *lu,
				long *parent, long **trans_tbl) );
RT_EXTERN(struct faceuse	*nmg_dup_face, (struct faceuse *fu, struct shell *s) );
d1910 2
a1911 3
RT_EXTERN(void			nmg_set_lu_orientation, (struct loopuse *lu, int is_opposite) );
RT_EXTERN(void			nmg_lu_reorient, (struct loopuse *lu,
				CONST plane_t norm, CONST struct rt_tol *tol) );
a2063 1
RT_EXTERN(void			nmg_rm_redundancies, (struct shell *s ) );
@


10.20
log
@added nmg_add_loop_to_face prototype
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.19 1993/03/25 23:20:29 mike Exp mm $
d42 1
a42 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.19 1993/03/25 23:20:29 mike Exp mm $ (BRL)"
d1891 2
a1892 1
RT_EXTERN(void			nmg_merge_2faces, (struct faceuse *dest_fu, struct faceuse *src_fu) );
@


10.19
log
@Return codes from nmg_keu(), nmg_kill_snakes(), nmg_simplify_face()
changed, so that they return (int) codes now.
Added declarations for lots of routines moved into nmg_mod.c
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.18 93/03/24 03:19:46 mike Exp Locker: mike $
d42 1
a42 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.18 93/03/24 03:19:46 mike Exp Locker: mike $ (BRL)"
d1836 2
@


10.18
log
@Updated some NMG externs
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.17 93/03/23 22:50:08 mike Exp Locker: mike $
d42 1
a42 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.17 93/03/23 22:50:08 mike Exp Locker: mike $ (BRL)"
d1815 1
a1815 1
RT_EXTERN(void			nmg_keu, (struct edgeuse *eu) );
d1850 14
d1873 2
a1874 2
RT_EXTERN(void			nmg_kill_snakes, (struct loopuse *lu) );
RT_EXTERN(void			nmg_simplify_face, (struct faceuse *fu) );
d1880 9
@


10.17
log
@Added arg to nmg_findeu()
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.16 93/03/20 04:09:33 mike Exp Locker: mike $
d42 1
a42 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.16 93/03/20 04:09:33 mike Exp Locker: mike $ (BRL)"
d1800 1
a1800 1
RT_EXTERN(struct model		*nmg_find_model, (long *magic_p) );
d1846 4
a1849 1
RT_EXTERN(struct vertexuse	*nmg_find_vu_in_face, (CONST point_t pt, struct faceuse *fu, CONST struct rt_tol *tol) );
d1856 2
a1861 1
RT_EXTERN(void			nmg_ck_lueu, (struct loopuse *lu, char *s) );
a1864 1
RT_EXTERN(void			nmg_ck_list, (struct rt_list *hd, CONST char *str) );
d1869 9
d1943 1
a1943 1
RT_EXTERN(void			nmg_pl_v, (FILE	*fp, struct vertex *v,
d1945 1
a1945 1
RT_EXTERN(void			nmg_pl_e, (FILE *fp, struct edge *e,
d1947 1
a1947 1
RT_EXTERN(void			nmg_pl_eu, (FILE *fp, struct edgeuse *eu,
d1949 1
a1949 1
RT_EXTERN(void			nmg_pl_lu, (FILE *fp, struct loopuse *fu, 
d1951 1
a1951 1
RT_EXTERN(void			nmg_pl_fu, (FILE *fp, struct faceuse *fu,
d1953 3
a1955 3
RT_EXTERN(void			nmg_pl_s, (FILE *fp, struct shell *s) );
RT_EXTERN(void			nmg_pl_r, (FILE *fp, struct nmgregion *r) );
RT_EXTERN(void			nmg_pl_m, (FILE *fp, struct model *m) );
d1957 1
a1957 1
				struct vertex *v, long *tab) );
d1959 1
a1959 1
				struct edge *e, long *tab,
d1962 1
a1962 1
				struct edgeuse *eu, long *tab,
d1965 1
a1965 1
				struct loopuse *lu, long *tab,
d1968 1
a1968 1
				struct faceuse *fu, long *tab, int fancy) );
d1970 1
a1970 1
				struct shell *s, int fancy) );
d1972 1
a1972 1
				struct nmgregion *r, int fancy) );
d1974 1
a1974 1
				struct model *m, int fancy) );
d1976 1
a1976 1
				long *b, struct edgeuse *eu) );
d1978 3
a1980 3
				long *b, struct edgeuse *eu) );
RT_EXTERN(void			nmg_pl_isect, (char *filename,
				struct shell *s) );
d1982 3
a1984 3
				struct faceuse *fu1) );
RT_EXTERN(void			nmg_pl_2fu, (char *str, int num,
				struct faceuse *fu1, struct faceuse *fu2,
d1986 5
a1990 5
RT_EXTERN(void			nmg_face_plot, (struct faceuse *fu) );
RT_EXTERN(void			nmg_2face_plot, (struct faceuse *fu1,
				struct faceuse *fu2) );
RT_EXTERN(void			nmg_face_lu_plot, (struct loopuse *lu,
				struct vertexuse *vu1, struct vertexuse *vu2) );
d2039 4
a2042 1

@


10.16
log
@Changed some external declarations
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.15 93/02/19 04:47:26 mike Exp Locker: mike $
d42 1
a42 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.15 93/02/19 04:47:26 mike Exp Locker: mike $ (BRL)"
d1848 3
a1850 1
RT_EXTERN(struct edgeuse	*nmg_findeu, (struct vertex *v1, struct vertex *v2, struct shell *s, struct edgeuse *eup) );
@


10.15
log
@Changed calling sequence of nmg_esplit(), nmg_ebreak(), nmg_e2break()
to use edgeuse pointers, rather than edge pointers.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.14 92/11/17 00:17:40 mike Exp Locker: mike $
d42 1
a42 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.14 92/11/17 00:17:40 mike Exp Locker: mike $ (BRL)"
d1898 1
a1898 1
RT_EXTERN(struct edgeuse	*nmg_faceradial, (struct edgeuse *eu) );
d1900 1
a1900 1
RT_EXTERN(void			nmg_euprint, (char *str, struct edgeuse *eu) );
d1905 1
a1905 1
RT_EXTERN(int			nmg_dangling_face, (struct faceuse *fu));
d1916 6
a1921 1
RT_EXTERN(int			nmg_pt_hitmis_f, (point_t pt, struct faceuse *fu, CONST struct rt_tol *tol, long *novote) );
d2015 1
@


10.14
log
@nmg_dangling_face() is different
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.13 92/11/16 23:25:13 mike Exp Locker: mike $
d42 1
a42 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.13 92/11/16 23:25:13 mike Exp Locker: mike $ (BRL)"
d1842 3
a1844 1
RT_EXTERN(struct edge		*nmg_esplit, (struct vertex *v, struct edge *e) );
@


10.13
log
@Added declarations from nmg_fcut.c
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.12 92/11/16 23:09:46 mike Exp Locker: mike $
d42 1
a42 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.12 92/11/16 23:09:46 mike Exp Locker: mike $ (BRL)"
d1903 1
a1903 1
RT_EXTERN(int			nmg_dangling_face, (struct faceuse *fu, char *tblXXX));
@


10.12
log
@Added declarations from nmg_misc.c and nmg_manif.c
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.11 92/11/11 00:24:22 mike Exp Locker: mike $
d42 1
a42 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.11 92/11/11 00:24:22 mike Exp Locker: mike $ (BRL)"
d1989 6
d2000 4
a2003 5
RT_EXTERN(void			nmg_face_plot, ( struct faceuse *fu) );
#if 0
/* Can't be here, because nmg_ray_state is defined in nmg_comb.c */
RT_EXTERN(void			nmg_face_lu_plot, ( struct loopuse *lu, struct nmg_ray_state *rs) );
#endif
@


10.11
log
@Added RT_SETJUMP and RT_UNSETJUMP, for g-jack and similar converters.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.10 92/10/27 17:58:14 mike Exp Locker: mike $
d42 1
a42 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.10 92/10/27 17:58:14 mike Exp Locker: mike $ (BRL)"
d1865 1
d1867 1
d1877 1
d1880 2
d1884 1
d1888 2
a1889 1
/* static nmg_check_radial */
d1897 1
a1897 1
RT_EXTERN(int			nmg_manifold_face, (struct faceuse *fu) );
d1899 12
a1910 3
RT_EXTERN(char 		*nmg_manifolds, (struct model *m) );
RT_EXTERN(char 		*nmg_shell_manifolds, (struct shell *sp, char *tbl) );
RT_EXTERN(struct edgeuse	*nmg_radial_face_edge_in_shell, (struct edgeuse *eu) );
@


10.10
log
@Added more declarations from pr.c
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.9 92/10/27 16:54:38 mike Exp Locker: mike $
d38 3
a40 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.9 92/10/27 16:54:38 mike Exp Locker: mike $ (BRL)"
d42 2
d1125 2
d1131 9
d1777 1
a1777 1
RT_EXTERN( unsigned long rt_glong, (CONST char *msgp));
d2027 4
@


10.9
log
@Added RT_DIR_PHONY_ADDR, to document the way things are.
Added some extern declarations.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.8 92/10/13 15:57:20 mm Exp Locker: mike $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.8 92/10/13 15:57:20 mm Exp Locker: mike $ (BRL)"
d1729 10
a1738 3
RT_EXTERN(void rt_pr_fallback_angle, (struct rt_vls *str, char *prefix,
	double angles[5]));
RT_EXTERN(void rt_find_fallback_angle, (double angles[5], vect_t vec));
@


10.8
log
@Added OP_NMG_TESS to union tree, to clean up mged/dodraw.c
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.7 92/07/23 05:11:20 mike Exp Locker: mm $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.7 92/07/23 05:11:20 mike Exp Locker: mm $ (BRL)"
d728 2
a1437 4
RT_EXTERN(int rt_struct_export, (struct rt_external *ext, genptr_t base, struct rt_imexport *imp) );
RT_EXTERN(int rt_struct_import, (genptr_t base, struct rt_imexport *imp, struct rt_external *ext) );
RT_EXTERN(int rt_struct_put, (FILE *fp, struct rt_external *ext) );
RT_EXTERN(int rt_struct_get, (struct rt_external *ext, FILE *fp) );
d1751 18
@


10.7
log
@Added more RT_EXTERN entries
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.6 92/06/01 16:19:42 mike Exp Locker: mike $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.6 92/06/01 16:19:42 mike Exp Locker: mike $ (BRL)"
d817 1
d837 9
@


10.6
log
@In order to reduce the size of executables, changed CKMAG macros to
call the subroutine rt_badmagic() when a problem is encountered,
rather than having all the code inline for every check.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.5 92/05/04 21:37:34 mike Exp Locker: mike $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.5 92/05/04 21:37:34 mike Exp Locker: mike $ (BRL)"
d1713 2
d1793 1
a1793 1
RT_EXTERN(void 		nmg_moveltof, (struct faceuse *fu, struct shell *s) );
d1800 1
d1806 1
a1806 1
RT_EXTERN(void			nmg_cut_loop, (struct vertexuse *vu1, struct vertexuse *vu2) );
d1811 3
d1901 5
d1924 3
a1926 3
/* from nmg_comb.c */
RT_EXTERN(void			nmg_ck_lueu, (struct loopuse *cklu, char *s) );
RT_EXTERN(void			nmg_face_combine, (struct nmg_ptbl *b,
d1928 2
a1929 1
				point_t pt, vect_t dir) );
@


10.5
log
@Began converting partition structures over to RT_LIST macros.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.5 92/05/04 15:58:24 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.5 92/05/04 15:58:24 mike Exp $ (BRL)"
d190 2
a191 10
	if( !(_ptr) )  { \
		rt_log("ERROR: null %s ptr, file %s, line %d\n", \
			_str, __FILE__, __LINE__ ); \
		rt_bomb("NULL pointer"); \
	} else if( *((long *)(_ptr)) != (_magic) )  { \
		rt_log("ERROR: bad %s ptr x%x, s/b x%x, was %s(x%x), file %s, line %d\n", \
			_str, _ptr, _magic, \
			rt_identify_magic( *((long *)(_ptr)) ), \
			*((long *)(_ptr)), __FILE__, __LINE__ ); \
		rt_bomb("Bad pointer"); \
d1738 3
@


10.4
log
@Added rti_region_fix_file
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.3 92/02/14 15:27:10 mmark Exp Locker: mike $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.3 92/02/14 15:27:10 mmark Exp Locker: mike $ (BRL)"
d506 1
d537 1
a537 1
	while( ((p) = res->re_parthead.pt_forw) == &(res->re_parthead) || \
d541 1
a541 1
	DEQUEUE_PT(p); \
d546 1
a546 1
			APPEND_PT( (p), &(res->re_parthead) ); \
d559 2
a560 6
/* Insert "new" partition in front of "old" partition */
#define INSERT_PT(new,old)	{ \
	(new)->pt_back = (old)->pt_back; \
	(old)->pt_back = (new); \
	(new)->pt_forw = (old); \
	(new)->pt_back->pt_forw = (new);  }
d562 2
a563 6
/* Append "new" partition after "old" partition */
#define APPEND_PT(new,old)	{ \
	(new)->pt_forw = (old)->pt_forw; \
	(new)->pt_back = (old); \
	(old)->pt_forw = (new); \
	(new)->pt_forw->pt_back = (new);  }
d566 1
a566 3
#define DEQUEUE_PT(cur)	{ \
	(cur)->pt_forw->pt_back = (cur)->pt_back; \
	(cur)->pt_back->pt_forw = (cur)->pt_forw;  }
d929 1
a929 1
	struct partition re_parthead;	/* Head of freelist */
@


10.3
log
@added erim solids
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.2 92/02/05 13:22:54 mike Exp Locker: mmark $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.2 92/02/05 13:22:54 mike Exp Locker: mmark $ (BRL)"
d1148 1
@


10.2
log
@Added rt_point_labels, modified declaration of db_put_external().
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.1 91/10/12 06:35:30 mike Rel4_0 Locker: mike $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 10.1 91/10/12 06:35:30 mike Rel4_0 Locker: mike $ (BRL)"
d431 5
d437 1
a437 1
#define ID_MAXIMUM	16	/* Maximum defined ID_xxx value */
@


10.1
log
@Release_4.0
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.95 91/10/10 22:41:02 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.95 91/10/10 22:41:02 mike Exp $ (BRL)"
d1203 1
a1203 1
 *			V L I S T
d1210 2
a1211 1
 *  On 32-bit machines, XXX of 35 results in structures just less than 1k.
d1303 1
a1303 1
 *			F U N C T A B
d1305 10
d1602 1
a1602 1
	CONST struct directory *dp, struct db_i *dbip ) );
@


9.95
log
@tu_name is no longer used.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.94 91/10/01 02:41:21 mike Exp Locker: mike $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.94 91/10/01 02:41:21 mike Exp Locker: mike $ (BRL)"
@


9.94
log
@Added some private internal counters to the resource structure,
to gain lots of performance back, by removing use of
RES_ACQUIRE( res_stats ) in shootray.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.93 91/09/27 21:45:23 phil Exp Locker: mike $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.93 91/09/27 21:45:23 phil Exp Locker: mike $ (BRL)"
a841 1
		char		*tu_name;	/* full path name of leaf */
@


9.93
log
@The iPSC/860 icc compiler likes the non-& version of offsetofarray().
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.92 91/08/28 00:24:13 mike Exp Locker: phil $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.92 91/08/28 00:24:13 mike Exp Locker: phil $ (BRL)"
d924 3
d946 9
d956 1
d1152 1
d1155 1
d1158 2
a1160 3
	long		nmiss_model;	/* rays missed model RPP */
	long		nmiss_tree;	/* rays missed sub-tree RPP */
	long		nmiss_solid;	/* rays missed solid RPP */
d1163 2
a1164 2
	int		needprep;	/* needs rt_prep */
	int		rti_nrays;	/* # calls to rt_shootray() */
d1431 2
@


9.92
log
@Corrected two deficiencies indicated by the Stardent
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.91 91/07/15 23:16:32 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.91 91/07/15 23:16:32 mike Exp $ (BRL)"
d961 1
a961 1
#if __STDC__
@


9.91
log
@Put underscores on the front of more macro parameters, to prevent confusion.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.90 91/07/05 21:39:51 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.90 91/07/05 21:39:51 mike Exp $ (BRL)"
d491 1
a491 1
#define RT_HIT_NORM( _hitp, _stp, rayp )  { \
d495 1
a495 1
		rt_log("stp=x%x, id=%d. hitp=x%x, rayp=x%x\n", _stp, _id, _hitp, rayp); \
d498 1
a498 1
	rt_functab[_id].ft_norm(_hitp, _stp, rayp); }
d1620 1
d1623 1
@


9.90
log
@Documented the fact that the application structure is subject to change.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.89 91/07/05 21:25:46 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.89 91/07/05 21:25:46 mike Exp $ (BRL)"
d174 4
a177 4
# define GETSTRUCT(p,str) \
	p = (struct str *)rt_calloc(1,sizeof(struct str), "getstruct " #str)
# define GETUNION(p,unn) \
	p = (union unn *)rt_calloc(1,sizeof(union unn), "getstruct " #unn)
d179 4
a182 4
# define GETSTRUCT(p,str) \
	p = (struct str *)rt_calloc(1,sizeof(struct str), "getstruct str")
# define GETUNION(p,unn) \
	p = (union unn *)rt_calloc(1,sizeof(union unn), "getstruct unn")
d289 5
a293 5
#define RT_CURVE( curvp, hitp, stp )  { \
	register int id = (stp)->st_id; \
	RT_CHECK_SOLTAB(stp); \
	if( id <= 0 || id > ID_MAXIMUM )  { \
		rt_log("stp=x%x, id=%d.\n", stp, id); \
d296 1
a296 1
	rt_functab[id].ft_curve( curvp, hitp, stp ); }
d309 5
a313 5
#define RT_HIT_UVCOORD( ap, stp, hitp, uvp )  { \
	register int id = (stp)->st_id; \
	RT_CHECK_SOLTAB(stp); \
	if( id <= 0 || id > ID_MAXIMUM )  { \
		rt_log("stp=x%x, id=%d.\n", stp, id); \
d316 1
a316 1
	rt_functab[id].ft_uv( ap, stp, hitp, uvp ); }
d491 5
a495 5
#define RT_HIT_NORM( hitp, stp, rayp )  { \
	register int id = (stp)->st_id; \
	RT_CHECK_SOLTAB(stp); \
	if( id <= 0 || id > ID_MAXIMUM ) { \
		rt_log("stp=x%x, id=%d. hitp=x%x, rayp=x%x\n", stp, id, hitp, rayp); \
d498 1
a498 1
	rt_functab[id].ft_norm(hitp, stp, rayp); }
@


9.89
log
@Changed calling sequence
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.88 91/07/01 03:28:53 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.88 91/07/01 03:28:53 mike Exp $ (BRL)"
d1041 13
a1053 1
 *  A future "multiple rays" interface will only provide a_return.
@


9.88
log
@Removed rt_booleval, until after optimization.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.87 91/06/30 23:02:34 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.87 91/06/30 23:02:34 mike Exp $ (BRL)"
d1620 1
a1620 1
	union tree **reg_trees, int cur));
@


9.87
log
@Changed rti_headsolid to rti_solidheads[] to improve speed of
parallel tree walking.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.86 91/06/30 22:08:46 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.86 91/06/30 22:08:46 mike Exp $ (BRL)"
a1465 4
					/* Eval bool tree node */
RT_EXTERN(int rt_booleval, (CONST union tree *treep,
	CONST struct partition *partp,
	struct region **trueregp, struct resource *resp) );
@


9.86
log
@Some additional CONST parameters, and rt_plot_all_{bboxes,solids},
plus rt_vlist_to_uplot()
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.85 91/06/30 19:18:56 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.85 91/06/30 19:18:56 mike Exp $ (BRL)"
d1106 7
a1127 1
	struct rt_list	rti_headsolid;	/* list of active solids */
d1155 1
d1164 14
d1576 1
d1578 1
@


9.85
log
@ANSI lint
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.84 91/06/29 23:36:27 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.84 91/06/29 23:36:27 mike Exp $ (BRL)"
d1446 3
a1448 2
RT_EXTERN(int rt_booleval, (union tree *treep, struct partition *partp,
	 struct region **trueregp, struct resource *resp) );
d1684 6
@


9.84
log
@Still more ANSI lint
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.83 91/06/29 23:16:30 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.83 91/06/29 23:16:30 mike Exp $ (BRL)"
d1361 1
a1361 1
RT_EXTERN(int rt_structparse, (struct rt_vls *vls,
@


9.83
log
@More CONST args
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.82 91/06/29 22:13:33 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.82 91/06/29 22:13:33 mike Exp $ (BRL)"
d1389 4
a1392 4
RT_EXTERN(void mat_copy, (mat_t dest, mat_t src) );
RT_EXTERN(void mat_mul, (mat_t dest, mat_t a, mat_t b) );
RT_EXTERN(void matXvec, (vect_t dest, mat_t m, vect_t src) );
RT_EXTERN(void mat_inv, (mat_t dest, mat_t src) );
d1397 2
a1398 2
RT_EXTERN(void mat_print, (char *title, mat_t m) );
RT_EXTERN(void mat_trn, (mat_t dest, mat_t src) );
d1407 1
a1407 1
RT_EXTERN(void mat_fromto, (mat_t dest, vect_t from, vect_t to) );
d1411 1
a1411 1
RT_EXTERN(void mat_lookat, (mat_t dest, vect_t dir, int yflip) );
@


9.82
log
@ANSI lint
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.81 91/06/25 04:50:54 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.81 91/06/25 04:50:54 mike Exp $ (BRL)"
d1361 2
a1362 1
RT_EXTERN(int rt_structparse, (struct rt_vls *vls, struct structparse *tab, char *base ) );
d1364 2
a1365 1
RT_EXTERN(void rt_structprint, (char *title, struct structparse *tab, char *base ) );
d1367 2
a1368 1
RT_EXTERN(void rt_vls_structprint, (struct rt_vls *vls, struct structparse *tab, char *base ) );
@


9.81
log
@combined_tree_state got a magic number.
Added tr_c to union tree, to properly handle OP_REGION
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.80 91/06/23 00:06:40 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.80 91/06/23 00:06:40 mike Exp $ (BRL)"
d395 1
a395 1
	struct directory *st_dp;	/* Directory entry of solid */
d455 1
a455 1
	char		*reg_name;	/* Identifying string */
d1276 1
a1276 1
	void	(*ft_print) RT_ARGS((struct soltab * /*stp*/));
d1314 2
a1315 2
			struct rt_external * /*ep*/,
			mat_t /*mat*/));
d1317 1
a1317 1
			struct rt_db_internal * /*ip*/,
d1347 3
a1349 1
RT_EXTERN(int rt_gettree, (struct rt_i *rtip, char *node) );
d1351 1
a1351 1
RT_EXTERN(void rt_pr_seg, (struct seg *segp) );
d1353 2
a1354 2
RT_EXTERN(void rt_pr_partitions, (struct rt_i *rtip,
	struct partition *phead, char *title) );
d1356 1
a1356 1
RT_EXTERN(void rt_printb, (char *s, unsigned long v, char *bits) );
d1358 2
a1359 1
RT_EXTERN(struct soltab *rt_find_solid, (struct rt_i *rtip, char *name) );
d1424 1
a1424 1
RT_EXTERN(char *rt_malloc, (unsigned int cnt, char *str) );
d1426 1
a1426 1
RT_EXTERN(void rt_free, (char *ptr, char *str) );
d1428 1
a1428 1
RT_EXTERN(char *rt_realloc, (char *ptr, unsigned int cnt, char *str) );
d1430 1
a1430 1
RT_EXTERN(char *rt_calloc, (unsigned nelem, unsigned elsize, char *str) );
d1432 1
a1432 1
RT_EXTERN(char *rt_strdup, (char *cp) );
d1452 1
a1452 1
RT_EXTERN(void rt_pr_soltab, (struct soltab *stp) );
d1454 1
a1454 1
RT_EXTERN(void rt_pr_region, (struct region *rp) );
d1456 4
a1459 1
RT_EXTERN(void rt_pr_tree, (union tree *tp, int lvl) );
d1461 1
a1461 1
RT_EXTERN(void rt_pr_pt, (struct rt_i *rtip, struct partition *pp) );
d1463 1
a1463 1
RT_EXTERN(void rt_pr_bitv, (char *str, bitv_t *bv, int len) );
d1465 1
a1465 1
RT_EXTERN(void rt_pr_hit, (char *str, struct hit *hitp) );
d1479 1
a1479 1
RT_EXTERN(void rt_pr_cut, (union cutter *cutp, int lvl) );
d1504 2
a1505 2
	struct db_full_path *oldp) );
RT_EXTERN(char *db_path_to_string, (struct db_full_path *pp) );
d1523 1
a1523 1
RT_EXTERN(union record *db_getmrec, ( struct db_i *, struct directory *dp ) );
d1525 2
a1526 2
RT_EXTERN(int db_get, (struct db_i *, struct directory *dp, union record *where,
	int offset, int len ) );
d1528 1
a1528 1
RT_EXTERN(int db_put, ( struct db_i *, struct directory *dp, union record *where,
d1532 1
a1532 1
RT_EXTERN(genptr_t db_getmrec, ( struct db_i *, struct directory *dp ) );
d1534 2
a1535 2
RT_EXTERN(int db_get, (struct db_i *, struct directory *dp, genptr_t where,
	int offset, int len ) );
d1537 2
a1538 2
RT_EXTERN(int db_put, ( struct db_i *, struct directory *dp, genptr_t where,
	int offset, int len ) );
d1541 1
a1541 1
	struct directory *dp, struct db_i *dbip ) );
d1543 1
a1543 1
	struct directory *dp, struct db_i *dbip ) );
d1573 31
d1639 1
a1639 1
	CONST plane_t b, CONST vect_t  rpp_min, CONST struct rt_tol *tol) );
d1679 1
a1679 1
RT_EXTERN(char *rt_units_string, (CONST double mm) );
d1858 2
d1861 1
a1865 1
RT_EXTERN(void			nmg_eval_shell, ( register struct shell *s, struct nmg_bool_state *bs ) );
d1867 7
a1873 1
RT_EXTERN(void			nmg_eval_plot, (struct nmg_bool_state *bs, int num, int delay) );
@


9.80
log
@Added RT_2RPP_DISJOINT and RT_POINT_IN_RPP
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.79 91/06/22 21:18:53 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.79 91/06/22 21:18:53 mike Exp $ (BRL)"
a435 39
 *			T R E E
 *
 *  Binary trees representing the Boolean operations between solids.
 */
#define MKOP(x)		((x))

#define OP_SOLID	MKOP(1)		/* Leaf:  tr_stp -> solid */
#define OP_UNION	MKOP(2)		/* Binary: L union R */
#define OP_INTERSECT	MKOP(3)		/* Binary: L intersect R */
#define OP_SUBTRACT	MKOP(4)		/* Binary: L subtract R */
#define OP_XOR		MKOP(5)		/* Binary: L xor R, not both*/
#define OP_REGION	MKOP(6)		/* Leaf: tr_stp -> combined_tree_state */
#define OP_NOP		MKOP(7)		/* Leaf with no effect */
/* Internal to library routines */
#define OP_NOT		MKOP(8)		/* Unary:  not L */
#define OP_GUARD	MKOP(9)		/* Unary:  not L, or else! */
#define OP_XNOP		MKOP(10)	/* Unary:  L, mark region */

union tree {
	int	tr_op;		/* Operation */
	struct tree_node {
		int		tb_op;		/* non-leaf */
		struct region	*tb_regionp;	/* ptr to containing region */
		union tree	*tb_left;
		union tree	*tb_right;
	} tr_b;
	struct tree_leaf {
		int		tu_op;		/* leaf, OP_SOLID */
		struct region	*tu_regionp;	/* ptr to containing region */
		struct soltab	*tu_stp;
		char		*tu_name;	/* full path name of leaf */
	} tr_a;
};
/* Things which are in the same place in both structures */
#define tr_regionp	tr_a.tu_regionp

#define TREE_NULL	((union tree *)0)

/*
d804 1
d808 46
@


9.79
log
@Calling sequence to ft_vshot() changed to use application struct,
rather than resource struct.  Also eliminated tol argument.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.78 91/06/22 20:53:09 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.78 91/06/22 20:53:09 mike Exp $ (BRL)"
d364 17
@


9.78
log
@ft_prep and ft_shot routines get tol through ap->a_rt_i
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.77 91/06/22 20:09:33 butler Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.77 91/06/22 20:09:33 butler Exp $ (BRL)"
d1272 1
a1272 2
			struct resource * /*resp*/,
			CONST struct rt_tol * /*tol*/));
@


9.77
log
@Added externs for new subroutines
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.76 91/06/14 03:40:04 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.76 91/06/14 03:40:04 mike Exp $ (BRL)"
d1246 1
a1246 2
			struct rt_i * /*rtip*/,
			CONST struct rt_tol * /*tol*/));
d1250 1
a1250 2
			struct seg * /*seghead*/,
			CONST struct rt_tol * /*tol*/));
@


9.76
log
@At the suggestion of Harry Reed, changed st_pathmat to st_matp, to save
memory on solids with identity matricies.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.75 91/06/13 01:34:46 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.75 91/06/13 01:34:46 mike Exp $ (BRL)"
d1600 2
d1603 1
d1650 1
d1798 2
d1802 7
@


9.75
log
@All matrix routines now have mat_ prefix.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.74 91/06/12 20:39:07 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.74 91/06/12 20:39:07 mike Exp $ (BRL)"
d384 1
a384 1
	mat_t		st_pathmat;	/* Xform matrix on path */
d1825 1
@


9.74
log
@Moved NMG subroutine declarations from nmg.h to raytrace.h,
to avoid circularity in defining types of args to the functions.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.73 91/06/04 22:55:13 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.73 91/06/04 22:55:13 mike Exp $ (BRL)"
d1365 4
a1368 3
/* XXX these two need mat_ on their names */
RT_EXTERN(void vtoh_move, (hvect_t dest, vect_t src) );
RT_EXTERN(void htov_move, (vect_t dest, hvect_t src) );
d1372 2
a1373 2
/* XXX new name */
RT_EXTERN(void ae_vec, (fastf_t *azp, fastf_t *elp, vect_t src) );
a1374 1
/* XXX new name */
d1377 2
d1384 4
a1387 3
/* XXX new names */
RT_EXTERN(void vec_ortho, (vect_t dest, vect_t src) );
RT_EXTERN(void vec_perp, (vect_t dest, vect_t src) );
d1615 4
d1816 1
@


9.73
log
@added rti_tol
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.72 91/05/23 10:34:58 jehunt Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.72 91/05/23 10:34:58 jehunt Exp $ (BRL)"
d1611 194
@


9.72
log
@added a LOS entry (ts_los) to the db_tree_state data structure
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.71 91/05/22 23:35:44 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.71 91/05/22 23:35:44 mike Exp $ (BRL)"
d1123 1
@


9.71
log
@Added RT_CK_TOL
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.70 91/05/18 02:44:13 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.70 91/05/18 02:44:13 mike Exp $ (BRL)"
d796 1
@


9.70
log
@Instituted new rt_tol struct for plane.c routines.
Added rt_tess_tol.
Changed calling sequence of ft_prep, ft_shot, ft_vshot, ft_plot, ft_tess.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.69 91/05/17 00:17:26 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.69 91/05/17 00:17:26 mike Exp $ (BRL)"
d135 1
d151 1
@


9.69
log
@Added rt_tol structure
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.68 91/05/16 23:22:23 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.68 91/05/16 23:22:23 mike Exp $ (BRL)"
d123 3
a125 2
 *		if( VDOT(a,b) >= tol->para )	a & b are parallel
 *		if( VDOT(a,b) <= tol->perp )	a & b are perpendicular
d128 1
d134 1
d136 5
d142 10
d1242 2
a1243 1
			struct rt_i * /*rtip*/));
d1247 2
a1248 1
			struct seg * /*seghead*/));
d1265 2
a1266 1
			double /*abs*/, double /*rel*/, double /*norm*/));
d1270 2
a1271 1
			struct resource * /*resp*/));
d1277 2
a1278 1
			double /*abs*/, double /*rel*/, double /*norm*/));
d1284 2
a1285 1
			double /*abs*/, double /*rel*/, double /*norm*/));
d1564 29
a1592 12
RT_EXTERN(int rt_3pts_distinct, (point_t a, point_t b, point_t c, double dist_tol_sq) );
RT_EXTERN(int rt_mk_plane_3pts, (plane_t plane, point_t a, point_t b, point_t c, double dist_tol_sq) );
RT_EXTERN(int rt_mkpoint_3planes, (point_t pt, plane_t a, plane_t b, plane_t c) );
RT_EXTERN(int rt_isect_ray_plane, (fastf_t *dist, point_t pt, vect_t dir, plane_t plane) );
RT_EXTERN(int rt_isect_2planes, (point_t pt, vect_t  dir, plane_t a, plane_t b, vect_t  rpp_min) );
RT_EXTERN(int rt_isect_2lines, (fastf_t *t, fastf_t *u, point_t p, vect_t d, point_t a, vect_t c) );
RT_EXTERN(int rt_isect_line_lseg, (fastf_t *t, point_t p, vect_t d, point_t a, point_t b) );
RT_EXTERN(double rt_dist_line_point, (point_t pt, vect_t dir, point_t a) );
RT_EXTERN(double rt_dist_line_origin, (point_t pt, vect_t dir) );
RT_EXTERN(double rt_area_of_triangle, (point_t a, point_t b, point_t c) );
RT_EXTERN(int rt_isect_pt_lseg, (fastf_t *dist, point_t a, point_t b, point_t p, fastf_t tolsq) );
RT_EXTERN(double rt_dist_pt_lseg, (point_t pca, point_t a, point_t b, point_t p) );
@


9.68
log
@Added some helpful comments for application writers.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.67 91/02/21 16:07:51 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.67 91/02/21 16:07:51 mike Exp $ (BRL)"
d97 35
@


9.67
log
@Eliminated stray sanity check on partition list.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.66 91/02/17 19:59:31 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.66 91/02/17 19:59:31 mike Exp $ (BRL)"
d664 3
d933 2
d939 3
a941 2
 *	a_hit		Routine to call when something is hit
 *	a_miss		Routine to call when ray misses everything
d943 15
d959 2
a960 1
 *  function called.
a966 2
	int		(*a_overlap)();	/* called when overlaps occur */
	int		a_level;	/* recursion level (for printing) */
d969 2
d972 2
a973 2
	int		a_zero1;	/* must be zero (sanity check) */
	/* THE FOLLOWING ROUTINES ARE MAINLINE & APPLICATION SPECIFIC */
d977 5
a983 2
	fastf_t		a_rbeam;	/* initial beam radius (mm) */
	fastf_t		a_diverge;	/* slope of beam divergance/mm */
d1028 11
a1041 3
	struct db_i	*rti_dbip;	/* prt to Database instance struct */
	vect_t		mdl_min;	/* min corner of model bounding RPP */
	vect_t		mdl_max;	/* max corner of model bounding RPP */
a1050 1
	int		useair;		/* "air" regions are used */
a1055 3
	vect_t		rti_pmin;	/* for plotting, min RPP */
	vect_t		rti_pmax;	/* for plotting, max RPP */
	int		rti_nlights;	/* number of light sources */
a1066 1
	double		rti_radius;	/* radius of model bounding sphere */
@


9.66
log
@rt_structparse returns an int
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.65 91/02/07 20:29:43 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.65 91/02/07 20:29:43 mike Exp $ (BRL)"
a506 1
			(p)->pt_magic = 0; /* sanity */ \
@


9.65
log
@Fixed magic number collision on RTI_MAGIC (and RT_LIST_HEAD_MAGIC).
Added rt_identify_magic();  expanded on from similar NMG function.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.64 91/02/04 18:28:29 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.64 91/02/04 18:28:29 mike Exp $ (BRL)"
d1246 1
a1246 1
RT_EXTERN(void rt_structparse, (struct rt_vls *vls, struct structparse *tab, char *base ) );
@


9.64
log
@Neatened up, employing RT_CKMAG() macro in the RT_CHECK_xxx() macros,
rather than using the often simpler code previously employed.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.63 91/01/28 23:27:03 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.63 91/01/28 23:27:03 mike Exp $ (BRL)"
a133 1
#define rt_identify_magic(s)	"(unimplemented)"	/* XXX */
d1042 1
a1042 1
#define RTI_MAGIC	0x01016580	/* magic # for integrity check */
d1501 3
@


9.63
log
@Modified for new "chunky" rt_vlist structures
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.62 91/01/26 03:17:23 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.62 91/01/26 03:17:23 mike Exp $ (BRL)"
d284 2
a285 11
#define RT_CHECK_SEG(_p)	{ \
	if( !(_p) )  {\
		rt_log("RT_CHECK_SEG() NULL seg ptr, %s line %d\n", \
			__FILE__, __LINE__ ); \
		rt_bomb("NULL seg ptr\n"); \
	} else if( (_p)->l.magic != RT_SEG_MAGIC )  { \
		rt_log("RT_CHECK_SEG(x%x) magic was x%x, s/b x%x, %s line %d\n", \
			(_p), (_p)->l.magic, RT_SEG_MAGIC, \
			__FILE__, __LINE__ ); \
		rt_bomb("bad seg ptr\n"); \
	} }
d337 2
a338 7
#define RT_CHECK_SOLTAB(_p)	{ \
	if( (_p)->l.magic != RT_SOLTAB_MAGIC )  { \
		rt_log("RT_CHECK_SOLTAB(x%x) magic was x%x, s/b x%x, %s line %d\n", \
			(_p), (_p)->l.magic, RT_SOLTAB_MAGIC, \
			__FILE__, __LINE__ ); \
		rt_bomb("bad soltab ptr\n"); \
	} }
d422 1
d438 2
d470 2
a476 2
	struct partition *pt_forw;		/* forwards link */
	struct partition *pt_back;		/* backwards link */
d485 2
a486 6
#define RT_CHECK_PT(_p)	{ if( (_p)->pt_magic != PT_MAGIC )  { \
				rt_log("RT_CHECK_PT(x%x) magic was x%x, s/b x%x, %s line %d\n", \
					(_p), (_p)->pt_magic, PT_MAGIC, \
					__FILE__, __LINE__ ); \
				rt_bomb("bad partition ptr\n"); \
			} }
d688 2
a689 6
#define RT_CHECK_DBI(_p) { if( (_p)->dbi_magic != DBI_MAGIC )  { \
				rt_log("RT_CHECK_DBI(x%x) magic was x%x, s/b x%x, %s line %d\n", \
					(_p), (_p)->dbi_magic, DBI_MAGIC, \
					__FILE__, __LINE__ ); \
				rt_bomb("bad db_i pointer\n"); \
			} }
d844 1
a860 1
	long		re_magic;	/* Magic number */
d864 2
a865 6
#define RT_RESOURCE_CHECK(_resp)	\
	{if((_resp)->re_magic != RESOURCE_MAGIC) {\
		rt_log("resp=x%x, magic s/b x%x was x%x, %s line %d\n", \
			(_resp), RESOURCE_MAGIC, (_resp)->re_magic, \
			__FILE__, __LINE__ ); \
		rt_bomb("bad resource struct"); } }
d1045 2
a1046 6
#define RT_CHECK_RTI(_p) { if( (_p)->rti_magic != RTI_MAGIC )  { \
				rt_log("RT_CHECK_RTI(x%x) magic was x%x, s/b x%x, %s line %d\n", \
					(_p), (_p)->rti_magic, RTI_MAGIC, \
					__FILE__, __LINE__ ); \
				rt_bomb("bad rt_i pointer\n"); \
			} }
a1123 5

/* XXX temporary */
#define GET_VL(p)	xxx
#define FREE_VL(p)	yyy
#define ADD_VL(hd,pnt,cmd)	zzz
@


9.62
log
@Eliminated "mat" argument to ft_plot and ft_tess;
these are now handled by the import operation
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.61 91/01/26 02:56:40 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.61 91/01/26 02:56:40 mike Exp $ (BRL)"
d297 1
a297 1
	while( !RT_LIST_LOOP((p),seg,&((res)->re_seg.l)) || !(p) ) \
d308 4
d314 1
a314 1
	while( RT_LIST_LOOP( _a, seg, &((_segheadp)->l) ) )  { \
d1013 1
a1013 1
	struct vlist	*rtg_vlFree;	/* vlist freelist */
d1027 1
a1048 1
	long		rti_magic;	/* magic # for integrity check */
d1079 19
a1097 5
 *  in 3-space.
 *  Intented for common handling of wireframe display information.
 *  XXX For the moment, allocated with individual malloc() calls.
 *  XXX For the moment, only hold one point per structure.
 *  It is debatable whether these should be single or double precision.
d1099 6
a1104 4
struct vlist {
	point_t		vl_pnt;		/* coordinates in space */
	int		vl_draw;	/* 1=draw, 0=move */
	struct vlist	*vl_forw;	/* next structure in list */
d1106 2
a1107 1
#define VL_NULL		((struct vlist *)0)
d1109 7
a1115 4
struct vlhead {
	struct vlist	*vh_first;
	struct vlist	*vh_last;
};
d1117 11
a1127 4
struct vlblock {
	int			count;
	struct color_vlhead	*cvp;
};
d1129 2
a1130 4
struct color_vlhead {
	long			rgb;
	struct vlhead		head;
};
d1132 9
a1140 7
/* Values for vl_draw */
#define VL_CMD_LINE_MOVE	0
#define VL_CMD_LINE_DRAW	1
#define VL_CMD_POLY_START	2	/* vl_pnt has surface normal */
#define VL_CMD_POLY_MOVE	3	/* move to first poly vertex */
#define VL_CMD_POLY_DRAW	4	/* subsequent poly vertex */
#define VL_CMD_POLY_END		5	/* last vert (repeats 1st), draw poly */
d1142 9
a1150 6
#define GET_VL(p)	{ \
			if( ((p) = rt_g.rtg_vlFree) == VL_NULL )  { \
				(p) = (struct vlist *)rt_malloc(sizeof(struct vlist), "vlist"); \
			} else { \
				rt_g.rtg_vlFree = (p)->vl_forw; \
			} }
d1152 4
a1155 5
/* Free an entire chain of vlist structs */
#define FREE_VL(p)	{ register struct vlist *_vp = (p); \
			while( _vp->vl_forw != VL_NULL ) _vp=_vp->vl_forw; \
			_vp->vl_forw = rt_g.rtg_vlFree; \
			rt_g.rtg_vlFree = (p);  }
a1156 13
#define ADD_VL(hd,pnt,draw)  { \
			register struct vlist *_vp; \
			GET_VL(_vp); \
			VMOVE( _vp->vl_pnt, pnt ); \
			_vp->vl_draw = draw; \
			_vp->vl_forw = VL_NULL; \
			if( (hd)->vh_first == VL_NULL ) { \
				(hd)->vh_first = (hd)->vh_last = _vp; \
			} else { \
				(hd)->vh_last->vl_forw = _vp; \
				(hd)->vh_last = _vp; \
			} }

d1214 1
a1214 1
			struct vlhead * /*vhead*/,
d1505 3
a1507 3
RT_EXTERN(struct vlblock *rt_vlblock_init, () );
RT_EXTERN(void rt_vlblock_free, (struct vlblock *vbp) );
RT_EXTERN(struct vlhead *rt_vlblock_find, (struct vlblock *vbp,
@


9.61
log
@Changed calling sequence to ts_leaf_func() routines
and rt_id_solid.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.60 91/01/25 22:36:28 cjohnson Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.60 91/01/25 22:36:28 cjohnson Exp $ (BRL)"
a1194 1
			mat_t /*mat*/,
a1205 1
			mat_t /*mat*/,
a1211 1
			mat_t /*mat*/,
@


9.60
log
@Change rt_struct et al to do "fill-in" rather than "malloc" of external
struct.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.59 91/01/25 21:17:25 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.59 91/01/25 21:17:25 mike Exp $ (BRL)"
d161 2
a162 1
#define RT_INIT_EXTERNAL(_p)	{(_p)->ext_magic = RT_EXTERNAL_MAGIC;}
d760 15
a774 3
	int		(*ts_region_start_func)();
	union tree *	(*ts_region_end_func)();
	union tree *	(*ts_leaf_func)();
d1514 3
@


9.59
log
@Converted function switch table to new import/export interface
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.58 91/01/25 12:51:49 cjohnson Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.58 91/01/25 12:51:49 cjohnson Exp $ (BRL)"
d1265 1
a1265 1
RT_EXTERN(struct rt_external  *rt_struct_export, (genptr_t base, struct rt_imexport *imp) );
a1266 2
RT_EXTERN(void rt_struct_free, (struct rt_external *ext) );
RT_EXTERN(int rt_struct_buf_size, (struct rt_imexport *imp) );
d1268 1
a1268 1
RT_EXTERN(struct rt_external *rt_struct_get, (FILE *fp) );
@


9.58
log
@Change prototypes to match inout.c (rt_struct_* et al)
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.57 91/01/14 22:47:57 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.57 91/01/14 22:47:57 mike Exp $ (BRL)"
d175 2
a176 1
#define RT_INIT_DB_INTERNAL(_p)	{(_p)->idb_magic = RT_DB_INTERNAL_MAGIC;}
a1159 1
#if defined(RECORD_DEFINED)
d1161 1
a1161 1
			union record * /*rec*/,
a1162 5
#else
	int	(*ft_prep) RT_ARGS((struct soltab * /*stp*/,
			genptr_t  /*rec*/,
			struct rt_i * /*rtip*/));
#endif
d1180 1
a1180 3
#if defined(RECORD_DEFINED)
	int	(*ft_plot) RT_ARGS((union record * /*rec*/,
			mat_t /*mat*/,
a1181 4
			struct directory * /*dp*/,
			double /*abs*/, double /*rel*/, double /*norm*/));
#else
	int	(*ft_plot) RT_ARGS((genptr_t /*rec*/,
d1183 1
a1183 2
			struct vlhead * /*vhead*/,
			struct directory * /*dp*/,
a1184 1
#endif
d1189 3
a1191 2
#if defined(RECORD_DEFINED) && defined(MODEL_DEFINED) && defined(NMGREGION_DEFINED)
	int	(*ft_tessellate) RT_ARGS((struct nmgregion ** /*r*/,
d1193 1
a1193 1
			union record * /*rec*/,
a1194 1
			struct directory * /*dp*/,
d1197 2
a1198 1
	int	(*ft_tessellate) RT_ARGS((genptr_t * /*r*/,
d1200 1
a1200 1
			genptr_t /*rec*/,
a1201 1
			struct directory * /*dp*/,
@


9.57
log
@ID_STRINGSOL has become ID_NMG
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.56 91/01/14 22:43:11 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.56 91/01/14 22:43:11 mike Exp $ (BRL)"
d1278 6
a1283 2
RT_EXTERN(char *rt_struct_export, (int *olen, char *base, struct rt_imexport *imp) );
RT_EXTERN(int rt_struct_import, (char *base, struct rt_imexport *imp, char *buf) );
@


9.56
log
@Added units conversion parameters to ft_export, ft_describe.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.55 91/01/12 07:26:48 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.55 91/01/12 07:26:48 mike Exp $ (BRL)"
d362 1
a362 1
#define	ID_STRINGSOL	11	/* String-defined solid */
@


9.55
log
@Changed to USE_PROTOTYPES.
On SGI 4D machines (3.3.1), can't have identifiers inside function
prototypes inside structure declarations, so they all had to
be commented out inside rt_functab.  Sigh.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.54 91/01/12 04:36:30 butler Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.54 91/01/12 04:36:30 butler Exp $ (BRL)"
d1221 2
a1222 1
			struct rt_db_internal * /*ip*/));
d1226 2
a1227 1
			int /*verbose*/));
@


9.54
log
@fixed prototype for rt_pr_fallback_angle
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.53 91/01/11 06:10:29 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.53 91/01/11 06:10:29 mike Exp $ (BRL)"
d41 1
a41 1
 *  System library routines used by the RT library.
d45 1
a45 1
#if __STDC__ && !apollo
d103 1
d105 1
a105 1
#if __STDC__
d1153 2
d1159 4
a1162 3
#if defined(__STDC__) && defined(RECORD_DEFINED)
	int	(*ft_prep) RT_ARGS((struct soltab *stp, union record *rec,
			struct rt_i *rtip));
d1164 3
a1166 2
	int	(*ft_prep) RT_ARGS((struct soltab *stp, genptr_t rec,
			struct rt_i *rtip));
d1168 15
a1182 9
	int 	(*ft_shot) RT_ARGS((struct soltab *stp, struct xray *rp,
			struct application *ap, struct seg *seghead));
	void	(*ft_print) RT_ARGS((struct soltab *stp));
	void	(*ft_norm) RT_ARGS((struct hit *hitp, struct soltab *stp,
			struct xray *rp));
	void	(*ft_uv) RT_ARGS((struct application *ap, struct soltab *stp,
			struct hit *hitp, struct uvcoord *uvp));
	void	(*ft_curve) RT_ARGS((struct curvature *cvp, struct hit *hitp,
			struct soltab *stp));
d1184 7
a1190 5
	void	(*ft_free) RT_ARGS((struct soltab *stp));
#if defined(__STDC__) && defined(RECORD_DEFINED)
	int	(*ft_plot) RT_ARGS((union record *rp, mat_t mat,
			struct vlhead *vhead, struct directory *dp,
			double abs_tol, double rel_tol, double norm_tol));
d1192 5
a1196 3
	int	(*ft_plot) RT_ARGS((genptr_t rp, mat_t mat,
			struct vlhead *vhead, struct directory *dp,
			double abs_tol, double rel_tol, double norm_tol));
d1198 11
a1208 8
	void	(*ft_vshot) RT_ARGS((struct soltab *stp[], struct xray *rp[],
			struct seg segp[], int n, struct resource *resp));
#if defined(__STDC__) && defined(RECORD_DEFINED) && \
    defined(MODEL_DEFINED) && defined(NMGREGION_DEFINED)
	int	(*ft_tessellate) RT_ARGS((struct nmgregion **r,
			struct model *m, union record *rp,
			mat_t mat, struct directory *dp,
			double abs_tol, double rel_tol, double norm_tol));
d1210 6
a1215 4
	int	(*ft_tessellate) RT_ARGS((genptr_t *r,
			genptr_t m, genptr_t rp,
			mat_t mat, struct directory *dp,
			double abs_tol, double rel_tol, double norm_tol));
d1217 9
a1225 7
	int	(*ft_import) RT_ARGS((struct rt_db_internal *ip,
			struct rt_external *ep, mat_t mat));
	int	(*ft_export) RT_ARGS((struct rt_external *ep,
			struct rt_db_internal *ip));
	void	(*ft_ifree) RT_ARGS((struct rt_db_internal *ip));
	int	(*ft_describe) RT_ARGS((struct rt_vls *str,
			struct rt_db_internal *ip, int verbose));
d1237 5
a1241 1
RT_EXTERN(void rt_log, (char *, ... ) );	/* Log message */
@


9.53
log
@Added import/export interface to rt_functab.
No changes made to calling sequences of existing routines yet.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.52 91/01/11 06:04:32 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.52 91/01/11 06:04:32 mike Exp $ (BRL)"
d1481 1
a1481 1
RT_EXTERN(void rt_pr_fallback_angle, (struct rt_vls *str, char *prefix
@


9.52
log
@Added 2 new routines
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.51 91/01/09 02:13:16 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.51 91/01/09 02:13:16 mike Exp $ (BRL)"
d1197 7
@


9.51
log
@Added db_get/put_external, db_free_external
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.50 91/01/09 01:52:43 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.50 91/01/09 01:52:43 mike Exp $ (BRL)"
d1472 5
@


9.50
log
@Added rt_external and rt_db_internal structures
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.49 91/01/05 02:54:54 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.49 91/01/05 02:54:54 mike Exp $ (BRL)"
d1398 6
@


9.49
log
@Reduced a_color[] to [3], to decrease struct copy time.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.48 91/01/05 02:54:26 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.48 91/01/05 02:54:26 mike Exp $ (BRL)"
d128 48
@


9.48
log
@Changed sp_fmt to char array.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.47 90/12/21 14:21:01 butler Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.47 90/12/21 14:21:01 butler Exp $ (BRL)"
d917 1
a917 1
	fastf_t		a_color[9];	/* application-specific color */
@


9.47
log
@changed sp_count to rt_structparse structure
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.46 90/12/10 19:36:29 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.46 90/12/10 19:36:29 mike Exp $ (BRL)"
d845 1
a845 1
	char		*sp_fmt;		/* "indir" or "%f", etc */
d857 1
a857 1
	char		im_fmt[4];		/* "len", "indir", or "%f", etc */
@


9.46
log
@Replaced void* with genptr_t
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.45 90/12/10 17:19:21 cjohnson Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.45 90/12/10 17:19:21 cjohnson Exp $ (BRL)"
d846 1
a983 1
	fastf_t		rti_pconv;	/* scale from rti_pmin */
@


9.45
log
@Add STDC, MODEL_DEFINED, and NMGREGION_DEFINED tests such that STDC
compilers do not use prototypes that are not yet defined.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.44 90/12/10 14:15:55 butler Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.44 90/12/10 14:15:55 butler Exp $ (BRL)"
d1112 1
a1112 1
	int	(*ft_prep) RT_ARGS((struct soltab *stp, void *rec,
d1131 1
a1131 1
	int	(*ft_plot) RT_ARGS((void *rp, mat_t mat,
d1144 2
a1145 2
	int	(*ft_tessellate) RT_ARGS((void **r,
			void *m, void *rp,
d1342 1
a1342 1
RT_EXTERN(void *db_getmrec, ( struct db_i *, struct directory *dp ) );
d1344 1
a1344 1
RT_EXTERN(int db_get, (struct db_i *, struct directory *dp, void *where,
d1347 1
a1347 1
RT_EXTERN(int db_put, ( struct db_i *, struct directory *dp, void *where,
@


9.44
log
@changed declaration for rt_structparse to reflect that the first arg
is now a struct rt_vls * instead of a char *
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.43 90/12/08 04:45:24 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.43 90/12/08 04:45:24 mike Exp $ (BRL)"
d1108 1
d1111 4
d1126 1
d1130 5
d1137 2
d1143 6
d1326 6
d1340 10
@


9.43
log
@Added struct import and export
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.42 90/12/08 01:29:08 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.42 90/12/08 01:29:08 mike Exp $ (BRL)"
d1160 2
a1161 2
RT_EXTERN(void rt_structparse, (char *cp, struct structparse *tab, char *base ) );
					/* Print arbitrary data structure */
d1163 2
@


9.42
log
@Moved rt_fastf_float, rt_mat_dbmat, rt_dbmat_mat
from raytrace.h to db.h, to avoid entanglements with dbfloat_t.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.41 90/12/07 05:28:46 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.41 90/12/07 05:28:46 mike Exp $ (BRL)"
d853 10
d1174 2
@


9.41
log
@New arg
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.40 90/12/07 01:34:57 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.40 90/12/07 01:34:57 mike Exp $ (BRL)"
d1243 2
a1244 8
					/* convert dbfloat->fastf_t */
/* XXX these next two should be dbfloat_t, but that means
 * XXX including db.h in absolutely everything.  No way.
 */
RT_EXTERN(void rt_fastf_float, (fastf_t *ff, float *fp, int n) );
					/* convert dbfloat mat->fastf_t */
RT_EXTERN(void rt_mat_dbmat, (fastf_t *ff, float *dbp) );
RT_EXTERN(void rt_dbmat_mat, (float *dbp, fastf_t *ff) );
@


9.40
log
@added rt_dbmat_mat
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.39 90/12/05 05:55:17 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.39 90/12/05 05:55:17 mike Exp $ (BRL)"
d1309 1
a1309 1
RT_EXTERN(int db_scan, ( struct db_i *, int (*handler)() ) );
@


9.39
log
@Moved #include of stddef stuff to top.
Changed to not redefine offsetof(), if it exists
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.39 90/12/05 05:18:55 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.39 90/12/05 05:18:55 mike Exp $ (BRL)"
d1250 1
@


9.38
log
@Moved rt_functab down to the bottom of the header file,
so that the structure declarations needed to declare the
function args will have been seen.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.37 90/11/12 18:17:33 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.37 90/11/12 18:17:33 mike Exp $ (BRL)"
d41 16
d838 3
a840 1
#	define offsetof(_t, _m)		(int)(&(((_t *)0)->_m))
a1385 14

/*
 *  System library routines used by the RT library.
 */
#if __STDC__ && !apollo
/*	NOTE:  Nested includes, gets malloc(), offsetof(), etc */
#	include <stdlib.h>
#	include <stddef.h>
#else
extern char	*malloc();
extern char	*calloc();
extern char	*realloc();
/**extern void	free(); **/
#endif
@


9.37
log
@Enhanced RT_CHECK_SEG
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.36 90/11/11 04:57:39 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.36 90/11/11 04:57:39 mike Exp $ (BRL)"
a305 34
/*
 *			F U N C T A B
 *
 *  Object-oriented interface to geometry modules.
 *  Table is indexed by ID_xxx value of particular solid.
 */
struct rt_functab {
	char	*ft_name;
	int	ft_use_rpp;
	int	(*ft_prep) RT_ARGS((struct soltab *stp, union record *rec,
			struct rt_i *rtip));
	int 	(*ft_shot) RT_ARGS((struct soltab *stp, struct xray *rp,
			struct application *ap, struct seg *seghead));
	void	(*ft_print) RT_ARGS((struct soltab *stp));
	void	(*ft_norm) RT_ARGS((struct hit *hitp, struct soltab *stp,
			struct xray *rp));
	void	(*ft_uv) RT_ARGS((struct application *ap, struct soltab *stp,
			struct hit *hitp, struct uvcoord *uvp));
	void	(*ft_curve) RT_ARGS((struct curvature *cvp, struct hit *hitp,
			struct soltab *stp));
	int	(*ft_classify)();
	void	(*ft_free) RT_ARGS((struct soltab *stp));
	int	(*ft_plot) RT_ARGS((union record *rp, mat_t mat,
			struct vlhead *vhead, struct directory *dp,
			double abs_tol, double rel_tol, double norm_tol));
	void	(*ft_vshot) RT_ARGS((struct soltab *stp[], struct xray *rp[],
			struct seg segp[], int n, struct resource *resp));
	int	(*ft_tessellate) RT_ARGS((struct nmgregion **r,
			struct model *m, union record *rp,
			mat_t mat, struct directory *dp,
			double abs_tol, double rel_tol, double norm_tol));
};
extern struct rt_functab rt_functab[];
extern int rt_nfunctab;
a306 1

d1067 38
@


9.36
log
@Added support for material property and color animations.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.35 90/11/02 03:07:02 mike Exp $
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.35 90/11/02 03:07:02 mike Exp $ (BRL)"
d218 5
a222 1
	if( (_p)->l.magic != RT_SEG_MAGIC )  { \
@


9.35
log
@Removed stray st_name
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.34 90/11/01 04:27:37 mike Exp $
d31 4
d38 1
a38 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.34 90/11/01 04:27:37 mike Exp $ (BRL)"
d385 1
d760 14
d776 1
a776 2
	struct directory **an_path;		/* pointer to path array */
	short		an_pathlen;		/* 0 = root */
d779 3
a781 1
		struct anim_mat anu_m;
d784 4
a787 4
#define AN_MATRIX	1			/* Matrix animation */
#define AN_PROPERTY	2			/* Material property anim */
#define AN_COLOR	3			/* Material color anim */
#define AN_SOLID	4			/* Solid parameter anim */
@


9.34
log
@Added another extern
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.33 90/10/15 23:20:28 mike Exp $
d34 1
a34 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.33 90/10/15 23:20:28 mike Exp $ (BRL)"
a254 1
	char		*st_name;	/* Leaf name of solid */
@


9.33
log
@Moved doubly-linked list macros into h/rtlist.h
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.32 90/10/15 11:39:38 mike Exp $
d34 1
a34 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.32 90/10/15 11:39:38 mike Exp $ (BRL)"
d1315 2
a1316 1
RT_EXTERN(int rt_mk_plane_3pts, (plane_t plane, point_t a, point_t b, point_t c) );
@


9.32
log
@Added hit_surfno
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.31 90/10/11 02:18:48 mike Exp $
d27 4
d34 1
a34 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.31 90/10/11 02:18:48 mike Exp $ (BRL)"
a107 103

/************************************************************************
 *									*
 *			Doubly-linked list support			*
 *									*
 ************************************************************************/

struct rt_list  {
	long		magic;
	struct rt_list	*forw;		/* "forward", "next" */
	struct rt_list	*back;		/* "back", "last" */
};
#define RT_LIST_MAGIC	0x01016580
#define RT_LIST_NULL	((struct rt_list *)0)

/* These macros all expect pointers to rt_list structures */

/* Insert "new" item in front of "old" item.  Often, "old" is the head. */
/* To put the new item at the tail of the list, insert before the head */
#define RT_LIST_INSERT(old,new)	{ \
	(new)->back = (old)->back; \
	(old)->back = (new); \
	(new)->forw = (old); \
	(new)->back->forw = (new);  }

/* Append "new" item after "old" item.  Often, "old" is the head. */
/* To put the new item at the head of the list, append after the head */
#define RT_LIST_APPEND(old,new)	{ \
	(new)->forw = (old)->forw; \
	(new)->back = (old); \
	(old)->forw = (new); \
	(new)->forw->back = (new);  }

/* Dequeue "cur" item from anywhere in doubly-linked list */
#define RT_LIST_DEQUEUE(cur)	{ \
	(cur)->forw->back = (cur)->back; \
	(cur)->back->forw = (cur)->forw; \
	(cur)->forw = (cur)->back = (struct rt_list *)NULL; }

/* Test if a doubly linked list is empty, given head pointer */
#define RT_LIST_IS_EMPTY(hp)	((hp)->forw == (hp))
#define RT_LIST_NON_EMPTY(hp)	((hp)->forw != (hp))

#define RT_LIST_INIT(hp)	{ \
	(hp)->forw = (hp)->back = (hp); \
	(hp)->magic = RT_LIST_MAGIC;	/* sanity */ }

/*
 *  Macros for walking a linked list, where the first element of
 *  some application structure is an rt_list structure.
 *  Thus, the pointer to the rt_list struct is a "pun" for the
 *  application structure as well.
 */
/* Return re-cast pointer to first element on list.
 * No checking is performed to see if list is empty.
 */
#define RT_LIST_LAST(structure,hp)	\
	((struct structure *)((hp)->back))
#define RT_LIST_FIRST(structure,hp)	\
	((struct structure *)((hp)->forw))
#define RT_LIST_NEXT(structure,hp)	\
	((struct structure *)((hp)->forw))
#define RT_LIST_MORE(p,structure,hp)	\
	((p) != (struct structure *)(hp))
#define RT_LIST_PNEXT(structure,p)	\
	((struct structure *)(((struct rt_list *)(p))->forw))
#define RT_LIST_PLAST(structure,p)	\
	((struct structure *)(((struct rt_list *)(p))->back))

#define RT_LIST_PNEXT_PNEXT(structure,p)	\
	((struct structure *)(((struct rt_list *)(p))->forw->forw))
#define RT_LIST_PNEXT_PLAST(structure,p)	\
	((struct structure *)(((struct rt_list *)(p))->forw->back))
#define RT_LIST_PLAST_PNEXT(structure,p)	\
	((struct structure *)(((struct rt_list *)(p))->back->forw))
#define RT_LIST_PLAST_PLAST(structure,p)	\
	((struct structure *)(((struct rt_list *)(p))->back->back))

/* Intended as innards for a for() loop to visit all nodes on list */
#define RT_LIST(p,structure,hp)	\
	(p)=RT_LIST_FIRST(structure,hp); \
	RT_LIST_MORE(p,structure,hp); \
	(p)=RT_LIST_PNEXT(structure,p)

/* Innards for a while() loop that picks off first elements */
#define RT_LIST_LOOP(p,structure,hp)	\
	(((p)=(struct structure *)((hp)->forw)) != (struct structure *)(hp))

/* Return the magic number of the first (or last) item on a list */
#define RT_LIST_FIRST_MAGIC(hp)		((hp)->forw->magic)
#define RT_LIST_LAST_MAGIC(hp)		((hp)->back->magic)

/* Return pointer to circular next element; ie, ignoring the list head */
#define RT_LIST_PNEXT_CIRC(structure,p)	\
	((RT_LIST_FIRST_MAGIC((struct rt_list *)(p)) == RT_LIST_MAGIC) ? \
		RT_LIST_PNEXT_PNEXT(structure,(struct rt_list *)(p)) : \
		RT_LIST_PNEXT(structure,p) )

/* Return pointer to circular last element; ie, ignoring the list head */
#define RT_LIST_PLAST_CIRC(structure,p)	\
	((RT_LIST_LAST_MAGIC((struct rt_list *)(p)) == RT_LIST_MAGIC) ? \
		RT_LIST_PLAST_PLAST(structure,(struct rt_list *)(p)) : \
		RT_LIST_PLAST(structure,p) )
@


9.31
log
@Added pipes and particles
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.30 90/10/07 21:37:16 mike Exp $
d30 1
a30 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.30 90/10/07 21:37:16 mike Exp $ (BRL)"
d234 3
a236 2
	vect_t		hit_vpriv;	/* private vector for xxx_*() */
	genptr_t	hit_private;	/* private handle for xxx_shot() */
@


9.30
log
@Changed soltab structure to use struct rt_list.
HeadSolid became rti_headsolid.
Added RT_CHECK_SOLTAB() macro to perform magic number checking.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.29 90/10/06 02:39:05 mike Exp $
d30 1
a30 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.29 90/10/06 02:39:05 mike Exp $ (BRL)"
d392 2
a393 1
#define ID_WIRE		15	/* Wire solid */
d395 1
a395 1
#define ID_MAXIMUM	15	/* Maximum defined ID_xxx value */
@


9.29
log
@Oops, programmers +/-1 disease.
Would cause dumps in rt_boolweave().
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.28 90/10/06 02:04:20 mike Exp $
d30 1
a30 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.28 90/10/06 02:04:20 mike Exp $ (BRL)"
d75 14
d264 1
d284 1
a303 1
	long		seg_magic;	/* sanity checking */
d346 1
a351 2
	struct soltab	*st_forw;	/* Forward linked list of solids */
	struct soltab	*st_back;	/* Backward links */
d361 4
a364 1
#define SOLTAB_NULL	((struct soltab *)0)
d366 8
d403 24
a426 13
	char		*ft_name;
	int		ft_use_rpp;
	int		(*ft_prep)();
	int 		(*ft_shot)();
	void		(*ft_print)();
	void		(*ft_norm)();
	void		(*ft_uv)();
	void		(*ft_curve)();
	int		(*ft_classify)();
	void		(*ft_free)();
	int		(*ft_plot)();
	void		(*ft_vshot)();
	int		(*ft_tessellate)();
d525 1
d1041 1
a1041 1
	struct soltab	*HeadSolid;	/* ptr to list of solids in model */
a1182 12
/*
 *  A macro for providing function prototypes, regardless of whether
 *  the compiler understands them or not.
 *  It is vital that the argument list given for "args" be enclosed
 *  in parens.
 */
#if __STDC__
#	define	RT_EXTERN(type_and_name,args)	extern type_and_name args
#else
#	define	RT_EXTERN(type_and_name,args)	extern type_and_name()
#endif

d1213 4
a1216 1

@


9.28
log
@Converted seg structures to use doubly linked lists.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.27 90/10/04 20:58:23 mike Exp $
d30 1
a30 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.27 90/10/04 20:58:23 mike Exp $ (BRL)"
d619 1
a619 1
	for( _wd=RT_BITV_BITS2WORDS(_lim); _wd>=0; _wd-- )  {  \
@


9.27
log
@Added rti_radius
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.26 90/07/31 00:57:29 mike Exp $
d30 1
a30 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.26 90/07/31 00:57:29 mike Exp $ (BRL)"
d91 46
d138 57
d287 1
a291 1
	struct seg	*seg_next;	/* non-zero if more segments */
d293 2
a294 2
#define SEG_NULL	((struct seg *)0)
#define SEG_MAGIC	0x98bcdef1
d296 7
a302 6
#define RT_CHECK_SEG(_p)	{ if( (_p)->seg_magic != SEG_MAGIC )  { \
				rt_log("RT_CHECK_SEG(x%x) magic was x%x, s/b x%x, %s line %d\n", \
					(_p), (_p)->seg_magic, SEG_MAGIC, \
					__FILE__, __LINE__ ); \
				rt_bomb("bad seg ptr\n"); \
			} }
d304 6
a309 7
#define GET_SEG(p,res)    { \
			while( ((p)=res->re_seg) == SEG_NULL ) \
				rt_get_seg(res); \
			res->re_seg = (p)->seg_next; \
			(p)->seg_next = SEG_NULL; \
			(p)->seg_magic = SEG_MAGIC; \
			res->re_segget++; }
d311 4
a314 6
#define FREE_SEG(p,res)  { \
			RT_CHECK_SEG(p); \
			(p)->seg_next = res->re_seg; \
			res->re_seg = (p); \
			(p)->seg_magic = 0; \
			res->re_segfree++; }
d316 6
a321 9
#define RT_FREE_SEG_LIST( _head, _res )	{ \
		register struct seg *_seg; \
		while( (_head) != SEG_NULL )  { \
			_seg = (_head)->seg_next; \
			FREE_SEG( (_head), _res ); \
			(_head) = _seg; \
		} \
		(_head) = SEG_NULL; \
	}
d381 1
a381 1
	struct seg 	*((*ft_shot)());
d530 6
a535 7
			while( res->re_parthead.pt_forw == PT_NULL || \
			    ((p) = res->re_parthead.pt_forw) == &(res->re_parthead) || \
			    (p)->pt_len != (ip)->rti_pt_bytes ) \
				rt_get_pt(ip, res); \
			(p)->pt_magic = PT_MAGIC; \
			DEQUEUE_PT(p); \
			res->re_partget++; }
d852 1
a852 1
	struct seg 	*re_seg;	/* Head of segment freelist */
d1240 2
a1241 2
RT_EXTERN(void rt_boolweave, (struct seg *segp_in, struct partition *PartHeadp,
	struct application *ap) );
@


9.26
log
@Fixed minor nit in RT_FREE_PT_LIST
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.25 90/06/07 02:16:30 mike Exp $
d30 1
a30 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.25 90/06/07 02:16:30 mike Exp $ (BRL)"
d943 1
@


9.25
log
@Chris has a database with d_len > 2^15, so it can't be a SHORT any more!
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.24 90/06/05 00:44:14 mike Exp $
d30 1
a30 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.24 90/06/05 00:44:14 mike Exp $ (BRL)"
d451 1
a451 1
			FREE_PT(_zap, ap->a_resource); \
@


9.24
log
@Modernized extern declarations for mat.c functions.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.23 90/05/24 18:06:51 mike Exp $
d30 1
a30 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.23 90/05/24 18:06:51 mike Exp $ (BRL)"
d638 2
a640 2
	short		d_len;			/* # of db granules used */
	short		d_nref;			/* # times ref'ed by COMBs */
@


9.23
log
@EXTERN --> RT_EXTERN, to avoid conflicts
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.22 90/05/24 04:07:37 mike Exp $
d30 1
a30 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.22 90/05/24 04:07:37 mike Exp $ (BRL)"
d1093 27
a1119 7
extern void mat_zero(), mat_idn(), mat_copy(), mat_mul(), matXvec();
extern void mat_inv(), mat_trn(), mat_ae(), mat_angles();
extern void vtoh_move(), htov_move(), mat_print();
extern void eigen2x2(), mat_fromto(), mat_lookat();
extern void ae_vec(), vec_ortho(), vec_perp();
extern void mat_xrot(), mat_yrot(), mat_zrot();
extern double mat_atan2();
@


9.22
log
@Added vlblock structures
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.21 90/05/24 01:12:20 mike Exp $
d30 1
a30 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.21 90/05/24 01:12:20 mike Exp $ (BRL)"
d1055 1
a1055 1
#	define	EXTERN(type_and_name,args)	extern type_and_name args
d1057 1
a1057 1
#	define	EXTERN(type_and_name,args)	extern type_and_name()
d1060 2
a1061 2
EXTERN(void rt_bomb, (char *str) );	/* Fatal error */
EXTERN(void rt_log, (char *, ... ) );	/* Log message */
d1063 1
a1063 1
EXTERN(struct rt_i *rt_dirbuild, (char *filename, char *buf, int len) );
d1065 1
a1065 1
EXTERN(void rt_prep, (struct rt_i *rtip) );
d1067 1
a1067 1
EXTERN(int rt_shootray, (struct application *ap) );
d1069 1
a1069 1
EXTERN(int rt_gettree, (struct rt_i *rtip, char *node) );
d1071 1
a1071 1
EXTERN(void rt_pr_seg, (struct seg *segp) );
d1073 1
a1073 1
EXTERN(void rt_pr_partitions, (struct rt_i *rtip,
d1076 1
a1076 1
EXTERN(void rt_printb, (char *s, unsigned long v, char *bits) );
d1078 1
a1078 1
EXTERN(struct soltab *rt_find_solid, (struct rt_i *rtip, char *name) );
d1080 1
a1080 1
EXTERN(void rt_structparse, (char *cp, struct structparse *tab, char *base ) );
d1082 2
a1083 2
EXTERN(void rt_structprint, (char *title, struct structparse *tab, char *base ) );
EXTERN(char *rt_read_cmd, (FILE *fp) );	/* Read semi-colon terminated line */
d1085 1
a1085 1
EXTERN(int rt_do_cmd, (struct rt_i *rtip, char *lp, struct command_tab *ctp) );
d1087 1
a1087 1
EXTERN(void rt_prep_timer, (void) );
d1089 1
a1089 1
EXTERN(double rt_read_timer, (char *str, int len) );
d1111 1
a1111 1
EXTERN(char *rt_malloc, (unsigned int cnt, char *str) );
d1113 1
a1113 1
EXTERN(void rt_free, (char *ptr, char *str) );
d1115 1
a1115 1
EXTERN(char *rt_realloc, (char *ptr, unsigned int cnt, char *str) );
d1117 1
a1117 1
EXTERN(char *rt_calloc, (unsigned nelem, unsigned elsize, char *str) );
d1119 1
a1119 1
EXTERN(char *rt_strdup, (char *cp) );
d1122 1
a1122 1
EXTERN(void rt_boolweave, (struct seg *segp_in, struct partition *PartHeadp,
d1125 1
a1125 1
EXTERN(int rt_boolfinal, (struct partition *InputHdp,
d1130 1
a1130 1
EXTERN(int rt_booleval, (union tree *treep, struct partition *partp,
d1133 1
a1133 1
EXTERN(void rt_grow_boolstack, (struct resource *res) );
d1135 1
a1135 1
EXTERN(int rt_fdiff, (double a, double b) );
d1137 1
a1137 1
EXTERN(double rt_reldiff, (double a, double b) );
d1139 1
a1139 1
EXTERN(void rt_pr_soltab, (struct soltab *stp) );
d1141 1
a1141 1
EXTERN(void rt_pr_region, (struct region *rp) );
d1143 1
a1143 1
EXTERN(void rt_pr_tree, (union tree *tp, int lvl) );
d1145 1
a1145 1
EXTERN(void rt_pr_pt, (struct rt_i *rtip, struct partition *pp) );
d1147 1
a1147 1
EXTERN(void rt_pr_bitv, (char *str, bitv_t *bv, int len) );
d1149 1
a1149 1
EXTERN(void rt_pr_hit, (char *str, struct hit *hitp) );
d1154 1
a1154 1
EXTERN(void rt_fastf_float, (fastf_t *ff, float *fp, int n) );
d1156 1
a1156 1
EXTERN(void rt_mat_dbmat, (fastf_t *ff, float *dbp) );
d1158 3
a1160 3
EXTERN(void rt_get_seg, (struct resource *res) );
EXTERN(void rt_get_pt, (struct rt_i *rtip, struct resource *res) );
EXTERN(void rt_get_bitv, (struct rt_i *rtip, struct resource *res) );
d1162 1
a1162 1
EXTERN(int rt_byte_roundup, (int nbytes) );
d1164 1
a1164 1
EXTERN(void rt_bitv_or, (bitv_t *out, bitv_t *in, int nbits) );
d1166 1
a1166 1
EXTERN(void rt_cut_it, (struct rt_i *rtip) );
d1168 1
a1168 1
EXTERN(void rt_pr_cut, (union cutter *cutp, int lvl) );
d1170 1
a1170 1
EXTERN(void rt_fr_cut, (union cutter *cutp) );
d1172 1
a1172 1
EXTERN(void rt_region_color_map, (struct region *regp) );
d1174 1
a1174 1
EXTERN(void rt_color_addrec, () );
d1176 1
a1176 1
EXTERN(void rt_cut_extend, (union cutter *cutp, struct soltab *stp) );
d1178 1
a1178 1
EXTERN(int rt_rpp_region, (struct rt_i *rtip, char *reg_name,
d1184 2
a1185 2
EXTERN(int db_add_anim, (struct db_i *dbip, struct animate *anp, int root) );
EXTERN(int db_do_anim, (struct animate *anp, mat_t stack, mat_t arc,
d1187 1
a1187 1
EXTERN(void db_free_anim, (struct db_i *dbip) );
d1190 1
a1190 1
EXTERN(void db_add_node_to_full_path, (struct db_full_path *pp,
d1192 1
a1192 1
EXTERN(void db_dup_full_path, (struct db_full_path *newp,
d1194 2
a1195 2
EXTERN(char *db_path_to_string, (struct db_full_path *pp) );
EXTERN(void db_free_full_path, (struct db_full_path *pp) );
d1199 1
a1199 1
EXTERN(struct db_i *db_open, ( char *name, char *mode ) );
d1201 1
a1201 1
EXTERN(struct db_i *db_create, ( char *name ) );
d1203 1
a1203 1
EXTERN(void db_close, ( struct db_i *dbip ) );
d1206 1
a1206 1
EXTERN(union record *db_getmrec, ( struct db_i *, struct directory *dp ) );
d1208 1
a1208 1
EXTERN(int db_get, (struct db_i *, struct directory *dp, union record *where,
d1211 1
a1211 1
EXTERN(int db_put, ( struct db_i *, struct directory *dp, union record *where,
d1215 1
a1215 1
EXTERN(int db_scan, ( struct db_i *, int (*handler)() ) );
d1217 1
a1217 1
EXTERN(void db_conversions, ( struct db_i *, int units ) );
d1220 1
a1220 1
EXTERN(struct directory *db_lookup,( struct db_i *, char *name, int noisy ) );
d1222 1
a1222 1
EXTERN(struct directory *db_diradd, ( struct db_i *, char *name, long laddr,
d1225 1
a1225 1
EXTERN(int db_dirdelete, ( struct db_i *, struct directory *dp ) );
d1228 1
a1228 1
EXTERN(int db_alloc, ( struct db_i *, struct directory *dp, int count ) );
d1230 1
a1230 1
EXTERN(int db_grow, ( struct db_i *, struct directory *dp, int count ) );
d1232 1
a1232 1
EXTERN(int db_trunc, ( struct db_i *, struct directory *dp, int count ) );
d1234 1
a1234 1
EXTERN(int db_delrec, ( struct db_i *, struct directory *dp, int recnum ) );
d1236 1
a1236 1
EXTERN(int db_delete, ( struct db_i *, struct directory *dp ) );
d1238 1
a1238 1
EXTERN(int db_zapper, ( struct db_i *, struct directory *dp, int start ) );
d1242 1
a1242 1
EXTERN(void rt_pri_set, ( int nval ) );
d1244 1
a1244 1
EXTERN(int rt_cpuget, (void) );
d1246 1
a1246 1
EXTERN(void rt_cpuset, (int sec) );
d1248 1
a1248 1
EXTERN(int rt_avail_cpus, (void) );
d1250 1
a1250 1
EXTERN(void rt_parallel, ( void (*func)(), int ncpu ) );
d1253 2
a1254 2
EXTERN(unsigned long memalloc, (struct mem_map **pp, unsigned size) );
EXTERN(unsigned long memget, (struct mem_map **pp, unsigned int size,
d1256 3
a1258 3
EXTERN(void memfree, (struct mem_map **pp, unsigned size, unsigned long addr) );
EXTERN(void mempurge, (struct mem_map **pp) );
EXTERN(void memprint, (struct mem_map **pp) );
d1260 3
a1262 3
EXTERN(struct vlblock *rt_vlblock_init, () );
EXTERN(void rt_vlblock_free, (struct vlblock *vbp) );
EXTERN(struct vlhead *rt_vlblock_find, (struct vlblock *vbp,
d1266 11
a1276 11
EXTERN(int rt_mk_plane_3pts, (plane_t plane, point_t a, point_t b, point_t c) );
EXTERN(int rt_mkpoint_3planes, (point_t pt, plane_t a, plane_t b, plane_t c) );
EXTERN(int rt_isect_ray_plane, (fastf_t *dist, point_t pt, vect_t dir, plane_t plane) );
EXTERN(int rt_isect_2planes, (point_t pt, vect_t  dir, plane_t a, plane_t b, vect_t  rpp_min) );
EXTERN(int rt_isect_2lines, (fastf_t *t, fastf_t *u, point_t p, vect_t d, point_t a, vect_t c) );
EXTERN(int rt_isect_line_lseg, (fastf_t *t, point_t p, vect_t d, point_t a, point_t b) );
EXTERN(double rt_dist_line_point, (point_t pt, vect_t dir, point_t a) );
EXTERN(double rt_dist_line_origin, (point_t pt, vect_t dir) );
EXTERN(double rt_area_of_triangle, (point_t a, point_t b, point_t c) );
EXTERN(int rt_isect_pt_lseg, (fastf_t *dist, point_t a, point_t b, point_t p, fastf_t tolsq) );
EXTERN(double rt_dist_pt_lseg, (point_t pca, point_t a, point_t b, point_t p) );
@


9.21
log
@Changed to using EXTERN macro to handle ANSI prototypes.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.20 90/05/22 21:15:45 mike Exp $
d30 1
a30 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.20 90/05/22 21:15:45 mike Exp $ (BRL)"
d976 10
d1260 5
d1268 1
a1268 1
EXTERN(int rt_isect_ray_plane, (fastf_t *dist, point_t pt, vect_t  dir, plane_t plane) );
@


9.20
log
@Added VL_CMD_* definitions, for vlist operations.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.19 90/05/22 21:07:29 butler Exp $
d30 1
a30 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.19 90/05/22 21:07:29 butler Exp $ (BRL)"
a1031 1

d1038 6
d1045 7
a1051 2
extern void rt_bomb(char *str);		/* Fatal error */
extern void rt_log(char *, ... );	/* Log message */
d1053 1
a1053 1
extern struct rt_i *rt_dirbuild(char *filename, char *buf, int len);
d1055 1
a1055 1
extern void rt_prep(struct rt_i *rtip);
d1057 1
a1057 1
extern int rt_shootray(struct application *ap);
d1059 1
a1059 1
extern int rt_gettree(struct rt_i *rtip, char *node);
d1061 1
a1061 1
extern void rt_pr_seg(struct seg *segp);
d1063 2
a1064 2
extern void rt_pr_partitions(struct rt_i *rtip,
	struct partition *phead, char *title);
d1066 1
a1066 1
extern void rt_printb(char *s, unsigned long v, char *bits);
d1068 1
a1068 1
extern struct soltab *rt_find_solid(struct rt_i *rtip, char *name);
d1070 1
a1070 1
extern void rt_structparse(char *cp, struct structparse *tab, char *base );
d1072 2
a1073 2
extern void rt_structprint(char *title, struct structparse *tab, char *base );
extern char *rt_read_cmd(FILE *fp);	/* Read semi-colon terminated line */
d1075 1
a1075 1
extern int rt_do_cmd(struct rt_i *rtip, char *lp, struct command_tab *ctp);
d1077 1
a1077 1
extern void rt_prep_timer(void);
d1079 1
a1079 1
extern double rt_read_timer(char *str, int len);
a1081 25

#else

extern void rt_bomb();			/* Fatal error */
extern void rt_log();			/* Log message */

extern struct rt_i *rt_dirbuild();	/* Read named MGED db, build toc */
extern void rt_prep();			/* Prepare for raytracing */
extern int rt_shootray();		/* Shoot a ray */

extern int rt_gettree();		/* Get expr tree for object */
extern void rt_pr_seg();		/* Print seg struct */
extern void rt_pr_partitions();		/* Print the partitions */
extern void rt_printb();		/* Print a bit vector */
extern struct soltab *rt_find_solid();	/* Find solid by leaf name */
extern void rt_structparse();		/* Parse arbitrary data structure */
extern void rt_structprint();		/* Print arbitrary data structure */
extern char *rt_read_cmd();		/* Read semi-colon terminated line */
extern int rt_do_cmd();			/* do cmd from string via cmd table */

extern void rt_prep_timer();		/* Start the timer */
extern double rt_read_timer();		/* Read timer, return time + str */
			
#endif

a1099 1
#if __STDC__
d1101 1
a1101 1
extern char *rt_malloc(unsigned int cnt, char *str);
d1103 1
a1103 1
extern void rt_free(char *ptr, char *str);
d1105 1
a1105 1
extern char *rt_realloc(char *ptr, unsigned int cnt, char *str);
d1107 1
a1107 1
extern char *rt_calloc(unsigned nelem, unsigned elsize, char *str);
d1109 1
a1109 1
extern char *rt_strdup(char *cp);
d1112 2
a1113 2
extern void rt_boolweave(struct seg *segp_in, struct partition *PartHeadp,
	struct application *ap);
d1115 1
a1115 1
extern int rt_boolfinal(struct partition *InputHdp,
d1118 1
a1118 1
	bitv_t *regionbits, struct application *ap);
d1120 2
a1121 2
extern int rt_booleval(union tree *treep, struct partition *partp,
	 struct region **trueregp, struct resource *resp);
d1123 1
a1123 1
extern void rt_grow_boolstack(struct resource *res);
d1125 1
a1125 1
extern int rt_fdiff(double a, double b);
d1127 1
a1127 1
extern double rt_reldiff(double a, double b);
d1129 1
a1129 1
extern void rt_pr_soltab(struct soltab *stp);
d1131 1
a1131 1
extern void rt_pr_region(struct region *rp);
d1133 1
a1133 1
extern void rt_pr_tree(union tree *tp, int lvl);
d1135 1
a1135 1
extern void rt_pr_pt(struct rt_i *rtip, struct partition *pp);
d1137 1
a1137 1
extern void rt_pr_bitv(char *str, bitv_t *bv, int len);
d1139 1
a1139 1
extern void rt_pr_hit(char *str, struct hit *hitp);
d1144 1
a1144 1
extern void rt_fastf_float(fastf_t *ff, float *fp, int n);
d1146 1
a1146 1
extern void rt_mat_dbmat(fastf_t *ff, float *dbp);
d1148 3
a1150 3
extern void rt_get_seg(struct resource *res);
extern void rt_get_pt(struct rt_i *rtip, struct resource *res);
extern void rt_get_bitv(struct rt_i *rtip, struct resource *res);
d1152 1
a1152 1
extern int rt_byte_roundup(int nbytes);
d1154 1
a1154 1
extern void rt_bitv_or(bitv_t *out, bitv_t *in, int nbits);
d1156 1
a1156 1
extern void rt_cut_it(struct rt_i *rtip);
d1158 1
a1158 1
extern void rt_pr_cut(union cutter *cutp, int lvl);
d1160 1
a1160 1
extern void rt_fr_cut(union cutter *cutp);
d1162 1
a1162 1
extern void rt_region_color_map(struct region *regp);
d1164 1
a1164 1
extern void rt_color_addrec();
d1166 1
a1166 1
extern void rt_cut_extend(union cutter *cutp, struct soltab *stp);
d1168 2
a1169 2
extern int rt_rpp_region(struct rt_i *rtip, char *reg_name,
	fastf_t *min_rpp, fastf_t *max_rpp);
d1174 4
a1177 4
extern int db_add_anim(struct db_i *dbip, struct animate *anp, int root);
extern int db_do_anim(struct animate *anp, mat_t stack, mat_t arc,
	struct mater_info *materp);
extern void db_free_anim(struct db_i *dbip);
d1180 6
a1185 6
extern void db_add_node_to_full_path(struct db_full_path *pp,
	struct directory *dp);
extern void db_dup_full_path(struct db_full_path *newp,
	struct db_full_path *oldp);
extern char *db_path_to_string(struct db_full_path *pp);
extern void db_free_full_path(struct db_full_path *pp);
d1189 1
a1189 1
extern struct db_i *db_open( char *name, char *mode );
d1191 1
a1191 1
extern struct db_i *db_create( char *name );
d1193 1
a1193 1
extern void db_close( struct db_i *dbip );
d1196 1
a1196 1
extern union record *db_getmrec( struct db_i *, struct directory *dp );
d1198 2
a1199 2
extern int db_get( struct db_i *, struct directory *dp, union record *where,
	int offset, int len );
d1201 2
a1202 2
extern int db_put( struct db_i *, struct directory *dp, union record *where,
	int offset, int len );
d1205 1
a1205 1
extern int db_scan( struct db_i *, int (*handler)() );
d1207 1
a1207 1
extern void db_conversions( struct db_i *, int units );
d1210 1
a1210 1
extern struct directory *db_lookup( struct db_i *, char *name, int noisy );
d1212 2
a1213 2
extern struct directory *db_diradd( struct db_i *, char *name, long laddr,
	int len, int flags );
d1215 1
a1215 1
extern int db_dirdelete( struct db_i *, struct directory *dp );
d1218 1
a1218 1
extern int db_alloc( struct db_i *, struct directory *dp, int count );
d1220 1
a1220 1
extern int db_grow( struct db_i *, struct directory *dp, int count );
d1222 1
a1222 1
extern int db_trunc( struct db_i *, struct directory *dp, int count );
d1224 1
a1224 1
extern int db_delrec( struct db_i *, struct directory *dp, int recnum );
d1226 1
a1226 1
extern int db_delete( struct db_i *, struct directory *dp );
d1228 1
a1228 1
extern int db_zapper( struct db_i *, struct directory *dp, int start );
d1232 1
a1232 1
extern void rt_pri_set( int nval );
d1234 1
a1234 1
extern int rt_cpuget(void);
d1236 1
a1236 1
extern void rt_cpuset(int sec);
d1238 1
a1238 1
extern int rt_avail_cpus(void);
d1240 1
a1240 1
extern void rt_parallel( void (*func)(), int ncpu );
d1243 6
a1248 6
extern unsigned long memalloc(struct mem_map **pp, unsigned size);
extern unsigned long memget(struct mem_map **pp, unsigned int size,
	unsigned int place);
extern void memfree(struct mem_map **pp, unsigned size, unsigned long addr);
extern void mempurge(struct mem_map **pp);
extern void memprint(struct mem_map **pp);
d1251 11
a1261 95
extern int rt_mk_plane_3pts(plane_t plane, point_t a, point_t b, point_t c);
extern int rt_mkpoint_3planes(point_t pt, plane_t a, plane_t b, plane_t c);
extern int rt_isect_ray_plane(fastf_t *dist, point_t pt, vect_t  dir, plane_t plane);
extern int rt_isect_2planes(point_t pt, vect_t  dir, plane_t a, plane_t b, vect_t  rpp_min);
extern int rt_isect_2lines(fastf_t *t, fastf_t *u, point_t p, vect_t d, point_t a, vect_t c);
extern int rt_isect_line_lseg(fastf_t *t, point_t p, vect_t d, point_t a, point_t b);
extern double rt_dist_line_point(point_t pt, vect_t dir, point_t a);
extern double rt_dist_line_origin(point_t pt, vect_t dir);
extern double rt_area_of_triangle(point_t a, point_t b, point_t c);
extern int rt_isect_pt_lseg(fastf_t *dist, point_t a, point_t b, point_t p, fastf_t tolsq);
extern double rt_dist_pt_lseg(point_t pca, point_t a, point_t b, point_t p);

#else

extern char *rt_malloc();		/* visible malloc() */
extern void rt_free();			/* visible free() */
extern char *rt_realloc();		/* visible realloc() */
extern char *rt_calloc();		/* visible calloc() */
extern char *rt_strdup();		/* Duplicate str w/malloc */

extern void rt_boolweave();		/* Weave segs into partitions */
extern int rt_boolfinal();		/* Eval booleans over partitions */
extern int rt_booleval();		/* Eval bool tree node */
extern void rt_grow_boolstack();
extern int rt_fdiff();			/* Approx Floating compare */
extern double rt_reldiff();		/* Relative Difference */
extern void rt_pr_soltab();		/* Print a soltab */
extern void rt_pr_region();		/* Print a region */
extern void rt_pr_tree();		/* Print an expr tree */
extern void rt_pr_pt();			/* Print a partition */
extern void rt_pr_bitv();		/* Print a bit vector */
extern void rt_pr_hit();		/* Print a hit point */
extern void rt_fastf_float();		/* convert dbfloat->fastf_t */
extern void rt_mat_dbmat();		/* convert dbfloat mat->fastf_t */
extern void rt_get_seg();		/* storage obtainer */
extern void rt_get_pt();
extern void rt_get_bitv();
extern int rt_byte_roundup();		/* malloc rounder */
extern void rt_bitv_or();		/* logical OR on bit vectors */
extern void rt_cut_it();		/* space partitioning */
extern void rt_pr_cut();		/* print cut node */
extern void rt_fr_cut();		/* free a cut tree */
extern void rt_draw_box();		/* unix-plot an RPP */
extern void rt_region_color_map();	/* regionid-driven color override */
extern void rt_color_addrec();		/* process ID_MATERIAL record */
extern void rt_cut_extend();		/* extend a cut box */
extern int rt_rpp_region();		/* find RPP of one region */

/* The database library */
extern int db_add_anim();
extern int db_do_anim();
extern void db_free_anim();
extern void db_add_node_to_full_path();
extern void db_dup_full_path();
extern char *db_path_to_string();
extern void db_free_full_path();
extern struct db_i *db_open();		/* open an existing model database */
extern struct db_i *db_create();	/* create a new model database */
extern void db_close();			/* close a model database */
extern union record *db_getmrec();	/* malloc & read records */
extern int db_get();			/* get several records from db */
extern int db_put();			/* put several records into db */
extern int db_scan();			/* read db (to build directory) */
extern void db_conversions();		/* update db unit conversions */
extern struct directory *db_lookup();	/* convert name to directory ptr */
extern struct directory *db_diradd();	/* add entry to directory */
extern int db_dirdelete();		/* delete entry from directory */
extern int db_alloc();			/* allocate "count" granules */
extern int db_grow();			/* grow by "count" granules */
extern int db_trunc();			/* truncate by "count" */
extern int db_delrec();			/* delete "recnum" from entry */
extern int db_delete();			/* delete all granules assigned dp */
extern int db_zapper();			/* write FREE records from 'start' */

/* memalloc.c */
extern unsigned long memalloc();
extern unsigned long memget();
extern void memfree();
extern void mempurge();
extern void memprint();

/* plane.c */
extern int rt_mk_plane_3pts();
extern int rt_mkpoint_3planes();
extern int rt_isect_ray_plane();
extern int rt_isect_2planes();
extern int rt_isect_2lines();
extern int rt_isect_line_lseg();
extern double rt_dist_line_point();
extern double rt_dist_line_origin();
extern double rt_area_of_triangle();
extern int rt_isect_pt_lseg();
extern double rt_dist_pt_lseg();

#endif
@


9.19
log
@Corrected some externs.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.18 90/05/17 11:19:48 mike Exp $
d30 1
a30 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.18 90/05/17 11:19:48 mike Exp $ (BRL)"
d975 8
@


9.18
log
@Fixed minor typo.
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.17 90/05/16 06:52:41 butler Exp $
d30 1
a30 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.17 90/05/16 06:52:41 butler Exp $ (BRL)"
d1265 1
a1265 1
extern int rt_dist_line_point(point_t pt, vect_t dir, point_t a);
d1347 1
a1347 1
extern int rt_dist_line_point();
@


9.17
log
@added extern declarations for all of the routines in librt/plane.c
@
text
@d24 1
a24 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 9.16 90/05/03 07:52:02 butler Exp $
d30 1
a30 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/raytrace.h,v 9.16 90/05/03 07:52:02 butler Exp $ (BRL)"
d1268 1
a1268 1
extern int rt_isect_pt_lseg(fastf_t, *dist, point_t a, point_t b, point_t p, fastf_t tolsq);
@


9.16
log
@added "NMG_debug" to rt_g to support NMG debugging.
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 9.15 90/05/02 23:00:10 butler Locked $
d30 1
a30 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: raytrace.h,v 9.15 90/05/02 23:00:10 butler Locked $ (BRL)"
d1063 2
d1258 13
d1339 13
@


9.15
log
@*** empty log message ***
@
text
@d24 1
a24 1
 *  $Header: /n/spark/m/cad/h/RCS/raytrace.h,v 9.14 90/05/02 01:08:55 mike Exp $
d30 1
a30 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: /n/spark/m/cad/h/RCS/raytrace.h,v 9.14 90/05/02 01:08:55 mike Exp $ (BRL)"
d894 1
@


9.14
log
@Added two new constants
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 9.13 90/04/12 02:52:10 mike Locked $
d30 1
a30 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: raytrace.h,v 9.13 90/04/12 02:52:10 mike Locked $ (BRL)"
@


9.13
log
@Added some definitions for new tree walker.
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 9.12 90/03/14 10:00:13 mike Locked $
d30 1
a30 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: raytrace.h,v 9.12 90/03/14 10:00:13 mike Locked $ (BRL)"
d1338 2
@


9.12
log
@plot and tessellate now return success codes.
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 9.11 90/03/10 00:43:18 mike Locked $
d30 1
a30 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: raytrace.h,v 9.11 90/03/10 00:43:18 mike Locked $ (BRL)"
d82 2
d87 2
d164 7
d310 6
a315 4
/* Internal */
#define OP_NOT		MKOP(6)		/* Unary:  not L */
#define OP_GUARD	MKOP(7)		/* Unary:  not L, or else! */
#define OP_XNOP		MKOP(8)		/* Unary:  L, mark region */
d617 1
d622 7
d653 47
a908 1
	char		*file;		/* name of file */
a923 1
	struct animate	*rti_anroot;	/* heads list of anim at root lvl */
d950 1
a950 1
				rt_bomb("bad rti pointer\n"); \
d1176 5
a1180 2
extern int rt_add_anim(struct rt_i *rtip, struct animate *anp, int root);
extern int rt_do_anim(struct animate *anp, mat_t stack, mat_t arc,
d1182 1
a1182 1
extern void rt_fr_anim(struct rt_i *rtip);
d1184 9
a1192 2
/* The database library */
/* open.c */
d1199 1
a1199 1
/* io.c */
d1208 1
a1208 1
/* scan.c */
d1213 1
a1213 1
/* lookup.c */
d1221 1
a1221 1
/* alloc.c */
a1289 3
extern int rt_add_anim();
extern int rt_do_anim();
extern void rt_fr_anim();
d1292 7
@


9.11
log
@Changed to genptr_t, moved define for CONST into machine.h
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 9.10 90/01/06 04:49:29 mike Locked $
d30 1
a30 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: raytrace.h,v 9.10 90/01/06 04:49:29 mike Locked $ (BRL)"
d279 1
a279 1
	void		(*ft_plot)();
d281 1
a281 1
	void		(*ft_tessellate)();
@


9.10
log
@Added RT_FREE_SEG_LIST and RT_FREE_PT_LIST
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 9.9 90/01/06 03:52:54 mike Locked $
d30 1
a30 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: raytrace.h,v 9.9 90/01/06 03:52:54 mike Locked $ (BRL)"
d114 1
a114 1
	char		*hit_private;	/* private handle for xxx_shot() */
d226 1
a226 1
	int		*st_specific;	/* -> ID-specific (private) struct */
d351 2
a352 2
	char		*reg_mfuncs;	/* User appl. funcs for material */
	char		*reg_udata;	/* User appl. data for material */
d792 1
a792 1
	char		*a_uptr;	/* application-specific pointer */
d1032 1
a1032 1
 *  These routines are not intended for Applications to use.	 *
a1251 6
#if __STDC__
#define	CONST	const
#else
#define	CONST	/**/
#endif

@


9.9
log
@Added RT_BITV_LOOP_START() macro set.
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 9.8 90/01/06 01:29:02 mike Locked $
d30 1
a30 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: raytrace.h,v 9.8 90/01/06 01:29:02 mike Locked $ (BRL)"
d204 9
d214 1
d432 10
@


9.8
log
@Addd histogram structure.
Added rti_Solids[].
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 9.7 89/12/31 04:59:31 mike Locked $
d30 1
a30 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: raytrace.h,v 9.7 89/12/31 04:59:31 mike Locked $ (BRL)"
d477 2
d480 25
d583 1
@


9.7
log
@rt_boolfinal() now returns an int.
Added declaration for rt_pr_soltab().
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 9.7 89/12/31 04:51:53 mike Locked $
d30 1
a30 1
#define RAYTRACE_H_VERSION	"@@(#)$Header: raytrace.h,v 9.7 89/12/31 04:51:53 mike Locked $ (BRL)"
d694 21
d825 3
@


9.6
log
@Added some magic numbers and error checking macros.
Also changed free partition list from singly-linked to
double-linked.
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 9.5 89/12/08 05:29:01 mike Locked $
d30 1
a30 1
#define RAYTRACE_H_VERSION	"@@(#)$Header$ (BRL)"
d982 1
a982 1
extern void rt_boolfinal(struct partition *InputHdp,
d995 2
d1116 1
a1116 1
extern void rt_boolfinal();		/* Eval booleans over partitions */
d1121 1
@


9.5
log
@Added ID numbers for ARBN and WIRE
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 9.4 89/10/13 20:35:15 mike Locked $
d30 2
d173 1
d180 1
d182 7
d193 2
a194 1
			p->seg_next = SEG_NULL; \
d198 1
d201 1
d361 4
d375 1
d385 1
d389 1
d391 7
d403 4
a406 1
	GET_PT(ip,p,res); bzero( ((char *) (p)), (ip)->rti_pt_bytes ); }
d409 3
a411 1
			while( ((p)=res->re_part) == PT_NULL ) \
d413 2
a414 1
			res->re_part = (p)->pt_forw; \
d418 3
a420 2
			(p)->pt_forw = res->re_part; \
			res->re_part = (p); \
d643 1
a643 1
	struct partition *re_part;	/* Head of freelist */
d661 1
a661 1
		rt_log("resp=x%x, magic s/b x%x was x%x, file %s line %d\n", \
d803 1
d807 7
@


9.4
log
@Added ID_VOL for 3-D volumes
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 9.3 89/10/10 15:42:12 mike Exp $
d233 2
d236 1
a236 1
#define ID_MAXIMUM	13	/* Maximum defined ID_xxx value */
@


9.3
log
@Added tessellate support
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 9.2 89/07/28 03:37:26 mike Locked $
d232 1
d234 1
a234 1
#define ID_MAXIMUM	12	/* Maximum defined ID_xxx value */
@


9.2
log
@Modifications for the Apollo
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 9.1 89/05/19 05:44:21 mike Rel3_5 $
d254 1
@


9.1
log
@Release_3.5
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 8.24 89/05/08 21:43:53 phil Exp $
d77 1
a77 1
#if __STDC__ && !alliant
d1146 1
a1146 1
#if __STDC__
@


8.24
log
@added db_conversions() routine
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 8.23 89/04/30 20:44:55 phil Locked $
@


8.23
log
@Added re_randptr
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 8.22 89/04/27 23:11:41 mike Locked $
d1014 2
d1104 1
@


8.22
log
@new const.c definitions
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 8.21 89/04/27 04:09:13 phil Locked $
d615 1
@


8.21
log
@Fix for Alliant not-quite-STDC problem.
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 8.20 89/04/21 22:31:28 mike Locked $
d1126 12
a1137 2
extern double	rt_invpi, rt_inv2pi;
extern double	rt_inv255;
@


8.20
log
@Added Gwyn "..." fix, removed special case for MIPS
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 8.19 89/04/14 03:02:33 mike Locked $
d77 1
a77 1
#if __STDC__
@


8.19
log
@sp_offset is now always &element (when !__STDC__);  when this is NOT
a byte offset (such as on the Cray), compensation is applied in
librt/parse.c
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 8.18 89/04/13 06:16:23 mike Locked $
d846 1
a846 1
extern void rt_log();			/* Log message */
a1093 1
#ifndef mips
a1109 29
#else
extern struct db_i *db_open( char *, char * );
extern struct db_i *db_create( char * );
extern void db_close( struct db_i * );
extern union record *db_getmrec( struct db_i *, struct directory * );
extern int db_get( struct db_i *, struct directory *, union record *,
	int , int  );
extern int db_put( struct db_i *, struct directory *, union record *,
	int , int  );
extern int db_scan( struct db_i *, int (*)() );
extern struct directory *db_lookup( struct db_i *, char *, int );
extern struct directory *db_diradd( struct db_i *, char *, long ,
	int , int  );
extern int db_dirdelete( struct db_i *, struct directory * );
extern int db_alloc( struct db_i *, struct directory *, int  );
extern int db_grow( struct db_i *, struct directory *, int );
extern int db_trunc( struct db_i *, struct directory *, int );
extern int db_delrec( struct db_i *, struct directory *, int );
extern int db_delete( struct db_i *, struct directory * );
extern int db_zapper( struct db_i *, struct directory *, int );

/* machine.c */
extern void rt_pri_set();		/* change to new "nice" value */
extern int rt_cpuget();			/* get CPU time limit */
extern void rt_cpuset();		/* set CPU time limit */
extern int rt_avail_cpus();		/* find # of CPUs available */
extern void rt_parallel();		/* run func in parallel */

#endif
@


8.18
log
@More function prototypes,
more magic numbers,
misc. stuff
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 8.17 89/04/06 20:43:07 mike Locked $
d632 5
d641 2
a642 10
#	if CRAY
		/* General problem of word-addressed hardware
		 * where (int *) and (char *) have different representations.
		 */
#		define offsetof(_t, _m)		((int)(&(((_t *)0)->_m))*sizeof(int))
#		define offsetofarray(_t, _m)	((int)( (((_t *)0)->_m))*sizeof(int))
#	else
#		define offsetof(_t, _m)		(int)(&(((_t *)0)->_m))
#		define offsetofarray(_t, _m)	(int)( (((_t *)0)->_m))
#	endif
a643 1

@


8.17
log
@Added re_magic
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 8.16 89/04/04 02:13:31 mike Locked $
d141 1
a141 1
	if( id < 0 || id >= rt_nfunctab )  { \
d205 1
d233 2
d253 1
d346 1
a346 1
	if( id < 0 || id >= rt_nfunctab ) { \
d619 6
d764 3
d909 2
d945 2
d980 2
d992 5
d1051 8
d1070 1
d1087 1
d1093 3
d1144 7
@


8.16
log
@Various STDC cleanups.
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 8.15 89/03/15 15:25:10 mike Locked $
d611 1
d614 1
@


8.15
log
@stroff_t MUST NOT be a void *, as it turns out.
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 8.14 89/03/15 15:16:32 mike Locked $
d77 1
a77 1
#ifdef __STDC__
d621 2
a622 7
#if defined(CRAY)
	/*
	 * CRAY machines have a problem taking the address of an arbitrary
	 * character within a structure.  int pointers have to be used.
	 * There is some matching hackery in the invididual tables.
	 */
	typedef int	*stroff_t;
d624 10
a633 1
	typedef char	*stroff_t;
d636 1
d640 2
a641 2
	stroff_t	sp_offset;		/* Offset within structure */
	void		(*sp_hook)();		/* Optional hooked function */
d669 1
d683 1
d687 4
d833 1
a833 1
#ifdef __STDC__
d854 3
a856 1
extern void rt_structparse(char *cp, struct structparse *tab, stroff_t base );
d880 1
d905 1
a905 1
#ifdef __STDC__
d1120 5
d1127 1
d1129 1
@


8.14
log
@Added some additional declarations, including rt_calloc().
Also made one change to eliminate reference to "union record *"
so that all users of this header file would NOT have to include
db.h as well.
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 8.13 89/02/27 02:06:35 mike Locked $
d629 1
a629 5
#	if defined(__STDC__) && !defined(apollo)
		typedef void	*stroff_t;
#	else
		typedef char	*stroff_t;
#	endif
@


8.13
log
@made stroff_t a char* on apollo (this may ultimately be what
__STDC__ should use, but at least this fixes the apollo in the
mean time).
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 8.12 89/01/19 19:48:44 phil Locked $
d77 7
a83 5
#define GETSTRUCT(p,str) \
	if( (p = (struct str *)rt_malloc(sizeof(struct str), \
	    "getstruct str")) == (struct str *)0 ) \
		exit(17); \
	bzero( (char *)p, sizeof(struct str));
a84 1

d902 2
d954 1
a954 1
extern void rt_color_addrec(union record *recp, long addr);
d1003 12
d1020 1
d1086 8
d1111 1
@


8.12
log
@For ANSII C, made tokens after #endif into comments
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 8.11 89/01/11 07:58:36 mike Locked $
d628 1
a628 1
#	ifdef __STDC__
@


8.11
log
@Added reg_instnum
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 8.10 88/12/30 06:22:54 mike Locked $
d1089 1
a1089 1
#endif RAYTRACE_H
@


8.10
log
@Added struct command_tab, definitions for rt_read_cmd, rt_do_cmd.
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 8.9 88/12/30 00:10:07 mike Locked $
d321 1
@


8.9
log
@Eliminated rti_DirHead, that function is now in dbi_Head
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 8.8 88/12/27 12:18:07 mike Locked $
d803 13
d817 1
d846 3
d869 2
@


8.8
log
@Added structparse
@
text
@d24 1
a24 1
 *  $Header: raytrace.h,v 8.7 88/12/15 01:34:18 mike Locked $
a730 1
	struct directory *rti_DirHead;	/* directory for this DB */
@


8.7
log
@added tolerances RT_LEN_TOL, RT_DOT_TOL, RT_PCOEF_TOL
@
text
@d4 2
a5 1
 * All the structures necessary for dealing with the RT ray tracer library.
d7 5
d24 1
a24 1
 *  $Header: raytrace.h,v 8.7 88/12/15 01:22:17 phil Exp $
d30 6
d43 30
d612 21
d634 8
d645 3
a647 1
 * Note:  When calling rt_shootray(), these fields are mandatory:
d653 2
a654 1
 * Also note that rt_shootray() returns the (int) return of a_hit()/a_miss().
d755 2
d831 2
d852 1
d856 1
a1062 29

/*
 *  Unfortunately, to prevent divide-by-zero, some tolerancing
 *  needs to be introduced.
 *
 *  RT_LEN_TOL is the shortest length, in mm, that can be stood
 *  as the dimensions of a primitive.
 *  Can probably become at least SMALL.
 *  Dot products smaller than RT_DOT_TOL are considered to have
 *  a dot product of zero, i.e., the angle is effectively zero.
 *  This is used to check vectors that should be perpendicular.
 *  asin(0.1   ) = 5.73917 degrees
 *  asin(0.01  ) = 0.572967
 *  asin(0.001 ) = 0.0572958 degrees
 *  asin(0.0001) = 0.00572958 degrees
 *
 *  sin(0.01 degrees) = sin(0.000174 radians) = 0.000174533
 *
 *  Many TGCs at least, in existing databases, will fail the
 *  perpendicularity test if DOT_TOL is much smaller than 0.001,
 *  which establishes a 1/20th degree tolerance.
 *  The intent is to eliminate grossly bad primitives, not pick nits.
 *
 *  RT_PCOEF_TOL is a tolerance on polynomial coefficients to prevent
 *  the root finder from having heartburn.
 */
#define RT_LEN_TOL	(1.0e-8)
#define RT_DOT_TOL	(0.001)
#define RT_PCOEF_TOL	(1.0e-10)
@


8.6
log
@sgi 3-D nit.
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 8.5 88/12/10 02:47:44 mike Locked $
d983 29
@


8.5
log
@Hardware specific versions of infinity.
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 8.4 88/12/06 15:18:03 mike Locked $
d24 1
a24 1
#ifdef vax
@


8.4
log
@Added dbi_inmem
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 8.3 88/12/05 22:24:37 mike Locked $
d24 5
a28 1
#define INFINITY	(1.0e20)
@


8.3
log
@Switched to using db_* family of routines for accessing the database.
@
text
@d18 1
a18 1
 *  $Header: /cad/d/mike/cad/h/RCS/raytrace.h,v 1.4 88/11/27 19:05:38 mike Exp $
d182 1
a182 1
#define	ID_STRSOL	11	/* String-defined solid */
d464 1
a464 1
	
@


8.2
log
@oops, really Rel 3.0
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 8.2 88/10/06 02:27:05 mike Rel3_0 $
d182 2
d417 1
d419 51
a486 1
#define DIR_BRANCH	0x8		/* branch name */
d488 1
a488 1
/* Args to rt_dir_lookup() */
d636 1
a637 1
	FILE		*fp;		/* file handle of database */
a653 1
	union record	*rti_db;	/* in-core database, when needed */
d784 4
a787 1
 *  Internal routines in the RT library.  Not for Applications   *
a800 5
					/* Look up name in toc */
extern struct directory *rt_dir_lookup(struct rt_i *rtip, char *str, int noisy);
					/* Add name to toc */
extern struct directory *rt_dir_add(struct rt_i *rtip, char *name,
	long laddr, int len, int flags);
d855 42
a903 2
extern struct directory *rt_dir_lookup();/* Look up name in toc */
extern struct directory *rt_dir_add();	/* Add name to toc */
d928 41
@


8.1
log
@Release_3.0
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 7.18 88/09/17 07:46:33 mike Exp $
d696 1
a696 1
extern void rt_printb(char *s, long v, char *bits);
d698 1
a698 1
extern struct soltab *rt_find_solid(struct rt_t *rtip, char *name);
d761 1
a761 1
	 struct region **trueregp);
d803 1
a803 1
	fastf_t min_rpp, fastf_t max_rpp);
@


7.18
log
@First set of additions for building vectors of space partitioning RPPs
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 7.17 88/09/09 04:05:52 mike Locked $
@


7.17
log
@Fixed declaration of rt_dir_add
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 7.16 88/09/02 19:55:45 mike Locked $
d388 3
d395 1
a395 1
	char	cut_type;
d398 2
a399 2
		char	cn_type;
		char	cn_axis;	/* 0,1,2 = cut along X,Y,Z */
d405 1
a405 1
		char	bn_type;
d610 4
@


7.16
log
@fixed the curvature comment
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 7.15 88/08/20 07:22:20 phil Locked $
d742 2
a743 1
extern struct directory *rt_dir_add(struct rt_i *rtip, char *name, long laddr);
@


7.15
log
@Added rtg_logindent, declaration for rt_printb().
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 7.14 88/08/19 03:25:25 mike Locked $
d75 5
a79 5
 *  Principal curvature c1 is <= c2.  A POSITIVE curvature in a
 *  particular direction indicates that the surface bends AWAY
 *  from the (outward pointing) normal vector.  (Thanks to GIFT).
 *  c1 and c2 are inverse radii.
 *  XXX this information needs to be changed, it is out of date!!
@


7.14
log
@Added rt_boolstack, re_boolslen
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 7.14 88/08/19 03:04:14 mike Exp $
d79 1
d565 1
d689 2
d709 1
@


7.13
log
@added rt_realloc()
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 7.12 88/07/14 20:08:17 phil Locked $
d482 3
d503 2
@


7.12
log
@Clarified comments on region ID and AIR codes
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 7.11 88/05/16 05:01:30 mike Locked $
d724 2
d791 1
@


7.11
log
@Added extra elements to directory struct, to
(a) enable progress on instance resolution, and
(b) provide compatibility with MGED needs.
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 7.10 88/05/16 01:38:20 mike Locked $
d263 2
a264 2
	short		reg_regionid;	/* Region ID code;  index to ? */
	short		reg_aircode;	/* ?? */
@


7.10
log
@Finished ANSI C declarations
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 7.9 88/05/14 02:32:28 mike Locked $
d419 4
d425 5
@


7.9
log
@lint fixes
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 7.8 88/05/14 01:31:32 mike Locked $
d760 15
a774 9
/* ran out of energy here */
extern void rt_bitv_or();		/* logical OR on bit vectors */
extern void rt_cut_it();		/* space partitioning */
extern void rt_pr_cut();		/* print cut node */
extern void rt_draw_box();		/* unix-plot an RPP */
extern void rt_region_color_map();	/* regionid-driven color override */
extern void rt_color_addrec();		/* process ID_MATERIAL record */
extern void rt_cut_extend();		/* extend a cut box */
extern int rt_rpp_region();		/* find RPP of one region */
@


7.8
log
@Added some __STDC__ stuff, more is needed
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 7.7 88/02/25 06:02:16 mike Locked $
d97 1
a97 1
	(void)rt_functab[id].ft_curve( curvp, hitp, stp ); }
d295 1
a295 1
	(void)rt_functab[id].ft_norm(hitp, stp, rayp); }
@


7.7
log
@Added vector list definitions
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 7.6 88/02/05 03:22:30 mike Locked $
d193 4
a196 4
	int		(*ft_print)();
	int		(*ft_norm)();
	int		(*ft_uv)();
	int		(*ft_curve)();
d198 2
a199 2
	int		(*ft_free)();
	int		(*ft_plot)();
d656 25
d695 1
d710 62
d802 1
@


7.6
log
@Moved NEAR_ZERO to vmath.h
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 7.5 88/01/27 06:37:33 mike Locked $
d549 1
d594 46
@


7.5
log
@Added rtg_parallel.
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 7.4 88/01/26 04:15:12 mike Locked $
a23 1
#define NEAR_ZERO(val,epsilon)	( ((val) > -epsilon) && ((val) < epsilon) )
@


7.4
log
@Added inheritance flags
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 7.3 88/01/23 05:45:58 mike Locked $
d544 1
@


7.3
log
@Added application structure slots for index of refraction and
cumulative length of ray.  These are for the use of applications..
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 7.3 88/01/23 05:28:24 mike Exp $
d249 2
@


7.2
log
@Added new library routine defns.
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 7.1 87/11/02 23:22:38 mike Locked $
d527 2
@


7.1
log
@Release 2.3
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 6.3 87/09/10 07:09:26 mike Exp $
d624 2
a626 1

d649 2
a650 1
extern void rt_fastf_float();		/* convert float->fastf_t */
@


6.3
log
@Added rti_nlight
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 6.2 87/08/09 19:14:51 mike Locked $
@


6.2
log
@Fixed error revealed by Cray-2, with constants needing casts to bitv_t
for BIT operations.
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 6.1 87/07/11 07:48:26 mike Rel $
d585 1
@


6.1
log
@Release 2.0
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 5.7 87/07/10 04:50:44 mike Exp $
d374 6
a379 3
#define BITTEST(lp,bit)	(lp[bit>>BITV_SHIFT] & (1<<(bit&BITV_MASK)))
#define BITSET(lp,bit)	(lp[bit>>BITV_SHIFT] |= (1<<(bit&BITV_MASK)))
#define BITCLR(lp,bit)	(lp[bit>>BITV_SHIFT] &= ~(1<<(bit&BITV_MASK)))
@


5.7
log
@Added rt_inv255
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 5.6 87/07/08 00:55:40 mike Locked $
@


5.6
log
@Deleted ma_transmit, added reg_transmit flag.
Also added a_purpose string to application struct, for debugging.
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 5.5 87/06/27 03:43:01 mike Locked $
d662 1
a662 1
 *  Variables and constants used by the RT library, not for external use.
d664 2
a665 1
extern double rt_invpi, rt_inv2pi;
@


5.5
log
@Added plotting bounding box, and scale factor.
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 5.4 87/06/26 23:27:34 mike Locked $
a246 1
	float	ma_transmit[3];		/* 0..1 light transmission [RGB] */
d270 1
d516 1
@


5.4
log
@ma_rgb as unsigned chars have become ma_color, as floats 0..1
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 5.3 87/06/26 22:31:38 mike Locked $
d578 3
@


5.3
log
@Added ma_transmit[3], for light transmission through glass.
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 5.3 87/06/26 22:29:35 mike Exp $
d248 2
a249 2
	char	ma_override;		/* non-0 ==> c_rgb is color */
	unsigned char ma_rgb[3];	/* explicit color:  0..255  */
@


5.2
log
@Moved mfuncs struct to RT-specific header file.
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 5.1 87/06/24 21:47:22 mike Locked $
d247 1
@


5.1
log
@Release 1.24
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 4.8 87/05/21 01:54:33 mike Locked $
a253 17
 *			M F U N C S
 *
 *  The interface to the various material property & texture routines.
 */
struct mfuncs {
	char		*mf_name;	/* Keyword for material */
	int		mf_magic;	/* To validate structure */
	struct mfuncs	*mf_forw;	/* Forward link */
	int		(*mf_setup)();	/* Routine for preparing */
	int		(*mf_render)();	/* Routine for rendering */
	int		(*mf_print)();	/* Routine for printing */
	int		(*mf_free)();	/* Routine for releasing storage */
};
#define MF_MAGIC	0x55968058
#define MF_NULL		((struct mfuncs *)0)

/*
d268 1
a268 1
	struct mfuncs	*reg_mfuncs;	/* User appl. funcs for material */
@


4.8
log
@Added a_overlap
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 4.7 87/04/28 00:25:21 mike Locked $
@


4.7
log
@changed RT_CURVE convention (no more ray pointer)
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 4.6 87/03/24 01:01:18 phil Locked $
d524 1
d540 1
@


4.6
log
@added ID_SPH for sphere
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 4.5 87/03/23 23:34:42 phil Locked $
d92 1
a92 1
#define RT_CURVE( curvp, hitp, stp, rayp )  { \
d98 1
a98 1
	(void)rt_functab[id].ft_curve( curvp, hitp, stp, rayp ); }
@


4.5
log
@New version, rt_i global extern eliminated,
Added functab for material libraries.
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 4.4 87/03/11 00:14:02 mike Exp $
d181 1
@


4.4
log
@Added initial animation structures.
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 4.3 87/02/12 22:00:27 mike Exp $
d33 2
a34 2
	p = (struct str *)rt_malloc(sizeof(struct str), "getstruct str"); \
	if( p == (struct str *)0 ) \
d92 7
a98 2
#define RT_CURVE( curvp, hitp, stp, rayp ) \
	rt_functab[(stp)->st_id].ft_curve( curvp, hitp, stp, rayp )
d189 1
d198 2
a199 1
	char		*ft_name;
d202 1
d253 17
d284 1
a284 1
	int		(*reg_ufunc)();	/* User appl. func for material */
d303 7
a309 2
#define RT_HIT_NORM( hitp, stp, rayp ) \
	rt_functab[(stp)->st_id].ft_norm(hitp, stp, rayp)
d321 1
a321 1
	long		pt_solhit[2];		/* VAR bit array:solids hit */
d323 1
a323 1
#define PT_NULL	((struct partition *)0)
d325 2
a326 2
#define PT_BYTES	(sizeof(struct partition) + \
			 BITS2BYTES(rt_i.nsolids) + sizeof(bitv_t))
a327 2
#define COPY_PT(out,in)	bcopy((char *)in, (char *)out, PT_BYTES)

d329 2
a330 2
#define GET_PT_INIT(p,res)	\
	{ GET_PT(p,res); bzero( ((char *) (p)), PT_BYTES ); }
d332 1
a332 1
#define GET_PT(p,res)   { \
d334 1
a334 1
				rt_get_pt(res); \
d371 1
a371 1
#define GET_BITV(p,res)  { \
d373 1
a373 1
				rt_get_bitv(res); \
d531 1
a531 2
	point_t		a_color;	/* application-specific color */
	vect_t		a_uvec;		/* application-specific vector */
d534 3
d549 1
a549 1
	int		res_malloc;	/* lock on memory allocation */
d552 2
d560 3
a562 3
 *  Definitions for librt.a which are specific to the
 *  particular model being processed;  ultimately,
 *  there could be several instances of this structure.
a567 1
	union tree	*RootTree;	/* ptr to total tree (non-region) */
d588 3
d593 1
a594 2
extern struct rt_i rt_i;	/* Eventually, will be a return value */

d613 1
a613 1
extern struct rt_i *rt_dirbuild();	/* Read named GED db, build toc */
a619 1
extern void rt_viewbounds();		/* Find bounding view-space RPP */
@


4.3
log
@Release 1.20 -- First Formal Release
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 4.2 87/01/28 22:33:03 mike Exp $
d401 1
d410 36
d556 1
@


4.2
log
@Release 1.16:  Added RT_CURVE macro and some comments.
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 4.1 86/12/29 02:46:06 mike Locked $
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 3.13 86/12/24 08:03:29 mike Exp $
d75 5
d88 6
@


3.13
log
@Added resource structure.
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 3.12 86/12/18 16:53:48 mike Locked $
@


3.12
log
@Added rti_db
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 3.11 86/11/07 02:54:50 mike Locked $
d115 4
a118 4
#define GET_SEG(p)    {	RES_ACQUIRE(&rt_g.res_seg); \
			while( ((p)=rt_g.FreeSeg) == SEG_NULL ) \
				rt_get_seg(); \
			rt_g.FreeSeg = (p)->seg_next; \
d120 1
a120 4
			RES_RELEASE(&rt_g.res_seg); }
#define FREE_SEG(p)   {	RES_ACQUIRE(&rt_g.res_seg); \
			(p)->seg_next = rt_g.FreeSeg; rt_g.FreeSeg = (p); \
			RES_RELEASE(&rt_g.res_seg); }
d122 4
d127 1
d290 2
a291 2
#define GET_PT_INIT(p)	\
	{ GET_PT(p); bzero( ((char *) (p)), PT_BYTES ); }
d293 5
a297 8
#define GET_PT(p)   { RES_ACQUIRE(&rt_g.res_pt); \
			while( ((p)=rt_g.FreePart) == PT_NULL ) \
				rt_get_pt(); \
			rt_g.FreePart = (p)->pt_forw; \
			RES_RELEASE(&rt_g.res_pt); }
#define FREE_PT(p) { RES_ACQUIRE(&rt_g.res_pt); \
			(p)->pt_forw = rt_g.FreePart; rt_g.FreePart = (p); \
			RES_RELEASE(&rt_g.res_pt); }
d299 5
d332 4
a335 4
#define GET_BITV(p)    {	RES_ACQUIRE(&rt_g.res_bitv); \
			while( ((p)=rt_i.FreeBitv) == BITV_NULL ) \
				rt_get_bitv(); \
			rt_i.FreeBitv = (p)->be_next; \
d337 1
a337 4
			RES_RELEASE(&rt_g.res_bitv); }
#define FREE_BITV(p)   {	RES_ACQUIRE(&rt_g.res_bitv); \
			(p)->be_next = rt_i.FreeBitv; rt_i.FreeBitv = (p); \
			RES_RELEASE(&rt_g.res_bitv); }
d339 5
d397 32
d430 1
d444 7
a450 6
	struct xray a_ray;	/* Actual ray to be shot */
	int	(*a_hit)();	/* routine to call when shot hits model */
	int	(*a_miss)();	/* routine to call when shot misses */
	int	a_level;	/* recursion level (for printing) */
	int	a_onehit;	/* flag to stop on first hit */
	struct rt_i *a_rt_i;	/* this librt instance */
d452 7
a458 7
	int	a_x;		/* Screen X of ray, where applicable */
	int	a_y;		/* Screen Y of ray, where applicable */
	int	a_user;		/* application-specific value */
	point_t	a_color;	/* application-specific color */
	vect_t	a_uvec;		/* application-specific vector */
	fastf_t	a_rbeam;	/* initial beam radius (mm) */
	fastf_t	a_diverge;	/* slope of beam divergance/mm */
a468 2
	struct seg 	*FreeSeg;	/* Head of segment freelist */
	struct partition *FreePart;	/* Head of freelist */
a470 2
	int		res_pt;		/* lock on free partition structs */
	int		res_seg;	/* lock on free seg structs */
a471 2
	int		res_printf;	/* lock on printing */
	int		res_bitv;	/* lock on bitvectors */
a492 1
	union bitv_elem *FreeBitv;	/* head of freelist */
@


3.11
log
@Added RT_HIT_NORM
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 3.10 86/10/27 22:17:48 mike Locked $
d474 1
@


3.10
log
@Redefined VPRINT to use rt_log rather than printf.
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 3.9 86/07/24 06:01:45 mike Exp $
a250 1

d254 2
a255 1
 *  Partitions of a ray
d257 5
d265 3
@


3.9
log
@Added uvcoord
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 3.8 86/07/24 01:38:26 mike Exp $
d430 2
d470 9
@


3.8
log
@Added curvature and beam divergance
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 3.7 86/07/22 04:12:47 mike Exp $
d82 14
@


3.7
log
@Returned cn_point to being a fastf_t.
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 3.6 86/07/22 03:44:54 mike Exp $
d71 11
d395 2
d517 1
@


3.6
log
@Added ft_use_rpp flag, ft_curve, ft_classify
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 3.5 86/07/22 03:25:17 mike Exp $
d329 1
a329 1
		long	cn_point;	/* cut through axis==point */
@


3.5
log
@Made cut node values long's,
added st_back to soltab for eventual expansion to double linking.
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 3.4 86/07/19 04:37:04 mike Exp $
d146 1
d152 2
@


3.4
log
@Cleaned and combined version, with rtdir.h and cut.h
included.
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 3.3 86/07/11 17:22:20 mike Exp $
d113 2
a114 1
	struct soltab	*st_forw;	/* Linked list of solids */
d326 1
a326 1
		fastf_t	cn_point;	/* cut through axis==point */
@


3.3
log
@material to mater_info for non-flexnames
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 3.2 86/07/11 01:30:07 mike Exp $
d24 2
a25 8
#ifdef HEP
/* full means resource free, empty means resource busy */
#define	RES_ACQUIRE(ptr)	(void)Daread(ptr)	/* wait full set empty */
#define RES_RELEASE(ptr)	(void)Daset(ptr,3)	/* set full */
#else
#define RES_ACQUIRE(ptr)	;
#define RES_RELEASE(ptr)	;
#endif
d138 6
a153 2
#define NEAR_ZERO(val,epsilon)	( ((val) > -epsilon) && ((val) < epsilon) )
#define INFINITY	(1.0e20)
a154 1

d313 1
a313 1
 *		A P P L I C A T I O N
d315 43
d383 2
d392 1
d403 2
d414 5
a419 1
	int		fd;		/* fd of database */
a426 3
	vect_t		mdl_min;	/* min corner of model bounding RPP */
	vect_t		mdl_max;	/* max corner of model bounding RPP */
	union bitv_elem *FreeBitv;	/* head of freelist */
a427 1
	char		*file;		/* name of file */
d429 4
d434 2
d438 6
a443 3
/*
 *  Global routines to interface with the RT library.
 */
d447 1
a447 1
extern int rt_gettree();		/* Get expr tree for object */
d450 3
a452 4
extern void rt_prep_timer();		/* Start the timer */
extern double rt_read_timer();		/* Read timer, return time + str */
extern int rt_dirbuild();		/* Read named GED db, build toc */
extern void rt_pr_seg();			/* Print seg struct */
d457 2
a458 4
/* RT Storage allocators */
extern char *rt_malloc();			/* visible malloc() */
extern void rt_free();			/* visible free() */
extern char *rt_strdup();			/* Duplicate str w/malloc */
d465 11
a475 4
/*
 *  Internal routines in RT library.
 *  Not intended for general use.
 */
d499 1
d507 1
a507 1
double rt_invpi, rt_inv2pi;
a511 2
extern long	lseek();
extern int	read(), write();
d513 1
a513 1
extern void	free();
@


3.2
log
@Minor cleanups inspired by the Cray
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 3.1 86/06/11 00:36:46 mike Exp $
d196 1
a196 1
 *			M A T E R I A L
d198 1
a198 1
struct material {
d219 1
a219 1
	struct material	reg_mater;	/* Real material information */
@


3.1
log
@Added support for new object-oriented material-property functions.
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 3.0 86/06/10 01:33:09 mike Exp $
d21 3
d154 1
a154 2
#define EPSILON		0.0001
#define NEAR_ZERO(f)	( ((f) > -EPSILON) && ((f) < EPSILON) )
d216 1
a216 1
	short		reg_material;	/* GIFT Material code */
d333 1
d420 3
a422 3
extern void rt_bool_weave();		/* Weave segs into partitions */
extern void rt_bool_final();		/* Eval booleans over partitions */
extern int rt_bool_eval();		/* Eval bool tree node */
d446 1
a446 1
 *  Library routines used by the RT library.
d448 5
d457 2
@


3.0
log
@rt/ and librt/ separated,
global datastructures simplified.
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 2.5 85/09/18 01:26:52 mike Exp $
d193 9
d214 1
a214 1
	short		reg_material;	/* Material */
d217 3
a219 1
	char		*reg_materp;	/* material structure */
d380 1
d436 2
@


2.5
log
@Added extra resource lock for HEP
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 2.4 85/09/14 05:30:53 mike Exp $
a20 8
/*
 *  Definitions necessary to operate in a parallel environment.
 */
extern int	res_pt;			/* lock on free partition structs */
extern int	res_seg;		/* lock on free seg structs */
extern int	res_malloc;		/* lock on memory allocation */
extern int	res_printf;		/* lock on printing */
extern int	res_bitv;		/* lock on bitvectors */
d36 1
a36 1
	p = (struct str *)vmalloc(sizeof(struct str), "getstruct str"); \
d46 1
a46 1
 * Not called just "ray" to prevent conflicts with other VLD stuff.
d92 5
a96 5
extern struct seg *FreeSeg;		/* Head of freelist */
#define GET_SEG(p)    {	RES_ACQUIRE(&res_seg); \
			while( ((p)=FreeSeg) == SEG_NULL ) \
				get_seg(); \
			FreeSeg = (p)->seg_next; \
d98 4
a101 4
			RES_RELEASE(&res_seg); }
#define FREE_SEG(p)   {	RES_ACQUIRE(&res_seg); \
			(p)->seg_next = FreeSeg; FreeSeg = (p); \
			RES_RELEASE(&res_seg); }
d141 1
a141 1
struct functab {
d149 1
a149 1
extern struct functab functab[];
d153 1
a153 1
#define INFINITY	1000000000.0
a211 2
extern struct region **Regions;		/* ptrs to regions [reg_bit] */
extern long nregions;			/* total # of regions participating */
a212 1

d218 2
a219 2
 *  NOTE:  get_pt allows enough storage at the end of the partition
 *  for a bit vector of "nsolids" bits in length.
a232 1

a233 1
extern struct partition *FreePart;		 /* Head of freelist */
d236 1
a236 1
			 BITS2BYTES(nsolids) + sizeof(bitv_t))
d244 8
a251 8
#define GET_PT(p)   { RES_ACQUIRE(&res_pt); \
			while( ((p)=FreePart) == PT_NULL ) \
				get_pt(); \
			FreePart = (p)->pt_forw; \
			RES_RELEASE(&res_pt); }
#define FREE_PT(p) { RES_ACQUIRE(&res_pt); \
			(p)->pt_forw = FreePart; FreePart = (p); \
			RES_RELEASE(&res_pt); }
d273 19
d305 1
a305 1
 * Note:  When calling shootray(), these fields are mandatory:
d311 1
a311 1
 * Also note that shootray() returns the (int) return of a_hit()/a_miss().
d329 2
a330 1
 *  Global variables used by the RT library.
d332 12
a343 13
extern int ged_fd;		/* fd of object file */
extern int debug;		/* non-zero for debugging, see debug.h */
extern long nsolids;		/* total # of solids participating */
extern long nregions;		/* total # of regions participating */
extern long nshots;		/* # of calls to ft_shot() */
extern long nmiss_model;	/* rays missed model RPP */
extern long nmiss_tree;		/* rays missed sub-tree RPP */
extern long nmiss_solid;	/* rays missed solid RPP */
extern long nmiss;		/* solid ft_shot() returned a miss */
extern long nhits;		/* solid ft_shot() returned a hit */
extern struct soltab *HeadSolid;/* pointer to list of solids in model */
extern vect_t mdl_min;		/* min corner of model bounding RPP */
extern vect_t mdl_max;		/* max corner of model bounding RPP */
d346 27
d375 2
a376 2
extern void rtbomb();			/* Fatal error */
extern void rtlog();			/* Log message */
d378 1
a378 1
extern int get_tree();			/* Get expr tree for object */
d380 8
a387 8
extern int shootray();			/* Shoot a ray */
extern void prep_timer();		/* Start the timer */
extern double read_timer();		/* Read timer, return time + str */
extern int dir_build();			/* Read named GED db, build toc */
extern void pr_seg();			/* Print seg struct */
extern void pr_partitions();		/* Print the partitions */
extern void viewbounds();		/* Find bounding view-space RPP */
extern struct soltab *find_solid();	/* Find solid by leaf name */
d389 4
a392 2
extern char *vmalloc();			/* visible malloc() */
extern void vfree();			/* visible free() */
d401 1
a401 1
 *  Not for general use.
d403 24
a426 11
extern struct directory *dir_lookup();	/* Look up name in toc */
extern struct directory *dir_add();	/* Add name to toc */
extern char *strdup();			/* Duplicate str w/malloc */
extern void bool_regions();		/* Eval booleans */
extern int bool_eval();			/* Eval bool tree node */
extern int fdiff();			/* Approx Floating compare */
extern double reldiff();		/* Relative Difference */
extern void pr_region();		/* Print a region */
extern void pr_tree();			/* Print an expr tree */
extern void fastf_float();		/* convert float->fastf_t */
extern void get_seg(), get_pt();	/* storage obtainers */
@


2.4
log
@Created BITS2BYTES to unify sizing of bit vectors.
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 2.4 85/09/14 05:27:02 mike Exp $
d28 1
@


2.3
log
@Changed pr_timer to read_timer.
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 2.2 85/09/06 02:25:46 mike Exp $
d248 1
a248 1
			 ((nsolids)+BITV_MASK)/8 + sizeof(bitv_t))
d289 1
d293 1
a293 1
#define BITZERO(lp,bits) bzero((char *)lp, ((bits)+BITV_MASK)/8 )
@


2.2
log
@Added a_uvec, for application use.
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 2.1 85/08/31 06:02:07 mike Exp $
d347 1
a347 1
extern double pr_timer();		/* Stop timer, print, return time */
@


2.1
log
@Version 2 of RT
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 1.24 85/07/30 05:51:16 mike Exp $
d310 1
a310 1
	int	a_level;	/* recursion level */
d317 1
d352 1
@


1.24
log
@Revised for joint GED/RT vmath.h;  some storage cleanups.
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 1.23 85/06/05 00:25:32 mike Exp $
a59 1
	struct xray	*r_forw;	/* !0 -> ray after deflection */
d72 1
d75 2
a76 1
	fastf_t		hit_dist;	/* dist from r_pt to hit_point */
a92 3
	int		seg_flag;
#define SEG_IN		0x4		/* IN point, normal, computed */
#define SEG_OUT		0x8		/* OUT point, normal, computed */
a95 1
	union tree	*seg_tp;	/* pointer to solid leaf node */
d119 3
a121 2
	vect_t		st_center;	/* Center of bounding Sphere */
	fastf_t		st_radsq;	/* Bounding sphere Radius, squared */
d127 3
a129 3
/*** bin is NOT PARALLEL ** */
	int		st_bin;		/* Temporary for boolean processing */
	int		st_uses;	/* # of refs by tr_stp leaves */
d145 2
d152 2
d160 1
a160 1
#define INFINITY	100000000.0
d166 1
a166 2
 *  Binary trees representing the Boolean operations which
 *  combine one or more solids into a region.
d168 1
a168 3
#define MKOP(x)		((x)<<1)
#define OP_BINARY	0x01			/* Binary/Unary (leaf) flag */
#define BINOP(x)	((x)->tr_op & OP_BINARY)
d170 9
a178 4
#define OP_SOLID	MKOP(1)			/* Leaf:  tr_stp -> solid */
#define OP_UNION	MKOP(2)|OP_BINARY	/* Binary: L union R */
#define OP_INTERSECT	MKOP(3)|OP_BINARY	/* Binary: L intersect R */
#define OP_SUBTRACT	MKOP(4)|OP_BINARY	/* Binary: L subtract R */
a179 2
#define TFLAG_NOBOUND	1			/* skip bounding RPP check */

d182 3
a184 5
	struct tree_binary {
		int		tb_op;		/* | OP_BINARY */
		int		tb_flags;
		vect_t		tb_min;		/* subtree min pt of RPP */
		vect_t		tb_max;		/* subtree max pt of RPP */
d188 1
a188 1
	struct tree_unary {
d190 1
a190 3
		int		tu_flags;
		vect_t		tu_min;		/* subtree min pt of RPP */
		vect_t		tu_max;		/* subtree max pt of RPP */
a191 1
		struct region	*tu_regionp;	/* ptr to containing region */
a192 1
		char		*tu_materp;	/* (struct mater *) */
d195 1
a195 6
#define tr_left		tr_b.tb_left
#define tr_right	tr_b.tb_right
#define tr_flags	tr_b.tb_flags
#define tr_min		tr_b.tb_min
#define tr_max		tr_b.tb_max
#define tr_stp		tr_a.tu_stp
d197 1
a197 2
#define tr_name		tr_a.tu_name
#define tr_materp	tr_a.tu_materp
a200 1

d209 1
d215 1
a215 1
	struct region	*reg_active;	/* linked list of hit regions */
d219 2
d227 3
a230 2
#define NBINS	200			/* # bins: # solids hit in ray */

a231 1
	unsigned char	pt_solhit[NBINS];	/* marks for solids hit */
d241 1
a242 2
#define pt_indist	pt_inhit->hit_dist
#define pt_outdist	pt_outhit->hit_dist
d247 6
a252 1
/* Initialize all the bins to FALSE, clear out structure */
d254 1
a254 1
	{ GET_PT(p);bzero( ((char *) (p)), sizeof(struct partition) ); }
d285 10
d303 1
a303 1
 * Also note that shootray() returns the return of a_hit/a_miss().
d310 2
d316 1
a316 3
	int	(*a_init)();	/* routine to init application */
	int	(*a_eol)();	/* routine for end of scan-line */
	int	(*a_end)();	/* routine to end application */
a322 1
extern int one_hit_flag;	/* non-zero to return first hit only */
d339 3
d343 1
a344 1
extern void rtbomb();			/* Exit with error message */
d350 1
a370 1
extern void pr_bins();			/* Print bins */
@


1.23
log
@timer_print, timer_prep changed to prep_timer, pr_timer
to accomodate compilers that only look at the first 8 chars.
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 1.22 85/06/04 23:23:43 mike Exp $
a20 3
extern char *malloc();
extern void free();

d43 2
a44 6
	if( debug & DEBUG_MEM )  printf("getstruct( str ): %s\n", __FILE__); \
	RES_ACQUIRE( &res_malloc ); \
	p = (struct str *)malloc(sizeof(struct str)); \
	RES_RELEASE( &res_malloc ); \
	if( p == (struct str *)0 ) { \
		fprintf(stderr,"rt/getstruct( p, str ): malloc failed\n");/* cpp magic */ \
d46 1
a46 1
	}  bzero( (char *)p, sizeof(struct str));
d104 3
a106 5
			if( ((p)=FreeSeg) == SEG_NULL )  { \
				GETSTRUCT((p), seg); \
			} else { \
				FreeSeg = (p)->seg_next; \
			} \
d129 1
d261 3
a263 5
			if( ((p)=FreePart) == PT_NULL )  { \
				GETSTRUCT((p), partition); \
			} else { \
				FreePart = (p)->pt_forw; \
			} \
d343 3
d366 1
@


1.22
log
@Various little changed needed to make the HEP version work.
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 1.21 85/05/29 00:13:14 mike Exp $
d347 2
a348 2
extern void timer_prep();		/* Start the timer */
extern double timer_print();		/* Stop timer, print, return time */
@


1.21
log
@Moved region and material pointer from solid structure to tree (leaf)
nodes, added path matrix and use count to solid structure, to permit
solids referenced with identical path matrices to "share",
resulting in far greater speed.
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 1.20 85/05/28 21:30:49 mike Exp $
d25 32
d110 2
a111 1
#define GET_SEG(p)    {	if( ((p)=FreeSeg) == SEG_NULL )  { \
d116 5
a120 2
			p->seg_next = SEG_NULL; }
#define FREE_SEG(p) {(p)->seg_next = FreeSeg; FreeSeg = (p);}
d268 2
a269 1
#define GET_PT(p)   { if( ((p)=FreePart) == PT_NULL )  { \
d273 5
a277 2
			}  }
#define FREE_PT(p) {(p)->pt_forw = FreePart; FreePart = (p);}
d338 2
a339 2
extern vect_t model_min;	/* min corner of model bounding RPP */
extern vect_t model_max;	/* max corner of model bounding RPP */
@


1.20
log
@Added tr_name, st_pathmat, to allow compressing
multiple references to the same solid in various contexts.
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 1.19 85/03/25 17:43:55 mike Exp $
d73 1
a99 1
	struct region	*st_regionp;	/* Pointer to containing region */
a102 1
	char		*st_materp;	/* (struct mater *) */
d148 2
d154 1
d162 1
d166 1
d168 1
d173 1
d177 1
d179 1
@


1.19
log
@Added materp to soltab struct
@
text
@d18 1
a18 1
 *  $Header: raytrace.h,v 1.18 85/03/25 11:43:51 mike Exp $
d90 1
d98 1
a98 1
	char		*st_name;	/* Name of solid */
d104 2
d163 1
d171 1
@


1.18
log
@Housekeeping
@
text
@d18 1
a18 1
 *  $Header$
d102 1
@


1.17
log
@changed return type
@
text
@d4 1
a4 1
 * All the structures necessary for dealing with the RT ray tracer routines.
d6 13
a18 1
 * $Revision: 1.16 $
@


1.16
log
@Return types changed.
@
text
@d6 1
a6 1
 * $Revision: 1.15 $
d278 1
a278 1
extern struct soltab *get_tree();	/* Get expr tree for object */
@


1.15
log
@Added more statistics on success of pruning algorithm.
@
text
@d6 1
a6 1
 * $Revision: 1.14 $
d278 1
a278 1
extern void get_tree();			/* Get expr tree for object */
d283 1
a283 1
extern void dir_build();		/* Read named GED db, build toc */
@


1.14
log
@Latest adjustments
@
text
@d6 1
a6 1
 * $Revision: 1.13 $
d265 6
a270 2
extern long nshots;		/* # of ray-meets-solid "shots" */
extern long nmiss;		/* # of ray-misses-solid's-sphere "shots" */
@


1.13
log
@Added space for region and tree bounding RPPs
@
text
@d6 1
a6 1
 * $Revision: 1.12 $
d137 2
a140 2
		vect_t		tb_min;		/* subtree min pt of RPP */
		vect_t		tb_max;		/* subtree max pt of RPP */
d144 2
a171 2
	vect_t		reg_min;	/* min point, region RPP */
	vect_t		reg_max;	/* max point, region RPP */
d186 1
a186 1
	struct soltab	*pt_instp;		/* IN solid pointer */
d188 1
a188 1
	struct soltab	*pt_outstp;		/* OUT solid pointer */
d234 8
d248 1
a250 1
	/* THE FOLLOWING ROUTINES ARE MAINLINE & APPLICATION SPECIFIC */
d268 2
d275 1
a275 1
extern void shootray();			/* Shoot a ray */
d280 2
a281 1
extern void pr_seg();				/* Print seg struct */
@


1.12
log
@Added normal flipping flags in partition.
Made NEAR_ZERO function more efficient for some inputs.
@
text
@d6 1
a6 1
 * $Revision: 1.11 $
d131 1
a131 1
#define OP_SUBTRACT	MKOP(4)|OP_BINARY	/* Binary: L intersect R */
d136 1
a136 1
		int		tb_op;
d139 2
d143 1
a143 1
		int		tu_op;
d149 2
d170 2
@


1.11
log
@Added LOCAL, fastf_t declarations.
Made shootray() recursive.
@
text
@d6 1
a6 1
 * $Revision: 1.10 $
d114 1
a114 1
#define NEAR_ZERO(f)	( ((f) < 0) ? ((f) > -EPSILON) : ((f) < EPSILON) )
d187 2
@


1.10
log
@General cleanup
@
text
@d6 1
a6 1
 * $Revision: 1.9 $
d275 9
a283 9
extern char *strdup();				/* Duplicate str w/malloc */
extern struct partition *bool_regions();	/* Eval booleans */
extern int bool_eval();				/* Eval bool tree node */
extern int fdiff();				/* Approx Floating compare */
extern double reldiff();			/* Relative Difference */
extern void pr_bins();				/* Print bins */
extern void pr_region();			/* Print a region */
extern void pr_tree();				/* Print an expr tree */
extern void fastf_float();			/* convert float->fastf_t */
@


1.9
log
@struct ray --> struct xray, for the VLDers
ray.h --> raytrace.h too
@
text
@d2 1
a2 1
 *			R T . H
d6 1
a6 1
 * $Revision: 1.8 $
d111 1
d240 52
@


1.8
log
@Lint corrections
@
text
@d2 1
a2 1
 *			R A Y . H
d4 3
a6 1
 * $Revision: 1.7 $
d13 1
a13 1
 *			R A Y
d16 1
d18 1
a18 1
struct ray {
d23 1
a23 1
	struct ray	*r_forw;	/* !0 -> ray after deflection */
d25 1
a25 1
#define RAY_NULL	((struct ray *)0)
d87 2
d228 1
a228 1
	struct ray a_ray;	/* Actual ray to be shot */
@


1.7
log
@Added "application" structure
@
text
@d4 1
a4 1
 * $Revision: 1.6 $
d7 3
d185 1
a185 1
#define PART_NULL	((struct partition *)0)
d189 2
a190 2
#define GET_PART_INIT(p)	\
	{ GET_PART(p);bzero( ((char *) (p)), sizeof(struct partition) ); }
d192 1
a192 1
#define GET_PART(p)   { if( ((p)=FreePart) == PART_NULL )  { \
d197 1
a197 1
#define FREE_PART(p) {(p)->pt_forw = FreePart; FreePart = (p);}
d200 1
a200 1
#define INSERT_PART(new,old)	{ \
d207 1
a207 1
#define APPEND_PART(new,old)	{ \
d214 1
a214 1
#define DEQUEUE_PART(cur)	{ \
@


1.6
log
@Fixed bug with GET_SEG
@
text
@d4 1
a4 1
 * $Revision: 1.5 $
d214 17
@


1.5
log
@Minor changes.
@
text
@d4 1
a4 1
 * $Revision: 1.4 $
d63 2
a64 1
			} }
@


1.4
log
@Modifications for ARS, code unified to use fastf_t
@
text
@d4 1
a4 1
 * $Revision: 1.3 $
d166 1
a166 1
#define NBINS	100			/* # bins: # solids hit in ray */
@


1.3
log
@changed floats to fastf_t, added freelist for seg structs.
@
text
@d4 1
a4 1
 * $Revision: 1.2 $
d94 1
@


1.2
log
@Boolean operation support
@
text
@d4 1
a4 1
 * $Revision: 1.1 $
d15 2
a16 2
	float		r_min;		/* entry dist to bounding sphere */
	float		r_max;		/* exit dist from bounding sphere */
d32 1
a32 1
	float		hit_dist;	/* dist from r_pt to hit_point */
d58 7
a66 1

d75 1
a75 1
	float		st_radsq;	/* Bounding sphere Radius, squared */
d104 1
a104 1

@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
 * $Revision$
d8 2
d19 1
d21 1
d23 2
d34 1
d36 2
d39 2
d57 1
d59 2
d62 2
d67 8
a74 6
	int	st_id;		/* Solid ident */
	vect_t	st_center;	/* Center of bounding Sphere */
	float	st_radsq;	/* Bounding sphere Radius, squared */
	int	*st_specific;	/* Ptr to type-specific (private) struct */
	struct soltab *st_forw;	/* Linked list of solids */
	char	*st_name;	/* Name of solid */
d76 1
d90 4
a93 3
	int	(*ft_prep)();
	int	(*ft_shot)();
	int	(*ft_print)();
d98 108
@
