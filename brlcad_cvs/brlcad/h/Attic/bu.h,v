head	1.145;
access;
symbols
	ansi-20040405-merged:1.136.2.5
	postmerge-20040405-ansi:1.143
	premerge-20040404-ansi:1.142
	postmerge-autoconf:1.142
	autoconf-freeze:1.139.6.6
	premerge-autoconf:1.141
	ansi-20040316-freeze:1.136.2.1
	postmerge-20040315-windows:1.141
	premerge-20040315-windows:1.141
	windows-20040315-freeze:1.136.4.1
	autoconf-20031203:1.139
	autoconf-20031202:1.139
	autoconf-branch:1.139.0.6
	phong-branch:1.139.0.4
	photonmap-branch:1.139.0.2
	rel-6-1-DP:1.138
	windows-branch:1.136.0.4
	rel-6-0-2:1.134
	ansi-branch:1.136.0.2
	rel-6-0-1-branch:1.134.0.2
	hartley-6-0-post:1.135
	hartley-6-0-pre:1.134
	rel-6-0-1:1.134
	rel-6-0:1.134
	rel-5-4:1.90.2.2
	offsite-5-3-pre:1.113
	rel-5-3:1.90.2.2
	rel-5-2:1.90
	rel-5-1-branch:1.90.0.2
	rel-5-1:1.90
	rel-5-0:1.65
	rel-5-0-beta:1.62
	rel-4-5:1.42
	ctj-4-5-post:1.37
	ctj-4-5-pre:1.36;
locks; strict;
comment	@ * @;


1.145
date	2004.05.24.04.11.52;	author morrison;	state dead;
branches;
next	1.144;

1.144
date	2004.05.10.15.30.42;	author erikg;	state Exp;
branches;
next	1.143;

1.143
date	2004.04.05.09.31.17;	author morrison;	state Exp;
branches;
next	1.142;

1.142
date	2004.03.18.14.44.47;	author erikg;	state Exp;
branches;
next	1.141;

1.141
date	2004.03.03.19.38.22;	author morrison;	state Exp;
branches;
next	1.140;

1.140
date	2003.12.09.15.00.25;	author jra;	state Exp;
branches;
next	1.139;

1.139
date	2002.11.11.01.18.45;	author jra;	state Exp;
branches
	1.139.6.1;
next	1.138;

1.138
date	2002.10.11.08.30.56;	author kermit;	state Exp;
branches;
next	1.137;

1.137
date	2002.10.01.13.52.32;	author jra;	state Exp;
branches;
next	1.136;

1.136
date	2002.08.20.17.07.29;	author jra;	state Exp;
branches
	1.136.2.1
	1.136.4.1;
next	1.135;

1.135
date	2002.08.15.20.54.42;	author hartley;	state Exp;
branches;
next	1.134;

1.134
date	2002.02.22.16.07.34;	author jra;	state Exp;
branches;
next	1.133;

1.133
date	2002.02.17.03.03.04;	author jra;	state Exp;
branches;
next	1.132;

1.132
date	2001.10.15.17.54.38;	author butler;	state Exp;
branches;
next	1.131;

1.131
date	2001.10.15.15.35.00;	author butler;	state Exp;
branches;
next	1.130;

1.130
date	2001.10.11.21.25.10;	author butler;	state Exp;
branches;
next	1.129;

1.129
date	2001.10.11.20.44.04;	author butler;	state Exp;
branches;
next	1.128;

1.128
date	2001.08.10.15.38.47;	author jra;	state Exp;
branches;
next	1.127;

1.127
date	2001.08.09.20.31.32;	author jra;	state Exp;
branches;
next	1.126;

1.126
date	2001.08.09.19.38.25;	author rbowers;	state Exp;
branches;
next	1.125;

1.125
date	2001.08.07.14.39.02;	author jra;	state Exp;
branches;
next	1.124;

1.124
date	2001.08.06.21.23.50;	author jra;	state Exp;
branches;
next	1.123;

1.123
date	2001.08.06.20.48.35;	author jra;	state Exp;
branches;
next	1.122;

1.122
date	2001.07.20.18.47.55;	author rbowers;	state Exp;
branches;
next	1.121;

1.121
date	2001.06.14.15.04.39;	author bparker;	state Exp;
branches;
next	1.120;

1.120
date	2001.05.16.21.37.43;	author morrison;	state Exp;
branches;
next	1.119;

1.119
date	2001.05.08.20.28.06;	author jra;	state Exp;
branches;
next	1.118;

1.118
date	2001.05.08.20.04.50;	author jra;	state Exp;
branches;
next	1.117;

1.117
date	2001.04.05.19.35.06;	author morrison;	state Exp;
branches;
next	1.116;

1.116
date	2001.03.23.22.33.45;	author butler;	state Exp;
branches;
next	1.115;

1.115
date	2001.03.21.21.56.17;	author bparker;	state Exp;
branches;
next	1.114;

1.114
date	2001.03.19.22.19.24;	author butler;	state Exp;
branches;
next	1.113;

1.113
date	2000.10.24.15.30.24;	author mike;	state Exp;
branches;
next	1.112;

1.112
date	2000.10.24.14.35.45;	author mike;	state Exp;
branches;
next	1.111;

1.111
date	2000.10.18.20.50.26;	author mike;	state Exp;
branches;
next	1.110;

1.110
date	2000.09.08.14.24.17;	author bparker;	state Exp;
branches;
next	1.109;

1.109
date	2000.09.07.17.42.05;	author mike;	state Exp;
branches;
next	1.108;

1.108
date	2000.09.05.21.06.03;	author mike;	state Exp;
branches;
next	1.107;

1.107
date	2000.08.30.23.39.24;	author mike;	state Exp;
branches;
next	1.106;

1.106
date	2000.08.30.23.03.03;	author mike;	state Exp;
branches;
next	1.105;

1.105
date	2000.08.23.00.31.58;	author mike;	state Exp;
branches;
next	1.104;

1.104
date	2000.08.22.03.18.06;	author mike;	state Exp;
branches;
next	1.103;

1.103
date	2000.08.21.02.06.59;	author butler;	state Exp;
branches;
next	1.102;

1.102
date	2000.07.24.18.36.42;	author butler;	state Exp;
branches;
next	1.101;

1.101
date	2000.07.13.02.35.32;	author cjohnson;	state Exp;
branches;
next	1.100;

1.100
date	2000.07.13.00.29.05;	author mike;	state Exp;
branches;
next	1.99;

1.99
date	2000.07.12.03.25.42;	author cjohnson;	state Exp;
branches;
next	1.98;

1.98
date	2000.07.12.01.12.40;	author mike;	state Exp;
branches;
next	1.97;

1.97
date	2000.07.11.23.12.37;	author mike;	state Exp;
branches;
next	1.96;

1.96
date	2000.07.05.21.19.33;	author mike;	state Exp;
branches;
next	1.95;

1.95
date	2000.06.29.20.49.37;	author mike;	state Exp;
branches;
next	1.94;

1.94
date	2000.06.29.20.47.54;	author mike;	state Exp;
branches;
next	1.93;

1.93
date	2000.06.29.17.53.41;	author mike;	state Exp;
branches;
next	1.92;

1.92
date	2000.06.29.14.26.37;	author mike;	state Exp;
branches;
next	1.91;

1.91
date	2000.06.26.18.05.38;	author mike;	state Exp;
branches;
next	1.90;

1.90
date	2000.06.23.05.52.57;	author mike;	state Exp;
branches
	1.90.2.1;
next	1.89;

1.89
date	2000.06.23.02.13.03;	author mike;	state Exp;
branches;
next	1.88;

1.88
date	2000.05.08.20.43.51;	author mike;	state Exp;
branches;
next	1.87;

1.87
date	2000.03.29.01.41.56;	author mike;	state Exp;
branches;
next	1.86;

1.86
date	2000.03.28.18.05.13;	author mike;	state Exp;
branches;
next	1.85;

1.85
date	2000.03.03.01.01.15;	author mike;	state Exp;
branches;
next	1.84;

1.84
date	2000.03.02.03.47.19;	author mike;	state Exp;
branches;
next	1.83;

1.83
date	2000.03.02.02.44.10;	author mike;	state Exp;
branches;
next	1.82;

1.82
date	2000.02.18.17.48.20;	author bparker;	state Exp;
branches;
next	1.81;

1.81
date	2000.02.10.04.59.34;	author mike;	state Exp;
branches;
next	1.80;

1.80
date	2000.02.08.05.09.56;	author mike;	state Exp;
branches;
next	1.79;

1.79
date	2000.02.02.20.11.06;	author mike;	state Exp;
branches;
next	1.78;

1.78
date	2000.01.29.00.31.19;	author butler;	state Exp;
branches;
next	1.77;

1.77
date	2000.01.28.22.24.09;	author mike;	state Exp;
branches;
next	1.76;

1.76
date	2000.01.28.22.17.07;	author butler;	state Exp;
branches;
next	1.75;

1.75
date	2000.01.14.22.43.56;	author mike;	state Exp;
branches;
next	1.74;

1.74
date	2000.01.12.21.56.23;	author mike;	state Exp;
branches;
next	1.73;

1.73
date	2000.01.07.20.50.17;	author mike;	state Exp;
branches;
next	1.72;

1.72
date	99.12.22.04.55.28;	author mike;	state Exp;
branches;
next	1.71;

1.71
date	99.12.22.03.17.30;	author mike;	state Exp;
branches;
next	1.70;

1.70
date	99.12.07.04.30.45;	author mike;	state Exp;
branches;
next	1.69;

1.69
date	99.11.29.17.55.27;	author butler;	state Exp;
branches;
next	1.68;

1.68
date	99.11.08.14.45.22;	author jra;	state Exp;
branches;
next	1.67;

1.67
date	99.11.02.20.31.31;	author jra;	state Exp;
branches;
next	1.66;

1.66
date	99.10.30.03.06.23;	author butler;	state Exp;
branches;
next	1.65;

1.65
date	99.07.02.21.24.43;	author mike;	state Exp;
branches;
next	1.64;

1.64
date	99.06.03.02.17.53;	author mike;	state Exp;
branches;
next	1.63;

1.63
date	99.06.03.01.11.06;	author mike;	state Exp;
branches;
next	1.62;

1.62
date	99.01.22.21.55.10;	author butler;	state Exp;
branches;
next	1.61;

1.61
date	99.01.13.04.05.00;	author mike;	state Exp;
branches;
next	1.60;

1.60
date	99.01.12.22.05.29;	author mike;	state Exp;
branches;
next	1.59;

1.59
date	99.01.12.16.18.43;	author pjt;	state Exp;
branches;
next	1.58;

1.58
date	98.12.30.01.28.47;	author mike;	state Exp;
branches;
next	1.57;

1.57
date	98.12.11.20.40.07;	author mike;	state Exp;
branches;
next	1.56;

1.56
date	98.12.11.04.25.20;	author mike;	state Exp;
branches;
next	1.55;

1.55
date	98.11.19.06.19.47;	author mike;	state Exp;
branches;
next	1.54;

1.54
date	98.11.05.20.58.13;	author mike;	state Exp;
branches;
next	1.53;

1.53
date	98.09.23.19.38.20;	author jra;	state Exp;
branches;
next	1.52;

1.52
date	98.08.21.20.38.33;	author mike;	state Exp;
branches;
next	1.51;

1.51
date	98.06.05.15.38.26;	author pjt;	state Exp;
branches;
next	1.50;

1.50
date	98.06.04.20.30.42;	author pjt;	state Exp;
branches;
next	1.49;

1.49
date	98.05.29.20.06.15;	author jra;	state Exp;
branches;
next	1.48;

1.48
date	98.05.29.20.02.23;	author jra;	state Exp;
branches;
next	1.47;

1.47
date	98.05.28.19.57.05;	author pjt;	state Exp;
branches;
next	1.46;

1.46
date	98.04.15.04.50.54;	author mike;	state Exp;
branches;
next	1.45;

1.45
date	98.03.26.06.47.35;	author mike;	state Exp;
branches;
next	1.44;

1.44
date	98.03.24.13.40.26;	author pjt;	state Exp;
branches;
next	1.43;

1.43
date	98.03.10.21.25.28;	author pjt;	state Exp;
branches;
next	1.42;

1.42
date	98.01.23.20.08.27;	author jra;	state Exp;
branches;
next	1.41;

1.41
date	98.01.08.03.29.07;	author mike;	state Exp;
branches;
next	1.40;

1.40
date	97.12.19.15.52.06;	author pjt;	state Exp;
branches;
next	1.39;

1.39
date	97.12.18.21.20.11;	author pjt;	state Exp;
branches;
next	1.38;

1.38
date	97.12.16.00.46.58;	author mike;	state Exp;
branches;
next	1.37;

1.37
date	97.08.22.22.49.24;	author mike;	state Exp;
branches;
next	1.36;

1.36
date	97.07.01.23.35.58;	author mike;	state Exp;
branches;
next	1.35;

1.35
date	97.06.13.21.35.09;	author mike;	state Exp;
branches;
next	1.34;

1.34
date	97.05.21.01.08.22;	author butler;	state Exp;
branches;
next	1.33;

1.33
date	97.04.16.06.58.11;	author mike;	state Exp;
branches;
next	1.32;

1.32
date	97.04.04.05.00.04;	author mike;	state Exp;
branches;
next	1.31;

1.31
date	97.04.04.04.57.09;	author mike;	state Exp;
branches;
next	1.30;

1.30
date	97.04.01.20.12.42;	author butler;	state Exp;
branches;
next	1.29;

1.29
date	97.04.01.05.41.16;	author mike;	state Exp;
branches;
next	1.28;

1.28
date	97.03.06.08.38.39;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	97.01.29.00.38.12;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	97.01.08.03.54.47;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	97.01.07.23.40.14;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	96.10.08.16.43.07;	author pjt;	state Exp;
branches;
next	1.23;

1.23
date	96.09.27.06.17.23;	author butler;	state Exp;
branches;
next	1.22;

1.22
date	96.09.14.03.40.53;	author butler;	state Exp;
branches;
next	1.21;

1.21
date	96.08.31.08.50.03;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	96.08.31.08.42.31;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	96.08.31.08.21.05;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	96.08.31.08.02.51;	author butler;	state Exp;
branches;
next	1.17;

1.17
date	96.08.31.06.41.32;	author butler;	state Exp;
branches;
next	1.16;

1.16
date	96.08.31.06.08.42;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	96.08.31.06.04.58;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	96.08.31.05.58.09;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	96.08.31.05.12.56;	author butler;	state Exp;
branches;
next	1.12;

1.12
date	96.08.31.04.00.26;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	96.08.31.03.03.34;	author butler;	state Exp;
branches;
next	1.10;

1.10
date	96.08.31.02.59.35;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	96.08.30.00.13.55;	author butler;	state Exp;
branches;
next	1.8;

1.8
date	96.08.29.05.54.35;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	96.08.29.03.04.25;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	96.08.28.08.40.04;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	96.08.28.06.11.55;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	96.08.28.05.40.43;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	96.08.28.04.23.51;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	96.08.27.06.16.18;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	96.08.27.01.09.53;	author mike;	state Exp;
branches;
next	;

1.90.2.1
date	2000.11.03.19.16.57;	author bparker;	state Exp;
branches;
next	1.90.2.2;

1.90.2.2
date	2001.02.22.00.09.16;	author butler;	state Exp;
branches;
next	;

1.136.2.1
date	2002.09.19.18.00.56;	author morrison;	state Exp;
branches;
next	1.136.2.2;

1.136.2.2
date	2004.03.17.21.16.10;	author morrison;	state Exp;
branches;
next	1.136.2.3;

1.136.2.3
date	2004.04.02.15.59.14;	author morrison;	state Exp;
branches;
next	1.136.2.4;

1.136.2.4
date	2004.04.04.20.46.09;	author morrison;	state Exp;
branches;
next	1.136.2.5;

1.136.2.5
date	2004.04.05.00.49.53;	author morrison;	state Exp;
branches;
next	;

1.136.4.1
date	2004.03.11.23.40.46;	author morrison;	state Exp;
branches;
next	;

1.139.6.1
date	2003.12.17.15.35.29;	author erikg;	state Exp;
branches;
next	1.139.6.2;

1.139.6.2
date	2004.01.08.14.24.50;	author erikg;	state Exp;
branches;
next	1.139.6.3;

1.139.6.3
date	2004.02.12.18.32.35;	author erikg;	state Exp;
branches;
next	1.139.6.4;

1.139.6.4
date	2004.03.10.13.24.59;	author erikg;	state Exp;
branches;
next	1.139.6.5;

1.139.6.5
date	2004.03.15.14.06.10;	author erikg;	state Exp;
branches;
next	1.139.6.6;

1.139.6.6
date	2004.03.16.13.00.07;	author erikg;	state Exp;
branches;
next	;


desc
@Header file for BRL-CAD Utility Library
@


1.145
log
@moved/renamed from top-level h/ to top-level include/
@
text
@/*
 *				B U . H
 *
 *  Header file for the BRL-CAD Utility Library, LIBBU.
 *
 *  This library provides several layers of low-level utility routines,
 *  providing features that make coding much easier.
 *	Parallel processing support:  threads, sempahores, parallel-malloc.
 *	Consolodated logging support:  bu_log(), bu_bomb().
 *
 *  The intention is that these routines are general extensions to
 *  the data types offered by the C language itself, and to the
 *  basic C runtime support provided by the system LIBC.
 *
 *  All of the data types provided by this library are defined in bu.h;
 *  none of the routines in this library will depend on data types defined
 *  in other BRL-CAD header files, such as vmath.h.
 *  Look for those routines in LIBBN.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
 *
 *  Include Sequencing -
 *	#include "conf.h"
 *	#include <stdio.h>
 *	#include "machine.h"	/_* For fastf_t definition on this machine *_/
 *	#include "rtlist.h"	/_* OPTIONAL, auto-included by bu.h *_/
 *	#include "bu.h"
 *
 *  Libraries Used -
 *	-lm -lc
 *
 *  $Header: /n/xoff/cvs/brlcad/h/bu.h,v 1.144 2004/05/10 15:30:42 erikg Exp $
 */

#ifndef SEEN_BU_H
#define SEEN_BU_H seen

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

/* Included for Tcl_Interp definition */
#include "tcl.h"

#ifdef __cplusplus
extern "C" {
#endif

#include <setjmp.h>

#define BU_H_VERSION	"@@(#)$Header: /n/xoff/cvs/brlcad/h/bu.h,v 1.144 2004/05/10 15:30:42 erikg Exp $ (BRL)"

#ifdef HAVE_TIME_H
# include <time.h>
#endif

#ifdef HAVE_SYS_TIME_H
# include <sys/time.h>
#endif

/*----------------------------------------------------------------------*/
/*
 *  System library routines used by LIBBS.
 *  If header files are to be included, this should happen first,
 *  to prevent accidentally redefining important stuff.
 */
#if HAVE_STDLIB_H
/*	NOTE:  Nested includes, gets malloc(), offsetof(), etc */
#	include <stdlib.h>
#	include <stddef.h>
#else
extern char	*malloc();
extern char	*calloc();
extern char	*realloc();
/**extern void	free(); **/
#endif

/* 
 * BU_FLSTR   Macro for getting a concatenated string of the current 
 * file and line number.  Produces something of the form:
 *   "filename.c"":""1234"
 */
#define bu_cpp_str(s) # s
#define bu_cpp_xstr(s)  bu_cpp_str(s)
#define bu_cpp_glue(a, b) a ## b
#define bu_cpp_xglue(a, b) bu_cpp_glue(a, b)
#define BU_FLSTR __FILE__ ":" bu_cpp_xstr(__LINE__)
#define BU_QFLSTR bu_cpp_xstr(__FILE__ line __LINE__)

/*
 *  Macros for providing function prototypes, regardless of whether
 *  the compiler understands them or not.
 *  It is vital that the argument list given for "args" be enclosed
 *  in parens.
 *  The setting of USE_PROTOTYPES is done in machine.h
 */
#if USE_PROTOTYPES
#	define	BU_EXTERN(type_and_name,args)	extern type_and_name args
#	define	BU_ARGS(args)			args
#else
#	define	BU_EXTERN(type_and_name,args)	extern type_and_name()
#	define	BU_ARGS(args)			()
#endif

/*
 *			B U _ F O R T R A N
 *
 *  This macro is used to take the 'C' function name,
 *  and convert it at compile time to the
 *  FORTRAN calling convention used for this particular system.
 *
 *  Both lower-case and upper-case alternatives have to be provided
 *  because there is no way to get the C preprocessor to change the
 *  case of a token.
 */
#if defined(CRAY)
#	define	BU_FORTRAN(lc,uc)	uc
#endif
#if defined(apollo) || defined(mips) || defined(aux)
	/* Lower case, with a trailing underscore */
#ifdef __STDC__
#	define	BU_FORTRAN(lc,uc)	lc ## _
#else
#	define	BU_FORTRAN(lc,uc)	lc/**/_
#endif
#endif
#if !defined(BU_FORTRAN)
#	define	BU_FORTRAN(lc,uc)	lc
#endif

/*
 * Handy memory allocator macro
 */

/* Acquire storage for a given struct, eg, BU_GETSTRUCT(ptr,structname); */
#if __STDC__
#  define BU_GETSTRUCT(_p,_str) \
	_p = (struct _str *)bu_calloc(1,sizeof(struct _str), #_str " (getstruct)" )
#  define BU_GETUNION(_p,_unn) \
	_p = (union _unn *)bu_calloc(1,sizeof(union _unn), #_unn " (getunion)")
#else
#  define BU_GETSTRUCT(_p,_str) \
	_p = (struct _str *)bu_calloc(1,sizeof(struct _str), "_str (getstruct)")
#  define BU_GETUNION(_p,_unn) \
	_p = (union _unn *)bu_calloc(1,sizeof(union _unn), "_unn (getunion)")
#endif

/*
 *                B U _ G E T T Y P E
 *
 * Acquire storage for a given TYPE, eg, BU_GETTYPE(ptr, typename);
 * Equivalent to BU_GETSTRUCT, except without the 'struct' Useful
 * for typedef'ed objects.
 */
#if __STDC__
#  define BU_GETTYPE(_p,_type) \
	_p = (_type *)bu_calloc(1,sizeof(_type), #_type " (gettype)" )
#else
#  define BU_GETTYPE(_p,_type) \
	_p = (_type *)bu_calloc(1,sizeof(_type), "_type (getstruct)")
#endif



/*
 *			B U _ C K M A G
 *
 *  Macros to check and validate a structure pointer, given that
 *  the first entry in the structure is a magic number.
 */
#ifdef NO_BOMBING_MACROS
#  define BU_CKMAG(_ptr, _magic, _str)
#  define BU_CKMAG_TCL(_interp, _ptr, _magic, _str)
#else
#  define BU_CKMAG(_ptr, _magic, _str)	\
	if( !(_ptr) || ( ((long)(_ptr)) & (sizeof(long)-1) ) || \
	    *((unsigned long *)(_ptr)) != (unsigned long)(_magic) )  { \
		bu_badmagic( (long *)(_ptr), (unsigned long)_magic, _str, __FILE__, __LINE__ ); \
	}
#  define BU_CKMAG_TCL(_interp, _ptr, _magic, _str)	\
	if( !(_ptr) || ( ((long)(_ptr)) & (sizeof(long)-1) ) || \
	     *((long *)(_ptr)) != (_magic) )  { \
		bu_badmagic_tcl( (_interp), (long *)(_ptr), (unsigned long)_magic, _str, __FILE__, __LINE__ ); \
		return TCL_ERROR; \
	}
#endif

/*
 *			B U _ A S S E R T
 *
 *  Quick and easy macros to generate an informative error message and
 *  abort execution if the specified condition does not hold true.
 *
 *  Example:		BU_ASSERT_LONG( j+7, <, 42 );
 */
#ifdef NO_BOMBING_MACROS
#  define BU_ASSERT(_equation)
#else
#  ifdef __STDC__
#    define BU_ASSERT(_equation)	\
	if( !(_equation) )  { \
		bu_log("BU_ASSERT( " #_equation " ) failed, file %s, line %d\n", \
			__FILE__, __LINE__ ); \
		bu_bomb("assertion failure\n"); \
	}
#  else
#    define BU_ASSERT(_equation)	\
	if( !(_equation) )  { \
		bu_log("BU_ASSERT( _equation ) failed, file %s, line %d\n", \
			__FILE__, __LINE__ ); \
		bu_bomb("assertion failure\n"); \
	}
#  endif
#endif

#ifdef NO_BOMBING_MACROS
#  define BU_ASSERT_PTR(_lhs,_relation,_rhs)
#else
#  ifdef __STDC__
#    define BU_ASSERT_PTR(_lhs,_relation,_rhs)	\
	if( !((_lhs) _relation (_rhs)) )  { \
		bu_log("BU_ASSERT_PTR( " #_lhs #_relation #_rhs " ) failed, lhs=x%lx, rhs=x%lx, file %s, line %d\n", \
			(long)(_lhs), (long)(_rhs),\
			__FILE__, __LINE__ ); \
		bu_bomb("BU_ASSERT_PTR failure\n"); \
	}
#  else
#    define BU_ASSERT_PTR(_lhs,_relation,_rhs)	\
	if( !((_lhs) _relation (_rhs)) )  { \
		bu_log("BU_ASSERT_PTR( _lhs _relation _rhs ) failed, lhs=x%lx, rhs=x%lx, file %s, line %d\n", \
			(long)(_lhs), (long)(_rhs),\
			__FILE__, __LINE__ ); \
		bu_bomb("BU_ASSERT_PTR failure\n"); \
	}
#  endif
#endif


#ifdef NO_BOMBING_MACROS
#  define BU_ASSERT_LONG(_lhs,_relation,_rhs)
#else
#  ifdef __STDC__
#    define BU_ASSERT_LONG(_lhs,_relation,_rhs)	\
	if( !((_lhs) _relation (_rhs)) )  { \
		bu_log("BU_ASSERT_LONG( " #_lhs #_relation #_rhs " ) failed, lhs=%ld, rhs=%ld, file %s, line %d\n", \
			(long)(_lhs), (long)(_rhs),\
			__FILE__, __LINE__ ); \
		bu_bomb("BU_ASSERT_LONG failure\n"); \
	}
#  else
#    define BU_ASSERT_LONG(_lhs,_relation,_rhs)	\
	if( !((_lhs) _relation (_rhs)) )  { \
		bu_log("BU_ASSERT_LONG( _lhs _relation _rhs ) failed, lhs=%ld, rhs=%ld, file %s, line %d\n", \
			(long)(_lhs), (long)(_rhs),\
			__FILE__, __LINE__ ); \
		bu_bomb("BU_ASSERT_LONG failure\n"); \
	}
#  endif
#endif


#ifdef NO_BOMBING_MACROS
#  define BU_ASSERT_DOUBLE(_lhs,_relation,_rhs)
#else
#  ifdef __STDC__
#    define BU_ASSERT_DOUBLE(_lhs,_relation,_rhs)	\
	if( !((_lhs) _relation (_rhs)) )  { \
		bu_log("BU_ASSERT_DOUBLE( " #_lhs #_relation #_rhs " ) failed, lhs=%lf, rhs=%lf, file %s, line %d\n", \
			(double)(_lhs), (double)(_rhs),\
			__FILE__, __LINE__ ); \
		bu_bomb("BU_ASSERT_DOUBLE failure\n"); \
	}
#  else
#    define BU_ASSERT_DOUBLE(_lhs,_relation,_rhs)	\
	if( !((_lhs) _relation (_rhs)) )  { \
		bu_log("BU_ASSERT_DOUBLE( _lhs _relation _rhs ) failed, lhs=%lf, rhs=%lf, file %s, line %d\n", \
			(long)(_lhs), (long)(_rhs),\
			__FILE__, __LINE__ ); \
		bu_bomb("BU_ASSERT_DOUBLE failure\n"); \
	}
#  endif
#endif

/*----------------------------------------------------------------------*/
/*
 *  Sizes of "network" format data.
 *  We use the same convention as the TCP/IP specification,
 *  namely, big-Endian, IEEE format, twos compliment.
 *  This is the BRL-CAD external data representation (XDR).
 *  See also the support routines in libbu/xdr.c
 */
#define SIZEOF_NETWORK_SHORT	2	/* htons(), bu_gshort(), bu_pshort() */
#define SIZEOF_NETWORK_LONG	4	/* htonl(), bu_glong(), bu_plong() */
#define SIZEOF_NETWORK_FLOAT	4	/* htonf() */
#define SIZEOF_NETWORK_DOUBLE	8	/* htond() */

/*----------------------------------------------------------------------*/
/* convert.c
 *
 *
 */
/*
 * Forward declarations.
 */
extern int bu_cv_itemlen(int cookie);
extern int bu_cv_cookie(char *in);
extern int bu_cv_optimize(int cookie);
extern int bu_cv_w_cookie(genptr_t, int, size_t, genptr_t, int, int);

extern int bu_cv_ntohss(signed short *, size_t, genptr_t, int);
extern int bu_cv_ntohus(unsigned short *, size_t, genptr_t, int);
extern int bu_cv_ntohsl(signed long int *, size_t, genptr_t, int);
extern int bu_cv_ntohul(unsigned long int *, size_t, genptr_t, int);
extern int bu_cv_htonss(genptr_t, size_t, signed short *, int);
extern int bu_cv_htonus(genptr_t, size_t, unsigned short *, int);
extern int bu_cv_htonsl(genptr_t, size_t, long *, int);
extern int bu_cv_htonul(genptr_t, size_t, unsigned long *, int);

/*
 * Theses should be moved to a header file soon.
 */
#define CV_CHANNEL_MASK	0x00ff
#define CV_HOST_MASK	0x0100
#define CV_SIGNED_MASK	0x0200
#define CV_TYPE_MASK	0x1c00  /* 0001 1100 0000 0000 */
#define CV_CONVERT_MASK 0x6000  /* 0110 0000 0000 0000 */

#define CV_TYPE_SHIFT	10
#define CV_CONVERT_SHIFT 13

#define CV_8	0x0400
#define	CV_16	0x0800
#define CV_32	0x0c00
#define CV_64	0x1000
#define CV_D	0x1400

#define CV_CLIP		0x0000
#define CV_NORMAL	0x2000
#define CV_LIT		0x4000

#define	IND_NOTSET	0
#define IND_BIG		1
#define IND_LITTLE	2
#define IND_ILL		3		/* PDP-11 */
#define IND_CRAY	4

/*----------------------------------------------------------------------*/
/* list.c */
/*
 *									*
 *			     B U _ L I S T				*
 *									*
 *			Doubly-linked list support			*
 *									*
 *  These macros assume that all user-provided structures will have	*
 *  a "struct bu_list" as their first element (often named "l" [ell]).	*
 *  Thus, a pointer to the bu_list struct is a "pun" for the		*
 *  user-provided structure as well, and the pointers can be converted	*
 *  back and forth safely with type casts.				*
 *									*
 *  Furthermore, the head of the linked list could be			*
 *  a full instance of the user-provided structure			*
 *  (although the storage-conscious programmer could make the head	*
 *  just an bu_list structure, with careful type casting).		*
 *  This results in a doubly-linked circular list, with the head	*
 *  having the same shape as all the list members.			*
 *  The application is free to make use of this symmetry and store	*
 *  data values in the head, or the extra storage in the head can	*
 *  be ignored.								*
 *									*
 *  Where a macro expects an argument "p", it should be a pointer to	*
 *  a user-provided structure.						*
 *									*
 *  Where a macro expects an argument "hp", it should be a pointer to	*
 *  a "struct bu_list" located in the list head, e.g., &(head.l).	*
 *									*
 *  Where a macro expects an argument "old", "new", or "cur", it should	*
 *  be a pointer to the "struct bu_list" located either			*
 *  in a user-provided structure, e.g. &((p)->l),			*
 *  or for the case of "old" it may also be in the list head, e.g.	*
 *	BU_LIST_INSERT( &(head.l), &((p)->l) );				*
 *									*
 *  Dequeueing the head of a list is a valid and			*
 *  well defined operation which should be performed with caution.	*
 *  Unless a pointer to some other element of the list is retained	*
 *  by the application, the rest of the linked list can no longer be	*
 *  referred to.							*
 *									*
 *  The "magic" field of the list header _must_ be set to the constant	*
 *  BU_LIST_HEAD_MAGIC, but the "magic" field of all list members	*
 *  should be established by user code, to identify the type of		*
 *  structure that the bu_list structure is embedded in.		*
 *  It is permissible for one list to contain an arbitrarily mixed	*
 *  set of user "magic" numbers, as long as the head is properly marked.*
 *									*
 *  There is a dual set of terminology used in some of the macros:	*
 *	FIRST / LAST	from the point of view of the list head		*
 *	NEXT / PREV	from the point of view of a list member		*
 *	forw / back	the actual pointer names			*
 *									*
 ************************************************************************/

struct bu_list {
	long		magic;
	struct bu_list	*forw;		/* "forward", "next" */
	struct bu_list	*back;		/* "back", "last" */
};
#define BU_LIST_HEAD_MAGIC	0x01016580	/* Magic num for list head */
#define BU_LIST_NULL	((struct bu_list *)0)

typedef struct bu_list bu_list_t;

struct bu_list *bu_list_new(void);
struct bu_list *bu_list_pop( struct bu_list *hp );

#define BU_LIST_CLOSE( hp ) { \
	assert( (hp) != NULL ); \
	if( (hp) == NULL ) \
		return; \
	assert( BU_LIST_IS_EMPTY( (hp) ) ); \
	bu_list_free( (hp) ); \
	bu_free( (char *)(hp), "bu_list head" ); \
}


/*
 *  Insert "new" item in front of "old" item.  Often, "old" is the head.
 *  To put the new item at the tail of the list, insert before the head, e.g.
 *	BU_LIST_INSERT( &(head.l), &((p)->l) );
 */
#define BU_LIST_INSERT(old,new)	{ \
	(new)->back = (old)->back; \
	(old)->back = (new); \
	(new)->forw = (old); \
	(new)->back->forw = (new);  }

/*
 *  Append "new" item after "old" item.  Often, "old" is the head.
 *  To put the new item at the head of the list, append after the head, e.g.
 *	BU_LIST_APPEND( &(head.l), &((p)->l) );
 */
#define BU_LIST_APPEND(old,new)	{ \
	(new)->forw = (old)->forw; \
	(new)->back = (old); \
	(old)->forw = (new); \
	(new)->forw->back = (new);  }

/* Dequeue "cur" item from anywhere in doubly-linked list */
#define BU_LIST_DEQUEUE(cur)	{ \
	(cur)->forw->back = (cur)->back; \
	(cur)->back->forw = (cur)->forw; \
	(cur)->forw = (cur)->back = BU_LIST_NULL;  /* sanity */ }

/* Dequeue "cur" but do not fix its links */
#define BU_LIST_DQ(cur) {\
	(cur)->forw->back = (cur)->back; \
	(cur)->back->forw = (cur)->forw; }

#define BU_LIST_DQ_T(cur, type) (\
	(cur)->forw->back = (cur)->back, \
	(cur)->back->forw = (cur)->forw, \
	(type *)(cur) )

/* This version of BU_LIST_DEQUEUE uses the comma operator
 * inorder to return a typecast version of the dequeued pointer
 */
#define BU_LIST_DEQUEUE_T( cur, type ) (\
	(cur)->forw->back = (cur)->back, \
	(cur)->back->forw = (cur)->forw, \
	(cur)->forw = (cur)->back = BU_LIST_NULL, \
	(type *)(cur) )


/*
 *  The Stack Discipline
 *
 *  BU_LIST_PUSH places p at the tail of hp.
 *  BU_LIST_POP  sets p to last element in hp's list (else NULL)
 *		  and, if p is non-null, dequeues it.
 */
#define BU_LIST_PUSH(hp,p)					\
	BU_LIST_APPEND(hp, (struct bu_list *)(p))

#define BU_LIST_POP(structure,hp,p)				\
	{							\
		if (BU_LIST_NON_EMPTY(hp))				\
		{							\
		    (p) = ((struct structure *)((hp)->forw));		\
		    BU_LIST_DEQUEUE((struct bu_list *)(p));		\
		}							\
		else							\
		     (p) = (struct structure *) 0;			\
	}

#define BU_LIST_POP_T(hp, type )				\
	(type *)bu_list_pop( hp )

/*
 *  "Bulk transfer" all elements from the list headed by src_hd
 *  onto the list headed by dest_hd, without examining every element
 *  in the list.  src_hd is left with a valid but empty list.
 *  
 *  BU_LIST_INSERT_LIST places src_hd elements at head of dest_hd list,
 *  BU_LIST_APPEND_LIST places src_hd elements at end of dest_hd list.
 */
#define BU_LIST_INSERT_LIST(dest_hp,src_hp) \
	if( BU_LIST_NON_EMPTY(src_hp) )  { \
		register struct bu_list	*_first = (src_hp)->forw; \
		register struct bu_list	*_last = (src_hp)->back; \
		(dest_hp)->forw->back = _last; \
		_last->forw = (dest_hp)->forw; \
		(dest_hp)->forw = _first; \
		_first->back = (dest_hp); \
		(src_hp)->forw = (src_hp)->back = (src_hp); \
	}

#define BU_LIST_APPEND_LIST(dest_hp,src_hp) \
	if( BU_LIST_NON_EMPTY(src_hp) )  {\
		register struct bu_list	*_first = (src_hp)->forw; \
		register struct bu_list	*_last = (src_hp)->back; \
		_first->back = (dest_hp)->back; \
		(dest_hp)->back->forw = _first; \
		(dest_hp)->back = _last; \
		_last->forw = (dest_hp); \
		(src_hp)->forw = (src_hp)->back = (src_hp); \
	}

/* Test if a doubly linked list is empty, given head pointer */
#define BU_LIST_IS_EMPTY(hp)	((hp)->forw == (hp))
#define BU_LIST_NON_EMPTY(hp)	((hp)->forw != (hp))
#define BU_LIST_NON_EMPTY_P(p,structure,hp)	\
	(((p)=(struct structure *)((hp)->forw)) != (struct structure *)(hp))
#define BU_LIST_IS_CLEAR(hp)	((hp)->magic == 0 && \
			(hp)->forw == BU_LIST_NULL && \
			(hp)->back == BU_LIST_NULL)

/* Handle list initialization */
#define	BU_LIST_UNINITIALIZED(hp)	((hp)->forw == BU_LIST_NULL)
#define	BU_LIST_IS_INITIALIZED(hp)	((hp)->forw != BU_LIST_NULL)
#define BU_LIST_INIT(hp)	{ \
	(hp)->forw = (hp)->back = (hp); \
	(hp)->magic = BU_LIST_HEAD_MAGIC;	/* used by circ. macros */ }
#define BU_LIST_MAGIC_SET(hp,val)	{(hp)->magic = (val);}
#define BU_LIST_MAGIC_OK(hp,val)	((hp)->magic == (val))
#define BU_LIST_MAGIC_WRONG(hp,val)	((hp)->magic != (val))

/* Return re-cast pointer to first element on list.
 * No checking is performed to see if list is empty.
 */
#define BU_LIST_LAST(structure,hp)	\
	((struct structure *)((hp)->back))
#define BU_LIST_BACK(structure,hp)	\
	((struct structure *)((hp)->back))
#define BU_LIST_PREV(structure,hp)	\
	((struct structure *)((hp)->back))
#define BU_LIST_FIRST(structure,hp)	\
	((struct structure *)((hp)->forw))
#define BU_LIST_FORW(structure,hp)	\
	((struct structure *)((hp)->forw))
#define BU_LIST_NEXT(structure,hp)	\
	((struct structure *)((hp)->forw))

/* Boolean test to see if current list element is the head */
#define BU_LIST_IS_HEAD(p,hp)	\
	(((struct bu_list *)(p)) == (hp))
#define BU_LIST_NOT_HEAD(p,hp)	\
	(((struct bu_list *)(p)) != (hp))
#define BU_CK_LIST_HEAD( _p )	BU_CKMAG( (_p), BU_LIST_HEAD_MAGIC, "bu_list")

/* Boolean test to see if previous list element is the head */
#define BU_LIST_PREV_IS_HEAD(p,hp)\
	(((struct bu_list *)(p))->back == (hp))
#define BU_LIST_PREV_NOT_HEAD(p,hp)\
	(((struct bu_list *)(p))->back != (hp))

/* Boolean test to see if the next list element is the head */
#define BU_LIST_NEXT_IS_HEAD(p,hp)	\
	(((struct bu_list *)(p))->forw == (hp))
#define BU_LIST_NEXT_NOT_HEAD(p,hp)	\
	(((struct bu_list *)(p))->forw != (hp))

#define BU_LIST_EACH( hp, p, type ) \
	 for( (p)=(type *)BU_LIST_FIRST(bu_list,hp); \
	      BU_LIST_NOT_HEAD(p,hp); \
	      (p)=(type *)BU_LIST_PNEXT(bu_list,p) ) \

#define BU_LIST_REVEACH( hp, p, type ) \
	 for( (p)=(type *)BU_LIST_LAST(bu_list,hp); \
	      BU_LIST_NOT_HEAD(p,hp); \
	      (p)=(type *)BU_LIST_PREV(bu_list,((struct bu_list *)(p))) ) \

#define BU_LIST_TAIL( hp, start, p, type ) \
	 for( (p)=(type *)start ; \
	      BU_LIST_NOT_HEAD(p,hp); \
	      (p)=(type *)BU_LIST_PNEXT(bu_list,(p)) )

/*
 *  Intended as innards for a for() loop to visit all nodes on list, e.g.:
 *	for( BU_LIST_FOR( p, structure, hp ) )  {
 *		work_on( p );
 *	}
 */
#define BU_LIST_FOR(p,structure,hp)	\
	(p)=BU_LIST_FIRST(structure,hp); \
	BU_LIST_NOT_HEAD(p,hp); \
	(p)=BU_LIST_PNEXT(structure,p)

#define BU_LIST_FOR_BACKWARDS(p,structure,hp)	\
	(p)=BU_LIST_LAST(structure,hp); \
	BU_LIST_NOT_HEAD(p,hp); \
	(p)=BU_LIST_PLAST(structure,p)

/*
 *  Process all the list members except hp and the actual head.
 *  Useful when starting somewhere besides the head.
 */
#define BU_LIST_FOR_CIRC(p,structure,hp)	\
	(p)=BU_LIST_PNEXT_CIRC(structure,hp); \
	(p) != (hp); \
	(p)=BU_LIST_PNEXT_CIRC(structure,p)

/*
 *  Intended as innards for a for() loop to visit elements of two lists
 *	in tandem, e.g.:
 *	    for (BU_LIST_FOR2(p1, p2, structure, hp1, hp2) ) {
 *		    process( p1, p2 );
 *	    }
 */
#define	BU_LIST_FOR2(p1,p2,structure,hp1,hp2)				\
		(p1)=BU_LIST_FIRST(structure,hp1),			\
		(p2)=BU_LIST_FIRST(structure,hp2);			\
		BU_LIST_NOT_HEAD((struct bu_list *)(p1),(hp1)) &&	\
		BU_LIST_NOT_HEAD((struct bu_list *)(p2),(hp2));		\
		(p1)=BU_LIST_NEXT(structure,(struct bu_list *)(p1)),	\
		(p2)=BU_LIST_NEXT(structure,(struct bu_list *)(p2))

/*
 *  Innards for a while() loop that constantly picks off the first element.
 *  Useful mostly for a loop that will dequeue every list element, e.g.:
 *	while( BU_LIST_WHILE(p, structure, hp) )  {
 *		BU_LIST_DEQUEUE( &(p->l) );
 *		free( (char *)p );
 *	}
 */
#define BU_LIST_WHILE(p,structure,hp)	\
	(((p)=(struct structure *)((hp)->forw)) != (struct structure *)(hp))

/* Return the magic number of the first (or last) item on a list */
#define BU_LIST_FIRST_MAGIC(hp)		((hp)->forw->magic)
#define BU_LIST_LAST_MAGIC(hp)		((hp)->back->magic)

/* Return pointer to next (or previous) element, which may be the head */
#define BU_LIST_PNEXT(structure,p)	\
	((struct structure *)(((struct bu_list *)(p))->forw))
#define BU_LIST_PLAST(structure,p)	\
	((struct structure *)(((struct bu_list *)(p))->back))

/* Return pointer two links away, which may include the head */
#define BU_LIST_PNEXT_PNEXT(structure,p)	\
	((struct structure *)(((struct bu_list *)(p))->forw->forw))
#define BU_LIST_PNEXT_PLAST(structure,p)	\
	((struct structure *)(((struct bu_list *)(p))->forw->back))
#define BU_LIST_PLAST_PNEXT(structure,p)	\
	((struct structure *)(((struct bu_list *)(p))->back->forw))
#define BU_LIST_PLAST_PLAST(structure,p)	\
	((struct structure *)(((struct bu_list *)(p))->back->back))

/* Return pointer to circular next element; ie, ignoring the list head */
#define BU_LIST_PNEXT_CIRC(structure,p)	\
	((BU_LIST_FIRST_MAGIC((struct bu_list *)(p)) == BU_LIST_HEAD_MAGIC) ? \
		BU_LIST_PNEXT_PNEXT(structure,(struct bu_list *)(p)) : \
		BU_LIST_PNEXT(structure,p) )

/* Return pointer to circular last element; ie, ignoring the list head */
#define BU_LIST_PPREV_CIRC(structure,p)	\
	((BU_LIST_LAST_MAGIC((struct bu_list *)(p)) == BU_LIST_HEAD_MAGIC) ? \
		BU_LIST_PLAST_PLAST(structure,(struct bu_list *)(p)) : \
		BU_LIST_PLAST(structure,p) )

/*
 *  Support for membership on multiple linked lists.
 *
 *  When a structure of type '_type' contains more than one bu_list structure
 *  within it (such as the NMG edgeuse), this macro can be used to convert
 *  a pointer '_ptr2' to a "midway" bu_list structure (an element called
 *  '_name2' in structure '_type') back into a pointer to the overall
 *  enclosing structure.  Examples:
 *
 *  eu = BU_LIST_MAIN_PTR( edgeuse, midway, l2 );
 *
 *  eu1 = BU_LIST_MAIN_PTR(edgeuse, BU_LIST_FIRST(bu_list, &eg1->eu_hd2), l2);
 */  
#define BU_LIST_MAIN_PTR(_type, _ptr2, _name2)	\
	((struct _type *)(((char *)(_ptr2)) - offsetof(struct _type, _name2.magic)))

/*----------------------------------------------------------------------*/
/* bitv.c */
/*
 *			B U _ B I T V
 *
 *  Bit vector data structure.
 *
 *  bu_bitv uses a little-endian encoding, placing bit 0 on the
 *  right side of the 0th word.
 *  This is done only because left-shifting a 1 can be done in an
 *  efficient word-length-independent manner;
 *  going the other way would require a compile-time constant with
 *  only the sign bit set, and an unsigned right shift, which some
 *  machines don't have in hardware, or an extra subtraction.
 *
 *  Application code should *never* peak at the bit-buffer; use the macros.
 *
 *  The external hex form is most signigicant byte first (bit 0 is at the right).
 *  Note that MUVES does it differently
 */
struct bu_bitv {
	struct bu_list	l;		/* linked list for caller's use */
	unsigned int	nbits;		/* actual size of bits[], in bits */
	bitv_t		bits[2];	/* variable size array */
};

#define BU_BITV_MAGIC		0x62697476	/* 'bitv' */
#define BU_CK_BITV(_vp)		BU_CKMAG(_vp, BU_BITV_MAGIC, "bu_bitv")

/*
 *  Bit-string manipulators for arbitrarily long bit strings
 *  stored as an array of bitv_t's.
 */
#define BU_BITS2BYTES(_nb)	(BU_BITS2WORDS(_nb)*sizeof(bitv_t))
#define BU_BITS2WORDS(_nb)	(((_nb)+BITV_MASK)>>BITV_SHIFT)
#define BU_WORDS2BITS(_nw)	((_nw)*sizeof(bitv_t)*8)

#if 1
#define BU_BITTEST(_bv,bit)	\
	(((_bv)->bits[(bit)>>BITV_SHIFT] & (((bitv_t)1)<<((bit)&BITV_MASK)))!=0)
#else
static __inline__ int BU_BITTEST(volatile void * addr, int nr)
{
        int oldbit;

        __asm__ __volatile__(
                "btl %2,%1\n\tsbbl %0,%0"
                :"=r" (oldbit)
                :"m" (addr),"Ir" (nr));
        return oldbit;
}
#endif

#define BU_BITSET(_bv,bit)	\
	((_bv)->bits[(bit)>>BITV_SHIFT] |= (((bitv_t)1)<<((bit)&BITV_MASK)))
#define BU_BITCLR(_bv,bit)	\
	((_bv)->bits[(bit)>>BITV_SHIFT] &= ~(((bitv_t)1)<<((bit)&BITV_MASK)))
#define BU_BITV_ZEROALL(_bv)	\
	{ memset( (char *)((_bv)->bits), 0, BU_BITS2BYTES( (_bv)->nbits ) ); }

/* This is not done by default for performance reasons */
#ifdef NO_BOMBING_MACROS
#  define BU_BITV_BITNUM_CHECK(_bv,_bit)
#else
#  define BU_BITV_BITNUM_CHECK(_bv,_bit)	/* Validate bit number */ \
	if( ((unsigned)(_bit)) >= (_bv)->nbits )  {\
		bu_log("BU_BITV_BITNUM_CHECK bit number (%u) out of range (0..%u)\n", \
			((unsigned)(_bit)), (_bv)->nbits); \
		bu_bomb("process self-terminating\n");\
	}
#endif

#ifdef NO_BOMBING_MACROS
#  define BU_BITV_NBITS_CHECK(_bv,_nbits)
#else
#  define BU_BITV_NBITS_CHECK(_bv,_nbits)	/* Validate number of bits */ \
	if( ((unsigned)(_nbits)) > (_bv)->nbits )  {\
		bu_log("BU_BITV_NBITS_CHECK number of bits (%u) out of range (> %u)", \
			((unsigned)(_nbits)), (_bv)->nbits ); \
		bu_bomb("process self-terminating"); \
		}
#endif


/*
 *  Macros to efficiently find all the ONE bits in a bit vector.
 *  Counts words down, counts bits in words going up, for speed & portability.
 *  It does not matter if the shift causes the sign bit to smear to the right.
 *
 *  Example:
 *	BU_BITV_LOOP_START(bv)  {
 *		fiddle(BU_BITV_LOOP_INDEX);
 *	} BU_BITV_LOOP_END;
 */
#define BU_BITV_LOOP_START(_bv)	\
{ \
	register int		_wd;	/* Current word number */  \
	BU_CK_BITV(_bv); \
	for( _wd=BU_BITS2WORDS((_bv)->nbits)-1; _wd>=0; _wd-- )  {  \
		register int	_b;	/* Current bit-in-word number */  \
		register bitv_t	_val;	/* Current word value */  \
		if((_val = (_bv)->bits[_wd])==0) continue;  \
		for(_b=0; _b < BITV_MASK+1; _b++, _val >>= 1 ) { \
			if( !(_val & 1) )  continue;

/*
 *  This macro is valid only between a BU_BITV_LOOP_START/LOOP_END pair,
 *  and gives the bit number of the current iteration.
 */
#define BU_BITV_LOOP_INDEX	((_wd << BITV_SHIFT) | _b)

#define BU_BITV_LOOP_END	\
		} /* end for(_b) */ \
	} /* end for(_wd) */ \
} /* end block */

/*----------------------------------------------------------------------*/
/* hist.c */

/*
 *			B U _ H I S T
 */
struct bu_hist  {
	long		magic;
	fastf_t		hg_min;		/* minimum value */
	fastf_t		hg_max;		/* maximum value */
	fastf_t		hg_clumpsize;	/* (max-min+1)/nbins+1 */
	long		hg_nsamples;	/* total number of samples spread into histogram */
	long		hg_nbins;	/* # of bins in hg_bins[] */
	long		*hg_bins;	/* array of counters */
};
#define BU_HIST_MAGIC	0x48697374	/* Hist */
#define BU_CK_HIST(_p)	BU_CKMAG(_p, BU_HIST_MAGIC, "struct bu_hist")

#define BU_HIST_TALLY( _hp, _val )	{ \
	if( (_val) <= (_hp)->hg_min )  { \
		(_hp)->hg_bins[0]++; \
	} else if( (_val) >= (_hp)->hg_max )  { \
		(_hp)->hg_bins[(_hp)->hg_nbins]++; \
	} else { \
		(_hp)->hg_bins[(int)(((_val)-(_hp)->hg_min)/(_hp)->hg_clumpsize)]++; \
	} \
	(_hp)->hg_nsamples++;  }

#define BU_HIST_TALLY_MULTIPLE( _hp, _val, _count )	{ \
	register int	__count = (_count); \
	if( (_val) <= (_hp)->hg_min )  { \
		(_hp)->hg_bins[0] += __count; \
	} else if( (_val) >= (_hp)->hg_max )  { \
		(_hp)->hg_bins[(_hp)->hg_nbins] += __count; \
	} else { \
		(_hp)->hg_bins[(int)(((_val)-(_hp)->hg_min)/(_hp)->hg_clumpsize)] += __count; \
	} \
	(_hp)->hg_nsamples += __count;  }


/*----------------------------------------------------------------------*/
/* ptbl.c */
/*
 *  Support for generalized "pointer tables".
 */
#define BU_PTBL_INIT	0	/* initialize table pointer struct & get storage */
#define BU_PTBL_INS	1	/* insert an item (long *) into a table */
#define BU_PTBL_LOC 	2	/* locate a (long *) in an existing table */
#define BU_PTBL_FREE	3	/* deallocate buffer associated with a table */
#define BU_PTBL_RST	4	/* empty a table, but keep storage on hand */
#define BU_PTBL_CAT	5	/* catenate one table onto another */
#define BU_PTBL_RM	6	/* remove all occurrences of an item from a table */
#define BU_PTBL_INS_UNIQUE 7	/* insert item into table, if not present */
#define BU_PTBL_ZERO	8	/* replace all occurrences of an item by 0 */

struct bu_ptbl {
	struct bu_list	l;	/* linked list for caller's use */
	int		end;	/* index into buffer of first available location */
	int		blen;	/* # of (long *)'s worth of storage at *buffer */
	long 		**buffer; /* data storage area */
};
#define BU_PTBL_MAGIC		0x7074626c		/* "ptbl" */
#define BU_CK_PTBL(_p)		BU_CKMAG(_p, BU_PTBL_MAGIC, "bu_ptbl")

/*
 *  For those routines that have to "peek" into the ptbl a little bit.
 */
#define BU_PTBL_BASEADDR(ptbl)	((ptbl)->buffer)
#define BU_PTBL_LASTADDR(ptbl)	((ptbl)->buffer + (ptbl)->end - 1)
#define BU_PTBL_END(ptbl)	((ptbl)->end)
#define BU_PTBL_LEN(p)	((p)->end)
#define BU_PTBL_GET(ptbl,i)	((ptbl)->buffer[(i)])
#define BU_PTBL_SET(ptbl,i,val)	((ptbl)->buffer[(i)] = (long*)(val))
#define BU_PTBL_TEST(ptbl)	((ptbl)->l.magic == BU_PTBL_MAGIC)
#define BU_PTBL_CLEAR_I(_ptbl, _i) ((_ptbl)->buffer[(_i)] = (long *)0)

/*
 *  A handy way to visit all the elements of the table is:
 *
 *	struct edgeuse **eup;
 *	for( eup = (struct edgeuse **)BU_PTBL_LASTADDR(&eutab);
 *	     eup >= (struct edgeuse **)BU_PTBL_BASEADDR(&eutab); eup-- )  {
 *		NMG_CK_EDGEUSE(*eup);
 *	}
 *  or
 *	for( BU_PTBL_FOR( eup, (struct edgeuse **), &eutab ) )  {
 *		NMG_CK_EDGEUSE(*eup);
 *	}
 */
#define BU_PTBL_FOR(ip,cast,ptbl)	\
    ip = cast BU_PTBL_LASTADDR(ptbl); ip >= cast BU_PTBL_BASEADDR(ptbl); ip--


/* vlist, vlblock?  But they use vmath.h... */

/*----------------------------------------------------------------------*/
/* mappedfile.c */
/*
 *			B U _ M A P P E D _ F I L E
 *
 *  Structure for opening a mapped file.
 *  Each file is opened and mapped only once (per application,
 *  as tagged by the string in "appl" field).
 *  Subsequent opens require an exact match on both strings.
 *
 *  Before allocating apbuf and performing data conversion into it,
 *  openers should check to see if the file has already been opened and
 *  converted previously.
 *
 *  When used in RT, the mapped files are not closed at the end of a frame,
 *  so that subsequent frames may take advantage of the large data files
 *  having already been read and converted.
 *  Examples include EBMs, texture maps, and height fields.
 *
 *  For appl == "db_i", file is a ".g" database & apbuf is (struct db_i *).
 */
struct bu_mapped_file {
	struct bu_list	l;
	char		*name;		/* bu_strdup() of file name */
	genptr_t	buf;		/* In-memory copy of file (may be mmapped) */
	long		buflen;		/* # bytes in 'buf' */
	int		is_mapped;	/* 1=mmap() used, 0=bu_malloc/fread */
	char		*appl;		/* bu_strdup() of tag for application using 'apbuf' */
	genptr_t	apbuf;		/* opt: application-specific buffer */
	long		apbuflen;	/* opt: application-specific buflen */
	time_t		modtime;	/* date stamp, in case file is modified */
	int		uses;		/* # ptrs to this struct handed out */
	int		dont_restat;	/* 1=on subsequent opens, don't re-stat() */
};
#define BU_MAPPED_FILE_MAGIC	0x4d617066	/* Mapf */
#define BU_CK_MAPPED_FILE(_p)	BU_CKMAG(_p, BU_MAPPED_FILE_MAGIC, "bu_mapped_file")

/*----------------------------------------------------------------------*/

/* formerly rt_g.rtg_logindent, now use bu_log_indent_delta() */
typedef int (*bu_hook_t)BU_ARGS((genptr_t, genptr_t));

struct bu_hook_list {
	struct bu_list	l;
	bu_hook_t	hookfunc;
	genptr_t 	clientdata;
};

#define BUHOOK_NULL 0
#define BUHOOK_LIST_MAGIC	0x90d5dead	/* Nietzsche? */
#define BUHOOK_LIST_NULL	((struct bu_hook_list *) 0)

extern struct bu_hook_list bu_log_hook_list;
extern struct bu_hook_list bu_bomb_hook_list;

/*----------------------------------------------------------------------*/
/* avs.c */
/*
 *  Attribute/value sets
 */

/*
 *			B U _ A T T R I B U T E _ V A L U E _ P A I R
 *
 *  These strings may or may not be individually allocated,
 *  it depends on usage.
 */
struct bu_attribute_value_pair {
	const char	*name;
	const char	*value;
};

/*
 *			B U _ A T T R I B U T E _ V A L U E _ S E T
 *
 *  A variable-sized attribute-value-pair array.
 *
 *  avp points to an array of [max] slots.
 *  The interface routines will realloc to extend as needed.
 *
 *  In general,
 *  each of the names and values is a local copy made with bu_strdup(),
 *  and each string needs to be freed individually.
 *  However, if a name or value pointer is between
 *  readonly_min and readonly_max, then it is part of a big malloc
 *  block that is being freed by the caller, and should not be individually
 *  freed.
 */
struct bu_attribute_value_set {
	long				magic;
	int				count;	/* # valid entries in avp */
	int				max;	/* # allocated slots in avp */
	struct bu_attribute_value_pair	*avp;	/* array[max] */
	char				*readonly_min;
	char				*readonly_max;
};
#define BU_AVS_MAGIC		0x41765321	/* AvS! */
#define BU_CK_AVS(_avp)		BU_CKMAG(_avp, BU_AVS_MAGIC, "bu_attribute_value_set")

#define BU_AVS_FOR(_pp, _avp)	\
	(_pp) = &(_avp)->avp[(_avp)->count-1]; (_pp) >= (_avp)->avp; (_pp)--

/*
 *  Some (but not all) attribute name and value string pointers are
 *  taken from an on-disk format bu_external block,
 *  while others have been bu_strdup()ed and need to be freed.
 *  This macro indicates whether the pointer needs to be freed or not.
 */
#define AVS_IS_FREEABLE(_avsp, _p)	\
	( (_avsp)->readonly_max == NULL || \
	    ((_p) < (_avsp)->readonly_min || (_p) > (_avsp)->readonly_max) )

/*----------------------------------------------------------------------*/
/* vls.c */
/*
 *  Variable Length Strings: bu_vls support (formerly rt_vls in h/rtstring.h)
 */
struct bu_vls  {
	long	vls_magic;
	char	*vls_str;	/* Dynamic memory for buffer */
	int	vls_offset;	/* Offset into vls_str where data is good */
	int	vls_len;	/* Length, not counting the null */
	int	vls_max;
};
#define BU_VLS_MAGIC		0x89333bbb
#define BU_CK_VLS(_vp)		BU_CKMAG(_vp, BU_VLS_MAGIC, "bu_vls")
#define BU_VLS_IS_INITIALIZED(_vp)	\
	((_vp) && ((_vp)->vls_magic == BU_VLS_MAGIC))

/*
 *  Section for manifest constants for bu_semaphore_acquire()
 */
#define BU_SEM_SYSCALL	0
#define BU_SEM_LISTS	1
#define BU_SEM_BN_NOISE	2
#define BU_SEM_MAPPEDFILE 3
#define BU_SEM_LAST	(BU_SEM_MAPPEDFILE+1)	/* allocate this many for LIBBU+LIBBN */
/*
 *  Automatic restart capability in bu_bomb().
 *  The return from BU_SETJUMP is the return from the setjmp().
 *  It is 0 on the first pass through, and non-zero when
 *  re-entered via a longjmp() from bu_bomb().
 *  This is only safe to use in non-parallel applications.
 */
#define BU_SETJUMP	setjmp((bu_setjmp_valid=1,bu_jmpbuf))
#define BU_UNSETJUMP	(bu_setjmp_valid=0)
/* These are global because BU_SETJUMP must be macro.  Please don't touch. */
extern int	bu_setjmp_valid;		/* !0 = bu_jmpbuf is valid */
extern jmp_buf	bu_jmpbuf;			/* for BU_SETJMP() */

/*-------------------------------------------------------------------------*/
/* 			B U _ M R O
 *
 *	Support for Multiply Represented Objects
 */

struct bu_mro {
	long		magic;
	struct bu_vls	string_rep;
	char		long_rep_is_valid;
	long		long_rep;
	char		double_rep_is_valid;
	double		double_rep;
};

#define BU_MRO_MAGIC	0x4D524F4F	/* MROO */
#define BU_CK_MRO(_vp)		BU_CKMAG(_vp, BU_MRO_MAGIC, "bu_mro")

#define BU_MRO_INVALIDATE(_p ) {\
	_p->long_rep_is_valid = '\0';\
	_p->double_rep_is_valid = '\0';\
}

#define BU_MRO_GETDOUBLE( _p ) ( _p->double_rep_is_valid ? _p->double_rep : \
	(_p->double_rep = strtod( bu_vls_addr( &_p->string_rep ), NULL ), \
	( _p->double_rep_is_valid='y', _p->double_rep ) ) )

#define BU_MRO_GETLONG( _p ) ( _p->long_rep_is_valid ? _p->long_rep : \
	(_p->long_rep = strtol( bu_vls_addr( &_p->string_rep ), NULL, 10 ), \
	( _p->long_rep_is_valid='y', _p->long_rep ) ) )

#define BU_MRO_GETSTRING( _p ) bu_vls_addr( &_p->string_rep )

#define BU_MRO_STRLEN( _p ) bu_vls_strlen( &_p->string_rep )

/*----------------------------------------------------------------------*/
/*
 * Section for BU_DEBUG values
 *
 * These can be set from the command-line of RT-compatible programs
 * using the "-! ###" option.
 */
extern int	bu_debug;
/* These definitions are each for one bit */
#define BU_DEBUG_OFF		0	/* No debugging */

#define BU_DEBUG_COREDUMP	0x00000001	/* 001 If set, bu_bomb() will dump core */

#define BU_DEBUG_MEM_CHECK	0x00000002	/* 002 Mem barrier & leak checking */
#define BU_DEBUG_MEM_LOG	0x00000004	/* 003 Print all dynamic memory operations */
#define BU_DEBUG_DB		0x00000008	/* 004 Database debugging */
	
#define BU_DEBUG_PARALLEL	0x00000010	/* 005 parallel support */

#define BU_DEBUG_MATH		0x00000100	/* 011 Fundamental math routines (plane.c, mat.c) */
#define BU_DEBUG_PTBL		0x00000200	/* 012 bu_ptbl_*() logging */
#define BU_DEBUG_AVS		0x00000400	/* 013 bu_avs_*() logging */
#define BU_DEBUG_MAPPED_FILE	0x00000800	/* 014 bu_mapped_file logging */

#define BU_DEBUG_TABDATA	0x00010000	/* 025 LIBBN: tabdata */

/* Format string for bu_printb() */
#define BU_DEBUG_FORMAT	\
"\020\
\025TABDATA\
\015?\
\014MAPPED_FILE\013AVS\012PTBL\011MATH\010?\7?\6?\5PARALLEL\
\4?\3MEM_LOG\2MEM_CHECK\1COREDUMP"

/*----------------------------------------------------------------------*/
/* parse.c */
/*
 *	Structure parse/print
 *
 *  Definitions and data structures needed for routines that assign values
 *  to elements of arbitrary data structures, the layout of which is
 *  described by tables of "bu_structparse" structures.
 *
 *  The general problem of word-addressed hardware
 *  where (int *) and (char *) have different representations
 *  is handled in the parsing routines that use sp_offset,
 *  because of the limitations placed on compile-time initializers.
 */
#if __STDC__ && !defined(ipsc860)
#	define bu_offsetofarray(_t, _m)	offsetof(_t, _m[0])
#else
#	if !defined(offsetof)
#		define bu_offsetof(_t, _m)		(int)(&(((_t *)0)->_m))
#	else
#		define bu_offsetof(_t, _m)	offsetof(_t, _m)
#	endif
#	define bu_offsetofarray(_t, _m)	(int)( (((_t *)0)->_m))
#endif

/*
 *  Convert address of global data object into byte "offset" from address 0.
 */
#if defined(CRAY)
#	define bu_byteoffset(_i)	(((int)&(_i)))	/* actually a word offset */
#else
#  if defined(IRIX) && IRIX > 5 && _MIPS_SIM != _MIPS_SIM_ABI32
#	define bu_byteoffset(_i)	((size_t)__INTADDR__(&(_i)))
#  else
#    if defined(sgi) || defined(__convexc__) || defined(ultrix) || defined(_HPUX_SOURCE)
	/* "Lazy" way.  Works on reasonable machines with byte addressing */
#	define bu_byteoffset(_i)	((int)((char *)&(_i)))
#    else
	/* "Conservative" way of finding # bytes as diff of 2 char ptrs */
#	define bu_byteoffset(_i)	((int)(((char *)&(_i))-((char *)0)))
#    endif
#  endif
#endif

/* The "bu_structparse" struct describes one element of a structure.
 * Collections of these are combined to describe entire structures (or at
 * least those portions for which parse/print/import/export support is
 * desired.  For example:
 *
 * struct data_structure {
 *	char	a_char;
 *	char	str[32];
 *	short	a_short;
 *	int	a_int;
 *	double	a_double;
 * } 
 *
 * struct data_structure data_default = 
 *	{ 'c', "the default string", 32767, 1, 1.0 };
 *
 * struct data_structure my_values;
 *
 * struct bu_structparse data_sp[] ={
 *
 * {"%c", 1,  "a_char",   bu_offsetof(data_structure, a_char),
 *	BU_STRUCTPARSE_FUNC_NULL,
 *	"a single character",	(void*)&default.a_char }, 
 *
 * {"%s", 32, "str",      bu_offsetofarray(data_structure, str),
 *	BU_STRUCTPARSE_FUNC_NULL,
 *	"This is a full character string", (void*)default.str }, }, 
 *
 * {"%i", 1,  "a_short",  bu_offsetof(data_structure, a_short),
 *	BU_STRUCTPARSE_FUNC_NULL,
 *	"A 16bit integer",	(void*)&default.a_short },
 *
 * {"%d", 1,  "a_int",    bu_offsetof(data_structure, a_int),
 *	BU_STRUCTPARSE_FUNC_NULL,
 *	"A full integer",	(void*)&default.a_int },
 *
 * {"%f", 1,  "a_double", bu_offsetof(data_structure, a_double),
 *	BU_STRUCTPARSE_FUNC_NULL,
 *	"A double-precision floating point value",  (void*)&default.a_double },
 *
 * { "", 0, (char *)NULL, 0,
 *	BU_STRUCTPARSE_FUNC_NULL, 
 *	(char *)NULL, (void *)NULL }
 *
 * };
 *
 *
 * To parse a string, call:
 *
 *	bu_struct_parse( vls_string, data_sp, (char *)my_values)
 *
 * this will parse the vls string and assign values to the members of the
 * structure my_values
 *
 *  A gross hack:  To set global variables (or others for that matter) you
 *	can store the actual address of the variable in the sp_offset field
 *	and pass a null pointer as the last argument to bu_struct_parse().
 *	If you don't understand why this would work, you probably shouldn't
 *	use this technique.
 */
struct bu_structparse {
	char		sp_fmt[4];		/* "i" or "%f", etc */
	long		sp_count;		/* number of elements */
	char		*sp_name;		/* Element's symbolic name */
	long		sp_offset;		/* Byte offset in struct */
	void		(*sp_hook)();		/* Optional hooked function, or indir ptr */
	char		*sp_desc;		/* description of element */
	void		*sp_default;		/* ptr to default value */
};
#define BU_STRUCTPARSE_FUNC_NULL	((void (*)())0)




/*----------------------------------------------------------------------*/
/*
 *			B U _ E X T E R N A L
 *
 *  An "opaque" handle for holding onto objects,
 *  typically in some kind of external form that is not directly
 *  usable without passing through an "importation" function.
 * A "bu_external" struct holds the "external binary" representation of a
 * structure or other block of arbitrary data.
 */
struct bu_external  {
	long	ext_magic;
	long	ext_nbytes;
	genptr_t ext_buf;
};
#define BU_EXTERNAL_MAGIC	0x768dbbd0
#define BU_INIT_EXTERNAL(_p)	{(_p)->ext_magic = BU_EXTERNAL_MAGIC; \
	(_p)->ext_buf = (genptr_t)NULL; (_p)->ext_nbytes = 0;}
#define BU_CK_EXTERNAL(_p)	BU_CKMAG(_p, BU_EXTERNAL_MAGIC, "bu_external")

/*----------------------------------------------------------------------*/
/* color.c */
#define	HUE		0
#define	SAT		1
#define	VAL		2
#define	ACHROMATIC	-1.0

struct bu_color
{
    long	buc_magic;
    fastf_t	buc_rgb[3];
};
#define	BU_COLOR_MAGIC		0x6275636c
#define	BU_COLOR_NULL		((struct bu_color *) 0)
#define BU_CK_COLOR(_bp)	BU_CKMAG(_bp, BU_COLOR_MAGIC, "bu_color")

/*----------------------------------------------------------------------*/
/* red-black tree support */
/*
 *	The data structures and constants for red-black trees.
 *
 *	Many of these routines are based on the algorithms in chapter 13
 *	of T. H. Cormen, C. E. Leiserson, and R. L. Rivest,
 *	_Introduction to algorithms_, MIT Press, Cambridge, MA, 1990.
 *
 *	Author:	Paul Tanenbaum
 *
 */

/*
 *			    B U _ R B _ L I S T
 *
 *		    List of nodes or packages
 *
 *	The red-black tree package uses this structure to maintain lists
 *	of all the nodes and all the packages in the tree.  Applications
 *	should not muck with these things.  They are maintained only to
 *	facilitate freeing bu_rb_trees.
 */
struct bu_rb_list
{
    struct bu_list	l;
    union
    {
	struct bu_rb_node    *rbl_n;
	struct bu_rb_package *rbl_p;
    }			rbl_u;
};
#define	rbl_magic	l.magic
#define	rbl_node	rbl_u.rbl_n
#define	rbl_package	rbl_u.rbl_p
#define	BU_RB_LIST_NULL	((struct bu_rb_list *) 0)


/*
 *			B U _ R B _ T R E E
 *
 *	This is the only data structure used in the red-black tree package
 *	to which application software need make any explicit reference.
 *
 *	The members of this structure are grouped into three
 *	classes:
 *	    Class I:	Reading is appropriate, when necessary,
 *			but applications should not modify.
 *	    Class II:	Reading and modifying are both appropriate,
 *			when necessary.
 *	    Class III:	All access should be through routines
 *			provided in the package.  Touch these
 *			at your own risk!
 */
typedef struct
{
    /* CLASS I - Applications may read directly... */
    long	 	rbt_magic;	  /* Magic no. for integrity check */
    int			rbt_nm_nodes;	  /* Number of nodes */
    /* CLASS II - Applications may read/write directly... */
    void		(*rbt_print)();	  /* Data pretty-print function */
    int			rbt_debug;	  /* Debug bits */
    char		*rbt_description; /* Comment for diagnostics */
    /* CLASS III - Applications should not manipulate directly... */
    int		 	rbt_nm_orders;	  /* Number of simultaneous orders */
    int			(**rbt_order)();  /* Comparison functions */
    struct bu_rb_node	**rbt_root;	  /* The actual trees */
    char		*rbt_unique;	  /* Uniqueness flags */
    struct bu_rb_node	*rbt_current;	  /* Current node */
    struct bu_rb_list	rbt_nodes;	  /* All nodes */
    struct bu_rb_list	rbt_packages;	  /* All packages */
    struct bu_rb_node	*rbt_empty_node;  /* Sentinel representing nil */
}	bu_rb_tree;
#define	BU_RB_TREE_NULL	((bu_rb_tree *) 0)
#define	BU_RB_TREE_MAGIC	0x72627472

/*
 *	Debug bit flags for member rbt_debug
 */
#define BU_RB_DEBUG_INSERT	0x00000001	/* Insertion process */
#define BU_RB_DEBUG_UNIQ	0x00000002	/* Uniqueness of inserts */
#define BU_RB_DEBUG_ROTATE	0x00000004	/* Rotation process */
#define BU_RB_DEBUG_OS	0x00000008	/* Order-statistic operations */
#define BU_RB_DEBUG_DELETE	0x00000010	/* Deletion process */

/*
 *			B U _ R B _ P A C K A G E
 *
 *		    Wrapper for application data
 *
 *	This structure provides a level of indirection between
 *	the application software's data and the red-black nodes
 *	in which the data is stored.  It is necessary because of
 *	the algorithm for deletion, which generally shuffles data
 *	among nodes in the tree.  The package structure allows
 *	the application data to remember which node "contains" it
 *	for each order.
 */
struct bu_rb_package
{
    long		rbp_magic;	/* Magic no. for integrity check */
    struct bu_rb_node	**rbp_node;	/* Containing nodes */
    struct bu_rb_list	*rbp_list_pos;	/* Place in the list of all pkgs. */
    void		*rbp_data;	/* Application data */
};
#define	BU_RB_PKG_NULL	((struct bu_rb_package *) 0)

/*
 *			    B U _ R B _ N O D E
 *
 *	For the most part, there is a one-to-one correspondence
 *	between nodes and chunks of application data.  When a
 *	node is created, all of its package pointers (one per
 *	order of the tree) point to the same chunk of data.
 *	However, subsequent deletions usually muddy this tidy
 *	state of affairs.
 */
struct bu_rb_node
{
    long		rbn_magic;	/* Magic no. for integrity check */
    bu_rb_tree		*rbn_tree;	/* Tree containing this node */
    struct bu_rb_node	**rbn_parent;	/* Parents */
    struct bu_rb_node	**rbn_left;	/* Left subtrees */
    struct bu_rb_node	**rbn_right;	/* Right subtrees */
    char		*rbn_color;	/* Colors of this node */
    int			*rbn_size;	/* Sizes of subtrees rooted here */
    struct bu_rb_package **rbn_package;	/* Contents of this node */
    int			rbn_pkg_refs;	/* How many orders are being used? */
    struct bu_rb_list	*rbn_list_pos;	/* Place in the list of all nodes */
};
#define	BU_RB_NODE_NULL	((struct bu_rb_node *) 0)

/*
 *	Applications interface to bu_rb_extreme()
 */
#define	SENSE_MIN	0
#define	SENSE_MAX	1
#define	bu_rb_min(t,o)	bu_rb_extreme((t), (o), SENSE_MIN)
#define	bu_rb_max(t,o)	bu_rb_extreme((t), (o), SENSE_MAX)
#define bu_rb_pred(t,o)	bu_rb_neighbor((t), (o), SENSE_MIN)
#define bu_rb_succ(t,o)	bu_rb_neighbor((t), (o), SENSE_MAX)

/*
 *	Applications interface to bu_rb_walk()
 */
#define	PREORDER	0
#define	INORDER		1
#define	POSTORDER	2

/*
 *			B U _ O B S E R V E R
 *
 */
struct bu_observer {
  struct bu_list	l;
  struct bu_vls		observer;
  struct bu_vls		cmd;
};
#define BU_OBSERVER_NULL	((struct bu_observer *)0)

/*			B U _ C M D T A B
 *
 *
 */
struct bu_cmdtab {
  char *ct_name;
  int (*ct_func)();
};

/*----------------------------------------------------------------------*/
/* Miscellaneous macros */
#define bu_made_it()		bu_log("Made it to %s:%d\n",	\
					__FILE__, __LINE__)
/*----------------------------------------------------------------------*/
/*
 *  Declarations of external functions in LIBBU.
 *  Source file names listed alphabetically.
 */

/* avs.c */
BU_EXTERN(void			bu_avs_init, (struct bu_attribute_value_set *avp,
				int len, const char *str));
BU_EXTERN(void			bu_avs_init_empty, (struct bu_attribute_value_set *avp ));
BU_EXTERN(struct bu_attribute_value_set	*bu_avs_new, (int len, const char *str));
BU_EXTERN(int			bu_avs_add, (struct bu_attribute_value_set *avp,
				const char *attribute,
				const char *value));
extern int			bu_avs_add_vls(struct bu_attribute_value_set *avp,
				const char *attribute,
				const struct bu_vls *value_vls);
void				bu_avs_merge( struct bu_attribute_value_set *dest,
				const struct bu_attribute_value_set *src );
extern const char *		bu_avs_get( const struct bu_attribute_value_set *avp,
				const char *attribute );
BU_EXTERN(int			bu_avs_remove, (struct bu_attribute_value_set *avp,
				const char *attribute));
BU_EXTERN(void			bu_avs_free, (struct bu_attribute_value_set *avp));
extern void			bu_avs_print( const struct bu_attribute_value_set *avp, const char *title );
extern void bu_avs_add_nonunique( struct bu_attribute_value_set *avsp, char *attribute, char *value );

/* badmagic.c */
BU_EXTERN(void			bu_badmagic, (const long *ptr, unsigned long magic,
				const char *str, const char *file, int line));

/* bitv.c */
BU_EXTERN(struct bu_bitv *	bu_bitv_new, (unsigned int nbits));
BU_EXTERN(void			bu_bitv_clear, (struct bu_bitv *bv));
BU_EXTERN(void			bu_bitv_or, (struct bu_bitv *ov,
				const struct bu_bitv *iv));
BU_EXTERN(void			bu_bitv_and, (struct bu_bitv *ov,
				const struct bu_bitv *iv));
BU_EXTERN(void			bu_bitv_vls, (struct bu_vls *v,
				const struct bu_bitv *bv));
BU_EXTERN(void			bu_pr_bitv, (const char *str,
				const struct bu_bitv *bv));
BU_EXTERN(void			bu_bitv_to_hex, (struct bu_vls *v,
				const struct bu_bitv *bv));
BU_EXTERN( struct bu_bitv *	bu_hex_to_bitv, (const char *str));
BU_EXTERN( struct bu_bitv *	bu_bitv_dup, (const struct bu_bitv *bv));
BU_EXTERN( void			bu_bitv_free, (struct bu_bitv *bv));

/* bomb.c */
BU_EXTERN(void			bu_bomb, (const char *str) );

/* color.c */
BU_EXTERN(void		bu_rgb_to_hsv,		(unsigned char *rgb,
						    fastf_t *hsv) );
BU_EXTERN(int		bu_hsv_to_rgb,		(fastf_t *hsv,
						    unsigned char *rgb) );
BU_EXTERN(int		bu_str_to_rgb,		(char *str,
						    unsigned char *rgb) );
BU_EXTERN(void		bu_color_of_rgb_chars,	(struct bu_color *cp,
						    unsigned char *rgb) );
BU_EXTERN(int		bu_color_to_rgb_chars,	(struct bu_color *cp,
						    unsigned char *rgb) );
BU_EXTERN(int		bu_color_of_rgb_floats,	(struct bu_color *cp,
						    fastf_t *rgb) );
BU_EXTERN(int		bu_color_to_rgb_floats,	(struct bu_color *cp,
						    fastf_t *rgb) );
BU_EXTERN(int		bu_color_of_hsv_floats,	(struct bu_color *cp,
						    fastf_t *hsv) );
BU_EXTERN(int		bu_color_to_hsv_floats,	(struct bu_color *cp,
						    fastf_t *hsv) );

/* convert.c*/
BU_EXTERN(int bu_cv_cookie, (char *in));
BU_EXTERN(int bu_cv_optimize, (int cookie));
BU_EXTERN(int bu_cv_w_cookie, (genptr_t out, int outcookie, size_t size,
			     genptr_t in,  int incookie,  int count));

/* file.c */
BU_EXTERN(struct bu_file	*bu_fopen, (char *fname, char *type) );
BU_EXTERN(int			bu_fclose, (struct bu_file *bfp) );
BU_EXTERN(int			bu_fgetc, (struct bu_file *bfp) );
BU_EXTERN(void			bu_printfile, (struct bu_file *bfp) );

/* brlcad_path.c */
BU_EXTERN(int			bu_file_exists, (const char *path) );
BU_EXTERN(char			*bu_brlcad_path, (const char *rhs) );

/* fopen_uniq */
BU_EXTERN(FILE *		bu_fopen_uniq, (const char *outfmt,
						const char *namefmt,
						int n) );
/* getopt.c */
extern int			bu_opterr;
extern int			bu_optind;
extern int			bu_optopt;
extern char *			bu_optarg;
BU_EXTERN(int			bu_getopt, (int nargc, char * const nargv[],
				const char *ostr) );

/* hist.c */
BU_EXTERN(void			bu_hist_free, (struct bu_hist *histp));
BU_EXTERN(void			bu_hist_init, (struct bu_hist *histp,
				fastf_t min, fastf_t max, unsigned int nbins));
BU_EXTERN(void			bu_hist_range, (struct bu_hist *hp,
				fastf_t low, fastf_t high));
BU_EXTERN(void			bu_hist_pr, (const struct bu_hist *histp,
				const char *title));

/* htond.c */
BU_EXTERN(void			htond, (unsigned char *out,
				const unsigned char *in, int count));
BU_EXTERN(void			ntohd, (unsigned char *out,
				const unsigned char *in, int count));

/* htonf.c */
BU_EXTERN(void			htonf, (unsigned char *out,
				const unsigned char *in, int count));
BU_EXTERN(void			ntohf, (unsigned char *out,
				const unsigned char *in, int count));

/* ispar.c */
BU_EXTERN(int			bu_is_parallel, () );
BU_EXTERN(void			bu_kill_parallel, () );

/* linebuf.c */
#define port_setlinebuf		bu_setlinebuf	/* libsysv compat */
BU_EXTERN(void			bu_setlinebuf, (FILE *fp) );

/* list.c */
BU_EXTERN(int			bu_list_len, (const struct bu_list *hd));
BU_EXTERN(void			bu_list_reverse, (struct bu_list *hd));
BU_EXTERN(void			bu_list_free, (struct bu_list *hd));
BU_EXTERN(void			bu_list_parallel_append, (struct bu_list *headp,
					struct bu_list *itemp));
BU_EXTERN(struct bu_list *	bu_list_parallel_dequeue, (struct bu_list *headp));
BU_EXTERN(void			bu_ck_list, (const struct bu_list *hd,
				const char *str) );
BU_EXTERN(void			bu_ck_list_magic, (const struct bu_list *hd,
				const char *str, const long magic) );

/* hook.c */
BU_EXTERN(void			bu_hook_list_init, (struct bu_hook_list *hlp));
BU_EXTERN(void			bu_add_hook, (struct bu_hook_list *hlp, bu_hook_t func, genptr_t clientdata));
BU_EXTERN(void			bu_delete_hook, (struct bu_hook_list *hlp, bu_hook_t func, genptr_t clientdata));
BU_EXTERN(void			bu_call_hook, (struct bu_hook_list *hlp, genptr_t buf));

/* log.c */
BU_EXTERN(void			bu_log_indent_delta, (int delta) );
BU_EXTERN(void			bu_log_indent_vls, (struct bu_vls *v) );
BU_EXTERN(void			bu_log_add_hook, (bu_hook_t func, genptr_t clientdata));
BU_EXTERN(void			bu_log_delete_hook, (bu_hook_t func, genptr_t clientdata));
BU_EXTERN(void			bu_putchar, (int c) );
#if defined(HAVE_STDARG_H)
 BU_EXTERN(void			bu_log, (char *, ... ) );
 BU_EXTERN(void			bu_flog, (FILE *, char *, ... ) );
#else
 BU_EXTERN(void			bu_log, () );
 BU_EXTERN(void			bu_flog, () );
#endif

/* magic.c */
BU_EXTERN(const char *		bu_identify_magic, (long magic) );

/* malloc.c */
extern long		bu_n_malloc;
extern long		bu_n_free;
extern long		bu_n_realloc;
BU_EXTERN(genptr_t		bu_malloc, (unsigned int cnt, const char *str));
BU_EXTERN(void			bu_free, (genptr_t ptr, const char *str));
BU_EXTERN(genptr_t		bu_realloc, (genptr_t ptr, unsigned int cnt,
				const char *str));
BU_EXTERN(genptr_t		bu_calloc, (unsigned int nelem,
				unsigned int elsize, const char *str));
BU_EXTERN(void			bu_prmem, (const char *str));
BU_EXTERN(char *		bu_strdup, (const char *cp));
BU_EXTERN(char *		bu_dirname, (const char *cp));
BU_EXTERN(int			bu_malloc_len_roundup, (int nbytes));
BU_EXTERN(void			bu_ck_malloc_ptr, (genptr_t ptr, const char *str));
BU_EXTERN(int			bu_mem_barriercheck, ());

/* mappedfile.c */
BU_EXTERN(struct bu_mapped_file *bu_open_mapped_file, (const char *name,
					const char *appl));
BU_EXTERN(void			bu_close_mapped_file, (struct bu_mapped_file *mp));
BU_EXTERN(void			bu_pr_mapped_file, (const char *title,
					const struct bu_mapped_file *mp));
BU_EXTERN(void			bu_free_mapped_files, (int verbose));
BU_EXTERN(struct bu_mapped_file *bu_open_mapped_file_with_path,
					(char * const *path,
					const char *name, const char *appl));

/* parallel.c */
BU_EXTERN(void			bu_nice_set, (int newnice));
BU_EXTERN(int			bu_cpulimit_get, ());
BU_EXTERN(void			bu_cpulimit_set, (int sec));
BU_EXTERN(int			bu_avail_cpus, ());
BU_EXTERN(fastf_t		bu_get_load_average, ());
BU_EXTERN(int			bu_get_public_cpus, ());
BU_EXTERN(int			bu_set_realtime, ());
BU_EXTERN(void			bu_parallel, (void (*func)BU_ARGS((int ncpu, genptr_t arg)),
				int ncpu, genptr_t arg));

/* parse.c */
BU_EXTERN(int			bu_struct_export, (struct bu_external *ext,
				const genptr_t base,
				const struct bu_structparse *imp));
BU_EXTERN(int			bu_struct_import, (genptr_t base,
				const struct bu_structparse *imp,
				const struct bu_external *ext));
BU_EXTERN(int			bu_struct_put, (FILE *fp,
				const struct bu_external *ext));
BU_EXTERN(int			bu_struct_get, (struct bu_external *ext,
				FILE *fp));
BU_EXTERN(void			bu_struct_wrap_buf,
				(struct bu_external *ext, genptr_t buf));
BU_EXTERN(int			bu_struct_parse, (const struct bu_vls *in_vls,
				const struct bu_structparse *desc, 
				const char *base));
BU_EXTERN(void			bu_struct_print, ( const char *title,
				const struct bu_structparse *parsetab,
				const char *base));
BU_EXTERN(void			bu_vls_struct_print, (struct bu_vls *vls,
				const struct bu_structparse *sdp,
				const char *base));
BU_EXTERN(void			bu_vls_struct_print2, (struct bu_vls *vls,
						       const char *title,
						       const struct bu_structparse *sdp,
						       const char *base));
BU_EXTERN(void			bu_vls_struct_item, (struct bu_vls *vp,
				const struct bu_structparse *sdp,
				const char *base,
				int sep_char));
BU_EXTERN(int			bu_vls_struct_item_named, (struct bu_vls *vp,
				const struct bu_structparse *sdp,
				const char *name,
				const char *base,
				int sep_char));
BU_EXTERN(void			bu_parse_mm, (const struct bu_structparse *sdp,
				const char *name,
				char *base,
				const char *value));
BU_EXTERN( int                  bu_key_eq_to_key_val, (char *in, char **next, struct bu_vls *vls) );
BU_EXTERN( int                  bu_shader_to_tcl_list, (char *in, struct bu_vls *vls) );
BU_EXTERN( int                  bu_key_val_to_key_eq, (char *in) );
BU_EXTERN( int                  bu_shader_to_key_eq, (char *in, struct bu_vls *vls) );
int				bu_fwrite_external( FILE *fp, const struct bu_external *ep );
void				bu_hexdump_external( FILE *fp, const struct bu_external *ep, const char *str);
void				bu_free_external(struct bu_external *ep);
void				bu_copy_external(struct bu_external *op, const struct bu_external *ip);
char				*bu_next_token( char *str );
				
/* printb.c */
BU_EXTERN(void			bu_vls_printb, (struct bu_vls *vls,
				const char *s, unsigned long v,
				const char *bits));
BU_EXTERN(void			bu_printb, (const char *s, unsigned long v,
				const char *bits));

/* ptbl.c */
BU_EXTERN(void			bu_ptbl_init, (struct bu_ptbl *b, int len, const char *str));
BU_EXTERN(void			bu_ptbl_reset, (struct bu_ptbl	*b));
BU_EXTERN(int			bu_ptbl_ins, (struct bu_ptbl *b, long *p));
BU_EXTERN(int			bu_ptbl_locate, (const struct bu_ptbl *b, const long *p));
BU_EXTERN(void			bu_ptbl_zero, (struct bu_ptbl *b, const long *p));
BU_EXTERN(int			bu_ptbl_ins_unique, (struct bu_ptbl *b, long *p));
BU_EXTERN(int			bu_ptbl_rm, (struct bu_ptbl *b, const long *p));
BU_EXTERN(void			bu_ptbl_cat, (struct bu_ptbl *dest,
				const struct bu_ptbl *src));
BU_EXTERN(void			bu_ptbl_cat_uniq, (struct bu_ptbl *dest,
				const struct bu_ptbl *src));
BU_EXTERN(void			bu_ptbl_free, (struct bu_ptbl	*b));
BU_EXTERN(int			bu_ptbl, (struct bu_ptbl *b, int func, long *p));
BU_EXTERN(void			bu_pr_ptbl, (const char *title,
				const struct bu_ptbl *tbl, int verbose));
BU_EXTERN(void			bu_ptbl_trunc, (struct bu_ptbl *tbl, int end));

/* rb_create.c */
BU_EXTERN(bu_rb_tree *bu_rb_create,	(char		*description,
				 int 		nm_orders,
				 int		(**order_funcs)()
				));
BU_EXTERN(bu_rb_tree *bu_rb_create1,	(char		*description,
				 int		(*order_func)()
				));
/* rb_delete.c */
BU_EXTERN(void bu_rb_delete,	(bu_rb_tree	*tree,
				 int		order
				));
#define		bu_rb_delete1(t)	bu_rb_delete((t), 0)

/* rb_diag.c */
BU_EXTERN(void bu_rb_diagnose_tree,(bu_rb_tree	*tree,
				 int		order,
				 int		trav_type
				));
BU_EXTERN(void bu_rb_summarize_tree,(bu_rb_tree	*tree
				 ));
/* rb_extreme.c */
BU_EXTERN(void *bu_rb_curr,	(bu_rb_tree	*tree,
				 int		order
				));
#define		bu_rb_curr1(t)	bu_rb_curr((t), 0)
BU_EXTERN(void *bu_rb_extreme,	(bu_rb_tree	*tree,
				 int		order,
				 int		sense
				));
BU_EXTERN(void *bu_rb_neighbor,	(bu_rb_tree	*tree,
				 int		order,
				 int		sense
				));
/* rb_free.c */
BU_EXTERN(void bu_rb_free,		(bu_rb_tree	*tree,
				 void		(*free_data)()
				));
#define	BU_RB_RETAIN_DATA	((void (*)()) 0)
#define		bu_rb_free1(t,f)					\
		{							\
		    BU_CKMAG((t), BU_RB_TREE_MAGIC, "red-black tree");	\
		    bu_free((char *) ((t) -> rbt_order),		\
				"red-black order function");		\
		    bu_rb_free(t,f);					\
		}
/* rb_insert.c */
BU_EXTERN(int bu_rb_insert,	(bu_rb_tree	*tree,
				 void		*data
				));
BU_EXTERN(int bu_rb_is_uniq,	(bu_rb_tree	*tree,
				 int		order
				));
#define		bu_rb_is_uniq1(t)	bu_rb_is_uniq((t), 0)
BU_EXTERN(void bu_rb_set_uniqv,	(bu_rb_tree	*tree,
				 bitv_t		vec
				));
BU_EXTERN(void bu_rb_uniq_all_off,	(bu_rb_tree	*tree
				));
BU_EXTERN(void bu_rb_uniq_all_on,	(bu_rb_tree	*tree
				));
BU_EXTERN(int bu_rb_uniq_off,	(bu_rb_tree	*tree,
				 int		order
				));
#define		bu_rb_uniq_off1(t)	bu_rb_uniq_off((t), 0)
BU_EXTERN(int bu_rb_uniq_on,	(bu_rb_tree	*tree,
				 int		order
				));
#define		bu_rb_uniq_on1(t)	bu_rb_uniq_on((t), 0)

/* rb_order_stats.c */
BU_EXTERN(int bu_rb_rank,	(bu_rb_tree	*tree,
				 int		order
				));
#define		bu_rb_rank1(t)	bu_rb_rank1((t), 0)
BU_EXTERN(void *bu_rb_select,	(bu_rb_tree	*tree,
				 int		order,
				 int		k
				));
#define		bu_rb_select1(t,k)	bu_rb_select((t), 0, (k))

/* rb_search.c */
BU_EXTERN(void *bu_rb_search,	(bu_rb_tree	*tree,
				 int		order,
				 void		*data
				));
#define		bu_rb_search1(t,d)	bu_rb_search((t), 0, (d))

/* rb_walk.c */
BU_EXTERN(void bu_rb_walk,		(bu_rb_tree	*tree,
				 int		order,
				 void		(*visit)(),
				 int		trav_type
				));
#define		bu_rb_walk1(t,v,d)	bu_rb_walk((t), 0, (v), (d))

/* semaphore.c */
BU_EXTERN(void			bu_semaphore_init, (unsigned int nsemaphores));
BU_EXTERN(void			bu_semaphore_acquire, (unsigned int i));
BU_EXTERN(void			bu_semaphore_release, (unsigned int i));

/* vls.c */
BU_EXTERN(void			bu_vls_init, (struct bu_vls *vp) );
BU_EXTERN(void			bu_vls_init_if_uninit, (struct bu_vls *vp) );
BU_EXTERN(struct bu_vls *	bu_vls_vlsinit, () );
BU_EXTERN(char *		bu_vls_addr, (const struct bu_vls *vp) );
BU_EXTERN(char *		bu_vls_strdup, (const struct bu_vls *vp) );
BU_EXTERN(char *		bu_vls_strgrab, (struct bu_vls *vp) );
BU_EXTERN(void			bu_vls_extend, (struct bu_vls *vp, unsigned int extra) );
BU_EXTERN(void			bu_vls_setlen, (struct bu_vls *vp, int newlen));
BU_EXTERN(int			bu_vls_strlen, (const struct bu_vls *vp) );
BU_EXTERN(void			bu_vls_trunc, (struct bu_vls *vp, int len) );
BU_EXTERN(void			bu_vls_trunc2, (struct bu_vls *vp, int len) );
BU_EXTERN(void			bu_vls_nibble, (struct bu_vls *vp, int len) );
BU_EXTERN(void			bu_vls_free, (struct bu_vls *vp) );
BU_EXTERN(void			bu_vls_vlsfree, (struct bu_vls *vp) );
BU_EXTERN(void			bu_vls_strcpy, (struct bu_vls *vp, const char *s) );
BU_EXTERN(void			bu_vls_strncpy, (struct bu_vls *vp, const char *s, long n) );
BU_EXTERN(void			bu_vls_strcat, (struct bu_vls *vp, const char *s) );
BU_EXTERN(void			bu_vls_strncat, (struct bu_vls *vp, const char *s, long n) );
BU_EXTERN(void			bu_vls_vlscat, (struct bu_vls *dest, const struct bu_vls *src) );
BU_EXTERN(void			bu_vls_vlscatzap, (struct bu_vls *dest, struct bu_vls *src) );
BU_EXTERN(void			bu_vls_from_argv, (struct bu_vls *vp, int argc, char **argv) );
BU_EXTERN(int			bu_argv_from_string, (char **argv, int lim, char *lp));
BU_EXTERN(void			bu_vls_fwrite, (FILE *fp, const struct bu_vls *vp) );
void				bu_vls_write( int fd, const struct bu_vls *vp );
int				bu_vls_read( struct bu_vls *vp, int fd );
BU_EXTERN(int			bu_vls_gets, (struct bu_vls *vp, FILE *fp) );
BU_EXTERN(void			bu_vls_putc, (struct bu_vls *vp, int c) );
void				bu_vls_trimspace( struct bu_vls *vp );
#if 0
BU_EXTERN(void			bu_vls_vprintf, (struct bu_vls *vls,
				const char *fmt, va_list ap));
#endif
BU_EXTERN(void			bu_vls_printf, (struct bu_vls *vls, char *fmt, ... ) );
BU_EXTERN(void			bu_vls_spaces, (struct bu_vls *vp, int cnt));
BU_EXTERN(int			bu_vls_print_positions_used, (const struct bu_vls *vp));
BU_EXTERN(void			bu_vls_detab, (struct bu_vls *vp));

#if 0
BU_EXTERN(void			bu_vls_blkset, (struct bu_vls *vp, int len, int ch) );
#endif

BU_EXTERN(void			bu_vls_prepend, (struct bu_vls *vp, char *str) );


/* vers.c (created by the Cakefile) */
extern const char		bu_version[];

/* units.c */
BU_EXTERN(double bu_units_conversion, (const char *str) );
BU_EXTERN(const char *bu_units_string, (const double mm) );
BU_EXTERN(double bu_mm_value, (const char *s) );
BU_EXTERN(void bu_mm_cvt, (register const struct bu_structparse	*sdp,
		register const char *name,  char *base, const char *value) );

/* xdr.c */
/* Macro version of library routine bu_glong() */
/* The argument is expected to be of type "unsigned char" */
#define BU_GLONGLONG(_cp)	\
	    ((((long)((_cp)[0])) << 56) |	\
             (((long)((_cp)[1])) << 48) |	\
             (((long)((_cp)[2])) << 40) |	\
             (((long)((_cp)[3])) << 32) |	\
             (((long)((_cp)[4])) << 24) |	\
             (((long)((_cp)[5])) << 16) |	\
             (((long)((_cp)[6])) <<  8) |	\
              ((long)((_cp)[7])) )
#define BU_GLONG(_cp)	\
	    ((((long)((_cp)[0])) << 24) |	\
             (((long)((_cp)[1])) << 16) |	\
             (((long)((_cp)[2])) <<  8) |	\
              ((long)((_cp)[3])) )
#define BU_GSHORT(_cp)	\
            ((((short)((_cp)[0])) << 8) | \
                       (_cp)[1] )

BU_EXTERN(unsigned short	bu_gshort, (const unsigned char *msgp));
BU_EXTERN(unsigned long		bu_glong, (const unsigned char *msgp));
BU_EXTERN(unsigned char *	bu_pshort, (register unsigned char *msgp,
				register int s));
BU_EXTERN(unsigned char *	bu_plong, (register unsigned char *msgp,
				register unsigned long l));


/* association.c */
BU_EXTERN(struct bu_vls *bu_association, (const char *fname, const char *value, int field_sep));

/* Things that live in libbu/observer.c */
extern void bu_observer_notify();
extern struct bu_cmdtab bu_observer_cmds[];
extern void bu_observer_free(struct bu_observer *);

/* bu_tcl.c */
/* The presence of Tcl_Interp as an arg prevents giving arg list */
extern void bu_badmagic_tcl(Tcl_Interp	*interp,
			    const long	*ptr,
			    unsigned long	magic,
			    const char	*str,
			    const char	*file,
			    int		line);

extern void bu_structparse_get_terse_form(Tcl_Interp	*interp,
					  register struct bu_structparse *sp);

extern int bu_structparse_argv(Tcl_Interp			*interp,
			       int				argc,
			       char				**argv,
			       const struct bu_structparse	*desc,
			       char				*base);

extern int bu_tcl_mem_barriercheck(ClientData	clientData,
				   Tcl_Interp	*interp,
				   int		argc,
				   char		**argv);

extern int bu_tcl_ck_malloc_ptr(ClientData		clientData,
				Tcl_Interp		*interp,
				int		argc,
				char		**argv);

extern int bu_tcl_malloc_len_roundup(ClientData	clientData,
				     Tcl_Interp	*interp,
				     int		argc,
				     char		**argv);

extern int bu_tcl_prmem(ClientData	clientData,
			Tcl_Interp	*interp,
			int	argc,
			char	**argv);

extern int bu_tcl_printb(ClientData	clientData,
			 Tcl_Interp	*interp,
			 int		argc,
			 char		**argv);

extern int bu_get_value_by_keyword(ClientData	clientData,
				   Tcl_Interp	*interp,
				   int		argc,
				   char		**argv);

extern int bu_get_all_keyword_values(ClientData	clientData,
				     Tcl_Interp	*interp,
				     int		argc,
				     char		**argv);

extern int bu_tcl_rgb_to_hsv(ClientData	clientData,
			     Tcl_Interp	*interp,
			     int		argc,
			     char		**argv);

extern int bu_tcl_hsv_to_rgb(ClientData	clientData,
			     Tcl_Interp	*interp,
			     int		argc,
			     char		**argv);

extern int bu_tcl_key_eq_to_key_val(ClientData	clientData,
				    Tcl_Interp	*interp,
				    int		argc,
				    char		**argv);

extern int bu_tcl_shader_to_key_val(ClientData	clientData,
				    Tcl_Interp	*interp,
				    int		argc,
				    char		**argv);

extern int bu_tcl_key_val_to_key_eq(ClientData	clientData,
				    Tcl_Interp	*interp,
				    int		argc,
				    char		**argv);

extern int bu_tcl_shader_to_key_eq(ClientData	clientData,
				   Tcl_Interp	*interp,
				   int		argc,
				   char		**argv);

extern int bu_tcl_brlcad_path(ClientData	clientData,
			      Tcl_Interp	*interp,
			      int		 argc,
			      char		**argv);

extern int bu_tcl_units_conversion(ClientData	clientData,
				   Tcl_Interp	*interp,
				   int		argc,
				   char		**argv);

extern void bu_tcl_setup(Tcl_Interp *interp);

extern int Bu_Init(Tcl_Interp *interp);

/* lex.c */
#define BU_LEX_ANY	0	/* pseudo type */
struct bu_lex_t_int {
	int type;
	int value;
};
#define BU_LEX_INT	1
struct bu_lex_t_dbl {
	int	type;
	double	value;
};
#define BU_LEX_DOUBLE	2
struct bu_lex_t_key {
	int	type;
	int	value;
};
#define BU_LEX_SYMBOL	3
#define BU_LEX_KEYWORD	4
struct bu_lex_t_id {
	int	type;
	char 	*value;
};
#define BU_LEX_IDENT	5
#define BU_LEX_NUMBER	6	/* Pseudo type */
union bu_lex_token {
	int			type;
	struct	bu_lex_t_int	t_int;
	struct	bu_lex_t_dbl	t_dbl;
	struct	bu_lex_t_key	t_key;
	struct	bu_lex_t_id	t_id;
};
struct bu_lex_key {
	int	tok_val;
	char	*string;
};
#define BU_LEX_NEED_MORE	0

int bu_lex(
	union bu_lex_token *token,
	struct bu_vls *rtstr,
	struct bu_lex_key *keywords,
	struct bu_lex_key *symbols);


/* mro.c */
void bu_mro_init_with_string( struct bu_mro *mrop, const char *string );
void bu_mro_set( struct bu_mro *mrop, const char *string );
void bu_mro_init( struct bu_mro *mrop );
void bu_mro_free( struct bu_mro *mrop );


/* hash.c */
struct bu_hash_entry {
	long magic;
	unsigned char *key;
	unsigned char *value;
	int key_len;
	struct bu_hash_entry *next;
};

struct bu_hash_tbl {
	long magic;
	unsigned long mask;
	unsigned long num_lists;
	unsigned long num_entries;
	struct bu_hash_entry **lists;
};

struct bu_hash_record {
	long magic;
	struct bu_hash_tbl *tbl;
	unsigned long index;
	struct bu_hash_entry *hsh_entry;
};

#define BU_HASH_TBL_MAGIC	0x48415348	/* "HASH" */
#define BU_HASH_RECORD_MAGIC	0x68617368	/* "hash" */
#define BU_HASH_ENTRY_MAGIC	0x48454E54	/* "HENT" */
#define BU_CK_HASH_TBL(_hp)	BU_CKMAG( _hp, BU_HASH_TBL_MAGIC, "bu_hash_tbl" )
#define BU_CK_HASH_RECORD(_rp)	BU_CKMAG( _rp, BU_HASH_RECORD_MAGIC, "bu_hash_record" )
#define BU_CK_HASH_ENTRY(_ep)	BU_CKMAG( _ep, BU_HASH_ENTRY_MAGIC, "bu_hash_entry" )

unsigned long bu_hash(unsigned char *str, int len);
struct bu_hash_tbl *bu_create_hash_tbl( unsigned long tbl_size );
struct bu_hash_entry *bu_find_hash_entry( struct bu_hash_tbl *hsh_tbl,
					  unsigned char *key,
					  int key_len,
					  struct bu_hash_entry **prev,
					  unsigned long *index2 );
void bu_set_hash_value( struct bu_hash_entry *hsh_entry, unsigned char *value );
unsigned char *bu_get_hash_value( struct bu_hash_entry *hsh_entry );
struct bu_hash_entry *bu_hash_add_entry( struct bu_hash_tbl *hsh_tbl, unsigned char *key, int key_len, int *new_entry );
void bu_hash_tbl_pr( struct bu_hash_tbl *hsh_tbl, char *str );
void bu_hash_tbl_free( struct bu_hash_tbl *hsh_tbl );
struct bu_hash_entry *bu_hash_tbl_first( struct bu_hash_tbl *hsh_tbl, struct bu_hash_record *rec );
struct bu_hash_entry *bu_hash_tbl_next( struct bu_hash_record *rec );


#ifdef __cplusplus
}
#endif
#endif /* SEEN_BU_H */
@


1.144
log
@change conf.h to a wrapped config.h
@
text
@d40 1
a40 1
 *  $Header: /cvs/brlcad/h/bu.h,v 1.143 2004/04/05 09:31:17 morrison Exp $
d59 1
a59 1
#define BU_H_VERSION	"@@(#)$Header: /cvs/brlcad/h/bu.h,v 1.143 2004/04/05 09:31:17 morrison Exp $ (BRL)"
@


1.143
log
@merge of ansi-6-0-branch into HEAD
@
text
@d40 1
a40 1
 *  $Header$
d46 4
d59 1
a59 1
#define BU_H_VERSION	"@@(#)$Header$ (BRL)"
@


1.142
log
@autoconf merge
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.139.6.6 2004/03/16 13:00:07 erikg Exp $
d45 4
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.139.6.6 2004/03/16 13:00:07 erikg Exp $ (BRL)"
d181 2
a182 2
	    *((long *)(_ptr)) != (_magic) )  { \
		bu_badmagic( (long *)(_ptr), _magic, _str, __FILE__, __LINE__ ); \
d187 1
a187 1
		bu_badmagic_tcl( (_interp), (long *)(_ptr), _magic, _str, __FILE__, __LINE__ ); \
d312 1
a312 1
extern int bu_cv_w_cookie(genptr_t, int, int, genptr_t, int, int);
d314 8
a321 8
extern int bu_cv_ntohss(signed short *, int, genptr_t, int);
extern int bu_cv_ntohus(unsigned short *, int, genptr_t, int);
extern int bu_cv_ntohsl(signed long int *, int, genptr_t, int);
extern int bu_cv_ntohul(unsigned long int *, int, genptr_t, int);
extern int bu_cv_htonss(genptr_t, int, signed short *, int);
extern int bu_cv_htonus(genptr_t, int, unsigned short *, int);
extern int bu_cv_htonsl(genptr_t, int, long *, int);
extern int bu_cv_htonul(genptr_t, int, unsigned long *, int);
d417 1
a417 1
struct bu_list *bu_list_new();
d1485 1
a1485 1
BU_EXTERN(void			bu_badmagic, (const long *ptr, long magic,
d1489 1
a1489 1
BU_EXTERN(struct bu_bitv *	bu_bitv_new, (int nbits));
d1531 1
a1531 1
BU_EXTERN(int bu_cv_w_cookie, (genptr_t out, int outcookie, int size,
d1559 1
a1559 1
				fastf_t min, fastf_t max, int nbins));
d1674 1
a1674 1
				char *base));
d1676 2
a1677 2
				const struct bu_structparse	*parsetab,
				const char			*base));
d1841 1
a1841 1
BU_EXTERN(void			bu_vls_extend, (struct bu_vls *vp, int extra) );
d1928 94
a2021 20
extern void bu_badmagic_tcl();
extern void bu_structparse_get_terse_form();
extern int bu_structparse_argv();
extern int bu_tcl_mem_barriercheck();
extern int bu_tcl_ck_malloc_ptr();
extern int bu_tcl_malloc_len_roundup();
extern int bu_tcl_prmem();
extern int bu_tcl_printb();
extern int bu_get_value_by_keyword();
extern int bu_get_all_keyword_values();
extern int bu_tcl_rgb_to_hsv();
extern int bu_tcl_hsv_to_rgb();
extern int bu_tcl_key_eq_to_key_val();
extern int bu_tcl_shader_to_key_val();
extern int bu_tcl_key_val_to_key_eq();
extern int bu_tcl_shader_to_key_eq();
extern int bu_tcl_brlcad_path();
extern int bu_tcl_units_conversion();
extern void bu_tcl_setup();
extern int Bu_Init();
d2073 1
d2111 1
a2111 1
					  unsigned long *index );
@


1.141
log
@quell warnings where undefined preprocessor symbols are used as values
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.140 2003/12/09 15:00:25 jra Exp $
d51 9
a59 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.140 2003/12/09 15:00:25 jra Exp $ (BRL)"
@


1.140
log
@Added macro: BU_MRO_STRLEN
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.139 2002/11/11 01:18:45 jra Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.139 2002/11/11 01:18:45 jra Exp $ (BRL)"
d108 1
a108 1
#if CRAY
d1146 1
a1146 1
#if CRAY
d1149 1
a1149 1
#  if IRIX > 5 && _MIPS_SIM != _MIPS_SIM_ABI32
d1152 1
a1152 1
#    if sgi || __convexc__ || ultrix || _HPUX_SOURCE
@


1.139
log
@Changed declaration of bu_hash_add_entry() to eliminate "new" (clashed with keyword for C++)
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.138 2002/10/11 08:30:56 kermit Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.138 2002/10/11 08:30:56 kermit Exp $ (BRL)"
d1081 2
@


1.139.6.1
log
@sync from head
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.140 2003/12/09 15:00:25 jra Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.140 2003/12/09 15:00:25 jra Exp $ (BRL)"
a1080 2

#define BU_MRO_STRLEN( _p ) bu_vls_strlen( &_p->string_rep )
@


1.139.6.2
log
@include sys/types.h if it's available
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.139.6.1 2003/12/17 15:35:29 erikg Exp $
a48 4
#ifdef HAVE_SYS_TYPES_H
# include <sys/types.h>
#endif

d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.139.6.1 2003/12/17 15:35:29 erikg Exp $ (BRL)"
@


1.139.6.3
log
@merge from HEAD
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.140 2003/12/09 15:00:25 jra Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.140 2003/12/09 15:00:25 jra Exp $ (BRL)"
@


1.139.6.4
log
@merge from head
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.141 2004/03/03 19:38:22 morrison Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.141 2004/03/03 19:38:22 morrison Exp $ (BRL)"
d112 1
a112 1
#if defined(CRAY)
d1150 1
a1150 1
#if defined(CRAY)
d1153 1
a1153 1
#  if defined(IRIX) && IRIX > 5 && _MIPS_SIM != _MIPS_SIM_ABI32
d1156 1
a1156 1
#    if defined(sgi) || defined(__convexc__) || defined(ultrix) || defined(_HPUX_SOURCE)
@


1.139.6.5
log
@merge from head
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.139.6.4 2004/03/10 13:24:59 erikg Exp $
d49 4
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.139.6.4 2004/03/10 13:24:59 erikg Exp $ (BRL)"
@


1.139.6.6
log
@fbsd/irix fixes
@
text
@d40 1
a40 1
 *  $Header$
d51 1
a51 9
#define BU_H_VERSION	"@@(#)$Header$ (BRL)"

#ifdef HAVE_TIME_H
# include <time.h>
#endif

#ifdef HAVE_SYS_TIME_H
# include <sys/time.h>
#endif
@


1.138
log
@Added initial support for IBM SP "Scalable Parallel" system running AIX.
Static build fully functional, still needs more work on shared build.
OpenGL support works, but there are issues communicatiing with mged.
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.137 2002/10/01 13:52:32 jra Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.137 2002/10/01 13:52:32 jra Exp $ (BRL)"
d2025 1
a2025 1
struct bu_hash_entry *bu_hash_add_entry( struct bu_hash_tbl *hsh_tbl, unsigned char *key, int key_len, int *new );
@


1.137
log
@Added support for hash tables
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.136 2002/08/20 17:07:29 jra Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.136 2002/08/20 17:07:29 jra Exp $ (BRL)"
d1595 1
a1595 1
#if __STDC__
@


1.136
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.134 2002/02/22 16:07:34 jra Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.134 2002/02/22 16:07:34 jra Exp $ (BRL)"
d1984 47
@


1.136.4.1
log
@sync to HEAD...
@
text
@d40 1
a40 1
 *  $Header: /n/cad/c/CVS/brlcad/h/bu.h,v 1.141 2004/03/03 19:38:22 morrison Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /n/cad/c/CVS/brlcad/h/bu.h,v 1.141 2004/03/03 19:38:22 morrison Exp $ (BRL)"
d108 1
a108 1
#if defined(CRAY)
a1081 2
#define BU_MRO_STRLEN( _p ) bu_vls_strlen( &_p->string_rep )

d1144 1
a1144 1
#if defined(CRAY)
d1147 1
a1147 1
#  if defined(IRIX) && IRIX > 5 && _MIPS_SIM != _MIPS_SIM_ABI32
d1150 1
a1150 1
#    if defined(sgi) || defined(__convexc__) || defined(ultrix) || defined(_HPUX_SOURCE)
d1595 1
a1595 1
#if defined(HAVE_STDARG_H)
a1983 47

/* hash.c */
struct bu_hash_entry {
	long magic;
	unsigned char *key;
	unsigned char *value;
	int key_len;
	struct bu_hash_entry *next;
};

struct bu_hash_tbl {
	long magic;
	unsigned long mask;
	unsigned long num_lists;
	unsigned long num_entries;
	struct bu_hash_entry **lists;
};

struct bu_hash_record {
	long magic;
	struct bu_hash_tbl *tbl;
	unsigned long index;
	struct bu_hash_entry *hsh_entry;
};

#define BU_HASH_TBL_MAGIC	0x48415348	/* "HASH" */
#define BU_HASH_RECORD_MAGIC	0x68617368	/* "hash" */
#define BU_HASH_ENTRY_MAGIC	0x48454E54	/* "HENT" */
#define BU_CK_HASH_TBL(_hp)	BU_CKMAG( _hp, BU_HASH_TBL_MAGIC, "bu_hash_tbl" )
#define BU_CK_HASH_RECORD(_rp)	BU_CKMAG( _rp, BU_HASH_RECORD_MAGIC, "bu_hash_record" )
#define BU_CK_HASH_ENTRY(_ep)	BU_CKMAG( _ep, BU_HASH_ENTRY_MAGIC, "bu_hash_entry" )

unsigned long bu_hash(unsigned char *str, int len);
struct bu_hash_tbl *bu_create_hash_tbl( unsigned long tbl_size );
struct bu_hash_entry *bu_find_hash_entry( struct bu_hash_tbl *hsh_tbl,
					  unsigned char *key,
					  int key_len,
					  struct bu_hash_entry **prev,
					  unsigned long *index );
void bu_set_hash_value( struct bu_hash_entry *hsh_entry, unsigned char *value );
unsigned char *bu_get_hash_value( struct bu_hash_entry *hsh_entry );
struct bu_hash_entry *bu_hash_add_entry( struct bu_hash_tbl *hsh_tbl, unsigned char *key, int key_len, int *new_entry );
void bu_hash_tbl_pr( struct bu_hash_tbl *hsh_tbl, char *str );
void bu_hash_tbl_free( struct bu_hash_tbl *hsh_tbl );
struct bu_hash_entry *bu_hash_tbl_first( struct bu_hash_tbl *hsh_tbl, struct bu_hash_record *rec );
struct bu_hash_entry *bu_hash_tbl_next( struct bu_hash_record *rec );

@


1.136.2.1
log
@Initial ANSIfication
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.136 2002/08/20 17:07:29 jra Exp $
a44 4

/* Included for Tcl_Interp definition */
#include "tcl.h"

d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.136 2002/08/20 17:07:29 jra Exp $ (BRL)"
d405 1
a405 1
struct bu_list *bu_list_new(void);
d1914 20
a1933 94
extern void bu_badmagic_tcl(Tcl_Interp	*interp,
			    const long	*ptr,
			    long	magic,
			    const char	*str,
			    const char	*file,
			    int		line);

extern void bu_structparse_get_terse_form(Tcl_Interp	*interp,
					  register struct bu_structparse *sp);

extern int bu_structparse_argv(Tcl_Interp			*interp,
			       int				argc,
			       char				**argv,
			       const struct bu_structparse	*desc,
			       char				*base);

extern int bu_tcl_mem_barriercheck(ClientData	clientData,
				   Tcl_Interp	*interp,
				   int		argc,
				   char		**argv);

extern int bu_tcl_ck_malloc_ptr(ClientData		clientData,
				Tcl_Interp		*interp,
				int		argc,
				char		**argv);

extern int bu_tcl_malloc_len_roundup(ClientData	clientData,
				     Tcl_Interp	*interp,
				     int		argc,
				     char		**argv);

extern int bu_tcl_prmem(ClientData	clientData,
			Tcl_Interp	*interp,
			int	argc,
			char	**argv);

extern int bu_tcl_printb(ClientData	clientData,
			 Tcl_Interp	*interp,
			 int		argc,
			 char		**argv);

extern int bu_get_value_by_keyword(ClientData	clientData,
				   Tcl_Interp	*interp,
				   int		argc,
				   char		**argv);

extern int bu_get_all_keyword_values(ClientData	clientData,
				     Tcl_Interp	*interp,
				     int		argc,
				     char		**argv);

extern int bu_tcl_rgb_to_hsv(ClientData	clientData,
			     Tcl_Interp	*interp,
			     int		argc,
			     char		**argv);

extern int bu_tcl_hsv_to_rgb(ClientData	clientData,
			     Tcl_Interp	*interp,
			     int		argc,
			     char		**argv);

extern int bu_tcl_key_eq_to_key_val(ClientData	clientData,
				    Tcl_Interp	*interp,
				    int		argc,
				    char		**argv);

extern int bu_tcl_shader_to_key_val(ClientData	clientData,
				    Tcl_Interp	*interp,
				    int		argc,
				    char		**argv);

extern int bu_tcl_key_val_to_key_eq(ClientData	clientData,
				    Tcl_Interp	*interp,
				    int		argc,
				    char		**argv);

extern int bu_tcl_shader_to_key_eq(ClientData	clientData,
				   Tcl_Interp	*interp,
				   int		argc,
				   char		**argv);

extern int bu_tcl_brlcad_path(ClientData	clientData,
			      Tcl_Interp	*interp,
			      int		 argc,
			      char		**argv);

extern int bu_tcl_units_conversion(ClientData	clientData,
				   Tcl_Interp	*interp,
				   int		argc,
				   char		**argv);

extern void bu_tcl_setup(Tcl_Interp *interp);

extern int Bu_Init(Tcl_Interp *interp);
@


1.136.2.2
log
@sync branch with HEAD
@
text
@d40 1
a40 1
 *  $Header$
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header$ (BRL)"
d112 1
a112 1
#if defined(CRAY)
a1085 2
#define BU_MRO_STRLEN( _p ) bu_vls_strlen( &_p->string_rep )

d1148 1
a1148 1
#if defined(CRAY)
d1151 1
a1151 1
#  if defined(IRIX) && IRIX > 5 && _MIPS_SIM != _MIPS_SIM_ABI32
d1154 1
a1154 1
#    if defined(sgi) || defined(__convexc__) || defined(ultrix) || defined(_HPUX_SOURCE)
d1599 1
a1599 1
#if defined(HAVE_STDARG_H)
a2061 47

/* hash.c */
struct bu_hash_entry {
	long magic;
	unsigned char *key;
	unsigned char *value;
	int key_len;
	struct bu_hash_entry *next;
};

struct bu_hash_tbl {
	long magic;
	unsigned long mask;
	unsigned long num_lists;
	unsigned long num_entries;
	struct bu_hash_entry **lists;
};

struct bu_hash_record {
	long magic;
	struct bu_hash_tbl *tbl;
	unsigned long index;
	struct bu_hash_entry *hsh_entry;
};

#define BU_HASH_TBL_MAGIC	0x48415348	/* "HASH" */
#define BU_HASH_RECORD_MAGIC	0x68617368	/* "hash" */
#define BU_HASH_ENTRY_MAGIC	0x48454E54	/* "HENT" */
#define BU_CK_HASH_TBL(_hp)	BU_CKMAG( _hp, BU_HASH_TBL_MAGIC, "bu_hash_tbl" )
#define BU_CK_HASH_RECORD(_rp)	BU_CKMAG( _rp, BU_HASH_RECORD_MAGIC, "bu_hash_record" )
#define BU_CK_HASH_ENTRY(_ep)	BU_CKMAG( _ep, BU_HASH_ENTRY_MAGIC, "bu_hash_entry" )

unsigned long bu_hash(unsigned char *str, int len);
struct bu_hash_tbl *bu_create_hash_tbl( unsigned long tbl_size );
struct bu_hash_entry *bu_find_hash_entry( struct bu_hash_tbl *hsh_tbl,
					  unsigned char *key,
					  int key_len,
					  struct bu_hash_entry **prev,
					  unsigned long *index );
void bu_set_hash_value( struct bu_hash_entry *hsh_entry, unsigned char *value );
unsigned char *bu_get_hash_value( struct bu_hash_entry *hsh_entry );
struct bu_hash_entry *bu_hash_add_entry( struct bu_hash_tbl *hsh_tbl, unsigned char *key, int key_len, int *new_entry );
void bu_hash_tbl_pr( struct bu_hash_tbl *hsh_tbl, char *str );
void bu_hash_tbl_free( struct bu_hash_tbl *hsh_tbl );
struct bu_hash_entry *bu_hash_tbl_first( struct bu_hash_tbl *hsh_tbl, struct bu_hash_record *rec );
struct bu_hash_entry *bu_hash_tbl_next( struct bu_hash_record *rec );

@


1.136.2.3
log
@make struct parse base const
@
text
@d1666 1
a1666 1
				const char *base));
d1668 2
a1669 2
				const struct bu_structparse *parsetab,
				const char *base));
@


1.136.2.4
log
@quell warning
@
text
@d40 1
a40 1
 *  $Header: /n/cad/c/CVS/brlcad/h/bu.h,v 1.136.2.3 2004/04/02 15:59:14 morrison Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /n/cad/c/CVS/brlcad/h/bu.h,v 1.136.2.3 2004/04/02 15:59:14 morrison Exp $ (BRL)"
d2102 1
a2102 1
					  unsigned long *index2 );
@


1.136.2.5
log
@more quelling of lots of warnings
@
text
@d40 1
a40 1
 *  $Header: /n/cad/c/CVS/brlcad/h/bu.h,v 1.136.2.4 2004/04/04 20:46:09 morrison Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /n/cad/c/CVS/brlcad/h/bu.h,v 1.136.2.4 2004/04/04 20:46:09 morrison Exp $ (BRL)"
d173 2
a174 2
	    *((unsigned long *)(_ptr)) != (unsigned long)(_magic) )  { \
		bu_badmagic( (long *)(_ptr), (unsigned long)_magic, _str, __FILE__, __LINE__ ); \
d179 1
a179 1
		bu_badmagic_tcl( (_interp), (long *)(_ptr), (unsigned long)_magic, _str, __FILE__, __LINE__ ); \
d304 1
a304 1
extern int bu_cv_w_cookie(genptr_t, int, size_t, genptr_t, int, int);
d306 8
a313 8
extern int bu_cv_ntohss(signed short *, size_t, genptr_t, int);
extern int bu_cv_ntohus(unsigned short *, size_t, genptr_t, int);
extern int bu_cv_ntohsl(signed long int *, size_t, genptr_t, int);
extern int bu_cv_ntohul(unsigned long int *, size_t, genptr_t, int);
extern int bu_cv_htonss(genptr_t, size_t, signed short *, int);
extern int bu_cv_htonus(genptr_t, size_t, unsigned short *, int);
extern int bu_cv_htonsl(genptr_t, size_t, long *, int);
extern int bu_cv_htonul(genptr_t, size_t, unsigned long *, int);
d1477 1
a1477 1
BU_EXTERN(void			bu_badmagic, (const long *ptr, unsigned long magic,
d1481 1
a1481 1
BU_EXTERN(struct bu_bitv *	bu_bitv_new, (unsigned int nbits));
d1523 1
a1523 1
BU_EXTERN(int bu_cv_w_cookie, (genptr_t out, int outcookie, size_t size,
d1551 1
a1551 1
				fastf_t min, fastf_t max, unsigned int nbins));
d1833 1
a1833 1
BU_EXTERN(void			bu_vls_extend, (struct bu_vls *vp, unsigned int extra) );
d1922 1
a1922 1
			    unsigned long	magic,
@


1.135
log
@Converted from K&R to ANSI C - RFH
@
text
@a44 4

/* Included for Tcl_Interp definition */
#include "tcl.h"

d405 1
a405 1
struct bu_list *bu_list_new(void);
d1914 20
a1933 94
extern void bu_badmagic_tcl(Tcl_Interp	*interp,
			    const long	*ptr,
			    long	magic,
			    const char	*str,
			    const char	*file,
			    int		line);

extern void bu_structparse_get_terse_form(Tcl_Interp	*interp,
					  register struct bu_structparse *sp);

extern int bu_structparse_argv(Tcl_Interp			*interp,
			       int				argc,
			       char				**argv,
			       const struct bu_structparse	*desc,
			       char				*base);

extern int bu_tcl_mem_barriercheck(ClientData	clientData,
				   Tcl_Interp	*interp,
				   int		argc,
				   char		**argv);

extern int bu_tcl_ck_malloc_ptr(ClientData		clientData,
				Tcl_Interp		*interp,
				int		argc,
				char		**argv);

extern int bu_tcl_malloc_len_roundup(ClientData	clientData,
				     Tcl_Interp	*interp,
				     int		argc,
				     char		**argv);

extern int bu_tcl_prmem(ClientData	clientData,
			Tcl_Interp	*interp,
			int	argc,
			char	**argv);

extern int bu_tcl_printb(ClientData	clientData,
			 Tcl_Interp	*interp,
			 int		argc,
			 char		**argv);

extern int bu_get_value_by_keyword(ClientData	clientData,
				   Tcl_Interp	*interp,
				   int		argc,
				   char		**argv);

extern int bu_get_all_keyword_values(ClientData	clientData,
				     Tcl_Interp	*interp,
				     int		argc,
				     char		**argv);

extern int bu_tcl_rgb_to_hsv(ClientData	clientData,
			     Tcl_Interp	*interp,
			     int		argc,
			     char		**argv);

extern int bu_tcl_hsv_to_rgb(ClientData	clientData,
			     Tcl_Interp	*interp,
			     int		argc,
			     char		**argv);

extern int bu_tcl_key_eq_to_key_val(ClientData	clientData,
				    Tcl_Interp	*interp,
				    int		argc,
				    char		**argv);

extern int bu_tcl_shader_to_key_val(ClientData	clientData,
				    Tcl_Interp	*interp,
				    int		argc,
				    char		**argv);

extern int bu_tcl_key_val_to_key_eq(ClientData	clientData,
				    Tcl_Interp	*interp,
				    int		argc,
				    char		**argv);

extern int bu_tcl_shader_to_key_eq(ClientData	clientData,
				   Tcl_Interp	*interp,
				   int		argc,
				   char		**argv);

extern int bu_tcl_brlcad_path(ClientData	clientData,
			      Tcl_Interp	*interp,
			      int		 argc,
			      char		**argv);

extern int bu_tcl_units_conversion(ClientData	clientData,
				   Tcl_Interp	*interp,
				   int		argc,
				   char		**argv);

extern void bu_tcl_setup(Tcl_Interp *interp);

extern int Bu_Init(Tcl_Interp *interp);
@


1.134
log
@Added bu_avs_add_nonunique()
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.133 2002/02/17 03:03:04 jra Exp $
d45 4
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.133 2002/02/17 03:03:04 jra Exp $ (BRL)"
d409 1
a409 1
struct bu_list *bu_list_new();
d1918 94
a2011 20
extern void bu_badmagic_tcl();
extern void bu_structparse_get_terse_form();
extern int bu_structparse_argv();
extern int bu_tcl_mem_barriercheck();
extern int bu_tcl_ck_malloc_ptr();
extern int bu_tcl_malloc_len_roundup();
extern int bu_tcl_prmem();
extern int bu_tcl_printb();
extern int bu_get_value_by_keyword();
extern int bu_get_all_keyword_values();
extern int bu_tcl_rgb_to_hsv();
extern int bu_tcl_hsv_to_rgb();
extern int bu_tcl_key_eq_to_key_val();
extern int bu_tcl_shader_to_key_val();
extern int bu_tcl_key_val_to_key_eq();
extern int bu_tcl_shader_to_key_eq();
extern int bu_tcl_brlcad_path();
extern int bu_tcl_units_conversion();
extern void bu_tcl_setup();
extern int Bu_Init();
@


1.133
log
@Moved definition of struct bu_cmdtab from cmd.h to bu.h to eliminate compiler
warnings
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.132 2001/10/15 17:54:38 butler Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.132 2001/10/15 17:54:38 butler Exp $ (BRL)"
d1468 1
@


1.132
log
@added extern for bu_fopen_uniq()
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.131 2001/10/15 15:35:00 butler Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.131 2001/10/15 15:35:00 butler Exp $ (BRL)"
d1429 9
@


1.131
log
@A more correct implementation of BU_FLSTR
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.130 2001/10/11 21:25:10 butler Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.130 2001/10/11 21:25:10 butler Exp $ (BRL)"
d1520 4
@


1.130
log
@Added macro BU_QFLSTR
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.129 2001/10/11 20:44:04 butler Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.129 2001/10/11 20:44:04 butler Exp $ (BRL)"
d71 2
a72 2
 * Macro for getting a concatenated string of the current file and line number
 * produces something of the form:
d79 1
a79 1
#define BU_FLSTR __FILE__ ## ":" ## bu_cpp_xstr(__LINE__)
@


1.129
log
@Added BU_FLSTR and support macros
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.128 2001/08/10 15:38:47 jra Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.128 2001/08/10 15:38:47 jra Exp $ (BRL)"
d80 1
a80 1

@


1.128
log
@Added BU_LIST_DQ and BU_LIST_DQ_T for MUVES
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.125 2001/08/07 14:39:02 jra Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.125 2001/08/07 14:39:02 jra Exp $ (BRL)"
d69 12
@


1.127
log
@More mods for MUVES
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.126 2001/08/09 19:38:25 rbowers Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.126 2001/08/09 19:38:25 rbowers Exp $ (BRL)"
d434 10
d466 7
a472 7
	    if( BU_LIST_NON_EMPTY(hp))				\
	    {							\
	        (p) = ((struct structure *)((hp)->forw));	\
	        BU_LIST_DEQUEUE((struct bu_list *)(p));		\
	    }							\
	    else						\
	     (p) = (struct structure *) 0;			\
a473 1

@


1.126
log
@-* wrapped the BU_LIST_POP macro in braces
CaVS: ----------------------------------------------------------------------
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.125 2001/08/07 14:39:02 jra Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.125 2001/08/07 14:39:02 jra Exp $ (BRL)"
d393 3
d401 1
a401 1
	BU_LIST_FREE( (hp) ); \
d437 2
a438 1
#define BU_LIST_DEQUEUE_T( cur, type ) ((cur)->forw->back = (cur)->back, \
d441 1
a441 1
	(type *)cur )
d455 2
a456 2
	{ 							\
	    if BU_LIST_NON_EMPTY(hp))				\
d461 1
a461 1
	    else {						\
a462 1
	    }							\
d465 1
d467 1
a467 1
	((type *)bu_list_pop( hp )
d554 1
a554 1
	 for( (p)=((type) *)BU_LIST_FIRST(bu_list,hp); \
d556 1
a556 1
	      (p)=((type) *)BU_LIST_PNEXT(bu_list,p) ) \
d559 1
a559 1
	 for( (p)=((type) *)BU_LIST_LAST(bu_list,hp); \
d561 1
a561 1
	      (p)=((type) *)BU_LIST_PPREV(bu_list,(p)) ) \
d564 1
a564 1
	 for( (p)=((type) *)start ; \
d566 1
a566 1
	      (p)=((type) *)BU_LIST_PNEXT(bu_list,(p)) )
@


1.125
log
@More mods for MUVES Dq Package
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.124 2001/08/06 21:23:50 jra Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.124 2001/08/06 21:23:50 jra Exp $ (BRL)"
d451 10
a460 7
	if (BU_LIST_NON_EMPTY(hp))				\
	{							\
	    (p) = ((struct structure *)((hp)->forw));		\
	    BU_LIST_DEQUEUE((struct bu_list *)(p));		\
	}							\
	else							\
	     (p) = (struct structure *) 0
@


1.124
log
@Added BU_LIST_DEQUEUE_T macro
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.123 2001/08/06 20:48:35 jra Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.123 2001/08/06 20:48:35 jra Exp $ (BRL)"
d459 2
a460 8
#define BU_LIST_POP_T(type, hp, p )				\
	if (BU_LIST_NON_EMPTY(hp))				\
	{							\
	    (p) = ((type *)((hp)->forw));		\
	    BU_LIST_DEQUEUE((struct bu_list *)(p));		\
	}							\
	else							\
	     (p) = (type *) 0
d545 15
@


1.123
log
@Changes to support replacement of MUVES Dq package
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.122 2001/07/20 18:47:55 rbowers Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.122 2001/07/20 18:47:55 rbowers Exp $ (BRL)"
d430 9
@


1.122
log
@*- added BU_GETTYPE macro. It is a BU_GETSTRUCT for typedef'ed objects.
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.121 2001/06/14 15:04:39 bparker Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.121 2001/06/14 15:04:39 bparker Exp $ (BRL)"
d391 11
d449 10
@


1.121
log
@*- declare bu_vls_struct_print2
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.120 2001/05/16 21:37:43 morrison Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.120 2001/05/16 21:37:43 morrison Exp $ (BRL)"
d127 16
@


1.120
log
@PRODUCTION optimizations
included a section in conf.h that controls how most optimization settings are used
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.119 2001/05/08 20:28:06 jra Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.119 2001/05/08 20:28:06 jra Exp $ (BRL)"
d1570 4
@


1.119
log
@Added declaration of bu_avs_init_empty()
BU_MRO_INVALIDATE now only adjusts flags
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.118 2001/05/08 20:04:50 jra Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.118 2001/05/08 20:04:50 jra Exp $ (BRL)"
d117 1
a117 1
# define BU_GETSTRUCT(_p,_str) \
d119 1
a119 1
# define BU_GETUNION(_p,_unn) \
d122 1
a122 1
# define BU_GETSTRUCT(_p,_str) \
d124 1
a124 1
# define BU_GETUNION(_p,_unn) \
d135 5
a139 1
#define BU_CKMAG(_ptr, _magic, _str)	\
d144 1
a144 1
#define BU_CKMAG_TCL(_interp, _ptr, _magic, _str)	\
d150 1
d160 5
a164 2
#ifdef __STDC__
#define BU_ASSERT(_equation)	\
d170 2
a171 2
#else
#define BU_ASSERT(_equation)	\
d177 1
d180 5
a184 2
#ifdef __STDC__
#define BU_ASSERT_PTR(_lhs,_relation,_rhs)	\
d191 2
a192 2
#else
#define BU_ASSERT_PTR(_lhs,_relation,_rhs)	\
d199 1
d202 6
a207 2
#ifdef __STDC__
#define BU_ASSERT_LONG(_lhs,_relation,_rhs)	\
d214 2
a215 2
#else
#define BU_ASSERT_LONG(_lhs,_relation,_rhs)	\
d222 1
d225 6
a230 2
#ifdef __STDC__
#define BU_ASSERT_DOUBLE(_lhs,_relation,_rhs)	\
d237 2
a238 2
#else
#define BU_ASSERT_DOUBLE(_lhs,_relation,_rhs)	\
d245 1
d642 1
d644 14
a657 1
	(((_bv)->bits[(bit)>>BITV_SHIFT] & (((bitv_t)1)<<((bit)&BITV_MASK)))?1:0)
d663 1
a663 1
	{ bzero( (char *)((_bv)->bits), BU_BITS2BYTES( (_bv)->nbits ) ); }
d666 4
a669 1
#define BU_BITV_BITNUM_CHECK(_bv,_bit)	/* Validate bit number */ \
d675 1
d677 4
a680 1
#define BU_BITV_NBITS_CHECK(_bv,_nbits)	/* Validate number of bits */ \
d686 1
@


1.118
log
@Added support for MRO's (Multiply Represented Objects)
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.117 2001/04/05 19:35:06 morrison Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.117 2001/04/05 19:35:06 morrison Exp $ (BRL)"
a940 1
	_p->long_rep = 0;\
a941 1
	_p->double_rep = 0.0;\
d1315 1
@


1.117
log
@updated SIGNED to signed
updated CONST to const
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.116 2001/03/23 22:33:45 butler Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.116 2001/03/23 22:33:45 butler Exp $ (BRL)"
d873 10
d921 35
d1325 1
a1325 1
				struct bu_attribute_value_set *src );
d1833 6
@


1.116
log
@Changes to support new DSP primitive representation
@
text
@d40 1
a40 1
 *  $Header: /n/tgm/d/CVS/brlcad/h/bu.h,v 1.115 2001/03/21 21:56:17 bparker Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /n/tgm/d/CVS/brlcad/h/bu.h,v 1.115 2001/03/21 21:56:17 bparker Exp $ (BRL)"
d251 1
a251 1
extern int bu_cv_ntohss(SIGNED short *, int, genptr_t, int);
d253 1
a253 1
extern int bu_cv_ntohsl(SIGNED long int *, int, genptr_t, int);
d255 1
a255 1
extern int bu_cv_htonss(genptr_t, int, SIGNED short *, int);
d1271 2
a1272 2
				int len, CONST char *str));
BU_EXTERN(struct bu_attribute_value_set	*bu_avs_new, (int len, CONST char *str));
d1274 2
a1275 2
				CONST char *attribute,
				CONST char *value));
d1284 1
a1284 1
				CONST char *attribute));
d1289 2
a1290 2
BU_EXTERN(void			bu_badmagic, (CONST long *ptr, long magic,
				CONST char *str, CONST char *file, int line));
d1296 1
a1296 1
				CONST struct bu_bitv *iv));
d1298 1
a1298 1
				CONST struct bu_bitv *iv));
d1300 3
a1302 3
				CONST struct bu_bitv *bv));
BU_EXTERN(void			bu_pr_bitv, (CONST char *str,
				CONST struct bu_bitv *bv));
d1304 3
a1306 3
				CONST struct bu_bitv *bv));
BU_EXTERN( struct bu_bitv *	bu_hex_to_bitv, (CONST char *str));
BU_EXTERN( struct bu_bitv *	bu_bitv_dup, (CONST struct bu_bitv *bv));
d1310 1
a1310 1
BU_EXTERN(void			bu_bomb, (CONST char *str) );
d1345 2
a1346 2
BU_EXTERN(int			bu_file_exists, (CONST char *path) );
BU_EXTERN(char			*bu_brlcad_path, (CONST char *rhs) );
d1353 2
a1354 2
BU_EXTERN(int			bu_getopt, (int nargc, char * CONST nargv[],
				CONST char *ostr) );
d1362 2
a1363 2
BU_EXTERN(void			bu_hist_pr, (CONST struct bu_hist *histp,
				CONST char *title));
d1367 1
a1367 1
				CONST unsigned char *in, int count));
d1369 1
a1369 1
				CONST unsigned char *in, int count));
d1373 1
a1373 1
				CONST unsigned char *in, int count));
d1375 1
a1375 1
				CONST unsigned char *in, int count));
d1386 1
a1386 1
BU_EXTERN(int			bu_list_len, (CONST struct bu_list *hd));
d1392 4
a1395 4
BU_EXTERN(void			bu_ck_list, (CONST struct bu_list *hd,
				CONST char *str) );
BU_EXTERN(void			bu_ck_list_magic, (CONST struct bu_list *hd,
				CONST char *str, CONST long magic) );
d1418 1
a1418 1
BU_EXTERN(CONST char *		bu_identify_magic, (long magic) );
d1424 2
a1425 2
BU_EXTERN(genptr_t		bu_malloc, (unsigned int cnt, CONST char *str));
BU_EXTERN(void			bu_free, (genptr_t ptr, CONST char *str));
d1427 1
a1427 1
				CONST char *str));
d1429 4
a1432 4
				unsigned int elsize, CONST char *str));
BU_EXTERN(void			bu_prmem, (CONST char *str));
BU_EXTERN(char *		bu_strdup, (CONST char *cp));
BU_EXTERN(char *		bu_dirname, (CONST char *cp));
d1434 1
a1434 1
BU_EXTERN(void			bu_ck_malloc_ptr, (genptr_t ptr, CONST char *str));
d1438 2
a1439 2
BU_EXTERN(struct bu_mapped_file *bu_open_mapped_file, (CONST char *name,
					CONST char *appl));
d1441 2
a1442 2
BU_EXTERN(void			bu_pr_mapped_file, (CONST char *title,
					CONST struct bu_mapped_file *mp));
d1445 2
a1446 2
					(char * CONST *path,
					CONST char *name, CONST char *appl));
d1461 2
a1462 2
				CONST genptr_t base,
				CONST struct bu_structparse *imp));
d1464 2
a1465 2
				CONST struct bu_structparse *imp,
				CONST struct bu_external *ext));
d1467 1
a1467 1
				CONST struct bu_external *ext));
d1472 2
a1473 2
BU_EXTERN(int			bu_struct_parse, (CONST struct bu_vls *in_vls,
				CONST struct bu_structparse *desc, 
d1475 3
a1477 3
BU_EXTERN(void			bu_struct_print, ( CONST char *title,
				CONST struct bu_structparse	*parsetab,
				CONST char			*base));
d1479 2
a1480 2
				CONST struct bu_structparse *sdp,
				CONST char *base));
d1482 2
a1483 2
				CONST struct bu_structparse *sdp,
				CONST char *base,
d1486 3
a1488 3
				CONST struct bu_structparse *sdp,
				CONST char *name,
				CONST char *base,
d1490 2
a1491 2
BU_EXTERN(void			bu_parse_mm, (CONST struct bu_structparse *sdp,
				CONST char *name,
d1493 1
a1493 1
				CONST char *value));
d1499 1
a1499 1
void				bu_hexdump_external( FILE *fp, CONST struct bu_external *ep, CONST char *str);
d1506 4
a1509 4
				CONST char *s, unsigned long v,
				CONST char *bits));
BU_EXTERN(void			bu_printb, (CONST char *s, unsigned long v,
				CONST char *bits));
d1512 1
a1512 1
BU_EXTERN(void			bu_ptbl_init, (struct bu_ptbl *b, int len, CONST char *str));
d1515 2
a1516 2
BU_EXTERN(int			bu_ptbl_locate, (CONST struct bu_ptbl *b, CONST long *p));
BU_EXTERN(void			bu_ptbl_zero, (struct bu_ptbl *b, CONST long *p));
d1518 1
a1518 1
BU_EXTERN(int			bu_ptbl_rm, (struct bu_ptbl *b, CONST long *p));
d1520 1
a1520 1
				CONST struct bu_ptbl *src));
d1522 1
a1522 1
				CONST struct bu_ptbl *src));
d1525 2
a1526 2
BU_EXTERN(void			bu_pr_ptbl, (CONST char *title,
				CONST struct bu_ptbl *tbl, int verbose));
d1634 2
a1635 2
BU_EXTERN(char *		bu_vls_addr, (CONST struct bu_vls *vp) );
BU_EXTERN(char *		bu_vls_strdup, (CONST struct bu_vls *vp) );
d1639 1
a1639 1
BU_EXTERN(int			bu_vls_strlen, (CONST struct bu_vls *vp) );
d1645 5
a1649 5
BU_EXTERN(void			bu_vls_strcpy, (struct bu_vls *vp, CONST char *s) );
BU_EXTERN(void			bu_vls_strncpy, (struct bu_vls *vp, CONST char *s, long n) );
BU_EXTERN(void			bu_vls_strcat, (struct bu_vls *vp, CONST char *s) );
BU_EXTERN(void			bu_vls_strncat, (struct bu_vls *vp, CONST char *s, long n) );
BU_EXTERN(void			bu_vls_vlscat, (struct bu_vls *dest, CONST struct bu_vls *src) );
d1653 1
a1653 1
BU_EXTERN(void			bu_vls_fwrite, (FILE *fp, CONST struct bu_vls *vp) );
d1661 1
a1661 1
				CONST char *fmt, va_list ap));
d1665 1
a1665 1
BU_EXTERN(int			bu_vls_print_positions_used, (CONST struct bu_vls *vp));
d1676 1
a1676 1
extern CONST char		bu_version[];
d1679 5
a1683 5
BU_EXTERN(double bu_units_conversion, (CONST char *str) );
BU_EXTERN(CONST char *bu_units_string, (CONST double mm) );
BU_EXTERN(double bu_mm_value, (CONST char *s) );
BU_EXTERN(void bu_mm_cvt, (register CONST struct bu_structparse	*sdp,
		register CONST char *name,  char *base, CONST char *value) );
d1706 2
a1707 2
BU_EXTERN(unsigned short	bu_gshort, (CONST unsigned char *msgp));
BU_EXTERN(unsigned long		bu_glong, (CONST unsigned char *msgp));
d1715 1
a1715 1
BU_EXTERN(struct bu_vls *bu_association, (CONST char *fname, CONST char *value, int field_sep));
@


1.115
log
@*- mod to comment
@
text
@d40 1
a40 1
 *  $Header: /d/CVS/brlcad/h/bu.h,v 1.114 2001/03/19 22:19:24 butler Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /d/CVS/brlcad/h/bu.h,v 1.114 2001/03/19 22:19:24 butler Exp $ (BRL)"
d1000 6
a1005 1
 * };
d1008 25
a1032 5
 * {"%c", 1,  "char_value", bu_offsetof(data_structure, a_char),   BU_STRUCTPARSE_FUNC_NULL}, 
 * {"%s", 32, "char_value", bu_offsetofarray(data_structure, str), BU_STRUCTPARSE_FUNC_NULL}, 
 * {"%i", 1,  "char_value", bu_offsetof(data_structure, a_short),  BU_STRUCTPARSE_FUNC_NULL}, 
 * {"%d", 1,  "char_value", bu_offsetof(data_structure, a_int),    BU_STRUCTPARSE_FUNC_NULL}, 
 * {"%f", 1,  "char_value", bu_offsetof(data_structure, a_double), BU_STRUCTPARSE_FUNC_NULL}, 
d1034 14
d1671 3
@


1.114
log
@patches to merge 5.3 into 6.0
@
text
@d40 1
a40 1
 *  $Header: /d/CVS/brlcad/h/bu.h,v 1.113 2000/10/24 15:30:24 mike Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /d/CVS/brlcad/h/bu.h,v 1.113 2000/10/24 15:30:24 mike Exp $ (BRL)"
d1675 1
a1675 1
/* These things that live in libbu/observer.c */
@


1.113
log
@
moved librt/rtlex.c to libbu/lex.c
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.112 2000/10/24 14:35:45 mike Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.112 2000/10/24 14:35:45 mike Exp $ (BRL)"
d926 2
a927 1

d1292 6
@


1.112
log
@
bu_next_token() moved out of librt/g_bot.c
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.111 2000/10/18 20:50:26 mike Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.111 2000/10/18 20:50:26 mike Exp $ (BRL)"
d1695 43
@


1.111
log
@
Added two macros formerly used only in MGED
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.110 2000/09/08 14:24:17 bparker Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.110 2000/09/08 14:24:17 bparker Exp $ (BRL)"
d1456 1
@


1.110
log
@Add declarations for new bu_XXX_hook routines.
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.109 2000/09/07 17:42:05 mike Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.109 2000/09/07 17:42:05 mike Exp $ (BRL)"
d470 6
@


1.109
log
@
Added malloc counters.
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.108 2000/09/05 21:06:03 mike Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.108 2000/09/05 21:06:03 mike Exp $ (BRL)"
d806 7
d814 5
d1345 6
d1354 2
a1355 2
BU_EXTERN(void			bu_add_hook, (bu_hook_t func, genptr_t clientdata));
BU_EXTERN(void			bu_delete_hook, (bu_hook_t func, genptr_t clientdata));
@


1.108
log
@
Added BU_PTBL_SET
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.107 2000/08/30 23:39:24 mike Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.107 2000/08/30 23:39:24 mike Exp $ (BRL)"
d1351 3
@


1.107
log
@
Added BU_DEBUG_MAPPED_FILE to print format
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.106 2000/08/30 23:03:03 mike Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.106 2000/08/30 23:03:03 mike Exp $ (BRL)"
d742 1
@


1.106
log
@
Added debug bit for bu_open_mapped_file()
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.105 2000/08/23 00:31:58 mike Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.105 2000/08/23 00:31:58 mike Exp $ (BRL)"
d922 1
a922 1
\013AVS\012PTBL\011MATH\010?\7?\6?\5PARALLEL\
@


1.105
log
@
Added externs for bu_tcl.c
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.104 2000/08/22 03:18:06 mike Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.104 2000/08/22 03:18:06 mike Exp $ (BRL)"
d913 1
@


1.104
log
@
Fixed bu_malloc debug string generated by BU_GETUNION().
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.103 2000/08/21 02:06:59 butler Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.103 2000/08/21 02:06:59 butler Exp $ (BRL)"
d1644 1
d1646 19
@


1.103
log
@Massive amounts of compiler warnings eliminated on Linux
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.102 2000/07/24 18:36:42 butler Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.102 2000/07/24 18:36:42 butler Exp $ (BRL)"
d120 1
a120 1
	_p = (union _unn *)bu_calloc(1,sizeof(union _unn), #_unn " (getstruct)")
d125 1
a125 1
	_p = (union _unn *)bu_calloc(1,sizeof(union _unn), "_unn (getstruct)")
@


1.102
log
@Added externs for all the stuff in convert.c
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.101 2000/07/13 02:35:32 cjohnson Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.101 2000/07/13 02:35:32 cjohnson Exp $ (BRL)"
d246 1
d250 1
d1645 1
@


1.101
log
@LINT from gcc -Wall
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.100 2000/07/13 00:29:05 mike Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.100 2000/07/13 00:29:05 mike Exp $ (BRL)"
d237 48
@


1.100
log
@
Added bu_avs_merge()
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.99 2000/07/12 03:25:42 cjohnson Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.99 2000/07/12 03:25:42 cjohnson Exp $ (BRL)"
d1197 1
d1401 1
@


1.99
log
@LINT from gcc -Wall.  These are to support clean up of libdm.
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.98 2000/07/12 01:12:40 mike Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.98 2000/07/12 01:12:40 mike Exp $ (BRL)"
d1169 2
@


1.98
log
@
Added bu_copy_external()
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.97 2000/07/11 23:12:37 mike Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.97 2000/07/11 23:12:37 mike Exp $ (BRL)"
d1584 1
a1584 1
/* These things live in libbu/observer.c */
d1587 4
@


1.97
log
@
Added externs from vls.c to bu.h
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.96 2000/07/05 21:19:33 mike Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.96 2000/07/05 21:19:33 mike Exp $ (BRL)"
d1373 1
@


1.96
log
@
Added externs
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.95 2000/06/29 20:49:37 mike Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.95 2000/06/29 20:49:37 mike Exp $ (BRL)"
d1521 1
d1523 2
d1527 1
@


1.95
log
@
Added externs for htonf().
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.94 2000/06/29 20:47:54 mike Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.94 2000/06/29 20:47:54 mike Exp $ (BRL)"
d1370 3
@


1.94
log
@
Added SIZEOF_NETWORK_FLOAT, htonf(), ntohf().
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.93 2000/06/29 17:53:41 mike Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.93 2000/06/29 17:53:41 mike Exp $ (BRL)"
d1250 6
@


1.93
log
@
added const
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.92 2000/06/29 14:26:37 mike Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.92 2000/06/29 14:26:37 mike Exp $ (BRL)"
d235 1
@


1.92
log
@
Added readonly_min/max handling.
Added bu_avs_get()
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.91 2000/06/26 18:05:38 mike Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.91 2000/06/26 18:05:38 mike Exp $ (BRL)"
d769 2
a770 2
	char	*name;
	char	*value;
@


1.91
log
@
Added support for attribute/value sets
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.90 2000/06/23 05:52:57 mike Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.90 2000/06/23 05:52:57 mike Exp $ (BRL)"
d776 12
a787 2
 *  Every one of the names and values is a local copy made with bu_strdup().
 *  They need to be freed individually.
d793 3
a795 1
	struct bu_attribute_value_pair	*avp;
d1165 5
d1173 1
@


1.90
log
@
Fixed type of ext_nbytes
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.89 2000/06/23 02:13:03 mike Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.89 2000/06/23 02:13:03 mike Exp $ (BRL)"
d226 12
d757 35
d849 1
d858 1
a858 1
\012PTBL\011MATH\010?\7?\6?\5PARALLEL\
d942 2
d1145 11
@


1.90.2.1
log
@Added BU_DEBUG_DB.
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.90 2000/06/23 05:52:57 mike Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.90 2000/06/23 05:52:57 mike Exp $ (BRL)"
d797 1
a797 2
#define BU_DEBUG_DB		0x00000008	/* 004 Database debugging */
	
@


1.90.2.2
log
@added externs for contents of convert.c
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.90.2.1 2000/11/03 19:16:57 bparker Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.90.2.1 2000/11/03 19:16:57 bparker Exp $ (BRL)"
a224 1

a1138 6

/* convert.c*/
BU_EXTERN(int bu_cv_cookie, (char *in));
BU_EXTERN(int bu_cv_optimize, (int cookie));
BU_EXTERN(int bu_cv_w_cookie, (genptr_t out, int outcookie, int size,
			     genptr_t in,  int incookie,  int count));
@


1.89
log
@
Added BU_GLONGLONG()
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.88 2000/05/08 20:43:51 mike Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.88 2000/05/08 20:43:51 mike Exp $ (BRL)"
d902 1
a902 1
	int	ext_nbytes;
@


1.88
log
@
Added BU_BITV_ZEROALL
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.87 2000/03/29 01:41:56 mike Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.87 2000/03/29 01:41:56 mike Exp $ (BRL)"
d1460 10
d1471 4
a1474 4
	    (((_cp)[0] << 24) |	\
             ((_cp)[1] << 16) |	\
             ((_cp)[2] <<  8) |	\
              (_cp)[3] )
d1476 2
a1477 2
             ((_cp)[0] <<  8) |	\
              (_cp)[1] )
@


1.87
log
@
Renamed nmg_ck_list* as bu_ck_list* routines
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.86 2000/03/28 18:05:13 mike Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.86 2000/03/28 18:05:13 mike Exp $ (BRL)"
d556 2
@


1.86
log
@
Elminated auto-include of compat4.h for bu.h
(It still happens in raytrace.h)
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.85 2000/03/03 01:01:15 mike Exp $
d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.85 2000/03/03 01:01:15 mike Exp $ (BRL)"
d1185 4
@


1.85
log
@
Removed a CONST from path arg to bu_open_mapped_file_with_path()
to please GCC compilers.
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.84 2000/03/02 03:47:19 mike Exp $
a42 4
#ifndef SEEN_COMPAT4_H
# include "compat4.h"
#endif

d51 1
a51 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.84 2000/03/02 03:47:19 mike Exp $ (BRL)"
@


1.84
log
@
Added bu_dirname()
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.83 2000/03/02 02:44:10 mike Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.83 2000/03/02 02:44:10 mike Exp $ (BRL)"
d1229 1
a1229 1
					(CONST char * CONST path[],
@


1.83
log
@
Added bu_open_mapped_file_with_path()
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.82 2000/02/18 17:48:20 bparker Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.82 2000/02/18 17:48:20 bparker Exp $ (BRL)"
d1216 1
@


1.82
log
@*- add struct bu_observer
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.81 2000/02/10 04:59:34 mike Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.81 2000/02/10 04:59:34 mike Exp $ (BRL)"
d1224 6
a1229 1

@


1.81
log
@
CONST
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.80 2000/02/08 05:09:56 mike Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.80 2000/02/08 05:09:56 mike Exp $ (BRL)"
d1077 11
d1471 4
@


1.80
log
@
Added BU_ASSERT_DOUBLE
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.79 2000/02/02 20:11:06 mike Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.79 2000/02/02 20:11:06 mike Exp $ (BRL)"
d1154 1
a1154 1
BU_EXTERN(void			bu_hist_pr, (struct bu_hist *histp,
@


1.79
log
@
Created explicit semaphore for libbu/mappedfile.c
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.78 2000/01/29 00:31:19 butler Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.78 2000/01/29 00:31:19 butler Exp $ (BRL)"
d208 18
@


1.78
log
@Type correction
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.77 2000/01/28 22:24:09 mike Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.77 2000/01/28 22:24:09 mike Exp $ (BRL)"
d751 2
a752 1
#define BU_SEM_LAST	(BU_SEM_BN_NOISE+1)	/* allocate this many for LIBBU+LIBBN */
@


1.77
log
@
Added documentation of -! flag in RT for setting bu_debug
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.76 2000/01/28 22:17:07 butler Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.76 2000/01/28 22:17:07 butler Exp $ (BRL)"
d546 1
a546 1
		bu_log("BU_BITV_BITNUM_CHECK bit number (%u) out of range (0..%u)\n",
@


1.76
log
@Made error reporting output more informative when # of bits exceeded
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.75 2000/01/14 22:43:56 mike Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.75 2000/01/14 22:43:56 mike Exp $ (BRL)"
d768 3
@


1.75
log
@
Added some new BU_ASSERT_xxx macros
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.74 2000/01/12 21:56:23 mike Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.74 2000/01/12 21:56:23 mike Exp $ (BRL)"
d545 6
a550 2
	if( ((unsigned)(_bit)) >= (_bv)->nbits )  \
		rt_bomb("BU_BITV_BITNUM_CHECK bit number out of range");
d552 6
a557 2
	if( ((unsigned)(_nbits)) > (_bv)->nbits )  \
		rt_bomb("BU_BITV_NBITS_CHECK number of bits out of range");
@


1.74
log
@
Added dont_stat to mapped file support
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.73 2000/01/07 20:50:17 mike Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.73 2000/01/07 20:50:17 mike Exp $ (BRL)"
d153 5
d172 36
@


1.73
log
@
Added missing function declarations.
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.72 1999/12/22 04:55:28 mike Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.72 1999/12/22 04:55:28 mike Exp $ (BRL)"
d668 1
@


1.72
log
@
Addition bu_mapped_file support.
db_open(,"r") now uses bu_open_mapped_file().
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.71 1999/12/22 03:17:30 mike Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.71 1999/12/22 03:17:30 mike Exp $ (BRL)"
d1349 4
@


1.71
log
@
Added 'modtime' field to mapped file struct
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.70 1999/12/07 04:30:45 mike Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.70 1999/12/07 04:30:45 mike Exp $ (BRL)"
d654 2
@


1.70
log
@
Added some more comments for Lee.
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.69 1999/11/29 17:55:27 butler Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.69 1999/11/29 17:55:27 butler Exp $ (BRL)"
d664 1
a664 1
	/* XXX Needs date stamp, in case file is modified */
@


1.69
log
@Added default and desc entries to structparse structure
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.68 1999/11/08 14:45:22 jra Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.68 1999/11/08 14:45:22 jra Exp $ (BRL)"
d640 14
@


1.68
log
@
Added proto for bu_bitv_dup().
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.65 1999/07/02 21:24:43 mike Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.65 1999/07/02 21:24:43 mike Exp $ (BRL)"
d483 1
d798 2
@


1.67
log
@Added routines to convert bit vectors to/from hex
@
text
@d1014 1
@


1.66
log
@Moved mathtab/rand_half from rt into libbn
Expanded structparse to include description and default
@
text
@d475 2
a476 2
 *  The external hex form should be big-endian hex, for MUVES compatability
 *  and overall ease of reading: left-to-right, starting with bit 0.
a482 1

a796 2
	char		*sp_desc;		/* description of element */
	void		*sp_default;		/* ptr to default value */
d1011 3
@


1.65
log
@
Eliminated dependence on compat4.h
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.64 1999/06/03 02:17:53 mike Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.64 1999/06/03 02:17:53 mike Exp $ (BRL)"
d483 1
d798 2
@


1.64
log
@
Scrubbed out stray rt_free() calls!
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.63 1999/06/03 01:11:06 mike Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.63 1999/06/03 01:11:06 mike Exp $ (BRL)"
d784 5
a788 5
 * {"%c", 1,  "char_value", bu_offsetof(data_structure, a_char),   FUNC_NULL}, 
 * {"%s", 32, "char_value", bu_offsetofarray(data_structure, str), FUNC_NULL}, 
 * {"%i", 1,  "char_value", bu_offsetof(data_structure, a_short),  FUNC_NULL}, 
 * {"%d", 1,  "char_value", bu_offsetof(data_structure, a_int),    FUNC_NULL}, 
 * {"%f", 1,  "char_value", bu_offsetof(data_structure, a_double), FUNC_NULL}, 
d819 1
a819 1
#define BU_CK_EXTERNAL(_p)	RT_CKMAG(_p, BU_EXTERNAL_MAGIC, "bu_external")
@


1.63
log
@
rt_assoc() became bu_association().  Nobody uses it.
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.62 1999/01/22 21:55:10 butler Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.62 1999/01/22 21:55:10 butler Exp $ (BRL)"
d1237 1
a1237 1
		    rt_free((char *) ((t) -> rbt_order),		\
@


1.62
log
@strncat and strncpy now take a LONG as the count parameter.  This is more
in keeping with the size_t parameter passed to the system library functions.
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.61 1999/01/13 04:05:00 mike Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.61 1999/01/13 04:05:00 mike Exp $ (BRL)"
d1358 3
@


1.61
log
@Moved bu_glong() et.al. to xdr.c.
Added macro versions of BU_GLONG() and BU_GSHORT()
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.60 1999/01/12 22:05:29 mike Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.60 1999/01/12 22:05:29 mike Exp $ (BRL)"
d1312 1
a1312 1
BU_EXTERN(void			bu_vls_strncpy, (struct bu_vls *vp, CONST char *s, int n) );
d1314 1
a1314 1
BU_EXTERN(void			bu_vls_strncat, (struct bu_vls *vp, CONST char *s, int n) );
@


1.60
log
@Added declarations for htond() and ntohd()
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.59 1999/01/12 16:18:43 pjt Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.59 1999/01/12 16:18:43 pjt Exp $ (BRL)"
a1141 6
BU_EXTERN(unsigned short	bu_gshort, (CONST unsigned char *msgp));
BU_EXTERN(unsigned long		bu_glong, (CONST unsigned char *msgp));
BU_EXTERN(unsigned char *	bu_pshort, (register unsigned char *msgp,
				register int s));
BU_EXTERN(unsigned char *	bu_plong, (register unsigned char *msgp,
				register unsigned long l));
d1339 19
@


1.59
log
@Handle details of folding libredblack into libbu
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.58 1998/12/30 01:28:47 mike Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.58 1998/12/30 01:28:47 mike Exp $ (BRL)"
d1061 6
@


1.58
log
@Merged in LibRedBlack support, plus color.c and file.c changes.
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.57 1998/12/11 20:40:07 mike Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.57 1998/12/11 20:40:07 mike Exp $ (BRL)"
a821 24
/* file.c */
/*
 *	General I/O for ASCII files: bu_file support
 */
struct bu_file  {
	long		file_magic;
	FILE		*file_ptr;	/* the actual file */
	char		*file_name;
	struct bu_vls	file_buf;	/* contents of current line */
	char		*file_bp;	/* pointer into current line */
	int		file_needline;	/* time to grab another line? */
	int		file_linenm;
	int		file_comment;	/* the comment character */
	int		file_buflen;	/* length of intact buffer */
};
typedef struct bu_file		BU_FILE;
#define BU_FILE_MAGIC		0x6275666c
#define BU_CK_FILE(_fp)		BU_CKMAG(_fp, BU_FILE_MAGIC, "bu_file")

#define bu_stdin		(&bu_iob[0])
extern BU_FILE			bu_iob[1];
#define BU_FILE_NO_COMMENT	-1

/*----------------------------------------------------------------------*/
d851 1
a851 1
 *			    R B _ L I S T
d855 4
a858 4
 *	LIBREDBLACK(3) uses this structure to maintain lists of
 *	all the nodes and all the packages in the tree.  Applications
 *	should not muck with these things.  They are maintained only
 *	to facilitate freeing bu_rb_trees.
d876 1
a876 1
 *			R B _ T R E E
d878 2
a879 3
 *	This is the only data structure used in LIBREDBLACK
 *	to which application software need make any explicit
 *	reference.
d888 1
a888 1
 *			provided in LIBREDBLACK.  Touch these
d923 1
a923 1
 *			R B _ P A C K A G E
d945 1
a945 1
 *			    R B _ N O D E
@


1.57
log
@tabdata.c moved from librt to libbn, routine names changed accordingly.
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.56 1998/12/11 04:25:20 mike Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.56 1998/12/11 04:25:20 mike Exp $ (BRL)"
d862 150
d1040 26
a1195 5





d1220 96
a1354 6
/* file.c */
BU_EXTERN(struct bu_file	*bu_fopen, (char *fname, char *type) );
BU_EXTERN(int			bu_fclose, (struct bu_file *bfp) );
BU_EXTERN(int			bu_fgetc, (struct bu_file *bfp) );
BU_EXTERN(void			bu_printfile, (struct bu_file *bfp) );

a1363 23

/* color.c */
BU_EXTERN(void		bu_rgb_to_hsv,		(unsigned char *rgb,
						    fastf_t *hsv) );
BU_EXTERN(int		bu_hsv_to_rgb,		(fastf_t *hsv,
						    unsigned char *rgb) );
BU_EXTERN(int		bu_str_to_rgb,		(char *str,
						    unsigned char *rgb) );
BU_EXTERN(void		bu_color_of_rgb_chars,	(struct bu_color *cp,
						    unsigned char *rgb) );
BU_EXTERN(int		bu_color_to_rgb_chars,	(struct bu_color *cp,
						    unsigned char *rgb) );
BU_EXTERN(int		bu_color_of_rgb_floats,	(struct bu_color *cp,
						    fastf_t *rgb) );
BU_EXTERN(int		bu_color_to_rgb_floats,	(struct bu_color *cp,
						    fastf_t *rgb) );
BU_EXTERN(int		bu_color_of_hsv_floats,	(struct bu_color *cp,
						    fastf_t *hsv) );
BU_EXTERN(int		bu_color_to_hsv_floats,	(struct bu_color *cp,
						    fastf_t *hsv) );



@


1.56
log
@Added BU_ASSERT() macro
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.55 1998/11/19 06:19:47 mike Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.55 1998/11/19 06:19:47 mike Exp $ (BRL)"
d716 1
d721 1
@


1.55
log
@Added BU_VLS_IS_INITIALIZED() macro
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.54 1998/11/05 20:58:13 mike Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.54 1998/11/05 20:58:13 mike Exp $ (BRL)"
d134 2
d150 19
@


1.54
log
@Added bu_list_parallel_append and bu_list_parallel_dequeue() for
Ron Bower's parallel MUVES work.
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.53 1998/09/23 19:38:20 jra Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.53 1998/09/23 19:38:20 jra Exp $ (BRL)"
d654 2
@


1.53
log
@Modified definition of bu_byteoffset() using definitions of _MIPS_SIM.
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.52 1998/08/21 20:38:33 mike Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.52 1998/08/21 20:38:33 mike Exp $ (BRL)"
d659 2
a660 1
#define BU_SEM_BN_NOISE	1
d898 3
@


1.52
log
@Added new routines from brlcad_path.c
@
text
@d40 1
a40 1
 *  $Header: /c/CVS/brlcad/h/bu.h,v 1.51 1998/06/05 15:38:26 pjt Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/h/bu.h,v 1.51 1998/06/05 15:38:26 pjt Exp $ (BRL)"
d731 1
a731 1
#  if IRIX > 5
@


1.51
log
@Added prototypes for many color methods
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.50 1998/06/04 20:30:42 pjt Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.50 1998/06/04 20:30:42 pjt Exp $ (BRL)"
d863 4
@


1.50
log
@Added some color stuff
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.48 1998/05/29 20:02:23 jra Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.48 1998/05/29 20:02:23 jra Exp $ (BRL)"
d831 3
a833 2
#define	BU_COLOR_MAGIC	0x6275636c
#define	BU_COLOR_NULL	((struct bu_color *) 0)
d1072 18
a1089 3
BU_EXTERN(void			bu_rgb_to_hsv, (unsigned char *rgb, fastf_t *hsv) );
BU_EXTERN(int			bu_hsv_to_rgb, (fastf_t *hsv, unsigned char *rgb) );
BU_EXTERN(int			bu_str_to_rgb, (char *str, unsigned char *rgb) );
@


1.49
log
@Added routines for converting between keyword=value and keyword-space-value lists.
@
text
@d40 1
a40 1
 *  $Header: /m/cad/CVS/brlcad/h/bu.h,v 1.48 1998/05/29 20:02:23 jra Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/CVS/brlcad/h/bu.h,v 1.48 1998/05/29 20:02:23 jra Exp $ (BRL)"
d820 15
d981 4
a984 4
BU_EXTERN( char *		bu_key_eq_to_key_val, (CONST char *in) );
BU_EXTERN( char *		bu_shader_to_key_val, (CONST char *in) );
BU_EXTERN( char *		bu_key_val_to_key_eq, (CONST char *in) );
BU_EXTERN( char *		bu_shader_to_key_eq, (CONST char *in) );
@


1.48
log
@PJT added bu_str_to_rgb().
@
text
@d40 1
a40 1
 *  $Header: /n/vapor/m/cad/h/RCS/bu.h,v 1.47 1998/05/28 19:57:05 pjt Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /n/vapor/m/cad/h/RCS/bu.h,v 1.47 1998/05/28 19:57:05 pjt Exp $ (BRL)"
d966 4
@


1.47
log
@Implemented conversions between RGB and HSV
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.46 1998/04/15 04:50:54 mike Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.46 1998/04/15 04:50:54 mike Exp $ (BRL)"
d1054 1
@


1.46
log
@Changed calling sequence to bu_parallel to allow one user-provided
pointer to be passed as an argument.
Provides a portable means of the threads establishing state,
without needing any global variables of their own.
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.45 1998/03/26 06:47:35 mike Exp mike $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.45 1998/03/26 06:47:35 mike Exp mike $ (BRL)"
d1050 4
@


1.45
log
@Added BU_LIST_IS_INITIALIZED
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.44 1998/03/24 13:40:26 pjt Exp mike $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.44 1998/03/24 13:40:26 pjt Exp mike $ (BRL)"
d922 2
a923 1
BU_EXTERN(void			bu_parallel, (void (*func)(), int ncpu));
@


1.44
log
@Changed made_it() macro to bu_made_it()
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.43 1998/03/10 21:25:28 pjt Exp pjt $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.43 1998/03/10 21:25:28 pjt Exp pjt $ (BRL)"
d301 1
@


1.43
log
@Added made_it() macro
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.42 1998/01/23 20:08:27 jra Exp pjt $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.42 1998/01/23 20:08:27 jra Exp pjt $ (BRL)"
d820 1
a820 1
#define made_it()		bu_log("Made it to %s:%d\n",	\
@


1.42
log
@Added BU_PTBL_CLEAR_I macro
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.41 1998/01/08 03:29:07 mike Exp jra $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.41 1998/01/08 03:29:07 mike Exp jra $ (BRL)"
d818 4
@


1.41
log
@Added additional checking for bad pointers in BU_CKMAG().
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.40 1997/12/19 15:52:06 pjt Exp mike $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.40 1997/12/19 15:52:06 pjt Exp mike $ (BRL)"
d592 1
@


1.40
log
@1. Added member file_needline to struct bu_file
2. Implemented support for NO_COMMENT in struct bu_file
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.39 1997/12/18 21:20:11 pjt Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.39 1997/12/18 21:20:11 pjt Exp $ (BRL)"
d138 2
a139 1
	if( !(_ptr) || *((long *)(_ptr)) != (_magic) )  { \
d143 2
a144 1
	if( !(_ptr) || *((long *)(_ptr)) != (_magic) )  { \
@


1.39
log
@Added BU_FILE stuff
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.38 1997/12/16 00:46:58 mike Exp pjt $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.38 1997/12/16 00:46:58 mike Exp pjt $ (BRL)"
d802 1
d804 1
a804 1
	char		file_comment;	/* the comment character */
d813 1
@


1.38
log
@Assigned dedicated semaphore for BU_SEM_BN_NOISE
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.37 1997/08/22 22:49:24 mike Exp mike $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.37 1997/08/22 22:49:24 mike Exp mike $ (BRL)"
d792 1
d794 21
d1023 6
@


1.37
log
@defining getopt to be bu_getopt()
messes up compilation on Solaris.
Made dependence on bu_getopt() explicit by modifying the code, please.
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.36 1997/07/01 23:35:58 mike Exp mike $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.36 1997/07/01 23:35:58 mike Exp mike $ (BRL)"
d655 2
a656 2
#define BU_SEM_BN_NOISE	4	/* XXX really old res_model. should get own */
#define BU_SEM_LAST	5	/* XXX allocate this many (want 6 really) */
@


1.36
log
@Added new routines.
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.35 1997/06/13 21:35:09 mike Exp mike $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.35 1997/06/13 21:35:09 mike Exp mike $ (BRL)"
a816 4
#define opterr			bu_opterr	/* libsysv compat */
#define optind			bu_optind
#define optopt			bu_optopt
#define optarg			bu_optarg
a820 1
#define getopt			bu_getopt
@


1.35
log
@Absorbed additions from nmg_fuse.c
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.34 1997/05/21 01:08:22 butler Exp mike $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.34 1997/05/21 01:08:22 butler Exp mike $ (BRL)"
d892 3
@


1.34
log
@added bu_mm_cvt() to support shaders in rt
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.33 1997/04/16 06:58:11 mike Exp butler $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.33 1997/04/16 06:58:11 mike Exp butler $ (BRL)"
d345 6
d352 9
d587 1
@


1.33
log
@Added BU_HIST_TALLY_MULTIPLE()
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.32 1997/04/04 05:00:04 mike Exp mike $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.32 1997/04/04 05:00:04 mike Exp mike $ (BRL)"
d995 3
@


1.32
log
@Added comments.
(Imagine that)
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.31 1997/04/04 04:57:09 mike Exp mike $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.31 1997/04/04 04:57:09 mike Exp mike $ (BRL)"
d519 1
d529 11
@


1.31
log
@Butler mod to add bu_parse_mm()
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.30 1997/04/01 20:12:42 butler Exp butler $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.30 1997/04/01 20:12:42 butler Exp butler $ (BRL)"
d422 2
d425 13
@


1.30
log
@moved units.c from librt to libbu
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.29 1997/04/01 05:41:16 mike Exp butler $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.29 1997/04/01 05:41:16 mike Exp butler $ (BRL)"
d727 3
d888 5
a892 1

@


1.29
log
@Added more sensible macro names.  Plus new routine.
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.28 1997/03/06 08:38:39 mike Exp mike $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.28 1997/03/06 08:38:39 mike Exp mike $ (BRL)"
d956 7
@


1.28
log
@Added TCL-compatible magic number checker.
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.27 1997/01/29 00:38:12 mike Exp mike $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.27 1997/01/29 00:38:12 mike Exp mike $ (BRL)"
d311 2
d317 2
d803 1
@


1.27
log
@Moved BU_COREDUMP to bit 1, for easier setting in MGED, etc.
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.26 1997/01/08 03:54:47 mike Exp mike $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.26 1997/01/08 03:54:47 mike Exp mike $ (BRL)"
d140 5
@


1.26
log
@Added BU_FORTRAN
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.25 1997/01/07 23:40:14 mike Exp mike $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.25 1997/01/07 23:40:14 mike Exp mike $ (BRL)"
a624 2
#define BU_DEBUG_MEM_CHECK	0x00000001	/* 001 Mem barrier & leak checking */
#define BU_DEBUG_MEM_LOG	0x00000002	/* 002 Print all dynamic memory operations */
d626 5
a635 1
#define BU_DEBUG_COREDUMP	0x00001000	/* 015 If set, bu_bomb() will dump core */
d640 1
a640 1
\015COREDUMP\
d642 1
a642 1
\4?\3?\2MEM_LOG\1MEM_CHECK"
@


1.25
log
@Added bu_byteoffset
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.24 1996/10/08 16:43:07 pjt Exp mike $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.24 1996/10/08 16:43:07 pjt Exp mike $ (BRL)"
d87 26
@


1.24
log
@Updated header comment in the BU_LIST section to refer to
BU_LIST_INSERT() instead of RT_LIST_INSERT()
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.23 1996/09/27 06:17:23 butler Exp $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.23 1996/09/27 06:17:23 butler Exp $ (BRL)"
d639 19
@


1.23
log
@ptbl test macro
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.22 1996/09/14 03:40:53 butler Exp butler $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.22 1996/09/14 03:40:53 butler Exp butler $ (BRL)"
d150 1
a150 1
 *	RT_LIST_INSERT( &(head.l), &((p)->l) );				*
@


1.22
log
@moved plane.c and noise.c into library
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.21 1996/08/31 08:50:03 mike Exp butler $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.21 1996/08/31 08:50:03 mike Exp butler $ (BRL)"
d511 1
@


1.21
log
@SERT, not SEBU
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.20 1996/08/31 08:42:31 mike Exp mike $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.20 1996/08/31 08:42:31 mike Exp mike $ (BRL)"
d576 2
a577 1

@


1.20
log
@Added bu_list, bu_hist
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.19 1996/08/31 08:21:05 mike Exp mike $
d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.19 1996/08/31 08:21:05 mike Exp mike $ (BRL)"
d232 1
a232 1
 *  BU_LIST_INSEBU_LIST places src_hd elements at head of dest_hd list,
d235 1
a235 1
#define BU_LIST_INSEBU_LIST(dest_hp,src_hp) \
@


1.19
log
@Added extra declaration
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.18 1996/08/31 08:02:51 butler Exp $
a42 4
#ifndef SEEN_RTLIST_H
# include "rtlist.h"
#endif

d55 1
a55 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.18 1996/08/31 08:02:51 butler Exp $ (BRL)"
d116 55
d172 212
d385 1
d390 1
a390 1
	struct rt_list	l;		/* linked list for caller's use */
d452 2
d455 25
d481 1
d496 1
a496 1
	struct rt_list	l;	/* linked list for caller's use */
a528 2
/* histogram */

d532 1
a532 1

d537 1
a537 1
	struct rt_list	l;
d558 1
d615 1
d671 3
d684 1
a684 1
	(_p)->ext_buf = GENPTR_NULL; (_p)->ext_nbytes = 0;}
d725 9
d741 4
@


1.18
log
@parse.c inherited contents of old inout.c which did binary structuer I/O
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.17 1996/08/31 06:41:32 butler Exp butler $
d59 1
a59 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.17 1996/08/31 06:41:32 butler Exp butler $ (BRL)"
d506 3
@


1.17
log
@extra protoypes and name changes for parse.c
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.16 1996/08/31 06:08:42 mike Exp butler $
d59 1
a59 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.16 1996/08/31 06:08:42 mike Exp butler $ (BRL)"
d498 2
a499 2
BU_EXTERN(void			bu_struct_buf, (struct bu_external *ext,
				genptr_t buf));
d503 4
a506 1
BU_EXTERN(void			bu_vls_item_print, (struct bu_vls *vp,
d508 3
a510 2
				CONST char *base ));
BU_EXTERN(void			bu_vls_item_print_nc, (struct bu_vls *vp,
d512 4
a515 13
				CONST char *base ));
BU_EXTERN(int			bu_vls_name_print, (struct bu_vls *vp,
				CONST struct bu_structparse *parsetab,
				CONST char *name, CONST char *base ));
BU_EXTERN(int			bu_vls_name_print_nc, (struct bu_vls *vp,
				CONST struct bu_structparse *parsetab,
				CONST char *name, CONST char *base ));
BU_EXTERN(void			bu_struct_print, (CONST char *title,
				CONST struct bu_structparse *parsetab,
				CONST char *base));
BU_EXTERN(void			bu_vls_struct_print, (struct  bu_vls *vls,
				register CONST struct bu_structparse *sdp,
				CONST char *base));
@


1.16
log
@Oops, got an extra bu_ in there.
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.15 1996/08/31 06:04:58 mike Exp mike $
d59 1
a59 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.15 1996/08/31 06:04:58 mike Exp mike $ (BRL)"
d482 19
a500 1
BU_EXTERN(int			bu_structparse, (CONST struct bu_vls *in_vls,
d515 1
a515 1
BU_EXTERN(void			bu_structprint, (CONST char *title,
d518 1
a518 1
BU_EXTERN(void			bu_vls_structprint, (struct  bu_vls *vls,
d521 5
a525 1
				
@


1.15
log
@Moved all structparse defines to have BU_ prefix
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.14 1996/08/31 05:58:09 mike Exp mike $
d59 1
a59 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.14 1996/08/31 05:58:09 mike Exp mike $ (BRL)"
d337 1
a337 1
#	define bu_offsetofarray(_t, _m)	bu_offsetof(_t, _m[0])
d339 1
a339 1
#	if !defined(bu_offsetof)
d341 2
@


1.14
log
@Added bu_mapped_file
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.13 1996/08/31 05:12:56 butler Exp mike $
d59 1
a59 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.13 1996/08/31 05:12:56 butler Exp mike $ (BRL)"
d337 1
a337 1
#	define offsetofarray(_t, _m)	offsetof(_t, _m[0])
d339 2
a340 2
#	if !defined(offsetof)
#		define offsetof(_t, _m)		(int)(&(((_t *)0)->_m))
d342 1
a342 1
#	define offsetofarray(_t, _m)	(int)( (((_t *)0)->_m))
d359 5
a363 5
 * {"%c", 1,  "char_value", offsetof(data_structure, a_char),	FUNC_NULL}, 
 * {"%s", 32, "char_value", offsetofarray(data_structure, str), FUNC_NULL}, 
 * {"%i", 1,  "char_value", offsetof(data_structure, a_short),	FUNC_NULL}, 
 * {"%d", 1,  "char_value", offsetof(data_structure, a_int), 	FUNC_NULL}, 
 * {"%f", 1,  "char_value", offsetof(data_structure, a_double), FUNC_NULL}, 
d373 1
a373 1
#define FUNC_NULL	((void (*)())0)
d375 4
a378 2
/* A "bu_external" struct holds the "external binary" representation of a
 * structure.
@


1.13
log
@bu_external struct added, bu_imexport struct removed
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.12 1996/08/31 04:00:26 mike Exp butler $
d59 1
a59 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.12 1996/08/31 04:00:26 mike Exp butler $ (BRL)"
d241 1
a241 1
/* rt_mapped_file */
d243 20
d463 6
@


1.12
log
@Changed calling sequence to bu_ptbl_init.
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.11 1996/08/31 03:03:34 butler Exp mike $
d59 1
a59 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.11 1996/08/31 03:03:34 butler Exp mike $ (BRL)"
d309 1
a309 1
 *  described by tables of "structparse" structures.
d325 21
d355 2
a356 3

/*
 *			B U _ I M E X P O R T
d358 4
a361 4
struct bu_imexport  {
	char		im_fmt[4];		/* "l", "i", or "%f", etc */
	int		im_offset;		/* byte offset in struct */
	int		im_count;		/* # of repetitions */
d363 4
a366 1
#define BU_IMEXPORT_NULL	((struct bu_imexport *)0)
@


1.11
log
@temporarily added definition for bu_imexport struct
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.10 1996/08/31 02:59:35 mike Exp butler $
d59 1
a59 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.10 1996/08/31 02:59:35 mike Exp butler $ (BRL)"
d459 1
a459 1
BU_EXTERN(void			bu_ptbl_init, (struct bu_ptbl *b, int len));
@


1.10
log
@Added comments.
@
text
@d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.9 1996/08/30 00:13:55 butler Exp mike $
d59 1
a59 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.9 1996/08/30 00:13:55 butler Exp mike $ (BRL)"
d335 9
@


1.9
log
@structparse moved to libbu
@
text
@d11 9
d40 1
a40 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.8 1996/08/29 05:54:35 mike Exp butler $
d59 1
a59 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.8 1996/08/29 05:54:35 mike Exp butler $ (BRL)"
@


1.8
log
@ispar.c
@
text
@d31 1
a31 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.7 1996/08/29 03:04:25 mike Exp mike $
d50 1
a50 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.7 1996/08/29 03:04:25 mike Exp mike $ (BRL)"
d296 33
d410 23
@


1.7
log
@Added some CONSTs
@
text
@d31 1
a31 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.6 1996/08/28 08:40:04 mike Exp mike $
d50 1
a50 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.6 1996/08/28 08:40:04 mike Exp mike $ (BRL)"
d332 4
a375 1
BU_EXTERN(int			bu_is_parallel, () );
@


1.6
log
@Added rt_list to head of bu_ptbl, for user convenience.
(I needed it in shootray)
@
text
@d31 1
a31 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.5 1996/08/28 06:11:55 mike Exp mike $
d50 1
a50 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.5 1996/08/28 06:11:55 mike Exp mike $ (BRL)"
d385 2
a386 3
BU_EXTERN(int			bu_ptbl_locate, (struct bu_ptbl *b, long *p));
BU_EXTERN(int			bu_ptbl_locate, (struct bu_ptbl *b, long *p));
BU_EXTERN(void			bu_ptbl_zero, (struct bu_ptbl *b, long *p));
d388 1
a388 1
BU_EXTERN(int			bu_ptbl_rm, (struct bu_ptbl *b, long *p));
@


1.5
log
@Changed externs.
@
text
@d31 1
a31 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.4 1996/08/28 05:40:43 mike Exp $
d50 1
a50 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.4 1996/08/28 05:40:43 mike Exp $ (BRL)"
d195 4
a198 4
	long	magic;	/* magic */
	int	end;	/* index into buffer of first available location */
	int	blen;	/* # of (long *)'s worth of storage at *buffer */
	long  **buffer;	/* data storage area */
@


1.4
log
@ptbl.c
@
text
@d31 1
a31 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.3 1996/08/28 04:23:51 mike Exp mike $
d50 1
a50 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.3 1996/08/28 04:23:51 mike Exp mike $ (BRL)"
d382 1
a382 1
BU_EXTERN(void			bu_ptbl_init, (struct bu_ptbl	*b));
d396 2
@


1.3
log
@Bitvector support
@
text
@d31 1
a31 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.2 1996/08/27 06:16:18 mike Exp mike $
d50 1
a50 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.2 1996/08/27 06:16:18 mike Exp mike $ (BRL)"
d52 1
d112 1
d179 49
d238 1
d270 1
d283 1
d291 1
a291 1
\011MATH\010?\7?\6?\5PARALLEL\
d294 1
d380 16
@


1.2
log
@Added getopt.c and linebuf.c support
@
text
@d22 1
a23 1
 *	#include <math.h>
d26 1
d31 1
a31 1
 *  $Header: /m/cad/h/RCS/bu.h,v 1.1 1996/08/27 01:09:53 mike Exp mike $
d50 1
a50 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 1.1 1996/08/27 01:09:53 mike Exp mike $ (BRL)"
a109 1
/* Bit vector macros would be a good candidate */
d111 66
d179 1
a179 1
/* vlist, vlblock */
d188 1
a188 1
 *  bu_vls support (formerly rt_vls in h/rtstring.h)
d248 12
@


1.1
log
@Initial revision
@
text
@a24 1
 *	#include "vmath.h"	/_* For vect_t definition *_/
a25 1
 *	#include "rtstring.h"	/_* OPTIONAL, auto-included by bu.h *_/
d30 1
a30 1
 *  $Header: /m/cad/h/RCS/bu.h,v 11.39 1996/08/13 16:43:26 butler Exp $
d49 1
a49 1
#define BU_H_VERSION	"@@(#)$Header: /m/cad/h/RCS/bu.h,v 11.39 1996/08/13 16:43:26 butler Exp $ (BRL)"
d117 1
a117 1
/* formerly rt_g.rtg_logindent, now use bu_log_indent() */
d186 17
d204 2
a205 1
BU_EXTERN(void			bu_log_indent, (int delta) );
d229 1
a229 1
BU_EXTERN(int			bu_byte_roundup, (int nbytes));
d255 1
d261 1
a274 1
BU_EXTERN(void			bu_vls_bomb, (CONST char *str, CONST struct bu_vls *badp) );
d286 3
@
