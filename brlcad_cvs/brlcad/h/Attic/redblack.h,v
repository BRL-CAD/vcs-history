head	11.18;
access;
symbols
	ansi-20040405-merged:11.17
	postmerge-20040405-ansi:11.17
	premerge-20040404-ansi:11.17
	postmerge-autoconf:11.17
	autoconf-freeze:11.17
	premerge-autoconf:11.17
	ansi-20040316-freeze:11.17
	postmerge-20040315-windows:11.17
	premerge-20040315-windows:11.17
	windows-20040315-freeze:11.17
	autoconf-20031203:11.17
	autoconf-20031202:11.17
	autoconf-branch:11.17.0.14
	phong-branch:11.17.0.12
	photonmap-branch:11.17.0.10
	rel-6-1-DP:11.17
	windows-branch:11.17.0.8
	rel-6-0-2:11.17
	ansi-branch:11.17.0.6
	rel-6-0-1-branch:11.17.0.4
	hartley-6-0-post:11.17
	hartley-6-0-pre:11.17
	rel-6-0-1:11.17
	rel-6-0:11.17
	rel-5-4:11.17
	offsite-5-3-pre:11.17
	rel-5-3:11.17
	rel-5-2:11.17
	rel-5-1-branch:11.17.0.2
	rel-5-1:11.17
	rel-5-0:11.17
	rel-5-0-beta:11.16
	rel-4-5:11.15
	ctj-4-5-post:11.15
	ctj-4-5-pre:11.15
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.18
date	2004.05.24.04.11.53;	author morrison;	state dead;
branches;
next	11.17;

11.17
date	99.06.03.02.17.53;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	98.12.30.01.37.46;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	96.11.27.17.47.17;	author pjt;	state Exp;
branches;
next	11.14;

11.14
date	96.11.26.20.15.12;	author pjt;	state Exp;
branches;
next	11.13;

11.13
date	96.11.26.19.15.08;	author pjt;	state Exp;
branches;
next	11.12;

11.12
date	96.08.31.09.40.00;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	96.02.06.20.06.13;	author pjt;	state Exp;
branches;
next	11.10;

11.10
date	95.09.20.12.45.52;	author pjt;	state Exp;
branches;
next	11.9;

11.9
date	95.09.20.12.43.42;	author pjt;	state Exp;
branches;
next	11.8;

11.8
date	95.09.20.12.41.53;	author pjt;	state Exp;
branches;
next	11.7;

11.7
date	95.09.18.14.14.51;	author pjt;	state Exp;
branches;
next	11.6;

11.6
date	95.04.21.13.32.49;	author pjt;	state Exp;
branches;
next	11.5;

11.5
date	95.04.19.20.13.11;	author pjt;	state Exp;
branches;
next	11.4;

11.4
date	95.04.19.19.05.40;	author pjt;	state Exp;
branches;
next	11.3;

11.3
date	95.04.07.14.38.47;	author pjt;	state Exp;
branches;
next	11.2;

11.2
date	95.04.07.14.34.19;	author pjt;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.48.35;	author mike;	state Rel4_4;
branches;
next	2.4;

2.4
date	94.11.01.10.57.03;	author pjt;	state Exp;
branches;
next	2.3;

2.3
date	94.11.01.10.45.48;	author pjt;	state Exp;
branches;
next	2.2;

2.2
date	94.09.22.15.31.09;	author pjt;	state Exp;
branches;
next	2.1;

2.1
date	93.03.25.11.03.34;	author pjt;	state Exp;
branches;
next	1.17;

1.17
date	93.01.22.11.46.59;	author pjt;	state Exp;
branches;
next	1.16;

1.16
date	93.01.15.14.32.06;	author pjt;	state zero_1;
branches;
next	1.15;

1.15
date	93.01.15.13.07.42;	author pjt;	state Exp;
branches;
next	1.14;

1.14
date	93.01.15.10.41.26;	author pjt;	state zero_0;
branches;
next	1.13;

1.13
date	93.01.14.15.01.43;	author pjt;	state Exp;
branches;
next	1.12;

1.12
date	93.01.14.10.57.09;	author pjt;	state Exp;
branches;
next	1.11;

1.11
date	93.01.14.10.50.24;	author pjt;	state Exp;
branches;
next	1.10;

1.10
date	93.01.14.10.13.22;	author pjt;	state Exp;
branches;
next	1.9;

1.9
date	93.01.14.09.21.52;	author pjt;	state Exp;
branches;
next	1.8;

1.8
date	93.01.05.09.13.15;	author pjt;	state Exp;
branches;
next	1.7;

1.7
date	92.12.23.12.44.15;	author pjt;	state Exp;
branches;
next	1.6;

1.6
date	92.12.23.11.12.19;	author pjt;	state Exp;
branches;
next	1.5;

1.5
date	92.11.06.13.48.24;	author pjt;	state Exp;
branches;
next	1.4;

1.4
date	92.11.05.11.31.06;	author pjt;	state Exp;
branches;
next	1.3;

1.3
date	92.11.04.12.56.23;	author pjt;	state Exp;
branches;
next	1.2;

1.2
date	92.11.04.12.15.26;	author pjt;	state Exp;
branches;
next	1.1;

1.1
date	92.11.04.10.29.09;	author pjt;	state Exp;
branches;
next	;


desc
@
     Header file for use within LIBREDBLACK(3)
     and by applications programs

@


11.18
log
@moved/renamed from top-level h/ to top-level include/
@
text
@/*			R E D B L A C K . H
 *
 *	The data structures and constants for red-black trees.
 *
 *	Many of these routines are based on the algorithms in chapter 13
 *	of T. H. Cormen, C. E. Leiserson, and R. L. Rivest,
 *	_Introduction to algorithms_, MIT Press, Cambridge, MA, 1990.
 *
 *	Author:	Paul Tanenbaum
 *
 */

#include "bu.h"
#if 0

/*
 *			    R B _ L I S T
 *
 *		    List of nodes or packages
 *
 *	LIBREDBLACK(3) uses this structure to maintain lists of
 *	all the nodes and all the packages in the tree.  Applications
 *	should not muck with these things.  They are maintained only
 *	to facilitate freeing rb_trees.
 */
struct rb_list
{
    struct bu_list	l;
    union
    {
	struct rb_node    *rbl_n;
	struct rb_package *rbl_p;
    }			rbl_u;
};
#define	rbl_magic	l.magic
#define	rbl_node	rbl_u.rbl_n
#define	rbl_package	rbl_u.rbl_p
#define	RB_LIST_NULL	((struct rb_list *) 0)


/*
 *			R B _ T R E E
 *
 *	This is the only data structure used in LIBREDBLACK
 *	to which application software need make any explicit
 *	reference.
 *
 *	The members of this structure are grouped into three
 *	classes:
 *	    Class I:	Reading is appropriate, when necessary,
 *			but applications should not modify.
 *	    Class II:	Reading and modifying are both appropriate,
 *			when necessary.
 *	    Class III:	All access should be through routines
 *			provided in LIBREDBLACK.  Touch these
 *			at your own risk!
 */
typedef struct
{
    /* CLASS I - Applications may read directly... */
    long	 	rbt_magic;	  /* Magic no. for integrity check */
    int			rbt_nm_nodes;	  /* Number of nodes */
    /* CLASS II - Applications may read/write directly... */
    void		(*rbt_print)();	  /* Data pretty-print function */
    int			rbt_debug;	  /* Debug bits */
    char		*rbt_description; /* Comment for diagnostics */
    /* CLASS III - Applications should not manipulate directly... */
    int		 	rbt_nm_orders;	  /* Number of simultaneous orders */
    int			(**rbt_order)();  /* Comparison functions */
    struct rb_node	**rbt_root;	  /* The actual trees */
    char		*rbt_unique;	  /* Uniqueness flags */
    struct rb_node	*rbt_current;	  /* Current node */
    struct rb_list	rbt_nodes;	  /* All nodes */
    struct rb_list	rbt_packages;	  /* All packages */
    struct rb_node	*rbt_empty_node;  /* Sentinel representing nil */
}	rb_tree;
#define	RB_TREE_NULL	((rb_tree *) 0)
#define	RB_TREE_MAGIC	0x72627472

/*
 *	Debug bit flags for member rbt_debug
 */
#define RB_DEBUG_INSERT	0x00000001	/* Insertion process */
#define RB_DEBUG_UNIQ	0x00000002	/* Uniqueness of inserts */
#define RB_DEBUG_ROTATE	0x00000004	/* Rotation process */
#define RB_DEBUG_OS	0x00000008	/* Order-statistic operations */
#define RB_DEBUG_DELETE	0x00000010	/* Deletion process */

/*
 *			R B _ P A C K A G E
 *
 *		    Wrapper for application data
 *
 *	This structure provides a level of indirection between
 *	the application software's data and the red-black nodes
 *	in which the data is stored.  It is necessary because of
 *	the algorithm for deletion, which generally shuffles data
 *	among nodes in the tree.  The package structure allows
 *	the application data to remember which node "contains" it
 *	for each order.
 */
struct rb_package
{
    long		rbp_magic;	/* Magic no. for integrity check */
    struct rb_node	**rbp_node;	/* Containing nodes */
    struct rb_list	*rbp_list_pos;	/* Place in the list of all pkgs. */
    void		*rbp_data;	/* Application data */
};
#define	RB_PKG_NULL	((struct rb_package *) 0)

/*
 *			    R B _ N O D E
 *
 *	For the most part, there is a one-to-one correspondence
 *	between nodes and chunks of application data.  When a
 *	node is created, all of its package pointers (one per
 *	order of the tree) point to the same chunk of data.
 *	However, subsequent deletions usually muddy this tidy
 *	state of affairs.
 */
struct rb_node
{
    long		rbn_magic;	/* Magic no. for integrity check */
    rb_tree		*rbn_tree;	/* Tree containing this node */
    struct rb_node	**rbn_parent;	/* Parents */
    struct rb_node	**rbn_left;	/* Left subtrees */
    struct rb_node	**rbn_right;	/* Right subtrees */
    char		*rbn_color;	/* Colors of this node */
    int			*rbn_size;	/* Sizes of subtrees rooted here */
    struct rb_package	**rbn_package;	/* Contents of this node */
    int			rbn_pkg_refs;	/* How many orders are being used? */
    struct rb_list	*rbn_list_pos;	/* Place in the list of all nodes */
};
#define	RB_NODE_NULL	((struct rb_node *) 0)

/*
 *	Applications interface to rb_extreme()
 */
#define	SENSE_MIN	0
#define	SENSE_MAX	1
#define	rb_min(t,o)	rb_extreme((t), (o), SENSE_MIN)
#define	rb_max(t,o)	rb_extreme((t), (o), SENSE_MAX)
#define rb_pred(t,o)	rb_neighbor((t), (o), SENSE_MIN)
#define rb_succ(t,o)	rb_neighbor((t), (o), SENSE_MAX)

/*
 *	Applications interface to rb_walk()
 */
#define	PREORDER	0
#define	INORDER		1
#define	POSTORDER	2

/*
 *	Applications interface to LIBREDBLACK
 */
BU_EXTERN(rb_tree *rb_create,	(char		*description,
				 int 		nm_orders,
				 int		(**order_funcs)()
				));
BU_EXTERN(rb_tree *rb_create1,	(char		*description,
				 int		(*order_func)()
				));
BU_EXTERN(void *rb_curr,	(rb_tree	*tree,
				 int		order
				));
#define		rb_curr1(t)	rb_curr((t), 0)
BU_EXTERN(void rb_delete,	(rb_tree	*tree,
				 int		order
				));
#define		rb_delete1(t)	rb_delete((t), 0)
BU_EXTERN(void rb_diagnose_tree,(rb_tree	*tree,
				 int		order,
				 int		trav_type
				));
BU_EXTERN(void *rb_extreme,	(rb_tree	*tree,
				 int		order,
				 int		sense
				));
BU_EXTERN(void rb_free,		(rb_tree	*tree,
				 void		(*free_data)()
				));
#define	RB_RETAIN_DATA	((void (*)()) 0)
#define		rb_free1(t,f)						\
		{							\
		    RB_CKMAG((t), RB_TREE_MAGIC, "red-black tree");	\
		    bu_free((char *) ((t) -> rbt_order),		\
				"red-black order function");		\
		    rb_free(t,f);					\
		}
BU_EXTERN(void *rb_select,	(rb_tree	*tree,
				 int		order,
				 int		k
				));
#define		rb_select1(t,k)	rb_select((t), 0, (k))
BU_EXTERN(int rb_insert,	(rb_tree	*tree,
				 void		*data
				));
BU_EXTERN(int rb_is_uniq,	(rb_tree	*tree,
				 int		order
				));
#define		rb_is_uniq1(t)	rb_is_uniq((t), 0)
BU_EXTERN(void *rb_neighbor,	(rb_tree	*tree,
				 int		order,
				 int		sense
				));
BU_EXTERN(int rb_rank,		(rb_tree	*tree,
				 int		order
				));
#define		rb_rank1(t)	rb_rank1((t), 0)
BU_EXTERN(void *rb_search,	(rb_tree	*tree,
				 int		order,
				 void		*data
				));
#define		rb_search1(t,d)	rb_search((t), 0, (d))
BU_EXTERN(void rb_set_uniqv,	(rb_tree	*tree,
				 bitv_t		vec
				));
BU_EXTERN(void rb_summarize_tree,(rb_tree	*tree
				 ));
BU_EXTERN(void rb_uniq_all_off,	(rb_tree	*tree
				));
BU_EXTERN(void rb_uniq_all_on,	(rb_tree	*tree
				));
BU_EXTERN(int rb_uniq_off,	(rb_tree	*tree,
				 int		order
				));
#define		rb_uniq_off1(t)	rb_uniq_off((t), 0)
BU_EXTERN(int rb_uniq_on,	(rb_tree	*tree,
				 int		order
				));
#define		rb_uniq_on1(t)	rb_uniq_on((t), 0)
BU_EXTERN(void rb_walk,		(rb_tree	*tree,
				 int		order,
				 void		(*visit)(),
				 int		trav_type
				));
#define		rb_walk1(t,v,d)	rb_walk((t), 0, (v), (d))

#endif
@


11.17
log
@
Scrubbed out stray rt_free() calls!
@
text
@@


11.16
log
@RedBlack routines are now part of LIBBU, not a separate LIBREDBLACK.
@
text
@d186 1
a186 1
		    rt_free((char *) ((t) -> rbt_order),		\
@


11.15
log
@Added RB_DEBUG_DELETE bit flag
@
text
@d3 1
a3 2
 *	The data structures, constants, and applications interface
 *	to LIBREDBLACK(3), the BRL-CAD red-black tree library.
d5 2
a6 2
 *	Many of the routines in LIBREDBLACK(3) are based on the algorithms
 *	in chapter 13 of T. H. Cormen, C. E. Leiserson, and R. L. Rivest,
a10 1
 *  $Header: /m/cad/h/RCS/redblack.h,v 11.14 1996/11/26 20:15:12 pjt Exp $
d13 2
a14 2
#ifndef REDBLACK_H
#define REDBLACK_H seen
d239 1
a239 1
#endif /* REDBLACK_H */
@


11.14
log
@Backed out the rbt_aptr member from rb_tree
@
text
@d12 1
a12 1
 *  $Header: /m/cad/h/RCS/redblack.h,v 11.12 1996/08/31 09:40:00 mike Exp $
d89 1
@


11.13
log
@Added rbt_aptr member of rb_tree
@
text
@a68 1
    void		*rbt_aptr;	  /* Application-specific pointer */
@


11.12
log
@Converted to LIBBU
@
text
@d12 1
a12 1
 *  $Header: /m/cad/h/RCS/redblack.h,v 11.11 1996/02/06 20:06:13 pjt Exp mike $
d69 1
@


11.11
log
@Fixed bug in (circular!) definition of rb_select1()
@
text
@d12 1
a12 1
 *  $Header: /m/cad/h/RCS/redblack.h,v 11.10 1995/09/20 12:45:52 pjt Exp pjt $
a18 14
 *  Macros for providing function prototypes, regardless of whether
 *  the compiler understands them or not.
 *  It is vital that the argument list given for "args" be enclosed
 *  in parens.
 */
#if __STDC__ || USE_PROTOTYPES
#	define	RB_EXTERN(type_and_name,args)	extern type_and_name args
#	define	RB_ARGS(args)			args
#else
#	define	RB_EXTERN(type_and_name,args)	extern type_and_name()
#	define	RB_ARGS(args)			()
#endif

/*
d30 1
a30 1
    struct rt_list	l;
d157 1
a157 1
RB_EXTERN(rb_tree *rb_create,	(char		*description,
d161 1
a161 1
RB_EXTERN(rb_tree *rb_create1,	(char		*description,
d164 1
a164 1
RB_EXTERN(void *rb_curr,	(rb_tree	*tree,
d168 1
a168 1
RB_EXTERN(void rb_delete,	(rb_tree	*tree,
d172 1
a172 1
RB_EXTERN(void rb_diagnose_tree,(rb_tree	*tree,
d176 1
a176 1
RB_EXTERN(void *rb_extreme,	(rb_tree	*tree,
d180 1
a180 1
RB_EXTERN(void rb_free,		(rb_tree	*tree,
d191 1
a191 1
RB_EXTERN(void *rb_select,	(rb_tree	*tree,
d196 1
a196 1
RB_EXTERN(int rb_insert,	(rb_tree	*tree,
d199 1
a199 1
RB_EXTERN(int rb_is_uniq,	(rb_tree	*tree,
d203 1
a203 1
RB_EXTERN(void *rb_neighbor,	(rb_tree	*tree,
d207 1
a207 1
RB_EXTERN(int rb_rank,		(rb_tree	*tree,
d211 1
a211 1
RB_EXTERN(void *rb_search,	(rb_tree	*tree,
d216 1
a216 1
RB_EXTERN(void rb_set_uniqv,	(rb_tree	*tree,
d219 1
a219 1
RB_EXTERN(void rb_summarize_tree,(rb_tree	*tree
d221 1
a221 1
RB_EXTERN(void rb_uniq_all_off,	(rb_tree	*tree
d223 1
a223 1
RB_EXTERN(void rb_uniq_all_on,	(rb_tree	*tree
d225 1
a225 1
RB_EXTERN(int rb_uniq_off,	(rb_tree	*tree,
d229 1
a229 1
RB_EXTERN(int rb_uniq_on,	(rb_tree	*tree,
d233 1
a233 1
RB_EXTERN(void rb_walk,		(rb_tree	*tree,
@


11.10
log
@Fixed another little bug in declaration of rb_rank()!!
@
text
@d12 1
a12 1
 *  $Header: /m/cad/h/RCS/redblack.h,v 11.9 1995/09/20 12:43:42 pjt Exp pjt $
d209 1
a209 1
#define		rb_select1(t,k)	rb_select1((t), 0, (k))
@


11.9
log
@Fixed minor bug in declaration of rb_rank()
@
text
@d12 1
a12 1
 *  $Header: /m/cad/h/RCS/redblack.h,v 11.8 1995/09/20 12:41:53 pjt Exp pjt $
d221 1
a221 1
RB_EXTERN(void *rb_rank,	(rb_tree	*tree,
@


11.8
log
@Added support for order-statistic operations,
including rbn_size member of struct rb_node.
@
text
@d12 1
a12 1
 *  $Header: /m/cad/h/RCS/redblack.h,v 11.7 1995/09/18 14:14:51 pjt Exp pjt $
d222 1
a222 1
				 int		order,
d227 1
a227 1
				 void	*data
@


11.7
log
@COB 11 Jul 95.  Added struct rb_list and support for freeing rb_trees
@
text
@d12 1
a12 1
 *  $Header: /m/cad/h/RCS/redblack.h,v 11.6 1995/04/21 13:32:49 pjt Exp pjt $
d102 1
d144 1
d205 5
d221 4
@


11.6
log
@Moved RB_TREE_MAGIC from rb_internals.h to ../h/redblack.h
and rearranged and commented definition of struct rb_tree
@
text
@d12 1
a12 1
 *  $Header: /m/cad/h/RCS/redblack.h,v 11.5 1995/04/19 20:13:11 pjt Exp $
d32 23
d56 1
d89 2
d120 1
d145 1
d192 11
@


11.5
log
@Added rb_curr() and rb_curr1() macro
@
text
@d7 2
a8 3
 *	in chapter 13 of Cormen, T. H., Leiserson, C. E., and Rivest, R. L.
 *	1990.  _Introduction to Algorithms_.  Cambridge, MA: MIT Press.
 *	pp. 263-80.
d12 1
a12 1
 *  $Header: /m/cad/h/RCS/redblack.h,v 11.4 1995/04/19 19:05:40 pjt Exp pjt $
d39 10
d52 1
d54 4
d59 1
a60 1
    int			rbt_nm_nodes;	  /* Number of nodes */
a61 1
    void		(*rbt_print)();	  /* Data pretty-print function */
a64 1
    int			rbt_debug;	  /* Debug bits */
d68 8
a202 7

/*
 *	Debug bit flags
 */
#define RB_DEBUG_INSERT	0x00000001	/* Insertion process */
#define RB_DEBUG_UNIQ	0x00000002	/* Uniqueness of inserts */
#define RB_DEBUG_ROTATE	0x00000004	/* Rotation process */
@


11.4
log
@1. Added rbt_unique and rbt_debug to rb_tree
2. Added prototypes for rb_is_uniq(), rb_set_uniqv(), rb_uniq_all_off(),
    rb_uniq_all_on(), rb_uniq_off(), and rb_uniq_on().
3. Implemented rb_is_uniq1(), rb_uniq_off1(), and rb_uniq_on1() macros
4. Added definitions of debug bit flags
@
text
@d13 1
a13 1
 *  $Header: /m/cad/h/RCS/redblack.h,v 11.3 1995/04/07 14:38:47 pjt Exp $
d128 4
@


11.3
log
@Fixed stupid bug I just created
@
text
@d13 1
a13 1
 *  $Header: /m/cad/h/RCS/redblack.h,v 11.2 1995/04/07 14:34:19 pjt Exp pjt $
d50 1
d52 1
d143 4
d156 3
d161 12
d179 7
@


11.2
log
@Implemented the rb_delete1() macro
@
text
@d13 1
a13 1
 *  $Header: /m/cad/h/RCS/redblack.h,v 11.1 95/01/04 09:48:35 mike Rel4_4 $
d129 1
a129 1
#define		rb_delete1(t)	rb_walk((t), 0)
@


11.1
log
@Release_4.4
@
text
@d13 1
a13 1
 *  $Header: /m/cad/h/RCS/redblack.h,v 2.4 94/11/01 10:57:03 pjt Exp $
d129 1
@


2.4
log
@Added rb_walk1()
@
text
@d13 1
a13 1
 *  $Header: /m/cad/h/RCS/redblack.h,v 2.3 94/11/01 10:45:48 pjt Exp Locker: pjt $
@


2.3
log
@Added rbt_nm_nodes to rb_tree
@
text
@d13 1
a13 1
 *  $Header: /m/cad/h/RCS/redblack.h,v 2.2 94/09/22 15:31:09 pjt Exp Locker: pjt $
d156 1
@


2.2
log
@Replaced prototype-type declarations with K&R style
@
text
@d13 1
a13 1
 *  $Header: /m/cad/libredblack/RCS/redblack.h,v 2.1 93/03/25 11:03:34 pjt Exp $
d46 1
@


2.1
log
@Installed into BRL CAD tree
@
text
@d13 1
a13 1
 *  $Header: /m/cad/libredblack/RCS/redblack.h,v 1.17 93/01/22 11:46:59 pjt Exp Locker: pjt $
d20 15
d118 37
a154 45
rb_tree *rb_create	(
			    char	*description,
			    int 	nm_orders,
			    int		(**order_funcs)()
			);
rb_tree *rb_create1	(
			    char	*description,
			    int		(*order_func)()
			);
void rb_delete		(
			    rb_tree	*tree,
			    int		order
			);
void rb_diagnose_tree	(
			    rb_tree	*tree,
			    int		order,
			    int		trav_type
			);
void *rb_extreme	(
			    rb_tree	*tree,
			    int		order,
			    int		sense
			);
int rb_insert		(
			    rb_tree	*tree,
			    void	*data
			);
void *rb_neighbor	(
			    rb_tree	*tree,
			    int		order,
			    int		sense
			);
void *rb_search		(
			    rb_tree	*tree,
			    int		order,
			    void	*data
			);
#define rb_search1(t,d)	rb_search((t), 0, (d))
void rb_summarize_tree	(   rb_tree	*tree	);
void rb_walk		(
			    rb_tree	*tree,
			    int		order,
			    void	(*visit)(),
			    int		trav_type
			);
@


1.17
log
@Added comments
@
text
@d13 1
a13 1
 *  $Header: /arl/pjt/libredblack/RCS/redblack.h,v 1.16 93/01/15 14:32:06 pjt Exp Locker: pjt $
@


1.16
log
@Added parameter trav_type to prototype for rb_diagnose_tree()
@
text
@d13 1
a13 1
 *  $Header: /arl/pjt/libredblack/RCS/redblack.h,v 1.15 93/01/15 13:07:42 pjt Exp Locker: pjt $
d21 4
d41 10
d61 8
a68 1
 *			R B _ N O D E
d140 1
a140 1
#define rb_search1(t,n)	rb_search((t), 0, (n))
@


1.15
log
@Added comments and performed general clean up
@
text
@d13 1
a13 1
 *  $Header: /arl/pjt/libredblack/RCS/redblack.h,v 1.14 93/01/15 10:41:26 pjt Exp Locker: pjt $
d97 2
a98 1
			    int		order
@


1.14
log
@Added traversal type to rb_walk()
@
text
@d3 2
a4 1
 *	Written by:	Paul Tanenbaum
d6 8
a13 1
 *  $Header: /arl/pjt/libredblack/RCS/redblack.h,v 1.13 93/01/14 15:01:43 pjt Exp Locker: pjt $
d20 1
a20 1
 *	Data structures
d35 3
d46 3
d66 1
a67 1
#define	SENSE_MAX	1
a70 1
#define rb_search1(t,n)	rb_search((t), 0, (n))
a107 4
void rb_install_print	(
			    rb_tree	*tree,
			    void	(*print_func)()
			);
d118 1
@


1.13
log
@1. Implemented (struct rb_package)
2. Added rbt_print and rbt_current to rb_tree
3. In (struct rb_node) replace rbn_data by rbn_package
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/redblack.h,v 1.12 93/01/14 10:57:09 pjt Exp Locker: pjt $
d60 7
d113 2
a114 1
			    void	(*visit)()
@


1.12
log
@one more tweak
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/redblack.h,v 1.11 93/01/14 10:50:24 pjt Exp Locker: pjt $
d20 1
d22 1
d27 8
d43 2
a44 2
    void		**rbn_data;	/* Contents of this node */
    int			rbn_data_refs;	/* How many orders are being used? */
d55 2
a56 2
#define rb_pred(o)	rb_neighbor((o), SENSE_MIN)
#define rb_succ(o)	rb_neighbor((o), SENSE_MAX)
d71 1
a71 1
int rb_delete		(
d73 1
a73 1
			    void	*data
d88 4
d93 1
@


1.11
log
@Yet another tweak to prototype of rb_delete()
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/redblack.h,v 1.10 93/01/14 10:13:22 pjt Exp Locker: pjt $
d61 1
a61 1
void *rb_delete		(
d64 1
@


1.10
log
@rbn_data_count renamed rbn_data_refs
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/redblack.h,v 1.9 93/01/14 09:21:52 pjt Exp Locker: pjt $
d61 3
a63 1
void *rb_delete		(   rb_tree	*tree	);
@


1.9
log
@1. Converted rbn_data from (void *) to (void **)
2. Added member rbn_data_count to struct rb_node
3. Removed second parameter from prototype for rb_delete()
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/redblack.h,v 1.8 93/01/05 09:13:15 pjt Exp Locker: pjt $
d27 8
a34 8
    long		rbn_magic;	  /* Magic no. for integrity check */
    rb_tree		*rbn_tree;	  /* Tree containing this node */
    struct rb_node	**rbn_parent;	  /* Parents */
    struct rb_node	**rbn_left;	  /* Left subtrees */
    struct rb_node	**rbn_right;	  /* Right subtrees */
    char		*rbn_color;	  /* Colors of this node */
    void		**rbn_data;	  /* Contents of this node */
    int			rbn_data_count;  /* How many orders being used? */
@


1.8
log
@1. Implemented rb_search1()
2. Added prototype for rb_create1()
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/redblack.h,v 1.7 92/12/23 12:44:15 pjt Exp Locker: pjt $
d21 1
d27 8
a34 7
    long		rbn_magic;	/* Magic no. for integrity check */
    rb_tree		*rbn_tree;	/* Tree containing this node */
    struct rb_node	**rbn_parent;	/* Parents */
    struct rb_node	**rbn_left;	/* Left subtrees */
    struct rb_node	**rbn_right;	/* Right subtrees */
    char		*rbn_color;	/* Colors of this node */
    void		*rbn_data;	/* Contents of this node */
d61 1
a61 4
int rb_delete		(
			    rb_tree	*tree,
			    void	*data
			);
@


1.7
log
@1. Implemented rb_pred() and rb_succ()
2. Added prototypes for rb_delete() and rb_neighbor()
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/redblack.h,v 1.6 92/12/23 11:12:19 pjt Exp Locker: pjt $
d45 1
d54 4
@


1.6
log
@In prototypes, changed parameter of rb_extreme() from "order_nm" to "order"
and parameter of rb_search() from "datum" to "data"
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/redblack.h,v 1.5 92/11/06 13:48:24 pjt Exp Locker: pjt $
d43 2
d54 4
d70 4
@


1.5
log
@Changed some names and added rb_diagnose_tree() and rb_summarize_tree()
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/redblack.h,v 1.4 92/11/05 11:31:06 pjt Exp Locker: pjt $
d58 1
a58 1
			    int		order_nm,
d68 1
a68 1
			    void	*datum
@


1.4
log
@Changed rb_node from (struct rb_node *) to (struct rb_node **)
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/redblack.h,v 1.3 92/11/04 12:56:23 pjt Exp Locker: pjt $
d37 1
a37 1
 *	Applications interface to _rb_extreme()
d40 1
a40 1
#define	rb_min(t,o)	_rb_extreme((t), (o), SENSE_MIN)
d42 1
a42 1
#define	rb_max(t,o)	_rb_extreme((t), (o), SENSE_MAX)
d50 1
a50 1
			    int		(**order)()
d52 1
a52 1
void *_rb_extreme	(
d54 4
d70 1
@


1.3
log
@Added prototype for rb_search()
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/redblack.h,v 1.2 92/11/04 12:15:26 pjt Exp Locker: pjt $
d20 1
a20 1
    struct rb_node	*rbt_root;	  /* The actual tree */
@


1.2
log
@Added prototypes for _rb_extreme() and rb_walk()
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/redblack.h,v 1.1 92/11/04 10:29:09 pjt Exp Locker: pjt $
d60 5
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.1 91/10/12 06:35:30 mike Rel4_0 $
d37 8
d52 5
d61 1
a61 1
void *rb_min		(
d63 2
a64 1
			    int		order_nm
@
