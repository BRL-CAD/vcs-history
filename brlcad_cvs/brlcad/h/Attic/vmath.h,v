head	11.24;
access;
symbols
	ansi-20040405-merged:11.23
	postmerge-20040405-ansi:11.23
	premerge-20040404-ansi:11.23
	postmerge-autoconf:11.23
	autoconf-freeze:11.23
	premerge-autoconf:11.23
	ansi-20040316-freeze:11.23
	postmerge-20040315-windows:11.23
	premerge-20040315-windows:11.23
	windows-20040315-freeze:11.23
	autoconf-20031203:11.23
	autoconf-20031202:11.23
	autoconf-branch:11.23.0.12
	phong-branch:11.23.0.10
	photonmap-branch:11.23.0.8
	rel-6-1-DP:11.23
	windows-branch:11.23.0.6
	rel-6-0-2:11.23
	ansi-branch:11.23.0.4
	rel-6-0-1-branch:11.23.0.2
	hartley-6-0-post:11.23
	hartley-6-0-pre:11.23
	rel-6-0-1:11.23
	rel-6-0:11.22
	rel-5-4:11.18.2.1
	offsite-5-3-pre:11.18
	rel-5-3:11.18.2.1
	rel-5-2:11.18
	rel-5-1-branch:11.18.0.2
	rel-5-1:11.18
	rel-5-0:11.10
	rel-5-0-beta:11.10
	rel-4-5:11.6
	ctj-4-5-post:11.4
	ctj-4-5-pre:11.4
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.4
	rel-1-10:4.1
	rt-2:2.5;
locks; strict;
comment	@ * @;


11.24
date	2004.05.24.04.11.54;	author morrison;	state dead;
branches;
next	11.23;

11.23
date	2002.05.17.12.27.48;	author morrison;	state Exp;
branches;
next	11.22;

11.22
date	2001.10.15.21.55.00;	author kermit;	state Exp;
branches;
next	11.21;

11.21
date	2001.04.02.21.37.53;	author morrison;	state Exp;
branches;
next	11.20;

11.20
date	2001.03.29.13.26.32;	author morrison;	state Exp;
branches;
next	11.19;

11.19
date	2001.03.19.22.19.25;	author butler;	state Exp;
branches;
next	11.18;

11.18
date	2000.05.09.20.42.59;	author mike;	state Exp;
branches
	11.18.2.1;
next	11.17;

11.17
date	2000.03.29.18.11.42;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	2000.02.20.03.45.50;	author butler;	state Exp;
branches;
next	11.15;

11.15
date	2000.02.14.21.28.57;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	2000.02.14.21.20.52;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	2000.02.11.23.37.42;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	99.12.23.06.26.27;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	99.12.07.01.11.51;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	99.01.15.07.37.48;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	98.12.11.05.53.12;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	98.10.14.12.27.53;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	98.03.19.14.54.57;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	97.09.11.21.35.34;	author butler;	state Exp;
branches;
next	11.5;

11.5
date	97.09.11.20.26.02;	author butler;	state Exp;
branches;
next	11.4;

11.4
date	97.01.07.22.35.43;	author butler;	state Exp;
branches;
next	11.3;

11.3
date	96.08.30.00.14.20;	author butler;	state Exp;
branches;
next	11.2;

11.2
date	95.12.29.23.10.19;	author butler;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.48.52;	author mike;	state Rel4_4;
branches;
next	10.15;

10.15
date	94.11.03.10.31.55;	author jra;	state Exp;
branches;
next	10.14;

10.14
date	94.09.16.20.08.39;	author mike;	state Exp;
branches;
next	10.13;

10.13
date	94.09.16.19.55.16;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	94.04.22.05.27.37;	author mike;	state Exp;
branches;
next	10.11;

10.11
date	94.04.12.22.37.40;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	94.01.25.09.45.34;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	93.12.06.21.33.58;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	93.09.23.13.21.18;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	93.07.20.15.16.07;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	93.04.01.03.26.39;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	93.03.20.04.09.04;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	93.03.03.01.47.16;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	93.02.24.21.20.56;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.10.06.23.10.46;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.35.42;	author mike;	state Rel4_0;
branches;
next	9.15;

9.15
date	91.07.03.02.20.13;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	91.06.17.22.49.45;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	91.05.17.00.17.42;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	91.05.16.22.41.10;	author stay;	state Exp;
branches;
next	9.11;

9.11
date	91.03.01.22.43.14;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	91.02.08.22.41.02;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	90.12.08.04.46.48;	author butler;	state Exp;
branches;
next	9.8;

9.8
date	90.05.17.23.20.23;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.05.02.01.11.20;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.02.07.23.44.03;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	89.12.08.22.45.36;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	89.10.10.15.44.14;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	89.08.12.07.28.21;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.08.12.04.37.50;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.44.41;	author mike;	state Rel3_5;
branches;
next	8.4;

8.4
date	89.04.24.06.43.35;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.01.19.19.48.48;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.01.14.30.18;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.24.41;	author mike;	state Rel3_0;
branches;
next	7.9;

7.9
date	88.09.21.04.22.58;	author mike;	state Exp;
branches;
next	7.8;

7.8
date	88.09.20.23.53.41;	author mike;	state Exp;
branches;
next	7.7;

7.7
date	88.09.20.02.34.39;	author mike;	state Exp;
branches;
next	7.6;

7.6
date	88.09.19.22.45.57;	author mike;	state Exp;
branches;
next	7.5;

7.5
date	88.09.13.23.50.09;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.07.15.05.53.03;	author kermit;	state Exp;
branches;
next	7.3;

7.3
date	88.05.13.21.58.38;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.02.05.03.20.47;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.22.47;	author mike;	state Rel;
branches;
next	6.2;

6.2
date	87.09.09.09.43.46;	author stay;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.48.34;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.21.47.32;	author mike;	state Rel;
branches;
next	4.5;

4.5
date	87.05.30.05.54.58;	author phil;	state Exp;
branches;
next	4.4;

4.4
date	87.02.12.22.00.34;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.02.09.17.34.22;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.01.28.22.33.52;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.02.46.14;	author mike;	state Rel1;
branches;
next	2.8;

2.8
date	86.09.23.22.06.30;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	86.07.24.06.02.04;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	86.07.11.01.30.22;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	85.08.16.05.22.23;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	85.07.30.05.33.58;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.07.30.04.13.14;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.05.29.15.47.20;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.03.12.02.01.39;	author mike;	state Prod;
branches;
next	1.1;

1.1
date	84.11.16.19.47.02;	author mike;	state Exp;
branches;
next	;

11.18.2.1
date	2001.02.12.22.17.00;	author butler;	state Exp;
branches;
next	;


desc
@Vector Math package
@


11.24
log
@moved/renamed from top-level h/ to top-level include/
@
text
@/*
 *			V M A T H . H
 *
 *  This header file defines many commonly used 3D vector math macros,
 *  and operates on vect_t, point_t, mat_t, and quat_t objects.
 *
 *  Note that while many people in the computer graphics field use
 *  post-multiplication with row vectors (ie, vector * matrix * matrix ...)
 *  the BRL CAD system uses the more traditional representation of 
 *  column vectors (ie, ... matrix * matrix * vector).  (The matrices
 *  in these two representations are the transposes of each other). Therefore,
 *  when transforming a vector by a matrix, pre-multiplication is used, ie:
 *
 *		view_vec = model2view_mat * model_vec
 *
 *  Furthermore, additional transformations are multiplied on the left, ie:
 *
 *		vec'  =  T1 * vec
 *		vec'' =  T2 * T1 * vec  =  T2 * vec'
 *
 *  The most notable implication of this is the location of the
 *  "delta" (translation) values in the matrix, ie:
 *
 *        x'     ( R0   R1   R2   Dx )      x
 *        y' =   ( R4   R5   R6   Dy )   *  y
 *        z'     ( R8   R9   R10  Dz )      z
 *        w'     (  0    0    0   1/s)      w
 *
 *  Note -
 *	vect_t objects are 3-tuples
 *	hvect_t objects are 4-tuples
 *
 *  Most of these macros require that the result be in
 *  separate storage, distinct from the input parameters,
 *  except where noted.
 *
 *  When writing macros like this, it is very important that any
 *  variables which are declared within code blocks inside a macro
 *  start with an underscore.  This prevents any name conflicts with
 *  user-provided parameters.  For example:
 *	{ register double _f; stuff; }
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Distribution Status -
 *	This file is public domain, distribution unlimited.
 *
 *  Include Sequencing -
 *	#include <stdio.h>
 *	#include <math.h>
 *	#include "machine.h"	/_* For fastf_t definition on this machine *_/
 *	#include "vmath.h"
 *
 *  Libraries Used -
 *	-lm -lc
 *
 *  $Header: /n/xoff/cvs/brlcad/h/vmath.h,v 11.23 2002/05/17 12:27:48 morrison Exp $
 */

#ifndef VMATH_H
#define VMATH_H seen

#ifdef __cplusplus
extern "C" {
#endif

#ifndef M_PI

# define M_E		2.7182818284590452354	/* e */
# define M_LOG2E	1.4426950408889634074	/* log_2 e */
# define M_LOG10E	0.43429448190325182765	/* log_10 e */
# define M_LN2		0.69314718055994530942	/* log_e 2 */
# define M_LN10		2.30258509299404568402	/* log_e 10 */
# define M_PI		3.14159265358979323846	/* pi */
# define M_PI_2		1.57079632679489661923	/* pi/2 */
# define M_PI_4		0.78539816339744830962	/* pi/4 */
# define M_1_PI		0.31830988618379067154	/* 1/pi */
# define M_2_PI		0.63661977236758134308	/* 2/pi */
# define M_2_SQRTPI	1.12837916709551257390	/* 2/sqrt(pi) */
# define M_SQRT2	1.41421356237309504880	/* sqrt(2) */
# define M_SQRT1_2	0.70710678118654752440	/* 1/sqrt(2) */
# define M_SQRT2_DIV2   0.70710678118654752440  /* 1/sqrt(2) */
#endif
#ifndef PI
#  define PI M_PI
#endif

#ifndef sqrt
	/* In case <math.h> has not been included, define sqrt() here */
#	if __STDC__
		extern double sqrt(double);
#	else
#		if (defined(sgi) && defined(mips) && !defined(SGI4D_Rel2))
			/* What could SGI have been thinking of? */
			extern double sqrt(double);
#		else
			extern double sqrt();
#		endif
#	endif
#endif

#define NEAR_ZERO(val,epsilon)	( ((val) > -epsilon) && ((val) < epsilon) )

#define CLAMP(_v, _l, _h) if (_v < _l) _v = _l; else if (_v > _h) _v = _h

#ifdef vax
#	define VDIVIDE_TOL	(1.0e-10)
#	define VUNITIZE_TOL	(1.0e-7)
#else
#	define VDIVIDE_TOL	(1.0e-20)
#	define VUNITIZE_TOL	(1.0e-15)
#endif

#define ELEMENTS_PER_VECT	3	/* # of fastf_t's per vect_t */
#define ELEMENTS_PER_PT         3
#define HVECT_LEN		4	/* # of fastf_t's per hvect_t */
#define HPT_LEN			4
#define ELEMENTS_PER_PLANE	4
#define ELEMENTS_PER_MAT	(4*4)

/*
 * Types for matrixes and vectors.
 */
typedef	fastf_t	mat_t[ELEMENTS_PER_MAT];
typedef	fastf_t	*matp_t;

typedef	fastf_t	vect_t[ELEMENTS_PER_VECT];
typedef	fastf_t	*vectp_t;

typedef fastf_t	point_t[ELEMENTS_PER_PT];
typedef fastf_t	*pointp_t;

typedef fastf_t point2d_t[2];

typedef fastf_t hvect_t[HVECT_LEN];
typedef fastf_t hpoint_t[HPT_LEN];

#define quat_t	hvect_t		/* 4-element quaternion */

/*
 *  Definition of a plane equation:
 *  A plane is defined by a unit-length outward pointing normal vector (N),
 *  and the perpendicular (shortest) distance from the origin to the plane
 *  (in element N[3]).
 *
 *  The plane consists of all points P=(x,y,z) such that
 *	VDOT(P,N) - N[3] == 0
 *  that is,
 *	N[X]*x + N[Y]*y + N[Z]*z - N[3] == 0
 *
 *  The inside of the halfspace bounded by the plane
 *  consists of all points P such that
 *	VDOT(P,N) - N[3] <= 0
 *
 *  A ray with direction D is classified w.r.t. the plane by
 *
 *	VDOT(D,N) < 0	ray enters halfspace defined by plane
 *	VDOT(D,N) == 0	ray is parallel to plane
 *	VDOT(D,N) > 0	ray exits halfspace defined by plane
 */
typedef fastf_t	plane_t[ELEMENTS_PER_PLANE];

/* Compute distance from a point to a plane */
#define DIST_PT_PLANE(_pt, _pl) (VDOT(_pt, _pl) - (_pl)[H])

/* Compute distance between two points */
#define DIST_PT_PT(a,b)		sqrt( \
	((a)[X]-(b)[X])*((a)[X]-(b)[X]) + \
	((a)[Y]-(b)[Y])*((a)[Y]-(b)[Y]) + \
	((a)[Z]-(b)[Z])*((a)[Z]-(b)[Z]) )

/* Element names in homogeneous vector (4-tuple) */
#define	X	0
#define	Y	1
#define Z	2
#define H	3
#define W	H

/* Locations of deltas in 4x4 Homogenous Transform matrix */
#define MDX	3
#define MDY	7
#define MDZ	11
#define MAT_DELTAS(m,x,y,z)	{ \
			(m)[MDX] = (x); \
			(m)[MDY] = (y); \
			(m)[MDZ] = (z); }

#define MAT_DELTAS_VEC(_m,_v)	\
			MAT_DELTAS(_m, (_v)[X], (_v)[Y], (_v)[Z] )
#define MAT_DELTAS_VEC_NEG(_m,_v)	\
			MAT_DELTAS(_m,-(_v)[X],-(_v)[Y],-(_v)[Z] )
#define MAT_DELTAS_GET(_v,_m)	{ \
			(_v)[X] = (_m)[MDX]; \
			(_v)[Y] = (_m)[MDY]; \
			(_v)[Z] = (_m)[MDZ]; }
#define MAT_DELTAS_GET_NEG(_v,_m)	{ \
			(_v)[X] = -(_m)[MDX]; \
			(_v)[Y] = -(_m)[MDY]; \
			(_v)[Z] = -(_m)[MDZ]; }

/* Locations of scaling values in 4x4 Homogenous Transform matrix */
#define MSX	0
#define MSY	5
#define MSZ	10
#define MSA	15

#define MAT_SCALE(_m, _x, _y, _z) { \
	(_m)[MSX] = _x; \
	(_m)[MSY] = _y; \
	(_m)[MSZ] = _z; }

#define MAT_SCALE_VEC(_m, _v) {\
	(_m)[MSX] = (_v)[X]; \
	(_m)[MSY] = (_v)[Y]; \
	(_m)[MSZ] = (_v)[Z]; }

#define MAT_SCALE_ALL(_m, _s) (_m)[MSA] = (_s)


/* Macro versions of librt/mat.c functions, for when speed really matters */
#define MAT_ZERO(m)	{ \
	(m)[0] = (m)[1] = (m)[2] = (m)[3] = \
	(m)[4] = (m)[5] = (m)[6] = (m)[7] = \
	(m)[8] = (m)[9] = (m)[10] = (m)[11] = \
	(m)[12] = (m)[13] = (m)[14] = (m)[15] = 0.0;}

/* #define MAT_ZERO(m)	{\
	register int _j; \
	for(_j=0; _j<16; _j++) (m)[_j]=0.0; }
  */

#define MAT_IDN(m)	{\
	(m)[1] = (m)[2] = (m)[3] = (m)[4] =\
	(m)[6] = (m)[7] = (m)[8] = (m)[9] = \
	(m)[11] = (m)[12] = (m)[13] = (m)[14] = 0.0;\
	(m)[0] = (m)[5] = (m)[10] = (m)[15] = 1.0;}

/* #define MAT_IDN(m)	{\
	int _j;	for(_j=0;_j<16;_j++) (m)[_j]=0.0;\
	(m)[0] = (m)[5] = (m)[10] = (m)[15] = 1.0;}
  */

#define MAT_COPY( d, s )	{ \
	(d)[0] = (s)[0];\
	(d)[1] = (s)[1];\
	(d)[2] = (s)[2];\
	(d)[3] = (s)[3];\
	(d)[4] = (s)[4];\
	(d)[5] = (s)[5];\
	(d)[6] = (s)[6];\
	(d)[7] = (s)[7];\
	(d)[8] = (s)[8];\
	(d)[9] = (s)[9];\
	(d)[10] = (s)[10];\
	(d)[11] = (s)[11];\
	(d)[12] = (s)[12];\
	(d)[13] = (s)[13];\
	(d)[14] = (s)[14];\
	(d)[15] = (s)[15]; }

/* #define MAT_COPY(o,m)   VMOVEN(o,m,16)  */

/* Set vector at `a' to have coordinates `b', `c', `d' */
#define VSET(a,b,c,d)	{ \
			(a)[X] = (b);\
			(a)[Y] = (c);\
			(a)[Z] = (d); }

/* Set all elements of vector to same scalar value */
#define VSETALL(a,s)	{ (a)[X] = (a)[Y] = (a)[Z] = (s); }

#define VSETALLN(v,s,n)  {\
	register int _j;\
	for (_j=0; _j<n; _j++) v[_j]=(s);}

/* Transfer vector at `b' to vector at `a' */
#define VMOVE(a,b)	{ \
			(a)[X] = (b)[X];\
			(a)[Y] = (b)[Y];\
			(a)[Z] = (b)[Z]; }

/* Transfer vector of length `n' at `b' to vector at `a' */
#define VMOVEN(a,b,n) \
	{ register int _vmove; \
	for(_vmove = 0; _vmove < (n); _vmove++) \
		(a)[_vmove] = (b)[_vmove]; \
	}

/* Move a homogeneous 4-tuple */
#define HMOVE(a,b)	{ \
			(a)[X] = (b)[X];\
			(a)[Y] = (b)[Y];\
			(a)[Z] = (b)[Z];\
			(a)[W] = (b)[W]; }

/* This naming convention seems better than the VMOVE_2D version below */
#define V2MOVE(a,b)	{ \
			(a)[X] = (b)[X];\
			(a)[Y] = (b)[Y]; }

/* Reverse the direction of b and store it in a */
#define VREVERSE(a,b)	{ \
			(a)[X] = -(b)[X]; \
			(a)[Y] = -(b)[Y]; \
			(a)[Z] = -(b)[Z]; }

/* Same as VREVERSE, but for a 4-tuple.  Also useful on plane_t objects */
#define HREVERSE(a,b)	{ \
			(a)[X] = -(b)[X]; \
			(a)[Y] = -(b)[Y]; \
			(a)[Z] = -(b)[Z]; \
			(a)[W] = -(b)[W]; }

/* Add vectors at `b' and `c', store result at `a' */
#ifdef SHORT_VECTORS
#define VADD2(a,b,c) VADD2N(a,b,c, 3)
#else
#define VADD2(a,b,c)	{ \
			(a)[X] = (b)[X] + (c)[X];\
			(a)[Y] = (b)[Y] + (c)[Y];\
			(a)[Z] = (b)[Z] + (c)[Z]; }
#endif /* SHORT_VECTORS */

/* Add vectors of length `n' at `b' and `c', store result at `a' */
#define VADD2N(a,b,c,n) \
	{ register int _vadd2; \
	for(_vadd2 = 0; _vadd2 < (n); _vadd2++) \
		(a)[_vadd2] = (b)[_vadd2] + (c)[_vadd2]; \
	}

#define V2ADD2(a,b,c)	{ \
			(a)[X] = (b)[X] + (c)[X];\
			(a)[Y] = (b)[Y] + (c)[Y];}

/* Subtract vector at `c' from vector at `b', store result at `a' */
#ifdef SHORT_VECTORS
#define VSUB2(a,b,c) 	VSUB2N(a,b,c, 3)
#else
#define VSUB2(a,b,c)	{ \
			(a)[X] = (b)[X] - (c)[X];\
			(a)[Y] = (b)[Y] - (c)[Y];\
			(a)[Z] = (b)[Z] - (c)[Z]; }
#endif /* SHORT_VECTORS */

/* Subtract `n' length vector at `c' from vector at `b', store result at `a' */
#define VSUB2N(a,b,c,n) \
	{ register int _vsub2; \
	for(_vsub2 = 0; _vsub2 < (n); _vsub2++) \
		(a)[_vsub2] = (b)[_vsub2] - (c)[_vsub2]; \
	}

#define V2SUB2(a,b,c)	{ \
			(a)[X] = (b)[X] - (c)[X];\
			(a)[Y] = (b)[Y] - (c)[Y];}

/* Vectors:  A = B - C - D */
#ifdef SHORT_VECTORS
#define VSUB3(a,b,c,d) VSUB3(a,b,c,d, 3)
#else
#define VSUB3(a,b,c,d)	{ \
			(a)[X] = (b)[X] - (c)[X] - (d)[X];\
			(a)[Y] = (b)[Y] - (c)[Y] - (d)[Y];\
			(a)[Z] = (b)[Z] - (c)[Z] - (d)[Z]; }
#endif /* SHORT_VECTORS */

/* Vectors:  A = B - C - D for vectors of length `n' */
#define VSUB3N(a,b,c,d,n) \
	{ register int _vsub3; \
	for(_vsub3 = 0; _vsub3 < (n); _vsub3++) \
		(a)[_vsub3] = (b)[_vsub3] - (c)[_vsub3] - (d)[_vsub3]; \
	}

/* Add 3 vectors at `b', `c', and `d', store result at `a' */
#ifdef SHORT_VECTORS
#define VADD3(a,b,c,d) VADD3N(a,b,c,d, 3)
#else
#define VADD3(a,b,c,d)	{ \
			(a)[X] = (b)[X] + (c)[X] + (d)[X];\
			(a)[Y] = (b)[Y] + (c)[Y] + (d)[Y];\
			(a)[Z] = (b)[Z] + (c)[Z] + (d)[Z]; }
#endif /* SHORT_VECTORS */

/* Add 3 vectors of length `n' at `b', `c', and `d', store result at `a' */
#define VADD3N(a,b,c,d,n) \
	{ register int _vadd3; \
	for(_vadd3 = 0; _vadd3 < (n); _vadd3++) \
		(a)[_vadd3] = (b)[_vadd3] + (c)[_vadd3] + (d)[_vadd3]; \
	}

/* Add 4 vectors at `b', `c', `d', and `e', store result at `a' */
#ifdef SHORT_VECTORS
#define VADD4(a,b,c,d,e) VADD4N(a,b,c,d,e, 3)
#else
#define VADD4(a,b,c,d,e) { \
			(a)[X] = (b)[X] + (c)[X] + (d)[X] + (e)[X];\
			(a)[Y] = (b)[Y] + (c)[Y] + (d)[Y] + (e)[Y];\
			(a)[Z] = (b)[Z] + (c)[Z] + (d)[Z] + (e)[Z]; }
#endif /* SHORT_VECTORS */

/* Add 4 `n' length vectors at `b', `c', `d', and `e', store result at `a' */
#define VADD4N(a,b,c,d,e,n) \
	{ register int _vadd4; \
	for(_vadd4 = 0; _vadd4 < (n); _vadd4++) \
		(a)[_vadd4] = (b)[_vadd4] + (c)[_vadd4] + (d)[_vadd4] + (e)[_vadd4];\
	}

/* Scale vector at `b' by scalar `c', store result at `a' */
#ifdef SHORT_VECTORS
#define VSCALE(a,b,c) VSCALEN(a,b,c, 3)
#else
#define VSCALE(a,b,c)	{ \
			(a)[X] = (b)[X] * (c);\
			(a)[Y] = (b)[Y] * (c);\
			(a)[Z] = (b)[Z] * (c); }
#endif /* SHORT_VECTORS */

#define HSCALE(a,b,c)	{ \
			(a)[X] = (b)[X] * (c);\
			(a)[Y] = (b)[Y] * (c);\
			(a)[Z] = (b)[Z] * (c);\
			(a)[W] = (b)[W] * (c); }

/* Scale vector of length `n' at `b' by scalar `c', store result at `a' */
#define VSCALEN(a,b,c,n) \
	{ register int _vscale; \
	for(_vscale = 0; _vscale < (n); _vscale++) \
		(a)[_vscale] = (b)[_vscale] * (c); \
	}

#define V2SCALE(a,b,c)	{ \
			(a)[X] = (b)[X] * (c);\
			(a)[Y] = (b)[Y] * (c); }

/* Normalize vector `a' to be a unit vector */
#ifdef SHORT_VECTORS
#define VUNITIZE(a) { \
	register double _f = MAGSQ(a); \
	register int _vunitize; \
	if ( ! NEAR_ZERO( _f-1.0, VUNITIZE_TOL ) ) { \
		_f = sqrt( _f ); \
		if( _f < VDIVIDE_TOL ) { VSETALL( (a), 0.0 ); } else { \
			_f = 1.0/_f; \
			for(_vunitize = 0; _vunitize < 3; _vunitize++) \
				(a)[_vunitize] *= _f; \
		} \
	} \
}
#else
#define VUNITIZE(a)	{ \
	register double _f = MAGSQ(a); \
	if ( ! NEAR_ZERO( _f-1.0, VUNITIZE_TOL ) ) { \
		_f = sqrt( _f ); \
		if( _f < VDIVIDE_TOL ) { VSETALL( (a), 0.0 ); } else { \
			_f = 1.0/_f; \
			(a)[X] *= _f; (a)[Y] *= _f; (a)[Z] *= _f; \
		} \
	} \
}
#endif /* SHORT_VECTORS */

/* If vector magnitude is too small, return an error code */
#define VUNITIZE_RET(a,ret)	{ \
			register double _f; _f = MAGNITUDE(a); \
			if( _f < VDIVIDE_TOL ) return(ret); \
			_f = 1.0/_f; \
			(a)[X] *= _f; (a)[Y] *= _f; (a)[Z] *= _f; }

/*
 *  Find the sum of two points, and scale the result.
 *  Often used to find the midpoint.
 */
#ifdef SHORT_VECTORS
#define VADD2SCALE( o, a, b, s )	VADD2SCALEN( o, a, b, s, 3 )
#else
#define VADD2SCALE( o, a, b, s )	{ \
					(o)[X] = ((a)[X] + (b)[X]) * (s); \
					(o)[Y] = ((a)[Y] + (b)[Y]) * (s); \
					(o)[Z] = ((a)[Z] + (b)[Z]) * (s); }
#endif

#define VADD2SCALEN( o, a, b, n ) \
	{ register int _vadd2scale; \
	for( _vadd2scale = 0; _vadd2scale < (n); _vadd2scale++ ) \
		(o)[_vadd2scale] = ((a)[_vadd2scale] + (b)[_vadd2scale]) * (s); \
	}

/*
 *  Find the difference between two points, and scale result.
 *  Often used to compute bounding sphere radius given rpp points.
 */
#ifdef SHORT_VECTORS
#define VSUB2SCALE( o, a, b, s )	VSUB2SCALEN( o, a, b, s, 3 )
#else
#define VSUB2SCALE( o, a, b, s )	{ \
					(o)[X] = ((a)[X] - (b)[X]) * (s); \
					(o)[Y] = ((a)[Y] - (b)[Y]) * (s); \
					(o)[Z] = ((a)[Z] - (b)[Z]) * (s); }
#endif

#define VSUB2SCALEN( o, a, b, n ) \
	{ register int _vsub2scale; \
	for( _vsub2scale = 0; _vsub2scale < (n); _vsub2scale++ ) \
		(o)[_vsub2scale] = ((a)[_vsub2scale] - (b)[_vsub2scale]) * (s); \
	}


/*
 *  Combine together several vectors, scaled by a scalar
 */
#ifdef SHORT_VECTORS
#define VCOMB3(o, a,b, c,d, e,f)	VCOMB3N(o, a,b, c,d, e,f, 3)
#else
#define VCOMB3(o, a,b, c,d, e,f)	{\
	(o)[X] = (a) * (b)[X] + (c) * (d)[X] + (e) * (f)[X];\
	(o)[Y] = (a) * (b)[Y] + (c) * (d)[Y] + (e) * (f)[Y];\
	(o)[Z] = (a) * (b)[Z] + (c) * (d)[Z] + (e) * (f)[Z];}
#endif /* SHORT_VECTORS */

#define VCOMB3N(o, a,b, c,d, e,f, n)	{\
	{ register int _vcomb3; \
	for(_vcomb3 = 0; _vcomb3 < (n); _vcomb3++) \
		(o)[_vcomb3] = (a) * (b)[_vcomb3] + (c) * (d)[_vcomb3] + (e) * (f)[_vcomb3]; \
	} }

#ifdef SHORT_VECTORS
#define VCOMB2(o, a,b, c,d)	VCOMB2N(o, a,b, c,d, 3)
#else
#define VCOMB2(o, a,b, c,d)	{\
	(o)[X] = (a) * (b)[X] + (c) * (d)[X];\
	(o)[Y] = (a) * (b)[Y] + (c) * (d)[Y];\
	(o)[Z] = (a) * (b)[Z] + (c) * (d)[Z];}
#endif /* SHORT_VECTORS */

#define VCOMB2N(o, a,b, c,d, n)	{\
	{ register int _vcomb2; \
	for(_vcomb2 = 0; _vcomb2 < (n); _vcomb2++) \
		(o)[_vcomb2] = (a) * (b)[_vcomb2] + (c) * (d)[_vcomb2]; \
	} }

#define VJOIN4(a,b,c,d,e,f,g,h,i,j)	{ \
	(a)[X] = (b)[X] + (c)*(d)[X] + (e)*(f)[X] + (g)*(h)[X] + (i)*(j)[X];\
	(a)[Y] = (b)[Y] + (c)*(d)[Y] + (e)*(f)[Y] + (g)*(h)[Y] + (i)*(j)[Y];\
	(a)[Z] = (b)[Z] + (c)*(d)[Z] + (e)*(f)[Z] + (g)*(h)[Z] + (i)*(j)[Z]; }

#define VJOIN3(a,b,c,d,e,f,g,h)		{ \
	(a)[X] = (b)[X] + (c)*(d)[X] + (e)*(f)[X] + (g)*(h)[X];\
	(a)[Y] = (b)[Y] + (c)*(d)[Y] + (e)*(f)[Y] + (g)*(h)[Y];\
	(a)[Z] = (b)[Z] + (c)*(d)[Z] + (e)*(f)[Z] + (g)*(h)[Z]; }

/* Compose vector at `a' of:
 *	Vector at `b' plus
 *	scalar `c' times vector at `d' plus
 *	scalar `e' times vector at `f'
 */
#ifdef SHORT_VECTORS
#define VJOIN2(a,b,c,d,e,f)	VJOIN2N(a,b,c,d,e,f,3)
#else
#define VJOIN2(a,b,c,d,e,f)	{ \
	(a)[X] = (b)[X] + (c) * (d)[X] + (e) * (f)[X];\
	(a)[Y] = (b)[Y] + (c) * (d)[Y] + (e) * (f)[Y];\
	(a)[Z] = (b)[Z] + (c) * (d)[Z] + (e) * (f)[Z]; }
#endif /* SHORT_VECTORS */

#define VJOIN2N(a,b,c,d,e,f,n)	\
	{ register int _vjoin2; \
	for(_vjoin2 = 0; _vjoin2 < (n); _vjoin2++) \
		(a)[_vjoin2] = (b)[_vjoin2] + (c) * (d)[_vjoin2] + (e) * (f)[_vjoin2]; \
	}

#ifdef SHORT_VECTORS
#define VJOIN1(a,b,c,d)		VJOIN1N(a,b,c,d,3)
#else
#define VJOIN1(a,b,c,d) 	{ \
	(a)[X] = (b)[X] + (c) * (d)[X];\
	(a)[Y] = (b)[Y] + (c) * (d)[Y];\
	(a)[Z] = (b)[Z] + (c) * (d)[Z]; }
#endif /* SHORT_VECTORS */

#define VJOIN1N(a,b,c,d,n) \
	{ register int _vjoin1; \
	for(_vjoin1 = 0; _vjoin1 < (n); _vjoin1++) \
		(a)[_vjoin1] = (b)[_vjoin1] + (c) * (d)[_vjoin1]; \
	}

#define HJOIN1(a,b,c,d)	{ \
			(a)[X] = (b)[X] + (c) * (d)[X]; \
			(a)[Y] = (b)[Y] + (c) * (d)[Y]; \
			(a)[Z] = (b)[Z] + (c) * (d)[Z]; \
			(a)[W] = (b)[W] + (c) * (d)[W]; }

#define V2JOIN1(a,b,c,d) 	{ \
			(a)[X] = (b)[X] + (c) * (d)[X];\
			(a)[Y] = (b)[Y] + (c) * (d)[Y]; }

/*
 *  Blend into vector `a'
 *	scalar `b' times vector at `c' plus
 *	scalar `d' times vector at `e'
 */
#ifdef SHORT_VECTORS
#define VBLEND2(a,b,c,d,e)	VBLEND2N(a,b,c,d,e,3)
#else
#define VBLEND2(a,b,c,d,e)	{ \
	(a)[X] = (b) * (c)[X] + (d) * (e)[X];\
	(a)[Y] = (b) * (c)[Y] + (d) * (e)[Y];\
	(a)[Z] = (b) * (c)[Z] + (d) * (e)[Z]; }
#endif /* SHORT_VECTORS */

#define VBLEND2N(a,b,c,d,e,n)	\
	{ register int _vblend2; \
	for(_vblend2 = 0; _vblend2 < (n); _vblend2++) \
		(a)[_vblend2] = (b) * (c)[_vblend2] + (d) * (e)[_vblend2]; \
	}

/* Return scalar magnitude squared of vector at `a' */
#define MAGSQ(a)	( (a)[X]*(a)[X] + (a)[Y]*(a)[Y] + (a)[Z]*(a)[Z] )
#define MAG2SQ(a)	( (a)[X]*(a)[X] + (a)[Y]*(a)[Y] )

/* Return scalar magnitude of vector at `a' */
#define MAGNITUDE(a)	sqrt( MAGSQ( a ) )

/*
 *  Store cross product of vectors at `b' and `c' in vector at `a'.
 *  Note that the "right hand rule" applies:
 *  If closing your right hand goes from `b' to `c', then your
 *  thumb points in the direction of the cross product.
 *
 *  If the angle from `b' to `c' goes clockwise, then 
 *  the result vector points "into" the plane (inward normal).
 *  Example:  b=(0,1,0), c=(1,0,0), then bXc=(0,0,-1).
 *
 *  If the angle from `b' to `c' goes counter-clockwise, then
 *  the result vector points "out" of the plane.
 *  This outward pointing normal is the BRL convention.
 */
#define VCROSS(a,b,c)	{ \
			(a)[X] = (b)[Y] * (c)[Z] - (b)[Z] * (c)[Y];\
			(a)[Y] = (b)[Z] * (c)[X] - (b)[X] * (c)[Z];\
			(a)[Z] = (b)[X] * (c)[Y] - (b)[Y] * (c)[X]; }

/* Compute dot product of vectors at `a' and `b' */
#define VDOT(a,b)	( (a)[X]*(b)[X] + (a)[Y]*(b)[Y] + (a)[Z]*(b)[Z] )

#define V2DOT(a,b)	( (a)[X]*(b)[X] + (a)[Y]*(b)[Y] )

/* Subtract two points to make a vector, dot with another vector */
#define VSUB2DOT(_pt2, _pt, _vec)	( \
	((_pt2)[X] - (_pt)[X]) * (_vec)[X] + \
	((_pt2)[Y] - (_pt)[Y]) * (_vec)[Y] + \
	((_pt2)[Z] - (_pt)[Z]) * (_vec)[Z] )

/* Turn a vector into comma-separated list of elements, for subroutine args */
#define V2ARGS(a)	(a)[X], (a)[Y]
#define V3ARGS(a)	(a)[X], (a)[Y], (a)[Z]
#define V4ARGS(a)	(a)[X], (a)[Y], (a)[Z], (a)[W]

/* Print vector name and components on stdout */
#define V2PRINT(a,b)	\
	(void)fprintf(stderr,"%s (%g, %g)\n", a, V2ARGS(b) );
#define VPRINT(a,b)	\
	(void)fprintf(stderr,"%s (%g, %g, %g)\n", a, V3ARGS(b) );
#define HPRINT(a,b)	\
	(void)fprintf(stderr,"%s (%g, %g, %g, %g)\n", a, V4ARGS(b) );

#ifdef __cplusplus
#define CPP_V3PRINT( _os, _title, _p )	(_os) << (_title) << "=(" << \
	(_p)[X] << ", " << (_p)[Y] << ")\n";
#define CPP_VPRINT( _os, _title, _p )	(_os) << (_title) << "=(" << \
	(_p)[X] << ", " << (_p)[Y] << ", " << (_p)[Z] << ")\n";
#define CPP_HPRINT( _os, _title, _p )	(_os) << (_title) << "=(" << \
	(_p)[X] << ", " << (_p)[Y] << ", " << (_p)[Z] << "," << (_p)[W]<< ")\n";
#endif

/* Vector element multiplication.  Really: diagonal matrix X vect */
#ifdef SHORT_VECTORS
#define VELMUL(a,b,c) \
	{ register int _velmul; \
	for(_velmul = 0; _velmul < 3; _velmul++) \
		(a)[_velmul] = (b)[_velmul] * (c)[_velmul]; \
	}
#else
#define VELMUL(a,b,c) 	{ \
	(a)[X] = (b)[X] * (c)[X];\
	(a)[Y] = (b)[Y] * (c)[Y];\
	(a)[Z] = (b)[Z] * (c)[Z]; }
#endif /* SHORT_VECTORS */

#ifdef SHORT_VECTORS
#define VELMUL3(a,b,c,d) \
	{ register int _velmul; \
	for(_velmul = 0; _velmul < 3; _velmul++) \
		(a)[_velmul] = (b)[_velmul] * (c)[_velmul] * (d)[_velmul]; \
	}
#else
#define VELMUL3(a,b,c,d) 	{ \
	(a)[X] = (b)[X] * (c)[X] * (d)[X];\
	(a)[Y] = (b)[Y] * (c)[Y] * (d)[Y];\
	(a)[Z] = (b)[Z] * (c)[Z] * (d)[Z]; }
#endif /* SHORT_VECTORS */

/* Similar to VELMUL */
#define VELDIV(a,b,c)	{ \
	(a)[0] = (b)[0] / (c)[0];\
	(a)[1] = (b)[1] / (c)[1];\
	(a)[2] = (b)[2] / (c)[2]; }

/* Given a direction vector, compute the inverses of each element. */
/* When division by zero would have occured, mark inverse as INFINITY. */
#define VINVDIR( _inv, _dir )	{ \
	if( (_dir)[X] < -SQRT_SMALL_FASTF || (_dir)[X] > SQRT_SMALL_FASTF )  { \
		(_inv)[X]=1.0/(_dir)[X]; \
	} else { \
		(_dir)[X] = 0.0; \
		(_inv)[X] = INFINITY; \
	} \
	if( (_dir)[Y] < -SQRT_SMALL_FASTF || (_dir)[Y] > SQRT_SMALL_FASTF )  { \
		(_inv)[Y]=1.0/(_dir)[Y]; \
	} else { \
		(_dir)[Y] = 0.0; \
		(_inv)[Y] = INFINITY; \
	} \
	if( (_dir)[Z] < -SQRT_SMALL_FASTF || (_dir)[Z] > SQRT_SMALL_FASTF )  { \
		(_inv)[Z]=1.0/(_dir)[Z]; \
	} else { \
		(_dir)[Z] = 0.0; \
		(_inv)[Z] = INFINITY; \
	} \
    }

/* Apply the 3x3 part of a mat_t to a 3-tuple. */
/* This rotates a vector without scaling it (changing its length) */
#ifdef SHORT_VECTORS
#define MAT3X3VEC(o,mat,vec) \
	{ register int _m3x3v; \
	for(_m3x3v = 0; _m3x3v < 3; _m3x3v++) \
		(o)[_m3x3v] = (mat)[4*_m3x3v+0]*(vec)[X] + \
			  (mat)[4*_m3x3v+1]*(vec)[Y] + \
			  (mat)[4*_m3x3v+2]*(vec)[Z]; \
	}
#else
#define MAT3X3VEC(o,mat,vec) 	{ \
	(o)[X] = (mat)[X]*(vec)[X]+(mat)[Y]*(vec)[Y] + (mat)[ 2]*(vec)[Z]; \
	(o)[Y] = (mat)[4]*(vec)[X]+(mat)[5]*(vec)[Y] + (mat)[ 6]*(vec)[Z]; \
	(o)[Z] = (mat)[8]*(vec)[X]+(mat)[9]*(vec)[Y] + (mat)[10]*(vec)[Z]; }
#endif /* SHORT_VECTORS */

/* Multiply a 3-tuple by the 3x3 part of a mat_t. */
#ifdef SHORT_VECTORS
#define VEC3X3MAT(o,i,m) \
	{ register int _v3x3m; \
	for(_v3x3m = 0; _v3x3m < 3; _v3x3m++) \
		(o)[_v3x3m] = (i)[X]*(m)[_v3x3m] + \
			(i)[Y]*(m)[_v3x3m+4] + \
			(i)[Z]*(m)[_v3x3m+8]; \
	}
#else
#define VEC3X3MAT(o,i,m) 	{ \
	(o)[X] = (i)[X]*(m)[X] + (i)[Y]*(m)[4] + (i)[Z]*(m)[8]; \
	(o)[Y] = (i)[X]*(m)[1] + (i)[Y]*(m)[5] + (i)[Z]*(m)[9]; \
	(o)[Z] = (i)[X]*(m)[2] + (i)[Y]*(m)[6] + (i)[Z]*(m)[10]; }
#endif /* SHORT_VECTORS */

/* Apply the 3x3 part of a mat_t to a 2-tuple (Z part=0). */
#ifdef SHORT_VECTORS
#define MAT3X2VEC(o,mat,vec) \
	{ register int _m3x2v; \
	for(_m3x2v = 0; _m3x2v < 3; _m3x2v++) \
		(o)[_m3x2v] = (mat)[4*_m3x2v]*(vec)[X] + \
			(mat)[4*_m3x2v+1]*(vec)[Y]; \
	}
#else
#define MAT3X2VEC(o,mat,vec) 	{ \
	(o)[X] = (mat)[0]*(vec)[X] + (mat)[Y]*(vec)[Y]; \
	(o)[Y] = (mat)[4]*(vec)[X] + (mat)[5]*(vec)[Y]; \
	(o)[Z] = (mat)[8]*(vec)[X] + (mat)[9]*(vec)[Y]; }
#endif /* SHORT_VECTORS */

/* Multiply a 2-tuple (Z=0) by the 3x3 part of a mat_t. */
#ifdef SHORT_VECTORS
#define VEC2X3MAT(o,i,m) \
	{ register int _v2x3m; \
	for(_v2x3m = 0; _v2x3m < 3; _v2x3m++) \
		(o)[_v2x3m] = (i)[X]*(m)[_v2x3m] + (i)[Y]*(m)[2*_v2x3m]; \
	}
#else
#define VEC2X3MAT(o,i,m) 	{ \
	(o)[X] = (i)[X]*(m)[0] + (i)[Y]*(m)[4]; \
	(o)[Y] = (i)[X]*(m)[1] + (i)[Y]*(m)[5]; \
	(o)[Z] = (i)[X]*(m)[2] + (i)[Y]*(m)[6]; }
#endif /* SHORT_VECTORS */

/* Apply a 4x4 matrix to a 3-tuple which is an absolute Point in space */
#ifdef SHORT_VECTORS
#define MAT4X3PNT(o,m,i) \
	{ register double _f; \
	register int _i_m4x3p, _j_m4x3p; \
	_f = 0.0; \
	for(_j_m4x3p = 0; _j_m4x3p < 3; _j_m4x3p++)  \
		_f += (m)[_j_m4x3p+12] * (i)[_j_m4x3p]; \
	_f = 1.0/(_f + (m)[15]); \
	for(_i_m4x3p = 0; _i_m4x3p < 3; _i_m4x3p++) \
		(o)[_i_m4x3p] = 0.0; \
	for(_i_m4x3p = 0; _i_m4x3p < 3; _i_m4x3p++)  { \
		for(_j_m4x3p = 0; _j_m4x3p < 3; _j_m4x3p++) \
			(o)[_i_m4x3p] += (m)[_j_m4x3p+4*_i_m4x3p] * (i)[_j_m4x3p]; \
	} \
	for(_i_m4x3p = 0; _i_m4x3p < 3; _i_m4x3p++)  { \
		(o)[_i_m4x3p] = ((o)[_i_m4x3p] + (m)[4*_i_m4x3p+3]) * _f; \
	} }
#else
#define MAT4X3PNT(o,m,i) \
	{ register double _f; \
	_f = 1.0/((m)[12]*(i)[X] + (m)[13]*(i)[Y] + (m)[14]*(i)[Z] + (m)[15]);\
	(o)[X]=((m)[0]*(i)[X] + (m)[1]*(i)[Y] + (m)[ 2]*(i)[Z] + (m)[3]) * _f;\
	(o)[Y]=((m)[4]*(i)[X] + (m)[5]*(i)[Y] + (m)[ 6]*(i)[Z] + (m)[7]) * _f;\
	(o)[Z]=((m)[8]*(i)[X] + (m)[9]*(i)[Y] + (m)[10]*(i)[Z] + (m)[11])* _f;}
#endif /* SHORT_VECTORS */

/* Multiply an Absolute 3-Point by a full 4x4 matrix. */
#define PNT3X4MAT(o,i,m) \
	{ register double _f; \
	_f = 1.0/((i)[X]*(m)[3] + (i)[Y]*(m)[7] + (i)[Z]*(m)[11] + (m)[15]);\
	(o)[X]=((i)[X]*(m)[0] + (i)[Y]*(m)[4] + (i)[Z]*(m)[8] + (m)[12]) * _f;\
	(o)[Y]=((i)[X]*(m)[1] + (i)[Y]*(m)[5] + (i)[Z]*(m)[9] + (m)[13]) * _f;\
	(o)[Z]=((i)[X]*(m)[2] + (i)[Y]*(m)[6] + (i)[Z]*(m)[10] + (m)[14])* _f;}

/* Multiply an Absolute hvect_t 4-Point by a full 4x4 matrix. */
#ifdef SHORT_VECTORS
#define MAT4X4PNT(o,m,i) \
	{ register int _i_m4x4p, _j_m4x4p; \
	for(_i_m4x4p = 0; _i_m4x4p < 4; _i_m4x4p++) \
		(o)[_i_m4x4p] = 0.0; \
	for(_i_m4x4p = 0; _i_m4x4p < 4; _i_m4x4p++) \
		for(_j_m4x4p = 0; _j_m4x4p < 4; _j_m4x4p++) \
			(o)[_i_m4x4p] += (m)[_j_m4x4p+4*_i_m4x4p] * (i)[_j_m4x4p]; \
	}
#else
#define MAT4X4PNT(o,m,i) 	{ \
	(o)[X]=(m)[ 0]*(i)[X] + (m)[ 1]*(i)[Y] + (m)[ 2]*(i)[Z] + (m)[ 3]*(i)[H];\
	(o)[Y]=(m)[ 4]*(i)[X] + (m)[ 5]*(i)[Y] + (m)[ 6]*(i)[Z] + (m)[ 7]*(i)[H];\
	(o)[Z]=(m)[ 8]*(i)[X] + (m)[ 9]*(i)[Y] + (m)[10]*(i)[Z] + (m)[11]*(i)[H];\
	(o)[H]=(m)[12]*(i)[X] + (m)[13]*(i)[Y] + (m)[14]*(i)[Z] + (m)[15]*(i)[H]; }
#endif /* SHORT_VECTORS */

/* Apply a 4x4 matrix to a 3-tuple which is a relative Vector in space */
/* This macro can scale the length of the vector if [15] != 1.0 */
#ifdef SHORT_VECTORS
#define MAT4X3VEC(o,m,i) \
	{ register double _f; \
	register int _i_m4x3v, _j_m4x3v; \
	_f = 1.0/((m)[15]); \
	for(_i_m4x3v = 0; _i_m4x3v < 3; _i_m4x3v++) \
		(o)[_i_m4x3v] = 0.0; \
	for(_i_m4x3v = 0; _i_m4x3v < 3; _i_m4x3v++) { \
		for(_j_m4x3v = 0; _j_m4x3v < 3; _j_m4x3v++) \
			(o)[_i_m4x3v] += (m)[_j_m4x3v+4*_i_m4x3v] * (i)[_j_m4x3v]; \
	} \
	for(_i_m4x3v = 0; _i_m4x3v < 3; _i_m4x3v++) { \
		(o)[_i_m4x3v] *= _f; \
	} }
#else
#define MAT4X3VEC(o,m,i) \
	{ register double _f;	_f = 1.0/((m)[15]);\
	(o)[X] = ((m)[0]*(i)[X] + (m)[1]*(i)[Y] + (m)[ 2]*(i)[Z]) * _f; \
	(o)[Y] = ((m)[4]*(i)[X] + (m)[5]*(i)[Y] + (m)[ 6]*(i)[Z]) * _f; \
	(o)[Z] = ((m)[8]*(i)[X] + (m)[9]*(i)[Y] + (m)[10]*(i)[Z]) * _f; }
#endif /* SHORT_VECTORS */

#define MAT4XSCALOR(o,m,i) \
	{(o) = (i) / (m)[15];}

/* Multiply a Relative 3-Vector by most of a 4x4 matrix */
#define VEC3X4MAT(o,i,m) \
	{ register double _f; 	_f = 1.0/((m)[15]); \
	(o)[X] = ((i)[X]*(m)[0] + (i)[Y]*(m)[4] + (i)[Z]*(m)[8]) * _f; \
	(o)[Y] = ((i)[X]*(m)[1] + (i)[Y]*(m)[5] + (i)[Z]*(m)[9]) * _f; \
	(o)[Z] = ((i)[X]*(m)[2] + (i)[Y]*(m)[6] + (i)[Z]*(m)[10]) * _f; }

/* Multiply a Relative 2-Vector by most of a 4x4 matrix */
#define VEC2X4MAT(o,i,m) \
	{ register double _f; 	_f = 1.0/((m)[15]); \
	(o)[X] = ((i)[X]*(m)[0] + (i)[Y]*(m)[4]) * _f; \
	(o)[Y] = ((i)[X]*(m)[1] + (i)[Y]*(m)[5]) * _f; \
	(o)[Z] = ((i)[X]*(m)[2] + (i)[Y]*(m)[6]) * _f; }

/* Test a vector for non-unit length */
#define BN_VEC_NON_UNIT_LEN(_vec)	\
	(fabs(MAGSQ(_vec)) < 0.0001 || fabs(fabs(MAGSQ(_vec))-1) > 0.0001)

/* Compare two vectors for EXACT equality.  Use carefully. */
#define VEQUAL(a,b)	((a)[X]==(b)[X] && (a)[Y]==(b)[Y] && (a)[Z]==(b)[Z])

/*
 *  Compare two vectors for approximate equality,
 *  within the specified absolute tolerance.
 */
#define VAPPROXEQUAL(a,b,tol)	( \
	NEAR_ZERO( (a)[X]-(b)[X], tol ) && \
	NEAR_ZERO( (a)[Y]-(b)[Y], tol ) && \
	NEAR_ZERO( (a)[Z]-(b)[Z], tol ) )

/* Test for all elements of `v' being smaller than `tol' */
#define VNEAR_ZERO(v, tol)	( \
	NEAR_ZERO(v[X],tol) && NEAR_ZERO(v[Y],tol) && NEAR_ZERO(v[Z],tol)  )

/* Macros to update min and max X,Y,Z values to contain a point */
#define V_MIN(r,s)	if( (s) < (r) ) r = (s)
#define V_MAX(r,s)	if( (s) > (r) ) r = (s)
#define VMIN(r,s)	{ V_MIN((r)[X],(s)[X]); V_MIN((r)[Y],(s)[Y]); V_MIN((r)[Z],(s)[Z]); }
#define VMAX(r,s)	{ V_MAX((r)[X],(s)[X]); V_MAX((r)[Y],(s)[Y]); V_MAX((r)[Z],(s)[Z]); }
#define VMINMAX( min, max, pt )	{ VMIN( (min), (pt) ); VMAX( (max), (pt) ); }

/* Divide out homogeneous parameter from hvect_t, creating vect_t */
#ifdef SHORT_VECTORS
#define HDIVIDE(a,b)  \
	{ register int _hdivide; \
	for(_hdivide = 0; _hdivide < 3; _hdivide++) \
		(a)[_hdivide] = (b)[_hdivide] / (b)[H]; \
	}
#else
#define HDIVIDE(a,b)  { \
	(a)[X] = (b)[X] / (b)[H];\
	(a)[Y] = (b)[Y] / (b)[H];\
	(a)[Z] = (b)[Z] / (b)[H]; }
#endif /* SHORT_VECTORS */

/*
 *  Some 2-D versions of the 3-D macros given above.
 *
 *  A better naming convention is V2MOVE() rather than VMOVE_2D().
 *  XXX These xxx_2D names are slated to go away, use the others.
 */
#define VADD2_2D(a,b,c)	V2ADD2(a,b,c)
#define VSUB2_2D(a,b,c)	V2SUB2(a,b,c)
#define MAGSQ_2D(a)	MAG2SQ(a)
#define VDOT_2D(a,b)	V2DOT(a,b)
#define VMOVE_2D(a,b)	V2MOVE(a,b)
#define VSCALE_2D(a,b,c)	V2SCALE(a,b,c)
#define VJOIN1_2D(a,b,c,d) 	V2JOIN1(a,b,c,d)

/*
 *  Quaternion math definitions.
 *
 *  Note that the W component will be put in the last [3] place
 *  rather than the first [0] place,
 *  so that the X, Y, Z elements will be compatible with vectors.
 *  Only QUAT_FROM_VROT macros depend on component locations, however.
 *
 *  Phillip Dykstra, 26 Sep 1985.
 *  Lee A. Butler, 14 March 1996.
 */
 
/* Create Quaternion from Vector and Rotation about vector.
 *
 * To produce a quaternion representing a rotation by PI radians about X-axis:
 *
 *	VSET(axis, 1, 0, 0);
 *	QUAT_FROM_VROT( quat, M_PI, axis);
 *		or
 *	QUAT_FROM_ROT( quat, M_PI, 1.0, 0.0, 0.0, 0.0 );
 *
 *  Alternatively, in degrees:
 *	QUAT_FROM_ROT_DEG( quat, 180.0, 1.0, 0.0, 0.0, 0.0 );
 *
 */
#define QUAT_FROM_ROT(q, r, x, y, z){ \
	register fastf_t _rot = (r) * 0.5; \
	QSET(q, x, y, z, cos(_rot)); \
	VUNITIZE(q); \
	_rot = sin(_rot); /* _rot is really just a temp variable now */ \
	VSCALE(q, q, _rot ); }

#define QUAT_FROM_VROT(q, r, v) { \
	register fastf_t _rot = (r) * 0.5; \
	VMOVE(q, v); \
	VUNITIZE(q); \
	(q)[W] = cos(_rot); \
	_rot = sin(_rot); /* _rot is really just a temp variable now */ \
	VSCALE(q, q, _rot ); }

#define QUAT_FROM_VROT_DEG(q, r, v) \
	QUAT_FROM_VROT(q, ((r)*(M_PI/180.0)), v)

#define QUAT_FROM_ROT_DEG(q, r, x, y, z) \
	QUAT_FROM_ROT(q, ((r)*(M_PI/180.0)), x, y, z)



/* Set quaternion at `a' to have coordinates `b', `c', `d', `e' */
#define QSET(a,b,c,d,e)	{ \
			(a)[X] = (b);\
			(a)[Y] = (c);\
			(a)[Z] = (d);\
			(a)[W] = (e); }

/* Transfer quaternion at `b' to quaternion at `a' */
#define QMOVE(a,b)	{ \
			(a)[X] = (b)[X];\
			(a)[Y] = (b)[Y];\
			(a)[Z] = (b)[Z];\
			(a)[W] = (b)[W]; }

/* Add quaternions at `b' and `c', store result at `a' */
#define QADD2(a,b,c)	{ \
			(a)[X] = (b)[X] + (c)[X];\
			(a)[Y] = (b)[Y] + (c)[Y];\
			(a)[Z] = (b)[Z] + (c)[Z];\
			(a)[W] = (b)[W] + (c)[W]; }

/* Subtract quaternion at `c' from quaternion at `b', store result at `a' */
#define QSUB2(a,b,c)	{ \
			(a)[X] = (b)[X] - (c)[X];\
			(a)[Y] = (b)[Y] - (c)[Y];\
			(a)[Z] = (b)[Z] - (c)[Z];\
			(a)[W] = (b)[W] - (c)[W]; }

/* Scale quaternion at `b' by scalar `c', store result at `a' */
#define QSCALE(a,b,c)	{ \
			(a)[X] = (b)[X] * (c);\
			(a)[Y] = (b)[Y] * (c);\
			(a)[Z] = (b)[Z] * (c);\
			(a)[W] = (b)[W] * (c); }

/* Normalize quaternion 'a' to be a unit quaternion */
#define QUNITIZE(a)	{register double _f; _f = QMAGNITUDE(a); \
			if( _f < VDIVIDE_TOL ) _f = 0.0; else _f = 1.0/_f; \
			(a)[X] *= _f; (a)[Y] *= _f; (a)[Z] *= _f; (a)[W] *= _f; }

/* Return scalar magnitude squared of quaternion at `a' */
#define QMAGSQ(a)	( (a)[X]*(a)[X] + (a)[Y]*(a)[Y] \
			+ (a)[Z]*(a)[Z] + (a)[W]*(a)[W] )

/* Return scalar magnitude of quaternion at `a' */
#define QMAGNITUDE(a)	sqrt( QMAGSQ( a ) )

/* Compute dot product of quaternions at `a' and `b' */
#define QDOT(a,b)	( (a)[X]*(b)[X] + (a)[Y]*(b)[Y] \
			+ (a)[Z]*(b)[Z] + (a)[W]*(b)[W] )

/*
 *  Compute quaternion product a = b * c
 *	a[W] = b[W]*c[W] - VDOT(b,c);
	VCROSS( temp, b, c );
 *	VJOIN2( a, temp, b[W], c, c[W], b );
 */
#define QMUL(a,b,c)	{ \
    (a)[W] = (b)[W]*(c)[W] - (b)[X]*(c)[X] - (b)[Y]*(c)[Y] - (b)[Z]*(c)[Z]; \
    (a)[X] = (b)[W]*(c)[X] + (b)[X]*(c)[W] + (b)[Y]*(c)[Z] - (b)[Z]*(c)[Y]; \
    (a)[Y] = (b)[W]*(c)[Y] + (b)[Y]*(c)[W] + (b)[Z]*(c)[X] - (b)[X]*(c)[Z]; \
    (a)[Z] = (b)[W]*(c)[Z] + (b)[Z]*(c)[W] + (b)[X]*(c)[Y] - (b)[Y]*(c)[X]; }

/* Conjugate quaternion */
#define QCONJUGATE(a,b)	{ \
	(a)[X] = -(b)[X]; \
	(a)[Y] = -(b)[Y]; \
	(a)[Z] = -(b)[Z]; \
	(a)[W] =  (b)[W]; }

/* Multiplicative inverse quaternion */
#define QINVERSE(a,b)	{ register double _f = QMAGSQ(b); \
	if( _f < VDIVIDE_TOL ) _f = 0.0; else _f = 1.0/_f; \
	(a)[X] = -(b)[X] * _f; \
	(a)[Y] = -(b)[Y] * _f; \
	(a)[Z] = -(b)[Z] * _f; \
	(a)[W] =  (b)[W] * _f; }

/*
 *  Blend into quaternion `a'
 *	scalar `b' times quaternion at `c' plus
 *	scalar `d' times quaternion at `e'
 */
#ifdef SHORT_VECTORS
#define QBLEND2(a,b,c,d,e)	VBLEND2N(a,b,c,d,e,4)
#else
#define QBLEND2(a,b,c,d,e)	{ \
	(a)[X] = (b) * (c)[X] + (d) * (e)[X];\
	(a)[Y] = (b) * (c)[Y] + (d) * (e)[Y];\
	(a)[Z] = (b) * (c)[Z] + (d) * (e)[Z];\
	(a)[W] = (b) * (c)[W] + (d) * (e)[W]; }
#endif /* SHORT_VECTORS */

/*
 *  Macros for dealing with 3-D "extents" represented as axis-aligned
 *  right parallelpipeds (RPPs).
 *  This is stored as two points:  a min point, and a max point.
 *  RPP 1 is defined by lo1, hi1, RPP 2 by lo2, hi2.
 */

/* Compare two extents represented as RPPs. If they are disjoint, return true */
#define V3RPP_DISJOINT(_l1, _h1, _l2, _h2) \
      ( (_l1)[X] > (_h2)[X] || (_l1)[Y] > (_h2)[Y] || (_l1)[Z] > (_h2)[Z] || \
	(_l2)[X] > (_h1)[X] || (_l2)[Y] > (_h1)[Y] || (_l2)[Z] > (_h1)[Z] )

/* Compare two extents represented as RPPs. If they overlap, return true */
#define V3RPP_OVERLAP(_l1, _h1, _l2, _h2) \
    (! ((_l1)[X] > (_h2)[X] || (_l1)[Y] > (_h2)[Y] || (_l1)[Z] > (_h2)[Z] || \
	(_l2)[X] > (_h1)[X] || (_l2)[Y] > (_h1)[Y] || (_l2)[Z] > (_h1)[Z]) )

/* If two extents overlap within distance tolerance, return true. */
#define V3RPP_OVERLAP_TOL(_l1, _h1, _l2, _h2, _t) \
    (! ((_l1)[X] > (_h2)[X] + (_t)->dist || \
	(_l1)[Y] > (_h2)[Y] + (_t)->dist || \
	(_l1)[Z] > (_h2)[Z] + (_t)->dist || \
	(_l2)[X] > (_h1)[X] + (_t)->dist || \
	(_l2)[Y] > (_h1)[Y] + (_t)->dist || \
	(_l2)[Z] > (_h1)[Z] + (_t)->dist ) )

/* Is the point within or on the boundary of the RPP? */
#define V3PT_IN_RPP(_pt, _lo, _hi)	( \
	(_pt)[X] >= (_lo)[X] && (_pt)[X] <= (_hi)[X] && \
	(_pt)[Y] >= (_lo)[Y] && (_pt)[Y] <= (_hi)[Y] && \
	(_pt)[Z] >= (_lo)[Z] && (_pt)[Z] <= (_hi)[Z]  )

/* Within the distance tolerance, is the point within the RPP? */
#define V3PT_IN_RPP_TOL(_pt, _lo, _hi, _t)	( \
	(_pt)[X] >= (_lo)[X]-(_t)->dist && (_pt)[X] <= (_hi)[X]+(_t)->dist && \
	(_pt)[Y] >= (_lo)[Y]-(_t)->dist && (_pt)[Y] <= (_hi)[Y]+(_t)->dist && \
	(_pt)[Z] >= (_lo)[Z]-(_t)->dist && (_pt)[Z] <= (_hi)[Z]+(_t)->dist  )

/*
 * Determine if one bounding box is within another.
 * Also returns true if the boxes are the same.
 */
#define V3RPP1_IN_RPP2( _lo1 , _hi1 , _lo2 , _hi2 )	( \
	(_lo1)[X] >= (_lo2)[X] && (_hi1)[X] <= (_hi2)[X] && \
	(_lo1)[Y] >= (_lo2)[Y] && (_hi1)[Y] <= (_hi2)[Y] && \
	(_lo1)[Z] >= (_lo2)[Z] && (_hi1)[Z] <= (_hi2)[Z] )

#ifdef __cplusplus
}
#endif

#endif /* VMATH_H */
@


11.23
log
@cleaned up comment marks for readability
@
text
@d62 1
a62 1
 *  $Header: /c/CVS/brlcad/h/vmath.h,v 11.22 2001/10/15 21:55:00 kermit Exp $
@


11.22
log
@added math.h defines
@
text
@d62 1
a62 1
 *  $Header: /c/CVS/brlcad/h/vmath.h,v 11.21 2001/04/02 21:37:53 morrison Exp $
d231 2
a232 2
  /*
#define MAT_ZERO(m)	{\
d242 2
a243 2
  /*
#define MAT_IDN(m)	{\
d265 2
a266 3
  /*
#define MAT_COPY(o,m)   VMOVEN(o,m,16)
  */
@


11.21
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d62 1
a62 1
 *  $Header: /c/CVS/brlcad/h/vmath.h,v 11.20 2001/03/29 13:26:32 morrison Exp $
d70 21
@


11.20
log
@added performance modified versions of the identity and zero'ing matrix functions/macros in h/vmath.h and h/bn.h

all tests to date showed that there was no considerable increase in code size, and all compilers tested (gcc and irix cc on linux, irix, and freebsd) showed up to 6X speed increase and outperformed the alternatives regardless of optimization used.
@
text
@d62 1
a62 1
 *  $Header: /c/CVS/brlcad/h/vmath.h,v 11.19 2001/03/19 22:19:25 butler Exp $
d227 18
d246 1
@


11.19
log
@patches to merge 5.3 into 6.0
@
text
@d62 1
a62 1
 *  $Header: /d/CVS/brlcad/h/vmath.h,v 11.18.2.1 2001/02/12 22:17:00 butler Exp $
d205 6
d214 1
d217 6
d225 1
@


11.18
log
@
Added a new macro from raytrace.h
@
text
@d62 1
a62 1
 *  $Header: /c/CVS/brlcad/h/vmath.h,v 11.17 2000/03/29 18:11:42 mike Exp $
d859 2
a860 2
#define V_MIN(r,s)	if( (r) > (s) ) r = (s)
#define V_MAX(r,s)	if( (r) < (s) ) r = (s)
@


11.18.2.1
log
@rtgeom.h comment changed on DSP
vmath.h modified to skip copy in VMINMAX when values are equal
@
text
@d62 1
a62 1
 *  $Header: /c/CVS/brlcad/h/vmath.h,v 11.18 2000/05/09 20:42:59 mike Exp $
d859 2
a860 2
#define V_MIN(r,s)	if( (s) < (r) ) r = (s)
#define V_MAX(r,s)	if( (s) > (r) ) r = (s)
@


11.17
log
@
Improved comment.
@
text
@d62 1
a62 1
 *  $Header: /c/CVS/brlcad/h/vmath.h,v 11.16 2000/02/20 03:45:50 butler Exp $
d1038 1
d1041 5
d1060 1
a1060 1
/* Is the point within the RPP? */
@


11.16
log
@Added CLAMP() macro
@
text
@d62 1
a62 1
 *  $Header: /c/CVS/brlcad/h/vmath.h,v 11.15 2000/02/14 21:28:57 mike Exp $
d1066 4
a1069 1
/* macro to determine if one bounding box is within another */
@


11.15
log
@
Added helpful comments
@
text
@d62 1
a62 1
 *  $Header: /c/CVS/brlcad/h/vmath.h,v 11.14 2000/02/14 21:20:52 mike Exp $
d87 2
@


11.14
log
@
Fixed typo in macro.
@
text
@d62 1
a62 1
 *  $Header: /c/CVS/brlcad/h/vmath.h,v 11.12 1999/12/23 06:26:27 mike Exp $
d681 1
d796 1
@


11.13
log
@
New checking macro
@
text
@d836 1
a836 1
	(fabs(MAGSQ(_vec)) < 0.0001 || fabs(fabs(MAGSQ(_vec))-1) < 0.0001)
@


11.12
log
@
Added new macro
@
text
@d62 1
a62 1
 *  $Header: /c/CVS/brlcad/h/vmath.h,v 11.11 1999/12/07 01:11:51 mike Exp $
d833 4
@


11.11
log
@
Added __cplusplus protection
@
text
@d62 1
a62 1
 *  $Header: /c/CVS/brlcad/h/vmath.h,v 11.10 1999/01/15 07:37:48 mike Exp $
d816 3
@


11.10
log
@Added C++ version of VPRINT
@
text
@d62 1
a62 1
 *  $Header: /c/CVS/brlcad/h/vmath.h,v 11.9 1998/12/11 05:53:12 mike Exp $
d68 4
d1060 4
@


11.9
log
@Added VELMUL3
@
text
@d62 1
a62 1
 *  $Header: /c/CVS/brlcad/h/vmath.h,v 11.8 1998/10/14 12:27:53 jra Exp $
d610 9
@


11.8
log
@There was a missing paren in QUAT_FROM_VROT and QUAT_FROM_ROT.
@
text
@d62 1
a62 1
 *  $Header: /c/CVS/brlcad/h/vmath.h,v 11.7 1998/03/19 14:54:57 jra Exp $
d623 13
@


11.7
log
@added typedef for point2d_t
@
text
@d62 1
a62 1
 *  $Header: /m/cad/h/RCS/vmath.h,v 11.6 1997/09/11 21:35:34 butler Exp jra $
d897 1
a897 1
	QUAT_FROM_VROT(q, ((r)*(M_PI/180.0), v)
d900 1
a900 1
	QUAT_FROM_ROT(q, ((r)*(M_PI/180.0), x, y, z)
@


11.6
log
@fixed deg->rad conversion
@
text
@d62 1
a62 1
 *  $Header: /m/cad/h/RCS/vmath.h,v 11.5 1997/09/11 20:26:02 butler Exp butler $
d110 2
@


11.5
log
@tidy up rot->quat macros
@
text
@d62 1
a62 1
 *  $Header: /m/cad/h/RCS/vmath.h,v 11.4 1997/01/07 22:35:43 butler Exp butler $
d895 1
a895 1
	QUAT_FROM_VROT(q, ((r)*(180.0/M_PI), v)
d898 1
a898 1
	QUAT_FROM_ROT(q, ((r)*(180.0/M_PI), x, y, z)
@


11.4
log
@John objected to the excessive calls to sqrt that gratuitous calls to
VUNITIZE() was generating.  So we changed it to do a MAGSQ() on the vector
first, check to see if the result was within tolerance of 1.0 and only
then unitize (and hence sqrt()) if necessary.
@
text
@d62 1
a62 1
 *  $Header: /m/cad/h/RCS/vmath.h,v 11.3 1996/08/30 00:14:20 butler Exp butler $
d865 3
a867 3

/*
 * Create Quaternion from Vector and Rotation (in Radians) about vector.
d871 3
a873 1
 *	Q_FROM_VROT_DEG( quat, M_PI, axis);
d875 3
a877 1
 * Lee A. Butler
d879 9
a887 2
#define QUAT_FROM_VROT_RAD(q, r, v) { \
	register fastf_t rot = (r) * 0.5; \
d890 10
a899 10
	(q)[W] = cos(rot); \
	rot = sin(rot); \
	VSCALE(q, q, rot ); }

#define QUAT_FROM_ROT(q, r, x, y, z) {\
	register fastf_t rot = (r) * 0.5; \
	QSET(q, x, y, z, cos(rot)); \
	VUNITIZE(q); \
	rot = sin(rot); \
	VSCALE(q, q, rot); }
a900 4
/*
 * Create Quaternion from Vector and Rotation (in Degrees) about vector.
 */
#define QUAT_FROM_VROT_DEG(q, r, v) Q_FROM_VROT_RAD(q, ((r)*(180.0/M_PI), v)
@


11.3
log
@QUAT_FROM_VROT_RAD() and QUAT_FROM_VROT_DEG() and QUAT_FROM_ROT() added
@
text
@d62 1
a62 1
 *  $Header: /m/cad/h/RCS/vmath.h,v 11.2 1995/12/29 23:10:19 butler Exp butler $
d86 1
d89 1
d380 12
a391 7
#define VUNITIZE(a) \
	{ register double _f; register int _vunitize; \
	_f = MAGNITUDE(a); \
	if( _f < VDIVIDE_TOL ) _f = 0.0; else _f = 1.0/_f; \
	for(_vunitize = 0; _vunitize < 3; _vunitize++) \
		(a)[_vunitize] *= _f; \
	}
d393 10
a402 3
#define VUNITIZE(a)	{ register double _f; _f = MAGNITUDE(a); \
			if( _f < VDIVIDE_TOL ) _f = 0.0; else _f = 1.0/_f; \
			(a)[X] *= _f; (a)[Y] *= _f; (a)[Z] *= _f; }
@


11.2
log
@added MAT_SCALE macros
@
text
@d62 1
a62 1
 *  $Header: /m/cad/h/RCS/vmath.h,v 11.1 1995/01/04 09:48:52 mike Rel4_4 butler $
d846 1
a846 1
 *  None of the macros here depend on component locations, however.
d849 1
d851 29
@


11.1
log
@Release_4.4
@
text
@d62 1
a62 1
 *  $Header: /m/cad/h/RCS/vmath.h,v 10.15 94/11/03 10:31:55 jra Exp $
d174 19
@


10.15
log
@Added macro V3RPP1_IN_RPP2.
@
text
@d62 1
a62 1
 *  $Header: /n/wolf/m/cad/h/RCS/vmath.h,v 10.14 94/09/16 20:08:39 mike Exp Locker: jra $
@


10.14
log
@Moved several handy macros from anim.h to vmath.h
@
text
@d62 1
a62 1
 *  $Header: /m/cad/h/RCS/vmath.h,v 10.13 94/09/16 19:55:16 mike Exp Locker: mike $
d956 6
@


10.13
log
@Added new-style 2D macros, e.g. V2MOVE().
@
text
@d62 1
a62 1
 *  $Header: /m/cad/h/RCS/vmath.h,v 10.12 94/04/22 05:27:37 mike Exp Locker: mike $
d175 11
d195 4
d589 7
@


10.12
log
@Added V2PRINT
@
text
@d62 1
a62 1
 *  $Header: /m/cad/h/RCS/vmath.h,v 10.11 94/04/12 22:37:40 mike Exp Locker: mike $
d204 5
d239 4
d260 4
d338 4
d487 4
d513 1
d540 2
d787 3
d791 7
a797 17
#define VADD2_2D(a,b,c)	{ \
			(a)[X] = (b)[X] + (c)[X];\
			(a)[Y] = (b)[Y] + (c)[Y];}
#define VSUB2_2D(a,b,c)	{ \
			(a)[X] = (b)[X] - (c)[X];\
			(a)[Y] = (b)[Y] - (c)[Y];}
#define MAGSQ_2D(a)	( (a)[X]*(a)[X] + (a)[Y]*(a)[Y] )
#define VDOT_2D(a,b)	( (a)[X]*(b)[X] + (a)[Y]*(b)[Y] )
#define VMOVE_2D(a,b)	{ \
			(a)[X] = (b)[X];\
			(a)[Y] = (b)[Y];}
#define VSCALE_2D(a,b,c)	{ \
			(a)[X] = (b)[X] * (c);\
			(a)[Y] = (b)[Y] * (c); }
#define VJOIN1_2D(a,b,c,d) 	{ \
			(a)[X] = (b)[X] + (c) * (d)[X];\
			(a)[Y] = (b)[Y] + (c) * (d)[Y]; }
@


10.11
log
@Added 2D macros
@
text
@d62 1
a62 1
 *  $Header: /m/cad/h/RCS/vmath.h,v 10.10 94/01/25 09:45:34 mike Exp Locker: mike $
d530 2
@


10.10
log
@Added DIST_PT_PT
@
text
@d62 1
a62 1
 *  $Header: /m/cad/h/RCS/vmath.h,v 10.9 93/12/06 21:33:58 mike Exp Locker: mike $
d340 7
d758 21
@


10.9
log
@Added HREVERSE()
@
text
@d62 1
a62 1
 *  $Header: /m/cad/h/RCS/vmath.h,v 10.8 93/09/23 13:21:18 mike Exp Locker: mike $
d139 6
@


10.8
log
@Added VINVDIR macro
@
text
@d62 1
a62 1
 *  $Header: /m/cad/h/RCS/vmath.h,v 10.7 93/07/20 15:16:07 mike Exp Locker: mike $
d203 7
@


10.7
log
@Exilimated nested commenting oddity
@
text
@d62 1
a62 1
 *  $Header: /m/cad/h/RCS/vmath.h,v 10.6 93/04/01 03:26:39 mike Exp Locker: mike $
d528 22
@


10.6
log
@Added #include sequencing
@
text
@d56 1
a56 1
 *	#include "machine.h"	/* For fastf_t definition on this machine *_/
d62 1
a62 1
 *  $Header: /m/cad/h/RCS/vmath.h,v 10.5 93/03/20 04:09:04 mike Exp Locker: mike $
@


10.5
log
@Added RPP macros
@
text
@d4 2
a5 1
 *  This header file defines many commonly used 3D vector math macros.
d47 1
a47 2
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
d53 10
a62 1
 *  $Header: /m/cad/h/RCS/vmath.h,v 10.4 93/03/03 01:47:16 mike Exp Locker: mike $
@


10.4
log
@Added DIST_PT_PLANE and V3RPP_OVERLAP
@
text
@d53 1
a53 1
 *  $Header: /m/cad/h/RCS/vmath.h,v 10.3 93/02/24 21:20:56 mike Exp Locker: mike $
d812 7
a818 1
/* Compare two extents represented as RPPs. if they overlap, return true */
d820 23
a842 2
    (! ((_l1)[0] > (_h2)[0] || (_l1)[1] > (_h2)[1] || (_l1)[2] > (_h2)[2] || \
	(_l2)[0] > (_h1)[0] || (_l2)[1] > (_h1)[1] || (_l2)[2] > (_h1)[2]) )
@


10.3
log
@Added V2ARGS
@
text
@d53 1
a53 1
 *  $Header: /m/cad/h/RCS/vmath.h,v 10.2 92/10/06 23:10:46 mike Exp Locker: mike $
d128 3
d811 5
@


10.2
log
@Added VSUB2DOT from nmg_inter.c
@
text
@d53 1
a53 1
 *  $Header: /m/cad/h/RCS/vmath.h,v 10.1 91/10/12 06:35:42 mike Rel4_0 Locker: mike $
d493 1
@


10.1
log
@Release_4.0
@
text
@d53 1
a53 1
 *  $Header: /m/cad/h/RCS/vmath.h,v 9.15 91/07/03 02:20:13 mike Exp $
d485 6
@


9.15
log
@Moved Homogeneous vector macros from nurb.h to vmath.h
@
text
@d53 1
a53 1
 *  $Header: /m/cad/h/RCS/vmath.h,v 9.14 91/06/17 22:49:45 mike Exp $
@


9.14
log
@Added more MAT_DELTAS macros
@
text
@d53 1
a53 1
 *  $Header: /m/cad/h/RCS/vmath.h,v 9.13 91/05/17 00:17:42 mike Exp $
d179 7
d287 6
d431 6
@


9.13
log
@Added {} to all multi-line macros
@
text
@d53 1
a53 1
 *  $Header: /m/cad/h/RCS/vmath.h,v 9.12 91/05/16 22:41:10 stay Exp $
d140 16
a155 3
			(m)[MDX] = x; \
			(m)[MDY] = y; \
			(m)[MDZ] = z; }
@


9.12
log
@Added {}
@
text
@d53 1
a53 1
 *  $Header: /m/cad/h/RCS/vmath.h,v 9.11 91/03/01 22:43:14 mike Exp $
d139 4
a142 3
#define MAT_DELTAS(m,x,y,z)	(m)[MDX] = x; \
				(m)[MDY] = y; \
				(m)[MDZ] = z;
d145 2
a146 1
#define VSET(a,b,c,d)	(a)[X] = (b);\
d148 1
a148 1
			(a)[Z] = (d)
d151 1
a151 1
#define VSETALL(a,s)	(a)[X] = (a)[Y] = (a)[Z] = (s);
d154 2
a155 1
#define VMOVE(a,b)	(a)[X] = (b)[X];\
d157 1
a157 1
			(a)[Z] = (b)[Z]
d167 2
a168 2
#define VREVERSE(a,b)	\
		{	(a)[X] = -(b)[X]; \
d170 1
a170 2
			(a)[Z] = -(b)[Z]; \
		}
d176 2
a177 1
#define VADD2(a,b,c)	(a)[X] = (b)[X] + (c)[X];\
d179 1
a179 1
			(a)[Z] = (b)[Z] + (c)[Z]
d193 2
a194 1
#define VSUB2(a,b,c)	(a)[X] = (b)[X] - (c)[X];\
d196 1
a196 1
			(a)[Z] = (b)[Z] - (c)[Z]
d210 2
a211 1
#define VSUB3(a,b,c,d)	(a)[X] = (b)[X] - (c)[X] - (d)[X];\
d213 1
a213 1
			(a)[Z] = (b)[Z] - (c)[Z] - (d)[Z]
d227 2
a228 1
#define VADD3(a,b,c,d)	(a)[X] = (b)[X] + (c)[X] + (d)[X];\
d230 1
a230 1
			(a)[Z] = (b)[Z] + (c)[Z] + (d)[Z]
d244 2
a245 1
#define VADD4(a,b,c,d,e) (a)[X] = (b)[X] + (c)[X] + (d)[X] + (e)[X];\
d247 1
a247 1
			(a)[Z] = (b)[Z] + (c)[Z] + (d)[Z] + (e)[Z]
d261 2
a262 1
#define VSCALE(a,b,c)	(a)[X] = (b)[X] * (c);\
d264 1
a264 1
			(a)[Z] = (b)[Z] * (c)
d296 2
a297 1
#define VADD2SCALE( o, a, b, s )	(o)[X] = ((a)[X] + (b)[X]) * (s); \
d299 1
a299 1
					(o)[Z] = ((a)[Z] + (b)[Z]) * (s);
d315 2
a316 1
#define VSUB2SCALE( o, a, b, s )	(o)[X] = ((a)[X] - (b)[X]) * (s); \
d318 1
a318 1
					(o)[Z] = ((a)[Z] - (b)[Z]) * (s);
d361 1
a361 1
#define VJOIN4(a,b,c,d,e,f,g,h,i,j)	\
d364 1
a364 1
	(a)[Z] = (b)[Z] + (c)*(d)[Z] + (e)*(f)[Z] + (g)*(h)[Z] + (i)*(j)[Z]
d366 1
a366 1
#define VJOIN3(a,b,c,d,e,f,g,h)	\
d369 1
a369 1
	(a)[Z] = (b)[Z] + (c)*(d)[Z] + (e)*(f)[Z] + (g)*(h)[Z]
d379 1
a379 1
#define VJOIN2(a,b,c,d,e,f)	\
d382 1
a382 1
	(a)[Z] = (b)[Z] + (c) * (d)[Z] + (e) * (f)[Z]
d394 1
a394 1
#define VJOIN1(a,b,c,d) \
d397 1
a397 1
	(a)[Z] = (b)[Z] + (c) * (d)[Z];
d414 1
a414 1
#define VBLEND2(a,b,c,d,e)	\
d417 1
a417 1
	(a)[Z] = (b) * (c)[Z] + (d) * (e)[Z];
d446 2
a447 1
#define VCROSS(a,b,c)	(a)[X] = (b)[Y] * (c)[Z] - (b)[Z] * (c)[Y];\
d449 1
a449 1
			(a)[Z] = (b)[X] * (c)[Y] - (b)[Y] * (c)[X]
d472 1
a472 1
#define VELMUL(a,b,c) \
d475 1
a475 1
	(a)[Z] = (b)[Z] * (c)[Z];
d488 1
a488 1
#define MAT3X3VEC(o,mat,vec) \
d491 1
a491 1
	(o)[Z] = (mat)[8]*(vec)[X]+(mat)[9]*(vec)[Y] + (mat)[10]*(vec)[Z];
d504 1
a504 1
#define VEC3X3MAT(o,i,m) \
d507 1
a507 1
	(o)[Z] = (i)[X]*(m)[2] + (i)[Y]*(m)[6] + (i)[Z]*(m)[10];
d519 1
a519 1
#define MAT3X2VEC(o,mat,vec) \
d522 1
a522 1
	(o)[Z] = (mat)[8]*(vec)[X] + (mat)[9]*(vec)[Y];
d533 1
a533 1
#define VEC2X3MAT(o,i,m) \
d536 1
a536 1
	(o)[Z] = (i)[X]*(m)[2] + (i)[Y]*(m)[6];
d585 1
a585 1
#define MAT4X4PNT(o,m,i) \
d589 1
a589 1
	(o)[H]=(m)[12]*(i)[X] + (m)[13]*(i)[Y] + (m)[14]*(i)[Z] + (m)[15]*(i)[H];
d660 1
a660 1
#define HDIVIDE(a,b)  \
d663 1
a663 1
	(a)[Z] = (b)[Z] / (b)[H];
d678 2
a679 1
#define QSET(a,b,c,d,e)	(a)[X] = (b);\
d682 1
a682 1
			(a)[W] = (e)
d685 2
a686 1
#define QMOVE(a,b)	(a)[X] = (b)[X];\
d689 1
a689 1
			(a)[W] = (b)[W]
d692 2
a693 1
#define QADD2(a,b,c)	(a)[X] = (b)[X] + (c)[X];\
d696 1
a696 1
			(a)[W] = (b)[W] + (c)[W]
d699 2
a700 1
#define QSUB2(a,b,c)	(a)[X] = (b)[X] - (c)[X];\
d703 1
a703 1
			(a)[W] = (b)[W] - (c)[W]
d706 2
a707 1
#define QSCALE(a,b,c)	(a)[X] = (b)[X] * (c);\
d710 1
a710 1
			(a)[W] = (b)[W] * (c)
d763 1
a763 1
#define QBLEND2(a,b,c,d,e)	\
d767 1
a767 1
	(a)[W] = (b) * (c)[W] + (d) * (e)[W];
@


9.11
log
@Added VJOIN3
@
text
@d53 1
a53 1
 *  $Header: /m/cad/h/RCS/vmath.h,v 9.10 91/02/08 22:41:02 mike Exp $
d164 2
a165 1
#define VREVERSE(a,b)	(a)[X] = -(b)[X]; \
d167 2
a168 1
			(a)[Z] = -(b)[Z];
@


9.10
log
@VMINMAX needed extra parens
@
text
@d53 1
a53 1
 *  $Header: /m/cad/h/RCS/vmath.h,v 9.9 90/12/08 04:46:48 butler Exp $
d353 5
@


9.9
log
@added ELEMENTS_PER_MAT
@
text
@d53 1
a53 1
 *  $Header: /m/cad/h/RCS/vmath.h,v 9.8 90/05/17 23:20:23 mike Exp $
d630 3
a632 3
#define VMIN(r,s)	{ V_MIN(r[X],s[X]); V_MIN(r[Y],s[Y]); V_MIN(r[Z],s[Z]); }
#define VMAX(r,s)	{ V_MAX(r[X],s[X]); V_MAX(r[Y],s[Y]); V_MAX(r[Z],s[Z]); }
#define VMINMAX( min, max, pt )	{ VMIN( min, pt ); VMAX( max, pt ); }
@


9.8
log
@Added V3ARGS, V4ARGS
@
text
@d53 1
a53 1
 *  $Header: /m/cad/h/RCS/vmath.h,v 9.7 90/05/02 01:11:20 mike Exp $
a80 6
/*
 * Types for matrixes and vectors.
 */
typedef	fastf_t	mat_t[4*4];
typedef	fastf_t	*matp_t;

d86 7
@


9.7
log
@Added VJOIN4, changed "register double f;" to "register double _f;"
to prevent conflicts with caller-provided variabled named "f".
@
text
@d53 1
a53 1
 *  $Header: vmath.h,v 9.6 90/02/07 23:44:03 mike Locked $
d435 4
d440 4
a443 2
#define VPRINT(a,b)	(void)fprintf(stderr,"%s (%g, %g, %g)\n", a, (b)[X], (b)[Y], (b)[Z])
#define HPRINT(a,b)	(void)fprintf(stderr,"%s (%g, %g, %g, %g)\n", a, (b)[X], (b)[Y], (b)[Z], (b)[3])
@


9.6
log
@Supplied some missing parens.
@
text
@d36 6
d53 1
a53 1
 *  $Header: vmath.h,v 9.5 89/12/08 22:45:36 mike Locked $
d348 5
d517 1
a517 1
	{ register double f; \
d519 1
a519 1
	f = 0.0; \
d521 2
a522 2
		f += (m)[_j_m4x3p+12] * (i)[_j_m4x3p]; \
	f = 1.0/(f + (m)[15]); \
d530 1
a530 1
		(o)[_i_m4x3p] = ((o)[_i_m4x3p] + (m)[4*_i_m4x3p+3]) * f; \
d534 5
a538 5
	{ register double f; \
	f = 1.0/((m)[12]*(i)[X] + (m)[13]*(i)[Y] + (m)[14]*(i)[Z] + (m)[15]);\
	(o)[X]=((m)[0]*(i)[X] + (m)[1]*(i)[Y] + (m)[ 2]*(i)[Z] + (m)[3]) * f;\
	(o)[Y]=((m)[4]*(i)[X] + (m)[5]*(i)[Y] + (m)[ 6]*(i)[Z] + (m)[7]) * f;\
	(o)[Z]=((m)[8]*(i)[X] + (m)[9]*(i)[Y] + (m)[10]*(i)[Z] + (m)[11])* f;}
d543 5
a547 5
	{ register double f; \
	f = 1.0/((i)[X]*(m)[3] + (i)[Y]*(m)[7] + (i)[Z]*(m)[11] + (m)[15]);\
	(o)[X]=((i)[X]*(m)[0] + (i)[Y]*(m)[4] + (i)[Z]*(m)[8] + (m)[12]) * f;\
	(o)[Y]=((i)[X]*(m)[1] + (i)[Y]*(m)[5] + (i)[Z]*(m)[9] + (m)[13]) * f;\
	(o)[Z]=((i)[X]*(m)[2] + (i)[Y]*(m)[6] + (i)[Z]*(m)[10] + (m)[14])* f;}
d570 1
a570 1
	{ register double f; \
d572 1
a572 1
	f = 1.0/((m)[15]); \
d580 1
a580 1
		(o)[_i_m4x3v] *= f; \
d584 4
a587 4
	{ register double f;	f = 1.0/((m)[15]);\
	(o)[X] = ((m)[0]*(i)[X] + (m)[1]*(i)[Y] + (m)[ 2]*(i)[Z]) * f; \
	(o)[Y] = ((m)[4]*(i)[X] + (m)[5]*(i)[Y] + (m)[ 6]*(i)[Z]) * f; \
	(o)[Z] = ((m)[8]*(i)[X] + (m)[9]*(i)[Y] + (m)[10]*(i)[Z]) * f; }
d592 4
a595 4
	{ register double f; 	f = 1.0/((m)[15]); \
	(o)[X] = ((i)[X]*(m)[0] + (i)[Y]*(m)[4] + (i)[Z]*(m)[8]) * f; \
	(o)[Y] = ((i)[X]*(m)[1] + (i)[Y]*(m)[5] + (i)[Z]*(m)[9]) * f; \
	(o)[Z] = ((i)[X]*(m)[2] + (i)[Y]*(m)[6] + (i)[Z]*(m)[10]) * f; }
d599 4
a602 4
	{ register double f; 	f = 1.0/((m)[15]); \
	(o)[X] = ((i)[X]*(m)[0] + (i)[Y]*(m)[4]) * f; \
	(o)[Y] = ((i)[X]*(m)[1] + (i)[Y]*(m)[5]) * f; \
	(o)[Z] = ((i)[X]*(m)[2] + (i)[Y]*(m)[6]) * f; }
@


9.5
log
@Changed from VECTORIZE to SHORT_VECTORS
@
text
@d47 1
a47 1
 *  $Header: vmath.h,v 9.4 89/10/10 15:44:14 mike Locked $
d279 3
a281 3
#define VADD2SCALE( o, a, b, s )	o[X] = ((a)[X] + (b)[X]) * (s); \
					o[Y] = ((a)[Y] + (b)[Y]) * (s); \
					o[Z] = ((a)[Z] + (b)[Z]) * (s);
d297 3
a299 3
#define VSUB2SCALE( o, a, b, s )	o[X] = ((a)[X] - (b)[X]) * (s); \
					o[Y] = ((a)[Y] - (b)[Y]) * (s); \
					o[Z] = ((a)[Z] - (b)[Z]) * (s);
@


9.4
log
@Added some more macros, and some additional commenting about
normal vectors, cross products, and plane equations.
@
text
@d47 1
a47 1
 *  $Header: vmath.h,v 9.3 89/08/12 07:28:21 mike Exp $
d162 1
a162 1
#ifdef VECTORIZE
d168 1
a168 1
#endif /* VECTORIZE */
d178 1
a178 1
#ifdef VECTORIZE
d184 1
a184 1
#endif /* VECTORIZE */
d194 1
a194 1
#ifdef VECTORIZE
d200 1
a200 1
#endif /* VECTORIZE */
d210 1
a210 1
#ifdef VECTORIZE
d216 1
a216 1
#endif /* VECTORIZE */
d226 1
a226 1
#ifdef VECTORIZE
d232 1
a232 1
#endif /* VECTORIZE */
d242 1
a242 1
#ifdef VECTORIZE
d248 1
a248 1
#endif /* VECTORIZE */
d258 1
a258 1
#ifdef VECTORIZE
d270 1
a270 1
#endif /* VECTORIZE */
d276 1
a276 1
#ifdef VECTORIZE
d294 1
a294 1
#ifdef VECTORIZE
d312 1
a312 1
#ifdef VECTORIZE
d319 1
a319 1
#endif /* VECTORIZE */
d327 1
a327 1
#ifdef VECTORIZE
d334 1
a334 1
#endif /* VECTORIZE */
d347 1
a347 1
#ifdef VECTORIZE
d354 1
a354 1
#endif /* VECTORIZE */
d362 1
a362 1
#ifdef VECTORIZE
d369 1
a369 1
#endif /* VECTORIZE */
d382 1
a382 1
#ifdef VECTORIZE
d389 1
a389 1
#endif /* VECTORIZE */
d429 1
a429 1
#ifdef VECTORIZE
d440 1
a440 1
#endif /* VECTORIZE */
d443 1
a443 1
#ifdef VECTORIZE
d456 1
a456 1
#endif /* VECTORIZE */
d459 1
a459 1
#ifdef VECTORIZE
d472 1
a472 1
#endif /* VECTORIZE */
d475 1
a475 1
#ifdef VECTORIZE
d487 1
a487 1
#endif /* VECTORIZE */
d490 1
a490 1
#ifdef VECTORIZE
d501 1
a501 1
#endif /* VECTORIZE */
d504 1
a504 1
#ifdef VECTORIZE
d528 1
a528 1
#endif /* VECTORIZE */
d539 1
a539 1
#ifdef VECTORIZE
d554 1
a554 1
#endif /* VECTORIZE */
d557 1
a557 1
#ifdef VECTORIZE
d577 1
a577 1
#endif /* VECTORIZE */
d617 1
a617 1
#ifdef VECTORIZE
d628 1
a628 1
#endif /* VECTORIZE */
d719 1
a719 1
#ifdef VECTORIZE
d727 1
a727 1
#endif /* VECTORIZE */
@


9.3
log
@Added more quaternion stuff.
@
text
@d47 1
a47 1
 *  $Header: vmath.h,v 9.2 89/08/12 04:37:50 mike Locked $
d96 23
a120 2
#define quat_t	hvect_t		/* 4-element quaternion */

d297 3
a299 3
#define VSUB2SCALE( o, a, b, s )	o[X] = ((a)[X] + (b)[X]) * (s); \
					o[Y] = ((a)[Y] + (b)[Y]) * (s); \
					o[Z] = ((a)[Z] + (b)[Z]) * (s);
d305 1
a305 1
		(o)[_vsub2scale] = ((a)[_vsub2scale] + (b)[_vsub2scale]) * (s); \
d403 14
a416 1
/* Store cross product of vectors at `b' and `c' in vector at `a' */
d595 13
@


9.2
log
@Added Phil's quaternion definitions
@
text
@d32 4
d47 1
a47 1
 *  $Header: vmath.h,v 9.1 89/05/19 05:44:41 mike Locked $
d356 20
d595 4
a598 4
#define QSET(a,b,c,d,e)	(a)[0] = (b);\
			(a)[1] = (c);\
			(a)[2] = (d);\
			(a)[3] = (e)
d601 4
a604 4
#define QMOVE(a,b)	(a)[0] = (b)[0];\
			(a)[1] = (b)[1];\
			(a)[2] = (b)[2];\
			(a)[3] = (b)[3]
d607 4
a610 4
#define QADD2(a,b,c)	(a)[0] = (b)[0] + (c)[0];\
			(a)[1] = (b)[1] + (c)[1];\
			(a)[2] = (b)[2] + (c)[2];\
			(a)[3] = (b)[3] + (c)[3]
d613 4
a616 4
#define QSUB2(a,b,c)	(a)[0] = (b)[0] - (c)[0];\
			(a)[1] = (b)[1] - (c)[1];\
			(a)[2] = (b)[2] - (c)[2];\
			(a)[3] = (b)[3] - (c)[3]
d619 4
a622 4
#define QSCALE(a,b,c)	(a)[0] = (b)[0] * (c);\
			(a)[1] = (b)[1] * (c);\
			(a)[2] = (b)[2] * (c);\
			(a)[3] = (b)[3] * (c)
d625 3
a627 3
#define QUNITIZE(a)	{FAST double f; f = QMAGNITUDE(a); \
			if( f < VDIVIDE_TOL ) f = 0.0; else f = 1.0/f; \
			(a)[0] *= f; (a)[1] *= f; (a)[2] *= f; (a)[3] *= f; }
d630 2
a631 2
#define QMAGSQ(a)	( (a)[0]*(a)[0] + (a)[1]*(a)[1] \
			+ (a)[2]*(a)[2] + (a)[3]*(a)[3] )
d637 44
a680 2
#define QDOT(a,b)	( (a)[0]*(b)[0] + (a)[1]*(b)[1] \
			+ (a)[2]*(b)[2] + (a)[3]*(b)[3] )
@


9.1
log
@Release_3.5
@
text
@d43 1
a43 1
 *  $Header: vmath.h,v 8.4 89/04/24 06:43:35 mike Exp $
d65 6
d81 1
d92 4
d101 1
d237 1
a237 1
	if( _f < 1.0e-10 ) _f = 0.0; else _f = 1.0/_f; \
d243 1
a243 1
			if( _f < 1.0e-10 ) _f = 0.0; else _f = 1.0/_f; \
d558 57
@


8.4
log
@STDC nit
@
text
@d43 1
a43 1
 *  $Header: vmath.h,v 8.3 89/01/19 19:48:48 mike Locked $
@


8.3
log
@For ANSII C, made tokens after #endif into comments
@
text
@d43 1
a43 1
 *  $Header: vmath.h,v 8.2 88/12/01 14:30:18 mike Locked $
d51 2
a52 2
#	if defined(__STDC__)
		extern double sqrt(double x);
@


8.2
log
@Changed loop variables in macros to be more informative when
vectorizing compilers mention them.
@
text
@d43 1
a43 1
 *  $Header: /cad/d/mike/cad/h/RCS/vmath.h,v 1.1 88/10/27 07:38:40 mike Exp $
d131 1
a131 1
#endif VECTORIZE
d147 1
a147 1
#endif VECTORIZE
d163 1
a163 1
#endif VECTORIZE
d179 1
a179 1
#endif VECTORIZE
d195 1
a195 1
#endif VECTORIZE
d211 1
a211 1
#endif VECTORIZE
d233 1
a233 1
#endif VECTORIZE
d282 1
a282 1
#endif VECTORIZE
d297 1
a297 1
#endif VECTORIZE
d317 1
a317 1
#endif VECTORIZE
d332 1
a332 1
#endif VECTORIZE
d370 1
a370 1
#endif VECTORIZE
d386 1
a386 1
#endif VECTORIZE
d402 1
a402 1
#endif VECTORIZE
d417 1
a417 1
#endif VECTORIZE
d431 1
a431 1
#endif VECTORIZE
d458 1
a458 1
#endif VECTORIZE
d484 1
a484 1
#endif VECTORIZE
d507 1
a507 1
#endif VECTORIZE
d545 1
a545 1
#endif VECTORIZE
d547 1
a547 1
#endif VMATH_H
@


8.1
log
@Release_3.0
@
text
@d43 1
a43 1
 *  $Header: vmath.h,v 7.9 88/09/21 04:22:58 mike Exp $
d100 3
a102 3
#define VSET(a,b,c,d)	(a)[0] = (b);\
			(a)[1] = (c);\
			(a)[2] = (d)
d105 1
a105 1
#define VSETALL(a,s)	(a)[0] = (a)[1] = (a)[2] = (s);
d108 3
a110 3
#define VMOVE(a,b)	(a)[0] = (b)[0];\
			(a)[1] = (b)[1];\
			(a)[2] = (b)[2]
d114 3
a116 3
	{ register int _i; \
	for(_i = 0; _i < n; _i++) \
		(a)[_i] = (b)[_i]; \
d120 3
a122 3
#define VREVERSE(a,b)	(a)[0] = -(b)[0]; \
			(a)[1] = -(b)[1]; \
			(a)[2] = -(b)[2];
d128 3
a130 3
#define VADD2(a,b,c)	(a)[0] = (b)[0] + (c)[0];\
			(a)[1] = (b)[1] + (c)[1];\
			(a)[2] = (b)[2] + (c)[2]
d135 3
a137 3
	{ register int _i; \
	for(_i = 0; _i < n; _i++) \
		(a)[_i] = (b)[_i] + (c)[_i]; \
d144 3
a146 3
#define VSUB2(a,b,c)	(a)[0] = (b)[0] - (c)[0];\
			(a)[1] = (b)[1] - (c)[1];\
			(a)[2] = (b)[2] - (c)[2]
d151 3
a153 3
	{ register int _i; \
	for(_i = 0; _i < n; _i++) \
		(a)[_i] = (b)[_i] - (c)[_i]; \
d160 3
a162 3
#define VSUB3(a,b,c,d)	(a)[0] = (b)[0] - (c)[0] - (d)[0];\
			(a)[1] = (b)[1] - (c)[1] - (d)[1];\
			(a)[2] = (b)[2] - (c)[2] - (d)[2]
d167 3
a169 3
	{ register int _i; \
	for(_i = 0; _i < n; _i++) \
		(a)[_i] = (b)[_i] - (c)[_i] - (d)[_i]; \
d176 3
a178 3
#define VADD3(a,b,c,d)	(a)[0] = (b)[0] + (c)[0] + (d)[0];\
			(a)[1] = (b)[1] + (c)[1] + (d)[1];\
			(a)[2] = (b)[2] + (c)[2] + (d)[2]
d183 3
a185 3
	{ register int _i; \
	for(_i = 0; _i < n; _i++) \
		(a)[_i] = (b)[_i] + (c)[_i] + (d)[_i]; \
d192 3
a194 3
#define VADD4(a,b,c,d,e) (a)[0] = (b)[0] + (c)[0] + (d)[0] + (e)[0];\
			(a)[1] = (b)[1] + (c)[1] + (d)[1] + (e)[1];\
			(a)[2] = (b)[2] + (c)[2] + (d)[2] + (e)[2]
d199 3
a201 3
	{ register int _i; \
	for(_i = 0; _i < n; _i++) \
		(a)[_i] = (b)[_i] + (c)[_i] + (d)[_i] + (e)[_i];\
d208 3
a210 3
#define VSCALE(a,b,c)	(a)[0] = (b)[0] * (c);\
			(a)[1] = (b)[1] * (c);\
			(a)[2] = (b)[2] * (c)
d215 3
a217 3
	{ register int _i; \
	for(_i = 0; _i < n; _i++) \
		(a)[_i] = (b)[_i] * (c); \
d223 5
a227 5
	{ register double f; register int _i; \
	f = MAGNITUDE(a); \
	if( f < 1.0e-10 ) f = 0.0; else f = 1.0/f; \
	for(_i = 0; _i < 3; _i++) \
		(a)[_i] *= f; \
d230 3
a232 3
#define VUNITIZE(a)	{ register double f; f = MAGNITUDE(a); \
			if( f < 1.0e-10 ) f = 0.0; else f = 1.0/f; \
			(a)[0] *= f; (a)[1] *= f; (a)[2] *= f; }
d235 4
a238 1
/* Combine together several vectors, scaled by a scalar */
d240 36
d285 3
a287 3
	{ register int _i; \
	for(_i = 0; _i < n; _i++) \
		(o)[_i] = (a) * (b)[_i] + (c) * (d)[_i] + (e) * (f)[_i]; \
d300 3
a302 3
	{ register int _i; \
	for(_i = 0; _i < n; _i++) \
		(o)[_i] = (a) * (b)[_i] + (c) * (d)[_i]; \
d314 3
a316 3
	(a)[0] = (b)[0] + (c) * (d)[0] + (e) * (f)[0];\
	(a)[1] = (b)[1] + (c) * (d)[1] + (e) * (f)[1];\
	(a)[2] = (b)[2] + (c) * (d)[2] + (e) * (f)[2]
d320 3
a322 3
	{ register int _i; \
	for(_i = 0; _i < n; _i++) \
		(a)[_i] = (b)[_i] + (c) * (d)[_i] + (e) * (f)[_i]; \
d329 3
a331 3
	(a)[0] = (b)[0] + (c) * (d)[0];\
	(a)[1] = (b)[1] + (c) * (d)[1];\
	(a)[2] = (b)[2] + (c) * (d)[2];
d335 3
a337 3
	{ register int _i; \
	for(_i = 0; _i < n; _i++) \
		(a)[_i] = (b)[_i] + (c) * (d)[_i]; \
d341 1
a341 1
#define MAGSQ(a)	( (a)[0]*(a)[0] + (a)[1]*(a)[1] + (a)[2]*(a)[2] )
d347 3
a349 3
#define VCROSS(a,b,c)	(a)[0] = (b)[1] * (c)[2] - (b)[2] * (c)[1];\
			(a)[1] = (b)[2] * (c)[0] - (b)[0] * (c)[2];\
			(a)[2] = (b)[0] * (c)[1] - (b)[1] * (c)[0]
d352 1
a352 1
#define VDOT(a,b)	( (a)[0]*(b)[0] + (a)[1]*(b)[1] + (a)[2]*(b)[2] )
d355 2
a356 2
#define VPRINT(a,b)	(void)fprintf(stderr,"%s (%g, %g, %g)\n", a, (b)[0], (b)[1], (b)[2])
#define HPRINT(a,b)	(void)fprintf(stderr,"%s (%g, %g, %g, %g)\n", a, (b)[0], (b)[1], (b)[2], (b)[3])
d361 3
a363 3
	{ register int _i; \
	for(_i = 0; _i < 3; _i++) \
		(a)[_i] = (b)[_i] * (c)[_i]; \
d367 3
a369 3
	(a)[0] = (b)[0] * (c)[0];\
	(a)[1] = (b)[1] * (c)[1];\
	(a)[2] = (b)[2] * (c)[2];
d375 5
a379 5
	{ register int _i; \
	for(_i = 0; _i < 3; _i++) \
		(o)[_i] = (mat)[4*_i+0]*(vec)[0] + \
			  (mat)[4*_i+1]*(vec)[1] + \
			  (mat)[4*_i+2]*(vec)[2]; \
d383 3
a385 3
	(o)[0] = (mat)[0]*(vec)[0]+(mat)[1]*(vec)[1] + (mat)[ 2]*(vec)[2]; \
	(o)[1] = (mat)[4]*(vec)[0]+(mat)[5]*(vec)[1] + (mat)[ 6]*(vec)[2]; \
	(o)[2] = (mat)[8]*(vec)[0]+(mat)[9]*(vec)[1] + (mat)[10]*(vec)[2];
d391 5
a395 3
	{ register int _i; \
	for(_i = 0; _i < 3; _i++) \
		(o)[_i] = (i)[X]*(m)[_i] + (i)[Y]*(m)[_i+4] + (i)[Z]*(m)[_i+8]; \
d399 1
a399 1
	(o)[X] = (i)[X]*(m)[0] + (i)[Y]*(m)[4] + (i)[Z]*(m)[8]; \
d407 4
a410 3
	{ register int _i; \
	for(_i = 0; _i < 3; _i++) \
		(o)[_i] = (mat)[4*_i]*(vec)[0] + (mat)[4*_i+1]*(vec)[1]; \
d414 3
a416 3
	(o)[0] = (mat)[0]*(vec)[0] + (mat)[1]*(vec)[1]; \
	(o)[1] = (mat)[4]*(vec)[0] + (mat)[5]*(vec)[1]; \
	(o)[2] = (mat)[8]*(vec)[0] + (mat)[9]*(vec)[1];
d422 3
a424 3
	{ register int _i; \
	for(_i = 0; _i < 3; _i++) \
		(o)[_i] = (i)[X]*(m)[_i] + (i)[Y]*(m)[2*_i]; \
d437 1
a437 1
	register int _i, _j; \
d439 2
a440 2
	for(_j = 0; _j < 3; _j++)  \
		f += (m)[_j+12] * (i)[_j]; \
d442 5
a446 5
	for(_i = 0; _i < 3; _i++) \
		(o)[_i] = 0.0; \
	for(_i = 0; _i < 3; _i++)  { \
		for(_j = 0; _j < 3; _j++) \
			(o)[_i] += (m)[_j+4*_i] * (i)[_j]; \
d448 2
a449 2
	for(_i = 0; _i < 3; _i++)  { \
		(o)[_i] = ((o)[_i] + (m)[4*_i+3]) * f; \
d471 6
a476 5
	{ register int _i, _j; \
	for(_i = 0; _i < 4; _i++) (o)[_i] = 0.0; \
	for(_i = 0; _i < 4; _i++) \
		for(_j = 0; _j < 4; _j++) \
			(o)[_i] += (m)[_j+4*_i] * (i)[_j]; \
d490 1
a490 1
	register int _i, _j; \
d492 5
a496 5
	for(_i = 0; _i < 3; _i++) \
		(o)[_i] = 0.0; \
	for(_i = 0; _i < 3; _i++) { \
		for(_j = 0; _j < 3; _j++) \
			(o)[_i] += (m)[_j+4*_i] * (i)[_j]; \
d498 2
a499 2
	for(_i = 0; _i < 3; _i++) { \
		(o)[_i] *= f; \
d536 3
a538 3
	{ register int _i; \
	for(_i = 0; _i < 3; _i++) \
		(a)[_i] = (b)[_i] / (b)[H]; \
@


7.9
log
@At long long last, a version of the extern sqrt() that causes the SGI to
(a) silence the compiler warnings, and
(b) give subroutine declarations the proper argument list!
G** D**n SGI Software!
@
text
@d43 1
a43 1
 *  $Header: vmath.h,v 7.8 88/09/20 23:53:41 mike Locked $
@


7.8
log
@Hopefully, the last sqrt() hack for the stupid stupid stupid SGI
@
text
@d43 1
a43 1
 *  $Header: vmath.h,v 7.7 88/09/20 02:34:39 mike Locked $
d50 3
a52 3
#	if defined(__STDC__) || \
	(defined(sgi) && defined(mips) && !defined(SGI4D_Rel2))
		extern double sqrt(double _sqrt_arg_x);
d54 6
a59 1
		extern double sqrt();
@


7.7
log
@On SGI 4-D release 2, there are no function prototypes.
On SGI 4-D release 3, function prototypes exist, and are used
in math.h, but __STDC__ is NOT defined.

Worse, on SGI 4-D release 2, giving the type of the argument
results in that symbol becomming globally known.
Hence, the change from "x" to "_sqrt_arg_x".
This seems to keep everything happy.
I HATE SGI!!!
@
text
@d43 1
a43 1
 *  $Header: vmath.h,v 7.6 88/09/19 22:45:57 mike Locked $
d50 2
a51 1
#	if defined(__STDC__) || (defined(sgi) && defined(mips))
@


7.6
log
@SGI makes me puke
@
text
@d43 1
a43 1
 *  $Header: vmath.h,v 7.5 88/09/13 23:50:09 mike Locked $
d51 1
a51 1
		extern double sqrt(double x);
@


7.5
log
@Simplified acccess of xxxN() macros,
split some loops, and shuffled some array indices to better
match vectorization templates.
@
text
@d43 1
a43 1
 *  $Header: vmath.h,v 7.4 88/07/15 05:53:03 mike Locked $
d50 1
a50 1
#	ifdef __STDC__
@


7.4
log
@Modifications to permit vectorization (hopefully).
@
text
@d43 1
a43 1
 *  $Header: vmath.h,v 7.3 88/05/13 21:58:38 mike Exp $
d120 1
a120 5
#define VADD2(a,b,c) \
	{ register int _i; \
	for(_i = 0; _i < 3; _i++) \
		(a)[_i] = (b)[_i] + (c)[_i]; \
	}
d136 1
a136 5
#define VSUB2(a,b,c) \
	{ register int _i; \
	for(_i = 0; _i < 3; _i++) \
		(a)[_i] = (b)[_i] - (c)[_i]; \
	}
d152 1
a152 5
#define VSUB3(a,b,c,d) \
	{ register int _i; \
	for(_i = 0; _i < 3; _i++) \
		(a)[_i] = (b)[_i] - (c)[_i] - (d)[_i]; \
	}
d168 1
a168 5
#define VADD3(a,b,c,d) \
	{ register int _i; \
	for(_i = 0; _i < 3; _i++) \
		(a)[_i] = (b)[_i] + (c)[_i] + (d)[_i]; \
	}
d184 1
a184 5
#define VADD4(a,b,c,d,e) \
	{ register int _i; \
	for(_i = 0; _i < 3; _i++) \
		(a)[_i] = (b)[_i] + (c)[_i] + (d)[_i] + (e)[_i];\
	}
d200 1
a200 5
#define VSCALE(a,b,c) \
	{ register int _i; \
	for(_i = 0; _i < 3; _i++) \
		(a)[_i] = (b)[_i] * (c); \
	}
d231 1
a231 5
#define VCOMB3(o, a,b, c,d, e,f)	{\
	{ register int _i; \
	for(_i = 0; _i < 3; _i++) \
		(o)[_i] = (a) * (b)[_i] + (c) * (d)[_i] + (e) * (f)[_i]; \
	} }
d246 1
a246 5
#define VCOMB2(o, a,b, c,d)	{\
	{ register int _i; \
	for(_i = 0; _i < 3; _i++) \
		(o)[_i] = (a) * (b)[_i] + (c) * (d)[_i]; \
	} }
d266 1
a266 5
#define VJOIN2(a,b,c,d,e,f)	\
	{ register int _i; \
	for(_i = 0; _i < 3; _i++) \
		(a)[_i] = (b)[_i] + (c) * (d)[_i] + (e) * (f)[_i]; \
	}
d281 1
a281 5
#define VJOIN1(a,b,c,d) \
	{ register int _i; \
	for(_i = 0; _i < 3; _i++) \
		(a)[_i] = (b)[_i] + (c) * (d)[_i]; \
	}
d348 1
a348 1
		(o)[_i] = (i)[X]*(m)[_i] + (i)[Y]*(m)[4+_i] + (i)[Z]*(m)[8+_i]; \
d391 2
a392 1
	for(_j = 0; _j < 3; _j++)  f+= (m)[12+_j] * (i)[_j]; \
d394 2
a396 1
		(o)[_i] = 0.0; \
d398 4
a401 3
			(o)[_i] += (m)[4*_i+_j] * (i)[_j]; \
		(o)[_i] += (m)[4*_i+3]; \
		(o)[_i] *=f; \
d427 1
a427 1
			(o)[_i] += (m)[4*_i+_j] * (i)[_j]; \
d443 2
a445 1
		(o)[_i] = 0.0; \
d447 3
a449 1
			(o)[_i] += (m)[4*_i+_j] * (i)[_j]; \
@


7.3
log
@Fixed definition of sqrt() for stdc.
@
text
@d43 1
a43 1
 *  $Header: vmath.h,v 7.2 88/02/05 03:20:47 mike Locked $
d106 7
d119 7
d129 1
d131 7
d139 7
d149 1
d151 7
d159 7
d169 1
d171 7
d179 7
d189 1
d191 7
d199 7
d209 1
d211 7
d219 7
d229 1
d231 18
a248 2
/* Normalize vector 'a' to be a unit vector */
#define VUNITIZE(a)	{FAST double f; f = MAGNITUDE(a); \
d251 1
d254 1
d256 6
d265 1
d267 7
d275 6
d284 1
d286 6
d297 1
d299 6
d308 1
d310 7
d318 6
d327 1
d329 6
d354 1
d356 6
d365 1
d368 1
d370 8
d381 1
d384 1
d386 6
d395 1
d398 1
d400 6
d409 1
d412 1
d414 6
d423 1
d425 2
a426 1
/* Apply a 4x4 matrix to a 3-tuple which is a absolue Point in space */
d428 15
a442 1
	{ FAST fastf_t f; \
d447 1
d451 1
a451 1
	{ FAST fastf_t f; \
d458 1
d460 8
d472 1
d475 1
d477 12
a488 1
	{ FAST fastf_t f;	f = 1.0/((m)[15]);\
d492 1
d496 1
a496 1
	{ FAST fastf_t f; 	f = 1.0/((m)[15]); \
d503 1
a503 1
	{ FAST fastf_t f; 	f = 1.0/((m)[15]); \
d519 1
d521 6
d530 1
@


7.2
log
@Added define for NEAR_ZERO.
@
text
@d43 1
a43 1
 *  $Header: vmath.h,v 7.1 87/11/02 23:22:47 mike Locked $
d49 8
a176 1
extern double sqrt();
@


7.1
log
@Release 2.3
@
text
@d43 1
a43 1
 *  $Header: vmath.h,v 6.2 87/09/09 09:43:46 stay Exp $
d48 2
@


6.2
log
@MAT4X4PNT assinged the Zth element to the Xth element causing havoc.
@
text
@d43 1
a43 1
 *  $Header: vmath.h,v 6.1 87/07/11 07:48:34 stay Locked $
@


6.1
log
@Release 2.0
@
text
@d43 1
a43 1
 *  $Header: vmath.h,v 5.1 87/06/24 21:47:32 mike Rel $
d231 1
a231 1
	(o)[X]=(m)[ 8]*(i)[X] + (m)[ 9]*(i)[Y] + (m)[10]*(i)[Z] + (m)[11]*(i)[H];\
@


5.1
log
@Release 1.24
@
text
@d43 1
a43 1
 *  $Header: vmath.h,v 4.5 87/05/30 05:54:58 mike Locked $
@


4.5
log
@changed some names to be more consistent.  house cleaning.
@
text
@d43 1
a43 1
 *  $Header: vmath.h,v 4.4 87/02/12 22:00:34 phil Locked $
@


4.4
log
@Release 1.20 -- First Formal Release
@
text
@d43 1
a43 1
 *  $Header: vmath.h,v 4.3 87/02/09 17:34:22 mike Exp $
d96 5
d187 2
a188 2
/* Apply the 3x3 part of a mat_t to a 3-tuple.  Post-multiply. */
#define MAT3XVEC(o,mat,vec) \
d193 2
a194 2
/* Multiply a 3-tuple by the 3x3 part of a mat_t.  Pre-multiply. */
#define VEC3x3MAT(o,i,m) \
d199 1
a199 1
/* Apply the 3x3 part of a mat_t to a 2-tuple (Z part=0).  Post-multiply */
d205 2
a206 2
/* Multiply a 2-tuple (Z=0) by the 3x3 part of a mat_t.  Pre-multiply */
#define VEC2x3MAT(o,i,m) \
d220 1
a220 1
#define PNT3x4MAT(o,i,m) \
d241 2
a242 2
/* Multiply a Relative 3-Vector by most of a 4x4 matrix.  Pre-multiply */
#define VEC3x4MAT(o,i,m) \
d248 2
a249 2
/* Multiply a Relative 2-Vector by most of a 4x4 matrix.  Pre-multiply */
#define VEC2x4MAT(o,i,m) \
a253 6

/* Reverse the direction of b and store it in a */
#define VREVERSE(a,b) \
	(a)[0] = -(b)[0]; \
	(a)[1] = -(b)[1]; \
	(a)[2] = -(b)[2];
@


4.3
log
@Release 1.18, updated headers.
@
text
@d43 1
a43 1
 *  $Header: vmath.h,v 4.2 87/01/28 22:33:52 mike Locked $
@


4.2
log
@Release 1.16:  VCOMB2,3 macros
@
text
@d7 4
a10 2
 *  post-multiplication, with column vectors, the BRL CAD system
 *  uses the more traditional representation of row vectors.  Therefore,
d24 2
a25 2
 *        y' =  (  R4   R5   R6   Dy  )  *  y
 *        z'    (  R8   R9   R10  Dz  )     z
d43 1
a43 1
 *  $Header: vmath.h,v 4.1 86/12/29 02:46:14 mike Locked $
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d41 1
a41 1
 *  $Header: vmath.h,v 2.8 86/09/23 22:06:30 mike Exp $
d128 11
@


2.8
log
@vect_t became 3-tuple, hvect_t is now the 4-tuple.
Added MAT4X4PNT, HDIVIDE macros.
@
text
@d41 1
a41 1
 *  $Header: vmath.h,v 2.7 86/07/24 06:02:04 mike Exp $
@


2.7
log
@Added VSETALL(), VMINMAX().
@
text
@d6 24
d41 1
a41 1
 *  $Header: vmath.h,v 2.6 86/07/11 01:30:22 mike Exp $
d53 4
a56 2
#define ELEMENTS_PER_VECT	4	/* # of fastf_t's per [xyzw] */
#define ELEMENTS_PER_PT         4
d64 3
d209 7
d252 6
@


2.6
log
@Minor cleanups inspired by the Cray
@
text
@d17 1
a17 1
 *  $Header: vmath.h,v 2.5 85/08/16 05:22:23 mike Exp $
d29 1
a29 1
#define ELEMENTS_PER_VECT	4	/* # of fastf_t's per [xyz] */
d57 3
d131 2
a132 2
#define VPRINT(a,b)	(void)fprintf(stderr,"%s (%f, %f, %f)\n", a, (b)[0], (b)[1], (b)[2])
#define HPRINT(a,b)	(void)fprintf(stderr,"%s (%f, %f, %f, %f)\n", a, (b)[0], (b)[1], (b)[2], (b)[3])
d209 7
@


2.5
log
@Added VEQUAL, made all fastf_t's within macros have storage class FAST.
@
text
@d17 1
a17 1
 *  $Header: vmath.h,v 2.4 85/07/30 05:33:58 mike Exp $
d20 3
d206 2
@


2.4
log
@Added ELEMENTS_PER_PT
@
text
@d17 1
a17 1
 *  $Header: vmath.h,v 2.3 85/07/30 04:13:14 mike Exp $
d160 1
a160 1
	{ LOCAL fastf_t f; \
d168 1
a168 1
	{ LOCAL fastf_t f; \
d176 1
a176 1
	{ LOCAL fastf_t f;	f = 1.0/((m)[15]);\
d183 1
a183 1
	{ LOCAL fastf_t f; 	f = 1.0/((m)[15]); \
d190 1
a190 1
	{ LOCAL fastf_t f; 	f = 1.0/((m)[15]); \
d200 3
@


2.3
log
@Combined GED & RT version.
@
text
@d17 1
a17 1
 *  $Header$
d27 1
d32 1
a32 1
typedef fastf_t	point_t[ELEMENTS_PER_VECT];
@


2.2
log
@Added error checking to VUNITIZE to prevent bad divisions.
@
text
@d17 1
a17 1
 *  $Header: vmath.h,v 2.2 85/05/29 15:44:53 mike Exp $
d20 14
d68 5
d89 1
a89 1
#define VUNITIZE(a)	{static double f; f = MAGNITUDE(a); \
d98 1
a98 1
#define VCOMPOSE(a,b,c,d,e,f)	\
d103 1
a103 1
#define VCOMP1(a,b,c,d) \
d124 2
a125 2
#define VPRINT(a,b)	(void)printf("%s (%f, %f, %f)\n", a, (b)[0], (b)[1], (b)[2])
#define HPRINT(a,b)	(void)printf("%s (%f, %f, %f, %f)\n", a, (b)[0], (b)[1], (b)[2], (b)[3])
a126 6
/* Acquire storage for a given struct, eg, GETSTRUCT(ptr,structname); */
#define GETSTRUCT(p,str) \
	p = (struct str *)malloc((unsigned)sizeof(struct str)); \
	if( p == (struct str *)0 ) \
		(void)printf("getstruct( p, str ): malloc failed\n");/* cpp magic */

d159 1
a159 1
	{ static double f; \
d167 1
a167 1
	{ static double f; \
d175 1
a175 1
	{ static double f;	f = 1.0/((m)[15]);\
d182 1
a182 1
	{ static double f; 	f = 1.0/((m)[15]); \
d189 1
a189 1
	{ static double f; 	f = 1.0/((m)[15]); \
@


2.1
log
@First production version.
@
text
@d17 1
a17 1
 *  $Header$
d70 2
a71 1
#define VUNITIZE(a)	{static float f; f = 1.0/MAGNITUDE(a); \
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
 * This header file defines many commonly used 3D vector math macros.
d6 1
a6 1
 * Author -
d9 9
a17 3
 *	Ballistic Research Laboratory
 *	U. S. Army
 *	March, 1980
d104 2
a105 2
#define VPRINT(a,b)	printf("%s (%f, %f, %f)\n", a, (b)[0], (b)[1], (b)[2])
#define HPRINT(a,b)	printf("%s (%f, %f, %f, %f)\n", a, (b)[0], (b)[1], (b)[2], (b)[3])
d109 1
a109 1
	p = (struct str *)malloc(sizeof(struct str)); \
d111 1
a111 1
		printf("getstruct( p, str ): malloc failed\n");/* cpp magic */
@
