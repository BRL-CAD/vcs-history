head	1.13;
access;
symbols
	ansi-20040405-merged:1.12
	postmerge-20040405-ansi:1.12
	premerge-20040404-ansi:1.12
	postmerge-autoconf:1.12
	autoconf-freeze:1.12
	premerge-autoconf:1.12
	ansi-20040316-freeze:1.12
	postmerge-20040315-windows:1.12
	premerge-20040315-windows:1.12
	windows-20040315-freeze:1.12
	autoconf-20031203:1.12
	autoconf-20031202:1.12
	autoconf-branch:1.12.0.12
	phong-branch:1.12.0.10
	photonmap-branch:1.12.0.8
	rel-6-1-DP:1.12
	windows-branch:1.12.0.6
	rel-6-0-2:1.12
	ansi-branch:1.12.0.4
	rel-6-0-1-branch:1.12.0.2
	hartley-6-0-post:1.12
	hartley-6-0-pre:1.12
	rel-6-0-1:1.12
	rel-6-0:1.12
	rel-5-4:1.10
	offsite-5-3-pre:1.11
	rel-5-3:1.10
	rel-5-2:1.10
	rel-5-1-branch:1.10.0.2
	rel-5-1:1.10
	rel-5-0:1.10
	rel-5-0-beta:1.10
	rel-4-5:1.7
	ctj-4-5-post:1.7
	ctj-4-5-pre:1.7;
locks; strict;
comment	@ * @;


1.13
date	2004.05.24.04.11.54;	author morrison;	state dead;
branches;
next	1.12;

1.12
date	2001.04.05.19.35.08;	author morrison;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.19.19.19.45;	author butler;	state Exp;
branches;
next	1.10;

1.10
date	98.12.11.20.53.54;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	98.12.11.20.40.36;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	98.11.19.03.39.32;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	96.04.06.00.58.18;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	96.03.16.00.56.14;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	96.03.16.00.48.19;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	96.03.09.04.34.19;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	96.02.28.03.21.31;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	96.02.28.02.01.11;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	96.02.27.09.16.34;	author mike;	state Exp;
branches;
next	;


desc
@h/spectrum.h
@


1.13
log
@moved/renamed from top-level h/ to top-level include/
@
text
@/*
 *			S P E C T R U M . H
 *
 *  A header file containing data structures to assist with
 *  recording spectral data.
 *  The overall notion is that each spectral sample should be
 *  as compact as possible (typically just an array of power levels),
 *  with all the context stored in one place.
 *
 *  The context is kept in an 'bn_table' structure, and
 *  the data for one particular sample are kept in an 'bn_tabdata'
 *  structure.
 *  tabdata.h provides the data structures, 
 *  librt/tabdata.c provides the routines.
 *
 *  The contents of the spectral sample in val[j] are interpreted
 *  in the interval (wavel[j]..wavel[j+1]).
 *  This value could be power, albedo, absorption, refractive index,
 *  or any other wavelength-specific parameter.
 *
 *  For example, if the val[] array contains power values, then
 *  val[j] contains the integral of the power from wavel[j] to wavel[j+1]
 *
 *  As an exmple, assume nwave=2, wavel[0]=500, wavel[1]=600, wavel[2]=700.
 *  Then val[0] would contain data for the 500 to 600nm interval,
 *  and val[1] would contain data for the 600 to 700nm interval.
 *  There would be no storage allocated for val[2] -- don't use it!
 *  There are several interpretations of this:
 *	1)  val[j] stores the total (integral, area) value for the interval, or
 *	2)  val[j] stores the average value across the interval.
 *
 *  The intervals need not be uniformly spaced; it is acceptable to
 *  increase wavelength sampling density around "important" frequencies.
 *  This will undoubtably complicate certain functions.
 *
 *  By convention, wavelength is stored in nanometers as an integer,
 *  and power is stored in Watts.
 *
 *  Wavelength Units -
 *	cm = 10** -2 m	centimeters
 *	mm = 10** -3 m	milimeters
 *	um = 10** -6 m	micrometers, or microns
 *	nm = 10** -9 m	nanometers
 *
 *  The Spectrum in nm -
 *	< 10 nm			X-Rays
 *	10 to 390		Ultraviolet
 *	390 to 770		Visible
 *	770 to 1500		Near IR
 *	1500 to 6,000		Middle IR	(includes 3-5 um band)
 *	6,000 to 40,000		Far IR		(includes 8-12 um band)
 *	40,000 to 1,000,000	Extreme IR
 *	> 10**6 nm		Microwaves	(300 GHz to 300 MHz)
 *	> 10**9 nm		Radio waves	(300 MHz and down)
 *
 *  It is tempting to store the wavelength in nanometers as an integer,
 *  but that might preclude very narrow-band calculations, such as might
 *  be required to study a single spectral line,
 *  and it might also preclude future extensions to X-rays.
 *  Because there are likely to be very few bn_table structures
 *  in use, the extra storage isn't a likely problem.
 *  The worst effect of this decision will be floating-point grunge
 *  when printing wavelengths, e.g. 650nm might print as 649.99nm.
 *  On the other hand, non-integer values might make it difficult to
 *  determine if two wavelengths from different curves were the "same",
 *  without introducing a wavelength "tolerance" notion.  Ugh.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
 *
 *  $Header: /n/xoff/cvs/brlcad/h/spectrum.h,v 1.12 2001/04/05 19:35:08 morrison Exp $
 */

/*
 * Routines
 */
BU_EXTERN( void			rt_spect_make_CIE_XYZ, (
					struct bn_tabdata **x,
					struct bn_tabdata **y,
					struct bn_tabdata **z,
					const struct bn_table *tabp));

BU_EXTERN( void			rt_spect_black_body, (struct bn_tabdata *data,
					double temp, unsigned int n));
BU_EXTERN( void			rt_spect_black_body_fast, (
					struct bn_tabdata *data,
					double temp));

BU_EXTERN(void			rt_spect_reflectance_rgb, 
	  (struct bn_tabdata	*curve, 
	   const float		rgb[3]));


@


1.12
log
@updated SIGNED to signed
updated CONST to const
@
text
@d78 1
a78 1
 *  $Header: /c/CVS/brlcad/h/spectrum.h,v 1.11 2000/10/19 19:19:45 butler Exp $
@


1.11
log
@Changes to compile under RedHat 7.0
@
text
@d78 1
a78 1
 *  $Header: /c/CVS/brlcad/h/spectrum.h,v 1.10 1998/12/11 20:53:54 mike Exp $
d88 1
a88 1
					CONST struct bn_table *tabp));
d98 1
a98 1
	   CONST float		rgb[3]));
@


1.10
log
@Drat, I missed some more rt_tabdata -> bn_tabdata changes.
@
text
@d78 1
a78 1
 *  $Header: /c/CVS/brlcad/h/spectrum.h,v 1.9 1998/12/11 20:40:36 mike Exp $
d95 6
@


1.9
log
@rt_tabdata is now bn_tabdata
@
text
@d10 2
a11 2
 *  The context is kept in an 'rt_table' structure, and
 *  the data for one particular sample are kept in an 'rt_tabdata'
d60 1
a60 1
 *  Because there are likely to be very few rt_table structures
d78 1
a78 1
 *  $Header: /c/CVS/brlcad/h/spectrum.h,v 1.8 1998/11/19 03:39:32 mike Exp $
@


1.8
log
@BU_EXTERN instead of RT_EXTERN
@
text
@d78 1
a78 1
 *  $Header: /c/CVS/brlcad/h/spectrum.h,v 1.7 1996/04/06 00:58:18 mike Exp $
d85 4
a88 4
					struct rt_tabdata **x,
					struct rt_tabdata **y,
					struct rt_tabdata **z,
					CONST struct rt_table *tabp));
d90 1
a90 1
BU_EXTERN( void			rt_spect_black_body, (struct rt_tabdata *data,
d93 1
a93 1
					struct rt_tabdata *data,
@


1.7
log
@Moved rt_table stuff out into h/tabdata.h
@
text
@d78 1
a78 1
 *  $Header: /m/cad/h/RCS/spectrum.h,v 1.6 1996/03/16 00:56:14 mike Exp mike $
d84 1
a84 1
RT_EXTERN( void			rt_spect_make_CIE_XYZ, (
d90 1
a90 1
RT_EXTERN( void			rt_spect_black_body, (struct rt_tabdata *data,
d92 1
a92 1
RT_EXTERN( void			rt_spect_black_body_fast, (
@


1.6
log
@One missing
@
text
@a1 2
 *			T A B L E . H
 * and
a2 1
    ...soon to be separated...
a9 7
 *  NOTE that this is really a much more general mechanism than originally
 *  envisioned -- these structures and support routines apply to
 *  any measured "curve" or "function" or "table" with one independent
 *  variable and scalar dependent variable(s).
 *  It is unclear how to properly generalize the names....  Ahh, packaging.
 *  Perhaps the "table" package?
 *
d13 2
d78 1
a78 1
 *  $Header: /m/cad/h/RCS/spectrum.h,v 1.5 1996/03/16 00:48:19 mike Exp mike $
a80 39
struct rt_table {
	long		magic;
	int		nx;
	fastf_t		x[1];	/* array of nx+1 wavelengths, dynamically sized */
};
#define RT_TABLE_MAGIC	0x53706374
#define RT_CK_TABLE(_p)	RT_CKMAG(_p, RT_TABLE_MAGIC, "rt_table")

/* Gets an rt_table, with x[] having size _nx+1 */
#define RT_GET_TABLE(_table, _nx)  { \
	if( (_nx) < 1 )  rt_bomb("RT_GET_TABLE() _nx < 1\n"); \
	_table = (struct rt_table *)rt_calloc( 1, \
		sizeof(struct rt_table) + sizeof(fastf_t)*(_nx), \
		"struct rt_table" ); \
	_table->magic = RT_TABLE_MAGIC; \
	_table->nx = (_nx);  }


struct rt_tabdata {
	long		magic;
	int		ny;
	CONST struct rt_table *table;	/* Up pointer to definition of X axis */
	fastf_t		y[1];		/* array of ny samples, dynamically sized */
};
#define RT_TABDATA_MAGIC	0x53736d70
#define RT_CK_TABDATA(_p)	RT_CKMAG(_p, RT_TABDATA_MAGIC, "rt_tabdata")

#define RT_SIZEOF_TABDATA(_table)	( sizeof(struct rt_tabdata) + \
			sizeof(fastf_t)*((_table)->nx-1) )

/* Gets an rt_tabdata, with y[] having size _ny */
#define RT_GET_TABDATA(_data, _table)  { \
	RT_CK_TABLE(_table);\
	_data = (struct rt_tabdata *)rt_calloc( 1, \
		RT_SIZEOF_TABDATA(_table), "struct rt_tabdata" ); \
	_data->magic = RT_TABDATA_MAGIC; \
	_data->ny = (_table)->nx; \
	_data->table = (_table); }

d82 1
a82 41
 * *** Table-generic routines
 */

RT_EXTERN( void			rt_ck_table, (CONST struct rt_table *tabp));
RT_EXTERN( struct rt_table	*rt_table_make_uniform, (int num, double first,
					double last));
RT_EXTERN( void			rt_tabdata_add, (struct rt_tabdata *out,
					CONST struct rt_tabdata *in1,
					CONST struct rt_tabdata *in2));
RT_EXTERN( void			rt_tabdata_mul, (struct rt_tabdata *out,
					CONST struct rt_tabdata *in1,
					CONST struct rt_tabdata *in2));
RT_EXTERN( void			rt_tabdata_scale, (struct rt_tabdata *out,
					CONST struct rt_tabdata *in1,
					double scale));
RT_EXTERN( double		rt_tabdata_area1, (CONST struct rt_tabdata *in));
RT_EXTERN( double		rt_tabdata_area2, (CONST struct rt_tabdata *in));
RT_EXTERN( fastf_t		rt_table_lin_interp, (CONST struct rt_tabdata *samp,
					double wl));
RT_EXTERN( struct rt_tabdata	*rt_tabdata_resample, (
					CONST struct rt_table *newtable,
					CONST struct rt_tabdata *olddata));
RT_EXTERN( int			rt_table_write, (CONST char *filename,
					CONST struct rt_table *tabp));
RT_EXTERN( struct rt_table	*rt_table_read, (CONST char *filename));
RT_EXTERN( int			rt_pr_table_and_tabdata, (CONST char *filename,
					CONST struct rt_tabdata *data));
RT_EXTERN( struct rt_tabdata	*rt_read_table_and_tabdata, (
					CONST char *filename));
RT_EXTERN( struct rt_tabdata	*rt_tabdata_binary_read, (CONST char *filename,
					int num,
					CONST struct rt_table *tabp));
RT_EXTERN( struct rt_tabdata	*rt_tabdata_malloc_array, (
					CONST struct rt_table *tabp,
					int num));
RT_EXTERN( void			rt_tabdata_copy, (struct rt_tabdata *out,
					CONST struct rt_tabdata *in));


/*
 * *** Spectrum-specific routines
@


1.5
log
@Converting over to table.h
@
text
@d86 1
a86 1
 *  $Header: /m/cad/h/RCS/spectrum.h,v 1.4 1996/03/09 04:34:19 mike Exp $
d158 3
@


1.4
log
@Added more externs
@
text
@d2 2
d5 1
d20 2
a21 2
 *  The context is kept in an 'rt_spectrum' structure, and
 *  the data for one particular sample are kept in an 'rt_spectral_sample'
d68 1
a68 1
 *  Because there are likely to be very few rt_spectrum structures
d86 1
a86 1
 *  $Header: /m/cad/h/RCS/spectrum.h,v 1.3 1996/02/28 03:21:31 mike Exp mike $
d89 4
a92 4
struct rt_spectrum {
	long	magic;
	int	nwave;
	fastf_t	wavel[1];	/* array of nwave+1 wavelengths, dynamically sized */
d94 2
a95 2
#define RT_SPECTRUM_MAGIC	0x53706374
#define RT_CK_SPECTRUM(_p)	RT_CKMAG(_p, RT_SPECTRUM_MAGIC, "rt_spectrum")
d97 15
a111 15
/* Gets an rt_spectrum, with wavel[] having size _nwave+1 */
#define RT_GET_SPECTRUM(_spect, _nwave)  { \
	if( (_nwave) < 1 )  rt_bomb("RT_GET_SPECTRUM() _nwave < 1\n"); \
	_spect = (struct rt_spectrum *)rt_calloc( 1, \
		sizeof(struct rt_spectrum) + sizeof(fastf_t)*(_nwave), \
		"struct rt_spectrum" ); \
	_spect->magic = RT_SPECTRUM_MAGIC; \
	_spect->nwave = (_nwave);  }


struct rt_spect_sample {
	long	magic;
	int	nwave;
	CONST struct rt_spectrum *spectrum;	/* Up pointer to "struct spectrum" */
	fastf_t	val[1];		/* array of nwave samples, dynamically sized */
d113 2
a114 2
#define RT_SPECT_SAMPLE_MAGIC	0x53736d70
#define RT_CK_SPECT_SAMPLE(_p)	RT_CKMAG(_p, RT_SPECT_SAMPLE_MAGIC, "rt_spect_sample")
d116 2
a117 2
#define RT_SIZEOF_SPECT_SAMPLE(_spect)	( sizeof(struct rt_spect_sample) + \
			sizeof(fastf_t)*((_spect)->nwave-1) )
d119 8
a126 8
/* Gets an rt_spect_sample, with val[] having size _nwave */
#define RT_GET_SPECT_SAMPLE(_ssamp, _spect)  { \
	RT_CK_SPECTRUM(_spect);\
	_ssamp = (struct rt_spect_sample *)rt_calloc( 1, \
		RT_SIZEOF_SPECT_SAMPLE(_spect), "struct rt_spect_sample" ); \
	_ssamp->magic = RT_SPECT_SAMPLE_MAGIC; \
	_ssamp->nwave = (_spect)->nwave; \
	_ssamp->spectrum = (_spect); }
d128 6
a133 1
RT_EXTERN( struct rt_spectrum	*rt_spect_uniform, (int num, double first,
d135 8
a142 8
RT_EXTERN( void			rt_spect_add, (struct rt_spect_sample *out,
					CONST struct rt_spect_sample *in1,
					CONST struct rt_spect_sample *in2));
RT_EXTERN( void			rt_spect_mul, (struct rt_spect_sample *out,
					CONST struct rt_spect_sample *in1,
					CONST struct rt_spect_sample *in2));
RT_EXTERN( void			rt_spect_scale, (struct rt_spect_sample *out,
					CONST struct rt_spect_sample *in1,
d144 3
a146 8
RT_EXTERN( double		rt_spect_area1, (CONST struct rt_spect_sample *in));
RT_EXTERN( double		rt_spect_area2, (CONST struct rt_spect_sample *in));
RT_EXTERN( void			rt_spect_make_CIE_XYZ, (
					struct rt_spect_sample **x,
					struct rt_spect_sample **y,
					struct rt_spect_sample **z,
					CONST struct rt_spectrum *spect));
RT_EXTERN( fastf_t		rt_spect_evaluate, (CONST struct rt_spect_sample *samp,
d148 9
a156 9
RT_EXTERN( struct rt_spect_sample *rt_spect_resample, (
					CONST struct rt_spectrum *newspect,
					CONST struct rt_spect_sample *oldsamp));
RT_EXTERN( int			rt_write_spectrum, (CONST char *filename,
					CONST struct rt_spectrum *spect));
RT_EXTERN( struct rt_spectrum	*rt_read_spectrum, (CONST char *filename));
RT_EXTERN( int			rt_write_spect_sample, (CONST char *filename,
					CONST struct rt_spect_sample *ss));
RT_EXTERN( struct rt_spect_sample *rt_read_spectrum_and_samples, (
d158 17
a174 1
RT_EXTERN( void			rt_spect_black_body, (struct rt_spect_sample *ss,
d177 1
a177 1
					struct rt_spect_sample *ss,
a178 5
RT_EXTERN( struct rt_spect_sample *rt_get_spect_sample_array, (
					CONST struct rt_spectrum *spect,
					int num));
RT_EXTERN( void			rt_spect_copy, (struct rt_spect_sample *out,
					CONST struct rt_spect_sample *in));
@


1.3
log
@Added another macro, more routines
@
text
@d15 1
d83 1
a83 1
 *  $Header: /m/cad/h/RCS/spectrum.h,v 1.2 1996/02/28 02:01:11 mike Exp mike $
d143 8
d153 2
d163 2
@


1.2
log
@Added externs
@
text
@d82 1
a82 1
 *  $Header: /m/cad/h/RCS/spectrum.h,v 1.1 1996/02/27 09:16:34 mike Exp mike $
a105 1
	/* Next item is dubious, it might force keeping use counts in rt_spectrum */
d112 3
d119 1
a119 3
		sizeof(struct rt_spect_sample) + \
			sizeof(fastf_t)*((_spect)->nwave-1), \
		"struct rt_spect_sample" ); \
d142 1
a142 1
RT_EXTERN( void			rt_write_spect_sample, (CONST char *filename,
d149 3
@


1.1
log
@Initial revision
@
text
@d10 6
d82 1
a82 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 11.30 1996/01/04 23:41:49 butler Exp $
d123 26
@
