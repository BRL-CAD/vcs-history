head	1.65;
access;
symbols
	ansi-20040405-merged:1.59.2.2
	postmerge-20040405-ansi:1.61
	premerge-20040404-ansi:1.60
	postmerge-autoconf:1.60
	autoconf-freeze:1.59.10.1
	premerge-autoconf:1.60
	ansi-20040316-freeze:1.59.2.1
	postmerge-20040315-windows:1.60
	premerge-20040315-windows:1.60
	windows-20040315-freeze:1.59.4.1
	autoconf-20031203:1.59
	autoconf-20031202:1.59
	autoconf-branch:1.59.0.10
	phong-branch:1.59.0.8
	photonmap-branch:1.59.0.6
	rel-6-1-DP:1.59
	windows-branch:1.59.0.4
	rel-6-0-2:1.57
	ansi-branch:1.59.0.2
	rel-6-0-1-branch:1.57.0.2
	hartley-6-0-post:1.58
	hartley-6-0-pre:1.57
	rel-6-0-1:1.57
	rel-6-0:1.56
	rel-5-4:1.53.2.1
	offsite-5-3-pre:1.55
	rel-5-3:1.53.2.1
	rel-5-2:1.53.2.1
	rel-5-1-branch:1.53.0.2
	rel-5-1:1.53
	rel-5-0:1.41
	rel-5-0-beta:1.39
	rel-4-5:1.28
	ctj-4-5-post:1.19
	ctj-4-5-pre:1.19;
locks; strict;
comment	@ * @;


1.65
date	2004.05.21.18.06.25;	author morrison;	state dead;
branches;
next	1.64;

1.64
date	2004.05.10.15.30.44;	author erikg;	state Exp;
branches;
next	1.63;

1.63
date	2004.05.10.15.25.26;	author morrison;	state Exp;
branches;
next	1.62;

1.62
date	2004.05.05.14.20.27;	author morrison;	state Exp;
branches;
next	1.61;

1.61
date	2004.04.05.07.45.07;	author morrison;	state Exp;
branches;
next	1.60;

1.60
date	2004.02.02.17.39.08;	author morrison;	state Exp;
branches;
next	1.59;

1.59
date	2002.08.20.17.07.44;	author jra;	state Exp;
branches
	1.59.2.1
	1.59.4.1
	1.59.10.1;
next	1.58;

1.58
date	2002.08.15.20.54.57;	author hartley;	state Exp;
branches;
next	1.57;

1.57
date	2002.06.19.20.08.10;	author butler;	state Exp;
branches;
next	1.56;

1.56
date	2001.03.31.01.56.52;	author morrison;	state Exp;
branches;
next	1.55;

1.55
date	2000.08.31.18.16.42;	author bparker;	state Exp;
branches;
next	1.54;

1.54
date	2000.08.17.18.15.20;	author bparker;	state Exp;
branches;
next	1.53;

1.53
date	2000.02.18.21.10.10;	author bparker;	state Exp;
branches
	1.53.2.1;
next	1.52;

1.52
date	2000.01.28.15.40.57;	author bparker;	state Exp;
branches;
next	1.51;

1.51
date	2000.01.24.19.09.22;	author butler;	state Exp;
branches;
next	1.50;

1.50
date	2000.01.21.19.09.06;	author bparker;	state Exp;
branches;
next	1.49;

1.49
date	2000.01.20.18.41.07;	author bparker;	state Exp;
branches;
next	1.48;

1.48
date	99.12.29.20.51.35;	author jra;	state Exp;
branches;
next	1.47;

1.47
date	99.12.27.21.10.48;	author bparker;	state Exp;
branches;
next	1.46;

1.46
date	99.12.17.16.38.47;	author bparker;	state Exp;
branches;
next	1.45;

1.45
date	99.12.01.16.02.24;	author bparker;	state Exp;
branches;
next	1.44;

1.44
date	99.12.01.13.31.14;	author bparker;	state Exp;
branches;
next	1.43;

1.43
date	99.11.03.14.28.18;	author bparker;	state Exp;
branches;
next	1.42;

1.42
date	99.11.02.14.10.13;	author bparker;	state Exp;
branches;
next	1.41;

1.41
date	99.07.23.20.19.12;	author bparker;	state Exp;
branches;
next	1.40;

1.40
date	99.06.16.23.23.02;	author jra;	state Exp;
branches;
next	1.39;

1.39
date	99.05.10.20.51.58;	author bparker;	state Exp;
branches;
next	1.38;

1.38
date	99.05.10.20.29.48;	author bparker;	state Exp;
branches;
next	1.37;

1.37
date	99.04.26.19.19.20;	author bparker;	state Exp;
branches;
next	1.36;

1.36
date	99.02.17.20.02.41;	author bparker;	state Exp;
branches;
next	1.35;

1.35
date	99.01.12.17.52.08;	author bparker;	state Exp;
branches;
next	1.34;

1.34
date	98.06.15.18.55.06;	author bparker;	state Exp;
branches;
next	1.33;

1.33
date	98.06.12.19.48.17;	author bparker;	state Exp;
branches;
next	1.32;

1.32
date	98.04.23.13.48.37;	author bparker;	state Exp;
branches;
next	1.31;

1.31
date	98.03.03.15.07.45;	author jra;	state Exp;
branches;
next	1.30;

1.30
date	98.03.02.20.39.50;	author bparker;	state Exp;
branches;
next	1.29;

1.29
date	98.02.26.15.06.27;	author bparker;	state Exp;
branches;
next	1.28;

1.28
date	98.01.05.20.28.50;	author bparker;	state Exp;
branches;
next	1.27;

1.27
date	97.12.16.14.33.53;	author pjt;	state Exp;
branches;
next	1.26;

1.26
date	97.11.21.20.59.03;	author bparker;	state Exp;
branches;
next	1.25;

1.25
date	97.11.03.20.06.28;	author bparker;	state Exp;
branches;
next	1.24;

1.24
date	97.10.10.21.10.52;	author bparker;	state Exp;
branches;
next	1.23;

1.23
date	97.10.10.16.49.52;	author bparker;	state Exp;
branches;
next	1.22;

1.22
date	97.10.10.13.00.24;	author bparker;	state Exp;
branches;
next	1.21;

1.21
date	97.09.23.21.16.23;	author bparker;	state Exp;
branches;
next	1.20;

1.20
date	97.08.01.21.22.47;	author bparker;	state Exp;
branches;
next	1.19;

1.19
date	97.05.21.13.03.44;	author bparker;	state Exp;
branches;
next	1.18;

1.18
date	97.05.08.14.10.41;	author bparker;	state Exp;
branches;
next	1.17;

1.17
date	97.04.24.18.14.07;	author bparker;	state Exp;
branches;
next	1.16;

1.16
date	97.04.23.18.38.02;	author bparker;	state Exp;
branches;
next	1.15;

1.15
date	97.04.22.15.05.26;	author bparker;	state Exp;
branches;
next	1.14;

1.14
date	97.03.03.19.59.39;	author bparker;	state Exp;
branches;
next	1.13;

1.13
date	97.03.03.18.32.11;	author bparker;	state Exp;
branches;
next	1.12;

1.12
date	97.01.24.21.06.44;	author bparker;	state Exp;
branches;
next	1.11;

1.11
date	97.01.08.02.47.03;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	97.01.02.20.03.29;	author bparker;	state Exp;
branches;
next	1.9;

1.9
date	96.12.04.21.26.04;	author bparker;	state Exp;
branches;
next	1.8;

1.8
date	96.10.24.22.13.14;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	96.10.23.20.28.49;	author bparker;	state Exp;
branches;
next	1.6;

1.6
date	96.10.04.20.28.06;	author bparker;	state Exp;
branches;
next	1.5;

1.5
date	96.09.30.19.40.38;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	96.09.26.20.37.27;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	96.09.25.20.28.29;	author bparker;	state Exp;
branches;
next	1.2;

1.2
date	96.09.23.17.40.15;	author bparker;	state Exp;
branches;
next	1.1;

1.1
date	96.09.17.21.24.32;	author bparker;	state Exp;
branches;
next	;

1.53.2.1
date	2000.09.01.17.24.43;	author bparker;	state Exp;
branches;
next	;

1.59.2.1
date	2002.09.19.18.01.17;	author morrison;	state Exp;
branches;
next	1.59.2.2;

1.59.2.2
date	2004.03.17.21.16.57;	author morrison;	state Exp;
branches;
next	;

1.59.4.1
date	2004.03.11.23.42.01;	author morrison;	state Exp;
branches;
next	;

1.59.10.1
date	2004.02.12.19.45.18;	author erikg;	state Exp;
branches;
next	;


desc
@Opengl Display Manager
@


1.65
log
@moved to src/
@
text
@/*
 *			D M - O G L . C
 *
 *  An X/ogl Display Manager.
 *  
 *  Authors -
 *	Carl Nuzman
 *	Robert G. Parker
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1988-2004 by the United States Army.
 *	All rights reserved.
 *
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include "tk.h"

#undef VMIN		/* is used in vmath.h, too */

#ifdef HAVE_XOSDEFS_H
#include <X11/Xfuncproto.h>
#include <X11/Xosdefs.h>
#endif
#if defined(linux)
#	undef   X_NOT_STDC_ENV
#	undef   X_NOT_POSIX
#endif

#define XLIB_ILLEGAL_ACCESS	/* necessary on facist SGI 5.0.1 */

#include <X11/extensions/XInput.h>
#include <GL/glx.h>
#include <GL/gl.h>

#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <math.h>
#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "dm.h"
#include "dm-ogl.h"
#include "dm_xvars.h"
#include "solid.h"

#define VIEWFACTOR      (1.0/(*dmp->dm_vp))
#define VIEWSIZE        (2.0*(*dmp->dm_vp))

/* these are from /usr/include/gl.h could be device dependent */
#define XMAXSCREEN	1279
#define YMAXSCREEN	1023
#define YSTEREO		491	/* subfield height, in scanlines */
#define YOFFSET_LEFT	532	/* YSTEREO + YBLANK ? */

#define USE_VECTOR_THRESHHOLD 0

#if USE_VECTOR_THRESHHOLD
extern int vectorThreshold;	/* defined in libdm/tcl.c */ 
#endif

static int ogl_actively_drawing;
HIDDEN XVisualInfo *ogl_choose_visual(struct dm *dmp, Tk_Window tkwin);

/* Display Manager package interface */
#define IRBOUND	4095.9	/* Max magnification in Rot matrix */

#define PLOTBOUND	1000.0	/* Max magnification in Rot matrix */
struct dm	*ogl_open(Tcl_Interp *interp, int argc, char **argv);
HIDDEN int	ogl_close(struct dm *dmp);
HIDDEN int	ogl_drawBegin(struct dm *dmp);
HIDDEN int      ogl_drawEnd(struct dm *dmp);
HIDDEN int	ogl_normal(struct dm *dmp), ogl_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye);
HIDDEN int	ogl_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect);
HIDDEN int	ogl_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2);
HIDDEN int      ogl_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y);
HIDDEN int	ogl_drawVList(struct dm *dmp, register struct bn_vlist *vp);
HIDDEN int      ogl_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict, fastf_t transparency);
HIDDEN int	ogl_setBGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b);
HIDDEN int	ogl_setLineAttr(struct dm *dmp, int width, int style);
HIDDEN int	ogl_configureWin_guts(struct dm *dmp, int force);
HIDDEN int	ogl_configureWin(struct dm *dmp);
HIDDEN int	ogl_setLight(struct dm *dmp, int lighting_on);
HIDDEN int	ogl_setTransparency(struct dm *dmp, int transparency_on);
HIDDEN int	ogl_setDepthMask(struct dm *dmp, int depthMask_on);
HIDDEN int	ogl_setZBuffer(struct dm *dmp, int zbuffer_on);
HIDDEN int	ogl_setWinBounds(struct dm *dmp, int *w), ogl_debug(struct dm *dmp, int lvl);
HIDDEN int      ogl_beginDList(struct dm *dmp, unsigned int list), ogl_endDList(struct dm *dmp);
HIDDEN int      ogl_drawDList(struct dm *dmp, unsigned int list);
HIDDEN int      ogl_freeDLists(struct dm *dmp, unsigned int list, int range);

struct dm dm_ogl = {
  ogl_close,
  ogl_drawBegin,
  ogl_drawEnd,
  ogl_normal,
  ogl_loadMatrix,
  ogl_drawString2D,
  ogl_drawLine2D,
  ogl_drawPoint2D,
  ogl_drawVList,
  ogl_setFGColor,
  ogl_setBGColor,
  ogl_setLineAttr,
  ogl_configureWin,
  ogl_setWinBounds,
  ogl_setLight,
  ogl_setTransparency,
  ogl_setDepthMask,
  ogl_setZBuffer,
  ogl_debug,
  ogl_beginDList,
  ogl_endDList,
  ogl_drawDList,
  ogl_freeDLists,
  0,
  1,				/* has displaylist */
  0,                            /* no stereo by default */
  1.0,				/* zoom-in limit */
  1,				/* bound flag */
  "ogl",
  "X Windows with OpenGL graphics",
  DM_TYPE_OGL,
  1,
  0,
  0,
  0,
  0,
  1.0, /* aspect ratio */
  0,
  {0, 0},
  {0, 0, 0, 0, 0},		/* bu_vls path name*/
  {0, 0, 0, 0, 0},		/* bu_vls full name drawing window */
  {0, 0, 0, 0, 0},		/* bu_vls short name drawing window */
  {0, 0, 0},			/* bg color */
  {0, 0, 0},			/* fg color */
  {GED_MIN, GED_MIN, GED_MIN},	/* clipmin */
  {GED_MAX, GED_MAX, GED_MAX},	/* clipmax */
  0,				/* no debugging */
  0,				/* no perspective */
  0,				/* no lighting */
  0,				/* no transparency */
  1,				/* zbuffer */
  0,				/* no zclipping */
  1,                            /* clear back buffer after drawing and swap */
  0				/* Tcl interpreter */
};

HIDDEN fastf_t default_viewscale = 1000.0;
HIDDEN double	xlim_view = 1.0;	/* args for glOrtho*/
HIDDEN double	ylim_view = 1.0;

/* lighting parameters */
HIDDEN float amb_three[] = {0.3, 0.3, 0.3, 1.0};


HIDDEN float light0_direction[] = {0.0, 0.0, 1.0, 0.0};
HIDDEN float light0_position[] = {100.0, 200.0, 100.0, 0.0};
HIDDEN float light0_diffuse[] = {1.0, 1.0, 1.0, 1.0}; /* white */
HIDDEN float wireColor[4];
HIDDEN float ambientColor[4];
HIDDEN float specularColor[4];
HIDDEN float diffuseColor[4];

void
ogl_fogHint(struct dm *dmp, int fastfog)
{
  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.fastfog = fastfog;
  glHint(GL_FOG_HINT, fastfog ? GL_FASTEST : GL_NICEST);
}

/*
 *			O G L _ O P E N
 *
 * Fire up the display manager, and the display processor.
 *
 */
struct dm *
ogl_open(Tcl_Interp *interp, int argc, char **argv)
{
  static int count = 0;
  GLfloat backgnd[4];
  int j, k;
  int make_square = -1;
  int ndevices;
  int nclass = 0;
  XDeviceInfoPtr olist, list;
  XDevice *dev;
  XEventClass e_class[15];
  XInputClassInfo *cip;
  struct bu_vls str;
  struct bu_vls init_proc_vls;
  Display *tmp_dpy;
  struct dm *dmp;
  Tk_Window tkwin;

  if((tkwin = Tk_MainWindow(interp)) == NULL){
	  return DM_NULL;
  }

  BU_GETSTRUCT(dmp, dm);
  if(dmp == DM_NULL)
    return DM_NULL;

  *dmp = dm_ogl; /* struct copy */
  dmp->dm_interp = interp;

  dmp->dm_vars.pub_vars = (genptr_t)bu_calloc(1, sizeof(struct dm_xvars), "ogl_open: dm_xvars");
  if(dmp->dm_vars.pub_vars == (genptr_t)NULL){
    bu_free(dmp, "ogl_open: dmp");
    return DM_NULL;
  }

  dmp->dm_vars.priv_vars = (genptr_t)bu_calloc(1, sizeof(struct ogl_vars), "ogl_open: ogl_vars");
  if(dmp->dm_vars.priv_vars == (genptr_t)NULL){
    bu_free(dmp->dm_vars.pub_vars, "ogl_open: dmp->dm_vars.pub_vars");
    bu_free(dmp, "ogl_open: dmp");
    return DM_NULL;
  }

  dmp->dm_vp = &default_viewscale;

  bu_vls_init(&dmp->dm_pathName);
  bu_vls_init(&dmp->dm_tkName);
  bu_vls_init(&dmp->dm_dName);
  bu_vls_init(&init_proc_vls);

  dm_processOptions(dmp, &init_proc_vls, --argc, ++argv);

  if(bu_vls_strlen(&dmp->dm_pathName) == 0)
     bu_vls_printf(&dmp->dm_pathName, ".dm_ogl%d", count);
  ++count;
  if(bu_vls_strlen(&dmp->dm_dName) == 0){
    char *dp;

    dp = getenv("DISPLAY");
    if(dp)
      bu_vls_strcpy(&dmp->dm_dName, dp);
    else
      bu_vls_strcpy(&dmp->dm_dName, ":0.0");
  }
  if(bu_vls_strlen(&init_proc_vls) == 0)
    bu_vls_strcpy(&init_proc_vls, "bind_dm");

  /* initialize dm specific variables */
  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devmotionnotify = LASTEvent;
  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devbuttonpress = LASTEvent;
  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devbuttonrelease = LASTEvent;
  dmp->dm_aspect = 1.0;

  /* initialize modifiable variables */
  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.rgb = 1;
  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.doublebuffer = 1;
  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.fastfog = 1;
  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.fogdensity = 1.0;
  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.lighting_on = dmp->dm_light;
  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.zbuffer_on = dmp->dm_zbuffer;
  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.zclipping_on = dmp->dm_zclip;
  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.debug = dmp->dm_debugLevel;
  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.bound = dmp->dm_bound;
  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.boundFlag = dmp->dm_boundFlag;

  /* this is important so that ogl_configureWin knows to set the font */
  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct = NULL;

  if((tmp_dpy = XOpenDisplay(bu_vls_addr(&dmp->dm_dName))) == NULL){
    bu_vls_free(&init_proc_vls);
    (void)ogl_close(dmp);
    return DM_NULL;
  }
#ifndef USE_MESA_GL
  {
    int return_val;

    if(!XQueryExtension(tmp_dpy, "GLX", &return_val, &return_val, &return_val)){
      bu_vls_free(&init_proc_vls);
      (void)ogl_close(dmp);
      return DM_NULL;
    }
  }
#endif
  if(dmp->dm_width == 0){
    dmp->dm_width =
      DisplayWidth(tmp_dpy, DefaultScreen(tmp_dpy)) - 30;
     ++make_square;
  }
  if(dmp->dm_height == 0){
    dmp->dm_height =
      DisplayHeight(tmp_dpy, DefaultScreen(tmp_dpy)) - 30;
     ++make_square;
  }

  if(make_square > 0){
    /* Make window square */
    if(dmp->dm_height <
       dmp->dm_width)
      dmp->dm_width =
	dmp->dm_height;
    else
      dmp->dm_height =
	dmp->dm_width;
  }

  XCloseDisplay(tmp_dpy);

  if(dmp->dm_top){
    /* Make xtkwin a toplevel window */
    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin =
      Tk_CreateWindowFromPath(interp,
			      tkwin,
			      bu_vls_addr(&dmp->dm_pathName),
			      bu_vls_addr(&dmp->dm_dName));
    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->top = ((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin;
  }else{
     char *cp;

     cp = strrchr(bu_vls_addr(&dmp->dm_pathName), (int)'.');
     if(cp == bu_vls_addr(&dmp->dm_pathName)){
       ((struct dm_xvars *)dmp->dm_vars.pub_vars)->top = tkwin;
     }else{
       struct bu_vls top_vls;

       bu_vls_init(&top_vls);
       bu_vls_printf(&top_vls, "%*s", cp - bu_vls_addr(&dmp->dm_pathName),
		     bu_vls_addr(&dmp->dm_pathName));
       ((struct dm_xvars *)dmp->dm_vars.pub_vars)->top =
	 Tk_NameToWindow(interp, bu_vls_addr(&top_vls), tkwin);
       bu_vls_free(&top_vls);
     }

     /* Make xtkwin an embedded window */
     ((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin =
       Tk_CreateWindow(interp, ((struct dm_xvars *)dmp->dm_vars.pub_vars)->top,
		       cp + 1, (char *)NULL);
  }

  if( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin == NULL ) {
    bu_log("dm-Ogl: Failed to open %s\n", bu_vls_addr(&dmp->dm_pathName));
    bu_vls_free(&init_proc_vls);
    (void)ogl_close(dmp);
    return DM_NULL;
  }

  bu_vls_printf(&dmp->dm_tkName, "%s",
		(char *)Tk_Name(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin));

  bu_vls_init(&str);
  bu_vls_printf(&str, "_init_dm %S %S\n",
		&init_proc_vls,
		&dmp->dm_pathName);

  if(Tcl_Eval(interp, bu_vls_addr(&str)) == TCL_ERROR){
    bu_vls_free(&init_proc_vls);
    bu_vls_free(&str);
    (void)ogl_close(dmp);
    return DM_NULL;
  }

  bu_vls_free(&init_proc_vls);
  bu_vls_free(&str);

  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy =
    Tk_Display(((struct dm_xvars *)dmp->dm_vars.pub_vars)->top);

  Tk_GeometryRequest(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin,
		     dmp->dm_width,
		     dmp->dm_height);

  /* must do this before MakeExist */
  if((((struct dm_xvars *)dmp->dm_vars.pub_vars)->vip=ogl_choose_visual(dmp,
				    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin)) == NULL){
    bu_log("ogl_open: Can't get an appropriate visual.\n");
    (void)ogl_close(dmp);
    return DM_NULL;
  }

  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->depth = ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.depth;

  Tk_MakeWindowExist(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin);

  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win =
    Tk_WindowId(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin);
  dmp->dm_id = ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win;

  /* open GLX context */
  if ((((struct ogl_vars *)dmp->dm_vars.priv_vars)->glxc =
       glXCreateContext(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			((struct dm_xvars *)dmp->dm_vars.pub_vars)->vip,
			(GLXContext)NULL, GL_TRUE))==NULL) {
    bu_log("ogl_open: couldn't create glXContext.\n");
    (void)ogl_close(dmp);
    return DM_NULL;
  }

  /* If we used an indirect context, then as far as sgi is concerned,
   * gl hasn't been used.
   */
  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->is_direct =
    (char) glXIsDirect(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		       ((struct ogl_vars *)dmp->dm_vars.priv_vars)->glxc);

  /*
   * Take a look at the available input devices. We're looking
   * for "dial+buttons".
   */
  olist = list =
    (XDeviceInfoPtr)XListInputDevices(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
				      &ndevices);

  /* IRIX 4.0.5 bug workaround */
  if( list == (XDeviceInfoPtr)NULL ||
      list == (XDeviceInfoPtr)1 )  goto Done;

  for(j = 0; j < ndevices; ++j, list++){
    if(list->use == IsXExtensionDevice){
      if(!strcmp(list->name, "dial+buttons")){
	if((dev = XOpenDevice(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			      list->id)) == (XDevice *)NULL){
	  bu_log("ogl_open: Couldn't open the dials+buttons\n");
	  goto Done;
	}

	for(cip = dev->classes, k = 0; k < dev->num_classes;
	    ++k, ++cip){
	  switch(cip->input_class){
#if IR_BUTTONS
	  case ButtonClass:
	    DeviceButtonPress(dev, ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devbuttonpress,
			      e_class[nclass]);
	    ++nclass;
	    DeviceButtonRelease(dev, ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devbuttonrelease,
				e_class[nclass]);
	    ++nclass;
	    break;
#endif
#if IR_KNOBS
	  case ValuatorClass:
	    DeviceMotionNotify(dev, ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devmotionnotify,
			       e_class[nclass]);
	    ++nclass;
	    break;
#endif
	  default:
	    break;
	  }
	}

	XSelectExtensionEvent(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win, e_class, nclass);
	goto Done;
      }
    }
  }
Done:
  XFreeDeviceList(olist);

  if (!glXMakeCurrent(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win,
		      ((struct ogl_vars *)dmp->dm_vars.priv_vars)->glxc)){
    bu_log("ogl_open: Couldn't make context current\n");
    (void)ogl_close(dmp);
    return DM_NULL;
  }

  /* display list (fontOffset + char) will display a given ASCII char */
  if ((((struct ogl_vars *)dmp->dm_vars.priv_vars)->fontOffset = glGenLists(128))==0){
    bu_log("dm-ogl: Can't make display lists for font.\n");
    (void)ogl_close(dmp);
    return DM_NULL;
  }

  /* This is the applications display list offset */
  dmp->dm_displaylist = ((struct ogl_vars *)dmp->dm_vars.priv_vars)->fontOffset + 128;

  ogl_setBGColor(dmp, 0, 0, 0);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  if (((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.doublebuffer)
    glDrawBuffer(GL_BACK);
  else
    glDrawBuffer(GL_FRONT);

  /* do viewport, ortho commands and initialize font */
  (void)ogl_configureWin_guts(dmp, 1);

  /* Lines will be solid when stippling disabled, dashed when enabled*/
  glLineStipple( 1, 0xCF33);
  glDisable(GL_LINE_STIPPLE);

  backgnd[0] = backgnd[1] = backgnd[2] = backgnd[3] = 0.0;
  glFogi(GL_FOG_MODE, GL_LINEAR);
  glFogf(GL_FOG_START, 0.0);
  glFogf(GL_FOG_END, 2.0);
  glFogfv(GL_FOG_COLOR, backgnd);

  /*XXX Need to do something about VIEWFACTOR */
  glFogf(GL_FOG_DENSITY, VIEWFACTOR);

  /* Initialize matrices */
  /* Leave it in model_view mode normally */
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  glOrtho( -xlim_view, xlim_view, -ylim_view, ylim_view, 0.0, 2.0 );
  glGetDoublev(GL_PROJECTION_MATRIX, ((struct ogl_vars *)dmp->dm_vars.priv_vars)->faceplate_mat);
  glPushMatrix();
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity(); 
  glTranslatef(0.0, 0.0, -1.0); 
  glPushMatrix();
  glLoadIdentity();
  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->face_flag = 1;	/* faceplate matrix is on top of stack */

  Tk_MapWindow(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin);
  return dmp;
}

/*
 */
int
ogl_share_dlist(struct dm *dmp1, struct dm *dmp2)
{
  GLfloat backgnd[4];
  GLfloat vf;
  GLXContext old_glxContext;

  if (dmp1 == (struct dm *)NULL)
    return TCL_ERROR;

  if (dmp2 == (struct dm *)NULL) {
    /* create a new graphics context for dmp1 with private display lists */

    old_glxContext = ((struct ogl_vars *)dmp1->dm_vars.priv_vars)->glxc;

    if ((((struct ogl_vars *)dmp1->dm_vars.priv_vars)->glxc =
	 glXCreateContext(((struct dm_xvars *)dmp1->dm_vars.pub_vars)->dpy,
			  ((struct dm_xvars *)dmp1->dm_vars.pub_vars)->vip,
			  (GLXContext)NULL, GL_TRUE))==NULL) {
      bu_log("ogl_share_dlist: couldn't create glXContext.\nUsing old context\n.");
      ((struct ogl_vars *)dmp1->dm_vars.priv_vars)->glxc = old_glxContext;

      return TCL_ERROR;
    }

    if (!glXMakeCurrent(((struct dm_xvars *)dmp1->dm_vars.pub_vars)->dpy,
			((struct dm_xvars *)dmp1->dm_vars.pub_vars)->win,
			((struct ogl_vars *)dmp1->dm_vars.priv_vars)->glxc)){
      bu_log("ogl_share_dlist: Couldn't make context current\nUsing old context\n.");
      ((struct ogl_vars *)dmp1->dm_vars.priv_vars)->glxc = old_glxContext;

      return TCL_ERROR;
    }

    /* display list (fontOffset + char) will display a given ASCII char */
    if ((((struct ogl_vars *)dmp1->dm_vars.priv_vars)->fontOffset = glGenLists(128))==0){
      bu_log("dm-ogl: Can't make display lists for font.\nUsing old context\n.");
      ((struct ogl_vars *)dmp1->dm_vars.priv_vars)->glxc = old_glxContext;

      return TCL_ERROR;
    }

    /* This is the applications display list offset */
    dmp1->dm_displaylist = ((struct ogl_vars *)dmp1->dm_vars.priv_vars)->fontOffset + 128;

    ogl_setBGColor(dmp1, 0, 0, 0);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    if (((struct ogl_vars *)dmp1->dm_vars.priv_vars)->mvars.doublebuffer)
      glDrawBuffer(GL_BACK);
    else
      glDrawBuffer(GL_FRONT);

    /* this is important so that ogl_configureWin knows to set the font */
    ((struct dm_xvars *)dmp1->dm_vars.pub_vars)->fontstruct = NULL;

    /* do viewport, ortho commands and initialize font */
    (void)ogl_configureWin_guts(dmp1, 1);

    /* Lines will be solid when stippling disabled, dashed when enabled*/
    glLineStipple( 1, 0xCF33);
    glDisable(GL_LINE_STIPPLE);

    backgnd[0] = backgnd[1] = backgnd[2] = backgnd[3] = 0.0;
    glFogi(GL_FOG_MODE, GL_LINEAR);
    glFogf(GL_FOG_START, 0.0);
    glFogf(GL_FOG_END, 2.0);
    glFogfv(GL_FOG_COLOR, backgnd);

    /*XXX Need to do something about VIEWFACTOR */
    vf = 1.0/(*dmp1->dm_vp);
    glFogf(GL_FOG_DENSITY, vf);

    /* Initialize matrices */
    /* Leave it in model_view mode normally */
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho( -xlim_view, xlim_view, -ylim_view, ylim_view, 0.0, 2.0 );
    glGetDoublev(GL_PROJECTION_MATRIX, ((struct ogl_vars *)dmp1->dm_vars.priv_vars)->faceplate_mat);
    glPushMatrix();
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity(); 
    glTranslatef(0.0, 0.0, -1.0); 
    glPushMatrix();
    glLoadIdentity();
    ((struct ogl_vars *)dmp1->dm_vars.priv_vars)->face_flag = 1; /* faceplate matrix is on top of stack */

    /* destroy old context */
    glXMakeCurrent(((struct dm_xvars *)dmp1->dm_vars.pub_vars)->dpy, None, NULL);
    glXDestroyContext(((struct dm_xvars *)dmp1->dm_vars.pub_vars)->dpy, old_glxContext);
  } else {
    /* dmp1 will share it's display lists with dmp2 */

    old_glxContext = ((struct ogl_vars *)dmp2->dm_vars.priv_vars)->glxc;

    if ((((struct ogl_vars *)dmp2->dm_vars.priv_vars)->glxc =
	 glXCreateContext(((struct dm_xvars *)dmp2->dm_vars.pub_vars)->dpy,
			  ((struct dm_xvars *)dmp2->dm_vars.pub_vars)->vip,
			  ((struct ogl_vars *)dmp1->dm_vars.priv_vars)->glxc,
			  GL_TRUE))==NULL) {
      bu_log("ogl_share_dlist: couldn't create glXContext.\nUsing old context\n.");
      ((struct ogl_vars *)dmp2->dm_vars.priv_vars)->glxc = old_glxContext;

      return TCL_ERROR;
    }

    if (!glXMakeCurrent(((struct dm_xvars *)dmp2->dm_vars.pub_vars)->dpy,
			((struct dm_xvars *)dmp2->dm_vars.pub_vars)->win,
			((struct ogl_vars *)dmp2->dm_vars.priv_vars)->glxc)){
      bu_log("ogl_share_dlist: Couldn't make context current\nUsing old context\n.");
      ((struct ogl_vars *)dmp2->dm_vars.priv_vars)->glxc = old_glxContext;

      return TCL_ERROR;
    }

    ((struct ogl_vars *)dmp2->dm_vars.priv_vars)->fontOffset = ((struct ogl_vars *)dmp1->dm_vars.priv_vars)->fontOffset;
    dmp2->dm_displaylist = dmp1->dm_displaylist;

    ogl_setBGColor(dmp2, 0, 0, 0);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    if (((struct ogl_vars *)dmp2->dm_vars.priv_vars)->mvars.doublebuffer)
      glDrawBuffer(GL_BACK);
    else
      glDrawBuffer(GL_FRONT);

    /* do viewport, ortho commands and initialize font */
    (void)ogl_configureWin_guts(dmp2, 1);

    /* Lines will be solid when stippling disabled, dashed when enabled*/
    glLineStipple( 1, 0xCF33);
    glDisable(GL_LINE_STIPPLE);

    backgnd[0] = backgnd[1] = backgnd[2] = backgnd[3] = 0.0;
    glFogi(GL_FOG_MODE, GL_LINEAR);
    glFogf(GL_FOG_START, 0.0);
    glFogf(GL_FOG_END, 2.0);
    glFogfv(GL_FOG_COLOR, backgnd);

    /*XXX Need to do something about VIEWFACTOR */
    vf = 1.0/(*dmp2->dm_vp);
    glFogf(GL_FOG_DENSITY, vf);

    /* Initialize matrices */
    /* Leave it in model_view mode normally */
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho( -xlim_view, xlim_view, -ylim_view, ylim_view, 0.0, 2.0 );
    glGetDoublev(GL_PROJECTION_MATRIX, ((struct ogl_vars *)dmp2->dm_vars.priv_vars)->faceplate_mat);
    glPushMatrix();
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity(); 
    glTranslatef(0.0, 0.0, -1.0); 
    glPushMatrix();
    glLoadIdentity();
    ((struct ogl_vars *)dmp2->dm_vars.priv_vars)->face_flag = 1; /* faceplate matrix is on top of stack */

    /* destroy old context */
    glXMakeCurrent(((struct dm_xvars *)dmp2->dm_vars.pub_vars)->dpy, None, NULL);
    glXDestroyContext(((struct dm_xvars *)dmp2->dm_vars.pub_vars)->dpy, old_glxContext);
  }

  return TCL_OK;
}

/*
 *  			O G L _ C L O S E
 *  
 *  Gracefully release the display.
 */
HIDDEN int
ogl_close(struct dm *dmp)
{
  if(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy){
    if(((struct ogl_vars *)dmp->dm_vars.priv_vars)->glxc){
      glXMakeCurrent(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy, None, NULL);
      glXDestroyContext(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			((struct ogl_vars *)dmp->dm_vars.priv_vars)->glxc);
    }

    if(((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap)
      XFreeColormap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap);

    if(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin)
      Tk_DestroyWindow(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin);

#if 0
    XCloseDisplay(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy);
#endif
  }

  bu_vls_free(&dmp->dm_pathName);
  bu_vls_free(&dmp->dm_tkName);
  bu_vls_free(&dmp->dm_dName);
  bu_free(dmp->dm_vars.priv_vars, "ogl_close: ogl_vars");
  bu_free(dmp->dm_vars.pub_vars, "ogl_close: dm_xvars");
  bu_free(dmp, "ogl_close: dmp");

  return TCL_OK;
}

/*
 *			O G L _ D R A W B E G I N
 *
 * There are global variables which are parameters to this routine.
 */
HIDDEN int
ogl_drawBegin(struct dm *dmp)
{
  GLfloat fogdepth;

  if (dmp->dm_debugLevel) {
    bu_log("ogl_drawBegin\n");

    if (ogl_actively_drawing)
	    bu_log("ogl_drawBegin: already actively drawing\n");
  }

  ogl_actively_drawing = 1;

  if (!glXMakeCurrent(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win,
		      ((struct ogl_vars *)dmp->dm_vars.priv_vars)->glxc)){
    bu_log("ogl_drawBegin: Couldn't make context current\n");
    return TCL_ERROR;
  }

  /* clear back buffer */
  if (!dmp->dm_clearBufferAfter &&
      ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.doublebuffer) {
    glClearColor(((struct ogl_vars *)dmp->dm_vars.priv_vars)->r,
		 ((struct ogl_vars *)dmp->dm_vars.priv_vars)->g,
		 ((struct ogl_vars *)dmp->dm_vars.priv_vars)->b,
		 0.0);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  }

  if (((struct ogl_vars *)dmp->dm_vars.priv_vars)->face_flag){
    glMatrixMode(GL_PROJECTION);
    glPopMatrix();
    glMatrixMode(GL_MODELVIEW);
    glPopMatrix();
    ((struct ogl_vars *)dmp->dm_vars.priv_vars)->face_flag = 0;
    if (((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.cueing_on){
      glEnable(GL_FOG);
      /*XXX Need to do something with Viewscale */
      fogdepth = 2.2 * (*dmp->dm_vp); /* 2.2 is heuristic */
      glFogf(GL_FOG_END, fogdepth);
      fogdepth = (GLfloat) (0.5*((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.fogdensity/
			    (*dmp->dm_vp));
      glFogf(GL_FOG_DENSITY, fogdepth);
      glFogi(GL_FOG_MODE, dmp->dm_perspective ? GL_EXP : GL_LINEAR);
    }
    if (dmp->dm_light) {
      glEnable(GL_LIGHTING);
    }
  }

  return TCL_OK;
}

/*
 *			O G L _ D R A W E N D
 */
HIDDEN int
ogl_drawEnd(struct dm *dmp)
{
  if (dmp->dm_debugLevel)
    bu_log("ogl_drawEnd\n");


  if (dmp->dm_light) {
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glLightfv(GL_LIGHT0, GL_POSITION, light0_direction);
  }

  if (((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.doublebuffer){
    glXSwapBuffers(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		   ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win);

    if (dmp->dm_clearBufferAfter) {
      /* give Graphics pipe time to work */
      glClearColor(((struct ogl_vars *)dmp->dm_vars.priv_vars)->r,
		   ((struct ogl_vars *)dmp->dm_vars.priv_vars)->g,
		   ((struct ogl_vars *)dmp->dm_vars.priv_vars)->b,
		   0.0);
      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    }
  }

  if (dmp->dm_debugLevel) {
    int error;
    struct bu_vls tmp_vls;

    bu_vls_init(&tmp_vls);
    bu_vls_printf(&tmp_vls, "ANY ERRORS?\n");

    while((error = glGetError())!=0){
      bu_vls_printf(&tmp_vls, "Error: %x\n", error);
    }

    bu_log("%s", bu_vls_addr(&tmp_vls));
    bu_vls_free(&tmp_vls);
  }

/*XXX Keep this off unless testing */
#if 0
  glFinish();
#endif

  ogl_actively_drawing = 0;
  return TCL_OK;
}

/*
 *  			O G L _ L O A D M A T R I X
 *
 *  Load a new transformation matrix.  This will be followed by
 *  many calls to ogl_drawVList().
 */
HIDDEN int
ogl_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye)
{
  register fastf_t *mptr;
  GLfloat gtmat[16];
  mat_t	newm;
	
  if(dmp->dm_debugLevel){
    struct bu_vls tmp_vls;

    bu_log("ogl_loadMatrix()\n");

    bu_vls_init(&tmp_vls);
    bu_vls_printf(&tmp_vls, "which eye = %d\t", which_eye);
    bu_vls_printf(&tmp_vls, "transformation matrix = \n");
    bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[0], mat[4], mat[8],mat[12]);
    bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[1], mat[5], mat[9],mat[13]);
    bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[2], mat[6], mat[10],mat[14]);
    bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[3], mat[7], mat[11],mat[15]);

    bu_log("%s", bu_vls_addr(&tmp_vls));
    bu_vls_free(&tmp_vls);
  }

  switch(which_eye)  {
  case 0:
    /* Non-stereo */
    break;
  case 1:
    /* R eye */
    glViewport(0,  0, (XMAXSCREEN)+1, ( YSTEREO)+1); 
    glScissor(0,  0, (XMAXSCREEN)+1, (YSTEREO)+1);
    ogl_drawString2D( dmp, "R", 0.986, 0.0, 0, 1 );
    break;
  case 2:
    /* L eye */
    glViewport(0,  0+YOFFSET_LEFT, ( XMAXSCREEN)+1,
	       ( YSTEREO+YOFFSET_LEFT)-( YOFFSET_LEFT)+1); 
    glScissor(0,  0+YOFFSET_LEFT, ( XMAXSCREEN)+1,
	      ( YSTEREO+YOFFSET_LEFT)-( YOFFSET_LEFT)+1);
    break;
  }

  if (!dmp->dm_zclip) {
    mat_t       nozclip;

    MAT_IDN( nozclip );
    nozclip[10] = 1.0e-20;
    bn_mat_mul( newm, nozclip, mat );
    mptr = newm;
  } else {
    mat_t       nozclip;

    MAT_IDN(nozclip);
    nozclip[10] = dmp->dm_bound;
    bn_mat_mul(newm, nozclip, mat);
    mptr = newm;
  }

  gtmat[0] = *(mptr++);
  gtmat[4] = *(mptr++);
  gtmat[8] = *(mptr++);
  gtmat[12] = *(mptr++);

  gtmat[1] = *(mptr++) * dmp->dm_aspect;
  gtmat[5] = *(mptr++) * dmp->dm_aspect;
  gtmat[9] = *(mptr++) * dmp->dm_aspect;
  gtmat[13] = *(mptr++) * dmp->dm_aspect;

  gtmat[2] = *(mptr++);
  gtmat[6] = *(mptr++);
  gtmat[10] = *(mptr++);
  gtmat[14] = *(mptr++);

  gtmat[3] = *(mptr++);
  gtmat[7] = *(mptr++);
  gtmat[11] = *(mptr++);
  gtmat[15] = *(mptr++);

  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  glTranslatef( 0.0, 0.0, -1.0 );
  glMultMatrixf( gtmat );

  return TCL_OK;
}

/*
 *  			O G L _ D R A W V L I S T
 *  
 */
HIDDEN int
ogl_drawVList(struct dm *dmp, register struct bn_vlist *vp)
{
	register struct rt_vlist	*tvp;
	int				first;
#if USE_VECTOR_THRESHHOLD
	static int			nvectors = 0;
#endif
	int mflag = 1;
	float black[4] = {0.0, 0.0, 0.0, 0.0};

	if (dmp->dm_debugLevel)
		bu_log("ogl_drawVList()\n");

	/* Viewing region is from -1.0 to +1.0 */
	first = 1;
	for (BU_LIST_FOR(tvp, rt_vlist, &vp->l)) {
		register int	i;
		register int	nused = tvp->nused;
		register int	*cmd = tvp->cmd;
		register point_t *pt = tvp->pt;
		for (i = 0; i < nused; i++,cmd++,pt++) {
			if (dmp->dm_debugLevel > 2)
				bu_log(" %d (%g %g %g)\n", *cmd, V3ARGS(pt));
			switch (*cmd) {
			case RT_VLIST_LINE_MOVE:
				/* Move, start line */
				if (first == 0)
					glEnd();
				first = 0;

				if (dmp->dm_light && mflag) {
				    mflag = 0;
				    glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, wireColor);
				    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, black);
				    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, black);
				    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, black);

				    if (dmp->dm_transparency)
					glDisable(GL_BLEND);
				}

				glBegin(GL_LINE_STRIP);
				glVertex3dv(*pt);
				break;
			case RT_VLIST_POLY_START:
				/* Start poly marker & normal */
				if (first == 0)
					glEnd();

				if (dmp->dm_light && mflag) {
				    mflag = 0;
				    glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, black);
				    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, ambientColor);
				    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, specularColor);
				    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffuseColor);

				    if (dmp->dm_transparency)
					glEnable(GL_BLEND);
				}

				glBegin(GL_POLYGON);
				/* Set surface normal (vl_pnt points outward) */
				glNormal3dv(*pt);
				break;
			case RT_VLIST_LINE_DRAW:
			case RT_VLIST_POLY_MOVE:
			case RT_VLIST_POLY_DRAW:
				glVertex3dv(*pt);
				break;
			case RT_VLIST_POLY_END:
				/* Draw, End Polygon */
				glVertex3dv(*pt);
				glEnd();
				first = 1;
				break;
			case RT_VLIST_POLY_VERTNORM:
				/* Set per-vertex normal.  Given before vert. */
				glNormal3dv(*pt);
				break;
			}
		}

#if USE_VECTOR_THRESHHOLD
/*XXX The Tcl_DoOneEvent below causes the following error:
X Error of failed request:  GLXBadContextState
*/

		nvectors += nused;

		if (nvectors >= vectorThreshold) {
			if (dmp->dm_debugLevel)
				bu_log("ogl_drawVList(): handle Tcl events\n");

			nvectors = 0;

			/* Handle events in the queue */
			while (Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT));

			if (dmp->dm_debugLevel)
				bu_log("ogl_drawVList(): handled Tcl events successfully\n");
		}
#endif
	}

	if (first == 0)
		glEnd();

	return TCL_OK;
}

/*
 *			O G L _ N O R M A L
 *
 * Restore the display processor to a normal mode of operation
 * (ie, not scaled, rotated, displaced, etc).
 */
HIDDEN int
ogl_normal(struct dm *dmp)
{

  if (dmp->dm_debugLevel)
    bu_log("ogl_normal\n");

  if (!((struct ogl_vars *)dmp->dm_vars.priv_vars)->face_flag){
    glMatrixMode(GL_PROJECTION);
    glPushMatrix();
    glLoadMatrixd( ((struct ogl_vars *)dmp->dm_vars.priv_vars)->faceplate_mat );
    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();
    glLoadIdentity();
    ((struct ogl_vars *)dmp->dm_vars.priv_vars)->face_flag = 1;
    if(((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.cueing_on)
      glDisable(GL_FOG);
    if (dmp->dm_light)
      glDisable(GL_LIGHTING);
  }

  return TCL_OK;
}

/*
 *			O G L _ D R A W S T R I N G 2 D
 *
 * Output a string.
 * The starting position of the beam is as specified.
 */
HIDDEN int
ogl_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect)
{
  if (dmp->dm_debugLevel)
    bu_log("ogl_drawString2D()\n");

  if(use_aspect)
    glRasterPos2f(x, y * dmp->dm_aspect);
  else
    glRasterPos2f(x, y);

  glListBase(((struct ogl_vars *)dmp->dm_vars.priv_vars)->fontOffset);
  glCallLists(strlen( str ), GL_UNSIGNED_BYTE,  str );

  return TCL_OK;
}


/*
 *			O G L _ D R A W L I N E 2 D
 *
 */
HIDDEN int
ogl_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2)
{
  
  if (dmp->dm_debugLevel)
    bu_log("ogl_drawLine2D()\n");

  if(dmp->dm_debugLevel){
    GLfloat pmat[16];

    glGetFloatv(GL_PROJECTION_MATRIX, pmat);
    bu_log("projection matrix:\n");
    bu_log("%g %g %g %g\n", pmat[0], pmat[4], pmat[8],pmat[12]);
    bu_log("%g %g %g %g\n", pmat[1], pmat[5], pmat[9],pmat[13]);
    bu_log("%g %g %g %g\n", pmat[2], pmat[6], pmat[10],pmat[14]);
    bu_log("%g %g %g %g\n", pmat[3], pmat[7], pmat[11],pmat[15]);
    glGetFloatv(GL_MODELVIEW_MATRIX, pmat);
    bu_log("modelview matrix:\n");
    bu_log("%g %g %g %g\n", pmat[0], pmat[4], pmat[8],pmat[12]);
    bu_log("%g %g %g %g\n", pmat[1], pmat[5], pmat[9],pmat[13]);
    bu_log("%g %g %g %g\n", pmat[2], pmat[6], pmat[10],pmat[14]);
    bu_log("%g %g %g %g\n", pmat[3], pmat[7], pmat[11],pmat[15]);
  }

  glBegin(GL_LINES); 
  glVertex2f(x1, y1);
  glVertex2f(x2, y2);
  glEnd();

  return TCL_OK;
}

HIDDEN int
ogl_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y)
{
  if (dmp->dm_debugLevel){
    bu_log("ogl_drawPoint2D():\n");
    bu_log("\tdmp: %ul\tx - %lf\ty - %lf\n", (unsigned long)dmp, x, y);
  }

  glBegin(GL_POINTS);
  glVertex2f(x, y);
  glEnd();

  return TCL_OK;
}


HIDDEN int
ogl_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict, fastf_t transparency)
{
  if (dmp->dm_debugLevel)
    bu_log("ogl_setFGColor()\n");

  dmp->dm_fg[0] = r;
  dmp->dm_fg[1] = g;
  dmp->dm_fg[2] = b;

  if(strict){
    glColor3ub( (GLubyte)r, (GLubyte)g, (GLubyte)b );
  }else{
  
    if (dmp->dm_light) {
      /* Ambient = .2, Diffuse = .6, Specular = .2 */

      /* wireColor gets the full rgb */
      wireColor[0] = r / 255.0;
      wireColor[1] = g / 255.0;
      wireColor[2] = b / 255.0;
      wireColor[3] = transparency;

      ambientColor[0] = wireColor[0] * 0.2;
      ambientColor[1] = wireColor[1] * 0.2;
      ambientColor[2] = wireColor[2] * 0.2;
      ambientColor[3] = wireColor[3];

      specularColor[0] = ambientColor[0];
      specularColor[1] = ambientColor[1];
      specularColor[2] = ambientColor[2];
      specularColor[3] = ambientColor[3];

      diffuseColor[0] = wireColor[0] * 0.6;
      diffuseColor[1] = wireColor[1] * 0.6;
      diffuseColor[2] = wireColor[2] * 0.6;
      diffuseColor[3] = wireColor[3];

#if 1
      glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, ambientColor);
      glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, specularColor);
      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffuseColor);
#endif

    }else{
      glColor3ub( (GLubyte)r,  (GLubyte)g,  (GLubyte)b );
    }
  }

  return TCL_OK;
}

HIDDEN int
ogl_setBGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b)
{
  if (dmp->dm_debugLevel)
    bu_log("ogl_setBGColor()\n");

  dmp->dm_bg[0] = r;
  dmp->dm_bg[1] = g;
  dmp->dm_bg[2] = b;

  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->r = r / 255.0;
  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->g = g / 255.0;
  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->b = b / 255.0;

  if(((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.doublebuffer){
    if (!glXMakeCurrent(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			((struct dm_xvars *)dmp->dm_vars.pub_vars)->win,
			((struct ogl_vars *)dmp->dm_vars.priv_vars)->glxc)){
      bu_log("ogl_setBGColor: Couldn't make context current\n");
      return TCL_ERROR;
    }

    glXSwapBuffers(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		   ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win);
    glClearColor(((struct ogl_vars *)dmp->dm_vars.priv_vars)->r,
		 ((struct ogl_vars *)dmp->dm_vars.priv_vars)->g,
		 ((struct ogl_vars *)dmp->dm_vars.priv_vars)->b,
		 0.0);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  }

  return TCL_OK;
}

HIDDEN int
ogl_setLineAttr(struct dm *dmp, int width, int style)
{
  if (dmp->dm_debugLevel)
    bu_log("ogl_setLineAttr()\n");

  dmp->dm_lineWidth = width;
  dmp->dm_lineStyle = style;

  glLineWidth((GLfloat) width);

  if(style == DM_DASHED_LINE)
    glEnable(GL_LINE_STIPPLE);
  else
    glDisable(GL_LINE_STIPPLE);
		
  return TCL_OK;
}

/* ARGSUSED */
HIDDEN int
ogl_debug(struct dm *dmp, int lvl)
{
  dmp->dm_debugLevel = lvl;

  return TCL_OK;
}

HIDDEN int
ogl_setWinBounds(struct dm *dmp, int *w)
{
  if (dmp->dm_debugLevel)
    bu_log("ogl_setWinBounds()\n");

  dmp->dm_clipmin[0] = w[0];
  dmp->dm_clipmin[1] = w[2];
  dmp->dm_clipmin[2] = w[4];
  dmp->dm_clipmax[0] = w[1];
  dmp->dm_clipmax[1] = w[3];
  dmp->dm_clipmax[2] = w[5];

  if (dmp->dm_clipmax[2] <= GED_MAX)
      dmp->dm_bound = 1.0;
  else
      dmp->dm_bound = GED_MAX / dmp->dm_clipmax[2];

  return TCL_OK;
}

#define OGL_DO_STEREO 1
/* currently, get a double buffered rgba visual that works with Tk and
 * OpenGL
 */
HIDDEN XVisualInfo *
ogl_choose_visual(struct dm *dmp, Tk_Window tkwin)
{
  XVisualInfo *vip, vitemp, *vibase, *maxvip;
#define NGOOD 256
  int good[NGOOD];
  int tries, baddepth;
  int num, i, j;
  int fail;

  /* requirements */
  int use;
  int rgba;
  int dbfr;

  /* desires */
  int m_zbuffer = 1; /* m_zbuffer - try to get zbuffer */
  int zbuffer;
#if OGL_DO_STEREO
  int m_stereo; /* m_stereo - try to get stereo */
  int stereo;

  /*XXX Need to do something with this */
  if( dmp->dm_stereo )  {
    m_stereo = 1;
  } else {
    m_stereo = 0;
  }
#endif

  bzero((void *)&vitemp, sizeof(XVisualInfo));
  /* Try to satisfy the above desires with a color visual of the
   * greatest depth */

  vibase = XGetVisualInfo(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			  0, &vitemp, &num);

  while (1) {
    for (i=0, j=0, vip=vibase; i<num; i++, vip++){
      /* requirements */
      fail = glXGetConfig(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		   vip, GLX_USE_GL, &use);
      if (fail || !use)
	continue;

      fail = glXGetConfig(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		     vip, GLX_RGBA, &rgba);
      if (fail || !rgba)
	continue;

      fail = glXGetConfig(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		     vip, GLX_DOUBLEBUFFER,&dbfr);
      if (fail || !dbfr)
	continue;

      /* desires */
      if ( m_zbuffer ) {
	fail = glXGetConfig(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			    vip, GLX_DEPTH_SIZE,&zbuffer);
	if (fail || !zbuffer)
	  continue;
      }

#if OGL_DO_STEREO
      if ( m_stereo ) {
	fail = glXGetConfig(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		     vip, GLX_STEREO, &stereo);
	if (fail || !stereo){
	  bu_log("ogl_choose_visual: failed visual - GLX_STEREO\n");
	  continue;
	}
      }
#endif

      /* this visual meets criteria */
      if(j >= NGOOD){
	bu_log("ogl_choose_visual: More than %d candidate visuals!\n", NGOOD);
	break;
      }
      good[j++] = i;
    }

    /* j = number of acceptable visuals under consideration */
    if (j >= 1){
      baddepth = 1000;
      for(tries = 0; tries < j; ++tries) {
	maxvip = vibase + good[0];
	for (i=1; i<j; i++) {
	  vip = vibase + good[i];
	  if ((vip->depth > maxvip->depth)&&(vip->depth < baddepth)){
	    maxvip = vip;
	  }
	}

	((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap =
	  XCreateColormap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			  RootWindow(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
				     maxvip->screen), maxvip->visual, AllocNone);

	if (Tk_SetWindowVisual(tkwin,
			       maxvip->visual, maxvip->depth,
			       ((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap)){

	  glXGetConfig(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		       maxvip, GLX_DEPTH_SIZE,
		       &((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.depth);
	  if (((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.depth > 0)
	    ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.zbuf = 1;

	  return (maxvip); /* success */
	} else { 
	  /* retry with lesser depth */
	  baddepth = maxvip->depth;
	  XFreeColormap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap);
	}
      }
    }

    /* if no success at this point, relax a desire and try again */

#if OGL_DO_STEREO
    if ( m_stereo ) {
      m_stereo = 0;
      bu_log("Stereo not available.\n");
      continue;
    }
#endif

    if ( m_zbuffer ) {
      m_zbuffer = 0;
      continue;
    }

    return (XVisualInfo *)NULL; /* failure */
  }
}


/* 
 *			O G L _ C O N F I G U R E W I N
 *
 *  Either initially, or on resize/reshape of the window,
 *  sense the actual size of the window, and perform any
 *  other initializations of the window configuration.
 *
 * also change font size if necessary
 */
HIDDEN int
ogl_configureWin_guts(struct dm *dmp, int force)
{
  GLint mm; 
  XWindowAttributes xwa;
  XFontStruct	*newfontstruct;

  if (dmp->dm_debugLevel)
    bu_log("ogl_configureWin_guts()\n");

  if (!glXMakeCurrent(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win,
		      ((struct ogl_vars *)dmp->dm_vars.priv_vars)->glxc)){
    bu_log("ogl_configureWin_guts: Couldn't make context current\n");
    return TCL_ERROR;
  }

  XGetWindowAttributes( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			((struct dm_xvars *)dmp->dm_vars.pub_vars)->win, &xwa );

  /* nothing to do */
  if (!force &&
      dmp->dm_height == xwa.height &&
      dmp->dm_width == xwa.width)
    return TCL_OK;
    
  dmp->dm_height = xwa.height;
  dmp->dm_width = xwa.width;
  dmp->dm_aspect = (fastf_t)dmp->dm_width / (fastf_t)dmp->dm_height;

  if (dmp->dm_debugLevel) {
    bu_log("ogl_configureWin_guts()\n");
    bu_log("width = %d, height = %d\n", dmp->dm_width, dmp->dm_height);
  }

  glViewport(0, 0, dmp->dm_width, dmp->dm_height);
#if 0
  glScissor(0,  0, (dmp->dm_width)+1,
	    (dmp->dm_height)+1);
#endif

  if(dmp->dm_zbuffer)
    ogl_setZBuffer(dmp, dmp->dm_zbuffer);

  ogl_setLight(dmp, dmp->dm_light);

  glClearColor(((struct ogl_vars *)dmp->dm_vars.priv_vars)->r,
	       ((struct ogl_vars *)dmp->dm_vars.priv_vars)->g,
	       ((struct ogl_vars *)dmp->dm_vars.priv_vars)->b,
	       0.0);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  /*CJXX this might cause problems in perspective mode? */
  glGetIntegerv(GL_MATRIX_MODE, &mm);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  glOrtho( -xlim_view, xlim_view, -ylim_view, ylim_view, 0.0, 2.0 );
  glMatrixMode(mm);

  /* First time through, load a font or quit */
  if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct == NULL) {
    if ((((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct =
	 XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			FONT9)) == NULL ) {
      /* Try hardcoded backup font */
      if ((((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct =
	   XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			  FONTBACK)) == NULL) {
	bu_log("ogl_configureWin_guts: Can't open font '%s' or '%s'\n", FONT9, FONTBACK);
	return TCL_ERROR;
      }
    }
    glXUseXFont( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->fid,
		 0, 127, ((struct ogl_vars *)dmp->dm_vars.priv_vars)->fontOffset);
  }
		

  /* Always try to choose a the font that best fits the window size.
   */

  if (dmp->dm_width < 582) {
    if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->per_char->width != 5) {
      if ((newfontstruct = XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
					  FONT5)) != NULL ) {
	XFreeFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct);
	((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct = newfontstruct;
	glXUseXFont( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->fid,
		     0, 127, ((struct ogl_vars *)dmp->dm_vars.priv_vars)->fontOffset);
      }
    }
  } else if (dmp->dm_width < 679) {
    if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->per_char->width != 6){
      if ((newfontstruct = XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
					  FONT6)) != NULL ) {
	XFreeFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct);
	((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct = newfontstruct;
	glXUseXFont( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->fid,
		     0, 127, ((struct ogl_vars *)dmp->dm_vars.priv_vars)->fontOffset);
      }
    }
  } else if (dmp->dm_width < 776) {
    if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->per_char->width != 7){
      if ((newfontstruct = XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
					  FONT7)) != NULL ) {
	XFreeFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct);
	((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct = newfontstruct;
	glXUseXFont( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->fid,
		     0, 127, ((struct ogl_vars *)dmp->dm_vars.priv_vars)->fontOffset);
      }
    }
  } else if (dmp->dm_width < 873) {
    if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->per_char->width != 8){
      if ((newfontstruct = XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
					  FONT8)) != NULL ) {
	XFreeFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct);
	((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct = newfontstruct;
	glXUseXFont( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->fid,
		     0, 127, ((struct ogl_vars *)dmp->dm_vars.priv_vars)->fontOffset);
      }
    }
  } else {
    if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->per_char->width != 9){
      if ((newfontstruct = XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
					  FONT9)) != NULL ) {
	XFreeFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct);
	((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct = newfontstruct;
	glXUseXFont( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->fid,
		     0, 127, ((struct ogl_vars *)dmp->dm_vars.priv_vars)->fontOffset);
      }
    }
  }

  return TCL_OK;
}

HIDDEN int
ogl_configureWin(struct dm *dmp)
{
  return ogl_configureWin_guts(dmp, 0);
}

HIDDEN int
ogl_setLight(struct dm *dmp, int lighting_on)
{
  if (dmp->dm_debugLevel)
    bu_log("ogl_setLight()\n");

  dmp->dm_light = lighting_on;
  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.lighting_on = dmp->dm_light;

  if (!glXMakeCurrent(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win,
		      ((struct ogl_vars *)dmp->dm_vars.priv_vars)->glxc)){
    bu_log("ogl_setLight: Couldn't make context current\n");
    return TCL_ERROR;
  }

  if (!dmp->dm_light) {
    /* Turn it off */
    glDisable(GL_LIGHTING);
  } else {
    /* Turn it on */

    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, amb_three);
    glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_FALSE);

    glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, light0_diffuse);
    glLightfv(GL_LIGHT0, GL_SPECULAR, light0_diffuse);

    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
  }

  return TCL_OK;
}	

HIDDEN int
ogl_setTransparency(struct dm *dmp,
		    int transparency_on)
{
  if (dmp->dm_debugLevel)
    bu_log("ogl_setTransparency()\n");

  dmp->dm_transparency = transparency_on;
  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.transparency_on = dmp->dm_transparency;

  if (!glXMakeCurrent(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win,
		      ((struct ogl_vars *)dmp->dm_vars.priv_vars)->glxc)){
    bu_log("ogl_setTransparency: Couldn't make context current\n");
    return TCL_ERROR;
  }

  if (transparency_on) {
    /* Turn it on */
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  } else {
    /* Turn it off */
    glDisable(GL_BLEND);
  }

  return TCL_OK;
}	

HIDDEN int
ogl_setDepthMask(struct dm *dmp,
		 int enable) {
  if (dmp->dm_debugLevel)
    bu_log("ogl_setDepthMask()\n");

  dmp->dm_depthMask = enable;

  if (!glXMakeCurrent(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win,
		      ((struct ogl_vars *)dmp->dm_vars.priv_vars)->glxc)){
    bu_log("ogl_setDepthMask: Couldn't make context current\n");
    return TCL_ERROR;
  }

  if (enable)
    glDepthMask(GL_TRUE);
  else
    glDepthMask(GL_FALSE);

  return TCL_OK;
}

HIDDEN int
ogl_setZBuffer(struct dm *dmp, int zbuffer_on)
{
  if (dmp->dm_debugLevel)
    bu_log("ogl_setZBuffer:\n");

  dmp->dm_zbuffer = zbuffer_on;
  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.zbuffer_on = dmp->dm_zbuffer;

  if (!glXMakeCurrent(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win,
		      ((struct ogl_vars *)dmp->dm_vars.priv_vars)->glxc)){
    bu_log("ogl_setZBuffer: Couldn't make context current\n");
    return TCL_ERROR;
  }

  if (((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.zbuf == 0) {
    dmp->dm_zbuffer = 0;
    ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.zbuffer_on = dmp->dm_zbuffer;
  }

  if (((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.zbuffer_on) {
    glDepthFunc(GL_LEQUAL);
    glEnable(GL_DEPTH_TEST);
  } else {
    glDisable(GL_DEPTH_TEST);
  }

  return TCL_OK;
}

int
ogl_beginDList(struct dm *dmp, unsigned int list)
{
  if (dmp->dm_debugLevel)
    bu_log("ogl_beginDList()\n");

  if (!glXMakeCurrent(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win,
		      ((struct ogl_vars *)dmp->dm_vars.priv_vars)->glxc)){
    bu_log("ogl_beginDList: Couldn't make context current\n");
    return TCL_ERROR;
  }

  glNewList(dmp->dm_displaylist + list, GL_COMPILE);
  return TCL_OK;
}

int
ogl_endDList(struct dm *dmp)
{
  if (dmp->dm_debugLevel)
    bu_log("ogl_endDList()\n");

  glEndList();
  return TCL_OK;
}

int
ogl_drawDList(struct dm *dmp, unsigned int list)
{
  if (dmp->dm_debugLevel)
    bu_log("ogl_drawDList()\n");

  glCallList(dmp->dm_displaylist + list);
  return TCL_OK;
}

int
ogl_freeDLists(struct dm *dmp, unsigned int list, int range)
{
  if (dmp->dm_debugLevel)
    bu_log("ogl_freeDLists()\n");

  if (!glXMakeCurrent(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win,
		      ((struct ogl_vars *)dmp->dm_vars.priv_vars)->glxc)){
    bu_log("ogl_freeDLists: Couldn't make context current\n");
    return TCL_ERROR;
  }

  glDeleteLists(dmp->dm_displaylist + list, (GLsizei)range);
  return TCL_OK;
}
@


1.64
log
@change conf.h to a wrapped config.h
@
text
@@


1.63
log
@Bob Parker's view modifications, png framebuffer support, shaded drawing mode
@
text
@d21 5
a25 1
#include "conf.h"
@


1.62
log
@make the USE_SURVICE_MODS not compile-time-optional.  so that means the #if sections go bye bye.
@
text
@d86 2
a87 1
HIDDEN int	ogl_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect), ogl_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2);
d90 2
a91 1
HIDDEN int      ogl_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict), ogl_setBGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b);
d96 2
d120 2
d131 1
a131 1
  IRBOUND,			/* zoom-in limit */
d149 2
a150 2
  {0.0, 0.0, 0.0},		/* clipmin */
  {0.0, 0.0, 0.0},		/* clipmax */
d154 1
d157 1
d172 4
d759 10
d809 1
a809 1
  if(((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.doublebuffer ){
d812 9
a820 6
    /* give Graphics pipe time to work */
    glClearColor(((struct ogl_vars *)dmp->dm_vars.priv_vars)->r,
		 ((struct ogl_vars *)dmp->dm_vars.priv_vars)->g,
		 ((struct ogl_vars *)dmp->dm_vars.priv_vars)->b,
		 0.0);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
d823 1
a823 1
  if(dmp->dm_debugLevel){
d904 6
a909 1
    mptr = mat;
d952 2
d974 12
d993 12
d1162 1
a1162 1
ogl_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict)
a1173 1
    float material[4];
d1178 26
a1203 11
      material[0] = ( r / 255.0) * .2;
      material[1] = ( g / 255.0) * .2;
      material[2] = ( b / 255.0) * .2;
      material[3] = 1.0;

      glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, material);
      glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, material);

      material[0] *= 3.0;
      material[1] *= 3.0;
      material[2] *= 3.0;
a1204 1
      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, material);
d1278 15
d1598 1
a1598 1
    bu_log("ogl_lighting()\n");
d1629 52
@


1.61
log
@merge of ansi-6-0-branch into HEAD
@
text
@d160 1
a160 1
#if USE_SURVICE_MODS
d162 1
a163 11
#else
HIDDEN float light0_position[] = {100.0, 200.0, 100.0, 0.0};
HIDDEN float light1_position[] = {100.0, 30.0, 100.0, 0.0};
HIDDEN float light2_position[] = {-100.0, 20.0, 20.0, 0.0};
HIDDEN float light3_position[] = {0.0, -100.0, -100.0, 0.0};

HIDDEN float light0_diffuse[] = {0.70, 0.70, 0.70, 1.0}; /* white */
HIDDEN float light1_diffuse[] = {0.60, 0.10, 0.10, 1.0}; /* red */
HIDDEN float light2_diffuse[] = {0.10, 0.30, 0.10, 1.0}; /* green */
HIDDEN float light3_diffuse[] = {0.10, 0.10, 0.30, 1.0}; /* blue */
#endif
a780 1
#if USE_SURVICE_MODS
a785 1
#endif
a906 10
#if !USE_SURVICE_MODS
  /* Make sure that new matrix is applied to the lights */
  if (dmp->dm_light) {
    glLightfv(GL_LIGHT0, GL_POSITION, light0_position);
    glLightfv(GL_LIGHT1, GL_POSITION, light1_position);
    glLightfv(GL_LIGHT2, GL_POSITION, light2_position);
    glLightfv(GL_LIGHT3, GL_POSITION, light3_position);
  }
#endif

a1127 1
#if USE_SURVICE_MODS
a1129 4
#else
      glMaterialfv(GL_FRONT, GL_AMBIENT, material);
      glMaterialfv(GL_FRONT, GL_SPECULAR, material);
#endif
a1134 1
#if USE_SURVICE_MODS
a1135 3
#else
      glMaterialfv(GL_FRONT, GL_DIFFUSE, material);
#endif
a1534 1
#if USE_SURVICE_MODS
a1540 17
#else
    /* light positions specified in ogl_newrot */
    glLightfv(GL_LIGHT0, GL_SPECULAR, light0_diffuse);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, light0_diffuse);
    glLightfv(GL_LIGHT1, GL_SPECULAR, light1_diffuse);
    glLightfv(GL_LIGHT1, GL_DIFFUSE, light1_diffuse);
    glLightfv(GL_LIGHT2, GL_SPECULAR, light2_diffuse);
    glLightfv(GL_LIGHT2, GL_DIFFUSE, light2_diffuse);
    glLightfv(GL_LIGHT3, GL_SPECULAR, light3_diffuse);
    glLightfv(GL_LIGHT3, GL_DIFFUSE, light3_diffuse);

    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glEnable(GL_LIGHT1);
    glEnable(GL_LIGHT2);
    glEnable(GL_LIGHT3);
#endif
@


1.60
log
@update copyright to include span through 2003
@
text
@d75 1
a75 1
HIDDEN XVisualInfo *ogl_choose_visual();
d81 18
a98 18
struct dm	*ogl_open();
HIDDEN int	ogl_close();
HIDDEN int	ogl_drawBegin();
HIDDEN int      ogl_drawEnd();
HIDDEN int	ogl_normal(), ogl_loadMatrix();
HIDDEN int	ogl_drawString2D(), ogl_drawLine2D();
HIDDEN int      ogl_drawPoint2D();
HIDDEN int	ogl_drawVList();
HIDDEN int      ogl_setFGColor(), ogl_setBGColor();
HIDDEN int	ogl_setLineAttr();
HIDDEN int	ogl_configureWin_guts();
HIDDEN int	ogl_configureWin();
HIDDEN int	ogl_setLight();
HIDDEN int	ogl_setZBuffer();
HIDDEN int	ogl_setWinBounds(), ogl_debug();
HIDDEN int      ogl_beginDList(), ogl_endDList();
HIDDEN int      ogl_drawDList();
HIDDEN int      ogl_freeDLists();
d176 1
a176 3
ogl_fogHint(dmp, fastfog)
struct dm *dmp;
int fastfog;
d189 1
a189 4
ogl_open(interp, argc, argv)
     Tcl_Interp *interp;
     int argc;
     char *argv[];
d530 1
a530 3
ogl_share_dlist(dmp1, dmp2)
struct dm *dmp1;
struct dm *dmp2;
d700 1
a700 2
ogl_close(dmp)
struct dm *dmp;
d737 1
a737 2
ogl_drawBegin(dmp)
struct dm *dmp;
d785 1
a785 2
ogl_drawEnd(dmp)
struct dm *dmp;
d841 1
a841 4
ogl_loadMatrix(dmp, mat, which_eye)
struct dm *dmp;
mat_t mat;
int which_eye;
d937 1
a937 3
ogl_drawVList(dmp, vp)
     struct dm			*dmp;
     register struct rt_vlist	*vp;
d1028 1
a1028 2
ogl_normal(dmp)
struct dm *dmp;
d1058 1
a1058 6
ogl_drawString2D( dmp, str, x, y, size, use_aspect )
struct dm *dmp;
register char *str;
fastf_t x, y;
int size;
int use_aspect;
d1080 1
a1080 4
ogl_drawLine2D( dmp, x1, y1, x2, y2)
struct dm *dmp;
fastf_t x1, y1;
fastf_t x2, y2;
d1112 1
a1112 3
ogl_drawPoint2D(dmp, x, y)
struct dm *dmp;
fastf_t x, y;
d1128 1
a1128 4
ogl_setFGColor(dmp, r, g, b, strict)
struct dm *dmp;
unsigned char r, g, b;
int strict;
d1176 1
a1176 3
ogl_setBGColor(dmp, r, g, b)
struct dm *dmp;
unsigned char r, g, b;
d1210 1
a1210 4
ogl_setLineAttr(dmp, width, style)
struct dm *dmp;
int width;
int style;
d1230 1
a1230 3
ogl_debug(dmp, lvl)
struct dm *dmp;
int lvl;
d1238 1
a1238 3
ogl_setWinBounds(dmp, w)
struct dm *dmp;
int w[6];
d1248 1
a1248 3
ogl_choose_visual(dmp, tkwin)
struct dm *dmp;
Tk_Window tkwin;
d1396 1
a1396 3
ogl_configureWin_guts(dmp, force)
struct dm *dmp;
int force;
d1536 1
a1536 2
ogl_configureWin(dmp)
struct dm *dmp;
d1542 1
a1542 3
ogl_setLight(dmp, lighting_on)
struct dm *dmp;
int lighting_on;
d1596 1
a1596 3
ogl_setZBuffer(dmp, zbuffer_on)
struct dm *dmp;
int zbuffer_on;
d1627 1
a1627 3
ogl_beginDList(dmp, list)
struct dm *dmp;
unsigned int list;
d1644 1
a1644 2
ogl_endDList(dmp)
struct dm *dmp;
d1654 1
a1654 3
ogl_drawDList(dmp, list)
struct dm *dmp;
unsigned int list;
d1664 1
a1664 4
ogl_freeDLists(dmp, list, range)
struct dm *dmp;
unsigned int list;
int range;
@


1.59
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1988 by the United States Army.
@


1.59.4.1
log
@sync to HEAD...
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
@


1.59.10.1
log
@merge from HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
@


1.59.2.1
log
@Initial ANSIfication
@
text
@d75 1
a75 1
HIDDEN XVisualInfo *ogl_choose_visual(struct dm *dmp, Tk_Window tkwin);
d81 18
a98 18
struct dm	*ogl_open(Tcl_Interp *interp, int argc, char **argv);
HIDDEN int	ogl_close(struct dm *dmp);
HIDDEN int	ogl_drawBegin(struct dm *dmp);
HIDDEN int      ogl_drawEnd(struct dm *dmp);
HIDDEN int	ogl_normal(struct dm *dmp), ogl_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye);
HIDDEN int	ogl_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect), ogl_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2);
HIDDEN int      ogl_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y);
HIDDEN int	ogl_drawVList(struct dm *dmp, register struct bn_vlist *vp);
HIDDEN int      ogl_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict), ogl_setBGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b);
HIDDEN int	ogl_setLineAttr(struct dm *dmp, int width, int style);
HIDDEN int	ogl_configureWin_guts(struct dm *dmp, int force);
HIDDEN int	ogl_configureWin(struct dm *dmp);
HIDDEN int	ogl_setLight(struct dm *dmp, int lighting_on);
HIDDEN int	ogl_setZBuffer(struct dm *dmp, int zbuffer_on);
HIDDEN int	ogl_setWinBounds(struct dm *dmp, int *w), ogl_debug(struct dm *dmp, int lvl);
HIDDEN int      ogl_beginDList(struct dm *dmp, unsigned int list), ogl_endDList(struct dm *dmp);
HIDDEN int      ogl_drawDList(struct dm *dmp, unsigned int list);
HIDDEN int      ogl_freeDLists(struct dm *dmp, unsigned int list, int range);
d176 3
a178 1
ogl_fogHint(struct dm *dmp, int fastfog)
d191 4
a194 1
ogl_open(Tcl_Interp *interp, int argc, char **argv)
d535 3
a537 1
ogl_share_dlist(struct dm *dmp1, struct dm *dmp2)
d707 2
a708 1
ogl_close(struct dm *dmp)
d745 2
a746 1
ogl_drawBegin(struct dm *dmp)
d794 2
a795 1
ogl_drawEnd(struct dm *dmp)
d851 4
a854 1
ogl_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye)
d950 3
a952 1
ogl_drawVList(struct dm *dmp, register struct bn_vlist *vp)
d1043 2
a1044 1
ogl_normal(struct dm *dmp)
d1074 6
a1079 1
ogl_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect)
d1101 4
a1104 1
ogl_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2)
d1136 3
a1138 1
ogl_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y)
d1154 4
a1157 1
ogl_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict)
d1205 3
a1207 1
ogl_setBGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b)
d1241 4
a1244 1
ogl_setLineAttr(struct dm *dmp, int width, int style)
d1264 3
a1266 1
ogl_debug(struct dm *dmp, int lvl)
d1274 3
a1276 1
ogl_setWinBounds(struct dm *dmp, int *w)
d1286 3
a1288 1
ogl_choose_visual(struct dm *dmp, Tk_Window tkwin)
d1436 3
a1438 1
ogl_configureWin_guts(struct dm *dmp, int force)
d1578 2
a1579 1
ogl_configureWin(struct dm *dmp)
d1585 3
a1587 1
ogl_setLight(struct dm *dmp, int lighting_on)
d1641 3
a1643 1
ogl_setZBuffer(struct dm *dmp, int zbuffer_on)
d1674 3
a1676 1
ogl_beginDList(struct dm *dmp, unsigned int list)
d1693 2
a1694 1
ogl_endDList(struct dm *dmp)
d1704 3
a1706 1
ogl_drawDList(struct dm *dmp, unsigned int list)
d1716 4
a1719 1
ogl_freeDLists(struct dm *dmp, unsigned int list, int range)
@


1.59.2.2
log
@sync branch with HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
@


1.58
log
@Converted from K&R to ANSI C - RFH
@
text
@d75 1
a75 1
HIDDEN XVisualInfo *ogl_choose_visual(struct dm *dmp, Tk_Window tkwin);
d81 18
a98 18
struct dm	*ogl_open(Tcl_Interp *interp, int argc, char **argv);
HIDDEN int	ogl_close(struct dm *dmp);
HIDDEN int	ogl_drawBegin(struct dm *dmp);
HIDDEN int      ogl_drawEnd(struct dm *dmp);
HIDDEN int	ogl_normal(struct dm *dmp), ogl_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye);
HIDDEN int	ogl_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect), ogl_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2);
HIDDEN int      ogl_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y);
HIDDEN int	ogl_drawVList(struct dm *dmp, register struct bn_vlist *vp);
HIDDEN int      ogl_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict), ogl_setBGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b);
HIDDEN int	ogl_setLineAttr(struct dm *dmp, int width, int style);
HIDDEN int	ogl_configureWin_guts(struct dm *dmp, int force);
HIDDEN int	ogl_configureWin(struct dm *dmp);
HIDDEN int	ogl_setLight(struct dm *dmp, int lighting_on);
HIDDEN int	ogl_setZBuffer(struct dm *dmp, int zbuffer_on);
HIDDEN int	ogl_setWinBounds(struct dm *dmp, int *w), ogl_debug(struct dm *dmp, int lvl);
HIDDEN int      ogl_beginDList(struct dm *dmp, unsigned int list), ogl_endDList(struct dm *dmp);
HIDDEN int      ogl_drawDList(struct dm *dmp, unsigned int list);
HIDDEN int      ogl_freeDLists(struct dm *dmp, unsigned int list, int range);
d176 3
a178 1
ogl_fogHint(struct dm *dmp, int fastfog)
d191 4
a194 1
ogl_open(Tcl_Interp *interp, int argc, char **argv)
d535 3
a537 1
ogl_share_dlist(struct dm *dmp1, struct dm *dmp2)
d707 2
a708 1
ogl_close(struct dm *dmp)
d745 2
a746 1
ogl_drawBegin(struct dm *dmp)
d794 2
a795 1
ogl_drawEnd(struct dm *dmp)
d851 4
a854 1
ogl_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye)
d950 3
a952 1
ogl_drawVList(struct dm *dmp, register struct bn_vlist *vp)
d1043 2
a1044 1
ogl_normal(struct dm *dmp)
d1074 6
a1079 1
ogl_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect)
d1101 4
a1104 1
ogl_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2)
d1136 3
a1138 1
ogl_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y)
d1154 4
a1157 1
ogl_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict)
d1205 3
a1207 1
ogl_setBGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b)
d1241 4
a1244 1
ogl_setLineAttr(struct dm *dmp, int width, int style)
d1264 3
a1266 1
ogl_debug(struct dm *dmp, int lvl)
d1274 3
a1276 1
ogl_setWinBounds(struct dm *dmp, int *w)
d1286 3
a1288 1
ogl_choose_visual(struct dm *dmp, Tk_Window tkwin)
d1436 3
a1438 1
ogl_configureWin_guts(struct dm *dmp, int force)
d1578 2
a1579 1
ogl_configureWin(struct dm *dmp)
d1585 3
a1587 1
ogl_setLight(struct dm *dmp, int lighting_on)
d1641 3
a1643 1
ogl_setZBuffer(struct dm *dmp, int zbuffer_on)
d1674 3
a1676 1
ogl_beginDList(struct dm *dmp, unsigned int list)
d1693 2
a1694 1
ogl_endDList(struct dm *dmp)
d1704 3
a1706 1
ogl_drawDList(struct dm *dmp, unsigned int list)
d1716 4
a1719 1
ogl_freeDLists(struct dm *dmp, unsigned int list, int range)
@


1.57
log
@SURVICE mods
@
text
@d75 1
a75 1
HIDDEN XVisualInfo *ogl_choose_visual();
d81 18
a98 18
struct dm	*ogl_open();
HIDDEN int	ogl_close();
HIDDEN int	ogl_drawBegin();
HIDDEN int      ogl_drawEnd();
HIDDEN int	ogl_normal(), ogl_loadMatrix();
HIDDEN int	ogl_drawString2D(), ogl_drawLine2D();
HIDDEN int      ogl_drawPoint2D();
HIDDEN int	ogl_drawVList();
HIDDEN int      ogl_setFGColor(), ogl_setBGColor();
HIDDEN int	ogl_setLineAttr();
HIDDEN int	ogl_configureWin_guts();
HIDDEN int	ogl_configureWin();
HIDDEN int	ogl_setLight();
HIDDEN int	ogl_setZBuffer();
HIDDEN int	ogl_setWinBounds(), ogl_debug();
HIDDEN int      ogl_beginDList(), ogl_endDList();
HIDDEN int      ogl_drawDList();
HIDDEN int      ogl_freeDLists();
d176 1
a176 3
ogl_fogHint(dmp, fastfog)
struct dm *dmp;
int fastfog;
d189 1
a189 4
ogl_open(interp, argc, argv)
     Tcl_Interp *interp;
     int argc;
     char *argv[];
d530 1
a530 3
ogl_share_dlist(dmp1, dmp2)
struct dm *dmp1;
struct dm *dmp2;
d700 1
a700 2
ogl_close(dmp)
struct dm *dmp;
d737 1
a737 2
ogl_drawBegin(dmp)
struct dm *dmp;
d785 1
a785 2
ogl_drawEnd(dmp)
struct dm *dmp;
d841 1
a841 4
ogl_loadMatrix(dmp, mat, which_eye)
struct dm *dmp;
mat_t mat;
int which_eye;
d937 1
a937 3
ogl_drawVList(dmp, vp)
     struct dm			*dmp;
     register struct rt_vlist	*vp;
d1028 1
a1028 2
ogl_normal(dmp)
struct dm *dmp;
d1058 1
a1058 6
ogl_drawString2D( dmp, str, x, y, size, use_aspect )
struct dm *dmp;
register char *str;
fastf_t x, y;
int size;
int use_aspect;
d1080 1
a1080 4
ogl_drawLine2D( dmp, x1, y1, x2, y2)
struct dm *dmp;
fastf_t x1, y1;
fastf_t x2, y2;
d1112 1
a1112 3
ogl_drawPoint2D(dmp, x, y)
struct dm *dmp;
fastf_t x, y;
d1128 1
a1128 4
ogl_setFGColor(dmp, r, g, b, strict)
struct dm *dmp;
unsigned char r, g, b;
int strict;
d1176 1
a1176 3
ogl_setBGColor(dmp, r, g, b)
struct dm *dmp;
unsigned char r, g, b;
d1210 1
a1210 4
ogl_setLineAttr(dmp, width, style)
struct dm *dmp;
int width;
int style;
d1230 1
a1230 3
ogl_debug(dmp, lvl)
struct dm *dmp;
int lvl;
d1238 1
a1238 3
ogl_setWinBounds(dmp, w)
struct dm *dmp;
int w[6];
d1248 1
a1248 3
ogl_choose_visual(dmp, tkwin)
struct dm *dmp;
Tk_Window tkwin;
d1396 1
a1396 3
ogl_configureWin_guts(dmp, force)
struct dm *dmp;
int force;
d1536 1
a1536 2
ogl_configureWin(dmp)
struct dm *dmp;
d1542 1
a1542 3
ogl_setLight(dmp, lighting_on)
struct dm *dmp;
int lighting_on;
d1596 1
a1596 3
ogl_setZBuffer(dmp, zbuffer_on)
struct dm *dmp;
int zbuffer_on;
d1627 1
a1627 3
ogl_beginDList(dmp, list)
struct dm *dmp;
unsigned int list;
d1644 1
a1644 2
ogl_endDList(dmp)
struct dm *dmp;
d1654 1
a1654 3
ogl_drawDList(dmp, list)
struct dm *dmp;
unsigned int list;
d1664 1
a1664 4
ogl_freeDLists(dmp, list, range)
struct dm *dmp;
unsigned int list;
int range;
@


1.56
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d160 4
d173 1
d800 9
d932 1
d940 1
d1178 5
d1185 1
d1190 4
d1195 1
d1611 8
a1619 1

d1632 1
d1634 1
a1634 1
    glEnable(GL_LIGHT2);
@


1.55
log
@Mods to rid libdm of two globals: tkwin and interp
@
text
@d885 1
a885 1
    bn_mat_idn( nozclip );
@


1.54
log
@Add vector counting code.
@
text
@d68 3
d72 1
a72 2

extern Tk_Window tkwin;
d138 7
a144 7
  0,
  0,
  0,
  0,
  0,
  0,				/* clipmin */
  0,				/* clipmax */
d148 3
a150 2
  1,				/* no zbuffer */
  0				/* no zclipping */
d186 4
a189 3
ogl_open(argc, argv)
int argc;
char *argv[];
d205 5
d216 1
d940 1
d942 1
d992 1
a992 1
#if 0
@


1.53
log
@*- mods to debug
@
text
@d68 2
d72 1
d735 1
a735 1
  if (dmp->dm_debugLevel)
d738 6
d816 1
d925 2
a926 2
struct dm *dmp;
register struct rt_vlist *vp;
d928 3
a930 2
  register struct rt_vlist *tvp;
  int first;
d932 2
a933 2
  if (dmp->dm_debugLevel)
    bu_log("ogl_drawVList()\n");
d935 1
a935 36
  /* Viewing region is from -1.0 to +1.0 */
  first = 1;
  for( BU_LIST_FOR( tvp, rt_vlist, &vp->l ) )  {
    register int	i;
    register int	nused = tvp->nused;
    register int	*cmd = tvp->cmd;
    register point_t *pt = tvp->pt;
    for( i = 0; i < nused; i++,cmd++,pt++ )  {
      if (dmp->dm_debugLevel > 2)
	bu_log(" %d (%g %g %g)\n", *cmd, V3ARGS(pt));
      switch( *cmd )  {
      case RT_VLIST_LINE_MOVE:
	/* Move, start line */
	if( first == 0 )
	  glEnd();
	first = 0;
	glBegin(GL_LINE_STRIP);
	glVertex3dv( *pt );
	break;
      case RT_VLIST_POLY_START:
	/* Start poly marker & normal */
	if( first == 0 )
	  glEnd();
	glBegin(GL_POLYGON);
	/* Set surface normal (vl_pnt points outward) */
	glNormal3dv( *pt );
	break;
      case RT_VLIST_LINE_DRAW:
      case RT_VLIST_POLY_MOVE:
      case RT_VLIST_POLY_DRAW:
	glVertex3dv( *pt );
	break;
      case RT_VLIST_POLY_END:
	/* Draw, End Polygon */
	glVertex3dv( *pt );
	glEnd();
d937 67
a1003 10
	break;
      case RT_VLIST_POLY_VERTNORM:
	/* Set per-vertex normal.  Given before vert. */
	glNormal3dv( *pt );
	break;
      }
    }
  }
  if( first == 0 )
    glEnd();
d1005 1
a1005 1
  return TCL_OK;
@


1.53.2.1
log
@Removed two globals: interp and tkwin
@
text
@d68 1
a68 1
#define USE_VECTOR_THRESHHOLD 0
a69 5
#if USE_VECTOR_THRESHHOLD
extern int vectorThreshold;	/* defined in libdm/tcl.c */ 
#endif

static int ogl_actively_drawing;
d133 7
a139 7
  {0, 0, 0, 0, 0},		/* bu_vls path name*/
  {0, 0, 0, 0, 0},		/* bu_vls full name drawing window */
  {0, 0, 0, 0, 0},		/* bu_vls short name drawing window */
  {0, 0, 0},			/* bg color */
  {0, 0, 0},			/* fg color */
  {0.0, 0.0, 0.0},		/* clipmin */
  {0.0, 0.0, 0.0},		/* clipmax */
d143 2
a144 3
  1,				/* zbuffer */
  0,				/* no zclipping */
  0				/* Tcl interpreter */
d180 3
a182 4
ogl_open(interp, argc, argv)
     Tcl_Interp *interp;
     int argc;
     char *argv[];
a197 5
  Tk_Window tkwin;

  if((tkwin = Tk_MainWindow(interp)) == NULL){
	  return DM_NULL;
  }
a203 1
  dmp->dm_interp = interp;
d732 1
a732 1
  if (dmp->dm_debugLevel) {
a734 6
    if (ogl_actively_drawing)
	    bu_log("ogl_drawBegin: already actively drawing\n");
  }

  ogl_actively_drawing = 1;

a806 1
  ogl_actively_drawing = 0;
d915 2
a916 2
     struct dm			*dmp;
     register struct rt_vlist	*vp;
d918 2
a919 5
	register struct rt_vlist	*tvp;
	int				first;
#if USE_VECTOR_THRESHHOLD
	static int			nvectors = 0;
#endif
d921 2
a922 2
	if (dmp->dm_debugLevel)
		bu_log("ogl_drawVList()\n");
d924 36
a959 1
	/* Viewing region is from -1.0 to +1.0 */
d961 10
a970 64
	for (BU_LIST_FOR(tvp, rt_vlist, &vp->l)) {
		register int	i;
		register int	nused = tvp->nused;
		register int	*cmd = tvp->cmd;
		register point_t *pt = tvp->pt;
		for (i = 0; i < nused; i++,cmd++,pt++) {
			if (dmp->dm_debugLevel > 2)
				bu_log(" %d (%g %g %g)\n", *cmd, V3ARGS(pt));
			switch (*cmd) {
			case RT_VLIST_LINE_MOVE:
				/* Move, start line */
				if (first == 0)
					glEnd();
				first = 0;
				glBegin(GL_LINE_STRIP);
				glVertex3dv(*pt);
				break;
			case RT_VLIST_POLY_START:
				/* Start poly marker & normal */
				if (first == 0)
					glEnd();
				glBegin(GL_POLYGON);
				/* Set surface normal (vl_pnt points outward) */
				glNormal3dv(*pt);
				break;
			case RT_VLIST_LINE_DRAW:
			case RT_VLIST_POLY_MOVE:
			case RT_VLIST_POLY_DRAW:
				glVertex3dv(*pt);
				break;
			case RT_VLIST_POLY_END:
				/* Draw, End Polygon */
				glVertex3dv(*pt);
				glEnd();
				first = 1;
				break;
			case RT_VLIST_POLY_VERTNORM:
				/* Set per-vertex normal.  Given before vert. */
				glNormal3dv(*pt);
				break;
			}
		}

#if USE_VECTOR_THRESHHOLD
/*XXX The Tcl_DoOneEvent below causes the following error:
X Error of failed request:  GLXBadContextState
*/

		nvectors += nused;

		if (nvectors >= vectorThreshold) {
			if (dmp->dm_debugLevel)
				bu_log("ogl_drawVList(): handle Tcl events\n");

			nvectors = 0;

			/* Handle events in the queue */
			while (Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT));

			if (dmp->dm_debugLevel)
				bu_log("ogl_drawVList(): handled Tcl events successfully\n");
		}
#endif
	}
d972 1
a972 4
	if (first == 0)
		glEnd();

	return TCL_OK;
@


1.52
log
@*- remove leading underscore from configureWin routines
@
text
@a1196 2
  XFlush(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy);
  bu_log("ogl_debug: flushed\n");
@


1.51
log
@Functions declared to return an int weren't returning an int.  Fixed.
@
text
@d86 1
a86 1
HIDDEN int	_ogl_configureWin();
d481 1
a481 1
  (void)_ogl_configureWin(dmp, 1);
d575 1
a575 1
    (void)_ogl_configureWin(dmp1, 1);
d645 1
a645 1
    (void)_ogl_configureWin(dmp2, 1);
d1366 1
a1366 1
_ogl_configureWin(dmp, force)
d1375 1
a1375 1
    bu_log("_ogl_configureWin()\n");
d1380 1
a1380 1
    bu_log("_ogl_configureWin: Couldn't make context current\n");
d1398 1
a1398 1
    bu_log("_ogl_configureWin()\n");
d1435 1
a1435 1
	bu_log("_ogl_configureWin: Can't open font '%s' or '%s'\n", FONT9, FONTBACK);
d1511 1
a1511 1
  return _ogl_configureWin(dmp, 0);
@


1.50
log
@*- new routine _ogl_configureWin
@
text
@d1511 1
a1511 1
  _ogl_configureWin(dmp, 0);
@


1.49
log
@*- fixed new bug in ogl_setBGColor (integer division)
*- mods to ogl_configureWin to verify that the size of
   the window did indeed change before doing anything
@
text
@d86 1
d481 1
a481 1
  (void)ogl_configureWin(dmp);
d575 1
a575 1
    (void)ogl_configureWin(dmp1);
d645 1
a645 1
    (void)ogl_configureWin(dmp2);
d1366 1
a1366 1
ogl_configureWin(dmp)
d1368 1
d1375 1
a1375 1
    bu_log("ogl_configureWin()\n");
d1380 1
a1380 1
    bu_log("ogl_configureWin: Couldn't make context current\n");
d1388 2
a1389 1
  if (dmp->dm_height == xwa.height &&
d1398 1
a1398 1
    bu_log("ogl_configureWin()\n");
d1435 1
a1435 1
	bu_log("ogl_configureWin: Can't open font '%s' or '%s'\n", FONT9, FONTBACK);
d1505 7
@


1.48
log
@Eliminated some unused variables
@
text
@a1142 1
#if 0
a1145 5
#else
  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->r = r >> 8;
  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->g = g >> 8;
  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->b = b >> 8;
#endif
d1384 6
d1392 8
a1399 3
	
  glViewport(0,  0, (dmp->dm_width),
	     (dmp->dm_height));
a1421 2

  dmp->dm_aspect = (fastf_t)dmp->dm_width / (fastf_t)dmp->dm_height;
@


1.47
log
@*- mods reflecting new members of "struct dm"
@
text
@a183 1
  int a_screen;
d185 1
a185 1
  int i, j, k;
d224 1
a224 1
  i = dm_processOptions(dmp, &init_proc_vls, --argc, ++argv);
a728 3
  GLint mm; 
  char i;
  char *str = "a";
d822 1
a822 2
  GLfloat gtmat[16], view[16];
  GLfloat *gtmatp;
a823 1
  int	i;
a918 1
  int i,j;
a983 1
  GLint mm; 
a1043 1
  register int nvec;
a1323 1
	  int result;
d1325 1
a1325 1
	  result = glXGetConfig(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
a1373 1
  int		npix;
@


1.46
log
@*- mods to reflect new member (dm_perspective) of struct dm
@
text
@d70 1
a70 5
void	ogl_configureWindowShape();
void	ogl_lighting();
void	ogl_zbuffer();

static XVisualInfo *ogl_choose_visual();
d77 16
a92 13
static int	ogl_close();
static int	ogl_drawBegin();
static int      ogl_drawEnd();
static int	ogl_normal(), ogl_loadMatrix();
static int	ogl_drawString2D(), ogl_drawLine2D();
static int      ogl_drawPoint2D();
static int	ogl_drawVList();
static int      ogl_setFGColor(), ogl_setBGColor();
static int	ogl_setLineAttr();
static int	ogl_setWinBounds(), ogl_debug();
static int      ogl_beginDList(), ogl_endDList();
static int      ogl_drawDList();
static int      ogl_freeDLists();
d107 1
d109 2
d141 2
d146 3
a148 3
static fastf_t default_viewscale = 1000.0;
static double	xlim_view = 1.0;	/* args for glOrtho*/
static double	ylim_view = 1.0;
d151 1
a151 1
static float amb_three[] = {0.3, 0.3, 0.3, 1.0};
d153 9
a161 9
static float light0_position[] = {100.0, 200.0, 100.0, 0.0};
static float light1_position[] = {100.0, 30.0, 100.0, 0.0};
static float light2_position[] = {-100.0, 20.0, 20.0, 0.0};
static float light3_position[] = {0.0, -100.0, -100.0, 0.0};

static float light0_diffuse[] = {0.70, 0.70, 0.70, 1.0}; /* white */
static float light1_diffuse[] = {0.60, 0.10, 0.10, 1.0}; /* red */
static float light2_diffuse[] = {0.10, 0.30, 0.10, 1.0}; /* green */
static float light3_diffuse[] = {0.10, 0.10, 0.30, 1.0}; /* blue */
a250 1
  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.zbuffer_on = 1;
d253 2
d260 1
a260 1
  /* this is important so that ogl_configureWindowShape knows to set the font */
d481 1
a481 1
  ogl_configureWindowShape(dmp);
d571 1
a571 1
    /* this is important so that ogl_configureWindowShape knows to set the font */
d575 1
a575 1
    ogl_configureWindowShape(dmp1);
d645 1
a645 1
    ogl_configureWindowShape(dmp2);
d688 1
a688 1
static int
d726 1
a726 1
static int
d761 1
a761 1
    if (((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.lighting_on){
d772 1
a772 1
static int
d819 1
a819 1
static int
a855 3
#if 0
    ogl_drawString2D( dmp, "R", 2020, 0, 0, DM_RED );
#else
a856 1
#endif
d904 1
a904 1
  if (((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.lighting_on ){
a913 1

d918 1
a918 3

/* ARGSUSED */
static int
d987 1
a987 1
static int
d1006 1
a1006 1
    if (((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.lighting_on)
d1019 1
a1019 1
static int
d1046 1
a1046 1
static int
d1082 1
a1082 1
static int
d1100 1
a1100 1
static int
d1118 1
a1118 1
    if(((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.lighting_on){
d1140 1
a1140 1
static int
d1182 1
a1182 1
static int
d1205 1
a1205 1
static int
d1217 1
a1217 1
static int
d1229 1
a1229 1
static XVisualInfo *
d1366 1
a1366 1
    return(NULL); /* failure */
d1372 1
a1372 1
 *			O G L _ C O N F I G U R E W I N D O W S H A P E
d1380 2
a1381 2
void
ogl_configureWindowShape(dmp)
d1390 1
a1390 1
    bu_log("ogl_configureWindowShape()\n");
d1395 2
a1396 2
    bu_log("ogl_configureWindowShape: Couldn't make context current\n");
    return;
d1411 2
a1412 3
  if( ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.zbuffer_on )
    ogl_zbuffer(dmp,
		((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.zbuffer_on);
d1414 1
a1414 2
  ogl_lighting(dmp,
	       ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.lighting_on);
d1440 2
a1441 2
	bu_log("ogl_configureWindowShape: Can't open font '%s' or '%s'\n", FONT9, FONTBACK);
	return;
d1508 2
d1512 2
a1513 2
void	
ogl_lighting(dmp, lighting_on)
d1520 2
a1521 1
  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.lighting_on = lighting_on;
d1526 2
a1527 2
    bu_log("ogl_lighting: Couldn't make context current\n");
    return;
d1530 1
a1530 1
  if (!((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.lighting_on) {
d1556 2
d1560 2
a1561 2
void	
ogl_zbuffer(dmp, zbuffer_on)
d1566 1
a1566 1
    bu_log("ogl_zbuffer:\n");
d1568 2
a1569 1
  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.zbuffer_on = zbuffer_on;
d1574 2
a1575 2
    bu_log("ogl_zbuffer: Couldn't make context current\n");
    return;
d1578 3
a1580 2
  if( ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.zbuf == 0 ) {
    ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.zbuffer_on = 0;
d1583 1
a1583 1
  if (((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.zbuffer_on)  {
d1589 2
@


1.45
log
@*- fixed typo
@
text
@d138 1
a142 1
static int perspective_mode = 0;
a214 1
  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->perspective_mode = &perspective_mode;
d754 1
a754 2
      glFogi(GL_FOG_MODE, *((struct ogl_vars *)dmp->dm_vars.priv_vars)->perspective_mode ?
	     GL_EXP : GL_LINEAR);
d921 1
a921 1
ogl_drawVList( dmp, vp, perspective )
a923 1
double perspective;
d940 1
a940 1
      if (dmp->dm_debugLevel)
@


1.44
log
@*- mods to reflect changes to struct dm
@
text
@d252 1
a252 1
  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.debug = dmp->dm_debug;
@


1.43
log
@*- remove code that sets the visual of the toplevel
   window. If this needs to be done, it shouldn't
   be done here.
@
text
@d88 1
a88 1
static int      ogl_setFGColor(), ogl_setBGColor(), ogl_getBGColor();
a106 1
  ogl_getBGColor,
d117 2
a118 1
  IRBOUND,
d132 7
a138 1
  0
a140 1

a247 1
  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.zclipping_on = 1;
d251 4
d731 1
a731 1
  if (((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.debug)
d773 1
a773 1
  if (((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.debug)
d787 1
a787 1
  if(((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.debug){
d828 1
a828 1
  if(((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.debug){
d868 1
a868 1
  if(!((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.zclipping_on){
d932 1
a932 1
  if (((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.debug)
d943 1
a943 1
      if (((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.debug)
d998 1
a998 1
  if (((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.debug)
d1032 1
a1032 1
  if (((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.debug)
d1059 1
a1059 1
  if (((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.debug)
d1062 1
a1062 1
  if(((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.debug){
d1092 1
a1092 1
  if (((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.debug){
d1108 1
a1108 1
register short r, g, b;
d1111 1
a1111 1
  if (((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.debug)
d1114 4
d1148 1
a1148 1
int r, g, b;
d1150 2
a1151 1
  GLclampf rf, gf, bf;
d1153 3
a1155 2
  if (((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.debug)
    bu_log("ogl_setBGColor()\n");
d1157 1
d1161 5
a1187 18
ogl_getBGColor(dmp, interp)
struct dm *dmp;
Tcl_Interp *interp;
{
  struct bu_vls vls;

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "%d %d %d",
		(int)(((struct ogl_vars *)dmp->dm_vars.priv_vars)->r * 255.0),
		(int)(((struct ogl_vars *)dmp->dm_vars.priv_vars)->g * 255.0),
		(int)(((struct ogl_vars *)dmp->dm_vars.priv_vars)->b * 255.0));
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  bu_vls_free(&vls);

  return TCL_OK;
}

static int
d1193 1
a1193 1
  if (((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.debug)
d1215 1
a1215 1
  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.debug = lvl;
d1394 1
a1394 1
  if (((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.debug)
d1522 1
a1522 1
  if (((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.debug)
d1567 1
a1567 1
  if (((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.debug)
d1596 1
a1596 1
  if (((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.debug)
d1614 1
a1614 1
  if (((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.debug)
d1626 1
a1626 1
  if (((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.debug)
d1639 1
a1639 1
  if (((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.debug)
@


1.42
log
@*- mods to ogl_choose_visual
@
text
@a1343 13
	  if (!dmp->dm_top) {
	    /*
	     * Try to set the visual of the toplevel window to be the same
	     * as the display manager window . This seems to be necessary
	     * to avoid the case where the toplevel window's colormap gets
	     * swapped in and hoses things up.
	     */
	    Tk_SetWindowVisual(((struct dm_xvars *)dmp->dm_vars.pub_vars)->top,
			       maxvip->visual,
			       maxvip->depth,
			       ((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap);
	  }

@


1.41
log
@*- mods to better support Mesa
@
text
@d1328 4
a1331 20
	{
	  Colormap default_cmap;
	  int default_screen;

	  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap =
	    XCreateColormap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			    RootWindow(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
				       maxvip->screen), maxvip->visual, AllocNone);

	  /* Copy default colors below CMAP_BASE to private colormap to help
	     reduce flashing */
	  default_screen = DefaultScreen(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy);
	  default_cmap = DefaultColormap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
					 default_screen);
	  dm_copy_cmap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		       ((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap, /* destination */
		       default_cmap,                            /* source */
		       /* low, high,  use XAllocColor */
		       0, CMAP_BASE, 0);
	}
d1344 13
a1356 3
#if 0
	  XFree((void *)vibase);
#endif
d1382 1
a1382 4
#if 0
      XFree((void *)vibase);
#endif
      return(NULL); /* failure */
@


1.40
log
@Can't check for GLX extension under Linux (in ogl_open)
@
text
@a37 4
#ifdef USE_MESA_GL
#include <MESA_GL/glx.h>
#include <MESA_GL/gl.h>
#else
a39 1
#endif
d256 1
a256 1
#if !defined(linux )
@


1.39
log
@*- mods to ogl_choose_visual
	- make search for zbuffer a desire
@
text
@d261 1
a261 1

d271 1
a271 1

@


1.38
log
@*- check return values from glXGetConfig
*- call glXGetConfig with GLX_DEPTH_SIZE attribute and
	check to insure that depth is nonzero
@
text
@d1248 9
a1256 4
  int use = 0;
  int rgba = 0;
  int dbfr = 0;
  int depth = 0;
d1258 2
a1259 1
  int m_stereo, stereo;
a1260 4
  /*
   * m_stereo - try to get stereo 
   */

d1294 7
a1300 4
      fail = glXGetConfig(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		     vip, GLX_DEPTH_SIZE,&depth);
      if (fail || !depth)
	continue;
a1302 1
      /* desires */
d1378 2
d1381 1
a1381 2
    /* if no success at this point, relax a desire and try again */
    if ( m_stereo ){
d1384 1
d1387 6
@


1.37
log
@*- add parameter to ogl_fogHint(), ogl_lighting() and ogl_zbuffer()
@
text
@d367 1
a367 1
  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->depth = ((struct dm_xvars *)dmp->dm_vars.pub_vars)->vip->depth;
d1247 1
d1251 1
d1277 1
a1277 1
      glXGetConfig(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
d1279 1
a1279 1
      if (!use)
d1282 1
a1282 1
      glXGetConfig(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
d1284 1
a1284 1
      if (!rgba)
d1287 1
a1287 1
      glXGetConfig(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
d1289 1
a1289 1
      if (!dbfr)
d1292 5
d1300 1
a1300 1
	glXGetConfig(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
d1302 2
a1303 1
	if (!stereo)
d1305 1
d1353 4
a1356 1
	  glXGetConfig(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy, maxvip, GLX_DEPTH_SIZE,
d1360 1
@


1.36
log
@*- some cleanup
@
text
@d160 1
a160 1
ogl_fogHint(dmp)
d162 1
d164 2
a165 2
  glHint(GL_FOG_HINT,
	 ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.fastfog ? GL_FASTEST : GL_NICEST);
d1417 2
a1418 1
    ogl_zbuffer(dmp);
d1420 2
a1421 1
  ogl_lighting(dmp);
d1518 1
a1518 1
ogl_lighting(dmp)
d1520 1
d1525 2
d1563 1
a1563 1
ogl_zbuffer(dmp)
d1565 1
d1570 2
a1579 3
#if 0
    bu_log("dm-Ogl: This machine has no Zbuffer to enable\n");
#endif
@


1.35
log
@*- code to support sharing display lists
@
text
@a80 8
/* Flags indicating whether the ogl and sgi display managers have been
 * attached.
 * These are necessary to decide whether or not to use direct rendering
 * with gl.
 */
char  ogl_ogl_used = 0;
char  ogl_sgi_used = 0;

a390 10
#if 0
  bu_log("%s is using %s OpenGL rendering context.\n", bu_vls_addr(&dmp->dm_pathName),
	 ((struct ogl_vars *)dmp->dm_vars.priv_vars)->is_direct ?
	 "a direct" : "an indirect");
#endif

  /* set ogl_ogl_used if the context was ever direct */
  ogl_ogl_used = (((struct ogl_vars *)dmp->dm_vars.priv_vars)->is_direct ||
		  ogl_ogl_used);

d1571 1
d1573 1
@


1.34
log
@*- add support for new routines:
	dm_setFGColor(), dm_setBGColor(), dm_getBGColor()
@
text
@d260 1
a260 2
  /* this is important so that ogl_configure_notify knows to set
   * the font */
a382 4
  /* If the sgi display manager has been used, then we must use
   * an indirect context. Otherwise use direct, since it is usually
   * faster.
   */
d385 2
a386 2
			((struct dm_xvars *)dmp->dm_vars.pub_vars)->vip, 0,
			ogl_sgi_used ? GL_FALSE : GL_TRUE))==NULL) {
d391 1
a481 4
#if 0
  glDrawBuffer(GL_FRONT_AND_BACK);
  glClearColor(0.0, 0.0, 0.0, 0.0);
#else
a482 1
#endif
d524 168
@


1.33
log
@*- change _setColor() to _setFGColor()
*- add _setBGColor()
@
text
@d101 1
a101 1
static int      ogl_setFGColor(), ogl_setBGColor();
d120 1
d996 1
d1026 18
@


1.32
log
@*- replaced Tcl_AppendResult with calls to bu_log
*- mods to ogl_configureWindowShape(), ogl_lighting() and ogl_zbuffer()
@
text
@d64 2
a65 2
#define VIEWFACTOR      (1/(*dmp->dm_vp))
#define VIEWSIZE        (2*(*dmp->dm_vp))
d101 2
a102 1
static int      ogl_setColor(), ogl_setLineAttr();
d118 2
a119 1
  ogl_setColor,
d485 1
d488 4
a491 1
  glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
d634 4
a637 1
    glClearColor(0.0, 0.0, 0.0, 0.0);
d960 1
a960 1
ogl_setColor(dmp, r, g, b, strict)
a964 2
  register int nvec;

d966 1
a966 1
    bu_log("ogl_setColor()\n");
d995 32
d1259 5
a1263 2
  glClearColor(0.0, 0.0, 0.0, 0.0);
  glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
@


1.31
log
@Added perspective arg to drawVList().
@
text
@d333 1
a333 3
    Tcl_AppendResult(interp, "dm-Ogl: Failed to open ",
		     bu_vls_addr(&dmp->dm_pathName),
		     "\n", (char *)NULL);
d367 1
a367 2
    Tcl_AppendResult(interp, "ogl_open: Can't get an appropriate visual.\n",
		     (char *)NULL);
d389 1
a389 2
    Tcl_AppendResult(interp, "ogl_open: couldn't create glXContext.\n",
		     (char *)NULL);
d399 7
a405 4
  Tcl_AppendResult(interp, "Using ",
		   ((struct ogl_vars *)dmp->dm_vars.priv_vars)->is_direct ?
		   "a direct" : "an indirect",
		   " OpenGL rendering context.\n", (char *)NULL);
d427 1
a427 3
	  Tcl_AppendResult(interp,
			   "Glx_open: Couldn't open the dials+buttons\n",
			   (char *)NULL);
d468 1
a468 1
    Tcl_AppendResult(interp, "ogl_open: Couldn't make context current\n", (char *)NULL);
d475 1
a475 1
    Tcl_AppendResult(interp, "dm-ogl: Can't make display lists for font.\n", (char *)NULL);
d517 1
a517 1
  glTranslatef( 0.0, 0.0, -1.0); 
d580 1
a580 1
    Tcl_AppendResult(interp, "ogl_drawBegin\n", (char *)NULL);
d585 1
a585 2
    Tcl_AppendResult(interp,
 		     "ogl_drawBegin: Couldn't make context current\n", (char *)NULL);
d622 1
a622 1
    Tcl_AppendResult(interp, "ogl_drawEnd\n", (char *)NULL);
d643 1
a643 1
    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
d676 1
a676 1
    Tcl_AppendResult(interp, "ogl_loadMatrix()\n", (char *)NULL);
d686 1
a686 1
    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
a723 1
#ifdef USE_RT_ASPECT
a732 11
#else
  gtmat[0] = *(mptr++) * dmp->dm_aspect;
  gtmat[4] = *(mptr++) * dmp->dm_aspect;
  gtmat[8] = *(mptr++) * dmp->dm_aspect;
  gtmat[12] = *(mptr++) * dmp->dm_aspect;

  gtmat[1] = *(mptr++);
  gtmat[5] = *(mptr++);
  gtmat[9] = *(mptr++);
  gtmat[13] = *(mptr++);
#endif
d778 1
a778 1
    Tcl_AppendResult(interp, "ogl_drawVList()\n", (char *)NULL);
d844 1
a844 1
    Tcl_AppendResult(interp, "ogl_normal\n", (char *)NULL);
a880 1
#ifdef USE_RT_ASPECT
a881 3
#else
    glRasterPos2f(x * dmp->dm_aspect, y);
#endif
d959 1
a959 1
    Tcl_AppendResult(interp, "ogl_setColor()\n", (char *)NULL);
d996 1
a996 1
    Tcl_AppendResult(interp, "ogl_setLineAttr()\n", (char *)NULL);
d1019 1
a1019 1
  Tcl_AppendResult(interp, "flushed\n", (char *)NULL);
d1164 1
a1164 1
      Tcl_AppendResult(interp, "Stereo not available.\n", (char *)NULL);
d1194 1
a1194 1
    Tcl_AppendResult(interp, "ogl_configureWindowShape()\n", (char *)NULL);
d1196 7
a1229 1
#ifdef USE_RT_ASPECT
a1230 5
#else
  dmp->dm_aspect =
    (fastf_t)dmp->dm_height/
    (fastf_t)dmp->dm_width;
#endif
d1241 1
a1241 2
	Tcl_AppendResult(interp, "dm-Ogl: Can't open font '", FONT9,
			 "' or '", FONTBACK, "'\n", (char *)NULL);
d1316 8
a1323 1
    Tcl_AppendResult(interp, "ogl_lighting()\n", (char *)NULL);
d1358 8
a1365 1
    Tcl_AppendResult(interp, "ogl_zbuffer()\n", (char *)NULL);
d1368 1
a1368 2
    Tcl_AppendResult(interp, "dm-Ogl: This machine has no Zbuffer to enable\n",
		     (char *)NULL);
d1386 1
a1386 1
    Tcl_AppendResult(interp, "ogl_beginDList()\n", (char *)NULL);
d1391 1
a1391 2
    Tcl_AppendResult(interp,
 		     "ogl_beginDList: Couldn't make context current\n", (char *)NULL);
d1404 1
a1404 1
    Tcl_AppendResult(interp, "ogl_endDList()\n", (char *)NULL);
d1416 1
a1416 1
    Tcl_AppendResult(interp, "ogl_drawDList()\n", (char *)NULL);
d1429 8
a1436 1
    Tcl_AppendResult(interp, "ogl_freeDLists()\n", (char *)NULL);
@


1.30
log
@*- change notion of aspect to width/height as in rt
@
text
@d784 1
a784 1
ogl_drawVList( dmp, vp )
d787 1
@


1.29
log
@*- mods to ogl_drawPoint2D(), ogl_drawLine2D() and ogl_drawString2D
	to use floats instead of ints for x/y parameters
*- use new dm_vars structure
@
text
@d702 1
d704 3
d728 11
d748 1
d895 4
a898 1
  if(use_aspect)	
d900 1
d1241 4
d1248 1
a1248 1

@


1.28
log
@save XVisualInfo *
@
text
@d4 1
d6 4
d18 1
d61 1
d79 1
a79 1
static XVisualInfo *ogl_set_visual();
d139 1
a139 1
  0,
a145 3
/* ogl stuff */
struct ogl_vars head_ogl_vars;

d169 1
a169 1
	 ((struct ogl_vars *)dmp->dm_vars)->mvars.fastfog ? GL_FASTEST : GL_NICEST);
d203 6
a208 4
  /* Only need to do this once for this display manager */
  if(!count){
    bzero((void *)&head_ogl_vars, sizeof(struct ogl_vars));
    BU_LIST_INIT( &head_ogl_vars.l );
d211 3
a213 3
  *dmp = dm_ogl; /* struct copy */
  BU_GETSTRUCT(dmp->dm_vars, ogl_vars);
  if(dmp->dm_vars == (genptr_t)NULL){
d219 1
a219 1
  ((struct ogl_vars *)dmp->dm_vars)->perspective_mode = &perspective_mode;
d244 3
a246 3
  ((struct ogl_vars *)dmp->dm_vars)->devmotionnotify = LASTEvent;
  ((struct ogl_vars *)dmp->dm_vars)->devbuttonpress = LASTEvent;
  ((struct ogl_vars *)dmp->dm_vars)->devbuttonrelease = LASTEvent;
d250 6
a255 8
  ((struct ogl_vars *)dmp->dm_vars)->mvars.rgb = 1;
  ((struct ogl_vars *)dmp->dm_vars)->mvars.doublebuffer = 1;
  ((struct ogl_vars *)dmp->dm_vars)->mvars.zclipping_on = 1;
  ((struct ogl_vars *)dmp->dm_vars)->mvars.zbuffer_on = 1;
  ((struct ogl_vars *)dmp->dm_vars)->mvars.fastfog = 1;
  ((struct ogl_vars *)dmp->dm_vars)->mvars.fogdensity = 1.0;

  BU_LIST_APPEND(&head_ogl_vars.l, &((struct ogl_vars *)dmp->dm_vars)->l);
d259 1
a259 1
  ((struct ogl_vars *)dmp->dm_vars)->fontstruct = NULL;
d303 1
a303 1
    ((struct ogl_vars *)dmp->dm_vars)->xtkwin =
d308 1
a308 1
    ((struct ogl_vars *)dmp->dm_vars)->top = ((struct ogl_vars *)dmp->dm_vars)->xtkwin;
d314 1
a314 1
       ((struct ogl_vars *)dmp->dm_vars)->top = tkwin;
d321 1
a321 1
       ((struct ogl_vars *)dmp->dm_vars)->top =
d327 2
a328 2
     ((struct ogl_vars *)dmp->dm_vars)->xtkwin =
       Tk_CreateWindow(interp, ((struct ogl_vars *)dmp->dm_vars)->top,
d332 1
a332 1
  if( ((struct ogl_vars *)dmp->dm_vars)->xtkwin == NULL ) {
d342 1
a342 1
		(char *)Tk_Name(((struct ogl_vars *)dmp->dm_vars)->xtkwin));
d359 2
a360 2
  ((struct ogl_vars *)dmp->dm_vars)->dpy =
    Tk_Display(((struct ogl_vars *)dmp->dm_vars)->top);
d362 1
a362 1
  Tk_GeometryRequest(((struct ogl_vars *)dmp->dm_vars)->xtkwin,
d367 2
a368 2
  if((((struct ogl_vars *)dmp->dm_vars)->vip=ogl_set_visual(dmp,
				    ((struct ogl_vars *)dmp->dm_vars)->xtkwin)) == NULL){
d375 1
a375 1
  ((struct ogl_vars *)dmp->dm_vars)->depth = ((struct ogl_vars *)dmp->dm_vars)->vip->depth;
d377 1
a377 1
  Tk_MakeWindowExist(((struct ogl_vars *)dmp->dm_vars)->xtkwin);
d379 3
a381 3
  ((struct ogl_vars *)dmp->dm_vars)->win =
    Tk_WindowId(((struct ogl_vars *)dmp->dm_vars)->xtkwin);
  dmp->dm_id = ((struct ogl_vars *)dmp->dm_vars)->win;
d388 3
a390 3
  if ((((struct ogl_vars *)dmp->dm_vars)->glxc =
       glXCreateContext(((struct ogl_vars *)dmp->dm_vars)->dpy,
			((struct ogl_vars *)dmp->dm_vars)->vip, 0,
d400 3
a402 3
  ((struct ogl_vars *)dmp->dm_vars)->is_direct =
    (char) glXIsDirect(((struct ogl_vars *)dmp->dm_vars)->dpy,
		       ((struct ogl_vars *)dmp->dm_vars)->glxc);
d404 1
a404 1
		   ((struct ogl_vars *)dmp->dm_vars)->is_direct ?
d408 1
a408 1
  ogl_ogl_used = (((struct ogl_vars *)dmp->dm_vars)->is_direct ||
d416 1
a416 1
    (XDeviceInfoPtr)XListInputDevices(((struct ogl_vars *)dmp->dm_vars)->dpy,
d426 1
a426 1
	if((dev = XOpenDevice(((struct ogl_vars *)dmp->dm_vars)->dpy,
d439 1
a439 1
	    DeviceButtonPress(dev, ((struct ogl_vars *)dmp->dm_vars)->devbuttonpress,
d442 1
a442 1
	    DeviceButtonRelease(dev, ((struct ogl_vars *)dmp->dm_vars)->devbuttonrelease,
d449 1
a449 1
	    DeviceMotionNotify(dev, ((struct ogl_vars *)dmp->dm_vars)->devmotionnotify,
d459 2
a460 2
	XSelectExtensionEvent(((struct ogl_vars *)dmp->dm_vars)->dpy,
			      ((struct ogl_vars *)dmp->dm_vars)->win, e_class, nclass);
d468 3
a470 3
  if (!glXMakeCurrent(((struct ogl_vars *)dmp->dm_vars)->dpy,
		      ((struct ogl_vars *)dmp->dm_vars)->win,
		      ((struct ogl_vars *)dmp->dm_vars)->glxc)){
d477 1
a477 1
  if ((((struct ogl_vars *)dmp->dm_vars)->fontOffset = glGenLists(128))==0){
d484 1
a484 1
  dmp->dm_displaylist = ((struct ogl_vars *)dmp->dm_vars)->fontOffset + 128;
d490 1
a490 1
  if (((struct ogl_vars *)dmp->dm_vars)->mvars.doublebuffer)
d516 1
a516 1
  glGetDoublev(GL_PROJECTION_MATRIX, ((struct ogl_vars *)dmp->dm_vars)->faceplate_mat);
d523 1
a523 1
  ((struct ogl_vars *)dmp->dm_vars)->face_flag = 1;	/* faceplate matrix is on top of stack */
d525 1
a525 1
  Tk_MapWindow(((struct ogl_vars *)dmp->dm_vars)->xtkwin);
d539 5
a543 11
  if(((struct ogl_vars *)dmp->dm_vars)->dpy){
    if(((struct ogl_vars *)dmp->dm_vars)->glxc){
#if 0
      glDrawBuffer(GL_FRONT);
      glClearColor(0.0, 0.0, 0.0, 0.0);
      /*	glClearDepth(0.0);*/
      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
      glDrawBuffer(GL_BACK);
#endif
      glXDestroyContext(((struct ogl_vars *)dmp->dm_vars)->dpy,
			((struct ogl_vars *)dmp->dm_vars)->glxc);
d546 6
a551 3
    if(((struct ogl_vars *)dmp->dm_vars)->cmap)
      XFreeColormap(((struct ogl_vars *)dmp->dm_vars)->dpy,
		    ((struct ogl_vars *)dmp->dm_vars)->cmap);
d553 3
a555 2
    if(((struct ogl_vars *)dmp->dm_vars)->xtkwin)
      Tk_DestroyWindow(((struct ogl_vars *)dmp->dm_vars)->xtkwin);
a557 3
  if(((struct ogl_vars *)dmp->dm_vars)->l.forw != BU_LIST_NULL)
    BU_LIST_DEQUEUE(&((struct ogl_vars *)dmp->dm_vars)->l);

d561 2
a562 1
  bu_free(dmp->dm_vars, "ogl_close: ogl_vars");
d569 1
a569 1
 *			O G L _ P R O L O G
d582 1
a582 1
  if (((struct ogl_vars *)dmp->dm_vars)->mvars.debug)
d585 3
a587 3
  if (!glXMakeCurrent(((struct ogl_vars *)dmp->dm_vars)->dpy,
		      ((struct ogl_vars *)dmp->dm_vars)->win,
		      ((struct ogl_vars *)dmp->dm_vars)->glxc)){
d593 1
a593 1
  if (((struct ogl_vars *)dmp->dm_vars)->face_flag){
d598 2
a599 2
    ((struct ogl_vars *)dmp->dm_vars)->face_flag = 0;
    if (((struct ogl_vars *)dmp->dm_vars)->mvars.cueing_on){
d604 1
a604 1
      fogdepth = (GLfloat) (0.5*((struct ogl_vars *)dmp->dm_vars)->mvars.fogdensity/
d607 1
a607 1
      glFogi(GL_FOG_MODE, *((struct ogl_vars *)dmp->dm_vars)->perspective_mode ?
d610 1
a610 1
    if (((struct ogl_vars *)dmp->dm_vars)->mvars.lighting_on){
d619 1
a619 1
 *			O G L _ E P I L O G
d625 1
a625 1
  if (((struct ogl_vars *)dmp->dm_vars)->mvars.debug)
d628 3
a630 3
  if(((struct ogl_vars *)dmp->dm_vars)->mvars.doublebuffer ){
    glXSwapBuffers(((struct ogl_vars *)dmp->dm_vars)->dpy,
		   ((struct ogl_vars *)dmp->dm_vars)->win);
d636 1
a636 1
  if(((struct ogl_vars *)dmp->dm_vars)->mvars.debug){
d660 1
a660 1
 *  			O G L _ N E W R O T
d677 1
a677 1
  if(((struct ogl_vars *)dmp->dm_vars)->mvars.debug){
d713 1
a713 1
  if( ! ((struct ogl_vars*)dmp->dm_vars)->mvars.zclipping_on ) {
d750 1
a750 1
  if (((struct ogl_vars *)dmp->dm_vars)->mvars.lighting_on ){
d776 1
a776 1
  if (((struct ogl_vars *)dmp->dm_vars)->mvars.debug)
d787 1
a787 1
      if (((struct ogl_vars *)dmp->dm_vars)->mvars.debug)
d842 1
a842 1
  if (((struct ogl_vars *)dmp->dm_vars)->mvars.debug)
d845 1
a845 1
  if (!((struct ogl_vars *)dmp->dm_vars)->face_flag){
d848 1
a848 1
    glLoadMatrixd( ((struct ogl_vars *)dmp->dm_vars)->faceplate_mat );
d852 2
a853 2
    ((struct ogl_vars *)dmp->dm_vars)->face_flag = 1;
    if(((struct ogl_vars *)dmp->dm_vars)->mvars.cueing_on)
d855 1
a855 1
    if (((struct ogl_vars *)dmp->dm_vars)->mvars.lighting_on)
d863 1
a863 1
 *			O G L _ P U T S
d872 1
a872 1
int x, y;
d876 2
a877 2
  if (((struct ogl_vars *)dmp->dm_vars)->mvars.debug)
    Tcl_AppendResult(interp, "ogl_drawString2D()\n", (char *)NULL);
d880 1
a880 1
    glRasterPos2f(GED2IRIS(x) * dmp->dm_aspect,  GED2IRIS(y));
d882 1
a882 1
    glRasterPos2f(GED2IRIS(x),  GED2IRIS(y));
d884 1
a884 1
  glListBase(((struct ogl_vars *)dmp->dm_vars)->fontOffset);
d892 1
a892 1
 *			O G L _ 2 D _ L I N E
d896 1
a896 1
ogl_drawLine2D( dmp, x1, y1, x2, y2 )
d898 2
a899 2
int x1, y1;
int x2, y2;
d903 2
a904 2
  if (((struct ogl_vars *)dmp->dm_vars)->mvars.debug)
    Tcl_AppendResult(interp, "ogl_drawLine2D()\n", (char *)NULL);
d906 1
a906 1
  if(((struct ogl_vars *)dmp->dm_vars)->mvars.debug){
a907 1
    struct bu_vls tmp_vls;
a908 1
    bu_vls_init(&tmp_vls);
d910 5
a914 5
    bu_vls_printf(&tmp_vls, "projection matrix:\n");
    bu_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[0], pmat[4], pmat[8],pmat[12]);
    bu_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[1], pmat[5], pmat[9],pmat[13]);
    bu_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[2], pmat[6], pmat[10],pmat[14]);
    bu_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[3], pmat[7], pmat[11],pmat[15]);
d916 5
a920 8
    bu_vls_printf(&tmp_vls, "modelview matrix:\n");
    bu_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[0], pmat[4], pmat[8],pmat[12]);
    bu_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[1], pmat[5], pmat[9],pmat[13]);
    bu_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[2], pmat[6], pmat[10],pmat[14]);
    bu_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[3], pmat[7], pmat[11],pmat[15]);

    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
    bu_vls_free(&tmp_vls);
d924 2
a925 2
  glVertex2f(GED2IRIS(x1),  GED2IRIS(y1));
  glVertex2f(GED2IRIS(x2),  GED2IRIS(y2));
d934 1
a934 1
int x, y;
d936 4
a939 2
  if (((struct ogl_vars *)dmp->dm_vars)->mvars.debug)
    Tcl_AppendResult(interp, "ogl_drawPoint2D()\n", (char *)NULL);
d942 1
a942 1
  glVertex2f(GED2IRIS(x), GED2IRIS(y));
d957 1
a957 1
  if (((struct ogl_vars *)dmp->dm_vars)->mvars.debug)
d965 1
a965 1
    if(((struct ogl_vars *)dmp->dm_vars)->mvars.lighting_on){
d994 1
a994 1
  if (((struct ogl_vars *)dmp->dm_vars)->mvars.debug)
d1016 2
a1017 2
  ((struct ogl_vars *)dmp->dm_vars)->mvars.debug = lvl;
  XFlush(((struct ogl_vars *)dmp->dm_vars)->dpy);
d1036 1
a1036 1
ogl_set_visual(dmp, tkwin)
d1041 2
a1043 1
  int good[40];
d1067 1
a1067 1
  vibase = XGetVisualInfo(((struct ogl_vars *)dmp->dm_vars)->dpy,
d1073 1
a1073 1
      glXGetConfig(((struct ogl_vars *)dmp->dm_vars)->dpy,
d1078 1
a1078 1
      glXGetConfig(((struct ogl_vars *)dmp->dm_vars)->dpy,
d1083 1
a1083 1
      glXGetConfig(((struct ogl_vars *)dmp->dm_vars)->dpy,
d1091 1
a1091 1
	glXGetConfig(((struct ogl_vars *)dmp->dm_vars)->dpy,
d1099 4
d1122 3
a1124 3
	  ((struct ogl_vars *)dmp->dm_vars)->cmap =
	    XCreateColormap(((struct ogl_vars *)dmp->dm_vars)->dpy,
			    RootWindow(((struct ogl_vars *)dmp->dm_vars)->dpy,
d1129 2
a1130 2
	  default_screen = DefaultScreen(((struct ogl_vars *)dmp->dm_vars)->dpy);
	  default_cmap = DefaultColormap(((struct ogl_vars *)dmp->dm_vars)->dpy,
d1132 2
a1133 2
	  dm_copy_cmap(((struct ogl_vars *)dmp->dm_vars)->dpy,
		       ((struct ogl_vars *)dmp->dm_vars)->cmap, /* destination */
d1141 5
a1145 5
			       ((struct ogl_vars *)dmp->dm_vars)->cmap)){
	  glXGetConfig(((struct ogl_vars *)dmp->dm_vars)->dpy, maxvip, GLX_DEPTH_SIZE,
		       &((struct ogl_vars *)dmp->dm_vars)->mvars.depth);
	  if (((struct ogl_vars *)dmp->dm_vars)->mvars.depth > 0)
	    ((struct ogl_vars *)dmp->dm_vars)->mvars.zbuf = 1;
d1153 2
a1154 2
	  XFreeColormap(((struct ogl_vars *)dmp->dm_vars)->dpy,
			((struct ogl_vars *)dmp->dm_vars)->cmap);
d1175 1
a1175 1
 *			O G L _ C O N F I G U R E _ W I N D O W _ S H A P E
d1192 1
a1192 1
  if (((struct ogl_vars *)dmp->dm_vars)->mvars.debug)
d1195 2
a1196 2
  XGetWindowAttributes( ((struct ogl_vars *)dmp->dm_vars)->dpy,
			((struct ogl_vars *)dmp->dm_vars)->win, &xwa );
d1207 1
a1207 1
  if( ((struct ogl_vars *)dmp->dm_vars)->mvars.zbuffer_on )
a1211 3
#if 0
  glDrawBuffer(GL_FRONT_AND_BACK);

d1213 1
a1213 9
  if (((struct ogl_vars *)dmp->dm_vars)->mvars.zbuffer_on)
    glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  else
    glClear( GL_COLOR_BUFFER_BIT);

  if (((struct ogl_vars *)dmp->dm_vars)->mvars.doublebuffer)
    glDrawBuffer(GL_BACK);
  else
    glDrawBuffer(GL_FRONT);
a1214 6
  /*CJXX*/
  glFlush();
#else
  glClearColor(0.0, 0.0, 0.0, 0.0);
  glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
#endif
d1227 3
a1229 3
  if (((struct ogl_vars *)dmp->dm_vars)->fontstruct == NULL) {
    if ((((struct ogl_vars *)dmp->dm_vars)->fontstruct =
	 XLoadQueryFont(((struct ogl_vars *)dmp->dm_vars)->dpy,
d1232 2
a1233 2
      if ((((struct ogl_vars *)dmp->dm_vars)->fontstruct =
	   XLoadQueryFont(((struct ogl_vars *)dmp->dm_vars)->dpy,
d1240 2
a1241 2
    glXUseXFont( ((struct ogl_vars *)dmp->dm_vars)->fontstruct->fid,
		 0, 127, ((struct ogl_vars *)dmp->dm_vars)->fontOffset);
d1249 2
a1250 2
    if (((struct ogl_vars *)dmp->dm_vars)->fontstruct->per_char->width != 5) {
      if ((newfontstruct = XLoadQueryFont(((struct ogl_vars *)dmp->dm_vars)->dpy,
d1252 5
a1256 5
	XFreeFont(((struct ogl_vars *)dmp->dm_vars)->dpy,
		  ((struct ogl_vars *)dmp->dm_vars)->fontstruct);
	((struct ogl_vars *)dmp->dm_vars)->fontstruct = newfontstruct;
	glXUseXFont( ((struct ogl_vars *)dmp->dm_vars)->fontstruct->fid,
		     0, 127, ((struct ogl_vars *)dmp->dm_vars)->fontOffset);
d1260 2
a1261 2
    if (((struct ogl_vars *)dmp->dm_vars)->fontstruct->per_char->width != 6){
      if ((newfontstruct = XLoadQueryFont(((struct ogl_vars *)dmp->dm_vars)->dpy,
d1263 5
a1267 5
	XFreeFont(((struct ogl_vars *)dmp->dm_vars)->dpy,
		  ((struct ogl_vars *)dmp->dm_vars)->fontstruct);
	((struct ogl_vars *)dmp->dm_vars)->fontstruct = newfontstruct;
	glXUseXFont( ((struct ogl_vars *)dmp->dm_vars)->fontstruct->fid,
		     0, 127, ((struct ogl_vars *)dmp->dm_vars)->fontOffset);
d1271 2
a1272 2
    if (((struct ogl_vars *)dmp->dm_vars)->fontstruct->per_char->width != 7){
      if ((newfontstruct = XLoadQueryFont(((struct ogl_vars *)dmp->dm_vars)->dpy,
d1274 5
a1278 5
	XFreeFont(((struct ogl_vars *)dmp->dm_vars)->dpy,
		  ((struct ogl_vars *)dmp->dm_vars)->fontstruct);
	((struct ogl_vars *)dmp->dm_vars)->fontstruct = newfontstruct;
	glXUseXFont( ((struct ogl_vars *)dmp->dm_vars)->fontstruct->fid,
		     0, 127, ((struct ogl_vars *)dmp->dm_vars)->fontOffset);
d1282 2
a1283 2
    if (((struct ogl_vars *)dmp->dm_vars)->fontstruct->per_char->width != 8){
      if ((newfontstruct = XLoadQueryFont(((struct ogl_vars *)dmp->dm_vars)->dpy,
d1285 5
a1289 5
	XFreeFont(((struct ogl_vars *)dmp->dm_vars)->dpy,
		  ((struct ogl_vars *)dmp->dm_vars)->fontstruct);
	((struct ogl_vars *)dmp->dm_vars)->fontstruct = newfontstruct;
	glXUseXFont( ((struct ogl_vars *)dmp->dm_vars)->fontstruct->fid,
		     0, 127, ((struct ogl_vars *)dmp->dm_vars)->fontOffset);
d1293 2
a1294 2
    if (((struct ogl_vars *)dmp->dm_vars)->fontstruct->per_char->width != 9){
      if ((newfontstruct = XLoadQueryFont(((struct ogl_vars *)dmp->dm_vars)->dpy,
d1296 5
a1300 5
	XFreeFont(((struct ogl_vars *)dmp->dm_vars)->dpy,
		  ((struct ogl_vars *)dmp->dm_vars)->fontstruct);
	((struct ogl_vars *)dmp->dm_vars)->fontstruct = newfontstruct;
	glXUseXFont( ((struct ogl_vars *)dmp->dm_vars)->fontstruct->fid,
		     0, 127, ((struct ogl_vars *)dmp->dm_vars)->fontOffset);
d1310 1
a1310 1
  if (((struct ogl_vars *)dmp->dm_vars)->mvars.debug)
d1313 1
a1313 1
  if (!((struct ogl_vars *)dmp->dm_vars)->mvars.lighting_on) {
d1345 1
a1345 1
  if (((struct ogl_vars *)dmp->dm_vars)->mvars.debug)
d1348 1
a1348 1
  if( ((struct ogl_vars *)dmp->dm_vars)->mvars.zbuf == 0 ) {
d1351 1
a1351 1
    ((struct ogl_vars *)dmp->dm_vars)->mvars.zbuffer_on = 0;
d1354 1
a1354 1
  if (((struct ogl_vars *)dmp->dm_vars)->mvars.zbuffer_on)  {
d1367 1
a1367 1
  if (((struct ogl_vars *)dmp->dm_vars)->mvars.debug)
d1370 3
a1372 3
  if (!glXMakeCurrent(((struct ogl_vars *)dmp->dm_vars)->dpy,
		      ((struct ogl_vars *)dmp->dm_vars)->win,
		      ((struct ogl_vars *)dmp->dm_vars)->glxc)){
d1386 1
a1386 1
  if (((struct ogl_vars *)dmp->dm_vars)->mvars.debug)
d1398 1
a1398 1
  if (((struct ogl_vars *)dmp->dm_vars)->mvars.debug)
d1411 1
a1411 1
  if (((struct ogl_vars *)dmp->dm_vars)->mvars.debug)
@


1.27
log
@Added a diagnostic
@
text
@a180 1
  XVisualInfo *vip;
d363 2
a364 2
  if((vip=ogl_set_visual(dmp,
			 ((struct ogl_vars *)dmp->dm_vars)->xtkwin))==NULL){
d371 2
d385 2
a386 1
       glXCreateContext(((struct ogl_vars *)dmp->dm_vars)->dpy, vip, 0,
@


1.26
log
@*- query for GLX extension
*- name changes and cleanup
@
text
@d785 2
@


1.25
log
@*- change ogl_drawVertex2D to ogl_drawPoint2D
*- mods to hide dm-ogl's use of display lists for fonts
@
text
@d68 3
a70 5
void	ogl_configure_window_shape();
void    ogl_establish_perspective();
void    ogl_set_perspective();
void	ogl_establish_lighting();
void	ogl_establish_zbuffer();
a140 2
int perspective_table[] = {
	30, 45, 60, 90 };
d143 1
d161 1
a161 1
ogl_do_fog(dmp)
a191 1
  struct bu_vls top_vls;
a193 1
  fastf_t tmp_vp;
a199 3
  *dmp = dm_ogl; /* struct copy */
  dmp->dm_vp = &tmp_vp;

d206 2
a207 1
  dmp->dm_vars = (genptr_t)bu_calloc(1, sizeof(struct ogl_vars), "ogl_open: ogl_vars");
d213 3
d221 1
a221 1
  i = dm_process_options(dmp, &init_proc_vls, --argc, ++argv);
a241 1
  ((struct ogl_vars *)dmp->dm_vars)->perspective_angle = 3;
a248 1
  ((struct ogl_vars *)dmp->dm_vars)->mvars.dummy_perspective = 1;
d259 1
a259 1
    bu_vls_free(&str);
d264 10
a297 1
  bu_vls_init(&top_vls);
a305 1
    bu_vls_printf(&top_vls, "%S", &dmp->dm_pathName);
a311 1
       bu_vls_strcpy(&top_vls, ".");
d313 3
d320 1
a322 2
     bu_vls_free(&top_vls);

d333 1
d347 1
a371 4
#if 0
  Tk_MoveToplevelWindow(((struct ogl_vars *)dmp->dm_vars)->xtkwin,
			1276 - 976, 0);
#endif
d470 1
a470 1
  /* display list (fontOffset + char) will displays a given ASCII char */
d490 1
a490 1
  ogl_configure_window_shape(dmp);
d605 1
a605 1
      glFogi(GL_FOG_MODE, ((struct ogl_vars *)dmp->dm_vars)->mvars.perspective_mode ?
a758 1

d937 3
d956 3
d993 3
d1178 1
a1178 1
ogl_configure_window_shape(dmp)
d1186 3
d1202 1
a1202 1
    ogl_establish_zbuffer(dmp);
d1204 1
a1204 1
  ogl_establish_lighting(dmp);
d1318 1
a1318 1
ogl_establish_lighting(dmp)
d1321 3
d1353 1
a1353 1
ogl_establish_zbuffer(dmp)
d1356 3
a1372 49
void
ogl_establish_perspective(dmp)
struct dm *dmp;
{
  struct bu_vls vls;

  bu_vls_init(&vls);
  bu_vls_printf( &vls, "set perspective %d\n",
		 ((struct ogl_vars *)dmp->dm_vars)->mvars.perspective_mode ?
		 perspective_table[((struct ogl_vars *)dmp->dm_vars)->perspective_angle] :
		 -1 );
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
}

/*
  This routine will toggle the perspective_angle if the
  dummy_perspective value is 0 or less. Otherwise, the
  perspective_angle is set to the value of (dummy_perspective - 1).
*/
void
ogl_set_perspective(dmp)
struct dm *dmp;
{
  /* set perspective matrix */
  if(((struct ogl_vars *)dmp->dm_vars)->mvars.dummy_perspective > 0)
    ((struct ogl_vars *)dmp->dm_vars)->perspective_angle =
      ((struct ogl_vars *)dmp->dm_vars)->mvars.dummy_perspective <= 4 ?
      ((struct ogl_vars *)dmp->dm_vars)->mvars.dummy_perspective - 1: 3;
  else if (--((struct ogl_vars *)dmp->dm_vars)->perspective_angle < 0) /* toggle perspective matrix */
    ((struct ogl_vars *)dmp->dm_vars)->perspective_angle = 3;

  if(((struct ogl_vars *)dmp->dm_vars)->mvars.perspective_mode){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf( &vls, "set perspective %d\n",
		   perspective_table[((struct ogl_vars *)dmp->dm_vars)->perspective_angle] );
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
  }

  /*
     Just in case the "!" is used with the set command. This
     allows us to toggle through more than two values.
   */
  ((struct ogl_vars *)dmp->dm_vars)->mvars.dummy_perspective = 1;
}

d1378 3
d1397 3
d1409 3
d1422 3
@


1.24
log
@some cleanup
@
text
@d92 1
a92 1
static int	ogl_normal(), ogl_newrot();
d94 1
a94 1
static int      ogl_drawVertex2D();
d107 1
a107 1
  ogl_newrot,
d110 1
a110 1
  ogl_drawVertex2D,
d272 1
a272 1
      DisplayWidth(tmp_dpy, DefaultScreen(tmp_dpy)) - 20;
d277 1
a277 1
      DisplayHeight(tmp_dpy, DefaultScreen(tmp_dpy)) - 20;
d477 1
a477 1
  dmp->dm_displaylist = ((struct ogl_vars *)dmp->dm_vars)->fontOffset + 127;
a589 7
#if 0
  if (!((struct ogl_vars *)dmp->dm_vars)->mvars.doublebuffer){
    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  }
#endif

d658 3
a660 1
 *  load new rotation matrix onto top of stack
d663 1
a663 1
ogl_newrot(dmp, mat, which_eye)
d677 1
a677 1
    Tcl_AppendResult(interp, "ogl_newrot()\n", (char *)NULL);
d681 1
a681 1
    bu_vls_printf(&tmp_vls, "newrot matrix = \n");
a725 6
#if 0
  gtmat[1] = *(mptr++) * dmp->dm_aspect;
  gtmat[5] = *(mptr++) * dmp->dm_aspect;
  gtmat[9] = *(mptr++) * dmp->dm_aspect;
  gtmat[13] = *(mptr++) * dmp->dm_aspect;
#else
a729 1
#endif
d760 1
a760 1
 *  			O G L _ O B J E C T
a761 5
 *  Set up for an object, transformed as indicated, and with an
 *  object center as specified.  The ratio of object to screen size
 *  is passed in as a convienience.
 *
 *  Returns 0 if object could be drawn, !0 if object was omitted.
a830 1
 * Turns off windowing.
d933 1
a933 1
ogl_drawVertex2D(dmp, x, y)
d1004 1
d1014 3
a1016 2
ogl_setWinBounds(w)
register int w[];
d1407 1
a1407 1
GLuint list;
d1417 1
a1417 1
  glNewList(list, GL_COMPILE);
d1432 1
a1432 1
GLuint list;
d1434 1
a1434 1
  glCallList(list);
d1441 2
a1442 2
GLuint list;
GLsizei range;
d1444 1
a1444 1
  glDeleteLists(list, range);
@


1.23
log
@*** empty log message ***
@
text
@a253 1
  ((struct ogl_vars *)dmp->dm_vars)->mvars.linewidth = 1;
@


1.22
log
@*- got rid of eventHandler
*- initialize dm_id (new member of "struct dm")
@
text
@d187 1
a189 1
  int make_square = -1;
@


1.21
log
@add display list support
@
text
@a115 1
  Nu_int0,
d120 1
d178 1
a178 2
ogl_open(eventHandler, argc, argv)
int (*eventHandler)();
a205 1
  dmp->dm_eventHandler = eventHandler;
a258 7
#if 0
  if(BU_LIST_IS_EMPTY(&head_ogl_vars.l))
#else
  if(dmp->dm_eventHandler != DM_EVENT_HANDLER_NULL)
#endif
    Tk_CreateGenericHandler(dmp->dm_eventHandler, (ClientData)DM_TYPE_OGL);

d376 1
a551 3

    if(BU_LIST_IS_EMPTY(&head_ogl_vars.l))
      Tk_DeleteGenericHandler(dmp->dm_eventHandler, (ClientData)DM_TYPE_OGL);
@


1.20
log
@rm ogl_irisX2ged() and ogl_irisY2ged()
@
text
@a96 1
static unsigned ogl_cvtvecs(), ogl_load();
d98 3
a113 2
  ogl_cvtvecs,
  ogl_load,
d117 6
a122 1
  0,				/* no displaylist */
a136 1
  0,
d485 3
d497 1
a497 1
  /* do viewport, ortho commands and initialize font*/
d667 5
d716 1
a716 1
    ogl_drawString2D( "R", 2020, 0, 0, DM_RED );
d795 1
a795 1
ogl_drawVList( dmp, vp, m )
a797 1
fastf_t *m;
d799 1
a799 3
  register struct rt_vlist	*tvp;
  register float	*gtvec;
  char	gtbuf[16+3*sizeof(double)];
a805 14
  /*
   *  It is claimed that the "dancing vector disease" of the
   *  4D GT processors is due to the array being passed to v3f()
   *  not being quad-word aligned (16-byte boundary).
   *  This hack ensures that the buffer has this alignment.
   *  Note that this requires gtbuf to be 16 bytes longer than needed.
   */
  gtvec = (float *)((((long)gtbuf)+15) & (~0xF));

#if 0
  if (illum && ((struct ogl_vars *)dmp->dm_vars)->mvars.cueing_on)
    glDisable(GL_FOG);	
#endif

a822 4
      case RT_VLIST_LINE_DRAW:
	/* Draw line */
	glVertex3dv( *pt );
	break;
d829 1
a829 2
	VMOVE( gtvec, *pt );
	glNormal3fv(gtvec);
d831 1
a832 3
	/* Polygon Move */
	glVertex3dv( *pt );
	break;
a833 1
	/* Polygon Draw */
d844 1
a844 2
	VMOVE( gtvec, *pt );
	glNormal3fv(gtvec);
a851 6
#if 0
  if (illum && ((struct ogl_vars *)dmp->dm_vars)->mvars.cueing_on){
    glEnable(GL_FOG);
  }
#endif

a1029 27

/* ARGSUSED */
static unsigned
ogl_cvtvecs( dmp, sp )
struct dm *dmp;
struct solid *sp;
{
	return( 0 );
}

/*
 * Loads displaylist
 */
static unsigned
ogl_load( dmp, addr, count )
struct dm *dmp;
unsigned addr, count;
{
  struct bu_vls tmp_vls;

  bu_vls_init(&tmp_vls);
  bu_vls_printf(&tmp_vls, "ogl_load(x%x, %d.)\n", addr, count );
  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
  bu_vls_free(&tmp_vls);
  return( 0 );
}

d1049 1
a1049 1
#define OGL_DO_STEREO 0
d1073 1
a1073 1
  if( mged_variables.eye_sep_dist )  {
a1158 3
#if OGL_DO_STEREO
	  ((struct ogl_vars *)dmp->dm_vars)->stereo_is_on = m_stereo;
#endif
d1212 1
d1215 1
d1376 1
d1430 44
@


1.19
log
@mods to ogl_setLineAttr
@
text
@a72 2
int     ogl_irisX2ged();
int     ogl_irisY2ged();
a164 26
}

/*
 *  Mouse coordinates are in absolute screen space, not relative to
 *  the window they came from.  Convert to window-relative,
 *  then to MGED-style +/-2048 range.
 */
int
ogl_irisX2ged(dmp, x, use_aspect)
struct dm *dmp;
register int x;
int use_aspect;
{
  if(use_aspect)
    return ((x/(double)dmp->dm_width - 0.5) /
	    dmp->dm_aspect * 4095);
  else
    return ((x/(double)dmp->dm_width - 0.5) * 4095);
}

int
ogl_irisY2ged(dmp, y)
struct dm *dmp;
register int y;
{
  return ((0.5 - y/(double)dmp->dm_height) * 4095);
@


1.18
log
@*- changed Ogl_ prefix to ogl_
*- mods to reflect change in "struct dm" --- added dm_type
                                         removed dm_open, dm_initWinProc
*- modify the handling of graphics buffers
@
text
@d127 2
d1060 1
a1060 1
ogl_setLineAttr(dmp, width, dashed)
d1063 1
a1063 1
int dashed;
d1065 3
a1067 1
  ((struct ogl_vars *)dmp->dm_vars)->mvars.linewidth = width;
d1070 1
a1070 1
  if( dashed )
@


1.17
log
@some cleanup
@
text
@d68 7
a74 7
void	Ogl_configure_window_shape();
void    Ogl_establish_perspective();
void    Ogl_set_perspective();
void	Ogl_establish_lighting();
void	Ogl_establish_zbuffer();
int     Ogl_irisX2ged();
int     Ogl_irisY2ged();
d76 1
a76 1
static XVisualInfo *Ogl_set_visual();
d90 11
a100 11
struct dm	*Ogl_open();
static int	Ogl_close();
static int	Ogl_drawBegin();
static int      Ogl_drawEnd();
static int	Ogl_normal(), Ogl_newrot();
static int	Ogl_drawString2D(), Ogl_drawLine2D();
static int      Ogl_drawVertex2D();
static int	Ogl_drawVList();
static int      Ogl_setColor(), Ogl_setLineAttr();
static unsigned Ogl_cvtvecs(), Ogl_load();
static int	Ogl_setWinBounds(), Ogl_debug();
d103 15
a117 16
  Ogl_open,
  Ogl_close,
  Ogl_drawBegin,
  Ogl_drawEnd,
  Ogl_normal,
  Ogl_newrot,
  Ogl_drawString2D,
  Ogl_drawLine2D,
  Ogl_drawVertex2D,
  Ogl_drawVList,
  Ogl_setColor,
  Ogl_setLineAttr,
  Ogl_cvtvecs,
  Ogl_load,
  Ogl_setWinBounds,
  Ogl_debug,
d121 3
a123 1
  "ogl", "X Windows with OpenGL graphics",
a132 1
  0,
d160 1
a160 1
Ogl_do_fog(dmp)
d173 1
a173 1
Ogl_irisX2ged(dmp, x, use_aspect)
d186 1
a186 1
Ogl_irisY2ged(dmp, y)
d200 1
a200 1
Ogl_open(eventHandler, argc, argv)
d219 1
d238 1
a238 1
  dmp->dm_vars = (genptr_t)bu_calloc(1, sizeof(struct ogl_vars), "Ogl_init: ogl_vars");
d240 1
a240 1
    bu_free(dmp, "Ogl_open: dmp");
d247 1
a247 1
  bu_vls_init(&dmp->dm_initWinProc);
d249 1
a249 5
  i = dm_process_options(dmp,
			 &dmp->dm_width,
			 &dmp->dm_height,
			 argc,
			 argv);
d263 2
a264 2
  if(bu_vls_strlen(&dmp->dm_initWinProc) == 0)
    bu_vls_strcpy(&dmp->dm_initWinProc, "bind_dm");
d292 1
a292 1
  /* this is important so that Ogl_configure_notify knows to set
d298 1
a298 1
    (void)Ogl_close(dmp);
d362 1
a362 1
    (void)Ogl_close(dmp);
d371 1
a371 1
		&dmp->dm_initWinProc,
d376 1
a376 1
    (void)Ogl_close(dmp);
d380 1
d391 1
a391 1
  if((vip=Ogl_set_visual(dmp,
d393 1
a393 1
    Tcl_AppendResult(interp, "Ogl_open: Can't get an appropriate visual.\n",
d395 1
a395 1
    (void)Ogl_close(dmp);
d416 1
a416 1
    Tcl_AppendResult(interp, "Ogl_open: couldn't create glXContext.\n",
d418 1
a418 1
    (void)Ogl_close(dmp);
d495 2
a496 2
    Tcl_AppendResult(interp, "Ogl_open: Couldn't make context current\n", (char *)NULL);
    (void)Ogl_close(dmp);
d503 1
a503 1
    (void)Ogl_close(dmp);
d507 9
d517 1
a517 1
  Ogl_configure_window_shape(dmp);
d557 1
a557 1
Ogl_close(dmp)
d590 2
a591 3
  bu_vls_free(&dmp->dm_initWinProc);
  bu_free(dmp->dm_vars, "Ogl_close: ogl_vars");
  bu_free(dmp, "Ogl_close: dmp");
d602 1
a602 1
Ogl_drawBegin(dmp)
d611 1
a611 1
    Tcl_AppendResult(interp, "Ogl_drawBegin\n", (char *)NULL);
d617 1
a617 1
 		     "Ogl_drawBegin: Couldn't make context current\n", (char *)NULL);
d621 1
d626 1
d657 1
a657 1
Ogl_drawEnd(dmp)
d661 1
a661 1
    Tcl_AppendResult(interp, "Ogl_drawEnd\n", (char *)NULL);
a670 3
  /* Prevent lag between events and updates */
  XSync(((struct ogl_vars *)dmp->dm_vars)->dpy, 0);

d694 1
a694 1
Ogl_newrot(dmp, mat, which_eye)
d708 1
a708 1
    Tcl_AppendResult(interp, "Ogl_newrot()\n", (char *)NULL);
d730 1
a730 1
    Ogl_drawString2D( "R", 2020, 0, 0, DM_RED );
d809 1
a809 1
Ogl_drawVList( dmp, vp, m )
d821 1
a821 1
    Tcl_AppendResult(interp, "Ogl_drawVList()\n", (char *)NULL);
d909 1
a909 1
Ogl_normal(dmp)
d915 1
a915 1
    Tcl_AppendResult(interp, "Ogl_normal\n", (char *)NULL);
d941 1
a941 1
Ogl_drawString2D( dmp, str, x, y, size, use_aspect )
d949 1
a949 1
    Tcl_AppendResult(interp, "Ogl_drawString2D()\n", (char *)NULL);
d968 1
a968 1
Ogl_drawLine2D( dmp, x1, y1, x2, y2 )
d976 1
a976 1
    Tcl_AppendResult(interp, "Ogl_drawLine2D()\n", (char *)NULL);
d1009 1
a1009 1
Ogl_drawVertex2D(dmp, x, y)
d1022 1
a1022 1
Ogl_setColor(dmp, r, g, b, strict)
d1058 1
a1058 1
Ogl_setLineAttr(dmp, width, dashed)
d1077 1
a1077 1
Ogl_cvtvecs( dmp, sp )
d1088 1
a1088 1
Ogl_load( dmp, addr, count )
d1095 1
a1095 1
  bu_vls_printf(&tmp_vls, "Ogl_load(x%x, %d.)\n", addr, count );
d1103 1
a1103 1
Ogl_debug(dmp, lvl)
d1114 1
a1114 1
Ogl_setWinBounds(w)
d1125 1
a1125 1
Ogl_set_visual(dmp, tkwin)
d1271 1
a1271 1
Ogl_configure_window_shape(dmp)
d1290 1
a1290 1
    Ogl_establish_zbuffer(dmp);
d1292 1
a1292 1
  Ogl_establish_lighting(dmp);
d1310 3
d1406 1
a1406 1
Ogl_establish_lighting(dmp)
d1418 1
a1418 1
    /* light positions specified in Ogl_newrot */
d1438 1
a1438 1
Ogl_establish_zbuffer(dmp)
d1455 1
a1455 1
Ogl_establish_perspective(dmp)
d1475 1
a1475 1
Ogl_set_perspective(dmp)
@


1.16
log
@added some error checking; modified use of BU_GETSTRUCT
@
text
@d237 2
a238 2
  BU_GETSTRUCT(dmp->dm_vars, ogl_vars);
  if(dmp->dm_vars == (struct ogl_vars *)NULL){
d1214 1
a1214 1
		       /* low - 0,  high - CMAP_BASE,  use XAllocColor */
d1246 1
a1246 1
    } else
@


1.15
log
@*** empty log message ***
@
text
@d223 5
a227 2
  dmp = BU_GETSTRUCT(dmp, dm);
  *dmp = dm_ogl;
d237 2
a238 2
  dmp->dm_vars = bu_calloc(1, sizeof(struct ogl_vars), "Ogl_init: ogl_vars");
  if(!dmp->dm_vars){
@


1.14
log
@*- remove call to Ogl_load_startup
*- call _init_dm with 2 parameters
@
text
@a199 1
#if DO_NEW_LIBDM_OPEN
a201 4
#else
Ogl_open(dmp, argc, argv)
struct dm *dmp;
#endif
a219 1
#if DO_NEW_LIBDM_OPEN
a226 1
#endif
@


1.13
log
@mods to have display manager to allocate its own memory
@
text
@a75 1
static int     Ogl_load_startup();
d236 4
a239 2
  if(!count)
    (void)Ogl_load_startup(dmp);
d357 2
a375 1
#if 1
d377 1
a377 1
  bu_vls_printf(&str, "_new_init_dm %S %S %S\n",
a378 1
		&top_vls,
a387 1
  bu_vls_free(&top_vls);
a390 11
#else
  bu_vls_init(&str);
  bu_vls_printf(&str, "_init_dm %s %s\n",
		bu_vls_addr(&dmp->dm_initWinProc),
		bu_vls_addr(&dmp->dm_pathName));
  if(Tcl_Eval(interp, bu_vls_addr(&str)) == TCL_ERROR){
    bu_vls_free(&str);
    (void)Ogl_close(dmp);
    return DM_NULL;
  }
  bu_vls_free(&str);
a391 4
  ((struct ogl_vars *)dmp->dm_vars)->dpy =
    Tk_Display(((struct ogl_vars *)dmp->dm_vars)->xtkwin);
#endif

a546 14
static int
Ogl_load_startup(dmp)
struct dm *dmp;
{
  char *filename;

  bzero((void *)&head_ogl_vars, sizeof(struct ogl_vars));
  BU_LIST_INIT( &head_ogl_vars.l );

  if((filename = getenv("DM_OGL_RCFILE")) != (char *)NULL )
    return Tcl_EvalFile(interp, filename);

  return TCL_OK;
}
@


1.12
log
@calling _init_dm instead of init_dm_win
@
text
@d41 5
d91 1
a91 1
static int	Ogl_open();
d124 5
a128 1
  0,				/* mem map */
d133 1
d174 1
a174 1
Ogl_irisX2ged(dmp, x)
d177 1
d179 5
a183 1
  return ((x/(double)((struct ogl_vars *)dmp->dm_vars)->width - 0.5) * 4095);
d191 1
a191 1
  return ((0.5 - y/(double)((struct ogl_vars *)dmp->dm_vars)->height) * 4095);
d200 5
a204 1
static int
d207 1
d218 1
d224 1
d226 9
d240 17
a256 3
  bu_vls_init_if_uninit(&dmp->dm_pathName);
  bu_vls_init_if_uninit(&dmp->dm_initWinProc);
  i = dm_process_options(dmp, argc, argv);
d258 11
a268 1
     bu_vls_printf(&dmp->dm_pathName, ".dm_ogl%d", count++);
d270 1
a270 1
    bu_vls_strcpy(&dmp->dm_initWinProc, "bind_dm_win");
d272 1
a272 1
  dmp->dm_vars = bu_calloc(1, sizeof(struct ogl_vars), "Ogl_init: ogl_vars");
d277 1
a277 1
  ((struct ogl_vars *)dmp->dm_vars)->aspect = 1.0;
d279 1
a279 1
  /* initialize the modifiable variables */
d289 1
d291 3
a297 3
  if(!dmp->dm_vars)
    return TCL_ERROR;

d302 1
a302 1
  if((tmp_dpy = XOpenDisplay(dmp->dm_dname)) == NULL){
d304 2
a305 1
    return TCL_ERROR;
d308 21
a328 13
  ((struct ogl_vars *)dmp->dm_vars)->width =
    DisplayWidth(tmp_dpy, DefaultScreen(tmp_dpy)) - 20;
  ((struct ogl_vars *)dmp->dm_vars)->height =
    DisplayHeight(tmp_dpy, DefaultScreen(tmp_dpy)) - 20;

  /* Make window square */
  if(((struct ogl_vars *)dmp->dm_vars)->height <
     ((struct ogl_vars *)dmp->dm_vars)->width)
    ((struct ogl_vars *)dmp->dm_vars)->width =
      ((struct ogl_vars *)dmp->dm_vars)->height;
  else
    ((struct ogl_vars *)dmp->dm_vars)->height =
      ((struct ogl_vars *)dmp->dm_vars)->width;
d332 29
a360 4
  /* Make xtkwin a toplevel window */
  ((struct ogl_vars *)dmp->dm_vars)->xtkwin =
    Tk_CreateWindowFromPath(interp, tkwin,
			    bu_vls_addr(&dmp->dm_pathName), dmp->dm_dname);
d366 18
a383 1
    return TCL_ERROR;
d386 6
d398 2
a399 1
    return TCL_ERROR;
d405 1
d408 2
a409 2
		     ((struct ogl_vars *)dmp->dm_vars)->width,
		     ((struct ogl_vars *)dmp->dm_vars)->height);
d416 2
a417 1
    return TCL_ERROR;
d439 2
a440 1
    return TCL_ERROR;
d517 2
a518 1
    return TCL_ERROR;
d524 2
a525 1
    return TCL_ERROR;
d548 1
a548 1
  glOrtho(-1.0, 1.0, -1.0, 1.0, 0.0, 2.0);
d559 1
a559 1
  return TCL_OK;
d613 4
d618 1
d780 4
a783 9
  gtmat[0] = *(mptr++) * ((struct ogl_vars *)dmp->dm_vars)->aspect;
  gtmat[4] = *(mptr++) * ((struct ogl_vars *)dmp->dm_vars)->aspect;
  gtmat[8] = *(mptr++) * ((struct ogl_vars *)dmp->dm_vars)->aspect;
  gtmat[12] = *(mptr++) * ((struct ogl_vars *)dmp->dm_vars)->aspect;

  gtmat[1] = *(mptr++) * ((struct ogl_vars *)dmp->dm_vars)->aspect;
  gtmat[5] = *(mptr++) * ((struct ogl_vars *)dmp->dm_vars)->aspect;
  gtmat[9] = *(mptr++) * ((struct ogl_vars *)dmp->dm_vars)->aspect;
  gtmat[13] = *(mptr++) * ((struct ogl_vars *)dmp->dm_vars)->aspect;
d785 12
d969 1
a969 1
Ogl_drawString2D( dmp, str, x, y, size )
d974 1
d979 5
a983 2
	
  glRasterPos2f(GED2IRIS(x),  GED2IRIS(y));
d1309 2
a1310 2
  ((struct ogl_vars *)dmp->dm_vars)->height = xwa.height;
  ((struct ogl_vars *)dmp->dm_vars)->width = xwa.width;
d1312 4
a1315 4
  glViewport(0,  0, (((struct ogl_vars *)dmp->dm_vars)->width),
	     (((struct ogl_vars *)dmp->dm_vars)->height));
  glScissor(0,  0, (((struct ogl_vars *)dmp->dm_vars)->width)+1,
	    (((struct ogl_vars *)dmp->dm_vars)->height)+1);
d1345 3
a1347 3
  ((struct ogl_vars *)dmp->dm_vars)->aspect =
    (fastf_t)((struct ogl_vars *)dmp->dm_vars)->height/
    (fastf_t)((struct ogl_vars *)dmp->dm_vars)->width;
d1372 1
a1372 1
  if (((struct ogl_vars *)dmp->dm_vars)->width < 582) {
d1383 1
a1383 1
  } else if (((struct ogl_vars *)dmp->dm_vars)->width < 679) {
d1394 1
a1394 1
  } else if (((struct ogl_vars *)dmp->dm_vars)->width < 776) {
d1405 1
a1405 1
  } else if (((struct ogl_vars *)dmp->dm_vars)->width < 873) {
@


1.11
log
@Widened to long
@
text
@d280 1
a280 1
  bu_vls_printf(&str, "init_dm_win %s %s\n",
@


1.10
log
@*- mods to Ogl_drawVertex2D
*- mods to use libbn directly
@
text
@d727 1
a727 1
  gtvec = (float *)((((int)gtbuf)+15) & (~0xF));
@


1.9
log
@change interface to Ogl_open
,.
@
text
@d40 2
d46 1
d62 1
d438 1
a438 1
		
d648 1
a648 1
    mat_idn( nozclip );
d650 1
a650 1
    mat_mul( newm, nozclip, mat );
d790 3
a792 3
	if (illum && ((struct ogl_vars *)dmp->dm_vars)->mvars.cueing_on){
		glEnable(GL_FOG);
	}
d795 1
a795 1
	return(1);	/* OK */
d848 1
a848 1
  glRasterPos2f( GED2IRIS(x),  GED2IRIS(y));
d894 2
a895 2
  glVertex2f( GED2IRIS(x1),  GED2IRIS(y1));
  glVertex2f( GED2IRIS(x2),  GED2IRIS(y2));
d906 5
a910 1
  return Ogl_drawLine2D(dmp, x, y, x+1, y+1);
@


1.8
log
@checkin for the week
@
text
@a47 1
extern struct solid HeadSolid;
a81 1
static int      Ogl_init();
a94 1
  Ogl_init,
d119 1
d175 6
d182 1
a182 1
Ogl_init(dmp, argc, argv)
d187 13
a199 1
  static count = 0;
d205 7
a211 1
  bu_vls_printf(&dmp->dm_pathName, ".dm_ogl%d", count++);
d223 3
a225 3
  ((struct ogl_vars *)dmp->dm_vars)->mvars.zclipping_on = 1; /* Z Clipping flag */
  ((struct ogl_vars *)dmp->dm_vars)->mvars.zbuffer_on = 1; /* Hardware Z buffer is on */
  ((struct ogl_vars *)dmp->dm_vars)->mvars.linewidth = 1; /* Line drawing width */
d235 2
a236 36
  if(dmp->dm_vars)
    return TCL_OK;

  return TCL_ERROR;
}

/*
 *			O G L _ O P E N
 *
 * Fire up the display manager, and the display processor.
 *
 */
static int
Ogl_open(dmp)
struct dm *dmp;
{
  XGCValues gcv;
  XColor a_color;
  Visual *a_visual;
  int a_screen, num, i, success;
  Colormap  a_cmap;
  XVisualInfo *vip;
  int dsize, use, dbfr, rgba, red, blue, green, alpha, index;
  GLfloat backgnd[4];
  long supplied;
  int j, k;
  int ndevices;
  int nclass = 0;
  XDeviceInfoPtr olist, list;
  XDevice *dev;
  XEventClass e_class[15];
  XInputClassInfo *cip;
  struct bu_vls str;
  Display *tmp_dpy;

  bu_vls_init(&str);
d247 4
a250 4
  ((struct ogl_vars *)dmp->dm_vars)->width = DisplayWidth(tmp_dpy,
							   DefaultScreen(tmp_dpy)) - 20;
  ((struct ogl_vars *)dmp->dm_vars)->height = DisplayHeight(tmp_dpy,
							     DefaultScreen(tmp_dpy)) - 20;
d253 4
a256 2
  if(((struct ogl_vars *)dmp->dm_vars)->height < ((struct ogl_vars *)dmp->dm_vars)->width)
    ((struct ogl_vars *)dmp->dm_vars)->width = ((struct ogl_vars *)dmp->dm_vars)->height;
d258 2
a259 1
    ((struct ogl_vars *)dmp->dm_vars)->height = ((struct ogl_vars *)dmp->dm_vars)->width;
d265 2
a266 1
    Tk_CreateWindowFromPath(interp, tkwin, bu_vls_addr(&dmp->dm_pathName), dmp->dm_dname);
a267 1
  /* Open the display - XXX see what NULL does now */
d269 2
a270 1
    Tcl_AppendResult(interp, "dm-Ogl: Failed to open ", bu_vls_addr(&dmp->dm_pathName),
d275 4
a278 3
  bu_vls_strcpy(&str, "init_ogl ");
  bu_vls_printf(&str, "%s\n", bu_vls_addr(&dmp->dm_pathName));

d283 1
d288 4
d293 4
a296 2
  if ((vip=Ogl_set_visual(dmp, ((struct ogl_vars *)dmp->dm_vars)->xtkwin))==NULL){
    Tcl_AppendResult(interp, "Ogl_open: Can't get an appropriate visual.\n", (char *)NULL);
d300 3
a302 8
#if 1
  Tk_GeometryRequest(((struct ogl_vars *)dmp->dm_vars)->xtkwin,
		     ((struct ogl_vars *)dmp->dm_vars)->width,
		     ((struct ogl_vars *)dmp->dm_vars)->height);

  Tk_ResizeWindow(((struct ogl_vars *)dmp->dm_vars)->xtkwin,
		  ((struct ogl_vars *)dmp->dm_vars)->width,
		  ((struct ogl_vars *)dmp->dm_vars)->height);
a303 1
  Tk_MoveToplevelWindow(((struct ogl_vars *)dmp->dm_vars)->xtkwin, 1276 - 976, 0);
a308 2
  a_screen = Tk_ScreenNumber(((struct ogl_vars *)dmp->dm_vars)->xtkwin);

d317 2
a318 1
    Tcl_AppendResult(interp, "Ogl_open: couldn't create glXContext.\n", (char *)NULL);
d327 4
a330 2
  Tcl_AppendResult(interp, "Using ", ((struct ogl_vars *)dmp->dm_vars)->is_direct ?
		   "a direct" : "an indirect", " OpenGL rendering context.\n", (char *)NULL);
d332 2
a333 1
  ogl_ogl_used = (((struct ogl_vars *)dmp->dm_vars)->is_direct || ogl_ogl_used);
d340 2
a341 1
    (XDeviceInfoPtr) XListInputDevices (((struct ogl_vars *)dmp->dm_vars)->dpy, &ndevices);
d352 2
a353 1
	  Tcl_AppendResult(interp, "Glx_open: Couldn't open the dials+buttons\n",
d463 2
a464 1
  if(((struct ogl_vars *)dmp->dm_vars)->glxc != NULL){
d466 5
a470 5
    glDrawBuffer(GL_FRONT);
    glClearColor(0.0, 0.0, 0.0, 0.0);
    /*	glClearDepth(0.0);*/
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glDrawBuffer(GL_BACK);
d472 13
a484 2
    glXDestroyContext(((struct ogl_vars *)dmp->dm_vars)->dpy,
		      ((struct ogl_vars *)dmp->dm_vars)->glxc);
a486 3
  if(((struct ogl_vars *)dmp->dm_vars)->xtkwin != NULL)
    Tk_DestroyWindow(((struct ogl_vars *)dmp->dm_vars)->xtkwin);

a491 3
  if(BU_LIST_IS_EMPTY(&head_ogl_vars.l))
    Tk_DeleteGenericHandler(dmp->dm_eventHandler, (ClientData)DM_TYPE_OGL);

d902 1
a902 1
  return Ogl_drawLine2D(dmp, x, y, x, y);
d917 1
a917 1
    register float material[4];
d922 3
a924 3
      material[0] = 	.2 * ( r / 255.0);
      material[1] = 	.2 * ( g / 255.0);
      material[2] = 	.2 * ( b / 255.0);
d994 2
d1002 1
d1015 1
d1018 3
a1020 2
  int use, rgba, dbfr;
  int tries, baddepth;
d1036 1
d1108 2
a1109 1
	if (Tk_SetWindowVisual(tkwin, maxvip->visual, maxvip->depth,
d1118 3
d1137 3
@


1.7
log
@.
@
text
@a155 11
/* get rid of when no longer needed */
#define USE_RAMP (((struct ogl_vars *)dmp->dm_vars)->mvars.cueing_on || \
		  ((struct ogl_vars *)dmp->dm_vars)->mvars.lighting_on)
#define CMAP_BASE	32
#define CMAP_RAMP_WIDTH	16
#define MAP_ENTRY(x)	( USE_RAMP ? \
			((x) * CMAP_RAMP_WIDTH + CMAP_BASE) : \
			((x) + CMAP_BASE) )

/********************************************************************/

a196 1
  ((struct ogl_vars *)dmp->dm_vars)->ovec = -1;
d1077 20
a1096 5
	/* make sure Tk handles it */
	((struct ogl_vars *)dmp->dm_vars)->cmap =
	  XCreateColormap(((struct ogl_vars *)dmp->dm_vars)->dpy,
			  RootWindow(((struct ogl_vars *)dmp->dm_vars)->dpy,
			  maxvip->screen), maxvip->visual, AllocNone);
@


1.6
log
@remove Ogl_irlimit and Ogl_add_tol, now using
dm_limit and dm_unlimit
@
text
@d16 1
a17 3
#include <stdio.h>
#include <math.h>
#include <termio.h>
a18 4
#include <ctype.h>

#include <sys/types.h>
#include <sys/time.h>
a19 1
#include <X11/X.h>
d28 1
a29 3
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/keysym.h>
a30 3
#include "tcl.h"
#include "tk.h"
#include <X11/extensions/XI.h>
d32 4
a35 1

d38 1
a38 1
#include <gl/device.h>
a43 1
#include "mater.h"
d48 1
d50 2
a51 2
#define VIEWFACTOR      (1/(*dmp->dmr_vp))
#define VIEWSIZE        (2*(*dmp->dmr_vp))
d68 1
a68 3
static void	Ogl_gen_color();
static void     Ogl_colorit();
static void     Ogl_load_startup();
a69 1
static void     print_cmap();
d83 1
a83 1
static int     Ogl_init();
d85 8
a92 7
static void	Ogl_close();
static void     Ogl_input();
static void	Ogl_prolog(), Ogl_epilog();
static void	Ogl_normal(), Ogl_newrot();
static void	Ogl_update();
static void	Ogl_puts(), Ogl_2d_line(), Ogl_light();
static int	Ogl_object();
d94 1
a94 2
static void	Ogl_viewchange(), Ogl_colorchange();
static void	Ogl_window(), Ogl_debug(), Ogl_selectargs();
d98 17
a114 12
  Ogl_open, Ogl_close,
  Ogl_input,
  Ogl_prolog, Ogl_epilog,
  Ogl_normal, Ogl_newrot,
  Ogl_update,
  Ogl_puts, Ogl_2d_line,
  Ogl_light,
  Ogl_object, Ogl_cvtvecs, Ogl_load,
  0,
  Ogl_viewchange,
  Ogl_colorchange,
  Ogl_window, Ogl_debug, 0, 0,
a147 1
/* functions */
a148 8
Ogl_do_linewidth(dmp)
struct dm *dmp;
{
  glLineWidth((GLfloat) ((struct ogl_vars *)dmp->dmr_vars)->mvars.linewidth);
}


void
d153 1
a153 1
	 ((struct ogl_vars *)dmp->dmr_vars)->mvars.fastfog ? GL_FASTEST : GL_NICEST);
d157 2
a158 2
#define USE_RAMP (((struct ogl_vars *)dmp->dmr_vars)->mvars.cueing_on || \
		  ((struct ogl_vars *)dmp->dmr_vars)->mvars.lighting_on)
d177 1
a177 1
  return ((x/(double)((struct ogl_vars *)dmp->dmr_vars)->width - 0.5) * 4095);
d185 1
a185 1
  return ((0.5 - y/(double)((struct ogl_vars *)dmp->dmr_vars)->height) * 4095);
d198 1
a198 1
    Ogl_load_startup(dmp);
d200 1
a200 1
  bu_vls_printf(&dmp->dmr_pathName, ".dm_ogl%d", count++);
d202 7
a208 7
  dmp->dmr_vars = bu_calloc(1, sizeof(struct ogl_vars), "Ogl_init: ogl_vars");
  ((struct ogl_vars *)dmp->dmr_vars)->devmotionnotify = LASTEvent;
  ((struct ogl_vars *)dmp->dmr_vars)->devbuttonpress = LASTEvent;
  ((struct ogl_vars *)dmp->dmr_vars)->devbuttonrelease = LASTEvent;
  ((struct ogl_vars *)dmp->dmr_vars)->perspective_angle = 3;
  ((struct ogl_vars *)dmp->dmr_vars)->aspect = 1.0;
  ((struct ogl_vars *)dmp->dmr_vars)->ovec = -1;
d211 8
a218 7
  ((struct ogl_vars *)dmp->dmr_vars)->mvars.cueing_on = 1; /* Depth cueing flag - for colormap work */
  ((struct ogl_vars *)dmp->dmr_vars)->mvars.zclipping_on = 1; /* Z Clipping flag */
  ((struct ogl_vars *)dmp->dmr_vars)->mvars.zbuffer_on = 1; /* Hardware Z buffer is on */
  ((struct ogl_vars *)dmp->dmr_vars)->mvars.linewidth = 1; /* Line drawing width */
  ((struct ogl_vars *)dmp->dmr_vars)->mvars.dummy_perspective = 1;
  ((struct ogl_vars *)dmp->dmr_vars)->mvars.fastfog = 1;
  ((struct ogl_vars *)dmp->dmr_vars)->mvars.fogdensity = 1.0;
d221 1
a221 1
    Tk_CreateGenericHandler(dmp->dmr_eventhandler, (ClientData)DM_TYPE_OGL);
d223 1
a223 1
  BU_LIST_APPEND(&head_ogl_vars.l, &((struct ogl_vars *)dmp->dmr_vars)->l);
d225 1
a225 1
  if(dmp->dmr_vars)
a244 1
  int major, minor;
d264 1
a264 1
  ((struct ogl_vars *)dmp->dmr_vars)->fontstruct = NULL;
d266 1
a266 1
  if((tmp_dpy = XOpenDisplay(dmp->dmr_dname)) == NULL){
d271 1
a271 1
  ((struct ogl_vars *)dmp->dmr_vars)->width = DisplayWidth(tmp_dpy,
d273 1
a273 1
  ((struct ogl_vars *)dmp->dmr_vars)->height = DisplayHeight(tmp_dpy,
d277 2
a278 2
  if(((struct ogl_vars *)dmp->dmr_vars)->height < ((struct ogl_vars *)dmp->dmr_vars)->width)
    ((struct ogl_vars *)dmp->dmr_vars)->width = ((struct ogl_vars *)dmp->dmr_vars)->height;
d280 1
a280 1
    ((struct ogl_vars *)dmp->dmr_vars)->height = ((struct ogl_vars *)dmp->dmr_vars)->width;
d285 2
a286 2
  ((struct ogl_vars *)dmp->dmr_vars)->xtkwin =
    Tk_CreateWindowFromPath(interp, tkwin, bu_vls_addr(&dmp->dmr_pathName), dmp->dmr_dname);
d289 2
a290 2
  if( ((struct ogl_vars *)dmp->dmr_vars)->xtkwin == NULL ) {
    Tcl_AppendResult(interp, "dm-Ogl: Failed to open ", bu_vls_addr(&dmp->dmr_pathName),
d296 1
a296 1
  bu_vls_printf(&str, "%s\n", bu_vls_addr(&dmp->dmr_pathName));
d303 2
a304 2
  ((struct ogl_vars *)dmp->dmr_vars)->dpy =
    Tk_Display(((struct ogl_vars *)dmp->dmr_vars)->xtkwin);
d307 1
a307 1
  if ((vip=Ogl_set_visual(dmp, ((struct ogl_vars *)dmp->dmr_vars)->xtkwin))==NULL){
d313 7
a319 7
  Tk_GeometryRequest(((struct ogl_vars *)dmp->dmr_vars)->xtkwin,
		     ((struct ogl_vars *)dmp->dmr_vars)->width,
		     ((struct ogl_vars *)dmp->dmr_vars)->height);

  Tk_ResizeWindow(((struct ogl_vars *)dmp->dmr_vars)->xtkwin,
		  ((struct ogl_vars *)dmp->dmr_vars)->width,
		  ((struct ogl_vars *)dmp->dmr_vars)->height);
d321 2
a322 2
  Tk_MoveToplevelWindow(((struct ogl_vars *)dmp->dmr_vars)->xtkwin, 1276 - 976, 0);
  Tk_MakeWindowExist(((struct ogl_vars *)dmp->dmr_vars)->xtkwin);
d324 2
a325 2
  ((struct ogl_vars *)dmp->dmr_vars)->win =
    Tk_WindowId(((struct ogl_vars *)dmp->dmr_vars)->xtkwin);
d327 1
a327 1
  a_screen = Tk_ScreenNumber(((struct ogl_vars *)dmp->dmr_vars)->xtkwin);
d334 2
a335 2
  if ((((struct ogl_vars *)dmp->dmr_vars)->glxc =
       glXCreateContext(((struct ogl_vars *)dmp->dmr_vars)->dpy, vip, 0,
d343 4
a346 4
  ((struct ogl_vars *)dmp->dmr_vars)->is_direct =
    (char) glXIsDirect(((struct ogl_vars *)dmp->dmr_vars)->dpy,
		       ((struct ogl_vars *)dmp->dmr_vars)->glxc);
  Tcl_AppendResult(interp, "Using ", ((struct ogl_vars *)dmp->dmr_vars)->is_direct ?
d349 1
a349 1
  ogl_ogl_used = (((struct ogl_vars *)dmp->dmr_vars)->is_direct || ogl_ogl_used);
d356 1
a356 1
    (XDeviceInfoPtr) XListInputDevices (((struct ogl_vars *)dmp->dmr_vars)->dpy, &ndevices);
d365 1
a365 1
	if((dev = XOpenDevice(((struct ogl_vars *)dmp->dmr_vars)->dpy,
d377 1
a377 1
	    DeviceButtonPress(dev, ((struct ogl_vars *)dmp->dmr_vars)->devbuttonpress,
d380 1
a380 1
	    DeviceButtonRelease(dev, ((struct ogl_vars *)dmp->dmr_vars)->devbuttonrelease,
d387 1
a387 1
	    DeviceMotionNotify(dev, ((struct ogl_vars *)dmp->dmr_vars)->devmotionnotify,
d397 2
a398 2
	XSelectExtensionEvent(((struct ogl_vars *)dmp->dmr_vars)->dpy,
			      ((struct ogl_vars *)dmp->dmr_vars)->win, e_class, nclass);
d406 3
a408 3
  if (!glXMakeCurrent(((struct ogl_vars *)dmp->dmr_vars)->dpy,
		      ((struct ogl_vars *)dmp->dmr_vars)->win,
		      ((struct ogl_vars *)dmp->dmr_vars)->glxc)){
d414 1
a414 1
  if ((((struct ogl_vars *)dmp->dmr_vars)->fontOffset = glGenLists(128))==0){
d430 2
a431 5
  if (((struct ogl_vars *)dmp->dmr_vars)->mvars.rgb)
    glFogfv(GL_FOG_COLOR, backgnd);
  else
    glFogi(GL_FOG_INDEX, CMAP_RAMP_WIDTH - 1);
#if 1
a433 5
#else
  glFogf(GL_FOG_DENSITY, 1.0);
#endif

	
d440 1
a440 1
  glGetDoublev(GL_PROJECTION_MATRIX, ((struct ogl_vars *)dmp->dmr_vars)->faceplate_mat);
d447 1
a447 1
  ((struct ogl_vars *)dmp->dmr_vars)->face_flag = 1;	/* faceplate matrix is on top of stack */
d449 1
a449 1
  Tk_MapWindow(((struct ogl_vars *)dmp->dmr_vars)->xtkwin);
d453 1
a453 2
/*XXX Just experimenting */
static void
d463 3
a465 1
    Tcl_EvalFile(interp, filename);
d473 1
a473 1
static void
d477 1
a477 1
  if(((struct ogl_vars *)dmp->dmr_vars)->glxc != NULL){
d485 2
a486 2
    glXDestroyContext(((struct ogl_vars *)dmp->dmr_vars)->dpy,
		      ((struct ogl_vars *)dmp->dmr_vars)->glxc);
d489 2
a490 2
  if(((struct ogl_vars *)dmp->dmr_vars)->xtkwin != NULL)
    Tk_DestroyWindow(((struct ogl_vars *)dmp->dmr_vars)->xtkwin);
d492 2
a493 2
  if(((struct ogl_vars *)dmp->dmr_vars)->l.forw != BU_LIST_NULL)
    BU_LIST_DEQUEUE(&((struct ogl_vars *)dmp->dmr_vars)->l);
d495 1
a495 1
  bu_free(dmp->dmr_vars, "Ogl_close: ogl_vars");
d498 3
a500 1
    Tk_DeleteGenericHandler(dmp->dmr_eventhandler, (ClientData)DM_TYPE_OGL);
d508 2
a509 2
static void
Ogl_prolog(dmp)
d517 2
a518 2
  if (((struct ogl_vars *)dmp->dmr_vars)->mvars.debug)
    Tcl_AppendResult(interp, "Ogl_prolog\n", (char *)NULL);
d520 6
a525 5
  if (!glXMakeCurrent(((struct ogl_vars *)dmp->dmr_vars)->dpy,
		      ((struct ogl_vars *)dmp->dmr_vars)->win,
		      ((struct ogl_vars *)dmp->dmr_vars)->glxc)){
    Tcl_AppendResult(interp, "Ogl_prolog: Couldn't make context current\n", (char *)NULL);
    return;
d528 1
a528 1
  if (!((struct ogl_vars *)dmp->dmr_vars)->mvars.doublebuffer){
a530 1
    /*			return;*/
d533 1
a533 1
  if (((struct ogl_vars *)dmp->dmr_vars)->face_flag){
d538 2
a539 2
    ((struct ogl_vars *)dmp->dmr_vars)->face_flag = 0;
    if (((struct ogl_vars *)dmp->dmr_vars)->mvars.cueing_on){
a540 1
#if 1
d542 1
a542 4
      fogdepth = 2.2 * (*dmp->dmr_vp); /* 2.2 is heuristic */
#else
      fogdepth = 2.2; /* 2.2 is heuristic */
#endif
d544 2
a545 7
#if 1
/*XXX Need to do something with Viewscale */
      fogdepth = (GLfloat) (0.5*((struct ogl_vars *)dmp->dmr_vars)->mvars.fogdensity/
			    (*dmp->dmr_vp));
#else
      fogdepth = (GLfloat) 0.5*((struct ogl_vars *)dmp->dmr_vars)->mvars.fogdensity;
#endif
d547 1
a547 1
      glFogi(GL_FOG_MODE, ((struct ogl_vars *)dmp->dmr_vars)->mvars.perspective_mode ?
d550 1
a550 1
    if (((struct ogl_vars *)dmp->dmr_vars)->mvars.lighting_on){
d554 2
a555 2
	
  glLineWidth((GLfloat) ((struct ogl_vars *)dmp->dmr_vars)->mvars.linewidth);
d561 2
a562 2
static void
Ogl_epilog(dmp)
d565 2
a566 15
  if (((struct ogl_vars *)dmp->dmr_vars)->mvars.debug)
    Tcl_AppendResult(interp, "Ogl_epilog\n", (char *)NULL);

  /*
   * A Point, in the Center of the Screen.
   * This is drawn last, to always come out on top.
   */

  glColor3ub( (short)((struct ogl_vars *)dmp->dmr_vars)->rgbtab[4].r,
	      (short)((struct ogl_vars *)dmp->dmr_vars)->rgbtab[4].g,
	      (short)((struct ogl_vars *)dmp->dmr_vars)->rgbtab[4].b );
  glBegin(GL_POINTS);
  glVertex2i(0,0);
  glEnd();
  /* end of faceplate */
d568 3
a570 3
  if(((struct ogl_vars *)dmp->dmr_vars)->mvars.doublebuffer ){
    glXSwapBuffers(((struct ogl_vars *)dmp->dmr_vars)->dpy,
		   ((struct ogl_vars *)dmp->dmr_vars)->win);
d577 1
a577 1
  XSync(((struct ogl_vars *)dmp->dmr_vars)->dpy, 0);
d579 1
a579 1
  if(((struct ogl_vars *)dmp->dmr_vars)->mvars.debug){
d594 1
a594 1
  return;
d601 1
a601 1
static void
d607 8
a614 5
	register fastf_t *mptr;
	GLfloat gtmat[16], view[16];
	GLfloat *gtmatp;
	mat_t	newm;
	int	i;
d616 1
a616 3
	
	if (((struct ogl_vars *)dmp->dmr_vars)->mvars.debug)
	  Tcl_AppendResult(interp, "Ogl_newrot()\n", (char *)NULL);
d618 7
a624 2
	if(((struct ogl_vars *)dmp->dmr_vars)->mvars.debug){
	  struct bu_vls tmp_vls;
d626 3
a628 7
	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "which eye = %d\t", which_eye);
	  bu_vls_printf(&tmp_vls, "newrot matrix = \n");
	  bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[0], mat[4], mat[8],mat[12]);
	  bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[1], mat[5], mat[9],mat[13]);
	  bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[2], mat[6], mat[10],mat[14]);
	  bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[3], mat[7], mat[11],mat[15]);
d630 29
a658 3
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}
d660 19
a678 18
	switch(which_eye)  {
	case 0:
		/* Non-stereo */
		break;
	case 1:
		/* R eye */
		glViewport(0,  0, (XMAXSCREEN)+1, ( YSTEREO)+1); 
		glScissor(0,  0, (XMAXSCREEN)+1, (YSTEREO)+1);
		Ogl_puts( "R", 2020, 0, 0, DM_RED );
		break;
	case 2:
		/* L eye */
		glViewport(0,  0+YOFFSET_LEFT, ( XMAXSCREEN)+1,
			   ( YSTEREO+YOFFSET_LEFT)-( YOFFSET_LEFT)+1); 
		glScissor(0,  0+YOFFSET_LEFT, ( XMAXSCREEN)+1,
			  ( YSTEREO+YOFFSET_LEFT)-( YOFFSET_LEFT)+1);
		break;
	}
d680 4
a683 1
	mptr = mat;
d685 7
a691 31
	gtmat[0] = *(mptr++) * ((struct ogl_vars *)dmp->dmr_vars)->aspect;
	gtmat[4] = *(mptr++) * ((struct ogl_vars *)dmp->dmr_vars)->aspect;
	gtmat[8] = *(mptr++) * ((struct ogl_vars *)dmp->dmr_vars)->aspect;
	gtmat[12] = *(mptr++) * ((struct ogl_vars *)dmp->dmr_vars)->aspect;

	gtmat[1] = *(mptr++) * ((struct ogl_vars *)dmp->dmr_vars)->aspect;
	gtmat[5] = *(mptr++) * ((struct ogl_vars *)dmp->dmr_vars)->aspect;
	gtmat[9] = *(mptr++) * ((struct ogl_vars *)dmp->dmr_vars)->aspect;
	gtmat[13] = *(mptr++) * ((struct ogl_vars *)dmp->dmr_vars)->aspect;

	gtmat[2] = *(mptr++);
	gtmat[6] = *(mptr++);
	gtmat[10] = *(mptr++);
	gtmat[14] = *(mptr++);

	gtmat[3] = *(mptr++);
	gtmat[7] = *(mptr++);
	gtmat[11] = *(mptr++);
	gtmat[15] = *(mptr++);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glTranslatef( 0.0, 0.0, -1.0 );
	glMultMatrixf( gtmat );

	/* Make sure that new matrix is applied to the lights */
	if (((struct ogl_vars *)dmp->dmr_vars)->mvars.lighting_on ){
		glLightfv(GL_LIGHT0, GL_POSITION, light0_position);
		glLightfv(GL_LIGHT1, GL_POSITION, light1_position);
		glLightfv(GL_LIGHT2, GL_POSITION, light2_position);
		glLightfv(GL_LIGHT3, GL_POSITION, light3_position);
d693 1
a693 1
	}
d710 1
a710 1
Ogl_object( dmp, vp, m, illum, linestyle, r, g, b, index )
a713 4
int illum;
int linestyle;
register short r, g, b;
short index;
d715 17
a731 69
	register struct rt_vlist	*tvp;
	register int nvec;
	register float	*gtvec;
	register float material[4];
	char	gtbuf[16+3*sizeof(double)];
	int first;
	int i,j;

	if (((struct ogl_vars *)dmp->dmr_vars)->mvars.debug)
	  Tcl_AppendResult(interp, "Ogl_Object()\n", (char *)NULL);

	/*
	 *  It is claimed that the "dancing vector disease" of the
	 *  4D GT processors is due to the array being passed to v3f()
	 *  not being quad-word aligned (16-byte boundary).
	 *  This hack ensures that the buffer has this alignment.
	 *  Note that this requires gtbuf to be 16 bytes longer than needed.
	 */
	gtvec = (float *)((((int)gtbuf)+15) & (~0xF));

	if (linestyle)
		glEnable(GL_LINE_STIPPLE);		/* set dot-dash */

	if (illum && ((struct ogl_vars *)dmp->dmr_vars)->mvars.cueing_on)
		glDisable(GL_FOG);	

	if( ((struct ogl_vars *)dmp->dmr_vars)->mvars.rgb )  {
		if( illum )  {
			r = g = b = 230;
		}

		if(((struct ogl_vars *)dmp->dmr_vars)->mvars.lighting_on)
		{

			/* Ambient = .2, Diffuse = .6, Specular = .2 */

			material[0] = 	.2 * ( r / 255.0);
			material[1] = 	.2 * ( g / 255.0);
			material[2] = 	.2 * ( b / 255.0);
			material[3] = 1.0;
			glMaterialfv(GL_FRONT, GL_AMBIENT, material);
			glMaterialfv(GL_FRONT, GL_SPECULAR, material);

			material[0] *= 3.0;
			material[1] *= 3.0;
			material[2] *= 3.0;
			glMaterialfv(GL_FRONT, GL_DIFFUSE, material);

		} else {
			glColor3ub( r,  g,  b );
		}
	} else {
		if (illum){
		  ((struct ogl_vars *)dmp->dmr_vars)->ovec = MAP_ENTRY(DM_WHITE);
		  glIndexi(((struct ogl_vars *)dmp->dmr_vars)->ovec);
		} else if( (nvec = MAP_ENTRY( index )) !=
			   ((struct ogl_vars *)dmp->dmr_vars)->ovec) {
		  glIndexi(nvec);
		  ((struct ogl_vars *)dmp->dmr_vars)->ovec = nvec;
		}

		if (((struct ogl_vars *)dmp->dmr_vars)->mvars.lighting_on){
		  material[0] = ((struct ogl_vars *)dmp->dmr_vars)->ovec -
		    CMAP_RAMP_WIDTH + 2;
		  material[1] = ((struct ogl_vars *)dmp->dmr_vars)->ovec - CMAP_RAMP_WIDTH/2;
		  material[2] = ((struct ogl_vars *)dmp->dmr_vars)->ovec - 1;
		  glMaterialfv(GL_FRONT, GL_COLOR_INDEXES, material);
		}
	}
d733 4
d738 42
a779 1
	/* Viewing region is from -1.0 to +1.0 */
d781 11
a791 51
	for( BU_LIST_FOR( tvp, rt_vlist, &vp->l ) )  {
		register int	i;
		register int	nused = tvp->nused;
		register int	*cmd = tvp->cmd;
		register point_t *pt = tvp->pt;
		for( i = 0; i < nused; i++,cmd++,pt++ )  {
			switch( *cmd )  {
			case RT_VLIST_LINE_MOVE:
				/* Move, start line */
				if( first == 0 )
					glEnd();
				first = 0;
				glBegin(GL_LINE_STRIP);
				glVertex3dv( *pt );
				break;
			case RT_VLIST_LINE_DRAW:
				/* Draw line */
				glVertex3dv( *pt );
				break;
			case RT_VLIST_POLY_START:
				/* Start poly marker & normal */
				if( first == 0 )
					glEnd();
				glBegin(GL_POLYGON);
				/* Set surface normal (vl_pnt points outward) */
				VMOVE( gtvec, *pt );
				glNormal3fv(gtvec);
				break;
			case RT_VLIST_POLY_MOVE:
				/* Polygon Move */
				glVertex3dv( *pt );
				break;
			case RT_VLIST_POLY_DRAW:
				/* Polygon Draw */
				glVertex3dv( *pt );
				break;
			case RT_VLIST_POLY_END:
				/* Draw, End Polygon */
				glVertex3dv( *pt );
				glEnd();
				first = 1;
				break;
			case RT_VLIST_POLY_VERTNORM:
				/* Set per-vertex normal.  Given before vert. */
				VMOVE( gtvec, *pt );
				glNormal3fv(gtvec);
				break;
			}
		}
	}
	if( first == 0 ) glEnd();
d793 2
a794 4
	if (linestyle)
		glDisable(GL_LINE_STIPPLE);	/* restore solid lines */

	if (illum && ((struct ogl_vars *)dmp->dmr_vars)->mvars.cueing_on){
d797 1
d809 1
a809 1
static void
d813 1
a813 1
	GLint mm; 
d815 2
a816 2
	if (((struct ogl_vars *)dmp->dmr_vars)->mvars.debug)
	  Tcl_AppendResult(interp, "Ogl_normal\n", (char *)NULL);
d818 13
a830 6
	if( ((struct ogl_vars *)dmp->dmr_vars)->mvars.rgb )  {
	  glColor3ub( 0,  0,  0 );
	} else {
	  ((struct ogl_vars *)dmp->dmr_vars)->ovec = MAP_ENTRY(DM_BLACK);
	  glIndexi( ((struct ogl_vars *)dmp->dmr_vars)->ovec );
	}
d832 1
a832 31
	if (!((struct ogl_vars *)dmp->dmr_vars)->face_flag){
		glMatrixMode(GL_PROJECTION);
		glPushMatrix();
		glLoadMatrixd( ((struct ogl_vars *)dmp->dmr_vars)->faceplate_mat );
		glMatrixMode(GL_MODELVIEW);
		glPushMatrix();
		glLoadIdentity();
		((struct ogl_vars *)dmp->dmr_vars)->face_flag = 1;
		if(((struct ogl_vars *)dmp->dmr_vars)->mvars.cueing_on)
			glDisable(GL_FOG);
		if (((struct ogl_vars *)dmp->dmr_vars)->mvars.lighting_on)
			glDisable(GL_LIGHTING);

	}

	return;
}

/*
 *			O G L _ U P D A T E
 *
 * Transmit accumulated displaylist to the display processor.
 */
static void
Ogl_update(dmp)
struct dm *dmp;
{
  if (((struct ogl_vars *)dmp->dmr_vars)->mvars.debug)
    Tcl_AppendResult(interp, "Ogl_update()\n", (char *)NULL);

    XFlush(((struct ogl_vars *)dmp->dmr_vars)->dpy);
a834 1

d836 1
a836 1
 *			XOGL _ P U T S
d841 2
a842 2
static void
Ogl_puts( dmp, str, x, y, size, colour )
d845 2
a846 1
int x,y,size, colour;
d848 2
a849 2
  if (((struct ogl_vars *)dmp->dmr_vars)->mvars.debug)
    Tcl_AppendResult(interp, "Ogl_puts()\n", (char *)NULL);
a851 12
  /*	glRasterPos2f( GED2IRIS(x),  GED2IRIS(y));*/
  if( ((struct ogl_vars *)dmp->dmr_vars)->mvars.rgb )  {
    glColor3ub( (short)((struct ogl_vars *)dmp->dmr_vars)->rgbtab[colour].r,
		(short)((struct ogl_vars *)dmp->dmr_vars)->rgbtab[colour].g,
		(short)((struct ogl_vars *)dmp->dmr_vars)->rgbtab[colour].b );
  } else {
    ((struct ogl_vars *)dmp->dmr_vars)->ovec = MAP_ENTRY(colour);
    glIndexi( ((struct ogl_vars *)dmp->dmr_vars)->ovec );
  }


  /*	glRasterPos2i( x,  y);*/
d853 1
a853 1
  glListBase(((struct ogl_vars *)dmp->dmr_vars)->fontOffset);
d855 2
d864 2
a865 2
static void
Ogl_2d_line( dmp, x1, y1, x2, y2, dashed )
a868 1
int dashed;
d870 4
a873 1
	register int nvec;
d875 3
a877 2
	if (((struct ogl_vars *)dmp->dmr_vars)->mvars.debug)
	  Tcl_AppendResult(interp, "Ogl_2d_line()\n", (char *)NULL);
d879 13
a891 2
	if( ((struct ogl_vars *)dmp->dmr_vars)->mvars.rgb )  {
		/* Yellow */
d893 3
a895 10
		glColor3ub( (short)255,  (short)255,  (short) 0 );
	} else {
	  if((nvec = MAP_ENTRY(DM_YELLOW)) !=
	     ((struct ogl_vars *)dmp->dmr_vars)->ovec) {
	    glIndexi(nvec);
	    ((struct ogl_vars *)dmp->dmr_vars)->ovec = nvec;
	  }
	}
	
/*	glColor3ub( (short)255,  (short)255,  (short) 0 );*/
d897 4
a900 17
	if(((struct ogl_vars *)dmp->dmr_vars)->mvars.debug){
	  GLfloat pmat[16];
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  glGetFloatv(GL_PROJECTION_MATRIX, pmat);
	  bu_vls_printf(&tmp_vls, "projection matrix:\n");
	  bu_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[0], pmat[4], pmat[8],pmat[12]);
	  bu_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[1], pmat[5], pmat[9],pmat[13]);
	  bu_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[2], pmat[6], pmat[10],pmat[14]);
	  bu_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[3], pmat[7], pmat[11],pmat[15]);
	  glGetFloatv(GL_MODELVIEW_MATRIX, pmat);
	  bu_vls_printf(&tmp_vls, "modelview matrix:\n");
	  bu_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[0], pmat[4], pmat[8],pmat[12]);
	  bu_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[1], pmat[5], pmat[9],pmat[13]);
	  bu_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[2], pmat[6], pmat[10],pmat[14]);
	  bu_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[3], pmat[7], pmat[11],pmat[15]);
d902 2
a903 3
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}
d905 6
a910 10
	if( dashed )
		glEnable(GL_LINE_STIPPLE);
		
	glBegin(GL_LINES); 
	 glVertex2f( GED2IRIS(x1),  GED2IRIS(y1));
	 glVertex2f( GED2IRIS(x2),  GED2IRIS(y2));
	glEnd();

	if( dashed )		/* restore solid */
		glDisable(GL_LINE_STIPPLE); 
d914 2
a915 18
/*
 *			O G L _ I N P U T
 *
 * Execution must suspend in this routine until a significant event
 * has occured on either the command stream,
 * unless "noblock" is set.
 *
 *
 * Implicit Return -
 *	If any files are ready for input, their bits will be set in 'input'.
 *	Otherwise, 'input' will be all zeros.
 *
 * DEPRECATED 
 *
 */
/* ARGSUSED */
static void
Ogl_input( dmp, input, noblock )
d917 2
a918 2
fd_set		*input;
int		noblock;
d920 27
a946 1
    return;
d949 3
a951 6
/* 
 *			O G L _ L I G H T
 */
/* ARGSUSED */
static void
Ogl_light( dmp, cmd, func )
d953 2
a954 2
int cmd;
int func;			/* BE_ or BV_ function */
d956 9
a964 1
	return;
d967 1
a993 103
static void
Ogl_viewchange(dmp)
struct dm *dmp;
{
}

static void
Ogl_colorchange(dmp)
struct dm *dmp;
{
	register int i;
	register int nramp;
	XColor celltest;
	int count = 0;
	Colormap a_cmap;

	if( ((struct ogl_vars *)dmp->dmr_vars)->mvars.debug )
	  Tcl_AppendResult(interp, "colorchange\n", (char *)NULL);

	/* Program the builtin colors */
	((struct ogl_vars *)dmp->dmr_vars)->rgbtab[0].r=0; 
	((struct ogl_vars *)dmp->dmr_vars)->rgbtab[0].g=0; 
	((struct ogl_vars *)dmp->dmr_vars)->rgbtab[0].b=0;/* Black */
	((struct ogl_vars *)dmp->dmr_vars)->rgbtab[1].r=255; 
	((struct ogl_vars *)dmp->dmr_vars)->rgbtab[1].g=0; 
	((struct ogl_vars *)dmp->dmr_vars)->rgbtab[1].b=0;/* Red */
	((struct ogl_vars *)dmp->dmr_vars)->rgbtab[2].r=0; 
	((struct ogl_vars *)dmp->dmr_vars)->rgbtab[2].g=0; 
	((struct ogl_vars *)dmp->dmr_vars)->rgbtab[2].b=255;/* Blue */
	((struct ogl_vars *)dmp->dmr_vars)->rgbtab[3].r=255; 
	((struct ogl_vars *)dmp->dmr_vars)->rgbtab[3].g=255;
	((struct ogl_vars *)dmp->dmr_vars)->rgbtab[3].b=0;/*Yellow */
	((struct ogl_vars *)dmp->dmr_vars)->rgbtab[4].r =
	  ((struct ogl_vars *)dmp->dmr_vars)->rgbtab[4].g =
	  ((struct ogl_vars *)dmp->dmr_vars)->rgbtab[4].b = 255; /* White */
	((struct ogl_vars *)dmp->dmr_vars)->uslots = 5;

	if( ((struct ogl_vars *)dmp->dmr_vars)->mvars.rgb )  {
		if(((struct ogl_vars *)dmp->dmr_vars)->mvars.cueing_on) {
			glEnable(GL_FOG);
		} else {
			glDisable(GL_FOG);
		}

		glColor3ub( (short)255,  (short)255,  (short)255 );

		return;
	}

	if(USE_RAMP && (((struct ogl_vars *)dmp->dmr_vars)->index_size < 7)) {
	  Tcl_AppendResult(interp, "Too few bitplanes: depthcueing and lighting disabled\n",
			   (char *)NULL);
	  ((struct ogl_vars *)dmp->dmr_vars)->mvars.cueing_on = 0;
	  ((struct ogl_vars *)dmp->dmr_vars)->mvars.lighting_on = 0;
	}
	/* number of slots is 2^indexsize */
	((struct ogl_vars *)dmp->dmr_vars)->nslots =
	  1<<((struct ogl_vars *)dmp->dmr_vars)->index_size;
	if( ((struct ogl_vars *)dmp->dmr_vars)->nslots > NSLOTS )
	  ((struct ogl_vars *)dmp->dmr_vars)->nslots = NSLOTS;
	if(USE_RAMP) {
	  /* peel off reserved ones */
	  ((struct ogl_vars *)dmp->dmr_vars)->nslots =
	    (((struct ogl_vars *)dmp->dmr_vars)->nslots - CMAP_BASE) / CMAP_RAMP_WIDTH;
	} else {
	  ((struct ogl_vars *)dmp->dmr_vars)->nslots -= CMAP_BASE;	/* peel off the reserved entries */
	}

	((struct ogl_vars *)dmp->dmr_vars)->ovec = -1;	/* Invalidate the old colormap entry */

	/* best to do this before the colorit */
	if (((struct ogl_vars *)dmp->dmr_vars)->mvars.cueing_on &&
	    ((struct ogl_vars *)dmp->dmr_vars)->mvars.lighting_on){
		((struct ogl_vars *)dmp->dmr_vars)->mvars.lighting_on = 0;
		glDisable(GL_LIGHTING);
	}

	/* Map the colors in the solid table to colormap indices */
	Ogl_colorit(dmp);

	for( i=0; i < ((struct ogl_vars *)dmp->dmr_vars)->uslots; i++ )  {
		Ogl_gen_color( dmp, i
#if 1
			       );
#else
			       , ((struct ogl_vars *)dmp->dmr_vars)->rgbtab[i].r,
			       ((struct ogl_vars *)dmp->dmr_vars)->rgbtab[i].g,
			       ((struct ogl_vars *)dmp->dmr_vars)->rgbtab[i].b);
#endif
	}

	/* best to do this after the colorit */
	if (((struct ogl_vars *)dmp->dmr_vars)->mvars.cueing_on){
		glEnable(GL_FOG);
	} else {
		glDisable(GL_FOG);
	}

	((struct ogl_vars *)dmp->dmr_vars)->ovec = MAP_ENTRY(DM_WHITE);
	glIndexi( ((struct ogl_vars *)dmp->dmr_vars)->ovec );

}

d995 1
a995 1
static void
d999 2
a1000 2
  ((struct ogl_vars *)dmp->dmr_vars)->mvars.debug = lvl;
  XFlush(((struct ogl_vars *)dmp->dmr_vars)->dpy);
d1004 2
a1005 2
static void
Ogl_window(w)
d1010 1
d1022 1
a1022 2
  int use, rgba, dbfr, stereo;
  int m_stereo, m_double, m_rgba;
d1024 2
d1027 2
a1028 3
  /* m_stereo - try to get stereo 
   * m_double - try to get double buffered
   * m_rgba  - try to get rgb
a1030 1
#if 0
a1038 3
  m_double = 1;
  m_rgba = 1;
	
d1042 1
a1042 1
  vibase = XGetVisualInfo(((struct ogl_vars *)dmp->dmr_vars)->dpy,
d1048 1
a1048 1
      glXGetConfig(((struct ogl_vars *)dmp->dmr_vars)->dpy,
d1052 2
a1053 3
      /* desires */
      if (m_rgba){
	glXGetConfig(((struct ogl_vars *)dmp->dmr_vars)->dpy,
d1055 6
a1060 4
	if (!rgba)
	  continue;
      } else if (vip->class != PseudoColor) {
	/* if index mode, accept only read/write*/
d1062 3
a1064 1
      }
d1066 1
a1066 1
	glXGetConfig(((struct ogl_vars *)dmp->dmr_vars)->dpy,
d1071 2
a1072 7
      if (m_double ) {
	glXGetConfig(((struct ogl_vars *)dmp->dmr_vars)->dpy,
		     vip, GLX_DOUBLEBUFFER,&dbfr);
	if (!dbfr)
	  continue;
      }
			
d1080 1
a1080 2
      tries = 0;
      while (tries < j) {
d1090 4
a1093 12
	if (maxvip->class == PseudoColor)
	  ((struct ogl_vars *)dmp->dmr_vars)->cmap =
	    XCreateColormap(((struct ogl_vars *)dmp->dmr_vars)->dpy,
			    RootWindow(((struct ogl_vars *)dmp->dmr_vars)->dpy,
				       maxvip->screen),
			    maxvip->visual, AllocAll);
	else
	  ((struct ogl_vars *)dmp->dmr_vars)->cmap =
	    XCreateColormap(((struct ogl_vars *)dmp->dmr_vars)->dpy,
			    RootWindow(((struct ogl_vars *)dmp->dmr_vars)->dpy,
				       maxvip->screen),
			    maxvip->visual, AllocNone);
d1096 9
a1104 14
			       ((struct ogl_vars *)dmp->dmr_vars)->cmap)){
	  ((struct ogl_vars *)dmp->dmr_vars)->mvars.doublebuffer = m_double;
	  glXGetConfig(((struct ogl_vars *)dmp->dmr_vars)->dpy, maxvip, GLX_DEPTH_SIZE,
		       &((struct ogl_vars *)dmp->dmr_vars)->mvars.depth);
	  if (((struct ogl_vars *)dmp->dmr_vars)->mvars.depth > 0)
	    ((struct ogl_vars *)dmp->dmr_vars)->mvars.zbuf = 1;
	  ((struct ogl_vars *)dmp->dmr_vars)->mvars.rgb = m_rgba;
	  if (!m_rgba){
	    glXGetConfig(((struct ogl_vars *)dmp->dmr_vars)->dpy,
			 maxvip, GLX_BUFFER_SIZE,
			 &((struct ogl_vars *)dmp->dmr_vars)->index_size);
	  }
	  ((struct ogl_vars *)dmp->dmr_vars)->stereo_is_on = m_stereo;
	  return (maxvip); /* sucess */
d1108 2
a1109 3
	  tries ++;
	  XFreeColormap(((struct ogl_vars *)dmp->dmr_vars)->dpy,
			((struct ogl_vars *)dmp->dmr_vars)->cmap);
d1114 1
d1119 2
a1120 7
    } else if (m_rgba) {
      m_rgba = 0;
      Tcl_AppendResult(interp, "RGBA not available.\n", (char *)NULL);
    } else if (m_double) {
      m_double = 0;
      Tcl_AppendResult(interp, "Doublebuffering not available. \n", (char *)NULL);
    } else {
a1121 1
    }
d1125 1
d1144 4
a1147 4
  XGetWindowAttributes( ((struct ogl_vars *)dmp->dmr_vars)->dpy,
			((struct ogl_vars *)dmp->dmr_vars)->win, &xwa );
  ((struct ogl_vars *)dmp->dmr_vars)->height = xwa.height;
  ((struct ogl_vars *)dmp->dmr_vars)->width = xwa.width;
d1149 4
a1152 4
  glViewport(0,  0, (((struct ogl_vars *)dmp->dmr_vars)->width),
	     (((struct ogl_vars *)dmp->dmr_vars)->height));
  glScissor(0,  0, (((struct ogl_vars *)dmp->dmr_vars)->width)+1,
	    (((struct ogl_vars *)dmp->dmr_vars)->height)+1);
d1154 1
a1154 1
  if( ((struct ogl_vars *)dmp->dmr_vars)->mvars.zbuffer_on )
d1163 1
a1163 1
  if (((struct ogl_vars *)dmp->dmr_vars)->mvars.zbuffer_on)
d1168 1
a1168 1
  if (((struct ogl_vars *)dmp->dmr_vars)->mvars.doublebuffer)
d1182 3
a1184 3
  ((struct ogl_vars *)dmp->dmr_vars)->aspect =
    (fastf_t)((struct ogl_vars *)dmp->dmr_vars)->height/
    (fastf_t)((struct ogl_vars *)dmp->dmr_vars)->width;
d1188 3
a1190 3
  if (((struct ogl_vars *)dmp->dmr_vars)->fontstruct == NULL) {
    if ((((struct ogl_vars *)dmp->dmr_vars)->fontstruct =
	 XLoadQueryFont(((struct ogl_vars *)dmp->dmr_vars)->dpy,
d1193 2
a1194 2
      if ((((struct ogl_vars *)dmp->dmr_vars)->fontstruct =
	   XLoadQueryFont(((struct ogl_vars *)dmp->dmr_vars)->dpy,
d1201 2
a1202 2
    glXUseXFont( ((struct ogl_vars *)dmp->dmr_vars)->fontstruct->fid,
		 0, 127, ((struct ogl_vars *)dmp->dmr_vars)->fontOffset);
d1209 3
a1211 3
  if (((struct ogl_vars *)dmp->dmr_vars)->width < 582) {
    if (((struct ogl_vars *)dmp->dmr_vars)->fontstruct->per_char->width != 5) {
      if ((newfontstruct = XLoadQueryFont(((struct ogl_vars *)dmp->dmr_vars)->dpy,
d1213 5
a1217 5
	XFreeFont(((struct ogl_vars *)dmp->dmr_vars)->dpy,
		  ((struct ogl_vars *)dmp->dmr_vars)->fontstruct);
	((struct ogl_vars *)dmp->dmr_vars)->fontstruct = newfontstruct;
	glXUseXFont( ((struct ogl_vars *)dmp->dmr_vars)->fontstruct->fid,
		     0, 127, ((struct ogl_vars *)dmp->dmr_vars)->fontOffset);
d1220 3
a1222 3
  } else if (((struct ogl_vars *)dmp->dmr_vars)->width < 679) {
    if (((struct ogl_vars *)dmp->dmr_vars)->fontstruct->per_char->width != 6){
      if ((newfontstruct = XLoadQueryFont(((struct ogl_vars *)dmp->dmr_vars)->dpy,
d1224 5
a1228 5
	XFreeFont(((struct ogl_vars *)dmp->dmr_vars)->dpy,
		  ((struct ogl_vars *)dmp->dmr_vars)->fontstruct);
	((struct ogl_vars *)dmp->dmr_vars)->fontstruct = newfontstruct;
	glXUseXFont( ((struct ogl_vars *)dmp->dmr_vars)->fontstruct->fid,
		     0, 127, ((struct ogl_vars *)dmp->dmr_vars)->fontOffset);
d1231 3
a1233 3
  } else if (((struct ogl_vars *)dmp->dmr_vars)->width < 776) {
    if (((struct ogl_vars *)dmp->dmr_vars)->fontstruct->per_char->width != 7){
      if ((newfontstruct = XLoadQueryFont(((struct ogl_vars *)dmp->dmr_vars)->dpy,
d1235 5
a1239 5
	XFreeFont(((struct ogl_vars *)dmp->dmr_vars)->dpy,
		  ((struct ogl_vars *)dmp->dmr_vars)->fontstruct);
	((struct ogl_vars *)dmp->dmr_vars)->fontstruct = newfontstruct;
	glXUseXFont( ((struct ogl_vars *)dmp->dmr_vars)->fontstruct->fid,
		     0, 127, ((struct ogl_vars *)dmp->dmr_vars)->fontOffset);
d1242 3
a1244 3
  } else if (((struct ogl_vars *)dmp->dmr_vars)->width < 873) {
    if (((struct ogl_vars *)dmp->dmr_vars)->fontstruct->per_char->width != 8){
      if ((newfontstruct = XLoadQueryFont(((struct ogl_vars *)dmp->dmr_vars)->dpy,
d1246 5
a1250 5
	XFreeFont(((struct ogl_vars *)dmp->dmr_vars)->dpy,
		  ((struct ogl_vars *)dmp->dmr_vars)->fontstruct);
	((struct ogl_vars *)dmp->dmr_vars)->fontstruct = newfontstruct;
	glXUseXFont( ((struct ogl_vars *)dmp->dmr_vars)->fontstruct->fid,
		     0, 127, ((struct ogl_vars *)dmp->dmr_vars)->fontOffset);
d1254 2
a1255 2
    if (((struct ogl_vars *)dmp->dmr_vars)->fontstruct->per_char->width != 9){
      if ((newfontstruct = XLoadQueryFont(((struct ogl_vars *)dmp->dmr_vars)->dpy,
d1257 5
a1261 5
	XFreeFont(((struct ogl_vars *)dmp->dmr_vars)->dpy,
		  ((struct ogl_vars *)dmp->dmr_vars)->fontstruct);
	((struct ogl_vars *)dmp->dmr_vars)->fontstruct = newfontstruct;
	glXUseXFont( ((struct ogl_vars *)dmp->dmr_vars)->fontstruct->fid,
		     0, 127, ((struct ogl_vars *)dmp->dmr_vars)->fontOffset);
d1271 1
a1271 1
  if (!((struct ogl_vars *)dmp->dmr_vars)->mvars.lighting_on) {
a1273 2
    if (!((struct ogl_vars *)dmp->dmr_vars)->mvars.rgb)
      Ogl_colorchange(dmp);
a1276 8
    if (!((struct ogl_vars *)dmp->dmr_vars)->mvars.rgb){
      if (((struct ogl_vars *)dmp->dmr_vars)->mvars.cueing_on){
	((struct ogl_vars *)dmp->dmr_vars)->mvars.cueing_on = 0;
	glDisable(GL_FOG);
      } 
      Ogl_colorchange(dmp);
    }

d1303 1
a1303 1
  if( ((struct ogl_vars *)dmp->dmr_vars)->mvars.zbuf == 0 ) {
d1306 1
a1306 1
    ((struct ogl_vars *)dmp->dmr_vars)->mvars.zbuffer_on = 0;
d1309 1
a1309 1
  if (((struct ogl_vars *)dmp->dmr_vars)->mvars.zbuffer_on)  {
d1324 2
a1325 2
		 ((struct ogl_vars *)dmp->dmr_vars)->mvars.perspective_mode ?
		 perspective_table[((struct ogl_vars *)dmp->dmr_vars)->perspective_angle] :
d1341 6
a1346 6
  if(((struct ogl_vars *)dmp->dmr_vars)->mvars.dummy_perspective > 0)
    ((struct ogl_vars *)dmp->dmr_vars)->perspective_angle =
      ((struct ogl_vars *)dmp->dmr_vars)->mvars.dummy_perspective <= 4 ?
      ((struct ogl_vars *)dmp->dmr_vars)->mvars.dummy_perspective - 1: 3;
  else if (--((struct ogl_vars *)dmp->dmr_vars)->perspective_angle < 0) /* toggle perspective matrix */
    ((struct ogl_vars *)dmp->dmr_vars)->perspective_angle = 3;
d1348 1
a1348 1
  if(((struct ogl_vars *)dmp->dmr_vars)->mvars.perspective_mode){
d1353 1
a1353 1
		   perspective_table[((struct ogl_vars *)dmp->dmr_vars)->perspective_angle] );
d1362 1
a1362 153
  ((struct ogl_vars *)dmp->dmr_vars)->mvars.dummy_perspective = 1;
}

static void
Ogl_colorit(dmp)
struct dm *dmp;
{
  register struct solid	*sp;
  register struct rgbtab *rgb;
  register int i;
  register int r,g,b;

  if( ((struct ogl_vars *)dmp->dmr_vars)->mvars.rgb )  return;

#if 0
  FOR_ALL_SOLIDS(sp, &dmp->dmr_hp->l)  {
    r = sp->s_color[0];
    g = sp->s_color[1];
    b = sp->s_color[2];
    if( (r == 255 && g == 255 && b == 255) ||
	(r == 0 && g == 0 && b == 0) )  {
      sp->s_dmindex = DM_WHITE;
      continue;
    }

    /* First, see if this matches an existing color map entry */
    rgb = ((struct ogl_vars *)dmp->dmr_vars)->rgbtab;
    for( i = 0; i < ((struct ogl_vars *)dmp->dmr_vars)->uslots; i++, rgb++ )  {
      if( rgb->r == r && rgb->g == g && rgb->b == b )  {
	sp->s_dmindex = i;
	goto next;
      }
    }

    /* If slots left, create a new color map entry, first-come basis */
    if( ((struct ogl_vars *)dmp->dmr_vars)->uslots <
	((struct ogl_vars *)dmp->dmr_vars)->nslots )  {
      rgb =
	&((struct ogl_vars *)dmp->dmr_vars)->rgbtab[i=
	 (((struct ogl_vars *)dmp->dmr_vars)->uslots++)];
      rgb->r = r;
      rgb->g = g;
      rgb->b = b;
      sp->s_dmindex = i;
      continue;
    }
    sp->s_dmindex = DM_YELLOW;	/* Default color */
next:		
    ;
  }
#endif
}


#if IR_KNOBS
ogl_dbtext(str)
{
  Tcl_AppendResult(interp, "dm-ogl: You pressed Help key and '",
		   str, "'\n", (char *)NULL);
}
#endif

/*			G E N _ C O L O R
 *
 *	maps a given color into the appropriate colormap entry
 *	for both depthcued and non-depthcued mode.  In depthcued mode,
 *	Ogl_gen_color also generates the colormap ramps.  Note that in depthcued
 *	mode, DM_BLACK uses map entry 0, and does not generate a ramp for it.
 *	Non depthcued mode skips the first CMAP_BASE colormap entries.
 *
 *	This routine is not called at all if
 *                       ((struct ogl_vars *)dmp->dmr_vars)->mvars.rgb is set.
 */
static void
Ogl_gen_color(dmp, c)
struct dm *dmp;
int c;
{
  if(USE_RAMP) {

    /*  Not much sense in making a ramp for DM_BLACK.  Besides
     *  which, doing so, would overwrite the bottom color
     *  map entries, which is a no-no.
     */
    if( c != DM_BLACK) {
      register int i, j;
      fastf_t r_inc, g_inc, b_inc;
      fastf_t red, green, blue;
      XColor cells[CMAP_RAMP_WIDTH];

      red = r_inc =
	((struct ogl_vars *)dmp->dmr_vars)->rgbtab[c].r * (256/CMAP_RAMP_WIDTH);
      green = g_inc =
	((struct ogl_vars *)dmp->dmr_vars)->rgbtab[c].g * (256/CMAP_RAMP_WIDTH);
      blue = b_inc =
	((struct ogl_vars *)dmp->dmr_vars)->rgbtab[c].b * (256/CMAP_RAMP_WIDTH);

#if 0
      red = rgbtab[c].r * 256;
      green = rgbtab[c].g * 256;
      blue = rgbtab[c].b * 256;
#endif
			
      if (((struct ogl_vars *)dmp->dmr_vars)->mvars.cueing_on){
	for(i = 0, j = MAP_ENTRY(c) + CMAP_RAMP_WIDTH - 1; 
	    i < CMAP_RAMP_WIDTH;
	    i++, j--, red += r_inc, green += g_inc, blue += b_inc){
	  cells[i].pixel = j;
	  cells[i].red = (short)red;
	  cells[i].green = (short)green;
	  cells[i].blue = (short)blue;
	  cells[i].flags = DoRed|DoGreen|DoBlue;
	}
      } else { /* ((struct ogl_vars *)dmp->dmr_vars)->mvars.lighting_on */ 
	for(i = 0, j = MAP_ENTRY(c) - CMAP_RAMP_WIDTH + 1; 
	    i < CMAP_RAMP_WIDTH;
	    i++, j++, red += r_inc, green += g_inc, blue += b_inc){
	  cells[i].pixel = j;
	  cells[i].red = (short)red;
	  cells[i].green = (short)green;
	  cells[i].blue = (short)blue;
	  cells[i].flags = DoRed|DoGreen|DoBlue;
	}
      }
      XStoreColors(((struct ogl_vars *)dmp->dmr_vars)->dpy,
		   ((struct ogl_vars *)dmp->dmr_vars)->cmap, cells, CMAP_RAMP_WIDTH);
    }
  } else {
    XColor cell, celltest;

    cell.pixel = c + CMAP_BASE;
    cell.red = ((struct ogl_vars *)dmp->dmr_vars)->rgbtab[c].r * 256;
    cell.green = ((struct ogl_vars *)dmp->dmr_vars)->rgbtab[c].g * 256;
    cell.blue = ((struct ogl_vars *)dmp->dmr_vars)->rgbtab[c].b * 256;
    cell.flags = DoRed|DoGreen|DoBlue;
    XStoreColor(((struct ogl_vars *)dmp->dmr_vars)->dpy,
		((struct ogl_vars *)dmp->dmr_vars)->cmap, &cell);
  }
}

static void
print_cmap(dmp)
struct dm *dmp;
{
  int i;
  XColor cell;

  for (i=0; i<112; i++){
    cell.pixel = i;
    XQueryColor(((struct ogl_vars *)dmp->dmr_vars)->dpy,
		((struct ogl_vars *)dmp->dmr_vars)->cmap, &cell);
    printf("%d  = %d %d %d\n",i,cell.red,cell.green,cell.blue);
  }
@


1.5
log
@more pruning
@
text
@a75 4
#ifdef IR_KNOBS
int     Ogl_irlimit();			/* provides knob dead spot */
int     Ogl_add_tol();
#endif
d173 2
a174 1
#define USE_RAMP	(((struct ogl_vars *)dmp->dmr_vars)->mvars.cueing_on || ((struct ogl_vars *)dmp->dmr_vars)->mvars.lighting_on)
d319 2
a320 1
  ((struct ogl_vars *)dmp->dmr_vars)->dpy = Tk_Display(((struct ogl_vars *)dmp->dmr_vars)->xtkwin);
d340 2
a341 1
  ((struct ogl_vars *)dmp->dmr_vars)->win = Tk_WindowId(((struct ogl_vars *)dmp->dmr_vars)->xtkwin);
a1672 28
}
/*
 *			I R L I M I T
 *
 * Because the dials are so sensitive, setting them exactly to
 * zero is very difficult.  This function can be used to extend the
 * location of "zero" into "the dead zone".
 */
int
Ogl_irlimit(i)
int i;
{
  if( i > NOISE )
    return( i-NOISE );
  if( i < -NOISE )
    return( i+NOISE );
  return(0);
}

int
Ogl_add_tol(i)
int i;\
{
  if( i > 0 )
    return( i + NOISE );
  if( i < 0 )
    return( i - NOISE );
  return(0);
@


1.4
log
@changed parameters to dmr_object
@
text
@a126 1
  0,				/* multi-window */
a132 2
  0,
  0,
d239 1
a239 1
    Tk_CreateGenericHandler(dmp->dmr_eventhandler, (ClientData)NULL);
d290 4
a293 2
  ((struct ogl_vars *)dmp->dmr_vars)->width = DisplayWidth(tmp_dpy, DefaultScreen(tmp_dpy)) - 20;
  ((struct ogl_vars *)dmp->dmr_vars)->height = DisplayHeight(tmp_dpy, DefaultScreen(tmp_dpy)) - 20;
d384 2
a385 1
	  Tcl_AppendResult(interp, "Glx_open: Couldn't open the dials+buttons\n", (char *)NULL);
d522 1
a522 1
    Tk_DeleteGenericHandler(dmp->dmr_eventhandler, (ClientData)NULL);
d578 2
a579 1
      glFogi(GL_FOG_MODE, ((struct ogl_vars *)dmp->dmr_vars)->mvars.perspective_mode ? GL_EXP : GL_LINEAR);
d688 4
a691 2
		glViewport(0,  0+YOFFSET_LEFT, ( XMAXSCREEN)+1, ( YSTEREO+YOFFSET_LEFT)-( YOFFSET_LEFT)+1); 
		glScissor(0,  0+YOFFSET_LEFT, ( XMAXSCREEN)+1, ( YSTEREO+YOFFSET_LEFT)-( YOFFSET_LEFT)+1);
a887 1

a1155 3
		/* apply region-id based colors to the solid table */
		dmp->dmr_cfunc();

a1179 3
	/* apply region-id based colors to the solid table */
	dmp->dmr_cfunc();

d1181 2
a1182 1
	if (((struct ogl_vars *)dmp->dmr_vars)->mvars.cueing_on && ((struct ogl_vars *)dmp->dmr_vars)->mvars.lighting_on){
d1191 5
a1195 2
		Ogl_gen_color( dmp, i,
			       ((struct ogl_vars *)dmp->dmr_vars)->rgbtab[i].r,
d1198 1
d1629 1
d1665 1
d1713 2
a1714 1
 *	This routine is not called at all if ((struct ogl_vars *)dmp->dmr_vars)->mvars.rgb is set.
a1745 1

@


1.3
log
@now using more generalized solid macros
@
text
@a80 1
static int	Ogl_setup();
d167 1
a167 4
	glLineWidth((GLfloat) ((struct ogl_vars *)dmp->dmr_vars)->mvars.linewidth);
#if 0
	dmaflag = 1;
#endif
d175 2
a176 4
	glHint(GL_FOG_HINT, ((struct ogl_vars *)dmp->dmr_vars)->mvars.fastfog ? GL_FASTEST : GL_NICEST);
#if 0
	dmaflag = 1;
#endif
d216 8
d241 5
d262 214
a475 1
  return Ogl_setup(dmp);
a515 5
#if 0
  if(dmp->dmr_app_close)
    dmp->dmr_app_close(((struct ogl_vars *)dmp->dmr_vars)->app_vars);
#endif

d743 1
a743 1
Ogl_object( dmp, sp, mat, ratio, white_flag )
d745 6
a750 4
register struct solid *sp;
mat_t mat;
double ratio;
int white_flag;
d752 1
a752 1
	register struct rt_vlist	*vp;
d772 1
a772 1
	if (sp->s_soldash)
d775 1
a775 1
	if (white_flag && ((struct ogl_vars *)dmp->dmr_vars)->mvars.cueing_on)
d779 1
a779 2
		register short	r, g, b;
		if( white_flag )  {
a780 4
		} else {
			r = (short)sp->s_color[0];
			g = (short)sp->s_color[1];
			b = (short)sp->s_color[2];
d804 1
a804 1
		if (white_flag){
d807 1
a807 1
		} else if( (nvec = MAP_ENTRY( sp->s_dmindex )) !=
d825 1
a825 1
	for( BU_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
d827 3
a829 3
		register int	nused = vp->nused;
		register int	*cmd = vp->cmd;
		register point_t *pt = vp->pt;
d877 1
a877 1
	if (sp->s_soldash)
d880 1
a880 1
	if (white_flag && ((struct ogl_vars *)dmp->dmr_vars)->mvars.cueing_on){
a1227 241
/* the font used depends on the size of the window opened */
#define FONTBACK	"-adobe-courier-medium-r-normal--10-100-75-75-m-60-iso8859-1"
#define FONT5	"5x7"
#define FONT6	"6x10"
#define FONT7	"7x13"
#define FONT8	"8x13"
#define FONT9	"9x15"

static int
Ogl_setup( dmp )
struct dm *dmp;
{
  static count = 0;
  char *cp, symbol;
  XGCValues gcv;
  XColor a_color;
  Visual *a_visual;
  int a_screen, num, i, success;
  int major, minor;
  Colormap  a_cmap;
  XVisualInfo *vip;
  int dsize, use, dbfr, rgba, red, blue, green, alpha, index;
  GLfloat backgnd[4];
  long supplied;
  int j, k;
  int ndevices;
  int nclass = 0;
  XDeviceInfoPtr olist, list;
  XDevice *dev;
  XEventClass e_class[15];
  XInputClassInfo *cip;
  struct bu_vls str;
  Display *tmp_dpy;

  bu_vls_init(&str);

  /* Only need to do this once for this display manager */
  if(!count)
    Ogl_load_startup(dmp);

  if(BU_LIST_IS_EMPTY(&head_ogl_vars.l))
    Tk_CreateGenericHandler(dmp->dmr_eventhandler, (ClientData)NULL);

  BU_LIST_APPEND(&head_ogl_vars.l, &((struct ogl_vars *)dmp->dmr_vars)->l);

  bu_vls_printf(&dmp->dmr_pathName, ".dm_ogl%d", count++);

  /* this is important so that Ogl_configure_notify knows to set
   * the font */
  ((struct ogl_vars *)dmp->dmr_vars)->fontstruct = NULL;

  if((tmp_dpy = XOpenDisplay(dmp->dmr_dname)) == NULL){
    bu_vls_free(&str);
    return TCL_ERROR;
  }

  ((struct ogl_vars *)dmp->dmr_vars)->width = DisplayWidth(tmp_dpy, DefaultScreen(tmp_dpy)) - 20;
  ((struct ogl_vars *)dmp->dmr_vars)->height = DisplayHeight(tmp_dpy, DefaultScreen(tmp_dpy)) - 20;

  /* Make window square */
  if(((struct ogl_vars *)dmp->dmr_vars)->height < ((struct ogl_vars *)dmp->dmr_vars)->width)
    ((struct ogl_vars *)dmp->dmr_vars)->width = ((struct ogl_vars *)dmp->dmr_vars)->height;
  else
    ((struct ogl_vars *)dmp->dmr_vars)->height = ((struct ogl_vars *)dmp->dmr_vars)->width;

  XCloseDisplay(tmp_dpy);

  /* Make xtkwin a toplevel window */
  ((struct ogl_vars *)dmp->dmr_vars)->xtkwin =
    Tk_CreateWindowFromPath(interp, tkwin, bu_vls_addr(&dmp->dmr_pathName), dmp->dmr_dname);

  /* Open the display - XXX see what NULL does now */
  if( ((struct ogl_vars *)dmp->dmr_vars)->xtkwin == NULL ) {
    Tcl_AppendResult(interp, "dm-Ogl: Failed to open ", bu_vls_addr(&dmp->dmr_pathName),
		     "\n", (char *)NULL);
    return TCL_ERROR;
  }

  bu_vls_strcpy(&str, "init_ogl ");
  bu_vls_printf(&str, "%s\n", bu_vls_addr(&dmp->dmr_pathName));

  if(Tcl_Eval(interp, bu_vls_addr(&str)) == TCL_ERROR){
    bu_vls_free(&str);
    return TCL_ERROR;
  }

  ((struct ogl_vars *)dmp->dmr_vars)->dpy = Tk_Display(((struct ogl_vars *)dmp->dmr_vars)->xtkwin);

  /* must do this before MakeExist */
  if ((vip=Ogl_set_visual(dmp, ((struct ogl_vars *)dmp->dmr_vars)->xtkwin))==NULL){
    Tcl_AppendResult(interp, "Ogl_open: Can't get an appropriate visual.\n", (char *)NULL);
    return TCL_ERROR;
  }

#if 1
  Tk_GeometryRequest(((struct ogl_vars *)dmp->dmr_vars)->xtkwin,
		     ((struct ogl_vars *)dmp->dmr_vars)->width,
		     ((struct ogl_vars *)dmp->dmr_vars)->height);

  Tk_ResizeWindow(((struct ogl_vars *)dmp->dmr_vars)->xtkwin,
		  ((struct ogl_vars *)dmp->dmr_vars)->width,
		  ((struct ogl_vars *)dmp->dmr_vars)->height);
#endif
  Tk_MoveToplevelWindow(((struct ogl_vars *)dmp->dmr_vars)->xtkwin, 1276 - 976, 0);
  Tk_MakeWindowExist(((struct ogl_vars *)dmp->dmr_vars)->xtkwin);

  ((struct ogl_vars *)dmp->dmr_vars)->win = Tk_WindowId(((struct ogl_vars *)dmp->dmr_vars)->xtkwin);

  a_screen = Tk_ScreenNumber(((struct ogl_vars *)dmp->dmr_vars)->xtkwin);

  /* open GLX context */
  /* If the sgi display manager has been used, then we must use
   * an indirect context. Otherwise use direct, since it is usually
   * faster.
   */
  if ((((struct ogl_vars *)dmp->dmr_vars)->glxc =
       glXCreateContext(((struct ogl_vars *)dmp->dmr_vars)->dpy, vip, 0,
			ogl_sgi_used ? GL_FALSE : GL_TRUE))==NULL) {
    Tcl_AppendResult(interp, "Ogl_open: couldn't create glXContext.\n", (char *)NULL);
    return TCL_ERROR;
  }
  /* If we used an indirect context, then as far as sgi is concerned,
   * gl hasn't been used.
   */
  ((struct ogl_vars *)dmp->dmr_vars)->is_direct =
    (char) glXIsDirect(((struct ogl_vars *)dmp->dmr_vars)->dpy,
		       ((struct ogl_vars *)dmp->dmr_vars)->glxc);
  Tcl_AppendResult(interp, "Using ", ((struct ogl_vars *)dmp->dmr_vars)->is_direct ?
		   "a direct" : "an indirect", " OpenGL rendering context.\n", (char *)NULL);
  /* set ogl_ogl_used if the context was ever direct */
  ogl_ogl_used = (((struct ogl_vars *)dmp->dmr_vars)->is_direct || ogl_ogl_used);

  /*
   * Take a look at the available input devices. We're looking
   * for "dial+buttons".
   */
  olist = list =
    (XDeviceInfoPtr) XListInputDevices (((struct ogl_vars *)dmp->dmr_vars)->dpy, &ndevices);

  /* IRIX 4.0.5 bug workaround */
  if( list == (XDeviceInfoPtr)NULL ||
      list == (XDeviceInfoPtr)1 )  goto Done;

  for(j = 0; j < ndevices; ++j, list++){
    if(list->use == IsXExtensionDevice){
      if(!strcmp(list->name, "dial+buttons")){
	if((dev = XOpenDevice(((struct ogl_vars *)dmp->dmr_vars)->dpy,
			      list->id)) == (XDevice *)NULL){
	  Tcl_AppendResult(interp, "Glx_open: Couldn't open the dials+buttons\n", (char *)NULL);
	  goto Done;
	}

	for(cip = dev->classes, k = 0; k < dev->num_classes;
	    ++k, ++cip){
	  switch(cip->input_class){
#if IR_BUTTONS
	  case ButtonClass:
	    DeviceButtonPress(dev, ((struct ogl_vars *)dmp->dmr_vars)->devbuttonpress,
			      e_class[nclass]);
	    ++nclass;
	    DeviceButtonRelease(dev, ((struct ogl_vars *)dmp->dmr_vars)->devbuttonrelease,
				e_class[nclass]);
	    ++nclass;
	    break;
#endif
#if IR_KNOBS
	  case ValuatorClass:
	    DeviceMotionNotify(dev, ((struct ogl_vars *)dmp->dmr_vars)->devmotionnotify,
			       e_class[nclass]);
	    ++nclass;
	    break;
#endif
	  default:
	    break;
	  }
	}

	XSelectExtensionEvent(((struct ogl_vars *)dmp->dmr_vars)->dpy,
			      ((struct ogl_vars *)dmp->dmr_vars)->win, e_class, nclass);
	goto Done;
      }
    }
  }
Done:
  XFreeDeviceList(olist);

  if (!glXMakeCurrent(((struct ogl_vars *)dmp->dmr_vars)->dpy,
		      ((struct ogl_vars *)dmp->dmr_vars)->win,
		      ((struct ogl_vars *)dmp->dmr_vars)->glxc)){
    Tcl_AppendResult(interp, "Ogl_open: Couldn't make context current\n", (char *)NULL);
    return TCL_ERROR;
  }

  /* display list (fontOffset + char) will displays a given ASCII char */
  if ((((struct ogl_vars *)dmp->dmr_vars)->fontOffset = glGenLists(128))==0){
    Tcl_AppendResult(interp, "dm-ogl: Can't make display lists for font.\n", (char *)NULL);
    return TCL_ERROR;
  }

  /* do viewport, ortho commands and initialize font*/
  Ogl_configure_window_shape(dmp);

  /* Lines will be solid when stippling disabled, dashed when enabled*/
  glLineStipple( 1, 0xCF33);
  glDisable(GL_LINE_STIPPLE);

  backgnd[0] = backgnd[1] = backgnd[2] = backgnd[3] = 0.0;
  glFogi(GL_FOG_MODE, GL_LINEAR);
  glFogf(GL_FOG_START, 0.0);
  glFogf(GL_FOG_END, 2.0);
  if (((struct ogl_vars *)dmp->dmr_vars)->mvars.rgb)
    glFogfv(GL_FOG_COLOR, backgnd);
  else
    glFogi(GL_FOG_INDEX, CMAP_RAMP_WIDTH - 1);
#if 1
  /*XXX Need to do something about VIEWFACTOR */
  glFogf(GL_FOG_DENSITY, VIEWFACTOR);
#else
  glFogf(GL_FOG_DENSITY, 1.0);
#endif

	

  /* Initialize matrices */
  /* Leave it in model_view mode normally */
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  glOrtho(-1.0, 1.0, -1.0, 1.0, 0.0, 2.0);
  glGetDoublev(GL_PROJECTION_MATRIX, ((struct ogl_vars *)dmp->dmr_vars)->faceplate_mat);
  glPushMatrix();
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity(); 
  glTranslatef( 0.0, 0.0, -1.0); 
  glPushMatrix();
  glLoadIdentity();
  ((struct ogl_vars *)dmp->dmr_vars)->face_flag = 1;	/* faceplate matrix is on top of stack */
		
  Tk_MapWindow(((struct ogl_vars *)dmp->dmr_vars)->xtkwin);
  return TCL_OK;
}

a1548 4

#if 0
  dmaflag = 1;
#endif
a1565 4

#if 0
  dmaflag = 1;
#endif	
a1580 3
#if 0
  dmaflag = 1;
#endif
a1614 4

#if 0
  dmaflag = 1;
#endif
@


1.2
log
@changed _dm.h to dm.h,
fixed use of is_direct
@
text
@d57 1
d59 2
a60 3
/*XXX This is just temporary!!! */
#include "../mged/solid.h"
#include "../mged/sedit.h"
a61 3
#define VIEWFACTOR      (1/(*((struct ogl_vars *)dmp->dmr_vars)->viewscale))
#define VIEWSIZE        (2*(*((struct ogl_vars *)dmp->dmr_vars)->viewscale))

d134 3
d146 1
a146 1
static fastf_t default_viewscale = 1.0;
d217 1
a217 1
Ogl_init(dmp, color_func)
d219 2
a220 1
void (*color_func)();
d222 1
a222 4
  dmp->dmr_vars = bu_malloc(sizeof(struct ogl_vars),
			    "Ogl_init: ogl_vars");
  bzero((void *)dmp->dmr_vars, sizeof(struct ogl_vars));

a228 2
  ((struct ogl_vars *)dmp->dmr_vars)->viewscale = &default_viewscale;
  ((struct ogl_vars *)dmp->dmr_vars)->color_func = color_func;
d350 1
a350 1
      fogdepth = 2.2 * (*((struct ogl_vars *)dmp->dmr_vars)->viewscale); /* 2.2 is heuristic */
d357 2
a358 1
      fogdepth = (GLfloat) (0.5*((struct ogl_vars *)dmp->dmr_vars)->mvars.fogdensity/(*((struct ogl_vars *)dmp->dmr_vars)->viewscale));
d943 1
a943 1
		((struct ogl_vars *)dmp->dmr_vars)->color_func();
d970 1
a970 1
	((struct ogl_vars *)dmp->dmr_vars)->color_func();
d1672 1
a1672 1
  FOR_ALL_SOLIDS( sp )  {
@


1.1
log
@Initial revision
@
text
@d55 1
a55 1
#include "_dm.h"
a97 1
char  is_direct = 0;
d1146 2
a1147 2
  Tcl_AppendResult(interp, "Using ", is_direct ? "a direct" : "an indirect",
		   " OpenGL rendering context.\n", (char *)NULL);
@
