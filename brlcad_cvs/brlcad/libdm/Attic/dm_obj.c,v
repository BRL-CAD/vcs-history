head	1.35;
access;
symbols
	ansi-20040405-merged:1.28.2.3
	postmerge-20040405-ansi:1.32
	premerge-20040404-ansi:1.31
	postmerge-autoconf:1.31
	autoconf-freeze:1.29.6.2
	premerge-autoconf:1.31
	ansi-20040316-freeze:1.28.2.1
	postmerge-20040315-windows:1.31
	premerge-20040315-windows:1.30
	windows-20040315-freeze:1.28.4.2
	autoconf-20031203:1.29
	autoconf-20031202:1.29
	autoconf-branch:1.29.0.6
	phong-branch:1.29.0.4
	photonmap-branch:1.29.0.2
	rel-6-1-DP:1.28
	windows-branch:1.28.0.4
	rel-6-0-2:1.26
	ansi-branch:1.28.0.2
	rel-6-0-1-branch:1.26.0.2
	hartley-6-0-post:1.27
	hartley-6-0-pre:1.26
	rel-6-0-1:1.26
	rel-6-0:1.26
	rel-5-4:1.19.2.2
	offsite-5-3-pre:1.24
	rel-5-3:1.19.2.2
	rel-5-2:1.19.2.1
	rel-5-1-branch:1.19.0.2
	rel-5-1:1.19;
locks; strict;
comment	@ * @;


1.35
date	2004.05.21.18.06.26;	author morrison;	state dead;
branches;
next	1.34;

1.34
date	2004.05.10.15.30.44;	author erikg;	state Exp;
branches;
next	1.33;

1.33
date	2004.05.10.15.25.26;	author morrison;	state Exp;
branches;
next	1.32;

1.32
date	2004.04.05.07.45.07;	author morrison;	state Exp;
branches;
next	1.31;

1.31
date	2004.03.16.19.41.54;	author morrison;	state Exp;
branches;
next	1.30;

1.30
date	2004.02.02.17.39.08;	author morrison;	state Exp;
branches;
next	1.29;

1.29
date	2003.04.02.15.06.30;	author jra;	state Exp;
branches
	1.29.6.1;
next	1.28;

1.28
date	2002.08.20.17.07.45;	author jra;	state Exp;
branches
	1.28.2.1
	1.28.4.1;
next	1.27;

1.27
date	2002.08.15.20.54.57;	author hartley;	state Exp;
branches;
next	1.26;

1.26
date	2001.05.02.22.29.09;	author bparker;	state Exp;
branches;
next	1.25;

1.25
date	2001.04.02.21.20.39;	author bparker;	state Exp;
branches;
next	1.24;

1.24
date	2001.03.01.22.51.54;	author bparker;	state Exp;
branches;
next	1.23;

1.23
date	2000.10.18.18.10.33;	author butler;	state Exp;
branches;
next	1.22;

1.22
date	2000.08.31.18.16.42;	author bparker;	state Exp;
branches;
next	1.21;

1.21
date	2000.07.12.03.24.44;	author cjohnson;	state Exp;
branches;
next	1.20;

1.20
date	2000.06.30.20.54.05;	author bparker;	state Exp;
branches;
next	1.19;

1.19
date	2000.05.26.14.33.13;	author bparker;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2000.05.19.18.53.04;	author bparker;	state Exp;
branches;
next	1.17;

1.17
date	2000.05.03.18.47.49;	author bparker;	state Exp;
branches;
next	1.16;

1.16
date	2000.04.20.21.26.27;	author bparker;	state Exp;
branches;
next	1.15;

1.15
date	2000.04.14.03.40.14;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	2000.04.14.00.18.59;	author cjohnson;	state Exp;
branches;
next	1.13;

1.13
date	2000.03.07.22.20.29;	author bparker;	state Exp;
branches;
next	1.12;

1.12
date	2000.02.18.21.09.47;	author bparker;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.28.15.43.24;	author bparker;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.20.18.45.17;	author bparker;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.14.23.50.22;	author bparker;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.10.22.49.45;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	99.12.29.20.53.29;	author jra;	state Exp;
branches;
next	1.6;

1.6
date	99.12.28.15.38.24;	author bparker;	state Exp;
branches;
next	1.5;

1.5
date	99.12.27.21.09.23;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	99.12.20.21.17.35;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	99.12.17.20.07.35;	author bparker;	state Exp;
branches;
next	1.2;

1.2
date	99.12.17.16.36.36;	author bparker;	state Exp;
branches;
next	1.1;

1.1
date	99.12.01.14.00.05;	author bparker;	state Exp;
branches;
next	;

1.19.2.1
date	2000.09.01.17.24.43;	author bparker;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2001.03.01.22.51.16;	author bparker;	state Exp;
branches;
next	;

1.28.2.1
date	2002.09.19.18.01.17;	author morrison;	state Exp;
branches;
next	1.28.2.2;

1.28.2.2
date	2004.03.17.21.16.58;	author morrison;	state Exp;
branches;
next	1.28.2.3;

1.28.2.3
date	2004.04.02.16.05.47;	author morrison;	state Exp;
branches;
next	;

1.28.4.1
date	2002.09.26.23.03.53;	author morrison;	state Exp;
branches;
next	1.28.4.2;

1.28.4.2
date	2004.03.11.23.42.01;	author morrison;	state Exp;
branches;
next	;

1.29.6.1
date	2004.02.12.19.45.18;	author erikg;	state Exp;
branches;
next	1.29.6.2;

1.29.6.2
date	2004.03.18.18.10.27;	author erikg;	state Exp;
branches;
next	;


desc
@@


1.35
log
@moved to src/
@
text
@/*
 *				D M _ O B J . C
 *
 * A display manager object contains the attributes and
 * methods for controlling display managers.
 * 
 * Source -
 *	SLAD CAD Team
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 * Author -
 *	Robert G. Parker
 *
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1997-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <math.h>

#ifdef DM_X
#if 1
#define USE_FBSERV
#endif

#include "tk.h"
#include <X11/Xutil.h>
#else
#include "tcl.h"
#endif

#ifdef WIN32
#include <tkwinport.h>
#endif

#include "machine.h"
#include "externs.h"
#include "cmd.h"                  /* includes bu.h */
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "solid.h"
#include "dm.h"
#include "png.h"
#include "zlib.h"

#ifdef DM_X
#include "dm-X.h"
#include "dm_xvars.h"

#ifdef DM_OGL
#ifndef WIN32
#include <GL/glx.h>
#endif
#include <GL/gl.h>
#include "dm-ogl.h"
#ifdef USE_FBSERV
extern int _ogl_open_existing();
extern int ogl_close_existing();
#endif /* USE_FBSERV */
#endif /* DM_OGL */

#ifdef USE_FBSERV
#ifndef WIN32
/* These functions live in libfb. */
extern int _X24_open_existing();
extern int X24_close_existing();
#endif
extern int fb_refresh();
#endif /* USE_FBSERV */

#endif /* DM_X */

static int dmo_open_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
#if 0
static int dmo_close_tcl();
#endif
static int dmo_drawBegin_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_drawEnd_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_clear_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_normal_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_loadmat_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_drawModelAxes_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_drawViewAxes_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_drawCenterDot_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_drawString_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_drawPoint_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_drawLine_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_drawVList_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_drawSList_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_drawGeom_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_fg_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_bg_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_lineWidth_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_lineStyle_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_configure_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_zclip_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_zbuffer_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_light_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_transparency_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_depthMask_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_bounds_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_perspective_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_debug_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
#ifdef USE_FBSERV
static int dmo_openFb();
static int dmo_closeFb();
static int dmo_listen_tcl();
static int dmo_refreshFb_tcl();
static void dmo_fbs_callback();
#endif
static int dmo_flush_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_sync_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_size_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_get_aspect_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_observer_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_png_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_clearBufferAfter_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);


static struct dm_obj HeadDMObj;	/* head of display manager object list */

static struct bu_cmdtab dmo_cmds[] = {
	{"bg",			dmo_bg_tcl},
	{"bounds",		dmo_bounds_tcl},
	{"clear",		dmo_clear_tcl},
#if 0
	{"close",		dmo_close_tcl},
#endif
	{"configure",		dmo_configure_tcl},
	{"debug",		dmo_debug_tcl},
	{"depthMask",		dmo_depthMask_tcl},
	{"drawBegin",		dmo_drawBegin_tcl},
	{"drawEnd",		dmo_drawEnd_tcl},
	{"drawGeom",		dmo_drawGeom_tcl},
	{"drawLine",		dmo_drawLine_tcl},
	{"drawPoint",		dmo_drawPoint_tcl},
	{"drawSList",		dmo_drawSList_tcl},
	{"drawString",		dmo_drawString_tcl},
	{"drawVList",		dmo_drawVList_tcl},
	{"drawModelAxes",	dmo_drawModelAxes_tcl},
	{"drawViewAxes",	dmo_drawViewAxes_tcl},
	{"drawCenterDot",	dmo_drawCenterDot_tcl},
	{"fg",			dmo_fg_tcl},
	{"flush",		dmo_flush_tcl},
	{"get_aspect",		dmo_get_aspect_tcl},
	{"light",		dmo_light_tcl},
	{"linestyle",		dmo_lineStyle_tcl},
	{"linewidth",		dmo_lineWidth_tcl},
#ifdef USE_FBSERV
	{"listen",		dmo_listen_tcl},
#endif
	{"loadmat",		dmo_loadmat_tcl},
	{"normal",		dmo_normal_tcl},
	{"observer",		dmo_observer_tcl},
	{"perspective",		dmo_perspective_tcl},
	{"png",		        dmo_png_tcl},
#ifdef USE_FBSERV
	{"refreshfb",		dmo_refreshFb_tcl},
#endif
	{"clearBufferAfter",    dmo_clearBufferAfter_tcl},
	{"size",		dmo_size_tcl},
	{"sync",		dmo_sync_tcl},
	{"transparency",	dmo_transparency_tcl},
	{"zbuffer",		dmo_zbuffer_tcl},
	{"zclip",		dmo_zclip_tcl},
	{(char *)0,		(int (*)())0}
};

/*
 *			D M _ C M D
 *
 * Generic interface for display manager object routines.
 * Usage:
 *        objname cmd ?args?
 *
 * Returns: result of DM command.
 */
static int
dmo_cmd(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	return bu_cmd(clientData, interp, argc, argv, dmo_cmds, 1);
}

int
Dmo_Init(Tcl_Interp *interp)
{
	BU_LIST_INIT(&HeadDMObj.l);
	(void)Tcl_CreateCommand(interp, "dm_open", (Tcl_CmdProc *)dmo_open_tcl,(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);

	return TCL_OK;
}

/*
 * Called by Tcl when the object is destroyed.
 */
static void
dmo_deleteProc(ClientData clientData)
{
	struct dm_obj *dmop = (struct dm_obj *)clientData;

	/* free observers */
	bu_observer_free(&dmop->dmo_observers);

#ifdef USE_FBSERV
	/* close framebuffer */
	dmo_closeFb(dmop);
#endif

	bu_vls_free(&dmop->dmo_name);
	DM_CLOSE(dmop->dmo_dmp);
	BU_LIST_DEQUEUE(&dmop->l);
	bu_free((genptr_t)dmop, "dmo_deleteProc: dmop");

}

#if 0
/*
 * Close a display manager object.
 *
 * Usage:
 *	  objname close
 */
static int
dmo_close_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
{
	struct bu_vls vls;
	struct dm_obj *dmop = (struct dm_obj *)clientData;

	if (argc != 2) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dm_close %s", argv[1]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* Among other things, this will call dmo_deleteProc. */
	Tcl_DeleteCommand(interp, bu_vls_addr(&dmop->dmo_name));

	return TCL_OK;
}
#endif

/*
 * Open/create a display manager object.
 *
 * Usage:
 *	  dm_open [name type [args]]
 */
static int
dmo_open_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dm_obj		*dmop;
	struct dm		*dmp;
	struct bu_vls		vls;
	int			name_index = 1;
	int			type;
	Tcl_Obj			*obj;

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);

	if (argc == 1) {
		/* get list of display manager objects */
		for (BU_LIST_FOR(dmop, dm_obj, &HeadDMObj.l))
			Tcl_AppendStringsToObj(obj, bu_vls_addr(&dmop->dmo_name), " ", (char *)NULL);

		Tcl_SetObjResult(interp, obj);
		return TCL_OK;
	}

	if (argc < 3) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dm_open %s", argv[1]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* check to see if display manager object exists */
	for (BU_LIST_FOR(dmop, dm_obj, &HeadDMObj.l)) {
		if (strcmp(argv[name_index],bu_vls_addr(&dmop->dmo_name)) == 0) {
			Tcl_AppendStringsToObj(obj, "dmo_open: ", argv[name_index],
					       " exists.", (char *)NULL);
			Tcl_SetObjResult(interp, obj);
			return TCL_ERROR;
		}
	}

#ifdef DM_X
	/* find display manager type */
	if (argv[2][0] == 'X' || argv[2][0] == 'x')
		type = DM_TYPE_X;
#ifdef DM_OGL
	else if (!strcmp(argv[2], "ogl"))
		type = DM_TYPE_OGL;
#endif /* DM_OGL */
#if 0
	/* XXX - not yet ready to handle these display types */
	else if (!strcmp(argv[2], "ps"))
		type = DM_TYPE_PS;
	else if (!strcmp(argv[2], "plot"))
		type = DM_TYPE_PLOT;
	else if (!strcmp(argv[2], "nu"))
		type = DM_TYPE_NULL;
#endif
	else {
		Tcl_AppendStringsToObj(obj,
				       "Unsupported display manager type - ",
				       argv[2], "\n",
				       "The supported types are: X, ogl, ps, plot and nu",
				       (char *)NULL);
		Tcl_SetObjResult(interp, obj);
		return TCL_ERROR;
	}
#else
	Tcl_AppendStringsToObj(obj, "dmo_open: no supported display types", (char *)NULL);
	Tcl_SetObjResult(interp, obj);
	return TCL_ERROR;
#endif /* DM_X */

	{
		int i;
		int arg_start = 3;
		int newargs = 2;
		int ac;
		char **av;

		ac = argc + newargs;
		av = (char **)bu_malloc(sizeof(char *) * (ac+1), "dmo_open_tcl: av");
		av[0] = argv[0];

		/* Insert new args (i.e. arrange to call init_dm_obj from dm_open()) */
		av[1] = "-i";
		av[2] = "init_dm_obj";

		/*
		 * Stuff name into argument list.
		 */
		av[3] = "-n";
		av[4] = argv[name_index];

		/* copy the rest */
		for (i = arg_start; i < argc; ++i)
			av[i+newargs] = argv[i];
		av[i+newargs] = (char *)NULL;

		if ((dmp = dm_open(interp, type, ac, av)) == DM_NULL) {
			if (Tcl_IsShared(obj))
				obj = Tcl_DuplicateObj(obj);

			Tcl_AppendStringsToObj(obj,
					       "dmo_open_tcl: Failed to open - ",
					       argv[name_index],
					       "\n",
					       (char *)NULL);
			bu_free((genptr_t)av, "dmo_open_tcl: av");

			Tcl_SetObjResult(interp, obj);
			return TCL_ERROR;
		}

		bu_free((genptr_t)av, "dmo_open_tcl: av");
	}

	/* acquire dm_obj struct */
	BU_GETSTRUCT(dmop,dm_obj);

	/* initialize dm_obj */
	bu_vls_init(&dmop->dmo_name);
	bu_vls_strcpy(&dmop->dmo_name,argv[name_index]);
	dmop->dmo_dmp = dmp;
	VSETALL(dmop->dmo_dmp->dm_clipmin, -2048.0);
	VSETALL(dmop->dmo_dmp->dm_clipmax, 2047.0);

#ifdef USE_FBSERV
	dmop->dmo_fbs.fbs_listener.fbsl_fbsp = &dmop->dmo_fbs;
	dmop->dmo_fbs.fbs_listener.fbsl_fd = -1;
	dmop->dmo_fbs.fbs_listener.fbsl_port = -1;
	dmop->dmo_fbs.fbs_fbp = FBIO_NULL;
	dmop->dmo_fbs.fbs_callback = dmo_fbs_callback;
	dmop->dmo_fbs.fbs_clientData = dmop;
#endif

	BU_LIST_INIT(&dmop->dmo_observers.l);

	/* append to list of dm_obj's */
	BU_LIST_APPEND(&HeadDMObj.l,&dmop->l);

	(void)Tcl_CreateCommand(interp,
				bu_vls_addr(&dmop->dmo_name),
				(Tcl_CmdProc *)dmo_cmd,
				(ClientData)dmop,
				dmo_deleteProc);

	/* send Configure event */
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "event generate %s <Configure>; update", bu_vls_addr(&dmop->dmo_name));
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

#ifdef USE_FBSERV
	/* open the framebuffer */
	dmo_openFb(dmop, interp);
#endif

	/* Return new function name as result */
	Tcl_SetResult(interp, bu_vls_addr(&dmop->dmo_name), TCL_VOLATILE);
	return TCL_OK;
}

static int
dmo_parseAxesArgs(Tcl_Interp *interp,
		  int argc,
		  char **argv,
		  fastf_t *viewSize,
		  mat_t rmat,
		  point_t axesPos,
		  fastf_t *axesSize,
		  int *axesColor,
		  int *labelColor,
		  int *lineWidth,
		  int *posOnly,
		  int *threeColor,
		  struct bu_vls *vlsp)
{
  if (sscanf(argv[2], "%lf", viewSize) != 1) {
    bu_vls_printf(vlsp, "parseAxesArgs: bad view size - %s\n", argv[2]);
    return TCL_ERROR;
  }

  if (bn_decode_mat(rmat, argv[3]) != 16) {
    bu_vls_printf(vlsp, "parseAxesArgs: bad rmat - %s\n", argv[3]);
    return TCL_ERROR;
  }

  if (bn_decode_vect(axesPos, argv[4]) != 3) {
    bu_vls_printf(vlsp, "parseAxesArgs: bad axes position - %s\n", argv[4]);
    return TCL_ERROR;
  }

  if (sscanf(argv[5], "%lf", axesSize) != 1) {
    bu_vls_printf(vlsp, "parseAxesArgs: bad axes size - %s\n", argv[5]);
    return TCL_ERROR;
  }

  if (sscanf(argv[6], "%d %d %d",
	     &axesColor[0],
	     &axesColor[1],
	     &axesColor[2]) != 3) {

    bu_vls_printf(vlsp, "parseAxesArgs: bad axes color - %s\n", argv[6]);
    return TCL_ERROR;
  }

  /* validate color */
  if (axesColor[0] < 0 || 255 < axesColor[0] ||
      axesColor[1] < 0 || 255 < axesColor[1] ||
      axesColor[2] < 0 || 255 < axesColor[2]) {

    bu_vls_printf(vlsp, "parseAxesArgs: bad axes color - %s\n", argv[6]);
    return TCL_ERROR;
  }

  if (sscanf(argv[7], "%d %d %d",
	     &labelColor[0],
	     &labelColor[1],
	     &labelColor[2]) != 3) {

    bu_vls_printf(vlsp, "parseAxesArgs: bad label color - %s\n", argv[7]);
    return TCL_ERROR;
  }

  /* validate color */
  if (labelColor[0] < 0 || 255 < labelColor[0] ||
      labelColor[1] < 0 || 255 < labelColor[1] ||
      labelColor[2] < 0 || 255 < labelColor[2]) {

    bu_vls_printf(vlsp, "parseAxesArgs: bad label color - %s\n", argv[7]);
    return TCL_ERROR;
  }

  if (sscanf(argv[8], "%d", lineWidth) != 1) {
    bu_vls_printf(vlsp, "parseAxesArgs: bad line width - %s\n", argv[8]);
    return TCL_ERROR;
  }

  /* validate lineWidth */
  if (*lineWidth < 0) {
    bu_vls_printf(vlsp, "parseAxesArgs: line width must be greater than 0\n");
    return TCL_ERROR;
  }

  /* parse positive only flag */
  if (sscanf(argv[9], "%d", posOnly) != 1) {
    bu_vls_printf(vlsp, "parseModelAxesArgs: bad positive only flag - %s\n", argv[9]);
    return TCL_ERROR;
  }

  /* validate tick enable flag */
  if (*posOnly < 0) {
    bu_vls_printf(vlsp, "parseModelAxesArgs: positive only flag must be >= 0\n");
    return TCL_ERROR;
  }

  /* parse three color flag */
  if (sscanf(argv[10], "%d", threeColor) != 1) {
    bu_vls_printf(vlsp, "parseModelAxesArgs: bad three color flag - %s\n", argv[10]);
    return TCL_ERROR;
  }

  /* validate tick enable flag */
  if (*threeColor < 0) {
    bu_vls_printf(vlsp, "parseModelAxesArgs: three color flag must be >= 0\n");
    return TCL_ERROR;
  }

  return TCL_OK;
}

/*
 * Draw the view axes.
 *
 * Usage:
 *	  objname drawViewAxes args
 *
 */
static int
dmo_drawViewAxes_tcl(ClientData	clientData,
		     Tcl_Interp	*interp,
		     int	argc,
		     char	**argv)
{
  point_t axesPos;
  fastf_t viewSize;
  mat_t rmat;
  fastf_t axesSize;
  int axesColor[3];
  int labelColor[3];
  int lineWidth;
  int posOnly;
  int threeColor;
  struct bu_vls vls;
  struct dm_obj *dmop = (struct dm_obj *)clientData;

  bu_vls_init(&vls);

  if (argc != 11) {
    /* return help message */
    bu_vls_printf(&vls, "helplib_alias dm_drawViewAxes %s", argv[1]);
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if (dmo_parseAxesArgs(interp, argc, argv, &viewSize, rmat, axesPos, &axesSize,
			axesColor, labelColor, &lineWidth,
			&posOnly, &threeColor, &vls) == TCL_ERROR) {
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  dmo_drawAxes_cmd(dmop->dmo_dmp, viewSize, rmat,
		   axesPos, axesSize, axesColor,
		   labelColor, lineWidth,
		   posOnly, /* positive direction only */
		   threeColor, /* three colors (i.e. X-red, Y-green, Z-blue) */
		   0, /* no ticks */
		   0, /* tick len */
		   0, /* major tick len */
		   0, /* tick interval */
		   0, /* ticks per major */
		   NULL, /* tick color */
		   NULL, /* major tick color */
		   0 /* tick threshold */);

  bu_vls_free(&vls);
  return TCL_OK;
}

/*
 * Draw the center dot.
 *
 * Usage:
 *	  drawCenterDot color
 *
 */
static int
dmo_drawCenterDot_cmd(struct dm_obj	*dmop,
		      Tcl_Interp	*interp,
		      int		argc,
		      char 		**argv)
{
    int color[3];

    if (argc != 2) {
	struct bu_vls vls;

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias dm_drawCenterDot %s", argv[1]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
    }

    if (sscanf(argv[1], "%d %d %d",
	       &color[0],
	       &color[1],
	       &color[2]) != 3) {
	struct bu_vls vls;

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "drawCenterDot: bad color - %s\n", argv[1]);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

	return TCL_ERROR;
    }

    /* validate color */
    if (color[0] < 0 || 255 < color[0] ||
	color[1] < 0 || 255 < color[1] ||
	color[2] < 0 || 255 < color[2]) {
	struct bu_vls vls;

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "drawCenterDot: bad color - %s\n", argv[1]);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

	return TCL_ERROR;
    }

    DM_SET_FGCOLOR(dmop->dmo_dmp,
		   color[0],
		   color[1],
		   color[2], 1, 1.0);

    DM_DRAW_POINT_2D(dmop->dmo_dmp, 0.0, 0.0);

    return TCL_OK;
}

/*
 * Draw the center dot.
 *
 * Usage:
 *	  objname drawCenterDot color
 *
 */
static int
dmo_drawCenterDot_tcl(ClientData	clientData,
		      Tcl_Interp	*interp,
		      int		argc,
		      char		**argv)
{
    struct dm_obj *dmop = (struct dm_obj *)clientData;

    return dmo_drawCenterDot_cmd(dmop, interp, argc-1, argv+1);
}

static int
dmo_parseModelAxesArgs(Tcl_Interp *interp,
		       int argc,
		       char **argv,
		       fastf_t *viewSize,
		       mat_t rmat,
		       point_t axesPos,
		       fastf_t *axesSize,
		       int *axesColor,
		       int *labelColor,
		       int *lineWidth,
		       int *posOnly,
		       int *threeColor,
		       mat_t model2view,
		       int *tickEnable,
		       int *tickLength,
		       int *majorTickLength,
		       fastf_t *tickInterval,
		       int *ticksPerMajor,
		       int *tickColor,
		       int *majorTickColor,
		       int *tickThreshold,
		       struct bu_vls *vlsp)
{
  if (dmo_parseAxesArgs(interp, argc, argv, viewSize, rmat, axesPos, axesSize,
			axesColor, labelColor, lineWidth,
			posOnly, threeColor, vlsp) == TCL_ERROR)
    return TCL_ERROR;

  /* parse model to view matrix */
  if (bn_decode_mat(model2view, argv[11]) != 16) {
    bu_vls_printf(vlsp, "parseModelAxesArgs: bad model2view - %s\n", argv[11]);
    return TCL_ERROR;
  }

  /* parse tick enable flag */
  if (sscanf(argv[12], "%d", tickEnable) != 1) {
    bu_vls_printf(vlsp, "parseModelAxesArgs: bad tick enable flag - %s\n", argv[12]);
    return TCL_ERROR;
  }

  /* validate tick enable flag */
  if (*tickEnable < 0) {
    bu_vls_printf(vlsp, "parseModelAxesArgs: tick enable flag must be >= 0\n");
    return TCL_ERROR;
  }

  /* parse tick length */
  if (sscanf(argv[13], "%d", tickLength) != 1) {
    bu_vls_printf(vlsp, "parseModelAxesArgs: bad tick length - %s\n", argv[13]);
    return TCL_ERROR;
  }

  /* validate tick length */
  if (*tickLength < 1) {
    bu_vls_printf(vlsp, "parseModelAxesArgs: tick length must be >= 1\n");
    return TCL_ERROR;
  }

  /* parse major tick length */
  if (sscanf(argv[14], "%d", majorTickLength) != 1) {
    bu_vls_printf(vlsp, "parseModelAxesArgs: bad major tick length - %s\n", argv[14]);
    return TCL_ERROR;
  }

  /* validate major tick length */
  if (*majorTickLength < 1) {
    bu_vls_printf(vlsp, "parseModelAxesArgs: major tick length must be >= 1\n");
    return TCL_ERROR;
  }

  /* parse tick interval */
  if (sscanf(argv[15], "%lf", tickInterval) != 1) {
    bu_vls_printf(vlsp, "parseModelAxesArgs: tick interval must be > 0");
    return TCL_ERROR;
  }

  /* validate tick interval */
  if (*tickInterval <= 0) {
    bu_vls_printf(vlsp, "parseModelAxesArgs: tick interval must be > 0");
    return TCL_ERROR;
  }

  /* parse ticks per major */
  if (sscanf(argv[16], "%d", ticksPerMajor) != 1) {
    bu_vls_printf(vlsp, "parseModelAxesArgs: bad ticks per major - %s\n", argv[16]);
    return TCL_ERROR;
  }

  /* validate ticks per major */
  if (*ticksPerMajor < 0) {
    bu_vls_printf(vlsp, "parseModelAxesArgs: ticks per major must be >= 0\n");
    return TCL_ERROR;
  }

  /* parse tick color */
  if (sscanf(argv[17], "%d %d %d",
	     &tickColor[0],
	     &tickColor[1],
	     &tickColor[2]) != 3) {

    bu_vls_printf(vlsp, "parseModelAxesArgs: bad tick color - %s\n", argv[17]);
    return TCL_ERROR;
  }

  /* validate tick color */
  if (tickColor[0] < 0 || 255 < tickColor[0] ||
      tickColor[1] < 0 || 255 < tickColor[1] ||
      tickColor[2] < 0 || 255 < tickColor[2]) {

    bu_vls_printf(vlsp, "parseModelAxesArgs: bad tick color - %s\n", argv[17]);
    return TCL_ERROR;
  }

  /* parse major tick color */
  if (sscanf(argv[18], "%d %d %d",
	     &majorTickColor[0],
	     &majorTickColor[1],
	     &majorTickColor[2]) != 3) {

    bu_vls_printf(vlsp, "parseModelAxesArgs: bad major tick color - %s\n", argv[18]);
    return TCL_ERROR;
  }

  /* validate tick color */
  if (majorTickColor[0] < 0 || 255 < majorTickColor[0] ||
      majorTickColor[1] < 0 || 255 < majorTickColor[1] ||
      majorTickColor[2] < 0 || 255 < majorTickColor[2]) {

    bu_vls_printf(vlsp, "parseModelAxesArgs: bad major tick color - %s\n", argv[18]);
    return TCL_ERROR;
  }

  /* parse tick threshold */
  if (sscanf(argv[19], "%d", tickThreshold) != 1) {
    bu_vls_printf(vlsp, "parseModelAxesArgs: bad tick threshold - %s\n", argv[19]);
    return TCL_ERROR;
  }

  /* validate tick threshold */
  if (*tickThreshold <= 0) {
    bu_vls_printf(vlsp, "parseModelAxesArgs: tick threshold must be > 0\n");
    return TCL_ERROR;
  }

  return TCL_OK;
}

/*
 * Draw the model axes.
 *
 * Usage:
 *	  objname drawModelAxes args
 *
 */
static int
dmo_drawModelAxes_tcl(ClientData	clientData,
		      Tcl_Interp	*interp,
		      int		argc,
		      char		**argv)
{
  point_t modelAxesPos;
  point_t viewAxesPos;
  fastf_t viewSize;
  mat_t rmat;
  mat_t model2view;
  fastf_t axesSize;
  int axesColor[3];
  int labelColor[3];
  int lineWidth;
  int posOnly;
  int threeColor;
  int tickEnable;
  int tickLength;
  int majorTickLength;
  fastf_t tickInterval;
  int ticksPerMajor;
  int tickColor[3];
  int majorTickColor[3];
  int tickThreshold;
  struct bu_vls vls;
  struct dm_obj *dmop = (struct dm_obj *)clientData;

  bu_vls_init(&vls);

  if (argc != 20) {
    /* return help message */
    bu_vls_printf(&vls, "helplib_alias dm_drawModelAxes %s", argv[1]);
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if (dmo_parseModelAxesArgs(interp, argc, argv,
			     &viewSize, rmat, modelAxesPos,
			     &axesSize, axesColor,
			     labelColor, &lineWidth,
			     &posOnly, &threeColor,
			     model2view, &tickEnable,
			     &tickLength, &majorTickLength,
			     &tickInterval, &ticksPerMajor,
			     tickColor, majorTickColor,
			     &tickThreshold, &vls) == TCL_ERROR) {
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  MAT4X3PNT(viewAxesPos, model2view, modelAxesPos);

  dmo_drawAxes_cmd(dmop->dmo_dmp, viewSize, rmat,
		   viewAxesPos, axesSize, axesColor,
		   labelColor, lineWidth,
		   posOnly, threeColor,
		   tickEnable,
		   tickLength, majorTickLength,
		   tickInterval, ticksPerMajor,
		   tickColor, majorTickColor,
		   tickThreshold);

  bu_vls_free(&vls);
  return TCL_OK;
}

/*
 * Begin the draw cycle.
 *
 * Usage:
 *	  objname drawBegin
 *
 */
static int
dmo_drawBegin_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dm_obj *dmop = (struct dm_obj *)clientData;

	return DM_DRAW_BEGIN(dmop->dmo_dmp);
}

static int
dmo_drawEnd_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dm_obj *dmop = (struct dm_obj *)clientData;

	return DM_DRAW_END(dmop->dmo_dmp);
}

/*
 * End the draw cycle.
 *
 * Usage:
 *	  objname drawEnd
 *
 */
static int
dmo_clear_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dm_obj *dmop = (struct dm_obj *)clientData;
	int status;

	if ((status = DM_DRAW_BEGIN(dmop->dmo_dmp)) != TCL_OK)
		return status;

	return DM_DRAW_END(dmop->dmo_dmp);
}

/*
 * Clear the display.
 *
 * Usage:
 *	  objname clear
 *
 */
static int
dmo_normal_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dm_obj *dmop = (struct dm_obj *)clientData;

	return DM_NORMAL(dmop->dmo_dmp);
}

/*
 * Reset the viewing transform.
 *
 * Usage:
 *	  objname normal
 *
 */
static int
dmo_loadmat_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	mat_t		mat;
	int		which_eye;

	if (argc != 4) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dm_loadmat %s", argv[1]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}


	if (bn_decode_mat(mat, argv[2]) != 16)
		return TCL_ERROR;

	if (sscanf(argv[3], "%d", &which_eye) != 1) {
		Tcl_Obj		*obj;

		obj = Tcl_GetObjResult(interp);
		if (Tcl_IsShared(obj))
			obj = Tcl_DuplicateObj(obj);

		Tcl_AppendStringsToObj(obj, "bad eye value - ", argv[3], (char *)NULL);
		Tcl_SetObjResult(interp, obj);
		return TCL_ERROR;
	}

	return DM_LOADMATRIX(dmop->dmo_dmp,mat,which_eye);
}

/*
 * Load the matrix.
 *
 * Usage:
 *	  objname loadmatrix mat
 *
 */
static int
dmo_drawString_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dm_obj *dmop = (struct dm_obj *)clientData;
	fastf_t x, y;
	int size;
	int use_aspect;

	if (argc != 7) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dm_drawString %s", argv[1]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/*XXX use sscanf */
	x = atof(argv[3]);
	y = atof(argv[4]);
	size = atoi(argv[5]);
	use_aspect = atoi(argv[6]);

	return DM_DRAW_STRING_2D(dmop->dmo_dmp,argv[2],x,y,size,use_aspect);
}

static int
dmo_drawPoint_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	fastf_t		x, y;

	if (argc != 4) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dm_drawPoint %s", argv[1]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/*XXX use sscanf */
	x = atof(argv[2]);
	y = atof(argv[3]);

	return DM_DRAW_POINT_2D(dmop->dmo_dmp,x,y);
}

/*
 * Draw the line.
 *
 * Usage:
 *	  objname drawLine x1 y1 x2 y2
 *
 */
static int
dmo_drawLine_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dm_obj *dmop = (struct dm_obj *)clientData;
	fastf_t x1, y1, x2, y2;

	if (argc != 6) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dm_drawLine %s", argv[1]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/*XXX use sscanf */
	x1 = atof(argv[2]);
	y1 = atof(argv[3]);
	x2 = atof(argv[4]);
	y2 = atof(argv[5]);

	return DM_DRAW_LINE_2D(dmop->dmo_dmp,x1,y1,x2,y2);
}

/*
 * Draw the vlist.
 *
 * Usage:
 *	  objname drawVList vid
 */
static int
dmo_drawVList_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dm_obj *dmop = (struct dm_obj *)clientData;
	struct rt_vlist *vp;

	if (argc != 3) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dm_drawVList %s", argv[1]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if (sscanf(argv[2], "%lu", (unsigned long *)&vp) != 1) {
		Tcl_Obj	*obj;

		obj = Tcl_GetObjResult(interp);
		if (Tcl_IsShared(obj))
			obj = Tcl_DuplicateObj(obj);

		Tcl_AppendStringsToObj(obj, "invalid vlist pointer - ", argv[2], (char *)NULL);
		Tcl_SetObjResult(interp, obj);
		return TCL_ERROR;
	}

	/* XXX this causes a core dump if vp is bogus */
	BN_CK_VLIST_TCL(interp,vp);

	return DM_DRAW_VLIST(dmop->dmo_dmp, vp);
}

static void
dmo_drawSolid(struct dm_obj	*dmop,
	      struct solid	*sp)
{
	if (sp->s_iflag == UP)
		DM_SET_FGCOLOR(dmop->dmo_dmp, 255, 255, 255, 0, sp->s_transparency);
	else
		DM_SET_FGCOLOR(dmop->dmo_dmp,
			       (short)sp->s_color[0],
			       (short)sp->s_color[1],
			       (short)sp->s_color[2], 0, sp->s_transparency);

	DM_DRAW_VLIST(dmop->dmo_dmp, (struct rt_vlist *)&sp->s_vlist);
}


/*
 * Usage:
 *	  objname drawSList hsp
 */
static int
dmo_drawSList(struct dm_obj	*dmop,
	      struct bu_list	*hsp)
{
	struct solid *sp;
	int linestyle = -1;

	if (dmop->dmo_dmp->dm_transparency) {
	  /* First, draw opaque stuff */
	  FOR_ALL_SOLIDS(sp, hsp) {
	    if (sp->s_transparency < 1.0)
	      continue;

	    if (linestyle != sp->s_soldash) {
	      linestyle = sp->s_soldash;
	      DM_SET_LINE_ATTR(dmop->dmo_dmp, dmop->dmo_dmp->dm_lineWidth, linestyle);
	    }

	    dmo_drawSolid(dmop, sp);
	  }

	  /* disable write to depth buffer */
	  DM_SET_DEPTH_MASK(dmop->dmo_dmp, 0);

	  /* Second, draw transparent stuff */
	  FOR_ALL_SOLIDS(sp, hsp) {
	    /* already drawn above */
	    if (sp->s_transparency == 1.0)
	      continue;

	    if (linestyle != sp->s_soldash) {
	      linestyle = sp->s_soldash;
	      DM_SET_LINE_ATTR(dmop->dmo_dmp, dmop->dmo_dmp->dm_lineWidth, linestyle);
	    }

	    dmo_drawSolid(dmop, sp);
	  }

	  /* re-enable write to depth buffer */
	  DM_SET_DEPTH_MASK(dmop->dmo_dmp, 1);
	} else {

	  FOR_ALL_SOLIDS(sp, hsp) {
	    if (linestyle != sp->s_soldash) {
	      linestyle = sp->s_soldash;
	      DM_SET_LINE_ATTR(dmop->dmo_dmp, dmop->dmo_dmp->dm_lineWidth, linestyle);
	    }

	    dmo_drawSolid(dmop, sp);
	  }
	}

	return TCL_OK;
}

/*
 * Usage:
 *	  objname drawSList sid
 */
static int
dmo_drawSList_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_list	*hsp;

	if (argc != 3) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dm_drawSList %s", argv[1]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if (sscanf(argv[2], "%lu", (unsigned long *)&hsp) != 1) {
		Tcl_Obj	*obj;

		obj = Tcl_GetObjResult(interp);
		if (Tcl_IsShared(obj))
			obj = Tcl_DuplicateObj(obj);

		Tcl_AppendStringsToObj(obj, "invalid solid list pointer - ",
				 argv[2], "\n", (char *)NULL);

		Tcl_SetObjResult(interp, obj);
		return TCL_ERROR;
	}
	dmo_drawSList(dmop, hsp);

	return TCL_OK;
}

/*
 * Draw "drawable geometry" objects.
 *
 * Usage:
 *	  objname drawGeom dg_obj(s)
 */
static int
dmo_drawGeom_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dm_obj *dmop = (struct dm_obj *)clientData;
	struct dg_obj *dgop;
	struct bu_vls vls;
	register int i;

	if (argc < 3) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dm_drawGeom %s", argv[1]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	argc -= 2;
	argv += 2;
	for (i = 0; i < argc; ++i) {
		for (BU_LIST_FOR(dgop, dg_obj, &HeadDGObj.l)) {
			if (strcmp(bu_vls_addr(&dgop->dgo_name), argv[i]) == 0) {
				dmo_drawSList(dmop, &dgop->dgo_headSolid);
				break;
			}
		}
	}

	return TCL_OK;
}

/*
 * Get/set the display manager's foreground color.
 *
 * Usage:
 *	  objname fg [rgb]
 */
static int
dmo_fg_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;
	int		r, g, b;
	Tcl_Obj		*obj;

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);

	bu_vls_init(&vls);

	/* get foreground color */
	if (argc == 2) {
		bu_vls_printf(&vls, "%d %d %d",
			      dmop->dmo_dmp->dm_fg[0],
			      dmop->dmo_dmp->dm_fg[1],
			      dmop->dmo_dmp->dm_fg[2]);
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		Tcl_SetObjResult(interp, obj);
		return TCL_OK;
	}

	/* set foreground color */
	if (argc == 3) {
		if (sscanf(argv[2], "%d %d %d", &r, &g, &b) != 3)
			goto bad_color;

		/* validate color */
		if (r < 0 || 255 < r ||
		    g < 0 || 255 < g ||
		    b < 0 || 255 < b)
			goto bad_color;

		bu_vls_free(&vls);
		return DM_SET_FGCOLOR(dmop->dmo_dmp,r,g,b,1,1.0);
	}

	/* wrong number of arguments */
	bu_vls_printf(&vls, "helplib_alias dm_fg %s", argv[1]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;

 bad_color:
	bu_vls_printf(&vls, "bad rgb color - %s\n", argv[2]);
	Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

	Tcl_SetObjResult(interp, obj);
	return TCL_ERROR;
}

/*
 * Get/set the display manager's background color.
 *
 * Usage:
 *	  objname bg [rgb]
 */
static int
dmo_bg_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;
	int		r, g, b;
	Tcl_Obj		*obj;

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);

	bu_vls_init(&vls);

	/* get background color */
	if (argc == 2) {
		bu_vls_printf(&vls, "%d %d %d",
			      dmop->dmo_dmp->dm_bg[0],
			      dmop->dmo_dmp->dm_bg[1],
			      dmop->dmo_dmp->dm_bg[2]);
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		Tcl_SetObjResult(interp, obj);
		return TCL_OK;
	}

	/* set background color */
	if (argc == 3) {
		if (sscanf(argv[2], "%d %d %d", &r, &g, &b) != 3)
			goto bad_color;

		/* validate color */
		if (r < 0 || 255 < r ||
		    g < 0 || 255 < g ||
		    b < 0 || 255 < b)
			goto bad_color;

		bu_vls_free(&vls);
		return DM_SET_BGCOLOR(dmop->dmo_dmp,r,g,b);
	}

	/* wrong number of arguments */
	bu_vls_printf(&vls, "helplib_alias dm_bg %s", argv[1]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;

 bad_color:
	bu_vls_printf(&vls, "bad rgb color - %s\n", argv[2]);
	Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

	Tcl_SetObjResult(interp, obj);
	return TCL_ERROR;
}

/*
 * Get/set the display manager's linewidth.
 *
 * Usage:
 *	  objname linewidth [n]
 */
static int
dmo_lineWidth_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;
	int		lineWidth;
	Tcl_Obj		*obj;

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);

	bu_vls_init(&vls);

	/* get linewidth */
	if (argc == 2) {
		bu_vls_printf(&vls, "%d", dmop->dmo_dmp->dm_lineWidth);
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		Tcl_SetObjResult(interp, obj);
		return TCL_OK;
	}

 	/* set lineWidth */
	if (argc == 3) {
		if (sscanf(argv[2], "%d", &lineWidth) != 1)
			goto bad_lineWidth;

		/* validate lineWidth */
		if (lineWidth < 0 || 20 < lineWidth)
			goto bad_lineWidth;

		bu_vls_free(&vls);
		return DM_SET_LINE_ATTR(dmop->dmo_dmp, lineWidth, dmop->dmo_dmp->dm_lineStyle);
	}

	/* wrong number of arguments */
	bu_vls_printf(&vls, "helplib_alias dm_linewidth %s", argv[1]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;

 bad_lineWidth:
	bu_vls_printf(&vls, "bad linewidth - %s\n", argv[2]);
	Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

	Tcl_SetObjResult(interp, obj);
	return TCL_ERROR;
}

/*
 * Get/set the display manager's linestyle.
 *
 * Usage:
 *	  objname linestyle [0|1]
 */
static int
dmo_lineStyle_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;
	int		linestyle;
	Tcl_Obj		*obj;

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);

	bu_vls_init(&vls);

	/* get linestyle */
	if (argc == 2) {
		bu_vls_printf(&vls, "%d", dmop->dmo_dmp->dm_lineStyle);
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		Tcl_SetObjResult(interp, obj);
		return TCL_OK;
	}

	/* set linestyle */
	if (argc == 3) {
		if (sscanf(argv[2], "%d", &linestyle) != 1)
			goto bad_linestyle;

		/* validate linestyle */
		if (linestyle < 0 || 1 < linestyle)
			goto bad_linestyle;

		bu_vls_free(&vls);
		return DM_SET_LINE_ATTR(dmop->dmo_dmp, dmop->dmo_dmp->dm_lineWidth, linestyle);
	}

	/* wrong number of arguments */
	bu_vls_printf(&vls, "helplib_alias dm_linestyle %1", argv[1]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;

 bad_linestyle:
	bu_vls_printf(&vls, "bad linestyle - %s\n", argv[2]);
	Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

	Tcl_SetObjResult(interp, obj);
	return TCL_ERROR;
}

/*
 * Configure the display manager window. This is typically
 * called as a result of a ConfigureNotify event.
 *
 * Usage:
 *	  objname configure
 */
static int
dmo_configure_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	int		status;

	if (argc != 2) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dm_configure %s", argv[1]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* configure the display manager window */
	status = DM_CONFIGURE_WIN(dmop->dmo_dmp);

#ifdef USE_FBSERV
	/* configure the framebuffer window */
	if (dmop->dmo_fbs.fbs_fbp != FBIO_NULL)
		fb_configureWindow(dmop->dmo_fbs.fbs_fbp,
				   dmop->dmo_dmp->dm_width,
				   dmop->dmo_dmp->dm_height);
#endif

	return status;
}

/*
 * Get/set the display manager's zclip flag.
 *
 * Usage:
 *	  objname zclip [0|1]
 */
static int
dmo_zclip_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;
	int		zclip;
	Tcl_Obj		*obj;

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);

	/* get zclip flag */
	if (argc == 2) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "%d", dmop->dmo_dmp->dm_zclip);
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		Tcl_SetObjResult(interp, obj);
		return TCL_OK;
	}

	/* set zclip flag */
	if (argc == 3) {
		if (sscanf(argv[2], "%d", &zclip) != 1) {
			Tcl_AppendStringsToObj(obj, "dmo_zclip: invalid zclip value - ",
					       argv[2], "\n", (char *)NULL);
			Tcl_SetObjResult(interp, obj);
			return TCL_ERROR;
		}

		dmop->dmo_dmp->dm_zclip = zclip;
		return TCL_OK;
	}

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias dm_zclip %s", argv[1]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
}

/*
 * Get/set the display manager's zbuffer flag.
 *
 * Usage:
 *	  objname zbuffer [0|1]
 */
static int
dmo_zbuffer_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;
	int		zbuffer;
	Tcl_Obj		*obj;

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);

	/* get zbuffer flag */
	if (argc == 2) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "%d", dmop->dmo_dmp->dm_zbuffer);
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		Tcl_SetObjResult(interp, obj);
		return TCL_OK;
	}

	/* set zbuffer flag */
	if (argc == 3) {
		if (sscanf(argv[2], "%d", &zbuffer) != 1) {
			Tcl_AppendStringsToObj(obj, "dmo_zbuffer: invalid zbuffer value - ",
					 argv[2], "\n", (char *)NULL);
			Tcl_SetObjResult(interp, obj);
			return TCL_ERROR;
		}

		DM_SET_ZBUFFER(dmop->dmo_dmp, zbuffer);
		return TCL_OK;
	}

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias dm_zbuffer %s", argv[1]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
}

/*
 * Get/set the display manager's light flag.
 *
 * Usage:
 *	  objname light [0|1]
 */
static int
dmo_light_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;
	int		light;
	Tcl_Obj		*obj;

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);

	/* get light flag */
	if (argc == 2) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "%d", dmop->dmo_dmp->dm_light);
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		Tcl_SetObjResult(interp, obj);
		return TCL_OK;
	}

	/* set light flag */
	if (argc == 3) {
		if (sscanf(argv[2], "%d", &light) != 1) {
			Tcl_AppendStringsToObj(obj, "dmo_light: invalid light value - ",
					 argv[2], "\n", (char *)NULL);

			Tcl_SetObjResult(interp, obj);
			return TCL_ERROR;
		}

		DM_SET_LIGHT(dmop->dmo_dmp, light);
		return TCL_OK;
	}

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias dm_light %s", argv[1]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
}

/*
 * Get/set the display manager's transparency flag.
 *
 * Usage:
 *	  objname transparency [0|1]
 */
static int
dmo_transparency_tcl(ClientData	clientData,
		     Tcl_Interp	*interp,
		     int	argc,
		     char	**argv)
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;
	int		transparency;
	Tcl_Obj		*obj;

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);

	/* get transparency flag */
	if (argc == 2) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "%d", dmop->dmo_dmp->dm_transparency);
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		Tcl_SetObjResult(interp, obj);
		return TCL_OK;
	}

	/* set transparency flag */
	if (argc == 3) {
		if (sscanf(argv[2], "%d", &transparency) != 1) {
			Tcl_AppendStringsToObj(obj, "dmo_transparency: invalid transparency value - ",
					 argv[2], "\n", (char *)NULL);

			Tcl_SetObjResult(interp, obj);
			return TCL_ERROR;
		}

		DM_SET_TRANSPARENCY(dmop->dmo_dmp, transparency);
		return TCL_OK;
	}

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias dm_transparency %s", argv[1]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
}

/*
 * Get/set the display manager's depth mask flag.
 *
 * Usage:
 *	  objname depthMask [0|1]
 */
static int
dmo_depthMask_tcl(ClientData	clientData,
		  Tcl_Interp	*interp,
		  int	argc,
		  char	**argv)
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;
	int		depthMask;
	Tcl_Obj		*obj;

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);

	/* get depthMask flag */
	if (argc == 2) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "%d", dmop->dmo_dmp->dm_depthMask);
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		Tcl_SetObjResult(interp, obj);
		return TCL_OK;
	}

	/* set depthMask flag */
	if (argc == 3) {
		if (sscanf(argv[2], "%d", &depthMask) != 1) {
			Tcl_AppendStringsToObj(obj, "dmo_depthMask: invalid depthMask value - ",
					 argv[2], "\n", (char *)NULL);

			Tcl_SetObjResult(interp, obj);
			return TCL_ERROR;
		}

		DM_SET_DEPTH_MASK(dmop->dmo_dmp, depthMask);
		return TCL_OK;
	}

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias dm_depthMask %s", argv[1]);
  	Tcl_Eval(interp, bu_vls_addr(&vls));
  	bu_vls_free(&vls);
  	return TCL_ERROR;
}

/*
 * Get/set the display manager's window bounds.
 *
 * Usage:
 *	  objname bounds ["xmin xmax ymin ymax zmin zmax"]
 */
static int
dmo_bounds_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;
	vect_t		clipmin, clipmax;
	Tcl_Obj		*obj;

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);

	/* get window bounds */
	if (argc == 2) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "%g %g %g %g %g %g",
			      dmop->dmo_dmp->dm_clipmin[X],
			      dmop->dmo_dmp->dm_clipmax[X],
			      dmop->dmo_dmp->dm_clipmin[Y],
			      dmop->dmo_dmp->dm_clipmax[Y],
			      dmop->dmo_dmp->dm_clipmin[Z],
			      dmop->dmo_dmp->dm_clipmax[Z]);
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		Tcl_SetObjResult(interp, obj);
		return TCL_OK;
	}

	/* set window bounds */
	if (argc == 3) {
		if (sscanf(argv[2], "%lf %lf %lf %lf %lf %lf",
			   &clipmin[X], &clipmax[X],
			   &clipmin[Y], &clipmax[Y],
			   &clipmin[Z], &clipmax[Z]) != 6) {
			Tcl_AppendStringsToObj(obj, "dmo_bounds: invalid bounds - ",
					 argv[2], "\n", (char *)NULL);

			Tcl_SetObjResult(interp, obj);
			return TCL_ERROR;
		}

		VMOVE(dmop->dmo_dmp->dm_clipmin, clipmin);
		VMOVE(dmop->dmo_dmp->dm_clipmax, clipmax);

		/* 
		 * Since dm_bound doesn't appear to be used anywhere,
		 * I'm going to use it for controlling the location
		 * of the zclipping plane in dm-ogl.c. dm-X.c uses
		 * dm_clipmin and dm_clipmax.
		 */
		if (dmop->dmo_dmp->dm_clipmax[2] <= GED_MAX)
		  dmop->dmo_dmp->dm_bound = 1.0;
		else
		  dmop->dmo_dmp->dm_bound = GED_MAX / dmop->dmo_dmp->dm_clipmax[2];

		return TCL_OK;
	}

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias dm_bounds %s", argv[1]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
}

/*
 * Get/set the display manager's perspective mode.
 *
 * Usage:
 *	  objname perspective [n]
 */
static int
dmo_perspective_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;
	int		perspective;
	Tcl_Obj		*obj;

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);

	/* get perspective mode */
	if (argc == 2) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "%d", dmop->dmo_dmp->dm_perspective);
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		Tcl_SetObjResult(interp, obj);
		return TCL_OK;
	}

	/* set perspective mode */
	if (argc == 3) {
		if (sscanf(argv[2], "%d", &perspective) != 1) {
			Tcl_AppendStringsToObj(obj,
					       "dmo_perspective: invalid perspective mode - ",
					       argv[2], "\n", (char *)NULL);

			Tcl_SetObjResult(interp, obj);
			return TCL_ERROR;
		}

		dmop->dmo_dmp->dm_perspective = perspective;
		return TCL_OK;
	}

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias dm_perspective %s", argv[1]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
}


static int
dmo_png_cmd(struct dm_obj	*dmop,
	    Tcl_Interp		*interp,
	    int			argc,
	    char 		**argv)
{
    FILE *fp;
    png_structp png_p;
    png_infop info_p;
    XImage *ximage_p;
    unsigned char **rows;
    unsigned char *idata;
    unsigned char *irow;
    int bytes_per_pixel;
    int bits_per_channel = 8;  /* bits per color channel */
    int i, j, k;
    unsigned char *dbyte0, *dbyte1, *dbyte2, *dbyte3;
    int red_shift;
    int green_shift;
    int blue_shift;
    int red_bits;
    int green_bits;
    int blue_bits;

    if (argc != 2) {
	struct bu_vls vls;

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias dm_png %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
    }

    if ((fp = fopen(argv[1], "w")) == NULL) {
	Tcl_AppendResult(interp, "png: cannot open \"", argv[1], " for writing\n", (char *)NULL);
	return TCL_ERROR;
    }

    png_p = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
    if (!png_p) {
	Tcl_AppendResult(interp, "png: could not create PNG write structure\n", (char *)NULL);
	fclose(fp);
	return TCL_ERROR;
    }

    info_p = png_create_info_struct(png_p);
    if (!info_p) {
	Tcl_AppendResult(interp, "png: could not create PNG info structure\n", (char *)NULL);
	fclose(fp);
	return TCL_ERROR;
    }

    ximage_p = XGetImage(((struct dm_xvars *)dmop->dmo_dmp->dm_vars.pub_vars)->dpy,
			 ((struct dm_xvars *)dmop->dmo_dmp->dm_vars.pub_vars)->win,
			 0, 0,
			 dmop->dmo_dmp->dm_width,
			 dmop->dmo_dmp->dm_height,
			 ~0, ZPixmap); 
    if (!ximage_p) {
	Tcl_AppendResult(interp, "png: could not get XImage\n", (char *)NULL);
	fclose(fp);
	return TCL_ERROR;
    }

#if 0
    bu_log("size of unsigned short - %d\n", sizeof(unsigned short));
    bu_log("size of unsigned int - %d\n", sizeof(unsigned int));
    bu_log("size of unsigned long - %d\n", sizeof(unsigned long));

    bu_log("red mask - %ld\n", ximage_p->red_mask);
    bu_log("green mask - %ld\n", ximage_p->green_mask);
    bu_log("blue mask - %ld\n", ximage_p->blue_mask);
#endif

    bytes_per_pixel = ximage_p->bytes_per_line / ximage_p->width;
    if (bytes_per_pixel == 4) {
	unsigned long mask;
	unsigned long tmask;

	mask = ximage_p->red_mask;
	tmask = 1;
	for (red_shift = 0; red_shift < 32; red_shift++) {
	    if (tmask & mask)
		break;
	    tmask = tmask << 1;
	}

	mask = ximage_p->green_mask;
	tmask = 1;
	for (green_shift = 0; green_shift < 32; green_shift++) {
	    if (tmask & mask)
		break;
	    tmask = tmask << 1;
	}

	mask = ximage_p->blue_mask;
	tmask = 1;
	for (blue_shift = 0; blue_shift < 32; blue_shift++) {
	    if (tmask & mask)
		break;
	    tmask = tmask << 1;
	}
    } else if (bytes_per_pixel == 2) {
	unsigned long mask;
	unsigned long tmask;
	int bpb = 8;   /* bits per byte */

	mask = ximage_p->red_mask;
	tmask = 1;
	for (red_shift = 0; red_shift < 16; red_shift++) {
	    if (tmask & mask)
		break;
	    tmask = tmask << 1;
	}
	for (red_bits = red_shift; red_bits < 16; red_bits++) {
	    if (!(tmask & mask))
		break;
	    tmask = tmask << 1;
	}

	red_bits = red_bits - red_shift;
#if 0
	bu_log("red shift - %d\n", red_shift);
#endif
	if (red_shift == 0)
	    red_shift = red_bits - bpb;
	else
	    red_shift = red_shift - (bpb - red_bits);
#if 0
	bu_log("red shift - %d\n", red_shift);
	bu_log("red bits - %d\n", red_bits);
#endif

	mask = ximage_p->green_mask;
	tmask = 1;
	for (green_shift = 0; green_shift < 16; green_shift++) {
	    if (tmask & mask)
		break;
	    tmask = tmask << 1;
	}
	for (green_bits = green_shift; green_bits < 16; green_bits++) {
	    if (!(tmask & mask))
		break;
	    tmask = tmask << 1;
	}

	green_bits = green_bits - green_shift;
#if 0
	bu_log("green shift- %d\n", green_shift);
#endif
	green_shift = green_shift - (bpb - green_bits);
#if 0
	bu_log("green shift - %d\n", green_shift);
	bu_log("green bits - %d\n", green_bits);
#endif

	mask = ximage_p->blue_mask;
	tmask = 1;
	for (blue_shift = 0; blue_shift < 16; blue_shift++) {
	    if (tmask & mask)
		break;
	    tmask = tmask << 1;
	}
	for (blue_bits = blue_shift; blue_bits < 16; blue_bits++) {
	    if (!(tmask & mask))
		break;
	    tmask = tmask << 1;
	}
	blue_bits = blue_bits - blue_shift;

#if 0
	bu_log("blue shift - %d\n", blue_shift);
#endif
	if (blue_shift == 0)
	    blue_shift = blue_bits - bpb;
	else
	    blue_shift = blue_shift - (bpb - blue_bits);
#if 0
	bu_log("blue shift - %d\n", blue_shift);
	bu_log("blue bits - %d\n", blue_bits);
#endif
    } else {
	struct bu_vls vls;

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "png: %d bytes per pixel is not yet supported\n", bytes_per_pixel);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	fclose(fp);
	bu_vls_free(&vls);

	return TCL_ERROR;
    }

    rows = (unsigned char **)bu_calloc(ximage_p->height, sizeof(unsigned char *), "rows");
    idata = (unsigned char *)bu_calloc(ximage_p->height * ximage_p->width, 4, "png data");

    /* for each scanline */
    for (i = ximage_p->height - 1, j = 0; 0 <= i; --i, ++j) {
	/* irow points to the current scanline in ximage_p */
	irow = (unsigned char *)(ximage_p->data + ((ximage_p->height-i-1)*ximage_p->bytes_per_line));

	if (bytes_per_pixel == 4) {
	    unsigned int pixel;

	    /* rows[j] points to the current scanline in idata */
	    rows[j] = (unsigned char *)(idata + ((ximage_p->height-i-1)*ximage_p->bytes_per_line));

	    /* for each pixel in current scanline of ximage_p */
	    for (k = 0; k < ximage_p->bytes_per_line; k += bytes_per_pixel) {
		pixel = *((unsigned int *)(irow + k));

		dbyte0 = rows[j] + k;
		dbyte1 = dbyte0 + 1;
		dbyte2 = dbyte0 + 2;
		dbyte3 = dbyte0 + 3;

		*dbyte0 = (pixel & ximage_p->red_mask) >> red_shift;
		*dbyte1 = (pixel & ximage_p->green_mask) >> green_shift;
		*dbyte2 = (pixel & ximage_p->blue_mask) >> blue_shift;
		*dbyte3 = 255;
	    }
	} else if (bytes_per_pixel == 2) {
	    unsigned short spixel;
	    unsigned long pixel;

	    /* rows[j] points to the current scanline in idata */
	    rows[j] = (unsigned char *)(idata + ((ximage_p->height-i-1)*ximage_p->bytes_per_line*2));

	    /* for each pixel in current scanline of ximage_p */
	    for (k = 0; k < ximage_p->bytes_per_line; k += bytes_per_pixel) {
		spixel = *((unsigned short *)(irow + k));
		pixel = spixel;

		dbyte0 = rows[j] + k*2;
		dbyte1 = dbyte0 + 1;
		dbyte2 = dbyte0 + 2;
		dbyte3 = dbyte0 + 3;

		if (0 <= red_shift)
		    *dbyte0 = (pixel & ximage_p->red_mask) >> red_shift;
		else
		    *dbyte0 = (pixel & ximage_p->red_mask) << -red_shift;

		*dbyte1 = (pixel & ximage_p->green_mask) >> green_shift;

		if (0 <= blue_shift)
		    *dbyte2 = (pixel & ximage_p->blue_mask) >> blue_shift;
		else
		    *dbyte2 = (pixel & ximage_p->blue_mask) << -blue_shift;

		*dbyte3 = 255;
	    }
	} else {
	    bu_free(rows, "rows");
	    bu_free(idata, "image data");
	    fclose(fp);

	    Tcl_AppendResult(interp, "png: not supported for this platform\n", (char *)NULL);
	    return TCL_ERROR;
	}
    }

    png_init_io(png_p, fp);
    png_set_filter(png_p, 0, PNG_FILTER_NONE);
    png_set_compression_level(png_p, Z_BEST_COMPRESSION);
    png_set_IHDR(png_p, info_p, ximage_p->width, ximage_p->height, bits_per_channel,
		 PNG_COLOR_TYPE_RGB_ALPHA, PNG_INTERLACE_NONE,
		 PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);
    png_set_gAMA(png_p, info_p, 0.77);
    png_write_info(png_p, info_p);
    png_write_image(png_p, rows);
    png_write_end(png_p, NULL);

    bu_free(rows, "rows");
    bu_free(idata, "image data");
    fclose(fp);

    return TCL_OK;
}

/*
 * Write the pixels to a file in png format.
 *
 * Usage:
 *	  objname png args
 *
 */
static int
dmo_png_tcl(ClientData	clientData,
	    Tcl_Interp	*interp,
	    int		argc,
	    char	**argv)
{
    struct dm_obj	*dmop = (struct dm_obj *)clientData;

    return dmo_png_cmd(dmop, interp, argc-1, argv+1);
}

/*
 * Get/set the clearBufferAfter flag.
 *
 * Usage:
 *	  objname clearBufferAfter [flag]
 *
 */
static int
dmo_clearBufferAfter_tcl(ClientData	clientData,
			 Tcl_Interp	*interp,
			 int		argc,
			 char           **argv) {
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;
	int		clearBufferAfter;
	Tcl_Obj		*obj;

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);

	/* get clearBufferAfter flag */
	if (argc == 2) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "%d", dmop->dmo_dmp->dm_clearBufferAfter);
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		Tcl_SetObjResult(interp, obj);
		return TCL_OK;
	}

	/* set clearBufferAfter flag */
	if (argc == 3) {
		if (sscanf(argv[2], "%d", &clearBufferAfter) != 1) {
			Tcl_AppendStringsToObj(obj, "dmo_clearBufferAfter: invalid clearBufferAfter value - ",
					       argv[2], "\n", (char *)NULL);
			Tcl_SetObjResult(interp, obj);
			return TCL_ERROR;
		}

		dmop->dmo_dmp->dm_clearBufferAfter = clearBufferAfter;
		return TCL_OK;
	}

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias dm_clearBufferAfter %s", argv[1]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
}


/*
 * Get/set the display manager's debug level.
 *
 * Usage:
 *	  objname debug [n]
 */
static int
dmo_debug_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;
	int		level;
	Tcl_Obj		*obj;

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);

	/* get debug level */
	if (argc == 2) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "%d", dmop->dmo_dmp->dm_debugLevel);
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		Tcl_SetObjResult(interp, obj);
		return TCL_OK;
	}

	/* set debug level */
	if (argc == 3) {
		if (sscanf(argv[2], "%d", &level) != 1) {
			Tcl_AppendStringsToObj(obj, "dmo_debug: invalid debug level - ",
					 argv[2], "\n", (char *)NULL);

			Tcl_SetObjResult(interp, obj);
			return TCL_ERROR;
		}

		return DM_DEBUG(dmop->dmo_dmp,level);
	}

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias dm_debug %s", argv[1]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
}

#ifdef USE_FBSERV
/*
 * Open/activate the display managers framebuffer.
 */
static int
dmo_openFb(dmop, interp)
     struct dm_obj	*dmop;
     Tcl_Interp		*interp;
{
	char	*X_name = "/dev/X";
#ifdef DM_OGL
	char	*ogl_name = "/dev/ogl";
#endif

	/* already open */
	if (dmop->dmo_fbs.fbs_fbp != FBIO_NULL)
		return TCL_OK;

	if ((dmop->dmo_fbs.fbs_fbp = (FBIO *)calloc(sizeof(FBIO), 1)) == FBIO_NULL) {
		Tcl_Obj	*obj;

		obj = Tcl_GetObjResult(interp);
		if (Tcl_IsShared(obj))
			obj = Tcl_DuplicateObj(obj);

		Tcl_AppendStringsToObj(obj, "openfb: failed to allocate framebuffer memory\n",
				 (char *)NULL);

		Tcl_SetObjResult(interp, obj);
		return TCL_ERROR;
	}

	switch (dmop->dmo_dmp->dm_type) {
#ifndef WIN32
	case DM_TYPE_X:
		*dmop->dmo_fbs.fbs_fbp = X24_interface; /* struct copy */

		dmop->dmo_fbs.fbs_fbp->if_name = malloc((unsigned)strlen(X_name) + 1);
		(void)strcpy(dmop->dmo_fbs.fbs_fbp->if_name, X_name);

		/* Mark OK by filling in magic number */
		dmop->dmo_fbs.fbs_fbp->if_magic = FB_MAGIC;

		_X24_open_existing(dmop->dmo_fbs.fbs_fbp,
				   ((struct dm_xvars *)dmop->dmo_dmp->dm_vars.pub_vars)->dpy,
				   ((struct x_vars *)dmop->dmo_dmp->dm_vars.priv_vars)->pix,
				   ((struct dm_xvars *)dmop->dmo_dmp->dm_vars.pub_vars)->win,
				   ((struct dm_xvars *)dmop->dmo_dmp->dm_vars.pub_vars)->cmap,
				   ((struct dm_xvars *)dmop->dmo_dmp->dm_vars.pub_vars)->vip,
				   dmop->dmo_dmp->dm_width,
				   dmop->dmo_dmp->dm_height,
				   ((struct x_vars *)dmop->dmo_dmp->dm_vars.priv_vars)->gc);
		break;
#endif
#ifdef DM_OGL
	case DM_TYPE_OGL:
		*dmop->dmo_fbs.fbs_fbp = ogl_interface; /* struct copy */

		dmop->dmo_fbs.fbs_fbp->if_name = malloc((unsigned)strlen(ogl_name) + 1);
		(void)strcpy(dmop->dmo_fbs.fbs_fbp->if_name, ogl_name);

		/* Mark OK by filling in magic number */
		dmop->dmo_fbs.fbs_fbp->if_magic = FB_MAGIC;

		_ogl_open_existing(dmop->dmo_fbs.fbs_fbp,
				   ((struct dm_xvars *)dmop->dmo_dmp->dm_vars.pub_vars)->dpy,
				   ((struct dm_xvars *)dmop->dmo_dmp->dm_vars.pub_vars)->win,
				   ((struct dm_xvars *)dmop->dmo_dmp->dm_vars.pub_vars)->cmap,
				   ((struct dm_xvars *)dmop->dmo_dmp->dm_vars.pub_vars)->vip,
				   dmop->dmo_dmp->dm_width,
				   dmop->dmo_dmp->dm_height,
				   ((struct ogl_vars *)dmop->dmo_dmp->dm_vars.priv_vars)->glxc,
				   ((struct ogl_vars *)dmop->dmo_dmp->dm_vars.priv_vars)->mvars.doublebuffer,
				   0);
		break;
#endif
	}

	return TCL_OK;
}

/*
 * Draw the point.
 *
 * Usage:
 *	  objname drawPoint x y
 *
 */
static int
dmo_closeFb(dmop)
     struct dm_obj *dmop;
{
	if (dmop->dmo_fbs.fbs_fbp == FBIO_NULL)
		return TCL_OK;

	_fb_pgflush(dmop->dmo_fbs.fbs_fbp);

	switch (dmop->dmo_dmp->dm_type) {
#ifndef WIN32
	case DM_TYPE_X:
		X24_close_existing(dmop->dmo_fbs.fbs_fbp);
		break;
#endif
#ifdef DM_OGL
	case DM_TYPE_OGL:
		ogl_close_existing(dmop->dmo_fbs.fbs_fbp);
		break;
#endif
	}

	/* free framebuffer memory */
	if (dmop->dmo_fbs.fbs_fbp->if_pbase != PIXEL_NULL)
		free((void *)dmop->dmo_fbs.fbs_fbp->if_pbase);
	free((void *)dmop->dmo_fbs.fbs_fbp->if_name);
	free((void *)dmop->dmo_fbs.fbs_fbp);
	dmop->dmo_fbs.fbs_fbp = FBIO_NULL;

	return TCL_OK;
}

#if 0
/*
 * Close/de-activate the display managers framebuffer.
 *
 * Usage:
 *	  objname closefb
 *
 */
static int
dmo_closeFb_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
{
	struct dm_obj *dmop = (struct dm_obj *)clientData;

	return dmo_closeFb(dmop);
}
#endif

/*
 * Set/get the port used to listen for framebuffer clients.
 *
 * Usage:
 *	  objname listen [port]
 *
 * Returns the port number actually used.
 *
 */
static int
dmo_listen_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;
	Tcl_Obj		*obj;

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);

	bu_vls_init(&vls);

	if (dmop->dmo_fbs.fbs_fbp == FBIO_NULL) {
		bu_vls_printf(&vls, "%s listen: framebuffer not open!\n", argv[0]);
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		Tcl_SetObjResult(interp, obj);
		return TCL_ERROR;
	}

	/* return the port number */
	if (argc == 2) {
		bu_vls_printf(&vls, "%d", dmop->dmo_fbs.fbs_listener.fbsl_port);
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		Tcl_SetObjResult(interp, obj);
		return TCL_OK;
	}

	if (argc == 3) {
		int port;

		if (sscanf(argv[2], "%d", &port) != 1) {
			Tcl_AppendStringsToObj(obj, "listen: bad value - ", argv[2], "\n", (char *)NULL);
			Tcl_SetObjResult(interp, obj);
			return TCL_ERROR;
		}

		if (port >= 0)
			fbs_open(interp, &dmop->dmo_fbs, port);
		else {
			fbs_close(interp, &dmop->dmo_fbs);
		}
		bu_vls_printf(&vls, "%d", dmop->dmo_fbs.fbs_listener.fbsl_port);
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		Tcl_SetObjResult(interp, obj);
		return TCL_OK;
	}

	bu_vls_printf(&vls, "helplib_alias dm_listen %s", argv[1]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
}

/*
 * Refresh the display managers framebuffer.
 *
 * Usage:
 *	  objname refresh
 *
 */
static int
dmo_refreshFb_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;

	if (dmop->dmo_fbs.fbs_fbp == FBIO_NULL) {
		Tcl_Obj	*obj;

		obj = Tcl_GetObjResult(interp);
		if (Tcl_IsShared(obj))
			obj = Tcl_DuplicateObj(obj);

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "%s refresh: framebuffer not open!\n", argv[0]);
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		Tcl_SetObjResult(interp, obj);
		return TCL_ERROR;
	}

	fb_refresh(dmop->dmo_fbs.fbs_fbp, 0, 0,
		   dmop->dmo_dmp->dm_width, dmop->dmo_dmp->dm_height);
  
	return TCL_OK;
}
#endif

/*
 * Flush the output buffer.
 *
 * Usage:
 *	  objname flush
 *
 */
static int
dmo_flush_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
#ifdef DM_X
	struct dm_obj *dmop = (struct dm_obj *)clientData;

	XFlush(((struct dm_xvars *)dmop->dmo_dmp->dm_vars.pub_vars)->dpy);
#endif
  
	return TCL_OK;
}

/*
 * Flush the output buffer and process all events.
 *
 * Usage:
 *	  objname sync
 *
 */
static int
dmo_sync_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
#ifdef DM_X
	struct dm_obj	*dmop = (struct dm_obj *)clientData;

	XSync(((struct dm_xvars *)dmop->dmo_dmp->dm_vars.pub_vars)->dpy, 0);
#endif
  
	return TCL_OK;
}

/*
 * Set/get window size.
 *
 * Usage:
 *	  objname size [width [height]]
 *
 */
static int
dmo_size_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;
	Tcl_Obj		*obj;

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);

	if (argc == 2) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "%d %d", dmop->dmo_dmp->dm_width, dmop->dmo_dmp->dm_height);
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		Tcl_SetObjResult(interp, obj);
		return TCL_OK;
	}

#ifdef DM_X
	if (argc == 3 || argc == 4) {
		int width, height;

		if (sscanf(argv[2], "%d", &width) != 1) {
			Tcl_AppendStringsToObj(obj, "size: bad width - ", argv[2], "\n", (char *)NULL);

			Tcl_SetObjResult(interp, obj);
			return TCL_ERROR;
		}

		if (argc == 3)
			height = width;
		else {
			if (sscanf(argv[3], "%d", &height) != 1) {
				Tcl_AppendStringsToObj(obj, "size: bad height - ", argv[3], "\n", (char *)NULL);
				Tcl_SetObjResult(interp, obj);
				return TCL_ERROR;
			}
		}

		Tk_GeometryRequest(((struct dm_xvars *)dmop->dmo_dmp->dm_vars.pub_vars)->xtkwin,
				   width, height);
		return TCL_OK;
	}

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias dm_size %s", argv[1]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
#else
	/* do nothing for now */
	return TCL_OK;
#endif
}

/*
 * Get window aspect ratio (i.e. width / height)
 *
 * Usage:
 *	  objname get_aspect
 *
 */
static int
dmo_get_aspect_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;
	Tcl_Obj		*obj;

	if (argc != 2) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dm_getaspect %s", argv[1]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "%g", dmop->dmo_dmp->dm_aspect);
	Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

	Tcl_SetObjResult(interp, obj);
	return TCL_OK;
}

/*
 * Attach/detach observers to/from list.
 *
 * Usage:
 *	  objname observer cmd [args]
 *
 */
static int
dmo_observer_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dm_obj *dmop = (struct dm_obj *)clientData;

	if (argc < 3) {
		struct bu_vls vls;

		/* return help message */
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dm_observer %s", argv[1]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	return bu_cmd((ClientData)&dmop->dmo_observers,
		      interp, argc - 2, argv + 2, bu_observer_cmds, 0);
}

#ifdef USE_FBSERV
static void
dmo_fbs_callback(clientData)
     genptr_t clientData;
{
	struct dm_obj *dmop = (struct dm_obj *)clientData;

	bu_observer_notify(dmop->dmo_dmp->dm_interp, &dmop->dmo_observers,
			   bu_vls_addr(&dmop->dmo_name));
}
#endif
@


1.34
log
@change conf.h to a wrapped config.h
@
text
@@


1.33
log
@Bob Parker's view modifications, png framebuffer support, shaded drawing mode
@
text
@d25 5
a29 1
#include "conf.h"
@


1.32
log
@merge of ansi-6-0-branch into HEAD
@
text
@d54 2
d93 3
d110 2
d127 3
d142 1
d151 3
d167 1
d171 1
d174 1
d185 1
a185 1
 *        procname cmd ?args?
d232 1
a232 1
 *	  procname close
d246 1
a246 1
		bu_vls_printf(&vls, "helplib dm_close");
d290 1
a290 1
		bu_vls_printf(&vls, "helplib dm_open");
d429 482
d926 7
d945 7
d960 7
d978 1
a978 1
		bu_vls_printf(&vls, "helplib dm_loadmat");
d1003 7
d1022 1
a1022 1
		bu_vls_printf(&vls, "helplib dm_drawString");
d1047 1
a1047 1
		bu_vls_printf(&vls, "helplib dm_drawPoint");
d1060 7
d1077 1
a1077 1
		bu_vls_printf(&vls, "helplib dm_drawLine");
d1093 2
d1096 1
a1096 1
 *	  procname drawVList vid
d1108 1
a1108 1
		bu_vls_printf(&vls, "helplib dm_drawVList");
d1132 16
d1150 1
a1150 1
 *	  procname drawSList hsp
d1153 2
a1154 1
dmo_drawSList(struct dm_obj *dmop, struct bu_list *hsp)
d1159 40
a1198 13
	FOR_ALL_SOLIDS(sp, hsp) {
		if (linestyle != sp->s_soldash) {
			linestyle = sp->s_soldash;
			DM_SET_LINE_ATTR(dmop->dmo_dmp, dmop->dmo_dmp->dm_lineWidth, linestyle);
		}

		if (sp->s_iflag == UP)
			DM_SET_FGCOLOR(dmop->dmo_dmp, 255, 255, 255, 0);
		else
			DM_SET_FGCOLOR(dmop->dmo_dmp,
				       (short)sp->s_color[0],
				       (short)sp->s_color[1],
				       (short)sp->s_color[2], 0);
d1200 2
a1201 1
		DM_DRAW_VLIST(dmop->dmo_dmp, (struct rt_vlist *)&sp->s_vlist);
d1209 1
a1209 1
 *	  procname drawSList sid
d1221 1
a1221 1
		bu_vls_printf(&vls, "helplib dm_drawSList");
d1249 1
a1249 1
 *	  procname drawGeom dg_obj(s)
d1261 1
a1261 1
		bu_vls_printf(&vls, "helplib dm_drawGeom");
d1285 1
a1285 1
 *	  procname fg [rgb]
d1326 1
a1326 1
		return DM_SET_FGCOLOR(dmop->dmo_dmp,r,g,b,1);
d1330 1
a1330 1
	bu_vls_printf(&vls, "helplib dm_fg");
d1348 1
a1348 1
 *	  procname bg [rgb]
d1393 1
a1393 1
	bu_vls_printf(&vls, "helplib dm_bg");
d1411 1
a1411 1
 *	  procname linewidth [n]
d1418 1
a1418 1
	int		linewidth;
d1437 1
a1437 1
	/* set linewidth */
d1439 2
a1440 2
		if (sscanf(argv[2], "%d", &linewidth) != 1)
			goto bad_linewidth;
d1442 3
a1444 3
		/* validate linewidth */
		if (linewidth < 0 || 20 < linewidth)
			goto bad_linewidth;
d1447 1
a1447 1
		return DM_SET_LINE_ATTR(dmop->dmo_dmp, linewidth, dmop->dmo_dmp->dm_lineStyle);
d1451 1
a1451 1
	bu_vls_printf(&vls, "helplib dm_linewidth");
d1456 1
a1456 1
 bad_linewidth:
d1469 1
a1469 1
 *	  procname linestyle [0|1]
d1509 1
a1509 1
	bu_vls_printf(&vls, "helplib dm_linestyle");
d1528 1
a1528 1
 *	  procname configure
d1540 1
a1540 1
		bu_vls_printf(&vls, "helplib dm_configure");
d1564 1
a1564 1
 *	  procname zclip [0|1]
d1603 1
a1603 1
	bu_vls_printf(&vls, "helplib dm_zclip");
d1613 1
a1613 1
 *	  procname zbuffer [0|1]
d1652 1
a1652 1
	bu_vls_printf(&vls, "helplib dm_zbuffer");
d1662 1
a1662 1
 *	  procname light [0|1]
d1702 1
a1702 1
	bu_vls_printf(&vls, "helplib dm_light");
d1709 106
d1818 1
a1818 1
 *	  procname bounds ["xmin xmax ymin ymax zmin zmax"]
d1864 12
d1880 1
a1880 1
	bu_vls_printf(&vls, "helplib dm_bounds");
d1883 1
d1891 1
a1891 1
 *	  procname perspective [n]
d1932 1
a1932 1
	bu_vls_printf(&vls, "helplib dm_perspective");
d1938 353
d2295 1
a2295 1
 *	  procname debug [n]
d2334 1
a2334 1
	bu_vls_printf(&vls, "helplib dm_debug");
d2421 7
d2465 1
a2465 1
 *	  procname closefb
d2485 1
a2485 1
 *	  procname listen [port]
d2548 1
a2548 1
	bu_vls_printf(&vls, "helplib dm_listen");
d2559 1
a2559 1
 *	  procname refresh
d2599 1
a2599 1
 *	  procname flush
d2618 1
a2618 1
 *	  procname sync
d2637 1
a2637 1
 *	  procname size [width [height]]
d2688 1
a2688 1
	bu_vls_printf(&vls, "helplib dm_size");
d2702 1
a2702 1
 *	  procname get_aspect
d2714 1
a2714 1
		bu_vls_printf(&vls, "helplib dm_getaspect");
d2737 1
a2737 1
 *	  procname observer cmd [args]
d2750 1
a2750 1
		bu_vls_printf(&vls, "helplib dm_observer");
@


1.31
log
@merge of windows-6-0-branch into head
@
text
@d82 1
a82 1
static int dmo_open_tcl(ClientData clientData,Tcl_Interp *interp,int argc,char **argv);
d86 22
a107 22
static int dmo_drawBegin_tcl();
static int dmo_drawEnd_tcl();
static int dmo_clear_tcl();
static int dmo_normal_tcl();
static int dmo_loadmat_tcl();
static int dmo_drawString_tcl();
static int dmo_drawPoint_tcl();
static int dmo_drawLine_tcl();
static int dmo_drawVList_tcl();
static int dmo_drawSList_tcl();
static int dmo_drawGeom_tcl();
static int dmo_fg_tcl();
static int dmo_bg_tcl();
static int dmo_lineWidth_tcl();
static int dmo_lineStyle_tcl();
static int dmo_configure_tcl();
static int dmo_zclip_tcl();
static int dmo_zbuffer_tcl();
static int dmo_light_tcl();
static int dmo_bounds_tcl();
static int dmo_perspective_tcl();
static int dmo_debug_tcl();
d115 5
a119 5
static int dmo_flush_tcl();
static int dmo_sync_tcl();
static int dmo_size_tcl();
static int dmo_get_aspect_tcl();
static int dmo_observer_tcl();
a171 1
#ifndef WIN32
d173 1
a173 13
dmo_cmd(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
#else
static int
dmo_cmd(
     ClientData	clientData,
     Tcl_Interp	*interp,
     int	argc,
     char	**argv)
#endif
d179 1
a179 2
Dmo_Init(interp)
     Tcl_Interp	*interp;
d182 1
a182 2
	(void)Tcl_CreateCommand(interp, "dm_open", dmo_open_tcl,
				(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
a189 1
#ifndef WIN32
d191 1
a191 6
dmo_deleteProc(clientData)
     ClientData	clientData;
#else
static void dmo_deleteProc(ClientData	clientData)
#endif

a247 1
#ifndef WIN32
d249 1
a249 12
dmo_open_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
#else
static int dmo_open_tcl(
     ClientData	clientData,
     Tcl_Interp	*interp,
     int	argc,
     char	**argv)
#endif
d412 1
a412 5
dmo_drawBegin_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d420 1
a420 5
dmo_drawEnd_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d428 1
a428 5
dmo_clear_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d440 1
a440 5
dmo_normal_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d448 1
a448 5
dmo_loadmat_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d484 1
a484 5
dmo_drawString_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d511 1
a511 5
dmo_drawPoint_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d534 1
a534 5
dmo_drawLine_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d563 1
a563 5
dmo_drawVList_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
d601 1
a601 3
dmo_drawSList(dmop, hsp)
     struct dm_obj	*dmop;
     struct bu_list	*hsp;
d631 1
a631 5
dmo_drawSList_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
d671 1
a671 5
dmo_drawGeom_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d707 1
a707 5
dmo_fg_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d770 1
a770 5
dmo_bg_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d833 1
a833 5
dmo_lineWidth_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d891 1
a891 5
dmo_lineStyle_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d950 1
a950 5
dmo_configure_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d986 1
a986 5
dmo_zclip_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d1035 1
a1035 5
dmo_zbuffer_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d1084 1
a1084 5
dmo_light_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d1134 1
a1134 5
dmo_bounds_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d1194 1
a1194 5
dmo_perspective_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d1245 1
a1245 5
dmo_debug_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d1543 1
a1543 5
dmo_flush_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d1562 1
a1562 5
dmo_sync_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d1581 1
a1581 5
dmo_size_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d1646 1
a1646 5
dmo_get_aspect_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d1681 1
a1681 5
dmo_observer_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
@


1.30
log
@update copyright to include span through 2003
@
text
@d42 4
d60 1
d62 1
d72 1
d76 1
d82 1
a82 1
static int dmo_open_tcl();
d172 1
d179 8
d205 1
d209 4
d269 1
d276 7
d1443 1
d1463 1
d1501 1
d1505 1
@


1.29
log
@Added a cast to quiet the compiler
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1997 by the United States Army
@


1.29.6.1
log
@merge from HEAD
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1997-2004 by the United States Army
@


1.29.6.2
log
@merge from head
@
text
@a41 4
#ifdef WIN32
#include <tkwinport.h>
#endif

a55 1
#ifndef WIN32
a56 1
#endif
a65 1
#ifndef WIN32
a68 1
#endif
d74 1
a74 1
static int dmo_open_tcl(ClientData clientData,Tcl_Interp *interp,int argc,char **argv);
a163 1
#ifndef WIN32
a169 8
#else
static int
dmo_cmd(
     ClientData	clientData,
     Tcl_Interp	*interp,
     int	argc,
     char	**argv)
#endif
a187 1
#ifndef WIN32
a190 4
#else
static void dmo_deleteProc(ClientData	clientData)
#endif

a246 1
#ifndef WIN32
a252 7
#else
static int dmo_open_tcl(
     ClientData	clientData,
     Tcl_Interp	*interp,
     int	argc,
     char	**argv)
#endif
a1412 1
#ifndef WIN32
a1431 1
#endif
a1468 1
#ifndef WIN32
a1471 1
#endif
@


1.28
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d394 1
a394 1
				dmo_cmd,
@


1.28.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@a41 4
#ifdef WIN32
#include <tkwinport.h>
#endif

a55 1
#ifndef WIN32
a56 1
#endif
a65 1
#ifndef WIN32
a68 1
#endif
d74 1
a74 1
static int dmo_open_tcl(ClientData clientData,Tcl_Interp *interp,int argc,char **argv);
a163 1
#ifndef WIN32
a169 8
#else
static int
dmo_cmd(
     ClientData	clientData,
     Tcl_Interp	*interp,
     int	argc,
     char	**argv)
#endif
a187 1
#ifndef WIN32
a190 4
#else
static void dmo_deleteProc(ClientData	clientData)
#endif

a246 1
#ifndef WIN32
a252 7
#else
static int dmo_open_tcl(
     ClientData	clientData,
     Tcl_Interp	*interp,
     int	argc,
     char	**argv)
#endif
a1412 1
#ifndef WIN32
a1431 1
#endif
a1468 1
#ifndef WIN32
a1471 1
#endif
@


1.28.4.2
log
@sync to HEAD...
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1997-2004 by the United States Army
d424 1
a424 1
				(Tcl_CmdProc *)dmo_cmd,
@


1.28.2.1
log
@Initial ANSIfication
@
text
@d74 1
a74 1
static int dmo_open_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d78 22
a99 22
static int dmo_drawBegin_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_drawEnd_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_clear_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_normal_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_loadmat_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_drawString_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_drawPoint_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_drawLine_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_drawVList_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_drawSList_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_drawGeom_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_fg_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_bg_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_lineWidth_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_lineStyle_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_configure_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_zclip_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_zbuffer_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_light_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_bounds_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_perspective_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_debug_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d107 5
a111 5
static int dmo_flush_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_sync_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_size_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_get_aspect_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_observer_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d165 5
a169 1
dmo_cmd(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d175 2
a176 1
Dmo_Init(Tcl_Interp *interp)
d189 2
a190 1
dmo_deleteProc(ClientData clientData)
d248 5
a252 1
dmo_open_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d415 5
a419 1
dmo_drawBegin_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d427 5
a431 1
dmo_drawEnd_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d439 5
a443 1
dmo_clear_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d455 5
a459 1
dmo_normal_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d467 5
a471 1
dmo_loadmat_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d507 5
a511 1
dmo_drawString_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d538 5
a542 1
dmo_drawPoint_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d565 5
a569 1
dmo_drawLine_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d598 5
a602 1
dmo_drawVList_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d640 3
a642 1
dmo_drawSList(struct dm_obj *dmop, struct bu_list *hsp)
d672 5
a676 1
dmo_drawSList_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d716 5
a720 1
dmo_drawGeom_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d756 5
a760 1
dmo_fg_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d823 5
a827 1
dmo_bg_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d890 5
a894 1
dmo_lineWidth_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d952 5
a956 1
dmo_lineStyle_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1015 5
a1019 1
dmo_configure_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1055 5
a1059 1
dmo_zclip_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1108 5
a1112 1
dmo_zbuffer_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1161 5
a1165 1
dmo_light_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1215 5
a1219 1
dmo_bounds_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1279 5
a1283 1
dmo_perspective_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1334 5
a1338 1
dmo_debug_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1632 5
a1636 1
dmo_flush_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1655 5
a1659 1
dmo_sync_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1678 5
a1682 1
dmo_size_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1747 5
a1751 1
dmo_get_aspect_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1786 5
a1790 1
dmo_observer_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
@


1.28.2.2
log
@sync branch with HEAD
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1997-2004 by the United States Army
a41 4
#ifdef WIN32
#include <tkwinport.h>
#endif

a55 1
#ifndef WIN32
a56 1
#endif
a65 1
#ifndef WIN32
a68 1
#endif
a163 1
#ifndef WIN32
a182 1
#ifndef WIN32
a240 1
#ifndef WIN32
d384 1
a384 1
				(Tcl_CmdProc *)dmo_cmd,
a1312 1
#ifndef WIN32
a1331 1
#endif
a1368 1
#ifndef WIN32
a1371 1
#endif
@


1.28.2.3
log
@quell warning, fix cvs join mistake
@
text
@d172 1
d183 2
a184 1
	(void)Tcl_CreateCommand(interp, "dm_open", (Tcl_CmdProc *)dmo_open_tcl,(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
d192 1
d251 1
@


1.27
log
@Converted from K&R to ANSI C - RFH
@
text
@d74 1
a74 1
static int dmo_open_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d78 22
a99 22
static int dmo_drawBegin_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_drawEnd_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_clear_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_normal_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_loadmat_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_drawString_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_drawPoint_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_drawLine_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_drawVList_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_drawSList_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_drawGeom_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_fg_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_bg_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_lineWidth_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_lineStyle_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_configure_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_zclip_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_zbuffer_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_light_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_bounds_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_perspective_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_debug_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d107 5
a111 5
static int dmo_flush_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_sync_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_size_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_get_aspect_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dmo_observer_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d165 5
a169 1
dmo_cmd(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d175 2
a176 1
Dmo_Init(Tcl_Interp *interp)
d189 2
a190 1
dmo_deleteProc(ClientData clientData)
d248 5
a252 1
dmo_open_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d415 5
a419 1
dmo_drawBegin_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d427 5
a431 1
dmo_drawEnd_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d439 5
a443 1
dmo_clear_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d455 5
a459 1
dmo_normal_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d467 5
a471 1
dmo_loadmat_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d507 5
a511 1
dmo_drawString_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d538 5
a542 1
dmo_drawPoint_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d565 5
a569 1
dmo_drawLine_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d598 5
a602 1
dmo_drawVList_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d640 3
a642 1
dmo_drawSList(struct dm_obj *dmop, struct bu_list *hsp)
d672 5
a676 1
dmo_drawSList_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d716 5
a720 1
dmo_drawGeom_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d756 5
a760 1
dmo_fg_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d823 5
a827 1
dmo_bg_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d890 5
a894 1
dmo_lineWidth_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d952 5
a956 1
dmo_lineStyle_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1015 5
a1019 1
dmo_configure_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1055 5
a1059 1
dmo_zclip_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1108 5
a1112 1
dmo_zbuffer_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1161 5
a1165 1
dmo_light_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1215 5
a1219 1
dmo_bounds_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1279 5
a1283 1
dmo_perspective_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1334 5
a1338 1
dmo_debug_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1632 5
a1636 1
dmo_flush_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1655 5
a1659 1
dmo_sync_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1678 5
a1682 1
dmo_size_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1747 5
a1751 1
dmo_get_aspect_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1786 5
a1790 1
dmo_observer_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
@


1.26
log
@*- hide the close command
@
text
@d74 1
a74 1
static int dmo_open_tcl();
d78 22
a99 22
static int dmo_drawBegin_tcl();
static int dmo_drawEnd_tcl();
static int dmo_clear_tcl();
static int dmo_normal_tcl();
static int dmo_loadmat_tcl();
static int dmo_drawString_tcl();
static int dmo_drawPoint_tcl();
static int dmo_drawLine_tcl();
static int dmo_drawVList_tcl();
static int dmo_drawSList_tcl();
static int dmo_drawGeom_tcl();
static int dmo_fg_tcl();
static int dmo_bg_tcl();
static int dmo_lineWidth_tcl();
static int dmo_lineStyle_tcl();
static int dmo_configure_tcl();
static int dmo_zclip_tcl();
static int dmo_zbuffer_tcl();
static int dmo_light_tcl();
static int dmo_bounds_tcl();
static int dmo_perspective_tcl();
static int dmo_debug_tcl();
d107 5
a111 5
static int dmo_flush_tcl();
static int dmo_sync_tcl();
static int dmo_size_tcl();
static int dmo_get_aspect_tcl();
static int dmo_observer_tcl();
d165 1
a165 5
dmo_cmd(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d171 1
a171 2
Dmo_Init(interp)
     Tcl_Interp	*interp;
d184 1
a184 2
dmo_deleteProc(clientData)
     ClientData	clientData;
d242 1
a242 5
dmo_open_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d405 1
a405 5
dmo_drawBegin_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d413 1
a413 5
dmo_drawEnd_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d421 1
a421 5
dmo_clear_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d433 1
a433 5
dmo_normal_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d441 1
a441 5
dmo_loadmat_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d477 1
a477 5
dmo_drawString_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d504 1
a504 5
dmo_drawPoint_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d527 1
a527 5
dmo_drawLine_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d556 1
a556 5
dmo_drawVList_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
d594 1
a594 3
dmo_drawSList(dmop, hsp)
     struct dm_obj	*dmop;
     struct bu_list	*hsp;
d624 1
a624 5
dmo_drawSList_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
d664 1
a664 5
dmo_drawGeom_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d700 1
a700 5
dmo_fg_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d763 1
a763 5
dmo_bg_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d826 1
a826 5
dmo_lineWidth_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d884 1
a884 5
dmo_lineStyle_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d943 1
a943 5
dmo_configure_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d979 1
a979 5
dmo_zclip_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d1028 1
a1028 5
dmo_zbuffer_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d1077 1
a1077 5
dmo_light_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d1127 1
a1127 5
dmo_bounds_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d1187 1
a1187 5
dmo_perspective_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d1238 1
a1238 5
dmo_debug_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d1532 1
a1532 5
dmo_flush_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d1551 1
a1551 5
dmo_sync_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d1570 1
a1570 5
dmo_size_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d1635 1
a1635 5
dmo_get_aspect_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d1670 1
a1670 5
dmo_observer_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
@


1.25
log
@*- remove Tk dependencies
@
text
@d75 1
d77 1
d119 1
d121 1
d209 1
d239 1
@


1.24
log
@*- pass extra parameter to _X24_open_existing
@
text
@a23 3
#if 1
#define USE_FBSERV
#endif
d30 6
d38 3
d50 2
a51 1
#ifdef USE_FBSERV
d53 2
d59 5
a63 3
#endif
#include "dm_xvars.h"
#endif
d65 1
a68 2
extern int _ogl_open_existing();
extern int ogl_close_existing();
d70 3
d103 1
a110 2
static void dmo_fbs_callback();

d193 1
d196 1
d286 1
d293 1
a293 1
#endif
d312 5
d371 2
d379 2
d398 1
d401 1
d1031 1
d1037 1
d1632 1
d1636 1
d1655 1
d1659 1
d1696 1
d1727 4
d1803 1
d1813 1
@


1.23
log
@Patches for compiling under RedHat 7.0
@
text
@d1391 1
@


1.22
log
@Mods to rid libdm of two globals: tkwin and interp
@
text
@d29 3
@


1.21
log
@LINT from gcc -Wall.  Includes some modifications to bu.h and fb.h
@
text
@d321 4
a324 1
		if ((dmp = dm_open(type, ac, av)) == DM_NULL) {
a344 1
	dmop->dmo_interp = interp;
d1768 1
a1768 1
	bu_observer_notify(dmop->dmo_interp, &dmop->dmo_observers,
@


1.20
log
@Replace deprecated Tcl_AppendResult stuff with Tcl_Obj stuff.
@
text
@d99 20
a118 20
	"bg",			dmo_bg_tcl,
	"bounds",		dmo_bounds_tcl,
	"clear",		dmo_clear_tcl,
	"close",		dmo_close_tcl,
	"configure",		dmo_configure_tcl,
	"debug",		dmo_debug_tcl,
	"drawBegin",		dmo_drawBegin_tcl,
	"drawEnd",		dmo_drawEnd_tcl,
	"drawGeom",		dmo_drawGeom_tcl,
	"drawLine",		dmo_drawLine_tcl,
	"drawPoint",		dmo_drawPoint_tcl,
	"drawSList",		dmo_drawSList_tcl,
	"drawString",		dmo_drawString_tcl,
	"drawVList",		dmo_drawVList_tcl,
	"fg",			dmo_fg_tcl,
	"flush",		dmo_flush_tcl,
	"get_aspect",		dmo_get_aspect_tcl,
	"light",		dmo_light_tcl,
	"linestyle",		dmo_lineStyle_tcl,
	"linewidth",		dmo_lineWidth_tcl,
d120 1
a120 1
	"listen",		dmo_listen_tcl,
d122 4
a125 4
	"loadmat",		dmo_loadmat_tcl,
	"normal",		dmo_normal_tcl,
	"observer",		dmo_observer_tcl,
	"perspective",		dmo_perspective_tcl,
d127 1
a127 1
	"refreshfb",		dmo_refreshFb_tcl,
d129 5
a133 5
	"size",			dmo_size_tcl,
	"sync",			dmo_sync_tcl,
	"zbuffer",		dmo_zbuffer_tcl,
	"zclip",		dmo_zclip_tcl,
	(char *)0,		(int (*)())0
@


1.19
log
@*- change dm_aspect to dm_getaspect
@
text
@d147 4
a150 4
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d157 1
a157 1
     Tcl_Interp *interp;
d171 1
a171 1
     ClientData clientData;
d196 4
a199 4
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d226 15
a240 10
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
{
	struct dm_obj *dmop;
	struct dm *dmp;
	struct bu_vls vls;
	int name_index = 1;
	int type;
d245 1
a245 1
			Tcl_AppendResult(interp, bu_vls_addr(&dmop->dmo_name), " ", (char *)NULL);
d247 1
d262 3
a264 2
			Tcl_AppendResult(interp, "dmo_open: ", argv[name_index],
					 " exists.", (char *)NULL);
d286 6
a291 4
		Tcl_AppendResult(interp,
				 "Unsupported display manager type - ",
				 argv[2], "\n",
				 "The supported types are: X, ogl, ps, plot and nu", (char *)NULL);
d322 5
a326 5
			Tcl_AppendResult(interp,
					 "dmo_open_tcl: Failed to open - ",
					 argv[name_index],
					 "\n",
					 (char *)NULL);
d328 2
a329 1
      
d373 1
a373 2
	Tcl_ResetResult(interp);
	Tcl_AppendResult(interp, bu_vls_addr(&dmop->dmo_name), (char *)NULL);
d379 4
a382 4
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d391 4
a394 4
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d403 4
a406 4
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d419 4
a422 4
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d431 8
a438 8
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
{
	struct dm_obj *dmop = (struct dm_obj *)clientData;
	mat_t mat;
	int which_eye;
d455 8
a462 1
		Tcl_AppendResult(interp, "bad eye value - ", argv[3], (char *)NULL);
d471 4
a474 4
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d502 4
a505 4
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d507 2
a508 2
	struct dm_obj *dmop = (struct dm_obj *)clientData;
	fastf_t x, y;
d529 4
a532 4
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d562 1
a562 1
     ClientData clientData;
d564 2
a565 2
     int     argc;
     char    **argv;
d581 8
a588 1
		Tcl_AppendResult(interp, "invalid vlist pointer - ", argv[2], (char *)NULL);
d604 2
a605 2
     struct dm_obj *dmop;
     struct bu_list *hsp;
d636 1
a636 1
     ClientData clientData;
d638 2
a639 2
     int     argc;
     char    **argv;
d641 2
a642 2
	struct dm_obj *dmop = (struct dm_obj *)clientData;
	struct bu_list *hsp;
d655 7
a661 1
		Tcl_AppendResult(interp, "invalid solid list pointer - ",
d663 2
d720 13
a732 8
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
{
	struct dm_obj *dmop = (struct dm_obj *)clientData;
	struct bu_vls vls;
	int r, g, b;
d742 1
a742 1
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
d744 2
d772 1
a772 1
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
d775 1
d787 13
a799 8
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
{
	struct dm_obj *dmop = (struct dm_obj *)clientData;
	struct bu_vls vls;
	int r, g, b;
d809 1
a809 1
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
d811 2
d839 1
a839 1
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
d842 1
d854 13
a866 8
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
{
	struct dm_obj *dmop = (struct dm_obj *)clientData;
	struct bu_vls vls;
	int linewidth;
d873 1
a873 1
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
d875 2
d901 1
a901 1
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
d904 1
d916 13
a928 8
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
{
	struct dm_obj *dmop = (struct dm_obj *)clientData;
	struct bu_vls vls;
	int linestyle;
d935 1
a935 1
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
d937 2
d963 1
a963 1
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
d966 1
d979 4
a982 4
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d984 2
a985 2
	struct dm_obj *dmop = (struct dm_obj *)clientData;
	int status;
d1002 3
a1004 3
	  fb_configureWindow(dmop->dmo_fbs.fbs_fbp,
			     dmop->dmo_dmp->dm_width,
			     dmop->dmo_dmp->dm_height);
d1017 13
a1029 8
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
{
	struct dm_obj *dmop = (struct dm_obj *)clientData;
	struct bu_vls vls;
	int zclip;
d1035 1
a1035 1
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
d1037 2
d1045 3
a1047 2
			Tcl_AppendResult(interp, "dmo_zclip: invalid zclip value - ",
					 argv[2], "\n", (char *)NULL);
d1070 13
a1082 8
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
{
	struct dm_obj *dmop = (struct dm_obj *)clientData;
	struct bu_vls vls;
	int zbuffer;
d1088 1
a1088 1
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
d1090 2
d1098 1
a1098 1
			Tcl_AppendResult(interp, "dmo_zbuffer: invalid zbuffer value - ",
d1100 1
d1123 13
a1135 8
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
{
	struct dm_obj *dmop = (struct dm_obj *)clientData;
	struct bu_vls vls;
	int light;
d1141 1
a1141 1
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
d1143 2
d1151 1
a1151 1
			Tcl_AppendResult(interp, "dmo_light: invalid light value - ",
d1153 2
d1177 13
a1189 8
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
{
	struct dm_obj *dmop = (struct dm_obj *)clientData;
	struct bu_vls vls;
	vect_t clipmin, clipmax;
d1201 1
a1201 1
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
d1203 2
d1214 1
a1214 1
			Tcl_AppendResult(interp, "dmo_bounds: invalid bounds - ",
d1216 2
d1241 13
a1253 8
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
{
	struct dm_obj *dmop = (struct dm_obj *)clientData;
	struct bu_vls vls;
	int perspective;
d1259 1
a1259 1
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
d1261 2
d1269 5
a1273 2
			Tcl_AppendResult(interp, "dmo_perspective: invalid perspective mode - ",
					 argv[2], "\n", (char *)NULL);
d1296 13
a1308 8
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
{
	struct dm_obj *dmop = (struct dm_obj *)clientData;
	struct bu_vls vls;
	int level;
d1314 1
a1314 1
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
d1316 2
d1324 1
a1324 1
			Tcl_AppendResult(interp, "dmo_debug: invalid debug level - ",
d1326 2
d1347 2
a1348 2
     struct dm_obj *dmop;
     Tcl_Interp *interp;
d1350 1
a1350 1
	char *X_name = "/dev/X";
d1352 1
a1352 1
	char *ogl_name = "/dev/ogl";
d1359 8
a1366 2
	if((dmop->dmo_fbs.fbs_fbp = (FBIO *)calloc(sizeof(FBIO), 1)) == FBIO_NULL){
		Tcl_AppendResult(interp, "openfb: failed to allocate framebuffer memory\n",
d1368 2
d1481 12
a1492 7
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
{
	struct dm_obj *dmop = (struct dm_obj *)clientData;
	struct bu_vls vls;
d1498 1
a1498 1
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
d1501 1
d1508 1
a1508 1
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
d1511 1
d1519 2
a1520 1
			Tcl_AppendResult(interp, "listen: bad value - ", argv[2], "\n", (char *)NULL);
d1530 1
a1530 1
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
d1533 1
d1553 4
a1556 4
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d1558 2
a1559 2
	struct dm_obj *dmop = (struct dm_obj *)clientData;
	struct bu_vls vls;
d1562 6
d1570 1
a1570 1
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
d1573 1
d1577 2
a1578 1
	fb_refresh(dmop->dmo_fbs.fbs_fbp, 0, 0, dmop->dmo_dmp->dm_width, dmop->dmo_dmp->dm_height);
d1593 4
a1596 4
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d1614 4
a1617 4
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d1619 1
a1619 1
	struct dm_obj *dmop = (struct dm_obj *)clientData;
d1635 12
a1646 7
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
{
	struct dm_obj *dmop = (struct dm_obj *)clientData;
	struct bu_vls vls;
d1651 1
a1651 1
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
d1653 2
d1662 3
a1664 1
			Tcl_AppendResult(interp, "size: bad width - ", argv[2], "\n", (char *)NULL);
d1672 2
a1673 1
				Tcl_AppendResult(interp, "size: bad height - ", argv[3], "\n", (char *)NULL);
d1699 8
a1706 7
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
{
	struct dm_obj *dmop = (struct dm_obj *)clientData;
	struct bu_vls vls;
d1716 4
d1722 1
a1722 1
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
d1725 1
d1738 4
a1741 4
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d1766 2
a1767 1
	bu_observer_notify(dmop->dmo_interp, &dmop->dmo_observers, bu_vls_addr(&dmop->dmo_name));
@


1.19.2.1
log
@Removed two globals: interp and tkwin
@
text
@d99 20
a118 20
	{"bg",			dmo_bg_tcl},
	{"bounds",		dmo_bounds_tcl},
	{"clear",		dmo_clear_tcl},
	{"close",		dmo_close_tcl},
	{"configure",		dmo_configure_tcl},
	{"debug",		dmo_debug_tcl},
	{"drawBegin",		dmo_drawBegin_tcl},
	{"drawEnd",		dmo_drawEnd_tcl},
	{"drawGeom",		dmo_drawGeom_tcl},
	{"drawLine",		dmo_drawLine_tcl},
	{"drawPoint",		dmo_drawPoint_tcl},
	{"drawSList",		dmo_drawSList_tcl},
	{"drawString",		dmo_drawString_tcl},
	{"drawVList",		dmo_drawVList_tcl},
	{"fg",			dmo_fg_tcl},
	{"flush",		dmo_flush_tcl},
	{"get_aspect",		dmo_get_aspect_tcl},
	{"light",		dmo_light_tcl},
	{"linestyle",		dmo_lineStyle_tcl},
	{"linewidth",		dmo_lineWidth_tcl},
d120 1
a120 1
	{"listen",		dmo_listen_tcl},
d122 4
a125 4
	{"loadmat",		dmo_loadmat_tcl},
	{"normal",		dmo_normal_tcl},
	{"observer",		dmo_observer_tcl},
	{"perspective",		dmo_perspective_tcl},
d127 1
a127 1
	{"refreshfb",		dmo_refreshFb_tcl},
d129 5
a133 5
	{"size",		dmo_size_tcl},
	{"sync",		dmo_sync_tcl},
	{"zbuffer",		dmo_zbuffer_tcl},
	{"zclip",		dmo_zclip_tcl},
	{(char *)0,		(int (*)())0}
d147 4
a150 4
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d157 1
a157 1
     Tcl_Interp	*interp;
d171 1
a171 1
     ClientData	clientData;
d196 4
a199 4
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d226 10
a235 15
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
{
	struct dm_obj		*dmop;
	struct dm		*dmp;
	struct bu_vls		vls;
	int			name_index = 1;
	int			type;
	Tcl_Obj			*obj;

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);
d240 1
a240 1
			Tcl_AppendStringsToObj(obj, bu_vls_addr(&dmop->dmo_name), " ", (char *)NULL);
a241 1
		Tcl_SetObjResult(interp, obj);
d256 2
a257 3
			Tcl_AppendStringsToObj(obj, "dmo_open: ", argv[name_index],
					       " exists.", (char *)NULL);
			Tcl_SetObjResult(interp, obj);
d279 4
a282 6
		Tcl_AppendStringsToObj(obj,
				       "Unsupported display manager type - ",
				       argv[2], "\n",
				       "The supported types are: X, ogl, ps, plot and nu",
				       (char *)NULL);
		Tcl_SetObjResult(interp, obj);
d312 6
a317 9
		if ((dmp = dm_open(interp, type, ac, av)) == DM_NULL) {
			if (Tcl_IsShared(obj))
				obj = Tcl_DuplicateObj(obj);

			Tcl_AppendStringsToObj(obj,
					       "dmo_open_tcl: Failed to open - ",
					       argv[name_index],
					       "\n",
					       (char *)NULL);
d319 1
a319 2

			Tcl_SetObjResult(interp, obj);
d332 1
d363 2
a364 1
	Tcl_SetResult(interp, bu_vls_addr(&dmop->dmo_name), TCL_VOLATILE);
d370 4
a373 4
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d382 4
a385 4
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d394 4
a397 4
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d410 4
a413 4
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d422 8
a429 8
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	mat_t		mat;
	int		which_eye;
d446 1
a446 8
		Tcl_Obj		*obj;

		obj = Tcl_GetObjResult(interp);
		if (Tcl_IsShared(obj))
			obj = Tcl_DuplicateObj(obj);

		Tcl_AppendStringsToObj(obj, "bad eye value - ", argv[3], (char *)NULL);
		Tcl_SetObjResult(interp, obj);
d455 4
a458 4
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d486 4
a489 4
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d491 2
a492 2
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	fastf_t		x, y;
d513 4
a516 4
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d546 1
a546 1
     ClientData	clientData;
d548 2
a549 2
     int	argc;
     char	**argv;
d565 1
a565 8
		Tcl_Obj	*obj;

		obj = Tcl_GetObjResult(interp);
		if (Tcl_IsShared(obj))
			obj = Tcl_DuplicateObj(obj);

		Tcl_AppendStringsToObj(obj, "invalid vlist pointer - ", argv[2], (char *)NULL);
		Tcl_SetObjResult(interp, obj);
d581 2
a582 2
     struct dm_obj	*dmop;
     struct bu_list	*hsp;
d613 1
a613 1
     ClientData	clientData;
d615 2
a616 2
     int	argc;
     char	**argv;
d618 2
a619 2
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_list	*hsp;
d632 1
a632 7
		Tcl_Obj	*obj;

		obj = Tcl_GetObjResult(interp);
		if (Tcl_IsShared(obj))
			obj = Tcl_DuplicateObj(obj);

		Tcl_AppendStringsToObj(obj, "invalid solid list pointer - ",
a633 2

		Tcl_SetObjResult(interp, obj);
d689 8
a696 13
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;
	int		r, g, b;
	Tcl_Obj		*obj;

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);
d706 1
a706 1
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
a707 2

		Tcl_SetObjResult(interp, obj);
d734 1
a734 1
	Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
a736 1
	Tcl_SetObjResult(interp, obj);
d748 8
a755 13
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;
	int		r, g, b;
	Tcl_Obj		*obj;

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);
d765 1
a765 1
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
a766 2

		Tcl_SetObjResult(interp, obj);
d793 1
a793 1
	Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
a795 1
	Tcl_SetObjResult(interp, obj);
d807 8
a814 13
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;
	int		linewidth;
	Tcl_Obj		*obj;

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);
d821 1
a821 1
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
a822 2

		Tcl_SetObjResult(interp, obj);
d847 1
a847 1
	Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
a849 1
	Tcl_SetObjResult(interp, obj);
d861 8
a868 13
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;
	int		linestyle;
	Tcl_Obj		*obj;

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);
d875 1
a875 1
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
a876 2

		Tcl_SetObjResult(interp, obj);
d901 1
a901 1
	Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
a903 1
	Tcl_SetObjResult(interp, obj);
d916 4
a919 4
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d921 2
a922 2
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	int		status;
d939 3
a941 3
		fb_configureWindow(dmop->dmo_fbs.fbs_fbp,
				   dmop->dmo_dmp->dm_width,
				   dmop->dmo_dmp->dm_height);
d954 8
a961 13
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;
	int		zclip;
	Tcl_Obj		*obj;

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);
d967 1
a967 1
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
a968 2

		Tcl_SetObjResult(interp, obj);
d975 2
a976 3
			Tcl_AppendStringsToObj(obj, "dmo_zclip: invalid zclip value - ",
					       argv[2], "\n", (char *)NULL);
			Tcl_SetObjResult(interp, obj);
d999 8
a1006 13
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;
	int		zbuffer;
	Tcl_Obj		*obj;

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);
d1012 1
a1012 1
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
a1013 2

		Tcl_SetObjResult(interp, obj);
d1020 1
a1020 1
			Tcl_AppendStringsToObj(obj, "dmo_zbuffer: invalid zbuffer value - ",
a1021 1
			Tcl_SetObjResult(interp, obj);
d1044 8
a1051 13
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;
	int		light;
	Tcl_Obj		*obj;

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);
d1057 1
a1057 1
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
a1058 2

		Tcl_SetObjResult(interp, obj);
d1065 1
a1065 1
			Tcl_AppendStringsToObj(obj, "dmo_light: invalid light value - ",
a1066 2

			Tcl_SetObjResult(interp, obj);
d1089 8
a1096 13
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;
	vect_t		clipmin, clipmax;
	Tcl_Obj		*obj;

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);
d1108 1
a1108 1
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
a1109 2

		Tcl_SetObjResult(interp, obj);
d1119 1
a1119 1
			Tcl_AppendStringsToObj(obj, "dmo_bounds: invalid bounds - ",
a1120 2

			Tcl_SetObjResult(interp, obj);
d1144 8
a1151 13
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;
	int		perspective;
	Tcl_Obj		*obj;

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);
d1157 1
a1157 1
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
a1158 2

		Tcl_SetObjResult(interp, obj);
d1165 2
a1166 5
			Tcl_AppendStringsToObj(obj,
					       "dmo_perspective: invalid perspective mode - ",
					       argv[2], "\n", (char *)NULL);

			Tcl_SetObjResult(interp, obj);
d1189 8
a1196 13
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;
	int		level;
	Tcl_Obj		*obj;

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);
d1202 1
a1202 1
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
a1203 2

		Tcl_SetObjResult(interp, obj);
d1210 1
a1210 1
			Tcl_AppendStringsToObj(obj, "dmo_debug: invalid debug level - ",
a1211 2

			Tcl_SetObjResult(interp, obj);
d1231 2
a1232 2
     struct dm_obj	*dmop;
     Tcl_Interp		*interp;
d1234 1
a1234 1
	char	*X_name = "/dev/X";
d1236 1
a1236 1
	char	*ogl_name = "/dev/ogl";
d1243 2
a1244 8
	if ((dmop->dmo_fbs.fbs_fbp = (FBIO *)calloc(sizeof(FBIO), 1)) == FBIO_NULL) {
		Tcl_Obj	*obj;

		obj = Tcl_GetObjResult(interp);
		if (Tcl_IsShared(obj))
			obj = Tcl_DuplicateObj(obj);

		Tcl_AppendStringsToObj(obj, "openfb: failed to allocate framebuffer memory\n",
a1245 2

		Tcl_SetObjResult(interp, obj);
d1357 7
a1363 12
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;
	Tcl_Obj		*obj;

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);
d1369 1
a1369 1
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
a1371 1
		Tcl_SetObjResult(interp, obj);
d1378 1
a1378 1
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
a1380 1
		Tcl_SetObjResult(interp, obj);
d1388 1
a1388 2
			Tcl_AppendStringsToObj(obj, "listen: bad value - ", argv[2], "\n", (char *)NULL);
			Tcl_SetObjResult(interp, obj);
d1398 1
a1398 1
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
a1400 1
		Tcl_SetObjResult(interp, obj);
d1420 4
a1423 4
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d1425 2
a1426 2
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;
a1428 6
		Tcl_Obj	*obj;

		obj = Tcl_GetObjResult(interp);
		if (Tcl_IsShared(obj))
			obj = Tcl_DuplicateObj(obj);

d1431 1
a1431 1
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
a1433 1
		Tcl_SetObjResult(interp, obj);
d1437 1
a1437 2
	fb_refresh(dmop->dmo_fbs.fbs_fbp, 0, 0,
		   dmop->dmo_dmp->dm_width, dmop->dmo_dmp->dm_height);
d1452 4
a1455 4
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d1473 4
a1476 4
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d1478 1
a1478 1
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
d1494 7
a1500 12
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;
	Tcl_Obj		*obj;

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);
d1505 1
a1505 1
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
a1506 2

		Tcl_SetObjResult(interp, obj);
d1514 1
a1514 3
			Tcl_AppendStringsToObj(obj, "size: bad width - ", argv[2], "\n", (char *)NULL);

			Tcl_SetObjResult(interp, obj);
d1522 1
a1522 2
				Tcl_AppendStringsToObj(obj, "size: bad height - ", argv[3], "\n", (char *)NULL);
				Tcl_SetObjResult(interp, obj);
d1548 7
a1554 8
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
{
	struct dm_obj	*dmop = (struct dm_obj *)clientData;
	struct bu_vls	vls;
	Tcl_Obj		*obj;
a1563 4
	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);

d1566 1
a1566 1
	Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
a1568 1
	Tcl_SetObjResult(interp, obj);
d1581 4
a1584 4
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d1609 1
a1609 2
	bu_observer_notify(dmop->dmo_dmp->dm_interp, &dmop->dmo_observers,
			   bu_vls_addr(&dmop->dmo_name));
@


1.19.2.2
log
@*- pass extra parameter to _X24_open_existing
@
text
@a1387 1
				   ((struct dm_xvars *)dmop->dmo_dmp->dm_vars.pub_vars)->win,
@


1.18
log
@*- alphabetize command list
@
text
@d1558 1
a1558 1
		bu_vls_printf(&vls, "helplib dm_aspect");
@


1.17
log
@*- remove extra comments
@
text
@d99 6
d107 4
a110 3
	"clear",		dmo_clear_tcl,
	"normal",		dmo_normal_tcl,
	"loadmat",		dmo_loadmat_tcl,
a111 2
	"drawPoint",		dmo_drawPoint_tcl,
	"drawLine",		dmo_drawLine_tcl,
a112 2
	"drawSList",		dmo_drawSList_tcl,
	"drawGeom",		dmo_drawGeom_tcl,
d114 4
a117 1
	"bg",			dmo_bg_tcl,
d119 6
a124 6
	"linestyle",		dmo_lineStyle_tcl,
	"configure",		dmo_configure_tcl,
	"light",		dmo_light_tcl,
	"zbuffer",		dmo_zbuffer_tcl,
	"zclip",		dmo_zclip_tcl,
	"bounds",		dmo_bounds_tcl,
a125 1
	"debug",		dmo_debug_tcl,
a126 5
#if 0
	"openfb",		dmo_openFb_tcl,
	"closefb",		dmo_closeFb_tcl,
#endif
	"listen",		dmo_listen_tcl,
d129 1
a129 1
	"flush",		dmo_flush_tcl,
d131 2
a132 4
	"close",		dmo_close_tcl,
	"size",			dmo_size_tcl,
	"get_aspect",		dmo_get_aspect_tcl,
	"observer",		dmo_observer_tcl,
@


1.16
log
@*- comment out display manager types
   that are not ready
@
text
@a14 4
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
@


1.15
log
@
Fixed stray type mismatch
@
text
@d275 2
d283 1
@


1.14
log
@#include solid.h was removed from raytrace.h so it is no longer
implicitly included here.  Add an explicte include here.
@
text
@d585 1
a585 1
     struct solid *hsp;
d590 1
a590 1
	FOR_ALL_SOLIDS(sp, &hsp->l) {
d622 1
a622 1
	struct solid *hsp;
@


1.13
log
@*- modified dmo_drawSList to use s_iflag
@
text
@d43 1
@


1.12
log
@*- observer command
@
text
@d595 8
a602 4
		DM_SET_FGCOLOR(dmop->dmo_dmp,
			       (short)sp->s_color[0],
			       (short)sp->s_color[1],
			       (short)sp->s_color[2], 0);
@


1.11
log
@*- added callback when framebuffer receives data
*- modified size command
@
text
@d94 2
a95 1
static int dmo_aspect_tcl();
d136 2
a137 1
	"aspect",		dmo_aspect_tcl,
d180 3
d344 1
d1345 1
a1345 1
 * Listen for framebuffer clients.
d1348 1
a1348 1
 *	  procname listen port
d1541 1
a1541 1
 *	  procname aspect
d1545 1
a1545 1
dmo_aspect_tcl(clientData, interp, argc, argv)
d1570 31
a1605 1
	struct bu_vls vls;
d1607 1
a1607 4
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "fbs_callback %s", bu_vls_addr(&dmop->dmo_name));
	Tcl_Eval(dmop->dmo_interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
@


1.10
log
@*- always open a framebuffer
@
text
@d96 2
d329 1
d337 2
d1478 1
a1478 1
 * Get window size (i.e. width and height)
d1481 1
a1481 1
 *	  procname size
d1494 1
a1494 1
	if (argc != 2) {
d1496 2
a1497 2
		bu_vls_printf(&vls, "helplib dm_size");
		Tcl_Eval(interp, bu_vls_addr(&vls));
d1499 23
a1521 1
		return TCL_ERROR;
d1525 2
a1526 2
	bu_vls_printf(&vls, "%d %d", dmop->dmo_dmp->dm_width, dmop->dmo_dmp->dm_height);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
d1528 1
a1528 2

	return TCL_OK;
d1562 13
@


1.9
log
@*- clean up
@
text
@d86 1
a86 1
static int dmo_openFb_tcl();
a87 1
static int dmo_closeFb_tcl();
d122 1
d125 1
d148 4
a151 4
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d153 1
a153 1
  return bu_cmd(clientData, interp, argc, argv, dmo_cmds, 1);
d158 1
a158 1
Tcl_Interp *interp;
d160 3
a162 3
  BU_LIST_INIT(&HeadDMObj.l);
  (void)Tcl_CreateCommand(interp, "dm_open", dmo_open_tcl,
			  (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
d164 1
a164 1
  return TCL_OK;
d172 1
a172 1
ClientData clientData;
d174 1
a174 1
  struct dm_obj *dmop = (struct dm_obj *)clientData;
d176 7
a182 5
  dmo_closeFb(dmop);
  bu_vls_free(&dmop->dmo_name);
  DM_CLOSE(dmop->dmo_dmp);
  BU_LIST_DEQUEUE(&dmop->l);
  bu_free((genptr_t)dmop, "dmo_deleteProc: dmop");
d194 4
a197 4
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d224 39
a262 39
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct dm_obj *dmop;
  struct dm *dmp;
  struct bu_vls vls;
  int name_index = 1;
  int type;

  if (argc == 1) {
    /* get list of display manager objects */
    for (BU_LIST_FOR(dmop, dm_obj, &HeadDMObj.l))
      Tcl_AppendResult(interp, bu_vls_addr(&dmop->dmo_name), " ", (char *)NULL);

    return TCL_OK;
  }

  if (argc < 3) {
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "helplib dm_open");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  /* check to see if display manager object exists */
  for (BU_LIST_FOR(dmop, dm_obj, &HeadDMObj.l)) {
    if (strcmp(argv[name_index],bu_vls_addr(&dmop->dmo_name)) == 0) {
      Tcl_AppendResult(interp, "dmo_open: ", argv[name_index],
		       " exists.", (char *)NULL);
      return TCL_ERROR;
    }
  }

  /* find display manager type */
  if (argv[2][0] == 'X' || argv[2][0] == 'x')
    type = DM_TYPE_X;
d264 2
a265 2
  else if (!strcmp(argv[2], "ogl"))
    type = DM_TYPE_OGL;
d267 47
a313 47
  else if (!strcmp(argv[2], "ps"))
    type = DM_TYPE_PS;
  else if (!strcmp(argv[2], "plot"))
    type = DM_TYPE_PLOT;
  else if (!strcmp(argv[2], "nu"))
    type = DM_TYPE_NULL;
  else {
    Tcl_AppendResult(interp,
		     "Unsupported display manager type - ",
		     argv[2], "\n",
		     "The supported types are: X, ogl, ps, plot and nu", (char *)NULL);
    return TCL_ERROR;
  }

  {
    int i;
    int arg_start = 3;
    int newargs = 2;
    int ac;
    char **av;

    ac = argc + newargs;
    av = (char **)bu_malloc(sizeof(char *) * (ac+1), "dmo_open_tcl: av");
    av[0] = argv[0];

    /* Insert new args (i.e. arrange to call init_dm_obj from dm_open()) */
    av[1] = "-i";
    av[2] = "init_dm_obj";

    /*
     * Stuff name into argument list.
     */
    av[3] = "-n";
    av[4] = argv[name_index];

    /* copy the rest */
    for (i = arg_start; i < argc; ++i)
      av[i+newargs] = argv[i];
    av[i+newargs] = (char *)NULL;

    if ((dmp = dm_open(type, ac, av)) == DM_NULL) {
      Tcl_AppendResult(interp,
		       "dmo_open_tcl: Failed to open - ",
		       argv[name_index],
		       "\n",
		       (char *)NULL);
      bu_free((genptr_t)av, "dmo_open_tcl: av");
d315 19
a333 2
      return TCL_ERROR;
    }
d335 2
a336 2
    bu_free((genptr_t)av, "dmo_open_tcl: av");
  }
d338 5
a342 2
  /* acquire dm_obj struct */
  BU_GETSTRUCT(dmop,dm_obj);
d344 13
a356 31
  /* initialize dm_obj */
  bu_vls_init(&dmop->dmo_name);
  bu_vls_strcpy(&dmop->dmo_name,argv[name_index]);
  dmop->dmo_dmp = dmp;
  VSETALL(dmop->dmo_dmp->dm_clipmin, -2048.0);
  VSETALL(dmop->dmo_dmp->dm_clipmax, 2047.0);
  dmop->dmo_fbs.fbs_listener.fbsl_fbsp = &dmop->dmo_fbs;
  dmop->dmo_fbs.fbs_listener.fbsl_fd = -1;
  dmop->dmo_fbs.fbs_listener.fbsl_port = -1;
  dmop->dmo_fbs.fbs_fbp = FBIO_NULL;

  /* append to list of dm_obj's */
  BU_LIST_APPEND(&HeadDMObj.l,&dmop->l);

  (void)Tcl_CreateCommand(interp,
			  bu_vls_addr(&dmop->dmo_name),
			  dmo_cmd,
			  (ClientData)dmop,
			  dmo_deleteProc);

  /* send Configure event */
  bu_vls_init(&vls);
  bu_vls_printf(&vls, "event generate %s <Configure>", bu_vls_addr(&dmop->dmo_name));
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);


  /* Return new function name as result */
  Tcl_ResetResult(interp);
  Tcl_AppendResult(interp, bu_vls_addr(&dmop->dmo_name), (char *)NULL);
  return TCL_OK;
d361 4
a364 4
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d366 1
a366 1
  struct dm_obj *dmop = (struct dm_obj *)clientData;
d368 1
a368 1
  return DM_DRAW_BEGIN(dmop->dmo_dmp);
d373 4
a376 4
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d378 1
a378 1
  struct dm_obj *dmop = (struct dm_obj *)clientData;
d380 1
a380 1
  return DM_DRAW_END(dmop->dmo_dmp);
d385 4
a388 4
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d390 2
a391 2
  struct dm_obj *dmop = (struct dm_obj *)clientData;
  int status;
d393 2
a394 2
  if ((status = DM_DRAW_BEGIN(dmop->dmo_dmp)) != TCL_OK)
    return status;
d396 1
a396 1
  return DM_DRAW_END(dmop->dmo_dmp);
d401 4
a404 4
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d406 1
a406 1
  struct dm_obj *dmop = (struct dm_obj *)clientData;
d408 1
a408 1
  return DM_NORMAL(dmop->dmo_dmp);
d413 22
a434 27
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct dm_obj *dmop = (struct dm_obj *)clientData;
  mat_t mat;
  int which_eye;

  if (argc != 4) {
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "helplib dm_loadmat");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }


  if (bn_decode_mat(mat, argv[2]) != 16)
    return TCL_ERROR;

  if (sscanf(argv[3], "%d", &which_eye) != 1) {
    Tcl_AppendResult(interp, "bad eye value - ", argv[3], (char *)NULL);
    return TCL_ERROR;
  }
d436 6
a441 1
  return DM_LOADMATRIX(dmop->dmo_dmp,mat,which_eye);
d446 9
a454 25
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct dm_obj *dmop = (struct dm_obj *)clientData;
  fastf_t x, y;
  int size;
  int use_aspect;

  if (argc != 7) {
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "helplib dm_drawString");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  /*XXX use sscanf */
  x = atof(argv[3]);
  y = atof(argv[4]);
  size = atoi(argv[5]);
  use_aspect = atoi(argv[6]);
d456 17
a472 1
  return DM_DRAW_STRING_2D(dmop->dmo_dmp,argv[2],x,y,size,use_aspect);
d477 10
a486 21
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct dm_obj *dmop = (struct dm_obj *)clientData;
  fastf_t x, y;

  if (argc != 4) {
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "helplib dm_drawPoint");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  /*XXX use sscanf */
  x = atof(argv[2]);
  y = atof(argv[3]);
d488 12
a499 1
  return DM_DRAW_POINT_2D(dmop->dmo_dmp,x,y);
d504 10
a513 23
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct dm_obj *dmop = (struct dm_obj *)clientData;
  fastf_t x1, y1, x2, y2;

  if (argc != 6) {
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "helplib dm_drawLine");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  /*XXX use sscanf */
  x1 = atof(argv[2]);
  y1 = atof(argv[3]);
  x2 = atof(argv[4]);
  y2 = atof(argv[5]);
d515 14
a528 1
  return DM_DRAW_LINE_2D(dmop->dmo_dmp,x1,y1,x2,y2);
d537 17
a553 22
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct dm_obj *dmop = (struct dm_obj *)clientData;
  struct rt_vlist *vp;

  if (argc != 3) {
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "helplib dm_drawVList");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if (sscanf(argv[2], "%lu", (unsigned long *)&vp) != 1) {
    Tcl_AppendResult(interp, "invalid vlist pointer - ", argv[2], (char *)NULL);
    return TCL_ERROR;
  }
d555 4
a558 2
  /* XXX this causes a core dump if vp is bogus */
  BN_CK_VLIST_TCL(interp,vp);
d560 4
a563 1
  return DM_DRAW_VLIST(dmop->dmo_dmp, vp);
d600 4
a603 4
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d636 4
a639 4
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d676 10
a685 47
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct dm_obj *dmop = (struct dm_obj *)clientData;
  struct bu_vls vls;
  int r, g, b;

  bu_vls_init(&vls);

  /* get foreground color */
  if (argc == 2) {
    bu_vls_printf(&vls, "%d %d %d",
		  dmop->dmo_dmp->dm_fg[0],
		  dmop->dmo_dmp->dm_fg[1],
		  dmop->dmo_dmp->dm_fg[2]);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);
    return TCL_OK;
  }

  /* set foreground color */
  if (argc == 3) {
    if (sscanf(argv[2], "%d %d %d", &r, &g, &b) != 3)
      goto bad_color;

    /* validate color */
    if (r < 0 || 255 < r ||
	g < 0 || 255 < g ||
	b < 0 || 255 < b)
      goto bad_color;

    bu_vls_free(&vls);
    return DM_SET_FGCOLOR(dmop->dmo_dmp,r,g,b,1);
  }

  /* wrong number of arguments */
  bu_vls_printf(&vls, "helplib dm_fg");
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
  return TCL_ERROR;

bad_color:
  bu_vls_printf(&vls, "bad rgb color - %s\n", argv[2]);
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  bu_vls_free(&vls);
d687 38
a724 1
  return TCL_ERROR;
d735 32
a766 47
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct dm_obj *dmop = (struct dm_obj *)clientData;
  struct bu_vls vls;
  int r, g, b;

  bu_vls_init(&vls);

  /* get background color */
  if (argc == 2) {
    bu_vls_printf(&vls, "%d %d %d",
		  dmop->dmo_dmp->dm_bg[0],
		  dmop->dmo_dmp->dm_bg[1],
		  dmop->dmo_dmp->dm_bg[2]);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);
    return TCL_OK;
  }

  /* set background color */
  if (argc == 3) {
    if (sscanf(argv[2], "%d %d %d", &r, &g, &b) != 3)
      goto bad_color;

    /* validate color */
    if (r < 0 || 255 < r ||
	g < 0 || 255 < g ||
	b < 0 || 255 < b)
      goto bad_color;

    bu_vls_free(&vls);
    return DM_SET_BGCOLOR(dmop->dmo_dmp,r,g,b);
  }

  /* wrong number of arguments */
  bu_vls_printf(&vls, "helplib dm_bg");
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
  return TCL_ERROR;

bad_color:
  bu_vls_printf(&vls, "bad rgb color - %s\n", argv[2]);
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  bu_vls_free(&vls);
d768 16
a783 1
  return TCL_ERROR;
d794 8
a801 42
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct dm_obj *dmop = (struct dm_obj *)clientData;
  struct bu_vls vls;
  int linewidth;

  bu_vls_init(&vls);

  /* get linewidth */
  if (argc == 2) {
    bu_vls_printf(&vls, "%d", dmop->dmo_dmp->dm_lineWidth);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);
    return TCL_OK;
  }

  /* set linewidth */
  if (argc == 3) {
    if (sscanf(argv[2], "%d", &linewidth) != 1)
      goto bad_linewidth;

    /* validate linewidth */
    if (linewidth < 0 || 20 < linewidth)
      goto bad_linewidth;

    bu_vls_free(&vls);
    return DM_SET_LINE_ATTR(dmop->dmo_dmp, linewidth, dmop->dmo_dmp->dm_lineStyle);
  }

  /* wrong number of arguments */
  bu_vls_printf(&vls, "helplib dm_linewidth");
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
  return TCL_ERROR;

bad_linewidth:
  bu_vls_printf(&vls, "bad linewidth - %s\n", argv[2]);
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  bu_vls_free(&vls);
d803 35
a837 1
  return TCL_ERROR;
d848 42
a889 42
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct dm_obj *dmop = (struct dm_obj *)clientData;
  struct bu_vls vls;
  int linestyle;

  bu_vls_init(&vls);

  /* get linestyle */
  if (argc == 2) {
    bu_vls_printf(&vls, "%d", dmop->dmo_dmp->dm_lineStyle);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);
    return TCL_OK;
  }

  /* set linestyle */
  if (argc == 3) {
    if (sscanf(argv[2], "%d", &linestyle) != 1)
      goto bad_linestyle;

    /* validate linestyle */
    if (linestyle < 0 || 1 < linestyle)
      goto bad_linestyle;

    bu_vls_free(&vls);
    return DM_SET_LINE_ATTR(dmop->dmo_dmp, dmop->dmo_dmp->dm_lineWidth, linestyle);
  }

  /* wrong number of arguments */
  bu_vls_printf(&vls, "helplib dm_linestyle");
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
  return TCL_ERROR;

bad_linestyle:
  bu_vls_printf(&vls, "bad linestyle - %s\n", argv[2]);
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  bu_vls_free(&vls);
d891 1
a891 1
  return TCL_ERROR;
d903 26
a928 16
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct dm_obj *dmop = (struct dm_obj *)clientData;

  if (argc != 2) {
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "helplib dm_configure");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }
d930 1
a930 1
  return DM_CONFIGURE_WIN(dmop->dmo_dmp);
d941 35
a975 35
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct dm_obj *dmop = (struct dm_obj *)clientData;
  struct bu_vls vls;
  int zclip;

  /* get zclip flag */
  if (argc == 2) {
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "%d", dmop->dmo_dmp->dm_zclip);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);
    return TCL_OK;
  }

  /* set zclip flag */
  if (argc == 3) {
    if (sscanf(argv[2], "%d", &zclip) != 1) {
      Tcl_AppendResult(interp, "dmo_zclip: invalid zclip value - ",
		       argv[2], "\n", (char *)NULL);
      return TCL_ERROR;
    }

    dmop->dmo_dmp->dm_zclip = zclip;
    return TCL_OK;
  }

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "helplib dm_zclip");
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
  return TCL_ERROR;
d986 35
a1020 35
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct dm_obj *dmop = (struct dm_obj *)clientData;
  struct bu_vls vls;
  int zbuffer;

  /* get zbuffer flag */
  if (argc == 2) {
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "%d", dmop->dmo_dmp->dm_zbuffer);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);
    return TCL_OK;
  }

  /* set zbuffer flag */
  if (argc == 3) {
    if (sscanf(argv[2], "%d", &zbuffer) != 1) {
      Tcl_AppendResult(interp, "dmo_zbuffer: invalid zbuffer value - ",
		       argv[2], "\n", (char *)NULL);
      return TCL_ERROR;
    }

    DM_SET_ZBUFFER(dmop->dmo_dmp, zbuffer);
    return TCL_OK;
  }

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "helplib dm_zbuffer");
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
  return TCL_ERROR;
d1031 35
a1065 35
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct dm_obj *dmop = (struct dm_obj *)clientData;
  struct bu_vls vls;
  int light;

  /* get light flag */
  if (argc == 2) {
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "%d", dmop->dmo_dmp->dm_light);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);
    return TCL_OK;
  }

  /* set light flag */
  if (argc == 3) {
    if (sscanf(argv[2], "%d", &light) != 1) {
      Tcl_AppendResult(interp, "dmo_light: invalid light value - ",
		       argv[2], "\n", (char *)NULL);
      return TCL_ERROR;
    }

    DM_SET_LIGHT(dmop->dmo_dmp, light);
    return TCL_OK;
  }

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "helplib dm_light");
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
  return TCL_ERROR;
d1076 45
a1120 45
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct dm_obj *dmop = (struct dm_obj *)clientData;
  struct bu_vls vls;
  vect_t clipmin, clipmax;

  /* get window bounds */
  if (argc == 2) {
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "%g %g %g %g %g %g",
		  dmop->dmo_dmp->dm_clipmin[X],
		  dmop->dmo_dmp->dm_clipmax[X],
		  dmop->dmo_dmp->dm_clipmin[Y],
		  dmop->dmo_dmp->dm_clipmax[Y],
		  dmop->dmo_dmp->dm_clipmin[Z],
		  dmop->dmo_dmp->dm_clipmax[Z]);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);
    return TCL_OK;
  }

  /* set window bounds */
  if (argc == 3) {
    if (sscanf(argv[2], "%lf %lf %lf %lf %lf %lf",
	       &clipmin[X], &clipmax[X],
	       &clipmin[Y], &clipmax[Y],
	       &clipmin[Z], &clipmax[Z]) != 6) {
      Tcl_AppendResult(interp, "dmo_bounds: invalid bounds - ",
		       argv[2], "\n", (char *)NULL);
      return TCL_ERROR;
    }

    VMOVE(dmop->dmo_dmp->dm_clipmin, clipmin);
    VMOVE(dmop->dmo_dmp->dm_clipmax, clipmax);
    return TCL_OK;
  }

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "helplib dm_bounds");
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
  return TCL_ERROR;
d1131 35
a1165 35
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct dm_obj *dmop = (struct dm_obj *)clientData;
  struct bu_vls vls;
  int perspective;

  /* get perspective mode */
  if (argc == 2) {
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "%d", dmop->dmo_dmp->dm_perspective);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);
    return TCL_OK;
  }

  /* set perspective mode */
  if (argc == 3) {
    if (sscanf(argv[2], "%d", &perspective) != 1) {
      Tcl_AppendResult(interp, "dmo_perspective: invalid perspective mode - ",
		       argv[2], "\n", (char *)NULL);
      return TCL_ERROR;
    }

    dmop->dmo_dmp->dm_perspective = perspective;
    return TCL_OK;
  }

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "helplib dm_perspective");
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
  return TCL_ERROR;
d1176 34
a1209 34
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct dm_obj *dmop = (struct dm_obj *)clientData;
  struct bu_vls vls;
  int level;

  /* get debug level */
  if (argc == 2) {
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "%d", dmop->dmo_dmp->dm_debugLevel);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);
    return TCL_OK;
  }

  /* set debug level */
  if (argc == 3) {
    if (sscanf(argv[2], "%d", &level) != 1) {
      Tcl_AppendResult(interp, "dmo_debug: invalid debug level - ",
		       argv[2], "\n", (char *)NULL);
      return TCL_ERROR;
    }

    return DM_DEBUG(dmop->dmo_dmp,level);
  }

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "helplib dm_debug");
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
  return TCL_ERROR;
a1214 4
 *
 * Usage:
 *	  procname openfb
 *
d1217 3
a1219 5
dmo_openFb_tcl(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d1221 1
a1221 2
  struct dm_obj *dmop = (struct dm_obj *)clientData;
  char *X_name = "/dev/X";
d1223 1
a1223 1
  char *ogl_name = "/dev/ogl";
d1226 29
a1254 29
  /* already open */
  if (dmop->dmo_fbs.fbs_fbp != FBIO_NULL)
	  return TCL_OK;

  if((dmop->dmo_fbs.fbs_fbp = (FBIO *)calloc(sizeof(FBIO), 1)) == FBIO_NULL){
    Tcl_AppendResult(interp, "openfb: failed to allocate framebuffer memory\n",
		     (char *)NULL);
    return TCL_ERROR;
  }

  switch (dmop->dmo_dmp->dm_type) {
  case DM_TYPE_X:
    *dmop->dmo_fbs.fbs_fbp = X24_interface; /* struct copy */

    dmop->dmo_fbs.fbs_fbp->if_name = malloc((unsigned)strlen(X_name) + 1);
    (void)strcpy(dmop->dmo_fbs.fbs_fbp->if_name, X_name);

    /* Mark OK by filling in magic number */
    dmop->dmo_fbs.fbs_fbp->if_magic = FB_MAGIC;

    _X24_open_existing(dmop->dmo_fbs.fbs_fbp,
		       ((struct dm_xvars *)dmop->dmo_dmp->dm_vars.pub_vars)->dpy,
		       ((struct x_vars *)dmop->dmo_dmp->dm_vars.priv_vars)->pix,
		       ((struct dm_xvars *)dmop->dmo_dmp->dm_vars.pub_vars)->cmap,
		       ((struct dm_xvars *)dmop->dmo_dmp->dm_vars.pub_vars)->vip,
		       dmop->dmo_dmp->dm_width,
		       dmop->dmo_dmp->dm_height,
		       ((struct x_vars *)dmop->dmo_dmp->dm_vars.priv_vars)->gc);
    break;
d1256 2
a1257 2
  case DM_TYPE_OGL:
    *dmop->dmo_fbs.fbs_fbp = ogl_interface; /* struct copy */
d1259 2
a1260 2
    dmop->dmo_fbs.fbs_fbp->if_name = malloc((unsigned)strlen(ogl_name) + 1);
    (void)strcpy(dmop->dmo_fbs.fbs_fbp->if_name, ogl_name);
d1262 2
a1263 2
    /* Mark OK by filling in magic number */
    dmop->dmo_fbs.fbs_fbp->if_magic = FB_MAGIC;
d1265 11
a1275 11
    _ogl_open_existing(dmop->dmo_fbs.fbs_fbp,
		       ((struct dm_xvars *)dmop->dmo_dmp->dm_vars.pub_vars)->dpy,
		       ((struct dm_xvars *)dmop->dmo_dmp->dm_vars.pub_vars)->win,
		       ((struct dm_xvars *)dmop->dmo_dmp->dm_vars.pub_vars)->cmap,
		       ((struct dm_xvars *)dmop->dmo_dmp->dm_vars.pub_vars)->vip,
		       dmop->dmo_dmp->dm_width,
		       dmop->dmo_dmp->dm_height,
		       ((struct ogl_vars *)dmop->dmo_dmp->dm_vars.priv_vars)->glxc,
		       ((struct ogl_vars *)dmop->dmo_dmp->dm_vars.priv_vars)->mvars.doublebuffer,
		       0);
    break;
d1277 1
a1277 1
  }
d1279 1
a1279 1
  return TCL_OK;
d1312 1
d1322 4
a1325 4
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d1327 1
a1327 1
  struct dm_obj *dmop = (struct dm_obj *)clientData;
d1329 1
a1329 1
  return dmo_closeFb(dmop);
d1331 1
d1344 4
a1347 4
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d1371 2
a1372 2
  if (argc == 3) {
    int port;
d1374 4
a1377 20
    if (sscanf(argv[2], "%d", &port) != 1) {
      Tcl_AppendResult(interp, "listen: bad value - ", argv[2], "\n", (char *)NULL);
      return TCL_ERROR;
    }

    if (port >= 0)
      fbs_open(interp, &dmop->dmo_fbs, port);
    else {
      fbs_close(interp, &dmop->dmo_fbs);
    }
    bu_vls_printf(&vls, "%d", dmop->dmo_fbs.fbs_listener.fbsl_port);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);

    return TCL_OK;
  }

  bu_vls_printf(&vls, "helplib dm_listen");
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
d1379 17
a1395 1
  return TCL_ERROR;
d1407 4
a1410 4
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d1439 4
a1442 4
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d1444 1
a1444 1
  struct dm_obj *dmop = (struct dm_obj *)clientData;
d1446 1
a1446 1
  XFlush(((struct dm_xvars *)dmop->dmo_dmp->dm_vars.pub_vars)->dpy);
d1448 1
a1448 1
  return TCL_OK;
d1460 4
a1463 4
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d1465 1
a1465 1
  struct dm_obj *dmop = (struct dm_obj *)clientData;
d1467 1
a1467 1
  XSync(((struct dm_xvars *)dmop->dmo_dmp->dm_vars.pub_vars)->dpy, 0);
d1469 1
a1469 1
  return TCL_OK;
@


1.8
log
@*- add commands size and aspect
*- change HIDDEN to static
*- change order of object name in dm_open (i.e. dm_open name type args)
@
text
@a56 1
extern int X24_refresh();
d59 1
a59 1
extern int ogl_refresh();
d139 1
a139 1
 * Generic interface for display manager routines.
d201 1
a201 1
		bu_vls_printf(&vls, "helplib dmo_close");
d421 1
a421 1
    bu_vls_printf(&vls, "helplib loadmat");
d455 1
a455 1
    bu_vls_printf(&vls, "helplib drawString");
d484 1
a484 1
    bu_vls_printf(&vls, "helplib drawPoint");
d511 1
a511 1
    bu_vls_printf(&vls, "helplib drawLine");
d544 1
a544 1
    bu_vls_printf(&vls, "helplib drawVList");
d607 1
a607 1
		bu_vls_printf(&vls, "helplib drawSList");
d1381 1
a1381 1
  bu_vls_printf(&vls, "helplib listen");
@


1.7
log
@Eliminated some unused variables
@
text
@d62 24
a85 24
HIDDEN int dmo_open_tcl();
HIDDEN int dmo_close_tcl();
HIDDEN int dmo_drawBegin_tcl();
HIDDEN int dmo_drawEnd_tcl();
HIDDEN int dmo_clear_tcl();
HIDDEN int dmo_normal_tcl();
HIDDEN int dmo_loadmat_tcl();
HIDDEN int dmo_drawString_tcl();
HIDDEN int dmo_drawPoint_tcl();
HIDDEN int dmo_drawLine_tcl();
HIDDEN int dmo_drawVList_tcl();
HIDDEN int dmo_drawSList_tcl();
HIDDEN int dmo_drawGeom_tcl();
HIDDEN int dmo_fg_tcl();
HIDDEN int dmo_bg_tcl();
HIDDEN int dmo_lineWidth_tcl();
HIDDEN int dmo_lineStyle_tcl();
HIDDEN int dmo_configure_tcl();
HIDDEN int dmo_zclip_tcl();
HIDDEN int dmo_zbuffer_tcl();
HIDDEN int dmo_light_tcl();
HIDDEN int dmo_bounds_tcl();
HIDDEN int dmo_perspective_tcl();
HIDDEN int dmo_debug_tcl();
d87 5
a91 5
HIDDEN int dmo_openFb_tcl();
HIDDEN int dmo_closeFb();
HIDDEN int dmo_closeFb_tcl();
HIDDEN int dmo_listen_tcl();
HIDDEN int dmo_refreshFb_tcl();
d93 4
a96 2
HIDDEN int dmo_flush_tcl();
HIDDEN int dmo_sync_tcl();
d98 1
a98 1
HIDDEN struct dm_obj HeadDMObj;	/* head of display manager object list */
d100 1
a100 1
HIDDEN struct bu_cmdtab dmo_cmds[] = {
d132 2
d146 1
a146 1
HIDDEN int
d170 1
a170 1
HIDDEN void
d190 1
a190 1
HIDDEN int
d218 1
a218 1
 *	  dm_open [type name [args]]
d220 1
a220 1
HIDDEN int
d230 1
d249 9
d259 1
a259 1
  if (argv[1][0] == 'X' || argv[1][0] == 'x')
d262 1
a262 1
  else if (!strcmp(argv[1], "ogl"))
d265 1
a265 1
  else if (!strcmp(argv[1], "ps"))
d267 1
a267 1
  else if (!strcmp(argv[1], "plot"))
d269 1
a269 1
  else if (!strcmp(argv[1], "nu"))
d274 2
a275 2
		     argv[1], "\n",
		     "The supported types are: X, ogl, ps, plot and nu\n", (char *)NULL);
a278 9
  /* check to see if display manager object exists */
  for (BU_LIST_FOR(dmop, dm_obj, &HeadDMObj.l)) {
    if (strcmp(argv[2],bu_vls_addr(&dmop->dmo_name)) == 0) {
      Tcl_AppendResult(interp, "dmo_open: ", argv[2],
		       " exists.\n", (char *)NULL);
      return TCL_ERROR;
    }
  }

d281 1
d290 1
a290 1
    /* arrange to call init_dm_obj from dm_open() */
d295 1
a295 2
     * Already have type, so reuse pointer to indicate that the next argument
     * points to the name.
d298 1
d301 1
a301 1
    for (i = 2; i < argc; ++i)
d308 1
a308 1
		       argv[2],
d324 1
a324 1
  bu_vls_strcpy(&dmop->dmo_name,argv[2]);
d355 1
a355 1
HIDDEN int
d367 1
a367 1
HIDDEN int
d379 1
a379 1
HIDDEN int
d395 1
a395 1
HIDDEN int
d407 1
a407 1
HIDDEN int
d440 1
a440 1
HIDDEN int
d471 1
a471 1
HIDDEN int
d498 1
a498 1
HIDDEN int
d531 1
a531 1
HIDDEN int
d566 1
a566 1
HIDDEN int
d594 1
a594 1
HIDDEN int
d630 1
a630 1
HIDDEN int
d670 1
a670 1
HIDDEN int
d729 1
a729 1
HIDDEN int
d788 1
a788 1
HIDDEN int
d842 1
a842 1
HIDDEN int
d897 1
a897 1
HIDDEN int
d925 1
a925 1
HIDDEN int
d970 1
a970 1
HIDDEN int
d1015 1
a1015 1
HIDDEN int
d1060 1
a1060 1
HIDDEN int
d1115 1
a1115 1
HIDDEN int
d1160 1
a1160 1
HIDDEN int
d1206 1
a1206 1
HIDDEN int
d1275 1
a1275 1
HIDDEN int
d1312 1
a1312 1
HIDDEN int
d1333 1
a1333 1
HIDDEN int
d1396 1
a1396 1
HIDDEN int
d1428 1
a1428 1
HIDDEN int
d1449 1
a1449 1
HIDDEN int
d1461 66
@


1.6
log
@*- add error checking when dealing with the display
   manager's framebuffer
*- code to stop listening when given a port number < 0
@
text
@a226 1
  char *save_argv1;
a1207 1
  struct bu_vls vls;
@


1.5
log
@*- add new commands to display manager object: sync, flush,
	clear, close, light, zbuffer
@
text
@d88 1
d172 1
d325 2
d557 5
d581 2
d1215 4
d1271 30
a1315 20
  struct bu_vls vls;

  _fb_pgflush(dmop->dmo_fbs.fbs_fbp);

  switch (dmop->dmo_dmp->dm_type) {
  case DM_TYPE_X:
    X24_close_existing(dmop->dmo_fbs.fbs_fbp);
    break;
#ifdef DM_OGL
  case DM_TYPE_OGL:
    ogl_close_existing(dmop->dmo_fbs.fbs_fbp);
    break;
#endif
  }

  /* free framebuffer memory */
  if(dmop->dmo_fbs.fbs_fbp->if_pbase != PIXEL_NULL)
    free((void *)dmop->dmo_fbs.fbs_fbp->if_pbase);
  free((void *)dmop->dmo_fbs.fbs_fbp->if_name);
  free((void *)dmop->dmo_fbs.fbs_fbp);
d1317 1
a1317 1
  return TCL_OK;
d1326 1
a1326 1
 * Returns the port number actually used in interp->result.
d1336 9
a1344 2
  struct dm_obj *dmop = (struct dm_obj *)clientData;
  struct bu_vls vls;
d1346 2
a1347 1
  bu_vls_init(&vls);
d1349 5
a1353 5
  /* return the port number */
  if (argc == 2) {
    bu_vls_printf(&vls, "%d", dmop->dmo_fbs.fbs_listener.fbsl_port);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);
d1355 2
a1356 2
    return TCL_OK;
  }
d1366 5
a1370 1
    fbs_open(interp, &dmop->dmo_fbs, port);
d1399 11
a1409 2
  struct dm_obj *dmop = (struct dm_obj *)clientData;
  struct bu_vls vls;
d1411 1
a1411 1
  fb_refresh(dmop->dmo_fbs.fbs_fbp, 0, 0, dmop->dmo_dmp->dm_width, dmop->dmo_dmp->dm_height);
d1413 1
a1413 1
  return TCL_OK;
@


1.4
log
@*- use new bu_cmd routines
@
text
@d14 13
d39 1
a39 1
#include "bu.h"
d42 1
a43 2
#include "solid.h"
#include "cmd.h"
a51 1
#include "./fbserv_obj.h"
d62 2
a63 9
struct dm_obj {
  struct bu_list	l;
  struct bu_vls		dmo_name;		/* display manager name/cmd */
  struct dm		*dmo_dmp;		/* display manager pointer */
#ifdef USE_FBSERV
  struct fbserv_obj	dmo_fbs;		/* fbserv object */
#endif
};

d66 1
d74 1
d81 2
d92 2
d100 1
d108 1
d114 2
d126 3
d156 2
d179 30
d321 2
a322 2
  dmop->dmo_fbs.fbs_listener.l_fbsp = &dmop->dmo_fbs;
  dmop->dmo_fbs.fbs_listener.l_fd = -1;
d371 16
d553 21
d585 2
a586 19
  struct dm_obj *dmop = (struct dm_obj *)clientData;
  struct solid *hsp;
  struct solid *sp;
  struct rt_vlist *vp;
  int linestyle;
#if 0
  fastf_t ratio;
  fastf_t inv_viewsize;
#endif

  if (argc != 3) {
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "helplib drawSList");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }
d588 2
a589 4
  if (sscanf(argv[2], "%lu", (unsigned long *)&hsp) != 1) {
    Tcl_AppendResult(interp, "invalid vlist pointer - ", argv[2], (char *)NULL);
    return TCL_ERROR;
  }
d591 13
a603 3
#if 0
  inv_viewsize = 1 / VIEWSIZE;
#endif
d605 2
a606 3
  FOR_ALL_SOLIDS(sp, &hsp->l) {
#if 0
    ratio = sp->s_size * inv_viewsize;
d608 17
a624 7
    /*
     * Check for this object being bigger than 
     * dmp->dm_bound * the window size, or smaller than a speck.
     */
    if (ratio >= dmop->dmo_dmp->dm_bound || ratio < 0.001)
      continue;
#endif
d626 7
a632 4
    if (linestyle != sp->s_soldash) {
      linestyle = sp->s_soldash;
      DM_SET_LINE_ATTR(dmop->dmo_dmp, dmop->dmo_dmp->dm_lineWidth, linestyle);
    }
d634 10
a643 6
    DM_SET_FGCOLOR(dmop->dmo_dmp,
		   (short)sp->s_color[0],
		   (short)sp->s_color[1],
		   (short)sp->s_color[2], 0);
    DM_DRAW_VLIST(dmop->dmo_dmp, (struct rt_vlist *)&sp->s_vlist);
  }
d645 1
a645 1
  return TCL_OK;
d900 1
a900 2
  dm_configureWindowShape(dmop->dmo_dmp);
  return TCL_OK;
d949 90
d1318 1
a1318 1
    bu_vls_printf(&vls, "%d", dmop->dmo_fbs.fbs_listener.l_port);
d1334 1
a1334 1
    bu_vls_printf(&vls, "%d", dmop->dmo_fbs.fbs_listener.l_port);
d1370 42
@


1.3
log
@*- miss-placed include
@
text
@d87 1
a87 1
HIDDEN struct cmdtab dmo_cmds[] = {
d131 1
a131 1
  return do_cmd(clientData, interp, argc, argv, dmo_cmds, 1);
@


1.2
log
@*- add fbserv capability
@
text
@d38 1
a39 1
#endif
@


1.1
log
@*- display manager object
@
text
@d15 4
d21 3
a23 1
#include "tcl.h"
d32 18
a54 1
  int	 		dmo_perspective;	/* !0 means using perspective */
d56 1
a56 2
  struct fbserv_obj	*dmo_fbsp;		/* fbserv pointer */
  int			dmo_fbactive;		/* !0 means framebuffer is active */
d81 2
d109 2
d156 1
a269 1
  dmop->dmo_perspective = 0;
d272 2
d485 1
a485 1
  return DM_DRAW_VLIST(dmop->dmo_dmp,vp,dmop->dmo_perspective);
d549 1
a549 3
    DM_DRAW_VLIST(dmop->dmo_dmp,
		  (struct rt_vlist *)&sp->s_vlist,
		  dmop->dmo_perspective);
d931 1
a931 1
    bu_vls_printf(&vls, "%d", dmop->dmo_perspective);
d940 1
a940 1
      Tcl_AppendResult(interp, "dmo_perspective: invalid debug level - ",
d945 1
a945 1
    dmop->dmo_perspective = perspective;
d1000 1
d1005 166
a1170 1
 *	  procname fb
a1171 1
 * Returns the port number in interp->result.
d1174 1
a1174 1
dmo_fb_tcl(clientData, interp, argc, argv)
d1183 2
d1187 1
@

