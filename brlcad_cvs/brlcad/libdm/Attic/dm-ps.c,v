head	1.39;
access;
symbols
	ansi-20040405-merged:1.33.2.3
	postmerge-20040405-ansi:1.36
	premerge-20040404-ansi:1.35
	postmerge-autoconf:1.35
	autoconf-freeze:1.33.10.3
	premerge-autoconf:1.35
	ansi-20040316-freeze:1.33.2.1
	postmerge-20040315-windows:1.35
	premerge-20040315-windows:1.34
	windows-20040315-freeze:1.33.4.2
	autoconf-20031203:1.33
	autoconf-20031202:1.33
	autoconf-branch:1.33.0.10
	phong-branch:1.33.0.8
	photonmap-branch:1.33.0.6
	rel-6-1-DP:1.33
	windows-branch:1.33.0.4
	rel-6-0-2:1.31
	ansi-branch:1.33.0.2
	rel-6-0-1-branch:1.31.0.2
	hartley-6-0-post:1.32
	hartley-6-0-pre:1.31
	rel-6-0-1:1.31
	rel-6-0:1.31
	rel-5-4:1.25.2.1
	offsite-5-3-pre:1.29
	rel-5-3:1.25.2.1
	rel-5-2:1.25.2.1
	rel-5-1-branch:1.25.0.2
	rel-5-1:1.25
	rel-5-0:1.22
	rel-5-0-beta:1.22
	rel-4-5:1.18
	ctj-4-5-post:1.15
	ctj-4-5-pre:1.15;
locks; strict;
comment	@ * @;


1.39
date	2004.05.21.18.06.25;	author morrison;	state dead;
branches;
next	1.38;

1.38
date	2004.05.10.15.30.44;	author erikg;	state Exp;
branches;
next	1.37;

1.37
date	2004.05.10.15.25.26;	author morrison;	state Exp;
branches;
next	1.36;

1.36
date	2004.04.05.07.45.07;	author morrison;	state Exp;
branches;
next	1.35;

1.35
date	2004.03.16.19.41.54;	author morrison;	state Exp;
branches;
next	1.34;

1.34
date	2004.02.02.17.39.08;	author morrison;	state Exp;
branches;
next	1.33;

1.33
date	2002.08.20.17.07.45;	author jra;	state Exp;
branches
	1.33.2.1
	1.33.4.1
	1.33.10.1;
next	1.32;

1.32
date	2002.08.15.20.54.57;	author hartley;	state Exp;
branches;
next	1.31;

1.31
date	2001.04.02.21.38.01;	author morrison;	state Exp;
branches;
next	1.30;

1.30
date	2001.03.31.01.56.52;	author morrison;	state Exp;
branches;
next	1.29;

1.29
date	2000.10.18.18.10.33;	author butler;	state Exp;
branches;
next	1.28;

1.28
date	2000.08.31.18.16.42;	author bparker;	state Exp;
branches;
next	1.27;

1.27
date	2000.07.12.03.24.44;	author cjohnson;	state Exp;
branches;
next	1.26;

1.26
date	2000.06.30.20.54.06;	author bparker;	state Exp;
branches;
next	1.25;

1.25
date	99.12.27.21.10.48;	author bparker;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	99.12.17.16.38.47;	author bparker;	state Exp;
branches;
next	1.23;

1.23
date	99.12.01.13.30.20;	author bparker;	state Exp;
branches;
next	1.22;

1.22
date	98.06.15.18.55.07;	author bparker;	state Exp;
branches;
next	1.21;

1.21
date	98.06.12.19.48.18;	author bparker;	state Exp;
branches;
next	1.20;

1.20
date	98.03.03.14.59.13;	author jra;	state Exp;
branches;
next	1.19;

1.19
date	98.02.26.15.21.55;	author bparker;	state Exp;
branches;
next	1.18;

1.18
date	97.11.03.20.10.38;	author bparker;	state Exp;
branches;
next	1.17;

1.17
date	97.10.10.12.55.49;	author bparker;	state Exp;
branches;
next	1.16;

1.16
date	97.09.23.21.15.29;	author bparker;	state Exp;
branches;
next	1.15;

1.15
date	97.05.21.13.02.35;	author bparker;	state Exp;
branches;
next	1.14;

1.14
date	97.05.08.14.21.19;	author bparker;	state Exp;
branches;
next	1.13;

1.13
date	97.04.24.18.14.07;	author bparker;	state Exp;
branches;
next	1.12;

1.12
date	97.04.23.18.39.25;	author bparker;	state Exp;
branches;
next	1.11;

1.11
date	97.04.22.15.04.52;	author bparker;	state Exp;
branches;
next	1.10;

1.10
date	97.03.03.18.29.27;	author bparker;	state Exp;
branches;
next	1.9;

1.9
date	97.01.17.23.01.25;	author bparker;	state Exp;
branches;
next	1.8;

1.8
date	97.01.02.20.07.48;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	96.12.04.21.30.21;	author bparker;	state Exp;
branches;
next	1.6;

1.6
date	96.10.23.20.28.49;	author bparker;	state Exp;
branches;
next	1.5;

1.5
date	96.09.30.19.40.38;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	96.09.26.20.37.27;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	96.09.25.20.27.08;	author bparker;	state Exp;
branches;
next	1.2;

1.2
date	96.09.23.17.48.21;	author bparker;	state Exp;
branches;
next	1.1;

1.1
date	96.09.17.21.24.56;	author bparker;	state Exp;
branches;
next	;

1.25.2.1
date	2000.09.01.17.24.42;	author bparker;	state Exp;
branches;
next	;

1.33.2.1
date	2002.09.19.18.01.17;	author morrison;	state Exp;
branches;
next	1.33.2.2;

1.33.2.2
date	2004.03.17.21.16.58;	author morrison;	state Exp;
branches;
next	1.33.2.3;

1.33.2.3
date	2004.04.02.16.05.06;	author morrison;	state Exp;
branches;
next	;

1.33.4.1
date	2002.09.26.23.03.53;	author morrison;	state Exp;
branches;
next	1.33.4.2;

1.33.4.2
date	2004.03.11.23.42.01;	author morrison;	state Exp;
branches;
next	;

1.33.10.1
date	2004.02.12.19.45.18;	author erikg;	state Exp;
branches;
next	1.33.10.2;

1.33.10.2
date	2004.03.15.14.06.18;	author erikg;	state Exp;
branches;
next	1.33.10.3;

1.33.10.3
date	2004.03.18.18.10.27;	author erikg;	state Exp;
branches;
next	;


desc
@Postscript Display Manager
@


1.39
log
@moved to src/
@
text
@/*
 *			D M - P S . C
 *
 * A useful hack to allow GED to generate
 * PostScript files that not only contain the drawn objects, but
 * also contain the faceplate display as well.
 * Mostly, used for making viewgraphs and photographs
 * of an editing session.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libdm/dm-ps.c,v 1.38 2004/05/10 15:30:44 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include "tcl.h"

#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#ifndef WIN32
#include <sys/time.h>		/* for struct timeval */
#endif
#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "mater.h"
#include "raytrace.h"
#include "dm.h"
#include "dm-ps.h"
#include "solid.h"

#define EPSILON          0.0001

/* Display Manager package interface */

#define PLOTBOUND	1000.0	/* Max magnification in Rot matrix */
struct dm	*ps_open(Tcl_Interp *interp, int argc, char **argv);
static int	ps_close(struct dm *dmp);
static int	ps_drawBegin(struct dm *dmp), ps_drawEnd(struct dm *dmp);
static int	ps_normal(struct dm *dmp), ps_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye);
static int	ps_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect), ps_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2);
static int      ps_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y);
static int	ps_drawVList(struct dm *dmp, register struct bn_vlist *vp);
static int      ps_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict, fastf_t transparency);
static int      ps_setBGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b);
static int      ps_setLineAttr(struct dm *dmp, int width, int style);
static int	ps_setWinBounds(struct dm *dmp, register int *w), ps_debug(struct dm *dmp, int lvl);

struct dm dm_ps = {
  ps_close,
  ps_drawBegin,
  ps_drawEnd,
  ps_normal,
  ps_loadMatrix,
  ps_drawString2D,
  ps_drawLine2D,
  ps_drawPoint2D,
  ps_drawVList,
  ps_setFGColor,
  ps_setBGColor,
  ps_setLineAttr,
  Nu_int0,
  ps_setWinBounds,
  Nu_int0,
  Nu_int0,
  Nu_int0,
  Nu_int0,
  ps_debug,
  Nu_int0,
  Nu_int0,
  Nu_int0,
  Nu_int0,
  0,
  0,				/* no displaylist */
  0,                            /* no stereo */
  PLOTBOUND,			/* zoom-in limit */
  1,				/* bound flag */
  "ps",
  "Screen to PostScript",
  DM_TYPE_PS,
  0,
  0,
  0,
  0,
  0,
  1.0, /* aspect ratio */
  0,
  {0, 0},
  {0, 0, 0, 0, 0},		/* bu_vls path name*/
  {0, 0, 0, 0, 0},		/* bu_vls full name drawing window */
  {0, 0, 0, 0, 0},		/* bu_vls short name drawing window */
  {0, 0, 0},			/* bg color */
  {0, 0, 0},			/* fg color */
  {0.0, 0.0, 0.0},		/* clipmin */
  {0.0, 0.0, 0.0},		/* clipmax */
  0,				/* no debugging */
  0,				/* no perspective */
  0,				/* no lighting */
  0,				/* no transparency */
  0,				/* no zbuffer */
  0,				/* no zclipping */
  1,                            /* clear back buffer after drawing and swap */
  0				/* Tcl interpreter */
};

char ps_usage[] = "Usage: ps [-f font] [-t title] [-c creator] [-s size in inches]\
 [-l linewidth] file";

struct ps_vars head_ps_vars;
static mat_t psmat;

/*
 *			P S _ O P E N
 *
 * Open the output file, and output the PostScript prolog.
 *
 */
struct dm *
ps_open(Tcl_Interp *interp, int argc, char **argv)
{
	static int	count = 0;
	struct dm	*dmp;
	Tcl_Obj		*obj;

	BU_GETSTRUCT(dmp, dm);
	if (dmp == DM_NULL)
		return DM_NULL;

	*dmp = dm_ps;  /* struct copy */
	dmp->dm_interp = interp;

	dmp->dm_vars.priv_vars = (genptr_t)bu_calloc(1, sizeof(struct ps_vars), "ps_open: ps_vars");
	if (dmp->dm_vars.priv_vars == (genptr_t)NULL) {
		bu_free(dmp, "ps_open: dmp");
		return DM_NULL;
	}

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);

	bu_vls_init(&dmp->dm_pathName);
	bu_vls_init(&dmp->dm_tkName);
	bu_vls_printf(&dmp->dm_pathName, ".dm_ps%d", count++);
	bu_vls_printf(&dmp->dm_tkName, "dm_ps%d", count++);

	bu_vls_init(&((struct ps_vars *)dmp->dm_vars.priv_vars)->fname);
	bu_vls_init(&((struct ps_vars *)dmp->dm_vars.priv_vars)->font);
	bu_vls_init(&((struct ps_vars *)dmp->dm_vars.priv_vars)->title);
	bu_vls_init(&((struct ps_vars *)dmp->dm_vars.priv_vars)->creator);

	/* set defaults */
	bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars.priv_vars)->font, "Courier");
	bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars.priv_vars)->title, "No Title");
	bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars.priv_vars)->creator, "LIBDM dm-ps");
	((struct ps_vars *)dmp->dm_vars.priv_vars)->scale = 0.0791;
	((struct ps_vars *)dmp->dm_vars.priv_vars)->linewidth = 4;
	((struct ps_vars *)dmp->dm_vars.priv_vars)->zclip = 0;

	/* skip first argument */
	--argc; ++argv;

	/* Process any options */
	while (argv[0] != (char *)0 && argv[0][0] == '-') {
		switch (argv[0][1]) {
		case 'f':               /* font */
			if (argv[0][2] != '\0')
				bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars.priv_vars)->font, &argv[0][2]);
			else {
				argv++;
				if (argv[0] == (char *)0 || argv[0][0] == '-') {
					Tcl_AppendStringsToObj(obj, ps_usage, (char *)0);
					(void)ps_close(dmp);

					Tcl_SetObjResult(interp, obj);
					return DM_NULL;
				} else
					bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars.priv_vars)->font, &argv[0][0]);
			}
			break;
		case 't':               /* title */
			if (argv[0][2] != '\0')
				bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars.priv_vars)->title, &argv[0][2]);
			else {
				argv++;
				if (argv[0] == (char *)0 || argv[0][0] == '-') {
					Tcl_AppendStringsToObj(obj, ps_usage, (char *)0);
					(void)ps_close(dmp);

					Tcl_SetObjResult(interp, obj);
					return DM_NULL;
				} else
					bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars.priv_vars)->title, &argv[0][0]);
			}
			break;
		case 'c':               /* creator */
			if (argv[0][2] != '\0')
				bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars.priv_vars)->creator, &argv[0][2]);
			else {
				argv++;
				if (argv[0] == (char *)0 || argv[0][0] == '-') {
					Tcl_AppendStringsToObj(obj, ps_usage, (char *)0);
					(void)ps_close(dmp);

					Tcl_SetObjResult(interp, obj);
					return DM_NULL;
				} else
					bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars.priv_vars)->creator, &argv[0][0]);
			}
			break;
		case 's':               /* size in inches */
			{
				fastf_t size;

				if (argv[0][2] != '\0')
					sscanf(&argv[0][2], "%lf", &size);
				else {
					argv++;
					if (argv[0] == (char *)0 || argv[0][0] == '-') {
						Tcl_AppendStringsToObj(obj, ps_usage, (char *)0);
						(void)ps_close(dmp);

						Tcl_SetObjResult(interp, obj);
						return DM_NULL;
					} else
						sscanf(&argv[0][0], "%lf", &size);
				}

				((struct ps_vars *)dmp->dm_vars.priv_vars)->scale = size * 0.017578125;
			}
			break;
		case 'l':               /* line width */
			if (argv[0][2] != '\0')
				sscanf(&argv[0][2], "%d", &((struct ps_vars *)dmp->dm_vars.priv_vars)->linewidth);
			else{
				argv++;
				if (argv[0] == (char *)0 || argv[0][0] == '-') {
					Tcl_AppendStringsToObj(obj, ps_usage, (char *)0);
					(void)ps_close(dmp);

					Tcl_SetObjResult(interp, obj);
					return DM_NULL;
				} else
					sscanf(&argv[0][0], "%d", &((struct ps_vars *)dmp->dm_vars.priv_vars)->linewidth);
			}
			break;
		case 'z':
#if 0
			((struct ps_vars *)dmp->dm_vars.priv_vars)->zclip = 1;
#else
			dmp->dm_zclip = 1;
#endif
			break;
		default:
			Tcl_AppendStringsToObj(obj, ps_usage, (char *)0);
			(void)ps_close(dmp);

			Tcl_SetObjResult(interp, obj);
			return DM_NULL;
		}
		argv++;
	}

	if(argv[0] == (char *)0) {
		Tcl_AppendStringsToObj(obj, "no filename specified\n", (char *)NULL);
		(void)ps_close(dmp);

		Tcl_SetObjResult(interp, obj);
		return DM_NULL;
	}

	bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars.priv_vars)->fname, argv[0]);

	if ((((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp =
	     fopen(bu_vls_addr(&((struct ps_vars *)dmp->dm_vars.priv_vars)->fname), "w")) == NULL) {
		Tcl_AppendStringsToObj(obj, "f_ps: Error opening file - ",
				 ((struct ps_vars *)dmp->dm_vars.priv_vars)->fname,
				 "\n", (char *)NULL);
		(void)ps_close(dmp);

		Tcl_SetObjResult(interp, obj);
		return DM_NULL;
	}
  
	setbuf(((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp,
	       ((struct ps_vars *)dmp->dm_vars.priv_vars)->ttybuf );
	fprintf(((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp,"%%!PS-Adobe-1.0\n\
%%begin(plot)\n\
%%%%DocumentFonts:  %s\n",
		bu_vls_addr(&((struct ps_vars *)dmp->dm_vars.priv_vars)->font));

	fprintf(((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp, "%%%%Title: %s\n",
		bu_vls_addr(&((struct ps_vars *)dmp->dm_vars.priv_vars)->title));

	fprintf(((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp, "\
%%%%Creator: %s\n\
%%%%BoundingBox: 0 0 324 324	%% 4.5in square, for TeX\n\
%%%%EndComments\n\
\n",
		bu_vls_addr(&((struct ps_vars *)dmp->dm_vars.priv_vars)->creator));

	fprintf(((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp, "\
%d setlinewidth\n\
\n\
%% Sizes, made functions to avoid scaling if not needed\n\
/FntH /%s findfont 80 scalefont def\n\
/DFntL { /FntL /%s findfont 73.4 scalefont def } def\n\
/DFntM { /FntM /%s findfont 50.2 scalefont def } def\n\
/DFntS { /FntS /%s findfont 44 scalefont def } def\n\
\n\
%% line styles\n\
/NV { [] 0 setdash } def	%% normal vectors\n\
/DV { [8] 0 setdash } def	%% dotted vectors\n\
/DDV { [8 8 32 8] 0 setdash } def	%% dot-dash vectors\n\
/SDV { [32 8] 0 setdash } def	%% short-dash vectors\n\
/LDV { [64 8] 0 setdash } def	%% long-dash vectors\n\
\n\
/NEWPG {\n\
	%f %f scale	%% 0-4096 to 324 units (4.5 inches)\n\
} def\n\
\n\
FntH  setfont\n\
NEWPG\n\
",
		((struct ps_vars *)dmp->dm_vars.priv_vars)->linewidth,
		bu_vls_addr(&((struct ps_vars *)dmp->dm_vars.priv_vars)->font),
		bu_vls_addr(&((struct ps_vars *)dmp->dm_vars.priv_vars)->font),
		bu_vls_addr(&((struct ps_vars *)dmp->dm_vars.priv_vars)->font),
		bu_vls_addr(&((struct ps_vars *)dmp->dm_vars.priv_vars)->font),
		((struct ps_vars *)dmp->dm_vars.priv_vars)->scale,
		((struct ps_vars *)dmp->dm_vars.priv_vars)->scale);

	MAT_IDN(psmat);

	Tcl_SetObjResult(interp, obj);
	return dmp;
}

/*
 *  			P S _ C L O S E
 *  
 *  Gracefully release the display.
 */
static int
ps_close(struct dm *dmp)
{
  if(!((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp)
    return TCL_ERROR;

  fputs("%end(plot)\n", ((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp);
  (void)fclose(((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp);

  bu_vls_free(&dmp->dm_pathName);
  bu_vls_free(&dmp->dm_tkName);
  bu_vls_free(&((struct ps_vars *)dmp->dm_vars.priv_vars)->fname);
  bu_vls_free(&((struct ps_vars *)dmp->dm_vars.priv_vars)->font);
  bu_vls_free(&((struct ps_vars *)dmp->dm_vars.priv_vars)->title);
  bu_vls_free(&((struct ps_vars *)dmp->dm_vars.priv_vars)->creator);
  bu_free(dmp->dm_vars.priv_vars, "ps_close: ps_vars");
  bu_free(dmp, "ps_close: dmp");

  return TCL_OK;
}

/*
 *			P S _ P R O L O G
 *
 * There are global variables which are parameters to this routine.
 */
static int
ps_drawBegin(struct dm *dmp)
{
  return TCL_OK;
}

/*
 *			P S _ E P I L O G
 */
static int
ps_drawEnd(struct dm *dmp)
{
  if( !((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp )
    return TCL_ERROR;

  fputs("% showpage	% uncomment to use raw file\n",
	((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp);
  (void)fflush( ((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp );

  return TCL_OK;
}

/*
 *  			P S _ N E W R O T
 *
 *  Load a new transformation matrix.  This will be followed by
 *  many calls to ps_drawVList().
 */
static int
ps_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye)
{
	Tcl_Obj	*obj;

	obj = Tcl_GetObjResult(dmp->dm_interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);

	if (((struct ps_vars *)dmp->dm_vars.priv_vars)->debug) {
		struct bu_vls tmp_vls;

		Tcl_AppendStringsToObj(obj, "ps_loadMatrix()\n", (char *)NULL);

		bu_vls_init(&tmp_vls);
		bu_vls_printf(&tmp_vls, "which eye = %d\t", which_eye);
		bu_vls_printf(&tmp_vls, "transformation matrix = \n");
		bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[0], mat[4], mat[8],mat[12]);
		bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[1], mat[5], mat[9],mat[13]);
		bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[2], mat[6], mat[10],mat[14]);
		bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[3], mat[7], mat[11],mat[15]);

		Tcl_AppendStringsToObj(obj, bu_vls_addr(&tmp_vls), (char *)NULL);
		bu_vls_free(&tmp_vls);
	}

	MAT_COPY(psmat, mat);

	Tcl_SetObjResult(dmp->dm_interp, obj);
	return TCL_OK;
}

/*
 *  			P S _ O B J E C T
 *  
 *  Set up for an object, transformed as indicated, and with an
 *  object center as specified.  The ratio of object to screen size
 *  is passed in as a convienience.
 *
 *  Returns 0 if object could be drawn, !0 if object was omitted.
 */
/* ARGSUSED */
static int
ps_drawVList(struct dm *dmp, register struct bn_vlist *vp)
{
  static vect_t			last;
  register struct rt_vlist	*tvp;
  register point_t		*pt_prev=NULL;
  register fastf_t		dist_prev=1.0;
  register fastf_t		dist;
  fastf_t			delta;
  int useful = 0;

  if( !((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp )
    return TCL_ERROR;

#if 0
  if( linestyle )
    fprintf(((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp, "DDV ");		/* Dot-dashed vectors */
  else
    fprintf(((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp, "NV ");		/* Normal vectors */
#endif

    /* delta is used in clipping to insure clipped endpoint is slightly
     * in front of eye plane (perspective mode only).
     * This value is a SWAG that seems to work OK.
     */
    delta = psmat[15]*0.0001;
    if( delta < 0.0 )
	delta = -delta;
    if( delta < SQRT_SMALL_FASTF )
	delta = SQRT_SMALL_FASTF;

  for( BU_LIST_FOR( tvp, rt_vlist, &vp->l ) )  {
    register int	i;
    register int	nused = tvp->nused;
    register int	*cmd = tvp->cmd;
    register point_t *pt = tvp->pt;
    for( i = 0; i < nused; i++,cmd++,pt++ )  {
      static vect_t	start, fin;
      switch( *cmd )  {
      case RT_VLIST_POLY_START:
      case RT_VLIST_POLY_VERTNORM:
	continue;
      case RT_VLIST_POLY_MOVE:
      case RT_VLIST_LINE_MOVE:
	/* Move, not draw */
		if (dmp->dm_perspective > 0)
	    	{
	    		/* cannot apply perspective transformation to
			 * points behind eye plane!!!!
	    		 */
	    		dist = VDOT( *pt, &psmat[12] ) + psmat[15];
	    		if( dist <= 0.0 )
	    		{
	    			pt_prev = pt;
	    			dist_prev = dist;
	    			continue;
	    		}
	    		else
	    		{
	    			MAT4X3PNT( last, psmat, *pt );
	    			dist_prev = dist;
	    			pt_prev = pt;
	    		}
	    	}
		else
			MAT4X3PNT( last, psmat, *pt );
	continue;
      case RT_VLIST_POLY_DRAW:
      case RT_VLIST_POLY_END:
      case RT_VLIST_LINE_DRAW:
	/* draw */
		if (dmp->dm_perspective > 0)
	    	{
	    		/* cannot apply perspective transformation to
			 * points behind eye plane!!!!
	    		 */
	    		dist = VDOT( *pt, &psmat[12] ) + psmat[15];
	    		if( dist <= 0.0 )
	    		{
	    			if( dist_prev <= 0.0 )
	    			{
	    				/* nothing to plot */
		    			dist_prev = dist;
		    			pt_prev = pt;
		    			continue;
	    			}
	    			else
	    			{
	    				fastf_t alpha;
	    				vect_t diff;
	    				point_t tmp_pt;

	    				/* clip this end */
	    				VSUB2( diff, *pt, *pt_prev );
	    				alpha = (dist_prev - delta) / ( dist_prev - dist );
	    				VJOIN1( tmp_pt, *pt_prev, alpha, diff );
	    				MAT4X3PNT( fin, psmat, tmp_pt );
	    			}
	    		}
	    		else
	    		{
	    			if( dist_prev <= 0.0 )
	    			{
	    				fastf_t alpha;
	    				vect_t diff;
	    				point_t tmp_pt;

	    				/* clip other end */
	    				VSUB2( diff, *pt, *pt_prev );
	    				alpha = (-dist_prev + delta) / ( dist - dist_prev );
	    				VJOIN1( tmp_pt, *pt_prev, alpha, diff );
	    				MAT4X3PNT( last, psmat, tmp_pt );
	    				MAT4X3PNT( fin, psmat, *pt );
	    			}
	    			else
	    			{
	    				MAT4X3PNT( fin, psmat, *pt );
	    			}
	    		}
	    	}
		else
			MAT4X3PNT( fin, psmat, *pt );
	VMOVE( start, last );
	VMOVE( last, fin );
	break;
      }

      if(vclip( start, fin, dmp->dm_clipmin,
		dmp->dm_clipmax ) == 0)
	continue;

      fprintf(((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp,
	      "newpath %d %d moveto %d %d lineto stroke\n",
	      GED_TO_PS( start[0] * 2047 ),
	      GED_TO_PS( start[1] * 2047 ),
	      GED_TO_PS( fin[0] * 2047 ),
	      GED_TO_PS( fin[1] * 2047 ) );
      useful = 1;
    }
  }

  if(useful)
    return TCL_OK;

  return TCL_ERROR;
}

/*
 *			P S _ N O R M A L
 *
 * Restore the display processor to a normal mode of operation
 * (ie, not scaled, rotated, displaced, etc).
 * Turns off windowing.
 */
static int
ps_normal(struct dm *dmp)
{
  return TCL_OK;
}

/*
 *			P S _ D R A W S T R I N G 2 D
 *
 * Output a string into the displaylist.
 * The starting position of the beam is as specified.
 */
/* ARGSUSED */
static int
ps_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect)
{
  int sx, sy;

  if( !((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp )
    return TCL_ERROR;

  switch( size )  {
  default:
    /* Smallest */
    fprintf(((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp,"DFntS ");
    break;
  case 1:
    fprintf(((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp,"DFntM ");
    break;
  case 2:
    fprintf(((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp,"DFntL ");
    break;
  case 3:
    /* Largest */
    fprintf(((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp,"FntH ");
    break;
  }

  sx = x * 2047.0 + 2048;
  sy = y * 2047.0 + 2048;
  fprintf(((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp,
	  "(%s) %d %d moveto show\n", str, sx, sy );

  return TCL_OK;
}

/*
 *			P S _ D R A W L I N E 2 D
 *
 */
static int
ps_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2)
{
  int sx1, sy1;
  int sx2, sy2;

  if( !((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp )
    return TCL_ERROR;

  sx1 = x1 * 2047.0 + 2048;
  sx2 = x2 * 2047.0 + 2048;
  sy1 = y1 * 2047.0 + 2048;
  sy2 = y2 * 2047.0 + 2048;

  fprintf(((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp,
	  "newpath %d %d moveto %d %d lineto stroke\n",
	  sx1, sy1, sx2, sy2);

  return TCL_OK;
}

static int
ps_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y)
{
  return ps_drawLine2D(dmp, x, y, x, y);
}

static int
ps_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict, fastf_t transparency)
{
  return TCL_OK;
}
static int
ps_setBGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b)
{
  return TCL_OK;
}

static int
ps_setLineAttr(struct dm *dmp, int width, int style)
{
  dmp->dm_lineWidth = width;
  dmp->dm_lineStyle = style;

  if(style == DM_DASHED_LINE)
    fprintf(((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp, "DDV "); /* Dot-dashed vectors */
  else
    fprintf(((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp, "NV "); /* Normal vectors */

  return TCL_OK;
}

/* ARGSUSED */
static int
ps_debug(struct dm *dmp, int lvl)
{
  dmp->dm_debugLevel = lvl;
  return TCL_OK;
}

static int
ps_setWinBounds(struct dm *dmp, register int *w)
{
  /* Compute the clipping bounds */
  dmp->dm_clipmin[0] = w[0] / 2048.;
  dmp->dm_clipmax[0] = w[1] / 2047.;
  dmp->dm_clipmin[1] = w[2] / 2048.;
  dmp->dm_clipmax[1] = w[3] / 2047.;

#if 0
  if(((struct ps_vars *)dmp->dm_vars.priv_vars)->zclip){
#else
  if (dmp->dm_zclip) {
#endif
    dmp->dm_clipmin[2] = w[4] / 2048.;
    dmp->dm_clipmax[2] = w[5] / 2047.;
  }else{
    dmp->dm_clipmin[2] = -1.0e20;
    dmp->dm_clipmax[2] = 1.0e20;
  }

  return TCL_OK;
}
@


1.38
log
@change conf.h to a wrapped config.h
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/libdm/dm-ps.c,v 1.37 2004/05/10 15:25:26 morrison Exp $ (BRL)";
@


1.37
log
@Bob Parker's view modifications, png framebuffer support, shaded drawing mode
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-ps.c,v 1.36 2004/04/05 07:45:07 morrison Exp $ (BRL)";
d26 5
a30 1
#include "conf.h"
@


1.36
log
@merge of ansi-6-0-branch into HEAD
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d59 1
a59 1
static int      ps_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict);
d81 2
d114 1
d117 1
d687 1
a687 1
ps_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict)
@


1.35
log
@merge of windows-6-0-branch into head
@
text
@d52 11
a62 10
struct dm	*ps_open();
static int	ps_close();
static int	ps_drawBegin(), ps_drawEnd();
static int	ps_normal(), ps_loadMatrix();
static int	ps_drawString2D(), ps_drawLine2D();
static int      ps_drawPoint2D();
static int	ps_drawVList();
static int      ps_setFGColor();
static int      ps_setLineAttr();
static int	ps_setWinBounds(), ps_debug();
d75 1
a75 1
  Nu_int0,
d130 1
a130 4
ps_open(interp, argc, argv)
     Tcl_Interp *interp;
     int	argc;
     char	*argv[];
d356 1
a356 2
ps_close(dmp)
struct dm *dmp;
d382 1
a382 2
ps_drawBegin(dmp)
struct dm *dmp;
d391 1
a391 2
ps_drawEnd(dmp)
struct dm *dmp;
d410 1
a410 4
ps_loadMatrix(dmp, mat, which_eye)
struct dm *dmp;
mat_t mat;
int which_eye;
d452 1
a452 3
ps_drawVList(dmp, vp)
struct dm *dmp;
register struct rt_vlist *vp;
d606 1
a606 2
ps_normal(dmp)
struct dm *dmp;
d619 1
a619 6
ps_drawString2D( dmp, str, x, y, size, use_aspect )
struct dm *dmp;
register char *str;
fastf_t x, y;
int size;
int use_aspect;
d656 1
a656 4
ps_drawLine2D(dmp, x1, y1, x2, y2)
struct dm *dmp;
fastf_t x1, y1;
fastf_t x2, y2;
d677 1
a677 3
ps_drawPoint2D(dmp, x, y)
struct dm *dmp;
fastf_t x, y;
d683 6
a688 4
ps_setFGColor(dmp, r, g, b, strict)
struct dm *dmp;
unsigned char r, g, b;
int strict;
d694 1
a694 4
ps_setLineAttr(dmp, width, style)
struct dm *dmp;
int width;
int style;
d709 1
a709 2
ps_debug(dmp, lvl)
struct dm *dmp;
d716 1
a716 3
ps_setWinBounds(dmp, w)
struct dm *dmp;
register int w[];
@


1.34
log
@update copyright to include span through 2003
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-ps.c,v 1.33 2002/08/20 17:07:45 jra Exp $ (BRL)";
d33 1
d35 1
@


1.33
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1985 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-ps.c,v 1.31 2001/04/02 21:38:01 morrison Exp $ (BRL)";
@


1.33.10.1
log
@merge from HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-ps.c,v 1.34 2004/02/02 17:39:08 morrison Exp $ (BRL)";
@


1.33.10.2
log
@merge from head
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-ps.c,v 1.33.10.1 2004/02/12 19:45:18 erikg Exp $ (BRL)";
@


1.33.10.3
log
@merge from head
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a32 1
#ifndef WIN32
a33 1
#endif
@


1.33.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-ps.c,v 1.33 2002/08/20 17:07:45 jra Exp $ (BRL)";
a32 1
#ifndef WIN32
a33 1
#endif
@


1.33.4.2
log
@sync to HEAD...
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libdm/dm-ps.c,v 1.33.4.1 2002/09/26 23:03:53 morrison Exp $ (BRL)";
@


1.33.2.1
log
@Initial ANSIfication
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-ps.c,v 1.33 2002/08/20 17:07:45 jra Exp $ (BRL)";
d50 10
a59 10
struct dm	*ps_open(Tcl_Interp *interp, int argc, char **argv);
static int	ps_close(struct dm *dmp);
static int	ps_drawBegin(struct dm *dmp), ps_drawEnd(struct dm *dmp);
static int	ps_normal(struct dm *dmp), ps_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye);
static int	ps_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect), ps_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2);
static int      ps_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y);
static int	ps_drawVList(struct dm *dmp, register struct bn_vlist *vp);
static int      ps_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict);
static int      ps_setLineAttr(struct dm *dmp, int width, int style);
static int	ps_setWinBounds(struct dm *dmp, register int *w), ps_debug(struct dm *dmp, int lvl);
d127 4
a130 1
ps_open(Tcl_Interp *interp, int argc, char **argv)
d356 2
a357 1
ps_close(struct dm *dmp)
d383 2
a384 1
ps_drawBegin(struct dm *dmp)
d393 2
a394 1
ps_drawEnd(struct dm *dmp)
d413 4
a416 1
ps_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye)
d458 3
a460 1
ps_drawVList(struct dm *dmp, register struct bn_vlist *vp)
d614 2
a615 1
ps_normal(struct dm *dmp)
d628 6
a633 1
ps_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect)
d670 4
a673 1
ps_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2)
d694 3
a696 1
ps_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y)
d702 4
a705 1
ps_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict)
d711 4
a714 1
ps_setLineAttr(struct dm *dmp, int width, int style)
d729 2
a730 1
ps_debug(struct dm *dmp, int lvl)
d737 3
a739 1
ps_setWinBounds(struct dm *dmp, register int *w)
@


1.33.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a32 1
#ifndef WIN32
a33 1
#endif
@


1.33.2.3
log
@replace null func with a real func for bg to parallel fg func
@
text
@a59 1
static int      ps_setBGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b);
d74 1
a74 1
  ps_setBGColor,
a682 5
{
  return TCL_OK;
}
static int
ps_setBGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b)
@


1.32
log
@Converted from K&R to ANSI C - RFH
@
text
@d50 10
a59 10
struct dm	*ps_open(Tcl_Interp *interp, int argc, char **argv);
static int	ps_close(struct dm *dmp);
static int	ps_drawBegin(struct dm *dmp), ps_drawEnd(struct dm *dmp);
static int	ps_normal(struct dm *dmp), ps_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye);
static int	ps_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect), ps_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2);
static int      ps_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y);
static int	ps_drawVList(struct dm *dmp, register struct bn_vlist *vp);
static int      ps_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict);
static int      ps_setLineAttr(struct dm *dmp, int width, int style);
static int	ps_setWinBounds(struct dm *dmp, register int *w), ps_debug(struct dm *dmp, int lvl);
d127 4
a130 1
ps_open(Tcl_Interp *interp, int argc, char **argv)
d356 2
a357 1
ps_close(struct dm *dmp)
d383 2
a384 1
ps_drawBegin(struct dm *dmp)
d393 2
a394 1
ps_drawEnd(struct dm *dmp)
d413 4
a416 1
ps_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye)
d458 3
a460 1
ps_drawVList(struct dm *dmp, register struct bn_vlist *vp)
d614 2
a615 1
ps_normal(struct dm *dmp)
d628 6
a633 1
ps_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect)
d670 4
a673 1
ps_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2)
d694 3
a696 1
ps_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y)
d702 4
a705 1
ps_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict)
d711 4
a714 1
ps_setLineAttr(struct dm *dmp, int width, int style)
d729 2
a730 1
ps_debug(struct dm *dmp, int lvl)
d737 3
a739 1
ps_setWinBounds(struct dm *dmp, register int *w)
@


1.31
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-ps.c,v 1.30 2001/03/31 01:56:52 morrison Exp $ (BRL)";
d50 10
a59 10
struct dm	*ps_open();
static int	ps_close();
static int	ps_drawBegin(), ps_drawEnd();
static int	ps_normal(), ps_loadMatrix();
static int	ps_drawString2D(), ps_drawLine2D();
static int      ps_drawPoint2D();
static int	ps_drawVList();
static int      ps_setFGColor();
static int      ps_setLineAttr();
static int	ps_setWinBounds(), ps_debug();
d127 1
a127 4
ps_open(interp, argc, argv)
     Tcl_Interp *interp;
     int	argc;
     char	*argv[];
d353 1
a353 2
ps_close(dmp)
struct dm *dmp;
d379 1
a379 2
ps_drawBegin(dmp)
struct dm *dmp;
d388 1
a388 2
ps_drawEnd(dmp)
struct dm *dmp;
d407 1
a407 4
ps_loadMatrix(dmp, mat, which_eye)
struct dm *dmp;
mat_t mat;
int which_eye;
d449 1
a449 3
ps_drawVList(dmp, vp)
struct dm *dmp;
register struct rt_vlist *vp;
d603 1
a603 2
ps_normal(dmp)
struct dm *dmp;
d616 1
a616 6
ps_drawString2D( dmp, str, x, y, size, use_aspect )
struct dm *dmp;
register char *str;
fastf_t x, y;
int size;
int use_aspect;
d653 1
a653 4
ps_drawLine2D(dmp, x1, y1, x2, y2)
struct dm *dmp;
fastf_t x1, y1;
fastf_t x2, y2;
d674 1
a674 3
ps_drawPoint2D(dmp, x, y)
struct dm *dmp;
fastf_t x, y;
d680 1
a680 4
ps_setFGColor(dmp, r, g, b, strict)
struct dm *dmp;
unsigned char r, g, b;
int strict;
d686 1
a686 4
ps_setLineAttr(dmp, width, style)
struct dm *dmp;
int width;
int style;
d701 1
a701 2
ps_debug(dmp, lvl)
struct dm *dmp;
d708 1
a708 3
ps_setWinBounds(dmp, w)
struct dm *dmp;
register int w[];
@


1.30
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-ps.c,v 1.29 2000/10/18 18:10:33 butler Exp $ (BRL)";
d441 1
a441 1
	bn_mat_copy(psmat, mat);
@


1.29
log
@Patches for compiling under RedHat 7.0
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-ps.c,v 1.28 2000/08/31 18:16:42 bparker Exp $ (BRL)";
d344 1
a344 1
	bn_mat_idn(psmat);
@


1.28
log
@Mods to rid libdm of two globals: tkwin and interp
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-ps.c,v 1.27 2000/07/12 03:24:44 cjohnson Exp $ (BRL)";
d30 3
@


1.27
log
@LINT from gcc -Wall.  Includes some modifications to bu.h and fb.h
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-ps.c,v 1.26 2000/06/30 20:54:06 bparker Exp $ (BRL)";
d107 2
a108 1
  0				/* no zclipping */
d124 2
a125 1
ps_open(argc, argv)
d138 1
d417 1
a417 1
	obj = Tcl_GetObjResult(interp);
d440 1
a440 1
	Tcl_SetObjResult(interp, obj);
@


1.26
log
@Replace deprecated Tcl_AppendResult stuff with Tcl_Obj stuff.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-ps.c,v 1.25 1999/12/27 21:10:48 bparker Exp $ (BRL)";
d96 7
a102 7
  0,
  0,
  0,
  0,
  0,
  0,				/* clipmin */
  0,				/* clipmax */
@


1.25
log
@*- mods reflecting new members of "struct dm"
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-ps.c,v 1.24 1999/12/17 16:38:47 bparker Exp $ (BRL)";
d124 2
a125 2
int argc;
char *argv[];
d127 14
a140 92
  static int count = 0;
  struct dm *dmp;

  BU_GETSTRUCT(dmp, dm);
  if(dmp == DM_NULL)
    return DM_NULL;

  *dmp = dm_ps;  /* struct copy */

  dmp->dm_vars.priv_vars = (genptr_t)bu_calloc(1, sizeof(struct ps_vars), "ps_open: ps_vars");
  if(dmp->dm_vars.priv_vars == (genptr_t)NULL){
    bu_free(dmp, "ps_open: dmp");
    return DM_NULL;
  }

  bu_vls_init(&dmp->dm_pathName);
  bu_vls_init(&dmp->dm_tkName);
  bu_vls_printf(&dmp->dm_pathName, ".dm_ps%d", count++);
  bu_vls_printf(&dmp->dm_tkName, "dm_ps%d", count++);

  bu_vls_init(&((struct ps_vars *)dmp->dm_vars.priv_vars)->fname);
  bu_vls_init(&((struct ps_vars *)dmp->dm_vars.priv_vars)->font);
  bu_vls_init(&((struct ps_vars *)dmp->dm_vars.priv_vars)->title);
  bu_vls_init(&((struct ps_vars *)dmp->dm_vars.priv_vars)->creator);

  /* set defaults */
  bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars.priv_vars)->font, "Courier");
  bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars.priv_vars)->title, "No Title");
  bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars.priv_vars)->creator, "LIBDM dm-ps");
  ((struct ps_vars *)dmp->dm_vars.priv_vars)->scale = 0.0791;
  ((struct ps_vars *)dmp->dm_vars.priv_vars)->linewidth = 4;
  ((struct ps_vars *)dmp->dm_vars.priv_vars)->zclip = 0;

  /* skip first argument */
  --argc; ++argv;

  /* Process any options */
  while(argv[0] != (char *)0 && argv[0][0] == '-'){
    switch(argv[0][1]){
    case 'f':               /* font */
      if(argv[0][2] != '\0')
	bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars.priv_vars)->font, &argv[0][2]);
      else{
	argv++;
	if(argv[0] == (char *)0 || argv[0][0] == '-'){
	  Tcl_AppendResult(interp, ps_usage, (char *)0);
	  (void)ps_close(dmp);
	  return DM_NULL;
	}else
	  bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars.priv_vars)->font, &argv[0][0]);
      }
      break;
    case 't':               /* title */
      if(argv[0][2] != '\0')
	bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars.priv_vars)->title, &argv[0][2]);
      else{
	argv++;
	if(argv[0] == (char *)0 || argv[0][0] == '-'){
	  Tcl_AppendResult(interp, ps_usage, (char *)0);
	  (void)ps_close(dmp);
	  return DM_NULL;
	}else
	  bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars.priv_vars)->title, &argv[0][0]);
      }
      break;
    case 'c':               /* creator */
      if(argv[0][2] != '\0')
	bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars.priv_vars)->creator, &argv[0][2]);
      else{
	argv++;
	if(argv[0] == (char *)0 || argv[0][0] == '-'){
	  Tcl_AppendResult(interp, ps_usage, (char *)0);
	  (void)ps_close(dmp);
	  return DM_NULL;
	}else
	  bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars.priv_vars)->creator, &argv[0][0]);
      }
      break;
    case 's':               /* size in inches */
      {
	fastf_t size;

	if(argv[0][2] != '\0')
	  sscanf(&argv[0][2], "%lf", &size);
	else{
	  argv++;
	  if(argv[0] == (char *)0 || argv[0][0] == '-'){
	    Tcl_AppendResult(interp, ps_usage, (char *)0);
	    (void)ps_close(dmp);
	    return DM_NULL;
	  }else
	    sscanf(&argv[0][0], "%lf", &size);
d143 110
a252 17
	((struct ps_vars *)dmp->dm_vars.priv_vars)->scale = size * 0.017578125;
      }
      break;
    case 'l':               /* line width */
      if(argv[0][2] != '\0')
	sscanf(&argv[0][2], "%d", &((struct ps_vars *)dmp->dm_vars.priv_vars)->linewidth);
      else{
	argv++;
	if(argv[0] == (char *)0 || argv[0][0] == '-'){
	  Tcl_AppendResult(interp, ps_usage, (char *)0);
	  (void)ps_close(dmp);
	  return DM_NULL;
	}else
	  sscanf(&argv[0][0], "%d", &((struct ps_vars *)dmp->dm_vars.priv_vars)->linewidth);
      }
      break;
    case 'z':
d254 1
a254 1
      ((struct ps_vars *)dmp->dm_vars.priv_vars)->zclip = 1;
d256 1
a256 1
      dmp->dm_zclip = 1;
d258 31
a288 25
      break;
    default:
      Tcl_AppendResult(interp, ps_usage, (char *)0);
      (void)ps_close(dmp);
      return DM_NULL;
    }
    argv++;
  }

  if(argv[0] == (char *)0){
    Tcl_AppendResult(interp, "no filename specified\n", (char *)NULL);
    (void)ps_close(dmp);
    return DM_NULL;
  }

  bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars.priv_vars)->fname, argv[0]);

  if( (((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp =
       fopen(bu_vls_addr(&((struct ps_vars *)dmp->dm_vars.priv_vars)->fname), "w")) == NULL){
    Tcl_AppendResult(interp, "f_ps: Error opening file - ",
		     ((struct ps_vars *)dmp->dm_vars.priv_vars)->fname,
		     "\n", (char *)NULL);
    (void)ps_close(dmp);
    return DM_NULL;
  }
d290 3
a292 3
  setbuf( ((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp,
	  ((struct ps_vars *)dmp->dm_vars.priv_vars)->ttybuf );
  fprintf(((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp,"%%!PS-Adobe-1.0\n\
d295 1
a295 1
	  bu_vls_addr(&((struct ps_vars *)dmp->dm_vars.priv_vars)->font));
d297 2
a298 2
  fprintf(((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp, "%%%%Title: %s\n",
	  bu_vls_addr(&((struct ps_vars *)dmp->dm_vars.priv_vars)->title));
d300 1
a300 1
  fprintf(((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp, "\
d304 2
a305 1
\n", bu_vls_addr(&((struct ps_vars *)dmp->dm_vars.priv_vars)->creator));
d307 1
a307 1
  fprintf(((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp, "\
d329 8
a336 7
", ((struct ps_vars *)dmp->dm_vars.priv_vars)->linewidth,
	  bu_vls_addr(&((struct ps_vars *)dmp->dm_vars.priv_vars)->font),
	  bu_vls_addr(&((struct ps_vars *)dmp->dm_vars.priv_vars)->font),
	  bu_vls_addr(&((struct ps_vars *)dmp->dm_vars.priv_vars)->font),
	  bu_vls_addr(&((struct ps_vars *)dmp->dm_vars.priv_vars)->font),
	  ((struct ps_vars *)dmp->dm_vars.priv_vars)->scale,
	  ((struct ps_vars *)dmp->dm_vars.priv_vars)->scale);
d338 1
a338 1
  bn_mat_idn(psmat);
d340 2
a341 1
  return dmp;
d412 1
a412 2
  if(((struct ps_vars *)dmp->dm_vars.priv_vars)->debug){
    struct bu_vls tmp_vls;
d414 16
a429 1
    Tcl_AppendResult(interp, "ps_loadMatrix()\n", (char *)NULL);
d431 5
a435 11
    bu_vls_init(&tmp_vls);
    bu_vls_printf(&tmp_vls, "which eye = %d\t", which_eye);
    bu_vls_printf(&tmp_vls, "transformation matrix = \n");
    bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[0], mat[4], mat[8],mat[12]);
    bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[1], mat[5], mat[9],mat[13]);
    bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[2], mat[6], mat[10],mat[14]);
    bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[3], mat[7], mat[11],mat[15]);

    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
    bu_vls_free(&tmp_vls);
  }
d437 2
a438 2
  bn_mat_copy(psmat, mat);
  return TCL_OK;
@


1.25.2.1
log
@Removed two globals: interp and tkwin
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-ps.c,v 1.28 2000/08/31 18:16:42 bparker Exp $ (BRL)";
d96 7
a102 7
  {0, 0, 0, 0, 0},		/* bu_vls path name*/
  {0, 0, 0, 0, 0},		/* bu_vls full name drawing window */
  {0, 0, 0, 0, 0},		/* bu_vls short name drawing window */
  {0, 0, 0},			/* bg color */
  {0, 0, 0},			/* fg color */
  {0.0, 0.0, 0.0},		/* clipmin */
  {0.0, 0.0, 0.0},		/* clipmax */
d107 1
a107 2
  0,				/* no zclipping */
  0				/* Tcl interpreter */
d123 3
a125 4
ps_open(interp, argc, argv)
     Tcl_Interp *interp;
     int	argc;
     char	*argv[];
d127 92
a218 15
	static int	count = 0;
	struct dm	*dmp;
	Tcl_Obj		*obj;

	BU_GETSTRUCT(dmp, dm);
	if (dmp == DM_NULL)
		return DM_NULL;

	*dmp = dm_ps;  /* struct copy */
	dmp->dm_interp = interp;

	dmp->dm_vars.priv_vars = (genptr_t)bu_calloc(1, sizeof(struct ps_vars), "ps_open: ps_vars");
	if (dmp->dm_vars.priv_vars == (genptr_t)NULL) {
		bu_free(dmp, "ps_open: dmp");
		return DM_NULL;
d221 17
a237 110
	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);

	bu_vls_init(&dmp->dm_pathName);
	bu_vls_init(&dmp->dm_tkName);
	bu_vls_printf(&dmp->dm_pathName, ".dm_ps%d", count++);
	bu_vls_printf(&dmp->dm_tkName, "dm_ps%d", count++);

	bu_vls_init(&((struct ps_vars *)dmp->dm_vars.priv_vars)->fname);
	bu_vls_init(&((struct ps_vars *)dmp->dm_vars.priv_vars)->font);
	bu_vls_init(&((struct ps_vars *)dmp->dm_vars.priv_vars)->title);
	bu_vls_init(&((struct ps_vars *)dmp->dm_vars.priv_vars)->creator);

	/* set defaults */
	bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars.priv_vars)->font, "Courier");
	bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars.priv_vars)->title, "No Title");
	bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars.priv_vars)->creator, "LIBDM dm-ps");
	((struct ps_vars *)dmp->dm_vars.priv_vars)->scale = 0.0791;
	((struct ps_vars *)dmp->dm_vars.priv_vars)->linewidth = 4;
	((struct ps_vars *)dmp->dm_vars.priv_vars)->zclip = 0;

	/* skip first argument */
	--argc; ++argv;

	/* Process any options */
	while (argv[0] != (char *)0 && argv[0][0] == '-') {
		switch (argv[0][1]) {
		case 'f':               /* font */
			if (argv[0][2] != '\0')
				bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars.priv_vars)->font, &argv[0][2]);
			else {
				argv++;
				if (argv[0] == (char *)0 || argv[0][0] == '-') {
					Tcl_AppendStringsToObj(obj, ps_usage, (char *)0);
					(void)ps_close(dmp);

					Tcl_SetObjResult(interp, obj);
					return DM_NULL;
				} else
					bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars.priv_vars)->font, &argv[0][0]);
			}
			break;
		case 't':               /* title */
			if (argv[0][2] != '\0')
				bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars.priv_vars)->title, &argv[0][2]);
			else {
				argv++;
				if (argv[0] == (char *)0 || argv[0][0] == '-') {
					Tcl_AppendStringsToObj(obj, ps_usage, (char *)0);
					(void)ps_close(dmp);

					Tcl_SetObjResult(interp, obj);
					return DM_NULL;
				} else
					bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars.priv_vars)->title, &argv[0][0]);
			}
			break;
		case 'c':               /* creator */
			if (argv[0][2] != '\0')
				bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars.priv_vars)->creator, &argv[0][2]);
			else {
				argv++;
				if (argv[0] == (char *)0 || argv[0][0] == '-') {
					Tcl_AppendStringsToObj(obj, ps_usage, (char *)0);
					(void)ps_close(dmp);

					Tcl_SetObjResult(interp, obj);
					return DM_NULL;
				} else
					bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars.priv_vars)->creator, &argv[0][0]);
			}
			break;
		case 's':               /* size in inches */
			{
				fastf_t size;

				if (argv[0][2] != '\0')
					sscanf(&argv[0][2], "%lf", &size);
				else {
					argv++;
					if (argv[0] == (char *)0 || argv[0][0] == '-') {
						Tcl_AppendStringsToObj(obj, ps_usage, (char *)0);
						(void)ps_close(dmp);

						Tcl_SetObjResult(interp, obj);
						return DM_NULL;
					} else
						sscanf(&argv[0][0], "%lf", &size);
				}

				((struct ps_vars *)dmp->dm_vars.priv_vars)->scale = size * 0.017578125;
			}
			break;
		case 'l':               /* line width */
			if (argv[0][2] != '\0')
				sscanf(&argv[0][2], "%d", &((struct ps_vars *)dmp->dm_vars.priv_vars)->linewidth);
			else{
				argv++;
				if (argv[0] == (char *)0 || argv[0][0] == '-') {
					Tcl_AppendStringsToObj(obj, ps_usage, (char *)0);
					(void)ps_close(dmp);

					Tcl_SetObjResult(interp, obj);
					return DM_NULL;
				} else
					sscanf(&argv[0][0], "%d", &((struct ps_vars *)dmp->dm_vars.priv_vars)->linewidth);
			}
			break;
		case 'z':
d239 1
a239 1
			((struct ps_vars *)dmp->dm_vars.priv_vars)->zclip = 1;
d241 1
a241 1
			dmp->dm_zclip = 1;
d243 25
a267 31
			break;
		default:
			Tcl_AppendStringsToObj(obj, ps_usage, (char *)0);
			(void)ps_close(dmp);

			Tcl_SetObjResult(interp, obj);
			return DM_NULL;
		}
		argv++;
	}

	if(argv[0] == (char *)0) {
		Tcl_AppendStringsToObj(obj, "no filename specified\n", (char *)NULL);
		(void)ps_close(dmp);

		Tcl_SetObjResult(interp, obj);
		return DM_NULL;
	}

	bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars.priv_vars)->fname, argv[0]);

	if ((((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp =
	     fopen(bu_vls_addr(&((struct ps_vars *)dmp->dm_vars.priv_vars)->fname), "w")) == NULL) {
		Tcl_AppendStringsToObj(obj, "f_ps: Error opening file - ",
				 ((struct ps_vars *)dmp->dm_vars.priv_vars)->fname,
				 "\n", (char *)NULL);
		(void)ps_close(dmp);

		Tcl_SetObjResult(interp, obj);
		return DM_NULL;
	}
d269 3
a271 3
	setbuf(((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp,
	       ((struct ps_vars *)dmp->dm_vars.priv_vars)->ttybuf );
	fprintf(((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp,"%%!PS-Adobe-1.0\n\
d274 1
a274 1
		bu_vls_addr(&((struct ps_vars *)dmp->dm_vars.priv_vars)->font));
d276 2
a277 2
	fprintf(((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp, "%%%%Title: %s\n",
		bu_vls_addr(&((struct ps_vars *)dmp->dm_vars.priv_vars)->title));
d279 1
a279 1
	fprintf(((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp, "\
d283 1
a283 2
\n",
		bu_vls_addr(&((struct ps_vars *)dmp->dm_vars.priv_vars)->creator));
d285 1
a285 1
	fprintf(((struct ps_vars *)dmp->dm_vars.priv_vars)->ps_fp, "\
d307 7
a313 8
",
		((struct ps_vars *)dmp->dm_vars.priv_vars)->linewidth,
		bu_vls_addr(&((struct ps_vars *)dmp->dm_vars.priv_vars)->font),
		bu_vls_addr(&((struct ps_vars *)dmp->dm_vars.priv_vars)->font),
		bu_vls_addr(&((struct ps_vars *)dmp->dm_vars.priv_vars)->font),
		bu_vls_addr(&((struct ps_vars *)dmp->dm_vars.priv_vars)->font),
		((struct ps_vars *)dmp->dm_vars.priv_vars)->scale,
		((struct ps_vars *)dmp->dm_vars.priv_vars)->scale);
d315 1
a315 1
	bn_mat_idn(psmat);
d317 1
a317 2
	Tcl_SetObjResult(interp, obj);
	return dmp;
d388 2
a389 18
	Tcl_Obj	*obj;

	obj = Tcl_GetObjResult(dmp->dm_interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);

	if (((struct ps_vars *)dmp->dm_vars.priv_vars)->debug) {
		struct bu_vls tmp_vls;

		Tcl_AppendStringsToObj(obj, "ps_loadMatrix()\n", (char *)NULL);

		bu_vls_init(&tmp_vls);
		bu_vls_printf(&tmp_vls, "which eye = %d\t", which_eye);
		bu_vls_printf(&tmp_vls, "transformation matrix = \n");
		bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[0], mat[4], mat[8],mat[12]);
		bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[1], mat[5], mat[9],mat[13]);
		bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[2], mat[6], mat[10],mat[14]);
		bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[3], mat[7], mat[11],mat[15]);
d391 1
a391 3
		Tcl_AppendStringsToObj(obj, bu_vls_addr(&tmp_vls), (char *)NULL);
		bu_vls_free(&tmp_vls);
	}
d393 11
a403 1
	bn_mat_copy(psmat, mat);
d405 2
a406 2
	Tcl_SetObjResult(dmp->dm_interp, obj);
	return TCL_OK;
@


1.24
log
@*- mods to reflect new member (dm_perspective) of struct dm
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-ps.c,v 1.23 1999/12/01 13:30:20 bparker Exp $ (BRL)";
d71 1
d73 2
d105 2
@


1.23
log
@*- mods to reflect changes to struct dm
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-ps.c,v 1.22 1998/06/15 18:55:07 bparker Exp $ (BRL)";
d101 1
d415 1
a415 1
ps_drawVList( dmp, vp, perspective )
a417 1
double perspective;
d461 1
a461 1
		if( perspective > 0.0 )
d487 1
a487 1
		if( perspective > 0.0 )
@


1.22
log
@*- add support for new routines:
	dm_setFGColor(), dm_setBGColor(), dm_getBGColor()
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/libdm/dm-ps.c,v 1.21 1998/06/12 19:48:18 bparker Exp $ (BRL)";
a69 1
  Nu_int0,
d80 2
a81 1
  PLOTBOUND,
d95 7
a101 1
  0
d232 1
d234 3
d543 2
a544 2
      if(vclip( start, fin, ((struct ps_vars *)dmp->dm_vars.priv_vars)->clipmin,
		((struct ps_vars *)dmp->dm_vars.priv_vars)->clipmax ) == 0)
d661 1
a661 1
register short r, g, b;
d689 1
d699 4
a702 4
  ((struct ps_vars *)dmp->dm_vars.priv_vars)->clipmin[0] = w[0] / 2048.;
  ((struct ps_vars *)dmp->dm_vars.priv_vars)->clipmax[0] = w[1] / 2047.;
  ((struct ps_vars *)dmp->dm_vars.priv_vars)->clipmin[1] = w[2] / 2048.;
  ((struct ps_vars *)dmp->dm_vars.priv_vars)->clipmax[1] = w[3] / 2047.;
d704 1
d706 5
a710 2
    ((struct ps_vars *)dmp->dm_vars.priv_vars)->clipmin[2] = w[4] / 2048.;
    ((struct ps_vars *)dmp->dm_vars.priv_vars)->clipmax[2] = w[5] / 2047.;
d712 2
a713 2
    ((struct ps_vars *)dmp->dm_vars.priv_vars)->clipmin[2] = -1.0e20;
    ((struct ps_vars *)dmp->dm_vars.priv_vars)->clipmax[2] = 1.0e20;
@


1.21
log
@*- change _setColor() to _setFGColor()
*- add _setBGColor()
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/libdm/dm-ps.c,v 1.20 1998/03/03 14:59:13 jra Exp $ (BRL)";
d69 1
@


1.20
log
@Fixed clipping in perspective mode.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-ps.c,v 1.19 1998/02/26 15:21:55 bparker Exp $ (BRL)";
d54 1
a54 1
static int      ps_setColor();
d68 2
a69 1
  ps_setColor,
d648 1
a648 1
ps_setColor(dmp, r, g, b, strict)
@


1.19
log
@*- mods to ps_drawPoint2D(), ps_drawLine2D() and ps_drawString2D()
	to use floats instead of ints for x/y parameters
*- use new dm_vars structure
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-ps.c,v 1.18 1997/11/03 20:10:38 bparker Exp bparker $ (BRL)";
d402 1
a402 1
ps_drawVList( dmp, vp )
d405 1
d409 4
d425 10
d449 21
a469 1
	MAT4X3PNT( last, psmat, *pt );
d475 51
a525 1
	MAT4X3PNT( fin, psmat, *pt );
@


1.18
log
@mods to ps_setWinBounds()
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-ps.c,v 1.17 1997/10/10 12:55:49 bparker Exp bparker $ (BRL)";
d90 1
a92 1
  0,
d122 2
a123 2
  dmp->dm_vars = (genptr_t)bu_calloc(1, sizeof(struct ps_vars), "ps_open: ps_vars");
  if(dmp->dm_vars == (genptr_t)NULL){
d133 4
a136 4
  bu_vls_init(&((struct ps_vars *)dmp->dm_vars)->fname);
  bu_vls_init(&((struct ps_vars *)dmp->dm_vars)->font);
  bu_vls_init(&((struct ps_vars *)dmp->dm_vars)->title);
  bu_vls_init(&((struct ps_vars *)dmp->dm_vars)->creator);
d139 6
a144 6
  bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars)->font, "Courier");
  bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars)->title, "No Title");
  bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars)->creator, "LIBDM dm-ps");
  ((struct ps_vars *)dmp->dm_vars)->scale = 0.0791;
  ((struct ps_vars *)dmp->dm_vars)->linewidth = 4;
  ((struct ps_vars *)dmp->dm_vars)->zclip = 0;
d154 1
a154 1
	bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars)->font, &argv[0][2]);
d162 1
a162 1
	  bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars)->font, &argv[0][0]);
d167 1
a167 1
	bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars)->title, &argv[0][2]);
d175 1
a175 1
	  bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars)->title, &argv[0][0]);
d180 1
a180 1
	bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars)->creator, &argv[0][2]);
d188 1
a188 1
	  bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars)->creator, &argv[0][0]);
d207 1
a207 1
	((struct ps_vars *)dmp->dm_vars)->scale = size * 0.017578125;
d212 1
a212 1
	sscanf(&argv[0][2], "%d", &((struct ps_vars *)dmp->dm_vars)->linewidth);
d220 1
a220 1
	  sscanf(&argv[0][0], "%d", &((struct ps_vars *)dmp->dm_vars)->linewidth);
d224 1
a224 1
      ((struct ps_vars *)dmp->dm_vars)->zclip = 1;
d240 1
a240 1
  bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars)->fname, argv[0]);
d242 2
a243 2
  if( (((struct ps_vars *)dmp->dm_vars)->ps_fp =
       fopen(bu_vls_addr(&((struct ps_vars *)dmp->dm_vars)->fname), "w")) == NULL){
d245 1
a245 1
		     ((struct ps_vars *)dmp->dm_vars)->fname,
d251 3
a253 3
  setbuf( ((struct ps_vars *)dmp->dm_vars)->ps_fp,
	  ((struct ps_vars *)dmp->dm_vars)->ttybuf );
  fprintf(((struct ps_vars *)dmp->dm_vars)->ps_fp,"%%!PS-Adobe-1.0\n\
d256 1
a256 1
	  bu_vls_addr(&((struct ps_vars *)dmp->dm_vars)->font));
d258 2
a259 2
  fprintf(((struct ps_vars *)dmp->dm_vars)->ps_fp, "%%%%Title: %s\n",
	  bu_vls_addr(&((struct ps_vars *)dmp->dm_vars)->title));
d261 1
a261 1
  fprintf(((struct ps_vars *)dmp->dm_vars)->ps_fp, "\
d265 1
a265 1
\n", bu_vls_addr(&((struct ps_vars *)dmp->dm_vars)->creator));
d267 1
a267 1
  fprintf(((struct ps_vars *)dmp->dm_vars)->ps_fp, "\
d289 7
a295 7
", ((struct ps_vars *)dmp->dm_vars)->linewidth,
	  bu_vls_addr(&((struct ps_vars *)dmp->dm_vars)->font),
	  bu_vls_addr(&((struct ps_vars *)dmp->dm_vars)->font),
	  bu_vls_addr(&((struct ps_vars *)dmp->dm_vars)->font),
	  bu_vls_addr(&((struct ps_vars *)dmp->dm_vars)->font),
	  ((struct ps_vars *)dmp->dm_vars)->scale,
	  ((struct ps_vars *)dmp->dm_vars)->scale);
d311 1
a311 1
  if(!((struct ps_vars *)dmp->dm_vars)->ps_fp)
d314 2
a315 2
  fputs("%end(plot)\n", ((struct ps_vars *)dmp->dm_vars)->ps_fp);
  (void)fclose(((struct ps_vars *)dmp->dm_vars)->ps_fp);
d319 5
a323 5
  bu_vls_free(&((struct ps_vars *)dmp->dm_vars)->fname);
  bu_vls_free(&((struct ps_vars *)dmp->dm_vars)->font);
  bu_vls_free(&((struct ps_vars *)dmp->dm_vars)->title);
  bu_vls_free(&((struct ps_vars *)dmp->dm_vars)->creator);
  bu_free(dmp->dm_vars, "ps_close: ps_vars");
d348 1
a348 1
  if( !((struct ps_vars *)dmp->dm_vars)->ps_fp )
d352 2
a353 2
	((struct ps_vars *)dmp->dm_vars)->ps_fp);
  (void)fflush( ((struct ps_vars *)dmp->dm_vars)->ps_fp );
d370 1
a370 1
  if(((struct ps_vars *)dmp->dm_vars)->debug){
d410 1
a410 1
  if( !((struct ps_vars *)dmp->dm_vars)->ps_fp )
d415 1
a415 1
    fprintf(((struct ps_vars *)dmp->dm_vars)->ps_fp, "DDV ");		/* Dot-dashed vectors */
d417 1
a417 1
    fprintf(((struct ps_vars *)dmp->dm_vars)->ps_fp, "NV ");		/* Normal vectors */
d446 2
a447 2
      if(vclip( start, fin, ((struct ps_vars *)dmp->dm_vars)->clipmin,
		((struct ps_vars *)dmp->dm_vars)->clipmax ) == 0)
d450 1
a450 1
      fprintf(((struct ps_vars *)dmp->dm_vars)->ps_fp,
d481 1
a481 1
 *			P S _ P U T S
d491 1
a491 1
int x, y;
d495 3
a497 1
  if( !((struct ps_vars *)dmp->dm_vars)->ps_fp )
d503 1
a503 1
    fprintf(((struct ps_vars *)dmp->dm_vars)->ps_fp,"DFntS ");
d506 1
a506 1
    fprintf(((struct ps_vars *)dmp->dm_vars)->ps_fp,"DFntM ");
d509 1
a509 1
    fprintf(((struct ps_vars *)dmp->dm_vars)->ps_fp,"DFntL ");
d513 1
a513 1
    fprintf(((struct ps_vars *)dmp->dm_vars)->ps_fp,"FntH ");
d517 4
a520 2
  fprintf(((struct ps_vars *)dmp->dm_vars)->ps_fp,
	  "(%s) %d %d moveto show\n", str, GED_TO_PS(x), GED_TO_PS(y) );
d530 1
a530 1
ps_drawLine2D( dmp, x1, y1, x2, y2 )
d532 2
a533 2
int x1, y1;
int x2, y2;
d535 4
a538 1
  if( !((struct ps_vars *)dmp->dm_vars)->ps_fp )
d541 6
a546 1
  fprintf(((struct ps_vars *)dmp->dm_vars)->ps_fp,
d548 1
a548 2
	  GED_TO_PS(x1), GED_TO_PS(y1),
	  GED_TO_PS(x2), GED_TO_PS(y2) );
d556 1
a556 1
int x, y;
d580 1
a580 1
    fprintf(((struct ps_vars *)dmp->dm_vars)->ps_fp, "DDV "); /* Dot-dashed vectors */
d582 1
a582 1
    fprintf(((struct ps_vars *)dmp->dm_vars)->ps_fp, "NV "); /* Normal vectors */
d601 8
a608 8
  ((struct ps_vars *)dmp->dm_vars)->clipmin[0] = w[0] / 2048.;
  ((struct ps_vars *)dmp->dm_vars)->clipmax[0] = w[1] / 2047.;
  ((struct ps_vars *)dmp->dm_vars)->clipmin[1] = w[2] / 2048.;
  ((struct ps_vars *)dmp->dm_vars)->clipmax[1] = w[3] / 2047.;

  if(((struct ps_vars *)dmp->dm_vars)->zclip){
    ((struct ps_vars *)dmp->dm_vars)->clipmin[2] = w[4] / 2048.;
    ((struct ps_vars *)dmp->dm_vars)->clipmax[2] = w[5] / 2047.;
d610 2
a611 2
    ((struct ps_vars *)dmp->dm_vars)->clipmin[2] = -1.0e20;
    ((struct ps_vars *)dmp->dm_vars)->clipmax[2] = 1.0e20;
@


1.17
log
@got rid of eventHandler
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-ps.c,v 1.16 1997/09/23 21:15:29 bparker Exp bparker $ (BRL)";
d50 1
a50 1
static int	ps_normal(), ps_newrot();
d52 1
a52 1
static int      ps_drawVertex2D();
d63 1
a63 1
  ps_newrot,
d66 1
a66 1
  ps_drawVertex2D,
d360 3
a362 1
 *  Stub.
a363 1
/* ARGSUSED */
d365 1
a365 1
ps_newrot(dmp, mat, which_eye)
d370 17
d522 1
a522 1
 *			P S _ 2 D _ G O T O
a533 7
#if 0
  if( dashed )
    fprintf(((struct ps_vars *)dmp->dm_vars)->ps_fp, "DDV ");	/* Dot-dashed vectors */
  else
    fprintf(((struct ps_vars *)dmp->dm_vars)->ps_fp, "NV ");		/* Normal vectors */
#endif

d543 1
a543 1
ps_drawVertex2D(dmp, x, y)
d590 4
a593 4
  ((struct ps_vars *)dmp->dm_vars)->clipmin[0] = w[1] / 2048.;
  ((struct ps_vars *)dmp->dm_vars)->clipmax[0] = w[0] / 2047.;
  ((struct ps_vars *)dmp->dm_vars)->clipmin[1] = w[3] / 2048.;
  ((struct ps_vars *)dmp->dm_vars)->clipmax[1] = w[2] / 2047.;
d596 2
a597 2
    ((struct ps_vars *)dmp->dm_vars)->clipmin[2] = w[5] / 2048.;
    ((struct ps_vars *)dmp->dm_vars)->clipmax[2] = w[4] / 2047.;
@


1.16
log
@add zclip
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-ps.c,v 1.15 1997/05/21 13:02:35 bparker Exp bparker $ (BRL)";
d76 1
a76 1
  Nu_int0,
d109 1
a109 2
ps_open(eventHandler, argc, argv)
int (*eventHandler)();
a120 1
  dmp->dm_eventHandler = eventHandler;
@


1.15
log
@mods to ps_setLineAttr
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-ps.c,v 1.14 1997/05/08 14:21:19 bparker Exp bparker $ (BRL)";
d35 1
a55 1
static unsigned ps_cvtvecs(), ps_load();
a69 2
  ps_cvtvecs,
  ps_load,
d73 4
d78 1
a92 1
  0,
d100 1
d146 1
d225 3
d299 2
d366 1
a366 1
ps_newrot(dmp, mat)
d369 1
d371 1
d386 1
a386 1
ps_drawVList( dmp, vp, mat )
a388 1
mat_t mat;
d418 1
a418 1
	MAT4X3PNT( last, mat, *pt );
d424 1
a424 1
	MAT4X3PNT( fin, mat, *pt );
a567 23
static unsigned
ps_cvtvecs( dmp, sp )
struct dm *dmp;
struct solid *sp;
{
	return( 0 );
}

/*
 * Loads displaylist
 */
static unsigned
ps_load( dmp, addr, count )
struct dm *dmp;
unsigned addr, count;
{
#if 0
	bu_log("ps_load(x%x, %d.)\n", addr, count );
#endif
	return( 0 );
}

/* ARGSUSED */
d582 1
a583 2
  ((struct ps_vars *)dmp->dm_vars)->clipmin[2] = w[5] / 2048.;
  ((struct ps_vars *)dmp->dm_vars)->clipmax[0] = w[0] / 2047.;
d585 8
a592 1
  ((struct ps_vars *)dmp->dm_vars)->clipmax[2] = w[4] / 2047.;
@


1.14
log
@*- changed PS_ prefix to ps_
*- mods to reflect change in "struct dm" --- added dm_type
                                         removed dm_open, dm_initWinProc
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-ps.c,v 1.13 1997/04/24 18:14:07 bparker Exp bparker $ (BRL)";
d83 2
d541 1
a541 1
ps_setLineAttr(dmp, width, dashed)
d544 1
a544 1
int dashed;
d546 4
a549 1
  if( dashed )
@


1.13
log
@some cleanup
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-ps.c,v 1.12 1997/04/23 18:39:25 bparker Exp bparker $ (BRL)";
d46 28
a73 29
struct dm	*PS_open();
static int	PS_close();
static int	PS_drawBegin(), PS_drawEnd();
static int	PS_normal(), PS_newrot();
static int	PS_drawString2D(), PS_drawLine2D();
static int      PS_drawVertex2D();
static int	PS_drawVList();
static int      PS_setColor();
static int      PS_setLineAttr();
static unsigned PS_cvtvecs(), PS_load();
static int	PS_setWinBounds(), PS_debug();

struct dm dm_PS = {
  PS_open,
  PS_close,
  PS_drawBegin,
  PS_drawEnd,
  PS_normal,
  PS_newrot,
  PS_drawString2D,
  PS_drawLine2D,
  PS_drawVertex2D,
  PS_drawVList,
  PS_setColor,
  PS_setLineAttr,
  PS_cvtvecs,
  PS_load,
  PS_setWinBounds,
  PS_debug,
d79 1
a88 1
  0,
d104 1
a104 1
PS_open(eventHandler, argc, argv)
d116 1
a116 1
  *dmp = dm_PS;  /* struct copy */
d119 1
a119 1
  dmp->dm_vars = (genptr_t)bu_calloc(1, sizeof(struct ps_vars), "PS_init: ps_vars");
d121 1
a121 1
    bu_free(dmp, "PS_open: dmp");
d141 4
a144 1
  
d155 1
a155 1
	  (void)PS_close(dmp);
d168 1
a168 1
	  (void)PS_close(dmp);
d181 1
a181 1
	  (void)PS_close(dmp);
d197 1
a197 1
	    (void)PS_close(dmp);
d213 1
a213 1
	  (void)PS_close(dmp);
d221 1
a221 1
      (void)PS_close(dmp);
d229 1
a229 1
    (void)PS_close(dmp);
d240 1
a240 1
    (void)PS_close(dmp);
d299 1
a299 1
PS_close(dmp)
d314 2
a315 2
  bu_free(dmp->dm_vars, "PS_close: ps_vars");
  bu_free(dmp, "PS_close: dmp");
d326 1
a326 1
PS_drawBegin(dmp)
d336 1
a336 1
PS_drawEnd(dmp)
d355 1
a355 1
PS_newrot(dmp, mat)
d373 1
a373 1
PS_drawVList( dmp, vp, mat )
d446 1
a446 1
PS_normal(dmp)
d460 1
a460 1
PS_drawString2D( dmp, str, x, y, size, use_aspect )
d498 1
a498 1
PS_drawLine2D( dmp, x1, y1, x2, y2 )
d522 1
a522 1
PS_drawVertex2D(dmp, x, y)
d526 1
a526 1
  return PS_drawLine2D(dmp, x, y, x, y);
d530 1
a530 1
PS_setColor(dmp, r, g, b, strict)
d539 1
a539 1
PS_setLineAttr(dmp, width, dashed)
d554 1
a554 1
PS_cvtvecs( dmp, sp )
d565 1
a565 1
PS_load( dmp, addr, count )
d570 1
a570 1
	bu_log("PS_load(x%x, %d.)\n", addr, count );
d577 1
a577 1
PS_debug(dmp, lvl)
d584 1
a584 1
PS_setWinBounds(dmp, w)
@


1.12
log
@added some error checking; modified use of BU_GETSTRUCT
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-ps.c,v 1.11 1997/04/22 15:04:52 bparker Exp bparker $ (BRL)";
d120 2
a121 10
#if 0
  /* Only need to do this once for this display manager */
  if(!count){
    bzero((void *)&head_ps_vars, sizeof(struct ps_vars));
    BU_LIST_INIT( &head_ps_vars.l );
  }
#endif

  BU_GETSTRUCT(dmp->dm_vars, ps_vars);
  if(dmp->dm_vars == (struct ps_vars *)NULL){
a125 4
#if 0
  BU_LIST_APPEND(&head_x_vars.l, &((struct x_vars *)dmp->dm_vars)->l);
#endif

a304 5

#if 0
  if(((struct ps_vars *)dmp->dm_vars)->l.forw != BU_LIST_NULL)
    BU_LIST_DEQUEUE(&((struct ps_vars *)dmp->dm_vars)->l);
#endif
@


1.11
log
@*** empty log message ***
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-ps.c,v 1.10 1997/03/03 18:29:27 bparker Exp bparker $ (BRL)";
a42 2
static int PS_load_startup();

d113 5
a117 2
  dmp = BU_GETSTRUCT(dmp, dm);
  *dmp = dm_PS;
d120 1
d122 5
a126 2
  if(!count)
    (void)PS_load_startup(dmp);
d128 2
a129 2
  dmp->dm_vars = bu_calloc(1, sizeof(struct ps_vars), "PS_init: ps_vars");
  if(!dmp->dm_vars){
d134 4
d318 1
d321 1
a609 15

  return TCL_OK;
}

static int
PS_load_startup(dmp)
struct dm *dmp;
{
  char *filename;

  bzero((void *)&head_ps_vars, sizeof(struct ps_vars));
  BU_LIST_INIT( &head_ps_vars.l );

  if((filename = getenv("DM_PS_RCFILE")) != (char *)NULL )
    return Tcl_EvalFile(interp, filename);
@


1.10
log
@mods to have display manager to allocate its own memory
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-ps.c,v 1.9 1997/01/17 23:01:25 bparker Exp bparker $ (BRL)";
a106 1
#if DO_NEW_LIBDM_OPEN
a108 4
#else
PS_open(dmp, argc, argv)
struct dm *dmp;
#endif
a112 1
#if DO_NEW_LIBDM_OPEN
a117 1
#endif
@


1.9
log
@mods to opens use of argv
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-ps.c,v 1.8 1997/01/02 20:07:48 bparker Exp bparker $ (BRL)";
d48 1
a48 1
static int	PS_open();
d85 1
d88 4
d106 5
a110 1
static int
d113 1
d118 7
d130 6
d137 1
d139 1
a140 1
  dmp->dm_vars = bu_calloc(1, sizeof(struct ps_vars), "PS_init: ps_vars");
d163 2
a164 1
	  return TCL_ERROR;
d176 2
a177 1
	  return TCL_ERROR;
d189 2
a190 1
	  return TCL_ERROR;
d205 2
a206 1
	    return TCL_ERROR;
d221 2
a222 1
	  return TCL_ERROR;
d229 2
a230 1
      return TCL_ERROR;
d237 2
a238 1
    return TCL_ERROR;
a242 3
  if(!dmp->dm_vars)
    return TCL_ERROR;

d248 2
a249 1
    return TCL_ERROR;
d298 1
a298 1
  return TCL_OK;
d319 2
d326 1
d471 1
a471 1
PS_drawString2D( dmp, str, x, y, size )
d476 1
@


1.8
log
@changed PS_drawVList's return value
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-ps.c,v 1.7 1996/12/04 21:30:21 bparker Exp bparker $ (BRL)";
d130 2
a131 2
  while(argv[1] != (char *)0 && argv[1][0] == '-'){
    switch(argv[1][1]){
d133 2
a134 2
      if(argv[1][2] != '\0')
	bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars)->font, &argv[1][2]);
d137 1
a137 1
	if(argv[1] == (char *)0 || argv[1][0] == '-'){
d141 1
a141 1
	  bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars)->font, &argv[1][0]);
d145 2
a146 2
      if(argv[1][2] != '\0')
	bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars)->title, &argv[1][2]);
d149 1
a149 1
	if(argv[1] == (char *)0 || argv[1][0] == '-'){
d153 1
a153 1
	  bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars)->title, &argv[1][0]);
d157 2
a158 2
      if(argv[1][2] != '\0')
	bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars)->creator, &argv[1][2]);
d161 1
a161 1
	if(argv[1] == (char *)0 || argv[1][0] == '-'){
d165 1
a165 1
	  bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars)->creator, &argv[1][0]);
d172 2
a173 2
	if(argv[1][2] != '\0')
	  sscanf(&argv[1][2], "%lf", &size);
d176 1
a176 1
	  if(argv[1] == (char *)0 || argv[1][0] == '-'){
d180 1
a180 1
	    sscanf(&argv[1][0], "%lf", &size);
d187 2
a188 2
      if(argv[1][2] != '\0')
	sscanf(&argv[1][2], "%d", &((struct ps_vars *)dmp->dm_vars)->linewidth);
d191 1
a191 1
	if(argv[1] == (char *)0 || argv[1][0] == '-'){
d195 1
a195 1
	  sscanf(&argv[1][0], "%d", &((struct ps_vars *)dmp->dm_vars)->linewidth);
d205 1
a205 1
  if(argv[1] == (char *)0){
d210 1
a210 1
  bu_vls_strcpy(&((struct ps_vars *)dmp->dm_vars)->fname, argv[1]);
@


1.7
log
@changed interface to PS_open
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-ps.c,v 1.6 1996/10/23 20:28:49 bparker Exp bparker $ (BRL)";
d362 1
a362 1
    return(0);
d411 4
a414 1
  return(useful);
@


1.6
log
@.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-ps.c,v 1.5 1996/09/30 19:40:38 bparker Exp bparker $ (BRL)";
a47 1
static int	PS_init();
a60 1
  PS_init,
d86 1
d95 6
d102 1
a102 1
PS_init(dmp, argc, argv)
d113 1
d212 2
a213 5
  if(dmp->dm_vars)
    return TCL_OK;

  return TCL_ERROR;
}
a214 10
/*
 *			P S _ O P E N
 *
 * Open the output file, and output the PostScript prolog.
 *
 */
static int
PS_open(dmp)
struct dm *dmp;
{
@


1.5
log
@more pruning
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-ps.c,v 1.4 1996/09/26 20:37:27 bparker Exp bparker $ (BRL)";
d43 1
a43 1
static void PS_load_startup();
d50 8
a57 7
static void	PS_close();
static void	PS_input();
static void	PS_prolog(), PS_epilog();
static void	PS_normal(), PS_newrot();
static void	PS_update();
static void	PS_puts(), PS_2d_line(), PS_light();
static int	PS_object();
d59 1
a59 2
static void	PS_viewchange(), PS_colorchange();
static void	PS_window(), PS_debug();
d63 17
a79 13
  PS_open, PS_close,
  PS_input,
  PS_prolog, PS_epilog,
  PS_normal, PS_newrot,
  PS_update,
  PS_puts, PS_2d_line,
  PS_light,
  PS_object,
  PS_cvtvecs, PS_load,
  0,
  PS_viewchange,
  PS_colorchange,
  PS_window, PS_debug, 0, 0,
d82 2
a83 1
  "ps", "Screen to PostScript",
d106 1
a106 1
    PS_load_startup(dmp);
d108 1
a108 1
  bu_vls_printf(&dmp->dmr_pathName, ".dm_ps%d", count++);
d110 5
a114 5
  dmp->dmr_vars = bu_calloc(1, sizeof(struct ps_vars), "PS_init: ps_vars");
  bu_vls_init(&((struct ps_vars *)dmp->dmr_vars)->fname);
  bu_vls_init(&((struct ps_vars *)dmp->dmr_vars)->font);
  bu_vls_init(&((struct ps_vars *)dmp->dmr_vars)->title);
  bu_vls_init(&((struct ps_vars *)dmp->dmr_vars)->creator);
d117 5
a121 5
  bu_vls_strcpy(&((struct ps_vars *)dmp->dmr_vars)->font, "Courier");
  bu_vls_strcpy(&((struct ps_vars *)dmp->dmr_vars)->title, "No Title");
  bu_vls_strcpy(&((struct ps_vars *)dmp->dmr_vars)->creator, "LIBDM dm-ps");
  ((struct ps_vars *)dmp->dmr_vars)->scale = 0.0791;
  ((struct ps_vars *)dmp->dmr_vars)->linewidth = 4;
d128 1
a128 1
	bu_vls_strcpy(&((struct ps_vars *)dmp->dmr_vars)->font, &argv[1][2]);
d135 1
a135 1
	  bu_vls_strcpy(&((struct ps_vars *)dmp->dmr_vars)->font, &argv[1][0]);
d140 1
a140 1
	bu_vls_strcpy(&((struct ps_vars *)dmp->dmr_vars)->title, &argv[1][2]);
d147 1
a147 1
	  bu_vls_strcpy(&((struct ps_vars *)dmp->dmr_vars)->title, &argv[1][0]);
d152 1
a152 1
	bu_vls_strcpy(&((struct ps_vars *)dmp->dmr_vars)->creator, &argv[1][2]);
d159 1
a159 1
	  bu_vls_strcpy(&((struct ps_vars *)dmp->dmr_vars)->creator, &argv[1][0]);
d177 1
a177 1
	((struct ps_vars *)dmp->dmr_vars)->scale = size * 0.017578125;
d182 1
a182 1
	sscanf(&argv[1][2], "%d", &((struct ps_vars *)dmp->dmr_vars)->linewidth);
d189 1
a189 1
	  sscanf(&argv[1][0], "%d", &((struct ps_vars *)dmp->dmr_vars)->linewidth);
d204 1
a204 1
  bu_vls_strcpy(&((struct ps_vars *)dmp->dmr_vars)->fname, argv[1]);
d206 1
a206 1
  if(dmp->dmr_vars)
d222 2
a223 2
  if( (((struct ps_vars *)dmp->dmr_vars)->ps_fp =
       fopen(bu_vls_addr(&((struct ps_vars *)dmp->dmr_vars)->fname), "w")) == NULL){
d225 1
a225 1
		     ((struct ps_vars *)dmp->dmr_vars)->fname,
d230 3
a232 3
  setbuf( ((struct ps_vars *)dmp->dmr_vars)->ps_fp,
	  ((struct ps_vars *)dmp->dmr_vars)->ttybuf );
  fprintf(((struct ps_vars *)dmp->dmr_vars)->ps_fp,"%%!PS-Adobe-1.0\n\
d235 1
a235 1
	  bu_vls_addr(&((struct ps_vars *)dmp->dmr_vars)->font));
d237 2
a238 2
  fprintf(((struct ps_vars *)dmp->dmr_vars)->ps_fp, "%%%%Title: %s\n",
	  bu_vls_addr(&((struct ps_vars *)dmp->dmr_vars)->title));
d240 1
a240 1
  fprintf(((struct ps_vars *)dmp->dmr_vars)->ps_fp, "\
d244 1
a244 1
\n", bu_vls_addr(&((struct ps_vars *)dmp->dmr_vars)->creator));
d246 1
a246 1
  fprintf(((struct ps_vars *)dmp->dmr_vars)->ps_fp, "\
d268 7
a274 7
", ((struct ps_vars *)dmp->dmr_vars)->linewidth,
	  bu_vls_addr(&((struct ps_vars *)dmp->dmr_vars)->font),
	  bu_vls_addr(&((struct ps_vars *)dmp->dmr_vars)->font),
	  bu_vls_addr(&((struct ps_vars *)dmp->dmr_vars)->font),
	  bu_vls_addr(&((struct ps_vars *)dmp->dmr_vars)->font),
	  ((struct ps_vars *)dmp->dmr_vars)->scale,
	  ((struct ps_vars *)dmp->dmr_vars)->scale);
d284 1
a284 1
static void
d288 2
a289 2
  if(!((struct ps_vars *)dmp->dmr_vars)->ps_fp)
    return;
d291 2
a292 2
  fputs("%end(plot)\n", ((struct ps_vars *)dmp->dmr_vars)->ps_fp);
  (void)fclose(((struct ps_vars *)dmp->dmr_vars)->ps_fp);
d294 2
a295 2
  if(((struct ps_vars *)dmp->dmr_vars)->l.forw != BU_LIST_NULL)
    BU_LIST_DEQUEUE(&((struct ps_vars *)dmp->dmr_vars)->l);
d297 7
a303 5
  bu_vls_free(&((struct ps_vars *)dmp->dmr_vars)->fname);
  bu_vls_free(&((struct ps_vars *)dmp->dmr_vars)->font);
  bu_vls_free(&((struct ps_vars *)dmp->dmr_vars)->title);
  bu_vls_free(&((struct ps_vars *)dmp->dmr_vars)->creator);
  bu_free(dmp->dmr_vars, "PS_close: ps_vars");
d311 2
a312 2
static void
PS_prolog(dmp)
d315 1
a315 2
  /* Put the center point up */
  PS_2d_line( dmp, 0, 0, 1, 1, 0 );
d321 2
a322 2
static void
PS_epilog(dmp)
d325 2
a326 1
  if( !((struct ps_vars *)dmp->dmr_vars)->ps_fp )  return;
d328 5
a332 3
  fputs("% showpage	% uncomment to use raw file\n", ((struct ps_vars *)dmp->dmr_vars)->ps_fp);
  (void)fflush( ((struct ps_vars *)dmp->dmr_vars)->ps_fp );
  return;
d340 1
a340 1
static void
d345 1
a345 1
	return;
d359 1
a359 1
PS_object( dmp, vp, mat, illum, linestyle, r, g, b, index )
a362 4
int illum;
int linestyle;
register short r, g, b;
short index;
d364 55
a418 50
	static vect_t			last;
	register struct rt_vlist	*tvp;
	int useful = 0;

	if( !((struct ps_vars *)dmp->dmr_vars)->ps_fp )  return(0);

	if( linestyle )
		fprintf(((struct ps_vars *)dmp->dmr_vars)->ps_fp, "DDV ");		/* Dot-dashed vectors */
	else
		fprintf(((struct ps_vars *)dmp->dmr_vars)->ps_fp, "NV ");		/* Normal vectors */

	for( BU_LIST_FOR( tvp, rt_vlist, &vp->l ) )  {
		register int	i;
		register int	nused = tvp->nused;
		register int	*cmd = tvp->cmd;
		register point_t *pt = tvp->pt;
		for( i = 0; i < nused; i++,cmd++,pt++ )  {
			static vect_t	start, fin;
			switch( *cmd )  {
			case RT_VLIST_POLY_START:
			case RT_VLIST_POLY_VERTNORM:
				continue;
			case RT_VLIST_POLY_MOVE:
			case RT_VLIST_LINE_MOVE:
				/* Move, not draw */
				MAT4X3PNT( last, mat, *pt );
				continue;
			case RT_VLIST_POLY_DRAW:
			case RT_VLIST_POLY_END:
			case RT_VLIST_LINE_DRAW:
				/* draw */
				MAT4X3PNT( fin, mat, *pt );
				VMOVE( start, last );
				VMOVE( last, fin );
				break;
			}

			if(
				vclip( start, fin, ((struct ps_vars *)dmp->dmr_vars)->clipmin, ((struct ps_vars *)dmp->dmr_vars)->clipmax ) == 0
			)  continue;

			fprintf(((struct ps_vars *)dmp->dmr_vars)->ps_fp,"newpath %d %d moveto %d %d lineto stroke\n",
				GED_TO_PS( start[0] * 2047 ),
				GED_TO_PS( start[1] * 2047 ),
				GED_TO_PS( fin[0] * 2047 ),
				GED_TO_PS( fin[1] * 2047 ) );
			useful = 1;
		}
	}
	return(useful);
d428 1
a428 1
static void
d432 1
a432 15
	return;
}

/*
 *			P S _ U P D A T E
 *
 * Transmit accumulated displaylist to the display processor.
 */
static void
PS_update(dmp)
struct dm *dmp;
{
	if( !((struct ps_vars *)dmp->dmr_vars)->ps_fp )  return;

	(void)fflush(((struct ps_vars *)dmp->dmr_vars)->ps_fp);
d442 2
a443 2
static void
PS_puts( dmp, str, x, y, size, color )
d446 2
d449 19
a467 1
	if( !((struct ps_vars *)dmp->dmr_vars)->ps_fp )  return;
d469 2
a470 16
	switch( size )  {
	default:
		/* Smallest */
		fprintf(((struct ps_vars *)dmp->dmr_vars)->ps_fp,"DFntS ");
		break;
	case 1:
		fprintf(((struct ps_vars *)dmp->dmr_vars)->ps_fp,"DFntM ");
		break;
	case 2:
		fprintf(((struct ps_vars *)dmp->dmr_vars)->ps_fp,"DFntL ");
		break;
	case 3:
		/* Largest */
		fprintf(((struct ps_vars *)dmp->dmr_vars)->ps_fp,"FntH ");
		break;
	}
d472 1
a472 2
	fprintf(((struct ps_vars *)dmp->dmr_vars)->ps_fp, "(%s) %d %d moveto show\n",
		str, GED_TO_PS(x), GED_TO_PS(y) );
d479 2
a480 2
static void
PS_2d_line( dmp, x1, y1, x2, y2, dashed )
a483 1
int dashed;
d485 9
d495 4
a498 1
	if( !((struct ps_vars *)dmp->dmr_vars)->ps_fp )  return;
d500 1
a500 7
	if( dashed )
		fprintf(((struct ps_vars *)dmp->dmr_vars)->ps_fp, "DDV ");	/* Dot-dashed vectors */
	else
		fprintf(((struct ps_vars *)dmp->dmr_vars)->ps_fp, "NV ");		/* Normal vectors */
	fprintf(((struct ps_vars *)dmp->dmr_vars)->ps_fp,"newpath %d %d moveto %d %d lineto stroke\n",
		GED_TO_PS(x1), GED_TO_PS(y1),
		GED_TO_PS(x2), GED_TO_PS(y2) );
d503 2
a504 13
/*
 *			P S _ I N P U T
 *
 * Execution must suspend in this routine until a significant event
 * has occured on either the command stream,
 * unless "noblock" is set.
 *
 * Implicit Return -
 *	If any files are ready for input, their bits will be set in 'input'.
 *	Otherwise, 'input' will be all zeros.
 */
static void
PS_input( dmp, input, noblock )
d506 1
a506 2
fd_set		*input;
int		noblock;
d508 2
a509 3
	struct timeval	tv;
	int		width;
	int		cnt;
d511 7
a517 27
#if defined(_SC_OPEN_MAX)
	if( (width = sysconf(_SC_OPEN_MAX)) <= 0 )
#endif
		width = 32;

	/*
	 * Check for input on the keyboard only.
	 *
	 * Suspend execution until either
	 *  1)  User types a full line
	 *  2)  The timelimit on SELECT has expired
	 *
	 * If a RATE operation is in progress (zoom, rotate, slew)
	 * in which we still have to update the display,
	 * do not suspend execution.
	 */
	tv.tv_sec = 0;
	if( noblock )  {
		tv.tv_usec = 0;
	}  else  {
		/* 1/20th second */
		tv.tv_usec = 50000;
	}
	cnt = select( width, input, (fd_set *)0,  (fd_set *)0, &tv );
	if( cnt < 0 )  {
		perror("dm/select");
	}
d520 2
a521 6
/* 
 *			P S _ L I G H T
 */
/* ARGSUSED */
static void
PS_light( dmp, cmd, func )
d523 2
a524 2
int cmd;
int func;			/* BE_ or BV_ function */
d526 6
a531 1
	return;
a556 12
static void
PS_viewchange(dmp)
struct dm *dmp;
{
}

static void
PS_colorchange(dmp)
struct dm *dmp;
{
}

d558 1
a558 1
static void
d562 1
d565 2
a566 2
static void
PS_window(dmp, w)
d571 8
a578 6
  ((struct ps_vars *)dmp->dmr_vars)->clipmin[0] = w[1] / 2048.;
  ((struct ps_vars *)dmp->dmr_vars)->clipmin[1] = w[3] / 2048.;
  ((struct ps_vars *)dmp->dmr_vars)->clipmin[2] = w[5] / 2048.;
  ((struct ps_vars *)dmp->dmr_vars)->clipmax[0] = w[0] / 2047.;
  ((struct ps_vars *)dmp->dmr_vars)->clipmax[1] = w[2] / 2047.;
  ((struct ps_vars *)dmp->dmr_vars)->clipmax[2] = w[4] / 2047.;
d581 1
a581 1
static void
d591 3
a593 1
    Tcl_EvalFile(interp, filename);
@


1.4
log
@changed parameters to dmr_object
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-ps.c,v 1.3 1996/09/25 20:27:08 bparker Exp bparker $ (BRL)";
a76 1
  0,				/* no display to release! */
a82 2
  0,
  0,
a592 1
  dmp->dmr_cfunc();
@


1.3
log
@more cleanup
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-ps.c,v 1.2 1996/09/23 17:48:21 bparker Exp bparker $ (BRL)";
a291 6
#if 0
  /* Give the application a chance to clean up */
  if(dmp->dmr_app_close)
    dmp->dmr_app_close(((struct ps_vars *)dmp->dmr_vars)->app_vars);
#endif

d353 1
a353 1
PS_object( dmp, sp, mat, ratio, white )
d355 1
a355 1
register struct solid *sp;
d357 4
a360 2
double ratio;
int white;
d363 1
a363 1
	register struct rt_vlist	*vp;
d368 1
a368 1
	if( sp->s_soldash )
d373 1
a373 1
	for( BU_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
d375 3
a377 3
		register int	nused = vp->nused;
		register int	*cmd = vp->cmd;
		register point_t *pt = vp->pt;
@


1.2
log
@generalized things a bit,
added a few options -- font, title, creator, size, linewidth
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-ps.c,v 1.1 1996/09/17 21:24:56 bparker Exp bparker $ (BRL)";
d39 1
a42 3
/*XXX This is just temporary!!! */
#include "../mged/solid.h"

d83 3
d95 1
a95 1
PS_init(dmp, color_func, argc, argv)
a96 1
void (*color_func)();
d108 1
a108 3
  dmp->dmr_vars = bu_malloc(sizeof(struct ps_vars), "PS_init: ps_vars");
  bzero((void *)dmp->dmr_vars, sizeof(struct ps_vars));
  ((struct ps_vars *)dmp->dmr_vars)->color_func = color_func;
d600 1
a600 1
  ((struct ps_vars *)dmp->dmr_vars)->color_func();
@


1.1
log
@Initial revision
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 11.7 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d37 1
a37 1
#include "_dm.h"
d45 1
a45 1
static int vclip();
d88 2
a89 3
static vect_t	clipmin, clipmax;	/* for vector clipping */
FILE	*ps_fp;			/* PostScript file pointer */
static char	ttybuf[BUFSIZ];
d91 2
a92 5
/*
 * Display coordinate conversion:
 *  GED is using -2048..+2047,
 *  and we define the PLOT file to use 0..4095
 */
d94 1
a94 1
PS_init(dmp, color_func)
d97 2
d100 5
d106 2
d111 94
d222 23
a244 18
	char line[64];

	if( (ps_fp = fopen( dmp->dmr_dname, "w" )) == NULL ){
	  Tcl_AppendResult(interp, "f_ps: Error opening file - ", dmp->dmr_dname,
			   "\n", (char *)NULL);
	  return TCL_ERROR;
	}

	setbuf( ps_fp, ttybuf );
	fputs( "%!PS-Adobe-1.0\n\
%begin(plot)\n\
%%DocumentFonts:  Courier\n", ps_fp );
	fprintf(ps_fp, "%%%%Title: %s\n", line );
	fputs( "\
%%Creator: MGED dm-ps.c\n\
%%BoundingBox: 0 0 324 324	% 4.5in square, for TeX\n\
%%EndComments\n\
\n", ps_fp );
d246 2
a247 2
	fputs( "\
4 setlinewidth\n\
d249 5
a253 5
% Sizes, made functions to avoid scaling if not needed\n\
/FntH /Courier findfont 80 scalefont def\n\
/DFntL { /FntL /Courier findfont 73.4 scalefont def } def\n\
/DFntM { /FntM /Courier findfont 50.2 scalefont def } def\n\
/DFntS { /FntS /Courier findfont 44 scalefont def } def\n\
d255 6
a260 6
% line styles\n\
/NV { [] 0 setdash } def	% normal vectors\n\
/DV { [8] 0 setdash } def	% dotted vectors\n\
/DDV { [8 8 32 8] 0 setdash } def	% dot-dash vectors\n\
/SDV { [32 8] 0 setdash } def	% short-dash vectors\n\
/LDV { [64 8] 0 setdash } def	% long-dash vectors\n\
d263 1
a263 1
	.0791 .0791 scale	% 0-4096 to 324 units (4.5 inches)\n\
d268 7
a274 1
", ps_fp);
d276 1
a276 1
	return(0);			/* OK */
d288 2
a289 1
  if( !ps_fp )  return;
d291 17
a307 3
  fputs("%end(plot)\n", ps_fp);
  (void)fclose(ps_fp);
  ps_fp = (FILE *)NULL;
d330 1
a330 1
  if( !ps_fp )  return;
d332 2
a333 2
  fputs("% showpage	% uncomment to use raw file\n", ps_fp);
  (void)fflush( ps_fp );
d372 1
a372 1
	if( !ps_fp )  return(0);
d375 1
a375 1
		fprintf(ps_fp, "DDV ");		/* Dot-dashed vectors */
d377 1
a377 1
		fprintf(ps_fp, "NV ");		/* Normal vectors */
d406 1
a406 1
				vclip( start, fin, clipmin, clipmax ) == 0
d409 1
a409 1
			fprintf(ps_fp,"newpath %d %d moveto %d %d lineto stroke\n",
d443 1
a443 1
	if( !ps_fp )  return;
d445 1
a445 1
	(void)fflush(ps_fp);
d460 1
a460 1
	if( !ps_fp )  return;
d465 1
a465 1
		fprintf(ps_fp,"DFntS ");
d468 1
a468 1
		fprintf(ps_fp,"DFntM ");
d471 1
a471 1
		fprintf(ps_fp,"DFntL ");
d475 1
a475 1
		fprintf(ps_fp,"FntH ");
d479 1
a479 1
	fprintf(ps_fp, "(%s) %d %d moveto show\n",
d495 1
a495 1
	if( !ps_fp )  return;
d498 1
a498 1
		fprintf(ps_fp, "DDV ");	/* Dot-dashed vectors */
d500 2
a501 2
		fprintf(ps_fp, "NV ");		/* Normal vectors */
	fprintf(ps_fp,"newpath %d %d moveto %d %d lineto stroke\n",
d618 6
a623 6
  clipmin[0] = w[1] / 2048.;
  clipmin[1] = w[3] / 2048.;
  clipmin[2] = w[5] / 2048.;
  clipmax[0] = w[0] / 2047.;
  clipmax[1] = w[2] / 2047.;
  clipmax[2] = w[4] / 2047.;
d626 5
a630 60
/*                      V C L I P
 *
 *  Clip a ray against a rectangular parallelpiped (RPP)
 *  that has faces parallel to the coordinate planes (a clipping RPP).
 *  The RPP is defined by a minimum point and a maximum point.
 *
 *  Returns -
 *	 0  if ray does not hit RPP,
 *	!0  if ray hits RPP.
 *
 *  Implicit Return -
 *	if !0 was returned, "a" and "b" have been clipped to the RPP.
 */
static int
vclip( a, b, min, max )
vect_t a, b;
register fastf_t *min, *max;
{
	static vect_t diff;
	static double sv;
	static double st;
	static double mindist, maxdist;
	register fastf_t *pt = &a[0];
	register fastf_t *dir = &diff[0];
	register int i;

	mindist = -INFINITY;
	maxdist = INFINITY;
	VSUB2( diff, b, a );

	for( i=0; i < 3; i++, pt++, dir++, max++, min++ )  {
		if( *dir < -EPSILON )  {
			if( (sv = (*min - *pt) / *dir) < 0.0 )
				return(0);	/* MISS */
			if(maxdist > sv)
				maxdist = sv;
			if( mindist < (st = (*max - *pt) / *dir) )
				mindist = st;
		}  else if( *dir > EPSILON )  {
			if( (st = (*max - *pt) / *dir) < 0.0 )
				return(0);	/* MISS */
			if(maxdist > st)
				maxdist = st;
			if( mindist < ((sv = (*min - *pt) / *dir)) )
				mindist = sv;
		}  else  {
			/*
			 *  If direction component along this axis is NEAR 0,
			 *  (ie, this ray is aligned with this axis),
			 *  merely check against the boundaries.
			 */
			if( (*min > *pt) || (*max < *pt) )
				return(0);	/* MISS */;
		}
	}
	if( mindist >= maxdist )
		return(0);	/* MISS */

	if( mindist > 1 || maxdist < 0 )
		return(0);	/* MISS */
d632 2
a633 2
	if( mindist <= 0 && maxdist >= 1 )
		return(1);	/* HIT, no clipping needed */
d635 2
a636 10
	/* Don't grow one end of a contained segment */
	if( mindist < 0 )
		mindist = 0;
	if( maxdist > 1 )
		maxdist = 1;

	/* Compute actual intercept points */
	VJOIN1( b, a, maxdist, diff );		/* b must go first */
	VJOIN1( a, a, mindist, diff );
	return(1);		/* HIT */
@
