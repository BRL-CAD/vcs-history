head	1.65;
access;
symbols
	ansi-20040405-merged:1.59.2.3
	postmerge-20040405-ansi:1.62
	premerge-20040404-ansi:1.61
	postmerge-autoconf:1.61
	autoconf-freeze:1.60.2.2
	premerge-autoconf:1.61
	ansi-20040316-freeze:1.59.2.1
	postmerge-20040315-windows:1.61
	premerge-20040315-windows:1.61
	windows-20040315-freeze:1.59.4.1
	autoconf-20031203:1.60
	autoconf-20031202:1.60
	autoconf-branch:1.60.0.2
	phong-branch:1.59.0.8
	photonmap-branch:1.59.0.6
	rel-6-1-DP:1.59
	windows-branch:1.59.0.4
	rel-6-0-2:1.57
	ansi-branch:1.59.0.2
	rel-6-0-1-branch:1.57.0.2
	hartley-6-0-post:1.58
	hartley-6-0-pre:1.57
	rel-6-0-1:1.57
	rel-6-0:1.57
	rel-5-4:1.49.2.2
	offsite-5-3-pre:1.53
	rel-5-3:1.49.2.2
	rel-5-2:1.49.2.1
	rel-5-1-branch:1.49.0.2
	rel-5-1:1.49
	rel-5-0:1.35
	rel-5-0-beta:1.35
	rel-4-5:1.29
	ctj-4-5-post:1.18
	ctj-4-5-pre:1.18;
locks; strict;
comment	@ * @;


1.65
date	2004.05.21.18.06.25;	author morrison;	state dead;
branches;
next	1.64;

1.64
date	2004.05.10.15.30.44;	author erikg;	state Exp;
branches;
next	1.63;

1.63
date	2004.05.10.15.25.26;	author morrison;	state Exp;
branches;
next	1.62;

1.62
date	2004.04.05.07.45.07;	author morrison;	state Exp;
branches;
next	1.61;

1.61
date	2004.02.02.17.39.08;	author morrison;	state Exp;
branches;
next	1.60;

1.60
date	2003.09.25.14.59.26;	author jra;	state Exp;
branches
	1.60.2.1;
next	1.59;

1.59
date	2002.08.20.17.07.44;	author jra;	state Exp;
branches
	1.59.2.1
	1.59.4.1;
next	1.58;

1.58
date	2002.08.15.20.54.57;	author hartley;	state Exp;
branches;
next	1.57;

1.57
date	2001.04.02.21.38.01;	author morrison;	state Exp;
branches;
next	1.56;

1.56
date	2001.04.02.13.04.34;	author jra;	state Exp;
branches;
next	1.55;

1.55
date	2001.03.31.01.56.51;	author morrison;	state Exp;
branches;
next	1.54;

1.54
date	2001.03.19.22.19.50;	author butler;	state Exp;
branches;
next	1.53;

1.53
date	2000.09.12.15.02.56;	author pjt;	state Exp;
branches;
next	1.52;

1.52
date	2000.08.31.18.16.42;	author bparker;	state Exp;
branches;
next	1.51;

1.51
date	2000.08.17.18.15.20;	author bparker;	state Exp;
branches;
next	1.50;

1.50
date	2000.07.12.03.24.43;	author cjohnson;	state Exp;
branches;
next	1.49;

1.49
date	2000.02.18.21.10.10;	author bparker;	state Exp;
branches
	1.49.2.1;
next	1.48;

1.48
date	2000.01.28.15.40.57;	author bparker;	state Exp;
branches;
next	1.47;

1.47
date	2000.01.24.19.09.22;	author butler;	state Exp;
branches;
next	1.46;

1.46
date	2000.01.21.19.09.06;	author bparker;	state Exp;
branches;
next	1.45;

1.45
date	2000.01.20.18.42.42;	author bparker;	state Exp;
branches;
next	1.44;

1.44
date	99.12.30.15.05.52;	author jra;	state Exp;
branches;
next	1.43;

1.43
date	99.12.29.23.43.32;	author bparker;	state Exp;
branches;
next	1.42;

1.42
date	99.12.29.20.47.51;	author jra;	state Exp;
branches;
next	1.41;

1.41
date	99.12.27.21.10.48;	author bparker;	state Exp;
branches;
next	1.40;

1.40
date	99.12.17.16.38.46;	author bparker;	state Exp;
branches;
next	1.39;

1.39
date	99.12.01.13.32.08;	author bparker;	state Exp;
branches;
next	1.38;

1.38
date	99.11.03.14.28.18;	author bparker;	state Exp;
branches;
next	1.37;

1.37
date	99.11.02.14.56.17;	author bparker;	state Exp;
branches;
next	1.36;

1.36
date	99.11.02.14.11.03;	author bparker;	state Exp;
branches;
next	1.35;

1.35
date	98.06.15.18.55.05;	author bparker;	state Exp;
branches;
next	1.34;

1.34
date	98.06.12.19.48.17;	author bparker;	state Exp;
branches;
next	1.33;

1.33
date	98.06.11.14.30.26;	author bparker;	state Exp;
branches;
next	1.32;

1.32
date	98.03.03.14.59.13;	author jra;	state Exp;
branches;
next	1.31;

1.31
date	98.03.02.14.06.19;	author bparker;	state Exp;
branches;
next	1.30;

1.30
date	98.02.26.15.11.18;	author bparker;	state Exp;
branches;
next	1.29;

1.29
date	98.01.05.20.27.38;	author bparker;	state Exp;
branches;
next	1.28;

1.28
date	97.12.16.14.50.47;	author bparker;	state Exp;
branches;
next	1.27;

1.27
date	97.11.21.21.07.18;	author bparker;	state Exp;
branches;
next	1.26;

1.26
date	97.10.10.21.09.53;	author bparker;	state Exp;
branches;
next	1.25;

1.25
date	97.10.10.16.52.35;	author bparker;	state Exp;
branches;
next	1.24;

1.24
date	97.10.10.12.57.31;	author bparker;	state Exp;
branches;
next	1.23;

1.23
date	97.10.09.14.08.45;	author bparker;	state Exp;
branches;
next	1.22;

1.22
date	97.10.09.14.06.11;	author bparker;	state Exp;
branches;
next	1.21;

1.21
date	97.09.23.21.17.14;	author bparker;	state Exp;
branches;
next	1.20;

1.20
date	97.08.20.20.33.19;	author bparker;	state Exp;
branches;
next	1.19;

1.19
date	97.08.01.21.33.03;	author bparker;	state Exp;
branches;
next	1.18;

1.18
date	97.05.21.13.03.30;	author bparker;	state Exp;
branches;
next	1.17;

1.17
date	97.05.08.14.19.03;	author bparker;	state Exp;
branches;
next	1.16;

1.16
date	97.04.24.18.14.07;	author bparker;	state Exp;
branches;
next	1.15;

1.15
date	97.04.23.18.35.31;	author bparker;	state Exp;
branches;
next	1.14;

1.14
date	97.04.22.15.05.48;	author bparker;	state Exp;
branches;
next	1.13;

1.13
date	97.03.26.18.40.21;	author jra;	state Exp;
branches;
next	1.12;

1.12
date	97.03.03.19.59.39;	author bparker;	state Exp;
branches;
next	1.11;

1.11
date	97.03.03.18.32.11;	author bparker;	state Exp;
branches;
next	1.10;

1.10
date	97.01.24.21.06.44;	author bparker;	state Exp;
branches;
next	1.9;

1.9
date	97.01.02.20.05.10;	author bparker;	state Exp;
branches;
next	1.8;

1.8
date	96.12.04.21.25.52;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	96.10.24.22.13.14;	author bparker;	state Exp;
branches;
next	1.6;

1.6
date	96.10.23.20.28.49;	author bparker;	state Exp;
branches;
next	1.5;

1.5
date	96.09.30.19.40.38;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	96.09.26.20.37.27;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	96.09.25.20.28.29;	author bparker;	state Exp;
branches;
next	1.2;

1.2
date	96.09.23.17.47.18;	author bparker;	state Exp;
branches;
next	1.1;

1.1
date	96.09.17.21.24.18;	author bparker;	state Exp;
branches;
next	;

1.49.2.1
date	2000.09.01.17.24.42;	author bparker;	state Exp;
branches;
next	1.49.2.2;

1.49.2.2
date	2001.03.01.19.21.15;	author butler;	state Exp;
branches;
next	;

1.59.2.1
date	2002.09.19.18.01.17;	author morrison;	state Exp;
branches;
next	1.59.2.2;

1.59.2.2
date	2004.03.17.21.16.57;	author morrison;	state Exp;
branches;
next	1.59.2.3;

1.59.2.3
date	2004.04.02.16.03.40;	author morrison;	state Exp;
branches;
next	;

1.59.4.1
date	2004.03.11.23.42.00;	author morrison;	state Exp;
branches;
next	;

1.60.2.1
date	2004.02.12.19.45.18;	author erikg;	state Exp;
branches;
next	1.60.2.2;

1.60.2.2
date	2004.03.15.14.06.18;	author erikg;	state Exp;
branches;
next	;


desc
@X Display Manager
@


1.65
log
@moved to src/
@
text
@/*
 *			D M - X . C
 *
 *  An X Window System Display Manager.
 *
 *  Author -
 *	Phillip Dykstra
 *	Robert G. Parker
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1988-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libdm/dm-X.c,v 1.64 2004/05/10 15:30:44 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <stdio.h>
#include <limits.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "tk.h"
#include <X11/Xutil.h>

#define USE_DIALS_AND_BUTTONS 1

#ifdef HAVE_XOSDEFS_H
#include <X11/Xfuncproto.h>
#include <X11/Xosdefs.h>
#endif
#if USE_DIALS_AND_BUTTONS
#include <X11/extensions/XInput.h>
#endif
#if defined(linux)
#	undef   X_NOT_STDC_ENV
#	undef   X_NOT_POSIX
#endif
#define XLIB_ILLEGAL_ACCESS	/* necessary on facist SGI 5.0.1 */

#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "dm.h"
#include "dm-X.h"
#include "dm_xvars.h"
#include "solid.h"


HIDDEN void	label();
HIDDEN void	draw();
HIDDEN void     x_var_init();
HIDDEN XVisualInfo *X_choose_visual(struct dm *dmp);

/* Display Manager package interface */

#define PLOTBOUND	1000.0	/* Max magnification in Rot matrix */
struct dm	*X_open(Tcl_Interp *interp, int argc, char **argv);
HIDDEN int	X_close(struct dm *dmp);
HIDDEN int	X_drawBegin(struct dm *dmp), X_drawEnd(struct dm *dmp);
HIDDEN int	X_normal(struct dm *dmp), X_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye);
HIDDEN int      X_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect);
HIDDEN int	X_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2);
HIDDEN int      X_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y);
HIDDEN int	X_drawVList(struct dm *dmp, register struct bn_vlist *vp);
HIDDEN int      X_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict, fastf_t transparency);
HIDDEN int	X_setBGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b);
HIDDEN int	X_setLineAttr(struct dm *dmp, int width, int style);
HIDDEN int	X_configureWin_guts(struct dm *dmp, int force);
HIDDEN int	X_configureWin(struct dm *dmp);
HIDDEN int	X_setLight(struct dm *dmp, int light_on);
HIDDEN int	X_setZBuffer(struct dm *dmp, int zbuffer_on);
HIDDEN int	X_setWinBounds(struct dm *dmp, register int *w), X_debug(struct dm *dmp, int lvl);

struct dm dm_X = {
  X_close,
  X_drawBegin,
  X_drawEnd,
  X_normal,
  X_loadMatrix,
  X_drawString2D,
  X_drawLine2D,
  X_drawPoint2D,
  X_drawVList,
  X_setFGColor,
  X_setBGColor,
  X_setLineAttr,
  X_configureWin,
  X_setWinBounds,
  X_setLight,
  Nu_int0,
  Nu_int0,
  X_setZBuffer,
  X_debug,
  Nu_int0,
  Nu_int0,
  Nu_int0,
  Nu_int0,
  0,
  0,				/* no displaylist */
  0,                            /* no stereo */
  PLOTBOUND,			/* zoom-in limit */
  1,				/* bound flag */
  "X",
  "X Window System (X11)",
  DM_TYPE_X,
  1,
  0,
  0,
  0,
  0,
  1.0, /* aspect ratio */
  0,
  {0, 0},
  {0, 0, 0, 0, 0},		/* bu_vls path name*/
  {0, 0, 0, 0, 0},		/* bu_vls full name drawing window */
  {0, 0, 0, 0, 0},		/* bu_vls short name drawing window */
  {0, 0, 0},			/* bg color */
  {0, 0, 0},			/* fg color */
  {GED_MIN, GED_MIN, GED_MIN},	/* clipmin */
  {GED_MAX, GED_MAX, GED_MAX},	/* clipmax */
  0,				/* no debugging */
  0,				/* no perspective */
  0,				/* no lighting */
  0,				/* no transparency */
  0,				/* no zbuffer */
  0,				/* no zclipping */
  1,                            /* clear back buffer after drawing and swap */
  0				/* Tcl interpreter */
};

fastf_t min_short = (fastf_t)SHRT_MIN;
fastf_t max_short = (fastf_t)SHRT_MAX;

extern int vectorThreshold;	/* defined in libdm/tcl.c */ 

static void 
get_color(Display *dpy, Colormap cmap, XColor *color)
{
	Status st;
	XColor rgb;
#define CSCK   0xf800

	rgb = *color;

	st = XAllocColor(dpy, cmap, color);
	switch (st) {
	case 1: 
#if 0
		if ( (color->red & CSCK) != (rgb.red & CSCK) ||
		     (color->green & CSCK) != (rgb.green & CSCK) ||
		     (color->blue & CSCK) != (rgb.blue & CSCK) ) {
			bu_log("\nlooking for fg    (%3d,%3d,%3d) %04x,%04x,%04x got \n                  (%3d,%3d,%3d) %04x,%04x,%04x\n",
			       (rgb.red >> 8), (rgb.green >> 8), (rgb.blue >> 8),
			       rgb.red, rgb.green, rgb.blue,

			       (color->red >> 8), (color->green >> 8), (color->blue >> 8),
			       color->red, color->green, color->blue);
		}
#endif
		break;
	case BadColor:
		bu_log("XAllocColor failed (BadColor) for (%3d,%3d,%3d) %04x,%04x,%04x\n", 
		       (rgb.red >> 8), (rgb.green >> 8), (rgb.blue >> 8),
		       rgb.red, rgb.green, rgb.blue);
		break;

	default:
		bu_log("XAllocColor error for (%3d,%3d,%3d) %04x,%04x,%04x\n", 
		       (rgb.red >> 8), (rgb.green >> 8), (rgb.blue >> 8),
		       rgb.red, rgb.green, rgb.blue);
		break;
	}
#undef CSCK

}

/*
 *			X _ O P E N
 *
 * Fire up the display manager, and the display processor.
 *
 */
struct dm *
X_open(Tcl_Interp *interp, int argc, char **argv)
{
  static int count = 0;
  int make_square = -1;
  XGCValues gcv;
#if USE_DIALS_AND_BUTTONS
  int j, k;
  int ndevices;
  int nclass = 0;
  XDeviceInfoPtr olist, list;
  XDevice *dev;
  XEventClass e_class[15];
  XInputClassInfo *cip;
#endif
  struct bu_vls str;
  struct bu_vls init_proc_vls;
  struct dm *dmp;
  Tk_Window tkwin;

  if ((tkwin = Tk_MainWindow(interp)) == NULL) {
	  return DM_NULL;
  }

  BU_GETSTRUCT(dmp, dm);
  if(dmp == DM_NULL)
    return DM_NULL;

  *dmp = dm_X; /* struct copy */
  dmp->dm_interp = interp;

  dmp->dm_vars.pub_vars = (genptr_t)bu_calloc(1, sizeof(struct dm_xvars), "X_open: dm_xvars");
  if(dmp->dm_vars.pub_vars == (genptr_t)NULL){
    bu_free(dmp, "X_open: dmp");
    return DM_NULL;
  }

  dmp->dm_vars.priv_vars = (genptr_t)bu_calloc(1, sizeof(struct x_vars), "X_open: x_vars");
  if(dmp->dm_vars.priv_vars == (genptr_t)NULL){
    bu_free(dmp->dm_vars.pub_vars, "X_open: dmp->dm_vars.pub_vars");
    bu_free(dmp, "X_open: dmp");
    return DM_NULL;
  }

  bu_vls_init(&dmp->dm_pathName);
  bu_vls_init(&dmp->dm_tkName);
  bu_vls_init(&dmp->dm_dName);
  bu_vls_init(&init_proc_vls);

  dm_processOptions(dmp, &init_proc_vls, --argc, ++argv);

  if(bu_vls_strlen(&dmp->dm_pathName) == 0)
    bu_vls_printf(&dmp->dm_pathName, ".dm_X%d", count);

  ++count;
  if(bu_vls_strlen(&dmp->dm_dName) == 0){
    char *dp;

    dp = getenv("DISPLAY");
    if(dp)
      bu_vls_strcpy(&dmp->dm_dName, dp);
    else
      bu_vls_strcpy(&dmp->dm_dName, ":0.0");
  }
  if(bu_vls_strlen(&init_proc_vls) == 0)
    bu_vls_strcpy(&init_proc_vls, "bind_dm");

  /* initialize dm specific variables */
  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devmotionnotify = LASTEvent;
  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devbuttonpress = LASTEvent;
  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devbuttonrelease = LASTEvent;
  dmp->dm_aspect = 1.0;

  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct = NULL;

  if(dmp->dm_top){
    /* Make xtkwin a toplevel window */
    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin = Tk_CreateWindowFromPath(interp, tkwin,
						      bu_vls_addr(&dmp->dm_pathName),
						      bu_vls_addr(&dmp->dm_dName));
    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->top = ((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin;
  }else{
    char *cp;

    cp = strrchr(bu_vls_addr(&dmp->dm_pathName), (int)'.');
    if(cp == bu_vls_addr(&dmp->dm_pathName)){
      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->top = tkwin;
    }else{
      struct bu_vls top_vls;

      bu_vls_init(&top_vls);
      bu_vls_printf(&top_vls, "%*s", cp - bu_vls_addr(&dmp->dm_pathName),
		    bu_vls_addr(&dmp->dm_pathName));
      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->top =
	Tk_NameToWindow(interp, bu_vls_addr(&top_vls), tkwin);
      bu_vls_free(&top_vls);
    }

    /* Make xtkwin an embedded window */
    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin =
      Tk_CreateWindow(interp, ((struct dm_xvars *)dmp->dm_vars.pub_vars)->top,
		      cp + 1, (char *)NULL);
  }

  if(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin == NULL){
    bu_log("X_open: Failed to open %s\n", bu_vls_addr(&dmp->dm_pathName));
    (void)X_close(dmp);
    return DM_NULL;
  }

  bu_vls_printf(&dmp->dm_tkName, "%s",
		(char *)Tk_Name(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin));

  bu_vls_init(&str);
  bu_vls_printf(&str, "_init_dm %S %S\n",
		&init_proc_vls,
		&dmp->dm_pathName);

  if(Tcl_Eval(interp, bu_vls_addr(&str)) == TCL_ERROR){
    bu_vls_free(&str);
    (void)X_close(dmp);

    return DM_NULL;
  }

  bu_vls_free(&init_proc_vls);
  bu_vls_free(&str);

  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy =
    Tk_Display(((struct dm_xvars *)dmp->dm_vars.pub_vars)->top);

  if(dmp->dm_width == 0){
    dmp->dm_width =
      DisplayWidth(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		   DefaultScreen(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy)) - 30;
    ++make_square;
  }

  if(dmp->dm_height == 0){
    dmp->dm_height =
      DisplayHeight(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		    DefaultScreen(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy)) - 30;
    ++make_square;
  }

  if(make_square > 0){
    /* Make window square */
    if(dmp->dm_height <
       dmp->dm_width)
      dmp->dm_width = dmp->dm_height;
    else
      dmp->dm_height = dmp->dm_width;
  }

  Tk_GeometryRequest(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin,
		     dmp->dm_width, 
		     dmp->dm_height);

#if 0
  /*XXX For debugging purposes */
  XSynchronize(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy, 1);
#endif

  /* must do this before MakeExist */
  if((((struct dm_xvars *)dmp->dm_vars.pub_vars)->vip = X_choose_visual(dmp)) == NULL){
    bu_log("X_open: Can't get an appropriate visual.\n");
    (void)X_close(dmp);
    return DM_NULL;
  }

  Tk_MakeWindowExist(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin);
  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win =
      Tk_WindowId(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin);
  dmp->dm_id = ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win;

  ((struct x_vars *)dmp->dm_vars.priv_vars)->pix =
    Tk_GetPixmap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		 DefaultRootWindow(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy),
		 dmp->dm_width,
		 dmp->dm_height,
		 Tk_Depth(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin));

  if(((struct x_vars *)dmp->dm_vars.priv_vars)->is_trueColor){
    XColor fg, bg;

    fg.red = 65535;
    fg.green = fg.blue = 0;

    get_color(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap,
	      &fg);

    ((struct x_vars *)dmp->dm_vars.priv_vars)->fg = fg.pixel;

    bg.red = bg.green = bg.blue = 0;
    get_color(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap,
		&bg);

    ((struct x_vars *)dmp->dm_vars.priv_vars)->bg = bg.pixel;
  }else{
    dm_allocate_color_cube( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap,
			    ((struct x_vars *)dmp->dm_vars.priv_vars)->pixels,
			    /* cube dimension, uses XStoreColor */
			    6, CMAP_BASE, 1 );

    ((struct x_vars *)dmp->dm_vars.priv_vars)->bg =
      dm_get_pixel(DM_BLACK,
		   ((struct x_vars *)dmp->dm_vars.priv_vars)->pixels,
		   CUBE_DIMENSION);
    ((struct x_vars *)dmp->dm_vars.priv_vars)->fg =
      dm_get_pixel(DM_RED,
		   ((struct x_vars *)dmp->dm_vars.priv_vars)->pixels,
		   CUBE_DIMENSION);
  }  

  gcv.background = ((struct x_vars *)dmp->dm_vars.priv_vars)->bg;
  gcv.foreground = ((struct x_vars *)dmp->dm_vars.priv_vars)->fg;
  ((struct x_vars *)dmp->dm_vars.priv_vars)->gc = XCreateGC(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
						  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win,
						  (GCForeground|GCBackground), &gcv);

  /* First see if the server supports XInputExtension */
  {
    int return_val;

    if(!XQueryExtension(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		     "XInputExtension", &return_val, &return_val, &return_val))
      goto Skip_dials;
  }

#if USE_DIALS_AND_BUTTONS
  /*
   * Take a look at the available input devices. We're looking
   * for "dial+buttons".
   */
  olist = list =
    (XDeviceInfoPtr)XListInputDevices(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
				      &ndevices);

  if( list == (XDeviceInfoPtr)NULL ||
      list == (XDeviceInfoPtr)1 )  goto Done;

  for(j = 0; j < ndevices; ++j, list++){
    if(list->use == IsXExtensionDevice){
      if(!strcmp(list->name, "dial+buttons")){
	if((dev = XOpenDevice(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			      list->id)) == (XDevice *)NULL){
	  bu_log("X_open: Couldn't open the dials+buttons\n");
	  goto Done;
	}

	for(cip = dev->classes, k = 0; k < dev->num_classes;
	    ++k, ++cip){
	  switch(cip->input_class){
#if IR_BUTTONS
	  case ButtonClass:
	    DeviceButtonPress(dev, ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devbuttonpress,
			      e_class[nclass]);
	    ++nclass;
	    DeviceButtonRelease(dev, ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devbuttonrelease,
				e_class[nclass]);
	    ++nclass;
	    break;
#endif
#if IR_KNOBS
	  case ValuatorClass:
	    DeviceMotionNotify(dev, ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devmotionnotify,
			       e_class[nclass]);
	    ++nclass;
	    break;
#endif
	  default:
	    break;
	  }
	}

	XSelectExtensionEvent(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win, e_class, nclass);
	goto Done;
      }
    }
  }
Done:
  XFreeDeviceList(olist);
#endif

Skip_dials:
#ifndef CRAY2
  (void)X_configureWin_guts(dmp, 1);
#endif

  Tk_SetWindowBackground(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin,
			 ((struct x_vars *)dmp->dm_vars.priv_vars)->bg);
  Tk_MapWindow(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin);

  MAT_IDN(((struct x_vars *)dmp->dm_vars.priv_vars)->xmat);

  return dmp;
}

/*
 *  			X _ C L O S E
 *  
 *  Gracefully release the display.
 */
HIDDEN int
X_close(struct dm *dmp)
{
  if(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy){
    if(((struct x_vars *)dmp->dm_vars.priv_vars)->gc)
      XFreeGC(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	      ((struct x_vars *)dmp->dm_vars.priv_vars)->gc);

    if(((struct x_vars *)dmp->dm_vars.priv_vars)->pix)
      Tk_FreePixmap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		    ((struct x_vars *)dmp->dm_vars.priv_vars)->pix);

    /*XXX Possibly need to free the colormap */
    if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap)
      XFreeColormap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap);

    if(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin)
      Tk_DestroyWindow(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin);

#if 0
    XCloseDisplay(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy);
#endif
  }

  bu_vls_free(&dmp->dm_pathName);
  bu_vls_free(&dmp->dm_tkName);
  bu_vls_free(&dmp->dm_dName);
  bu_free(dmp->dm_vars.priv_vars, "X_close: x_vars");
  bu_free(dmp->dm_vars.pub_vars, "X_close: dm_xvars");
  bu_free(dmp, "X_close: dmp");

  return TCL_OK;
}

/*
 *			X _ D R A W B E G I N
 */
HIDDEN int
X_drawBegin(struct dm *dmp)
{
  XGCValues       gcv;

  if (dmp->dm_debugLevel)
    bu_log("X_drawBegin()\n");

  /* clear pixmap */
  gcv.foreground = ((struct x_vars *)dmp->dm_vars.priv_vars)->bg;
  XChangeGC(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	    ((struct x_vars *)dmp->dm_vars.priv_vars)->gc,
	    GCForeground, &gcv);
  XFillRectangle(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		 ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
		 ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, 0,
		 0, dmp->dm_width + 1,
		 dmp->dm_height + 1);

  /* reset foreground */
  gcv.foreground = ((struct x_vars *)dmp->dm_vars.priv_vars)->fg;
  XChangeGC(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	    ((struct x_vars *)dmp->dm_vars.priv_vars)->gc,
	    GCForeground, &gcv);

  return TCL_OK;
}

/*
 *			X _ E P I L O G
 */
HIDDEN int
X_drawEnd(struct dm *dmp)
{
  if (dmp->dm_debugLevel)
    bu_log("X_drawEnd()\n");

  XCopyArea(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	    ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
	    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win,
	    ((struct x_vars *)dmp->dm_vars.priv_vars)->gc,
	      0, 0, dmp->dm_width,
 	    dmp->dm_height, 0, 0);

  /* Prevent lag between events and updates */
  XSync(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy, 0);

  return TCL_OK;
}

/*
 *  			X _ L O A D M A T R I X
 *
 *  Load a new transformation matrix.  This will be followed by
 *  many calls to X_drawVList().
 */
/* ARGSUSED */
HIDDEN int
X_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye)
{
  if(dmp->dm_debugLevel){
    bu_log("X_loadMatrix()\n");

    bu_log("which eye = %d\t", which_eye);
    bu_log("transformation matrix = \n");
#if 1
    bu_log("%g %g %g %g\n", mat[0], mat[1], mat[2], mat[3]);
    bu_log("%g %g %g %g\n", mat[4], mat[5], mat[6], mat[7]);
    bu_log("%g %g %g %g\n", mat[8], mat[9], mat[10], mat[11]);
    bu_log("%g %g %g %g\n", mat[12], mat[13], mat[14], mat[15]);
#else
    bu_log("%g %g %g %g\n", mat[0], mat[4], mat[8], mat[12]);
    bu_log("%g %g %g %g\n", mat[1], mat[5], mat[9], mat[13]);
    bu_log("%g %g %g %g\n", mat[2], mat[6], mat[10], mat[14]);
    bu_log("%g %g %g %g\n", mat[3], mat[7], mat[11], mat[15]);
#endif
  }

  MAT_COPY(((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, mat);
  return TCL_OK;
}

/*
 *  			X _ D R A W V L I S T
 *  
 */

HIDDEN int
X_drawVList(struct dm *dmp, register struct bn_vlist *vp)
{
	static vect_t			spnt, lpnt, pnt;
	register struct rt_vlist	*tvp;
	XSegment			segbuf[1024];		/* XDrawSegments list */
	XSegment			*segp;			/* current segment */
	int				nseg;		        /* number of segments */
	fastf_t				delta;
	register point_t		*pt_prev = NULL;
	fastf_t				dist_prev=1.0;
	static int			nvectors = 0;

	if (dmp->dm_debugLevel) {
		bu_log("X_drawVList()\n");
		bu_log("vp - %lu, perspective - %d\n", vp, dmp->dm_perspective);
	}

	/* delta is used in clipping to insure clipped endpoint is slightly
	 * in front of eye plane (perspective mode only).
	 * This value is a SWAG that seems to work OK.
	 */
	delta = ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat[15]*0.0001;
	if (delta < 0.0)
		delta = -delta;
	if (delta < SQRT_SMALL_FASTF)
		delta = SQRT_SMALL_FASTF;

	nseg = 0;
	segp = segbuf;
	for (BU_LIST_FOR(tvp, rt_vlist, &vp->l)) {
		register int	i;
		register int	nused = tvp->nused;
		register int	*cmd = tvp->cmd;
		register point_t *pt = tvp->pt;
		fastf_t 	 dist;

		/* Viewing region is from -1.0 to +1.0 */
		/* 2^31 ~= 2e9 -- dynamic range of a long int */
		/* 2^(31-11) = 2^20 ~= 1e6 */
		/* Integerize and let the X server do the clipping */
		for (i = 0; i < nused; i++,cmd++,pt++) {
			switch (*cmd) {
			case RT_VLIST_POLY_START:

			case RT_VLIST_POLY_VERTNORM:
				continue;
			case RT_VLIST_POLY_MOVE:
			case RT_VLIST_LINE_MOVE:
				/* Move, not draw */
				if (dmp->dm_debugLevel > 2) {
					bu_log("before transformation:\n");
					bu_log("pt - %lf %lf %lf\n", V3ARGS(*pt));
				}

				if (dmp->dm_perspective > 0) {
					/* cannot apply perspective transformation to
					 * points behind eye plane!!!!
					 */
					dist = VDOT(*pt, &((struct x_vars *)dmp->dm_vars.priv_vars)->xmat[12]) + ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat[15];
					if (dist <= 0.0) {
						pt_prev = pt;
						dist_prev = dist;
						continue;
					} else {
						MAT4X3PNT(lpnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, *pt);
						dist_prev = dist;
						pt_prev = pt;
					}
				} else {
					MAT4X3PNT(lpnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, *pt);
				}

				lpnt[0] *= 2047;
				lpnt[1] *= 2047 * dmp->dm_aspect;
				lpnt[2] *= 2047;
				continue;
			case RT_VLIST_POLY_DRAW:
			case RT_VLIST_POLY_END:
			case RT_VLIST_LINE_DRAW:
				/* draw */
				if (dmp->dm_debugLevel > 2) {
					bu_log("before transformation:\n");
					bu_log("pt - %lf %lf %lf\n", V3ARGS(*pt));
				}

				if (dmp->dm_perspective > 0) {
					/* cannot apply perspective transformation to
					 * points behind eye plane!!!!
					 */
					dist = VDOT( *pt, &((struct x_vars *)dmp->dm_vars.priv_vars)->xmat[12] ) + ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat[15];
					if (dmp->dm_debugLevel > 2)
						bu_log( "dist=%g, dist_prev=%g\n", dist, dist_prev );
					if (dist <= 0.0) {
						if (dist_prev <= 0.0) {
							/* nothing to plot */
							dist_prev = dist;
							pt_prev = pt;
							continue;
						} else {
							fastf_t alpha;
							vect_t diff;
							point_t tmp_pt;

							/* clip this end */
							VSUB2(diff, *pt, *pt_prev);
							alpha = (dist_prev - delta) / (dist_prev - dist);
							VJOIN1(tmp_pt, *pt_prev, alpha, diff);
							MAT4X3PNT(pnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, tmp_pt);
						}
					} else {
						if (dist_prev <= 0.0) {
							fastf_t alpha;
							vect_t diff;
							point_t tmp_pt;

							/* clip other end */
							VSUB2(diff, *pt, *pt_prev);
							alpha = (-dist_prev + delta) / (dist - dist_prev);
							VJOIN1(tmp_pt, *pt_prev, alpha, diff);
							MAT4X3PNT(lpnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, tmp_pt);
							lpnt[0] *= 2047;
							lpnt[1] *= 2047 * dmp->dm_aspect;
							lpnt[2] *= 2047;
							MAT4X3PNT(pnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, *pt);
						} else {
							MAT4X3PNT(pnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, *pt);
						}
					}
					dist_prev = dist;
				} else {
					MAT4X3PNT(pnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, *pt);
				}

				pnt[0] *= 2047;
				pnt[1] *= 2047 * dmp->dm_aspect;
				pnt[2] *= 2047;

				/* save pnt --- it might get changed by clip() */
				VMOVE(spnt, pnt);
				pt_prev = pt;

				if (dmp->dm_debugLevel > 2) {
					bu_log("before clipping:\n");
					bu_log("clipmin - %lf %lf %lf\n",
					       dmp->dm_clipmin[X],
					       dmp->dm_clipmin[Y],
					       dmp->dm_clipmin[Z]);
					bu_log("clipmax - %lf %lf %lf\n",
					       dmp->dm_clipmax[X],
					       dmp->dm_clipmax[Y],
					       dmp->dm_clipmax[Z]);
					bu_log("pt1 - %lf %lf %lf\n", lpnt[X], lpnt[Y], lpnt[Z]);
					bu_log("pt2 - %lf %lf %lf\n", pnt[X], pnt[Y], pnt[Z]);
				}

				if (dmp->dm_zclip) {
					if (vclip(lpnt, pnt,
						  dmp->dm_clipmin,
						  dmp->dm_clipmax) == 0) {
						VMOVE(lpnt, spnt);
						continue;
					}
				} else {
					/* Check to see if lpnt or pnt contain values that exceed
					   the capacity of a short (segbuf is an array of XSegments which
					   contain shorts). If so, do clipping now. Otherwise, let the
					   X server do the clipping */
					if (lpnt[0] < min_short || max_short < lpnt[0] ||
					    lpnt[1] < min_short || max_short < lpnt[1] ||
					    pnt[0] < min_short || max_short < pnt[0] ||
					    pnt[1] < min_short || max_short < pnt[1]) {
						/* if the entire line segment will not be visible then ignore it */
						if (clip(&lpnt[0], &lpnt[1], &pnt[0], &pnt[1]) == -1) {
							VMOVE(lpnt, spnt);
							continue;
						}
					}
				}

				if (dmp->dm_debugLevel > 2) {
					bu_log("after clipping:\n");
					bu_log("pt1 - %lf %lf %lf\n", lpnt[X], lpnt[Y], lpnt[Z]);
					bu_log("pt2 - %lf %lf %lf\n", pnt[X], pnt[Y], pnt[Z]);
				}

				/* convert to X window coordinates */
				segp->x1 = (short)GED_TO_Xx(dmp, lpnt[0]);
				segp->y1 = (short)GED_TO_Xy(dmp, lpnt[1]);
				segp->x2 = (short)GED_TO_Xx(dmp, pnt[0]);
				segp->y2 = (short)GED_TO_Xy(dmp, pnt[1]);

				nseg++;
				segp++;
				VMOVE(lpnt, spnt);

				if (nseg == 1024) {
					XDrawSegments(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
						      ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
						      ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, segbuf, nseg);

					nseg = 0;
					segp = segbuf;
				}
				break;
			}
		}

		nvectors += nused;
		if (nvectors >= vectorThreshold) {
			if (dmp->dm_debugLevel)
				bu_log("X_drawVList(): handle Tcl events\n");

			nvectors = 0;

			/* Handle events in the queue */
			while (Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT));
		}
	}

	if (nseg) {
		XDrawSegments( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			       ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
			       ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, segbuf, nseg );
	}

	return TCL_OK;
}

/*
 *			X _ N O R M A L
 *
 * Restore the display processor to a normal mode of operation
 * (ie, not scaled, rotated, displaced, etc).
 */
HIDDEN int
X_normal(struct dm *dmp)
{
  if (dmp->dm_debugLevel)
    bu_log("X_normal()\n");

  return TCL_OK;
}

/*
 *			X _ D R A W S T R I N G 2 D
 *
 * Output a string into the displaylist.
 * The starting position of the beam is as specified.
 */
/* ARGSUSED */
HIDDEN int
X_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect)
{
  int sx, sy;

  if (dmp->dm_debugLevel){
    bu_log("X_drawString2D():\n");
    bu_log("\tstr - %s\n", str);
    bu_log("\tx - %g\n", x);
    bu_log("\ty - %g\n", y);
    bu_log("\tsize - %d\n", size);
    if(use_aspect){
      bu_log("\tuse_aspect - %d\t\taspect ratio - %g\n", use_aspect, dmp->dm_aspect);
    }else
      bu_log("\tuse_aspect - 0");
  }

  sx = dm_Normal2Xx(dmp, x);
  sy = dm_Normal2Xy(dmp, y, use_aspect);

  XDrawString( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	       ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
	       ((struct x_vars *)dmp->dm_vars.priv_vars)->gc,
	       sx, sy, str, strlen(str) );

  return TCL_OK;
}

HIDDEN int
X_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2)
{
  int	sx1, sy1, sx2, sy2;

  sx1 = dm_Normal2Xx(dmp, x1);
  sx2 = dm_Normal2Xx(dmp, x2);
  sy1 = dm_Normal2Xy(dmp, y1, 0);
  sy2 = dm_Normal2Xy(dmp, y2, 0);

  if (dmp->dm_debugLevel) {
    bu_log("X_drawLine2D()\n");
    bu_log("x1 = %g, y1 = %g\n", x1, y1);
    bu_log("x2 = %g, y2 = %g\n", x2, y2);
    bu_log("sx1 = %d, sy1 = %d\n", sx1, sy1);
    bu_log("sx2 = %d, sy2 = %d\n", sx2, sy2);
  }

  XDrawLine( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	     ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
	     ((struct x_vars *)dmp->dm_vars.priv_vars)->gc,
	     sx1, sy1, sx2, sy2 );

  return TCL_OK;
}

HIDDEN int
X_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y)
{
  int   sx, sy;

  sx = dm_Normal2Xx(dmp, x);
  sy = dm_Normal2Xy(dmp, y, 0);

  if (dmp->dm_debugLevel) {
    bu_log("X_drawPoint2D()\n");
    bu_log("x = %g, y = %g\n", x, y);
    bu_log("sx = %d, sy = %d\n", sx, sy);
  }

  XDrawPoint( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	      ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
	      ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, sx, sy );

  return TCL_OK;
}

HIDDEN int
X_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict, fastf_t transparency)
{
  XGCValues gcv;

  if (dmp->dm_debugLevel)
    bu_log("X_setFGColor()\n");

  dmp->dm_fg[0] = r;
  dmp->dm_fg[1] = g;
  dmp->dm_fg[2] = b;

  if(((struct x_vars *)dmp->dm_vars.priv_vars)->is_trueColor){
    XColor color;

    color.red = r << 8;
    color.green = g << 8;
    color.blue = b << 8;
    get_color(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap,
	      &color);

    gcv.foreground = color.pixel;
  }else
    gcv.foreground = dm_get_pixel(r, g, b,
				  ((struct x_vars *)dmp->dm_vars.priv_vars)->pixels,
				  CUBE_DIMENSION);

  /* save foreground pixel */
  ((struct x_vars *)dmp->dm_vars.priv_vars)->fg = gcv.foreground;

  XChangeGC(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	    ((struct x_vars *)dmp->dm_vars.priv_vars)->gc,
	    GCForeground, &gcv);

  return TCL_OK;
}

HIDDEN int
X_setBGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b)
{
  if (dmp->dm_debugLevel)
    bu_log("X_setBGColor()\n");

  dmp->dm_bg[0] = r;
  dmp->dm_bg[1] = g;
  dmp->dm_bg[2] = b;

  if(((struct x_vars *)dmp->dm_vars.priv_vars)->is_trueColor){

    XColor color;

    color.red = r << 8;
    color.green = g << 8;
    color.blue = b << 8;

    get_color(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap,
		&color);

    ((struct x_vars *)dmp->dm_vars.priv_vars)->bg = color.pixel;
  } else
    ((struct x_vars *)dmp->dm_vars.priv_vars)->bg =
      dm_get_pixel(r, g, b, ((struct x_vars *)dmp->dm_vars.priv_vars)->pixels, CUBE_DIMENSION);

  return TCL_OK;
}

HIDDEN int
X_setLineAttr(struct dm *dmp, int width, int style)
{
  int linestyle;

  if (dmp->dm_debugLevel)
    bu_log("X_setLineAttr()\n");

  dmp->dm_lineWidth = width;
  dmp->dm_lineStyle = style;

  if(width <= 1)
    width = 0;

  if(style == DM_DASHED_LINE)
    linestyle = LineOnOffDash;
  else
    linestyle = LineSolid;

  XSetLineAttributes( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		      ((struct x_vars *)dmp->dm_vars.priv_vars)->gc,
		      width, linestyle, CapButt, JoinMiter );

  return TCL_OK;
}

/* ARGSUSED */
HIDDEN int
X_debug(struct dm *dmp, int lvl)
{
  dmp->dm_debugLevel = lvl;

  return TCL_OK;
}

HIDDEN int
X_setWinBounds(struct dm *dmp, register int *w)
{
  if (dmp->dm_debugLevel)
    bu_log("X_setWinBounds()\n");

  dmp->dm_clipmin[0] = w[0];
  dmp->dm_clipmin[1] = w[2];
  dmp->dm_clipmin[2] = w[4];
  dmp->dm_clipmax[0] = w[1];
  dmp->dm_clipmax[1] = w[3];
  dmp->dm_clipmax[2] = w[5];

  return TCL_OK;
}

HIDDEN int
X_configureWin_guts(struct dm *dmp, int force)
{
  XWindowAttributes xwa;
  XFontStruct     *newfontstruct;
  XGCValues       gcv;

  XGetWindowAttributes( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			((struct dm_xvars *)dmp->dm_vars.pub_vars)->win, &xwa );

  /* nothing to do */
  if (!force &&
      dmp->dm_height == xwa.height &&
      dmp->dm_width == xwa.width)
    return TCL_OK;
    
  dmp->dm_height = xwa.height;
  dmp->dm_width = xwa.width;
  dmp->dm_aspect = (fastf_t)dmp->dm_width / (fastf_t)dmp->dm_height;

  if (dmp->dm_debugLevel) {
    bu_log("X_configureWin_guts()\n");
    bu_log("width = %d, height = %d\n", dmp->dm_width, dmp->dm_height);
  }

  Tk_FreePixmap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		((struct x_vars *)dmp->dm_vars.priv_vars)->pix);
  ((struct x_vars *)dmp->dm_vars.priv_vars)->pix =
    Tk_GetPixmap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		 DefaultRootWindow(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy),
		 dmp->dm_width,
		 dmp->dm_height,
		 Tk_Depth(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin));

  /* First time through, load a font or quit */
  if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct == NULL) {
    if ((((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct =
	 XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy, FONT9)) == NULL ) {
      /* Try hardcoded backup font */
      if ((((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct =
	   XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy, FONTBACK)) == NULL) {
	bu_log("dm-X: Can't open font '%s' or '%s'\n", FONT9, FONTBACK);
	return TCL_ERROR;
      }
    }

    gcv.font = ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->fid;
    XChangeGC(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	      ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, GCFont, &gcv);
  }

  /* Always try to choose a the font that best fits the window size.
   */

  if (dmp->dm_width < 582) {
    if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->per_char->width != 5) {
      if ((newfontstruct = XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
					  FONT5)) != NULL ) {
	XFreeFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct);
	((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct = newfontstruct;
	gcv.font = ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->fid;
	XChangeGC(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		  ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, GCFont, &gcv);
      }
    }
  } else if (dmp->dm_width < 679) {
    if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->per_char->width != 6){
      if ((newfontstruct = XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
					  FONT6)) != NULL ) {
	XFreeFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct);
	((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct = newfontstruct;
	gcv.font = ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->fid;
	XChangeGC(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		  ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, GCFont, &gcv);
      }
    }
  } else if (dmp->dm_width < 776) {
    if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->per_char->width != 7){
      if ((newfontstruct = XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
					  FONT7)) != NULL ) {
	XFreeFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct);
	((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct = newfontstruct;
	gcv.font = ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->fid;
	XChangeGC(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		  ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, GCFont, &gcv);
      }
    }
  } else if (dmp->dm_width < 873) {
    if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->per_char->width != 8){
      if ((newfontstruct = XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
					  FONT8)) != NULL ) {
	XFreeFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct);
	((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct = newfontstruct;
	gcv.font = ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->fid;
	XChangeGC(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		  ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, GCFont, &gcv);
      }
    }
  } else {
    if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->per_char->width != 9){
      if ((newfontstruct = XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
					  FONT9)) != NULL ) {
	XFreeFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct);
	((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct = newfontstruct;
	gcv.font = ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->fid;
	XChangeGC(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		  ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, GCFont, &gcv);
      }
    }
  }

  return TCL_OK;
}

HIDDEN int
X_configureWin(struct dm *dmp)
{
  /* don't force */
  return X_configureWin_guts(dmp, 0);
}

HIDDEN int
X_setLight(struct dm *dmp, int light_on)
{
  if (dmp->dm_debugLevel)
    bu_log("X_setLight:\n");

  dmp->dm_light = light_on;

  return TCL_OK;
}

HIDDEN int
X_setZBuffer(struct dm *dmp, int zbuffer_on)
{
  if (dmp->dm_debugLevel)
    bu_log("X_setZBuffer:\n");

  dmp->dm_zbuffer = zbuffer_on;

  return TCL_OK;
}

HIDDEN XVisualInfo *
X_choose_visual(struct dm *dmp)
{
  XVisualInfo *vip, vitemp, *vibase, *maxvip;
  int good[256];
  int num, i, j;
  int tries, baddepth;
  int desire_trueColor = 1;
  int min_depth = 8;

  vibase = XGetVisualInfo(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			  0, &vitemp, &num);

  while (1) {
    for (i=0, j=0, vip=vibase; i<num; i++, vip++){
#if 0
      /* code to force a particular visual class and depth */
      if (vip->depth != 8)
	continue;
      if (vip->class != PseudoColor)
	continue;
#else
      /* requirements */
      if (vip->depth < min_depth)
	continue;
      if (desire_trueColor){
	if (vip->class != TrueColor)
	  continue;
      }else if (vip->class != PseudoColor)
	continue;
#endif
			
      /* this visual meets criteria */
      good[j++] = i;
    }

    baddepth = 1000;
    for(tries = 0; tries < j; ++tries) {
      maxvip = vibase + good[0];
      for (i=1; i<j; i++) {
	vip = vibase + good[i];
	if ((vip->depth > maxvip->depth)&&(vip->depth < baddepth)){
	  maxvip = vip;
	}
      }

      /* make sure Tk handles it */
      if(desire_trueColor){
	((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap =
	  XCreateColormap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			  RootWindow(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
				     maxvip->screen),
			  maxvip->visual, AllocNone);
	((struct x_vars *)dmp->dm_vars.priv_vars)->is_trueColor = 1;
      }else{
	((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap =
	  XCreateColormap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			  RootWindow(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
				     maxvip->screen),
			  maxvip->visual, AllocAll);
	((struct x_vars *)dmp->dm_vars.priv_vars)->is_trueColor = 0;
      }

      if (Tk_SetWindowVisual(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin,
			     maxvip->visual,
			     maxvip->depth,
			     ((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap)){
	((struct dm_xvars *)dmp->dm_vars.pub_vars)->depth = maxvip->depth;

	return maxvip; /* success */
      } else { 
	/* retry with lesser depth */
	baddepth = maxvip->depth;
	XFreeColormap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap);
      }
    }

    if(desire_trueColor)
      desire_trueColor = 0;
    else
      return (XVisualInfo *)NULL; /* failure */
  }
}
@


1.64
log
@change conf.h to a wrapped config.h
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/libdm/dm-X.c,v 1.63 2004/05/10 15:25:26 morrison Exp $ (BRL)";
@


1.63
log
@Bob Parker's view modifications, png framebuffer support, shaded drawing mode
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-X.c,v 1.62 2004/04/05 07:45:07 morrison Exp $ (BRL)";
d23 5
a27 1
#include "conf.h"
@


1.62
log
@merge of ansi-6-0-branch into HEAD
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d77 1
a77 1
HIDDEN int      X_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict);
d102 2
d131 2
a132 2
  {0.0, 0.0, 0.0},		/* clipmin */
  {0.0, 0.0, 0.0},		/* clipmax */
d136 1
d139 1
d954 1
a954 1
X_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict)
@


1.61
log
@update copyright to include span through 2003
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-X.c,v 1.60 2003/09/25 14:59:26 jra Exp $ (BRL)";
d64 1
a64 1
HIDDEN XVisualInfo *X_choose_visual();
d69 16
a84 15
struct dm	*X_open();
HIDDEN int	X_close();
HIDDEN int	X_drawBegin(), X_drawEnd();
HIDDEN int	X_normal(), X_loadMatrix();
HIDDEN int      X_drawString2D();
HIDDEN int	X_drawLine2D();
HIDDEN int      X_drawPoint2D();
HIDDEN int	X_drawVList();
HIDDEN int      X_setFGColor(), X_setBGColor();
HIDDEN int	X_setLineAttr();
HIDDEN int	X_configureWin_guts();
HIDDEN int	X_configureWin();
HIDDEN int	X_setLight();
HIDDEN int	X_setZBuffer();
HIDDEN int	X_setWinBounds(), X_debug();
d192 1
a192 4
X_open(interp, argc, argv)
     Tcl_Interp *interp;
     int argc;
     char *argv[];
d499 1
a499 2
X_close(dmp)
struct dm *dmp;
d537 1
a537 2
X_drawBegin(dmp)
struct dm *dmp;
d568 1
a568 2
X_drawEnd(dmp)
struct dm *dmp;
d594 1
a594 4
X_loadMatrix(dmp, mat, which_eye)
struct dm *dmp;
mat_t mat;
int which_eye;
d624 1
a624 3
X_drawVList(dmp, vp)
     struct dm			*dmp;
     register struct rt_vlist	*vp;
d859 1
a859 2
X_normal(dmp)
struct dm *dmp;
d875 1
a875 6
X_drawString2D(dmp, str, x, y, size, use_aspect)
struct dm *dmp;
register char *str;
fastf_t x, y;
int size;
int use_aspect;
d903 1
a903 4
X_drawLine2D( dmp, x1, y1, x2, y2)
struct dm *dmp;
fastf_t x1, y1;
fastf_t x2, y2;
d929 1
a929 3
X_drawPoint2D( dmp, x, y )
struct dm *dmp;
fastf_t x, y;
d950 1
a950 4
X_setFGColor(dmp, r, g, b, strict)
struct dm *dmp;
unsigned char r, g, b;
int strict;
d988 1
a988 3
X_setBGColor(dmp, r, g, b)
struct dm *dmp;
unsigned char r, g, b;
d1018 1
a1018 4
X_setLineAttr(dmp, width, style)
struct dm *dmp;
int width;
int style;
d1045 1
a1045 3
X_debug(dmp, lvl)
struct dm *dmp;
int lvl;
d1053 1
a1053 3
X_setWinBounds(dmp, w)
struct dm *dmp;
register int w[6];
d1069 1
a1069 3
X_configureWin_guts(dmp, force)
struct dm *dmp;
int force;
d1188 1
a1188 2
X_configureWin(dmp)
struct dm *dmp;
d1195 1
a1195 3
X_setLight(dmp, light_on)
     struct dm *dmp;
     int light_on;
d1206 1
a1206 3
X_setZBuffer(dmp, zbuffer_on)
struct dm *dmp;
int zbuffer_on;
d1217 1
a1217 2
X_choose_visual(dmp)
struct dm *dmp;
@


1.60
log
@Ifdef'd out the complaining about slightly off color values in "get_color()" when
XAllocColor() claims it succeeded. This was making some applications (like rtwizard)
completely unusable
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1988 by the United States Army.
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-X.c,v 1.59 2002/08/20 17:07:44 jra Exp $ (BRL)";
@


1.60.2.1
log
@merge from HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-X.c,v 1.61 2004/02/02 17:39:08 morrison Exp $ (BRL)";
@


1.60.2.2
log
@merge from head
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-X.c,v 1.60.2.1 2004/02/12 19:45:18 erikg Exp $ (BRL)";
@


1.59
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-X.c,v 1.57 2001/04/02 21:38:01 morrison Exp $ (BRL)";
d155 1
d166 1
@


1.59.4.1
log
@sync to HEAD...
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libdm/dm-X.c,v 1.61 2004/02/02 17:39:08 morrison Exp $ (BRL)";
a154 1
#if 0
a164 1
#endif
@


1.59.2.1
log
@Initial ANSIfication
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-X.c,v 1.59 2002/08/20 17:07:44 jra Exp $ (BRL)";
d64 1
a64 1
HIDDEN XVisualInfo *X_choose_visual(struct dm *dmp);
d69 15
a83 15
struct dm	*X_open(Tcl_Interp *interp, int argc, char **argv);
HIDDEN int	X_close(struct dm *dmp);
HIDDEN int	X_drawBegin(struct dm *dmp), X_drawEnd(struct dm *dmp);
HIDDEN int	X_normal(struct dm *dmp), X_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye);
HIDDEN int      X_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect);
HIDDEN int	X_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2);
HIDDEN int      X_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y);
HIDDEN int	X_drawVList(struct dm *dmp, register struct bn_vlist *vp);
HIDDEN int      X_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict), X_setBGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b);
HIDDEN int	X_setLineAttr(struct dm *dmp, int width, int style);
HIDDEN int	X_configureWin_guts(struct dm *dmp, int force);
HIDDEN int	X_configureWin(struct dm *dmp);
HIDDEN int	X_setLight(struct dm *dmp, int light_on);
HIDDEN int	X_setZBuffer(struct dm *dmp, int zbuffer_on);
HIDDEN int	X_setWinBounds(struct dm *dmp, register int *w), X_debug(struct dm *dmp, int lvl);
d189 4
a192 1
X_open(Tcl_Interp *interp, int argc, char **argv)
d499 2
a500 1
X_close(struct dm *dmp)
d538 2
a539 1
X_drawBegin(struct dm *dmp)
d570 2
a571 1
X_drawEnd(struct dm *dmp)
d597 4
a600 1
X_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye)
d630 3
a632 1
X_drawVList(struct dm *dmp, register struct bn_vlist *vp)
d867 2
a868 1
X_normal(struct dm *dmp)
d884 6
a889 1
X_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect)
d917 4
a920 1
X_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2)
d946 3
a948 1
X_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y)
d969 4
a972 1
X_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict)
d1010 3
a1012 1
X_setBGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b)
d1042 4
a1045 1
X_setLineAttr(struct dm *dmp, int width, int style)
d1072 3
a1074 1
X_debug(struct dm *dmp, int lvl)
d1082 3
a1084 1
X_setWinBounds(struct dm *dmp, register int *w)
d1100 3
a1102 1
X_configureWin_guts(struct dm *dmp, int force)
d1221 2
a1222 1
X_configureWin(struct dm *dmp)
d1229 3
a1231 1
X_setLight(struct dm *dmp, int light_on)
d1242 3
a1244 1
X_setZBuffer(struct dm *dmp, int zbuffer_on)
d1255 2
a1256 1
X_choose_visual(struct dm *dmp)
@


1.59.2.2
log
@sync branch with HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a154 1
#if 0
a164 1
#endif
@


1.59.2.3
log
@need to match the fg/bg function sig to quell warning
@
text
@d77 1
a77 2
HIDDEN int      X_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict);
HIDDEN int	X_setBGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b);
@


1.58
log
@Converted from K&R to ANSI C - RFH
@
text
@d64 1
a64 1
HIDDEN XVisualInfo *X_choose_visual(struct dm *dmp);
d69 15
a83 15
struct dm	*X_open(Tcl_Interp *interp, int argc, char **argv);
HIDDEN int	X_close(struct dm *dmp);
HIDDEN int	X_drawBegin(struct dm *dmp), X_drawEnd(struct dm *dmp);
HIDDEN int	X_normal(struct dm *dmp), X_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye);
HIDDEN int      X_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect);
HIDDEN int	X_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2);
HIDDEN int      X_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y);
HIDDEN int	X_drawVList(struct dm *dmp, register struct bn_vlist *vp);
HIDDEN int      X_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict), X_setBGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b);
HIDDEN int	X_setLineAttr(struct dm *dmp, int width, int style);
HIDDEN int	X_configureWin_guts(struct dm *dmp, int force);
HIDDEN int	X_configureWin(struct dm *dmp);
HIDDEN int	X_setLight(struct dm *dmp, int light_on);
HIDDEN int	X_setZBuffer(struct dm *dmp, int zbuffer_on);
HIDDEN int	X_setWinBounds(struct dm *dmp, register int *w), X_debug(struct dm *dmp, int lvl);
d189 4
a192 1
X_open(Tcl_Interp *interp, int argc, char **argv)
d499 2
a500 1
X_close(struct dm *dmp)
d538 2
a539 1
X_drawBegin(struct dm *dmp)
d570 2
a571 1
X_drawEnd(struct dm *dmp)
d597 4
a600 1
X_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye)
d630 3
a632 1
X_drawVList(struct dm *dmp, register struct bn_vlist *vp)
d867 2
a868 1
X_normal(struct dm *dmp)
d884 6
a889 1
X_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect)
d917 4
a920 1
X_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2)
d946 3
a948 1
X_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y)
d969 4
a972 1
X_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict)
d1010 3
a1012 1
X_setBGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b)
d1042 4
a1045 1
X_setLineAttr(struct dm *dmp, int width, int style)
d1072 3
a1074 1
X_debug(struct dm *dmp, int lvl)
d1082 3
a1084 1
X_setWinBounds(struct dm *dmp, register int *w)
d1100 3
a1102 1
X_configureWin_guts(struct dm *dmp, int force)
d1221 2
a1222 1
X_configureWin(struct dm *dmp)
d1229 3
a1231 1
X_setLight(struct dm *dmp, int light_on)
d1242 3
a1244 1
X_setZBuffer(struct dm *dmp, int zbuffer_on)
d1255 2
a1256 1
X_choose_visual(struct dm *dmp)
@


1.57
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-X.c,v 1.56 2001/04/02 13:04:34 jra Exp $ (BRL)";
d64 1
a64 1
HIDDEN XVisualInfo *X_choose_visual();
d69 15
a83 15
struct dm	*X_open();
HIDDEN int	X_close();
HIDDEN int	X_drawBegin(), X_drawEnd();
HIDDEN int	X_normal(), X_loadMatrix();
HIDDEN int      X_drawString2D();
HIDDEN int	X_drawLine2D();
HIDDEN int      X_drawPoint2D();
HIDDEN int	X_drawVList();
HIDDEN int      X_setFGColor(), X_setBGColor();
HIDDEN int	X_setLineAttr();
HIDDEN int	X_configureWin_guts();
HIDDEN int	X_configureWin();
HIDDEN int	X_setLight();
HIDDEN int	X_setZBuffer();
HIDDEN int	X_setWinBounds(), X_debug();
d189 1
a189 4
X_open(interp, argc, argv)
     Tcl_Interp *interp;
     int argc;
     char *argv[];
d496 1
a496 2
X_close(dmp)
struct dm *dmp;
d534 1
a534 2
X_drawBegin(dmp)
struct dm *dmp;
d565 1
a565 2
X_drawEnd(dmp)
struct dm *dmp;
d591 1
a591 4
X_loadMatrix(dmp, mat, which_eye)
struct dm *dmp;
mat_t mat;
int which_eye;
d621 1
a621 3
X_drawVList(dmp, vp)
     struct dm			*dmp;
     register struct rt_vlist	*vp;
d856 1
a856 2
X_normal(dmp)
struct dm *dmp;
d872 1
a872 6
X_drawString2D(dmp, str, x, y, size, use_aspect)
struct dm *dmp;
register char *str;
fastf_t x, y;
int size;
int use_aspect;
d900 1
a900 4
X_drawLine2D( dmp, x1, y1, x2, y2)
struct dm *dmp;
fastf_t x1, y1;
fastf_t x2, y2;
d926 1
a926 3
X_drawPoint2D( dmp, x, y )
struct dm *dmp;
fastf_t x, y;
d947 1
a947 4
X_setFGColor(dmp, r, g, b, strict)
struct dm *dmp;
unsigned char r, g, b;
int strict;
d985 1
a985 3
X_setBGColor(dmp, r, g, b)
struct dm *dmp;
unsigned char r, g, b;
d1015 1
a1015 4
X_setLineAttr(dmp, width, style)
struct dm *dmp;
int width;
int style;
d1042 1
a1042 3
X_debug(dmp, lvl)
struct dm *dmp;
int lvl;
d1050 1
a1050 3
X_setWinBounds(dmp, w)
struct dm *dmp;
register int w[6];
d1066 1
a1066 3
X_configureWin_guts(dmp, force)
struct dm *dmp;
int force;
d1185 1
a1185 2
X_configureWin(dmp)
struct dm *dmp;
d1192 1
a1192 3
X_setLight(dmp, light_on)
     struct dm *dmp;
     int light_on;
d1203 1
a1203 3
X_setZBuffer(dmp, zbuffer_on)
struct dm *dmp;
int zbuffer_on;
d1214 1
a1214 2
X_choose_visual(dmp)
struct dm *dmp;
@


1.56
log
@Lint
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-X.c,v 1.55 2001/03/31 01:56:51 morrison Exp $ (BRL)";
d620 1
a620 1
  bn_mat_copy(((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, mat);
@


1.55
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-X.c,v 1.54 2001/03/19 22:19:50 butler Exp $ (BRL)";
a373 3
    int r = 255;
    int g = 0;
    int b = 0;
a384 1
    r = g = b = 0;
@


1.54
log
@patches to merge 5.3 into 6.0
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/libdm/dm-X.c,v 1.53 2000/09/12 15:02:56 pjt Exp $ (BRL)";
d492 1
a492 1
  bn_mat_idn(((struct x_vars *)dmp->dm_vars.priv_vars)->xmat);
@


1.53
log
@Turned dials and buttons back on
(They no longer need to be turned off to make vanilla-flavored wish's life
easier, since we now have libtclhooks)
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-X.c,v 1.52 2000/08/31 18:16:42 bparker Exp $ (BRL)";
d143 39
d374 3
d379 1
a379 1
    fg.red = 255 << 8;
d381 5
a385 3
    XAllocColor(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap,
		&fg);
d388 1
d390 1
a390 1
    XAllocColor(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
d393 1
d993 1
a993 1
    XAllocColor(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
d995 2
a996 1
		&color);
d1026 1
d1032 2
a1033 1
    XAllocColor(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
d1036 1
@


1.52
log
@Mods to rid libdm of two globals: tkwin and interp
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-X.c,v 1.51 2000/08/17 18:15:20 bparker Exp $ (BRL)";
d34 1
a34 1
#define USE_DIALS_AND_BUTTONS 0
@


1.51
log
@Add vector counting code.
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-X.c,v 1.50 2000/07/12 03:24:43 cjohnson Exp $ (BRL)";
d34 2
d40 1
d42 1
d134 2
a135 1
  0				/* no zclipping */
a142 3
/* Currently, the application must define these. */
extern Tk_Window tkwin;

d150 4
a153 3
X_open(argc, argv)
int argc;
char *argv[];
a155 1
  int j, k;
d158 2
d166 1
d170 5
d181 1
d381 1
d435 1
@


1.50
log
@LINT from gcc -Wall.  Includes some modifications to bu.h and fb.h
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-X.c,v 1.49 2000/02/18 21:10:10 bparker Exp $ (BRL)";
d136 2
d576 2
a577 2
struct dm *dmp;
register struct rt_vlist *vp;
d579 14
a592 13
    static vect_t spnt, lpnt, pnt;
    register struct rt_vlist *tvp;
    XSegment segbuf[1024];		/* XDrawSegments list */
    XSegment *segp;			/* current segment */
    int	nseg;			        /* number of segments */
    fastf_t delta;
    register point_t *pt_prev = NULL;
    fastf_t 	 dist_prev=1.0;

    if (dmp->dm_debugLevel) {
      bu_log("X_drawVList()\n");
      bu_log("vp - %lu, perspective - %d\n", vp, dmp->dm_perspective);
    }
d594 188
a781 34
    /* delta is used in clipping to insure clipped endpoint is slightly
     * in front of eye plane (perspective mode only).
     * This value is a SWAG that seems to work OK.
     */
    delta = ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat[15]*0.0001;
    if( delta < 0.0 )
	delta = -delta;
    if( delta < SQRT_SMALL_FASTF )
	delta = SQRT_SMALL_FASTF;

    nseg = 0;
    segp = segbuf;
    for( BU_LIST_FOR( tvp, rt_vlist, &vp->l ) )  {
	register int	i;
	register int	nused = tvp->nused;
	register int	*cmd = tvp->cmd;
	register point_t *pt = tvp->pt;
    	fastf_t 	 dist;

	/* Viewing region is from -1.0 to +1.0 */
	/* 2^31 ~= 2e9 -- dynamic range of a long int */
	/* 2^(31-11) = 2^20 ~= 1e6 */
	/* Integerize and let the X server do the clipping */
	for( i = 0; i < nused; i++,cmd++,pt++ )  {
	    switch( *cmd )  {
	    case RT_VLIST_POLY_START:
	    case RT_VLIST_POLY_VERTNORM:
		continue;
	    case RT_VLIST_POLY_MOVE:
	    case RT_VLIST_LINE_MOVE:
		/* Move, not draw */
		if(dmp->dm_debugLevel > 2){
		  bu_log("before transformation:\n");
		  bu_log("pt - %lf %lf %lf\n", V3ARGS(*pt));
d784 4
a787 17
		if (dmp->dm_perspective > 0) {
	    		/* cannot apply perspective transformation to
			 * points behind eye plane!!!!
	    		 */
	    		dist = VDOT(*pt, &((struct x_vars *)dmp->dm_vars.priv_vars)->xmat[12]) + ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat[15];
	    		if( dist <= 0.0 ) {
	    			pt_prev = pt;
	    			dist_prev = dist;
	    			continue;
	    		} else	{
	    			MAT4X3PNT(lpnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, *pt);
	    			dist_prev = dist;
	    			pt_prev = pt;
	    		}
	    	} else {
			MAT4X3PNT(lpnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, *pt);
		}
d789 1
a789 12
		lpnt[0] *= 2047;
		lpnt[1] *= 2047 * dmp->dm_aspect;
		lpnt[2] *= 2047;
		continue;
	    case RT_VLIST_POLY_DRAW:
	    case RT_VLIST_POLY_END:
	    case RT_VLIST_LINE_DRAW:
		/* draw */
		if(dmp->dm_debugLevel > 2){
		  bu_log("before transformation:\n");
		  bu_log("pt - %lf %lf %lf\n", V3ARGS(*pt));
		}
d791 2
a792 68
		if (dmp->dm_perspective > 0) {
	    		/* cannot apply perspective transformation to
			 * points behind eye plane!!!!
	    		 */
	    		dist = VDOT( *pt, &((struct x_vars *)dmp->dm_vars.priv_vars)->xmat[12] ) + ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat[15];
			if(dmp->dm_debugLevel > 2)
	    			bu_log( "dist=%g, dist_prev=%g\n", dist, dist_prev );
	    		if( dist <= 0.0 ) {
	    			if( dist_prev <= 0.0 ) {
	    				/* nothing to plot */
		    			dist_prev = dist;
		    			pt_prev = pt;
		    			continue;
	    			} else {
	    				fastf_t alpha;
	    				vect_t diff;
	    				point_t tmp_pt;

	    				/* clip this end */
	    				VSUB2( diff, *pt, *pt_prev );
	    				alpha = (dist_prev - delta) / ( dist_prev - dist );
	    				VJOIN1( tmp_pt, *pt_prev, alpha, diff );
	    				MAT4X3PNT( pnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, tmp_pt );
	    			}
	    		} else {
	    			if( dist_prev <= 0.0 ) {
	    				fastf_t alpha;
	    				vect_t diff;
	    				point_t tmp_pt;

	    				/* clip other end */
	    				VSUB2( diff, *pt, *pt_prev );
	    				alpha = (-dist_prev + delta) / ( dist - dist_prev );
	    				VJOIN1( tmp_pt, *pt_prev, alpha, diff );
	    				MAT4X3PNT( lpnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, tmp_pt );
	    				lpnt[0] *= 2047;
	    				lpnt[1] *= 2047 * dmp->dm_aspect;
	    				lpnt[2] *= 2047;
	    				MAT4X3PNT( pnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, *pt );
	    			} else {
	    				MAT4X3PNT( pnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, *pt );
	    			}
	    		}
			dist_prev = dist;
	    	} else {
			MAT4X3PNT( pnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, *pt );
		}

		pnt[0] *= 2047;
		pnt[1] *= 2047 * dmp->dm_aspect;
		pnt[2] *= 2047;

		/* save pnt --- it might get changed by clip() */
		VMOVE(spnt, pnt);
	    	pt_prev = pt;

		if(dmp->dm_debugLevel > 2) {
		  bu_log("before clipping:\n");
		  bu_log("clipmin - %lf %lf %lf\n",
			 dmp->dm_clipmin[X],
			 dmp->dm_clipmin[Y],
			 dmp->dm_clipmin[Z]);
		  bu_log("clipmax - %lf %lf %lf\n",
			 dmp->dm_clipmax[X],
			 dmp->dm_clipmax[Y],
			 dmp->dm_clipmax[Z]);
		  bu_log("pt1 - %lf %lf %lf\n", lpnt[X], lpnt[Y], lpnt[Z]);
		  bu_log("pt2 - %lf %lf %lf\n", pnt[X], pnt[Y], pnt[Z]);
d794 1
d796 4
a799 50
		if (dmp->dm_zclip) {
		  if(vclip(lpnt, pnt,
			   dmp->dm_clipmin,
			   dmp->dm_clipmax) == 0){
		    VMOVE(lpnt, spnt);
		    continue;
		  }
		}else{
		  /* Check to see if lpnt or pnt contain values that exceed
		     the capacity of a short (segbuf is an array of XSegments which
		     contain shorts). If so, do clipping now. Otherwise, let the
		     X server do the clipping */
		  if(lpnt[0] < min_short || max_short < lpnt[0] ||
		     lpnt[1] < min_short || max_short < lpnt[1] ||
		     pnt[0] < min_short || max_short < pnt[0] ||
		     pnt[1] < min_short || max_short < pnt[1]){
		    /* if the entire line segment will not be visible then ignore it */
		    if(clip(&lpnt[0], &lpnt[1], &pnt[0], &pnt[1]) == -1){
		      VMOVE(lpnt, spnt);
		      continue;
		    }
		  }
		}

		if(dmp->dm_debugLevel > 2) {
		  bu_log("after clipping:\n");
		  bu_log("pt1 - %lf %lf %lf\n", lpnt[X], lpnt[Y], lpnt[Z]);
		  bu_log("pt2 - %lf %lf %lf\n", pnt[X], pnt[Y], pnt[Z]);
		}

		/* convert to X window coordinates */
		segp->x1 = (short)GED_TO_Xx(dmp, lpnt[0]);
		segp->y1 = (short)GED_TO_Xy(dmp, lpnt[1]);
		segp->x2 = (short)GED_TO_Xx(dmp, pnt[0]);
		segp->y2 = (short)GED_TO_Xy(dmp, pnt[1]);

		nseg++;
		segp++;
		VMOVE(lpnt, spnt);

		if( nseg == 1024 ) {
		  XDrawSegments( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
				 ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
				 ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, segbuf, nseg );

		  nseg = 0;
		  segp = segbuf;
		}
		break;
	    }
a800 6
    }
    if( nseg ) {
      XDrawSegments( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		     ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
		     ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, segbuf, nseg );
    }
d802 1
a802 1
    return TCL_OK;
@


1.49
log
@*- mods to debug
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-X.c,v 1.48 2000/01/28 15:40:57 bparker Exp $ (BRL)";
d119 7
a125 7
  0,
  0,
  0,
  0,
  0,
  0,				/* clipmin */
  0,				/* clipmax */
d627 1
a627 2
		if (dmp->dm_perspective > 0)
	    	{
d632 1
a632 2
	    		if( dist <= 0.0 )
	    		{
d636 1
a636 3
	    		}
	    		else
	    		{
d641 1
a641 2
	    	}
		else
d643 1
d658 1
a658 2
		if (dmp->dm_perspective > 0)
	    	{
d665 2
a666 4
	    		if( dist <= 0.0 )
	    		{
	    			if( dist_prev <= 0.0 )
	    			{
d671 1
a671 3
	    			}
	    			else
	    			{
d682 2
a683 5
	    		}
	    		else
	    		{
	    			if( dist_prev <= 0.0 )
	    			{
d697 1
a697 3
	    			}
	    			else
	    			{
d701 2
a702 2
	    	}
		else
d704 1
a712 1
	    	dist_prev = dist;
@


1.49.2.1
log
@Removed two globals: interp and tkwin
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-X.c,v 1.52 2000/08/31 18:16:42 bparker Exp $ (BRL)";
a33 2
#define USE_DIALS_AND_BUTTONS 0

a37 1
#if USE_DIALS_AND_BUTTONS
a38 1
#endif
d119 7
a125 7
  {0, 0, 0, 0, 0},		/* bu_vls path name*/
  {0, 0, 0, 0, 0},		/* bu_vls full name drawing window */
  {0, 0, 0, 0, 0},		/* bu_vls short name drawing window */
  {0, 0, 0},			/* bg color */
  {0, 0, 0},			/* fg color */
  {0.0, 0.0, 0.0},		/* clipmin */
  {0.0, 0.0, 0.0},		/* clipmax */
d130 1
a130 2
  0,				/* no zclipping */
  0				/* Tcl interpreter */
d136 2
a137 1
extern int vectorThreshold;	/* defined in libdm/tcl.c */ 
d146 3
a148 4
X_open(interp, argc, argv)
     Tcl_Interp *interp;
     int argc;
     char *argv[];
d151 1
a153 2
#if USE_DIALS_AND_BUTTONS
  int j, k;
a159 1
#endif
a162 5
  Tk_Window tkwin;

  if ((tkwin = Tk_MainWindow(interp)) == NULL) {
	  return DM_NULL;
  }
a168 1
  dmp->dm_interp = interp;
a367 1
#if USE_DIALS_AND_BUTTONS
a420 1
#endif
d574 2
a575 2
     struct dm			*dmp;
     register struct rt_vlist	*vp;
d577 49
a625 14
	static vect_t			spnt, lpnt, pnt;
	register struct rt_vlist	*tvp;
	XSegment			segbuf[1024];		/* XDrawSegments list */
	XSegment			*segp;			/* current segment */
	int				nseg;		        /* number of segments */
	fastf_t				delta;
	register point_t		*pt_prev = NULL;
	fastf_t				dist_prev=1.0;
	static int			nvectors = 0;

	if (dmp->dm_debugLevel) {
		bu_log("X_drawVList()\n");
		bu_log("vp - %lu, perspective - %d\n", vp, dmp->dm_perspective);
	}
d627 33
a659 188
	/* delta is used in clipping to insure clipped endpoint is slightly
	 * in front of eye plane (perspective mode only).
	 * This value is a SWAG that seems to work OK.
	 */
	delta = ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat[15]*0.0001;
	if (delta < 0.0)
		delta = -delta;
	if (delta < SQRT_SMALL_FASTF)
		delta = SQRT_SMALL_FASTF;

	nseg = 0;
	segp = segbuf;
	for (BU_LIST_FOR(tvp, rt_vlist, &vp->l)) {
		register int	i;
		register int	nused = tvp->nused;
		register int	*cmd = tvp->cmd;
		register point_t *pt = tvp->pt;
		fastf_t 	 dist;

		/* Viewing region is from -1.0 to +1.0 */
		/* 2^31 ~= 2e9 -- dynamic range of a long int */
		/* 2^(31-11) = 2^20 ~= 1e6 */
		/* Integerize and let the X server do the clipping */
		for (i = 0; i < nused; i++,cmd++,pt++) {
			switch (*cmd) {
			case RT_VLIST_POLY_START:

			case RT_VLIST_POLY_VERTNORM:
				continue;
			case RT_VLIST_POLY_MOVE:
			case RT_VLIST_LINE_MOVE:
				/* Move, not draw */
				if (dmp->dm_debugLevel > 2) {
					bu_log("before transformation:\n");
					bu_log("pt - %lf %lf %lf\n", V3ARGS(*pt));
				}

				if (dmp->dm_perspective > 0) {
					/* cannot apply perspective transformation to
					 * points behind eye plane!!!!
					 */
					dist = VDOT(*pt, &((struct x_vars *)dmp->dm_vars.priv_vars)->xmat[12]) + ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat[15];
					if (dist <= 0.0) {
						pt_prev = pt;
						dist_prev = dist;
						continue;
					} else {
						MAT4X3PNT(lpnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, *pt);
						dist_prev = dist;
						pt_prev = pt;
					}
				} else {
					MAT4X3PNT(lpnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, *pt);
				}

				lpnt[0] *= 2047;
				lpnt[1] *= 2047 * dmp->dm_aspect;
				lpnt[2] *= 2047;
				continue;
			case RT_VLIST_POLY_DRAW:
			case RT_VLIST_POLY_END:
			case RT_VLIST_LINE_DRAW:
				/* draw */
				if (dmp->dm_debugLevel > 2) {
					bu_log("before transformation:\n");
					bu_log("pt - %lf %lf %lf\n", V3ARGS(*pt));
				}

				if (dmp->dm_perspective > 0) {
					/* cannot apply perspective transformation to
					 * points behind eye plane!!!!
					 */
					dist = VDOT( *pt, &((struct x_vars *)dmp->dm_vars.priv_vars)->xmat[12] ) + ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat[15];
					if (dmp->dm_debugLevel > 2)
						bu_log( "dist=%g, dist_prev=%g\n", dist, dist_prev );
					if (dist <= 0.0) {
						if (dist_prev <= 0.0) {
							/* nothing to plot */
							dist_prev = dist;
							pt_prev = pt;
							continue;
						} else {
							fastf_t alpha;
							vect_t diff;
							point_t tmp_pt;

							/* clip this end */
							VSUB2(diff, *pt, *pt_prev);
							alpha = (dist_prev - delta) / (dist_prev - dist);
							VJOIN1(tmp_pt, *pt_prev, alpha, diff);
							MAT4X3PNT(pnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, tmp_pt);
						}
					} else {
						if (dist_prev <= 0.0) {
							fastf_t alpha;
							vect_t diff;
							point_t tmp_pt;

							/* clip other end */
							VSUB2(diff, *pt, *pt_prev);
							alpha = (-dist_prev + delta) / (dist - dist_prev);
							VJOIN1(tmp_pt, *pt_prev, alpha, diff);
							MAT4X3PNT(lpnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, tmp_pt);
							lpnt[0] *= 2047;
							lpnt[1] *= 2047 * dmp->dm_aspect;
							lpnt[2] *= 2047;
							MAT4X3PNT(pnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, *pt);
						} else {
							MAT4X3PNT(pnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, *pt);
						}
					}
					dist_prev = dist;
				} else {
					MAT4X3PNT(pnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, *pt);
				}

				pnt[0] *= 2047;
				pnt[1] *= 2047 * dmp->dm_aspect;
				pnt[2] *= 2047;

				/* save pnt --- it might get changed by clip() */
				VMOVE(spnt, pnt);
				pt_prev = pt;

				if (dmp->dm_debugLevel > 2) {
					bu_log("before clipping:\n");
					bu_log("clipmin - %lf %lf %lf\n",
					       dmp->dm_clipmin[X],
					       dmp->dm_clipmin[Y],
					       dmp->dm_clipmin[Z]);
					bu_log("clipmax - %lf %lf %lf\n",
					       dmp->dm_clipmax[X],
					       dmp->dm_clipmax[Y],
					       dmp->dm_clipmax[Z]);
					bu_log("pt1 - %lf %lf %lf\n", lpnt[X], lpnt[Y], lpnt[Z]);
					bu_log("pt2 - %lf %lf %lf\n", pnt[X], pnt[Y], pnt[Z]);
				}

				if (dmp->dm_zclip) {
					if (vclip(lpnt, pnt,
						  dmp->dm_clipmin,
						  dmp->dm_clipmax) == 0) {
						VMOVE(lpnt, spnt);
						continue;
					}
				} else {
					/* Check to see if lpnt or pnt contain values that exceed
					   the capacity of a short (segbuf is an array of XSegments which
					   contain shorts). If so, do clipping now. Otherwise, let the
					   X server do the clipping */
					if (lpnt[0] < min_short || max_short < lpnt[0] ||
					    lpnt[1] < min_short || max_short < lpnt[1] ||
					    pnt[0] < min_short || max_short < pnt[0] ||
					    pnt[1] < min_short || max_short < pnt[1]) {
						/* if the entire line segment will not be visible then ignore it */
						if (clip(&lpnt[0], &lpnt[1], &pnt[0], &pnt[1]) == -1) {
							VMOVE(lpnt, spnt);
							continue;
						}
					}
				}

				if (dmp->dm_debugLevel > 2) {
					bu_log("after clipping:\n");
					bu_log("pt1 - %lf %lf %lf\n", lpnt[X], lpnt[Y], lpnt[Z]);
					bu_log("pt2 - %lf %lf %lf\n", pnt[X], pnt[Y], pnt[Z]);
				}

				/* convert to X window coordinates */
				segp->x1 = (short)GED_TO_Xx(dmp, lpnt[0]);
				segp->y1 = (short)GED_TO_Xy(dmp, lpnt[1]);
				segp->x2 = (short)GED_TO_Xx(dmp, pnt[0]);
				segp->y2 = (short)GED_TO_Xy(dmp, pnt[1]);

				nseg++;
				segp++;
				VMOVE(lpnt, spnt);

				if (nseg == 1024) {
					XDrawSegments(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
						      ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
						      ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, segbuf, nseg);

					nseg = 0;
					segp = segbuf;
				}
				break;
			}
d662 79
a740 4
		nvectors += nused;
		if (nvectors >= vectorThreshold) {
			if (dmp->dm_debugLevel)
				bu_log("X_drawVList(): handle Tcl events\n");
d742 23
a764 1
			nvectors = 0;
d766 4
a769 2
			/* Handle events in the queue */
			while (Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT));
a770 1
	}
d772 20
a791 4
	if (nseg) {
		XDrawSegments( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			       ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
			       ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, segbuf, nseg );
d793 6
d800 1
a800 1
	return TCL_OK;
@


1.49.2.2
log
@Added check to calls to XAllocColor to make sure we got something vaguely correct
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-X.c,v 1.49.2.1 2000/09/01 17:24:42 bparker Exp $ (BRL)";
a142 40
static void 
get_color(Display *dpy, Colormap cmap, XColor *color)
{
	Status st;
	XColor rgb;
#define CSCK   0xf800

	rgb = *color;

	st = XAllocColor(dpy, cmap, color);
	switch (st) {
	case 1: 
		if ( (color->red & CSCK) != (rgb.red & CSCK) ||
		     (color->green & CSCK) != (rgb.green & CSCK) ||
		     (color->blue & CSCK) != (rgb.blue & CSCK) ) {
			bu_log("\nlooking for fg    (%3d,%3d,%3d) %04x,%04x,%04x got \n                  (%3d,%3d,%3d) %04x,%04x,%04x\n",
			       (rgb.red >> 8), (rgb.green >> 8), (rgb.blue >> 8),
			       rgb.red, rgb.green, rgb.blue,

			       (color->red >> 8), (color->green >> 8), (color->blue >> 8),
			       color->red, color->green, color->blue);
		}
		break;
	case BadColor:
		bu_log("XAllocColor failed (BadColor) for (%3d,%3d,%3d) %04x,%04x,%04x\n", 
		       (rgb.red >> 8), (rgb.green >> 8), (rgb.blue >> 8),
		       rgb.red, rgb.green, rgb.blue);
		break;

	default:
		bu_log("XAllocColor error for (%3d,%3d,%3d) %04x,%04x,%04x\n", 
		       (rgb.red >> 8), (rgb.green >> 8), (rgb.blue >> 8),
		       rgb.red, rgb.green, rgb.blue);
		break;
	}
#undef CSCK

}


a334 3
    int r = 255;
    int g = 0;
    int b = 0;
d337 1
a337 1
    fg.red = 65535;
d339 3
a341 5

    get_color(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap,
	      &fg);

a343 1
    r = g = b = 0;
d345 1
a345 1
    get_color(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
a347 1

d947 1
a947 1
    get_color(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
d949 1
a949 2
	      &color);

a978 1

d984 1
a984 2

    get_color(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
a986 1

@


1.48
log
@*- remove leading underscore from configureWin routines
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-X.c,v 1.47 2000/01/24 19:09:22 butler Exp $ (BRL)";
a1015 2
  XFlush(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy);
  bu_log("flushed\n");
@


1.47
log
@Functions declared to return an int weren't returning an int.  Fixed.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-X.c,v 1.46 2000/01/21 19:09:06 bparker Exp $ (BRL)";
d75 1
a75 1
HIDDEN int	_X_configureWin();
d424 1
a424 1
  (void)_X_configureWin(dmp, 1);
d1041 1
a1041 1
_X_configureWin(dmp, force)
d1063 1
a1063 1
    bu_log("_X_configureWin()\n");
d1166 1
a1166 1
  return _X_configureWin(dmp, 0);
@


1.46
log
@*- new routine _ogl_configureWin
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-X.c,v 1.45 2000/01/20 18:42:42 bparker Exp $ (BRL)";
d1166 1
a1166 1
  _X_configureWin(dmp, 0);
@


1.45
log
@*- mods to X_configureWin to verify that the window
   size did indeed change before doing anything
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-X.c,v 1.44 1999/12/30 15:05:52 jra Exp $ (BRL)";
d75 1
d424 1
a424 1
  (void)X_configureWin(dmp);
d1041 1
a1041 1
X_configureWin(dmp)
d1043 1
d1053 2
a1054 1
  if (dmp->dm_height == xwa.height &&
d1063 1
a1063 1
    bu_log("X_configureWin()\n");
d1159 8
@


1.44
log
@Eliminating more unused variables
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-X.c,v 1.43 1999/12/29 23:43:32 bparker Exp $ (BRL)";
a961 6
#if 0
  ((struct x_vars *)dmp->dm_vars.priv_vars)->r = r / 255.0;
  ((struct x_vars *)dmp->dm_vars.priv_vars)->g = g / 255.0;
  ((struct x_vars *)dmp->dm_vars.priv_vars)->b = b / 255.0;
#endif

d1049 6
d1061 1
a1061 1
    bu_log("width = %d, height = %d", dmp->dm_width, dmp->dm_height);
@


1.43
log
@*- fixed typo
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-X.c,v 1.42 1999/12/29 20:47:51 jra Exp $ (BRL)";
a299 2

  Tk_ScreenNumber(((struct dm_xvars *)dmp->dm_vars.pub_vars)->top);
@


1.42
log
@Eliminated unused variables
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-X.c,v 1.41 1999/12/27 21:10:48 bparker Exp $ (BRL)";
d301 1
a301 1
  k_ScreenNumber(((struct dm_xvars *)dmp->dm_vars.pub_vars)->top);
@


1.41
log
@*- mods reflecting new members of "struct dm"
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-X.c,v 1.40 1999/12/17 16:38:46 bparker Exp $ (BRL)";
d150 1
a150 2
  int i, j, k;
  int a_screen;
a152 3
  XColor a_color;
  Visual *a_visual;
  Colormap  a_cmap;
a160 1
  Display *tmp_dpy;
d187 1
a187 1
  i = dm_processOptions(dmp, &init_proc_vls, --argc, ++argv);
d301 1
a301 1
  a_screen = Tk_ScreenNumber(((struct dm_xvars *)dmp->dm_vars.pub_vars)->top);
a581 1
    XGCValues gcv;
@


1.40
log
@*- mods to reflect new member (dm_perspective) of struct dm
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-X.c,v 1.39 1999/12/01 13:32:08 bparker Exp $ (BRL)";
a55 1
void     X_configureWindowShape();
d57 4
a60 4
static void	label();
static void	draw();
static void     x_var_init();
static XVisualInfo *X_choose_visual();
d66 13
a78 10
static int	X_close();
static int	X_drawBegin(), X_drawEnd();
static int	X_normal(), X_loadMatrix();
static int      X_drawString2D();
static int	X_drawLine2D();
static int      X_drawPoint2D();
static int	X_drawVList();
static int      X_setFGColor(), X_setBGColor();
static int	X_setLineAttr();
static int	X_setWinBounds(), X_debug();
d93 1
d95 2
d127 2
d430 1
a430 1
  X_configureWindowShape(dmp);
d447 1
a447 1
static int
d486 1
a486 1
static int
d518 1
a518 1
static int
d545 1
a545 1
static int
d578 1
a578 1
static int
d816 1
a816 1
static int
d833 1
a833 1
static int
d866 1
a866 1
static int
d895 1
a895 1
static int
d918 1
a918 1
static int
d958 1
a958 1
static int
d993 1
a993 1
static int
d1023 1
a1023 1
static int
d1035 1
a1035 1
static int
d1053 2
a1054 2
void
X_configureWindowShape(dmp)
d1068 1
a1068 1
    bu_log("X_configureWindowShape()\n");
d1089 1
a1089 1
	return;
d1162 28
d1192 1
a1192 1
static XVisualInfo *
d1274 1
a1274 1
      return NULL; /* failure */
@


1.39
log
@*- mods to reflect changes to struct dm
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-X.c,v 1.38 1999/11/03 14:28:18 bparker Exp $ (BRL)";
d121 1
d572 1
a572 1
X_drawVList( dmp, vp, perspective )
a574 1
double perspective;
d588 1
a588 1
      bu_log("vp - %lu, perspective - %g\n", vp, perspective);
d627 1
a627 1
		if( perspective > 0.0 )
d662 1
a662 1
		if( perspective > 0.0 )
@


1.38
log
@*- remove code that sets the visual of the toplevel
   window. If this needs to be done, it shouldn't
   be done here.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-X.c,v 1.37 1999/11/02 14:56:17 bparker Exp $ (BRL)";
d74 1
a74 1
static int      X_setFGColor(), X_setBGColor(), X_getBGColor();
a89 1
  X_getBGColor,
d100 2
a101 1
  PLOTBOUND,
d115 7
a121 1
  0
a129 2
static mat_t xmat;

a207 3
  /* initialize modifiable variables */
  ((struct x_vars *)dmp->dm_vars.priv_vars)->mvars.zclip = 1;

d429 1
a429 1
  bn_mat_idn(xmat);
d476 1
a476 3
 *			X _ P R O L O G
 *
 * There are global variables which are parameters to this routine.
d484 1
a484 1
  if (((struct x_vars *)dmp->dm_vars.priv_vars)->mvars.debug)
d498 6
d514 1
a514 1
  if (((struct x_vars *)dmp->dm_vars.priv_vars)->mvars.debug)
d522 1
a522 1
	    dmp->dm_height, 0, 0);
d543 1
a543 1
  if(((struct x_vars *)dmp->dm_vars.priv_vars)->mvars.debug){
d561 1
a561 1
  bn_mat_copy(xmat, mat);
d586 1
a586 1
    if(((struct x_vars *)dmp->dm_vars.priv_vars)->mvars.debug)
d588 2
d595 1
a595 1
    delta = xmat[15]*0.0001;
d622 1
a622 1
		if(((struct x_vars *)dmp->dm_vars.priv_vars)->mvars.debug){
d632 1
a632 1
	    		dist = VDOT( *pt, &xmat[12] ) + xmat[15];
d641 1
a641 1
	    			MAT4X3PNT( lpnt, xmat, *pt );
d647 1
a647 1
			MAT4X3PNT( lpnt, xmat, *pt );
d657 1
a657 1
		if(((struct x_vars *)dmp->dm_vars.priv_vars)->mvars.debug){
d667 2
a668 2
	    		dist = VDOT( *pt, &xmat[12] ) + xmat[15];
			if(((struct x_vars *)dmp->dm_vars.priv_vars)->mvars.debug )
d689 1
a689 1
	    				MAT4X3PNT( pnt, xmat, tmp_pt );
d704 1
a704 1
	    				MAT4X3PNT( lpnt, xmat, tmp_pt );
d708 1
a708 1
	    				MAT4X3PNT( pnt, xmat, *pt );
d712 1
a712 1
	    				MAT4X3PNT( pnt, xmat, *pt );
d717 1
a717 1
			MAT4X3PNT( pnt, xmat, *pt );
d728 1
a728 1
		if(((struct x_vars *)dmp->dm_vars.priv_vars)->mvars.debug) {
d731 3
a733 3
			 ((struct x_vars *)dmp->dm_vars.priv_vars)->clipmin[X],
			 ((struct x_vars *)dmp->dm_vars.priv_vars)->clipmin[Y],
			 ((struct x_vars *)dmp->dm_vars.priv_vars)->clipmin[Z]);
d735 3
a737 3
			 ((struct x_vars *)dmp->dm_vars.priv_vars)->clipmax[X],
			 ((struct x_vars *)dmp->dm_vars.priv_vars)->clipmax[Y],
			 ((struct x_vars *)dmp->dm_vars.priv_vars)->clipmax[Z]);
d742 1
a742 1
		if(((struct x_vars *)dmp->dm_vars.priv_vars)->mvars.zclip){
d744 2
a745 2
			   ((struct x_vars *)dmp->dm_vars.priv_vars)->clipmin,
			   ((struct x_vars *)dmp->dm_vars.priv_vars)->clipmax) == 0){
d766 1
a766 1
		if(((struct x_vars *)dmp->dm_vars.priv_vars)->mvars.debug) {
d813 1
a813 1
  if (((struct x_vars *)dmp->dm_vars.priv_vars)->mvars.debug)
d836 1
a836 1
  if (((struct x_vars *)dmp->dm_vars.priv_vars)->mvars.debug){
d839 2
a840 2
    bu_log("\tx - %lf\n", x);
    bu_log("\ty - %lf\n", y);
d843 1
a843 1
      bu_log("\tuse_aspect - %d\t\taspect ratio - %lf\n", use_aspect, dmp->dm_aspect);
a866 3
  if (((struct x_vars *)dmp->dm_vars.priv_vars)->mvars.debug)
    bu_log("X_drawLine2D()\n");

d872 8
a894 3
  if (((struct x_vars *)dmp->dm_vars.priv_vars)->mvars.debug)
    bu_log("X_drawPoint2D()\n");

d898 6
d914 1
a914 1
register short r, g, b;
d919 1
a919 1
  if (((struct x_vars *)dmp->dm_vars.priv_vars)->mvars.debug)
d922 4
d937 2
a938 1
    gcv.foreground = dm_get_pixel(r, g, b, ((struct x_vars *)dmp->dm_vars.priv_vars)->pixels,
d941 3
d954 1
a954 1
int r, g, b;
d956 1
a956 1
  if (((struct x_vars *)dmp->dm_vars.priv_vars)->mvars.debug)
d959 5
d967 1
a986 18
X_getBGColor(dmp, interp)
struct dm *dmp;
Tcl_Interp *interp;
{
  struct bu_vls vls;

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "%d %d %d",
		(int)(((struct x_vars *)dmp->dm_vars.priv_vars)->r * 255.0),
		(int)(((struct x_vars *)dmp->dm_vars.priv_vars)->g * 255.0),
		(int)(((struct x_vars *)dmp->dm_vars.priv_vars)->b * 255.0));
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  bu_vls_free(&vls);

  return TCL_OK;
}

static int
d994 1
a994 1
  if (((struct x_vars *)dmp->dm_vars.priv_vars)->mvars.debug)
d1021 1
a1021 1
  ((struct x_vars *)dmp->dm_vars.priv_vars)->mvars.debug = lvl;
d1033 1
a1033 1
  if (((struct x_vars *)dmp->dm_vars.priv_vars)->mvars.debug)
d1036 6
a1041 6
  ((struct x_vars *)dmp->dm_vars.priv_vars)->clipmin[0] = w[0];
  ((struct x_vars *)dmp->dm_vars.priv_vars)->clipmin[1] = w[2];
  ((struct x_vars *)dmp->dm_vars.priv_vars)->clipmin[2] = w[4];
  ((struct x_vars *)dmp->dm_vars.priv_vars)->clipmax[0] = w[1];
  ((struct x_vars *)dmp->dm_vars.priv_vars)->clipmax[1] = w[3];
  ((struct x_vars *)dmp->dm_vars.priv_vars)->clipmax[2] = w[5];
a1053 3
  if (((struct x_vars *)dmp->dm_vars.priv_vars)->mvars.debug)
    bu_log("X_configureWindowShape()\n");

d1059 5
@


1.37
log
@*- turn off test code in X_choose_visual
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-X.c,v 1.36 1999/11/02 14:11:03 bparker Exp $ (BRL)";
d294 1
a294 1
  XSynchronize(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy, TRUE);
a1212 13

	if (!dmp->dm_top) {
	  /*
	   * Try to set the visual of the toplevel window to be the same
	   * as the display manager window . This seems to be necessary
	   * to avoid the case where the toplevel window's colormap gets
	   * swapped in and hoses things up.
	   */
	  Tk_SetWindowVisual(((struct dm_xvars *)dmp->dm_vars.pub_vars)->top,
			     maxvip->visual,
			     maxvip->depth,
			     ((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap);
	}
@


1.36
log
@*- mods to X_choose_visual
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-X.c,v 1.35 1998/06/15 18:55:05 bparker Exp $ (BRL)";
d1160 1
a1160 1
#if 1
@


1.35
log
@*- add support for new routines:
	dm_setFGColor(), dm_setBGColor(), dm_getBGColor()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/libdm/dm-X.c,v 1.34 1998/06/12 19:48:17 bparker Exp $ (BRL)";
a151 1
  struct bu_vls top_vls;
a208 1
  bu_vls_init(&top_vls);
a214 1
    bu_vls_printf(&top_vls, "%S", &dmp->dm_pathName);
a220 1
      bu_vls_strcpy(&top_vls, ".");
d222 3
d229 1
a231 2
    bu_vls_free(&top_vls);

a305 2
  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->depth = ((struct dm_xvars *)dmp->dm_vars.pub_vars)->vip->depth;

d340 8
a347 6
    ((struct x_vars *)dmp->dm_vars.priv_vars)->bg = dm_get_pixel(DM_BLACK,
						       ((struct x_vars *)dmp->dm_vars.priv_vars)->pixels,
						       CUBE_DIMENSION);
    ((struct x_vars *)dmp->dm_vars.priv_vars)->fg = dm_get_pixel(DM_RED,
						       ((struct x_vars *)dmp->dm_vars.priv_vars)->pixels,
						       CUBE_DIMENSION);
d452 1
a452 1
    if(((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap)
d1153 1
d1155 2
a1156 1
  vibase = XGetVisualInfo(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy, 0, &vitemp, &num);
d1158 1
a1158 1
  while(1){
d1160 7
d1168 4
a1171 2
      if(desire_trueColor){
	if(vip->class != TrueColor)
d1175 1
d1193 5
a1197 2
	((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap = XCreateColormap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy, RootWindow(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy, maxvip->screen),
								maxvip->visual, AllocNone);
d1200 5
a1204 2
	((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap = XCreateColormap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy, RootWindow(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy, maxvip->screen),
								maxvip->visual, AllocAll);
d1208 4
a1211 2
      if (Tk_SetWindowVisual(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin, maxvip->visual,
			     maxvip->depth, ((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap)){
d1213 14
d1231 2
a1232 1
	XFreeColormap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy, ((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap);
@


1.34
log
@*- change _setColor() to _setFGColor()
*- add _setBGColor()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/libdm/dm-X.c,v 1.33 1998/06/11 14:30:26 bparker Exp $ (BRL)";
d74 1
a74 1
static int      X_setFGColor(), X_setBGColor();
d90 1
d938 4
d955 18
@


1.33
log
@*- remove the following ifdef: USE_RT_ASPECT
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/libdm/dm-X.c,v 1.32 1998/03/03 14:59:13 jra Exp $ (BRL)";
d74 2
a75 1
static int      X_setColor(), X_setLineAttr();
d88 2
a89 1
  X_setColor,
d898 1
a898 1
X_setColor(dmp, r, g, b, strict)
d906 1
a906 1
    bu_log("X_setColor()\n");
d930 25
a1185 4




@


1.32
log
@Fixed clipping in perspective mode.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.31 1998/03/02 14:06:19 bparker Exp jra $ (BRL)";
a640 1
#ifdef USE_RT_ASPECT
a642 4
#else
		lpnt[0] *= 2047 * dmp->dm_aspect;
		lpnt[1] *= 2047;
#endif
a710 1
#ifdef USE_RT_ASPECT
a712 4
#else
		pnt[0] *= 2047 * dmp->dm_aspect;
		pnt[1] *= 2047;
#endif
a839 1
#ifdef USE_RT_ASPECT
a841 4
#else
  sx = dm_Normal2Xx(dmp, x, use_aspect);
  sy = dm_Normal2Xy(dmp, y);
#endif
d862 4
a865 4
  sx1 = dm_Normal2Xx(dmp, x1, 0);
  sx2 = dm_Normal2Xx(dmp, x2, 0);
  sy1 = dm_Normal2Xy(dmp, y1);
  sy2 = dm_Normal2Xy(dmp, y2);
d885 2
a886 2
  sx = dm_Normal2Xx(dmp, x, 0);
  sy = dm_Normal2Xy(dmp, y);
a1001 1
#ifdef USE_RT_ASPECT
a1002 5
#else
  dmp->dm_aspect =
    (fastf_t)dmp->dm_height /
    (fastf_t)dmp->dm_width;
#endif
@


1.31
log
@*- changed aspect to width/height
*- added debug statements
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.30 1998/02/26 15:11:18 bparker Exp bparker $ (BRL)";
a563 1
/* ARGSUSED */
d565 1
a565 1
X_drawVList( dmp, vp )
d568 1
d576 3
d583 10
d600 1
d619 21
a639 6
		MAT4X3PNT( lpnt, xmat, *pt );
#if 0
		if( lpnt[0] < -1e6 || lpnt[0] > 1e6 ||
		    lpnt[1] < -1e6 || lpnt[1] > 1e6 )
		  continue; /* omit this point (ugh) */
#endif
d659 56
a714 6
		MAT4X3PNT( pnt, xmat, *pt );
#if 0
		if( pnt[0] < -1e6 || pnt[0] > 1e6 ||
		    pnt[1] < -1e6 || pnt[1] > 1e6 )
		  continue; /* omit this point (ugh) */
#endif
d727 2
d730 1
a730 1
		if(((struct x_vars *)dmp->dm_vars.priv_vars)->mvars.debug){
d768 1
a768 1
		if(((struct x_vars *)dmp->dm_vars.priv_vars)->mvars.debug){
@


1.30
log
@*- mods to X_drawPoint2D(), X_drawLine2D() and X_drawString2D
	to use floats instead of ints for x/y parameters
*- use new dm_vars structure
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.29 1998/01/05 20:27:38 bparker Exp bparker $ (BRL)";
d238 1
a238 3
    Tcl_AppendResult(interp, "dm-X: Failed to open ",
		     bu_vls_addr(&dmp->dm_pathName),
		     "\n", (char *)NULL);
d300 1
a300 1
    Tcl_AppendResult(interp, "X_open: Can't get an appropriate visual.\n", (char *)NULL);
d380 1
a380 3
	  Tcl_AppendResult(interp,
			   "X_open: Couldn't open the dials+buttons\n",
			   (char *)NULL);
d485 1
a485 1
    Tcl_AppendResult(interp, "X_drawBegin()\n", (char *)NULL);
d509 1
a509 1
    Tcl_AppendResult(interp, "X_drawEnd()\n", (char *)NULL);
d538 1
a538 1
    struct bu_vls tmp_vls;
d540 13
a552 12
    Tcl_AppendResult(interp, "X_loadMatrix()\n", (char *)NULL);

    bu_vls_init(&tmp_vls);
    bu_vls_printf(&tmp_vls, "which eye = %d\t", which_eye);
    bu_vls_printf(&tmp_vls, "transformation matrix = \n");
    bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[0], mat[4], mat[8],mat[12]);
    bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[1], mat[5], mat[9],mat[13]);
    bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[2], mat[6], mat[10],mat[14]);
    bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[3], mat[7], mat[11],mat[15]);

    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
    bu_vls_free(&tmp_vls);
d577 2
a578 2
    if (((struct x_vars *)dmp->dm_vars.priv_vars)->mvars.debug)
      Tcl_AppendResult(interp, "X_drawVList()\n", (char *)NULL);
d600 5
d612 4
d618 1
d625 5
d637 4
d643 1
d649 14
d687 6
d735 1
a735 1
    Tcl_AppendResult(interp, "X_normal()\n", (char *)NULL);
d769 4
d775 1
d794 1
a794 1
    Tcl_AppendResult(interp, "X_drawLine2D()\n", (char *)NULL);
d817 1
a817 1
    Tcl_AppendResult(interp, "X_drawPoint2D()\n", (char *)NULL);
d838 1
a838 1
    Tcl_AppendResult(interp, "X_setColor()\n", (char *)NULL);
d870 1
a870 1
    Tcl_AppendResult(interp, "X_setLineAttr()\n", (char *)NULL);
d898 1
a898 1
  Tcl_AppendResult(interp, "flushed\n", (char *)NULL);
d909 1
a909 1
    Tcl_AppendResult(interp, "X_setWinBounds()\n", (char *)NULL);
d930 1
a930 1
    Tcl_AppendResult(interp, "X_configureWindowShape()\n", (char *)NULL);
d936 3
d942 1
d960 1
a960 2
	Tcl_AppendResult(interp, "dm-X: Can't open font '", FONT9,
			 "' or '", FONTBACK, "'\n", (char *)NULL);
@


1.29
log
@save XVisualInfo *
@
text
@d4 1
a4 2
 *  An X Window System interface for MGED.
 *  X11R2.  Color support is yet to be implemented.
d8 1
d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.28 1997/12/16 14:50:47 bparker Exp bparker $ (BRL)";
d53 1
d61 1
a61 1
static XVisualInfo *X_set_visual();
d109 1
a111 1
  0,
a120 1
struct x_vars head_x_vars;
d160 4
a163 4
  /* Only need to do this once for this display manager */
  if(!count){
    bzero((void *)&head_x_vars, sizeof(struct x_vars));
    BU_LIST_INIT( &head_x_vars.l );
d166 3
a168 2
  dmp->dm_vars = (genptr_t)bu_calloc(1, sizeof(struct x_vars), "X_open: x_vars");
  if(dmp->dm_vars == (genptr_t)NULL){
d197 3
a199 3
  ((struct x_vars *)dmp->dm_vars)->devmotionnotify = LASTEvent;
  ((struct x_vars *)dmp->dm_vars)->devbuttonpress = LASTEvent;
  ((struct x_vars *)dmp->dm_vars)->devbuttonrelease = LASTEvent;
d203 1
a203 1
  ((struct x_vars *)dmp->dm_vars)->mvars.zclip = 1;
d205 1
a205 1
  BU_LIST_APPEND(&head_x_vars.l, &((struct x_vars *)dmp->dm_vars)->l);
a206 2
  ((struct x_vars *)dmp->dm_vars)->fontstruct = NULL;

d210 1
a210 1
    ((struct x_vars *)dmp->dm_vars)->xtkwin = Tk_CreateWindowFromPath(interp, tkwin,
d213 1
a213 1
    ((struct x_vars *)dmp->dm_vars)->top = ((struct x_vars *)dmp->dm_vars)->xtkwin;
d220 1
a220 1
      ((struct x_vars *)dmp->dm_vars)->top = tkwin;
d225 1
a225 1
      ((struct x_vars *)dmp->dm_vars)->top =
d232 2
a233 2
    ((struct x_vars *)dmp->dm_vars)->xtkwin =
      Tk_CreateWindow(interp, ((struct x_vars *)dmp->dm_vars)->top,
d237 1
a237 1
  if(((struct x_vars *)dmp->dm_vars)->xtkwin == NULL){
d246 1
a246 1
		(char *)Tk_Name(((struct x_vars *)dmp->dm_vars)->xtkwin));
d263 2
a264 2
  ((struct x_vars *)dmp->dm_vars)->dpy =
    Tk_Display(((struct x_vars *)dmp->dm_vars)->top);
d268 2
a269 2
      DisplayWidth(((struct x_vars *)dmp->dm_vars)->dpy,
		   DefaultScreen(((struct x_vars *)dmp->dm_vars)->dpy)) - 30;
d275 2
a276 2
      DisplayHeight(((struct x_vars *)dmp->dm_vars)->dpy,
		    DefaultScreen(((struct x_vars *)dmp->dm_vars)->dpy)) - 30;
d289 1
a289 1
  Tk_GeometryRequest(((struct x_vars *)dmp->dm_vars)->xtkwin,
d295 1
a295 1
  XSynchronize(((struct x_vars *)dmp->dm_vars)->dpy, TRUE);
d298 1
a298 1
  a_screen = Tk_ScreenNumber(((struct x_vars *)dmp->dm_vars)->top);
d301 1
a301 1
  if((((struct x_vars *)dmp->dm_vars)->vip = X_set_visual(dmp)) == NULL){
d307 1
a307 1
  ((struct x_vars *)dmp->dm_vars)->depth = ((struct x_vars *)dmp->dm_vars)->vip->depth;
d309 8
a316 8
  Tk_MakeWindowExist(((struct x_vars *)dmp->dm_vars)->xtkwin);
  ((struct x_vars *)dmp->dm_vars)->win =
      Tk_WindowId(((struct x_vars *)dmp->dm_vars)->xtkwin);
  dmp->dm_id = ((struct x_vars *)dmp->dm_vars)->win;

  ((struct x_vars *)dmp->dm_vars)->pix =
    Tk_GetPixmap(((struct x_vars *)dmp->dm_vars)->dpy,
		 DefaultRootWindow(((struct x_vars *)dmp->dm_vars)->dpy),
d319 1
a319 1
		 Tk_Depth(((struct x_vars *)dmp->dm_vars)->xtkwin));
d321 1
a321 1
  if(((struct x_vars *)dmp->dm_vars)->is_trueColor){
d326 2
a327 2
    XAllocColor(((struct x_vars *)dmp->dm_vars)->dpy,
		((struct x_vars *)dmp->dm_vars)->cmap,
d329 1
a329 1
    ((struct x_vars *)dmp->dm_vars)->fg = fg.pixel;
d332 2
a333 2
    XAllocColor(((struct x_vars *)dmp->dm_vars)->dpy,
		((struct x_vars *)dmp->dm_vars)->cmap,
d335 1
a335 1
    ((struct x_vars *)dmp->dm_vars)->bg = bg.pixel;
d337 3
a339 3
    dm_allocate_color_cube( ((struct x_vars *)dmp->dm_vars)->dpy,
			    ((struct x_vars *)dmp->dm_vars)->cmap,
			    ((struct x_vars *)dmp->dm_vars)->pixels,
d343 2
a344 2
    ((struct x_vars *)dmp->dm_vars)->bg = dm_get_pixel(DM_BLACK,
						       ((struct x_vars *)dmp->dm_vars)->pixels,
d346 2
a347 2
    ((struct x_vars *)dmp->dm_vars)->fg = dm_get_pixel(DM_RED,
						       ((struct x_vars *)dmp->dm_vars)->pixels,
d351 4
a354 4
  gcv.background = ((struct x_vars *)dmp->dm_vars)->bg;
  gcv.foreground = ((struct x_vars *)dmp->dm_vars)->fg;
  ((struct x_vars *)dmp->dm_vars)->gc = XCreateGC(((struct x_vars *)dmp->dm_vars)->dpy,
						  ((struct x_vars *)dmp->dm_vars)->win,
d361 1
a361 1
    if(!XQueryExtension(((struct x_vars *)dmp->dm_vars)->dpy,
d371 1
a371 1
    (XDeviceInfoPtr)XListInputDevices(((struct x_vars *)dmp->dm_vars)->dpy,
d380 1
a380 1
	if((dev = XOpenDevice(((struct x_vars *)dmp->dm_vars)->dpy,
d393 1
a393 1
	    DeviceButtonPress(dev, ((struct x_vars *)dmp->dm_vars)->devbuttonpress,
d396 1
a396 1
	    DeviceButtonRelease(dev, ((struct x_vars *)dmp->dm_vars)->devbuttonrelease,
d403 1
a403 1
	    DeviceMotionNotify(dev, ((struct x_vars *)dmp->dm_vars)->devmotionnotify,
d413 2
a414 2
	XSelectExtensionEvent(((struct x_vars *)dmp->dm_vars)->dpy,
			      ((struct x_vars *)dmp->dm_vars)->win, e_class, nclass);
d427 3
a429 3
  Tk_SetWindowBackground(((struct x_vars *)dmp->dm_vars)->xtkwin,
			 ((struct x_vars *)dmp->dm_vars)->bg);
  Tk_MapWindow(((struct x_vars *)dmp->dm_vars)->xtkwin);
d445 8
a452 8
  if(((struct x_vars *)dmp->dm_vars)->dpy){
    if(((struct x_vars *)dmp->dm_vars)->gc)
      XFreeGC(((struct x_vars *)dmp->dm_vars)->dpy,
	      ((struct x_vars *)dmp->dm_vars)->gc);

    if(((struct x_vars *)dmp->dm_vars)->pix)
      Tk_FreePixmap(((struct x_vars *)dmp->dm_vars)->dpy,
		    ((struct x_vars *)dmp->dm_vars)->pix);
d455 6
a460 3
    if(((struct x_vars *)dmp->dm_vars)->cmap)
      XFreeColormap(((struct x_vars *)dmp->dm_vars)->dpy,
		    ((struct x_vars *)dmp->dm_vars)->cmap);
d462 3
a464 2
    if(((struct x_vars *)dmp->dm_vars)->xtkwin)
      Tk_DestroyWindow(((struct x_vars *)dmp->dm_vars)->xtkwin);
a466 3
  if(((struct x_vars *)dmp->dm_vars)->l.forw != BU_LIST_NULL)
    BU_LIST_DEQUEUE(&((struct x_vars *)dmp->dm_vars)->l);

d470 2
a471 1
  bu_free(dmp->dm_vars, "X_close: x_vars");
d473 1
d488 1
a488 1
  if (((struct x_vars *)dmp->dm_vars)->mvars.debug)
d491 4
a494 3
  gcv.foreground = ((struct x_vars *)dmp->dm_vars)->bg;
  XChangeGC(((struct x_vars *)dmp->dm_vars)->dpy,
	    ((struct x_vars *)dmp->dm_vars)->gc,
d496 3
a498 3
  XFillRectangle(((struct x_vars *)dmp->dm_vars)->dpy,
		 ((struct x_vars *)dmp->dm_vars)->pix,
		 ((struct x_vars *)dmp->dm_vars)->gc, 0,
d512 1
a512 1
  if (((struct x_vars *)dmp->dm_vars)->mvars.debug)
d515 4
a518 4
  XCopyArea(((struct x_vars *)dmp->dm_vars)->dpy,
	    ((struct x_vars *)dmp->dm_vars)->pix,
	    ((struct x_vars *)dmp->dm_vars)->win,
	    ((struct x_vars *)dmp->dm_vars)->gc,
d523 1
a523 1
  XSync(((struct x_vars *)dmp->dm_vars)->dpy, 0);
d541 1
a541 1
  if(((struct x_vars *)dmp->dm_vars)->mvars.debug){
d580 1
a580 1
    if (((struct x_vars *)dmp->dm_vars)->mvars.debug)
d632 1
a632 1
		if(((struct x_vars *)dmp->dm_vars)->mvars.zclip){
d634 2
a635 2
			   ((struct x_vars *)dmp->dm_vars)->clipmin,
			   ((struct x_vars *)dmp->dm_vars)->clipmax) == 0){
d667 3
a669 3
		  XDrawSegments( ((struct x_vars *)dmp->dm_vars)->dpy,
				 ((struct x_vars *)dmp->dm_vars)->pix,
				 ((struct x_vars *)dmp->dm_vars)->gc, segbuf, nseg );
d679 3
a681 3
      XDrawSegments( ((struct x_vars *)dmp->dm_vars)->dpy,
		     ((struct x_vars *)dmp->dm_vars)->pix,
		     ((struct x_vars *)dmp->dm_vars)->gc, segbuf, nseg );
d697 1
a697 1
  if (((struct x_vars *)dmp->dm_vars)->mvars.debug)
d711 1
a711 1
X_drawString2D( dmp, str, x, y, size, use_aspect )
d714 1
a714 1
int x, y;
d718 1
a718 1
  int	sx, sy;
d720 11
a730 7
  if (((struct x_vars *)dmp->dm_vars)->mvars.debug)
    Tcl_AppendResult(interp, "X_drawString2D()\n", (char *)NULL);

  if(use_aspect)
    sx = GED_TO_Xx(dmp, x * dmp->dm_aspect);
  else
    sx = GED_TO_Xx(dmp, x );
d732 2
a733 1
  sy = GED_TO_Xy(dmp, y );
d735 3
a737 3
  XDrawString( ((struct x_vars *)dmp->dm_vars)->dpy,
	       ((struct x_vars *)dmp->dm_vars)->pix,
	       ((struct x_vars *)dmp->dm_vars)->gc,
d744 1
a744 1
X_drawLine2D( dmp, x1, y1, x2, y2 )
d746 2
a747 2
int x1, y1;
int x2, y2;
d751 1
a751 1
  if (((struct x_vars *)dmp->dm_vars)->mvars.debug)
d754 8
a761 8
  sx1 = GED_TO_Xx(dmp, x1);
  sy1 = GED_TO_Xy(dmp, y1);
  sx2 = GED_TO_Xx(dmp, x2);
  sy2 = GED_TO_Xy(dmp, y2);

  XDrawLine( ((struct x_vars *)dmp->dm_vars)->dpy,
	     ((struct x_vars *)dmp->dm_vars)->pix,
	     ((struct x_vars *)dmp->dm_vars)->gc,
d768 1
a768 1
X_drawPoint2D(dmp, x, y)
d770 1
a770 1
int x, y;
d774 1
a774 1
  if (((struct x_vars *)dmp->dm_vars)->mvars.debug)
d777 2
a778 2
  sx = GED_TO_Xx(dmp, x );
  sy = GED_TO_Xy(dmp, y );
d780 3
a782 3
  XDrawPoint( ((struct x_vars *)dmp->dm_vars)->dpy,
	      ((struct x_vars *)dmp->dm_vars)->pix,
	      ((struct x_vars *)dmp->dm_vars)->gc, sx, sy );
d795 1
a795 1
  if (((struct x_vars *)dmp->dm_vars)->mvars.debug)
d798 1
a798 1
  if(((struct x_vars *)dmp->dm_vars)->is_trueColor){
d804 2
a805 2
    XAllocColor(((struct x_vars *)dmp->dm_vars)->dpy,
		((struct x_vars *)dmp->dm_vars)->cmap,
d809 1
a809 1
    gcv.foreground = dm_get_pixel(r, g, b, ((struct x_vars *)dmp->dm_vars)->pixels,
d812 2
a813 2
  XChangeGC(((struct x_vars *)dmp->dm_vars)->dpy,
	    ((struct x_vars *)dmp->dm_vars)->gc,
d827 1
a827 1
  if (((struct x_vars *)dmp->dm_vars)->mvars.debug)
d841 2
a842 2
  XSetLineAttributes( ((struct x_vars *)dmp->dm_vars)->dpy,
		      ((struct x_vars *)dmp->dm_vars)->gc,
d854 2
a855 2
  ((struct x_vars *)dmp->dm_vars)->mvars.debug = lvl;
  XFlush(((struct x_vars *)dmp->dm_vars)->dpy);
d866 1
a866 1
  if (((struct x_vars *)dmp->dm_vars)->mvars.debug)
d869 6
a874 6
  ((struct x_vars *)dmp->dm_vars)->clipmin[0] = w[0];
  ((struct x_vars *)dmp->dm_vars)->clipmin[1] = w[2];
  ((struct x_vars *)dmp->dm_vars)->clipmin[2] = w[4];
  ((struct x_vars *)dmp->dm_vars)->clipmax[0] = w[1];
  ((struct x_vars *)dmp->dm_vars)->clipmax[1] = w[3];
  ((struct x_vars *)dmp->dm_vars)->clipmax[2] = w[5];
d887 1
a887 1
  if (((struct x_vars *)dmp->dm_vars)->mvars.debug)
d890 2
a891 2
  XGetWindowAttributes( ((struct x_vars *)dmp->dm_vars)->dpy,
			((struct x_vars *)dmp->dm_vars)->win, &xwa );
d898 5
a902 5
  Tk_FreePixmap(((struct x_vars *)dmp->dm_vars)->dpy,
		((struct x_vars *)dmp->dm_vars)->pix);
  ((struct x_vars *)dmp->dm_vars)->pix =
    Tk_GetPixmap(((struct x_vars *)dmp->dm_vars)->dpy,
		 DefaultRootWindow(((struct x_vars *)dmp->dm_vars)->dpy),
d905 1
a905 1
		 Tk_Depth(((struct x_vars *)dmp->dm_vars)->xtkwin));
d908 3
a910 3
  if (((struct x_vars *)dmp->dm_vars)->fontstruct == NULL) {
    if ((((struct x_vars *)dmp->dm_vars)->fontstruct =
	 XLoadQueryFont(((struct x_vars *)dmp->dm_vars)->dpy, FONT9)) == NULL ) {
d912 2
a913 2
      if ((((struct x_vars *)dmp->dm_vars)->fontstruct =
	   XLoadQueryFont(((struct x_vars *)dmp->dm_vars)->dpy, FONTBACK)) == NULL) {
d920 3
a922 3
    gcv.font = ((struct x_vars *)dmp->dm_vars)->fontstruct->fid;
    XChangeGC(((struct x_vars *)dmp->dm_vars)->dpy,
	      ((struct x_vars *)dmp->dm_vars)->gc, GCFont, &gcv);
d929 2
a930 2
    if (((struct x_vars *)dmp->dm_vars)->fontstruct->per_char->width != 5) {
      if ((newfontstruct = XLoadQueryFont(((struct x_vars *)dmp->dm_vars)->dpy,
d932 6
a937 6
	XFreeFont(((struct x_vars *)dmp->dm_vars)->dpy,
		  ((struct x_vars *)dmp->dm_vars)->fontstruct);
	((struct x_vars *)dmp->dm_vars)->fontstruct = newfontstruct;
	gcv.font = ((struct x_vars *)dmp->dm_vars)->fontstruct->fid;
	XChangeGC(((struct x_vars *)dmp->dm_vars)->dpy,
		  ((struct x_vars *)dmp->dm_vars)->gc, GCFont, &gcv);
d941 2
a942 2
    if (((struct x_vars *)dmp->dm_vars)->fontstruct->per_char->width != 6){
      if ((newfontstruct = XLoadQueryFont(((struct x_vars *)dmp->dm_vars)->dpy,
d944 6
a949 6
	XFreeFont(((struct x_vars *)dmp->dm_vars)->dpy,
		  ((struct x_vars *)dmp->dm_vars)->fontstruct);
	((struct x_vars *)dmp->dm_vars)->fontstruct = newfontstruct;
	gcv.font = ((struct x_vars *)dmp->dm_vars)->fontstruct->fid;
	XChangeGC(((struct x_vars *)dmp->dm_vars)->dpy,
		  ((struct x_vars *)dmp->dm_vars)->gc, GCFont, &gcv);
d953 2
a954 2
    if (((struct x_vars *)dmp->dm_vars)->fontstruct->per_char->width != 7){
      if ((newfontstruct = XLoadQueryFont(((struct x_vars *)dmp->dm_vars)->dpy,
d956 6
a961 6
	XFreeFont(((struct x_vars *)dmp->dm_vars)->dpy,
		  ((struct x_vars *)dmp->dm_vars)->fontstruct);
	((struct x_vars *)dmp->dm_vars)->fontstruct = newfontstruct;
	gcv.font = ((struct x_vars *)dmp->dm_vars)->fontstruct->fid;
	XChangeGC(((struct x_vars *)dmp->dm_vars)->dpy,
		  ((struct x_vars *)dmp->dm_vars)->gc, GCFont, &gcv);
d965 2
a966 2
    if (((struct x_vars *)dmp->dm_vars)->fontstruct->per_char->width != 8){
      if ((newfontstruct = XLoadQueryFont(((struct x_vars *)dmp->dm_vars)->dpy,
d968 6
a973 6
	XFreeFont(((struct x_vars *)dmp->dm_vars)->dpy,
		  ((struct x_vars *)dmp->dm_vars)->fontstruct);
	((struct x_vars *)dmp->dm_vars)->fontstruct = newfontstruct;
	gcv.font = ((struct x_vars *)dmp->dm_vars)->fontstruct->fid;
	XChangeGC(((struct x_vars *)dmp->dm_vars)->dpy,
		  ((struct x_vars *)dmp->dm_vars)->gc, GCFont, &gcv);
d977 2
a978 2
    if (((struct x_vars *)dmp->dm_vars)->fontstruct->per_char->width != 9){
      if ((newfontstruct = XLoadQueryFont(((struct x_vars *)dmp->dm_vars)->dpy,
d980 6
a985 6
	XFreeFont(((struct x_vars *)dmp->dm_vars)->dpy,
		  ((struct x_vars *)dmp->dm_vars)->fontstruct);
	((struct x_vars *)dmp->dm_vars)->fontstruct = newfontstruct;
	gcv.font = ((struct x_vars *)dmp->dm_vars)->fontstruct->fid;
	XChangeGC(((struct x_vars *)dmp->dm_vars)->dpy,
		  ((struct x_vars *)dmp->dm_vars)->gc, GCFont, &gcv);
d991 2
a992 2
XVisualInfo *
X_set_visual(dmp)
d996 1
a996 1
  int good[40];
d1001 1
a1001 1
  vibase = XGetVisualInfo(((struct x_vars *)dmp->dm_vars)->dpy, 0, &vitemp, &num);
d1028 1
a1028 1
	((struct x_vars *)dmp->dm_vars)->cmap = XCreateColormap(((struct x_vars *)dmp->dm_vars)->dpy, RootWindow(((struct x_vars *)dmp->dm_vars)->dpy, maxvip->screen),
d1030 1
a1030 1
	((struct x_vars *)dmp->dm_vars)->is_trueColor = 1;
d1032 1
a1032 1
	((struct x_vars *)dmp->dm_vars)->cmap = XCreateColormap(((struct x_vars *)dmp->dm_vars)->dpy, RootWindow(((struct x_vars *)dmp->dm_vars)->dpy, maxvip->screen),
d1034 1
a1034 1
	((struct x_vars *)dmp->dm_vars)->is_trueColor = 0;
d1037 3
a1039 3
      if (Tk_SetWindowVisual(((struct x_vars *)dmp->dm_vars)->xtkwin, maxvip->visual,
			     maxvip->depth, ((struct x_vars *)dmp->dm_vars)->cmap)){
	((struct x_vars *)dmp->dm_vars)->depth = maxvip->depth;
d1044 1
a1044 1
	XFreeColormap(((struct x_vars *)dmp->dm_vars)->dpy, ((struct x_vars *)dmp->dm_vars)->cmap);
@


1.28
log
@mods to X_set_visual
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.27 1997/11/21 21:07:18 bparker Exp bparker $ (BRL)";
d60 1
a60 1
static int X_set_visual();
d302 1
a302 1
  if(X_set_visual(dmp) == 0){
d308 2
d983 1
a983 1
static int
d1032 1
a1032 1
	return 1; /* success */
d1043 1
a1043 1
      return(0); /* failure */
@


1.27
log
@*- query for XInputExtension
*- name changes and cleanup
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.26 1997/10/10 21:09:53 bparker Exp bparker $ (BRL)";
d996 4
a999 3
      if(desire_trueColor && vip->class != TrueColor)
	continue;
      else if (vip->class != PseudoColor)
@


1.26
log
@mods to support zclipping
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.25 1997/10/10 16:52:35 bparker Exp bparker $ (BRL)";
d55 1
a55 4
void     X_configure_window_shape();
void     X_establish_perspective();
void     X_set_perspective();
int      X_drawString2D();
d68 2
a69 1
static int	X_normal(), X_newrot();
d71 1
a71 1
static int      X_drawVertex2D();
d81 1
a81 1
  X_newrot,
d84 1
a84 1
  X_drawVertex2D,
a116 3
vect_t clipmin;
vect_t clipmax;

a120 1
static int perspective_table[] = { 30, 45, 60, 90 };
d177 1
a177 1
  i = dm_process_options(dmp, &init_proc_vls, --argc, ++argv);
d180 1
a180 1
    bu_vls_printf(&dmp->dm_pathName, ".dm_x%d", count);
d196 3
a198 1
  ((struct x_vars *)dmp->dm_vars)->perspective_angle = 3;
a202 1
  ((struct x_vars *)dmp->dm_vars)->mvars.dummy_perspective = 1;
d270 1
a270 1
		   DefaultScreen(((struct x_vars *)dmp->dm_vars)->dpy)) - 20;
d277 1
a277 1
		    DefaultScreen(((struct x_vars *)dmp->dm_vars)->dpy)) - 20;
a300 2
  Tcl_AppendResult(interp, "X_open: begin synchronous execution\n", (char *)NULL);

d356 9
d382 1
a382 1
			   "Glx_open: Couldn't open the dials+buttons\n",
d421 1
d423 1
a423 1
  X_configure_window_shape(dmp);
d484 3
d507 3
d524 4
a527 2
 *  			X _ N E W R O T
 *  Stub.
d531 1
a531 1
X_newrot(dmp, mat, which_eye)
d536 17
a559 1
 *  Returns 0 if object could be drawn, !0 if object was omitted.
d575 3
d599 1
d601 4
a604 2
		   lpnt[1] < -1e6 || lpnt[1] > 1e6 )
		    continue; /* omit this point (ugh) */
d607 1
d614 1
d616 3
a618 2
		   pnt[1] < -1e6 || pnt[1] > 1e6 )
		    continue; /* omit this point (ugh) */
d628 3
a630 1
		  if(vclip(lpnt, pnt, clipmin, clipmax) == 0){
a642 1

a686 1
 * Turns off windowing.
d692 3
d705 1
a705 1
int
d715 3
d741 3
d758 1
a758 1
X_drawVertex2D(dmp, x, y)
d764 3
d785 3
d817 3
d842 1
d844 1
d854 1
a854 1
register int w[];
d856 2
a857 6
  clipmin[0] = w[1];
  clipmin[1] = w[3];
  clipmin[2] = w[5];
  clipmax[0] = w[0];
  clipmax[1] = w[2];
  clipmax[2] = w[4];
d859 7
d870 1
a870 1
X_configure_window_shape(dmp)
d877 3
a978 51
}

void
X_establish_perspective(dmp)
struct dm *dmp;
{
  struct bu_vls vls;

  bu_vls_init(&vls);
  bu_vls_printf( &vls, "set perspective %d\n",
		 ((struct x_vars *)dmp->dm_vars)->mvars.perspective_mode ?
		 perspective_table[((struct x_vars *)dmp->dm_vars)->perspective_angle] :
		 -1 );

  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
}

/*
   This routine will toggle the perspective_angle if the
   dummy_perspective value is 0 or less. Otherwise, the
   perspective_angle is set to the value of (dummy_perspective - 1).
*/
void
X_set_perspective(dmp)
struct dm *dmp;
{
  /* set perspective matrix */
  if(((struct x_vars *)dmp->dm_vars)->mvars.dummy_perspective > 0)
    ((struct x_vars *)dmp->dm_vars)->perspective_angle =
      ((struct x_vars *)dmp->dm_vars)->mvars.dummy_perspective <= 4 ?
      ((struct x_vars *)dmp->dm_vars)->mvars.dummy_perspective - 1: 3;
  else if (--((struct x_vars *)dmp->dm_vars)->perspective_angle < 0) /* toggle perspective matrix */
    ((struct x_vars *)dmp->dm_vars)->perspective_angle = 3;

  if(((struct x_vars *)dmp->dm_vars)->mvars.perspective_mode){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "set perspective %d\n",
		  perspective_table[((struct x_vars *)dmp->dm_vars)->perspective_angle]);

    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
  }

  /*
     Just in case the "!" is used with the set command. This
     allows us to toggle through more than two values.
   */
  ((struct x_vars *)dmp->dm_vars)->mvars.dummy_perspective = 1;
@


1.25
log
@add support for dials+buttons (for consistency)
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.24 1997/10/10 12:57:31 bparker Exp bparker $ (BRL)";
d119 3
d206 1
d586 1
d591 13
a603 7
		/* Check to see if lpnt or pnt contain values that exceed
		   the capacity of a short (segbuf is an array of XSegments which
		   contain shorts). If so, do clipping now. Otherwise, let the
		   X server do the clipping */
		if(lpnt[0] < min_short || max_short < lpnt[0] ||
		   lpnt[1] < min_short || max_short < lpnt[1] ||
		   pnt[0] < min_short || max_short < pnt[0] ||
d606 5
a610 4
		  /* if the entire line segment will not be visible then ignore it */
		  if(clip(&lpnt[0], &lpnt[1], &pnt[0], &pnt[1]) == -1){
		    VMOVE(lpnt, spnt);
		    continue;
d800 6
a805 9
#if 0
  /* Compute the clipping bounds */
  clipmin[0] = w[1] / 2048.;
  clipmin[1] = w[3] / 2048.;
  clipmin[2] = w[5] / 2048.;
  clipmax[0] = w[0] / 2047.;
  clipmax[1] = w[2] / 2047.;
  clipmax[2] = w[4] / 2047.;
#endif
@


1.24
log
@*- got rid of eventHandler
*- initialize dm_id (new member of "struct dm")
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.23 1997/10/09 14:08:45 bparker Exp bparker $ (BRL)";
d38 1
d138 1
a138 1
  int i;
d145 6
d358 56
@


1.23
log
@oops! forgot to remove a print statement :-)
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.22 1997/10/09 14:06:11 bparker Exp bparker $ (BRL)";
d95 1
a95 1
  Nu_int0,
d132 1
a132 2
X_open(eventHandler, argc, argv)
int (*eventHandler)();
a154 1
  dmp->dm_eventHandler = eventHandler;
a197 7
#if 0  
  if(BU_LIST_IS_EMPTY(&head_x_vars.l))
#else
  if(dmp->dm_eventHandler != DM_EVENT_HANDLER_NULL)
#endif
    Tk_CreateGenericHandler(dmp->dm_eventHandler, (ClientData)DM_TYPE_X);

a303 2
  Tcl_AppendResult(interp, "X_open: end synchronous execution\n", (char *)NULL);

d307 1
a389 3

    if(BU_LIST_IS_EMPTY(&head_x_vars.l))
      Tk_DeleteGenericHandler(dmp->dm_eventHandler, (ClientData)DM_TYPE_X);
@


1.22
log
@add support for TrueColor
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.21 1997/09/23 21:17:14 bparker Exp bparker $ (BRL)";
a149 3

fprintf(stderr, "X_open: enter\n");
fflush(stderr);
@


1.21
log
@mods to X_newrot() and X_drawVList()
.,
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.20 1997/08/20 20:33:19 bparker Exp bparker $ (BRL)";
d151 3
d301 1
a301 1
  /*XXX*/
d307 2
d310 1
a310 4
  if(X_set_visual(((struct x_vars *)dmp->dm_vars)->dpy,
		  ((struct x_vars *)dmp->dm_vars)->xtkwin,
		  &((struct x_vars *)dmp->dm_vars)->cmap,
		  &((struct x_vars *)dmp->dm_vars)->depth) == 0){
d316 2
d329 30
a358 13
  dm_allocate_color_cube( ((struct x_vars *)dmp->dm_vars)->dpy,
			  ((struct x_vars *)dmp->dm_vars)->cmap,
			  ((struct x_vars *)dmp->dm_vars)->pixels,
			  /* cube dimension, uses XStoreColor */
			  6, CMAP_BASE, 1 );

  ((struct x_vars *)dmp->dm_vars)->bg = dm_get_pixel(DM_BLACK,
				     ((struct x_vars *)dmp->dm_vars)->pixels,
						     CUBE_DIMENSION);
  ((struct x_vars *)dmp->dm_vars)->fg = dm_get_pixel(DM_RED,
				     ((struct x_vars *)dmp->dm_vars)->pixels,
						     CUBE_DIMENSION);
  
a669 1

d678 14
a691 2
  gcv.foreground = dm_get_pixel(r, g, b, ((struct x_vars *)dmp->dm_vars)->pixels,
				CUBE_DIMENSION);
d915 2
a916 5
X_set_visual(dpy, tkwin, cmap, depth)
Display *dpy;
Tk_Window tkwin;
Colormap *cmap;
int *depth;
d922 1
d924 1
a924 1
  vibase = XGetVisualInfo(dpy, 0, &vitemp, &num);
d926 10
a935 6
  for (i=0, j=0, vip=vibase; i<num; i++, vip++){
#if 1
    /* requirements */
    if (vip->class != PseudoColor) {
      /* if index mode, accept only read/write*/
      continue;
a936 5
#endif
			
    /* this visual meets criteria */
    good[j++] = i;
  }
d938 8
a945 11
  /* j = number of acceptable visuals under consideration */
  if(j < 1)
    return(0); /* failure */

  baddepth = 1000;
  for(tries = 0; tries < j; ++tries) {
    maxvip = vibase + good[0];
    for (i=1; i<j; i++) {
      vip = vibase + good[i];
      if ((vip->depth > maxvip->depth)&&(vip->depth < baddepth)){
	maxvip = vip;
a946 1
    }
d948 10
a957 3
    /* make sure Tk handles it */
    *cmap = XCreateColormap(dpy, RootWindow(dpy, maxvip->screen),
			    maxvip->visual, AllocAll);
d959 9
a967 7
    if (Tk_SetWindowVisual(tkwin, maxvip->visual, maxvip->depth, *cmap)){
      *depth = maxvip->depth;
      return 1; /* success */
    } else { 
      /* retry with lesser depth */
      baddepth = maxvip->depth;
      XFreeColormap(dpy, *cmap);
d969 5
a974 2

  return(0); /* failure */
@


1.20
log
@mods to properly do clipping
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.19 1997/08/01 21:33:03 bparker Exp bparker $ (BRL)";
d48 1
a74 1
static unsigned X_cvtvecs(), X_load();
a88 2
  X_cvtvecs,
  X_load,
d92 4
d97 1
a111 1
  0,
d123 1
d352 2
d448 1
a448 1
X_newrot(dmp, mat)
d451 1
d453 1
d465 1
a465 1
X_drawVList( dmp, vp, mat )
a467 1
mat_t mat;
d496 1
a496 1
		MAT4X3PNT( lpnt, mat, *pt );
d507 1
a507 1
		MAT4X3PNT( pnt, mat, *pt );
a690 21
}


/* ARGSUSED */
static unsigned
X_cvtvecs( dmp, sp )
struct dm *dmp;
struct solid *sp;
{
  return 0;
}

/*
 * Loads displaylist
 */
static unsigned
X_load( dmp, addr, count )
struct dm *dmp;
unsigned addr, count;
{
  return 0;
@


1.19
log
@mod to speed up X drawing
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.18 1997/05/21 13:03:30 bparker Exp bparker $ (BRL)";
d24 2
d113 3
d463 2
a464 2
    static vect_t   pnt;
    register struct rt_vlist	*tvp;
a468 3
    int	x, y;
    int	lastx = 0;
    int	lasty = 0;
d490 3
a492 3
		MAT4X3PNT( pnt, mat, *pt );
		if( pnt[0] < -1e6 || pnt[0] > 1e6 ||
		   pnt[1] < -1e6 || pnt[1] > 1e6 )
d494 2
a495 6
		pnt[0] *= 2047 * dmp->dm_aspect;
		pnt[1] *= 2047;
		x = GED_TO_Xx(dmp, pnt[0]);
		y = GED_TO_Xy(dmp, pnt[1]);
		lastx = x;
		lasty = y;
a505 2
		/* Integerize and let the X server do the clipping */

d508 3
a510 2
		x = GED_TO_Xx(dmp, pnt[0]);
		y = GED_TO_Xy(dmp, pnt[1]);
d512 22
a533 4
		segp->x1 = lastx;
		segp->y1 = lasty;
		segp->x2 = x;
		segp->y2 = y;
d536 2
a537 2
		lastx = x;
		lasty = y;
@


1.18
log
@mods to X_setLineAttr
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.17 1997/05/08 14:19:03 bparker Exp bparker $ (BRL)";
d657 2
a658 2
  if(width < 1)
    width = 1;
@


1.17
log
@mods to reflect change in "struct dm" --- added dm_type
                                      removed dm_open, dm_initWinProc
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.16 1997/04/24 18:14:07 bparker Exp bparker $ (BRL)";
d100 2
d647 1
a647 1
X_setLineAttr(dmp, width, dashed)
d650 1
a650 1
int dashed;
d652 1
a652 1
  int linestyle = LineSolid;
d654 2
a655 2
  if(dashed)
    linestyle = LineOnOffDash;
d659 5
@


1.16
log
@some cleanup
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.15 1997/04/23 18:35:31 bparker Exp bparker $ (BRL)";
d70 1
a70 1
static int	X_drawVlist();
a75 1
  X_open,
d84 1
a84 1
  X_drawVlist,
d94 3
a96 1
  "X", "X Window System (X11)",
a105 1
  0,
d137 1
d163 1
a163 1
  bu_vls_init(&dmp->dm_initWinProc);
d165 1
a165 5
  i = dm_process_options(dmp,
			 &dmp->dm_width,
			 &dmp->dm_height,
			 argc,
			 argv);
d180 2
a181 2
  if(bu_vls_strlen(&dmp->dm_initWinProc) == 0)
    bu_vls_strcpy(&dmp->dm_initWinProc, "bind_dm");
d244 1
a244 1
		&dmp->dm_initWinProc,
d254 1
a380 1
  bu_vls_free(&dmp->dm_initWinProc);
d451 1
a451 1
X_drawVlist( dmp, vp, mat )
@


1.15
log
@added some error checking; modified use of BU_GETSTRUCT
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.14 1997/04/22 15:05:48 bparker Exp bparker $ (BRL)";
d153 2
a154 2
  BU_GETSTRUCT(dmp->dm_vars, x_vars);
  if(dmp->dm_vars == (struct x_vars *)NULL){
d864 2
a865 2
     bu_vls_printf( &vls, "set perspective %d\n",
		    perspective_table[((struct x_vars *)dmp->dm_vars)->perspective_angle] );
a889 3
  /* Try to satisfy the above desires with a color visual of the
   * greatest depth */

d892 8
a899 7
  while (1) {
    for (i=0, j=0, vip=vibase; i<num; i++, vip++){
      /* requirements */
      if (vip->class != PseudoColor) {
	/* if index mode, accept only read/write*/
	continue;
      }
d901 3
a903 3
      /* this visual meets criteria */
      good[j++] = i;
    }
d905 3
a907 11
    /* j = number of acceptable visuals under consideration */
    if (j >= 1){
      baddepth = 1000;
      for(tries = 0; tries < j; ++tries) {
	maxvip = vibase + good[0];
	for (i=1; i<j; i++) {
	  vip = vibase + good[i];
	  if ((vip->depth > maxvip->depth)&&(vip->depth < baddepth)){
	    maxvip = vip;
	  }
	}
d909 7
a915 12
	/* make sure Tk handles it */
	*cmap = XCreateColormap(dpy, RootWindow(dpy, maxvip->screen),
				maxvip->visual, AllocAll);

	if (Tk_SetWindowVisual(tkwin, maxvip->visual, maxvip->depth, *cmap)){
	  *depth = maxvip->depth;
	  return 1; /* success */
	} else { 
	  /* retry with lesser depth */
	  baddepth = maxvip->depth;
	  XFreeColormap(dpy, *cmap);
	}
d919 12
a930 1
    return(0); /* failure */
d932 2
@


1.14
log
@*** empty log message ***
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.13 1997/03/26 18:40:21 jra Exp bparker $ (BRL)";
d140 5
a144 2
  dmp = BU_GETSTRUCT(dmp, dm);
  *dmp = dm_X;
d153 2
a154 2
  dmp->dm_vars = bu_calloc(1, sizeof(struct x_vars), "X_open: x_vars");
  if(!dmp->dm_vars){
@


1.13
log
@corrected a return of X_set_visual() and a comparison of its return in X_open().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.12 1997/03/03 19:59:39 bparker Exp jra $ (BRL)";
a121 1
#if DO_NEW_LIBDM_OPEN
a123 4
#else
X_open(dmp, argc, argv)
struct dm *dmp;
#endif
a137 1
#if DO_NEW_LIBDM_OPEN
a142 1
#endif
@


1.12
log
@*- remove call to X_load_startup
*- call _init_dm with 2 parameters
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.11 1997/03/03 18:32:11 bparker Exp bparker $ (BRL)";
d304 1
a304 1
		  &((struct x_vars *)dmp->dm_vars)->depth) == NULL){
d938 1
a938 1
    return(NULL); /* failure */
@


1.11
log
@mods to have display manager to allocate its own memory
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.10 1997/01/24 21:06:44 bparker Exp bparker $ (BRL)";
a58 1
static int X_load_startup();
d152 4
a155 2
  if(!count)
    (void)X_load_startup(dmp);
d157 1
a157 1
  dmp->dm_vars = bu_calloc(1, sizeof(struct x_vars), "X_init: x_vars");
d230 2
a248 1
#if 1
d250 1
a250 1
  bu_vls_printf(&str, "_new_init_dm %S %S %S\n",
a251 1
		&top_vls,
d257 1
a261 1
  bu_vls_free(&top_vls);
a278 17
#else
  /*
   * Create the X drawing window by calling init_x which
   * is defined in xinit.tcl
   */
  bu_vls_init(&str);
  bu_vls_printf(&str, "_init_dm %s %s\n",
		bu_vls_addr(&dmp->dm_initWinProc),
		bu_vls_addr(&dmp->dm_pathName));

  if(Tcl_Eval(interp, bu_vls_addr(&str)) == TCL_ERROR){
    bu_vls_free(&str);
    (void)X_close(dmp);
    return DM_NULL;
  }

  bu_vls_free(&str);
a279 11
  ((struct x_vars *)dmp->dm_vars)->dpy =
    Tk_Display(((struct x_vars *)dmp->dm_vars)->xtkwin);

  dmp->dm_width =
    DisplayWidth(((struct x_vars *)dmp->dm_vars)->dpy,
		 DefaultScreen(((struct x_vars *)dmp->dm_vars)->dpy)) - 20;
  dmp->dm_height =
    DisplayHeight(((struct x_vars *)dmp->dm_vars)->dpy,
		  DefaultScreen(((struct x_vars *)dmp->dm_vars)->dpy)) - 20;

#endif
a880 17


static int
X_load_startup(dmp)
struct dm *dmp;
{
  char *filename;

  bzero((void *)&head_x_vars, sizeof(struct x_vars));
  BU_LIST_INIT( &head_x_vars.l );

  if((filename = getenv("DM_X_RCFILE")) != (char *)NULL )
    return Tcl_EvalFile(interp, filename);

  return TCL_OK;
}

@


1.10
log
@calling _init_dm instead of init_dm_win
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.9 1997/01/02 20:05:10 bparker Exp bparker $ (BRL)";
d24 5
d54 1
d65 1
a65 1
static int	X_open();
d69 1
a69 1
static int	X_drawString2D(), X_drawLine2D();
d97 5
d122 5
a126 1
static int
d129 1
d135 2
a139 1
  int a_screen;
d142 1
d144 7
d156 17
a172 3
  bu_vls_init_if_uninit(&dmp->dm_pathName);
  bu_vls_init_if_uninit(&dmp->dm_initWinProc);
  i = dm_process_options(dmp, argc, argv);
d174 12
a185 1
    bu_vls_printf(&dmp->dm_pathName, ".dm_x%d", count++);
d187 1
a187 1
    bu_vls_strcpy(&dmp->dm_initWinProc, "bind_dm_win");
d189 1
a189 1
  dmp->dm_vars = bu_calloc(1, sizeof(struct x_vars), "X_init: x_vars");
d191 1
d193 1
a193 1
  /* initialize the modifiable variables */
d196 1
d198 3
d205 56
a260 2
  if(!dmp->dm_vars)
    return TCL_ERROR;
d262 2
a263 1
  ((struct x_vars *)dmp->dm_vars)->fontstruct = NULL;
d265 6
a270 3
  /* Make xtkwin a toplevel window */
  ((struct x_vars *)dmp->dm_vars)->xtkwin = Tk_CreateWindowFromPath(interp, tkwin,
				       bu_vls_addr(&dmp->dm_pathName), dmp->dm_dname);
d272 7
d290 2
a291 1
    return TCL_ERROR;
d298 2
a299 1
  ((struct x_vars *)dmp->dm_vars)->width =
d302 1
a302 1
  ((struct x_vars *)dmp->dm_vars)->height =
d306 9
a314 5
  /* Make window square */
  if(((struct x_vars *)dmp->dm_vars)->height < ((struct x_vars *)dmp->dm_vars)->width)
    ((struct x_vars *)dmp->dm_vars)->width = ((struct x_vars *)dmp->dm_vars)->height;
  else
    ((struct x_vars *)dmp->dm_vars)->height = ((struct x_vars *)dmp->dm_vars)->width;
d317 2
a318 2
		     ((struct x_vars *)dmp->dm_vars)->width, 
		     ((struct x_vars *)dmp->dm_vars)->height);
d325 1
a325 1
  a_screen = Tk_ScreenNumber(((struct x_vars *)dmp->dm_vars)->xtkwin);
d333 2
a334 1
    return TCL_ERROR;
d344 2
a345 2
		 ((struct x_vars *)dmp->dm_vars)->width,
		 ((struct x_vars *)dmp->dm_vars)->height,
d375 1
a375 1
  return TCL_OK;
d411 4
d416 1
a416 1

d438 2
a439 2
		 0, ((struct x_vars *)dmp->dm_vars)->width + 1,
		 ((struct x_vars *)dmp->dm_vars)->height + 1);
d455 2
a456 2
	      0, 0, ((struct x_vars *)dmp->dm_vars)->width,
	    ((struct x_vars *)dmp->dm_vars)->height, 0, 0);
d524 1
a524 1
		pnt[0] *= 2047;
d542 1
a542 1
		pnt[0] *= 2047;
d597 2
a598 2
static int
X_drawString2D( dmp, str, x, y, size )
d603 1
d607 5
a611 1
  sx = GED_TO_Xx(dmp, x );
d630 4
a633 4
  sx1 = GED_TO_Xx(dmp, x1 );
  sy1 = GED_TO_Xy(dmp, y1 );
  sx2 = GED_TO_Xx(dmp, x2 );
  sy2 = GED_TO_Xy(dmp, y2 );
d759 14
a772 2
  ((struct x_vars *)dmp->dm_vars)->height = xwa.height;
  ((struct x_vars *)dmp->dm_vars)->width = xwa.width;
d795 1
a795 1
  if (((struct x_vars *)dmp->dm_vars)->width < 582) {
d807 1
a807 1
  } else if (((struct x_vars *)dmp->dm_vars)->width < 679) {
d819 1
a819 1
  } else if (((struct x_vars *)dmp->dm_vars)->width < 776) {
d831 1
a831 1
  } else if (((struct x_vars *)dmp->dm_vars)->width < 873) {
@


1.9
log
@*** empty log message ***
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.8 1996/12/04 21:25:52 bparker Exp bparker $ (BRL)";
d164 1
a164 1
  bu_vls_printf(&str, "init_dm_win %s %s\n",
@


1.8
log
@change interface to X_open
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.7 1996/10/24 22:13:14 bparker Exp bparker $ (BRL)";
a723 3
#if 0
  dmaflag = 1;
#endif
a758 4

#if 0
  dmaflag = 1;
#endif
d837 4
@


1.7
log
@checkin for the week
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.6 1996/10/23 20:28:49 bparker Exp bparker $ (BRL)";
a39 1

d44 1
a58 1
static int	X_init();
a70 1
  X_init,
d95 1
d105 6
d112 1
a112 1
X_init(dmp, argc, argv)
d118 8
d131 7
a137 1
  bu_vls_printf(&dmp->dm_pathName, ".dm_x%d", count++);
d150 2
a151 25
  if(dmp->dm_vars)
    return TCL_OK;

  return TCL_ERROR;
}

/*
 *			X _ O P E N
 *
 * Fire up the display manager, and the display processor.
 *
 */
static int
X_open(dmp)
struct dm *dmp;
{
  XGCValues gcv;
  XColor a_color;
  Visual *a_visual;
  int a_screen;
  Colormap  a_cmap;
  struct bu_vls str;
  Display *tmp_dpy;

  bu_vls_init(&str);
d163 4
a166 2
  bu_vls_strcpy(&str, "init_x ");
  bu_vls_printf(&str, "%s\n", bu_vls_addr(&dmp->dm_pathName));
d260 13
a272 7
  if(((struct x_vars *)dmp->dm_vars)->gc != 0)
    XFreeGC(((struct x_vars *)dmp->dm_vars)->dpy,
	    ((struct x_vars *)dmp->dm_vars)->gc);

  if(((struct x_vars *)dmp->dm_vars)->pix != 0)
     Tk_FreePixmap(((struct x_vars *)dmp->dm_vars)->dpy,
		   ((struct x_vars *)dmp->dm_vars)->pix);
d274 2
a275 1
  /*XXX Possibly need to free the colormap */
d277 3
a279 2
  if(((struct x_vars *)dmp->dm_vars)->xtkwin != 0)
    Tk_DestroyWindow(((struct x_vars *)dmp->dm_vars)->xtkwin);
a284 3

  if(BU_LIST_IS_EMPTY(&head_x_vars.l))
    Tk_DeleteGenericHandler(dmp->dm_eventHandler, (ClientData)DM_TYPE_X);
@


1.6
log
@.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.5 1996/09/30 19:40:38 bparker Exp bparker $ (BRL)";
a54 1
#define CMAP_BASE 32
a70 4
static unsigned long get_pixel();
static void get_color_slot();
static void allocate_color_cube();

d223 12
a234 1
  allocate_color_cube(dmp);
d530 2
a531 1
  gcv.foreground = get_pixel(dmp, r, g, b);
a780 78

/* Return the allocated pixel value that most closely represents
the color requested. */
static unsigned long
get_pixel(dmp, r, g, b)
struct dm *dmp;
short r, g, b;
{
  short rr, rg, rb;

  get_color_slot(r, &rr);
  get_color_slot(g, &rg);
  get_color_slot(b, &rb);

  return(((struct x_vars *)dmp->dm_vars)->pixel[rr * 36 + rg * 6 + rb]);
}

/* get color component value */
static void
get_color_slot(sc, c)
short sc;
short *c;
{
  if(sc < 42)
	*c = 0;
  else if(sc < 85)
	*c = 1;
  else if(sc < 127)
	*c = 2;
  else if(sc < 170)
	*c = 3;
  else if(sc < 212)
	*c = 4;
  else
	*c = 5;
}

static void
allocate_color_cube(dmp)
struct dm *dmp;
{
  XColor color;
  XColor colors[CMAP_BASE];
  Colormap cmap;
  int i;
  int r, g, b;

  /* store default colors below CMAP_BASE */
  cmap = DefaultColormap(((struct x_vars *)dmp->dm_vars)->dpy,
			 DefaultScreen(((struct x_vars *)dmp->dm_vars)->dpy));
  for(i = 0; i < CMAP_BASE; ++i)
    colors[i].pixel = i;
  XQueryColors(((struct x_vars *)dmp->dm_vars)->dpy, cmap, colors, CMAP_BASE);
  for(i = 0; i < CMAP_BASE; ++i)
    XStoreColor(((struct x_vars *)dmp->dm_vars)->dpy,
		((struct x_vars *)dmp->dm_vars)->cmap,
		&colors[i]);

  /* store color cube above CMAP_BASE */
  for(i = r = 0; r < 65026; r = r + 13005)
    for(g = 0; g < 65026; g = g + 13005)
      for(b = 0; b < 65026; b = b + 13005){
	color.red = (unsigned short)r;
	color.green = (unsigned short)g;
	color.blue = (unsigned short)b;
	((struct x_vars *)dmp->dm_vars)->pixel[i] = color.pixel = i++ + CMAP_BASE;
	color.flags = DoRed|DoGreen|DoBlue;
	XStoreColor(((struct x_vars *)dmp->dm_vars)->dpy,
		    ((struct x_vars *)dmp->dm_vars)->cmap,
		    &color);
      }

  /* black */
  ((struct x_vars *)dmp->dm_vars)->bg = ((struct x_vars *)dmp->dm_vars)->pixel[0];

  /* red */
  ((struct x_vars *)dmp->dm_vars)->fg = ((struct x_vars *)dmp->dm_vars)->pixel[180];
}
@


1.5
log
@more pruning
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.4 1996/09/26 20:37:27 bparker Exp bparker $ (BRL)";
d24 2
a26 2
#include <sys/time.h>		/* for struct timeval */
#include <X11/X.h>
a35 4
#include "tk.h"
#include <X11/Xutil.h>
#include <X11/extensions/Xext.h>
#include <X11/extensions/multibuf.h>
d40 1
a41 1
#include "mater.h"
a44 1
#include "solid.h"
d53 3
a55 1
static void X_load_startup();
d60 1
a60 1
static int     X_init();
d62 7
a68 7
static void	X_close();
static void	X_input();
static void	X_prolog(), X_epilog();
static void	X_normal(), X_newrot();
static void	X_update();
static void	X_puts(), X_2d_line(), X_light();
static int	X_object();
d70 1
a70 2
static void	X_viewchange(), X_colorchange();
static void	X_window(), X_debug();
a71 1
#if TRY_COLOR_CUBE
a74 1
#endif
d78 17
a94 12
  X_open, X_close,
  X_input,
  X_prolog, X_epilog,
  X_normal, X_newrot,
  X_update,
  X_puts, X_2d_line,
  X_light,
  X_object,	X_cvtvecs, X_load,
  Nu_void,
  X_viewchange,
  X_colorchange,
  X_window, X_debug, Nu_int0, Nu_int0,
d121 1
a121 1
    X_load_startup(dmp);
d123 1
a123 1
  bu_vls_printf(&dmp->dmr_pathName, ".dm_x%d", count++);
d125 2
a126 2
  dmp->dmr_vars = bu_calloc(1, sizeof(struct x_vars), "X_init: x_vars");
  ((struct x_vars *)dmp->dmr_vars)->perspective_angle = 3;
d129 1
a129 1
  ((struct x_vars *)dmp->dmr_vars)->mvars.dummy_perspective = 1;
d132 1
a132 1
    Tk_CreateGenericHandler(dmp->dmr_eventhandler, (ClientData)DM_TYPE_X);
d134 1
a134 1
  BU_LIST_APPEND(&head_x_vars.l, &((struct x_vars *)dmp->dmr_vars)->l);
d136 1
a136 1
  if(dmp->dmr_vars)
d162 1
a162 1
  ((struct x_vars *)dmp->dmr_vars)->fontstruct = NULL;
d165 2
a166 2
  ((struct x_vars *)dmp->dmr_vars)->xtkwin = Tk_CreateWindowFromPath(interp, tkwin,
				       bu_vls_addr(&dmp->dmr_pathName), dmp->dmr_dname);
d173 1
a173 1
  bu_vls_printf(&str, "%s\n", bu_vls_addr(&dmp->dmr_pathName));
d182 8
a189 7
  ((struct x_vars *)dmp->dmr_vars)->dpy = Tk_Display(((struct x_vars *)dmp->dmr_vars)->xtkwin);
  ((struct x_vars *)dmp->dmr_vars)->width =
    DisplayWidth(((struct x_vars *)dmp->dmr_vars)->dpy,
		 DefaultScreen(((struct x_vars *)dmp->dmr_vars)->dpy)) - 20;
  ((struct x_vars *)dmp->dmr_vars)->height =
    DisplayHeight(((struct x_vars *)dmp->dmr_vars)->dpy,
		  DefaultScreen(((struct x_vars *)dmp->dmr_vars)->dpy)) - 20;
d192 2
a193 2
  if(((struct x_vars *)dmp->dmr_vars)->height < ((struct x_vars *)dmp->dmr_vars)->width)
    ((struct x_vars *)dmp->dmr_vars)->width = ((struct x_vars *)dmp->dmr_vars)->height;
d195 1
a195 1
    ((struct x_vars *)dmp->dmr_vars)->height = ((struct x_vars *)dmp->dmr_vars)->width;
d197 3
a199 3
  Tk_GeometryRequest(((struct x_vars *)dmp->dmr_vars)->xtkwin,
		     ((struct x_vars *)dmp->dmr_vars)->width, 
		     ((struct x_vars *)dmp->dmr_vars)->height);
d203 1
a203 1
  XSynchronize(((struct x_vars *)dmp->dmr_vars)->dpy, TRUE);
d206 8
a213 26
  Tk_MakeWindowExist(((struct x_vars *)dmp->dmr_vars)->xtkwin);
  ((struct x_vars *)dmp->dmr_vars)->win =
      Tk_WindowId(((struct x_vars *)dmp->dmr_vars)->xtkwin);

  ((struct x_vars *)dmp->dmr_vars)->pix = Tk_GetPixmap(((struct x_vars *)dmp->dmr_vars)->dpy,
    DefaultRootWindow(((struct x_vars *)dmp->dmr_vars)->dpy), ((struct x_vars *)dmp->dmr_vars)->width,
    ((struct x_vars *)dmp->dmr_vars)->height, Tk_Depth(((struct x_vars *)dmp->dmr_vars)->xtkwin));

  a_screen = Tk_ScreenNumber(((struct x_vars *)dmp->dmr_vars)->xtkwin);
  a_visual = Tk_Visual(((struct x_vars *)dmp->dmr_vars)->xtkwin);

  /* Get color map indices for the colors we use. */
  ((struct x_vars *)dmp->dmr_vars)->black = BlackPixel( ((struct x_vars *)dmp->dmr_vars)->dpy, a_screen );
  ((struct x_vars *)dmp->dmr_vars)->white = WhitePixel( ((struct x_vars *)dmp->dmr_vars)->dpy, a_screen );

#if TRY_COLOR_CUBE
  ((struct x_vars *)dmp->dmr_vars)->cmap = a_cmap = Tk_Colormap(((struct x_vars *)dmp->dmr_vars)->xtkwin);
#else
  a_cmap = Tk_Colormap(((struct x_vars *)dmp->dmr_vars)->xtkwin);
#endif
  a_color.red = 255<<8;
  a_color.green=0;
  a_color.blue=0;
  a_color.flags = DoRed | DoGreen| DoBlue;
  if ( ! XAllocColor(((struct x_vars *)dmp->dmr_vars)->dpy, a_cmap, &a_color)) {
    Tcl_AppendResult(interp, "dm-X: Can't Allocate red\n", (char *)NULL);
a215 67
  ((struct x_vars *)dmp->dmr_vars)->red = a_color.pixel;
    if ( ((struct x_vars *)dmp->dmr_vars)->red == ((struct x_vars *)dmp->dmr_vars)->white )
      ((struct x_vars *)dmp->dmr_vars)->red = ((struct x_vars *)dmp->dmr_vars)->black;

    a_color.red = 200<<8;
    a_color.green=200<<8;
    a_color.blue=0<<8;
    a_color.flags = DoRed | DoGreen| DoBlue;
    if ( ! XAllocColor(((struct x_vars *)dmp->dmr_vars)->dpy, a_cmap, &a_color)) {
      Tcl_AppendResult(interp, "dm-X: Can't Allocate yellow\n", (char *)NULL);
      return TCL_ERROR;
    }
    ((struct x_vars *)dmp->dmr_vars)->yellow = a_color.pixel;
    if ( ((struct x_vars *)dmp->dmr_vars)->yellow == ((struct x_vars *)dmp->dmr_vars)->white )
      ((struct x_vars *)dmp->dmr_vars)->yellow = ((struct x_vars *)dmp->dmr_vars)->black;
    
    a_color.red = 0;
    a_color.green=0;
    a_color.blue=255<<8;
    a_color.flags = DoRed | DoGreen| DoBlue;
    if ( ! XAllocColor(((struct x_vars *)dmp->dmr_vars)->dpy, a_cmap, &a_color)) {
      Tcl_AppendResult(interp, "dm-X: Can't Allocate blue\n", (char *)NULL);
      return TCL_ERROR;
    }
    ((struct x_vars *)dmp->dmr_vars)->blue = a_color.pixel;
    if ( ((struct x_vars *)dmp->dmr_vars)->blue == ((struct x_vars *)dmp->dmr_vars)->white )
      ((struct x_vars *)dmp->dmr_vars)->blue = ((struct x_vars *)dmp->dmr_vars)->black;

    a_color.red = 128<<8;
    a_color.green=128<<8;
    a_color.blue= 128<<8;
    a_color.flags = DoRed | DoGreen| DoBlue;
    if ( ! XAllocColor(((struct x_vars *)dmp->dmr_vars)->dpy, a_cmap, &a_color)) {
      Tcl_AppendResult(interp, "dm-X: Can't Allocate gray\n", (char *)NULL);
      return TCL_ERROR;
    }
    ((struct x_vars *)dmp->dmr_vars)->gray = a_color.pixel;
    if ( ((struct x_vars *)dmp->dmr_vars)->gray == ((struct x_vars *)dmp->dmr_vars)->white )
      ((struct x_vars *)dmp->dmr_vars)->gray = ((struct x_vars *)dmp->dmr_vars)->black;

    /* Select border, background, foreground colors,
     * and border width.
     */
    if( a_visual->class == GrayScale || a_visual->class == StaticGray ) {
	((struct x_vars *)dmp->dmr_vars)->is_monochrome = 1;
	((struct x_vars *)dmp->dmr_vars)->bd = BlackPixel( ((struct x_vars *)dmp->dmr_vars)->dpy, a_screen );
	((struct x_vars *)dmp->dmr_vars)->bg = WhitePixel( ((struct x_vars *)dmp->dmr_vars)->dpy, a_screen );
	((struct x_vars *)dmp->dmr_vars)->fg = BlackPixel( ((struct x_vars *)dmp->dmr_vars)->dpy, a_screen );
    } else {
	/* Hey, it's a color server.  Ought to use 'em! */
	((struct x_vars *)dmp->dmr_vars)->is_monochrome = 0;
	((struct x_vars *)dmp->dmr_vars)->bd = WhitePixel( ((struct x_vars *)dmp->dmr_vars)->dpy, a_screen );
	((struct x_vars *)dmp->dmr_vars)->bg = BlackPixel( ((struct x_vars *)dmp->dmr_vars)->dpy, a_screen );
	((struct x_vars *)dmp->dmr_vars)->fg = WhitePixel( ((struct x_vars *)dmp->dmr_vars)->dpy, a_screen );
    }

    if( !((struct x_vars *)dmp->dmr_vars)->is_monochrome &&
	((struct x_vars *)dmp->dmr_vars)->fg != ((struct x_vars *)dmp->dmr_vars)->red &&
	((struct x_vars *)dmp->dmr_vars)->red != ((struct x_vars *)dmp->dmr_vars)->black )
      ((struct x_vars *)dmp->dmr_vars)->fg = ((struct x_vars *)dmp->dmr_vars)->red;

    gcv.foreground = ((struct x_vars *)dmp->dmr_vars)->fg;
    gcv.background = ((struct x_vars *)dmp->dmr_vars)->bg;
    ((struct x_vars *)dmp->dmr_vars)->gc = XCreateGC(((struct x_vars *)dmp->dmr_vars)->dpy,
					       ((struct x_vars *)dmp->dmr_vars)->win,
					       (GCForeground|GCBackground),
					       &gcv);
d217 18
a234 3
#if TRY_COLOR_CUBE
    allocate_color_cube(dmp);
#endif
d237 1
a237 1
    X_configure_window_shape(dmp);
d240 3
a242 2
    Tk_SetWindowBackground(((struct x_vars *)dmp->dmr_vars)->xtkwin, ((struct x_vars *)dmp->dmr_vars)->bg);
    Tk_MapWindow(((struct x_vars *)dmp->dmr_vars)->xtkwin);
d244 1
a244 1
    return TCL_OK;
d252 1
a252 1
static void
d256 3
a258 2
  if(((struct x_vars *)dmp->dmr_vars)->gc != 0)
    XFreeGC(((struct x_vars *)dmp->dmr_vars)->dpy, ((struct x_vars *)dmp->dmr_vars)->gc);
d260 3
a262 2
  if(((struct x_vars *)dmp->dmr_vars)->pix != 0)
     Tk_FreePixmap(((struct x_vars *)dmp->dmr_vars)->dpy, ((struct x_vars *)dmp->dmr_vars)->pix);
d264 1
a264 2
  if(((struct x_vars *)dmp->dmr_vars)->xtkwin != 0)
    Tk_DestroyWindow(((struct x_vars *)dmp->dmr_vars)->xtkwin);
d266 2
a267 2
  if(((struct x_vars *)dmp->dmr_vars)->l.forw != BU_LIST_NULL)
    BU_LIST_DEQUEUE(&((struct x_vars *)dmp->dmr_vars)->l);
d269 2
a270 1
  bu_free(dmp->dmr_vars, "X_close: x_vars");
d272 2
d275 3
a277 1
    Tk_DeleteGenericHandler(dmp->dmr_eventhandler, (ClientData)DM_TYPE_X);
d285 2
a286 2
static void
X_prolog(dmp)
d291 3
a293 2
  gcv.foreground = ((struct x_vars *)dmp->dmr_vars)->bg;
  XChangeGC(((struct x_vars *)dmp->dmr_vars)->dpy, ((struct x_vars *)dmp->dmr_vars)->gc,
d295 7
a301 3
  XFillRectangle(((struct x_vars *)dmp->dmr_vars)->dpy, ((struct x_vars *)dmp->dmr_vars)->pix,
		 ((struct x_vars *)dmp->dmr_vars)->gc, 0, 0, ((struct x_vars *)dmp->dmr_vars)->width + 1,
		 ((struct x_vars *)dmp->dmr_vars)->height + 1);
d307 2
a308 2
static void
X_epilog(dmp)
d311 6
a316 2
    /* Put the center point up last */
    draw( dmp, 0, 0, 0, 0 );
d318 2
a319 4
    XCopyArea(((struct x_vars *)dmp->dmr_vars)->dpy, ((struct x_vars *)dmp->dmr_vars)->pix,
	      ((struct x_vars *)dmp->dmr_vars)->win, ((struct x_vars *)dmp->dmr_vars)->gc,
	      0, 0, ((struct x_vars *)dmp->dmr_vars)->width, ((struct x_vars *)dmp->dmr_vars)->height,
	      0, 0);
d321 1
a321 2
    /* Prevent lag between events and updates */
    XSync(((struct x_vars *)dmp->dmr_vars)->dpy, 0);
d329 1
a329 1
static void
d334 1
a334 1
	return;
d338 1
a338 1
 *  			X _ O B J E C T
a339 4
 *  Set up for an object, transformed as indicated, and with an
 *  object center as specified.  The ratio of object to screen size
 *  is passed in as a convienience.
 *
d345 1
a345 1
X_object( dmp, vp, mat, illum, linestyle, r, g, b, index )
a348 4
int illum;
int linestyle;
register short r, g, b;
short index;
a358 26
    int   line_width = 1;
    int   line_style = LineSolid;

#if TRY_COLOR_CUBE
    if(illum){    /* if highlighted */
      gcv.foreground = get_pixel(dmp, r, g, b);

      /* if solid color is already the same as the highlight color use double line width */
      if(gcv.foreground == ((struct x_vars *)dmp->dmr_vars)->white)
	line_width = 2;
      else
	gcv.foreground = ((struct x_vars *)dmp->dmr_vars)->white;
    }else
      gcv.foreground = get_pixel(dmp, r, g, b);
#else
    gcv.foreground = ((struct x_vars *)dmp->dmr_vars)->fg;
#endif
    XChangeGC(((struct x_vars *)dmp->dmr_vars)->dpy,
	      ((struct x_vars *)dmp->dmr_vars)->gc, GCForeground, &gcv);

    if( linestyle )
      line_style = LineOnOffDash;

    XSetLineAttributes( ((struct x_vars *)dmp->dmr_vars)->dpy,
			((struct x_vars *)dmp->dmr_vars)->gc,
			line_width, line_style, CapButt, JoinMiter );
d399 1
d401 1
a401 9
		/*XXX Color */
#if !TRY_COLOR_CUBE
		gcv.foreground = ((struct x_vars *)dmp->dmr_vars)->fg;
		if( illum && !((struct x_vars *)dmp->dmr_vars)->is_monochrome ){
		    gcv.foreground = ((struct x_vars *)dmp->dmr_vars)->white;
		}
		XChangeGC( ((struct x_vars *)dmp->dmr_vars)->dpy,
			   ((struct x_vars *)dmp->dmr_vars)->gc, GCForeground, &gcv );
#endif
d416 4
a419 20
		  XDrawSegments( ((struct x_vars *)dmp->dmr_vars)->dpy,
				 ((struct x_vars *)dmp->dmr_vars)->pix,
				 ((struct x_vars *)dmp->dmr_vars)->gc, segbuf, nseg );
		  /* Thicken the drawing, if monochrome */
		  if( illum && ((struct x_vars *)dmp->dmr_vars)->is_monochrome ){
		    int	i;
		    /* XXX - width and height don't work on Sun! */
		    /* Thus the following gross hack */
		    segp = segbuf;
		    for( i = 0; i < nseg; i++ ) {
		      segp->x1++;
		      segp->y1++;
		      segp->x2++;
		      segp->y2++;
		      segp++;
		    }
		    XDrawSegments( ((struct x_vars *)dmp->dmr_vars)->dpy,
				   ((struct x_vars *)dmp->dmr_vars)->pix,
				   ((struct x_vars *)dmp->dmr_vars)->gc, segbuf, nseg );
		  }
d428 3
a430 19
      XDrawSegments( ((struct x_vars *)dmp->dmr_vars)->dpy,
		     ((struct x_vars *)dmp->dmr_vars)->pix,
		     ((struct x_vars *)dmp->dmr_vars)->gc, segbuf, nseg );
      if( illum && ((struct x_vars *)dmp->dmr_vars)->is_monochrome ){
	int	i;
	/* XXX - width and height don't work on Sun! */
	/* Thus the following gross hack */
	segp = segbuf;
	for( i = 0; i < nseg; i++ ) {
	  segp->x1++;
	  segp->y1++;
	  segp->x2++;
	  segp->y2++;
	  segp++;
	}
	XDrawSegments( ((struct x_vars *)dmp->dmr_vars)->dpy,
		       ((struct x_vars *)dmp->dmr_vars)->pix,
		       ((struct x_vars *)dmp->dmr_vars)->gc, segbuf, nseg );
      }
d433 1
a433 1
    return 1;    /* OK */
d443 1
a443 1
static void
d447 1
a447 13
	return;
}

/*
 *			X _ U P D A T E
 *
 * Transmit accumulated displaylist to the display processor.
 */
static void
X_update(dmp)
struct dm *dmp;
{
    XFlush(((struct x_vars *)dmp->dmr_vars)->dpy);
d451 1
a451 1
 *			X _ P U T S
d457 2
a458 2
static void
X_puts( dmp, str, x, y, size, color )
d461 2
d464 1
a464 2
	XGCValues gcv;
	unsigned long fg;
d466 9
a474 21
	switch( color )  {
	case DM_BLACK:
		fg = ((struct x_vars *)dmp->dmr_vars)->black;
		break;
	case DM_RED:
		fg = ((struct x_vars *)dmp->dmr_vars)->red;
		break;
	case DM_BLUE:
		fg = ((struct x_vars *)dmp->dmr_vars)->blue;
		break;
	default:
	case DM_YELLOW:
		fg = ((struct x_vars *)dmp->dmr_vars)->yellow;
		break;
	case DM_WHITE:
		fg = ((struct x_vars *)dmp->dmr_vars)->gray;
		break;
	}
	gcv.foreground = fg;
	XChangeGC( ((struct x_vars *)dmp->dmr_vars)->dpy, ((struct x_vars *)dmp->dmr_vars)->gc, GCForeground, &gcv );
	label( dmp, (double)x, (double)y, str );
d477 2
a478 6
/*
 *			X _ 2 D _ G O T O
 *
 */
static void
X_2d_line( dmp, x1, y1, x2, y2, dashed )
d482 20
a501 1
int dashed;
d503 8
a510 1
    XGCValues gcv;
d512 1
a512 8
    gcv.foreground = ((struct x_vars *)dmp->dmr_vars)->yellow;
    XChangeGC( ((struct x_vars *)dmp->dmr_vars)->dpy, ((struct x_vars *)dmp->dmr_vars)->gc, GCForeground, &gcv );
    if( dashed ) {
	XSetLineAttributes(((struct x_vars *)dmp->dmr_vars)->dpy, ((struct x_vars *)dmp->dmr_vars)->gc, 1, LineOnOffDash, CapButt, JoinMiter );
    } else {
	XSetLineAttributes(((struct x_vars *)dmp->dmr_vars)->dpy, ((struct x_vars *)dmp->dmr_vars)->gc, 1, LineSolid, CapButt, JoinMiter );
    }
    draw( dmp, x1, y1, x2, y2 );
d516 5
a520 20
/*
 *			X _ I N P U T
 *
 * Execution must suspend in this routine until a significant event
 * has occured on either the command stream,
 * unless "noblock" is set.
 *
 *
 * Implicit Return -
 *	If any files are ready for input, their bits will be set in 'input'.
 *	Otherwise, 'input' will be all zeros.
 *
 * DEPRECATED 
 *
 */
/* ARGSUSED */
static void
X_input( input, noblock )
fd_set		*input;
int		noblock;
d522 8
a529 1
    return;
d532 2
a533 6
/* 
 *			X _ L I G H T
 */
/* ARGSUSED */
static void
X_light( dmp, cmd, func )
d535 2
a536 2
int cmd;
int func;			/* BE_ or BV_ function */
d538 13
a550 1
  return;
d553 1
a573 12
static void
X_viewchange(dmp)
struct dm *dmp;
{
}

static void
X_colorchange(dmp)
struct dm *dmp;
{
}

d575 1
a575 1
static void
d579 1
a579 1
  XFlush(((struct x_vars *)dmp->dmr_vars)->dpy);
d581 2
d585 2
a586 2
static void
X_window(dmp, w)
d591 7
a597 7
	/* Compute the clipping bounds */
	clipmin[0] = w[1] / 2048.;
	clipmin[1] = w[3] / 2048.;
	clipmin[2] = w[5] / 2048.;
	clipmax[0] = w[0] / 2047.;
	clipmax[1] = w[2] / 2047.;
	clipmax[2] = w[4] / 2047.;
a598 1
}
d600 1
a600 44
/*********XXX**********/
/*
 *  Called for 2d_line, and dot at center of screen.
 */
static void
draw( dmp, x1, y1, x2, y2 )
struct dm *dmp;
int	x1, y1;		/* from point */
int	x2, y2;		/* to point */
{
  int	sx1, sy1, sx2, sy2;

  sx1 = GED_TO_Xx(dmp, x1 );
  sy1 = GED_TO_Xy(dmp, y1 );
  sx2 = GED_TO_Xx(dmp, x2 );
  sy2 = GED_TO_Xy(dmp, y2 );

  if( sx1 == sx2 && sy1 == sy2 )
    XDrawPoint( ((struct x_vars *)dmp->dmr_vars)->dpy,
		((struct x_vars *)dmp->dmr_vars)->pix,
		((struct x_vars *)dmp->dmr_vars)->gc, sx1, sy1 );
  else
    XDrawLine( ((struct x_vars *)dmp->dmr_vars)->dpy,
	       ((struct x_vars *)dmp->dmr_vars)->pix,
	       ((struct x_vars *)dmp->dmr_vars)->gc, sx1, sy1, sx2, sy2 );
}

static void
label( dmp, x, y, str )
struct dm *dmp;
double	x, y;
char	*str;
{
  int	sx, sy;

  sx = GED_TO_Xx(dmp, x );
  sy = GED_TO_Xy(dmp, y );
  /* point is center of text? - seems like what MGED wants... */
  /* The following makes the menu look good, the rest bad */
  /*sy += ((struct x_vars *)dmp->dmr_vars)->fontstruct->max_bounds.ascent + ((struct x_vars *)dmp->dmr_vars)->fontstruct->max_bounds.descent/2);*/

  XDrawString( ((struct x_vars *)dmp->dmr_vars)->dpy,
	       ((struct x_vars *)dmp->dmr_vars)->pix,
	       ((struct x_vars *)dmp->dmr_vars)->gc, sx, sy, str, strlen(str) );
d611 4
a614 4
  XGetWindowAttributes( ((struct x_vars *)dmp->dmr_vars)->dpy,
			((struct x_vars *)dmp->dmr_vars)->win, &xwa );
  ((struct x_vars *)dmp->dmr_vars)->height = xwa.height;
  ((struct x_vars *)dmp->dmr_vars)->width = xwa.width;
d617 3
a619 2
  if (((struct x_vars *)dmp->dmr_vars)->fontstruct == NULL) {
    if ((((struct x_vars *)dmp->dmr_vars)->fontstruct = XLoadQueryFont(((struct x_vars *)dmp->dmr_vars)->dpy, FONT9)) == NULL ) {
d621 2
a622 1
      if ((((struct x_vars *)dmp->dmr_vars)->fontstruct = XLoadQueryFont(((struct x_vars *)dmp->dmr_vars)->dpy, FONTBACK)) == NULL) {
d629 3
a631 3
    gcv.font = ((struct x_vars *)dmp->dmr_vars)->fontstruct->fid;
    XChangeGC(((struct x_vars *)dmp->dmr_vars)->dpy, ((struct x_vars *)dmp->dmr_vars)->gc,
	      GCFont, &gcv);
d637 10
a646 8
  if (((struct x_vars *)dmp->dmr_vars)->width < 582) {
    if (((struct x_vars *)dmp->dmr_vars)->fontstruct->per_char->width != 5) {
      if ((newfontstruct = XLoadQueryFont(((struct x_vars *)dmp->dmr_vars)->dpy, FONT5)) != NULL ) {
	XFreeFont(((struct x_vars *)dmp->dmr_vars)->dpy, ((struct x_vars *)dmp->dmr_vars)->fontstruct);
	((struct x_vars *)dmp->dmr_vars)->fontstruct = newfontstruct;
	gcv.font = ((struct x_vars *)dmp->dmr_vars)->fontstruct->fid;
	XChangeGC(((struct x_vars *)dmp->dmr_vars)->dpy, ((struct x_vars *)dmp->dmr_vars)->gc,
		  GCFont, &gcv);
d649 10
a658 8
  } else if (((struct x_vars *)dmp->dmr_vars)->width < 679) {
    if (((struct x_vars *)dmp->dmr_vars)->fontstruct->per_char->width != 6){
      if ((newfontstruct = XLoadQueryFont(((struct x_vars *)dmp->dmr_vars)->dpy, FONT6)) != NULL ) {
	XFreeFont(((struct x_vars *)dmp->dmr_vars)->dpy, ((struct x_vars *)dmp->dmr_vars)->fontstruct);
	((struct x_vars *)dmp->dmr_vars)->fontstruct = newfontstruct;
	gcv.font = ((struct x_vars *)dmp->dmr_vars)->fontstruct->fid;
	XChangeGC(((struct x_vars *)dmp->dmr_vars)->dpy, ((struct x_vars *)dmp->dmr_vars)->gc,
		  GCFont, &gcv);
d661 10
a670 8
  } else if (((struct x_vars *)dmp->dmr_vars)->width < 776) {
    if (((struct x_vars *)dmp->dmr_vars)->fontstruct->per_char->width != 7){
      if ((newfontstruct = XLoadQueryFont(((struct x_vars *)dmp->dmr_vars)->dpy, FONT7)) != NULL ) {
	XFreeFont(((struct x_vars *)dmp->dmr_vars)->dpy, ((struct x_vars *)dmp->dmr_vars)->fontstruct);
	((struct x_vars *)dmp->dmr_vars)->fontstruct = newfontstruct;
	gcv.font = ((struct x_vars *)dmp->dmr_vars)->fontstruct->fid;
	XChangeGC(((struct x_vars *)dmp->dmr_vars)->dpy, ((struct x_vars *)dmp->dmr_vars)->gc,
		  GCFont, &gcv);
d673 10
a682 8
  } else if (((struct x_vars *)dmp->dmr_vars)->width < 873) {
    if (((struct x_vars *)dmp->dmr_vars)->fontstruct->per_char->width != 8){
      if ((newfontstruct = XLoadQueryFont(((struct x_vars *)dmp->dmr_vars)->dpy, FONT8)) != NULL ) {
	XFreeFont(((struct x_vars *)dmp->dmr_vars)->dpy, ((struct x_vars *)dmp->dmr_vars)->fontstruct);
	((struct x_vars *)dmp->dmr_vars)->fontstruct = newfontstruct;
	gcv.font = ((struct x_vars *)dmp->dmr_vars)->fontstruct->fid;
	XChangeGC(((struct x_vars *)dmp->dmr_vars)->dpy, ((struct x_vars *)dmp->dmr_vars)->gc,
		  GCFont, &gcv);
d686 9
a694 7
    if (((struct x_vars *)dmp->dmr_vars)->fontstruct->per_char->width != 9){
      if ((newfontstruct = XLoadQueryFont(((struct x_vars *)dmp->dmr_vars)->dpy, FONT9)) != NULL ) {
	XFreeFont(((struct x_vars *)dmp->dmr_vars)->dpy, ((struct x_vars *)dmp->dmr_vars)->fontstruct);
	((struct x_vars *)dmp->dmr_vars)->fontstruct = newfontstruct;
	gcv.font = ((struct x_vars *)dmp->dmr_vars)->fontstruct->fid;
	XChangeGC(((struct x_vars *)dmp->dmr_vars)->dpy, ((struct x_vars *)dmp->dmr_vars)->gc,
		  GCFont, &gcv);
d708 3
a710 2
		((struct x_vars *)dmp->dmr_vars)->mvars.perspective_mode ?
		perspective_table[((struct x_vars *)dmp->dmr_vars)->perspective_angle] : -1 );
d729 6
a734 6
  if(((struct x_vars *)dmp->dmr_vars)->mvars.dummy_perspective > 0)
    ((struct x_vars *)dmp->dmr_vars)->perspective_angle =
      ((struct x_vars *)dmp->dmr_vars)->mvars.dummy_perspective <= 4 ?
      ((struct x_vars *)dmp->dmr_vars)->mvars.dummy_perspective - 1: 3;
  else if (--((struct x_vars *)dmp->dmr_vars)->perspective_angle < 0) /* toggle perspective matrix */
    ((struct x_vars *)dmp->dmr_vars)->perspective_angle = 3;
d736 1
a736 1
  if(((struct x_vars *)dmp->dmr_vars)->mvars.perspective_mode){
d741 1
a741 1
		    perspective_table[((struct x_vars *)dmp->dmr_vars)->perspective_angle] );
d751 1
a751 1
  ((struct x_vars *)dmp->dmr_vars)->mvars.dummy_perspective = 1;
d759 1
a759 1
static void
d769 3
a771 1
    Tcl_EvalFile(interp, filename);
a774 1
#if TRY_COLOR_CUBE
d788 1
a788 1
  return(((struct x_vars *)dmp->dmr_vars)->pixel[rr * 36 + rg * 6 + rb]);
a810 2
/* Try to allocate 216 colors. If a color cannot be
allocated, the default foreground color will be used.*/
d815 5
a819 2
  int	i = 0;
  XColor	color;
d821 10
a830 1
  int r, g, b;
d832 2
a833 1
  for(r = 0; r < 65026; r = r + 13005)
d839 37
a875 10
	if(XAllocColor(((struct x_vars *)dmp->dmr_vars)->dpy,
		       ((struct x_vars *)dmp->dmr_vars)->cmap, &color)){
	  if(color.pixel == ((struct x_vars *)dmp->dmr_vars)->bg)
	    /* that is, if the allocated color is the same as
	       the background color */
	    ((struct x_vars *)dmp->dmr_vars)->pixel[i++] = ((struct x_vars *)dmp->dmr_vars)->fg;	/* default foreground color, which may not be black */
	  else
	    ((struct x_vars *)dmp->dmr_vars)->pixel[i++] = color.pixel;
	}else	/* could not allocate a color */
	  ((struct x_vars *)dmp->dmr_vars)->pixel[i++] = ((struct x_vars *)dmp->dmr_vars)->fg;
d877 34
a911 1
#endif
@


1.4
log
@changed parameters to dmr_object
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.3 1996/09/25 20:28:29 bparker Exp bparker $ (BRL)";
a50 7
#define FONTBACK	"-adobe-courier-medium-r-normal--10-100-75-75-m-60-iso8859-1"
#define FONT5	"5x7"
#define FONT6	"6x10"
#define FONT7	"7x13"
#define FONT8	"8x13"
#define FONT9	"9x15"

a96 1
  0,				/* multi-window */
a102 2
  0,
  0,
d133 1
a133 1
    Tk_CreateGenericHandler(dmp->dmr_eventhandler, (ClientData)NULL);
d340 1
a340 1
    Tk_DeleteGenericHandler(dmp->dmr_eventhandler, (ClientData)NULL);
a416 1
    int useful = TCL_ERROR;
d497 2
a498 1
		XChangeGC( ((struct x_vars *)dmp->dmr_vars)->dpy, ((struct x_vars *)dmp->dmr_vars)->gc, GCForeground, &gcv );
a512 1
		useful = TCL_OK;
d514 15
a528 15
		    XDrawSegments( ((struct x_vars *)dmp->dmr_vars)->dpy, ((struct x_vars *)dmp->dmr_vars)->pix, ((struct x_vars *)dmp->dmr_vars)->gc, segbuf, nseg );
		    /* Thicken the drawing, if monochrome */
		    if( illum && ((struct x_vars *)dmp->dmr_vars)->is_monochrome ){
			int	i;
			/* XXX - width and height don't work on Sun! */
			/* Thus the following gross hack */
			segp = segbuf;
			for( i = 0; i < nseg; i++ ) {
			    segp->x1++;
			    segp->y1++;
			    segp->x2++;
			    segp->y2++;
			    segp++;
			}
			XDrawSegments( ((struct x_vars *)dmp->dmr_vars)->dpy, ((struct x_vars *)dmp->dmr_vars)->pix, ((struct x_vars *)dmp->dmr_vars)->gc, segbuf, nseg );
d530 6
a535 2
		    nseg = 0;
		    segp = segbuf;
d542 14
a555 14
	XDrawSegments( ((struct x_vars *)dmp->dmr_vars)->dpy, ((struct x_vars *)dmp->dmr_vars)->pix, ((struct x_vars *)dmp->dmr_vars)->gc, segbuf, nseg );
	if( illum && ((struct x_vars *)dmp->dmr_vars)->is_monochrome ){
	    int	i;
	    /* XXX - width and height don't work on Sun! */
	    /* Thus the following gross hack */
	    segp = segbuf;
	    for( i = 0; i < nseg; i++ ) {
		segp->x1++;
		segp->y1++;
		segp->x2++;
		segp->y2++;
		segp++;
	    }
	    XDrawSegments( ((struct x_vars *)dmp->dmr_vars)->dpy, ((struct x_vars *)dmp->dmr_vars)->pix, ((struct x_vars *)dmp->dmr_vars)->gc, segbuf, nseg );
d557 4
d563 1
a563 1
    return(useful);
a720 2
  /* apply colors to the solid table */
  dmp->dmr_cfunc();
@


1.3
log
@now using more generalized solid macros
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.2 1996/09/23 17:47:18 bparker Exp bparker $ (BRL)";
d142 5
d173 1
a173 4
  if(BU_LIST_IS_EMPTY(&head_x_vars.l))
    Tk_CreateGenericHandler(dmp->dmr_eventhandler, (ClientData)NULL);

  BU_LIST_APPEND(&head_x_vars.l, &((struct x_vars *)dmp->dmr_vars)->l);
a343 6
#if 0
  /* Give the application a chance to clean up */
  if(dmp->dmr_app_close)
    dmp->dmr_app_close(((struct x_vars *)dmp->dmr_vars)->app_vars);
#endif

d416 1
a416 1
X_object( dmp, sp, mat, ratio, white_flag )
d418 1
a418 1
register struct solid *sp;
d420 4
a423 2
double ratio;
int white_flag;
d426 1
a426 1
    register struct rt_vlist	*vp;
d439 2
a440 2
    if(white_flag){    /* if highlighted */
      gcv.foreground = get_pixel(dmp, sp->s_color);
d448 1
a448 1
      gcv.foreground = get_pixel(dmp, sp->s_color);
d452 2
a453 1
    XChangeGC(((struct x_vars *)dmp->dmr_vars)->dpy, ((struct x_vars *)dmp->dmr_vars)->gc, GCForeground, &gcv);
d455 1
a455 1
    if( sp->s_soldash )
d458 2
a459 1
    XSetLineAttributes( ((struct x_vars *)dmp->dmr_vars)->dpy, ((struct x_vars *)dmp->dmr_vars)->gc,
d464 1
a464 1
    for( BU_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
d466 3
a468 3
	register int	nused = vp->nused;
	register int	*cmd = vp->cmd;
	register point_t *pt = vp->pt;
d505 1
a505 1
		if( white_flag && !((struct x_vars *)dmp->dmr_vars)->is_monochrome ){
d527 1
a527 1
		    if( white_flag && ((struct x_vars *)dmp->dmr_vars)->is_monochrome ){
d550 1
a550 1
	if( white_flag && ((struct x_vars *)dmp->dmr_vars)->is_monochrome ){
d960 1
a960 1
get_pixel(dmp, s_color)
d962 1
a962 1
unsigned char	*s_color;
d964 1
a964 1
  unsigned char	r, g, b;
d966 3
a968 3
  get_color_slot(s_color[0], &r);
  get_color_slot(s_color[1], &g);
  get_color_slot(s_color[2], &b);
d970 1
a970 1
  return(((struct x_vars *)dmp->dmr_vars)->pixel[r * 36 + g * 6 + b]);
d976 2
a977 2
unsigned char sc;
unsigned char *c;
@


1.2
log
@cleanup
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-X.c,v 1.1 1996/09/17 21:24:18 bparker Exp bparker $ (BRL)";
d49 1
a50 4
/*XXX This is just temporary!!! */
#include "../mged/solid.h"
#include "../mged/sedit.h"

d110 3
d123 1
a123 1
X_init(dmp, color_func, argc, argv)
a124 1
void (*color_func)();
d136 1
a136 2
  dmp->dmr_vars = bu_malloc(sizeof(struct x_vars), "X_init: x_vars");
  bzero((void *)dmp->dmr_vars, sizeof(struct x_vars));
a137 1
  ((struct x_vars *)dmp->dmr_vars)->color_func = color_func;
d724 2
a725 1
  ((struct x_vars *)dmp->dmr_vars)->color_func();
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.49 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d47 1
a47 1
#include "_dm.h"
a66 1
static int	X_setup();
d68 1
a85 2
static void X_load_startup();

d102 1
a102 1
  0,
d105 1
a105 1
  X_window, X_debug, 0, 0,
a116 1
extern Tcl_Interp *interp;
d123 1
a123 1
X_init(dmp, color_func)
d126 2
d129 8
d161 164
a324 1
  return X_setup(dmp);
d354 1
a354 1
  bu_free(dmp->dmr_vars, "X_close: dmp->dmr_vars");
a798 179
}

static int
X_setup( dmp )
struct dm *dmp;
{
  static int count = 0;
  int first_event, first_error;
  char *cp;
  XGCValues gcv;
  XColor a_color;
  Visual *a_visual;
  int a_screen;
  Colormap  a_cmap;
  struct bu_vls str;
  Display *tmp_dpy;

  bu_vls_init(&str);

  /* Only need to do this once for this display manager */
  if(!count)
    X_load_startup(dmp);

  if(BU_LIST_IS_EMPTY(&head_x_vars.l))
    Tk_CreateGenericHandler(dmp->dmr_eventhandler, (ClientData)NULL);

  BU_LIST_APPEND(&head_x_vars.l, &((struct x_vars *)dmp->dmr_vars)->l);

  bu_vls_printf(&dmp->dmr_pathName, ".dm_x%d", count++);

  /* Make xtkwin a toplevel window */
  ((struct x_vars *)dmp->dmr_vars)->xtkwin = Tk_CreateWindowFromPath(interp, tkwin,
				       bu_vls_addr(&dmp->dmr_pathName), dmp->dmr_dname);

  /*
   * Create the X drawing window by calling init_x which
   * is defined in xinit.tcl
   */
  bu_vls_strcpy(&str, "init_x ");
  bu_vls_printf(&str, "%s\n", bu_vls_addr(&dmp->dmr_pathName));

  if(Tcl_Eval(interp, bu_vls_addr(&str)) == TCL_ERROR){
    bu_vls_free(&str);
    return TCL_ERROR;
  }

  bu_vls_free(&str);

  ((struct x_vars *)dmp->dmr_vars)->dpy = Tk_Display(((struct x_vars *)dmp->dmr_vars)->xtkwin);
  ((struct x_vars *)dmp->dmr_vars)->width =
    DisplayWidth(((struct x_vars *)dmp->dmr_vars)->dpy,
		 DefaultScreen(((struct x_vars *)dmp->dmr_vars)->dpy)) - 20;
  ((struct x_vars *)dmp->dmr_vars)->height =
    DisplayHeight(((struct x_vars *)dmp->dmr_vars)->dpy,
		  DefaultScreen(((struct x_vars *)dmp->dmr_vars)->dpy)) - 20;

  /* Make window square */
  if(((struct x_vars *)dmp->dmr_vars)->height < ((struct x_vars *)dmp->dmr_vars)->width)
    ((struct x_vars *)dmp->dmr_vars)->width = ((struct x_vars *)dmp->dmr_vars)->height;
  else
    ((struct x_vars *)dmp->dmr_vars)->height = ((struct x_vars *)dmp->dmr_vars)->width;

  Tk_GeometryRequest(((struct x_vars *)dmp->dmr_vars)->xtkwin,
		     ((struct x_vars *)dmp->dmr_vars)->width, 
		     ((struct x_vars *)dmp->dmr_vars)->height);

#if 0
  /*XXX*/
  XSynchronize(((struct x_vars *)dmp->dmr_vars)->dpy, TRUE);
#endif

  Tk_MakeWindowExist(((struct x_vars *)dmp->dmr_vars)->xtkwin);
  ((struct x_vars *)dmp->dmr_vars)->win =
      Tk_WindowId(((struct x_vars *)dmp->dmr_vars)->xtkwin);

  ((struct x_vars *)dmp->dmr_vars)->pix = Tk_GetPixmap(((struct x_vars *)dmp->dmr_vars)->dpy,
    DefaultRootWindow(((struct x_vars *)dmp->dmr_vars)->dpy), ((struct x_vars *)dmp->dmr_vars)->width,
    ((struct x_vars *)dmp->dmr_vars)->height, Tk_Depth(((struct x_vars *)dmp->dmr_vars)->xtkwin));

  a_screen = Tk_ScreenNumber(((struct x_vars *)dmp->dmr_vars)->xtkwin);
  a_visual = Tk_Visual(((struct x_vars *)dmp->dmr_vars)->xtkwin);

  /* Get color map indices for the colors we use. */
  ((struct x_vars *)dmp->dmr_vars)->black = BlackPixel( ((struct x_vars *)dmp->dmr_vars)->dpy, a_screen );
  ((struct x_vars *)dmp->dmr_vars)->white = WhitePixel( ((struct x_vars *)dmp->dmr_vars)->dpy, a_screen );

#if TRY_COLOR_CUBE
  ((struct x_vars *)dmp->dmr_vars)->cmap = a_cmap = Tk_Colormap(((struct x_vars *)dmp->dmr_vars)->xtkwin);
#else
  a_cmap = Tk_Colormap(((struct x_vars *)dmp->dmr_vars)->xtkwin);
#endif
  a_color.red = 255<<8;
  a_color.green=0;
  a_color.blue=0;
  a_color.flags = DoRed | DoGreen| DoBlue;
  if ( ! XAllocColor(((struct x_vars *)dmp->dmr_vars)->dpy, a_cmap, &a_color)) {
    Tcl_AppendResult(interp, "dm-X: Can't Allocate red\n", (char *)NULL);
    return TCL_ERROR;
  }
  ((struct x_vars *)dmp->dmr_vars)->red = a_color.pixel;
    if ( ((struct x_vars *)dmp->dmr_vars)->red == ((struct x_vars *)dmp->dmr_vars)->white )
      ((struct x_vars *)dmp->dmr_vars)->red = ((struct x_vars *)dmp->dmr_vars)->black;

    a_color.red = 200<<8;
    a_color.green=200<<8;
    a_color.blue=0<<8;
    a_color.flags = DoRed | DoGreen| DoBlue;
    if ( ! XAllocColor(((struct x_vars *)dmp->dmr_vars)->dpy, a_cmap, &a_color)) {
      Tcl_AppendResult(interp, "dm-X: Can't Allocate yellow\n", (char *)NULL);
      return TCL_ERROR;
    }
    ((struct x_vars *)dmp->dmr_vars)->yellow = a_color.pixel;
    if ( ((struct x_vars *)dmp->dmr_vars)->yellow == ((struct x_vars *)dmp->dmr_vars)->white )
      ((struct x_vars *)dmp->dmr_vars)->yellow = ((struct x_vars *)dmp->dmr_vars)->black;
    
    a_color.red = 0;
    a_color.green=0;
    a_color.blue=255<<8;
    a_color.flags = DoRed | DoGreen| DoBlue;
    if ( ! XAllocColor(((struct x_vars *)dmp->dmr_vars)->dpy, a_cmap, &a_color)) {
      Tcl_AppendResult(interp, "dm-X: Can't Allocate blue\n", (char *)NULL);
      return TCL_ERROR;
    }
    ((struct x_vars *)dmp->dmr_vars)->blue = a_color.pixel;
    if ( ((struct x_vars *)dmp->dmr_vars)->blue == ((struct x_vars *)dmp->dmr_vars)->white )
      ((struct x_vars *)dmp->dmr_vars)->blue = ((struct x_vars *)dmp->dmr_vars)->black;

    a_color.red = 128<<8;
    a_color.green=128<<8;
    a_color.blue= 128<<8;
    a_color.flags = DoRed | DoGreen| DoBlue;
    if ( ! XAllocColor(((struct x_vars *)dmp->dmr_vars)->dpy, a_cmap, &a_color)) {
      Tcl_AppendResult(interp, "dm-X: Can't Allocate gray\n", (char *)NULL);
      return TCL_ERROR;
    }
    ((struct x_vars *)dmp->dmr_vars)->gray = a_color.pixel;
    if ( ((struct x_vars *)dmp->dmr_vars)->gray == ((struct x_vars *)dmp->dmr_vars)->white )
      ((struct x_vars *)dmp->dmr_vars)->gray = ((struct x_vars *)dmp->dmr_vars)->black;

    /* Select border, background, foreground colors,
     * and border width.
     */
    if( a_visual->class == GrayScale || a_visual->class == StaticGray ) {
	((struct x_vars *)dmp->dmr_vars)->is_monochrome = 1;
	((struct x_vars *)dmp->dmr_vars)->bd = BlackPixel( ((struct x_vars *)dmp->dmr_vars)->dpy, a_screen );
	((struct x_vars *)dmp->dmr_vars)->bg = WhitePixel( ((struct x_vars *)dmp->dmr_vars)->dpy, a_screen );
	((struct x_vars *)dmp->dmr_vars)->fg = BlackPixel( ((struct x_vars *)dmp->dmr_vars)->dpy, a_screen );
    } else {
	/* Hey, it's a color server.  Ought to use 'em! */
	((struct x_vars *)dmp->dmr_vars)->is_monochrome = 0;
	((struct x_vars *)dmp->dmr_vars)->bd = WhitePixel( ((struct x_vars *)dmp->dmr_vars)->dpy, a_screen );
	((struct x_vars *)dmp->dmr_vars)->bg = BlackPixel( ((struct x_vars *)dmp->dmr_vars)->dpy, a_screen );
	((struct x_vars *)dmp->dmr_vars)->fg = WhitePixel( ((struct x_vars *)dmp->dmr_vars)->dpy, a_screen );
    }

    if( !((struct x_vars *)dmp->dmr_vars)->is_monochrome &&
	((struct x_vars *)dmp->dmr_vars)->fg != ((struct x_vars *)dmp->dmr_vars)->red &&
	((struct x_vars *)dmp->dmr_vars)->red != ((struct x_vars *)dmp->dmr_vars)->black )
      ((struct x_vars *)dmp->dmr_vars)->fg = ((struct x_vars *)dmp->dmr_vars)->red;

    gcv.foreground = ((struct x_vars *)dmp->dmr_vars)->fg;
    gcv.background = ((struct x_vars *)dmp->dmr_vars)->bg;
    ((struct x_vars *)dmp->dmr_vars)->gc = XCreateGC(((struct x_vars *)dmp->dmr_vars)->dpy,
					       ((struct x_vars *)dmp->dmr_vars)->win,
					       (GCForeground|GCBackground),
					       &gcv);

#if TRY_COLOR_CUBE
    allocate_color_cube(dmp);
#endif

#ifndef CRAY2
    X_configure_window_shape(dmp);
#endif

    Tk_SetWindowBackground(((struct x_vars *)dmp->dmr_vars)->xtkwin, ((struct x_vars *)dmp->dmr_vars)->bg);
    Tk_MapWindow(((struct x_vars *)dmp->dmr_vars)->xtkwin);

    return TCL_OK;
@
