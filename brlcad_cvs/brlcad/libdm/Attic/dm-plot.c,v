head	1.38;
access;
symbols
	ansi-20040405-merged:1.32.2.3
	postmerge-20040405-ansi:1.35
	premerge-20040404-ansi:1.34
	postmerge-autoconf:1.34
	autoconf-freeze:1.32.10.3
	premerge-autoconf:1.34
	ansi-20040316-freeze:1.32.2.1
	postmerge-20040315-windows:1.34
	premerge-20040315-windows:1.33
	windows-20040315-freeze:1.32.4.2
	autoconf-20031203:1.32
	autoconf-20031202:1.32
	autoconf-branch:1.32.0.10
	phong-branch:1.32.0.8
	photonmap-branch:1.32.0.6
	rel-6-1-DP:1.32
	windows-branch:1.32.0.4
	rel-6-0-2:1.30
	ansi-branch:1.32.0.2
	rel-6-0-1-branch:1.30.0.2
	hartley-6-0-post:1.31
	hartley-6-0-pre:1.30
	rel-6-0-1:1.30
	rel-6-0:1.30
	rel-5-4:1.24.2.1
	offsite-5-3-pre:1.28
	rel-5-3:1.24.2.1
	rel-5-2:1.24.2.1
	rel-5-1-branch:1.24.0.2
	rel-5-1:1.24
	rel-5-0:1.21
	rel-5-0-beta:1.21
	rel-4-5:1.17
	ctj-4-5-post:1.14
	ctj-4-5-pre:1.14;
locks; strict;
comment	@ * @;


1.38
date	2004.05.21.18.06.25;	author morrison;	state dead;
branches;
next	1.37;

1.37
date	2004.05.10.15.30.44;	author erikg;	state Exp;
branches;
next	1.36;

1.36
date	2004.05.10.15.25.26;	author morrison;	state Exp;
branches;
next	1.35;

1.35
date	2004.04.05.07.45.07;	author morrison;	state Exp;
branches;
next	1.34;

1.34
date	2004.03.16.19.41.54;	author morrison;	state Exp;
branches;
next	1.33;

1.33
date	2004.02.02.17.39.08;	author morrison;	state Exp;
branches;
next	1.32;

1.32
date	2002.08.20.17.07.44;	author jra;	state Exp;
branches
	1.32.2.1
	1.32.4.1
	1.32.10.1;
next	1.31;

1.31
date	2002.08.15.20.54.57;	author hartley;	state Exp;
branches;
next	1.30;

1.30
date	2001.04.02.21.38.01;	author morrison;	state Exp;
branches;
next	1.29;

1.29
date	2001.03.31.01.56.52;	author morrison;	state Exp;
branches;
next	1.28;

1.28
date	2000.10.18.18.10.33;	author butler;	state Exp;
branches;
next	1.27;

1.27
date	2000.08.31.18.16.42;	author bparker;	state Exp;
branches;
next	1.26;

1.26
date	2000.07.12.03.24.44;	author cjohnson;	state Exp;
branches;
next	1.25;

1.25
date	2000.06.30.20.54.06;	author bparker;	state Exp;
branches;
next	1.24;

1.24
date	99.12.27.21.10.48;	author bparker;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	99.12.17.16.38.47;	author bparker;	state Exp;
branches;
next	1.22;

1.22
date	99.12.01.13.30.20;	author bparker;	state Exp;
branches;
next	1.21;

1.21
date	98.06.15.18.55.06;	author bparker;	state Exp;
branches;
next	1.20;

1.20
date	98.06.12.19.48.18;	author bparker;	state Exp;
branches;
next	1.19;

1.19
date	98.03.03.14.59.13;	author jra;	state Exp;
branches;
next	1.18;

1.18
date	98.02.26.15.22.56;	author bparker;	state Exp;
branches;
next	1.17;

1.17
date	97.11.03.20.09.50;	author bparker;	state Exp;
branches;
next	1.16;

1.16
date	97.10.10.12.56.09;	author bparker;	state Exp;
branches;
next	1.15;

1.15
date	97.09.23.21.14.42;	author bparker;	state Exp;
branches;
next	1.14;

1.14
date	97.05.21.13.02.59;	author bparker;	state Exp;
branches;
next	1.13;

1.13
date	97.05.08.14.19.47;	author bparker;	state Exp;
branches;
next	1.12;

1.12
date	97.04.24.18.14.07;	author bparker;	state Exp;
branches;
next	1.11;

1.11
date	97.04.23.18.38.24;	author bparker;	state Exp;
branches;
next	1.10;

1.10
date	97.04.22.15.04.46;	author bparker;	state Exp;
branches;
next	1.9;

1.9
date	97.03.03.18.31.49;	author bparker;	state Exp;
branches;
next	1.8;

1.8
date	97.01.17.23.01.25;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	97.01.02.20.06.37;	author bparker;	state Exp;
branches;
next	1.6;

1.6
date	96.12.04.21.30.49;	author bparker;	state Exp;
branches;
next	1.5;

1.5
date	96.10.23.20.28.49;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	96.09.30.19.40.38;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	96.09.26.20.37.27;	author bparker;	state Exp;
branches;
next	1.2;

1.2
date	96.09.25.20.27.08;	author bparker;	state Exp;
branches;
next	1.1;

1.1
date	96.09.23.17.58.10;	author bparker;	state Exp;
branches;
next	;

1.24.2.1
date	2000.09.01.17.24.42;	author bparker;	state Exp;
branches;
next	;

1.32.2.1
date	2002.09.19.18.01.17;	author morrison;	state Exp;
branches;
next	1.32.2.2;

1.32.2.2
date	2004.03.17.21.16.58;	author morrison;	state Exp;
branches;
next	1.32.2.3;

1.32.2.3
date	2004.04.02.16.04.34;	author morrison;	state Exp;
branches;
next	;

1.32.4.1
date	2002.09.26.23.03.53;	author morrison;	state Exp;
branches;
next	1.32.4.2;

1.32.4.2
date	2004.03.11.23.42.01;	author morrison;	state Exp;
branches;
next	;

1.32.10.1
date	2004.02.12.19.45.18;	author erikg;	state Exp;
branches;
next	1.32.10.2;

1.32.10.2
date	2004.03.15.14.06.18;	author erikg;	state Exp;
branches;
next	1.32.10.3;

1.32.10.3
date	2004.03.18.18.10.27;	author erikg;	state Exp;
branches;
next	;


desc
@Unix Plot Display Manager
@


1.38
log
@moved to src/
@
text
@/*
 *			D M - P L O T . C
 *
 * An unsatisfying (but useful) hack to allow GED to generate
 * UNIX-plot files that not only contain the drawn objects, but
 * also contain the faceplate display as well.
 * Mostly, a useful hack for making viewgraphs and photographs
 * of an editing session.
 * We assume that the UNIX-plot filter used can at least discard
 * the non-standard extention to specify color (a Gwyn@@BRL addition).
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libdm/dm-plot.c,v 1.37 2004/05/10 15:30:44 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include "tcl.h"

#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif

#ifndef WIN32
#include <sys/time.h>		/* for struct timeval */
#endif
#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "mater.h"
#include "raytrace.h"
#include "dm.h"
#include "dm-plot.h"
#include "solid.h"
#include "plot3.h"

/* Display Manager package interface */

#define PLOTBOUND	1000.0	/* Max magnification in Rot matrix */
struct dm	*plot_open(Tcl_Interp *interp, int argc, char **argv);
static int	plot_close(struct dm *dmp);
static int	plot_drawBegin(struct dm *dmp), plot_drawEnd(struct dm *dmp);
static int	plot_normal(struct dm *dmp), plot_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye);
static int	plot_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect), plot_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2);
static int      plot_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y);
static int	plot_drawVList(struct dm *dmp, register struct bn_vlist *vp);
static int      plot_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict, fastf_t transparency);
static int      plot_setBGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b);
static int      plot_setLineAttr(struct dm *dmp, int width, int style);
static int	plot_setWinBounds(struct dm *dmp, register int *w), plot_debug(struct dm *dmp, int lvl);

struct dm dm_plot = {
  plot_close,
  plot_drawBegin,
  plot_drawEnd,
  plot_normal,
  plot_loadMatrix,
  plot_drawString2D,
  plot_drawLine2D,
  plot_drawPoint2D,
  plot_drawVList,
  plot_setFGColor,
  plot_setBGColor,
  plot_setLineAttr,
  Nu_int0,
  plot_setWinBounds,
  Nu_int0,
  Nu_int0,
  Nu_int0,
  Nu_int0,
  plot_debug,
  Nu_int0,
  Nu_int0,
  Nu_int0,
  Nu_int0,
  0,
  0,				/* no displaylist */
  0,				/* no stereo */
  PLOTBOUND,			/* zoom-in limit */
  1,				/* bound flag */
  "plot",
  "Screen to UNIX-Plot",
  DM_TYPE_PLOT,
  0,
  0,
  0,
  0,
  0,
  1.0, /* aspect ratio */
  0,
  {0, 0},
  {0, 0, 0, 0, 0},		/* bu_vls path name*/
  {0, 0, 0, 0, 0},		/* bu_vls full name drawing window */
  {0, 0, 0, 0, 0},		/* bu_vls short name drawing window */
  {0, 0, 0},			/* bg color */
  {0, 0, 0},			/* fg color */
  {0.0, 0.0, 0.0},		/* clipmin */
  {0.0, 0.0, 0.0},		/* clipmax */
  0,				/* no debugging */
  0,				/* no perspective */
  0,				/* no lighting */
  0,				/* no transparency */
  0,				/* no zbuffer */
  0,				/* no zclipping */
  0				/* Tcl interpreter */
};

struct plot_vars head_plot_vars;
static mat_t plotmat;

/*
 *			P L O T _ O P E N
 *
 * Fire up the display manager, and the display processor.
 *
 */
struct dm *
plot_open(Tcl_Interp *interp, int argc, char **argv)
{
	static int	count = 0;
	struct dm	*dmp;
	Tcl_Obj		*obj;

	BU_GETSTRUCT(dmp, dm);
	if (dmp == DM_NULL)
		return DM_NULL;

	*dmp = dm_plot; /* struct copy */
	dmp->dm_interp = interp;

	dmp->dm_vars.priv_vars = (genptr_t)bu_calloc(1, sizeof(struct plot_vars), "plot_open: plot_vars");
	BU_GETSTRUCT(dmp->dm_vars.priv_vars, plot_vars);
	if (dmp->dm_vars.priv_vars == (genptr_t)NULL) {
		bu_free(dmp, "plot_open: dmp");
		return DM_NULL;
	}

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);

	bu_vls_init(&((struct plot_vars *)dmp->dm_vars.priv_vars)->vls);
	bu_vls_init(&dmp->dm_pathName);
	bu_vls_init(&dmp->dm_tkName);
	bu_vls_printf(&dmp->dm_pathName, ".dm_plot%d", count++);
	bu_vls_printf(&dmp->dm_tkName, "dm_plot%d", count++);

	/* skip first argument */
	--argc; ++argv;

	/* Process any options */
	((struct plot_vars *)dmp->dm_vars.priv_vars)->is_3D = 1;          /* 3-D w/color, by default */
	while (argv[0] != (char *)0 && argv[0][0] == '-') {
		switch (argv[0][1]) {
		case '3':
			break;
		case '2':
			((struct plot_vars *)dmp->dm_vars.priv_vars)->is_3D = 0;		/* 2-D, for portability */
			break;
		case 'g':
			((struct plot_vars *)dmp->dm_vars.priv_vars)->grid = 1;
			break;
		case 'f':
			((struct plot_vars *)dmp->dm_vars.priv_vars)->floating = 1;
			break;
		case 'z':
		case 'Z':
			/* Enable Z clipping */
			Tcl_AppendStringsToObj(obj, "Clipped in Z to viewing cube\n", (char *)NULL);
#if 0
			((struct plot_vars *)dmp->dm_vars.priv_vars)->zclip = 1;
#else
			dmp->dm_zclip = 1;
#endif
			break;
		default:
			Tcl_AppendStringsToObj(obj, "bad PLOT option ", argv[0], "\n", (char *)NULL);
			(void)plot_close(dmp);

			Tcl_SetObjResult(interp, obj);
			return DM_NULL;
		}
		argv++;
	}
	if (argv[0] == (char *)0) {
		Tcl_AppendStringsToObj(obj, "no filename or filter specified\n", (char *)NULL);
		(void)plot_close(dmp);

		Tcl_SetObjResult(interp, obj);
		return DM_NULL;
	}

	if (argv[0][0] == '|') {
		bu_vls_strcpy(&((struct plot_vars *)dmp->dm_vars.priv_vars)->vls, &argv[0][1]);
		while( (++argv)[0] != (char *)0 ) {
			bu_vls_strcat( &((struct plot_vars *)dmp->dm_vars.priv_vars)->vls, " " );
			bu_vls_strcat( &((struct plot_vars *)dmp->dm_vars.priv_vars)->vls, argv[0] );
		}

		((struct plot_vars *)dmp->dm_vars.priv_vars)->is_pipe = 1;
	} else {
		bu_vls_strcpy(&((struct plot_vars *)dmp->dm_vars.priv_vars)->vls, argv[0]);
	}

	if (((struct plot_vars *)dmp->dm_vars.priv_vars)->is_pipe) {
		if ((((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp =
		     popen( bu_vls_addr(&((struct plot_vars *)dmp->dm_vars.priv_vars)->vls), "w")) == NULL) {
			perror( bu_vls_addr(&((struct plot_vars *)dmp->dm_vars.priv_vars)->vls));
			(void)plot_close(dmp);
			Tcl_SetObjResult(interp, obj);
			return DM_NULL;
		}
    
		Tcl_AppendStringsToObj(obj, "piped to ",
				 bu_vls_addr(&((struct plot_vars *)dmp->dm_vars.priv_vars)->vls),
				 "\n", (char *)NULL);
	} else {
		if ((((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp =
		     fopen( bu_vls_addr(&((struct plot_vars *)dmp->dm_vars.priv_vars)->vls), "w" )) == NULL) {
			perror(bu_vls_addr(&((struct plot_vars *)dmp->dm_vars.priv_vars)->vls));
			(void)plot_close(dmp);
			Tcl_SetObjResult(interp, obj);
			return DM_NULL;
		}

		Tcl_AppendStringsToObj(obj, "plot stored in ",
				 bu_vls_addr(&((struct plot_vars *)dmp->dm_vars.priv_vars)->vls),
				 "\n", (char *)NULL);
	}

	setbuf(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp,
	       ((struct plot_vars *)dmp->dm_vars.priv_vars)->ttybuf);

	if (((struct plot_vars *)dmp->dm_vars.priv_vars)->is_3D)
		pl_3space(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp,
			  -2048, -2048, -2048, 2048, 2048, 2048);
	else
		pl_space(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp,
			 -2048, -2048, 2048, 2048);

	MAT_IDN(plotmat);

	Tcl_SetObjResult(interp, obj);
	return dmp;
}

/*
 *  			P L O T _ C L O S E
 *  
 *  Gracefully release the display.
 */
static int
plot_close(struct dm *dmp)
{
	(void)fflush(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp);

	if (((struct plot_vars *)dmp->dm_vars.priv_vars)->is_pipe)
		pclose(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp); /* close pipe, eat dead children */
	else
		fclose(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp);

	bu_vls_free(&dmp->dm_pathName);
	bu_free(dmp->dm_vars.priv_vars, "plot_close: plot_vars");
	bu_free(dmp, "plot_close: dmp");
	return TCL_OK;
}

/*
 *			P L O T _ P R O L O G
 *
 * There are global variables which are parameters to this routine.
 */
static int
plot_drawBegin(struct dm *dmp)
{
	/* We expect the screen to be blank so far, from last frame flush */

	return TCL_OK;
}

/*
 *			P L O T _ E P I L O G
 */
static int
plot_drawEnd(struct dm *dmp)
{
	pl_flush(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp); /* BRL-specific command */
	pl_erase(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp); /* forces drawing */
	(void)fflush(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp);

	return TCL_OK;
}

/*
 *  			P L O T _ L O A D M A T R I X
 *
 *  Load a new transformation matrix.  This will be followed by
 *  many calls to plot_drawVList().
 */
static int
plot_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye)
{
	Tcl_Obj	*obj;

	obj = Tcl_GetObjResult(dmp->dm_interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);

	if (((struct plot_vars *)dmp->dm_vars.priv_vars)->debug) {
		struct bu_vls tmp_vls;

		Tcl_AppendStringsToObj(obj, "plot_loadMatrix()\n", (char *)NULL);

		bu_vls_init(&tmp_vls);
		bu_vls_printf(&tmp_vls, "which eye = %d\t", which_eye);
		bu_vls_printf(&tmp_vls, "transformation matrix = \n");
		bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[0], mat[4], mat[8],mat[12]);
		bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[1], mat[5], mat[9],mat[13]);
		bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[2], mat[6], mat[10],mat[14]);
		bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[3], mat[7], mat[11],mat[15]);

		Tcl_AppendStringsToObj(obj, bu_vls_addr(&tmp_vls), (char *)NULL);
		bu_vls_free(&tmp_vls);
	}

	MAT_COPY(plotmat, mat);
	Tcl_SetObjResult(dmp->dm_interp, obj);
	return TCL_OK;
}

/*
 *  			P L O T _ O B J E C T
 *  
 *  Set up for an object, transformed as indicated, and with an
 *  object center as specified.  The ratio of object to screen size
 *  is passed in as a convienience.
 *
 *  Returns 0 if object could be drawn, !0 if object was omitted.
 */
static int
plot_drawVList(struct dm *dmp, register struct bn_vlist *vp)
{
	static vect_t			last;
	register struct rt_vlist	*tvp;
	register point_t		*pt_prev=NULL;
	register fastf_t		dist_prev=1.0;
	register fastf_t		dist;
	fastf_t				delta;
	int				useful = 0;

	if (((struct plot_vars *)dmp->dm_vars.priv_vars)->floating) {
		rt_vlist_to_uplot(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp, &vp->l);
		      
		return TCL_OK;
	}

	/* delta is used in clipping to insure clipped endpoint is slightly
	 * in front of eye plane (perspective mode only).
	 * This value is a SWAG that seems to work OK.
	 */
	delta = plotmat[15]*0.0001;
	if (delta < 0.0)
		delta = -delta;
	if (delta < SQRT_SMALL_FASTF)
		delta = SQRT_SMALL_FASTF;

	for (BU_LIST_FOR(tvp, rt_vlist, &vp->l)) {
		register int	i;
		register int	nused = tvp->nused;
		register int	*cmd = tvp->cmd;
		register point_t *pt = tvp->pt;
		for (i = 0; i < nused; i++,cmd++,pt++) {
			static vect_t	start, fin;
			switch (*cmd) {
			case RT_VLIST_POLY_START:
			case RT_VLIST_POLY_VERTNORM:
				continue;
			case RT_VLIST_POLY_MOVE:
			case RT_VLIST_LINE_MOVE:
				/* Move, not draw */
				if (dmp->dm_perspective > 0) {
					/* cannot apply perspective transformation to
					 * points behind eye plane!!!!
					 */
					dist = VDOT( *pt, &plotmat[12] ) + plotmat[15];
					if (dist <= 0.0) {
						pt_prev = pt;
						dist_prev = dist;
						continue;
					} else {
						MAT4X3PNT(last, plotmat, *pt);
						dist_prev = dist;
						pt_prev = pt;
					}
				} else
					MAT4X3PNT(last, plotmat, *pt);
				continue;
			case RT_VLIST_POLY_DRAW:
			case RT_VLIST_POLY_END:
			case RT_VLIST_LINE_DRAW:
	/* draw */
				if (dmp->dm_perspective > 0) {
					/* cannot apply perspective transformation to
					 * points behind eye plane!!!!
					 */
					dist = VDOT( *pt, &plotmat[12] ) + plotmat[15];
					if (dist <= 0.0) {
						if (dist_prev <= 0.0) {
							/* nothing to plot */
							dist_prev = dist;
							pt_prev = pt;
							continue;
						} else {
							fastf_t alpha;
							vect_t diff;
							point_t tmp_pt;

							/* clip this end */
							VSUB2( diff, *pt, *pt_prev );
							alpha = (dist_prev - delta) / (dist_prev - dist);
							VJOIN1(tmp_pt, *pt_prev, alpha, diff);
							MAT4X3PNT(fin, plotmat, tmp_pt);
						}
					} else {
						if (dist_prev <= 0.0) {
							fastf_t alpha;
							vect_t diff;
							point_t tmp_pt;

							/* clip other end */
							VSUB2( diff, *pt, *pt_prev );
							alpha = (-dist_prev + delta) / ( dist - dist_prev );
							VJOIN1( tmp_pt, *pt_prev, alpha, diff );
							MAT4X3PNT( last, plotmat, tmp_pt );
							MAT4X3PNT( fin, plotmat, *pt );
						} else {
							MAT4X3PNT( fin, plotmat, *pt );
						}
					}
				} else
					MAT4X3PNT( fin, plotmat, *pt );
				VMOVE( start, last );
				VMOVE( last, fin );
				break;
			}
			if (vclip(start, fin, dmp->dm_clipmin, dmp->dm_clipmax) == 0)
				continue;

			if (((struct plot_vars *)dmp->dm_vars.priv_vars)->is_3D)
				pl_3line(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp, 
					 (int)(start[X] * 2047),
					 (int)(start[Y] * 2047),
					 (int)(start[Z] * 2047),
					 (int)(fin[X] * 2047),
					 (int)(fin[Y] * 2047),
					 (int)(fin[Z] * 2047));
			else
				pl_line(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp, 
					(int)(start[X] * 2047),
					(int)(start[Y] * 2047),
					(int)(fin[X] * 2047),
					(int)(fin[Y] * 2047));

			useful = 1;
		}
	}

	if (useful)
		return TCL_OK;

	return TCL_ERROR;
}

/*
 *			P L O T _ N O R M A L
 *
 * Restore the display processor to a normal mode of operation
 * (ie, not scaled, rotated, displaced, etc).
 * Turns off windowing.
 */
static int
plot_normal(struct dm *dmp)
{
	return TCL_OK;
}


/*
 *			P L O T _ P U T S
 *
 * Output a string into the displaylist.
 * The starting position of the beam is as specified.
 */
/* ARGSUSED */
static int
plot_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect)
{
	int	sx, sy;

	sx = x * 2047;
	sy = y + 2047;
	pl_move(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp, sx, sy);
	pl_label(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp, str);

	return TCL_OK;
}

/*
 *			P L O T _ 2 D _ G O T O
 *
 */
static int
plot_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2)
{
	int	sx1, sy1;
	int	sx2, sy2;

	sx1 = x1 * 2047;
	sx2 = x2 * 2047;
	sy1 = y1 + 2047;
	sy2 = y2 + 2047;
	pl_move(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp, sx1, sy1);
	pl_cont(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp, sx2, sy2);

	return TCL_OK;
}


static int
plot_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y)
{
	return plot_drawLine2D(dmp, x, y, x, y);
}


static int
plot_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict, fastf_t transparency)
{
	pl_color(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp, (int)r, (int)g, (int)b);
	return TCL_OK;
}
static int
plot_setBGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b)
{
	return TCL_OK;
}


static int
plot_setLineAttr(struct dm *dmp, int width, int style)
{
	dmp->dm_lineWidth = width;
	dmp->dm_lineStyle = style;

	if (style == DM_DASHED_LINE)
		pl_linmod(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp, "dotdashed");
	else
		pl_linmod(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp, "solid");

	return TCL_OK;
}

/* ARGSUSED */
static int
plot_debug(struct dm *dmp, int lvl)
{
	Tcl_Obj	*obj;

	obj = Tcl_GetObjResult(dmp->dm_interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);

	dmp->dm_debugLevel = lvl;
	(void)fflush(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp);
	Tcl_AppendStringsToObj(obj, "flushed\n", (char *)NULL);

	Tcl_SetObjResult(dmp->dm_interp, obj);
	return TCL_OK;
}

static int
plot_setWinBounds(struct dm *dmp, register int *w)
{
	/* Compute the clipping bounds */
	dmp->dm_clipmin[0] = w[0] / 2048.;
	dmp->dm_clipmax[0] = w[1] / 2047.;
	dmp->dm_clipmin[1] = w[2] / 2048.;
	dmp->dm_clipmax[1] = w[3] / 2047.;

	if (dmp->dm_zclip) {
		dmp->dm_clipmin[2] = w[4] / 2048.;
		dmp->dm_clipmax[2] = w[5] / 2047.;
	} else {
		dmp->dm_clipmin[2] = -1.0e20;
		dmp->dm_clipmax[2] = 1.0e20;
	}

	return TCL_OK;
}
@


1.37
log
@change conf.h to a wrapped config.h
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/libdm/dm-plot.c,v 1.36 2004/05/10 15:25:26 morrison Exp $ (BRL)";
@


1.36
log
@Bob Parker's view modifications, png framebuffer support, shaded drawing mode
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-plot.c,v 1.35 2004/04/05 07:45:07 morrison Exp $ (BRL)";
d28 5
a32 1
#include "conf.h"
@


1.35
log
@merge of ansi-6-0-branch into HEAD
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d61 1
a61 1
static int      plot_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict);
d83 2
d116 1
d551 1
a551 1
plot_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict)
@


1.34
log
@merge of windows-6-0-branch into head
@
text
@d54 11
a64 10
struct dm	*plot_open();
static int	plot_close();
static int	plot_drawBegin(), plot_drawEnd();
static int	plot_normal(), plot_loadMatrix();
static int	plot_drawString2D(), plot_drawLine2D();
static int      plot_drawPoint2D();
static int	plot_drawVList();
static int      plot_setFGColor();
static int      plot_setLineAttr();
static int	plot_setWinBounds(), plot_debug();
d77 1
a77 1
  Nu_int0,
d129 1
a129 4
plot_open(interp, argc, argv)
     int	argc;
     char	*argv[];
     Tcl_Interp *interp;
d264 1
a264 2
plot_close(dmp)
     struct dm	*dmp;
d285 1
a285 2
plot_drawBegin(dmp)
     struct dm	*dmp;
d296 1
a296 2
plot_drawEnd(dmp)
     struct dm	*dmp;
d312 1
a312 4
plot_loadMatrix(dmp, mat, which_eye)
     struct dm	*dmp;
     mat_t	mat;
     int	which_eye;
d352 1
a352 3
plot_drawVList(dmp, vp)
     struct dm			*dmp;
     register struct rt_vlist	*vp;
d493 1
a493 2
plot_normal(dmp)
     struct dm	*dmp;
d507 1
a507 6
plot_drawString2D( dmp, str, x, y, size, use_aspect )
     struct dm		*dmp;
     register char	*str;
     fastf_t		x, y;
     int		size;
     int		use_aspect;
d524 1
a524 4
plot_drawLine2D( dmp, x1, y1, x2, y2 )
     struct dm	*dmp;
     fastf_t	x1, y1;
     fastf_t	x2, y2;
d541 1
a541 3
plot_drawPoint2D(dmp, x, y)
     struct dm	*dmp;
     fastf_t	x, y;
d548 1
a548 4
plot_setFGColor(dmp, r, g, b, strict)
     struct dm		*dmp;
     unsigned char	r, g, b;
     int		strict;
d553 5
d561 1
a561 4
plot_setLineAttr(dmp, width, style)
     struct dm	*dmp;
     int	width;
     int	style;
d576 1
a576 2
plot_debug(dmp, lvl)
     struct dm	*dmp;
d593 1
a593 3
plot_setWinBounds(dmp, w)
     struct dm		*dmp;
     register int	w[];
@


1.33
log
@update copyright to include span through 2003
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-plot.c,v 1.32 2002/08/20 17:07:44 jra Exp $ (BRL)";
d36 1
d38 1
@


1.32
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1985 by the United States Army.
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-plot.c,v 1.30 2001/04/02 21:38:01 morrison Exp $ (BRL)";
@


1.32.10.1
log
@merge from HEAD
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-plot.c,v 1.33 2004/02/02 17:39:08 morrison Exp $ (BRL)";
@


1.32.10.2
log
@merge from head
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-plot.c,v 1.32.10.1 2004/02/12 19:45:18 erikg Exp $ (BRL)";
@


1.32.10.3
log
@merge from head
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a35 1
#ifndef WIN32
a36 1
#endif
@


1.32.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-plot.c,v 1.32 2002/08/20 17:07:44 jra Exp $ (BRL)";
a35 1
#ifndef WIN32
a36 1
#endif
@


1.32.4.2
log
@sync to HEAD...
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libdm/dm-plot.c,v 1.32.4.1 2002/09/26 23:03:53 morrison Exp $ (BRL)";
@


1.32.2.1
log
@Initial ANSIfication
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-plot.c,v 1.32 2002/08/20 17:07:44 jra Exp $ (BRL)";
d52 10
a61 10
struct dm	*plot_open(Tcl_Interp *interp, int argc, char **argv);
static int	plot_close(struct dm *dmp);
static int	plot_drawBegin(struct dm *dmp), plot_drawEnd(struct dm *dmp);
static int	plot_normal(struct dm *dmp), plot_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye);
static int	plot_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect), plot_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2);
static int      plot_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y);
static int	plot_drawVList(struct dm *dmp, register struct bn_vlist *vp);
static int      plot_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict);
static int      plot_setLineAttr(struct dm *dmp, int width, int style);
static int	plot_setWinBounds(struct dm *dmp, register int *w), plot_debug(struct dm *dmp, int lvl);
d126 4
a129 1
plot_open(Tcl_Interp *interp, int argc, char **argv)
d264 2
a265 1
plot_close(struct dm *dmp)
d286 2
a287 1
plot_drawBegin(struct dm *dmp)
d298 2
a299 1
plot_drawEnd(struct dm *dmp)
d315 4
a318 1
plot_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye)
d358 3
a360 1
plot_drawVList(struct dm *dmp, register struct bn_vlist *vp)
d501 2
a502 1
plot_normal(struct dm *dmp)
d516 6
a521 1
plot_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect)
d538 4
a541 1
plot_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2)
d558 3
a560 1
plot_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y)
d567 4
a570 1
plot_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict)
d578 4
a581 1
plot_setLineAttr(struct dm *dmp, int width, int style)
d596 2
a597 1
plot_debug(struct dm *dmp, int lvl)
d614 3
a616 1
plot_setWinBounds(struct dm *dmp, register int *w)
@


1.32.2.2
log
@sync branch with HEAD
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a35 1
#ifndef WIN32
a36 1
#endif
@


1.32.2.3
log
@replace null func with a real func for bg to parallel fg func
@
text
@a61 1
static int      plot_setBGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b);
d76 1
a76 1
  plot_setBGColor,
a549 5
	return TCL_OK;
}
static int
plot_setBGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b)
{
@


1.31
log
@Converted from K&R to ANSI C - RFH
@
text
@d52 10
a61 10
struct dm	*plot_open(Tcl_Interp *interp, int argc, char **argv);
static int	plot_close(struct dm *dmp);
static int	plot_drawBegin(struct dm *dmp), plot_drawEnd(struct dm *dmp);
static int	plot_normal(struct dm *dmp), plot_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye);
static int	plot_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect), plot_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2);
static int      plot_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y);
static int	plot_drawVList(struct dm *dmp, register struct bn_vlist *vp);
static int      plot_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict);
static int      plot_setLineAttr(struct dm *dmp, int width, int style);
static int	plot_setWinBounds(struct dm *dmp, register int *w), plot_debug(struct dm *dmp, int lvl);
d126 4
a129 1
plot_open(Tcl_Interp *interp, int argc, char **argv)
d264 2
a265 1
plot_close(struct dm *dmp)
d286 2
a287 1
plot_drawBegin(struct dm *dmp)
d298 2
a299 1
plot_drawEnd(struct dm *dmp)
d315 4
a318 1
plot_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye)
d358 3
a360 1
plot_drawVList(struct dm *dmp, register struct bn_vlist *vp)
d501 2
a502 1
plot_normal(struct dm *dmp)
d516 6
a521 1
plot_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect)
d538 4
a541 1
plot_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2)
d558 3
a560 1
plot_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y)
d567 4
a570 1
plot_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict)
d578 4
a581 1
plot_setLineAttr(struct dm *dmp, int width, int style)
d596 2
a597 1
plot_debug(struct dm *dmp, int lvl)
d614 3
a616 1
plot_setWinBounds(struct dm *dmp, register int *w)
@


1.30
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-plot.c,v 1.29 2001/03/31 01:56:52 morrison Exp $ (BRL)";
d52 10
a61 10
struct dm	*plot_open();
static int	plot_close();
static int	plot_drawBegin(), plot_drawEnd();
static int	plot_normal(), plot_loadMatrix();
static int	plot_drawString2D(), plot_drawLine2D();
static int      plot_drawPoint2D();
static int	plot_drawVList();
static int      plot_setFGColor();
static int      plot_setLineAttr();
static int	plot_setWinBounds(), plot_debug();
d126 1
a126 4
plot_open(interp, argc, argv)
     int	argc;
     char	*argv[];
     Tcl_Interp *interp;
d261 1
a261 2
plot_close(dmp)
     struct dm	*dmp;
d282 1
a282 2
plot_drawBegin(dmp)
     struct dm	*dmp;
d293 1
a293 2
plot_drawEnd(dmp)
     struct dm	*dmp;
d309 1
a309 4
plot_loadMatrix(dmp, mat, which_eye)
     struct dm	*dmp;
     mat_t	mat;
     int	which_eye;
d349 1
a349 3
plot_drawVList(dmp, vp)
     struct dm			*dmp;
     register struct rt_vlist	*vp;
d490 1
a490 2
plot_normal(dmp)
     struct dm	*dmp;
d504 1
a504 6
plot_drawString2D( dmp, str, x, y, size, use_aspect )
     struct dm		*dmp;
     register char	*str;
     fastf_t		x, y;
     int		size;
     int		use_aspect;
d521 1
a521 4
plot_drawLine2D( dmp, x1, y1, x2, y2 )
     struct dm	*dmp;
     fastf_t	x1, y1;
     fastf_t	x2, y2;
d538 1
a538 3
plot_drawPoint2D(dmp, x, y)
     struct dm	*dmp;
     fastf_t	x, y;
d545 1
a545 4
plot_setFGColor(dmp, r, g, b, strict)
     struct dm		*dmp;
     unsigned char	r, g, b;
     int		strict;
d553 1
a553 4
plot_setLineAttr(dmp, width, style)
     struct dm	*dmp;
     int	width;
     int	style;
d568 1
a568 2
plot_debug(dmp, lvl)
     struct dm	*dmp;
d585 1
a585 3
plot_setWinBounds(dmp, w)
     struct dm		*dmp;
     register int	w[];
@


1.29
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-plot.c,v 1.28 2000/10/18 18:10:33 butler Exp $ (BRL)";
d343 1
a343 1
	bn_mat_copy(plotmat, mat);
@


1.28
log
@Patches for compiling under RedHat 7.0
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-plot.c,v 1.27 2000/08/31 18:16:42 bparker Exp $ (BRL)";
d252 1
a252 1
	bn_mat_idn(plotmat);
@


1.27
log
@Mods to rid libdm of two globals: tkwin and interp
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-plot.c,v 1.26 2000/07/12 03:24:44 cjohnson Exp $ (BRL)";
d32 4
@


1.26
log
@LINT from gcc -Wall.  Includes some modifications to bu.h and fb.h
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-plot.c,v 1.25 2000/06/30 20:54:06 bparker Exp $ (BRL)";
d108 2
a109 1
  0				/* no zclipping */
d122 1
a122 1
plot_open(argc, argv)
d125 1
d136 1
d318 1
a318 1
	obj = Tcl_GetObjResult(interp);
d340 1
a340 1
	Tcl_SetObjResult(interp, obj);
d597 1
a597 1
	obj = Tcl_GetObjResult(interp);
d605 1
a605 1
	Tcl_SetObjResult(interp, obj);
@


1.25
log
@Replace deprecated Tcl_AppendResult stuff with Tcl_Obj stuff.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-plot.c,v 1.24 1999/12/27 21:10:48 bparker Exp $ (BRL)";
d43 1
d97 7
a103 7
  0,
  0,
  0,
  0,
  0,
  0,				/* clipmin */
  0,				/* clipmax */
@


1.24
log
@*- mods reflecting new members of "struct dm"
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-plot.c,v 1.23 1999/12/17 16:38:47 bparker Exp $ (BRL)";
d121 2
a122 2
int argc;
char *argv[];
d124 49
a172 44
  static int count = 0;
  struct dm *dmp;

  BU_GETSTRUCT(dmp, dm);
  if(dmp == DM_NULL)
    return DM_NULL;

  *dmp = dm_plot; /* struct copy */

  dmp->dm_vars.priv_vars = (genptr_t)bu_calloc(1, sizeof(struct plot_vars), "plot_open: plot_vars");
  BU_GETSTRUCT(dmp->dm_vars.priv_vars, plot_vars);
  if(dmp->dm_vars.priv_vars == (genptr_t)NULL){
    bu_free(dmp, "plot_open: dmp");
    return DM_NULL;
  }

  bu_vls_init(&((struct plot_vars *)dmp->dm_vars.priv_vars)->vls);
  bu_vls_init(&dmp->dm_pathName);
  bu_vls_init(&dmp->dm_tkName);
  bu_vls_printf(&dmp->dm_pathName, ".dm_plot%d", count++);
  bu_vls_printf(&dmp->dm_tkName, "dm_plot%d", count++);

  /* skip first argument */
  --argc; ++argv;

  /* Process any options */
  ((struct plot_vars *)dmp->dm_vars.priv_vars)->is_3D = 1;          /* 3-D w/color, by default */
  while( argv[0] != (char *)0 && argv[0][0] == '-' )  {
    switch( argv[0][1] )  {
    case '3':
      break;
    case '2':
      ((struct plot_vars *)dmp->dm_vars.priv_vars)->is_3D = 0;		/* 2-D, for portability */
      break;
    case 'g':
      ((struct plot_vars *)dmp->dm_vars.priv_vars)->grid = 1;
      break;
    case 'f':
      ((struct plot_vars *)dmp->dm_vars.priv_vars)->floating = 1;
      break;
    case 'z':
    case 'Z':
      /* Enable Z clipping */
      Tcl_AppendResult(interp, "Clipped in Z to viewing cube\n", (char *)NULL);
d174 1
a174 1
      ((struct plot_vars *)dmp->dm_vars.priv_vars)->zclip = 1;
d176 1
a176 1
      dmp->dm_zclip = 1;
d178 38
a215 33
      break;
    default:
      Tcl_AppendResult(interp, "bad PLOT option ", argv[0], "\n", (char *)NULL);
      (void)plot_close(dmp);
      return DM_NULL;
    }
    argv++;
  }
  if( argv[0] == (char *)0 )  {
    Tcl_AppendResult(interp, "no filename or filter specified\n", (char *)NULL);
    (void)plot_close(dmp);
    return DM_NULL;
  }

  if( argv[0][0] == '|' )  {
    bu_vls_strcpy(&((struct plot_vars *)dmp->dm_vars.priv_vars)->vls, &argv[0][1]);
    while( (++argv)[0] != (char *)0 ) {
      bu_vls_strcat( &((struct plot_vars *)dmp->dm_vars.priv_vars)->vls, " " );
      bu_vls_strcat( &((struct plot_vars *)dmp->dm_vars.priv_vars)->vls, argv[0] );
    }

    ((struct plot_vars *)dmp->dm_vars.priv_vars)->is_pipe = 1;
  }else{
    bu_vls_strcpy(&((struct plot_vars *)dmp->dm_vars.priv_vars)->vls, argv[0]);
  }

  if(((struct plot_vars *)dmp->dm_vars.priv_vars)->is_pipe){
    if((((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp =
	popen( bu_vls_addr(&((struct plot_vars *)dmp->dm_vars.priv_vars)->vls), "w")) == NULL){
      perror( bu_vls_addr(&((struct plot_vars *)dmp->dm_vars.priv_vars)->vls));
      (void)plot_close(dmp);
      return DM_NULL;
    }
d217 26
a242 25
    Tcl_AppendResult(interp, "piped to ",
		     bu_vls_addr(&((struct plot_vars *)dmp->dm_vars.priv_vars)->vls),
		     "\n", (char *)NULL);
  }else{
    if((((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp =
	fopen( bu_vls_addr(&((struct plot_vars *)dmp->dm_vars.priv_vars)->vls), "w" )) == NULL){
      perror(bu_vls_addr(&((struct plot_vars *)dmp->dm_vars.priv_vars)->vls));
      (void)plot_close(dmp);
      return DM_NULL;
    }

    Tcl_AppendResult(interp, "plot stored in ",
		     bu_vls_addr(&((struct plot_vars *)dmp->dm_vars.priv_vars)->vls),
		     "\n", (char *)NULL);
  }

  setbuf(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp,
	  ((struct plot_vars *)dmp->dm_vars.priv_vars)->ttybuf);

  if(((struct plot_vars *)dmp->dm_vars.priv_vars)->is_3D)
    pl_3space( ((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp,
	       -2048, -2048, -2048, 2048, 2048, 2048 );
  else
    pl_space( ((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp,
	      -2048, -2048, 2048, 2048 );
d244 1
a244 1
  bn_mat_idn(plotmat);
d246 2
a247 1
  return dmp;
d257 1
a257 1
struct dm *dmp;
d259 1
a259 1
  (void)fflush(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp);
d261 9
a269 9
  if(((struct plot_vars *)dmp->dm_vars.priv_vars)->is_pipe)
    pclose(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp); /* close pipe, eat dead children */
  else
    fclose(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp);

  bu_vls_free(&dmp->dm_pathName);
  bu_free(dmp->dm_vars.priv_vars, "plot_close: plot_vars");
  bu_free(dmp, "plot_close: dmp");
  return TCL_OK;
d279 1
a279 1
struct dm *dmp;
d281 1
a281 1
  /* We expect the screen to be blank so far, from last frame flush */
d283 1
a283 1
  return TCL_OK;
d291 1
a291 1
struct dm *dmp;
d293 3
a295 3
  pl_flush( ((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp ); /* BRL-specific command */
  pl_erase( ((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp ); /* forces drawing */
  (void)fflush( ((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp );
d297 1
a297 1
  return TCL_OK;
d308 30
a337 23
struct dm *dmp;
mat_t mat;
int which_eye;
{
  if(((struct plot_vars *)dmp->dm_vars.priv_vars)->debug){
    struct bu_vls tmp_vls;

    Tcl_AppendResult(interp, "plot_loadMatrix()\n", (char *)NULL);

    bu_vls_init(&tmp_vls);
    bu_vls_printf(&tmp_vls, "which eye = %d\t", which_eye);
    bu_vls_printf(&tmp_vls, "transformation matrix = \n");
    bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[0], mat[4], mat[8],mat[12]);
    bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[1], mat[5], mat[9],mat[13]);
    bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[2], mat[6], mat[10],mat[14]);
    bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[3], mat[7], mat[11],mat[15]);

    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
    bu_vls_free(&tmp_vls);
  }

  bn_mat_copy(plotmat, mat);
  return TCL_OK;
d351 2
a352 2
struct dm *dmp;
register struct rt_vlist *vp;
d354 7
a360 7
  static vect_t			last;
  register struct rt_vlist	*tvp;
  register point_t		*pt_prev=NULL;
  register fastf_t		dist_prev=1.0;
  register fastf_t		dist;
  fastf_t			delta;
  int useful = 0;
d362 2
a363 2
  if(((struct plot_vars *)dmp->dm_vars.priv_vars)->floating){
    rt_vlist_to_uplot(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp, &vp->l);
d365 2
a366 2
    return TCL_OK;
  }
d368 44
a411 49
    /* delta is used in clipping to insure clipped endpoint is slightly
     * in front of eye plane (perspective mode only).
     * This value is a SWAG that seems to work OK.
     */
    delta = plotmat[15]*0.0001;
    if( delta < 0.0 )
	delta = -delta;
    if( delta < SQRT_SMALL_FASTF )
	delta = SQRT_SMALL_FASTF;

  for( BU_LIST_FOR( tvp, rt_vlist, &vp->l ) )  {
    register int	i;
    register int	nused = tvp->nused;
    register int	*cmd = tvp->cmd;
    register point_t *pt = tvp->pt;
    for( i = 0; i < nused; i++,cmd++,pt++ )  {
      static vect_t	start, fin;
      switch( *cmd )  {
      case RT_VLIST_POLY_START:
      case RT_VLIST_POLY_VERTNORM:
	continue;
      case RT_VLIST_POLY_MOVE:
      case RT_VLIST_LINE_MOVE:
	/* Move, not draw */
		if (dmp->dm_perspective > 0)
	    	{
	    		/* cannot apply perspective transformation to
			 * points behind eye plane!!!!
	    		 */
	    		dist = VDOT( *pt, &plotmat[12] ) + plotmat[15];
	    		if( dist <= 0.0 )
	    		{
	    			pt_prev = pt;
	    			dist_prev = dist;
	    			continue;
	    		}
	    		else
	    		{
	    			MAT4X3PNT( last, plotmat, *pt );
	    			dist_prev = dist;
	    			pt_prev = pt;
	    		}
	    	}
		else
			MAT4X3PNT( last, plotmat, *pt );
	continue;
      case RT_VLIST_POLY_DRAW:
      case RT_VLIST_POLY_END:
      case RT_VLIST_LINE_DRAW:
d413 65
a477 76
		if (dmp->dm_perspective > 0)
	    	{
	    		/* cannot apply perspective transformation to
			 * points behind eye plane!!!!
	    		 */
	    		dist = VDOT( *pt, &plotmat[12] ) + plotmat[15];
	    		if( dist <= 0.0 )
	    		{
	    			if( dist_prev <= 0.0 )
	    			{
	    				/* nothing to plot */
		    			dist_prev = dist;
		    			pt_prev = pt;
		    			continue;
	    			}
	    			else
	    			{
	    				fastf_t alpha;
	    				vect_t diff;
	    				point_t tmp_pt;

	    				/* clip this end */
	    				VSUB2( diff, *pt, *pt_prev );
	    				alpha = (dist_prev - delta) / ( dist_prev - dist );
	    				VJOIN1( tmp_pt, *pt_prev, alpha, diff );
	    				MAT4X3PNT( fin, plotmat, tmp_pt );
	    			}
	    		}
	    		else
	    		{
	    			if( dist_prev <= 0.0 )
	    			{
	    				fastf_t alpha;
	    				vect_t diff;
	    				point_t tmp_pt;

	    				/* clip other end */
	    				VSUB2( diff, *pt, *pt_prev );
	    				alpha = (-dist_prev + delta) / ( dist - dist_prev );
	    				VJOIN1( tmp_pt, *pt_prev, alpha, diff );
	    				MAT4X3PNT( last, plotmat, tmp_pt );
	    				MAT4X3PNT( fin, plotmat, *pt );
	    			}
	    			else
	    			{
	    				MAT4X3PNT( fin, plotmat, *pt );
	    			}
	    		}
	    	}
		else
			MAT4X3PNT( fin, plotmat, *pt );
	VMOVE( start, last );
	VMOVE( last, fin );
	break;
      }
      if(vclip(start, fin, dmp->dm_clipmin, dmp->dm_clipmax) == 0)
	continue;

      if(((struct plot_vars *)dmp->dm_vars.priv_vars)->is_3D)
	pl_3line( ((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp, 
		  (int)( start[X] * 2047 ),
		  (int)( start[Y] * 2047 ),
		  (int)( start[Z] * 2047 ),
		  (int)( fin[X] * 2047 ),
		  (int)( fin[Y] * 2047 ),
		  (int)( fin[Z] * 2047 ) );
      else
	pl_line( ((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp, 
		 (int)( start[X] * 2047 ),
		 (int)( start[Y] * 2047 ),
		 (int)( fin[X] * 2047 ),
		 (int)( fin[Y] * 2047 ) );

      useful = 1;
    }
  }
d479 2
a480 2
  if(useful)
    return TCL_OK;
d482 1
a482 1
  return TCL_ERROR;
d494 1
a494 1
struct dm *dmp;
d496 1
a496 1
  return TCL_OK;
d509 12
a520 12
struct dm *dmp;
register char *str;
fastf_t x, y;
int size;
int use_aspect;
{
  int sx, sy;

  sx = x * 2047;
  sy = y + 2047;
  pl_move( ((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp, sx, sy);
  pl_label( ((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp, str);
d522 1
a522 1
  return TCL_OK;
d531 13
a543 13
struct dm *dmp;
fastf_t x1, y1;
fastf_t x2, y2;
{
  int sx1, sy1;
  int sx2, sy2;

  sx1 = x1 * 2047;
  sx2 = x2 * 2047;
  sy1 = y1 + 2047;
  sy2 = y2 + 2047;
  pl_move( ((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp, sx1, sy1);
  pl_cont( ((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp, sx2, sy2);
d545 1
a545 1
  return TCL_OK;
d551 2
a552 2
struct dm *dmp;
fastf_t x, y;
d554 1
a554 1
  return plot_drawLine2D( dmp, x, y, x, y );
d560 3
a562 3
struct dm *dmp;
unsigned char r, g, b;
int strict;
d564 2
a565 2
  pl_color( ((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp,  (int)r, (int)g, (int)b );
  return TCL_OK;
d571 11
a581 11
struct dm *dmp;
int width;
int style;
{
  dmp->dm_lineWidth = width;
  dmp->dm_lineStyle = style;

  if(style == DM_DASHED_LINE)
    pl_linmod( ((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp, "dotdashed");
  else
    pl_linmod( ((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp, "solid");
d583 1
a583 1
  return TCL_OK;
d589 1
a589 1
struct dm *dmp;
d591 9
a599 3
  dmp->dm_debugLevel = lvl;
  (void)fflush(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp);
  Tcl_AppendResult(interp, "flushed\n", (char *)NULL);
d601 2
a602 1
  return TCL_OK;
d607 2
a608 2
struct dm *dmp;
register int w[];
d610 13
a622 13
  /* Compute the clipping bounds */
  dmp->dm_clipmin[0] = w[0] / 2048.;
  dmp->dm_clipmax[0] = w[1] / 2047.;
  dmp->dm_clipmin[1] = w[2] / 2048.;
  dmp->dm_clipmax[1] = w[3] / 2047.;

  if (dmp->dm_zclip) {
    dmp->dm_clipmin[2] = w[4] / 2048.;
    dmp->dm_clipmax[2] = w[5] / 2047.;
  }else{
    dmp->dm_clipmin[2] = -1.0e20;
    dmp->dm_clipmax[2] = 1.0e20;
  }
d624 1
a624 1
  return TCL_OK;
@


1.24.2.1
log
@Removed two globals: interp and tkwin
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-plot.c,v 1.27 2000/08/31 18:16:42 bparker Exp $ (BRL)";
a42 1
#include "plot3.h"
d96 7
a102 7
  {0, 0, 0, 0, 0},		/* bu_vls path name*/
  {0, 0, 0, 0, 0},		/* bu_vls full name drawing window */
  {0, 0, 0, 0, 0},		/* bu_vls short name drawing window */
  {0, 0, 0},			/* bg color */
  {0, 0, 0},			/* fg color */
  {0.0, 0.0, 0.0},		/* clipmin */
  {0.0, 0.0, 0.0},		/* clipmax */
d107 1
a107 2
  0,				/* no zclipping */
  0				/* Tcl interpreter */
d120 48
a167 55
plot_open(interp, argc, argv)
     int	argc;
     char	*argv[];
     Tcl_Interp *interp;
{
	static int	count = 0;
	struct dm	*dmp;
	Tcl_Obj		*obj;

	BU_GETSTRUCT(dmp, dm);
	if (dmp == DM_NULL)
		return DM_NULL;

	*dmp = dm_plot; /* struct copy */
	dmp->dm_interp = interp;

	dmp->dm_vars.priv_vars = (genptr_t)bu_calloc(1, sizeof(struct plot_vars), "plot_open: plot_vars");
	BU_GETSTRUCT(dmp->dm_vars.priv_vars, plot_vars);
	if (dmp->dm_vars.priv_vars == (genptr_t)NULL) {
		bu_free(dmp, "plot_open: dmp");
		return DM_NULL;
	}

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);

	bu_vls_init(&((struct plot_vars *)dmp->dm_vars.priv_vars)->vls);
	bu_vls_init(&dmp->dm_pathName);
	bu_vls_init(&dmp->dm_tkName);
	bu_vls_printf(&dmp->dm_pathName, ".dm_plot%d", count++);
	bu_vls_printf(&dmp->dm_tkName, "dm_plot%d", count++);

	/* skip first argument */
	--argc; ++argv;

	/* Process any options */
	((struct plot_vars *)dmp->dm_vars.priv_vars)->is_3D = 1;          /* 3-D w/color, by default */
	while (argv[0] != (char *)0 && argv[0][0] == '-') {
		switch (argv[0][1]) {
		case '3':
			break;
		case '2':
			((struct plot_vars *)dmp->dm_vars.priv_vars)->is_3D = 0;		/* 2-D, for portability */
			break;
		case 'g':
			((struct plot_vars *)dmp->dm_vars.priv_vars)->grid = 1;
			break;
		case 'f':
			((struct plot_vars *)dmp->dm_vars.priv_vars)->floating = 1;
			break;
		case 'z':
		case 'Z':
			/* Enable Z clipping */
			Tcl_AppendStringsToObj(obj, "Clipped in Z to viewing cube\n", (char *)NULL);
d169 1
a169 1
			((struct plot_vars *)dmp->dm_vars.priv_vars)->zclip = 1;
d171 1
a171 1
			dmp->dm_zclip = 1;
d173 33
a205 38
			break;
		default:
			Tcl_AppendStringsToObj(obj, "bad PLOT option ", argv[0], "\n", (char *)NULL);
			(void)plot_close(dmp);

			Tcl_SetObjResult(interp, obj);
			return DM_NULL;
		}
		argv++;
	}
	if (argv[0] == (char *)0) {
		Tcl_AppendStringsToObj(obj, "no filename or filter specified\n", (char *)NULL);
		(void)plot_close(dmp);

		Tcl_SetObjResult(interp, obj);
		return DM_NULL;
	}

	if (argv[0][0] == '|') {
		bu_vls_strcpy(&((struct plot_vars *)dmp->dm_vars.priv_vars)->vls, &argv[0][1]);
		while( (++argv)[0] != (char *)0 ) {
			bu_vls_strcat( &((struct plot_vars *)dmp->dm_vars.priv_vars)->vls, " " );
			bu_vls_strcat( &((struct plot_vars *)dmp->dm_vars.priv_vars)->vls, argv[0] );
		}

		((struct plot_vars *)dmp->dm_vars.priv_vars)->is_pipe = 1;
	} else {
		bu_vls_strcpy(&((struct plot_vars *)dmp->dm_vars.priv_vars)->vls, argv[0]);
	}

	if (((struct plot_vars *)dmp->dm_vars.priv_vars)->is_pipe) {
		if ((((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp =
		     popen( bu_vls_addr(&((struct plot_vars *)dmp->dm_vars.priv_vars)->vls), "w")) == NULL) {
			perror( bu_vls_addr(&((struct plot_vars *)dmp->dm_vars.priv_vars)->vls));
			(void)plot_close(dmp);
			Tcl_SetObjResult(interp, obj);
			return DM_NULL;
		}
d207 25
a231 26
		Tcl_AppendStringsToObj(obj, "piped to ",
				 bu_vls_addr(&((struct plot_vars *)dmp->dm_vars.priv_vars)->vls),
				 "\n", (char *)NULL);
	} else {
		if ((((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp =
		     fopen( bu_vls_addr(&((struct plot_vars *)dmp->dm_vars.priv_vars)->vls), "w" )) == NULL) {
			perror(bu_vls_addr(&((struct plot_vars *)dmp->dm_vars.priv_vars)->vls));
			(void)plot_close(dmp);
			Tcl_SetObjResult(interp, obj);
			return DM_NULL;
		}

		Tcl_AppendStringsToObj(obj, "plot stored in ",
				 bu_vls_addr(&((struct plot_vars *)dmp->dm_vars.priv_vars)->vls),
				 "\n", (char *)NULL);
	}

	setbuf(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp,
	       ((struct plot_vars *)dmp->dm_vars.priv_vars)->ttybuf);

	if (((struct plot_vars *)dmp->dm_vars.priv_vars)->is_3D)
		pl_3space(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp,
			  -2048, -2048, -2048, 2048, 2048, 2048);
	else
		pl_space(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp,
			 -2048, -2048, 2048, 2048);
d233 1
a233 1
	bn_mat_idn(plotmat);
d235 1
a235 2
	Tcl_SetObjResult(interp, obj);
	return dmp;
d245 1
a245 1
     struct dm	*dmp;
d247 1
a247 1
	(void)fflush(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp);
d249 9
a257 9
	if (((struct plot_vars *)dmp->dm_vars.priv_vars)->is_pipe)
		pclose(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp); /* close pipe, eat dead children */
	else
		fclose(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp);

	bu_vls_free(&dmp->dm_pathName);
	bu_free(dmp->dm_vars.priv_vars, "plot_close: plot_vars");
	bu_free(dmp, "plot_close: dmp");
	return TCL_OK;
d267 1
a267 1
     struct dm	*dmp;
d269 1
a269 1
	/* We expect the screen to be blank so far, from last frame flush */
d271 1
a271 1
	return TCL_OK;
d279 1
a279 1
     struct dm	*dmp;
d281 3
a283 3
	pl_flush(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp); /* BRL-specific command */
	pl_erase(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp); /* forces drawing */
	(void)fflush(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp);
d285 1
a285 1
	return TCL_OK;
d296 23
a318 30
     struct dm	*dmp;
     mat_t	mat;
     int	which_eye;
{
	Tcl_Obj	*obj;

	obj = Tcl_GetObjResult(dmp->dm_interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);

	if (((struct plot_vars *)dmp->dm_vars.priv_vars)->debug) {
		struct bu_vls tmp_vls;

		Tcl_AppendStringsToObj(obj, "plot_loadMatrix()\n", (char *)NULL);

		bu_vls_init(&tmp_vls);
		bu_vls_printf(&tmp_vls, "which eye = %d\t", which_eye);
		bu_vls_printf(&tmp_vls, "transformation matrix = \n");
		bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[0], mat[4], mat[8],mat[12]);
		bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[1], mat[5], mat[9],mat[13]);
		bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[2], mat[6], mat[10],mat[14]);
		bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[3], mat[7], mat[11],mat[15]);

		Tcl_AppendStringsToObj(obj, bu_vls_addr(&tmp_vls), (char *)NULL);
		bu_vls_free(&tmp_vls);
	}

	bn_mat_copy(plotmat, mat);
	Tcl_SetObjResult(dmp->dm_interp, obj);
	return TCL_OK;
d332 2
a333 2
     struct dm			*dmp;
     register struct rt_vlist	*vp;
d335 7
a341 7
	static vect_t			last;
	register struct rt_vlist	*tvp;
	register point_t		*pt_prev=NULL;
	register fastf_t		dist_prev=1.0;
	register fastf_t		dist;
	fastf_t				delta;
	int				useful = 0;
d343 2
a344 2
	if (((struct plot_vars *)dmp->dm_vars.priv_vars)->floating) {
		rt_vlist_to_uplot(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp, &vp->l);
d346 2
a347 2
		return TCL_OK;
	}
d349 49
a397 44
	/* delta is used in clipping to insure clipped endpoint is slightly
	 * in front of eye plane (perspective mode only).
	 * This value is a SWAG that seems to work OK.
	 */
	delta = plotmat[15]*0.0001;
	if (delta < 0.0)
		delta = -delta;
	if (delta < SQRT_SMALL_FASTF)
		delta = SQRT_SMALL_FASTF;

	for (BU_LIST_FOR(tvp, rt_vlist, &vp->l)) {
		register int	i;
		register int	nused = tvp->nused;
		register int	*cmd = tvp->cmd;
		register point_t *pt = tvp->pt;
		for (i = 0; i < nused; i++,cmd++,pt++) {
			static vect_t	start, fin;
			switch (*cmd) {
			case RT_VLIST_POLY_START:
			case RT_VLIST_POLY_VERTNORM:
				continue;
			case RT_VLIST_POLY_MOVE:
			case RT_VLIST_LINE_MOVE:
				/* Move, not draw */
				if (dmp->dm_perspective > 0) {
					/* cannot apply perspective transformation to
					 * points behind eye plane!!!!
					 */
					dist = VDOT( *pt, &plotmat[12] ) + plotmat[15];
					if (dist <= 0.0) {
						pt_prev = pt;
						dist_prev = dist;
						continue;
					} else {
						MAT4X3PNT(last, plotmat, *pt);
						dist_prev = dist;
						pt_prev = pt;
					}
				} else
					MAT4X3PNT(last, plotmat, *pt);
				continue;
			case RT_VLIST_POLY_DRAW:
			case RT_VLIST_POLY_END:
			case RT_VLIST_LINE_DRAW:
d399 76
a474 65
				if (dmp->dm_perspective > 0) {
					/* cannot apply perspective transformation to
					 * points behind eye plane!!!!
					 */
					dist = VDOT( *pt, &plotmat[12] ) + plotmat[15];
					if (dist <= 0.0) {
						if (dist_prev <= 0.0) {
							/* nothing to plot */
							dist_prev = dist;
							pt_prev = pt;
							continue;
						} else {
							fastf_t alpha;
							vect_t diff;
							point_t tmp_pt;

							/* clip this end */
							VSUB2( diff, *pt, *pt_prev );
							alpha = (dist_prev - delta) / (dist_prev - dist);
							VJOIN1(tmp_pt, *pt_prev, alpha, diff);
							MAT4X3PNT(fin, plotmat, tmp_pt);
						}
					} else {
						if (dist_prev <= 0.0) {
							fastf_t alpha;
							vect_t diff;
							point_t tmp_pt;

							/* clip other end */
							VSUB2( diff, *pt, *pt_prev );
							alpha = (-dist_prev + delta) / ( dist - dist_prev );
							VJOIN1( tmp_pt, *pt_prev, alpha, diff );
							MAT4X3PNT( last, plotmat, tmp_pt );
							MAT4X3PNT( fin, plotmat, *pt );
						} else {
							MAT4X3PNT( fin, plotmat, *pt );
						}
					}
				} else
					MAT4X3PNT( fin, plotmat, *pt );
				VMOVE( start, last );
				VMOVE( last, fin );
				break;
			}
			if (vclip(start, fin, dmp->dm_clipmin, dmp->dm_clipmax) == 0)
				continue;

			if (((struct plot_vars *)dmp->dm_vars.priv_vars)->is_3D)
				pl_3line(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp, 
					 (int)(start[X] * 2047),
					 (int)(start[Y] * 2047),
					 (int)(start[Z] * 2047),
					 (int)(fin[X] * 2047),
					 (int)(fin[Y] * 2047),
					 (int)(fin[Z] * 2047));
			else
				pl_line(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp, 
					(int)(start[X] * 2047),
					(int)(start[Y] * 2047),
					(int)(fin[X] * 2047),
					(int)(fin[Y] * 2047));

			useful = 1;
		}
	}
d476 2
a477 2
	if (useful)
		return TCL_OK;
d479 1
a479 1
	return TCL_ERROR;
d491 1
a491 1
     struct dm	*dmp;
d493 1
a493 1
	return TCL_OK;
d506 12
a517 12
     struct dm		*dmp;
     register char	*str;
     fastf_t		x, y;
     int		size;
     int		use_aspect;
{
	int	sx, sy;

	sx = x * 2047;
	sy = y + 2047;
	pl_move(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp, sx, sy);
	pl_label(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp, str);
d519 1
a519 1
	return TCL_OK;
d528 13
a540 13
     struct dm	*dmp;
     fastf_t	x1, y1;
     fastf_t	x2, y2;
{
	int	sx1, sy1;
	int	sx2, sy2;

	sx1 = x1 * 2047;
	sx2 = x2 * 2047;
	sy1 = y1 + 2047;
	sy2 = y2 + 2047;
	pl_move(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp, sx1, sy1);
	pl_cont(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp, sx2, sy2);
d542 1
a542 1
	return TCL_OK;
d548 2
a549 2
     struct dm	*dmp;
     fastf_t	x, y;
d551 1
a551 1
	return plot_drawLine2D(dmp, x, y, x, y);
d557 3
a559 3
     struct dm		*dmp;
     unsigned char	r, g, b;
     int		strict;
d561 2
a562 2
	pl_color(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp, (int)r, (int)g, (int)b);
	return TCL_OK;
d568 11
a578 11
     struct dm	*dmp;
     int	width;
     int	style;
{
	dmp->dm_lineWidth = width;
	dmp->dm_lineStyle = style;

	if (style == DM_DASHED_LINE)
		pl_linmod(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp, "dotdashed");
	else
		pl_linmod(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp, "solid");
d580 1
a580 1
	return TCL_OK;
d586 1
a586 1
     struct dm	*dmp;
d588 3
a590 9
	Tcl_Obj	*obj;

	obj = Tcl_GetObjResult(dmp->dm_interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);

	dmp->dm_debugLevel = lvl;
	(void)fflush(((struct plot_vars *)dmp->dm_vars.priv_vars)->up_fp);
	Tcl_AppendStringsToObj(obj, "flushed\n", (char *)NULL);
d592 1
a592 2
	Tcl_SetObjResult(dmp->dm_interp, obj);
	return TCL_OK;
d597 2
a598 2
     struct dm		*dmp;
     register int	w[];
d600 13
a612 13
	/* Compute the clipping bounds */
	dmp->dm_clipmin[0] = w[0] / 2048.;
	dmp->dm_clipmax[0] = w[1] / 2047.;
	dmp->dm_clipmin[1] = w[2] / 2048.;
	dmp->dm_clipmax[1] = w[3] / 2047.;

	if (dmp->dm_zclip) {
		dmp->dm_clipmin[2] = w[4] / 2048.;
		dmp->dm_clipmax[2] = w[5] / 2047.;
	} else {
		dmp->dm_clipmin[2] = -1.0e20;
		dmp->dm_clipmax[2] = 1.0e20;
	}
d614 1
a614 1
	return TCL_OK;
@


1.23
log
@*- mods to reflect new member (dm_perspective) of struct dm
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-plot.c,v 1.22 1999/12/01 13:30:20 bparker Exp $ (BRL)";
d71 1
d73 2
d105 2
@


1.22
log
@*- mods to reflect changes to struct dm
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-plot.c,v 1.21 1998/06/15 18:55:06 bparker Exp $ (BRL)";
d101 1
d326 1
a326 1
plot_drawVList( dmp, vp, perspective )
a328 1
double perspective;
d368 1
a368 1
		if( perspective > 0.0 )
d394 1
a394 1
		if( perspective > 0.0 )
@


1.21
log
@*- add support for new routines:
	dm_setFGColor(), dm_setBGColor(), dm_getBGColor()
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/libdm/dm-plot.c,v 1.20 1998/06/12 19:48:18 bparker Exp $ (BRL)";
a69 1
  Nu_int0,
d78 4
a81 3
  0,			/* no displaylist */
  0,                    /* no stereo */
  PLOTBOUND,
d95 7
a101 1
  0
d162 1
d164 3
d449 1
a449 2
      if(vclip(start, fin, ((struct plot_vars *)dmp->dm_vars.priv_vars)->clipmin,
		((struct plot_vars *)dmp->dm_vars.priv_vars)->clipmax) == 0)
d553 1
a553 1
register short r, g, b;
d583 1
d596 8
a603 8
  ((struct plot_vars *)dmp->dm_vars.priv_vars)->clipmin[0] = w[0] / 2048.;
  ((struct plot_vars *)dmp->dm_vars.priv_vars)->clipmax[0] = w[1] / 2047.;
  ((struct plot_vars *)dmp->dm_vars.priv_vars)->clipmin[1] = w[2] / 2048.;
  ((struct plot_vars *)dmp->dm_vars.priv_vars)->clipmax[1] = w[3] / 2047.;

  if(((struct plot_vars *)dmp->dm_vars.priv_vars)->zclip){
    ((struct plot_vars *)dmp->dm_vars.priv_vars)->clipmin[2] = w[4] / 2048.;
    ((struct plot_vars *)dmp->dm_vars.priv_vars)->clipmax[2] = w[5] / 2047.;
d605 2
a606 2
    ((struct plot_vars *)dmp->dm_vars.priv_vars)->clipmin[2] = -1.0e20;
    ((struct plot_vars *)dmp->dm_vars.priv_vars)->clipmax[2] = 1.0e20;
@


1.20
log
@*- change _setColor() to _setFGColor()
*- add _setBGColor()
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/libdm/dm-plot.c,v 1.19 1998/03/03 14:59:13 jra Exp $ (BRL)";
d69 1
@


1.19
log
@Fixed clipping in perspective mode.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-plot.c,v 1.18 1998/02/26 15:22:56 bparker Exp jra $ (BRL)";
d54 1
a54 1
static int      plot_setColor();
d68 2
a69 1
  plot_setColor,
d541 1
a541 1
plot_setColor(dmp, r, g, b, strict)
@


1.18
log
@*- mods to plot_drawPoint2D(), plot_drawLine2D() and plot_drawString2d()
	to use floats instead of ints for x/y parameters
*- use new dm_vars structure
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-plot.c,v 1.17 1997/11/03 20:09:50 bparker Exp bparker $ (BRL)";
d313 1
a313 1
plot_drawVList( dmp, vp )
d316 1
d320 4
d332 10
d356 21
a376 1
	MAT4X3PNT( last, plotmat, *pt );
d382 51
a432 1
	MAT4X3PNT( fin, plotmat, *pt );
@


1.17
log
@mods to plot_setWinBounds()
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-plot.c,v 1.16 1997/10/10 12:56:09 bparker Exp bparker $ (BRL)";
d90 1
a92 1
  0,
d119 3
a121 2
  dmp->dm_vars = (genptr_t)bu_calloc(1, sizeof(struct plot_vars), "plot_open: plot_vars");
  if(dmp->dm_vars == (genptr_t)NULL){
d126 1
a126 1
  bu_vls_init(&((struct plot_vars *)dmp->dm_vars)->vls);
d136 1
a136 1
  ((struct plot_vars *)dmp->dm_vars)->is_3D = 1;          /* 3-D w/color, by default */
d142 1
a142 1
      ((struct plot_vars *)dmp->dm_vars)->is_3D = 0;		/* 2-D, for portability */
d145 1
a145 1
      ((struct plot_vars *)dmp->dm_vars)->grid = 1;
d148 1
a148 1
      ((struct plot_vars *)dmp->dm_vars)->floating = 1;
d154 1
a154 1
      ((struct plot_vars *)dmp->dm_vars)->zclip = 1;
d170 1
a170 1
    bu_vls_strcpy(&((struct plot_vars *)dmp->dm_vars)->vls, &argv[0][1]);
d172 2
a173 2
      bu_vls_strcat( &((struct plot_vars *)dmp->dm_vars)->vls, " " );
      bu_vls_strcat( &((struct plot_vars *)dmp->dm_vars)->vls, argv[0] );
d176 1
a176 1
    ((struct plot_vars *)dmp->dm_vars)->is_pipe = 1;
d178 1
a178 1
    bu_vls_strcpy(&((struct plot_vars *)dmp->dm_vars)->vls, argv[0]);
d181 4
a184 4
  if(((struct plot_vars *)dmp->dm_vars)->is_pipe){
    if((((struct plot_vars *)dmp->dm_vars)->up_fp =
	popen( bu_vls_addr(&((struct plot_vars *)dmp->dm_vars)->vls), "w")) == NULL){
      perror( bu_vls_addr(&((struct plot_vars *)dmp->dm_vars)->vls));
d190 1
a190 1
		     bu_vls_addr(&((struct plot_vars *)dmp->dm_vars)->vls),
d193 3
a195 3
    if((((struct plot_vars *)dmp->dm_vars)->up_fp =
	fopen( bu_vls_addr(&((struct plot_vars *)dmp->dm_vars)->vls), "w" )) == NULL){
      perror(bu_vls_addr(&((struct plot_vars *)dmp->dm_vars)->vls));
d201 1
a201 1
		     bu_vls_addr(&((struct plot_vars *)dmp->dm_vars)->vls),
d205 2
a206 2
  setbuf(((struct plot_vars *)dmp->dm_vars)->up_fp,
	  ((struct plot_vars *)dmp->dm_vars)->ttybuf);
d208 2
a209 2
  if(((struct plot_vars *)dmp->dm_vars)->is_3D)
    pl_3space( ((struct plot_vars *)dmp->dm_vars)->up_fp,
d212 1
a212 1
    pl_space( ((struct plot_vars *)dmp->dm_vars)->up_fp,
d229 1
a229 1
  (void)fflush(((struct plot_vars *)dmp->dm_vars)->up_fp);
d231 2
a232 2
  if(((struct plot_vars *)dmp->dm_vars)->is_pipe)
    pclose(((struct plot_vars *)dmp->dm_vars)->up_fp); /* close pipe, eat dead children */
d234 1
a234 1
    fclose(((struct plot_vars *)dmp->dm_vars)->up_fp);
d237 1
a237 1
  bu_free(dmp->dm_vars, "plot_close: plot_vars");
d263 3
a265 3
  pl_flush( ((struct plot_vars *)dmp->dm_vars)->up_fp ); /* BRL-specific command */
  pl_erase( ((struct plot_vars *)dmp->dm_vars)->up_fp ); /* forces drawing */
  (void)fflush( ((struct plot_vars *)dmp->dm_vars)->up_fp );
d282 1
a282 1
  if(((struct plot_vars *)dmp->dm_vars)->debug){
d321 2
a322 2
  if(((struct plot_vars *)dmp->dm_vars)->floating){
    rt_vlist_to_uplot(((struct plot_vars *)dmp->dm_vars)->up_fp, &vp->l);
d352 2
a353 2
      if(vclip(start, fin, ((struct plot_vars *)dmp->dm_vars)->clipmin,
		((struct plot_vars *)dmp->dm_vars)->clipmax) == 0)
d356 2
a357 2
      if(((struct plot_vars *)dmp->dm_vars)->is_3D)
	pl_3line( ((struct plot_vars *)dmp->dm_vars)->up_fp, 
d365 1
a365 1
	pl_line( ((struct plot_vars *)dmp->dm_vars)->up_fp, 
d407 1
a407 1
int x, y;
d411 6
a416 2
  pl_move( ((struct plot_vars *)dmp->dm_vars)->up_fp, x,y);
  pl_label( ((struct plot_vars *)dmp->dm_vars)->up_fp, str);
d428 2
a429 2
int x1, y1;
int x2, y2;
d431 9
a439 2
  pl_move( ((struct plot_vars *)dmp->dm_vars)->up_fp, x1,y1);
  pl_cont( ((struct plot_vars *)dmp->dm_vars)->up_fp, x2,y2);
d448 1
a448 1
int x, y;
d460 1
a460 1
  pl_color( ((struct plot_vars *)dmp->dm_vars)->up_fp,  (int)r, (int)g, (int)b );
d475 1
a475 1
    pl_linmod( ((struct plot_vars *)dmp->dm_vars)->up_fp, "dotdashed");
d477 1
a477 1
    pl_linmod( ((struct plot_vars *)dmp->dm_vars)->up_fp, "solid");
d487 1
a487 1
  (void)fflush(((struct plot_vars *)dmp->dm_vars)->up_fp);
d499 8
a506 8
  ((struct plot_vars *)dmp->dm_vars)->clipmin[0] = w[0] / 2048.;
  ((struct plot_vars *)dmp->dm_vars)->clipmax[0] = w[1] / 2047.;
  ((struct plot_vars *)dmp->dm_vars)->clipmin[1] = w[2] / 2048.;
  ((struct plot_vars *)dmp->dm_vars)->clipmax[1] = w[3] / 2047.;

  if(((struct plot_vars *)dmp->dm_vars)->zclip){
    ((struct plot_vars *)dmp->dm_vars)->clipmin[2] = w[4] / 2048.;
    ((struct plot_vars *)dmp->dm_vars)->clipmax[2] = w[5] / 2047.;
d508 2
a509 2
    ((struct plot_vars *)dmp->dm_vars)->clipmin[2] = -1.0e20;
    ((struct plot_vars *)dmp->dm_vars)->clipmax[2] = 1.0e20;
@


1.16
log
@got rid of eventHandler
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-plot.c,v 1.15 1997/09/23 21:14:42 bparker Exp bparker $ (BRL)";
d50 1
a50 1
static int	plot_normal(), plot_newrot();
d52 1
a52 1
static int      plot_drawVertex2D();
d63 1
a63 1
  plot_newrot,
d66 1
a66 1
  plot_drawVertex2D,
d270 4
a273 1
 *  			P L O T _ N E W R O T
d276 1
a276 1
plot_newrot(dmp, mat, which_eye)
d281 17
d434 1
a434 1
plot_drawVertex2D(dmp, x, y)
d487 4
a490 4
  ((struct plot_vars *)dmp->dm_vars)->clipmin[0] = w[1] / 2048.;
  ((struct plot_vars *)dmp->dm_vars)->clipmax[0] = w[0] / 2047.;
  ((struct plot_vars *)dmp->dm_vars)->clipmin[1] = w[3] / 2048.;
  ((struct plot_vars *)dmp->dm_vars)->clipmax[1] = w[2] / 2047.;
d493 2
a494 2
    ((struct plot_vars *)dmp->dm_vars)->clipmin[2] = w[5] / 2048.;
    ((struct plot_vars *)dmp->dm_vars)->clipmax[2] = w[4] / 2047.;
@


1.15
log
@*** empty log message ***
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-plot.c,v 1.14 1997/05/21 13:02:59 bparker Exp bparker $ (BRL)";
d76 1
a76 1
  Nu_int0,
d106 1
a106 2
plot_open(eventHandler, argc, argv)
int (*eventHandler)();
a117 1
  dmp->dm_eventHandler = eventHandler;
@


1.14
log
@mods to plot_setLineAttr
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-plot.c,v 1.13 1997/05/08 14:19:47 bparker Exp bparker $ (BRL)";
d37 1
a55 1
static unsigned plot_cvtvecs(), plot_load();
a69 2
  plot_cvtvecs,
  plot_load,
d73 4
d78 1
a92 1
  0,
d97 1
a147 1
#if 0
a156 1
#endif
d172 1
a172 1
    while( (++argv)[1] != (char *)0 ) {
d216 2
a272 1
 *  Stub.
a273 1
/* ARGSUSED */
d275 1
a275 1
plot_newrot(dmp, mat)
d278 1
d280 1
a292 1
/* ARGSUSED */
d294 1
a294 1
plot_drawVList( dmp, vp, mat )
a296 1
mat_t mat;
d302 5
a306 5
#if 0
  if( illum )  {
    pl_linmod( ((struct plot_vars *)dmp->dm_vars)->up_fp, "longdashed" );
  } else
#endif
d322 1
a322 1
	MAT4X3PNT( last, mat, *pt );
d328 1
a328 1
	MAT4X3PNT( fin, mat, *pt );
d336 1
a336 3
#if 0      
      pl_color( ((struct plot_vars *)dmp->dm_vars)->up_fp, r, g, b );
#endif
a451 27

/* ARGSUSED */
static unsigned
plot_cvtvecs( dmp, sp )
struct dm *dmp;
struct solid *sp;
{
  return( 0 );
}

/*
 * Loads displaylist
 */
static unsigned
plot_load( dmp, addr, count )
struct dm *dmp;
unsigned addr, count;
{
  struct bu_vls tmp_vls;

  bu_vls_init(&tmp_vls);
  bu_vls_printf(&tmp_vls, "plot_load(x%x, %d.)\n", addr, count);
  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
  bu_vls_free(&tmp_vls);
  return( 0 );
}

d470 1
a471 2
  ((struct plot_vars *)dmp->dm_vars)->clipmin[2] = w[5] / 2048.;
  ((struct plot_vars *)dmp->dm_vars)->clipmax[0] = w[0] / 2047.;
d473 8
a480 1
  ((struct plot_vars *)dmp->dm_vars)->clipmax[2] = w[4] / 2047.;
@


1.13
log
@*- changed Plot_ prefix to plot_
*- mods to reflect change in "struct dm" --- added dm_type
                                         removed dm_open, dm_initWinProc
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-plot.c,v 1.12 1997/04/24 18:14:07 bparker Exp bparker $ (BRL)";
d83 2
d437 1
a437 1
plot_setLineAttr(dmp, width, dashed)
d440 1
a440 1
int dashed;
d442 4
a445 1
  if(dashed)
@


1.12
log
@some cleanup
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-plot.c,v 1.11 1997/04/23 18:38:24 bparker Exp bparker $ (BRL)";
a42 2
static int Plot_load_startup();

d46 28
a73 29
struct dm	*Plot_open();
static int	Plot_close();
static int	Plot_drawBegin(), Plot_drawEnd();
static int	Plot_normal(), Plot_newrot();
static int	Plot_drawString2D(), Plot_drawLine2D();
static int      Plot_drawVertex2D();
static int	Plot_drawVList();
static int      Plot_setColor();
static int      Plot_setLineAttr();
static unsigned Plot_cvtvecs(), Plot_load();
static int	Plot_setWinBounds(), Plot_debug();

struct dm dm_Plot = {
  Plot_open,
  Plot_close,
  Plot_drawBegin,
  Plot_drawEnd,
  Plot_normal,
  Plot_newrot,
  Plot_drawString2D,
  Plot_drawLine2D,
  Plot_drawVertex2D,
  Plot_drawVList,
  Plot_setColor,
  Plot_setLineAttr,
  Plot_cvtvecs,
  Plot_load,
  Plot_setWinBounds,
  Plot_debug,
d79 1
a88 1
  0,
d101 1
a101 1
Plot_open(eventHandler, argc, argv)
d113 1
a113 1
  *dmp = dm_Plot;
d116 1
a116 1
  dmp->dm_vars = (genptr_t)bu_calloc(1, sizeof(struct plot_vars), "Plot_init: plot_vars");
d118 1
a118 1
    bu_free(dmp, "Plot_open: dmp");
d128 3
d156 1
a156 1
      (void)Plot_close(dmp);
d163 1
a163 1
    (void)Plot_close(dmp);
d183 1
a183 1
      (void)Plot_close(dmp);
d194 1
a194 1
      (void)Plot_close(dmp);
d222 1
a222 1
Plot_close(dmp)
d233 2
a234 2
  bu_free(dmp->dm_vars, "Plot_close: plot_vars");
  bu_free(dmp, "Plot_close: dmp");
d244 1
a244 1
Plot_drawBegin(dmp)
d256 1
a256 1
Plot_drawEnd(dmp)
d272 1
a272 1
Plot_newrot(dmp, mat)
d290 1
a290 1
Plot_drawVList( dmp, vp, mat )
d369 1
a369 1
Plot_normal(dmp)
d384 1
a384 1
Plot_drawString2D( dmp, str, x, y, size, use_aspect )
d402 1
a402 1
Plot_drawLine2D( dmp, x1, y1, x2, y2 )
d415 1
a415 1
Plot_drawVertex2D(dmp, x, y)
d419 1
a419 1
  return Plot_drawLine2D( dmp, x, y, x, y );
d424 1
a424 1
Plot_setColor(dmp, r, g, b, strict)
d435 1
a435 1
Plot_setLineAttr(dmp, width, dashed)
d451 1
a451 1
Plot_cvtvecs( dmp, sp )
d462 1
a462 1
Plot_load( dmp, addr, count )
d469 1
a469 1
  bu_vls_printf(&tmp_vls, "Plot_load(x%x, %d.)\n", addr, count);
d477 1
a477 1
Plot_debug(dmp, lvl)
d487 1
a487 1
Plot_setWinBounds(dmp, w)
a497 13

  return TCL_OK;
}

static int
Plot_load_startup(dmp)
struct dm *dmp;
{
  char *filename;


  if((filename = getenv("DM_PLOT_RCFILE")) != (char *)NULL )
    return Tcl_EvalFile(interp, filename);
@


1.11
log
@added some error checking; modified use of BU_GETSTRUCT
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-plot.c,v 1.10 1997/04/22 15:04:46 bparker Exp bparker $ (BRL)";
d119 2
a120 10
#if 0
  /* Only need to do this once for this display manager */
  if(!count){
    bzero((void *)&head_plot_vars, sizeof(struct plot_vars));
    BU_LIST_INIT( &head_plot_vars.l );
  }
#endif

  BU_GETSTRUCT(dmp->dm_vars, plot_vars);
  if(dmp->dm_vars == (struct plot_vars *)NULL){
a230 5

#if 0
  if(((struct plot_vars *)dmp->dm_vars)->l.forw != BU_LIST_NULL)
    BU_LIST_DEQUEUE(&((struct plot_vars *)dmp->dm_vars)->l);
#endif
@


1.10
log
@*** empty log message ***
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-plot.c,v 1.9 1997/03/03 18:31:49 bparker Exp bparker $ (BRL)";
d112 4
a115 1
  dmp = BU_GETSTRUCT(dmp, dm);
d119 1
d121 5
a125 2
  if(!count)
    (void)Plot_load_startup(dmp);
d127 2
a128 2
  dmp->dm_vars = bu_calloc(1, sizeof(struct plot_vars), "Plot_init: plot_vars");
  if(!dmp->dm_vars){
d240 1
d243 1
a520 2
  bzero((void *)&head_plot_vars, sizeof(struct plot_vars));
  BU_LIST_INIT( &head_plot_vars.l );
@


1.9
log
@mods to have display manager to allocate its own memory
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-plot.c,v 1.8 1997/01/17 23:01:25 bparker Exp bparker $ (BRL)";
a103 1
#if DO_NEW_LIBDM_OPEN
a105 4
#else
Plot_open(dmp, argc, argv)
struct dm *dmp;
#endif
a109 1
#if DO_NEW_LIBDM_OPEN
a114 1
#endif
@


1.8
log
@mods to opens use of argv
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-plot.c,v 1.7 1997/01/02 20:06:37 bparker Exp bparker $ (BRL)";
d48 1
a48 1
static int	Plot_open();
d85 1
d88 4
d103 5
a107 1
static int
d110 1
d115 7
d127 7
d135 1
d137 1
a137 3

  dmp->dm_vars = bu_calloc(1, sizeof(struct plot_vars), "Plot_init: plot_vars");
  bu_vls_init(&((struct plot_vars *)dmp->dm_vars)->vls);
d164 2
a165 1
      return TCL_ERROR;
d171 2
a172 1
    return TCL_ERROR;
a186 3
  if(!dmp->dm_vars)
    return TCL_ERROR;

d191 2
a192 1
      return TCL_ERROR;
d202 2
a203 1
      return TCL_ERROR;
d221 1
a221 1
  return TCL_OK;
d243 1
d245 1
d395 1
a395 1
Plot_drawString2D( dmp, str, x, y, size )
d400 1
@


1.7
log
@changed Plot_drawVList's return value
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-plot.c,v 1.6 1996/12/04 21:30:49 bparker Exp bparker $ (BRL)";
d118 2
a119 2
  while( argv[1] != (char *)0 && argv[1][0] == '-' )  {
    switch( argv[1][1] )  {
d140 1
a140 1
      Tcl_AppendResult(interp, "bad PLOT option ", argv[1], "\n", (char *)NULL);
d145 1
a145 1
  if( argv[1] == (char *)0 )  {
d150 2
a151 2
  if( argv[1][0] == '|' )  {
    bu_vls_strcpy(&((struct plot_vars *)dmp->dm_vars)->vls, &argv[1][1]);
d154 1
a154 1
      bu_vls_strcat( &((struct plot_vars *)dmp->dm_vars)->vls, argv[1] );
d159 1
a159 1
    bu_vls_strcpy(&((struct plot_vars *)dmp->dm_vars)->vls, argv[1]);
@


1.6
log
@changed interface to Plot_open
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-plot.c,v 1.5 1996/10/23 20:28:49 bparker Exp bparker $ (BRL)";
d340 4
a343 1
  return(useful);
@


1.5
log
@.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-plot.c,v 1.4 1996/09/30 19:40:38 bparker Exp bparker $ (BRL)";
a47 1
static int	Plot_init();
a60 1
  Plot_init,
d86 1
d92 6
d99 1
a99 1
Plot_init(dmp, argc, argv)
d110 1
d162 2
a163 5
  if(dmp->dm_vars)
    return TCL_OK;

  return TCL_ERROR;
}
a164 10
/*
 *			P L O T _ O P E N
 *
 * Fire up the display manager, and the display processor.
 *
 */
static int
Plot_open(dmp)
struct dm *dmp;
{
@


1.4
log
@more pruning
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-plot.c,v 1.3 1996/09/26 20:37:27 bparker Exp bparker $ (BRL)";
d43 1
a43 1
static void Plot_load_startup();
d50 8
a57 7
static void	Plot_close();
static void	Plot_input();
static void	Plot_prolog(), Plot_epilog();
static void	Plot_normal(), Plot_newrot();
static void	Plot_update();
static void	Plot_puts(), Plot_2d_line(), Plot_light();
static int	Plot_object();
d59 1
a59 2
static void	Plot_viewchange(), Plot_colorchange();
static void	Plot_window(), Plot_debug();
d63 17
a79 13
  Plot_open, Plot_close,
  Plot_input,
  Plot_prolog, Plot_epilog,
  Plot_normal, Plot_newrot,
  Plot_update,
  Plot_puts, Plot_2d_line,
  Plot_light,
  Plot_object,
  Plot_cvtvecs, Plot_load,
  Nu_void,
  Plot_viewchange,
  Plot_colorchange,
  Plot_window, Plot_debug, Nu_int0, Nu_int0,
d82 2
a83 1
  "plot", "Screen to UNIX-Plot",
d103 1
a103 1
    Plot_load_startup(dmp);
d105 1
a105 1
  bu_vls_printf(&dmp->dmr_pathName, ".dm_plot%d", count++);
d107 2
a108 2
  dmp->dmr_vars = bu_calloc(1, sizeof(struct plot_vars), "Plot_init: plot_vars");
  bu_vls_init(&((struct plot_vars *)dmp->dmr_vars)->vls);
d111 1
a111 1
  ((struct plot_vars *)dmp->dmr_vars)->is_3D = 1;          /* 3-D w/color, by default */
d117 1
a117 1
      ((struct plot_vars *)dmp->dmr_vars)->is_3D = 0;		/* 2-D, for portability */
d120 1
a120 1
      ((struct plot_vars *)dmp->dmr_vars)->grid = 1;
d124 1
a124 1
      ((struct plot_vars *)dmp->dmr_vars)->floating = 1;
d130 1
a130 1
      ((struct plot_vars *)dmp->dmr_vars)->zclip = 1;
d145 1
a145 1
    bu_vls_strcpy(&((struct plot_vars *)dmp->dmr_vars)->vls, &argv[1][1]);
d147 2
a148 2
      bu_vls_strcat( &((struct plot_vars *)dmp->dmr_vars)->vls, " " );
      bu_vls_strcat( &((struct plot_vars *)dmp->dmr_vars)->vls, argv[1] );
d151 1
a151 1
    ((struct plot_vars *)dmp->dmr_vars)->is_pipe = 1;
d153 1
a153 1
    bu_vls_strcpy(&((struct plot_vars *)dmp->dmr_vars)->vls, argv[1]);
d156 1
a156 1
  if(dmp->dmr_vars)
d172 4
a175 4
  if(((struct plot_vars *)dmp->dmr_vars)->is_pipe){
    if((((struct plot_vars *)dmp->dmr_vars)->up_fp =
	popen( bu_vls_addr(&((struct plot_vars *)dmp->dmr_vars)->vls), "w")) == NULL){
      perror( bu_vls_addr(&((struct plot_vars *)dmp->dmr_vars)->vls));
d180 1
a180 1
		     bu_vls_addr(&((struct plot_vars *)dmp->dmr_vars)->vls),
d183 3
a185 3
    if((((struct plot_vars *)dmp->dmr_vars)->up_fp =
	fopen( bu_vls_addr(&((struct plot_vars *)dmp->dmr_vars)->vls), "w" )) == NULL){
      perror(bu_vls_addr(&((struct plot_vars *)dmp->dmr_vars)->vls));
d190 1
a190 1
		     bu_vls_addr(&((struct plot_vars *)dmp->dmr_vars)->vls),
d194 2
a195 2
  setbuf(((struct plot_vars *)dmp->dmr_vars)->up_fp,
	  ((struct plot_vars *)dmp->dmr_vars)->ttybuf);
d197 2
a198 2
  if(((struct plot_vars *)dmp->dmr_vars)->is_3D)
    pl_3space( ((struct plot_vars *)dmp->dmr_vars)->up_fp,
d201 1
a201 1
    pl_space( ((struct plot_vars *)dmp->dmr_vars)->up_fp,
d212 1
a212 1
static void
d216 1
a216 1
  (void)fflush(((struct plot_vars *)dmp->dmr_vars)->up_fp);
d218 2
a219 2
  if(((struct plot_vars *)dmp->dmr_vars)->is_pipe)
    pclose(((struct plot_vars *)dmp->dmr_vars)->up_fp); /* close pipe, eat dead children */
d221 1
a221 1
    fclose(((struct plot_vars *)dmp->dmr_vars)->up_fp);
d223 2
a224 2
  if(((struct plot_vars *)dmp->dmr_vars)->l.forw != BU_LIST_NULL)
    BU_LIST_DEQUEUE(&((struct plot_vars *)dmp->dmr_vars)->l);
d226 2
a227 1
  bu_free(dmp->dmr_vars, "Plot_close: plot_vars");
d235 2
a236 2
static void
Plot_prolog(dmp)
d241 1
a241 3
  /* Put the center point up */
  pl_move( ((struct plot_vars *)dmp->dmr_vars)->up_fp,  0, 0 );
  pl_cont( ((struct plot_vars *)dmp->dmr_vars)->up_fp,  0, 0 );
d247 2
a248 2
static void
Plot_epilog(dmp)
d251 5
a255 3
  pl_flush( ((struct plot_vars *)dmp->dmr_vars)->up_fp ); /* BRL-specific command */
  pl_erase( ((struct plot_vars *)dmp->dmr_vars)->up_fp ); /* forces drawing */
  (void)fflush( ((struct plot_vars *)dmp->dmr_vars)->up_fp );
d263 1
a263 1
static void
d268 1
a268 1
  return;
d282 1
a282 1
Plot_object( dmp, vp, mat, illum, linestyle, r, g, b, index )
a285 4
int illum;
int linestyle;
register short r, g, b;
short index;
d291 1
d293 3
a295 7
    pl_linmod( ((struct plot_vars *)dmp->dmr_vars)->up_fp, "longdashed" );
  } else {
    if( linestyle )
      pl_linmod( ((struct plot_vars *)dmp->dmr_vars)->up_fp, "dotdashed");
    else
      pl_linmod( ((struct plot_vars *)dmp->dmr_vars)->up_fp, "solid");
  }
d322 2
a323 2
      if(vclip(start, fin, ((struct plot_vars *)dmp->dmr_vars)->clipmin,
		((struct plot_vars *)dmp->dmr_vars)->clipmax) == 0)
d325 5
a329 5
      
      pl_color( ((struct plot_vars *)dmp->dmr_vars)->up_fp, r, g, b );

      if(((struct plot_vars *)dmp->dmr_vars)->is_3D)
	pl_3line( ((struct plot_vars *)dmp->dmr_vars)->up_fp, 
d337 1
a337 1
	pl_line( ((struct plot_vars *)dmp->dmr_vars)->up_fp, 
d357 1
a357 1
static void
d361 1
a361 1
  return;
a363 11
/*
 *			P L O T _ U P D A T E
 *
 * Transmit accumulated displaylist to the display processor.
 */
static void
Plot_update(dmp)
struct dm *dmp;
{
  (void)fflush(((struct plot_vars *)dmp->dmr_vars)->up_fp);
}
d372 2
a373 2
static void
Plot_puts( dmp, str, x, y, size, color )
d376 2
d379 2
a380 17
  switch( color )  {
  case DM_BLACK:
    pl_color( ((struct plot_vars *)dmp->dmr_vars)->up_fp,  0, 0, 0 );
    break;
  case DM_RED:
    pl_color( ((struct plot_vars *)dmp->dmr_vars)->up_fp,  255, 0, 0 );
    break;
  case DM_BLUE:
    pl_color( ((struct plot_vars *)dmp->dmr_vars)->up_fp,  0, 255, 0 );
    break;
  case DM_YELLOW:
    pl_color( ((struct plot_vars *)dmp->dmr_vars)->up_fp,  255, 255, 0 );
    break;
  case DM_WHITE:
    pl_color( ((struct plot_vars *)dmp->dmr_vars)->up_fp,  255, 255, 255 );
    break;
  }
d382 1
a382 2
  pl_move( ((struct plot_vars *)dmp->dmr_vars)->up_fp, x,y);
  pl_label( ((struct plot_vars *)dmp->dmr_vars)->up_fp, str);
d389 2
a390 2
static void
Plot_2d_line( dmp, x1, y1, x2, y2, dashed )
a393 1
int dashed;
d395 2
a396 1
  pl_color( ((struct plot_vars *)dmp->dmr_vars)->up_fp,  255, 255, 0 );	/* Yellow */
d398 2
a399 4
  if( dashed )
    pl_linmod( ((struct plot_vars *)dmp->dmr_vars)->up_fp, "dotdashed");
  else
    pl_linmod( ((struct plot_vars *)dmp->dmr_vars)->up_fp, "solid");
a400 3
  pl_move( ((struct plot_vars *)dmp->dmr_vars)->up_fp, x1,y1);
  pl_cont( ((struct plot_vars *)dmp->dmr_vars)->up_fp, x2,y2);
}
d402 2
a403 13
/*
 *			P L O T _ I N P U T
 *
 * Execution must suspend in this routine until a significant event
 * has occured on either the command stream,
 * unless "noblock" is set.
 *
 * Implicit Return -
 *	If any files are ready for input, their bits will be set in 'input'.
 *	Otherwise, 'input' will be all zeros.
 */
static void
Plot_input( dmp, input, noblock )
d405 1
a405 2
fd_set		*input;
int		noblock;
d407 2
a408 3
	struct timeval	tv;
	int		width;
	int		cnt;
a409 4
#if defined(_SC_OPEN_MAX)
	if( (width = sysconf(_SC_OPEN_MAX)) <= 0 )
#endif
		width = 32;
d411 8
a418 22
	/*
	 * Check for input on the keyboard
	 *
	 * Suspend execution until either
	 *  1)  User types a full line
	 *  2)  The timelimit on SELECT has expired
	 *
	 * If a RATE operation is in progress (zoom, rotate, slew)
	 * in which we still have to update the display,
	 * do not suspend execution.
	 */
	tv.tv_sec = 0;
	if( noblock )  {
		tv.tv_usec = 0;
	}  else  {
		/* 1/20th second */
		tv.tv_usec = 50000;
	}
	cnt = select( width, input, (fd_set *)0,  (fd_set *)0, &tv );
	if( cnt < 0 )  {
		perror("dm/select");
	}
d421 3
a423 6
/* 
 *			P L O T _ L I G H T
 */
/* ARGSUSED */
static void
Plot_light( dmp, cmd, func )
d425 2
a426 2
int cmd;
int func;			/* BE_ or BV_ function */
d428 6
a433 1
  return;
d436 1
a462 12
static void
Plot_viewchange(dmp)
struct dm *dmp;
{
}

static void
Plot_colorchange(dmp)
struct dm *dmp;
{
}

d464 1
a464 1
static void
d468 1
a468 1
  (void)fflush(((struct plot_vars *)dmp->dmr_vars)->up_fp);
d470 2
d474 2
a475 2
static void
Plot_window(dmp, w)
d480 8
a487 6
  ((struct plot_vars *)dmp->dmr_vars)->clipmin[0] = w[1] / 2048.;
  ((struct plot_vars *)dmp->dmr_vars)->clipmin[1] = w[3] / 2048.;
  ((struct plot_vars *)dmp->dmr_vars)->clipmin[2] = w[5] / 2048.;
  ((struct plot_vars *)dmp->dmr_vars)->clipmax[0] = w[0] / 2047.;
  ((struct plot_vars *)dmp->dmr_vars)->clipmax[1] = w[2] / 2047.;
  ((struct plot_vars *)dmp->dmr_vars)->clipmax[2] = w[4] / 2047.;
d490 1
a490 1
static void
d500 3
a502 1
    Tcl_EvalFile(interp, filename);
@


1.3
log
@changed parameters to dmr_object
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-plot.c,v 1.2 1996/09/25 20:27:08 bparker Exp bparker $ (BRL)";
a76 1
  1,			/* play it safe (could be frame buffer) */
a82 2
  0,
  0,
a531 1
  dmp->dmr_cfunc();
@


1.2
log
@more cleanup
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-plot.c,v 1.1 1996/09/23 17:58:10 bparker Exp bparker $ (BRL)";
a220 6
#if 0
  /* Give the application a chance to clean up */
  if(dmp->dmr_app_close)
    dmp->dmr_app_close(((struct plot_vars *)dmp->dmr_vars)->app_vars);
#endif

d279 1
a279 1
Plot_object( dmp, sp, mat, ratio, white )
d281 1
a281 1
register struct solid *sp;
d283 4
a286 1
double ratio;
d289 1
a289 1
  register struct rt_vlist	*vp;
d292 1
a292 1
  if( white )  {
d295 1
a295 1
    if( sp->s_soldash )
d301 1
a301 1
  for( BU_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
d303 3
a305 3
    register int	nused = vp->nused;
    register int	*cmd = vp->cmd;
    register point_t *pt = vp->pt;
d330 1
a330 4
      pl_color( ((struct plot_vars *)dmp->dmr_vars)->up_fp,
		sp->s_color[0],
		sp->s_color[1],
		sp->s_color[2] );
@


1.1
log
@Initial revision
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-plot.c,v 11.4 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d41 1
a42 3
/*XXX This is just temporary!!! */
#include "../mged/solid.h"

d83 3
d92 1
a92 1
Plot_init(dmp, color_func, argc, argv)
a93 1
void (*color_func)();
d105 1
a105 3
  dmp->dmr_vars = bu_malloc(sizeof(struct plot_vars), "Plot_init: plot_vars");
  bzero((void *)dmp->dmr_vars, sizeof(struct plot_vars));
  ((struct plot_vars *)dmp->dmr_vars)->color_func = color_func;
d541 1
a541 1
  ((struct plot_vars *)dmp->dmr_vars)->color_func();
@
