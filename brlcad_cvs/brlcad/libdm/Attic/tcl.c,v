head	1.22;
access;
symbols
	ansi-20040405-merged:1.18.2.2
	postmerge-20040405-ansi:1.20
	premerge-20040404-ansi:1.19
	postmerge-autoconf:1.19
	autoconf-freeze:1.19
	premerge-autoconf:1.19
	ansi-20040316-freeze:1.18.2.1
	postmerge-20040315-windows:1.19
	premerge-20040315-windows:1.19
	windows-20040315-freeze:1.18.4.1
	autoconf-20031203:1.19
	autoconf-20031202:1.19
	autoconf-branch:1.19.0.6
	phong-branch:1.19.0.4
	photonmap-branch:1.19.0.2
	rel-6-1-DP:1.18
	windows-branch:1.18.0.4
	rel-6-0-2:1.16
	ansi-branch:1.18.0.2
	rel-6-0-1-branch:1.16.0.2
	hartley-6-0-post:1.17
	hartley-6-0-pre:1.16
	rel-6-0-1:1.16
	rel-6-0:1.16
	rel-5-4:1.12.2.1
	offsite-5-3-pre:1.15
	rel-5-3:1.12.2.1
	rel-5-2:1.12.2.1
	rel-5-1-branch:1.12.0.2
	rel-5-1:1.12
	rel-5-0:1.5
	rel-5-0-beta:1.5
	rel-4-5:1.4;
locks; strict;
comment	@ * @;


1.22
date	2004.05.21.18.06.26;	author morrison;	state dead;
branches;
next	1.21;

1.21
date	2004.05.10.15.30.44;	author erikg;	state Exp;
branches;
next	1.20;

1.20
date	2004.04.05.07.45.07;	author morrison;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.01.15.01.43;	author jra;	state Exp;
branches;
next	1.18;

1.18
date	2002.08.20.17.07.45;	author jra;	state Exp;
branches
	1.18.2.1
	1.18.4.1;
next	1.17;

1.17
date	2002.08.15.20.54.58;	author hartley;	state Exp;
branches;
next	1.16;

1.16
date	2001.04.02.21.20.39;	author bparker;	state Exp;
branches;
next	1.15;

1.15
date	2000.08.17.18.15.20;	author bparker;	state Exp;
branches;
next	1.14;

1.14
date	2000.07.12.03.24.44;	author cjohnson;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.30.20.54.06;	author bparker;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.20.21.24.47;	author bparker;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2000.01.14.23.49.06;	author bparker;	state Exp;
branches;
next	1.10;

1.10
date	99.12.27.21.06.52;	author bparker;	state Exp;
branches;
next	1.9;

1.9
date	99.12.20.21.25.11;	author bparker;	state Exp;
branches;
next	1.8;

1.8
date	99.12.17.16.33.59;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	99.12.01.13.55.52;	author bparker;	state Exp;
branches;
next	1.6;

1.6
date	99.10.22.21.34.59;	author bparker;	state Exp;
branches;
next	1.5;

1.5
date	98.02.26.15.33.53;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	98.01.05.20.43.02;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	97.11.21.21.08.16;	author bparker;	state Exp;
branches;
next	1.2;

1.2
date	97.09.16.13.14.46;	author jra;	state Exp;
branches;
next	1.1;

1.1
date	97.08.01.21.31.08;	author bparker;	state Exp;
branches;
next	;

1.12.2.1
date	2000.09.01.17.24.43;	author bparker;	state Exp;
branches;
next	;

1.18.2.1
date	2002.09.19.18.01.17;	author morrison;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2004.03.17.21.16.59;	author morrison;	state Exp;
branches;
next	;

1.18.4.1
date	2004.03.11.23.42.01;	author morrison;	state Exp;
branches;
next	;


desc
@tcl wrappers to access libdm via Tcl
@


1.22
log
@moved to src/
@
text
@/*
 *				T C L . C
 *
 * LIBDM's tcl interface.
 * 
 * Source -
 *	SLAD CAD Team
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 * Author -
 *	Robert G. Parker
 */
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <math.h>
#include "tcl.h"
#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "dm.h"
#include "cmd.h"

#ifdef DM_X
/* from libdm/query.c */
extern int dm_validXType();
extern char *dm_bestXType();
#endif

/* from libdm/dm_obj.c */
extern int Dmo_Init(Tcl_Interp *interp);

HIDDEN int dm_validXType_tcl();
HIDDEN int dm_bestXType_tcl();

int vectorThreshold = 100000;

HIDDEN struct bu_cmdtab cmdtab[] = {
#ifdef DM_X
	{"dm_validXType",	dm_validXType_tcl},
	{"dm_bestXType",	dm_bestXType_tcl},
#endif
	{(char *)0,		(int (*)())0}
};

int
Dm_Init(Tcl_Interp *interp)
{
	const char		*version_number;
	struct bu_vls	vls;

	/* register commands */
	bu_register_cmds(interp, cmdtab);

	bu_vls_init(&vls);
	bu_vls_strcpy(&vls, "vectorThreshold");
	Tcl_LinkVar(interp, bu_vls_addr(&vls), (char *)&vectorThreshold,
		    TCL_LINK_INT);
	bu_vls_free(&vls);

	/* initialize display manager object code */
	Dmo_Init(interp);

	Tcl_SetVar(interp, "dm_version", (char *)dm_version+5, TCL_GLOBAL_ONLY);
	Tcl_Eval(interp, "lindex $dm_version 2");
	version_number = Tcl_GetStringResult(interp);
	Tcl_PkgProvide(interp,  "Dm", version_number);

	return TCL_OK;
}

#ifdef DM_X
HIDDEN int
dm_validXType_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
{
	struct bu_vls	vls;
	Tcl_Obj		*obj;

	bu_vls_init(&vls);

	if(argc != 3){
		bu_vls_printf(&vls, "helplib dm_validXType");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	bu_vls_printf(&vls, "%d", dm_validXType(argv[1], argv[2]));
	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);
	Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

	Tcl_SetObjResult(interp, obj);
	return TCL_OK;
}

HIDDEN int
dm_bestXType_tcl(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
	Tcl_Obj		*obj;

	if (argc != 2) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib dm_bestXType");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);
	Tcl_AppendStringsToObj(obj, dm_bestXType(argv[1]), (char *)NULL);

	Tcl_SetObjResult(interp, obj);
	return TCL_OK;
}
#endif
@


1.21
log
@change conf.h to a wrapped config.h
@
text
@@


1.20
log
@merge of ansi-6-0-branch into HEAD
@
text
@d14 5
a18 1
#include "conf.h"
@


1.19
log
@Added a "const" to quiet the compiler
@
text
@d31 1
a31 1
extern int Dmo_Init();
d47 1
a47 2
Dm_Init(interp)
     Tcl_Interp *interp;
@


1.18
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d50 1
a50 1
	char		*version_number;
@


1.18.4.1
log
@sync to HEAD...
@
text
@d50 1
a50 1
	const char		*version_number;
@


1.18.2.1
log
@Initial ANSIfication
@
text
@d31 1
a31 1
extern int Dmo_Init(Tcl_Interp *interp);
d47 2
a48 1
Dm_Init(Tcl_Interp *interp)
@


1.18.2.2
log
@sync branch with HEAD
@
text
@d49 1
a49 1
	const char		*version_number;
@


1.17
log
@Converted from K&R to ANSI C - RFH
@
text
@d31 1
a31 1
extern int Dmo_Init(Tcl_Interp *interp);
d47 2
a48 1
Dm_Init(Tcl_Interp *interp)
@


1.16
log
@*- remove Tk dependencies
@
text
@d31 1
a31 1
extern int Dmo_Init();
d47 1
a47 2
Dm_Init(interp)
     Tcl_Interp *interp;
@


1.15
log
@Add vector counting code.
@
text
@d24 1
d28 1
d39 1
d42 1
d73 1
d131 1
@


1.14
log
@LINT from gcc -Wall.  Includes some modifications to bu.h and fb.h
@
text
@d34 2
d44 1
a44 1
Tcl_Interp *interp;
d46 5
a50 1
  char *version_number;
d52 5
a56 2
  /* register commands */
  bu_register_cmds(interp, cmdtab);
d58 2
a59 2
  /* initialize display manager object code */
  Dmo_Init(interp);
d61 4
a64 4
  Tcl_SetVar(interp, "dm_version", (char *)dm_version+5, TCL_GLOBAL_ONLY);
  Tcl_Eval(interp, "lindex $dm_version 2");
  version_number = Tcl_GetStringResult(interp);
  Tcl_PkgProvide(interp,  "Dm", version_number);
d66 1
a66 1
  return TCL_OK;
@


1.13
log
@Replace deprecated Tcl_AppendResult stuff with Tcl_Obj stuff.
@
text
@d35 3
a37 3
	"dm_validXType",	dm_validXType_tcl,
	"dm_bestXType",		dm_bestXType_tcl,
	(char *)0,		(int (*)())0
@


1.12
log
@*- set dm_version and call Tcl_PkgProvide
@
text
@d62 4
a65 4
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d67 2
a68 1
  struct bu_vls vls;
d70 1
a70 1
  bu_vls_init(&vls);
d72 13
a84 10
  if(argc != 3){
    bu_vls_printf(&vls, "helplib dm_validXType");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  bu_vls_printf(&vls, "%d", dm_validXType(argv[1], argv[2]));
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  bu_vls_free(&vls);
d86 2
a87 1
  return TCL_OK;
d97 4
a100 2
  if (argc != 2) {
    struct bu_vls vls;
d102 11
a112 6
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "helplib dm_bestXType");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }
d114 2
a115 2
  Tcl_AppendResult(interp, dm_bestXType(argv[1]), (char *)NULL);
  return TCL_OK;
@


1.12.2.1
log
@Removed two globals: interp and tkwin
@
text
@a33 2
int vectorThreshold = 100000;

d35 3
a37 3
	{"dm_validXType",	dm_validXType_tcl},
	{"dm_bestXType",	dm_bestXType_tcl},
	{(char *)0,		(int (*)())0}
d42 1
a42 1
     Tcl_Interp *interp;
d44 1
a44 2
	char		*version_number;
	struct bu_vls	vls;
d46 2
a47 2
	/* register commands */
	bu_register_cmds(interp, cmdtab);
d49 2
a50 13
	bu_vls_init(&vls);
	bu_vls_strcpy(&vls, "vectorThreshold");
	Tcl_LinkVar(interp, bu_vls_addr(&vls), (char *)&vectorThreshold,
		    TCL_LINK_INT);
	bu_vls_free(&vls);

	/* initialize display manager object code */
	Dmo_Init(interp);

	Tcl_SetVar(interp, "dm_version", (char *)dm_version+5, TCL_GLOBAL_ONLY);
	Tcl_Eval(interp, "lindex $dm_version 2");
	version_number = Tcl_GetStringResult(interp);
	Tcl_PkgProvide(interp,  "Dm", version_number);
d52 6
a57 1
	return TCL_OK;
d62 4
a65 4
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d67 1
a67 2
	struct bu_vls	vls;
	Tcl_Obj		*obj;
d69 1
a69 1
	bu_vls_init(&vls);
d71 10
a80 13
	if(argc != 3){
		bu_vls_printf(&vls, "helplib dm_validXType");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	bu_vls_printf(&vls, "%d", dm_validXType(argv[1], argv[2]));
	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);
	Tcl_AppendStringsToObj(obj, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);
d82 1
a82 2
	Tcl_SetObjResult(interp, obj);
	return TCL_OK;
d92 2
a93 4
	Tcl_Obj		*obj;

	if (argc != 2) {
		struct bu_vls vls;
d95 6
a100 11
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib dm_bestXType");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	obj = Tcl_GetObjResult(interp);
	if (Tcl_IsShared(obj))
		obj = Tcl_DuplicateObj(obj);
	Tcl_AppendStringsToObj(obj, dm_bestXType(argv[1]), (char *)NULL);
d102 2
a103 2
	Tcl_SetObjResult(interp, obj);
	return TCL_OK;
@


1.11
log
@*- using bu_register_cmds
@
text
@d44 2
d51 5
@


1.10
log
@*- moved view_obj to librt
*- register dm_open in dm_obj.c
@
text
@d44 2
a45 6
  register struct bu_cmdtab *ctp;

  for (ctp = cmdtab; ctp->ct_name != (char *)NULL; ctp++) {
    (void)Tcl_CreateCommand(interp, ctp->ct_name, ctp->ct_func,
			    (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
  }
@


1.9
log
@*- use bu_cmd routines
@
text
@a27 3
/* from libdm/dm-generic.c */
extern struct dm *dm_open();

a28 1
extern int dmo_open_tcl();
a30 14
/* from libdm/view_obj.c */
extern int vo_open_tcl();
extern int Vo_Init();

#if 0
/* from libdm/geometry_obj.c */
extern int geo_open_tcl();
extern int Geo_Init();

/* from libdm/db_obj.c */
extern int dbo_open_tcl();
extern int Dbo_Init();
#endif

a36 6
	"dm_open",		dmo_open_tcl,
	"vo_open",		vo_open_tcl,
#if 0
	"geo_open",		geo_open_tcl,
	"db_open",		dbo_open_tcl,
#endif
a52 11

  /* initialize view object code */
  Vo_Init(interp);

#if 0
  /* initialize geometry object code */
  Geo_Init(interp);

  /* initialize database object */
  Dbo_Init(interp);
#endif
@


1.8
log
@*- remove unneeded cpp directives
@
text
@d39 1
d47 1
d52 1
a52 1
HIDDEN struct cmdtab cmdtab[] = {
d57 1
d60 1
d68 1
a68 1
  register struct cmdtab *ctp;
d81 1
d87 1
@


1.7
log
@*- add support for a few objects:
	display manager, view, database
@
text
@a42 1
#if 1
a45 1
#endif
a55 1
#if 1
a56 1
#endif
@


1.6
log
@*- change dm_tclInit to Dm_Init
@
text
@d1 13
d15 2
a16 1
#include "tk.h"
d20 1
d22 1
d24 1
d28 2
a29 2
static int dm_validXType_tcl();
static int dm_bestXType_tcl();
d31 31
a61 9
struct cmdtab {
  char *ct_name;
  int (*ct_func)();
};

static struct cmdtab cmdtab[] = {
  "dm_validXType", dm_validXType_tcl,
  "dm_bestXType", dm_bestXType_tcl,
  0, 0
d70 1
a70 1
  for(ctp = cmdtab; ctp->ct_name != (char *)NULL; ctp++){
d72 1
a72 1
			   (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
d75 12
d90 1
a90 1
static int
d115 1
a115 1
static int
d122 1
a122 1
  if(argc != 2){
@


1.5
log
@*- cleanup
*- add Tcl support for dm_validXType() and dm_bestXType()
@
text
@d26 1
a26 1
dm_tclInit(interp)
d31 1
a31 1
  for(ctp = cmdtab; ctp->ct_name != NULL; ctp++){
@


1.4
log
@experimenting with XSendEvent
@
text
@d8 2
a9 19
extern int dm_best_type();
extern char *dm_best_name();
extern int dm_name2type();
extern char **dm_names();
extern char *dm_type2name();
extern int *dm_types();
#if 0
extern int dm_send_xevent;
#endif

static int dm_best_type_tcl();
static int dm_best_name_tcl();
static int dm_name2type_tcl();
static int dm_names_tcl();
static int dm_type2name_tcl();
static int dm_types_tcl();
#if 0
static int dm_send_xevent_tcl();
#endif
d11 3
d20 2
a21 9
  "dm_best_type", dm_best_type_tcl,
  "dm_best_name", dm_best_name_tcl,
  "dm_name2type", dm_name2type_tcl,
  "dm_names", dm_names_tcl,
  "dm_type2name", dm_type2name_tcl,
  "dm_types", dm_types_tcl,
#if 0
  "dm_send_xevent", dm_send_xevent_tcl,
#endif
d40 1
a40 75
dm_best_type_tcl(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct bu_vls vls;

  bu_vls_init(&vls);

  if(argc != 1){
    bu_vls_printf(&vls, "helplib dm_best_type");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  bu_vls_printf(&vls, "%d", dm_best_type());
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  bu_vls_free(&vls);

  return TCL_OK;
}

static int
dm_best_name_tcl(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  if(argc != 1){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "helplib dm_best_type");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  Tcl_AppendResult(interp, dm_best_name(), (char *)NULL);

  return TCL_OK;
}

static int
dm_name2type_tcl(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  int type;
  struct bu_vls vls;

  bu_vls_init(&vls);

  if(argc != 2){
    bu_vls_printf(&vls, "helplib dm_name2type");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  type = dm_name2type(argv[1]);
  bu_vls_printf(&vls, "%d", type);
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  bu_vls_free(&vls);

  return TCL_OK;
}

static int
dm_names_tcl(clientData, interp, argc, argv)
a46 2
  char **names;
  char **cpp;
d50 2
a51 2
  if(argc != 1){
    bu_vls_printf(&vls, "helplib dm_names");
d57 1
a57 6
  names = dm_names();
  bu_vls_printf(&vls, "{");
  for(cpp = names; *cpp != (char *)NULL; ++cpp)
    bu_vls_printf(&vls, " %s", *cpp);

  bu_vls_printf(&vls, " }");
a59 1
  bu_free((genptr_t)names, "dm_names_tcl: names");
d65 1
a65 1
dm_type2name_tcl(clientData, interp, argc, argv)
a70 2
  char *name;

d75 1
a75 27
    bu_vls_printf(&vls, "helplib dm_type2name");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  name = dm_type2name(atoi(argv[1]));
  Tcl_AppendResult(interp, name, (char *)NULL);

  return TCL_OK;
}

static int
dm_types_tcl(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct bu_vls vls;
  int *types;
  int *ip;

  bu_vls_init(&vls);

  if(argc != 1){
    bu_vls_printf(&vls, "helplib dm_types");
d81 1
a81 10
  types = dm_types();
  bu_vls_printf(&vls, "{");
  for(ip = types; *ip != DM_TYPE_BAD; ++ip)
    bu_vls_printf(&vls, " %d", *ip);

  bu_vls_printf(&vls, " }");
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  bu_vls_free(&vls);
  bu_free((genptr_t)types, "dm_types_tcl: types");

a83 43

#if 0
/*XXX experimenting */
static int
dm_send_xevent_tcl(clientData, interp, argc, argv)
ClientData	clientData;
Tcl_Interp     *interp;
int		argc;
char	      **argv;
{
  Tk_Window tk_w;
  Display *dpy;
  Window w;
  int type;
  int propagate;

  if(argc != 4){
    struct bu_vls vls;

    bu_vls_init(&vls)
    bu_vls_printf(&vls, "helplib dm_send_xevent");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  tk_w = Tk_NameToWindow(interp, argv[1], tkwin);
  dpy = Tk_Display(tk_w);
  w = Tk_WindowId(tk_w);

  if(sscanf(argv[2], "%d", &type) != 1){
    Tcl_AppendResult(interp, "dm_send_xevent_tcl: failed to get event type", (char *)NULL);
    return TCL_ERROR;
  }

  if(sscanf(argv[2], "%d", &propagate) != 1){
    Tcl_AppendResult(interp, "dm_send_xevent_tcl: failed to get propagation", (char *)NULL);
    return TCL_ERROR;
  }

  return dm_send_xevent(dpy, w, type, propagate, argv[3]);
}
#endif
@


1.3
log
@call helplib instead of help
@
text
@d2 1
a2 1
#include "tcl.h"
d14 3
d24 3
d40 3
d224 43
@


1.2
log
@Functions were declared as "static int", but defined as "int".
@
text
@d38 1
a38 1
dm_Tcl_Init(interp)
d63 1
a63 1
    bu_vls_printf(&vls, "help dm_best_type");
d87 1
a87 1
    bu_vls_printf(&vls, "help dm_best_type");
d111 1
a111 1
    bu_vls_printf(&vls, "help dm_name2type");
d139 1
a139 1
    bu_vls_printf(&vls, "help dm_names");
d171 1
a171 1
    bu_vls_printf(&vls, "help dm_type2name");
d197 1
a197 1
    bu_vls_printf(&vls, "help dm_types");
@


1.1
log
@Initial revision
@
text
@d51 1
a51 1
int
d76 1
a76 1
int
d98 1
a98 1
int
d125 1
a125 1
int
d158 1
a158 1
int
d183 1
a183 1
int
@
