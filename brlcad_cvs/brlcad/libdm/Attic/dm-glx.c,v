head	1.29;
access;
symbols
	ansi-20040405-merged:1.26.4.1
	postmerge-20040405-ansi:1.27
	premerge-20040404-ansi:1.27
	postmerge-autoconf:1.27
	autoconf-freeze:1.26.12.2
	premerge-autoconf:1.27
	ansi-20040316-freeze:1.26
	postmerge-20040315-windows:1.27
	premerge-20040315-windows:1.27
	windows-20040315-freeze:1.26.6.1
	autoconf-20031203:1.26
	autoconf-20031202:1.26
	autoconf-branch:1.26.0.12
	phong-branch:1.26.0.10
	photonmap-branch:1.26.0.8
	rel-6-1-DP:1.26
	windows-branch:1.26.0.6
	rel-6-0-2:1.26
	ansi-branch:1.26.0.4
	rel-6-0-1-branch:1.26.0.2
	hartley-6-0-post:1.26
	hartley-6-0-pre:1.26
	rel-6-0-1:1.26
	rel-6-0:1.26
	rel-5-4:1.25
	offsite-5-3-pre:1.25
	rel-5-3:1.25
	rel-5-2:1.25
	rel-5-1-branch:1.25.0.2
	rel-5-1:1.25
	rel-5-0:1.25
	rel-5-0-beta:1.25
	rel-4-5:1.25
	ctj-4-5-post:1.18
	ctj-4-5-pre:1.18;
locks; strict;
comment	@ * @;


1.29
date	2004.05.21.18.06.25;	author morrison;	state dead;
branches;
next	1.28;

1.28
date	2004.05.10.15.30.44;	author erikg;	state Exp;
branches;
next	1.27;

1.27
date	2004.02.02.17.39.08;	author morrison;	state Exp;
branches;
next	1.26;

1.26
date	2001.03.31.01.56.52;	author morrison;	state Exp;
branches
	1.26.4.1
	1.26.6.1
	1.26.12.1;
next	1.25;

1.25
date	98.01.05.20.29.08;	author bparker;	state Exp;
branches;
next	1.24;

1.24
date	97.11.21.21.01.07;	author bparker;	state Exp;
branches;
next	1.23;

1.23
date	97.11.03.20.07.53;	author bparker;	state Exp;
branches;
next	1.22;

1.22
date	97.10.10.21.10.40;	author bparker;	state Exp;
branches;
next	1.21;

1.21
date	97.10.10.13.00.41;	author bparker;	state Exp;
branches;
next	1.20;

1.20
date	97.09.23.21.16.40;	author bparker;	state Exp;
branches;
next	1.19;

1.19
date	97.08.01.21.25.41;	author bparker;	state Exp;
branches;
next	1.18;

1.18
date	97.05.21.13.04.09;	author bparker;	state Exp;
branches;
next	1.17;

1.17
date	97.05.08.14.17.19;	author bparker;	state Exp;
branches;
next	1.16;

1.16
date	97.04.24.18.14.07;	author bparker;	state Exp;
branches;
next	1.15;

1.15
date	97.04.23.18.37.50;	author bparker;	state Exp;
branches;
next	1.14;

1.14
date	97.04.22.15.05.13;	author bparker;	state Exp;
branches;
next	1.13;

1.13
date	97.03.03.19.59.39;	author bparker;	state Exp;
branches;
next	1.12;

1.12
date	97.03.03.18.32.11;	author bparker;	state Exp;
branches;
next	1.11;

1.11
date	97.01.24.21.06.44;	author bparker;	state Exp;
branches;
next	1.10;

1.10
date	97.01.02.20.05.30;	author bparker;	state Exp;
branches;
next	1.9;

1.9
date	96.12.04.21.25.31;	author bparker;	state Exp;
branches;
next	1.8;

1.8
date	96.10.24.22.13.14;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	96.10.23.20.28.49;	author bparker;	state Exp;
branches;
next	1.6;

1.6
date	96.10.04.20.29.03;	author bparker;	state Exp;
branches;
next	1.5;

1.5
date	96.09.30.19.40.38;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	96.09.26.20.37.27;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	96.09.25.20.28.29;	author bparker;	state Exp;
branches;
next	1.2;

1.2
date	96.09.23.17.43.56;	author bparker;	state Exp;
branches;
next	1.1;

1.1
date	96.09.17.21.25.19;	author bparker;	state Exp;
branches;
next	;

1.26.4.1
date	2004.03.17.21.16.57;	author morrison;	state Exp;
branches;
next	;

1.26.6.1
date	2004.03.11.23.42.00;	author morrison;	state Exp;
branches;
next	;

1.26.12.1
date	2004.02.12.19.45.18;	author erikg;	state Exp;
branches;
next	1.26.12.2;

1.26.12.2
date	2004.03.15.14.06.18;	author erikg;	state Exp;
branches;
next	;


desc
@GL/X Display Manager
@


1.29
log
@moved to src/
@
text
@/*
   Just a note:

   These particular commands should not be used in
   mixed mode programming.

   qdevice
   blkqread
   qtest
   getbutton
   getvaluator
   setvaluator
   unqdevice
   mapcolor
   gconfig
   doublebuffer
   RGBmode
   winopen
   foreground
   noborder
   keepaspect
   prefposition
*/
/*
 *			D M - G L X . C
 *
 *  This display manager started out with the guts from DM-4D which
 *  was modified to use mixed-mode (i.e. gl and X )
 *
 *  Authors -
 *      Robert G. Parker
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1988-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libdm/dm-glx.c,v 1.28 2004/05/10 15:30:44 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include "tk.h"

#ifdef HAVE_XOSDEFS_H
#include <X11/Xfuncproto.h>
#include <X11/Xosdefs.h>
#endif

#include <gl/glws.h>
#include <X11/extensions/XInput.h>
#include <X11/Xutil.h>
#include <sys/invent.h>

#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <math.h>
#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "dm.h"
#include "dm-glx.h"
#include "solid.h"

#define YSTEREO		491	/* subfield height, in scanlines */
#define YOFFSET_LEFT	532	/* YSTEREO + YBLANK ? */

extern Tk_Window tkwin;
extern inventory_t	*getinvent();
extern char ogl_ogl_used;
extern char ogl_sgi_used;

/* Display Manager package interface */

#define IRBOUND	4095.9	/* Max magnification in Rot matrix */

/* These functions and variables are available to applications */
void    glx_configureWindowShape();
void	glx_lighting();
void	glx_zbuffer();
void glx_clearToBlack();

struct glx_vars head_glx_vars;
/* End of functions and variables that are available to applications */


static void set_window();
static XVisualInfo *extract_visual();
static unsigned long extract_value();

static void glx_var_init();
static void glx_make_materials();

struct dm	*glx_open();
static int	glx_close();
static int	glx_drawBegin(), glx_drawEnd();
static int	glx_normal(), glx_loadMatrix();
static int	glx_drawString2D(), glx_drawLine2D();
static int      glx_drawPoint2D();
static int	glx_drawVList();
static int      glx_setColor(), glx_setLineAttr();
static int	glx_setWinBounds(), glx_debug();
static int      glx_beginDList(), glx_endDList();
static int      glx_drawDList();
static int      glx_freeDLists();

static GLXconfig glx_config_wish_list [] = {
  { GLX_NORMAL, GLX_WINDOW, GLX_NONE },
  { GLX_NORMAL, GLX_VISUAL, GLX_NONE},
  { GLX_NORMAL, GLX_DOUBLE, TRUE },
  { GLX_NORMAL, GLX_RGB, TRUE },
  { GLX_NORMAL, GLX_RGBSIZE, GLX_NOCONFIG},
  { GLX_NORMAL, GLX_ZSIZE, GLX_NOCONFIG },
  { 0, 0, 0 }
};

static double	xlim_view = 1.0;	/* args for ortho() */
static double	ylim_view = 1.0;

struct dm dm_glx = {
  glx_close,
  glx_drawBegin,
  glx_drawEnd,
  glx_normal,
  glx_loadMatrix,
  glx_drawString2D,
  glx_drawLine2D,
  glx_drawPoint2D,
  glx_drawVList,
  glx_setColor,
  glx_setLineAttr,
  glx_setWinBounds,
  glx_debug,
  glx_beginDList,
  glx_endDList,
  glx_drawDList,
  glx_freeDLists,
  0,
  1,			/* has displaylist */
  0,                    /* no stereo by default */
  IRBOUND,
  "glx",
  "SGI - mixed mode", 
  DM_TYPE_GLX,
  1,
  0,
  0,
  0,
  0,
  1.0, /* aspect ratio */
  0,
  0,
  0,
  0,
  0
};

/*
 *			G L X _ O P E N
 *
 */
struct dm *
glx_open(argc, argv)
int argc;
char *argv[];
{
  static int count = 0;
  register int	i;
  Matrix		m;
  inventory_t	*inv;
  struct bu_vls str;
  struct bu_vls init_proc_vls;
  int j, k;
  int ndevices;
  int nclass = 0;
  int make_square = -1;
  XDeviceInfoPtr olist, list;
  XDevice *dev;
  XEventClass e_class[15];
  XInputClassInfo *cip;
  GLXconfig *p, *glx_config;
  XVisualInfo *visual_info;
  struct dm *dmp;

  BU_GETSTRUCT(dmp, dm);
  if(dmp == DM_NULL)
    return DM_NULL;

  *dmp = dm_glx;  /* struct copy */

  /* Only need to do this once for this display manager */
  if(!count){
    bzero((void *)&head_glx_vars, sizeof(struct glx_vars));
    BU_LIST_INIT( &head_glx_vars.l );
  }

  BU_GETSTRUCT(dmp->dm_vars, glx_vars);
  if(dmp->dm_vars == (genptr_t)NULL){
    bu_free(dmp, "glx_open: dmp");
    return DM_NULL;
  }

  bu_vls_init(&dmp->dm_pathName);
  bu_vls_init(&dmp->dm_tkName);
  bu_vls_init(&dmp->dm_dName);
  bu_vls_init(&init_proc_vls);

  i = dm_processOptions(dmp, &init_proc_vls, --argc, ++argv);

  if(bu_vls_strlen(&dmp->dm_pathName) == 0)
     bu_vls_printf(&dmp->dm_pathName, ".dm_glx%d", count);

  ++count;
  if(bu_vls_strlen(&dmp->dm_dName) == 0){
    char *dp;

    dp = getenv("DISPLAY");
    if(dp)
      bu_vls_strcpy(&dmp->dm_dName, dp);
    else
      bu_vls_strcpy(&dmp->dm_dName, ":0.0");
  }

  if(bu_vls_strlen(&init_proc_vls) == 0)
    bu_vls_strcpy(&init_proc_vls, "bind_dm");

  /* initialize dm specific variables */
  ((struct glx_vars *)dmp->dm_vars)->devmotionnotify = LASTEvent;
  ((struct glx_vars *)dmp->dm_vars)->devbuttonpress = LASTEvent;
  ((struct glx_vars *)dmp->dm_vars)->devbuttonrelease = LASTEvent;

  /* initialize modifiable variables */
  ((struct glx_vars *)dmp->dm_vars)->mvars.zclipping_on = 1;       /* Z Clipping flag */
  ((struct glx_vars *)dmp->dm_vars)->mvars.zbuffer_on = 1;         /* Hardware Z buffer is on */

  BU_LIST_APPEND(&head_glx_vars.l, &((struct glx_vars *)dmp->dm_vars)->l);

#ifdef DM_OGL
  /* This is a hack to handle the fact that the sgi attach crashes
   * if a direct OpenGL context has been previously opened in the 
   * current mged session. This stops the attach before it crashes.
   */
  if (ogl_ogl_used){
    Tcl_AppendResult(interp, "Can't attach sgi, because a direct OpenGL context has\n",
		     "previously been opened in this session. To use sgi,\n",
		     "quit this session and reopen it.\n", (char *)NULL);
    bu_vls_free(&init_proc_vls);
    (void)glx_close(dmp);
    return DM_NULL;
  }
  ogl_sgi_used = 1;
#endif /* DM_OGL */

  if(dmp->dm_top){
    ((struct glx_vars *)dmp->dm_vars)->xtkwin =
      Tk_CreateWindowFromPath(interp, tkwin,
			      bu_vls_addr(&dmp->dm_pathName),
			      bu_vls_addr(&dmp->dm_dName));
    ((struct glx_vars *)dmp->dm_vars)->top = ((struct glx_vars *)dmp->dm_vars)->xtkwin;
  }else{
    char *cp;

    cp = strrchr(bu_vls_addr(&dmp->dm_pathName), (int)'.');
    if(cp == bu_vls_addr(&dmp->dm_pathName)){
      ((struct glx_vars *)dmp->dm_vars)->top = tkwin;
    }else{
      struct bu_vls top_vls;

      bu_vls_init(&top_vls);
      bu_vls_printf(&top_vls, "%*s", cp - bu_vls_addr(&dmp->dm_pathName),
		    bu_vls_addr(&dmp->dm_pathName));
      ((struct glx_vars *)dmp->dm_vars)->top =
	Tk_NameToWindow(interp, bu_vls_addr(&top_vls), tkwin);
      bu_vls_free(&top_vls);
    }

    /* Make xtkwin an embedded window */
    ((struct glx_vars *)dmp->dm_vars)->xtkwin =
      Tk_CreateWindow(interp, ((struct glx_vars *)dmp->dm_vars)->top,
		      cp + 1, (char *)NULL);
  }

  if(((struct glx_vars *)dmp->dm_vars)->xtkwin == NULL){
    Tcl_AppendResult(interp, "dm-X: Failed to open ",
		     bu_vls_addr(&dmp->dm_pathName),
		     "\n", (char *)NULL);
    bu_vls_free(&init_proc_vls);
    (void)glx_close(dmp);
    return DM_NULL;
  }

  {
    int return_val;

    if(!XQueryExtension(Tk_Display(((struct glx_vars *)dmp->dm_vars)->top), "SGI-GLX",
			&return_val, &return_val, &return_val)){
      bu_vls_free(&init_proc_vls);
      (void)glx_close(dmp);
      return DM_NULL;
    }
  }

  bu_vls_printf(&dmp->dm_tkName, "%s",
		(char *)Tk_Name(((struct glx_vars *)dmp->dm_vars)->xtkwin));

  bu_vls_init(&str);
  bu_vls_printf(&str, "_init_dm %S %S \n",
		&init_proc_vls,
		&dmp->dm_pathName);

  if(Tcl_Eval(interp, bu_vls_addr(&str)) == TCL_ERROR){
    bu_vls_free(&init_proc_vls);
    bu_vls_free(&str);
    (void)glx_close(dmp);

    return DM_NULL;
  }

  bu_vls_free(&init_proc_vls);
  bu_vls_free(&str);

  ((struct glx_vars *)dmp->dm_vars)->dpy =
    Tk_Display(((struct glx_vars *)dmp->dm_vars)->top);

  if(dmp->dm_width == 0){
    dmp->dm_width =
      DisplayWidth(((struct glx_vars *)dmp->dm_vars)->dpy,
		   DefaultScreen(((struct glx_vars *)dmp->dm_vars)->dpy)) - 30;
    ++make_square;
  }

  if(dmp->dm_height == 0){
    dmp->dm_height =
      DisplayHeight(((struct glx_vars *)dmp->dm_vars)->dpy,
		    DefaultScreen(((struct glx_vars *)dmp->dm_vars)->dpy)) - 30;
    ++make_square;
  }

  if(make_square > 0){
    /* Make window square */
    if( dmp->dm_height <
	dmp->dm_width )
      dmp->dm_width = dmp->dm_height;
    else /* we have a funky shaped monitor */ 
      dmp->dm_height = dmp->dm_width;
  }

  Tk_GeometryRequest(((struct glx_vars *)dmp->dm_vars)->xtkwin,
		     dmp->dm_width,
		     dmp->dm_height);

  glx_config = GLXgetconfig(((struct glx_vars *)dmp->dm_vars)->dpy,
			    Tk_ScreenNumber(((struct glx_vars *)dmp->dm_vars)->xtkwin),
			    glx_config_wish_list);
  ((struct glx_vars *)dmp->dm_vars)->vip = extract_visual(dmp, GLX_NORMAL, glx_config);
  ((struct glx_vars *)dmp->dm_vars)->depth = ((struct glx_vars *)dmp->dm_vars)->vip->depth;
  ((struct glx_vars *)dmp->dm_vars)->cmap = extract_value(GLX_NORMAL, GLX_COLORMAP,
							   glx_config);
  if(Tk_SetWindowVisual(((struct glx_vars *)dmp->dm_vars)->xtkwin,
			((struct glx_vars *)dmp->dm_vars)->vip->visual,
			((struct glx_vars *)dmp->dm_vars)->depth,
			((struct glx_vars *)dmp->dm_vars)->cmap) == 0){
    (void)glx_close(dmp);
    return DM_NULL;
  }

  Tk_MakeWindowExist(((struct glx_vars *)dmp->dm_vars)->xtkwin);
  ((struct glx_vars *)dmp->dm_vars)->win =
    Tk_WindowId(((struct glx_vars *)dmp->dm_vars)->xtkwin);
  dmp->dm_id = (unsigned long)((struct glx_vars *)dmp->dm_vars)->win;
  set_window(GLX_NORMAL, ((struct glx_vars *)dmp->dm_vars)->win, glx_config);

  /* Inform the GL that you intend to render GL into an X window */
  if(GLXlink(((struct glx_vars *)dmp->dm_vars)->dpy, glx_config) < 0){
    (void)glx_close(dmp);
    return DM_NULL;
  }

  GLXwinset(((struct glx_vars *)dmp->dm_vars)->dpy,
	    ((struct glx_vars *)dmp->dm_vars)->win);

  /* set configuration variables */
  for(p = glx_config; p->buffer; ++p){
    switch(p->buffer){
    case GLX_NORMAL:
      switch(p->mode){
      case GLX_ZSIZE:
	if(p->arg)
	  ((struct glx_vars *)dmp->dm_vars)->mvars.zbuf = 1;
	else
	  ((struct glx_vars *)dmp->dm_vars)->mvars.zbuf = 0;

	break;
      case GLX_RGB:
	if(p->arg)
	  ((struct glx_vars *)dmp->dm_vars)->mvars.rgb = 1;
	else
	  ((struct glx_vars *)dmp->dm_vars)->mvars.rgb = 0;
	
	break;
      case GLX_DOUBLE:
	if(p->arg)
	  ((struct glx_vars *)dmp->dm_vars)->mvars.doublebuffer = 1;
	else
	  ((struct glx_vars *)dmp->dm_vars)->mvars.doublebuffer = 0;

	break;
      case GLX_STEREOBUF:
	((struct glx_vars *)dmp->dm_vars)->stereo_is_on = 1;

	break;
      case GLX_BUFSIZE:
      case GLX_STENSIZE:
      case GLX_ACSIZE:
      case GLX_VISUAL:
      case GLX_COLORMAP:
      case GLX_WINDOW:
      case GLX_MSSAMPLE:
      case GLX_MSZSIZE:
      case GLX_MSSSIZE:
      case GLX_RGBSIZE:
      default:
	break;
      }
    case GLX_OVERLAY:
    case GLX_POPUP:
    case GLX_UNDERLAY:
    default:
      break;
    }
  }

  free((void *)glx_config);

  winconstraints();	/* remove constraints on the window size */

  /*
   * Establish GL library operating modes
   */
  /* Don't draw polygon edges */
  glcompat( GLC_OLDPOLYGON, 0 );

  /* Z-range mapping */
  /* Z range from getgdesc(GD_ZMIN)
   * to getgdesc(GD_ZMAX).
   * Hardware specific.
   */
  glcompat( GLC_ZRANGEMAP, 0 );

  /* Take off a smidgeon for wraparound, as suggested by SGI manual */

  ((struct glx_vars *)dmp->dm_vars)->mvars.min_scr_z = getgdesc(GD_ZMIN)+15;
  ((struct glx_vars *)dmp->dm_vars)->mvars.max_scr_z = getgdesc(GD_ZMAX)-15;

  if( ((struct glx_vars *)dmp->dm_vars)->mvars.doublebuffer){
    /* Clear out image from windows underneath */
    frontbuffer(1);
    glx_clearToBlack(dmp);
    frontbuffer(0);
    glx_clearToBlack(dmp);
  }

  glx_configureWindowShape(dmp);

  /* Line style 0 is solid.  Program line style 1 as dot-dashed */
  deflinestyle( 1, 0xCF33 );
  setlinestyle( 0 );

  /*
   * Take a look at the available input devices. We're looking
   * for "dial+buttons".
   */
  olist = list =
    (XDeviceInfoPtr)XListInputDevices(((struct glx_vars *)dmp->dm_vars)->dpy, &ndevices);

  /* IRIX 4.0.5 bug workaround */
  if( list == (XDeviceInfoPtr)NULL ||
      list == (XDeviceInfoPtr)1 )  goto Done;

  for(j = 0; j < ndevices; ++j, list++){
    if(list->use == IsXExtensionDevice){
      if(!strcmp(list->name, "dial+buttons")){
	if((dev = XOpenDevice(((struct glx_vars *)dmp->dm_vars)->dpy,
			      list->id)) == (XDevice *)NULL){
	  Tcl_AppendResult(interp, "glx_open: Couldn't open the dials+buttons\n",
			   (char *)NULL);
	  goto Done;
	}

	for(cip = dev->classes, k = 0; k < dev->num_classes;
	    ++k, ++cip){
	  switch(cip->input_class){
#if IR_BUTTONS
	  case ButtonClass:
	    DeviceButtonPress(dev, ((struct glx_vars *)dmp->dm_vars)->devbuttonpress,
			      e_class[nclass]);
	    ++nclass;
	    DeviceButtonRelease(dev, ((struct glx_vars *)dmp->dm_vars)->devbuttonrelease,
				e_class[nclass]);
	    ++nclass;
#endif
	    break;
#if IR_KNOBS
	  case ValuatorClass:
	    DeviceMotionNotify(dev, ((struct glx_vars *)dmp->dm_vars)->devmotionnotify,
			       e_class[nclass]);
	    ++nclass;
	    break;
#endif
	  default:
	    break;
	  }
	}

	XSelectExtensionEvent(((struct glx_vars *)dmp->dm_vars)->dpy,
			      ((struct glx_vars *)dmp->dm_vars)->win, e_class, nclass);
	goto Done;
      }
    }
  }
Done:
  XFreeDeviceList(olist);

  Tk_MapWindow(((struct glx_vars *)dmp->dm_vars)->xtkwin);
  return dmp;
}


/* 
 *			G L X _ C O N F I G U R E W I N D O W S H A P E
 *
 *  Either initially, or on resize/reshape of the window,
 *  sense the actual size of the window, and perform any
 *  other initializations of the window configuration.
 */
void
glx_configureWindowShape(dmp)
struct dm *dmp;
{
  int		npix;
  XWindowAttributes xwa;

  if (((struct glx_vars *)dmp->dm_vars)->mvars.debug)
    Tcl_AppendResult(interp, "glx_configureWindowShape()\n", (char *)NULL);

  XGetWindowAttributes( ((struct glx_vars *)dmp->dm_vars)->dpy,
			((struct glx_vars *)dmp->dm_vars)->win, &xwa );
  dmp->dm_width = xwa.width;
  dmp->dm_height = xwa.height;

  /* Write enable all the bloody bits after resize! */
  viewport(0, dmp->dm_width, 0,
	   dmp->dm_height);

  if( ((struct glx_vars *)dmp->dm_vars)->mvars.zbuf )
    glx_zbuffer(dmp);

  glx_lighting(dmp);
  glx_clearToBlack(dmp);

  ortho( -xlim_view, xlim_view, -ylim_view, ylim_view, -1.0, 1.0 );
  dmp->dm_aspect =
    (fastf_t)dmp->dm_height/
    (fastf_t)dmp->dm_width;
}

/*
 *  			G L X _ C L O S E
 *  
 *  Gracefully release the display.  Well, mostly gracefully -- see
 *  the comments in the open routine.
 */
static int
glx_close(dmp)
struct dm *dmp;
{
  if(((struct glx_vars *)dmp->dm_vars)->dpy){
    if(((struct glx_vars *)dmp->dm_vars)->mvars.cueing_on)
      depthcue(0);

    lampoff( 0xf );

    /* avoids error messages when reattaching */
    mmode(MVIEWING);	
    lmbind(LIGHT2,0);
    lmbind(LIGHT3,0);
    lmbind(LIGHT4,0);
    lmbind(LIGHT5,0);

    frontbuffer(1);
    glx_clearToBlack(dmp);
    frontbuffer(0);

    GLXunlink(((struct glx_vars *)dmp->dm_vars)->dpy,
	      ((struct glx_vars *)dmp->dm_vars)->win);
  }

  if(((struct glx_vars *)dmp->dm_vars)->xtkwin != NULL)
    Tk_DestroyWindow(((struct glx_vars *)dmp->dm_vars)->xtkwin);

  if(((struct glx_vars *)dmp->dm_vars)->l.forw != BU_LIST_NULL)
    BU_LIST_DEQUEUE(&((struct glx_vars *)dmp->dm_vars)->l);

  bu_vls_free(&dmp->dm_pathName);
  bu_vls_free(&dmp->dm_tkName);
  bu_vls_free(&dmp->dm_dName);
  bu_free(dmp->dm_vars, "glx_close: glx_vars");
  bu_free(dmp, "glx_close: dmp");

  return TCL_OK;
}

/*
 *			G L X _ D R A W B E G I N
 *
 * Define the world, and include in it instances of all the
 * important things.
 */
static int
glx_drawBegin(dmp)
struct dm *dmp;
{
  if (((struct glx_vars *)dmp->dm_vars)->mvars.debug)
    Tcl_AppendResult(interp, "glx_drawBegin()\n", (char *)NULL);

  if(GLXwinset(((struct glx_vars *)dmp->dm_vars)->dpy,
	       ((struct glx_vars *)dmp->dm_vars)->win) < 0){
    Tcl_AppendResult(interp, "glx_drawBegin: GLXwinset() failed\n", (char *)NULL);
    return TCL_ERROR;
  }

  ortho( -xlim_view, xlim_view, -ylim_view, ylim_view, -1.0, 1.0 );

  if( !((struct glx_vars *)dmp->dm_vars)->mvars.doublebuffer )
    glx_clearToBlack(dmp);

  return TCL_OK;
}

/*
 *			G L X _ D R A W E N D
 *
 * End the drawing sequence.
 */
static int
glx_drawEnd(dmp)
struct dm *dmp;
{
  if (((struct glx_vars *)dmp->dm_vars)->mvars.debug)
    Tcl_AppendResult(interp, "glx_drawEnd()\n", (char *)NULL);

  /*
   * A Point, in the Center of the Screen.
   * This is drawn last, to always come out on top.
   */
  glx_drawLine2D( dmp, 0, 0, 0, 0, 0 );
  /* End of faceplate */

  if(((struct glx_vars *)dmp->dm_vars)->mvars.doublebuffer){
    swapbuffers();
    /* give Graphics pipe time to work */
    glx_clearToBlack(dmp);
  }

  return TCL_OK;
}

/*
 *			G L X _ N O R M A L
 *
 * Restore the display processor to a normal mode of operation
 * (ie, not scaled, rotated, displaced, etc).
 */
static int
glx_normal(dmp)
struct dm *dmp;
{
  if (((struct glx_vars *)dmp->dm_vars)->mvars.debug)
    Tcl_AppendResult(interp, "glx_normal()\n", (char *)NULL);

  ortho( -xlim_view, xlim_view, -ylim_view, ylim_view, -1.0, 1.0 );

  return TCL_OK;
}

/*
 *  			G L X _ L O A D M A T R I X
 *
 *  Load a new transformation matrix.  This will be followed by
 *  many calls to glx_drawVList().
 *
 *  IMPORTANT COORDINATE SYSTEM NOTE:
 *
 *  MGED uses a right handed coordinate system where +Z points OUT of
 *  the screen.  The Silicon Graphics uses a left handed coordinate
 *  system where +Z points INTO the screen.
 *  This difference in convention is handled here.
 *  The conversion is accomplished by concatenating a matrix multiply
 *  by
 *            (  1    0    0   0  )
 *            (  0    1    0   0  )
 *            (  0    0   -1   0  )
 *            (  0    0    0   1  )
 *
 *  However, this is actually implemented by straight-line code which
 *  flips the sign on the entire third row.
 *
 *  Note that through BRL-CAD Release 3.7 this was handled by flipping
 *  the direction of the shade ramps.  Now, with the Z-buffer being used,
 *  the correct solution is important.
 */
static int
glx_loadMatrix(dmp, mat, which_eye)
struct dm *dmp;
mat_t	mat;
int which_eye;
{
  register fastf_t *mptr;
  Matrix	gtmat;
  mat_t	newm;
  int	i;

  if(((struct glx_vars *)dmp->dm_vars)->mvars.debug){
    struct bu_vls tmp_vls;

    Tcl_AppendResult(interp, "glx_loadMatrix()\n", (char *)NULL);

    bu_vls_init(&tmp_vls);
    bu_vls_printf(&tmp_vls, "which eye = %d\t", which_eye);
    bu_vls_printf(&tmp_vls, "transformation matrix = \n");
    bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[0], mat[4], mat[8],mat[12]);
    bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[1], mat[5], mat[9],mat[13]);
    bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[2], mat[6], mat[10],mat[14]);
    bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[3], mat[7], mat[11],mat[15]);

    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
    bu_vls_free(&tmp_vls);
  }

  switch(which_eye)  {
  case 0:
    /* Non-stereo */
    break;
  case 1:
    /* R eye */
    viewport(0, XMAXSCREEN, 0, YSTEREO);
    glx_drawString2D( dmp, "R", 2020, 0, 0, DM_RED );
    break;
  case 2:
    /* L eye */
    viewport(0, XMAXSCREEN, 0+YOFFSET_LEFT, YSTEREO+YOFFSET_LEFT);
    break;
  }

  if( ! ((struct glx_vars *)dmp->dm_vars)->mvars.zclipping_on ) {
    mat_t	nozclip;

    MAT_IDN( nozclip );
    nozclip[10] = 1.0e-20;
    bn_mat_mul( newm, nozclip, mat );
    mptr = newm;
  } else {
    mptr = mat;
  }

  gtmat[0][0] = *(mptr++) * dmp->dm_aspect;
  gtmat[1][0] = *(mptr++) * dmp->dm_aspect;
  gtmat[2][0] = *(mptr++) * dmp->dm_aspect;
  gtmat[3][0] = *(mptr++) * dmp->dm_aspect;

  gtmat[0][1] = *(mptr++);
  gtmat[1][1] = *(mptr++);
  gtmat[2][1] = *(mptr++);
  gtmat[3][1] = *(mptr++);

  gtmat[0][2] = *(mptr++);
  gtmat[1][2] = *(mptr++);
  gtmat[2][2] = *(mptr++);
  gtmat[3][2] = *(mptr++);

  gtmat[0][3] = *(mptr++);
  gtmat[1][3] = *(mptr++);
  gtmat[2][3] = *(mptr++);
  gtmat[3][3] = *(mptr++);

  /*
   *  Convert between MGED's right handed coordinate system
   *  where +Z comes out of the screen to the Silicon Graphics's
   *  left handed coordinate system, where +Z goes INTO the screen.
   */
  gtmat[0][2] = -gtmat[0][2];
  gtmat[1][2] = -gtmat[1][2];
  gtmat[2][2] = -gtmat[2][2];
  gtmat[3][2] = -gtmat[3][2];

  loadmatrix( gtmat );
  return TCL_OK;
}

static float material_objdef[] = {
	ALPHA,		1.0,	
	AMBIENT,	0.2, 0.2, 0.2,	/* 0.4 in rt */
	DIFFUSE,	0.6, 0.6, 0.6,
	SPECULAR,	0.2, 0.2, 0.2,
	EMISSION,	0.0, 0.0, 0.0,
	SHININESS,	10.0,
	LMNULL   };

/*
 *  			G L X _ O B J E C T
 *  
 */
static int
glx_drawVList( dmp, vp )
struct dm *dmp;
register struct rt_vlist *vp;
{
  register struct rt_vlist	*tvp;
  register int nvec;
  register float	*gtvec;
  char	gtbuf[16+3*sizeof(double)];
  int first;
  int i,j;

  if (((struct glx_vars *)dmp->dm_vars)->mvars.debug)
    Tcl_AppendResult(interp, "glx_drawVList()\n", (char *)NULL);

  /*
   *  It is claimed that the "dancing vector disease" of the
   *  4D GT processors is due to the array being passed to v3f()
   *  not being quad-word aligned (16-byte boundary).
   *  This hack ensures that the buffer has this alignment.
   *  Note that this requires gtbuf to be 16 bytes longer than needed.
   */
  gtvec = (float *)((((int)gtbuf)+15) & (~0xF));

  /* Viewing region is from -1.0 to +1.0 */
  first = 1;
  for( BU_LIST_FOR( tvp, rt_vlist, &vp->l ) )  {
    register int	i;
    register int	nused = tvp->nused;
    register int	*cmd = tvp->cmd;
    register point_t *pt = tvp->pt;
    for( i = 0; i < nused; i++,cmd++,pt++ )  {
      switch( *cmd )  {
      case RT_VLIST_LINE_MOVE:
	/* Move, start line */
	  if( first == 0 )
	    endline();
	  first = 0;
	  bgnline();
	  v3d( *pt );
	  break;
      case RT_VLIST_LINE_DRAW:
	/* Draw line */
	v3d( *pt );
	break;
      case RT_VLIST_POLY_START:
	/* Start poly marker & normal */
	if( first == 0 )
	  endline();
	/* concave(TRUE); */
	bgnpolygon();
	/* Set surface normal (vl_pnt points outward) */
	VMOVE( gtvec, *pt );
	n3f(gtvec);
	break;
      case RT_VLIST_POLY_MOVE:
	/* Polygon Move */
	v3d( *pt );
	break;
      case RT_VLIST_POLY_DRAW:
	/* Polygon Draw */
	v3d( *pt );
	break;
      case RT_VLIST_POLY_END:
	/* Draw, End Polygon */
	v3d( *pt );
	endpolygon();
	first = 1;
	break;
      case RT_VLIST_POLY_VERTNORM:
	/* Set per-vertex normal.  Given before vert. */
	VMOVE( gtvec, *pt );
	n3f(gtvec);
	break;
      }
    }
  }

  if( first == 0 )
    endline();

  return TCL_OK;
}


/*
 *			G L X _ P U T S
 *
 * Output a string.
 * The starting position of the beam is as specified.
 */
static int
glx_drawString2D( dmp, str, x, y, size, use_aspect )
struct dm *dmp;
register char *str;
int x,y;
int size;
int use_aspect;
{
  if (((struct glx_vars *)dmp->dm_vars)->mvars.debug)
    Tcl_AppendResult(interp, "glx_drawString2D()\n", (char *)NULL);

  if(use_aspect)
    cmov2( GED2IRIS(x) * dmp->dm_aspect, GED2IRIS(y));
  else
    cmov2( GED2IRIS(x), GED2IRIS(y));

  charstr( str );

  return TCL_OK;
}

/*
 *			G L X _ D R A W L I N E 2 D
 *
 */
static int
glx_drawLine2D( dmp, x1, y1, x2, y2 )
struct dm *dmp;
int x1, y1;
int x2, y2;
{
  register int nvec;

  if (((struct glx_vars *)dmp->dm_vars)->mvars.debug)
    Tcl_AppendResult(interp, "glx_drawLine2D()\n", (char *)NULL);

  move2( GED2IRIS(x1), GED2IRIS(y1));
  draw2( GED2IRIS(x2), GED2IRIS(y2));

  return TCL_OK;
}

/*
 *                      G L X _ D R A W P O I N T 2 D
 *
 */
static int
glx_drawPoint2D(dmp, x, y)
struct dm *dmp;
int x, y;
{
  if (((struct glx_vars *)dmp->dm_vars)->mvars.debug)
    Tcl_AppendResult(interp, "glx_drawPoint2D()\n", (char *)NULL);

  return glx_drawLine2D(dmp, x, y, x, y);
}

/*
 *                      G L X _ S E T C O L O R
 *
 */
static int
glx_setColor(dmp, r, g, b, strict)
struct dm *dmp;
register short r, g, b;
int strict;
{
  if (((struct glx_vars *)dmp->dm_vars)->mvars.debug)
    Tcl_AppendResult(interp, "glx_setColor()\n", (char *)NULL);

  /*
   * IMPORTANT DEPTHCUEING NOTE
   *
   * Also note that the depthcueing shaderange() routine wanders
   * outside it's allotted range due to roundoff errors.  A buffer
   * entry is kept on each end of the shading curves, and the
   * highlight mode uses the *next* to the brightest entry --
   * otherwise it can (and does) fall off the shading ramp.
   */

  if(strict){
    if(((struct glx_vars *)dmp->dm_vars)->mvars.cueing_on) {
      lRGBrange(r, g, b, r, g, b,
		((struct glx_vars *)dmp->dm_vars)->mvars.min_scr_z,
		((struct glx_vars *)dmp->dm_vars)->mvars.max_scr_z );
    }

    RGBcolor( r, g, b );
  }else{
    if(((struct glx_vars *)dmp->dm_vars)->mvars.cueing_on)  {
      lRGBrange(r/10, g/10, b/10, r, g, b,
		((struct glx_vars *)dmp->dm_vars)->mvars.min_scr_z,
		((struct glx_vars *)dmp->dm_vars)->mvars.max_scr_z );
    } else if(((struct glx_vars *)dmp->dm_vars)->mvars.lighting_on) {
      /* Ambient = .2, Diffuse = .6, Specular = .2 */

      /* Ambient */
      material_objdef[3] = 	.2 * ( r / 255.0);
      material_objdef[4] = 	.2 * ( g / 255.0);
      material_objdef[5] = 	.2 * ( b / 255.0);

      /* diffuse */
      material_objdef[7] = 	.6 * ( r / 255.0);
      material_objdef[8] = 	.6 * ( g / 255.0);
      material_objdef[9] = 	.6 * ( b / 255.0);

      /* Specular */
      material_objdef[11] = 	.2 * ( r / 255.0);
      material_objdef[12] = 	.2 * ( g / 255.0);
      material_objdef[13] = 	.2 * ( b / 255.0);

      lmdef(DEFMATERIAL, 21, 0, material_objdef);
      lmbind(MATERIAL, 21);
    } else
      RGBcolor( r, g, b );
  }

  return TCL_OK;
}

/*
 *                         G L X _ S E T L I N E A T T R
 *
 */
static int
glx_setLineAttr(dmp, width, style)
struct dm *dmp;
int width;
int style;
{
  if (((struct glx_vars *)dmp->dm_vars)->mvars.debug)
    Tcl_AppendResult(interp, "glx_setLineAttr()\n", (char *)NULL);

  dmp->dm_lineWidth = width;
  dmp->dm_lineStyle = style;

  linewidth(width);

  if(style == DM_DASHED_LINE)
    setlinestyle(1);
  else
    setlinestyle(0);

  return TCL_OK;
}

/*
 *                         G L X _ D E B U G
 *
 */
static int
glx_debug(dmp, lvl)
struct dm *dmp;
int lvl;
{
  ((struct glx_vars *)dmp->dm_vars)->mvars.debug = lvl;

  return TCL_OK;
}

/*
 *                         G L X _ S E T W I N B O U N D S
 *
 */
static int
glx_setWinBounds(dmp, w)
struct dm *dmp;
int w[6];
{
  if (((struct glx_vars *)dmp->dm_vars)->mvars.debug)
    Tcl_AppendResult(interp, "glx_setWinBounds()\n", (char *)NULL);

  return TCL_OK;
}

/*
 *                         G L X _ Z B U F F E R
 *
 */
void
glx_zbuffer(dmp)
struct dm *dmp;
{
  if (((struct glx_vars *)dmp->dm_vars)->mvars.debug)
    Tcl_AppendResult(interp, "glx_zbuffer()\n", (char *)NULL);

  if( ((struct glx_vars *)dmp->dm_vars)->mvars.zbuf == 0 )  {
    Tcl_AppendResult(interp, "dm-4d: This machine has no Zbuffer to enable\n",
		     (char *)NULL);
    ((struct glx_vars *)dmp->dm_vars)->mvars.zbuffer_on = 0;
  }

  zbuffer( ((struct glx_vars *)dmp->dm_vars)->mvars.zbuffer_on );

  if(((struct glx_vars *)dmp->dm_vars)->mvars.zbuffer_on)  {
    /* Set screen coords of near and far clipping planes */
    lsetdepth(((struct glx_vars *)dmp->dm_vars)->mvars.min_scr_z,
	      ((struct glx_vars *)dmp->dm_vars)->mvars.max_scr_z);
  }
}

void
glx_clearToBlack(dmp)
struct dm *dmp;
{
  if (((struct glx_vars *)dmp->dm_vars)->mvars.debug)
    Tcl_AppendResult(interp, "glx_clearToBlack()\n", (char *)NULL);

  /* Re-enable the full viewport */
  viewport(0, dmp->dm_width, 0,
	   dmp->dm_height);

  if( ((struct glx_vars *)dmp->dm_vars)->mvars.zbuffer_on )  {
    zfunction( ZF_LEQUAL );
    if( ((struct glx_vars *)dmp->dm_vars)->mvars.rgb )  {
      czclear( 0x000000, ((struct glx_vars *)dmp->dm_vars)->mvars.max_scr_z );
    } else {
      czclear( BLACK, ((struct glx_vars *)dmp->dm_vars)->mvars.max_scr_z );
    }
  } else {
    if( ((struct glx_vars *)dmp->dm_vars)->mvars.rgb )  {
      RGBcolor( (short)0, (short)0, (short)0 );
    } else {
      color(BLACK);
    }
    clear();
  }
}

#if 0
/* Handy fakeouts when we don't want to link with -lmpc */
usinit()	{ 
	bu_log("usinit\n"); 
}
usnewlock()	{ 
	bu_log("usnewlock\n"); 
}
taskcreate()	{ 
	bu_log("taskcreate\n"); 
}
#endif

/*
 *                            G L X _ L I G H T I N G
 *
 *  The struct_parse will change the value of the variable.
 *  Just implement it, here.
 */
void
glx_lighting(dmp)
struct dm *dmp;
{
  if (((struct glx_vars *)dmp->dm_vars)->mvars.debug)
    Tcl_AppendResult(interp, "glx_lighting()\n", (char *)NULL);

  if( !((struct glx_vars *)dmp->dm_vars)->mvars.lighting_on )  {
    /* Turn it off */
    mmode(MVIEWING);
    lmbind(MATERIAL,0);
    lmbind(LMODEL,0);
    mmode(MSINGLE);
  } else {
    /* Turn it on */
    if( ((struct glx_vars *)dmp->dm_vars)->mvars.cueing_on )  {
      /* Has to be off for lighting */
      ((struct glx_vars *)dmp->dm_vars)->mvars.cueing_on = 0;
#if 0
      glx_colorchange(dmp);
#else
      depthcue(0);
#endif
    }

    mmode(MVIEWING);

    glx_make_materials();	/* Define material properties */

    lmbind(LMODEL, 2);	/* infinite */
    lmbind(LIGHT2,2);
    lmbind(LIGHT3,3);
    lmbind(LIGHT4,4);
    lmbind(LIGHT5,5);

    /* RGB color commands & lighting */
    lmcolor( LMC_COLOR );

    mmode(MSINGLE);
  }
}

/*
 *  Some initial lighting model stuff
 *  Really, MGED needs to derrive it's lighting from the database,
 *  but for now, this hack will suffice.
 *
 *  For materials, the definitions are:
 *	ALPHA		opacity.  1.0=opaque
 *	AMBIENT		ambient reflectance of the material  0..1
 *	DIFFUSE		diffuse reflectance of the material  0..1
 *	SPECULAR	specular reflectance of the material  0..1
 *	EMISSION	emission color ???
 *	SHININESS	specular scattering exponent, integer 0..128
 */
static float material_default[] = {
	ALPHA,		1.0,
	AMBIENT,	0.2, 0.2, 0.2,
	DIFFUSE,	0.8, 0.8, 0.8,
	EMISSION,	0.0, 0.0, 0.0,
	SHININESS,	0.0,
	SPECULAR,	0.0, 0.0, 0.0,
	LMNULL   };

/* Something like the RT default phong material */
static float material_rtdefault[] = {
	ALPHA,		1.0,	
	AMBIENT,	0.2, 0.2, 0.2,	/* 0.4 in rt */
	DIFFUSE,	0.6, 0.6, 0.6,
	SPECULAR,	0.2, 0.2, 0.2,
	EMISSION,	0.0, 0.0, 0.0,
	SHININESS,	10.0,
	LMNULL   };

/* This was the "default" material in the demo */
static float material_xdefault[] = {
	AMBIENT, 0.35, 0.25,  0.1,
	DIFFUSE, 0.1, 0.5, 0.1,
	SPECULAR, 0.0, 0.0, 0.0,
	SHININESS, 5.0,
	LMNULL   };

static float mat_brass[] = {
	AMBIENT, 0.35, 0.25,  0.1,
	DIFFUSE, 0.65, 0.5, 0.35,
	SPECULAR, 0.0, 0.0, 0.0,
	SHININESS, 5.0,
	LMNULL   };

static float mat_shinybrass[] = {
	AMBIENT, 0.25, 0.15, 0.0,
	DIFFUSE, 0.65, 0.5, 0.35,
	SPECULAR, 0.9, 0.6, 0.0,
	SHININESS, 10.0,
	LMNULL   };

static float mat_pewter[] = {
	AMBIENT, 0.0, 0.0,  0.0,
	DIFFUSE, 0.6, 0.55 , 0.65,
	SPECULAR, 0.9, 0.9, 0.95,
	SHININESS, 10.0,
	LMNULL   };

static float mat_silver[] = {
	AMBIENT, 0.4, 0.4,  0.4,
	DIFFUSE, 0.3, 0.3, 0.3,
	SPECULAR, 0.9, 0.9, 0.95,
	SHININESS, 30.0,
	LMNULL   };

static float mat_gold[] = {
	AMBIENT, 0.4, 0.2, 0.0,
	DIFFUSE, 0.9, 0.5, 0.0,
	SPECULAR, 0.7, 0.7, 0.0,
	SHININESS, 10.0,
	LMNULL   };

static float mat_shinygold[] = {
	AMBIENT, 0.4, 0.2,  0.0,
	DIFFUSE, 0.9, 0.5, 0.0,
	SPECULAR, 0.9, 0.9, 0.0,
	SHININESS, 20.0,
	LMNULL   };

static float mat_plaster[] = {
	AMBIENT, 0.2, 0.2,  0.2,
	DIFFUSE, 0.95, 0.95, 0.95,
	SPECULAR, 0.0, 0.0, 0.0,
	SHININESS, 1.0,
	LMNULL   };

static float mat_redplastic[] = {
	AMBIENT, 0.3, 0.1, 0.1,
	DIFFUSE, 0.5, 0.1, 0.1,
	SPECULAR, 0.45, 0.45, 0.45,
	SHININESS, 30.0,
	LMNULL   };

static float mat_greenplastic[] = {
	AMBIENT, 0.1, 0.3, 0.1,
	DIFFUSE, 0.1, 0.5, 0.1,
	SPECULAR, 0.45, 0.45, 0.45,
	SHININESS, 30.0,
	LMNULL   };

static float mat_blueplastic[] = {
	AMBIENT, 0.1, 0.1, 0.3,
	DIFFUSE, 0.1, 0.1, 0.5,
	SPECULAR, 0.45, 0.45, 0.45,
	SHININESS, 30.0,
	LMNULL   };

static float mat_greenflat[] = {
	EMISSION,   0.0, 0.4, 0.0,
	AMBIENT,    0.0, 0.0, 0.0,
	DIFFUSE,    0.0, 0.0, 0.0,
	SPECULAR,   0.0, 0.6, 0.0,
	SHININESS, 10.0,
	LMNULL
};

static float mat_greenshiny[]= {
	EMISSION, 0.0, 0.4, 0.0,
	AMBIENT,  0.1, 0.25, 0.1,
	DIFFUSE,  0.5, 0.5, 0.5,
	SPECULAR,  0.25, 0.9, 0.25,
	SHININESS, 10.0,
	LMNULL
};

static float mat_blueflat[] = {
	EMISSION, 0.0, 0.0, 0.4,
	AMBIENT,  0.1, 0.25, 0.1,
	DIFFUSE,  0.0, 0.5, 0.5,
	SPECULAR,  0.0, 0.0, 0.9,
	SHININESS, 10.0,
	LMNULL
};

static float mat_blueshiny[] = {
	EMISSION, 0.0, 0.0, 0.6,
	AMBIENT,  0.1, 0.25, 0.5,
	DIFFUSE,  0.5, 0.5, 0.5,
	SPECULAR,  0.5, 0.0, 0.0,
	SHININESS, 10.0,
	LMNULL
};

static float mat_redflat[] = {
	EMISSION, 0.60, 0.0, 0.0,
	AMBIENT,  0.1, 0.25, 0.1,
	DIFFUSE,  0.5, 0.5, 0.5,
	SPECULAR,  0.5, 0.0, 0.0,
	SHININESS, 1.0,
	LMNULL
};

static float mat_redshiny[] = {
	EMISSION, 0.60, 0.0, 0.0,
	AMBIENT,  0.1, 0.25, 0.1,
	DIFFUSE,  0.5, 0.5, 0.5,
	SPECULAR,  0.5, 0.0, 0.0,
	SHININESS, 10.0,
	LMNULL
};

static float mat_beigeshiny[] = {
	EMISSION, 0.5, 0.5, 0.6,
	AMBIENT,  0.35, 0.35, 0.0,
	DIFFUSE,  0.5, 0.5, 0.0,
	SPECULAR,  0.5, 0.5, 0.0,
	SHININESS, 10.0,
	LMNULL
};

/*
 *  Meanings of the parameters:
 *	AMBIENT		ambient light associated with this source ???, 0..1
 *	LCOLOR		light color, 0..1
 *	POSITION	position of light.  w=0 for infinite lights
 */
static float default_light[] = {
	AMBIENT,	0.0, 0.0, 0.0, 
	LCOLOR,		1.0, 1.0, 1.0, 
	POSITION,	0.0, 0.0, 1.0, 0.0,
	LMNULL};


#if 1
# if 0
static float white_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.70, 0.70, 0.70, 
	POSITION, 100.0, -200.0, 100.0, 0.0, 
	LMNULL};


static float red_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.6, 0.1, 0.1, 
	POSITION, -100.0, -30.0, 100.0, 0.0, 
	LMNULL};

static float green_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.3, 0.1, 
	POSITION, 100.0, -20.0, 20.0, 0.0, 
	LMNULL};


static float blue_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.1, 0.3, 
	POSITION, 0.0, 100.0, -100.0, 0.0, 
	LMNULL};

static float white_local_light[] = {
	AMBIENT, 0.0, 1.0, 0.0, 
	LCOLOR,   0.75, 0.75, 0.75, 
	POSITION, 0.0, 10.0, 10.0, 5.0, 
	LMNULL};
# else
static float white_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.70, 0.70, 0.70, 
	POSITION, 100.0, 200.0, 100.0, 0.0, 
	LMNULL};


static float red_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.6, 0.1, 0.1, 
	POSITION, 100.0, 30.0, 100.0, 0.0, 
	LMNULL};

static float green_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.3, 0.1, 
	POSITION, -100.0, 20.0, 20.0, 0.0, 
	LMNULL};


static float blue_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.1, 0.3, 
	POSITION, 0.0, -100.0, -100.0, 0.0, 
	LMNULL};

static float white_local_light[] = {
	AMBIENT, 0.0, 1.0, 0.0, 
	LCOLOR,   0.75, 0.75, 0.75, 
	POSITION, 0.0, 10.0, 10.0, 5.0, 
	LMNULL};
# endif

#else
static float white_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.70, 0.70, 0.70, 
	POSITION, 10.0, 50.0, 50.0, 0.0, 
	LMNULL};


static float red_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.5, 0.1, 0.1, 
	POSITION, -100.0, 0.0, 0.0, 0.0, 
	LMNULL};

static float green_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.5, 0.1, 
	POSITION, 100.0, 50.0, 0.0, 0.0, 
	LMNULL};

static float blue_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.1, 0.5, 
	POSITION, 0.0, -50.0, 0.0, 0.0, 
	LMNULL};

static float orange_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,	0.35, 0.175, 0.0, 
	POSITION, -50.0, 50.0, 10.0, 0.0, 
	LMNULL};

static float white_local_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.75, 0.75, 0.75, 
	POSITION, 0.0, 10.0, 10.0, 5.0, 
	LMNULL};


#endif




/*
 *  Lighting model parameters
 *	AMBIENT		amount of ambient light present in the scene, 0..1
 *	ATTENUATION	fixed and variable attenuation factor, 0..1
 *	LOCALVIEWER	1=eye at (0,0,0), 0=eye at (0,0,+inf)
 */
static float	default_lmodel[] = {
	AMBIENT,	0.2,  0.2,  0.2,
	ATTENUATION,	1.0, 0.0, 
	LOCALVIEWER,	0.0, 
	LMNULL};

static float infinite[] = {
	AMBIENT, 0.3,  0.3, 0.3, 
	LOCALVIEWER, 0.0, 
	LMNULL};

static float local[] = {
	AMBIENT, 0.3,  0.3, 0.3, 
	LOCALVIEWER, 1.0, 
	ATTENUATION, 1.0, 0.0, 
	LMNULL};

static void
glx_make_materials()
{
	/* define material properties */
	lmdef (DEFMATERIAL, 1, 0, material_default);

	lmdef (DEFMATERIAL, 2, 0, mat_brass);
	lmdef (DEFMATERIAL, 3, 0, mat_shinybrass);
	lmdef (DEFMATERIAL, 4, 0, mat_pewter);
	lmdef (DEFMATERIAL, 5, 0, mat_silver);
	lmdef (DEFMATERIAL, 6, 0, mat_gold);
	lmdef (DEFMATERIAL, 7, 0, mat_shinygold);
	lmdef (DEFMATERIAL, 8, 0, mat_plaster);
	lmdef (DEFMATERIAL, 9, 0, mat_redplastic);
	lmdef (DEFMATERIAL, 10, 0, mat_greenplastic);
	lmdef (DEFMATERIAL, 11, 0, mat_blueplastic);

	lmdef (DEFMATERIAL, 12, 0, mat_greenflat);
	lmdef (DEFMATERIAL, 13, 0, mat_greenshiny);

	lmdef (DEFMATERIAL, 14, 0, mat_blueflat);
	lmdef (DEFMATERIAL, 15, 0, mat_blueshiny);

	lmdef (DEFMATERIAL, 16, 0, mat_redflat);
	lmdef (DEFMATERIAL, 17, 0, mat_redshiny);

	lmdef (DEFMATERIAL, 18, 0, mat_beigeshiny);

	lmdef( DEFMATERIAL, 19, 0, material_xdefault );
	lmdef( DEFMATERIAL, 20, 0, material_rtdefault );

	/*    lmdef (DEFLIGHT, 1, 0, default_light); */
	lmdef (DEFLIGHT, 4, 0, green_inf_light);
	lmdef (DEFLIGHT, 2, 0, white_inf_light);
	lmdef (DEFLIGHT, 3, 0, red_inf_light);
	lmdef (DEFLIGHT, 4, 0, green_inf_light);
	lmdef (DEFLIGHT, 5, 0, blue_inf_light);
	/*    lmdef (DEFLIGHT, 6, 0, orange_inf_light); */
	lmdef (DEFLIGHT, 7, 0, white_local_light);

	lmdef (DEFLMODEL, 1, 0, default_lmodel);
	lmdef (DEFLMODEL, 2, 0, infinite);
	lmdef (DEFLMODEL, 3, 0, local);
}

/*
 *  Check to see if setmonitor(STR_RECT) will work.
 *  Returns -
 *	> 0	If stereo is available
 *	0	If not
 */
static int
glx_has_stereo()
{
#if !defined(__sgi) && !defined(__mips)
	/* IRIX 3 systems, test to see if DER1_STEREO bit is
	 * read/write (no hardware underneath), or
	 * read only (hardware underneath, which can't be read back.
	 */
	int	rw_orig, rw1, rw2;

	rw_orig = getvideo(DE_R1);
	rw1 = rw_orig ^ DER1_STEREO;	/* Toggle the bit */
	setvideo(DE_R1, rw1);
	rw2 = getvideo(DE_R1);
	if( rw1 != rw2 )  {
		setvideo(DE_R1, rw_orig);/* Restore original state */
		return 1;		/* Has stereo */
	}
	rw1 = rw1 ^ DER1_STEREO;	/* Toggle the bit, again */
	setvideo(DE_R1, rw1);
	rw2 = getvideo(DE_R1);
	if( rw1 != rw2 )  {
		setvideo(DE_R1, rw_orig);/* Restore original state */
		return 1;		/* Has stereo */
	}
	setvideo(DE_R1, rw_orig);	/* Restore original state */
	return 0;			/* Does not have stereo */
#else
	/* IRIX 4 systems */
	return getgdesc(GD_STEREO);
#endif
}

static unsigned long
extract_value(buffer, mode, conf)
int buffer;
int mode;
GLXconfig *conf;
{
  int i;

  for (i = 0; conf[i].buffer; i++)
    if (conf[i].buffer == buffer && conf[i].mode == mode)
      return conf[i].arg;

  return 0;
}

/* Extract X visual information */
static XVisualInfo*
extract_visual(dmp, buffer, conf)
struct dm *dmp;
int buffer;
GLXconfig *conf;
{
  XVisualInfo template, *v;
  int n;

  template.screen = Tk_ScreenNumber(((struct glx_vars *)dmp->dm_vars)->xtkwin);
  template.visualid = extract_value(buffer, GLX_VISUAL, conf);

  return XGetVisualInfo(((struct glx_vars *)dmp->dm_vars)->dpy,
			VisualScreenMask|VisualIDMask, &template, &n);
}

/* 
 * Fill the configuration structure with the appropriately
 * created window
 */
static void
set_window(buffer, _win, conf)
int buffer;
Window _win;
GLXconfig *conf;
{
  int i;

  for (i = 0; conf[i].buffer; i++)
    if (conf[i].buffer == buffer && conf[i].mode == GLX_WINDOW)
      conf[i].arg = _win;
}

/*
 *                  G L X _ B E G I N D L I S T
 *
 */
int
glx_beginDList(dmp, list)
struct dm *dmp;
unsigned int list;
{
  if (((struct glx_vars *)dmp->dm_vars)->mvars.debug)
    Tcl_AppendResult(interp, "glx_beginDList()\n", (char *)NULL);

  GLXwinset(((struct glx_vars *)dmp->dm_vars)->dpy,
	    ((struct glx_vars *)dmp->dm_vars)->win);
  makeobj((Object)list);

  return TCL_OK;
}

/*
 *                  G L X _ E N D D L I S T
 *
 */
int
glx_endDList(dmp)
struct dm *dmp;
{
  if (((struct glx_vars *)dmp->dm_vars)->mvars.debug)
    Tcl_AppendResult(interp, "glx_endDList()\n", (char *)NULL);

  closeobj();
  return TCL_OK;
}

/*
 *                  G L X _ D R A W D L I S T
 *
 */
int
glx_drawDList(dmp, list)
struct dm *dmp;
unsigned int list;
{
  if (((struct glx_vars *)dmp->dm_vars)->mvars.debug)
    Tcl_AppendResult(interp, "glx_drawDList()\n", (char *)NULL);

  callobj((Object)list);
  return TCL_OK;
}

/*
 *                  G L X _ F R E E D L I S T
 *
 */
int
glx_freeDLists(dmp, list, range)
struct dm *dmp;
unsigned int list;
int range;
{
  int i;

  if (((struct glx_vars *)dmp->dm_vars)->mvars.debug)
    Tcl_AppendResult(interp, "glx_freeDLists()\n", (char *)NULL);

  for(i = 0; i < range; ++i)
    delobj((Object)(list + i));

  return TCL_OK;
}
@


1.28
log
@change conf.h to a wrapped config.h
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/libdm/dm-glx.c,v 1.27 2004/02/02 17:39:08 morrison Exp $ (BRL)";
@


1.27
log
@update copyright to include span through 2003
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-glx.c,v 1.26 2001/03/31 01:56:52 morrison Exp $ (BRL)";
d46 5
a50 1
#include "conf.h"
@


1.26
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d39 1
a39 1
 *	This software is Copyright (C) 1988 by the United States Army.
d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-glx.c,v 1.25 1998/01/05 20:29:08 bparker Exp $ (BRL)";
@


1.26.4.1
log
@sync branch with HEAD
@
text
@d39 1
a39 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d43 1
a43 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
@


1.26.6.1
log
@sync to HEAD...
@
text
@d39 1
a39 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libdm/dm-glx.c,v 1.27 2004/02/02 17:39:08 morrison Exp $ (BRL)";
@


1.26.12.1
log
@merge from HEAD
@
text
@d39 1
a39 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-glx.c,v 1.27 2004/02/02 17:39:08 morrison Exp $ (BRL)";
@


1.26.12.2
log
@merge from head
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libdm/dm-glx.c,v 1.26.12.1 2004/02/12 19:45:18 erikg Exp $ (BRL)";
@


1.25
log
@save XVisualInfo *
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-glx.c,v 1.24 1997/11/21 21:01:07 bparker Exp bparker $ (BRL)";
d769 1
a769 1
    bn_mat_idn( nozclip );
@


1.24
log
@*- query for SGI-GLX extension
*- name changes and cleanup
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-glx.c,v 1.23 1997/11/03 20:07:53 bparker Exp bparker $ (BRL)";
d366 2
a367 3
  visual_info = extract_visual(dmp, GLX_NORMAL, glx_config);
  ((struct glx_vars *)dmp->dm_vars)->vis = visual_info->visual;
  ((struct glx_vars *)dmp->dm_vars)->depth = visual_info->depth;
d371 1
a371 1
			((struct glx_vars *)dmp->dm_vars)->vis,
@


1.23
log
@*- change glx_drawVertex2D to glx_drawPoint2D
*- change glx_newrot to glx_loadMatrix
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-glx.c,v 1.22 1997/10/10 21:10:40 bparker Exp bparker $ (BRL)";
d89 4
a92 6
void    glx_configure_window_shape();
void    glx_establish_perspective();
void    glx_set_perspective();
void	glx_establish_lighting();
void	glx_establish_zbuffer();
void glx_clear_to_black();
a127 2
static int perspective_table[] = { 
	30, 45, 60, 90 };
d170 1
a170 1
 *			I R _ O P E N
a171 5
 *  Fire up the display manager, and the display processor. Note that
 *  this brain-damaged version of the MEX display manager gets terribly
 *  confused if you try to close your last window.  Tough. We go ahead
 *  and close the window.  Ignore the "ERR_CLOSEDLASTWINDOW" error
 *  message. It doesn't hurt anything.  Silly MEX.
a182 1
  struct bu_vls top_vls;
d200 1
a200 1
  *dmp = dm_glx;
a208 2
  dmp->dm_vars = (genptr_t)bu_calloc(1, sizeof(struct glx_vars),
				     "glx_open: struct glx_vars");
d219 1
a219 1
  i = dm_process_options(dmp, &init_proc_vls, --argc, ++argv);
d234 1
a241 1
  ((struct glx_vars *)dmp->dm_vars)->perspective_angle = 3;
a245 1
  ((struct glx_vars *)dmp->dm_vars)->mvars.dummy_perspective = 1;
d258 1
a264 1
  bu_vls_init(&top_vls);
a270 1
    bu_vls_printf(&top_vls, "%S", &dmp->dm_pathName);
a276 1
      bu_vls_strcpy(&top_vls, ".");
d278 3
d285 1
a287 2
    bu_vls_free(&top_vls);

d298 1
d303 11
d323 1
d326 1
a358 1

d470 1
a470 1
    glx_clear_to_black(dmp);
d472 1
a472 1
    glx_clear_to_black(dmp);
d475 1
a475 1
  glx_configure_window_shape(dmp);
d542 1
a542 1
 *			I R _ C O N F I G U R E _ W I N D O W _ S H A P E
d549 1
a549 1
glx_configure_window_shape(dmp)
d555 3
d568 1
a568 1
    glx_establish_zbuffer(dmp);
d570 2
a571 2
  glx_establish_lighting(dmp);
  glx_clear_to_black(dmp);
d580 1
a580 1
 *  			I R _ C L O S E
d590 18
a607 21
    if(((struct glx_vars *)dmp->dm_vars)->xtkwin != NULL){
      if(((struct glx_vars *)dmp->dm_vars)->mvars.cueing_on)
	depthcue(0);

      lampoff( 0xf );

      /* avoids error messages when reattaching */
      mmode(MVIEWING);	
      lmbind(LIGHT2,0);
      lmbind(LIGHT3,0);
      lmbind(LIGHT4,0);
      lmbind(LIGHT5,0);

      frontbuffer(1);
      glx_clear_to_black(dmp);
      frontbuffer(0);

      GLXunlink(((struct glx_vars *)dmp->dm_vars)->dpy,
		((struct glx_vars *)dmp->dm_vars)->win);
      Tk_DestroyWindow(((struct glx_vars *)dmp->dm_vars)->xtkwin);
    }
d610 3
d636 1
a636 1
    Tcl_AppendResult(interp, "glx_drawBegin\n", (char *)NULL);
d647 1
a647 1
    glx_clear_to_black(dmp);
d662 1
a662 1
    Tcl_AppendResult(interp, "glx_drawEnd\n", (char *)NULL);
d674 1
a674 1
    glx_clear_to_black(dmp);
d681 1
a681 1
 *			I R _ N O R M A L
d691 1
a691 1
    Tcl_AppendResult(interp, "glx_normal\n", (char *)NULL);
d822 1
a822 1
 *  			I R _ O B J E C T
d911 1
a911 1
 *			I R _ P U T S
d938 1
a938 1
 *			I R _ 2 D _ L I N E
d958 4
d967 3
d973 4
d983 3
d1036 4
a1039 1

d1046 3
d1062 4
d1076 4
d1085 3
a1090 20

void
glx_establish_perspective(dmp)
struct dm *dmp;
{
  struct bu_vls vls;

  bu_vls_init(&vls);
  bu_vls_printf( &vls, "set perspective %d\n",
		((struct glx_vars *)dmp->dm_vars)->mvars.perspective_mode ?
		perspective_table[((struct glx_vars *)dmp->dm_vars)->perspective_angle] :
		-1 );

  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
#if 0
  dmaflag = 1;
#endif
}

d1092 3
a1094 4
   This routine will toggle the perspective_angle if the
   dummy_perspective value is 0 or less. Otherwise, the
   perspective_angle is set to the value of (dummy_perspective - 1).
*/
d1096 1
a1096 1
glx_set_perspective(dmp)
d1099 2
a1100 14
  /* set perspective matrix */
  if(((struct glx_vars *)dmp->dm_vars)->mvars.dummy_perspective > 0)
    ((struct glx_vars *)dmp->dm_vars)->perspective_angle =
      ((struct glx_vars *)dmp->dm_vars)->mvars.dummy_perspective <= 4 ?
      ((struct glx_vars *)dmp->dm_vars)->mvars.dummy_perspective - 1: 3;
  else if (--((struct glx_vars *)dmp->dm_vars)->perspective_angle < 0) /* toggle perspective matrix */
    ((struct glx_vars *)dmp->dm_vars)->perspective_angle = 3;

  if(((struct glx_vars *)dmp->dm_vars)->mvars.perspective_mode){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf( &vls, "set perspective %d\n",
		  perspective_table[((struct glx_vars *)dmp->dm_vars)->perspective_angle] );
d1102 4
a1105 2
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
d1108 1
a1108 5
  /*
     Just in case the "!" is used with the set command. This
     allows us to toggle through more than two values.
   */
  ((struct glx_vars *)dmp->dm_vars)->mvars.dummy_perspective = 1;
d1110 5
a1114 3
#if 0
  dmaflag = 1;
#endif
d1118 1
a1118 1
glx_establish_zbuffer(dmp)
d1121 2
a1122 15
	if( ((struct glx_vars *)dmp->dm_vars)->mvars.zbuf == 0 )  {
	  Tcl_AppendResult(interp, "dm-4d: This machine has no Zbuffer to enable\n",
			   (char *)NULL);
	  ((struct glx_vars *)dmp->dm_vars)->mvars.zbuffer_on = 0;
	}
	zbuffer( ((struct glx_vars *)dmp->dm_vars)->mvars.zbuffer_on );
	if( ((struct glx_vars *)dmp->dm_vars)->mvars.zbuffer_on)  {
	  /* Set screen coords of near and far clipping planes */
	  lsetdepth(((struct glx_vars *)dmp->dm_vars)->mvars.min_scr_z,
		    ((struct glx_vars *)dmp->dm_vars)->mvars.max_scr_z);
	}
#if 0
	dmaflag = 1;
#endif
}
a1123 4
void
glx_clear_to_black(dmp)
struct dm *dmp;
{
d1159 2
d1165 1
a1165 1
glx_establish_lighting(dmp)
d1168 3
a1203 4

#if 0
  dmaflag = 1;
#endif
d1659 4
d1668 3
d1678 4
d1686 3
d1693 4
d1702 3
d1709 4
d1720 3
@


1.22
log
@some cleanup
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-glx.c,v 1.21 1997/10/10 13:00:41 bparker Exp bparker $ (BRL)";
d110 1
a110 1
static int	glx_normal(), glx_newrot();
d112 1
a112 1
static int      glx_drawVertex2D();
d140 1
a140 1
  glx_newrot,
d143 1
a143 1
  glx_drawVertex2D,
d338 1
a338 1
		   DefaultScreen(((struct glx_vars *)dmp->dm_vars)->dpy)) - 20;
d345 1
a345 1
		    DefaultScreen(((struct glx_vars *)dmp->dm_vars)->dpy)) - 20;
d623 1
a623 1
 *			G L X _ P R O L O G
d626 1
a626 3
 * important things.  Most important of all is the object "faceplate",
 * which is built between dm_normal() and dm_epilog()
 * by dm_puts and dm_2d_line calls from adcursor() and dotitles().
a631 3
  GLXwinset(((struct glx_vars *)dmp->dm_vars)->dpy,
	    ((struct glx_vars *)dmp->dm_vars)->win);

d635 6
d650 1
a650 1
 *			I R _ N O R M A L
d652 1
a652 22
 * Restore the display processor to a normal mode of operation
 * (ie, not scaled, rotated, displaced, etc).
 * Turns off windowing.
 */
static int
glx_normal(dmp)
struct dm *dmp;
{
  if (((struct glx_vars *)dmp->dm_vars)->mvars.debug)
    Tcl_AppendResult(interp, "glx_normal\n", (char *)NULL);

#if 0
  RGBcolor( (short)0, (short)0, (short)0 );
#endif

  ortho( -xlim_view, xlim_view, -ylim_view, ylim_view, -1.0, 1.0 );

  return TCL_OK;
}

/*
 *			I R _ E P I L O G
d678 19
a696 1
 *  			I R _ N E W R O T
d698 1
a698 1
 *  Load a new rotation matrix.  This will be followed by
d722 1
a722 1
glx_newrot(dmp, mat, which_eye)
d732 16
a747 2
  if (((struct glx_vars *)dmp->dm_vars)->mvars.debug)
    Tcl_AppendResult(interp, "glx_newrot()\n", (char *)NULL);
a820 4
 *  Set up for an object, transformed as indicated, and with an
 *  object center as specified.  The ratio of object to screen size
 *  is passed in as a convienience.  Mat is model2view.
 *
d956 1
a956 1
glx_drawVertex2D(dmp, x, y)
d1042 1
d1052 1
a1052 1
int w[];
@


1.21
log
@*- got rid of eventHandler
*- initialize dm_id (new member of "struct dm")
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-glx.c,v 1.20 1997/09/23 21:16:40 bparker Exp bparker $ (BRL)";
a257 1
  ((struct glx_vars *)dmp->dm_vars)->mvars.linewidth = 1;      /* Line drawing width */
a643 4

#if 0
  linewidth(((struct glx_vars *)dmp->dm_vars)->mvars.linewidth);
#endif
@


1.20
log
@add display list support
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-glx.c,v 1.19 1997/08/01 21:25:41 bparker Exp bparker $ (BRL)";
a148 1
  Nu_int0,
d153 1
d183 1
a183 2
glx_open(eventHandler, argc, argv)
int (*eventHandler)();
a210 1
  dmp->dm_eventHandler = eventHandler;
a260 7
#if 0
  if(BU_LIST_IS_EMPTY(&head_glx_vars.l))
#else
  if(dmp->dm_eventHandler != DM_EVENT_HANDLER_NULL)
#endif
    Tk_CreateGenericHandler(dmp->dm_eventHandler, (ClientData)DM_TYPE_GLX);

d383 1
a608 3

    if(BU_LIST_IS_EMPTY(&head_glx_vars.l))
      Tk_DeleteGenericHandler(dmp->dm_eventHandler, (ClientData)DM_TYPE_GLX);
@


1.19
log
@rm glx_irisX2ged() and glx_irisY2ged()
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-glx.c,v 1.18 1997/05/21 13:04:09 bparker Exp bparker $ (BRL)";
a114 1
static unsigned glx_cvtvecs(), glx_load();
d116 3
a146 2
  glx_cvtvecs,
  glx_load,
d150 6
a155 1
  0,			/* no "displaylist", per. se. */
a169 1
  0,
d831 1
a831 1
glx_drawVList( dmp, vp, m )
a833 1
fastf_t *m;
a1046 25

/*
 *			I R _ C V T V E C S
 *
 */
static unsigned
glx_cvtvecs( dmp, sp )
struct dm *dmp;
register struct solid *sp;
{
  return( 0 );	/* No "displaylist" consumed */
}

/*
 * Loads displaylist from storage[]
 */
static unsigned
glx_load( dmp, addr, count )
struct dm *dmp;
unsigned addr, count;
{
  return( 0 );		/* FLAG:  error */
}


d1679 43
@


1.18
log
@mods to glx_setLineAttr
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-glx.c,v 1.17 1997/05/08 14:17:19 bparker Exp bparker $ (BRL)";
a94 2
int glx_irisX2ged();
int glx_irisY2ged();
a167 26

/*
 *  Mouse coordinates are in absolute screen space, not relative to
 *  the window they came from.  Convert to window-relative,
 *  then to MGED-style +/-2048 range.
 */
int
glx_irisX2ged(dmp, x, use_aspect)
struct dm *dmp;
register int x;
int use_aspect;
{
  if(use_aspect)
    return ((x / (double)dmp->dm_width - 0.5) /
	    dmp->dm_aspect * 4095);
  else
    return ((x / (double)dmp->dm_width - 0.5) * 4095);
}

int
glx_irisY2ged(dmp, y)
struct dm *dmp;
register int y;
{
  return ((0.5 - y/(double)dmp->dm_height) * 4095);
}
@


1.17
log
@*- changed Glx_ prefix to glx_
*- mods to reflect change in "struct dm" --- added dm_type
                                         removed dm_open, dm_initWinProc
*- modify the handling of graphics buffers
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-glx.c,v 1.16 1997/04/24 18:14:07 bparker Exp bparker $ (BRL)";
d160 2
d1054 1
a1054 1
glx_setLineAttr(dmp, width, dashed)
d1057 1
a1057 1
int dashed;
d1059 3
a1061 1
  ((struct glx_vars *)dmp->dm_vars)->mvars.linewidth = width;
d1064 2
a1065 2
  if(dashed)
    setlinestyle(1);    /* into dot-dash */
@


1.16
log
@some cleanup
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-glx.c,v 1.15 1997/04/23 18:37:50 bparker Exp bparker $ (BRL)";
d89 8
a96 7
void    Glx_configure_window_shape();
void    Glx_establish_perspective();
void    Glx_set_perspective();
void	Glx_establish_lighting();
void	Glx_establish_zbuffer();
int Glx_irisX2ged();
int Glx_irisY2ged();
d106 2
a107 14
static void Glx_var_init();
static void Glx_make_materials();
static void Glx_clear_to_black();

struct dm	*Glx_open();
static int	Glx_close();
static int	Glx_drawBegin(), Glx_drawEnd();
static int	Glx_normal(), Glx_newrot();
static int	Glx_drawString2D(), Glx_drawLine2D();
static int      Glx_drawVertex2D();
static int	Glx_drawVList();
static int      Glx_setColor(), Glx_setLineAttr();
static unsigned Glx_cvtvecs(), Glx_load();
static int	Glx_setWinBounds(), Glx_debug();
d109 11
d136 15
a150 16
  Glx_open,
  Glx_close,
  Glx_drawBegin,
  Glx_drawEnd,
  Glx_normal,
  Glx_newrot,
  Glx_drawString2D,
  Glx_drawLine2D,
  Glx_drawVertex2D,
  Glx_drawVList,
  Glx_setColor,
  Glx_setLineAttr,
  Glx_cvtvecs,
  Glx_load,
  Glx_setWinBounds,
  Glx_debug,
d154 3
a156 1
  "glx", "SGI - mixed mode", 
a165 1
  0,
d175 1
a175 1
Glx_irisX2ged(dmp, x, use_aspect)
d188 1
a188 1
Glx_irisY2ged(dmp, y)
d205 1
a205 1
Glx_open(eventHandler, argc, argv)
d216 1
d244 1
a244 1
				     "Glx_init: struct glx_vars");
d246 1
a246 1
    bu_free(dmp, "Glx_open: dmp");
d253 1
a253 1
  bu_vls_init(&dmp->dm_initWinProc);
d255 1
a255 5
  i = dm_process_options(dmp,
			 &dmp->dm_width,
			 &dmp->dm_height,
			 argc,
			 argv);
d270 2
a271 2
  if(bu_vls_strlen(&dmp->dm_initWinProc) == 0)
    bu_vls_strcpy(&dmp->dm_initWinProc, "bind_dm");
d303 1
a303 1
    (void)Glx_close(dmp);
d343 1
a343 1
    (void)Glx_close(dmp);
a349 1
#if 1
d352 1
a352 1
		&dmp->dm_initWinProc,
d357 1
a357 1
    (void)Glx_close(dmp);
d361 1
a379 19
#else
  bu_vls_init(&str);
  bu_vls_printf(&str, "_init_dm %s %s\n",
		bu_vls_addr(&dmp->dm_initWinProc),
		bu_vls_addr(&dmp->dm_pathName));

  if(Tcl_Eval(interp, bu_vls_addr(&str)) == TCL_ERROR){
        bu_vls_free(&str);
	return TCL_ERROR;
  }

  bu_vls_free(&str);

  ((struct glx_vars *)dmp->dm_vars)->dpy =
    Tk_Display(((struct glx_vars *)dmp->dm_vars)->xtkwin);

#if 0
  XSynchronize(((struct glx_vars *)dmp->dm_vars)->dpy, True);
#endif
a380 8
  dmp->dm_width =
    DisplayWidth(((struct glx_vars *)dmp->dm_vars)->dpy,
		 DefaultScreen(((struct glx_vars *)dmp->dm_vars)->dpy)) - 20;
  dmp->dm_height =
    DisplayHeight(((struct glx_vars *)dmp->dm_vars)->dpy,
		  DefaultScreen(((struct glx_vars *)dmp->dm_vars)->dpy)) - 20;

#endif
d407 1
a407 1
    (void)Glx_close(dmp);
d418 1
a418 1
    (void)Glx_close(dmp);
d498 9
a506 1
  Glx_configure_window_shape(dmp);
d528 1
a528 1
	  Tcl_AppendResult(interp, "Glx_open: Couldn't open the dials+buttons\n",
d580 1
a580 1
Glx_configure_window_shape(dmp)
d596 1
a596 1
    Glx_establish_zbuffer(dmp);
d598 2
a599 10
  Glx_establish_lighting(dmp);
	
  if( ((struct glx_vars *)dmp->dm_vars)->mvars.doublebuffer){
    /* Clear out image from windows underneath */
    frontbuffer(1);
    Glx_clear_to_black(dmp);
    frontbuffer(0);
    Glx_clear_to_black(dmp);
  } else
    Glx_clear_to_black(dmp);
d614 1
a614 1
Glx_close(dmp)
d632 1
a632 1
      Glx_clear_to_black(dmp);
d650 2
a651 3
  bu_vls_free(&dmp->dm_initWinProc);
  bu_free(dmp->dm_vars, "Glx_close: glx_vars");
  bu_free(dmp, "Glx_close: dmp");
d665 1
a665 1
Glx_drawBegin(dmp)
d672 1
a672 1
    Tcl_AppendResult(interp, "Glx_drawBegin\n", (char *)NULL);
d677 1
a677 1
    Glx_clear_to_black(dmp);
d694 1
a694 1
Glx_normal(dmp)
d698 1
a698 1
    Tcl_AppendResult(interp, "Glx_normal\n", (char *)NULL);
d713 1
a713 1
Glx_drawEnd(dmp)
d717 1
a717 1
    Tcl_AppendResult(interp, "Glx_drawEnd\n", (char *)NULL);
d723 1
a723 1
  Glx_drawLine2D( dmp, 0, 0, 0, 0, 0 );
d729 1
a729 1
    Glx_clear_to_black(dmp);
d739 1
a739 1
 *  many calls to Glx_drawVList().
d762 1
a762 1
Glx_newrot(dmp, mat, which_eye)
d773 1
a773 1
    Tcl_AppendResult(interp, "Glx_newrot()\n", (char *)NULL);
d782 1
a782 1
    Glx_drawString2D( dmp, "R", 2020, 0, 0, DM_RED );
d853 1
a853 1
Glx_drawVList( dmp, vp, m )
d866 1
a866 1
    Tcl_AppendResult(interp, "Glx_drawVList()\n", (char *)NULL);
d945 1
a945 1
Glx_drawString2D( dmp, str, x, y, size, use_aspect )
d953 1
a953 1
    Tcl_AppendResult(interp, "Glx_drawString2D()\n", (char *)NULL);
d970 1
a970 1
Glx_drawLine2D( dmp, x1, y1, x2, y2 )
d978 1
a978 1
    Tcl_AppendResult(interp, "Glx_drawLine2D()\n", (char *)NULL);
d987 1
a987 1
Glx_drawVertex2D(dmp, x, y)
d991 1
a991 1
  return Glx_drawLine2D(dmp, x, y, x, y);
d995 1
a995 1
Glx_setColor(dmp, r, g, b, strict)
d1052 1
a1052 1
Glx_setLineAttr(dmp, width, dashed)
d1074 1
a1074 1
Glx_cvtvecs( dmp, sp )
d1085 1
a1085 1
Glx_load( dmp, addr, count )
d1094 1
a1094 1
Glx_debug(dmp, lvl)
d1103 1
a1103 1
Glx_setWinBounds(dmp, w)
d1112 1
a1112 1
Glx_establish_perspective(dmp)
d1136 1
a1136 1
Glx_set_perspective(dmp)
d1170 1
a1170 1
Glx_establish_zbuffer(dmp)
d1189 2
a1190 2
static void
Glx_clear_to_black(dmp)
d1232 1
a1232 1
Glx_establish_lighting(dmp)
d1247 1
a1247 1
      Glx_colorchange(dmp);
d1255 1
a1255 1
    Glx_make_materials();	/* Define material properties */
d1595 1
a1595 1
Glx_make_materials()
d1646 1
a1646 1
Glx_has_stereo()
@


1.15
log
@added some error checking; modified use of BU_GETSTRUCT
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-glx.c,v 1.14 1997/04/22 15:05:13 bparker Exp bparker $ (BRL)";
d122 1
d125 1
d242 3
a244 1
  if(dmp->dm_vars == (struct glx_vars *)NULL){
d433 7
a439 4
  Tk_SetWindowVisual(((struct glx_vars *)dmp->dm_vars)->xtkwin,
		     ((struct glx_vars *)dmp->dm_vars)->vis,
		     ((struct glx_vars *)dmp->dm_vars)->depth,
		     ((struct glx_vars *)dmp->dm_vars)->cmap);
@


1.14
log
@*** empty log message ***
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-glx.c,v 1.13 1997/03/03 19:59:39 bparker Exp bparker $ (BRL)";
d226 4
a229 1
  dmp = BU_GETSTRUCT(dmp, dm);
d239 2
a240 2
  dmp->dm_vars = bu_calloc(1, sizeof(struct glx_vars), "Glx_init: struct glx_vars");
  if(!dmp->dm_vars){
@


1.13
log
@remove call to Glx_load_startup
call _init_dm with 2 parameters
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-glx.c,v 1.12 1997/03/03 18:32:11 bparker Exp bparker $ (BRL)";
a202 1
#if DO_NEW_LIBDM_OPEN
a204 4
#else
Glx_open(dmp, argc, argv)
struct dm *dmp;
#endif
a223 1
#if DO_NEW_LIBDM_OPEN
a228 1
#endif
@


1.12
log
@mods to have display manager to allocate its own memory
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-glx.c,v 1.11 1997/01/24 21:06:44 bparker Exp bparker $ (BRL)";
a104 1
static int Glx_load_startup();
d238 4
a241 2
  if(!count)
    (void)Glx_load_startup(dmp);
d334 2
d355 1
a355 1
  bu_vls_printf(&str, "_new_init_dm %S %S %S\n",
a356 1
		&top_vls,
a365 1
  bu_vls_free(&top_vls);
a589 15
/*XXX Just experimenting */
static int
Glx_load_startup(dmp)
struct dm *dmp;
{
  char *filename;

  bzero((void *)&head_glx_vars, sizeof(struct glx_vars));
  BU_LIST_INIT( &head_glx_vars.l );

  if((filename = getenv("DM_GLX_RCFILE")) != (char *)NULL )
    return Tcl_EvalFile(interp, filename);

  return TCL_OK;
}
@


1.11
log
@calling _init_dm instead of init_dm_win
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-glx.c,v 1.10 1997/01/02 20:05:30 bparker Exp bparker $ (BRL)";
d60 5
d110 1
a110 1
static int	Glx_open();
d154 5
a158 2
  "glx", "SGI - mixed mode",
  0,			/* mem map */
d163 2
d174 1
a174 1
Glx_irisX2ged(dmp, x)
d177 1
d179 5
a183 1
  return ((x/(double)((struct glx_vars *)dmp->dm_vars)->width - 0.5) * 4095);
d191 1
a191 1
  return ((0.5 - y/(double)((struct glx_vars *)dmp->dm_vars)->height) * 4095);
d203 5
a207 1
static int
d210 1
d219 1
d223 1
d230 7
d242 17
a258 3
  bu_vls_init_if_uninit(&dmp->dm_pathName);
  bu_vls_init_if_uninit(&dmp->dm_initWinProc);
  i = dm_process_options(dmp, argc, argv);
d260 12
a271 1
     bu_vls_printf(&dmp->dm_pathName, ".dm_glx%d", count++);
d273 1
a273 1
    bu_vls_strcpy(&dmp->dm_initWinProc, "bind_dm_win");
d275 1
a275 1
  dmp->dm_vars = bu_calloc(1, sizeof(struct glx_vars), "Glx_init: struct glx_vars");
d281 1
a281 1
  /* initialize the modifiable variables */
d287 1
d289 3
d305 2
a306 1
    return TCL_ERROR;
d311 64
a374 2
  if(!dmp->dm_vars)
    return TCL_ERROR;
d376 7
a382 6
  ((struct glx_vars *)dmp->dm_vars)->xtkwin =
    Tk_CreateWindowFromPath(interp, tkwin, bu_vls_addr(&dmp->dm_pathName), dmp->dm_dname);
  /*
   * Create the X drawing window by calling init_glx which
   * is defined in glxinit.tcl
   */
d402 1
a402 1
  ((struct glx_vars *)dmp->dm_vars)->width =
d405 1
a405 1
  ((struct glx_vars *)dmp->dm_vars)->height =
d409 10
a418 5
  /* Make window square */
  if( ((struct glx_vars *)dmp->dm_vars)->height < ((struct glx_vars *)dmp->dm_vars)->width )
    ((struct glx_vars *)dmp->dm_vars)->width = ((struct glx_vars *)dmp->dm_vars)->height;
  else /* we have a funky shaped monitor */ 
    ((struct glx_vars *)dmp->dm_vars)->height = ((struct glx_vars *)dmp->dm_vars)->width;
d421 2
a422 2
		     ((struct glx_vars *)dmp->dm_vars)->width,
		     ((struct glx_vars *)dmp->dm_vars)->height);
d443 4
a446 2
  if(GLXlink(((struct glx_vars *)dmp->dm_vars)->dpy, glx_config) < 0)
    return TCL_ERROR;
d586 1
a586 1
  return TCL_OK;
d621 2
a622 2
  ((struct glx_vars *)dmp->dm_vars)->width = xwa.width;
  ((struct glx_vars *)dmp->dm_vars)->height = xwa.height;
d625 2
a626 2
  viewport(0, ((struct glx_vars *)dmp->dm_vars)->width, 0,
	   ((struct glx_vars *)dmp->dm_vars)->height);
d643 3
a645 3
  ((struct glx_vars *)dmp->dm_vars)->aspect =
    (fastf_t)((struct glx_vars *)dmp->dm_vars)->height/
    (fastf_t)((struct glx_vars *)dmp->dm_vars)->width;
d688 4
d693 1
d843 4
a846 4
  gtmat[0][0] = *(mptr++) * ((struct glx_vars *)dmp->dm_vars)->aspect;
  gtmat[1][0] = *(mptr++) * ((struct glx_vars *)dmp->dm_vars)->aspect;
  gtmat[2][0] = *(mptr++) * ((struct glx_vars *)dmp->dm_vars)->aspect;
  gtmat[3][0] = *(mptr++) * ((struct glx_vars *)dmp->dm_vars)->aspect;
d987 1
a987 1
Glx_drawString2D( dmp, str, x, y, size )
d992 1
d997 5
a1001 1
  cmov2( GED2IRIS(x), GED2IRIS(y));
d1236 2
a1237 2
  viewport(0, ((struct glx_vars *)dmp->dm_vars)->width, 0,
	   ((struct glx_vars *)dmp->dm_vars)->height);
@


1.10
log
@*- mods to use libbn
*- fixed a few return values
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-glx.c,v 1.9 1996/12/04 21:25:31 bparker Exp bparker $ (BRL)";
d262 1
a262 1
  bu_vls_printf(&str, "init_dm_win %s %s\n",
@


1.9
log
@change interface to Glx_open
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-glx.c,v 1.8 1996/10/24 22:13:14 bparker Exp bparker $ (BRL)";
d59 2
d65 1
d701 1
a701 1
    mat_idn( nozclip );
d703 1
a703 1
    mat_mul( newm, nozclip, mat );
d740 1
a758 3
 *  Returns -
 *	 0 if object could be drawn
 *	!0 if object was omitted.
d842 1
a842 1
  return(1);	/* OK */
d864 2
d885 2
@


1.8
log
@checkin for the week
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-glx.c,v 1.7 1996/10/23 20:28:49 bparker Exp bparker $ (BRL)";
d66 1
a101 1
static int      Glx_init();
a126 1
  Glx_init,
d151 1
d176 9
d186 1
a186 1
Glx_init(dmp, argc, argv)
d192 13
d210 7
a216 1
  bu_vls_printf(&dmp->dm_pathName, ".dm_glx%d", count++);
d249 2
a250 35
  if(dmp->dm_vars)
    return TCL_OK;

  return TCL_ERROR;
}


/*
 *			I R _ O P E N
 *
 *  Fire up the display manager, and the display processor. Note that
 *  this brain-damaged version of the MEX display manager gets terribly
 *  confused if you try to close your last window.  Tough. We go ahead
 *  and close the window.  Ignore the "ERR_CLOSEDLASTWINDOW" error
 *  message. It doesn't hurt anything.  Silly MEX.
 */
static int
Glx_open(dmp)
struct dm *dmp;
{
  register int	i;
  Matrix		m;
  inventory_t	*inv;
  struct bu_vls str;
  int j, k;
  int ndevices;
  int nclass = 0;
  XDeviceInfoPtr olist, list;
  XDevice *dev;
  XEventClass e_class[15];
  XInputClassInfo *cip;
  GLXconfig *p, *glx_config;
  XVisualInfo *visual_info;

  bu_vls_init(&str);
d258 4
a261 2
  bu_vls_strcpy(&str, "init_glx ");
  bu_vls_printf(&str, "%s\n", bu_vls_addr(&dmp->dm_pathName));
d272 5
d526 22
a547 16
  if(((struct glx_vars *)dmp->dm_vars)->xtkwin != NULL){
    if(((struct glx_vars *)dmp->dm_vars)->mvars.cueing_on)
      depthcue(0);

    lampoff( 0xf );

    /* avoids error messages when reattaching */
    mmode(MVIEWING);	
    lmbind(LIGHT2,0);
    lmbind(LIGHT3,0);
    lmbind(LIGHT4,0);
    lmbind(LIGHT5,0);

    frontbuffer(1);
    Glx_clear_to_black(dmp);
    frontbuffer(0);
d549 2
a550 3
    GLXunlink(((struct glx_vars *)dmp->dm_vars)->dpy,
	      ((struct glx_vars *)dmp->dm_vars)->win);
    Tk_DestroyWindow(((struct glx_vars *)dmp->dm_vars)->xtkwin);
a556 3

  if(BU_LIST_IS_EMPTY(&head_glx_vars.l))
    Tk_DeleteGenericHandler(dmp->dm_eventHandler, (ClientData)DM_TYPE_GLX);
@


1.7
log
@.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-glx.c,v 1.6 1996/10/04 20:29:03 bparker Exp bparker $ (BRL)";
a97 2
static void Glx_colorit();
static void Glx_gen_color();
a122 2
static int ovec = -1;		/* Old color map entry number */
static int kblights();
a124 9
#if 0
/*XXX This looks application specific */
static unsigned char invbmap[BV_MAXFUNC+1];
#endif

#ifdef IR_BUTTONS
/* bit 0 == switchlight 0 */
static unsigned long lights;
#endif
a175 7
#define CMAP_BASE	32
#define CMAP_RAMP_WIDTH	16
#define MAP_ENTRY(x)	((((struct glx_vars *)dmp->dm_vars)->mvars.cueing_on) ? \
			((x) * CMAP_RAMP_WIDTH + CMAP_BASE) : \
			((x) + CMAP_BASE) )


a1003 30

static void
Glx_colorit(dmp)
struct dm *dmp;
{
  register struct solid	*sp;
  register struct rgbtab *rgb;
  register int i;
  register int r,g,b;

  if( ((struct glx_vars *)dmp->dm_vars)->mvars.rgb )
    return;
}

/*			G E N _ C O L O R
 *
 *	maps a given color into the appropriate colormap entry
 *	for both depthcued and non-depthcued mode.  In depthcued mode,
 *	glx_gen_color also generates the colormap ramps.  Note that in depthcued
 *	mode, DM_BLACK uses map entry 0, and does not generate a ramp for it.
 *	Non depthcued mode skips the first CMAP_BASE colormap entries.
 *
 *	This routine is not called at all if ((struct glx_vars *)dmp->dm_vars)->mvars.rgb is set.
 */
static void
Glx_gen_color(c)
int c;
{
  return;
}
@


1.6
log
@- a little house cleaning
- now using dm_limit and dm_unlimit instead of
Glx_irlimit and Glx_add_tol.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-glx.c,v 1.5 1996/09/30 19:40:38 bparker Exp bparker $ (BRL)";
d47 1
d49 4
a52 5
#include <stdio.h>
#include <math.h>
#include <termio.h>
#undef VMIN		/* is used in vmath.h, too */
#include <ctype.h>
a53 1
#include <X11/X.h>
a54 2
#include "tk.h"
#include <X11/extensions/XI.h>
a56 8

#include <gl/gl.h>		/* SGI IRIS library */
#include <gl/device.h>		/* SGI IRIS library */
#include <gl/get.h>		/* SGI IRIS library */
#include <gl/cg2vme.h>		/* SGI IRIS, for DE_R1 defn on IRIX 3 */
#include <gl/addrs.h>		/* SGI IRIS, for DER1_STEREO defn on IRIX 3 */
#include <sys/types.h>
#include <sys/time.h>
a65 1
#include "solid.h"
a79 1
void    Glx_viewchange();
d96 1
a96 1
static void Glx_load_startup();
d105 7
a111 7
static void	Glx_close();
static void     Glx_input();
static void	Glx_prolog(), Glx_epilog();
static void	Glx_normal(), Glx_newrot();
static void	Glx_update();
static void	Glx_puts(), Glx_2d_line(), Glx_light();
static int	Glx_object();
d113 1
a113 2
static void	Glx_colorchange();
static void	Glx_window(), Glx_debug();
d141 17
a157 13
  Glx_open, Glx_close,
  Glx_input,
  Glx_prolog, Glx_epilog,
  Glx_normal, Glx_newrot,
  Glx_update,
  Glx_puts, Glx_2d_line,
  Glx_light,
  Glx_object,
  Glx_cvtvecs, Glx_load,
  0,
  Glx_viewchange,
  Glx_colorchange,
  Glx_window, Glx_debug, 0, 0,
d178 1
a178 1
  return ((x/(double)((struct glx_vars *)dmp->dmr_vars)->width - 0.5) * 4095);
d186 1
a186 1
  return ((0.5 - y/(double)((struct glx_vars *)dmp->dmr_vars)->height) * 4095);
d191 1
a191 1
#define MAP_ENTRY(x)	((((struct glx_vars *)dmp->dmr_vars)->mvars.cueing_on) ? \
d206 1
a206 1
    Glx_load_startup(dmp);
d208 1
a208 1
  bu_vls_printf(&dmp->dmr_pathName, ".dm_glx%d", count++);
d210 5
a214 5
  dmp->dmr_vars = bu_calloc(1, sizeof(struct glx_vars), "Glx_init: struct glx_vars");
  ((struct glx_vars *)dmp->dmr_vars)->devmotionnotify = LASTEvent;
  ((struct glx_vars *)dmp->dmr_vars)->devbuttonpress = LASTEvent;
  ((struct glx_vars *)dmp->dmr_vars)->devbuttonrelease = LASTEvent;
  ((struct glx_vars *)dmp->dmr_vars)->perspective_angle = 3;
d217 4
a220 5
  ((struct glx_vars *)dmp->dmr_vars)->mvars.cueing_on = 1;          /* Depth cueing flag - for colormap work */
  ((struct glx_vars *)dmp->dmr_vars)->mvars.zclipping_on = 1;       /* Z Clipping flag */
  ((struct glx_vars *)dmp->dmr_vars)->mvars.zbuffer_on = 1;         /* Hardware Z buffer is on */
  ((struct glx_vars *)dmp->dmr_vars)->mvars.linewidth = 1;      /* Line drawing width */
  ((struct glx_vars *)dmp->dmr_vars)->mvars.dummy_perspective = 1;
d223 1
a223 1
    Tk_CreateGenericHandler(dmp->dmr_eventhandler, (ClientData)DM_TYPE_GLX);
d225 1
a225 1
  BU_LIST_APPEND(&head_glx_vars.l, &((struct glx_vars *)dmp->dmr_vars)->l);
d241 1
a241 1
  if(dmp->dmr_vars)
d277 2
a278 2
  ((struct glx_vars *)dmp->dmr_vars)->xtkwin =
    Tk_CreateWindowFromPath(interp, tkwin, bu_vls_addr(&dmp->dmr_pathName), dmp->dmr_dname);
d284 1
a284 1
  bu_vls_printf(&str, "%s\n", bu_vls_addr(&dmp->dmr_pathName));
d293 8
a300 8
  ((struct glx_vars *)dmp->dmr_vars)->dpy =
    Tk_Display(((struct glx_vars *)dmp->dmr_vars)->xtkwin);
  ((struct glx_vars *)dmp->dmr_vars)->width =
    DisplayWidth(((struct glx_vars *)dmp->dmr_vars)->dpy,
		 DefaultScreen(((struct glx_vars *)dmp->dmr_vars)->dpy)) - 20;
  ((struct glx_vars *)dmp->dmr_vars)->height =
    DisplayHeight(((struct glx_vars *)dmp->dmr_vars)->dpy,
		  DefaultScreen(((struct glx_vars *)dmp->dmr_vars)->dpy)) - 20;
d303 2
a304 2
  if( ((struct glx_vars *)dmp->dmr_vars)->height < ((struct glx_vars *)dmp->dmr_vars)->width )
    ((struct glx_vars *)dmp->dmr_vars)->width = ((struct glx_vars *)dmp->dmr_vars)->height;
d306 5
a310 1
    ((struct glx_vars *)dmp->dmr_vars)->height = ((struct glx_vars *)dmp->dmr_vars)->width;
d312 2
a313 7
  Tk_GeometryRequest(((struct glx_vars *)dmp->dmr_vars)->xtkwin,
		     ((struct glx_vars *)dmp->dmr_vars)->width,
		     ((struct glx_vars *)dmp->dmr_vars)->height);

  ((struct glx_vars *)dmp->dmr_vars)->is_gt = 1;
  glx_config = GLXgetconfig(((struct glx_vars *)dmp->dmr_vars)->dpy,
			    Tk_ScreenNumber(((struct glx_vars *)dmp->dmr_vars)->xtkwin),
d316 3
a318 3
  ((struct glx_vars *)dmp->dmr_vars)->vis = visual_info->visual;
  ((struct glx_vars *)dmp->dmr_vars)->depth = visual_info->depth;
  ((struct glx_vars *)dmp->dmr_vars)->cmap = extract_value(GLX_NORMAL, GLX_COLORMAP,
d320 9
a328 9
  Tk_SetWindowVisual(((struct glx_vars *)dmp->dmr_vars)->xtkwin,
		     ((struct glx_vars *)dmp->dmr_vars)->vis,
		     ((struct glx_vars *)dmp->dmr_vars)->depth,
		     ((struct glx_vars *)dmp->dmr_vars)->cmap);

  Tk_MakeWindowExist(((struct glx_vars *)dmp->dmr_vars)->xtkwin);
  ((struct glx_vars *)dmp->dmr_vars)->win =
    Tk_WindowId(((struct glx_vars *)dmp->dmr_vars)->xtkwin);
  set_window(GLX_NORMAL, ((struct glx_vars *)dmp->dmr_vars)->win, glx_config);
d331 1
a331 1
  if(GLXlink(((struct glx_vars *)dmp->dmr_vars)->dpy, glx_config) < 0)
d334 2
a335 2
  GLXwinset(((struct glx_vars *)dmp->dmr_vars)->dpy,
	    ((struct glx_vars *)dmp->dmr_vars)->win);
d344 1
a344 1
	  ((struct glx_vars *)dmp->dmr_vars)->mvars.zbuf = 1;
d346 1
a346 1
	  ((struct glx_vars *)dmp->dmr_vars)->mvars.zbuf = 0;
d351 1
a351 1
	  ((struct glx_vars *)dmp->dmr_vars)->mvars.rgb = 1;
d353 1
a353 1
	  ((struct glx_vars *)dmp->dmr_vars)->mvars.rgb = 0;
d358 1
a358 1
	  ((struct glx_vars *)dmp->dmr_vars)->mvars.doublebuffer = 1;
d360 1
a360 1
	  ((struct glx_vars *)dmp->dmr_vars)->mvars.doublebuffer = 0;
d364 1
a364 1
	((struct glx_vars *)dmp->dmr_vars)->stereo_is_on = 1;
d407 2
a408 2
  ((struct glx_vars *)dmp->dmr_vars)->mvars.min_scr_z = getgdesc(GD_ZMIN)+15;
  ((struct glx_vars *)dmp->dmr_vars)->mvars.max_scr_z = getgdesc(GD_ZMAX)-15;
d421 1
a421 1
    (XDeviceInfoPtr)XListInputDevices(((struct glx_vars *)dmp->dmr_vars)->dpy, &ndevices);
d430 1
a430 1
	if((dev = XOpenDevice(((struct glx_vars *)dmp->dmr_vars)->dpy,
d442 1
a442 1
	    DeviceButtonPress(dev, ((struct glx_vars *)dmp->dmr_vars)->devbuttonpress,
d445 1
a445 1
	    DeviceButtonRelease(dev, ((struct glx_vars *)dmp->dmr_vars)->devbuttonrelease,
d452 1
a452 1
	    DeviceMotionNotify(dev, ((struct glx_vars *)dmp->dmr_vars)->devmotionnotify,
d462 2
a463 2
	XSelectExtensionEvent(((struct glx_vars *)dmp->dmr_vars)->dpy,
			      ((struct glx_vars *)dmp->dmr_vars)->win, e_class, nclass);
d471 1
a471 1
  Tk_MapWindow(((struct glx_vars *)dmp->dmr_vars)->xtkwin);
d476 1
a476 1
static void
d486 3
a488 1
    Tcl_EvalFile(interp, filename);
d505 4
a508 4
  XGetWindowAttributes( ((struct glx_vars *)dmp->dmr_vars)->dpy,
			((struct glx_vars *)dmp->dmr_vars)->win, &xwa );
  ((struct glx_vars *)dmp->dmr_vars)->width = xwa.width;
  ((struct glx_vars *)dmp->dmr_vars)->height = xwa.height;
d511 2
a512 2
  viewport(0, ((struct glx_vars *)dmp->dmr_vars)->width, 0,
	   ((struct glx_vars *)dmp->dmr_vars)->height);
d514 1
a514 1
  if( ((struct glx_vars *)dmp->dmr_vars)->mvars.zbuf )
d519 1
a519 1
  if( ((struct glx_vars *)dmp->dmr_vars)->mvars.doublebuffer){
d529 3
a531 3
  ((struct glx_vars *)dmp->dmr_vars)->aspect =
    (fastf_t)((struct glx_vars *)dmp->dmr_vars)->height/
    (fastf_t)((struct glx_vars *)dmp->dmr_vars)->width;
d540 1
a540 1
static void
d544 2
a545 2
  if(((struct glx_vars *)dmp->dmr_vars)->xtkwin != NULL){
    if(((struct glx_vars *)dmp->dmr_vars)->mvars.cueing_on)
d561 3
a563 3
    GLXunlink(((struct glx_vars *)dmp->dmr_vars)->dpy,
	      ((struct glx_vars *)dmp->dmr_vars)->win);
    Tk_DestroyWindow(((struct glx_vars *)dmp->dmr_vars)->xtkwin);
d566 2
a567 2
  if(((struct glx_vars *)dmp->dmr_vars)->l.forw != BU_LIST_NULL)
    BU_LIST_DEQUEUE(&((struct glx_vars *)dmp->dmr_vars)->l);
d569 1
a569 1
  bu_free(dmp->dmr_vars, "Glx_close: glx_vars");
d572 3
a574 1
    Tk_DeleteGenericHandler(dmp->dmr_eventhandler, (ClientData)DM_TYPE_GLX);
d582 2
a583 2
 * which is built between dmr_normal() and dmr_epilog()
 * by dmr_puts and dmr_2d_line calls from adcursor() and dotitles().
d585 2
a586 2
static void
Glx_prolog(dmp)
d589 2
a590 2
  GLXwinset(((struct glx_vars *)dmp->dmr_vars)->dpy,
	    ((struct glx_vars *)dmp->dmr_vars)->win);
d592 2
a593 2
  if (((struct glx_vars *)dmp->dmr_vars)->mvars.debug)
    Tcl_AppendResult(interp, "Glx_prolog\n", (char *)NULL);
d597 1
a597 1
  if( !((struct glx_vars *)dmp->dmr_vars)->mvars.doublebuffer ){
d599 4
a602 2
    return;
  }
d604 1
a604 1
  linewidth(((struct glx_vars *)dmp->dmr_vars)->mvars.linewidth);
d614 1
a614 1
static void
d618 1
a618 1
  if (((struct glx_vars *)dmp->dmr_vars)->mvars.debug)
d621 3
a623 5
  if( ((struct glx_vars *)dmp->dmr_vars)->mvars.rgb )  {
    RGBcolor( (short)0, (short)0, (short)0 );
  } else {
    color(BLACK);
  }
d626 2
d633 2
a634 2
static void
Glx_epilog(dmp)
d637 2
a638 2
  if (((struct glx_vars *)dmp->dmr_vars)->mvars.debug)
    Tcl_AppendResult(interp, "Glx_epilog\n", (char *)NULL);
d644 1
a644 1
  Glx_2d_line( dmp, 0, 0, 0, 0, 0 );
d647 1
a647 1
  if(((struct glx_vars *)dmp->dmr_vars)->mvars.doublebuffer){
d652 2
d660 1
a660 1
 *  many calls to Glx_object().
d682 1
a682 1
static void
d688 25
a712 22
	register fastf_t *mptr;
	Matrix	gtmat;
	mat_t	newm;
	int	i;

	if (((struct glx_vars *)dmp->dmr_vars)->mvars.debug)
	  Tcl_AppendResult(interp, "Glx_newrot()\n", (char *)NULL);

	switch(which_eye)  {
	case 0:
		/* Non-stereo */
		break;
	case 1:
		/* R eye */
		viewport(0, XMAXSCREEN, 0, YSTEREO);
		Glx_puts( dmp, "R", 2020, 0, 0, DM_RED );
		break;
	case 2:
		/* L eye */
		viewport(0, XMAXSCREEN, 0+YOFFSET_LEFT, YSTEREO+YOFFSET_LEFT);
		break;
	}
d714 7
a720 2
	if( ! ((struct glx_vars *)dmp->dmr_vars)->mvars.zclipping_on ) {
		mat_t	nozclip;
d722 19
a740 7
		mat_idn( nozclip );
		nozclip[10] = 1.0e-20;
		mat_mul( newm, nozclip, mat );
		mptr = newm;
	} else {
		mptr = mat;
	}
d742 9
a750 29
	gtmat[0][0] = *(mptr++) * ((struct glx_vars *)dmp->dmr_vars)->aspect;
	gtmat[1][0] = *(mptr++) * ((struct glx_vars *)dmp->dmr_vars)->aspect;
	gtmat[2][0] = *(mptr++) * ((struct glx_vars *)dmp->dmr_vars)->aspect;
	gtmat[3][0] = *(mptr++) * ((struct glx_vars *)dmp->dmr_vars)->aspect;

	gtmat[0][1] = *(mptr++);
	gtmat[1][1] = *(mptr++);
	gtmat[2][1] = *(mptr++);
	gtmat[3][1] = *(mptr++);

	gtmat[0][2] = *(mptr++);
	gtmat[1][2] = *(mptr++);
	gtmat[2][2] = *(mptr++);
	gtmat[3][2] = *(mptr++);

	gtmat[0][3] = *(mptr++);
	gtmat[1][3] = *(mptr++);
	gtmat[2][3] = *(mptr++);
	gtmat[3][3] = *(mptr++);

	/*
	 *  Convert between MGED's right handed coordinate system
	 *  where +Z comes out of the screen to the Silicon Graphics's
	 *  left handed coordinate system, where +Z goes INTO the screen.
	 */
	gtmat[0][2] = -gtmat[0][2];
	gtmat[1][2] = -gtmat[1][2];
	gtmat[2][2] = -gtmat[2][2];
	gtmat[3][2] = -gtmat[3][2];
d752 1
a752 1
	loadmatrix( gtmat );
d776 1
a776 1
Glx_object( dmp, vp, m, illum, linestyle, r, g, b, index )
a779 4
int illum;
int linestyle;
register short r, g, b;
short index;
d781 6
a786 18
	register struct rt_vlist	*tvp;
	register int nvec;
	register float	*gtvec;
	char	gtbuf[16+3*sizeof(double)];
	int first;
	int i,j;

	if (((struct glx_vars *)dmp->dmr_vars)->mvars.debug)
	  Tcl_AppendResult(interp, "Glx_Object()\n", (char *)NULL);

	/*
	 *  It is claimed that the "dancing vector disease" of the
	 *  4D GT processors is due to the array being passed to v3f()
	 *  not being quad-word aligned (16-byte boundary).
	 *  This hack ensures that the buffer has this alignment.
	 *  Note that this requires gtbuf to be 16 bytes longer than needed.
	 */
	gtvec = (float *)((((int)gtbuf)+15) & (~0xF));
d788 2
a789 11
	/*
	 * IMPORTANT DEPTHCUEING NOTE
	 *
	 * Also note that the depthcueing shaderange() routine wanders
	 * outside it's allotted range due to roundoff errors.  A buffer
	 * entry is kept on each end of the shading curves, and the
	 * highlight mode uses the *next* to the brightest entry --
	 * otherwise it can (and does) fall off the shading ramp.
	 */
	if (linestyle)
		setlinestyle( 1 );		/* set dot-dash */
d791 8
a798 4
	if( ((struct glx_vars *)dmp->dmr_vars)->mvars.rgb )  {
	  if( illum )  {
	    r = g = b = 230;
	  }
d800 43
a842 56
	  if(((struct glx_vars *)dmp->dmr_vars)->mvars.cueing_on)  {
	    lRGBrange(r/10, g/10, b/10, r, g, b,
		      ((struct glx_vars *)dmp->dmr_vars)->mvars.min_scr_z,
		      ((struct glx_vars *)dmp->dmr_vars)->mvars.max_scr_z );
	  } else if(((struct glx_vars *)dmp->dmr_vars)->mvars.lighting_on &&
		    ((struct glx_vars *)dmp->dmr_vars)->is_gt) {
	    /* Ambient = .2, Diffuse = .6, Specular = .2 */

	    /* Ambient */
	    material_objdef[3] = 	.2 * ( r / 255.0);
	    material_objdef[4] = 	.2 * ( g / 255.0);
	    material_objdef[5] = 	.2 * ( b / 255.0);

	    /* diffuse */
	    material_objdef[7] = 	.6 * ( r / 255.0);
	    material_objdef[8] = 	.6 * ( g / 255.0);
	    material_objdef[9] = 	.6 * ( b / 255.0);

	    /* Specular */
	    material_objdef[11] = 	.2 * ( r / 255.0);
	    material_objdef[12] = 	.2 * ( g / 255.0);
	    material_objdef[13] = 	.2 * ( b / 255.0);

	    lmdef(DEFMATERIAL, 21, 0, material_objdef);
	    lmbind(MATERIAL, 21);
	  } else
	    RGBcolor( r, g, b );
	} else {
	  if( illum ) {
	    ovec = nvec = MAP_ENTRY(DM_WHITE);
	    /* Use the *next* to the brightest white entry */
	    if(((struct glx_vars *)dmp->dmr_vars)->mvars.cueing_on)  {
	      lshaderange(nvec+1, nvec+1, 
			  ((struct glx_vars *)dmp->dmr_vars)->mvars.min_scr_z,
			  ((struct glx_vars *)dmp->dmr_vars)->mvars.max_scr_z );
	    }
	    color( nvec );
	  } else {
	    if( (nvec = MAP_ENTRY( index )) != ovec) {
	      /* Use only the middle 14 to allow for roundoff...
	       * Pity the poor fool who has defined a black object.
	       * The code will use the "reserved" color map entries
	       * to display it when in depthcued mode.
	       */
	      if(((struct glx_vars *)dmp->dmr_vars)->mvars.cueing_on)  {
		lshaderange(nvec+1, nvec+14,
			    ((struct glx_vars *)dmp->dmr_vars)->mvars.min_scr_z,
			    ((struct glx_vars *)dmp->dmr_vars)->mvars.max_scr_z );
	      }
	      color( nvec );
	      ovec = nvec;
	    }
	  }
	}

	/* Viewing region is from -1.0 to +1.0 */
d844 9
a852 52
	for( BU_LIST_FOR( tvp, rt_vlist, &vp->l ) )  {
		register int	i;
		register int	nused = tvp->nused;
		register int	*cmd = tvp->cmd;
		register point_t *pt = tvp->pt;
		for( i = 0; i < nused; i++,cmd++,pt++ )  {
			switch( *cmd )  {
			case RT_VLIST_LINE_MOVE:
				/* Move, start line */
				if( first == 0 )
					endline();
				first = 0;
				bgnline();
				v3d( *pt );
				break;
			case RT_VLIST_LINE_DRAW:
				/* Draw line */
				v3d( *pt );
				break;
			case RT_VLIST_POLY_START:
				/* Start poly marker & normal */
				if( first == 0 )
					endline();
				/* concave(TRUE); */
				bgnpolygon();
				/* Set surface normal (vl_pnt points outward) */
				VMOVE( gtvec, *pt );
				n3f(gtvec);
				break;
			case RT_VLIST_POLY_MOVE:
				/* Polygon Move */
				v3d( *pt );
				break;
			case RT_VLIST_POLY_DRAW:
				/* Polygon Draw */
				v3d( *pt );
				break;
			case RT_VLIST_POLY_END:
				/* Draw, End Polygon */
				v3d( *pt );
				endpolygon();
				first = 1;
				break;
			case RT_VLIST_POLY_VERTNORM:
				/* Set per-vertex normal.  Given before vert. */
				VMOVE( gtvec, *pt );
				n3f(gtvec);
				break;
			}
		}
	}
	if( first == 0 ) endline();
d854 2
a855 2
	if (linestyle)
		setlinestyle(0);		/* restore solid lines */
d857 1
a857 1
	return(1);	/* OK */
a859 15
/*
 *			I R _ U P D A T E
 *
 * Transmit accumulated displaylist to the display processor.
 * Last routine called in refresh cycle.
 */
static void
Glx_update(dmp)
struct dm *dmp;
{
	if (((struct glx_vars *)dmp->dmr_vars)->mvars.debug)
	  Tcl_AppendResult(interp, "Glx_update()\n", (char *)NULL);

	return;
}
d867 2
a868 2
static void
Glx_puts( dmp, str, x, y, size, colour )
d871 2
a872 1
int x,y,size, colour;
d874 2
a875 2
	if (((struct glx_vars *)dmp->dmr_vars)->mvars.debug)
	  Tcl_AppendResult(interp, "Glx_puts()\n", (char *)NULL);
d877 2
a878 9
	cmov2( GED2IRIS(x), GED2IRIS(y));
	if( ((struct glx_vars *)dmp->dmr_vars)->mvars.rgb )  {
		RGBcolor( (short)((struct glx_vars *)dmp->dmr_vars)->rgbtab[colour].r,
		    (short)((struct glx_vars *)dmp->dmr_vars)->rgbtab[colour].g,
		    (short)((struct glx_vars *)dmp->dmr_vars)->rgbtab[colour].b );
	} else {
		color( MAP_ENTRY(colour) );
	}
	charstr( str );
d885 2
a886 2
static void
Glx_2d_line( dmp, x1, y1, x2, y2, dashed )
a889 1
int dashed;
d893 2
a894 2
  if (((struct glx_vars *)dmp->dmr_vars)->mvars.debug)
    Tcl_AppendResult(interp, "Glx_2d_line()\n", (char *)NULL);
a895 22
  if( ((struct glx_vars *)dmp->dmr_vars)->mvars.rgb )  {
    /* Yellow */
    if(((struct glx_vars *)dmp->dmr_vars)->mvars.cueing_on)  {
      lRGBrange(255, 255, 0,
		255, 255, 0,
		((struct glx_vars *)dmp->dmr_vars)->mvars.min_scr_z,
		((struct glx_vars *)dmp->dmr_vars)->mvars.max_scr_z );
    }
    RGBcolor( (short)255, (short)255, (short) 0 );
  } else {
    if((nvec = MAP_ENTRY(DM_YELLOW)) != ovec) {
      if(((struct glx_vars *)dmp->dmr_vars)->mvars.cueing_on)
	lshaderange(nvec, nvec, ((struct glx_vars *)dmp->dmr_vars)->mvars.min_scr_z,
		    ((struct glx_vars *)dmp->dmr_vars)->mvars.max_scr_z );
      color( nvec );
      ovec = nvec;
    }
  }

  if( dashed )
    setlinestyle(1);	/* into dot-dash */

d898 1
d900 6
a905 2
  if( dashed )
    setlinestyle(0);	/* restore to solid */
d908 2
a909 13
/*
 *			I R _ I N P U T
 *
 * Execution must suspend in this routine until a significant event
 * has occured on either the command stream, or a device event has
 * occured, unless "noblock" is set.
 *
 * Implicit Return -
 *	If any files are ready for input, their bits will be set in 'input'.
 *	Otherwise, 'input' will be all zeros.
 */
static void
Glx_input( dmp, input, noblock )
d911 2
a912 2
fd_set		*input;
int		noblock;
d914 48
a961 1
  return;
d965 2
a966 11
/* 
 *			I R _ L I G H T
 *
 * This function must keep both the light hardware, and the software
 * copy of the lights up to date.  Note that requests for light changes
 * may not actually cause the lights to be changed, depending on
 * whether the buttons are being used for "view" or "edit" functions
 * (although this is not done in the present code).
 */
static void
Glx_light( dmp, cmd, func )
d968 2
a969 2
int cmd;
int func;			/* BE_ or BV_ function */
d971 7
a977 18
	register unsigned short bit;
#if 0
/*XXX This looks application specific */
#ifdef IR_BUTTONS
	/* Check for BE_ function not assigned to a button */
	if( (bit = invbmap[func]) == 0 && cmd != LIGHT_RESET )
		return;
	switch( cmd )  {
	case LIGHT_RESET:
		lights = 0;
		break;
	case LIGHT_ON:
		lights |= 1<<bit;
		break;
	case LIGHT_OFF:
		lights &= ~(1<<bit);
		break;
	}
d979 1
a979 6
	/* Update the lights box. */
#if !defined(__sgi)	/* This bombs, on early Irix 4.0 releases */
	setdblights( lights );
#endif
#endif
#endif
d982 1
d992 1
a992 1
	return( 0 );	/* No "displaylist" consumed */
d1003 1
a1003 1
	return( 0 );		/* FLAG:  error */
a1005 14
void
Glx_viewchange( dmp, cmd, sp )
struct dm *dmp;
register int cmd;
register struct solid *sp;
{
  if( ((struct glx_vars *)dmp->dmr_vars)->mvars.debug ){
    struct bu_vls tmp_vls;

    bu_vls_init(&tmp_vls);
    bu_vls_printf(&tmp_vls, "viewchange( %d, x%x )\n", cmd, sp );
    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
    bu_vls_free(&tmp_vls);
  }
d1007 1
a1007 15
  switch( cmd ){
  case DM_CHGV_ADD:
    break;
  case DM_CHGV_REDO:
    break;
  case DM_CHGV_DEL:
    break;
  case DM_CHGV_REPL:
    return;
  case DM_CHGV_ILLUM:
    break;
  }
}

static void
d1011 3
a1013 1
  ((struct glx_vars *)dmp->dmr_vars)->mvars.debug = lvl;
d1016 2
a1017 2
void
Glx_window(dmp, w)
d1021 1
a1024 81
/*
 *  			I R _ C O L O R C H A N G E
 *  
 *  Go through the solid table, and allocate color map slots.
 *	8 bit system gives 4 or 8,
 *	24 bit system gives 12 or 24.
 */
static void
Glx_colorchange(dmp)
struct dm *dmp;
{
	register int i;
	register int nramp;

	if( ((struct glx_vars *)dmp->dmr_vars)->mvars.debug )
	  Tcl_AppendResult(interp, "colorchange\n", (char *)NULL);

	/* Program the builtin colors */
	((struct glx_vars *)dmp->dmr_vars)->rgbtab[0].r=0; 
	((struct glx_vars *)dmp->dmr_vars)->rgbtab[0].g=0; 
	((struct glx_vars *)dmp->dmr_vars)->rgbtab[0].b=0;/* Black */
	((struct glx_vars *)dmp->dmr_vars)->rgbtab[1].r=255; 
	((struct glx_vars *)dmp->dmr_vars)->rgbtab[1].g=0; 
	((struct glx_vars *)dmp->dmr_vars)->rgbtab[1].b=0;/* Red */
	((struct glx_vars *)dmp->dmr_vars)->rgbtab[2].r=0; 
	((struct glx_vars *)dmp->dmr_vars)->rgbtab[2].g=0; 
	((struct glx_vars *)dmp->dmr_vars)->rgbtab[2].b=255;/* Blue */
	((struct glx_vars *)dmp->dmr_vars)->rgbtab[3].r=255; 
	((struct glx_vars *)dmp->dmr_vars)->rgbtab[3].g=255;
	((struct glx_vars *)dmp->dmr_vars)->rgbtab[3].b=0;/*Yellow */
	((struct glx_vars *)dmp->dmr_vars)->rgbtab[4].r =
	  ((struct glx_vars *)dmp->dmr_vars)->rgbtab[4].g =
	  ((struct glx_vars *)dmp->dmr_vars)->rgbtab[4].b = 255; /* White */
	((struct glx_vars *)dmp->dmr_vars)->uslots = 5;

	if( ((struct glx_vars *)dmp->dmr_vars)->mvars.rgb )  {
		if(((struct glx_vars *)dmp->dmr_vars)->mvars.cueing_on) {
			depthcue(1);
		} else {
			depthcue(0);
		}

		RGBcolor( (short)255, (short)255, (short)255 );

		return;
	}

	((struct glx_vars *)dmp->dmr_vars)->nslots = getplanes();
	if(((struct glx_vars *)dmp->dmr_vars)->mvars.cueing_on &&
	   (((struct glx_vars *)dmp->dmr_vars)->nslots < 7)) {
	  Tcl_AppendResult(interp, "Too few bitplanes: depthcueing disabled\n", (char *)NULL);
	  ((struct glx_vars *)dmp->dmr_vars)->mvars.cueing_on = 0;
	}
	((struct glx_vars *)dmp->dmr_vars)->nslots =
	  1<<((struct glx_vars *)dmp->dmr_vars)->nslots;
	if( ((struct glx_vars *)dmp->dmr_vars)->nslots > NSLOTS )
	  ((struct glx_vars *)dmp->dmr_vars)->nslots = NSLOTS;
	if(((struct glx_vars *)dmp->dmr_vars)->mvars.cueing_on) {
	  /* peel off reserved ones */
	  ((struct glx_vars *)dmp->dmr_vars)->nslots =
	    (((struct glx_vars *)dmp->dmr_vars)->nslots - CMAP_BASE) / CMAP_RAMP_WIDTH;
	  depthcue(1);
	} else {
	  ((struct glx_vars *)dmp->dmr_vars)->nslots -= CMAP_BASE;	/* peel off the reserved entries */
	  depthcue(0);
	}

	ovec = -1;	/* Invalidate the old colormap entry */

	/* Map the colors in the solid table to colormap indices */
	Glx_colorit(dmp);

	for( i=0; i < ((struct glx_vars *)dmp->dmr_vars)->uslots; i++ )  {
	  Glx_gen_color( i, ((struct glx_vars *)dmp->dmr_vars)->rgbtab[i].r,
			 ((struct glx_vars *)dmp->dmr_vars)->rgbtab[i].g,
			 ((struct glx_vars *)dmp->dmr_vars)->rgbtab[i].b);
	}

	color(WHITE);	/* undefinied after gconfig() */
}

d1029 4
a1032 4
	register struct solid	*sp;
	register struct rgbtab *rgb;
	register int i;
	register int r,g,b;
d1034 2
a1035 38

	if( ((struct glx_vars *)dmp->dmr_vars)->mvars.rgb )  return;

#if 0
	FOR_ALL_SOLIDS(sp, &dmp->dmr_hp->l)  {
		r = sp->s_color[0];
		g = sp->s_color[1];
		b = sp->s_color[2];
		if( (r == 255 && g == 255 && b == 255) ||
		    (r == 0 && g == 0 && b == 0) )  {
			sp->s_dmindex = DM_WHITE;
			continue;
		}

		/* First, see if this matches an existing color map entry */
		rgb = ((struct glx_vars *)dmp->dmr_vars)->rgbtab;
		for( i = 0; i < ((struct glx_vars *)dmp->dmr_vars)->uslots; i++, rgb++ )  {
			if( rgb->r == r && rgb->g == g && rgb->b == b )  {
				sp->s_dmindex = i;
				goto next;
			}
		}

		/* If slots left, create a new color map entry, first-come basis */
		if( ((struct glx_vars *)dmp->dmr_vars)->uslots <
		    ((struct glx_vars *)dmp->dmr_vars)->nslots )  {
		  rgb = &((struct glx_vars *)dmp->dmr_vars)->rgbtab[i=(((struct glx_vars *)dmp->dmr_vars)->uslots++)];
		  rgb->r = r;
		  rgb->g = g;
		  rgb->b = b;
		  sp->s_dmindex = i;
		  continue;
		}
		sp->s_dmindex = DM_YELLOW;	/* Default color */
next:		
		;
	}
#endif
d1046 1
a1046 1
 *	This routine is not called at all if ((struct glx_vars *)dmp->dmr_vars)->mvars.rgb is set.
a1054 19
#ifdef never
/*
 *  Update the PF key lights.
 */
static int
kblights()
{
	char	lights;

	lights = (((struct glx_vars *)dmp->dmr_vars)->mvars.cueing_on)
	    | (((struct glx_vars *)dmp->dmr_vars)->mvars.zclipping_on << 1)
	    | (((struct glx_vars *)dmp->dmr_vars)->mvars.perspective_mode << 2)
	    | (((struct glx_vars *)dmp->dmr_vars)->mvars.zbuffer_on << 3);

	lampon(lights);
	lampoff(lights^0xf);
}
#endif

d1063 2
a1064 2
		((struct glx_vars *)dmp->dmr_vars)->mvars.perspective_mode ?
		perspective_table[((struct glx_vars *)dmp->dmr_vars)->perspective_angle] :
d1084 6
a1089 6
  if(((struct glx_vars *)dmp->dmr_vars)->mvars.dummy_perspective > 0)
    ((struct glx_vars *)dmp->dmr_vars)->perspective_angle =
      ((struct glx_vars *)dmp->dmr_vars)->mvars.dummy_perspective <= 4 ?
      ((struct glx_vars *)dmp->dmr_vars)->mvars.dummy_perspective - 1: 3;
  else if (--((struct glx_vars *)dmp->dmr_vars)->perspective_angle < 0) /* toggle perspective matrix */
    ((struct glx_vars *)dmp->dmr_vars)->perspective_angle = 3;
d1091 1
a1091 1
  if(((struct glx_vars *)dmp->dmr_vars)->mvars.perspective_mode){
d1096 1
a1096 1
		  perspective_table[((struct glx_vars *)dmp->dmr_vars)->perspective_angle] );
d1106 1
a1106 1
  ((struct glx_vars *)dmp->dmr_vars)->mvars.dummy_perspective = 1;
d1117 1
a1117 1
	if( ((struct glx_vars *)dmp->dmr_vars)->mvars.zbuf == 0 )  {
d1120 1
a1120 1
	  ((struct glx_vars *)dmp->dmr_vars)->mvars.zbuffer_on = 0;
d1122 2
a1123 2
	zbuffer( ((struct glx_vars *)dmp->dmr_vars)->mvars.zbuffer_on );
	if( ((struct glx_vars *)dmp->dmr_vars)->mvars.zbuffer_on)  {
d1125 2
a1126 2
	  lsetdepth(((struct glx_vars *)dmp->dmr_vars)->mvars.min_scr_z,
		    ((struct glx_vars *)dmp->dmr_vars)->mvars.max_scr_z);
d1138 2
a1139 2
  viewport(0, ((struct glx_vars *)dmp->dmr_vars)->width, 0,
	   ((struct glx_vars *)dmp->dmr_vars)->height);
d1141 1
a1141 1
  if( ((struct glx_vars *)dmp->dmr_vars)->mvars.zbuffer_on )  {
d1143 2
a1144 2
    if( ((struct glx_vars *)dmp->dmr_vars)->mvars.rgb )  {
      czclear( 0x000000, ((struct glx_vars *)dmp->dmr_vars)->mvars.max_scr_z );
d1146 1
a1146 1
      czclear( BLACK, ((struct glx_vars *)dmp->dmr_vars)->mvars.max_scr_z );
d1149 1
a1149 1
    if( ((struct glx_vars *)dmp->dmr_vars)->mvars.rgb )  {
d1179 1
a1179 1
  if( !((struct glx_vars *)dmp->dmr_vars)->mvars.lighting_on )  {
d1187 1
a1187 1
    if( ((struct glx_vars *)dmp->dmr_vars)->mvars.cueing_on )  {
d1189 2
a1190 1
      ((struct glx_vars *)dmp->dmr_vars)->mvars.cueing_on = 0;
d1192 3
d1647 1
a1647 1
  template.screen = Tk_ScreenNumber(((struct glx_vars *)dmp->dmr_vars)->xtkwin);
d1650 1
a1650 1
  return XGetVisualInfo(((struct glx_vars *)dmp->dmr_vars)->dpy,
@


1.5
log
@more pruning
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-glx.c,v 1.4 1996/09/26 20:37:27 bparker Exp bparker $ (BRL)";
a97 4
#ifdef IR_KNOBS
int Glx_irlimit();			/* provides knob dead spot */
int Glx_add_tol();
#endif
d288 2
a289 1
  ((struct glx_vars *)dmp->dmr_vars)->xtkwin = Tk_CreateWindowFromPath(interp, tkwin, bu_vls_addr(&dmp->dmr_pathName), dmp->dmr_dname);
d304 8
a311 3
  ((struct glx_vars *)dmp->dmr_vars)->dpy = Tk_Display(((struct glx_vars *)dmp->dmr_vars)->xtkwin);
  ((struct glx_vars *)dmp->dmr_vars)->width = DisplayWidth(((struct glx_vars *)dmp->dmr_vars)->dpy, DefaultScreen(((struct glx_vars *)dmp->dmr_vars)->dpy)) - 20;
  ((struct glx_vars *)dmp->dmr_vars)->height = DisplayHeight(((struct glx_vars *)dmp->dmr_vars)->dpy, DefaultScreen(((struct glx_vars *)dmp->dmr_vars)->dpy)) - 20;
d319 3
a321 1
  Tk_GeometryRequest(((struct glx_vars *)dmp->dmr_vars)->xtkwin, ((struct glx_vars *)dmp->dmr_vars)->width, ((struct glx_vars *)dmp->dmr_vars)->height);
d324 3
a326 1
  glx_config = GLXgetconfig(((struct glx_vars *)dmp->dmr_vars)->dpy, Tk_ScreenNumber(((struct glx_vars *)dmp->dmr_vars)->xtkwin), glx_config_wish_list);
d330 6
a335 2
  ((struct glx_vars *)dmp->dmr_vars)->cmap = extract_value(GLX_NORMAL, GLX_COLORMAP, glx_config);
  Tk_SetWindowVisual(((struct glx_vars *)dmp->dmr_vars)->xtkwin, ((struct glx_vars *)dmp->dmr_vars)->vis, ((struct glx_vars *)dmp->dmr_vars)->depth, ((struct glx_vars *)dmp->dmr_vars)->cmap);
d338 2
a339 1
  ((struct glx_vars *)dmp->dmr_vars)->win = Tk_WindowId(((struct glx_vars *)dmp->dmr_vars)->xtkwin);
d346 2
a347 1
  GLXwinset(((struct glx_vars *)dmp->dmr_vars)->dpy, ((struct glx_vars *)dmp->dmr_vars)->win);
d432 2
a433 1
  olist = list = (XDeviceInfoPtr) XListInputDevices (((struct glx_vars *)dmp->dmr_vars)->dpy, &ndevices);
d442 2
a443 1
	if((dev = XOpenDevice(((struct glx_vars *)dmp->dmr_vars)->dpy, list->id)) == (XDevice *)NULL){
d454 2
a455 1
	    DeviceButtonPress(dev, ((struct glx_vars *)dmp->dmr_vars)->devbuttonpress, e_class[nclass]);
d457 2
a458 1
	    DeviceButtonRelease(dev, ((struct glx_vars *)dmp->dmr_vars)->devbuttonrelease, e_class[nclass]);
d464 2
a465 1
	    DeviceMotionNotify(dev, ((struct glx_vars *)dmp->dmr_vars)->devmotionnotify, e_class[nclass]);
d474 2
a475 1
	XSelectExtensionEvent(((struct glx_vars *)dmp->dmr_vars)->dpy, ((struct glx_vars *)dmp->dmr_vars)->win, e_class, nclass);
d515 2
a516 1
  XGetWindowAttributes( ((struct glx_vars *)dmp->dmr_vars)->dpy, ((struct glx_vars *)dmp->dmr_vars)->win, &xwa );
d521 2
a522 1
  viewport(0, ((struct glx_vars *)dmp->dmr_vars)->width, 0, ((struct glx_vars *)dmp->dmr_vars)->height);
d539 3
a541 1
  ((struct glx_vars *)dmp->dmr_vars)->aspect = (fastf_t)((struct glx_vars *)dmp->dmr_vars)->height/(fastf_t)((struct glx_vars *)dmp->dmr_vars)->width;
d597 2
a598 1
  GLXwinset(((struct glx_vars *)dmp->dmr_vars)->dpy, ((struct glx_vars *)dmp->dmr_vars)->win);
d994 1
a994 1
	register int nvec;
d996 2
a997 2
	if (((struct glx_vars *)dmp->dmr_vars)->mvars.debug)
	  Tcl_AppendResult(interp, "Glx_2d_line()\n", (char *)NULL);
d999 18
a1016 17
	if( ((struct glx_vars *)dmp->dmr_vars)->mvars.rgb )  {
		/* Yellow */
		if(((struct glx_vars *)dmp->dmr_vars)->mvars.cueing_on)  {
			lRGBrange(
			    255, 255, 0,
			    255, 255, 0,
			    ((struct glx_vars *)dmp->dmr_vars)->mvars.min_scr_z, ((struct glx_vars *)dmp->dmr_vars)->mvars.max_scr_z );
		}
		RGBcolor( (short)255, (short)255, (short) 0 );
	} else {
		if((nvec = MAP_ENTRY(DM_YELLOW)) != ovec) {
			if(((struct glx_vars *)dmp->dmr_vars)->mvars.cueing_on) lshaderange(nvec, nvec,
			    ((struct glx_vars *)dmp->dmr_vars)->mvars.min_scr_z, ((struct glx_vars *)dmp->dmr_vars)->mvars.max_scr_z );
			color( nvec );
			ovec = nvec;
		}
	}
d1018 2
a1019 2
	if( dashed )
		setlinestyle(1);	/* into dot-dash */
d1021 2
a1022 2
	move2( GED2IRIS(x1), GED2IRIS(y1));
	draw2( GED2IRIS(x2), GED2IRIS(y2));
d1024 2
a1025 2
	if( dashed )
		setlinestyle(0);	/* restore to solid */
d1188 3
a1190 1
	((struct glx_vars *)dmp->dmr_vars)->rgbtab[4].r = ((struct glx_vars *)dmp->dmr_vars)->rgbtab[4].g = ((struct glx_vars *)dmp->dmr_vars)->rgbtab[4].b = 255; /* White */
d1206 2
a1207 1
	if(((struct glx_vars *)dmp->dmr_vars)->mvars.cueing_on && (((struct glx_vars *)dmp->dmr_vars)->nslots < 7)) {
d1211 4
a1214 2
	((struct glx_vars *)dmp->dmr_vars)->nslots = 1<<((struct glx_vars *)dmp->dmr_vars)->nslots;
	if( ((struct glx_vars *)dmp->dmr_vars)->nslots > NSLOTS )  ((struct glx_vars *)dmp->dmr_vars)->nslots = NSLOTS;
d1216 4
a1219 3
		/* peel off reserved ones */
		((struct glx_vars *)dmp->dmr_vars)->nslots = (((struct glx_vars *)dmp->dmr_vars)->nslots - CMAP_BASE) / CMAP_RAMP_WIDTH;
		depthcue(1);
d1221 2
a1222 2
		((struct glx_vars *)dmp->dmr_vars)->nslots -= CMAP_BASE;	/* peel off the reserved entries */
		depthcue(0);
d1231 3
a1233 1
	  Glx_gen_color( i, ((struct glx_vars *)dmp->dmr_vars)->rgbtab[i].r, ((struct glx_vars *)dmp->dmr_vars)->rgbtab[i].g, ((struct glx_vars *)dmp->dmr_vars)->rgbtab[i].b);
d1272 8
a1279 7
		if( ((struct glx_vars *)dmp->dmr_vars)->uslots < ((struct glx_vars *)dmp->dmr_vars)->nslots )  {
			rgb = &((struct glx_vars *)dmp->dmr_vars)->rgbtab[i=(((struct glx_vars *)dmp->dmr_vars)->uslots++)];
			rgb->r = r;
			rgb->g = g;
			rgb->b = b;
			sp->s_dmindex = i;
			continue;
a1287 31
#if IR_KNOBS
/*
 *			I R L I M I T
 *
 * Because the dials are so sensitive, setting them exactly to
 * zero is very difficult.  This function can be used to extend the
 * location of "zero" into "the dead zone".
 */
int
Glx_irlimit(i)
int i;
{
	if( i > NOISE )
		return( i-NOISE );
	if( i < -NOISE )
		return( i+NOISE );
	return(0);
}

int
Glx_add_tol(i)
int i;
{
  if( i > 0 )
    return( i + NOISE );
  if( i < 0 )
    return( i - NOISE );
  return(0);
}
#endif

d1354 3
a1356 1
    ((struct glx_vars *)dmp->dmr_vars)->perspective_angle = ((struct glx_vars *)dmp->dmr_vars)->mvars.dummy_perspective <= 4 ? ((struct glx_vars *)dmp->dmr_vars)->mvars.dummy_perspective - 1: 3;
d1394 2
a1395 1
	  lsetdepth(((struct glx_vars *)dmp->dmr_vars)->mvars.min_scr_z, ((struct glx_vars *)dmp->dmr_vars)->mvars.max_scr_z);
d1915 2
a1916 1
  return XGetVisualInfo(((struct glx_vars *)dmp->dmr_vars)->dpy, VisualScreenMask|VisualIDMask, &template, &n);
@


1.4
log
@changed parameters to dmr_object
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-glx.c,v 1.3 1996/09/25 20:28:29 bparker Exp bparker $ (BRL)";
a172 1
  0,			/* multi-window */
a178 2
  0,
  0,
a217 14
#ifdef DM_OGL
  /* This is a hack to handle the fact that the sgi attach crashes
   * if a direct OpenGL context has been previously opened in the 
   * current mged session. This stops the attach before it crashes.
   */
  if (ogl_ogl_used){
    Tcl_AppendResult(interp, "Can't attach sgi, because a direct OpenGL context has\n",
		     "previously been opened in this session. To use sgi,\n",
		     "quit this session and reopen it.\n", (char *)NULL);
    return TCL_ERROR;
  }
  ogl_sgi_used = 1;
#endif /* DM_OGL */

d238 1
a238 1
    Tk_CreateGenericHandler(dmp->dmr_eventhandler, (ClientData)NULL);
d242 14
d560 1
a560 1
    Tk_DeleteGenericHandler(dmp->dmr_eventhandler, (ClientData)NULL);
a1175 3
		/* apply region-id based colors to the solid table */
		dmp->dmr_cfunc();

a1196 3
	/* apply region-id based colors to the solid table */
	dmp->dmr_cfunc();

d1219 1
d1252 1
@


1.3
log
@now using more generalized solid macros
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-glx.c,v 1.2 1996/09/23 17:43:56 bparker Exp bparker $ (BRL)";
a112 1
static int Glx_setup();
d219 22
d254 5
a278 21
#ifdef DM_OGL
  /* This is a hack to handle the fact that the sgi attach crashes
   * if a direct OpenGL context has been previously opened in the 
   * current mged session. This stops the attach before it crashes.
   */
  if (ogl_ogl_used){
    Tcl_AppendResult(interp, "Can't attach sgi, because a direct OpenGL context has\n",
		     "previously been opened in this session. To use sgi,\n",
		     "quit this session and reopen it.\n", (char *)NULL);
    return TCL_ERROR;
  }
  ogl_sgi_used = 1;
#endif /* DM_OGL */

  return Glx_setup(dmp);
}

static int
Glx_setup(dmp)
struct dm *dmp;
{
a279 1
  static int count = 0;
a294 10
  /* Only need to do this once for this display manager */
  if(!count)
    Glx_load_startup(dmp);

  if(BU_LIST_IS_EMPTY(&head_glx_vars.l))
    Tk_CreateGenericHandler(dmp->dmr_eventhandler, (ClientData)NULL);

  BU_LIST_APPEND(&head_glx_vars.l, &((struct glx_vars *)dmp->dmr_vars)->l);

  bu_vls_printf(&dmp->dmr_pathName, ".dm_glx%d", count++);
d552 2
a553 1
    GLXunlink(((struct glx_vars *)dmp->dmr_vars)->dpy, ((struct glx_vars *)dmp->dmr_vars)->win);
a556 5
#if 0
  if(dmp->dmr_app_close)
    dmp->dmr_app_close(((struct glx_vars *)dmp->dmr_vars)->app_vars);
#endif

d760 1
a760 1
Glx_object( dmp, sp, m, ratio, white )
d762 6
a767 4
register struct solid *sp;
fastf_t		*m;
double		ratio;
int		white;
d769 1
a769 1
	register struct rt_vlist	*vp;
d797 1
a797 1
	if (sp->s_soldash)
d801 3
a803 37
		register short	r, g, b;
		if( white )  {
			r = g = b = 230;
		} else {
			r = (short)sp->s_color[0];
			g = (short)sp->s_color[1];
			b = (short)sp->s_color[2];
		}
		if(((struct glx_vars *)dmp->dmr_vars)->mvars.cueing_on)  {
			lRGBrange(
			    r/10, g/10, b/10,
			    r, g, b,
			    ((struct glx_vars *)dmp->dmr_vars)->mvars.min_scr_z, ((struct glx_vars *)dmp->dmr_vars)->mvars.max_scr_z );
		} else
		if(((struct glx_vars *)dmp->dmr_vars)->mvars.lighting_on && ((struct glx_vars *)dmp->dmr_vars)->is_gt)
		{
			/* Ambient = .2, Diffuse = .6, Specular = .2 */

			/* Ambient */
			material_objdef[3] = 	.2 * ( r / 255.0);
			material_objdef[4] = 	.2 * ( g / 255.0);
			material_objdef[5] = 	.2 * ( b / 255.0);

			/* diffuse */
			material_objdef[7] = 	.6 * ( r / 255.0);
			material_objdef[8] = 	.6 * ( g / 255.0);
			material_objdef[9] = 	.6 * ( b / 255.0);

			/* Specular */
			material_objdef[11] = 	.2 * ( r / 255.0);
			material_objdef[12] = 	.2 * ( g / 255.0);
			material_objdef[13] = 	.2 * ( b / 255.0);

			lmdef(DEFMATERIAL, 21, 0, material_objdef);
			lmbind(MATERIAL, 21);

		} else
d805 27
a831 1
			RGBcolor( r, g, b );
d833 25
a857 23
		if( white ) {
			ovec = nvec = MAP_ENTRY(DM_WHITE);
			/* Use the *next* to the brightest white entry */
			if(((struct glx_vars *)dmp->dmr_vars)->mvars.cueing_on)  {
				lshaderange(nvec+1, nvec+1,
				    ((struct glx_vars *)dmp->dmr_vars)->mvars.min_scr_z, ((struct glx_vars *)dmp->dmr_vars)->mvars.max_scr_z );
			}
			color( nvec );
		} else {
			if( (nvec = MAP_ENTRY( sp->s_dmindex )) != ovec) {
				/* Use only the middle 14 to allow for roundoff...
				 * Pity the poor fool who has defined a black object.
				 * The code will use the "reserved" color map entries
				 * to display it when in depthcued mode.
				 */
				if(((struct glx_vars *)dmp->dmr_vars)->mvars.cueing_on)  {
					lshaderange(nvec+1, nvec+14,
					    ((struct glx_vars *)dmp->dmr_vars)->mvars.min_scr_z, ((struct glx_vars *)dmp->dmr_vars)->mvars.max_scr_z );
				}
				color( nvec );
				ovec = nvec;
			}
		}
d862 1
a862 1
	for( BU_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
d864 3
a866 3
		register int	nused = vp->nused;
		register int	*cmd = vp->cmd;
		register point_t *pt = vp->pt;
d915 1
a915 1
	if (sp->s_soldash)
@


1.2
log
@changed _dm.h to dm.h,
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/libdm/RCS/dm-glx.c,v 1.1 1996/09/17 21:25:19 bparker Exp bparker $ (BRL)";
d77 1
a78 4
/*XXX This is just temporary!!! */
#include "../mged/solid.h"
#include "../mged/sedit.h"

d180 3
d215 1
a215 1
Glx_init(dmp, color_func)
d217 2
a218 1
void (*color_func)();
d220 1
a220 2
  dmp->dmr_vars = bu_malloc(sizeof(struct glx_vars), "Glx_init: struct glx_vars");
  bzero((void *)dmp->dmr_vars, sizeof(struct glx_vars));
a224 1
  ((struct glx_vars *)dmp->dmr_vars)->color_func = color_func;
d1194 1
a1194 1
		((struct glx_vars *)dmp->dmr_vars)->color_func();
d1218 1
a1218 1
	((struct glx_vars *)dmp->dmr_vars)->color_func();
d1242 1
a1242 1
	FOR_ALL_SOLIDS( sp )  {
@


1.1
log
@Initial revision
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.30 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d71 1
d75 1
a75 2
#include "externs.h"
#include "_dm.h"
d87 2
a253 1
#if 0
d259 1
a259 1
  if (Glx_Glx_used){
d265 1
a265 1
  Glx_sgi_used = 1;
a266 1
#endif
a541 5
#if 0
  if(Glx_Glx_used)
    return;
#endif

@
