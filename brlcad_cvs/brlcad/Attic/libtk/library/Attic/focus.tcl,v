head	1.3;
access;
symbols
	rel-5-2:1.2
	rel-5-1-patches:1.2.0.2
	rel-5-1:1.2
	rel-5-0:1.1
	rel-5-0beta:1.1;
locks; strict;
comment	@# @;


1.3
date	2000.12.06.21.21.33;	author bparker;	state dead;
branches;
next	1.2;

1.2
date	99.10.19.20.02.38;	author jra;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	98.06.02.19.49.00;	author jra;	state Exp;
branches;
next	;

1.2.2.1
date	2000.12.06.21.26.44;	author bparker;	state dead;
branches;
next	;


desc
@Original
@


1.3
log
@Upgrading to newer version
@
text
@# focus.tcl --
#
# This file defines several procedures for managing the input
# focus.
#
# RCS: @@(#) $Id: focus.tcl,v 1.2 1999/10/19 20:02:38 jra Exp $
#
# Copyright (c) 1994-1995 Sun Microsystems, Inc.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#

# tk_focusNext --
# This procedure returns the name of the next window after "w" in
# "focus order" (the window that should receive the focus next if
# Tab is typed in w).  "Next" is defined by a pre-order search
# of a top-level and its non-top-level descendants, with the stacking
# order determining the order of siblings.  The "-takefocus" options
# on windows determine whether or not they should be skipped.
#
# Arguments:
# w -		Name of a window.

proc tk_focusNext w {
    set cur $w
    while 1 {

	# Descend to just before the first child of the current widget.

	set parent $cur
	set children [winfo children $cur]
	set i -1

	# Look for the next sibling that isn't a top-level.

	while 1 {
	    incr i
	    if {$i < [llength $children]} {
		set cur [lindex $children $i]
              if {![string compare [winfo toplevel $cur] $cur]} {
		    continue
		} else {
		    break
		}
	    }

	    # No more siblings, so go to the current widget's parent.
	    # If it's a top-level, break out of the loop, otherwise
	    # look for its next sibling.

	    set cur $parent
          if {![string compare [winfo toplevel $cur] $cur]} {
		break
	    }
	    set parent [winfo parent $parent]
	    set children [winfo children $parent]
	    set i [lsearch -exact $children $cur]
	}
      if {![string compare $w $cur] || [tkFocusOK $cur]} {
	    return $cur
	}
    }
}

# tk_focusPrev --
# This procedure returns the name of the previous window before "w" in
# "focus order" (the window that should receive the focus next if
# Shift-Tab is typed in w).  "Next" is defined by a pre-order search
# of a top-level and its non-top-level descendants, with the stacking
# order determining the order of siblings.  The "-takefocus" options
# on windows determine whether or not they should be skipped.
#
# Arguments:
# w -		Name of a window.

proc tk_focusPrev w {
    set cur $w
    while 1 {

	# Collect information about the current window's position
	# among its siblings.  Also, if the window is a top-level,
	# then reposition to just after the last child of the window.

      if {![string compare [winfo toplevel $cur] $cur]}  {
	    set parent $cur
	    set children [winfo children $cur]
	    set i [llength $children]
	} else {
	    set parent [winfo parent $cur]
	    set children [winfo children $parent]
	    set i [lsearch -exact $children $cur]
	}

	# Go to the previous sibling, then descend to its last descendant
	# (highest in stacking order.  While doing this, ignore top-levels
	# and their descendants.  When we run out of descendants, go up
	# one level to the parent.

	while {$i > 0} {
	    incr i -1
	    set cur [lindex $children $i]
          if {![string compare [winfo toplevel $cur] $cur]} {
		continue
	    }
	    set parent $cur
	    set children [winfo children $parent]
	    set i [llength $children]
	}
	set cur $parent
      if {![string compare $w $cur] || [tkFocusOK $cur]} {
	    return $cur
	}
    }
}

# tkFocusOK --
#
# This procedure is invoked to decide whether or not to focus on
# a given window.  It returns 1 if it's OK to focus on the window,
# 0 if it's not OK.  The code first checks whether the window is
# viewable.  If not, then it never focuses on the window.  Then it
# checks the -takefocus option for the window and uses it if it's
# set.  If there's no -takefocus option, the procedure checks to
# see if (a) the widget isn't disabled, and (b) it has some key
# bindings.  If all of these are true, then 1 is returned.
#
# Arguments:
# w -		Name of a window.

proc tkFocusOK w {
    set code [catch {$w cget -takefocus} value]
    if {($code == 0) && [string compare $value ""]} {
	if {$value == 0} {
	    return 0
	} elseif {$value == 1} {
	    return [winfo viewable $w]
	} else {
	    set value [uplevel #0 $value $w]
          if {[string compare $value ""]} {
		return $value
	    }
	}
    }
    if {![winfo viewable $w]} {
	return 0
    }
    set code [catch {$w cget -state} value]
    if {($code == 0) && ![string compare $value "disabled"]} {
	return 0
    }
    regexp Key|Focus "[bind $w] [bind [winfo class $w]]"
}

# tk_focusFollowsMouse --
#
# If this procedure is invoked, Tk will enter "focus-follows-mouse"
# mode, where the focus is always on whatever window contains the
# mouse.  If this procedure isn't invoked, then the user typically
# has to click on a window to give it the focus.
#
# Arguments:
# None.

proc tk_focusFollowsMouse {} {
    set old [bind all <Enter>]
    set script {
      if {![string compare "%d" "NotifyAncestor"]
              || ![string compare "%d" "NotifyNonlinear"]
              || ![string compare "%d" "NotifyInferior"]} {
          if {[tkFocusOK %W]} {
              focus %W
          }
	}
    }
    if {[string compare $old ""]} {
	bind all <Enter> "$old; $script"
    } else {
	bind all <Enter> $script
    }
}
@


1.2
log
@tk 8.2.1 update
@
text
@d6 1
a6 1
# RCS: @@(#) $Id: focus.tcl,v 1.4 1999/04/16 01:51:26 stanton Exp $
@


1.2.2.1
log
@Upgrading to newer version
@
text
@d6 1
a6 1
# RCS: @@(#) $Id: focus.tcl,v 1.2 1999/10/19 20:02:38 jra Exp $
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
# SCCS: @@(#) focus.tcl 1.17 96/02/16 10:48:21
d41 1
a41 1
		if {[winfo toplevel $cur] == $cur} {
d53 1
a53 1
	    if {[winfo toplevel $cur] == $cur} {
d60 1
a60 1
	if {($cur == $w) || [tkFocusOK $cur]} {
d84 2
a85 2
    
	if {[winfo toplevel $cur] == $cur}  {
d103 1
a103 1
	    if {[winfo toplevel $cur] == $cur} {
d111 1
a111 1
	if {($cur == $w) || [tkFocusOK $cur]} {
d133 1
a133 1
    if {($code == 0) && ($value != "")} {
d140 1
a140 1
	    if {$value != ""} {
d149 1
a149 1
    if {($code == 0) && ($value == "disabled")} {
d168 6
a173 5
	if {("%d" == "NotifyAncestor") || ("%d" == "NotifyNonlinear")
		|| ("%d" == "NotifyInferior")} {
	    if [tkFocusOK %W] {
		focus %W
	    }
d176 1
a176 1
    if {$old != ""} {
@

