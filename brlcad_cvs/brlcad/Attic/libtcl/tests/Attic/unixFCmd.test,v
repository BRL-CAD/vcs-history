head	1.3;
access;
symbols
	rel-5-2:1.2
	rel-5-1-patches:1.2.0.2
	rel-5-1:1.2
	rel-5-0:1.1
	rel-5-0beta:1.1;
locks; strict;
comment	@# @;


1.3
date	2000.12.06.21.20.41;	author bparker;	state dead;
branches;
next	1.2;

1.2
date	99.10.19.19.36.18;	author jra;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	98.06.02.19.42.05;	author jra;	state Exp;
branches;
next	;

1.2.2.1
date	2000.12.06.21.26.03;	author bparker;	state dead;
branches;
next	;


desc
@Original
@


1.3
log
@Upgrading to newer version
@
text
@# This file tests the tclUnixFCmd.c file.
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 1996 Sun Microsystems, Inc.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: unixFCmd.test,v 1.2 1999/10/19 19:36:18 jra Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import ::tcltest::*
}

# Several tests require need to match results against the unix username
set user {}
if {$tcl_platform(platform) == "unix"} {
    catch {set user [exec whoami]}
    if {$user == ""} {
	catch {regexp {^[^(]*\(([^)]*)\)} [exec id] dummy user}
    }
    if {$user == ""} {
	set user "root"
    }
}

proc openup {path} {
    testchmod 777 $path
    if {[file isdirectory $path]} {
	catch {
	    foreach p [glob [file join $path *]] {
		openup $p
	    }
	}
    }
}

proc cleanup {args} {
    foreach p ". $args" {
	set x ""
	catch {
	    set x [glob [file join $p tf*] [file join $p td*]]
	}
	foreach file $x {
	    if {[catch {file delete -force -- $file}]} {
		openup $file
		file delete -force -- $file
	    }
	}
    }
}

test unixFCmd-1.1 {TclpRenameFile: EACCES} {unixOnly notRoot} {
    cleanup
    file mkdir td1/td2/td3
    exec chmod 000 td1/td2
    set msg [list [catch {file rename td1/td2/td3 td2} msg] $msg]
    exec chmod 755 td1/td2
    set msg
} {1 {error renaming "td1/td2/td3": permission denied}}
test unixFCmd-1.2 {TclpRenameFile: EEXIST} {unixOnly notRoot} {
    cleanup
    file mkdir td1/td2
    file mkdir td2
    list [catch {file rename td2 td1} msg] $msg
} {1 {error renaming "td2" to "td1/td2": file already exists}}
test unixFCmd-1.3 {TclpRenameFile: EINVAL} {unixOnly notRoot} {
    cleanup
    file mkdir td1
    list [catch {file rename td1 td1} msg] $msg
} {1 {error renaming "td1" to "td1/td1": trying to rename a volume or move a directory into itself}}
test unixFCmd-1.4 {TclpRenameFile: EISDIR} {emptyTest unixOnly notRoot} {
    # can't make it happen
} {}
test unixFCmd-1.5 {TclpRenameFile: ENOENT} {unixOnly notRoot} {
    cleanup
    file mkdir td1
    list [catch {file rename td2 td1} msg] $msg
} {1 {error renaming "td2": no such file or directory}}
test unixFCmd-1.6 {TclpRenameFile: ENOTDIR} {emptyTest unixOnly notRoot} {
    # can't make it happen
} {}
test unixFCmd-1.7 {TclpRenameFile: EXDEV} {unixOnly notRoot} {
    cleanup
    file mkdir foo/bar
    file attr foo -perm 040555
    set catchResult [catch {file rename foo/bar /tmp} msg]
    set msg [lindex [split $msg :] end]
    catch {file delete /tmp/bar}
    catch {file attr foo -perm 040777}
    catch {file delete -force foo}
    list $catchResult $msg
} {1 { permission denied}}
test unixFCmd-1.8 {Checking EINTR Bug} {unixOnly notRoot nonPortable} {
    testalarm 
    after 2000
    list [testgotsig] [testgotsig]
} {1 0}
test unixFCmd-1.9 {Checking EINTR Bug} {unixOnly notRoot nonPortable} {
    cleanup
    set f [open tfalarm w]
    puts $f {
	after 2000
	puts "hello world"
	exit 0
    }
    close $f
    testalarm 
    set pipe [open "|[info nameofexecutable] tfalarm" r+]
    set line [read $pipe 1]
    catch {close $pipe}
    list $line [testgotsig]
} {h 1}
test unixFCmd-2.1 {TclpCopyFile: target exists: lstat(dst) == 0} \
	{unixOnly notRoot} {
    cleanup
    exec touch tf1
    exec touch tf2
    file copy -force tf1 tf2
} {}
test unixFCmd-2.2 {TclpCopyFile: src is symlink} {unixOnly notRoot} {
    cleanup
    exec ln -s tf1 tf2
    file copy tf2 tf3
    file type tf3
} {link}
test unixFCmd-2.3 {TclpCopyFile: src is block} {unixOnly notRoot} {
    cleanup
    set null "/dev/null"
    while {[file type $null] != "characterSpecial"} {
	set null [file join [file dirname $null] [file readlink $null]]
    }
    # file copy $null tf1
} {}
test unixFCmd-2.4 {TclpCopyFile: src is fifo} {unixOnly notRoot} {
    cleanup
    if [catch {exec mknod tf1 p}] {
	list 1
    } else {
	file copy tf1 tf2
	expr {"[file type tf1]" == "[file type tf2]"}
    }
} {1}
test unixFCmd-2.5 {TclpCopyFile: copy attributes} {unixOnly notRoot} {
    cleanup
    exec touch tf1
    exec chmod 472 tf1
    file copy tf1 tf2
    string range [exec ls -l tf2] 0 9
} {-r--rwx-w-}

test unixFCmd-3.1 {CopyFile not done} {emptyTest unixOnly notRoot} {
} {}

test unixFCmd-4.1 {TclpDeleteFile not done} {emptyTest unixOnly notRoot} {
} {}

test unixFCmd-5.1 {TclpCreateDirectory not done} {emptyTest unixOnly notRoot} {
} {}

test unixFCmd-6.1 {TclpCopyDirectory not done} {emptyTest unixOnly notRoot} {
} {}

test unixFCmd-7.1 {TclpRemoveDirectory not done} {emptyTest unixOnly notRoot} {
} {}

test unixFCmd-8.1 {TraverseUnixTree not done} {emptyTest unixOnly notRoot} {
} {}

test unixFCmd-9.1 {TraversalCopy not done} {emptyTest unixOnly notRoot} {
} {}

test unixFCmd-10.1 {TraversalDelete not done} {emptyTest unixOnly notRoot} {
} {}

test unixFCmd-11.1 {CopyFileAttrs not done} {emptyTest unixOnly notRoot} {
} {}

test unixFCmd-12.1 {GetGroupAttribute - file not found} {unixOnly notRoot} {
    catch {file delete -force -- foo.test}
    list [catch {file attributes foo.test -group} msg] $msg
} {1 {could not read "foo.test": no such file or directory}}
test unixFCmd-12.2 {GetGroupAttribute - file found} {unixOnly notRoot} {
    catch {file delete -force -- foo.test}
    close [open foo.test w]
    list [catch {file attributes foo.test -group}] [file delete -force -- foo.test]
} {0 {}}

test unixFCmd-13.1 {GetOwnerAttribute - file not found} {unixOnly notRoot} {
    catch {file delete -force -- foo.test}
    list [catch {file attributes foo.test -group} msg] $msg
} {1 {could not read "foo.test": no such file or directory}}
test unixFCmd-13.2 {GetOwnerAttribute} {unixOnly notRoot} {
    catch {file delete -force -- foo.test}
    close [open foo.test w]
    list [catch {file attributes foo.test -owner} msg] \
	    [string compare $msg $user] [file delete -force -- foo.test]
} {0 0 {}}

test unixFCmd-14.1 {GetPermissionsAttribute - file not found} {unixOnly notRoot} {
    catch {file delete -force -- foo.test}
    list [catch {file attributes foo.test -permissions} msg] $msg
} {1 {could not read "foo.test": no such file or directory}}
test unixFCmd-14.2 {GetPermissionsAttribute} {unixOnly notRoot} {
    catch {file delete -force -- foo.test}
    close [open foo.test w]
    list [catch {file attribute foo.test -permissions}] \
	    [file delete -force -- foo.test]
} {0 {}}

# Find a group that exists on this system, or else skip tests that require
# groups
set ::tcltest::testConstraints(foundGroup) 0
catch {
    set groupList [exec groups]
    set group [lindex $groupList 0]
    set ::tcltest::testConstraints(foundGroup) 1
}

#groups hard to test
test unixFCmd-15.1 {SetGroupAttribute - invalid group} {unixOnly notRoot} {
    catch {file delete -force -- foo.test}
    list [catch {file attributes foo.test -group foozzz} msg] \
	    $msg [file delete -force -- foo.test]
} {1 {could not set group for file "foo.test": group "foozzz" does not exist} {}}
test unixFCmd-15.2 {SetGroupAttribute - invalid file} \
	{unixOnly notRoot foundGroup} {
    catch {file delete -force -- foo.test}
    list [catch {file attributes foo.test -group $group} msg] $msg
} {1 {could not set group for file "foo.test": no such file or directory}}

#changing owners hard to do
test unixFCmd-16.1 {SetOwnerAttribute - current owner} {unixOnly notRoot} {
    catch {file delete -force -- foo.test}
    close [open foo.test w]
    list [catch {file attributes foo.test -owner $user} msg] \
	    $msg [string compare [file attributes foo.test -owner] $user] \
	    [file delete -force -- foo.test]
} {0 {} 0 {}}
test unixFCmd-16.2 {SetOwnerAttribute - invalid file} {unixOnly notRoot} {
    catch {file delete -force -- foo.test}
    list [catch {file attributes foo.test -owner $user} msg] $msg
} {1 {could not set owner for file "foo.test": no such file or directory}}
test unixFCmd-16.3 {SetOwnerAttribute - invalid owner} {unixOnly notRoot} {
    catch {file delete -force -- foo.test}
    list [catch {file attributes foo.test -owner foozzz} msg] $msg
} {1 {could not set owner for file "foo.test": user "foozzz" does not exist}}


test unixFCmd-17.1 {SetPermissionsAttribute} {unixOnly notRoot} {
    catch {file delete -force -- foo.test}
    close [open foo.test w]
    list [catch {file attributes foo.test -permissions 0000} msg] \
	    $msg [file attributes foo.test -permissions] \
	    [file delete -force -- foo.test]
} {0 {} 00000 {}}
test unixFCmd-17.2 {SetPermissionsAttribute} {unixOnly notRoot} {
    catch {file delete -force -- foo.test}
    list [catch {file attributes foo.test -permissions 0000} msg] $msg
} {1 {could not set permissions for file "foo.test": no such file or directory}}
test unixFCmd-17.3 {SetPermissionsAttribute} {unixOnly notRoot} {
    catch {file delete -force -- foo.test}
    close [open foo.test w]
    list [catch {file attributes foo.test -permissions foo} msg] $msg \
	    [file delete -force -- foo.test]
} {1 {expected integer but got "foo"} {}}
test unixFCmd-18.1 {Unix pwd} {nonPortable unixOnly notRoot} {
    # This test is nonportable because SunOS generates a weird error
    # message when the current directory isn't readable.
    set cd [pwd]
    set nd $cd/tstdir
    file mkdir $nd
    cd $nd
    exec chmod 000 $nd
    set r [list [catch {pwd} res] [string range $res 0 36]];
    cd $cd;
    exec chmod 755 $nd
    file delete $nd
    set r
} {1 {error getting working directory name:}}

# cleanup
cleanup
::tcltest::cleanupTests
return












@


1.2
log
@TCL 8.2.1 update
@
text
@d12 1
a12 1
# RCS: @@(#) $Id: unixFCmd.test,v 1.9 1999/07/01 17:36:20 jenn Exp $
@


1.2.2.1
log
@Upgrading to newer version
@
text
@d12 1
a12 1
# RCS: @@(#) $Id: unixFCmd.test,v 1.2 1999/10/19 19:36:18 jra Exp $
@


1.1
log
@Initial revision
@
text
@d12 1
a12 1
# SCCS: @@(#) unixFCmd.test 1.15 97/11/03 15:58:22
d14 3
a16 4
if {[string compare test [info procs test]] == 1} then {source defs}

if {$tcl_platform(platform) != "unix"} {
    return
d19 10
a28 4
if {$user == "root"} {
    puts "Skipping unixFCmd tests.  They depend on not being able to write to"
    puts "certain directories.  It would be too dangerous to run them as root."
    return
d57 1
a57 1
test unixFCmd-1.1 {TclpRenameFile: EACCES} {
d65 1
a65 1
test unixFCmd-1.2 {TclpRenameFile: EEXIST} {
d71 1
a71 1
test unixFCmd-1.3 {TclpRenameFile: EINVAL} {
d76 1
a76 1
test unixFCmd-1.4 {TclpRenameFile: EISDIR} {
d79 1
a79 1
test unixFCmd-1.5 {TclpRenameFile: ENOENT} {
d84 1
a84 1
test unixFCmd-1.6 {TclpRenameFile: ENOTDIR} {
d87 1
a87 1
test unixFCmd-1.7 {TclpRenameFile: EXDEV} {
d91 2
a92 3
    set msg [list [catch {file rename foo/bar /tmp} msg] $msg]
    set a1 {1 {can't unlink "foo/bar": permission denied}}
    set result [expr {$msg == $a1}]
d96 24
a119 4
    set result
} {1}

test unixFCmd-2.1 {TclpCopyFile: target exists: lstat(dst) == 0} {
d125 1
a125 1
test unixFCmd-2.2 {TclpCopyFile: src is symlink} {
d131 1
a131 1
test unixFCmd-2.3 {TclpCopyFile: src is block} {
d139 1
a139 1
test unixFCmd-2.4 {TclpCopyFile: src is fifo} {
d148 1
a148 1
test unixFCmd-2.5 {TclpCopyFile: copy attributes} {
d156 1
a156 1
test unixFCmd-3.1 {CopyFile not done} {
d159 1
a159 1
test unixFCmd-4.1 {TclpDeleteFile not done} {
d162 1
a162 1
test unixFCmd-5.1 {TclpCreateDirectory not done} {
d165 1
a165 1
test unixFCmd-6.1 {TclpCopyDirectory not done} {
d168 1
a168 1
test unixFCmd-7.1 {TclpRemoveDirectory not done} {
d171 1
a171 1
test unixFCmd-8.1 {TraverseUnixTree not done} {
d174 1
a174 1
test unixFCmd-9.1 {TraversalCopy not done} {
d177 1
a177 1
test unixFCmd-10.1 {TraversalDelete not done} {
d180 1
a180 1
test unixFCmd-11.1 {CopyFileAttrs not done} {
d183 1
a183 8
set testConfig(tclGroup) 0
if {[catch {exec {groups}} groupList] == 0} {
    if {[lsearch $groupList tcl] != -1} {
	set testConfig(tclGroup) 1
    }
}

test unixFCmd-12.1 {GetGroupAttribute - file not found} {
d186 2
a187 2
} {1 {could not stat file "foo.test": no such file or directory}}
test unixFCmd-12.2 {GetGroupAttribute - file found} {
d193 1
a193 1
test unixFCmd-13.1 {GetOwnerAttribute - file not found} {
d196 2
a197 2
} {1 {could not stat file "foo.test": no such file or directory}}
test unixFCmd-13.2 {GetOwnerAttribute} {
d200 2
a201 1
    list [catch {file attributes foo.test -owner} msg] [string compare $msg $user] [file delete -force -- foo.test]
d204 1
a204 1
test unixFCmd-14.1 {GetPermissionsAttribute - file not found} {
d207 2
a208 2
} {1 {could not stat file "foo.test": no such file or directory}}
test unixFCmd-14.2 {GetPermissionsAttribute} {
d211 2
a212 1
    list [catch {file attribute foo.test -permissions}] [file delete -force -- foo.test]
d215 9
d225 1
a225 1
test unixFCmd-15.1 {SetGroupAttribute - invalid group} {
d227 2
a228 1
    list [catch {file attributes foo.test -group foozzz} msg] $msg [file delete -force -- foo.test]
d230 2
a231 1
test unixFCmd-15.2 {SetGroupAttribute - invalid file} {tclGroup} {
d233 1
a233 1
    list [catch {file attributes foo.test -group tcl} msg] $msg
d237 1
a237 1
test unixFCmd-16.1 {SetOwnerAttribute - current owner} {
d240 3
a242 1
    list [catch {file attributes foo.test -owner $user} msg] $msg [string compare [file attributes foo.test -owner] $user] [file delete -force -- foo.test]
d244 1
a244 1
test unixFCmd-16.2 {SetOwnerAttribute - invalid file} {
d248 1
a248 1
test unixFCmd-16.3 {SetOwnerAttribute - invalid owner} {
d254 1
a254 1
test unixFCmd-17.1 {SetPermissionsAttribute} {
d257 3
a259 1
    list [catch {file attributes foo.test -permissions 0000} msg] $msg [file attributes foo.test -permissions] [file delete -force -- foo.test]
d261 1
a261 1
test unixFCmd-17.2 {SetPermissionsAttribute} {
d265 1
a265 1
test unixFCmd-17.3 {SetPermissionsAttribute} {
d268 2
a269 1
    list [catch {file attributes foo.test -permissions foo} msg] $msg [file delete -force -- foo.test]
d271 1
a271 1
test unixFCmd-18.1 {Unix pwd} {nonPortable} {
d286 1
d288 14
@

