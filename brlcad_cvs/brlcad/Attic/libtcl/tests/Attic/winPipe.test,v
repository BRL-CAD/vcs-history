head	1.3;
access;
symbols
	rel-5-2:1.2
	rel-5-1-patches:1.2.0.2
	rel-5-1:1.2
	rel-5-0:1.1
	rel-5-0beta:1.1;
locks; strict;
comment	@# @;


1.3
date	2000.12.06.21.20.43;	author bparker;	state dead;
branches;
next	1.2;

1.2
date	99.10.19.19.36.19;	author jra;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	98.06.02.19.42.05;	author jra;	state Exp;
branches;
next	;

1.2.2.1
date	2000.12.06.21.26.04;	author bparker;	state dead;
branches;
next	;


desc
@Original
@


1.3
log
@Upgrading to newer version
@
text
@# 
# winPipe.test --
#
# This file contains a collection of tests for tclWinPipe.c
#
# Sourcing this file into Tcl runs the tests and generates output for 
# errors.  No output means no errors were found.
#
# Copyright (c) 1996 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: winPipe.test,v 1.2 1999/10/19 19:36:19 jra Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import ::tcltest::*
}

set bindir [file join [pwd] [file dirname [info nameofexecutable]]]
set cat16 [file join  $bindir cat16.exe]
set cat32 [file join $bindir cat32.exe]

set ::tcltest::testConstraints(cat32) [file exists $cat32]
set ::tcltest::testConstraints(cat16) [file exists $cat16]

if {[catch {puts console1 ""}]} {
    set ::tcltest::testConstraints(AllocConsole) 1
} else {
    set ::tcltest::testConstraints(.console) 1
}

set big bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n
append big $big
append big $big	
append big $big
append big $big
append big $big
append big $big

set f [open "little" w] 
puts -nonewline $f "little"
close $f

set f [open "big" w]
puts -nonewline $f $big
close $f

proc contents {file} {
    set f [open $file r]
    set r [read $f]
    close $f
    set r
}

set f [open more w]
puts $f {
    while {[eof stdin] == 0} {
	puts -nonewline [read stdin]
    }
}
close $f

test winpipe-1.1 {32 bit comprehensive tests: from little file} {pcOnly stdio cat32} {
    exec $cat32 < little > stdout 2> stderr
    list [contents stdout] [contents stderr]
} {little stderr32}
test winpipe-1.2 {32 bit comprehensive tests: from big file} {pcOnly stdio cat32} {
    exec $cat32 < big > stdout 2> stderr
    list [contents stdout] [contents stderr]
} "{$big} stderr32"
test winpipe-1.3 {32 bit comprehensive tests: a little from pipe} {nt stdio cat32} {
    exec $::tcltest::tcltest more < little | $cat32 > stdout 2> stderr
    list [contents stdout] [contents stderr]
} {little stderr32}
test winpipe-1.4 {32 bit comprehensive tests: a lot from pipe} {nt stdio cat32} {
    exec $::tcltest::tcltest more < big | $cat32 > stdout 2> stderr
    list [contents stdout] [contents stderr]
} "{$big} stderr32"
test winpipe-1.5 {32 bit comprehensive tests: a lot from pipe} {95 stdio cat32} {
    exec command /c type big |& $cat32 > stdout 2> stderr
    list [contents stdout] [contents stderr]
} "{$big} stderr32"
test winpipe-1.6 {32 bit comprehensive tests: from console} \
	{pcOnly stdio cat32 AllocConsole} {
    # would block waiting for human input
} {}
test winpipe-1.7 {32 bit comprehensive tests: from NUL} {pcOnly stdio cat32} {
    exec $cat32 < nul > stdout 2> stderr
    list [contents stdout] [contents stderr]
} {{} stderr32}
test winpipe-1.8 {32 bit comprehensive tests: from socket} {pcOnly stdio cat32} {
    # doesn't work
} {}
test winpipe-1.9 {32 bit comprehensive tests: from nowhere} \
	{pcOnly stdio cat32 .console} {
    exec $cat32 > stdout 2> stderr
    list [contents stdout] [contents stderr]
} {{} stderr32}
test winpipe-1.10 {32 bit comprehensive tests: from file handle} \
	{pcOnly stdio cat32} {
    set f [open "little" r]
    exec $cat32 <@@$f > stdout 2> stderr
    close $f
    list [contents stdout] [contents stderr]
} {little stderr32}
test winpipe-1.11 {32 bit comprehensive tests: read from application} \
	{pcOnly stdio cat32} {
    set f [open "|$cat32 < little" r]
    gets $f line
    catch {close $f} msg
    list $line $msg
} {little stderr32}
test winpipe-1.12 {32 bit comprehensive tests: a little to file} \
	{pcOnly stdio cat32} {
    exec $cat32 < little > stdout 2> stderr
    list [contents stdout] [contents stderr]
} {little stderr32}
test winpipe-1.13 {32 bit comprehensive tests: a lot to file} \
	{pcOnly stdio cat32} {
    exec $cat32 < big > stdout 2> stderr
    list [contents stdout] [contents stderr]
} "{$big} stderr32"
test winpipe-1.14 {32 bit comprehensive tests: a little to pipe} \
	{pcOnly stdio cat32} {
    exec $cat32 < little | $::tcltest::tcltest more > stdout 2> stderr
    list [contents stdout] [contents stderr]
} {little stderr32}
test winpipe-1.15 {32 bit comprehensive tests: a lot to pipe} \
	{pcOnly stdio cat32} {
    exec $cat32 < big | $::tcltest::tcltest more > stdout 2> stderr
    list [contents stdout] [contents stderr]
} "{$big} stderr32"
test winpipe-1.16 {32 bit comprehensive tests: to console} {pcOnly stdio cat32} {
    catch {exec $cat32 << "You should see this\n" >@@stdout} msg
    set msg
} stderr32
test winpipe-1.17 {32 bit comprehensive tests: to NUL} {pcOnly stdio cat32} {
    # some apps hang when sending a large amount to NUL.  $cat32 isn't one.
    catch {exec $cat32 < big > nul} msg
    set msg
} stderr32
test winpipe-1.18 {32 bit comprehensive tests: to nowhere} \
	{pcOnly stdio cat32 .console} {
    exec $cat32 < big >&@@stdout 
} {}
test winpipe-1.19 {32 bit comprehensive tests: to file handle} {pcOnly stdio cat32} {
    set f1 [open "stdout" w]
    set f2 [open "stderr" w]
    exec $cat32 < little >@@$f1 2>@@$f2
    close $f1
    close $f2
    list [contents stdout] [contents stderr]
} {little stderr32}
test winpipe-1.20 {32 bit comprehensive tests: write to application} \
	{pcOnly stdio cat32} {
    set f [open "|$cat32 > stdout" w]
    puts -nonewline $f "foo"
    catch {close $f} msg
    list [contents stdout] $msg
} {foo stderr32}
test winpipe-1.21 {32 bit comprehensive tests: read/write application} \
	{pcOnly stdio cat32} {
    set f [open "|$cat32" r+]
    puts $f $big
    puts $f \032
    flush $f
    set r [read $f 64]
    catch {close $f}
    set r
} "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"
test winpipe-1.22 {Checking command.com for Win95/98 hanging} \
	{pcOnly stdio} {
    exec command.com /c dir /b
    set result 1
} 1

test winpipe-2.1 {16 bit comprehensive tests: from little file} {pcOnly stdio cat16} {
    exec $cat16 < little > stdout 2> stderr
    list [contents stdout] [contents stderr]
} "little stderr16"
test winpipe-2.2 {16 bit comprehensive tests: from big file} {pcOnly stdio cat16} {
    exec $cat16 < big > stdout 2> stderr
    list [contents stdout] [contents stderr] 
} "{$big} stderr16"
test winpipe-2.3 {16 bit comprehensive tests: a little from pipe} {pcOnly stdio cat16} {
    exec $::tcltest::tcltest more < little | $cat16 > stdout 2> stderr
    list [contents stdout] [contents stderr]
} {little stderr16}
test winpipe-2.4 {16 bit comprehensive tests: a lot from pipe} {nt stdio cat16} {
    exec $cat16 < big | $cat16 > stdout 2> stderr
    list [contents stdout] [contents stderr] 
} "{$big} stderr16stderr16"
test winpipe-2.5 {16 bit comprehensive tests: a lot from pipe} {95 stdio cat16} {
    exec $::tcltest::tcltest more < big | $cat16 > stdout 2> stderr
    list [contents stdout] [contents stderr] 
} "{$big} stderr16"
test winpipe-2.6 {16 bit comprehensive tests: from console} \
	{pcOnly stdio cat16 AllocConsole} {
    # would block waiting for human input
} {}		     
test winpipe-2.7 {16 bit comprehensive tests: from NUL} {nt stdio cat16} {
    exec $cat16 < nul > stdout 2> stderr
    list [contents stdout] [contents stderr]
} "{} stderr16"
test winpipe-2.8 {16 bit comprehensive tests: from socket} {pcOnly stdio cat16} {
    # doesn't work
} {}
test winpipe-2.9 {16 bit comprehensive tests: from nowhere} {pcOnly stdio cat16 .console} {
    exec $cat16 > stdout 2> stderr
    list [contents stdout] [contents stderr]
} "{} stderr16"
test winpipe-2.10 {16 bit comprehensive tests: from file handle} {pcOnly stdio cat16} {
    set f [open "little" r]
    exec $cat16 <@@$f > stdout 2> stderr
    close $f
    list [contents stdout] [contents stderr]
} "little stderr16"
test winpipe-2.11 {16 bit comprehensive tests: read from application} {pcOnly stdio cat16} {
    set f [open "|$cat16 < little" r]
    gets $f line
    catch {close $f} msg
    list $line $msg
} "little stderr16"
test winpipe-2.12 {16 bit comprehensive tests: a little to file} {pcOnly stdio cat16} {
    exec $cat16 < little > stdout 2> stderr
    list [contents stdout] [contents stderr]
} "little stderr16"
test winpipe-2.13 {16 bit comprehensive tests: a lot to file} {pcOnly stdio cat16} {
    exec $cat16 < big > stdout 2> stderr
    list [contents stdout] [contents stderr]
} "{$big} stderr16"
test winpipe-2.14 {16 bit comprehensive tests: a little to pipe} {pcOnly stdio cat16} {
    exec $cat16 < little | $::tcltest::tcltest more > stdout 2> stderr
    list [contents stdout] [contents stderr]
} {little stderr16}
test winpipe-2.15 {16 bit comprehensive tests: a lot to pipe} {pcOnly stdio cat16} {
    exec $cat16 < big | $::tcltest::tcltest more > stdout 2> stderr
    list [contents stdout] [contents stderr]
} "{$big} stderr16"
test winpipe-2.16 {16 bit comprehensive tests: to console} {pcOnly stdio cat16} {
    catch {exec $cat16 << "You should see this\n" >@@stdout} msg
    set msg
} [lindex stderr16 0]
test winpipe-2.17 {16 bit comprehensive tests: to NUL} {nt stdio cat16} {
    # some apps hang when sending a large amount to NUL.  cat16 isn't one.
    catch {exec $cat16 < big > nul} msg
    set msg
} stderr16
test winpipe-2.18 {16 bit comprehensive tests: to nowhere} {pcOnly stdio cat16 .console} {
    exec $cat16 < big >&@@stdout 
} {}
test winpipe-2.19 {16 bit comprehensive tests: to file handle} {pcOnly stdio cat16} {
    set f1 [open "stdout" w]
    set f2 [open "stderr" w]
    exec $cat16 < little >@@$f1 2>@@$f2
    close $f1
    close $f2
    list [contents stdout] [contents stderr]
} "little stderr16"
test winpipe-2.20 {16 bit comprehensive tests: write to application} {pcOnly stdio cat16} {
    set f [open "|$cat16 > stdout" w]
    puts -nonewline $f "foo"
    catch {close $f} msg
    list [contents stdout] $msg
} "foo stderr16"
test winpipe-2.21 {16 bit comprehensive tests: read/write application} {nt stdio cat16} {
    set f [open "|$cat16" r+]
    puts $f $big
    puts $f \032
    flush $f
    set r [read $f 64]
    catch {close $f}
    set r
} "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"
file delete more

test winpipe-4.1 {Tcl_WaitPid} {nt stdio} {
    proc readResults {f} {
	global x result
	if { [eof $f] } {
	    close $f
	    set x 1
	} else {
	    set line [read $f ]
	    set result "$result$line"
	}
    }

    set f [open "|$cat32 < big 2> stderr" r]
    fconfigure $f  -buffering none -blocking 0
    fileevent $f readable "readResults $f"
    set x 0
    set result ""
    vwait x
    list $result $x [contents stderr]
} "{$big} 1 stderr32"

close [open nothing w]

catch {set env_tmp $env(TMP)}
catch {set env_temp $env(TEMP)}

set env(TMP) c:/
set env(TEMP) c:/

test winpipe-5.1 {TclpCreateTempFile: cleanup temp files} {pcOnly stdio} {
    set x {}
    set existing [glob -nocomplain c:/tcl*.tmp]
    exec $::tcltest::tcltest < nothing 
    foreach p [glob -nocomplain c:/tcl*.tmp] {
	if {[lsearch $existing $p] == -1} {
	    lappend x $p
	}
    }
    set x
} {}
test winpipe-5.2 {TclpCreateTempFile: TMP and TEMP not defined} {pcOnly stdio} {
    set tmp $env(TMP)
    set temp $env(TEMP)
    unset env(TMP)
    unset env(TEMP)
    exec $::tcltest::tcltest < nothing
    set env(TMP) $tmp
    set env(TEMP) $temp
    set x {}
} {}
test winpipe-5.3 {TclpCreateTempFile: TMP specifies non-existent directory} \
	{pcOnly stdio} {
    set tmp $env(TMP)
    set env(TMP) snarky
    exec $::tcltest::tcltest < nothing
    set env(TMP) $tmp
    set x {}
} {}
test winpipe-5.4 {TclpCreateTempFile: TEMP specifies non-existent directory} \
	{pcOnly stdio} {
    set tmp $env(TMP)
    set temp $env(TEMP)
    unset env(TMP)
    set env(TEMP) snarky
    exec $::tcltest::tcltest < nothing
    set env(TMP) $tmp
    set env(TEMP) $temp
    set x {}
} {}

test winpipe-6.1 {PipeSetupProc & PipeCheckProc: read threads} \
	{pcOnly stdio cat32} {
    set f [open "|$cat32" r+]
    fconfigure $f -blocking 0
    fileevent $f writable { set x writable }
    set x {}
    vwait x
    fileevent $f writable {}
    fileevent $f readable { lappend x readable }
    after 100 { lappend x timeout }
    vwait x
    puts $f foobar
    flush $f
    vwait x
    lappend x [read $f]
    after 100 { lappend x timeout }
    vwait x
    lappend x [catch {close $f} msg] $msg
} {writable timeout readable {foobar
} timeout 1 stderr32}
test winpipe-6.2 {PipeSetupProc & PipeCheckProc: write threads} \
	{pcOnly stdio cat32} {
    set f [open "|$cat32" r+]
    fconfigure $f -blocking 0
    fileevent $f writable { set x writable }
    set x {}
    vwait x
    puts -nonewline $f $big$big$big$big
    flush $f
    after 100 { lappend x timeout }
    vwait x
    lappend x [catch {close $f} msg] $msg
} {writable timeout 0 {}}

makeFile {
    puts "[list $argv0 $argv]"
} echoArgs.tcl

test winpipe-7.1 {BuildCommandLine: null arguments} {pcOnly stdio} {
    exec $::tcltest::tcltest echoArgs.tcl foo "" bar
} {echoArgs.tcl {foo {} bar}}
test winpipe-7.2 {BuildCommandLine: null arguments} {pcOnly stdio} {
    exec $::tcltest::tcltest echoArgs.tcl foo \" bar
} {echoArgs.tcl {foo {"} bar}}

# restore old values for env(TMP) and env(TEMP)

if {[catch {set env(TMP) $env_tmp}]} {
    unset env(TMP)
}
if {[catch {set env(TEMP) $env_temp}]} {
    unset env(TEMP)
}

# cleanup
file delete big little stdout stderr nothing echoArgs.tcl
::tcltest::cleanupTests
return











@


1.2
log
@TCL 8.2.1 update
@
text
@d15 1
a15 1
# RCS: @@(#) $Id: winPipe.test,v 1.11 1999/07/01 17:36:20 jenn Exp $
@


1.2.2.1
log
@Upgrading to newer version
@
text
@d15 1
a15 1
# RCS: @@(#) $Id: winPipe.test,v 1.2 1999/10/19 19:36:19 jra Exp $
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1

d10 1
d15 1
a15 1
# SCCS: @@(#) winPipe.test 1.11 97/10/09 17:06:16
d17 3
a19 2
if {$tcl_platform(platform) != "windows"} {
    return
d22 3
a24 2
set cat16 [file join $tcl_library ../win/cat16.exe]
set cat32 [file join $tcl_library ../win/cat32.exe]
d26 2
a27 1
if {[string compare test [info procs test]] == 1} then {source defs}
d29 2
a30 2
if [catch {puts console1 ""}] {
    set testConfig(AllocConsole) 1
d32 1
a32 1
    set testConfig(.console) 1
d35 1
a35 1
set big aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n
d58 9
a66 2
if {$testConfig(stdio) && [file exists $cat32]} {
test winpipe-1.1 {32 bit comprehensive tests: from little file} {
d69 2
a70 2
} "little stderr32"
test winpipe-1.2 {32 bit comprehensive tests: from big file} {
d74 2
a75 2
test winpipe-1.3 {32 bit comprehensive tests: a little from pipe} {nt} {
    exec more < little | $cat32 > stdout 2> stderr
d77 3
a79 7
} "{little\n} stderr32"
test winpipe-1.4 {32 bit comprehensive tests: a little from pipe} {95} {
    exec more < little |& $cat32 > stdout 2> stderr
    list [contents stdout] [contents stderr]
} "{\nlittle} stderr32"
test winpipe-1.5 {32 bit comprehensive tests: a lot from pipe} {nt} {
    exec more < big | $cat32 > stdout 2> stderr
d82 1
a82 1
test winpipe-1.6 {32 bit comprehensive tests: a lot from pipe} {95} {
d86 2
a87 1
test winpipe-1.7 {32 bit comprehensive tests: from console} {AllocConsole} {
d90 1
a90 1
test winpipe-1.8 {32 bit comprehensive tests: from NUL} {
d93 2
a94 2
} "{} stderr32"
test winpipe-1.9 {32 bit comprehensive tests: from socket} {
d97 2
a98 1
test winpipe-1.10 {32 bit comprehensive tests: from nowhere} {.console} {
d101 3
a103 2
} "{} stderr32"
test winpipe-1.11 {32 bit comprehensive tests: from file handle} {
d108 3
a110 2
} "little stderr32"
test winpipe-1.12 {32 bit comprehensive tests: read from application} {
d115 3
a117 2
} "little stderr32"
test winpipe-1.13 {32 bit comprehensive tests: a little to file} {
d120 3
a122 2
} "little stderr32"
test winpipe-1.14 {32 bit comprehensive tests: a lot to file} {
d126 8
a133 2
test winpipe-1.15 {32 bit comprehensive tests: a little to pipe} {nt} {
    exec $cat32 < little | more > stdout 2> stderr
d135 2
a136 14
} "{little\n} stderr32"
test winpipe-1.16 {32 bit comprehensive tests: a little to pipe} {95} {
    exec $cat32 < little | more > stdout 2> stderr
    list [contents stdout] [contents stderr]
} "{\nlittle} stderr32"
test winpipe-1.17 {32 bit comprehensive tests: a lot to pipe} {nt} {
    exec $cat32 < big | more > stdout 2> stderr
    list [contents stdout] [contents stderr]
} "{$big\n} stderr32"
test winpipe-1.18 {32 bit comprehensive tests: a lot to pipe} {95} {
    exec $cat32 < big | more > stdout 2> stderr
    list [contents stdout] [contents stderr]
} "{\n$big} stderr32"
test winpipe-1.19 {32 bit comprehensive tests: to console} {
d140 1
a140 1
test winpipe-1.20 {32 bit comprehensive tests: to NUL} {
d145 2
a146 1
test winpipe-1.21 {32 bit comprehensive tests: to nowhere} {.console} {
d149 1
a149 1
test winpipe-1.22 {32 bit comprehensive tests: to file handle} {
d156 3
a158 2
} "little stderr32"
test winpipe-1.23 {32 bit comprehensive tests: write to application} {
d163 3
a165 2
} "foo stderr32"
test winpipe-1.24 {32 bit comprehensive tests: read/write application} {
d173 6
a178 2
} "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
}
d180 1
a180 6
set stderr16 "stderr16"
if {$tcl_platform(os) == "Win32s"} {
    set stderr16 "{}"
}
if [file exists $cat16] {
test winpipe-2.1 {16 bit comprehensive tests: from little file} {
d183 2
a184 2
} "little $stderr16"
test winpipe-2.2 {16 bit comprehensive tests: from big file} {
d187 3
a189 7
} "{$big} $stderr16"
test winpipe-2.3 {16 bit comprehensive tests: a little from pipe} {nt} {
    exec more < little | $cat16 > stdout 2> stderr
    list [contents stdout] [contents stderr]
} "{little\n} stderr16"
test winpipe-2.4 {16 bit comprehensive tests: a little from pipe} {95} {
    exec more < little | $cat16 > stdout 2> stderr
d191 2
a192 2
} "{\nlittle} stderr16"
test winpipe-2.5 {16 bit comprehensive tests: a lot from pipe} {nt} {
d196 2
a197 2
test winpipe-2.6 {16 bit comprehensive tests: a lot from pipe} {95} {
    exec more < big | $cat16 > stdout 2> stderr
d199 3
a201 2
} "{\n$big} stderr16"
test winpipe-2.7 {16 bit comprehensive tests: from console} {AllocConsole} {
d204 1
a204 1
test winpipe-2.8 {16 bit comprehensive tests: from NUL} {nt} {
d208 1
a208 1
test winpipe-2.9 {16 bit comprehensive tests: from socket} {
d211 1
a211 1
test winpipe-2.10 {16 bit comprehensive tests: from nowhere} {.console} {
d215 1
a215 1
test winpipe-2.11 {16 bit comprehensive tests: from file handle} {
d220 2
a221 2
} "little $stderr16"
test winpipe-2.12 {16 bit comprehensive tests: read from application} {
d226 2
a227 2
} "little $stderr16"
test winpipe-2.13 {16 bit comprehensive tests: a little to file} {
d230 2
a231 2
} "little $stderr16"
test winpipe-2.14 {16 bit comprehensive tests: a lot to file} {
d234 7
a240 15
} "{$big} $stderr16"
test winpipe-2.15 {16 bit comprehensive tests: a little to pipe} {nt} {
    catch {exec $cat16 < little | more > stdout 2> stderr}
    list [contents stdout] [contents stderr]
} "{little\n} stderr16"
test winpipe-2.16 {16 bit comprehensive tests: a little to pipe} {95} {
    exec $cat16 < little | more > stdout 2> stderr
    list [contents stdout] [contents stderr]
} "{\nlittle} stderr16"
test winpipe-2.17 {16 bit comprehensive tests: a lot to pipe} {nt} {
    catch {exec $cat16 < big | more > stdout 2> stderr}
    list [contents stdout] [contents stderr]
} "{$big\n} stderr16"
test winpipe-2.18 {16 bit comprehensive tests: a lot to pipe} {95} {
    exec $cat16 < big | more > stdout 2> stderr
d242 2
a243 2
} "{\n$big} stderr16"
test winpipe-2.19 {16 bit comprehensive tests: to console} {
d246 2
a247 2
} [lindex $stderr16 0]
test winpipe-2.20 {16 bit comprehensive tests: to NUL} {nt} {
d252 1
a252 1
test winpipe-2.21 {16 bit comprehensive tests: to nowhere} {.console} {
d255 1
a255 1
test winpipe-2.22 {16 bit comprehensive tests: to file handle} {
d262 2
a263 2
} "little $stderr16"
test winpipe-2.23 {16 bit comprehensive tests: write to application} {!win32s} {
d269 1
a269 1
test winpipe-2.24 {16 bit comprehensive tests: read/write application} {nt} {
d277 2
a278 2
} "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
}
d280 1
a280 1
test winpipe-3.1 {Tcl_WaitPid} {nt} {
d309 1
a309 1
test winpipe-3.1 {TclpCreateTempFile: cleanup temp files} {
d312 1
a312 1
    exec $tcltest < nothing 
d314 1
a314 1
	if {[lsearch $existing $p] != -1} {
d320 1
a320 1
test winpipe-3.2 {TclpCreateTempFile: TMP and TEMP not defined} {
d325 1
a325 1
    exec $tcltest < nothing
d330 2
a331 1
test winpipe-3.3 {TclpCreateTempFile: TMP specifies non-existent directory} {
d334 1
a334 1
    exec $tcltest < nothing
d338 2
a339 1
test winpipe-3.3 {TclpCreateTempFile: TEMP specifies non-existent directory} {
d344 1
a344 1
    exec $tcltest < nothing
d350 46
a395 1
# restore old values fro env(TMP) and env(TEMP)
d398 1
a398 1
    unset $env(TMP)
d401 1
a401 1
    unset $env(TEMP)
d404 15
a418 1
file delete big little stdout stderr nothing
@

