head	1.3;
access;
symbols
	rel-5-2:1.2
	rel-5-1-patches:1.2.0.2
	rel-5-1:1.2
	rel-5-0:1.1
	rel-5-0beta:1.1;
locks; strict;
comment	@# @;


1.3
date	2000.12.06.21.20.32;	author bparker;	state dead;
branches;
next	1.2;

1.2
date	99.10.19.19.36.11;	author jra;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	98.06.02.19.42.05;	author jra;	state Exp;
branches;
next	;

1.2.2.1
date	2000.12.06.21.25.56;	author bparker;	state dead;
branches;
next	;


desc
@Original
@


1.3
log
@Upgrading to newer version
@
text
@# Commands covered:  none (tests environment variable implementation)
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 1991-1993 The Regents of the University of California.
# Copyright (c) 1994 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: env.test,v 1.2 1999/10/19 19:36:11 jra Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import ::tcltest::*
}

#
# These tests will run on any platform (and indeed crashed
# on the Mac).  So put them before you test for the existance
# of exec.
#
test env-1.1 {propagation of env values to child interpreters} {
    catch {interp delete child}
    catch {unset env(test)}
    interp create child
    set env(test) garbage
    set return [child eval {set env(test)}]
    interp delete child
    unset env(test)
    set return
} {garbage}
#
# This one crashed on Solaris under Tcl8.0, so we only
# want to make sure it runs.
#
test env-1.2 {lappend to env value} {
    catch {unset env(test)}
    set env(test) aaaaaaaaaaaaaaaa
    append env(test) bbbbbbbbbbbbbb
    unset env(test)
} {}
test env-1.3 {reflection of env by "array names"} {
    catch {interp delete child}
    catch {unset env(test)}
    interp create child
    child eval {set env(test) garbage}
    set names [array names env]
    interp delete child
    set ix [lsearch $names test]
    catch {unset env(test)}
    expr {$ix >= 0}
} {1}


# Some tests require the "exec" command.
# Skip them if exec is not defined.
set ::tcltest::testConstraints(execCommandExists) [expr {[info commands exec] != ""}]

set f [open printenv w]
puts $f {
    proc lrem {listname name} {
	upvar $listname list
	set i [lsearch $list $name]
	if {$i >= 0} {
	    set list [lreplace $list $i $i]
	}
	return $list
    }
	
    set names [lsort [array names env]]
    if {$tcl_platform(platform) == "windows"} {
	lrem names HOME
        lrem names COMSPEC
	lrem names ComSpec
	lrem names ""
    }	
    foreach name {TCL_LIBRARY PATH LD_LIBRARY_PATH LIBPATH PURE_PROG_NAME DISPLAY SHLIB_PATH } {
	lrem names $name
    }
    foreach p $names {
	puts "$p=$env($p)"
    }
    exit
}
close $f
	
proc getenv {} {
    global printenv tcltest
    catch {exec $::tcltest::tcltest printenv} out
    if {$out == "child process exited abnormally"} {
	set out {}
    }
    return $out
}

# Save the current environment variables at the start of the test.

foreach name [array names env] {
    set env2($name) $env($name)
    unset env($name)
}

# Added the following lines so that child tcltest can actually find its
# library if the initial tcltest is run from a non-standard place.
# ('saved' env vars)
foreach name {TCL_LIBRARY PATH LD_LIBRARY_PATH LIBPATH DISPLAY SHLIB_PATH} {
  if {[info exists env2($name)]} {
     set env($name) $env2($name);
  }
}

test env-2.1 {adding environment variables} {execCommandExists} {
    getenv
} {}

set env(NAME1) "test string"
test env-2.2 {adding environment variables} {execCommandExists} {
    getenv
} {NAME1=test string}

set env(NAME2) "more"
test env-2.3 {adding environment variables} {execCommandExists} {
    getenv
} {NAME1=test string
NAME2=more}

set env(XYZZY) "garbage"
test env-2.4 {adding environment variables} {execCommandExists} {
    getenv
} {NAME1=test string
NAME2=more
XYZZY=garbage}

set env(NAME2) "new value"
test env-3.1 {changing environment variables} {execCommandExists} {
    set result [getenv]
    unset env(NAME2)
    set result
} {NAME1=test string
NAME2=new value
XYZZY=garbage}

test env-4.1 {unsetting environment variables} {execCommandExists} {
    set result [getenv]
    unset env(NAME1)
    set result
} {NAME1=test string
XYZZY=garbage}

test env-4.2 {unsetting environment variables} {execCommandExists} {
    set result [getenv]
    unset env(XYZZY)
    set result
} {XYZZY=garbage}

test env-4.3 {setting international environment variables} {execCommandExists} {
    set env(\ua7) \ub6
    getenv
} "\ua7=\ub6"
test env-4.4 {changing international environment variables} {execCommandExists} {
    set env(\ua7) \ua7
    getenv
} "\ua7=\ua7"
test env-4.5 {unsetting international environment variables} {execCommandExists} {
    set env(\ub6) \ua7
    unset env(\ua7)
    set result [getenv]
    unset env(\ub6)
    set result
} "\ub6=\ua7"

test env-5.0 {corner cases - set a value, it should exist} {} {
    set env(temp) a
    set result [set env(temp)]
    unset env(temp)
    set result
} {a}
test env-5.1 {corner cases - remove one elem at a time} {} {
    # When no environment variables exist, the env var will
    # contain no entries.  The "array names" call synchs up
    # the C-level environ array with the Tcl level env array.
    # Make sure an empty Tcl array is created.

    set x [array get env]
    foreach e [array names env] {
	unset env($e)
    }
    set result [catch {array names env}]
    array set env $x
    set result
} {0}
test env-5.2 {corner cases - unset the env array} {} {
    # Unsetting a variable in an interp detaches the C-level
    # traces from the Tcl "env" variable.

    interp create i 
    i eval { unset env }
    i eval { set env(THIS_SHOULDNT_EXIST) a}
    set result [info exist env(THIS_SHOULDNT_EXIST)]
    interp delete i
    set result
} {0}
test env-5.3 {corner cases - unset the env in master should unset child} {} {
    # Variables deleted in a master interp should be deleted in
    # child interp too.

    interp create i 
    i eval { set env(THIS_SHOULD_EXIST) a}
    set result [set env(THIS_SHOULD_EXIST)]
    unset env(THIS_SHOULD_EXIST)
    lappend result [i eval {catch {set env(THIS_SHOULD_EXIST)}}]
    interp delete i
    set result
} {a 1}
test env-5.4 {corner cases - unset the env array} {knownBug} {
    # The info exist command should be in synch with the env array.
    # Know Bug: 1737

    interp create i 
    i eval { set env(THIS_SHOULD_EXIST) a}
    set     result [info exists env(THIS_SHOULD_EXIST)]
    lappend result [set env(THIS_SHOULD_EXIST)]
    lappend result [info exists env(THIS_SHOULD_EXIST)]
    interp delete i
    set result
} {1 a 1}
test env-5.5 {corner cases - cannot have null entries on Windows} {pcOnly} {
    set env() a
    catch {set env()}
} {1}


# Restore the environment variables at the end of the test.

foreach name [array names env] {
    unset env($name)
}
foreach name [array names env2] {
    set env($name) $env2($name)
}

# cleanup
file delete printenv
::tcltest::cleanupTests
return












@


1.2
log
@TCL 8.2.1 update
@
text
@d14 1
a14 1
# RCS: @@(#) $Id: env.test,v 1.9.4.2 1999/09/22 21:06:15 jenn Exp $
@


1.2.2.1
log
@Upgrading to newer version
@
text
@d14 1
a14 1
# RCS: @@(#) $Id: env.test,v 1.2 1999/10/19 19:36:11 jra Exp $
@


1.1
log
@Initial revision
@
text
@d9 1
d14 1
a14 1
# SCCS: @@(#) env.test 1.14 97/10/31 17:00:03
d16 4
a19 1
if {[string compare test [info procs test]] == 1} then {source defs}
d45 17
a61 5
} {}    
if {[info commands exec] == ""} {
    puts "exec not implemented for this machine"
    return
}
a62 5
if {$tcl_platform(os) == "Win32s"} {
    puts "Cannot run multiple copies of tcl at the same time under Win32s"
    return
}
   
d81 1
a81 1
    foreach name {TCL_LIBRARY PATH LD_LIBRARY_PATH} {
d87 1
d93 1
a93 1
    catch {exec $tcltest printenv} out
d110 1
a110 1
foreach name {TCL_LIBRARY PATH LD_LIBRARY_PATH} {
d116 1
a116 1
test env-2.1 {adding environment variables} {
d121 1
a121 1
test env-2.2 {adding environment variables} {
d126 1
a126 1
test env-2.3 {adding environment variables} {
d132 1
a132 1
test env-2.4 {adding environment variables} {
d139 4
a142 2
test env-3.1 {changing environment variables} {
    getenv
d147 4
a150 3
unset env(NAME2)
test env-4.1 {unsetting environment variables} {
    getenv
d153 9
a161 2
unset env(NAME1)
test env-4.2 {unsetting environment variables} {
d163 73
a235 1
} {XYZZY=garbage}
d246 1
d248 14
@

