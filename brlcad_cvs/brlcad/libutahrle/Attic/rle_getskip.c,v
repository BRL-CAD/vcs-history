head	11.7;
access;
symbols
	ansi-20040405-merged:11.4.2.1
	postmerge-20040405-ansi:11.5
	premerge-20040404-ansi:11.4
	postmerge-autoconf:11.4
	autoconf-freeze:11.4
	premerge-autoconf:11.4
	postmerge-20040315-windows:11.4
	premerge-20040315-windows:11.4
	windows-20040315-freeze:11.4
	autoconf-20031203:11.4
	autoconf-20031202:11.4
	autoconf-branch:11.4.0.10
	phong-branch:11.4.0.8
	photonmap-branch:11.4.0.6
	rel-6-1-DP:11.4
	windows-branch:11.4.0.4
	rel-6-0-2:11.2
	ansi-branch:11.4.0.2
	rel-6-0-1-branch:11.2.0.2
	hartley-6-0-post:11.3
	hartley-6-0-pre:11.2
	rel-6-0-1:11.2
	rel-6-0:11.2
	rel-5-4:11.1
	offsite-5-3-pre:11.1
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.7
date	2004.05.21.17.59.45;	author morrison;	state dead;
branches;
next	11.6;

11.6
date	2004.05.10.15.30.47;	author erikg;	state Exp;
branches;
next	11.5;

11.5
date	2004.04.05.07.40.44;	author morrison;	state Exp;
branches;
next	11.4;

11.4
date	2002.08.20.17.08.18;	author jra;	state Exp;
branches
	11.4.2.1;
next	11.3;

11.3
date	2002.08.15.20.55.29;	author hartley;	state Exp;
branches;
next	11.2;

11.2
date	2001.04.12.14.12.29;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.05.18;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.08.10.23.20.22;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	92.04.08.14.13.18;	author butler;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.38.32;	author mike;	state Rel4_0;
branches;
next	1.2;

1.2
date	91.01.09.03.32.26;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	91.01.03.17.30.54;	author butler;	state Exp;
branches;
next	;

11.4.2.1
date	2002.09.19.18.01.56;	author morrison;	state Exp;
branches;
next	;


desc
@Dist 3.0 patchlevel 2 installation
@


11.7
log
@moved from top-level to src/other/.
@
text
@/*
 * This software is copyrighted as noted below.  It may be freely copied,
 * modified, and redistributed, provided that the copyright notice is 
 * preserved on all copies.
 * 
 * There is no warranty or other guarantee of fitness for this software,
 * it is provided solely "as is".  Bug reports or fixes may be sent
 * to the author, who may or may not act on them as he desires.
 *
 * You may not include this software in a program or other software product
 * without supplying the source, or without informing the end-user that the 
 * source is available for no extra charge.
 *
 * If you modify this software, you should include a notice giving the
 * name of the person performing the modification, the date of modification,
 * and the reason for such modification.
 */
/* 
 * rle_getskip.c - Skip scanlines on input.
 * 
 * Author:	Spencer W. Thomas
 * 		EECS Dept.
 * 		University of Michigan
 * Date:	Wed Jun 27 1990
 * Copyright (c) 1990, University of Michigan
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <stdlib.h>

#include "machine.h"

#include "rle.h"
#include "rle_code.h"

/* Read a two-byte "short" that started in VAX (LITTLE_ENDIAN) order */
#define VAXSHORT( var, fp )\
	{ var = fgetc(fp)&0xFF; var |= (fgetc(fp)) << 8; }
  
/* Instruction format -- first byte is opcode, second is datum. */

#define OPCODE(inst) (inst[0] & ~LONG)
#define LONGP(inst) (inst[0] & LONG)
#define DATUM(inst) (inst[1] & 0xff)	/* Make sure it's unsigned. */

/*****************************************************************
 * TAG( rle_getskip )
 * 
 * Skip the next scanline with data on it.
 * Most useful for skipping to end-of-image.
 * Inputs:
 * 	the_hdr:	Describes input image.
 * Outputs:
 * 	Returns the number of the next scanline.  At EOF returns 32768.
 * Assumptions:
 * 	rle_get_setup has been called.
 * Algorithm:
 * 	Read input to the beginning of the next scanline, or to EOF or
 * 	end of image.
 */
unsigned int
rle_getskip(rle_hdr *the_hdr)
{
    unsigned char inst[2];
    register FILE *infile = the_hdr->rle_file;
    int nc;

    /* Add in vertical skip from last scanline */
    if ( the_hdr->priv.get.vert_skip > 0) 
	the_hdr->priv.get.scan_y += the_hdr->priv.get.vert_skip;
    the_hdr->priv.get.vert_skip = 0;

    if ( the_hdr->priv.get.is_eof )
	return 32768;		/* too big for 16 bits, signal EOF */
    
    /* Otherwise, read and interpret instructions until a skipLines
     * instruction is encountered.
     */
    for (;;)
    {
    	register int code;

        inst[0] = getc( infile );
	inst[1] = getc( infile );
	if ( feof(infile) )
	{
	    the_hdr->priv.get.is_eof = 1;
	    break;		/* <--- one of the exits */
	}

    	code = OPCODE(inst);
	switch( code )
	{
	case RSkipLinesOp:
	    if ( LONGP(inst) )
	    {
		VAXSHORT( the_hdr->priv.get.vert_skip, infile );
	    }
	    else
		the_hdr->priv.get.vert_skip = DATUM(inst);
	    break;			/* need to break for() here, too */

	case RSetColorOp:
	    /* No-op here. */
	    break;

	case RSkipPixelsOp:
	    if ( LONGP(inst) )
	    {
		(void)getc( infile );
		(void)getc( infile );
	    }
	    break;

	case RByteDataOp:
	    if ( LONGP(inst) )
	    {
	        VAXSHORT( nc, infile );
	    }
	    else
		nc = DATUM(inst);
	    nc++;
	    if ( the_hdr->priv.get.is_seek )
		fseek( infile, ((nc + 1) / 2) * 2, 1 );
	    else
	    {
		register int ii;
		for ( ii = ((nc + 1) / 2) * 2; ii > 0; ii-- )
		    (void) getc( infile );	/* discard it */
	    }

	    break;

	case RRunDataOp:
	    if ( LONGP(inst) )
	    {
		(void)getc( infile );
		(void)getc( infile );
	    }
	    (void)getc( infile );
	    (void)getc( infile );
	    break;

	case REOFOp:
	    the_hdr->priv.get.is_eof = 1;
	    break;

	default:
	    fprintf( stderr, "rle_getskip: Unrecognized opcode: %d\n", OPCODE(inst) );
	    exit(1);
	}
	if ( OPCODE(inst) == REOFOp )
	    break;			/* <--- the other loop exit */
	if ( OPCODE(inst) == RSkipLinesOp )
	    break;
    }

    /* Return the number of the NEXT scanline. */
    the_hdr->priv.get.scan_y +=
	the_hdr->priv.get.vert_skip;
    the_hdr->priv.get.vert_skip = 0;

    if ( the_hdr->priv.get.is_eof )
	return 32768;		/* too big for 16 bits, signal EOF */
    else
	return the_hdr->priv.get.scan_y;
}
@


11.6
log
@change conf.h to a wrapped config.h
@
text
@@


11.5
log
@merge of ansi-6-0-branch into HEAD
@
text
@d28 5
a32 1
#include "conf.h"
@


11.4
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d64 1
a64 2
rle_getskip( the_hdr )
rle_hdr *the_hdr;
@


11.4.2.1
log
@Initial ANSIfication
@
text
@d64 2
a65 1
rle_getskip(rle_hdr *the_hdr)
@


11.3
log
@Converted from K&R to ANSI C - RFH
@
text
@d64 2
a65 1
rle_getskip(rle_hdr *the_hdr)
@


11.2
log
@*- include stdlib.h
@
text
@d64 1
a64 2
rle_getskip( the_hdr )
rle_hdr *the_hdr;
@


11.1
log
@Release_4.4
@
text
@d31 1
@


10.3
log
@Altered #defines and #includes to conform to BRL-CAD standards
@
text
@@


10.2
log
@debugging added
@
text
@d28 6
@


10.1
log
@Release_4.0
@
text
@d77 2
d87 2
a88 1
	switch( OPCODE(inst) )
@


1.2
log
@changed include of rle*.h files to use quotes instead of <>
@
text
@@


1.1
log
@Initial revision
@
text
@d28 2
a29 2
#include <rle.h>
#include <rle_code.h>
@
