head	11.8;
access;
symbols
	ansi-20040405-merged:11.5.2.2
	postmerge-20040405-ansi:11.6
	premerge-20040404-ansi:11.5
	postmerge-autoconf:11.5
	autoconf-freeze:11.5
	premerge-autoconf:11.5
	postmerge-20040315-windows:11.5
	premerge-20040315-windows:11.5
	windows-20040315-freeze:11.5
	autoconf-20031203:11.5
	autoconf-20031202:11.5
	autoconf-branch:11.5.0.10
	phong-branch:11.5.0.8
	photonmap-branch:11.5.0.6
	rel-6-1-DP:11.5
	windows-branch:11.5.0.4
	rel-6-0-2:11.3
	ansi-branch:11.5.0.2
	rel-6-0-1-branch:11.3.0.2
	hartley-6-0-post:11.4
	hartley-6-0-pre:11.3
	rel-6-0-1:11.3
	rel-6-0:11.3
	rel-5-4:11.2
	offsite-5-3-pre:11.2
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.8
date	2004.05.21.17.59.38;	author morrison;	state dead;
branches;
next	11.7;

11.7
date	2004.05.10.15.30.47;	author erikg;	state Exp;
branches;
next	11.6;

11.6
date	2004.04.05.07.40.44;	author morrison;	state Exp;
branches;
next	11.5;

11.5
date	2002.08.20.17.08.18;	author jra;	state Exp;
branches
	11.5.2.1;
next	11.4;

11.4
date	2002.08.15.20.55.28;	author hartley;	state Exp;
branches;
next	11.3;

11.3
date	2001.04.20.22.31.07;	author morrison;	state Exp;
branches;
next	11.2;

11.2
date	98.09.22.02.40.39;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.04.53;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.08.10.23.17.40;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.08.10.22.48.42;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.38.10;	author mike;	state Rel4_0;
branches;
next	1.2;

1.2
date	91.01.05.02.17.49;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	91.01.03.17.29.41;	author butler;	state Exp;
branches;
next	;

11.5.2.1
date	2002.09.19.18.01.55;	author morrison;	state Exp;
branches;
next	11.5.2.2;

11.5.2.2
date	2004.04.02.23.18.29;	author morrison;	state Exp;
branches;
next	;


desc
@Dist 3.0 patchlevel 2 installation
@


11.8
log
@moved from top-level to src/other/.
@
text
@/*
 * This software is copyrighted as noted below.  It may be freely copied,
 * modified, and redistributed, provided that the copyright notice is 
 * preserved on all copies.
 * 
 * There is no warranty or other guarantee of fitness for this software,
 * it is provided solely "as is".  Bug reports or fixes may be sent
 * to the author, who may or may not act on them as he desires.
 *
 * You may not include this software in a program or other software product
 * without supplying the source, or without informing the end-user that the 
 * source is available for no extra charge.
 *
 * If you modify this software, you should include a notice giving the
 * name of the person performing the modification, the date of modification,
 * and the reason for such modification.
 *
 *  Modified at BRL 16-May-88 by Mike Muuss to avoid Alliant STDC desire
 *  to have all "void" functions so declared.
 */
/* 
 * Runput.c - General purpose Run Length Encoding.
 * 
 * Author:	Spencer W. Thomas
 * 		Computer Science Dept.
 * 		University of Utah
 * Date:	Mon Aug  9 1982
 * Copyright (c) 1982,1986 Spencer W. Thomas
 * 
 * $Id: Runput.c,v 11.7 2004/05/10 15:30:47 erikg Exp $
 * 
 * Modified by:	Todd W. Fuqua
 * 	Date:	Jul 22 1984
 * convert to new RLE format to make room for larger frame buffers
 */

/* THIS IS WAY OUT OF DATE.  See rle.5.
 * The output file format is:
 * 
 * Word 0:	A "magic" number.  The top byte of the word contains
 *		the letter 'R' or the letter 'W'.  'W' indicates that
 *		only black and white information was saved.  The bottom
 *		byte is one of the following:
 *	' ':	Means a straight "box" save, -S flag was given.
 *	'B':	Image saved with background color, clear screen to
 *		background before restoring image.
 *	'O':	Image saved in overlay mode.
 * 
 * Words 1-6:	The structure
 * {     short   xpos,			Lower left corner
 *             ypos,
 *             xsize,			Size of saved box
 *             ysize;
 *     char    rgb[3];			Background color
 *     char    map;			flag for map presence
 * }
 * 
 * If the map flag is non-zero, then the color map will follow as 
 * 3*256 16 bit words, first the red map, then the green map, and
 * finally the blue map.
 * 
 * Following the setup information is the Run Length Encoded image.
 * Each instruction consists of a 4-bit opcode, a 12-bit datum and
 * possibly one or more following words (all words are 16 bits).  The
 * instruction opcodes are:
 * 
 * SkipLines (1):   The bottom 10 bits are an unsigned number to be added to
 *		    current Y position.
 * 
 * SetColor (2):    The datum indicates which color is to be loaded with
 * 		    the data described by the following ByteData and
 * 		    RunData instructions.  0->red, 1->green, 2->blue.  The
 * 		    operation also resets the X position to the initial
 * 		    X (i.e. a carriage return operation is performed).
 * 
 * SkipPixels (3):  The bottom 10 bits are an unsigned number to be
 * 		    added to the current X position.
 * 
 * ByteData (5):    The datum is one less than the number of bytes of
 * 		    color data following.  If the number of bytes is
 * 		    odd, a filler byte will be appended to the end of
 * 		    the byte string to make an integral number of 16-bit
 * 		    words.  The bytes are in PDP-11 order.  The X
 * 		    position is incremented to follow the last byte of
 * 		    data.
 * 
 * RunData (6):	    The datum is one less than the run length.  The
 * 		    following word contains (in its lower 8 bits) the
 * 		    color of the run.  The X position is incremented to
 * 		    follow the last byte in the run.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "rle_put.h"
#include "rle.h"
#include "rle_code.h"

#define UPPER 255			/* anything bigger ain't a byte */

/*
 * Macros to make writing instructions with correct byte order easier.
 */
/* Write a two-byte value in little_endian order. */
#define	put16(a)    (putc((a)&0xff,rle_fd),putc(((a)>>8)&0xff,rle_fd))

/* short instructions */
#define mk_short_1(oper,a1)		/* one argument short */ \
    putc(oper,rle_fd), putc((char)a1,rle_fd)

#define mk_short_2(oper,a1,a2)		/* two argument short */ \
    putc(oper,rle_fd), putc((char)a1,rle_fd), put16(a2)

/* long instructions */
#define mk_long_1(oper,a1)		/* one argument long */ \
    putc((char)(LONG|oper),rle_fd), putc('\0', rle_fd), put16(a1)

#define mk_long_2(oper,a1,a2)		/* two argument long */ \
    putc((char)(LONG|oper),rle_fd), putc('\0', rle_fd), \
    put16(a1), put16(a2)

/* choose between long and short format instructions */
/* NOTE: these macros can only be used where a STATEMENT is legal */

#define mk_inst_1(oper,a1)		/* one argument inst */ \
    if (a1>UPPER) (mk_long_1(oper,a1)); else (mk_short_1(oper,a1))

#define mk_inst_2(oper,a1,a2)		/* two argument inst */ \
    if (a1>UPPER) (mk_long_2(oper,a1,a2)); else (mk_short_2(oper,a1,a2))

/* 
 * Opcode definitions
 */
#define	    RSkipLines(n)   	    mk_inst_1(RSkipLinesOp,(n))

#define	    RSetColor(c)	    mk_short_1(RSetColorOp,(c))
				    /* has side effect of performing */
				    /* "carriage return" action */

#define	    RSkipPixels(n)	    mk_inst_1(RSkipPixelsOp,(n))

#define	    RNewLine		    RSkipLines(1)

#define	    RByteData(n)	    mk_inst_1(RByteDataOp,n)
					/* followed by ((n+1)/2)*2 bytes */
					/* of data.  If n is odd, last */
					/* byte will be ignored */
					/* "cursor" is left at pixel */
					/* following last pixel written */

#define	    RRunData(n,c)	    mk_inst_2(RRunDataOp,(n),(c))
					/* next word contains color data */
					/* "cursor" is left at pixel after */
					/* end of run */

#define     REOF		    mk_inst_1(REOFOp,0)
					/* Really opcode only */

extern char *vax_pshort(register char *msgp, register unsigned int s);

/*****************************************************************
 * TAG( RunSetup )
 * Put out initial setup data for RLE files.
 */
void
RunSetup(register rle_hdr *the_hdr)
{
    struct XtndRsetup setup;
    register FILE * rle_fd = the_hdr->rle_file;

    put16( RLE_MAGIC );

    if ( the_hdr->background == 2 )
	setup.h_flags = H_CLEARFIRST;
    else if ( the_hdr->background == 0 )
	setup.h_flags = H_NO_BACKGROUND;
    else
	setup.h_flags = 0;
    if ( the_hdr->alpha )
	setup.h_flags |= H_ALPHA;
    if ( the_hdr->comments != NULL && *the_hdr->comments != NULL )
	setup.h_flags |= H_COMMENT;

    setup.h_ncolors = the_hdr->ncolors;
    setup.h_pixelbits = 8;		/* Grinnell dependent */
    if ( the_hdr->ncmap > 0 && the_hdr->cmap == NULL )
    {
	fprintf( stderr,
		 "Color map of size %d*%d specified, but not supplied\n",
			the_hdr->ncmap, the_hdr->cmaplen );
	the_hdr->ncmap = 0;
    }
    setup.h_cmaplen = the_hdr->cmaplen;	/* log2 of color map size */
    setup.h_ncmap = the_hdr->ncmap;	/* no of color channels */
    vax_pshort(setup.hc_xpos, (unsigned int)the_hdr->xmin);
    vax_pshort(setup.hc_ypos, (unsigned int)the_hdr->ymin);
    vax_pshort(setup.hc_xlen, (unsigned int)(the_hdr->xmax - the_hdr->xmin + 1));
    vax_pshort(setup.hc_ylen, (unsigned int)(the_hdr->ymax - the_hdr->ymin + 1));
    fwrite((char *)&setup, SETUPSIZE, 1, rle_fd);
    if ( the_hdr->background != 0 )
    {
	register int i;
	register rle_pixel *background =
	    (rle_pixel *)malloc( (unsigned)(the_hdr->ncolors + 1) );
	register int *bg_color;
	/* 
	 * If even number of bg color bytes, put out one more to get to 
	 * 16 bit boundary.
	 */
	bg_color = the_hdr->bg_color;
	for ( i = 0; i < the_hdr->ncolors; i++ )
	    background[i] =  *bg_color++;
	/* Extra byte, if written, should be 0. */
	background[i] = 0;
	fwrite((char *)background, (unsigned)((the_hdr->ncolors / 2) * 2 + 1), 1, rle_fd);
	free( background );
    }
    else
	putc( '\0', rle_fd );
    if (the_hdr->ncmap > 0)
    {
	/* Big-endian machines are harder */
	register int i, nmap = (1 << the_hdr->cmaplen) *
			       the_hdr->ncmap;
	register char *h_cmap = (char *)malloc( (unsigned)nmap * 2 );
	if ( h_cmap == NULL )
	{
	    fprintf( stderr, "Malloc failed for color map of size %d\n",
		     nmap );
	    exit( 1 );
	}
	for ( i = 0; i < nmap; i++ )
	    vax_pshort( &h_cmap[i*2], (unsigned int)the_hdr->cmap[i] );

	fwrite( h_cmap, (unsigned)nmap, 2, rle_fd );
	free( h_cmap );
    }

    /* Now write out comments if given */
    if ( setup.h_flags & H_COMMENT )
    {
	int comlen;
	register const char ** com_p;

	/* Get the total length of comments */
	comlen = 0;
	for ( com_p = the_hdr->comments; *com_p != NULL; com_p++ )
	    comlen += 1 + strlen( *com_p );

	put16( comlen );
	for ( com_p = the_hdr->comments; *com_p != NULL; com_p++ )
	    fwrite( *com_p, 1, strlen( *com_p ) + 1, rle_fd );

	if ( comlen & 1 )	/* if odd length, round up */
	    putc( '\0', rle_fd );
    }
}

/*****************************************************************
 * TAG( RunSkipBlankLines )
 * Skip one or more blank lines in the RLE file.
 */
void
RunSkipBlankLines(int nblank, register rle_hdr *the_hdr)
{
    register FILE * rle_fd = the_hdr->rle_file;
    RSkipLines(nblank);
}

/*****************************************************************
 * TAG( RunSetColor )
 * Select a color and do carriage return.
 * color: 0 = Red, 1 = Green, 2 = Blue.
 */
void
RunSetColor(int c, register rle_hdr *the_hdr)
{
    register FILE * rle_fd = the_hdr->rle_file;
    RSetColor(c);
}

/*****************************************************************
 * TAG( RunSkipPixels )
 * Skip a run of background.
 */

/* ARGSUSED */
void
RunSkipPixels(int nskip, int last, int wasrun, register rle_hdr *the_hdr)
{
    register FILE * rle_fd = the_hdr->rle_file;
    if (0) wasrun=wasrun;
    if (! last && nskip > 0)
    {
	RSkipPixels(nskip);
    }
}

/*****************************************************************
 * TAG( RunNewScanLine )
 * Perform a newline action.  Since CR is implied by the Set Color
 * operation, only generate code if the newline flag is true.
 */
void
RunNewScanLine(int flag, register rle_hdr *the_hdr)
{
    register FILE * rle_fd = the_hdr->rle_file;
    if (flag)
    {
	RNewLine;
    }
}

/*****************************************************************
 * TAG( Runputdata )
 * Put one or more pixels of byte data into the output file.
 */
void
Runputdata(rle_pixel *buf, int n, register rle_hdr *the_hdr)
{
    register FILE * rle_fd = the_hdr->rle_file;
    if (n == 0)
	return;

    RByteData(n-1);
    fwrite((char *)buf, (unsigned)n, 1, rle_fd);
    if ( n & 1 )
	putc( 0, rle_fd );
}

/*****************************************************************
 * TAG( Runputrun )
 * Output a single color run.
 */

/* ARGSUSED */
void
Runputrun(int color, int n, int last, register rle_hdr *the_hdr)
{
    register FILE * rle_fd = the_hdr->rle_file;
    if (0) last=last;
    RRunData(n-1,color);
}


/*****************************************************************
 * TAG( RunputEof )
 * Output an EOF opcode
 */
void
RunputEof(register rle_hdr *the_hdr)
{
    register FILE * rle_fd = the_hdr->rle_file;
    REOF;
}
@


11.7
log
@change conf.h to a wrapped config.h
@
text
@d30 1
a30 1
 * $Id: Runput.c,v 11.6 2004/04/05 07:40:44 morrison Exp $
@


11.6
log
@merge of ansi-6-0-branch into HEAD
@
text
@d30 1
a30 1
 * $Id$
d93 5
a97 1
#include "conf.h"
@


11.5
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d30 1
a30 1
 * $Id: Runput.c,v 11.3 2001/04/20 22:31:07 morrison Exp $
d168 1
a168 1
extern char *vax_pshort();
d175 1
a175 2
RunSetup(the_hdr)
register rle_hdr * the_hdr;
d204 4
a207 4
    vax_pshort(setup.hc_xpos,the_hdr->xmin);
    vax_pshort(setup.hc_ypos,the_hdr->ymin);
    vax_pshort(setup.hc_xlen,the_hdr->xmax - the_hdr->xmin + 1);
    vax_pshort(setup.hc_ylen,the_hdr->ymax - the_hdr->ymin + 1);
d224 1
a224 1
	fwrite((char *)background, (the_hdr->ncolors / 2) * 2 + 1, 1, rle_fd);
d234 1
a234 1
	register char *h_cmap = (char *)malloc( nmap * 2 );
d242 1
a242 1
	    vax_pshort( &h_cmap[i*2], the_hdr->cmap[i] );
d244 1
a244 1
	fwrite( h_cmap, nmap, 2, rle_fd );
d273 1
a273 3
RunSkipBlankLines(nblank, the_hdr)
int nblank;
register rle_hdr * the_hdr;
d285 1
a285 3
RunSetColor(c, the_hdr)
int c;
register rle_hdr * the_hdr;
d298 1
a298 3
RunSkipPixels(nskip, last, wasrun, the_hdr)
int nskip, last, wasrun;
register rle_hdr * the_hdr;
d301 1
d314 1
a314 3
RunNewScanLine(flag, the_hdr)
int flag;
register rle_hdr * the_hdr;
d328 1
a328 4
Runputdata(buf, n, the_hdr)
rle_pixel * buf;
int n;
register rle_hdr * the_hdr;
d335 1
a335 1
    fwrite((char *)buf, n, 1, rle_fd);
d347 1
a347 3
Runputrun(color, n, last, the_hdr)
int color, n, last;
register rle_hdr * the_hdr;
d350 1
d360 1
a360 2
RunputEof( the_hdr )
register rle_hdr * the_hdr;
@


11.5.2.1
log
@Initial ANSIfication
@
text
@d30 1
a30 1
 * $Id: Runput.c,v 11.5 2002/08/20 17:08:18 jra Exp $
d168 1
a168 1
extern char *vax_pshort(register char *msgp, register short unsigned int s);
d175 2
a176 1
RunSetup(register rle_hdr *the_hdr)
d274 3
a276 1
RunSkipBlankLines(int nblank, register rle_hdr *the_hdr)
d288 3
a290 1
RunSetColor(int c, register rle_hdr *the_hdr)
d303 3
a305 1
RunSkipPixels(int nskip, int last, int wasrun, register rle_hdr *the_hdr)
d320 3
a322 1
RunNewScanLine(int flag, register rle_hdr *the_hdr)
d336 4
a339 1
Runputdata(rle_pixel *buf, int n, register rle_hdr *the_hdr)
d358 3
a360 1
Runputrun(int color, int n, int last, register rle_hdr *the_hdr)
d372 2
a373 1
RunputEof(register rle_hdr *the_hdr)
@


11.5.2.2
log
@quell verbose warnings
@
text
@d30 1
a30 1
 * $Id: Runput.c,v 11.5.2.1 2002/09/19 18:01:55 morrison Exp $
d168 1
a168 1
extern char *vax_pshort(register char *msgp, register unsigned int s);
d204 4
a207 4
    vax_pshort(setup.hc_xpos, (unsigned int)the_hdr->xmin);
    vax_pshort(setup.hc_ypos, (unsigned int)the_hdr->ymin);
    vax_pshort(setup.hc_xlen, (unsigned int)(the_hdr->xmax - the_hdr->xmin + 1));
    vax_pshort(setup.hc_ylen, (unsigned int)(the_hdr->ymax - the_hdr->ymin + 1));
d224 1
a224 1
	fwrite((char *)background, (unsigned)((the_hdr->ncolors / 2) * 2 + 1), 1, rle_fd);
d234 1
a234 1
	register char *h_cmap = (char *)malloc( (unsigned)nmap * 2 );
d242 1
a242 1
	    vax_pshort( &h_cmap[i*2], (unsigned int)the_hdr->cmap[i] );
d244 1
a244 1
	fwrite( h_cmap, (unsigned)nmap, 2, rle_fd );
a300 1
    if (0) wasrun=wasrun;
d334 1
a334 1
    fwrite((char *)buf, (unsigned)n, 1, rle_fd);
a348 1
    if (0) last=last;
@


11.4
log
@Converted from K&R to ANSI C - RFH
@
text
@d168 1
a168 1
extern char *vax_pshort(register char *msgp, register short unsigned int s);
d175 2
a176 1
RunSetup(register rle_hdr *the_hdr)
d274 3
a276 1
RunSkipBlankLines(int nblank, register rle_hdr *the_hdr)
d288 3
a290 1
RunSetColor(int c, register rle_hdr *the_hdr)
d303 3
a305 1
RunSkipPixels(int nskip, int last, int wasrun, register rle_hdr *the_hdr)
d320 3
a322 1
RunNewScanLine(int flag, register rle_hdr *the_hdr)
d336 4
a339 1
Runputdata(rle_pixel *buf, int n, register rle_hdr *the_hdr)
d358 3
a360 1
Runputrun(int color, int n, int last, register rle_hdr *the_hdr)
d372 2
a373 1
RunputEof(register rle_hdr *the_hdr)
@


11.3
log
@CONST to const
@
text
@d30 1
a30 1
 * $Id: Runput.c,v 11.2 1998/09/22 02:40:39 mike Exp $
d168 1
a168 1
extern char *vax_pshort();
d175 1
a175 2
RunSetup(the_hdr)
register rle_hdr * the_hdr;
d273 1
a273 3
RunSkipBlankLines(nblank, the_hdr)
int nblank;
register rle_hdr * the_hdr;
d285 1
a285 3
RunSetColor(c, the_hdr)
int c;
register rle_hdr * the_hdr;
d298 1
a298 3
RunSkipPixels(nskip, last, wasrun, the_hdr)
int nskip, last, wasrun;
register rle_hdr * the_hdr;
d313 1
a313 3
RunNewScanLine(flag, the_hdr)
int flag;
register rle_hdr * the_hdr;
d327 1
a327 4
Runputdata(buf, n, the_hdr)
rle_pixel * buf;
int n;
register rle_hdr * the_hdr;
d346 1
a346 3
Runputrun(color, n, last, the_hdr)
int color, n, last;
register rle_hdr * the_hdr;
d358 1
a358 2
RunputEof( the_hdr )
register rle_hdr * the_hdr;
@


11.2
log
@Added missing printf() args.
@
text
@d30 1
a30 1
 * $Id: Runput.c,v 11.1 1995/01/04 10:04:53 mike Rel4_4 $
d253 1
a253 1
	register CONST char ** com_p;
@


11.1
log
@Release_4.4
@
text
@d30 1
a30 1
 * $Id: Runput.c,v 10.3 94/08/10 23:17:40 gdurf Exp $
d199 2
a200 1
		 "Color map of size %d*%d specified, but not supplied\n" );
@


10.3
log
@Altered #defines and #includes to conform to BRL-CAD standards
@
text
@d30 1
a30 1
 * $Id: Runput.c,v 10.2 1994/08/10 22:48:42 gdurf Exp gdurf $
@


10.2
log
@Factored ifdefs
@
text
@d30 1
a30 1
 * $Id: Runput.c,v 10.1 91/10/12 06:38:10 mike Rel4_0 $
d252 1
a252 1
	register CONST_DECL char ** com_p;
@


10.1
log
@Release_4.0
@
text
@d30 1
a30 1
 * $Id: Runput.c,v 3.0 90/08/03 15:19:58 spencer Exp $
d93 1
a93 7
#include	<stdio.h>
#include	"rle_put.h"
#include	"rle.h"
#include	"rle_code.h"
#ifdef USE_STDLIB_H
#include	<stdlib.h>
#else
d95 1
d97 1
a97 7
#include	<string.h>
#else
#include	<strings.h>
#endif /* USE_STRING_H */

#ifndef VOID_STAR
extern char * malloc();
d99 2
a100 3
extern void *malloc();
#endif /* VOID_STAR */
extern void free();
d102 5
a106 1
#endif /* USE_STDLIB_H */
@


1.2
log
@changed #include "stdio.h" to #include <stdio.h>
@
text
@@


1.1
log
@Initial revision
@
text
@d93 1
a93 1
#include	"stdio.h"
@
