head	1.7;
access;
symbols
	ansi-20040405-merged:1.5.4.1
	postmerge-20040405-ansi:1.6
	premerge-20040404-ansi:1.6
	postmerge-autoconf:1.6
	autoconf-freeze:1.6
	premerge-autoconf:1.6
	postmerge-20040315-windows:1.6
	premerge-20040315-windows:1.6
	windows-20040315-freeze:1.5.6.1
	autoconf-20031203:1.6
	autoconf-20031202:1.6
	autoconf-branch:1.6.0.6
	phong-branch:1.6.0.4
	photonmap-branch:1.6.0.2
	rel-6-1-DP:1.5
	windows-branch:1.5.0.6
	rel-6-0-2:1.5
	ansi-branch:1.5.0.4
	rel-6-0-1-branch:1.5.0.2
	hartley-6-0-post:1.5
	hartley-6-0-pre:1.5
	rel-6-0-1:1.5;
locks; strict;
comment	@# @;


1.7
date	2004.05.21.16.41.46;	author morrison;	state dead;
branches;
next	1.6;

1.6
date	2003.03.13.19.45.34;	author jra;	state Exp;
branches;
next	1.5;

1.5
date	2002.07.19.19.24.25;	author rbowers;	state Exp;
branches
	1.5.4.1
	1.5.6.1;
next	1.4;

1.4
date	2002.07.18.16.10.30;	author rbowers;	state Exp;
branches;
next	1.3;

1.3
date	2002.07.11.14.23.53;	author rbowers;	state Exp;
branches;
next	1.2;

1.2
date	2002.07.10.20.13.07;	author rbowers;	state Exp;
branches;
next	1.1;

1.1
date	2002.07.08.17.27.54;	author rbowers;	state Exp;
branches;
next	;

1.5.4.1
date	2004.03.17.21.23.17;	author morrison;	state Exp;
branches;
next	;

1.5.6.1
date	2004.03.11.23.52.26;	author morrison;	state Exp;
branches;
next	;


desc
@@


1.7
log
@moved to src/tclscripts/
@
text
@#
# PictureTypeBase.itcl
#
# This is the base class for the various picture types (duh!).
#  It provides the shared methods.
#

#
# Required packages
#
package require Itcl
package require Itk
package require Iwidgets

namespace eval RtWizard {
  
    package provide PictureTypeBase 1.0

    #
    # Required packages
    #

    # None!

    #
    # The PictureTypeBase class should not be instantiated!
    #
    ::itcl::class PictureTypeBase {

	public {
	    constructor {args} {}

	    #
	    # These methods handle when a picture type is chosen
	    # or replaced.
	    #
	    method activate {}	    
	    method deactivate {}

	    #
	    # Accessor methods
	    #
	    method getTitle {} {
		return $title
	    }

	    method getSampleImage {} {
		return $sampleImage
	    }

	    method getDescText {} {
		return $descText
	    }

	    method getHelpStr {} {
		return $helpStr
	    }

	    #
	    # These methods generate pictures. They query the 
	    # individual pages for the information they need.
	    #
	    method preview {}
	    method fullSize {} 
	}

	protected {
	    method rtCmd {objPage width height fb} {}
	    method rtedgeCmd \
		    {objPage fb width height \
		    {overlay 0} \
		    {occMode 0} \
		    {occObjsPage {}}}  {}
	    method hexToRGB {hexRGB} {}

	    variable title
	    variable sampleImage
	    variable descText
	    variable helpStr
	    variable introText
	    variable startPage
	}
	
	private { 
	    method runRtCmd {cmd {viewInfo {}}}
	    method testRead {pipe}
	    
	    variable waiting ""
	}
    }

    #--------------------#
    #   Public Methods   #
    #--------------------#    
    #
    # constructor - Loads all of the information necessary
    #               to support this image type. This includes
    #               the sample image, the descriptive text,
    #
    itcl::body PictureTypeBase::constructor { args } {
	#
	# Protect against instantiation. This is an _abstract_
	# class.
	#
	set type [namespace tail [$this info class]]
	if { $type == "PictureTypeBase" } {
	    error "Can't instantiate the abstract PictureTypeBase class."
	}

	#
	# The support directory name is the same as the 
	# class type.
	#
	if { [info exists ::env(BRLCAD_ROOT)] } {
	    set rootDir $::env(BRLCAD_ROOT)
	} else {
	    set rootDir [file join / usr brlcad ]
	} 
	set dir [ file join $rootDir tclscripts rtwizard examples \
		$type ]

	#
	# Load the title string
	#
	set tmpFile [file join $dir title.txt]
	set fd [open $tmpFile r]
	set title [read -nonewline $fd]
	close $fd

	#
	# Create an image object to hold the sample image.
	#
	set tmpFile [ file join $dir preview.small.gif ]
	set sampleImage [ image create photo -file $tmpFile ]

	#
	# Load the text that describes the sample.
	#	
	set tmpFile [file join $dir desc.txt]
	set fd [open $tmpFile r]
	set descText [read -nonewline $fd]
	close $fd

	#
	# Load the help string. 
	#
	set tmpFile [file join $dir helpstr.txt]
	set fd [open $tmpFile r]
	set helpStr [read -nonewline $fd]
	close $fd

	#
	# Load the introtext. 
	#
	set tmpFile [file join $dir intro.txt]
	set fd [open $tmpFile r]
	set introText [read -nonewline $fd]
	close $fd
    }

    #
    # activate - called when this picture type is selected.
    #
    itcl::body PictureTypeBase::activate { } {
	append msg "PictureTypeBase::activate called" \
		" - should be overloaded by derived class."
	error $msg
    }

    #
    # deactivate - called when this picture type is deselected.
    #
    itcl::body PictureTypeBase::deactivate { } {
	append msg "PictureTypeBase::deactivate called" \
		" - should be overloaded by derived class."
	error $msg
    }

    #
    # preview - generates a 1/4 size preview image
    #
    itcl::body PictureTypeBase::preview { } {
	append msg "PictureTypeBase::preview called" \
		" - should be overloaded by derived class."
	error $msg
    }

    #
    # fullSize - generates the full size image
    #
    itcl::body PictureTypeBase::fullSize { } {
	append msg "PictureTypeBase::fullSize called" \
		" - should be overloaded by derived class."
	error $msg
    }

    #-------------------#
    # Protected Methods #
    #-------------------#
    #
    # rtCmd - formats an rt command to generate a picture. 
    #         Width, height, and framebuffer are passed in
    #         because they differ for fullSize and preview
    #
    itcl::body PictureTypeBase::rtCmd \
	    {objPage fb width height } {
	#
	# Get the page that contains the view information.
	#
	set viewPage [$::exp getViewPage]

	#
	# Get the view info
	#
	set viewInfo [$viewPage getEyeModel]
	
	#
	# Get the background color
	#
	set bgHex [$objPage getBackgroundColor]
	set bg [hexToRGB $bgHex]

	#
	# Get the object list, the file is global
	#
	set objects [$objPage getObjects]

	#
	# compute the aspect ratio. Note how floating point
	# math is forced.
	#
	set ar [ expr $width.0 / $height.0 ]

	#
	# Assemble the rt command - note that it is a 
	# full-blown script.
	#
	set cmd [list rt -M -R -F $fb -w $width \
		-n $height -V $ar -A 0.9 \
		-C [lindex $bg 0]/[lindex $bg 1]/[lindex $bg 2] \
		$::RtWizard::dbFile]

	foreach obj $objects {
	    lappend cmd $obj
	}

	runRtCmd $cmd $viewInfo
    }

    #
    # rtedgeCmd - formats an rtedge command to generate a picture. 
    #
    itcl::body PictureTypeBase::rtedgeCmd \
	    {objPage fb width height \
	    {overlay 0} \
	    {occMode 0} \
	    {occObjsPage {}}} {
	#
	# Get the page that contains the view information.
	#
	set viewPage [$::exp getViewPage]

	#
	# Get the view info
	#
	set viewInfo [$viewPage getEyeModel]

	#
	# Get the edge color color
	#
	set lineHex [$objPage getLineColor]
	set l [hexToRGB $lineHex]

	#
	# Get the non-line color
	#
	set nonLineHex [$objPage getNonLineColor]
	set nl [hexToRGB $nonLineHex]

	#
	# Get the object list, the file is global
	#
	set objects [$objPage getObjects]

	#
	# compute the aspect ratio. Note how floating point
	# math is forced.
	#
	set ar [ expr $width.0 / $height.0 ]

	#
	# Determine if region colors were requested, if so, use them.
	# Otherwise, use the specified foreground colors.
	#
	if {[$objPage getRegionColorFlag] == "true"} {
	    set fgMode [list set rc=1]
	} else {
	    set fgMode [list set fg=[lindex $l 0],[lindex $l 1],[lindex $l 2]]
	}

	#
	# Assemble the rtedge command - note that it is a 
	# full-blown script.
	#
	if {$occMode != 0} {
	    #
	    # If required, get occlusion objects
	    #	    
	    set occObjects [$occObjsPage getObjects]

	    set cmd [list rtedge -M -R -F $fb -w $width \
		    -n $height -V $ar -A 0.9 \
		    -c "$fgMode" \
		    -c "set bg=[lindex $nl 0],[lindex $nl 1],[lindex $nl 2]" \
		    -c "set om=$occMode" \
		    -c "set oo=\"$occObjects\"" \
		    $::RtWizard::dbFile]
	} else {

	    set cmd [list rtedge -M -R -F $fb -w $width \
		    -n $height -V $ar -A 0.9 \
		    -c "$fgMode" \
		    -c "set bg=[lindex $nl 0],[lindex $nl 1],[lindex $nl 2]" \
		    -c "set ov=$overlay" \
		    $::RtWizard::dbFile]
	}	

	#
	# Add the objects
	#
	foreach obj $objects {
	    lappend cmd $obj
	}

	runRtCmd $cmd $viewInfo

    }


    #
    # hexToRGB - converts an RGB color in hex #rrggbb format to 
    #            decimal {rrr ggg bbb} format
    #
    itcl::body PictureTypeBase::hexToRGB {hexRGB} {

	scan [string range $hexRGB 1 2] "%x" redDec
	scan [string range $hexRGB 3 4] "%x" greenDec
	scan [string range $hexRGB 5 6] "%x" blueDec
	
	return [list $redDec $greenDec $blueDec]
    }

    #
    # runRtCmd - common method for event-handling the rt commands
    #
    itcl::body PictureTypeBase::runRtCmd {cmd {viewInfo {}}} {
	set ::waiting ""
	#
	# open the pipe
	#
	set pipe [open "| $cmd" r+]

	#
	# puts the matrix info to the pipe
	#
	if {[string length $viewInfo] != 0} {
	    puts $pipe "$viewInfo"
	    puts $pipe "start 0; clean; end;\n\n"
	    flush $pipe
	}

	#
	# Set up a callback for readable events, and wait!
	#
# 	fileevent $pipe readable [ list testRead $pipe ]
#	fileevent $pipe writable [ list testWrite $pipe ]
#	vwait ::waiting
	fconfigure $pipe -blocking true

	catch "close $pipe" catchResult
	puts $catchResult
    }

    #
    # TestRead - pipe fileevent callback
    #
    itcl::body PictureTypeBase::testRead {pipe} {
	
	set waiting "Done"
    }
}; # end namespace

#
# TestRead - pipe fileevent callback
#
proc testRead {pipe} {
	set ::waiting "Done"
}

#
# TestWrite - pipe fileevent callback
#
proc testWrite {pipe} {
    if [eof $pipe] {
	set ::waiting "Done"
    }
}





































@


1.6
log
@*** empty log message ***
@
text
@@


1.5
log
@-* corrected a bug in the rtwizard render script.
@
text
@d13 1
a13 1
package require Iwidgets 3.0
d375 4
a378 3
	fileevent $pipe readable [ list testRead $pipe ]
	fileevent $pipe writable [ list testWrite $pipe ]
	vwait ::waiting
@


1.5.4.1
log
@sync branch with HEAD
@
text
@d13 1
a13 1
package require Iwidgets
d375 3
a377 4
# 	fileevent $pipe readable [ list testRead $pipe ]
#	fileevent $pipe writable [ list testWrite $pipe ]
#	vwait ::waiting
	fconfigure $pipe -blocking true
@


1.5.6.1
log
@sync to HEAD...
@
text
@d13 1
a13 1
package require Iwidgets
d375 3
a377 4
# 	fileevent $pipe readable [ list testRead $pipe ]
#	fileevent $pipe writable [ list testWrite $pipe ]
#	vwait ::waiting
	fconfigure $pipe -blocking true
@


1.4
log
@-* Fixed a problem with BRLCAD_ROOT support.
@
text
@a374 1
#	fileevent $pipe readable [ itcl::code $this testRead $pipe 
d403 1
a403 1
    if [eof $pip] {
@


1.3
log
@-* fixed 2 bugs.
   1. Wrong current view rather than selected view used for rt.
   2. View shifted when pages switched.
@
text
@d114 2
a115 2
	if { [info exists env(BRLCAD_ROOT)] } {
	    set rootDir $env(BRLCAD_ROOT)
@


1.2
log
@-* Replaced hard-wired path with one based on BRLCAD_ROOT or /usr/brlcad
@
text
@d380 2
a381 2
	catch "close $pipe" junk
	puts $junk
@


1.1
log
@-* moved rtwizard files to brlcad/tclscripts/rtwizard
@
text
@d112 1
a112 1
	# class type. Note that although this is
d114 6
a119 1
	set dir [ file join / vld rbowers brlcad rtwizard lib examples \
@

