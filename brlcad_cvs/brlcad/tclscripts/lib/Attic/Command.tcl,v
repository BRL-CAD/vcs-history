head	1.18;
access;
symbols
	ansi-20040405-merged:1.14.4.1
	postmerge-20040405-ansi:1.16
	premerge-20040404-ansi:1.16
	postmerge-autoconf:1.16
	autoconf-freeze:1.15.6.1
	premerge-autoconf:1.16
	postmerge-20040315-windows:1.16
	premerge-20040315-windows:1.16
	windows-20040315-freeze:1.14.6.2
	autoconf-20031203:1.15
	autoconf-20031202:1.15
	autoconf-branch:1.15.0.6
	phong-branch:1.15.0.4
	photonmap-branch:1.15.0.2
	rel-6-1-DP:1.14
	windows-branch:1.14.0.6
	rel-6-0-2:1.14
	ansi-branch:1.14.0.4
	rel-6-0-1-branch:1.14.0.2
	hartley-6-0-post:1.14
	hartley-6-0-pre:1.14
	rel-6-0-1:1.14
	rel-6-0:1.13
	rel-5-4:1.7.2.3
	offsite-5-3-pre:1.11
	rel-5-3:1.7.2.3
	rel-5-2:1.7.2.1
	rel-5-1-branch:1.7.0.2
	rel-5-1:1.7;
locks; strict;
comment	@# @;


1.18
date	2004.05.21.16.41.19;	author morrison;	state dead;
branches;
next	1.17;

1.17
date	2004.05.10.15.25.29;	author morrison;	state Exp;
branches;
next	1.16;

1.16
date	2004.02.02.17.39.43;	author morrison;	state Exp;
branches;
next	1.15;

1.15
date	2003.03.13.19.45.30;	author jra;	state Exp;
branches
	1.15.6.1;
next	1.14;

1.14
date	2002.06.17.17.44.59;	author jra;	state Exp;
branches
	1.14.4.1
	1.14.6.1;
next	1.13;

1.13
date	2001.12.03.23.15.47;	author bparker;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.13.21.10.01;	author bparker;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.09.15.31.15;	author bparker;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.02.18.13.57;	author bparker;	state Exp;
branches;
next	1.9;

1.9
date	2000.10.26.16.58.04;	author bparker;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.21.21.06.34;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.18.21.43.56;	author bparker;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2000.03.03.23.10.05;	author bparker;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.29.16.04.02;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.28.23.35.58;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.18.21.26.05;	author bparker;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.04.19.19.00;	author bparker;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.03.22.51.44;	author bparker;	state Exp;
branches;
next	;

1.7.2.1
date	2000.08.16.17.02.25;	author bparker;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2000.10.26.16.57.05;	author bparker;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2001.03.02.16.23.39;	author bparker;	state Exp;
branches;
next	;

1.14.4.1
date	2004.03.17.21.23.04;	author morrison;	state Exp;
branches;
next	;

1.14.6.1
date	2002.09.26.23.04.16;	author morrison;	state Exp;
branches;
next	1.14.6.2;

1.14.6.2
date	2004.03.11.23.48.51;	author morrison;	state Exp;
branches;
next	;

1.15.6.1
date	2004.02.12.18.34.48;	author erikg;	state Exp;
branches;
next	;


desc
@@


1.18
log
@moved to src/tclscripts/
@
text
@#                 C O M M A N D . T C L
#
# Author -
#	Bob Parker
#
# Source -
#	The U. S. Army Research Laboratory
#	Aberdeen Proving Ground, Maryland  21005
#
# Distribution Notice -
#	Re-distribution of this software is restricted, as described in
#       your "Statement of Terms and Conditions for the Release of
#       The BRL-CAD Package" agreement.
#
# Copyright Notice -
#       This software is Copyright (C) 1998-2004 by the United States Army
#       in all countries except the USA.  All rights reserved.
#
# Description -
#	The Command class implements a command window with command line
#       editing and command history.
#
::itcl::class Command {
    inherit ::iwidgets::Scrolledtext

    constructor {args} {}
    destructor {}

    itk_option define -edit_style edit_style Edit_style emacs
    itk_option define -prompt prompt Prompt "> "
    itk_option define -prompt2 prompt2 Prompt ""
    itk_option define -cmd_prefix cmd_prefix Cmd_prefix ""
    itk_option define -selection_color selection_color TextColor #fefe8e
    itk_option define -prompt_color prompt_color TextColor red1
    itk_option define -cmd_color cmd_color TextColor black
    itk_option define -oldcmd_color oldcmd_color TextColor red3
    itk_option define -result_color result_color TextColor blue3
    itk_option define -maxlines maxlines MaxLines 1000

    public method history {}
    public method edit_style {args}
    public method putstring {str}

    private method invoke {}
    private method first_char_in_line {}
    private method beginning_of_line {}
    private method end_of_line {}
    private method backward_char {}
    private method forward_char {}
    private method backward_word {}
    private method forward_word {}
    private method end_word {}
    private method backward_delete_char {}
    private method delete_char {}
    private method backward_delete_word {}
    private method delete_word {}
    private method delete_end_word {}
    private method delete_line {}
    private method delete_end_of_line {}
    private method delete_beginning_of_line {}
    private method next {}
    private method prev {}
    private method transpose {}
    private method execute {}
    private method interrupt {}
    private method vi_edit_mode {}
    private method vi_overwrite_mode {}
    private method vi_insert_mode {}
    private method vi_process_edit {c state}
    private method vi_process_overwrite {c state}
    private method text_op_begin {x y}
    private method text_paste {}
    private method text_scroll {x y}
    private method selection_begin {x y}
    private method selection_add {x y}
    private method select_word {x y}
    private method select_line {x y}
    private method selection_modify {x y}
    private method print {str}
    private method print_prompt {}
    private method print_prompt2 {}
    private method print_tag {str tag}
    private method cursor_highlight {}

    private method doBindings {}
    private method doButtonBindings {}
    private method doKeyBindings {}
    private method doControl_a {}
    private method doControl_c {}
    private method doMeta_d {}
    private method doMeta_BackSpace {}
    private method doReturn {}
    private method doLeft {}
    private method doRight {}

    private variable hist ""
    private variable cmdlist ""
    private variable scratchline ""
    private variable moveView 0
    private variable freshline 1

    private variable overwrite_flag 0
    private variable change_flag 0
    private variable delete_flag 0
    private variable search_flag 0
    private variable search_char ""
    private variable search_dir ""
}

::itcl::configbody Command::edit_style {
    edit_style $itk_option(-edit_style)
}

::itcl::configbody Command::cmd_prefix {
    if {$itk_option(-cmd_prefix) == ""} {
	set cmdlist ""
	return
    }

    # if getUserCmds doesn't exist, use all recognized functions
    if {[catch {eval $itk_option(-cmd_prefix) info function getUserCmds}]} {
	if {[catch {eval $itk_option(-cmd_prefix) info function} _cmdlist]} {
	    error "Bad command prefix: no related functions"
	}

	# strip off namespace
	set cmdlist ""
	foreach cmd $_cmdlist {
	    lappend cmdlist [namespace tail $cmd]
	}
    } else {
	set cmdlist [eval $itk_option(-cmd_prefix) getUserCmds]
    }

}

::itcl::configbody Command::selection_color {
	$itk_component(text) tag configure sel -foreground $itk_option(-selection_color)
}

::itcl::configbody Command::prompt_color {
	$itk_component(text) tag configure prompt -foreground $itk_option(-prompt_color)
}

::itcl::configbody Command::cmd_color {
	$itk_component(text) tag configure cmd -foreground $itk_option(-cmd_color)
}

::itcl::configbody Command::oldcmd_color {
	$itk_component(text) tag configure oldcmd -foreground $itk_option(-oldcmd_color)
}

::itcl::configbody Command::result_color {
	$itk_component(text) tag configure result -foreground $itk_option(-result_color)
}

::itcl::configbody Command::maxlines {
    if {$itk_option(-maxlines) < 1} {
	error "-maxlines must be greater than zero"
    }
}

::itcl::body Command::constructor {args} {
	eval itk_initialize $args

	doBindings

	# create command history object
	set hist [string map {:: "" . _} $this]
	set hist [ch_open [subst $hist]_hist]

	# initialize text widget
	print_prompt
	$itk_component(text) insert insert " "
	beginning_of_line

	$itk_component(text) tag configure sel -background $itk_option(-selection_color)
	$itk_component(text) tag configure prompt -foreground $itk_option(-prompt_color)
	$itk_component(text) tag configure cmd -foreground $itk_option(-cmd_color)
	$itk_component(text) tag configure oldcmd -foreground $itk_option(-oldcmd_color)
	$itk_component(text) tag configure result -foreground $itk_option(-result_color)
}

::itcl::body Command::destructor {} {
    # destroy command history object
    rename $hist ""
}


############################## Public Methods ##############################
::itcl::body Command::history {} {
    eval $hist history
}

::itcl::body Command::edit_style {args} {
    if {$args == ""} {
	return $itk_option(-edit_style)
    }

    switch $args {
	emacs -
	vi {
	    set itk_option(-edit_style) $args
	    doKeyBindings
	}
	default {
	    error "Bad edit_style - $args"
	}
    }
}

::itcl::body Command::putstring {str} {
    set w $itk_component(text)
    set promptBegin [$w index {end - 1 l}]
    $w mark set curr insert
    $w mark set insert $promptBegin

    if {$str != ""} {
	if {[string index $str end] == "\n"} {
	    print_tag $str result
	} else {
	    print_tag $str\n result
	}
    }

    $w mark set insert curr
    $w see insert

    # get rid of oldest output
    set nlines [expr int([$w index end])]
    if {$nlines > $itk_option(-maxlines)} {
	$w delete 1.0 [expr $nlines - $itk_option(-maxlines)].end
    }
}

############################## Protected/Private Methods  ##############################

::itcl::body Command::invoke {} {
    set w $itk_component(text)

    set cmd [$w get promptEnd insert]

    # remove any instances of prompt2 from the beginning of each secondary line
    regsub -all "\n$itk_option(-prompt2)" $cmd "" cmd
    
    set hcmd $cmd

    if {$itk_option(-cmd_prefix) != ""} {
	# get command name
	if {[regexp {^[ \t]*([^\]\[ \t\n\r{}]+)} $cmd match cname]} {
	    set cindex [lsearch -exact $cmdlist $cname]
	    if {$cindex != -1} {
		# found command name in cmdlist, so prepend cmd_prefix to cmd
		set cmd [concat $itk_option(-cmd_prefix) $cmd]
	    }
	}
    }

    if [info complete $cmd] {
	set result [catch {uplevel #0 $cmd} msg]

	if {$result != 0} {
	    $w tag add oldcmd promptEnd insert
	    print_tag "Error: $msg\n" result
	} else {
	    $w tag add oldcmd promptEnd insert

	    if {$msg != ""} {
		print_tag $msg\n result
	    }
	}

	$hist add $hcmd
	print_prompt

	# get rid of oldest output
	set nlines [expr int([$w index end])]
	if {$nlines > $itk_option(-maxlines)} {
	    $w delete 1.0 [expr $nlines - $itk_option(-maxlines)].end
	}
    } else {
	print_prompt2
    }
    $w see insert
}

::itcl::body Command::first_char_in_line {} {
    set w $itk_component(text)
    $w mark set insert promptEnd
    set c [$w get insert]
    if {$c == " "} {
	forward_word
    }
    cursor_highlight
}

::itcl::body Command::beginning_of_line {} {
    set w $itk_component(text)
    $w mark set insert promptEnd
    cursor_highlight
}

::itcl::body Command::end_of_line {} {
    set w $itk_component(text)
    $w mark set insert {end - 2c}
    cursor_highlight
    $w see insert
}

::itcl::body Command::backward_char {} {
    set w $itk_component(text)
    if [$w compare insert > promptEnd] {
	$w mark set insert {insert - 1c}
	cursor_highlight
    }
}

::itcl::body Command::forward_char {} {
    set w $itk_component(text)
    if [$w compare insert < {end - 2c}] {
	$w mark set insert {insert + 1c}
	cursor_highlight
    }
}

::itcl::body Command::backward_word {} {
    set w $itk_component(text)
    set ti [$w search -backwards -regexp "\[ \t\]\[^ \t\]" {insert - 1c} promptEnd]
    if [string length $ti] {
	$w mark set insert "$ti + 1c"
    } else {
	$w mark set insert promptEnd
    }

    cursor_highlight
}

::itcl::body Command::forward_word {} {
    set w $itk_component(text)
    set ti [$w search -forward -regexp "\[ \t\]\[^ \t\]" insert {end - 2c}]
    if [string length $ti] {
	$w mark set insert "$ti + 1c"
	cursor_highlight
    }
}

::itcl::body Command::end_word {} {
    set w $itk_component(text)
    set ti [$w search -forward -regexp "\[^ \t\]\[ \t\]" {insert + 1c} {end - 2c}]
    if [string length $ti] {
	$w mark set insert $ti
    } else {
	$w mark set insert {end - 2c}
    }

    cursor_highlight
}

::itcl::body Command::backward_delete_char {} {
    set w $itk_component(text)
#    catch {$w tag remove sel sel.first promptEnd}
    if [$w compare insert > promptEnd] {
	$w mark set insert {insert - 1c}
	$w delete insert
	cursor_highlight
    }
}

::itcl::body Command::delete_char {} {
    set w $itk_component(text)
#    catch {$w tag remove sel sel.first promptEnd}
    if {[$w compare insert >= promptEnd] && [$w compare insert < {end - 2c}]} {
	$w delete insert
	cursor_highlight
    }
}

::itcl::body Command::backward_delete_word {} {
    set w $itk_component(text)
    set ti [$w search -backwards -regexp "\[ \t\]\[^ \t\]" {insert - 1c} promptEnd]
    if [string length $ti] {
	$w delete "$ti + 1c" insert
    } else {
	$w delete promptEnd insert
    }
    cursor_highlight
}

::itcl::body Command::delete_word {} {
    set w $itk_component(text)
    set ti [$w search -forward -regexp "\[ \t\]\[^ \t\]" {insert + 1c} {end - 2c}]
    if [string length $ti] {
	$w delete insert "$ti + 1c"
    } else {
	$w delete insert "end - 2c"
    }

    cursor_highlight
}

::itcl::body Command::delete_end_word {} {
    set w $itk_component(text)
    set ti [$w search -forward -regexp "\[^ \t\]\[ \t\]" {insert + 1c} {end - 2c}]
    if [string length $ti] {
	$w delete insert "$ti + 1c"
    } else {
	$w delete insert "end - 2c"
    }

    cursor_highlight
}

::itcl::body Command::delete_line {} {
    set w $itk_component(text)
    $w delete promptEnd end-2c
    cursor_highlight
}

::itcl::body Command::delete_end_of_line {} {
    set w $itk_component(text)
    $w delete insert end-2c
    cursor_highlight
}

::itcl::body Command::delete_beginning_of_line {} {
    set w $itk_component(text)
    $w delete promptEnd insert
    cursor_highlight
}

::itcl::body Command::next {} {
    set w $itk_component(text)
    set result [catch {$hist next} msg]

    if {$result==0} {
	$w delete promptEnd {end - 2c}
	$w mark set insert promptEnd
	$w insert insert [string range $msg 0 \
		[expr [string length $msg]-2]]

	cursor_highlight
	$w see insert
    } else {
	if {!$freshline} {
	    $w delete promptEnd {end - 2c}
	    $w mark set insert promptEnd
	    $w insert insert [string range $scratchline 0\
		    [expr [string length $scratchline] - 1]]
	    set freshline 1
	    cursor_highlight
	}
    }
}

::itcl::body Command::prev {} {
    set w $itk_component(text)
    set result [catch {$hist prev} msg]

    if {$result==0} {
	if {$freshline} {
	    set scratchline [$w get promptEnd {end -2c}]
	    set freshline 0
	}

	$w delete promptEnd {end - 2c}
	$w mark set insert promptEnd

	$w insert insert [string range $msg 0 \
		[expr [string length $msg]-2]]

	cursor_highlight
	$w see insert
    }
}

::itcl::body Command::transpose {} {
    set w $itk_component(text)
    if {[$w compare insert > promptEnd] && [$w compare {end - 2c} > {promptEnd + 1c}]} {
	if [$w compare insert >= {end - 2c}] {
	    set before [$w get {insert - 2c}]
	    $w delete {insert - 2c}
	    $w insert insert $before
	} else {
	    set before [$w get {insert - 1c}]
	    $w delete {insert - 1c}
	    $w insert {insert + 1c} $before
	    $w mark set insert {insert + 2c}
	}
    }
    cursor_highlight
}

::itcl::body Command::execute {} {
    set w $itk_component(text)
    $w mark set insert {end - 2c}
    $w insert insert \n

    $w see insert
    update

    invoke
    set freshline 1
    cursor_highlight
}

::itcl::body Command::interrupt {} {
    set w $itk_component(text)

    $w insert insert \n
    print_prompt
    $w see insert
}

##################################################################################
#                                                                                #
#                        VI Specific Callbacks                                   #
#                                                                                #
##################################################################################
::itcl::body Command::vi_edit_mode {} {
    set w $itk_component(text)
    bind $w <BackSpace> "[::itcl::code $this backward_char]; break"
    bind $w <space> "[::itcl::code $this forward_char]; break"
    bind $w <KeyPress> "[::itcl::code $this vi_process_edit %A %s]; break"
}

::itcl::body Command::vi_overwrite_mode {} {
    set w $itk_component(text)
    bind $w <BackSpace> "[::itcl::code $this backward_delete_char]; break"
    bind $w <space> "[::itcl::code $this delete_char]; %W insert insert %A; break"
    bind $w <KeyPress> "[::itcl::code $this vi_process_overwrite %A %s]; break"
}

::itcl::body Command::vi_insert_mode {} {
    set w $itk_component(text)
    bind $w <BackSpace> "[::itcl::code $this backward_delete_char]; break"
    bind $w <space> {}
    bind $w <KeyPress> {}
}

::itcl::body Command::vi_process_edit {c state} {
    set w $itk_component(text)

    # Throw away all non-visible characters
    if {![string match \[!-~\] $c] || $state > 1} {
	return
    }

    if {$overwrite_flag} {
	delete_char
	$w insert insert $c
	set overwrite_flag 0

	return
    }

    switch $search_flag {
	f {
	    set search_dir forward
	    set search_char $c
	    set newindex [$w search $c {insert + 1c} {end - 2c}]
	    if {$newindex != ""} {
		if {$delete_flag} {
		    $w delete insert $newindex+1c
		} elseif {$change_flag} {
		    $w delete insert $newindex+1c
		    vi_insert_mode
		} else {
		    $w mark set insert $newindex
		}

		cursor_highlight
	    }

	    set delete_flag 0
	    set change_flag 0
	    set search_flag 0

	    return
	}
	F {
	    set search_dir backward
	    set search_char $c
	    set newindex [$w search -backwards $c {insert - 1c} promptEnd]
	    if {$newindex != ""} {
		if {$delete_flag} {
		    $w delete $newindex insert
		} elseif {$change_flag} {
		    $w delete $newindex insert
		    vi_insert_mode
		} else {
		    $w mark set insert $newindex
		}

		cursor_highlight
	    }

	    set delete_flag 0
	    set change_flag 0
	    set search_flag 0

	    return
	}
    }

    switch $c {
	; {
	    set delete_flag 0
	    if {$search_char == ""} {
		return
	    }

	    switch $search_dir {
		forward {
		    set newindex [$w search $search_char {insert + 1c} {end - 2c}]
		    if {$newindex != ""} {
			if {$delete_flag} {
			    $w delete insert $newindex+1c
			    set delete_flag 0
			} elseif {$change_flag} {
			    $w delete insert $newindex+1c
			    vi_insert_mode
			    set change_flag 0
			} else {
			    $w mark set insert $newindex
			}
			cursor_highlight
		    }
		}
		backward {
		    set newindex [$w search -backwards $search_char {insert - 1c} promptEnd]
		    if {$newindex != ""} {
			if {$delete_flag} {
			    $w delete $newindex insert
			    set delete_flag 0
			} elseif {$change_flag} {
			    $w delete $newindex insert
			    vi_insert_mode
			    set change_flag 0
			} else {
			    $w mark set insert $newindex
			}
			cursor_highlight
		    }
		}
	    }
	}
	, {
	    set delete_flag 0
	    if {$search_char == ""} {
		return
	    }

	    switch $search_dir {
		backward {
		    set newindex [$w search $search_char {insert + 1c} {end - 2c}]
		    if {$newindex != ""} {
			if {$delete_flag} {
			    $w delete insert $newindex+1c
			    set delete_flag 0
			} elseif {$change_flag} {
			    $w delete insert $newindex+1c
			    vi_insert_mode
			    set change_flag 0
			} else {
			    $w mark set insert $newindex
			}
			cursor_highlight
		    }
		}
		forward {
		    set newindex [$w search -backwards $search_char {insert - 1c} promptEnd]
		    if {$newindex != ""} {
			if {$delete_flag} {
			    $w delete $newindex insert
			    set delete_flag 0
			} elseif {$change_flag} {
			    $w delete $newindex insert
			    vi_insert_mode
			    set change_flag 0
			} else {
			    $w mark set insert $newindex
			}
			cursor_highlight
		    }
		}
	    }
	}
	0 {
	    if {$delete_flag} {
		delete_beginning_of_line
		set delete_flag 0
	    } elseif {$change_flag} {
		delete_beginning_of_line
		vi_insert_mode
		set change_flag 0
	    } else {
		beginning_of_line
	    }
	}
	a {
	    forward_char
	    vi_insert_mode
	    set delete_flag 0
	    set change_flag 0
	}
	b {
	    if {$delete_flag} {
		backward_delete_word
		set delete_flag 0
	    } elseif {$change_flag} {
		backward_delete_word
		vi_insert_mode
		set change_flag 0
	    } else {
		backward_word
	    }
	}
	c {
	    if {$change_flag} {
		delete_line
		vi_insert_mode
		set change_flag 0
	    } else {
		set change_flag 1
	    }
	    set delete_flag 0
	}
	d {
	    if {$delete_flag} {
		delete_line
		set delete_flag 0
	    } else {
		set delete_flag 1
	    }
	    set change_flag 0
	}
	e {
	    if {$delete_flag} {
		delete_end_word
	    } elseif {$change_flag} {
		delete_end_word
		vi_insert_mode
		set change_flag 0
	    } else {
		end_word
	    }
	    set delete_flag 0
	}
	f {
	    set search_flag f
	}
	h {
	    if {$delete_flag} {
		backward_delete_char
		set delete_flag 0
	    } elseif {$change_flag} {
		backward_delete_char
		vi_insert_mode
		set change_flag 0
	    } else {
		backward_char
	    }
	}
	i {
	    vi_insert_mode
	    set delete_flag 0
	    set change_flag 0
	}
	j {
	    next
	    set delete_flag 0
	    set change_flag 0
	}
	k {
	    prev
	    set delete_flag 0
	    set change_flag 0
	}
	l {
	    if {$delete_flag} {
		delete_char
		set delete_flag 0
	    } elseif {$change_flag} {
		delete_char
		vi_insert_mode
		set change_flag 0
	    } else {
		forward_char
	    }
	}
	r {
	    set overwrite_flag 1
	    set delete_flag 0
	    set change_flag 0
	}
	s {
	    delete_char
	    vi_insert_mode
	    set delete_flag 0
	    set change_flag 0
	}
	w {
	    if {$delete_flag} {
		delete_word
		set delete_flag 0
	    } elseif {$change_flag} {
		delete_word
		vi_insert_mode
		set change_flag 0
	    } else {
		forward_word
	    }
	}
	x {
	    delete_char
	    set delete_flag 0
	    set change_flag 0
	}
	A {
	    end_of_line
	    vi_insert_mode
	    set delete_flag 0
	    set change_flag 0
	}
	C {
	    delete_end_of_line
	    vi_insert_mode
	    set delete_flag 0
	    set change_flag 0
	}
	D {
	    delete_end_of_line
	    set delete_flag 0
	    set change_flag 0
	}
	F {
	    set search_flag F
	}
	I {
	    beginning_of_line
	    vi_insert_mode
	    set delete_flag 0
	    set change_flag 0
	}
	R {
	    vi_overwrite_mode
	    set delete_flag 0
	    set change_flag 0
	}
	X {
	    backward_delete_char
	    set delete_flag 0
	    set change_flag 0
	}
	$ {
	    if {$delete_flag} {
		delete_end_of_line
		set delete_flag 0
	    } elseif {$change_flag} {
		delete_end_of_line
		vi_insert_mode
		set change_flag 0
	    } else {
		end_of_line
	    }
	}
	default {
	    set delete_flag 0
	    set change_flag 0
	}
    }
}

::itcl::body Command::vi_process_overwrite {c state} {
    set w $itk_component(text)
    # Throw away all non-visible characters
    if {![string match \[!-~\] $c] || $state > 1} {
	return
    }

    delete_char
    $w insert insert $c
}
# End - VI Specific Callbacks


::itcl::body Command::text_op_begin {x y} {
    set w $itk_component(text)
    global mged_gui

    set moveView 0
    $w scan mark $x $y
}

::itcl::body Command::text_paste {} {
    set w $itk_component(text)

    if {!$moveView} {
	catch {$w insert insert [selection get -displayof $w]}
	$w see insert
    }

    if {[$w cget -state] == "normal"} {
	focus $w
    }
}

::itcl::body Command::text_scroll {x y} {
    set w $itk_component(text)

    set moveView 1
    $w scan dragto $x $y
}

::itcl::body Command::selection_begin {x y} {
    set w $itk_component(text)
    $w mark set anchor [::tk::TextClosestGap $w $x $y]
    $w tag remove sel 0.0 end

    if {[$w cget -state] == "normal"} {
	focus $w
    }
}

::itcl::body Command::selection_add {x y} {
    set w $itk_component(text)
    set cur [::tk::TextClosestGap $w $x $y]

    if [catch {$w index anchor}] {
	$w mark set anchor $cur
    }

    if [$w compare $cur < anchor] {
	set first $cur
	set last anchor
    } else {
	set first anchor
	set last $cur
    }

    $w tag remove sel 0.0 $first
    $w tag add sel $first $last
    $w tag remove sel $last end
}

::itcl::body Command::select_word {x y} {
    set w $itk_component(text)
    set cur [::tk::TextClosestGap $w $x $y]

    if [catch {$w index anchor}] {
	$w mark set anchor $cur
    }

    if [$w compare $cur < anchor] {
	set first [::tk::TextPrevPos $w "$cur + 1c" tcl_wordBreakBefore]
	set last [::tk::TextNextPos $w "anchor" tcl_wordBreakAfter]
    } else {
	set first [::tk::TextPrevPos $w anchor tcl_wordBreakBefore]
	set last [::tk::TextNextPos $w "$cur - 1c" tcl_wordBreakAfter]
    }

    $w tag remove sel 0.0 $first
    $w tag add sel $first $last
    $w tag remove sel $last end
}

::itcl::body Command::select_line {x y} {
    set w $itk_component(text)
    set cur [::tk::TextClosestGap $w $x $y]

    if [catch {$w index anchor}] {
	$w mark set anchor $cur
    }

    if [$w compare $cur < anchor] {
	set first [$w index "$cur linestart"]
	set last [$w index "anchor - 1c lineend + 1c"]
    } else {
	set first [$w index "anchor linestart"]
	set last [$w index "$cur lineend + 1c"]
    }

    $w tag remove sel 0.0 $first
    $w tag add sel $first $last
    $w tag remove sel $last end
}

::itcl::body Command::selection_modify {x y} {
    set w $itk_component(text)
    ::tk::TextResetAnchor $w @@$x,$y
    selection_add $x $y
}

::itcl::body Command::print {str} {
    set w $itk_component(text)
    $w insert insert $str
}

::itcl::body Command::print_prompt {} {
    set w $itk_component(text)
    print_tag $itk_option(-prompt) prompt
    $w mark set promptEnd insert
    $w mark gravity promptEnd left
}

::itcl::body Command::print_prompt2 {} {
    set w $itk_component(text)
    $w insert insert $itk_option(-prompt2)
}

::itcl::body Command::print_tag {str tag} {
    set w $itk_component(text)
    set first [$w index insert]
    $w insert insert $str
    set last [$w index insert]
    $w tag add $tag $first $last
}

::itcl::body Command::cursor_highlight {} {
    set w $itk_component(text)
    $w tag delete hlt
    $w tag add hlt insert
    $w tag configure hlt -background yellow
}

::itcl::body Command::doBindings {} {
    set w $itk_component(text)
    bind $w <Enter> "focus $w; break"

    doKeyBindings
    doButtonBindings
}

::itcl::body Command::doKeyBindings {} {
    set w $itk_component(text)
    switch $itk_option(-edit_style) {
	vi {
	    vi_insert_mode

	    bind $w <Escape> "[::itcl::code $this vi_edit_mode]; break"
	    bind $w <Control-d> "break"
	    bind $w <Control-u> "[::itcl::code $this delete_beginning_of_line]; break"
	}
	default
	    -
	emacs {
	    bind $w <Escape> "break"
	    bind $w <Control-d> "[::itcl::code $this delete_char]; break"
	    bind $w <Control-u> "[::itcl::code $this delete_line]; break"
	    bind $w <BackSpace> "[::itcl::code $this backward_delete_char]; break"
	    bind $w <space> {}
	    bind $w <KeyPress> {}
	}
    }

# Common Key Bindings
    bind $w <Return> "[::itcl::code $this doReturn]; break"
    bind $w <KP_Enter> "[::itcl::code $this doReturn]; break"
    bind $w <Delete> "[::itcl::code $this backward_delete_char]; break"
    bind $w <Left> "[::itcl::code $this doLeft]; break"
    bind $w <Right> "[::itcl::code $this doRight]; break"
    bind $w <Control-a> "[::itcl::code $this doControl_a]; break"
    bind $w <Control-b> "[::itcl::code $this backward_char]; break"
    bind $w <Control-c> "[::itcl::code $this doControl_c]; break"
    bind $w <Control-e> "[::itcl::code $this end_of_line]; break"
    bind $w <Control-f> "[::itcl::code $this forward_char]; break"
    bind $w <Control-k> "[::itcl::code $this delete_end_of_line]; break"
    bind $w <Control-n> "[::itcl::code $this next]; break"
    bind $w <Control-o> "break"
    bind $w <Control-p> "[::itcl::code $this prev]; break"
    bind $w <Control-t> "[::itcl::code $this transpose]; break"
    bind $w <Control-w> "[::itcl::code $this backward_delete_word]; break"
    bind $w <Up> "[::itcl::code $this prev]; break"
    bind $w <Down> "[::itcl::code $this next]; break"
    bind $w <Home> "[::itcl::code $this beginning_of_line]; break"
    bind $w <End> "[::itcl::code $this end_of_line]; break"
    bind $w <Meta-d> "[::itcl::code $this doMeta_d]; break"
    bind $w <Meta-BackSpace> "[::itcl::code $this doMeta_BackSpace]; break"

    bind $w <Alt-Key> {
	::tk::TraverseToMenu %W %A
	break
    }
}

::itcl::body Command::doButtonBindings {} {
    set w $itk_component(text)
    bind $w <1> "[::itcl::code $this selection_begin %x %y]; break"
    bind $w <B1-Motion> "[::itcl::code $this selection_add %x %y]; break"
    bind $w <Double-1> "[::itcl::code $this select_word %x %y]; break"
    bind $w <Triple-1> "[::itcl::code $this select_line %x %y]; break"
    bind $w <Shift-1> "[::itcl::code $this selection_modify %x %y]; break"

    bind $w <Double-Shift-1> {
	break
    }

    bind $w <Triple-Shift-1> {
	break
    }

    bind $w <B1-Leave> {
	break
    }

    bind $w <B1-Enter> {
	break
    }

    bind $w <ButtonRelease-1> {
	break
    }

    bind $w <Control-1> {
	break
    }

    bind $w <ButtonRelease-2> "[::itcl::code $this text_paste]; break"
    bind $w <2> "[::itcl::code $this text_op_begin %x %y]; break"
    bind $w <B2-Motion> "[::itcl::code $this text_scroll %x %y]; break"
}

::itcl::body Command::doControl_a {} {
    if {$itk_option(-edit_style) == "vi"} {
	first_char_in_line
    } else {
	beginning_of_line
    }
}

::itcl::body Command::doControl_c {} {
    interrupt
    if {$itk_option(-edit_style) == "vi"} {
	vi_insert_mode
    }
}

::itcl::body Command::doMeta_d {} {
    if [%W compare insert < promptEnd] {
	break
    }
    cursor_highlight
}

::itcl::body Command::doMeta_BackSpace {} {
    if [%W compare insert <= promptEnd] {
	break
    }
    cursor_highlight
}

::itcl::body Command::doReturn {} {
    execute
    if {$itk_option(-edit_style) == "vi"} {
	vi_insert_mode
    }
}

::itcl::body Command::doLeft {} {
    backward_char
    if {$itk_option(-edit_style) == "vi"} {
	vi_edit_mode
    }
}

::itcl::body Command::doRight {} {
    forward_char
    if {$itk_option(-edit_style) == "vi"} {
	vi_edit_mode
    }
}
@


1.17
log
@Bob Parker's view modifications, png framebuffer support, shaded drawing mode
@
text
@@


1.16
log
@update copyright to include span through 2003
@
text
@d23 2
a24 2
class Command {
    inherit iwidgets::Scrolledtext
d110 1
a110 1
configbody Command::edit_style {
d114 1
a114 1
configbody Command::cmd_prefix {
d137 1
a137 1
configbody Command::selection_color {
d141 1
a141 1
configbody Command::prompt_color {
d145 1
a145 1
configbody Command::cmd_color {
d149 1
a149 1
configbody Command::oldcmd_color {
d153 1
a153 1
configbody Command::result_color {
d157 1
a157 1
configbody Command::maxlines {
d163 1
a163 1
body Command::constructor {args} {
d184 1
a184 1
body Command::destructor {} {
d191 1
a191 1
body Command::history {} {
d195 1
a195 1
body Command::edit_style {args} {
d212 1
a212 1
body Command::putstring {str} {
d238 1
a238 1
body Command::invoke {} {
d287 1
a287 1
body Command::first_char_in_line {} {
d297 1
a297 1
body Command::beginning_of_line {} {
d303 1
a303 1
body Command::end_of_line {} {
d310 1
a310 1
body Command::backward_char {} {
d318 1
a318 1
body Command::forward_char {} {
d326 1
a326 1
body Command::backward_word {} {
d338 1
a338 1
body Command::forward_word {} {
d347 1
a347 1
body Command::end_word {} {
d359 1
a359 1
body Command::backward_delete_char {} {
d369 1
a369 1
body Command::delete_char {} {
d378 1
a378 1
body Command::backward_delete_word {} {
d389 1
a389 1
body Command::delete_word {} {
d401 1
a401 1
body Command::delete_end_word {} {
d413 1
a413 1
body Command::delete_line {} {
d419 1
a419 1
body Command::delete_end_of_line {} {
d425 1
a425 1
body Command::delete_beginning_of_line {} {
d431 1
a431 1
body Command::next {} {
d455 1
a455 1
body Command::prev {} {
d476 1
a476 1
body Command::transpose {} {
d493 1
a493 1
body Command::execute {} {
d506 1
a506 1
body Command::interrupt {} {
d519 1
a519 1
body Command::vi_edit_mode {} {
d521 3
a523 3
    bind $w <BackSpace> "[code $this backward_char]; break"
    bind $w <space> "[code $this forward_char]; break"
    bind $w <KeyPress> "[code $this vi_process_edit %A %s]; break"
d526 1
a526 1
body Command::vi_overwrite_mode {} {
d528 3
a530 3
    bind $w <BackSpace> "[code $this backward_delete_char]; break"
    bind $w <space> "[code $this delete_char]; %W insert insert %A; break"
    bind $w <KeyPress> "[code $this vi_process_overwrite %A %s]; break"
d533 1
a533 1
body Command::vi_insert_mode {} {
d535 1
a535 1
    bind $w <BackSpace> "[code $this backward_delete_char]; break"
d540 1
a540 1
body Command::vi_process_edit {c state} {
d874 1
a874 1
body Command::vi_process_overwrite {c state} {
d887 1
a887 1
body Command::text_op_begin {x y} {
d895 1
a895 1
body Command::text_paste {} {
d908 1
a908 1
body Command::text_scroll {x y} {
d915 1
a915 1
body Command::selection_begin {x y} {
d925 1
a925 1
body Command::selection_add {x y} {
d946 1
a946 1
body Command::select_word {x y} {
d967 1
a967 1
body Command::select_line {x y} {
d988 1
a988 1
body Command::selection_modify {x y} {
d994 1
a994 1
body Command::print {str} {
d999 1
a999 1
body Command::print_prompt {} {
d1006 1
a1006 1
body Command::print_prompt2 {} {
d1011 1
a1011 1
body Command::print_tag {str tag} {
d1019 1
a1019 1
body Command::cursor_highlight {} {
d1026 1
a1026 1
body Command::doBindings {} {
d1034 1
a1034 1
body Command::doKeyBindings {} {
d1040 1
a1040 1
	    bind $w <Escape> "[code $this vi_edit_mode]; break"
d1042 1
a1042 1
	    bind $w <Control-u> "[code $this delete_beginning_of_line]; break"
d1048 3
a1050 3
	    bind $w <Control-d> "[code $this delete_char]; break"
	    bind $w <Control-u> "[code $this delete_line]; break"
	    bind $w <BackSpace> "[code $this backward_delete_char]; break"
d1057 12
a1068 12
    bind $w <Return> "[code $this doReturn]; break"
    bind $w <KP_Enter> "[code $this doReturn]; break"
    bind $w <Delete> "[code $this backward_delete_char]; break"
    bind $w <Left> "[code $this doLeft]; break"
    bind $w <Right> "[code $this doRight]; break"
    bind $w <Control-a> "[code $this doControl_a]; break"
    bind $w <Control-b> "[code $this backward_char]; break"
    bind $w <Control-c> "[code $this doControl_c]; break"
    bind $w <Control-e> "[code $this end_of_line]; break"
    bind $w <Control-f> "[code $this forward_char]; break"
    bind $w <Control-k> "[code $this delete_end_of_line]; break"
    bind $w <Control-n> "[code $this next]; break"
d1070 9
a1078 9
    bind $w <Control-p> "[code $this prev]; break"
    bind $w <Control-t> "[code $this transpose]; break"
    bind $w <Control-w> "[code $this backward_delete_word]; break"
    bind $w <Up> "[code $this prev]; break"
    bind $w <Down> "[code $this next]; break"
    bind $w <Home> "[code $this beginning_of_line]; break"
    bind $w <End> "[code $this end_of_line]; break"
    bind $w <Meta-d> "[code $this doMeta_d]; break"
    bind $w <Meta-BackSpace> "[code $this doMeta_BackSpace]; break"
d1086 1
a1086 1
body Command::doButtonBindings {} {
d1088 5
a1092 5
    bind $w <1> "[code $this selection_begin %x %y]; break"
    bind $w <B1-Motion> "[code $this selection_add %x %y]; break"
    bind $w <Double-1> "[code $this select_word %x %y]; break"
    bind $w <Triple-1> "[code $this select_line %x %y]; break"
    bind $w <Shift-1> "[code $this selection_modify %x %y]; break"
d1118 3
a1120 3
    bind $w <ButtonRelease-2> "[code $this text_paste]; break"
    bind $w <2> "[code $this text_op_begin %x %y]; break"
    bind $w <B2-Motion> "[code $this text_scroll %x %y]; break"
d1123 1
a1123 1
body Command::doControl_a {} {
d1131 1
a1131 1
body Command::doControl_c {} {
d1138 1
a1138 1
body Command::doMeta_d {} {
d1145 1
a1145 1
body Command::doMeta_BackSpace {} {
d1152 1
a1152 1
body Command::doReturn {} {
d1159 1
a1159 1
body Command::doLeft {} {
d1166 1
a1166 1
body Command::doRight {} {
@


1.15
log
@*** empty log message ***
@
text
@d16 1
a16 1
#       This software is Copyright (C) 1998 by the United States Army
@


1.15.6.1
log
@merge from HEAD
@
text
@d16 1
a16 1
#       This software is Copyright (C) 1998-2004 by the United States Army
@


1.14
log
@Mods from Bob Parker:
	- Mods to the "invoke" method to better handle braces in incomplete commands
          (i.e. the user is building a proc across multiple lines) when the
          cmd_prefix is not the empty string.

        - Added support for the -prompt2 option. The itk_option(-prompt2) string
          will be used when the command is in an incomplete state.
@
text
@d917 1
a917 1
    $w mark set anchor [tkTextClosestGap $w $x $y]
d927 1
a927 1
    set cur [tkTextClosestGap $w $x $y]
d948 1
a948 1
    set cur [tkTextClosestGap $w $x $y]
d955 2
a956 2
	set first [tkTextPrevPos $w "$cur + 1c" tcl_wordBreakBefore]
	set last [tkTextNextPos $w "anchor" tcl_wordBreakAfter]
d958 2
a959 2
	set first [tkTextPrevPos $w anchor tcl_wordBreakBefore]
	set last [tkTextNextPos $w "$cur - 1c" tcl_wordBreakAfter]
d969 1
a969 1
    set cur [tkTextClosestGap $w $x $y]
d990 1
a990 1
    tkTextResetAnchor $w @@$x,$y
d1081 1
a1081 1
	tkTraverseToMenu %W %A
@


1.14.4.1
log
@sync branch with HEAD
@
text
@d16 1
a16 1
#       This software is Copyright (C) 1998-2004 by the United States Army
d917 1
a917 1
    $w mark set anchor [::tk::TextClosestGap $w $x $y]
d927 1
a927 1
    set cur [::tk::TextClosestGap $w $x $y]
d948 1
a948 1
    set cur [::tk::TextClosestGap $w $x $y]
d955 2
a956 2
	set first [::tk::TextPrevPos $w "$cur + 1c" tcl_wordBreakBefore]
	set last [::tk::TextNextPos $w "anchor" tcl_wordBreakAfter]
d958 2
a959 2
	set first [::tk::TextPrevPos $w anchor tcl_wordBreakBefore]
	set last [::tk::TextNextPos $w "$cur - 1c" tcl_wordBreakAfter]
d969 1
a969 1
    set cur [::tk::TextClosestGap $w $x $y]
d990 1
a990 1
    ::tk::TextResetAnchor $w @@$x,$y
d1081 1
a1081 1
	::tk::TraverseToMenu %W %A
@


1.14.6.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d917 1
a917 1
    $w mark set anchor [::tk::TextClosestGap $w $x $y]
d927 1
a927 1
    set cur [::tk::TextClosestGap $w $x $y]
d948 1
a948 1
    set cur [::tk::TextClosestGap $w $x $y]
d955 2
a956 2
	set first [::tk::TextPrevPos $w "$cur + 1c" tcl_wordBreakBefore]
	set last [::tk::TextNextPos $w "anchor" tcl_wordBreakAfter]
d958 2
a959 2
	set first [::tk::TextPrevPos $w anchor tcl_wordBreakBefore]
	set last [::tk::TextNextPos $w "$cur - 1c" tcl_wordBreakAfter]
d969 1
a969 1
    set cur [::tk::TextClosestGap $w $x $y]
d990 1
a990 1
    ::tk::TextResetAnchor $w @@$x,$y
d1081 1
a1081 1
	::tk::TraverseToMenu %W %A
@


1.14.6.2
log
@sync to HEAD...
@
text
@d16 1
a16 1
#       This software is Copyright (C) 1998-2004 by the United States Army
@


1.13
log
@*- added putstring method
@
text
@d1 1
a1 1
##                 C O M M A N D . T C L
d31 1
d81 1
d237 1
d242 4
d249 7
a255 4
	set cname [lindex $cmd 0]
	set cindex [lsearch -exact $cmdlist $cname]
	if {$cindex != -1} {
	    set cmd [concat $itk_option(-cmd_prefix) $cmd]
d281 2
d1004 5
@


1.12
log
@*- fix for BackSpace, Delete and Ctrl-d
   (the cut-buffer was getting cleared)
@
text
@d41 1
d210 24
d243 1
a243 1
	set cindex [lsearch $cmdlist $cname]
@


1.11
log
@*- mods to cmd_prefix's configbody
@
text
@d324 1
a324 1
    catch {$w tag remove sel sel.first promptEnd}
d334 1
a334 1
    catch {$w tag remove sel sel.first promptEnd}
@


1.10
log
@*- mods to config_body for cmd_prefix
@
text
@d129 1
a129 1
	set cmdlist [$itk_option(-cmd_prefix) getUserCmds]
@


1.9
log
@Add -maxlines option which is used
to purge command window of old text.
@
text
@d117 13
a129 3
    set bad [catch {eval $itk_option(-cmd_prefix) info function} _cmdlist]
    if {$bad} {
	error "Bad command prefix: no related functions"
a131 6
    set bad [catch {eval $itk_option(-cmd_prefix) info class} class]
    if {$bad} {
	error "Bad command prefix: no class"
    }
    # strip off class
    set cmdlist [string map "$class\:: \"\"" $_cmdlist]
@


1.8
log
@Mods to the invoke method.
@
text
@d37 1
d150 6
d236 6
@


1.7
log
@*- remove args parameter from history method
@
text
@d116 1
a116 1
    set bad [catch {$itk_option(-cmd_prefix) info function} cmdlist]
d118 1
a118 1
	return -code error "Bad command prefix: no related functions"
d121 1
a121 1
    set bad [catch {$itk_option(-cmd_prefix) info class} class]
d123 1
a123 1
	return -code error "Bad command prefix: no class"
d126 1
a126 1
    set cmdlist [string map "$class\:: \"\"" $cmdlist]
d193 1
a193 1
	    return -code error "Bad edit_style - $args"
d198 1
a198 1
############################## Protected/Private Method  ##############################
d203 1
d205 1
a205 5
    if {$itk_option(-cmd_prefix) == ""} {
	set hcmd $cmd
    } else {
	set hcmd $cmd

a211 1

@


1.7.2.1
log
@Make use of Help object.
@
text
@d116 1
a116 1
    set bad [catch {eval $itk_option(-cmd_prefix) info function} _cmdlist]
d118 1
a118 1
	error "Bad command prefix: no related functions"
d121 1
a121 1
    set bad [catch {eval $itk_option(-cmd_prefix) info class} class]
d123 1
a123 1
	error "Bad command prefix: no class"
d126 1
a126 1
    set cmdlist [string map "$class\:: \"\"" $_cmdlist]
d193 1
a193 1
	    error "Bad edit_style - $args"
d198 1
a198 1
############################## Protected/Private Methods  ##############################
a202 1
    set hcmd $cmd
d204 5
a208 1
    if {$itk_option(-cmd_prefix) != ""} {
d215 1
@


1.7.2.2
log
@Add -maxlines option which is used to
purge command window of old text.
@
text
@a36 1
    itk_option define -maxlines maxlines MaxLines 1000
a148 6
configbody Command::maxlines {
    if {$itk_option(-maxlines) < 1} {
	error "-maxlines must be greater than zero"
    }
}

a228 6

	# get rid of oldest output
	set nlines [expr int([$w index end])]
	if {$nlines > $itk_option(-maxlines)} {
	    $w delete 1.0 [expr $nlines - $itk_option(-maxlines)].end
	}
@


1.7.2.3
log
@*- mods to configbody for cmd_prefix
@
text
@d117 4
a120 5
    # if getUserCmds doesn't exist, use all recognized functions
    if {[catch {eval $itk_option(-cmd_prefix) info function getUserCmds}]} {
	if {[catch {eval $itk_option(-cmd_prefix) info function} _cmdlist]} {
	    error "Bad command prefix: no related functions"
	}
d122 3
a124 7
	# strip off namespace
	set cmdlist ""
	foreach cmd $_cmdlist {
	    lappend cmdlist [namespace tail $cmd]
	}
    } else {
	set cmdlist [$itk_option(-cmd_prefix) getUserCmds]
d126 2
a127 1

@


1.6
log
@*- add method: edit_style
@
text
@d38 1
a38 1
    public method history {args}
d177 2
a178 2
body Command::history {args} {
    eval $hist history $args
@


1.5
log
@*- configbody Command::cmd_prefix builds a list of
   commands recognized by cmd_prefix
*- modify Command::invoke to check cmd_prefix's command list
   before prepending cmd_prefix
@
text
@d39 1
d107 1
a107 10
    switch $itk_option(-edit_style) {
	emacs -
	vi {
	    doKeyBindings
	}
	default {
	    return -code error "Bad edit_style"
	}
    }

d175 24
a1115 5
}

############################## Command Object's Interface ##############################
body Command::history {args} {
    eval $hist history $args
@


1.4
log
@*- turn prompt, edit_style and cmd_prefix into itk_option's
@
text
@d92 1
d118 19
d186 14
a199 1
    set cmd [concat $itk_option(-cmd_prefix) [$w get promptEnd insert]]
d215 1
a215 1
	$hist add $cmd
@


1.3
log
@*- define color options
@
text
@a25 21
    private variable hist ""
    private variable scratchline ""
    private variable moveView 0
    private variable freshline 1

    private variable overwrite_flag 0
    private variable change_flag 0
    private variable delete_flag 0
    private variable search_flag 0
    private variable search_char ""
    private variable search_dir ""

    public variable edit_style emacs
    public variable prompt "> "
    public variable cmd_prefix ""
#    public variable selection_color #fefe8e
#    public variable prompt_color red1
#    public variable cmd_color black
#    public variable oldcmd_color red3
#    public variable result_color blue3

d29 3
d38 2
d91 11
a101 1
    public method history {args}
d105 1
a105 1
    switch $edit_style {
d138 2
a150 2
	eval itk_initialize $args

d166 1
a166 1
    set cmd [concat $cmd_prefix [$w get promptEnd insert]]
a179 3

#	    distribute_text $w $cmd $msg
#	    stuff_str "\nmged:$id> $cmd\n$msg"
d902 1
a902 1
    print_tag $prompt prompt
d932 1
a932 1
    switch $edit_style {
d1020 1
a1020 1
    if {$edit_style == "vi"} {
d1029 1
a1029 1
    if {$edit_style == "vi"} {
d1050 1
a1050 1
    if {$edit_style == "vi"} {
d1057 1
a1057 1
    if {$edit_style == "vi"} {
d1064 1
a1064 1
    if {$edit_style == "vi"} {
@


1.2
log
@*- modify vi stuff
*- add configbody's for public variables
*- add history command
*- and assorted methods for handling specific events
@
text
@d41 14
a54 29
    public variable selection_color #fefe8e
    public variable prompt_color red1
    public variable cmd_color black
    public variable oldcmd_color red3
    public variable result_color blue3

    constructor {args} {
	eval itk_initialize $args
	doBindings

	# create command history object
	set hist [string map {:: "" . _} $this]
	set hist [ch_open [subst $hist]_hist]

	# initialize text widget
	print_prompt
	$itk_component(text) insert insert " "
	beginning_of_line

	$itk_component(text) tag configure sel -background $selection_color
	$itk_component(text) tag configure prompt -foreground $prompt_color
	$itk_component(text) tag configure oldcmd -foreground $oldcmd_color
	$itk_component(text) tag configure result -foreground $result_color
    }

    destructor {
	# destroy command history object
	rename $hist ""
    }
d124 1
a124 1
	$itk_component(text) tag configure sel -foreground $selection_color
d128 1
a128 1
	$itk_component(text) tag configure prompt -foreground $prompt_color
d132 1
a132 1
	$itk_component(text) tag configure cmd -foreground $cmd_color
d136 1
a136 1
	$itk_component(text) tag configure oldcmd -foreground $oldcmd_color
d140 27
a166 1
	$itk_component(text) tag configure result -foreground $result_color
@


1.1
log
@Command Window Object
	- this is not quite ready; just being safe
@
text
@a27 1
    private variable cmd_prefix ""
d40 2
a41 1
    public variable db_glob 0
d43 1
a45 1
    public variable selection_color #fefe8e
d115 8
d127 1
a127 2
	emacs {
	}
d129 1
d135 21
d164 1
a164 6
	if {$db_glob} {
	    catch {db_glob $cmd} globbed_cmd
	    set result [catch {uplevel #0 $globbed_cmd} msg]
	} else {
	    set result [catch {uplevel #0 $cmd} msg]
	}
a180 1
	set cmd_prefix ""
a407 1
    set cmd_prefix ""
d629 1
a629 1
		delete_line $w
d638 1
a638 1
		delete_end_word $w
d640 2
a641 2
		delete_end_word $w
		vi_insert_mode $w
d644 1
a644 1
		end_word $w
d653 1
a653 1
		backward_delete_char $w
d656 2
a657 2
		backward_delete_char $w
		vi_insert_mode $w
d660 1
a660 1
		backward_char $w
d664 1
a664 1
	    vi_insert_mode $w
d669 1
a669 1
	    next $w
d674 1
a674 1
	    prev $w
d680 1
a680 1
		delete_char $w
d683 2
a684 2
		delete_char $w
		vi_insert_mode $w
d687 1
a687 1
		forward_char $w
d696 2
a697 2
	    delete_char $w
	    vi_insert_mode $w
d703 1
a703 1
		delete_word $w
d706 2
a707 2
		delete_word $w
		vi_insert_mode $w
d710 1
a710 1
		forward_word $w
d714 1
a714 1
	    delete_char $w
d719 2
a720 2
	    end_of_line $w
	    vi_insert_mode $w
d725 2
a726 2
	    delete_end_of_line $w
	    vi_insert_mode $w
d731 1
a731 1
	    delete_end_of_line $w
d739 2
a740 2
	    beginning_of_line $w
	    vi_insert_mode $w
d745 1
a745 1
	    vi_overwrite_mode $w
d750 1
a750 1
	    backward_delete_char $w
d756 1
a756 1
		delete_end_of_line $w
d759 2
a760 2
		delete_end_of_line $w
		vi_insert_mode $w
d763 1
a763 1
		end_of_line $w
d780 1
a780 1
    delete_char $w
d934 3
a936 39
	    bind $w <Escape> {
		[code $this vi_edit_mode]
		break
	    }

	    bind $w <Left> {
		[code $this backward_char; vi_edit_mode]
		break
	    }

	    bind $w <Right> {
		[code $this forward_char; vi_edit_mode]
		break
	    }


	    bind $w <Control-d> {
		break
	    }

	    bind $w <Control-u> {
		[code $this delete_beginning_of_line]
		break
	    }

	    bind $w <Return> {
		[code $this execute; vi_insert_mode]
		break
	    }

	    bind $w <KP_Enter> {
		[code $this execute; vi_insert_mode]
		break
	    }

	    bind $w <Delete> {
		[code $this backward_delete_char]
		break
	    }
a941 2
	    bind $w <Left> "[code $this backward_char]; break"
	    bind $w <Right> "[code $this forward_char]; break"
a944 3
	    bind $w <Delete> "[code $this backward_delete_char]; break"
	    bind $w <Return> "[code $this execute]; break"
	    bind $w <KP_Enter> "[code $this execute]; break"
d951 5
d958 1
a958 10

    bind $w <Control-c> {
	[code $this
	interrupt
	if {\$edit_style == "vi"} {
	    vi_insert_mode
	}]
	break
    }

d963 1
a963 5

    bind $w <Control-o> {
	break
    }

d971 2
a972 14

    bind $w <Meta-d> {
	if [%W compare insert < promptEnd] {
	    break
	}
	[code $this cursor_highlight]
    }

    bind $w <Meta-BackSpace> {
	if [%W compare insert <= promptEnd] {
	    break
	}
	[code $this cursor_highlight]
    }
d1023 47
@

