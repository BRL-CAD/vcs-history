head	1.10;
access;
symbols
	ansi-20040405-merged:1.7.4.1
	postmerge-20040405-ansi:1.9
	premerge-20040404-ansi:1.9
	postmerge-autoconf:1.9
	autoconf-freeze:1.8.6.1
	premerge-autoconf:1.9
	postmerge-20040315-windows:1.9
	premerge-20040315-windows:1.9
	windows-20040315-freeze:1.7.6.2
	autoconf-20031203:1.8
	autoconf-20031202:1.8
	autoconf-branch:1.8.0.6
	phong-branch:1.8.0.4
	photonmap-branch:1.8.0.2
	rel-6-1-DP:1.7
	windows-branch:1.7.0.6
	rel-6-0-2:1.7
	ansi-branch:1.7.0.4
	rel-6-0-1-branch:1.7.0.2
	hartley-6-0-post:1.7
	hartley-6-0-pre:1.7
	rel-6-0-1:1.7
	rel-6-0:1.7
	rel-5-4:1.6
	offsite-5-3-pre:1.6
	rel-5-3:1.6
	rel-5-2:1.6
	rel-5-1-branch:1.6.0.2
	rel-5-1:1.6
	rel-5-0:1.6
	rel-5-0-beta:1.6
	rel-4-5:1.5;
locks; strict;
comment	@# @;


1.10
date	2004.05.21.16.41.32;	author morrison;	state dead;
branches;
next	1.9;

1.9
date	2004.02.02.17.39.44;	author morrison;	state Exp;
branches;
next	1.8;

1.8
date	2003.03.13.19.45.33;	author jra;	state Exp;
branches
	1.8.6.1;
next	1.7;

1.7
date	2001.11.05.21.20.08;	author morrison;	state Exp;
branches
	1.7.4.1
	1.7.6.1;
next	1.6;

1.6
date	99.01.19.22.31.31;	author bparker;	state Exp;
branches;
next	1.5;

1.5
date	97.11.21.21.44.04;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	96.07.09.19.43.28;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	95.08.10.21.11.09;	author gdurf;	state Exp;
branches;
next	1.2;

1.2
date	95.08.03.21.49.08;	author gdurf;	state Exp;
branches;
next	1.1;

1.1
date	95.07.25.17.54.50;	author gdurf;	state Exp;
branches;
next	;

1.7.4.1
date	2004.03.17.21.23.16;	author morrison;	state Exp;
branches;
next	;

1.7.6.1
date	2002.09.26.23.04.21;	author morrison;	state Exp;
branches;
next	1.7.6.2;

1.7.6.2
date	2004.03.11.23.49.00;	author morrison;	state Exp;
branches;
next	;

1.8.6.1
date	2004.02.12.18.34.49;	author erikg;	state Exp;
branches;
next	;


desc
@Tk widget for creating solids
@


1.10
log
@moved to src/tclscripts/
@
text
@#			S O L C R E A T E . T C L 
#
# Author -
#	Glenn Durfee
#
# Source -
#	The U. S. Army Ballistic Research Laboratory
#	Aberdeen Proving Ground, Maryland  21005
#  
# Distribution Notice -
#	Re-distribution of this software is restricted, as described in
#	your "Statement of Terms and Conditions for the Release of
#	The BRL-CAD Package" agreement.
#
# Copyright Notice -
#	This software is Copyright (C) 1995-2004 by the United States Army
#	in all countries except the USA.  All rights reserved.
#
# Description -
#       Program to allow automated generation and interactive placement of new
#       solids with user-selectable default values.
#
# Modifications -
#        (Bob Parker):
#             Generalized the code to accommodate multiple instances of the
#             user interface.
#

#=============================================================================
# PHASE 0: variable defaults
#=============================================================================

set solc(types) {arb8 sph ell ellg tor tgc rec half rpc rhc epa ehy eto part}
set solc(descr_arb8) "Arbitrary 8-vertex polyhedron"
set solc(default_arb8) {V1 {1 -1 -1}  V2 {1 1 -1}  V3 {1 1 1}  V4 {1 -1 1} \
	V5 {-1 -1 -1} V6 {-1 1 -1} V7 {-1 1 1} V8 {-1 -1 1}}
set solc(descr_sph)  "Sphere"
set solc(default_sph)  {V {0 0 0} A {1 0 0} B {0 1 0} C {0 0 1}}
set solc(descr_ell)  "Ellipsoid"
set solc(default_ell)  {V {0 0 0} A {2 0 0} B {0 1 0} C {0 0 1}}
set solc(descr_ellg) "General Ellipsoid"
set solc(default_ellg) {V {0 0 0} A {4 0 0} B {0 2 0} C {0 0 1}}
set solc(descr_tor)  "Torus"
set solc(default_tor)  {V {0 0 0} H {1 0 0} r_h 2 r_a 1}
set solc(descr_tgc)  "Truncated General Cone"
set solc(default_tgc)  {V {0 0 0} H {0 0 4} A {1 0 0} B {0 .5 0} \
	C {.5 0 0} D {0 1 0}}
set solc(descr_rec)  "Right Elliptical Cylinder"
set solc(default_rec)  {V {0 0 0} H {0 0 4} A {1 0 0} B {0 .5 0} \
	C {1 0 0} D {0 .5 0}}
set solc(descr_half) "Halfspace"		 
set solc(default_half) {N {0 0 1} d -1}
set solc(descr_rpc)  "Right Parabolic Cylinder"
set solc(default_rpc)  {V {-1 -1 -1.5} H {0 0 1} B {0 .5 0} r .25}
set solc(descr_rhc)  "Right Hyperbolic Cylinder"
set solc(default_rhc)  {V {-1 -1 -1.5} H {0 0 1} B {0 .5 0} r .25 c .1}
set solc(descr_epa)  "Elliptical Paraboloid"
set solc(default_epa)  {V {-1 -1 -1.5} H {0 0 1} A {0 1 0} r_1 .5 r_2 .25}
set solc(descr_ehy)  "Right Hyperbolic Cylinder"
set solc(default_ehy)  {V {-1 -1 -1.5} H {0 0 1} A {0 1 0} r_1 .5 r_2 .25 \
	                 c .25}
set solc(descr_eto)  "Elliptical Torus"		 
set solc(default_eto)  {V {-1 -1 -1} N {0 0 1} C {.1 0 .1} r .5 r_d .05}
set solc(descr_part) "Particle Primitive"
set solc(default_part) {V {-1 -1 -.5} H {0 0 1} r_v 0.5 r_h 0.25}

set solc(label,V) "Vertex"
set solc(label,A) "A vector"
set solc(label,B) "B vector"
set solc(label,C) "C vector"
set solc(label,D) "D vector"
set solc(label,H) "H vector"
set solc(label,N) "Normal vector"
set solc(label,c) "c value"
set solc(label,d) "d value"
set solc(label,r) "Radius"
set solc(label,r_a) "Radius a"
set solc(label,r_v) "Radius v"
set solc(label,r_h) "Radius h"
set solc(label,r_1) "Radius 1"
set solc(label,r_2) "Radius 2"
set solc(label,r_d) "Radius d"

set solc(winnum) 0
set solc(default_type) arb8
set solc(default_indexvar) index
set solc(default_operation) "incr index"

#=============================================================================
# PHASE 1: solcreate procedure
#-----------------------------------------------------------------------------
# Makes a toplevel window with the labels, entry fields, and buttons to allow
# the user to create new solids.
#=============================================================================

proc solcreate { id args } {
    global solc
    global $solc(default_indexvar)
    global mged_gui

    set w .solc$solc(winnum)
    incr solc(winnum)

    # Pull the solid type out of the argument list if present

    if { [llength $args]>0 } then {
	set ic(default_type) [lindex $args 0]
    }

    catch { destroy $w }
    toplevel $w -screen $mged_gui($id,screen)
    wm title $w "Primitive Creation"

    # Make three frames: top one for entry fields and labels, middle one for
    # solid creation defaults, and bottom one for create and quit buttons

    frame $w.t
    frame $w.m
    frame $w.b

    pack $w.t $w.m $w.b -side top -fill x -expand yes
    
    # Top frame contains two frames: l (left) and r (right)
    # Left one is for labels and right one is for entry boxes

    frame $w.t.l
    frame $w.t.r

    # Right frame (entry fields) should grow if window width increased

    pack $w.t.l -side left -fill y
    pack $w.t.r -side left -fill x -expand yes

    # Create a label for each entry field

    label $w.t.l.format   -text "Format of name" -anchor w
    label $w.t.l.indexvar -text "Index variable" -anchor w
    label $w.t.l.index    -text "Index" -anchor w
    label $w.t.l.oper     -text "Operation" -anchor w
    label $w.t.l.type     -text "Primitive type" -relief raised -bd 1 -anchor w

    pack $w.t.l.format $w.t.l.indexvar $w.t.l.index $w.t.l.oper $w.t.l.type \
	    -side top -fill both -expand yes -anchor w

    # For the "Primitive type" label, allow left-clicking to get a list of solids

    bind $w.t.l.type <1> "solc_list $w $id"

    # Set up some reasonable defaults for the entry fields
    # If the default index variable does not exist, set it equal to 1

    set solc($w,format) "my$solc(default_type).\$$solc(default_indexvar)"
    if { [catch { set $solc(default_indexvar) }]!=0 } {
	set $solc(default_indexvar) 1
    }
    set solc($w,indexvar) $solc(default_indexvar)
    set solc($w,oper) $solc(default_operation)
    set solc($w,type) $solc(default_type)

    # Create the entry boxes

    entry $w.t.r.format   -relief sunken -width 16 -textvar solc($w,format)
    entry $w.t.r.indexvar -relief sunken -width 16 -textvar solc($w,indexvar)
    entry $w.t.r.index    -relief sunken -width 16 -textvar $solc($w,indexvar)
    entry $w.t.r.oper     -relief sunken -width 16 -textvar solc($w,oper)
    entry $w.t.r.type     -relief sunken -width 16 -textvar solc($w,type)
    
    bind $w.t.r.indexvar <Return> "solc_newvar $w"
    bind $w.t.r.type     <Return> "solc_defaults $w $w.m"

    pack $w.t.r.format $w.t.r.indexvar $w.t.r.index $w.t.r.oper $w.t.r.type \
	    -side top -fill x -expand yes

    solc_defaults $w $w.m

    button $w.b.quit   -text "Quit"   -command "solc_quit $w"
    button $w.b.create -text "Create" -command "solc_create $w"
    pack $w.b.quit $w.b.create -side left -fill x -expand yes

    button $w.accept -text "Accept" -state disabled -command "solc_accept $w"
    pack $w.accept -side top -fill x -expand yes
}

#==============================================================================
# PHASE 2: Support routines
#==============================================================================

# solc_list
# Pops up a list of supported solid types.

proc solc_list { w id } {
    global solc
    global $solc($w,indexvar)
    global mged_gui
    
    catch { destroy $w.slist }
    toplevel $w.slist -screen $mged_gui($id,screen)
    wm title $w.slist "Primitive type list"

    set solc($w,descr) ""

    set doit "set solc($w,type) \[selection get\] ; solc_defaults $w $w.m ; \
	      destroy $w.slist"

    label $w.slist.descr -textvar solc($w,descr)
    listbox $w.slist.l -height [llength $solc(types)] -width 20
    button $w.slist.accept -text "Accept" -command $doit
    foreach soltype [lsort $solc(types)] {
	$w.slist.l insert end $soltype
    }
    pack $w.slist.descr $w.slist.l $w.slist.accept -side top
    set new_descr "catch \{ set solc($w,descr) \
	    \$solc(descr_\[selection get\]) \}"

    bind $w.slist.l <ButtonRelease> $new_descr
    bind $w.slist.descr <1> $doit
    bind $w.slist.l <2> "::tk::ListboxBeginSelect \%W \[\%W index \@@\%x,\%y\] ; \
	    $new_descr"
    bind $w.slist <Return> $doit
}

# solc_newvar
# Called when a new variable is requested.

proc solc_newvar { w } {
    global solc
    global $solc($w,indexvar)

    if { [catch { set $solc($w,indexvar) }] != 0 } then {
	set $solc($w,indexvar) 1
    }
}

# solc_accept

proc solc_accept { w } {
    global solc
    global $solc($w,indexvar)
    
    $w.accept configure -state disabled
    $w.b.create configure -state normal
    press accept
}

proc solc_quit { w } {
    global solc
    global $solc($w,indexvar)

    set solc(default_indexvar) $solc($w,indexvar)
    set solc(default_type) $solc($w,type)
    set solc(default_oper) $solc($w,oper)

    destroy $w
}

proc solc_create { w } {
    global solc
    global $solc($w,indexvar)
    
    # Perform the formatting of the "name format" supplied by the user
    set name [eval list $solc($w,format)]

    # Perform the operation described by the "index operation" supplied by user
    eval $solc($w,oper)

    set solc(default_indexvar) $solc($w,indexvar)
    set solc(default_type) $solc($w,type)
    set solc(default_oper) $solc($w,oper)

    set solc(default_$solc($w,type)) [eval list [set solc($w,do)]]
    press top
    eval db put $name $solc($w,type) [set solc($w,do)]
    e $name
    sed $name
    press sxy

    $w.accept configure -state normal
    $w.b.create configure -state disabled
}

proc solc_defs { type } {
    global solc

    set retval {}
    catch { set retval $solc(default_[string tolower $type]) }

    return $retval
}

proc solc_defaults { w wfr } {
    global solc
    global $solc($w,indexvar)

    catch { eval destroy [winfo children $wfr] }

    if { [catch { db form $solc($w,type) }]!=0 } then {
	return
    }

    label $wfr.header -text "Default values"
    pack $wfr.header -side top -fill x -expand yes -anchor c
    
    set form [db form $solc($w,type)]
    set len [llength $form]

    set defs [solc_defs $solc($w,type)]

    if { [llength $defs]<1 } then {
	return
    }

    frame $wfr.l
    frame $wfr.r
    pack $wfr.l -side left -fill y
    pack $wfr.r -side left -fill x -expand yes

    set solc($w,do) ""

    for { set i 0 } { $i<$len } { incr i } {
	set attr [lindex $form $i]
	incr i
	
	frame $wfr.r.f$attr
	pack $wfr.r.f$attr -side top -fill x -expand yes
	set solc($w,do) [eval concat \[set solc($w,do)\] $attr \\\[eval list]

	set field [lindex $form $i]
	set fieldlen [llength $field]
	set defvals [lindex $defs [expr [lsearch $defs $attr]+1]]

	if { [string first "%f" $field]>-1 || [string first "%d" $field]>-1 } {
	    for { set num 0 } { $num<$fieldlen } { incr num } {
		entry $wfr.r.f$attr.e$num -width 6 -relief sunken
		pack $wfr.r.f$attr.e$num -side left -fill x -expand yes
		$wfr.r.f$attr.e$num insert insert [lindex $defvals $num]
		set solc($w,do) [eval concat \[set solc($w,do)\] \
			\\\[$wfr.r.f$attr.e$num get\\\]]
	    }
	}

	set solc($w,do) [eval concat \[set solc($w,do)\] \\\]]

	if { [catch { label $wfr.l.l$attr -text "$solc(label,$attr)" \
		-anchor w}]!=0 } then {
	    label $wfr.l.l$attr -text "$attr" -anchor w
	}

	pack $wfr.l.l$attr -side top -anchor w -fill y -expand yes
    }
}












@


1.9
log
@update copyright to include span through 2003
@
text
@@


1.8
log
@*** empty log message ***
@
text
@d16 1
a16 1
#	This software is Copyright (C) 1995 by the United States Army
@


1.8.6.1
log
@merge from HEAD
@
text
@d16 1
a16 1
#	This software is Copyright (C) 1995-2004 by the United States Army
@


1.7
log
@Solid to Primitive naming convention conversions
@
text
@d217 1
a217 1
    bind $w.slist.l <2> "tkListboxBeginSelect \%W \[\%W index \@@\%x,\%y\] ; \
@


1.7.4.1
log
@sync branch with HEAD
@
text
@d16 1
a16 1
#	This software is Copyright (C) 1995-2004 by the United States Army
d217 1
a217 1
    bind $w.slist.l <2> "::tk::ListboxBeginSelect \%W \[\%W index \@@\%x,\%y\] ; \
@


1.7.6.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d217 1
a217 1
    bind $w.slist.l <2> "::tk::ListboxBeginSelect \%W \[\%W index \@@\%x,\%y\] ; \
@


1.7.6.2
log
@sync to HEAD...
@
text
@d16 1
a16 1
#	This software is Copyright (C) 1995-2004 by the United States Army
@


1.6
log
@*- cleanup variables
@
text
@d64 1
a64 1
set solc(descr_part) "Particle Solid"
d112 1
a112 1
    wm title $w "Solid Creation"
d140 1
a140 1
    label $w.t.l.type     -text "Solid type" -relief raised -bd 1 -anchor w
d145 1
a145 1
    # For the "Solid type" label, allow left-clicking to get a list of solids
d198 1
a198 1
    wm title $w.slist "Solid type list"
@


1.5
log
@*** empty log message ***
@
text
@d99 1
a99 1
    global player_screen
d111 1
a111 1
    toplevel $w -screen $player_screen($id)
d194 1
a194 1
    global player_screen
d197 1
a197 1
    toplevel $w.slist -screen $player_screen($id)
@


1.4
log
@generalized to allow multiple instances
@
text
@d271 1
d273 1
@


1.3
log
@*** empty log message ***
@
text
@d22 6
d96 1
a96 1
proc solcreate args {
d99 1
d111 1
a111 1
    toplevel $w
d147 1
a147 1
    bind $w.t.l.type <1> "solc_list $w"
d191 1
a191 1
proc solc_list { w } {
d194 1
d197 1
a197 1
    toplevel $w.slist
@


1.2
log
@*** empty log message ***
@
text
@d204 4
a207 2
    bind $w.slist.l <ButtonRelease> "set solc($w,descr) \
	    \$solc(descr_\[selection get\])"
d209 2
a239 1
    uplevel #0
@


1.1
log
@Initial revision
@
text
@d1 59
a59 18
set solc(default,arb8) { V1 {1 -1 -1}  V2 {1 1 -1}  V3 {1 1 1}  V4 {1 -1 1} \
                         V5 {-1 -1 -1} V6 {-1 1 -1} V7 {-1 1 1} V8 {-1 -1 1} }
set solc(default,sph)  { V {0 0 0} A {1 0 0} B {0 1 0} C {0 0 1} }
set solc(default,ell)  { V {0 0 0} A {2 0 0} B {0 1 0} C {0 0 1} }
set solc(default,ellg) { V {0 0 0} A {4 0 0} B {0 2 0} C {0 0 1} }
set solc(default,tor)  { V {0 0 0} H {1 0 0} r_h 2 r_a 1 }
set solc(default,tgc)  { V {0 0 0} H {0 0 4} A {1 0 0} B {0 .5 0} \
	                 C {.5 0 0} D {0 1 0} }
set solc(default,rec)  { V {0 0 0} H {0 0 4} A {1 0 0} B {0 .5 0} \
	                 C {1 0 0} D {0 .5 0} }
set solc(default,half) { N {0 0 1} d -1 }
set solc(default,rpc)  { V {-1 -1 -1.5} H {0 0 1} B {0 .5 0} r .25 }
set solc(default,rhc)  { V {-1 -1 -1.5} H {0 0 1} B {0 .5 0} r .25 c .1 }
set solc(default,epa)  { V {-1 -1 -1.5} H {0 0 1} A {0 1 0} r_1 .5 r_2 .25 }
set solc(default,ehy)  { V {-1 -1 -1.5} H {0 0 1} A {0 1 0} r_1 .5 r_2 .25 \
	                 c .25 }
set solc(default,eto)  { V {-1 -1 -1} N {0 0 1} C {.1 0 .1} r .5 r_d .05 }
set solc(default,part) { V {-1 -1 -.5} H {0 0 1} r_v 0.5 r_h 0.25 }
a60 4
set solc(winnum) 0
set solc(default,type) arb8
set solc(default,indexvar) index

d78 13
a90 1
proc solcreate { } {
d92 1
a92 1
    global $solc(default,indexvar)
d94 1
a94 1
    set w $solc(winnum)
d97 37
a133 3
    catch { destroy .solc$w }
    toplevel .solc$w
    wm title .solc$w "Solid Creation"
d135 2
a136 3
    frame .solc$w.top
    frame .solc$w.top.left
    frame .solc$w.top.right
d138 1
a138 3
    pack .solc$w.top -side top -fill x -expand yes
    pack .solc$w.top.left -side left -fill y
    pack .solc$w.top.right -side left -fill x -expand yes
d140 1
a140 4
    label .solc$w.top.left.index -text "Index" -anchor w
    label .solc$w.top.left.indexvar -text "Index var" -anchor w
    label .solc$w.top.left.format -text "Format" -anchor w
    label .solc$w.top.left.type -text "Solid type" -anchor w
d142 2
a143 3
    pack .solc$w.top.left.index .solc$w.top.left.indexvar \
	    .solc$w.top.left.format .solc$w.top.left.type \
	    -side top -fill y -expand yes -anchor w
d145 3
a147 2
    if { [catch { set solc($w,index) [set $solc(default,indexvar)] }]!=0 } {
	set solc($w,index) 1
d149 14
a162 2
    entry .solc$w.top.right.index -relief sunken -width 12 \
	    -textvariable solc($w,index)
d164 2
a165 3
    set solc($w,indexvar) $solc(default,indexvar)
    entry .solc$w.top.right.indexvar -relief sunken -width 12 \
	    -textvariable solc($w,indexvar)
d167 1
a167 3
    set solc($w,format) "my$solc(default,type).\$$solc(default,indexvar)"
    entry .solc$w.top.right.format -relief sunken -width 12 \
	    -textvariable solc($w,format)
d169 3
a171 4
    set solc($w,type) $solc(default,type)
    entry .solc$w.top.right.type -relief sunken -width 12 \
	    -textvariable solc($w,type)
    bind .solc$w.top.right.type <Key-Return> "solnewtype $w"
d173 3
a175 3
    pack .solc$w.top.right.index .solc$w.top.right.indexvar \
	    .solc$w.top.right.format .solc$w.top.right.index \
	    .solc$w.top.right.type  -side top -fill x -expand yes
d177 3
a179 2
    soldefaults .solc$w.def $solc(default,type)
    pack .solc$w.def -side top -fill x -expand yes
d181 2
a182 2
    frame .solc$w.bot
    pack .solc$w.bot -side top -fill x -expand yes
d184 3
a186 7
    button .solc$w.bot.quit -text "Quit" -command "solquit $w"
    button .solc$w.bot.create -text "Create" -command "soldoit $w"
    pack .solc$w.bot.quit .solc$w.bot.create -side left -fill x -expand yes

    button .solc$w.accept -text "Accept" -command "press accept" \
	    -state disabled -command "solaccept $w"
    pack .solc$w.accept -side top -fill x -expand yes
d188 20
d210 10
a219 4
proc solaccept { w } {
    .solc$w.accept configure -state disabled
    .solc$w.bot.create configure -state normal
    press accept
d222 3
a224 1
proc solnewtype { w } {
d226 1
d228 3
a230 2
    soldefaults .solc$w.def $solc($w,type)
    pack .solc$w.def -after .solc$w.top -side top -fill x -expand yes
d233 1
a233 1
proc solquit { w } {
d235 2
d238 3
a240 2
    set solc(default,indexvar) $solc($w,indexvar)
    set solc(default,type) $solc($w,type)
d242 1
a242 1
    destroy .solc$w
d245 1
a245 1
proc soldoit { w } {
d249 2
a250 3
    set $solc($w,indexvar) $solc($w,index)

    set objname [eval list $solc($w,format)]
d252 2
a253 4
    incr solc($w,index)
    set $solc($w,indexvar) $solc($w,index)
    set solc(default,indexvar) $solc($w,indexvar)
    set solc(default,type) $solc($w,type)
d255 7
a261 4
    set solc(default,$solc($w,type)) [eval list [set solc(do,.solc$w.def)]]

    eval db put $objname $solc($w,type) [set solc(do,.solc$w.def)]
    sed $objname
a262 2
    .solc$w.accept configure -state normal
    .solc$w.bot.create configure -state disabled
d264 2
d268 1
a268 1
proc soldefs { type } {
d272 1
a272 1
    catch { set retval $solc(default,[string tolower $type]) }
d277 1
a277 1
proc soldefaults { fr type } {
d279 1
d281 3
a283 4
    catch { destroy $fr }
    frame $fr
    
    if { [catch { db form $type }]!=0 } then {
d287 2
a288 2
    label $fr.header -text "Default values"
    pack $fr.header -side top -fill x -expand yes -anchor c
d290 1
a290 1
    set form [db form $type]
d293 1
a293 1
    set defs [soldefs $type]
d299 4
a302 4
    frame $fr.l
    frame $fr.r
    pack $fr.l -side left -fill y
    pack $fr.r -side left -fill x -expand yes
d304 1
a304 1
    set solc(do,$fr) ""
d310 3
a312 3
	frame $fr.r.f$attr
	pack $fr.r.f$attr -side top -fill x -expand yes
	set solc(do,$fr) [eval concat \[set solc(do,$fr)\] $attr \\\"]
d320 5
a324 5
		entry $fr.r.f$attr.e$num -width 6 -relief sunken
		pack $fr.r.f$attr.e$num -side left -fill x -expand yes
		$fr.r.f$attr.e$num insert insert [lindex $defvals $num]
		set solc(do,$fr) [eval concat \[set solc(do,$fr)\] \
			\\\[$fr.r.f$attr.e$num get\\\]]
d328 1
a328 1
	set solc(do,$fr) [eval concat \[set solc(do,$fr)\] \\\"]
d330 1
a330 1
	if { [catch { label $fr.l.l$attr -text "$solc(label,$attr)" \
d332 1
a332 1
	    label $fr.l.l$attr -text "$attr" -anchor w
d335 1
a335 1
	pack $fr.l.l$attr -side top -anchor w -fill y -expand yes
@
