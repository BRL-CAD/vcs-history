head	1.14;
access;
symbols
	ansi-20040405-merged:1.13
	postmerge-20040405-ansi:1.13
	premerge-20040404-ansi:1.13
	postmerge-autoconf:1.13
	autoconf-freeze:1.13
	premerge-autoconf:1.13
	postmerge-20040315-windows:1.13
	premerge-20040315-windows:1.13
	windows-20040315-freeze:1.13
	autoconf-20031203:1.13
	autoconf-20031202:1.13
	autoconf-branch:1.13.0.12
	phong-branch:1.13.0.10
	photonmap-branch:1.13.0.8
	rel-6-1-DP:1.13
	windows-branch:1.13.0.6
	rel-6-0-2:1.13
	ansi-branch:1.13.0.4
	rel-6-0-1-branch:1.13.0.2
	hartley-6-0-post:1.13
	hartley-6-0-pre:1.13
	rel-6-0-1:1.13
	rel-6-0:1.13
	rel-5-4:1.6.2.5
	offsite-5-3-pre:1.11
	rel-5-3:1.6.2.5
	rel-5-2:1.6
	rel-5-1-branch:1.6.0.2
	rel-5-1:1.6
	rel-5-0:1.6
	rel-5-0-beta:1.5;
locks; strict;
comment	@# @;


1.14
date	2004.05.21.16.41.27;	author morrison;	state dead;
branches;
next	1.13;

1.13
date	2001.08.02.17.43.05;	author bparker;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.26.21.19.04;	author bparker;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.09.19.44.07;	author bparker;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.16.22.32.03;	author bparker;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.02.22.28.02;	author bparker;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.28.16.25.58;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.16.21.49.06;	author bparker;	state Exp;
branches;
next	1.6;

1.6
date	99.09.08.13.18.18;	author bparker;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.02.10.15.21.13;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	98.06.15.19.28.23;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	98.05.01.21.21.37;	author bparker;	state Exp;
branches;
next	1.2;

1.2
date	98.04.23.13.47.00;	author bparker;	state Exp;
branches;
next	1.1;

1.1
date	98.04.09.21.00.13;	author bparker;	state Exp;
branches;
next	;

1.6.2.1
date	2000.11.16.21.48.09;	author bparker;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2000.11.28.16.25.33;	author bparker;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.02.02.22.25.51;	author bparker;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2001.02.08.21.51.37;	author bparker;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2001.03.09.19.36.49;	author bparker;	state Exp;
branches;
next	;


desc
@@


1.14
log
@moved to src/tclscripts/
@
text
@#
#			L I S T . T C L
#
#  Author -
#	Robert G. Parker
#
#  Description -
#	Tcl routines for utilizing Tcl's listbox.
#

proc create_listbox { top screen type items abort_cmd } {
    toplevel $top -screen $screen
    frame $top.frame
    listbox $top.listbox -xscrollcommand "$top.hscrollbar set" -yscrollcommand "$top.vscrollbar set"
    foreach word $items {
	$top.listbox insert end $word
    }
    # right justify
    $top.listbox xview 1000
    scrollbar $top.hscrollbar -orient horizontal -command "$top.listbox xview"
    scrollbar $top.vscrollbar -command "$top.listbox yview"
    button $top.abortB -text "Abort $type Selection" \
	-command "$abort_cmd"

    grid $top.listbox $top.vscrollbar -sticky "nsew" -in $top.frame
    grid $top.hscrollbar x -sticky "nsew" -in $top.frame
    grid $top.frame -sticky "nsew" -padx 8 -pady 8
    grid $top.abortB -padx 8 -pady 8
    grid columnconfigure $top.frame 0 -weight 1
    grid rowconfigure $top.frame 0 -weight 1
    grid columnconfigure $top 0 -weight 1
    grid rowconfigure $top 0 -weight 1

    place_near_mouse $top
    wm protocol $top WM_DELETE_WINDOW "catch { destroy $top }"
    wm title $top "$type Selection Menu"
}

proc bind_listbox {top event action} {
    bind $top.listbox $event "$action"
}

proc get_listbox_entry {w x y} {
    if ![winfo exists $w] {
	return
    }

    $w selection clear 0 end
    $w selection set @@$x,$y

    return [$w get @@$x,$y]
}


## - lbdcHack
#
# Listbox double click hack.
#
proc lbdcHack {w x y t id type path} {
    global mged_gui
    global mged_default
    global comb_control
    global bot_v1 bot_v2 bot_v3

    # set item from listbox selection @@$x,$y
    switch $type {
	s1 -
	s2 -
	o -
	c1 -
	c2 -
	c3 -
	bf {
	    set item [get_listbox_entry $w $x $y]
	}
	m1 -
	m2 {
	    set item [$w index @@$x,$y]
	}
	default {
	    error "lbdcHack: bad type - $type"
	}
    }

    if {$mged_gui($id,lastButtonPress) == 0 ||
        $mged_gui($id,lastItem) != $item ||
        [expr {abs($mged_gui($id,lastButtonPress) - $t) > $mged_default(doubleClickTol)}]} {

	switch $type {
	    s1 -
	    s2 -
	    o {
		solid_illum $item
	    }
	    c1 -
	    c2 {
		set spath [comb_get_solid_path $item]
		set path_pos [comb_get_path_pos $spath $item]
		matrix_illum $spath $path_pos
	    }
	    c3 {
	    }
	    m1 -
	    m2 {
		matrix_illum $path $item
	    }
	    bf {
		set bot_v1 [lindex $item 0];
		set bot_v2 [lindex $item 1];
		set bot_v3 [lindex $item 2];
		get_solid_keypoint;
		refresh;
	    }
	}
    } else {
	switch $type {
	    s1 {
		_mged_sed -i 1 $item
	    }
	    s2 {
		set mged_gui($id,mgs_path) $item
	    }
	    o {
		bind $w <ButtonRelease-1> \
			"destroy [winfo parent $w]; build_matrix_menu $id $item; break"
		set mged_gui($id,lastButtonPress) $t
		set mged_gui($id,lastItem) $item
		return
	    }
	    c1 {
		set mged_gui($id,mgc_comb) $item
	    }
	    c2 -
	    c3 {
		set comb_control($id,name) $item
		comb_reset $id
	    }
	    m1 {
		_mged_press oill
		_mged_ill -i 1 $path
		_mged_matpick $item
	    }
	    m2 {
		set mged_gui($id,mgs_pos) $item
	    }
	    bf {
		set bot_v1 [lindex $item 0];
		set bot_v2 [lindex $item 1];
		set bot_v3 [lindex $item 2];
		get_solid_keypoint;
		refresh;
	    }
	}

	bind $w <ButtonRelease-1> \
		"destroy [winfo parent $w]; break"
    }

    set mged_gui($id,lastButtonPress) $t
    set mged_gui($id,lastItem) $item
    return
}
@


1.13
log
@*- remove special code for handling sketch primitives;
   this now lives in callbacks.tcl
@
text
@@


1.12
log
@*- fix primitive selection where the
   primitive is not supported by "db get"
@
text
@d39 1
a39 1
proc bind_listbox { top event action } {
d43 1
a43 1
proc get_listbox_entry { w x y } {
d118 1
a118 11
		if {[catch {[db get $item]} sol_data]} {
		    set sol_type ""
		} else {
		    set sol_type [lindex $sol_data 0]
		}

		if {$sol_type == "sketch"} {
		    Sketch_editor .#auto $item
		} else {
		    _mged_sed -i 1 $item
		}
d126 2
d161 1
@


1.11
log
@*- set item to index if doing matrix select
@
text
@d118 7
a124 3
		set sol_data [db get $item]
		set sol_type [lindex $sol_data 0]
		if { $sol_type == "sketch" } {
@


1.10
log
@*- mods to lbdcHack to handle more scenarios
@
text
@a72 2
	m1 -
	m2 -
d75 4
@


1.9
log
@*- mods that get around an apparent Tcl bug
   when selecting on <Double-1> events.
@
text
@d62 2
d65 1
d67 9
a75 2
	s -
	c {
d78 2
a79 2
	m {
	    set item [$w index @@$x,$y]
d88 3
a90 1
	    s {
d93 2
a94 1
	    c {
d99 4
a102 1
	    m {
d105 7
d115 10
a124 1
	    s {
d126 2
d129 2
a130 1
			"destroy [winfo parent $w]; break"
d132 1
a132 1
	    c {
a133 2
		bind $w <ButtonRelease-1> \
			"destroy [winfo parent $w]; break"
d135 11
a145 1
	    m {
d147 7
a153 2
		bind $w <ButtonRelease-1> \
			"destroy [winfo parent $w]; break"
d156 3
@


1.8
log
@Add horizontal scrollbar to listbox.
@
text
@d53 60
@


1.7
log
@Mods to create_listbox to right justify the list.
@
text
@d14 1
a14 1
    listbox $top.listbox -yscrollcommand "$top.scrollbar set"
d20 2
a21 1
    scrollbar $top.scrollbar -command "$top.listbox yview"
d25 2
a26 1
    grid $top.listbox $top.scrollbar -sticky "nsew" -in $top.frame
@


1.6
log
@*- remove break statement in bind_listbox proc
@
text
@d18 2
@


1.6.2.1
log
@Mod to create_listbox to right justify the list.
@
text
@a17 2
    # right justify
    $top.listbox xview 1000
@


1.6.2.2
log
@Add horizontal scrollbar to listbox.
@
text
@d14 1
a14 1
    listbox $top.listbox -xscrollcommand "$top.hscrollbar set" -yscrollcommand "$top.vscrollbar set"
d20 1
a20 2
    scrollbar $top.hscrollbar -orient horizontal -command "$top.listbox xview"
    scrollbar $top.vscrollbar -command "$top.listbox yview"
d24 1
a24 2
    grid $top.listbox $top.vscrollbar -sticky "nsew" -in $top.frame
    grid $top.hscrollbar x -sticky "nsew" -in $top.frame
@


1.6.2.3
log
@*- mods that get around an apparent Tcl bug
   when selecting <Double-1> events
@
text
@a52 60


## - lbdcHack
#
# Listbox double click hack.
#
proc lbdcHack {w x y t id type path} {
    global mged_gui
    global mged_default

    switch $type {
	s -
	c {
	    set item [get_listbox_entry $w $x $y]
	}
	m {
	    set item [$w index @@$x,$y]
	}
    }

    if {$mged_gui($id,lastButtonPress) == 0 ||
        $mged_gui($id,lastItem) != $item ||
        [expr {abs($mged_gui($id,lastButtonPress) - $t) > $mged_default(doubleClickTol)}]} {

	switch $type {
	    s {
		solid_illum $item
	    }
	    c {
		set spath [comb_get_solid_path $item]
		set path_pos [comb_get_path_pos $spath $item]
		matrix_illum $spath $path_pos
	    }
	    m {
		matrix_illum $path $item
	    }
	}
    } else {
	switch $type {
	    s {
		set mged_gui($id,mgs_path) $item
		bind $w <ButtonRelease-1> \
			"destroy [winfo parent $w]; break"
	    }
	    c {
		set mged_gui($id,mgc_comb) $item
		bind $w <ButtonRelease-1> \
			"destroy [winfo parent $w]; break"
	    }
	    m {
		set mged_gui($id,mgs_pos) $item
		bind $w <ButtonRelease-1> \
			"destroy [winfo parent $w]; break"
	    }
	}
    }

    set mged_gui($id,lastButtonPress) $t
    set mged_gui($id,lastItem) $item
}
@


1.6.2.4
log
@*- mods to lbdcHack to handle other situations
   that need this double click hack.
@
text
@a61 2
    global comb_control
    global bot_v1 bot_v2 bot_v3
a62 1
    # set item from listbox selection @@$x,$y
d64 2
a65 9
	s1 -
	s2 -
	o -
	c1 -
	c2 -
	c3 -
	m1 -
	m2 -
	bf {
d68 2
a69 2
	default {
	    error "lbdcHack: bad type - $type"
d78 1
a78 3
	    s1 -
	    s2 -
	    o {
d81 1
a81 2
	    c1 -
	    c2 {
d86 1
a86 4
	    c3 {
	    }
	    m1 -
	    m2 {
a88 7
	    bf {
		set bot_v1 [lindex $item 0];
		set bot_v2 [lindex $item 1];
		set bot_v3 [lindex $item 2];
		get_solid_keypoint;
		refresh;
	    }
d92 1
a92 10
	    s1 {
		set sol_data [db get $item]
		set sol_type [lindex $sol_data 0]
		if { $sol_type == "sketch" } {
		    Sketch_editor .#auto $item
		} else {
		    _mged_sed -i 1 $item
		}
	    }
	    s2 {
a93 2
	    }
	    o {
d95 1
a95 2
			"destroy [winfo parent $w]; build_matrix_menu $id $item; break"
		return
d97 1
a97 1
	    c1 {
d99 2
d102 1
a102 11
	    c2 -
	    c3 {
		set comb_control($id,name) $item
		comb_reset $id
	    }
	    m1 {
		_mged_press oill
		_mged_ill -i 1 $path
		_mged_matpick $item
	    }
	    m2 {
d104 2
a105 7
	    }
	    bf {
		set bot_v1 [lindex $item 0];
		set bot_v2 [lindex $item 1];
		set bot_v3 [lindex $item 2];
		get_solid_keypoint;
		refresh;
a107 3

	bind $w <ButtonRelease-1> \
		"destroy [winfo parent $w]; break"
@


1.6.2.5
log
@*- for matrix selection set item to index
@
text
@d73 2
a76 4
	}
	m1 -
	m2 {
	    set item [$w index @@$x,$y]
@


1.5
log
@*- use place_near_mouse proc to position widgets near the mouse
@
text
@d36 1
a36 1
    bind $top.listbox $event "$action; break"
@


1.4
log
@*- append "break" to bindings to prevent further processing
@
text
@d30 1
a30 4
    set pxy [winfo pointerxy $top]
    set x [lindex $pxy 0]
    set y [lindex $pxy 1]

a31 1
    wm geometry $top +$x+$y
@


1.3
log
@*** empty log message ***
@
text
@d40 1
a40 1
    bind $top.listbox $event $action
@


1.2
log
@*- mods to create_listbox
@
text
@d42 11
@


1.1
log
@Tcl routines for utilizing Tcl's listbox.
@
text
@d11 1
a11 1
proc create_listbox { top screen type items } {
d20 1
a20 1
	-command "destroy $top"
@
