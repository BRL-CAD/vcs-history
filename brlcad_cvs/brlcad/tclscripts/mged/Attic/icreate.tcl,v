head	1.8;
access;
symbols
	ansi-20040405-merged:1.6.6.1
	postmerge-20040405-ansi:1.7
	premerge-20040404-ansi:1.7
	postmerge-autoconf:1.7
	autoconf-freeze:1.6.14.1
	premerge-autoconf:1.7
	postmerge-20040315-windows:1.7
	premerge-20040315-windows:1.7
	windows-20040315-freeze:1.6.8.1
	autoconf-20031203:1.6
	autoconf-20031202:1.6
	autoconf-branch:1.6.0.14
	phong-branch:1.6.0.12
	photonmap-branch:1.6.0.10
	rel-6-1-DP:1.6
	windows-branch:1.6.0.8
	rel-6-0-2:1.6
	ansi-branch:1.6.0.6
	rel-6-0-1-branch:1.6.0.4
	hartley-6-0-post:1.6
	hartley-6-0-pre:1.6
	rel-6-0-1:1.6
	rel-6-0:1.6
	rel-5-4:1.6
	offsite-5-3-pre:1.6
	rel-5-3:1.6
	rel-5-2:1.6
	rel-5-1-branch:1.6.0.2
	rel-5-1:1.6
	rel-5-0:1.6
	rel-5-0-beta:1.6
	rel-4-5:1.4;
locks; strict;
comment	@# @;


1.8
date	2004.05.21.16.41.24;	author morrison;	state dead;
branches;
next	1.7;

1.7
date	2004.02.02.17.39.43;	author morrison;	state Exp;
branches;
next	1.6;

1.6
date	99.01.19.22.31.29;	author bparker;	state Exp;
branches
	1.6.6.1
	1.6.8.1
	1.6.14.1;
next	1.5;

1.5
date	98.06.15.19.28.23;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	96.07.09.19.44.17;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	95.08.10.21.10.45;	author gdurf;	state Exp;
branches;
next	1.2;

1.2
date	95.08.03.21.45.51;	author gdurf;	state Exp;
branches;
next	1.1;

1.1
date	95.07.27.17.42.59;	author gdurf;	state Exp;
branches;
next	;

1.6.6.1
date	2004.03.17.21.23.11;	author morrison;	state Exp;
branches;
next	;

1.6.8.1
date	2004.03.11.23.48.58;	author morrison;	state Exp;
branches;
next	;

1.6.14.1
date	2004.02.12.18.34.49;	author erikg;	state Exp;
branches;
next	;


desc
@Tk script for tool for automated instancing
@


1.8
log
@moved to src/tclscripts/
@
text
@#			 I C R E A T E . T C L 
#
# Author -
#	Glenn Durfee
#
# Source -
#	The U. S. Army Ballistic Research Laboratory
#	Aberdeen Proving Ground, Maryland  21005
#  
# Distribution Notice -
#	Re-distribution of this software is restricted, as described in
#	your "Statement of Terms and Conditions for the Release of
#	The BRL-CAD Package" agreement.
#
# Copyright Notice -
#	This software is Copyright (C) 1995-2004 by the United States Army
#	in all countries except the USA.  All rights reserved.
#
# Description -
#       Program to allow automated generation and interactive placement of new
#       instances of preexisting combinations.
#
# Modifications -
#        (Bob Parker):
#             Generalized the code to accommodate multiple instances of the
#             user interface.
#

#=============================================================================
# PHASE 0: variable defaults
#=============================================================================

set ic(winnum) 0
set ic(default_type) ""
set ic(default_path) ""
set ic(default_indexvar) index
set ic(default_operation) "incr index"

#=============================================================================
# PHASE 1: icreate procedure
#-----------------------------------------------------------------------------
# Makes a toplevel window with the labels, entry fields, and buttons to allow
# the user to create new instances of existing objects.
#=============================================================================

proc icreate { id args } {
    global ic
    global $ic(default_indexvar)
    global mged_gui

    set w .ic$ic(winnum)
    incr ic(winnum)

    # Pull the object name out of the argument list if present
    
    if { [llength $args]>0 } then {
	set ic(default_type) [lindex $args 0]
    }

    catch { destroy $w }
    toplevel $w -screen $mged_gui($id,screen)
    wm title $w "Instance Creation"

    # Make two frames: top one for entry fields and labels, buttom one for
    # create and quit buttons
    
    frame $w.t
    frame $w.b

    pack $w.t $w.b -side top -fill x -expand yes

    # Top frame contains two frames: l (left) and r (right)
    # Left one is for labels and right one is for entry boxes
    
    frame $w.t.l
    frame $w.t.r

    # Right frame (entry fields) should grow if window width increased

    pack $w.t.l -side left -fill y
    pack $w.t.r -side left -fill x -expand yes

    # Create a label for each entry field

    label $w.t.l.format   -text "Format of name"
    label $w.t.l.indexvar -text "Index variable"
    label $w.t.l.index    -text "Index"
    label $w.t.l.oper     -text "Operation"
    label $w.t.l.type     -text "Prototype"
    label $w.t.l.comb     -text "Comb to add to"
    label $w.t.l.ref      -text "Reference path" -relief raised -bd 1
    bind $w.t.l.ref <1> "ic_reflist $w $id; break"

    pack $w.t.l.format $w.t.l.indexvar $w.t.l.index $w.t.l.oper $w.t.l.type \
	    $w.t.l.comb $w.t.l.ref -side top -fill y -expand yes -anchor w

    # Set up some reasonable defaults for the entry fields
    # If the default index variable does not exist, set it equal to 1

    set ic($w,format) "my$ic(default_type).\$$ic(default_indexvar)"
    set ic($w,indexvar) $ic(default_indexvar)
    if { [catch { set ic($w,index) [set $ic(default_indexvar)] }]!=0 } {
	set ic($w,index) 1
	set $ic(default_indexvar) 1
    }
    set ic($w,oper) $ic(default_operation)
    set ic($w,type) $ic(default_type)
    set ic($w,comb) ""
    if { [catch { set ic($w,ref) [lindex [pathlist $ic($w,type)] 0] }] != 0 } {
	set ic($w,ref) ""
    }

    # Create the entry boxes

    entry $w.t.r.format   -relief sunken -width 16 -textvar ic($w,format)
    entry $w.t.r.indexvar -relief sunken -width 16 -textvar ic($w,indexvar)
    entry $w.t.r.index    -relief sunken -width 16 -textvar ic($w,index)
    entry $w.t.r.oper     -relief sunken -width 16 -textvar ic($w,oper)
    entry $w.t.r.type     -relief sunken -width 16 -textvar ic($w,type)
    entry $w.t.r.comb     -relief sunken -width 16 -textvar ic($w,comb)
    entry $w.t.r.ref      -relief sunken -width 12 -textvar ic($w,ref)

    bind $w.t.r.indexvar <Key-Return> "ic_newvar $w; break"
    bind $w.t.r.index    <Key-Return> "set \$ic($w,indexvar) \$ic($w,index); break"

    pack $w.t.r.format $w.t.r.indexvar $w.t.r.index $w.t.r.oper $w.t.r.type \
	    $w.t.r.comb $w.t.r.ref -side top -fill x -expand yes

    # Bottom contains two frames: left and right, which each contain two
    # buttons

    button $w.b.quit   -text "Quit"   -command "ic_quit $w"
    button $w.b.create -text "Create" -command "ic_create $w"
    pack $w.b.quit $w.b.create -side left -fill x -expand yes

    button $w.accept -text "Accept" -state disabled -command "ic_accept $w"
    pack $w.accept -side top -fill x -expand yes
}

#=============================================================================
# PHASE 2: Support routines
#=============================================================================

# ic_newvar

proc ic_newvar { w } {
    global ic
    global $ic($w,indexvar)
    
    if { [catch { set ic($w,index) [set $ic($w,indexvar)] }] != 0 } then {
	set ic($w,index) 1
	set $ic($w,indexvar) 1
    }
}

# ic_accept

proc ic_accept { w } {
    $w.accept configure -state disabled
    $w.b.create configure -state normal
    press accept
}

# ic_quit

proc ic_quit { w } {
    global ic
    global $ic($w,indexvar)

    set $ic($w,indexvar) $ic($w,index)
    set ic(default_indexvar) $ic($w,indexvar)
    set ic(default_type) $ic($w,type)
    set ic(default_oper) $ic($w,oper)

    destroy $w
}

# ic_create
# Actually carries out the task of creating a new instance

proc ic_create { w } {
    global ic
    global $ic($w,indexvar)
    
    set $ic($w,indexvar) $ic($w,index)

    # Perform the formatting of the "name format" supplied by the user
    set name [eval list $ic($w,format)]

    # Perform the operation described by the "index operation" supplied by user
    eval $ic($w,oper)

    set ic(default_indexvar) $ic($w,indexvar)
    set ic(default_type) $ic($w,type)
    set ic(default_oper) $ic($w,oper)

    g $name $ic($w,type)
    if { $ic($w,comb)!="" } then {
	i $ic($w,comb) $name
    }
    e $ic($w,comb)/$name
    oed $ic($w,comb) $name$ic($w,ref)
    press oxy

    $w.accept configure -state normal
    $w.b.create configure -state disabled
}

# ic_reflist
# Pops up a window list containing all of the possible reference solids

proc ic_reflist { w id } {
    global ic
    global mged_gui

    catch { destroy $w.ref }
    if {[llength $ic($w,type)]==0} then {
	error "Please enter a prototype first."
	return
    }
    
    toplevel $w.ref -screen $mged_gui($id,screen)
    wm title $w.ref "Reference solid list"

    listbox $w.ref.lbox

    foreach solid [pathlist $ic($w,type)] {
	$w.ref.lbox insert end $solid
    }

    bind $w.ref.lbox <Double-Button-1> "set ic($w,ref) \[selection get\]; break"

    button $w.ref.dismiss -text "Dismiss" -command "destroy $w.ref"

    pack $w.ref.lbox -side top -fill y -fill x -expand yes
    pack $w.ref.dismiss -side top -fill x
}







@


1.7
log
@update copyright to include span through 2003
@
text
@@


1.6
log
@*- cleanup variables
@
text
@d16 1
a16 1
#	This software is Copyright (C) 1995 by the United States Army
@


1.6.6.1
log
@sync branch with HEAD
@
text
@d16 1
a16 1
#	This software is Copyright (C) 1995-2004 by the United States Army
@


1.6.8.1
log
@sync to HEAD...
@
text
@d16 1
a16 1
#	This software is Copyright (C) 1995-2004 by the United States Army
@


1.6.14.1
log
@merge from HEAD
@
text
@d16 1
a16 1
#	This software is Copyright (C) 1995-2004 by the United States Army
@


1.5
log
@*- append "break" to bindings to prevent further processing
@
text
@d49 1
a49 1
    global player_screen
d61 1
a61 1
    toplevel $w -screen $player_screen($id)
d214 1
a214 1
    global player_screen
d222 1
a222 1
    toplevel $w.ref -screen $player_screen($id)
@


1.4
log
@ generalized to allow multiple instances
@
text
@d92 1
a92 1
    bind $w.t.l.ref <1> "ic_reflist $w $id"
d123 2
a124 2
    bind $w.t.r.indexvar <Key-Return> "ic_newvar $w"
    bind $w.t.r.index    <Key-Return> "set \$ic($w,indexvar) \$ic($w,index)"
d231 1
a231 1
    bind $w.ref.lbox <Double-Button-1> "set ic($w,ref) \[selection get\]"
@


1.3
log
@*** empty log message ***
@
text
@d22 6
d46 1
a46 1
proc icreate args {
d49 1
d61 1
a61 1
    toplevel $w
d92 1
a92 1
    bind $w.t.l.ref <1> "ic_reflist $w"
d212 1
a212 1
proc ic_reflist { w } {
d214 1
d222 1
a222 1
    toplevel $w.ref
@


1.2
log
@Lots of improvements
@
text
@d84 2
a85 1
    label $w.t.l.ref      -text "Reference path"
d125 3
a127 2
    frame $w.b.l
    frame $w.b.r
d129 2
a130 11
    pack $w.b.l $w.b.r -side left -fill x -expand yes

    button $w.b.l.quit   -text "Quit"   -command "ic_quit $w"
    button $w.b.l.create -text "Create" -command "ic_create $w"

    pack $w.b.l.quit $w.b.l.create -side top -fill x -expand yes

    button $w.b.r.ref    -text "Solids" -command "ic_reflist $w"
    button $w.b.r.accept -text "Accept" -state disabled -command "ic_accept $w"

    pack $w.b.r.ref $w.b.r.accept -side top -fill x -expand yes
d152 2
a153 2
    $w.b.r.accept configure -state disabled
    $w.b.l.create configure -state normal
d198 2
a199 2
    $w.b.r.accept configure -state normal
    $w.b.l.create configure -state disabled
d209 5
@


1.1
log
@Initial revision
@
text
@d1 26
d28 11
a38 2
set ic(default,type) ""
set ic(default,indexvar) index
d42 1
a42 1
    global $ic(default,indexvar)
d44 1
a44 1
    set w $ic(winnum)
d47 2
d50 1
a50 1
	set ic(default,type) [lindex $args 0]
d53 22
a74 3
    catch { destroy .ic$w }
    toplevel .ic$w
    wm title .ic$w "Instance Creation"
d76 1
a76 3
    frame .ic$w.top
    frame .ic$w.top.left
    frame .ic$w.top.right
d78 7
a84 3
    pack .ic$w.top -side top -fill x -expand yes
    pack .ic$w.top.left -side left -fill y
    pack .ic$w.top.right -side left -fill x -expand yes
d86 2
a87 5
    label .ic$w.top.left.index -text "Index" -anchor w
    label .ic$w.top.left.indexvar -text "Index var" -anchor w
    label .ic$w.top.left.format -text "Format" -anchor w
    label .ic$w.top.left.type -text "Prototype" -anchor w
    label .ic$w.top.left.comb -text "Comb to add to" -anchor w
d89 2
a90 3
    pack .ic$w.top.left.index .ic$w.top.left.indexvar \
	    .ic$w.top.left.format .ic$w.top.left.type .ic$w.top.left.comb \
	    -side top -fill y -expand yes -anchor w
d92 3
a94 1
    if { [catch { set ic($w,index) [set $ic(default,indexvar)] }]!=0 } {
d96 1
d98 8
a105 2
    entry .ic$w.top.right.index -relief sunken -width 12 \
	    -textvariable ic($w,index)
d107 7
a113 11
    set ic($w,indexvar) $ic(default,indexvar)
    entry .ic$w.top.right.indexvar -relief sunken -width 12 \
	    -textvariable ic($w,indexvar)

    set ic($w,format) "my$ic(default,type).\$$ic(default,indexvar)"
    entry .ic$w.top.right.format -relief sunken -width 12 \
	    -textvariable ic($w,format)

    set ic($w,type) $ic(default,type)
    entry .ic$w.top.right.type -relief sunken -width 12 \
	    -textvariable ic($w,type)
d115 24
a138 3
    set ic($w,comb) ""
    entry .ic$w.top.right.comb -relief sunken -width 12 \
	    -textvariable ic($w,comb)
d140 3
a142 11
    pack .ic$w.top.right.index .ic$w.top.right.indexvar \
	    .ic$w.top.right.format .ic$w.top.right.index \
	    .ic$w.top.right.type .ic$w.top.right.comb \
	    -side top -fill x -expand yes

    frame .ic$w.bot
    pack .ic$w.bot -side top -fill x -expand yes

    button .ic$w.bot.quit -text "Quit" -command "icquit $w"
    button .ic$w.bot.create -text "Create" -command "icdoit $w"
    pack .ic$w.bot.quit .ic$w.bot.create -side left -fill x -expand yes
d144 1
a144 2
    button .ic$w.accept -text "Accept" -state disabled -command "icaccept $w"
    pack .ic$w.accept -side top -fill x -expand yes
d146 8
d156 5
a160 3
proc icaccept { w } {
    .ic$w.accept configure -state disabled
    .ic$w.bot.create configure -state normal
d164 3
a166 1
proc icquit { w } {
d170 4
a173 2
    set ic(default,indexvar) $ic($w,indexvar)
    set ic(default,type) $ic($w,type)
d175 1
a175 1
    destroy .ic$w
d178 4
a181 1
proc icdoit { w } {
d187 9
a195 6
    set objname [eval list $ic($w,format)]
    
    incr ic($w,index)
    set $ic($w,indexvar) $ic($w,index)
    set ic(default,indexvar) $ic($w,indexvar)
    set ic(default,type) $ic($w,type)
d197 1
a197 1
    g $objname $ic($w,type)
d199 1
a199 1
	i $ic($w,comb) $objname
d201 27
a227 2
    E $objname
    press oill
d229 2
a230 2
    .ic$w.accept configure -state normal
    .ic$w.bot.create configure -state disabled
@
