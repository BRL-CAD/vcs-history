head	1.17;
access;
symbols
	ansi-20040405-merged:1.15.4.1
	postmerge-20040405-ansi:1.16
	premerge-20040404-ansi:1.16
	postmerge-autoconf:1.16
	autoconf-freeze:1.16
	premerge-autoconf:1.16
	postmerge-20040315-windows:1.16
	premerge-20040315-windows:1.16
	windows-20040315-freeze:1.15.6.2
	autoconf-20031203:1.16
	autoconf-20031202:1.16
	autoconf-branch:1.16.0.6
	phong-branch:1.16.0.4
	photonmap-branch:1.16.0.2
	rel-6-1-DP:1.15
	windows-branch:1.15.0.6
	rel-6-0-2:1.15
	ansi-branch:1.15.0.4
	rel-6-0-1-branch:1.15.0.2
	hartley-6-0-post:1.15
	hartley-6-0-pre:1.15
	rel-6-0-1:1.15
	rel-6-0:1.15
	rel-5-4:1.10.2.4
	offsite-5-3-pre:1.14
	rel-5-3:1.10.2.4
	rel-5-2:1.10
	rel-5-1-branch:1.10.0.2
	rel-5-1:1.10
	rel-5-0:1.10
	rel-5-0-beta:1.8;
locks; strict;
comment	@# @;


1.17
date	2004.05.21.16.41.23;	author morrison;	state dead;
branches;
next	1.16;

1.16
date	2003.03.13.19.45.31;	author jra;	state Exp;
branches;
next	1.15;

1.15
date	2001.04.03.22.33.03;	author bparker;	state Exp;
branches
	1.15.4.1
	1.15.6.1;
next	1.14;

1.14
date	2001.02.02.14.50.24;	author bparker;	state Exp;
branches;
next	1.13;

1.13
date	2000.12.22.00.35.15;	author bparker;	state Exp;
branches;
next	1.12;

1.12
date	2000.11.14.19.15.36;	author bparker;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.11.03.00.37;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	99.09.01.18.08.25;	author bparker;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	99.07.16.17.40.15;	author bparker;	state Exp;
branches;
next	1.8;

1.8
date	99.02.10.15.21.12;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	99.01.19.22.31.28;	author bparker;	state Exp;
branches;
next	1.6;

1.6
date	98.12.29.20.53.02;	author bparker;	state Exp;
branches;
next	1.5;

1.5
date	98.12.18.20.31.56;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	98.12.09.22.32.13;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	98.10.22.18.43.56;	author bparker;	state Exp;
branches;
next	1.2;

1.2
date	98.08.13.12.46.42;	author bparker;	state Exp;
branches;
next	1.1;

1.1
date	98.07.15.16.08.30;	author bparker;	state Exp;
branches;
next	;

1.10.2.1
date	2000.11.14.18.54.31;	author bparker;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2000.11.14.19.36.26;	author bparker;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2000.12.22.00.02.28;	author bparker;	state Exp;
branches;
next	1.10.2.4;

1.10.2.4
date	2001.02.02.14.46.54;	author bparker;	state Exp;
branches;
next	;

1.15.4.1
date	2004.03.17.21.23.10;	author morrison;	state Exp;
branches;
next	;

1.15.6.1
date	2002.09.26.23.04.17;	author morrison;	state Exp;
branches;
next	1.15.6.2;

1.15.6.2
date	2004.03.11.23.48.58;	author morrison;	state Exp;
branches;
next	;


desc
@@


1.17
log
@moved to src/tclscripts/
@
text
@##
#				E D I T _ S O L I D . T C L
#
# Authors -
#	Bob Parker
#
# Source -
#	The U. S. Army Research Laboratory
#	Aberdeen Proving Ground, Maryland  21005
#
# Distribution Notice -
#	Re-distribution of this software is restricted, as described in
#       your "Statement of Terms and Conditions for the Release of
#       The BRL-CAD Package" agreement.
#
# Description -
#	This is a primitive editor for MGED that can be used to both edit and
#	create primitives.
#
# Acknowledgements -
#	This editor is based on Glen Durfee's editobj.tcl (to edit primitives)
#	and solcreate.tcl (to create primitives).
#

## - init_edit_solid
#
proc init_edit_solid { id args } {
    global mged_gui
    global solid_data
    global esol_control
    global ::tk::Priv

    if {[opendb] == ""} {
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "No database." \
		"No database has been opened!" info 0 OK
	return
    }

    set w .$id.edit_solid

    if { [winfo exists $w] } {
	raise $w
	return
    }

    set esol_control($id,cmd) ""

    if ![info exists esol_control($id,inc_op)] {
	set esol_control($id,inc_op) $solid_data(entry,incr_op)
    }

    if ![info exists esol_control($id,dec_op)] {
	set esol_control($id,dec_op) $solid_data(entry,decr_op)
    }

    if ![info exists esol_control($id,format_string)] {
	set esol_control($id,format_string) $solid_data(entry,fmt)
    }

    if {[llength $args] > 0} {
	# if a name is provided, use it
	set esol_control($id,name) [lindex $args 0]
    } elseif {![info exists esol_control($id,name)] || $esol_control($id,name) == "" } {
	set esol_control($id,name) $solid_data(name,default)
    }

    if ![info exists esol_control($id,type)] {
	set esol_control($id,type) $solid_data(type,default)
    }

    if ![info exists esol_control($id,draw)] {
	set esol_control($id,draw) 1
    }

    set row -1
    toplevel $w -screen $mged_gui($id,screen)

    incr row
    frame $w._F$row -relief flat -bd 2
    frame $w.nameF
    label $w.nameL -text "Name:" -anchor e
    set hoc_data { { summary "The name of a primitive must be unique
within a database." } }
    hoc_register_data $w.nameL "Primitive Name" $hoc_data
    entry $w.nameE -relief sunken -bd 2 -textvar esol_control($id,name)
    hoc_register_data $w.nameE "Primitive Name" $hoc_data
    grid $w.nameL $w.nameE -in $w.nameF
    bind $w.nameE <Return> "esol_reset $id $w 0"
    #
    frame $w.typeF
    label $w.typeL -text "Type:" -anchor e
    hoc_register_data $w.typeL "Primitive Type"\
	    { { summary "The supported primitive types are: arb8, sph,
ell, tor, rec, half, rpc, rhc, epa, ehy, eto
part, dsp, ebm and vol." } }
    menubutton $w.typeMB -relief raised -bd 2 -textvariable esol_control($id,type)\
	    -menu $w.typeMB.m -indicatoron 1
    hoc_register_data $w.typeMB "Primitive Type"\
	    { { summary "Indicates the current primitive type. Note that
the left mouse button will pop up a menu
of the supported primitive types." } }
    menu $w.typeMB.m -title "Primitive Type" -tearoff 0
    foreach type $solid_data(types) {
	$w.typeMB.m add command -label $type\
		-command "esol_process_type $id $w.sformF $type"
	hoc_register_menu_data "Primitive Type" $type "Primitive Type - $type"\
		"\"synopsis \\\"Change primitive type to $type.\\\"\"
	         \"description \\\"$solid_data(hoc,$type)\\\"\""
    }
    grid $w.typeL $w.typeMB -in $w.typeF
    #
    grid $w.nameF x $w.typeF x -sticky nsew -in $w._F$row -padx 8
    grid columnconfigure $w._F$row 0 -weight 0
    grid columnconfigure $w._F$row 1 -weight 0
    grid columnconfigure $w._F$row 2 -weight 0
    grid columnconfigure $w._F$row 3 -weight 1
    grid $w._F$row -row $row -column 0 -sticky nsew -pady 8
    grid rowconfigure $w $row -weight 0

    incr row
    set esol_control(form) $row
    esol_build_default_form $id $w.sformF
    grid $w.sformF -row $row -column 0 -sticky nsew -padx 8
    grid rowconfigure $w $row -weight 1

    incr row
    frame $w._F$row -relief groove -bd 2
    #
    frame $w.decF
    set hoc_data { { summary "The decrement equation is used to modify
the primitive parameter values. Note that \"$val\"
represents the current value in a primitive
parameter entry widget and must be present
somewhere in the equation." } }
    label $w.decL -text "-operator:" -width 9 -anchor e
    hoc_register_data $w.decL "Decrement Operator Equation" $hoc_data
    entry $w.decE -relief sunken -bd 2 -textvar esol_control($id,dec_op)
    hoc_register_data $w.decE "Decrement Operator Equation" $hoc_data
    grid $w.decL $w.decE -in $w.decF -sticky nsew
    grid columnconfigure $w.decF 0 -weight 0
    grid columnconfigure $w.decF 1 -weight 1
    #
    frame $w.incF
    set hoc_data { { summary "The increment equation is used to modify
the primitive parameter values. Note that \"$val\"
represents the current value in a primitive
parameter entry widget and must be present
somewhere in the equation." } }
    label $w.incL -text "+operator:" -width 9 -anchor e
    hoc_register_data $w.incL "Increment Operator Equation" $hoc_data
    entry $w.incE -relief sunken -bd 2 -textvar esol_control($id,inc_op)
    hoc_register_data $w.incE "Increment Operator Equation" $hoc_data
    grid $w.incL $w.incE -in $w.incF -sticky nsew
    grid columnconfigure $w.incF 0 -weight 0
    grid columnconfigure $w.incF 1 -weight 1
    #
    frame $w.fmtF
    set hoc_data { { summary "This string is used with the Tcl
format command to format the values
of the primitive parameter entries." }
              { see_also format } }
    label $w.fmtL -text "format:" -width 9 -anchor e
    hoc_register_data $w.fmtL "Format" $hoc_data
    entry $w.fmtE -relief sunken -bd 2 -textvar esol_control($id,format_string)
    hoc_register_data $w.fmtE "Format" $hoc_data
    grid $w.fmtL $w.fmtE -in $w.fmtF -sticky nsew
    grid columnconfigure $w.fmtF 0 -weight 0
    grid columnconfigure $w.fmtF 1 -weight 1
    bind $w.fmtE <Return> "esol_format_entries $id $w.sformF._F"
    #
    grid $w.decF x $w.incF -sticky nsew -in $w._F$row -padx 8 -pady 8
    grid $w.fmtF x x -sticky nsew -in $w._F$row -padx 8 -pady 8
    grid columnconfigure $w._F$row 0 -weight 1
    grid columnconfigure $w._F$row 1 -weight 0
    grid columnconfigure $w._F$row 2 -weight 1
    grid $w._F$row -row $row -column 0 -sticky nsew -padx 8 -pady 8
    grid rowconfigure $w $row -weight 0

    incr row
    checkbutton $w.drawCB -relief flat -bd 2 -text "Draw"\
	    -offvalue 0 -onvalue 1 -variable esol_control($id,draw)
    hoc_register_data $w.drawCB "Draw"\
	    { { summary "Toggle drawing/updating the primitive
in the panes (geometry windows)." } }
    grid $w.drawCB -row $row -column 0 -sticky nsew -padx 8
    grid rowconfigure $w $row -weight 0

    incr row
    set esol_control(buttons) $row
    frame $w._F$row -borderwidth 2
    button $w.okB -text "OK" \
	    -command "esol_ok $id $w $w.sformF"
    hoc_register_data $w.okB "OK"\
	    { { summary "Apply the control panel settings to the
database primitive, then dismiss/close the
control panel." } }
    button $w.applyB -text "Apply" -command "esol_apply $id $w $w.sformF"
    hoc_register_data $w.applyB "Apply"\
	    { { summary "Apply the control panel settings
to the database primitive." } }
    button $w.resetB -text "Reset" -command "esol_reset $id $w 1"
    hoc_register_data $w.resetB "Reset"\
	    { { summary "Reset the primitive parameter entries
with values from the database." } }
    button $w.dismissB -text "Dismiss" -command "destroy $w"
    hoc_register_data $w.dismissB "Dismiss"\
	    { { summary "Dismiss/close the control panel." } }
    grid $w.okB $w.applyB x $w.resetB x $w.dismissB -sticky nsew -in $w._F$row
    grid columnconfigure $w._F$row 2 -weight 1
    grid columnconfigure $w._F$row 4 -weight 1
    grid $w._F$row -row $row -column 0 -sticky nsew -padx 6 -pady 8
    grid rowconfigure $w $row -weight 0
    esol_rename_applyB $id $w

    # only one column
    grid columnconfigure $w 0 -weight 1

    place_near_mouse $w
    wm protocol $w WM_DELETE_WINDOW "catch { destroy $w }"
    wm title $w "Primitive Editor ($id)"
}

## - esol_build_default_form
#
# Using $esol_control($id,name), determine if a primitive exists by this name.
# If so, then use its values to initialize the form. Otherwise, use
# the default values for the current primitive type to initialize the form.
#
proc esol_build_default_form { id w } {
    global solid_data
    global esol_control

    if [catch {set vals [db get $esol_control($id,name)]} msg] {
	# This primitive doesn't exist yet, so use the last primitive type
	#   to get attributes and their values.
	set vals $solid_data(attr,$esol_control($id,type))

	# create mode
	set esol_control($id,edit) 0
	set esol_control($id,cmd) "db put $esol_control($id,name) $esol_control($id,type)"
    } else {
	set esol_control($id,edit) 1
	set esol_control($id,type) [lindex $vals 0]
	set esol_control($id,cmd) "db adjust $esol_control($id,name)"

	# skip primitive type
	set vals [lrange $vals 1 end]
    }

    esol_build_form $id $w $esol_control($id,type) $vals 1 1 1
}

## - esol_build_form
#
# This proc builds a primitive form for creating/editing primitives.
#
proc esol_build_form { id w type vals do_gui do_cmd do_entries } {
    global base2local
    global local2base
    global solid_data
    global esol_control

    set sform $w._F

    if $do_gui {
	frame $w -relief groove -bd 2
	frame $sform
    }

    set form [db form $type]
    set len [llength $form]

    for { set i 0; set row 0 } { $i < $len } { incr i; incr row } {
	set attr [lindex $form $i]
	incr i

	if $do_cmd {
	    set esol_control($id,cmd) "$esol_control($id,cmd) $attr \""
	}

	if $do_gui {
	    if { [catch { label $sform._$attr\L -text "$solid_data(labels,$attr)" \
		    -anchor w }]!=0 } {
		label $sform._$attr\L -text "$attr" -anchor w
	    }
	    grid $sform._$attr\L -row $row -column 0 -sticky nsew
	    grid columnconfigure $sform 0 -weight 0
	}
	
	set field [lindex $form $i]
	set fieldlen [llength $field]
	for { set num 0 } { $num < $fieldlen } { incr num } {
	    set fe_type [lindex $field $num]
	    set tnum [expr $num % 4]

	    # increment row if more than 4 field elements
	    if {$num && $tnum == 0} {
		incr row
	    }

	    # configure each row
	    if {$tnum == 0 && $do_gui} {
		grid rowconfigure $sform $row -weight 1
	    }

	    switch -glob $fe_type {
		# bu_vls type arguments are %S, char arrays are %s.
		{%*[sS]} {
		    if $do_gui {
			entry $sform._$attr\E$num -relief sunken
			grid $sform._$attr\E$num - - -row $row -column 1 -sticky nsew
			grid columnconfigure $sform 1 -weight 1
		    }

		    if $do_entries {
			$sform._$attr\E$num delete 0 end
			$sform._$attr\E$num insert insert \
				[lindex [lindex $vals $i] $num]
		    }

		    if $do_cmd {
			set esol_control($id,cmd) "$esol_control($id,cmd)\[$sform._$attr\E$num get\]"
		    }
		}
		%*d {
		    if $do_gui {
			button $sform._$attr\decB$num -text \- -command \
				"esol_dec_int $id $sform._$attr\E$num"
			button $sform._$attr\incB$num -text \+ -command \
				"esol_inc_int $id $sform._$attr\E$num"
			entry $sform._$attr\E$num -width 6 -relief sunken
			
			grid $sform._$attr\decB$num -row $row -column [expr $tnum * 3 + 1] -sticky nsew
			grid $sform._$attr\E$num -row $row -column [expr $tnum * 3 + 2] -sticky nsew
			grid $sform._$attr\incB$num -row $row -column [expr $tnum * 3 + 3] -sticky nsew
			grid columnconfigure $sform [expr $tnum * 3 + 1] -weight 0
			grid columnconfigure $sform [expr $tnum * 3 + 2] -weight 1
			grid columnconfigure $sform [expr $tnum * 3 + 3] -weight 0
		    }

		    if $do_entries {
			$sform._$attr\E$num delete 0 end
			$sform._$attr\E$num insert insert [lindex [lindex $vals $i] $num]
		    }

		    if $do_cmd {
			set esol_control($id,cmd) "$esol_control($id,cmd) \[$sform._$attr\E$num get\]"
		    }
		}
		%*f {
		    if $do_gui {
			button $sform._$attr\decB$num -text \- -command \
				"esol_dec $id $sform._$attr\E$num"
			button $sform._$attr\incB$num -text \+ -command \
				"esol_inc $id $sform._$attr\E$num"
			entry $sform._$attr\E$num -width 6 -relief sunken

			grid $sform._$attr\decB$num -row $row -column [expr $tnum * 3 + 1] -sticky nsew
			grid $sform._$attr\E$num -row $row -column [expr $tnum * 3 + 2] -sticky nsew
			grid $sform._$attr\incB$num -row $row -column [expr $tnum * 3 + 3] -sticky nsew
			grid columnconfigure $sform [expr $tnum * 3 + 1] -weight 0
			grid columnconfigure $sform [expr $tnum * 3 + 2] -weight 1
			grid columnconfigure $sform [expr $tnum * 3 + 3] -weight 0
		    }

		    if $do_entries {
			$sform._$attr\E$num delete 0 end
			$sform._$attr\E$num insert insert \
				[format $esol_control($id,format_string) [expr [lindex \
				[lindex $vals $i] $num] * $base2local]]
		    }

		    if $do_cmd {
			set esol_control($id,cmd) "$esol_control($id,cmd) \[expr \[$sform._$attr\E$num get\] * $local2base\]"
		    }
		}
		default {
		    puts "esolint_build_form: skipping, attr - $attr, field - $fe_type"
		}
	    }
	}

	if $do_gui {
	    grid rowconfigure $sform $row -weight 1
	}

	if $do_cmd {
	    set esol_control($id,cmd) "$esol_control($id,cmd)\""
	}
    }

    if $do_gui {
	grid $sform -sticky nsew -row 0 -column 0 -padx 8 -pady 8
	grid columnconfigure $w 0 -weight 1
	grid rowconfigure $w 0 -weight 1
    }
}

proc esol_ok { id w sform } {
    esol_apply $id $w $sform
    catch { destroy $w }
}

## - esol_apply
#
proc esol_apply { id w sform } {
    global esol_control

    set solid_exists [expr ![catch {db get $esol_control($id,name)} vals]]
    if {$esol_control($id,name) != [lindex $esol_control($id,cmd) 2] ||\
	    ($esol_control($id,edit) && !$solid_exists)} {
	# Here we assume (yikes!!!) that the user is aware
	# of what he/she is doing and oblige by making
	# a last minute change to the command list.

	switch $esol_control($id,edit) {
	    0 {
		set last 3
	    }
	    1 {
		set last 2
	    }
	    2 {
		set last 5
	    }
	}

	if $solid_exists {
	    if {$esol_control($id,type) == [lindex $vals 0]} {
		set tmp_db_cmd [lreplace $esol_control($id,cmd)\
			0 $last db adjust $esol_control($id,name)]
	    } else {
		set tmp_db_cmd "kill $esol_control($id,name);\
			[lreplace $esol_control($id,cmd)\
			0 $last db put $esol_control($id,name) $esol_control($id,type)]"
	    }
	} else {
	    # This primitive doesn't exist.
	    set tmp_db_cmd [lreplace $esol_control($id,cmd)\
		    0 $last db put $esol_control($id,name) $esol_control($id,type)]
	}

	# fix the broken command list
	regsub -all "\[{}\]" $tmp_db_cmd \" esol_control($id,cmd)
    }

    eval [set esol_control($id,cmd)]

    set esol_control($id,edit) 1
    esol_rename_applyB $id $w

    # rebuild esol_control($id,db_cmd)
    set esol_control($id,cmd) "db adjust $esol_control($id,name)"
    esol_build_form $id $sform $esol_control($id,type) {} 0 1 0

    if $esol_control($id,draw) {
	if [esol_isdrawn $esol_control($id,name)] {
	    eval _mged_draw [_mged_who]
	} else {
	    _mged_draw $esol_control($id,name)
	}
    }
}

proc esol_isdrawn { sol } {
    set sol_list [_mged_x -2]

    if {-1 < [lsearch -exact $sol_list $sol]} {
	return 1
    }

    return 0
}

## - esol_inc_int
#
proc esol_inc_int { id entryfield } {
    global esol_control

    set val [expr int([$entryfield get])]
    incr val

    $entryfield delete 0 end
    $entryfield insert insert $val
}

## - esol_dec_int
#
proc esol_dec_int { id entryfield } {
    global esol_control

    set val [expr int([$entryfield get])]
    incr val -1

    $entryfield delete 0 end
    $entryfield insert insert $val
}

## - esol_inc
#
proc esol_inc { id entryfield } {
    global esol_control

    set val [$entryfield get]

    $entryfield delete 0 end
    $entryfield insert insert [format $esol_control($id,format_string) [expr $esol_control($id,inc_op)]]
}

## - esol_dec
#
proc esol_dec { id entryfield } {
    global esol_control

    set val [$entryfield get]

    $entryfield delete 0 end
    $entryfield insert insert [format $esol_control($id,format_string) [expr $esol_control($id,dec_op)]]
}

## - esol_process_type
#
proc esol_process_type { id w newType } {
    global solid_data
    global esol_control

    # nothing to do
    if {$newType == $esol_control($id,type)} {
	return
    }

    if [catch {db get $esol_control($id,name)} vals] {
	# This primitive doesn't exist.

	# create mode
	set esol_control($id,edit) 0
	set esol_control($id,cmd) "db put $esol_control($id,name) $newType"
	set vals $solid_data(attr,$newType)
    } else {
	# This primitive exists

	if { $newType == [lindex $vals 0] } {
	    # going back to original type, so use values from primitive
	    # skip type
	    set vals [lrange $vals 1 end]

	    set esol_control($id,edit) 1
	    set esol_control($id,cmd) "db adjust $esol_control($id,name)"
	} else {
	    # changing primitive type, so use default values
	    set vals $solid_data(attr,$newType)

	    set esol_control($id,edit) 2
	    set esol_control($id,cmd) "kill $esol_control($id,name); db put $esol_control($id,name) $newType"
	}
    }

    set esol_control($id,type) $newType

    # remove and destroy existing form
    grid forget $w
    destroy $w

    # create and install a new form
    esol_build_form $id $w $newType $vals 1 1 1
    grid $w -row $esol_control(form) -column 0 -sticky nsew -padx 8 -pady 8
}

## - esol_reset
#
proc esol_reset { id w reset_entry_values } {
    global solid_data
    global esol_control

    if [catch {db get $esol_control($id,name)} vals] {
	# This primitive doesn't exist.

	# create mode
	set esol_control($id,edit) 0
	set esol_control($id,cmd) "db put $esol_control($id,name) $esol_control($id,type)"

	if $reset_entry_values {
	    set vals $solid_data(attr,$esol_control($id,type))

	    # reset command and entry values
	    esol_build_form $id $w.sformF $esol_control($id,type) $vals 0 1 1
	} else {
	    # reset command
	    esol_build_form $id $w.sformF $esol_control($id,type) {} 0 1 0
	}
    } else {
	# This primitive exists

	# edit mode
	set esol_control($id,edit) 1
	set esol_control($id,cmd) "db adjust $esol_control($id,name)"

	set type [lindex $vals 0]
	set vals [lrange $vals 1 end]
	if { $esol_control($id,type) == $type } {
	    # reset command and entry values
	    esol_build_form $id $w.sformF $esol_control($id,type) $vals 0 1 1
	} else {
	    set esol_control($id,type) $type

	    # remove and destroy existing form
	    grid forget $w.sformF
	    destroy $w.sformF

	    # create and install a new form
	    esol_build_form $id $w.sformF $esol_control($id,type) $vals 1 1 1
	    grid $w.sformF -row $esol_control(form) -column 0 -sticky nsew -padx 8 -pady 8
	}
    }

    esol_rename_applyB $id $w
}

proc esol_rename_applyB { id w } {
    global esol_control

    #XXX Disable for now.
    if { 0 } {
	if { $esol_control($id,edit) } {
	    $w.applyB configure -text "Apply"
	} else {
	    $w.applyB configure -text "Create"
	}
    }
}

proc esol_format_entries { id w } {
    global esol_control

    foreach child [winfo children $w] {
	if { [winfo class $child] == "Entry" } {
	    set val [$child get]
	    $child delete 0 end
	    $child insert insert [format $esol_control($id,format_string) $val]
	}
    }
}
@


1.16
log
@*** empty log message ***
@
text
@@


1.15
log
@*- mods requested by Eric regarding consistency
   when using capitalization in the GUI
@
text
@d31 1
a31 1
    global tkPriv
d34 1
a34 1
	cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "No database." \
@


1.15.4.1
log
@sync branch with HEAD
@
text
@d31 1
a31 1
    global ::tk::Priv
d34 1
a34 1
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "No database." \
@


1.15.6.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d31 1
a31 1
    variable ::tk::Priv
d34 1
a34 1
	cad_dialog $Priv(cad_dialog) $mged_gui($id,screen) "No database." \
@


1.15.6.2
log
@sync to HEAD...
@
text
@d31 1
a31 1
    global ::tk::Priv
d34 1
a34 1
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "No database." \
@


1.14
log
@*- change solid to primitive
@
text
@d191 1
a191 1
    button $w.okB -text "Ok" \
d193 1
a193 1
    hoc_register_data $w.okB "Ok"\
@


1.13
log
@Use tkPriv(cad_dialog) for dialog name.
@
text
@d17 2
a18 2
#	This is a solid editor for MGED that can be used to both edit and
#	create solids.
d21 2
a22 2
#	This editor is based on Glen Durfee's editobj.tcl (to edit solids)
#	and solcreate.tcl (to create solids).
d82 1
a82 1
    set hoc_data { { summary "The name of a solid must be unique
d84 1
a84 1
    hoc_register_data $w.nameL "Solid Name" $hoc_data
d86 1
a86 1
    hoc_register_data $w.nameE "Solid Name" $hoc_data
d92 2
a93 2
    hoc_register_data $w.typeL "Solid Type"\
	    { { summary "The supported solid types are: arb8, sph,
d98 2
a99 2
    hoc_register_data $w.typeMB "Solid Type"\
	    { { summary "Indicates the current solid type. Note that
d101 2
a102 2
of the supported solid types." } }
    menu $w.typeMB.m -title "Solid Type" -tearoff 0
d106 2
a107 2
	hoc_register_menu_data "Solid Type" $type "Solid Type - $type"\
		"\"synopsis \\\"Change solid type to $type.\\\"\"
d131 2
a132 2
the solid parameter values. Note that \"$val\"
represents the current value in a solid
d145 2
a146 2
the solid parameter values. Note that \"$val\"
represents the current value in a solid
d160 1
a160 1
of the solid parameter entries." }
d183 1
a183 1
	    { { summary "Toggle drawing/updating the solid
d195 1
a195 1
database solid, then dismiss/close the
d200 1
a200 1
to the database solid." } }
d203 1
a203 1
	    { { summary "Reset the solid parameter entries
d220 1
a220 1
    wm title $w "Solid Editor ($id)"
d225 1
a225 1
# Using $esol_control($id,name), determine if a solid exists by this name.
d227 1
a227 1
# the default values for the current solid type to initialize the form.
d234 1
a234 1
	# This solid doesn't exist yet, so use the last solid type
d246 1
a246 1
	# skip solid type
d255 1
a255 1
# This proc builds a solid form for creating/editing solids.
d438 1
a438 1
	    # This solid doesn't exist.
d533 1
a533 1
	# This solid doesn't exist.
d540 1
a540 1
	# This solid exists
d543 1
a543 1
	    # going back to original type, so use values from solid
d550 1
a550 1
	    # changing solid type, so use default values
d576 1
a576 1
	# This solid doesn't exist.
d592 1
a592 1
	# This solid exists
@


1.12
log
@Move call to solid_data_init to openw.tcl
@
text
@d31 1
d34 1
a34 1
	cad_dialog .$id.uncool $mged_gui($id,screen) "No database." \
@


1.11
log
@
Fixed it so that %S forms don't make the GUI-builder barf.
@
text
@a24 3
# Call this routine to initialize the "solid_data" array
solid_data_init

@


1.10
log
@*- check for no database open
@
text
@d309 2
a310 1
		%*s {
@


1.10.2.1
log
@Move call to solid_data_init to openw.tcl
@
text
@d25 3
@


1.10.2.2
log
@*** empty log message ***
@
text
@d306 1
a306 2
		# bu_vls type arguments are %S, char arrays are %s.
		{%*[sS]} {
@


1.10.2.3
log
@Use tkPriv(cad_dialog) for dialog name.
@
text
@a30 1
    global tkPriv
d33 1
a33 1
	cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "No database." \
@


1.10.2.4
log
@*- change solid to primitive
@
text
@d17 2
a18 2
#	This is a primitive editor for MGED that can be used to both edit and
#	create primitives.
d21 2
a22 2
#	This editor is based on Glen Durfee's editobj.tcl (to edit primitives)
#	and solcreate.tcl (to create primitives).
d82 1
a82 1
    set hoc_data { { summary "The name of a primitive must be unique
d84 1
a84 1
    hoc_register_data $w.nameL "Primitive Name" $hoc_data
d86 1
a86 1
    hoc_register_data $w.nameE "Primitive Name" $hoc_data
d92 2
a93 2
    hoc_register_data $w.typeL "Primitive Type"\
	    { { summary "The supported primitive types are: arb8, sph,
d98 2
a99 2
    hoc_register_data $w.typeMB "Primitive Type"\
	    { { summary "Indicates the current primitive type. Note that
d101 2
a102 2
of the supported primitive types." } }
    menu $w.typeMB.m -title "Primitive Type" -tearoff 0
d106 2
a107 2
	hoc_register_menu_data "Primitive Type" $type "Primitive Type - $type"\
		"\"synopsis \\\"Change primitive type to $type.\\\"\"
d131 2
a132 2
the primitive parameter values. Note that \"$val\"
represents the current value in a primitive
d145 2
a146 2
the primitive parameter values. Note that \"$val\"
represents the current value in a primitive
d160 1
a160 1
of the primitive parameter entries." }
d183 1
a183 1
	    { { summary "Toggle drawing/updating the primitive
d195 1
a195 1
database primitive, then dismiss/close the
d200 1
a200 1
to the database primitive." } }
d203 1
a203 1
	    { { summary "Reset the primitive parameter entries
d220 1
a220 1
    wm title $w "Primitive Editor ($id)"
d225 1
a225 1
# Using $esol_control($id,name), determine if a primitive exists by this name.
d227 1
a227 1
# the default values for the current primitive type to initialize the form.
d234 1
a234 1
	# This primitive doesn't exist yet, so use the last primitive type
d246 1
a246 1
	# skip primitive type
d255 1
a255 1
# This proc builds a primitive form for creating/editing primitives.
d438 1
a438 1
	    # This primitive doesn't exist.
d533 1
a533 1
	# This primitive doesn't exist.
d540 1
a540 1
	# This primitive exists
d543 1
a543 1
	    # going back to original type, so use values from primitive
d550 1
a550 1
	    # changing primitive type, so use default values
d576 1
a576 1
	# This primitive doesn't exist.
d592 1
a592 1
	# This primitive exists
@


1.9
log
@*- mods to handle integer and string parameter types
*- simply code that builds the command string
*- mods to better handle matrices
@
text
@d35 6
@


1.8
log
@*- use place_near_mouse proc to position widgets near the mouse
@
text
@d91 1
a91 1
and part." } }
d269 1
a269 1
    for { set i 0; set row 0 } { $i<$len } { incr i; incr row } {
d274 1
a274 1
	    set esol_control($id,cmd) [eval concat \[set esol_control($id,cmd)\] $attr \\\"]
d288 8
a295 16
	for { set num 0 } { $num<$fieldlen } { incr num } {
	    if { [string first "%f" $field]>-1 } {
		if $do_gui {
		    button $sform._$attr\decB$num -text \- -command \
			    "esol_dec $id $sform._$attr\E$num"
		    button $sform._$attr\incB$num -text \+ -command \
			    "esol_inc $id $sform._$attr\E$num"
		    entry $sform._$attr\E$num -width 6 -relief sunken

		    grid $sform._$attr\decB$num -row $row -column [expr $num * 3 + 1] -sticky nsew
		    grid $sform._$attr\E$num -row $row -column [expr $num * 3 + 2] -sticky nsew
		    grid $sform._$attr\incB$num -row $row -column [expr $num * 3 + 3] -sticky nsew
		    grid columnconfigure $sform [expr $num * 3 + 1] -weight 0
		    grid columnconfigure $sform [expr $num * 3 + 2] -weight 1
		    grid columnconfigure $sform [expr $num * 3 + 3] -weight 0
		}
d297 4
d302 69
a370 5
		if $do_entries {
		    $sform._$attr\E$num delete 0 end
		    $sform._$attr\E$num insert insert \
			    [format $esol_control($id,format_string) [expr [lindex \
			    [lindex $vals $i] $num] * $base2local]]
d372 2
a373 4

		if $do_cmd {
		    set esol_control($id,cmd) [eval concat \[set esol_control($id,cmd)\] \
			    \\\[expr \\\[$sform._$attr\E$num get\\\] * $local2base\\\]]
a374 3
	    } else {
		# XXXX Temporary debugging
		puts "esol_build_form: skipping field"
d383 1
a383 1
	    set esol_control($id,cmd) [eval concat \[set esol_control($id,cmd)\] \\\"]
d468 24
@


1.7
log
@*- cleanup variables
@
text
@d214 1
a214 4
    set pxy [winfo pointerxy $w]
    set x [lindex $pxy 0]
    set y [lindex $pxy 1]

a215 1
    wm geometry $w +$x+$y
@


1.6
log
@*- change esol_do_cmd to esol_apply
@
text
@d31 1
a31 1
    global player_screen
d33 1
a33 8
    global esol_db_cmd
    global esol_inc_operation
    global esol_dec_operation
    global esol_format_string
    global esol_name
    global esol_type
    global esol_row
    global esol_draw
d42 1
a42 1
    set esol_db_cmd($id) ""
d44 2
a45 2
    if ![info exists esol_inc_operation($id)] {
	set esol_inc_operation($id) $solid_data(entry,incr_op)
d48 2
a49 2
    if ![info exists esol_dec_operation($id)] {
	set esol_dec_operation($id) $solid_data(entry,decr_op)
d52 2
a53 2
    if ![info exists esol_format_string($id)] {
	set esol_format_string($id) $solid_data(entry,fmt)
d58 3
a60 3
	set esol_name($id) [lindex $args 0]
    } elseif {![info exists esol_name($id)] || $esol_name($id) == "" } {
	set esol_name($id) $solid_data(name,default)
d63 2
a64 2
    if ![info exists esol_type($id)] {
	set esol_type($id) $solid_data(type,default)
d67 2
a68 2
    if ![info exists esol_draw($id)] {
	set esol_draw($id) 1
d72 1
a72 1
    toplevel $w -screen $player_screen($id)
d81 1
a81 1
    entry $w.nameE -relief sunken -bd 2 -textvar esol_name($id)
d92 1
a92 1
    menubutton $w.typeMB -relief raised -bd 2 -textvariable esol_type($id)\
d117 1
a117 1
    set esol_row(form) $row
d133 1
a133 1
    entry $w.decE -relief sunken -bd 2 -textvar esol_dec_operation($id)
d147 1
a147 1
    entry $w.incE -relief sunken -bd 2 -textvar esol_inc_operation($id)
d160 1
a160 1
    entry $w.fmtE -relief sunken -bd 2 -textvar esol_format_string($id)
d177 1
a177 1
	    -offvalue 0 -onvalue 1 -variable esol_draw($id)
d185 1
a185 1
    set esol_row(buttons) $row
d225 1
a225 1
# Using $esol_name($id), determine if a solid exists by this name.
d231 1
a231 4
    global esol_db_cmd
    global esol_name
    global esol_type
    global esol_edit
d233 1
a233 1
    if [catch {set vals [db get $esol_name($id)]} msg] {
d236 1
a236 1
	set vals $solid_data(attr,$esol_type($id))
d239 2
a240 2
	set esol_edit($id) 0
	set esol_db_cmd($id) "db put $esol_name($id) $esol_type($id)"
d242 3
a244 3
	set esol_edit($id) 1
	set esol_type($id) [lindex $vals 0]
	set esol_db_cmd($id) "db adjust $esol_name($id)"
d250 1
a250 1
    esol_build_form $id $w $esol_type($id) $vals 1 1 1
d261 1
a261 3
    global esol_db_cmd
    global esol_format_string
    global esol_name
d278 1
a278 1
	    set esol_db_cmd($id) [eval concat \[set esol_db_cmd($id)\] $attr \\\"]
d313 1
a313 1
			    [format $esol_format_string($id) [expr [lindex \
d318 1
a318 1
		    set esol_db_cmd($id) [eval concat \[set esol_db_cmd($id)\] \
d332 1
a332 1
	    set esol_db_cmd($id) [eval concat \[set esol_db_cmd($id)\] \\\"]
d351 5
a355 9
    global esol_db_cmd
    global esol_name
    global esol_type
    global esol_edit
    global esol_draw

    set solid_exists [expr ![catch {db get $esol_name($id)} vals]]
    if {$esol_name($id) != [lindex $esol_db_cmd($id) 2] ||\
	    ($esol_edit($id) && !$solid_exists)} {
d360 1
a360 1
	switch $esol_edit($id) {
d373 3
a375 3
	    if {$esol_type($id) == [lindex $vals 0]} {
		set tmp_db_cmd [lreplace $esol_db_cmd($id)\
			0 $last db adjust $esol_name($id)]
d377 3
a379 3
		set tmp_db_cmd "kill $esol_name($id);\
			[lreplace $esol_db_cmd($id)\
			0 $last db put $esol_name($id) $esol_type($id)]"
d383 2
a384 2
	    set tmp_db_cmd [lreplace $esol_db_cmd($id)\
		    0 $last db put $esol_name($id) $esol_type($id)]
d388 1
a388 1
	regsub -all "\[{}\]" $tmp_db_cmd \" esol_db_cmd($id)
d391 1
a391 1
    eval [set esol_db_cmd($id)]
d393 1
a393 1
    set esol_edit($id) 1
d396 3
a398 3
    # rebuild esol_db_cmd
    set esol_db_cmd($id) "db adjust $esol_name($id)"
    esol_build_form $id $sform $esol_type($id) {} 0 1 0
d400 2
a401 2
    if $esol_draw($id) {
	if [esol_isdrawn $esol_name($id)] {
d404 1
a404 1
	    _mged_draw $esol_name($id)
d422 1
a422 2
    global esol_inc_operation
    global esol_format_string
d427 1
a427 1
    $entryfield insert insert [format $esol_format_string($id) [expr $esol_inc_operation($id)]]
d433 1
a433 2
    global esol_dec_operation
    global esol_format_string
d438 1
a438 1
    $entryfield insert insert [format $esol_format_string($id) [expr $esol_dec_operation($id)]]
d445 1
a445 5
    global esol_db_cmd
    global esol_name
    global esol_type
    global esol_row
    global esol_edit
d448 1
a448 1
    if {$newType == $esol_type($id)} {
d452 1
a452 1
    if [catch {db get $esol_name($id)} vals] {
d456 2
a457 2
	set esol_edit($id) 0
	set esol_db_cmd($id) "db put $esol_name($id) $newType"
d467 2
a468 2
	    set esol_edit($id) 1
	    set esol_db_cmd($id) "db adjust $esol_name($id)"
d473 2
a474 2
	    set esol_edit($id) 2
	    set esol_db_cmd($id) "kill $esol_name($id); db put $esol_name($id) $newType"
d478 1
a478 1
    set esol_type($id) $newType
d486 1
a486 1
    grid $w -row $esol_row(form) -column 0 -sticky nsew -padx 8 -pady 8
d493 1
a493 5
    global esol_db_cmd
    global esol_name
    global esol_type
    global esol_row
    global esol_edit
d495 1
a495 1
    if [catch {db get $esol_name($id)} vals] {
d499 2
a500 2
	set esol_edit($id) 0
	set esol_db_cmd($id) "db put $esol_name($id) $esol_type($id)"
d503 1
a503 1
	    set vals $solid_data(attr,$esol_type($id))
d506 1
a506 1
	    esol_build_form $id $w.sformF $esol_type($id) $vals 0 1 1
d509 1
a509 1
	    esol_build_form $id $w.sformF $esol_type($id) {} 0 1 0
d515 2
a516 2
	set esol_edit($id) 1
	set esol_db_cmd($id) "db adjust $esol_name($id)"
d520 1
a520 1
	if { $esol_type($id) == $type } {
d522 1
a522 1
	    esol_build_form $id $w.sformF $esol_type($id) $vals 0 1 1
d524 1
a524 1
	    set esol_type($id) $type
d531 2
a532 2
	    esol_build_form $id $w.sformF $esol_type($id) $vals 1 1 1
	    grid $w.sformF -row $esol_row(form) -column 0 -sticky nsew -padx 8 -pady 8
d540 1
a540 1
    global esol_edit
d544 1
a544 1
	if { $esol_edit($id) } {
d553 1
a553 1
    global esol_format_string
d559 1
a559 1
	    $child insert insert [format $esol_format_string($id) $val]
@


1.5
log
@*- add help messages
@
text
@d200 1
a200 1
    button $w.applyB -text "Apply" -command "esol_do_cmd $id $w $w.sformF"
d356 1
a356 1
    esol_do_cmd $id $w $sform
d360 1
a360 1
## - esol_do_cmd
d362 1
a362 1
proc esol_do_cmd { id w sform } {
@


1.4
log
@*- add Ok button
*- add help messages --- still need solid specific messages
@
text
@d85 1
a85 2
    hoc_register_data $w.nameL "Solid Name"\
	    { { summary "The name of a solid must be unique
d87 1
d89 1
a89 3
    hoc_register_data $w.nameE "Solid Name"\
	    { { summary "Enter a solid name. Note that the
name must be unique." } }
d133 1
a133 3
    label $w.decL -text "-operator:" -width 9 -anchor e
    hoc_register_data $w.decL "Decrement Operator Equation"\
	    { { summary "The decrement equation is used to modify
d138 2
d141 1
a141 5
    hoc_register_data $w.decE "Decrement Operator Equation"\
	    { { summary "Enter the decrement operator equation.
Note that \"$val\" represents the current value
in a solid parameter entry widget and must
be present somewhere in the equation." } }
d147 1
a147 3
    label $w.incL -text "+operator:" -width 9 -anchor e
    hoc_register_data $w.incL "Increment Operator Equation"\
	    { { summary "The increment equation is used to modify
d152 2
d155 1
a155 5
    hoc_register_data $w.incE "Increment Operator Equation"\
	    { { summary "Enter the increment operator equation.
Note that \"$val\" represents the current value
in a solid parameter entry widget and must
be present somewhere in the equation." } }
d161 1
a161 3
    label $w.fmtL -text "format:" -width 9 -anchor e
    hoc_register_data $w.fmtL "Format"\
	    { { summary "This string is used with the Tcl
d165 2
d168 1
a168 3
    hoc_register_data $w.fmtE "Format"\
	    { { summary "Enter the format string." }
              { see_also format } }
@


1.3
log
@*- modified esol_do_cmd to redraw solids if the solid being
	edited exists in the solid list. If it doesn't then
	draw only that solid.
@
text
@d85 3
d89 3
d97 4
d103 5
a107 1
    menu $w.typeMB.m -tearoff 0
d111 3
d136 6
d143 5
d154 6
d161 5
d172 5
d178 3
d197 3
d206 6
d213 3
d217 3
d221 5
a225 6
    grid $w.applyB x $w.resetB x $w.dismissB -sticky nsew -in $w._F$row
    grid columnconfigure $w._F$row 0 -weight 0
    grid columnconfigure $w._F$row 1 -weight 1
    grid columnconfigure $w._F$row 2 -weight 0
    grid columnconfigure $w._F$row 3 -weight 1
    grid columnconfigure $w._F$row 4 -weight 0
d365 5
@


1.2
log
@*- added (id) to the title
@
text
@d363 5
a367 3
	set lineup [_mged_who]
	_mged_draw $esol_name($id)
	eval _mged_draw $lineup
d369 10
@


1.1
log
@*- a solid editor that provides a way to both
   edit and create solids
@
text
@d111 1
a111 1
    grid $w.sformF -row $row -column 0 -sticky nsew -padx 8 -pady 8
d144 1
a144 1
    grid $w._F$row -row $row -column 0 -sticky nsew -padx 8 -pady 4
d150 1
a150 1
    grid $w.drawCB -row $row -column 0 -sticky nsew -padx 8 -pady 4
d178 1
a178 1
    wm title $w "Solid Editor"
d363 1
d365 1
@
