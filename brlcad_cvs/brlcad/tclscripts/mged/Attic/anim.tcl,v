head	1.32;
access;
symbols
	ansi-20040405-merged:1.30.4.1
	postmerge-20040405-ansi:1.31
	premerge-20040404-ansi:1.31
	postmerge-autoconf:1.31
	autoconf-freeze:1.31
	premerge-autoconf:1.31
	postmerge-20040315-windows:1.31
	premerge-20040315-windows:1.31
	windows-20040315-freeze:1.30.6.2
	autoconf-20031203:1.31
	autoconf-20031202:1.31
	autoconf-branch:1.31.0.6
	phong-branch:1.31.0.4
	photonmap-branch:1.31.0.2
	rel-6-1-DP:1.30
	windows-branch:1.30.0.6
	rel-6-0-2:1.30
	ansi-branch:1.30.0.4
	rel-6-0-1-branch:1.30.0.2
	hartley-6-0-post:1.30
	hartley-6-0-pre:1.30
	rel-6-0-1:1.30
	rel-6-0:1.30
	rel-5-4:1.24.2.1
	offsite-5-3-pre:1.25
	rel-5-3:1.24.2.1
	rel-5-2:1.24
	rel-5-1-branch:1.24.0.2
	rel-5-1:1.24
	rel-5-0:1.24
	rel-5-0-beta:1.23
	rel-4-5:1.20;
locks; strict;
comment	@# @;


1.32
date	2004.05.21.16.41.21;	author morrison;	state dead;
branches;
next	1.31;

1.31
date	2003.03.13.19.45.30;	author jra;	state Exp;
branches;
next	1.30;

1.30
date	2001.11.05.21.20.07;	author morrison;	state Exp;
branches
	1.30.4.1
	1.30.6.1;
next	1.29;

1.29
date	2001.09.05.20.54.46;	author bparker;	state Exp;
branches;
next	1.28;

1.28
date	2001.08.14.18.40.54;	author bparker;	state Exp;
branches;
next	1.27;

1.27
date	2001.08.01.17.19.20;	author bparker;	state Exp;
branches;
next	1.26;

1.26
date	2001.04.03.22.33.03;	author bparker;	state Exp;
branches;
next	1.25;

1.25
date	2000.12.22.00.35.15;	author bparker;	state Exp;
branches;
next	1.24;

1.24
date	99.09.01.18.40.00;	author bparker;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	99.02.10.15.19.33;	author bparker;	state Exp;
branches;
next	1.22;

1.22
date	99.02.09.22.18.15;	author jra;	state Exp;
branches;
next	1.21;

1.21
date	99.02.09.15.19.38;	author bparker;	state Exp;
branches;
next	1.20;

1.20
date	96.08.29.20.28.16;	author cnuzman;	state Exp;
branches;
next	1.19;

1.19
date	96.08.26.23.19.19;	author cnuzman;	state Exp;
branches;
next	1.18;

1.18
date	96.08.19.17.25.54;	author cnuzman;	state Exp;
branches;
next	1.17;

1.17
date	96.08.16.23.48.15;	author cnuzman;	state Exp;
branches;
next	1.16;

1.16
date	96.08.15.20.31.57;	author cnuzman;	state Exp;
branches;
next	1.15;

1.15
date	96.08.14.19.21.50;	author cnuzman;	state Exp;
branches;
next	1.14;

1.14
date	96.08.13.11.54.39;	author cnuzman;	state Exp;
branches;
next	1.13;

1.13
date	96.08.01.21.42.32;	author cnuzman;	state Exp;
branches;
next	1.12;

1.12
date	96.07.31.00.36.16;	author cnuzman;	state Exp;
branches;
next	1.11;

1.11
date	96.07.30.01.05.19;	author cnuzman;	state Exp;
branches;
next	1.10;

1.10
date	96.07.27.02.32.17;	author cnuzman;	state Exp;
branches;
next	1.9;

1.9
date	96.07.24.21.27.08;	author cnuzman;	state Exp;
branches;
next	1.8;

1.8
date	96.07.24.02.24.45;	author cnuzman;	state Exp;
branches;
next	1.7;

1.7
date	96.07.22.21.45.12;	author cnuzman;	state Exp;
branches;
next	1.6;

1.6
date	96.07.19.21.00.44;	author cnuzman;	state Exp;
branches;
next	1.5;

1.5
date	96.07.19.00.12.28;	author cnuzman;	state Exp;
branches;
next	1.4;

1.4
date	96.07.19.00.08.56;	author cnuzman;	state Exp;
branches;
next	1.3;

1.3
date	96.07.19.00.02.35;	author cnuzman;	state Exp;
branches;
next	1.2;

1.2
date	96.07.17.18.03.44;	author cnuzman;	state Exp;
branches;
next	1.1;

1.1
date	96.07.17.15.57.06;	author cnuzman;	state Exp;
branches;
next	;

1.24.2.1
date	2000.12.22.00.02.28;	author bparker;	state Exp;
branches;
next	;

1.30.4.1
date	2004.03.17.21.23.09;	author morrison;	state Exp;
branches;
next	;

1.30.6.1
date	2002.09.26.23.04.16;	author morrison;	state Exp;
branches;
next	1.30.6.2;

1.30.6.2
date	2004.03.11.23.48.57;	author morrison;	state Exp;
branches;
next	;


desc
@Tcl/Tk gui interface for creating animations within MGED
@


1.32
log
@moved to src/tclscripts/
@
text
@# ANIM.TCL - AnimMate
# Tcl/Tk Gui Interface for Creating and Displaying Animation Scripts within
#  MGED.
# Author: Carl Nuzman
#Sections:
#	Create main window
#	Curve Editor
#	Table Editor
#	View Editor
#	Create Script
#	Create Track Script
#	Combine Scripts
#	Show Scripts
#	Quit AnimMate
#	General Procedures

if ![info exists tk_version] {
    loadtk
}

#Conventions:
# 1.> for each main widget *foo*, the calling routine should call
#  sketch_init_*foo* once before making any calls to sketch_popup_*foo*
#  Currently the choices for *foo* are from the following list:
#  {draw view table objanim track sort preview}
# 2.> a "p" argument indicates a parent widget. 
#  eg. when calling sketch_popup_draw the calling function provides a widget 
#  to be the new widget's parent. Whenever tk is running, there is a toplevel
#  widget called "." which can be used.
#-----------------------------------------------------------------
# Create main window
#-----------------------------------------------------------------
proc sketch_init_main {} {
	# global variable initialisations
	uplevel #0 set mged_sketch_init_main 1
	uplevel #0 set mged_sketch_temp1 "./_mged_sketch_temp1_"
	uplevel #0 set mged_sketch_temp2 "./_mged_sketch_temp2_"

	#note - change this variable in production version
#	set version "developement"
        set version ""
	if { $version == "developement" } {
		uplevel #0 {set mged_sketch_anim_path "/m/cad/.anim.6d/"}
		uplevel #0 {set mged_sketch_tab_path "/m/cad/.tab.6d/"}
	} else {
		uplevel #0 {set mged_sketch_anim_path ""}
		uplevel #0 {set mged_sketch_tab_path ""}
	}

	#variable shared between draw and table
	uplevel #0 set mged_sketch_fps "30"

	#allow button 2 to activate buttons
	uplevel #0 { set mged_sketch_bindclasses {Button Radiobutton Checkbutton Menubutton}}
	upvar #0 mged_sketch_bindclasses wlist
	foreach wclass $wlist {
		#save previous bindings
		uplevel #0 [list set mged_sketch_bindB($wclass) [bind $wclass <Button-2>] ]
		uplevel #0 [list set mged_sketch_bindBR($wclass) [bind $wclass <ButtonRelease-2>] ]
		uplevel #0 [list set mged_sketch_bindBM($wclass) [bind $wclass <B2-Motion>] ]
		#add new bindings
		bind $wclass <Button-2> +[bind $wclass <Button-1>]
		bind $wclass <ButtonRelease-2> +[bind $wclass <ButtonRelease-1>]
		bind $wclass <B2-Motion> +[bind $wclass <B1-Motion>]
	}
}

proc sketch_popup_main { {p .} } {
	sketch_init_main
	sketch_init_draw
	sketch_init_view
	sketch_init_table
	sketch_init_objanim
	sketch_init_track
	sketch_init_sort
	sketch_init_preview

	if { $p == "." } { 
		set root ".sketch" 
	} else { 
		set root "$p.sketch"
	}
	catch {destroy $root}

	toplevel $root
	place_near_mouse $root
	wm title $root "MGED AnimMate"
	button $root.b0 -text "Curve Editor" -command "sketch_popup_draw $root"
	button $root.b1 -text "View Editor" -command "sketch_popup_view $root"
	menubutton $root.b2 -text "Table Editor" -menu $root.b2.m0
	menu $root.b2.m0 -tearoff 0 -postcommand "sketch_post_table_menu $root.b2.m0"
	$root.b2.m0 add command -label "New Editor" -command "incr mged_sketch_table_index; sketch_popup_table $root \$mged_sketch_table_index"
	menubutton $root.b3 -text "Create Script" -menu $root.b3.m0
	menu $root.b3.m0 -tearoff 0
	$root.b3.m0 add command -label "Object" -command "sketch_popup_objanim $root obj"
	$root.b3.m0 add command -label "View" -command "sketch_popup_objanim $root view"
	$root.b3.m0 add command -label "Articulated Track" -command "sketch_popup_track_anim $root"
	button $root.b4 -text "Combine Scripts" -command "sketch_popup_sort $root"
	button $root.b5 -text "Show Script" -command "sketch_popup_preview $root"
	button $root.b6 -text "Quit" -command "sketch_quit $root"

	pack $root.b0 $root.b2 $root.b1 $root.b3 $root.b4 \
		$root.b5 $root.b6 \
		-side top -fill x -expand yes

}

proc sketch_post_table_menu {menu} {
	if { [$menu index end] > 0 } {
		$menu delete 1 end
	}
	foreach ted [sketch_table_list] {
		$menu add command -label "Editor [sketch_table_get_label $ted]" -command "raise $ted"
	}
}

#-----------------------------------------------------------------
# Curve Editor
#-----------------------------------------------------------------
#Comments: 
#A curve is a list of nodes. Each node contains a time parameter and 
#a 3-D point. The list of points is stored in a vlist using "vdraw".
#The list of time parameters is stored in a global variable 
#mged_sketch_time_*name*.
proc sketch_init_draw {} {
	#curve
	uplevel #0 set mged_sketch_init_draw 1
	uplevel #0 set mged_sketch_node 0		
	uplevel #0 set mged_sketch_count 0		
	uplevel #0 set mged_sketch_time 0.0	
	uplevel #0 set mged_sketch_tinc 1.0
	uplevel #0 set mged_sketch_tinit 0.0
	uplevel #0 {set mged_sketch_name ""}
	uplevel #0 {set mged_sketch_splname ""}
	uplevel #0 {set mged_sketch_splprefix "spl_"}
	uplevel #0 {set mged_sketch_color "255 255 0"}
	uplevel #0 set mged_sketch_defname "vdraw"
	#dependencies
	foreach dep {main} {
		if { [info globals mged_sketch_init_$dep] == "" } {
			sketch_init_$dep
		}
	}
}

proc sketch_popup_draw { p } {
	global mged_sketch_fps mged_sketch_color mged_sketch_time \
		 mged_sketch_name mged_sketch_count mged_sketch_node \
		mged_sketch_splname mged_sketch_splprefix mged_sketch_defname

	if { $p == "." } { 
		set root ".draw" 
	} else { 
		set root "$p.draw"
	}
   	if { [info commands $root] != ""} {
		raise $root
		return
	}
	toplevel $root
	place_near_mouse $root
	wm title $root "MGED AnimMate curve editor"
	button $root.b0 -text "Add" -command {sketch_add [view center] $mged_sketch_node}
	button $root.b1 -text "Insert" -command {sketch_insert [view center] $mged_sketch_node}
	button $root.b2 -text "Move" -command {sketch_move [view center] $mged_sketch_node}
	button $root.b3 -text "Delete" -command {sketch_delete $mged_sketch_node}
	frame  $root.f1
	label  $root.f1.l0 -text "Node "
	label  $root.f1.l1 -textvariable mged_sketch_node
	label  $root.f1.l2 -text " of "
	label  $root.f1.l3 -textvariable mged_sketch_count
	frame  $root.f0 
	button $root.f0.b4 -text "-->" -command {sketch_incr 10}
	button $root.f0.b40 -text "->" -command {sketch_incr 1}
	button $root.f0.b50 -text "<-" -command {sketch_incr -1}
	button $root.f0.b5 -text "<--" -command {sketch_incr -10}
	frame  $root.f4
	#label  $root.f4.l0 -text "Current Curve:"
	menubutton $root.f4.mb0 -text "Current Curve:" -menu $root.f4.mb0.m
	menu $root.f4.mb0.m -tearoff 0
	$root.f4.mb0.m add command -label "New Curve" -command {sketch_popup_name new}
	$root.f4.mb0.m add cascade -label "Open Curve" \
		-menu $root.f4.mb0.m.m0
	$root.f4.mb0.m add command -label "Rename Curve" -command {sketch_popup_name rename}
	$root.f4.mb0.m add command -label "Copy Curve" -command {sketch_popup_name copy}
	$root.f4.mb0.m add cascade -label "Delete Curve" \
		-menu $root.f4.mb0.m.m1

	menu $root.f4.mb0.m.m0 -tearoff 0 \
		-postcommand "sketch_post_curve_list $root.f4.mb0.m.m0 open"
	$root.f4.mb0.m.m0 add command -label "dummy"
	menu $root.f4.mb0.m.m1 -tearoff 0 \
		-postcommand "sketch_post_curve_list $root.f4.mb0.m.m1 delete"
	$root.f4.mb0.m.m1 add command -label "dummy"

	label  $root.f4.l1 -textvariable mged_sketch_name

	frame  $root.f5
	label  $root.f5.l0 -text "Time:"
	entry  $root.f5.e0 -width 8 -textvariable mged_sketch_time
	bind   $root.f5.e0 <Key-Return> " sketch_time_set \[$root.f5.e0 get\]"

	frame  $root.f2
	#label $root.f2.l0 -text "Color:"
	menubutton $root.f2.mb0 -text "Color:" -menu $root.f2.mb0.m
	menu $root.f2.mb0.m -tearoff 0
	$root.f2.mb0.m add cascade -label "Current Curve" \
		-menu $root.f2.mb0.m.m0
	$root.f2.mb0.m add cascade -label "Current Spline" \
		-menu $root.f2.mb0.m.m1
	$root.f2.mb0.m add cascade -label "Other" \
		-menu $root.f2.mb0.m.m2
	menu $root.f2.mb0.m.m0 -tearoff 0
	menu $root.f2.mb0.m.m1 -tearoff 0
	menu $root.f2.mb0.m.m2 -tearoff 0
	sketch_add_color_menu $root.f2.mb0.m.m0 current
	sketch_add_color_menu $root.f2.mb0.m.m1 spline
	sketch_add_color_menu $root.f2.mb0.m.m2 other
	entry $root.f2.e0 -width 12 -textvariable mged_sketch_color
	bind  $root.f2.e0 <Key-Return> "sketch_color \[$root.f2.e0 get\]"
	frame $root.f6 -relief groove -bd 3
	button $root.f6.b0 -text "Spline Interpolate" -command {sketch_do_spline spline}
	button $root.f6.b1 -text "Cspline Interpolate" -command {sketch_do_spline cspline}
	frame $root.f6.f0
	label $root.f6.f0.l0 -text "Into Curve:"
	entry $root.f6.f0.e0 -width 15 -textvariable mged_sketch_splname
	frame  $root.f6.f1
	label $root.f6.f1.l0 -text "Frames Per Second:"
	entry $root.f6.f1.e0 -width 4 -textvariable mged_sketch_fps
	bind  $root.f6.f1.e0 <Key-Return> "focus $root "
	frame $root.f8
	button $root.f8.b0 -text "Up" -command "raise $p"
	button $root.f8.b1 -text "Cancel" -command "destroy $root"

	menubutton $root.mb0 -text "Read/Write" -menu $root.mb0.m0
	menu $root.mb0.m0
	$root.mb0.m0 add command -label "Read Curve from File" -command {sketch_popup_load}
	$root.mb0.m0 add command -label "Write Curve to File" -command {sketch_popup_save curve}
	$root.mb0.m0 add command -label "Write Spline to File" -command {sketch_popup_save spline}
	
	pack \
		$root.f4 $root.f5 $root.f1 $root.f0 \
		$root.b0 $root.b1 $root.b2 $root.b3 \
		$root.f2 \
		$root.f6 \
		$root.mb0 \
		$root.f8	\
		-side top -fill x -expand yes
	pack \
		$root.f6.b0 $root.f6.b1 \
		$root.f6.f0 $root.f6.f1 \
		-side top -fill x -expand yes
	pack $root.f6.f0.l0 $root.f6.f0.e0 \
		$root.f6.f1.l0 $root.f6.f1.e0 \
		$root.f8.b0 $root.f8.b1 \
		-side left -expand yes
	pack $root.f0.b4 $root.f0.b40 $root.f0.b50 $root.f0.b5 \
		-side right -expand yes
	pack $root.f1.l0 $root.f1.l1 $root.f1.l2 $root.f1.l3 \
		$root.f2.mb0 $root.f2.e0 \
		$root.f4.mb0 $root.f4.l1 \
		$root.f5.l0 $root.f5.e0 \
		-side left -expand yes
	
	#initialize name
	if { [vdraw open] } {
		sketch_open_curve [vdraw read n]
	} else {
		sketch_open_curve $mged_sketch_defname
	} 
	set mged_sketch_splname "$mged_sketch_splprefix[vdraw read n]"
	sketch_update
}

proc sketch_post_curve_list { menu function } {
	switch $function {
		open {set command sketch_name}
		delete {set command sketch_delete_curve}
	}
	$menu delete 0 end
	foreach curve [vdraw vlist l] {
		if { $curve != "_sketch_hl_" } {
		  $menu add command -label $curve -command "$command $curve"
		}
	}
}

proc sketch_open_curve {name} {
	global mged_sketch_tinc
	set res [vdraw open $name]
	if {$res < 0} {
		tk_dialog ._sketch_msg {Couldn't open curve} \
			"Curve $name cannot be opened - it conflicts\
			 with existing geometry." {} 0 {OK}
	} else {
	       #create associated time variable if non-existent
		if { [vdraw read n] != "$name" } {
			#debugging - should never happen
			puts "Warning: wanted $name got [vdraw read n]"
		}
		set tname "mged_sketch_time_$name"
		uplevel #0 "append $tname {}"
		upvar #0 $tname time
		set len [vdraw read l]
		set lenn [expr $len - 1]
		set tlen [llength $time]
		if { $tlen > $len } {
			set time [lrange $time 0 $lenn]
		} elseif { $tlen < $len } {
			set last [lindex $time [expr $tlen - 1]]
			set time [lrange $time 0 [expr $tlen - 2]]
			set val 0.0
			for {set i 0} { $i <= [expr $len - $tlen]} {incr i} {
				lappend time [expr $last + $val]
				set val [expr $val + $mged_sketch_tinc]
			}
		}
	}
	#puts "Opening curve $name with result $res"
	return $res
}

#set the time stamp for current node
proc sketch_time_set { value } {
	upvar #0 mged_sketch_node node
	upvar #0 [format "mged_sketch_time_%s" [vdraw read n]] tlist
	if {$node != ""} {
	set tlist [lreplace $tlist $node $node $value]
	}
	focus .
}

#update graphical representation of current curve
proc sketch_update {} {
	global mged_sketch_count mged_sketch_time mged_sketch_node
	global mged_sketch_name mged_sketch_splname mged_sketch_color

	set mged_sketch_count [vdraw read l]

	sketch_clip

	upvar #0 [format "mged_sketch_time_%s" [vdraw read n]] tlist 

	if {$mged_sketch_node == ""} {
		set mged_sketch_time ""
	} else {
		set mged_sketch_time [lindex $tlist $mged_sketch_node]
	}

	set mged_sketch_color [sketch_hex_to_rgb [vdraw read c]]
	set mged_sketch_name  [vdraw read n]
	
	if { [vdraw send] < 0 } {
		tk_dialog ._sketch_msg {Can't display curve} \
		  "Can't create pseudo-solid _VDRW$mged_sketch_name because true solid \
		   with that name exists. Kill the true solid or choose a \
		    a different name for this curve." {} 0 {OK} 
		return -1
	}

	
	if { $mged_sketch_count > 0 } {
		sketch_highlight 
	} else {
		kill -f "_VDRW_sketch_hl_"
	}
	return 0

}


#keep current node in bounds
# 0 <= node < count, or "" if count == 0
proc sketch_clip {} {
	global mged_sketch_node mged_sketch_count

	if {$mged_sketch_count <= 0} {
		set mged_sketch_node ""
		return
	}
	#else
	if {$mged_sketch_node == ""} {
		set mged_sketch_node 0
	}
	if { $mged_sketch_node >= $mged_sketch_count } {
		set mged_sketch_node [expr $mged_sketch_count - 1]
	} 
	if { $mged_sketch_node < 0 } {
		set mged_sketch_node 0
	}
}

#show current node with 3-d cursor
proc sketch_highlight { } {
	global mged_sketch_node

	if {$mged_sketch_node == ""} return

	set offset [expr [view size] * 0.01]
	set oldname [vdraw read n]
	set vertex [eval [concat vdraw read $mged_sketch_node]]

	set v_x [lindex $vertex 1]
	set v_y [lindex $vertex 2]
	set v_z [lindex $vertex 3]
	vdraw send
	sketch_open_curve _sketch_hl_
	sketch_draw_highlight $v_x $v_y $v_z $offset
	sketch_open_curve $oldname
	
}

proc sketch_draw_highlight {v_x v_y v_z offset} {
	vdraw delete a
	vdraw write n 0 [expr $v_x - $offset] $v_y $v_z
	vdraw write n 1 [expr $v_x + $offset] $v_y $v_z
	vdraw write n 0 $v_x [expr $v_y - $offset] $v_z
	vdraw write n 1 $v_x [expr $v_y + $offset] $v_z
	vdraw write n 0 $v_x $v_y [expr $v_z - $offset]
	vdraw write n 1 $v_x $v_y [expr $v_z + $offset]
	vdraw params c 0x00ffff
	vdraw send
}

#increment current node by specified amount
proc sketch_incr { i } {
	global mged_sketch_node

	if { $mged_sketch_node != "" } {
		incr mged_sketch_node $i
	}
	sketch_update
}

#add node behind node n, where n can range from -1 to l-1
proc sketch_add { point n } {
	global mged_sketch_tinc mged_sketch_tinit mged_sketch_node

	set length [vdraw read l]
	set last [expr $length - 1]
	upvar #0 "mged_sketch_time_[vdraw read n]" tlist
	if { $length == 0 } {
		eval vdraw write 0 0 $point
		set tlist [list $mged_sketch_tinit]
		sketch_update
		return
	} 
	if { ($n == "") || ($n < -1) || ($n > $last) } {
		sketch_update
		return
	}
	set newn [expr $n + 1]
	if { $n == -1 } {
		eval vdraw insert $newn 0 $point
		set vertex [vdraw read 1]
		eval vdraw write 1 1 [lrange $vertex 1 3]
		set tn [expr [lindex $tlist 0] - $mged_sketch_tinc]
	} elseif { $n == $last} {
		eval vdraw insert $newn 1 $point
		set tn [expr [lindex $tlist $last] + $mged_sketch_tinc]
	} else {
		eval vdraw insert $newn 1 $point
		set tn [expr ([lindex $tlist $n]+[lindex $tlist $newn])*0.5]
	}
	set tlist [linsert $tlist $newn $tn]
	set mged_sketch_node $newn
	sketch_update
}	

#insert current view center before specified node
proc sketch_insert { point n } {
	if { $n != "" } {
		set n [expr $n - 1]
	}
	sketch_add $point $n
}

#move specified node to current view center
proc sketch_move { point n } {
	if { $n == "" } {
		sketch_update
		return
	}
	if { $n == 0 } {
		eval vdraw write $n 0 $point
	} else {
		eval vdraw write $n 1 $point
	}
	sketch_update
}

#delete specified node
proc sketch_delete { n } {

	if { $n == "" } {
		sketch_update
		return
	}
	vdraw delete $n
	if { ($n == 0) && ([vdraw read l] > 0) } {
		set vertex [vdraw read 0]
		eval [concat vdraw write 0 0 [lrange $vertex 1 3]]
	}
	upvar #0 [format "mged_sketch_time_%s" [vdraw read n]] tlist
	set tlist [lreplace $tlist $n $n]

	sketch_update
}

proc sketch_add_color_menu {m {type current}} {
	set colors {
		{red		{255 0 0}}
		{green		{0 255 0}}
		{blue		{0 0 255}}
		{yellow		{255 255 0}}
		{cyan		{0 255 255}}
		{magenta	{255 0 255}}
		{white		{255 255 255}}
		{gray		{150 150 150}}
		{black		{1 1 1}}
		{other		""}
	}
	foreach item $colors {
		$m add command -label [lindex $item 0] \
		   -command "sketch_popup_color $type \{[lindex $item 1]\}" \
		   -background [sketch_rgb_to_hex [lindex $item 1] pound] \
		   -foreground [sketch_rgb_to_hex [sketch_rgb_inv [lindex $item 1]] pound]
	}
}


proc sketch_popup_color {type color} {
	global mged_sketch_color mged_sketch_splname
	set flag 0
	if {($color == "other")||($color == "")} { 
		set color ""
		incr flag
	}
	if { $type == "current" } {
		set mged_sketch_color $color
		set name [vdraw read n]
	} elseif { $type == "spline" } {
		set name $mged_sketch_splname
	} else {
		#other
		set name ""
		incr flag
	}

	if { $flag == 0 } {
		set oldname [vdraw read n]
		vdraw open $name
		sketch_color $color
		vdraw open $oldname
		sketch_update
		return
	}
	#else
	set entries [list \
		[list "Name of curve:" $name] \
		[list "New color:" $color] \
		]
	set buttons [list \
		[list "OK" "set oldname \[vdraw read n\]; \
			vdraw open \[._sketch_input.f0.e get\]; \
			sketch_color \[._sketch_input.f1.e get \]; \
			vdraw open \$oldname; \
			sketch_update; \
			destroy ._sketch_input"] \
		{"Cancel" "destroy ._sketch_input"} \
		]
	sketch_popup_input "Color Curve" $entries $buttons
	return
}
		

#set current curve color
proc sketch_color { color } {
	global mged_sketch_color
	vdraw params c [sketch_rgb_to_hex $color]
	vdraw send
	set mged_sketch_color [sketch_hex_to_rgb [vdraw read c]]
	catch {focus .}
}


proc sketch_do_spline { mode } {
	global mged_sketch_fps mged_sketch_splname \
		mged_sketch_temp1 mged_sketch_temp2 \
		mged_sketch_tab_path

	#write vertices to temp2, result to temp1
	set fo [open $mged_sketch_temp2 w]
	set length [vdraw read l]
	if { $length < 2 } {
		puts {Need at least two vertices}
		close $fo
		return -1
	} elseif { $length == 2 } {
		set cmdstr "linear"
	} else {
		set cmdstr $mode
	}

	sketch_write_to_fd $fo $length
	close $fo

	upvar #0 [format "mged_sketch_time_%s" [vdraw read n]] tlist
	set start [lindex $tlist 0]
	set end [lindex $tlist [expr $length - 1]]
	set fo [open "| ${mged_sketch_tab_path}tabinterp -q > $mged_sketch_temp1" w]
	puts $fo "file $mged_sketch_temp2 0 1 2;"
	puts $fo [concat times $start $end $mged_sketch_fps {;}]
	puts $fo "interp $cmdstr 0 1 2;"
	# catch can be removed when tabinterp -q option is installed
	catch {close $fo}
	exec rm $mged_sketch_temp2

	#read results into curve
	set fi [open $mged_sketch_temp1 r]
	set oldname [vdraw read n]
	set oldcolor [sketch_hex_to_rgb [vdraw read c]]
	vdraw send
	sketch_open_curve $mged_sketch_splname
	vdraw delete a
	set num_read [sketch_read_from_fd $fi]
	close $fi
	#vdraw params c $oldcolor
	vdraw send
	sketch_open_curve $oldname
	exec rm $mged_sketch_temp1
	return $num_read
}



proc sketch_popup_load {} {
	set entries [list \
		{"File to Load"} \
		[list "Name of Curve" [vdraw read n]] \
		]
	set buttons [list \
		{"OK" {sketch_load [._sketch_input.f0.e get] \
				[._sketch_input.f1.e get]} } \
		{"Cancel" "destroy ._sketch_input"} \
		]
	sketch_popup_input "Load Curve" $entries $buttons
}

#load from file to specified curve
proc sketch_load { filename  curve } {
	global mged_sketch_splname mged_sketch_splprefix
	if { [sketch_open_curve $curve] < 0 } {
		echo "Couldn't open" $curve
		return	
	}
	set fd [open $filename r]
	vdraw delete a
	sketch_read_from_fd $fd
	close $fd
	catch {destroy ._sketch_input}
	sketch_update				
	set mged_sketch_splname "$mged_sketch_splprefix[vdraw read n]"
}


proc sketch_popup_save { type  } {
	global mged_sketch_splprefix

	set entries [list \
		[list "Name of Curve" [vdraw read n]] \
		{"Save to File:"} \
		]
	set buttons [list \
		{"OK" {sketch_save [._sketch_input.f0.e get] \
				[._sketch_input.f1.e get]} }\
		{"Cancel" "destroy ._sketch_input"} \
		]
	sketch_popup_input "Save Curve" $entries $buttons
	if {$type == "spline"} {
		._sketch_input.f0.e insert 0 $mged_sketch_splprefix
	}
}

#save specified curve to file
proc sketch_save { curve filename } {
	if {[file exists $filename] } {
		set ans [tk_dialog ._sketch_msg {File Exists} \
			{File already exists.} {} 1 {Overwrite} {Cancel} ]
		if { $ans == 1} {
			return
		}
	}

	set oldcurve [vdraw read n]
	set fd [open $filename w]
	sketch_open_curve $curve
	sketch_write_to_fd $fd [vdraw read l]
	close $fd
	sketch_open_curve $oldcurve
	catch {destroy ._sketch_input}
}



proc sketch_popup_name {{mode new}} {
	if { $mode == "new"} {
		sketch_popup_input "Select New Curve" {
			{"Name for new curve:" ""}
		} {
			{"OK" {sketch_name [._sketch_input.f0.e get]}}
			{"Cancel" "destroy ._sketch_input"}
		}
	} elseif { $mode == "rename" } {
		sketch_popup_input "Rename Curve" {
			{"New name for curve:" ""}
		} [list \
			[list "OK" "sketch_rename \[._sketch_input.f0.e get\]" ] \
			{"Cancel" "destroy ._sketch_input"} \
		]
	} elseif { $mode == "copy" } {
		sketch_popup_input "Copy Curve" {
			{"Name for copy:" ""}
		} [list \
			[list "OK" "sketch_copy \[._sketch_input.f0.e get\]" ] \
			{"Cancel" "destroy ._sketch_input"} \
		]
	}
}

proc sketch_name { name } {
	global mged_sketch_splname mged_sketch_splprefix
	if {[sketch_open_curve $name] < 0} {
		return
	}
	catch {destroy ._sketch_input}
	sketch_update
	set mged_sketch_splname "$mged_sketch_splprefix[vdraw read n]"
}

proc sketch_rename { name } {
	global mged_sketch_splname mged_sketch_splprefix
	set oldname [vdraw read n]
	if { [catch {vdraw params n $name }] == 1 } {
		#error occurred - name already exists
		set ans [tk_dialog ._sketch_msg {Curve exists} \
		  "A curve with name $name already exists." {} \
		  1 {Rename anyway} {Cancel} ]
		if { $ans == 1 } { 
			return -1
		} else {
			vdraw vlist d $name
			vdraw params n $name
		}
	}
	#for some reason, this update is needed to prevent dialog from
	#crashing
	update
	upvar #0 "mged_sketch_time_$oldname" oldtime
	uplevel #0 "append mged_sketch_time_$name {}"
	upvar #0 "mged_sketch_time_$name" newtime
	set newtime $oldtime
	#sketch_update will fail if name conflicts with true solid
	if { [sketch_update] == 0 } {
		catch {destroy ._sketch_input}
		kill -f "_VDRW$oldname"
		unset oldtime
		set mged_sketch_name [vdraw read n]
		if { "$mged_sketch_name" != "$name" } {
			puts "sketch_rename error. This should never happen."
		}
		set mged_sketch_splname "$mged_sketch_splprefix$mged_sketch_name"
	} else {
		#put things back
		unset newtime
		vdraw params name $oldname
		sketch_update
	}
}

proc sketch_copy { name } {
	set basename [vdraw read n]
	if { [vdraw open $name ] == 0 } {
		set ans [tk_dialog ._sketch_msg {Curve exists} \
		  "A curve with name $name already exists." {} \
		  1 {Copy anyway} {Cancel} ]
		if { $ans == 1 } {
			vdraw open $basename
			return -1
		} else {
			vdraw delete a
		}
	}
	vdraw open $basename
	set buffer ._sketch_scratch_
	text $buffer
	sketch_text_echoc $buffer
	sketch_open_curve $name
	sketch_text_apply $buffer replace
	destroy $buffer
	if {[sketch_update] == 0} {
		catch {destroy ._sketch_input}
	} else {
		sketch_open_curve $basename
		vdraw vlist d $name
		sketch_update
	}
}

proc sketch_popup_delete_curve {} {
	set entries [list \
		[list "Delete Curve:" [vdraw read n]] \
		]
	set buttons [list \
		{ "OK" {sketch_delete_curve [._sketch_input.f0.e get]; \
				destroy ._sketch_input} } \
		{ "Cancel" "destroy ._sketch_input" } \
		]
	sketch_popup_input "Delete Curve" $entries $buttons
}

proc sketch_delete_curve { name } {
	global mged_sketch_defname

	vdraw vlist d $name
	catch {vdraw vlist d _sketch_hl_}
	if { [vdraw open] } {
		sketch_open_curve [vdraw read n]
	} else {
		sketch_open_curve $mged_sketch_defname
	}
	uplevel #0 "set mged_sketch_time_$name {}"
	kill -f "_VDRW$name"
	sketch_update
}

#-----------------------------------------------------------------
# View Curve Editor
#-----------------------------------------------------------------
#Comments: 
# A view curve consists of a series of nodes. Each node contains all
# the information necessary to reproduce a view state. Different 
#combinations of parameters are possible - the implemented combinations
#can be found in the first switch statement of sketch_set_vparams{}. 
#Each view curve is realized as a read-only table widget whose parent is
#$mged_sketch_vwidget and whose name is $mged_sketch_vprefix*name*.
proc sketch_init_view {} {
	#view curve
	uplevel #0 set mged_sketch_init_view 1
	uplevel #0 set mged_sketch_vapply 0
	uplevel #0 set mged_sketch_vwidget ".view"
	uplevel #0 set mged_sketch_vprefix "_v_"
	uplevel #0 set mged_sketch_vnode 0		
	uplevel #0 set mged_sketch_vcount 0		
	uplevel #0 set mged_sketch_vtime 0.0	
	uplevel #0 set mged_sketch_vtinc 1.0	
	uplevel #0 {set mged_sketch_vname ""}
	uplevel #0 {set mged_sketch_vparams {size eye quat}}
	uplevel #0 {set mged_sketch_vchoices {
		{size eye quat}
		{size eye ypr}
		{size center quat}
		{size center ypr}
		{eye center}
		}}
	uplevel #0 set mged_sketch_cmdlen(quat) 4
	uplevel #0 set mged_sketch_cmdlen(eye) 3
	uplevel #0 set mged_sketch_cmdlen(center) 3
	uplevel #0 set mged_sketch_cmdlen(ypr) 3
	uplevel #0 set mged_sketch_cmdlen(aet) 3
	uplevel #0 set mged_sketch_cmdlen(size) 1
	#dependencies
	foreach dep {main table} {
		if { [info globals mged_sketch_init_$dep] == "" } {
			sketch_init_$dep
		}
	}
}

proc sketch_popup_view { p } {
	global mged_sketch_vtime \
		 mged_sketch_vname mged_sketch_vcount mged_sketch_vnode \
		mged_sketch_vparams mged_sketch_vwidget mged_sketch_vprefix \
		mged_sketch_vchoices

	if { $p == "." } { 
		set root ".view" 
	} else { 
		set root "$p.view"
	}
	set mged_sketch_vwidget "$root"
	#set mged_sketch_vprefix "_v_"
	set prefix $mged_sketch_vwidget.$mged_sketch_vprefix
	if { [info commands $root] != ""} {
		wm deiconify $root
		raise $root
		return
	}
	toplevel $root
	place_near_mouse $root
	wm title $root "MGED AnimMate view curve editor"
	button $root.b0 -text "Add" -command {sketch_vadd $mged_sketch_vnode}
	button $root.b1 -text "Insert" -command {sketch_vinsert $mged_sketch_vnode}
	button $root.b2 -text "Move" -command {sketch_vmove $mged_sketch_vnode}
	button $root.b3 -text "Delete" -command {sketch_vdelete $mged_sketch_vnode}
	frame  $root.f1
	label  $root.f1.l0 -text "Node "
	label  $root.f1.l1 -textvariable mged_sketch_vnode
	label  $root.f1.l2 -text " of "
	label  $root.f1.l3 -textvariable mged_sketch_vcount
	checkbutton $root.cb0 -text "Apply Current Node to View" \
		-variable mged_sketch_vapply -command "sketch_vupdate"
	$root.cb0 deselect
	frame  $root.f0 
	button $root.f0.b4 -text "-->" -command {sketch_vincr 10}
	button $root.f0.b40 -text "->" -command {sketch_vincr 1}
	button $root.f0.b50 -text "<-" -command {sketch_vincr -1}
	button $root.f0.b5 -text "<--" -command {sketch_vincr -10}
	frame  $root.f4
	#label  $root.f4.l0 -text "Current V-Curve:"
	menubutton $root.f4.mb0 -text "Current V-Curve:" -menu $root.f4.mb0.m
	menu $root.f4.mb0.m -tearoff 0
	$root.f4.mb0.m add command -label "New V-Curve" \
		-command {sketch_popup_vname select}
	$root.f4.mb0.m add cascade -label "Open V-Curve" \
		-menu $root.f4.mb0.m.m0
	$root.f4.mb0.m add command -label "Rename V-Curve" \
		-command {sketch_popup_vname rename}
	$root.f4.mb0.m add command -label "Copy V-Curve" \
		-command {sketch_popup_vname copy}
	$root.f4.mb0.m add cascade -label "Delete V-Curve" \
		-menu $root.f4.mb0.m.m1

	menu $root.f4.mb0.m.m0 -tearoff 0 \
		-postcommand "sketch_post_vcurve_list $root.f4.mb0.m.m0 open"
	$root.f4.mb0.m.m0 add command -label "dummy"
	menu $root.f4.mb0.m.m1 -tearoff 0 \
		-postcommand "sketch_post_vcurve_list $root.f4.mb0.m.m1 delete"
	$root.f4.mb0.m.m1 add command -label "dummy"

	button  $root.f4.l1 -textvariable mged_sketch_vname \
		-command "wm deiconify $prefix\$mged_sketch_vname; \
			raise $prefix\$mged_sketch_vname"
	frame $root.f3
	menubutton $root.f3.mb0 -text "Parameters:" -menu $root.f3.mb0.m
	menu $root.f3.mb0.m -tearoff 0
	foreach choice $mged_sketch_vchoices {
		$root.f3.mb0.m add command -label $choice \
			-command "sketch_set_vparams \{$choice\}"
	}
	label $root.f3.l0 -textvariable mged_sketch_vparams

	frame  $root.f5
	label  $root.f5.l0 -text "Time:"
	entry  $root.f5.e0 -width 8 -textvariable mged_sketch_vtime
	bind   $root.f5.e0 <Key-Return> "sketch_vtime_set \[$root.f5.e0 get\]"

	frame $root.f8
	button $root.f8.b0 -text "Up" -command "raise $p"
	button $root.f8.b1 -text "Cancel" -command "sketch_view_cancel"

	menubutton $root.mb0 -text "Read/Write" -menu $root.mb0.m0
	menu $root.mb0.m0
	$root.mb0.m0 add command -label "Read V-Curve from File" -command {sketch_popup_vload}
	$root.mb0.m0 add command -label "Write V-Curve to File" -command {sketch_popup_vsave curve}
	
	pack \
		$root.f4 $root.f3 $root.f5 $root.f1 $root.cb0 $root.f0 \
		$root.b0 $root.b1 $root.b2 $root.b3 \
		$root.mb0 \
		$root.f8	\
		-side top -fill x -expand yes
	pack \
		$root.f8.b0 $root.f8.b1 \
		-side left -expand yes
	pack $root.f0.b4 $root.f0.b40 $root.f0.b50 $root.f0.b5 \
		-side right -expand yes
	pack $root.f1.l0 $root.f1.l1 $root.f1.l2 $root.f1.l3 \
		$root.f4.mb0 $root.f4.l1 \
		$root.f3.mb0 $root.f3.l0 \
		$root.f5.l0 $root.f5.e0 \
		-side left -expand yes
	
	#initialize name
	sketch_open_vcurve $mged_sketch_vname
	sketch_vupdate
}

proc sketch_open_vcurve {name} {
	global mged_sketch_vname mged_sketch_vparams mged_sketch_vwidget \
		mged_sketch_vprefix mged_sketch_vapply

	set prefix $mged_sketch_vwidget.$mged_sketch_vprefix
	#get non-empty name
	if { $name == "" } {
		#pick from existing
		set any [sketch_vcurve_get_label \
			[lindex [sketch_vcurve_list] 0] ]
		if { $any == "" } {
			set name "view"
		} else {
			set name $any
		}
	}

	#create if doesn't exist
	if { [info commands $prefix$name.t] == "" } {
		sketch_popup_table_create $mged_sketch_vwidget \
			$mged_sketch_vprefix$name "View curve: $name" vcurve
		$prefix$name.t tag configure current -background white \
			-relief raised -borderwidth 2
	}
	set mged_sketch_vname $name	
	#create parameter list if need be
	set vpname "mged_sketch_vparams_$name"
	uplevel #0 "append $vpname {}"
	upvar #0 $vpname vpn
	sketch_set_vparams $vpn

	#wm deiconify $prefix$name
	#raise $prefix$name
	raise $mged_sketch_vwidget
	set mged_sketch_vapply 0
}

proc sketch_post_vcurve_list { menu function } {
	switch $function {
		open {set command sketch_vname}
		delete {set command sketch_delete_vcurve}
	}

	$menu delete 0 end
	foreach ved [sketch_vcurve_list] {
		set vcurve [sketch_vcurve_get_label $ved]
		$menu add command -label $vcurve -command "$command $vcurve"
	}
		
}



#set the viewparameters for the current view curve and convert if necessary
proc sketch_set_vparams { newlist } {
	global mged_sketch_vname mged_sketch_vparams \
		mged_sketch_temp1 mged_sketch_temp2 mged_sketch_anim_path\
		mged_sketch_vwidget mged_sketch_vprefix mged_sketch_vchoices

	#make it one of the allowable values
	set flag 0
	foreach choice $mged_sketch_vchoices {
		if { $newlist == $choice } {
			set flag 1
			break
		}
	}
	if { !$flag} {
			set newlist {size eye quat}
	}

	set mged_sketch_vparams $newlist
	uplevel #0 "append mged_sketch_vparams_$mged_sketch_vname {}"
	upvar #0 mged_sketch_vparams_$mged_sketch_vname oldlist
	if { $oldlist == $newlist } return
	set text $mged_sketch_vwidget.$mged_sketch_vprefix$mged_sketch_vname.t
	if { ([info commands $text] == "") || ([sketch_text_rows $text] < 1)} {
		set oldlist $newlist
		return
	}
	#otherwise, we must convert the text
	#convert to {size eye ypr}
	set buffer $text._params_scratch_
	if { [info commands $buffer] != "" } {
		destroy $buffer
	}
	text $buffer
	$text configure -state normal
	switch $oldlist {
		{size eye quat} {
			set fd [open "| ${mged_sketch_anim_path}anim_orient qv y \
					> $mged_sketch_temp1 " w]
			sketch_text_to_fd $text $fd "5,6,7,8"
			catch {close $fd}
			set fd [open $mged_sketch_temp1 r]
			sketch_text_col_arith $text all {@@0 @@1 @@2 @@3 @@4}
			sketch_text_from_fd $text $fd all right
			close $fd
			exec rm $mged_sketch_temp1
		}
		{eye center} {
			
			set fd [open "| ${mged_sketch_anim_path}anim_lookat -y -v \
					> $mged_sketch_temp1" w]
			sketch_text_to_fd $text $fd all
			close $fd
			set fd [open $mged_sketch_temp1 r]
			sketch_text_from_fd $text $fd all replace
			close $fd
			exec rm $mged_sketch_temp1
		}
		{size center ypr} {
			set fd [open "| ${mged_sketch_anim_path}anim_cascade -ry 0 0 0 > $mged_sketch_temp1" w]
			sketch_text_do_script $buffer $text all {@@0 @@2 @@3 @@4 @@5 @@6 @@7 {-@@1/2.0} 0.0 0.0}
			sketch_text_to_fd $buffer $fd all
			close $fd
			set fd [open $mged_sketch_temp1 r]
			sketch_text_from_fd $buffer $fd "1,2,3" right
			close $fd
			$text delete 1.0 end
			sketch_text_do_script $text $buffer all {@@0 {-2.0*@@7} @@10 @@11 @@12 @@4 @@5 @@6}
			exec rm $mged_sketch_temp1
		}
		{size center quat} {
			set fd [open "| ${mged_sketch_anim_path}anim_orient qv y > $mged_sketch_temp1" w]
			sketch_text_to_fd $text $fd "5,6,7,8"
			catch {close $fd}
			sketch_text_do_script $buffer $text all {@@0 @@2 @@3 @@4 {-@@1/2.0} 0.0 0.0}
			set fd [open "| ${mged_sketch_anim_path}chan_permute -i stdin 0 1 2 3 4 5 6 -i $mged_sketch_temp1 8 9 10 -o stdout 0 1 2 3 8 9 10 4 5 6 | ${mged_sketch_anim_path}anim_cascade -ry 0 0 0 > $mged_sketch_temp2" w]
			sketch_text_to_fd $buffer $fd all
			close $fd
			set fd [open $mged_sketch_temp2 r]
			$text delete 1.0 end
			sketch_text_do_script $text $buffer all {@@0 {-2.0*@@4} }
			sketch_text_from_fd $text $fd "1,2,3,4,5,6" right
			close $fd
			exec rm $mged_sketch_temp1 $mged_sketch_temp2
		}
		{size eye ypr} -
		default {}
	}

	$buffer delete 1.0 end

	#convert from {size eye ypr}
	switch $newlist {
		{size eye quat} {
			set fd [open "| ${mged_sketch_anim_path}anim_orient y qv \
					> $mged_sketch_temp1 " w]
			sketch_text_to_fd $text $fd "5,6,7"
			catch {close $fd}
			set fd [open $mged_sketch_temp1 r]
			sketch_text_col_arith $text all {@@0 @@1 @@2 @@3 @@4}
			sketch_text_from_fd $text $fd all right
			close $fd
			exec rm $mged_sketch_temp1
		}
		{eye center} {
			sketch_text_do_script $buffer $text all \
			   {@@0 @@2 @@3 @@4 @@5 @@6 @@7 {@@1*0.5} 0.0 0.0 0.0 0.0 0.0}
			set fd [open "| ${mged_sketch_anim_path}anim_cascade \
					> $mged_sketch_temp2" w]
			sketch_text_to_fd $buffer $fd all
			close $fd
			sketch_text_col_arith $text all {@@0 @@2 @@3 @@4}
			set fd [open $mged_sketch_temp2 r]
			sketch_text_from_fd $text $fd "1,2,3" right
			close $fd
			exec rm $mged_sketch_temp2
		}
		{size center ypr} {
			set fd [open "| ${mged_sketch_anim_path}anim_cascade -ry 0 0 0 > $mged_sketch_temp1" w]
			sketch_text_do_script $buffer $text all {@@0 @@2 @@3 @@4 @@5 @@6 @@7 {@@1/2.0} 0.0 0.0}
			sketch_text_to_fd $buffer $fd all
			close $fd
			set fd [open $mged_sketch_temp1 r]
			sketch_text_from_fd $buffer $fd "1,2,3" right
			close $fd
			$text delete 1.0 end
			sketch_text_do_script $text $buffer all {@@0 {2.0*@@7} @@10 @@11 @@12 @@4 @@5 @@6}
			exec rm $mged_sketch_temp1
		}
		{size center quat} {
			set fd [open "| ${mged_sketch_anim_path}anim_cascade -ry 0 0 0 > $mged_sketch_temp1" w]
			sketch_text_do_script $buffer $text all {@@0 @@2 @@3 @@4 @@5 @@6 @@7 {@@1/2.0} 0.0 0.0}
			sketch_text_to_fd $buffer $fd all
			close $fd
			set fd [open "| ${mged_sketch_anim_path}chan_permute -i $mged_sketch_temp1 0 1 2 3 4 5 6 -o stdout 4 5 6 | ${mged_sketch_anim_path}anim_orient y qv | ${mged_sketch_anim_path}chan_permute -i stdin 7 8 9 10 -i $mged_sketch_temp1 0 1 2 3 4 5 6 -o stdout 1 2 3 7 8 9 10" r]
			$text delete 1.0 end
			sketch_text_do_script $text $buffer all {@@0 {2.0*@@7}}
			sketch_text_from_fd $text $fd all right
			close $fd
			exec rm $mged_sketch_temp1
		}
		{size eye ypr} -
		default {}
	}

	$text configure -state disabled
	destroy $buffer
	set oldlist $newlist
	return
}



#append current view parameters to view curve
proc sketch_vadd { n } {
	global mged_sketch_vnode mged_sketch_vcount mged_sketch_vtinc
	global mged_sketch_vtime mged_sketch_vname mged_sketch_vparams mged_sketch_vwidget mged_sketch_vprefix

	set text $mged_sketch_vwidget.$mged_sketch_vprefix$mged_sketch_vname.t
	set length [sketch_text_rows $text]
	set last [expr $length - 1]
	if { $length == 0 } {
		set mged_sketch_vtime 0.0
		set mged_sketch_vnode 0
		set n $mged_sketch_vnode
		$text configure -state normal
		$text insert "1.0" [sketch_get_view_line $mged_sketch_vtime nl]
		$text configure -state disabled
		sketch_vupdate 
		return		
	} 
	if { ($n == "") || ($n < -1) || ($n > $last) } {
		sketch_vupdate
		return
	}
	set line [expr $n + 2]
	set preline [expr $n + 1]
	if { $n == -1 } {
		set time1 [lindex [$text get "$line.0" "$line.0 lineend"] 0] 
		set mged_sketch_vtime [expr $time1 - $mged_sketch_vtinc]
	} elseif { $n == $last } {
		set time0 [lindex [$text get "$preline.0" "$preline.0 lineend"] 0] 
		set mged_sketch_vtime [expr $time0 + $mged_sketch_vtinc]
	} else {
		set time0 [lindex [$text get "$preline.0" "$preline.0 lineend"] 0] 
		set time1 [lindex [$text get "$line.0" "$line.0 lineend"] 0] 
		set mged_sketch_vtime [expr ($time0 + $time1)*0.5]
	}
	$text configure -state normal
	$text insert "$line.0" [sketch_get_view_line $mged_sketch_vtime nl]
	$text configure -state disabled
	set mged_sketch_vnode $preline
	sketch_vupdate
}

proc sketch_vinsert { n } {
	if { $n != "" } {
		set n [expr $n - 1]
	}
	sketch_vadd $n
}

proc sketch_get_view_line { time {mode 0}} {
	global mged_sketch_vparams

	set line "\t$time"
	foreach cmd $mged_sketch_vparams {
		set new [join [view $cmd] "\t"]
		append line "\t$new"
	}
	if { $mode == "nl" } {
		return "$line\n"
	}
	return $line
}
	
#delete specified node
proc sketch_vdelete { n } {
	global mged_sketch_vname mged_sketch_vwidget mged_sketch_vprefix

	set text $mged_sketch_vwidget.$mged_sketch_vprefix$mged_sketch_vname.t
	if { $n == "" } {
		sketch_vupdate
		return
	}
	incr n 1
	$text configure -state normal
	$text delete "$n.0" "$n.0 lineend + 1 c"
	$text configure -state disabled

	sketch_vupdate
}

#move specified node to current view
proc sketch_vmove { n } {
	global mged_sketch_vtime mged_sketch_vname mged_sketch_vwidget mged_sketch_vprefix

	if { $n == "" } {
		sketch_vupdate
		return
	}
	incr n 1
	set text $mged_sketch_vwidget.$mged_sketch_vprefix$mged_sketch_vname.t
	set mged_sketch_vtime [lindex [$text get "$n.0" "$n.0 lineend"] 0]
	$text configure -state normal
	$text delete "$n.0" "$n.0 lineend"
	$text insert "$n.0" [sketch_get_view_line $mged_sketch_vtime] 			
	$text configure -state disabled

	sketch_vupdate
}

#insert current view center at specified node
proc sketch_vinsert2 { n } {
	global mged_sketch_vtinc global mged_sketch_vtime mged_sketch_vname \
		mged_sketch_vwidget mged_sketch_vprefix

	if { $n == "" } {
		sketch_vupdate
		return
	}
	incr n 1
	set text $mged_sketch_vwidget.$mged_sketch_vprefix$mged_sketch_vname.t
	set t2 [lindex [$text get "$n.0" "$n.0 lineend"] 0]
	if { $n == 1 } {
		set mged_sketch_vtime [expr $t2 - $mged_sketch_vtinc]
	} else {
		set i [expr $n - 1]
		set t1 [lindex [$text get "$i.0" "$i.0 lineend"] 0]
		set mged_sketch_vtime  [expr 0.5*($t1+$t2)]
	}
	$text configure -state normal
	$text insert "$n.0" [sketch_get_view_line $mged_sketch_vtime nl] 			
	$text configure -state disabled
	
	sketch_vupdate
}

#update description of view curve
proc sketch_vupdate {} {
	global mged_sketch_vcount mged_sketch_vtime mged_sketch_vnode
	global mged_sketch_vname mged_sketch_vparams mged_sketch_cmdlen \
		mged_sketch_vwidget mged_sketch_vprefix mged_sketch_vapply

	if { $mged_sketch_vname == "" } {
		puts "sketch_vupdate: no view curve"
		return
	}
	set text $mged_sketch_vwidget.$mged_sketch_vprefix$mged_sketch_vname.t
	set mged_sketch_vcount [sketch_text_rows $text]
	sketch_vclip

	if {$mged_sketch_vnode == ""} {
		set mged_sketch_vtime ""
		return
	}

	set node [expr $mged_sketch_vnode + 1]
	set line [$text get "$node.0" "$node.0 lineend"]

	set len [llength $line]
	if { $len < 1 } {
		puts "sketch_vupdate: Empty line"
		return
	}

	set mged_sketch_vtime [lindex $line 0]
	
	if { $mged_sketch_vapply } {
		set i 1
		set str ""
		foreach cmd $mged_sketch_vparams {
			set cargs [lrange $line $i \
			   [expr $i + $mged_sketch_cmdlen($cmd) - 1] ]
			set str [concat $str $cmd $cargs]
			incr i $mged_sketch_cmdlen($cmd)
		}
		if { $i != $len } {
			puts "sketch_vupdate: expected $i columns, got $len"
			return
		} 
		eval view $str
	}

	#highlight the current line
	$text tag remove current 1.0 end
	set line [expr $mged_sketch_vnode + 1]
	set nline [expr $mged_sketch_vnode + 2]
	$text tag add current "$line.0" "$nline.0"
}

#increment current node by specified amount
proc sketch_vincr { i } {
	global mged_sketch_vnode

	if { $mged_sketch_vnode != "" } {
		incr mged_sketch_vnode $i
	}
	sketch_vupdate
}

#keep current node in bounds
# 0 <= node < count, or "" if count == 0
proc sketch_vclip {} {
	global mged_sketch_vnode mged_sketch_vcount

	if {$mged_sketch_vcount <= 0} {
		set mged_sketch_vnode ""
		return
	}
	#else
	if {$mged_sketch_vnode == ""} {
		set mged_sketch_vnode 0
	}
	if { $mged_sketch_vnode >= $mged_sketch_vcount } {
		set mged_sketch_vnode [expr $mged_sketch_vcount - 1]
	} 
	if { $mged_sketch_vnode < 0 } {
		set mged_sketch_vnode 0
	}
}


#set the time stamp for current node
proc sketch_vtime_set { value } {
	global mged_sketch_vname mged_sketch_vwidget mged_sketch_vprefix

	upvar #0 mged_sketch_vnode node
	if {$node != ""} {
		set n [expr $node + 1]
		set text $mged_sketch_vwidget.$mged_sketch_vprefix$mged_sketch_vname.t
		set line [$text get "$n.0" "$n.0 lineend"]
		set lline [split $line "\t"]
		set lline [lreplace $lline 1 1 $value]
		set line [join $lline "\t"]
		$text configure -state normal
		$text delete "$n.0" "$n.0 lineend"
		$text insert "$n.0" $line
		$text configure -state disabled
	}
	focus .
}


proc sketch_popup_vsave { type  } {
	global mged_sketch_vname

	set entries [list \
		[list "Name of View curve" $mged_sketch_vname] \
		{"Save to File:"} \
		{"Which columns:" "all"} \
		]
	set buttons [list \
		{"OK" {sketch_vsave [._sketch_input.f0.e get] \
			[._sketch_input.f1.e get] \
			[._sketch_input.f2.e get] } }\
		{"Cancel" "destroy ._sketch_input"} \
		]
	sketch_popup_input "Save View curve" $entries $buttons
}

proc sketch_vsave { vcurve filename cols } {
	global mged_sketch_vwidget mged_sketch_vprefix

	set text $mged_sketch_vwidget.$mged_sketch_vprefix$vcurve.t
	if {[info commands $text] == ""} {
		tk_dialog ._sketch_msg {Can't find View Curve} \
		   "Can't find view curve $vcurve." {} 0 {OK}
		return
	}
	if {[file exists $filename] } {
		set ans [tk_dialog ._sketch_msg {File Exists} \
			{File already exists.} {} 1 {Overwrite} {Cancel} ]
		if { $ans == 1} {
			return
		}
	}
	set fd [open $filename w]
	sketch_text_to_fd $text $fd $cols
	close $fd
	catch {destroy ._sketch_input}
}


proc sketch_popup_vload {} {
	global mged_sketch_vname
	set entries [list \
		{"File to Load"} \
		[list "Name of View Curve" $mged_sketch_vname] \
		{"Load which columns:" "all"} \
		]
	set buttons [list \
		[list "OK" "sketch_vload \[._sketch_input.f0.e get\] \
			\[._sketch_input.f1.e get\] \
			\[._sketch_input.f2.e get\]" ] \
		{"Cancel" "destroy ._sketch_input"} \
		]
	sketch_popup_input "Load View Curve" $entries $buttons
}

proc sketch_vload { filename vcurve cols} {
	global mged_sketch_vname mged_sketch_vparams mged_sketch_vwidget mged_sketch_vprefix

	set oldname $mged_sketch_vname
	sketch_open_vcurve $vcurve
	#check for correct number of columns
	set fd [open $filename r]
	set numcol [sketch_line_cols [gets $fd]]
	close $fd
	if {$cols == "all"} {
		set num $numcol
	} else {
		set num [sketch_parse_col $col $numcol output]
	}
	if { [sketch_vcurve_check_col $mged_sketch_vparams $num] == -1} {
		sketch_open_vcurve $oldname
		return -1
	}
	set text $mged_sketch_vwidget.$mged_sketch_vprefix$vcurve.t
	set fd [open $filename r]
	$text configure -state normal
	sketch_text_from_fd $text $fd $cols replace
	$text configure -state disabled
	close $fd
	catch {destroy ._sketch_input}
	sketch_vupdate
}
	
	

proc sketch_popup_vname {{mode select}} {
	if { $mode == "select"} {
		sketch_popup_input "Select View Curve" {
			{"Name for new v-curve:" ""}
		} {
			{"OK" {sketch_vname [._sketch_input.f0.e get]}}
			{"Cancel" "destroy ._sketch_input"}
		}
	} elseif { $mode == "rename" } {
		sketch_popup_input "Rename View Curve" {
			{"New name for v-curve:" ""}
		} [list \
			[list "OK" "sketch_vrename \[._sketch_input.f0.e get\] \
				$mode" ] \
			{"Cancel" "destroy ._sketch_input"} \
		]
	} elseif { $mode == "copy" } {
		sketch_popup_input "Copy View Curve" {
			{"Name for copy:" ""}
		} [list \
			[list "OK" "sketch_vrename \[._sketch_input.f0.e get\] \
				$mode" ] \
			{"Cancel" "destroy ._sketch_input"} \
		]
	}
}

proc sketch_vname { name } {
	sketch_open_vcurve $name
	catch {destroy ._sketch_input}
	sketch_vupdate
}
 
proc sketch_vrename { name mode } {
	global mged_sketch_vname mged_sketch_vwidget mged_sketch_vprefix \
		mged_sketch_vparams

	set oldname $mged_sketch_vname
	set oldparams $mged_sketch_vparams
	if { $oldname == $name } {
		catch {destroy ._sketch_input}
		return
	}
	set ntext $mged_sketch_vwidget.$mged_sketch_vprefix$name.t
	set otext $mged_sketch_vwidget.$mged_sketch_vprefix$oldname.t
	
	if {[info commands $ntext] != ""} {
		set ans [tk_dialog ._sketch_msg {View Curve Exists} \
		   "View curve $name already exists." {} 1 {Overwrite} \
		   {Cancel}]
		if {$ans == 1} return
	}
	sketch_open_vcurve $name
	$ntext configure -state normal
	$ntext delete 1.0 end
	sketch_set_vparams $oldparams
	sketch_text_from_text $ntext $otext all replace
	$ntext configure -state disabled
	if { $mode == "rename"} {
		destroy $mged_sketch_vwidget.$mged_sketch_vprefix$oldname
	}
	#else copy
	sketch_vupdate
	catch {destroy ._sketch_input}
}
	
proc sketch_popup_delete_vcurve {} {
	global mged_sketch_vname
	set entries [list \
		[list "Delete View Curve:" $mged_sketch_vname] \
		]
	set buttons [list \
		{ "OK" {sketch_delete_vcurve [._sketch_input.f0.e get]; \
				destroy ._sketch_input} } \
		{ "Cancel" "destroy ._sketch_input" } \
		]
	sketch_popup_input "Delete View Curve" $entries $buttons
}

proc sketch_delete_vcurve { name } {
	global mged_sketch_vwidget mged_sketch_vprefix

	catch {destroy $mged_sketch_vwidget.$mged_sketch_vprefix$name}
	catch {unset mged_sketch_vparams_$name}
	sketch_open_vcurve ""
	sketch_vupdate
}


proc sketch_view_cancel {} {
	global mged_sketch_vwidget mged_sketch_vprefix

	wm withdraw $mged_sketch_vwidget
	set prefix $mged_sketch_vwidget.$mged_sketch_vprefix
	foreach ved [sketch_vcurve_list] {
		wm withdraw $ved
	}
}



#display message and return -1 if wrong number of columns
proc sketch_vcurve_check_col { vparams incol } {
	global mged_sketch_cmdlen
	set k 1
	set descr "time(1)"
	foreach cmd $vparams {
		set i $mged_sketch_cmdlen($cmd)
		append descr ", $cmd\($i\)"
		incr k $i
	}
	if { $incol != $k } {
		tk_dialog ._sketch_msg {Wrong number of columns} \
		   "You provided $incol columns of data. However, this view \
		   curve requires $k columns.  \
		   The columns should have the following format: $descr" \
		   {} 0 {OK}
		return -1
	}
	return 0
}
	
proc sketch_vcurve_list {} {
	global mged_sketch_vwidget mged_sketch_vprefix
	set prefix $mged_sketch_vwidget.$mged_sketch_vprefix
	set list ""
	foreach text [ info commands $prefix*.t] {
		set last [expr [string length $text] - 3]
	  	lappend list [string range $text 0 $last]
	}
	return $list
}

proc sketch_vcurve_get_label { vcurve} {
	global mged_sketch_vwidget mged_sketch_vprefix
	set prefix $mged_sketch_vwidget.$mged_sketch_vprefix
	set j [string length $prefix]
	return [string range $vcurve $j end]
}
	

	

#-----------------------------------------------------------------
# Table Editor
#-----------------------------------------------------------------
proc sketch_init_table {} {
	#table editor
	uplevel #0 set mged_sketch_init_table 1
	uplevel #0 set mged_sketch_table_lmode "replace"
	uplevel #0 set mged_sketch_table_index -1
	uplevel #0 set mged_sketch_table_prefix "_a_txt_"
	uplevel #0 set mged_sketch_table_interp "quat"
	uplevel #0 set mged_sketch_table_v0 "100%"
	uplevel #0 set mged_sketch_table_v1 "100%"
	uplevel #0 set mged_sketch_table_pcols "1,2,3"
	#dependencies
	foreach dep {main } {
		if { [info globals mged_sketch_init_$dep] == "" } {
			sketch_init_$dep
		}
	}
}

#table editor for curves
proc sketch_popup_table { p name args } {
	global mged_sketch_table_prefix

	if { $p == "." } { 
		set root ".$mged_sketch_table_prefix$name" 
	} else { 
		set root "$p.$mged_sketch_table_prefix$name"
	}

	if { [info commands $root ] != "" } {
		raise $root
		return
	}

	sketch_popup_table_create $p $mged_sketch_table_prefix$name \
		"Table editor $name" table

	#fill with appropriate text
	switch [lindex $args 0] {
		empty {$root.t delete 1.0 end}
		curve {
		  set oldname [vdraw read n]
		  sketch_open_curve [lindex $args 1]
		  $root.t delete 1.0 end
		  sketch_text_echoc $root.t
		  sketch_open_curve $oldname }
		clone {
		  sketch_text_copy [lindex $args 1] \
		     $root.t replace }
		default {
		  $root.t delete 1.0 end
		  sketch_text_echoc $root.t
		}
	}

	#finish colbar initialization
	#$root.colbar insert 1.0 "\ttime(0)\tx(1)\ty(2)\tz(3)"
	sketch_table_bar_set $root.t $root.colbar 0.0
}

#p 	- parent widget
#suffix - name for this widget
#label  - text for label
#mode	- table (read/write) or vcurve (read only)
proc sketch_popup_table_create { p suffix label {mode table}} {

	if { $p == "." } { 
		set name ".$suffix" 
	} else { 
		set name "$p.$suffix"
	}
	toplevel $name
	place_near_mouse $name
	wm title $name "MGED AnimMate $label"
	if { $mode == "vcurve" } {
		wm withdraw $name
	}
	text $name.t -width 80 -height 20 -wrap none \
		-tabs {20 numeric 220 numeric 420 numeric 620 numeric} \
		-xscrollcommand \
		"sketch_scroll_both $name" \
		-yscrollcommand "$name.s1 set"
	text $name.colbar -width 80 -height 1 -wrap none \
		-tabs {20 center 230 center 430 center 630 center}
	scrollbar $name.s0 -command \
		"$name.t xview" \
		-orient horizontal
	scrollbar $name.s1 -command "$name.t yview"
	frame $name.f1
	label $name.f1.l0 -text $label
	frame  $name.f0
	if { $mode == "table" } {
		button $name.f0.b3 -text "Clear" -command "$name.t delete 1.0 end"
		button $name.f0.b4 -text "Interpolate" -command "sketch_popup_table_interp $name.t $name.colbar"
		button $name.f0.b5 -text "Edit Columns" -command "sketch_popup_table_col $name.t $name.colbar"
		button $name.f0.b7 -text "Estimate Time" -command "sketch_popup_table_time $name.t"

		menubutton $name.f0.mb0 -text "Read" -menu $name.f0.mb0.m
		menu $name.f0.mb0.m -tearoff 0 -postcommand "sketch_post_read_menu $name.f0.mb0.m $name.t"
		$name.f0.mb0.m add command -label "dummy"
		button $name.f0.b6 -text "Cancel" -command "destroy $name"
	} else {
		button $name.f0.b6 -text "Hide" -command "wm withdraw $name"
	}
	button $name.f0.b8 -text "Clone" -command "incr mged_sketch_table_index; sketch_popup_table $p \$mged_sketch_table_index clone $name.t"
	button $name.f0.b9 -text "Up" -command "raise $p"
	menubutton $name.f0.mb1 -text "Write" -menu $name.f0.mb1.m
	menu $name.f0.mb1.m -tearoff 0 \
		-postcommand "sketch_post_write_menu $name.f0.mb1.m $name.t"
	$name.f0.mb1.m add command -label "dummy"
	pack $name.f0 $name.s0 -side bottom -fill x
	pack $name.s1 -side right -fill y	
	pack $name.f0.mb1 -side left -fill x -expand yes
	if { $mode == "table" } {
		pack $name.f0.mb0 \
			$name.f0.b3 $name.f0.b4 $name.f0.b5 $name.f0.b7 \
			-side left -fill x -expand yes
	}
	pack $name.f0.b8 $name.f0.b9 $name.f0.b6 \
		-side left -fill x -expand yes

	pack $name.f1 $name.colbar $name.t\
		-side top -expand yes -fill x -anchor w
	pack $name.f1.l0

	if { $mode == "vcurve" } {
		$name.t configure -state disabled
	}

}

proc sketch_popup_table_time { w } {
	global mged_sketch_table_v0 mged_sketch_table_v1 \
		mged_sketch_table_pcols

	set entries [list \
		[list "Start Speed:" $mged_sketch_table_v0] \
		[list "End Speed:" $mged_sketch_table_v1] \
		[list "Path Columns:" $mged_sketch_table_pcols] \
		]
	set buttons [list \
		[list  "OK" "sketch_table_time $w \
		    \[._sketch_input.f0.e get\] \[._sketch_input.f1.e get\] \
			\[._sketch_input.f2.e get\]"] \
		{"Cancel" "destroy ._sketch_input"} \
		]
	sketch_popup_input "Estimate Time" $entries $buttons
}

proc sketch_table_time {w v0 v1 cols } {
	global mged_sketch_temp1 mged_sketch_temp2 mged_sketch_anim_path \
		mged_sketch_table_v0 mged_sketch_table_v1 mged_sketch_table_pcols
	
	set mged_sketch_table_v0 $v0
	set mged_sketch_table_v1 $v1
	set mged_sketch_table_pcols $cols
	#global mged_sketch_table_lmode

	if { ($v0 == "100%") || ($v0 == "") } {
		set arg0 ""
	} else {
		set temp [split $v0 %]
		if { [llength $temp] > 1 } {
			set arg0 "-i [expr [lindex $temp 0]/100.0]"
		} else {
			set arg0 "-s $v0"
		}
	}
	if { ($v1 == "100%") || ($v1 == "") } {
		set arg1 ""
	} else {
		set temp [split $v1 %]
		if { [llength $temp] > 1 } {
			set arg1 "-f [expr [lindex $temp 0]/100.0]"
		} else {
			set arg1 "-e $v1"
		}
	}
	if { $cols == "" } {
		set $cols "1,2,3"
	}
	#count number of lines, doesn't matter if a couple extra
	scan [$w index end] %d maxlen
	set arg2 "-m $maxlen"
	set cmd "| ${mged_sketch_anim_path}anim_time $arg0 $arg1 $arg2 > $mged_sketch_temp1"
	#puts $cmd
	set f1 [open $cmd w] 
	set mycols "0,$cols"
	sketch_text_to_fd $w $f1 $mycols
	close $f1
	#set temp $mged_sketch_table_lmode
	#set mged_sketch_table_lmode left
	set f1 [open $mged_sketch_temp1 r]
	sketch_text_from_fd $w $f1 0 left
	close $f1
	sketch_text_from_text $w $w "0,2-" replace
	exec rm $mged_sketch_temp1
	#set mged_sketch_table_lmode $temp
	catch {destroy ._sketch_input}
}

proc sketch_scroll_both { w args} {
	eval $w.s0 set $args
	eval sketch_table_bar_set $w.t $w.colbar $args
}

#match number of columns in time bar with number of columns in text
#first line. Adjust time bar scroll
proc sketch_table_bar_set { w wbar args } {
	set i [sketch_text_cols $w]
	set j [sketch_text_cols $wbar]
	if { $i != $j } {
		$wbar delete 1.0 end
		set j 0
		while { $j < $i } {
			append addstr "\t$j"
			incr j
		}
		append addstr "         "
		$wbar insert "1.0 lineend" $addstr
	}
	$wbar xview moveto [lindex $args 0]
}


proc sketch_table_bar_reset { w } {
	if {[regsub {(^\..+)(\.[^\.]+$)} $w {\1} parent] == 0} {
		#no parent, do nothing
		return
	}
	if { [info commands $parent.colbar] == "" } {
		return
	}
	sketch_table_bar_set $w $parent.colbar [lindex [$w xview] 0]
}

proc sketch_post_write_menu { menu text } {
	$menu delete 0 end
	$menu add command -label "To File" \
		-command "sketch_popup_write $text file"
	if { [info globals mged_sketch_init_draw] != "" } {
		$menu add command -label "To Curve" \
			-command "sketch_popup_write $text curve"
	}
	if { [info globals mged_sketch_init_view] != "" } {
		$menu add command -label "To V-Curve" \
			-command "sketch_popup_write $text vcurve"
	}
}

proc sketch_table_list {} {
	global mged_sketch_table_prefix
	set list ""
	foreach text [info commands *.$mged_sketch_table_prefix*.t] {
		set last [expr [string length $text] - 3]
		lappend list [string range $text 0 $last]
	}
	return $list
}

proc sketch_table_get_label { ted } {
	global mged_sketch_table_prefix
	if { [regsub "(.+\\.$mged_sketch_table_prefix)(.+\$)" $ted {\2} label] } {
		return $label
	} else {
		return ""
	}
}

proc sketch_post_read_menu { menu text } {
	$menu delete 0 end
	$menu add command -label "From File" \
		-command "sketch_popup_read $text file file"
	if { [info globals mged_sketch_init_table] != "" } {
		foreach ted [sketch_table_list] {
			$menu add command \
			 -label "From Editor [sketch_table_get_label $ted]" \
			 -command "sketch_popup_read $text text $ted.t"
		}
	}
	if { [info globals mged_sketch_init_draw] != "" } {
		foreach curve [vdraw vlist l] {
			if { [info globals "mged_sketch_time_$curve"] != ""} {
			  $menu add command -label "From Curve $curve" \
			    -command "sketch_popup_read $text curve $curve"
			}
		}
	}
	if { [info globals mged_sketch_init_view] != "" } {
		foreach ved [sketch_vcurve_list] {
			$menu add command -label \
			 "From V-Curve [sketch_vcurve_get_label $ved]" \
			 -command "sketch_popup_read $text text $ved.t"
		}
	}
}

proc sketch_popup_table_col {w wbar} {
	#make sure bar is up to date
	sketch_table_bar_reset $w
	#sketch_table_bar_set $w $wbar [lindex [$w xview] 0]

	catch { destroy ._sketch_col }
	toplevel ._sketch_col
	place_near_mouse ._sketch_col
	wm title ._sketch_col "Edit Columns"
	frame ._sketch_col.fa
	frame ._sketch_col.fb
	pack ._sketch_col.fb ._sketch_col.fa -side bottom -anchor e
	set collist [lrange [split [$wbar get 1.0 "1.0 lineend"] "\t"] \
			1 end]
	set i 0
	set cmd "sketch_text_do_col $w \[._sketch_col.fb.e0 get\]"
	foreach col $collist {
		set cmd [sketch_table_col_add $i $col $cmd old]
		incr i
	}
	#append cmd "; sketch_table_bar_reset $w; destroy ._sketch_col"
	
	if {$i > 0} {
		bind  ._sketch_col.fr[expr $i-1].e0 <Key-Return> \
			{._sketch_col.fa.b0 invoke}
	}
	button ._sketch_col.fa.b2 -text "Add Column" -command {sketch_table_col_add_one} 
	button ._sketch_col.fa.b0 -text "OK" -command $cmd
	button ._sketch_col.fa.b1 -text "Cancel" -command {destroy ._sketch_col}
	label ._sketch_col.fb.l0 -text "Number of Rows:" 
	entry ._sketch_col.fb.e0 -width 5
	._sketch_col.fb.e0 insert end "all"
	bind ._sketch_col.fb.e0 <Key-Return> {._sketch_col.fa.b0 invoke}
	pack ._sketch_col.fa.b2 ._sketch_col.fa.b0 ._sketch_col.fa.b1 -side left
	pack ._sketch_col.fb.l0 ._sketch_col.fb.e0 -side left -fill x

	if { $i > 0 } {
		focus ._sketch_col.fr0.e0
	}
}

proc sketch_table_col_add_one {} {
	set num [llength [info commands ._sketch_col.fr*.e0]]
	set cmd [lindex [split [._sketch_col.fa.b0 cget -command] \;] 0]
	set cmd [sketch_table_col_add $num $num $cmd new]
	bind  ._sketch_col.fr$num.e0 <Key-Return> {._sketch_col.fa.b0 invoke}
	._sketch_col.fa.b0 configure -command $cmd
}

proc sketch_table_col_add { i col cmd flag } {
		frame ._sketch_col.fr$i
		set col [string trim $col]
		label ._sketch_col.fr$i.l0 -text "$col:"
		entry ._sketch_col.fr$i.e0 -width 20
		if { $flag == "old" } {
			._sketch_col.fr$i.e0 insert end @@$i
		}
		append cmd " \[._sketch_col.fr$i.e0 get\]"
		if {$i > 0} {
			set j [expr $i-1]
			bind ._sketch_col.fr$j.e0 <Key-Return> \
			  "focus ._sketch_col.fr$i.e0"
		}
		pack ._sketch_col.fr$i -side top -fill x -expand yes
		pack ._sketch_col.fr$i.l0 ._sketch_col.fr$i.e0 -side left -fill x -expand yes
		return $cmd
}

proc sketch_text_do_col {w rows args} {
	sketch_text_col_arith $w $rows $args
	sketch_table_bar_reset $w
	destroy ._sketch_col
}


proc sketch_text_col_arith {w rows arglist} {
	set buffer $w._col_scratch_
	#destroy if exists already
	if {[info commands $buffer] != ""} {
		destroy $buffer
	}
	text $buffer
	sketch_text_do_script $buffer $w $rows $arglist
	$w delete 1.0 end
	$w insert end [$buffer get 1.0 end]
	destroy $buffer
}

#win - take text from
#wout - write text to
#rows - number of rows to write (copies source length if rows not pos. int.)
#args - series of column arithmetic descriptions
# @@1 refers to column 1, @@pi refers to pi, @@i refers to row index
# @@n refers to number of rows, @@e refers to e
proc sketch_text_do_script {wout win rows slist} {
	#parse scripts
	set colout 0

	foreach script $slist {
		if {$script != ""} {
			regsub -all {@@pi} $script 3.14159265358979323846 temp2
			regsub -all {@@e} $temp2 2.7182818284590452354 temp
			regsub -all {(@@)([in])} $temp {$column(\2)} \
				script
			regsub -all {(@@)([0-9]+)}  $script {$column(\2)} \
				outscript($colout)
			incr colout
		}
	}
	if { [regexp {^[0-9]+$} $rows] == "0" } {
		set column(n) [sketch_text_rows $win]
	} else {
		set column(n) $rows
	}
	for {set i 1} { $i <= $column(n) } {incr i} {
		set cols [lrange \
			[split [$win get "$i.0" "$i.0 lineend"] "\t"] \
			1 end]
		set collen [llength $cols]
		set column(i) [expr $i - 1.0]
		for {set j 0} {$j < $collen} {incr j} {
			set column($j) "[lindex $cols $j]"
		}
		for {set j 0} {$j < $colout} {incr j} {
			$wout insert end \
	 		  [format "\t%.12g" [expr $outscript($j)]]
		}
		$wout insert end "\n"
	}
}

proc sketch_popup_table_interp {w wbar}	{
	global mged_sketch_table_interp
	#make sure bar is up to date
	sketch_table_bar_reset $w

	catch { destroy ._sketch_col }
	toplevel ._sketch_col
	place_near_mouse ._sketch_col
	wm title ._sketch_col "Column Interpolator"
	frame ._sketch_col.fz
	label ._sketch_col.fz.l0 -text "0:" 
	label ._sketch_col.fz.l1 -text "Time" -width 20
	pack ._sketch_col.fz -side top -fill x -expand yes
	pack ._sketch_col.fz.l0 ._sketch_col.fz.l1 -side left -fill x -expand yes
	frame ._sketch_col.fa
	frame ._sketch_col.fb
	frame ._sketch_col.fc
	frame ._sketch_col.fd

	frame ._sketch_col.fe
	menubutton ._sketch_col.fe.mb0 -text "Active Command:" \
		-menu ._sketch_col.fe.mb0.m0
	menu ._sketch_col.fe.mb0.m0
	label ._sketch_col.fe.l0 -textvariable mged_sketch_table_interp

	pack ._sketch_col.fe ._sketch_col.fa -side bottom -fill x -expand yes
	pack ._sketch_col.fd ._sketch_col.fc \
		._sketch_col.fb -side bottom -anchor e

	set collist [lrange [split [$wbar get 1.0 "1.0 lineend"] "\t"] \
			2 end]
	set i 1
	set cmd "sketch_text_do_interp $w \[._sketch_col.fb.e0 get\] \
		\[._sketch_col.fc.e0 get\] \[._sketch_col.fd.e0 get\]"
	foreach col $collist {
		set cmd [sketch_table_interp_add $i $col $cmd old]
		incr i
	}
	#append cmd "; sketch_table_bar_reset $w; destroy ._sketch_col"
	
	if {$i > 1} {
		bind  ._sketch_col.fr[expr $i-1].e0 <Key-Return> \
			{focus ._sketch_col.fb.e0}
	}
	button ._sketch_col.fa.b2 -text "Add Column" -command {sketch_table_interp_add_one} 
	button ._sketch_col.fa.b0 -text "OK" -command $cmd
	button ._sketch_col.fa.b1 -text "Cancel" -command {destroy ._sketch_col}
	label ._sketch_col.fb.l0 -text "Start Time:" 
	entry ._sketch_col.fb.e0 -width 10
	bind ._sketch_col.fb.e0 <Key-Return> {focus ._sketch_col.fc.e0}
	label ._sketch_col.fc.l0 -text "End Time:" 
	entry ._sketch_col.fc.e0 -width 10
	bind ._sketch_col.fc.e0 <Key-Return> {focus ._sketch_col.fd.e0}
	label ._sketch_col.fd.l0 -text "Frames Per Second:" 
	entry ._sketch_col.fd.e0 -width 10 -textvariable mged_sketch_fps
	bind ._sketch_col.fd.e0 <Key-Return> {._sketch_col.fa.b0 invoke}
	pack ._sketch_col.fa.b2 ._sketch_col.fa.b0 ._sketch_col.fa.b1 \
		._sketch_col.fe.mb0 ._sketch_col.fe.l0 \
		-side left -expand yes -fill x
	pack ._sketch_col.fb.l0 ._sketch_col.fb.e0 \
		._sketch_col.fc.l0 ._sketch_col.fc.e0 \
		._sketch_col.fd.l0 ._sketch_col.fd.e0 \
		-side left -fill x

	._sketch_col.fe.mb0.m0 add command -label "Step (src)" -command {set mged_sketch_table_interp step }
	._sketch_col.fe.mb0.m0 add command -label "Linear (src)" -command {set mged_sketch_table_interp linear }
	._sketch_col.fe.mb0.m0 add command -label "Spline (src)" -command {set mged_sketch_table_interp spline }
	._sketch_col.fe.mb0.m0 add command -label "Periodic Spline (src)" -command {set mged_sketch_table_interp cspline }
	._sketch_col.fe.mb0.m0 add command -label "Quaternion (src)" -command {set mged_sketch_table_interp quat }
	._sketch_col.fe.mb0.m0 add command -label "Rate (init) (incr/s)" -command {set mged_sketch_table_interp rate }
	._sketch_col.fe.mb0.m0 add command -label "Accel (init) (incr/s)" -command {set mged_sketch_table_interp accel}
	._sketch_col.fe.mb0.m0 add command -label "Next (src) (offset)" -command {set mged_sketch_table_interp next}
	._sketch_col.fe.mb0.m0 add command -label "Delete Column" -command {set mged_sketch_table_interp delete}

	if { $i > 1 } {
		focus ._sketch_col.fr1.e0
	}

	#guess start and end times
	set n [sketch_text_rows $w]
	if { $n < 2} {return}
	._sketch_col.fb.e0 insert end \
		[lindex [split [$w get 1.0 "1.0 lineend"] \t] 1]
	._sketch_col.fc.e0 insert end \
		[lindex [split [$w get $n.0 "$n.0 lineend"] \t] 1]
	
}

proc sketch_text_interpolate { w start stop fps slist } {
	global mged_sketch_temp1 mged_sketch_temp2 mged_sketch_tab_path
	#global mged_sketch_table_lmode
	#check all instructions in args
	set i 0
	set indlist 0
	set quatcount 0
	foreach script $slist {
		set type [lindex $script 0]
		switch $type {
			step - 
			spline -
			linear -
			cspline {
				lappend filelist $i
				lappend indlist [lindex $script 1]
				set cmd($i) "interp $type $i;"
				incr i
			}
			quat {
				lappend filelist $i
				lappend indlist [lindex $script 1]
				if {$quatcount == 0} {
					set cmd($i) "interp quat $i;"
					set quatend [expr $i + 4]
					set quatcount 3
				} else {
					if { $i != [expr $quatend - $quatcount] } {
						tk_dialog ._sketch_msg {Invalid entry} \
							{The interpolator requires four adjacent "quat" columns.} {} \
							 0 {OK}
						return -1
					}
					set cmd($i) ""
					incr quatcount -1
				}
				incr i
			}
			rate -
			accel {
				set cmd($i) "$type $i [lindex $script 1] \
					[lindex $script 2];"
				incr i
			}
			next {
				set cmd($i) "$type $i \
					[expr [lindex $script 1] - 1] \
					[lindex $script 2];"
				incr i
			}
			default { puts "unknown command" }
		}
	}
	if { $quatcount != 0} {
		tk_dialog ._sketch_msg {Invalid entry} \
			{The interpolator requires four adjacent "quat" columns.} {} \
			 0 {OK}
		return -1
	}
	set fd [open $mged_sketch_temp1 w]
	sketch_text_to_fd $w $fd [join $indlist ,]
	close $fd

	set fd [open $mged_sketch_temp2 w]
	if { [info exists filelist] == 1} {
		puts $fd "file $mged_sketch_temp1 $filelist;"
	}
	puts $fd "times $start $stop $fps;"
	for {set j 0} { $j < $i } {incr j} {
		puts $fd $cmd($j)
	}
	close $fd

	set fd [open "| ${mged_sketch_tab_path}tabinterp -q < $mged_sketch_temp2 " r]
	sketch_text_from_fd $w $fd all replace
	#catch can be removed when -q option added to tabinterp
	catch {close $fd}
	catch {exec rm $mged_sketch_temp1 $mged_sketch_temp2}
	return 0	
}
	
proc sketch_interp_fill { str args} {
	if { $args == "" } {
		foreach ent [info commands {._sketch_col.fr[0-9]*.e0}] {
			$ent delete 0 end
			$ent insert end $str
		}
	} else {
		set ent [info commands ._sketch_col.fr1.e0]
		for {set i 1} { $ent != ""} { 
			set ent [info commands ._sketch_col.fr$i.e0]} {
			$ent delete 0 end
			$ent insert end "$str $i"
			incr i
		}
	}
}
			

proc sketch_table_interp_add { i col cmd flag } {
		frame ._sketch_col.fr$i
		set col [string trim $col]
		button ._sketch_col.fr$i.l0 -text "$col:" \
			-command "sketch_table_interp_entry ._sketch_col.fr$i.e0 $i"
		entry ._sketch_col.fr$i.e0 -width 20
		if { $flag == "old" } {
			._sketch_col.fr$i.e0 insert end "spline $i"
		}
		append cmd " \[._sketch_col.fr$i.e0 get\]"
		if {$i > 1} {
			set j [expr $i-1]
			bind ._sketch_col.fr$j.e0 <Key-Return> \
			  "focus ._sketch_col.fr$i.e0"
		}
		pack ._sketch_col.fr$i -side top -fill x -expand yes
		pack ._sketch_col.fr$i.l0 ._sketch_col.fr$i.e0 -side left -fill x -expand yes
		return $cmd
}

proc sketch_table_interp_entry { entry index } {
	upvar #0 mged_sketch_table_interp type

	switch $type {
		step -
		linear -
		spline - 
		cspline -
		quat {
			$entry delete 0 end
			$entry insert 0 "$type $index"
		}
		rate -
		accel -
		next {
			$entry delete 0 end
			$entry insert 0 $type
		}
		delete {
			$entry delete 0 end
		}
	}
}


proc sketch_table_interp_add_one {} {
	set num [llength [info commands ._sketch_col.fr*.e0]]
	incr num
	set cmd [._sketch_col.fa.b0 cget -command]
	#set cmd [lindex [split [._sketch_col.fa.b0 cget -command] \;] 0]
	set cmd [sketch_table_interp_add $num $num $cmd new]
	bind  ._sketch_col.fr$num.e0 <Key-Return> {focus ._sketch_col.fb.e0}
	._sketch_col.fa.b0 configure -command $cmd
}

proc sketch_text_do_interp { w start stop fps args } {
	if {[sketch_text_interpolate $w $start $stop $fps $args] != 0} {
		return
	}
	sketch_table_bar_reset $w
	destroy ._sketch_col
}

proc sketch_popup_read {w type src} {
	global mged_sketch_table_lmode
	switch $type {
		file {
			set entries [list [list "File to read:" ""]]
			set okcmd "sketch_text_readf $w \
				\[._sketch_input.f0.e get\] \
				\[._sketch_input.f1.e get\] \
				\$mged_sketch_table_lmode"
		}
		curve {
			set entries {}
			set okcmd "sketch_text_readc $w $src \
				\[._sketch_input.f0.e get\] \
				\$mged_sketch_table_lmode"
		}
		default {
			set entries {}
			set okcmd "sketch_text_from_text $w $src \
				\[._sketch_input.f0.e get\] \
				\$mged_sketch_table_lmode; \
				destroy ._sketch_input"
		}
	}
	lappend entries {"Which columns:" "all"}
	set buttons [list \
		[list "OK" $okcmd] \
		[list "Cancel" "destroy ._sketch_input"] \
		]
	sketch_popup_input "Read from $src" $entries $buttons
	frame ._sketch_input.f3
	pack ._sketch_input.f3 -side bottom
	radiobutton ._sketch_input.f3.r0 -text "Replace" \
		-variable mged_sketch_table_lmode -value "replace"
	radiobutton ._sketch_input.f3.r1 -text "Append" \
		-variable mged_sketch_table_lmode -value "end"
	radiobutton ._sketch_input.f3.r2 -text "Add New Columns" \
		-variable mged_sketch_table_lmode -value "right"

	pack ._sketch_input.f3.r0 ._sketch_input.f3.r1 ._sketch_input.f3.r2 \
		-side left -fill x

}

proc sketch_text_readc {w curve col mode} {
	set oldcurve [vdraw read n]
	sketch_open_curve $curve
	set buffer $w._readc_scratch_
	text $buffer
	sketch_text_echoc $buffer
	sketch_text_from_text $w $buffer $col $mode
	destroy $buffer
	sketch_open_curve $oldcurve
	sketch_table_bar_reset $w
	catch {destroy ._sketch_input}

}

proc sketch_popup_write {w dst} {
	global mged_sketch_vname
	switch $dst {
		file {
			set entries [list [list "Write to file:" ""]]
			set okcmd "sketch_text_writef $w \
				\[._sketch_input.f0.e get\] \
				\[._sketch_input.f1.e get\]"
		}
		curve {
			set entries [list [list "Write to curve:" [vdraw read n]]]
			set okcmd "sketch_text_writec $w \
				\[._sketch_input.f0.e get\] \
				\[._sketch_input.f1.e get\]"
		}
		vcurve {
			set entries [list [list "Write to v-curve:" $mged_sketch_vname]]
			set okcmd "sketch_text_writevc $w \
				\[._sketch_input.f0.e get\] \
				\[._sketch_input.f1.e get\]"
		}

	}
	lappend entries {"Which columns:" "all"}
	set buttons [list \
		[list "OK" $okcmd] \
		[list "Cancel" "destroy ._sketch_input"] \
		]
	sketch_popup_input "Write to $dst" $entries $buttons
}

proc sketch_text_writec {w curve col} {
	set buffer $w._writec_scratch_
	text $buffer
	sketch_text_from_text $buffer $w $col append
	set i [sketch_text_cols $buffer]
	if { $i < 3 } {
		destroy $buffer
		puts "Need at least three columns"
		return -1
	}
	if { $i == 3 } {
		#assume time is missing
		sketch_text_col_arith $buffer all {@@i @@0 @@1 @@2}
		puts "Filling in missing time column"
	}
	set oldcurve [vdraw read n]
	sketch_open_curve $curve
	sketch_text_apply $buffer replace
	sketch_open_curve $oldcurve
	destroy $buffer
	catch {destroy ._sketch_input}
	sketch_update

}

proc sketch_text_writevc {w vcurve col} {
	global mged_sketch_vparams mged_sketch_vname mged_sketch_vwidget mged_sketch_vprefix

	set oldname $mged_sketch_vname
	sketch_open_vcurve $vcurve
	#check for correct number of columns	
	set numcol [sketch_text_cols $w]
	if { $col == "all" } {
		set num $numcol
	} else {
		set num [sketch_parse_col $col $numcol output]
	}
	if { [sketch_vcurve_check_col $mged_sketch_vparams $num] == -1} {
		sketch_open_vcurve $oldname
		return -1
	}

	set text $mged_sketch_vwidget.$mged_sketch_vprefix$vcurve.t
	$text configure -state normal
	sketch_text_from_text $text $w $col replace
	$text configure -state disabled
	sketch_vupdate
	catch {destroy ._sketch_input}
}



#-----------------------------------------------------------------
# Create Scripts
#-----------------------------------------------------------------
proc sketch_init_objanim {} {
	# object animation
	uplevel #0 set mged_sketch_init_objanim 1
	uplevel #0 set mged_sketch_objorv "object"
	uplevel #0 set mged_sketch_objname "/foo.r"
	uplevel #0 set mged_sketch_objvsize "500"
	uplevel #0 {set mged_sketch_objcen "0 0 0"}
	uplevel #0 {set mged_sketch_objori "0 0 0"}
	uplevel #0 {set mged_sketch_eyecen "0 0 0"}
	uplevel #0 {set mged_sketch_eyeori "0 0 0"}
	uplevel #0 {set mged_sketch_objsteer ""}
	uplevel #0 set mged_sketch_objopt "none"
	uplevel #0 set mged_sketch_objmang "60"
	uplevel #0 {set mged_sketch_objlaf ""}
	uplevel #0 {set mged_sketch_objdisp ""}
	uplevel #0 {set mged_sketch_objrot ""}
	uplevel #0 set mged_sketch_objframe "0"
	uplevel #0 set mged_sketch_objscript "foo.script"
	uplevel #0 set mged_sketch_objsrctype "curve:"
	uplevel #0 set mged_sketch_objsource "foo"
	uplevel #0 set mged_sketch_objcname "foo"
	uplevel #0 set mged_sketch_objfname "foo.table"
	uplevel #0 set mged_sketch_objrv 0
	uplevel #0 set mged_sketch_objrotonly 0
	uplevel #0 set mged_sketch_objncols 4
	uplevel #0 {set mged_sketch_objcols "t x y z"}
	#dependencies
	foreach dep {main} {
		if { [info globals mged_sketch_init_$dep] == "" } {
			sketch_init_$dep
		}
	}
}

#control creation of animation scripts
#mode can be obj or view
proc sketch_popup_objanim { p {mode obj} } {
	if { $p == "." } { 
		set root ".oanim" 
	} else { 
		set root "$p.oanim"
	}
	if { [info commands $root ] != ""} {
		if { [info commands $root.l$mode] != ""} {
			raise $root
			return
		} else {
			destroy $root
		}
	} 

	#create widget
	toplevel $root
	frame $root.f0
	label $root.f0.l0 -text "Output File: "
	entry $root.f0.e0 -width 20 -textvariable mged_sketch_objscript
	frame $root.f1
	label $root.f1.l0 -text Source
	tk_optionMenu $root.f1.om0 mged_sketch_objsrctype \
		"curve:" "view curve:" "table editor:" "file:" 
	entry $root.f1.e0 -width 20 -textvariable mged_sketch_objsource
	frame $root.f2
	place_near_mouse $root
	if {$mode == "view"} {
		wm title $root "MGED AnimMate View Animation"
		label $root.l$mode -text "Create View Animation"
		button $root.f2.l0 -text "View Size:" -command \
			{set mged_sketch_objvsize [view size]}
		entry $root.f2.e0 -width 20 -textvariable mged_sketch_objvsize
		frame $root.f9
		button $root.f9.b0 -text "Eye Point:" \
			-command { set mged_sketch_eyecen [view eye] }
		entry $root.f9.e0 -width 20 -textvariable mged_sketch_eyecen
		frame $root.f10
		button $root.f10.b0 -text "Eye Yaw,Pitch,Roll: " \
			-command { set mged_sketch_eyeori [view ypr] }
		entry $root.f10.e0 -width 20 -textvariable mged_sketch_eyeori
		set if_view "$root.f9 $root.f10"
		checkbutton $root.cb0 -text "Read View Size from Source" \
			-variable mged_sketch_objrv -command "sketch_script_update $mode"
		$root.cb0 deselect
		uplevel #0 set mged_sketch_objdisp "-d"
		uplevel #0 set mged_sketch_objrot "-b"
		set lookat_txt "Eye path and look-at path"
	} else {
		wm title $root "MGED AnimMate Object Animation"
		set if_view ""
		label $root.l$mode -text "Create Object Animation"
		label $root.f2.l0 -text "Object Name:"
		entry $root.f2.e0 -width 20 -textvariable mged_sketch_objname
		checkbutton $root.cb1 -text "Relative Displacement" \
			-variable mged_sketch_objdisp -offvalue "-d" -onvalue "-c"
		checkbutton $root.cb2 -text "Relative Orientation" \
			-variable mged_sketch_objrot -offvalue "-b" -onvalue "-a"
		uplevel #0 set mged_sketch_objrv 0
		$root.cb1 deselect
		$root.cb2 deselect
		set lookat_txt "Object path and look-at path"
	}
	frame $root.f3
	button $root.f3.b0 -text "Object Center:" \
		-command { set mged_sketch_objcen [view center] }
	entry $root.f3.e0 -width 20 -textvariable mged_sketch_objcen
	frame $root.f4
	button $root.f4.b0 -text "Object Yaw,Pitch,Roll: " \
		-command { set mged_sketch_objori [view ypr] }
	entry $root.f4.e0 -width 20 -textvariable mged_sketch_objori
	checkbutton $root.cb3 -text "No Translation" \
		-variable mged_sketch_objrotonly -command "sketch_script_update $mode"
	$root.cb3 deselect
	frame $root.f5
	label $root.f5.l0 -text "First Frame:"
	entry $root.f5.e0 -width 20 -textvariable mged_sketch_objframe
	frame $root.f6
	button $root.f6.b0 -text "OK" -command "sketch_objanim $mode"
	button $root.f6.b1 -text "Show Script" -command "sketch_popup_preview $p \$mged_sketch_objscript"
	button $root.f6.b2 -text "Up" -command "raise $p"
	button $root.f6.b3 -text "Cancel" -command "destroy $root"

	label $root.l1 -text "Orientation Control: "
	radiobutton $root.rb0 -text "No Rotation" \
		-variable mged_sketch_objopt -value "none" -command "sketch_script_update $mode"
	radiobutton $root.rb1 -text "Automatic Steering" \
		-variable mged_sketch_objopt -value "steer" -command "sketch_script_update $mode"
	radiobutton $root.rb2 -text "Automatic Steering and Banking" \
		-variable mged_sketch_objopt -value "bank" -command "sketch_script_update $mode"
	frame $root.f7
	label $root.f7.l0 -text "    Maximum Bank Angle ="
	entry $root.f7.e0 -textvariable mged_sketch_objmang -width 4
	radiobutton $root.rb3 -text "Rotation Specified as YPR" \
		-variable mged_sketch_objopt -value "ypr" -command "sketch_script_update $mode"
	radiobutton $root.rb4 -text "Rotation Specified as Quat" \
		-variable mged_sketch_objopt -value "quat" -command "sketch_script_update $mode"
	radiobutton $root.rb5 -text $lookat_txt \
		-variable mged_sketch_objopt -value "lookat" -command "sketch_script_update $mode"
	frame $root.f8
	label $root.f8.l0 -textvariable mged_sketch_objncols
	label $root.f8.l1 -text "Input Columns Needed:"
	label $root.f8.l2 -textvariable mged_sketch_objcols


	pack	$root.l$mode $root.f0 $root.f1 \
		-side top -fill x -expand yes
	pack 	$root.f8 -side top
	eval pack	$root.f2 $root.f3 \
		$root.f4 ${if_view} $root.f5 \
		-side top -fill x -expand yes

	if {$mode == "view"} {
		pack $root.cb0 $root.cb3 -side top -anchor w

		pack $root.f9.b0 $root.f10.b0 \
			-side left -anchor w
		pack $root.f9.e0 $root.f10.e0 \
			-side right -anchor e
	} else {
		pack $root.cb1 $root.cb2 $root.cb3 \
			-side top -anchor w
	}

	pack 	$root.l1 -side top -anchor w

	pack 	$root.rb0 $root.rb1 $root.rb2 \
		-side top -anchor w
	pack	$root.f7 -side top -anchor e
	pack	$root.rb3 $root.rb4 $root.rb5 \
		-side top -anchor w
	pack 	$root.f6 -side top -fill x -expand yes


	pack \
		$root.f0.l0 $root.f1.l0 $root.f1.om0\
		$root.f2.l0 $root.f3.b0 \
		$root.f4.b0 $root.f5.l0 \
		$root.f8.l0 $root.f8.l1 $root.f8.l2\
		-side left -anchor w

	pack \
		$root.f0.e0 $root.f1.e0 $root.f2.e0\
		$root.f3.e0 $root.f4.e0 $root.f5.e0\
		-side right -anchor e

	pack \
		$root.f6.b0 $root.f6.b1 $root.f6.b2 $root.f6.b3 \
		-side left -fill x -expand yes

	pack \
		$root.f7.e0 $root.f7.l0 \
		-side right

	focus $root.f0.e0
	bind $root.f0.e0 <Key-Return> "focus $root.f1.e0"
	bind $root.f1.e0 <Key-Return> "focus $root.f2.e0"
	bind $root.f2.e0 <Key-Return> "focus $root.f3.e0"
	bind $root.f3.e0 <Key-Return> "focus $root.f4.e0"
	if { $mode == "view" } {
		bind $root.f4.e0 <Key-Return> "focus $root.f9.e0"
		bind $root.f9.e0 <Key-Return> "focus $root.f10.e0"
		bind $root.f10.e0 <Key-Return> "focus $root.f5.e0"
	} else {
		bind $root.f4.e0 <Key-Return> "focus $root.f5.e0"
	}
	bind $root.f5.e0 <Key-Return> "$root.f6.b0 invoke"

	sketch_script_update $mode
}

#create animation script
proc sketch_objanim { objorview } {
	global mged_sketch_objname \
		mged_sketch_objcen mged_sketch_objori mged_sketch_objsteer \
		mged_sketch_eyecen mged_sketch_eyeori \
		mged_sketch_objopt mged_sketch_objdisp mged_sketch_objrot \
		mged_sketch_objframe mged_sketch_objscript \
		mged_sketch_objmang \
		mged_sketch_objorv mged_sketch_objvsize \
		mged_sketch_objlaf mged_sketch_objrv mged_sketch_objrotonly \
		mged_sketch_temp1 mged_sketch_temp2 mged_sketch_anim_path \
		mged_sketch_table_prefix \
		mged_sketch_vwidget mged_sketch_vprefix

	upvar #0 mged_sketch_objsrctype ltype
	upvar #0 mged_sketch_objsource src
	upvar #0 mged_sketch_objncols ncols

	# make sure animated object exists (this will create an error if it doesn't)
	set tmp 0
	set tmp [db get $mged_sketch_objname]
	if { $tmp == 0 } return

	#find the source
	switch $ltype {
		"curve:" { 
			set type curve 
			set oldcurve [vdraw read n]
			vdraw send
			set ret [sketch_open_curve $src]
			if {$ret != 0} {
				tk_dialog ._sketch_msg {Couldn't find curve} \
				  "Couldn't find curve $src." \
				  {} 0 {OK}
				sketch_open_curve $oldcurve
				return
			}
		}
		"view curve:" {
			set type text
			set w ""
			foreach ved [sketch_vcurve_list] {
				if { [sketch_vcurve_get_label $ved] == $src} {
					set w $ved.t
					break
				}
			}
			if { $w == ""} {
				tk_dialog ._sketch_msg {Couldn't find view curve} \
				"Couldn't find view curve $src." \
				{} 0 {OK}
				return
			}
		}
		"table editor:" {
			set type text
			set w ""
			foreach ted [sketch_table_list] {
				if { [sketch_table_get_label $ted] == $src } {
					set w $ted.t
					break
				}
			}
			if { $w  == ""} {
				tk_dialog ._sketch_msg {Couldn't find editor} \
				  "Couldn't find table editor $src. \
				   (Text editor identifier must be an integer)." \
				  {} 0 {OK}
				return
			}
		}
		"file:" {
			#non-existent file errors handled by Tcl
			set type file
		}
		default {
			puts "sketch_objanim: Unknown ltype $ltype"
			return -1
		}
	}


	#test for valid number of columns
	switch $type {
	"curve" {
		if {$ncols != 4} {
			tk_dialog ._sketch_msg {Wrong number of columns} \
			"The animation you requested requires $ncols \
			 input columns. A curve provides 4." {} 0 "OK"
			sketch_open_curve $oldcurve
			return
		}
	} 
	"text" {
		set nsrc [sketch_text_cols $w]
		if { $nsrc > $ncols } {
			set ans [tk_dialog ._sketch_msg {Excess columns} \
			"The animation you requested only uses $ncols \
			input columns. Text editor $src has $nsrc columns. \
			Only the first $ncols columns will be used." \
			{} 0 {OK} {Cancel}]
			if { $ans } return
			set colsp "0-[expr $ncols-1]"
		} elseif { $nsrc < $ncols } {
			tk_dialog ._sketch_msg {Insufficient columns} \
			"The animation you requested requires $ncols \
			input columns. Text editor $src has only $nsrc." \
			{} 0 "OK"
			return
		} else {
			set colsp all
		}
	}
	"file" {
		set fd [open $src r]
		gets $fd line
		close $fd
		set nsrc [sketch_line_cols $line]
		if { $nsrc > $ncols } {
			set ans [tk_dialog ._sketch_msg {Excess columns} \
			"The animation you requested only uses $ncols \
			input columns. File $src has $nsrc columns. \
			Only the first $ncols columns will be used." \
			{} 0 {OK} {Cancel}]
			if { $ans } return
			for {set i 0} { $i < $nsrc} {incr i} {
				append incol " $i"
				if { $i < $ncols } {
					append outcol " $i"
				}
			}
			set filecmd "${mged_sketch_anim_path}chan_permute -i $src $incol -o stdout $outcol"
		} elseif { $nsrc < $ncols } {
			tk_dialog ._sketch_msg {Insufficient columns} \
			"The animation you requested requires $ncols \
			input columns. File $src has only $nsrc." \
			{} 0 "OK"
			return
		} else {
			set filecmd ""
		}
	}
	}

	#check for overwriting script file
	if {[file exists $mged_sketch_objscript] } {
		set ans [tk_dialog ._sketch_msg {File Exists} \
			"File $mged_sketch_objscript already exists." \
			{} 1 {Overwrite} {Cancel} ]
		if { $ans == 1} {
			return
		}
	}


	# build argument string
	if {$mged_sketch_objframe == ""} { set mged_sketch_objframe 0}
	set opts "-f $mged_sketch_objframe"
	if { $objorview == "view" } {
		set rcen $mged_sketch_objcen
		set rypr $mged_sketch_objori
		set wcen $mged_sketch_eyecen
		set wypr $mged_sketch_eyeori
		set i 0
		if {$rcen == ""} { set rcen "0 0 0"; incr i }
		if {$rypr == ""} { set rypr "0 0 0"; incr i }
		if {$wcen == ""} { set wcen "0 0 0"; incr i }
		if {$wypr == ""} { set wypr "0 0 0"; incr i }
		if { $i < 4 } {
			set fd [open "| ${mged_sketch_anim_path}anim_cascade \
			   -or -fc $wcen -fy $wypr -ac $rcen -ay $rypr" r]
			gets $fd line
			close $fd
			set veye [lrange $line 1 3]
			set vypr [lrange $line 4 6]
			#puts "ypri $ypri eyei $eyei"
			append opts " -d $veye -b $vypr"
		}
		if { $mged_sketch_objrv == 1} {
			set ovname " -v -1"
			set lookat_v "-v"
		} else {
			set ovname " -v $mged_sketch_objvsize"
			set lookat_v ""
		}
	} else {
		if { $mged_sketch_objcen != "" } {
			append opts " $mged_sketch_objdisp $mged_sketch_objcen"
		}
		if { $mged_sketch_objori != "" } {
			append opts " $mged_sketch_objrot $mged_sketch_objori"
		}
		set ovname " $mged_sketch_objname"
		set lookat_v ""
	}
	#puts "anim_script options: $opts"

	if { $mged_sketch_objopt == "lookat" } {
		set anim_lookat ${mged_sketch_anim_path}anim_lookat
		if { $type == "curve" } {
			#This shouldn't happen
			puts "sketch_objanim: Can't do lookat orientation \
				from curve."
			return
		} elseif { $type == "text" } {
			set fd [open "| $anim_lookat -y $lookat_v | \
			  ${mged_sketch_anim_path}anim_script $opts $ovname > \
			  $mged_sketch_objscript" w]
			sketch_text_to_fd $w $fd $colsp
			catch {close $fd}
			return
		} elseif { $type == "file" } {
			if { $filecmd == "" } {
				catch {eval exec $anim_lookat -y $lookat_v < $src | \
				  ${mged_sketch_anim_path}anim_script $opts $ovname > \
				  $mged_sketch_objscript}
			} else {
				catch {eval exec $filecmd | $anim_lookat -y $lookat_v | \
				  ${mged_sketch_anim_path}anim_script $opts $ovname > \
				  $mged_sketch_objscript}
			}

			return
		}
		return

	}

	if { $mged_sketch_objopt == "bank" } {
		if { $mged_sketch_objmang > 89 } {
			set mged_sketch_objmang 89
		} elseif { $mged_sketch_objmang < -89 } {
			set mged_sketch_objmang -89
		}
		set do_bank ${mged_sketch_anim_path}anim_fly
		if { $type == "curve" } {
			set sfile $mged_sketch_temp1
			set fd [open $sfile w]
			sketch_write_to_fd $fd [vdraw read l]
			close $fd
		} elseif { $type == "text" } {
			set sfile $mged_sketch_temp1
			set fd [open $sfile w]
			sketch_text_to_fd $w $fd "0,1,2,3"
			close $fd
		} elseif { $type == "file"} {
			if { $filecmd == ""} {
				set sfile $src
			} else {
				set sfile $mged_sketch_temp1
				exec $filecmd > $sfile
			}
		}

		set factor [exec $do_bank -b $mged_sketch_objmang < $sfile]
		eval exec $do_bank -f $factor < $sfile \
			| ${mged_sketch_anim_path}anim_script $opts $ovname > $mged_sketch_objscript
			
		if { $type == "curve" } {
			sketch_open_curve $oldcurve
			exec rm $sfile
		} elseif { $type == "text" } {
			exec rm $sfile
		} elseif { $type == "file"} {
			catch {rm $mged_sketch_temp1}
		}
		return
	}


	#else just use anim_script
	switch $mged_sketch_objopt {
	none	{ append opts " -t" }
	steer	{ append opts " -s" }
	ypr	{ }
	quat	{ append opts " -q -p" }
	}

	if { $mged_sketch_objrotonly } {
		append opts " -r"
	}
	
	#puts "anim_script options: $opts"
	#puts "anim_script name: $ovname"
	if { $type == "file"} {
		#puts "filecmd = $filecmd src = $src"
		if { $filecmd == "" } {
			eval exec ${mged_sketch_anim_path}anim_script $opts $ovname < $src > \
			  $mged_sketch_objscript
		} else {
			eval exec $filecmd | ${mged_sketch_anim_path}anim_script $opts $ovname | \
			  $mged_sketch_objscript
		}
	} elseif { $type == "curve" } {
		set fd [open \
		     [concat | ${mged_sketch_anim_path}anim_script $opts $ovname > \
		     $mged_sketch_objscript] w ]
		sketch_write_to_fd $fd [vdraw read l]
		close $fd
		sketch_open_curve $oldcurve
	} elseif { $type == "text" } {
		set fd [open \
		     [concat | ${mged_sketch_anim_path}anim_script $opts $ovname > \
		     $mged_sketch_objscript] w ]
		sketch_text_to_fd $w $fd $colsp
		close $fd
	}

	return
}

proc sketch_script_update { objorview } {
	global mged_sketch_objopt mged_sketch_objcols mged_sketch_objncols \
		mged_sketch_objrv mged_sketch_objrotonly

	switch $mged_sketch_objopt {
	none	-
	steer	{
		set base "t x y z"
		set mged_sketch_objrotonly 0
	}
	bank	{
		set base "t x y z"
		set mged_sketch_objrv 0
		set mged_sketch_objrotonly 0
	}
	ypr	{set base "t x y z y p r"}
	quat	{set base "t x y z qx qy qz qw"}
	lookat  {
		set base "t x y z lx ly lz"
		set mged_sketch_objrotonly 0
	}
	}

	if { $mged_sketch_objrotonly } {
		set base [lreplace $base 1 3]
	}
	
	if { ($mged_sketch_objrv) && ($mged_sketch_objopt != "lookat") } {
		set base [linsert $base 1 v]
	}

	set mged_sketch_objncols [llength $base]
	set mged_sketch_objcols $base
}



#-----------------------------------------------------------------
# Create Track Animation Scripts
#-----------------------------------------------------------------
proc sketch_init_track {} {
	#track animation
	uplevel #0 set mged_sketch_init_track 1
	uplevel #0 {set mged_sketch_track_vsrc ""}
	uplevel #0 {set mged_sketch_track_wname ""}
	uplevel #0 {set mged_sketch_track_wsrc ""}
	uplevel #0 {set mged_sketch_track_pname ""}
	uplevel #0 set mged_sketch_track_npads 1
	uplevel #0 {set mged_sketch_track_dist "-s"  }
	uplevel #0 {set mged_sketch_track_type Minimize  }
	uplevel #0 {set mged_sketch_track_len ""  }
	uplevel #0 {set mged_sketch_track_geom 0  }
	uplevel #0 {set mged_sketch_track_arced "0"}
	uplevel #0 {set mged_sketch_track_antistr 0}
	#dependencies
	foreach dep {main objanim} {
		if { [info globals mged_sketch_init_$dep] == "" } {
			sketch_init_$dep
		}
	}
}

#control creation of animation scripts
proc sketch_popup_track_anim { p } {
	if { $p == "." } { 
		set root ".tanim" 
	} else { 
		set root "$p.tanim"
	}
	if { [info commands $root] != ""} {
		raise $root
		return
	}

	toplevel $root

	place_near_mouse $root
	wm title $root "MGED AnimMate Track Animation"
	label $root.l0 -text "Create Track Animation"
	frame $root.f0
	label $root.f0.l0 -text "Output File: "
	entry $root.f0.e0 -width 20 -textvariable mged_sketch_objscript
	frame $root.f1
	label $root.f1.l0 -text "Vehicle Path from Table: "
	entry $root.f1.e0 -width 20 -textvariable mged_sketch_track_vsrc
	frame $root.f1a
	radiobutton $root.f1a.r0 -text "Distance" -variable mged_sketch_track_dist -value "-u"
	radiobutton $root.f1a.r1 -text "Position" -variable mged_sketch_track_dist -value "-s"
	radiobutton $root.f1a.r2 -text "Position and YPR" -variable mged_sketch_track_dist -value "-y"
	frame $root.f2
	label $root.f2.l0 -text "Wheel Specs from Table: "
	entry $root.f2.e0 -width 20 -textvariable mged_sketch_track_wsrc
	frame $root.fw
	label $root.fw.l0 -text "Wheel Base Name:"
	entry $root.fw.e0 -width 20 -textvariable mged_sketch_track_wname
	frame $root.f4
	label $root.f4.l0 -text "Pad Base Name:"
	entry $root.f4.e0 -width 20 -textvariable mged_sketch_track_pname
	frame $root.f5
	label $root.f5.l0 -text "Number of Pads: "
	entry $root.f5.e0 -textvariable mged_sketch_track_npads
	frame $root.f3
	tk_optionMenu $root.f3.om mged_sketch_track_type \
		"Minimize" "Elastic" "Rigid"	
	label $root.f3.l0 -text "Track Length:"
	entry $root.f3.e0 -width 20 -textvariable mged_sketch_track_len
	frame $root.f3a
	button $root.f3a.b0 -text "Get Track Length from Wheel Specs" \
		-command "sketch_track_get_length \$mged_sketch_track_wsrc"
	frame $root.f6
	button $root.f6.b0 -text "Vehicle Center:" \
			-command { set mged_sketch_objcen [view center] }
	entry $root.f6.e0 -width 20 -textvariable mged_sketch_objcen
	frame $root.f7
	button $root.f7.b0 -text "Vehicle Yaw,Pitch,Roll: " \
			-command { set mged_sketch_objori [view ypr] }
	entry $root.f7.e0 -width 20 -textvariable mged_sketch_objori
	frame $root.f8
	label $root.f8.l0 -text "First Frame:"
	entry $root.f8.e0 -width 20 -textvariable mged_sketch_objframe
	frame $root.fa
	checkbutton $root.fa.cb -text "Create Geometry File from Frame:" -variable mged_sketch_track_geom
	entry $root.fa.e0 -width 3 -textvariable mged_sketch_track_arced
	checkbutton $root.cb0 -text "Enable Anti-Strobing" -variable mged_sketch_track_antistr
	frame $root.f9
	button $root.f9.b0 -text "OK" -command {sketch_do_track }
	button $root.f9.b1 -text "Show Script" -command "sketch_popup_preview $p \$mged_sketch_objscript"
	button $root.f9.b2 -text "Up" -command "raise $p"
	button $root.f9.b3 -text "Cancel" -command "destroy $root"
	

	pack	$root.l0 $root.f0 $root.f1 $root.f1a $root.f2 \
		$root.fw \
		$root.f4 $root.f5 $root.f3 $root.f3a\
		$root.f6 $root.f7 \
		$root.f8 $root.fa $root.cb0 $root.f9\
		-side top -fill x -expand yes

	pack \
		$root.f0.l0 $root.f1.l0 $root.f2.l0 \
		$root.fw.l0 \
		$root.f4.l0 $root.f5.l0 \
		$root.f6.b0 $root.f7.b0 \
		$root.f8.l0 \
		$root.f3.om $root.f3.l0 \
		-side left -anchor w

	pack \
		$root.f0.e0 $root.f1.e0 $root.f2.e0 $root.f3.e0\
		$root.fw.e0 $root.f4.e0 $root.f5.e0\
		$root.f6.e0 $root.f7.e0 $root.f8.e0 \
		$root.fa.e0 $root.fa.cb \
		$root.f1a.r2 $root.f1a.r1 $root.f1a.r0 \
		$root.f3a.b0 \
		-side right -anchor e

	pack \
		$root.f9.b0 $root.f9.b1 $root.f9.b2 $root.f9.b3 \
		-side left -fill x -expand yes


	focus $root.f0.e0
	bind $root.f0.e0 <Key-Return> "focus $root.f1.e0"
	bind $root.f1.e0 <Key-Return> "focus $root.f2.e0"
	bind $root.f2.e0 <Key-Return> "focus $root.fw.e0"
	bind $root.fw.e0 <Key-Return> "focus $root.f4.e0"
	bind $root.f4.e0 <Key-Return> "focus $root.f5.e0"
	bind $root.f5.e0 <Key-Return> "focus $root.f3.e0"
	bind $root.f3.e0 <Key-Return> "focus $root.f6.e0"
	bind $root.f6.e0 <Key-Return> "focus $root.f7.e0"
	bind $root.f7.e0 <Key-Return> "focus $root.f8.e0"
	bind $root.f8.e0 <Key-Return> "focus $root.fa.e0"
	bind $root.fa.e0 <Key-Return> "$root.f9.b0 invoke; focus $root"


}

proc sketch_track_get_length { tid } {
	global mged_sketch_temp1 mged_sketch_anim_path mged_sketch_track_len
	
	set text [sketch_text_from_table $tid 4]
	if { $text == "" } {return 0}
	set fd [open $mged_sketch_temp1 w]
	sketch_text_to_fd $text $fd all
	close $fd
	set fd [open "| ${mged_sketch_anim_path}anim_track \
		-c $mged_sketch_temp1" r]
	catch {flush $fd}
	gets $fd length
	catch {close $fd}
	set mged_sketch_track_len $length
	exec rm $mged_sketch_temp1
}
	

proc sketch_do_track { } {
	
	global mged_sketch_temp1 mged_sketch_anim_path \
		mged_sketch_track_vsrc \
		mged_sketch_track_wsrc \
		mged_sketch_track_dist \
		mged_sketch_track_type \
		mged_sketch_track_len \
		mged_sketch_track_geom \
		mged_sketch_track_arced mged_sketch_track_antistr\
		mged_sketch_objcen mged_sketch_objori mged_sketch_objframe

	upvar #0 mged_sketch_track_wname wname
	upvar #0 mged_sketch_track_pname pname
	upvar #0 mged_sketch_track_npads numpads
	upvar #0 mged_sketch_objscript outfile
	set ypr $mged_sketch_objori
	set center $mged_sketch_objcen

	#check for overwriting script file
	if {[file exists $outfile] } {
		set ans [tk_dialog ._sketch_msg {File Exists} \
			"File $outfile already exists." \
			{} 1 {Overwrite} {Cancel} ]
		if { $ans == 1} {
			return
		}
	}

	set wtext [sketch_text_from_table $mged_sketch_track_wsrc 4]
	if { $wtext == "" } { return -1 }

	switch -- $mged_sketch_track_dist {
		"-u" {set needcol 2}
		"-s" {set needcol 4}
		"-y" {set needcol 7}
	}

	
	if { ($mged_sketch_track_vsrc == "") && $mged_sketch_track_geom && ($mged_sketch_track_arced == "0") } {
		set g_except 1
		set vtext ._sketch_track_vtext
		catch {destroy ._sketch_track_vtext}
		text $vtext
		$vtext insert 1.0 "0 0 0 0 0 0 0"
	} else {
		set g_except 0
		set vtext \
		  [sketch_text_from_table $mged_sketch_track_vsrc $needcol]
		if { $vtext == "" } { return -1 }
	}


	set numwheels [sketch_text_rows $wtext]
	if { $numwheels < 2 } {
		tk_dialog ._sketch_msg "Not enough wheels" "The wheel file \
		has only $numwheels wheel(s). You must specify the position \
		and radius of at least 2 wheels." {} 0 "OK"
		return -1
	}

	if { $wname == "" } {
		set wcmd ""
	} else {
		set wcmd "-w $wname"
		# make sure wheel names exist
		set tmp 0
		for { set count 0 } { $count < $numwheels } { incr count } {
			set tmp [db get $wname$count]
			if { $tmp == 0 } return
		}
	}
	if { ($pname == "") || ($numpads == "") } {
		set pcmd ""
	} else {
		set pcmd "-p $numpads $pname"
		# make sure the pad names exist
		set tmp 0
		for { set count 0 } { $count < $numpads } { incr count } {
			set tmp [db get $pname$count]
			if { $tmp == 0 } return
		}
	}
	if { ($pcmd == "") && ($wcmd == "") } {
		tk_dialog ._sketch_msg "AnimMate Track animation error" \
		   "You must specify a pad name and number and/or a wheel name." {} 0 "OK"
		return -1;
	}
	set fd [open $mged_sketch_temp1 w]
	sketch_text_to_fd $wtext $fd all
	close $fd

	while { [llength $ypr] < 3 } { lappend ypr 0}
	while { [llength $center] < 3 } { lappend center 0}
	if { $mged_sketch_track_geom == 1 } {
		if { $mged_sketch_track_arced == "" } {
			set mged_sketch_track_arced 0
		}
		set arccmd "-g $mged_sketch_track_arced"
	} else {
		set arccmd ""
	}
	
	set tlen [expr $mged_sketch_track_len]
	if { $tlen == "" } {
		set tlen 0
	}
	switch $mged_sketch_track_type {
		Minimize { set lencmd "-lm" }
		Elastic { set lencmd "-le $tlen" }
		Rigid { set lencmd "-lf $tlen" }
	}

	if { $mged_sketch_objframe != ""} {
		set fcmd "-f $mged_sketch_objframe"
	} else {
		set fcmd ""
	}

	if { $mged_sketch_track_antistr == 1 } {
		set acmd "-a"
	} else {
		set acmd " "
	}

	set myargs "$acmd $lencmd $arccmd $mged_sketch_track_dist -b $ypr \
		-d $center $fcmd $wcmd $pcmd"
	#puts $myargs

	set fd [ open "| ${mged_sketch_anim_path}anim_track \
		$myargs	$mged_sketch_temp1 > $outfile" w]
	sketch_text_to_fd $vtext $fd all
	close $fd
	exec rm $mged_sketch_temp1
	if { $g_except } {
		destroy $vtext
	}
}


#-----------------------------------------------------------------
# Combine Scripts
#-----------------------------------------------------------------
proc sketch_init_sort {} {
	uplevel #0 set mged_sketch_init_sort 1
	uplevel #0 set mged_sketch_sort_temp "./_mged_sketch_sort_"
	#dependencies
	foreach dep {main} {
		if { [info globals mged_sketch_init_$dep] == "" } {
			sketch_init_$dep
		}
	}
}

proc sketch_popup_sort { p } {
	if { $p == "." } { 
		set root ".sort" 
	} else { 
		set root "$p.sort"
	}
	if { [info commands $root] != ""} {
		raise $root
		return
	}
	toplevel $root
	place_near_mouse $root
	wm title $root "MGED AnimMate Combine Scripts"
	label $root.l0 -text "Combine Scripts"
	frame $root.f0
	label $root.f0.l0 -text "Combine Scripts:"
	entry $root.f0.e0 -width 20 
	frame $root.f0.f0
	listbox $root.f0.f0.lb0 -height 6 -width 20 \
		-yscrollcommand "$root.f0.f0.s0 set"
	scrollbar $root.f0.f0.s0 -command "$root.f0.f0.lb0 yview"
	frame $root.f1
	button $root.f1.b0 -text "Filter:" -command " \
	  sketch_list_filter $root.f1.f1.lb1 \[$root.f1.e1 get \] "
	entry $root.f1.e1 -width 20
	frame $root.f1.f1
	listbox $root.f1.f1.lb1 -height 6 -width 20 \
		-yscrollcommand "$root.f1.f1.s0 set"
	scrollbar $root.f1.f1.s0 -command "$root.f1.f1.lb1 yview"
	frame $root.f2
	label $root.f2.l0 -text "Create Script: "
	entry $root.f2.e0 -width 20
	frame $root.f3
	button $root.f3.b0 -text "OK" -command "sketch_sort $root \
		\[$root.f2.e0 get\] $root.f0.f0.lb0; \
		$root.f1.b0 invoke"
	button $root.f3.b1 -text "Show Script" -command "sketch_popup_preview $p \[$root.f2.e0 get\]"
	button $root.f3.b2 -text "Up" -command "raise $p"
	button $root.f3.b3 -text "Cancel" -command "destroy $root"

	bind $root.f0.e0 <Key-Return> " sketch_sort_entry1 $root.f0.e0 $root.f0.f0.lb0 $root.f2.e0 "
	bind $root.f1.e1 <Key-Return> " $root.f1.b0 invoke "
	bind $root.f0.f0.lb0 <Button-1> "sketch_list_remove_y $root.f0.f0.lb0 %y "
	bind $root.f1.f1.lb1 <Button-1> "sketch_list_add_y $root.f1.f1.lb1 $root.f0.f0.lb0 %y "
	bind $root.f2.e0 <Key-Return> "$root.f3.b0 invoke"

	$root.f2.e0 insert end ".script"
	$root.f2.e0 selection range 0 end
	$root.f2.e0 icursor 0

	$root.f1.e1 insert end "./*.script"
	sketch_list_filter $root.f1.f1.lb1 "./*.script"

	pack $root.f3 $root.f2 -side bottom -fill x -expand yes
	pack $root.l0 -side top
	pack $root.f0 -side left
	pack $root.f1 -side right

	pack $root.f0.l0 $root.f0.e0 $root.f0.f0 \
		$root.f1.b0 $root.f1.e1 $root.f1.f1 \
		-side top -anchor w
	pack $root.f2.l0 $root.f2.e0 \
		-side left
	pack $root.f3.b0 $root.f3.b1 $root.f3.b2 $root.f3.b3 \
		-side left -expand yes -fill x
	pack $root.f0.f0.lb0 $root.f0.f0.s0 \
		$root.f1.f1.lb1 $root.f1.f1.s0 \
		-side left -fill y -expand yes

	focus $root.f0.e0

}

proc sketch_sort_entry1 { entry list nentry } {
	if { [set line [$entry get]] == "" } {
		focus $nentry
	}
	$list insert end $line
	$entry delete 0 end
}

proc sketch_sort { sortp outfile list } {
	global mged_sketch_sort_temp mged_sketch_tab_path

	if { [info commands $sortp.fa] != "" } {
		tk_dialog ._sketch_msg {Script already sorting} \
		  "The previous script is still being sorted" {} 0 "OK"
		return
	}
	#check for overwriting script file
	if {[file exists $outfile] } {
		set ans [tk_dialog ._sketch_msg {File Exists} \
			"File $outfile already exists." \
			{} 1 {Overwrite} {Cancel} ]
		if { $ans == 1} {
			return
		}
	}

	set files ""
	foreach file [$list get 0 end] {
		append files "$file "
	}
	set pid [eval exec cat $files | ${mged_sketch_tab_path}scriptsort \
		-q -b 1 > $outfile &]

	frame $sortp.fa
	label $sortp.fa.l0 -text "Sorting $outfile ..."
	button $sortp.fa.b0 -text "Halt" -command "exec kill $pid"
	pack $sortp.fa -side bottom -before $sortp.f3
	pack $sortp.fa.l0 $sortp.fa.b0 -side left -fill x

	set done "destroy $sortp.fa"
	sketch_sort_monitor $outfile -1 $done
}

proc sketch_sort_monitor { file oldtime script} {
	set newtime [file mtime $file]
	if { $newtime > $oldtime } {
		after 1000 [list sketch_sort_monitor $file $newtime $script]
	} else {
		eval $script
	}
}

proc sketch_list_remove_y { list y } {
	$list delete [$list nearest $y]
}

proc sketch_list_add_y { in out y } {
	$out insert end [$in get [$in nearest $y]]
}

proc sketch_list_filter { list filter } {
	$list delete 0 end
	if { $filter == "" } return
	foreach file [glob $filter] {
		$list insert end [file tail $file]
	}
}

#-----------------------------------------------------------------
# Show Script
#-----------------------------------------------------------------
proc sketch_init_preview {} {
	# preview script
	uplevel #0 set mged_sketch_init_preview 1
	uplevel #0 {set mged_sketch_prevs ""}
	uplevel #0 {set mged_sketch_preve ""}
	uplevel #0 {set mged_sketch_prevp ""}
	uplevel #0 {set mged_sketch_prev_size [view size]}
	uplevel #0 {set mged_sketch_prev_center [view center]}
	uplevel #0 {set mged_sketch_prev_quat [view quat]}
	uplevel #0 {set mged_sketch_prev_fps "30"}
	#dependencies
	foreach dep {main} {
		if { [info globals mged_sketch_init_$dep] == "" } {
			sketch_init_$dep
		}
	}
}

#control animation previews
proc sketch_popup_preview { p {filename ""} } {
	if { $p == "." } { 
		set root ".prev" 
	} else { 
		set root "$p.prev"
	}
	if { [info commands $root] != ""} {
		raise $root
		if { $filename != "" } {
			$root.f0.e0 delete 0 end
			$root.f0.e0 insert end $filename
		}
		$root.f0.e0 selection range 0 end
		return
	}
	toplevel $root
	place_near_mouse $root
	wm title $root "MGED AnimMate Show Script"
	label $root.l0 -text "Show Script"
	frame $root.f0
	label $root.f0.l0 -text "Script File: "
	entry $root.f0.e0 -width 20
	frame $root.f1
	label $root.f1.l0 -text "Max Frames Per Second:"
	entry $root.f1.e0 -width 5 \
		-textvariable mged_sketch_prev_fps
	frame $root.f2
	label $root.f2.l0 -text "Start Frame: "
	entry $root.f2.e0 -width 5 -textvariable mged_sketch_prevs
	frame $root.f3
	label $root.f3.l0 -text "End Frame: "
	entry $root.f3.e0 -width 5 -textvariable mged_sketch_preve
	checkbutton $root.cb0 -text "Polygon Rendering" \
		-variable mged_sketch_prevp -onvalue "-v" -offvalue ""
	frame $root.f4
	button $root.f4.b0 -text "Show" \
		-command "sketch_preview \[$root.f0.e0 get\]"
	button $root.f4.b1 -text "Up" -command "raise $p"
	button $root.f4.b2 -text "Cancel" -command "destroy $root"
	button $root.f4.b3 -text "Restore" -command "sketch_prev_restore"

	$root.f0.e0 delete 0 end
	$root.f0.e0 insert 0 $filename
	$root.f0.e0 selection range 0 end

	pack $root.l0 \
		$root.f0 $root.f1 $root.f2 \
		$root.f3 $root.cb0 $root.f4 \
		-side top -expand yes -fill x -anchor w
	
	pack $root.f0.l0 $root.f1.l0 $root.f2.l0 $root.f3.l0 \
		-side left
	pack $root.f0.e0 $root.f1.e0 $root.f2.e0 $root.f3.e0 \
		-side right
	pack $root.f4.b0 $root.f4.b1 $root.f4.b2 $root.f4.b3 \
		-side left -expand yes -fill x

	focus $root.f0.e0
	bind $root.f0.e0 <Key-Return> "focus $root.f1.e0"
	bind $root.f1.e0 <Key-Return> "focus $root.f2.e0"
	bind $root.f2.e0 <Key-Return> "focus $root.f3.e0"
	bind $root.f3.e0 <Key-Return> "$root.f4.b0 invoke"
}

#preview an animation script
proc sketch_preview { filename } {
	upvar #0 mged_sketch_prev_fps fps
	upvar #0 mged_sketch_prevp arg0
	global mged_sketch_prevs mged_sketch_preve mged_sketch_prev_size \
		mged_sketch_prev_center mged_sketch_prev_quat

	#save list of curves currently displayed
	set clist ""
	set vlist [db_glob "dummy_cmd _VDRW*"]
	foreach name [lrange $vlist 1 end] {
		lappend clist [string range $name 5 end]
	}

	set mged_sketch_prev_size [view size]
	set mged_sketch_prev_center [view center]
	set mged_sketch_prev_quat [view quat]

	if {($mged_sketch_prevs == "first")||($mged_sketch_prevs == "")} {
		set arg1 ""
	} else {
		set arg1 [format "-D%s" $mged_sketch_prevs]
	}
	if {($mged_sketch_preve == "last")||($mged_sketch_preve == "")} {
		set arg2 ""
	} else {
		set arg2 [format "-K%s" $mged_sketch_preve]
	}
	if {($fps <= 0) || ($fps == "") } {
		set arg3 ""
	} else {
		set arg3 [format "-d%s" [expr 1.0 / $fps]]
	}

	
	eval [concat preview $arg0 $arg1 $arg2 $arg3 $filename]
	# restore current curves to display
	if [vdraw open] {
		set oldname [vdraw read n]
	} else {
		set oldname ""
	}
	foreach curve $clist {
		vdraw open $curve
		vdraw send
	}
	if {$oldname != "" } {
		sketch_open_curve $oldname
	}
}

proc sketch_prev_restore {} {
	global mged_sketch_prev_size mged_sketch_prev_center \
		mged_sketch_prev_quat

	eval viewset size $mged_sketch_prev_size \
		center $mged_sketch_prev_center quat $mged_sketch_prev_quat
	eval e [who]
}	
	
#-----------------------------------------------------------------
# Quit
#-----------------------------------------------------------------
proc sketch_quit { p } {
	destroy $p
	foreach var [info globals mged_sketch_init*] {
		uplevel #0 "unset $var"
	}
	kill -f _VDRW_sketch_hl_

	#reset button 2 bindings
	upvar #0 mged_sketch_bindclasses wlist
	global mged_sketch_bindB mged_sketch_bindBR mged_sketch_bindBM
	foreach wclass $wlist {
		bind $wclass <Button-2> $mged_sketch_bindB($wclass)
		bind $wclass <ButtonRelease-2> $mged_sketch_bindBR($wclass)
		bind $wclass <B2-Motion> $mged_sketch_bindBM($wclass)
	}
	# anything else?
}

#-----------------------------------------------------------------
# Other Procedures
#-----------------------------------------------------------------
# write "length" curve nodes to given file descriptor
proc sketch_write_to_fd { fd length} {
	upvar #0 [format "mged_sketch_time_%s" [vdraw read n]] tlist
	if { ![info exists tlist] } { return } 
	for { set i 0} { $i < $length} {incr i} {
		puts $fd [concat \
			[lindex $tlist $i] \
			[lrange [vdraw read $i] 1 3] ]
	}
}	

# read curve nodes from file, return number appended
proc sketch_read_from_fd { fd } {
	upvar #0 [format "mged_sketch_time_%s" [vdraw read n]] tlist
	set line {}
	set tlist {}
	if { [gets $fd line] >= 0 } {
		lappend tlist [lindex $line 0]
		vdraw write n 0 [lindex $line 1] [lindex $line 2] \
				[lindex $line 3]
		set num_added 1
	} else {
		tk_dialog ._sketch_msg {Empty file} \
			{The file you loaded was empty.} {} \
			 0 {OK}
		return 0
	}
	while { [gets $fd line] >= 0 } {
		lappend tlist [lindex $line 0]
		vdraw write n 1 [lindex $line 1] [lindex $line 2] \
				[lindex $line 3]
		incr num_added
	}
	return $num_added
}

#read current curve into end of table editor
proc sketch_text_echoc { w } {
	if { ! [vdraw open] } { return }
	set length [vdraw read l]
	upvar #0 "mged_sketch_time_[vdraw read n]" tlist
	if { ![info exists tlist] } { return } 
	for {set i 0} {$i < $length} {incr i} {
		set temp [vdraw read $i]
		$w insert end [format "\t%s\t%s\t%s\t%s\n" \
			[lindex $tlist $i] [lindex $temp 1] \
			[lindex $temp 2] [lindex $temp 3] ]
			
	}
}

#copy one text widget to another, replacing if specified
proc sketch_text_copy { win wout args } {
	if { [lindex $args 0] == "replace" } {
		$wout delete 1.0 end
	}
	#otherwise just append to existing
	$wout insert end [$win get 1.0 "end -1 c"]
}

#apply first four columns from table editor to current curve
proc sketch_text_apply { w mode} {
	upvar #0 [format "mged_sketch_time_%s" [vdraw read n]] tlist
	if {$mode == "replace"} {
		vdraw delete a
		set tlist {}
	}
	#otherwise append to existing
	if { [set line [$w get 1.0 "1.0 lineend"]] != ""} {
		lappend tlist [lindex $line 0]
		vdraw write n 0 [lindex $line 1] [lindex $line 2] \
				[lindex $line 3]
		set num_added 2
	} else {
		tk_dialog ._sketch_msg {Empty text} \
			{The text you loaded was empty.} {} \
			 0 {OK}
		return 0
	}
	while { [set line [$w get $num_added.0 "$num_added.0 lineend"]] != ""} {
		lappend tlist [lindex $line 0]
		vdraw write n 1 [lindex $line 1] [lindex $line 2] \
				[lindex $line 3]
		incr num_added
	}
	sketch_update
	return [expr $num_added - 1]
}

#save the specified columns of the text to a file
proc sketch_text_writef { w filename col } {
	if {[file exists $filename] } {
		set ans [tk_dialog ._sketch_msg {File Exists} \
			{File already exists.} {} 1 {Overwrite} {Cancel} ]
		if { $ans == 1} {
			return
		}
	}

	set fd [open $filename w]
	sketch_text_to_fd $w $fd $col
	close $fd
	catch {	destroy ._sketch_input}
}

proc sketch_text_readf { w filename col mode } {
	set fd [open $filename r]
	sketch_text_from_fd $w $fd $col $mode
	close $fd
	sketch_table_bar_reset $w
	catch {destroy ._sketch_input}
}

#write the specified columns of the text to fd
proc sketch_text_to_fd { w fd col} {

	if {$col == "all"} {
		set i 1
		while { [set line [$w get $i.0 "$i.0 lineend"]] != ""} {
			puts $fd $line
			incr i
		}
		return [expr $i - 1]
	} else {
		sketch_parse_col $col [sketch_text_cols $w] \
			colarray
		set numcols [array size colarray]
		set i 1
		while { [set line [$w get $i.0 "$i.0 lineend"]] != ""} {
			set outline ""
			for {set j 0} { $j < $numcols} {incr j} {
				lappend outline [lindex $line $colarray($j)]
			}
			puts $fd [join $outline \t]
			incr i
		}
		return [expr $i - 1]
	}
}

proc sketch_pos_int {str} {
	return [regexp {^[0-9]+$} $str]
}

#str is a list of columns, something like "0-2,5,7,9-" 
#num is the number of columns that exist, eg "11"
#output is an array holding the columns, eg 0,1,2,5,7,9,10
#returns the number of columns requested, or -1 on error
proc sketch_parse_col {str num output} {
	upvar $output out
	set temp [split $str ,]
	set len [llength $temp]
	set k 0
	for {set i 0} {$i < $len} {incr i} {
		set temp1 [lindex $temp $i]
		set temp1 [split $temp1 -]
		set len1 [llength $temp1]
		set start [lindex $temp1 0]
		if {$len1 > 1} { 
			set end [lindex $temp1 1]
		} else {
			set end $start
		}	
		if {$start == "" } {set start 0}
		if {$end == "" } {set end [expr $num - 1]}
		if {!(([sketch_pos_int $start])&&([sketch_pos_int $end]))} {
			return -1
		}
		set sign 1
		if {$start > $end} {
			set test {$j >= $end}
			set change {incr j -1}
		} else {
			set test {$j <= $end}
			set change {incr j 1}
		}		
		for {set j $start} $test $change {
			if {($j>=0)&&($j<$num)} {
				set out($k) $j
				incr k
			}
		}
	}
	return $k
}




proc sketch_print {} {
	set length [vdraw read l]
	puts "Name is [vdraw read n]"
	for {set i 0} { $i < $length} { incr i} {
		puts [vdraw read $i]
	}
	
}

proc sketch_popup_input {title entries buttons} {
	catch {destroy ._sketch_input}
	toplevel ._sketch_input
	place_near_mouse ._sketch_input
	if {$title != ""} { wm title ._sketch_input $title }
	set max 0
	foreach pair $entries {
		set len [string length [lindex $pair 0]]
		if { $len > $max} {
			set max $len
		}
	}
	set i 0
	foreach pair $entries {
		frame ._sketch_input.f$i
		pack ._sketch_input.f$i -side top -expand yes -anchor w -fill x
		set mylabel [lindex $pair 0]
		set k [string length $mylabel] 
		label ._sketch_input.f$i.l -text $mylabel -width $max -anchor e
		entry ._sketch_input.f$i.e -width 20
		if { $i > 0 } {
			bind  ._sketch_input.f[expr $i-1].e <Key-Return> \
			  "focus ._sketch_input.f$i.e; \
			   ._sketch_input.f$i.e selection range 0 end"
		}
		._sketch_input.f$i.e insert end [lindex $pair 1]
		pack ._sketch_input.f$i.l ._sketch_input.f$i.e \
			-side left -anchor w
		incr i
	}
	set max 0
	foreach pair $buttons {
		set len [string length [lindex $pair 0]]
		if { $len > $max} {
			set max $len
		}
	}
	set j 0
	foreach pair $buttons {
		if { $j >= $i } { 
			frame ._sketch_input.f$j 
			pack ._sketch_input.f$j -side top -anchor e
		}
		button ._sketch_input.f$j.b -text [lindex $pair 0] \
			-command [lindex $pair 1] -width $max
		pack ._sketch_input.f$j.b -side right
		incr j
	}
	if { $j > $i } { 
		set max $j; set min $i } else { 
		set max $i; set min $j }
	if { $max < 1 } { 
		destroy ._sketch_input 
		return -1
	} 
	if { $min < 1} {
		return 0
	}
	._sketch_input.f0.e selection range 0 end
	focus ._sketch_input.f0.e
	bind ._sketch_input.f[expr $i-1].e <Key-Return> \
			{._sketch_input.f0.b invoke}
	return 0
}

#transfer columns from one text widget to another
#columns is any string accepted by sketch_parse_col
#mode is one of replace, append, left, right
#rows optionally specifies maximum number of rows
proc sketch_text_from_text { wout win col mode {rows all}} {
	set srclines [sketch_text_rows $win]
	if { [regexp {^[0-9]+$} $rows] == "0" } {
		set numlines $srclines
	} else {
		set numlines $rows
		if { $numlines > $srclines } {
			set numlines $srclines
		}
	}

	if { $mode == "replace" } {
		$wout mark set prev_end "end - 2 c"
		if { [$wout index prev_end] == "1.0"} {set mode append}
	}
	if {$col == "all"} {
		if {($mode == "right") || ($mode == "left")} {
			if  {$mode == "right"} {
				set place lineend
			} else {
				set place ""
			}
			for {set i 1} { $i <= $numlines} {incr i} {
				if {[$wout get "$i.0 lineend"] == ""} {
					$wout insert "$i.0 lineend" "\n"
				}
				set line [join [$win get $i.0 "$i.0 lineend"]\
					"\t" ]
				$wout insert "$i.0 $place" "\t$line"
			}
			return
		} 
		#else
		if {[lindex [split [$wout index "end - 1 c"] .] 1] != 0} {
			$wout insert "end - 1 c" "\n"
		}
		for {set i 1} { $i <= $numlines} {incr i} {
			set line [join [$win get $i.0 "$i.0 lineend"] "\t" ]
			$wout insert end "\t$line\n"
		}
		if { $mode == "replace"} {
			$wout delete 1.0 "prev_end + 1 c"
		}
		return
	} 
	#else
	#note: depends on first row for number of columns
	sketch_parse_col $col [sketch_text_cols $win] colarray
	set numcols [array size colarray]

	if {($mode == "right") || ($mode == "left")} {
		if  {$mode == "right"} {
			set place lineend
		} else {
			set place ""
		}
		for {set i 1} { $i <= $numlines} {incr i} {
			if {[$wout get "$i.0 lineend"] == ""} {
				$wout insert "$i.0 lineend" "\n"
			}
			set line [$win get $i.0 "$i.0 lineend"]
			set outline ""
			for {set j 0} { $j < $numcols} {incr j} {
				lappend outline [lindex $line $colarray($j)]
			}
			set outline [join $outline "\t"]
			$wout insert "$i.0 $place" "\t$outline"
		}
		return
	}
	if {[lindex [split [$wout index "end - 1 c"] .] 1] != 0} {
		$wout insert "end - 1 c" "\n"
	}
	for {set i 1} { $i <= $numlines} {incr i} {
		set line [$win get $i.0 "$i.0 lineend"]
		set outline ""
		for {set j 0} { $j < $numcols} {incr j} {
			lappend outline [lindex $line $colarray($j)]
		}
		set outline [join $outline "\t"]
		$wout insert end "\t$outline\n"
	}
	if { $mode == "replace"} {
		$wout delete 1.0 "prev_end + 1 c"
	}
	return
}

proc sketch_text_from_fd { w fd col mode } {
	if { ($col != "all") || ($mode == "left") || ($mode == "right")} {
		set mymode two
		set myw $w._ffd_scratch
		text $myw
	} else {
		#simple case, don't need intermediate buffer
		set mymode one
		set myw $w
		if {$mode == "replace"} {
			$w delete 1.0 end
		}
	}

	if {[lindex [split [$myw index "end - 1 c"] .] 1] != 0} {
		$myw insert "end - 1 c" "\n"
	}
	while { [gets $fd line] >= 0} {
		set line [join $line "\t"]
		$myw insert end "\t$line\n"
	}
	if { $mymode == "one" } {
		return 1
	}

	sketch_text_from_text $w $myw $col $mode
	destroy $myw
	return 2
}

#get number of rows in text widget, excluding vestigial rows on the end
proc sketch_text_rows {w} {
	set i [lindex [split [$w index end] .] 0]
	while { $i > 0 } {
		if { [$w index "$i.0 lineend"] != "$i.0" } break
		incr i -1
	}
	return $i
}

proc sketch_line_cols {line} {
	regsub -all \[\t\ \n\]+ $line \t res
	return [llength [split [string trim $res " \t\n"] "\t"]]
}

proc sketch_text_cols {w} {
	return [sketch_line_cols [$w get 1.0 "1.0 lineend"]]
}

proc sketch_rgb_clip { rgb } {
	while { [llength $rgb] < 3 } { lappend rgb "0" }
	for {set i 0} { $i < 3} { incr i} {
		set color [expr int([lindex $rgb $i])]
		if { $color < 0 } { 
			set color 0
		} elseif { $color > 255} {
			set color 255
		}
		lappend result $color
	}	
	return $result
}

proc sketch_rgb_to_hex { rgb {type no_pound}} {
	set rgb [sketch_rgb_clip $rgb]
	if {$type == "no_pound"} {
		return [format "%.2x%.2x%.2x" [lindex $rgb 0] \
				[lindex $rgb 1] [lindex $rgb 2]]
	} else {
		return [format "#%.2x%.2x%.2x" [lindex $rgb 0] \
				[lindex $rgb 1] [lindex $rgb 2]]
	}
}

proc sketch_rgb_inv { rgb } {
	set rgb [sketch_rgb_clip $rgb]
	foreach color $rgb {
		lappend result [expr 255 - $color]
	}
	return $result
}

proc sketch_hex_to_rgb { hex } {
	set hex [string trimleft $hex #]
	if { [string index $hex 1] != "x" } {
		set hex "0x$hex"
	}
	set blue [expr $hex%0x100]
	set green [expr ($hex-$blue)%0x10000]
	set red [expr ($hex-$green-$blue)%0x1000000]
	return [ list [expr $red/0x10000] [expr $green/0x100] [expr $blue]]
}

#Given table editor id, return corresponding text widget.
#If needcol is specified, check that widget has needcol columns.
proc sketch_text_from_table {tid {needcol -1}} {
	set text ""
	foreach ted [sketch_table_list] {
		if { [sketch_table_get_label $ted] == $tid } {
			set text $ted.t
			break
		}
	}
	if { $text  == ""} {
		tk_dialog ._sketch_msg {Couldn't find editor} \
		  "Couldn't find table editor $tid. \
		   (Text editor identifier must be an integer)." \
		  {} 0 {OK}
		return
	}
	#check number of columns
	set numcol [sketch_text_cols $text]
	if { ($needcol != -1) && ( $numcol != $needcol) } {
		tk_dialog ._sketch_msg {Wrong number of columns} \
		 "Table editor $tid has $numcol \
		  columns, but $needcol are required." {} 0 {OK}
		return
	}
	return $text
}


	
#-------------------------------------------------------------------
# Go
#-------------------------------------------------------------------
# Uncomment the following command in order to run the animator 
# automatically when anim.tcl is sourced.

proc animmate { id {p .} } {
    global mged_gui
    global ::tk::Priv

    if {[opendb] == ""} {
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "No database." \
		"No database has been opened!" info 0 OK
	return
    }

    sketch_popup_main $p
}

#animmate
@


1.31
log
@*** empty log message ***
@
text
@@


1.30
log
@Solid to Primitive naming convention conversions
@
text
@d4143 1
a4143 1
    global tkPriv
d4146 1
a4146 1
	cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "No database." \
@


1.30.4.1
log
@sync branch with HEAD
@
text
@d4143 1
a4143 1
    global ::tk::Priv
d4146 1
a4146 1
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "No database." \
@


1.30.6.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d4143 1
a4143 1
    variable ::tk::Priv
d4146 1
a4146 1
	cad_dialog $Priv(cad_dialog) $mged_gui($id,screen) "No database." \
@


1.30.6.2
log
@sync to HEAD...
@
text
@d4143 1
a4143 1
    global ::tk::Priv
d4146 1
a4146 1
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "No database." \
@


1.29
log
@*- change viewset to view
@
text
@d3848 1
a3848 1
	puts "Solid name is [vdraw read n]"
@


1.28
log
@*- convert to using vdraw's full
   subcommand names.
@
text
@d1363 1
a1363 1
		eval viewset $str
@


1.27
log
@*- use view instead of viewget
@
text
@d266 2
a267 2
	if { [vdraw o] } {
		sketch_open_curve [vdraw r n]
d271 1
a271 1
	set mged_sketch_splname "$mged_sketch_splprefix[vdraw r n]"
d281 1
a281 1
	foreach curve [vdraw v l] {
d290 1
a290 1
	set res [vdraw o $name]
d297 1
a297 1
		if { [vdraw r n] != "$name" } {
d299 1
a299 1
			puts "Warning: wanted $name got [vdraw r n]"
d304 1
a304 1
		set len [vdraw r l]
d326 1
a326 1
	upvar #0 [format "mged_sketch_time_%s" [vdraw r n]] tlist
d338 1
a338 1
	set mged_sketch_count [vdraw r l]
d342 1
a342 1
	upvar #0 [format "mged_sketch_time_%s" [vdraw r n]] tlist 
d350 2
a351 2
	set mged_sketch_color [sketch_hex_to_rgb [vdraw r c]]
	set mged_sketch_name  [vdraw r n]
d353 1
a353 1
	if { [vdraw s] < 0 } {
d400 2
a401 2
	set oldname [vdraw r n]
	set vertex [eval [concat vdraw r $mged_sketch_node]]
d406 1
a406 1
	vdraw s
d414 9
a422 9
	vdraw d a
	vdraw w n 0 [expr $v_x - $offset] $v_y $v_z
	vdraw w n 1 [expr $v_x + $offset] $v_y $v_z
	vdraw w n 0 $v_x [expr $v_y - $offset] $v_z
	vdraw w n 1 $v_x [expr $v_y + $offset] $v_z
	vdraw w n 0 $v_x $v_y [expr $v_z - $offset]
	vdraw w n 1 $v_x $v_y [expr $v_z + $offset]
	vdraw p c 0x00ffff
	vdraw s 
d439 1
a439 1
	set length [vdraw r l]
d441 1
a441 1
	upvar #0 "mged_sketch_time_[vdraw r n]" tlist
d443 1
a443 1
		eval vdraw w 0 0 $point
d454 3
a456 3
		eval vdraw i $newn 0 $point
		set vertex [vdraw r 1]
		eval vdraw w 1 1 [lrange $vertex 1 3]
d459 1
a459 1
		eval vdraw i $newn 1 $point
d462 1
a462 1
		eval vdraw i $newn 1 $point
d485 1
a485 1
		eval vdraw w $n 0 $point
d487 1
a487 1
		eval vdraw w $n 1 $point
d499 4
a502 4
	vdraw d $n
	if { ($n == 0) && ([vdraw r l] > 0) } {
		set vertex [vdraw r 0]
		eval [concat vdraw w 0 0 [lrange $vertex 1 3]]
d504 1
a504 1
	upvar #0 [format "mged_sketch_time_%s" [vdraw r n]] tlist
d541 1
a541 1
		set name [vdraw r n]
d551 2
a552 2
		set oldname [vdraw r n]
		vdraw o $name
d554 1
a554 1
		vdraw o $oldname
d564 2
a565 2
		[list "OK" "set oldname \[vdraw r n\]; \
			vdraw o \[._sketch_input.f0.e get\]; \
d567 1
a567 1
			vdraw o \$oldname; \
d580 3
a582 3
	vdraw p c [sketch_rgb_to_hex $color]
	vdraw s
	set mged_sketch_color [sketch_hex_to_rgb [vdraw r c]]
d594 1
a594 1
	set length [vdraw r l]
d608 1
a608 1
	upvar #0 [format "mged_sketch_time_%s" [vdraw r n]] tlist
d621 3
a623 3
	set oldname [vdraw r n]
	set oldcolor [sketch_hex_to_rgb [vdraw r c]]
	vdraw s
d625 1
a625 1
	vdraw d a
d628 2
a629 2
	#vdraw p c $oldcolor
	vdraw s
d640 1
a640 1
		[list "Name of Curve" [vdraw r n]] \
d658 1
a658 1
	vdraw d a
d663 1
a663 1
	set mged_sketch_splname "$mged_sketch_splprefix[vdraw r n]"
d671 1
a671 1
		[list "Name of Curve" [vdraw r n]] \
d695 1
a695 1
	set oldcurve [vdraw r n]
d698 1
a698 1
	sketch_write_to_fd $fd [vdraw r l]
d738 1
a738 1
	set mged_sketch_splname "$mged_sketch_splprefix[vdraw r n]"
d743 2
a744 2
	set oldname [vdraw r n]
	if { [catch {vdraw p n $name }] == 1 } {
d752 2
a753 2
			vdraw v d $name
			vdraw p n $name
d768 1
a768 1
		set mged_sketch_name [vdraw r n]
d776 1
a776 1
		vdraw p n $oldname
d782 2
a783 2
	set basename [vdraw r n]
	if { [vdraw o $name ] == 0 } {
d788 1
a788 1
			vdraw 0 $basename
d791 1
a791 1
			vdraw d a
d794 1
a794 1
	vdraw o $basename
d805 1
a805 1
		vdraw v d $name
d812 1
a812 1
		[list "Delete Curve:" [vdraw r n]] \
d825 4
a828 4
	vdraw v d $name
	catch {vdraw v d _sketch_hl_}
	if { [vdraw o] } {
		sketch_open_curve [vdraw r n]
d1698 1
a1698 1
		  set oldname [vdraw r n]
d1938 1
a1938 1
		foreach curve [vdraw v l] {
d2380 1
a2380 1
	set oldcurve [vdraw r n]
d2403 1
a2403 1
			set entries [list [list "Write to curve:" [vdraw r n]]]
d2439 1
a2439 1
	set oldcurve [vdraw r n]
d2713 2
a2714 2
			set oldcurve [vdraw r n]
			vdraw s
d2924 1
a2924 1
			sketch_write_to_fd $fd [vdraw r l]
d2983 1
a2983 1
		sketch_write_to_fd $fd [vdraw r l]
d3610 2
a3611 2
	if [vdraw o] {
		set oldname [vdraw r n]
d3616 2
a3617 2
		vdraw o $curve
		vdraw s
d3659 1
a3659 1
	upvar #0 [format "mged_sketch_time_%s" [vdraw r n]] tlist
d3664 1
a3664 1
			[lrange [vdraw r $i] 1 3] ]
d3670 1
a3670 1
	upvar #0 [format "mged_sketch_time_%s" [vdraw r n]] tlist
d3675 1
a3675 1
		vdraw w n 0 [lindex $line 1] [lindex $line 2] \
d3686 1
a3686 1
		vdraw w n 1 [lindex $line 1] [lindex $line 2] \
d3695 3
a3697 3
	if { ! [vdraw o] } { return }
	set length [vdraw r l]
	upvar #0 "mged_sketch_time_[vdraw r n]" tlist
d3700 1
a3700 1
		set temp [vdraw r $i]
d3719 1
a3719 1
	upvar #0 [format "mged_sketch_time_%s" [vdraw r n]] tlist
d3721 1
a3721 1
		vdraw d a
d3727 1
a3727 1
		vdraw w n 0 [lindex $line 1] [lindex $line 2] \
d3738 1
a3738 1
		vdraw w n 1 [lindex $line 1] [lindex $line 2] \
d3847 2
a3848 2
	set length [vdraw r l]
	puts "Solid name is [vdraw r n]"
d3850 1
a3850 1
		puts [vdraw r $i]
@


1.26
log
@*- mods requested by Eric regarding consistency
   when using capitalization in the GUI
@
text
@d163 3
a165 3
	button $root.b0 -text "Add" -command {sketch_add [viewget center] $mged_sketch_node}
	button $root.b1 -text "Insert" -command {sketch_insert [viewget center] $mged_sketch_node}
	button $root.b2 -text "Move" -command {sketch_move [viewget center] $mged_sketch_node}
d399 1
a399 1
	set offset [expr [viewget size] * 0.01]
d1249 1
a1249 1
		set new [join [viewget $cmd] "\t"]
d2546 1
a2546 1
			{set mged_sketch_objvsize [viewget size]}
d2550 1
a2550 1
			-command { set mged_sketch_eyecen [viewget eye] }
d2554 1
a2554 1
			-command { set mged_sketch_eyeori [viewget ypr] }
d2580 1
a2580 1
		-command { set mged_sketch_objcen [viewget center] }
d2584 1
a2584 1
		-command { set mged_sketch_objori [viewget ypr] }
d3108 1
a3108 1
			-command { set mged_sketch_objcen [viewget center] }
d3112 1
a3112 1
			-command { set mged_sketch_objori [viewget ypr] }
d3496 3
a3498 3
	uplevel #0 {set mged_sketch_prev_size [viewget size]}
	uplevel #0 {set mged_sketch_prev_center [viewget center]}
	uplevel #0 {set mged_sketch_prev_quat [viewget quat]}
d3587 3
a3589 3
	set mged_sketch_prev_size [viewget size]
	set mged_sketch_prev_center [viewget center]
	set mged_sketch_prev_quat [viewget quat]
@


1.25
log
@Use tkPriv(cad_dialog) for dialog name.
@
text
@d88 3
a90 3
	button $root.b0 -text "CURVE EDITOR" -command "sketch_popup_draw $root"
	button $root.b1 -text "VIEW EDITOR" -command "sketch_popup_view $root"
	menubutton $root.b2 -text "TABLE EDITOR" -menu $root.b2.m0
d92 2
a93 2
	$root.b2.m0 add command -label "New editor" -command "incr mged_sketch_table_index; sketch_popup_table $root \$mged_sketch_table_index"
	menubutton $root.b3 -text "CREATE SCRIPT" -menu $root.b3.m0
d98 3
a100 3
	button $root.b4 -text "COMBINE SCRIPTS" -command "sketch_popup_sort $root"
	button $root.b5 -text "SHOW SCRIPT" -command "sketch_popup_preview $root"
	button $root.b6 -text "QUIT" -command "sketch_quit $root"
d163 4
a166 4
	button $root.b0 -text "ADD" -command {sketch_add [viewget center] $mged_sketch_node}
	button $root.b1 -text "INSERT" -command {sketch_insert [viewget center] $mged_sketch_node}
	button $root.b2 -text "MOVE" -command {sketch_move [viewget center] $mged_sketch_node}
	button $root.b3 -text "DELETE" -command {sketch_delete $mged_sketch_node}
d178 2
a179 2
	#label  $root.f4.l0 -text "Current curve:"
	menubutton $root.f4.mb0 -text "Current curve:" -menu $root.f4.mb0.m
d207 1
a207 1
	$root.f2.mb0.m add cascade -label "Current curve" \
d209 1
a209 1
	$root.f2.mb0.m add cascade -label "Current spline" \
d225 1
a225 1
	label $root.f6.f0.l0 -text "into curve:"
d228 1
a228 1
	label $root.f6.f1.l0 -text "Frames per second:"
d237 3
a239 3
	$root.mb0.m0 add command -label "Read Curve From File" -command {sketch_popup_load}
	$root.mb0.m0 add command -label "Write Curve To File" -command {sketch_popup_save curve}
	$root.mb0.m0 add command -label "Write Spline To File" -command {sketch_popup_save spline}
d902 4
a905 4
	button $root.b0 -text "ADD" -command {sketch_vadd $mged_sketch_vnode}
	button $root.b1 -text "INSERT" -command {sketch_vinsert $mged_sketch_vnode}
	button $root.b2 -text "MOVE" -command {sketch_vmove $mged_sketch_vnode}
	button $root.b3 -text "DELETE" -command {sketch_vdelete $mged_sketch_vnode}
d911 1
a911 1
	checkbutton $root.cb0 -text "Apply current node to view" \
d920 2
a921 2
	#label  $root.f4.l0 -text "Current v-curve:"
	menubutton $root.f4.mb0 -text "Current v-curve:" -menu $root.f4.mb0.m
d923 1
a923 1
	$root.f4.mb0.m add command -label "New V-curve" \
d925 1
a925 1
	$root.f4.mb0.m add cascade -label "Open V-curve" \
d927 1
a927 1
	$root.f4.mb0.m add command -label "Rename V-curve" \
d931 1
a931 1
	$root.f4.mb0.m add cascade -label "Delete V-curve" \
d964 2
a965 2
	$root.mb0.m0 add command -label "Read V-curve From File" -command {sketch_popup_vload}
	$root.mb0.m0 add command -label "Write V-curve To File" -command {sketch_popup_vsave curve}
d1895 1
a1895 1
	$menu add command -label "to File" \
d1898 1
a1898 1
		$menu add command -label "to Curve" \
d1902 1
a1902 1
		$menu add command -label "to V-curve" \
d1928 1
a1928 1
	$menu add command -label "from File" \
d1933 1
a1933 1
			 -label "from editor [sketch_table_get_label $ted]" \
d1940 1
a1940 1
			  $menu add command -label "from curve $curve" \
d1948 1
a1948 1
			 "from v-curve [sketch_vcurve_get_label $ved]" \
d2096 1
a2096 1
	label ._sketch_col.fz.l1 -text "time" -width 20
d2152 1
a2152 1
	._sketch_col.fe.mb0.m0 add command -label "Periodic spline (src)" -command {set mged_sketch_table_interp cspline }
d2157 1
a2157 1
	._sketch_col.fe.mb0.m0 add command -label "Delete column" -command {set mged_sketch_table_interp delete}
d2533 1
a2533 1
	label $root.f0.l0 -text "Output file: "
d2544 2
a2545 2
		label $root.l$mode -text "CREATE VIEW ANIMATION"
		button $root.f2.l0 -text "View size:" -command \
d2549 1
a2549 1
		button $root.f9.b0 -text "Eye point:" \
d2553 1
a2553 1
		button $root.f10.b0 -text "Eye yaw,pitch,roll: " \
d2557 1
a2557 1
		checkbutton $root.cb0 -text "Read viewsize from source" \
d2566 2
a2567 2
		label $root.l$mode -text "CREATE OBJECT ANIMATION"
		label $root.f2.l0 -text "Object name:"
d2579 1
a2579 1
	button $root.f3.b0 -text "Object center:" \
d2583 1
a2583 1
	button $root.f4.b0 -text "Object yaw,pitch,roll: " \
d2590 1
a2590 1
	label $root.f5.l0 -text "First frame:"
d2601 1
a2601 1
	radiobutton $root.rb1 -text "Automatic steering" \
d2603 1
a2603 1
	radiobutton $root.rb2 -text "Automatic steering and banking" \
d2606 1
a2606 1
	label $root.f7.l0 -text "    maximum bank angle ="
d2608 1
a2608 1
	radiobutton $root.rb3 -text "Rotation specified as ypr" \
d2610 1
a2610 1
	radiobutton $root.rb4 -text "Rotation specified as quat" \
d2616 1
a2616 1
	label $root.f8.l1 -text "input columns needed:"
d3075 1
a3075 1
	label $root.l0 -text "CREATE TRACK ANIMATION"
d3077 1
a3077 1
	label $root.f0.l0 -text "Output file: "
d3080 1
a3080 1
	label $root.f1.l0 -text "Vehicle path from table: "
d3085 1
a3085 1
	radiobutton $root.f1a.r2 -text "Pos. and ypr" -variable mged_sketch_track_dist -value "-y"
d3087 1
a3087 1
	label $root.f2.l0 -text "Wheel specs from table: "
d3090 1
a3090 1
	label $root.fw.l0 -text "Wheel base name:"
d3093 1
a3093 1
	label $root.f4.l0 -text "Pad base name:"
d3096 1
a3096 1
	label $root.f5.l0 -text "Number of pads: "
d3101 1
a3101 1
	label $root.f3.l0 -text "track length:"
d3104 1
a3104 1
	button $root.f3a.b0 -text "Get track length from wheel specs" \
d3107 1
a3107 1
	button $root.f6.b0 -text "Vehicle center:" \
d3111 1
a3111 1
	button $root.f7.b0 -text "Vehicle yaw,pitch,roll: " \
d3115 1
a3115 1
	label $root.f8.l0 -text "First frame:"
d3118 1
a3118 1
	checkbutton $root.fa.cb -text "Create geometry file from frame:" -variable mged_sketch_track_geom
d3120 1
a3120 1
	checkbutton $root.cb0 -text "Enable anti-strobing" -variable mged_sketch_track_antistr
d3359 1
a3359 1
	label $root.l0 -text "COMBINE SCRIPTS"
d3376 1
a3376 1
	label $root.f2.l0 -text "Create script: "
d3527 1
a3527 1
	label $root.l0 -text "SHOW SCRIPT"
d3529 1
a3529 1
	label $root.f0.l0 -text "Script file: "
d3532 1
a3532 1
	label $root.f1.l0 -text "Max frames per second:"
d3536 1
a3536 1
	label $root.f2.l0 -text "Start frame: "
d3539 1
a3539 1
	label $root.f3.l0 -text "End frame: "
d3541 1
a3541 1
	checkbutton $root.cb0 -text "Polygon rendering" \
@


1.24
log
@*- check for open database
@
text
@d4143 1
d4146 1
a4146 1
	cad_dialog .$id.uncool $mged_gui($id,screen) "No database." \
@


1.24.2.1
log
@Use tkPriv(cad_dialog) for dialog name.
@
text
@a4142 1
    global tkPriv
d4145 1
a4145 1
	cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "No database." \
@


1.23
log
@*- mods to pop up widgets near the mouse
@
text
@d4141 10
a4150 2
proc animmate { {p .} } {
	sketch_popup_main $p
@


1.22
log
@Added some checks for mged objects.
@
text
@d86 1
d161 1
d900 1
d1729 1
d1961 1
d2092 1
d2541 1
d3073 1
d3357 1
d3525 1
d3858 1
@


1.21
log
@*- add optional argument to animmate proc so it
   can be called from MGED's default gui
*- a few updates
@
text
@d2697 5
d3249 6
d3260 6
@


1.20
log
@tinkering
@
text
@d17 4
d40 2
a41 1
	set version "developement"
d3555 1
a3555 1
	set vlist [mged_glob "dummy_cmd _VDRW*"]
d4113 2
a4114 2
proc animmate {} {
	sketch_popup_main
@


1.19
log
@added anti-strobing to track animation
@
text
@a31 4
	#hack
	uplevel #0 set mged_sketch_anim_path "/m/cad/.anim.6d/"
	#hack
	uplevel #0 set mged_sketch_tab_path "/m/cad/.tab.6d/"
d35 13
d94 1
a94 1
	button $root.b6 -text "QUIT ANIMATOR" -command "sketch_quit $root"
a130 1
	uplevel #0 set mged_sketch_fps "10"
d1657 3
d1780 3
d1784 3
a1786 3
		{"Start Speed:" "100%"} \
		{"End Speed:" "100%"} \
		{"Path Columns:" "1,2,3"} \
d1798 6
a1803 2
	global mged_sketch_temp1 mged_sketch_temp2 mged_sketch_anim_path

d2128 1
a2128 1
	entry ._sketch_col.fd.e0 -width 10
a2129 1
	._sketch_col.fd.e0 insert end "30"
a2235 1
	#set mged_sketch_table_lmode replace	
d2239 1
d3468 1
d3502 1
a3502 1
		-textvariable mged_sketch_fps
d3543 1
a3543 1
	upvar #0 mged_sketch_fps fps
d3606 2
a3607 2
	foreach var [info globals mged_sketch*] {
		#uplevel #0 "unset $var"
d4108 5
a4112 1
#sketch_popup_main
@


1.18
log
@minor features to track animation
@
text
@d8 1
a9 1
#	Table Editor
d87 1
a87 1
	pack $root.b0 $root.b1 $root.b2 $root.b3 $root.b4 \
d3016 1
d3085 1
d3097 1
a3097 1
		$root.f8 $root.fa $root.f9\
d3166 1
a3166 1
		mged_sketch_track_arced \
d3264 7
a3270 1
	set myargs "$lencmd $arccmd $mged_sketch_track_dist -b $ypr \
@


1.17
log
@major revision of track animation
@
text
@d3123 1
a3123 2
	bind $root.f1.e0 <Key-Return> "focus $root.f1a.e0"
	bind $root.f1a.e0 <Key-Return> "focus $root.f3.e0"
d3132 1
a3132 1
	bind $root.fa.e0 <Key-Return> "$root.f9.b0 invoke"
a3191 3
	set vtext \
	  [sketch_text_from_table $mged_sketch_track_vsrc $needcol]
	if { $vtext == "" } { return -1 }
d3193 15
d3253 1
a3253 1
		Fixed { set lencmd "-lf $tlen" }
d3271 3
@


1.16
log
@minor fixes
@
text
@d1648 1
d1977 2
a1978 1
		label ._sketch_col.fr$i.l0 -text "$col:" -width 10
d1989 2
a1990 2
		pack ._sketch_col.fr$i -side top
		pack ._sketch_col.fr$i.l0 ._sketch_col.fr$i.e0 -side left
d2058 1
d2066 1
a2066 1
	label ._sketch_col.fz.l0 -text "0:" -width 10
d2068 2
a2069 2
	pack ._sketch_col.fz -side top
	pack ._sketch_col.fz.l0 ._sketch_col.fz.l1 -side left
d2074 8
a2081 4
	menubutton ._sketch_col.mb0 -text "Choose Command" \
		-menu ._sketch_col.mb0.m0
	menu ._sketch_col.mb0.m0
	pack ._sketch_col.mb0 ._sketch_col.fa -side bottom -fill x -expand yes
d2084 1
d2113 3
a2115 1
	pack ._sketch_col.fa.b2 ._sketch_col.fa.b0 ._sketch_col.fa.b1 -side left
d2121 9
a2129 8
	._sketch_col.mb0.m0 add command -label "Step (src)" -command {sketch_interp_fill step i}
	._sketch_col.mb0.m0 add command -label "Linear (src)" -command {sketch_interp_fill linear i}
	._sketch_col.mb0.m0 add command -label "Spline (src)" -command {sketch_interp_fill spline i}
	._sketch_col.mb0.m0 add command -label "Periodic spline (src)" -command {sketch_interp_fill cspline i}
	._sketch_col.mb0.m0 add command -label "Quaternion (src)" -command {sketch_interp_fill quat i}
	._sketch_col.mb0.m0 add command -label "Rate (init) (incr/s)" -command {sketch_interp_fill rate }
	._sketch_col.mb0.m0 add command -label "Accel (init) (incr/s)" -command {sketch_interp_fill accel}
	._sketch_col.mb0.m0 add command -label "Next (src) (offset)" -command {sketch_interp_fill next}
d2246 3
a2248 1
		label ._sketch_col.fr$i.l0 -text "$col:" -width 10
d2259 2
a2260 2
		pack ._sketch_col.fr$i -side top
		pack ._sketch_col.fr$i.l0 ._sketch_col.fr$i.e0 -side left
d2264 25
d3006 10
a3015 6
	uplevel #0 {set mged_sketch_whlname ""}
	uplevel #0 {set mged_sketch_whlsource ""}
	uplevel #0 {set mged_sketch_lnkname ""}
	uplevel #0 set mged_sketch_numpads 1
	uplevel #0 set mged_sketch_radii "1"
	uplevel #0 {set mged_sketch_track_arced ""}
d3035 1
d3044 6
a3049 2
	label $root.f1.l0 -text "Vehicle path curve: "
	entry $root.f1.e0 -width 20 -textvariable mged_sketch_objsource
d3051 2
a3052 5
	label $root.f2.l0 -text "Wheel curve: "
	entry $root.f2.e0 -width 20 -textvariable mged_sketch_whlsource
	frame $root.f3
	label $root.f3.l0 -text "Radii of wheels (or common radius):"
	entry $root.f3.e0 -textvariable mged_sketch_radii
d3055 1
a3055 1
	entry $root.fw.e0 -width 20 -textvariable mged_sketch_whlname
d3058 1
a3058 1
	entry $root.f4.e0 -width 20 -textvariable mged_sketch_lnkname
d3061 9
a3069 1
	entry $root.f5.e0 -textvariable mged_sketch_numpads
d3082 2
a3083 2
	label $root.fa.l0 -text "Arced frame (arced script only):"
	entry $root.fa.e0 -width 20 -textvariable mged_sketch_track_arced
d3085 1
a3085 1
	button $root.f9.b0 -text "OK" -command {sketch_do_track $mged_sketch_objscript $mged_sketch_whlsource $mged_sketch_objsource $mged_sketch_objori $mged_sketch_objcen $mged_sketch_radii $mged_sketch_numpads $mged_sketch_lnkname}
d3091 3
a3093 3
	pack	$root.l0 $root.f0 $root.f1 $root.f2 \
		$root.f3 $root.fw \
		$root.f4 $root.f5 \
a3097 1

d3100 1
a3100 1
		$root.f3.l0 $root.fw.l0 \
d3103 2
a3104 1
		$root.f8.l0 $root.fa.l0 \
d3110 4
a3113 1
		$root.f6.e0 $root.f7.e0 $root.f8.e0 $root.fa.e0 \
d3123 3
a3125 3
	bind $root.f1.e0 <Key-Return> "focus $root.f2.e0"
	bind $root.f2.e0 <Key-Return> "focus $root.f3.e0"
	bind $root.f3.e0 <Key-Return> "focus $root.fw.e0"
d3128 2
a3129 1
	bind $root.f5.e0 <Key-Return> "focus $root.f6.e0"
d3132 2
a3133 1
	bind $root.f8.e0 <Key-Return> "$root.f9.b0 invoke"
d3138 17
d3156 2
a3157 2
proc sketch_do_track { outfile wcurve tcurve ypr center radius numpads \
								padname} {
d3159 15
a3173 3
		mged_sketch_track_arced

	upvar #0 mged_sketch_whlname wname
d3184 14
a3197 6
	set oldname [vdraw r n]
	if {[sketch_open_curve $wcurve] < 0} {
		sketch_open_curve $oldname
		return -1
	}
	set numwheels [vdraw r l]
d3199 3
a3201 3
		tk_dialog ._sketch_msg "Not enough wheels" "The curve $wcurve \
		has only $numwheels point(s). You must specify the position \
		of at least 2 wheels." {} 0 "OK"
d3204 1
d3210 2
a3211 2
	if { ($padname == "") || ($numpads == "") } {
		set lcmd ""
d3213 1
a3213 1
		set lcmd "-l $numpads $padname"
d3215 1
a3215 1
	if { ($lcmd == "") && ($wcmd == "") } {
d3221 1
a3221 9
	set rad 1
	for {set i 0} { $i < $numwheels} { incr i} {
		if {[llength $radius] > $i} {
			set rad [lindex $radius $i]
		}
		set node [vdraw r $i]
		puts $fd [list [lindex $node 1] [lindex $node 2] \
			[lindex $node 3] $rad]
	}
d3223 1
a3223 7
	sketch_open_curve $tcurve
	set len [vdraw r l]
	if { $len < 3 } {
		tk_dialog ._sketch_msg "Curve too short"	"The curve $tcurve \
		has only $len point(s). At least 3 are required." {} 0 "OK"
		return -1
	}
d3225 7
a3231 2
	while { [llength $center] < 3 } { lappend ypr 0}
	if { $mged_sketch_track_arced == "" } {
d3233 14
d3248 1
a3248 1
		set arccmd "-g $mged_sketch_track_arced"
d3250 8
a3257 3
	set fd [ open "| ${mged_sketch_anim_path}anim_hardtrack $arccmd -s -b $ypr \
		-d $center $wcmd $lcmd $mged_sketch_temp1 > $outfile" w]
	sketch_write_to_fd $fd $len
a3258 1
	sketch_open_curve $oldname
d4032 28
d4068 1
a4068 1
#sketch_main_window
@


1.15
log
@made buttons respond to mouse button 2. Restore previousbinding on exit
@
text
@d33 1
a33 1
	uplevel #0 set mged_sketch_anim_path "/m/cad/anim/"
d38 2
a39 1
	puts whosever
a40 1
	puts whatever
a41 1
	puts inever
d43 1
d47 1
a51 1
	puts younever
d580 2
a581 2
	if { $length < 3 } {
		puts {Need at least three vertices}
d584 4
d599 1
a599 1
	puts $fo "interp $mode 0 1 2;"
d2504 1
a2504 1
		checkbutton $root.cb2 -text "Relative Rotation" \
d2654 8
a2661 2
			set w $mged_sketch_vwidget.${mged_sketch_vprefix}$src.t
			if { [info commands $w ] == ""} {
d2670 8
a2677 2
			set w $mged_sketch_table_prefix$src.t
			if { [info commands $w ] == ""} {
@


1.14
log
@test
@
text
@d38 14
d90 1
d3450 9
@


1.13
log
@added arced button to track animation, fixed a couple of bugs
@
text
@d3 1
a3 1
# MGED.
@


1.12
log
@use scriptsort rather than anim_sort, added restore button
@
text
@d252 3
a254 4
		$menu add command -label $curve -command "$command $curve"
	}
	if { $function == "open" } {
		$menu delete _sketch_hl_
d2942 1
d2998 3
d3012 1
a3012 1
		$root.f8 $root.f9\
d3021 1
a3021 1
		$root.f8.l0 \
d3027 1
a3027 1
		$root.f6.e0 $root.f7.e0 $root.f8.e0 \
d3053 4
a3056 2
	global mged_sketch_temp1 mged_sketch_anim_path
	uplevel #0 mged_sketch_whlname wname
d3114 6
a3119 1
	set fd [ open "| ${mged_sketch_anim_path}anim_hardtrack -s -b $ypr \
@


1.11
log
@polishing, new anim_hardtrack syntax
@
text
@d32 1
d34 2
a35 1
	uplevel #0 set mged_sketch_tab_path "/m/cad/tab/"
d3143 1
d3213 1
a3213 1
	global mged_sketch_anim_path mged_sketch_sort_temp
d3230 1
a3230 1
	append cmd "cat "
d3232 1
a3232 1
		append cmd " $file"
d3234 2
a3235 4
	append cmd " > $mged_sketch_sort_temp"
	eval exec $cmd
	set pid [exec ${mged_sketch_anim_path}anim_sort \
		< $mged_sketch_sort_temp > $outfile &]
d3243 1
a3243 1
	set done "destroy $sortp.fa; exec rm $mged_sketch_sort_temp"
d3281 3
d3301 4
a3304 2
		$root.f0.e0 delete 0 end
		$root.f0.e0 insert end $filename
d3309 1
d3331 1
d3346 1
a3346 1
	pack $root.f4.b0 $root.f4.b1 $root.f4.b2 \
d3360 2
a3361 1
	global mged_sketch_prevs mged_sketch_preve
d3370 4
d3407 8
a3414 1

@


1.10
log
@view curves can be script source, polished
@
text
@d130 1
a130 1
	wm title $root "MGED curve editor"
d838 1
a838 1
	foreach dep {main text} {
d865 1
a865 1
	wm title $root "MGED view curve editor"
d2475 1
d2489 1
d2525 1
a2525 1
	radiobutton $root.rb5 -text "Eye-path and look-at path " \
d2813 2
d2936 1
d2939 1
a2939 1
	uplevel #0 set mged_sketch_numlinks 1
d2962 1
a2962 1
	wm title $root "MGED Track Animation"
d2976 3
d2980 1
a2980 1
	label $root.f4.l0 -text "Link path name:"
d2983 2
a2984 2
	label $root.f5.l0 -text "Number of links: "
	entry $root.f5.e0 -textvariable mged_sketch_numlinks
d2997 1
a2997 1
	button $root.f9.b0 -text "Create Script" -command {sketch_do_track $mged_sketch_objscript $mged_sketch_whlsource $mged_sketch_objsource $mged_sketch_objori $mged_sketch_objcen $mged_sketch_radii $mged_sketch_numlinks $mged_sketch_lnkname}
d2999 2
a3000 1
	button $root.f9.b2 -text "Cancel" -command "destroy $root"
d3003 2
a3004 2
	pack	$root.l0 $root.f0 $root.f1 \
		$root.f2 $root.f3 \
d3012 2
a3013 2
		$root.f0.l0 $root.f1.l0 \
		$root.f2.l0 $root.f3.l0 \
d3020 2
a3021 2
		$root.f0.e0 $root.f1.e0 $root.f2.e0\
		$root.f3.e0 $root.f4.e0 $root.f5.e0\
d3026 1
a3026 1
		$root.f9.b0 $root.f9.b1 $root.f9.b2 \
d3034 2
a3035 1
	bind $root.f3.e0 <Key-Return> "focus $root.f4.e0"
d3046 2
a3047 2
proc sketch_do_track { outfile wcurve tcurve ypr center radius numlinks \
								linkname} {
d3049 1
a3049 1

d3072 15
a3087 1
	puts $fd "$numwheels $numlinks"
d3108 1
a3108 1
		-d $center $linkname $mged_sketch_temp1 > $outfile" w]
d3160 2
a3161 1
	button $root.f2.b0 -text "OK" -command "sketch_sort $root \
d3164 3
a3166 1
	button $root.f2.b1 -text "Cancel" -command "destroy $root"
d3172 1
a3172 1
	bind $root.f2.e0 <Key-Return> "$root.f2.b0 invoke"
d3181 1
a3181 1
	pack $root.f2 -side bottom
d3189 4
a3192 2
	pack $root.f2.l0 $root.f2.e0 $root.f2.b0 \
	 	$root.f2.b1 -side left
d3239 1
a3239 1
	pack $sortp.fa -side bottom -before $sortp.f2
d3322 2
a3323 2
	button $root.f4.b1 -text "Cancel" \
		-command "destroy $root"
d3333 7
a3339 6
	pack $root.f0.l0 $root.f0.e0 \
		$root.f1.l0 $root.f1.e0 \
		$root.f2.l0 $root.f2.e0 \
		$root.f3.l0 $root.f3.e0 \
		$root.f4.b0 $root.f4.b1 \
		-side left -expand yes
@


1.9
log
@replaced APPEND with ADD, improved view curves
@
text
@d18 1
a18 1
# 1.> for each the main widget *foo*, the calling routine should call
d21 1
a21 1
#  {draw view text objanim track sort preview}
d42 1
a42 1
	sketch_init_text
d59 3
a61 1
	button $root.b2 -text "TABLE EDITOR" -command "sketch_popup_text $root"
d64 1
a64 1
	$root.b3.m0 add command -label "Object" -command "sketch_popup_objanim $root object"
d76 9
d857 1
a857 1
	set mged_sketch_vprefix "_v_"
d961 3
a963 5
		set any [lindex [info commands $prefix*.t] 0]
		set i [string length $prefix]
		set j [expr [string length $any] - 3]
		if { ($j<$i) } {
			# default
d966 1
a966 1
			set name [string range $any $i $j]
d972 2
a973 2
		sketch_popup_text_create $mged_sketch_vwidget \
			$mged_sketch_vprefix$name "View curve: $name" ro
d984 2
a985 2
	wm deiconify $prefix$name
	raise $prefix$name
a990 1
	global mged_sketch_vwidget mged_sketch_vprefix
a995 2
	set prefix $mged_sketch_vwidget.$mged_sketch_vprefix
	set i [string length $prefix]
d997 3
a999 7
	foreach str [info commands $prefix*.t] {
		set j [expr [string length $str] -3]
		if { $j >= $i } {
			set vcurve [string range $str $i $j]
			$menu add command -label $vcurve \
				-command "$command $vcurve"
		}
d1001 1
d1453 1
a1453 2
	set numcol [llength [split [gets $fd] \t]]
	incr numcol -1
d1570 2
a1571 4
	foreach ted [info commands $prefix*.t] {
		set j [expr [string length $ted] - 3]
		set name [string range $ted 0 $j]
		wm withdraw $name
d1597 21
a1617 1
		
d1622 1
a1622 1
proc sketch_init_text {} {
d1624 4
a1627 4
	uplevel #0 set mged_sketch_init_text 1
	uplevel #0 set mged_sketch_text_lmode "replace"
	uplevel #0 set mged_sketch_text_index 0
	uplevel #0 set mged_sketch_text_prefix ".text"
d1637 2
a1638 2
proc sketch_popup_text { p args } {
	global mged_sketch_text_prefix
d1641 1
a1641 1
		set root ".text" 
d1643 1
a1643 1
		set root "$p.text"
d1645 4
a1648 10
	upvar #0  mged_sketch_text_index index
	set z $index
	#puts "creating $root$z"
	set mged_sketch_text_prefix "$root"

	if { [info commands $root$z] == "" } {
		#create if not yet existing
		#puts "does not yet exist"
		sketch_popup_text_create $p text$z "Table editor $z" rw
		incr index
d1651 3
d1656 1
a1656 1
		empty {$root$z.t delete 1.0 end}
d1660 2
a1661 2
		  $root$z.t delete 1.0 end
		  sketch_text_echoc $root$z.t
d1665 1
a1665 1
		     $root$z.t replace }
d1667 2
a1668 2
		  $root$z.t delete 1.0 end
		  sketch_text_echoc $root$z.t
d1672 3
a1674 3
	#finish textbar initialization
	#$root$z.textbar insert 1.0 "\ttime(0)\tx(1)\ty(2)\tz(3)"
	sketch_text_bar_set $root$z.t $root$z.textbar 0.0
d1680 2
a1681 2
#mode	- rw (read/write) or ro (read only)
proc sketch_popup_text_create { p suffix label {mode rw}} {
d1690 3
d1698 2
a1699 2
	text $name.textbar -width 80 -height 1 -wrap none \
		-tabs {50 center 250 center 450 center 650 center}
d1707 1
a1707 1
	if { $mode == "rw" } {
d1709 3
a1711 3
		button $name.f0.b4 -text "Interpolate" -command "sketch_popup_text_interp $name.t $name.textbar"
		button $name.f0.b5 -text "Edit Columns" -command "sketch_popup_text_col $name.t $name.textbar"
		button $name.f0.b7 -text "Estimate Time" -command "sketch_popup_text_time $name.t"
d1720 1
a1720 1
	button $name.f0.b8 -text "Clone" -command "sketch_popup_text $p clone $name.t"
d1729 1
a1729 1
	if { $mode == "rw" } {
d1737 1
a1737 1
	pack $name.f1 $name.textbar $name.t\
d1741 1
a1741 1
	if { $mode == "ro" } {
d1747 1
a1747 44


proc sketch_popup_text_save { w } {
	set entries [list \
		{"Save to File:"} \
		{"Save which columns:" all} \
		]
	set buttons [list \
		[list  "OK" \
		  [concat sketch_text_save $w \
		    {[._sketch_input.f0.e get] [._sketch_input.f1.e get]}] ]\
		{"Cancel" "destroy ._sketch_input"} \
		]
	sketch_popup_input "Save Columns" $entries $buttons
}

proc sketch_popup_text_load { w } {
	global mged_sketch_text_lmode

	set entries [list \
		{"Load from file:"} \
		{"Load which columns:" all} \
		]
	set buttons [list \
		[list  "OK" "sketch_text_load $w \
		    \[._sketch_input.f0.e get\] \[._sketch_input.f1.e get\] \
			\$mged_sketch_text_lmode" ] \
		{"Cancel" "destroy ._sketch_input"} \
		]
	sketch_popup_input "Load Columns" $entries $buttons
	frame ._sketch_input.f3
	pack ._sketch_input.f3 -side bottom
	radiobutton ._sketch_input.f3.r0 -text "Replace" \
		-variable mged_sketch_text_lmode -value "replace"
	radiobutton ._sketch_input.f3.r1 -text "Append" \
		-variable mged_sketch_text_lmode -value "end"
	radiobutton ._sketch_input.f3.r2 -text "Add New Columns" \
		-variable mged_sketch_text_lmode -value "right"

	pack ._sketch_input.f3.r0 ._sketch_input.f3.r1 ._sketch_input.f3.r2 \
		-side left -fill x
}

proc sketch_popup_text_time { w } {
d1754 1
a1754 1
		[list  "OK" "sketch_text_time $w \
d1762 1
a1762 1
proc sketch_text_time {w v0 v1 cols } {
d1765 1
a1765 1
	#global mged_sketch_text_lmode
d1799 2
a1800 2
	#set temp $mged_sketch_text_lmode
	#set mged_sketch_text_lmode left
d1806 1
a1806 1
	#set mged_sketch_text_lmode $temp
d1812 1
a1812 1
	eval sketch_text_bar_set $w.t $w.textbar $args
d1817 12
a1828 19
proc sketch_text_bar_set { w wbar args } {
	set i [llength [split [$w get 1.0 "1.0 lineend"] "\t"]]
	set j [llength [split [$wbar get 1.0 "1.0 lineend"] "\t"]]
	if {$i > 0} {
		incr i -1
	}
	if {$j > 0} {
		incr j -1
	}
	while { $j < $i } {
		$wbar insert "1.0 lineend" "\t$j        "
		incr j
	}
	if { $j > $i } {
		set line [$wbar get 1.0 "1.0 lineend"]
		set newline [join [lrange [split $line "\t"] 0 $i] "\t"]
		#puts "barset $i $j $line $newline"
		$wbar delete 1.0 "1.0 lineend"
		$wbar insert 1.0 $newline
a1829 1
	
d1834 1
a1834 1
proc sketch_text_bar_reset { w } {
d1839 1
a1839 1
	if { [info commands $parent.textbar] == "" } {
d1842 1
a1842 1
	sketch_text_bar_set $w $parent.textbar [lindex [$w xview] 0]
d1859 19
d1882 2
a1883 3
	foreach ted [info commands *.text*.t] {
		set good [regsub {(.+\.text)([0-9]+)(\.t$)} $ted {\2} index]
		if { $good == 1 } {
d1885 2
a1886 2
			  -label "from editor $index" -command \
			  "sketch_popup_read $text text $ted"
d1898 4
a1901 11
		global mged_sketch_vwidget mged_sketch_vprefix
		set prefix $mged_sketch_vwidget.$mged_sketch_vprefix
		set i [string length $prefix]
		foreach ted [info commands $prefix*.t] {
			set j [expr [string length $ted] - 3]
			if { $j >= $i } {
				set vcurve [string range $ted $i $j]
				$menu add command \
				  -label "from v-curve $vcurve" -command \
				  "sketch_popup_read $text text $ted"
			}
d1906 1
a1906 1
proc sketch_popup_text_col {w wbar} {
d1908 2
a1909 2
	sketch_text_bar_reset $w
	#sketch_text_bar_set $w $wbar [lindex [$w xview] 0]
d1922 1
a1922 1
		set cmd [sketch_text_col_add $i $col $cmd old]
d1925 1
a1925 1
	#append cmd "; sketch_text_bar_reset $w; destroy ._sketch_col"
d1931 1
a1931 1
	button ._sketch_col.fa.b2 -text "Add Column" -command {sketch_text_col_add_one} 
d1946 1
a1946 1
proc sketch_text_col_add_one {} {
d1949 1
a1949 1
	set cmd [sketch_text_col_add $num $num $cmd new]
d1954 1
a1954 1
proc sketch_text_col_add { i col cmd flag } {
d1974 1
a1974 1
	sketch_text_bar_reset $w
d2035 1
a2035 1
proc sketch_popup_text_interp {w wbar}	{
d2037 1
a2037 1
	sketch_text_bar_reset $w
d2063 1
a2063 1
		set cmd [sketch_text_interp_add $i $col $cmd old]
d2066 1
a2066 1
	#append cmd "; sketch_text_bar_reset $w; destroy ._sketch_col"
d2072 1
a2072 1
	button ._sketch_col.fa.b2 -text "Add Column" -command {sketch_text_interp_add_one} 
d2116 1
a2116 1
	#global mged_sketch_text_lmode
d2188 1
a2188 1
	#set mged_sketch_text_lmode replace	
d2213 1
a2213 1
proc sketch_text_interp_add { i col cmd flag } {
d2231 1
a2231 1
proc sketch_text_interp_add_one {} {
d2236 1
a2236 1
	set cmd [sketch_text_interp_add $num $num $cmd new]
d2245 1
a2245 1
	sketch_text_bar_reset $w
d2250 1
a2250 1
	global mged_sketch_text_lmode
d2257 1
a2257 1
				\$mged_sketch_text_lmode"
d2263 1
a2263 1
				\$mged_sketch_text_lmode"
d2269 1
a2269 1
				\$mged_sketch_text_lmode; \
d2282 1
a2282 1
		-variable mged_sketch_text_lmode -value "replace"
d2284 1
a2284 1
		-variable mged_sketch_text_lmode -value "end"
d2286 1
a2286 1
		-variable mged_sketch_text_lmode -value "right"
d2302 1
a2302 1
	sketch_text_bar_reset $w
d2342 1
a2342 2
	set i [llength [split [$buffer get 1.0 "1.0 lineend"] "\t"]]
	incr i -1
d2369 1
a2369 2
	set numcol [llength [split [$w get 1.0 "1.0 lineend"] \t]]
	incr numcol -1
d2428 2
a2429 2
proc sketch_popup_objanim { p {mode object} } {

d2435 10
a2444 3
	if { [info commands $root] != ""} {
		catch {destroy $root}
	}
a2445 1

d2452 1
a2452 1
		"curve:" "editor:" "file:" 
d2456 2
a2457 2
		wm title $root "MGED View Animation"
		label $root.l0 -text "CREATE VIEW ANIMATION"
d2476 1
a2476 1
		wm title $root "MGED Object Animation"
d2478 1
a2478 1
		label $root.l0 -text "CREATE OBJECT ANIMATION"
d2504 4
a2507 3
	button $root.f6.b0 -text "Create Script" -command "sketch_objanim $mode"
	button $root.f6.b1 -text "Show Script" -command {sketch_popup_preview $mged_sketch_objscript}
	button $root.f6.b2 -text "Cancel" -command "destroy $root"
d2531 1
a2531 1
	pack	$root.l0 $root.f0 $root.f1 \
a2537 3



d2573 1
a2573 1
		$root.f6.b0 $root.f6.b1 $root.f6.b2 \
d2608 2
a2609 1
		mged_sketch_text_prefix
d2611 1
a2611 1
	upvar #0 mged_sketch_objsrctype type
d2615 48
a2662 1
	#test for valid source
d2664 1
a2664 4
	"spline:" {
		set type "curve:"
	}
	"curve:" {
a2668 9
			return
		}
		set oldcurve [vdraw r n]
		vdraw s
		set ret [sketch_open_curve $src]
		if {$ret != 0} {
			tk_dialog ._sketch_msg {Couldn't find curve} \
			  "Couldn't find curve $src." \
			  {} 0 {OK}
d2673 2
a2674 17
	"editor:" {
		set w ""
		foreach ed [info commands $mged_sketch_text_prefix*.t] {
			if { $ed == "$mged_sketch_text_prefix$src.t"} {
				set w "$mged_sketch_text_prefix$src.t"
				break
			}
		}
		if { $w == "" } {
			tk_dialog ._sketch_msg {Couldn't find editor} \
			  "Couldn't find table editor $src. \
			   (Text editor identifier must be an integer)." \
			  {} 0 {OK}
			return
		}
		set nsrc [llength [split [$w get 1.0 "1.0 lineend"] \t]]
		incr nsrc -1
d2693 1
a2693 1
	"file:" {
d2697 1
a2697 5
		set line "\t$line\t"
		set tab "\t"
		regsub -all "\[$tab \]+" $line "\t" res
		set nsrc [llength [split $res \t]] 
		incr nsrc -2
d2724 11
d2779 1
a2779 1
		if { $type == "curve:" } {
d2784 1
a2784 1
		} elseif { $type == "editor:" } {
d2791 1
a2791 1
		} elseif { $type == "file:" } {
d2813 1
a2813 1
		if { $type == "curve:" } {
d2818 1
a2818 1
		} elseif { $type == "editor:" } {
d2823 1
a2823 1
		} elseif { $type == "file:"} {
d2836 1
a2836 1
		if { $type == "curve:" } {
d2839 1
a2839 1
		} elseif { $type == "editor:" } {
d2841 1
a2841 1
		} elseif { $type == "file:"} {
d2862 1
a2862 1
	if { $type == "file:"} {
d2871 1
a2871 1
	} elseif { $type == "curve:" } {
d2878 1
a2878 1
	} elseif { $type == "editor:" } {
d2907 1
a2907 1
		set base "t ex ey ez lx ly lz"
d2990 1
a2990 1
	button $root.f9.b1 -text "Show Script" -command {sketch_popup_preview $mged_sketch_objscript}
d3041 9
d3188 10
d3490 1
a3490 1
	sketch_text_bar_reset $w
d3505 1
a3505 1
		sketch_parse_col $col [llength [$w get 1.0 "1.0 lineend"]] \
d3694 1
a3694 2
	set i [llength [split [$win get 1.0 "1.0 lineend"] "\t"]]
	sketch_parse_col $col [expr $i - 1] colarray
d3773 9
@


1.8
log
@added new view curve types
@
text
@d88 2
a89 1
	uplevel #0 set mged_sketch_tinc 1.0	
d120 3
a122 3
	button $root.b0 -text "APPEND" -command "sketch_append"
	button $root.b1 -text "INSERT" -command {sketch_insert $mged_sketch_node}
	button $root.b2 -text "MOVE" -command {sketch_move $mged_sketch_node}
d393 3
a395 4
#append current view center to current curve
proc sketch_append {} {
	global mged_sketch_node mged_sketch_count mged_sketch_tinc
	global mged_sketch_time
d397 3
a399 1
	set length [vdraw read length]
d401 6
a406 26
		set cmd 0
		upvar #0 [format "mged_sketch_time_%s" [vdraw r n]] tlist
		set mged_sketch_time 0.0
		set tlist $mged_sketch_time
	} else {
		set cmd 1
		upvar #0 [format "mged_sketch_time_%s" [vdraw r n]] tlist
		set mged_sketch_time [expr \
			[lindex $tlist [expr $mged_sketch_count - 1]] \
			+ $mged_sketch_tinc]
		lappend tlist $mged_sketch_time
		#puts $mged_sketch_time
	}
	set center [viewget center]
	#set center [viewget eye]
	set mged_sketch_node [vdraw r l]
	eval [concat vdraw w n $cmd $center]
	sketch_update
}

#insert current view center at specified node
proc sketch_insert { n } {
	global mged_sketch_tinc

	upvar #0 [format "mged_sketch_time_%s" [vdraw r n]] tlist
	if { $n == "" } {
d410 3
a412 2
	if { $n == 0 } {
		eval [concat vdraw i $n 0 [viewget center]]
d414 1
a414 1
		eval [concat vdraw w 1 1 [lrange $vertex 1 3]]
d416 3
d420 2
a421 3
		eval [concat vdraw i $n 1 [viewget center]]
		set tn [expr [lindex $tlist $n]+[lindex $tlist [expr $n - 1]]]
		set tn [expr $tn * 0.5]
d423 2
a424 1
	set tlist [linsert $tlist $n $tn]
d426 8
d437 1
a437 1
proc sketch_move { n } {
d443 1
a443 1
		eval [concat vdraw w $n 0 [viewget center]]
d445 1
a445 1
		eval [concat vdraw w $n 1 [viewget center]]
d749 3
a751 2
	text ._sketch_scratch
	sketch_text_echoc ._sketch_scratch
d753 2
a754 2
	sketch_text_apply ._sketch_scratch replace
	destroy ._sketch_scratch
d804 1
d855 1
a855 1
	button $root.b0 -text "APPEND" -command "sketch_vappend"
d864 3
d921 1
a921 1
		$root.f4 $root.f3 $root.f5 $root.f1 $root.f0 \
d943 2
a944 1
	global mged_sketch_vname mged_sketch_vparams mged_sketch_vwidget mged_sketch_vprefix
d965 2
d978 1
a978 1

d1157 1
a1157 1
proc sketch_vappend {} {
d1163 1
d1167 23
a1189 9
		set node $mged_sketch_vnode
		incr node 1
	} else {
		set node $mged_sketch_vnode
		incr node 1
		set mged_sketch_vtime [lindex [$text get \
		   "$node.0" "$node.0 lineend"] 0]
		set mged_sketch_vtime \
		   [expr $mged_sketch_vtime+$mged_sketch_vtinc]
a1190 1
	incr node 1
d1192 1
a1192 1
	$text insert "$node.0" [sketch_get_view_line nl]
d1194 3
a1196 1
	incr mged_sketch_vnode 1
d1198 5
a1202 1
	sketch_vupdate
d1205 2
a1206 2
proc sketch_get_view_line { {mode 0}} {
	global mged_sketch_vtime mged_sketch_vparams
d1208 1
a1208 1
	set line "\t$mged_sketch_vtime"
d1249 1
a1249 1
	$text insert "$n.0" [sketch_get_view_line] 			
d1256 1
a1256 1
proc sketch_vinsert { n } {
d1275 1
a1275 1
	$text insert "$n.0" [sketch_get_view_line nl] 			
d1285 1
a1285 1
		mged_sketch_vwidget mged_sketch_vprefix
d1311 14
a1324 7
	set i 1
	set str ""
	foreach cmd $mged_sketch_vparams {
		set cargs [lrange $line $i \
		   [expr $i + $mged_sketch_cmdlen($cmd) - 1] ]
		set str [concat $str $cmd $cargs]
		incr i $mged_sketch_cmdlen($cmd)
d1326 6
a1331 5
	if { $i != $len } {
		puts "sketch_vupdate: expected $i columns, got $len"
		return
	} 
	eval viewset $str
d1437 1
a1437 1
			\[._sketch_input.f2.e get\] \$mged_sketch_text_lmode"] \
a1440 11
	frame ._sketch_input.f3
	pack ._sketch_input.f3 -side bottom
	radiobutton ._sketch_input.f3.r0 -text "Replace" \
		-variable mged_sketch_text_lmode -value "replace"
	radiobutton ._sketch_input.f3.r1 -text "Append" \
		-variable mged_sketch_text_lmode -value "end"
	radiobutton ._sketch_input.f3.r2 -text "Add New Columns" \
		-variable mged_sketch_text_lmode -value "right"

	pack ._sketch_input.f3.r0 ._sketch_input.f3.r1 ._sketch_input.f3.r2 \
		-side left -fill x
d1443 1
a1443 1
proc sketch_vload { filename vcurve cols mode} {
d1465 1
a1465 1
	sketch_text_from_fd $text $fd $cols $mode
d2000 1
a2000 1
	set buffer $w._scratch_
d2316 5
a2320 4
	text $w._scratch_
	sketch_text_echoc $w._scratch_ 
	sketch_text_from_text $w $w._scratch_ $col $mode
	destroy $w._scratch_
d2359 4
a2362 4
	
	text $w._scratch_
	sketch_text_from_text $w._scratch_ $w $col append
	set i [llength [split [$w._scratch_ get 1.0 "1.0 lineend"] "\t"]]
d2365 1
a2365 1
		destroy $w._scratch_
d2371 1
a2371 1
		sketch_text_col_arith $w._scratch_ all {@@i @@0 @@1 @@2}
d2376 1
a2376 1
	sketch_text_apply $w._scratch_ replace
d2378 1
a2378 1
	destroy $w._scratch_
d3710 1
a3710 1
		set myw $w._scratch
@


1.7
log
@more polishing
@
text
@d32 2
a33 2
	uplevel #0 set mged_sketch_anim_dir "/m/cad/anim/"
	uplevel #0 set mged_sketch_tab_dir "/m/cad/tab/"
d554 1
a554 1
		mged_sketch_tab_dir
d571 1
a571 1
	set fo [open "| ${mged_sketch_tab_dir}tabinterp -q > $mged_sketch_temp1" w]
d682 1
a682 1
		sketch_popup_input "Curve Copy" {
d817 7
d841 2
a842 1
		mged_sketch_vparams mged_sketch_vwidget mged_sketch_vprefix
d901 4
a904 6
	$root.f3.mb0.m add command -label "{size eye quat}" \
		-command "sketch_set_vparams {size eye quat}"
	$root.f3.mb0.m add command -label "{size eye ypr}" \
		-command "sketch_set_vparams {size eye ypr}"
	$root.f3.mb0.m add command -label "{eye center}" \
		-command "sketch_set_vparams {eye center}"
d1004 2
a1005 2
		mged_sketch_temp1 mged_sketch_temp2 mged_sketch_anim_dir\
		mged_sketch_vwidget mged_sketch_vprefix
d1008 8
a1015 5
	switch $newlist {
		{size eye quat} -
		{size eye ypr} -
		{eye center} {}
		default {
a1016 1
		}
d1018 1
d1030 5
d1038 1
a1038 1
			set fd [open "| ${mged_sketch_anim_dir}anim_orient qv y \
d1050 1
a1050 1
			set fd [open "| ${mged_sketch_anim_dir}anim_lookat -y -v \
d1059 27
d1090 2
d1095 1
a1095 1
			set fd [open "| ${mged_sketch_anim_dir}anim_orient y qv \
d1106 1
a1106 2
			text $text._scratch_
			sketch_text_do_script $text $text._scratch_ all \
d1108 1
a1108 1
			set fd [open "| ${mged_sketch_anim_dir}anim_cascade \
d1110 1
a1110 1
			sketch_text_to_fd $text._scratch_ $fd all
a1111 1
			destroy $text._scratch_
d1118 24
d1147 1
d1457 2
a1458 2
		sketch_popup_input "View Curve Select" {
			{"V-curve to select:" ""}
d1463 2
a1464 2
	} elseif { ($mode == "rename") || ($mode == "copy") } {
		sketch_popup_input "View Curve Rename" {
d1471 8
d1637 1
a1637 1
	$root$z.textbar insert 1.0 "\ttime(0)\tx(1)\ty(2)\tz(3)"
d1671 2
a1672 2
		button $name.f0.b5 -text "Estimate Time" -command "sketch_popup_text_time $name.t"
		button $name.f0.b7 -text "Edit Columns" -command "sketch_popup_text_col $name.t $name.textbar"
d1767 1
a1767 1
	global mged_sketch_temp1 mged_sketch_temp2 mged_sketch_anim_dir
d1797 1
a1797 1
	set cmd "| ${mged_sketch_anim_dir}anim_time $arg0 $arg1 $arg2 > $mged_sketch_temp1"
d1938 1
d1987 1
a1987 1
	sketch_text_do_script $w $buffer $rows $arglist
d1995 1
a1995 1
#rows - number of rows to write (copies source length if rows not int >= 0)
d1998 2
a1999 2
# @@n refers to number of rows
proc sketch_text_do_script {win wout rows slist} {
d2005 2
a2006 1
			regsub -all {@@pi} $script 3.141592654 temp
d2116 1
a2116 1
	global mged_sketch_temp1 mged_sketch_temp2 mged_sketch_tab_dir
d2188 1
a2188 1
	set fd [open "| ${mged_sketch_tab_dir}tabinterp -q < $mged_sketch_temp2 " r]
d2605 1
a2605 1
		mged_sketch_temp1 mged_sketch_temp2 mged_sketch_anim_dir \
d2692 1
a2692 1
			set filecmd "${mged_sketch_anim_dir}chan_permute -i $src $incol -o stdout $outcol"
d2719 1
a2719 1
			set fd [open "| ${mged_sketch_anim_dir}anim_cascade \
d2748 1
a2748 1
		set anim_lookat ${mged_sketch_anim_dir}anim_lookat
d2756 1
a2756 1
			  ${mged_sketch_anim_dir}anim_script $opts $ovname > \
d2764 1
a2764 1
				  ${mged_sketch_anim_dir}anim_script $opts $ovname > \
d2768 1
a2768 1
				  ${mged_sketch_anim_dir}anim_script $opts $ovname > \
d2782 1
a2782 1
		set do_bank ${mged_sketch_anim_dir}anim_fly
d2804 1
a2804 1
			| ${mged_sketch_anim_dir}anim_script $opts $ovname > $mged_sketch_objscript
d2835 1
a2835 1
			eval exec ${mged_sketch_anim_dir}anim_script $opts $ovname < $src > \
d2838 1
a2838 1
			eval exec $filecmd | ${mged_sketch_anim_dir}anim_script $opts $ovname | \
d2843 1
a2843 1
		     [concat | ${mged_sketch_anim_dir}anim_script $opts $ovname > \
d2850 1
a2850 1
		     [concat | ${mged_sketch_anim_dir}anim_script $opts $ovname > \
d3008 1
a3008 1
	global mged_sketch_temp1 mged_sketch_anim_dir
d3044 1
a3044 1
	set fd [ open "| ${mged_sketch_anim_dir}anim_hardtrack -s -b $ypr \
d3142 1
a3142 1
	global mged_sketch_anim_dir mged_sketch_sort_temp
d3155 1
a3155 1
	set pid [exec ${mged_sketch_anim_dir}anim_sort \
d3690 1
a3690 1
		set myw $w._scratch_
@


1.6
log
@extensive polishing
@
text
@d1679 3
a1681 2
		{"Start Speed:" auto} \
		{"End Speed:" auto} \
d1685 2
a1686 1
		    \[._sketch_input.f0.e get\] \[._sketch_input.f1.e get\]"] \
d1692 1
a1692 1
proc sketch_text_time {w v0 v1} {
d1697 1
a1697 1
	if { ($v0 == "auto") || ($v0 == "") } {
d1700 6
a1705 1
		set arg0 "-s $v0"
d1707 1
a1707 1
	if { ($v1 == "auto") || ($v1 == "") } {
d1710 9
a1718 1
		set arg1 "-e $v1"
a1722 1
	#until new command is installed
d1726 2
a1727 1
	sketch_text_to_fd $w $f1 "0,1,2,3"
d1967 5
d1976 1
a1976 1
	menubutton ._sketch_col.mb0 -text "Choose Interpolator" \
d3294 1
@


1.5
log
@changed from vdraw c to vdraw v
@
text
@d1 1
a1 1
# ANIM.TCL
d14 1
a14 1
#	Quit Animator
d56 1
a56 1
	wm title $root "MGED Animator"
d77 5
d91 1
d106 1
a106 1
		mged_sketch_splname mged_sketch_defname
d137 3
a139 1
	$root.f4.mb0.m add command -label "Select Curve" -command {sketch_popup_name select}
d142 2
d145 7
d188 1
a188 1
	button $root.f8.b0 -text "Main Window" -command "raise $p"
a195 1
	$root.mb0.m0 add command -label "Delete Curve" -command {sketch_popup_delete_curve}
d227 1
a227 1
	set mged_sketch_splname "spl_[vdraw r n]"
d231 13
d258 1
a258 1
		set tname "mged_time_$name"
d283 1
a283 1
	upvar #0 [format "mged_time_%s" [vdraw r n]] tlist
d299 1
a299 1
	upvar #0 [format "mged_time_%s" [vdraw r n]] tlist 
d400 1
a400 1
		upvar #0 [format "mged_time_%s" [vdraw r n]] tlist
d405 1
a405 1
		upvar #0 [format "mged_time_%s" [vdraw r n]] tlist
d423 1
a423 1
	upvar #0 [format "mged_time_%s" [vdraw r n]] tlist
d468 1
a468 1
	upvar #0 [format "mged_time_%s" [vdraw r n]] tlist
d498 5
a502 2
	if {$color == "other"} { set color ""}
	set name ""
d506 1
a506 2
	} 
	if { $type == "spline" } {
d508 13
d568 1
a568 1
	upvar #0 [format "mged_time_%s" [vdraw r n]] tlist
d586 1
a586 1
	set num_read [sketch_append_from_fd $fi]
d612 1
a612 1
	global mged_sketch_splname
d619 1
a619 1
	sketch_append_from_fd $fd
d623 1
a623 1
	set mged_sketch_splname "spl_[vdraw r n]"
d628 2
d641 1
a641 1
		._sketch_input.f0.e insert 0 spl_
d666 4
a669 4
proc sketch_popup_name {{mode select}} {
	if { $mode == "select"} {
		sketch_popup_input "Curve Select" {
			{"Curve to select:" ""}
d675 1
a675 1
		sketch_popup_input "Curve Rename" {
d692 1
a692 1
	global mged_sketch_splname
d698 1
a698 1
	set mged_sketch_splname "spl_[vdraw r n]"
d702 1
a702 1
	global mged_sketch_splname
d719 3
a721 3
	upvar #0 "mged_time_$oldname" oldtime
	uplevel #0 "append mged_time_$name {}"
	upvar #0 "mged_time_$name" newtime
d732 1
a732 1
		set mged_sketch_splname "spl_$mged_sketch_name"
a783 1
	puts "deleting $name"
d791 1
a791 1
	uplevel #0 "set mged_time_$name {}"
d797 1
a797 1
# View Editor
d799 7
d869 17
a885 3
	$root.f4.mb0.m add command -label "Select V-curve" -command {sketch_popup_vname select}
	$root.f4.mb0.m add command -label "Rename V-curve" -command {sketch_popup_vname rename}
	$root.f4.mb0.m add command -label "Copy V-Curve" -command {sketch_popup_vname copy}
d907 1
a907 1
	button $root.f8.b0 -text "Main Window" -command "raise $p"
a913 1
	$root.mb0.m0 add command -label "Delete V-curve" -command {sketch_popup_delete_vcurve}
d958 1
a958 1
			$mged_sketch_vprefix$name $name ro
d973 22
d1437 1
a1437 1
	sketch_text_from_text $otext $ntext all replace
d1540 1
a1540 1
		sketch_popup_text_create $p text$z $z
d1567 4
d1579 1
a1579 1
	wm title $name "MGED Animator table editor $label"
d1592 1
a1592 1
	label $name.f1.l0 -text "Table editor $label"
d1599 1
d1608 1
a1608 1
	button $name.f0.b9 -text "Main" -command "raise $p"
d1687 1
a1687 1
	sketch_popup_input "Load Columns" $entries $buttons
d1784 2
a1785 5
	$menu add command -label "from File" -command "sketch_popup_read $text file"
	if { [info globals mged_sketch_init_draw] != "" } {
		$menu add command -label "from Curve" \
			-command "sketch_popup_read $text curve"
	}
d1791 9
a1799 1
			  "sketch_popup_read $text $ted"
d1812 1
a1812 1
				  "sketch_popup_read $text $ted"
a1817 2


a1818 1
	
d1825 1
d1951 1
d2154 1
a2154 1
proc sketch_popup_read {w src} {
d2156 1
a2156 1
	switch $src {
d2165 2
a2166 2
			set entries [list [list "Curve to read:" [vdraw r n]]]
			set okcmd "sketch_text_readc $w \
a2167 1
				\[._sketch_input.f1.e get\] \
d2169 1
a2169 3
		
}
		#else text-text
d2172 1
a2172 1
			set okcmd "sketch_text_from_text $src $w \
d2203 1
a2203 1
	sketch_text_from_text $w._scratch_ $w $col $mode
d2245 1
a2245 1
	sketch_text_from_text $w $w._scratch_ $col append
d2288 1
a2288 1
	sketch_text_from_text $w $text $col replace
d2737 1
a2737 1
		puts "filecmd = $filecmd src = $src"
d3238 2
a3239 1
	upvar #0 [format "mged_time_%s" [vdraw r n]] tlist
d3248 2
a3249 2
proc sketch_append_from_fd { fd } {
	upvar #0 [format "mged_time_%s" [vdraw r n]] tlist
d3275 2
a3276 1
	upvar #0 [format "mged_time_%s" [vdraw r n]] tlist
d3297 1
a3297 1
	upvar #0 [format "mged_time_%s" [vdraw r n]] tlist
d3501 1
a3501 1
proc sketch_text_from_text { win wout col mode {rows all}} {
d3615 1
a3615 1
	sketch_text_from_text $myw $w $col $mode
@


1.4
log
@switched from vget to viewget
@
text
@d666 1
a666 1
			vdraw c d $name
d718 1
a718 1
		vdraw c d $name
d739 2
a740 2
	vdraw c d $name
	catch {vdraw c d _sketch_hl_}
@


1.3
log
@modified so that various widgets can be called independently
@
text
@d327 1
a327 1
	set offset [expr [vget size] * 0.01]
d383 2
a384 2
	set center [vget center]
	#set center [vget eye]
d400 1
a400 1
		eval [concat vdraw i $n 0 [vget center]]
d405 1
a405 1
		eval [concat vdraw i $n 1 [vget center]]
d420 1
a420 1
		eval [concat vdraw w $n 0 [vget center]]
d422 1
a422 1
		eval [concat vdraw w $n 1 [vget center]]
d1035 1
a1035 1
		set new [join [vget $cmd] "\t"]
d2266 1
a2266 1
			{set mged_sketch_objvsize [vget size]}
d2270 1
a2270 1
			-command { set mged_sketch_eyecen [vget eye] }
d2274 1
a2274 1
			-command { set mged_sketch_eyeori [vget ypr] }
d2298 1
a2298 1
		-command { set mged_sketch_objcen [vget center] }
d2302 1
a2302 1
		-command { set mged_sketch_objori [vget ypr] }
d2760 1
a2760 1
			-command { set mged_sketch_objcen [vget center] }
d2764 1
a2764 1
			-command { set mged_sketch_objori [vget ypr] }
@


1.2
log
@first little bugs
@
text
@d17 9
d29 1
a29 24
proc sketch_main_window {} {
	sketch_init_globals
	catch {destroy .sketch}

	toplevel .sketch
	wm title .sketch "MGED Animator"
	button .sketch.b0 -text "CURVE EDITOR" -command "sketch_popup_draw"
	button .sketch.b1 -text "VIEW EDITOR" -command "sketch_popup_view"
	button .sketch.b2 -text "TABLE EDITOR" -command "sketch_popup_text"
	menubutton .sketch.b3 -text "CREATE SCRIPT" -menu .sketch.b3.m0
	menu .sketch.b3.m0 -tearoff 0
	.sketch.b3.m0 add command -label "Object" -command "sketch_popup_objanim object"
	.sketch.b3.m0 add command -label "View" -command "sketch_popup_objanim view"
	.sketch.b3.m0 add command -label "Articulated Track" -command "sketch_popup_track_anim"
	button .sketch.b4 -text "COMBINE SCRIPTS" -command "sketch_popup_sort"
	button .sketch.b5 -text "SHOW SCRIPT" -command "sketch_popup_preview"
	button .sketch.b6 -text "QUIT ANIMATOR" -command "sketch_quit"

	pack .sketch.b0 .sketch.b1 .sketch.b2 .sketch.b3 .sketch.b4 \
		.sketch.b5 .sketch.b6 \
		-side left -fill x -expand yes
}

proc sketch_init_globals {} {
d31 1
d36 42
a77 1
	uplevel #0 set mged_sketch_sort_temp "./_mged_sketch_sort_"
d79 1
d89 6
a94 49
	#view curve
	uplevel #0 set mged_sketch_vnode 0		
	uplevel #0 set mged_sketch_vcount 0		
	uplevel #0 set mged_sketch_vtime 0.0	
	uplevel #0 set mged_sketch_vtinc 1.0	
	uplevel #0 {set mged_sketch_vname ""}
	uplevel #0 {set mged_sketch_vparams {size eye quat}}
	uplevel #0 set mged_sketch_cmdlen(quat) 4
	uplevel #0 set mged_sketch_cmdlen(eye) 3
	uplevel #0 set mged_sketch_cmdlen(center) 3
	uplevel #0 set mged_sketch_cmdlen(ypr) 3
	uplevel #0 set mged_sketch_cmdlen(aet) 3
	uplevel #0 set mged_sketch_cmdlen(size) 1
	# object animation
	uplevel #0 set mged_sketch_objorv "object"
	uplevel #0 set mged_sketch_objname "/foo.r"
	uplevel #0 set mged_sketch_objvsize "500"
	uplevel #0 {set mged_sketch_objcen "0 0 0"}
	uplevel #0 {set mged_sketch_objori "0 0 0"}
	uplevel #0 {set mged_sketch_eyecen "0 0 0"}
	uplevel #0 {set mged_sketch_eyeori "0 0 0"}
	uplevel #0 {set mged_sketch_objsteer ""}
	uplevel #0 set mged_sketch_objopt "none"
	uplevel #0 set mged_sketch_objmang "60"
	uplevel #0 {set mged_sketch_objlaf ""}
	uplevel #0 {set mged_sketch_objdisp ""}
	uplevel #0 {set mged_sketch_objrot ""}
	uplevel #0 set mged_sketch_objframe "0"
	uplevel #0 set mged_sketch_objscript "foo.script"
	uplevel #0 set mged_sketch_objsrctype "curve:"
	uplevel #0 set mged_sketch_objsource "foo"
	uplevel #0 set mged_sketch_objcname "foo"
	uplevel #0 set mged_sketch_objfname "foo.table"
	uplevel #0 set mged_sketch_objrv 0
	uplevel #0 set mged_sketch_objrotonly 0
	uplevel #0 set mged_sketch_objncols 4
	uplevel #0 {set mged_sketch_objcols "t x y z"}
	# preview script
	uplevel #0 {set mged_sketch_prevs ""}
	uplevel #0 {set mged_sketch_preve ""}
	uplevel #0 {set mged_sketch_prevp ""}
	#table editor
	uplevel #0 set mged_sketch_text_lmode "replace"
	uplevel #0 set mged_sketch_text_index 0
	#track animation
	uplevel #0 {set mged_sketch_whlsource ""}
	uplevel #0 {set mged_sketch_lnkname ""}
	uplevel #0 set mged_sketch_numlinks 1
	uplevel #0 set mged_sketch_radii "1"
d97 1
a97 4
#-----------------------------------------------------------------
# Curve Editor
#-----------------------------------------------------------------
proc sketch_popup_draw {} {
d102 78
a179 73
	if { [info commands .sketch.draw] != ""} {
		raise .sketch.draw
		return
	}
	toplevel .sketch.draw
	wm title .sketch.draw "MGED curve editor"
	button .sketch.draw.b0 -text "APPEND" -command "sketch_append"
	button .sketch.draw.b1 -text "INSERT" -command {sketch_insert $mged_sketch_node}
	button .sketch.draw.b2 -text "MOVE" -command {sketch_move $mged_sketch_node}
	button .sketch.draw.b3 -text "DELETE" -command {sketch_delete $mged_sketch_node}
	frame  .sketch.draw.f1
	label  .sketch.draw.f1.l0 -text "Node "
	label  .sketch.draw.f1.l1 -textvariable mged_sketch_node
	label  .sketch.draw.f1.l2 -text " of "
	label  .sketch.draw.f1.l3 -textvariable mged_sketch_count
	frame  .sketch.draw.f0 
	button .sketch.draw.f0.b4 -text "-->" -command {sketch_incr 10}
	button .sketch.draw.f0.b40 -text "->" -command {sketch_incr 1}
	button .sketch.draw.f0.b50 -text "<-" -command {sketch_incr -1}
	button .sketch.draw.f0.b5 -text "<--" -command {sketch_incr -10}
	frame  .sketch.draw.f4
	#label  .sketch.draw.f4.l0 -text "Current curve:"
	menubutton .sketch.draw.f4.mb0 -text "Current curve:" -menu .sketch.draw.f4.mb0.m
	menu .sketch.draw.f4.mb0.m -tearoff 0
	.sketch.draw.f4.mb0.m add command -label "Select Curve" -command {sketch_popup_name select}
	.sketch.draw.f4.mb0.m add command -label "Rename Curve" -command {sketch_popup_name rename}
	.sketch.draw.f4.mb0.m add command -label "Copy Curve" -command {sketch_popup_name copy}

	label  .sketch.draw.f4.l1 -textvariable mged_sketch_name

	frame  .sketch.draw.f5
	label  .sketch.draw.f5.l0 -text "Time:"
	entry  .sketch.draw.f5.e0 -width 8 -textvariable mged_sketch_time
	bind   .sketch.draw.f5.e0 <Key-Return> { sketch_time_set [.sketch.draw.f5.e0 get]}

	frame  .sketch.draw.f2
	#label .sketch.draw.f2.l0 -text "Color:"
	menubutton .sketch.draw.f2.mb0 -text "Color:" -menu .sketch.draw.f2.mb0.m
	menu .sketch.draw.f2.mb0.m -tearoff 0
	.sketch.draw.f2.mb0.m add cascade -label "Current curve" \
		-menu .sketch.draw.f2.mb0.m.m0
	.sketch.draw.f2.mb0.m add cascade -label "Current spline" \
		-menu .sketch.draw.f2.mb0.m.m1
	.sketch.draw.f2.mb0.m add cascade -label "Other" \
		-menu .sketch.draw.f2.mb0.m.m2
	menu .sketch.draw.f2.mb0.m.m0 -tearoff 0
	menu .sketch.draw.f2.mb0.m.m1 -tearoff 0
	menu .sketch.draw.f2.mb0.m.m2 -tearoff 0
	sketch_add_color_menu .sketch.draw.f2.mb0.m.m0 current
	sketch_add_color_menu .sketch.draw.f2.mb0.m.m1 spline
	sketch_add_color_menu .sketch.draw.f2.mb0.m.m2 other
	entry .sketch.draw.f2.e0 -width 12 -textvariable mged_sketch_color
	bind  .sketch.draw.f2.e0 <Key-Return> { sketch_color [.sketch.draw.f2.e0 get]}
	frame .sketch.draw.f6 -relief groove -bd 3
	button .sketch.draw.f6.b0 -text "Spline Interpolate" -command {sketch_do_spline spline}
	button .sketch.draw.f6.b1 -text "Cspline Interpolate" -command {sketch_do_spline cspline}
	frame .sketch.draw.f6.f0
	label .sketch.draw.f6.f0.l0 -text "into curve:"
	entry .sketch.draw.f6.f0.e0 -width 15 -textvariable mged_sketch_splname
	frame  .sketch.draw.f6.f1
	label .sketch.draw.f6.f1.l0 -text "Frames per second:"
	entry .sketch.draw.f6.f1.e0 -width 4 -textvariable mged_sketch_fps
	bind  .sketch.draw.f6.f1.e0 <Key-Return> { focus .sketch.draw }
	frame .sketch.draw.f8
	button .sketch.draw.f8.b0 -text "Main Window" -command "raise .sketch"
	button .sketch.draw.f8.b1 -text "Cancel" -command "destroy .sketch.draw"

	menubutton .sketch.draw.mb0 -text "Read/Write" -menu .sketch.draw.mb0.m0
	menu .sketch.draw.mb0.m0
	.sketch.draw.mb0.m0 add command -label "Read Curve From File" -command {sketch_popup_load}
	.sketch.draw.mb0.m0 add command -label "Write Curve To File" -command {sketch_popup_save curve}
	.sketch.draw.mb0.m0 add command -label "Write Spline To File" -command {sketch_popup_save spline}
	.sketch.draw.mb0.m0 add command -label "Delete Curve" -command {sketch_popup_delete_curve}
d182 6
a187 6
		.sketch.draw.f4 .sketch.draw.f5 .sketch.draw.f1 .sketch.draw.f0 \
		.sketch.draw.b0 .sketch.draw.b1 .sketch.draw.b2 .sketch.draw.b3 \
		.sketch.draw.f2 \
		.sketch.draw.f6 \
		.sketch.draw.mb0 \
		.sketch.draw.f8	\
d190 2
a191 2
		.sketch.draw.f6.b0 .sketch.draw.f6.b1 \
		.sketch.draw.f6.f0 .sketch.draw.f6.f1 \
d193 3
a195 3
	pack .sketch.draw.f6.f0.l0 .sketch.draw.f6.f0.e0 \
		.sketch.draw.f6.f1.l0 .sketch.draw.f6.f1.e0 \
		.sketch.draw.f8.b0 .sketch.draw.f8.b1 \
d197 1
a197 1
	pack .sketch.draw.f0.b4 .sketch.draw.f0.b40 .sketch.draw.f0.b50 .sketch.draw.f0.b5 \
d199 4
a202 4
	pack .sketch.draw.f1.l0 .sketch.draw.f1.l1 .sketch.draw.f1.l2 .sketch.draw.f1.l3 \
		.sketch.draw.f2.mb0 .sketch.draw.f2.e0 \
		.sketch.draw.f4.mb0 .sketch.draw.f4.l1 \
		.sketch.draw.f5.l0 .sketch.draw.f5.e0 \
d220 1
a220 1
		tk_dialog .sketch.msg {Couldn't open curve} \
d258 1
a258 1
	focus .sketch
d282 1
a282 1
		tk_dialog .sketch.msg {Can't display curve} \
d485 2
a486 2
			vdraw o \[.sketch.input.f0.e get\]; \
			sketch_color \[.sketch.input.f1.e get \]; \
d489 2
a490 2
			destroy .sketch.input"] \
		{"Cancel" "destroy .sketch.input"} \
d503 1
a503 1
	catch {focus .sketch.draw}
d559 3
a561 3
		{"OK" {sketch_load [.sketch.input.f0.e get] \
				[.sketch.input.f1.e get]} } \
		{"Cancel" "destroy .sketch.input"} \
d577 1
a577 1
	catch {destroy .sketch.input}
d589 3
a591 3
		{"OK" {sketch_save [.sketch.input.f0.e get] \
				[.sketch.input.f1.e get]} }\
		{"Cancel" "destroy .sketch.input"} \
d595 1
a595 1
		.sketch.input.f0.e insert 0 spl_
d602 1
a602 1
		set ans [tk_dialog .sketch.msg {File Exists} \
d615 1
a615 1
	catch {destroy .sketch.input}
d625 2
a626 2
			{"OK" {sketch_name [.sketch.input.f0.e get]}}
			{"Cancel" "destroy .sketch.input"}
d632 2
a633 2
			[list "OK" "sketch_rename \[.sketch.input.f0.e get\]" ] \
			{"Cancel" "destroy .sketch.input"} \
d639 2
a640 2
			[list "OK" "sketch_copy \[.sketch.input.f0.e get\]" ] \
			{"Cancel" "destroy .sketch.input"} \
d650 1
a650 1
	catch {destroy .sketch.input}
d658 3
a660 3
	set res [vdraw p n $name]
	if { $res < 0 } {
		set ans [tk_dialog .sketch.msg {Curve exists} \
d677 1
a677 1
	#sketch_update will fail if name conflicts
d679 1
a679 1
		catch {destroy .sketch.input}
d697 2
a698 3
	set res [vdraw o $name]
	if { $res == 0 } {
		set ans [tk_dialog .sketch.msg {Curve exists} \
d702 1
d709 2
a710 2
	text .sketch._scratch_
	sketch_text_echoc .sketch._scratch_
d712 2
a713 2
	sketch_text_apply .sketch._scratch_ replace
	destroy .sketch._scratch_
d715 1
a715 1
		catch {destroy .sketch.input}
d728 3
a730 3
		{ "OK" {sketch_delete_curve [.sketch.input.f0.e get]; \
				destroy .sketch.input} } \
		{ "Cancel" "destroy .sketch.input" } \
d754 26
a779 1
proc sketch_popup_view {} {
d782 1
a782 1
		mged_sketch_vparams
d784 44
a827 36
	if { [info commands .sketch.view] != ""} {
		wm deiconify .sketch.view
		raise .sketch.view
		return
	}
	toplevel .sketch.view
	wm title .sketch.view "MGED view curve editor"
	button .sketch.view.b0 -text "APPEND" -command "sketch_vappend"
	button .sketch.view.b1 -text "INSERT" -command {sketch_vinsert $mged_sketch_vnode}
	button .sketch.view.b2 -text "MOVE" -command {sketch_vmove $mged_sketch_vnode}
	button .sketch.view.b3 -text "DELETE" -command {sketch_vdelete $mged_sketch_vnode}
	frame  .sketch.view.f1
	label  .sketch.view.f1.l0 -text "Node "
	label  .sketch.view.f1.l1 -textvariable mged_sketch_vnode
	label  .sketch.view.f1.l2 -text " of "
	label  .sketch.view.f1.l3 -textvariable mged_sketch_vcount
	frame  .sketch.view.f0 
	button .sketch.view.f0.b4 -text "-->" -command {sketch_vincr 10}
	button .sketch.view.f0.b40 -text "->" -command {sketch_vincr 1}
	button .sketch.view.f0.b50 -text "<-" -command {sketch_vincr -1}
	button .sketch.view.f0.b5 -text "<--" -command {sketch_vincr -10}
	frame  .sketch.view.f4
	#label  .sketch.view.f4.l0 -text "Current v-curve:"
	menubutton .sketch.view.f4.mb0 -text "Current v-curve:" -menu .sketch.view.f4.mb0.m
	menu .sketch.view.f4.mb0.m -tearoff 0
	.sketch.view.f4.mb0.m add command -label "Select V-curve" -command {sketch_popup_vname select}
	.sketch.view.f4.mb0.m add command -label "Rename V-curve" -command {sketch_popup_vname rename}
	.sketch.view.f4.mb0.m add command -label "Copy V-Curve" -command {sketch_popup_vname copy}

	button  .sketch.view.f4.l1 -textvariable mged_sketch_vname \
		-command {wm deiconify .sketch.view._v_$mged_sketch_vname; \
				raise .sketch.view._v_$mged_sketch_vname}
	frame .sketch.view.f3
	menubutton .sketch.view.f3.mb0 -text "Parameters:" -menu .sketch.view.f3.mb0.m
	menu .sketch.view.f3.mb0.m -tearoff 0
	.sketch.view.f3.mb0.m add command -label "{size eye quat}" \
d829 1
a829 1
	.sketch.view.f3.mb0.m add command -label "{size eye ypr}" \
d831 1
a831 1
	.sketch.view.f3.mb0.m add command -label "{eye center}" \
d833 1
a833 1
	label .sketch.view.f3.l0 -textvariable mged_sketch_vparams
d835 14
a848 14
	frame  .sketch.view.f5
	label  .sketch.view.f5.l0 -text "Time:"
	entry  .sketch.view.f5.e0 -width 8 -textvariable mged_sketch_vtime
	bind   .sketch.view.f5.e0 <Key-Return> { sketch_vtime_set [.sketch.view.f5.e0 get]}

	frame .sketch.view.f8
	button .sketch.view.f8.b0 -text "Main Window" -command "raise .sketch"
	button .sketch.view.f8.b1 -text "Cancel" -command "sketch_view_cancel"

	menubutton .sketch.view.mb0 -text "Read/Write" -menu .sketch.view.mb0.m0
	menu .sketch.view.mb0.m0
	.sketch.view.mb0.m0 add command -label "Read V-curve From File" -command {sketch_popup_vload}
	.sketch.view.mb0.m0 add command -label "Write V-curve To File" -command {sketch_popup_vsave curve}
	.sketch.view.mb0.m0 add command -label "Delete V-curve" -command {sketch_popup_delete_vcurve}
d851 4
a854 4
		.sketch.view.f4 .sketch.view.f3 .sketch.view.f5 .sketch.view.f1 .sketch.view.f0 \
		.sketch.view.b0 .sketch.view.b1 .sketch.view.b2 .sketch.view.b3 \
		.sketch.view.mb0 \
		.sketch.view.f8	\
d857 1
a857 1
		.sketch.view.f8.b0 .sketch.view.f8.b1 \
d859 1
a859 1
	pack .sketch.view.f0.b4 .sketch.view.f0.b40 .sketch.view.f0.b50 .sketch.view.f0.b5 \
d861 4
a864 4
	pack .sketch.view.f1.l0 .sketch.view.f1.l1 .sketch.view.f1.l2 .sketch.view.f1.l3 \
		.sketch.view.f4.mb0 .sketch.view.f4.l1 \
		.sketch.view.f3.mb0 .sketch.view.f3.l0 \
		.sketch.view.f5.l0 .sketch.view.f5.e0 \
d873 1
a873 1
	global mged_sketch_vname mged_sketch_vparams
d875 1
d879 4
a882 2
		set any [lindex [info commands .sketch.view._v_*.t] 0]
		if {[regexp {(\.sketch\.view\._v_)(.+)(\.t$)} $any all a name b] == 0} {
d885 2
d891 3
a893 2
	if { [info commands .sketch.view._v_$name.t] == "" } {
		sketch_popup_text_create .sketch.view._v_$name $name ro
d902 3
a904 3
	wm deiconify .sketch.view._v_$name
	raise .sketch.view._v_$name

d911 2
a912 1
		mged_sketch_temp1 mged_sketch_temp2 mged_sketch_anim_dir
d927 1
a927 1
	set text .sketch.view._v_$mged_sketch_vname.t
d1004 1
a1004 1
	global mged_sketch_vtime mged_sketch_vname mged_sketch_vparams
d1006 1
a1006 1
	set text .sketch.view._v_$mged_sketch_vname.t
d1046 1
a1046 1
	global mged_sketch_vname
d1048 1
a1048 1
	set text .sketch.view._v_$mged_sketch_vname.t
d1063 1
a1063 1
	global mged_sketch_vtime mged_sketch_vname
d1070 1
a1070 1
	set text .sketch.view._v_$mged_sketch_vname.t
d1082 2
a1083 1
	global mged_sketch_vtinc global mged_sketch_vtime mged_sketch_vname
d1090 1
a1090 1
	set text .sketch.view._v_$mged_sketch_vname.t
d1109 2
a1110 1
	global mged_sketch_vname mged_sketch_vparams mged_sketch_cmdlen
d1116 1
a1116 1
	set text .sketch.view._v_$mged_sketch_vname.t
d1185 1
a1185 1
	global mged_sketch_vname
d1190 1
a1190 1
		set text .sketch.view._v_$mged_sketch_vname.t
d1200 1
a1200 1
	focus .sketch
d1213 4
a1216 4
		{"OK" {sketch_vsave [.sketch.input.f0.e get] \
			[.sketch.input.f1.e get] \
			[.sketch.input.f2.e get] } }\
		{"Cancel" "destroy .sketch.input"} \
d1222 3
a1224 1
	set text .sketch.view._v_$vcurve.t
d1226 1
a1226 1
		tk_dialog .sketch.msg {Can't find View Curve} \
d1231 1
a1231 1
		set ans [tk_dialog .sketch.msg {File Exists} \
d1240 1
a1240 1
	catch {destroy .sketch.input}
d1252 4
a1255 4
		[list "OK" "sketch_vload \[.sketch.input.f0.e get\] \
			\[.sketch.input.f1.e get\] \
			\[.sketch.input.f2.e get\] \$mged_sketch_text_lmode"] \
		{"Cancel" "destroy .sketch.input"} \
d1258 3
a1260 3
	frame .sketch.input.f3
	pack .sketch.input.f3 -side bottom
	radiobutton .sketch.input.f3.r0 -text "Replace" \
d1262 1
a1262 1
	radiobutton .sketch.input.f3.r1 -text "Append" \
d1264 1
a1264 1
	radiobutton .sketch.input.f3.r2 -text "Add New Columns" \
d1267 1
a1267 1
	pack .sketch.input.f3.r0 .sketch.input.f3.r1 .sketch.input.f3.r2 \
d1272 1
a1272 1
	global mged_sketch_vname mged_sketch_vparams
d1290 1
a1290 1
	set text .sketch.view._v_$vcurve.t
d1296 1
a1296 1
	catch {destroy .sketch.input}
d1307 2
a1308 2
			{"OK" {sketch_vname [.sketch.input.f0.e get]}}
			{"Cancel" "destroy .sketch.input"}
d1314 1
a1314 1
			[list "OK" "sketch_vrename \[.sketch.input.f0.e get\] \
d1316 1
a1316 1
			{"Cancel" "destroy .sketch.input"} \
d1323 1
a1323 1
	catch {destroy .sketch.input}
d1328 2
a1329 1
	global mged_sketch_vname
d1332 1
d1334 2
a1335 1
		catch {destroy .sketch.input}
d1337 2
a1338 2
	set ntext .sketch.view._v_$name.t
	set otext .sketch.view._v_$oldname.t
d1341 1
a1341 1
		set ans [tk_dialog .sketch.msg {View Curve Exists} \
d1343 1
a1343 1
		   {Cancel}
d1348 2
d1353 1
a1353 1
		destroy .sketch.view._v_$oldname
d1357 1
a1357 1
	catch {destroy .sketch.input}
d1366 3
a1368 3
		{ "OK" {sketch_delete_vcurve [.sketch.input.f0.e get]; \
				destroy .sketch.input} } \
		{ "Cancel" "destroy .sketch.input" } \
d1374 3
a1376 1
	catch {destroy .sketch.view._v_$name}
d1384 7
a1390 3
	wm withdraw .sketch.view
	foreach ted [info commands .sketch.view._v_*.t] {
		regsub {(^\.sketch\.view\._v_.*)(\.t$)} $ted {\1} name
d1408 1
a1408 1
		tk_dialog .sketch.msg {Wrong number of columns} \
d1422 122
d1552 2
a1553 2
		    {[.sketch.input.f0.e get] [.sketch.input.f1.e get]}] ]\
		{"Cancel" "destroy .sketch.input"} \
d1567 1
a1567 1
		    \[.sketch.input.f0.e get\] \[.sketch.input.f1.e get\] \
d1569 1
a1569 1
		{"Cancel" "destroy .sketch.input"} \
d1572 3
a1574 3
	frame .sketch.input.f3
	pack .sketch.input.f3 -side bottom
	radiobutton .sketch.input.f3.r0 -text "Replace" \
d1576 1
a1576 1
	radiobutton .sketch.input.f3.r1 -text "Append" \
d1578 1
a1578 1
	radiobutton .sketch.input.f3.r2 -text "Add New Columns" \
d1581 1
a1581 1
	pack .sketch.input.f3.r0 .sketch.input.f3.r1 .sketch.input.f3.r2 \
d1592 2
a1593 2
		    \[.sketch.input.f0.e get\] \[.sketch.input.f1.e get\]"] \
		{"Cancel" "destroy .sketch.input"} \
d1630 1
a1630 97
	catch {destroy .sketch.input}
}

#table editor for curves
proc sketch_popup_text { args } {

	upvar #0  mged_sketch_text_index index
	set z $index
	#puts "creating .sketch.text$z"
	if { [info commands .sketch.text$z] == "" } {
		#create if not yet existing
		#puts "does not yet exist"
		sketch_popup_text_create .sketch.text$z $z
		incr index
	}

	#fill with appropriate text
	switch [lindex $args 0] {
		empty {.sketch.text$z.t delete 1.0 end}
		curve {
		  set oldname [vdraw r n]
		  sketch_open_curve [lindex $args 1]
		  .sketch.text$z.t delete 1.0 end
		  sketch_text_echoc .sketch.text$z.t
		  sketch_open_curve $oldname }
		clone {
		  sketch_text_copy [lindex $args 1] \
		     .sketch.text$z.t replace }
		default {
		  .sketch.text$z.t delete 1.0 end
		  sketch_text_echoc .sketch.text$z.t
		}
	}

	#finish textbar initialization
	.sketch.text$z.textbar insert 1.0 "\ttime(0)\tx(1)\ty(2)\tz(3)"
	sketch_text_bar_set .sketch.text$z.t .sketch.text$z.textbar 0.0
}

proc sketch_popup_text_create { name index {mode rw}} {

	toplevel $name
	wm title $name "MGED Animator table editor $index"
	text $name.t -width 80 -height 20 -wrap none \
		-tabs {20 numeric 220 numeric 420 numeric 620 numeric} \
		-xscrollcommand \
		"sketch_scroll_both $name" \
		-yscrollcommand "$name.s1 set"
	text $name.textbar -width 80 -height 1 -wrap none \
		-tabs {50 center 250 center 450 center 650 center}
	scrollbar $name.s0 -command \
		"$name.t xview" \
		-orient horizontal
	scrollbar $name.s1 -command "$name.t yview"
	frame $name.f1
	label $name.f1.l0 -text "Table editor $index"
	frame  $name.f0
	if { $mode == "rw" } {
		button $name.f0.b3 -text "Clear" -command "$name.t delete 1.0 end"
		button $name.f0.b4 -text "Interpolate" -command "sketch_popup_text_interp $name.t $name.textbar"
		button $name.f0.b5 -text "Estimate Time" -command "sketch_popup_text_time $name.t"
		button $name.f0.b7 -text "Edit Columns" -command "sketch_popup_text_col $name.t $name.textbar"
		menubutton $name.f0.mb0 -text "Read" -menu $name.f0.mb0.m
		menu $name.f0.mb0.m -tearoff 0 -postcommand "sketch_post_read_menu $name.f0.mb0.m $name.t"
		$name.f0.mb0.m add command -label "from File" -command "sketch_popup_read $name.t file"
		$name.f0.mb0.m add command -label "from Curve" -command "sketch_popup_read $name.t curve"
		button $name.f0.b6 -text "Cancel" -command "destroy $name"
	} else {
		button $name.f0.b6 -text "Hide" -command "wm withdraw $name"
	}
	button $name.f0.b8 -text "Clone" -command "sketch_popup_text clone $name.t"
	button $name.f0.b9 -text "Main" -command "raise .sketch"
	menubutton $name.f0.mb1 -text "Write" -menu $name.f0.mb1.m
	menu $name.f0.mb1.m -tearoff 0
	$name.f0.mb1.m add command -label "to File" -command "sketch_popup_write $name.t file"
	$name.f0.mb1.m add command -label "to Curve" -command "sketch_popup_write $name.t curve"
	$name.f0.mb1.m add command -label "to V-curve" -command "sketch_popup_write $name.t vcurve"

	pack $name.f0 $name.s0 -side bottom -fill x
	pack $name.s1 -side right -fill y	
	pack $name.f0.mb1 -side left -fill x -expand yes
	if { $mode == "rw" } {
		pack $name.f0.mb0 \
			$name.f0.b3 $name.f0.b4 $name.f0.b5 $name.f0.b7 \
			-side left -fill x -expand yes
	}
	pack $name.f0.b8 $name.f0.b9 $name.f0.b6 \
		-side left -fill x -expand yes

	pack $name.f1 $name.textbar $name.t\
		-side top -expand yes -fill x -anchor w
	pack $name.f1.l0

	if { $mode == "ro" } {
		$name.t configure -state disabled
	}

d1676 14
d1693 4
a1696 1
	$menu add command -label "from Curve" -command "sketch_popup_read $text curve"
d1705 12
a1716 7
	foreach ted [info commands .sketch.view._v_*.t] {
		set good [regsub {(\.sketch\.view\._v_)(.+)(\.t)} \
		   $ted {\2} vcurve]
		if { $good == 1 } {
			$menu add command \
			  -label "from v-curve $vcurve" -command \
			  "sketch_popup_read $text $ted"
d1729 5
a1733 5
	catch { destroy .sketch.col }
	toplevel .sketch.col
	frame .sketch.col.fa
	frame .sketch.col.fb
	pack .sketch.col.fb .sketch.col.fa -side bottom -anchor e
d1737 1
a1737 1
	set cmd "sketch_text_do_col $w \[.sketch.col.fb.e0 get\]"
d1742 1
a1742 1
	#append cmd "; sketch_text_bar_reset $w; destroy .sketch.col"
d1745 2
a1746 2
		bind  .sketch.col.fr[expr $i-1].e0 <Key-Return> \
			{.sketch.col.fa.b0 invoke}
d1748 8
a1755 8
	button .sketch.col.fa.b2 -text "Add Column" -command {sketch_text_col_add_one} 
	button .sketch.col.fa.b0 -text "OK" -command $cmd
	button .sketch.col.fa.b1 -text "Cancel" -command {destroy .sketch.col}
	label .sketch.col.fb.l0 -text "Number of Rows:" 
	entry .sketch.col.fb.e0 -width 5
	.sketch.col.fb.e0 insert end "all"
	pack .sketch.col.fa.b2 .sketch.col.fa.b0 .sketch.col.fa.b1 -side left
	pack .sketch.col.fb.l0 .sketch.col.fb.e0 -side left -fill x
d1758 1
a1758 1
		focus .sketch.col.fr0.e0
d1763 2
a1764 2
	set num [llength [info commands .sketch.col.fr*.e0]]
	set cmd [lindex [split [.sketch.col.fa.b0 cget -command] \;] 0]
d1766 2
a1767 2
	bind  .sketch.col.fr$num.e0 <Key-Return> {.sketch.col.fa.b0 invoke}
	.sketch.col.fa.b0 configure -command $cmd
d1771 3
a1773 3
		frame .sketch.col.fr$i
		label .sketch.col.fr$i.l0 -text "$col:" -width 10
		entry .sketch.col.fr$i.e0 -width 20
d1775 1
a1775 1
			.sketch.col.fr$i.e0 insert end @@$i
d1777 1
a1777 1
		append cmd " \[.sketch.col.fr$i.e0 get\]"
d1780 2
a1781 2
			bind .sketch.col.fr$j.e0 <Key-Return> \
			  "focus .sketch.col.fr$i.e0"
d1783 2
a1784 2
		pack .sketch.col.fr$i -side top
		pack .sketch.col.fr$i.l0 .sketch.col.fr$i.e0 -side left
d1791 1
a1791 1
	destroy .sketch.col
d1854 12
a1865 12
	catch { destroy .sketch.col }
	toplevel .sketch.col
	frame .sketch.col.fa
	frame .sketch.col.fb
	frame .sketch.col.fc
	frame .sketch.col.fd
	menubutton .sketch.col.mb0 -text "Choose Interpolator" \
		-menu .sketch.col.mb0.m0
	menu .sketch.col.mb0.m0
	pack .sketch.col.mb0 .sketch.col.fa -side bottom -fill x -expand yes
	pack .sketch.col.fd .sketch.col.fc \
		.sketch.col.fb -side bottom -anchor e
d1869 2
a1870 2
	set cmd "sketch_text_do_interp $w \[.sketch.col.fb.e0 get\] \
		\[.sketch.col.fc.e0 get\] \[.sketch.col.fd.e0 get\]"
d1875 1
a1875 1
	#append cmd "; sketch_text_bar_reset $w; destroy .sketch.col"
d1878 2
a1879 2
		bind  .sketch.col.fr[expr $i-1].e0 <Key-Return> \
			{focus .sketch.col.fb.e0}
d1881 17
a1897 17
	button .sketch.col.fa.b2 -text "Add Column" -command {sketch_text_interp_add_one} 
	button .sketch.col.fa.b0 -text "OK" -command $cmd
	button .sketch.col.fa.b1 -text "Cancel" -command {destroy .sketch.col}
	label .sketch.col.fb.l0 -text "Start Time:" 
	entry .sketch.col.fb.e0 -width 10
	bind .sketch.col.fb.e0 <Key-Return> {focus .sketch.col.fc.e0}
	label .sketch.col.fc.l0 -text "End Time:" 
	entry .sketch.col.fc.e0 -width 10
	bind .sketch.col.fc.e0 <Key-Return> {focus .sketch.col.fd.e0}
	label .sketch.col.fd.l0 -text "Frames Per Second:" 
	entry .sketch.col.fd.e0 -width 10
	bind .sketch.col.fd.e0 <Key-Return> {.sketch.col.fa.b0 invoke}
	.sketch.col.fd.e0 insert end "30"
	pack .sketch.col.fa.b2 .sketch.col.fa.b0 .sketch.col.fa.b1 -side left
	pack .sketch.col.fb.l0 .sketch.col.fb.e0 \
		.sketch.col.fc.l0 .sketch.col.fc.e0 \
		.sketch.col.fd.l0 .sketch.col.fd.e0 \
d1900 8
a1907 8
	.sketch.col.mb0.m0 add command -label "Step (src)" -command {sketch_interp_fill step i}
	.sketch.col.mb0.m0 add command -label "Linear (src)" -command {sketch_interp_fill linear i}
	.sketch.col.mb0.m0 add command -label "Spline (src)" -command {sketch_interp_fill spline i}
	.sketch.col.mb0.m0 add command -label "Periodic spline (src)" -command {sketch_interp_fill cspline i}
	.sketch.col.mb0.m0 add command -label "Quaternion (src)" -command {sketch_interp_fill quat i}
	.sketch.col.mb0.m0 add command -label "Rate (init) (incr/s)" -command {sketch_interp_fill rate }
	.sketch.col.mb0.m0 add command -label "Accel (init) (incr/s)" -command {sketch_interp_fill accel}
	.sketch.col.mb0.m0 add command -label "Next (src) (offset)" -command {sketch_interp_fill next}
d1910 1
a1910 1
		focus .sketch.col.fr1.e0
d1916 1
a1916 1
	.sketch.col.fb.e0 insert end \
d1918 1
a1918 1
	.sketch.col.fc.e0 insert end \
d1951 1
a1951 1
						tk_dialog .sketch.msg {Invalid entry} \
d1977 1
a1977 1
		tk_dialog .sketch.msg {Invalid entry} \
d2006 1
a2006 1
		foreach ent [info commands {.sketch.col.fr[0-9]*.e0}] {
d2011 1
a2011 1
		set ent [info commands .sketch.col.fr1.e0]
d2013 1
a2013 1
			set ent [info commands .sketch.col.fr$i.e0]} {
d2023 3
a2025 3
		frame .sketch.col.fr$i
		label .sketch.col.fr$i.l0 -text "$col:" -width 10
		entry .sketch.col.fr$i.e0 -width 20
d2027 1
a2027 1
			.sketch.col.fr$i.e0 insert end "spline $i"
d2029 1
a2029 1
		append cmd " \[.sketch.col.fr$i.e0 get\]"
d2032 2
a2033 2
			bind .sketch.col.fr$j.e0 <Key-Return> \
			  "focus .sketch.col.fr$i.e0"
d2035 2
a2036 2
		pack .sketch.col.fr$i -side top
		pack .sketch.col.fr$i.l0 .sketch.col.fr$i.e0 -side left
d2041 1
a2041 1
	set num [llength [info commands .sketch.col.fr*.e0]]
d2043 2
a2044 2
	set cmd [.sketch.col.fa.b0 cget -command]
	#set cmd [lindex [split [.sketch.col.fa.b0 cget -command] \;] 0]
d2046 2
a2047 2
	bind  .sketch.col.fr$num.e0 <Key-Return> {focus .sketch.col.fb.e0}
	.sketch.col.fa.b0 configure -command $cmd
d2055 1
a2055 1
	destroy .sketch.col
d2064 2
a2065 2
				\[.sketch.input.f0.e get\] \
				\[.sketch.input.f1.e get\] \
d2071 2
a2072 2
				\[.sketch.input.f0.e get\] \
				\[.sketch.input.f1.e get\] \
d2080 1
a2080 1
				\[.sketch.input.f0.e get\] \
d2082 1
a2082 1
				destroy .sketch.input"
d2088 1
a2088 1
		[list "Cancel" "destroy .sketch.input"] \
d2091 3
a2093 3
	frame .sketch.input.f3
	pack .sketch.input.f3 -side bottom
	radiobutton .sketch.input.f3.r0 -text "Replace" \
d2095 1
a2095 1
	radiobutton .sketch.input.f3.r1 -text "Append" \
d2097 1
a2097 1
	radiobutton .sketch.input.f3.r2 -text "Add New Columns" \
d2100 1
a2100 1
	pack .sketch.input.f3.r0 .sketch.input.f3.r1 .sketch.input.f3.r2 \
d2114 1
a2114 1
	catch {destroy .sketch.input}
d2124 2
a2125 2
				\[.sketch.input.f0.e get\] \
				\[.sketch.input.f1.e get\]"
d2130 2
a2131 2
				\[.sketch.input.f0.e get\] \
				\[.sketch.input.f1.e get\]"
d2136 2
a2137 2
				\[.sketch.input.f0.e get\] \
				\[.sketch.input.f1.e get\]"
d2144 1
a2144 1
		[list "Cancel" "destroy .sketch.input"] \
d2170 1
a2170 1
	catch {destroy .sketch.input}
d2176 1
a2176 1
	global mged_sketch_vparams mged_sketch_vname
d2193 1
a2193 1
	set text .sketch.view._v_$vcurve.t
d2198 1
a2198 1
	catch {destroy .sketch.input}
d2206 34
d2241 1
a2241 6
proc sketch_popup_objanim { {mode object} } {

	if { [info commands .sketch.oanim] != ""} {
		catch {destroy .sketch.oanim}
	}
	toplevel .sketch.oanim
d2243 16
a2258 6
	frame .sketch.oanim.f0
	label .sketch.oanim.f0.l0 -text "Output file: "
	entry .sketch.oanim.f0.e0 -width 20 -textvariable mged_sketch_objscript
	frame .sketch.oanim.f1
	label .sketch.oanim.f1.l0 -text Source
	tk_optionMenu .sketch.oanim.f1.om0 mged_sketch_objsrctype \
d2260 2
a2261 2
	entry .sketch.oanim.f1.e0 -width 20 -textvariable mged_sketch_objsource
	frame .sketch.oanim.f2
d2263 3
a2265 3
		wm title .sketch.oanim "MGED View Animation"
		label .sketch.oanim.l0 -text "CREATE VIEW ANIMATION"
		button .sketch.oanim.f2.l0 -text "View size:" -command \
d2267 3
a2269 3
		entry .sketch.oanim.f2.e0 -width 20 -textvariable mged_sketch_objvsize
		frame .sketch.oanim.f9
		button .sketch.oanim.f9.b0 -text "Eye point:" \
d2271 3
a2273 3
		entry .sketch.oanim.f9.e0 -width 20 -textvariable mged_sketch_eyecen
		frame .sketch.oanim.f10
		button .sketch.oanim.f10.b0 -text "Eye yaw,pitch,roll: " \
d2275 3
a2277 3
		entry .sketch.oanim.f10.e0 -width 20 -textvariable mged_sketch_eyeori
		set if_view ".sketch.oanim.f9 .sketch.oanim.f10"
		checkbutton .sketch.oanim.cb0 -text "Read viewsize from source" \
d2279 1
a2279 1
		.sketch.oanim.cb0 deselect
d2283 1
a2283 1
		wm title .sketch.oanim "MGED Object Animation"
d2285 4
a2288 4
		label .sketch.oanim.l0 -text "CREATE OBJECT ANIMATION"
		label .sketch.oanim.f2.l0 -text "Object name:"
		entry .sketch.oanim.f2.e0 -width 20 -textvariable mged_sketch_objname
		checkbutton .sketch.oanim.cb1 -text "Relative Displacement" \
d2290 1
a2290 1
		checkbutton .sketch.oanim.cb2 -text "Relative Rotation" \
d2293 2
a2294 2
		.sketch.oanim.cb1 deselect
		.sketch.oanim.cb2 deselect
d2296 2
a2297 2
	frame .sketch.oanim.f3
	button .sketch.oanim.f3.b0 -text "Object center:" \
d2299 3
a2301 3
	entry .sketch.oanim.f3.e0 -width 20 -textvariable mged_sketch_objcen
	frame .sketch.oanim.f4
	button .sketch.oanim.f4.b0 -text "Object yaw,pitch,roll: " \
d2303 2
a2304 2
	entry .sketch.oanim.f4.e0 -width 20 -textvariable mged_sketch_objori
	checkbutton .sketch.oanim.cb3 -text "No Translation" \
d2306 8
a2313 8
	.sketch.oanim.cb3 deselect
	frame .sketch.oanim.f5
	label .sketch.oanim.f5.l0 -text "First frame:"
	entry .sketch.oanim.f5.e0 -width 20 -textvariable mged_sketch_objframe
	frame .sketch.oanim.f6
	button .sketch.oanim.f6.b0 -text "Create Script" -command "sketch_objanim $mode"
	button .sketch.oanim.f6.b1 -text "Show Script" -command {sketch_popup_preview $mged_sketch_objscript}
	button .sketch.oanim.f6.b2 -text "Cancel" -command {destroy .sketch.oanim}
d2315 2
a2316 2
	label .sketch.oanim.l1 -text "Orientation Control: "
	radiobutton .sketch.oanim.rb0 -text "No Rotation" \
d2318 1
a2318 1
	radiobutton .sketch.oanim.rb1 -text "Automatic steering" \
d2320 1
a2320 1
	radiobutton .sketch.oanim.rb2 -text "Automatic steering and banking" \
d2322 4
a2325 4
	frame .sketch.oanim.f7
	label .sketch.oanim.f7.l0 -text "    maximum bank angle ="
	entry .sketch.oanim.f7.e0 -textvariable mged_sketch_objmang -width 4
	radiobutton .sketch.oanim.rb3 -text "Rotation specified as ypr" \
d2327 1
a2327 1
	radiobutton .sketch.oanim.rb4 -text "Rotation specified as quat" \
d2329 1
a2329 1
	radiobutton .sketch.oanim.rb5 -text "Eye-path and look-at path " \
d2331 4
a2334 4
	frame .sketch.oanim.f8
	label .sketch.oanim.f8.l0 -textvariable mged_sketch_objncols
	label .sketch.oanim.f8.l1 -text "input columns needed:"
	label .sketch.oanim.f8.l2 -textvariable mged_sketch_objcols
d2337 1
a2337 1
	pack	.sketch.oanim.l0 .sketch.oanim.f0 .sketch.oanim.f1 \
d2339 3
a2341 3
	pack 	.sketch.oanim.f8 -side top
	eval pack	.sketch.oanim.f2 .sketch.oanim.f3 \
		.sketch.oanim.f4 ${if_view} .sketch.oanim.f5 \
d2348 1
a2348 1
		pack .sketch.oanim.cb0 .sketch.oanim.cb3 -side top -anchor w
d2350 1
a2350 1
		pack .sketch.oanim.f9.b0 .sketch.oanim.f10.b0 \
d2352 1
a2352 1
		pack .sketch.oanim.f9.e0 .sketch.oanim.f10.e0 \
d2355 1
a2355 1
		pack .sketch.oanim.cb1 .sketch.oanim.cb2 .sketch.oanim.cb3 \
d2359 1
a2359 1
	pack 	.sketch.oanim.l1 -side top -anchor w
d2361 1
a2361 1
	pack 	.sketch.oanim.rb0 .sketch.oanim.rb1 .sketch.oanim.rb2 \
d2363 2
a2364 2
	pack	.sketch.oanim.f7 -side top -anchor e
	pack	.sketch.oanim.rb3 .sketch.oanim.rb4 .sketch.oanim.rb5 \
d2366 1
a2366 1
	pack 	.sketch.oanim.f6 -side top -fill x -expand yes
d2370 4
a2373 4
		.sketch.oanim.f0.l0 .sketch.oanim.f1.l0 .sketch.oanim.f1.om0\
		.sketch.oanim.f2.l0 .sketch.oanim.f3.b0 \
		.sketch.oanim.f4.b0 .sketch.oanim.f5.l0 \
		.sketch.oanim.f8.l0 .sketch.oanim.f8.l1 .sketch.oanim.f8.l2\
d2377 2
a2378 2
		.sketch.oanim.f0.e0 .sketch.oanim.f1.e0 .sketch.oanim.f2.e0\
		.sketch.oanim.f3.e0 .sketch.oanim.f4.e0 .sketch.oanim.f5.e0\
d2382 1
a2382 1
		.sketch.oanim.f6.b0 .sketch.oanim.f6.b1 .sketch.oanim.f6.b2 \
d2386 1
a2386 1
		.sketch.oanim.f7.e0 .sketch.oanim.f7.l0 \
d2389 5
a2393 5
	focus .sketch.oanim.f0.e0
	bind .sketch.oanim.f0.e0 <Key-Return> {focus .sketch.oanim.f1.e0}
	bind .sketch.oanim.f1.e0 <Key-Return> {focus .sketch.oanim.f2.e0}
	bind .sketch.oanim.f2.e0 <Key-Return> {focus .sketch.oanim.f3.e0}
	bind .sketch.oanim.f3.e0 <Key-Return> {focus .sketch.oanim.f4.e0}
d2395 3
a2397 3
		bind .sketch.oanim.f4.e0 <Key-Return> {focus .sketch.oanim.f9.e0}
		bind .sketch.oanim.f9.e0 <Key-Return> {focus .sketch.oanim.f10.e0}
		bind .sketch.oanim.f10.e0 <Key-Return> {focus .sketch.oanim.f5.e0}
d2399 1
a2399 1
		bind .sketch.oanim.f4.e0 <Key-Return> {focus .sketch.oanim.f5.e0}
d2401 1
a2401 1
	bind .sketch.oanim.f5.e0 <Key-Return> {.sketch.oanim.f6.b0 invoke}
d2416 2
a2417 1
		mged_sketch_temp1 mged_sketch_temp2 mged_sketch_anim_dir
a2418 1

d2430 1
a2430 1
			tk_dialog .sketch.msg {Wrong number of columns} \
d2439 1
a2439 1
			tk_dialog .sketch.msg {Couldn't find curve} \
d2448 3
a2450 3
		foreach ed [info commands .sketch.text*.t] {
			if { $ed == ".sketch.text$src.t"} {
				set w ".sketch.text$src.t"
d2455 1
a2455 1
			tk_dialog .sketch.msg {Couldn't find editor} \
d2464 1
a2464 1
			set ans [tk_dialog .sketch.msg {Excess columns} \
d2472 1
a2472 1
			tk_dialog .sketch.msg {Insufficient columns} \
d2491 1
a2491 1
			set ans [tk_dialog .sketch.msg {Excess columns} \
d2505 1
a2505 1
			tk_dialog .sketch.msg {Insufficient columns} \
d2710 12
a2721 6
#control creation of animation scripts
proc sketch_popup_track_anim { } {

	if { [info commands .sketch.tanim] != ""} {
		raise .sketch.tanim
		return
d2723 1
a2723 1
	toplevel .sketch.tanim
d2725 35
a2759 22
	wm title .sketch.tanim "MGED Track Animation"
	label .sketch.tanim.l0 -text "CREATE TRACK ANIMATION"
	frame .sketch.tanim.f0
	label .sketch.tanim.f0.l0 -text "Output file: "
	entry .sketch.tanim.f0.e0 -width 20 -textvariable mged_sketch_objscript
	frame .sketch.tanim.f1
	label .sketch.tanim.f1.l0 -text "Vehicle path curve: "
	entry .sketch.tanim.f1.e0 -width 20 -textvariable mged_sketch_objsource
	frame .sketch.tanim.f2
	label .sketch.tanim.f2.l0 -text "Wheel curve: "
	entry .sketch.tanim.f2.e0 -width 20 -textvariable mged_sketch_whlsource
	frame .sketch.tanim.f3
	label .sketch.tanim.f3.l0 -text "Radii of wheels (or common radius):"
	entry .sketch.tanim.f3.e0 -textvariable mged_sketch_radii
	frame .sketch.tanim.f4
	label .sketch.tanim.f4.l0 -text "Link path name:"
	entry .sketch.tanim.f4.e0 -width 20 -textvariable mged_sketch_lnkname
	frame .sketch.tanim.f5
	label .sketch.tanim.f5.l0 -text "Number of links: "
	entry .sketch.tanim.f5.e0 -textvariable mged_sketch_numlinks
	frame .sketch.tanim.f6
	button .sketch.tanim.f6.b0 -text "Vehicle center:" \
d2761 3
a2763 3
	entry .sketch.tanim.f6.e0 -width 20 -textvariable mged_sketch_objcen
	frame .sketch.tanim.f7
	button .sketch.tanim.f7.b0 -text "Vehicle yaw,pitch,roll: " \
d2765 8
a2772 8
	entry .sketch.tanim.f7.e0 -width 20 -textvariable mged_sketch_objori
	frame .sketch.tanim.f8
	label .sketch.tanim.f8.l0 -text "First frame:"
	entry .sketch.tanim.f8.e0 -width 20 -textvariable mged_sketch_objframe
	frame .sketch.tanim.f9
	button .sketch.tanim.f9.b0 -text "Create Script" -command {sketch_do_track $mged_sketch_objscript $mged_sketch_whlsource $mged_sketch_objsource $mged_sketch_objori $mged_sketch_objcen $mged_sketch_radii $mged_sketch_numlinks $mged_sketch_lnkname}
	button .sketch.tanim.f9.b1 -text "Show Script" -command {sketch_popup_preview $mged_sketch_objscript}
	button .sketch.tanim.f9.b2 -text "Cancel" -command {destroy .sketch.tanim}
d2775 5
a2779 5
	pack	.sketch.tanim.l0 .sketch.tanim.f0 .sketch.tanim.f1 \
		.sketch.tanim.f2 .sketch.tanim.f3 \
		.sketch.tanim.f4 .sketch.tanim.f5 \
		.sketch.tanim.f6 .sketch.tanim.f7 \
		.sketch.tanim.f8 .sketch.tanim.f9\
d2784 5
a2788 5
		.sketch.tanim.f0.l0 .sketch.tanim.f1.l0 \
		.sketch.tanim.f2.l0 .sketch.tanim.f3.l0 \
		.sketch.tanim.f4.l0 .sketch.tanim.f5.l0 \
		.sketch.tanim.f6.b0 .sketch.tanim.f7.b0 \
		.sketch.tanim.f8.l0 \
d2792 3
a2794 3
		.sketch.tanim.f0.e0 .sketch.tanim.f1.e0 .sketch.tanim.f2.e0\
		.sketch.tanim.f3.e0 .sketch.tanim.f4.e0 .sketch.tanim.f5.e0\
		.sketch.tanim.f6.e0 .sketch.tanim.f7.e0 .sketch.tanim.f8.e0 \
d2798 1
a2798 1
		.sketch.tanim.f9.b0 .sketch.tanim.f9.b1 .sketch.tanim.f9.b2 \
d2802 10
a2811 10
	focus .sketch.tanim.f0.e0
	bind .sketch.tanim.f0.e0 <Key-Return> {focus .sketch.tanim.f1.e0}
	bind .sketch.tanim.f1.e0 <Key-Return> {focus .sketch.tanim.f2.e0}
	bind .sketch.tanim.f2.e0 <Key-Return> {focus .sketch.tanim.f3.e0}
	bind .sketch.tanim.f3.e0 <Key-Return> {focus .sketch.tanim.f4.e0}
	bind .sketch.tanim.f4.e0 <Key-Return> {focus .sketch.tanim.f5.e0}
	bind .sketch.tanim.f5.e0 <Key-Return> {focus .sketch.tanim.f6.e0}
	bind .sketch.tanim.f6.e0 <Key-Return> {focus .sketch.tanim.f7.e0}
	bind .sketch.tanim.f7.e0 <Key-Return> {focus .sketch.tanim.f8.e0}
	bind .sketch.tanim.f8.e0 <Key-Return> {.sketch.tanim.f9.b0 invoke}
d2829 1
a2829 1
		tk_dialog .sketch.msg "Not enough wheels" "The curve $wcurve \
d2849 1
a2849 1
		tk_dialog .sketch.msg "Curve too short"	"The curve $tcurve \
d2867 8
a2874 5
proc sketch_popup_sort {} {
	
	if { [info commands .sketch.sort] != ""} {
		raise .sketch.sort
		return
d2876 1
a2876 40
	toplevel .sketch.sort
	label .sketch.sort.l0 -text "COMBINE SCRIPTS"
	frame .sketch.sort.f0
	label .sketch.sort.f0.l0 -text "Combine Scripts:"
	entry .sketch.sort.f0.e0 -width 20 
	frame .sketch.sort.f0.f0
	listbox .sketch.sort.f0.f0.lb0 -height 6 -width 20 \
		-yscrollcommand ".sketch.sort.f0.f0.s0 set"
	scrollbar .sketch.sort.f0.f0.s0 -command ".sketch.sort.f0.f0.lb0 yview"
	frame .sketch.sort.f1
	button .sketch.sort.f1.b0 -text "Filter:" -command { \
	  sketch_list_filter .sketch.sort.f1.f1.lb1 [.sketch.sort.f1.e1 get ] }
	entry .sketch.sort.f1.e1 -width 20
	frame .sketch.sort.f1.f1
	listbox .sketch.sort.f1.f1.lb1 -height 6 -width 20 \
		-yscrollcommand ".sketch.sort.f1.f1.s0 set"
	scrollbar .sketch.sort.f1.f1.s0 -command ".sketch.sort.f1.f1.lb1 yview"
	frame .sketch.sort.f2
	label .sketch.sort.f2.l0 -text "Create script: "
	entry .sketch.sort.f2.e0 -width 20
	button .sketch.sort.f2.b0 -text "OK" -command {sketch_sort [.sketch.sort.f2.e0 get] .sketch.sort.f0.f0.lb0; .sketch.sort.f1.b0 invoke}
	button .sketch.sort.f2.b1 -text "Cancel" -command "destroy .sketch.sort"

	bind .sketch.sort.f0.e0 <Key-Return> { sketch_sort_entry1 .sketch.sort.f0.e0 .sketch.sort.f0.f0.lb0 .sketch.sort.f2.e0 }
	bind .sketch.sort.f1.e1 <Key-Return> { .sketch.sort.f1.b0 invoke }
	bind .sketch.sort.f0.f0.lb0 <Button-1> { sketch_list_remove_y .sketch.sort.f0.f0.lb0 %y }
	bind .sketch.sort.f1.f1.lb1 <Button-1> { sketch_list_add_y .sketch.sort.f1.f1.lb1 .sketch.sort.f0.f0.lb0 %y }
	bind .sketch.sort.f2.e0 <Key-Return> { .sketch.sort.f2.b0 invoke }

	.sketch.sort.f2.e0 insert end ".script"
	.sketch.sort.f2.e0 selection range 0 end
	.sketch.sort.f2.e0 icursor 0

	.sketch.sort.f1.e1 insert end "./*.script"
	sketch_list_filter .sketch.sort.f1.f1.lb1 "./*.script"

	pack .sketch.sort.f2 -side bottom
	pack .sketch.sort.l0 -side top
	pack .sketch.sort.f0 -side left
	pack .sketch.sort.f1 -side right
d2878 55
a2932 2
	pack .sketch.sort.f0.l0 .sketch.sort.f0.e0 .sketch.sort.f0.f0 \
		.sketch.sort.f1.b0 .sketch.sort.f1.e1 .sketch.sort.f1.f1 \
d2934 4
a2937 4
	pack .sketch.sort.f2.l0 .sketch.sort.f2.e0 .sketch.sort.f2.b0 \
	 	.sketch.sort.f2.b1 -side left
	pack .sketch.sort.f0.f0.lb0 .sketch.sort.f0.f0.s0 \
		.sketch.sort.f1.f1.lb1 .sketch.sort.f1.f1.s0 \
d2940 1
a2940 1
	focus .sketch.sort.f0.e0
d2952 1
a2952 1
proc sketch_sort { outfile list } {
d2955 2
a2956 2
	if { [info commands .sketch.sort.fa] != "" } {
		tk_dialog .sketch.sort.msg {Script already sorting} \
d2969 5
a2973 5
	frame .sketch.sort.fa
	label .sketch.sort.fa.l0 -text "Sorting $outfile ..."
	button .sketch.sort.fa.b0 -text "Halt" -command "exec kill $pid"
	pack .sketch.sort.fa -side bottom -before .sketch.sort.f2
	pack .sketch.sort.fa.l0 .sketch.sort.fa.b0 -side left -fill x
d2975 1
a2975 1
	set done "destroy .sketch.sort.fa; exec rm $mged_sketch_sort_temp"
d3007 14
d3022 21
a3042 17
proc sketch_popup_preview { {filename ""} } {

	if { [info commands .sketch.prev] != ""} {
		raise .sketch.prev
		.sketch.prev.f0.e0 delete 0 end
		.sketch.prev.f0.e0 insert end $filename
		.sketch.prev.f0.e0 selection range 0 end
		return
	}
	toplevel .sketch.prev
	label .sketch.prev.l0 -text "SHOW SCRIPT"
	frame .sketch.prev.f0
	label .sketch.prev.f0.l0 -text "Script file: "
	entry .sketch.prev.f0.e0 -width 20
	frame .sketch.prev.f1
	label .sketch.prev.f1.l0 -text "Max frames per second:"
	entry .sketch.prev.f1.e0 -width 5 \
d3044 7
a3050 7
	frame .sketch.prev.f2
	label .sketch.prev.f2.l0 -text "Start frame: "
	entry .sketch.prev.f2.e0 -width 5 -textvariable mged_sketch_prevs
	frame .sketch.prev.f3
	label .sketch.prev.f3.l0 -text "End frame: "
	entry .sketch.prev.f3.e0 -width 5 -textvariable mged_sketch_preve
	checkbutton .sketch.prev.cb0 -text "Polygon rendering" \
d3052 13
a3064 13
	frame .sketch.prev.f4
	button .sketch.prev.f4.b0 -text "Show" \
		-command {sketch_preview [.sketch.prev.f0.e0 get]}
	button .sketch.prev.f4.b1 -text "Cancel" \
		-command { destroy .sketch.prev }

	.sketch.prev.f0.e0 delete 0 end
	.sketch.prev.f0.e0 insert 0 $filename
	.sketch.prev.f0.e0 selection range 0 end

	pack .sketch.prev.l0 \
		.sketch.prev.f0 .sketch.prev.f1 .sketch.prev.f2 \
		.sketch.prev.f3 .sketch.prev.cb0 .sketch.prev.f4 \
d3066 5
a3070 5
	pack .sketch.prev.f0.l0 .sketch.prev.f0.e0 \
		.sketch.prev.f1.l0 .sketch.prev.f1.e0 \
		.sketch.prev.f2.l0 .sketch.prev.f2.e0 \
		.sketch.prev.f3.l0 .sketch.prev.f3.e0 \
		.sketch.prev.f4.b0 .sketch.prev.f4.b1 \
d3073 5
a3077 5
	focus .sketch.prev.f0.e0
	bind .sketch.prev.f0.e0 <Key-Return> {focus .sketch.prev.f1.e0}
	bind .sketch.prev.f1.e0 <Key-Return> {focus .sketch.prev.f2.e0}
	bind .sketch.prev.f2.e0 <Key-Return> {focus .sketch.prev.f3.e0}
	bind .sketch.prev.f3.e0 <Key-Return> {.sketch.prev.f4.b0 invoke}
d3131 2
a3132 2
proc sketch_quit {} {
	destroy .sketch
d3164 1
a3164 1
		tk_dialog .sketch.msg {Empty file} \
d3214 1
a3214 1
		tk_dialog .sketch.msg {Empty text} \
d3232 1
a3232 1
		set ans [tk_dialog .sketch.msg {File Exists} \
d3242 1
a3242 1
	catch {	destroy .sketch.input}
d3250 1
a3250 1
	catch {destroy .sketch.input}
d3339 3
a3341 3
	catch {destroy .sketch.input}
	toplevel .sketch.input
	if {$title != ""} { wm title .sketch.input $title }
d3351 2
a3352 2
		frame .sketch.input.f$i
		pack .sketch.input.f$i -side top -expand yes -anchor w -fill x
d3355 2
a3356 2
		label .sketch.input.f$i.l -text $mylabel -width $max -anchor e
		entry .sketch.input.f$i.e -width 20
d3358 3
a3360 3
			bind  .sketch.input.f[expr $i-1].e <Key-Return> \
			  "focus .sketch.input.f$i.e; \
			   .sketch.input.f$i.e selection range 0 end"
d3362 2
a3363 2
		.sketch.input.f$i.e insert end [lindex $pair 1]
		pack .sketch.input.f$i.l .sketch.input.f$i.e \
d3377 2
a3378 2
			frame .sketch.input.f$j 
			pack .sketch.input.f$j -side top -anchor e
d3380 1
a3380 1
		button .sketch.input.f$j.b -text [lindex $pair 0] \
d3382 1
a3382 1
		pack .sketch.input.f$j.b -side right
d3389 1
a3389 1
		destroy .sketch.input 
d3395 4
a3398 4
	.sketch.input.f0.e selection range 0 end
	focus .sketch.input.f0.e
	bind .sketch.input.f[expr $i-1].e <Key-Return> \
			{.sketch.input.f0.b invoke}
@


1.1
log
@Initial revision
@
text
@d21 1
d40 1
a40 1
		-side top -fill x -expand yes
d55 3
a57 3
	uplevel #0 set mged_sketch_name ""
	uplevel #0 set mged_sketch_splname ""
	uplevel #0 set mged_sketch_color "255 255 0"
d65 2
a66 2
	uplevel #0 set mged_sketch_vname ""
	uplevel #0 set mged_sketch_vparams {size eye quat}
d77 5
a81 5
	uplevel #0 set mged_sketch_objcen "0 0 0"
	uplevel #0 set mged_sketch_objori "0 0 0"
	uplevel #0 set mged_sketch_eyecen "0 0 0"
	uplevel #0 set mged_sketch_eyeori "0 0 0"
	uplevel #0 set mged_sketch_objsteer ""
d84 3
a86 3
	uplevel #0 set mged_sketch_objlaf ""
	uplevel #0 set mged_sketch_objdisp ""
	uplevel #0 set mged_sketch_objrot ""
d96 1
a96 1
	uplevel #0 set mged_sketch_objcols "t x y z"
d98 3
a100 3
	uplevel #0 set mged_sketch_prevs ""
	uplevel #0 set mged_sketch_preve ""
	uplevel #0 set mged_sketch_prevp ""
d105 2
a106 2
	uplevel #0 set mged_sketch_whlsource ""
	uplevel #0 set mged_sketch_lnkname ""
@
