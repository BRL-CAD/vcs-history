head	1.48;
access;
symbols
	ansi-20040405-merged:1.43.4.1
	postmerge-20040405-ansi:1.47
	premerge-20040404-ansi:1.47
	postmerge-autoconf:1.47
	autoconf-freeze:1.47
	premerge-autoconf:1.47
	postmerge-20040315-windows:1.47
	premerge-20040315-windows:1.47
	windows-20040315-freeze:1.43.6.2
	autoconf-20031203:1.47
	autoconf-20031202:1.47
	autoconf-branch:1.47.0.4
	phong-branch:1.47.0.2
	photonmap-branch:1.45.0.2
	rel-6-1-DP:1.43
	windows-branch:1.43.0.6
	rel-6-0-2:1.43
	ansi-branch:1.43.0.4
	rel-6-0-1-branch:1.43.0.2
	hartley-6-0-post:1.43
	hartley-6-0-pre:1.43
	rel-6-0-1:1.43
	rel-6-0:1.41
	rel-5-4:1.33.2.4
	offsite-5-3-pre:1.38
	rel-5-3:1.33.2.4
	rel-5-2:1.33
	rel-5-1-branch:1.33.0.2
	rel-5-1:1.33
	rel-5-0:1.32
	rel-5-0-beta:1.29;
locks; strict;
comment	@# @;


1.48
date	2004.05.21.16.41.22;	author morrison;	state dead;
branches;
next	1.47;

1.47
date	2003.04.21.12.34.35;	author jra;	state Exp;
branches;
next	1.46;

1.46
date	2003.04.21.12.06.12;	author jra;	state Exp;
branches;
next	1.45;

1.45
date	2003.04.09.15.03.51;	author jra;	state Exp;
branches
	1.45.2.1;
next	1.44;

1.44
date	2003.03.13.19.45.31;	author jra;	state Exp;
branches;
next	1.43;

1.43
date	2002.08.05.15.31.41;	author jra;	state Exp;
branches
	1.43.4.1
	1.43.6.1;
next	1.42;

1.42
date	2002.08.03.00.52.57;	author jra;	state Exp;
branches;
next	1.41;

1.41
date	2001.10.30.20.25.17;	author bparker;	state Exp;
branches;
next	1.40;

1.40
date	2001.10.15.21.48.40;	author bparker;	state Exp;
branches;
next	1.39;

1.39
date	2001.04.03.22.33.03;	author bparker;	state Exp;
branches;
next	1.38;

1.38
date	2001.02.26.22.21.11;	author bparker;	state Exp;
branches;
next	1.37;

1.37
date	2000.12.22.00.35.15;	author bparker;	state Exp;
branches;
next	1.36;

1.36
date	2000.11.19.16.33.13;	author butler;	state Exp;
branches;
next	1.35;

1.35
date	2000.11.17.20.21.15;	author bparker;	state Exp;
branches;
next	1.34;

1.34
date	2000.10.16.17.05.07;	author butler;	state Exp;
branches;
next	1.33;

1.33
date	2000.03.03.14.00.56;	author jra;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	99.09.10.23.07.07;	author bparker;	state Exp;
branches;
next	1.31;

1.31
date	99.09.08.13.14.31;	author bparker;	state Exp;
branches;
next	1.30;

1.30
date	99.09.01.18.42.45;	author bparker;	state Exp;
branches;
next	1.29;

1.29
date	99.05.06.12.24.27;	author jra;	state Exp;
branches;
next	1.28;

1.28
date	99.05.05.15.26.45;	author jra;	state Exp;
branches;
next	1.27;

1.27
date	99.04.23.17.49.11;	author bparker;	state Exp;
branches;
next	1.26;

1.26
date	99.04.16.20.56.41;	author jra;	state Exp;
branches;
next	1.25;

1.25
date	99.02.10.15.21.12;	author bparker;	state Exp;
branches;
next	1.24;

1.24
date	99.01.19.22.31.28;	author bparker;	state Exp;
branches;
next	1.23;

1.23
date	99.01.04.22.54.03;	author bparker;	state Exp;
branches;
next	1.22;

1.22
date	98.12.15.17.07.20;	author bparker;	state Exp;
branches;
next	1.21;

1.21
date	98.12.14.03.51.38;	author jra;	state Exp;
branches;
next	1.20;

1.20
date	98.12.09.22.11.46;	author bparker;	state Exp;
branches;
next	1.19;

1.19
date	98.12.01.02.23.06;	author jra;	state Exp;
branches;
next	1.18;

1.18
date	98.11.30.03.22.12;	author jra;	state Exp;
branches;
next	1.17;

1.17
date	98.11.27.21.35.10;	author jra;	state Exp;
branches;
next	1.16;

1.16
date	98.11.25.20.29.10;	author bparker;	state Exp;
branches;
next	1.15;

1.15
date	98.11.25.14.24.05;	author bparker;	state Exp;
branches;
next	1.14;

1.14
date	98.11.24.21.42.39;	author bparker;	state Exp;
branches;
next	1.13;

1.13
date	98.11.24.21.04.57;	author jra;	state Exp;
branches;
next	1.12;

1.12
date	98.11.23.20.39.50;	author bparker;	state Exp;
branches;
next	1.11;

1.11
date	98.11.20.20.57.56;	author jra;	state Exp;
branches;
next	1.10;

1.10
date	98.11.20.14.46.42;	author jra;	state Exp;
branches;
next	1.9;

1.9
date	98.11.20.14.26.43;	author bparker;	state Exp;
branches;
next	1.8;

1.8
date	98.11.19.18.39.28;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	98.11.19.16.12.58;	author bparker;	state Exp;
branches;
next	1.6;

1.6
date	98.11.06.21.28.41;	author bparker;	state Exp;
branches;
next	1.5;

1.5
date	98.08.13.12.46.07;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	98.06.24.18.38.06;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	98.06.15.19.28.20;	author bparker;	state Exp;
branches;
next	1.2;

1.2
date	98.06.09.18.13.40;	author bparker;	state Exp;
branches;
next	1.1;

1.1
date	98.04.09.21.26.33;	author bparker;	state Exp;
branches;
next	;

1.33.2.1
date	2000.11.17.20.16.41;	author bparker;	state Exp;
branches;
next	1.33.2.2;

1.33.2.2
date	2000.11.20.21.06.46;	author jra;	state Exp;
branches;
next	1.33.2.3;

1.33.2.3
date	2000.12.22.00.02.28;	author bparker;	state Exp;
branches;
next	1.33.2.4;

1.33.2.4
date	2001.02.26.22.20.28;	author bparker;	state Exp;
branches;
next	;

1.43.4.1
date	2004.03.17.21.23.10;	author morrison;	state Exp;
branches;
next	;

1.43.6.1
date	2002.09.26.23.04.17;	author morrison;	state Exp;
branches;
next	1.43.6.2;

1.43.6.2
date	2004.03.11.23.48.58;	author morrison;	state Exp;
branches;
next	;

1.45.2.1
date	2003.08.26.14.04.47;	author justin;	state Exp;
branches;
next	;


desc
@Widget for creating/editing a combination.
@


1.48
log
@moved to src/tclscripts/
@
text
@#
#			C O M B . T C L
#
#	Widget for editing a combination.
#
#	Author - Robert G. Parker
#
# This is the widget hierarchy from the top level down to the shader frames or Boolean
# expression frames
# 
# widget names include $id to make them unique. Typically, $id == "id_0"
# 
# Top level combination editor widget: $id.comb
# 
# slaves:
# 	.id_0.comb.control_buttons_frame
# 		frame for control buttons (OK, Apply, Reset, Dismiss)
# 	.id_0.comb.my_tabbed
# 		frame for holding the Boolean or Shader stuff
# 	.id_0.comb.region_inherit_frame
# 		frame for "Is Region" and "Inherit" as well as button to
# 		switch between Boolean and shader displays
# 	.id_0.comb.name_stuff
# 		frame for combination label, name and menubutton
# 
# -------------------------------------------------
# .id_0.comb.my_tabbed
# 
# 	This frame is just a holder for either the Boolean stuff or the shader stuff
# 
# slaves:
# 	.id_0.comb.my_tabbed.bool_labeled
# 			or
# 	.id_0.comb.my_tabbed.shader_labeled
# 
# -------------------------------------------------
# .id_0.comb.my_tabbed.bool_labeled.childsite
# 
# 	This frame is a childsite of the ".id_0.comb.my_tabbed.bool_labeled" mentioned above
# 	This frame is only mapped when the Boolean expression is displayed.
# 
# slaves:
# 	.id_0.comb.id_los_air_mater
# 		frame containing the region id, air code, material id, and LOS
# 		This frame is toggled on and off using the "Is Region" checkbutton
# 
# 	.id_0.comb.bool_expr_frame
# 		Frame for the Boolean expression. Contains a label, scrollbar,
# 		and text widget.
# 
# -------------------------------------------------
# .id_0.comb.my_tabbed.shader_labeled.childsite
# 	This frame is the childsite of the ".id_0.comb.my_tabbed.shader_labeled"
# 	mentioned above. This frame is only mapped when the shader is displayed.
# slaves:
# 
# 	.id_0.comb.color_frame
# 		frame for the color label, entry, and menubutton
# 	.id_0.comb.shader_top_frame
# 		frame for the shader stuff
# 
# -------------------------------------------------
# .id_0.comb.shader_top_frame
# slaves:
# 	.id_0.comb.shader_label_entry_frame
# 		frame for the shader label, entry, and menubutton
# 	.id_0.comb.shader_frame
# 		frame for the individual shaders to fill
# 		this frame is passed by "do_shade" to the shaders
# 
# -------------------------------------------------
# .id_0.comb.shader_frame
# slaves:
# 	.id_0.comb.shader_frame.fr
# 		frame created by an individual shader to hold all its stuff
# 
# -------------------------------------------------
# .id_0.comb.shader_frame.fr
# slaves:
# 	For the typical shader, the slaves of this frame are the individual
# 	labels, buttons, checkbuttons, entry widgets, menubuttons, etc, for
# 	that particular shader. This is the end of the hierarchy for simple
# 	shaders. From here down, the discussion only relates to the "stack"
# 	shader
# 
# 	For the "stack" shader, the slaves of this frame are:
# 
# 	.id_0.comb.shader_frame.fr.add
# 		frame for the "Add shader" button
# 	.id_0.comb.shader_frame.fr.leesf
# 		scrolledframe to hold all the stacked shaders
# 
# -------------------------------------------------
# .id_0.comb.shader_frame.fr.leesf
# slaves:
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite
# 		frame internal to the scrolledframe
# 
# -------------------------------------------------
# .id_0.comb.shader_frame.fr.leesf.lwchildsite
# slaves:
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.vertsb
# 		vertical scrollbar for scrolledframe
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.horizsb
# 		horizontal scrollbar (dynamic)
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper
# 		frame internal to scrolledframe
# 
# -------------------------------------------------
# .id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper
# slaves:
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas
# 		another object internal to the scrolledframe widget
# 
# -------------------------------------------------
# .id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas.sfchildsite
# 	This frame is the actual childsite provided by the scrolledframe widget "leesf"
# 	It will contain a "stack" of frames, one for each shader currently
# 	in the stack
# 
# slaves:
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas.sfchildsite.stk_1
# 		frame for first stacked shader
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas.sfchildsite.stk_2
# 		frame for second stacked shader
# 	.
# 	.
# 	.
# 
# -------------------------------------------------
# .id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas.sfchildsite.stk_1
# 	This is a frame for an individual shader in the stack
# 
# slaves:
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas.sfchildsite.stk_1.del
# 		The delete button for this shader
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas.sfchildsite.stk_1.lab
# 		The label identifying which type of shader this one is
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas.sfchildsite.stk_1.fr
# 		The frame where the actual buttons, label, entries, etc for this
# 		particular shader located.
# 


# We use the Labeledframe from Iwidgets
package require Iwidgets

check_externs "get_comb put_comb"

# this routine displays "which_frame" ("Bool" or "Shade") and forgets the other
proc toggle_bool_shade_frame { id which_frame } {

    set top .$id.comb

    if { $which_frame == "Bool" } {
	grid forget $top.my_tabbed.shader_labeled
	grid $top.my_tabbed.bool_labeled -sticky nsew
	$top.region_inherit_frame.bool_shade_b configure \
	    -text "Show Shader" \
	    -command "toggle_bool_shade_frame $id Shade"
    } else {
	grid forget $top.my_tabbed.bool_labeled
	grid $top.my_tabbed.shader_labeled -sticky nsew
	$top.region_inherit_frame.bool_shade_b configure \
	    -text "Show Boolean" \
	    -command "toggle_bool_shade_frame $id Bool"
    }
}

# top level interface to the combination editor
#
# Creates a top level window containing (among other widgets) two
# labeledframes, one for the Boolean expression and one for shader stuff.
# Only one of these frames is visible at any one time
#
proc init_comb { id } {
    package require Iwidgets
    global mged_gui
    global comb_control
    global shader_params
    global ::tk::Priv

    if {[opendb] == ""} {
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "No database." \
		"No database has been opened!" info 0 OK
	return
    }

    # name of our top level window
    set top .$id.comb

    # if we already have such a window, just pop it up
    if [winfo exists $top] {
	raise $top
	return
    }

    # get default values for ident, air, los, and material
    set defaults [regdef]
    set default_ident [lindex $defaults 1]
    set default_air [lindex $defaults 3]
    set default_los [lindex $defaults 5]
    set default_material [lindex $defaults 7]

    # set the padding
    set comb_control($id,padx) 4
    set comb_control($id,pady) 2

    set comb_control($id,name) ""
    set comb_control($id,isRegion) "Yes"
    set comb_control($id,id) $default_ident
    set comb_control($id,air) $default_air
    set comb_control($id,material) $default_material
    set comb_control($id,los) $default_los
    set comb_control($id,color) ""
    set comb_control($id,inherit) ""
    set comb_control($id,comb) ""
    set comb_control($id,shader) ""
    set comb_control($id,shader_gui) ""
    set comb_control($id,dirty_name) 1

    # invoke a handler whenever the combination name is changed
    trace vdelete comb_control($id,name) w "comb_handle_trace $id"
    trace variable comb_control($id,name) w "comb_handle_trace $id"

    # create our top level window
    toplevel $top -screen $mged_gui($id,screen)

    # create a frame to hold either of the labeledframes
    set my_tabbed_frame [frame $top.my_tabbed -relief flat]

    # create the two labeledframes
    iwidgets::Labeledframe $my_tabbed_frame.shader_labeled -labeltext "Shader"
    iwidgets::Labeledframe $my_tabbed_frame.bool_labeled -labeltext "Boolean"

    # get the childsites (frames) of the labeledframes
    # store them in the "comb_control" array for global access
    set bool_frame [$my_tabbed_frame.bool_labeled childsite]
    set comb_control($id,bool_frame) $bool_frame
    set shade_frame [$my_tabbed_frame.shader_labeled childsite]
    
    # row 0 is just the color
    # row 1 is the actual frame containing the shader stuff
    grid rowconfigure $shade_frame 0 -weight 0
    grid rowconfigure $shade_frame 1 -weight 1

    # strange, but it appears that the childsite in this labeledframe
    # is in column 1 ?????
    grid columnconfigure $top.my_tabbed.shader_labeled 0 -weight 0
    grid columnconfigure $top.my_tabbed.shader_labeled 1 -weight 1

    # frame to hold the combination name, entry widget, and menunutton
    frame $top.name_stuff

    # frame to hold the region id, los, air code, and GIFT material code
    frame $top.id_los_air_mater 

    # frame to hold the color label and the "colorF" frame (created by
    # "color_entry_build")
    frame $top.color_frame

    # frame to contain all the shader stuff
    frame $top.shader_top_frame -relief groove -bd 2 

    # frame to hold the display selection menubutton, the "IsRegion",
    # checkbutton, and the "Inherit" checkbutton
    frame $top.region_inherit_frame 

    # frame to hold the label, text and scrollbar widgets for the
    # Boolean expression
    frame $top.bool_expr_frame 

    # frame to hold the control buttons (Apply, dismiss, ...)
    frame $top.control_buttons_frame 

    # frame to hold the region name entry and menubutton widgets
    # this frame sits in the "name_stuff" frame above
    frame $top.name_entry_and_menu_frame -relief sunken -bd 2 

    # frame to hold the shader label, entry, and menubutton widgets
    frame $top.shader_label_entry_frame

    # empty frame to pass to the shader routines (in "shaders.tcl")
    frame $top.shader_frame

    # frame to hold the shader entry and menubutton widgets
    # this frame sits in the "shader_label_entry_frame" above
    frame $top.shader_entry_and_menu_frame -relief sunken -bd 2 

    # arrange for global access
    set comb_control($id,shader_frame) $top.shader_frame
    set shader_params($id,window) $comb_control($id,shader_frame)

    # initialize name of shader
    set shader_params($id,shader_name) ""

    # create the button that will choose whether the "Boolean" or
    # "Shader" frame is displayed
    set bool_shade_b [button $top.region_inherit_frame.bool_shade_b \
			  -text "Show Shader" \
			  -command "toggle_bool_shade_frame $id Bool"]
    if { 0 } {
    set bool_shade_mb [menubutton $top.region_inherit_frame.bool_shade_menuB \
			   -text "Select View" \
			   -indicatoron true \
			   -relief raised]

    # create menu for above menubutton
    menu $bool_shade_mb.menu -tearoff false
    $bool_shade_mb.menu add command \
	-label "Show Boolean" \
	-command "toggle_bool_shade_frame $id Bool"
    $bool_shade_mb.menu add command \
	-label "Show Shader" \
	-command "toggle_bool_shade_frame $id Shade"
    $bool_shade_mb configure -menu $bool_shade_mb.menu

    # help for above menubutton
    set hoc_data { { summary "Use this button to select whether the Boolean
expression or the Shader parameters is displayed" } }
    hoc_register_data $bool_shade_mb "Select View" $hoc_data
    }

    set hoc_data { { summary "Use this button to select whether the Boolean
expression or the Shader parameters is displayed" } }
    hoc_register_data $bool_shade_b "Select View" $hoc_data

    # create label for combination name
    label $top.nameL -text "Name" -anchor e
    set hoc_data { { summary "The combination name is the name of a
region or a group. The region flag must be set
in order for the combination to be a region.
Note that a region defines a space containing
homogeneous material. In contrast, a group can
contain many different materials." } }
    hoc_register_data $top.nameL "Combination Name" $hoc_data

    # create entry widget for combination name
    entry $top.nameE -relief flat -width 35 -textvar comb_control($id,name)
    hoc_register_data $top.nameE "Combination Name" $hoc_data

    # create menubutton for selecting combination
    menubutton $top.nameMB -relief raised -bd 2\
	    -menu $top.nameMB.m -indicatoron 1
    hoc_register_data $top.nameMB "Combination Selection"\
	    { { summary "This pops up a menu of methods for selecting
a combination name." } }

    # create menu for above menubutton
    menu $top.nameMB.m -title "Combination Selection Method" -tearoff 0

    # add menu items
    $top.nameMB.m add command -label "Select From All Displayed"\
	    -command "winset \$mged_gui($id,active_dm); build_comb_menu_all_displayed"
    hoc_register_menu_data "Combination Selection Method" "Select From All Displayed"\
	    "Select Combination From All Displayed"\
	    { { summary "This pops up a listbox containing the combinations
currently being displayed in the geometry window. The
user can select from among the combinations listed here.
Note - When selecting items from this listbox, a left buttonpress
highlights the combination in question until the button is
released. To select a combination, double click with the left
mouse button." } }
    $top.nameMB.m add command -label "Select Along Ray"\
	    -command "winset \$mged_gui($id,active_dm); set mouse_behavior c"
    hoc_register_menu_data "Combination Selection Method" "Select Along Ray"\
	    "Select Combination Along Ray"\
	    { { summary "This method allows the user to use the
mouse to fire a ray at the combination of interest.
If only one combination is hit, that combination is
selected. If nothing is hit the user can simply fire
another ray, perhaps taking better aim :-). If more
than one combination is hit, a listbox of the hit
combinations is presented. Note - When selecting
items from this listbox, a left buttonpress highlights
the combination in question until the button is
released. To select a combination, double click with
the left mouse button." } }
    $top.nameMB.m add command -label "Select From All"\
	    -command "build_comb_menu_all"
    hoc_register_menu_data "Combination Selection Method" "Select From All"\
	    "Select Combination From All"\
	    { { summary "This pops up a listbox containing all the
combinations in the database. The user can select
from among the combinations listed here. Note - To select
a combination, double click with the left mouse button." } }
    $top.nameMB.m add command -label "Select From All Regions"\
	    -command "build_comb_menu_all_regions"
    hoc_register_menu_data "Combination Selection Method" "Select From All Regions"\
	    "Select Combination From All Regions"\
	    { { summary "This pops up a listbox containing all the
regions in the database. The user can select
from among the regions listed here. Note - To select
a region, double click with the left mouse button." } }
    $top.nameMB.m add command -label "Autoname"\
	    -command "set comb_control($id,name) \[_mged_make_name comb@@\]"
    hoc_register_menu_data "Combination Selection Method" "Autoname"\
	    "Automatically generate a combination name."\
	    { { summary "This automatically generates a combination
name of the form 'comb@@' where '@@' represents
the counter used by make_name." }
              { see_also "make_name" } }

    # create label for region id
    label $top.idL -text "Region Id:" -anchor e
    set hoc_data { { summary "The region id (i.e. item code) is a number
that is typically used for grouping regions
belonging to a particular component. If the
region id is non-zero it is considered to be
a model component. Otherwise, it is considered
to be air. The air code is then used to designate
the kind of air." } }
    hoc_register_data $top.idL "Region Id" $hoc_data

    # create entry widget for region id
    entry $top.idE -relief sunken -width 5 -textvar comb_control($id,id)
    hoc_register_data $top.idE "Region Id" $hoc_data

    # create label for air code
    label $top.airL -text " Air Code:" -anchor e
    set hoc_data { { summary "The air code is a number that is typically
used to designate the kind of air a region
represents. An air code of \"1\" signifies
universal air. An air code that is greater
than \"1\" signifies some other kind of air.
While an air code of \"0\" means that the
region represents a component." } }
    hoc_register_data $top.airL "Air Code" $hoc_data

    # create entry widget for air code
    entry $top.airE -relief sunken -width 2 -textvar comb_control($id,air)
    hoc_register_data $top.airE "Air Code" $hoc_data

    # create label for material code
    label $top.materialL -text " Material Id:" -anchor e
    set hoc_data { { summary "The material id represents a particular
material type as identified by a material
database. In the past, the gift material
database was used to identify the material
type." } }
    hoc_register_data $top.materialL "Material Id" $hoc_data

    # create entry widget for material code
    entry $top.materialE -relief sunken -width 2 -textvar comb_control($id,material)
    hoc_register_data $top.materialE "Material Id" $hoc_data

    # create label for LOS
    label $top.losL -text " LOS:" -anchor e
    set hoc_data { { summary "LOS is a number that represents the
percentage of material a component region
is composed of. For example, if some component
region is defined to be made of \"mild steel\", as
designated by its material id, with an LOS of 20
then the region is considered to be composed of
20% \"mild steel\"."  } }
    hoc_register_data $top.losL "LOS" $hoc_data

    # create entry widget for LOS
    entry $top.losE -relief sunken -width 3 -textvar comb_control($id,los)
    hoc_register_data $top.losE "LOS" $hoc_data

    # create label for color
    label $top.colorL -text "Color" -anchor e
    hoc_register_data $top.colorL "Color"\
	    { { summary "Material color is used by the ray tracer
when rendering. It is also used by MGED
when determining what color to use when
drawing an object" } }

    # create a color entry widget and a color menubutton
    # $top.colorF is the name of the container created by color_entry_build
    # that contains the entry and menubutton for specifying a color
    color_entry_build $top color comb_control($id,color)\
	    "color_entry_chooser $id $top color \"Combination Color\"\
	    comb_control $id,color"\
	    12 $comb_control($id,color) not_rt

    # create "shader" label
    label $top.shaderL -text "Shader" -anchor e
    set hoc_data { { summary "Use this to manually enter the shader
parameters. Note - when entering the
shader parameters directly, the shader
GUI will automatically be updated." } }
    hoc_register_data $top.shaderL "Shader" $hoc_data

    # create entry widget for shader string
    entry $top.shaderE -relief flat -width 12 -textvar comb_control($id,shader)
    hoc_register_data $top.shaderE "Shader" $hoc_data

    # whenever any key is released inside the shader entry widget.
    # call "set_shader_params" to update the shader display
    # (see "shaders.tcl" for this routine)
    bind $top.shaderE <KeyRelease> "set_shader_params comb_control($id,shader) $id"

    # create menubutton to select from all the shaders
    menubutton $top.shaderMB -relief raised -bd 2\
	    -menu $top.shaderMB.m -indicatoron 1
    hoc_register_data $top.shaderMB "Menu of Shaders"\
	    { { summary "This pops up a menu of shader types.
Selecting a shader from the menu will
reconfigure the shader's GUI to take on
the form of the selected shader type." } }

    # create menu for above menubutton
    menu $top.shaderMB.m -title "Shader" -tearoff 0
    $top.shaderMB.m add command -label plastic \
	    -command "comb_shader_gui $id plastic"
    hoc_register_menu_data "Shader" plastic "Shader - Plastic" \
	    { { summary "Set shader parameters to make this object appear as plastic." } }

    # add all the shaders to the above menu
    $top.shaderMB.m add command -label mirror \
	    -command "comb_shader_gui $id mirror"
    hoc_register_menu_data "Shader" mirror "Shader - Mirror" \
	    { { summary "Set shader parameters to make this object appear as a mirror." } }
    $top.shaderMB.m add command -label glass \
	    -command "comb_shader_gui $id glass"
    hoc_register_menu_data "Shader" glass "Shader - Glass" \
	    { { summary "Set shader parameters to make this object appear as glass." } }


    $top.shaderMB.m add command -label light \
	    -command "comb_shader_gui $id light"
    hoc_register_menu_data "Shader" light "Shader - Light" \
	    { { summary "Set shader parameters to make this object appear as a light source." } }



    $top.shaderMB.m add command -label "texture (color)" \
	    -command "comb_shader_gui $id texture"
    hoc_register_menu_data "Shader" "texture (color)" "Shader - Texture (color)"\
	    { { summary "Map a color texture on this object." } }
    $top.shaderMB.m add command -label "texture (b/w)" \
	    -command "comb_shader_gui $id bwtexture"
    hoc_register_menu_data "Shader" "texture (b/w)" "Shader - Texture (b/w)" \
	    { { summary "Map a black and white texture on this object." } }
    $top.shaderMB.m add command -label "bump map" \
	    -command "comb_shader_gui $id bump"
    hoc_register_menu_data "Shader" "bump map" "Shader - Bump" \
		{ { summary "Apply a bump map to perturb the surface normals of this object." } }
    $top.shaderMB.m add command -label "checker" \
	    -command "comb_shader_gui $id checker"
    hoc_register_menu_data "Shader" "checker" "Shader - Checker" \
		{ { summary "texture map a checkerboard pattern on this object." } }
    $top.shaderMB.m add command -label "test map" \
	    -command "comb_shader_gui $id testmap"
    hoc_register_menu_data "Shader" "test map" "Shader - testmap" \
		{ { summary "Map a red and blue gradient on this object proportional to 'uv'\n\
			texture map coordinates." } }
    $top.shaderMB.m add command -label "fake star pattern" \
	    -command "comb_shader_gui $id fakestar"
    hoc_register_menu_data "Shader" "fake star pattern" "Shader - fakestar" \
		{ { summary "Map a fake star field on this object." } }
    $top.shaderMB.m add command -label "cloud" \
	-command "comb_shader_gui $id cloud"
    hoc_register_menu_data "Shader" "cloud" "Shader - cloud" \
	{ { summary "Map a cloud texture on this object." } }
    $top.shaderMB.m add command -label "stack" \
	-command "comb_shader_gui $id stack"
    hoc_register_menu_data "Shader" "stack" "Shader - stack" \
	{ { summary "Consecutively apply multiple shaders to this object." } }
    $top.shaderMB.m add command -label "envmap" \
	-command "comb_shader_gui $id envmap"
    hoc_register_menu_data "Shader" "envmap" "Shader - envmap" \
	{ { summary "Apply an environment map using this region." } }
    $top.shaderMB.m add command -label "projection" \
	-command "comb_shader_gui $id prj"
    hoc_register_menu_data "Shader" "projection" "Shader - prj" \
	{ { summary "Project one or more images on this object." } }
    $top.shaderMB.m add command -label "camouflage" \
	-command "comb_shader_gui $id camo"
    hoc_register_menu_data "Shader" "camouflage" "Shader - camo" \
	{ { summary "Apply camouflage to this object." } }
    $top.shaderMB.m add command -label "air" \
	-command "comb_shader_gui $id air"
    hoc_register_menu_data "Shader" "air" "Shader - air" \
	{ { summary "Apply the air shader to this object." } }
    $top.shaderMB.m add command -label "extern" \
	-command "comb_shader_gui $id extern"
    hoc_register_menu_data "Shader" "extern" "Shader - extern" \
	{ { summary "Use the extern shader (shader parameters in an external file)." } }

    # allow for the possiblity that a shader exists that is not in the above list
    $top.shaderMB.m add command -label "unlisted" \
	-command "comb_shader_gui $id unlisted"
    hoc_register_menu_data "Shader" "unlisted" "Shader - unlisted" \
	{ { summary "Apply a shader that this gui doesn't recognize." } }

    # create label for Boolean expression
    label $top.combL -text "Boolean Expression:" -anchor w
    set hoc_data { { summary "A boolean expression is used to combine
objects to form a region or group. This expression
can consist of three kinds of operators. The 'u'
operator indicates union. The union of two objects
is defined as the volume in both objects. The '-'
operator indicates difference. The difference of two
objects is defined as the volume of the first object
minus the volume of the second object. Lastly, the
'+' operator indicates intersection. The intersection
of two objects is defined as the volume common to
both objects. Note - an object can be a solid, region
or group." } }
    hoc_register_data $top.combL "Boolean Expression" $hoc_data

    # create text widget to hold the Boolean expression
    text $top.combT -relief sunken -bd 2 -width 40 -height 10\
	    -yscrollcommand "$top.combS set" -setgrid true \
	    -tab {3c}
    hoc_register_data $top.combT "Edit Boolean Expression" $hoc_data

    # may need a vertical scrollbar for complex expressions
    scrollbar $top.combS -relief flat -command "$top.combT yview"

    # create "Is Region" checkbutton
    checkbutton $top.isRegionCB -relief raised -text "Is Region"\
	    -offvalue No -onvalue Yes -variable comb_control($id,isRegion)\
	    -command "comb_toggle_isRegion $id"
    hoc_register_data $top.isRegionCB "Is Region" \
	{ { summary "Toggle the region flag on/off. If the
region flag is toggled on \(i.e. checkbutton
is highligted\) the GUI reconfigures itself to
handle regions. If the region flag is toggled
off the GUI reconfigures itself to handle
groups. Note - both regions and groups are
combinations. However, a region is special
in that it has its region flag set. It is
also required to be homogeneous \(i.e. consisting
of the same material\)." } }

    # create "Inherit" checkbutton
    checkbutton $top.inheritCB -relief raised -text "Inherit"\
	    -offvalue No -onvalue Yes -variable comb_control($id,inherit)
    hoc_register_data $top.inheritCB "Inherit"\
	    { { summary "Toggle inheritance on/off. If inheritance
is on, everything in the group takes on
the characteristics of the group. Note -
setting the inheritance for a region has
no effect \(i.e. the members of a region
always take on the characteristics of the
region\)." } }

    # create the control buttons (OK, Apply, ...)
    button $top.okB -relief raised -text "OK"\
	    -command "comb_ok $id $top"
    hoc_register_data $top.okB "OK"\
	    { { summary "Apply the data in the \"Combination Editor\"
to the combination then close the
\"Combination Editor\"." } }
    button $top.applyB -relief raised -text "Apply"\
	    -command "comb_apply $id"
    hoc_register_data $top.applyB "Apply"\
	    { { summary "Apply the data in the \"Combination Editor\"
to the combination." } }
    button $top.resetB -relief raised -text "Reset"\
	    -command "comb_reset $id"
    hoc_register_data $top.resetB "Reset"\
	    { { summary "Reset the \"Combination Editor\" with data
from the combination." } }
    button $top.dismissB -relief raised -text "Dismiss" \
	    -command "comb_dismiss $id $top"
    hoc_register_data $top.dismissB "Dismiss" \
	    { { summary "Dismiss (close) the \"Combination Editor\"." } }

    # put name label, entry, and menu button in "name_stuff" frame
    grid $top.nameE $top.nameMB -sticky "ew" -in $top.name_entry_and_menu_frame
    grid columnconfigure $top.name_entry_and_menu_frame 0 -weight 1
    grid $top.nameL -sticky "e" -in $top.name_stuff -pady $comb_control($id,pady) -row 0 -column 0
    grid $top.name_entry_and_menu_frame -sticky "ew" -in $top.name_stuff -pady $comb_control($id,pady) -row 0 -column 1
    grid columnconfigure $top.name_stuff 1 -weight 1

    # put ident, los, air code, and material id into "id_los_air_mater" frame
    grid $top.idL -in $top.id_los_air_mater -pady $comb_control($id,pady) -row 0 -column 0 -sticky ew
    grid $top.idE -in $top.id_los_air_mater -pady $comb_control($id,pady) -row 0 -column 1 -sticky ew
    grid $top.airL -in $top.id_los_air_mater -pady $comb_control($id,pady) -row 0 -column 2 -sticky ew
    grid $top.airE -in $top.id_los_air_mater -pady $comb_control($id,pady) -row 0 -column 3 -sticky ew
    grid $top.materialL -in $top.id_los_air_mater -pady $comb_control($id,pady) -row 0 -column 4 -sticky ew
    grid $top.materialE -in $top.id_los_air_mater -pady $comb_control($id,pady) -row 0 -column 5 -sticky ew
    grid $top.losL -in $top.id_los_air_mater -pady $comb_control($id,pady) -row 0 -column 6 -sticky ew
    grid $top.losE -in $top.id_los_air_mater -pady $comb_control($id,pady) -row 0 -column 7 -sticky ew
    grid rowconfigure $top.id_los_air_mater 0 -weight 1
    grid columnconfigure $top.id_los_air_mater 1 -weight 1
    grid columnconfigure $top.id_los_air_mater 3 -weight 1
    grid columnconfigure $top.id_los_air_mater 5 -weight 1
    grid columnconfigure $top.id_los_air_mater 7 -weight 1
    grid columnconfigure $top.id_los_air_mater 0 -weight 0
    grid columnconfigure $top.id_los_air_mater 2 -weight 0
    grid columnconfigure $top.id_los_air_mater 4 -weight 0
    grid columnconfigure $top.id_los_air_mater 6 -weight 0


    # put id_los_air_mater into the "Boolean" frame
    grid $top.id_los_air_mater -in $bool_frame \
             -padx $comb_control($id,padx) \
             -pady $comb_control($id,pady) \
             -sticky new -row 0 -column 0
    grid $top.bool_expr_frame -in $bool_frame \
             -padx $comb_control($id,padx) \
             -pady $comb_control($id,pady) \
             -sticky nsew -row 1 -column 0
    grid columnconfigure $bool_frame 0 -weight 1
    grid rowconfigure $bool_frame 0 -weight 0
    grid rowconfigure $bool_frame 1 -weight 1

    # put the color label and the frame built by
    # "color_entry_build" into "color_frame"
    grid $top.colorL \
            -row 0 -column 0 \
	    -sticky "e" \
            -in $top.color_frame \
            -pady $comb_control($id,pady)
    grid $top.colorF \
            -row 0 -column 1 \
	    -sticky "w" \
            -in $top.color_frame \
            -pady $comb_control($id,pady)

    # puts shader entry widget and shader selector menubutton into the
    # "shader_entry_and_menu_frame"
    grid $top.shaderE $top.shaderMB \
	    -sticky "ew" \
	    -in $top.shader_entry_and_menu_frame
    grid columnconfigure $top.shader_entry_and_menu_frame 0 -weight 1

    # combine the above frame and the shader label
    # into  the "shader_label_entry_frame"
    grid $top.shaderL \
	-row 0 -column 0 \
	-sticky "e" \
	-in $top.shader_label_entry_frame
    grid $top.shader_entry_and_menu_frame \
	-row 0 -column 1 \
	-sticky "ew" \
	-in $top.shader_label_entry_frame
    grid columnconfigure $top.shader_label_entry_frame 1 -weight 1

    # puts the above frame in the "shader_top_frame"
    grid $top.shader_label_entry_frame \
	    -sticky "new" \
	    -in $top.shader_top_frame\
	    -padx $comb_control($id,padx) \
	    -pady $comb_control($id,pady)

    grid rowconfigure $top.shader_top_frame 0 -weight 0
    grid rowconfigure $top.shader_top_frame 1 -weight 1
    grid columnconfigure $top.shader_top_frame 0 -weight 1

    # puts color frame into "Shader" labeledframe
    grid $top.color_frame -in $shade_frame \
             -padx $comb_control($id,padx) \
             -pady $comb_control($id,pady) \
             -sticky new -row 0 -column 0

    # add the actual shader frame to the "Shader" labeledframe
    grid $top.shader_top_frame -in $shade_frame \
             -padx $comb_control($id,padx) \
             -pady $comb_control($id,pady) \
             -sticky nsew -row 1 -column 0

    grid rowconfigure $shade_frame 0 -weight 0
    grid rowconfigure $shade_frame 1 -weight 1
    grid columnconfigure $shade_frame 0 -weight 1

    # grid the "Shader labeledframe childsite frame
    grid $shade_frame -sticky nsew

    # put the display selection menubutton, the "Is Region" checkbutton,
    # and the "Inherit" checkbutton in the "region_inherit_frame"
    grid $bool_shade_b \
            -row 0 -column 0 \
            -sticky "w" \
            -in $top.region_inherit_frame
    grid $top.isRegionCB \
            -row 0 -column 2 \
            -sticky "nse" \
            -in $top.region_inherit_frame
    grid $top.inheritCB \
            -row 0 -column 3 \
            -sticky "nse" \
            -in $top.region_inherit_frame
    grid columnconfigure $top.region_inherit_frame 1 -weight 1
    grid rowconfigure $top.region_inherit_frame 0 -weight 0

    # put the Boolean expression label, text and scrollbar into the
    # "bool_expr_frame"
    grid $top.combL -sticky "w" -in $top.bool_expr_frame -row 0 -column 0
    grid $top.combT -sticky "nsew" -in $top.bool_expr_frame -row 1 -column 0
    grid $top.combS -sticky "ns" -in $top.bool_expr_frame -row 1 -column 1
    grid rowconfigure $top.bool_expr_frame 0 -weight 0
    grid rowconfigure $top.bool_expr_frame 1 -weight 1
    grid columnconfigure $top.bool_expr_frame 0 -weight 1
    grid columnconfigure $top.bool_expr_frame 1 -weight 0

    # put the control buttons into the "control_buttons_frame"
    grid $top.okB $top.applyB x $top.resetB x $top.dismissB -sticky "ew"\
	    -in $top.control_buttons_frame -pady $comb_control($id,pady)
    grid columnconfigure $top.control_buttons_frame 2 -weight 1
    grid columnconfigure $top.control_buttons_frame 4 -weight 1

    # grid the remaining frames
    grid $top.name_stuff \
         -sticky "ew" \
         -padx $comb_control($id,padx) \
         -pady $comb_control($id,pady) \
         -row 0 -column 0

    grid $top.region_inherit_frame \
         -padx $comb_control($id,padx) \
         -pady $comb_control($id,pady) \
         -sticky new -row 1 -column 0

    grid $my_tabbed_frame \
          -sticky "nsew" \
          -padx $comb_control($id,padx) \
          -pady $comb_control($id,pady) \
          -row 2 -column 0
    grid rowconfigure $my_tabbed_frame 0 -weight 1
    grid columnconfigure $my_tabbed_frame 0 -weight 1

    grid $top.control_buttons_frame \
         -sticky "ew" \
         -padx $comb_control($id,padx) \
         -pady $comb_control($id,pady) \
         -row 3 -column 0

    grid rowconfigure $top 0 -weight 0
    grid rowconfigure $top 2 -weight 1
    grid columnconfigure $top 0 -weight 1

    # start with "Boolean" frame dsplayed
    toggle_bool_shade_frame $id "Bool"

    # handle event when someone presses "Enter"
    # in the combination name entry widget
    bind $top.nameE <Return> "comb_reset $id; break"

    place_near_mouse $top
    wm protocol $top WM_DELETE_WINDOW "catch {comb_dismiss $id $top}"
    wm title $top "Combination Editor ($id)"

}

# called when "OK" is pressed
proc comb_ok {id top} {

    # apply the parameters
    set ret [comb_apply $id]

    if {$ret == 0} {
	# destroy the window
	comb_dismiss $id $top
    }
}

# apply the parameters to the actual combination on disk
proc comb_apply { id } {
    global mged_gui
    global comb_control
    global ::tk::Priv

    set top .$id.comb

    # get the Boolean expression fron the text widget
    set comb_control($id,comb) [$top.combT get 0.0 end]

    # if someone has edited the combination name, take care about
    # overwriting an existing object
    if {$comb_control($id,dirty_name) && [db_exist $comb_control($id,name)]} {
	set ret [cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen)\
		"Warning!"\
		"Warning: about to overwrite $comb_control($id,name)"\
		"" 0 OK Cancel]

	if {$ret} {
	    return 1
	}
    }

    if {$comb_control($id,isRegion)} {

	# this is a region

	if {$comb_control($id,id) < 0} {
	    # region id is less than zero!!!!
	    cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen)\
		    "Bad region id!"\
		    "Region id must be >= 0"\
		    "" 0 OK
	    return 1
	}

	if {$comb_control($id,air) < 0} {
	    # air code is less than zero!!!
	    cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen)\
		    "Bad air code!"\
		    "Air code must be >= 0"\
		    "" 0 OK
	    return 1
	}

	if {$comb_control($id,id) == 0 && $comb_control($id,air) == 0 ||
            $comb_control($id,id) != 0 && $comb_control($id,air) != 0} {
	    # exactly one of region id and air code should be set
	    set ret [cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen)\
		    "Warning: both region id and air code are set/unset"\
		    "Warning: both region id and air code are set/unset"\
		    "" 0 OK Cancel]

	    if {$ret} {
		return 1
	    }
	}

	# get color
	if {$comb_control($id,color) == ""} {
	    set color ""
	} else {
	    set color [getRGBorReset $top.colorMB comb_control($id,color) $comb_control($id,color)]
	}

	# actually apply the edist to the combination on disk
	set ret [catch {put_comb $comb_control($id,name) $comb_control($id,isRegion) \
		$comb_control($id,id) $comb_control($id,air) $comb_control($id,material) \
		$comb_control($id,los) $color $comb_control($id,shader) \
		$comb_control($id,inherit) $comb_control($id,comb)} comb_error]

	if {$ret} {
	    cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) \
		    "comb_apply: Error"\
		    $comb_error\
		    "" 0 OK 
	}

	# set any attributes that we have saved
	set ret [catch {eval attr set $comb_control($id,name) $comb_control($id,attrs) } comb_error ]

	if {$ret} {
	    cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) \
		    "comb_apply: Error"\
		    $comb_error\
		    "" 0 OK 
	}

	return $ret
    }


    # this is not a region

    # get the color
    if {$comb_control($id,color) == ""} {
	set color ""
    } else {
	set color [getRGBorReset $top.colorMB comb_control($id,color) $comb_control($id,color)]
    }

    # actually apply the edits to the combination on disk
    set ret [catch {put_comb $comb_control($id,name) $comb_control($id,isRegion)\
	    $color $comb_control($id,shader) $comb_control($id,inherit)\
	    $comb_control($id,comb)} comb_error]

    if {$ret} {
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) \
		"comb_apply: Error"\
		$comb_error\
		"" 0 OK 
    }

    # set any attributes that we have saved
    set ret [catch {eval attr set $comb_control($id,name) $comb_control($id,attrs) } comb_error ]

    if {$ret} {
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) \
	    "comb_apply: Error"\
	    $comb_error\
	    "" 0 OK 
    }

    return $ret
}

# called when "Reset" button is pressed
# ignores any edits made and restores data from disk
proc comb_reset { id } {
    global mged_gui
    global comb_control
    global ::tk::Priv

    set top .$id.comb

    if {$comb_control($id,name) == ""} {
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen)\
		"You must specify a region/combination name!"\
		"You must specify a region/combination name!"\
		"" 0 OK
	return
    }

    # get the combination data from disk
    set save_isRegion $comb_control($id,isRegion)
    set result [catch {get_comb $comb_control($id,name)} comb_defs]
    if {$result == 1} {
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen)\
		"comb_reset: Error"\
		$comb_defs\
		"" 0 OK
	return
    }

    # get the attributes
    set result [catch {attr get $comb_control($id,name)} comb_attrs]
    if { $result == 1 } {
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen)\
		"comb_reset: Error"\
		$comb_attrs\
		"" 0 OK
	return
    }

    # eliminate attributes that might conflict with changes we make
    set tmp_comb_attrs {}
    set num_attrs [expr [llength $comb_attrs] / 2]
    for { set i $num_attrs } { $i > 0 } { incr i -1 } {
	set key [lindex $comb_attrs [expr ($i - 1) * 2]]
	set keep 1
	if { [string compare $key "region"] == 0 } {
	    set keep 0
	} elseif { [string compare $key "region_id"] == 0 } {
	    set keep 0
	} elseif { [string compare $key "material_id"] == 0 } {
	    set keep 0
	} elseif { [string compare $key "los"] == 0 } {
	    set keep 0
	} elseif { [string compare $key "aircode"] == 0 } {
	    set keep 0
	} elseif { [string compare $key "rgb"] == 0 } {
	    set keep 0
	} elseif { [string compare $key "oshader"] == 0 } {
	    set keep 0
	} elseif { [string compare $key "inherit"] == 0 } {
	    set keep 0
	}

	if { $keep } {
	    lappend tmp_comb_attrs $key [lindex $comb_attrs [expr {($i - 1) * 2 + 1}]]
	}
    }

    # save the attributes
    set comb_control($id,attrs) $tmp_comb_attrs

    set comb_control($id,isRegion) [lindex $comb_defs 1]

    # set all our data variables for the editor
    if {$comb_control($id,isRegion) == "Yes"} {
	if {$result == 2} {
	    # get default values for ident, air, los, and material
	    set defaults [regdef]
	    set default_ident [lindex $defaults 1]
	    set default_air [lindex $defaults 3]
	    set default_los [lindex $defaults 5]
	    set default_material [lindex $defaults 7]

	    set comb_control($id,id) $default_ident
	    set comb_control($id,air) $default_air
	    set comb_control($id,material) $default_material
	    set comb_control($id,los) $default_los
	} else {
	    set comb_control($id,id) [lindex $comb_defs 2]
	    set comb_control($id,air) [lindex $comb_defs 3]
	    set comb_control($id,material) [lindex $comb_defs 4]
	    set comb_control($id,los) [lindex $comb_defs 5]
	}
	set comb_control($id,color) [lindex $comb_defs 6]
	set comb_control($id,shader) [lindex $comb_defs 7]
	set comb_control($id,inherit) [lindex $comb_defs 8]
	set comb_control($id,comb) [lindex $comb_defs 9]
    } else {
	set comb_control($id,color) [lindex $comb_defs 2]
	set comb_control($id,shader) [lindex $comb_defs 3]
	set comb_control($id,inherit) [lindex $comb_defs 4]
	set comb_control($id,comb) [lindex $comb_defs 5]
    }

    if {$comb_control($id,color) == ""} {
	set comb_control($id,color) [$top cget -bg]
	color_entry_update $top color comb_control($id,color) $comb_control($id,color)
	set comb_control($id,color) ""
    } else {
	color_entry_update $top color comb_control($id,color) $comb_control($id,color)
    }

    $top.combT delete 0.0 end
    $top.combT insert end $comb_control($id,comb)

    if {$save_isRegion != $comb_control($id,isRegion)} {
	comb_toggle_isRegion $id
    }

    if { [llength $comb_control($id,shader)] > 0 } {
	set comb_control($id,shader_gui) [do_shader comb_control($id,shader) $id \
		$comb_control($id,shader_frame)]
	grid $comb_control($id,shader_frame) \
		-row 1 \
		-sticky "nsew" \
		-in $top.shader_top_frame \
		-padx $comb_control($id,padx) \
		-pady $comb_control($id,pady)
	grid rowconfigure $top.shader_top_frame 0 -weight 0
	grid rowconfigure $top.shader_top_frame 1 -weight 1
	grid columnconfigure $top.shader_top_frame 0 -weight 1
	grid columnconfigure $top.shader_frame 0 -weight 1
    } else {
	grid forget $comb_control($id,shader_frame)
	catch { destroy $comb_control($id,shader_gui) }
    }

    set comb_control($id,dirty_name) 0
}

# called when "Dismiss" button is pressed
proc comb_dismiss {id top} {
    global comb_control

    # destroy it all
    catch {destroy $top}
    catch {destroy $comb_control($id,shader_gui)}
    trace vdelete comb_control($id,name) w "comb_handle_trace $id"
}

# called when "Is Region" checkbutton is pressed
proc comb_toggle_isRegion { id } {
    global comb_control

    set top .$id.comb
    grid remove $top.id_los_air_mater

    if {$comb_control($id,isRegion) == "Yes"} {
	grid $top.id_los_air_mater -in $comb_control($id,bool_frame) \
	    -padx $comb_control($id,padx) \
	    -pady $comb_control($id,pady) \
	    -sticky new -row 0 -column 0
    } else {
	grid forget $top.id_los_air_mater
    }
}

proc comb_shader_gui { id shader_type } {
    global comb_control

    set top .$id.comb
    set current_shader_type [lindex $comb_control($id,shader) 0]

    if { $current_shader_type != $shader_type } {
	set comb_control($id,shader) $shader_type
    }

    set comb_control($id,shader_gui) [do_shader comb_control($id,shader) $id \
	    $comb_control($id,shader_frame)]
    grid $comb_control($id,shader_frame) \
	    -row 1 \
	    -sticky "nsew" \
	    -in $top.shader_top_frame \
	    -padx $comb_control($id,padx) \
	    -pady $comb_control($id,pady)

    grid rowconfigure $top.shader_top_frame 0 -weight 0
    grid rowconfigure $top.shader_top_frame 1 -weight 1
    grid columnconfigure $top.shader_top_frame 0 -weight 1
    grid columnconfigure $top.shader_frame 0 -weight 1
}

proc db_exist {obj} {
    set ret [catch {db get $obj}]
    if {$ret} {
	return 0
    } else {
	return 1
    }
}

# mark name as dirty if someone edits it
proc comb_handle_trace {id name1 name2 op} {
    global comb_control

    set comb_control($id,dirty_name) 1
}

#proc comb_select_material { id } {
#    global mged_gui
#    global comb_control
#
#    set top .$id.sel_material
#
#    if [winfo exists $top] {
#	raise $top
#	return
#    }
#
#    toplevel $top -screen $mged_gui($id,screen)
#
#    frame $top.gridF1
#    frame $top.gridF3
#    frame $top.gridF4 -relief groove -bd 2
#
#    listbox $top.materialLB -selectmode single -yscrollcommand "$top.materialS set"
#    scrollbar $top.materialS -relief flat -command "$top.materialLB yview"
#
#    label $top.materialL -text "Material List:" -anchor w
#    entry $top.materialE -width 12 -textvar comb_control($id,material_list)
#
#    button $top.resetB -relief raised -text "Reset"\
#	    -command "load_material $id"
#    button $top.dismissB -relief raised -text "Dismiss"\
#	    -command "catch { destroy $top }"
#
#    grid $top.materialLB $top.materialS -sticky "nsew" -in $top.gridF
#    grid rowconfigure $top.gridF1 0 -weight 1
#    grid columnconfigure $top.gridF1 0 -weight 1
#
#    grid $top.materialL x -sticky "ew" -in $top.gridF3
#    grid $top.materialE $top.resetB -sticky "nsew" -in $top.gridF3
#    grid columnconfigure $top.gridF3 0 -weight 1
#
#    grid $top.dismissB -in $top.gridF4 -pady $comb_control($id,pady)
#
#    grid $top.gridF1 -sticky "nsew" -padx $comb_control($id,padx) -pady $comb_control($id,pady)
#    grid $top.gridF3 -sticky "ew" -padx $comb_control($id,padx) -pady $comb_control($id,pady)
#    grid $top.gridF4 -sticky "ew"
#    grid rowconfigure $top 0 -weight 1
#    grid columnconfigure $top 0 -weight 1
#
#    wm title $top "Select Material"
#}
#
#proc load_material { id } {
#    global comb_control
#}
@


1.47
log
@Added explanation of widget hierarchy
@
text
@@


1.46
log
@changes to make the UI a bit more compact
@
text
@d8 136
@


1.45
log
@Now uses a button to select whether the Boolean expression or Shader stuff is displayed
(Not using tabbed notebook because it dos not respond correctly to changing contents)
@
text
@d9 3
d14 2
a15 1
proc toggle_my_tab { id which_frame } {
d20 5
a24 2
	grid forget $top.my_tabbed.shade_frame
	grid $top.my_tabbed.bool_frame -sticky nsew
d26 5
a30 5
	grid forget $top.my_tabbed.bool_frame
	grid $top.my_tabbed.shade_frame -sticky nsew
	grid rowconfigure $top.my_tabbed.shade_frame 0 -weight 0
	grid rowconfigure $top.my_tabbed.shade_frame 1 -weight 1
	grid columnconfigure $top.my_tabbed.shade_frame 0 -weight 1
d34 6
d53 1
d56 1
d86 1
d90 5
a94 2
    # set this variable to one to use the tabbed notebook version
    set use_notebook 0
d96 14
a109 1
    toplevel $top -screen $mged_gui($id,screen)
d111 4
a114 17
    set my_tabbed_frame [frame $top.my_tabbed]
    set bool_frame [frame $my_tabbed_frame.bool_frame -relief raised -bd 3]
    set shade_frame [frame $my_tabbed_frame.shade_frame -relief raised -bd 3]
    set tabs_frame [frame $my_tabbed_frame.tabs_frame]
    set comb_control($id,which_frame) "Bool"
    set bool_but_frame [frame $tabs_frame.bool_but_frame -relief groove -borderwidth 3]
    radiobutton $bool_but_frame.show_bool -value "Bool" \
	-variable comb_control($id,which_frame) \
	-command "toggle_my_tab $id Bool"
    label $bool_but_frame.bool_label -text "Show Boolean"
    set shade_but_frame [frame $tabs_frame.shade_but_frame -relief groove -borderwidth 3]
    radiobutton $shade_but_frame.show_shade -value "Shade" \
	-variable comb_control($id,which_frame) \
	-command "toggle_my_tab $id Shade"
    label $shade_but_frame.shade_label -text "Show Shader"
    grid $bool_but_frame.bool_label $bool_but_frame.show_bool
    grid $shade_but_frame.shade_label $shade_but_frame.show_shade
d116 1
d118 2
d121 6
a126 1
    frame $top.color_frame 
d128 3
d132 3
d136 2
d139 3
d143 9
a151 2
    frame $top.shader_label_entry_frame 
    frame $top.shader_frame 
d154 1
d156 3
a159 1
    set shader_params($id,window) $comb_control($id,shader_frame)
d161 32
d201 2
d205 2
d212 2
d215 2
d268 1
d278 2
d283 1
d293 2
d298 1
d306 2
d311 1
d321 2
d326 1
d333 2
d342 1
d349 2
d354 3
d359 1
d367 2
d374 2
d446 2
d453 1
d468 2
d474 2
d478 1
d482 4
a485 4
    hoc_register_data $top.isRegionCB "Is Region"\
	    { { summary "Toggle the region flag on/off. If the
region flag is toggled on (i.e. checkbutton
is highligted) the GUI reconfigures itself to
d491 4
a494 2
also required to be homogeneous (i.e. consisting
of the same material)." } }
d502 1
a502 1
no effect (i.e. the members of a region
d504 1
a504 1
region)." } }
d506 1
d568 12
a579 6
    grid $top.colorL $top.colorF \
	    -sticky "e" -in $top.color_frame -pady $comb_control($id,pady)

    grid columnconfigure $top.color_frame 1 -weight 100
    grid columnconfigure $top.color_frame 2 -weight 1
    grid columnconfigure $top.color_frame 4 -weight 100
d581 2
d588 10
a597 3
    grid $top.shaderL $top.shader_entry_and_menu_frame \
	    -sticky "ew" \
	    -in $top.shader_label_entry_frame
d600 1
d602 1
a602 1
	    -sticky "ew" \
d606 3
d611 1
a611 1
    # puts color frame into "Shader" notebook page
d615 3
a617 1
             -sticky nw -row 0 -column 0
d627 19
a645 3
    grid $top.isRegionCB $top.inheritCB x -sticky "ew" -in $top.region_inherit_frame\
	    -ipadx 4 -ipady 4
    grid columnconfigure $top.region_inherit_frame 2 -weight 1
d647 2
d657 1
d663 1
a674 3
    grid $bool_but_frame x  x $shade_but_frame -sticky nw
    grid $tabs_frame -sticky nw
    toggle_my_tab $id $comb_control($id,which_frame)
d680 1
a680 1
    grid rowconfigure $my_tabbed_frame 1 -weight 1
d693 5
d706 1
d708 2
d713 1
d718 1
d725 2
d729 2
d743 3
d747 1
d756 1
d766 1
d777 1
d784 1
d797 1
d810 4
d820 1
d831 2
a832 1
    
d845 2
d862 1
d873 1
d912 1
d917 1
d968 1
a968 1
		-sticky "ew" \
d972 4
d984 1
d988 1
d994 1
d1002 1
a1002 1
	grid $top.id_los_air_mater -in $top.my_tabbed.bool_frame \
d1025 1
a1025 1
	    -sticky "ew" \
d1029 5
d1045 1
@


1.45.2.1
log
@updated for merging
@
text
@a7 139
# This is the widget hierarchy from the top level down to the shader frames or Boolean
# expression frames
# 
# widget names include $id to make them unique. Typically, $id == "id_0"
# 
# Top level combination editor widget: $id.comb
# 
# slaves:
# 	.id_0.comb.control_buttons_frame
# 		frame for control buttons (OK, Apply, Reset, Dismiss)
# 	.id_0.comb.my_tabbed
# 		frame for holding the Boolean or Shader stuff
# 	.id_0.comb.region_inherit_frame
# 		frame for "Is Region" and "Inherit" as well as button to
# 		switch between Boolean and shader displays
# 	.id_0.comb.name_stuff
# 		frame for combination label, name and menubutton
# 
# -------------------------------------------------
# .id_0.comb.my_tabbed
# 
# 	This frame is just a holder for either the Boolean stuff or the shader stuff
# 
# slaves:
# 	.id_0.comb.my_tabbed.bool_labeled
# 			or
# 	.id_0.comb.my_tabbed.shader_labeled
# 
# -------------------------------------------------
# .id_0.comb.my_tabbed.bool_labeled.childsite
# 
# 	This frame is a childsite of the ".id_0.comb.my_tabbed.bool_labeled" mentioned above
# 	This frame is only mapped when the Boolean expression is displayed.
# 
# slaves:
# 	.id_0.comb.id_los_air_mater
# 		frame containing the region id, air code, material id, and LOS
# 		This frame is toggled on and off using the "Is Region" checkbutton
# 
# 	.id_0.comb.bool_expr_frame
# 		Frame for the Boolean expression. Contains a label, scrollbar,
# 		and text widget.
# 
# -------------------------------------------------
# .id_0.comb.my_tabbed.shader_labeled.childsite
# 	This frame is the childsite of the ".id_0.comb.my_tabbed.shader_labeled"
# 	mentioned above. This frame is only mapped when the shader is displayed.
# slaves:
# 
# 	.id_0.comb.color_frame
# 		frame for the color label, entry, and menubutton
# 	.id_0.comb.shader_top_frame
# 		frame for the shader stuff
# 
# -------------------------------------------------
# .id_0.comb.shader_top_frame
# slaves:
# 	.id_0.comb.shader_label_entry_frame
# 		frame for the shader label, entry, and menubutton
# 	.id_0.comb.shader_frame
# 		frame for the individual shaders to fill
# 		this frame is passed by "do_shade" to the shaders
# 
# -------------------------------------------------
# .id_0.comb.shader_frame
# slaves:
# 	.id_0.comb.shader_frame.fr
# 		frame created by an individual shader to hold all its stuff
# 
# -------------------------------------------------
# .id_0.comb.shader_frame.fr
# slaves:
# 	For the typical shader, the slaves of this frame are the individual
# 	labels, buttons, checkbuttons, entry widgets, menubuttons, etc, for
# 	that particular shader. This is the end of the hierarchy for simple
# 	shaders. From here down, the discussion only relates to the "stack"
# 	shader
# 
# 	For the "stack" shader, the slaves of this frame are:
# 
# 	.id_0.comb.shader_frame.fr.add
# 		frame for the "Add shader" button
# 	.id_0.comb.shader_frame.fr.leesf
# 		scrolledframe to hold all the stacked shaders
# 
# -------------------------------------------------
# .id_0.comb.shader_frame.fr.leesf
# slaves:
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite
# 		frame internal to the scrolledframe
# 
# -------------------------------------------------
# .id_0.comb.shader_frame.fr.leesf.lwchildsite
# slaves:
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.vertsb
# 		vertical scrollbar for scrolledframe
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.horizsb
# 		horizontal scrollbar (dynamic)
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper
# 		frame internal to scrolledframe
# 
# -------------------------------------------------
# .id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper
# slaves:
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas
# 		another object internal to the scrolledframe widget
# 
# -------------------------------------------------
# .id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas.sfchildsite
# 	This frame is the actual childsite provided by the scrolledframe widget "leesf"
# 	It will contain a "stack" of frames, one for each shader currently
# 	in the stack
# 
# slaves:
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas.sfchildsite.stk_1
# 		frame for first stacked shader
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas.sfchildsite.stk_2
# 		frame for second stacked shader
# 	.
# 	.
# 	.
# 
# -------------------------------------------------
# .id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas.sfchildsite.stk_1
# 	This is a frame for an individual shader in the stack
# 
# slaves:
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas.sfchildsite.stk_1.del
# 		The delete button for this shader
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas.sfchildsite.stk_1.lab
# 		The label identifying which type of shader this one is
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas.sfchildsite.stk_1.fr
# 		The frame where the actual buttons, label, entries, etc for this
# 		particular shader located.
# 


# We use the Labeledframe from Iwidgets
package require Iwidgets
d11 1
a11 2
# this routine displays "which_frame" ("Bool" or "Shade") and forgets the other
proc toggle_bool_shade_frame { id which_frame } {
d16 2
a17 5
	grid forget $top.my_tabbed.shader_labeled
	grid $top.my_tabbed.bool_labeled -sticky nsew
	$top.region_inherit_frame.bool_shade_b configure \
	    -text "Show Shader" \
	    -command "toggle_bool_shade_frame $id Shade"
d19 5
a23 5
	grid forget $top.my_tabbed.bool_labeled
	grid $top.my_tabbed.shader_labeled -sticky nsew
	$top.region_inherit_frame.bool_shade_b configure \
	    -text "Show Boolean" \
	    -command "toggle_bool_shade_frame $id Bool"
a26 6
# top level interface to the combination editor
#
# Creates a top level window containing (among other widgets) two
# labeledframes, one for the Boolean expression and one for shader stuff.
# Only one of these frames is visible at any one time
#
a39 1
    # name of our top level window
a41 1
    # if we already have such a window, just pop it up
a70 1
    # invoke a handler whenever the combination name is changed
d74 3
a76 1
    # create our top level window
d79 17
a95 22
    # create a frame to hold either of the labeledframes
    set my_tabbed_frame [frame $top.my_tabbed -relief flat]

    # create the two labeledframes
    iwidgets::Labeledframe $my_tabbed_frame.shader_labeled -labeltext "Shader"
    iwidgets::Labeledframe $my_tabbed_frame.bool_labeled -labeltext "Boolean"

    # get the childsites (frames) of the labeledframes
    # store them in the "comb_control" array for global access
    set bool_frame [$my_tabbed_frame.bool_labeled childsite]
    set comb_control($id,bool_frame) $bool_frame
    set shade_frame [$my_tabbed_frame.shader_labeled childsite]
    
    # row 0 is just the color
    # row 1 is the actual frame containing the shader stuff
    grid rowconfigure $shade_frame 0 -weight 0
    grid rowconfigure $shade_frame 1 -weight 1

    # strange, but it appears that the childsite in this labeledframe
    # is in column 1 ?????
    grid columnconfigure $top.my_tabbed.shader_labeled 0 -weight 0
    grid columnconfigure $top.my_tabbed.shader_labeled 1 -weight 1
a96 1
    # frame to hold the combination name, entry widget, and menunutton
a97 2

    # frame to hold the region id, los, air code, and GIFT material code
d99 1
a99 6

    # frame to hold the color label and the "colorF" frame (created by
    # "color_entry_build")
    frame $top.color_frame

    # frame to contain all the shader stuff
a100 3

    # frame to hold the display selection menubutton, the "IsRegion",
    # checkbutton, and the "Inherit" checkbutton
a101 3

    # frame to hold the label, text and scrollbar widgets for the
    # Boolean expression
a102 2

    # frame to hold the control buttons (Apply, dismiss, ...)
a103 3

    # frame to hold the region name entry and menubutton widgets
    # this frame sits in the "name_stuff" frame above
d105 2
a106 9

    # frame to hold the shader label, entry, and menubutton widgets
    frame $top.shader_label_entry_frame

    # empty frame to pass to the shader routines (in "shaders.tcl")
    frame $top.shader_frame

    # frame to hold the shader entry and menubutton widgets
    # this frame sits in the "shader_label_entry_frame" above
a108 1
    # arrange for global access
d110 1
a112 35
    # initialize name of shader
    set shader_params($id,shader_name) ""

    # create the button that will choose whether the "Boolean" or
    # "Shader" frame is displayed
    set bool_shade_b [button $top.region_inherit_frame.bool_shade_b \
			  -text "Show Shader" \
			  -command "toggle_bool_shade_frame $id Bool"]
    if { 0 } {
    set bool_shade_mb [menubutton $top.region_inherit_frame.bool_shade_menuB \
			   -text "Select View" \
			   -indicatoron true \
			   -relief raised]

    # create menu for above menubutton
    menu $bool_shade_mb.menu -tearoff false
    $bool_shade_mb.menu add command \
	-label "Show Boolean" \
	-command "toggle_bool_shade_frame $id Bool"
    $bool_shade_mb.menu add command \
	-label "Show Shader" \
	-command "toggle_bool_shade_frame $id Shade"
    $bool_shade_mb configure -menu $bool_shade_mb.menu

    # help for above menubutton
    set hoc_data { { summary "Use this button to select whether the Boolean
expression or the Shader parameters is displayed" } }
    hoc_register_data $bool_shade_mb "Select View" $hoc_data
    }

    set hoc_data { { summary "Use this button to select whether the Boolean
expression or the Shader parameters is displayed" } }
    hoc_register_data $bool_shade_b "Select View" $hoc_data

    # create label for combination name
a120 2

    # create entry widget for combination name
a122 2

    # create menubutton for selecting combination
a127 2

    # create menu for above menubutton
a128 2

    # add menu items
a179 1
    # create label for region id
a188 2

    # create entry widget for region id
a191 1
    # create label for air code
a200 2

    # create entry widget for air code
a203 1
    # create label for material code
a210 2

    # create entry widget for material code
a213 1
    # create label for LOS
a222 2

    # create entry widget for LOS
a225 1
    # create label for color
a231 2

    # create a color entry widget and a color menubutton
a238 1
    # create "shader" label
a244 2

    # create entry widget for shader string
a247 3
    # whenever any key is released inside the shader entry widget.
    # call "set_shader_params" to update the shader display
    # (see "shaders.tcl" for this routine)
a249 1
    # create menubutton to select from all the shaders
a256 2

    # create menu for above menubutton
a261 2

    # add all the shaders to the above menu
a331 2

    # allow for the possiblity that a shader exists that is not in the above list
a336 1
    # create label for Boolean expression
a350 2

    # create text widget to hold the Boolean expression
a354 2

    # may need a vertical scrollbar for complex expressions
a356 1
    # create "Is Region" checkbutton
d360 4
a363 4
    hoc_register_data $top.isRegionCB "Is Region" \
	{ { summary "Toggle the region flag on/off. If the
region flag is toggled on \(i.e. checkbutton
is highligted\) the GUI reconfigures itself to
d369 2
a370 4
also required to be homogeneous \(i.e. consisting
of the same material\)." } }

    # create "Inherit" checkbutton
d378 1
a378 1
no effect \(i.e. the members of a region
d380 1
a380 1
region\)." } }
a381 1
    # create the control buttons (OK, Apply, ...)
d443 6
a448 12
    # put the color label and the frame built by
    # "color_entry_build" into "color_frame"
    grid $top.colorL \
            -row 0 -column 0 \
	    -sticky "e" \
            -in $top.color_frame \
            -pady $comb_control($id,pady)
    grid $top.colorF \
            -row 0 -column 1 \
	    -sticky "w" \
            -in $top.color_frame \
            -pady $comb_control($id,pady)
a449 2
    # puts shader entry widget and shader selector menubutton into the
    # "shader_entry_and_menu_frame"
d455 3
a457 10
    # combine the above frame and the shader label
    # into  the "shader_label_entry_frame"
    grid $top.shaderL \
	-row 0 -column 0 \
	-sticky "e" \
	-in $top.shader_label_entry_frame
    grid $top.shader_entry_and_menu_frame \
	-row 0 -column 1 \
	-sticky "ew" \
	-in $top.shader_label_entry_frame
a459 1
    # puts the above frame in the "shader_top_frame"
d461 1
a461 1
	    -sticky "new" \
a464 3

    grid rowconfigure $top.shader_top_frame 0 -weight 0
    grid rowconfigure $top.shader_top_frame 1 -weight 1
d467 1
a467 1
    # puts color frame into "Shader" labeledframe
d471 1
a471 3
             -sticky new -row 0 -column 0

    # add the actual shader frame to the "Shader" labeledframe
d481 3
a483 19
    # grid the "Shader labeledframe childsite frame
    grid $shade_frame -sticky nsew

    # put the display selection menubutton, the "Is Region" checkbutton,
    # and the "Inherit" checkbutton in the "region_inherit_frame"
    grid $bool_shade_b \
            -row 0 -column 0 \
            -sticky "w" \
            -in $top.region_inherit_frame
    grid $top.isRegionCB \
            -row 0 -column 2 \
            -sticky "nse" \
            -in $top.region_inherit_frame
    grid $top.inheritCB \
            -row 0 -column 3 \
            -sticky "nse" \
            -in $top.region_inherit_frame
    grid columnconfigure $top.region_inherit_frame 1 -weight 1
    grid rowconfigure $top.region_inherit_frame 0 -weight 0
a484 2
    # put the Boolean expression label, text and scrollbar into the
    # "bool_expr_frame"
a492 1
    # put the control buttons into the "control_buttons_frame"
a497 1
    # grid the remaining frames
d509 3
d517 1
a517 1
    grid rowconfigure $my_tabbed_frame 0 -weight 1
a529 5
    # start with "Boolean" frame dsplayed
    toggle_bool_shade_frame $id "Bool"

    # handle event when someone presses "Enter"
    # in the combination name entry widget
a537 1
# called when "OK" is pressed
a538 2

    # apply the parameters
a541 1
	# destroy the window
a545 1
# apply the parameters to the actual combination on disk
a551 2

    # get the Boolean expression fron the text widget
a553 2
    # if someone has edited the combination name, take care about
    # overwriting an existing object
a565 3

	# this is a region

a566 1
	    # region id is less than zero!!!!
a574 1
	    # air code is less than zero!!!
a583 1
	    # exactly one of region id and air code should be set
a593 1
	# get color
a599 1
	# actually apply the edist to the combination on disk
a611 1
	# set any attributes that we have saved
a623 4

    # this is not a region

    # get the color
a629 1
    # actually apply the edits to the combination on disk
d640 1
a640 2

    # set any attributes that we have saved
a652 2
# called when "Reset" button is pressed
# ignores any edits made and restores data from disk
a667 1
    # get the combination data from disk
a677 1
    # get the attributes
a715 1
    # save the attributes
a719 1
    # set all our data variables for the editor
d770 1
a770 1
		-sticky "nsew" \
a773 4
	grid rowconfigure $top.shader_top_frame 0 -weight 0
	grid rowconfigure $top.shader_top_frame 1 -weight 1
	grid columnconfigure $top.shader_top_frame 0 -weight 1
	grid columnconfigure $top.shader_frame 0 -weight 1
a781 1
# called when "Dismiss" button is pressed
a784 1
    # destroy it all
a789 1
# called when "Is Region" checkbutton is pressed
d797 1
a797 1
	grid $top.id_los_air_mater -in $comb_control($id,bool_frame) \
d820 1
a820 1
	    -sticky "nsew" \
a823 5

    grid rowconfigure $top.shader_top_frame 0 -weight 0
    grid rowconfigure $top.shader_top_frame 1 -weight 1
    grid columnconfigure $top.shader_top_frame 0 -weight 1
    grid columnconfigure $top.shader_frame 0 -weight 1
a834 1
# mark name as dirty if someone edits it
@


1.44
log
@*** empty log message ***
@
text
@d11 16
d28 1
d74 3
d79 29
a107 14
    frame $top.gridF1
    frame $top.gridF2 -relief groove -bd 2
    frame $top.gridF3
    frame $top.gridF4
    frame $top.gridF5
    frame $top.nameF -relief sunken -bd 2
    frame $top.idF -relief sunken -bd 2
    frame $top.airF -relief sunken -bd 2
    frame $top.materialF -relief sunken -bd 2
    frame $top.losF -relief sunken -bd 2
    frame $top.shaderF1
    frame $top.shaderF2
    frame $top.shaderEF -relief sunken -bd 2
    frame $top.combF
d109 1
a109 1
    set comb_control($id,shader_frame) $top.shaderF2
d121 1
a121 1
    entry $top.nameE -relief flat -width 12 -textvar comb_control($id,name)
d180 1
a180 1
    label $top.idL -text "Region Id" -anchor e
d189 1
a189 1
    entry $top.idE -relief flat -width 12 -textvar comb_control($id,id)
d192 1
a192 1
    label $top.airL -text "Air Code" -anchor e
d201 1
a201 1
    entry $top.airE -relief flat -width 12 -textvar comb_control($id,air)
d204 1
a204 1
    label $top.materialL -text "Material Id" -anchor e
d211 1
a211 1
    entry $top.materialE -relief flat -width 12 -textvar comb_control($id,material)
d214 1
a214 1
    label $top.losL -text "LOS" -anchor e
d223 1
a223 1
    entry $top.losE -relief flat -width 12 -textvar comb_control($id,los)
d403 46
a448 22
    grid $top.nameE $top.nameMB -sticky "ew" -in $top.nameF
    grid columnconfigure $top.nameF 0 -weight 1
    grid $top.idE -sticky "ew" -in $top.idF
    grid columnconfigure $top.idF 0 -weight 1
    grid $top.nameL $top.nameF x $top.idL $top.idF \
	    -sticky "ew" -in $top.gridF1 -pady $comb_control($id,pady)

    grid $top.airE -sticky "ew" -in $top.airF
    grid columnconfigure $top.airF 0 -weight 1
    grid $top.colorL $top.colorF x $top.airL $top.airF \
	    -sticky "ew" -in $top.gridF1 -pady $comb_control($id,pady)

    grid $top.materialE -sticky "ew" -in $top.materialF
    grid columnconfigure $top.materialF 0 -weight 1
    grid $top.losE -sticky "ew" -in $top.losF
    grid columnconfigure $top.losF 0 -weight 1
    grid $top.materialL $top.materialF x $top.losL $top.losF \
	    -sticky "ew" -in $top.gridF1 -pady $comb_control($id,pady)

    grid columnconfigure $top.gridF1 1 -weight 100
    grid columnconfigure $top.gridF1 2 -weight 1
    grid columnconfigure $top.gridF1 4 -weight 100
d452 2
a453 2
	    -in $top.shaderEF
    grid columnconfigure $top.shaderEF 0 -weight 1
d455 1
a455 1
    grid $top.shaderL $top.shaderEF \
d457 2
a458 2
	    -in $top.shaderF1
    grid columnconfigure $top.shaderF1 1 -weight 1
d460 1
a460 1
    grid $top.shaderF1 \
d462 1
a462 1
	    -in $top.gridF2\
d465 1
a465 6
#    grid $top.shaderF2 \
#	    -sticky "ew" \
#	    -in $top.gridF2 \
#	    -padx $comb_control($id,padx) \
#	    -pady $comb_control($id,pady)
    grid columnconfigure $top.gridF2 0 -weight 1
d467 15
a481 1
    grid $top.isRegionCB $top.inheritCB x -sticky "ew" -in $top.gridF3\
d483 1
a483 1
    grid columnconfigure $top.gridF3 2 -weight 1
d485 7
a491 4
    grid $top.combL x -sticky "w" -in $top.gridF4
    grid $top.combT $top.combS -sticky "nsew" -in $top.gridF4
    grid rowconfigure $top.gridF4 1 -weight 1
    grid columnconfigure $top.gridF4 0 -weight 1
d494 34
a527 10
	    -in $top.gridF5 -pady $comb_control($id,pady)
    grid columnconfigure $top.gridF5 2 -weight 1
    grid columnconfigure $top.gridF5 4 -weight 1

    grid $top.gridF1 -sticky "ew" -padx $comb_control($id,padx) -pady $comb_control($id,pady)
    grid $top.gridF2 -sticky "ew" -padx $comb_control($id,padx) -pady $comb_control($id,pady)
    grid $top.gridF3 -sticky "ew" -padx $comb_control($id,padx) -pady $comb_control($id,pady)
    grid $top.gridF4 -sticky "nsew" -padx $comb_control($id,padx) -pady $comb_control($id,pady)
    grid $top.gridF5 -sticky "ew" -padx $comb_control($id,padx) -pady $comb_control($id,pady)
    grid rowconfigure $top 3 -weight 1
d535 1
d771 1
a771 1
		-in $top.gridF2 \
d794 1
a794 1
    grid remove $top.gridF1
d797 4
a800 32
	grid forget $top.nameL $top.nameF $top.colorL $top.colorF

	frame $top.idF -relief sunken -bd 2
	label $top.idL -text "Region Id" -anchor w
	entry $top.idE -relief flat -width 12 -textvar comb_control($id,id)
	grid $top.idE -sticky "ew" -in $top.idF
	grid columnconfigure $top.idF 0 -weight 1

	frame $top.airF -relief sunken -bd 2
	label $top.airL -text "Air Code" -anchor w
	entry $top.airE -relief flat -width 12 -textvar comb_control($id,air)
	grid $top.airE -sticky "ew" -in $top.airF
	grid columnconfigure $top.airF 0 -weight 1

	frame $top.materialF -relief sunken -bd 2
	label $top.materialL -text "Material" -anchor w
	entry $top.materialE -relief flat -width 12 -textvar comb_control($id,material)
	grid $top.materialE -sticky "ew" -in $top.materialF
	grid columnconfigure $top.materialF 0 -weight 1

	frame $top.losF -relief sunken -bd 2
	label $top.losL -text "LOS" -anchor w
	entry $top.losE -relief flat -width 12 -textvar comb_control($id,los)
	grid $top.losE -sticky "ew" -in $top.losF
	grid columnconfigure $top.losF 0 -weight 1

	grid $top.nameL $top.nameF x $top.idL $top.idF \
		-sticky "ew" -in $top.gridF1 -pady $comb_control($id,pady)
	grid $top.colorL $top.colorF x $top.airL $top.airF \
		-sticky "ew" -in $top.gridF1 -pady $comb_control($id,pady)
	grid $top.materialL $top.materialF x $top.losL $top.losF \
		-sticky "ew" -in $top.gridF1 -pady $comb_control($id,pady)
d802 1
a802 14
	grid forget $top.nameL $top.nameF \
		$top.idL $top.idF \
		$top.colorL $top.colorF \
		$top.airL $top.airF \
		$top.materialL $top.materialF \
		$top.losL $top.losF

	destroy $top.idL $top.idE $top.idF \
		$top.airL $top.airE $top.airF \
		$top.materialL $top.materialE $top.materialF\
		$top.losL $top.losE $top.losF

	grid $top.nameL $top.nameF x $top.colorL $top.colorF \
		-sticky "ew" -row 0 -in $top.gridF1 -pady $comb_control($id,pady)
a803 2

    grid $top.gridF1 -row 0
d821 1
a821 1
	    -in $top.gridF2 \
@


1.43
log
@"temp" is no longer a "reserved" attribute
@
text
@d15 1
a15 1
    global tkPriv
d18 1
a18 1
	cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "No database." \
d453 1
a453 1
    global tkPriv
d459 1
a459 1
	set ret [cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen)\
d471 1
a471 1
	    cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen)\
d479 1
a479 1
	    cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen)\
d488 1
a488 1
	    set ret [cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen)\
d510 1
a510 1
	    cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) \
d519 1
a519 1
	    cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) \
d539 1
a539 1
	cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) \
d548 1
a548 1
	cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) \
d560 1
a560 1
    global tkPriv
d565 1
a565 1
	cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen)\
d575 1
a575 1
	cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen)\
d584 1
a584 1
	cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen)\
@


1.43.4.1
log
@sync branch with HEAD
@
text
@a7 139
# This is the widget hierarchy from the top level down to the shader frames or Boolean
# expression frames
# 
# widget names include $id to make them unique. Typically, $id == "id_0"
# 
# Top level combination editor widget: $id.comb
# 
# slaves:
# 	.id_0.comb.control_buttons_frame
# 		frame for control buttons (OK, Apply, Reset, Dismiss)
# 	.id_0.comb.my_tabbed
# 		frame for holding the Boolean or Shader stuff
# 	.id_0.comb.region_inherit_frame
# 		frame for "Is Region" and "Inherit" as well as button to
# 		switch between Boolean and shader displays
# 	.id_0.comb.name_stuff
# 		frame for combination label, name and menubutton
# 
# -------------------------------------------------
# .id_0.comb.my_tabbed
# 
# 	This frame is just a holder for either the Boolean stuff or the shader stuff
# 
# slaves:
# 	.id_0.comb.my_tabbed.bool_labeled
# 			or
# 	.id_0.comb.my_tabbed.shader_labeled
# 
# -------------------------------------------------
# .id_0.comb.my_tabbed.bool_labeled.childsite
# 
# 	This frame is a childsite of the ".id_0.comb.my_tabbed.bool_labeled" mentioned above
# 	This frame is only mapped when the Boolean expression is displayed.
# 
# slaves:
# 	.id_0.comb.id_los_air_mater
# 		frame containing the region id, air code, material id, and LOS
# 		This frame is toggled on and off using the "Is Region" checkbutton
# 
# 	.id_0.comb.bool_expr_frame
# 		Frame for the Boolean expression. Contains a label, scrollbar,
# 		and text widget.
# 
# -------------------------------------------------
# .id_0.comb.my_tabbed.shader_labeled.childsite
# 	This frame is the childsite of the ".id_0.comb.my_tabbed.shader_labeled"
# 	mentioned above. This frame is only mapped when the shader is displayed.
# slaves:
# 
# 	.id_0.comb.color_frame
# 		frame for the color label, entry, and menubutton
# 	.id_0.comb.shader_top_frame
# 		frame for the shader stuff
# 
# -------------------------------------------------
# .id_0.comb.shader_top_frame
# slaves:
# 	.id_0.comb.shader_label_entry_frame
# 		frame for the shader label, entry, and menubutton
# 	.id_0.comb.shader_frame
# 		frame for the individual shaders to fill
# 		this frame is passed by "do_shade" to the shaders
# 
# -------------------------------------------------
# .id_0.comb.shader_frame
# slaves:
# 	.id_0.comb.shader_frame.fr
# 		frame created by an individual shader to hold all its stuff
# 
# -------------------------------------------------
# .id_0.comb.shader_frame.fr
# slaves:
# 	For the typical shader, the slaves of this frame are the individual
# 	labels, buttons, checkbuttons, entry widgets, menubuttons, etc, for
# 	that particular shader. This is the end of the hierarchy for simple
# 	shaders. From here down, the discussion only relates to the "stack"
# 	shader
# 
# 	For the "stack" shader, the slaves of this frame are:
# 
# 	.id_0.comb.shader_frame.fr.add
# 		frame for the "Add shader" button
# 	.id_0.comb.shader_frame.fr.leesf
# 		scrolledframe to hold all the stacked shaders
# 
# -------------------------------------------------
# .id_0.comb.shader_frame.fr.leesf
# slaves:
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite
# 		frame internal to the scrolledframe
# 
# -------------------------------------------------
# .id_0.comb.shader_frame.fr.leesf.lwchildsite
# slaves:
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.vertsb
# 		vertical scrollbar for scrolledframe
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.horizsb
# 		horizontal scrollbar (dynamic)
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper
# 		frame internal to scrolledframe
# 
# -------------------------------------------------
# .id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper
# slaves:
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas
# 		another object internal to the scrolledframe widget
# 
# -------------------------------------------------
# .id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas.sfchildsite
# 	This frame is the actual childsite provided by the scrolledframe widget "leesf"
# 	It will contain a "stack" of frames, one for each shader currently
# 	in the stack
# 
# slaves:
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas.sfchildsite.stk_1
# 		frame for first stacked shader
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas.sfchildsite.stk_2
# 		frame for second stacked shader
# 	.
# 	.
# 	.
# 
# -------------------------------------------------
# .id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas.sfchildsite.stk_1
# 	This is a frame for an individual shader in the stack
# 
# slaves:
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas.sfchildsite.stk_1.del
# 		The delete button for this shader
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas.sfchildsite.stk_1.lab
# 		The label identifying which type of shader this one is
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas.sfchildsite.stk_1.fr
# 		The frame where the actual buttons, label, entries, etc for this
# 		particular shader located.
# 


# We use the Labeledframe from Iwidgets
package require Iwidgets
a10 26
# this routine displays "which_frame" ("Bool" or "Shade") and forgets the other
proc toggle_bool_shade_frame { id which_frame } {

    set top .$id.comb

    if { $which_frame == "Bool" } {
	grid forget $top.my_tabbed.shader_labeled
	grid $top.my_tabbed.bool_labeled -sticky nsew
	$top.region_inherit_frame.bool_shade_b configure \
	    -text "Show Shader" \
	    -command "toggle_bool_shade_frame $id Shade"
    } else {
	grid forget $top.my_tabbed.bool_labeled
	grid $top.my_tabbed.shader_labeled -sticky nsew
	$top.region_inherit_frame.bool_shade_b configure \
	    -text "Show Boolean" \
	    -command "toggle_bool_shade_frame $id Bool"
    }
}

# top level interface to the combination editor
#
# Creates a top level window containing (among other widgets) two
# labeledframes, one for the Boolean expression and one for shader stuff.
# Only one of these frames is visible at any one time
#
a11 1
    package require Iwidgets
d15 1
a15 1
    global ::tk::Priv
d18 1
a18 1
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "No database." \
a22 1
    # name of our top level window
a24 1
    # if we already have such a window, just pop it up
a53 1
    # invoke a handler whenever the combination name is changed
a56 1
    # create our top level window
d59 14
a72 2
    # create a frame to hold either of the labeledframes
    set my_tabbed_frame [frame $top.my_tabbed -relief flat]
d74 2
a75 60
    # create the two labeledframes
    iwidgets::Labeledframe $my_tabbed_frame.shader_labeled -labeltext "Shader"
    iwidgets::Labeledframe $my_tabbed_frame.bool_labeled -labeltext "Boolean"

    # get the childsites (frames) of the labeledframes
    # store them in the "comb_control" array for global access
    set bool_frame [$my_tabbed_frame.bool_labeled childsite]
    set comb_control($id,bool_frame) $bool_frame
    set shade_frame [$my_tabbed_frame.shader_labeled childsite]
    
    # row 0 is just the color
    # row 1 is the actual frame containing the shader stuff
    grid rowconfigure $shade_frame 0 -weight 0
    grid rowconfigure $shade_frame 1 -weight 1

    # strange, but it appears that the childsite in this labeledframe
    # is in column 1 ?????
    grid columnconfigure $top.my_tabbed.shader_labeled 0 -weight 0
    grid columnconfigure $top.my_tabbed.shader_labeled 1 -weight 1

    # frame to hold the combination name, entry widget, and menunutton
    frame $top.name_stuff

    # frame to hold the region id, los, air code, and GIFT material code
    frame $top.id_los_air_mater 

    # frame to hold the color label and the "colorF" frame (created by
    # "color_entry_build")
    frame $top.color_frame

    # frame to contain all the shader stuff
    frame $top.shader_top_frame -relief groove -bd 2 

    # frame to hold the display selection menubutton, the "IsRegion",
    # checkbutton, and the "Inherit" checkbutton
    frame $top.region_inherit_frame 

    # frame to hold the label, text and scrollbar widgets for the
    # Boolean expression
    frame $top.bool_expr_frame 

    # frame to hold the control buttons (Apply, dismiss, ...)
    frame $top.control_buttons_frame 

    # frame to hold the region name entry and menubutton widgets
    # this frame sits in the "name_stuff" frame above
    frame $top.name_entry_and_menu_frame -relief sunken -bd 2 

    # frame to hold the shader label, entry, and menubutton widgets
    frame $top.shader_label_entry_frame

    # empty frame to pass to the shader routines (in "shaders.tcl")
    frame $top.shader_frame

    # frame to hold the shader entry and menubutton widgets
    # this frame sits in the "shader_label_entry_frame" above
    frame $top.shader_entry_and_menu_frame -relief sunken -bd 2 

    # arrange for global access
    set comb_control($id,shader_frame) $top.shader_frame
a77 35
    # initialize name of shader
    set shader_params($id,shader_name) ""

    # create the button that will choose whether the "Boolean" or
    # "Shader" frame is displayed
    set bool_shade_b [button $top.region_inherit_frame.bool_shade_b \
			  -text "Show Shader" \
			  -command "toggle_bool_shade_frame $id Bool"]
    if { 0 } {
    set bool_shade_mb [menubutton $top.region_inherit_frame.bool_shade_menuB \
			   -text "Select View" \
			   -indicatoron true \
			   -relief raised]

    # create menu for above menubutton
    menu $bool_shade_mb.menu -tearoff false
    $bool_shade_mb.menu add command \
	-label "Show Boolean" \
	-command "toggle_bool_shade_frame $id Bool"
    $bool_shade_mb.menu add command \
	-label "Show Shader" \
	-command "toggle_bool_shade_frame $id Shade"
    $bool_shade_mb configure -menu $bool_shade_mb.menu

    # help for above menubutton
    set hoc_data { { summary "Use this button to select whether the Boolean
expression or the Shader parameters is displayed" } }
    hoc_register_data $bool_shade_mb "Select View" $hoc_data
    }

    set hoc_data { { summary "Use this button to select whether the Boolean
expression or the Shader parameters is displayed" } }
    hoc_register_data $bool_shade_b "Select View" $hoc_data

    # create label for combination name
d86 1
a86 3

    # create entry widget for combination name
    entry $top.nameE -relief flat -width 35 -textvar comb_control($id,name)
a87 2

    # create menubutton for selecting combination
a92 2

    # create menu for above menubutton
a93 2

    # add menu items
d145 1
a145 2
    # create label for region id
    label $top.idL -text "Region Id:" -anchor e
d154 1
a154 3

    # create entry widget for region id
    entry $top.idE -relief sunken -width 5 -textvar comb_control($id,id)
d157 1
a157 2
    # create label for air code
    label $top.airL -text " Air Code:" -anchor e
d166 1
a166 3

    # create entry widget for air code
    entry $top.airE -relief sunken -width 2 -textvar comb_control($id,air)
d169 1
a169 2
    # create label for material code
    label $top.materialL -text " Material Id:" -anchor e
d176 1
a176 3

    # create entry widget for material code
    entry $top.materialE -relief sunken -width 2 -textvar comb_control($id,material)
d179 1
a179 2
    # create label for LOS
    label $top.losL -text " LOS:" -anchor e
d188 1
a188 3

    # create entry widget for LOS
    entry $top.losE -relief sunken -width 3 -textvar comb_control($id,los)
a190 1
    # create label for color
a196 2

    # create a color entry widget and a color menubutton
a203 1
    # create "shader" label
a209 2

    # create entry widget for shader string
a212 3
    # whenever any key is released inside the shader entry widget.
    # call "set_shader_params" to update the shader display
    # (see "shaders.tcl" for this routine)
a214 1
    # create menubutton to select from all the shaders
a221 2

    # create menu for above menubutton
a226 2

    # add all the shaders to the above menu
a296 2

    # allow for the possiblity that a shader exists that is not in the above list
a301 1
    # create label for Boolean expression
a315 2

    # create text widget to hold the Boolean expression
a319 2

    # may need a vertical scrollbar for complex expressions
a321 1
    # create "Is Region" checkbutton
d325 4
a328 4
    hoc_register_data $top.isRegionCB "Is Region" \
	{ { summary "Toggle the region flag on/off. If the
region flag is toggled on \(i.e. checkbutton
is highligted\) the GUI reconfigures itself to
d334 2
a335 4
also required to be homogeneous \(i.e. consisting
of the same material\)." } }

    # create "Inherit" checkbutton
d343 1
a343 1
no effect \(i.e. the members of a region
d345 1
a345 1
region\)." } }
a346 1
    # create the control buttons (OK, Apply, ...)
d368 22
a389 52
    # put name label, entry, and menu button in "name_stuff" frame
    grid $top.nameE $top.nameMB -sticky "ew" -in $top.name_entry_and_menu_frame
    grid columnconfigure $top.name_entry_and_menu_frame 0 -weight 1
    grid $top.nameL -sticky "e" -in $top.name_stuff -pady $comb_control($id,pady) -row 0 -column 0
    grid $top.name_entry_and_menu_frame -sticky "ew" -in $top.name_stuff -pady $comb_control($id,pady) -row 0 -column 1
    grid columnconfigure $top.name_stuff 1 -weight 1

    # put ident, los, air code, and material id into "id_los_air_mater" frame
    grid $top.idL -in $top.id_los_air_mater -pady $comb_control($id,pady) -row 0 -column 0 -sticky ew
    grid $top.idE -in $top.id_los_air_mater -pady $comb_control($id,pady) -row 0 -column 1 -sticky ew
    grid $top.airL -in $top.id_los_air_mater -pady $comb_control($id,pady) -row 0 -column 2 -sticky ew
    grid $top.airE -in $top.id_los_air_mater -pady $comb_control($id,pady) -row 0 -column 3 -sticky ew
    grid $top.materialL -in $top.id_los_air_mater -pady $comb_control($id,pady) -row 0 -column 4 -sticky ew
    grid $top.materialE -in $top.id_los_air_mater -pady $comb_control($id,pady) -row 0 -column 5 -sticky ew
    grid $top.losL -in $top.id_los_air_mater -pady $comb_control($id,pady) -row 0 -column 6 -sticky ew
    grid $top.losE -in $top.id_los_air_mater -pady $comb_control($id,pady) -row 0 -column 7 -sticky ew
    grid rowconfigure $top.id_los_air_mater 0 -weight 1
    grid columnconfigure $top.id_los_air_mater 1 -weight 1
    grid columnconfigure $top.id_los_air_mater 3 -weight 1
    grid columnconfigure $top.id_los_air_mater 5 -weight 1
    grid columnconfigure $top.id_los_air_mater 7 -weight 1
    grid columnconfigure $top.id_los_air_mater 0 -weight 0
    grid columnconfigure $top.id_los_air_mater 2 -weight 0
    grid columnconfigure $top.id_los_air_mater 4 -weight 0
    grid columnconfigure $top.id_los_air_mater 6 -weight 0


    # put id_los_air_mater into the "Boolean" frame
    grid $top.id_los_air_mater -in $bool_frame \
             -padx $comb_control($id,padx) \
             -pady $comb_control($id,pady) \
             -sticky new -row 0 -column 0
    grid $top.bool_expr_frame -in $bool_frame \
             -padx $comb_control($id,padx) \
             -pady $comb_control($id,pady) \
             -sticky nsew -row 1 -column 0
    grid columnconfigure $bool_frame 0 -weight 1
    grid rowconfigure $bool_frame 0 -weight 0
    grid rowconfigure $bool_frame 1 -weight 1

    # put the color label and the frame built by
    # "color_entry_build" into "color_frame"
    grid $top.colorL \
            -row 0 -column 0 \
	    -sticky "e" \
            -in $top.color_frame \
            -pady $comb_control($id,pady)
    grid $top.colorF \
            -row 0 -column 1 \
	    -sticky "w" \
            -in $top.color_frame \
            -pady $comb_control($id,pady)
a390 2
    # puts shader entry widget and shader selector menubutton into the
    # "shader_entry_and_menu_frame"
d393 7
a399 2
	    -in $top.shader_entry_and_menu_frame
    grid columnconfigure $top.shader_entry_and_menu_frame 0 -weight 1
d401 3
a403 16
    # combine the above frame and the shader label
    # into  the "shader_label_entry_frame"
    grid $top.shaderL \
	-row 0 -column 0 \
	-sticky "e" \
	-in $top.shader_label_entry_frame
    grid $top.shader_entry_and_menu_frame \
	-row 0 -column 1 \
	-sticky "ew" \
	-in $top.shader_label_entry_frame
    grid columnconfigure $top.shader_label_entry_frame 1 -weight 1

    # puts the above frame in the "shader_top_frame"
    grid $top.shader_label_entry_frame \
	    -sticky "new" \
	    -in $top.shader_top_frame\
d406 15
a421 51
    grid rowconfigure $top.shader_top_frame 0 -weight 0
    grid rowconfigure $top.shader_top_frame 1 -weight 1
    grid columnconfigure $top.shader_top_frame 0 -weight 1

    # puts color frame into "Shader" labeledframe
    grid $top.color_frame -in $shade_frame \
             -padx $comb_control($id,padx) \
             -pady $comb_control($id,pady) \
             -sticky new -row 0 -column 0

    # add the actual shader frame to the "Shader" labeledframe
    grid $top.shader_top_frame -in $shade_frame \
             -padx $comb_control($id,padx) \
             -pady $comb_control($id,pady) \
             -sticky nsew -row 1 -column 0

    grid rowconfigure $shade_frame 0 -weight 0
    grid rowconfigure $shade_frame 1 -weight 1
    grid columnconfigure $shade_frame 0 -weight 1

    # grid the "Shader labeledframe childsite frame
    grid $shade_frame -sticky nsew

    # put the display selection menubutton, the "Is Region" checkbutton,
    # and the "Inherit" checkbutton in the "region_inherit_frame"
    grid $bool_shade_b \
            -row 0 -column 0 \
            -sticky "w" \
            -in $top.region_inherit_frame
    grid $top.isRegionCB \
            -row 0 -column 2 \
            -sticky "nse" \
            -in $top.region_inherit_frame
    grid $top.inheritCB \
            -row 0 -column 3 \
            -sticky "nse" \
            -in $top.region_inherit_frame
    grid columnconfigure $top.region_inherit_frame 1 -weight 1
    grid rowconfigure $top.region_inherit_frame 0 -weight 0

    # put the Boolean expression label, text and scrollbar into the
    # "bool_expr_frame"
    grid $top.combL -sticky "w" -in $top.bool_expr_frame -row 0 -column 0
    grid $top.combT -sticky "nsew" -in $top.bool_expr_frame -row 1 -column 0
    grid $top.combS -sticky "ns" -in $top.bool_expr_frame -row 1 -column 1
    grid rowconfigure $top.bool_expr_frame 0 -weight 0
    grid rowconfigure $top.bool_expr_frame 1 -weight 1
    grid columnconfigure $top.bool_expr_frame 0 -weight 1
    grid columnconfigure $top.bool_expr_frame 1 -weight 0

    # put the control buttons into the "control_buttons_frame"
d423 10
a432 32
	    -in $top.control_buttons_frame -pady $comb_control($id,pady)
    grid columnconfigure $top.control_buttons_frame 2 -weight 1
    grid columnconfigure $top.control_buttons_frame 4 -weight 1

    # grid the remaining frames
    grid $top.name_stuff \
         -sticky "ew" \
         -padx $comb_control($id,padx) \
         -pady $comb_control($id,pady) \
         -row 0 -column 0

    grid $top.region_inherit_frame \
         -padx $comb_control($id,padx) \
         -pady $comb_control($id,pady) \
         -sticky new -row 1 -column 0

    grid $my_tabbed_frame \
          -sticky "nsew" \
          -padx $comb_control($id,padx) \
          -pady $comb_control($id,pady) \
          -row 2 -column 0
    grid rowconfigure $my_tabbed_frame 0 -weight 1
    grid columnconfigure $my_tabbed_frame 0 -weight 1

    grid $top.control_buttons_frame \
         -sticky "ew" \
         -padx $comb_control($id,padx) \
         -pady $comb_control($id,pady) \
         -row 3 -column 0

    grid rowconfigure $top 0 -weight 0
    grid rowconfigure $top 2 -weight 1
a434 5
    # start with "Boolean" frame dsplayed
    toggle_bool_shade_frame $id "Bool"

    # handle event when someone presses "Enter"
    # in the combination name entry widget
a439 1

a441 1
# called when "OK" is pressed
a442 2

    # apply the parameters
a445 1
	# destroy the window
a449 1
# apply the parameters to the actual combination on disk
d453 1
a453 1
    global ::tk::Priv
a455 2

    # get the Boolean expression fron the text widget
a457 2
    # if someone has edited the combination name, take care about
    # overwriting an existing object
d459 1
a459 1
	set ret [cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen)\
a469 3

	# this is a region

d471 1
a471 2
	    # region id is less than zero!!!!
	    cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen)\
d479 1
a479 2
	    # air code is less than zero!!!
	    cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen)\
d488 1
a488 2
	    # exactly one of region id and air code should be set
	    set ret [cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen)\
a497 1
	# get color
a503 1
	# actually apply the edist to the combination on disk
d510 1
a510 1
	    cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) \
a515 1
	# set any attributes that we have saved
d519 1
a519 1
	    cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) \
a527 4

    # this is not a region

    # get the color
a533 1
    # actually apply the edits to the combination on disk
d539 1
a539 1
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) \
d544 1
a544 2

    # set any attributes that we have saved
d548 1
a548 1
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) \
a556 2
# called when "Reset" button is pressed
# ignores any edits made and restores data from disk
d560 1
a560 1
    global ::tk::Priv
d565 1
a565 1
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen)\
a571 1
    # get the combination data from disk
d575 1
a575 1
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen)\
a581 1
    # get the attributes
d584 1
a584 1
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen)\
a619 1
    # save the attributes
a623 1
    # set all our data variables for the editor
d674 2
a675 2
		-sticky "nsew" \
		-in $top.shader_top_frame \
a677 4
	grid rowconfigure $top.shader_top_frame 0 -weight 0
	grid rowconfigure $top.shader_top_frame 1 -weight 1
	grid columnconfigure $top.shader_top_frame 0 -weight 1
	grid columnconfigure $top.shader_frame 0 -weight 1
a685 1
# called when "Dismiss" button is pressed
a688 1
    # destroy it all
a693 1
# called when "Is Region" checkbutton is pressed
d698 1
a698 1
    grid remove $top.id_los_air_mater
d701 32
a732 4
	grid $top.id_los_air_mater -in $comb_control($id,bool_frame) \
	    -padx $comb_control($id,padx) \
	    -pady $comb_control($id,pady) \
	    -sticky new -row 0 -column 0
d734 14
a747 1
	grid forget $top.id_los_air_mater
d749 2
d767 2
a768 2
	    -sticky "nsew" \
	    -in $top.shader_top_frame \
a770 5

    grid rowconfigure $top.shader_top_frame 0 -weight 0
    grid rowconfigure $top.shader_top_frame 1 -weight 1
    grid columnconfigure $top.shader_top_frame 0 -weight 1
    grid columnconfigure $top.shader_frame 0 -weight 1
a781 1
# mark name as dirty if someone edits it
@


1.43.6.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d15 1
a15 1
    variable ::tk::Priv
d18 1
a18 1
	cad_dialog $Priv(cad_dialog) $mged_gui($id,screen) "No database." \
d453 1
a453 1
    variable ::tk::Priv
d459 1
a459 1
	set ret [cad_dialog $Priv(cad_dialog) $mged_gui($id,screen)\
d471 1
a471 1
	    cad_dialog $Priv(cad_dialog) $mged_gui($id,screen)\
d479 1
a479 1
	    cad_dialog kPriv(cad_dialog) $mged_gui($id,screen)\
d488 1
a488 1
	    set ret [cad_dialog $Priv(cad_dialog) $mged_gui($id,screen)\
d510 1
a510 1
	    cad_dialog $Priv(cad_dialog) $mged_gui($id,screen) \
d539 1
a539 1
	cad_dialog $Priv(cad_dialog) $mged_gui($id,screen) \
d560 1
a560 1
    variable ::tk::Priv
d565 1
a565 1
	cad_dialog $Priv(cad_dialog) $mged_gui($id,screen)\
d575 1
a575 1
	cad_dialog $Priv(cad_dialog) $mged_gui($id,screen)\
@


1.43.6.2
log
@sync to HEAD...
@
text
@a7 139
# This is the widget hierarchy from the top level down to the shader frames or Boolean
# expression frames
# 
# widget names include $id to make them unique. Typically, $id == "id_0"
# 
# Top level combination editor widget: $id.comb
# 
# slaves:
# 	.id_0.comb.control_buttons_frame
# 		frame for control buttons (OK, Apply, Reset, Dismiss)
# 	.id_0.comb.my_tabbed
# 		frame for holding the Boolean or Shader stuff
# 	.id_0.comb.region_inherit_frame
# 		frame for "Is Region" and "Inherit" as well as button to
# 		switch between Boolean and shader displays
# 	.id_0.comb.name_stuff
# 		frame for combination label, name and menubutton
# 
# -------------------------------------------------
# .id_0.comb.my_tabbed
# 
# 	This frame is just a holder for either the Boolean stuff or the shader stuff
# 
# slaves:
# 	.id_0.comb.my_tabbed.bool_labeled
# 			or
# 	.id_0.comb.my_tabbed.shader_labeled
# 
# -------------------------------------------------
# .id_0.comb.my_tabbed.bool_labeled.childsite
# 
# 	This frame is a childsite of the ".id_0.comb.my_tabbed.bool_labeled" mentioned above
# 	This frame is only mapped when the Boolean expression is displayed.
# 
# slaves:
# 	.id_0.comb.id_los_air_mater
# 		frame containing the region id, air code, material id, and LOS
# 		This frame is toggled on and off using the "Is Region" checkbutton
# 
# 	.id_0.comb.bool_expr_frame
# 		Frame for the Boolean expression. Contains a label, scrollbar,
# 		and text widget.
# 
# -------------------------------------------------
# .id_0.comb.my_tabbed.shader_labeled.childsite
# 	This frame is the childsite of the ".id_0.comb.my_tabbed.shader_labeled"
# 	mentioned above. This frame is only mapped when the shader is displayed.
# slaves:
# 
# 	.id_0.comb.color_frame
# 		frame for the color label, entry, and menubutton
# 	.id_0.comb.shader_top_frame
# 		frame for the shader stuff
# 
# -------------------------------------------------
# .id_0.comb.shader_top_frame
# slaves:
# 	.id_0.comb.shader_label_entry_frame
# 		frame for the shader label, entry, and menubutton
# 	.id_0.comb.shader_frame
# 		frame for the individual shaders to fill
# 		this frame is passed by "do_shade" to the shaders
# 
# -------------------------------------------------
# .id_0.comb.shader_frame
# slaves:
# 	.id_0.comb.shader_frame.fr
# 		frame created by an individual shader to hold all its stuff
# 
# -------------------------------------------------
# .id_0.comb.shader_frame.fr
# slaves:
# 	For the typical shader, the slaves of this frame are the individual
# 	labels, buttons, checkbuttons, entry widgets, menubuttons, etc, for
# 	that particular shader. This is the end of the hierarchy for simple
# 	shaders. From here down, the discussion only relates to the "stack"
# 	shader
# 
# 	For the "stack" shader, the slaves of this frame are:
# 
# 	.id_0.comb.shader_frame.fr.add
# 		frame for the "Add shader" button
# 	.id_0.comb.shader_frame.fr.leesf
# 		scrolledframe to hold all the stacked shaders
# 
# -------------------------------------------------
# .id_0.comb.shader_frame.fr.leesf
# slaves:
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite
# 		frame internal to the scrolledframe
# 
# -------------------------------------------------
# .id_0.comb.shader_frame.fr.leesf.lwchildsite
# slaves:
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.vertsb
# 		vertical scrollbar for scrolledframe
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.horizsb
# 		horizontal scrollbar (dynamic)
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper
# 		frame internal to scrolledframe
# 
# -------------------------------------------------
# .id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper
# slaves:
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas
# 		another object internal to the scrolledframe widget
# 
# -------------------------------------------------
# .id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas.sfchildsite
# 	This frame is the actual childsite provided by the scrolledframe widget "leesf"
# 	It will contain a "stack" of frames, one for each shader currently
# 	in the stack
# 
# slaves:
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas.sfchildsite.stk_1
# 		frame for first stacked shader
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas.sfchildsite.stk_2
# 		frame for second stacked shader
# 	.
# 	.
# 	.
# 
# -------------------------------------------------
# .id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas.sfchildsite.stk_1
# 	This is a frame for an individual shader in the stack
# 
# slaves:
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas.sfchildsite.stk_1.del
# 		The delete button for this shader
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas.sfchildsite.stk_1.lab
# 		The label identifying which type of shader this one is
# 	.id_0.comb.shader_frame.fr.leesf.lwchildsite.clipper.canvas.sfchildsite.stk_1.fr
# 		The frame where the actual buttons, label, entries, etc for this
# 		particular shader located.
# 


# We use the Labeledframe from Iwidgets
package require Iwidgets
a10 26
# this routine displays "which_frame" ("Bool" or "Shade") and forgets the other
proc toggle_bool_shade_frame { id which_frame } {

    set top .$id.comb

    if { $which_frame == "Bool" } {
	grid forget $top.my_tabbed.shader_labeled
	grid $top.my_tabbed.bool_labeled -sticky nsew
	$top.region_inherit_frame.bool_shade_b configure \
	    -text "Show Shader" \
	    -command "toggle_bool_shade_frame $id Shade"
    } else {
	grid forget $top.my_tabbed.bool_labeled
	grid $top.my_tabbed.shader_labeled -sticky nsew
	$top.region_inherit_frame.bool_shade_b configure \
	    -text "Show Boolean" \
	    -command "toggle_bool_shade_frame $id Bool"
    }
}

# top level interface to the combination editor
#
# Creates a top level window containing (among other widgets) two
# labeledframes, one for the Boolean expression and one for shader stuff.
# Only one of these frames is visible at any one time
#
a11 1
    package require Iwidgets
d15 1
a15 1
    global ::tk::Priv
d18 1
a18 1
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "No database." \
a22 1
    # name of our top level window
a24 1
    # if we already have such a window, just pop it up
a53 1
    # invoke a handler whenever the combination name is changed
a56 1
    # create our top level window
d59 14
a72 2
    # create a frame to hold either of the labeledframes
    set my_tabbed_frame [frame $top.my_tabbed -relief flat]
d74 2
a75 60
    # create the two labeledframes
    iwidgets::Labeledframe $my_tabbed_frame.shader_labeled -labeltext "Shader"
    iwidgets::Labeledframe $my_tabbed_frame.bool_labeled -labeltext "Boolean"

    # get the childsites (frames) of the labeledframes
    # store them in the "comb_control" array for global access
    set bool_frame [$my_tabbed_frame.bool_labeled childsite]
    set comb_control($id,bool_frame) $bool_frame
    set shade_frame [$my_tabbed_frame.shader_labeled childsite]
    
    # row 0 is just the color
    # row 1 is the actual frame containing the shader stuff
    grid rowconfigure $shade_frame 0 -weight 0
    grid rowconfigure $shade_frame 1 -weight 1

    # strange, but it appears that the childsite in this labeledframe
    # is in column 1 ?????
    grid columnconfigure $top.my_tabbed.shader_labeled 0 -weight 0
    grid columnconfigure $top.my_tabbed.shader_labeled 1 -weight 1

    # frame to hold the combination name, entry widget, and menunutton
    frame $top.name_stuff

    # frame to hold the region id, los, air code, and GIFT material code
    frame $top.id_los_air_mater 

    # frame to hold the color label and the "colorF" frame (created by
    # "color_entry_build")
    frame $top.color_frame

    # frame to contain all the shader stuff
    frame $top.shader_top_frame -relief groove -bd 2 

    # frame to hold the display selection menubutton, the "IsRegion",
    # checkbutton, and the "Inherit" checkbutton
    frame $top.region_inherit_frame 

    # frame to hold the label, text and scrollbar widgets for the
    # Boolean expression
    frame $top.bool_expr_frame 

    # frame to hold the control buttons (Apply, dismiss, ...)
    frame $top.control_buttons_frame 

    # frame to hold the region name entry and menubutton widgets
    # this frame sits in the "name_stuff" frame above
    frame $top.name_entry_and_menu_frame -relief sunken -bd 2 

    # frame to hold the shader label, entry, and menubutton widgets
    frame $top.shader_label_entry_frame

    # empty frame to pass to the shader routines (in "shaders.tcl")
    frame $top.shader_frame

    # frame to hold the shader entry and menubutton widgets
    # this frame sits in the "shader_label_entry_frame" above
    frame $top.shader_entry_and_menu_frame -relief sunken -bd 2 

    # arrange for global access
    set comb_control($id,shader_frame) $top.shader_frame
a77 35
    # initialize name of shader
    set shader_params($id,shader_name) ""

    # create the button that will choose whether the "Boolean" or
    # "Shader" frame is displayed
    set bool_shade_b [button $top.region_inherit_frame.bool_shade_b \
			  -text "Show Shader" \
			  -command "toggle_bool_shade_frame $id Bool"]
    if { 0 } {
    set bool_shade_mb [menubutton $top.region_inherit_frame.bool_shade_menuB \
			   -text "Select View" \
			   -indicatoron true \
			   -relief raised]

    # create menu for above menubutton
    menu $bool_shade_mb.menu -tearoff false
    $bool_shade_mb.menu add command \
	-label "Show Boolean" \
	-command "toggle_bool_shade_frame $id Bool"
    $bool_shade_mb.menu add command \
	-label "Show Shader" \
	-command "toggle_bool_shade_frame $id Shade"
    $bool_shade_mb configure -menu $bool_shade_mb.menu

    # help for above menubutton
    set hoc_data { { summary "Use this button to select whether the Boolean
expression or the Shader parameters is displayed" } }
    hoc_register_data $bool_shade_mb "Select View" $hoc_data
    }

    set hoc_data { { summary "Use this button to select whether the Boolean
expression or the Shader parameters is displayed" } }
    hoc_register_data $bool_shade_b "Select View" $hoc_data

    # create label for combination name
d86 1
a86 3

    # create entry widget for combination name
    entry $top.nameE -relief flat -width 35 -textvar comb_control($id,name)
a87 2

    # create menubutton for selecting combination
a92 2

    # create menu for above menubutton
a93 2

    # add menu items
d145 1
a145 2
    # create label for region id
    label $top.idL -text "Region Id:" -anchor e
d154 1
a154 3

    # create entry widget for region id
    entry $top.idE -relief sunken -width 5 -textvar comb_control($id,id)
d157 1
a157 2
    # create label for air code
    label $top.airL -text " Air Code:" -anchor e
d166 1
a166 3

    # create entry widget for air code
    entry $top.airE -relief sunken -width 2 -textvar comb_control($id,air)
d169 1
a169 2
    # create label for material code
    label $top.materialL -text " Material Id:" -anchor e
d176 1
a176 3

    # create entry widget for material code
    entry $top.materialE -relief sunken -width 2 -textvar comb_control($id,material)
d179 1
a179 2
    # create label for LOS
    label $top.losL -text " LOS:" -anchor e
d188 1
a188 3

    # create entry widget for LOS
    entry $top.losE -relief sunken -width 3 -textvar comb_control($id,los)
a190 1
    # create label for color
a196 2

    # create a color entry widget and a color menubutton
a203 1
    # create "shader" label
a209 2

    # create entry widget for shader string
a212 3
    # whenever any key is released inside the shader entry widget.
    # call "set_shader_params" to update the shader display
    # (see "shaders.tcl" for this routine)
a214 1
    # create menubutton to select from all the shaders
a221 2

    # create menu for above menubutton
a226 2

    # add all the shaders to the above menu
a296 2

    # allow for the possiblity that a shader exists that is not in the above list
a301 1
    # create label for Boolean expression
a315 2

    # create text widget to hold the Boolean expression
a319 2

    # may need a vertical scrollbar for complex expressions
a321 1
    # create "Is Region" checkbutton
d325 4
a328 4
    hoc_register_data $top.isRegionCB "Is Region" \
	{ { summary "Toggle the region flag on/off. If the
region flag is toggled on \(i.e. checkbutton
is highligted\) the GUI reconfigures itself to
d334 2
a335 4
also required to be homogeneous \(i.e. consisting
of the same material\)." } }

    # create "Inherit" checkbutton
d343 1
a343 1
no effect \(i.e. the members of a region
d345 1
a345 1
region\)." } }
a346 1
    # create the control buttons (OK, Apply, ...)
d368 22
a389 52
    # put name label, entry, and menu button in "name_stuff" frame
    grid $top.nameE $top.nameMB -sticky "ew" -in $top.name_entry_and_menu_frame
    grid columnconfigure $top.name_entry_and_menu_frame 0 -weight 1
    grid $top.nameL -sticky "e" -in $top.name_stuff -pady $comb_control($id,pady) -row 0 -column 0
    grid $top.name_entry_and_menu_frame -sticky "ew" -in $top.name_stuff -pady $comb_control($id,pady) -row 0 -column 1
    grid columnconfigure $top.name_stuff 1 -weight 1

    # put ident, los, air code, and material id into "id_los_air_mater" frame
    grid $top.idL -in $top.id_los_air_mater -pady $comb_control($id,pady) -row 0 -column 0 -sticky ew
    grid $top.idE -in $top.id_los_air_mater -pady $comb_control($id,pady) -row 0 -column 1 -sticky ew
    grid $top.airL -in $top.id_los_air_mater -pady $comb_control($id,pady) -row 0 -column 2 -sticky ew
    grid $top.airE -in $top.id_los_air_mater -pady $comb_control($id,pady) -row 0 -column 3 -sticky ew
    grid $top.materialL -in $top.id_los_air_mater -pady $comb_control($id,pady) -row 0 -column 4 -sticky ew
    grid $top.materialE -in $top.id_los_air_mater -pady $comb_control($id,pady) -row 0 -column 5 -sticky ew
    grid $top.losL -in $top.id_los_air_mater -pady $comb_control($id,pady) -row 0 -column 6 -sticky ew
    grid $top.losE -in $top.id_los_air_mater -pady $comb_control($id,pady) -row 0 -column 7 -sticky ew
    grid rowconfigure $top.id_los_air_mater 0 -weight 1
    grid columnconfigure $top.id_los_air_mater 1 -weight 1
    grid columnconfigure $top.id_los_air_mater 3 -weight 1
    grid columnconfigure $top.id_los_air_mater 5 -weight 1
    grid columnconfigure $top.id_los_air_mater 7 -weight 1
    grid columnconfigure $top.id_los_air_mater 0 -weight 0
    grid columnconfigure $top.id_los_air_mater 2 -weight 0
    grid columnconfigure $top.id_los_air_mater 4 -weight 0
    grid columnconfigure $top.id_los_air_mater 6 -weight 0


    # put id_los_air_mater into the "Boolean" frame
    grid $top.id_los_air_mater -in $bool_frame \
             -padx $comb_control($id,padx) \
             -pady $comb_control($id,pady) \
             -sticky new -row 0 -column 0
    grid $top.bool_expr_frame -in $bool_frame \
             -padx $comb_control($id,padx) \
             -pady $comb_control($id,pady) \
             -sticky nsew -row 1 -column 0
    grid columnconfigure $bool_frame 0 -weight 1
    grid rowconfigure $bool_frame 0 -weight 0
    grid rowconfigure $bool_frame 1 -weight 1

    # put the color label and the frame built by
    # "color_entry_build" into "color_frame"
    grid $top.colorL \
            -row 0 -column 0 \
	    -sticky "e" \
            -in $top.color_frame \
            -pady $comb_control($id,pady)
    grid $top.colorF \
            -row 0 -column 1 \
	    -sticky "w" \
            -in $top.color_frame \
            -pady $comb_control($id,pady)
a390 2
    # puts shader entry widget and shader selector menubutton into the
    # "shader_entry_and_menu_frame"
d393 7
a399 2
	    -in $top.shader_entry_and_menu_frame
    grid columnconfigure $top.shader_entry_and_menu_frame 0 -weight 1
d401 3
a403 16
    # combine the above frame and the shader label
    # into  the "shader_label_entry_frame"
    grid $top.shaderL \
	-row 0 -column 0 \
	-sticky "e" \
	-in $top.shader_label_entry_frame
    grid $top.shader_entry_and_menu_frame \
	-row 0 -column 1 \
	-sticky "ew" \
	-in $top.shader_label_entry_frame
    grid columnconfigure $top.shader_label_entry_frame 1 -weight 1

    # puts the above frame in the "shader_top_frame"
    grid $top.shader_label_entry_frame \
	    -sticky "new" \
	    -in $top.shader_top_frame\
d406 15
a421 51
    grid rowconfigure $top.shader_top_frame 0 -weight 0
    grid rowconfigure $top.shader_top_frame 1 -weight 1
    grid columnconfigure $top.shader_top_frame 0 -weight 1

    # puts color frame into "Shader" labeledframe
    grid $top.color_frame -in $shade_frame \
             -padx $comb_control($id,padx) \
             -pady $comb_control($id,pady) \
             -sticky new -row 0 -column 0

    # add the actual shader frame to the "Shader" labeledframe
    grid $top.shader_top_frame -in $shade_frame \
             -padx $comb_control($id,padx) \
             -pady $comb_control($id,pady) \
             -sticky nsew -row 1 -column 0

    grid rowconfigure $shade_frame 0 -weight 0
    grid rowconfigure $shade_frame 1 -weight 1
    grid columnconfigure $shade_frame 0 -weight 1

    # grid the "Shader labeledframe childsite frame
    grid $shade_frame -sticky nsew

    # put the display selection menubutton, the "Is Region" checkbutton,
    # and the "Inherit" checkbutton in the "region_inherit_frame"
    grid $bool_shade_b \
            -row 0 -column 0 \
            -sticky "w" \
            -in $top.region_inherit_frame
    grid $top.isRegionCB \
            -row 0 -column 2 \
            -sticky "nse" \
            -in $top.region_inherit_frame
    grid $top.inheritCB \
            -row 0 -column 3 \
            -sticky "nse" \
            -in $top.region_inherit_frame
    grid columnconfigure $top.region_inherit_frame 1 -weight 1
    grid rowconfigure $top.region_inherit_frame 0 -weight 0

    # put the Boolean expression label, text and scrollbar into the
    # "bool_expr_frame"
    grid $top.combL -sticky "w" -in $top.bool_expr_frame -row 0 -column 0
    grid $top.combT -sticky "nsew" -in $top.bool_expr_frame -row 1 -column 0
    grid $top.combS -sticky "ns" -in $top.bool_expr_frame -row 1 -column 1
    grid rowconfigure $top.bool_expr_frame 0 -weight 0
    grid rowconfigure $top.bool_expr_frame 1 -weight 1
    grid columnconfigure $top.bool_expr_frame 0 -weight 1
    grid columnconfigure $top.bool_expr_frame 1 -weight 0

    # put the control buttons into the "control_buttons_frame"
d423 10
a432 32
	    -in $top.control_buttons_frame -pady $comb_control($id,pady)
    grid columnconfigure $top.control_buttons_frame 2 -weight 1
    grid columnconfigure $top.control_buttons_frame 4 -weight 1

    # grid the remaining frames
    grid $top.name_stuff \
         -sticky "ew" \
         -padx $comb_control($id,padx) \
         -pady $comb_control($id,pady) \
         -row 0 -column 0

    grid $top.region_inherit_frame \
         -padx $comb_control($id,padx) \
         -pady $comb_control($id,pady) \
         -sticky new -row 1 -column 0

    grid $my_tabbed_frame \
          -sticky "nsew" \
          -padx $comb_control($id,padx) \
          -pady $comb_control($id,pady) \
          -row 2 -column 0
    grid rowconfigure $my_tabbed_frame 0 -weight 1
    grid columnconfigure $my_tabbed_frame 0 -weight 1

    grid $top.control_buttons_frame \
         -sticky "ew" \
         -padx $comb_control($id,padx) \
         -pady $comb_control($id,pady) \
         -row 3 -column 0

    grid rowconfigure $top 0 -weight 0
    grid rowconfigure $top 2 -weight 1
a434 5
    # start with "Boolean" frame dsplayed
    toggle_bool_shade_frame $id "Bool"

    # handle event when someone presses "Enter"
    # in the combination name entry widget
a439 1

a441 1
# called when "OK" is pressed
a442 2

    # apply the parameters
a445 1
	# destroy the window
a449 1
# apply the parameters to the actual combination on disk
d453 1
a453 1
    global ::tk::Priv
a455 2

    # get the Boolean expression fron the text widget
a457 2
    # if someone has edited the combination name, take care about
    # overwriting an existing object
d459 1
a459 1
	set ret [cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen)\
a469 3

	# this is a region

d471 1
a471 2
	    # region id is less than zero!!!!
	    cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen)\
d479 1
a479 2
	    # air code is less than zero!!!
	    cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen)\
d488 1
a488 2
	    # exactly one of region id and air code should be set
	    set ret [cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen)\
a497 1
	# get color
a503 1
	# actually apply the edist to the combination on disk
d510 1
a510 1
	    cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) \
a515 1
	# set any attributes that we have saved
d519 1
a519 1
	    cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) \
a527 4

    # this is not a region

    # get the color
a533 1
    # actually apply the edits to the combination on disk
d539 1
a539 1
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) \
d544 1
a544 2

    # set any attributes that we have saved
d548 1
a548 1
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) \
a556 2
# called when "Reset" button is pressed
# ignores any edits made and restores data from disk
d560 1
a560 1
    global ::tk::Priv
d565 1
a565 1
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen)\
a571 1
    # get the combination data from disk
d575 1
a575 1
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen)\
a581 1
    # get the attributes
d584 1
a584 1
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen)\
a619 1
    # save the attributes
a623 1
    # set all our data variables for the editor
d674 2
a675 2
		-sticky "nsew" \
		-in $top.shader_top_frame \
a677 4
	grid rowconfigure $top.shader_top_frame 0 -weight 0
	grid rowconfigure $top.shader_top_frame 1 -weight 1
	grid columnconfigure $top.shader_top_frame 0 -weight 1
	grid columnconfigure $top.shader_frame 0 -weight 1
a685 1
# called when "Dismiss" button is pressed
a688 1
    # destroy it all
a693 1
# called when "Is Region" checkbutton is pressed
d698 1
a698 1
    grid remove $top.id_los_air_mater
d701 32
a732 4
	grid $top.id_los_air_mater -in $comb_control($id,bool_frame) \
	    -padx $comb_control($id,padx) \
	    -pady $comb_control($id,pady) \
	    -sticky new -row 0 -column 0
d734 14
a747 1
	grid forget $top.id_los_air_mater
d749 2
d767 2
a768 2
	    -sticky "nsew" \
	    -in $top.shader_top_frame \
a770 5

    grid rowconfigure $top.shader_top_frame 0 -weight 0
    grid rowconfigure $top.shader_top_frame 1 -weight 1
    grid columnconfigure $top.shader_top_frame 0 -weight 1
    grid columnconfigure $top.shader_frame 0 -weight 1
a781 1
# mark name as dirty if someone edits it
@


1.42
log
@combination editor was erasing attributes
@
text
@a612 2
	} elseif { [string compare $key "temp"] == 0 } {
	    set keep 0
@


1.41
log
@*- add parameter to color_entry_build to indicate
   whether or not to use background colors for rt
@
text
@d516 9
d545 9
d581 42
@


1.40
log
@*- set tabs on text window
@
text
@d202 1
a202 1
	    12 $comb_control($id,color)
@


1.39
log
@*- mods requested by Eric regarding consistency
   when using capitalization in the GUI
@
text
@d317 2
a318 1
	    -yscrollcommand "$top.combS set" -setgrid true
@


1.38
log
@*- change unknown to unlisted
@
text
@d346 1
a346 1
    button $top.okB -relief raised -text "Ok"\
d348 1
a348 1
    hoc_register_data $top.okB "Ok"\
@


1.37
log
@Use tkPriv(cad_dialog) for dialog name.
@
text
@d297 3
a299 3
    $top.shaderMB.m add command -label "Unknown" \
	-command "comb_shader_gui $id unknown"
    hoc_register_menu_data "Shader" "Unknown" "Shader - unknown" \
@


1.36
log
@Changes to support the light shader gui
@
text
@d15 1
d18 1
a18 1
	cad_dialog .$id.uncool $mged_gui($id,screen) "No database." \
d452 1
d458 1
a458 1
	set ret [cad_dialog .$id.combDialog $mged_gui($id,screen)\
d470 1
a470 1
	    cad_dialog .$id.combDialog $mged_gui($id,screen)\
d478 1
a478 1
	    cad_dialog .$id.combDialog $mged_gui($id,screen)\
d487 1
a487 1
	    set ret [cad_dialog .$id.combDialog $mged_gui($id,screen)\
d509 1
a509 1
	    cad_dialog .$id.combDialog $mged_gui($id,screen) \
d529 1
a529 1
	cad_dialog .$id.combDialog $mged_gui($id,screen) \
d541 1
d546 1
a546 1
	cad_dialog .$id.combDialog $mged_gui($id,screen)\
d556 1
a556 1
	cad_dialog .$id.combDialog $mged_gui($id,screen)\
d596 1
a596 1
	set comb_control($id,color) [lindex [$top configure -bg] 4]
@


1.35
log
@Added more error checking:
  *- check id and air values
     (i.e. both zero, or both nonzero)
  *- warn user if about to overwrite
     an existing combination that has
     never been reconciled to the gui
@
text
@d234 9
@


1.34
log
@Added "light" shader to GUI, including Icons to help explain behaviour
@
text
@d51 4
a241 5

	$top.shaderMB.m add command -label "light" \
	    -command "comb_shader_gui $id light" 


d427 1
d431 6
a436 3
proc comb_ok { id top } {
    comb_apply $id
    comb_dismiss $id $top
d446 10
a455 4
# apply the parameters in the shader frame to the shader string
#    if { $comb_control($id,shader) != "" } then {
#	do_shader_apply comb_control($id,shader) $id
#    }
d463 1
a463 1
	    return
d471 1
a471 1
	    return
d474 10
a483 5
	if {$comb_control($id,id) == 0 && $comb_control($id,air) == 0} {
	    cad_dialog .$id.combDialog $mged_gui($id,screen)\
		    "Warning: both region id and air code are 0"\
		    "Warning: both region id and air code are 0"\
		    "" 0 OK
d491 2
a492 1
	set result [catch {put_comb $comb_control($id,name) $comb_control($id,isRegion) \
d497 5
a501 2
	if {$result} {
	    return $comb_error
d504 1
a504 1
	return
d512 2
a513 1
    set result [catch {put_comb $comb_control($id,name) $comb_control($id,isRegion)\
d517 5
a521 2
    if {$result} {
	return $comb_error
d523 2
d611 2
d615 1
a615 1
proc comb_dismiss { id top } {
d618 3
a620 2
    catch { destroy $top }
    catch { destroy $comb_control($id,shader_gui) }
d700 15
@


1.33
log
@Added Lee's 'extern' shader
@
text
@d238 5
@


1.33.2.1
log
@Added more error checking:
  *- check id and air values
     (i.e. both zero, or both nonzero)
  *- warn user if about to overwrite
     an existing combination that has
     never been reconciled to the gui.
@
text
@a50 4
    set comb_control($id,dirty_name) 1

    trace vdelete comb_control($id,name) w "comb_handle_trace $id"
    trace variable comb_control($id,name) w "comb_handle_trace $id"
a422 1
    wm protocol $top WM_DELETE_WINDOW "catch {comb_dismiss $id $top}"
d426 3
a428 6
proc comb_ok {id top} {
    set ret [comb_apply $id]

    if {$ret == 0} {
	comb_dismiss $id $top
    }
d438 4
a441 10
    if {$comb_control($id,dirty_name) && [db_exist $comb_control($id,name)]} {
	set ret [cad_dialog .$id.combDialog $mged_gui($id,screen)\
		"Warning!"\
		"Warning: about to overwrite $comb_control($id,name)"\
		"" 0 OK Cancel]

	if {$ret} {
	    return 1
	}
    }
d449 1
a449 1
	    return 1
d457 1
a457 1
	    return 1
d460 5
a464 10
	if {$comb_control($id,id) == 0 && $comb_control($id,air) == 0 ||
            $comb_control($id,id) != 0 && $comb_control($id,air) != 0} {
	    set ret [cad_dialog .$id.combDialog $mged_gui($id,screen)\
		    "Warning: both region id and air code are set/unset"\
		    "Warning: both region id and air code are set/unset"\
		    "" 0 OK Cancel]

	    if {$ret} {
		return 1
	    }
d472 1
a472 2

	set ret [catch {put_comb $comb_control($id,name) $comb_control($id,isRegion) \
d477 2
a478 5
	if {$ret} {
	    cad_dialog .$id.combDialog $mged_gui($id,screen) \
		    "comb_apply: Error"\
		    $comb_error\
		    "" 0 OK 
d481 1
a481 1
	return $ret
d489 1
a489 2

    set ret [catch {put_comb $comb_control($id,name) $comb_control($id,isRegion)\
d493 2
a494 5
    if {$ret} {
	cad_dialog .$id.combDialog $mged_gui($id,screen) \
		"comb_apply: Error"\
		$comb_error\
		"" 0 OK 
a495 2
    
    return $ret
a581 2

    set comb_control($id,dirty_name) 0
d584 1
a584 1
proc comb_dismiss {id top} {
d587 2
a588 3
    catch {destroy $top}
    catch {destroy $comb_control($id,shader_gui)}
    trace vdelete comb_control($id,name) w "comb_handle_trace $id"
a667 15
}

proc db_exist {obj} {
    set ret [catch {db get $obj}]
    if {$ret} {
	return 0
    } else {
	return 1
    }
}

proc comb_handle_trace {id name1 name2 op} {
    global comb_control

    set comb_control($id,dirty_name) 1
@


1.33.2.2
log
@Added light shader GUI
@
text
@a233 9


    $top.shaderMB.m add command -label light \
	    -command "comb_shader_gui $id light"
    hoc_register_menu_data "Shader" light "Shader - Light" \
	    { { summary "Set shader parameters to make this object appear as a light source." } }



@


1.33.2.3
log
@Use tkPriv(cad_dialog) for dialog name.
@
text
@a14 1
    global tkPriv
d17 1
a17 1
	cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "No database." \
a450 1
    global tkPriv
d456 1
a456 1
	set ret [cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen)\
d468 1
a468 1
	    cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen)\
d476 1
a476 1
	    cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen)\
d485 1
a485 1
	    set ret [cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen)\
d507 1
a507 1
	    cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) \
d527 1
a527 1
	cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) \
a538 1
    global tkPriv
d543 1
a543 1
	cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen)\
d553 1
a553 1
	cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen)\
d593 1
a593 1
	set comb_control($id,color) [$top cget -bg]
@


1.33.2.4
log
@*- change unknown to unlisted
@
text
@d297 3
a299 3
    $top.shaderMB.m add command -label "unlisted" \
	-command "comb_shader_gui $id unlisted"
    hoc_register_menu_data "Shader" "unlisted" "Shader - unlisted" \
@


1.32
log
@*- mods convert non-rgb entries to rgb before feeding
   to MGED
@
text
@d279 4
@


1.31
log
@*- add more menu items to "Name" menu
@
text
@d463 5
d470 1
a470 1
		$comb_control($id,los) $comb_control($id,color) $comb_control($id,shader) \
d480 5
d486 1
a486 1
	    $comb_control($id,color) $comb_control($id,shader) $comb_control($id,inherit)\
d550 8
a557 1
    color_entry_update $top color comb_control($id,color) $comb_control($id,color)
@


1.30
log
@*- check for open database
*- call color_entry_update with new signature
@
text
@d87 1
a87 14
a combination. At the moment there are two methods.
The first brings up a listbox containing the combinations
currently being displayed in the geometry window. The
user can select from among the combinations listed here.
The second selection method allows the user to use the
mouse to fire a ray at the combination of interest. If
only one combination is hit, that combination is selected.
If nothing is hit the user can simply fire another ray,
perhaps taking better aim :-). If more than one combination
is hit, a listbox of the hit combinations is presented
as with the first selection method. Note - When selecting
items from a listbox, a left buttonpress highlights the combination
in question until the button is released. To select a combination,
double click with the left mouse button." } }
d89 3
a91 3
    $top.nameMB.m add command -label "Select from all displayed"\
	    -command "winset \$mged_gui($id,active_dm); build_comb_menu_all"
    hoc_register_menu_data "Combination Selection Method" "Select from all displayed"\
d96 1
a96 1
Note - When selecting items from a listbox, a left buttonpress
d100 1
a100 1
    $top.nameMB.m add command -label "Select along ray"\
d102 1
a102 1
    hoc_register_menu_data "Combination Selection Method" "Select along ray"\
d111 1
a111 1
items from a listbox, a left buttonpress highlights
d115 24
@


1.29
log
@Added the 'air' shader
@
text
@d16 6
d529 1
a529 1
    color_entry_update $top color $comb_control($id,color)
@


1.28
log
@Added camo and projection shaders, and removed comb_callback
@
text
@d258 4
@


1.27
log
@*- call modified regdef and use the defaults that it returns
@
text
@d191 1
a191 2
    bind $top.shaderE <KeyRelease> "set_shader_params comb_control($id,shader) $id; \
	    comb_callback $id $top.gridF2"
d250 8
a625 30
}

# This is being called after a call to set_shader_params, which
# may build the shader GUI.
proc comb_callback { id master } {
    global comb_control

    set err [catch "set material [lindex $comb_control($id,shader) 0]"]
    if { $err != 0 } return

    if [is_good_shader $material] {
	# If not managing shader frame, then manage it.
	if { [llength [grid slaves $master] ] <= 1 } {
	    grid $comb_control($id,shader_frame) \
		    -row 1 \
		    -sticky "ew" \
		    -in $master \
		    -padx $comb_control($id,padx) \
		    -pady $comb_control($id,pady)
	}

	return
    }

    # We have a bad material type. If managing
    # the shader frame, then unmanage it.
    if { [llength [grid slaves $master] ] == 2 } {
	grid forget $comb_control($id,shader_frame)
	catch { destroy $comb_control($id,shader_gui) }
    }
@


1.26
log
@Added support for unrecognized shader strings and made some other small mods.
@
text
@d23 7
d36 4
a39 4
    set comb_control($id,id) ""
    set comb_control($id,air) ""
    set comb_control($id,material) ""
    set comb_control($id,los) ""
d483 18
a500 4
	set comb_control($id,id) [lindex $comb_defs 2]
	set comb_control($id,air) [lindex $comb_defs 3]
	set comb_control($id,material) [lindex $comb_defs 4]
	set comb_control($id,los) [lindex $comb_defs 5]
@


1.25
log
@*- use place_near_mouse proc to position widgets near the mouse
@
text
@d244 4
d605 2
a606 1
    set material [lindex $comb_control($id,shader) 0]
@


1.24
log
@*- cleanup variables
@
text
@d379 1
a379 4
    set pxy [winfo pointerxy $top]
    set x [lindex $pxy 0]
    set y [lindex $pxy 1]
    wm geometry $top +$x+$y
@


1.23
log
@*- moved entry labels beside (instead of on above) entry widgets
*- mods to manage/unmanage shader frame
@
text
@d12 1
a12 2
    global player_screen
    global mged_active_dm
d39 1
a39 1
    toplevel $top -screen $player_screen($id)
d90 1
a90 1
	    -command "winset \$mged_active_dm($id); build_comb_menu_all"
d101 1
a101 1
	    -command "winset \$mged_active_dm($id); set mouse_behavior c"
d392 1
a392 1
    global player_screen
d405 1
a405 1
	    cad_dialog .$id.combDialog $player_screen($id)\
d413 1
a413 1
	    cad_dialog .$id.combDialog $player_screen($id)\
d421 1
a421 1
	    cad_dialog .$id.combDialog $player_screen($id)\
d449 1
a449 1
    global player_screen
d455 1
a455 1
	cad_dialog .$id.combDialog $player_screen($id)\
d465 1
a465 1
	cad_dialog .$id.combDialog $player_screen($id)\
d629 1
a629 1
#    global player_screen
d639 1
a639 1
#    toplevel $top -screen $player_screen($id)
@


1.22
log
@*- mods to help data
@
text
@d15 1
d42 2
a43 2
    frame $top.gridF
    frame $top.gridF2
d46 9
a54 13
    frame $top.nameF
    frame $top.nameFF -relief sunken -bd 2
    frame $top.idF
    frame $top.idFF -relief sunken -bd 2
    frame $top.airF
    frame $top.airFF -relief sunken -bd 2
    frame $top.materialF
    frame $top.materialFF -relief sunken -bd 2
    frame $top.losF
    frame $top.losFF -relief sunken -bd 2
    frame $top.color_F
    frame $top.shaderF -relief groove -bd 2
    frame $top.shaderFF -relief sunken -bd 2
a55 1
    frame $top.combFF -relief sunken -bd 2
d57 3
a59 1
    set comb_control($id,shader_frame) $top.shaderF
d61 1
a61 1
    label $top.nameL -text "Name" -anchor w
d117 1
a117 1
    label $top.idL -text "Region Id" -anchor w
d129 1
a129 1
    label $top.airL -text "Air Code" -anchor w
d141 1
a141 1
    label $top.materialL -text "Material Id" -anchor w
d151 1
a151 1
    label $top.losL -text "LOS" -anchor w
d163 1
a163 1
    label $top.colorL -text "Color" -anchor w
d176 1
a176 1
    label $top.shaderL -text "Shader" -anchor w
d185 2
a186 1
    bind $top.shaderE <KeyRelease> "set_shader_params comb_control($id,shader) $id"
d196 3
a198 3
    $top.shaderMB.m add command -label plastic\
	    -command "comb_shader_gui $id plastic $top.shaderF"
    hoc_register_menu_data "Shader" plastic "Shader - Plastic"\
d200 3
a202 3
    $top.shaderMB.m add command -label mirror\
	    -command "comb_shader_gui $id mirror $top.shaderF"
    hoc_register_menu_data "Shader" mirror "Shader - Mirror"\
d204 3
a206 3
    $top.shaderMB.m add command -label glass\
	    -command "comb_shader_gui $id glass $top.shaderF"
    hoc_register_menu_data "Shader" glass "Shader - Glass"\
d208 2
a209 2
    $top.shaderMB.m add command -label "texture (color)"\
	    -command "comb_shader_gui $id texture $top.shaderF"
d212 3
a214 3
    $top.shaderMB.m add command -label "texture (b/w)"\
	    -command "comb_shader_gui $id bwtexture $top.shaderF"
    hoc_register_menu_data "Shader" "texture (b/w)" "Shader - Texture (b/w)"\
d216 3
a218 3
    $top.shaderMB.m add command -label "bump map"\
	    -command "comb_shader_gui $id bump $top.shaderF"
    hoc_register_menu_data "Shader" "bump map" "Shader - Bump"\
d220 3
a222 3
    $top.shaderMB.m add command -label "checker"\
	    -command "comb_shader_gui $id checker $top.shaderF"
    hoc_register_menu_data "Shader" "checker" "Shader - Checker"\
d224 3
a226 3
    $top.shaderMB.m add command -label "test map"\
	    -command "comb_shader_gui $id testmap $top.shaderF"
    hoc_register_menu_data "Shader" "test map" "Shader - testmap"\
d229 3
a231 3
    $top.shaderMB.m add command -label "fake star pattern"\
	    -command "comb_shader_gui $id fakestar $top.shaderF"
    hoc_register_menu_data "Shader" "fake star pattern" "Shader - fakestar"\
d233 3
a235 3
    $top.shaderMB.m add command -label "cloud"\
	-command "comb_shader_gui $id cloud $top.shaderF"
    hoc_register_menu_data "Shader" "cloud" "Shader - cloud"\
d237 3
a239 3
    $top.shaderMB.m add command -label "stack"\
	-command "comb_shader_gui $id stack $top.shaderF"
    hoc_register_menu_data "Shader" "stack" "Shader - stack"\
d241 3
a243 3
    $top.shaderMB.m add command -label "envmap"\
	-command "comb_shader_gui $id envmap $top.shaderF"
    hoc_register_menu_data "Shader" "envmap" "Shader - envmap"\
d261 1
a261 1
	    -yscrollcommand "$top.gridF3.s set" -setgrid true
d263 1
a263 1
    scrollbar $top.gridF3.s -relief flat -command "$top.combT yview"
d306 1
a306 1
    button $top.dismissB -relief raised -text "Dismiss"\
d308 1
a308 1
    hoc_register_data $top.dismissB "Dismiss"\
d311 1
a311 7
    grid $top.nameL -sticky "ew" -in $top.nameF
    grid $top.nameE $top.nameMB -sticky "ew" -in $top.nameFF
    grid $top.nameFF -sticky "ew" -in $top.nameF
    grid $top.idL -sticky "ew" -in $top.idF
    grid $top.idE -sticky "ew" -in $top.idFF
    grid $top.idFF -sticky "ew" -in $top.idF
    grid $top.nameF x $top.idF -sticky "ew" -in $top.gridF -pady $comb_control($id,pady)
d313 1
a313 1
    grid columnconfigure $top.nameFF 0 -weight 1
d315 2
a316 1
    grid columnconfigure $top.idFF 0 -weight 1
d318 1
a318 7
    grid $top.colorL -sticky "ew" -in $top.color_F
    grid $top.colorF -sticky "ew" -in $top.color_F
    grid $top.airL -sticky "ew" -in $top.airF
    grid $top.airE -sticky "ew" -in $top.airFF
    grid $top.airFF -sticky "ew" -in $top.airF
    grid $top.color_F x $top.airF -sticky "ew" -in $top.gridF -pady $comb_control($id,pady)
    grid columnconfigure $top.color_F 0 -weight 1
d320 2
a321 1
    grid columnconfigure $top.airFF 0 -weight 1
d323 1
a323 7
    grid $top.materialL -sticky "ew" -in $top.materialF
    grid $top.materialE -sticky "ew" -in $top.materialFF
    grid $top.materialFF -sticky "ew" -in $top.materialF
    grid $top.losL -sticky "ew" -in $top.losF
    grid $top.losE -sticky "ew" -in $top.losFF
    grid $top.losFF -sticky "ew" -in $top.losF
    grid $top.materialF x $top.losF -sticky "ew" -in $top.gridF -pady $comb_control($id,pady)
d325 1
a325 1
    grid columnconfigure $top.materialFF 0 -weight 1
d327 2
a328 1
    grid columnconfigure $top.losFF 0 -weight 1
d330 25
a354 9
    grid $top.shaderL -sticky "ew" -in $top.shaderF\
	    -padx $comb_control($id,padx) -pady $comb_control($id,pady)
    grid $top.shaderE $top.shaderMB -sticky "ew" -in $top.shaderFF
    grid $top.shaderFF -sticky "ew" -in $top.shaderF\
	    -padx $comb_control($id,padx) -pady $comb_control($id,pady)
    grid $top.shaderF - - -sticky "ew" -in $top.gridF -pady [expr $comb_control($id,pady) + 4]
#    grid $top.selectMaterialB -row 3 -column 2 -sticky "sw" -in $top.gridF -pady $comb_control($id,pady)
    grid columnconfigure $top.shaderF 0 -weight 1
    grid columnconfigure $top.shaderFF 0 -weight 1
d356 1
a356 1
    grid $top.isRegionCB $top.inheritCB x -sticky "ew" -in $top.gridF2\
d358 1
d360 4
a363 9
    grid columnconfigure $top.gridF 0 -weight 1
    grid columnconfigure $top.gridF 1 -minsize 20
    grid columnconfigure $top.gridF 2 -weight 1
    grid columnconfigure $top.gridF2 2 -weight 1

    grid $top.combL x -sticky "w" -in $top.gridF3
    grid $top.combT $top.gridF3.s -sticky "nsew" -in $top.gridF3
    grid rowconfigure $top.gridF3 1 -weight 1
    grid columnconfigure $top.gridF3 0 -weight 1
d366 3
a368 3
	    -in $top.gridF4 -pady $comb_control($id,pady)
    grid columnconfigure $top.gridF4 2 -weight 1
    grid columnconfigure $top.gridF4 4 -weight 1
d370 1
a370 1
    grid $top.gridF -sticky "ew" -padx $comb_control($id,padx) -pady $comb_control($id,pady)
d372 4
a375 3
    grid $top.gridF3 -sticky "nsew" -padx $comb_control($id,padx) -pady $comb_control($id,pady)
    grid $top.gridF4 -sticky "ew" -padx $comb_control($id,padx) -pady $comb_control($id,pady)
    grid rowconfigure $top 2 -weight 1
d400 3
a402 3
    if { $comb_control($id,shader) != "" } then {
	do_shader_apply comb_control($id,shader) $id
    }
d428 4
a431 4
	set result [catch {put_comb $comb_control($id,name) $comb_control($id,isRegion)\
		$comb_control($id,id) $comb_control($id,air) $comb_control($id,material) $comb_control($id,los)\
		$comb_control($id,color) $comb_control($id,shader) $comb_control($id,inherit)\
		$comb_control($id,comb)} comb_error]
d500 8
a507 1
	set comb_control($id,shader_gui) [do_shader comb_control($id,shader) $id $comb_control($id,shader_frame)]
d509 1
d525 1
a525 1
    grid remove $top.gridF
d528 1
a528 1
	grid forget $top.nameF $top.color_F $top.shaderF
d530 1
a530 9
	frame $top.idF
	frame $top.idFF -relief sunken -bd 2
	frame $top.airF
	frame $top.airFF -relief sunken -bd 2
	frame $top.materialF
	frame $top.materialFF -relief sunken -bd 2
	frame $top.losF
	frame $top.losFF -relief sunken -bd 2

d533 2
d536 1
d539 2
d542 1
d545 2
d548 1
d551 1
a551 24

	grid $top.idL -sticky "ew" -in $top.idF
	grid $top.idE -sticky "ew" -in $top.idFF
	grid $top.idFF -sticky "ew" -in $top.idF
	grid $top.nameF x $top.idF -sticky "ew" -row 0 -in $top.gridF -pady $comb_control($id,pady)
	grid columnconfigure $top.idF 0 -weight 1
	grid columnconfigure $top.idFF 0 -weight 1

	grid $top.airL -sticky "ew" -in $top.airF
	grid $top.airE -sticky "ew" -in $top.airFF
	grid $top.airFF -sticky "ew" -in $top.airF
	grid $top.color_F x $top.airF -sticky "ew" -in $top.gridF -pady $comb_control($id,pady)
	grid columnconfigure $top.airF 0 -weight 1
	grid columnconfigure $top.airFF 0 -weight 1

	grid $top.materialL -sticky "ew" -in $top.materialF
	grid $top.materialE -sticky "ew" -in $top.materialFF
	grid $top.materialFF -sticky "ew" -in $top.materialF
	grid $top.losL -sticky "ew" -in $top.losF
	grid $top.losE -sticky "ew" -in $top.losFF
	grid $top.losFF -sticky "ew" -in $top.losF
	grid $top.materialF x $top.losF -sticky "ew" -in $top.gridF -pady $comb_control($id,pady)

	grid $top.shaderF - - -sticky "ew" -in $top.gridF -pady [expr $comb_control($id,pady) + 4]
a552 1
	grid columnconfigure $top.losFF 0 -weight 1
d554 6
a559 2
	grid columnconfigure $top.materialF 0 -weight 1
	grid columnconfigure $top.materialFF 0 -weight 1
d561 11
a571 2
	grid forget $top.nameF $top.idF $top.airF $top.materialF $top.losF\
		$top.color_F $top.shaderF
d573 2
a574 12
	destroy $top.idL $top.idE
	destroy $top.airL $top.airE
	destroy $top.materialL $top.materialE
	destroy $top.losL $top.losE
	destroy $top.idF $top.idFF
	destroy $top.airF $top.airFF
	destroy $top.materialF $top.materialFF
	destroy $top.losF $top.losFF

	grid $top.nameF - - -sticky "ew" -row 0 -in $top.gridF -pady $comb_control($id,pady)
	grid $top.color_F - - -sticky "ew" -in $top.gridF -pady $comb_control($id,pady)
	grid $top.shaderF - - -sticky "ew" -in $top.gridF -pady $comb_control($id,pady)
d577 1
a577 1
    grid $top.gridF
d580 1
a580 1
proc comb_shader_gui { id shader_type shader_frame } {
d583 1
d590 37
a626 1
    set comb_control($id,shader_gui) [do_shader comb_control($id,shader) $id $shader_frame]
d642 3
a644 3
#    frame $top.gridF
#    frame $top.gridF2
#    frame $top.gridF3 -relief groove -bd 2
d658 2
a659 2
#    grid rowconfigure $top.gridF 0 -weight 1
#    grid columnconfigure $top.gridF 0 -weight 1
d661 9
a669 9
#    grid $top.materialL x -sticky "ew" -in $top.gridF2
#    grid $top.materialE $top.resetB -sticky "nsew" -in $top.gridF2
#    grid columnconfigure $top.gridF2 0 -weight 1
#
#    grid $top.dismissB -in $top.gridF3 -pady $comb_control($id,pady)
#
#    grid $top.gridF -sticky "nsew" -padx $comb_control($id,padx) -pady $comb_control($id,pady)
#    grid $top.gridF2 -sticky "ew" -padx $comb_control($id,padx) -pady $comb_control($id,pady)
#    grid $top.gridF3 -sticky "ew"
@


1.21
log
@Added envmap and cloud gui's.
@
text
@d64 1
a64 2
    hoc_register_data $top.nameL "Combination Name"\
	    { { summary "The combination name is the name of a
d70 1
d72 1
a72 2
    hoc_register_data $top.nameE "Combination Name"\
	    { { summary "Enter a combination name." } }
d120 1
a120 2
    hoc_register_data $top.idL "Region Id"\
	    { { summary "The region id (i.e. item code) is a number
d127 1
d129 1
a129 2
    hoc_register_data $top.idE "Region Id"\
	    { { summary "Enter region id." } }
d132 1
a132 2
    hoc_register_data $top.airL "Air Code"\
	    { { summary "The air code is a number that is typically
d139 1
d141 1
a141 2
    hoc_register_data $top.airE "Air Code"\
	    { { summary "Enter air code." } }
d144 6
a149 5
    hoc_register_data $top.materialL "Material Id"\
	    { { summary "The material id represents a particular
material type as identified by a material database.
In the past, the gift material database was used to
identify the material type." } }
d151 1
a151 2
    hoc_register_data $top.materialE "Material Id"\
	    { { summary "Enter material id." } }
d154 1
a154 2
    hoc_register_data $top.losL "LOS"\
	    { { summary "LOS is a number that represents the
d161 1
d163 1
a163 2
    hoc_register_data $top.losE "LOS"\
	    { { summary "Enter los." } }
d179 5
a183 4
    hoc_register_data $top.shaderL "Shader"\
	    { { summary "The shader is used by the raytracer
when rendering. The shader specification
greatly influences the resulting image." } }
d185 1
a185 5
    hoc_register_data $top.shaderE "Shader"\
	    { { summary "Use this to manually enter the shader
parameters. Note - when entering the
shader parameters directly, pressing \"Enter\"
will update the rest of the shader GUI." } }
d248 1
a248 2
    hoc_register_data $top.combL "Boolean Expression"\
	    { { summary "A boolean expression is used to combine
d251 1
a251 1
operator represents union. The union of two objects
d253 1
a253 1
operator represents difference. The difference of two
d256 1
a256 1
'+' operator represents intersection. The intersection
d260 1
d263 1
a263 2
    hoc_register_data $top.combT "Edit Boolean Expression"\
	    { { summary "Edit the boolean expression." } }
d293 4
@


1.20
log
@*- add Ok button
@
text
@d241 4
d249 4
@


1.19
log
@Added shader parameter parsing with each keystroke.
@
text
@d291 2
d365 1
a365 1
    grid $top.applyB x $top.resetB x $top.dismissB -sticky "ew"\
d367 2
a368 2
    grid columnconfigure $top.gridF4 1 -weight 1
    grid columnconfigure $top.gridF4 3 -weight 1
d384 5
@


1.18
log
@Started adding stack shader.
@
text
@d194 1
a194 1
    bind $top.shaderE <Return> "set_shader_params comb_control($id,shader) $id"
@


1.17
log
@Added more shader guis
@
text
@d232 1
a232 1
    $top.shaderMB.m add command -label "Test Map"\
d234 1
a234 1
    hoc_register_menu_data "Shader" "Test Map" "Shader - testmap"\
d237 1
a237 1
    $top.shaderMB.m add command -label "Fake Star Pattern"\
d239 1
a239 1
    hoc_register_menu_data "Shader" "Fake Star" "Shader - fakestar"\
d241 4
d392 3
a394 1
    do_shader_apply comb_control($id,shader) $id
@


1.16
log
@*- use color_entry_update
@
text
@d207 1
a207 1
	    { { summary "See jra for info on plastic." } }
d211 1
a211 1
	    { { summary "See jra for info on mirror." } }
d215 1
a215 1
	    { { summary "See jra for info on glass." } }
d219 1
a219 1
	    { { summary "See jra for info on texture (color)." } }
d223 18
a240 1
	    { { summary "See jra for info on texture (b/w)." } }
@


1.15
log
@*- remove left over color routines
@
text
@d460 1
a460 1
    set_WidgetRGBColor $top.colorMB $comb_control($id,color)
@


1.14
log
@*- add help messages
*- use new routine for color menu (i.e. color_entry_build)
*- some clean up
@
text
@a180 17
    hoc_register_data $top.colorE "Color"\
	    { { summary "Enter a color specification. The color
is specified using three integers (i.e. r g b)
in the range 0 to 255. For example:

\tblack\t\t0 0 0
\twhite\t\t255 255 255
\tred\t\t255 0 0
\tgreen\t\t0 255 0
\tblue\t\t0 0 255
\tyellow\t\t255 255 0
\tcyan\t\t0 255 255
\tmagenta\t\t255 0 255

Note - when entering colors directly,
pressing \"Enter\" will update the color
of the menubutton." } }
a353 3
    bind $top.colorE <Return> "comb_set_colorMB $id; break"
    comb_set_colorMB $id

a558 31
}

proc comb_choose_color { id parent } {
    global player_screen

    set child color

    cadColorWidget dialog $parent $child\
	    -title "Combination Color"\
	    -initialcolor [$parent.colorMB cget -background]\
	    -ok "comb_color_ok $id $parent $parent.$child"\
	    -cancel "cadColorWidget_destroy $parent.$child"
}

proc comb_color_ok { id parent w } {
    global comb_control

    upvar #0 $w data

    $parent.colorMB configure -bg $data(finalColor)
    set comb_control($id,color) "$data(red) $data(green) $data(blue)"

    destroy $w
    unset data
}

proc comb_set_colorMB { id } {
    global comb_control

    set top .$id.comb
    set_WidgetRGBColor $top.colorMB $comb_control($id,color)
@


1.13
log
@Added binding for <Return> to shader params entry widget to parse string
and set individual widget values.
@
text
@d31 1
a31 1
    set comb_control($id,gift) ""
d51 2
a52 2
    frame $top.giftF
    frame $top.giftFF -relief sunken -bd 2
d55 1
a55 2
    frame $top.colorF
    frame $top.colorFF -relief sunken -bd 2
d64 7
d72 2
d76 17
a92 1
    menu $top.nameMB.m -tearoff 0
d95 9
d106 13
d121 8
d130 2
d134 8
d143 2
d146 9
a154 2
    label $top.giftL -text "Gift Material" -anchor w
    entry $top.giftE -relief flat -width 12 -textvar comb_control($id,gift)
d157 8
d166 2
d170 28
a197 23
    entry $top.colorE -relief flat -width 12 -textvar comb_control($id,color)
    menubutton $top.colorMB -relief raised -bd 2\
	    -menu $top.colorMB.m -indicatoron 1
    menu $top.colorMB.m -tearoff 0
    $top.colorMB.m add command -label black\
	     -command "set comb_control($id,color) \"0 0 0\"; comb_set_colorMB $id"
    $top.colorMB.m add command -label white\
	     -command "set comb_control($id,color) \"220 220 220\"; comb_set_colorMB $id"
    $top.colorMB.m add command -label red\
	     -command "set comb_control($id,color) \"220 0 0\"; comb_set_colorMB $id"
    $top.colorMB.m add command -label green\
	     -command "set comb_control($id,color) \"0 220 0\"; comb_set_colorMB $id"
    $top.colorMB.m add command -label blue\
	     -command "set comb_control($id,color) \"0 0 220\"; comb_set_colorMB $id"
    $top.colorMB.m add command -label yellow\
	     -command "set comb_control($id,color) \"220 220 0\"; comb_set_colorMB $id"
    $top.colorMB.m add command -label cyan\
	    -command "set comb_control($id,color) \"0 220 220\"; comb_set_colorMB $id"
    $top.colorMB.m add command -label magenta\
	    -command "set comb_control($id,color) \"220 0 220\"; comb_set_colorMB $id"
    $top.colorMB.m add separator
    $top.colorMB.m add command -label "Color Tool..."\
	    -command "comb_choose_color $id $top"
d200 4
d205 6
d215 6
a220 1
    menu $top.shaderMB.m -tearoff 0
d223 2
d227 2
d231 2
d235 2
d239 2
d243 13
d258 2
a261 3
#    button $top.selectGiftB -relief raised -text "Select Gift Material"\
#	    -command "comb_select_gift $id"

d265 11
d278 8
d289 3
d294 3
d299 2
d314 2
a315 3
    grid $top.colorL -sticky "ew" -in $top.colorF
    grid $top.colorE $top.colorMB -sticky "ew" -in $top.colorFF
    grid $top.colorFF -sticky "ew" -in $top.colorF
d319 2
a320 3
    grid $top.colorF x $top.airF -sticky "ew" -in $top.gridF -pady $comb_control($id,pady)
    grid columnconfigure $top.colorF 0 -weight 1
    grid columnconfigure $top.colorFF 0 -weight 1
d324 3
a326 3
    grid $top.giftL -sticky "ew" -in $top.giftF
    grid $top.giftE -sticky "ew" -in $top.giftFF
    grid $top.giftFF -sticky "ew" -in $top.giftF
d330 3
a332 3
    grid $top.giftF x $top.losF -sticky "ew" -in $top.gridF -pady $comb_control($id,pady)
    grid columnconfigure $top.giftF 0 -weight 1
    grid columnconfigure $top.giftFF 0 -weight 1
d342 1
a342 1
#    grid $top.selectGiftB -row 3 -column 2 -sticky "sw" -in $top.gridF -pady $comb_control($id,pady)
d418 1
a418 1
		$comb_control($id,id) $comb_control($id,air) $comb_control($id,gift) $comb_control($id,los)\
d467 1
a467 1
	set comb_control($id,gift) [lindex $comb_defs 4]
d509 1
a509 1
	grid forget $top.nameF $top.colorF $top.shaderF
d515 2
a516 2
	frame $top.giftF
	frame $top.giftFF -relief sunken -bd 2
d526 2
a527 2
	label $top.giftL -text "Gift Material" -anchor w
	entry $top.giftE -relief flat -width 12 -textvar comb_control($id,gift)
a531 3
#	button $top.selectGiftB -relief raised -text "Select Gift Material"\
#		-command "comb_select_gift $id"

d542 1
a542 1
	grid $top.colorF x $top.airF -sticky "ew" -in $top.gridF -pady $comb_control($id,pady)
d546 3
a548 3
	grid $top.giftL -sticky "ew" -in $top.giftF
	grid $top.giftE -sticky "ew" -in $top.giftFF
	grid $top.giftFF -sticky "ew" -in $top.giftF
d552 1
a552 1
	grid $top.giftF x $top.losF -sticky "ew" -in $top.gridF -pady $comb_control($id,pady)
d558 2
a559 3
#	grid $top.selectGiftB -row 3 -column 2 -sticky "sw" -in $top.gridF -pady $comb_control($id,pady)
	grid columnconfigure $top.giftF 0 -weight 1
	grid columnconfigure $top.giftFF 0 -weight 1
d561 2
a562 4
	grid forget $top.nameF $top.idF $top.airF $top.giftF $top.losF\
		$top.colorF $top.shaderF
#	grid forget $top.nameF $top.idF $top.airF $top.giftF $top.losF\
#		$top.colorF $top.shaderF $top.selectGiftB
d566 1
a566 1
	destroy $top.giftL $top.giftE
a567 1
#	destroy $top.selectGiftB
d570 1
a570 1
	destroy $top.giftF $top.giftFF
d574 1
a574 1
	grid $top.colorF - - -sticky "ew" -in $top.gridF -pady $comb_control($id,pady)
d624 1
a624 1
#proc comb_select_gift { id } {
d628 1
a628 1
#    set top .$id.sel_gift
d641 2
a642 2
#    listbox $top.giftLB -selectmode single -yscrollcommand "$top.giftS set"
#    scrollbar $top.giftS -relief flat -command "$top.giftLB yview"
d644 2
a645 2
#    label $top.giftL -text "Gift List:" -anchor w
#    entry $top.giftE -width 12 -textvar comb_control($id,gift_list)
d648 1
a648 1
#	    -command "load_gift_material $id"
d652 1
a652 1
#    grid $top.giftLB $top.giftS -sticky "nsew" -in $top.gridF
d656 2
a657 2
#    grid $top.giftL x -sticky "ew" -in $top.gridF2
#    grid $top.giftE $top.resetB -sticky "nsew" -in $top.gridF2
d668 1
a668 1
#    wm title $top "Select Gift Material"
d671 1
a671 1
#proc load_gift_material { id } {
@


1.12
log
@*- keep track of padding within comb_control
	(i.e. comb_control($id,padx) for x padding)
*- add groove around shader along with padding
*- mods to grid management of shader when toggling
	if its a region or not.
@
text
@d113 2
@


1.11
log
@Minors mods for shaders.
@
text
@d24 2
a25 2
    set padx 4
    set pady 2
d57 1
a57 1
    frame $top.shaderF
d154 1
a154 1
    grid $top.nameF x $top.idF -sticky "ew" -in $top.gridF -pady $pady
d166 1
a166 1
    grid $top.colorF x $top.airF -sticky "ew" -in $top.gridF -pady $pady
d178 1
a178 1
    grid $top.giftF x $top.losF -sticky "ew" -in $top.gridF -pady $pady
d184 2
a185 1
    grid $top.shaderL -sticky "ew" -in $top.shaderF
d187 4
a190 3
    grid $top.shaderFF -sticky "ew" -in $top.shaderF
    grid $top.shaderF - - -sticky "ew" -in $top.gridF -pady $pady
#    grid $top.selectGiftB -row 3 -column 2 -sticky "sw" -in $top.gridF -pady $pady
d208 1
a208 1
	    -in $top.gridF4 -pady $pady
d212 4
a215 4
    grid $top.gridF -sticky "ew" -padx $padx -pady $pady
    grid $top.gridF2 -sticky "ew" -padx $padx -pady $pady
    grid $top.gridF3 -sticky "nsew" -padx $padx -pady $pady
    grid $top.gridF4 -sticky "ew" -padx $padx -pady $pady
d386 1
a386 1
	grid $top.nameF x $top.idF -sticky "ew" -row 0 -in $top.gridF -pady $pady
d393 1
a393 1
	grid $top.colorF x $top.airF -sticky "ew" -in $top.gridF -pady $pady
d397 3
d403 3
a405 1
	grid $top.shaderF x $top.losF -sticky "ew" -in $top.gridF -pady $pady
d409 1
a409 5
	grid $top.giftL -sticky "ew" -in $top.giftF
	grid $top.giftE -sticky "ew" -in $top.giftFF
	grid $top.giftFF -sticky "ew" -in $top.giftF
	grid $top.giftF x x -sticky "ew" -in $top.gridF -pady $pady
#	grid $top.selectGiftB -row 3 -column 2 -sticky "sw" -in $top.gridF -pady $pady
d428 3
a430 3
	grid $top.nameF x x -sticky "ew" -in $top.gridF -pady $pady
	grid $top.colorF x x -sticky "ew" -in $top.gridF -pady $pady
	grid $top.shaderF x x -sticky "ew" -in $top.gridF -pady $pady
d515 1
a515 1
#    grid $top.dismissB -in $top.gridF3 -pady $pady
d517 2
a518 2
#    grid $top.gridF -sticky "nsew" -padx $padx -pady $pady
#    grid $top.gridF2 -sticky "ew" -padx $padx -pady $pady
@


1.10
log
@Added shaders to combination editor.
@
text
@d122 1
a122 1
    $top.shaderMB.m add command -label texture\
d124 2
d335 1
a335 1
	do_shader comb_control($id,shader) $id $comb_control($id,shader_frame)
d469 1
a469 1
    if {$current_shader_type != $shader_type} {
@


1.9
log
@*- reduce the padding between widgets
@
text
@d62 2
d117 1
a117 1
	    -command "comb_shader_gui $id plastic"
d119 1
a119 1
	    -command "comb_shader_gui $id mirror"
d121 3
a123 1
	    -command "comb_shader_gui $id glass"
d170 3
a172 3
    grid $top.shaderL -sticky "ew" -in $top.shaderF
    grid $top.shaderE $top.shaderMB -sticky "ew" -in $top.shaderFF
    grid $top.shaderFF -sticky "ew" -in $top.shaderF
d176 3
a178 3
    grid $top.shaderF x $top.losF -sticky "ew" -in $top.gridF -pady $pady
    grid columnconfigure $top.shaderF 0 -weight 1
    grid columnconfigure $top.shaderFF 0 -weight 1
d182 4
a185 4
    grid $top.giftL -sticky "ew" -in $top.giftF
    grid $top.giftE -sticky "ew" -in $top.giftFF
    grid $top.giftFF -sticky "ew" -in $top.giftF
    grid $top.giftF x x -sticky "ew" -in $top.gridF -pady $pady
d187 2
a188 2
    grid columnconfigure $top.giftF 0 -weight 1
    grid columnconfigure $top.giftFF 0 -weight 1
d234 3
d331 6
a348 3
    set padx 4
    set pady 2

d462 1
a462 1
proc comb_shader_gui { id shader_type } {
d471 1
a471 1
    set comb_control($id,shader_gui) [do_shader comb_control($id,shader) $id]
a484 3
#    set padx 4
#    set pady 2
#
d523 1
a523 1
#}@


1.8
log
@*- added parameter to call to do_shader
@
text
@d23 4
d148 1
a148 1
    grid $top.nameF x $top.idF -sticky "ew" -in $top.gridF -pady 8
d160 1
a160 1
    grid $top.colorF x $top.airF -sticky "ew" -in $top.gridF -pady 8
d172 1
a172 1
    grid $top.shaderF x $top.losF -sticky "ew" -in $top.gridF -pady 8
d181 2
a182 2
    grid $top.giftF x x -sticky "ew" -in $top.gridF -pady 8
#    grid $top.selectGiftB -row 3 -column 2 -sticky "sw" -in $top.gridF -pady 8
d200 1
a200 1
	    -in $top.gridF4 -pady 8
d204 4
a207 4
    grid $top.gridF -sticky "ew" -padx 8 -pady 8
    grid $top.gridF2 -sticky "ew" -padx 8 -pady 8
    grid $top.gridF3 -sticky "nsew" -padx 8 -pady 8
    grid $top.gridF4 -sticky "ew" -padx 8 -pady 8
d336 3
d372 1
a372 1
	grid $top.nameF x $top.idF -sticky "ew" -row 0 -in $top.gridF -pady 8
d379 1
a379 1
	grid $top.colorF x $top.airF -sticky "ew" -in $top.gridF -pady 8
d386 1
a386 1
	grid $top.shaderF x $top.losF -sticky "ew" -in $top.gridF -pady 8
d393 2
a394 2
	grid $top.giftF x x -sticky "ew" -in $top.gridF -pady 8
#	grid $top.selectGiftB -row 3 -column 2 -sticky "sw" -in $top.gridF -pady 8
d413 3
a415 3
	grid $top.nameF x x -sticky "ew" -in $top.gridF -pady 8
	grid $top.colorF x x -sticky "ew" -in $top.gridF -pady 8
	grid $top.shaderF x x -sticky "ew" -in $top.gridF -pady 8
d475 3
d503 1
a503 1
#    grid $top.dismissB -in $top.gridF3 -pady 8
d505 2
a506 2
#    grid $top.gridF -sticky "nsew" -padx 8 -pady 8
#    grid $top.gridF2 -sticky "ew" -padx 8 -pady 16
@


1.7
log
@*- mods to use comb_control
*- mods to use jra's do_shader routine
@
text
@d454 1
a454 1
    set comb_control($id,shader_gui) [do_shader comb_control($id,shader)]
@


1.6
log
@*- cleanup
@
text
@d14 1
a14 10
    global comb_name
    global comb_isRegion
    global comb_id
    global comb_air
    global comb_gift
    global comb_los
    global comb_color
    global comb_shader
    global comb_inherit
    global comb_comb
d23 11
a33 10
    set comb_name($id) ""
    set comb_isRegion($id) "Yes"
    set comb_id($id) ""
    set comb_air($id) ""
    set comb_gift($id) ""
    set comb_los($id) ""
    set comb_color($id) ""
    set comb_shader($id) ""
    set comb_inherit($id) ""
    set comb_comb($id) ""
d59 1
a59 1
    entry $top.nameE -relief flat -width 12 -textvar comb_name($id)
d69 1
a69 1
    entry $top.idE -relief flat -width 12 -textvar comb_id($id)
d72 1
a72 1
    entry $top.airE -relief flat -width 12 -textvar comb_air($id)
d75 1
a75 1
    entry $top.giftE -relief flat -width 12 -textvar comb_gift($id)
d78 1
a78 1
    entry $top.losE -relief flat -width 12 -textvar comb_los($id)
d81 1
a81 1
    entry $top.colorE -relief flat -width 12 -textvar comb_color($id)
d86 1
a86 1
	     -command "set comb_color($id) \"0 0 0\"; comb_set_colorMB $id"
d88 1
a88 1
	     -command "set comb_color($id) \"220 220 220\"; comb_set_colorMB $id"
d90 1
a90 1
	     -command "set comb_color($id) \"220 0 0\"; comb_set_colorMB $id"
d92 1
a92 1
	     -command "set comb_color($id) \"0 220 0\"; comb_set_colorMB $id"
d94 1
a94 1
	     -command "set comb_color($id) \"0 0 220\"; comb_set_colorMB $id"
d96 1
a96 1
	     -command "set comb_color($id) \"220 220 0\"; comb_set_colorMB $id"
d98 1
a98 1
	    -command "set comb_color($id) \"0 220 220\"; comb_set_colorMB $id"
d100 1
a100 1
	    -command "set comb_color($id) \"220 0 220\"; comb_set_colorMB $id"
d106 1
a106 1
    entry $top.shaderE -relief flat -width 12 -textvar comb_shader($id)
a109 2
    $top.shaderMB.m add command -label default\
	    -command "set comb_shader($id) default"
d111 1
a111 1
	    -command "set comb_shader($id) plastic"
d113 1
a113 1
	    -command "set comb_shader($id) mirror"
d115 1
a115 1
	    -command "set comb_shader($id) glass"
d126 1
a126 1
	    -offvalue No -onvalue Yes -variable comb_isRegion($id)\
d129 1
a129 1
	    -offvalue No -onvalue Yes -variable comb_inherit($id)
d136 1
a136 1
	    -command "catch { destroy $top }"
d163 1
a163 1
    grid $top.shaderE -sticky "ew" -in $top.shaderFF
d195 1
a195 1
    grid $top.applyB $top.resetB x $top.dismissB -sticky "ew"\
d197 2
a198 1
    grid columnconfigure $top.gridF4 2 -weight 1
d221 1
a221 10
    global comb_name
    global comb_isRegion
    global comb_id
    global comb_air
    global comb_gift
    global comb_los
    global comb_color
    global comb_shader
    global comb_inherit
    global comb_comb
d224 1
a224 1
    set comb_comb($id) [$top.combT get 0.0 end]
d226 2
a227 2
    if {$comb_isRegion($id)} {
	if {$comb_id($id) < 0} {
d235 1
a235 1
	if {$comb_air($id) < 0} {
d243 1
a243 1
	if {$comb_id($id) == 0 && $comb_air($id) == 0} {
d250 4
a253 4
	set result [catch {put_comb $comb_name($id) $comb_isRegion($id)\
		$comb_id($id) $comb_air($id) $comb_gift($id) $comb_los($id)\
		$comb_color($id) $comb_shader($id) $comb_inherit($id)\
		$comb_comb($id)} comb_error]
d262 3
a264 3
    set result [catch {put_comb $comb_name($id) $comb_isRegion($id)\
	    $comb_color($id) $comb_shader($id) $comb_inherit($id)\
	    $comb_comb($id)} comb_error]
d273 1
a273 10
    global comb_name
    global comb_isRegion
    global comb_id
    global comb_air
    global comb_gift
    global comb_los
    global comb_color
    global comb_shader
    global comb_inherit
    global comb_comb
d277 1
a277 1
    if {$comb_name($id) == ""} {
d285 2
a286 2
    set save_isRegion $comb_isRegion($id)
    set result [catch {get_comb $comb_name($id)} comb_defs]
d295 1
a295 1
    set comb_isRegion($id) [lindex $comb_defs 1]
d297 9
a305 9
    if {$comb_isRegion($id) == "Yes"} {
	set comb_id($id) [lindex $comb_defs 2]
	set comb_air($id) [lindex $comb_defs 3]
	set comb_gift($id) [lindex $comb_defs 4]
	set comb_los($id) [lindex $comb_defs 5]
	set comb_color($id) [lindex $comb_defs 6]
	set comb_shader($id) [lindex $comb_defs 7]
	set comb_inherit($id) [lindex $comb_defs 8]
	set comb_comb($id) [lindex $comb_defs 9]
d307 4
a310 4
	set comb_color($id) [lindex $comb_defs 2]
	set comb_shader($id) [lindex $comb_defs 3]
	set comb_inherit($id) [lindex $comb_defs 4]
	set comb_comb($id) [lindex $comb_defs 5]
d313 1
a313 1
    set_WidgetRGBColor $top.colorMB $comb_color($id)
d315 1
a315 1
    $top.combT insert end $comb_comb($id)
d317 1
a317 1
    if {$save_isRegion != $comb_isRegion($id)} {
d322 7
d330 1
a330 1
    global comb_isRegion
d335 1
a335 1
    if {$comb_isRegion($id) == "Yes"} {
d348 1
a348 1
	entry $top.idE -relief flat -width 12 -textvar comb_id($id)
d351 1
a351 1
	entry $top.airE -relief flat -width 12 -textvar comb_air($id)
d354 1
a354 1
	entry $top.giftE -relief flat -width 12 -textvar comb_gift($id)
d357 1
a357 1
	entry $top.losE -relief flat -width 12 -textvar comb_los($id)
d427 1
a427 1
    global comb_color
d432 1
a432 1
    set comb_color($id) "$data(red) $data(green) $data(blue)"
d439 1
a439 1
    global comb_color
d442 13
a454 1
    set_WidgetRGBColor $top.colorMB $comb_color($id)
d459 1
a459 2
#    global comb_gift
#    global comb_gift_list
d478 1
a478 1
#    entry $top.giftE -width 12 -textvar comb_gift_list($id)
d505 1
a505 2
#    global comb_gift
#    global comb_gift_list
@


1.5
log
@*- added (id) to the title
@
text
@d143 2
a144 2
    button $top.loadDefB -relief raised -text "Reset"\
	    -command "comb_load_defaults $id"
d205 1
a205 1
    grid $top.applyB $top.loadDefB x $top.dismissB -sticky "ew"\
d219 1
a219 1
    bind $top.nameE <Return> "comb_load_defaults $id; break"
d289 1
a289 1
proc comb_load_defaults { id } {
d316 1
a316 1
		"comb_load_defaults: Error"\
d489 1
a489 1
#    button $top.loadB -relief raised -text "Load"\
d499 1
a499 1
#    grid $top.giftE $top.loadB -sticky "nsew" -in $top.gridF2
@


1.4
log
@*- mods to reflect parameter change in cadColorWidget()
*- a little house cleaning
@
text
@d225 1
a225 1
    wm title $top "Combination Editor"
@


1.3
log
@*- append "break" to bindings to prevent further processing
@
text
@d111 1
a111 1
	    -command "comb_choose_color $id"
d434 1
a434 1
proc comb_choose_color { id } {
a435 1
    global comb_color
d437 1
a437 1
    set top .$id.comb
d439 5
a443 4
    cadColorWidget dialog $top -title "Combination Color"\
	    -initialcolor [$top.colorMB cget -background]\
	    -ok "comb_color_ok $id $top.colorWidget"\
	    -cancel "comb_color_cancel $id $top.colorWidget"
d446 1
a446 1
proc comb_color_ok { id w } {
d451 1
a451 2
    set top .$id.comb
    $top.colorMB configure -bg $data(finalColor)
a452 7

    destroy $w
    unset data
}

proc comb_color_cancel { id w } {
    upvar #0 $w data
@


1.2
log
@*- use cad_dialog instead of mged_dialog
*- use new cadColorWidget
*- new procs: comb_color_ok() and comb_color_cancel()
@
text
@d216 1
a216 1
    bind $top.colorE <Return> "comb_set_colorMB $id"
d219 1
a219 1
    bind $top.nameE <Return> "comb_load_defaults $id"
@


1.1
log
@Initial revision
@
text
@d25 1
a25 1
    set top .comb$id
d241 1
a241 1
    set top .comb$id
d246 1
a246 1
	    mged_dialog .$id.combDialog $player_screen($id)\
d254 1
a254 1
	    mged_dialog .$id.combDialog $player_screen($id)\
d262 1
a262 1
	    mged_dialog .$id.combDialog $player_screen($id)\
d302 1
a302 1
    set top .comb$id
d305 1
a305 1
	mged_dialog .$id.combDialog $player_screen($id)\
d315 1
a315 1
	mged_dialog .$id.combDialog $player_screen($id)\
d352 1
a352 1
    set top .comb$id
d438 1
a438 2
    set top .comb$id
    set colors [chooseColor $top]
d440 18
a457 3
    if {[llength $colors] == 0} {
	return
    }
d459 2
a460 7
    if {[llength $colors] != 2} {
	mged_dialog .$id.combDialog $player_screen($id)\
		"Error choosing a color!"\
		"Error choosing a color!"\
		"" 0 OK
	return
    }
d462 2
a463 2
    $top.colorMB configure -bg [lindex $colors 0]
    set comb_color($id) [lindex $colors 1]
d469 1
a469 1
    set top .comb$id
@
