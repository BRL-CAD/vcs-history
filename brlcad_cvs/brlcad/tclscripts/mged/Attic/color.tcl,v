head	1.12;
access;
symbols
	ansi-20040405-merged:1.10.4.1
	postmerge-20040405-ansi:1.11
	premerge-20040404-ansi:1.11
	postmerge-autoconf:1.11
	autoconf-freeze:1.11
	premerge-autoconf:1.11
	postmerge-20040315-windows:1.11
	premerge-20040315-windows:1.11
	windows-20040315-freeze:1.10.6.1
	autoconf-20031203:1.11
	autoconf-20031202:1.11
	autoconf-branch:1.11.0.4
	phong-branch:1.11.0.2
	photonmap-branch:1.10.0.8
	rel-6-1-DP:1.10
	windows-branch:1.10.0.6
	rel-6-0-2:1.10
	ansi-branch:1.10.0.4
	rel-6-0-1-branch:1.10.0.2
	hartley-6-0-post:1.10
	hartley-6-0-pre:1.10
	rel-6-0-1:1.10
	rel-6-0:1.10
	rel-5-4:1.7.2.1
	offsite-5-3-pre:1.8
	rel-5-3:1.7.2.1
	rel-5-2:1.7
	rel-5-1-branch:1.7.0.2
	rel-5-1:1.7
	rel-5-0:1.7
	rel-5-0-beta:1.5
	rel-4-5:1.1;
locks; strict;
comment	@# @;


1.12
date	2004.05.21.16.41.22;	author morrison;	state dead;
branches;
next	1.11;

1.11
date	2003.05.12.00.28.09;	author jra;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.30.20.25.17;	author bparker;	state Exp;
branches
	1.10.4.1
	1.10.6.1
	1.10.8.1;
next	1.9;

1.9
date	2001.09.07.14.54.05;	author bparker;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.22.00.45.24;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	99.09.10.23.07.07;	author bparker;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	99.09.01.18.47.47;	author bparker;	state Exp;
branches;
next	1.5;

1.5
date	99.04.09.21.27.35;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	98.11.25.14.23.03;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	98.10.21.17.41.53;	author bparker;	state Exp;
branches;
next	1.2;

1.2
date	98.06.09.18.14.46;	author bparker;	state Exp;
branches;
next	1.1;

1.1
date	97.09.29.16.00.24;	author bparker;	state Exp;
branches;
next	;

1.7.2.1
date	2000.12.22.00.03.36;	author bparker;	state Exp;
branches;
next	;

1.10.4.1
date	2004.03.17.21.23.10;	author morrison;	state Exp;
branches;
next	;

1.10.6.1
date	2004.03.11.23.48.58;	author morrison;	state Exp;
branches;
next	;

1.10.8.1
date	2003.08.26.14.04.47;	author justin;	state Exp;
branches;
next	;


desc
@color utilities
@


1.12
log
@moved to src/tclscripts/
@
text
@##
#			C O L O R . T C L
#
# Author -
#	Robert G. Parker
#
# Source -
#       The U. S. Army Research Laboratory
#       Aberdeen Proving Ground, Maryland  21005
#
# Distribution Notice -
#       Re-distribution of this software is restricted, as described in
#       your "Statement of Terms and Conditions for the Release of
#       The BRL-CAD Package" agreement.
#
# Description -
#	Color utilities.
#

## color_entry_build --
#
# Build a color entry widget. The color entry widget consists of
# an entry and a menubutton widget. The menu associated with the 
# menubutton contains some canned color entries as well as an
# entry that invokes a user specified command for setting the color.
#
proc color_entry_build { top key vn user_color_cmd width icolor canned_colors } {
    frame $top.$key\F -relief sunken -bd 2
    entry $top.$key\E -relief flat -width $width -textvar $vn
    hoc_register_data $top.$key\E "Color"\
	    { { summary "Enter a color specification. The color
can be specified using three integers (i.e. r g b)
in the range 0 to 255. For example:

\tblack\t\t0 0 0
\twhite\t\t255 255 255
\tred\t\t255 0 0
\tgreen\t\t0 255 0
\tblue\t\t0 0 255
\tyellow\t\t255 255 0
\tcyan\t\t0 255 255
\tmagenta\t\t255 0 255

The color can also be specified using a six character
hexadecimal number (i.e. #ff0000 specifies red). And
of course the color can be specified by name. For
example, the name \"blue\" specifies a color with
an rgb value of 0 0 255.

Note - when entering colors directly,
pressing \"Enter\" will update the color
of the menubutton." } }

    menubutton $top.$key\MB -relief raised -bd 2\
	    -menu $top.$key\MB.m -indicatoron 1
    hoc_register_data $top.$key\MB "Color Menu"\
	    { { summary "Pop up a menu of colors. Also included
in the menu is an entry for a color tool." } }
    menu $top.$key\MB.m -title "Color" -tearoff 0

if {$canned_colors == "rt"} {
    $top.$key\MB.m add command -background #000032 -activebackground #000032 \
	    -command "set $vn \"0 0 50\"; \
	              setWidgetRGBColor $top.$key\MB $vn \$$vn"
    $top.$key\MB.m add command -background #84dfff -activebackground #84dfff \
	    -command "set $vn \"132 223 255\"; \
	              setWidgetRGBColor $top.$key\MB $vn \$$vn"
    $top.$key\MB.m add command -background #008000 -activebackground #008000 \
	    -command "set $vn \"0 128 0\"; \
	              setWidgetRGBColor $top.$key\MB $vn \$$vn"
    $top.$key\MB.m add command -background #f0f0a0 -activebackground #f0f0a0 \
	    -command "set $vn \"240 240 160\"; \
	              setWidgetRGBColor $top.$key\MB $vn \$$vn"
    $top.$key\MB.m add command -background #ffffff -activebackground #ffffff \
	    -command "set $vn \"255 255 255\"; \
	              setWidgetRGBColor $top.$key\MB $vn \$$vn"
    $top.$key\MB.m add command -background #808080 -activebackground #808080 \
	    -command "set $vn \"128 128 128\"; \
	              setWidgetRGBColor $top.$key\MB $vn \$$vn"
    $top.$key\MB.m add command -background #000000 -activebackground #000000 \
	    -command "set $vn \"0 0 0\"; \
	              setWidgetRGBColor $top.$key\MB $vn \$$vn"
} else {
    $top.$key\MB.m add command -background #000000 -activebackground #000000 \
	    -command "set $vn \"0 0 0\"; \
	              setWidgetRGBColor $top.$key\MB $vn \$$vn"
    $top.$key\MB.m add command -background #ffffff -activebackground #ffffff \
	    -command "set $vn \"255 255 255\"; \
	              setWidgetRGBColor $top.$key\MB $vn \$$vn"
    $top.$key\MB.m add command -background #ff0000 -activebackground #ff0000 \
	    -command "set $vn \"255 0 0\"; \
	              setWidgetRGBColor $top.$key\MB $vn \$$vn"
    $top.$key\MB.m add command -background #00ff00 -activebackground #00ff00 \
	    -command "set $vn \"0 255 0\"; \
	              setWidgetRGBColor $top.$key\MB $vn \$$vn"
    $top.$key\MB.m add command -background #0000ff -activebackground #0000ff \
	    -command "set $vn \"0 0 255\"; \
	              setWidgetRGBColor $top.$key\MB $vn \$$vn"
    $top.$key\MB.m add command -background #ffff00 -activebackground #ffff00 \
	    -command "set $vn \"255 255 0\"; \
	              setWidgetRGBColor $top.$key\MB $vn \$$vn"
    $top.$key\MB.m add command -background #00ffff -activebackground #00ffff \
	    -command "set $vn \"0 255 255\"; \
	              setWidgetRGBColor $top.$key\MB $vn \$$vn"
    $top.$key\MB.m add command -background #ff00ff -activebackground #ff00ff \
	    -command "set $vn \"255 0 255\"; \
	              setWidgetRGBColor $top.$key\MB $vn \$$vn"
}
    $top.$key\MB.m add separator
    $top.$key\MB.m add command -label "Color Tool..." -command $user_color_cmd
    hoc_register_menu_data "Color" "Color Tool..." "Color Tool"\
	    { { summary "The color tool allows the user to specify
a color using either RGB or HSV. The resulting
color is RGB." } }

    # initialize color
    catch {[list uplevel #0 [list set $vn $icolor]]}
    setWidgetRGBColor $top.$key\MB $vn $icolor

    grid $top.$key\E $top.$key\MB -sticky "nsew" -in $top.$key\F
    grid columnconfigure $top.$key\F 0 -weight 1
    grid rowconfigure $top.$key\F 0 -weight 1

    bind $top.$key\E <Return> "setWidgetColor $top.$key\MB $vn \$$vn"

    return $top.$key\F
}

proc color_entry_destroy { top key } {
    grid forget $top.$key\F
    destroy $top.$key\F $top.$key\E $top.$key\MB
}

proc color_entry_update { top key vn icolor } {
    if [winfo exists $top.$key\MB] {
	setWidgetColor $top.$key\MB $vn $icolor
    }
}

proc color_entry_chooser { id top key title vn vin } {
    set child color

    cadColorWidget dialog $top $child\
	    -title $title\
	    -initialcolor [$top.$key\MB cget -background]\
	    -ok "color_entry_ok $id $top $top.$child $key $vn $vin"\
	    -cancel "cadColorWidget_destroy $top.$child"
}

proc color_entry_ok { id top w key vn vin } {
    upvar #0 $w data $vn varname

    $top.$key\MB configure -bg $data(finalColor)
    $top.$key\MB configure -activebackground $data(finalColor)

    if {$vin == ""} {
	set varname "$data(red) $data(green) $data(blue)"
    } else {
	set varname($vin) "$data(red) $data(green) $data(blue)"
    }

    destroy $w
    unset data
}

## -- setWidgetRGBColor
#
# Set the widget color given an rgb string.
#
proc setWidgetRGBColor { w vn rgb } {

    if ![winfo exists $w] {
	return -code error "setWidgetRGBColor: bad Tk window name --> $w"
    }

    if {$rgb != ""} {
	set result [regexp "^(\[0-9\]+)\[ \]+(\[0-9\]+)\[ \]+(\[0-9\]+)$" \
		$rgb cmatch red green blue]
	if {!$result} {
	    # reset varname to properly reflect the current color of the widget
	    set varname [$w cget -bg]
	    return -code error "Improper color specification - $rgb"
	}
    } else {
	return
    }

    $w configure -bg [format "#%02x%02x%02x" $red $green $blue]
    $w configure -activebackground [format "#%02x%02x%02x" $red $green $blue]
}

## -- setWidgetColor
#
# Set the widget color given a color string.
#
proc setWidgetColor { w vn color } {
    set rgb [getRGBorReset $w $vn $color]
    setWidgetRGBColor $w $vn $rgb
}


## -- getRGBorReset
#
# Get the RGB value corresponding to the given color. Failing that
# reset the variable vn to the value provided by the widget w
#
proc getRGBorReset { w vn color } {
    upvar #0 $vn varname

    if ![winfo exists $w] {
	return -code error "getRGBorReset: bad Tk window name --> $w"
    }

    # convert to RGB
    set result [catch {getRGB $w $color} rgb]
    if {$result} {
	# reset varname to properly reflect the current color of the widget
	set varname [$w cget -bg]
	return -code error $rgb
    }

    return $rgb
}

## -- getRGB
#
# Get the RGB value corresponding to the given color.
#
proc getRGB { w color } {
    # convert to RGB
    set rgb [cadColorWidget_getRGB $w $color]

    # Check to make sure the color is valid
    if {[llength $rgb] == 3} {
	return $rgb
    }

    # not a color recognized by cadColorWidget_getRGB
    set result [regexp "^\[ \]*(\[0-9\]+)\[ \]+(\[0-9\]+)\[ \]+(\[0-9\]+)\[ \]*$" \
	    $color cmatch red green blue]
    if {!$result ||
        $red < 0 || $red > 255 ||
        $green < 0 || $green > 255 ||
        $blue < 0 || $blue > 255 } {
	return -code error "Improper color specification - $color"
    }

    return $color
}
@


1.11
log
@Fixed incorrect "catch" construction
@
text
@@


1.10
log
@*- add parameter to color_entry_build to indicate
   whether or not to use background colors for rt
@
text
@d117 1
a117 1
    catch [list uplevel #0 [list set $vn $icolor]]
@


1.10.4.1
log
@sync branch with HEAD
@
text
@d117 1
a117 1
    catch {[list uplevel #0 [list set $vn $icolor]]}
@


1.10.6.1
log
@sync to HEAD...
@
text
@d117 1
a117 1
    catch {[list uplevel #0 [list set $vn $icolor]]}
@


1.10.8.1
log
@updated for merging
@
text
@d117 1
a117 1
    catch {[list uplevel #0 [list set $vn $icolor]]}
@


1.9
log
@*- replaced color names with colors in
   the color_entry widget's menu
@
text
@d27 1
a27 1
proc color_entry_build { top key vn user_color_cmd width icolor } {
d61 1
d83 26
@


1.8
log
@Use cget instead of configure to get
the current option value
@
text
@d60 12
a71 2
    $top.$key\MB.m add command -label black\
	    -command "set $vn \"0 0 0\"; \
d73 1
a73 3
    hoc_register_menu_data "Color" black "Color - Black"\
	    { { summary "Black is specified by \"0 0 0\"." } }
    $top.$key\MB.m add command -label white\
d76 5
a80 29
    hoc_register_menu_data "Color" white "Color - White"\
	    { { summary "White is specified by \"255 255 255\"." } }
    $top.$key\MB.m add command -label red\
	    -command "set $vn \"255 0 0\"; \
	              setWidgetRGBColor $top.$key\MB $vn \$$vn"
    hoc_register_menu_data "Color" red "Color - Red"\
	    { { summary "Red is specified by \"255 0 0\"." } }
    $top.$key\MB.m add command -label green\
	    -command "set $vn \"0 255 0\"; \
	              setWidgetRGBColor $top.$key\MB $vn \$$vn"
    hoc_register_menu_data "Color" green "Color - Green"\
	    { { summary "Green is specified by \"0 255 0\"." } }
    $top.$key\MB.m add command -label blue\
	    -command "set $vn \"0 0 255\"; \
	              setWidgetRGBColor $top.$key\MB $vn \$$vn"
    hoc_register_menu_data "Color" blue "Color - Blue"\
	    { { summary "Blue is specified by \"0 0 255\"." } }
    $top.$key\MB.m add command -label yellow\
	    -command "set $vn \"255 255 0\"; \
	              setWidgetRGBColor $top.$key\MB $vn \$$vn"
    hoc_register_menu_data "Color" yellow "Color - Yellow"\
	    { { summary "Yellow is specified by \"255 255 0\"." } }
    $top.$key\MB.m add command -label cyan\
	    -command "set $vn \"0 255 255\"; \
	              setWidgetRGBColor $top.$key\MB $vn \$$vn"
    hoc_register_menu_data "Color" cyan "Color - Cyan"\
	    { { summary "Cyan is specified by \"0 255 255\"." } }
    $top.$key\MB.m add command -label magenta\
	    -command "set $vn \"255 0 255\"; \
a81 2
    hoc_register_menu_data "Color" magenta "Color - Magenta"\
	    { { summary "Magenta is specified by \"255 0 255\"." } }
d127 1
d162 1
@


1.7
log
@*- mods convert non-rgb entries to rgb before feeding
   to MGED
@
text
@d171 1
a171 1
	    set varname [lindex [$w configure -bg] 4]
a185 16
#    upvar #0 $vn varname

#    if ![winfo exists $w] {
#	return -code error "setWidgetColor: bad Tk window name --> $w"
#    }

    # convert to RGB
#    set result [catch {getRGB $w $color} rgb]
#    if {$result} {
	# reset varname to properly reflect the current color of the widget
#	set varname [lindex [$w configure -bg] 4]
#	return -code error $rgb
#    } else {
#	setWidgetRGBColor $w $vn $rgb
#    }

d207 1
a207 1
	set varname [lindex [$w configure -bg] 4]
@


1.7.2.1
log
@Use cget instead of configure for getting
current values of an option.
@
text
@d171 1
a171 1
	    set varname [$w cget -bg]
d186 16
d223 1
a223 1
	set varname [$w cget -bg]
@


1.6
log
@*- mods set_WidgetRGBColor's signature to include a variable name
*- add setWidgetColor proc that calls set_WidgetRGBColor after
   converting the passed in color to rgb
@
text
@d126 3
a128 1
    setWidgetRGBColor $top.$key\MB $vn $icolor
d156 1
a156 1
# setWidgetRGBColor --
a160 1
    upvar #0 $vn varname
d163 1
a163 1
	return "setWidgetRGBColor: bad Tk window name --> $w"
d172 1
a172 5
	    cad_dialog $w.colorDialog [winfo screen $w]\
		    "Improper color specification!"\
		    "Improper color specification: $rgb"\
		    "" 0 OK
	    return
d181 4
d186 29
d216 1
a216 1
	return "setWidgetColor: bad Tk window name --> $w"
d220 16
d240 11
a250 4
	setWidgetRGBColor $w $vn $rgb
    } else {
	# assume already RGB, if not setWidgetRGBColor will catch it 
	setWidgetRGBColor $w $vn $color
d252 3
a254 1
}@


1.5
log
@*- typo
@
text
@d27 1
a27 1
proc color_entry_build { top key var_name user_color_cmd width icolor } {
d29 1
a29 1
    entry $top.$key\E -relief flat -width $width -textvar $var_name
d32 1
a32 1
is specified using three integers (i.e. r g b)
d44 6
d61 2
a62 1
	    -command "set $var_name \"0 0 0\"; set_WidgetRGBColor $top.$key\MB \$$var_name"
d66 2
a67 1
	    -command "set $var_name \"255 255 255\"; set_WidgetRGBColor $top.$key\MB \$$var_name"
d71 2
a72 1
	    -command "set $var_name \"255 0 0\"; set_WidgetRGBColor $top.$key\MB \$$var_name"
d76 2
a77 1
	    -command "set $var_name \"0 255 0\"; set_WidgetRGBColor $top.$key\MB \$$var_name"
d81 2
a82 1
	    -command "set $var_name \"0 0 255\"; set_WidgetRGBColor $top.$key\MB \$$var_name"
d86 2
a87 1
	    -command "set $var_name \"255 255 0\"; set_WidgetRGBColor $top.$key\MB \$$var_name"
d91 2
a92 1
	    -command "set $var_name \"0 255 255\"; set_WidgetRGBColor $top.$key\MB \$$var_name"
d96 2
a97 1
	    -command "set $var_name \"255 0 255\"; set_WidgetRGBColor $top.$key\MB \$$var_name"
d108 2
a109 2
    catch [list uplevel #0 [list set $var_name $icolor]]
    set_WidgetRGBColor $top.$key\MB $icolor
d115 1
a115 1
    bind $top.$key\E <Return> "set_WidgetRGBColor $top.$key\MB \$$var_name"
d125 2
a126 2
proc color_entry_update { top key icolor } {
    set_WidgetRGBColor $top.$key\MB $icolor
d154 1
a154 1
# set_WidgetRGBColor --
d158 3
a160 1
proc set_WidgetRGBColor { w rgb_str } {
d162 1
a162 1
	return "set_WidgetRGBColor: bad Tk window name --> $w"
d165 1
a165 1
    if {$rgb_str != ""} {
d167 1
a167 1
		$rgb_str cmatch red green blue]
d169 2
d173 1
a173 1
		    "Improper color specification: $rgb_str"\
d183 17
@


1.4
log
@*- add help messages
@
text
@d51 1
a51 1
	    { { summary "Pops up a menu of colors. Also included
@


1.3
log
@*- add more routines
	- color_entry_build
	- color_entry_destroy
	- color_entry_update
	- color_entry_chooser
	- color_entry_ok
@
text
@d30 18
d50 4
a53 1
    menu $top.$key\MB.m -tearoff 0
d56 2
d60 2
d64 2
d68 2
d72 2
d76 2
d80 2
d84 2
d88 4
@


1.2
log
@*- remove chooseColor()
*- use cad_dialog instead of mged_dialog
@
text
@d1 9
d11 4
a14 1
#			C O L O R . T C L
d16 1
d19 7
a25 1
#	Author - Robert G. Parker
d27 71
a97 1
###############################################################################
@


1.1
log
@Initial revision
@
text
@d8 1
d10 1
d12 1
a12 1
#		C H O O S E C O L O R
a13 24
# Returns a list containing the chosen color expressed two ways:
#	1) #XXXXXX, where the X's are hex(i.e. 2 for each of RGB)
#	2) r g b
#
proc chooseColor { parent } {
    set hex_color [tk_chooseColor -parent $parent] 
    if {$hex_color == ""} {
	return {}
    }

    set result [regexp "^#(\[0-9AaBbCcDdEeFf\]\[0-9AaBbCcDdEeFf\])(\[0-9AaBbCcDdEeFf\]\[0-9AaBbCcDdEeFf\])(\[0-9AaBbCcDdEeFf\]\[0-9AaBbCcDdEeFf\])$" $hex_color cmatch hred hgreen hblue]

    if {$result} {
	set rgb [format "%d %d %d" 0X$hred 0X$hgreen 0X$hblue]
	return [list $hex_color $rgb]
    } else {
	mged_dialog $w.colorDialog [winfo screen $parent]\
		"chooseColor: tk_chooseColor returned bad value"\
		"chooseColor: tk_chooseColor returned bad value - $hex_color"\
		"" 0 OK
	return {}
    }
}

d23 1
a23 1
	    mged_dialog $w.colorDialog [winfo screen $w]\
@
