head	1.7;
access;
symbols
	ansi-20040405-merged:1.5.4.1
	postmerge-20040405-ansi:1.6
	premerge-20040404-ansi:1.6
	postmerge-autoconf:1.6
	autoconf-freeze:1.6
	premerge-autoconf:1.6
	postmerge-20040315-windows:1.6
	premerge-20040315-windows:1.6
	windows-20040315-freeze:1.5.6.1
	autoconf-20031203:1.6
	autoconf-20031202:1.6
	autoconf-branch:1.6.0.6
	phong-branch:1.6.0.4
	photonmap-branch:1.6.0.2
	rel-6-1-DP:1.5
	windows-branch:1.5.0.6
	rel-6-0-2:1.5
	ansi-branch:1.5.0.4
	rel-6-0-1-branch:1.5.0.2
	hartley-6-0-post:1.5
	hartley-6-0-pre:1.5
	rel-6-0-1:1.5
	rel-6-0:1.5;
locks; strict;
comment	@# @;


1.7
date	2004.05.21.16.41.21;	author morrison;	state dead;
branches;
next	1.6;

1.6
date	2003.04.09.20.13.21;	author jra;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.15.18.48.17;	author tranese;	state Exp;
branches
	1.5.4.1
	1.5.6.1;
next	1.4;

1.4
date	2002.03.13.23.15.26;	author tranese;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.29.19.02.51;	author tranese;	state Exp;
branches;
next	1.2;

1.2
date	2001.10.22.19.35.22;	author tranese;	state Exp;
branches;
next	1.1;

1.1
date	2001.10.18.20.25.10;	author tranese;	state Exp;
branches;
next	;

1.5.4.1
date	2004.03.17.21.23.09;	author morrison;	state Exp;
branches;
next	;

1.5.6.1
date	2004.03.11.23.48.57;	author morrison;	state Exp;
branches;
next	;


desc
@@


1.7
log
@moved to src/tclscripts/
@
text
@#			      A C C E L . T C L
#
# Author -
#      Bob Hartley, SEAP
#
# Date-
#      15 August 2000
#
# Description-
#      Various accelerators for BRL-CAD.
#
# Modifications-       
#      TraNese Christy
#        *- Changed proc names
#        *- Added ability to accept variable number of args
#        *- Added usage message
#        *- Made the code more readable and efficient
#



#
#                               R C C - C A P
#
#     Generate a cap on a specified RCC 
#     Default end is "b"; Default height creates spherical cap
#     Assume (A=B=C=D) || (A=B && C=D)
#
proc rcc-cap {args} {
    global mged_display
    set usage "Usage: rcc-cap rccname newname \[height\] \[b|t\] \n \
	       \t(create a cap (ell) at an end of an rcc)"
    set argc [llength $args]
    if {$argc < 2 || $argc > 4} {
	error "$usage"
    }
    set rccname [lindex $args 0]
    set newname [lindex $args 1]
    if {$argc == 2} {
	foreach {ax ay az} [db get $rccname A] {}
	set amag [expr sqrt($ax*$ax + $ay*$ay + $az*$az)]
	set height $amag
	set end b
    } elseif {$argc == 3} {
	if { [regexp {^[0-9]+.*[0-9]*$} [lindex $args 2]]} {
	    set height [expr [bu_units_conversion $mged_display(units)] *[lindex $args 2]]
            set end b
	} else {
	    foreach {ax ay az} [db get $rccname A] {}
	    set amag [expr sqrt($ax*$ax + $ay*$ay + $az*$az)]
	    set height $amag
	    set end [lindex $args 2]
	}
    } else {
       set height [expr [bu_units_conversion $mged_display(units)] *[lindex $args 2]]
       set end [lindex $args 3]
    }
  #Choices for $end are either "b" (base) or "t" (top)
    if {$end != "b" && $end != "t"} {
	error "bad end '$end' : must be b or t"
    }
  #Set Variables
    set hv [db get $rccname H]
    set uhv [vunitize $hv]
    set ellheight [vscale $uhv $height]
    set vertex [db get $rccname V]
    if {$end == "t"} {
	set vertex [vadd2 {$vertex} $hv]
        set vec1 C
        set vec2 D  
    } else {
	set ellheight [vreverse $ellheight]
        set vec1 A
        set vec2 B
    }
    set Alist [db get $rccname $vec1]
    set Blist [db get $rccname $vec2]
  #Create ELL 
    db put $newname ell V "$vertex" A "$Alist" B "$Blist" C "$ellheight"        
    e $newname
    return $newname
}

#
#                               R C C - T G C
#
#   Generate a TGC with a specified apex (ptx pty ptz) at a specified end of
#   a specified RCC; Default end is "b"
#
#
proc rcc-tgc {args} {
    global mged_display
    set usage "Usage: rcc-tgc rccname newname x y z \[b|t\] \n   \
               \t(create a tgc with the specified apex at an end of an rcc)"
    set argc [llength $args]
    if {$argc < 5 || $argc > 6} {
	error "$usage"
    }
    set rccname [lindex $args 0]
    set newname [lindex $args 1]
    set ptx [lindex $args 2]
    set pty [lindex $args 3]
    set ptz [lindex $args 4]
    if {$argc == 5} {
	set end b
    } else {
	set end [lindex $args 5]
    }
  #Choices for $end are either "b" (base) or "t" (top)  
    if {$end != "b" && $end != "t"} {
	error "bad end '$end' : must be b or t" 
    }
  #Set Variables
    if {$end == "t"} {
	set vec1 C
	set vec2 D
	set vertex [vadd2 [db get $rccname V] [db get $rccname H]]
    } else {
	set vec1 A
        set vec2 B
        set vertex [db get $rccname V]
    }
    set vector1 [db get $rccname $vec1]
    set vector2 [db get $rccname $vec2]
    set scalar .000001
#    set apex [list $ptx $pty $ptz]
    set apex ""
    foreach pt {$ptx $pty $ptz} {
	set result [expr $pt*[bu_units_conversion $mged_display(units)]]
        lappend apex $result
    }
    set height [vsub2 $apex $vertex]
  #Create TGC
  #in order to create properly, convert to display units
    foreach param {vertex height vector1 vector2} val "{$vertex} {$height} {$vector1} {$vector2}" {
	set result ""
	foreach coord $val {
	    set temp [expr $coord/[bu_units_conversion $mged_display(units)]]
            lappend result $temp
	}
	set $param $result
    }
    set scalar [expr $scalar/[bu_units_conversion $mged_display(units)]]
    eval in $newname tgc $vertex $height $vector1 $vector2 $scalar $scalar
    return $newname
}

#
#                               T O R - R C C
#
#  Generate an RCC from a specified TOR
#
#
proc tor-rcc {args} {
    global mged_display
    set usage "Usage: tor-rcc torname newname \n \
	       \t(create an rcc from a tor)"
    set argc [llength $args]
    if {$argc < 2 || $argc > 2} {
	error "$usage"
    }
    set torname [lindex $args 0]
    set newname [lindex $args 1]
  #Get TOR coordinates
    foreach {tvx tvy tvz} [db get $torname V] {}   
    foreach {thx thy thz} [db get $torname H] {}   
    set radius1 [db get $torname r_a]
    set radius2 [db get $torname r_h]
  #Set RCC coordinates
    foreach coord {rvx rvy rvz} vval {$tvx $tvy $tvz} hval {$thx $thy $thz} {
	set $coord [expr $vval + $hval * $radius2]
    }
    set scale [expr -2*$radius2]
    foreach coord {rhx rhy rhz} hval {$thx $thy $thz} {
	set $coord [expr $scale * $hval]
    }
  #Create RCC
  #in order to create properly, have to use display units
    foreach param {rvx rvy rvz rhx rhy rhz radius1} val "$rvx $rvy $rvz $rhx $rhy $rhz $radius1" {
	set $param [expr $val/[bu_units_conversion $mged_display(units)]]
    }
    in $newname rcc $rvx $rvy $rvz $rhx $rhy $rhz $radius1
    return $newname
}

#
#                               R C C - T O R
#
#  Generate a TOR from a specified RCC
#
#   
proc rcc-tor {args} {
    global mged_display
    set usage "Usage: rcc-tor rccname newname \n \
	       \t(create a tor from an rcc)"
    set argc [llength $args]
    if {$argc < 2 || $argc > 2} {
	error "$usage"
    }
    set rccname [lindex $args 0]
    set newname [lindex $args 1]
  #Get RCC coordinates    
    foreach {rvx rvy rvz} [db get $rccname V] {}
    foreach {rax ray raz} [db get $rccname A] {}
    foreach {rhx rhy rhz} [db get $rccname H] {}
  #Set TOR coordinates
    set radius1 [expr sqrt($rax*$rax + $ray*$ray + $raz*$raz)]
    set radius2 [expr sqrt($rhx*$rhx + $rhy*$rhy + $rhz*$rhz)*.5] 
  #TOR not made if RCC is at least twice as high as it is wide
    if {$radius2 >= $radius1} {
	error "RCC is at least twice as high as it is wide -- \n \
		\t radius2 > radius1 : TOR not made!"
    }
    foreach coord {tvx tvy tvz} vval {$rvx $rvy $rvz} hval {$rhx $rhy $rhz} {
	set $coord [expr $vval + $hval*.5]
    }
  #Create TOR
  #in order to create properly, have to use display units
    foreach param {tvx tvy tvz rhx rhy rhz radius1 radius2} val "$tvx $tvy $tvz $rhx $rhy $rhz $radius1 $radius2" {
	set $param [expr $val/[bu_units_conversion $mged_display(units)]]
    }
    in $newname tor $tvx $tvy $tvz $rhx $rhy $rhz $radius1 $radius2
    return $newname
}

#
#                             R C C - B L E N D
#
#  Generate a flange at a specified base of a specified RCC
#  The flange created is a region made up of a TOR and an RCC
#  thickness is the thickness of the TOR; Default end is "b"
#
#
proc rcc-blend {args} {
    global mged_display
    set usage "Usage: rcc-blend rccname newname thickness \[b|t\] \n \
	       \t(create a blend at an end of an rcc)"
    set argc [llength $args]
    if {$argc < 3 || $argc > 4} {
	error "$usage"
    }
    set rccname1 [lindex $args 0]
    set newname [lindex $args 1]
    set thickness [expr [bu_units_conversion $mged_display(units)] * [lindex $args 2]]
    if {$argc == 3} {
	set end b
    } else {
	set end [lindex $args 3]
    }
  #Choices for $end are either "b" (base) or "t" (top)
    if {$end != "b" && $end != "t"} {
	error "bad end '$end': must be b or t"
    }
  #Get RCC coordinates
    foreach {rvx rvy rvz} [db get $rccname1 V] {}
    foreach {rhx rhy rhz} [db get $rccname1 H] {}
    foreach {rax ray raz} [db get $rccname1 A] {}    
  #Set Variables  
    set amag [expr $thickness + (sqrt($rax*$rax + $ray*$ray + $raz*$raz))]
    set hmag [expr sqrt($rhx*$rhx + $rhy*$rhy + $rhz*$rhz)]
    set num [expr $hmag-$thickness] 
    if {$end == "t"} {
	foreach coord {vx vy vz} vval {$rvx $rvy $rvz} hval {$rhx $rhy $rhz} {
	    set t$coord [expr $vval + $hval * $num/$hmag]
            set r$coord [expr $vval + $num/$hmag * $hval]
        }
    } else {
	foreach coord {tvx tvy tvz} vval {$rvx $rvy $rvz} hval {$rhx $rhy $rhz} {
	    set $coord [expr $vval + $hval * $thickness/$hmag]
        }
    }
  #Create TOR
    set torname [make_name $newname]
    set hscale [expr $thickness/$hmag]
  #In order to make TOR properly, have to convert parameters to display units  
    foreach param {tvx tvy tvz rhx rhy rhz amag thickness} val "$tvx $tvy $tvz $rhx $rhy $rhz $amag $thickness" {
	set $param [expr $val/[bu_units_conversion $mged_display(units)]]
    } 
    in $torname tor $tvx $tvy $tvz $rhx $rhy $rhz $amag $thickness
  #Create RCC2
    set rccname2 [make_name $newname]
  #In order to make TOR properly, have to convert parameters to display units
    foreach param {rvx rvy rvz } val "$rvx $rvy $rvz" {
	set $param [expr $val/[bu_units_conversion $mged_display(units)]]
    }
    in $rccname2 rcc $rvx $rvy $rvz [expr $hscale*$rhx] [expr $hscale*$rhy] [expr $hscale*$rhz] $amag
  #Create Flange
    r $newname u $rccname2 - $torname - $rccname1
    d $torname $rccname2
    e $newname
    return $newname
}

#
#                               R P P - C A P
#
#  Generate an ARB6 with a specified height at the specified face of
#  a specified RPP; Default orient is "0"
#
#
proc rpp-cap {args} {
#If orient = 0, the peaks of the ARB6 are drawn at the midpoint between the
# first and second points and the midpoint between the third and fourth points
# of the specified face
#If orient = 1, the peaks of the ARB6 are drawn at the midpoint between the 
# first and fourth points and the midpoint between the second and third points
# of the specified face
    global mged_display
    set usage "Usage: rpp-cap rppname newname face height \[0|1\] \n \
	       \t(create a cap (arb6) at a face of an rpp)"
    set argc [llength $args]
    if {$argc < 4 || $argc > 5} {
	error "$usage"
    }
    set rppname [lindex $args 0]
    set newname [lindex $args 1]
    set face [lindex $args 2]
    set height [expr [lindex $args 3]*[bu_units_conversion $mged_display(units)]]
    if {$argc == 4} {
	set orient 0
    } else {
	set orient [lindex $args 4]
    }   
  #Choices for orient are either "0" or "1"
    if {$orient != 0 && $orient != 1} {
	error "bad orient '$orient': must be 0 or 1"
    }
  #Set Constants
    foreach pt {a b c d} index {0 1 2 3} {
	set $pt [string index $face $index]
    }
    foreach vert {V1 V2 V3 V4} pt {$a $b $c $d} {
	set $vert [eval db get $rppname V$pt]
    }

  #Determine Normal
    set u1 [vunitize [vsub $V4 $V3]]
    set u2 [vunitize [vsub $V2 $V3]]
    set normal [vunitize [vcross $u1 $u2]]
    set hvector [vscale $normal $height]
  #Determine Midpoint
    if {$orient == 0} {
	set rise1 [vadd2 $V1 $V2]
	set rise2 [vadd2 $V3 $V4]
        set P1 $V1
        set P2 $V2
        set P3 $V3
        set P4 $V4
    } else {
	set rise2 [vadd2 $V1 $V4]
        set rise1 [vadd2 $V2 $V3]
        set P1 $V2
        set P2 $V3
        set P3 $V4
        set P4 $V1
    }

    foreach coord {r1x r1y r1z} index {0 1 2} {
	set $coord [expr [lindex $rise1 $index] * .5]
    }
    foreach coord {r2x r2y r2z} index {0 1 2} {
	set $coord [expr [lindex $rise2 $index] * .5]
    }
  #Choose the first point (1-8) not on the specified face
    set pt 1
    set index 0
    while {$index <= 3 && $pt <= 8} {
	if {$pt == [string index $face $index]} {
	    incr pt
            set index 0 
        } else {
            incr index 
        }
    }
  #Determine direction of hvector 
  #Form vector from a point on the specified face and a point not on the face
    set direct [vunitize [vsub $V1 [db get $rppname V$pt]]]
    set dp [vdot $normal $direct]
    if {$dp < 0} {
	set hvector [vreverse $hvector]
    }
  #Set ARB6 coordinates
    foreach coord {r1x r1y r1z} value {$r1x $r1y $r1z} index {0 1 2} {
      	set $coord [expr $value + [lindex $hvector $index]]
    }
    foreach coord {r2x r2y r2z} value {$r2x $r2y $r2z} index {0 1 2} {
	set $coord [expr $value + [lindex $hvector $index]]
    }
  #Create ARB6
  #in order to create properly, convert to display units
    foreach param {P1 P2 P3 P4} val "{$P1} {$P2} {$P3} {$P4}" {
	set result ""
	foreach coord $val {
	    set temp [expr $coord/[bu_units_conversion $mged_display(units)]]
            lappend result $temp
	}
	set $param $result
    }
    foreach coord {r1x r1y r1z r2x r2y r2z } val "$r1x $r1y $r1z $r2x $r2y $r2z" {
	set $coord [expr $val/[bu_units_conversion $mged_display(units)]]
    }

    eval in $newname arb6 $P1 $P2 $P3 $P4 $r1x $r1y $r1z $r2x $r2y $r2z
    return $newname
}

#
#                              R P P - A R C H
#
#  Generate a cylinder between the specified edges of an RPP
#  The edges are represented by the first and second and the third and fourth
#  points of the specified face.
#
#
proc rpp-arch {args} {
    global mged_display
    set usage "Usage: rpp-arch rppname newname face \n \
	       \t(create an arch at a face of an rpp)"
    set argc [llength $args]
    if {$argc < 3 || $argc > 3} {
	error "$usage"
    }
    set rppname [lindex $args 0]
    set newname [lindex $args 1]
    set face [lindex $args 2]
  #Set Constants
    foreach pt {a b c d} index {0 1 2 3} {
	set $pt [string index $face $index]	
    }
    foreach vert {V1 V2 V3 V4} pt {$a $b $c $d} {
	set $vert [eval db get $rppname V$pt]
    }
  #Set Variables
    set height  [vsub2 $V2 $V1]
    set vertex [vscale [vadd2 $V4 $V1] .5]
    set radius [vmagnitude [vsub2 $vertex $V4]]
  #Create RCC 
  #in order to create properly, have to use display units
    foreach param {vertex height radius} val "{$vertex} {$height} {$radius}" {
	set result ""
	foreach coord $val {
	    set temp [expr $coord/[bu_units_conversion $mged_display(units)]]
            lappend result $temp
	}
	set $param $result
    }
    eval in $newname rcc $vertex $height $radius
    return $newname
}

#
#                              S P H - P A R T 
#
#  Generates a PART that encompasses two specified SPHs
#
#
proc sph-part {args} {
    global mged_display
    set usage "Usage: sph-part sph1name sph2name newname \n \
	       \t(create a part from two sph's)"
    set argc [llength $args]
    if {$argc < 3 || $argc > 3} {
	error "$usage"
    }
    set sphname1 [lindex $args 0]
    set sphname2 [lindex $args 1]
    set newname [lindex $args 2]
  #Get SPH coordinates
    foreach {vx1 vy1 vz1} [db get $sphname1 V] {}
    foreach {vx2 vy2 vz2} [db get $sphname2 V] {}
    foreach {ax1 ay1 az1} [db get $sphname1 A] {}
    foreach {ax2 ay2 az2} [db get $sphname2 A] {}
  #Set Variables
    set radius1 [expr sqrt($ax1*$ax1 + $ay1*$ay1 + $az1*$az1)]
    set radius2 [expr sqrt($ax2*$ax2 + $ay2*$ay2 + $az2*$az2)] 
    set hx [expr $vx2-$vx1]
    set hy [expr $vy2-$vy1]
    set hz [expr $vz2-$vz1]    
  #in order to create properly, convert to display units
    foreach param {vx1 vy1 vz1 hx hy hz radius1 radius2} val "$vx1 $vy1 $vz1 $hx $hy $hz $radius1 $radius2" {
	set $param [expr $val/[bu_units_conversion $mged_display(units)]]
    }
  #Create PART
    in $newname part $vx1 $vy1 $vz1 $hx $hy $hz $radius1 $radius2
    return $newname
}

@


1.6
log
@Adjustments to account for the correction of rt_parsetab_tclget()
@
text
@@


1.5
log
@*- Modified accelerators to work in any units not just millimeters.
@
text
@d40 1
a40 1
	foreach {ax ay az} [lindex [db get $rccname A] 0] {}
d49 1
a49 1
	    foreach {ax ay az} [lindex [db get $rccname A] 0] {}
d63 4
a66 4
    set hv [eval db get $rccname H]
    set uhv [eval vunitize $hv]
    set ellheight [eval vscale {$uhv} $height]
    set vertex [lindex [db get $rccname V] 0]
d68 1
a68 1
	set vertex [eval vadd2 {$vertex} $hv]
d72 1
a72 1
	set ellheight [eval vreverse {$ellheight}]
d76 2
a77 2
    set Alist [lindex [db get $rccname $vec1] 0]
    set Blist [lindex [db get $rccname $vec2] 0]
d117 1
a117 1
	set vertex [vadd2 [lindex [db get $rccname V] 0] [lindex [db get $rccname H] 0]]
d121 1
a121 1
        set vertex [lindex [db get $rccname V] 0]
d123 2
a124 2
    set vector1 [lindex [db get $rccname $vec1] 0]
    set vector2 [lindex [db get $rccname $vec2] 0]
d132 1
a132 1
    set height [eval vsub2 {$apex} {$vertex}]
d165 4
a168 4
    foreach {tvx tvy tvz} [lindex [db get $torname V] 0] {}   
    foreach {thx thy thz} [lindex [db get $torname H] 0] {}   
    set radius1 [eval db get $torname r_a]
    set radius2 [eval db get $torname r_h]
d203 3
a205 3
    foreach {rvx rvy rvz} [lindex [db get $rccname V] 0] {}
    foreach {rax ray raz} [lindex [db get $rccname A] 0] {}
    foreach {rhx rhy rhz} [lindex [db get $rccname H] 0] {}
d255 3
a257 3
    foreach {rvx rvy rvz} [lindex [db get $rccname1 V] 0] {}
    foreach {rhx rhy rhz} [lindex [db get $rccname1 H] 0] {}
    foreach {rax ray raz} [lindex [db get $rccname1 A] 0] {}    
d273 1
a273 1
    set torname [eval make_name $newname]
d281 1
a281 1
    set rccname2 [eval make_name $newname]
d335 1
d337 4
a340 4
    set u1 [eval vunitize {[eval vsub $V2 $V4]}]
    set u2 [eval vunitize {[eval vsub $V1 $V3]}]
    set normal [eval vcross {$u1} {$u2}]
    set hvector [eval vscale {$normal} $height]
d343 6
a348 6
	set rise1 [eval vadd2 $V1 $V2]
	set rise2 [eval vadd2 $V3 $V4]
        set P1 [lindex $V1 0]
        set P2 [lindex $V2 0]
        set P3 [lindex $V3 0]
        set P4 [lindex $V4 0]
d350 6
a355 6
	set rise2 [eval vadd2 $V1 $V4]
        set rise1 [eval vadd2 $V2 $V3]
        set P1 [lindex $V2 0]
        set P2 [lindex $V3 0]
        set P3 [lindex $V4 0]
        set P4 [lindex $V1 0]
d357 1
d377 1
a377 1
    set direct [eval vunitize {[eval vsub $V1 [db get $rppname V$pt]]}]
d380 1
a380 1
	set hvector [eval vreverse {$hvector}]
d402 1
d434 3
a436 3
    set height  [eval vsub2 $V2 $V1]
    set vertex [eval vscale {[eval vadd2 $V4 $V1]} .5]
    set radius [eval vmagnitude {[eval vsub2 {$vertex} $V4]}]
d469 4
a472 4
    foreach {vx1 vy1 vz1} [lindex [db get $sphname1 V] 0] {}
    foreach {vx2 vy2 vz2} [lindex [db get $sphname2 V] 0] {}
    foreach {ax1 ay1 az1} [lindex [db get $sphname1 A] 0] {}
    foreach {ax2 ay2 az2} [lindex [db get $sphname2 A] 0] {}
@


1.5.4.1
log
@sync branch with HEAD
@
text
@d40 1
a40 1
	foreach {ax ay az} [db get $rccname A] {}
d49 1
a49 1
	    foreach {ax ay az} [db get $rccname A] {}
d63 4
a66 4
    set hv [db get $rccname H]
    set uhv [vunitize $hv]
    set ellheight [vscale $uhv $height]
    set vertex [db get $rccname V]
d68 1
a68 1
	set vertex [vadd2 {$vertex} $hv]
d72 1
a72 1
	set ellheight [vreverse $ellheight]
d76 2
a77 2
    set Alist [db get $rccname $vec1]
    set Blist [db get $rccname $vec2]
d117 1
a117 1
	set vertex [vadd2 [db get $rccname V] [db get $rccname H]]
d121 1
a121 1
        set vertex [db get $rccname V]
d123 2
a124 2
    set vector1 [db get $rccname $vec1]
    set vector2 [db get $rccname $vec2]
d132 1
a132 1
    set height [vsub2 $apex $vertex]
d165 4
a168 4
    foreach {tvx tvy tvz} [db get $torname V] {}   
    foreach {thx thy thz} [db get $torname H] {}   
    set radius1 [db get $torname r_a]
    set radius2 [db get $torname r_h]
d203 3
a205 3
    foreach {rvx rvy rvz} [db get $rccname V] {}
    foreach {rax ray raz} [db get $rccname A] {}
    foreach {rhx rhy rhz} [db get $rccname H] {}
d255 3
a257 3
    foreach {rvx rvy rvz} [db get $rccname1 V] {}
    foreach {rhx rhy rhz} [db get $rccname1 H] {}
    foreach {rax ray raz} [db get $rccname1 A] {}    
d273 1
a273 1
    set torname [make_name $newname]
d281 1
a281 1
    set rccname2 [make_name $newname]
a334 1

d336 4
a339 4
    set u1 [vunitize [vsub $V4 $V3]]
    set u2 [vunitize [vsub $V2 $V3]]
    set normal [vunitize [vcross $u1 $u2]]
    set hvector [vscale $normal $height]
d342 6
a347 6
	set rise1 [vadd2 $V1 $V2]
	set rise2 [vadd2 $V3 $V4]
        set P1 $V1
        set P2 $V2
        set P3 $V3
        set P4 $V4
d349 6
a354 6
	set rise2 [vadd2 $V1 $V4]
        set rise1 [vadd2 $V2 $V3]
        set P1 $V2
        set P2 $V3
        set P3 $V4
        set P4 $V1
a355 1

d375 1
a375 1
    set direct [vunitize [vsub $V1 [db get $rppname V$pt]]]
d378 1
a378 1
	set hvector [vreverse $hvector]
a399 1

d431 3
a433 3
    set height  [vsub2 $V2 $V1]
    set vertex [vscale [vadd2 $V4 $V1] .5]
    set radius [vmagnitude [vsub2 $vertex $V4]]
d466 4
a469 4
    foreach {vx1 vy1 vz1} [db get $sphname1 V] {}
    foreach {vx2 vy2 vz2} [db get $sphname2 V] {}
    foreach {ax1 ay1 az1} [db get $sphname1 A] {}
    foreach {ax2 ay2 az2} [db get $sphname2 A] {}
@


1.5.6.1
log
@sync to HEAD...
@
text
@d40 1
a40 1
	foreach {ax ay az} [db get $rccname A] {}
d49 1
a49 1
	    foreach {ax ay az} [db get $rccname A] {}
d63 4
a66 4
    set hv [db get $rccname H]
    set uhv [vunitize $hv]
    set ellheight [vscale $uhv $height]
    set vertex [db get $rccname V]
d68 1
a68 1
	set vertex [vadd2 {$vertex} $hv]
d72 1
a72 1
	set ellheight [vreverse $ellheight]
d76 2
a77 2
    set Alist [db get $rccname $vec1]
    set Blist [db get $rccname $vec2]
d117 1
a117 1
	set vertex [vadd2 [db get $rccname V] [db get $rccname H]]
d121 1
a121 1
        set vertex [db get $rccname V]
d123 2
a124 2
    set vector1 [db get $rccname $vec1]
    set vector2 [db get $rccname $vec2]
d132 1
a132 1
    set height [vsub2 $apex $vertex]
d165 4
a168 4
    foreach {tvx tvy tvz} [db get $torname V] {}   
    foreach {thx thy thz} [db get $torname H] {}   
    set radius1 [db get $torname r_a]
    set radius2 [db get $torname r_h]
d203 3
a205 3
    foreach {rvx rvy rvz} [db get $rccname V] {}
    foreach {rax ray raz} [db get $rccname A] {}
    foreach {rhx rhy rhz} [db get $rccname H] {}
d255 3
a257 3
    foreach {rvx rvy rvz} [db get $rccname1 V] {}
    foreach {rhx rhy rhz} [db get $rccname1 H] {}
    foreach {rax ray raz} [db get $rccname1 A] {}    
d273 1
a273 1
    set torname [make_name $newname]
d281 1
a281 1
    set rccname2 [make_name $newname]
a334 1

d336 4
a339 4
    set u1 [vunitize [vsub $V4 $V3]]
    set u2 [vunitize [vsub $V2 $V3]]
    set normal [vunitize [vcross $u1 $u2]]
    set hvector [vscale $normal $height]
d342 6
a347 6
	set rise1 [vadd2 $V1 $V2]
	set rise2 [vadd2 $V3 $V4]
        set P1 $V1
        set P2 $V2
        set P3 $V3
        set P4 $V4
d349 6
a354 6
	set rise2 [vadd2 $V1 $V4]
        set rise1 [vadd2 $V2 $V3]
        set P1 $V2
        set P2 $V3
        set P3 $V4
        set P4 $V1
a355 1

d375 1
a375 1
    set direct [vunitize [vsub $V1 [db get $rppname V$pt]]]
d378 1
a378 1
	set hvector [vreverse $hvector]
a399 1

d431 3
a433 3
    set height  [vsub2 $V2 $V1]
    set vertex [vscale [vadd2 $V4 $V1] .5]
    set radius [vmagnitude [vsub2 $vertex $V4]]
d466 4
a469 4
    foreach {vx1 vy1 vz1} [db get $sphname1 V] {}
    foreach {vx2 vy2 vz2} [db get $sphname2 V] {}
    foreach {ax1 ay1 az1} [db get $sphname1 A] {}
    foreach {ax2 ay2 az2} [db get $sphname2 A] {}
@


1.4
log
@*- Performed option name substitution -- changed 'v' (vertex) to 'b' (base) and 'h' (height) to 't' (top). (rcc-blend, rcc-cap, rcc-tgc)
*- Changed names in usage statements. (sph-part)
@
text
@d21 1
d30 1
d32 1
a32 1
	       \t(create a cap at an end of an rcc)"
d46 1
a46 1
	    set height [lindex $args 2]
d55 1
a55 1
       set height [lindex $args 2]
d92 1
d126 6
a131 1
    set apex [list $ptx $pty $ptz]
d134 10
d155 1
d178 4
d193 1
d218 4
d235 1
d244 1
a244 1
    set thickness [lindex $args 2]
d257 1
a257 1
    foreach {rax ray raz} [lindex [db get $rccname1 A] 0] {}        
d274 5
d282 4
a285 1
    set hscale [expr $thickness/$hmag]
a301 1

d308 1
d318 1
a318 1
    set height [lindex $args 3]
d388 12
d413 1
d435 9
d455 1
d475 5
a479 1
    set hz [expr $vz2-$vz1]
@


1.3
log
@*- Changed capitalization of primitives displayed in usage message
@
text
@d25 2
a26 2
#     Default end is "v"; Default height creates spherical cap
#
d29 1
a29 1
    set usage "Usage: rcc-cap rccname newname \[height\] \[v|h\] \n \
d41 1
a41 1
	set end v
d43 1
a43 1
	if { [regexp {^[0-9]+$} [lindex $args 2]]} {
d45 1
a45 1
            set end v
d56 3
a58 3
  #Choices for $end are either "v" (vertex) or "h" (height)
    if {$end != "v" && $end != "h"} {
	error "bad end '$end' : must be v or h"
d65 1
a65 1
    if {$end == "h"} {
d86 1
a86 1
#   a specified RCC; Default end is "v"
d90 1
a90 1
    set usage "Usage: rcc-tgc rccname newname x y z \[v|h\] \n   \
d102 1
a102 1
	set end v
d106 3
a108 3
  #Choices for $end are either "v" (vertex) or "h" (height)  
    if {$end != "v" && $end != "h"} {
	error "bad end '$end' : must be v or h" 
d111 1
a111 1
    if {$end == "h"} {
d203 1
a203 1
#  thickness is the thickness of the TOR; Default end is "v"
d207 2
a208 2
    set usage "Usage: rcc-blend rccname newname thickness \[v|h\] \n \
	       \t(create a flange at an end of an rcc)"
d217 1
a217 1
	set end v
d221 3
a223 3
  #Choices for $end are either "v" (vertex) or "h" (height)
    if {$end != "v" && $end != "h"} {
	error "bad end '$end': must be v or h"
d233 1
a233 1
    if {$end == "h"} {
d396 1
a396 1
    set usage "Usage: sph-part sph1 sph2 newname \n \
@


1.2
log
@*- Changed comment
@
text
@d30 1
a30 1
	       \t(create a cap at an end of an RCC)"
d91 1
a91 1
               \t(create a TGC with the specified apex at an end of an RCC)"
d138 1
a138 1
	       \t(create an RCC from a TOR)"
d171 1
a171 1
	       \t(create a TOR from an RCC)"
d208 1
a208 1
	       \t(create a flange at an end of an RCC)"
d273 1
a273 1
	       \t(create a cap (ARB6) at face of an RPP)"
d365 1
a365 1
	       \t(create an arch at a face of an RPP)"
d397 1
a397 1
	       \t(create a PART from two SPHs)"
@


1.1
log
@* Various accelerators to be used in MGED to automatically generate
  new primitives from existing ones.
@
text
@d3 2
a4 3
#	Authors-
#		Bob Hartley, SEAP
#               TraNese Christy
d6 12
a17 2
#	Date-
#		15 August 2000
a18 2
# 	Description-
#		Various accelerators for BRL-CAD.
@

