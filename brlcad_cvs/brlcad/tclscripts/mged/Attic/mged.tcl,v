head	1.58;
access;
symbols
	ansi-20040405-merged:1.54.2.1
	postmerge-20040405-ansi:1.57
	premerge-20040404-ansi:1.57
	postmerge-autoconf:1.57
	autoconf-freeze:1.55.6.3
	premerge-autoconf:1.57
	postmerge-20040315-windows:1.57
	premerge-20040315-windows:1.57
	windows-20040315-freeze:1.54.4.2
	autoconf-20031203:1.55
	autoconf-20031202:1.55
	autoconf-branch:1.55.0.6
	phong-branch:1.55.0.4
	photonmap-branch:1.55.0.2
	rel-6-1-DP:1.54
	windows-branch:1.54.0.4
	rel-6-0-2:1.51
	ansi-branch:1.54.0.2
	rel-6-0-1-branch:1.51.0.2
	hartley-6-0-post:1.53
	hartley-6-0-pre:1.52
	rel-6-0-1:1.51
	rel-6-0:1.51
	rel-5-4:1.45.2.5
	offsite-5-3-pre:1.50
	rel-5-3:1.45.2.5
	rel-5-2:1.45
	rel-5-1-branch:1.45.0.2
	rel-5-1:1.45
	rel-5-0:1.43
	rel-5-0-beta:1.37
	rel-4-5:1.21;
locks; strict;
comment	@# @;


1.58
date	2004.05.21.16.41.27;	author morrison;	state dead;
branches;
next	1.57;

1.57
date	2004.03.15.20.20.04;	author morrison;	state Exp;
branches;
next	1.56;

1.56
date	2004.02.02.17.39.44;	author morrison;	state Exp;
branches;
next	1.55;

1.55
date	2003.03.13.19.45.31;	author jra;	state Exp;
branches
	1.55.6.1;
next	1.54;

1.54
date	2002.08.20.17.08.47;	author jra;	state Exp;
branches
	1.54.2.1
	1.54.4.1;
next	1.53;

1.53
date	2002.08.15.20.55.59;	author hartley;	state Exp;
branches;
next	1.52;

1.52
date	2002.08.11.02.28.21;	author morrison;	state Exp;
branches;
next	1.51;

1.51
date	2001.04.03.22.33.03;	author bparker;	state Exp;
branches;
next	1.50;

1.50
date	2001.02.16.22.26.00;	author bparker;	state Exp;
branches;
next	1.49;

1.49
date	2000.12.22.00.35.15;	author bparker;	state Exp;
branches;
next	1.48;

1.48
date	2000.11.17.15.40.48;	author bparker;	state Exp;
branches;
next	1.47;

1.47
date	2000.11.02.17.43.26;	author bparker;	state Exp;
branches;
next	1.46;

1.46
date	2000.10.26.17.43.13;	author jra;	state Exp;
branches;
next	1.45;

1.45
date	99.10.14.16.14.51;	author bparker;	state Exp;
branches
	1.45.2.1;
next	1.44;

1.44
date	99.10.08.21.50.25;	author bparker;	state Exp;
branches;
next	1.43;

1.43
date	99.09.01.18.43.28;	author bparker;	state Exp;
branches;
next	1.42;

1.42
date	99.08.31.15.52.14;	author bparker;	state Exp;
branches;
next	1.41;

1.41
date	99.06.21.17.02.25;	author bparker;	state Exp;
branches;
next	1.40;

1.40
date	99.06.11.18.41.52;	author bparker;	state Exp;
branches;
next	1.39;

1.39
date	99.06.11.17.59.49;	author bparker;	state Exp;
branches;
next	1.38;

1.38
date	99.06.03.21.20.03;	author bparker;	state Exp;
branches;
next	1.37;

1.37
date	99.05.06.17.41.26;	author bparker;	state Exp;
branches;
next	1.36;

1.36
date	99.04.20.20.31.55;	author bparker;	state Exp;
branches;
next	1.35;

1.35
date	99.04.09.21.27.10;	author bparker;	state Exp;
branches;
next	1.34;

1.34
date	99.03.09.22.09.53;	author bparker;	state Exp;
branches;
next	1.33;

1.33
date	99.01.27.20.36.25;	author bparker;	state Exp;
branches;
next	1.32;

1.32
date	99.01.26.19.05.18;	author bparker;	state Exp;
branches;
next	1.31;

1.31
date	99.01.21.22.16.48;	author bparker;	state Exp;
branches;
next	1.30;

1.30
date	99.01.19.22.31.30;	author bparker;	state Exp;
branches;
next	1.29;

1.29
date	98.06.16.17.56.16;	author bparker;	state Exp;
branches;
next	1.28;

1.28
date	98.06.15.19.28.25;	author bparker;	state Exp;
branches;
next	1.27;

1.27
date	98.06.09.18.01.24;	author bparker;	state Exp;
branches;
next	1.26;

1.26
date	98.05.07.15.12.52;	author bparker;	state Exp;
branches;
next	1.25;

1.25
date	98.04.06.17.09.27;	author bparker;	state Exp;
branches;
next	1.24;

1.24
date	98.04.01.18.06.31;	author bparker;	state Exp;
branches;
next	1.23;

1.23
date	98.03.20.22.40.22;	author bparker;	state Exp;
branches;
next	1.22;

1.22
date	98.03.06.22.57.46;	author bparker;	state Exp;
branches;
next	1.21;

1.21
date	97.11.04.20.13.14;	author bparker;	state Exp;
branches;
next	1.20;

1.20
date	97.09.29.16.05.52;	author bparker;	state Exp;
branches;
next	1.19;

1.19
date	97.07.17.20.43.28;	author bparker;	state Exp;
branches;
next	1.18;

1.18
date	97.05.28.18.09.07;	author jra;	state Exp;
branches;
next	1.17;

1.17
date	97.05.22.13.22.20;	author jra;	state Exp;
branches;
next	1.16;

1.16
date	97.05.22.13.20.27;	author jra;	state Exp;
branches;
next	1.15;

1.15
date	97.04.24.18.26.22;	author bparker;	state Exp;
branches;
next	1.14;

1.14
date	97.04.18.13.12.28;	author bparker;	state Exp;
branches;
next	1.13;

1.13
date	97.04.18.12.34.29;	author bparker;	state Exp;
branches;
next	1.12;

1.12
date	97.04.15.20.56.52;	author bparker;	state Exp;
branches;
next	1.11;

1.11
date	97.04.15.19.23.14;	author bparker;	state Exp;
branches;
next	1.10;

1.10
date	97.04.14.20.01.39;	author butler;	state Exp;
branches;
next	1.9;

1.9
date	97.04.14.19.40.21;	author bparker;	state Exp;
branches;
next	1.8;

1.8
date	96.07.19.20.44.05;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	96.07.09.19.44.51;	author bparker;	state Exp;
branches;
next	1.6;

1.6
date	95.12.09.20.34.10;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	95.09.09.02.51.12;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	95.09.09.02.49.37;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	95.09.09.02.17.33;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	95.08.10.21.10.57;	author gdurf;	state Exp;
branches;
next	1.1;

1.1
date	95.06.15.20.26.05;	author gdurf;	state Exp;
branches;
next	;

1.45.2.1
date	2000.10.26.20.09.18;	author jra;	state Exp;
branches;
next	1.45.2.2;

1.45.2.2
date	2000.11.02.17.42.32;	author bparker;	state Exp;
branches;
next	1.45.2.3;

1.45.2.3
date	2000.11.17.15.25.02;	author bparker;	state Exp;
branches;
next	1.45.2.4;

1.45.2.4
date	2000.12.22.00.02.27;	author bparker;	state Exp;
branches;
next	1.45.2.5;

1.45.2.5
date	2001.02.09.21.09.40;	author bparker;	state Exp;
branches;
next	;

1.54.2.1
date	2004.03.17.21.23.11;	author morrison;	state Exp;
branches;
next	;

1.54.4.1
date	2002.09.26.23.04.18;	author morrison;	state Exp;
branches;
next	1.54.4.2;

1.54.4.2
date	2004.03.11.23.48.58;	author morrison;	state Exp;
branches;
next	;

1.55.6.1
date	2004.02.12.18.34.49;	author erikg;	state Exp;
branches;
next	1.55.6.2;

1.55.6.2
date	2004.03.15.14.08.10;	author erikg;	state Exp;
branches;
next	1.55.6.3;

1.55.6.3
date	2004.03.18.18.10.33;	author erikg;	state Exp;
branches;
next	;


desc
@Sample user interface for mged
@


1.58
log
@moved to src/tclscripts/
@
text
@#			M G E D . T C L
#
# Author -
#	Glenn Durfee
#
# Source -
#	The U. S. Army Ballistic Research Laboratory
#	Aberdeen Proving Ground, Maryland  21005
#  
# Distribution Notice -
#	Re-distribution of this software is restricted, as described in
#	your "Statement of Terms and Conditions for the Release of
#	The BRL-CAD Package" agreement.
#
# Copyright Notice -
#	This software is Copyright (C) 1995-2004 by the United States Army
#	in all countries except the USA.  All rights reserved.
#
# Description -
#       Sample user interface for MGED
#
#  $Revision: 1.57 $
#
# Modifications -
#        (Bob Parker):
#             Generalized the code to accommodate multiple instances of this
#             user interface.

if ![info exists mged_players] {
    set mged_players {}
}

if ![info exists env(DISPLAY)] {
    set env(DISPLAY) ":0"
}

#==============================================================================
# Ensure that tk.tcl has been loaded already via mged command 'loadtk'.
#==============================================================================
if { [info exists tk_strictMotif] == 0 } {
    loadtk
}

#==============================================================================
# Loading MGED support routines from other files:
#------------------------------------------------------------------------------
#        vmath.tcl  :  The vector math library
#         menu.tcl  :  The Tk menu replacement
# html_library.tcl  :  Stephen Uhler's routines for processing HTML
#==============================================================================
if ![info exists mged_default(html_dir)] {
    set mged_default(html_dir) /usr/brlcad/html/manuals/mged
}

if [info exists env(MGED_HTML_DIR)] {
        set mged_html_dir $env(MGED_HTML_DIR)
} else {
        set mged_html_dir $mged_default(html_dir)
}

proc ia_help { parent screen cmds } {
    set w $parent.help

    catch { destroy $w }
    toplevel $w -screen $screen
    wm title $w "MGED Help"

    button $w.cancel -command "destroy $w" -text "Cancel"
    pack $w.cancel -side bottom -fill x

    scrollbar $w.s -command "$w.l yview"
    listbox $w.l -bd 2 -yscroll "$w.s set" -exportselection false
    pack $w.s -side right -fill y
    pack $w.l -side top -fill both -expand yes

    foreach cmd $cmds {
	$w.l insert end $cmd
    }

#    bind $w.l <Button-1> "mged_help %W $screen"
    bind $w.l <Button-1> "handle_select %W %y; mged_help %W $screen; break"
    bind $w.l <Button-2> "handle_select %W %y; mged_help %W $screen; break"
    bind $w.l <Return> "mged_help %W $screen; break"

    place_near_mouse $w
}

proc handle_select { w y } {
    set curr_sel [$w curselection]
    if { $curr_sel != "" } {
	$w selection clear $curr_sel
    }

    $w selection set [$w nearest $y]
}

proc mged_help { w1 screen } {
    global ::tk::Priv

    catch { help [$w1 get [$w1 curselection]]} msg
    cad_dialog $::tk::Priv(cad_dialog) $screen Usage $msg info 0 OK
}

proc ia_apropos { parent screen } {
    set w $parent.apropos

    catch { destroy $w }
    if { [cad_input_dialog $w $screen Apropos \
	   "Enter keyword to search for:" keyword ""\
	   0 {{ summary "This is where the keyword, on which to search,
is entered. The keyword is used to search
for commands whose descriptions contains the
given keyword."} { see_also apropos }} OK Cancel] == 1 } {
	return
    }

    ia_help $parent $screen [apropos $keyword]
}

proc ia_changestate { args } {
    global mged_display
    global mged_gui
    global transform
    global transform_what

    set id [lindex $args 0]

    if {$mged_display($mged_gui($id,active_dm),adc) != ""} {
	set mged_gui($id,illum_label) $mged_display($mged_gui($id,active_dm),adc)
    } elseif {[string length $mged_display(keypoint)]>0} {
	set mged_gui($id,illum_label) $mged_display(keypoint)
    } elseif {$mged_display(state) == "VIEWING"} {
	set mged_gui($id,illum_label) $mged_display($mged_gui($id,active_dm),fps)
    } else {
	if {$mged_display(state) == "OBJ PATH"} {
	    set mged_gui($id,illum_label) [format "Illuminated path: %s/__MATRIX__%s" \
		    $mged_display(path_lhs) $mged_display(path_rhs)]
	} else {
	    set mged_gui($id,illum_label) [format "Illuminated path: %s    %s" \
		    $mged_display(path_lhs) $mged_display(path_rhs)]
	}
    }
}

proc ::tk::TextInsert {w s} {
    if {$s == ""} {
	return
    }
    catch {
	if {[$w compare sel.first <= insert] && \
		[$w compare sel.last >= insert]} {
	    $w tag remove sel sel.first promptEnd
	    $w delete sel.first sel.last
	}
    }
    $w insert insert $s
    $w see insert
}

proc get_player_id_t { w } {
    global mged_players
    
    foreach id $mged_players {
	set _w .$id.t
	if { $w == $_w } {
	    return $id
	}
    }

    return ":"
}

proc do_New { id } {
    global mged_gui
    global ::tk::Priv

    set ret [cad_input_dialog .$id.new $mged_gui($id,screen)\
	    "New MGED Database" \
	    "Enter new database filename:" ia_filename "${mged_gui(databaseDir)}/" \
	    0 {{ summary "Enter a new database name. Note - a database
must not exist by this name."}}\
	    OK Cancel]

    if {$ia_filename != "" && $ret == 0} {
	# save the directory
	if [file isdirectory $ia_filename] {
	    # the split followed by the join removes extra /'s
	    set mged_gui(databaseDir) [eval file join [file split $ia_filename]]
	    cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "Not a database." \
		    "$ia_filename is a directory!" info 0 OK
	    return
	} else {
	    set mged_gui(databaseDir) [file dirname $ia_filename]
	}

	if [file exists $ia_filename] {
	    cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "Existing Database" \
		    "$ia_filename already exists" info 0 OK
	} else {
	    set ret [catch {opendb $ia_filename y} msg]
	    if {$ret} {
		cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "Error" \
			$msg info 0 OK
	    } else {
		cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "File created" \
			$msg info 0 OK
	    }
	}
    }
}

proc do_Open { id } {
    global mged_gui
    global ::tk::Priv

    set ftypes {{{MGED Database} {.g}} {{All Files} {*}}}
    set filename [tk_getOpenFile -parent .$id -filetypes $ftypes \
	    -initialdir $mged_gui(databaseDir) -title "Open MGED Database"]

    if {$filename != ""} {
	# save the directory
	set mged_gui(databaseDir) [file dirname $filename]

	set ret [catch {opendb $filename} msg]
	if {$ret} {
	    cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "Error" \
		    $msg info 0 OK
	} else {
	    cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "File loaded" \
		    $msg info 0 OK
	}
    }
}

## - getFile
#
# Call Tk's filebrowser to get a file. Initialize the browser to 
# look in $dir at files of type $ftype. The dir parameter is
# updated before returning. This routine returns the absolute
# pathname of the file. Note - the filename length is currently
# limited to a max of 127 characters.
#
proc getFile { parent dir ftypes title } {
    global mged_gui
    global ::tk::Priv

    upvar #0 $dir path

    if {![info exists path] || $path == ""} {
	set path [pwd]
    }

    set filename [tk_getOpenFile -parent $parent -filetypes $ftypes \
	    -initialdir $path -title $title]

    # warn about filenames whose lengths are larger than 127 characters
    if {[string length $filename] > 127} {
	if {$parent == "."} {
	    set parent ""
	}
	cad_dialog $::tk::Priv(cad_dialog) $parent "Error" \
		"Length of path is greater than 127 bytes." info 0 OK
	return ""
    }

    if {$filename != ""} {
	# save the path
	set path [file dirname $filename]
    }

    return $filename
}

proc do_Concat { id } {
    global mged_gui
    global ::tk::Priv

    if {[opendb] == ""} {
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "No database." \
		"No database has been opened!" info 0 OK
	return
    }

    set ftypes {{{MGED Database} {.g}} {{All Files} {*}}}
    set filename [tk_getOpenFile -parent .$id -filetypes $ftypes \
	    -initialdir $mged_gui(databaseDir) \
	    -title "Insert MGED Database"]

    if {$filename != ""} {
	# save the directory
	set mged_gui(databaseDir) [file dirname $filename]

	set ret [cad_input_dialog .$id.prefix $mged_gui($id,screen) "Prefix" \
		"Enter prefix (optional):" prefix ""\
		0 {{ summary "
This is where to enter a prefix. The prefix,
if entered, is prepended to each object of
the database being inserted."} { see_also dbconcat } } OK Cancel]

        if {$prefix == ""} {
	    set prefix /
	}

	if {$ret == 0} {
	    dbconcat $filename $prefix
	}
    }
}

proc do_LoadScript { id } {
	global mged_gui
	global ::tk::Priv
	
	set ftypes {{{All Readable Scripts} {.tcl .sh .rt}} {{Raytrace Scripts} {.rt .sh}} {{Tcl Scripts} {.tcl}} {{All Files} {*}}}
	set ia_filename [tk_getOpenFile -parent .$id -filetypes $ftypes -initialdir $mged_gui(loadScriptDir) -title "Load Script"]
	
	if {$ia_filename != ""} {
		# save the directory
		set mged_gui(loadScriptDir) [file dirname $ia_filename]

		# read in the first two lines of the script file
		# XXX this is not the best thing to do if we have a big script file..
		set ret [ catch { open $ia_filename } scriptfd ]
		if {$ret} {
			cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "Error" $scriptfd info 0 OK
		}
		set ret [ catch { read $scriptfd } scriptsource ]
		if {$ret} {
			cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "Error" $scriptsource info 0 OK
		}
		set ret [ catch { close $scriptfd } msg ]
		if {$ret} {
			cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "Error" $msg info 0 OK
		}			

		# the script should now be stored in scriptsource. attempt to determine some basic types
		if [ regexp {^#!/bin/sh.*?\nrt} $scriptsource ] {
			# handle "saveview" raytrace script

			# attempt to loadview
			set ret [catch { loadview $ia_filename } output ]

		} elseif [ regexp {^#!/.*\n} $scriptsource ] {
			# handle other shell scripts by simply loading them

			set ret [ catch { exec $ia_filename } output ]

		} else {
			# assume we have a tcl script

			set ret [catch {source $ia_filename} output ]

		}
		# end iteration over script detection

		# output a result dialog
		if {$ret} {
			cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "Error" $output info 0 OK
		} else {
			cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "Script loaded" "Script successfully loaded!" info 0 OK
		}
	}
	# end check if filename was given
}

proc do_Units { id } {
    global mged_gui
    global mged_display
    global ::tk::Priv

    if {[opendb] == ""} {
	set mged_display(units) ""
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "No database." \
		"No database has been opened!" info 0 OK
	return
    }

    _mged_units $mged_display(units)
}

proc do_rt_script { id } {
    global mged_gui
    global ::tk::Priv

    set ia_filename [fs_dialog .$id.rtscript .$id "./*"]
    if {[string length $ia_filename] > 0} {
	saveview $ia_filename
    } else {
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "Error" \
		"No such file exists." warning 0 OK
    }
}

proc do_About_MGED { id } {
    global mged_gui
    global mged_default
    global version
    global ::tk::Priv

    cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "About MGED..." \
	    "$version
MGED (Multi-device Geometry EDitor) is part
of the BRL-CAD(TM) package.
Developed by the U. S. Army Research Laboratory
Aberdeen Proving Ground, Maryland  21005-5068  USA

Note - html documentation can be found in
$mged_default(html_dir)" \
	    {} 0 OK
}

proc command_help { id } {
    global mged_gui

    ia_help .$id $mged_gui($id,screen) [concat [?]]
}

proc on_context_help { id } {
}

proc ia_invoke { w } {
    global mged_gui
    global glob_compat_mode

    set id [get_player_id_t $w]

    if {([string length [$w get promptEnd insert]] == 1) &&\
	    ([string length $mged_gui($id,more_default)] > 0)} {
	#If no input and a default is supplied then use it
	set hcmd [concat $mged_gui($id,cmd_prefix) $mged_gui($id,more_default)]
    } else {
	set hcmd [concat $mged_gui($id,cmd_prefix) [$w get promptEnd insert]]
    }

    if {$mged_gui($id,apply_to) == 1} {
	set cmd "mged_apply_local $id \"$hcmd\""
    } elseif {$mged_gui($id,apply_to) == 2} {
	set cmd "mged_apply_using_list $id \"$hcmd\""
    } elseif {$mged_gui($id,apply_to) == 3} {
	set cmd "mged_apply_all $mged_gui($id,active_dm) \"$hcmd\""
    } else {
	set cmd $hcmd
    }

    set mged_gui($id,more_default) ""

    if [info complete $cmd] {
	if {!$mged_gui($w,insert_char_flag)} {
	    cmd_win set $id
	}

	if {$glob_compat_mode == 0} {
	    set result [catch { uplevel #0 $cmd } ia_msg]
	} else {
	    catch { db_glob $cmd } globbed_cmd
	    set result [catch { uplevel #0 $globbed_cmd } ia_msg]
	}

	if { ![winfo exists $w] } {
	    distribute_text $w $hcmd $ia_msg
	    stuff_str "\nmged:$id> $hcmd\n$ia_msg"
	    hist add $hcmd
	    return 
	}

	if {$result != 0} {
            set i [string first "more arguments needed::" $ia_msg]
            if { $i > -1 } {
		if { $i != 0 } {
		    mged_print $w [string range $ia_msg 0 [expr $i - 1]]
		}
		
		set ia_prompt [string range $ia_msg [expr $i + 23] end]
		mged_print_prompt $w $ia_prompt
		set mged_gui($id,cmd_prefix) $hcmd
		$w see insert
		set mged_gui($id,more_default) [get_more_default]
		return
	    }
	    .$id.t tag add oldcmd promptEnd insert
	    mged_print_tag $w "Error: $ia_msg\n" result
	} else {
	    .$id.t tag add oldcmd promptEnd insert

	    if {$ia_msg != ""} {
		mged_print_tag $w $ia_msg\n result
	    }

	    distribute_text $w $hcmd $ia_msg
	    stuff_str "\nmged:$id> $hcmd\n$ia_msg"
	}

	hist add $hcmd
	set mged_gui($id,cmd_prefix) ""
	mged_print_prompt $w "mged> "
    }
    $w see insert
}

proc echo args {
    return $args
}

#==============================================================================
# HTML support
#==============================================================================
proc man_goto { w screen } {
    global ia_url
    global ::tk::Priv

    cad_input_dialog $::tk::Priv(cad_dialog) $screen "Go To" "Enter filename to read:" \
	    filename $ia_url(current) \
	    0 {{ summary "Enter a filename or URL."}} OK

    if { [file exists $filename]!=0 } {
	if { [string match /* $filename] } {
	    set new_url $filename
	} else {
	    set new_url [pwd]/$filename
	}

	HMlink_callback $w.text $new_url
    } else {
	cad_dialog $::tk::Priv(cad_dialog) $screen "Error reading file" \
		"Cannot read file $filename." error 0 OK
    }
}

proc ia_man { parent screen } {
    global mged_html_dir ia_url message

    set w $parent.man
    catch { destroy $w }
    toplevel $w -screen $screen
    wm title $w "MGED HTML browser"

    frame $w.f -relief sunken -bd 1
    pack $w.f -side top -fill x

    button $w.f.close -text Close -command "destroy $w"
    button $w.f.goto -text "Go To" -command "man_goto $w $screen"
    button $w.f.back -text "Back" -command "ia_man_back $w.text"

    pack $w.f.close $w.f.goto $w.f.back -side left -fill x -expand yes

    label $w.message -textvar message -anchor w
    pack $w.message -side top -anchor w -fill x

    scrollbar $w.scrolly -command "$w.text yview"
    scrollbar $w.scrollx -command "$w.text xview" -orient horizontal
    text $w.text -relief ridge -yscroll "$w.scrolly set" \
	    -xscroll "$w.scrollx set"
    pack $w.scrolly -side right -fill y
    pack $w.text -side top -fill both -expand yes
    pack $w.scrollx -side bottom -fill x

    set w $w.text

    HMinit_win $w
    set ia_url(current)   $mged_html_dir/
    set ia_url(last)      ""
    set ia_url(backtrack) ""
    HMlink_callback $w contents.html
}

proc HMlink_callback { w href } {
    global ia_url message

    if {[string match /* $href]} {
	set new_url $href
    } else {
	if { [file isdirectory $ia_url(current)] } {
	    set new_url $ia_url(current)$href
	} else {
	    set new_url [file dirname $ia_url(current)]/$href
	}
    }

    # Remove tags
    regsub {#[0-9a-zA-Z]*} $new_url {} ia_url(current)
    lappend ia_url(last) $ia_url(current)
    set ia_url(backtrack) [lrange $ia_url(last) 0 \
	    [expr [llength $ia_url(last)]-2]]

    HMreset_win $w
    HMparse_html [ia_get_html $ia_url(current)] "HMrender $w"
    update
}

proc ia_man_back { w } {
    global ia_url message

    if {[llength $ia_url(backtrack)]<1} {
	return
    }
    
    set new_url [lindex $ia_url(backtrack) end]
    set ia_url(backtrack) [lrange $ia_url(backtrack) 0 \
	    [expr [llength $ia_url(backtrack)]-2]]

    HMreset_win $w
    HMparse_html [ia_get_html $new_url] "HMrender $w"
    update
}

proc HMset_image { handle src } {
    global ia_url message

    if {[string match http://* $src]} {
	return
    }
    
    if {[string match /* $src]} {
	set image $src
    } else {
	set image [file dirname $ia_url(current)]/$src
    }

    set message "Fetching image $image."
    update
    if {[string first " $image " " [image names] "] >= 0} {
	HMgot_image $handle $image
    } else {
	catch {image create photo $image -file $image} image
	HMgot_image $handle $image
    }
}

proc ia_get_html {file} {
    global message ia_url

    set message "Reading file $file"
    update

    if {[string match *.gif $file]} {
	return "<img src=\"[file tail $file]\">"
    }
    
    if {[catch {set fd [open $file]} msg]} {
	return "
	<title>Bad file $file</title>
	<h1>Error reading $file</h1><p>
	$msg<hr>
	"
    }
    set result [read $fd]
    close $fd
    return $result
}

#==============================================================================
# Other Support Routines
#==============================================================================
@


1.57
log
@ws
@
text
@d22 1
a22 1
#  $Revision$
@


1.56
log
@update copyright to include span through 2003
@
text
@d22 1
a22 1
#  $Revision: 1.55 $
a361 1

a363 1

@


1.55
log
@*** empty log message ***
@
text
@d16 1
a16 1
#	This software is Copyright (C) 1995 by the United States Army
d22 1
a22 1
#  $Revision: 1.54 $
@


1.55.6.1
log
@merge from HEAD
@
text
@d16 1
a16 1
#	This software is Copyright (C) 1995-2004 by the United States Army
d22 1
a22 1
#  $Revision: 1.56 $
@


1.55.6.2
log
@merge from head
@
text
@d22 1
a22 1
#  $Revision: 1.55.6.1 $
@


1.55.6.3
log
@merge from head
@
text
@d22 1
a22 1
#  $Revision$
d362 1
d365 1
@


1.54
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d22 1
a22 1
#  $Revision: 1.52 $
d98 1
a98 1
    global tkPriv
d101 1
a101 1
    cad_dialog $tkPriv(cad_dialog) $screen Usage $msg info 0 OK
d145 1
a145 1
proc tkTextInsert {w s} {
d175 1
a175 1
    global tkPriv
d189 1
a189 1
	    cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "Not a database." \
d197 1
a197 1
	    cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "Existing Database" \
d202 1
a202 1
		cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "Error" \
d205 1
a205 1
		cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "File created" \
d214 1
a214 1
    global tkPriv
d226 1
a226 1
	    cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "Error" \
d229 1
a229 1
	    cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "File loaded" \
d245 1
a245 1
    global tkPriv
d261 1
a261 1
	cad_dialog $tkPriv(cad_dialog) $parent "Error" \
d276 1
a276 1
    global tkPriv
d279 1
a279 1
	cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "No database." \
d312 1
a312 1
	global tkPriv
d325 1
a325 1
			cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "Error" $scriptfd info 0 OK
d329 1
a329 1
			cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "Error" $scriptsource info 0 OK
d333 1
a333 1
			cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "Error" $msg info 0 OK
d358 1
a358 1
			cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "Error" $output info 0 OK
d360 1
a360 1
			cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "Script loaded" "Script successfully loaded!" info 0 OK
d371 1
a371 1
    global tkPriv
d375 1
a375 1
	cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "No database." \
d385 1
a385 1
    global tkPriv
d391 1
a391 1
	cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "Error" \
d400 1
a400 1
    global tkPriv
d402 1
a402 1
    cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "About MGED..." \
d511 1
a511 1
    global tkPriv
d513 1
a513 1
    cad_input_dialog $tkPriv(cad_dialog) $screen "Go To" "Enter filename to read:" \
d526 1
a526 1
	cad_dialog $tkPriv(cad_dialog) $screen "Error reading file" \
@


1.54.2.1
log
@sync branch with HEAD
@
text
@d16 1
a16 1
#	This software is Copyright (C) 1995-2004 by the United States Army
d22 1
a22 1
#  $Revision$
d98 1
a98 1
    global ::tk::Priv
d101 1
a101 1
    cad_dialog $::tk::Priv(cad_dialog) $screen Usage $msg info 0 OK
d145 1
a145 1
proc ::tk::TextInsert {w s} {
d175 1
a175 1
    global ::tk::Priv
d189 1
a189 1
	    cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "Not a database." \
d197 1
a197 1
	    cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "Existing Database" \
d202 1
a202 1
		cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "Error" \
d205 1
a205 1
		cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "File created" \
d214 1
a214 1
    global ::tk::Priv
d226 1
a226 1
	    cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "Error" \
d229 1
a229 1
	    cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "File loaded" \
d245 1
a245 1
    global ::tk::Priv
d261 1
a261 1
	cad_dialog $::tk::Priv(cad_dialog) $parent "Error" \
d276 1
a276 1
    global ::tk::Priv
d279 1
a279 1
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "No database." \
d312 1
a312 1
	global ::tk::Priv
d325 1
a325 1
			cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "Error" $scriptfd info 0 OK
d329 1
a329 1
			cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "Error" $scriptsource info 0 OK
d333 1
a333 1
			cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "Error" $msg info 0 OK
d358 1
a358 1
			cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "Error" $output info 0 OK
d360 1
a360 1
			cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "Script loaded" "Script successfully loaded!" info 0 OK
d362 1
d365 1
d371 1
a371 1
    global ::tk::Priv
d375 1
a375 1
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "No database." \
d385 1
a385 1
    global ::tk::Priv
d391 1
a391 1
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "Error" \
d400 1
a400 1
    global ::tk::Priv
d402 1
a402 1
    cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "About MGED..." \
d511 1
a511 1
    global ::tk::Priv
d513 1
a513 1
    cad_input_dialog $::tk::Priv(cad_dialog) $screen "Go To" "Enter filename to read:" \
d526 1
a526 1
	cad_dialog $::tk::Priv(cad_dialog) $screen "Error reading file" \
@


1.54.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d22 1
a22 1
#  $Revision: 1.54 $
d98 1
a98 1
    variable ::tk::Priv
d101 1
a101 1
    cad_dialog $Priv(cad_dialog) $screen Usage $msg info 0 OK
d175 1
a175 1
    variable ::tk::Priv
d189 1
a189 1
	    cad_dialog $Priv(cad_dialog) $mged_gui($id,screen) "Not a database." \
d197 1
a197 1
	    cad_dialog $Priv(cad_dialog) $mged_gui($id,screen) "Existing Database" \
d202 1
a202 1
		cad_dialog $Priv(cad_dialog) $mged_gui($id,screen) "Error" \
d205 1
a205 1
		cad_dialog $Priv(cad_dialog) $mged_gui($id,screen) "File created" \
d214 1
a214 1
    variable ::tk::Priv
d226 1
a226 1
	    cad_dialog $Priv(cad_dialog) $mged_gui($id,screen) "Error" \
d229 1
a229 1
	    cad_dialog $Priv(cad_dialog) $mged_gui($id,screen) "File loaded" \
d245 1
a245 1
    variable ::tk::Priv
d261 1
a261 1
	cad_dialog $Priv(cad_dialog) $parent "Error" \
d276 1
a276 1
    variable ::tk::Priv
d279 1
a279 1
	cad_dialog $Priv(cad_dialog) $mged_gui($id,screen) "No database." \
d312 1
a312 1
	variable ::tk::Priv
d325 1
a325 1
			cad_dialog $Priv(cad_dialog) $mged_gui($id,screen) "Error" $scriptfd info 0 OK
d329 1
a329 1
			cad_dialog $Priv(cad_dialog) $mged_gui($id,screen) "Error" $scriptsource info 0 OK
d333 1
a333 1
			cad_dialog $Priv(cad_dialog) $mged_gui($id,screen) "Error" $msg info 0 OK
d358 1
a358 1
			cad_dialog $Priv(cad_dialog) $mged_gui($id,screen) "Error" $output info 0 OK
d360 1
a360 1
			cad_dialog $Priv(cad_dialog) $mged_gui($id,screen) "Script loaded" "Script successfully loaded!" info 0 OK
d362 1
d365 1
d371 1
a371 1
    variable ::tk::Priv
d375 1
a375 1
	cad_dialog $Priv(cad_dialog) $mged_gui($id,screen) "No database." \
d385 1
a385 1
    variable ::tk::Priv
d391 1
a391 1
	cad_dialog $Priv(cad_dialog) $mged_gui($id,screen) "Error" \
d400 1
a400 1
    variable ::tk::Priv
d402 1
a402 1
    cad_dialog $Priv(cad_dialog) $mged_gui($id,screen) "About MGED..." \
d511 1
a511 1
    variable ::tk::Priv
d513 1
a513 1
    cad_input_dialog $Priv(cad_dialog) $screen "Go To" "Enter filename to read:" \
d526 1
a526 1
	cad_dialog $Priv(cad_dialog) $screen "Error reading file" \
@


1.54.4.2
log
@sync to HEAD...
@
text
@d16 1
a16 1
#	This software is Copyright (C) 1995-2004 by the United States Army
d22 1
a22 1
#  $Revision: 1.54.4.1 $
d98 1
a98 1
    global ::tk::Priv
d101 1
a101 1
    cad_dialog $::tk::Priv(cad_dialog) $screen Usage $msg info 0 OK
d145 1
a145 1
proc ::tk::TextInsert {w s} {
d175 1
a175 1
    global ::tk::Priv
d189 1
a189 1
	    cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "Not a database." \
d197 1
a197 1
	    cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "Existing Database" \
d202 1
a202 1
		cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "Error" \
d205 1
a205 1
		cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "File created" \
d214 1
a214 1
    global ::tk::Priv
d226 1
a226 1
	    cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "Error" \
d229 1
a229 1
	    cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "File loaded" \
d245 1
a245 1
    global ::tk::Priv
d261 1
a261 1
	cad_dialog $::tk::Priv(cad_dialog) $parent "Error" \
d276 1
a276 1
    global ::tk::Priv
d279 1
a279 1
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "No database." \
d312 1
a312 1
	global ::tk::Priv
d325 1
a325 1
			cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "Error" $scriptfd info 0 OK
d329 1
a329 1
			cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "Error" $scriptsource info 0 OK
d333 1
a333 1
			cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "Error" $msg info 0 OK
d358 1
a358 1
			cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "Error" $output info 0 OK
d360 1
a360 1
			cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "Script loaded" "Script successfully loaded!" info 0 OK
d369 1
a369 1
    global ::tk::Priv
d373 1
a373 1
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "No database." \
d383 1
a383 1
    global ::tk::Priv
d389 1
a389 1
	cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "Error" \
d398 1
a398 1
    global ::tk::Priv
d400 1
a400 1
    cad_dialog $::tk::Priv(cad_dialog) $mged_gui($id,screen) "About MGED..." \
d509 1
a509 1
    global ::tk::Priv
d511 1
a511 1
    cad_input_dialog $::tk::Priv(cad_dialog) $screen "Go To" "Enter filename to read:" \
d524 1
a524 1
	cad_dialog $::tk::Priv(cad_dialog) $screen "Error reading file" \
@


1.53
log
@Converted from K&R to ANSI C - RFH
@
text
@d22 1
a22 1
#  $Revision: 1.51 $
d294 1
a294 1
		"Enter prefix:" prefix ""\
d311 51
a361 2
    global mged_gui
    global tkPriv
d363 2
a364 4
    set ftypes {{{Tcl Scripts} {.tcl}} {{All Files} {*}}}
    set ia_filename [tk_getOpenFile -parent .$id -filetypes $ftypes \
	    -initialdir $mged_gui(loadScriptDir) \
	    -title "Load Script"]
a365 13
    if {$ia_filename != ""} {
	# save the directory
	set mged_gui(loadScriptDir) [file dirname $ia_filename]

	set ret [catch {source $ia_filename} msg]
	if {$ret} {
	    cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "Error" \
		    $msg info 0 OK
	} else {
	    cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "Script loaded" \
		    "Script successfully loaded!" info 0 OK
	}
    }
@


1.52
log
@added support to load other script types such as raytrace scripts (using the new loadview command), as well as properly run other \#\!... scripts instead of simply assuming only tcl scripts
@
text
@d294 1
a294 1
		"Enter prefix (optional):" prefix ""\
d311 2
a312 51
	global mged_gui
	global tkPriv
	
	set ftypes {{{All Readable Scripts} {.tcl .sh .rt}} {{Raytrace Scripts} {.rt .sh}} {{Tcl Scripts} {.tcl}} {{All Files} {*}}}
	set ia_filename [tk_getOpenFile -parent .$id -filetypes $ftypes -initialdir $mged_gui(loadScriptDir) -title "Load Script"]
	
	if {$ia_filename != ""} {
		# save the directory
		set mged_gui(loadScriptDir) [file dirname $ia_filename]

		# read in the first two lines of the script file
		# XXX this is not the best thing to do if we have a big script file..
		set ret [ catch { open $ia_filename } scriptfd ]
		if {$ret} {
			cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "Error" $scriptfd info 0 OK
		}
		set ret [ catch { read $scriptfd } scriptsource ]
		if {$ret} {
			cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "Error" $scriptsource info 0 OK
		}
		set ret [ catch { close $scriptfd } msg ]
		if {$ret} {
			cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "Error" $msg info 0 OK
		}			

		# the script should now be stored in scriptsource. attempt to determine some basic types
		if [ regexp {^#!/bin/sh.*?\nrt} $scriptsource ] {
			# handle "saveview" raytrace script

			# attempt to loadview
			set ret [catch { loadview $ia_filename } output ]

		} elseif [ regexp {^#!/.*\n} $scriptsource ] {
			# handle other shell scripts by simply loading them

			set ret [ catch { exec $ia_filename } output ]

		} else {
			# assume we have a tcl script

			set ret [catch {source $ia_filename} output ]

		}
		# end iteration over script detection

		# output a result dialog
		if {$ret} {
			cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "Error" $output info 0 OK
		} else {
			cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "Script loaded" "Script successfully loaded!" info 0 OK
		}
d314 16
d331 1
a331 2
	# end check if filename was given

@


1.51
log
@*- mods requested by Eric regarding consistency
   when using capitalization in the GUI
@
text
@d22 1
a22 1
#  $Revision: 1.50 $
d294 1
a294 1
		"Enter prefix:" prefix ""\
d311 51
a361 2
    global mged_gui
    global tkPriv
d363 2
a364 4
    set ftypes {{{Tcl Scripts} {.tcl}} {{All Files} {*}}}
    set ia_filename [tk_getOpenFile -parent .$id -filetypes $ftypes \
	    -initialdir $mged_gui(loadScriptDir) \
	    -title "Load Script"]
a365 13
    if {$ia_filename != ""} {
	# save the directory
	set mged_gui(loadScriptDir) [file dirname $ia_filename]

	set ret [catch {source $ia_filename} msg]
	if {$ret} {
	    cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "Error" \
		    $msg info 0 OK
	} else {
	    cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "Script loaded" \
		    "Script successfully loaded!" info 0 OK
	}
    }
@


1.50
log
@*- code to remove extra /'s from the path
   of the open dialog entry
@
text
@d22 1
a22 1
#  $Revision: 1.49 $
d182 1
a182 1
	    OK CANCEL]
d298 1
a298 1
the database being inserted."} { see_also dbconcat } } OK CANCEL]
@


1.49
log
@Use tkPriv(cad_dialog) for dialog name.
@
text
@d22 1
a22 1
#  $Revision: 1.45.2.4 $
d187 2
a188 1
	    set mged_gui(databaseDir) $ia_filename
@


1.48
log
@ia_help proc now calls place_near_mouse
to position the help dialog
@
text
@d22 1
a22 1
#  $Revision: 1.47 $
d80 4
a83 4
#    bind $w.l <Button-1> "mged_help %W $w.u $screen"
    bind $w.l <Button-1> "handle_select %W %y; mged_help %W $w.u $screen; break"
    bind $w.l <Button-2> "handle_select %W %y; mged_help %W $w.u $screen; break"
    bind $w.l <Return> "mged_help %W $w.u $screen; break"
d97 3
a99 1
proc mged_help { w1 w2 screen } {
d101 1
a101 2
    catch { destroy $w2 }
    cad_dialog $w2 $screen Usage $msg info 0 OK
d175 1
d188 1
a188 1
	    cad_dialog .$id.uncool $mged_gui($id,screen) "Not a database." \
d196 1
a196 1
	    cad_dialog .$id.uncool $mged_gui($id,screen) "Existing Database" \
d201 1
a201 1
		cad_dialog .$id.uncool $mged_gui($id,screen) "Error" \
d204 1
a204 1
		cad_dialog .$id.cool $mged_gui($id,screen) "File created" \
d213 1
d225 1
a225 1
	    cad_dialog .$id.uncool $mged_gui($id,screen) "Error" \
d228 1
a228 1
	    cad_dialog .$id.cool $mged_gui($id,screen) "File loaded" \
d244 2
d260 1
a260 1
	cad_dialog $parent.uncool $parent "Error" \
d275 1
d278 1
a278 1
	cad_dialog .$id.uncool $mged_gui($id,screen) "No database." \
d311 1
d324 1
a324 1
	    cad_dialog .$id.uncool $mged_gui($id,screen) "Error" \
d327 1
a327 1
	    cad_dialog .$id.cool $mged_gui($id,screen) "Script loaded" \
d336 1
d340 1
a340 1
	cad_dialog .$id.uncool $mged_gui($id,screen) "No database." \
d350 1
d356 1
a356 1
	cad_dialog .$id.uncool $mged_gui($id,screen) "Error" \
d365 1
d367 1
a367 1
    cad_dialog .$id.about $mged_gui($id,screen) "About MGED..." \
d476 1
d478 1
a478 1
    cad_input_dialog $w.goto $screen "Go To" "Enter filename to read:" \
d491 1
a491 1
	cad_dialog $w.gotoerror $screen "Error reading file" \
@


1.47
log
@Add note about MGED manual's html directory.
@
text
@d22 1
a22 1
#  $Revision: 1.46 $
d84 2
@


1.46
log
@Added "/" to end of prompt for new database name
@
text
@d22 1
a22 1
#  $Revision: 1.45 $
d352 1
d360 4
a363 1
Aberdeen Proving Ground, Maryland  21005-5068  USA" \
@


1.45
log
@*- get rid of the no longer needed id parameter
@
text
@d22 1
a22 1
#  $Revision: 1.44 $
d175 1
a175 1
	    "Enter new database filename:" ia_filename $mged_gui(databaseDir) \
@


1.45.2.1
log
@Added a "/" at the end of the prompt for a new database name
@
text
@d22 1
a22 1
#  $Revision: 1.45 $
d175 1
a175 1
	    "Enter new database filename:" ia_filename "${mged_gui(databaseDir)}/" \
@


1.45.2.2
log
@Add note about MGED manual html directory.
@
text
@d22 1
a22 1
#  $Revision: 1.45.2.1 $
a351 1
    global mged_default
d359 1
a359 4
Aberdeen Proving Ground, Maryland  21005-5068  USA

Note - html documentation can be found in
$mged_default(html_dir)" \
@


1.45.2.3
log
@ia_help proc now calls place_near_mouse
to position the help dialog
@
text
@d22 1
a22 1
#  $Revision: 1.45.2.2 $
a83 2

    place_near_mouse $w
@


1.45.2.4
log
@Use tkPriv(cad_dialog) for dialog name.
@
text
@d22 1
a22 1
#  $Revision: 1.45.2.3 $
d80 4
a83 4
#    bind $w.l <Button-1> "mged_help %W $screen"
    bind $w.l <Button-1> "handle_select %W %y; mged_help %W $screen; break"
    bind $w.l <Button-2> "handle_select %W %y; mged_help %W $screen; break"
    bind $w.l <Return> "mged_help %W $screen; break"
d97 1
a97 3
proc mged_help { w1 screen } {
    global tkPriv

d99 2
a100 1
    cad_dialog $tkPriv(cad_dialog) $screen Usage $msg info 0 OK
a173 1
    global tkPriv
d186 1
a186 1
	    cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "Not a database." \
d194 1
a194 1
	    cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "Existing Database" \
d199 1
a199 1
		cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "Error" \
d202 1
a202 1
		cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "File created" \
a210 1
    global tkPriv
d222 1
a222 1
	    cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "Error" \
d225 1
a225 1
	    cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "File loaded" \
a240 2
    global tkPriv

d255 1
a255 1
	cad_dialog $tkPriv(cad_dialog) $parent "Error" \
a269 1
    global tkPriv
d272 1
a272 1
	cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "No database." \
a304 1
    global tkPriv
d317 1
a317 1
	    cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "Error" \
d320 1
a320 1
	    cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "Script loaded" \
a328 1
    global tkPriv
d332 1
a332 1
	cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "No database." \
a341 1
    global tkPriv
d347 1
a347 1
	cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "Error" \
a355 1
    global tkPriv
d357 1
a357 1
    cad_dialog $tkPriv(cad_dialog) $mged_gui($id,screen) "About MGED..." \
a465 1
    global tkPriv
d467 1
a467 1
    cad_input_dialog $tkPriv(cad_dialog) $screen "Go To" "Enter filename to read:" \
d480 1
a480 1
	cad_dialog $tkPriv(cad_dialog) $screen "Error reading file" \
@


1.45.2.5
log
@Mods to remove extra /'s from mged_gui(databaseDir).
This fixes a bug that shows up in the new database dialog.
@
text
@d22 1
a22 1
#  $Revision: 1.45.2.4 $
d187 1
a187 2
	    # the split followed by the join removes extra /'s
	    set mged_gui(databaseDir) [eval file join [file split $ia_filename]]
@


1.44
log
@*- new tcl proc called getFile that calls Tk's
   tk_getOpenFile filebrowser. getFile is being
   called from edsol.c to handle solids that reference
   one or more files.
@
text
@d22 1
a22 1
#  $Revision: 1.43 $
d237 1
a237 1
proc getFile { id parent dir ftypes title } {
d253 1
a253 1
	cad_dialog $parent.uncool $mged_gui($id,screen) "Error" \
@


1.43
log
@*- check for open database
@
text
@d22 1
a22 1
#  $Revision: 1.42 $
d210 3
a212 4
    set file_types {{{MGED Database} {.g}} {{All Files} {*}}}
    set ia_filename [tk_getOpenFile -parent .$id -filetypes $file_types \
	    -initialdir $mged_gui(databaseDir) \
	    -title "Open MGED Database"]
d214 1
a214 1
    if {$ia_filename != ""} {
d216 1
a216 1
	set mged_gui(databaseDir) [file dirname $ia_filename]
d218 1
a218 1
	set ret [catch {opendb $ia_filename} msg]
d229 37
d275 2
a276 2
    set file_types {{{MGED Database} {.g}} {{All Files} {*}}}
    set ia_filename [tk_getOpenFile -parent .$id -filetypes $file_types \
d280 1
a280 1
    if {$ia_filename != ""} {
d282 1
a282 1
	set mged_gui(databaseDir) [file dirname $ia_filename]
d296 1
a296 1
	    dbconcat $ia_filename $prefix
d304 2
a305 2
    set file_types {{{Tcl Scripts} {.tcl}} {{All Files} {*}}}
    set ia_filename [tk_getOpenFile -parent .$id -filetypes $file_types \
@


1.42
log
@*- use mged_gui(databaseDir) and mged_gui(loadScriptDir) to
   initialize tk_getOpenFile
*- stop using tk_getOpenFile's -defaultextension option
@
text
@d22 1
a22 1
#  $Revision: 1.41 $
d233 6
d289 1
d291 7
@


1.41
log
@*- changed loaded to created
@
text
@d22 1
a22 1
#  $Revision: 1.40 $
d175 1
a175 1
	    "Enter new database filename:" ia_filename ""\
d181 10
d210 5
a214 3
    set file_types {{{MGED Database} {.g}}}
    set ia_filename [tk_getOpenFile -parent .$id -filetypes $file_types\
	    -title "Open MGED Database" -defaultextension ".g"]
d216 3
d233 5
a237 3
    set file_types {{{MGED Database} {.g}}}
    set ia_filename [tk_getOpenFile -parent .$id -filetypes $file_types\
	    -title "Insert MGED Database" -defaultextension ".g"]
d239 3
d262 5
a266 3
    set file_types {{{Tcl Scripts} {.tcl}}}
    set ia_filename [tk_getOpenFile -parent .$id -filetypes $file_types\
	    -title "Load Script" -defaultextension ".tcl"]
d268 3
@


1.40
log
@*- add do_LoadScript proc for browsing the file system
	for a Tcl script to load.
@
text
@d22 1
a22 1
#  $Revision: 1.39 $
d190 1
a190 1
		cad_dialog .$id.cool $mged_gui($id,screen) "File loaded" \
@


1.39
log
@*- mods to do_Open and do_New to catch the return value
   from the call to opendb
@
text
@d22 1
a22 1
#  $Revision: 1.38 $
a169 18
proc do_Open { id } {
    global mged_gui

    set file_types {{{MGED Database} {.g}}}
    set ia_filename [tk_getOpenFile -parent .$id -filetypes $file_types\
	    -title "Open MGED Database" -defaultextension ".g"]
    if {$ia_filename != ""} {
	set ret [catch {opendb $ia_filename} msg]
	if {$ret} {
	    cad_dialog .$id.cool $mged_gui($id,screen) "Error" \
		    $msg info 0 OK
	} else {
	    cad_dialog .$id.cool $mged_gui($id,screen) "File loaded" \
		    $msg info 0 OK
	}
    }
}

d187 1
a187 1
		cad_dialog .$id.cool $mged_gui($id,screen) "Error" \
d197 18
d220 1
a220 1
	    -initialdir . -title "Insert MGED Database" -defaultextension ".g"]
d235 18
@


1.38
log
@*- fixed bug in do_Concat
	- if prefix not specified then hand dbconcat a '/'
@
text
@d22 1
a22 1
#  $Revision: 1.37 $
d177 8
a184 3
	opendb $ia_filename
	cad_dialog .$id.cool $mged_gui($id,screen) "File loaded" \
		"Database $ia_filename successfully loaded." info 0 OK
d203 8
a210 3
	    opendb $ia_filename y
	    cad_dialog .$id.cool $mged_gui($id,screen) "File loaded" \
		    "Database $ia_filename successfully loaded." info 0 OK
d229 4
d234 1
a234 5
	    if {$prefix != ""} {
		dbconcat $ia_filename $prefix
	    } else {
		dbconcat $ia_filename /
	    }
@


1.37
log
@*- add help on context
@
text
@d22 1
a22 1
#  $Revision: 1.36 $
d223 1
a223 1
		dbconcat $ia_filename
@


1.36
log
@*- update code that searches for the MGED manual
*- clean up a bit
@
text
@d22 1
a22 1
#  $Revision: 1.35 $
d106 5
a110 1
	   "Enter keyword to search for:" keyword "" 0 OK Cancel] == 1 } {
d186 6
a191 2
    set ret [cad_input_dialog .$id.new $mged_gui($id,screen) "New MGED Database" \
	    "Enter new database filename:" ia_filename "" 0 OK CANCEL]
d212 13
a224 7
	cad_input_dialog .$id.prefix $mged_gui($id,screen) "Prefix" \
		"Enter prefix:" prefix "" 0 OK

	if {$prefix != ""} {
	    dbconcat $ia_filename $prefix
	} else {
	    dbconcat $ia_filename /
d359 3
a361 1
	    filename $ia_url(current) 0 OK
@


1.35
log
@*- call mged_apply_all with pathname of current display manager window
@
text
@d22 1
a22 1
#  $Revision: 1.34 $
d33 1
a33 3
if {[info exists env(DISPLAY)] == 0} {
    puts "The DISPLAY environment variable was not set."
    puts "Setting the DISPLAY environment variable to :0\n"
a36 1

a48 1
#      sliders.tcl  :  The Tk sliders replacement
d51 4
d56 1
a56 1
    set mged_html_dir $env(MGED_HTML_DIR)
d58 1
a58 1
    set mged_html_dir [lindex $auto_path 0]/../../html/mged
a60 2
#catch { source [lindex $auto_path 0]/sliders.tcl }

d362 1
a362 1
    
a387 8
#    if { [info exists ia_url]==0 } {
#	while { [file exists $mged_html_dir/index.html]==0 } {
#	    cad_input_dialog .mgedhtmldir $screen "Need path to MGED .html files"
#		    "Please enter the full path to the MGED .html files:" \
#		    mged_html_dir $mged_html_dir 0 OK
#	}
#    }

d394 1
a394 1
    HMlink_callback $w index.html
@


1.34
log
@*** empty log message ***
@
text
@d22 1
a22 1
#  $Revision: 1.33 $
d276 1
a276 1
	set cmd "mged_apply_all \"$hcmd\""
@


1.33
log
@*- collapse hist_add, hist_next and hist_prev into hist
@
text
@d22 1
a22 1
#  $Revision: 1.32 $
d29 4
a152 4
}

if ![info exists mged_players] {
    set mged_players ""
@


1.32
log
@*- use cmd_win instead of cmd_set
@
text
@d22 1
a22 1
#  $Revision: 1.31 $
d298 1
a298 1
	    hist_add $hcmd
d329 1
a329 1
	hist_add $hcmd
@


1.31
log
@*- fixed bug 379,
   libtk's tk_getOpenFile proc didn't like an initial directory of "."
@
text
@d22 1
a22 1
#  $Revision: 1.30 $
d285 1
a285 1
	    cmd_set $id
@


1.30
log
@*- cleanup variables
@
text
@d22 1
a22 1
#  $Revision: 1.29 $
d173 1
a173 1
	    -initialdir . -title "Open MGED Database" -defaultextension ".g"]
@


1.29
log
@*- modify do_About_MGED() to include version info
@
text
@d22 1
a22 1
#  $Revision: 1.28 $
d112 2
a113 2
    global mged_display ia_illum_label
    global mged_active_dm
d119 2
a120 2
    if {$mged_display($mged_active_dm($id),adc) != ""} {
	set ia_illum_label($id) $mged_display($mged_active_dm($id),adc)
d122 1
a122 1
	set ia_illum_label($id) $mged_display(keypoint)
d124 1
a124 1
	set ia_illum_label($id) $mged_display($mged_active_dm($id),fps)
d127 1
a127 1
	    set ia_illum_label($id) [format "Illuminated path: %s/__MATRIX__%s" \
d130 1
a130 1
	    set ia_illum_label($id) [format "Illuminated path: %s    %s" \
d169 1
a169 1
    global player_screen
d176 1
a176 1
	cad_dialog .$id.cool $player_screen($id) "File loaded" \
d182 1
a182 1
    global player_screen
d184 1
a184 1
    set ret [cad_input_dialog .$id.new $player_screen($id) "New MGED Database" \
d189 1
a189 1
	    cad_dialog .$id.uncool $player_screen($id) "Existing Database" \
d193 1
a193 1
	    cad_dialog .$id.cool $player_screen($id) "File loaded" \
d200 1
a200 1
    global player_screen
d206 1
a206 1
	cad_input_dialog .$id.prefix $player_screen($id) "Prefix" \
d224 1
a224 1
    global player_screen
d230 1
a230 1
	cad_dialog .$id.uncool $player_screen($id) "Error" \
d236 1
a236 1
    global player_screen
d239 1
a239 1
    cad_dialog .$id.about $player_screen($id) "About MGED..." \
d249 1
a249 1
    global player_screen
d251 1
a251 1
    ia_help .$id $player_screen($id) [concat [?]]
d258 1
a258 3
    global ia_cmd_prefix
    global ia_more_default
    global mged_apply_to
a259 1
    global dm_insert_char_flag
d264 1
a264 1
	    ([string length $ia_more_default($id)] > 0)} {
d266 1
a266 1
	set hcmd [concat $ia_cmd_prefix($id) $ia_more_default($id)]
d268 1
a268 1
	set hcmd [concat $ia_cmd_prefix($id) [$w get promptEnd insert]]
d271 1
a271 1
    if {$mged_apply_to($id) == 1} {
d273 1
a273 1
    } elseif {$mged_apply_to($id) == 2} {
d275 1
a275 1
    } elseif {$mged_apply_to($id) == 3} {
d281 1
a281 1
    set ia_more_default($id) ""
d284 1
a284 1
	if {!$dm_insert_char_flag($w)} {
d311 1
a311 1
		set ia_cmd_prefix($id) $hcmd
d313 1
a313 1
		set ia_more_default($id) [get_more_default]
d330 1
a330 1
	set ia_cmd_prefix($id) ""
@


1.28
log
@*- append "break" to bindings to prevent further processing
@
text
@d22 1
a22 1
#  $Revision: 1.27 $
d237 1
d240 5
a244 6
	    "MGED: Multi-device Geometry EDitor\n\
\n\
MGED is a part of the BRL-CAD(TM) package.\n\n\
Developed by The U. S. Army Research Laboratory\n\
Aberdeen Proving Ground, Maryland  21005-5068  USA\n\
" \
@


1.27
log
@*- move mged_dialog and mged_input_dialog to cad_dialog.tcl
	and changed their names to cad_dialog and cad_input_dialog.
*- use new dialog routines
@
text
@d22 1
a22 1
#  $Revision: 1.26 $
d79 3
a81 3
    bind $w.l <Button-1> "handle_select %W %y; mged_help %W $w.u $screen"
    bind $w.l <Button-2> "handle_select %W %y; mged_help %W $w.u $screen"
    bind $w.l <Return> "mged_help %W $w.u $screen"
@


1.26
log
@*- use dm_insert_char_flag as an array indexed by the
	GUI's text widget (i.e. .$id.t)
@
text
@d22 1
a22 1
#  $Revision: 1.25 $
a43 137
# Support routines: MGED dialog boxes
#------------------------------------------------------------------------------
# "mged_dialog" and "mged_input_dialog" are based off of the "tk_dialog" that
# comes with Tk 4.0.
#==============================================================================

# mged_dialog
# Much like tk_dialog, but doesn't perform a grab.
# Makes a dialog window with the given title, text, bitmap, and buttons.

proc mged_dialog { w screen title text bitmap default args } {
    global button$w

    toplevel $w -screen $screen
    wm title $w $title
    wm iconname $w Dialog
    frame $w.top -relief raised -bd 1
    pack $w.top -side top -fill both
    frame $w.bot -relief raised -bd 1
    pack $w.bot -side bottom -fill both

    message $w.top.msg -text $text -width 12i
    pack $w.top.msg -side right -expand yes -fill both -padx 2m -pady 2m
    if { $bitmap != "" } {
	label $w.top.bitmap -bitmap $bitmap
	pack $w.top.bitmap -side left -padx 2m -pady 2m
    }

    set i 0
    foreach but $args {
	button $w.bot.button$i -text $but -command "set button$w $i"
	if { $i == $default } {
	    frame $w.bot.default -relief sunken -bd 1
	    raise $w.bot.button$i
	    pack $w.bot.default -side left -expand yes -padx 2m -pady 1m
	    pack $w.bot.button$i -in $w.bot.default -side left -padx 1m \
		    -pady 1m -ipadx 1m -ipady 1
	} else {
	    pack $w.bot.button$i -side left -expand yes \
		    -padx 2m -pady 2m -ipadx 1m -ipady 1
	}
	incr i
    }

    if { $default >= 0 } {
	bind $w <Return> "$w.bot.button$default flash ; set button$w $default"
    }

    set pxy [winfo pointerxy $w]
    set x [lindex $pxy 0]
    set y [lindex $pxy 1]
    set width [winfo reqwidth $w]
    set dx [expr $width / 2]
    set x [expr $x - $dx]
    set y [expr $y - 70]
    if {$x < 0} {
	set x 0
    }
    if {$y < 0} {
	set y 0
    }
    wm geometry $w +$x+$y

    tkwait variable button$w
    catch { destroy $w }
    return [set button$w]
}

## mged_input_dialog
##   Creates a dialog with the given title, text, and buttons, along with an
##   entry box (with possible default value) whose contents are to be returned
##   in the variable name contained in entryvar.

proc mged_input_dialog { w screen title text entryvar defaultentry default args } {
    global button$w entry$w
    upvar $entryvar entrylocal

    set entry$w $defaultentry
    
    toplevel $w -screen $screen
    wm title $w $title
    wm iconname $w Dialog
    frame $w.top -relief raised -bd 1
    pack $w.top -side top -fill both
    frame $w.mid -relief raised -bd 1
    pack $w.mid -side top -fill both
    frame $w.bot -relief raised -bd 1
    pack $w.bot -side bottom -fill both

    message $w.top.msg -text $text -width 12i
    pack $w.top.msg -side right -expand yes -fill both -padx 2m -pady 2m

    entry $w.mid.ent -relief sunken -width 16 -textvariable entry$w
    pack $w.mid.ent -side top -expand yes -fill both -padx 1m -pady 1m

    set i 0
    foreach but $args {
	button $w.bot.button$i -text $but -command "set button$w $i"
	if { $i == $default } {
	    frame $w.bot.default -relief sunken -bd 1
	    raise $w.bot.button$i
	    pack $w.bot.default -side left -expand yes -padx 2m -pady 1m
	    pack $w.bot.button$i -in $w.bot.default -side left -padx 1m \
		    -pady 1m -ipadx 1m -ipady 1
	} else {
	    pack $w.bot.button$i -side left -expand yes \
		    -padx 2m -pady 2m -ipadx 1m -ipady 1
	}
	incr i
    }

    if { $default >= 0 } {
	bind $w <Return> "$w.bot.button$default flash ; set button$w $default"
    }

    set pxy [winfo pointerxy $w]
    set x [lindex $pxy 0]
    set y [lindex $pxy 1]
    set width [winfo reqwidth $w]
    set dx [expr $width / 2]
    set x [expr $x - $dx]
    set y [expr $y - 70]
    if {$x < 0} {
	set x 0
    }
    if {$y < 0} {
	set y 0
    }
    wm geometry $w +$x+$y

    tkwait variable button$w
    set entrylocal [set entry$w]
    catch { destroy $w }
    return [set button$w]
}

#==============================================================================
d96 1
a96 1
    mged_dialog $w2 $screen Usage $msg info 0 OK
d103 1
a103 1
    if { [mged_input_dialog $w $screen Apropos \
d176 1
a176 1
	mged_dialog .$id.cool $player_screen($id) "File loaded" \
d184 1
a184 1
    set ret [mged_input_dialog .$id.new $player_screen($id) "New MGED Database" \
d189 1
a189 1
	    mged_dialog .$id.uncool $player_screen($id) "Existing Database" \
d193 1
a193 1
	    mged_dialog .$id.cool $player_screen($id) "File loaded" \
d206 1
a206 1
	mged_input_dialog .$id.prefix $player_screen($id) "Prefix" \
d230 1
a230 1
	mged_dialog .$id.uncool $player_screen($id) "Error" \
d238 1
a238 1
    mged_dialog .$id.about $player_screen($id) "About MGED..." \
d349 1
a349 1
    mged_input_dialog $w.goto $screen "Go To" "Enter filename to read:" \
d360 1
a360 1
	mged_dialog $w.gotoerror $screen "Error reading file" \
d395 1
a395 1
#	    mged_input_dialog .mgedhtmldir $screen "Need path to MGED .html files"
@


1.25
log
@*- use glob_compat_mode in ia_invoke
@
text
@d22 1
a22 1
#  $Revision: 1.24 $
a396 1
    global dm_insert_char_flag
d399 1
d424 1
a424 1
	if {!$dm_insert_char_flag} {
d428 4
a431 2
	if {$glob_compat_mode} {
	    catch { expand $cmd } globbed_cmd
a432 2
	} else {
	    set result [catch { uplevel #0 $cmd } ia_msg]
@


1.24
log
@*** empty log message ***
@
text
@d22 1
a22 1
#  $Revision: 1.23 $
d399 1
d427 7
a433 2
	catch [list db_glob $cmd] globbed_cmd
	set result [catch [list uplevel #0 $globbed_cmd] ia_msg]
@


1.23
log
@code mods to support use of color in MGED's command window
@
text
@d22 1
a22 1
#  $Revision: 1.22 $
d450 1
d453 2
a455 1
		.$id.t tag add oldcmd promptEnd insert
@


1.22
log
@mods to ia_invoke
@
text
@d22 1
a22 1
#  $Revision: 1.21 $
d215 4
a218 4
#    bind $w.l <Button-1> "doit_help %W $w.u $screen"
    bind $w.l <Button-1> "handle_select %W %y; doit_help %W $w.u $screen"
    bind $w.l <Button-2> "handle_select %W %y; doit_help %W $w.u $screen"
    bind $w.l <Return> "doit_help %W $w.u $screen"
d230 1
a230 1
proc doit_help { w1 w2 screen } {
a287 24
proc insert_text { id str } {
    ia_rtlog .$id.t $str
}

proc ia_rtlog { w str } {
    $w insert insert $str
#    $w see insert
}

proc ia_rtlog_bold { w str } {
    set boldStart [$w index insert]
    $w insert insert $str
    set boldEnd [$w index insert]
    $w tag add bold $boldStart $boldEnd
#    $w see insert
}

proc ia_print_prompt { w str } {
    ia_rtlog_bold $w $str
    $w mark set promptEnd {insert}
    $w mark gravity promptEnd left
}


d411 1
a411 1
	set cmd "doit_local $id \"$hcmd\""
d413 1
a413 1
	set cmd "doit_using_list $id \"$hcmd\""
d415 1
a415 1
	set cmd "doit_all \"$hcmd\""
d440 1
a440 1
		    ia_rtlog $w [string range $ia_msg 0 [expr $i - 1]]
d444 1
a444 1
		ia_print_prompt $w $ia_prompt
d450 1
a450 1
	    ia_rtlog $w "Error: $ia_msg\n"
d453 2
a454 1
		ia_rtlog $w $ia_msg\n
d463 1
a463 1
	ia_print_prompt $w "mged> "
@


1.21
log
@remove demand for user to supply MGED_HTML_DIR
@
text
@d22 1
a22 1
#  $Revision: 1.20 $
d194 1
a194 1
catch { source [lindex $auto_path 0]/sliders.tcl }
a328 28
proc distribute_text { w cmd str} {
    global mged_players

    set src_id [get_player_id_t $w]
    foreach id $mged_players {
	set _w .$id.t
	if [winfo exists $_w] {
	    if {$w != $_w} {
		set _promptBegin [$_w index {end - 1 l}]
		$_w mark set curr insert
		$_w mark set insert $_promptBegin

		if {$cmd != ""} {
		    ia_rtlog_bold $_w "mged:$src_id> "
		    ia_rtlog_bold $_w $cmd\n
		}

		if {$str != ""} {
		    ia_rtlog_bold $_w $str\n
		}

		$_w mark set insert curr
		$_w see insert
	    }
	}
    }
}

d421 2
d429 1
a429 1
	set cmd [concat $ia_cmd_prefix($id) $ia_more_default($id)]
d431 1
a431 1
	set cmd [concat $ia_cmd_prefix($id) [$w get promptEnd insert]]
d434 10
d447 3
a449 1
	cmd_set $id
d454 3
a456 3
	    distribute_text $w $cmd $ia_msg
	    stuff_str "\nmged:$id> $cmd\n$ia_msg"
	    hist_add $cmd
d469 1
a469 1
		set ia_cmd_prefix($id) $cmd
d480 2
a481 2
	    distribute_text $w $cmd $ia_msg
	    stuff_str "\nmged:$id> $cmd\n$ia_msg"
d484 1
a484 1
	hist_add $cmd
@


1.20
log
@*** empty log message ***
@
text
@d22 1
a22 1
#  $Revision: 1.19 $
a191 6
}

while { [file exists $mged_html_dir/index.html]==0 } {
    mged_input_dialog .mgeddir $env(DISPLAY) "MGED_HTML_DIR environment variable not set" \
	    "Please enter the full path to the MGED HTML files:" \
	    mged_html_dir $mged_html_dir 0 OK
@


1.19
log
@*- move help stuff to help.tcl
*- other mods for new interface
@
text
@d22 1
a22 1
#  $Revision: 1.18 $
d92 15
d159 15
d379 12
a390 7
    set file_types {{{MGED Database} {.g}}}
    set ia_filename [tk_getSaveFile -parent .$id -filetypes $file_types\
	    -initialdir . -title "New MGED Database" -defaultextension ".g"]
    if {$ia_filename != ""} {
	opendb $ia_filename y
	mged_dialog .$id.cool $player_screen($id) "File loaded" \
		"Database $ia_filename successfully loaded." info 0 OK
d401 8
a408 1
	dbconcat $ia_filename /
a411 3
proc do_Keep { id } {
}

a417 3
proc do_Raytrace { id } {
}

d425 1
a425 1
	mged_dialog .$id.toobad $player_screen($id) "Error" \
a429 6
proc do_plot { id } {
}

proc do_postscript { id } {
}

d436 1
a436 1
MGED is a part of The BRL-CAD Package.\n\n\
d470 1
a470 1
	catch [list mged_glob $cmd] globbed_cmd
@


1.18
log
@corrected one-line help for viewget
@
text
@d22 1
a22 1
#  $Revision: 1.17 $
d227 2
d232 3
a234 1
    if { [string length $mged_display(keypoint)]>0 } {
d236 1
a236 1
    } elseif { [string compare $mged_display(state) VIEWING]==0 } {
d239 7
a245 2
	set ia_illum_label($id) [format "Illuminated path:    %s    %s" \
		$mged_display(path_lhs) $mged_display(path_rhs)]
a332 3
#    if { [mged_input_dialog .$id.open $player_screen($id) "Open New File" \
#	    "Enter filename of database you wish to open:" \
#	    ia_filename "" 0 Open Cancel] == 0 } {
d336 50
a385 1
    set ia_filename [fs_dialog .$id.open .$id "./*.g"]
d387 4
a390 8
	if [file exists $ia_filename] {
	    opendb $ia_filename
	    mged_dialog .$id.cool $player_screen($id) "File loaded" \
		    "Database $ia_filename successfully loaded." info 0 OK
	} else {
	    mged_dialog .$id.toobad $player_screen($id) "Error" \
		    "No such file exists." warning 0 OK
	}
d394 6
d413 1
a413 1
proc do_On_command { id } {
d419 3
a635 240

#==============================================================================
#
# TCL versions of MGED "help", "?", and "apropos" commands
#
#==============================================================================

set help_data(?)		{{}	{summary of available mged commands}}
set help_data(?lib)		{{}	{summary of available library commands}}
set help_data(%)		{{}	{escape to interactive shell}}
set help_data(3ptarb)		{{}	{makes arb given 3 pts, 2 coord of 4th pt, and thickness}}
set help_data(adc)		{{[<a1|a2|dst|dh|dv|hv|dx|dy|dz|xyz|reset|help> value(s)]}	{control the angle/distance cursor}}
set help_data(ae)		{{[-i] azim elev [twist]}	{set view using azim, elev and twist angles}}
set help_data(aim)		{{[command_window [pathName of display window]]}	{aims command_window at pathName}}
set help_data(aip)		{{[fb]}		{advance illumination pointer or path position forward or backward}}
set help_data(analyze)		{{[arbname]}	{analyze faces of ARB}}
set help_data(apropos)		{{keyword}	{finds commands whose descriptions contain the given keyword}}
set help_data(arb)		{{name rot fb}	{make arb8, rotation + fallback}}
set help_data(arced)		{{a/b ...anim_command...}	{edit matrix or materials on combination's arc}}
set help_data(area)		{{[endpoint_tolerance]}	{calculate presented area of view}}
set help_data(attach)		{{[-d display_string] [-i init_script] [-n name]
	      [-t is_toplevel] [-W width] [-N height]
	      [-S square_size] dev_type}	{attach to a display manager}}
set help_data(attach4)		{{id screen dtype}	{open a set of 4 display windows}}
set help_data(B)		{{<objects>}	{clear screen, edit objects}}
set help_data(bev)		{{[-t] [-P#] new_obj obj1 op obj2 op obj3 op ...}	{Boolean evaluation of objects via NMG's}}
set help_data(c)		{{[-gr] comb_name [boolean_expr]}	{create or extend a combination using standard notation}}
set help_data(cat)		{{<objects>}	{list attributes (brief)}}
set help_data(center)		{{x y z}	{set view center}}
set help_data(closew)		{{id}	{close display/command window pair}}
set help_data(color)		{{low high r g b str}	{make color entry}}
set help_data(comb)		{{comb_name <operation solid>}	{create or extend combination w/booleans}}
set help_data(comb_color)	{{comb R G B}	{assign a color to a combination (like 'mater')}}
set help_data(copyeval)		{{new_solid path_to_old_solid}	{copy an 'evaluated' path solid}}
set help_data(copymat)		{{a/b c/d}	{copy matrix from one combination's arc to another's}}
set help_data(cp)		{{from to}	{copy [duplicate] object}}
set help_data(cpi)		{{from to}	{copy cylinder and position at end of original cylinder}}
set help_data(d)		{{<objects>}	{remove objects from the screen}}
set help_data(dall)		{{<objects>}	{remove all occurrences of object(s) from the screen}}
set help_data(db)		{{command}	{database manipulation routines}}
set help_data(dbconcat)		{{file [prefix]}	{concatenate 'file' onto end of present database.  Run 'dup file' first.}}
set help_data(debugbu)		{{[hex_code]}	{Show/set debugging bit vector for libbu}}
set help_data(debugdir)		{{}	{Print in-memory directory, for debugging}}
set help_data(debuglib)		{{[hex_code]}	{Show/set debugging bit vector for librt}}
set help_data(debugmem)		{{}	{Print librt memory use map}}
set help_data(debugnmg)		{{[hex code]}	{Show/set debugging bit vector for NMG}}
set help_data(decompose)	{{nmg_solid [prefix]}	{decompose nmg_solid into maximally connected shells}}
set help_data(delay)		{{sec usec}	{Delay for the specified amount of time}}
set help_data(dm)		{{set var [val]}	{Do display-manager specific command}}
set help_data(draw)		{{<objects>}	{draw objects}}
set help_data(dup)		{{file [prefix]}	{check for dup names in 'file'}}
set help_data(E)		{{ [-s] <objects>}	{evaluated edit of objects. Option 's' provides a slower, but better fidelity evaluation}}
set help_data(e)		{{<objects>}	{edit objects}}
set help_data(eac)		{{Air_code(s)}	{display all regions with given air code}}
set help_data(echo)		{{[text]}	{echo arguments back}}
set help_data(edcodes)		{{object(s)}	{edit region ident codes}}
set help_data(edmater)		{{comb(s)}	{edit combination materials}}
set help_data(edcolor)		{{}	{text edit color table}}
set help_data(edcomb)		{{combname Regionflag regionid air los [GIFTmater]}	{edit combination record info}}
set help_data(edgedir)		{{[delta_x delta_y delta_z]|[rot fb]}	{define direction of ARB edge being moved}}
set help_data(erase)		{{<objects>}	{remove objects from the screen}}
set help_data(erase_all)	{{<objects>}	{remove all occurrences of object(s) from the screen}}
set help_data(ev)		{{[-dnqstuvwT] [-P #] <objects>}	{evaluate objects via NMG tessellation}}
set help_data(eqn)		{{A B C}	{planar equation coefficients}}
set help_data(exit)		{{}	{exit}}
set help_data(extrude)		{{#### distance}	{extrude dist from face}}
set help_data(expand)		{{wildcard expression}	{expands wildcard expression}}
set help_data(eye_pt)		{{mx my mz}	{set eye point to given model coordinates (in mm)}}
set help_data(facedef)		{{####}	{define new face for an arb}}
set help_data(facetize)		{{[-tT] [-P#] new_obj old_obj(s)}	{convert objects to faceted NMG objects at current tol}}
set help_data(find)		{{<objects>}	{find all references to objects}}
set help_data(fix)		{{}	{fix display after hardware error}}
set help_data(fracture)		{{NMGsolid [prefix]}	{fracture an NMG solid into many NMG solids, each containing one face\n}}
set help_data(g)		{{groupname <objects>}	{group objects}}
set help_data(getknob)		{{knobname}	{Gets the current setting of the given knob}}
set help_data(output_hook)	{{output_hook_name}	{All output is sent to the Tcl procedure \"output_hook_name\"}}
set help_data(help)		{{[commands]}	{give usage message for given commands}}
set help_data(helplib)		{{[library commands]}	{give usage message for given library commands}}
set help_data(history)		{{[-delays]}	{list command history}}
set help_data(hist_prev)	{{}	{Returns previous command in history}}
set help_data(hist_next)	{{}	{Returns next command in history}}
set help_data(hist_add)		{{[command]}	{Adds command to the history (without executing it)}}
set help_data(i)		{{obj combination [operation]}	{add instance of obj to comb}}
set help_data(idents)		{{file object(s)}	{make ascii summary of region idents}}
set help_data(ill)		{{name}	{illuminate object}}
set help_data(in)		{{[-f] [-s] parameters...}	{keyboard entry of solids.  -f for no drawing, -s to enter solid edit}}
set help_data(inside)		{{}	{finds inside solid per specified thicknesses}}
set help_data(item)		{{region item [air [GIFTmater [los]]]}	{set region ident codes}}
set help_data(jcs)		{{id}	{join collaborative session}}
set help_data(joint)		{{command [options]}	{articulation/animation commands}}
set help_data(journal)		{{[-d] fileName}	{record all commands and timings to journal}}
set help_data(keep)		{{keep_file object(s)}	{save named objects in specified file}}
set help_data(keypoint)		{{[x y z | reset]}	{set/see center of editing transformations}}
set help_data(kill)		{{[-f] <objects>}	{delete object[s] from file}}
set help_data(killall)		{{<objects>}	{kill object[s] and all references}}
set help_data(killtree)		{{<object>}	{kill complete tree[s] - BE CAREFUL}}
set help_data(knob)		{{[-e -i -v] [id [val]]}	{emulate knob twist}}
set help_data(l)		{{<objects>}	{list attributes (verbose)}}
set help_data(L)		{{1|0 xpos ypos}	{handle a left mouse event}}
set help_data(labelvert)	{{object[s]}	{label vertices of wireframes of objects}}
set help_data(listeval)		{{}	{lists 'evaluated' path solids}}
set help_data(load_dv)		{{}	{Initializes the view matrices}}
set help_data(loadtk)		{{[DISPLAY]}	{Initializes Tk window library}}
set help_data(lookat)		{{x y z}	{Adjust view to look at given coordinates}}
set help_data(ls)		{{}	{table of contents}}
set help_data(M)		{{1|0 xpos ypos}	{handle a middle mouse event}}
set help_data(make)		{{name <arb8|sph|ellg|tor|tgc|rpc|rhc|epa|ehy|eto|part|grip|half|nmg|pipe>}	{create a primitive}}
set help_data(make_bb)		{{new_rpp_name obj1_or_path1 [list of objects or paths ...]}	{make a bounding box solid enclosing specified objects/paths}}
set help_data(mater)		{{comb [material]}	{assign/delete material to combination}}
set help_data(matpick)		{{# or a/b}	{select arc which has matrix to be edited, in O_PATH state}}
set help_data(memprint)		{{}	{print memory maps}}
set help_data(mirface)		{{#### axis}	{mirror an ARB face}}
set help_data(mirror)		{{old new axis}	{mirror solid or combination around axis}}
set help_data(model2view)	{{mx my mz}	{convert point in model coords (mm) to view coords}}
set help_data(mv)		{{old new}	{rename object}}
set help_data(mvall)		{{oldname newname}	{rename object everywhere}}
set help_data(nirt)		{{}	{trace a single ray from current view}}
set help_data(nmg_simplify)	{{[arb|tgc|ell|poly] new_solid nmg_solid}	{simplify nmg_solid, if possible}}
set help_data(oed)		{{path_lhs path_rhs}	{Go from view to object_edit of path_lhs/path_rhs}}
set help_data(opendb)		{{database.g}	{Close current .g file, and open new .g file}}
set help_data(openw)		{{[-c b|c|g] [-d display string] [-gd graphics display string] [-gt graphics type] [-id name] [-h] [-j] [-s]}	{open display/command window pair}}
set help_data(orientation)	{{x y z w}	{Set view direction from quaternion}}
set help_data(orot)		{{[-i] xdeg ydeg zdeg}	{rotate object being edited}}
set help_data(oscale)		{{factor}	{scale object by factor}}
set help_data(overlay)		{{file.plot [name]}	{Read UNIX-Plot as named overlay}}
set help_data(p)		{{dx [dy dz]}	{set parameters}}
set help_data(paths)		{{pattern}	{lists all paths matching input path}}
set help_data(pathlist)		{{name(s)}	{list all paths from name(s) to leaves}}
set help_data(pcs)		{{}	{print collaborative participants}}
set help_data(pmp)		{{}	{print mged players}}
set help_data(permute)		{{tuple}	{permute vertices of an ARB}}
set help_data(plot)		{{[-float] [-zclip] [-2d] [-grid] [out_file] [|filter]}	{make UNIX-plot of view}}
set help_data(pl)		{{[-float] [-zclip] [-2d] [-grid] [out_file] [|filter]}	{Experimental - uses dm-plot:make UNIX-plot of view}}
set help_data(polybinout)	{{file}	{store vlist polygons into polygon file (experimental)}}
set help_data(pov)		{{args}	{experimental:  set point-of-view}}
set help_data(prcolor)		{{}	{print color&material table}}
set help_data(prefix)		{{new_prefix object(s)}	{prefix each occurrence of object name(s)}}
set help_data(preview)		{{[-v] [-d sec_delay] [-D start frame] [-K last frame] rt_script_file}	{preview new style RT animation script}}
set help_data(press)		{{button_label}	{emulate button press}}
set help_data(ps)		{{[-f font] [-t title] [-c creator] [-s size in inches] [-l linewidth] file}	{creates a postscript file of the current view}}
set help_data(push)		{{object[s]}	{pushes object's path transformations to solids}}
set help_data(putmat)		{{a/b {I | m0 m1 ... m16}}	{replace matrix on combination's arc}}
set help_data(q)		{{}	{quit}}
set help_data(qcs)		{{id}	{quit collaborative session}}
set help_data(quit)		{{}	{quit}}
set help_data(qorot)		{{x y z dx dy dz theta}	{rotate object being edited about specified vector}}
set help_data(qvrot)		{{dx dy dz theta}	{set view from direction vector and twist angle}}
set help_data(r)		{{region <operation solid>}	{create or extend a Region combination}}
set help_data(R)		{{1|0 xpos ypos}	{handle a right mouse event}}
set help_data(rcodes)		{{filename}	{read region ident codes from filename}}
set help_data(red)		{{object}	{edit a group or region using a text editor}}
set help_data(refresh)		{{}	{send new control list}}
set help_data(regdebug)		{{[number]}	{toggle display manager debugging or set debug level}}
set help_data(regdef)		{{item [air [los [GIFTmaterial]]]}	{change next region default codes}}
set help_data(regions)		{{file object(s)}	{make ascii summary of regions}}
set help_data(release)		{{[name]}	{release display processor}}
set help_data(release4)		{{id}	{release the display manager window opened with attach4}}
set help_data(rfarb)		{{}	{makes arb given point, 2 coord of 3 pts, rot, fb, thickness}}
set help_data(rm)		{{comb <members>}	{remove members from comb}}
set help_data(rmater)		{{filename}	{read combination materials from filename}}
set help_data(rmats)		{{file}	{load view(s) from 'savekey' file}}
set help_data(rotobj)		{{[-i] xdeg ydeg zdeg}	{rotate object being edited}}
set help_data(rrt)		{{prog [options]}	{invoke prog with view}}
set help_data(rt)		{{[options]}	{do raytrace of view}}
set help_data(rtcheck)		{{[options]}	{check for overlaps in current view}}
set help_data(savekey)		{{file [time]}	{save keyframe in file (experimental)}}
set help_data(saveview)		{{file [args]}	{save view in file for RT}}
set help_data(showmats)		{{path}	{show xform matrices along path}}
set help_data(sed)		{{<path>}	{solid-edit named solid}}
set help_data(setview)		{{x y z}	{set the view given angles x, y, and z in degrees}}
set help_data(shells)		{{nmg_model}	{breaks model into seperate shells}}
set help_data(shader)		{{comb material [arg(s)]}	{assign materials (like 'mater')}}
set help_data(size)		{{size}	{set view size}}
set help_data(sliders)		{{[on|off]}	{turns the sliders on or off, or reads current state}}
set help_data(solids)		{{file object(s)}	{make ascii summary of solid parameters}}
set help_data(solids_on_ray)	{{h v}	{List all displayed solids along a ray}}
set help_data(status)		{{}	{get view status}}
set help_data(summary)		{{[s r g]}	{count/list solid/reg/groups}}
set help_data(sv)		{{x y [z]}	{Move view center to (x, y, z)}}
set help_data(svb)		{{}	{set view reference base}}
set help_data(sync)		{{}	{forces UNIX sync}}
set help_data(t)		{{}	{table of contents}}
set help_data(ted)		{{}	{text edit a solid's parameters}}
set help_data(tie)		{{pathName1 pathName2}	{tie display manager pathName1 to display manager pathName2}}
set help_data(title)		{{[string]}	{print or change the title}}
set help_data(tol)		{{[abs #] [rel #] [norm #] [dist #] [perp #]}	{show/set tessellation and calculation tolerances}}
set help_data(tops)		{{}	{find all top level objects}}
set help_data(track)		{{<parameters>}	{adds tracks to database}}
set help_data(tran)		{{[-i] x y [z]}	{absolute translate using view coordinates}}
set help_data(translate)	{{x y z}	{trans object to x,y, z}}
set help_data(tree)		{{object(s)}	{print out a tree of all members of an object}}
set help_data(units)		{{[mm|cm|m|in|ft|...]}	{change units}}
set help_data(untie)		{{pathName}	{untie display manager pathName}}
set help_data(mged_update)	{{}	{handle outstanding events and refresh}}
set help_data(vars)		{{[var=opt]}	{assign/display mged variables}}
set help_data(vdraw)		{{write|insert|delete|read|length|show [args]}	{Expermental drawing (cnuzman)}}
set help_data(viewget)		{{center|size|eye|ypr|quat|aet}	{Experimental - return high-precision view parameters.}}
set help_data(viewset)		{{center|eye|size|ypr|quat|aet}	{Experimental - set several view parameters at once.}}
set help_data(view2model)	{{mx my mz}	{convert point in view coords to model coords (mm)}}
set help_data(vrmgr)		{{host {master|slave|overview}}	{link with Virtual Reality manager}}
set help_data(vrot)		{{xdeg ydeg zdeg}	{rotate viewpoint}}
set help_data(vrot_center)	{{v|m x y z}	{set center point of viewpoint rotation, in model or view coords}}
set help_data(wcodes)		{{filename object(s)}	{write region ident codes to filename}}
set help_data(whatid)		{{region_name}	{display ident number for region}}
set help_data(whichair)		{{air_codes(s)}	{lists all regions with given air code}}
set help_data(whichid)		{{ident(s)}	{lists all regions with given ident code}}
set help_data(which_shader)	{{Shader(s)}	{lists all combinations using the given shaders}}
set help_data(who)		{{[r(eal)|p(hony)|b(oth)]}	{list the top-level objects currently being displayed}}
set help_data(winset)		{{pathname}	{sets the current display manager to pathname}}
set help_data(wmater)		{{filename comb(s)}	{write combination materials to filename}}
set help_data(x)		{{lvl}	{print solid table & vector list}}
set help_data(xpush)		{{object}	{Experimental Push Command}}
set help_data(Z)		{{}	{zap all objects off screen}}
set help_data(zoom)		{{scale_factor}	{zoom view in or out}}

proc help {args}	{
	global help_data

	if {[llength $args] > 0} {
                return [help_comm help_data $args]
        } else {
                return [help_comm help_data]
        }
}

proc ? {} {
	global help_data

	return [?_comm help_data 15 5]
}

proc apropos key {
	global help_data

	return [apropos_comm help_data $key]
}




@


1.17
log
@removed help for "tab" command.
@
text
@d22 1
a22 1
#  $Revision: 1.16 $
d772 1
a772 1
set help_data(viewget)		{{center|size|eye|ypr|quat}	{Experimental - return high-precision view parameters.}}
@


1.16
log
@Changes by Bparker.
@
text
@d22 1
a22 1
#  $Revision: 1.15 $
a757 1
set help_data(tab)		{{object[s]}	{tabulates objects as stored in database}}
@


1.15
log
@*** empty log message ***
@
text
@d22 1
a22 1
#  $Revision: 1.14 $
d161 1
a161 1
    set mged_html_dir [lindex $auto_path 0]/../html/mged
d224 1
a224 1
proc ia_changestate args {
d226 1
d233 1
a233 2
#	set ia_illum_label($id) "No objects illuminated"
	set ia_illum_label($id) $mged_display($id,fps)
d256 1
a256 1
    ia_rtlog .ia$id.t $str
d287 1
a287 1
	set _w .ia$id.t
d301 1
a301 1
	set _w .ia$id.t
a306 2
		ia_rtlog_bold $_w "mged:$src_id> "
		ia_rtlog_bold $_w $cmd\n
d308 5
d324 1
a324 1
#    if { [mged_input_dialog .ia$id.open $player_screen($id) "Open New File" \
d330 1
a330 1
    set ia_filename [fs_dialog .ia$id.open .ia$id "./*.g"]
d334 1
a334 1
	    mged_dialog .ia$id.cool $player_screen($id) "File loaded" \
d337 1
a337 1
	    mged_dialog .ia$id.toobad $player_screen($id) "Error" \
d346 1
a346 1
    mged_dialog .ia$id.about $player_screen($id) "About MGED..." \
d359 1
a359 1
    ia_help .ia$id $player_screen($id) [concat [?]]
d696 1
a696 1
set help_data(openw)		{{[-c] [-j] id screen dtype [dscreen]}	{open display/command window pair}}
d713 1
a713 1
set help_data(preview)		{{[-v] [-d sec_delay] rt_script_file}	{preview new style RT animation script}}
d728 1
a728 1
set help_data(regdebug)		{{}	{toggle register print}}
@


1.14
log
@*** empty log message ***
@
text
@d22 1
a22 1
#  $Revision: 1.13 $
d276 5
@


1.13
log
@*- add a few elements to help_data
*- use set of common routines within help, ? and apropos
@
text
@d22 1
a22 1
#  $Revision: 1.12 $
d170 1
a170 1
catch { source [lindex $auto_path 0]/new_sliders.tcl }
@


1.12
log
@*- added procs ? and apropos
@
text
@d22 1
a22 1
#  $Revision: 1.11 $
a169 2
#catch { source [lindex $auto_path 0]/sliders.tcl }
# The new_sliders are not quite ready ---- need to test
a170 5
#trace variable mged_display(state)    w ia_changestate
#trace variable mged_display(path_lhs) w ia_changestate
#trace variable mged_display(path_rhs) w ia_changestate
#trace variable mged_display(keypoint) w ia_changestate
#trace variable mged_display(adc)      w ia_changestate
d362 1
d571 1
a571 1
# TCL version of MGED "help" command
d575 2
a576 1
set help_data(?)		{{}	{summary of available commands}}
d591 1
d597 1
d645 1
d656 1
d688 1
d696 2
d711 1
d724 1
d753 1
a753 1
set help_data(title)		{{string}	{change the title}}
d787 5
a791 14
	if {[llength $args] > 0}	{
		set cmd [lindex $args 0]
		if [info exists help_data($cmd)] {
			return "Usage: $cmd [lindex $help_data($cmd) 0]\n\t([lindex $help_data($cmd) 1])"
		} else {
			return "Command not found: $cmd"
		}
	} else {
		foreach cmd [lsort [array names help_data]] {
			append info "$cmd [lindex $help_data($cmd) 0]\n\t[lindex $help_data($cmd) 1]\n"
		}

		return $info
	}
d795 1
a795 1
    global help_data
d797 1
a797 9
    set i 1
    foreach cmd [lsort [array names help_data]] {
	append info [format "%-16s" $cmd]
	if { ![expr $i % 4] } {
	    append info "\n"
	}
	incr i
    }
    return $info
d801 1
a801 12
    global help_data

    set info ""
    foreach cmd [lsort [array names help_data]] {
	if {[string first $key $cmd] != -1} {
	    append info "$cmd "
	} elseif {[string first $key [lindex $help_data($cmd) 0]] != -1} {
	    append info "$cmd "
	} elseif {[string first $key [lindex $help_data($cmd) 1]] != -1} {
	    append info "$cmd "
	}
    }
d803 1
a803 1
    return $info
@


1.11
log
@*- modify help proc to use return instead of puts
*- mods to a few of the help_data elements
@
text
@d22 1
a22 1
#  $Revision: 1.10 $
d797 31
@


1.10
log
@added tcl version of mged "help" command
@
text
@d22 1
a22 1
#  $Revision: 1.9 $
d593 3
a595 1
set help_data(attach)		{{[-d display_string] [-i init_script] [-n name]\n\t\t[-t is_toplevel]\n[-W width] [-N height]\n\t\t[-S square_size] dev_type}	{attach to a display manager}}
d707 1
a707 1
set help_data(putmat)		{{a/b \{I | m0 m1 ... m16\}}	{replace matrix on combination's arc}}
d764 1
a764 1
set help_data(vrmgr)		{{host \{master|slave|overview\}}	{link with Virtual Reality manager}}
d786 1
a786 1
			puts "Usage: $cmd [lindex $help_data($cmd) 0]\n\t([lindex $help_data($cmd) 1])"
d788 1
a788 1
			puts "Command not found: $cmd"
d792 1
a792 1
			puts "$cmd [lindex $help_data($cmd) 0]\n\t[lindex $help_data($cmd) 1]"
d794 2
@


1.9
log
@*** empty log message ***
@
text
@d22 1
a22 1
#  $Revision: 1.8 $
d574 224
@


1.8
log
@modified for auto loading
@
text
@d22 1
a22 1
#  $Revision: 1.7 $
d26 1
a26 1
#             Generalized the code to accommodate multiple instances of the
d35 1
d44 1
a44 1
# PHASE 0: Support routines: MGED dialog boxes
d151 1
a151 1
# PHASE 0.5: Loading MGED support routines from other files:
d170 8
a177 6
catch { source [lindex $auto_path 0]/sliders.tcl }
trace variable mged_display(state)    w ia_changestate
trace variable mged_display(path_lhs) w ia_changestate
trace variable mged_display(path_rhs) w ia_changestate
trace variable mged_display(keypoint) w ia_changestate
trace variable mged_display(adc)      w ia_changestate
d198 2
a199 1
    bind $w.l <Double-Button-1> "doit_help %W $w.u $screen"
d234 7
a240 2
    if { [string compare $mged_display(state) VIEWING]==0 } {
	set ia_illum_label "No objects illuminated"
d242 1
a242 1
	set ia_illum_label [format "Illuminated path:    %s    %s" \
a244 11
    
#    if { [string length $mged_display(adc)]>0 } {
#	set ia_illum_label $mged_display(adc)
#    } elseif { [string length $mged_display(keypoint)]>0 } {
#	set ia_illum_label $mged_display(keypoint)
#    } elseif { [string compare $mged_display(state) VIEWING]==0 } {
#	set ia_illum_label "No objects illuminated"
#    } else {
#	set ia_illum_label [format "Illuminated path:    %s    %s" \
#		$mged_display(path_lhs) $mged_display(path_rhs)]
#    }
d286 1
a286 2
    global player_count
    global player_ids
d288 2
a289 2
    for { set j 0 } { $j < $player_count } { incr j } {
	set _w .ia$player_ids($j).t
d291 1
a291 1
	    return $player_ids($j)
d299 1
a299 6
    global player_count
    global player_ids

    set id [get_player_id_t $w]
    for { set j 0 } { $j < $player_count } { incr j } {
	set _w .ia$player_ids($j).t
d301 3
d309 1
a309 1
		ia_rtlog_bold $_w "mged:$id> "
d323 3
d329 2
a330 3
    if { [mged_input_dialog .ia$id.open $player_screen($id) "Open New File" \
	    "Enter filename of database you wish to open:" \
	    ia_filename "" 0 Open Cancel] == 0 } {
d380 8
d424 1
a424 1
# PHASE 5: HTML support
d496 5
a500 1
	set new_url [file dirname $ia_url(current)]/$href
a504 1
    
d576 1
a576 219
# Spit out message about the openw command
#==============================================================================
#puts "\nNote: use the openw command to open mged interface windows"
#puts "Usage: openw id host:0\n"

set player_count 0
proc openw { id screen } {
    global ia_filename
    global ia_cmd_prefix
    global ia_more_default
    global output_as_return
    global faceplate
    global ia_font
    global player_ids
    global player_count
    global player_screen

#==============================================================================
# PHASE 1: Creation of main window
#==============================================================================

catch { destroy .ia$id }
	
toplevel .ia$id -screen $screen
wm title .ia$id "MGED Interaction Window"

set player_ids($player_count) $id
set player_screen($id) $screen
incr player_count
    
#==============================================================================
# PHASE 2: Construction of menu bar
#==============================================================================

frame .ia$id.m -relief raised -bd 1
pack .ia$id.m -side top -fill x

menubutton .ia$id.m.file -text "File" -menu .ia$id.m.file.m -underline 0
menu .ia$id.m.file.m
.ia$id.m.file.m add command -label "Open" -underline 0 -command "do_Open $id"

.ia$id.m.file.m add command -label "Quit" -command quit -underline 0

menubutton .ia$id.m.tools -text "Tools" -menu .ia$id.m.tools.m -underline 0
menu .ia$id.m.tools.m
.ia$id.m.tools.m add command -label "Place new solid" -underline 10 -command "solcreate $id"
.ia$id.m.tools.m add command -label "Place new instance" -underline 10 -command "icreate $id"
.ia$id.m.tools.m add command -label "Solid Click" -underline 6 -command "init_solclick $id"

menubutton .ia$id.m.help -text "Help" -menu .ia$id.m.help.m -underline 0
menu .ia$id.m.help.m
.ia$id.m.help.m add command -label "About MGED" -underline 6 -command "do_About_MGED $id"
.ia$id.m.help.m add command -label "On command..." -underline 0 \
	-command "do_On_command $id"
.ia$id.m.help.m add command -label "Apropos" -underline 0 -command "ia_apropos .ia$id $screen"
.ia$id.m.help.m add command -label "MGED Manual" -underline 0 -command "ia_man .ia$id $screen"

pack .ia$id.m.file .ia$id.m.tools -side left
pack .ia$id.m.help -side right

#==============================================================================
# PHASE 3: Bottom-row display
#==============================================================================

frame .ia$id.dpy
pack .ia$id.dpy -side bottom -anchor w -fill x

label .ia$id.dpy.cent -text "Center: " -anchor w
label .ia$id.dpy.centvar -textvar mged_display(center) -anchor w
label .ia$id.dpy.size -text "Size: " -anchor w
label .ia$id.dpy.sizevar -textvar mged_display(size) -anchor w
label .ia$id.dpy.unitsvar -textvar mged_display(units) -anchor w
label .ia$id.dpy.azim -text "Azim: " -anchor w
label .ia$id.dpy.azimvar -textvar mged_display(azimuth) -anchor w
label .ia$id.dpy.elev -text "Elev: " -anchor w
label .ia$id.dpy.elevvar -textvar mged_display(elevation) -anchor w
label .ia$id.dpy.twist -text "Twist: " -anchor w
label .ia$id.dpy.twistvar -textvar mged_display(twist) -anchor w

pack .ia$id.dpy.cent .ia$id.dpy.cent .ia$id.dpy.centvar .ia$id.dpy.size .ia$id.dpy.sizevar \
	.ia$id.dpy.unitsvar -side left -anchor w

pack .ia$id.dpy.twistvar .ia$id.dpy.twist .ia$id.dpy.elevvar .ia$id.dpy.elev \
	.ia$id.dpy.azimvar .ia$id.dpy.azim -side right -anchor w

frame .ia$id.illum
pack .ia$id.illum -side bottom -before .ia$id.dpy -anchor w -fill x

ia_changestate

label .ia$id.illum.label -textvar ia_illum_label
pack .ia$id.illum.label -side left -anchor w

#==============================================================================
# PHASE 4: Text widget for interaction
#==============================================================================

text .ia$id.t -relief sunken -bd 2 -yscrollcommand ".ia$id.s set" -setgrid true
scrollbar .ia$id.s -relief flat -command ".ia$id.t yview"
pack .ia$id.s -side right -fill y
pack .ia$id.t -side top -fill both -expand yes

bind .ia$id.t <Return> {
    %W mark set insert {end - 1c};
    %W insert insert \n;
    ia_invoke %W;
    break;
}

bind .ia$id.t <Delete> {
    catch {%W tag remove sel sel.first promptEnd}
    if {[%W tag nextrange sel 1.0 end] == ""} {
	if [%W compare insert < promptEnd] {
	    break
	}
    }
}

bind .ia$id.t <BackSpace> {
    catch {%W tag remove sel sel.first promptEnd}
    if {[%W tag nextrange sel 1.0 end] == ""} {
	if [%W compare insert <= promptEnd] {
	    break
	}
    }
}

bind .ia$id.t <Control-a> {
    %W mark set insert promptEnd
    break
}

bind .ia$id.t <Control-u> {
    %W delete promptEnd {promptEnd lineend}
    %W mark set insert promptEnd
}

bind .ia$id.t <Control-p> {
    %W delete promptEnd {promptEnd lineend}
    %W mark set insert promptEnd
    set id [get_player_id_t %W]
    cmd_set $id
    set result [catch hist_prev msg]
    if {$result==0} {
	%W insert insert [string range $msg 0 \
		[expr [string length $msg]-2]]
    }
    break
}

bind .ia$id.t <Control-n> {
    %W delete promptEnd {promptEnd lineend}
    %W mark set insert promptEnd
    set id [get_player_id_t %W]
    cmd_set $id
    set result [catch hist_next msg]
    if {$result==0} {
	%W insert insert [string range $msg 0 \
		[expr [string length $msg]-2]]
    }
    break
}

bind .ia$id.t <Control-c> {
    %W mark set insert {end - 1c};
    %W insert insert \n;
    ia_print_prompt %W "mged> "
    %W see insert
    set id [get_player_id_t %W]
    set ia_cmd_prefix($id) ""
    set ia_more_default($id) ""
}

bind .ia$id.t <Control-d> {
    if [%W compare insert < promptEnd] {
	break
    }
}

bind .ia$id.t <Control-k> {
    if [%W compare insert < promptEnd] {
	break
    }
}

bind .ia$id.t <Control-t> {
    if [%W compare insert < promptEnd] {
	break
    }
}

bind .ia$id.t <Meta-d> {
    if [%W compare insert < promptEnd] {
	break
    }
}

bind .ia$id.t <Meta-BackSpace> {
    if [%W compare insert <= promptEnd] {
	break
    }
}

bind .ia$id.t <Control-h> {
    if [%W compare insert <= promptEnd] {
	break
    }
}

set ia_cmd_prefix($id) ""
set ia_more_default($id) ""
ia_print_prompt .ia$id.t "mged> "

.ia$id.t tag configure bold -font -*-Courier-Bold-R-Normal-*-120-*-*-*-*-*-*
set ia_font -*-Courier-Medium-R-Normal-*-120-*-*-*-*-*-*
.ia$id.t configure -font $ia_font

#==============================================================================
# PHASE 5: Creation of other auxilary windows
a577 4

mmenu_init $id
cmd_init $id .ia$id.t
}
@


1.7
log
@ generalized to allow multiple instances
@
text
@d22 1
a22 1
#  $Revision: 1.10 $
a41 2
wm withdraw .

a156 13

if [info exists env(MGED_LIBRARY)] {
    set mged_library $env(MGED_LIBRARY)
} else {
    set mged_library "/"
}

while { [file exists $mged_library/mged2.tcl]==0 } {
    mged_input_dialog .mgeddir $env(DISPLAY) "MGED_LIBRARY environment variable not set" \
	    "Please enter the full path to the MGED .tcl files:" \
	    mged_library $mged_library 0 OK
}

d160 1
a160 1
    set mged_html_dir "/"
d169 1
a169 9
catch { source $mged_library/vmath.tcl }
catch { source $mged_library/html_library.tcl }
catch { source $mged_library/menu2.tcl }
catch { source $mged_library/editobj2.tcl }
catch { source $mged_library/sliders2.tcl }
catch { source $mged_library/solcreate2.tcl }
catch { source $mged_library/icreate2.tcl }
catch { source $mged_library/solclick2.tcl }

a248 1
auto_load tkTextInsert
a280 1

a286 1

a300 1

a439 1

d441 1
a441 1
    global mged_library mged_html_dir ia_url message
d468 7
a474 7
    if { [info exists ia_url]==0 } {
	while { [file exists $mged_html_dir/index.html]==0 } {
	    mged_input_dialog .mgedhtmldir $screen "Need path to MGED .html files"
		    "Please enter the full path to the MGED .html files:" \
		    mged_html_dir $mged_html_dir 0 OK
	}
    }
a566 2


d570 2
a571 2
puts "\nNote: use the openw command to open mged interface windows"
puts "Usage: openw id host:0\n"
a575 2
    global mged_library
    global mged_display
a779 3
#set output_as_return 1
#set faceplate 0
# output_hook ia_rtlog
d790 2
a791 2
cmd_init $id
}@


1.6
log
@Fixed minor bug, with default entry not being put in right variable.
@
text
@d22 12
a33 1
#  $Revision: 1.5 $
d39 1
a39 1
	loadtk
d42 2
d55 1
a55 1
proc mged_dialog { w title text bitmap default args } {
d58 1
a58 1
    toplevel $w
d68 1
a68 1
    if { $bitmap != "" } then {
d89 1
a89 1
    if { $default >= 0 } then {
d103 1
a103 1
proc mged_input_dialog { w title text entryvar defaultentry default args } {
d109 1
a109 1
    toplevel $w
d141 1
a141 1
    if { $default >= 0 } then {
d160 1
a160 1
if [info exists env(MGED_LIBRARY)] then {
d163 7
a169 6
	if [file exists ../mged/mged.tcl] then {
		set mged_library ../mged
	} else {
		# For now, take MGED macros from /usr/brlcad/tcl/.
		set mged_library $tcl_library
	}
d172 1
a172 1
if [info exists env(MGED_HTML_DIR)] then {
d175 1
a175 5
	if [file exists ../html/mged/index.html] then {
		set mged_html_dir ../html/mged
	} else {
		set mged_html_dir /usr/brlcad/html
	}
d178 4
a181 4
while { [file exists $mged_library/vmath.tcl]==0 } {
    mged_input_dialog .mgeddir "Need path to MGED .tcl files" \
	    "Please enter the full path to the MGED .tcl files:" \
	    mged_library $mged_library 0 OK
a184 5
catch { source $mged_library/menu.tcl }
catch { source $mged_library/editobj.tcl }
update
catch { source $mged_library/sliders.tcl }
update
d186 6
d193 5
a197 33
#==============================================================================
# PHASE 1: Creation of main window
#==============================================================================

catch { destroy .ia }
toplevel .ia
wm title .ia "MGED Interaction Window"

#==============================================================================
# PHASE 2: Construction of menu bar
#==============================================================================

frame .ia.m -relief raised -bd 1
pack .ia.m -side top -fill x

menubutton .ia.m.file -text "File" -menu .ia.m.file.m -underline 0
menu .ia.m.file.m
.ia.m.file.m add command -label "Open" -underline 0 -command {
    if { [mged_input_dialog .ia.open "Open New File" \
	    "Enter filename of database you wish to open:" \
	    ia_filename "" 0 Open Cancel] == 0 } then {
	if [file exists $ia_filename] then {
	    opendb $ia_filename
	    mged_dialog .ia.cool "File loaded" \
		    "Database $ia_filename successfully loaded." info 0 OK
	} else {
	    mged_dialog .ia.toobad "Error" \
		    "No such file exists." warning 0 OK
	}
    }
}

.ia.m.file.m add command -label "Quit" -command quit -underline 0
d199 2
a200 41
menubutton .ia.m.tools -text "Tools" -menu .ia.m.tools.m -underline 0
menu .ia.m.tools.m
.ia.m.tools.m add command -label "Place new solid" -underline 10 -command {
    if { [info exists solc]==0 } then {
	source $mged_library/solcreate.tcl
    }
    solcreate
}
.ia.m.tools.m add command -label "Place new instance" -underline 10 -command {
    if { [info exists ic]==0 } then {
	source $mged_library/icreate.tcl
    }
    icreate
}
.ia.m.tools.m add command -label "Solid Click" -underline 6 -command {
    if { [winfo exists .metasolclick]==0 } then {
	source $mged_library/solclick.tcl
    }
}

menubutton .ia.m.help -text "Help" -menu .ia.m.help.m -underline 0
menu .ia.m.help.m
.ia.m.help.m add command -label "About MGED" -underline 6 -command {
    mged_dialog .ia_about "About MGED..." \
	    "MGED: Multi-device Geometry EDitor\n\
\n\
MGED is a part of The BRL-CAD Package.\n\n\
Developed by The U. S. Army Research Laboratory\n\
Aberdeen Proving Ground, Maryland  21005-5068  USA\n\
" \
	    {} 0 OK

    
}
.ia.m.help.m add command -label "On command..." -underline 0 \
	-command [list ia_help [?]]
.ia.m.help.m add command -label "Apropos" -underline 0 -command ia_apropos
.ia.m.help.m add command -label "MGED Manual" -underline 0 -command ia_man

pack .ia.m.file .ia.m.tools -side left
pack .ia.m.help -side right
a201 3
proc ia_help { cmds } {
    set w .ia.help

d203 1
a203 1
    toplevel $w
d210 1
a210 1
    listbox $w.l -bd 2 -yscroll "$w.s set"
d218 3
a220 6
    set doit "catch { destroy $w.u } ; \
	    catch { help \[selection get\] } msg ; \
	    mged_dialog $w.u Usage \$msg info 0 OK"
    bind $w.l <Double-Button-1> $doit
    bind $w.l <2> "tkListboxBeginSelect \%W \[\%W index \@@\%x,\%y\] ; $doit"
    bind $w.l <Return> $doit
d223 4
a226 7
proc ia_apropos { } {
    set w .ia.apropos

    catch { destroy $w }
    if { [mged_input_dialog $w Apropos \
	   "Enter keyword to search for:" keyword "" 0 OK Cancel] == 1 } then {
	return
d229 1
a229 1
    ia_help [apropos $keyword]
d232 5
a236 3
#==============================================================================
# PHASE 3: Bottom-row display
#==============================================================================
d238 2
a239 2
frame .ia.dpy
pack .ia.dpy -side bottom -anchor w -fill x
d241 5
a245 11
label .ia.dpy.cent -text "Center: " -anchor w
label .ia.dpy.centvar -textvar mged_display(center) -anchor w
label .ia.dpy.size -text "Size: " -anchor w
label .ia.dpy.sizevar -textvar mged_display(size) -anchor w
label .ia.dpy.unitsvar -textvar mged_display(units) -anchor w
label .ia.dpy.azim -text "Azim: " -anchor w
label .ia.dpy.azimvar -textvar mged_display(azimuth) -anchor w
label .ia.dpy.elev -text "Elev: " -anchor w
label .ia.dpy.elevvar -textvar mged_display(elevation) -anchor w
label .ia.dpy.twist -text "Twist: " -anchor w
label .ia.dpy.twistvar -textvar mged_display(twist) -anchor w
d247 2
a248 5
pack .ia.dpy.cent .ia.dpy.cent .ia.dpy.centvar .ia.dpy.size .ia.dpy.sizevar \
	.ia.dpy.unitsvar -side left -anchor w

pack .ia.dpy.twistvar .ia.dpy.twist .ia.dpy.elevvar .ia.dpy.elev \
	.ia.dpy.azimvar .ia.dpy.azim -side right -anchor w
a249 3
frame .ia.illum
pack .ia.illum -side bottom -before .ia.dpy -anchor w -fill x

d253 1
a253 1
    if { [string compare $mged_display(state) VIEWING]==0 } then {
d260 1
a260 1
#    if { [string length $mged_display(adc)]>0 } then {
d262 1
a262 1
#    } elseif { [string length $mged_display(keypoint)]>0 } then {
d264 1
a264 1
#    } elseif { [string compare $mged_display(state) VIEWING]==0 } then {
d272 19
a290 1
ia_changestate
d292 4
a295 2
label .ia.illum.label -textvar ia_illum_label
pack .ia.illum.label -side left -anchor w
d297 7
a303 5
trace variable mged_display(state)    w ia_changestate
trace variable mged_display(path_lhs) w ia_changestate
trace variable mged_display(path_rhs) w ia_changestate
trace variable mged_display(keypoint) w ia_changestate
trace variable mged_display(adc)      w ia_changestate
a304 3
#==============================================================================
# PHASE 4: Text widget for interaction
#==============================================================================
d306 4
a309 10
text .ia.t -relief sunken -bd 2 -yscrollcommand ".ia.s set" -setgrid true
scrollbar .ia.s -relief flat -command ".ia.t yview"
pack .ia.s -side right -fill y
pack .ia.t -side top -fill both -expand yes

bind .ia.t <Return> {
    .ia.t mark set insert {end - 1c}
    .ia.t insert insert \n
    ia_invoke
    break
d312 9
a320 5
bind .ia.t <Delete> {
    catch {.ia.t tag remove sel sel.first promptEnd}
    if {[.ia.t tag nextrange sel 1.0 end] == ""} {
	if [.ia.t compare insert < promptEnd] {
	    break
d323 2
d327 8
a334 8
bind .ia.t <BackSpace> {
    catch {.ia.t tag remove sel sel.first promptEnd}
    if {[.ia.t tag nextrange sel 1.0 end] == ""} then {
	if [.ia.t compare insert <= promptEnd] then {
	    break
	}
    }
}
d336 7
a342 4
bind .ia.t <Control-a> {
    .ia.t mark set insert promptEnd
    break
}
d344 3
a346 4
bind .ia.t <Control-u> {
    .ia.t delete promptEnd {promptEnd lineend}
    .ia.t mark set insert promptEnd
}
d348 4
a351 7
bind .ia.t <Control-p> {
    .ia.t delete promptEnd {promptEnd lineend}
    .ia.t mark set insert promptEnd
    set result [catch hist_prev msg]
    if {$result==0} then {
	.ia.t insert insert [string range $msg 0 \
		[expr [string length $msg]-2]]
a352 1
    break
d355 14
a368 7
bind .ia.t <Control-n> {
    .ia.t delete promptEnd {promptEnd lineend}
    .ia.t mark set insert promptEnd
    set result [catch hist_next msg]
    if {$result==0} then {
	.ia.t insert insert [string range $msg 0 \
		[expr [string length $msg]-2]]
a369 1
    break
d372 2
a373 5
bind .ia.t <Control-d> {
    if [.ia.t compare insert < promptEnd] {
	break
    }
}
d375 8
a382 4
bind .ia.t <Control-k> {
    if [.ia.t compare insert < promptEnd] {
	break
    }
d385 2
a386 5
bind .ia.t <Control-t> {
    if [.ia.t compare insert < promptEnd] {
	break
    }
}
d388 1
a388 4
bind .ia.t <Meta-d> {
    if [.ia.t compare insert < promptEnd] {
	break
    }
d391 3
a393 5
bind .ia.t <Meta-BackSpace> {
    if [.ia.t compare insert <= promptEnd] {
	break
    }
}
d395 1
a395 5
bind .ia.t <Control-h> {
    if [.ia.t compare insert <= promptEnd] {
	break
    }
}
d397 5
a401 11
auto_load tkTextInsert
proc tkTextInsert {w s} {
    if {$s == ""} {
	return
    }
    catch {
	if {[$w compare sel.first <= insert] && \
		[$w compare sel.last >= insert]} then {
	    $w tag remove sel sel.first promptEnd
	    $w delete sel.first sel.last
	}
a402 3
    $w insert insert $s
    $w see insert
}
d404 1
a404 8
proc ia_rtlog { str } {
    set logStart [.ia.t index insert]
    .ia.t insert insert $str
    .ia.t mark set promptEnd {insert}
    .ia.t mark gravity promptEnd left
    .ia.t tag add bold $logStart promptEnd
    .ia.t yview -pickplace insert
}
a405 4
proc ia_invoke {} {
    global ia_cmd_prefix
    
    set cmd [concat $ia_cmd_prefix [.ia.t get promptEnd insert]]
d407 15
a421 6
	set result [catch [list uplevel #0 $cmd] ia_msg]
	if {$result != 0} then {
	    if { [regexp "more arguments needed::" $ia_msg] } then {
		set ia_prompt [string range $ia_msg 23 end]
		ia_rtlog $ia_prompt
		set ia_cmd_prefix $cmd
d424 1
a424 1
	    ia_rtlog "Error: $ia_msg\n"
d427 1
a427 1
		ia_rtlog $ia_msg\n
d429 3
d433 1
d435 2
a436 2
	set ia_cmd_prefix ""
	ia_rtlog "mged> "
d438 1
a438 1
    .ia.t yview -pickplace insert
a440 6
set ia_cmd_prefix ""
ia_rtlog "mged> "
set output_as_return 1
set faceplate 0
# output_hook ia_rtlog

a444 4
.ia.t tag configure bold -font -*-Courier-Bold-R-Normal-*-120-*-*-*-*-*-*
set ia_font -*-Courier-Medium-R-Normal-*-120-*-*-*-*-*-*
.ia.t configure -font $ia_font

d448 18
d467 2
a468 1
proc ia_man { } {
d471 1
a471 1
    set w .ia.man
d473 1
a473 1
    toplevel $w
d480 1
a480 16
    button $w.f.goto -text "Go To" -command {
	mged_input_dialog .ia.man.goto "Go To" "Enter filename to read:" \
		filename $ia_url(current) 0 OK
	if { [file exists filename]!=0 } then {
	    if { [string match /* $filename] } then {
		set new_url $filename
	    } else {
		set new_url [pwd]/$filename
	    }

    	    HMlink_callback .ia.man.text $new_url
	} else {
	    mged_dialog .ia.man.gotoerror "Error reading file" \
		    "Cannot read file $filename." error 0 OK
	}
    }
d496 1
a496 1
    if { [info exists ia_url]==0 } then {
d498 1
a498 1
	    mged_input_dialog .mgedhtmldir "Need path to MGED .html files" \
d537 1
a537 1
    if {[llength $ia_url(backtrack)]<1} then {
d553 1
a553 1
    if {[string match http://* $src]} then {
d557 1
a557 1
    if {[string match /* $src]} then {
d565 1
a565 1
    if {[string first " $image " " [image names] "] >= 0} then {
d579 1
a579 1
    if {[string match *.gif $file]} then {
d594 233
@


1.5
log
@Even better idea.
@
text
@d22 1
a22 1
#  $Revision: 1.4 $
d94 1
a94 1
    set entry $defaultentry
@


1.4
log
@Improvements in library finding
@
text
@d22 1
a22 1
#  $Revision$
d153 2
a154 1
		set mged_library /usr/brlcad/tcl
@


1.3
log
@Added automatic "loadtk", if user hasn't done one yet.
Fixed bug in handling of help command's expansion of [?]
by changing f_fhelp() in cmd.c to cmd_fhelp().
@
text
@d21 2
d150 15
a164 1
    set mged_library ../mged
a526 6

if [info exists env(MGED_HTML_DIR)] then {
    set mged_html_dir $env(MGED_HTML_DIR)
} else {
    set mged_html_dir ../html/mged
}
@


1.2
log
@*** empty log message ***
@
text
@d22 6
d196 1
a196 1
    
d223 1
a223 1
	    "MGED: Multidisplay \[combinatorial solid\] Geometry EDitor\n\
d225 4
a228 2
MGED is a part of the BRL-CAD package developed at the Army\n\
Research Laboratory at Aberdeen Proving Ground, Maryland, U.S.A." \
d234 1
a234 1
	-command [list ia_help [lrange [?] 5 end]]
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
#	T M G E D . T C L
d3 2
a4 1
#	Tcl/Tk GUI (graphical user interface) for mged-tcl.
d6 8
a13 3
#	This implementation makes extensive use of the Tk toolkit.
#	It also requires special hooks in mged's cmd.c, which are compiled in
#		when the -DMGED_TCL option is present.
d15 3
a17 2
#	Author -
#		Glenn Durfee
d19 42
a60 87
#	Source -
#		The U. S. Army Ballistic Research Laboratory
#		Aberdeen Proving Ground, Maryland 21005
#
#	Copyright Notice -
#		This software is Copyright (C) 1995 by the United States Army.
#		All rights reserved.

set RCSid { "@@(#)$Header: /m/cad/tmged/RCS/tmged.tcl,v 1.13 1995/05/30 15:58:02 gdurf Exp $ (BRL)" }

mset sgi_win_size=600


#=============================================================================
# PHASE 0: Tcl Variable defaults
#=============================================================================

# "printend" is the last printed character, before whatever the user types.
# Input to MGED is defined as everything between printend and the end of line.
set printend insert

# Some slider defaults.
set sliders(exist) 0
set sliders(fov) 0

# size of dead spot on sliders
set sliders(NOISE) 128


#=============================================================================
# PHASE 1: The button menu
#-----------------------------------------------------------------------------
# The button menu has three parts -- edit options, view options, and 
#   miscellaneous options.  Ideally, we would disable those buttons that are
#   not valid at the time.
#=============================================================================

frame .edit -borderwidth 1 -relief sunken
button .edit.reject -text "Reject Edit" -command "press reject"
button .edit.accept -text "Accept Edit" -command "press accept"

frame .view -borderwidth 1 -relief sunken
button .view.top -text "Top" -command "press top"
button .view.bottom -text "Bottom" -command "press bottom"
button .view.right -text "Right" -command "press right"
button .view.left -text "Left" -command "press left"
button .view.front -text "Front" -command "press front"
button .view.rear -text "Rear" -command "press rear"
button .view.4545 -text "45, 45" -command "press 45,45"
button .view.3525 -text "35, 25" -command "press 35,25"
button .view.restore -text "Restore View" -command "press restore"
button .view.save -text "Save View" -command "press save"
button .view.reset -text "Reset View" -command "press reset"
button .view.sliders -text "Sliders" -command "sliders_create"
button .view.calibrate -text "Calibrate Sliders" -command { knob calibrate; foreach knob { aX aY aZ } { .sliders.f.k$knob set 0 } }
button .view.zero -text "Zero Sliders" -command "sliders_zero"

frame .misc -borderwidth 1 -relief sunken
button .misc.tcolor -text "Color Edit" -command "tcolor"

pack .edit .view .misc -padx 1m -pady 1m -fill x

pack .edit.reject .edit.accept -padx 1m -pady 1 -fill x
pack .view.top .view.bottom .view.right .view.left .view.front .view.rear \
	.view.4545 .view.3525 .view.restore .view.save .view.reset \
	.view.sliders .view.zero .view.calibrate -padx 1m -pady 1 -fill x
pack .misc.tcolor -padx 1m -pady 1 -fill x


#=============================================================================
# PHASE 2: Slider behavior
#-----------------------------------------------------------------------------
# When the sliders exist, pressing the "sliders" button makes them go away.
# When they don't exist, pressing the "sliders" button makes them appear.
# They are modeled after the 4D knobs (dials), right down to the -2048 to 2047
#   range established in dm-4d.c.
# Only the field-of-view slider has its value shown (0 to 120); it might be
#   confusing to see -2048 to 2047 on the others (besides, it would take up
#   more space.)
#=============================================================================

proc sliders_create { } {
	global sliders

	if { $sliders(exist) } then {
		catch { destroy .sliders }
		set sliders(exist) 0
d62 9
a70 2
		catch { destroy .sliders }
		toplevel .sliders -class Dialog
d72 47
a118 62
		frame .sliders.f -borderwidth 3
		label .sliders.f.ratelabel -text "Rate Based Sliders" -anchor c
		scale .sliders.f.kX -label "X Translate" -showvalue no \
			-from -2048 -to 2047 -orient horizontal \
			-length 400 -command "sliders_change X"
		scale .sliders.f.kY -label "Y Translate" -showvalue no \
			-from -2048 -to 2047 -orient horizontal \
			-length 400 -command "sliders_change Y"
		scale .sliders.f.kZ -label "Z Translate" -showvalue no \
			-from -2048 -to 2047 -orient horizontal \
			-length 400 -command "sliders_change Z"
		scale .sliders.f.kS -label "Zoom" -showvalue no \
			-from -2048 -to 2047 -orient horizontal -length 400 \
			-command "sliders_change S"
		scale .sliders.f.kx -label "X Rotate" -showvalue no \
			-from -2048 -to 2047 -orient horizontal -length 400 \
			-command "sliders_change x"
		scale .sliders.f.ky -label "Y Rotate" -showvalue no \
			-from -2048 -to 2047 -orient horizontal -length 400 \
			-command "sliders_change y"
		scale .sliders.f.kz -label "Z Rotate" -showvalue no \
			-from -2048 -to 2047 -orient horizontal -length 400 \
			-command "sliders_change z"
		
		label .sliders.f.abslabel -text "Absolute Sliders" -anchor c
		scale .sliders.f.kaX -label "X Translate" -showvalue no \
			-from -2048 -to 2047 -orient horizontal \
			-length 400 -command "sliders_change aX"
		scale .sliders.f.kaY -label "Y Translate" -showvalue no \
			-from -2048 -to 2047 -orient horizontal \
			-length 400 -command "sliders_change aY"
		scale .sliders.f.kaZ -label "Z Translate" -showvalue no \
			-from -2048 -to 2047 -orient horizontal \
			-length 400 -command "sliders_change aZ"
		scale .sliders.f.kaS -label "Zoom" -showvalue no \
			-from -2048 -to 2047 -orient horizontal -length 400 \
			-command "sliders_change aS"
		scale .sliders.f.kax -label "X Rotate" -showvalue no \
			-from -2048 -to 2047 -orient horizontal -length 400 \
			-command "sliders_change ax"
		scale .sliders.f.kay -label "Y Rotate" -showvalue no \
			-from -2048 -to 2047 -orient horizontal -length 400 \
			-command "sliders_change ay"
		scale .sliders.f.kaz -label "Z Rotate" -showvalue no \
			-from -2048 -to 2047 -orient horizontal -length 400 \
			-command "sliders_change az"
		scale .sliders.f.fov -label "Field of view" -showvalue yes \
			-from 0 -to 120 -orient horizontal -length 400 \
			-command sliders_fov

		pack .sliders.f -padx 1m -pady 1m
		pack .sliders.f.ratelabel -pady 4
		pack .sliders.f.kX .sliders.f.kY .sliders.f.kZ .sliders.f.kS \
		     .sliders.f.kx .sliders.f.ky .sliders.f.kz
		pack .sliders.f.abslabel -pady 4
		pack .sliders.f.kaX .sliders.f.kaY .sliders.f.kaZ \
		     .sliders.f.kaS .sliders.f.kax .sliders.f.kay \
		     .sliders.f.kaz .sliders.f.fov

		foreach knob { X Y Z S x y z aX aY aZ aS ax ay az } {
		    .sliders.f.k$knob set [expr round(2048.0*[getknob $knob])]
		}
d120 3
a122 1
		.sliders.f.fov set $sliders(fov)
d124 63
a186 1
		set sliders(exist) 1
d188 1
d190 2
d193 29
d223 12
a234 4
## sliders_irlimit
##   Because the sliders may seem too sensitive, setting them exactly to zero
##   may be hard.  This function can be used to extend the location of "zero" 
##   into "the dead zone".
d236 3
a238 2
proc sliders_irlimit { val } {
	global sliders
d240 7
a246 3
	if { [expr $val > $sliders(NOISE)] } then {
	    return [expr ($val-$sliders(NOISE))*2048/(2048-$sliders(NOISE))]
	}
d248 3
a250 3
	if { [expr $val < -$sliders(NOISE)] } then {
	    return [expr ($val+$sliders(NOISE))*2048/(2048-$sliders(NOISE))]
	}
d252 6
a257 1
	return 0
d260 2
d263 5
a267 2
## sliders_change
##   Generic slider-changing callback.
d269 1
a269 2
proc sliders_change { which val } {
	knob $which [expr [sliders_irlimit $val] / 2048.0]
d272 24
d297 2
a298 2
## sliders_fov
##   Callback for field-of-view slider.
d300 2
a301 2
proc sliders_fov { val } {
	global sliders
d303 17
a319 6
	set sliders(fov) $val
	if { [expr $val==0] } then {
		mset perspective=-1
	} else {
		mset perspective=$val
	}
d322 1
d324 2
a325 2
## sliders_zero
##   Zeroes the sliders.
d327 5
a331 2
proc sliders_zero { } {
	global sliders
d333 3
a335 7
	if { [expr $sliders(exist)!=0] } then {
		foreach knob { X Y Z S x y z aX aY aZ aS ax ay az } {
			knob $knob 0
			.sliders.f.k$knob set 0
		}
	}
}
d337 4
d342 6
a347 2
## sliders_togglerate
##   Callback for toggling the "Rate Based" togglebutton.
d349 8
a356 2
proc sliders_togglerate { } {
	global sliders
d358 5
a362 4
	if { [expr $sliders(rate_based)==0] } then {
		mset rateknobs=0
	} else {
		mset rateknobs=1
d364 1
d367 4
d372 4
a375 280
#=============================================================================
# PHASE 3: MGED Interaction
#-----------------------------------------------------------------------------
# Sets up the MGED Interaction window ".i", which has the following structure:
# At the top, a menu ".i.menu" with some Useful Functions, and a help option.
# Note that some of those functions request filenames in a rather rudimentary
#   fashion.  An honest-to-goodness file selection box would be rather nice.
# The remainder of the window is contained within a sunken frame, ".i.f".
# This frame has two parts: the text widget, ".i.f.text", which contains all
#   mged output (rt_log is hooked into outputting there, see cmd.c), as well
#   as the input from the user.
# In gui_output in cmd.c, when output is sent to ".i.f.text", the variable
#   "printend" is set to the end of the MGED output, which is also the
#   beginning of the user's input.  When the user hits return, everything 
#   from printend to the end of the line is snarfed from .i.f.text and fed 
#   to mged to process as it pleases (see gui_cmdline in cmd.c)
#=============================================================================

toplevel .i
wm title .i "MGED Interaction"

#-----------------------------------------------------------------------------
# MENUS
#-----------------------------------------------------------------------------

frame .i.menu -relief raised -borderwidth 1
menubutton .i.menu.file -text "File" -menu .i.menu.file.m -underline 0
menu .i.menu.file.m
.i.menu.file.m add command -label "Source" -command sourcefile -underline 0
.i.menu.file.m add command -label "Save History" -command savehist \
	-underline 5
.i.menu.file.m add command -label "Save Timed History" -command savethist \
	-underline 5
.i.menu.file.m add command -label "Save Full Transcript" -command savetrans \
	-underline 5
.i.menu.file.m add command -label "Quit" -command quit -underline 0

menubutton .i.menu.help -text "Help" -menu .i.menu.help.m -underline 0
menu .i.menu.help.m
.i.menu.help.m add command -label "Still under construction." -underline 0

pack .i.menu -side top -fill x
pack .i.menu.file -side left
pack .i.menu.help -side right

tk_menuBar .i.menu .i.menu.file .i.menu.help
tk_bindForTraversal .

## fsb
##   Conjures up a file "selection" box with the given properties.

proc fsb { w title caption oktext callback } {
	global filename

	catch { destroy $w }
	toplevel $w -class Dialog
	wm title $w $title

	set filename($w) ""

	frame  $w.f -relief flat
	pack   $w.f -padx 1m -pady 1m
	label  $w.f.label -text $caption
	pack   $w.f.label -side top
	entry  $w.f.entry -textvariable filename($w) -width 16 -relief sunken
	bind   $w.f.entry <Return> "$callback \$filename($w) ; destroy $w"
	pack   $w.f.entry -expand yes -fill x -side top
	button $w.f.ok -text $oktext \
		-command "$callback \$filename($w) ; destroy $w"
	button $w.f.cancel -text "Cancel" -command "destroy $w"
	pack   $w.f.ok -side left -pady 1m
	pack   $w.f.cancel -side right -pady 1m
}


## sourcefile
##   Callback for "Source File" menu item

proc sourcefile { } {
	fsb .sf "Source file" "Enter name of file to be sourced:" \
		"Source" source
}


## savetrans
##   Callback for "Save Transcript" menu item

proc savetrans { } {
	fsb .st "Save Transcript" "Enter filename to store transcript in:" \
		"Save" recordtrans
}


## recordtrans
##   Used by savetrans/fsb to record a transcript to the end of the given file

proc recordtrans { fname } {
	set f [open $fname a+]
	puts $f [.i.f.text get 1.0 end]
	close $f
}


## savehist 
##   Callback for "Save History" menu item

proc savehist { } {
	fsb .sh "Save History" "Enter filename to store history in:" \
		"Save" "history -outfile"
}


## savethist 
##   Callback for "Save Timed History" menu item

proc savethist { } {
	fsb .sh "Save Timed History" \
		"Enter filename to store timed history in:" \
		"Save" "history -delays -outfile"
}


#-----------------------------------------------------------------------------
# MGED INTERACTION WIDGET
#-----------------------------------------------------------------------------

frame .i.f -relief sunken -borderwidth 2
pack .i.f -padx 3 -pady 3

text .i.f.text -relief raised -bd 2 -yscrollcommand ".i.f.scroll set" \
	-width 80 -height 10 -wrap char
scrollbar .i.f.scroll -command ".i.f.text yview"
pack .i.f.scroll -side right -fill y
pack .i.f.text -side left

# give it some rudimentary tcsh/jove/emacs-like bindings

bind .i.f.text <Return> +execute
bind .i.f.text <Control-a> ".i.f.text mark set insert \$printend"
bind .i.f.text <Control-e> ".i.f.text mark set insert end"
bind .i.f.text <Control-d> ".i.f.text delete insert"
bind .i.f.text <Control-k> "set yankbuffer \[.i.f.text get insert \
	\"insert lineend\"\] ; .i.f.text delete insert \"insert lineend\""
bind .i.f.text <Control-y> ".i.f.text insert insert \$yankbuffer ; \
	.i.f.text yview -pickplace insert"
bind .i.f.text <Control-b> ".i.f.text mark set insert \"insert - 1 chars\""
bind .i.f.text <Control-f> ".i.f.text mark set insert \"insert + 1 chars\""
set yankbuffer ""

## execute 
##   Callback for a carriage-return in the MGED Interaction window.
##   Note that if the end of the line on which the carriage return was pressed
##     is before the end of the last prompt, the ".i.f.text get" returns
##     nothing and no command is executed.

proc execute { } {
	global printend sliders

	set commandend [.i.f.text index "insert lineend"]

	.i.f.text mark set insert end
	.i.f.text insert insert \n
	cmdline "[format "%s\n" [.i.f.text get $printend $commandend]]"
	.i.f.text yview -pickplace insert
}





#=============================================================================
# PHASE 4: tcolor -- the color editor
#-----------------------------------------------------------------------------
# Standard Tcl/Tk demo "/usr/{brl,local,contrib}/lib/tk/demos/tcolor".
# It has been assimilated (with minor changes).
# When the color of your choice has been selected, it is spat into the
#   .i.f.text MGED Interaction widget as if you had typed it there.
#=============================================================================

# colorSpace -			Color space currently being used for
#				editing.  Must be "rgb", "cmy", or "hsb".
# label1, label2, label3 -	Labels for the scales.
# red, green, blue -		Current color intensities in decimal
#				on a scale of 0-65535.
# color -			A string giving the current color value
#				in the proper form for x:
#				#RRRRGGGGBBBB
# updating -			Non-zero means that we're in the middle of
#				updating the scales to load a new color,so
#				information shouldn't be propagating back
#				from the scales to other elements of the
#				program:  this would make an infinite loop.
# command -			Holds the command that has been typed
#				into the "Command" entry.
# autoUpdate -			1 means execute the update command
#				automatically whenever the color changes.
# name -			Name for new color, typed into entry.

set colorSpace hsb
set red 65535
set green 0
set blue 0
set color #ffff00000000
set updating 0
set autoUpdate 1
set name ""
		
proc tcolor { } {
	global colorSpace red green blue color updating autoUpdate name

	catch { destroy .c }
	toplevel .c

	wm title .c "Color Editor"
	tk_bindForTraversal .c
	focus .c

# Create the menu bar at the top of the window.

	frame .c.menu -relief raised -borderwidth 2
	pack .c.menu -side top -fill x
	menubutton .c.menu.file -text "Color space" -menu .c.menu.file.m \
		-underline 0
	menu .c.menu.file.m
	.c.menu.file.m add radio -label "RGB color space" \
		-variable colorSpace -value rgb -underline 0 \
		-command {changeColorSpace rgb}
	.c.menu.file.m add radio -label "CMY color space" \
		-variable colorSpace -value cmy -underline 0 \
		-command {changeColorSpace cmy}
	.c.menu.file.m add radio -label "HSB color space" \
		-variable colorSpace -value hsb -underline 0 \
		-command {changeColorSpace hsb}
	pack .c.menu.file -side left
	tk_menuBar .c.menu .c.menu.file

# Create the command entry window at the bottom of the window, along
# with the update button.

	frame .c.bot -relief raised -borderwidth 2
	pack .c.bot -side bottom -fill x
	button .c.cancel -text "Cancel" -command "destroy .c"
	button .c.ok -text "Ok" -command ".i.f.text insert \
		insert \"\$red \$green \$blue\"; destroy .c"
	pack .c.cancel .c.ok -in .c.bot -side left -pady .1c -padx .25c \
		-expand yes -fill x -ipadx 0.25c
	
# Create the listbox that holds all of the color names in rgb.txt,
# if an rgb.txt file can be found.

	frame .c.middle -relief raised -borderwidth 2
	pack .c.middle -side top -fill both
	foreach i {/usr/local/lib/X11/rgb.txt /usr/lib/X11/rgb.txt
		/X11/R5/lib/X11/rgb.txt /X11/R4/lib/rgb/rgb.txt
		/usr/X11R6/lib/X11/rgb.txt } {
		if ![file readable $i] {
			continue;
		}
		set f [open $i]
		frame .c.middle.left
		pack .c.middle.left -side left -padx .25c -pady .25c
		listbox .c.names -geometry 20x12 \
			-yscrollcommand ".c.scroll set" -relief sunken \
			-borderwidth 2 -exportselection false
		tk_listboxSingleSelect .c.names
		bind .c.names <Double-1> {
		    tc_loadNamedColor [.c.names get [.c.names curselection]]
		}
		scrollbar .c.scroll -orient vertical -command \
			".c.names yview" -relief sunken -borderwidth 2
		pack .c.names -in .c.middle.left -side left
		pack .c.scroll -in .c.middle.left -side right -fill y
		while {[gets $f line] >= 0} {
			if {[llength $line] == 4} {
				.c.names insert end [lindex $line 3]
			}
		}
		close $f
		break;
	}
d377 10
a386 2
# Create the three scales for editing the color, and the entry for
# typing in a color value.
d388 10
a397 25
	frame .c.middle.middle
	pack .c.middle.middle -side left -expand yes -fill y
	frame .c.middle.middle.1
	frame .c.middle.middle.2
	frame .c.middle.middle.3
	frame .c.middle.middle.4
	pack .c.middle.middle.1 .c.middle.middle.2 .c.middle.middle.3 \
		-side top -expand yes
	pack .c.middle.middle.4 -side top -expand yes -fill x
	foreach i {1 2 3} {
		label .c.label$i -textvariable label$i
		scale .c.scale$i -from 0 -to 1000 -length 10c \
			-orient horizontal -command tc_scaleChanged
		button .c.up$i -width 2 -text + -command "tc_inc $i 1"
		button .c.down$i -width 2 -text - -command "tc_inc $i -1"
		pack .c.label$i -in .c.middle.middle.$i -side top -anchor w
		pack .c.down$i -in .c.middle.middle.$i -side left -padx .25c
		pack .c.scale$i -in .c.middle.middle.$i -side left
		pack .c.up$i -in .c.middle.middle.$i -side left -padx .25c
	}
	label .c.nameLabel -text "Name of new color:"
	entry .c.name -relief sunken -borderwidth 2 -textvariable name \
		-width 30 -font -Adobe-Courier-Medium-R-Normal-*-120-*
	pack .c.nameLabel .c.name -in .c.middle.middle.4 -side left
	bind .c.name <Return> {tc_loadNamedColor $name}
d399 5
a403 1
# Create the color display swatch on the right side of the window.
d405 5
a409 7
	frame .c.middle.right
	pack .c.middle.right -side left -pady .25c -padx .25c -anchor s
	frame .c.swatch -width 2c -height 5c -background $color
	label .c.value -textvariable color -width 13 \
		-font -Adobe-Courier-Medium-R-Normal-*-120-*
	pack .c.swatch -in .c.middle.right -side top -expand yes -fill both
	pack .c.value -in .c.middle.right -side bottom -pady .25c
d411 4
a414 1
	changeColorSpace hsb
d417 5
a421 3
# The procedure below handles the "+" and "-" buttons next to
# the adjustor scales.  They just increment or decrement the
# appropriate scale value.
d423 4
a426 2
proc tc_inc {scale inc} {
	.c.scale$scale set [expr [.c.scale$scale get]+$inc]
d429 5
a433 3
# The procedure below is invoked when one of the scales is adjusted.
# It propagates color information from the current scale readings
# to everywhere else that it is used.
d435 3
a437 3
proc tc_scaleChanged args {
    global red green blue colorSpace color updating autoUpdate
    if $updating {
d440 34
a473 9
    if {$colorSpace == "rgb"} {
	set red   [format %.0f [expr [.c.scale1 get]*65.535]]
	set green [format %.0f [expr [.c.scale2 get]*65.535]]
	set blue  [format %.0f [expr [.c.scale3 get]*65.535]]
    } else {
	if {$colorSpace == "cmy"} {
	    set red   [format %.0f [expr {65535 - [.c.scale1 get]*65.535}]]
	    set green [format %.0f [expr {65535 - [.c.scale2 get]*65.535}]]
	    set blue  [format %.0f [expr {65535 - [.c.scale3 get]*65.535}]]
d475 3
a477 6
	    set list [hsbToRgb [expr {[.c.scale1 get]/1000.0}] \
		    [expr {[.c.scale2 get]/1000.0}] \
		    [expr {[.c.scale3 get]/1000.0}]]
	    set red [lindex $list 0]
	    set green [lindex $list 1]
	    set blue [lindex $list 2]
d479 54
a532 23
    }
    set color [format "#%04x%04x%04x" $red $green $blue]
    .c.swatch config -bg $color
    update idletasks
}

# The procedure below is invoked to update the scales from the
# current red, green, and blue intensities.  It's invoked after
# a change in the color space and after a named color value has
# been loaded.

proc tc_setScales {} {
    global red green blue colorSpace updating
    set updating 1
    if {$colorSpace == "rgb"} {
	.c.scale1 set [format %.0f [expr $red/65.535]]
	.c.scale2 set [format %.0f [expr $green/65.535]]
	.c.scale3 set [format %.0f [expr $blue/65.535]]
    } else {
	if {$colorSpace == "cmy"} {
	    .c.scale1 set [format %.0f [expr (65535-$red)/65.535]]
	    .c.scale2 set [format %.0f [expr (65535-$green)/65.535]]
	    .c.scale3 set [format %.0f [expr (65535-$blue)/65.535]]
d534 2
a535 4
	    set list [rgbToHsv $red $green $blue]
	    .c.scale1 set [format %.0f [expr {[lindex $list 0] * 1000.0}]]
	    .c.scale2 set [format %.0f [expr {[lindex $list 1] * 1000.0}]]
	    .c.scale3 set [format %.0f [expr {[lindex $list 2] * 1000.0}]]
d538 3
a540 2
    set updating 0
}
d542 2
a543 3
# The procedure below is invoked when a named color has been
# selected from the listbox or typed into the entry.  It loads
# the color into the editor.
d545 7
a551 2
proc tc_loadNamedColor name {
    global red green blue color autoUpdate
d553 5
a557 15
    if {[string index $name 0] != "#"} {
	set list [winfo rgb .c.swatch $name]
	set red [lindex $list 0]
	set green [lindex $list 1]
	set blue [lindex $list 2]
    } else {
	case [string length $name] {
	    4 {set format "#%1x%1x%1x"; set shift 12}
	    7 {set format "#%2x%2x%2x"; set shift 8}
	    10 {set format "#%3x%3x%3x"; set shift 4}
	    13 {set format "#%4x%4x%4x"; set shift 0}
	    default {error "syntax error in color name \"$name\""}
	}
	if {[scan $name $format red green blue] != 3} {
	    error "syntax error in color name \"$name\""
a558 21
	set red [expr $red<<$shift]
	set green [expr $green<<$shift]
	set blue [expr $blue<<$shift]
    }
    tc_setScales
    set color [format "#%04x%04x%04x" $red $green $blue]
    .c.swatch config -bg $color
}

# The procedure below is invoked when a new color space is selected.
# It changes the labels on the scales and re-loads the scales with
# the appropriate values for the current color in the new color space

proc changeColorSpace space {
    global label1 label2 label3
    if {$space == "rgb"} {
	set label1 Red
	set label2 Green
	set label3 Blue
	tc_setScales
	return
d560 17
a576 6
    if {$space == "cmy"} {
	set label1 Cyan
	set label2 Magenta
	set label3 Yellow
	tc_setScales
	return
d578 17
a594 5
    if {$space == "hsb"} {
	set label1 Hue
	set label2 Saturation
	set label3 Brightness
	tc_setScales
d597 8
d607 5
a611 20
# The procedure below converts an RGB value to HSB.  It takes red, green,
# and blue components (0-65535) as arguments, and returns a list containing
# HSB components (floating-point, 0-1) as result.  The code here is a copy
# of the code on page 615 of "Fundamentals of Interactive Computer Graphics"
# by Foley and Van Dam.

proc rgbToHsv {red green blue} {
    if {$red > $green} {
	set max $red.0
	set min $green.0
    } else {
	set max $green.0
	set min $red.0
    }
    if {$blue > $max} {
	set max $blue.0
    } else {
	if {$blue < $min} {
	    set min $blue.0
	}
d613 3
a615 3
    set range [expr $max-$min]
    if {$max == 0} {
	set sat 0
d617 1
a617 1
	set sat [expr {($max-$min)/$max}]
a618 18
    if {$sat == 0} {
	set hue 0
    } else {
	set rc [expr {($max - $red)/$range}]
	set gc [expr {($max - $green)/$range}]
	set bc [expr {($max - $blue)/$range}]
	if {$red == $max} {
	    set hue [expr {.166667*($bc - $gc)}]
	} else {
	    if {$green == $max} {
		set hue [expr {.166667*(2 + $rc - $bc)}]
	    } else {
		set hue [expr {.166667*(4 + $gc - $rc)}]
	    }
	}
    }
    return [list $hue $sat [expr {$max/65535}]]
}
d620 4
a623 10
# The procedure below converts an HSB value to RGB.  It takes hue, saturation,
# and value components (floating-point, 0-1.0) as arguments, and returns a
# list containing RGB components (integers, 0-65535) as result.  The code
# here is a copy of the code on page 616 of "Fundamentals of Interactive
# Computer Graphics" by Foley and Van Dam.

proc hsbToRgb {hue sat value} {
    set v [format %.0f [expr 65535.0*$value]]
    if {$sat == 0} {
	return "$v $v $v"
d625 2
a626 17
	set hue [expr $hue*6.0]
	if {$hue >= 6.0} {
	    set hue 0.0
	}
	scan $hue. %d i
	set f [expr $hue-$i]
	set p [format %.0f [expr {65535.0*$value*(1 - $sat)}]]
	set q [format %.0f [expr {65535.0*$value*(1 - ($sat*$f))}]]
	set t [format %.0f [expr {65535.0*$value*(1 - ($sat*(1 - $f)))}]]
	case $i \
	    0 {return "$v $t $p"} \
	    1 {return "$q $v $p"} \
	    2 {return "$p $v $t"} \
	    3 {return "$p $q $v"} \
	    4 {return "$t $p $v"} \
	    5 {return "$v $p $q"}
	error "i value $i is out of range"
d630 2
d633 2
d636 15
a650 9
#============================================================================
# PHASE 5: Commands MGED to set things up all nice and pretty.
#============================================================================

# The usual faceplate is now superfluous
mset faceplate=0

# Tell MGED to put in necessary GUI hooks.
gui .i.f.text
@
