head	1.42;
access;
symbols
	ansi-20040405-merged:1.34.4.1
	postmerge-20040405-ansi:1.41
	premerge-20040404-ansi:1.41
	postmerge-autoconf:1.41
	autoconf-freeze:1.41
	premerge-autoconf:1.41
	postmerge-20040315-windows:1.41
	premerge-20040315-windows:1.41
	windows-20040315-freeze:1.34.6.1
	autoconf-20031203:1.41
	autoconf-20031202:1.41
	autoconf-branch:1.41.0.4
	phong-branch:1.41.0.2
	photonmap-branch:1.38.0.2
	rel-6-1-DP:1.34
	windows-branch:1.34.0.6
	rel-6-0-2:1.34
	ansi-branch:1.34.0.4
	rel-6-0-1-branch:1.34.0.2
	hartley-6-0-post:1.34
	hartley-6-0-pre:1.34
	rel-6-0-1:1.34
	rel-6-0:1.34
	rel-5-4:1.26.2.3
	offsite-5-3-pre:1.32
	rel-5-3:1.26.2.3
	rel-5-2:1.26
	rel-5-1-branch:1.26.0.2
	rel-5-1:1.26
	rel-5-0:1.21
	rel-5-0-beta:1.21;
locks; strict;
comment	@# @;


1.42
date	2004.05.21.16.41.32;	author morrison;	state dead;
branches;
next	1.41;

1.41
date	2003.08.27.19.18.56;	author justin;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2003.04.21.12.37.16;	author jra;	state Exp;
branches;
next	1.39;

1.39
date	2003.04.21.12.06.12;	author jra;	state Exp;
branches;
next	1.38;

1.38
date	2003.04.14.20.42.49;	author jra;	state Exp;
branches
	1.38.2.1;
next	1.37;

1.37
date	2003.04.09.15.04.49;	author jra;	state Exp;
branches;
next	1.36;

1.36
date	2003.04.05.00.19.27;	author butler;	state Exp;
branches;
next	1.35;

1.35
date	2002.12.27.18.26.48;	author jra;	state Exp;
branches;
next	1.34;

1.34
date	2001.10.30.20.25.17;	author bparker;	state Exp;
branches
	1.34.4.1
	1.34.6.1;
next	1.33;

1.33
date	2001.03.19.22.20.20;	author butler;	state Exp;
branches;
next	1.32;

1.32
date	2001.01.30.16.21.26;	author jra;	state Exp;
branches;
next	1.31;

1.31
date	2000.11.20.20.19.32;	author butler;	state Exp;
branches;
next	1.30;

1.30
date	2000.11.19.16.33.15;	author butler;	state Exp;
branches;
next	1.29;

1.29
date	2000.10.19.19.19.47;	author butler;	state Exp;
branches;
next	1.28;

1.28
date	2000.10.16.17.05.08;	author butler;	state Exp;
branches;
next	1.27;

1.27
date	2000.08.17.13.33.02;	author jra;	state Exp;
branches;
next	1.26;

1.26
date	2000.03.03.15.18.28;	author jra;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2000.03.03.14.50.07;	author jra;	state Exp;
branches;
next	1.24;

1.24
date	2000.03.03.14.00.55;	author jra;	state Exp;
branches;
next	1.23;

1.23
date	99.10.04.18.00.12;	author butler;	state Exp;
branches;
next	1.22;

1.22
date	99.10.04.17.30.11;	author jra;	state Exp;
branches;
next	1.21;

1.21
date	99.05.06.12.25.08;	author jra;	state Exp;
branches;
next	1.20;

1.20
date	99.05.05.19.03.48;	author jra;	state Exp;
branches;
next	1.19;

1.19
date	99.05.05.15.26.00;	author jra;	state Exp;
branches;
next	1.18;

1.18
date	99.04.23.18.08.54;	author jra;	state Exp;
branches;
next	1.17;

1.17
date	99.04.16.20.56.41;	author jra;	state Exp;
branches;
next	1.16;

1.16
date	99.03.08.16.59.21;	author jra;	state Exp;
branches;
next	1.15;

1.15
date	99.02.12.19.08.20;	author jra;	state Exp;
branches;
next	1.14;

1.14
date	99.01.28.15.23.57;	author jra;	state Exp;
branches;
next	1.13;

1.13
date	99.01.05.21.10.59;	author jra;	state Exp;
branches;
next	1.12;

1.12
date	98.12.15.15.38.17;	author jra;	state Exp;
branches;
next	1.11;

1.11
date	98.12.14.20.49.04;	author jra;	state Exp;
branches;
next	1.10;

1.10
date	98.12.14.03.51.38;	author jra;	state Exp;
branches;
next	1.9;

1.9
date	98.12.09.14.32.09;	author jra;	state Exp;
branches;
next	1.8;

1.8
date	98.12.01.02.30.18;	author jra;	state Exp;
branches;
next	1.7;

1.7
date	98.12.01.02.23.06;	author jra;	state Exp;
branches;
next	1.6;

1.6
date	98.11.30.14.04.55;	author jra;	state Exp;
branches;
next	1.5;

1.5
date	98.11.30.03.22.53;	author jra;	state Exp;
branches;
next	1.4;

1.4
date	98.11.27.21.34.47;	author jra;	state Exp;
branches;
next	1.3;

1.3
date	98.11.20.21.03.04;	author jra;	state Exp;
branches;
next	1.2;

1.2
date	98.11.19.16.40.59;	author jra;	state Exp;
branches;
next	1.1;

1.1
date	98.11.19.14.35.04;	author jra;	state Exp;
branches;
next	;

1.26.2.1
date	2000.11.20.21.06.46;	author jra;	state Exp;
branches;
next	1.26.2.2;

1.26.2.2
date	2000.11.30.02.56.26;	author jra;	state Exp;
branches;
next	1.26.2.3;

1.26.2.3
date	2000.11.30.13.56.32;	author jra;	state Exp;
branches;
next	;

1.34.4.1
date	2004.03.17.21.23.16;	author morrison;	state Exp;
branches;
next	;

1.34.6.1
date	2004.03.11.23.48.59;	author morrison;	state Exp;
branches;
next	;

1.38.2.1
date	2003.08.12.22.48.26;	author justin;	state Exp;
branches;
next	1.38.2.2;

1.38.2.2
date	2003.08.26.14.04.47;	author justin;	state Exp;
branches;
next	;

1.41.2.1
date	2003.09.10.22.06.12;	author butler;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2003.09.13.17.51.27;	author butler;	state Exp;
branches;
next	;


desc
@@


1.42
log
@moved to src/tclscripts/
@
text
@#  routines implement the gui for the BRL-CAD shaders
# shader_params is a global array containing all the values for this shader gui
# make your shader param names unique
# the 'id' is passed to these routines to use for uniqueness
# the top-level interface is 'do_shader'
# See "comb.tcl" for an explanation of the widget hierarchy

# To implement a new shader gui:
#	1. add the new shader to the switch command in 'stack_add',
#		'stack_insert', and 'env_select', if this shader is
#		appropriate for being in a stack or environment map
#	2. add the new shader to the menus in 'do_stack' and 'do_envmap'
#		(again, if appropriate)
#	3. add a menu item for the new shader in 'init_comb' (comb.tcl) 
#		(required)
#	4. add the following routines: (all are required, replace 'newshader'
#		 with your shader name

# proc do_newshader { shade_var id } - Creates the frame to hold the shader widgets and
#	creates the labels, entries, buttons... Also registers 'help-on-context' data.
#	all entry widgets should bind <KeyRelease> to "do_shader_apply".
#	calls 'set_newshader_values' to set initial settings of widgets.
#	returns the created frame name.

# proc set_newshader_values { shader_str id }
#	sets the shader widget values according to the passed in shader string

# proc do_newshader_apply { shade_var id }
#	builds a shader string from the widgets and places the finished string
#	in a level 0 variable, whose name gets passed in

# proc set_newshader_defaults { id }
#	This routine sets the default values for this shader

proc vec_compare { v1 v2 n } {
	for { set i 0 } { $i < $n } { incr i } {
		if { [expr [lindex $v1 $i] != [lindex $v2 $i]] } then {
			return 1
		}
	}
	return 0
}

# extern routines (the "extern" shader)
proc do_extern { shade_var id } {
	global shader_params
	upvar #0 $shade_var shader_str

	catch { destroy $shader_params($id,window).fr }
	frame $shader_params($id,window).fr

	label $shader_params($id,window).fr.file -text File
	entry $shader_params($id,window).fr.file_e -width 20 -textvariable shader_params($id,extern_file)
	bind $shader_params($id,window).fr.file_e <KeyRelease> "do_shader_apply $shade_var $id"

	hoc_register_data $shader_params($id,window).fr.file "File" {
		{summary "The 'extern' shader is merely another way of assigning shaders to combinations.\n\
			In this shader, all the parameters are stored in an outboard file. The format of the file\n\
			is:\n\
				shader_name key_word1=value keyword2=value...\n\
			\n\
			This shader is actually a variant of the stack shader, so you can supply more than one\n\
			shader in the file by using the ';' as a separator. For example:\n\
			\n\
				camo s=200 t1=-.3 t2=.125;plastic di=.8\n\
			\n\
			will apply the 'camo' shader, then the 'plastic' shader.\n\
			\n\
			Enter the name of the outboard file here."}
	}
	hoc_register_data $shader_params($id,window).fr.file_e "File" {
		{summary "The 'extern' shader is merely another way of assigning shaders to combinations.\n\
			In this shader, all the parameters are stored in an outboard file. The format of the file\n\
			is:\n\
				shader_name key_word1=value keyword2=value...\n\
			\n\
			This shader is actually a variant of the stack shader, so you can supply more than one\n\
			shader in the file by using the ';' as a separator. For example:\n\
			\n\
				camo s=200 t1=-.3 t2=.125;plastic di=.8\n\
			\n\
			will apply the 'camo' shader, then the 'plastic' shader.\n\
			\n\
			Enter the name of the outboard file here."}
	}

	set_extern_values $shader_str $id

	grid $shader_params($id,window).fr.file -row 0 -column 0 -sticky e
	grid $shader_params($id,window).fr.file_e -row 0 -column 1 -sticky w
	grid $shader_params($id,window).fr -ipadx 3 -ipady 3 -sticky ew
	return $shader_params($id,window).fr
}

proc set_extern_values { shader_str id } {
	global shader_params

	if { [llength $shader_str] > 1 } then {
		set params [lindex $shader_str 1]
	        set shader_name [lindex $shader_str 0]
	        if { $shader_name != "extern" } {
		    return
		}
	} else {
		set params ""
	}
	set err [catch {set list_len [llength $params]}]
	if { $err } {set list_len 0}
	if { $list_len > 0 } then {
		set shader_params($id,extern_file) [lindex $params 0]
	}

}

proc do_extern_apply { shade_var id } {
	global shader_params
	upvar #0 $shade_var shade_str

	set params ""
	if { [string length $shader_params($id,extern_file) ] > 0 } then {
		lappend params $shader_params($id,extern_file)
	}

	set shade_str [list extern $params]
}

proc set_extern_defaults { id } {
	global shader_params

	set shader_params($id,extern_file) ""
}

# camouflage routines

proc color_trigger { shade_var id name1 name2 op } {
	do_shader_apply $shade_var $id
}

proc do_camo {  shade_var id } {
	global shader_params
	upvar #0 $shade_var shader_str

	catch { destroy $shader_params($id,window).fr }
	frame $shader_params($id,window).fr

	trace vdelete shader_params($id,c1) w "color_trigger $shade_var $id"
	trace vdelete shader_params($id,c2) w "color_trigger $shade_var $id"
	trace vdelete shader_params($id,c3) w "color_trigger $shade_var $id"

	set shader_params($id,c1) ""
	set shader_params($id,c2) ""
	set shader_params($id,c3) ""

	label $shader_params($id,window).fr.lacun -text Lacunarity
	entry $shader_params($id,window).fr.lacun_e -width 7 -textvariable shader_params($id,lacun)
	bind $shader_params($id,window).fr.lacun_e <KeyRelease> "do_shader_apply $shade_var $id"
	hoc_register_data $shader_params($id,window).fr.lacun "Lacunarity" {
		{summary "The 'camo' shader creates a pseudo-random tri-color camouflage pattern\n\
			on the object using a fractal noise pattern. This is a procedural shader\n\
			based upon a fractal noise function known as fractional brownian motion or fBm.\n\
			The fractal noise function produces a pseudo-random number in the range\n\
			[-1.0 ... 1.0] from the 3-space coordinates of a point in the bounding volume of the region."}
		{description "The grid on which the noise function is built is scaled by this value\n\
			for each successive octave of noise which will be combined to produce the\n\
			final result. (default is 2.1753974)"}
		{range "Must be greater than zero"}
	}
	hoc_register_data $shader_params($id,window).fr.lacun_e "Lacunarity" {
		{summary "The 'camo' shader creates a pseudo-random tri-color camouflage pattern\n\
			on the object using a fractal noise pattern. This is a procedural shader\n\
			based upon a fractal noise function known as fractional brownian motion or fBm.\n\
			The fractal noise function produces a pseudo-random number in the range\n\
			[-1.0 ... 1.0] from the 3-space coordinates of a point in the bounding volume of the region."}
		{description "The grid on which the noise function is built is scaled by this value\n\
			for each successive octave of noise which will be combined to produce the\n\
			final result. (default is 2.1753974)"}
		{range "Must be greater than zero"}
	}

	label $shader_params($id,window).fr.h -text "H value"
	entry $shader_params($id,window).fr.h_e -width 7 -textvariable shader_params($id,hval)
	bind $shader_params($id,window).fr.h_e <KeyRelease> "do_shader_apply $shade_var $id"
	hoc_register_data $shader_params($id,window).fr.h "H Value" {
		{summary "The 'camo' shader creates a pseudo-random tri-color camouflage pattern\n\
			on the object using a fractal noise pattern. This is a procedural shader\n\
			based upon a fractal noise function known as fractional brownian motion or fBm.\n\
			The fractal noise function produces a pseudo-random number in the range\n\
			[-1.0 ... 1.0] from the 3-space coordinates of a point in the bounding volume of the region."}
		{description "Larger values mean additional octaves have less effect"}
		{range "At least 1.0 (default is 1.0)"}
	}
	hoc_register_data $shader_params($id,window).fr.h_e "H Value" {
		{summary "The 'camo' shader creates a pseudo-random tri-color camouflage pattern\n\
			on the object using a fractal noise pattern. This is a procedural shader\n\
			based upon a fractal noise function known as fractional brownian motion or fBm.\n\
			The fractal noise function produces a pseudo-random number in the range\n\
			[-1.0 ... 1.0] from the 3-space coordinates of a point in the bounding volume of the region."}
		{description "Larger values mean additional octaves have less effect"}
		{range "At least 1.0 (default is 1.0)"}
	}

	label $shader_params($id,window).fr.octaves -text "Octaves"
	entry $shader_params($id,window).fr.octaves_e -width 7 -textvariable shader_params($id,octaves)
	bind $shader_params($id,window).fr.octaves_e <KeyRelease> "do_shader_apply $shade_var $id"
	hoc_register_data $shader_params($id,window).fr.octaves "Octaves" {
		{summary "The 'camo' shader creates a pseudo-random tri-color camouflage pattern\n\
			on the object using a fractal noise pattern. This is a procedural shader\n\
			based upon a fractal noise function known as fractional brownian motion or fBm.\n\
			The fractal noise function produces a pseudo-random number in the range\n\
			[-1.0 ... 1.0] from the 3-space coordinates of a point in the bounding volume of the region."}
		{description "The number of times the noise grid will be scaled\n\
			and recombined to produce the final noise function."}
		{range "Must be greater than 0 (default is  4.0)"}
	}
	hoc_register_data $shader_params($id,window).fr.octaves_e "Octaves" {
		{summary "The 'camo' shader creates a pseudo-random tri-color camouflage pattern\n\
			on the object using a fractal noise pattern. This is a procedural shader\n\
			based upon a fractal noise function known as fractional brownian motion or fBm.\n\
			The fractal noise function produces a pseudo-random number in the range\n\
			[-1.0 ... 1.0] from the 3-space coordinates of a point in the bounding volume of the region."}
		{description "The number of times the noise grid will be scaled\n\
			and recombined to produce the final noise function."}
		{range "Must be greater than 0 (default is  4.0)"}
	}

	label $shader_params($id,window).fr.size -text "Noise Size"
	entry $shader_params($id,window).fr.size_e -width 7 -textvariable shader_params($id,size)
	bind $shader_params($id,window).fr.size_e <KeyRelease> "do_shader_apply $shade_var $id"
	hoc_register_data $shader_params($id,window).fr.size "Noise Size" {
		{summary "The 'camo' shader creates a pseudo-random tri-color camouflage pattern\n\
			on the object using a fractal noise pattern. This is a procedural shader\n\
			based upon a fractal noise function known as fractional brownian motion or fBm.\n\
			The fractal noise function produces a pseudo-random number in the range\n\
			[-1.0 ... 1.0] from the 3-space coordinates of a point in the bounding volume of the region."}
		{description "A larger number here produces larger color patches (default is 1.0)"}
		{range "must be greater than zero"}
	}
	hoc_register_data $shader_params($id,window).fr.size_e "Noise Size" {
		{summary "The 'camo' shader creates a pseudo-random tri-color camouflage pattern\n\
			on the object using a fractal noise pattern. This is a procedural shader\n\
			based upon a fractal noise function known as fractional brownian motion or fBm.\n\
			The fractal noise function produces a pseudo-random number in the range\n\
			[-1.0 ... 1.0] from the 3-space coordinates of a point in the bounding volume of the region."}
		{description "A larger number here produces larger color patches (default is 1.0)"}
		{range "must be greater than zero"}
	}

	label $shader_params($id,window).fr.scale -text "Noise Scale (X, Y, Z)"
	entry $shader_params($id,window).fr.scale_e -width 20 -textvariable shader_params($id,scale)
	bind $shader_params($id,window).fr.scale_e <KeyRelease> "do_shader_apply $shade_var $id"
	hoc_register_data $shader_params($id,window).fr.scale "Noise Scale" {
		{summary "The 'camo' shader creates a pseudo-random tri-color camouflage pattern\n\
			on the object using a fractal noise pattern. This is a procedural shader\n\
			based upon a fractal noise function known as fractional brownian motion or fBm.\n\
			The fractal noise function produces a pseudo-random number in the range\n\
			[-1.0 ... 1.0] from the 3-space coordinates of a point in the bounding volume of the region."}
		{description "Three scale values are required (X, Y, and Z). These values\n\
			allow scaling the noise pattern non-uniformly"}
		{range "Must be greater than 0 Default values are (1.0 1.0 1.0)"}
	}
	hoc_register_data $shader_params($id,window).fr.scale_e "Noise Scale" {
		{summary "The 'camo' shader creates a pseudo-random tri-color camouflage pattern\n\
			on the object using a fractal noise pattern. This is a procedural shader\n\
			based upon a fractal noise function known as fractional brownian motion or fBm.\n\
			The fractal noise function produces a pseudo-random number in the range\n\
			[-1.0 ... 1.0] from the 3-space coordinates of a point in the bounding volume of the region."}
		{description "Three scale values are required (X, Y, and Z). These values\n\
			allow scaling the noise pattern non-uniformly"}
		{range "Must be greater than 0 Default values are (1.0 1.0 1.0)"}
	}

	label $shader_params($id,window).fr.c1 -text "Color #1"
	frame $shader_params($id,window).fr.c1_e
	color_entry_build $shader_params($id,window).fr.c1_e color shader_params($id,c1)\
		"color_entry_chooser $id $shader_params($id,window).fr.c1_e color \"Color #1\"\
		 shader_params $id,c1"\
		12 $shader_params($id,c1) not_rt
	hoc_register_data $shader_params($id,window).fr.c1 "Color #1" {
		{summary "The 'camo' shader creates a pseudo-random tri-color camouflage pattern\n\
			on the object using a fractal noise pattern. This is a procedural shader\n\
			based upon a fractal noise function known as fractional brownian motion or fBm.\n\
			The fractal noise function produces a pseudo-random number in the range\n\
			[-1.0 ... 1.0] from the 3-space coordinates of a point in the bounding volume of the region."}
		{description "This is one of three colors used in the camouflage pattern\n\
			(default color is 97/74/41)"}
	}

	label $shader_params($id,window).fr.c2 -text "Background Color"
	frame $shader_params($id,window).fr.c2_e
	color_entry_build $shader_params($id,window).fr.c2_e color shader_params($id,c2)\
		"color_entry_chooser $id $shader_params($id,window).fr.c2_e color \"Background Color\"\
		 shader_params $id,c2"\
		12 $shader_params($id,c2) not_rt
	hoc_register_data $shader_params($id,window).fr.c2 "Background Color" {
		{summary "The 'camo' shader creates a pseudo-random tri-color camouflage pattern\n\
			on the object using a fractal noise pattern. This is a procedural shader\n\
			based upon a fractal noise function known as fractional brownian motion or fBm.\n\
			The fractal noise function produces a pseudo-random number in the range\n\
			[-1.0 ... 1.0] from the 3-space coordinates of a point in the bounding volume of the region."}
		{description "This is the background color used in the camouflage pattern\n\
			(default color is 26/77/10)"}
	}

	label $shader_params($id,window).fr.c3 -text "Color #2"
	frame $shader_params($id,window).fr.c3_e
	color_entry_build $shader_params($id,window).fr.c3_e color shader_params($id,c3)\
		"color_entry_chooser $id $shader_params($id,window).fr.c3_e color \"Color #2\"\
		 shader_params $id,c3"\
		12 $shader_params($id,c3) not_rt
	hoc_register_data $shader_params($id,window).fr.c3 "Color #2" {
		{summary "The 'camo' shader creates a pseudo-random tri-color camouflage pattern\n\
			on the object using a fractal noise pattern. This is a procedural shader\n\
			based upon a fractal noise function known as fractional brownian motion or fBm.\n\
			The fractal noise function produces a pseudo-random number in the range\n\
			[-1.0 ... 1.0] from the 3-space coordinates of a point in the bounding volume of the region."}
		{description "This is one of three colors used in the camouflage pattern\n\
			(default color is 38/38/38)"}
	}

	label $shader_params($id,window).fr.t1 -text "Threshold #1"
	entry $shader_params($id,window).fr.t1_e -width 7 -textvariable  shader_params($id,t1)
	bind $shader_params($id,window).fr.t1_e <KeyRelease> "do_shader_apply $shade_var $id"
	hoc_register_data $shader_params($id,window).fr.t1 "Noise Scale" {
		{summary "The 'camo' shader creates a pseudo-random tri-color camouflage pattern\n\
			on the object using a fractal noise pattern. This is a procedural shader\n\
			based upon a fractal noise function known as fractional brownian motion or fBm.\n\
			The fractal noise function produces a pseudo-random number in the range\n\
			[-1.0 ... 1.0] from the 3-space coordinates of a point in the bounding volume of the region."}
		{description "Areas where the noise function returns a value less than this threshold\n\
			will be colored using color #1"}
		{range " -1.0 to +1.0 (default is -0.25)"}
	}
	hoc_register_data $shader_params($id,window).fr.t1_e "Threshold #1" {
		{summary "The 'camo' shader creates a pseudo-random tri-color camouflage pattern\n\
			on the object using a fractal noise pattern. This is a procedural shader\n\
			based upon a fractal noise function known as fractional brownian motion or fBm.\n\
			The fractal noise function produces a pseudo-random number in the range\n\
			[-1.0 ... 1.0] from the 3-space coordinates of a point in the bounding volume of the region."}
		{description "Areas where the noise function returns a value less than this threshold\n\
			will be colored using color #1"}
		{range " -1.0 to +1.0 (default is -0.25)"}
	}

	label $shader_params($id,window).fr.t2 -text "Threshold #2"
	entry $shader_params($id,window).fr.t2_e -width 7 -textvariable  shader_params($id,t2)
	bind $shader_params($id,window).fr.t2_e <KeyRelease> "do_shader_apply $shade_var $id"
	hoc_register_data $shader_params($id,window).fr.t2 "Noise Scale" {
		{summary "The 'camo' shader creates a pseudo-random tri-color camouflage pattern\n\
			on the object using a fractal noise pattern. This is a procedural shader\n\
			based upon a fractal noise function known as fractional brownian motion or fBm.\n\
			The fractal noise function produces a pseudo-random number in the range\n\
			[-1.0 ... 1.0] from the 3-space coordinates of a point in the bounding volume of the region."}
		{description "Areas where the noise function returns a value greater than this threshold\n\
			will be colored using color #2"}
		{range " -1.0 to +1.0 (default is 0.25)"}
	}
	hoc_register_data $shader_params($id,window).fr.t2_e "Threshold #2" {
		{summary "The 'camo' shader creates a pseudo-random tri-color camouflage pattern\n\
			on the object using a fractal noise pattern. This is a procedural shader\n\
			based upon a fractal noise function known as fractional brownian motion or fBm.\n\
			The fractal noise function produces a pseudo-random number in the range\n\
			[-1.0 ... 1.0] from the 3-space coordinates of a point in the bounding volume of the region."}
		{description "Areas where the noise function returns a value greater than this threshold\n\
			will be colored using color #2"}
		{range " -1.0 to +1.0 (default is 0.25)"}
	}

	label $shader_params($id,window).fr.delta -text "Noise Delta (X, Y, Z)"
	entry $shader_params($id,window).fr.delta_e -width 20  -textvariable shader_params($id,delta)
	bind $shader_params($id,window).fr.delta_e <KeyRelease> "do_shader_apply $shade_var $id"
	hoc_register_data $shader_params($id,window).fr.delta "Noise Delta" {
		{summary "The 'camo' shader creates a pseudo-random tri-color camouflage pattern\n\
			on the object using a fractal noise pattern. This is a procedural shader\n\
			based upon a fractal noise function known as fractional brownian motion or fBm.\n\
			The fractal noise function produces a pseudo-random number in the range\n\
			[-1.0 ... 1.0] from the 3-space coordinates of a point in the bounding volume of the region."}
		{description "These values provide a delta into the noise space.\n\
			Default values are (1000.0 1000.0 1000.0)" }
	}
	hoc_register_data $shader_params($id,window).fr.delta_e "Noise Delta" {
		{summary "The 'camo' shader creates a pseudo-random tri-color camouflage pattern\n\
			on the object using a fractal noise pattern. This is a procedural shader\n\
			based upon a fractal noise function known as fractional brownian motion or fBm.\n\
			The fractal noise function produces a pseudo-random number in the range\n\
			[-1.0 ... 1.0] from the 3-space coordinates of a point in the bounding volume of the region."}
		{description "These values provide a delta into the noise space.\n\
			Default values are (1000.0 1000.0 1000.0)" }
	}

	set_camo_values $shader_str $id

	trace variable shader_params($id,c1) w "color_trigger $shade_var $id"
	trace variable shader_params($id,c2) w "color_trigger $shade_var $id"
	trace variable shader_params($id,c3) w "color_trigger $shade_var $id"

	grid $shader_params($id,window).fr.c2 -row 0 -column 0 -columnspan 2 -sticky e
	grid $shader_params($id,window).fr.c2_e.colorF
	grid $shader_params($id,window).fr.c2_e -row 0 -column 2 -columnspan 2 -sticky w
	grid $shader_params($id,window).fr.c1 -row 1 -column 0 -columnspan 2 -sticky e
	grid $shader_params($id,window).fr.c1_e.colorF
	grid $shader_params($id,window).fr.c1_e -row 1 -column 2 -columnspan 2 -sticky w
	grid $shader_params($id,window).fr.c3 -row 2 -column 0 -columnspan 2 -sticky e
	grid $shader_params($id,window).fr.c3_e.colorF
	grid $shader_params($id,window).fr.c3_e -row 2 -column 2 -columnspan 2 -sticky w
	grid $shader_params($id,window).fr.t1 -row 3 -column 0 -sticky e
	grid $shader_params($id,window).fr.t1_e -row 3 -column 1 -sticky w
	grid $shader_params($id,window).fr.t2 -row 3 -column 2 -sticky e
	grid $shader_params($id,window).fr.t2_e -row 3 -column 3 -sticky w
	grid $shader_params($id,window).fr.lacun -row 4 -column 0 -sticky e
	grid $shader_params($id,window).fr.lacun_e -row 4 -column 1 -sticky w
	grid $shader_params($id,window).fr.h -row 4 -column 2 -sticky e
	grid $shader_params($id,window).fr.h_e -row 4 -column 3 -sticky w
	grid $shader_params($id,window).fr.size -row 5 -column 0 -sticky e
	grid $shader_params($id,window).fr.size_e -row 5 -column 1 -sticky w
	grid $shader_params($id,window).fr.octaves -row 5 -column 2 -sticky e
	grid $shader_params($id,window).fr.octaves_e -row 5 -column 3 -sticky w
	grid $shader_params($id,window).fr.scale -row 6 -column 0 -columnspan 2 -sticky e
	grid $shader_params($id,window).fr.scale_e -row 6 -column 2 -columnspan 2 -sticky w
	grid $shader_params($id,window).fr.delta -row 7 -column 0  -columnspan 2 -sticky e
	grid $shader_params($id,window).fr.delta_e -row 7 -column 2  -columnspan 2 -sticky w

	grid $shader_params($id,window).fr -sticky ew -ipadx 3 -ipady 3

	return $shader_params($id,window).fr
}

proc set_camo_values { shader_str id } {
	global shader_params

	if { [llength $shader_str] > 1 } then {
		set params [lindex $shader_str 1]
	        set shader_name [lindex $shader_str 0]
	        if { $shader_name != "camo" } {
		    return
		}
	} else {
		set params ""
	}

	# temporarily remove traces on the colors
	set tr1_info [trace vinfo shader_params($id,c1)]
	set tr1_len [llength $tr1_info]
	for {set index 0} {$index < $tr1_len } {incr index } {
		set atrace [lindex $tr1_info $index]
		trace vdelete shader_params($id,c1) [lindex $atrace 0] [lindex $atrace 1]
	}
	set tr2_info [trace vinfo shader_params($id,c2)]
	set tr2_len [llength $tr2_info]
	for {set index 0} {$index < $tr2_len } {incr index } {
		set atrace [lindex $tr2_info $index]
		trace vdelete shader_params($id,c2) [lindex $atrace 0] [lindex $atrace 1]
	}
	set tr3_info [trace vinfo shader_params($id,c3)]
	set tr3_len [llength $tr3_info]
	for {set index 0} {$index < $tr3_len } {incr index } {
		set atrace [lindex $tr3_info $index]
		trace vdelete shader_params($id,c3) [lindex $atrace 0] [lindex $atrace 1]
	}

	set shader_params($id,c1) $shader_params($id,def_c1)
	set shader_params($id,c2) $shader_params($id,def_c2)
	set shader_params($id,c3) $shader_params($id,def_c3)
	set shader_params($id,lacun) $shader_params($id,def_lacun)
	set shader_params($id,hval) $shader_params($id,def_hval)
	set shader_params($id,octaves) $shader_params($id,def_octaves) 
	set shader_params($id,size) $shader_params($id,def_size)
	set shader_params($id,scale) $shader_params($id,def_scale)
	set shader_params($id,t1) $shader_params($id,def_t1)
	set shader_params($id,t2) $shader_params($id,def_t2)
	set shader_params($id,delta) $shader_params($id,def_delta)

	set err [catch {set list_len [llength $params]}]
	if { $err } {set list_len 0}
	if { $list_len > 0 } then {
		 for { set index 0 } { $index < $list_len } { set index [expr $index + 2] } {
			set key [lindex $params $index]
			set value [lindex $params [expr $index + 1]]

			switch $key {
				lacunarity -
				l { catch {
					if { $value != $shader_params($id,def_lacun) } then {
						set shader_params($id,lacun) $value
					}
				   }  }
				H { catch {
					if { $value != $shader_params($id,def_hval) } then {
						set shader_params($id,hval) $value
					}
				  }  }
				octaves -
				o { catch {
					if { $value != $shader_params($id,def_octaves) } then  {
						set shader_params($id,octaves) $value
					}
				  }  }
				t1 { catch {
					if { $value != $shader_params($id,def_t1) } then  {
						set shader_params($id,t1) $value
					}
				  }  }
				t2 { catch {
					if { $value != $shader_params($id,def_t2) } then  {
						set shader_params($id,t2) $value
					}
				  }  }
				size -
				s { catch {
					if { $value != $shader_params($id,def_size) } then  {
						set shader_params($id,size) $value
					}
				  }  }
				vscale -
				vs -
				v { catch {
					if { [vec_compare $value $shader_params($id,def_scale) 3] } then  {
						set shader_params($id,scale) $value
					}
				  }  }
				c1 { catch {
					if { [vec_compare $value $shader_params($id,def_c1) 3] } then  {
						set shader_params($id,c1) $value
					}
				  }  }
				c2 { catch {
					if { [vec_compare $value $shader_params($id,def_c2) 3] } then  {
						set shader_params($id,c2) $value
					}
				  }  }
				c3 { catch {
					if { $value != $shader_params($id,def_c3) } then  {
						set shader_params($id,c3) $value
					}
				  }  }
				delta -
				d { catch {
					if { [vec_compare $value $shader_params($id,def_delta) 3] } then {
						set shader_params($id,delta) $value
					}
				  }   }
			}
		}
	}

	# reinstate the traces on the colors
	for {set index 0} {$index < $tr1_len } {incr index } {
		set atrace [lindex $tr1_info $index]
		trace variable shader_params($id,c1) [lindex $atrace 0] [lindex $atrace 1]
	}
	for {set index 0} {$index < $tr2_len } {incr index } {
		set atrace [lindex $tr2_info $index]
		trace variable shader_params($id,c2) [lindex $atrace 0] [lindex $atrace 1]
	}
	for {set index 0} {$index < $tr3_len } {incr index } {
		set atrace [lindex $tr3_info $index]
		trace variable shader_params($id,c3) [lindex $atrace 0] [lindex $atrace 1]
	}
}

proc do_camo_apply { shade_var id } {
	global shader_params
	upvar #0 $shade_var shade_str

	set params ""

	if { [string length $shader_params($id,lacun) ] > 0 } then {
		catch {
			if { [expr $shader_params($id,lacun) != $shader_params($id,def_lacun)] } then {
				lappend params l $shader_params($id,lacun)
			}
		}
	}

	if { [string length $shader_params($id,hval) ] > 0 } then {
		catch {
			if { [expr $shader_params($id,hval) != $shader_params($id,def_hval)] } then {
				lappend params H $shader_params($id,hval)
			}
		}
	}

	if { [string length $shader_params($id,octaves) ] > 0 } then {
		catch {
			if { [expr $shader_params($id,octaves) != $shader_params($id,def_octaves)] } then {
				lappend params o $shader_params($id,octaves)
			}
		}
	}

	if { [string length $shader_params($id,t1) ] > 0 } then {
		catch {
			if { [expr $shader_params($id,t1) != $shader_params($id,def_t1)] } then {
				lappend params t1 $shader_params($id,t1)
			}
		}
	}

	if { [string length $shader_params($id,t2) ] > 0 } then {
		catch {
			if { [expr $shader_params($id,t2) != $shader_params($id,def_t2)] } then {
				lappend params t2 $shader_params($id,t2)
			}
		}
	}

	if { [string length $shader_params($id,size) ] > 0 } then {
		catch {
			if { [expr $shader_params($id,size) != $shader_params($id,def_size)] } then {
				lappend params s $shader_params($id,size)
			}
		}
	}

	if { [string length $shader_params($id,scale) ] > 0 } then {
		catch {
			if { [vec_compare $shader_params($id,scale) $shader_params($id,def_scale) 3] } then {
				lappend params v $shader_params($id,scale)
			}
		}
	}

	if { [string length $shader_params($id,c1) ] > 0 } then {
		catch {
			if { [vec_compare $shader_params($id,c1) $shader_params($id,def_c1) 3] } then {
				lappend params c1 $shader_params($id,c1)
			}
		}
	}

	if { [string length $shader_params($id,c2) ] > 0 } then {
		catch {
			if { [vec_compare $shader_params($id,c2) $shader_params($id,def_c2) 3] } then {
				lappend params c2 $shader_params($id,c2)
			}
		}
	}

	if { [string length $shader_params($id,c3) ] > 0 } then {
		catch {
			if { [vec_compare $shader_params($id,c3) $shader_params($id,def_c3) 3] } then {
				lappend params c3 $shader_params($id,c3)
			}
		}
	}

	if { [string length $shader_params($id,delta) ] > 0 } then {
		catch {
			if { [vec_compare $shader_params($id,delta) $shader_params($id,def_delta) 3] } then {
				lappend params d $shader_params($id,delta)
			}
		}
	}

	set shade_str [list camo $params]
}

proc set_camo_defaults { id } {
	global shader_params

	set shader_params($id,def_lacun) 2.1753974
	set shader_params($id,def_hval) 1.0
	set shader_params($id,def_octaves) 4.0
	set shader_params($id,def_size) 1.0
	set shader_params($id,def_scale) { 1.0 1.0 1.0 }
	set shader_params($id,def_c1) { 97  74 41 }
	set shader_params($id,def_c2) { 26 77 10 }
	set shader_params($id,def_c3) { 38 38 38 }
	set shader_params($id,def_t1) -0.25
	set shader_params($id,def_t2) 0.25
	set shader_params($id,def_delta) { 1000.0 1000.0 1000.0 }
}

# Projection routines
proc do_prj {  shade_var id } {
	global shader_params
	upvar #0 $shade_var shader_str

	catch { destroy $shader_params($id,window).fr }
	frame $shader_params($id,window).fr

	label $shader_params($id,window).fr.fname -text "Parameter File"
	entry $shader_params($id,window).fr.fname_e -width 20 -textvariable shader_params($id,fname)
	bind $shader_params($id,window).fr.fname_e <KeyRelease> "do_shader_apply $shade_var $id"

	hoc_register_data $shader_params($id,window).fr.fname "File Name" {
		{summary "The projection shader projects one or more images on the object.\n\
			All the parameters required by the projection shader are\n\
			expected to be supplied in a single file. The MGED command\n\
			'prj_add' may be used to construct this file."}

		{description "The name of the file containing the parameters for\n\
			the projection shader"}
	}
	hoc_register_data $shader_params($id,window).fr.fname_e "File Name" {
		{summary "The projection shader projects one or more images on the object.\n\
			All the parameters required by the projection shader are\n\
			expected to be supplied in a single file. The MGED command\n\
			'prj_add' may be used to construct this file."}
		{description "The name of the file containing the parameters for\n\
			the projection shader"}
	}

	set_prj_values $shader_str $id

	grid $shader_params($id,window).fr.fname -row 0 -column 0 -sticky e
	grid $shader_params($id,window).fr.fname_e -row 0 -column 1 -sticky w

	grid $shader_params($id,window).fr -sticky ew -ipadx 3 -ipady 3

	return $shader_params($id,window).fr
}

proc set_prj_values { shader_str id } {
	global shader_params

	set shader_params($id,fname) ""

	if { [llength $shader_str] > 1 } then {
		set params [lindex $shader_str 1]
	        set shader_name [lindex $shader_str 0]
	        if { $shader_name != "prj" } {
		    return
		}
	} else {
		set params ""
	}
	set err [catch {set list_len [llength $params]}]
	if { $err } {set list_len 0}
	if { $list_len > 0 } then {
		set shader_params($id,fname) [lindex $params 0]
	}
}

proc do_prj_apply { shade_var id } {
	global shader_params
	upvar #0 $shade_var shade_str

	set params ""

	if { [string length $shader_params($id,fname) ] > 0 } then {
		lappend params $shader_params($id,fname)
	}

	set shade_str [list prj $params]
}

proc set_prj_defaults { id } {
	global shader_params

	set shader_params($id,fname) ""
}

# FAKESTAR routines
proc do_fakestar { shade_var id } {
	global shader_params
	upvar #0 $shade_var shader_str

	catch { destroy $shader_params($id,window).fr }
	frame $shader_params($id,window).fr

	label $shader_params($id,window).fr.fakestar_m \
	    -text "There are no parameters to set \n\
                   for the fakestar texture map"
	hoc_register_data $shader_params($id,window).fr.fakestar_m "Fake Star" {
		{summary "The Fake Star texture maps an imaginary star field onto the object."}
	}

	grid $shader_params($id,window).fr.fakestar_m -sticky ew
	grid $shader_params($id,window).fr -ipadx 3 -pady 3

	grid columnconfigure $shader_params($id,window).fr.fakestar_m 0 -weight 1
	grid columnconfigure $shader_params($id,window).fr 0 -weight 1

	return $shader_params($id,window).fr
}

proc set_fakestar_values { shader_str id } {
#	there are none
	return
}

proc do_fakestar_apply { shade_var id } {
	return
}

proc set_fakestar_defaults { id } {
	return
}

# TESTMAP routines
proc do_testmap { shade_var id } {
	global shader_params
	upvar #0 $shade_var shader_str

	catch { destroy $shader_params($id,window).fr }
	frame $shader_params($id,window).fr

	label $shader_params($id,window).fr.tst_m -text "There are no parameters to set for the testmap"
	hoc_register_data $shader_params($id,window).fr.tst_m "Testmap" {
		{summary "The 'testmap' shader maps red and blue colors onto the object\n\
			based on the 'uv' coordinates. The colors vary from (0 0 0) at\n\
			'uv' == (0,0) to (255 0 255) at 'uv' == (1,1)."}
	}

	grid $shader_params($id,window).fr.tst_m -sticky ew
	grid $shader_params($id,window).fr -ipadx 3 -ipady 3

	grid columnconfigure $shader_params($id,window).fr.tst_m 0 -weight 1
	grid columnconfigure $shader_params($id,window).fr 0 -weight 1

	return $shader_params($id,window).fr
}

proc set_testmap_values { shader_str id } {
#	there are none
	return
}

proc do_testmap_apply { shade_var id } {
	return
}

proc set_testmap_defaults { id } {
	return
}

# CHECKER routines
proc do_checker { shade_var id } {
	global shader_params
	upvar #0 $shade_var shader_str

	catch { destroy $shader_params($id,window).fr }
	frame $shader_params($id,window).fr

	label $shader_params($id,window).fr.color1 -text "First Color"
	entry $shader_params($id,window).fr.color1_e -width 15 -textvariable shader_params($id,ckr_a)
	bind $shader_params($id,window).fr.color1_e <KeyRelease> "do_shader_apply $shade_var $id"
	label $shader_params($id,window).fr.color2 -text "Second Color"
	entry $shader_params($id,window).fr.color2_e -width 15 -textvariable shader_params($id,ckr_b)
	bind $shader_params($id,window).fr.color2_e <KeyRelease> "do_shader_apply $shade_var $id"
	label $shader_params($id,window).fr.scale -text "Scale"
	entry $shader_params($id,window).fr.scale_e -width 15 -textvariable shader_params($id,ckr_scale)
	bind $shader_params($id,window).fr.scale_e <KeyRelease> "do_shader_apply $shade_var $id"

	hoc_register_data $shader_params($id,window).fr.color1_e "First Color" {
		{summary "Enter one of the colors to use in the checkerboard pattern\n\
			default here is '255 255 255'"}
		{range "An RGB triple, each value from 0 to 255"}
	}
	hoc_register_data $shader_params($id,window).fr.color2_e "Second Color" {
		{summary "Enter another color to use in the checkerboard pattern\n\
			default here is '0 0 0'"}
		{range "An RGB triple, each value from 0 to 255"}
	}
	hoc_register_data $shader_params($id,window).fr.color1 "First Color" {
		{summary "Enter one of the colors to use in the checkerboard pattern"}
		{range "An RGB triple, each value from 0 to 255"}
	}
	hoc_register_data $shader_params($id,window).fr.color2 "Second Color" {
		{summary "Enter another color to use in the checkerboard pattern"}
		{range "An RGB triple, each value from 0 to 255"}
	}
	hoc_register_data $shader_params($id,window).fr.scale "Scale" {
		{summary "Enter a scale factor to use for the checkerboard pattern\n\
			(Allows different numbers of checks)"}
		{range "Non-zero positive numbers"}
	}
	hoc_register_data $shader_params($id,window).fr.scale_e "Scale" {
		{summary "Enter a scale factor to use for the checkerboard pattern\n\
			(Allows different numbers of checks)"}
		{range "Non-zero positive numbers"}
	}

	set_checker_values $shader_str $id

	grid $shader_params($id,window).fr.color1 -row 0 -column 0 -sticky e
	grid $shader_params($id,window).fr.color1_e -row 0 -column 1 -sticky w
	grid $shader_params($id,window).fr.color2 -row 1 -column 0 -sticky e
	grid $shader_params($id,window).fr.color2_e -row 1 -column 1 -sticky w
	grid $shader_params($id,window).fr.scale -row 2 -column 0 -sticky e
	grid $shader_params($id,window).fr.scale_e -row 2 -column 1 -sticky w

	grid columnconfigure $shader_params($id,window).fr.color1_e 0 -weight 1
	grid columnconfigure $shader_params($id,window).fr.color2_e 0 -weight 1

	grid $shader_params($id,window).fr -sticky new -ipadx 3 -ipady 3
	grid columnconfigure $shader_params($id,window).fr 0 -weight 1
	grid columnconfigure $shader_params($id,window).fr 1 -weight 1

	return $shader_params($id,window).fr
}

proc set_checker_values { shader_str id } {
	global shader_params

	set shader_params($id,ckr_a) $shader_params($id,def_ckr_a)
	set shader_params($id,ckr_b) $shader_params($id,def_ckr_b)
	set shader_params($id,ckr_scale) $shader_params($id,def_ckr_scale)

	if { [llength $shader_str] > 1 } then {
		set params [lindex $shader_str 1]
	        set shader_name [lindex $shader_str 0]
	        if { $shader_name != "checker" } {
		    return
		}
	} else {
		set params ""
	}
	set err [catch {set list_len [llength $params]}]
	if { $err } {set  list_len 0}
	if { $list_len > 1 } then {

		for { set index 0 } { $index < $list_len } { set index [expr $index + 2] } {
			set key [lindex $params $index]
			set value [lindex $params [expr $index + 1]]

			switch $key {
				a { catch {
					if { $value != $shader_params($id,def_ckr_a) } then {
						set shader_params($id,ckr_a) $value }
				    }
				}

				b { catch {
					if { $value != $shader_params($id,def_ckr_b) } then {
						set shader_params($id,ckr_b) $value }
				    }
				}
				s { catch {
					if { $value != $shader_params($id,def_ckr_scale) } then {
						set shader_params($id,ckr_scale) $value }
				    }
				}
			}
		}
	}
}

proc do_checker_apply { shade_var id } {
	global shader_params
	upvar #0 $shade_var shader

	set params ""

	# check each parameter to see if it's been set
	# if set to the default, ignore it
	catch {
		if { [string length $shader_params($id,ckr_a) ] > 0 } then {
			if { $shader_params($id,ckr_a) != $shader_params($id,def_ckr_a) } then {
				lappend params a $shader_params($id,ckr_a)
			}
		}
	}
	catch {
		if { [string length $shader_params($id,ckr_b) ] > 0 } then {
			if { $shader_params($id,ckr_b) != $shader_params($id,def_ckr_b) } then {
				lappend params b $shader_params($id,ckr_b)
			}
		}
	}
	catch {
		if { [string length $shader_params($id,ckr_scale) ] > 0 } then {
			if { $shader_params($id,ckr_scale) != $shader_params($id,def_ckr_scale) } then {
				lappend params s $shader_params($id,ckr_scale)
			}
		}
	}

	set shader [list checker $params ]
}

proc set_checker_defaults { id } {
	global shader_params

	set shader_params($id,def_ckr_a) [list 255 255 255]
	set shader_params($id,def_ckr_b) [list 0 0 0]
	set shader_params($id,def_ckr_scale) 2.0
}

# PHONG routines

proc do_plastic { shade_var id } {
	return [do_phong $shade_var $id]
}

proc do_mirror { shade_var id } {
	return [do_phong $shade_var $id]
}

proc do_glass { shade_var id } {
	return [do_phong $shade_var $id]
}

proc do_phong { shade_var id } {
	global shader_params
	upvar #0 $shade_var shader_str

	catch { destroy $shader_params($id,window).fr }
	frame $shader_params($id,window).fr

	label $shader_params($id,window).fr.trans -text Transparency
	entry $shader_params($id,window).fr.trans_e -width 5 -textvariable shader_params($id,trans)
	bind $shader_params($id,window).fr.trans_e <KeyRelease> "do_shader_apply $shade_var $id"
	label $shader_params($id,window).fr.refl -text "mirror reflectance"
	entry $shader_params($id,window).fr.refl_e -width 5 -textvariable shader_params($id,refl)
	bind $shader_params($id,window).fr.refl_e <KeyRelease> "do_shader_apply $shade_var $id"
	label $shader_params($id,window).fr.spec -text "Specular reflectivity"
	entry $shader_params($id,window).fr.spec_e -width 5 -textvariable shader_params($id,spec)
	bind $shader_params($id,window).fr.spec_e <KeyRelease> "do_shader_apply $shade_var $id"
	label $shader_params($id,window).fr.diff -text "Diffuse reflectivity"
	entry $shader_params($id,window).fr.diff_e -width 5 -textvariable shader_params($id,diff)
	bind $shader_params($id,window).fr.diff_e <KeyRelease> "do_shader_apply $shade_var $id"
	label $shader_params($id,window).fr.ri -text "Refractive index"
	entry $shader_params($id,window).fr.ri_e -width 5 -textvariable shader_params($id,ri)
	bind $shader_params($id,window).fr.ri_e <KeyRelease> "do_shader_apply $shade_var $id"
	label $shader_params($id,window).fr.shine -text Shininess
	entry $shader_params($id,window).fr.shine_e -width 5 -textvariable shader_params($id,shine)
	bind $shader_params($id,window).fr.shine_e <KeyRelease> "do_shader_apply $shade_var $id"
	label $shader_params($id,window).fr.ext -text Extinction
	entry $shader_params($id,window).fr.ext_e -width 5 -textvariable shader_params($id,ext)
	bind $shader_params($id,window).fr.ext_e <KeyRelease> "do_shader_apply $shade_var $id"
	label $shader_params($id,window).fr.emiss -text Emission
	entry $shader_params($id,window).fr.emiss_e -width 5 -textvariable shader_params($id,emiss)
	bind $shader_params($id,window).fr.emiss_e <KeyRelease> "do_shader_apply $shade_var $id"

	hoc_register_data $shader_params($id,window).fr.emiss Emissivity {
		{summary "In addition to reflecting and transmitting light,\n\
			an object may also emit or absorb light. This paramter\n\
			describes that property."}
		{description "Emissivity/absorption"}
		{range "-1.0 through 1.0"}
	}

	hoc_register_data $shader_params($id,window).fr.emiss_e Emissivity {
		{summary "In addition to reflecting and transmitting light,\n\
			an object may also emit or absorb light. This paramter\n\
			describes that property."}
		{description "Emissivity/absorption"}
		{range "-1.0 through 1.0"}
	}

	hoc_register_data $shader_params($id,window).fr.trans Transparency {
		{summary "The observer can see diffuse and specular reflections from\n\
			an object as well as transmitted and/or reflected images.\n\
			The transparency is the fraction of light that will be\n\
			transmitted through the object. The mirror reflectance is\n\
			the fraction of light that will be reflected as a mirror image.\n\
			The fraction of light remaining after transmission and mirror\n\
			reflection is divided between diffuse and specular reflections\n\
			The diffuse and specular reflections are what the observer uses to\n\
			perceive the color and shape of an object. Transparency plus mirror\n\
			reflectance is typically less than 1.0, and diffuse plus specular\n\
			is typically equal to 1.0."}
		{description "The fraction of light that will be\n\
			transmitted through this object" }
		{range "0.0 through 1.0"}
	}

	hoc_register_data $shader_params($id,window).fr.trans_e Transparency {
		{summary "The observer can see diffuse and specular reflections from\n\
			an object as well as transmitted and/or reflected images.\n\
			The transparency is the fraction of light that will be\n\
			transmitted through the object. The mirror reflectance is\n\
			the fraction of light that will be reflected as a mirror image.\n\
			The fraction of light remaining after transmission and mirror\n\
			reflection is divided between diffuse and specular reflections\n\
			The diffuse and specular reflections are what the observer uses to\n\
			perceive the color and shape of an object. Transparency plus mirror\n\
			reflectance is typically less than 1.0, and diffuse plus specular\n\
			is typically equal to 1.0."}
		{description "Enter the fraction of light that\n\
			will be transmitted through this object"}
		{range "0.0 through 1.0"}
	}

	hoc_register_data $shader_params($id,window).fr.refl "Mirror Reflectivity" {
		{summary "The observer can see diffuse and specular reflections from\n\
			an object as well as transmitted and/or reflected images.\n\
			The transparency is the fraction of light that will be\n\
			transmitted through the object. The mirror reflectance is\n\
			the fraction of light that will be reflected as a mirror image.\n\
			The fraction of light remaining after transmission and mirror\n\
			reflection is divided between diffuse and specular reflections\n\
			The diffuse and specular reflections are what the observer uses to\n\
			perceive the color and shape of an object. Transparency plus mirror\n\
			reflectance is typically less than 1.0, and diffuse plus specular\n\
			is typically equal to 1.0."}
		{description "The fraction of light that will be reflected\n\
			by the surface of this object"}
		{range "0.0 through 1.0" }
	}

	hoc_register_data $shader_params($id,window).fr.refl_e "Mirror Reflectivity" {
		{summary "The observer can see diffuse and specular reflections from\n\
			an object as well as transmitted and/or reflected images.\n\
			The transparency is the fraction of light that will be\n\
			transmitted through the object. The mirror reflectance is\n\
			the fraction of light that will be reflected as a mirror image.\n\
			The fraction of light remaining after transmission and mirror\n\
			reflection is divided between diffuse and specular reflections\n\
			The diffuse and specular reflections are what the observer uses to\n\
			perceive the color and shape of an object. Transparency plus mirror\n\
			reflectance is typically less than 1.0, and diffuse plus specular\n\
			is typically equal to 1.0."}
		{description "Enter the fraction of light that will be reflected\n\
			by the surface of this object"}
		{range "0.0 through 1.0" }
	}

	hoc_register_data $shader_params($id,window).fr.spec "Specular Reflectivity" {
		{summary "The observer can see diffuse and specular reflections from\n\
			an object as well as transmitted and/or reflected images.\n\
			The transparency is the fraction of light that will be\n\
			transmitted through the object. The mirror reflectance is\n\
			the fraction of light that will be reflected as a mirror image.\n\
			The fraction of light remaining after transmission and mirror\n\
			reflection is divided between diffuse and specular reflections\n\
			The diffuse and specular reflections are what the observer uses to\n\
			perceive the color and shape of an object. Transparency plus mirror\n\
			reflectance is typically less than 1.0, and diffuse plus specular\n\
			is typically equal to 1.0."}
		{description "Enter the fraction of light that will be specularly reflected\n\
			by the surface of this object"}
		{range "0.0 through 1.0" }
	}

	hoc_register_data $shader_params($id,window).fr.spec_e "Specular Reflectivity" {
		{summary "The observer can see diffuse and specular reflections from\n\
			an object as well as transmitted and/or reflected images.\n\
			The transparency is the fraction of light that will be\n\
			transmitted through the object. The mirror reflectance is\n\
			the fraction of light that will be reflected as a mirror image.\n\
			The fraction of light remaining after transmission and mirror\n\
			reflection is divided between diffuse and specular reflections\n\
			The diffuse and specular reflections are what the observer uses to\n\
			perceive the color and shape of an object. Transparency plus mirror\n\
			reflectance is typically less than 1.0, and diffuse plus specular\n\
			is typically equal to 1.0."}
		{description "Enter the fraction of light that will be specularly reflected\n\
			by the surface of this object"}
		{range "0.0 through 1.0" }
	}

	hoc_register_data $shader_params($id,window).fr.diff "Diffuse Reflectivity" {
		{summary "The observer can see diffuse and specular reflections from\n\
			an object as well as transmitted and/or reflected images.\n\
			The transparency is the fraction of light that will be\n\
			transmitted through the object. The mirror reflectance is\n\
			the fraction of light that will be reflected as a mirror image.\n\
			The fraction of light remaining after transmission and mirror\n\
			reflection is divided between diffuse and specular reflections\n\
			The diffuse and specular reflections are what the observer uses to\n\
			perceive the color and shape of an object. Transparency plus mirror\n\
			reflectance is typically less than 1.0, and diffuse plus specular\n\
			is typically equal to 1.0."}
		{description "Enter the fraction of light that will be diffusely reflected\n\
			by the surface of this object"}
		{range "0.0 through 1.0" }
	}

	hoc_register_data $shader_params($id,window).fr.diff_e "Diffuse Reflectivity" {
		{summary "The observer can see diffuse and specular reflections from\n\
			an object as well as transmitted and/or reflected images.\n\
			The transparency is the fraction of light that will be\n\
			transmitted through the object. The mirror reflectance is\n\
			the fraction of light that will be reflected as a mirror image.\n\
			The fraction of light remaining after transmission and mirror\n\
			reflection is divided between diffuse and specular reflections\n\
			The diffuse and specular reflections are what the observer uses to\n\
			perceive the color and shape of an object. Transparency plus mirror\n\
			reflectance is typically less than 1.0, and diffuse plus specular\n\
			is typically equal to 1.0."}
		{description "Enter the fraction of light that will be diffusely reflected\n\
			by the surface of this object"}
		{range "0.0 through 1.0" }
	}

	hoc_register_data $shader_params($id,window).fr.ri_e "Index of Refraction" {
		{summary "This is the index of refraction for this material. The index for\n\
			air is 1.0. This parameter is only useful for materials that have\n\
			a non-zero transparency."}
		{range "not less than 1.0"}
	}

	hoc_register_data $shader_params($id,window).fr.shine_e "Shininess" {
		{summary "An indication of the 'shininess' of this material. A higher number\n\
			will make the object look more shiney"}
		{range "integer values from 1 to 10"}
	}

	hoc_register_data $shader_params($id,window).fr.ext_e "Extinction" {
		{summary "Fraction of light absorbed per linear meter of this material.\n\
			The default value here is 0.0."}
		{range "non-negative"}
	}

#	set variables from current 'params' list

	set_phong_values $shader_str $id

	grid $shader_params($id,window).fr.trans -row 0 -column 0 -sticky e
	grid $shader_params($id,window).fr.trans_e -row 0 -column 1 -sticky w
	grid $shader_params($id,window).fr.refl -row 0 -column 2 -sticky e
	grid $shader_params($id,window).fr.refl_e -row 0 -column 3 -sticky w
	grid $shader_params($id,window).fr.spec -row 1 -column 0 -sticky e
	grid $shader_params($id,window).fr.spec_e -row 1 -column 1 -sticky w
	grid $shader_params($id,window).fr.diff -row 1 -column 2 -sticky e
	grid $shader_params($id,window).fr.diff_e -row 1 -column 3 -sticky w
	grid $shader_params($id,window).fr.ri -row 2 -column 0 -sticky e
	grid $shader_params($id,window).fr.ri_e -row 2 -column 1 -sticky w
	grid $shader_params($id,window).fr.shine -row 3 -column 0 -sticky e
	grid $shader_params($id,window).fr.shine_e -row 3 -column 1 -sticky w
	grid $shader_params($id,window).fr.ext -row 2 -column 2 -sticky e
	grid $shader_params($id,window).fr.ext_e -row 2 -column 3 -sticky w
	grid $shader_params($id,window).fr.emiss -row 3 -column 2 -sticky e
	grid $shader_params($id,window).fr.emiss_e -row 3 -column 3 -sticky w
	
	grid $shader_params($id,window).fr -sticky new -ipadx 3 -ipady 3
	return $shader_params($id,window).fr
}

proc set_plastic_values { shader_str id } {
	set_phong_values $shader_str $id
}

proc set_glass_values { shader_str id } {
	set_phong_values $shader_str $id
}

proc set_mirror_values { shader_str id } {
	set_phong_values $shader_str $id
}

proc set_phong_values { shader_str id } {
	global shader_params

	set shader_params($id,trans) $shader_params($id,def_trans)
	set shader_params($id,refl) $shader_params($id,def_refl)
	set shader_params($id,spec) $shader_params($id,def_spec)
	set shader_params($id,diff) $shader_params($id,def_diff)
	set shader_params($id,ri) $shader_params($id,def_ri)
	set shader_params($id,shine) $shader_params($id,def_shine)
	set shader_params($id,ext) $shader_params($id,def_ext)
	set shader_params($id,emiss) $shader_params($id,def_emiss)

	if { [llength $shader_str] > 1 } then {
		set params [lindex $shader_str 1]
	        set shader_name [lindex $shader_str 0]
	        if { $shader_name != "plastic" && $shader_name != "glass" && $shader_name != "mirror" } {
		    return
		}
	} else {
		set params ""
	}
	set err [catch {set list_len [llength $params]}]
	if { $err } {set list_len 0}
	if { $list_len > 1 } then {

		for { set index 0 } { $index < $list_len } { set index [expr $index + 2] } {
			set key [lindex $params $index]
			set value [lindex $params [expr $index + 1]]

			switch $key {
				ri { catch {
					if { $value != $shader_params($id,def_ri) } then {
						set shader_params($id,ri) $value }
				     }
				}

				shine -
				sh { catch {
					if { $value != $shader_params($id,def_shine) } then {
						set shader_params($id,shine) $value }
				     }
				}

				specular -
				sp { catch {
					if { $value != $shader_params($id,def_spec) } then {
						set shader_params($id,spec) $value }
				     }
				}

				diffuse -
				di { catch {
					if { $value != $shader_params($id,def_diff) } then {
						set shader_params($id,diff) $value }
				     }
				}

				transmit -
				tr { catch {
					if { $value != $shader_params($id,def_trans) } then {
						set shader_params($id,trans) $value }
				     }
				}

				reflect -
				re { catch {
					if { $value != $shader_params($id,def_refl) } then {
						set shader_params($id,refl) $value }
				     }
				}

				extinction_per_meter -
				extinction -
				ex { catch {
					if { $value != $shader_params($id,def_ext) } then {
						set shader_params($id,ext) $value }
				     }
				}
				emission -
				em { catch {
					if { $value != $shader_params($id,def_emiss) } then {
						set shader_params($id,emiss) $value }
					}
				}
			}
		}
	}
}

proc do_plastic_apply { shade_var id } {
	upvar #0 $shade_var shader

	set params [do_phong_apply $id]

	set shader [list plastic $params]
}

proc do_glass_apply { shade_var id } {
	upvar #0 $shade_var shader

	set params [do_phong_apply $id]

	set shader [list glass $params]
}

proc do_mirror_apply { shade_var id } {
	upvar #0 $shade_var shader

	set params [do_phong_apply $id]

	set shader [list mirror $params]
}


proc do_phong_apply { id } {
	global shader_params

	set params ""

	# check each parameter to see if it's been set
	# if set to the default, ignore it
	if { [string length $shader_params($id,trans) ] > 0 } then {
	    catch {
		if { [expr $shader_params($id,trans) != $shader_params($id,def_trans)] } then {
			lappend params tr $shader_params($id,trans) } }
	    }
	if { [string length $shader_params($id,refl) ] > 0 } then {
	    catch {
		if { [expr $shader_params($id,refl) != $shader_params($id,def_refl)] } then {
			lappend params re $shader_params($id,refl) } }
	    }
	if { [string length $shader_params($id,spec) ] > 0 } then {
	    catch {
		if { [expr $shader_params($id,spec) != $shader_params($id,def_spec)] } then {
			lappend params sp $shader_params($id,spec) } }
	    }
	if { [string length $shader_params($id,diff) ] > 0 } then {
	    catch {
		if { [expr $shader_params($id,diff) != $shader_params($id,def_diff)] } then {
			lappend params di $shader_params($id,diff) } }
	    }
	if { [string length $shader_params($id,ri) ] > 0 } then {
	    catch {
		if { [expr $shader_params($id,ri) != $shader_params($id,def_ri)] } then {
			lappend params ri $shader_params($id,ri) } }
	    }
	if { [string length $shader_params($id,shine)] > 0 } then {
	    catch {
		if { [expr $shader_params($id,shine) != $shader_params($id,def_shine)] } then {
			lappend params sh $shader_params($id,shine) } }
	    }
	if { [string length $shader_params($id,ext)] > 0 } then {
	    catch {
		if { [expr $shader_params($id,ext) != $shader_params($id,def_ext)] } then {
			lappend params ex $shader_params($id,ext) } }
	    }
	if { [string length $shader_params($id,emiss)] > 0 } then {
	    catch {
		if { [expr $shader_params($id,emiss) != $shader_params($id,def_emiss)] } then {
			lappend params em $shader_params($id,emiss) } }
	    }

	return "$params"
}

proc set_plastic_defaults { id } {
	global shader_params

	set shader_params($id,def_shine) 10
	set shader_params($id,def_spec) 0.7
	set shader_params($id,def_diff) 0.3
	set shader_params($id,def_trans) 0
	set shader_params($id,def_refl) 0
	set shader_params($id,def_ri) 1.0
	set shader_params($id,def_ext) 0
	set shader_params($id,def_emiss) 0
}

proc set_mirror_defaults { id } {
	global shader_params

	set shader_params($id,def_shine) 4
	set shader_params($id,def_spec) 0.6
	set shader_params($id,def_diff) 0.4
	set shader_params($id,def_trans) 0
	set shader_params($id,def_refl) 0.75
	set shader_params($id,def_ri) 1.65
	set shader_params($id,def_ext) 0
	set shader_params($id,def_emiss) 0
}

proc set_glass_defaults { id } {
	global shader_params

	set shader_params($id,def_shine) 4
	set shader_params($id,def_spec) 0.7
	set shader_params($id,def_diff) 0.3
	set shader_params($id,def_trans) 0.8
	set shader_params($id,def_refl) 0.1
	set shader_params($id,def_ri) 1.65
	set shader_params($id,def_ext) 0
	set shader_params($id,def_emiss) 0
}

# TEXTURE MAP routines

proc set_bump_defaults { id } {
	set_texture_defaults $id
}

proc set_bwtexture_defaults { id } {
	set_texture_defaults $id
}

proc set_texture_defaults { id } {
	global shader_params

	set shader_params($id,def_width) 512
	set shader_params($id,def_height) 512
}

proc set_bump_values { shader_str id } {
	set_texture_values $shader_str $id
}

proc set_bwtexture_values { shader_str id } {
	set_texture_values $shader_str $id
}

proc set_texture_values { shader_str id } {
	global shader_params

#       make sure all the entry variables start empty

	set shader_params($id,transp) ""
	set shader_params($id,trans_valid) 0
	set shader_params($id,file) ""
	set shader_params($id,width) $shader_params($id,def_width)
	set shader_params($id,height) $shader_params($id,def_height)
	set shader_params($id,mirror) 0
	set shader_params($id,tx_scale_u) 1
	set shader_params($id,tx_scale_v) 1

	if { [llength $shader_str] > 1 } then {
		set params [lindex $shader_str 1]
	        set shader_name [lindex $shader_str 0]
	        if { $shader_name != "bump" && $shader_name != "bwtexture" && $shader_name != "texture" } {
		    return
		}
	} else {
		set params ""
	}
	set err [catch {set list_len [llength $params]}]
	if { $err } {set list_len 0}
	if { $list_len > 1 } then {

		for { set index 0 } { $index < $list_len } { set index [expr $index + 2] } {
			set key [lindex $params $index]
			set value [lindex $params [expr $index + 1]]

			switch $key {
				w { catch {
					if { $value != $shader_params($id,def_width) } then {
						set shader_params($id,width) $value }
				    }
				}

				n -
				l { catch {
					if { $value != $shader_params($id,def_height) } then {
						set shader_params($id,height) $value }
				    }
				}

				transp {
						set shader_params($id,transp) $value
				}

				trans_valid {
						if { $value != 0 } then {
							set shader_params($id,trans_valid) 1
						} else {
							set shader_params($id,trans_valid) 0
						}
				}

				file {
						set shader_params($id,file) $value
				}

				m {
					set shader_params($id,mirror) $value
				}

				uv {
					set uv_list [string map {","  " " } $value]
					set shader_params($id,tx_scale_u) [lindex $uv_list 0]
					set shader_params($id,tx_scale_v) [lindex $uv_list 1]
				}
			}
		}
	}
}

set light_data {
	e	fraction	f	1.0	"fraction of total light contributed"		"0..1" 		0 0 \
	e	angle		a	180	"angle of light cone"				"0..180" 	1 0 \
	e	target		d	{0 0 0}	"Point to which light is directed\n   (angle must be less than 180)"   "any X,Y,Z"	2 0 \
	e	lumens		b	1.0	"Lumens for Photon mapping" 		        "And Real #"	3 0 \
	c	infinite 	i	0	"Boolean: light is infinite distance away"	"0,1" 		3 2 \
	c	visible 	v	1	"Boolean: light souce object can be seen"	"0,1" 		3 3 \
	i	icon		icon	""	"Shows effect of values for:\n  Shadow Rays\n  infinite\n  visible" "" 0 4 \
    }


proc set_light_defaults { id } {
	global shader_params
	global light_data

	foreach {type name abbrev def_val desc range row col } $light_data {
		set shader_params(def_light_$abbrev) $def_val
	}

	set shader_params(def_light_s) 1
}

proc assign_light_defaults { id } {
	global shader_params
	global light_data

	foreach {type name abbrev def_val desc range row col } $light_data {
		set shader_params($id,light_$abbrev) $def_val
	}

	set shader_params($id,light_s) $shader_params(def_light_s)
}

proc do_light { shade_var id } {
	global shader_params
	global light_data
	upvar #0 $shade_var shader_str

	# Destroy our frame in case it already exists
	catch { destroy $shader_params($id,window).fr }
 
	# Create a frame for the widgets for this shader
	frame $shader_params($id,window).fr


	# For each variable, create a label and an entry widgets
	# and bind <KeyRelease> so that the shader string wil be updated

	set w $shader_params($id,window).fr

	assign_light_defaults $id


	# Load the images
	if { [info exists shader_params(light_i0_v0_s0)] == 0 } {
	    foreach i { 0 1 } {
		foreach v { 0 1 } {
		    foreach s { 0 1 2 3 4 5 6 7 8 9 } {
			set shader_params(light_i${i}_v${v}_s${s}) \
			  [image create photo -file \
				[bu_brlcad_path \
				    "tclscripts/mged/l_i${i}_v${v}_s${s}.gif"]]
		    }
		}
	    }
	}




	foreach {type name abbrev def_val summary range row col } $light_data {
	    switch $type {
		e {
		    # Create the labeled entry widgets
		    grid [label $w.${abbrev}_lbl -text $name ] -row $row -column $col
		    grid [entry $w.${abbrev}_ent -width 10 -textvariable shader_params($id,light_$abbrev)]\
			 -row $row -column [expr $col + 1]

		    bind $w.${abbrev}_ent <KeyRelease> "do_shader_apply $shade_var $id"

		    hoc_register_data $w.${abbrev}_lbl $name [list [list summary $summary] [list range "$range (default: $def_val)"]]
		    hoc_register_data $w.${abbrev}_ent $name [list [list summary $summary] [list range "$range (default: $def_val)"]]
		}
		c {
		   # Create checkboxes
		    grid [checkbutton $w.${abbrev} -text $name -relief sunken -bd 3 \
			-variable shader_params($id,light_$abbrev) \
			-command "do_shader_apply $shade_var $id"] \
			-row $row -column $col

		    hoc_register_data $w.${abbrev} $name [list [list summary $summary] [list range "$range (default: $def_val)"]]
		}
		i {
		   # Create label to display the selected image

		    grid [label $w.icon -relief sunken -bd 3 \
			-image $shader_params(light_i0_v1_s1) ] \
			-rowspan 3 -row $row -column $col
		    hoc_register_data $w.icon shadows [list [list summary $summary]]

		    set shader_params($id,icon) $w.icon
		}
	    }
	}

	# Create the scale for shadow rays
	grid [scale $w.shadows -orient horiz -label "Shadow Rays" \
		-from 0 -to 9 -bd 3 -relief sunken \
		-command "light_scale $shade_var $id $w.icon"\
		-variable shader_params($id,light_s) ] \
		-row 0 -column 2 -rowspan 3 -columnspan 2 -sticky nesw
        hoc_register_data $w.shadows shadows [list [list summary "number of rays to fire at light source in determining shadow\n0 rays means no shadows"] [list range "0..9"]]



	# Set the entry widget values from the current shader string
	set_light_values $shader_str $id

	# Grid the shader widget window into the parent widget
	grid $shader_params($id,window).fr -sticky ew -ipadx 3 -ipady 3

	# weight the columns of the grid evenly
	grid columnconfigure $shader_params($id,window).fr 0 -weight 1
	grid columnconfigure $shader_params($id,window).fr 1 -weight 1

	return $shader_params($id,window).fr
}

# set the entry widget values from the shader string and
# fill in the gui variables

# called when user modifies shader string directly
proc set_light_values { shader_str id } {
	global shader_params

	# grab OUR shader parameters from the shader string
	if { [llength $shader_str] > 1 } then {
		set params [lindex $shader_str 1]
	        set shader_name [lindex $shader_str 0]
	        if { $shader_name != "light" } {
		    return
		}
	} else {
		set params ""
	}

	set err [catch {set list_len [llength $params]}]
	if { $err } {set  list_len 0}
	if { $list_len > 1 } then {

	    # For each of my parameters, set 
	    foreach { key value } $params {

		switch -- $key {
		    default {
				tk_messageBox -message "key $key value $value"
		    }
		    infinite -
		    i { set shader_params($id,light_i) $value }
		    visible -
		    v {	set shader_params($id,light_v) $value }
		    shadows -
		    s {	set shader_params($id,light_s) $value }
		    bright -
		    b {	set shader_params($id,light_b) $value }
		    angle -
		    a { set shader_params($id,light_a) $value }
		    fraction -
		    f { set shader_params($id,light_f) $value }
		    direct -
		    d { set shader_params($id,light_d) $value }
		}
	    }
	}

	do_light_icon $id

}
# Since the scale appends a value to the end of it's args, we can't
# use do_shader_apply directly for scale widgets  That's why we have this
# wrapper proc
proc light_scale {shade_var id icon val args} {
	global shader_params
	do_shader_apply $shade_var $id
}

# This routine takes the values in the shader_params array and creates
# A shader string from it.
# This is called when the user modifies a value in one of the entry widgets
proc do_light_apply { shade_var id } {
	global shader_params
	upvar #0 $shade_var shader

	set params ""

	set pattern ($id,light_)(\[a-z\]*)
	foreach i [array names shader_params] {
	    if { [regexp $pattern $i name head varname] && \
	         $shader_params($id,light_$varname) != \
	         $shader_params(def_light_$varname) } {
			lappend params $varname $shader_params($id,light_$varname)
		}
	}

	do_light_icon $id

	set shader [list "light" $params ]
}

proc do_light_icon { id } {
	global shader_params

	set name ""

	append name "light_i" $shader_params($id,light_i) 
	append name "_v"  $shader_params($id,light_v)
	append name "_s"  $shader_params($id,light_s)

	$shader_params($id,icon) configure -image $shader_params($name)
}


######################################################################


proc do_bump_apply { shade_var id } {
	do_texture_apply $shade_var $id
}

proc do_bwtexture_apply { shade_var id } {
	do_texture_apply $shade_var $id
}

proc do_texture_apply { shade_var id } {
	global shader_params
	upvar #0 $shade_var shader

	set params ""

	# check each parameter to see if it's been set
	# if set to the default, ignore it
	if { [string length $shader_params($id,file) ] > 0 } then {
			lappend params file $shader_params($id,file) }
	if { [string length $shader_params($id,width) ] > 0 } then {
	    catch {
		if { $shader_params($id,width) != $shader_params($id,def_width) } then {
			lappend params w $shader_params($id,width) } }
	    }
	if { [string length $shader_params($id,height) ] > 0 } then {
	    catch {
		if { $shader_params($id,height) != $shader_params($id,def_height) } then {
			lappend params n $shader_params($id,height) } }
	    }
	if { [string length $shader_params($id,transp) ] > 0 } then {
			lappend params transp $shader_params($id,transp) }
	if { $shader_params($id,trans_valid) != 0 } then {
			if { [string length $shader_params($id,transp) ] == 0 } then {
				tk_messageBox -type ok -icon error -title "ERROR: Missing transparency RGB" -message "Cannot set transparency to valid without a transparency color"
				set shader_params($id,trans_valid) 0
			} else {
				lappend params trans_valid 1 }
	}
	if { [string length $shader_params($id,mirror)] > 0 } then {
		if { $shader_params($id,mirror) != 0 } {
			lappend params m $shader_params($id,mirror)
		}
	}
	if { [string length $shader_params($id,tx_scale_u)] > 0 || [string length $shader_params($id,tx_scale_v)] > 0 } then {
		if { $shader_params($id,tx_scale_u) != 1 || $shader_params($id,tx_scale_v) != 1 } {
			lappend params uv $shader_params($id,tx_scale_u),$shader_params($id,tx_scale_v)
		}
	}

	set shader [list $shader_params($id,shader_name) $params ]
}

proc do_bump { shade_var id } {
	return [do_texture $shade_var $id]
}

proc do_bwtexture { shade_var id } {
	return [do_texture $shade_var $id]
}

proc do_texture { shade_var id } {
    global shader_params
    upvar #0 $shade_var shader_str

    catch { destroy $shader_params($id,window).fr }
    frame $shader_params($id,window).fr
    frame $shader_params($id,window).fr.file_fr -relief flat
    frame $shader_params($id,window).fr.repl -relief groove -bd 2
    frame $shader_params($id,window).fr.transp_fr -relief flat

    label $shader_params($id,window).fr.file_fr.file -text "Texture File Name"
    entry $shader_params($id,window).fr.file_fr.file_e -width 20 \
	-textvariable shader_params($id,file)
    bind $shader_params($id,window).fr.file_fr.file_e <KeyRelease> "do_shader_apply $shade_var $id"
    label $shader_params($id,window).fr.file_fr.width -text "File Width (pixels)"
    entry $shader_params($id,window).fr.file_fr.width_e -width 5 \
	-textvariable shader_params($id,width)
    bind $shader_params($id,window).fr.file_fr.width_e <KeyRelease> "do_shader_apply $shade_var $id"
    label $shader_params($id,window).fr.file_fr.height -text "File height (pixels)"
    entry $shader_params($id,window).fr.file_fr.height_e -width 5 \
	-textvariable shader_params($id,height)
    bind $shader_params($id,window).fr.file_fr.height_e \
	<KeyRelease> "do_shader_apply $shade_var $id"
    label $shader_params($id,window).fr.repl.mirror -text "Mirror Adjacent tiles"
    checkbutton $shader_params($id,window).fr.repl.mirror_e \
	-variable shader_params($id,mirror) \
	-command "do_shader_apply $shade_var $id"
    label $shader_params($id,window).fr.repl.u_scale -text "in U-direction"
    entry $shader_params($id,window).fr.repl.u_scale_e -width 4 \
	-textvariable shader_params($id,tx_scale_u)
    bind $shader_params($id,window).fr.repl.u_scale_e <KeyRelease> "do_shader_apply $shade_var $id"
    label $shader_params($id,window).fr.repl.v_scale -text "in V-direction"
    entry $shader_params($id,window).fr.repl.v_scale_e -width 4 \
	-textvariable shader_params($id,tx_scale_v)
    bind $shader_params($id,window).fr.repl.v_scale_e <KeyRelease> "do_shader_apply $shade_var $id"
    label $shader_params($id,window).fr.transp_fr.trans -text "Transparency (RGB)"
    entry $shader_params($id,window).fr.transp_fr.trans_e -width 11 \
	-textvariable shader_params($id,transp)
    bind $shader_params($id,window).fr.transp_fr.trans_e <KeyRelease> \
	"do_shader_apply $shade_var $id"
    checkbutton $shader_params($id,window).fr.transp_fr.valid_e \
	-variable shader_params($id,trans_valid) \
	-command  "do_shader_apply $shade_var $id"

    hoc_register_data $shader_params($id,window).fr.file_e File {
	{ summary "Enter the name of the file containing the texture to be mapped to this\n\
		object. This file should be a 'pix' file for the 'texture' or 'bump' shaders,\n\
		or a 'bw' file for 'bwtexture'. For the 'bump' shader, the red and blue\n\
		channels of the image are used to perturb the true surface normal.\n\
		Red and blue values of 128 produce no perturbation, while values of 0\n\
		produce maximum perturbation in one direction and 255 produces maximum\n\
		perturbation in the opposite"}
    }

    hoc_register_data $shader_params($id,window).fr.width_e Width {
	{ summary "Enter the width of the texture in pixels\n(default is 512)"}
    }

    hoc_register_data $shader_params($id,window).fr.height_e Height {
	{ summary "Enter the height of the texture in pixels\n(default is 512)"}
    }

    hoc_register_data $shader_params($id,window).fr.transp_fr.trans_e Transparency {
	{ summary "Enter the color in the texture that will be treated as\n\
		transparent. All pixels on this object that get assigned this\n\
		color from the texture will be treated as though this object\n\
		does not exist. For the 'texture' shader, this must be an RGB\n\
		triple. For the 'bwtexture' shader, a single value is sufficient\n\
		This is ignored for the 'bump' shader"}
	{ range "RGB values must be integers from 0 to 255"}
    }

    hoc_register_data $shader_params($id,window).fr.repl.mirror Mirror {
	{ summary "Turn this option on to get smooth transitions between adjacent tiles\n\
		of the texture by mirroring. This only has an effect when texture\n\
		replication is greater than 1"}
    }

    hoc_register_data $shader_params($id,window).fr.repl.mirror_e Mirror {
	{ summary "Turn this option on to get smooth transitions between adjacent tiles\n\
		of the texture by mirroring. This only has an effect when texture\n\
		replication is greater than 1"}
    }

    hoc_register_data $shader_params($id,window).fr.repl.u_scale "Texture Replication" {
	{summary "Each object being shaded has UV coordinates from 0 through 1.0 used to\n\
		lookup which part of the texture should be applied where.  Normally,\n\
		one entire copy of the texture is stretched or compressed to fit the object.\n\
		This is changed when a value other than 1 is entered here. The value entered here\n\
		specifies the number of texture patterns to be used across the object in the U\n\
		parameter direction"}
	{ range "Real numbers greater than 0.0" }
    }

    hoc_register_data $shader_params($id,window).fr.repl.u_scale_e "Texture Replication" {
	{summary "Each object being shaded has UV coordinates from 0 through 1.0 used to\n\
		lookup which part of the texture should be applied where.  Normally,\n\
		one entire copy of the texture is stretched or compressed to fit the object.\n\
		This is changed when a value other than 1 is entered here. The value entered here\n\
		specifies the number of texture patterns to be used across the object in the U\n\
		parameter direction"}
	{ range "Real numbers greater than 0.0" }
    }

    hoc_register_data $shader_params($id,window).fr.repl.v_scale "Texture Replication" {
	{summary "Each object being shaded has UV coordinates from 0 through 1.0 used to\n\
		lookup which part of the texture should be applied where.  Normally,\n\
		one entire copy of the texture is stretched or compressed to fit the object.\n\
		This is changed when a value other than 1 is entered here. The value entered here\n\
		specifies the number of texture patterns to be used across the object in the V\n\
		parameter direction"}
	{ range "Real numbers greater than 0.0" }
    }

    hoc_register_data $shader_params($id,window).fr.repl.v_scale_e "Texture Replication" {
	{summary "Each object being shaded has UV coordinates from 0 through 1.0 used to\n\
		lookup which part of the texture should be applied where.  Normally,\n\
		one entire copy of the texture is stretched or compressed to fit the object.\n\
		This is changed when a value other than 1 is entered here. The value entered here\n\
		specifies the number of texture patterns to be used across the object in the V\n\
		parameter direction"}
	{ range "Real numbers greater than 0.0" }
    }

    hoc_register_data $shader_params($id,window).fr.transp_fr.valid_e Transparency {
	{ summary "If depressed, transparency is enabled using the transparency\n\
		color. Otherwise, the transparency color is ignored. The 'bump'\n\
		shader does not use this button."}
    }

    hoc_register_data $shader_params($id,window).fr.file File {
	{ summary "Enter the name of the file containing the texture to be mapped to this\n\
		object. This file should be a 'pix' file for the 'texture' or 'bump' shaders,\n\
		or a 'bw' file for 'bwtexture'. For the 'bump' shader, the red and blue\n\
		channels of the image are used to perturb the true surface normal.\n\
		Red and blue values of 128 produce no perturbation, while values of 0\n\
		produce maximum perturbation in one direction and 255 produces maximum\n\
		perturbation in the opposite"}
    }
    
    hoc_register_data $shader_params($id,window).fr.width Width {
	{ summary "Enter the width of the texture in pixels\n(default is 512)"}
    }

    hoc_register_data $shader_params($id,window).fr.height Height {
	{ summary "Enter the height of the texture in pixels\n(default is 512)"}
    }

    hoc_register_data $shader_params($id,window).fr.transp_fr.trans Transparency {
	{ summary "Enter the color in the texture that will be treated as\n\
		transparent. All pixels on this object that get assigned this\n\
		color from the texture will be treated as though this object\n\
		does not exist. For the 'texture' shader, this must be an RGB\n\
		triple. For the 'bwtexture' shader, a single value is sufficient.\n\
		The checkbutton to the left must be depressed for transparency\n\
		to be active. This is ignored for the 'bump' shader"}
	{ range "RGB values must be integers from 0 to 255"}
    }

#	set variables from current 'params' list

    set_texture_values $shader_str $id

    label $shader_params($id,window).fr.repl.repl_label \
	-text "Texture Replication"
    grid $shader_params($id,window).fr.repl.repl_label \
	-row 0 -column 0 -columnspan 4 -sticky ew
    grid $shader_params($id,window).fr.repl.u_scale \
	-row 1 -column 0 -sticky e
    grid $shader_params($id,window).fr.repl.u_scale_e \
	-row 1 -column 1 -sticky w
    grid $shader_params($id,window).fr.repl.v_scale \
	-row 1 -column 2 -sticky e
    grid $shader_params($id,window).fr.repl.v_scale_e \
	-row 1 -column 3 -sticky w
    grid $shader_params($id,window).fr.repl.mirror_e \
	-row 2 -column 1 -sticky e
    grid $shader_params($id,window).fr.repl.mirror \
	-row 2 -column 2 -sticky w

    grid $shader_params($id,window).fr.file_fr.file -row 0 -column 0 -sticky e
    grid $shader_params($id,window).fr.file_fr.file_e -row 0 -column 1 -columnspan 3 -sticky ew
    grid $shader_params($id,window).fr.file_fr.width -row 1 -column 0 -sticky e
    grid $shader_params($id,window).fr.file_fr.width_e -row 1 -column 1 -sticky w
    grid $shader_params($id,window).fr.file_fr.height -row 1 -column 2 -sticky e
    grid $shader_params($id,window).fr.file_fr.height_e -row 1 -column 3 -sticky w
    grid $shader_params($id,window).fr.file_fr -row 0 -column 0 -sticky ew
    grid columnconfigure $shader_params($id,window).fr.file_fr 0 -weight 1
    grid columnconfigure $shader_params($id,window).fr.file_fr 1 -weight 1
    grid columnconfigure $shader_params($id,window).fr.file_fr 2 -weight 1
    grid columnconfigure $shader_params($id,window).fr.file_fr 3 -weight 1
    grid $shader_params($id,window).fr.repl -row 1 -column 0 -sticky nsew
    grid $shader_params($id,window).fr.transp_fr.valid_e -row 0 -column 0 -sticky w
    grid $shader_params($id,window).fr.transp_fr.trans -row 0 -column 1 -sticky e
    grid $shader_params($id,window).fr.transp_fr.trans_e -row 0 -column 2 -sticky w
    grid $shader_params($id,window).fr.transp_fr -row 2 -column 0
    
    grid $shader_params($id,window).fr -sticky new -ipadx 3 -ipady 3
    grid columnconfigure $shader_params($id,window).fr 0 -weight 1

    return $shader_params($id,window).fr
}

# STACK routines

proc do_stack_apply { shade_var id } {
	global shader_params
	upvar #0 $shade_var shade_str

	# this may be called via a binding in some other shader and so might get the 'id' from
	# that shader. So it may be of the form 'id_#,stk_#' (where # is some number)

	set index [string first ",stk" $id]
	if { $index == -1 } then {
		set use_id $id
	} else {
		set index2 [expr $index - 1]
		set use_id [string range $id 0 $index2]
	}

	set params ""

	for {set index 0} {$index < $shader_params($use_id,stack_len)} {incr index} {
		if { [string compare $shader_params($use_id,stk_$index,window) "deleted"] == 0 } {continue}
		set shade_str $shader_params($use_id,stk_$index,shader_name)
		if { [string length $shade_str] == 0 } {set shade_str unknown}
		set shader_name [lindex $shade_str 0]

		do_shader_apply $shade_var $use_id,stk_$index

		if { [string length $shade_str] == 0 } then {
			lappend params {unknown}
		} else {
			lappend params $shade_str
		}
	}

	if {$params == "" } {
		tk_messageBox -type ok -icon error -title "ERROR: Empty stack"\
			-message "The stack shader is meaningless without placing other shaders in the stack"
		set shade_str stack
	} else {
		set shade_str "stack {$params}"
	}
}

proc set_stack_defaults { id } {
	global shader_params

	set shader_params($id,stack_len) 0
}

proc stack_delete { index shade_var id } {
	global shader_params

	# destroy the shader subwindow
	catch {destroy $shader_params($id,stk_$index,window) }

	# adjust the shader list
	set shader_params($id,stk_$index,window) deleted
	set shader_params($id,stk_$index,shader_name) ""
}

proc stack_add { shader shade_var id childsite} {
	global shader_params

	set index $shader_params($id,stack_len)
	incr shader_params($id,stack_len)
	frame $childsite.stk_$index -bd 2 -relief groove
	set shader_params($id,stk_$index,window) $childsite.stk_$index

	if { [is_good_shader $shader] } then {
		label $childsite.stk_$index.lab -text $shader -bg CadetBlue -fg white
	} else {
		label $childsite.stk_$index.lab -text "Unrecognized Shader" -bg CadetBlue -fg white
	}
	grid $childsite.stk_$index.lab -columnspan 4 -sticky ew
	set shader_params($id,stk_$index,shader_name) $shader

	button $childsite.stk_$index.del -text delete -width 8 \
		-command "stack_delete $index $shade_var $id;\
			do_shader_apply $shade_var $id"
	hoc_register_data $childsite.stk_$index.del "Delete" {
		{summary "The 'stack' shader applies a series of shaders to the\n\
			object being edited. This button will delete one shader\n\
			from the stack"}
	}

	switch $shader {
		plastic {
			set_plastic_defaults "$id,stk_$index"
			set tmp_win [do_phong $shade_var $id,stk_$index]
		}
		glass {
			set_glass_defaults "$id,stk_$index"
			set tmp_win [do_phong $shade_var $id,stk_$index]
		}
		mirror {
			set_mirror_defaults "$id,stk_$index"
			set tmp_win [do_phong $shade_var $id,stk_$index]
		}
		light {
			set_light_defaults "$id,light_$index"
			set tmp_win [do_light $shade_var $id,stk_$index]
		}
		bump -
		bwtexture -
		texture {
			set_texture_defaults "$id,stk_$index"
			set tmp_win [do_texture $shade_var $id,stk_$index]
		}
		checker {
			set_checker_defaults "$id,stk_$index"
			set tmp_win [do_checker $shade_var $id,stk_$index]
		}
		testmap {
			set_testmap_defaults "$id,stk_$index"
			set tmp_win [do_testmap $shade_var $id,stk_$index]
		}
		fakestar {
			set_fakestar_defaults "$id,stk_$index"
			set tmp_win [do_fakestar $shade_var $id,stk_$index]
		}
		cloud {
			set_cloud_defaults "$id,stk_$index"
			set tmp_win [do_cloud $shade_var $id,stk_$index]
		}
		prj {
			set_prj_defaults "$id,stk_$index"
			set tmp_win [do_prj $shade_var $id,stk_$index]
		}
		camo {
			set_camo_defaults "$id,stk_$index"
			set tmp_win [do_camo $shade_var $id,stk_$index]
		}
		air {
			set_air_defaults "$id,stk_$index"
			set tmp_win [do_air $shade_var $id,stk_$index]
		}
		default {
			set_unknown_defaults "$id,stk_$index"
			set tmp_win [do_unknown $shade_var $id,stk_$index]
		}
	}

	grid $childsite.stk_$index.del -columnspan 4
	grid $childsite.stk_$index -columnspan 2 -sticky ew
	grid columnconfigure $childsite.stk_$index 0 -minsize 400
}

# do not call this routine without first deleting the index_th window
proc stack_insert { index shader shade_var id } {
	global shader_params

    set childsite [$shader_params($id,window).fr.leesf childsite]
	frame $childsite.stk_$index -relief raised -bd 3
	set shader_params($id,stk_$index,window) $childsite.stk_$index

	if { [is_good_shader $shader] } then {
		label $childsite.stk_$index.lab -text $shader -bg CadetBlue -fg white
	} else {
		label $childsite.stk_$index.lab -text "Unrecognized Shader" -bg CadetBlue -fg white
	}
	button $childsite.stk_$index.del -text delete -width 8 \
		-command "stack_delete $index $shade_var $id;\
			do_shader_apply $shade_var $id"
	hoc_register_data $childsite.stk_$index.del "Delete" {
		{summary "The 'stack' shader applies a series of shaders to the\n\
			object being edited. This button will delete one shader\n\
			from the stack"}
	}

	grid $childsite.stk_$index.lab -columnspan 4 -sticky ew
	set shader_params($id,stk_$index,shader_name) $shader

	switch $shader {
		plastic {
			set_plastic_defaults "$id,stk_$index"
			set tmp_win [do_phong $shade_var $id,stk_$index]
		}
		glass {
			set_glass_defaults "$id,stk_$index"
			set tmp_win [do_phong $shade_var $id,stk_$index]
		}
		mirror {
			set_mirror_defaults "$id,stk_$index"
			set tmp_win [do_phong $shade_var $id,stk_$index]
		}
		light {
			set_light_defaults "$id,light_$index"
			set tmp_win [do_light $shade_var $id,light_$index]
		}
		bump -
		bwtexture -
		texture {
			set_texture_defaults "$id,stk_$index"
			set tmp_win [do_texture $shade_var $id,stk_$index]
		}
		checker {
			set_checker_defaults "$id,stk_$index"
			set tmp_win [do_checker $shade_var $id,stk_$index]
		}
		testmap {
			set_testmap_defaults "$id,stk_$index"
			set tmp_win [do_testmap $shade_var $id,stk_$index]
		}
		fakestar {
			set_fakestar_defaults "$id,stk_$index"
			set tmp_win [do_fakestar $shade_var $id,stk_$index]
		}
		cloud {
			set_cloud_defaults "$id,stk_$index"
			set tmp_win [do_cloud $shade_var $id,stk_$index]
		}
		camo {
			set_camo_defaults "$id,stk_$index"
			set tmp_win [do_camo $shade_var $id,stk_$index]
		}
		prj {
			set_prj_defaults "$id,stk_$index"
			set tmp_win [do_prj $shade_var $id,stk_$index]
		}
		air {
			set_air_defaults "$id,stk_$index"
			set tmp_win [do_air $shade_var $id,stk_$index]
		}
		default {
			set_unknown_defaults "$id,stk_$index"
			set tmp_win [do_unknown $shade_var $id,stk_$index]
		}
	}
	grid $childsite.stk_$index.del -columnspan 4 -sticky ew

	set index 0
	for { set i 0 } { $i < $shader_params($id,stack_len) } { incr i } {
		if { [string compare $shader_params($id,stk_$i,window) "deleted"] == 0 } continue
		grid $childsite.stk_$i -columnspan 2 -sticky ew -row [expr $index + 2]
		grid columnconfigure $childsite.stk_$i 0 -minsize 400 -weight 1
		incr index
	}
}

proc set_stack_values { shade_str id } {
	global shader_params

	set err [catch "set shade_length [llength $shade_str]"]
	if { $err != 0 } {return}

	if {$shade_length < 2 } {return}

	# get  shader name (should be stack, or maybe envmap)
	set shader [lindex $shade_str 0]

	# get parameters (this should be the list of shaders in the stack)
	set shader_list [lindex $shade_str 1]

	# if this is an envmap using a stack, get the stack stuff out of the shader_list
	if { [string compare $shader envmap] == 0 } {
		# envmap shader using a stack
		set err [catch "set shade_length [llength $shader_list]"]
		if { $err != 0 } {return}

		if {$shade_length < 2 } {return}

		 set shader [lindex $shader_list 0]
		 set shader_list [lindex $shader_list 1]
	}

	set err [catch "set no_of_shaders [llength $shader_list]"]
	if { $err != 0 } {return}

	# process each shader in the list
	for {set index 0} {$index < $no_of_shaders} {incr index } {
		# get the index_th shader from the shader list
		set sub_str [lindex $shader_list $index]
		set shader [lindex $sub_str 0]

		# if we are beyond the current stack length, then we need to add another shader to the stack
		if { $index >= $shader_params($id,stack_len) } {
			# add another shader frame
			stack_add $shader $shader_params($id,shade_var) $id [$shader_params($id,window).fr.leesf childsite]
			if { [is_good_shader $shader]} then {
				set_${shader}_values $sub_str $id,stk_$index
			} else {
				set_unknown_values $sub_str $id,stk_$index
			}
		} else {
			# make mods to existing frame
			set count -1
			for { set i 0 } { $i < $shader_params($id,stack_len) } { incr i } {
				# ignore deleted windows
				if { [string compare $shader_params($id,stk_$i,window) "deleted"] == 0 } continue
				incr count

				# $shader should match $shader_params($id,stk_$i,shader_name)
				if { $count == $index } then {
					if { [string compare $shader_params($id,stk_$i,shader_name) $shader] == 0 } then {
						# shader name hasn't changed, so just set the new values
						if { [is_good_shader $shader] } then {
							set_${shader}_values $sub_str $id,stk_$i
						} else {
							set_unknown_values $sub_str $id,stk_$i
						}
					} else {
						# shader name has changed
						if { [is_good_shader $shader] } then {
							# new shader is recognized replace the old with the new
							stack_delete $i $shader_params($id,shade_var) $id
							stack_insert $i $shader $shader_params($id,shade_var) $id
							set_${shader}_values $sub_str $id,stk_$i
						} elseif { [is_good_shader $shader_params($id,stk_$i,shader_name)] } then {
							# new shader is unrecognized, but old is recognized, replace
							stack_delete $i $shader_params($id,shade_var) $id
							stack_insert $i $shader $shader_params($id,shade_var) $id
							if { [string length $sub_str] == 0 } then {
								set_unknown_values unknown $id,stk_$i
							}  else {
								set_unknown_values $sub_str $id,stk_$i
							}
						} else {
							# old shader is unrecognized and new is unrecognized, just update values
							set_unknown_values $sub_str $id,stk_$i
						}
					}
				}
			}
		}
	}
}

proc do_stack { shade_var id } {
	global shader_params
	upvar #0 $shade_var shade_str

	catch { destroy $shader_params($id,window).fr }
	frame $shader_params($id,window).fr -padx 3 -pady 3

    set childsite [[iwidgets::scrolledframe $shader_params($id,window).fr.leesf -width 432 -height 250 -hscrollmode dynamic ] childsite]

	set shader_params($id,shade_var) $shade_var

	menubutton $shader_params($id,window).fr.add\
		-menu $shader_params($id,window).fr.add.m\
		-text "Add shader" -relief raised
	hoc_register_data $shader_params($id,window).fr.add "Add Shader" {
		{summary "Use this menu to select a shader to add to\n\
			the end of the stack"}
	}

	menu $shader_params($id,window).fr.add.m -tearoff 0
	$shader_params($id,window).fr.add.m add command \
		-label plastic -command "stack_add plastic $shade_var $id $childsite; do_shader_apply $shade_var $id"
	$shader_params($id,window).fr.add.m add command \
		-label glass -command "stack_add glass $shade_var $id $childsite; do_shader_apply $shade_var $id"
	$shader_params($id,window).fr.add.m add command \
		-label mirror -command "stack_add mirror $shade_var $id $childsite; do_shader_apply $shade_var $id"

	$shader_params($id,window).fr.add.m add command \
		-label light -command "stack_add light $shade_var $id $childsite; do_shader_apply $shade_var $id"

	$shader_params($id,window).fr.add.m add command \
		-label "bump map" -command "stack_add bump $shade_var $id $childsite; do_shader_apply $shade_var $id"
	$shader_params($id,window).fr.add.m add command \
		-label texture -command "stack_add texture $shade_var $id $childsite; do_shader_apply $shade_var $id"
	$shader_params($id,window).fr.add.m add command \
		-label bwtexture -command "stack_add bwtexture $shade_var $id $childsite; do_shader_apply $shade_var $id"
	$shader_params($id,window).fr.add.m add command \
		-label fakestar -command "stack_add fakestar $shade_var $id $childsite; do_shader_apply $shade_var $id"
	$shader_params($id,window).fr.add.m add command \
		-label cloud -command "stack_add cloud $shade_var $id $childsite; do_shader_apply $shade_var $id"
	$shader_params($id,window).fr.add.m add command \
		-label checker -command "stack_add checker $shade_var $id $childsite; do_shader_apply $shade_var $id"
	$shader_params($id,window).fr.add.m add command \
		-label camouflage -command "stack_add camo $shade_var $id $childsite; do_shader_apply $shade_var $id"
	$shader_params($id,window).fr.add.m add command \
		-label projection -command "stack_add prj $shade_var $id $childsite; do_shader_apply $shade_var $id"
	$shader_params($id,window).fr.add.m add command \
		-label air -command "stack_add air $shade_var $id $childsite; do_shader_apply $shade_var $id"
	$shader_params($id,window).fr.add.m add command \
		-label testmap -command "stack_add testmap $shade_var $id $childsite; do_shader_apply $shade_var $id"
	$shader_params($id,window).fr.add.m add command \
		-label Unknown -command "stack_add unknown $shade_var $id $childsite; do_shader_apply $shade_var $id"

    grid $shader_params($id,window).fr.add -columnspan 2 -row 0
    grid $shader_params($id,window).fr.leesf -sticky nsew -row 1
    grid columnconfigure $shader_params($id,window).fr 0 -weight 1
    grid rowconfigure $shader_params($id,window).fr 1 -weight 1

    grid rowconfigure $shader_params($id,window) 0 -weight 1
    grid rowconfigure $shader_params($id,window) 1 -weight 0
    grid columnconfigure $shader_params($id,window) 0 -weight 1
    grid $shader_params($id,window).fr -sticky ewns
    grid rowconfigure $shader_params($id,window).fr 1 -weight 1

    set_stack_values $shade_str $id

    return $shader_params($id,window).fr
}

proc env_select { shader shade_var id } {
	global shader_params

	if { [winfo exists $shader_params($id,window).fr.env] } {
		set err [catch "set tmp $shader_params($id,env,shader_name)"]
		if { $err != 0 } {
			set old_shader ""
		} else {
			set old_shader $tmp
		}
	} else {
		set old_shader ""
	}

	if { [string compare $old_shader $shader] == 0 } {return}
	set shader_params($id,env,shader_name) $shader

	catch {destroy $shader_params($id,window).fr.env}
	frame $shader_params($id,window).fr.env -relief raised -bd 3
	set shader_params($id,env,window) $shader_params($id,window).fr.env

	label $shader_params($id,window).fr.env.lab -text $shader
	grid $shader_params($id,window).fr.env.lab -columnspan 4 -sticky ew
	grid $shader_params($id,window).fr.env -sticky ew
	grid columnconfigure $shader_params($id,window).fr.env 0 -minsize 400

	switch $shader {
		plastic {
			set_plastic_defaults "$id,env"
			set tmp_win [do_phong $shade_var $id,env]
		}
		glass {
			set_glass_defaults "$id,env"
			set tmp_win [do_phong $shade_var $id,env]
		}
		mirror {
			set_mirror_defaults "$id,env"
			set tmp_win [do_phong $shade_var $id,env]
		}
		light {
			set_light_defaults "$id,light_$index"
			set tmp_win [do_light $shade_var $id,light_$index]
		}
		bump -
		bwtexture -
		texture {
			set_texture_defaults "$id,env"
			set tmp_win [do_texture $shade_var $id,env]
		}
		checker {
			set_checker_defaults "$id,env"
			set tmp_win [do_checker $shade_var $id,env]
		}
		testmap {
			set_testmap_defaults "$id,env"
			set tmp_win [do_testmap $shade_var $id,env]
		}
		fakestar {
			set_fakestar_defaults "$id,env"
			set tmp_win [do_fakestar $shade_var $id,env]
		}
		cloud {
			set_cloud_defaults "$id,env"
			set tmp_win [do_cloud $shade_var $id,env]
		}
		stack {
			set_stack_defaults "$id,env"
			set tmp_win [do_stack $shade_var $id,env]
		}
		prj {
			set_prj_defaults "$id,env"
			set tmp_win [do_prj $shade_var $id,env]
		}
		camo {
			set_camo_defaults "$id,env"
			set tmp_win [do_camo $shade_var $id,env]
		}
		air {
			set_air_defaults "$id,env"
			set tmp_win [do_air $shade_var $id,env]
		}
		default {
			set_unknown_defaults "$id,env"
			set tmp_win [do_unknown $shade_var $id,env]
		}
	}
#	do_envmap_apply $shade_var $id
}

proc set_envmap_defaults { id } {
	set shader_params($id,env,shader_name) ""
}

proc do_envmap_apply { shade_var id } {
	global shader_params
	upvar #0 $shade_var shade_str

	set params ""

# this may be called via a binding in some other shader and so might get the 'id' from
# that shader. So it may be of the form 'id_#,env' (where # is some number)

	set index [string first ",env" $id]
	if { $index == -1 } then {
		set use_id $id
	} else {
		set index2 [expr $index - 1]
		set use_id [string range $id 0 $index2]
	}

	set shade_str $shader_params($use_id,env,shader_name)
	do_shader_apply $shade_var $use_id,env
	set params $shade_str

	if {$params == "" } {
		tk_messageBox -type ok -icon error -title "ERROR: Empty envmap"\
			-message "The envmap shader is meaningless without selecting another shader as the environmant"
		set shade_str envmap
	} else {
		set shade_str "envmap {$params}"
	}
}

proc set_envmap_values { shade_str id } {
	global shader_params

	set err [catch "set shade_length [llength $shade_str]"]
	if { $err != 0 } {return}

	if { $shade_length < 2 } { return }
	set err [catch {set env_params [lindex $shade_str 1]}]
	if { $err } {return}
	set err [catch "set sub_len [llength $env_params]"]
	if { $err != 0 } {return}

	set shader [lindex $env_params 0]

	if { [winfo exists $shader_params($id,window).fr.env] } {
		set err [catch "set tmp $shader_params($id,env,shader_name)"]
		if { $err != 0 } {
			set old_shader ""
		} else {
			set old_shader $tmp
		}
	} else {
		set old_shader ""
	}

	if { [string compare $old_shader $shader] != 0 }  then {
		if { [is_good_shader $old_shader] || [is_good_shader $shader]} then {
			env_select $shader $shader_params($id,shade_var) $id
		}
	}
	if { [is_good_shader $shader] } then {
		set_${shader}_values $env_params $id,env
	} else {
		set_unknown_values $env_params $id,env
	}
}

proc do_envmap { shade_var id } {
	global shader_params
	upvar #0 $shade_var shade_str

	catch { destroy $shader_params($id,window).fr }
	frame $shader_params($id,window).fr

	set shader_params($id,shade_var) $shade_var

	menubutton $shader_params($id,window).fr.sel_env\
		-menu $shader_params($id,window).fr.sel_env.m\
		-text "Select shader" -relief raised
	hoc_register_data $shader_params($id,window).fr.sel_env "Select Shader" {
		{summary "Use this menu to select a shader for the environment map"}
	}

	menu $shader_params($id,window).fr.sel_env.m -tearoff 0
	$shader_params($id,window).fr.sel_env.m add command \
		-label plastic -command "env_select plastic $shade_var $id; do_shader_apply $shade_var $id"
	$shader_params($id,window).fr.sel_env.m add command \
		-label glass -command "env_select glass $shade_var $id; do_shader_apply $shade_var $id"
	$shader_params($id,window).fr.sel_env.m add command \
		-label mirror -command "env_select mirror $shade_var $id; do_shader_apply $shade_var $id"
	$shader_params($id,window).fr.sel_env.m add command \
		-label "bump map" -command "env_select bump $shade_var $id; do_shader_apply $shade_var $id"
	$shader_params($id,window).fr.sel_env.m add command \
		-label texture -command "env_select texture $shade_var $id; do_shader_apply $shade_var $id"
	$shader_params($id,window).fr.sel_env.m add command \
		-label bwtexture -command "env_select bwtexture $shade_var $id; do_shader_apply $shade_var $id"
	$shader_params($id,window).fr.sel_env.m add command \
		-label fakestar -command "env_select fakestar $shade_var $id; do_shader_apply $shade_var $id"
	$shader_params($id,window).fr.sel_env.m add command \
		-label cloud -command "env_select cloud $shade_var $id; do_shader_apply $shade_var $id"
	$shader_params($id,window).fr.sel_env.m add command \
		-label checker -command "env_select checker $shade_var $id; do_shader_apply $shade_var $id"
	$shader_params($id,window).fr.sel_env.m add command \
		-label camouflage -command "env_select camo $shade_var $id; do_shader_apply $shade_var $id"
	$shader_params($id,window).fr.sel_env.m add command \
		-label projection -command "env_select prj $shade_var $id; do_shader_apply $shade_var $id"
	$shader_params($id,window).fr.sel_env.m add command \
		-label testmap -command "env_select testmap $shade_var $id; do_shader_apply $shade_var $id"
	$shader_params($id,window).fr.sel_env.m add command \
		-label Unrecognized -command "env_select unknown $shade_var $id; do_shader_apply $shade_var $id"
	$shader_params($id,window).fr.sel_env.m add command \
		-label stack -command "env_select stack $shade_var $id; do_shader_apply $shade_var $id"

	grid $shader_params($id,window).fr.sel_env

	grid $shader_params($id,window).fr -sticky ew -ipadx 3 -ipady 3

	set_envmap_values $shade_str $id

	return $shader_params($id,window).fr
}

proc do_cloud { shade_var id } {
	global shader_params
	upvar #0 $shade_var shader_str

	catch { destroy $shader_params($id,window).fr }
	frame $shader_params($id,window).fr

	label $shader_params($id,window).fr.cl_thresh -text Threshold
	entry $shader_params($id,window).fr.cl_thresh_e -width 5 -textvariable shader_params($id,cl_thresh)
	bind $shader_params($id,window).fr.cl_thresh_e <KeyRelease> "do_shader_apply $shade_var $id"
	label $shader_params($id,window).fr.cl_range -text Range
	entry $shader_params($id,window).fr.cl_range_e -width 5 -textvariable shader_params($id,cl_range)
	bind $shader_params($id,window).fr.cl_range_e <KeyRelease> "do_shader_apply $shade_var $id"

	hoc_register_data $shader_params($id,window).fr.cl_thresh Threshold {
		{summary "A value (from 0 to 1) is calculated for each point in the texture\n\
			and compared to the threshold. Values above the threshold are cloud\n\
			otherwise it becomes blue sky. The default value is 0.35"}
		{range "0.0 to 1.0"}
	}
	hoc_register_data $shader_params($id,window).fr.cl_thresh_e Threshold {
		{summary "A value (from 0 to 1) is calculated for each point in the texture\n\
			and compared to the threshold. Values above the threshold are cloud\n\
			otherwise it becomes blue sky. The default value is 0.35"}
		{range "0.0 to 1.0"}
	}
	hoc_register_data $shader_params($id,window).fr.cl_range range {
		{summary "A value (from 0 to 1) is calculated for each point in the texture.\n\
			The range determines what range of values will be used for graduating\n\
			between cloud and blue sky. A range of 0 produces clouds with sharp edges\n\
			The default value is 0.3"}
		{range "0.0 to 1.0"}
	}
	hoc_register_data $shader_params($id,window).fr.cl_range_e range {
		{summary "A value (from 0 to 1) is calculated for each point in the texture.\n\
			The range determines what range of values will be used for graduating\n\
			between cloud and blue sky. A range of 0 produces clouds with sharp edges\n\
			The default value is 0.3"}
		{range "0.0 to 1.0"}
	}

	set_cloud_values $shader_str $id

	grid $shader_params($id,window).fr.cl_thresh -row 0 -column 0 -sticky e
	grid $shader_params($id,window).fr.cl_thresh_e -row 0 -column 1 -sticky w
	grid $shader_params($id,window).fr.cl_range -row 0 -column 2 -sticky e
	grid $shader_params($id,window).fr.cl_range_e -row 0 -column 3 -sticky w

	grid $shader_params($id,window).fr -ipadx 3 -ipady 3 -sticky ew

	return $shader_params($id,window).fr
}

proc set_cloud_values { shader_str id } {
	global shader_params

	set shader_params($id,cl_thresh) $shader_params($id,def_cl_thresh)
	set shader_params($id,cl_range) $shader_params($id,def_cl_range)

	if { [llength $shader_str] > 1 } then {
		set params [lindex $shader_str 1]
	        set shader_name [lindex $shader_str 0]
	        if { $shader_name != "cloud" } {
		    return
		}
	} else {
		set params ""
	}
	set err [catch {set list_len [llength $params]}]
	if { $err } {set list_len 0}
	if { $list_len > 1 } then {
		for { set index 0 } { $index < $list_len } { set index [expr $index + 2] } {
			set key [lindex $params $index]
			set value [lindex $params [expr $index + 1]]
			switch $key {
				thresh { catch {
					if { $value != $shader_params($id,def_cl_thresh) } then {
						set shader_params($id,cl_thresh) $value }
				    }
				}
				range { catch {
					if { $value != $shader_params($id,def_cl_range) } then {
						set shader_params($id,cl_range) $value }
				    }
				}
			}
		}
	}
}

proc do_cloud_apply { shade_var id } {
	global shader_params
	upvar #0 $shade_var shader

	set params ""

	# check each parameter to see if it's been set
	# if set to the default, ignore it
	if { [string length $shader_params($id,cl_thresh) ] > 0 } then {
	    catch {
		if { $shader_params($id,cl_thresh) != $shader_params($id,def_cl_thresh) } then {
			lappend params thresh $shader_params($id,cl_thresh) } }
	    }
	if { [string length $shader_params($id,cl_range) ] > 0 } then {
	    catch {
		if { $shader_params($id,cl_range) != $shader_params($id,def_cl_range) } then {
			lappend params range $shader_params($id,cl_range) } }
	    }

	set shader [list cloud $params ]
}

proc set_cloud_defaults { id } {
	global shader_params

	set shader_params($id,def_cl_thresh) 0.35
	set shader_params($id,def_cl_range) 0.3
}

proc do_unknown { shade_var id } {
	global shader_params
	upvar #0 $shade_var shader_str

	catch { destroy $shader_params($id,window).fr }
	frame $shader_params($id,window).fr

	label $shader_params($id,window).fr.name -text "Shader Name"
	entry $shader_params($id,window).fr.name_e -width 15 -textvariable shader_params($id,unk_name)
	bind $shader_params($id,window).fr.name_e <KeyRelease> "do_shader_apply $shade_var $id"
	label $shader_params($id,window).fr.param -text "Shader Parameters"
	entry $shader_params($id,window).fr.param_e -width 20 -textvariable shader_params($id,unk_param)
	bind $shader_params($id,window).fr.param_e <KeyRelease> "do_shader_apply $shade_var $id"

	hoc_register_data $shader_params($id,window).fr.name_e "Shader Name" {
		{summary "Enter the name of a BRL-CAD shader"}
	}
	hoc_register_data $shader_params($id,window).fr.param_e "Shader Parameters" {
		{summary "Enter the parameters for this BRL-CAD shader"}
	}
	hoc_register_data $shader_params($id,window).fr.name "Shader Name" {
		{summary "Enter the name of a BRL-CAD shader"}
	}
	hoc_register_data $shader_params($id,window).fr.param "Shader Parameters" {
		{summary "Enter the parameters for this BRL-CAD shader"}
	}

	set_unknown_values $shader_str $id

	grid $shader_params($id,window).fr.name -row 0 -column 0 -sticky e
	grid $shader_params($id,window).fr.name_e -row 0 -column 1 -sticky w
	grid $shader_params($id,window).fr.param -row 1 -column 0 -sticky e
	grid $shader_params($id,window).fr.param_e -row 1 -column 1 -sticky w

	grid $shader_params($id,window).fr -sticky ew -ipadx 3 -ipady 3
	grid columnconfigure $shader_params($id,window).fr 0 -weight 0
	grid columnconfigure $shader_params($id,window).fr 1 -weight 1

	return $shader_params($id,window).fr
}

proc set_unknown_values { shader_str id } {
	global shader_params

	set shader_params($id,unk_param) ""

	set err [catch {set shader [lindex $shader_str 0]}]
	if { $err } return
	if { [string compare "stack" $shader] == 0 } then {
		set shader_params($id,unk_name) unknown
	} elseif { [string compare "envmap" $shader] == 0 } then {
		set shader1 ""
		set err [catch {set shader1 [lindex $shader_str 1]}]
		if { $err } return
		set err [catch {set envshader [lindex $shader1 0]}]
		if { $err } return
		set shader_params($id,unk_name) $envshader
		set err [catch {set envparams [lindex $shader1 1]}]
		if { $err } return
		set shader_params($id,unk_param) $envparams
	} else {
		set shader_params($id,unk_name) [lindex $shader_str 0]
		if { [llength $shader_str] > 1 } then {
			set shader_params($id,unk_param) [lindex $shader_str 1]
		}
	}
}

proc do_unknown_apply { shade_var id } {
	global shader_params
	upvar #0 $shade_var shader
	set shader [list $shader_params($id,unk_name) $shader_params($id,unk_param)]

	if { [string length $shader] < 1 } then {
		set shader unknown
	}
}

proc set_unknown_defaults { id } {
	return
}

proc do_air { shade_var id } {
	global shader_params
	upvar #0 $shade_var shader_str

	catch { destroy $shader_params($id,window).fr }
	frame $shader_params($id,window).fr

	label $shader_params($id,window).fr.density -text "Density"
	entry $shader_params($id,window).fr.density_e -width 5 -textvariable shader_params($id,density)
	bind $shader_params($id,window).fr.density_e <KeyRelease> "do_shader_apply $shade_var $id"

	label $shader_params($id,window).fr.delta -text "Delta"
	entry $shader_params($id,window).fr.delta_e -width 5 -textvariable shader_params($id,delta)
	bind $shader_params($id,window).fr.delta_e <KeyRelease> "do_shader_apply $shade_var $id"

	label $shader_params($id,window).fr.scale -text "Scale"
	entry $shader_params($id,window).fr.scale_e -width 5 -textvariable shader_params($id,air_scale)
	bind $shader_params($id,window).fr.scale_e <KeyRelease> "do_shader_apply $shade_var $id"

	hoc_register_data $shader_params($id,window).fr.density "Density" {
		{summary "The 'air' shader implements Beer's law to produce realistic\n\
			fog or haze"}
		{description "The 'density' (optical density) is the fraction of energy\n\
			 scattered or absorbed per meter"}
		{range "non-negative (default is 0.1)"}
	}
	hoc_register_data $shader_params($id,window).fr.density_e "Density" {
		{summary "The 'air' shader implements Beer's law to produce realistic\n\
			fog or haze"}
		{description "The 'density' (optical density) is the fraction of energy\n\
			 scattered or absorbed per meter"}
		{range "non-negative (default is 0.1)"}
	}

	set_air_values $shader_str $id

	grid $shader_params($id,window).fr.density -row 0 -column 0 -sticky e
	grid $shader_params($id,window).fr.density_e -row 0 -column 1 -sticky w
	grid $shader_params($id,window).fr.delta -row 0 -column 2 -sticky e
	grid $shader_params($id,window).fr.delta_e -row 0 -column 3 -sticky w
	grid $shader_params($id,window).fr.scale -row 1 -column 1 -sticky e
	grid $shader_params($id,window).fr.scale_e -row 1 -column 2 -sticky w

	grid $shader_params($id,window).fr -sticky ew -ipadx 3 -ipady 3

	return $shader_params($id,window).fr
}

proc set_air_values { shader_str id } {
	global shader_params

	set shader_params($id,density) $shader_params($id,def_density)
	set shader_params($id,delta) $shader_params($id,def_delta)
	set shader_params($id,air_scale) $shader_params($id,def_air_scale)

	if { [llength $shader_str] > 1 } then {
		set params [lindex $shader_str 1]
	        set shader_name [lindex $shader_str 0]
	        if { $shader_name != "air" } {
		    return
		}
	} else {
		set params ""
	}

	set err [catch {set list_len [llength $params]}]
	if { $err } {set list_len 0}
	if { $list_len > 1 } then {
		for { set index 0 } { $index < $list_len } { set index [expr $index + 2] } {
			set key [lindex $params $index]
			set value [lindex $params [expr $index + 1]]

			switch $key {
				dpm { catch {
						if { $value != $shader_params($id,def_density) } then {
							set shader_params($id,density) $value
						}
					}
				}
				delta -
				d { catch {
						if { $value != $shader_params($id,def_delta) } then {
							set shader_params($id,delta) $value
						}
					}
				}
				scale -
				s { catch {
						if { $value != $shader_params($id,def_air_scale) } then {
							set shader_params($id,air_scale) $value
						}
					}
				}
			}
		}
	}
}

proc do_air_apply { shade_var id } {
	global shader_params
	upvar #0 $shade_var shade_str

	set params ""

	if { [string length $shader_params($id,density) ] > 0 } then {
		if { $shader_params($id,density) != $shader_params($id,def_density) } then {
			lappend params dpm $shader_params($id,density)
		}
	}

	if { [string length $shader_params($id,delta) ] > 0 } then {
		if { $shader_params($id,delta) != $shader_params($id,def_delta) } then {
			lappend params d $shader_params($id,delta)
		}
	}

	if { [string length $shader_params($id,air_scale) ] > 0 } then {
		if { $shader_params($id,air_scale) != $shader_params($id,def_air_scale) } then {
			lappend params s $shader_params($id,air_scale)
		}
	}

	set shade_str [list air $params]
}

proc set_air_defaults { id } {
	global shader_params

	set shader_params($id,def_density) 0.1
	set shader_params($id,def_air_scale) 0.01
	set shader_params($id,def_delta) 0.0
}

# This proc is called whenever the user types in the main 'shader' entry widget
proc set_shader_params { shade_var id } {
	upvar #0 $shade_var shade_str
	global shader_params errorInfo

	set err [catch "set shader [lindex $shade_str 0]"]
	if { $err != 0 } {return}

	#  if possible, just update values in the current frame
	if { [string compare $shader $shader_params($id,shader_name)] == 0 ||
		([is_good_shader $shader] == 0 &&
		 [is_good_shader $shader_params($id,shader_name)] == 0) } then {

		if { [llength [info procs set_${shader}_values]] == 1 } {
			set_${shader}_values $shade_str $id
		} else {
			set_unknown_values $shade_str $id
		}
	} else {
		# we have to replace the current frame with a different shader
		do_shader $shade_var $id $shader_params($id,window)
		return
	}
}

# This is the top-level interface
#	'shade_var' contains the name of the variable that the level 0 caller is using
#	to hold the shader string, e.g., "plastic { sh 8 dp .1 }"
#	These routines will update that variable
proc do_shader { shade_var id frame_name } {
	global shader_params errorInfo
	upvar #0 $shade_var shade_str

	set shader_params($id,parent_window_id) $id
	set shader_params($id,window) $frame_name
	set shader_params($id,shade_var) $shade_var

	set my_win ""

	if { [llength $shade_str] > 0 } then {
		set material [lindex $shade_str 0]
		set shader_params($id,shader_name) $material

		if { [llength [info procs do_$material]] == 1 &&
		     [llength [info procs set_${material}_defaults]] == 1} {
			set_${material}_defaults $id
			set mywin [do_$material $shade_var $id]
		} else {
			set_unknown_defaults $id
			set my_win [do_unknown $shade_var $id]
		}
	}

	return $my_win
}


proc do_shader_apply { shade_var id } {
	upvar #0 $shade_var shader_str

	if { [string length $shader_str] == 0 } { return }

	set current_shader_type [lindex $shader_str 0]

	if { [llength [info procs do_${current_shader_type}_apply]] } {
		do_${current_shader_type}_apply $shade_var $id
	} else {
		do_unknown_apply $shade_var $id
	}
}

proc is_good_shader { shader } {

	return [llength [info procs do_$shader] ]
}
@


1.41
log
@rt.tcl updated for photon mapping under advanced settings and shaders.tcl
updated for the addition of lumens into the light shader for photon mapping.
@
text
@@


1.41.2.1
log
@rt.tcl: sphere invalidation input
shaders.tcl: light attenuation
@
text
@a1196 1

d1217 1
d1542 1
a1542 1
	e	lumens		b	1.0	"Energy of light source.  Energy needed depends on scene size"	"And Real #"	3 0 \
a1544 1
	c	attenuation	t	0	"Boolean: light power decreases over distance.  Initial power specified in lumens."	"0,1" 3 4
@


1.41.2.2
log
@Fixed attenuation for light sources
@
text
@d1545 1
a1545 1
	c	attenuation	atten	0	"Boolean: light power decreases over distance.  Initial power specified in lumens."	"0,1" 3 4
@


1.40
log
@Added a reference to the "widget hierarchy" discussion in comb.tcl
@
text
@d1542 1
@


1.39
log
@changes to make the UI a bit more compact
@
text
@d6 1
@


1.38
log
@bug in light shader, was not recognizing its own shader name
@
text
@d760 3
a762 1
	label $shader_params($id,window).fr.fakestar_m -text "There are no parameters to set for the fakestar texture map"
d885 1
a885 1
	grid $shader_params($id,window).fr -sticky ew -ipadx 3 -ipady 3
d1217 1
a1217 1
	grid $shader_params($id,window).fr -sticky ew -ipadx 3 -ipady 3
d1821 76
a1896 2
	global shader_params
	upvar #0 $shade_var shader_str
d1898 5
a1902 3
	catch { destroy $shader_params($id,window).fr }
	frame $shader_params($id,window).fr
        frame $shader_params($id,window).fr.repl -relief groove -bd 3
d1904 9
a1912 36
	label $shader_params($id,window).fr.file -text "Texture File Name"
	entry $shader_params($id,window).fr.file_e -width 40 -textvariable shader_params($id,file)
	bind $shader_params($id,window).fr.file_e <KeyRelease> "do_shader_apply $shade_var $id"
	label $shader_params($id,window).fr.width -text "File Width (pixels)"
	entry $shader_params($id,window).fr.width_e -width 5 -textvariable shader_params($id,width)
	bind $shader_params($id,window).fr.width_e <KeyRelease> "do_shader_apply $shade_var $id"
	label $shader_params($id,window).fr.height -text "File height (pixels)"
	entry $shader_params($id,window).fr.height_e -width 5 -textvariable shader_params($id,height)
	bind $shader_params($id,window).fr.height_e <KeyRelease> "do_shader_apply $shade_var $id"
	label $shader_params($id,window).fr.repl.mirror -text "Mirror Adjacent tiles"
	checkbutton $shader_params($id,window).fr.repl.mirror_e \
		-variable shader_params($id,mirror) \
		-command "do_shader_apply $shade_var $id"
	label $shader_params($id,window).fr.repl.u_scale -text "in U-direction"
	entry $shader_params($id,window).fr.repl.u_scale_e -width 4 -textvariable shader_params($id,tx_scale_u)
	bind $shader_params($id,window).fr.repl.u_scale_e <KeyRelease> "do_shader_apply $shade_var $id"
	label $shader_params($id,window).fr.repl.v_scale -text "in V-direction"
	entry $shader_params($id,window).fr.repl.v_scale_e -width 4 -textvariable shader_params($id,tx_scale_v)
	bind $shader_params($id,window).fr.repl.v_scale_e <KeyRelease> "do_shader_apply $shade_var $id"
	label $shader_params($id,window).fr.trans -text "Transparency (RGB)"
	entry $shader_params($id,window).fr.trans_e -width 15 -textvariable shader_params($id,transp)
	bind $shader_params($id,window).fr.trans_e <KeyRelease> "do_shader_apply $shade_var $id"
	label $shader_params($id,window).fr.valid -text "Use transparency"
	checkbutton $shader_params($id,window).fr.valid_e \
		-variable shader_params($id,trans_valid) \
		-command  "do_shader_apply $shade_var $id"

	hoc_register_data $shader_params($id,window).fr.file_e File {
		{ summary "Enter the name of the file containing the texture to be mapped to this\n\
			object. This file should be a 'pix' file for the 'texture' or 'bump' shaders,\n\
			or a 'bw' file for 'bwtexture'. For the 'bump' shader, the red and blue\n\
			channels of the image are used to perturb the true surface normal.\n\
			Red and blue values of 128 produce no perturbation, while values of 0\n\
			produce maximum perturbation in one direction and 255 produces maximum\n\
			perturbation in the opposite"}
	}
d1914 9
a1922 3
	hoc_register_data $shader_params($id,window).fr.width_e Width {
		{ summary "Enter the width of the texture in pixels\n(default is 512)"}
	}
d1924 9
a1932 3
	hoc_register_data $shader_params($id,window).fr.height_e Height {
		{ summary "Enter the height of the texture in pixels\n(default is 512)"}
	}
d1934 9
a1942 77
	hoc_register_data $shader_params($id,window).fr.trans_e Transparency {
		{ summary "Enter the color in the texture that will be treated as\n\
			transparent. All pixels on this object that get assigned this\n\
			color from the texture will be treated as though this object\n\
			does not exist. For the 'texture' shader, this must be an RGB\n\
			triple. For the 'bwtexture' shader, a single value is sufficient\n\
			This is ignored for the 'bump' shader"}
		{ range "RGB values must be integers from 0 to 255"}
	}

	hoc_register_data $shader_params($id,window).fr.repl.mirror Mirror {
		{ summary "Turn this option on to get smooth transitions between adjacent tiles\n\
			of the texture by mirroring. This only has an effect when texture\n\
			replication is greater than 1"}
	}

	hoc_register_data $shader_params($id,window).fr.repl.mirror_e Mirror {
		{ summary "Turn this option on to get smooth transitions between adjacent tiles\n\
			of the texture by mirroring. This only has an effect when texture\n\
			replication is greater than 1"}
	}

	hoc_register_data $shader_params($id,window).fr.repl.u_scale "Texture Replication" {
		{summary "Each object being shaded has UV coordinates from 0 through 1.0 used to\n\
			lookup which part of the texture should be applied where.  Normally,\n\
			one entire copy of the texture is stretched or compressed to fit the object.\n\
			This is changed when a value other than 1 is entered here. The value entered here\n\
			specifies the number of texture patterns to be used across the object in the U\n\
			parameter direction"}
		{ range "Real numbers greater than 0.0" }
	}

	hoc_register_data $shader_params($id,window).fr.repl.u_scale_e "Texture Replication" {
		{summary "Each object being shaded has UV coordinates from 0 through 1.0 used to\n\
			lookup which part of the texture should be applied where.  Normally,\n\
			one entire copy of the texture is stretched or compressed to fit the object.\n\
			This is changed when a value other than 1 is entered here. The value entered here\n\
			specifies the number of texture patterns to be used across the object in the U\n\
			parameter direction"}
		{ range "Real numbers greater than 0.0" }
	}

	hoc_register_data $shader_params($id,window).fr.repl.v_scale "Texture Replication" {
		{summary "Each object being shaded has UV coordinates from 0 through 1.0 used to\n\
			lookup which part of the texture should be applied where.  Normally,\n\
			one entire copy of the texture is stretched or compressed to fit the object.\n\
			This is changed when a value other than 1 is entered here. The value entered here\n\
			specifies the number of texture patterns to be used across the object in the V\n\
			parameter direction"}
		{ range "Real numbers greater than 0.0" }
	}

	hoc_register_data $shader_params($id,window).fr.repl.v_scale_e "Texture Replication" {
		{summary "Each object being shaded has UV coordinates from 0 through 1.0 used to\n\
			lookup which part of the texture should be applied where.  Normally,\n\
			one entire copy of the texture is stretched or compressed to fit the object.\n\
			This is changed when a value other than 1 is entered here. The value entered here\n\
			specifies the number of texture patterns to be used across the object in the V\n\
			parameter direction"}
		{ range "Real numbers greater than 0.0" }
	}

	hoc_register_data $shader_params($id,window).fr.valid_e Transparency {
		{ summary "If depressed, transparency is enabled using the transparency\n\
			color. Otherwise, the transparency color is ignored. The 'bump'\n\
			shader does not use this button."}
	}

	hoc_register_data $shader_params($id,window).fr.file File {
		{ summary "Enter the name of the file containing the texture to be mapped to this\n\
			object. This file should be a 'pix' file for the 'texture' or 'bump' shaders,\n\
			or a 'bw' file for 'bwtexture'. For the 'bump' shader, the red and blue\n\
			channels of the image are used to perturb the true surface normal.\n\
			Red and blue values of 128 produce no perturbation, while values of 0\n\
			produce maximum perturbation in one direction and 255 produces maximum\n\
			perturbation in the opposite"}
	}
d1944 5
a1948 3
	hoc_register_data $shader_params($id,window).fr.width Width {
		{ summary "Enter the width of the texture in pixels\n(default is 512)"}
	}
d1950 13
a1962 3
	hoc_register_data $shader_params($id,window).fr.height Height {
		{ summary "Enter the height of the texture in pixels\n(default is 512)"}
	}
d1964 3
a1966 9
	hoc_register_data $shader_params($id,window).fr.trans Transparency {
		{ summary "Enter the color in the texture that will be treated as\n\
			transparent. All pixels on this object that get assigned this\n\
			color from the texture will be treated as though this object\n\
			does not exist. For the 'texture' shader, this must be an RGB\n\
			triple. For the 'bwtexture' shader, a single value is sufficient.\n\
			This is ignored for the 'bump' shader"}
		{ range "RGB values must be integers from 0 to 255"}
	}
d1968 10
a1977 5
	hoc_register_data $shader_params($id,window).fr.valid Transparency {
		{ summary "If depressed, transparency is enabled using the transparency\n\
			color. Otherwise, the transparency color is ignored. The 'bump'\n\
			shader does not use this button."}
	}
d1981 1
a1981 1
	set_texture_values $shader_str $id
d1983 36
a2018 28
        label $shader_params($id,window).fr.repl.repl_label \
	    -text "Texture Replication"
        grid $shader_params($id,window).fr.repl.repl_label \
	    -row 0 -column 0 -columnspan 4 -sticky ew
        grid $shader_params($id,window).fr.repl.u_scale \
	    -row 1 -column 0 -sticky e
        grid $shader_params($id,window).fr.repl.u_scale_e \
	    -row 1 -column 1 -sticky w
        grid $shader_params($id,window).fr.repl.v_scale \
	    -row 1 -column 2 -sticky e
        grid $shader_params($id,window).fr.repl.v_scale_e \
	    -row 1 -column 3 -sticky w
        grid $shader_params($id,window).fr.repl.mirror_e \
	    -row 2 -column 1 -sticky e
        grid $shader_params($id,window).fr.repl.mirror \
	    -row 2 -column 2 -sticky w

	grid $shader_params($id,window).fr.file -row 0 -column 0 -sticky e
	grid $shader_params($id,window).fr.file_e -row 0 -column 1 -columnspan 5 -sticky w
	grid $shader_params($id,window).fr.width -row 1 -column 0 -sticky e
	grid $shader_params($id,window).fr.width_e -row 1 -column 1 -sticky w
	grid $shader_params($id,window).fr.height -row 1 -column 2 -sticky e
	grid $shader_params($id,window).fr.height_e -row 1 -column 3 -sticky w
        grid $shader_params($id,window).fr.repl -row 2 -column 0 -sticky nsew -columnspan 5
	grid $shader_params($id,window).fr.trans -row 3 -column 0 -sticky e
	grid $shader_params($id,window).fr.trans_e -row 3 -column 1 -sticky w
	grid $shader_params($id,window).fr.valid_e -row 3 -column 2 -sticky e
	grid $shader_params($id,window).fr.valid -row 3 -column 3 -sticky w
d2020 1
a2020 3
	grid $shader_params($id,window).fr -columnspan 4 -sticky ew -ipadx 3 -ipady 3

	return $shader_params($id,window).fr
d2088 1
a2088 1
	frame $childsite.stk_$index -relief raised -bd 3
d2092 1
a2092 1
		label $childsite.stk_$index.lab -text $shader
d2094 1
a2094 1
		label $childsite.stk_$index.lab -text "Unrecognized Shader"
d2179 1
a2179 1
		label $childsite.stk_$index.lab -text $shader
d2181 1
a2181 1
		label $childsite.stk_$index.lab -text "Unrecognized Shader"
d2251 1
a2251 1
	grid $childsite.stk_$index.del -columnspan 4
d2257 1
a2257 1
		grid columnconfigure $childsite.stk_$i 0 -minsize 400
d2355 3
a2357 1
	frame $shader_params($id,window).fr -bd 3 -relief sunken
a2358 1
    set childsite [[scrolledframe $shader_params($id,window).fr.leesf -width 425 -height 250 -hscrollmode dynamic ] childsite]
d2404 1
a2404 1
    grid $shader_params($id,window).fr.leesf -sticky ew -row 1
d2408 2
a2409 1
    grid rowconfigure $shader_params($id,window) 1 -weight 1
d2412 1
d2414 1
a2414 1
	set_stack_values $shade_str $id
d2416 1
a2416 1
	return $shader_params($id,window).fr
d2764 1
a2764 1
	entry $shader_params($id,window).fr.param_e -width 40 -textvariable shader_params($id,unk_param)
a2786 3
	grid columnconfigure $shader_params($id,window).fr.name_e 0 -weight 1
	grid columnconfigure $shader_params($id,window).fr.param_e 0 -weight 1

d2788 1
a2788 1
	grid columnconfigure $shader_params($id,window).fr 0 -weight 1
@


1.38.2.1
log
@attenuation update
@
text
@a1538 1
	e	lumens		b	1.0	"Lumens for Photon mapping" 		        "And Real #"	3 0 \
@


1.38.2.2
log
@updated for merging
@
text
@a5 1
# See "comb.tcl" for an explanation of the widget hierarchy
d760 1
a760 3
	label $shader_params($id,window).fr.fakestar_m \
	    -text "There are no parameters to set \n\
                   for the fakestar texture map"
d883 1
a883 1
	grid $shader_params($id,window).fr -sticky new -ipadx 3 -ipady 3
d1215 1
a1215 1
	grid $shader_params($id,window).fr -sticky new -ipadx 3 -ipady 3
d1820 2
a1821 2
    global shader_params
    upvar #0 $shade_var shader_str
d1823 3
a1825 49
    catch { destroy $shader_params($id,window).fr }
    frame $shader_params($id,window).fr
    frame $shader_params($id,window).fr.file_fr -relief flat
    frame $shader_params($id,window).fr.repl -relief groove -bd 2
    frame $shader_params($id,window).fr.transp_fr -relief flat

    label $shader_params($id,window).fr.file_fr.file -text "Texture File Name"
    entry $shader_params($id,window).fr.file_fr.file_e -width 20 \
	-textvariable shader_params($id,file)
    bind $shader_params($id,window).fr.file_fr.file_e <KeyRelease> "do_shader_apply $shade_var $id"
    label $shader_params($id,window).fr.file_fr.width -text "File Width (pixels)"
    entry $shader_params($id,window).fr.file_fr.width_e -width 5 \
	-textvariable shader_params($id,width)
    bind $shader_params($id,window).fr.file_fr.width_e <KeyRelease> "do_shader_apply $shade_var $id"
    label $shader_params($id,window).fr.file_fr.height -text "File height (pixels)"
    entry $shader_params($id,window).fr.file_fr.height_e -width 5 \
	-textvariable shader_params($id,height)
    bind $shader_params($id,window).fr.file_fr.height_e \
	<KeyRelease> "do_shader_apply $shade_var $id"
    label $shader_params($id,window).fr.repl.mirror -text "Mirror Adjacent tiles"
    checkbutton $shader_params($id,window).fr.repl.mirror_e \
	-variable shader_params($id,mirror) \
	-command "do_shader_apply $shade_var $id"
    label $shader_params($id,window).fr.repl.u_scale -text "in U-direction"
    entry $shader_params($id,window).fr.repl.u_scale_e -width 4 \
	-textvariable shader_params($id,tx_scale_u)
    bind $shader_params($id,window).fr.repl.u_scale_e <KeyRelease> "do_shader_apply $shade_var $id"
    label $shader_params($id,window).fr.repl.v_scale -text "in V-direction"
    entry $shader_params($id,window).fr.repl.v_scale_e -width 4 \
	-textvariable shader_params($id,tx_scale_v)
    bind $shader_params($id,window).fr.repl.v_scale_e <KeyRelease> "do_shader_apply $shade_var $id"
    label $shader_params($id,window).fr.transp_fr.trans -text "Transparency (RGB)"
    entry $shader_params($id,window).fr.transp_fr.trans_e -width 11 \
	-textvariable shader_params($id,transp)
    bind $shader_params($id,window).fr.transp_fr.trans_e <KeyRelease> \
	"do_shader_apply $shade_var $id"
    checkbutton $shader_params($id,window).fr.transp_fr.valid_e \
	-variable shader_params($id,trans_valid) \
	-command  "do_shader_apply $shade_var $id"

    hoc_register_data $shader_params($id,window).fr.file_e File {
	{ summary "Enter the name of the file containing the texture to be mapped to this\n\
		object. This file should be a 'pix' file for the 'texture' or 'bump' shaders,\n\
		or a 'bw' file for 'bwtexture'. For the 'bump' shader, the red and blue\n\
		channels of the image are used to perturb the true surface normal.\n\
		Red and blue values of 128 produce no perturbation, while values of 0\n\
		produce maximum perturbation in one direction and 255 produces maximum\n\
		perturbation in the opposite"}
    }
d1827 36
a1862 3
    hoc_register_data $shader_params($id,window).fr.width_e Width {
	{ summary "Enter the width of the texture in pixels\n(default is 512)"}
    }
d1864 3
a1866 3
    hoc_register_data $shader_params($id,window).fr.height_e Height {
	{ summary "Enter the height of the texture in pixels\n(default is 512)"}
    }
d1868 3
a1870 9
    hoc_register_data $shader_params($id,window).fr.transp_fr.trans_e Transparency {
	{ summary "Enter the color in the texture that will be treated as\n\
		transparent. All pixels on this object that get assigned this\n\
		color from the texture will be treated as though this object\n\
		does not exist. For the 'texture' shader, this must be an RGB\n\
		triple. For the 'bwtexture' shader, a single value is sufficient\n\
		This is ignored for the 'bump' shader"}
	{ range "RGB values must be integers from 0 to 255"}
    }
d1872 77
a1948 5
    hoc_register_data $shader_params($id,window).fr.repl.mirror Mirror {
	{ summary "Turn this option on to get smooth transitions between adjacent tiles\n\
		of the texture by mirroring. This only has an effect when texture\n\
		replication is greater than 1"}
    }
d1950 3
a1952 5
    hoc_register_data $shader_params($id,window).fr.repl.mirror_e Mirror {
	{ summary "Turn this option on to get smooth transitions between adjacent tiles\n\
		of the texture by mirroring. This only has an effect when texture\n\
		replication is greater than 1"}
    }
d1954 3
a1956 9
    hoc_register_data $shader_params($id,window).fr.repl.u_scale "Texture Replication" {
	{summary "Each object being shaded has UV coordinates from 0 through 1.0 used to\n\
		lookup which part of the texture should be applied where.  Normally,\n\
		one entire copy of the texture is stretched or compressed to fit the object.\n\
		This is changed when a value other than 1 is entered here. The value entered here\n\
		specifies the number of texture patterns to be used across the object in the U\n\
		parameter direction"}
	{ range "Real numbers greater than 0.0" }
    }
d1958 9
a1966 9
    hoc_register_data $shader_params($id,window).fr.repl.u_scale_e "Texture Replication" {
	{summary "Each object being shaded has UV coordinates from 0 through 1.0 used to\n\
		lookup which part of the texture should be applied where.  Normally,\n\
		one entire copy of the texture is stretched or compressed to fit the object.\n\
		This is changed when a value other than 1 is entered here. The value entered here\n\
		specifies the number of texture patterns to be used across the object in the U\n\
		parameter direction"}
	{ range "Real numbers greater than 0.0" }
    }
d1968 5
a1972 9
    hoc_register_data $shader_params($id,window).fr.repl.v_scale "Texture Replication" {
	{summary "Each object being shaded has UV coordinates from 0 through 1.0 used to\n\
		lookup which part of the texture should be applied where.  Normally,\n\
		one entire copy of the texture is stretched or compressed to fit the object.\n\
		This is changed when a value other than 1 is entered here. The value entered here\n\
		specifies the number of texture patterns to be used across the object in the V\n\
		parameter direction"}
	{ range "Real numbers greater than 0.0" }
    }
d1974 1
a1974 9
    hoc_register_data $shader_params($id,window).fr.repl.v_scale_e "Texture Replication" {
	{summary "Each object being shaded has UV coordinates from 0 through 1.0 used to\n\
		lookup which part of the texture should be applied where.  Normally,\n\
		one entire copy of the texture is stretched or compressed to fit the object.\n\
		This is changed when a value other than 1 is entered here. The value entered here\n\
		specifies the number of texture patterns to be used across the object in the V\n\
		parameter direction"}
	{ range "Real numbers greater than 0.0" }
    }
d1976 1
a1976 5
    hoc_register_data $shader_params($id,window).fr.transp_fr.valid_e Transparency {
	{ summary "If depressed, transparency is enabled using the transparency\n\
		color. Otherwise, the transparency color is ignored. The 'bump'\n\
		shader does not use this button."}
    }
d1978 16
a1993 13
    hoc_register_data $shader_params($id,window).fr.file File {
	{ summary "Enter the name of the file containing the texture to be mapped to this\n\
		object. This file should be a 'pix' file for the 'texture' or 'bump' shaders,\n\
		or a 'bw' file for 'bwtexture'. For the 'bump' shader, the red and blue\n\
		channels of the image are used to perturb the true surface normal.\n\
		Red and blue values of 128 produce no perturbation, while values of 0\n\
		produce maximum perturbation in one direction and 255 produces maximum\n\
		perturbation in the opposite"}
    }
    
    hoc_register_data $shader_params($id,window).fr.width Width {
	{ summary "Enter the width of the texture in pixels\n(default is 512)"}
    }
d1995 11
a2005 3
    hoc_register_data $shader_params($id,window).fr.height Height {
	{ summary "Enter the height of the texture in pixels\n(default is 512)"}
    }
d2007 1
a2007 10
    hoc_register_data $shader_params($id,window).fr.transp_fr.trans Transparency {
	{ summary "Enter the color in the texture that will be treated as\n\
		transparent. All pixels on this object that get assigned this\n\
		color from the texture will be treated as though this object\n\
		does not exist. For the 'texture' shader, this must be an RGB\n\
		triple. For the 'bwtexture' shader, a single value is sufficient.\n\
		The checkbutton to the left must be depressed for transparency\n\
		to be active. This is ignored for the 'bump' shader"}
	{ range "RGB values must be integers from 0 to 255"}
    }
d2009 1
a2009 42
#	set variables from current 'params' list

    set_texture_values $shader_str $id

    label $shader_params($id,window).fr.repl.repl_label \
	-text "Texture Replication"
    grid $shader_params($id,window).fr.repl.repl_label \
	-row 0 -column 0 -columnspan 4 -sticky ew
    grid $shader_params($id,window).fr.repl.u_scale \
	-row 1 -column 0 -sticky e
    grid $shader_params($id,window).fr.repl.u_scale_e \
	-row 1 -column 1 -sticky w
    grid $shader_params($id,window).fr.repl.v_scale \
	-row 1 -column 2 -sticky e
    grid $shader_params($id,window).fr.repl.v_scale_e \
	-row 1 -column 3 -sticky w
    grid $shader_params($id,window).fr.repl.mirror_e \
	-row 2 -column 1 -sticky e
    grid $shader_params($id,window).fr.repl.mirror \
	-row 2 -column 2 -sticky w

    grid $shader_params($id,window).fr.file_fr.file -row 0 -column 0 -sticky e
    grid $shader_params($id,window).fr.file_fr.file_e -row 0 -column 1 -columnspan 3 -sticky ew
    grid $shader_params($id,window).fr.file_fr.width -row 1 -column 0 -sticky e
    grid $shader_params($id,window).fr.file_fr.width_e -row 1 -column 1 -sticky w
    grid $shader_params($id,window).fr.file_fr.height -row 1 -column 2 -sticky e
    grid $shader_params($id,window).fr.file_fr.height_e -row 1 -column 3 -sticky w
    grid $shader_params($id,window).fr.file_fr -row 0 -column 0 -sticky ew
    grid columnconfigure $shader_params($id,window).fr.file_fr 0 -weight 1
    grid columnconfigure $shader_params($id,window).fr.file_fr 1 -weight 1
    grid columnconfigure $shader_params($id,window).fr.file_fr 2 -weight 1
    grid columnconfigure $shader_params($id,window).fr.file_fr 3 -weight 1
    grid $shader_params($id,window).fr.repl -row 1 -column 0 -sticky nsew
    grid $shader_params($id,window).fr.transp_fr.valid_e -row 0 -column 0 -sticky w
    grid $shader_params($id,window).fr.transp_fr.trans -row 0 -column 1 -sticky e
    grid $shader_params($id,window).fr.transp_fr.trans_e -row 0 -column 2 -sticky w
    grid $shader_params($id,window).fr.transp_fr -row 2 -column 0
    
    grid $shader_params($id,window).fr -sticky new -ipadx 3 -ipady 3
    grid columnconfigure $shader_params($id,window).fr 0 -weight 1

    return $shader_params($id,window).fr
d2077 1
a2077 1
	frame $childsite.stk_$index -bd 2 -relief groove
d2081 1
a2081 1
		label $childsite.stk_$index.lab -text $shader -bg CadetBlue -fg white
d2083 1
a2083 1
		label $childsite.stk_$index.lab -text "Unrecognized Shader" -bg CadetBlue -fg white
d2168 1
a2168 1
		label $childsite.stk_$index.lab -text $shader -bg CadetBlue -fg white
d2170 1
a2170 1
		label $childsite.stk_$index.lab -text "Unrecognized Shader" -bg CadetBlue -fg white
d2240 1
a2240 1
	grid $childsite.stk_$index.del -columnspan 4 -sticky ew
d2246 1
a2246 1
		grid columnconfigure $childsite.stk_$i 0 -minsize 400 -weight 1
d2344 1
a2344 3
	frame $shader_params($id,window).fr -padx 3 -pady 3

    set childsite [[iwidgets::scrolledframe $shader_params($id,window).fr.leesf -width 432 -height 250 -hscrollmode dynamic ] childsite]
d2346 1
d2392 1
a2392 1
    grid $shader_params($id,window).fr.leesf -sticky nsew -row 1
d2396 1
a2396 2
    grid rowconfigure $shader_params($id,window) 0 -weight 1
    grid rowconfigure $shader_params($id,window) 1 -weight 0
a2398 1
    grid rowconfigure $shader_params($id,window).fr 1 -weight 1
d2400 1
a2400 1
    set_stack_values $shade_str $id
d2402 1
a2402 1
    return $shader_params($id,window).fr
d2750 1
a2750 1
	entry $shader_params($id,window).fr.param_e -width 20 -textvariable shader_params($id,unk_param)
d2773 3
d2777 1
a2777 1
	grid columnconfigure $shader_params($id,window).fr 0 -weight 0
@


1.37
log
@re-arranged texture frame to conserve some space
@
text
@d1673 1
a1673 1
	        if { $shader_str != "light" } {
@


1.36
log
@Folded stack shader contents into an Itcl ScrolledFrame widget. This prevents
the panel from growing to infinite length when building stack shaders.
@
text
@d1824 1
d1835 2
a1836 2
	label $shader_params($id,window).fr.mirror -text "Mirror Adjacent tiles"
	checkbutton $shader_params($id,window).fr.mirror_e \
d1839 6
a1844 6
	label $shader_params($id,window).fr.u_scale -text "Texture Replication in U-direction"
	entry $shader_params($id,window).fr.u_scale_e -width 4 -textvariable shader_params($id,tx_scale_u)
	bind $shader_params($id,window).fr.u_scale_e <KeyRelease> "do_shader_apply $shade_var $id"
	label $shader_params($id,window).fr.v_scale -text "V-direction"
	entry $shader_params($id,window).fr.v_scale_e -width 4 -textvariable shader_params($id,tx_scale_v)
	bind $shader_params($id,window).fr.v_scale_e <KeyRelease> "do_shader_apply $shade_var $id"
d1881 1
a1881 1
	hoc_register_data $shader_params($id,window).fr.mirror Mirror {
d1887 1
a1887 1
	hoc_register_data $shader_params($id,window).fr.mirror_e Mirror {
d1893 1
a1893 1
	hoc_register_data $shader_params($id,window).fr.u_scale "Texture Replication" {
d1903 1
a1903 1
	hoc_register_data $shader_params($id,window).fr.u_scale_e "Texture Replication" {
d1913 1
a1913 1
	hoc_register_data $shader_params($id,window).fr.v_scale "Texture Replication" {
d1923 1
a1923 1
	hoc_register_data $shader_params($id,window).fr.v_scale_e "Texture Replication" {
d1977 17
d2000 1
a2000 6
	grid $shader_params($id,window).fr.u_scale -row 2 -column 0 -sticky e
	grid $shader_params($id,window).fr.u_scale_e -row 2 -column 1 -sticky w
	grid $shader_params($id,window).fr.v_scale -row 2 -column 2 -sticky e
	grid $shader_params($id,window).fr.v_scale_e -row 2 -column 3 -sticky w
	grid $shader_params($id,window).fr.mirror_e -row 2 -column 4 -sticky e
	grid $shader_params($id,window).fr.mirror -row 2 -column 5 -sticky w
@


1.35
log
@fixed bug where the projection shader was getting someone else's parameters
Now all the shaders check that they areusing their own parameters
@
text
@a1215 1

d2058 1
a2058 1
proc stack_add { shader shade_var id } {
d2063 2
a2064 2
	frame $shader_params($id,window).fr.stk_$index -relief raised -bd 3
	set shader_params($id,stk_$index,window) $shader_params($id,window).fr.stk_$index
d2067 1
a2067 1
		label $shader_params($id,window).fr.stk_$index.lab -text $shader
d2069 1
a2069 1
		label $shader_params($id,window).fr.stk_$index.lab -text "Unrecognized Shader"
d2071 1
a2071 1
	grid $shader_params($id,window).fr.stk_$index.lab -columnspan 4 -sticky ew
d2074 1
a2074 1
	button $shader_params($id,window).fr.stk_$index.del -text delete -width 8 \
d2077 1
a2077 1
	hoc_register_data $shader_params($id,window).fr.stk_$index.del "Delete" {
d2140 3
a2142 3
	grid $shader_params($id,window).fr.stk_$index.del -columnspan 4
	grid $shader_params($id,window).fr.stk_$index -columnspan 2 -sticky ew
	grid columnconfigure $shader_params($id,window).fr.stk_$index 0 -minsize 400
d2149 3
a2151 2
	frame $shader_params($id,window).fr.stk_$index -relief raised -bd 3
	set shader_params($id,stk_$index,window) $shader_params($id,window).fr.stk_$index
d2154 1
a2154 1
		label $shader_params($id,window).fr.stk_$index.lab -text $shader
d2156 1
a2156 1
		label $shader_params($id,window).fr.stk_$index.lab -text "Unrecognized Shader"
d2158 1
a2158 1
	button $shader_params($id,window).fr.stk_$index.del -text delete -width 8 \
d2161 1
a2161 1
	hoc_register_data $shader_params($id,window).fr.stk_$index.del "Delete" {
d2167 1
a2167 1
	grid $shader_params($id,window).fr.stk_$index.lab -columnspan 4 -sticky ew
d2226 1
a2226 1
	grid $shader_params($id,window).fr.stk_$index.del -columnspan 4
d2231 2
a2232 2
		grid $shader_params($id,window).fr.stk_$i -columnspan 2 -sticky ew -row [expr $index + 2]
		grid columnconfigure $shader_params($id,window).fr.stk_$i 0 -minsize 400
d2275 1
a2275 1
			stack_add $shader $shader_params($id,shade_var) $id
d2330 1
a2330 1
	frame $shader_params($id,window).fr
d2332 1
d2345 1
a2345 1
		-label plastic -command "stack_add plastic $shade_var $id; do_shader_apply $shade_var $id"
d2347 1
a2347 1
		-label glass -command "stack_add glass $shade_var $id; do_shader_apply $shade_var $id"
d2349 1
a2349 1
		-label mirror -command "stack_add mirror $shade_var $id; do_shader_apply $shade_var $id"
d2352 1
a2352 1
		-label light -command "stack_add light $shade_var $id; do_shader_apply $shade_var $id"
d2355 1
a2355 1
		-label "bump map" -command "stack_add bump $shade_var $id; do_shader_apply $shade_var $id"
d2357 1
a2357 1
		-label texture -command "stack_add texture $shade_var $id; do_shader_apply $shade_var $id"
d2359 1
a2359 1
		-label bwtexture -command "stack_add bwtexture $shade_var $id; do_shader_apply $shade_var $id"
d2361 1
a2361 1
		-label fakestar -command "stack_add fakestar $shade_var $id; do_shader_apply $shade_var $id"
d2363 1
a2363 1
		-label cloud -command "stack_add cloud $shade_var $id; do_shader_apply $shade_var $id"
d2365 1
a2365 1
		-label checker -command "stack_add checker $shade_var $id; do_shader_apply $shade_var $id"
d2367 1
a2367 1
		-label camouflage -command "stack_add camo $shade_var $id; do_shader_apply $shade_var $id"
d2369 1
a2369 1
		-label projection -command "stack_add prj $shade_var $id; do_shader_apply $shade_var $id"
d2371 1
a2371 1
		-label air -command "stack_add air $shade_var $id; do_shader_apply $shade_var $id"
d2373 1
a2373 1
		-label testmap -command "stack_add testmap $shade_var $id; do_shader_apply $shade_var $id"
d2375 1
a2375 1
		-label Unknown -command "stack_add unknown $shade_var $id; do_shader_apply $shade_var $id"
d2377 8
a2384 3
	grid $shader_params($id,window).fr.add -columnspan 2

	grid $shader_params($id,window).fr -sticky ew -ipadx 3 -ipady 3
@


1.34
log
@*- add parameter to color_entry_build to indicate
   whether or not to use background colors for rt
@
text
@d99 4
d429 10
a470 5
	if { [llength $shader_str] > 1 } then {
		set params [lindex $shader_str 1]
	} else {
		set params ""
	}
d719 4
d899 4
d1246 4
d1477 4
d1673 4
d2661 4
d2861 4
@


1.34.4.1
log
@sync branch with HEAD
@
text
@a5 1
# See "comb.tcl" for an explanation of the widget hierarchy
a98 4
	        set shader_name [lindex $shader_str 0]
	        if { $shader_name != "extern" } {
		    return
		}
a424 10
	if { [llength $shader_str] > 1 } then {
		set params [lindex $shader_str 1]
	        set shader_name [lindex $shader_str 0]
	        if { $shader_name != "camo" } {
		    return
		}
	} else {
		set params ""
	}

d457 5
a709 4
	        set shader_name [lindex $shader_str 0]
	        if { $shader_name != "prj" } {
		    return
		}
d747 1
a747 3
	label $shader_params($id,window).fr.fakestar_m \
	    -text "There are no parameters to set \n\
                   for the fakestar texture map"
d870 1
a870 1
	grid $shader_params($id,window).fr -sticky new -ipadx 3 -ipady 3
a885 4
	        set shader_name [lindex $shader_str 0]
	        if { $shader_name != "checker" } {
		    return
		}
d1198 2
a1199 1
	grid $shader_params($id,window).fr -sticky new -ipadx 3 -ipady 3
a1228 4
	        set shader_name [lindex $shader_str 0]
	        if { $shader_name != "plastic" && $shader_name != "glass" && $shader_name != "mirror" } {
		    return
		}
a1455 4
	        set shader_name [lindex $shader_str 0]
	        if { $shader_name != "bump" && $shader_name != "bwtexture" && $shader_name != "texture" } {
		    return
		}
a1514 1
	e	lumens		b	1.0	"Lumens for Photon mapping" 		        "And Real #"	3 0 \
a1647 4
	        set shader_name [lindex $shader_str 0]
	        if { $shader_name != "light" } {
		    return
		}
d1791 2
a1792 2
    global shader_params
    upvar #0 $shade_var shader_str
d1794 2
a1795 49
    catch { destroy $shader_params($id,window).fr }
    frame $shader_params($id,window).fr
    frame $shader_params($id,window).fr.file_fr -relief flat
    frame $shader_params($id,window).fr.repl -relief groove -bd 2
    frame $shader_params($id,window).fr.transp_fr -relief flat

    label $shader_params($id,window).fr.file_fr.file -text "Texture File Name"
    entry $shader_params($id,window).fr.file_fr.file_e -width 20 \
	-textvariable shader_params($id,file)
    bind $shader_params($id,window).fr.file_fr.file_e <KeyRelease> "do_shader_apply $shade_var $id"
    label $shader_params($id,window).fr.file_fr.width -text "File Width (pixels)"
    entry $shader_params($id,window).fr.file_fr.width_e -width 5 \
	-textvariable shader_params($id,width)
    bind $shader_params($id,window).fr.file_fr.width_e <KeyRelease> "do_shader_apply $shade_var $id"
    label $shader_params($id,window).fr.file_fr.height -text "File height (pixels)"
    entry $shader_params($id,window).fr.file_fr.height_e -width 5 \
	-textvariable shader_params($id,height)
    bind $shader_params($id,window).fr.file_fr.height_e \
	<KeyRelease> "do_shader_apply $shade_var $id"
    label $shader_params($id,window).fr.repl.mirror -text "Mirror Adjacent tiles"
    checkbutton $shader_params($id,window).fr.repl.mirror_e \
	-variable shader_params($id,mirror) \
	-command "do_shader_apply $shade_var $id"
    label $shader_params($id,window).fr.repl.u_scale -text "in U-direction"
    entry $shader_params($id,window).fr.repl.u_scale_e -width 4 \
	-textvariable shader_params($id,tx_scale_u)
    bind $shader_params($id,window).fr.repl.u_scale_e <KeyRelease> "do_shader_apply $shade_var $id"
    label $shader_params($id,window).fr.repl.v_scale -text "in V-direction"
    entry $shader_params($id,window).fr.repl.v_scale_e -width 4 \
	-textvariable shader_params($id,tx_scale_v)
    bind $shader_params($id,window).fr.repl.v_scale_e <KeyRelease> "do_shader_apply $shade_var $id"
    label $shader_params($id,window).fr.transp_fr.trans -text "Transparency (RGB)"
    entry $shader_params($id,window).fr.transp_fr.trans_e -width 11 \
	-textvariable shader_params($id,transp)
    bind $shader_params($id,window).fr.transp_fr.trans_e <KeyRelease> \
	"do_shader_apply $shade_var $id"
    checkbutton $shader_params($id,window).fr.transp_fr.valid_e \
	-variable shader_params($id,trans_valid) \
	-command  "do_shader_apply $shade_var $id"

    hoc_register_data $shader_params($id,window).fr.file_e File {
	{ summary "Enter the name of the file containing the texture to be mapped to this\n\
		object. This file should be a 'pix' file for the 'texture' or 'bump' shaders,\n\
		or a 'bw' file for 'bwtexture'. For the 'bump' shader, the red and blue\n\
		channels of the image are used to perturb the true surface normal.\n\
		Red and blue values of 128 produce no perturbation, while values of 0\n\
		produce maximum perturbation in one direction and 255 produces maximum\n\
		perturbation in the opposite"}
    }
d1797 36
a1832 3
    hoc_register_data $shader_params($id,window).fr.width_e Width {
	{ summary "Enter the width of the texture in pixels\n(default is 512)"}
    }
d1834 3
a1836 3
    hoc_register_data $shader_params($id,window).fr.height_e Height {
	{ summary "Enter the height of the texture in pixels\n(default is 512)"}
    }
d1838 3
a1840 9
    hoc_register_data $shader_params($id,window).fr.transp_fr.trans_e Transparency {
	{ summary "Enter the color in the texture that will be treated as\n\
		transparent. All pixels on this object that get assigned this\n\
		color from the texture will be treated as though this object\n\
		does not exist. For the 'texture' shader, this must be an RGB\n\
		triple. For the 'bwtexture' shader, a single value is sufficient\n\
		This is ignored for the 'bump' shader"}
	{ range "RGB values must be integers from 0 to 255"}
    }
d1842 77
a1918 5
    hoc_register_data $shader_params($id,window).fr.repl.mirror Mirror {
	{ summary "Turn this option on to get smooth transitions between adjacent tiles\n\
		of the texture by mirroring. This only has an effect when texture\n\
		replication is greater than 1"}
    }
d1920 3
a1922 5
    hoc_register_data $shader_params($id,window).fr.repl.mirror_e Mirror {
	{ summary "Turn this option on to get smooth transitions between adjacent tiles\n\
		of the texture by mirroring. This only has an effect when texture\n\
		replication is greater than 1"}
    }
d1924 3
a1926 9
    hoc_register_data $shader_params($id,window).fr.repl.u_scale "Texture Replication" {
	{summary "Each object being shaded has UV coordinates from 0 through 1.0 used to\n\
		lookup which part of the texture should be applied where.  Normally,\n\
		one entire copy of the texture is stretched or compressed to fit the object.\n\
		This is changed when a value other than 1 is entered here. The value entered here\n\
		specifies the number of texture patterns to be used across the object in the U\n\
		parameter direction"}
	{ range "Real numbers greater than 0.0" }
    }
d1928 9
a1936 9
    hoc_register_data $shader_params($id,window).fr.repl.u_scale_e "Texture Replication" {
	{summary "Each object being shaded has UV coordinates from 0 through 1.0 used to\n\
		lookup which part of the texture should be applied where.  Normally,\n\
		one entire copy of the texture is stretched or compressed to fit the object.\n\
		This is changed when a value other than 1 is entered here. The value entered here\n\
		specifies the number of texture patterns to be used across the object in the U\n\
		parameter direction"}
	{ range "Real numbers greater than 0.0" }
    }
d1938 5
a1942 9
    hoc_register_data $shader_params($id,window).fr.repl.v_scale "Texture Replication" {
	{summary "Each object being shaded has UV coordinates from 0 through 1.0 used to\n\
		lookup which part of the texture should be applied where.  Normally,\n\
		one entire copy of the texture is stretched or compressed to fit the object.\n\
		This is changed when a value other than 1 is entered here. The value entered here\n\
		specifies the number of texture patterns to be used across the object in the V\n\
		parameter direction"}
	{ range "Real numbers greater than 0.0" }
    }
d1944 1
a1944 9
    hoc_register_data $shader_params($id,window).fr.repl.v_scale_e "Texture Replication" {
	{summary "Each object being shaded has UV coordinates from 0 through 1.0 used to\n\
		lookup which part of the texture should be applied where.  Normally,\n\
		one entire copy of the texture is stretched or compressed to fit the object.\n\
		This is changed when a value other than 1 is entered here. The value entered here\n\
		specifies the number of texture patterns to be used across the object in the V\n\
		parameter direction"}
	{ range "Real numbers greater than 0.0" }
    }
d1946 1
a1946 5
    hoc_register_data $shader_params($id,window).fr.transp_fr.valid_e Transparency {
	{ summary "If depressed, transparency is enabled using the transparency\n\
		color. Otherwise, the transparency color is ignored. The 'bump'\n\
		shader does not use this button."}
    }
d1948 16
a1963 13
    hoc_register_data $shader_params($id,window).fr.file File {
	{ summary "Enter the name of the file containing the texture to be mapped to this\n\
		object. This file should be a 'pix' file for the 'texture' or 'bump' shaders,\n\
		or a 'bw' file for 'bwtexture'. For the 'bump' shader, the red and blue\n\
		channels of the image are used to perturb the true surface normal.\n\
		Red and blue values of 128 produce no perturbation, while values of 0\n\
		produce maximum perturbation in one direction and 255 produces maximum\n\
		perturbation in the opposite"}
    }
    
    hoc_register_data $shader_params($id,window).fr.width Width {
	{ summary "Enter the width of the texture in pixels\n(default is 512)"}
    }
d1965 1
a1965 3
    hoc_register_data $shader_params($id,window).fr.height Height {
	{ summary "Enter the height of the texture in pixels\n(default is 512)"}
    }
d1967 1
a1967 53
    hoc_register_data $shader_params($id,window).fr.transp_fr.trans Transparency {
	{ summary "Enter the color in the texture that will be treated as\n\
		transparent. All pixels on this object that get assigned this\n\
		color from the texture will be treated as though this object\n\
		does not exist. For the 'texture' shader, this must be an RGB\n\
		triple. For the 'bwtexture' shader, a single value is sufficient.\n\
		The checkbutton to the left must be depressed for transparency\n\
		to be active. This is ignored for the 'bump' shader"}
	{ range "RGB values must be integers from 0 to 255"}
    }

#	set variables from current 'params' list

    set_texture_values $shader_str $id

    label $shader_params($id,window).fr.repl.repl_label \
	-text "Texture Replication"
    grid $shader_params($id,window).fr.repl.repl_label \
	-row 0 -column 0 -columnspan 4 -sticky ew
    grid $shader_params($id,window).fr.repl.u_scale \
	-row 1 -column 0 -sticky e
    grid $shader_params($id,window).fr.repl.u_scale_e \
	-row 1 -column 1 -sticky w
    grid $shader_params($id,window).fr.repl.v_scale \
	-row 1 -column 2 -sticky e
    grid $shader_params($id,window).fr.repl.v_scale_e \
	-row 1 -column 3 -sticky w
    grid $shader_params($id,window).fr.repl.mirror_e \
	-row 2 -column 1 -sticky e
    grid $shader_params($id,window).fr.repl.mirror \
	-row 2 -column 2 -sticky w

    grid $shader_params($id,window).fr.file_fr.file -row 0 -column 0 -sticky e
    grid $shader_params($id,window).fr.file_fr.file_e -row 0 -column 1 -columnspan 3 -sticky ew
    grid $shader_params($id,window).fr.file_fr.width -row 1 -column 0 -sticky e
    grid $shader_params($id,window).fr.file_fr.width_e -row 1 -column 1 -sticky w
    grid $shader_params($id,window).fr.file_fr.height -row 1 -column 2 -sticky e
    grid $shader_params($id,window).fr.file_fr.height_e -row 1 -column 3 -sticky w
    grid $shader_params($id,window).fr.file_fr -row 0 -column 0 -sticky ew
    grid columnconfigure $shader_params($id,window).fr.file_fr 0 -weight 1
    grid columnconfigure $shader_params($id,window).fr.file_fr 1 -weight 1
    grid columnconfigure $shader_params($id,window).fr.file_fr 2 -weight 1
    grid columnconfigure $shader_params($id,window).fr.file_fr 3 -weight 1
    grid $shader_params($id,window).fr.repl -row 1 -column 0 -sticky nsew
    grid $shader_params($id,window).fr.transp_fr.valid_e -row 0 -column 0 -sticky w
    grid $shader_params($id,window).fr.transp_fr.trans -row 0 -column 1 -sticky e
    grid $shader_params($id,window).fr.transp_fr.trans_e -row 0 -column 2 -sticky w
    grid $shader_params($id,window).fr.transp_fr -row 2 -column 0
    
    grid $shader_params($id,window).fr -sticky new -ipadx 3 -ipady 3
    grid columnconfigure $shader_params($id,window).fr 0 -weight 1

    return $shader_params($id,window).fr
d2030 1
a2030 1
proc stack_add { shader shade_var id childsite} {
d2035 2
a2036 2
	frame $childsite.stk_$index -bd 2 -relief groove
	set shader_params($id,stk_$index,window) $childsite.stk_$index
d2039 1
a2039 1
		label $childsite.stk_$index.lab -text $shader -bg CadetBlue -fg white
d2041 1
a2041 1
		label $childsite.stk_$index.lab -text "Unrecognized Shader" -bg CadetBlue -fg white
d2043 1
a2043 1
	grid $childsite.stk_$index.lab -columnspan 4 -sticky ew
d2046 1
a2046 1
	button $childsite.stk_$index.del -text delete -width 8 \
d2049 1
a2049 1
	hoc_register_data $childsite.stk_$index.del "Delete" {
d2112 3
a2114 3
	grid $childsite.stk_$index.del -columnspan 4
	grid $childsite.stk_$index -columnspan 2 -sticky ew
	grid columnconfigure $childsite.stk_$index 0 -minsize 400
d2121 2
a2122 3
    set childsite [$shader_params($id,window).fr.leesf childsite]
	frame $childsite.stk_$index -relief raised -bd 3
	set shader_params($id,stk_$index,window) $childsite.stk_$index
d2125 1
a2125 1
		label $childsite.stk_$index.lab -text $shader -bg CadetBlue -fg white
d2127 1
a2127 1
		label $childsite.stk_$index.lab -text "Unrecognized Shader" -bg CadetBlue -fg white
d2129 1
a2129 1
	button $childsite.stk_$index.del -text delete -width 8 \
d2132 1
a2132 1
	hoc_register_data $childsite.stk_$index.del "Delete" {
d2138 1
a2138 1
	grid $childsite.stk_$index.lab -columnspan 4 -sticky ew
d2197 1
a2197 1
	grid $childsite.stk_$index.del -columnspan 4 -sticky ew
d2202 2
a2203 2
		grid $childsite.stk_$i -columnspan 2 -sticky ew -row [expr $index + 2]
		grid columnconfigure $childsite.stk_$i 0 -minsize 400 -weight 1
d2246 1
a2246 1
			stack_add $shader $shader_params($id,shade_var) $id [$shader_params($id,window).fr.leesf childsite]
d2301 1
a2301 3
	frame $shader_params($id,window).fr -padx 3 -pady 3

    set childsite [[iwidgets::scrolledframe $shader_params($id,window).fr.leesf -width 432 -height 250 -hscrollmode dynamic ] childsite]
d2315 1
a2315 1
		-label plastic -command "stack_add plastic $shade_var $id $childsite; do_shader_apply $shade_var $id"
d2317 1
a2317 1
		-label glass -command "stack_add glass $shade_var $id $childsite; do_shader_apply $shade_var $id"
d2319 1
a2319 1
		-label mirror -command "stack_add mirror $shade_var $id $childsite; do_shader_apply $shade_var $id"
d2322 1
a2322 1
		-label light -command "stack_add light $shade_var $id $childsite; do_shader_apply $shade_var $id"
d2325 1
a2325 1
		-label "bump map" -command "stack_add bump $shade_var $id $childsite; do_shader_apply $shade_var $id"
d2327 1
a2327 1
		-label texture -command "stack_add texture $shade_var $id $childsite; do_shader_apply $shade_var $id"
d2329 1
a2329 1
		-label bwtexture -command "stack_add bwtexture $shade_var $id $childsite; do_shader_apply $shade_var $id"
d2331 1
a2331 1
		-label fakestar -command "stack_add fakestar $shade_var $id $childsite; do_shader_apply $shade_var $id"
d2333 1
a2333 1
		-label cloud -command "stack_add cloud $shade_var $id $childsite; do_shader_apply $shade_var $id"
d2335 1
a2335 1
		-label checker -command "stack_add checker $shade_var $id $childsite; do_shader_apply $shade_var $id"
d2337 1
a2337 1
		-label camouflage -command "stack_add camo $shade_var $id $childsite; do_shader_apply $shade_var $id"
d2339 1
a2339 1
		-label projection -command "stack_add prj $shade_var $id $childsite; do_shader_apply $shade_var $id"
d2341 1
a2341 1
		-label air -command "stack_add air $shade_var $id $childsite; do_shader_apply $shade_var $id"
d2343 1
a2343 1
		-label testmap -command "stack_add testmap $shade_var $id $childsite; do_shader_apply $shade_var $id"
d2345 3
a2347 1
		-label Unknown -command "stack_add unknown $shade_var $id $childsite; do_shader_apply $shade_var $id"
d2349 1
a2349 10
    grid $shader_params($id,window).fr.add -columnspan 2 -row 0
    grid $shader_params($id,window).fr.leesf -sticky nsew -row 1
    grid columnconfigure $shader_params($id,window).fr 0 -weight 1
    grid rowconfigure $shader_params($id,window).fr 1 -weight 1

    grid rowconfigure $shader_params($id,window) 0 -weight 1
    grid rowconfigure $shader_params($id,window) 1 -weight 0
    grid columnconfigure $shader_params($id,window) 0 -weight 1
    grid $shader_params($id,window).fr -sticky ewns
    grid rowconfigure $shader_params($id,window).fr 1 -weight 1
d2351 1
a2351 1
    set_stack_values $shade_str $id
d2353 1
a2353 1
    return $shader_params($id,window).fr
a2631 4
	        set shader_name [lindex $shader_str 0]
	        if { $shader_name != "cloud" } {
		    return
		}
d2697 1
a2697 1
	entry $shader_params($id,window).fr.param_e -width 20 -textvariable shader_params($id,unk_param)
d2720 3
d2724 1
a2724 1
	grid columnconfigure $shader_params($id,window).fr 0 -weight 0
a2827 4
	        set shader_name [lindex $shader_str 0]
	        if { $shader_name != "air" } {
		    return
		}
@


1.34.6.1
log
@sync to HEAD...
@
text
@a5 1
# See "comb.tcl" for an explanation of the widget hierarchy
a98 4
	        set shader_name [lindex $shader_str 0]
	        if { $shader_name != "extern" } {
		    return
		}
a424 10
	if { [llength $shader_str] > 1 } then {
		set params [lindex $shader_str 1]
	        set shader_name [lindex $shader_str 0]
	        if { $shader_name != "camo" } {
		    return
		}
	} else {
		set params ""
	}

d457 5
a709 4
	        set shader_name [lindex $shader_str 0]
	        if { $shader_name != "prj" } {
		    return
		}
d747 1
a747 3
	label $shader_params($id,window).fr.fakestar_m \
	    -text "There are no parameters to set \n\
                   for the fakestar texture map"
d870 1
a870 1
	grid $shader_params($id,window).fr -sticky new -ipadx 3 -ipady 3
a885 4
	        set shader_name [lindex $shader_str 0]
	        if { $shader_name != "checker" } {
		    return
		}
d1198 2
a1199 1
	grid $shader_params($id,window).fr -sticky new -ipadx 3 -ipady 3
a1228 4
	        set shader_name [lindex $shader_str 0]
	        if { $shader_name != "plastic" && $shader_name != "glass" && $shader_name != "mirror" } {
		    return
		}
a1455 4
	        set shader_name [lindex $shader_str 0]
	        if { $shader_name != "bump" && $shader_name != "bwtexture" && $shader_name != "texture" } {
		    return
		}
a1514 1
	e	lumens		b	1.0	"Lumens for Photon mapping" 		        "And Real #"	3 0 \
a1647 4
	        set shader_name [lindex $shader_str 0]
	        if { $shader_name != "light" } {
		    return
		}
d1791 2
a1792 2
    global shader_params
    upvar #0 $shade_var shader_str
d1794 2
a1795 49
    catch { destroy $shader_params($id,window).fr }
    frame $shader_params($id,window).fr
    frame $shader_params($id,window).fr.file_fr -relief flat
    frame $shader_params($id,window).fr.repl -relief groove -bd 2
    frame $shader_params($id,window).fr.transp_fr -relief flat

    label $shader_params($id,window).fr.file_fr.file -text "Texture File Name"
    entry $shader_params($id,window).fr.file_fr.file_e -width 20 \
	-textvariable shader_params($id,file)
    bind $shader_params($id,window).fr.file_fr.file_e <KeyRelease> "do_shader_apply $shade_var $id"
    label $shader_params($id,window).fr.file_fr.width -text "File Width (pixels)"
    entry $shader_params($id,window).fr.file_fr.width_e -width 5 \
	-textvariable shader_params($id,width)
    bind $shader_params($id,window).fr.file_fr.width_e <KeyRelease> "do_shader_apply $shade_var $id"
    label $shader_params($id,window).fr.file_fr.height -text "File height (pixels)"
    entry $shader_params($id,window).fr.file_fr.height_e -width 5 \
	-textvariable shader_params($id,height)
    bind $shader_params($id,window).fr.file_fr.height_e \
	<KeyRelease> "do_shader_apply $shade_var $id"
    label $shader_params($id,window).fr.repl.mirror -text "Mirror Adjacent tiles"
    checkbutton $shader_params($id,window).fr.repl.mirror_e \
	-variable shader_params($id,mirror) \
	-command "do_shader_apply $shade_var $id"
    label $shader_params($id,window).fr.repl.u_scale -text "in U-direction"
    entry $shader_params($id,window).fr.repl.u_scale_e -width 4 \
	-textvariable shader_params($id,tx_scale_u)
    bind $shader_params($id,window).fr.repl.u_scale_e <KeyRelease> "do_shader_apply $shade_var $id"
    label $shader_params($id,window).fr.repl.v_scale -text "in V-direction"
    entry $shader_params($id,window).fr.repl.v_scale_e -width 4 \
	-textvariable shader_params($id,tx_scale_v)
    bind $shader_params($id,window).fr.repl.v_scale_e <KeyRelease> "do_shader_apply $shade_var $id"
    label $shader_params($id,window).fr.transp_fr.trans -text "Transparency (RGB)"
    entry $shader_params($id,window).fr.transp_fr.trans_e -width 11 \
	-textvariable shader_params($id,transp)
    bind $shader_params($id,window).fr.transp_fr.trans_e <KeyRelease> \
	"do_shader_apply $shade_var $id"
    checkbutton $shader_params($id,window).fr.transp_fr.valid_e \
	-variable shader_params($id,trans_valid) \
	-command  "do_shader_apply $shade_var $id"

    hoc_register_data $shader_params($id,window).fr.file_e File {
	{ summary "Enter the name of the file containing the texture to be mapped to this\n\
		object. This file should be a 'pix' file for the 'texture' or 'bump' shaders,\n\
		or a 'bw' file for 'bwtexture'. For the 'bump' shader, the red and blue\n\
		channels of the image are used to perturb the true surface normal.\n\
		Red and blue values of 128 produce no perturbation, while values of 0\n\
		produce maximum perturbation in one direction and 255 produces maximum\n\
		perturbation in the opposite"}
    }
d1797 36
a1832 3
    hoc_register_data $shader_params($id,window).fr.width_e Width {
	{ summary "Enter the width of the texture in pixels\n(default is 512)"}
    }
d1834 3
a1836 3
    hoc_register_data $shader_params($id,window).fr.height_e Height {
	{ summary "Enter the height of the texture in pixels\n(default is 512)"}
    }
d1838 3
a1840 9
    hoc_register_data $shader_params($id,window).fr.transp_fr.trans_e Transparency {
	{ summary "Enter the color in the texture that will be treated as\n\
		transparent. All pixels on this object that get assigned this\n\
		color from the texture will be treated as though this object\n\
		does not exist. For the 'texture' shader, this must be an RGB\n\
		triple. For the 'bwtexture' shader, a single value is sufficient\n\
		This is ignored for the 'bump' shader"}
	{ range "RGB values must be integers from 0 to 255"}
    }
d1842 77
a1918 5
    hoc_register_data $shader_params($id,window).fr.repl.mirror Mirror {
	{ summary "Turn this option on to get smooth transitions between adjacent tiles\n\
		of the texture by mirroring. This only has an effect when texture\n\
		replication is greater than 1"}
    }
d1920 3
a1922 5
    hoc_register_data $shader_params($id,window).fr.repl.mirror_e Mirror {
	{ summary "Turn this option on to get smooth transitions between adjacent tiles\n\
		of the texture by mirroring. This only has an effect when texture\n\
		replication is greater than 1"}
    }
d1924 3
a1926 9
    hoc_register_data $shader_params($id,window).fr.repl.u_scale "Texture Replication" {
	{summary "Each object being shaded has UV coordinates from 0 through 1.0 used to\n\
		lookup which part of the texture should be applied where.  Normally,\n\
		one entire copy of the texture is stretched or compressed to fit the object.\n\
		This is changed when a value other than 1 is entered here. The value entered here\n\
		specifies the number of texture patterns to be used across the object in the U\n\
		parameter direction"}
	{ range "Real numbers greater than 0.0" }
    }
d1928 9
a1936 9
    hoc_register_data $shader_params($id,window).fr.repl.u_scale_e "Texture Replication" {
	{summary "Each object being shaded has UV coordinates from 0 through 1.0 used to\n\
		lookup which part of the texture should be applied where.  Normally,\n\
		one entire copy of the texture is stretched or compressed to fit the object.\n\
		This is changed when a value other than 1 is entered here. The value entered here\n\
		specifies the number of texture patterns to be used across the object in the U\n\
		parameter direction"}
	{ range "Real numbers greater than 0.0" }
    }
d1938 5
a1942 9
    hoc_register_data $shader_params($id,window).fr.repl.v_scale "Texture Replication" {
	{summary "Each object being shaded has UV coordinates from 0 through 1.0 used to\n\
		lookup which part of the texture should be applied where.  Normally,\n\
		one entire copy of the texture is stretched or compressed to fit the object.\n\
		This is changed when a value other than 1 is entered here. The value entered here\n\
		specifies the number of texture patterns to be used across the object in the V\n\
		parameter direction"}
	{ range "Real numbers greater than 0.0" }
    }
d1944 1
a1944 9
    hoc_register_data $shader_params($id,window).fr.repl.v_scale_e "Texture Replication" {
	{summary "Each object being shaded has UV coordinates from 0 through 1.0 used to\n\
		lookup which part of the texture should be applied where.  Normally,\n\
		one entire copy of the texture is stretched or compressed to fit the object.\n\
		This is changed when a value other than 1 is entered here. The value entered here\n\
		specifies the number of texture patterns to be used across the object in the V\n\
		parameter direction"}
	{ range "Real numbers greater than 0.0" }
    }
d1946 1
a1946 5
    hoc_register_data $shader_params($id,window).fr.transp_fr.valid_e Transparency {
	{ summary "If depressed, transparency is enabled using the transparency\n\
		color. Otherwise, the transparency color is ignored. The 'bump'\n\
		shader does not use this button."}
    }
d1948 16
a1963 13
    hoc_register_data $shader_params($id,window).fr.file File {
	{ summary "Enter the name of the file containing the texture to be mapped to this\n\
		object. This file should be a 'pix' file for the 'texture' or 'bump' shaders,\n\
		or a 'bw' file for 'bwtexture'. For the 'bump' shader, the red and blue\n\
		channels of the image are used to perturb the true surface normal.\n\
		Red and blue values of 128 produce no perturbation, while values of 0\n\
		produce maximum perturbation in one direction and 255 produces maximum\n\
		perturbation in the opposite"}
    }
    
    hoc_register_data $shader_params($id,window).fr.width Width {
	{ summary "Enter the width of the texture in pixels\n(default is 512)"}
    }
d1965 1
a1965 3
    hoc_register_data $shader_params($id,window).fr.height Height {
	{ summary "Enter the height of the texture in pixels\n(default is 512)"}
    }
d1967 1
a1967 53
    hoc_register_data $shader_params($id,window).fr.transp_fr.trans Transparency {
	{ summary "Enter the color in the texture that will be treated as\n\
		transparent. All pixels on this object that get assigned this\n\
		color from the texture will be treated as though this object\n\
		does not exist. For the 'texture' shader, this must be an RGB\n\
		triple. For the 'bwtexture' shader, a single value is sufficient.\n\
		The checkbutton to the left must be depressed for transparency\n\
		to be active. This is ignored for the 'bump' shader"}
	{ range "RGB values must be integers from 0 to 255"}
    }

#	set variables from current 'params' list

    set_texture_values $shader_str $id

    label $shader_params($id,window).fr.repl.repl_label \
	-text "Texture Replication"
    grid $shader_params($id,window).fr.repl.repl_label \
	-row 0 -column 0 -columnspan 4 -sticky ew
    grid $shader_params($id,window).fr.repl.u_scale \
	-row 1 -column 0 -sticky e
    grid $shader_params($id,window).fr.repl.u_scale_e \
	-row 1 -column 1 -sticky w
    grid $shader_params($id,window).fr.repl.v_scale \
	-row 1 -column 2 -sticky e
    grid $shader_params($id,window).fr.repl.v_scale_e \
	-row 1 -column 3 -sticky w
    grid $shader_params($id,window).fr.repl.mirror_e \
	-row 2 -column 1 -sticky e
    grid $shader_params($id,window).fr.repl.mirror \
	-row 2 -column 2 -sticky w

    grid $shader_params($id,window).fr.file_fr.file -row 0 -column 0 -sticky e
    grid $shader_params($id,window).fr.file_fr.file_e -row 0 -column 1 -columnspan 3 -sticky ew
    grid $shader_params($id,window).fr.file_fr.width -row 1 -column 0 -sticky e
    grid $shader_params($id,window).fr.file_fr.width_e -row 1 -column 1 -sticky w
    grid $shader_params($id,window).fr.file_fr.height -row 1 -column 2 -sticky e
    grid $shader_params($id,window).fr.file_fr.height_e -row 1 -column 3 -sticky w
    grid $shader_params($id,window).fr.file_fr -row 0 -column 0 -sticky ew
    grid columnconfigure $shader_params($id,window).fr.file_fr 0 -weight 1
    grid columnconfigure $shader_params($id,window).fr.file_fr 1 -weight 1
    grid columnconfigure $shader_params($id,window).fr.file_fr 2 -weight 1
    grid columnconfigure $shader_params($id,window).fr.file_fr 3 -weight 1
    grid $shader_params($id,window).fr.repl -row 1 -column 0 -sticky nsew
    grid $shader_params($id,window).fr.transp_fr.valid_e -row 0 -column 0 -sticky w
    grid $shader_params($id,window).fr.transp_fr.trans -row 0 -column 1 -sticky e
    grid $shader_params($id,window).fr.transp_fr.trans_e -row 0 -column 2 -sticky w
    grid $shader_params($id,window).fr.transp_fr -row 2 -column 0
    
    grid $shader_params($id,window).fr -sticky new -ipadx 3 -ipady 3
    grid columnconfigure $shader_params($id,window).fr 0 -weight 1

    return $shader_params($id,window).fr
d2030 1
a2030 1
proc stack_add { shader shade_var id childsite} {
d2035 2
a2036 2
	frame $childsite.stk_$index -bd 2 -relief groove
	set shader_params($id,stk_$index,window) $childsite.stk_$index
d2039 1
a2039 1
		label $childsite.stk_$index.lab -text $shader -bg CadetBlue -fg white
d2041 1
a2041 1
		label $childsite.stk_$index.lab -text "Unrecognized Shader" -bg CadetBlue -fg white
d2043 1
a2043 1
	grid $childsite.stk_$index.lab -columnspan 4 -sticky ew
d2046 1
a2046 1
	button $childsite.stk_$index.del -text delete -width 8 \
d2049 1
a2049 1
	hoc_register_data $childsite.stk_$index.del "Delete" {
d2112 3
a2114 3
	grid $childsite.stk_$index.del -columnspan 4
	grid $childsite.stk_$index -columnspan 2 -sticky ew
	grid columnconfigure $childsite.stk_$index 0 -minsize 400
d2121 2
a2122 3
    set childsite [$shader_params($id,window).fr.leesf childsite]
	frame $childsite.stk_$index -relief raised -bd 3
	set shader_params($id,stk_$index,window) $childsite.stk_$index
d2125 1
a2125 1
		label $childsite.stk_$index.lab -text $shader -bg CadetBlue -fg white
d2127 1
a2127 1
		label $childsite.stk_$index.lab -text "Unrecognized Shader" -bg CadetBlue -fg white
d2129 1
a2129 1
	button $childsite.stk_$index.del -text delete -width 8 \
d2132 1
a2132 1
	hoc_register_data $childsite.stk_$index.del "Delete" {
d2138 1
a2138 1
	grid $childsite.stk_$index.lab -columnspan 4 -sticky ew
d2197 1
a2197 1
	grid $childsite.stk_$index.del -columnspan 4 -sticky ew
d2202 2
a2203 2
		grid $childsite.stk_$i -columnspan 2 -sticky ew -row [expr $index + 2]
		grid columnconfigure $childsite.stk_$i 0 -minsize 400 -weight 1
d2246 1
a2246 1
			stack_add $shader $shader_params($id,shade_var) $id [$shader_params($id,window).fr.leesf childsite]
d2301 1
a2301 3
	frame $shader_params($id,window).fr -padx 3 -pady 3

    set childsite [[iwidgets::scrolledframe $shader_params($id,window).fr.leesf -width 432 -height 250 -hscrollmode dynamic ] childsite]
d2315 1
a2315 1
		-label plastic -command "stack_add plastic $shade_var $id $childsite; do_shader_apply $shade_var $id"
d2317 1
a2317 1
		-label glass -command "stack_add glass $shade_var $id $childsite; do_shader_apply $shade_var $id"
d2319 1
a2319 1
		-label mirror -command "stack_add mirror $shade_var $id $childsite; do_shader_apply $shade_var $id"
d2322 1
a2322 1
		-label light -command "stack_add light $shade_var $id $childsite; do_shader_apply $shade_var $id"
d2325 1
a2325 1
		-label "bump map" -command "stack_add bump $shade_var $id $childsite; do_shader_apply $shade_var $id"
d2327 1
a2327 1
		-label texture -command "stack_add texture $shade_var $id $childsite; do_shader_apply $shade_var $id"
d2329 1
a2329 1
		-label bwtexture -command "stack_add bwtexture $shade_var $id $childsite; do_shader_apply $shade_var $id"
d2331 1
a2331 1
		-label fakestar -command "stack_add fakestar $shade_var $id $childsite; do_shader_apply $shade_var $id"
d2333 1
a2333 1
		-label cloud -command "stack_add cloud $shade_var $id $childsite; do_shader_apply $shade_var $id"
d2335 1
a2335 1
		-label checker -command "stack_add checker $shade_var $id $childsite; do_shader_apply $shade_var $id"
d2337 1
a2337 1
		-label camouflage -command "stack_add camo $shade_var $id $childsite; do_shader_apply $shade_var $id"
d2339 1
a2339 1
		-label projection -command "stack_add prj $shade_var $id $childsite; do_shader_apply $shade_var $id"
d2341 1
a2341 1
		-label air -command "stack_add air $shade_var $id $childsite; do_shader_apply $shade_var $id"
d2343 1
a2343 1
		-label testmap -command "stack_add testmap $shade_var $id $childsite; do_shader_apply $shade_var $id"
d2345 3
a2347 1
		-label Unknown -command "stack_add unknown $shade_var $id $childsite; do_shader_apply $shade_var $id"
d2349 1
a2349 10
    grid $shader_params($id,window).fr.add -columnspan 2 -row 0
    grid $shader_params($id,window).fr.leesf -sticky nsew -row 1
    grid columnconfigure $shader_params($id,window).fr 0 -weight 1
    grid rowconfigure $shader_params($id,window).fr 1 -weight 1

    grid rowconfigure $shader_params($id,window) 0 -weight 1
    grid rowconfigure $shader_params($id,window) 1 -weight 0
    grid columnconfigure $shader_params($id,window) 0 -weight 1
    grid $shader_params($id,window).fr -sticky ewns
    grid rowconfigure $shader_params($id,window).fr 1 -weight 1
d2351 1
a2351 1
    set_stack_values $shade_str $id
d2353 1
a2353 1
    return $shader_params($id,window).fr
a2631 4
	        set shader_name [lindex $shader_str 0]
	        if { $shader_name != "cloud" } {
		    return
		}
d2697 1
a2697 1
	entry $shader_params($id,window).fr.param_e -width 20 -textvariable shader_params($id,unk_param)
d2720 3
d2724 1
a2724 1
	grid columnconfigure $shader_params($id,window).fr 0 -weight 0
a2827 4
	        set shader_name [lindex $shader_str 0]
	        if { $shader_name != "air" } {
		    return
		}
@


1.33
log
@patches to merge 5.3 into 6.0
@
text
@d272 1
a272 1
		12 $shader_params($id,c1)
d288 1
a288 1
		12 $shader_params($id,c2)
d304 1
a304 1
		12 $shader_params($id,c3)
@


1.32
log
@light routine was not setting default for shadow rays
@
text
@a1510 3



d1514 1
a1514 1
	e	target		t	{0 0 0}	"Point to which light is directed\n   (angle must be set)"   "any X,Y,Z"	2 0 \
d1528 1
d1539 1
d1621 1
a1621 1
        hoc_register_data $w.shadows shadows [list [list summary summary] [list range range]]
a1728 9









@


1.31
log
@Added Help-on-context for light shader gui
@
text
@d1531 1
d1541 1
@


1.30
log
@Changes to support the light shader gui
@
text
@d1514 8
a1523 32




######################################################################
proc labeled_entry {w name varname summary range} {
    upvar #0 $varname var
    set f [frame $w]

    pack [label $f.label -text $name] -side left -fill x
    pack [entry $f.entry -textvariable $varname -width 10] -side right

    hoc_register_data $f.label $name [list \
	[list summary $summary] \
	[list range $range] ]
    hoc_register_data $f.entry $name [list \
	[list summary $summary] \
	[list range $range] ]

    return $f
}

set light_variables {
b shadows  s 1 "Does the light cast shadows" 
b infinite i 0 "light infinitely far away (pos gives direction)" 
b visible  v 1 "Is the light object visible" 
v bright   b 1000 "1000"
v angle    a 180 ""
v fraction f 1 ""
v target   t {0 0 0} ""
}

d1526 1
a1526 1
	global light_variables
d1528 1
a1528 1
	foreach {type name abbrev def_val desc} $light_variables {
d1535 1
a1535 1
	global light_variables
d1537 1
a1537 1
	foreach {type name abbrev def_val desc} $light_variables {
a1541 1

d1544 1
a1544 1
	global light_variables
a1560 26
	# Create the labeled entry widgets
	set row 0
	foreach { n i } { bright b fraction f angle a target t } {
	    grid [label $w.${i}_lbl -text $n ] -row $row -column 0
	    grid [entry $w.${i}_ent -width 10 -textvariable shader_params($id,light_$i)]\
		 -row $row -column 1
	    bind $w.${i}_ent <KeyRelease> "do_shader_apply $shade_var $id"
	    incr row
	}

	# Create the scale for shadow rays
	grid [scale $w.shadows -orient horiz -label "Shadow Rays" \
		-from 0 -to 9 -bd 3 -relief sunken \
		-command "light_scale $shade_var $id $w.icon"\
		-variable shader_params($id,light_s) ] \
		-row 0 -column 2 -rowspan 3 -columnspan 2 -sticky nesw

	# Create checkboxes for booleans
	set column 2
	foreach { n i } { infinite i visible v } {
	    grid [checkbutton $w.${i} -text $n -relief sunken -bd 3 \
		-variable shader_params($id,light_$i) \
		-command "do_shader_apply $shade_var $id"] \
		-row 3 -column $column
	    incr column
	}
a1575 4
	# Create a label to display the selected image
	grid [label $w.icon -relief sunken -bd 3 \
		-image $shader_params(light_i0_v1_s1) ] \
		-rowspan 3 -row 0 -column 4
d1577 45
a1621 1
	set shader_params($id,icon) $w.icon
a1656 2

		tk_messageBox -message "set_light_values key $key  value $value"
@


1.29
log
@Changes to compile under RedHat 7.0
@
text
@d1545 1
a1545 1
v direct   d {0 0 0} ""
d1574 1
a1574 1

d1586 26
a1611 18
	grid [checkbutton $w.infinite -text Infinite \
		-variable shader_params($id,light_i) \
		-command "do_shader_apply $shade_var $id" ] \
		-row 0 -column 0

#	grid [scale $w.shadows -from 0 -to 9 -orient horiz -label "Shadows" \
#		-resolution 1 -variable shader_params($id,light_s) ] \
#		-row 0 -column 1

	grid [checkbutton $w.shadows -text "Shadows" \
		-variable shader_params($id,light_s) \
		-command "do_shader_apply $shade_var $id" ] \
		-row 0 -column 1

	grid [checkbutton $w.visible -text "Visible" \
		-variable shader_params($id,light_v) \
		-command "do_shader_apply $shade_var $id" ] \
		-row 0 -column 2
d1613 1
d1617 1
a1617 1
		    foreach s { 0 1 9 } {
d1621 1
a1621 1
				    "tclscripts/mged/l_i${i}_v${v}_s${s}.ppm"]]
d1627 1
d1630 1
a1630 1
		-rowspan 3 -row 0 -column 3
a1634 24
	grid [labeled_entry $w.bright bright shader_params($id,light_b) \
		"How bright should the light be" "0..1"] \
		-row 1 -column 0
	bind $w.bright.entry <KeyRelease> "do_shader_apply $shade_var $id"

	grid [labeled_entry $w.fraction fraction \
		shader_params($id,light_f) \
		"What percentage of the total light does this produce" \
		"0..1" ] \
		-row 1 -column 1
	bind $w.fraction.entry <KeyRelease> "do_shader_apply $shade_var $id"

	grid [labeled_entry $w.angle angle shader_params($id,light_a) \
		"What is the angle of the light cone?" "0..180"] \
		-row 2 -column 0
	bind $w.angle.entry <KeyRelease> "do_shader_apply $shade_var $id"

	grid [labeled_entry $w.direct direct \
		shader_params($id,light_d) \
		"Where is the light pointed (when angle < 180)" \
		"0..1"] \
		-row 2 -column 1
	bind $w.direct.entry <KeyRelease> "do_shader_apply $shade_var $id"

a1692 1

d1696 7
d1734 1
a1734 12

	 

	if { $shader_params($id,light_s) > 1 } then {
		append name "_s" 9
	} 

	if { $shader_params($id,light_s) > 0 } then {
		append name "_s" 1
	} else {
		append name "_s" 0
	}
@


1.28
log
@Added "light" shader to GUI, including Icons to help explain behaviour
@
text
@d1553 1
a1553 1
		set shader_params($id,def_light_$abbrev) $def_val
d1724 2
a1725 1
	         $shader_params($id,light_$varname) != $shader_params($id,def_light_$varname) } {
d2110 1
a2110 1
			set tmp_win [do_light $shade_var $id,light_$index]
@


1.27
log
@Added support for phong emissivity
@
text
@d1511 259
d2107 4
d2193 4
d2359 4
d2433 4
@


1.26
log
@Added some HOC to the extern shader and the new parameters of ther texture shader.
@
text
@d1002 19
d1189 8
a1196 6
	grid $shader_params($id,window).fr.ri -row 2 -column 1 -sticky e
	grid $shader_params($id,window).fr.ri_e -row 2 -column 2 -sticky w
	grid $shader_params($id,window).fr.shine -row 3 -column 1 -sticky e
	grid $shader_params($id,window).fr.shine_e -row 3 -column 2 -sticky w
	grid $shader_params($id,window).fr.ext -row 4 -column 1 -sticky e
	grid $shader_params($id,window).fr.ext_e -row 4 -column 2 -sticky w
d1225 1
d1289 6
d1367 5
d1386 1
d1399 1
d1412 1
@


1.26.2.1
log
@Added light shader GUI
@
text
@a1001 19
	label $shader_params($id,window).fr.emiss -text Emission
	entry $shader_params($id,window).fr.emiss_e -width 5 -textvariable shader_params($id,emiss)
	bind $shader_params($id,window).fr.emiss_e <KeyRelease> "do_shader_apply $shade_var $id"

	hoc_register_data $shader_params($id,window).fr.emiss Emissivity {
		{summary "In addition to reflecting and transmitting light,\n\
			an object may also emit or absorb light. This paramter\n\
			describes that property."}
		{description "Emissivity/absorption"}
		{range "-1.0 through 1.0"}
	}

	hoc_register_data $shader_params($id,window).fr.emiss_e Emissivity {
		{summary "In addition to reflecting and transmitting light,\n\
			an object may also emit or absorb light. This paramter\n\
			describes that property."}
		{description "Emissivity/absorption"}
		{range "-1.0 through 1.0"}
	}
d1170 6
a1175 8
	grid $shader_params($id,window).fr.ri -row 2 -column 0 -sticky e
	grid $shader_params($id,window).fr.ri_e -row 2 -column 1 -sticky w
	grid $shader_params($id,window).fr.shine -row 3 -column 0 -sticky e
	grid $shader_params($id,window).fr.shine_e -row 3 -column 1 -sticky w
	grid $shader_params($id,window).fr.ext -row 2 -column 2 -sticky e
	grid $shader_params($id,window).fr.ext_e -row 2 -column 3 -sticky w
	grid $shader_params($id,window).fr.emiss -row 3 -column 2 -sticky e
	grid $shader_params($id,window).fr.emiss_e -row 3 -column 3 -sticky w
a1203 1
	set shader_params($id,emiss) $shader_params($id,def_emiss)
a1266 6
				emission -
				em { catch {
					if { $value != $shader_params($id,def_emiss) } then {
						set shader_params($id,emiss) $value }
					}
				}
a1338 5
	if { [string length $shader_params($id,emiss)] > 0 } then {
	    catch {
		if { [expr $shader_params($id,emiss) != $shader_params($id,def_emiss)] } then {
			lappend params em $shader_params($id,emiss) } }
	    }
a1352 1
	set shader_params($id,def_emiss) 0
a1364 1
	set shader_params($id,def_emiss) 0
a1376 1
	set shader_params($id,def_emiss) 0
a1474 228



set light_data {
	e	fraction	f	1.0	"fraction of total light contributed"		"0..1" 		0 0 \
	e	angle		a	180	"angle of light cone"				"0..180" 	1 0 \
	e	target		t	{0 0 0}	"Point to which light is directed\n   (angle must be set)"   "any X,Y,Z"	2 0 \
	c	infinite 	i	0	"Boolean: light is infinite distance away"	"0,1" 		3 2 \
	c	visible 	v	1	"Boolean: light souce object can be seen"	"0,1" 		3 3 \
	i	icon		icon	""	"Shows effect of values for:\n  Shadow Rays\n  infinite\n  visible" "" 0 4 \
    }


proc set_light_defaults { id } {
	global shader_params
	global light_data

	foreach {type name abbrev def_val desc range row col } $light_data {
		set shader_params(def_light_$abbrev) $def_val
	}
}

proc assign_light_defaults { id } {
	global shader_params
	global light_data

	foreach {type name abbrev def_val desc range row col } $light_data {
		set shader_params($id,light_$abbrev) $def_val
	}
}

proc do_light { shade_var id } {
	global shader_params
	global light_data
	upvar #0 $shade_var shader_str

	# Destroy our frame in case it already exists
	catch { destroy $shader_params($id,window).fr }
 
	# Create a frame for the widgets for this shader
	frame $shader_params($id,window).fr


	# For each variable, create a label and an entry widgets
	# and bind <KeyRelease> so that the shader string wil be updated

	set w $shader_params($id,window).fr

	assign_light_defaults $id


	# Load the images
	if { [info exists shader_params(light_i0_v0_s0)] == 0 } {
	    foreach i { 0 1 } {
		foreach v { 0 1 } {
		    foreach s { 0 1 2 3 4 5 6 7 8 9 } {
			set shader_params(light_i${i}_v${v}_s${s}) \
			  [image create photo -file \
				[bu_brlcad_path \
				    "tclscripts/mged/l_i${i}_v${v}_s${s}.gif"]]
		    }
		}
	    }
	}




	foreach {type name abbrev def_val summary range row col } $light_data {
	    switch $type {
		e {
		    # Create the labeled entry widgets
		    grid [label $w.${abbrev}_lbl -text $name ] -row $row -column $col
		    grid [entry $w.${abbrev}_ent -width 10 -textvariable shader_params($id,light_$abbrev)]\
			 -row $row -column [expr $col + 1]

		    bind $w.${abbrev}_ent <KeyRelease> "do_shader_apply $shade_var $id"

		    hoc_register_data $w.${abbrev}_lbl $name [list [list summary $summary] [list range "$range (default: $def_val)"]]
		    hoc_register_data $w.${abbrev}_ent $name [list [list summary $summary] [list range "$range (default: $def_val)"]]
		}
		c {
		   # Create checkboxes
		    grid [checkbutton $w.${abbrev} -text $name -relief sunken -bd 3 \
			-variable shader_params($id,light_$abbrev) \
			-command "do_shader_apply $shade_var $id"] \
			-row $row -column $col

		    hoc_register_data $w.${abbrev} $name [list [list summary $summary] [list range "$range (default: $def_val)"]]
		}
		i {
		   # Create label to display the selected image

		    grid [label $w.icon -relief sunken -bd 3 \
			-image $shader_params(light_i0_v1_s1) ] \
			-rowspan 3 -row $row -column $col
		    hoc_register_data $w.icon shadows [list [list summary $summary]]

		    set shader_params($id,icon) $w.icon
		}
	    }
	}

	# Create the scale for shadow rays
	grid [scale $w.shadows -orient horiz -label "Shadow Rays" \
		-from 0 -to 9 -bd 3 -relief sunken \
		-command "light_scale $shade_var $id $w.icon"\
		-variable shader_params($id,light_s) ] \
		-row 0 -column 2 -rowspan 3 -columnspan 2 -sticky nesw
        hoc_register_data $w.shadows shadows [list [list summary summary] [list range range]]



	# Set the entry widget values from the current shader string
	set_light_values $shader_str $id

	# Grid the shader widget window into the parent widget
	grid $shader_params($id,window).fr -sticky ew -ipadx 3 -ipady 3

	# weight the columns of the grid evenly
	grid columnconfigure $shader_params($id,window).fr 0 -weight 1
	grid columnconfigure $shader_params($id,window).fr 1 -weight 1

	return $shader_params($id,window).fr
}

# set the entry widget values from the shader string and
# fill in the gui variables

# called when user modifies shader string directly
proc set_light_values { shader_str id } {
	global shader_params

	# grab OUR shader parameters from the shader string
	if { [llength $shader_str] > 1 } then {
		set params [lindex $shader_str 1]
	} else {
		set params ""
	}

	set err [catch {set list_len [llength $params]}]
	if { $err } {set  list_len 0}
	if { $list_len > 1 } then {

	    # For each of my parameters, set 
	    foreach { key value } $params {

		switch -- $key {
		    default {
				tk_messageBox -message "key $key value $value"
		    }
		    infinite -
		    i { set shader_params($id,light_i) $value }
		    visible -
		    v {	set shader_params($id,light_v) $value }
		    shadows -
		    s {	set shader_params($id,light_s) $value }
		    bright -
		    b {	set shader_params($id,light_b) $value }
		    angle -
		    a { set shader_params($id,light_a) $value }
		    fraction -
		    f { set shader_params($id,light_f) $value }
		    direct -
		    d { set shader_params($id,light_d) $value }
		}
	    }
	}

	do_light_icon $id

}
# Since the scale appends a value to the end of it's args, we can't
# use do_shader_apply directly for scale widgets  That's why we have this
# wrapper proc
proc light_scale {shade_var id icon val args} {
	global shader_params
	do_shader_apply $shade_var $id
}

# This routine takes the values in the shader_params array and creates
# A shader string from it.
# This is called when the user modifies a value in one of the entry widgets
proc do_light_apply { shade_var id } {
	global shader_params
	upvar #0 $shade_var shader

	set params ""

	set pattern ($id,light_)(\[a-z\]*)
	foreach i [array names shader_params] {
	    if { [regexp $pattern $i name head varname] && \
	         $shader_params($id,light_$varname) != \
	         $shader_params(def_light_$varname) } {
			lappend params $varname $shader_params($id,light_$varname)
		}
	}

	do_light_icon $id

	set shader [list "light" $params ]
}

proc do_light_icon { id } {
	global shader_params

	set name ""

	append name "light_i" $shader_params($id,light_i) 
	append name "_v"  $shader_params($id,light_v)
	append name "_s"  $shader_params($id,light_s)

	$shader_params($id,icon) configure -image $shader_params($name)
}


######################################################################











a1811 4
		light {
			set_light_defaults "$id,light_$index"
			set tmp_win [do_light $shade_var $id,stk_$index]
		}
a1893 4
		light {
			set_light_defaults "$id,light_$index"
			set tmp_win [do_light $shade_var $id,light_$index]
		}
a2055 4

	$shader_params($id,window).fr.add.m add command \
		-label light -command "stack_add light $shade_var $id; do_shader_apply $shade_var $id"

a2125 4
		}
		light {
			set_light_defaults "$id,light_$index"
			set tmp_win [do_light $shade_var $id,light_$index]
@


1.26.2.2
log
@corrected abbreviation for light target, added default setting for shadow rays,
added HOC data for shadow rays
@
text
@d1517 1
a1517 1
	e	target		d	{0 0 0}	"Point to which light is directed\n   (angle must be less than 180)"   "any X,Y,Z"	2 0 \
a1530 2

	set shader_params(def_light_s) 1
d1620 1
a1620 1
        hoc_register_data $w.shadows shadows [list [list summary "number of rays to fire at light source in determining shadow\n0 rays means no shadows"] [list range "0..9"]]
@


1.26.2.3
log
@Number of shadow rays was not getting initialized to the default
@
text
@a1541 2

	set shader_params($id,light_s) $shader_params(def_light_s)
@


1.25
log
@Added Lee's changes to the texture shader
@
text
@d60 1
d65 4
a68 1
			will apply the 'camo' shader, then the 'plastic' shader."}
d75 1
d80 4
a83 1
			will apply the 'camo' shader, then the 'plastic' shader."}
d1594 52
@


1.24
log
@Added Lee's 'extern' shader
@
text
@d1406 3
d1452 10
d1504 10
d1542 10
d1633 1
a1633 1
	grid $shader_params($id,window).fr.file_e -row 0 -column 1 -columnspan 3 -sticky w
d1638 10
a1647 4
	grid $shader_params($id,window).fr.trans -row 2 -column 0 -sticky e
	grid $shader_params($id,window).fr.trans_e -row 2 -column 1 -sticky w
	grid $shader_params($id,window).fr.valid_e -row 2 -column 2 -sticky e
	grid $shader_params($id,window).fr.valid -row 2 -column 3 -sticky w
@


1.23
log
@

Limit line-length of the description at the head of the file
@
text
@d43 77
@


1.22
log
@Simplified switch statements and added some comments
@
text
@d8 2
a9 1
#	1. add the new shader to the switch command in 'stack_add', 'stack_insert', and 'env_select', if this shader is
d11 6
a16 3
#	2. add the new shader to the menus in 'do_stack' and 'do_envmap' (again, if appropriate)
#	3. add a menu item for the new shader in 'init_comb' (comb.tcl) (required)
#	4. add the following routines: (all are required, replace 'newshader' with your shader name
@


1.21
log
@Added 'air' shader and    improved HOC for camo
@
text
@d3 1
d8 1
a8 4
#	1. add the new shader to the 'switch' in 'do_shader_apply'
#	2. add the new shader to the 'switch' in 'do_shader'
#	3. add the new shader to the 'switch' in 'set_shader_params'
#	4. add the new shader to the switch command in 'stack_add', 'stack_insert', and 'env_select', if this shader is
d10 3
a12 4
#	5. add the new shader to the menus in 'do_stack' and 'do_envmap'
#	6. add a menu item for the new shader in 'init_comb' (comb.tcl)
#	7. add the new shader to the list of shader names in the 'is_good_shader' proc
#	8. add the following routines:
d15 3
a17 2
#	creates the labels, entries, buttons... Also registers 'help-in-context' data
#	calls 'set_newshader_values' to set initial settings of widgets
a29 4




d61 1
a61 1
	entry $shader_params($id,window).fr.lacun_e -width 5 -textvariable shader_params($id,lacun)
d87 1
a87 1
	entry $shader_params($id,window).fr.h_e -width 5 -textvariable shader_params($id,hval)
d109 1
a109 1
	entry $shader_params($id,window).fr.octaves_e -width 5 -textvariable shader_params($id,octaves)
d133 1
a133 1
	entry $shader_params($id,window).fr.size_e -width 5 -textvariable shader_params($id,size)
d227 1
a227 1
	entry $shader_params($id,window).fr.t1_e -width 5 -textvariable  shader_params($id,t1)
d251 1
a251 1
	entry $shader_params($id,window).fr.t2_e -width 5 -textvariable  shader_params($id,t2)
d356 11
a366 11
	set shader_params($id,c1) ""
	set shader_params($id,c2) ""
	set shader_params($id,c3) ""
	set shader_params($id,lacun) ""
	set shader_params($id,hval) ""
	set shader_params($id,octaves) ""
	set shader_params($id,size) ""
	set shader_params($id,scale) ""
	set shader_params($id,t1) ""
	set shader_params($id,t2) ""
	set shader_params($id,delta) ""
d791 3
a793 2
	set shader_params($id,ckr_a) ""
	set shader_params($id,ckr_b) ""
d873 12
d1108 7
a1114 9
#	make sure all the entry variables start empty

	set shader_params($id,trans) ""
	set shader_params($id,refl) ""
	set shader_params($id,spec) ""
	set shader_params($id,diff) ""
	set shader_params($id,ri) ""
	set shader_params($id,shine) ""
	set shader_params($id,ext) ""
d1323 2
a1324 2
	set shader_params($id,width) ""
	set shader_params($id,height) ""
d1414 8
d2175 3
a2177 2
	set shader_params($id,cl_thresh) ""
	set shader_params($id,cl_range) ""
d2330 8
d2357 4
d2370 3
a2372 1
	set shader_params($id,density) ""
d2390 1
a2390 1
							set $shader_params($id,dennsity) $value
d2396 9
a2404 2
						if { $value != $shader_params($id,def_density) } then {
							set $shader_params($id,dennsity) $value
a2407 1

d2425 12
d2444 1
a2444 1
	set shader_params($id,def_scale) 1.0
d2461 4
a2464 49
		switch $shader {
			glass {
				set_glass_values $shade_str $id
			}
			mirror {
				set_mirror_values $shade_str $id
			}
			plastic {
				set_phong_values $shade_str $id
			}
			bump {
				set_bump_values $shade_str $id
			}
			bwtexture {
				set_bwtexture_values $shade_str $id
			}
			texture {
				set_texture_values $shade_str $id
			}
			checker {
				set_checker_values $shade_str $id
			}
			testmap {
				set_testmap_values $shade_str $id
			}
			fakestar {
				set_fakestar_values $shade_str $id
			}
			stack {
				set_stack_values $shade_str $id
			}
			envmap {
				set_envmap_values $shade_str $id
			}
			cloud {
				set_cloud_values $shade_str $id
			}
			prj {
				set_prj_values $shade_str $id
			}
			camo {
				set_camo_values $shade_str $id
			}
			air {
				aet_air_values $shade_str $id
			}
			default {
				set_unknown_values $shade_str $id
			}
d2491 7
a2497 59
		switch $material {
			glass {
				set_glass_defaults $id
				set my_win [do_phong $shade_var $id]
			}
			mirror {
				set_mirror_defaults $id
				set my_win [do_phong $shade_var $id]
			}
			plastic {
				set_plastic_defaults $id
				set my_win [do_phong $shade_var $id]
			}
			bump -
			bwtexture -
			texture {
				set_texture_defaults $id
				set my_win [do_texture $shade_var $id]
			}
			checker {
				set_checker_defaults $id
				set my_win [do_checker $shade_var $id]
			}
			testmap {
				set_testmap_defaults $id
				set my_win [do_testmap $shade_var $id]
			}
			fakestar {
				set_fakestar_defaults $id
				set my_win [do_fakestar $shade_var $id]
			}
			stack {
				set_stack_defaults $id
				set my_win [do_stack $shade_var $id]
			}
			envmap {
				set_envmap_defaults $id
				set my_win [do_envmap $shade_var $id]
			}
			cloud {
				set_cloud_defaults $id
				set my_win [do_cloud $shade_var $id]
			}
			prj {
				set_prj_defaults $id
				set my_win [do_prj $shade_var $id]
			}
			camo {
				set_camo_defaults $id
				set my_win [do_camo $shade_var $id]
			}
			air {
				set_air_defaults $id
				set my_win [do_air $shade_var $id]
			}
			default {
				set_unknown_defaults $id
				set my_win [do_unknown $shade_var $id]
			}
d2509 1
d2512 4
a2515 47
	switch $current_shader_type {

		plastic {
			do_plastic_apply $shade_var $id
		}
		mirror {
			do_mirror_apply $shade_var $id
		}
		glass {
			do_glass_apply $shade_var $id
		}

		bump -
		bwtexture -
		texture {
			do_texture_apply $shade_var $id
		}
		checker {
			do_checker_apply $shade_var $id
		}
		testmap {
			do_testmap_apply $shade_var $id
		}
		fakestar {
			do_fakestar_apply $shade_var $id
		}
		stack {
			do_stack_apply $shade_var $id
		}
		envmap {
			do_envmap_apply $shade_var $id
		}
		cloud {
			do_cloud_apply $shade_var $id
		}
		prj {
			do_prj_apply $shade_var $id
		}
		camo {
			do_camo_apply $shade_var $id
		}
		air {
			do_air_apply $shade_var $id
		}
		default {
			do_unknown_apply $shade_var $id
		}
d2520 2
a2521 18
	switch $shader {
		stack -
		plastic -
		glass -
		mirror -
		bump -
		texture -
		bwtexture -
		fakestar -
		checker -
		envmap -
		cloud -
		prj -
		camo -
		air -
		testmap { return 1 }
		default { return 0 }
	}
@


1.20
log
@Fixed some minor bugs
@
text
@d70 1
a70 1
		{summary "The 'camo' shader creates a pseudo-random tri-color camoflage pattern\n\
d81 1
a81 1
		{summary "The 'camo' shader creates a pseudo-random tri-color camoflage pattern\n\
d96 1
a96 1
		{summary "The 'camo' shader creates a pseudo-random tri-color camoflage pattern\n\
d101 2
a102 2
		{description "The value for H (default is 1.0)"}
		{range "??"}
d105 1
a105 1
		{summary "The 'camo' shader creates a pseudo-random tri-color camoflage pattern\n\
d110 2
a111 2
		{description "The value for H (default is 1.0)"}
		{range "??"}
d118 1
a118 1
		{summary "The 'camo' shader creates a pseudo-random tri-color camoflage pattern\n\
d128 1
a128 1
		{summary "The 'camo' shader creates a pseudo-random tri-color camoflage pattern\n\
d142 1
a142 1
		{summary "The 'camo' shader creates a pseudo-random tri-color camoflage pattern\n\
d151 1
a151 1
		{summary "The 'camo' shader creates a pseudo-random tri-color camoflage pattern\n\
d164 1
a164 1
		{summary "The 'camo' shader creates a pseudo-random tri-color camoflage pattern\n\
d169 2
a170 1
		{description "Three scale values are required (X, Y, and Z)."}
d174 1
a174 1
		{summary "The 'camo' shader creates a pseudo-random tri-color camoflage pattern\n\
d179 2
a180 1
		{description "Three scale values are required (X, Y, and Z)."}
d191 1
a191 1
		{summary "The 'camo' shader creates a pseudo-random tri-color camoflage pattern\n\
d207 1
a207 1
		{summary "The 'camo' shader creates a pseudo-random tri-color camoflage pattern\n\
d223 1
a223 1
		{summary "The 'camo' shader creates a pseudo-random tri-color camoflage pattern\n\
d236 1
a236 1
		{summary "The 'camo' shader creates a pseudo-random tri-color camoflage pattern\n\
d245 2
a246 2
	hoc_register_data $shader_params($id,window).fr.t1_e "Noise Scale" {
		{summary "The 'camo' shader creates a pseudo-random tri-color camoflage pattern\n\
d260 1
a260 1
		{summary "The 'camo' shader creates a pseudo-random tri-color camoflage pattern\n\
d266 2
a267 2
			will be colored using color #2 (default is 0.25)"}
		{range " -1.0 to +1.0"}
d269 2
a270 2
	hoc_register_data $shader_params($id,window).fr.t2_e "Noise Scale" {
		{summary "The 'camo' shader creates a pseudo-random tri-color camoflage pattern\n\
d276 2
a277 2
			will be colored using color #2 (default is 0.25)"}
		{range " -1.0 to +1.0"}
d284 1
a284 1
		{summary "The 'camo' shader creates a pseudo-random tri-color camoflage pattern\n\
d293 1
a293 1
		{summary "The 'camo' shader creates a pseudo-random tri-color camoflage pattern\n\
d1649 4
d1731 4
d1880 2
d1968 4
d2305 97
d2458 3
d2541 4
d2603 3
d2627 1
@


1.19
log
@Added camo and projection shaders
@
text
@d1 1
a1 1
# these routines implement the gui for the BRL-CAD shaders
d1525 2
a1526 2
# this may be called via a binding in some other shader and so might get the 'id' from
# that shader. So it may be of the form 'id_#,stk_#' (where # is some number)
a1544 10
#		if { ![is_good_shader $shader_name] } then {
#			# this is an unrecognized shader
#			if { [is_good_shader [lindex $shade_str 0]] } then {
#				# and the name has changed to a recognized shader
#				stack_delete $index $shade_var $id
#				stack_insert $index [lindex $shade_str 0] $shade_var $id
#				set_${shader}_values $shade_str $id,stk_$i
#				do_shader_apply $shade_var $use_id,stk_$index
#			}
#		}
d1570 2
a1571 1
# destroy the shader subwindow
d1574 1
a1574 1
# adjust the shader list
a1576 1
#	do_stack_apply $shade_var $id
d1595 8
a1602 2
	button $shader_params($id,window).fr.stk_$index.del -text delete \
		-command "stack_delete $index $shade_var $id" -width 8
a1655 1
#	do_shader_apply $shade_var $id
d1670 8
a1677 2
	button $shader_params($id,window).fr.stk_$index.del -text delete \
		-command "stack_delete $index $shade_var $id"
a1738 2

#	do_stack_apply $shade_var $id
d1848 1
a1848 1
		-label plastic -command "stack_add plastic $shade_var $id"
d1850 1
a1850 1
		-label glass -command "stack_add glass $shade_var $id"
d1852 1
a1852 1
		-label mirror -command "stack_add mirror $shade_var $id"
d1854 1
a1854 1
		-label "bump map" -command "stack_add bump $shade_var $id"
d1856 1
a1856 1
		-label texture -command "stack_add texture $shade_var $id"
d1858 1
a1858 1
		-label bwtexture -command "stack_add bwtexture $shade_var $id"
d1860 1
a1860 1
		-label fakestar -command "stack_add fakestar $shade_var $id"
d1862 1
a1862 1
		-label cloud -command "stack_add cloud $shade_var $id"
d1864 1
a1864 1
		-label checker -command "stack_add checker $shade_var $id"
d1866 1
a1866 1
		-label camouflage -command "stack_add camo $shade_var $id"
d1868 1
a1868 1
		-label projection -command "stack_add prj $shade_var $id"
d1870 1
a1870 1
		-label testmap -command "stack_add testmap $shade_var $id"
d1872 1
a1872 1
		-label Unknown -command "stack_add unknown $shade_var $id"
d1961 1
a1961 1
	do_envmap_apply $shade_var $id
a1965 1
	return
d2005 1
a2005 1
	set err [ctach {set env_params [lindex $shade_str 1]}]
d2012 16
a2027 1
	env_select $shader $shader_params($id,shade_var) $id
a2032 1
	do_shader_apply $shader_params($id,shade_var) $id
d2053 1
a2053 1
		-label plastic -command "env_select plastic $shade_var $id"
d2055 1
a2055 1
		-label glass -command "env_select glass $shade_var $id"
d2057 1
a2057 1
		-label mirror -command "env_select mirror $shade_var $id"
d2059 1
a2059 1
		-label "bump map" -command "env_select bump $shade_var $id"
d2061 1
a2061 1
		-label texture -command "env_select texture $shade_var $id"
d2063 1
a2063 1
		-label bwtexture -command "env_select bwtexture $shade_var $id"
d2065 1
a2065 1
		-label fakestar -command "env_select fakestar $shade_var $id"
d2067 1
a2067 1
		-label cloud -command "env_select cloud $shade_var $id"
d2069 1
a2069 1
		-label checker -command "env_select checker $shade_var $id"
d2071 1
a2071 1
		-label camouflage -command "env_select camo $shade_var $id"
d2073 1
a2073 1
		-label projection -command "env_select prj $shade_var $id"
d2075 1
a2075 1
		-label testmap -command "env_select testmap $shade_var $id"
d2077 1
a2077 1
		-label Unrecognized -command "env_select unknown $shade_var $id"
d2079 1
a2079 1
		-label stack -command "env_select stack $shade_var $id"
d2224 6
d2254 2
a2255 2
	if { $err } {return}
	if { [string compare "stack" $shader] == 0 || [string compare "envmap" $shader] == 0 } then {
d2257 10
@


1.18
log
@Removed reference to my home directory :-)
@
text
@d10 1
a10 1
#	4. add the new shader to the switch command in 'stack_add' and 'env_select', if this shader is
d12 4
a15 3
#	5. add a menu item for the new shader in 'init_comb' (comb.tcl)
#	6. add the new shader to the list of shader names in the 'is_good_shader' proc
#	7. add the following routines:
d32 622
d803 2
a804 1
	set list_len [llength $params]
d1114 2
a1115 1
	set list_len [llength $params]
d1324 2
a1325 1
	set list_len [llength $params]
d1586 1
a1586 1
	do_stack_apply $shade_var $id
d1643 8
d1660 1
a1660 1
	do_shader_apply $shade_var $id
d1716 8
d1739 1
a1739 1
	do_stack_apply $shade_var $id
d1750 2
a1751 1
	set rerun_stack_apply 0
d1753 1
a1753 1
	set shader [lindex $shade_str 0]
d1756 1
a1767 1

d1771 1
d1773 1
d1776 2
d1793 2
a1818 1
							set rerun_stack_apply 1
a1827 2

	if { $rerun_stack_apply } {do_stack_apply $shader_params($id,shade_var) $id}
d1867 4
d1949 8
d2007 2
a2008 1
	set env_params [lindex $shade_str 1]
d2059 4
d2141 2
a2142 1
	set list_len [llength $params]
d2235 2
a2236 1
	set shader [lindex $shader_str 0]
d2261 1
d2264 1
a2264 1
	global shader_params
d2269 54
a2322 1
	if { [string compare $shader $shader_params($id,shader_name)] } { 
a2325 42

	switch $shader {
		glass {
			set_glass_values $shade_str $id
		}
		mirror {
			set_mirror_values $shade_str $id
		}
		plastic {
			set_phong_values $shade_str $id
		}
		bump {
			set_bump_values $shade_str $id
		}
		bwtexture {
			set_bwtexture_values $shade_str $id
		}
		texture {
			set_texture_values $shade_str $id
		}
		checker {
			set_checker_values $shade_str $id
		}
		testmap {
			set_testmap_values $shade_str $id
		}
		fakestar {
			set_fakestar_values $shade_str $id
		}
		stack {
			set_stack_values $shade_str $id
		}
		envmap {
			set_envmap_values $shade_str $id
		}
		cloud {
			set_cloud_values $shade_str $id
		}
		default {
			set_unknown_values $shade_str $id
		}
	}
d2333 1
a2333 1
	global shader_params
d2345 1
d2389 8
d2449 6
d2474 2
@


1.17
log
@Added support for unrecognized shader strings and made some other small mods.
@
text
@a0 2
#!/vld/jra/brlcad/.libtk.m4i64/wish

@


1.16
log
@Delete method for stack shader needed to update the shader string
@
text
@a913 1
	set index 0
d915 1
a915 1
		if {$shader_params($use_id,stk_$index,shader_name) == "" } {continue}
d917 3
d921 16
a936 1
		lappend params $shade_str
a955 1

a958 3
# remove the shader from the 'delete' menu
	catch {$shader_params($id,window).fr.del.m delete $index}

d973 5
a977 1
	label $shader_params($id,window).fr.stk_$index.lab -text $shader
d981 2
a982 3
	set index_lab [expr $index + 1]
	$shader_params($id,window).fr.del.m add command -label "$shader"\
		-command "stack_delete $index $shade_var $id"
d1019 4
d1025 1
d1028 71
d1110 2
d1134 2
a1136 1
				stack_add $shader $shader_params($id,shade_var) $id
d1138 2
d1142 1
d1145 7
a1151 4
				if { [string length $shader_params($id,stk_$i,shader_name)] } {
					incr count
					if { $count == $index } then {
						if { [string compare $shader_params($id,stk_$i,shader_name) $shader] == 0 } then {
d1154 11
d1166 5
a1170 4
							if { [is_good_shader $shader] } then {
								stack_add $shader $shader_params($id,shade_var) $id
								set j [expr $shader_params($id,stack_len) - 1 ]
								set_${shader}_values $sub_str $id,stk_$j
d1172 4
d1182 2
d1224 2
a1225 10

	menubutton $shader_params($id,window).fr.del\
		-menu $shader_params($id,window).fr.del.m\
		-text "Delete shader" -relief raised
	hoc_register_data $shader_params($id,window).fr.del "Delete Shader" {
		{summary "Use this menu to select a shader to delete from\n\
			the stack"}
	}

	menu $shader_params($id,window).fr.del.m -tearoff 0
d1227 1
a1227 1
	grid $shader_params($id,window).fr.add $shader_params($id,window).fr.del
a1238 2
	if { [is_good_shader $shader] == 0 } {return}

d1301 4
d1306 1
a1306 1

a1356 2
	if { [is_good_shader $shader] == 0 } {return}

d1358 6
a1363 1
	set_${shader}_values $env_params $id,env
d1404 2
d1530 68
a1602 1

d1609 1
a1609 1
	
d1636 1
a1636 1
				set_fakestar_values $shade_str $id
d1647 3
d1663 1
d1713 4
d1764 3
@


1.15
log
@Added Lee's new parameter for the Checker shader.
@
text
@d937 1
a937 1
proc stack_delete { index id } {
d949 1
d966 1
a966 1
		-command "stack_delete $index $id"
d1053 1
a1053 1
							stack_delete $i $id
@


1.14
log
@Stack Shader wasn't putting new shaders in the shad string immediately.
@
text
@d119 3
d141 10
d158 2
d201 5
d233 7
d249 1
@


1.13
log
@Fixed a typo.
@
text
@d978 1
@


1.12
log
@Minor clean-up.
@
text
@d579 1
a579 1
		if { [expr compare $shader_params($id,ri) != $shader_params($id,def_ri)] } then {
d1448 1
a1448 5
	if { [llength $shade_str] < 1 } then {
		set shade_str plastic
		set shader_params($id,shader_name) $shade_str
		set my_win [do_plastic $shade_var $id]
	} else {
@


1.11
log
@Fixed a few bugs in comparisions (used 'catch')
@
text
@d46 2
a47 2
	grid $shader_params($id,window).fr.fakestar_m -row 0 -column 1 -columnspan 2
	grid $shader_params($id,window).fr -columnspan 4
d49 3
d83 5
a87 2
	grid $shader_params($id,window).fr.tst_m -row 0 -column 1 -columnspan 2
	grid $shader_params($id,window).fr -columnspan 4
d141 4
a144 4
	grid $shader_params($id,window).fr.color1 -row 0 -column 1 -sticky e
	grid $shader_params($id,window).fr.color1_e -row 0 -column 2 -sticky w
	grid $shader_params($id,window).fr.color2 -row 1 -column 1 -sticky e
	grid $shader_params($id,window).fr.color2_e -row 1 -column 2 -sticky w
d146 2
a147 1
	grid $shader_params($id,window).fr -columnspan 4
d149 4
d429 1
a429 1
	grid $shader_params($id,window).fr -columnspan 4
d862 1
a862 1
	grid $shader_params($id,window).fr -columnspan 4
d932 1
a932 1
	grid $shader_params($id,window).fr.stk_$index.lab -columnspan 4
d936 1
a936 1
	$shader_params($id,window).fr.del.m add command -label "#$index_lab $shader"\
d977 1
d1072 2
d1088 1
a1088 1
	grid $shader_params($id,window).fr -ipadx 3 -ipady 3 -sticky ew
d1119 3
a1121 1
	grid $shader_params($id,window).fr.env.lab -columnspan 4
a1163 1
	grid $shader_params($id,window).fr.env -sticky ew
d1262 1
a1262 2
	grid $shader_params($id,window).fr -ipadx 3 -ipady 3 -sticky ew
	grid columnconfigure $shader_params($id,window).fr 0 -weight 1
d1292 1
a1292 1
			otherwise it becomes blue sky." The default value is 0.35}
d1317 1
a1317 1
	grid $shader_params($id,window).fr -columnspan 4
@


1.10
log
@Added envmap and cloud gui's.
@
text
@d115 2
a116 1
		{summary "Enter one of the colors to use in the checkerboard pattern"}
d120 2
a121 1
		{summary "Enter another color to use in the checkerboard pattern"}
d164 1
a164 1
				a {
d167 1
d170 1
a170 1
				b {
d173 1
d188 5
a192 3
	if { [string length $shader_params($id,ckr_a) ] > 0 } then {
		if { $shader_params($id,ckr_a) != $shader_params($id,def_ckr_a) } then {
			lappend params a $shader_params($id,ckr_a)
d195 5
a199 3
	if { [string length $shader_params($id,ckr_b) ] > 0 } then {
		if { $shader_params($id,ckr_b) != $shader_params($id,def_ckr_b) } then {
			lappend params b $shader_params($id,ckr_b)
d461 1
a461 1
				ri {
d464 1
d468 1
a468 1
				sh {
d471 1
d475 1
a475 1
				sp {
d478 1
d482 1
a482 1
				di {
d485 1
d489 1
a489 1
				tr {
d492 1
d496 1
a496 1
				re {
d499 1
d504 1
a504 1
				ex {
d507 1
d547 1
d550 1
d552 1
d555 1
d557 1
d560 1
d562 1
d565 1
d567 1
d570 1
d572 1
d575 1
d577 1
d580 1
d670 1
a670 1
				w {
d673 1
d677 1
a677 1
				l {
d680 1
d722 2
a723 1
		if { [expr $shader_params($id,width) != $shader_params($id,def_width)] } then {
d725 1
d727 2
a728 1
		if { [expr $shader_params($id,height) != $shader_params($id,def_height)] } then {
d730 1
d1005 1
a1005 1
				if { $shader_params($id,stk_$i,shader_name) != "" } {
d1085 9
a1093 2
	set err [catch "set tmp $shader_params($id,env,shader_name)"]
	if { $err != 0 } {
a1094 2
	} else {
		set old_shader $tmp
d1096 1
d1269 27
d1324 1
a1324 1
				thresh {
d1327 1
d1329 1
a1329 1
				range {
d1332 1
d1348 2
a1349 1
		if { [expr $shader_params($id,cl_thresh) != $shader_params($id,def_cl_thresh)] } then {
d1351 1
d1353 2
a1354 1
		if { [expr $shader_params($id,cl_range) != $shader_params($id,def_cl_range)] } then {
d1356 1
d1376 1
a1376 1
	if { $shader != $shader_params($id,shader_name) } { 
d1407 1
a1407 1
			set_fakestar_values $shade_str $id
@


1.9
log
@Added more help.
@
text
@d12 2
a13 2
#	4. add the new shader to the switch command in 'stack_add', if this shader is
#		appropriate for being in a stack
d544 1
a544 1
		if { [expr $shader_params($id,ri) != $shader_params($id,def_ri)] } then {
d763 2
a764 1
			color. Otherwise, the transparency color is ignored"}
d797 2
a798 1
			color. Otherwise, the transparency color is ignored"}
a905 4
		fakestar {
			set_fakestar_defaults "$id,stk_$index"
			set tmp_win [do_fakestar $shade_var $id,stk_$index]
		}
d920 8
d941 1
d944 12
d1023 2
d1046 248
d1338 6
d1402 8
d1452 6
d1472 2
@


1.8
log
@Added more processing on each keystroke.
@
text
@d122 8
d186 3
a188 1
			lappend params a $shader_params($id,ckr_a) } }
d191 3
a193 1
			lappend params b $shader_params($id,ckr_b) } }
d735 6
a740 2
			object. This file should be a 'pix' file for the 'texture' shader,\n\
			or a 'bw' file for 'bwtexture'."}
d756 2
a757 1
			triple. For the 'bwtexture' shader, a single value is sufficient"}
d766 33
d983 4
d1009 4
@


1.7
log
@Added shader parameter parsing with each keystroke.
@
text
@d109 1
a109 1
	bind $shader_params($id,window).fr.color1_e <Return> "do_shader_apply $shade_var $id"
d112 1
a112 1
	bind $shader_params($id,window).fr.color2_e <Return> "do_shader_apply $shade_var $id"
d204 1
a204 1
	bind $shader_params($id,window).fr.trans_e <Return> "do_shader_apply $shade_var $id"
d207 1
a207 1
	bind $shader_params($id,window).fr.refl_e <Return> "do_shader_apply $shade_var $id"
d210 1
a210 1
	bind $shader_params($id,window).fr.spec_e <Return> "do_shader_apply $shade_var $id"
d213 1
a213 1
	bind $shader_params($id,window).fr.diff_e <Return> "do_shader_apply $shade_var $id"
d216 1
a216 1
	bind $shader_params($id,window).fr.ri_e <Return> "do_shader_apply $shade_var $id"
d219 1
a219 1
	bind $shader_params($id,window).fr.shine_e <Return> "do_shader_apply $shade_var $id"
d222 1
a222 1
	bind $shader_params($id,window).fr.ext_e <Return> "do_shader_apply $shade_var $id"
d706 1
a706 1
	bind $shader_params($id,window).fr.file_e <Return> "do_shader_apply $shade_var $id"
d709 1
a709 1
	bind $shader_params($id,window).fr.width_e <Return> "do_shader_apply $shade_var $id"
d712 1
a712 1
	bind $shader_params($id,window).fr.height_e <Return> "do_shader_apply $shade_var $id"
d715 1
a715 1
	bind $shader_params($id,window).fr.trans_e <Return> "do_shader_apply $shade_var $id"
d717 3
a719 1
	checkbutton $shader_params($id,window).fr.valid_e -variable shader_params($id,trans_valid)
@


1.6
log
@More work on the stack shader gui.
@
text
@d15 2
a16 1
#	6. add the following routines:
d125 4
a128 4
	grid $shader_params($id,window).fr.color1 -row 0 -column 1
	grid $shader_params($id,window).fr.color1_e -row 0 -column 2
	grid $shader_params($id,window).fr.color2 -row 1 -column 1
	grid $shader_params($id,window).fr.color2_e -row 1 -column 2
d383 14
a396 14
	grid $shader_params($id,window).fr.trans -row 0 -column 0
	grid $shader_params($id,window).fr.trans_e -row 0 -column 1
	grid $shader_params($id,window).fr.refl -row 0 -column 2
	grid $shader_params($id,window).fr.refl_e -row 0 -column 3
	grid $shader_params($id,window).fr.spec -row 1 -column 0
	grid $shader_params($id,window).fr.spec_e -row 1 -column 1
	grid $shader_params($id,window).fr.diff -row 1 -column 2
	grid $shader_params($id,window).fr.diff_e -row 1 -column 3
	grid $shader_params($id,window).fr.ri -row 2 -column 1
	grid $shader_params($id,window).fr.ri_e -row 2 -column 2
	grid $shader_params($id,window).fr.shine -row 3 -column 1
	grid $shader_params($id,window).fr.shine_e -row 3 -column 2
	grid $shader_params($id,window).fr.ext -row 4 -column 1
	grid $shader_params($id,window).fr.ext_e -row 4 -column 2
a812 1
puts "destroying window ($index) $shader_params($id,stk_$index,window)"
d872 1
a872 1
	grid $shader_params($id,window).fr.stk_$index -columnspan 2
d878 3
a880 1
	set shade_length [llength $shade_str]
d882 1
d884 4
a887 1
	set no_of_shaders [llength $shader_list]
d892 23
a914 2
			stack_add $shader $shader_params($id,shade_var) $id
			set_${shader}_values $sub_str $id,stk_$index
d958 1
a958 1
	grid $shader_params($id,window).fr
d971 1
a971 5
	if { $err != 0 } {
		tk_messageBox -title "Shader String Error" -type ok -icon error \
			-message "Invalid shader string ($shade_str)"
		return
	}
d979 6
a984 2
		glass -
		mirror -
d988 6
a993 2
		bump -
		bwtexture -
d1007 1
a1007 1
			set_stack_values $shade_sr $id
d1023 2
a1066 6

			default {
				tk_messageBox -title "Shader Name Error" -type ok -icon error \
					 -message "Invalid shader name ($material)"
				set my_win ""
			}
d1109 16
@


1.5
log
@Started adding stack shader.
@
text
@d581 8
d596 8
d659 8
d772 11
d786 4
a789 4
	for {set index 0} {$index < $shader_params($id,stack_len)} {incr index} {
		if {$shader_params($id,stk_$index,shader_name) == "" } {continue}
		set shade_str $shader_params($id,stk_$index,shader_name)
		do_shader_apply $shade_var $id,stk_$index
@


1.4
log
@Added more shader guis.
@
text
@d12 4
a15 2
#	3. add a menu item for the new shader in 'init_comb' (comb.tcl)
#	4. add the following routines:
d41 1
a41 1
	hoc_register_data $shader_params($id,window).fr.tst_m "Fake Star" {
d182 1
a182 1
	set shader [list $shader_params($id,shader_name) $params ]
d402 12
d486 26
a511 1
proc do_phong_apply { shade_var id } {
a512 1
	upvar #0 $shade_var shader
d540 1
a540 1
	set shader [list $shader_params($id,shader_name) $params ]
d543 1
a543 1
proc set_phong_defaults { id } {
d546 8
a553 1
	switch $shader_params($id,shader_name) {
d555 2
a556 9
		plastic {
			set shader_params($id,def_shine) 10
			set shader_params($id,def_spec) 0.7
			set shader_params($id,def_diff) 0.3
			set shader_params($id,def_trans) 0
			set shader_params($id,def_refl) 0
			set shader_params($id,def_ri) 1.0
			set shader_params($id,def_ext) 0
		}
d558 8
a565 9
		mirror {
			set shader_params($id,def_shine) 4
			set shader_params($id,def_spec) 0.6
			set shader_params($id,def_diff) 0.4
			set shader_params($id,def_trans) 0
			set shader_params($id,def_refl) 0.75
			set shader_params($id,def_ri) 1.65
			set shader_params($id,def_ext) 0
		}
d567 2
a568 10
		glass {
			set shader_params($id,def_shine) 4
			set shader_params($id,def_spec) 0.7
			set shader_params($id,def_diff) 0.3
			set shader_params($id,def_trans) 0.8
			set shader_params($id,def_refl) 0.1
			set shader_params($id,def_ri) 1.65
			set shader_params($id,def_ext) 0
		}
	}
d570 7
d584 2
a585 8
	switch $shader_params($id,shader_name) {
		bump -
		bwtexture -
		texture {
			set shader_params($id,def_width) 512
			set shader_params($id,def_height) 512
		}
	}
d742 161
d940 3
d965 8
a972 2
			glass -
			mirror -
d974 1
a974 1
				set_phong_defaults $id
d995 4
d1015 1
d1020 6
a1025 2
		plastic -
		mirror -
d1027 1
a1027 1
			do_phong_apply $shade_var $id
d1043 3
@


1.3
log
@More work on the shaders.
@
text
@d4 2
a5 1
# shader_params is an array containing all the values for this shader
d8 91
a98 1
proc do_shader_apply { shade_var id } {
d101 44
a144 1
	set current_shader_type [lindex $shader_str 0]
d146 3
a148 1
	switch $current_shader_type {
d150 5
a154 5
		plastic -
		mirror -
		glass {
			do_phong_apply $shade_var $id
		}
d156 5
a160 3
		bwtexture -
		texture {
			do_texture_apply $shade_var $id
d165 25
a194 1
	set saved_str $shader_str
d201 1
d204 1
d207 1
d210 1
d213 1
d216 1
d219 1
d222 12
a233 10
		{summary "The observer can see diffuse and specular reflections from\n \
			an object as well as transmitted and/or reflected images.\n \
			The transparency is the fraction of light that will be\n \
			transmitted through the object. The mirror reflectance is\n \
			the fraction of light that will be reflected as a mirror image.\n \
			The fraction of light remaining after transmission and mirror\n \
			reflection is divided between diffuse and specular reflections\n \
			The diffuse and specular reflections are what the observer uses to\n \
			perceive the color and shape of an object."}
		{description "The fraction of light that will be\n \
d239 12
a250 1
		{description "Enter the fraction of light that\n \
d255 81
a335 2
	hoc_register_data $shader_params($id,window).fr.refl Reflectivity {
		{description "The fraction of light that will be reflected\n \
d340 13
a352 2
	hoc_register_data $shader_params($id,window).fr.refl_e Reflectivity {
		{description "Enter the fraction of light that will be reflected\n \
d357 19
a393 3
#	grid $shader_params($id,window).fr.apply -row 6 -column 0
#	grid $shader_params($id,window).fr.reset -row 6 -column 1 -columnspan 2
#	grid $shader_params($id,window).fr.dismiss -row 6 -column 3
d502 1
a502 9
	set shader [list $shader_params($id,default_choice) $params ]
}

proc do_phong_reset { shade_var id saved_str } {
	global shader_params
	upvar #0 $shade_var shader_str

	set shader_str $saved_str
	set_phong_values $saved_str $id
d508 1
a508 1
	switch $shader_params($id,default_choice) {
a542 28

proc do_plastic { shade_var id } {
	global shader_params

	set shader_params($id,default_choice) plastic
	set_phong_defaults $id
	set my_win [do_phong $shade_var $id]
	return $my_win
}

proc do_mirror { shade_var id } {
	global shader_params

	set shader_params($id,default_choice) mirror
	set_phong_defaults $id
	set my_win [do_phong $shade_var $id]
	return $my_win
}

proc do_glass { shade_var id } {
	global shader_params

	set shader_params($id,default_choice) glass
	set_phong_defaults $id
	set my_win [do_phong $shade_var $id]
	return $my_win
}

a544 8
proc do_texture_reset { shade_var id saved_str } {
	global shader_params
	upvar #0 $shade_var shader_str

	set shader_str $saved_str
	set_texture_values $saved_str $id
}

d548 2
a549 1
	switch $shader_params($id,default_choice) {
d564 1
a564 1
	set shader_params($id,trans_valid) ""
d639 1
a639 1
	set shader [list $shader_params($id,default_choice) $params ]
d642 1
a642 1
proc do_texture_main { shade_var id } {
a644 1
	set saved_str $shader_str
a645 4
#	set shader_params($id,window) .top_$id
#	catch {destroy $shader_params($id,window)}
#	toplevel $shader_params($id,window)
#	wm title $shader_params($id,window) "$shader_params($id,default_choice) Shader Parameters"
d651 1
d654 1
d657 1
d660 1
d664 27
a690 3
#	button $shader_params($id,window).fr.apply -text apply -command "do_texture_apply $shade_var $id"
#	button $shader_params($id,window).fr.reset -text reset -command "do_texture_reset $shade_var $id {$saved_str}"
#	button $shader_params($id,window).fr.dismiss -text dismiss -command "do_dismiss $id"
a705 3
#	grid $shader_params($id,window).fr.apply -row 3 -column 0
#	grid $shader_params($id,window).fr.reset -row 3 -column 1 -columnspan 2
#	grid $shader_params($id,window).fr.dismiss -row 3 -column 3
d712 2
a713 1
proc do_texture { shade_var id } {
d716 34
a749 4
	set shader_params($id,default_choice) texture
	set_texture_defaults $id
	set my_win [do_texture_main $shade_var $id]
	return $my_win
d756 1
a756 1
proc do_shader { shade_var id_name frame_name } {
d760 2
a761 2
	set shader_params($id_name,parent_window_id) $id_name
	set shader_params($id_name,window) $frame_name
d765 2
a766 1
		set my_win [do_plastic $shade_var $id_name]
d769 1
d771 7
a777 3
			glass { set my_win [do_glass $shade_var $id_name] }
			mirror { set my_win [do_mirror $shade_var $id_name] }
			plastic { set my_win [do_plastic $shade_var $id_name] }
d779 16
a794 1
			texture { set my_win [do_texture $shade_var $id_name] }
d797 2
a798 1
				tk_messageBox -title "Shader Name Error" -type ok -icon error -message "Invalid shader name ($material)"
d807 30
@


1.2
log
@Added 'id' to allow multiple invocations.
@
text
@d7 18
a24 4
# common routine to dismiss the gui
proc do_dismiss { id } {
	global shader_params
	destroy $shader_params($id,window)
a26 1

d34 1
a34 4
	set shader_params($id,window) .top_$id
	catch {destroy $shader_params($id,window)}
	toplevel $shader_params($id,window)
	wm title $shader_params($id,window) "$shader_params($id,default_choice) Shader Parameters"
d39 1
a39 1
	label $shader_params($id,window).fr.refl -text Reflectivity
d41 1
a41 1
	label $shader_params($id,window).fr.spec -text Specular
d43 1
a43 1
	label $shader_params($id,window).fr.diff -text Diffuse
d52 32
a83 3
	button $shader_params($id,window).fr.apply -text apply -command "do_phong_apply $shade_var $id"
	button $shader_params($id,window).fr.reset -text reset -command "do_phong_reset $shade_var $id {$saved_str}"
	button $shader_params($id,window).fr.dismiss -text dismiss -command "do_dismiss $id"
d103 3
a105 3
	grid $shader_params($id,window).fr.apply -row 6 -column 0
	grid $shader_params($id,window).fr.reset -row 6 -column 1 -columnspan 2
	grid $shader_params($id,window).fr.dismiss -row 6 -column 3
d107 1
a107 1
	pack $shader_params($id,window).fr
d109 1
a109 1
	return $shader_params($id,window)
d305 1
d402 5
a406 4
	set shader_params($id,window) .top_$id
	catch {destroy $shader_params($id,window)}
	toplevel $shader_params($id,window)
	wm title $shader_params($id,window) "$shader_params($id,default_choice) Shader Parameters"
d420 3
a422 3
	button $shader_params($id,window).fr.apply -text apply -command "do_texture_apply $shade_var $id"
	button $shader_params($id,window).fr.reset -text reset -command "do_texture_reset $shade_var $id {$saved_str}"
	button $shader_params($id,window).fr.dismiss -text dismiss -command "do_dismiss $id"
d438 3
a440 3
	grid $shader_params($id,window).fr.apply -row 3 -column 0
	grid $shader_params($id,window).fr.reset -row 3 -column 1 -columnspan 2
	grid $shader_params($id,window).fr.dismiss -row 3 -column 3
d442 1
a442 1
	pack $shader_params($id,window).fr
d444 1
a444 1
	return $shader_params($id,window)
d460 1
a460 1
proc do_shader { shade_var id_name } {
d465 1
d476 1
d488 1
@


1.1
log
@GUI for shader assignment in MGED
@
text
@d8 1
a8 1
proc do_dismiss {} {
d10 1
a10 1
	destroy $shader_params(window)
d16 1
a16 1
proc do_phong { shade_var } {
d21 24
a44 24
	set shader_params(window) .top
	catch {destroy $shader_params(window)}
	toplevel $shader_params(window)
	wm title $shader_params(window) "$shader_params(default_choice) Shader Parameters"
	frame $shader_params(window).fr

	label $shader_params(window).fr.trans -text Transparency
	entry $shader_params(window).fr.trans_e -width 5 -textvariable shader_params(trans)
	label $shader_params(window).fr.refl -text Reflectivity
	entry $shader_params(window).fr.refl_e -width 5 -textvariable shader_params(refl)
	label $shader_params(window).fr.spec -text Specular
	entry $shader_params(window).fr.spec_e -width 5 -textvariable shader_params(spec)
	label $shader_params(window).fr.diff -text Diffuse
	entry $shader_params(window).fr.diff_e -width 5 -textvariable shader_params(diff)
	label $shader_params(window).fr.ri -text "Refractive index"
	entry $shader_params(window).fr.ri_e -width 5 -textvariable shader_params(ri)
	label $shader_params(window).fr.shine -text Shininess
	entry $shader_params(window).fr.shine_e -width 5 -textvariable shader_params(shine)
	label $shader_params(window).fr.ext -text Extinction
	entry $shader_params(window).fr.ext_e -width 5 -textvariable shader_params(ext)

	button $shader_params(window).fr.apply -text apply -command "do_phong_apply $shade_var"
	button $shader_params(window).fr.reset -text reset -command "do_phong_reset $shade_var {$saved_str}"
	button $shader_params(window).fr.dismiss -text dismiss -command do_dismiss
d48 1
a48 1
	set_phong_values $shader_str
d50 17
a66 17
	grid $shader_params(window).fr.trans -row 0 -column 0
	grid $shader_params(window).fr.trans_e -row 0 -column 1
	grid $shader_params(window).fr.refl -row 0 -column 2
	grid $shader_params(window).fr.refl_e -row 0 -column 3
	grid $shader_params(window).fr.spec -row 1 -column 0
	grid $shader_params(window).fr.spec_e -row 1 -column 1
	grid $shader_params(window).fr.diff -row 1 -column 2
	grid $shader_params(window).fr.diff_e -row 1 -column 3
	grid $shader_params(window).fr.ri -row 2 -column 1
	grid $shader_params(window).fr.ri_e -row 2 -column 2
	grid $shader_params(window).fr.shine -row 3 -column 1
	grid $shader_params(window).fr.shine_e -row 3 -column 2
	grid $shader_params(window).fr.ext -row 4 -column 1
	grid $shader_params(window).fr.ext_e -row 4 -column 2
	grid $shader_params(window).fr.apply -row 6 -column 0
	grid $shader_params(window).fr.reset -row 6 -column 1 -columnspan 2
	grid $shader_params(window).fr.dismiss -row 6 -column 3
d68 1
a68 1
	pack $shader_params(window).fr
d70 1
a70 1
	return $shader_params(window)
d73 1
a73 1
proc set_phong_values { shader_str } {
d78 7
a84 7
	set shader_params(trans) ""
	set shader_params(refl) ""
	set shader_params(spec) ""
	set shader_params(diff) ""
	set shader_params(ri) ""
	set shader_params(shine) ""
	set shader_params(ext) ""
d100 2
a101 2
					if { $value != $shader_params(def_ri) } then {
						set shader_params(ri) $value }
d106 2
a107 2
					if { $value != $shader_params(def_shine) } then {
						set shader_params(shine) $value }
d112 2
a113 2
					if { $value != $shader_params(def_spec) } then {
						set shader_params(spec) $value }
d118 2
a119 2
					if { $value != $shader_params(def_diff) } then {
						set shader_params(diff) $value }
d124 2
a125 2
					if { $value != $shader_params(def_trans) } then {
						set shader_params(trans) $value }
d130 2
a131 2
					if { $value != $shader_params(def_refl) } then {
						set shader_params(refl) $value }
d137 2
a138 2
					if { $value != $shader_params(def_ext) } then {
						set shader_params(ext) $value }
d145 1
a145 1
proc do_phong_apply { shade_var } {
d153 21
a173 21
	if { [string length $shader_params(trans) ] > 0 } then {
		if { [expr $shader_params(trans) != $shader_params(def_trans)] } then {
			lappend params tr $shader_params(trans) } }
	if { [string length $shader_params(refl) ] > 0 } then {
		if { [expr $shader_params(refl) != $shader_params(def_refl)] } then {
			lappend params re $shader_params(refl) } }
	if { [string length $shader_params(spec) ] > 0 } then {
		if { [expr $shader_params(spec) != $shader_params(def_spec)] } then {
			lappend params sp $shader_params(spec) } }
	if { [string length $shader_params(diff) ] > 0 } then {
		if { [expr $shader_params(diff) != $shader_params(def_diff)] } then {
			lappend params di $shader_params(diff) } }
	if { [string length $shader_params(ri) ] > 0 } then {
		if { [expr $shader_params(ri) != $shader_params(def_ri)] } then {
			lappend params ri $shader_params(ri) } }
	if { [string length $shader_params(shine)] > 0 } then {
		if { [expr $shader_params(shine) != $shader_params(def_shine)] } then {
			lappend params sh $shader_params(shine) } }
	if { [string length $shader_params(ext)] > 0 } then {
		if { [expr $shader_params(ext) != $shader_params(def_ext)] } then {
			lappend params ex $shader_params(ext) } }
d175 1
a175 1
	set shader [list $shader_params(default_choice) $params ]
d178 1
a178 1
proc do_phong_reset { shade_var saved_str } {
d183 1
a183 1
	set_phong_values $saved_str
d186 1
a186 1
proc set_phong_defaults {} {
d189 1
a189 1
	switch $shader_params(default_choice) {
d192 7
a198 7
			set shader_params(def_shine) 10
			set shader_params(def_spec) 0.7
			set shader_params(def_diff) 0.3
			set shader_params(def_trans) 0
			set shader_params(def_refl) 0
			set shader_params(def_ri) 1.0
			set shader_params(def_ext) 0
d202 7
a208 7
			set shader_params(def_shine) 4
			set shader_params(def_spec) 0.6
			set shader_params(def_diff) 0.4
			set shader_params(def_trans) 0
			set shader_params(def_refl) 0.75
			set shader_params(def_ri) 1.65
			set shader_params(def_ext) 0
d212 7
a218 7
			set shader_params(def_shine) 4
			set shader_params(def_spec) 0.7
			set shader_params(def_diff) 0.3
			set shader_params(def_trans) 0.8
			set shader_params(def_refl) 0.1
			set shader_params(def_ri) 1.65
			set shader_params(def_ext) 0
d225 1
a225 1
proc do_plastic { shade_var } {
d228 3
a230 3
	set shader_params(default_choice) plastic
	set_phong_defaults
	set my_win [do_phong $shade_var]
d234 1
a234 1
proc do_mirror { shade_var } {
d237 3
a239 3
	set shader_params(default_choice) mirror
	set_phong_defaults
	set my_win [do_phong $shade_var]
d243 1
a243 1
proc do_glass { shade_var } {
d246 3
a248 3
	set shader_params(default_choice) glass
	set_phong_defaults
	set my_win [do_phong $shade_var]
d254 1
a254 1
proc do_texture_reset { shade_var saved_str } {
d259 1
a259 1
	set_texture_values $saved_str
d262 1
a262 1
proc set_texture_defaults {} {
d265 1
a265 1
	switch $shader_params(default_choice) {
d267 2
a268 2
			set shader_params(def_width) 512
			set shader_params(def_height) 512
d273 1
a273 1
proc set_texture_values { shader_str } {
d278 5
a282 5
	set shader_params(transp) ""
	set shader_params(trans_valid) ""
	set shader_params(file) ""
	set shader_params(width) ""
	set shader_params(height) ""
d298 2
a299 2
					if { $value != $shader_params(def_width) } then {
						set shader_params(width) $value }
d304 2
a305 2
					if { $value != $shader_params(def_height) } then {
						set shader_params(height) $value }
d309 1
a309 1
						set shader_params(transp) $value
d314 1
a314 1
							set shader_params(trans_valid) 1
d316 1
a316 1
							set shader_params(trans_valid) 0
d321 1
a321 1
						set shader_params(file) $value
d328 1
a328 1
proc do_texture_apply { shade_var } {
d336 12
a347 12
	if { [string length $shader_params(file) ] > 0 } then {
			lappend params file $shader_params(file) }
	if { [string length $shader_params(width) ] > 0 } then {
		if { [expr $shader_params(width) != $shader_params(def_width)] } then {
			lappend params w $shader_params(width) } }
	if { [string length $shader_params(height) ] > 0 } then {
		if { [expr $shader_params(height) != $shader_params(def_height)] } then {
			lappend params n $shader_params(height) } }
	if { [string length $shader_params(transp) ] > 0 } then {
			lappend params transp $shader_params(transp) }
	if { $shader_params(trans_valid) != 0 } then {
			if { [string length $shader_params(transp) ] == 0 } then {
d349 1
a349 1
				set shader_params(trans_valid) 0
d354 1
a354 1
	set shader [list $shader_params(default_choice) $params ]
d357 1
a357 1
proc do_texture_main { shade_var } {
d362 20
a381 20
	set shader_params(window) .top
	catch {destroy $shader_params(window)}
	toplevel $shader_params(window)
	wm title $shader_params(window) "$shader_params(default_choice) Shader Parameters"
	frame $shader_params(window).fr

	label $shader_params(window).fr.file -text "Texture File Name"
	entry $shader_params(window).fr.file_e -width 40 -textvariable shader_params(file)
	label $shader_params(window).fr.width -text "File Width (pixels)"
	entry $shader_params(window).fr.width_e -width 5 -textvariable shader_params(width)
	label $shader_params(window).fr.height -text "File height (pixels)"
	entry $shader_params(window).fr.height_e -width 5 -textvariable shader_params(height)
	label $shader_params(window).fr.trans -text "Transparency (RGB)"
	entry $shader_params(window).fr.trans_e -width 15 -textvariable shader_params(transp)
	label $shader_params(window).fr.valid -text "Use transparency"
	checkbutton $shader_params(window).fr.valid_e -variable shader_params(trans_valid)

	button $shader_params(window).fr.apply -text apply -command "do_texture_apply $shade_var"
	button $shader_params(window).fr.reset -text reset -command "do_texture_reset $shade_var {$saved_str}"
	button $shader_params(window).fr.dismiss -text dismiss -command do_dismiss
d385 1
a385 1
	set_texture_values $shader_str
d387 13
a399 13
	grid $shader_params(window).fr.file -row 0 -column 0 -sticky e
	grid $shader_params(window).fr.file_e -row 0 -column 1 -columnspan 3 -sticky w
	grid $shader_params(window).fr.width -row 1 -column 0 -sticky e
	grid $shader_params(window).fr.width_e -row 1 -column 1 -sticky w
	grid $shader_params(window).fr.height -row 1 -column 2 -sticky e
	grid $shader_params(window).fr.height_e -row 1 -column 3 -sticky w
	grid $shader_params(window).fr.trans -row 2 -column 0 -sticky e
	grid $shader_params(window).fr.trans_e -row 2 -column 1 -sticky w
	grid $shader_params(window).fr.valid_e -row 2 -column 2 -sticky e
	grid $shader_params(window).fr.valid -row 2 -column 3 -sticky w
	grid $shader_params(window).fr.apply -row 3 -column 0
	grid $shader_params(window).fr.reset -row 3 -column 1 -columnspan 2
	grid $shader_params(window).fr.dismiss -row 3 -column 3
d401 1
a401 1
	pack $shader_params(window).fr
d403 1
a403 1
	return $shader_params(window)
d406 1
a406 1
proc do_texture { shade_var } {
d409 3
a411 3
	set shader_params(default_choice) texture
	set_texture_defaults
	set my_win [do_texture_main $shade_var]
d419 2
a420 1
proc do_shader { shade_var } {
d423 2
d427 1
a427 1
		set my_win [do_plastic $shade_var]
d431 4
a434 4
			glass { set my_win [do_glass $shade_var] }
			mirror { set my_win [do_mirror $shade_var] }
			plastic { set my_win [do_plastic $shade_var] }
			texture { set my_win [do_texture $shade_var] }
@
