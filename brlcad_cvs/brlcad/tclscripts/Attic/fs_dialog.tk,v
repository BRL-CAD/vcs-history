head	1.4;
access;
symbols
	ansi-20040405-merged:1.3
	postmerge-20040405-ansi:1.3
	premerge-20040404-ansi:1.3
	postmerge-autoconf:1.3
	autoconf-freeze:1.3
	premerge-autoconf:1.3
	postmerge-20040315-windows:1.3
	premerge-20040315-windows:1.3
	windows-20040315-freeze:1.3
	autoconf-20031203:1.3
	autoconf-20031202:1.3
	autoconf-branch:1.3.0.14
	phong-branch:1.3.0.12
	photonmap-branch:1.3.0.10
	rel-6-1-DP:1.3
	windows-branch:1.3.0.8
	rel-6-0-2:1.3
	ansi-branch:1.3.0.6
	rel-6-0-1-branch:1.3.0.4
	hartley-6-0-post:1.3
	hartley-6-0-pre:1.3
	rel-6-0-1:1.3
	rel-6-0:1.3
	rel-5-4:1.3
	offsite-5-3-pre:1.3
	rel-5-3:1.3
	rel-5-2:1.3
	rel-5-1-branch:1.3.0.2
	rel-5-1:1.3
	rel-5-0:1.3
	rel-5-0-beta:1.3
	rel-4-5:1.3
	ctj-4-5-post:1.3
	ctj-4-5-pre:1.3;
locks; strict;
comment	@# @;


1.4
date	2004.05.21.16.41.18;	author morrison;	state dead;
branches;
next	1.3;

1.3
date	96.12.19.18.23.33;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	96.12.18.22.11.33;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	96.12.18.20.09.25;	author butler;	state Exp;
branches;
next	;


desc
@A file selection dialog box
@


1.4
log
@moved to src/tclscripts/
@
text
@#
#  F S _ D I A L O G
#
#  Author	Lee A. Butler	<butler@@arl.mil>
#
#  A file selection dialog, which is not unlike the one present in netscape.
#  Uses straight Tcl/Tk with no extensions, and no bitmaps
#
#  Parameter	Meaning
#  ------------------------------------------------------------
#  w		The name of the widget to use for the toplevel dialog window
#  parent	The parent window (for positioning/screen information)
#  pattern	A file matching pattern that specifies the directory and
#			file(s) to look for
#  Return:
#	string:	"" if cancel selected, full filename selected otherwise
#
#  Example Usage:
#	set filename [fs_dialog .w . /usr/*/bin/*]
#
#  To try the dialog:
#	$ wish
#	% source fs_dialog.tk
#	% fs_dialog_test
#
proc fs_dialog {w parent pattern} {
    global fs_glob

    set parent_toplevel [winfo toplevel $parent]

    # if $w already exists we need to get rid of it.
    catch {destroy $w}

    toplevel $w -class FSDialog -screen [winfo screen $parent_toplevel]
    wm withdraw $w

    fs_dialog_resources

    wm title $w FileDialog
    wm iconname $w FileDialog

    
    # The following command means that the dialog won't be posted if
    # [winfo parent $w] is iconified, but it's really needed;  otherwise
    # the dialog can become obscured by other windows in the application,
    # even though its grab keeps the rest of the application from being 
    # used.
    wm transient $w $parent_toplevel

    set fs_glob(win) $w

    #
    # The filter entry panel
    #
    frame $w.filter
	frame $w.filter.hdr
	    label $w.filter.hdr.lbl -relief flat -bd 0
	    pack  $w.filter.hdr.lbl -side left -anchor w

	    label $w.filter.hdr.file -textvariable fs_glob(pat_file)
	    pack  $w.filter.hdr.file -side right -anchor e

	    label $w.filter.hdr.dir -textvariable fs_glob(pat_dir)
	    pack  $w.filter.hdr.dir -side right -anchor e
	pack  $w.filter.hdr -side top -anchor w -expand 1 -fill x

	entry $w.filter.ent -textvariable fs_glob(filter)
	pack  $w.filter.ent -side top -anchor w -expand 1 -fill x

    pack $w.filter -side top -expand 1 -fill x -padx 5 -pady 5

    #
    #  The file/directory panel
    #
    frame $w.m
	#
	# File panel
	frame $w.m.files -relief ridge -bd 1
	    label $w.m.files.lbl
	    pack  $w.m.files.lbl -side top -anchor w
	    scrollbar $w.m.files.sb -command "$w.m.files.lb yview"
	    pack $w.m.files.sb -side right -fill y
	    set fs_glob(listbox_file) [listbox $w.m.files.lb -yscrollcommand "$w.m.files.sb set" -selectmode single]
	    pack $w.m.files.lb -side right
	pack  $w.m.files -side right -anchor e

	#
	# Directory panel
	frame $w.m.dirs -relief ridge -bd 1
	    label $w.m.dirs.lbl -relief flat
	    pack  $w.m.dirs.lbl -side top -anchor w
	    scrollbar $w.m.dirs.sb -command "$w.m.dirs.lb yview"
	    pack $w.m.dirs.sb -side right -fill y
	    set fs_glob(listbox_dir) [listbox $w.m.dirs.lb -yscrollcommand "$w.m.dirs.sb set" -selectmode single]
	    pack $w.m.dirs.lb -side right
	pack  $w.m.dirs -side left -anchor w
    pack $w.m -side top -expand 1 -fill x -padx 5

    #
    # Selection Panel
    #
    frame $w.sel
	label $w.sel.lbl
	pack  $w.sel.lbl -side top -anchor w
	entry $w.sel.ent -textvariable fs_glob(selection)
	pack  $w.sel.ent -side top -anchor w -expand 1 -fill x
    pack $w.sel -side top -expand 1 -fill x -padx 5

    #
    # Button Panel
    #
    frame $w.btns -bd 1 -relief ridge
	button $w.btns.ok -command {set fs_glob(button) 1}
	pack $w.btns.ok -side left -expand 1 -pady 8
	button $w.btns.filter -command \
		{fs_dialog_filterstring $fs_glob(filter)}
	pack $w.btns.filter -side left -expand 1
	button $w.btns.cancel -command {set fs_glob(button) 0}
	pack $w.btns.cancel -side left -expand 1
    pack  $w.btns -side bottom -expand 1 -fill x -padx 5 -pady 5
    
    update idletasks

    scan [wm geometry $parent_toplevel] "%dx%d+%d+%d" p_w p_h p_x p_y

    # put the window in the middle of the parent, but not off the screen
    set m_w [winfo reqwidth $w]
    set m_h [winfo reqheight $w]

    set m_x [expr $p_x + $p_w / 2 - $m_w/2]
    if { $m_x < 0 } { set m_x 0 }

    set m_y [expr $p_y + $p_h / 2 - $m_h/2]
    if { $m_y < 0 } { set m_y 0 }

    wm geom $w +$m_x+$m_y

    # Don't allow resize
    wm minsize $w $m_w $m_h
    wm maxsize $w $m_w $m_h
    wm deiconify $w

    fs_dialog_filterstring $pattern
    fs_dialog_bindings

    grab set $w

    tkwait variable fs_glob(button)
    destroy $w
    if { $fs_glob(button) } {
	set ret_status $fs_glob(selection)
    } else {
	set ret_status ""
    }

    # Clean up our garbage
    unset fs_glob(selection) fs_glob(filter) \
    	fs_glob(pat_file) fs_glob(pat_dir) \
    	fs_glob(listbox_dir) fs_glob(listbox_file) \
    	fs_glob(win) fs_glob(button)

    return $ret_status
}


#########################################################
#							#
#	Support routines for fs_dialog			#
#							#
#########################################################


#
#
#  Set the resource for the dialog strings
#
proc fs_dialog_resources {} {
    option add *FSDialog*filter.hdr.lbl.text	Filter		startup
    option add *FSDialog*files.lbl.text		Files		startup
    option add *FSDialog*dirs.lbl.text		Directories	startup
    option add *FSDialog*sel.lbl.text		Selection	startup
    option add *FSDialog*btns.ok.text		OK		startup
    option add *FSDialog*btns.filter.text	Filter		startup
    option add *FSDialog*btns.cancel.text	Cancel		startup
}

#
#  fs_dialog_rescan
#
#  Fill in the "Directories" and "Files" listboxes to reflect a new
#  filter pattern.  If the directory is unique, then set the selection
#  string to the directory path
#
proc fs_dialog_rescan {} {
    global fs_glob

    set cursor [$fs_glob(win) cget -cursor]
    $fs_glob(win) config -cursor watch
    update idletasks

    set dirpat(1) $fs_glob(pat_dir).?*
    set dirpat(2) $fs_glob(pat_dir)*
    set filepat $fs_glob(pat_dir)$fs_glob(pat_file)

    $fs_glob(listbox_dir) delete 0 end
    $fs_glob(listbox_file) delete 0 end


    # Put the directory part in the selection box if
    # only 1 directory matches pat_dir
    set dir [glob -nocomplain $fs_glob(pat_dir)]
    if { [llength $dir] == 1 } {
	set fs_glob(selection) $dir
	set fs_glob(fully_qualified) 0

	# Fill in the directory listbox
	foreach i [lsort [glob -nocomplain $dirpat(1) $dirpat(2) ]] {
	    if { [file isdirectory $i]} {
		$fs_glob(listbox_dir) insert end [file tail $i]
	    }
	}

	# Fill in the file listbox
	foreach i [lsort [glob -nocomplain $filepat]] {
	    if { ! [file isdirectory $i] } {
		$fs_glob(listbox_file) insert end [file tail $i]
	    }
	}

    } else {
    	set fs_glob(selection) ""
	set fs_glob(fully_qualified) 1

	# Fill in the directory listbox
	foreach i [lsort [glob -nocomplain $dirpat(1) $dirpat(2) ]] {
	    if { [file isdirectory $i]} {
		$fs_glob(listbox_dir) insert end $i
	    }
	}

	# Fill in the file listbox
	foreach i [lsort [glob -nocomplain $filepat]] {
	    if { ! [file isdirectory $i] } {
		$fs_glob(listbox_file) insert end $i
	    }
	}

    }
    $fs_glob(win) config -cursor $cursor
}


#
# Called to set a (new) filterstring, and update the directory/file listboxes
#
proc fs_dialog_filterstring {pattern} {
    global fs_glob

    if {[regexp {/$} $pattern]} {
	# pattern ends in /, so assume directory and file of *
	set fs_glob(pat_dir) $pattern
	set fs_glob(pat_file) {*}
    } else {
	set fs_glob(pat_file) [file tail $pattern]

	# get a directory name that ends in "/"
	regsub {[^/]$} [file dirname $pattern] &/ fs_glob(pat_dir) 
    }

    set fs_glob(filter) "$fs_glob(pat_dir)$fs_glob(pat_file)"

    fs_dialog_rescan
}

#
#  fs_dialog_click_file
#
#  Event routine for mouse events in the "File" listbox that aren't handled
#  by the listbox widget.
#
proc fs_dialog_click_file {} {
    global fs_glob

    # update the selection
    if { $fs_glob(fully_qualified) == 0} {
	set fs_glob(selection) $fs_glob(pat_dir)[selection get]
    } else {
	set fs_glob(selection) [selection get]
    }
}

#
#  fs_dialog_click_dir
#
#  Event routine for mouse events in the "Directories" listbox that aren't 
#  handled by the listbox widget.
#
#  get the selection, build a new pattern, and call fs_dialog_filterstring
#
proc fs_dialog_click_dir {y} {
	global fs_glob

	set newdir [$fs_glob(listbox_dir) get [$fs_glob(listbox_dir) nearest $y]]

	if { $fs_glob(fully_qualified) == 1} {
		# Fully qualified path stored in directory widget
		# Just replace the pattern with the selection

		set fs_glob(pat_dir) $newdir/
		set fs_glob(filter) $newdir/$fs_glob(pat_file)
		fs_dialog_rescan
		return
	}

	# if we've selected ".." do relative/absolute raise
	# else just add selection to the end of the directory pattern

	if {[regexp {^/} $fs_glob(pat_dir)]} {
		# Absolute Path (Begins with "/")
		if {$newdir == ".."} {
			# Delete last directory from path
			regsub {[^/]+/$} $fs_glob(pat_dir) {} fs_glob(pat_dir)
		} else {
			# Add new directory to path
			set fs_glob(pat_dir) $fs_glob(pat_dir)$newdir/
		}
	} else {
		# Relative Path (Begins with "./" or "../"

		set pat_minus_one [file dirname $fs_glob(pat_dir)]/
		set pat_plus_one $fs_glob(pat_dir)$newdir/
		file stat $pat_minus_one pmo
		file stat $pat_plus_one ppo

		if { $pmo(ino) == $ppo(ino) } {
			# raising up path we descended or
			# descending path we raised through
			set fs_glob(pat_dir) $pat_minus_one
		} else {
			# Raising up higher
			set fs_glob(pat_dir) $fs_glob(pat_dir)$newdir/
		}
	}
	
	set fs_glob(filter) $fs_glob(pat_dir)$fs_glob(pat_file)

	fs_dialog_rescan
}

#
#  fs_dialog_bindings
#
#  set bindings for widgets
#
proc fs_dialog_bindings {} {
	global fs_glob

	bind $fs_glob(win).filter.ent <KeyPress-Return> \
		{fs_dialog_filterstring $fs_glob(filter)}
	bind $fs_glob(listbox_file) <Double-Button-1> {fs_dialog_click_file}
	bind $fs_glob(listbox_dir) <Double-Button-1> {fs_dialog_click_dir %y}
}

#
#  fs_dialog_test
#
#  Short little application that uses fs_dialog
#
proc fs_dialog_test {} {
	global pattern
	frame .main
	label .main.lbl -text Pattern
	pack .main.lbl -side left

	set pattern [exec pwd]/*
	entry .main.ent -textvariable pattern
	pack .main.ent -side left -expand 1 -fill x

	button .main.browse -text "Browse" -command {doit}
	pack .main.browse -side left

	button .main.exit -text "Exit" -command exit
	pack .main.exit -side left

	pack .main -expand 1 -fill x -side top

	proc doit {} {
		global pattern

		.msg delete 1.0 end
		set new_file [fs_dialog .w .main $pattern]
		if { $new_file == "" } {
			.msg insert end "User Cancelled"
		} else {
			.msg insert end "User file: $new_file"
		}
	}

	bind .main.ent <KeyPress-Return> {doit}

	text .msg -width 40 -height 2
	pack .msg -side bottom -expand 1 -fill x
}
@


1.3
log
@fixed error in processing relative directory changes
@
text
@@


1.2
log
@New version that returns a string rather than taking a parameter variable
name.  Also includes fixes for when directory specification is ambiguous.
@
text
@d57 1
a57 1
	    label $w.filter.hdr.lbl
d60 1
a60 2
	    label $w.filter.hdr.file -textvariable fs_glob(pat_file) \
	    	-bd 1 -relief raised
d62 2
a63 2
	    label $w.filter.hdr.dir -textvariable fs_glob(pat_dir) \
	    	-bd 1 -relief raised
d197 12
d217 1
a217 4
	set pat(1) $fs_glob(pat_dir).?*
	set pat(2) $fs_glob(pat_dir)*
	$fs_glob(listbox_dir) delete 0 end
	foreach i [lsort [glob -nocomplain $pat(1) $pat(2) ]] {
d224 2
a225 4
	set pat(1) 
	$fs_glob(listbox_file) delete 0 end
	foreach i [lsort [glob -nocomplain $fs_glob(pat_dir)$fs_glob(pat_file)]] {
 	    if { ! [file isdirectory $i]} {
d235 1
a235 4
	set pat(1) $fs_glob(pat_dir).?*
	set pat(2) $fs_glob(pat_dir)*
	$fs_glob(listbox_dir) delete 0 end
	foreach i [lsort [glob -nocomplain $pat(1) $pat(2) ]] {
d242 2
a243 4
	set pat(1) 
	$fs_glob(listbox_file) delete 0 end
	foreach i [lsort [glob -nocomplain $fs_glob(pat_dir)$fs_glob(pat_file)]] {
 	    if { ! [file isdirectory $i]} {
d249 1
a249 3



d306 3
a308 1
		#
a316 1
	
d319 1
a319 1
		# Absolute Path
d328 13
a340 3
		# Relative Path
		if {$newdir == ".."} {
			# Add new directory to path
a341 22
		} else {
			# if the directory selected is the name of 
			# the last part of the pat_dir then delete the last
			# directory from pat_dir
			# else add new_dir to pat_dir
			#
			# How I wish I could just ask if dir1 == dir2

			set pat_minus_one [file dirname $fs_glob(pat_dir)]/
			set pat_plus_one $fs_glob(pat_dir)$newdir/
			file stat $pat_minus_one pmo
			file stat $pat_plus_one ppo

			if { $pmo(ino) == $ppo(ino) } {
				# Re-descending path we went up
				# delete last directroy from pat_dir
				set fs_glob(pat_dir) $pat_minus_one
			} else {
				# Descending new leg of tree
				# Add new directory to path
				set fs_glob(pat_dir) $fs_glob(pat_dir)$newdir/
			}
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
#  Uses straight Tcl/Tk with no extensions
d11 2
a12 2
#  w		The name of the widget to use for the toplevel window
#  parent	The parent window (for positioning information)
a14 4
#  caller_filename
#		The name of a variable in the caller's frame to get the
#			filename.  This is only set if the user confirms
#			the selection
d16 1
a16 1
#	boolean: (1) string was set (0) User cancelled dialog
d19 1
a20 6
#	if { [fs_dialog .w .main $pattern "new_file" ] } {
#		puts "User Selected File: $new_file"
#	} else {
#		puts "User Cancelled File selection"
#	}	
#
d26 1
a26 1
proc fs_dialog {w parent pattern caller_filename} {
d28 2
a29 1
    upvar $caller_filename filename
d34 1
a34 1
    toplevel $w -class FSDialog
d37 1
a37 1
    fs_dialog_res
d48 1
a49 1
    wm transient $w [winfo toplevel [winfo parent $w]]
d125 1
a125 1
    scan [wm geometry [winfo toplevel $parent]] "%dx%d+%d+%d" p_w p_h p_x p_y
a150 1
    set ret_status $fs_glob(button)
d152 3
a154 1
	set filename $fs_glob(selection)
d178 1
a178 1
proc fs_dialog_res {} {
d198 13
a210 6
    # Fill in the directory listbox
    set pat(1) $fs_glob(pat_dir).?*
    set pat(2) $fs_glob(pat_dir)*
    $fs_glob(listbox_dir) delete 0 end
    foreach i [lsort [glob -nocomplain $pat(1) $pat(2) ]] {
	if { [file isdirectory $i]} {
d212 1
a213 1
    }
d215 5
a219 5
    # Fill in the file listbox
    set pat(1) 
    $fs_glob(listbox_file) delete 0 end
    foreach i [lsort [glob -nocomplain $fs_glob(pat_dir)$fs_glob(pat_file)]] {
 	if { ! [file isdirectory $i]} {
d221 1
a222 1
    }
a223 4
    # Put the directory part in the selection box if
    # only 1 directory matches pat_dir
    if { [llength [glob -nocomplain $fs_glob(pat_dir)]] == 1 } {
	set fs_glob(selection) $fs_glob(pat_dir)
d226 21
d248 3
d283 1
a283 1
	global fs_glob
d285 2
a286 1
	# update the selection
d288 3
d304 9
a316 1
	set newdir [$fs_glob(listbox_dir) get [$fs_glob(listbox_dir) nearest $y]]
d403 4
a406 1
		if { [fs_dialog .w .main $pattern "new_file" ] } {
d408 1
a408 3
		} else {
			.msg insert end "User Cancelled"
		}	
a411 1

@
