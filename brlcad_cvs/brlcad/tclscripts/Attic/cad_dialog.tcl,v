head	1.13;
access;
symbols
	ansi-20040405-merged:1.9.4.1
	postmerge-20040405-ansi:1.12
	premerge-20040404-ansi:1.12
	postmerge-autoconf:1.12
	autoconf-freeze:1.11.4.1
	premerge-autoconf:1.12
	postmerge-20040315-windows:1.12
	premerge-20040315-windows:1.12
	windows-20040315-freeze:1.9.6.2
	autoconf-20031203:1.11
	autoconf-20031202:1.11
	autoconf-branch:1.11.0.4
	phong-branch:1.11.0.2
	photonmap-branch:1.10.0.2
	rel-6-1-DP:1.9
	windows-branch:1.9.0.6
	rel-6-0-2:1.9
	ansi-branch:1.9.0.4
	rel-6-0-1-branch:1.9.0.2
	hartley-6-0-post:1.9
	hartley-6-0-pre:1.9
	rel-6-0-1:1.9
	rel-6-0:1.9
	rel-5-4:1.7.2.2
	offsite-5-3-pre:1.9
	rel-5-3:1.7.2.2
	rel-5-2:1.7
	rel-5-1-branch:1.7.0.2
	rel-5-1:1.7
	rel-5-0:1.5
	rel-5-0-beta:1.5;
locks; strict;
comment	@# @;


1.13
date	2004.05.21.16.41.17;	author morrison;	state dead;
branches;
next	1.12;

1.12
date	2004.02.02.17.39.42;	author morrison;	state Exp;
branches;
next	1.11;

1.11
date	2003.08.06.12.28.06;	author jra;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2003.03.13.19.45.26;	author jra;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2000.12.22.00.44.35;	author bparker;	state Exp;
branches
	1.9.4.1
	1.9.6.1;
next	1.8;

1.8
date	2000.11.17.15.41.13;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	99.10.19.20.25.30;	author jra;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	99.10.14.16.16.35;	author bparker;	state Exp;
branches;
next	1.5;

1.5
date	99.05.06.17.43.09;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	99.04.30.20.43.35;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	99.04.27.15.30.18;	author bparker;	state Exp;
branches;
next	1.2;

1.2
date	98.11.24.21.51.48;	author bparker;	state Exp;
branches;
next	1.1;

1.1
date	98.06.09.17.49.08;	author bparker;	state Exp;
branches;
next	;

1.7.2.1
date	2000.11.17.15.31.27;	author bparker;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2000.12.22.00.41.51;	author bparker;	state Exp;
branches;
next	;

1.9.4.1
date	2004.03.17.21.23.04;	author morrison;	state Exp;
branches;
next	;

1.9.6.1
date	2002.09.26.23.04.16;	author morrison;	state Exp;
branches;
next	1.9.6.2;

1.9.6.2
date	2004.03.11.23.48.41;	author morrison;	state Exp;
branches;
next	;

1.10.2.1
date	2003.08.26.14.04.41;	author justin;	state Exp;
branches;
next	;

1.11.4.1
date	2004.02.12.18.34.47;	author erikg;	state Exp;
branches;
next	;


desc
@@


1.13
log
@moved to src/tclscripts/
@
text
@#			C A D . T C L
#
# Author -
#	Glenn Durfee
#
# Source -
#	The U. S. Army Ballistic Research Laboratory
#	Aberdeen Proving Ground, Maryland  21005
#  
# Distribution Notice -
#	Re-distribution of this software is restricted, as described in
#	your "Statement of Terms and Conditions for the Release of
#	The BRL-CAD Package" agreement.
#
# Copyright Notice -
#	This software is Copyright (C) 1995-2004 by the United States Army
#	in all countries except the USA.  All rights reserved.
#
# Description -
#	"cad_dialog" and "cad_input_dialog" are based off of the
#	"tk_dialog" that comes with Tk 4.0.
#
# Modifications -
#        (Bob Parker):
#		*- mods to pop up the dialog box near the pointer.
#		*- mods to cad_dialog (i.e. use text widget with
#		   scrollbar if string length becomes too large).
#		*- add ::tk::Priv(wait_cmd) and use in all dialogs
#	 (John Anderson):
#		*- added cad_radio proc
#
#==============================================================================

if {![info exists ::tk::Priv(wait_cmd)]} {
    set ::tk::Priv(wait_cmd) tkwait
}

# cad_dialog --
#
# Much like tk_dialog, but doesn't perform a grab.
# Makes a dialog window with the given title, text, bitmap, and buttons.
#
proc cad_dialog { w screen title text bitmap default args } {
    global button$w
    global ::tk::Priv

    if [winfo exists $w] {
	catch {destroy $w}
    }

    # The screen parameter can be the pathname of some
    # widget where the screen value can be obtained.
    # Otherwise, it is assumed to be a genuine X DISPLAY
    # string.
    if [winfo exists $screen] {
	set screen [winfo screen $screen]
    }

    toplevel $w -screen $screen
    wm title $w $title
    wm iconname $w Dialog
    frame $w.top -relief raised -bd 1
    pack $w.top -side top -expand yes -fill both
    frame $w.bot -relief raised -bd 1
    pack $w.bot -side bottom -fill both

    # Use a text widget with scrollbar if string is too large
    if {[string length $text] > 1000} {
	frame $w.top.msgF
	text $w.top.msgT -yscrollcommand "$w.top.msgS set"
	$w.top.msgT insert 1.0 $text
	$w.top.msgT configure -state disabled
	scrollbar $w.top.msgS -command "$w.top.msgT yview"
	grid $w.top.msgT $w.top.msgS -sticky nsew -in $w.top.msgF
	grid columnconfigure $w.top.msgF 0 -weight 1
	grid rowconfigure $w.top.msgF 0 -weight 1

	# since pack is being used elsewhere,
	# we'll begin using it now.
	pack $w.top.msgF -side right -expand yes -fill both -padx 2m -pady 2m
    } else {
	message $w.top.msg -text $text -width 12i
	pack $w.top.msg -side right -expand yes -fill both -padx 2m -pady 2m
    }

    if { $bitmap != "" } {
	label $w.top.bitmap -bitmap $bitmap
	pack $w.top.bitmap -side left -padx 2m -pady 2m
    }

    set i 0
    foreach but $args {
	button $w.bot.button$i -text $but -command "set button$w $i"
	if { $i == $default } {
	    frame $w.bot.default -relief sunken -bd 1
	    raise $w.bot.button$i
	    pack $w.bot.default -side left -expand yes -padx 2m -pady 1m
	    pack $w.bot.button$i -in $w.bot.default -side left -padx 1m \
		    -pady 1m -ipadx 1m -ipady 1
	} else {
	    pack $w.bot.button$i -side left -expand yes \
		    -padx 2m -pady 2m -ipadx 1m -ipady 1
	}
	incr i
    }

    if { $default >= 0 } {
	bind $w <Return> "$w.bot.button$default flash ; set button$w $default"
    }

    place_near_mouse $w

    $::tk::Priv(wait_cmd) variable button$w
    catch { destroy $w }
    return [set button$w]
}

# cad_input_dialog --
#
#   Creates a dialog with the given title, text, and buttons, along with an
#   entry box (with possible default value) whose contents are to be returned
#   in the variable name contained in entryvar.
#
proc cad_input_dialog { w screen title text entryvar defaultentry default entry_hoc_data args } {
    global hoc_data
    global button$w entry$w
    global ::tk::Priv
    upvar $entryvar entrylocal

    set entry$w $defaultentry
    
    # The screen parameter can be the pathname of some
    # widget where the screen value can be obtained.
    # Otherwise, it is assumed to be a genuine X DISPLAY
    # string.
    if [winfo exists $screen] {
	set screen [winfo screen $screen]
    }

    toplevel $w -screen $screen
    wm title $w $title
    wm iconname $w Dialog
    frame $w.top -relief raised -bd 1
    pack $w.top -side top -expand yes -fill both
    frame $w.mid -relief raised -bd 1
    pack $w.mid -side top -fill both
    frame $w.bot -relief raised -bd 1
    pack $w.bot -side bottom -fill both

    message $w.top.msg -text $text -width 12i
    pack $w.top.msg -side right -expand yes -fill both -padx 2m -pady 2m

    entry $w.mid.ent -relief sunken -width 16 -textvariable entry$w
    hoc_register_data $w.mid.ent "Entry Widget" $entry_hoc_data
    pack $w.mid.ent -side top -expand yes -fill both -padx 1m -pady 1m

    set i 0
    foreach but $args {
	button $w.bot.button$i -text $but -command "set button$w $i"
	hoc_register_data $w.bot.button$i "Button Action"\
		{{summary "Dismiss the dialog box, taking other
actions as indicated by the button label."}}
	if { $i == $default } {
	    frame $w.bot.default -relief sunken -bd 1
	    raise $w.bot.button$i
	    pack $w.bot.default -side left -expand yes -padx 2m -pady 1m
	    pack $w.bot.button$i -in $w.bot.default -side left -padx 1m \
		    -pady 1m -ipadx 1m -ipady 1
	} else {
	    pack $w.bot.button$i -side left -expand yes \
		    -padx 2m -pady 2m -ipadx 1m -ipady 1
	}
	incr i
    }

    if { $default >= 0 } {
	bind $w <Return> "$w.bot.button$default flash ; set button$w $default"
    }

    place_near_mouse $w

    $::tk::Priv(wait_cmd) variable button$w
    set entrylocal [set entry$w]
    catch { destroy $w }
    return [set button$w]
}

# This proc pops up a dialog box with some radio buttons, an "apply" button, and a "dismiss" button
#
#	my_widget_name is the name to be used for this toplevel window
#	screen can be the pathname of some widget where the screen value can be obtained. Otherwise,
#		it is assumed to be a genuine X DISPLAY string.
#	radio_result is a string containing the name of the variable to hold the result (must be global)
#	title is the title to be displayed on the popup
#	text_message is a message to be displayed in the window (typically instructions for the user)
#	choice_labels is a list of labels for the radio buttons
#	default is the index of the default choice
#	help_strings is a list of help strings for the corresponding labels in choice_labels
proc cad_radio { my_widget_name screen radio_result title text_message default choice_labels help_strings } {
	global $radio_result
        global ::tk::Priv
	# The screen parameter can be the pathname of some
	# widget where the screen value can be obtained.
	# Otherwise, it is assumed to be a genuine X DISPLAY
	# string.
	if [winfo exists $screen] {
		set screen [winfo screen $screen]
	}

	set done 0
	set w $my_widget_name

	if [winfo exists $w] { catch "destroy $w" }
	toplevel $w -screen $screen
	wm title $w $title
	wm iconname $w Dialog
	message $w.mess -text $text_message -justify center -width 500
	hoc_register_data $w.mess "Radio Button Selection Dialog" {
		{ summary "Use this window to select any one of the possibilities listed" }
	}
	grid $w.mess -row 0 -column 0 -columnspan 2 -sticky ew
	set counter 0
	foreach choice $choice_labels {
		radiobutton $w.but_$counter -value $counter -variable $radio_result
		label $w.lab_$counter -text $choice
		grid $w.lab_$counter -row [expr $counter + 1] -column 1 -sticky ew
		grid $w.but_$counter -row [expr $counter + 1] -column 0 -sticky ew
		set hoc_data [subst {{ summary \"[lindex $help_strings $counter]\" }}]
		hoc_register_data $w.lab_$counter [lindex $choice_labels $counter] $hoc_data
		hoc_register_data $w.but_$counter [lindex $choice_labels $counter] $hoc_data
		incr counter
	}
	$w.but_$default invoke

	button $w.apply -text Apply -command {set done 1}
	hoc_register_data $w.apply "Apply" {
		{ summary "Click on this button to indicate you have finished making your selection" }
	}

	button $w.dismiss -text Dismiss -command "set $radio_result $default; set done 2"
	hoc_register_data $w.dismiss "Dismiss" {
		{ summary "Click on this button to indicate you do not want to change\nthis selection from its value when the window first appeared" }
	}

	grid $w.apply -row [expr $counter + 1] -column 0
	grid $w.dismiss -row [ expr $counter + 1] -column 1
	update

	$::tk::Priv(wait_cmd) variable done
	catch " destroy $w "
}

proc cad_list_buts { my_widget_name screen list_of_results cur_settings title text_message choice_labels help_strings } {
    global $list_of_results
    global list_but_result
    global list_buts_done
    global ::tk::Priv

    # The screen parameter can be the pathname of some
    # widget where the screen value can be obtained.
    # Otherwise, it is assumed to be a genuine X DISPLAY
    # string.
    if [winfo exists $screen] {
	set screen [winfo screen $screen]
    }

    set list_buts_done 0
    set w $my_widget_name

    if [winfo exists $w] { catch "destroy $w" }
    toplevel $w -screen $screen
    wm title $w $title
    wm iconname $w Dialog
    message $w.mess -text $text_message -justify center -width 500
    hoc_register_data $w.mess "List selection Dialog" {
	{ summary "Use this window select any number (or none) of the possibilities listed" }
    }

    grid $w.mess -row 0 -column 0 -columnspan 2 -sticky ew
    if { [llength $cur_settings] != [llength $choice_labels]} {
	puts "settings do not match choices"
	set $list_of_results $cur_settings
	catch " destroy $w "
	return
    }
    set counter 0
    foreach setting $cur_settings choice $choice_labels {
	set list_but_result($counter) $setting
	checkbutton $w.but_$counter -text [lindex $choice_labels $counter] -variable list_but_result($counter)
	grid $w.but_$counter -row [expr $counter + 1] -column 0 -sticky ew -columnspan 2
	set hoc_data [subst {{ summary \"[lindex $help_strings $counter]\" }}]
	hoc_register_data $w.but_$counter [lindex $choice_labels $counter] $hoc_data
	incr counter
    }

    button $w.apply -text Apply -command "set list_buts_done 1"
    hoc_register_data $w.apply "Apply" {
	{ summary "Click on this button to indicate you have finished making your selections" }
    }

    button $w.dismiss -text Dismiss -command "set list_buts_done 2"
    hoc_register_data $w.dismiss "Dismiss" {
	{ summary "Click on this button to indicate you do not want to change\nthe selections from their values when the window first appeared" }
    }

    grid $w.apply -row [expr $counter + 1] -column 0
    grid $w.dismiss -row [ expr $counter + 1] -column 1
    update

    $::tk::Priv(wait_cmd) variable list_buts_done

    set num_choices [llength $choice_labels]
    if { $list_buts_done == 2 } {
	set $list_of_results $cur_settings
    } else {
	set $list_of_results {}
	for { set counter 0 } { $counter < $num_choices } { incr counter } {
	    if { $list_but_result($counter) == 1 } {
		lappend $list_of_results "1"
	    } else {
		lappend $list_of_results "0"
	    }
	}
    }
    catch " destroy $w "
}

@


1.12
log
@update copyright to include span through 2003
@
text
@@


1.11
log
@Added "cad_list_buts" proc. Displays a list of selections (checkbuttons) and returns
the list of selections made.
@
text
@d16 1
a16 1
#	This software is Copyright (C) 1995 by the United States Army
@


1.11.4.1
log
@merge from HEAD
@
text
@d16 1
a16 1
#	This software is Copyright (C) 1995-2004 by the United States Army
@


1.10
log
@Update to tcl/tk 8.4 and itcl 3.2.1
@
text
@d241 2
a242 2
	hoc_register_data $w.dismiss "DIsmiss" {
		{ summary "Click on this button to indicate you do not want to change\nthis selection from its value when the window appeard" }
d252 76
@


1.10.2.1
log
@updated for merging
@
text
@d241 2
a242 2
	hoc_register_data $w.dismiss "Dismiss" {
		{ summary "Click on this button to indicate you do not want to change\nthis selection from its value when the window first appeared" }
a251 76

proc cad_list_buts { my_widget_name screen list_of_results cur_settings title text_message choice_labels help_strings } {
    global $list_of_results
    global list_but_result
    global list_buts_done
    global ::tk::Priv

    # The screen parameter can be the pathname of some
    # widget where the screen value can be obtained.
    # Otherwise, it is assumed to be a genuine X DISPLAY
    # string.
    if [winfo exists $screen] {
	set screen [winfo screen $screen]
    }

    set list_buts_done 0
    set w $my_widget_name

    if [winfo exists $w] { catch "destroy $w" }
    toplevel $w -screen $screen
    wm title $w $title
    wm iconname $w Dialog
    message $w.mess -text $text_message -justify center -width 500
    hoc_register_data $w.mess "List selection Dialog" {
	{ summary "Use this window select any number (or none) of the possibilities listed" }
    }

    grid $w.mess -row 0 -column 0 -columnspan 2 -sticky ew
    if { [llength $cur_settings] != [llength $choice_labels]} {
	puts "settings do not match choices"
	set $list_of_results $cur_settings
	catch " destroy $w "
	return
    }
    set counter 0
    foreach setting $cur_settings choice $choice_labels {
	set list_but_result($counter) $setting
	checkbutton $w.but_$counter -text [lindex $choice_labels $counter] -variable list_but_result($counter)
	grid $w.but_$counter -row [expr $counter + 1] -column 0 -sticky ew -columnspan 2
	set hoc_data [subst {{ summary \"[lindex $help_strings $counter]\" }}]
	hoc_register_data $w.but_$counter [lindex $choice_labels $counter] $hoc_data
	incr counter
    }

    button $w.apply -text Apply -command "set list_buts_done 1"
    hoc_register_data $w.apply "Apply" {
	{ summary "Click on this button to indicate you have finished making your selections" }
    }

    button $w.dismiss -text Dismiss -command "set list_buts_done 2"
    hoc_register_data $w.dismiss "Dismiss" {
	{ summary "Click on this button to indicate you do not want to change\nthe selections from their values when the window first appeared" }
    }

    grid $w.apply -row [expr $counter + 1] -column 0
    grid $w.dismiss -row [ expr $counter + 1] -column 1
    update

    $::tk::Priv(wait_cmd) variable list_buts_done

    set num_choices [llength $choice_labels]
    if { $list_buts_done == 2 } {
	set $list_of_results $cur_settings
    } else {
	set $list_of_results {}
	for { set counter 0 } { $counter < $num_choices } { incr counter } {
	    if { $list_but_result($counter) == 1 } {
		lappend $list_of_results "1"
	    } else {
		lappend $list_of_results "0"
	    }
	}
    }
    catch " destroy $w "
}

@


1.9
log
@Use $tkPriv(wait_cmd) instead of tkwait
@
text
@d28 1
a28 1
#		*- add tkPriv(wait_cmd) and use in all dialogs
d34 2
a35 2
if {![info exists tkPriv(wait_cmd)]} {
    set tkPriv(wait_cmd) tkwait
d45 1
a45 1
    global tkPriv
d113 1
a113 1
    $tkPriv(wait_cmd) variable button$w
d127 1
a127 1
    global tkPriv
d182 1
a182 1
    $tkPriv(wait_cmd) variable button$w
d201 1
a201 1
        global tkPriv
d249 1
a249 1
	$tkPriv(wait_cmd) variable done
@


1.9.4.1
log
@sync branch with HEAD
@
text
@d16 1
a16 1
#	This software is Copyright (C) 1995-2004 by the United States Army
d28 1
a28 1
#		*- add ::tk::Priv(wait_cmd) and use in all dialogs
d34 2
a35 2
if {![info exists ::tk::Priv(wait_cmd)]} {
    set ::tk::Priv(wait_cmd) tkwait
d45 1
a45 1
    global ::tk::Priv
d113 1
a113 1
    $::tk::Priv(wait_cmd) variable button$w
d127 1
a127 1
    global ::tk::Priv
d182 1
a182 1
    $::tk::Priv(wait_cmd) variable button$w
d201 1
a201 1
        global ::tk::Priv
d241 2
a242 2
	hoc_register_data $w.dismiss "Dismiss" {
		{ summary "Click on this button to indicate you do not want to change\nthis selection from its value when the window first appeared" }
d249 1
a249 1
	$::tk::Priv(wait_cmd) variable done
a251 76

proc cad_list_buts { my_widget_name screen list_of_results cur_settings title text_message choice_labels help_strings } {
    global $list_of_results
    global list_but_result
    global list_buts_done
    global ::tk::Priv

    # The screen parameter can be the pathname of some
    # widget where the screen value can be obtained.
    # Otherwise, it is assumed to be a genuine X DISPLAY
    # string.
    if [winfo exists $screen] {
	set screen [winfo screen $screen]
    }

    set list_buts_done 0
    set w $my_widget_name

    if [winfo exists $w] { catch "destroy $w" }
    toplevel $w -screen $screen
    wm title $w $title
    wm iconname $w Dialog
    message $w.mess -text $text_message -justify center -width 500
    hoc_register_data $w.mess "List selection Dialog" {
	{ summary "Use this window select any number (or none) of the possibilities listed" }
    }

    grid $w.mess -row 0 -column 0 -columnspan 2 -sticky ew
    if { [llength $cur_settings] != [llength $choice_labels]} {
	puts "settings do not match choices"
	set $list_of_results $cur_settings
	catch " destroy $w "
	return
    }
    set counter 0
    foreach setting $cur_settings choice $choice_labels {
	set list_but_result($counter) $setting
	checkbutton $w.but_$counter -text [lindex $choice_labels $counter] -variable list_but_result($counter)
	grid $w.but_$counter -row [expr $counter + 1] -column 0 -sticky ew -columnspan 2
	set hoc_data [subst {{ summary \"[lindex $help_strings $counter]\" }}]
	hoc_register_data $w.but_$counter [lindex $choice_labels $counter] $hoc_data
	incr counter
    }

    button $w.apply -text Apply -command "set list_buts_done 1"
    hoc_register_data $w.apply "Apply" {
	{ summary "Click on this button to indicate you have finished making your selections" }
    }

    button $w.dismiss -text Dismiss -command "set list_buts_done 2"
    hoc_register_data $w.dismiss "Dismiss" {
	{ summary "Click on this button to indicate you do not want to change\nthe selections from their values when the window first appeared" }
    }

    grid $w.apply -row [expr $counter + 1] -column 0
    grid $w.dismiss -row [ expr $counter + 1] -column 1
    update

    $::tk::Priv(wait_cmd) variable list_buts_done

    set num_choices [llength $choice_labels]
    if { $list_buts_done == 2 } {
	set $list_of_results $cur_settings
    } else {
	set $list_of_results {}
	for { set counter 0 } { $counter < $num_choices } { incr counter } {
	    if { $list_but_result($counter) == 1 } {
		lappend $list_of_results "1"
	    } else {
		lappend $list_of_results "0"
	    }
	}
    }
    catch " destroy $w "
}

@


1.9.6.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d34 2
a35 2
if {![info exists ::tk::Priv(wait_cmd)]} {
    set ::tk::Priv(wait_cmd) tkwait
d45 1
a45 1
    variable ::tk::Priv
d113 1
a113 1
    $Priv(wait_cmd) variable button$w
d127 1
a127 1
    variable ::tk::Priv
d182 1
a182 1
    $Priv(wait_cmd) variable button$w
d201 1
a201 1
        variable ::tk::Priv
d249 1
a249 1
	$Priv(wait_cmd) variable done
@


1.9.6.2
log
@sync to HEAD...
@
text
@d16 1
a16 1
#	This software is Copyright (C) 1995-2004 by the United States Army
d28 1
a28 1
#		*- add ::tk::Priv(wait_cmd) and use in all dialogs
d45 1
a45 1
    global ::tk::Priv
d113 1
a113 1
    $::tk::Priv(wait_cmd) variable button$w
d127 1
a127 1
    global ::tk::Priv
d182 1
a182 1
    $::tk::Priv(wait_cmd) variable button$w
d201 1
a201 1
        global ::tk::Priv
d241 2
a242 2
	hoc_register_data $w.dismiss "Dismiss" {
		{ summary "Click on this button to indicate you do not want to change\nthis selection from its value when the window first appeared" }
d249 1
a249 1
	$::tk::Priv(wait_cmd) variable done
a251 76

proc cad_list_buts { my_widget_name screen list_of_results cur_settings title text_message choice_labels help_strings } {
    global $list_of_results
    global list_but_result
    global list_buts_done
    global ::tk::Priv

    # The screen parameter can be the pathname of some
    # widget where the screen value can be obtained.
    # Otherwise, it is assumed to be a genuine X DISPLAY
    # string.
    if [winfo exists $screen] {
	set screen [winfo screen $screen]
    }

    set list_buts_done 0
    set w $my_widget_name

    if [winfo exists $w] { catch "destroy $w" }
    toplevel $w -screen $screen
    wm title $w $title
    wm iconname $w Dialog
    message $w.mess -text $text_message -justify center -width 500
    hoc_register_data $w.mess "List selection Dialog" {
	{ summary "Use this window select any number (or none) of the possibilities listed" }
    }

    grid $w.mess -row 0 -column 0 -columnspan 2 -sticky ew
    if { [llength $cur_settings] != [llength $choice_labels]} {
	puts "settings do not match choices"
	set $list_of_results $cur_settings
	catch " destroy $w "
	return
    }
    set counter 0
    foreach setting $cur_settings choice $choice_labels {
	set list_but_result($counter) $setting
	checkbutton $w.but_$counter -text [lindex $choice_labels $counter] -variable list_but_result($counter)
	grid $w.but_$counter -row [expr $counter + 1] -column 0 -sticky ew -columnspan 2
	set hoc_data [subst {{ summary \"[lindex $help_strings $counter]\" }}]
	hoc_register_data $w.but_$counter [lindex $choice_labels $counter] $hoc_data
	incr counter
    }

    button $w.apply -text Apply -command "set list_buts_done 1"
    hoc_register_data $w.apply "Apply" {
	{ summary "Click on this button to indicate you have finished making your selections" }
    }

    button $w.dismiss -text Dismiss -command "set list_buts_done 2"
    hoc_register_data $w.dismiss "Dismiss" {
	{ summary "Click on this button to indicate you do not want to change\nthe selections from their values when the window first appeared" }
    }

    grid $w.apply -row [expr $counter + 1] -column 0
    grid $w.dismiss -row [ expr $counter + 1] -column 1
    update

    $::tk::Priv(wait_cmd) variable list_buts_done

    set num_choices [llength $choice_labels]
    if { $list_buts_done == 2 } {
	set $list_of_results $cur_settings
    } else {
	set $list_of_results {}
	for { set counter 0 } { $counter < $num_choices } { incr counter } {
	    if { $list_but_result($counter) == 1 } {
		lappend $list_of_results "1"
	    } else {
		lappend $list_of_results "0"
	    }
	}
    }
    catch " destroy $w "
}

@


1.8
log
@cad_dialog and cad_input_dialog procs
now call place_near_mouse
@
text
@d28 1
d34 4
d45 1
d48 1
a48 2
	raise $w
	return
d113 1
a113 1
    tkwait variable button$w
d127 1
d182 1
a182 1
    tkwait variable button$w
d201 1
d249 1
a249 1
	tkwait variable done
@


1.7
log
@Added cad_radio proc
@
text
@d106 1
a106 14
    set pxy [winfo pointerxy $w]
    set x [lindex $pxy 0]
    set y [lindex $pxy 1]
    set width [winfo reqwidth $w]
    set dx [expr $width / 2]
    set x [expr $x - $dx]
    set y [expr $y - 70]
    if {$x < 0} {
	set x 0
    }
    if {$y < 0} {
	set y 0
    }
    wm geometry $w +$x+$y
d174 1
a174 14
    set pxy [winfo pointerxy $w]
    set x [lindex $pxy 0]
    set y [lindex $pxy 1]
    set width [winfo reqwidth $w]
    set dx [expr $width / 2]
    set x [expr $x - $dx]
    set y [expr $y - 70]
    if {$x < 0} {
	set x 0
    }
    if {$y < 0} {
	set y 0
    }
    wm geometry $w +$x+$y
@


1.7.2.1
log
@cad_dialog and cad_input_dialog procs
now call place_near_mouse
@
text
@d106 14
a119 1
    place_near_mouse $w
d187 14
a200 1
    place_near_mouse $w
@


1.7.2.2
log
@Use tkPriv(wait_cmd)
@
text
@a27 1
#		*- add tkPriv(wait_cmd) and use in all dialogs
a32 4
if {![info exists tkPriv(wait_cmd)]} {
    set tkPriv(wait_cmd) tkwait
}

a39 1
    global tkPriv
d42 2
a43 1
	catch {destroy $w}
d108 1
a108 1
    $tkPriv(wait_cmd) variable button$w
a121 1
    global tkPriv
d176 1
a176 1
    $tkPriv(wait_cmd) variable button$w
a194 1
        global tkPriv
d242 1
a242 1
	$tkPriv(wait_cmd) variable done
@


1.6
log
@*- change the interpretation of the screen parameter
@
text
@d28 2
d206 64
@


1.5
log
@*- mods to cad_input_dialog() to accept a parameter that
contains help on context for the entry widget
@
text
@d44 8
d137 8
@


1.4
log
@*- mod to cad_dialog to properly resize
@
text
@d122 2
a123 1
proc cad_input_dialog { w screen title text entryvar defaultentry default args } {
d133 1
a133 1
    pack $w.top -side top -fill both
d143 1
d149 3
@


1.3
log
@*- mods to the cad_dialog proc to use a text
   widget and scrollbar when the incoming string
   gets too large (i.e. > 1000)
@
text
@d48 1
a48 1
    pack $w.top -side top -fill both
@


1.2
log
@*- if the dialog exists, raise it and return
@
text
@d20 2
a21 2
#	"cad_dialog" and "cad_input_dialog" are based off of the "tk_dialog" that
#	comes with Tk 4.0.
d25 3
a27 1
#		*- mods to popup the dialog box near the pointer
d52 19
a70 2
    message $w.top.msg -text $text -width 12i
    pack $w.top.msg -side right -expand yes -fill both -padx 2m -pady 2m
@


1.1
log
@*- "cad_dialog" and "cad_input_dialog" are based off of the "tk_dialog" that
    comes with Tk 4.0.
@
text
@d37 5
@
