head	1.7;
access;
symbols
	ansi-20040405-merged:1.4.4.1
	postmerge-20040405-ansi:1.6
	premerge-20040404-ansi:1.6
	postmerge-autoconf:1.6
	autoconf-freeze:1.5.6.1
	premerge-autoconf:1.6
	postmerge-20040315-windows:1.6
	premerge-20040315-windows:1.6
	windows-20040315-freeze:1.4.6.2
	autoconf-20031203:1.5
	autoconf-20031202:1.5
	autoconf-branch:1.5.0.6
	phong-branch:1.5.0.4
	photonmap-branch:1.5.0.2
	rel-6-1-DP:1.4
	windows-branch:1.4.0.6
	rel-6-0-2:1.4
	ansi-branch:1.4.0.4
	rel-6-0-1-branch:1.4.0.2
	hartley-6-0-post:1.4
	hartley-6-0-pre:1.4
	rel-6-0-1:1.4
	rel-6-0:1.4
	rel-5-4:1.3.2.1
	offsite-5-3-pre:1.3
	rel-5-3:1.3.2.1
	rel-5-2:1.3
	rel-5-1-branch:1.3.0.2
	rel-5-1:1.3
	rel-5-0:1.3
	rel-5-0-beta:1.3;
locks; strict;
comment	@# @;


1.7
date	2004.05.21.16.41.18;	author morrison;	state dead;
branches;
next	1.6;

1.6
date	2004.02.02.17.39.42;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2003.03.13.19.45.26;	author jra;	state Exp;
branches
	1.5.6.1;
next	1.4;

1.4
date	2001.03.19.22.20.19;	author butler;	state Exp;
branches
	1.4.4.1
	1.4.6.1;
next	1.3;

1.3
date	98.11.13.22.27.06;	author bparker;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	98.04.28.15.28.46;	author bparker;	state Exp;
branches;
next	1.1;

1.1
date	98.04.24.20.29.08;	author bparker;	state Exp;
branches;
next	;

1.3.2.1
date	2000.12.22.00.40.48;	author bparker;	state Exp;
branches;
next	;

1.4.4.1
date	2004.03.17.21.23.04;	author morrison;	state Exp;
branches;
next	;

1.4.6.1
date	2002.09.26.23.04.16;	author morrison;	state Exp;
branches;
next	1.4.6.2;

1.4.6.2
date	2004.03.11.23.48.41;	author morrison;	state Exp;
branches;
next	;

1.5.6.1
date	2004.02.12.18.34.47;	author erikg;	state Exp;
branches;
next	;


desc
@@


1.7
log
@moved to src/tclscripts/
@
text
@##
#				M E N U _ O V E R R I D E . T C L
#
# Author -
#	Bob Parker
#
# Source -
#	The U. S. Army Research Laboratory
#	Aberdeen Proving Ground, Maryland  21005
#
# Distribution Notice -
#	Re-distribution of this software is restricted, as described in
#       your "Statement of Terms and Conditions for the Release of
#       The BRL-CAD Package" agreement.
#
# Copyright Notice -
#       This software is Copyright (C) 1998-2004 by the United States Army
#       in all countries except the USA.  All rights reserved.
#
# Description -
#	The proc's below were copied from libtk/menu.tcl and modified.
#

bind Menu <ButtonRelease> {
    cad_MenuInvoke %W %b
}

# cad_MenuInvoke --
#
# This procedure is invoked when a button is released over a menu.
# It invokes the appropriate menu action and unposts the menu if
# it came from a menubutton.
#
# Arguments:
# w -			Name of the menu widget.
# button -		Button that was released.
#
proc cad_MenuInvoke { w button } {
    global ::tk::Priv

    if { ([lsearch -exact [array name ::tk::Priv] window] != -1) && $::tk::Priv(window) == ""} {
	# Mouse was pressed over a menu without a menu button, then
	# dragged off the menu (possibly with a cascade posted) and
	# released.  Unpost everything and quit.

	$w postcascade none
	$w activate none
	event generate $w <<MenuSelect>>
	::tk::MenuUnpost $w
	return
    }
    if {[$w type active] == "cascade"} {
	$w postcascade active
	set menu [$w entrycget active -menu]
	::tk::MenuFirstEntry $menu
    } elseif {[$w type active] == "tearoff"} {
	::tk::MenuUnpost $w
	::tk::TearOffMenu $w
    } elseif {[$w cget -type] == "menubar"} {
	$w postcascade none
	$w activate none
	event generate $w <<MenuSelect>>
	::tk::MenuUnpost $w
    } else {
	::tk::MenuUnpost $w

	if {$button == 3} {
	    hoc_menu_callback $w
	} else {
	    uplevel #0 [list $w invoke active]
	}
    }
}

proc cad_MenuFirstEntry { menu } {
    if {$menu == ""} {
	return
    }

    tk_menuSetFocus $menu

    if {[$menu index active] != "none"} {
        return
    }

    set last [$menu index last]

    if {$last == "none"} {
        return
    }

    for {set i 0} {$i <= $last} {incr i} {
	if {([catch {set state [$menu entrycget $i -state]}] == 0)
	&& ($state != "disabled") && ([$menu type $i] != "tearoff")} {
	    $menu activate $i
	    ::tk::GenerateMenuSelect $menu
	    if {[$menu type $i] == "cascade"} {
		set cascade [$menu entrycget $i -menu]
		if {[string compare $cascade ""] != 0} {
		    $menu postcascade $i
		}
	    }
            return
	}
    }   
}

proc ::tk::TraverseWithinMenu { w char } {
    if {$char == ""} {
	return
    }

    set char [string tolower $char]
    set last [$w index last]

    if {$last == "none"} {
        return
    }

    for {set i 0} {$i <= $last} {incr i} {
	if [catch {set char2 [string index  [$w entrycget $i -label]  [$w entrycget $i -underline]]}] {
	    continue
	}

	if {[string compare $char [string tolower $char2]] == 0} {
	    if {[$w type $i] == "cascade"} {
		$w activate $i
		$w postcascade active
		event generate $w <<MenuSelect>>
		set m2 [$w entrycget $i -menu]
		if {$m2 != ""} {
		    cad_MenuFirstEntry $m2
		}
	    }    else {
                ::tk::MenuUnpost $w
                uplevel #0 [list $w invoke $i]
	    }
            return
	}

    }
}

proc ::tk::MenuNextMenu {menu direction} {
    global ::tk::Priv

    # First handle traversals into and out of cascaded menus.

    if {$direction == "right"} {
	set count 1
	set parent [winfo parent $menu]
	set class [winfo class $parent]
	if {[$menu type active] == "cascade"} {
	    $menu postcascade active
	    set m2 [$menu entrycget active -menu]
	    if {$m2 != ""} {
		cad_MenuFirstEntry $m2
	    }
	    return
	} else {
	    set parent [winfo parent $menu]
	    while {($parent != ".")} {
		if {([winfo class $parent] == "Menu")
			&& ([$parent cget -type] == "menubar")} {
		    tk_menuSetFocus $parent
		    ::tk::MenuNextEntry $parent 1
		    return
		}
		set parent [winfo parent $parent]
	    }
	}
    } else {
	set count -1
	set m2 [winfo parent $menu]
	if {[winfo class $m2] == "Menu"} {
	    if {[$m2 cget -type] != "menubar"} {
		$menu activate none
		::tk::GenerateMenuSelect $menu
		tk_menuSetFocus $m2
		
		# This code unposts any posted submenu in the parent.
		
		set tmp [$m2 index active]
		$m2 activate none
		$m2 activate $tmp
		return
	    }
	}
    }

    # Can't traverse into or out of a cascaded menu.  Go to the next
    # or previous menubutton, if that makes sense.

    set m2 [winfo parent $menu]
    if {[winfo class $m2] == "Menu"} {
	if {[$m2 cget -type] == "menubar"} {
	    tk_menuSetFocus $m2
	    ::tk::MenuNextEntry $m2 -1
	    return
	}
    }

    set w $::tk::Priv(postedMb)
    if {$w == ""} {
	return
    }
    set buttons [winfo children [winfo parent $w]]
    set length [llength $buttons]
    set i [expr [lsearch -exact $buttons $w] + $count]
    while 1 {
	while {$i < 0} {
	    incr i $length
	}
	while {$i >= $length} {
	    incr i -$length
	}
	set mb [lindex $buttons $i]
	if {([winfo class $mb] == "Menubutton")
		&& ([$mb cget -state] != "disabled")
		&& ([$mb cget -menu] != "")
		&& ([[$mb cget -menu] index last] != "none")} {
	    break
	}
	if {$mb == $w} {
	    return
	}
	incr i $count
    }
    ::tk::MbPost $mb
    ::tk::MenuFirstEntry [$mb cget -menu]
}

proc ::tk::MenuNextEntry {menu count} {
    global ::tk::Priv

    if {[$menu index last] == "none"} {
	return
    }
    $menu postcascade none
    set length [expr [$menu index last]+1]
    set quitAfter $length
    set active [$menu index active]
    if {$active == "none"} {
	set i 0
    } else {
	set i [expr $active + $count]
    }
    while 1 {
	if {$quitAfter <= 0} {
	    # We've tried every entry in the menu.  Either there are
	    # none, or they're all disabled.  Just give up.

	    return
	}
	while {$i < 0} {
	    incr i $length
	}
	while {$i >= $length} {
	    incr i -$length
	}
	if {[catch {$menu entrycget $i -state} state] == 0} {
	    if {$state != "disabled"} {
		break
	    }
	}
	if {$i == $active} {
	    return
	}
	incr i $count
	incr quitAfter -1
    }
    $menu activate $i
    ::tk::GenerateMenuSelect $menu
    if {[$menu type $i] == "cascade"} {
	set cascade [$menu entrycget $i -menu]
	if {[string compare $cascade ""] != 0} {
	    $menu postcascade $i
#	    ::tk::MenuFirstEntry $cascade
	}
    }
}

proc ::tk::MenuEscape menu {
    global ::tk::Priv

    set parent [winfo parent $menu]
    if {([winfo class $parent] != "Menu")} {
	::tk::MenuUnpost $menu
    } elseif {([$parent cget -type] == "menubar")} {
	::tk::MenuUnpost $menu
	::tk::RestoreOldGrab
    } else {
	set grand_parent [winfo parent $parent]
	if {[winfo class $grand_parent] != "Menu"} {
	    ::tk::MenuUnpost $menu
	} else {
	    ::tk::MenuNextMenu $menu left
	}
    }
}
@


1.6
log
@update copyright to include span through 2003
@
text
@@


1.5
log
@Update to tcl/tk 8.4 and itcl 3.2.1
@
text
@d17 1
a17 1
#       This software is Copyright (C) 1998 by the United States Army
@


1.5.6.1
log
@merge from HEAD
@
text
@d17 1
a17 1
#       This software is Copyright (C) 1998-2004 by the United States Army
@


1.4
log
@patches to merge 5.3 into 6.0
@
text
@d39 1
a39 1
    global tkPriv
d41 1
a41 1
    if {$tkPriv(window) == ""} {
d49 1
a49 1
	tkMenuUnpost $w
d55 1
a55 1
	tkMenuFirstEntry $menu
d57 2
a58 2
	tkMenuUnpost $w
	tkTearOffMenu $w
d63 1
a63 1
	tkMenuUnpost $w
d65 1
a65 1
	tkMenuUnpost $w
d96 1
a96 1
	    tkGenerateMenuSelect $menu
d108 1
a108 1
proc tkTraverseWithinMenu { w char } {
d135 1
a135 1
                tkMenuUnpost $w
d144 2
a145 2
proc tkMenuNextMenu {menu direction} {
    global tkPriv
d166 1
a166 1
		    tkMenuNextEntry $parent 1
d178 1
a178 1
		tkGenerateMenuSelect $menu
d198 1
a198 1
	    tkMenuNextEntry $m2 -1
d203 1
a203 1
    set w $tkPriv(postedMb)
d229 2
a230 2
    tkMbPost $mb
    tkMenuFirstEntry [$mb cget -menu]
d233 2
a234 2
proc tkMenuNextEntry {menu count} {
    global tkPriv
d273 1
a273 1
    tkGenerateMenuSelect $menu
d278 1
a278 1
#	    tkMenuFirstEntry $cascade
d283 2
a284 2
proc tkMenuEscape menu {
    global tkPriv
d288 1
a288 1
	tkMenuUnpost $menu
d290 2
a291 2
	tkMenuUnpost $menu
	tkRestoreOldGrab
d295 1
a295 1
	    tkMenuUnpost $menu
d297 1
a297 1
	    tkMenuNextMenu $menu left
@


1.4.4.1
log
@sync branch with HEAD
@
text
@d17 1
a17 1
#       This software is Copyright (C) 1998-2004 by the United States Army
d39 1
a39 1
    global ::tk::Priv
d41 1
a41 1
    if { ([lsearch -exact [array name ::tk::Priv] window] != -1) && $::tk::Priv(window) == ""} {
d49 1
a49 1
	::tk::MenuUnpost $w
d55 1
a55 1
	::tk::MenuFirstEntry $menu
d57 2
a58 2
	::tk::MenuUnpost $w
	::tk::TearOffMenu $w
d63 1
a63 1
	::tk::MenuUnpost $w
d65 1
a65 1
	::tk::MenuUnpost $w
d96 1
a96 1
	    ::tk::GenerateMenuSelect $menu
d108 1
a108 1
proc ::tk::TraverseWithinMenu { w char } {
d135 1
a135 1
                ::tk::MenuUnpost $w
d144 2
a145 2
proc ::tk::MenuNextMenu {menu direction} {
    global ::tk::Priv
d166 1
a166 1
		    ::tk::MenuNextEntry $parent 1
d178 1
a178 1
		::tk::GenerateMenuSelect $menu
d198 1
a198 1
	    ::tk::MenuNextEntry $m2 -1
d203 1
a203 1
    set w $::tk::Priv(postedMb)
d229 2
a230 2
    ::tk::MbPost $mb
    ::tk::MenuFirstEntry [$mb cget -menu]
d233 2
a234 2
proc ::tk::MenuNextEntry {menu count} {
    global ::tk::Priv
d273 1
a273 1
    ::tk::GenerateMenuSelect $menu
d278 1
a278 1
#	    ::tk::MenuFirstEntry $cascade
d283 2
a284 2
proc ::tk::MenuEscape menu {
    global ::tk::Priv
d288 1
a288 1
	::tk::MenuUnpost $menu
d290 2
a291 2
	::tk::MenuUnpost $menu
	::tk::RestoreOldGrab
d295 1
a295 1
	    ::tk::MenuUnpost $menu
d297 1
a297 1
	    ::tk::MenuNextMenu $menu left
@


1.4.6.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d39 1
a39 1
    variable ::tk::Priv
d41 1
a41 1
    if {$Priv(window) == ""} {
d49 1
a49 1
	::tk::MenuUnpost $w
d55 1
a55 1
	::tk::MenuFirstEntry $menu
d57 2
a58 2
	::tk::MenuUnpost $w
	::tk::TearOffMenu $w
d63 1
a63 1
	::tk::MenuUnpost $w
d65 1
a65 1
	::tk::MenuUnpost $w
d96 1
a96 1
	    ::tk::GenerateMenuSelect $menu
d135 1
a135 1
                ::tk::MenuUnpost $w
d145 1
a145 1
    variable ::tk::Priv
d178 1
a178 1
		::tk::GenerateMenuSelect $menu
d203 1
a203 1
    set w $Priv(postedMb)
d229 2
a230 2
    ::tk::MbPost $mb
    ::tk::MenuFirstEntry [$mb cget -menu]
d234 1
a234 1
    variable ::tk::Priv
d273 1
a273 1
    ::tk::GenerateMenuSelect $menu
d278 1
a278 1
#	    ::tk::MenuFirstEntry $cascade
d284 1
a284 1
    global Priv
d290 2
a291 2
	::tk::MenuUnpost $menu
	::tk::RestoreOldGrab
d295 1
a295 1
	    ::tk::MenuUnpost $menu
@


1.4.6.2
log
@sync to HEAD...
@
text
@d17 1
a17 1
#       This software is Copyright (C) 1998-2004 by the United States Army
d39 1
a39 1
    global ::tk::Priv
d41 1
a41 1
    if { ([lsearch -exact [array name ::tk::Priv] window] != -1) && $::tk::Priv(window) == ""} {
d108 1
a108 1
proc ::tk::TraverseWithinMenu { w char } {
d144 2
a145 2
proc ::tk::MenuNextMenu {menu direction} {
    global ::tk::Priv
d166 1
a166 1
		    ::tk::MenuNextEntry $parent 1
d198 1
a198 1
	    ::tk::MenuNextEntry $m2 -1
d203 1
a203 1
    set w $::tk::Priv(postedMb)
d233 2
a234 2
proc ::tk::MenuNextEntry {menu count} {
    global ::tk::Priv
d283 2
a284 2
proc ::tk::MenuEscape menu {
    global ::tk::Priv
d288 1
a288 1
	::tk::MenuUnpost $menu
d297 1
a297 1
	    ::tk::MenuNextMenu $menu left
@


1.3
log
@*- partially override tkMenuInvoke with cad_MenuInvoke in
   order to allow menus to participate in the CAD help system.
@
text
@d30 1
a30 1
# This procedure is invoked when button 1 is released over a menu.
@


1.3.2.1
log
@Typo in comment.
@
text
@d30 1
a30 1
# This procedure is invoked when a button is released over a menu.
@


1.2
log
@mods to tkMenuEscape
@
text
@d1 1
a1 1
#
d24 3
a26 4
proc tkTraverseWithinMenu { w char } {
    if {$char == ""} {
	return
    }
d28 12
a39 2
    set char [string tolower $char]
    set last [$w index last]
d41 10
a50 2
    if {$last == "none"} {
        return
d52 19
a70 20

    for {set i 0} {$i <= $last} {incr i} {
	if [catch {set char2 [string index  [$w entrycget $i -label]  [$w entrycget $i -underline]]}] {
	    continue
	}

	if {[string compare $char [string tolower $char2]] == 0} {
	    if {[$w type $i] == "cascade"} {
		$w activate $i
		$w postcascade active
		event generate $w <<MenuSelect>>
		set m2 [$w entrycget $i -menu]
		if {$m2 != ""} {
		    mged_MenuFirstEntry $m2
		}
	    }    else {
                tkMenuUnpost $w
                uplevel #0 [list $w invoke $i]
	    }
            return
a71 1

d75 1
a75 1
proc mged_MenuFirstEntry { menu } {
d108 36
d157 1
a157 1
		mged_MenuFirstEntry $m2
@


1.1
log
@Proc's to override some of the ones in libtk/menu.tcl.
@
text
@d237 1
a237 5
	if {[$menu cget -type] == "menubar"} {
	    tkMenuUnpost [$menu entrycget $tkPriv(activeItem) -menu]
	} else {
	    tkMenuUnpost $menu
	}
d242 6
a247 1
	tkMenuNextMenu $menu left
d249 1
a249 1
}@
