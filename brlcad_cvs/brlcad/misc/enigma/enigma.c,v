head	14.4;
access;
symbols
	rel-7-10-4:14.3
	STABLE:14.3.0.2
	stable-branch:14.1
	rel-7-10-2:14.3
	rel-7-10-0:14.3
	rel-7-8-4:14.2
	rel-7-8-2:14.2
	rel-7-8-0:14.2
	trimnurbs-branch:14.2.0.2
	help:14.2
	temp_tag:14.2
	bobWinPort-20051223-freeze:14.1
	postmerge-20051223-bobWinPort:14.2
	premerge-20051223-bobWinPort:14.2
	rel-7-6-6:14.2
	rel-7-6-4:14.2
	rel-7-6-2:14.1
	rel-7-6-branch:14.1.0.6
	rel-7-6-0:14.1
	rel-7-4-2:14.1
	rel-7-4-branch:14.1.0.4
	bobWinPort:14.1.0.2
	rel-7-4-0:14.1
	rel-7-2-6:14.1
	rel-7-2-4:14.1
	rel-7-2-2:14.1
	rel-7-2-0:14.1
	rel-7-0-4:14.1
	rel-7-0-2:14.1
	rel-7-0-1:14.1
	opensource-post:14.1
	opensource-pre:1.1
	rel-7-0-branch:1.1.0.2
	rel-7-0:1.1
	postmerge-20040405-ansi:1.1
	premerge-20040404-ansi:1.1
	postmerge-autoconf:1.1
	premerge-autoconf:1.1;
locks; strict;
comment	@ * @;


14.4
date	2007.12.18.15.51.32;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2007.01.27.01.41.29;	author brlcad;	state Exp;
branches;
next	14.2;

14.2
date	2005.10.23.04.27.08;	author brlcad;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.10;	author morrison;	state Exp;
branches
	14.1.6.1;
next	1.1;

1.1
date	2004.03.17.05.30.52;	author morrison;	state Exp;
branches;
next	;

14.1.6.1
date	2005.11.13.13.46.10;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.4
log
@quell warning, need #define _XOPEN_SOURCE to get crypt from unistd.h on SGI linux
@
text
@/*
 *	"enigma.c" is in file cbw.tar from
 *	anonymous FTP host watmsg.waterloo.edu: pub/crypt/cbw.tar.Z
 *
 *	A one-rotor machine designed along the lines of Enigma
 *	but considerably trivialized.
 *
 *	A public-domain replacement for the UNIX "crypt" command.
 *
 *	Upgraded to function properly on 64-bit machines.
 *
 *      Upgraded to have inline "makekey", and to test for
 *	backwards-compatible operation of crypt(), rather than MD5 version.
 *      crypt() is often found in -lcrypt
 *
 *	Added backwards-compatibility for handling illegal salt chars.
 */

#define _XOPEN_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define MINUSKVAR "CrYpTkEy"

#define ECHO 010
#define ROTORSZ 256
#define MASK 0377
char	t1[ROTORSZ];
char	t2[ROTORSZ];
char	t3[ROTORSZ];
char	deck[ROTORSZ];
char	ibuf[13];
char	buf[13];

void	shuffle(char *);

void
puth( title, cp, len )
char	*title;
char	*cp;
int	len;
{
	fprintf( stderr, "%s = %s = ", title, cp);
	while( len-- > 0 )  {
		fprintf(stderr, "%2.2x ", (*cp++) & 0xFF );
	}
	fprintf(stderr,"\n");
}

/* Different versions of crypt(3) interpret illegal chars differently.
 * Emulate the behavior seen on 4.3BSD and earlier AT&T versions.
 * (Why did FreeBSD have to change this?)
 */
int
saltfix(c)
int c;
{
	if( (c >= '.' && c <= '9') || (c >= 'A' && c <= 'Z' )
		|| (c >= 'a' && c <= 'z') ) return c;

	fprintf(stderr, "WARNING: Character '%c' is illegal in first two bytes of salt.\nAttempting to map in backwards-compatible manner.\n", c);
	/* Heuristics to match older behavior with newer libraries */
	if( c <= '-' )  return ('z' - ( c - '-' ));
	if( c >= '{' )  return ((c - '{' ) + '.');
	if( c >= '[' && c <= '`' )  return ((c - '[' ) + 'U' );
	if( c >= ':' && c <= '@@' )  return ((c - ':' ) + '3' );

	fprintf(stderr, "ERROR: Character '%c' is illegal in password, aborting.\n", c);
	exit(1);
	/* NOTREACHED */
}

void
setup(pw)
	char *pw;
{
	int ic, i, k, temp;
	unsigned random;
	long seed;
	char *r;
	char salt[3];

	/* Verify backwards-compatible operation of library routine crypt() */
	r = crypt("glorp", "gl");
	if( strncmp( r, "$1$gl$85n.KNI", 13 ) == 0 )  {
		fprintf(stderr, "enigma: crypt() library routine is using MD5 rather than DES.\n%s\n",
			"Incompatible encryption would occur, aborting.");
		exit(1);
	}
	if( strcmp( r, "gl4EsjmGvYQE." ) != 0 )  {
		fprintf(stderr, "enigma: malfunction in crypt() library routine, aborting.\n");
		exit(1);
	}

	/* Don't exec makekey, just invoke library routine directly */
	strncpy(ibuf, pw, 8);
	while (*pw)
		*pw++ = '\0';
	ibuf[8] = '\0';
	salt[0] = saltfix(ibuf[0]);
	salt[1] = saltfix(ibuf[1]);
	salt[2] = '\0';
	r = crypt( ibuf, salt );
	strncpy( buf, r, sizeof(buf) );

	/* First 2 bytes are echo of the salt.  Replace with original salt. */
	buf[0] = ibuf[0];
	buf[1] = ibuf[1];

	seed = 123;
	for (i=0; i<13; i++)
		seed = seed*buf[i] + i;
	for(i=0;i<ROTORSZ;i++) {
		t1[i] = i;
		deck[i] = i;
	}
	for(i=0;i<ROTORSZ;i++) {
		seed = 5*seed + buf[i%13];
		if( sizeof(long) > 4 )  {
			/* Force seed to stay in 32-bit signed math */
			if( seed & 0x80000000 )
				seed = seed | (-1L & ~0xFFFFFFFFL);
			else
				seed &= 0x7FFFFFFF;
		}
		random = seed % 65521;
		k = ROTORSZ-1 - i;
		ic = (random&MASK)%(k+1);
		random >>= 8;
		temp = t1[k];
		t1[k] = t1[ic];
		t1[ic] = temp;
		if(t3[k]!=0) continue;
		ic = (random&MASK) % k;
		while(t3[ic]!=0) ic = (ic+1) % k;
		t3[k] = ic;
		t3[ic] = k;
	}
	for(i=0;i<ROTORSZ;i++)
		t2[t1[i]&MASK] = i;
}

int
main(argc, argv)
	char *argv[];
{
	register int i, n1, n2, nr1, nr2;
	int secureflg = 0, kflag = 0;
	char *cp;

	if (argc > 1 && argv[1][0] == '-') {
		if (argv[1][1] == 's') {
			argc--;
			argv++;
			secureflg = 1;
		} else if (argv[1][1] == 'k') {
			argc--;
			argv++;
			kflag = 1;
		}
	}
	if (kflag) {
		if ((cp = getenv(MINUSKVAR)) == NULL) {
			fprintf(stderr, "%s not set\n", MINUSKVAR);
			exit(1);
		}
		setup(cp);
	} else if (argc != 2) {
		setup(getpass("Enter key:"));
	}
	else
		setup(argv[1]);
	n1 = 0;
	n2 = 0;
	nr2 = 0;

	while((i=getchar()) != -1) {
		if (secureflg) {
			nr1 = deck[n1]&MASK;
			nr2 = deck[nr1]&MASK;
		} else {
			nr1 = n1;
		}
		i = t2[(t3[(t1[(i+nr1)&MASK]+nr2)&MASK]-nr2)&MASK]-nr1;
		putchar(i);
		n1++;
		if(n1==ROTORSZ) {
			n1 = 0;
			n2++;
			if(n2==ROTORSZ) n2 = 0;
			if (secureflg) {
				shuffle(deck);
			} else {
				nr2 = n2;
			}
		}
	}

	return 0;
}

void
shuffle(deck)
	char deck[];
{
	int i, ic, k, temp;
	unsigned random;
	static long seed = 123;

	for(i=0;i<ROTORSZ;i++) {
		seed = 5*seed + buf[i%13];
		random = seed % 65521;
		k = ROTORSZ-1 - i;
		ic = (random&MASK)%(k+1);
		temp = deck[k];
		deck[k] = deck[ic];
		deck[ic] = temp;
	}
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.3
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d19 2
@


14.2
log
@trailing ws
@
text
@d67 1
a67 1
 	if( c >= ':' && c <= '@@' )  return ((c - ':' ) + '3' );
d81 2
a82 2
        char *r;
        char salt[3];
d84 4
a87 4
        /* Verify backwards-compatible operation of library routine crypt() */
        r = crypt("glorp", "gl");
        if( strncmp( r, "$1$gl$85n.KNI", 13 ) == 0 )  {
                fprintf(stderr, "enigma: crypt() library routine is using MD5 rather than DES.\n%s\n",
d89 6
a94 6
                exit(1);
        }
        if( strcmp( r, "gl4EsjmGvYQE." ) != 0 )  {
                fprintf(stderr, "enigma: malfunction in crypt() library routine, aborting.\n");
                exit(1);
        }
d96 1
a96 1
        /* Don't exec makekey, just invoke library routine directly */
d104 2
a105 2
        r = crypt( ibuf, salt );
        strncpy( buf, r, sizeof(buf) );
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d69 1
a69 1
	fprintf(stderr, "ERROR: Character '%c' is illegal in password, aborting.\n", c);	
@


14.1.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d69 1
a69 1
	fprintf(stderr, "ERROR: Character '%c' is illegal in password, aborting.\n", c);
@


1.1
log
@add enigma, the public domain crypt replacement to the distribution for convenience
@
text
@d221 10
@

