head	11.7;
access;
symbols
	ansi-20040405-merged:11.4.2.1
	postmerge-20040405-ansi:11.5
	premerge-20040404-ansi:11.4
	postmerge-autoconf:11.4
	autoconf-freeze:11.4
	premerge-autoconf:11.4
	postmerge-20040315-windows:11.4
	premerge-20040315-windows:11.4
	windows-20040315-freeze:11.4
	autoconf-20031203:11.4
	autoconf-20031202:11.4
	autoconf-branch:11.4.0.10
	phong-branch:11.4.0.8
	photonmap-branch:11.4.0.6
	rel-6-1-DP:11.4
	windows-branch:11.4.0.4
	rel-6-0-2:11.2
	ansi-branch:11.4.0.2
	rel-6-0-1-branch:11.2.0.2
	hartley-6-0-post:11.3
	hartley-6-0-pre:11.2
	rel-6-0-1:11.2
	rel-6-0:11.2
	rel-5-4:11.1
	offsite-5-3-pre:11.1
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1;
locks; strict;
comment	@ * @;


11.7
date	2004.05.21.13.50.00;	author morrison;	state dead;
branches;
next	11.6;

11.6
date	2004.05.10.15.30.51;	author erikg;	state Exp;
branches;
next	11.5;

11.5
date	2004.04.05.05.46.03;	author morrison;	state Exp;
branches;
next	11.4;

11.4
date	2002.08.20.17.09.12;	author jra;	state Exp;
branches
	11.4.2.1;
next	11.3;

11.3
date	2002.08.15.20.56.23;	author hartley;	state Exp;
branches;
next	11.2;

11.2
date	2001.08.10.18.36.57;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.18.28;	author mike;	state Rel4_4;
branches;
next	10.5;

10.5
date	94.11.14.23.20.42;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.10.28.03.01.47;	author butler;	state Exp;
branches;
next	10.3;

10.3
date	94.08.23.19.49.40;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	93.10.26.03.09.59;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.50.26;	author mike;	state Rel4_0;
branches;
next	9.2;

9.2
date	91.07.19.01.31.53;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.13.54;	author mike;	state Rel3_5;
branches;
next	8.1;

8.1
date	88.10.05.00.52.45;	author mike;	state Rel3_0;
branches;
next	1.9;

1.9
date	88.08.10.19.53.30;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	88.06.24.05.41.15;	author phil;	state Exp;
branches;
next	1.7;

1.7
date	88.05.15.23.51.11;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	88.05.07.04.22.58;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	88.01.27.03.13.14;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	88.01.09.03.51.56;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	88.01.07.04.54.37;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	88.01.06.07.29.38;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	88.01.05.20.18.12;	author mike;	state Exp;
branches;
next	;

11.4.2.1
date	2002.09.19.18.02.52;	author morrison;	state Exp;
branches;
next	;


desc
@Lyon Lamb VAS IV
@


11.7
log
@moved to src/vas4/
@
text
@/*
 *			V A S _ I O . C
 *
 *  I/O routines to talk to a Lyon-Lamb VAS IV video animation controller.
 *
 *
 *  Authors -
 *	Steve Satterfield, USNA
 *	Joe Johnson, USNA
 *	Michael John Muuss, BRL
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimitied.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/vas4/vas_io.c,v 11.6 2004/05/10 15:30:51 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#if HAVE_UNISTD_H
#include <unistd.h>
#endif

#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>

#if defined(HAVE_XOPEN)
#  undef SYSV
#  undef BSD
#  include <termios.h>

static struct termios	vtty;

#if defined(__bsdi__)
#	include <sys/ioctl_compat.h>
#	define TAB3 (TAB1|TAB2)
#	define OCRNL   0000010
#endif

#else	/* !defined(HAVE_XOPEN) */

#ifdef SYSV
#  include <termio.h>
struct termio vtty;
#endif
#ifdef BSD
#  include <sgtty.h>
struct sgttyb vtty;
#endif

#endif /* _POSIX_SOURCE */

#include "./vas4.h"

#define VAS_PORT	"/dev/vas"
#define BAUD		B300

void	vas_response(char c);

int vas_fd;
extern int debug;

/*
 * vas_open - attach to the VAS serial line
 *
 *	return a file descriptor of NULL on error
 */
void
vas_open(void)
{

	/* Open VAS Port */
	if((vas_fd=open(VAS_PORT,O_RDWR)) < 0){
		perror(VAS_PORT);
		exit(1);
	}

	/* Setup VAS line */
#ifdef BSD
	vtty.sg_ispeed = BAUD;
	vtty.sg_ospeed = BAUD;
	vtty.sg_flags = RAW|EVENP|ODDP;
	ioctl(vas_fd,TIOCSETP,&vtty);
	ioctl(vas_fd,TIOCEXCL,&vtty);	/* exclusive use */
#endif
#ifdef SYSV
	vtty.c_cflag = BAUD | CS8;      /* Character size = 8 bits */
	vtty.c_cflag &= ~CSTOPB;         /* One stop bit */
	vtty.c_cflag |= CREAD;           /* Enable the reader */
	vtty.c_cflag &= ~PARENB;         /* Parity disable */
	vtty.c_cflag &= ~HUPCL;          /* No hangup on close */
	vtty.c_cflag |= CLOCAL;          /* Line has no modem control */
 
	vtty.c_iflag &= ~(BRKINT|ICRNL|INLCR|IXON|IXANY|IXOFF);
	vtty.c_iflag |= IGNBRK|IGNPAR;
 
	vtty.c_oflag &= ~(OPOST|ONLCR|OCRNL);    /* Turn off all post-processing */
	vtty.c_oflag |= TAB3;		/* output tab expansion ON */
	vtty.c_cc[VMIN] = 1;
	vtty.c_cc[VTIME] = 0;

	vtty.c_lflag &= ~ICANON;         /* Raw mode */
	vtty.c_lflag &= ~ISIG;           /* Signals OFF */
	vtty.c_lflag &= ~(ECHO|ECHOE|ECHOK);     /* Echo mode OFF */

	if( ioctl(vas_fd, TCSETA, &vtty) < 0 ) { 
		perror(VAS_PORT);
		exit(1);
	}

	/* Be certain the FNDELAY is off */
	if( fcntl(vas_fd, F_SETFL, 0) < 0 )  {
		perror(VAS_PORT);
		exit(2);
	}
#endif
#ifdef HAVE_XOPEN
	vtty.c_cflag = BAUD | CS8;      /* Character size = 8 bits */
	vtty.c_cflag &= ~CSTOPB;         /* One stop bit */
	vtty.c_cflag |= CREAD;           /* Enable the reader */
	vtty.c_cflag &= ~PARENB;         /* Parity disable */
	vtty.c_cflag &= ~HUPCL;          /* No hangup on close */
	vtty.c_cflag |= CLOCAL;          /* Line has no modem control */
 
	vtty.c_iflag &= ~(BRKINT|ICRNL|INLCR|IXON|IXANY|IXOFF);
	vtty.c_iflag |= IGNBRK|IGNPAR;
 
	vtty.c_oflag &= ~(OPOST|ONLCR|OCRNL);    /* Turn off all post-processing */
	vtty.c_oflag |= TAB3;		/* output tab expansion ON */
	vtty.c_cc[VMIN] = 1;
	vtty.c_cc[VTIME] = 0;

	vtty.c_lflag &= ~ICANON;         /* Raw mode */
	vtty.c_lflag &= ~ISIG;           /* Signals OFF */
	vtty.c_lflag &= ~(ECHO|ECHOE|ECHOK);     /* Echo mode OFF */

	if( tcsetattr( vas_fd, TCSAFLUSH, &vtty ) < 0 )  {
		perror(VAS_PORT);
		exit(1);
	}

	/* Be certain the FNDELAY is off */
	if( fcntl(vas_fd, F_SETFL, 0) < 0 )  {
		perror(VAS_PORT);
		exit(2);
	}
#endif
}

/*
 *			V A S _ R A W P U T C
 *
 *  Defeat the (typically desirable) ack/rexmit behavior of the
 *  vas_putc() routine.  Useful mostly for the 'V' (get_vtr_status)
 *  command, and the 'A' (send current activity) commands.
 */
int
vas_rawputc(char c)
{
	int	got;

	got = write(vas_fd, &c, 1);
	if (got != 1)  {
		perror("VAS Write");
		return(got);
		/* Error recovery?? */
	}
	if(debug) fprintf(stderr,"vas_rawputc 0%o '%c'\n",c,c);
	return(got);
}

/*
 *			V A S _ P U T C
 *
 *  Output the specified character to the VAS.
 *  Wait for a 006 (^F) ACK of this character, 
 *  or for an "activity state" character,
 *  else retransmit.
 */
int
vas_putc(char c)
{
	int	got;
	int	reply;
	int	count;

	for( count=0; count<20; count++ )  {
		got = write(vas_fd, &c, 1);
		if (got < 1)  {
			perror("VAS Write");
			return(got);
			/* Error recovery?? */
		}
		if(debug) fprintf(stderr,"vas_putc 0%o '%c'\n",c,c);

reread:
		reply=vas_getc();
		if( reply == 006 )
			return(got);		/* ACK */
		if( reply >= 0x60 && reply <= 0x78 )  {
			vas_response(reply);
			return(got);
		}
		if( reply == 007 )  {
			if(count>4) fprintf(stderr, "retry\n");
			sleep(1);
			continue;		/* NACK, please repeat */
		}
		fprintf(stderr,"vas4:  non-ACK rcvd for cmd %c\n",c);
		vas_response(reply);
		goto reread;		/* See if ACK is buffered up */
	}
	fprintf(stderr,"vas4:  unable to perform cmd %c after retries\n", c);
	return(-1);
}

/*
 *			V A S _ P U T S
 *
 *  Output a null terminated string to the VAS.
 */
void
vas_puts(char *s)
{
	while (*s != '\0' ) {
		vas_putc(*s++);
	}
}

/*
 *			V A S _ P U T N U M
 *
 *  Output a number in decimal to the VAS.
 */
void
vas_putnum(int n)
{
	char	buf[32];

	sprintf(buf,"%d",n);
	vas_puts(buf);
}


/*
 *			V A S _ G E T C
 *
 * Read a single character from the VAS, return EOF on error
 */
int
vas_getc(void)
{
	char c;

	if (read(vas_fd, &c, 1) > 0)  {
		if(debug)fprintf(stderr,"vas_getc: 0%o %c\n", c&0377, c&0377);
		return(c & 0377);
	}  else
		return(EOF);
}

/*
 *			V A S _ C L O S E
 */
void
vas_close(void)
{
	close(vas_fd);
	vas_fd = -1;
}

/*
 *			V A S _ A W A I T
 *
 *  Slurp up input characters, until designated one comes along.
 *  If too much time has been spent waiting, we should consider
 *  some way of bailing out.  Error recovery needs more attention.
 *
 *  Returns -
 *	0	all is well
 *	-1	failure
 */
int
vas_await(int c, int sec)
{
	int	reply;
	int	count;

	for(count=0; count<20; count++)  {
		reply = vas_getc();
		if(debug) vas_response(reply);
		if( reply == c )  return(0);	/* OK */
		if(!debug) vas_response(reply);
	}
	return(-1);			/* BAD:  too many bad chars */
}

/*
 *			V A S _ R E S P O N S E
 *
 *  Attempt to interpret a reply as something sensible.
 *  This may not work in all cases (such as a multi-character response),
 *  but certainly beats looking at single-character codes.
 */
void
vas_response(char c)
{
	fprintf(stderr,"---Got 0%o '%c' ", c, c);
	switch(c)  {
	case 6:
		fprintf(stderr,"last command accepted\n");
		break;
	case 7:
		fprintf(stderr,"***Command ignored at current activity level\n");
		break;
	case 'I':
		fprintf(stderr,"Initialized.  Controller is ready for operation\n");
		break;
	case 'P':
		fprintf(stderr,"Program cmd accepted\n");
		break;
	case 'F':
		fprintf(stderr,"Frame rate cmd accepted\n");
		break;
	case 'E':
		fprintf(stderr,"Update cmd accepted\n");
		break;
	case 'U':
		fprintf(stderr,"Update cmd accepted\n");
		break;
	case 'S':
		fprintf(stderr,"Search command accepted, ready for E/E\n");
		break;
	case 'W':
		fprintf(stderr,"After E/E, search began, scene is not correct\n");
		break;
	case 'B':
		fprintf(stderr,"After E/E, search began, frame code lost while checking scene\n");
		break;
	case 'N':
		fprintf(stderr,"After E/E, search for frame fails (preceding frame not found)\n");
		break;
	case 'R':
		fprintf(stderr,"Ready to accept Record command\n");
		break;
	case 'M':
		fprintf(stderr,"Preroll fails after Record cmd, backspace for retry begins\n");
		break;
	case 'X':
		fprintf(stderr,"Notice:  2 frames before cut-in\n");
		break;
	case 'Y':
		fprintf(stderr,"Notice:  2 frames before cut-out\n");
		break;
	case 'D':
		fprintf(stderr,"Recording done, starting backspacing for next preroll\n");
		break;
	case 'J':
		fprintf(stderr,"Jaunt:  standby timeout;  tape moving back to Title\n");
		break;
	case 'T':
		fprintf(stderr,"Trash:  recording interrupted by STOP\n");
		break;
	case 'Q':
		fprintf(stderr,"Quit:  Ending EDIT mode\n");
		break;
	case 'L':
		fprintf(stderr,"Located sought frame\n");
		break;
	case 'K':
		fprintf(stderr,"Knave:  Search-for-frame failed\n");
		break;

	/**** Current activity states ****/
	/**** These are all suspect, as they don't match the BRL manual ***/
	case '`':
		fprintf(stderr,"Idling:  Power-on condition or newly initialized\n");
		break;
	case 'a':
		fprintf(stderr,"Register function is active\n");
		break;
	case 'b':
		fprintf(stderr,"Accepting programming for a recording\n");
		break;
	case 'c':
		fprintf(stderr,"Accepting programming for an edit recording\n");
		break;
	case 'd':
		fprintf(stderr,"Flashing E/E switch; ready to search for frame\n");
		break;
	case 'e':
		fprintf(stderr,"Checking for position on correct scene\n");
		break;
	case 'f':
		fprintf(stderr,"Ready to record next recording or TITLE\n");
		break;
	case 'g':
		fprintf(stderr,"Prerolling, about to make recording\n");
		break;
	case 'h':
		fprintf(stderr,"Recording in progress\n");
		break;
	case 'i':
		fprintf(stderr,"Backspacing for next preroll and recording\n");
		break;
	case 'j':
		fprintf(stderr,"Searching for frame preceding next to record\n");
		break;
	case 'k':
		fprintf(stderr,"Accepting programming for Frame Change\n");
		break;
	case 'l':
		fprintf(stderr,"Accepting programming for HOLD\n");
		break;
	case 'm':
		fprintf(stderr,"Displaying a warning message\n");
		break;
	case 'n':
		fprintf(stderr,"Ready to record first recording on old scene\n");
		break;
	case 'o':
		fprintf(stderr,"Holding momentarily before allowing to RECORD\n");
		break;

	default:
		fprintf(stderr,"???unknown???\n");
		break;
	}
}
@


11.6
log
@change conf.h to a wrapped config.h
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/vas4/vas_io.c,v 11.5 2004/04/05 05:46:03 morrison Exp $ (BRL)";
@


11.5
log
@merge of ansi-6-0-branch into head
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d24 5
a28 1
#include "conf.h"
@


11.4
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vas4/vas_io.c,v 11.2 2001/08/10 18:36:57 jra Exp $ (BRL)";
d65 1
a65 1
void	vas_response();
d76 1
a76 1
vas_open()
d165 1
a165 2
vas_rawputc(c)
char c;
d188 1
a188 2
vas_putc(c)
char c;
d230 1
a230 2
vas_puts(s)
char *s;
d243 1
a243 2
vas_putnum(n)
int	n;
d258 1
a258 1
vas_getc()
d273 1
a273 1
vas_close()
d291 1
a291 3
vas_await(c, sec)
int	c;
int	sec;
d313 1
a313 2
vas_response(c)
char	c;
@


11.4.2.1
log
@Initial ANSIfication
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vas4/vas_io.c,v 11.4 2002/08/20 17:09:12 jra Exp $ (BRL)";
d65 1
a65 1
void	vas_response(char c);
d76 1
a76 1
vas_open(void)
d165 2
a166 1
vas_rawputc(char c)
d189 2
a190 1
vas_putc(char c)
d232 2
a233 1
vas_puts(char *s)
d246 2
a247 1
vas_putnum(int n)
d262 1
a262 1
vas_getc(void)
d277 1
a277 1
vas_close(void)
d295 3
a297 1
vas_await(int c, int sec)
d319 2
a320 1
vas_response(char c)
@


11.3
log
@Converted from K&R to ANSI C - RFH
@
text
@d65 1
a65 1
void	vas_response(char c);
d76 1
a76 1
vas_open(void)
d165 2
a166 1
vas_rawputc(char c)
d189 2
a190 1
vas_putc(char c)
d232 2
a233 1
vas_puts(char *s)
d246 2
a247 1
vas_putnum(int n)
d262 1
a262 1
vas_getc(void)
d277 1
a277 1
vas_close(void)
d295 3
a297 1
vas_await(int c, int sec)
d319 2
a320 1
vas_response(char c)
@


11.2
log
@lint
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vas4/vas_io.c,v 11.1 1995/01/04 10:18:28 mike Rel4_4 $ (BRL)";
d65 1
a65 1
void	vas_response();
d76 1
a76 1
vas_open()
d165 1
a165 2
vas_rawputc(c)
char c;
d188 1
a188 2
vas_putc(c)
char c;
d230 1
a230 2
vas_puts(s)
char *s;
d243 1
a243 2
vas_putnum(n)
int	n;
d258 1
a258 1
vas_getc()
d273 1
a273 1
vas_close()
d291 1
a291 3
vas_await(c, sec)
int	c;
int	sec;
d313 1
a313 2
vas_response(c)
char	c;
@


11.1
log
@Release_4.4
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vas4/RCS/vas_io.c,v 10.5 94/11/14 23:20:42 mike Exp $ (BRL)";
d26 5
@


10.5
log
@Irix 6
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vas4/RCS/vas_io.c,v 10.4 94/10/28 03:01:47 butler Exp Locker: mike $ (BRL)";
@


10.4
log
@bsdi patches
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vas4/RCS/vas_io.c,v 10.3 1994/08/23 19:49:40 gdurf Exp butler $ (BRL)";
d99 1
a99 1
	vtty.c_oflag &= ~(OPOST|ONLCR|OCRNL);    /* Turn off all post-processin!
d130 1
a130 1
	vtty.c_oflag &= ~(OPOST|ONLCR|OCRNL);    /* Turn off all post-processin!
@


10.3
log
@Factored ifdefs
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vas4/RCS/vas_io.c,v 10.2 1993/10/26 03:09:59 mike Exp gdurf $ (BRL)";
d35 6
@


10.2
log
@POSIX
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vas4/RCS/vas_io.c,v 10.1 91/10/12 06:50:26 mike Rel4_0 Locker: mike $ (BRL)";
d24 2
d29 1
a29 4
#if defined(_POSIX_SOURCE)
#  if !defined(_XOPEN_SOURCE)
#	define _XOPEN_SOURCE 1	/* to get TAB3, etc */
#  endif
d36 1
a36 1
#else	/* !defined(_POSIX_SOURCE) */
d113 1
a113 1
#ifdef _POSIX_SOURCE
@


10.1
log
@Release_4.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vas4/RCS/vas_io.c,v 9.2 91/07/19 01:31:53 mike Exp $ (BRL)";
a24 1
#ifdef SYSV
a25 4
#include <termio.h>
#else
#include <sgtty.h>
#endif
d27 12
a38 1
#define RW 2
d40 1
d42 3
a44 1
#else
d48 2
d70 1
a70 1
	if((vas_fd=open(VAS_PORT,RW)) < 0){
d104 31
@


9.2
log
@Can't use NULL for '\0'
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vas4/RCS/vas_io.c,v 9.1 89/05/19 06:13:54 mike Rel3_5 $ (BRL)";
@


9.1
log
@Release_3.5
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: vas_io.c,v 8.1 88/10/05 00:52:45 mike Rel3_0 $ (BRL)";
d183 1
a183 1
	while (*s != NULL ) {
@


8.1
log
@Release_3.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: vas_io.c,v 1.9 88/08/10 19:53:30 mike Exp $ (BRL)";
@


1.9
log
@This version actually works on both the SGI 3D and 4D
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: vas_io.c,v 1.8 88/06/24 05:41:15 phil Exp $ (BRL)";
@


1.8
log
@Added SYSV case for the SGI 3D
Its crufty in its present form, but it works.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: vas_io.c,v 1.7 88/05/15 23:51:11 phil Locked $ (BRL)";
a72 1
	ioctl( vas_fd, TCGETA, &vtty );
a81 1
	vtty.c_iflag |= ISTRIP;
d83 2
a84 2
	/*vtty.c_oflag &= ~(OPOST|ONLCR|OCRNL);    /* Turn off all post-processin!
	vtty.c_oflag = 0;
a90 1
	vtty.c_lflag = NOFLSH;              /* no processing */
@


1.7
log
@lint fixes
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: vas_io.c,v 1.6 88/05/07 04:22:58 mike Locked $ (BRL)";
d25 4
d30 1
d33 5
a37 1
struct sgttyb user, vtty;
d65 1
d71 35
@


1.6
log
@Changed to use perror
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: vas_io.c,v 1.5 88/01/27 03:13:14 mike Locked $ (BRL)";
d35 2
d45 1
a45 1

d70 1
d83 1
a83 1

d94 1
d137 1
d151 1
d167 1
d182 1
d200 1
d224 1
@


1.5
log
@Added missing return statement.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: vas_io.c,v 1.4 88/01/09 03:51:56 mike Locked $ (BRL)";
d49 1
a49 3
		fprintf(stderr,"Can not open VAS port");
		fprintf(stderr,VAS_PORT);
		fprintf(stderr,"\n");
d56 1
a56 1
	vtty.sg_flags = RAW+EVENP+ODDP;
@


1.4
log
@Improved robustness of vas_putc() routine, especially in the
face of getting NAK indications.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: vas4.c,v 1.5 88/01/08 17:05:58 mike Locked $ (BRL)";
d127 1
@


1.3
log
@Added debug on input as well.
@
text
@d2 17
a18 1
 * vas_io.c - I/O routines to talk to the VAS IV
d20 3
a23 1

d36 1
a36 1
int debug = TRUE;
d98 1
d100 8
a107 8
retry:
	got = write(vas_fd, &c, 1);
	if (got != 1)  {
		perror("VAS Write");
		return(got);
		/* Error recovery?? */
	}
	if(debug) fprintf(stderr,"vas_putc 0%o '%c'\n",c,c);
d109 14
a122 4
	reply=vas_getc();
	if( reply == 006 )
		return(got);
	if( reply >= 0x60 && reply <= 0x78 )  {
d124 1
a124 1
		return(got);
d126 1
a126 4
	fprintf(stderr,"VAS -- no ACK rcvd!!\n");
	vas_response(reply);
	sleep(1);
	goto retry;
d157 5
a161 2
/* Read a single character from the VAS, return EOF on error */

d173 3
a175 1

a181 1

a182 29
   vas_putc_wait - Like putc, but also wait for a specified response

   send		- the character to send to VAS
   expect 	- is the character expected
 *
 *  This routine has the dubious property that it will continue to
 *  reissue the command character until it hears the response
 *  character.  Considering the large number of "asynchronous"
 *  replies of an advisory nature, this seems unwise.
 */
vas_putc_wait(send, expect)
char send, expect;
{
	char c;

	vas_putc(send);

	while (1) {
		if (debug) {
			fprintf(stderr,"Sent '%c', Expect '%c'\n",send,expect);
		}
		c = vas_getc();
		if (debug)  vas_response(c);
		if (c == expect)
			break;
	}
}

/*
d204 1
@


1.2
log
@Updated for use at BRL
@
text
@d137 2
a138 1
	if (read(vas_fd, &c, 1) > 0)
d140 1
a140 1
	else
@


1.1
log
@Initial revision
@
text
@d12 1
a12 1
#include "vas4.h"
a19 3

/* #define DEBUG 1 /* Define to simulate VAS with stdio */

a28 2
#if DEBUG
#else
d30 1
a30 1
	if((vas_fd=open(VAS_PORT,RW)) == EOF){
a42 1
#endif
d45 11
d57 7
a63 1
/* Output the specified character to the VAS */
d65 10
d78 2
a79 1
	int n_written;
d81 8
a88 8
#ifdef DEBUG
	vas_fd = 1;
#endif
	n_written = write(vas_fd, &c, 1);
	if (n_written != 1)
		fprintf(stderr,"VAS write error\n");
fprintf(stderr,"<%c>",c);
	return(n_written);
d90 11
d103 5
a107 2
/* Output a string to the VAS. (The string must be NULL terminated) */

d116 9
d126 5
a136 4
#ifdef DEBUG
	vas_fd = 2;
#endif

a145 2
#ifdef DEBUG
#else
d147 1
a147 2
#endif

d156 6
a161 2
*/

a164 1

d171 1
a171 1
			fprintf(stderr,"Send '%c', Expect '%c' ",send,expect);
d174 1
a174 2
		if (debug)
			fprintf(stderr,"Got '%c'\n",c);
d180 17
d198 7
a204 1
#ifdef MAIN
d206 9
a214 1
main()
d216 65
a280 1
	int c;
d282 50
a331 1
	vas_puts("hello\n");
d333 4
a336 8
	vas_open();

	vas_putc('I');

	fprintf(stderr,"Waiting for VAS response\n");
	c = vas_getc();

	printf("octal: '%o'  char: '%c'\n",c,c);
a337 3
#endif

	
@
