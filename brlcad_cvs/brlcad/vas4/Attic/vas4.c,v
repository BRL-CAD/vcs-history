head	11.7;
access;
symbols
	ansi-20040405-merged:11.4.2.1
	postmerge-20040405-ansi:11.5
	premerge-20040404-ansi:11.4
	postmerge-autoconf:11.4
	autoconf-freeze:11.4
	premerge-autoconf:11.4
	postmerge-20040315-windows:11.4
	premerge-20040315-windows:11.4
	windows-20040315-freeze:11.4
	autoconf-20031203:11.4
	autoconf-20031202:11.4
	autoconf-branch:11.4.0.10
	phong-branch:11.4.0.8
	photonmap-branch:11.4.0.6
	rel-6-1-DP:11.4
	windows-branch:11.4.0.4
	rel-6-0-2:11.2
	ansi-branch:11.4.0.2
	rel-6-0-1-branch:11.2.0.2
	hartley-6-0-post:11.3
	hartley-6-0-pre:11.2
	rel-6-0-1:11.2
	rel-6-0:11.2
	rel-5-4:11.1
	offsite-5-3-pre:11.1
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1;
locks; strict;
comment	@ * @;


11.7
date	2004.05.21.13.50.00;	author morrison;	state dead;
branches;
next	11.6;

11.6
date	2004.05.10.15.30.51;	author erikg;	state Exp;
branches;
next	11.5;

11.5
date	2004.04.05.05.46.03;	author morrison;	state Exp;
branches;
next	11.4;

11.4
date	2002.08.20.17.09.12;	author jra;	state Exp;
branches
	11.4.2.1;
next	11.3;

11.3
date	2002.08.15.20.56.23;	author hartley;	state Exp;
branches;
next	11.2;

11.2
date	2001.08.10.18.36.57;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.18.27;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.11.14.23.19.43;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.23.19.49.50;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.50.24;	author mike;	state Rel4_0;
branches;
next	9.1;

9.1
date	89.05.19.06.13.51;	author mike;	state Rel3_5;
branches;
next	8.1;

8.1
date	88.10.05.00.52.42;	author mike;	state Rel3_0;
branches;
next	1.9;

1.9
date	88.08.11.03.14.14;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	88.05.15.23.51.03;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	88.01.27.03.10.40;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	88.01.09.03.50.44;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	88.01.08.17.05.58;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	88.01.07.04.53.38;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	88.01.07.01.37.02;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	88.01.06.07.29.34;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	88.01.05.20.18.05;	author mike;	state Exp;
branches;
next	;

11.4.2.1
date	2002.09.19.18.02.52;	author morrison;	state Exp;
branches;
next	;


desc
@Lyon Lamb VAS IV
@


11.7
log
@moved to src/vas4/
@
text
@/*
 *			V A S 4 . C
 *
 *  Program to control the Lyon-Lamb VAS IV video animation controller
 *  with Sony BVU-850 recorder (or equiv).
 *
 *
 *  Authors -
 *	Steve Satterfield, USNA
 *	Joe Johnson, USNA
 *	Michael John Muuss, BRL
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimitied.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/vas4/vas4.c,v 11.6 2004/05/10 15:30:51 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>

#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"		/* For getopt */
#include "fb.h"
#include "./vas4.h"

int		debug;

static char	*framebuffer = NULL;
static int	scr_width = 0;		/* screen tracks file if not given */
static int	scr_height = 0;

void	usage(void), usage_new(void), usage_record(void), usage_seq(void);
void	program_recording(int new, int scene_number, int start_frame), record_add_to_scene(int number_of_frames), do_record(int wait);
void	get_tape_position(void);

/*
 *			G E T _ A R G S
 */
int
get_args(int argc, register char **argv)
{
	register int c;

	while ( (c = getopt( argc, argv, "dhF:s:S:w:W:n:N:" )) != EOF )  {
		switch( c )  {
		case 'd':
			debug = 1;
			break;

		case 'h':
			/* high-res */
			scr_height = scr_width = 1024;
			break;
		case 'F':
			framebuffer = optarg;
			break;
		case 'S':
		case 's':
			/* square file size */
			scr_height = scr_width = atoi(optarg);
			break;
		case 'w':
		case 'W':
			scr_width = atoi(optarg);
			break;
		case 'n':
		case 'N':
			scr_height = atoi(optarg);
			break;

		default:		/* '?' */
			return(0);
		}
	}

	if( optind >= argc )
		return(0);

	return(1);		/* OK */
}

/*
 *			M A I N
 */
int
main(int argc, char **argv)
{
	register FBIO	*fbp = FBIO_NULL;
	int scene_number = 1;
	int start_frame = 1;
	int number_of_frames=0;
	int number_of_images=0;
	int start_seq_number=0;
	int	exit_code;

	exit_code = 0;

	if ( !get_args( argc, argv ) )  {
		usage();
		exit( 1 );
	}

	argc -= (optind-1);
	argv += (optind-1);

	/*
	 *  First group of commands.
	 *  No checking of VAS IV status is performed first.
	 */
	if (strcmp(argv[1],"init") == 0) {
		vas_open();
		if( get_vas_status() < 0 )
			exit(1);
		vas_putc(C_INIT);
		vas_await(R_INIT, 5);
		if( get_vtr_status(0) < 0 )
			exit_code = 1;
		goto done;
	}
	else if (strcmp(argv[1],"status") == 0) {
		vas_open();
		(void)get_vas_status();
		(void)get_vtr_status(1);
		get_tape_position();
		(void)get_frame_code();
		goto done;
	}
	else if (strcmp(argv[1],"sequence") == 0) {
		if (argc == 2) {
			number_of_images = 1;
			number_of_frames = 1;
			start_seq_number = 1;
		}
		else if (argc == 4) {
			number_of_images = atoi(argv[2]);
			if (number_of_images < 1)
				usage_seq();
			number_of_frames = str2frames(argv[3]);
			if (number_of_frames < 1)
				usage_seq();
			start_seq_number = 1;
		}
		else if (argc == 5) {
			number_of_images = atoi(argv[2]);
			if (number_of_images < 1)
				usage_seq();
			number_of_frames = str2frames(argv[3]);
			if (number_of_frames < 1)
				usage_seq();
			start_seq_number = atoi(argv[4]);
		}
		else
			usage_seq();


		record_seq(number_of_images, number_of_frames, start_seq_number);
		goto done;
	}

	/*
	 *  Second group of commands.
	 *  VAS IV is opened, and status of VAS is checked first
	 *  but VTR is not queried.
	 */
	vas_open();
	if( get_vas_status() < 0 )
		exit(1);

	if (strcmp(argv[1],"rewind") == 0) {
		vas_putc(C_REWIND);
		goto done;
	}
	else if (strcmp(argv[1],"play") == 0) {
		vas_putc(C_PLAY);
		goto done;
	}
	else if (strcmp(argv[1],"stop") == 0) {
		vas_putc(C_STOP);
		goto done;
	}
	else if (strcmp(argv[1],"fforward") == 0) {
		vas_putc(C_FFORWARD);
		goto done;
	}

	/*
	 *  Third group of commands.
	 *  VAS IV is opened and checked above,
	 *  and VTR status is checked here.
	 */
	if( get_vtr_status(0) < 0 )  {
		exit_code = 1;
		goto done;
	}
	if( strcmp(argv[1], "search") == 0 )  {
		if( argc >= 3 )
			start_frame = str2frames(argv[2]);
		else
			start_frame = 1;
		exit_code = search_frame(start_frame);
		goto done;
	}
	else if( strcmp(argv[1], "time0") == 0 )  {
		exit_code = time0();
		goto done;
	}
	else if( strcmp( argv[1], "reset_time" ) == 0 )  {
		exit_code = reset_tape_time();
		goto done;
	}

	/*
	 *  If this is running on a workstation, and a window has to be
	 *  opened to cause image to be re-displayed, do so now.
	 */
	if( framebuffer != (char *)0 )  {
		if( (fbp = fb_open( framebuffer, scr_width, scr_height )) == FBIO_NULL )  {
			exit_code = 12;
			goto done;
		}
	}

	/*
	 *  Commands that will actually record some image onto tape
	 */
	if (strcmp(argv[1], "new") == 0) {
		if( argc >= 4 )  {
			if( (start_frame = str2frames(argv[3])) < 1 )
				usage_new();
		}
		if (argc >= 3) {
			if( (scene_number = atoi(argv[2])) < 1 )
				usage_new();
		}
		else if (argc == 2) {
			scene_number = 1;
		}
		else {
			usage_new();
		}
		program_recording(1, scene_number, start_frame);
		goto done;
	}
	else if (strcmp(argv[1], "old") == 0) {
		if( argc >= 4 )  {
			if( (start_frame = str2frames(argv[3])) < 1 )
				usage_new();
		}
		if (argc >= 3) {
			if( (scene_number = atoi(argv[2])) < 1 )
				usage_new();
		}
		else if (argc == 2) {
			scene_number = 1;
		}
		else {
			usage_new();
		}
		/* May need one more parameter here, eventually */
		program_recording(0, scene_number, start_frame);
		goto done;
	}
	else if (strcmp(argv[1],"record") == 0) {
		if (argc == 3) {
			number_of_frames = str2frames(argv[2]);
			if (number_of_frames < 1) {
				usage_record();
			}
		}
		else if (argc == 2) {
			number_of_frames = 1;
		}
		else {
			usage_record();
		}
		record_add_to_scene(number_of_frames);
		goto done;
	} else {
		/* None of the above */
		usage();
		exit_code = 1;
	}

done:
	vas_close();
	if(fbp) fb_close(fbp);
	exit(exit_code);
}

void
usage(void)
{
	fprintf(stderr,"Usage: vas4 [-d] [-h] [-F framebuffer]\n");
	fprintf(stderr,"	[-{sS} squarescrsize] [-{wW} scr_width] [-{nN} scr_height]\n");
	fprintf(stderr,"	keyword [options]\n");
	fprintf(stderr,"Keywords:\n");
	fprintf(stderr,"  init\n");
	fprintf(stderr,"  status\n");
	fprintf(stderr,"  stop\n");
	fprintf(stderr,"  play\n");
	fprintf(stderr,"  rewind\n");
	fprintf(stderr,"  fforward\n");
	fprintf(stderr,"  new [scene_number [start_frame]]\n");
	fprintf(stderr,"  old [scene_number [start_frame]]\n");
	fprintf(stderr,"  record [n_frames]\n");
	fprintf(stderr,"  sequence [n_images n_frames [start_seq]]\n");
	fprintf(stderr,"  search [frame]\n");
	fprintf(stderr,"  time0\n");
	fprintf(stderr,"  reset_time\n");
	exit(1);
}

void
usage_new(void)
{
	fprintf(stderr,"Usage: vas4 new [sn]\n");
	fprintf(stderr,"\t[sn]\tscene number must be >= 1\n");
	exit(1);
}

void
usage_record(void)
{
	fprintf(stderr,"Usage: vas4 record [nf]\n");
	fprintf(stderr,"\t[nf]\tnumber of frames must be >= 1\n");
	exit(1);
}

void
usage_seq(void)
{
	fprintf(stderr,"Usage: vas4 sequence [n nf] [start]\n");
	fprintf(stderr,"\t[n nf]\tthe number of images n must be > 1\n");
	fprintf(stderr,"\t\tand the number of frames nf  must be > 1\n");
	fprintf(stderr,"\t[start] is the starting sequence number\n");
	fprintf(stderr,"\t\tIf start is specified, n and nf must also be specified\n");
	exit(1);
}


/*
 *			P R O G R A M _ R E C O R D I N G
 */
void
program_recording(int new, int scene_number, int start_frame)
{
	int number_of_frames = 1;

	/* Enter VAS IV program mode */	
	vas_putc(C_PROGRAM);
	vas_await(R_PROGRAM, 0);

	vas_putnum(number_of_frames);
	vas_putc(C_ENTER);

	vas_putnum(scene_number);
	vas_putc(C_ENTER);

	/* New or Old scene */
	if( new )  {
		vas_putnum(1);
		vas_putc(C_ENTER);

		vas_putnum(start_frame);
		vas_putc(C_ENTER);
	} else {
		vas_putnum(0);
		vas_putc(C_ENTER);

		vas_putnum(start_frame);	/* First frame */
		vas_putc(C_ENTER);

		/* I believe this is used only to initiate a search */
		vas_putnum(start_frame);	/* Last recorded frame */
		vas_putc(C_ENTER);
	}
	vas_await(R_SEARCH, 120);

	/* E/E light should now be flashing, Press E/E */
	vas_putc(C_EE);
	vas_await(R_RECORD, 30);

	/* New scene only records 4 sec matte */
	if( new )  {
		fprintf(stderr,"Recording built-in title matte\n");
		do_record(1);
	}
}

/*
 *			R E C O R D _ A D D _ T O _ S C E N E
 */
void
record_add_to_scene(int number_of_frames)
{
	vas_putc(C_FRAME_CHANGE);
	vas_putnum(number_of_frames);
	vas_putc(C_ENTER);

	fprintf(stderr,"Recording %d frames, %g seconds\n",
		number_of_frames, (double)number_of_frames/30.);
	do_record(0);
}

/*
 *			D O _ R E C O R D
 *
 *  Handle the actual mechanics of starting a record operation,
 *  given that everything has been set up.
 *  If tape-head-unload timer has gone off, also handle retry
 *  operations, until frames are actually recorded.
 *
 *  NOTE:  at the present time, use of no-wait operation
 *  may result in deadlocks, if a subsequent invocation of
 *  this program is started before the backup operation has finished,
 *  because that will result in an unsolicited 'R' (ready for Record)
 *  command.  get_vtr_status() could be extended or supplemented
 *  so that most commands would wait until the VTR stops moving,
 *  but this added complexity is unwelcome.  Therefore, even though
 *  this feature is "implemented", it may cause problems.
 *  So far, this has not proven to be troublesome, but nearly all
 *  experience so far has been with frame-load time much greater than
 *  the tape backspace time.
 */
void
do_record(int wait)
{
	register int c;

	vas_putc(C_RECORD);
	for(;;)  {
		c = vas_getc();
		if(debug) vas_response(c);
		switch( c )  {
		case R_RECORD:
			/* Completely done, ready to record next frame */
			break;
		case R_DONE:
			if( wait )  {
				continue;
			} else {
				/* Don't wait for tape backspacing */
				break;
			}
		case R_MISSED:
			/*
			 * Preroll failed (typ. due to timer),
			 * VAS is backspacing for retry, wait for GO.
			 */
			vas_await(R_RECORD,99);
			vas_putc(C_RECORD);
			continue;
		case R_CUT_IN:
		case R_CUT_OUT:
			/* These are for info only */
			continue;
		default:
			if(!debug) vas_response(c);
			continue;
		}
		break;
	}
	return;
}

/*
 *			S E A R C H _ F R A M E
 *
 *  It is unclear what modes this is safe in
 */
int
search_frame(int frame)
{
	int	reply;

	vas_putc(C_SEARCH);
	vas_putnum(frame);
	vas_putc(C_ENTER);
	reply = vas_getc();
	if( reply == 'L' )
		return(0);	/* OK */
	/* 'K' is expected failure code */
	vas_response(reply);
	return(-1);		/* fail */
}

/*
 *			R E S E T _ T A P E _ T I M E
 * 
 *  Reset tape time to 00:00:00:00
 *
 *  This is only safe when the tape is playing or not moving.
 */
int
reset_tape_time(void)
{
	vas_putc(C_RESET_TAPETIME);
	return(0);
}

/*
 *			T I M E 0
 * 
 *  Seek to time timer value 00:00:00:00, as set by ?INIT? or
 *  reset_tape_time(), above.
 *
 *  It is unclear what modes this is safe in
 */
int
time0(void)
{
	int	reply;

	vas_putc(C_SEARCH);
	vas_putc(C_SEARCH);
	reply = vas_getc();
	if( reply == 'L' )
		return(0);	/* OK */
	vas_response(reply);
	return(-1);		/* fail */
}

/*
 *			G E T _ V A S _ S T A T U S
 *
 *  Returns -
 *	-1	VAS is unwell
 *	>0	VAS is ready, value is return code
 */
int
get_vas_status(void)
{
	int	reply;

	vas_rawputc(C_ACTIVITY);
	reply = vas_getc();		/* Needs timeout */
	if(debug) vas_response(reply);
	if( reply < 0x60 || reply > 0x78 )  return(-1);
	return(reply);
}

/*
 *			G E T _ V T R _ S T A T U S
 *
 *  If 'chatter' is 0, only errors are logged to stderr,
 *  otherwise all conditions are logged.
 *
 *  Returns -
 *	1	all is well, VTR is ready to roll
 *	0	all is well
 *	-1	problems (with description)
 */
int
get_vtr_status(int chatter)
{
	char	buf[4];

	vas_rawputc(C_VTR_STATUS);
	buf[0] = vas_getc();
	buf[1] = vas_getc();
	buf[2] = vas_getc();
	buf[3] = vas_getc();

	if( buf[0] != 'V' )  {
		fprintf(stderr,"Link to VTR is not working\n");
		return(-1);
	}
	if( buf[1] != 'R' )  {
		if( buf[1] == 'L' )  {
			fprintf(stderr,"VTR is in Local mode, can not be program controlled\n");
			return(-1);
		}
		fprintf(stderr, "VTR is in unknown mode\n");
		return(-1);
	}
	if( buf[2] == 'R' )  {
		if(chatter) fprintf(stderr,"VTR is online and ready to roll\n");
		return(1);	/* very OK */
	} else if(  buf[2] == 'N' )  {
		if(chatter) fprintf(stderr,"VTR is online and stopped\n");
		return(0);	/* OK */
	} else {
		fprintf(stderr,"VTR is online and has unknown ready status\n");
		return(-1);
	}
	/* [3] is S for stop, P for play, 
	 *   L for shuttle var speed, W for slow speed */
}

int
get_frame_code(void)
{
	int	status;
	char	scene[4];
	char	frame[7];

	vas_rawputc(C_SEND_FRAME_CODE);
	status = vas_getc();
	scene[0] = vas_getc();
	scene[1] = vas_getc();
	scene[2] = vas_getc();
	scene[3] = '\0';
	frame[0] = vas_getc();
	frame[1] = vas_getc();
	frame[2] = vas_getc();
	frame[3] = vas_getc();
	frame[4] = vas_getc();
	frame[5] = vas_getc();
	frame[6] = '\0';
	if( status != 'C' && status != '<' )  {
		fprintf(stderr,"get_frame_code:  unable to acquire\n");
		return(-1);
	}
	fprintf(stderr,"Scene %s, Frame %s\n", scene, frame);
	/* May want to do something more here */
	return(0);
}

void
get_tape_position(void)
{
	char	buf[9];
	int	i;

	vas_rawputc(C_SEND_TAPE_POS);
	for( i=0; i<8; i++ )
		buf[i] = vas_getc();
	buf[8] = '\0';
	fprintf(stderr, "Tape counter is at %s\n", buf);
	/* May want to do more here */
}

/*
 *			S T R 2 F R A M E S
 *
 *  Given a numeric string, convert it to frames.
 *  The input is expected to be a number followed by letters,
 *  which will apply a multiplier, eg
 *	10	10 frames
 *	12f	12 frames
 *	3s	3 seconds (90 frames)
 *	1m	1 minute (1800 frames)
 *
 *  Excess characters in the string are ignored, so inputs of the form
 *  "32sec" and "3min" are fine.
 */
int
str2frames(char *str)
{
	int	num;
	char	suffix[32];

	suffix[0] = '\0';
	sscanf( str, "%d%s", &num, suffix );
	switch( suffix[0] )  {
	case 'f':
	case '\0':
		break;
	case 's':
		num *= 30;
		break;
	case 'm':
		num *= 60 * 30;
		break;
	default:
		fprintf(stderr, "str2frames:  suffix '%s' unknown\n", str);
		break;
	}
	return(num);
}
@


11.6
log
@change conf.h to a wrapped config.h
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/vas4/vas4.c,v 11.5 2004/04/05 05:46:03 morrison Exp $ (BRL)";
@


11.5
log
@merge of ansi-6-0-branch into head
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d25 5
a29 1
#include "conf.h"
@


11.4
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vas4/vas4.c,v 11.2 2001/08/10 18:36:57 jra Exp $ (BRL)";
d46 3
a48 3
void	usage(), usage_new(), usage_record(), usage_seq();
void	program_recording(), record_add_to_scene(), do_record();
void	get_tape_position();
d54 1
a54 2
get_args( argc, argv )
register char **argv;
d100 1
a100 3
main(argc, argv)
int argc;
char **argv;
d305 1
a305 1
usage()
d328 1
a328 1
usage_new()
d336 1
a336 1
usage_record()
d344 1
a344 1
usage_seq()
d359 1
a359 4
program_recording(new, scene_number, start_frame)
int	new;
int	scene_number;
int	start_frame;
d365 1
a365 1
	vas_await(R_PROGRAM);
d408 1
a408 2
record_add_to_scene(number_of_frames)
int number_of_frames;
d440 1
a440 1
do_record(wait)
d486 1
a486 2
search_frame(frame)
int	frame;
d509 1
a509 1
reset_tape_time()
d524 1
a524 1
time0()
d545 1
a545 1
get_vas_status()
d568 1
a568 2
get_vtr_status(chatter)
int	chatter;
d605 1
a605 1
get_frame_code()
d634 1
a634 1
get_tape_position()
d662 1
a662 2
str2frames(str)
char	*str;
@


11.4.2.1
log
@Initial ANSIfication
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vas4/vas4.c,v 11.4 2002/08/20 17:09:12 jra Exp $ (BRL)";
d46 3
a48 3
void	usage(void), usage_new(void), usage_record(void), usage_seq(void);
void	program_recording(int new, int scene_number, int start_frame), record_add_to_scene(int number_of_frames), do_record(int wait);
void	get_tape_position(void);
d54 2
a55 1
get_args(int argc, register char **argv)
d101 3
a103 1
main(int argc, char **argv)
d308 1
a308 1
usage(void)
d331 1
a331 1
usage_new(void)
d339 1
a339 1
usage_record(void)
d347 1
a347 1
usage_seq(void)
d362 4
a365 1
program_recording(int new, int scene_number, int start_frame)
d371 1
a371 1
	vas_await(R_PROGRAM, 0);
d414 2
a415 1
record_add_to_scene(int number_of_frames)
d447 1
a447 1
do_record(int wait)
d493 2
a494 1
search_frame(int frame)
d517 1
a517 1
reset_tape_time(void)
d532 1
a532 1
time0(void)
d553 1
a553 1
get_vas_status(void)
d576 2
a577 1
get_vtr_status(int chatter)
d614 1
a614 1
get_frame_code(void)
d643 1
a643 1
get_tape_position(void)
d671 2
a672 1
str2frames(char *str)
@


11.3
log
@Converted from K&R to ANSI C - RFH
@
text
@d46 3
a48 3
void	usage(void), usage_new(void), usage_record(void), usage_seq(void);
void	program_recording(int new, int scene_number, int start_frame), record_add_to_scene(int number_of_frames), do_record(int wait);
void	get_tape_position(void);
d54 2
a55 1
get_args(int argc, register char **argv)
d101 3
a103 1
main(int argc, char **argv)
d308 1
a308 1
usage(void)
d331 1
a331 1
usage_new(void)
d339 1
a339 1
usage_record(void)
d347 1
a347 1
usage_seq(void)
d362 4
a365 1
program_recording(int new, int scene_number, int start_frame)
d371 1
a371 1
	vas_await(R_PROGRAM, 0);
d414 2
a415 1
record_add_to_scene(int number_of_frames)
d447 1
a447 1
do_record(int wait)
d493 2
a494 1
search_frame(int frame)
d517 1
a517 1
reset_tape_time(void)
d532 1
a532 1
time0(void)
d553 1
a553 1
get_vas_status(void)
d576 2
a577 1
get_vtr_status(int chatter)
d614 1
a614 1
get_frame_code(void)
d643 1
a643 1
get_tape_position(void)
d671 2
a672 1
str2frames(char *str)
@


11.2
log
@lint
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vas4/vas4.c,v 11.1 1995/01/04 10:18:27 mike Rel4_4 $ (BRL)";
d46 3
a48 3
void	usage(), usage_new(), usage_record(), usage_seq();
void	program_recording(), record_add_to_scene(), do_record();
void	get_tape_position();
d54 1
a54 2
get_args( argc, argv )
register char **argv;
d100 1
a100 3
main(argc, argv)
int argc;
char **argv;
d305 1
a305 1
usage()
d328 1
a328 1
usage_new()
d336 1
a336 1
usage_record()
d344 1
a344 1
usage_seq()
d359 1
a359 4
program_recording(new, scene_number, start_frame)
int	new;
int	scene_number;
int	start_frame;
d365 1
a365 1
	vas_await(R_PROGRAM);
d408 1
a408 2
record_add_to_scene(number_of_frames)
int number_of_frames;
d440 1
a440 1
do_record(wait)
d486 1
a486 2
search_frame(frame)
int	frame;
d509 1
a509 1
reset_tape_time()
d524 1
a524 1
time0()
d545 1
a545 1
get_vas_status()
d568 1
a568 2
get_vtr_status(chatter)
int	chatter;
d605 1
a605 1
get_frame_code()
d634 1
a634 1
get_tape_position()
d662 1
a662 2
str2frames(str)
char	*str;
@


11.1
log
@Release_4.4
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/vas4/RCS/vas4.c,v 10.3 94/11/14 23:19:43 mike Exp $ (BRL)";
d29 6
d53 1
d100 1
d108 3
a110 3
	int number_of_frames;
	int number_of_images;
	int start_seq_number;
@


10.3
log
@Irix 6
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/vas4/RCS/vas4.c,v 10.2 94/08/23 19:49:50 gdurf Exp Locker: mike $ (BRL)";
@


10.2
log
@Added includes
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/vas4/RCS/vas4.c,v 10.1 1991/10/12 06:50:24 mike Rel4_0 gdurf $ (BRL)";
a358 1
	char str[100];
a510 2
	int	reply;

@


10.1
log
@Release_4.0
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: vas4.c,v 9.1 89/05/19 06:13:51 mike Rel3_5 $ (BRL)";
d25 2
d28 3
a32 4

extern int	getopt();
extern char	*optarg;
extern int	optind;
@


9.1
log
@Release_3.5
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: vas4.c,v 8.1 88/10/05 00:52:42 mike Rel3_0 $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: vas4.c,v 1.9 88/08/11 03:14:14 mike Exp $ (BRL)";
@


1.9
log
@Added -F framebuffer option, and related image size options,
to enable using with a windowing workstation like the SGI
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: vas4.c,v 1.8 88/05/15 23:51:03 mike Locked $ (BRL)";
@


1.8
log
@lint fixes
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: vas4.c,v 1.7 88/01/27 03:10:40 mike Locked $ (BRL)";
d26 1
d29 3
a31 1
int	debug;
d33 6
d44 46
d96 1
d106 1
a106 1
	if (argc < 2)
d108 1
a108 4

	if( strcmp(argv[1], "-d") == 0 )  {
		debug = 1;
		argv++; argc--;
d111 3
d199 4
a202 2
	if( get_vtr_status(0) < 0 )
		exit(1);
d213 1
d219 16
a234 1
	else if (strcmp(argv[1], "new") == 0) {
d282 1
a282 1
			usage_new();
d294 1
d301 4
a304 1
	fprintf(stderr,"Usage: vas4 [-d] keyword [options]\n");
d325 1
a325 1
	fprintf(stderr,"\t[sn]\tscene number must be > 1\n");
d333 1
a333 1
	fprintf(stderr,"\t[nf]\tnumber of frames must be > 1\n");
@


1.7
log
@Fixed calling sequence error (harmless).
Fixed bug with "old" command recording some frames.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: vas4.c,v 1.6 88/01/09 03:50:44 mike Locked $ (BRL)";
d30 4
d76 1
a76 1
		(void)get_tape_position();
d223 1
d243 1
d251 1
d259 1
d274 1
d327 1
d360 1
d406 1
d430 1
d447 1
d468 1
d491 1
d529 1
d558 1
@


1.6
log
@Improved recording code, created separate do_record() function
which is common in several places.
Added "nowait" ability for do_record, so that tape backspace
can happen in parallel with loading next frame into framebuffer.
Misc. bugfixes.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: vas4.c,v 1.5 88/01/08 17:05:58 mike Locked $ (BRL)";
d63 1
a63 1
		vas_await(R_INIT);
d309 4
a312 2
	fprintf(stderr,"Recording built-in title matte\n");
	do_record(1);
@


1.5
log
@Added str2frames() function, to permit more flexible time inputs
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d28 1
a28 1
extern int	debug;
d30 3
d62 3
a64 2
		vas_putc_wait(C_INIT, R_INIT);
		if( get_vtr_status() < 0 )
a65 1
		fprintf(stderr,"VAS Initialized\n");
d71 1
a71 1
		(void)get_vtr_status();
a118 1
		fprintf(stderr,"VTR Rewinding\n");
a122 1
		fprintf(stderr,"VTR Playing\n");
a126 2
/**		vas_await(0, 5);	/* XXX */
		fprintf(stderr,"VTR STOPPED\n");
a130 1
		fprintf(stderr,"VTR Fast Forward\n");
d139 1
a139 1
	if( get_vtr_status() < 0 )
d275 2
a276 1
	vas_putc_wait(C_PROGRAM, R_PROGRAM);
d305 2
a306 1
	vas_putc_wait(C_EE, R_RECORD);
d309 2
a310 3
	fprintf(stderr,"Record built-in title matte\n");
	vas_putc(C_RECORD);
	vas_await(R_RECORD, 30);
a318 3
	char str[100],c,send;
	int retry;

d325 40
a364 10
	for( retry=0; retry<4; retry++ )  {
		vas_putc(C_RECORD);
		for(;;)  {
			c = vas_getc();
			if( c == R_RECORD)
				goto done;
			vas_response(c);
			if (c == R_MISSED) {
				fprintf(stderr,"Preroll failed (typ. due to timer), backspacing for retry\n");
				vas_await(R_RECORD,99);
d367 15
d383 1
a384 2
done:
	get_tape_position();
d414 1
a414 1
 *  It is unclear what modes this is safe in
d421 1
a421 5
	reply = vas_getc();
	if( reply == 'L' )
		return(0);	/* OK */
	vas_response(reply);
	return(-1);		/* fail */
d427 1
a427 1
 *  Seek to time timer value 00:00:00:00, as set by INIT or
d466 3
d474 2
a475 1
get_vtr_status()
d498 1
a498 1
		fprintf(stderr,"VTR is online and ready to roll\n");
d501 1
a501 1
		fprintf(stderr,"VTR is online and stopped\n");
@


1.4
log
@Eliminated bad code
@
text
@d2 1
a2 1
 * vas4.c - program to control the Lyon-Lamb VAS IV 
d4 2
a5 1
 * See man page for details.
a6 1
 * Steve Satterfield, CADIG, USNA
d8 12
a19 1
 * The vas record routines are based upon work by Joe Johnson
d21 3
d83 1
a83 1
			number_of_frames = atoi(argv[3]);
d92 1
a92 1
			number_of_frames = atoi(argv[3]);
d145 1
a145 1
			start_frame = atoi(argv[2]);
d160 1
a160 1
			if( (start_frame = atoi(argv[3])) < 1 )
d178 1
a178 1
			if( (start_frame = atoi(argv[3])) < 1 )
d197 1
a197 1
			number_of_frames = atoi(argv[2]);
d337 1
a337 1
				fprintf(stderr,"Preroll failed\n");
d510 40
@


1.3
log
@Added a bunch of new commands, and more subroutines.
@
text
@a308 24
#ifdef never
	/* This code does not work */
	/* If it has dropped out of E/E, need to get it back into it */
	for(;;)  {
		get_vtr_status();
		c = get_vas_status();
		switch(c)  {
		case '`':			/* After init */
		case 'x':			/* positioned on title after timeout */
			fprintf(stderr,"pressing EE---------\n");
			vas_putc(C_EE);	
			vas_response(vas_getc());	/* should get R_RECORD */
			continue;
		default:
			sleep(1);
			continue;
		case 'a':	/* BRL version of u-code only?? */
			/* Ready to roll */
			break;
		}
		break;
	}
#endif

@


1.2
log
@Updated for use at BRL
@
text
@d21 1
d37 4
d43 2
d48 35
d84 5
a88 3
			fprintf(stderr,"VAS Initialized\n");
		vas_close();
		exit(exit_code);
d90 11
a100 2
	else if (strcmp(argv[1],"rewind") == 0) {
		vas_open();
d103 1
a103 1
		vas_close();
a105 1
		vas_open();
d108 1
a108 1
		vas_close();
a110 1
		vas_open();
d112 1
a112 1
		vas_await(0, 5);
d114 1
a114 1
		vas_close();
a116 1
		vas_open();
d119 1
a119 1
		vas_close();
d121 26
a146 4
	else if (strcmp(argv[1],"new") == 0) {
		if (argc == 3) {
			scene_number = atoi(argv[2]);
			if (scene_number < 1) {
a147 1
			}
d149 4
d159 2
a160 1
		record_new_scene(scene_number);
d162 19
d195 5
a200 2
	else if (strcmp(argv[1],"status") == 0) {
		vas_open();
d202 2
a203 39
		/* Request activity, result code will be interpreted for us */
		vas_putc(C_ACTIVITY);
		get_vtr_status();
		vas_close();
	}
	else if (strcmp(argv[1],"sequence") == 0) {
		if (argc == 2) {
			number_of_images = 1;
			number_of_frames = 1;
			start_seq_number = 1;
		}
		else if (argc == 4) {
			number_of_images = atoi(argv[2]);
			if (number_of_images < 1)
				usage_seq();
			number_of_frames = atoi(argv[3]);
			if (number_of_frames < 1)
				usage_seq();
			start_seq_number = 1;
		}
		else if (argc == 5) {
			number_of_images = atoi(argv[2]);
			if (number_of_images < 1)
				usage_seq();
			number_of_frames = atoi(argv[3]);
			if (number_of_frames < 1)
				usage_seq();
			start_seq_number = atoi(argv[4]);
		}
		else
			usage_seq();


		record_seq(number_of_images, number_of_frames, start_seq_number);
	}
	else {
		usage();
		exit(1);
	}
d207 1
a207 2
usage(code)
int code;
d210 13
a222 1
	fprintf(stderr,"keywords: init, rewind, play, stop, new, record, sequence, status\n");
d252 1
a252 1
 *			R E C O R D _ N E W _ S C E N E
d254 4
a257 2
record_new_scene(scene_number)
int scene_number;
a260 1
	int start_frame = 1;
a261 6
	vas_open();

	/* Init the VAS */
	vas_putc_wait(C_INIT, R_INIT);
	fprintf(stderr,"VAS Initialized\n");

d272 3
a274 2
	vas_putnum(1);		/* New.  0 for Old */
	vas_putc(C_ENTER);
d276 13
a288 2
	vas_putnum(start_frame);
	vas_putc(C_ENTER);
d295 1
a295 1
	fprintf(stderr,"Record 4 sec matte\n");
a297 4

	vas_close();

	fprintf(stderr,"Record_new_scene Done\n");
d309 2
a310 4
	vas_open();
	if( get_vtr_status() < 0 )
		exit(1);

d312 20
a331 2
	vas_putc(C_EE);	
	vas_response(vas_getc());	/* should get R_RECORD */
d354 3
d358 19
a376 2
	vas_close();
	fprintf(stderr,"Recording Done\n");
d380 58
d441 1
d467 10
a476 1
	/* [2] is R for ready, N otherwise */
d479 41
a519 1
	return(0);		/* OK */
@


1.1
log
@Initial revision
@
text
@d12 1
a12 1
#include "vas4.h"
d14 1
d24 1
d26 1
d31 5
d39 4
a42 1
		fprintf(stderr,"VAS Initialized\n");
d44 1
d61 1
a99 1

a100 3
	else if (strcmp(argv[1],"rs170") == 0) {
		init_ik();
	}
d102 6
a107 1
		status();
d141 1
d143 1
a143 1

d149 2
a150 2
	fprintf(stderr,"Usage: vas4 keyword [options]\n");
	fprintf(stderr,"\nkeywords: init, rewind, play, stop, new, record, rs170, sequence, status\n");
d157 1
a157 1
	fprintf(stderr,"\n\t[sn]\tscene number must be > 1\n");
d164 1
a164 1
	fprintf(stderr,"\n\t[nf]\tnumber of frames must be > 1\n");
d171 1
a171 1
	fprintf(stderr,"\n\t[n nf]\tthe number of images n must be > 1\n");
d173 1
a173 1
	fprintf(stderr,"\n\t[start] is the starting sequence number\n");
d179 3
a181 3



a188 1
	fprintf(stderr,"Recording Started\n");
d198 1
a198 3
	/* Set the number of frames */
	sprintf(str,"%d",number_of_frames);
	vas_puts(str);
d201 1
a201 3
	/* Set the scene number */
	sprintf(str,"%d",scene_number);
	vas_puts(str);
d205 2
a206 1
	vas_putc(C_ENTER);   /* For new scene simple skip */
d208 1
a208 3
	/* Set the starting frame */
	sprintf(str,"%d",start_frame);
	vas_puts(str);
d210 1
d212 1
a212 5
	fprintf(stderr,"sleep 2\n");
	sleep(2);

	/* E/E light should now be flashing */
	/* Press E/E */
a214 3
	fprintf(stderr,"Sleep 2\n");
	sleep(2);

d217 2
a218 1
	vas_putc_wait(C_RECORD, R_RECORD);
a219 3
	fprintf(stderr,"Sleep 2\n");
	sleep(2);

d222 1
a222 1
	fprintf(stderr,"Recording Done\n");
d225 3
a227 1

d235 2
d238 3
a240 4
	sprintf(str,"%c%d%c",C_FRAME_CHANGE,number_of_frames,C_ENTER);
	vas_puts(str);
	fprintf(stderr,"Sleep 1\n");
	sleep(1);
d242 7
a248 5
	fprintf(stderr,"Recording (approximately %g seconds)\n",(float)number_of_frames/30.);
	retry = 1;
	while (retry == 1) {
		retry = 0;
		send = C_RECORD;
d250 5
a254 3
		while ((c = vas_getc()) !=  R_RECORD) {
			fprintf(stderr,"Send '%c', Expect '%c', Got '%c'\n",
				send,R_RECORD,c);
d256 3
a258 6
				fprintf(stderr,"Preroll failed, sleep for 5 seconds\n");
				fprintf(stderr,"Then re-try\n");
				sleep(5);
				vas_putc(C_EE);
				send = C_EE;
				retry = 1;
a260 2
		fprintf(stderr,"Send '%c', Expect '%c', Got '%c'\n",
			send,R_RECORD,c);
d262 1
a263 3
	fprintf(stderr,"Sleep 2\n");
	sleep(2);

d266 35
@
