head	1.7;
access;
symbols
	ansi-20040405-merged:1.6
	postmerge-20040405-ansi:1.6
	premerge-20040404-ansi:1.6
	postmerge-autoconf:1.6
	autoconf-freeze:1.6
	premerge-autoconf:1.6
	ansi-20040316-freeze:1.6
	postmerge-20040315-windows:1.6
	premerge-20040315-windows:1.6
	windows-20040315-freeze:1.6
	autoconf-20031203:1.6
	autoconf-20031202:1.6
	autoconf-branch:1.6.0.14
	phong-branch:1.6.0.12
	photonmap-branch:1.6.0.10
	rel-6-1-DP:1.6
	windows-branch:1.6.0.8
	rel-6-0-2:1.6
	ansi-branch:1.6.0.6
	rel-6-0-1-branch:1.6.0.4
	hartley-6-0-post:1.6
	hartley-6-0-pre:1.6
	rel-6-0-1:1.6
	rel-6-0:1.6
	rel-5-4:1.6
	offsite-5-3-pre:1.6
	rel-5-3:1.6
	rel-5-2:1.6
	rel-5-1-branch:1.6.0.2
	rel-5-1:1.6
	rel-5-0:1.6
	rel-5-0-beta:1.6
	rel-4-5:1.5
	ctj-4-5-post:1.3
	ctj-4-5-pre:1.3
	rel-4-4:1.3
	rel-4-0:1.3
	rel-3-5:1.2;
locks; strict;
comment	@ * @;


1.7
date	2004.05.24.04.18.20;	author morrison;	state dead;
branches;
next	1.6;

1.6
date	98.06.23.18.20.41;	author jra;	state Exp;
branches;
next	1.5;

1.5
date	97.12.16.03.45.56;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	97.06.23.17.13.42;	author gdurf;	state Exp;
branches;
next	1.3;

1.3
date	91.01.15.13.53.34;	author moss;	state Exp;
branches;
next	1.2;

1.2
date	89.01.20.15.21.40;	author moss;	state Exp;
branches;
next	1.1;

1.1
date	88.10.28.17.02.26;	author moss;	state Exp;
branches;
next	;


desc
@@


1.7
log
@moved to src/burst/
@
text
@/*
	Author:		Gary S. Moss
			U. S. Army Ballistic Research Laboratory
			Aberdeen Proving Ground
			Maryland 21005-5066

	$Header: /n/xoff/cvs/brlcad/burst/vecmath.h,v 1.6 1998/06/23 18:20:41 jra Exp $
*/
#ifndef _POLY9
#include <math.h>
#endif
#ifndef Abs
#define Abs( a )		((a) > 0 ? (a) : -(a))
#endif
#define AbsDotProd( A, B )	(Abs( Dot( A, B ) ))
#define AddVec( A, B )        { (A)[X] += (B)[X]; \
				(A)[Y] += (B)[Y]; \
				(A)[Z] += (B)[Z]; }
#define Add2Vec( A, B, C )    { (C)[X] = (A)[X]+(B)[X]; \
				(C)[Y] = (A)[Y]+(B)[Y]; \
				(C)[Z] = (A)[Z]+(B)[Z]; }
#define AproxEq( a, b, e )	(Abs( (a)-(b) ) < (e))
#define AproxEqVec( A, B, e ) ( AproxEq((A)[X],(B)[X],(e)) && \
				AproxEq((A)[Y],(B)[Y],(e)) && \
				AproxEq((A)[Z],(B)[Z],(e)) )
#define CopyVec( A, B )	      { (A)[X] = (B)[X]; \
				(A)[Y] = (B)[Y]; \
				(A)[Z] = (B)[Z]; }
#define CrossProd( A, B, C )  {	(C)[X] = (A)[Y]*(B)[Z]-(A)[Z]*(B)[Y]; \
				(C)[Y] = (A)[Z]*(B)[X]-(A)[X]*(B)[Z]; \
				(C)[Z] = (A)[X]*(B)[Y]-(A)[Y]*(B)[X]; }
#define DEGRAD	57.2957795130823208767981548141051703324054724665642
					/* degrees per radian */
#define DiffVec( A, B )       { (A)[X] -= (B)[X]; \
				(A)[Y] -= (B)[Y]; \
				(A)[Z] -= (B)[Z]; }
#define Diff2Vec( A, B, C )   { (C)[X] = (A)[X]-(B)[X]; \
				(C)[Y] = (A)[Y]-(B)[Y]; \
				(C)[Z] = (A)[Z]-(B)[Z]; }
#define Dist3d( A, B )		(sqrt(	Sqr((A)[X]-(B)[X])+\
					Sqr((A)[Y]-(B)[Y])+\
					Sqr((A)[Z]-(B)[Z]))\
				)
#define DivideVec( A, S )     { (A)[X] /= (S); \
				(A)[Y] /= (S); \
				(A)[Z] /= (S); }
#define Dot( A, B )		((A)[X]*(B)[X]+(A)[Y]*(B)[Y]+(A)[Z]*(B)[Z])
#ifndef	EPSILON
#define EPSILON	0.000001
#endif
#define Expand_Vec_Int( V )	(int)(V)[X], (int)(V)[Y], (int)(V)[Z]
#define LOG10E	0.43429448190325182765112891891660508229439700580367
					/* log of e to the base 10 */
#define Mag( A )	      	sqrt( AbsDotProd(A,A) )
#define Mag3(a1,a2,a3)		(sqrt(Sqr(a1)+Sqr(a2)+Sqr(a3)))
#ifndef Min
#define Min( a, b )		((a) < (b) ? (a) : (b))
#define Max( a, b )		((a) > (b) ? (a) : (b))
#endif
#define MinMax( m, M, a )    { m = Min( m, a ); M = Max( M, a ); }
#define MinMaxVec( A, B, C ) { (A)[X] = Min( (A)[X], (C)[X] ); \
			       (A)[Y] = Min( (A)[Y], (C)[Y] ); \
			       (A)[Z] = Min( (A)[Z], (C)[Z] ); \
			       (B)[X] = Max( (B)[X], (C)[X] ); \
			       (B)[Y] = Max( (B)[Y], (C)[Y] ); \
			       (B)[Z] = Max( (B)[Z], (C)[Z] ); }
#define NearZero( a )		((a) < EPSILON && (a) > -EPSILON)
#define NonZeroVec( V )	(!NearZero((V)[X]) || !NearZero((V)[Y])|| !NearZero((V)[Z]))
#ifndef PI
#define PI	3.14159265358979323846264338327950288419716939937511
#endif
					/* ratio of circumf. to diam. */
#define RelDist3d( A, B )	(Sqr((A)[X]-(B)[X])+\
				 Sqr((A)[Y]-(B)[Y])+\
				 Sqr((A)[Z]-(B)[Z]))
#define ScaleVec( A, s )      { (A)[X] *= (s); \
				(A)[Y] *= (s); \
				(A)[Z] *= (s); }
#define Scale2Vec( A, s, B )   { (B)[X] = (A)[X] * (s); \
				(B)[Y] = (A)[Y] * (s); \
				(B)[Z] = (A)[Z] * (s); }
#define Sqr(a)			((a)*(a))
#define TWO_PI		6.28318530717958647692528676655900576839433879875022
/* Scale vector 'a' to have magnitude 'l'.				*/
#define V_Length( a, l ) \
		{	double f, m; \
		if( (m=Mag(a)) == 0.0 ) \
			brst_log( "Magnitude is zero!\n" ); \
		else \
			{ \
			f = (l)/m; \
			(a)[X] *= f; (a)[Y] *= f; (a)[Z] *= f; \
			} \
		}

#define V_Print(a,b,func) \
		func( "%s\t<%12.6f,%12.6f,%12.6f>\n", a, (b)[0], (b)[1], (b)[2] )
#ifndef X
#define X		0
#define Y		1
#define Z		2
#endif
@


1.6
log
@convert bu_log to brst_log to avoid conflicts
@
text
@d7 1
a7 1
	$Header: /c/CVS/brlcad/burst/vecmath.h,v 1.5 1997/12/16 03:45:56 mike Exp $
@


1.5
log
@UPgraded using h/sed4
@
text
@d7 1
a7 1
	$Header: /m/cad/burst/RCS/vecmath.h,v 1.4 1997/06/23 17:13:42 gdurf Exp mike $
d88 1
a88 1
			bu_log( "Magnitude is zero!\n" ); \
@


1.4
log
@Protected definition of PI (Linux systems)
@
text
@d7 1
a7 1
	$Header: /m/cad/burst/RCS/vecmath.h,v 1.3 1991/01/15 13:53:34 moss Exp gdurf $
d88 1
a88 1
			rt_log( "Magnitude is zero!\n" ); \
@


1.3
log
@Removed author's phone number from top of file comment.  This will be
shipped as version 2.1.
@
text
@d7 1
a7 1
	$Header: /vld/moss/src/burst/RCS/vecmath.h,v 1.2 89/01/20 15:21:40 moss Exp $
d69 1
d71 1
@


1.2
log
@Just saving this version for backup purposes, recently added support for
explicitly inputing burst points.
@
text
@d6 2
a7 2
			(301)278-6647 or AV-298-6647
	$Header: /usr/vld/moss/src/burst/RCS/vecmath.h,v 1.1 88/10/28 17:02:26 moss Exp $
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
	$Header: vecmath.h,v 1.2 87/05/12 10:42:51 moss Locked $
a11 1
extern double	sqrt();
@
