head	1.26;
access;
symbols
	ansi-20040405-merged:1.23.4.2
	postmerge-20040405-ansi:1.25
	premerge-20040404-ansi:1.24
	postmerge-autoconf:1.24
	autoconf-freeze:1.24
	premerge-autoconf:1.24
	ansi-20040316-freeze:1.23.4.1
	postmerge-20040315-windows:1.24
	premerge-20040315-windows:1.24
	windows-20040315-freeze:1.23.6.1
	autoconf-20031203:1.24
	autoconf-20031202:1.24
	autoconf-branch:1.24.0.6
	phong-branch:1.24.0.4
	photonmap-branch:1.24.0.2
	rel-6-1-DP:1.24
	windows-branch:1.23.0.6
	rel-6-0-2:1.23
	ansi-branch:1.23.0.4
	rel-6-0-1-branch:1.23.0.2
	hartley-6-0-post:1.23
	hartley-6-0-pre:1.23
	rel-6-0-1:1.23
	rel-6-0:1.23
	rel-5-4:1.19.2.1
	offsite-5-3-pre:1.22
	rel-5-3:1.19.2.1
	rel-5-2:1.19
	rel-5-1-branch:1.19.0.2
	rel-5-1:1.19
	rel-5-0:1.18
	rel-5-0-beta:1.18
	rel-4-5:1.15
	ctj-4-5-post:1.14
	ctj-4-5-pre:1.14
	rel-4-4:1.13
	rel-4-0:1.11
	rel-3-5:1.3;
locks; strict;
comment	@ * @;


1.26
date	2004.05.24.04.18.19;	author morrison;	state dead;
branches;
next	1.25;

1.25
date	2004.04.05.07.50.09;	author morrison;	state Exp;
branches;
next	1.24;

1.24
date	2002.10.22.23.04.36;	author morrison;	state Exp;
branches;
next	1.23;

1.23
date	2001.10.17.07.40.00;	author morrison;	state Exp;
branches
	1.23.4.1
	1.23.6.1;
next	1.22;

1.22
date	2000.11.20.13.25.46;	author jra;	state Exp;
branches;
next	1.21;

1.21
date	2000.09.06.20.12.41;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	2000.08.24.23.12.43;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	2000.01.31.16.32.50;	author jra;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	98.06.23.18.20.40;	author jra;	state Exp;
branches;
next	1.17;

1.17
date	98.03.27.07.07.20;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	98.03.26.08.09.30;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	97.12.16.03.45.56;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	96.12.31.17.37.34;	author jra;	state Exp;
branches;
next	1.13;

1.13
date	93.12.15.11.46.16;	author moss;	state Exp;
branches;
next	1.12;

1.12
date	93.12.15.08.18.30;	author moss;	state Exp;
branches;
next	1.11;

1.11
date	91.09.11.10.41.08;	author moss;	state Exp;
branches;
next	1.10;

1.10
date	91.01.15.13.53.22;	author moss;	state Exp;
branches;
next	1.9;

1.9
date	90.08.28.12.24.09;	author moss;	state Exp;
branches;
next	1.8;

1.8
date	90.08.22.09.40.00;	author moss;	state Exp;
branches;
next	1.7;

1.7
date	89.10.31.12.20.00;	author moss;	state Exp;
branches;
next	1.6;

1.6
date	89.08.18.09.46.28;	author moss;	state Exp;
branches;
next	1.5;

1.5
date	89.07.14.12.59.37;	author moss;	state Exp;
branches;
next	1.4;

1.4
date	89.07.07.16.33.18;	author moss;	state Exp;
branches;
next	1.3;

1.3
date	89.01.20.15.21.14;	author moss;	state Exp;
branches;
next	1.2;

1.2
date	88.11.07.17.01.40;	author moss;	state Exp;
branches;
next	1.1;

1.1
date	88.10.28.17.02.18;	author moss;	state Exp;
branches;
next	;

1.19.2.1
date	2000.11.20.13.22.54;	author jra;	state Exp;
branches;
next	;

1.23.4.1
date	2003.02.15.19.47.56;	author morrison;	state Exp;
branches;
next	1.23.4.2;

1.23.4.2
date	2004.03.17.21.15.51;	author morrison;	state Exp;
branches;
next	;

1.23.6.1
date	2004.03.11.23.40.27;	author morrison;	state Exp;
branches;
next	;


desc
@@


1.26
log
@moved to src/burst/
@
text
@/*
	Author:		Gary S. Moss
			U. S. Army Ballistic Research Laboratory
			Aberdeen Proving Ground
			Maryland 21005-5066
*/
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/burst/grid.c,v 1.25 2004/04/05 07:50:09 morrison Exp $ (BRL)";
#endif

#ifndef DEBUG
#define NDEBUG
#define STATIC static
#else
#define STATIC
#endif

#include <assert.h>

#include <stdio.h>
#include <signal.h>
#include <fcntl.h>
#include <math.h>

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "fb.h"
#include "plot3.h"

#include "./vecmath.h"
#include "./ascii.h"
#include "./extern.h"

#define DEBUG_GRID	0
#define DEBUG_SHOT	1

/* local communication with multitasking process */
static int currshot;	/* current shot index */
static int lastshot;	/* final shot index */

static fastf_t viewdir[3];	/* direction of attack */
static fastf_t delta;		/* angular delta ray of spall cone */
static fastf_t comphi;		/* angle between ring and cone axis */
static fastf_t phiinc;		/* angle between concentric rings */

static fastf_t cantdelta[3];	/* delta ray specified by yaw and pitch */
	
static struct application ag;	/* global application structure (zeroed out) */

/* functions local to this module */
STATIC bool doBursts();
STATIC bool burstPoint();
STATIC bool burstRay();
STATIC bool gridShot();
STATIC fastf_t	max();
STATIC fastf_t	min();
STATIC int f_BurstHit();
STATIC int f_BurstMiss();
STATIC int f_HushOverlap();
STATIC int f_Overlap();
STATIC int f_ShotHit();
STATIC int f_ShotMiss();
STATIC int getRayOrigin();
STATIC int readBurst();
STATIC int readShot();
STATIC void consVector();
STATIC void lgtModel();
STATIC void view_end();
STATIC void view_pix();
STATIC void spallVec();

/*
	void colorPartition( register struct region *regp, int type )

	If user has asked for a UNIX plot write a color command to
	the output stream plotfp which represents the region specified
	by regp.
 */
void
colorPartition( regp, type )
register struct region *regp;
int type;
	{	Colors	*colorp;
	if( plotfile[0] == NUL )
		return;
	assert( plotfp != NULL );
	bu_semaphore_acquire( BU_SEM_SYSCALL );
	switch( type )
		{
	case C_CRIT :
		if( (colorp = findColors( regp->reg_regionid, &colorids ))
			== NULL )
			pl_color( plotfp, R_CRIT, G_CRIT, B_CRIT );
		else
			pl_color( plotfp,
				  (int) colorp->c_rgb[0],
				  (int) colorp->c_rgb[1],
				  (int) colorp->c_rgb[2]
				  );
		break;
	case C_MAIN :
		if( (colorp = findColors( regp->reg_regionid, &colorids ))
			== NULL )
			{
			if( InsideAir(regp ) )
				pl_color( plotfp,
					  R_INAIR, G_INAIR, B_INAIR );
			else
			if( Air(regp ) )
				pl_color( plotfp,
					  R_OUTAIR, G_OUTAIR, B_OUTAIR );
			else
				pl_color( plotfp, R_COMP, G_COMP, B_COMP );
			}
		else
			pl_color( plotfp,
				 (int) colorp->c_rgb[0],
				 (int) colorp->c_rgb[1],
				 (int) colorp->c_rgb[2]
				 );
		break;
	default :
		brst_log( "colorPartition: bad type %d.\n", type );
		break;
		}
	bu_semaphore_release( BU_SEM_SYSCALL );
	return;
	}

/*
	bool doBursts( void )

	This routine gets called when explicit burst points are being
	input.  Crank through all burst points.  Return code of false
	would indicate a failure in the application routine given to
	rt_shootray() or an error or EOF in getting the next set of
	burst point coordinates.
 */
STATIC bool
doBursts()
	{	bool			status = true;
	noverlaps = 0;
	CopyVec( ag.a_ray.r_dir, viewdir ); /* XXX -- could be done up in
						gridModel() */
	for( ; ! userinterrupt; view_pix( &ag ) )
		{
		if(	TSTBIT(firemode,FM_FILE)
		    &&	(!(status = readBurst( burstpoint )) || status == EOF)
			)
			break;
		ag.a_level = 0;	 /* initialize recursion level */
		plotGrid( burstpoint );

		prntBurstHdr( burstpoint, viewdir );
		if( ! burstPoint( &ag, zaxis, burstpoint ) )
			{
			/* fatal error in application routine */
			brst_log( "Fatal error: raytracing aborted.\n" );
			return	false;
			}
		if( ! TSTBIT(firemode,FM_FILE) )
			{
			view_pix( &ag );
			break;
			}
		}
	return	status == EOF ? true : status;
	}

/*
	void enforceLOS( register struct application *ap,
				register struct partition *pt_headp )

	Enforce the line-of-sight tolerance by deleting partitions that are
	too thin.
 */
STATIC void
enforceLOS( ap, pt_headp )
register struct application	*ap;
register struct partition	*pt_headp;
	{	register struct partition	*pp;
	for( pp = pt_headp->pt_forw; pp != pt_headp; )
		{	register struct partition *nextpp = pp->pt_forw;
		if( pp->pt_outhit->hit_dist - pp->pt_inhit->hit_dist
			<= LOS_TOL )
			{
			DEQUEUE_PT( pp );
			FREE_PT( pp, ap->a_resource );
			}
		pp = nextpp;
		}
	return;
	}

/*
	int f_BurstHit( struct application *ap, struct partition *pt_headp )

	This routine handles all output associated with burst ray intersections.

	RETURN CODES: -1 indicates a fatal error, and fatalerror will be
	set to true.  A positive number is interpreted as the count of critical
	component intersections.  A value of false would indicate that zero
	critical components were encountered.
 */
STATIC int
f_BurstHit( ap, pt_headp, segp )
struct application *ap;
struct partition *pt_headp;
struct seg *segp;
	{	Pt_Queue *qshield = PT_Q_NULL;
		register struct partition *cpp, *spp;
		register int nbar;
		register int ncrit = 0;
#ifdef VDEBUG
	prntDbgPartitions( ap, pt_headp, "f_BurstHit: initial partitions" );
#endif
	/* Find first barrier in front of the burst point. */
	for(	spp = pt_headp->pt_forw;
		spp != pt_headp
	    &&	spp->pt_outhit->hit_dist < 0.1;
		spp = spp->pt_forw
		) 
		;
	for(	cpp = spp, nbar = 0;
		cpp != pt_headp && nbar <= nbarriers;
		cpp = cpp->pt_forw
		) 
		{	register struct region *regp = cpp->pt_regionp;
			struct xray *rayp = &ap->a_ray;
		if( Air( regp ) )
			continue; /* Air doesn't matter here. */
		if( findIdents( regp->reg_regionid, &critids ) )
			{	fastf_t entrynorm[3], exitnorm[3];
			if( ncrit == 0 )
				prntRayHeader( ap->a_ray.r_dir, viewdir,
						ap->a_user );
			/* Output queued non-critical components. */
			prntShieldComp( ap, pt_headp, qshield );
			qFree( qshield );
			qshield = PT_Q_NULL; /* queue empty */

			/* Output critical component intersection;
			   prntRegionHdr fills in hit entry/exit normals. */
			prntRegionHdr( ap, pt_headp, cpp, entrynorm, exitnorm );
			colorPartition( regp, C_CRIT );
			plotPartition( cpp->pt_inhit, cpp->pt_outhit,
					rayp, regp );
			if( fbfile[0] != NUL && ncrit == 0 )
				/* first hit on critical component */
				lgtModel( ap, cpp, cpp->pt_inhit, rayp,
					entrynorm );
			ncrit++;
			}
		else
		/* Queue up shielding components until we hit a critical one. */
		if( cpp->pt_forw != pt_headp )
			{
			if( ! qAdd( cpp, &qshield ) )
				{
				fatalerror = true;
				return	-1;
				}
			nbar++;
			}
		}
	qFree( qshield );
	if( ncrit == 0 )
		return	ap->a_miss( ap );
	else
		return	ncrit;
	}


/*
	int f_HushOverlap( struct application *ap, struct partition *pp,
		struct region *reg1, struct region *reg2,
		struct partition *pheadp )

	Do not report diagnostics about individual overlaps, but keep count
	of significant ones (at least as thick as OVERLAP_TOL).
	Some of this code is from librt/bool.c:rt_defoverlap() for
	consistency of which region is picked.

	Returns -
	 0	to eliminate partition with overlap entirely
	 1	to retain partition in output list, claimed by reg1
	 2	to retain partition in output list, claimed by reg2
 */
/*ARGSUSED*/
STATIC int
f_HushOverlap( ap, pp, reg1, reg2, pheadp )
struct application *ap;
struct partition *pp;
struct region *reg1, *reg2;
struct partition *pheadp;
	{	fastf_t depth;
#ifdef BRLCAD4_0
	RT_CHECK_PT(pp);
#endif
	depth = pp->pt_outhit->hit_dist - pp->pt_inhit->hit_dist;
	if( depth >= OVERLAP_TOL )
		noverlaps++;

	/* Apply heuristics as to which region should claim partition. */
	if( reg1->reg_aircode != 0 )
		/* reg1 was air, replace with reg2 */
		return 2;
	if( pp->pt_back != pheadp )
		{ /* Repeat a prev region, if that is a choice */
		if( pp->pt_back->pt_regionp == reg1 )
			return 1;
		if( pp->pt_back->pt_regionp == reg2 )
			return 2;
		}
	/* To provide some consistency from ray to ray, use lowest bit # */
	if( reg1->reg_bit < reg2->reg_bit )
		return 1;
	return 2;
	}

/*
	int f_Overlap( struct application *ap, struct partition *pp,
		struct region *reg1, struct region *reg2,
		struct partition *pheadp )

	Do report diagnostics and keep count of individual overlaps
	that are at least as thick as OVERLAP_TOL.
	Some of this code is from librt/bool.c:rt_defoverlap() for
	consistency of which region is picked.

	Returns -
	 0	to eliminate partition with overlap entirely
	 1	to retain partition in output list, claimed by reg1
	 2	to retain partition in output list, claimed by reg2
 */
/*ARGSUSED*/
STATIC int
f_Overlap( ap, pp, reg1, reg2, pheadp )
struct application *ap;
struct partition *pp;
struct region *reg1, *reg2;
struct partition *pheadp;
	{	fastf_t depth;
		point_t pt;
#ifdef BRLCAD4_0
	RT_CHECK_PT(pp);
#endif
	depth = pp->pt_outhit->hit_dist - pp->pt_inhit->hit_dist;
	if( depth >= OVERLAP_TOL )
		{
		noverlaps++;

		VJOIN1( pt, ap->a_ray.r_pt, pp->pt_inhit->hit_dist,
			ap->a_ray.r_dir );
		brst_log( "OVERLAP:\n" );
		brst_log( "reg=%s isol=%s,\n",
			reg1->reg_name, pp->pt_inseg->seg_stp->st_name
			);
		brst_log( "reg=%s osol=%s,\n",
			reg2->reg_name, pp->pt_outseg->seg_stp->st_name
			);
		brst_log( "depth %.2fmm at (%g,%g,%g) x%d y%d lvl%d purpose=%s\n",
			depth,
			pt[X], pt[Y], pt[Z],
			ap->a_x, ap->a_y, ap->a_level, ap->a_purpose
			);
		}

	/* Apply heuristics as to which region should claim partition. */
	if( reg1->reg_aircode != 0 )
		/* reg1 was air, replace with reg2 */
		return 2;
	if( pp->pt_back != pheadp )
		{ /* Repeat a prev region, if that is a choice */
		if( pp->pt_back->pt_regionp == reg1 )
			return 1;
		if( pp->pt_back->pt_regionp == reg2 )
			return 2;
		}
	/* To provide some consistency from ray to ray, use lowest bit # */
	if( reg1->reg_bit < reg2->reg_bit )
		return 1;
	return 2;
	}

/*
	int f_ShotHit( struct application *ap, struct partition *pt_headp )

	This routine is called when a shotline hits the model.  All output
	associated with the main penetrator path is printed here.  If line-
	of-sight bursting is requested, burst point gridding is spawned by
	a call to burstPoint() which dispatches the burst ray task burstRay(),
	a recursive call to the ray tracer.

	RETURN CODES: false would indicate a failure in an application routine
	handed to rt_shootray() by burstRay().  Otherwise, true is returned.
 */
STATIC int
f_ShotHit( ap, pt_headp, segp )
struct application *ap;
struct partition *pt_headp;
struct seg *segp;
	{	register struct partition *pp;
		struct partition *bp = PT_NULL;
		fastf_t burstnorm[3]; /* normal at burst point */
#if DEBUG_GRID
	brst_log( "f_ShotHit\n" );
	for( pp = pt_headp->pt_forw; pp != pt_headp; pp = pp->pt_forw )
		brst_log( "\tregion is '%s',\tid=%d\taircode=%d\n",
			pp->pt_regionp->reg_name,
			(int) pp->pt_regionp->reg_regionid,
			(int) pp->pt_regionp->reg_aircode );
#endif
	/* Output cell identification. */
	prntCellIdent( ap );
	/* Color cell if making frame buffer image. */
	if( fbfile[0] != NUL )
		paintCellFb( ap, pixtarg, zoom == 1 ? pixblack : pixbkgr );

	/* First delete thin partitions. */
	enforceLOS( ap, pt_headp );

	/* Output ray intersections.  This code is extremely cryptic because
		it is dealing with errors in the geometry, where there is
		either adjacent airs of differing types, or voids (gaps)
		in the description.  In the case of adjacent airs, phantom
		armor must be output.  For voids, outside air is the default
		(everyone knows that air rushes to fill a vacuum), so we
		must pretend that it is there.  Outside air is also called
		01 air because its aircode equals 1.  Please tread carefully
		on the code within this loop, it is filled with special
		cases involving adjacency of partitions both real (explicit)
		and imagined (implicit).
	 */
	for( pp = pt_headp->pt_forw; pp != pt_headp; pp = pp->pt_forw )
		{	fastf_t	los = 0.0;
			int	voidflag = false;
			register struct partition *np = pp->pt_forw;
			register struct partition *cp;
			register struct region *regp = pp->pt_regionp;
			register struct region *nregp = pp->pt_forw->pt_regionp;
		/* Fill in entry and exit points into hit structures. */
		{	register struct hit *ihitp = pp->pt_inhit;
			register struct hit *ohitp = pp->pt_outhit;
			register struct xray *rayp = &ap->a_ray;
		VJOIN1( ihitp->hit_point, rayp->r_pt, ihitp->hit_dist,
			rayp->r_dir );
		VJOIN1( ohitp->hit_point, rayp->r_pt, ohitp->hit_dist,
			rayp->r_dir );
		colorPartition( regp, C_MAIN );
		plotPartition( ihitp, ohitp, rayp, regp );
		}

		/* Check for voids. */
		if( np != pt_headp )
			{
#if DEBUG_GRID
			brst_log( "\tprocessing region '%s',\tid=%d\taircode=%d\n",
				pp->pt_regionp->reg_name,
				(int) pp->pt_regionp->reg_regionid,
				(int) pp->pt_regionp->reg_aircode );
			brst_log( "\tcheck for voids\n" );
#endif
			los = np->pt_inhit->hit_dist -
					pp->pt_outhit->hit_dist;
#if DEBUG_GRID
			brst_log( "\tlos=%g tolerance=%g\n",
				los, LOS_TOL );
#endif
			voidflag = ( los > LOS_TOL );
			/* If the void occurs adjacent to explicit outside
				air, extend the outside air to fill it. */
			if( OutsideAir( np->pt_regionp ) )
				{
#if DEBUG_GRID
				brst_log( "\t\toutside air\n" );
#endif
				if( voidflag )
					{
					np->pt_inhit->hit_dist =
						pp->pt_outhit->hit_dist;
					voidflag = false;
					}
				/* Keep going until we are past 01 air. */
				for(	cp = np->pt_forw;
					cp != pt_headp;
					cp = cp->pt_forw )
					{
					if( OutsideAir( cp->pt_regionp ) )
						/* Include outside air. */
						np->pt_outhit->hit_dist =
						cp->pt_outhit->hit_dist;
					else
					if( cp->pt_inhit->hit_dist -
					    np->pt_outhit->hit_dist
						> LOS_TOL )
						/* Include void following
							outside air. */
						np->pt_outhit->hit_dist =
						cp->pt_inhit->hit_dist;
					else
						break;
					}
				}
			}
		/* Merge adjacent inside airs of same type. */
		if( np != pt_headp && InsideAir( np->pt_regionp ) )
			{
#if DEBUG_GRID
			brst_log( "\tmerging inside airs\n" );
#endif
			for(	cp = np->pt_forw;
				cp != pt_headp;
				cp = cp->pt_forw )
				{
				if(	InsideAir( cp->pt_regionp )
				    &&	SameAir(np->pt_regionp, cp->pt_regionp)
				    &&	cp->pt_inhit->hit_dist -
						np->pt_outhit->hit_dist
					<= LOS_TOL )
					np->pt_outhit->hit_dist =
						cp->pt_outhit->hit_dist;
				else
					break;
				}
			}

		/* Check for possible phantom armor before internal air,
			that is if it is the first thing hit. */
		if( pp->pt_back == pt_headp && InsideAir( regp ) )
			{	fastf_t	slos;
			/* If adjacent partitions are the same air, extend
				the first on to include them. */
#if DEBUG_GRID
			brst_log( "\tphantom armor before internal air\n" );
#endif
			for( cp = np; cp != pt_headp; cp = cp->pt_forw )
				{
				if(	InsideAir( cp->pt_regionp )
				    &&	SameAir( regp, cp->pt_regionp )
				    &&	cp->pt_inhit->hit_dist -
						pp->pt_outhit->hit_dist
					<= LOS_TOL )
					pp->pt_outhit->hit_dist =
						cp->pt_outhit->hit_dist;
				else
					break;
				
				}

			slos = pp->pt_outhit->hit_dist - pp->pt_inhit->hit_dist;
			prntPhantom( pp->pt_inhit, (int) regp->reg_aircode,
					slos );
			}				
		else
		if( ! Air( regp ) ) /* If we have a component, output it. */
			{	fastf_t entrynorm[3];	/* normal at entry */
				fastf_t exitnorm[3];	/* normal at exit */
			/* Get entry normal. */
			getRtHitNorm( pp->pt_inhit, pp->pt_inseg->seg_stp,
				&ap->a_ray, (bool) pp->pt_inflip, entrynorm );
			(void) chkEntryNorm( pp, &ap->a_ray, entrynorm,
				"shotline entry normal" );
			/* Get exit normal. */
			getRtHitNorm( pp->pt_outhit, pp->pt_outseg->seg_stp,
				&ap->a_ray, (bool) pp->pt_outflip, exitnorm );
			(void) chkExitNorm( pp, &ap->a_ray, exitnorm,
				"shotline exit normal" );

#if DEBUG_GRID
			brst_log( "\twe have a component\n" );
#endif
			/* In the case of fragmenting munitions, a hit on any
				component will cause a burst point. */
			if( bp == PT_NULL && bdist > 0.0 )
				{
				bp = pp;	/* register exterior burst */
				CopyVec( burstnorm, exitnorm );
				}

			/* If there is a void, output 01 air as space. */
			if( voidflag )
				{
#if DEBUG_GRID
				brst_log( "\t\tthere is a void, %s\n",
					"so outputting 01 air" );
#endif
				if(	bp == PT_NULL && ! reqburstair
				    &&	findIdents( regp->reg_regionid,
							&armorids ) )
					{ /* Bursting on armor/void (ouchh). */
					bp = pp;
					CopyVec( burstnorm, exitnorm );
					}
				prntSeg( ap, pp, OUTSIDE_AIR,
					entrynorm, exitnorm, pp == bp );
				}
			else
			/* If air expicitly follows, output space code. */
			if( np != pt_headp && Air( nregp ) )
				{
				/* Check for interior burst point. */
#if DEBUG_GRID
				brst_log( "\t\texplicit air follows\n" );
#endif
				if(	bp == PT_NULL && bdist <= 0.0
				    &&	findIdents( regp->reg_regionid,
							&armorids )
				    && ( ! reqburstair
				     ||	findIdents( nregp->reg_aircode,
							&airids ))
					)
					{
					bp = pp; /* register interior burst */
					CopyVec( burstnorm, exitnorm );
					}
				prntSeg( ap, pp, nregp->reg_aircode,
					entrynorm, exitnorm, pp == bp );
				}
			else
			if( np == pt_headp )
				{
				/* Last component gets 09 air. */
#if DEBUG_GRID
				brst_log( "\t\tlast component\n" );
#endif
				prntSeg( ap, pp, EXIT_AIR,
					entrynorm, exitnorm, pp == bp );
				}
			else
			/* No air follows component. */
			if( SameCmp( regp, nregp ) )
				{
#if DEBUG_GRID
				brst_log( "\t\tmerging adjacent components\n" );
#endif
				/* Merge adjacent components with same
					idents. */
				*np->pt_inhit = *pp->pt_inhit;
				np->pt_inseg = pp->pt_inseg;
				np->pt_inflip = pp->pt_inflip;
				continue;
				}
			else
				{
#if DEBUG_GRID
				brst_log( "\t\tdifferent component follows\n" );
#endif
				prntSeg( ap, pp, 0,
					entrynorm, exitnorm, pp == bp );
					/* component follows */
				}
			}
		/* Check for adjacency of differing airs, implicit or
			explicit and output phantom armor as needed. */
		if( InsideAir( regp ) )
			{
#if DEBUG_GRID
			brst_log( "\tcheck for adjacency of differing airs; inside air\n" );
#endif
			/* Inside air followed by implicit outside air. */
			if( voidflag )
				prntPhantom( pp->pt_outhit, OUTSIDE_AIR, los );
			}
		/* Check next partition for adjacency problems. */
		if( np != pt_headp )
			{
#if DEBUG_GRID
			brst_log( "\tcheck next partition for adjacency\n" );
#endif
			/* See if inside air follows impl. outside air. */
			if( voidflag && InsideAir( nregp ) )
				{	fastf_t	slos =
						np->pt_outhit->hit_dist -
						np->pt_inhit->hit_dist;
#if DEBUG_GRID
				brst_log( "\t\tinside air follows impl. outside air\n" );
#endif
				prntPhantom( np->pt_inhit, nregp->reg_aircode,
						slos );
				}
			else
			/* See if differing airs are adjacent. */
			if(   !	voidflag
			    &&	Air( regp )
			    &&	Air( nregp )
			    &&	DiffAir( nregp, regp )
				)
				{	fastf_t slos = np->pt_outhit->hit_dist -
						 np->pt_inhit->hit_dist;
#if DEBUG_GRID
				brst_log( "\t\tdiffering airs are adjacent\n" );
#endif
				prntPhantom( np->pt_inhit,
						(int) nregp->reg_aircode,
						slos );
				}
			}
		/* Output phantom armor if internal air is last hit. */
		if( np == pt_headp && InsideAir( regp ) )
			{
#if DEBUG_GRID
			brst_log( "\tinternal air last hit\n" );
#endif
			prntPhantom( pp->pt_outhit, EXIT_AIR, 0.0 );
			}
		}
	if( nriplevels == 0 )
		return	true;

	if( bp != PT_NULL )
		{	fastf_t burstpt[3];
		/* This is a burst point, calculate coordinates. */
		if( bdist > 0.0 )
			{ /* Exterior burst point (i.e. case-fragmenting
				munition with contact-fuzed set-back device):
				location is bdist prior to entry point. */
			VJOIN1( burstpt, bp->pt_inhit->hit_point, -bdist,
				ap->a_ray.r_dir );
			}
		else
		if( bdist < 0.0 )
			{ /* Interior burst point (i.e. case-fragment
				munition with delayed fuzing): location is
				the magnitude of bdist beyond the exit
				point. */
			VJOIN1( burstpt, bp->pt_outhit->hit_point, -bdist,
				ap->a_ray.r_dir );
			}
		else	  /* Interior burst point: no fuzing offset. */
			CopyVec( burstpt, bp->pt_outhit->hit_point );

		/* Only generate burst rays if nspallrays is greater then
			zero. */
		if( nspallrays < 1 )
			return	true;

		return	burstPoint( ap, burstnorm, burstpt );
		}
	return	true;
	}

/*
	void getRtHitNorm( struct hit *hitp, struct soltab *stp,
			struct xray *rayp, bool flipped, fastf_t normvec[3] )

	Fill normal and hit point into hit struct and if the flipped
	flag is set, reverse the normal.  Return a private copy of the
	flipped normal in normvec.  NOTE: the normal placed in the hit
	struct should not be modified (ie reversed) by the application
	because it can be instanced by other solids.
 */
void
getRtHitNorm( hitp, stp, rayp, flipped, normvec )
struct hit *hitp;
struct soltab *stp;
struct xray *rayp;
bool flipped;
fastf_t normvec[3];
	{
	RT_HIT_NORMAL( normvec, hitp, stp, rayp, flipped );
	}

bool
chkEntryNorm( pp, rayp, normvec, purpose )
struct partition *pp;
struct xray *rayp;
fastf_t normvec[3];
char *purpose;
	{	fastf_t f;
		static int flipct = 0;
		static int totalct = 0;
		struct soltab *stp = pp->pt_inseg->seg_stp;
		bool ret = true;
	totalct++;
	/* Dot product of ray direction with normal *should* be negative. */
	f = Dot( rayp->r_dir, normvec );
	if( NearZero( f ) )
		{
#ifdef DEBUG
		brst_log( "chkEntryNorm: near 90 degree obliquity.\n" );
		brst_log( "\tPnt %g,%g,%g\n\tDir %g,%g,%g\n\tNorm %g,%g,%g.\n",
			rayp->r_pt[X], rayp->r_pt[Y], rayp->r_pt[Z],
			rayp->r_dir[X], rayp->r_dir[Y], rayp->r_dir[Z],
			normvec[X], normvec[Y], normvec[Z] );
#endif
		ret = false;
		}
	if( f > 0.0 )
		{
		flipct++;
		brst_log( "Fixed flipped entry normal:\n" );
		brst_log( "\tregion \"%s\" solid \"%s\" type %d \"%s\".\n",
			pp->pt_regionp->reg_name, stp->st_name,
			stp->st_id, purpose );
#ifdef DEBUG
		brst_log( "\tPnt %g,%g,%g\n\tDir %g,%g,%g\n\tNorm %g,%g,%g.\n",
			rayp->r_pt[X], rayp->r_pt[Y], rayp->r_pt[Z],
			rayp->r_dir[X], rayp->r_dir[Y], rayp->r_dir[Z],
			normvec[X], normvec[Y], normvec[Z] );
		brst_log( "\tDist %g Hit Pnt %g,%g,%g\n",
			pp->pt_inhit->hit_dist,
			pp->pt_inhit->hit_point[X],
			pp->pt_inhit->hit_point[Y],
			pp->pt_inhit->hit_point[Z] );
		brst_log( "\t%d of %d normals flipped.\n", flipct, totalct );
#endif
		ScaleVec( normvec, -1.0 );
		ret = false;
		}
	return ret;
	}

bool
chkExitNorm( pp, rayp, normvec, purpose )
struct partition *pp;
struct xray *rayp;
fastf_t normvec[3];
char *purpose;
	{	fastf_t f;
		static int flipct = 0;
		static int totalct = 0;
		struct soltab *stp = pp->pt_outseg->seg_stp;
		bool ret = true;
	totalct++;
	/* Dot product of ray direction with normal *should* be positive. */
	f = Dot( rayp->r_dir, normvec );
	if( NearZero( f ) )
		{
#ifdef DEBUG
		brst_log( "chkExitNorm: near 90 degree obliquity.\n" );
		brst_log( "\tPnt %g,%g,%g\n\tDir %g,%g,%g\n\tNorm %g,%g,%g.\n",
			rayp->r_pt[X], rayp->r_pt[Y], rayp->r_pt[Z],
			rayp->r_dir[X], rayp->r_dir[Y], rayp->r_dir[Z],
			normvec[X], normvec[Y], normvec[Z] );
#endif
		ret = false;
		}
	if( f < 0.0 )
		{
		flipct++;
		brst_log( "Fixed flipped exit normal:\n" );
		brst_log( "\tregion \"%s\" solid \"%s\" type %d \"%s\".\n",
			pp->pt_regionp->reg_name, stp->st_name,
			stp->st_id, purpose );
#ifdef DEBUG
		brst_log( "\tPnt %g,%g,%g\n\tDir %g,%g,%g\n\tNorm %g,%g,%g.\n",
			rayp->r_pt[X], rayp->r_pt[Y], rayp->r_pt[Z],
			rayp->r_dir[X], rayp->r_dir[Y], rayp->r_dir[Z],
			normvec[X], normvec[Y], normvec[Z] );
		brst_log( "\tDist %g Hit Pnt %g,%g,%g\n",
			pp->pt_outhit->hit_dist,
			pp->pt_outhit->hit_point[X],
			pp->pt_outhit->hit_point[Y],
			pp->pt_outhit->hit_point[Z] );
		brst_log( "\t%d of %d normals flipped.\n", flipct, totalct );
#endif
		ScaleVec( normvec, -1.0 );
		ret = false;
		}
	return ret;
	}

/*
	int f_ShotMiss( register struct application *ap )

	Shot missed the model; if ground bursting is enabled, intersect with
	ground plane, else just arrange for appropriate background color for
	debugging.
 */	
STATIC int
f_ShotMiss( ap )
register struct application *ap;
	{
	if( groundburst )
		{	fastf_t dist;
			fastf_t	hitpoint[3];
		/* first find intersection of shot with ground plane */
		if( ap->a_ray.r_dir[Z] >= 0.0 )
			/* Shot direction is upward, can't hit the ground
				from underneath. */
			goto	missed_ground;
		if( ap->a_ray.r_pt[Z] <= -grndht )
			/* Must be above ground to hit it from above. */
			goto	missed_ground;
		/* ground plane is grndht distance below the target origin */
		hitpoint[Z] = -grndht;
		/* distance along ray from ray origin to ground plane */
		dist = (hitpoint[Z] - ap->a_ray.r_pt[Z]) / ap->a_ray.r_dir[Z];
		/* solve for X and Y intersection coordinates */
		hitpoint[X] = ap->a_ray.r_pt[X] + ap->a_ray.r_dir[X]*dist;
		hitpoint[Y] = ap->a_ray.r_pt[Y] + ap->a_ray.r_dir[Y]*dist;
		/* check for limits of ground plane */
		if(	hitpoint[X] <= grndfr && hitpoint[X] >= -grndbk
		    &&	hitpoint[Y] <= grndlf && hitpoint[Y] >= -grndrt
			) /* We have a hit. */
			{
			if( fbfile[0] != NUL )
				paintCellFb( ap, pixghit,
					zoom == 1 ? pixblack : pixbkgr );
			if( bdist > 0.0 )
				{ /* simulate standoff fuzing */	
				VJOIN1( hitpoint, hitpoint, -bdist,
					ap->a_ray.r_dir );
				}
			else
			if( bdist < 0.0 )
				{ /* interior burst not implemented in ground */
				brst_log( "User error: %s %s.\n",
					"negative burst distance can not be",
					"specified with ground plane bursting"
					);
				fatalerror = true;
				return	-1;
				}
			/* else bdist == 0.0, no adjustment necessary */
			/* only burst if nspallrays greater than zero */
			if( nspallrays > 0 )
				{
				prntBurstHdr( hitpoint, viewdir );
				return	burstPoint( ap, zaxis, hitpoint );
				}
			else
				return	true;
			}
		}
missed_ground :
	if( fbfile[0] != NUL )
		paintCellFb( ap, pixmiss, zoom == 1 ? pixblack : pixbkgr );
	VSETALL( ap->a_color, 0.0 ); /* All misses black. */
	return	false;
	}

/*
	int f_BurstMiss( register struct application *ap )

	Burst ray missed the model, so do nothing.
 */	
STATIC int
f_BurstMiss( ap )
register struct application *ap;
	{
	VSETALL( ap->a_color, 0.0 ); /* All misses black. */
	return	false;
	}

/*
	int getRayOrigin( register struct application *ap )

	This routine fills in the ray origin ap->a_ray.r_pt by folding
	together firing mode and dithering options. By-products of this
	routine include the grid offsets which are stored in ap->a_uvec,
	2-digit random numbers (when opted) which are stored in ap->a_user,
	and grid indices are stored in ap->a_x and ap->a_y.  Return
	codes are: false for failure to read new firing coordinates, or
	true for success. 
 */
STATIC int
getRayOrigin( ap )
register struct application	*ap;
	{	register fastf_t	*vec = ap->a_uvec;
		fastf_t			gridyinc[3], gridxinc[3];
		fastf_t			scalecx, scalecy;
	if( TSTBIT(firemode,FM_SHOT) )
		{
		if( TSTBIT(firemode,FM_FILE) )
			{
			switch( readShot( vec ) )
				{
			case EOF :	return	EOF;
			case true :	break;
			case false :	return	false;
				}
			}
		else	/* Single shot specified. */
			CopyVec( vec, fire );
		if( TSTBIT(firemode,FM_3DIM) )
			{	fastf_t	hitpoint[3];
			/* Project 3-d hit-point back into grid space. */
			CopyVec( hitpoint, vec );
			vec[X] = Dot( gridhor, hitpoint );
			vec[Y] = Dot( gridver, hitpoint );
			}
		ap->a_x = vec[X] / cellsz;
		ap->a_y = vec[Y] / cellsz;
		scalecx = vec[X];
		scalecy = vec[Y];
		}
	else
		{	fastf_t xoffset = 0.0;
			fastf_t yoffset = 0.0;
		ap->a_x = currshot % gridwidth + gridxorg;
		ap->a_y = currshot / gridwidth + gridyorg;
		if( dithercells )
			{
			/* 2-digit random number, 1's place gives X
				offset, 10's place gives Y offset.
			 */
#ifdef SYSV /* Use lrand48() only if random() not available.  */
			ap->a_user = lrand48() % 100;
#else
			ap->a_user = random() % 100;
#endif
			xoffset = (ap->a_user%10)*0.1 - 0.5;
			yoffset = (ap->a_user/10)*0.1 - 0.5;
			}
		/* Compute magnitude of grid offsets. */
		scalecx = (fastf_t) ap->a_x + xoffset;
		scalecy = (fastf_t) ap->a_y + yoffset;
		vec[X] = scalecx *= cellsz;
		vec[Y] = scalecy *= cellsz;
		}
	/* Compute cell horizontal and vertical	vectors relative to
		grid origin. */
	Scale2Vec( gridhor, scalecx, gridxinc );
	Scale2Vec( gridver, scalecy, gridyinc );
	Add2Vec( gridsoff, gridyinc, ap->a_ray.r_pt );
	AddVec( ap->a_ray.r_pt, gridxinc );
	return	true;
	}

/*
	void gridInit( void )

	Grid initialization routine; must be done once per view.
 */
void
gridInit()
	{
	notify( "Initializing grid", NOTIFY_APPEND );
	rt_prep_timer();

#if DEBUG_SHOT
	if( TSTBIT(firemode,FM_BURST) )
		brst_log( "gridInit: reading burst points.\n" );
	else	{
		if( TSTBIT(firemode,FM_SHOT) )
			brst_log( "gridInit: shooting discrete shots.\n" );
		else
			brst_log( "gridInit: shooting %s.\n",
				TSTBIT(firemode,FM_PART) ?
				"partial envelope" : "full envelope" );
		}
	if( TSTBIT(firemode,FM_BURST) || TSTBIT(firemode,FM_SHOT) )
		{
		brst_log( "gridInit: reading %s coordinates from %s.\n",
			TSTBIT(firemode,FM_3DIM) ? "3-d" : "2-d",
			TSTBIT(firemode,FM_FILE) ? "file" : "command stream" );
		
		}
	else
	if( TSTBIT(firemode,FM_FILE) || TSTBIT(firemode,FM_3DIM) )
		brst_log( "BUG: insane combination of fire mode bits:0x%x\n",
			firemode );
	if( TSTBIT(firemode,FM_BURST) || shotburst )
		nriplevels = 1;
	else
		nriplevels = 0;
	if( !shotburst && groundburst )
		{
		(void) sprintf( scrbuf,
				"Ground bursting directive ignored: %s.\n",
				"only relevant if bursting along shotline" );
		warning( scrbuf );
		brst_log( scrbuf );
		}
#endif
	/* compute grid unit vectors */
	gridRotate( viewazim, viewelev, 0.0, gridhor, gridver );

	if( yaw != 0.0 || pitch != 0.0 )
		{	fastf_t	negsinyaw = -sin( yaw );
			fastf_t	sinpitch = sin( pitch );
			fastf_t	xdeltavec[3], ydeltavec[3];
#if DEBUG_SHOT
		brst_log( "gridInit: canting warhead\n" );
#endif
		cantwarhead = true;
		Scale2Vec( gridhor,  negsinyaw, xdeltavec );
		Scale2Vec( gridver,  sinpitch,  ydeltavec );
		Add2Vec( xdeltavec, ydeltavec, cantdelta );
		}

	/* unit vector from origin of model toward eye */
	consVector( viewdir, viewazim, viewelev );

	/* reposition file pointers if necessary */
	if( TSTBIT(firemode,FM_SHOT) && TSTBIT(firemode,FM_FILE) )
		rewind( shotfp );
	else
	if( TSTBIT(firemode,FM_BURST) && TSTBIT(firemode,FM_FILE) )
		rewind( burstfp );

	/* Compute distances from grid origin (model origin) to each
		border of grid, and grid indices at borders of grid.
	 */
	if( ! TSTBIT(firemode,FM_PART) )
		{	fastf_t modelmin[3];
			fastf_t modelmax[3];
		if( groundburst )
			{ /* extend grid to include ground platform */
			modelmax[X] = Max( rtip->mdl_max[X], grndfr );
			modelmin[X] = Min( rtip->mdl_min[X], -grndbk );
			modelmax[Y] = Max( rtip->mdl_max[Y], grndlf );
			modelmin[Y] = Min( rtip->mdl_min[Y], -grndrt );
			modelmax[Z] = rtip->mdl_max[Z];
			modelmin[Z] = Min( rtip->mdl_min[Z], -grndht );
			}
		else
			{ /* size grid by model RPP */
			CopyVec( modelmin, rtip->mdl_min );
			CopyVec( modelmax, rtip->mdl_max );
			}
		/* Calculate extent of grid. */
		gridrt = max(	gridhor[X] * modelmax[X],
				gridhor[X] * modelmin[X]
				) +
			  max(	gridhor[Y] * modelmax[Y],
				gridhor[Y] * modelmin[Y]
				) +
			  max(	gridhor[Z] * modelmax[Z],
				gridhor[Z] * modelmin[Z]
				);
		gridlf = min(	gridhor[X] * modelmax[X],
				gridhor[X] * modelmin[X]
				) +
			  min(	gridhor[Y] * modelmax[Y],
				gridhor[Y] * modelmin[Y]
				) +
			  min(	gridhor[Z] * modelmax[Z],
				gridhor[Z] * modelmin[Z]
				);
		gridup = max(	gridver[X] * modelmax[X],
				gridver[X] * modelmin[X]
				) +
			  max(	gridver[Y] * modelmax[Y],
				gridver[Y] * modelmin[Y]
				) +
			  max(	gridver[Z] * modelmax[Z],
				gridver[Z] * modelmin[Z]
				);
		griddn = min(	gridver[X] * modelmax[X],
				gridver[X] * modelmin[X]
				) +
			  min(	gridver[Y] * modelmax[Y],
				gridver[Y] * modelmin[Y]
				) +
			  min(	gridver[Z] * modelmax[Z],
				gridver[Z] * modelmin[Z]
				);
		/* Calculate extent of model in plane of grid. */
		if( groundburst )
			{
			modlrt = max(	gridhor[X] * rtip->mdl_max[X],
					gridhor[X] * rtip->mdl_min[X]
					) +
				  max(	gridhor[Y] * rtip->mdl_max[Y],
					gridhor[Y] * rtip->mdl_min[Y]
					) +
				  max(	gridhor[Z] * rtip->mdl_max[Z],
					gridhor[Z] * rtip->mdl_min[Z]
					);
			modllf = min(	gridhor[X] * rtip->mdl_max[X],
					gridhor[X] * rtip->mdl_min[X]
					) +
				  min(	gridhor[Y] * rtip->mdl_max[Y],
					gridhor[Y] * rtip->mdl_min[Y]
					) +
				  min(	gridhor[Z] * rtip->mdl_max[Z],
					gridhor[Z] * rtip->mdl_min[Z]
					);
			modlup = max(	gridver[X] * rtip->mdl_max[X],
					gridver[X] * rtip->mdl_min[X]
					) +
				  max(	gridver[Y] * rtip->mdl_max[Y],
					gridver[Y] * rtip->mdl_min[Y]
					) +
				  max(	gridver[Z] * rtip->mdl_max[Z],
					gridver[Z] * rtip->mdl_min[Z]
					);
			modldn = min(	gridver[X] * rtip->mdl_max[X],
					gridver[X] * rtip->mdl_min[X]
					) +
				  min(	gridver[Y] * rtip->mdl_max[Y],
					gridver[Y] * rtip->mdl_min[Y]
					) +
				  min(	gridver[Z] * rtip->mdl_max[Z],
					gridver[Z] * rtip->mdl_min[Z]
				);
			}
		else
			{
			modlrt = gridrt;
			modllf = gridlf;
			modlup = gridup;
			modldn = griddn;
			}
		}
	gridxorg = gridlf / cellsz;
	gridxfin = gridrt / cellsz;
	gridyorg = griddn / cellsz;
	gridyfin = gridup / cellsz;

	/* allow for randomization of cells */
	if( dithercells )
		{
		gridxorg--;
		gridxfin++;
		gridyorg--;
		gridyfin++;
		}
#if DEBUG_SHOT
	brst_log( "gridInit: xorg,xfin,yorg,yfin=%d,%d,%d,%d\n",
		gridxorg, gridxfin, gridyorg, gridyfin );
	brst_log( "gridInit: left,right,down,up=%g,%g,%g,%g\n",
		gridlf, gridrt, griddn, gridup );
#endif

	/* compute stand-off distance */
	standoff = max(	viewdir[X] * rtip->mdl_max[X],
			viewdir[X] * rtip->mdl_min[X]
			) +
		  max(	viewdir[Y] * rtip->mdl_max[Y],
			viewdir[Y] * rtip->mdl_min[Y]
			) +
		  max(	viewdir[Z] * rtip->mdl_max[Z],
			viewdir[Z] * rtip->mdl_min[Z]
			);

	/* determine largest grid dimension for frame buffer display */
	gridwidth  = gridxfin - gridxorg + 1;
	gridheight = gridyfin - gridyorg + 1;
	gridsz = Max( gridwidth, gridheight );

	/* vector to grid origin from model origin */
	Scale2Vec( viewdir, standoff, gridsoff );

	/* direction of grid rays */
	ScaleVec( viewdir, -1.0 );

	prntTimer( "grid" );
	notify( NULL, NOTIFY_DELETE );
	return;
	}

/*
	void gridModel( void )

	This routine dispatches the top-level ray tracing task.	
 */
void
gridModel()
	{
	ag.a_onehit = false;
	ag.a_overlap = reportoverlaps ? f_Overlap : f_HushOverlap;
	ag.a_logoverlap = rt_silent_logoverlap;
	ag.a_rt_i = rtip;
	if( ! TSTBIT(firemode,FM_BURST) )
		{ /* set up for shotlines */
		ag.a_hit = f_ShotHit;
		ag.a_miss = f_ShotMiss;
		}

	plotInit();	/* initialize plot file if appropriate */

	if( ! imageInit() ) /* initialize frame buffer if appropriate */
		{
		warning( "Error: problem opening frame buffer." );
		return;
		}
	/* output initial line for this aspect */
	prntAspectInit();

	fatalerror = false;
	userinterrupt = false;	/* set by interrupt handler */

	rt_prep_timer();
	notify( "Raytracing", NOTIFY_ERASE );

	if( TSTBIT(firemode,FM_BURST) )  {
		if( ! doBursts() )
			return;
		else
			goto	endvu;
	}

	/* get starting and ending shot number */
	currshot = 0;
	lastshot = gridwidth * gridheight - 1;

	/* SERIAL case -- one CPU does all the work */
	if( ! gridShot() )
		return;
endvu:	view_end();
	return;
	}

/*
	bool gridShot( void )

	This routine is the grid-level raytracing task; suitable for a
	multi-tasking process.  Return code of false would indicate a
	failure in the application routine given to rt_shootray() or an
	error or EOF in getting the next set of firing coordinates.
 */
STATIC bool
gridShot()
	{	bool status = true;
		struct application a;
	a = ag;
	a.a_resource = RESOURCE_NULL;

	assert( a.a_hit == ag.a_hit );
	assert( a.a_miss == ag.a_miss );
	assert( a.a_overlap == ag.a_overlap );
	assert( a.a_rt_i == ag.a_rt_i );
	assert( a.a_onehit == ag.a_onehit );
	a.a_user = 0;
	a.a_purpose = "shotline";
	prntGridOffsets( gridxorg, gridyorg );
	noverlaps = 0;
	for( ; ! userinterrupt; view_pix( &a ) )
		{
		if( ! TSTBIT(firemode,FM_SHOT) && currshot > lastshot )
			break;
		if( ! (status = getRayOrigin( &a )) || status == EOF )
			break;
		currshot++;
		prntFiringCoords( a.a_uvec );
		CopyVec( a.a_ray.r_dir, viewdir );
		a.a_level = 0;	 /* initialize recursion level */
		plotGrid( a.a_ray.r_pt );
		if( rt_shootray( &a ) == -1 && fatalerror )
			{
			/* fatal error in application routine */
			brst_log( "Fatal error: raytracing aborted.\n" );
			return	false;
			}
		if( ! TSTBIT(firemode,FM_FILE) && TSTBIT(firemode,FM_SHOT) )
			{
			view_pix( &a );
			break;
			}
		}
	return	status == EOF ? true : status;
	}

/*
	void lgtModel( register struct application *ap, struct partition *pp,
			struct hit *hitp, struct xray *rayp,
			fastf_t surfnorm[3] )

	This routine is a simple lighting model which places RGB coefficients
	(0 to 1) in ap->a_color based on the cosine of the angle between
	the surface normal and viewing direction and the color associated with
	the component.  Also, the distance to the surface is placed in
	ap->a_cumlen so that the impact location can be projected into grid
	space.
 */
STATIC void
lgtModel( ap, pp, hitp, rayp, surfnorm )
register struct application *ap;
struct partition *pp;
struct hit *hitp;
struct xray *rayp;
fastf_t surfnorm[3];
	{	Colors  *colorp;
		fastf_t intensity = -Dot( viewdir, surfnorm );
	if( intensity < 0.0 )
		intensity = -intensity;

	if(	(colorp =
		findColors( pp->pt_regionp->reg_regionid, &colorids ))
		!= COLORS_NULL
		)
		{
		ap->a_color[RED] = (fastf_t)colorp->c_rgb[RED]/255.0;
		ap->a_color[GRN] = (fastf_t)colorp->c_rgb[GRN]/255.0;
		ap->a_color[BLU] = (fastf_t)colorp->c_rgb[BLU]/255.0;
		}
	else
		ap->a_color[RED] =
		ap->a_color[GRN] =
		ap->a_color[BLU] = 1.0;
	ScaleVec( ap->a_color, intensity );
	ap->a_cumlen = hitp->hit_dist;
	}

/*
	fastf_t max( fastf_t a, fastf_t b )

	Returns the maximum of a and b.  Useful when a macro would
	cause side-effects or redundant computation.
 */
STATIC fastf_t
max( a, b )
fastf_t	a, b;
	{
	return	Max( a, b );
	}

/*
	fastf_t min( fastf_t a, fastf_t b )

	Returns the minimum of a and b.  Useful when a macro would
	cause side-effects or redundant computation.
 */
STATIC fastf_t
min( a, b )
fastf_t	a, b;
	{
	return	Min( a, b );
	}

/*
	int readBurst( register fastf_t *vec )

	This routine reads the next set of burst point coordinates from the
	input stream burstfp.  Returns true for success, false for a format
	error and EOF for normal end-of-file.  If false is returned,
	fatalerror will be set to true.
 */
STATIC int
readBurst( vec )
register fastf_t	*vec;
	{	int	items;
	assert( burstfp != (FILE *) NULL );
	/* read 3D firing coordinates from input stream */
	if( (items =
#if SINGLE_PRECISION
	     fscanf( burstfp, "%f %f %f", &vec[X], &vec[Y], &vec[Z] )) != 3 )
#else
	     fscanf( burstfp, "%lf %lf %lf", &vec[X], &vec[Y], &vec[Z] )) != 3 )
#endif
		{
		if( items != EOF )
			{
			brst_log( "Fatal error: %d burst coordinates read.\n",
				items );
			fatalerror = true;
			return	false;
			}
		else
			return	EOF;
		}
	else
		{
		vec[X] /= unitconv;
		vec[Y] /= unitconv;
		vec[Z] /= unitconv;
		}
	return	true;
	}

/*
	int readShot( register fastf_t *vec )

	This routine reads the next set of firing coordinates from the
	input stream shotfp, using the format selected by the firemode
	bitflag.  Returns true for success, false for a format error and EOF
	for normal end-of-file.  If false is returned, fatalerror will be
	set to true.
 */
STATIC int
readShot( vec )
register fastf_t	*vec;
	{
	assert( shotfp != (FILE *) NULL );
	if( ! TSTBIT(firemode,FM_3DIM) ) /* absence of 3D flag means 2D */
		{	int	items;
		/* read 2D firing coordinates from input stream */
		if( (items =
#if SINGLE_PRECISION
		     fscanf( shotfp, "%f %f", &vec[X], &vec[Y] )) != 2 )
#else
		     fscanf( shotfp, "%lf %lf", &vec[X], &vec[Y] )) != 2 )
#endif
			{
			if( items != EOF )
				{
				brst_log( "Fatal error: only %d firing coordinates read.\n", items );
				fatalerror = true;
				return	false;
				}
			else
				return	EOF;
			}
		else
			{
			vec[X] /= unitconv;
			vec[Y] /= unitconv;
			}
		}
	else
	if( TSTBIT(firemode,FM_3DIM) ) /* 3D coordinates */
		{	int	items;
		/* read 3D firing coordinates from input stream */
		if( (items =
#if SINGLE_PRECISION
		     fscanf( shotfp, "%f %f %f", &vec[X], &vec[Y], &vec[Z] )) != 3 )
#else
		     fscanf( shotfp, "%lf %lf %lf", &vec[X], &vec[Y], &vec[Z] )) != 3 )
#endif

			{
			if( items != EOF )
				{
				brst_log( "Fatal error: %d firing coordinates read.\n", items );
				fatalerror = true;
				return	false;
				}
			else
				return	EOF;
			}
		else
			{
			vec[X] /= unitconv;
			vec[Y] /= unitconv;
			vec[Z] /= unitconv;
			}
		}
	else
		{
		brst_log( "BUG: readShot called with bad firemode.\n" );
		return	false;
		}
	return	true;
	}

/*
	int roundToInt( fastf_t f )

	RETURN CODES: the nearest integer to f.
 */
int roundToInt( fastf_t f )
	{	register int a;
	a = f;
	if( f - a >= 0.5 )
		return	a + 1;
	else
		return	a;
	}

/*
	void spallInit( void )

	Burst grid initialization routine; should be called once per view.
	Does some one-time computation for current bursting parameters; the
	following globals are filled in:

		delta		-- the target ray delta angle
		phiinc		-- the actual angle between concentric rings
		raysolidangle	-- the average solid angle per spall ray

	Determines actual number of sampling rays yielded by the even-
	distribution algorithm from the number requested.
 */
void
spallInit()
	{	fastf_t	theta;	 /* solid angle of spall sampling cone */
		fastf_t phi;	 /* angle between ray and cone axis */
		fastf_t philast; /* guard against floating point error */
		int spallct = 0; /* actual no. of sampling rays */
		int n;
	if( nspallrays < 1 )
		{
		delta = 0.0;
		phiinc = 0.0;
		raysolidangle = 0.0;
		brst_log( "%d sampling rays\n", spallct );
		return;
		}

	/* Compute sampling cone of rays which are equally spaced. */
	theta = TWO_PI * (1.0 - cos( conehfangle )); /* solid angle */
	delta = sqrt( theta/nspallrays ); /* angular ray delta */
	n = conehfangle / delta;
	phiinc = conehfangle / n;
	philast = conehfangle + EPSILON;
	/* Crank through spall cone generation once to count actual number
		generated.
	 */
	for( phi = 0.0; phi <= philast; phi += phiinc )
		{	fastf_t	sinphi = sin( phi );
			fastf_t	gamma, gammainc, gammalast;
			int m;
		sinphi = Abs( sinphi );
		m = (TWO_PI * sinphi)/delta + 1;
		gammainc = TWO_PI / m;
		gammalast = TWO_PI-gammainc+EPSILON;
		for( gamma = 0.0; gamma <= gammalast; gamma += gammainc )
			spallct++;
		}
	raysolidangle = theta / spallct;
	brst_log( "Solid angle of sampling cone = %g\n", theta );
	brst_log( "Solid angle per sampling ray = %g\n", raysolidangle );
	brst_log( "%d sampling rays\n", spallct );
	return;
	}

/* To facilitate one-time per burst point initialization of the spall
	ray application structure while leaving burstRay() with the
	capability of being used as a multitasking process, a_burst must
	be accessible by both the burstPoint() and burstRay() routines, but
	can be local to this module. */
static struct application	a_burst; /* prototype spall ray */

/*
	int burstPoint( register struct application *ap,
			register fastf_t *normal, register fastf_t *bpt )

	This routine dispatches the burst point ray tracing task burstRay().
	RETURN CODES:	false for fatal ray tracing error, true otherwise.
 */
STATIC bool
burstPoint( ap, normal, bpt )
register struct application *ap;
register fastf_t *normal;
register fastf_t *bpt; /* burst point coordinates */
	{
	a_burst = *ap;
	a_burst.a_miss = f_BurstMiss;
	a_burst.a_hit = f_BurstHit;
	a_burst.a_level++;
	a_burst.a_user = 0; /* ray number */
	a_burst.a_purpose = "spall ray";
	assert( a_burst.a_overlap == ap->a_overlap );
	
	/* If pitch or yaw is specified, cant the main penetrator
		axis. */
	if( cantwarhead )
		{
		AddVec( a_burst.a_ray.r_dir, cantdelta );
		V_Length( a_burst.a_ray.r_dir, 1.0 );
		}
	/* If a deflected cone is specified (the default) the spall cone
		axis is half way between the main penetrator axis and exit
		normal of the spalling component.
	 */
	if( deflectcone )
		{
		AddVec( a_burst.a_ray.r_dir, normal );
		V_Length( a_burst.a_ray.r_dir, 1.0 );
		}
	CopyVec( a_burst.a_ray.r_pt, bpt );

	comphi = 0.0; /* Initialize global for concurrent access. */
		
	/* SERIAL case -- one CPU does all the work. */
	return	burstRay();
	}

STATIC bool
burstRay()
	{ /* Need local copy of all but readonly variables for concurrent
		threads of execution. */
		struct application	a_spall;
		fastf_t			phi;
		bool			hitcrit = false;
	a_spall = a_burst;
	a_spall.a_resource = RESOURCE_NULL;
	for( ; ! userinterrupt; )
		{	fastf_t	sinphi;
			fastf_t	gamma, gammainc, gammalast;
			register int done;
			int m;
		bu_semaphore_acquire( RT_SEM_WORKER );
		phi = comphi;
		comphi += phiinc;
		done = phi > conehfangle;
		bu_semaphore_release( RT_SEM_WORKER );
		if( done )
			break;
		sinphi = sin( phi );
		sinphi = Abs( sinphi );
		m = (TWO_PI * sinphi)/delta + 1;
		gammainc = TWO_PI / m;
		gammalast = TWO_PI - gammainc + EPSILON;
		for( gamma = 0.0; gamma <= gammalast; gamma += gammainc )
			{	register int	ncrit;
			spallVec( a_burst.a_ray.r_dir, a_spall.a_ray.r_dir,
				 phi, gamma );
			plotRay( &a_spall.a_ray );
			bu_semaphore_acquire( RT_SEM_WORKER );
			a_spall.a_user = a_burst.a_user++;
			bu_semaphore_release( RT_SEM_WORKER );
			if(	(ncrit = rt_shootray( &a_spall )) == -1
			     &&	fatalerror )
				{
				/* Fatal error in application routine. */
				brst_log( "Error: ray tracing aborted.\n" );
				return	false;
				}
			if( fbfile[0] != NUL && ncrit > 0 )
				{
				paintSpallFb( &a_spall );
				hitcrit = true;
				}
			if( histfile[0] != NUL )
				{
				bu_semaphore_acquire( BU_SEM_SYSCALL );
				(void) fprintf( histfp, "%d\n", ncrit );
				bu_semaphore_release( BU_SEM_SYSCALL );
				}
			}
		}
	if( fbfile[0] != NUL )
		{
		if( hitcrit )
			paintCellFb( &a_spall, pixcrit, pixtarg );
		else
			paintCellFb( &a_spall, pixbhit, pixtarg );
		}
	return	true;
	}

STATIC void
spallVec( dvec, s_rdir, phi, gamma )
register fastf_t	*dvec, *s_rdir;
fastf_t			phi, gamma;
	{	fastf_t			cosphi = cos( phi );
		fastf_t			singamma = sin( gamma );
		fastf_t			cosgamma = cos( gamma );
		fastf_t			csgaphi, ssgaphi;
		fastf_t			sinphi = sin( phi );
		fastf_t			cosdphi[3];
		fastf_t			fvec[3];
		fastf_t			evec[3];

	if(	AproxEqVec( dvec, zaxis, VEC_TOL )
	    ||	AproxEqVec( dvec, negzaxis, VEC_TOL )
		)
		{
		CopyVec( evec, xaxis );
		}
	else
		{
		CrossProd( dvec, zaxis, evec );
		}
	CrossProd( evec, dvec, fvec );
	Scale2Vec( dvec, cosphi, cosdphi );
	ssgaphi = singamma * sinphi;
	csgaphi = cosgamma * sinphi;
	VJOIN2( s_rdir, cosdphi, ssgaphi, evec, csgaphi, fvec );
	V_Length( s_rdir, 1.0 ); /* unitize */
	return;
	}

/*	c o n s _ V e c t o r ( )
	Construct a direction vector out of azimuth and elevation angles
	in radians, allocating storage for it and returning its address.
 */
STATIC void
consVector( vec, azim, elev )
register fastf_t	*vec;
fastf_t	azim, elev;
	{ /* Store cosine of the elevation to save calculating twice. */
		fastf_t	cosE;
	cosE = cos( elev );
	vec[0] = cos( azim ) * cosE;
	vec[1] = sin( azim ) * cosE;
	vec[2] = sin( elev );
	return;
	}

#if STD_SIGNAL_DECLS
/*ARGSUSED*/
void
#else
int
#endif
abort_RT( sig )
int	sig;
	{
	(void) signal( SIGINT, abort_RT );
	userinterrupt = 1;
#if STD_SIGNAL_DECLS
	return;
#else
	return	sig;
#endif
	}

#if 0
/*	i p o w ( )
	Integer exponent pow() function.
	Returns d to the nth power.
 */
STATIC fastf_t
ipow( d, n )
register fastf_t	d;
register int	n;
	{	register fastf_t	result = 1.0;
	if( d == 0.0 )
		return	0.0;
	while( n-- > 0 )
		result *= d;
	return	result;
	}
#endif

/*	v i e w _ p i x ( ) */
STATIC void
view_pix( ap )
register struct application	*ap;
	{
	bu_semaphore_acquire( BU_SEM_SYSCALL );
	if( ! TSTBIT(firemode,FM_BURST) )
		prntGridOffsets( ap->a_x, ap->a_y );
	if( tty )
		prntTimer( NULL );
	bu_semaphore_release( BU_SEM_SYSCALL );
	return;
	}

/*	v i e w _ e n d ( ) */
STATIC void
view_end()
	{
	if( gridfile[0] != NUL )
		(void) fflush( gridfp );
	if( histfile[0] != NUL )
		(void) fflush( histfp );
	if( plotfile[0] != NUL )
		(void) fflush( plotfp );
	if( outfile[0] != NUL )
		(void) fflush( outfp );
	if( shotlnfile[0] != NUL )
		(void) fflush( shotlnfp );
	prntTimer( "view" );
	if( noverlaps > 0 )
		brst_log( "%d overlaps detected over %g mm thick.\n",
			noverlaps, OVERLAP_TOL );
	return;
	}
@


1.25
log
@merge of ansi-6-0-branch into HEAD
@
text
@d8 1
a8 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


1.24
log
@Modified round() to be roundToInt() to better describe what the function does, and to avoid clashing with a system round that may return a floating point value (macosx)
@
text
@d8 1
a8 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/burst/grid.c,v 1.23 2001/10/17 07:40:00 morrison Exp $ (BRL)";
d1538 1
a1538 2
int roundToInt( f )
fastf_t	f;
@


1.23
log
@Mac OS X warning and error fixes for non-production build
@
text
@d8 1
a8 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/burst/grid.c,v 1.22 2000/11/20 13:25:46 jra Exp $ (BRL)";
d1534 1
a1534 1
	int round( fastf_t f )
d1538 1
a1538 1
int round( f )
@


1.23.6.1
log
@sync to HEAD...
@
text
@d8 1
a8 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/burst/grid.c,v 1.24 2002/10/22 23:04:36 morrison Exp $ (BRL)";
d1534 1
a1534 1
	int roundToInt( fastf_t f )
d1538 1
a1538 1
int roundToInt( f )
@


1.23.4.1
log
@changed the name of the double->int round routine to fround so not to conflict with the system round call that does double->double
@
text
@d8 1
a8 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/burst/grid.c,v 1.23 2001/10/17 07:40:00 morrison Exp $ (BRL)";
d1538 1
a1538 1
int fround( f )
@


1.23.4.2
log
@sync branch with HEAD
@
text
@d8 1
a8 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d1534 1
a1534 1
	int roundToInt( fastf_t f )
d1538 2
a1539 1
int roundToInt( fastf_t f )
@


1.22
log
@Added line to set logoverap
@
text
@d8 1
a8 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/burst/grid.c,v 1.21 2000/09/06 20:12:41 mike Exp $ (BRL)";
d1538 1
a1538 2
int
round( f )
@


1.21
log
@
lint
@
text
@d8 1
a8 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/burst/grid.c,v 1.20 2000/08/24 23:12:43 mike Exp $ (BRL)";
d1259 1
@


1.20
log
@
RCSid
@
text
@d8 1
a8 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/burst/grid.c,v 1.19 2000/01/31 16:32:50 jra Exp $ (BRL)";
d26 1
d28 1
d31 1
d1282 1
a1282 1
	if( TSTBIT(firemode,FM_BURST) )
d1287 1
d1788 1
d1804 1
@


1.19
log
@Eliminated some unused variables
@
text
@d8 1
a8 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/burst/grid.c,v 1.18 1998/06/23 18:20:40 jra Exp $ (BRL)";
@


1.19.2.1
log
@Added line to set logoverlap as suggested by Tom Browder
@
text
@d8 1
a8 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/burst/grid.c,v 1.19 2000/01/31 16:32:50 jra Exp $ (BRL)";
a1255 1
	ag.a_logoverlap = rt_silent_logoverlap;
@


1.18
log
@convert bu_log to brst_log to avoid conflicts
@
text
@d8 1
a8 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/burst/grid.c,v 1.17 1998/03/27 07:07:20 mike Exp $ (BRL)";
d601 1
a601 2
				{ fastf_t slos = np->pt_outhit->hit_dist -
						np->pt_inhit->hit_dist;
a1658 1
		fastf_t			nrings = conehfangle / phiinc;
@


1.17
log
@Changed to RT_HIT_NORMAL.
@
text
@d8 1
a8 1
static char RCSid[] = "@@(#)$Header: /m/cad/burst/RCS/grid.c,v 1.16 1998/03/26 08:09:30 mike Exp mike $ (BRL)";
d123 1
a123 1
		bu_log( "colorPartition: bad type %d.\n", type );
d158 1
a158 1
			bu_log( "Fatal error: raytracing aborted.\n" );
d355 2
a356 2
		bu_log( "OVERLAP:\n" );
		bu_log( "reg=%s isol=%s,\n",
d359 1
a359 1
		bu_log( "reg=%s osol=%s,\n",
d362 1
a362 1
		bu_log( "depth %.2fmm at (%g,%g,%g) x%d y%d lvl%d purpose=%s\n",
d407 1
a407 1
	bu_log( "f_ShotHit\n" );
d409 1
a409 1
		bu_log( "\tregion is '%s',\tid=%d\taircode=%d\n",
d458 1
a458 1
			bu_log( "\tprocessing region '%s',\tid=%d\taircode=%d\n",
d462 1
a462 1
			bu_log( "\tcheck for voids\n" );
d467 1
a467 1
			bu_log( "\tlos=%g tolerance=%g\n",
d476 1
a476 1
				bu_log( "\t\toutside air\n" );
d510 1
a510 1
			bu_log( "\tmerging inside airs\n" );
d535 1
a535 1
			bu_log( "\tphantom armor before internal air\n" );
d571 1
a571 1
			bu_log( "\twe have a component\n" );
d585 1
a585 1
				bu_log( "\t\tthere is a void, %s\n",
d605 1
a605 1
				bu_log( "\t\texplicit air follows\n" );
d626 1
a626 1
				bu_log( "\t\tlast component\n" );
d636 1
a636 1
				bu_log( "\t\tmerging adjacent components\n" );
d648 1
a648 1
				bu_log( "\t\tdifferent component follows\n" );
d660 1
a660 1
			bu_log( "\tcheck for adjacency of differing airs; inside air\n" );
d670 1
a670 1
			bu_log( "\tcheck next partition for adjacency\n" );
d678 1
a678 1
				bu_log( "\t\tinside air follows impl. outside air\n" );
d693 1
a693 1
				bu_log( "\t\tdiffering airs are adjacent\n" );
d704 1
a704 1
			bu_log( "\tinternal air last hit\n" );
d782 2
a783 2
		bu_log( "chkEntryNorm: near 90 degree obliquity.\n" );
		bu_log( "\tPnt %g,%g,%g\n\tDir %g,%g,%g\n\tNorm %g,%g,%g.\n",
d793 2
a794 2
		bu_log( "Fixed flipped entry normal:\n" );
		bu_log( "\tregion \"%s\" solid \"%s\" type %d \"%s\".\n",
d798 1
a798 1
		bu_log( "\tPnt %g,%g,%g\n\tDir %g,%g,%g\n\tNorm %g,%g,%g.\n",
d802 1
a802 1
		bu_log( "\tDist %g Hit Pnt %g,%g,%g\n",
d807 1
a807 1
		bu_log( "\t%d of %d normals flipped.\n", flipct, totalct );
d832 2
a833 2
		bu_log( "chkExitNorm: near 90 degree obliquity.\n" );
		bu_log( "\tPnt %g,%g,%g\n\tDir %g,%g,%g\n\tNorm %g,%g,%g.\n",
d843 2
a844 2
		bu_log( "Fixed flipped exit normal:\n" );
		bu_log( "\tregion \"%s\" solid \"%s\" type %d \"%s\".\n",
d848 1
a848 1
		bu_log( "\tPnt %g,%g,%g\n\tDir %g,%g,%g\n\tNorm %g,%g,%g.\n",
d852 1
a852 1
		bu_log( "\tDist %g Hit Pnt %g,%g,%g\n",
d857 1
a857 1
		bu_log( "\t%d of %d normals flipped.\n", flipct, totalct );
d910 1
a910 1
				bu_log( "User error: %s %s.\n",
d1036 1
a1036 1
		bu_log( "gridInit: reading burst points.\n" );
d1039 1
a1039 1
			bu_log( "gridInit: shooting discrete shots.\n" );
d1041 1
a1041 1
			bu_log( "gridInit: shooting %s.\n",
d1047 1
a1047 1
		bu_log( "gridInit: reading %s coordinates from %s.\n",
d1054 1
a1054 1
		bu_log( "BUG: insane combination of fire mode bits:0x%x\n",
d1066 1
a1066 1
		bu_log( scrbuf );
d1077 1
a1077 1
		bu_log( "gridInit: canting warhead\n" );
d1214 1
a1214 1
	bu_log( "gridInit: xorg,xfin,yorg,yfin=%d,%d,%d,%d\n",
d1216 1
a1216 1
	bu_log( "gridInit: left,right,down,up=%g,%g,%g,%g\n",
d1335 1
a1335 1
			bu_log( "Fatal error: raytracing aborted.\n" );
d1437 1
a1437 1
			bu_log( "Fatal error: %d burst coordinates read.\n",
d1480 1
a1480 1
				bu_log( "Fatal error: only %d firing coordinates read.\n", items );
d1507 1
a1507 1
				bu_log( "Fatal error: %d firing coordinates read.\n", items );
d1523 1
a1523 1
		bu_log( "BUG: readShot called with bad firemode.\n" );
d1571 1
a1571 1
		bu_log( "%d sampling rays\n", spallct );
d1596 3
a1598 3
	bu_log( "Solid angle of sampling cone = %g\n", theta );
	bu_log( "Solid angle per sampling ray = %g\n", raysolidangle );
	bu_log( "%d sampling rays\n", spallct );
d1693 1
a1693 1
				bu_log( "Error: ray tracing aborted.\n" );
d1832 1
a1832 1
		bu_log( "%d overlaps detected over %g mm thick.\n",
@


1.16
log
@a_hit has an extra arg.
@
text
@d8 1
a8 1
static char RCSid[] = "@@(#)$Header: /m/cad/burst/RCS/grid.c,v 1.15 1997/12/16 03:45:56 mike Exp mike $ (BRL)";
d762 1
a762 6
	RT_HIT_NORM( hitp, stp, rayp );
	CopyVec( normvec, hitp->hit_normal ); 
	if( flipped )
		{
		ScaleVec( normvec, -1.0 );
		}
@


1.15
log
@UPgraded using h/sed4
@
text
@d8 1
a8 1
static char RCSid[] = "@@(#)$Header: /m/cad/burst/RCS/grid.c,v 1.14 1996/12/31 17:37:34 jra Exp mike $ (BRL)";
d206 1
a206 1
f_BurstHit( ap, pt_headp )
d209 1
d399 1
a399 1
f_ShotHit( ap, pt_headp )
d402 1
@


1.14
log
@minor mod for Solaris.
@
text
@d8 1
a8 1
static char RCSid[] = "@@(#)$Header: /m/cad/burst/RCS/grid.c,v 1.13 1993/12/15 11:46:16 moss Exp jra $ (BRL)";
d87 1
a87 1
	RES_ACQUIRE( &rt_g.res_syscall );
d123 1
a123 1
		rt_log( "colorPartition: bad type %d.\n", type );
d126 1
a126 1
	RES_RELEASE( &rt_g.res_syscall );
d158 1
a158 1
			rt_log( "Fatal error: raytracing aborted.\n" );
d354 2
a355 2
		rt_log( "OVERLAP:\n" );
		rt_log( "reg=%s isol=%s,\n",
d358 1
a358 1
		rt_log( "reg=%s osol=%s,\n",
d361 1
a361 1
		rt_log( "depth %.2fmm at (%g,%g,%g) x%d y%d lvl%d purpose=%s\n",
d405 1
a405 1
	rt_log( "f_ShotHit\n" );
d407 1
a407 1
		rt_log( "\tregion is '%s',\tid=%d\taircode=%d\n",
d456 1
a456 1
			rt_log( "\tprocessing region '%s',\tid=%d\taircode=%d\n",
d460 1
a460 1
			rt_log( "\tcheck for voids\n" );
d465 1
a465 1
			rt_log( "\tlos=%g tolerance=%g\n",
d474 1
a474 1
				rt_log( "\t\toutside air\n" );
d508 1
a508 1
			rt_log( "\tmerging inside airs\n" );
d533 1
a533 1
			rt_log( "\tphantom armor before internal air\n" );
d569 1
a569 1
			rt_log( "\twe have a component\n" );
d583 1
a583 1
				rt_log( "\t\tthere is a void, %s\n",
d603 1
a603 1
				rt_log( "\t\texplicit air follows\n" );
d624 1
a624 1
				rt_log( "\t\tlast component\n" );
d634 1
a634 1
				rt_log( "\t\tmerging adjacent components\n" );
d646 1
a646 1
				rt_log( "\t\tdifferent component follows\n" );
d658 1
a658 1
			rt_log( "\tcheck for adjacency of differing airs; inside air\n" );
d668 1
a668 1
			rt_log( "\tcheck next partition for adjacency\n" );
d676 1
a676 1
				rt_log( "\t\tinside air follows impl. outside air\n" );
d691 1
a691 1
				rt_log( "\t\tdiffering airs are adjacent\n" );
d702 1
a702 1
			rt_log( "\tinternal air last hit\n" );
d785 2
a786 2
		rt_log( "chkEntryNorm: near 90 degree obliquity.\n" );
		rt_log( "\tPnt %g,%g,%g\n\tDir %g,%g,%g\n\tNorm %g,%g,%g.\n",
d796 2
a797 2
		rt_log( "Fixed flipped entry normal:\n" );
		rt_log( "\tregion \"%s\" solid \"%s\" type %d \"%s\".\n",
d801 1
a801 1
		rt_log( "\tPnt %g,%g,%g\n\tDir %g,%g,%g\n\tNorm %g,%g,%g.\n",
d805 1
a805 1
		rt_log( "\tDist %g Hit Pnt %g,%g,%g\n",
d810 1
a810 1
		rt_log( "\t%d of %d normals flipped.\n", flipct, totalct );
d835 2
a836 2
		rt_log( "chkExitNorm: near 90 degree obliquity.\n" );
		rt_log( "\tPnt %g,%g,%g\n\tDir %g,%g,%g\n\tNorm %g,%g,%g.\n",
d846 2
a847 2
		rt_log( "Fixed flipped exit normal:\n" );
		rt_log( "\tregion \"%s\" solid \"%s\" type %d \"%s\".\n",
d851 1
a851 1
		rt_log( "\tPnt %g,%g,%g\n\tDir %g,%g,%g\n\tNorm %g,%g,%g.\n",
d855 1
a855 1
		rt_log( "\tDist %g Hit Pnt %g,%g,%g\n",
d860 1
a860 1
		rt_log( "\t%d of %d normals flipped.\n", flipct, totalct );
d913 1
a913 1
				rt_log( "User error: %s %s.\n",
d1039 1
a1039 1
		rt_log( "gridInit: reading burst points.\n" );
d1042 1
a1042 1
			rt_log( "gridInit: shooting discrete shots.\n" );
d1044 1
a1044 1
			rt_log( "gridInit: shooting %s.\n",
d1050 1
a1050 1
		rt_log( "gridInit: reading %s coordinates from %s.\n",
d1057 1
a1057 1
		rt_log( "BUG: insane combination of fire mode bits:0x%x\n",
d1069 1
a1069 1
		rt_log( scrbuf );
d1080 1
a1080 1
		rt_log( "gridInit: canting warhead\n" );
d1217 1
a1217 1
	rt_log( "gridInit: xorg,xfin,yorg,yfin=%d,%d,%d,%d\n",
d1219 1
a1219 1
	rt_log( "gridInit: left,right,down,up=%g,%g,%g,%g\n",
d1338 1
a1338 1
			rt_log( "Fatal error: raytracing aborted.\n" );
d1440 1
a1440 1
			rt_log( "Fatal error: %d burst coordinates read.\n",
d1483 1
a1483 1
				rt_log( "Fatal error: only %d firing coordinates read.\n", items );
d1510 1
a1510 1
				rt_log( "Fatal error: %d firing coordinates read.\n", items );
d1526 1
a1526 1
		rt_log( "BUG: readShot called with bad firemode.\n" );
d1574 1
a1574 1
		rt_log( "%d sampling rays\n", spallct );
d1599 3
a1601 3
	rt_log( "Solid angle of sampling cone = %g\n", theta );
	rt_log( "Solid angle per sampling ray = %g\n", raysolidangle );
	rt_log( "%d sampling rays\n", spallct );
d1672 1
a1672 1
		RES_ACQUIRE( &rt_g.res_worker );
d1676 1
a1676 1
		RES_RELEASE( &rt_g.res_worker );
d1689 1
a1689 1
			RES_ACQUIRE( &rt_g.res_worker );
d1691 1
a1691 1
			RES_RELEASE( &rt_g.res_worker );
d1696 1
a1696 1
				rt_log( "Error: ray tracing aborted.\n" );
d1706 1
a1706 1
				RES_ACQUIRE( &rt_g.res_syscall );
d1708 1
a1708 1
				RES_RELEASE( &rt_g.res_syscall );
d1810 1
a1810 1
	RES_ACQUIRE( &rt_g.res_syscall );
d1815 1
a1815 1
	RES_RELEASE( &rt_g.res_syscall );
d1835 1
a1835 1
		rt_log( "%d overlaps detected over %g mm thick.\n",
@


1.13
log
@Added output of '2' and '3' records when inputing burst points or bursting
on the ground.
@
text
@d8 1
a8 1
static char RCSid[] = "@@(#)$Header: /vld/moss/src/burst/RCS/grid.c,v 1.12 93/12/15 08:18:30 moss Exp Locker: moss $ (BRL)";
d1379 3
a1381 3
		ap->a_color[RED] = colorp->c_rgb[RED]/255.0;
		ap->a_color[GRN] = colorp->c_rgb[GRN]/255.0;
		ap->a_color[BLU] = colorp->c_rgb[BLU]/255.0;
@


1.12
log
@Apparently added burstflag to end of ray intersect record.
@
text
@d8 1
a8 1
static char RCSid[] = "@@(#)$Header: /vld/moss/src/burst/RCS/grid.c,v 1.11 91/09/11 10:41:08 moss Exp $ (BRL)";
d153 2
d923 2
d926 1
a1649 2

	/* prntBurstHdr( bpt ); XXX print something about burst point? */
@


1.11
log
@Fixed handling of normals, was flipping them in place (in the hit struct),
now we make a private copy and flip it; required passing entry and/or
exit normals down to some functions.  The exit angle was being computed
from a reversed normal, also the sine of the fallback angle was negated.
Format of azimuth changed to 9.4f from 8.4 to allow for large negative
values (ie -270.0000).
@
text
@d8 1
a8 1
static char RCSid[] = "@@(#)$Header: /vld/moss/src/burst/RCS/grid.c,v 1.10 91/01/15 13:53:22 moss Exp $ (BRL)";
d592 1
a592 1
					entrynorm, exitnorm );
d615 1
a615 1
					entrynorm, exitnorm );
d625 1
a625 1
					entrynorm, exitnorm );
d647 1
a647 1
					entrynorm, exitnorm );
@


1.10
log
@Removed author's phone number from top of file comment.  This will be
shipped as version 2.1.
@
text
@d8 1
a8 1
static char RCSid[] = "@@(#)$Header: /vld/moss/src/burst/RCS/grid.c,v 1.9 90/08/28 12:24:09 moss Exp $ (BRL)";
d207 7
a213 4
	{	Pt_Queue			*qshield = PT_Q_NULL;
		register struct partition	*cpp, *spp;
		register int			nbar;
		register int			ncrit = 0;
d230 1
a230 1
			{
d241 1
a241 1
			prntRegionHdr( ap, pt_headp, cpp );
d247 2
a248 1
				lgtModel( ap, cpp, cpp->pt_inhit, rayp );
d270 1
d273 2
a274 1
				struct region *reg1, struct region *reg2 )
d278 7
d288 28
a315 10
f_HushOverlap( ap, pp, reg1, reg2 )
struct application	*ap;
struct partition	*pp;
struct region		*reg1, *reg2;
	{	fastf_t depth = pp->pt_outhit->hit_dist -
					pp->pt_inhit->hit_dist;
	if( depth < OVERLAP_TOL )
		return  1;
	noverlaps++;
	return	1;
d320 2
a321 1
				struct region *reg1, struct region *reg2 )
d325 7
d335 46
a380 25
f_Overlap( ap, pp, reg1, reg2 )
struct application	*ap;
struct partition	*pp;
struct region		*reg1, *reg2;
	{	point_t pt;
		fastf_t depth = pp->pt_outhit->hit_dist -
					pp->pt_inhit->hit_dist;
	if( depth < OVERLAP_TOL )
		return  1;
	VJOIN1( pt, ap->a_ray.r_pt, pp->pt_inhit->hit_dist,
		ap->a_ray.r_dir );
	rt_log( "OVERLAP:\n" );
	rt_log( "reg=%s isol=%s,\n",
		reg1->reg_name, pp->pt_inseg->seg_stp->st_name
		);
	rt_log( "reg=%s osol=%s,\n",
		reg2->reg_name, pp->pt_outseg->seg_stp->st_name
		);
	rt_log( "depth %.2fmm at (%g,%g,%g) x%d y%d lvl%d purpose=%s\n",
		depth,
		pt[X], pt[Y], pt[Z],
		ap->a_x, ap->a_y, ap->a_level, ap->a_purpose
		);
	noverlaps++;
	return	1;
d400 2
a401 1
		struct partition	*bp = PT_NULL;
d553 13
a565 1
			{
d572 1
d574 2
d587 1
a587 1
					/* Bursting on armor/void (ouchh). */
d589 4
a592 1
				prntSeg( ap, pp, OUTSIDE_AIR );
d610 1
d612 4
a615 1
				prntSeg( ap, pp, nregp->reg_aircode );
d624 2
a625 1
				prntSeg( ap, pp, EXIT_AIR );
d646 3
a648 1
				prntSeg( ap, pp, 0 ); /* component follows */
a709 2
			register struct hit *ohitp;
			register struct soltab	*stp;
d735 1
a735 6
		/* fill in hit point and normal */
		stp = bp->pt_outseg->seg_stp;
		ohitp = bp->pt_outhit;
		RT_HIT_NORM( ohitp, stp, &(ap->a_ray) );
		Check_Oflip( bp, ohitp->hit_normal, ap->a_ray.r_dir );
		return	burstPoint( ap, ohitp->hit_normal, burstpt );
d741 126
d1347 2
a1348 1
			struct hit *hitp, struct xray *rayp )
d1358 1
a1358 1
lgtModel( ap, pp, hitp, rayp )
d1363 1
d1365 1
a1365 1
		fastf_t intensity = -Dot( viewdir, hitp->hit_normal );
a1383 1
	return;
@


1.9
log
@This is the official release of version 2.0 which includes mods in the
output format to both correct a misinterpretation of the ICD, facilitate
easier postprocessing, increase precision, etc.  Also an option to not
require burst air was added.  Finally, a bug fix involving adjacent inside
airs of the same type at the beginning of a shotline was implemented.
@
text
@a5 1
			(301)278-6651 or AV-298-6651
d8 1
a8 1
static char RCSid[] = "@@(#)$Header: /vld/moss/src/burst/RCS/grid.c,v 1.8 90/08/22 09:40:00 moss Exp $ (BRL)";
@


1.8
log
@About to make some sweeping revisions.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /usr/vld/moss/src/burst/RCS/grid.c,v 1.7 89/10/31 12:20:00 moss Exp $ (BRL)";
d426 1
d432 3
a434 2
						> LOS_TOL
						)
d448 2
a449 1
			for( cp = np->pt_forw; cp != pt_headp;
d453 1
a453 2
				    &&	SameAir( np->pt_regionp,
						 cp->pt_regionp )
d456 1
a456 2
					<= LOS_TOL
					)
d468 2
d473 13
d488 2
a489 1
			prntPhantom( pp->pt_inhit, regp->reg_aircode, slos );
d492 1
a492 2
		/* If we have a component, output it. */
		if( ! Air( regp ) )
d506 2
a507 1
				rt_log( "\t\tthere is a void, so outputting 01 air\n" );
d509 5
d528 3
a530 2
				    &&	findIdents( nregp->reg_aircode,
							&airids )
d601 1
a601 1
				{ fastf_t slos = np->pt_outhit->hit_dist -
d606 2
a607 1
				prntPhantom( np->pt_inhit, nregp->reg_aircode,
@


1.7
log
@This version released to Eglin and Service Engineering after BRL-CAD '89
Symposium.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /usr/vld/moss/src/burst/RCS/grid.c,v 1.6 89/08/18 09:46:28 moss Exp $ (BRL)";
d826 12
@


1.6
log
@Fixed exterior bursting (bdist > 0.0) to burst on 1st component hit
regardless of whether or not it is designated as burst-armor, or
followed by burst-air.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /usr/vld/moss/src/burst/RCS/grid.c,v 1.5 89/07/14 12:59:37 moss Exp $ (BRL)";
d87 1
a87 1
	assert( plotfp != (FILE *) NULL );
d93 1
a93 1
			== COLORS_NULL )
a101 3
	case C_SHIELD :
		pl_color( plotfp, R_SHIELD, G_SHIELD, B_SHIELD );
		break;
d104 1
a104 1
			== COLORS_NULL )
d315 1
a315 1
	rt_log( "depth %gmm at (%g,%g,%g) x%d y%d lvl%d\n",
d318 1
a318 1
		ap->a_x, ap->a_y, ap->a_level
d624 1
a624 1
			zero. */
d1017 1
a1017 1
		{ /* set up for shot lines */
d1076 1
a1076 1
	a.a_purpose = "shot line";
@


1.5
log
@This is the pre-release copy that Bud took with him.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /usr/vld/moss/src/burst/RCS/grid.c,v 1.4 89/07/07 16:33:18 moss Exp $ (BRL)";
d484 5
d502 1
a502 1
				/* Check for burst point. */
d506 1
a506 1
				if(	bp == PT_NULL
d512 1
a512 1
					bp = pp;
d626 2
a627 2
		/* only generate burst rays if nspallrays is greater then
			zero */
@


1.4
log
@Ready for Bud's visit.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /usr/vld/moss/src/burst/RCS/grid.c,v 1.3 89/01/20 15:21:14 moss Exp $ (BRL)";
d354 1
a354 1
	prntCellIdent( ap, pt_headp );
d871 1
d908 47
@


1.3
log
@Just saving this version for backup purposes, recently added support for
explicitly inputing burst points.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /usr/vld/moss/src/burst/RCS/grid.c,v 1.2 88/11/07 17:01:40 moss Exp $ (BRL)";
d12 6
a17 1
#define DEBUG_GRID	false
d19 2
d25 1
a25 1
#include <assert.h>
d30 1
d35 3
a47 3
static fastf_t xaxis[3] = { 1.0, 0.0, 0.0 };
static fastf_t zaxis[3] = { 0.0, 0.0, 1.0 };
static fastf_t negzaxis[3] = { 0.0, 0.0, -1.0 };
d49 1
a49 1
static struct application ag; /* global application structure */
d52 20
a71 20
_LOCAL_ bool doBursts();
_LOCAL_ bool burstPoint();
_LOCAL_ bool burstRay();
_LOCAL_ bool gridShot();
_LOCAL_ fastf_t	max();
_LOCAL_ fastf_t	min();
_LOCAL_ int f_BurstHit();
_LOCAL_ int f_BurstMiss();
_LOCAL_ int f_HushOverlap();
_LOCAL_ int f_Overlap();
_LOCAL_ int f_ShotHit();
_LOCAL_ int f_ShotMiss();
_LOCAL_ int getRayOrigin();
_LOCAL_ int readBurst();
_LOCAL_ int readShot();
_LOCAL_ void consVector();
_LOCAL_ void lgtModel();
_LOCAL_ void view_end();
_LOCAL_ void view_pix();
_LOCAL_ void spallVec();
d77 2
a78 2
	the output stream 'plotfp' which represents the region specified
	by 'regp'.
d140 1
a140 1
	'rt_shootray' or an error or EOF in getting the next set of
d143 1
a143 1
_LOCAL_ bool
d151 1
a151 1
		if(	firemode & FM_FILE
d163 1
a163 1
		if( !(firemode & FM_FILE) )
d179 1
a179 1
_LOCAL_ void
d202 1
a202 1
	RETURN CODES: -1 indicates a fatal error, and 'fatalerror' will be
d207 1
a207 1
_LOCAL_ int
d226 2
a227 1
		{	register struct region	*regp = cpp->pt_regionp;
d231 15
a245 3
			{	register struct xray	*rayp = &ap->a_ray;
				register struct hit	*hitp;
			hitp = cpp->pt_inhit;
d247 2
a248 31
				{	register struct soltab	*stp;
				stp = cpp->pt_inseg->seg_stp;
				RT_HIT_NORM( hitp, stp, rayp );
				Check_Iflip( cpp, hitp->hit_normal,
						rayp->r_dir );
				rt_log( "f_BurstHit: pt=<%g,%g,%g> dir=<%g,%g,%g>\n",
					ap->a_ray.r_pt[X],
					ap->a_ray.r_pt[Y],
					ap->a_ray.r_pt[Z],
					ap->a_ray.r_dir[X],
					ap->a_ray.r_dir[Y],
					ap->a_ray.r_dir[Z] );
				rt_log( "f_BurstHit: hit pt <%g,%g,%g> dist %g\n",
					hitp->hit_point[X],
					hitp->hit_point[Y],
					hitp->hit_point[Z],
					hitp->hit_dist );
				lgtModel( ap, cpp, hitp, rayp );
				}
			else
				{
				VJOIN1( hitp->hit_point, rayp->r_pt,
					hitp->hit_dist, rayp->r_dir );
				}
			prntRegionHdr( ap, hitp, regp, nbar );
			hitp = cpp->pt_outhit;
			VJOIN1( hitp->hit_point, rayp->r_pt,
				hitp->hit_dist, rayp->r_dir );
			colorPartition( regp, C_CRIT );
			plotPartition( cpp->pt_inhit, hitp, rayp, regp );
			prntShieldComp( ap, rayp, qshield );
d251 2
a252 1
		/* Add all components to list of shielding components. */
d278 1
a278 1
_LOCAL_ int
d299 1
a299 1
_LOCAL_ int
d333 1
a333 1
	a call to 'burstPoint' which dispatches the burst ray task 'burstRay',
d337 1
a337 1
	handed to 'rt_shootray' by 'burstRay'.  Otherwise, true is returned.
d339 1
a339 1
_LOCAL_ int
a343 1
		register int		ct = 0; /* Cumulative count. */
d474 2
a475 3
			slos = pp->pt_outhit->hit_dist -
					pp->pt_inhit->hit_dist;
			prntPhantom( ap, regp->reg_aircode, slos, ++ct );
d490 1
a490 2
				prntSeg( ap, pp, false,
						OUTSIDE_AIR, los, ++ct );
a506 1
					{
d508 1
a508 8
					prntSeg( ap, pp, true,
						 nregp->reg_aircode,
						 slos, ++ct );
					}
				else
					prntSeg( ap, pp, false,
						 nregp->reg_aircode,
						 slos, ++ct );
d515 1
a515 1
				rt_log( "\t\tlast component, so outputting 09 air\n" );
d517 1
a517 2
				prntSeg( ap, pp, false,
					 EXIT_AIR, 0.0, ++ct );
d528 3
a530 2
				np->pt_inhit->hit_dist =
					pp->pt_inhit->hit_dist;
d538 1
a538 1
				prntSeg( ap, pp, false, 0, 0.0, ++ct );
d550 1
a550 1
				prntPhantom( ap, OUTSIDE_AIR, los, ++ct );
d566 2
a567 2
				prntPhantom( ap, nregp->reg_aircode,
						slos, ++ct );
d581 2
a582 2
				prntPhantom( ap, nregp->reg_aircode,
						slos, ++ct );
d591 1
a591 1
			prntPhantom( ap, EXIT_AIR, 0.0, ++ct );
d605 1
a605 1
				location is 'bdist' prior to entry point. */
d613 1
a613 1
				the magnitude of 'bdist' beyond the exit
d621 1
a621 3
		prntBurstHdr( ap, bp, bp->pt_forw, burstpt );

		/* only generate burst rays if 'nspallrays' is greater then
d643 1
a643 1
_LOCAL_ int
d658 1
d660 3
a662 1
		dist = (ap->a_ray.r_pt[Z] + hitpoint[Z]) / ap->a_ray.r_dir[Z];
d665 1
d681 4
a684 1
				rt_log( "User error: negative burst distance can not be specified with ground plane bursting.\n" );
d689 1
a689 1
			/* only burst if 'nspallrays' greater than zero */
d708 1
a708 1
_LOCAL_ int
d719 1
a719 1
	This routine fills in the ray origin 'ap->a_ray.r_pt' by folding
d721 3
a723 3
	routine include the grid offsets which are stored in 'ap->a_uvec',
	2-digit random numbers (when opted) which are stored in 'ap->a_user',
	and grid indices are stored in 'ap->a_x' and 'ap->a_y'.  Return
d727 1
a727 1
_LOCAL_ int
d733 1
a733 1
	if( firemode & FM_SHOT )
d735 1
a735 1
		if( firemode & FM_FILE )
d746 1
a746 1
		if( firemode & FM_3DIM )
d802 23
d832 3
d844 7
d854 1
a854 6
	if( firemode & FM_SHOT && firemode & FM_FILE )
		rewind( shotfp );
	else
	if( firemode & FM_BURST && firemode & FM_FILE )
		rewind( burstfp );
	if( ! (firemode & FM_PART) && ! (firemode & FM_BURST) )
d858 1
a858 1
			{
d866 5
d921 6
d966 1
a966 1
	if( ! (firemode & FM_BURST) )
d988 1
a988 1
	if( firemode & FM_BURST )
d1010 1
a1010 1
	failure in the application routine given to 'rt_shootray' or an
d1013 1
a1013 1
_LOCAL_ bool
d1015 3
a1017 2
	{	bool			status = true;
		struct application	a;
d1019 6
a1024 5
	a.a_hit = ag.a_hit;
	a.a_miss = ag.a_miss;
	a.a_overlap = ag.a_overlap;
	a.a_rt_i = ag.a_rt_i;
	a.a_onehit = ag.a_onehit;
d1031 1
a1031 1
		if( !(firemode & FM_SHOT) && currshot > lastshot )
d1046 1
a1046 1
		if( !(firemode & FM_FILE) && (firemode & FM_SHOT) )
d1060 1
a1060 1
	(0 to 1) in 'ap->a_color' based on the cosine of the angle between
d1063 1
a1063 1
	'ap->a_cumlen' so that the impact location can be projected into grid
d1066 1
a1066 1
_LOCAL_ void
d1098 1
a1098 1
	Returns the maximum of 'a' and 'b'.  Useful when a macro would
d1101 1
a1101 1
_LOCAL_ fastf_t
d1111 1
a1111 1
	Returns the minimum of 'a' and 'b'.  Useful when a macro would
d1114 1
a1114 1
_LOCAL_ fastf_t
d1125 1
a1125 1
	input stream 'burstfp'.  Returns true for success, false for a format
d1127 1
a1127 1
	'fatalerror' will be set to true.
d1129 1
a1129 1
_LOCAL_ int
d1165 1
a1165 1
	input stream 'shotfp', using the format selected by the 'firemode'
d1167 1
a1167 1
	for normal end-of-file.  If false is returned, 'fatalerror' will be
d1170 1
a1170 1
_LOCAL_ int
d1175 1
a1175 1
	if( !(firemode & FM_3DIM) ) /* absence of 3D flag means 2D */
d1201 1
a1201 1
	if( firemode & FM_3DIM ) /* 3D coordinates */
d1239 1
a1239 1
	RETURN CODES: the nearest integer to 'f'.
d1310 3
a1312 3
	ray application structure while leaving 'burstRay' with the
	capability of being used as a multitasking process, 'a_burst' must
	be accessible by both the 'burstPoint' and 'burstRay' routines, but
d1320 1
a1320 1
	This routine dispatches the burst point ray tracing task 'burstRay'.
d1323 1
a1323 1
_LOCAL_ bool
a1331 1
	a_burst.a_overlap = ap->a_overlap; /* shouldn't need this */
d1335 1
d1355 2
d1363 1
a1363 1
_LOCAL_ bool
d1428 1
a1428 1
_LOCAL_ void
d1441 2
a1442 2
	if(	AproxEqVec( dvec, zaxis, Epsilon )
	    ||	AproxEqVec( dvec, negzaxis, Epsilon )
d1464 1
a1464 1
_LOCAL_ void
d1477 1
a1477 1
#if defined( SYSV )
d1488 1
a1488 1
#if defined( SYSV )
d1497 1
a1497 1
	Returns 'd' to the 'n'th power.
d1499 1
a1499 1
_LOCAL_ fastf_t
d1512 1
a1512 1
_LOCAL_ void
d1517 1
a1517 1
	if( ! (firemode & FM_BURST) )
d1526 1
a1526 1
_LOCAL_ void
d1537 2
a1538 7
	if(	fbfile[0] != NUL
	     &&	(!(firemode & FM_SHOT) || (firemode & FM_FILE))
		)
		{
		if( closFbDevice() )
			fbiop = FBIO_NULL;
		}
@


1.2
log
@Just saving this version for fallback.
@
text
@d6 1
a6 1
			(301)278-6647 or AV-298-6647
d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /usr/vld/moss/src/burst/RCS/grid.c,v 1.1 88/10/28 17:02:18 moss Exp $ (BRL)";
a11 1
#define DEBUG_BURST	false
d18 1
d27 3
a29 3
/* Local communication with worker(). */
static int	currshot;	/* Current shot index. */
static int	lastshot;	/* Final shot index. */
d31 4
a34 4
static fastf_t	viewdir[3];	/* Direction of grid rays. */
static fastf_t	delta;		/* Angular delta ray of spall cone. */
static fastf_t	comphi;		/* Angle between ring and cone axis. */
static fastf_t	phiinc;		/* Angle between concentric rings. */
d36 6
a41 1
static fastf_t	cantdelta[3];	/* Delta ray specified by yaw and pitch.*/
d43 21
a63 1
static struct application ag;	/* Global application structure. */
d65 2
a66 14
_LOCAL_ bool	gridShot();
_LOCAL_ int	burstRay();
_LOCAL_ int	f_BurstHit();
_LOCAL_ int	f_BurstMiss();
_LOCAL_ int	f_Hit();
_LOCAL_ int	f_HushOverlap();
_LOCAL_ int	f_Miss();
_LOCAL_ int	f_Overlap();
_LOCAL_ int	f_Penetrate();
_LOCAL_ int	f_Canted_Warhead();
_LOCAL_ int	f_Warhead_Miss();
_LOCAL_ void	view_pix(), view_end();
_LOCAL_ void	spallVec();
void		consVector();
d68 4
a71 14
fastf_t
min( a, b )
fastf_t	a, b;
	{
	return	Min( a, b );
	}

fastf_t
max( a, b )
fastf_t	a, b;
	{
	return	Max( a, b );
	}

d73 3
a75 356
gridInit()
	{
	notify( "Initializing grid...", NOTIFY_APPEND );
	rt_prep_timer();

	/* Compute grid unit vectors. */
	gridRotate( viewazim, viewelev, 0.0, gridhor, gridver );

	if( yaw != 0.0 || pitch != 0.0 )
		{	fastf_t	negsinyaw = -sin( yaw );
			fastf_t	sinpitch = sin( pitch );
			fastf_t	xdeltavec[3], ydeltavec[3];
		cantwarhead = true;
		Scale2Vec( gridhor,  negsinyaw, xdeltavec );
		Scale2Vec( gridver,  sinpitch,  ydeltavec );
		Add2Vec( xdeltavec, ydeltavec, cantdelta );
		}

	/* Unit vector from origin of model toward eye. */
	consVector( viewdir, viewazim, viewelev );

	/* Compute distances from grid origin (model origin) to each
		border of grid, and grid indices at borders of grid.
	 */
	if( firemode & FM_SHOT && firemode & FM_FILE )
		rewind( shotfp );
	if( ! (firemode & FM_PART) )
		{
		gridrt = max(	gridhor[X] * rtip->mdl_max[X],
				gridhor[X] * rtip->mdl_min[X]
				) +
			  max(	gridhor[Y] * rtip->mdl_max[Y],
				gridhor[Y] * rtip->mdl_min[Y]
				) +
			  max(	gridhor[Z] * rtip->mdl_max[Z],
				gridhor[Z] * rtip->mdl_min[Z]
				);
		gridlf = min(	gridhor[X] * rtip->mdl_max[X],
				gridhor[X] * rtip->mdl_min[X]
				) +
			  min(	gridhor[Y] * rtip->mdl_max[Y],
				gridhor[Y] * rtip->mdl_min[Y]
				) +
			  min(	gridhor[Z] * rtip->mdl_max[Z],
				gridhor[Z] * rtip->mdl_min[Z]
				);
		gridup = max(	gridver[X] * rtip->mdl_max[X],
				gridver[X] * rtip->mdl_min[X]
				) +
			  max(	gridver[Y] * rtip->mdl_max[Y],
				gridver[Y] * rtip->mdl_min[Y]
				) +
			  max(	gridver[Z] * rtip->mdl_max[Z],
				gridver[Z] * rtip->mdl_min[Z]
				);
		griddn = min(	gridver[X] * rtip->mdl_max[X],
				gridver[X] * rtip->mdl_min[X]
				) +
			  min(	gridver[Y] * rtip->mdl_max[Y],
				gridver[Y] * rtip->mdl_min[Y]
				) +
			  min(	gridver[Z] * rtip->mdl_max[Z],
				gridver[Z] * rtip->mdl_min[Z]
				);
		}
	gridxorg = gridlf / cellsz;
	gridxfin = gridrt / cellsz;
	gridyorg = griddn / cellsz;
	gridyfin = gridup / cellsz;

	/* Allow for randomization of cells. */
	if( dithercells )
		{
		gridxorg--;
		gridxfin++;
		gridyorg--;
		gridyfin++;
		}

	/* Compute stand-off distance. */
	standoff = max(	viewdir[X] * rtip->mdl_max[X],
			viewdir[X] * rtip->mdl_min[X]
			) +
		  max(	viewdir[Y] * rtip->mdl_max[Y],
			viewdir[Y] * rtip->mdl_min[Y]
			) +
		  max(	viewdir[Z] * rtip->mdl_max[Z],
			viewdir[Z] * rtip->mdl_min[Z]
			);

	/* Determine largest grid dimension for frame buffer display. */
	gridwidth  = gridxfin - gridxorg + 1;
	gridheight = gridyfin - gridyorg + 1;
	gridsz = Max( gridwidth, gridheight );

	/* Vector to grid origin. */
	Scale2Vec( viewdir, standoff, gridsoff );

	/* Direction of grid rays. */
	ScaleVec( viewdir, -1.0 );

	prntTimer( "grid" );
	return;
	}

void
spallInit()
	{	fastf_t	theta;	 /* solid angle of spall sampling cone */
		fastf_t phi;	 /* angle between ray and cone axis */
		fastf_t philast; /* gaurd against floating point error */
		int	spallct; /* actual no. of sampling rays */
		int	m, n;

	/* Compute sampling cone of rays which are equally spaced. */
	theta = TWO_PI * (1.0 - cos( conehfangle )); /* Solid angle. */
	delta = sqrt( theta/nspallrays );	/* Angular ray delta. */
	n = conehfangle / delta;
	phiinc = conehfangle / n;
	philast = conehfangle + EPSILON;
	/* Crank through spall cone generation once to count actual number
		generated.
	 */
	for( phi = 0.0, spallct = 0; phi <= philast; phi += phiinc )
		{	fastf_t	sinphi = sin( phi );
			fastf_t	gamma, gammainc, gammalast;
		sinphi = Abs( sinphi );
		m = (TWO_PI * sinphi)/delta + 1;
		gammainc = TWO_PI / m;
		gammalast = TWO_PI-gammainc+EPSILON;
		for( gamma = 0.0; gamma <= gammalast; gamma += gammainc )
			spallct++;
		}
	raysolidangle = theta / spallct;
	rt_log( "Solid angle of sampling cone = %g\n", theta );
	rt_log( "Solid angle per sampling ray = %g\n", raysolidangle );
	rt_log( "%d sampling rays\n", spallct );
	return;
	}

void
gridModel()
	{
	if( cantwarhead )
		ag.a_onehit = true;
	else
		ag.a_onehit = false;
	ag.a_hit = f_Hit;
	ag.a_miss = f_Miss;
	ag.a_overlap = reportoverlaps ? f_Overlap : f_HushOverlap;
	ag.a_rt_i = rtip;

	plotInit();	/* initialize plot file if appropriate */

	imageInit();	/* initialize frame buffer if appropriate */

	/* output initial line for this aspect */
	prntAspectInit();

	fatalerror = false;
	userinterrupt = false;	/* set by interrupt handler */

	/* get starting and ending shot number */
	currshot = 0;
	lastshot = gridwidth * gridheight - 1;

	rt_prep_timer();
	notify( "Raytracing...", NOTIFY_ERASE );

	/* SERIAL case -- one CPU does all the work */
	if( ! gridShot() )
		return;
	view_end();
	return;
	}

_LOCAL_ int
readShot( vec )
register fastf_t	*vec;
	{
	if( !(firemode & FM_3DIM) )
		{	int	items;
		/* Read firing coordinates from file. */
		if( (items =
#if defined(sgi) && ! defined(mips)
		     fscanf( shotfp, "%f %f", &vec[X], &vec[Y] )) != 2 )
#else
		     fscanf( shotfp, "%lf %lf", &vec[X], &vec[Y] )) != 2 )
#endif
			{
			if( items != EOF )
				{
				rt_log( "Fatal error: only %d firing coordinates read.\n", items );
				return	false;
				}
			else
				return	EOF;
			}
		else
			{
			vec[X] /= unitconv;
			vec[Y] /= unitconv;
			}
		}
	else
	if( firemode & FM_3DIM )
		{	int	items;
		/* Read firing coordinates from file. */
		if( (items =
#if defined(sgi) && ! defined(mips)
		     fscanf( shotfp, "%f %f %f", &vec[X], &vec[Y], &vec[Z] )) != 3 )
#else
		     fscanf( shotfp, "%lf %lf %lf", &vec[X], &vec[Y], &vec[Z] )) != 3 )
#endif

			{
			if( items != EOF )
				{
				rt_log( "Fatal error: %d firing coordinates read.\n", items );
				return	false;
				}
			else
				return	EOF;
			}
		else
			{
			vec[X] /= unitconv;
			vec[Y] /= unitconv;
			vec[Z] /= unitconv;
			}
		}
	else
		{
		rt_log( "BUG: readShot called with bad firemode.\n" );
		return	false;
		}
	return	true;
	}

_LOCAL_ bool
getRayOrigin( ap )
register struct application	*ap;
	{	register fastf_t	*vec = ap->a_uvec;
		fastf_t			gridyinc[3], gridxinc[3];
		fastf_t			scalecx, scalecy;
	if( firemode & FM_SHOT )
		{
		if( firemode & FM_FILE )
			{
			switch( readShot( vec ) )
				{
			case EOF :	return	false;
			case true :	break;
			case false :	return	false;
				}
			}
		else	/* Single shot specified. */
			CopyVec( vec, fire );
		if( firemode & FM_3DIM )
			{	fastf_t	hitpoint[3];
			/* Project 3-d hit-point back into grid space. */
			CopyVec( hitpoint, vec );
			vec[X] = Dot( gridhor, hitpoint );
			vec[Y] = Dot( gridver, hitpoint );
			}
		ap->a_x = vec[X] / cellsz;
		ap->a_y = vec[Y] / cellsz;
		scalecx = vec[X];
		scalecy = vec[Y];
		}
	else
		{	fastf_t xoffset = 0.0;
			fastf_t yoffset = 0.0;
		ap->a_x = currshot % gridwidth + gridxorg;
		ap->a_y = currshot / gridwidth + gridyorg;
		if( dithercells )
			{
			/* 2-digit random number, 1's place gives X
				offset, 10's place gives Y offset.
			 */
#ifdef SYSV /* Use lrand48() only if random() not available.  */
			ap->a_user = lrand48() % 100;
#else
			ap->a_user = random() % 100;
#endif
			xoffset = (ap->a_user%10)*0.1 - 0.5;
			yoffset = (ap->a_user/10)*0.1 - 0.5;
			}
		/* Compute magnitude of grid offsets. */
		scalecx = (fastf_t) ap->a_x + xoffset;
		scalecy = (fastf_t) ap->a_y + yoffset;
		vec[X] = scalecx *= cellsz;
		vec[Y] = scalecy *= cellsz;
		}
	/* Compute cell horizontal and vertical	vectors relative to
		grid origin. */
	Scale2Vec( gridhor, scalecx, gridxinc );
	Scale2Vec( gridver, scalecy, gridyinc );
	Add2Vec( gridsoff, gridyinc, ap->a_ray.r_pt );
	AddVec( ap->a_ray.r_pt, gridxinc );
	return	true;
	}

_LOCAL_ void
prntFiringCoords( vec )
register fastf_t	*vec;
	{
	if( gridfile[0] != '\0' )
		(void) fprintf( gridfp,
				"%7.2f %7.2f\n",
				vec[X]*unitconv, vec[Y]*unitconv );
	return;
	}

_LOCAL_ bool
gridShot()
	{	bool			status = true;
		struct application	a;
	a.a_resource = RESOURCE_NULL;
	a.a_hit = ag.a_hit;
	a.a_miss = ag.a_miss;
	a.a_overlap = ag.a_overlap;
	a.a_rt_i = ag.a_rt_i;
	a.a_onehit = ag.a_onehit;
	a.a_user = 0;
	prntGridOffsets( gridxorg, gridyorg );
	noverlaps = 0;
	for( ; ! userinterrupt; view_pix( &a ) )
		{
		if( !(firemode & FM_SHOT) && currshot > lastshot )
			break;
		if( ! (status = getRayOrigin( &a )) )
			break;
		currshot++;
		prntFiringCoords( a.a_uvec );
		CopyVec( a.a_ray.r_dir, viewdir );
		a.a_level = 0;	 /* Recursion level. */
		plotGrid( a.a_ray.r_pt );
		if( rt_shootray( &a ) == -1 && fatalerror )
			{
			/* Fatal error in application routine. */
			rt_log( "Fatal error: raytracing aborted.\n" );
			return	false;
			}
		if( !(firemode & FM_FILE) && (firemode & FM_SHOT) )
			{
			view_pix( &a );
			break;
			}
		}
	return	status;
	}

void
color_Part( regp, type )
register struct region	*regp;
int			type;
d77 1
a77 1
	if( plotfp == NULL )
d79 1
d119 1
a119 1
		rt_log( "color_Part: bad type %d.\n", type );
d126 2
a127 1
/*	enforce_LOS()
d129 39
d172 1
a172 1
enforce_LOS( ap, pt_headp )
d189 10
d200 84
d285 1
d298 8
a306 1
/*ARGSUSED*/
d334 2
a335 15
_LOCAL_ int
f_Hit( ap, pt_headp )
struct application	*ap;
struct partition	*pt_headp;
	{
	/* Output cell identification. */
	prntCellIdent( ap, pt_headp );
	/* Color cell if making frame buffer image. */
	if( fbfile[0] != NUL )
		paintCellFb( ap, pixtarg, pixbkgr );
	if( cantwarhead )
		return	f_Canted_Warhead( ap, pt_headp );
	else
		return	f_Penetrate( ap, pt_headp );
	}
d337 5
a341 8
_LOCAL_ int
f_Warhead_Miss( ap )
struct application	*ap;
	{
	if( setback != 0.0 )
		prntComin( ap, PT_NULL );
	return	0;
	}
d343 3
d347 3
a349 34
f_Canted_Warhead( ap, pt_headp )
struct application	*ap;
struct partition	*pt_headp;
	{	struct application	a_cant;
		register fastf_t	*rdir = ap->a_ray.r_dir;
		register fastf_t	*cantpt = a_cant.a_ray.r_pt;
		register fastf_t	*cantdir = a_cant.a_ray.r_dir;
		register fastf_t	*hitpointp;
	a_cant = *ap;
	a_cant.a_hit = f_Penetrate;
	a_cant.a_miss = f_Warhead_Miss;
	a_cant.a_overlap = ap->a_overlap; /* Shouldn't need this. */
	a_cant.a_onehit = false;
	a_cant.a_level = ap->a_level+1;

	/* Calculate trajectory of canted warhead. */
	hitpointp = pt_headp->pt_forw->pt_inhit->hit_point;
	color_Part( pt_headp->pt_forw->pt_regionp, C_MAIN );
	plotPartition(	pt_headp->pt_forw->pt_inhit,
			pt_headp->pt_forw->pt_outhit,
			&ap->a_ray,
			pt_headp->pt_forw->pt_regionp
			);
	VJOIN1( cantpt, hitpointp, -setback, rdir );
	/* Perturb ray direction. */
	Add2Vec( rdir, cantdelta, cantdir );
	V_Length( cantdir, 1.0 );
	return	rt_shootray( &a_cant );
	}

_LOCAL_ int
f_Penetrate( ap, pt_headp )
struct application	*ap;
struct partition	*pt_headp;
d354 1
a354 1
	rt_log( "f_Penetrate\n" );
d361 5
a365 2
	if( setback != 0.0 )
		prntComin( ap, pt_headp );
d368 1
a368 1
	enforce_LOS( ap, pt_headp );
d387 2
a388 2
			register struct region	*regp = pp->pt_regionp;
			register struct region	*nregp = pp->pt_forw->pt_regionp;
d390 8
a397 8
		{	register struct hit	*ihitp = pp->pt_inhit;
			register struct hit	*ohitp = pp->pt_outhit;
			register struct xray	*rayp = &ap->a_ray;
		VJOIN1( ihitp->hit_point, rayp->r_pt,
			ihitp->hit_dist, rayp->r_dir );
		VJOIN1( ohitp->hit_point, rayp->r_pt,
			ohitp->hit_dist, rayp->r_dir );
		color_Part( regp, C_MAIN );
d405 4
d413 4
d457 1
a457 2
			for(	cp = np->pt_forw;
				cp != pt_headp;
d564 1
a564 1
			rt_log( "\tcheck for adjacency of differingt airs; inside air\n" );
d613 1
a613 1
		return	1;
d616 36
a651 4
		{
		/* This is a burst point. */
		prntBurstHdr( ap, bp, bp->pt_forw );
		return	burstPoint( ap, bp );
d653 1
a653 1
	return	1;
d656 7
d664 1
a664 1
f_Miss( ap )
d667 43
d711 1
a711 1
		paintCellFb( ap, pixmiss, pixbkgr );
d713 1
a713 1
	return	0;
d716 5
d726 1
a726 1
	return	0;
d729 80
d810 234
a1043 5
lgt_Model( ap, pp, hitp, rayp )
register struct application	*ap;
struct partition	*pp;
struct hit		*hitp;
struct xray		*rayp;
d1045 1
a1045 1
		fastf_t intensity = -Dot( rayp->r_dir, hitp->hit_normal );
d1047 1
a1047 1
		intensity = 0.0;
d1067 34
d1102 60
a1161 32
f_BurstHit( ap, pt_headp )
struct application	*ap;
struct partition	*pt_headp;
	{	Pt_Queue			*qshield = PT_Q_NULL;
		register struct partition	*cpp, *spp;
		register int			nbar;
		register int			ncrit = 0;
	/* Find first barrier in front of the burst point. */
	for(	spp = pt_headp->pt_forw;
		spp != pt_headp
	    &&	spp->pt_outhit->hit_dist < 0.1;
		spp = spp->pt_forw
		) 
		;
	for(	cpp = spp, nbar = 0;
		cpp != pt_headp && nbar <= nbarriers;
		cpp = cpp->pt_forw
		) 
		{	register struct region	*regp = cpp->pt_regionp;
		if( Air( regp ) )
			continue; /* Air doesn't matter here. */
		if( findIdents( regp->reg_regionid, &critids ) )
			{	register struct xray	*rayp = &ap->a_ray;
				register struct hit	*hitp;
			hitp = cpp->pt_inhit;
			if( fbfile[0] != NUL && ncrit == 0 )
				{	register struct soltab	*stp;
				stp = cpp->pt_inseg->seg_stp;
				RT_HIT_NORM( hitp, stp, rayp );
				Check_Iflip( cpp, hitp->hit_normal,
						rayp->r_dir );
				lgt_Model( ap, cpp, hitp, rayp );
d1164 1
a1164 12
				{
				VJOIN1( hitp->hit_point, rayp->r_pt,
					hitp->hit_dist, rayp->r_dir );
				}
			prntRegionHdr( ap, hitp, regp, nbar );
			hitp = cpp->pt_outhit;
			VJOIN1( hitp->hit_point, rayp->r_pt,
				hitp->hit_dist, rayp->r_dir );
			color_Part( regp, C_CRIT );
			plotPartition( cpp->pt_inhit, hitp, rayp, regp );
			prntShieldComp( ap, rayp, qshield );
			ncrit++;
d1166 1
a1166 2
		/* Add all components to list of shielding components. */
		if( cpp->pt_forw != pt_headp )
d1168 17
a1184 1
			if( ! qAdd( cpp, &qshield ) )
d1186 1
d1188 1
a1188 1
				return	-1;
d1190 2
a1191 1
			nbar++;
d1193 6
a1199 7
	qFree( qshield );
	if( ncrit == 0 )
		{
		if( fbfile[0] != NUL )
			paintCellFb( ap, pixbhit, pixtarg );
		return	ap->a_miss( ap );
		}
d1202 2
a1203 3
		if( fbfile[0] != NUL )
			paintCellFb( ap, pixcrit, pixtarg );
		return	ncrit;
d1205 1
d1208 5
d1216 1
a1216 1
	{	register int	a;
d1224 2
a1225 1
struct application	a_burst; /* Prototype spall ray. */
d1227 3
a1229 12
_LOCAL_ int
burstPoint( ap, pp )
register struct application	*ap;
register struct partition	*pp;
	{	fastf_t			s_rdir[3];
		register struct hit	*ohitp;
		register struct soltab	*stp;
	/* Fill in hit point and normal. */
	stp = pp->pt_outseg->seg_stp;
	ohitp = pp->pt_outhit;
	RT_HIT_NORM( ohitp, stp, &(ap->a_ray) );
	Check_Oflip( pp, ohitp->hit_normal, ap->a_ray.r_dir );
d1231 70
d1304 1
a1304 1
	a_burst.a_overlap = ap->a_overlap; /* Shouldn't need this. */
d1306 13
a1318 4
	a_burst.a_user = 0; /* Ray number. */

	/* By default, spall cone axis is half way between main penetrator
		direction and exit normal of critical component.
d1322 1
a1322 1
		AddVec( a_burst.a_ray.r_dir, ohitp->hit_normal );
d1325 2
a1326 1
	CopyVec( a_burst.a_ray.r_pt, ohitp->hit_point );
d1333 1
a1333 1
_LOCAL_ int
d1340 1
a1340 1
		int			m;
d1346 2
a1347 1
			register int	done;
d1372 2
a1373 2
				rt_log( "Fatal error: raytracing aborted.\n" );
				return	0;
d1376 1
d1378 2
d1388 8
a1395 1
	return	1;
d1402 1
a1402 4
	{	static fastf_t		xaxis[3] = { 1.0, 0.0, 0.0 };
		static fastf_t		zaxis[3] = { 0.0, 0.0, 1.0 };
		static fastf_t		negzaxis[3] = { 0.0, 0.0, -1.0 };
		fastf_t			cosphi = cos( phi );
d1426 1
d1434 1
a1434 1
void
a1485 5
#if 0
		/* map grid offsets to frame buffer coordinates */
		int	x = ap->a_x-gridxorg+(gridsz-gridwidth)/2;
		int	y = ap->a_y-gridyorg+(gridsz-gridheight)/2;
#endif
d1487 2
a1488 1
	prntGridOffsets( ap->a_x, ap->a_y );
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d12 1
d14 1
a30 6
static int	gridwidth;	/* Grid width in cells. */
static int	gridheight;	/* Grid height in cells. */

static fastf_t	gridhor[3];	/* Horizontal grid direction cosines. */
static fastf_t	gridver[3];	/* Vertical grid direction cosines. */
static fastf_t	gridsoff[3];	/* Grid origin translated by standoff. */
a31 1

d40 14
a53 13
_LOCAL_ bool		gridShot();
_LOCAL_ int		burstRay();
_LOCAL_ int		f_Hit();
_LOCAL_ int		f_HushOverlap();
_LOCAL_ int		f_Miss();
_LOCAL_ int		f_Overlap();
_LOCAL_ int		f_Penetrate();
_LOCAL_ int		f_Spall();
_LOCAL_ int		f_Canted_Warhead();
_LOCAL_ int		f_Warhead_Miss();
_LOCAL_ void		view_pix(), view_end();
_LOCAL_ void		spallVec();
void			consVector();
d71 2
a72 3
	{	fastf_t		gridrt, gridlf, gridup, griddn;

	notify( "Initializing grid..." );
d76 1
a76 2
	gridRotate(	viewazim, viewelev, 0.0,
			gridhor, gridver );
d94 3
a96 1
	if( firemode & FM_SHOT )
a97 6
		if( firemode & FM_FILE )
			rewind( shotfp );
		gridxorg = gridxfin = gridyorg = gridyfin = 0;
		}
	else
		{
d134 5
a138 4
		gridxorg = gridlf / cellsz;
		gridxfin = gridrt / cellsz;
		gridyorg = griddn / cellsz;
		gridyfin = gridup / cellsz;
d140 3
a142 1
		/* Allow for randomization of cells. */
d146 1
a146 1
		gridxorg++;
d221 1
a221 1
	plotInit();
d223 3
a225 1
	/* Output initial line for this aspect. */
d229 1
a229 1
	userinterrupt = false;	/* Set by interrupt handler. */
d231 1
a231 1
	/* Get starting and ending shot number. */
d236 1
a236 1
	notify( "Raytracing..." );
d238 1
a238 3
	/*
	 * SERIAL case -- one CPU does all the work.
	 */
d320 1
a320 1
			case EOF :	return	true;
a375 4
#if false
	rt_log( "Firing coords <%7.2f,%7.2f>\n",
		vec[X]*unitconv, vec[Y]*unitconv );
#endif
d398 1
a398 1
		if( !(firemode & FM_FILE) && currshot > lastshot )
d414 2
d417 1
d548 3
d604 8
d652 3
d662 3
d694 3
a696 1
			prntScr( "Merging inside airs" );
d719 4
d731 3
d738 1
a738 1
				rt_log( "outputting 01 air\n" );
d750 1
a750 1
				rt_log( "\texplicit air follows\n" );
d774 1
a774 1
				rt_log( "\toutputting 09 air\n" );
d784 1
a784 1
				rt_log( "\tmerging adjacent components\n" );
d795 1
a795 1
				rt_log( "\tdifferent component follows\n" );
d804 3
d814 3
d822 3
d837 3
d846 4
d851 1
d859 1
a859 1
		prntBurstHdr(	ap, bp, bp->pt_forw );
d869 2
d875 8
d908 1
d913 1
a913 1
f_Spall( ap, pt_headp )
d973 3
d977 1
d979 3
d983 1
d986 1
a986 1
_LOCAL_ int
d1003 1
a1003 5
	{
#ifdef alliant
		register int	d7;	/* known to be in d7 */
#endif
		fastf_t			s_rdir[3];
a1005 1
	prntScr( "burstPoint" );
d1013 2
a1014 2
	a_burst.a_miss = f_Miss;
	a_burst.a_hit = f_Spall;
a1041 1
	prntScr( "burstray()" );
d1046 1
a1046 1
			fastf_t	gamma, gammainc;
d1059 2
a1060 3
		for(	gamma = 0.0;
			gamma <= TWO_PI-gammainc;
			gamma += gammainc )
d1076 1
a1076 18
				{	RGBpixel	pixel;
					int		x, y;
					int		err;
				pixel[RED] = a_spall.a_color[RED] * 255;
				pixel[GRN] = a_spall.a_color[GRN] * 255;
				pixel[BLU] = a_spall.a_color[BLU] * 255;
				x = round( 255 +
					Dot( a_spall.a_ray.r_dir, gridhor )
					* nrings );
				y = round( 255 +
					Dot( a_spall.a_ray.r_dir, gridver )
					* nrings );
				RES_ACQUIRE( &rt_g.res_stats );
				err = fb_write( fbiop, x, y, pixel, 1 );
				RES_RELEASE( &rt_g.res_stats );
				if( err == -1 )
					rt_log( "Write failed to pixel <%d,%d>.\n", x, y );
				}
a1148 4
#if false
	if( fbfile[0] != NUL )
		(void) fb_flush( fbiop );
#endif
a1194 4
#if false
	if( fbfile[0] != NUL )
		fb_flush( fbiop );
#endif
d1203 7
@
