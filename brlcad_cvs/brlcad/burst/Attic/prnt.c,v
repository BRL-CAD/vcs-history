head	1.32;
access;
symbols
	ansi-20040405-merged:1.30
	postmerge-20040405-ansi:1.30
	premerge-20040404-ansi:1.30
	postmerge-autoconf:1.30
	autoconf-freeze:1.30
	premerge-autoconf:1.30
	ansi-20040316-freeze:1.30
	postmerge-20040315-windows:1.30
	premerge-20040315-windows:1.30
	windows-20040315-freeze:1.30
	autoconf-20031203:1.30
	autoconf-20031202:1.30
	autoconf-branch:1.30.0.12
	phong-branch:1.30.0.10
	photonmap-branch:1.30.0.8
	rel-6-1-DP:1.30
	windows-branch:1.30.0.6
	rel-6-0-2:1.30
	ansi-branch:1.30.0.4
	rel-6-0-1-branch:1.30.0.2
	hartley-6-0-post:1.30
	hartley-6-0-pre:1.30
	rel-6-0-1:1.30
	rel-6-0:1.30
	rel-5-4:1.24
	offsite-5-3-pre:1.27
	rel-5-3:1.24
	rel-5-2:1.24
	rel-5-1-branch:1.24.0.2
	rel-5-1:1.24
	rel-5-0:1.24
	rel-5-0-beta:1.24
	rel-4-5:1.19
	ctj-4-5-post:1.18
	ctj-4-5-pre:1.18
	rel-4-4:1.17
	rel-4-0:1.14
	rel-3-5:1.3;
locks; strict;
comment	@ * @;


1.32
date	2004.05.24.04.18.19;	author morrison;	state dead;
branches;
next	1.31;

1.31
date	2004.05.10.15.30.41;	author erikg;	state Exp;
branches;
next	1.30;

1.30
date	2001.10.17.07.40.00;	author morrison;	state Exp;
branches;
next	1.29;

1.29
date	2001.08.09.18.47.09;	author jra;	state Exp;
branches;
next	1.28;

1.28
date	2001.05.17.20.03.05;	author morrison;	state Exp;
branches;
next	1.27;

1.27
date	2000.09.06.20.37.23;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	2000.09.06.20.14.09;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	2000.08.24.23.12.44;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	98.10.28.17.11.15;	author jra;	state Exp;
branches;
next	1.23;

1.23
date	98.06.27.04.56.23;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	98.06.27.04.51.30;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	98.06.23.18.20.41;	author jra;	state Exp;
branches;
next	1.20;

1.20
date	98.03.26.08.10.18;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	97.12.16.03.45.56;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	96.07.18.17.32.30;	author jra;	state Exp;
branches;
next	1.17;

1.17
date	93.12.22.08.20.20;	author moss;	state Exp;
branches;
next	1.16;

1.16
date	93.12.15.11.46.21;	author moss;	state Exp;
branches;
next	1.15;

1.15
date	93.12.15.08.18.57;	author moss;	state Exp;
branches;
next	1.14;

1.14
date	91.09.13.09.39.10;	author moss;	state Exp;
branches;
next	1.13;

1.13
date	91.09.11.10.45.19;	author moss;	state Exp;
branches;
next	1.12;

1.12
date	91.08.26.11.05.21;	author moss;	state Exp;
branches;
next	1.11;

1.11
date	91.01.15.13.53.28;	author moss;	state Exp;
branches;
next	1.10;

1.10
date	90.09.14.14.27.28;	author moss;	state Exp;
branches;
next	1.9;

1.9
date	90.08.28.16.28.34;	author moss;	state Exp;
branches;
next	1.8;

1.8
date	90.08.28.12.24.18;	author moss;	state Exp;
branches;
next	1.7;

1.7
date	90.08.22.09.40.08;	author moss;	state Exp;
branches;
next	1.6;

1.6
date	89.10.31.12.20.09;	author moss;	state Exp;
branches;
next	1.5;

1.5
date	89.07.14.12.59.47;	author moss;	state Exp;
branches;
next	1.4;

1.4
date	89.07.07.16.33.30;	author moss;	state Exp;
branches;
next	1.3;

1.3
date	89.01.20.15.21.29;	author moss;	state Exp;
branches;
next	1.2;

1.2
date	88.11.07.17.02.11;	author moss;	state Exp;
branches;
next	1.1;

1.1
date	88.10.28.17.02.22;	author moss;	state Exp;
branches;
next	;


desc
@@


1.32
log
@moved to src/burst/
@
text
@/*
	Author:		Gary S. Moss
			U. S. Army Ballistic Research Laboratory
			Aberdeen Proving Ground
			Maryland 21005-5066
*/
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/burst/prnt.c,v 1.31 2004/05/10 15:30:41 erikg Exp $ (BRL)";
#endif

#ifndef DEBUG
#define NDEBUG
#define STATIC static
#else
#define STATIC
#endif

#include <assert.h>

#include <stdio.h>
#include <time.h>
#include <string.h>
#include <signal.h>

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include "./vecmath.h"
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "libtermio.h"

#include "./Sc.h"
#include "./ascii.h"
#include "./extern.h"


#define MAX_COLS	128

#define PHANTOM_ARMOR	111

STATIC fastf_t getNormThickness();

int
doMore( linesp )
int	*linesp;
	{	register int	ret = true;
	if( ! tty )
		return	true;
	TcSaveTty( HmTtyFd );
	TcSetRaw( HmTtyFd );
	TcClrEcho( HmTtyFd );
	ScSetStandout();
	prompt( "-- More -- " );
	ScClrStandout();
	(void) fflush( stdout );
	switch( HmGetchar() )
		{
	case 'q' :
	case 'n' :
		ret = false;
		break;
	case LF :
	case CR :
		*linesp = 1;
		break;
	default :
		*linesp = (PROMPT_Y-SCROLL_TOP);
		break;
		}
	TcResetTty( HmTtyFd );
	return	ret;
	}

STATIC int
f_Nerror( ap )
struct application *ap;
	{
	brst_log( "Couldn't compute thickness or exit point %s.\n",
		"along normal direction" );
	V_Print( "\tpnt", ap->a_ray.r_pt, brst_log );
	V_Print( "\tdir", ap->a_ray.r_dir, brst_log );
	ap->a_rbeam = 0.0;
	return	0;
	}

/*	f_Normal()

	Shooting from surface of object along reversed entry normal to
	compute exit point along normal direction and normal thickness.
	Thickness returned in "a_rbeam".
 */
STATIC int
f_Normal( ap, pt_headp, segp )
struct application *ap;
struct partition *pt_headp;
struct seg *segp;
	{	register struct partition *pp = pt_headp->pt_forw;
		register struct partition *cp;
		register struct hit *ohitp;
	for(	cp = pp->pt_forw;
		cp != pt_headp && SameCmp( pp->pt_regionp, cp->pt_regionp );
		cp = cp->pt_forw
		)
		;
	ohitp = cp->pt_back->pt_outhit;
	ap->a_rbeam = ohitp->hit_dist - pp->pt_inhit->hit_dist;
#ifdef VDEBUG
	brst_log( "f_Normal: thickness=%g dout=%g din=%g\n",
		ap->a_rbeam*unitconv, ohitp->hit_dist, pp->pt_inhit->hit_dist );
#endif
	return	1;
	}

#include <errno.h>
/* These aren't defined in BSD errno.h.					*/
extern int	errno;
#if !HAVE_SYS_ERRLIST_DECL
extern int	sys_nerr;
extern char	*sys_errlist[];
#endif

void
locPerror( msg )
char    *msg;
	{
	if( errno > 0 && errno < sys_nerr )
		brst_log( "%s: %s\n", msg, sys_errlist[errno] );
	else
		brst_log( "BUG: errno not set, shouldn't call perror.\n" );
	return;
	}

int
notify( str, mode )
char    *str;
int	mode;
	{       register int    i;
		static int      lastlen = -1;
		register int    len;
		static char	buf[LNBUFSZ] = { 0 };
		register char	*p='\0';
	if( ! tty )
		return	false;
	switch( mode )
		{
	case NOTIFY_APPEND :
		p = buf + lastlen;
		break;
	case NOTIFY_DELETE :
		for( p = buf+lastlen; p > buf && *p != NOTIFY_DELIM; p-- )
			;
		break;
	case NOTIFY_ERASE :
		p = buf;
		break;
		}
	if( str != NULL )
		{
		if( p > buf )
			*p++ = NOTIFY_DELIM;
		(void) strcpy( p, str );
		}
	else
		*p = NUL;
	(void) ScMvCursor( PROMPT_X, PROMPT_Y );
	len = strlen( buf );
	if( len > 0 )
		{
		(void) ScSetStandout();
		(void) fputs( buf, stdout );
		(void) ScClrStandout();
		}

	/* Blank out remainder of previous command. */
	for( i = len; i < lastlen; i++ )
		(void) putchar( ' ' );
	(void) ScMvCursor( PROMPT_X, PROMPT_Y );
	(void) fflush( stdout );
	lastlen = len;
	return	true;
	}

/*
	void prntAspectInit( void )

	Burst Point Library and Shotline file: header record for each view.
	Ref. Figure 20., Line Number 1 and Figure 19., Line Number 1 of ICD.
 */
void
prntAspectInit()
	{	fastf_t projarea;	/* projected area */
	/* Convert to user units before squaring cell size. */
	projarea = cellsz*unitconv;
	projarea *= projarea;
	if(	outfile[0] != NUL
	    &&	fprintf(outfp,
			"%c % 9.4f % 8.4f % 5.2f % 10.2f %-6s % 9.6f\n",
			PB_ASPECT_INIT,
			viewazim*DEGRAD, /* attack azimuth in degrees */
			viewelev*DEGRAD, /* attack elevation in degrees */
			bdist*unitconv,  /* BDIST */
			projarea, /* projected area associated with burst pt. */
			units == U_INCHES ?      "inches" :
			units == U_FEET ?        "feet" :
			units == U_MILLIMETERS ? "mm" :
			units == U_CENTIMETERS ? "cm" :
			units == U_METERS ?      "meters" : "units?",
			raysolidangle
			) < 0
		)
		{
		brst_log( "Write failed to file (%s)!\n", outfile );
		locPerror( "fprintf" );
		exitCleanly( 1 );
		}
	if(	shotlnfile[0] != NUL
	    &&	fprintf(shotlnfp,
		     "%c % 9.4f % 8.4f % 7.2f % 7.2f %7.2f %7.2f %7.2f %-6s\n",
			PS_ASPECT_INIT,
			viewazim*DEGRAD, /* attack azimuth in degrees */
			viewelev*DEGRAD, /* attack elevation in degrees */
			cellsz*unitconv, /* shotline separation */
			modlrt*unitconv, /* maximum Y'-coordinate of target */
			modllf*unitconv, /* minimum Y'-coordinate of target */
			modlup*unitconv, /* maximum Z'-coordinate of target */
			modldn*unitconv, /* minimum Z'-coordinate of target */
			units == U_INCHES ?      "inches" :
			units == U_FEET ?        "feet" :
			units == U_MILLIMETERS ? "mm" :
			units == U_CENTIMETERS ? "cm" :
			units == U_METERS ?      "meters" : "units?"
			) < 0
		)
		{
		brst_log( "Write failed to file (%s)!\n", shotlnfile );
		locPerror( "fprintf" );
		exitCleanly( 1 );
		}
	return;
	}

/*
	void prntBurstHdr( fastf_t *bpt, fastf_t *shotdir )

	This routine must be called before bursting when doing either a
	ground plane burst or bursting at user-specified coordinates.  The
	purpose is to output fake PB_CELL_IDENT and PB_RAY_INTERSECT records
	to the Burst Point Library so that the coordinates of the burst point
	can be made available.

 */
void
prntBurstHdr( bpt, shotdir )
fastf_t *bpt;		/* burst point in model coords */
fastf_t *shotdir;	/* shotline direction vector */
	{	fastf_t vec[3];
	/* Transform burst point (model coordinate system) into the shotline
	   coordinate system. */
	vec[Y] = Dot( gridhor, bpt );	/* Y' */
	vec[Z] = Dot( gridver, bpt );	/* Z' */
	vec[X] = -Dot( shotdir, bpt );	/* X' - shotdir is reverse of X' */

	if(	outfile[0] != NUL
	    &&	fprintf(outfp,
			"%c % 8.3f % 8.3f\n",
			PB_CELL_IDENT,
			vec[Y]*unitconv,
			 	/* horizontal coordinate of burst point (Y') */
			vec[Z]*unitconv
			 	/* vertical coordinate of burst point (Z') */
			) < 0
		)
		{
		brst_log( "Write failed to file (%s)!\n", outfile );
		locPerror( "fprintf" );
		exitCleanly( 1 );
		}
	if(	outfile[0] != NUL
	    &&	fprintf( outfp,
			"%c % 8.2f % 8.2f %4d %2d % 7.3f % 7.2f % 7.3f %c\n",
			PB_RAY_INTERSECT,
			vec[X]*unitconv, /* X' coordinate of burst point */
			0.0,		/* LOS thickness of component */
			9999,		/* dummy component code number */
			9,		/* dummy space code */
			0.0,		/* N/A */
			0.0,		/* N/A */
			0.0,		/* N/A */
			'1'		/* burst was generated */
			) < 0
		)
		{
		brst_log( "Write failed to file (%s)!\n", outfile );
		locPerror( "fprintf" );
		exitCleanly( 1 );
		}
	}

/*
	void prntCellIdent( struct application *ap )

	Burst Point Library and Shotline file: information about shotline.
	Ref. Figure 20., Line Number 2 and Figure 19., Line Number 2 of ICD.

	NOTE: field width of first 2 floats compatible with PB_RAY_HEADER
	record.
 */
void
prntCellIdent( ap )
register struct application *ap;
	{
	if(	outfile[0] != NUL
	    &&	fprintf(outfp,
			"%c % 8.3f % 8.3f\n",
			PB_CELL_IDENT,
			ap->a_uvec[X]*unitconv,
			 	/* horizontal coordinate of shotline (Y') */
			ap->a_uvec[Y]*unitconv
			 	/* vertical coordinate of shotline (Z') */
			) < 0
		)
		{
		brst_log( "Write failed to file (%s)!\n", outfile );
		locPerror( "fprintf" );
		exitCleanly( 1 );
		}
	if(	shotlnfile[0] != NUL
	    &&	fprintf(shotlnfp,
			"%c % 8.3f % 8.3f\n",
			PS_CELL_IDENT,
			ap->a_uvec[X]*unitconv,
			 	/* horizontal coordinate of shotline (Y') */
			ap->a_uvec[Y]*unitconv
			 	/* vertical coordinate of shotline (Z') */
			) < 0
		)
		{
		brst_log( "Write failed to file (%s)!\n", shotlnfile );
		locPerror( "fprintf" );
		exitCleanly( 1 );
		}
	return;
	}

/*
	void prntSeg( struct application *ap, struct partition *cpp, int space,
			fastf_t entrynorm[3], fastf_t exitnorm[3],
			bool burstflag )

	Burst Point Library and Shotline file: information about each component
	hit along path of main penetrator (shotline).
	Ref. Figure 20., Line Number 3 and Figure 19., Line Number 2 of ICD.
 */
void
prntSeg( ap, cpp, space, entrynorm, exitnorm, burstflag )
register struct application *ap;
register struct partition *cpp;		/* component partition */
int space;
fastf_t entrynorm[3];
fastf_t exitnorm[3];
bool burstflag; /* Was a burst generated by this partition? */
	{	fastf_t icosobliquity;	/* cosine of obliquity at entry */
		fastf_t ocosobliquity;	/* cosine of obliquity at exit */
		fastf_t	entryangle;	/* obliquity angle at entry */
		fastf_t exitangle;	/* obliquity angle at exit */
		fastf_t los;		/* line-of-sight thickness */
		fastf_t normthickness;	/* normal thickness */
		fastf_t	rotangle;	/* rotation angle */
		fastf_t sinfbangle;	/* sine of fall back angle */

	/* This *should* give negative of desired result. */
	icosobliquity = Dot( ap->a_ray.r_dir, entrynorm );
	icosobliquity = -icosobliquity;

	ocosobliquity = Dot( ap->a_ray.r_dir, exitnorm );

	if( exitnorm[Y] == 0.0 && exitnorm[X] == 0.0 )
		rotangle = 0.0;
	else
		{
		rotangle = atan2( exitnorm[Y], exitnorm[X] );
		rotangle *= DEGRAD; /* convert to degrees */
		if( rotangle < 0.0 )
			rotangle += 360.0;
		}
	/* Compute sine of fallback angle.  NB: the Air Force measures the
		fallback angle from the horizontal (X-Y) plane. */
	sinfbangle = Dot( exitnorm, zaxis );

	los = (cpp->pt_outhit->hit_dist-cpp->pt_inhit->hit_dist)*unitconv;
#ifdef VDEBUG
	brst_log( "prntSeg: los=%g dout=%g din=%g\n",
		los, cpp->pt_outhit->hit_dist, cpp->pt_inhit->hit_dist );
#endif

	if(	outfile[0] != NUL
	    &&	fprintf( outfp,
			"%c % 8.2f % 8.2f %4d %2d % 7.3f % 7.2f % 7.3f %c\n",
			PB_RAY_INTERSECT,
			(standoff - cpp->pt_inhit->hit_dist)*unitconv,
					/* X'-coordinate of intersection */
			los,		/* LOS thickness of component */
			cpp->pt_regionp->reg_regionid,
					/* component code number */
			space,		/* space code */
			sinfbangle,	/* sine of fallback angle at exit */
			rotangle,	/* rotation angle in degrees at exit */
			icosobliquity,	/* cosine of obliquity angle at entry */
			burstflag ? '1' : '0' /* flag generation of burst */
			) < 0
		)
		{
		brst_log( "Write failed to file (%s)!\n", outfile );
		locPerror( "fprintf" );
		exitCleanly( 1 );
		}
	if( shotlnfile[0] == NUL )
		return;
	entryangle = AproxEq( icosobliquity, 1.0, COS_TOL ) ?
			0.0 : acos( icosobliquity ) * DEGRAD;
	if(	(normthickness =
		 getNormThickness( ap, cpp, icosobliquity, entrynorm )) <= 0.0
	    &&	fatalerror )
		{
		brst_log( "Couldn't compute normal thickness.\n" );
		brst_log( "\tshotline coordinates <%g,%g>\n",
			ap->a_uvec[X]*unitconv,
			ap->a_uvec[Y]*unitconv
			);
		brst_log( "\tregion name '%s' solid name '%s'\n",
			cpp->pt_regionp->reg_name,
			cpp->pt_inseg->seg_stp->st_name );
		return;
		}
	exitangle = AproxEq( ocosobliquity, 1.0, COS_TOL ) ?
			0.0 : acos( ocosobliquity ) * DEGRAD;
	if( fprintf( shotlnfp,
	       "%c % 8.2f % 7.3f % 7.2f %4d % 8.2f % 8.2f %2d % 7.2f % 7.2f\n",
			PS_SHOT_INTERSECT,
			(standoff - cpp->pt_inhit->hit_dist)*unitconv,
					/* X'-coordinate of intersection */
			sinfbangle,	/* sine of fallback angle at exit */
			rotangle,	/* rotation angle in degrees at exit */
			cpp->pt_regionp->reg_regionid,
					/* component code number */
			normthickness*unitconv,
					/* normal thickness of component */
			los,		/* LOS thickness of component */
			space,		/* space code */
			entryangle,	/* entry obliquity angle in degrees */
			exitangle	/* exit obliquity angle in degrees */
			) < 0
		)
		{
		brst_log( "Write failed to file (%s)!\n", shotlnfile );
		locPerror( "fprintf" );
		exitCleanly( 1 );
		}
	}

/*
	void prntRayHeader( fastf_t *raydir, fastf_t *shotdir, unsigned rayno )

	Burst Point Library: information about burst ray.  All angles are
	WRT the shotline coordinate system, represented by X', Y' and Z'.
	Ref. Figure 20., Line Number 19 of ICD.
	
	NOTE: field width of first 2 floats compatible with PB_CELL_IDENT
	record.
 */
void
prntRayHeader( raydir, shotdir, rayno )
fastf_t	*raydir;	/* burst ray direction vector */
fastf_t *shotdir;	/* shotline direction vector */
unsigned rayno;		/* ray number for this burst point */
	{	double cosxr;	 /* cosine of angle between X' and raydir */
		double cosyr;	 /* cosine of angle between Y' and raydir */
		fastf_t azim;	 /* ray azim in radians */
		fastf_t sinelev; /* sine of ray elevation */
	if( outfile[0] == NUL )
		return;
	cosxr = -Dot( shotdir, raydir ); /* shotdir is reverse of X' */
	cosyr = Dot( gridhor, raydir );
	if( cosyr == 0.0 && cosxr == 0.0 )
		azim = 0.0;
	else
		azim = atan2( cosyr, cosxr );
	sinelev = Dot( gridver, raydir );
	if(	fprintf( outfp,
			"%c %8.3f %8.3f %6u\n",
			PB_RAY_HEADER,
			azim,   /* ray azimuth angle WRT shotline (radians). */
			sinelev, /* sine of ray elevation angle WRT shotline. */
			rayno
			) < 0
		)
		{
		brst_log( "Write failed to file (%s)!\n", outfile );
		locPerror( "fprintf" );
		exitCleanly( 1 );
		}
	}

/*
	void prntRegionHdr( struct application *ap, struct partition *pt_headp,
				struct partition *pp, fastf_t entrynorm[3],
				fastf_t exitnorm[3] )

	Burst Point Libary: intersection along burst ray.
	Ref. Figure 20., Line Number 20 of ICD.
 */
void
prntRegionHdr( ap, pt_headp, pp, entrynorm, exitnorm )
struct application *ap;
struct partition *pt_headp;
struct partition *pp;
fastf_t entrynorm[3], exitnorm[3];
	{	fastf_t	cosobliquity;
		fastf_t normthickness;
		register struct hit *ihitp = pp->pt_inhit;
		register struct hit *ohitp = pp->pt_outhit;
		register struct region *regp = pp->pt_regionp;
		register struct xray *rayp = &ap->a_ray;
	/* Get entry/exit normals and fill in hit points */
	getRtHitNorm( ihitp, pp->pt_inseg->seg_stp, rayp,
		(bool) pp->pt_inflip, entrynorm );
	if( ! chkEntryNorm( pp, rayp, entrynorm,
		"spall ray component entry normal" ) )
		{
#ifdef DEBUG
		prntDbgPartitions( ap, pt_headp,
			"prntRegionHdr: entry normal flipped." );
#endif
		}
	getRtHitNorm( ohitp, pp->pt_outseg->seg_stp, rayp,
		(bool) pp->pt_outflip, exitnorm );
	if( ! chkExitNorm( pp, rayp, exitnorm,
		"spall ray component exit normal" ) )
		{
#ifdef DEBUG
		prntDbgPartitions( ap, pt_headp,
			"prntRegionHdr: exit normal flipped." );
#endif
		}


	/* calculate cosine of obliquity angle */
	cosobliquity = Dot( ap->a_ray.r_dir, entrynorm );
	cosobliquity = -cosobliquity;
#if DEBUG
	if( cosobliquity - COS_TOL > 1.0 )
		{
		brst_log( "cosobliquity=%12.8f\n", cosobliquity );
		brst_log( "normal=<%g,%g,%g>\n",
			entrynorm[X],
			entrynorm[Y],
			entrynorm[Z]
			);
		brst_log( "ray direction=<%g,%g,%g>\n",
			ap->a_ray.r_dir[X],
			ap->a_ray.r_dir[Y],
			ap->a_ray.r_dir[Z]
			);
		brst_log( "region name '%s'\n", regp->reg_name );
		}
#endif
	if( outfile[0] == NUL )
		return;

	
	/* Now we must find normal thickness through component. */
	normthickness = getNormThickness( ap, pp, cosobliquity, entrynorm );
	bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
	if(	fprintf( outfp,
			"%c % 10.3f % 9.3f % 9.3f %4d %4d % 6.3f\n",
			PB_REGION_HEADER,
			ihitp->hit_dist*unitconv, /* distance from burst pt. */
			(ohitp->hit_dist - ihitp->hit_dist)*unitconv, /* LOS */
			normthickness*unitconv,	  /* normal thickness */
			pp->pt_forw == pt_headp ?
				EXIT_AIR : pp->pt_forw->pt_regionp->reg_aircode,
			regp->reg_regionid,
			cosobliquity
			) < 0
		)
		{
		bu_semaphore_release( BU_SEM_SYSCALL );	/* unlock */
		brst_log( "Write failed to file (%s)!\n", outfile );
		locPerror( "fprintf" );
		exitCleanly( 1 );
		}
	bu_semaphore_release( BU_SEM_SYSCALL );	/* unlock */
	}

/*
	fastf_t getNormThickness( struct application *ap, struct partition *pp,
				fastf_t cosobliquity, fastf_t normvec[3] )

	Given a partition structure with entry hit point and a private copy
	of the associated normal vector, the current application structure
	and the cosine of the obliquity at entry to the component, return
	the normal thickness through the component at the given hit point.

 */
STATIC fastf_t
getNormThickness( ap, pp, cosobliquity, normvec )
register struct application *ap;
register struct partition *pp;
fastf_t cosobliquity;
fastf_t normvec[3];
	{
#ifdef VDEBUG
	brst_log( "getNormThickness() pp 0x%x normal %g,%g,%g\n",
		pp, normvec[X], normvec[Y], normvec[Z] );
#endif
	if( AproxEq( cosobliquity, 1.0, COS_TOL ) )
		{ /* Trajectory was normal to surface, so no need
			to shoot another ray. */
			fastf_t	thickness = pp->pt_outhit->hit_dist -
					pp->pt_inhit->hit_dist;
#ifdef VDEBUG
		brst_log( "getNormThickness: using existing partitions.\n" );
		brst_log( "\tthickness=%g dout=%g din=%g normal=%g,%g,%g\n",
			thickness*unitconv,
			pp->pt_outhit->hit_dist, pp->pt_inhit->hit_dist,
			normvec[X], normvec[Y], normvec[Z] );
#endif
		return	thickness;
		}
	else     
		{ /* need to shoot ray */
			struct application a_thick;
			register struct hit *ihitp = pp->pt_inhit;
			register struct region *regp = pp->pt_regionp;
		a_thick = *ap;
		a_thick.a_hit = f_Normal;
		a_thick.a_miss = f_Nerror;
		a_thick.a_level++;     
		a_thick.a_user = regp->reg_regionid;
		a_thick.a_purpose = "normal thickness";
		CopyVec( a_thick.a_ray.r_pt, ihitp->hit_point );
		Scale2Vec( normvec, -1.0, a_thick.a_ray.r_dir );
		if( rt_shootray( &a_thick ) == -1 && fatalerror )
			{ /* Fatal error in application routine. */
			brst_log( "Fatal error: raytracing aborted.\n" );
			return	0.0;
			}
		return	a_thick.a_rbeam;
		}
	/*NOTREACHED*/
	}

void
prntDbgPartitions( ap, pt_headp, label )
struct application *ap;
struct partition *pt_headp;
char *label;
	{	struct partition *dpp;
	brst_log( "%s (0x%x)\n", label, pt_headp );
	if( ap != NULL )
		brst_log( "\tPnt %g,%g,%g Dir %g,%g,%g\n",
			ap->a_ray.r_pt[X],
			ap->a_ray.r_pt[Y],
			ap->a_ray.r_pt[Z],
			ap->a_ray.r_dir[X],
			ap->a_ray.r_dir[Y],
			ap->a_ray.r_dir[Z] );
	for( dpp = pt_headp->pt_forw; dpp != pt_headp; dpp = dpp->pt_forw )
		{
		brst_log( "\t0x%x: reg \"%s\" sols \"%s\",\"%s\" in %g out %g\n",
			dpp,
			dpp->pt_regionp->reg_name,
			dpp->pt_inseg->seg_stp->st_name,
			dpp->pt_outseg->seg_stp->st_name,
			dpp->pt_inhit->hit_dist,
			dpp->pt_outhit->hit_dist );
		brst_log( "\tinstp 0x%x outstp 0x%x inhit 0x%x outhit 0x%x\n",
			dpp->pt_inseg->seg_stp, dpp->pt_outseg->seg_stp,
			dpp->pt_inhit, dpp->pt_outhit );
		}
	brst_log( "--\n" );
	}

/*
	void prntShieldComp( struct application *ap, struct partition *pt_headp,
				Pt_Queue *qp )
 */
void
prntShieldComp( ap, pt_headp, qp )
struct application *ap;
struct partition *pt_headp;
register Pt_Queue *qp;
	{	fastf_t entrynorm[3], exitnorm[3];
	if( outfile[0] == NUL )
		return;
	if( qp == PT_Q_NULL )
		return;
	prntShieldComp( ap, pt_headp, qp->q_next );
	prntRegionHdr( ap, pt_headp, qp->q_part, entrynorm, exitnorm );
	}
void
prntColors( colorp, str )
register Colors	*colorp;
char	*str;
	{
	brst_log( "%s:\n", str );
	for(	colorp = colorp->c_next;
		colorp != COLORS_NULL;
		colorp = colorp->c_next )
		{
		brst_log( "\t%d..%d\t%d,%d,%d\n",
			(int)colorp->c_lower,
			(int)colorp->c_upper,
			(int)colorp->c_rgb[0],
			(int)colorp->c_rgb[1],
			(int)colorp->c_rgb[2]
			);
		}
	}

/*
	void prntFiringCoords( register fastf_t *vec )

	If the user has asked for grid coordinates to be saved, write
	them to the output stream 'gridfp'.
 */
void
prntFiringCoords( vec )
register fastf_t *vec;
	{
	if( gridfile[0] == '\0' )
		return;
	assert( gridfp != (FILE *) NULL );
	if( fprintf( gridfp, "%7.2f %7.2f\n", vec[X]*unitconv, vec[Y]*unitconv )
		< 0 )
		{
		brst_log( "Write failed to file (%s)!\n", gridfile );
		locPerror( "fprintf" );
		exitCleanly( 1 );
		}
	}

void
prntGridOffsets( x, y )
int	x, y;
	{
	if( ! tty )
		return;
	(void) ScMvCursor( GRID_X, GRID_Y );
	(void) printf( "[% 4d:% 4d,% 4d:% 4d]",
			x, gridxfin, y, gridyfin
			);
	(void) fflush( stdout );
	return;
	}

void
prntIdents( idp, str )
register Ids	*idp;
char	*str;
	{
	brst_log( "%s:\n", str );
	for( idp = idp->i_next ; idp != IDS_NULL; idp = idp->i_next )
		{
		if( idp->i_lower == idp->i_upper )
			brst_log( "\t%d\n", (int) idp->i_lower );
		else
			brst_log( "\t%d..%d\n",
				(int)idp->i_lower,
				(int)idp->i_upper
				);
		}
	return;
	}

/**/
void
prntPagedMenu( menu )
register char	**menu;
	{	register int	done = false;
		int		lines =	(PROMPT_Y-SCROLL_TOP);
	if( ! tty )
		{
		for( ; *menu != NULL; menu++ )
			brst_log( "%s\n", *menu );
		return;
		}
	for( ; *menu != NULL && ! done;  )
		{
		for( ; lines > 0 && *menu != NULL; menu++, --lines )
			brst_log( "%-*s\n", co, *menu );
		if( *menu != NULL )
			done = ! doMore( &lines );
		prompt( "" );
		}
	(void) fflush( stdout );
	return;
	}

/*
	void prntPhantom( struct hit *hitp, int space, fastf_t los )

	Output "phantom armor" pseudo component.  This component has no
	surface normal or thickness, so many zero fields are used for
	conformity with the normal component output formats.
 */
/*ARGSUSED*/
void
prntPhantom( hitp, space, los )
struct hit *hitp;	/* ptr. to phantom's intersection information */
int space;		/* space code behind phantom */
fastf_t	los;		/* LOS of space */
	{
	if(	outfile[0] != NUL
	    &&	fprintf( outfp,
			"%c % 8.2f % 8.2f %4d %2d % 7.3f % 7.3f % 7.3f %c\n",
			PB_RAY_INTERSECT,
			(standoff-hitp->hit_dist)*unitconv,
				/* X'-coordinate of intersection */
			0.0,	/* LOS thickness of component */
			PHANTOM_ARMOR, /* component code number */
			space,	/* space code */
			0.0,	/* sine of fallback angle */
			0.0,	/* rotation angle (degrees) */
			0.0, /* cosine of obliquity angle at entry */
			'0'	/* no burst from phantom armor */
			) < 0
		)
		{
		brst_log( "Write failed to file!\n", outfile );
		locPerror( "fprintf" );
		exitCleanly( 1 );
		}
	if(	shotlnfile[0] != NUL
	    &&	fprintf( shotlnfp,
	       "%c % 8.2f % 7.3f % 7.3f %4d % 8.2f % 8.2f %2d % 7.2f % 7.2f\n",
			PS_SHOT_INTERSECT,
			(standoff-hitp->hit_dist)*unitconv,
					/* X'-coordinate of intersection */
			0.0,		/* sine of fallback angle */
			0.0,		/* rotation angle in degrees */
			PHANTOM_ARMOR,	/* component code number */
			0.0,		/* normal thickness of component */
			0.0,		/* LOS thickness of component */
			space,		/* space code */
			0.0,		/* entry obliquity angle in degrees */
			0.0		/* exit obliquity angle in degrees */
			) < 0
		)
		{
		brst_log( "Write failed to file (%s)!\n", shotlnfile );
		locPerror( "fprintf" );
		exitCleanly( 1 );
		}
	return;
	}
#if defined(HAVE_STDARG_H)
/* STDARG */
void
prntScr( char *format, ... )
	{
		va_list	ap;
	va_start( ap, format );
#else
/* VARARGS */
void
prntScr( va_alist )
va_dcl
	{	register char *format; /* picked up by va_arg() */
		va_list	ap;
	va_start( ap );
#endif
	format  = va_arg( ap, char * );
	if( tty )
		{
		TcClrTabs( HmTtyFd );
		if( ScDL != NULL )
			{
			(void) ScMvCursor( 1, SCROLL_TOP );
			(void) ScDeleteLn();
			(void) ScMvCursor( 1, SCROLL_BTM );
			(void) ScClrEOL();
			(void) vprintf( format, ap );
			}
		else
		if( ScSetScrlReg( SCROLL_TOP, SCROLL_BTM+1 ) )
			{	char buf[LNBUFSZ];
			(void) ScMvCursor( 1, SCROLL_BTM+1 );
			(void) ScClrEOL();
			/* Work around for problem with vprintf(): it doesn't
				cause the screen to scroll, don't know why. */
			(void) vsprintf( buf, format, ap );
			(void) puts( buf );
			/*(void) vprintf( format, ap );*/
			(void) ScMvCursor( 1, SCROLL_BTM+1 );
			(void) ScClrScrlReg();
			}
		else
			{
			(void) vprintf( format, ap );
			(void) fputs( "\n", stdout );
			}
		(void) fflush( stdout );
		}
	else
		{
		(void) vfprintf( stderr, format, ap );
		(void) fputs( "\n", stderr );
		}
	va_end( ap );
	return;
	}



/*
	void	prntTimer( char *str )
 */
void
prntTimer( str )
char    *str;
	{
	(void) rt_read_timer( timer, TIMER_LEN-1 );
	if( tty )
		{
		(void) ScMvCursor( TIMER_X, TIMER_Y );
		if( str == NULL )
			(void) printf( "%s", timer );
		else
			(void) printf( "%s:\t%s", str, timer );
		(void) ScClrEOL();
		(void) fflush( stdout );
		}
	else
		brst_log( "%s:\t%s\n", str == NULL ? "(null)" : str, timer );
	}

void
prntTitle( title )
char	*title;
	{
	if( ! tty || RT_G_DEBUG )
		brst_log( "%s\n", title == NULL ? "(null)" : title );
	}

static char	*usage[] =
	{
	"Usage: burst [-b]",
	"\tThe -b option suppresses the screen display (for batch jobs).",
	NULL
	};
void
prntUsage()
	{	register char   **p = usage;
	while( *p != NULL )
		(void) fprintf( stderr, "%s\n", *p++ );
	}

void
prompt( str )
char    *str;
	{
	(void) ScMvCursor( PROMPT_X, PROMPT_Y );
	if( str == (char *) NULL )
		(void) ScClrEOL();
	else
		{
		(void) ScSetStandout();
		(void) fputs( str, stdout );
		(void) ScClrStandout();
		}
	(void) fflush( stdout );
	}

int
qAdd( pp, qpp )
struct partition	*pp;
Pt_Queue		**qpp;
	{	Pt_Queue	*newq;
	bu_semaphore_acquire( BU_SEM_SYSCALL );
	if( (newq = (Pt_Queue *) malloc( sizeof(Pt_Queue) )) == PT_Q_NULL )
		{
		Malloc_Bomb( sizeof(Pt_Queue) );
		bu_semaphore_release( BU_SEM_SYSCALL );
		return	0;
		}
	bu_semaphore_release( BU_SEM_SYSCALL );
	newq->q_next = *qpp;
	newq->q_part = pp;
	*qpp = newq;
	return	1;
	}

void
qFree( qp )
Pt_Queue	*qp;
	{
	if( qp == PT_Q_NULL )
		return;
	qFree( qp->q_next );
	bu_semaphore_acquire( BU_SEM_SYSCALL );
	free( (char *) qp );
	bu_semaphore_release( BU_SEM_SYSCALL );
	}

void
warning( str )
char	*str;
	{
	if( tty )
		HmError( str );
	else
		prntScr( str );
	}
@


1.31
log
@change conf.h to a wrapped config.h
@
text
@d8 1
a8 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/burst/prnt.c,v 1.30 2001/10/17 07:40:00 morrison Exp $ (BRL)";
@


1.30
log
@Mac OS X warning and error fixes for non-production build
@
text
@d8 1
a8 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/burst/prnt.c,v 1.29 2001/08/09 18:47:09 jra Exp $ (BRL)";
d25 5
a29 1
#include "conf.h"
@


1.29
log
@Lint
@
text
@d8 1
a8 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/burst/prnt.c,v 1.28 2001/05/17 20:03:05 morrison Exp $ (BRL)";
d23 1
@


1.28
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d8 1
a8 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/burst/prnt.c,v 1.27 2000/09/06 20:37:23 mike Exp $ (BRL)";
d142 1
a142 1
		register char	*p;
@


1.27
log
@
lint
@
text
@d8 1
a8 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/burst/prnt.c,v 1.26 2000/09/06 20:14:09 mike Exp $ (BRL)";
d943 1
a943 1
	if( ! tty || rt_g.debug )
@


1.26
log
@
Fixed printf format.
@
text
@d8 1
a8 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/burst/prnt.c,v 1.25 2000/08/24 23:12:44 mike Exp $ (BRL)";
d27 1
d29 1
d31 1
@


1.25
log
@
RCSid
@
text
@d8 1
a8 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/burst/prnt.c,v 1.24 1998/10/28 17:11:15 jra Exp $ (BRL)";
d488 1
a488 1
			"%c % 8.3f % 8.3f % 6u\n",
@


1.24
log
@Mods to get it to compile under Linux.
@
text
@d8 1
a8 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/burst/prnt.c,v 1.23 1998/06/27 04:56:23 mike Exp $ (BRL)";
@


1.23
log
@Use macro from conf.h rather than always saying "no" to sys_errlist[]
@
text
@d8 1
a8 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/burst/prnt.c,v 1.22 1998/06/27 04:51:30 mike Exp $ (BRL)";
d24 2
a30 1
#include "./vecmath.h"
@


1.22
log
@FreeBSD port.  sys_errlist is CONST *CONST sys_errlist[]; now.
@
text
@d8 1
a8 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/burst/prnt.c,v 1.21 1998/06/23 18:20:41 jra Exp $ (BRL)";
d114 1
a115 1
#if 0
@


1.21
log
@convert bu_log to brst_log to avoid conflicts
@
text
@d8 1
a8 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/burst/prnt.c,v 1.20 1998/03/26 08:10:18 mike Exp $ (BRL)";
d115 1
d117 1
@


1.20
log
@a_hit has extra arg
@
text
@d8 1
a8 1
static char RCSid[] = "@@(#)$Header: /m/cad/burst/RCS/prnt.c,v 1.19 1997/12/16 03:45:56 mike Exp mike $ (BRL)";
d75 1
a75 1
	bu_log( "Couldn't compute thickness or exit point %s.\n",
d77 2
a78 2
	V_Print( "\tpnt", ap->a_ray.r_pt, bu_log );
	V_Print( "\tdir", ap->a_ray.r_dir, bu_log );
d105 1
a105 1
	bu_log( "f_Normal: thickness=%g dout=%g din=%g\n",
d122 1
a122 1
		bu_log( "%s: %s\n", msg, sys_errlist[errno] );
d124 1
a124 1
		bu_log( "BUG: errno not set, shouldn't call perror.\n" );
d207 1
a207 1
		bu_log( "Write failed to file (%s)!\n", outfile );
d230 1
a230 1
		bu_log( "Write failed to file (%s)!\n", shotlnfile );
d269 1
a269 1
		bu_log( "Write failed to file (%s)!\n", outfile );
d288 1
a288 1
		bu_log( "Write failed to file (%s)!\n", outfile );
d318 1
a318 1
		bu_log( "Write failed to file (%s)!\n", outfile );
d333 1
a333 1
		bu_log( "Write failed to file (%s)!\n", shotlnfile );
d387 1
a387 1
	bu_log( "prntSeg: los=%g dout=%g din=%g\n",
d408 1
a408 1
		bu_log( "Write failed to file (%s)!\n", outfile );
d420 2
a421 2
		bu_log( "Couldn't compute normal thickness.\n" );
		bu_log( "\tshotline coordinates <%g,%g>\n",
d425 1
a425 1
		bu_log( "\tregion name '%s' solid name '%s'\n",
d450 1
a450 1
		bu_log( "Write failed to file (%s)!\n", shotlnfile );
d493 1
a493 1
		bu_log( "Write failed to file (%s)!\n", outfile );
d548 2
a549 2
		bu_log( "cosobliquity=%12.8f\n", cosobliquity );
		bu_log( "normal=<%g,%g,%g>\n",
d554 1
a554 1
		bu_log( "ray direction=<%g,%g,%g>\n",
d559 1
a559 1
		bu_log( "region name '%s'\n", regp->reg_name );
d583 1
a583 1
		bu_log( "Write failed to file (%s)!\n", outfile );
d608 1
a608 1
	bu_log( "getNormThickness() pp 0x%x normal %g,%g,%g\n",
d617 2
a618 2
		bu_log( "getNormThickness: using existing partitions.\n" );
		bu_log( "\tthickness=%g dout=%g din=%g normal=%g,%g,%g\n",
d640 1
a640 1
			bu_log( "Fatal error: raytracing aborted.\n" );
d654 1
a654 1
	bu_log( "%s (0x%x)\n", label, pt_headp );
d656 1
a656 1
		bu_log( "\tPnt %g,%g,%g Dir %g,%g,%g\n",
d665 1
a665 1
		bu_log( "\t0x%x: reg \"%s\" sols \"%s\",\"%s\" in %g out %g\n",
d672 1
a672 1
		bu_log( "\tinstp 0x%x outstp 0x%x inhit 0x%x outhit 0x%x\n",
d676 1
a676 1
	bu_log( "--\n" );
d701 1
a701 1
	bu_log( "%s:\n", str );
d706 1
a706 1
		bu_log( "\t%d..%d\t%d,%d,%d\n",
d732 1
a732 1
		bu_log( "Write failed to file (%s)!\n", gridfile );
d757 1
a757 1
	bu_log( "%s:\n", str );
d761 1
a761 1
			bu_log( "\t%d\n", (int) idp->i_lower );
d763 1
a763 1
			bu_log( "\t%d..%d\n",
d780 1
a780 1
			bu_log( "%s\n", *menu );
d786 1
a786 1
			bu_log( "%-*s\n", co, *menu );
d825 1
a825 1
		bu_log( "Write failed to file!\n", outfile );
d846 1
a846 1
		bu_log( "Write failed to file (%s)!\n", shotlnfile );
d930 1
a930 1
		bu_log( "%s:\t%s\n", str == NULL ? "(null)" : str, timer );
d938 1
a938 1
		bu_log( "%s\n", title == NULL ? "(null)" : title );
@


1.19
log
@UPgraded using h/sed4
@
text
@d8 1
a8 1
static char RCSid[] = "@@(#)$Header: /m/cad/burst/RCS/prnt.c,v 1.18 1996/07/18 17:32:30 jra Exp mike $ (BRL)";
d90 1
a90 1
f_Normal( ap, pt_headp )
d93 1
@


1.18
log
@Minor Mods for IRIX 6.2
@
text
@d8 1
a8 1
static char RCSid[] = "@@(#)$Header: /m/cad/burst/RCS/prnt.c,v 1.17 1993/12/22 08:20:20 moss Exp jra $ (BRL)";
d75 1
a75 1
	rt_log( "Couldn't compute thickness or exit point %s.\n",
d77 2
a78 2
	V_Print( "\tpnt", ap->a_ray.r_pt, rt_log );
	V_Print( "\tdir", ap->a_ray.r_dir, rt_log );
d104 1
a104 1
	rt_log( "f_Normal: thickness=%g dout=%g din=%g\n",
d121 1
a121 1
		rt_log( "%s: %s\n", msg, sys_errlist[errno] );
d123 1
a123 1
		rt_log( "BUG: errno not set, shouldn't call perror.\n" );
d206 1
a206 1
		rt_log( "Write failed to file (%s)!\n", outfile );
d229 1
a229 1
		rt_log( "Write failed to file (%s)!\n", shotlnfile );
d268 1
a268 1
		rt_log( "Write failed to file (%s)!\n", outfile );
d287 1
a287 1
		rt_log( "Write failed to file (%s)!\n", outfile );
d317 1
a317 1
		rt_log( "Write failed to file (%s)!\n", outfile );
d332 1
a332 1
		rt_log( "Write failed to file (%s)!\n", shotlnfile );
d386 1
a386 1
	rt_log( "prntSeg: los=%g dout=%g din=%g\n",
d407 1
a407 1
		rt_log( "Write failed to file (%s)!\n", outfile );
d419 2
a420 2
		rt_log( "Couldn't compute normal thickness.\n" );
		rt_log( "\tshotline coordinates <%g,%g>\n",
d424 1
a424 1
		rt_log( "\tregion name '%s' solid name '%s'\n",
d449 1
a449 1
		rt_log( "Write failed to file (%s)!\n", shotlnfile );
d492 1
a492 1
		rt_log( "Write failed to file (%s)!\n", outfile );
d547 2
a548 2
		rt_log( "cosobliquity=%12.8f\n", cosobliquity );
		rt_log( "normal=<%g,%g,%g>\n",
d553 1
a553 1
		rt_log( "ray direction=<%g,%g,%g>\n",
d558 1
a558 1
		rt_log( "region name '%s'\n", regp->reg_name );
d567 1
a567 1
	RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
d581 2
a582 2
		RES_RELEASE( &rt_g.res_syscall );	/* unlock */
		rt_log( "Write failed to file (%s)!\n", outfile );
d586 1
a586 1
	RES_RELEASE( &rt_g.res_syscall );	/* unlock */
d607 1
a607 1
	rt_log( "getNormThickness() pp 0x%x normal %g,%g,%g\n",
d616 2
a617 2
		rt_log( "getNormThickness: using existing partitions.\n" );
		rt_log( "\tthickness=%g dout=%g din=%g normal=%g,%g,%g\n",
d639 1
a639 1
			rt_log( "Fatal error: raytracing aborted.\n" );
d653 1
a653 1
	rt_log( "%s (0x%x)\n", label, pt_headp );
d655 1
a655 1
		rt_log( "\tPnt %g,%g,%g Dir %g,%g,%g\n",
d664 1
a664 1
		rt_log( "\t0x%x: reg \"%s\" sols \"%s\",\"%s\" in %g out %g\n",
d671 1
a671 1
		rt_log( "\tinstp 0x%x outstp 0x%x inhit 0x%x outhit 0x%x\n",
d675 1
a675 1
	rt_log( "--\n" );
d700 1
a700 1
	rt_log( "%s:\n", str );
d705 1
a705 1
		rt_log( "\t%d..%d\t%d,%d,%d\n",
d731 1
a731 1
		rt_log( "Write failed to file (%s)!\n", gridfile );
d756 1
a756 1
	rt_log( "%s:\n", str );
d760 1
a760 1
			rt_log( "\t%d\n", (int) idp->i_lower );
d762 1
a762 1
			rt_log( "\t%d..%d\n",
d779 1
a779 1
			rt_log( "%s\n", *menu );
d785 1
a785 1
			rt_log( "%-*s\n", co, *menu );
d824 1
a824 1
		rt_log( "Write failed to file!\n", outfile );
d845 1
a845 1
		rt_log( "Write failed to file (%s)!\n", shotlnfile );
d929 1
a929 1
		rt_log( "%s:\t%s\n", str == NULL ? "(null)" : str, timer );
d937 1
a937 1
		rt_log( "%s\n", title == NULL ? "(null)" : title );
d974 1
a974 1
	RES_ACQUIRE( &rt_g.res_syscall );
d978 1
a978 1
		RES_RELEASE( &rt_g.res_syscall );
d981 1
a981 1
	RES_RELEASE( &rt_g.res_syscall );
d995 1
a995 1
	RES_ACQUIRE( &rt_g.res_syscall );
d997 1
a997 1
	RES_RELEASE( &rt_g.res_syscall );
@


1.17
log
@The X' direction in prntBurstHdr was reversed.
@
text
@d8 1
a8 1
static char RCSid[] = "@@(#)$Header: /vld/moss/src/burst/RCS/prnt.c,v 1.16 93/12/15 11:46:21 moss Exp Locker: moss $ (BRL)";
d851 8
a858 2

#include <varargs.h>
d866 1
@


1.16
log
@Added output of '2' and '3' records when inputing burst points or bursting
on the ground.
@
text
@d8 1
a8 1
static char RCSid[] = "@@(#)$Header: /vld/moss/src/burst/RCS/prnt.c,v 1.15 93/12/15 08:18:57 moss Exp Locker: moss $ (BRL)";
d237 1
a237 1
	void prntBurstHdr( fastf_t *bpt, fastf_t *vdir )
d247 3
a249 3
prntBurstHdr( bpt, vdir )
fastf_t *bpt;	/* burst point in model coords */
fastf_t *vdir;	/* direction of view (unit vector) */
d255 1
a255 1
	vec[X] = Dot( vdir, bpt );	/* X' */
@


1.15
log
@Apparently added burstflag to end of ray intersect record.
@
text
@d8 1
a8 1
static char RCSid[] = "@@(#)$Header: /vld/moss/src/burst/RCS/prnt.c,v 1.14 91/09/13 09:39:10 moss Exp $ (BRL)";
d234 57
@


1.14
log
@Added comment about definition of fallback angle.
@
text
@d8 1
a8 1
static char RCSid[] = "@@(#)$Header: /vld/moss/src/burst/RCS/prnt.c,v 1.13 91/09/11 10:45:19 moss Exp $ (BRL)";
d284 2
a285 1
			fastf_t entrynorm[3], fastf_t exitnorm[3] )
d292 1
a292 1
prntSeg( ap, cpp, space, entrynorm, exitnorm )
d298 1
d335 1
a335 1
			"%c % 8.2f % 8.2f %4d %2d % 7.3f % 7.2f % 7.3f\n",
d345 2
a346 1
			icosobliquity	/* cosine of obliquity angle at entry */
d753 1
a753 1
			"%c % 8.2f % 8.2f %4d %2d % 7.3f % 7.3f % 7.3f\n",
d762 2
a763 1
			0.0 /* cosine of obliquity angle at entry */
@


1.13
log
@Fixed handling of normals, was flipping them in place (in the hit struct),
now we make a private copy and flip it; required passing entry and/or
exit normals down to some functions.  The exit angle was being computed
from a reversed normal, also the sine of the fallback angle was negated.
Format of azimuth changed to 9.4f from 8.4 to allow for large negative
values (ie -270.0000).
@
text
@d8 1
a8 1
static char RCSid[] = "@@(#)$Header: /vld/moss/src/burst/RCS/prnt.c,v 1.12 91/08/26 11:05:21 moss Exp $ (BRL)";
d321 2
@


1.12
log
@Ported to ANSI C compiler; tested on XMP under UNICOS 5.1 and on SGI under
IRIX 3.3.1.
This version tests correctly using BRLCAD3.7.
@
text
@d8 1
a8 1
static char RCSid[] = "@@(#)$Header: /vld/moss/src/burst/RCS/prnt.c,v 1.11 91/01/15 13:53:28 moss Exp $ (BRL)";
d73 1
a73 1
struct application	*ap;
d75 1
a75 1
	rt_log( "Couldn't compute thickness or exit point%s.\n",
d91 5
a95 5
struct application	*ap;
struct partition	*pt_headp;
	{	register struct partition	*pp = pt_headp->pt_forw;
		register struct partition	*cp;
		register struct hit		*ohitp;
d103 1
a103 1
#ifdef DEBUG
d191 1
a191 1
			"%c % 8.4f % 8.4f % 5.2f % 10.2f %-6s % 9.6f\n",
d212 1
a212 1
		     "%c % 8.4f % 8.4f % 7.2f % 7.2f %7.2f %7.2f %7.2f %-6s\n",
d283 2
a284 1
	void prntSeg( struct application *ap, struct partition *cpp, int space )
d291 1
a291 1
prntSeg( ap, cpp, space )
d295 2
a304 4
		register struct hit *ihitp;
		register struct hit *ohitp;
		register struct soltab *istp;
		register struct soltab *ostp;
d306 7
a312 65
	/* fill in entry hit point and normal */
	istp = cpp->pt_inseg->seg_stp;
	ihitp = cpp->pt_inhit;
	RT_HIT_NORM( ihitp, istp, &(ap->a_ray) );
	
	/* check for flipped normal and fix */
	if( cpp->pt_inflip )
		{
		ScaleVec( ihitp->hit_normal, -1.0 );
		cpp->pt_inflip = 0;
		}
fixed_entry_normal:
	/* This *should* give negative of desired result, but make sure. */
	icosobliquity = Dot( ap->a_ray.r_dir, ihitp->hit_normal );
	if( NearZero( icosobliquity ) )
		icosobliquity = 0.0;
	else
	if( icosobliquity < 0.0 )
		icosobliquity = -icosobliquity;
	else 
		{ 
#ifdef DEBUG 
		rt_log( "prntSeg: fixed flipped entry normal.\n" );
		rt_log( "cosine of angle of obliquity is %12.9f\n",
			icosobliquity );
		rt_log( "\tregion name '%s' solid name '%s'\n",
			cpp->pt_regionp->reg_name,
			istp->st_name );
#endif
		ScaleVec( ihitp->hit_normal, -1.0 );
		goto fixed_entry_normal;
		}
	/* fill in exit hit point and normal */
	ostp = cpp->pt_outseg->seg_stp;
	ohitp = cpp->pt_outhit;
	RT_HIT_NORM( ohitp, ostp, &(ap->a_ray) );
	
	/* check for flipped normal and fix */
	if( cpp->pt_outflip )
		{
		ScaleVec( ohitp->hit_normal, -1.0 );
		cpp->pt_outflip = 0;
		}
fixed_exit_normal:
	/* This *should* give negative of desired result, but make sure. */
	ocosobliquity = Dot( ap->a_ray.r_dir, ohitp->hit_normal );
	if( NearZero( ocosobliquity ) )
		ocosobliquity = 0.0;
	else
	if( ocosobliquity < 0.0 )
		ocosobliquity = -ocosobliquity;
	else 
		{ 
#ifdef DEBUG 
		rt_log( "prntSeg: fixed flipped exit normal.\n" );
		rt_log( "cosine of angle of obliquity is %12.9f\n",
			ocosobliquity );
		rt_log( "\tregion name '%s' solid name '%s'\n",
			cpp->pt_regionp->reg_name,
			ostp->st_name );
#endif
		ScaleVec( ohitp->hit_normal, -1.0 );
		goto fixed_exit_normal;
		}
	if( ohitp->hit_normal[Y] == 0.0 && ohitp->hit_normal[X] == 0.0 )
d316 1
a316 1
		rotangle = atan2( ohitp->hit_normal[Y], ohitp->hit_normal[X] );
d321 1
a321 1
	sinfbangle = Dot( ohitp->hit_normal, zaxis );
d323 2
a324 2
	los = (cpp->pt_outhit->hit_dist-ihitp->hit_dist)*unitconv;
#ifdef DEBUG
d326 1
a326 1
		los, cpp->pt_outhit->hit_dist, ihitp->hit_dist );
d333 1
a333 1
			(standoff-ihitp->hit_dist)*unitconv,
d354 1
a354 1
		 getNormThickness( ap, cpp, icosobliquity )) <= 0.0
d364 1
a364 1
			istp->st_name );
d372 1
a372 1
			(standoff-ihitp->hit_dist)*unitconv,
a390 1
	return;
a433 1
	return;
d438 2
a439 1
				struct partition *pp )
d445 1
a445 1
prntRegionHdr( ap, pt_headp, pp )
d449 1
a454 1
		register struct soltab	*stp = pp->pt_inseg->seg_stp;
d456 5
a460 16
	/* fill in entry/exit normals and hit points */
	RT_HIT_NORM( ihitp, stp, rayp );
	Check_Iflip( pp, ihitp->hit_normal, rayp->r_dir );
	stp = pp->pt_outseg->seg_stp;
	RT_HIT_NORM( ohitp, stp, rayp );
	Check_Oflip( pp, ohitp->hit_normal, rayp->r_dir );

	/* calculate cosine of obliquity angle */
fixed_normal:
	cosobliquity = Dot( ap->a_ray.r_dir, ihitp->hit_normal );
	if( NearZero( cosobliquity ) )
		cosobliquity = 0.0;
	else
	if( cosobliquity < 0.0 )
		cosobliquity = -cosobliquity;
	else
d462 3
a464 3
#if DEBUG
		rt_log( "prntRegionHdr: fixed flipped entry normal.\n" );
		rt_log( "region name '%s'\n", regp->reg_name );
a465 2
		ScaleVec( ihitp->hit_normal, -1.0 );
		goto    fixed_normal;
d467 15
d487 3
a489 3
			ihitp->hit_normal[X],
			ihitp->hit_normal[Y],
			ihitp->hit_normal[Z]
d504 2
a505 2
	normthickness = getNormThickness( ap, pp, cosobliquity );
 	RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
a524 1
	return;
d529 1
a529 1
					fast_t cosobliquity )
d531 4
a534 4
	Given a partition structure with entry hit point and normal filled in,
	the current application structure and the cosine of the obliquity at
	entry to the component, return the normal thickness through the
	component at the given hit point.
d538 1
a538 1
getNormThickness( ap, pp, cosobliquity )
d542 1
d544 4
d553 1
a553 1
#ifdef DEBUG
d555 1
a555 1
		rt_log( "\tthickness=%g dout=%g din=%g\n",
d557 2
a558 1
			pp->pt_outhit->hit_dist, pp->pt_inhit->hit_dist );
a570 1
		a_thick.a_uptr = regp->reg_name;
d574 1
a574 4
#ifdef DEBUG
		rt_log( "getNormThickness: ray tracing.\n" );
#endif
		Scale2Vec( ihitp->hit_normal, -1.0, a_thick.a_ray.r_dir );
d585 31
d625 1
a625 1
	{
d631 1
a631 2
	prntRegionHdr( ap, pt_headp, qp->q_part );
	return;
a650 1
	return;
a672 1
	return;
a859 1
	return;
a867 1
	return;
a880 1
	return;
a896 1
	return;
a927 1
	return;
a937 1
	return;
@


1.11
log
@Removed author's phone number from top of file comment.  This will be
shipped as version 2.1.
@
text
@d8 1
a8 1
static char RCSid[] = "@@(#)$Header: /vld/moss/src/burst/RCS/prnt.c,v 1.10 90/09/14 14:27:28 moss Exp $ (BRL)";
a23 2
#include "./Sc.h"

d28 1
d321 3
d353 3
d526 3
@


1.10
log
@Added missing space before solid angle in burst library.
Added check for calling atan2(0,0); returns NaN on the SGIs.
@
text
@a5 1
			(301)278-6651 or AV-298-6651
d8 1
a8 1
static char RCSid[] = "@@(#)$Header: /vld/moss/src/burst/RCS/prnt.c,v 1.9 90/08/28 16:28:34 moss Exp $ (BRL)";
@


1.9
log
@Extracted debug write inadvertantly left in.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /vld/moss/src/burst/RCS/prnt.c,v 1.8 90/08/28 12:24:18 moss Exp $ (BRL)";
d25 1
a25 1
#include <Sc/Sc.h>
d193 1
a193 1
			"%c % 8.4f % 8.4f % 5.2f % 10.2f %-6s% 9.6f\n",
d367 9
a375 4
	rotangle = atan2( ohitp->hit_normal[Y], ohitp->hit_normal[X] );
	rotangle *= DEGRAD; /* convert to degrees */
	if( rotangle < 0.0 )
		rotangle += 360.0;
d472 4
a475 1
	azim = atan2( cosyr, cosxr );
@


1.8
log
@This is the official release of version 2.0 which includes mods in the
output format to both correct a misinterpretation of the ICD, facilitate
easier postprocessing, increase precision, etc.  Also an option to not
require burst air was added.  Finally, a bug fix involving adjacent inside
airs of the same type at the beginning of a shotline was implemented.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /vld/moss/src/burst/RCS/prnt.c,v 1.7 90/08/22 09:40:08 moss Exp $ (BRL)";
a297 1
		fastf_t	cosrotation;	/* cosine of rotation angle */
d367 4
a370 1
	cosrotation = Dot( ohitp->hit_normal, xaxis );
d372 1
a372 2
	rotangle = AproxEq( cosrotation, 1.0, COS_TOL ) ?
			0.0 : acos( cosrotation ) * DEGRAD;
d381 1
a381 1
			"%c % 8.2f % 8.2f %4d %2d % 7.3f % 7.3f % 7.3f\n",
d420 1
a420 1
	       "%c % 8.2f % 7.3f % 7.3f %4d % 8.2f % 8.2f %2d % 7.2f % 7.2f\n",
@


1.7
log
@About to make some sweeping revisions.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /usr/vld/moss/src/burst/RCS/prnt.c,v 1.6 89/10/31 12:20:09 moss Exp $ (BRL)";
d193 1
a193 1
			"%c % 8.4f % 8.4f % 4.1f % 10.2f %-6s\n",
d203 2
a204 1
			units == U_METERS ?      "meters" : "units?"
d243 3
d253 1
a253 1
			"%c % 8.2f % 8.2f\n",
d268 1
a268 1
			"%c % 8.2f % 8.2f\n",
d296 2
a297 1
	{	fastf_t cosobliquity;	/* cosine of obliquity at entry */
d307 2
a308 1
		register struct soltab *stp;
d311 1
a311 1
	stp = cpp->pt_inseg->seg_stp;
d313 1
a313 1
	RT_HIT_NORM( ihitp, stp, &(ap->a_ray) );
d323 3
a325 3
	cosobliquity = Dot( ap->a_ray.r_dir, ihitp->hit_normal );
	if( cosobliquity < 0.0 )
		cosobliquity = -cosobliquity;
d331 1
a331 1
			cosobliquity );
d334 1
a334 1
			stp->st_name );
d339 31
a369 2
	cosrotation = Dot( ihitp->hit_normal, xaxis );
	sinfbangle = Dot( ihitp->hit_normal, zaxis );
d388 3
a390 3
			sinfbangle,	/* sine of fallback angle */
			rotangle,	/* rotation angle in degrees */
			cosobliquity	/* cosine of obliquity angle at entry */
d400 2
a401 2
	entryangle = AproxEq( cosobliquity, 1.0, COS_TOL ) ?
			0.0 : acos( cosobliquity ) * DEGRAD;
d403 1
a403 1
		 getNormThickness( ap, cpp, cosobliquity )) <= 0.0
d413 1
a413 1
			stp->st_name );
d416 2
a417 31
	/* fill in exit hit point and normal */
	stp = cpp->pt_outseg->seg_stp;
	ohitp = cpp->pt_outhit;
	RT_HIT_NORM( ohitp, stp, &(ap->a_ray) );
	
	/* check for flipped normal and fix */
	if( cpp->pt_outflip )
		{
		ScaleVec( ohitp->hit_normal, -1.0 );
		cpp->pt_outflip = 0;
		}
fixed_exit_normal:
	/* This *should* give negative of desired result, but make sure. */
	cosobliquity = Dot( ap->a_ray.r_dir, ohitp->hit_normal );
	if( cosobliquity < 0.0 )
		cosobliquity = -cosobliquity;
	else 
		{ 
#ifdef DEBUG 
		rt_log( "prntSeg: fixed flipped exit normal.\n" );
		rt_log( "cosine of angle of obliquity is %12.9f\n",
			cosobliquity );
		rt_log( "\tregion name '%s' solid name '%s'\n",
			cpp->pt_regionp->reg_name,
			stp->st_name );
#endif
		ScaleVec( ohitp->hit_normal, -1.0 );
		goto fixed_exit_normal;
		}
	exitangle = AproxEq( cosobliquity, 1.0, COS_TOL ) ?
			0.0 : acos( cosobliquity ) * DEGRAD;
d423 2
a424 2
			sinfbangle,	/* sine of fallback angle */
			rotangle,	/* rotation angle in degrees */
d449 3
d469 1
a469 1
			"%c % 6.3f % 6.3f % 6u\n",
@


1.6
log
@This version released to Eglin and Service Engineering after BRL-CAD '89
Symposium.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /usr/vld/moss/src/burst/RCS/prnt.c,v 1.5 89/07/14 12:59:47 moss Exp $ (BRL)";
a81 1
	VSET( ap->a_vvec, 0.0, 0.0, 0.0 );
d89 1
a89 1
	Exit point returned in "a_vvec", thickness returned in "a_rbeam".
a96 1
		register struct xray		*rp = &ap->a_ray;
a104 1
	VJOIN1( ap->a_vvec, rp->r_pt, ohitp->hit_dist, rp->r_dir );
d576 1
a576 11
	{	struct application a_thick;
		register struct hit *ihitp = pp->pt_inhit;
		register struct region *regp = pp->pt_regionp;
	a_thick = *ap;
	a_thick.a_hit = f_Normal;
	a_thick.a_miss = f_Nerror;
	a_thick.a_level++;     
	a_thick.a_uptr = regp->reg_name;
	a_thick.a_user = regp->reg_regionid;
	a_thick.a_purpose = "normal thickness";
	CopyVec( a_thick.a_ray.r_pt, ihitp->hit_point );
d579 3
a581 6
			to shoot another ray.  We will use the
			f_Normal routine to make sure we are
			consistant in our calculations, even
			though it requires some unnecessary vector
			math. */
		CopyVec( a_thick.a_ray.r_dir, ap->a_ray.r_dir );
d584 3
d588 2
a589 2
		(void) f_Normal( &a_thick, pp->pt_back );
		} 
d592 11
d612 1
d614 1
a614 1
	return	a_thick.a_rbeam;
@


1.5
log
@This is the pre-release copy that Bud took with him.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /usr/vld/moss/src/burst/RCS/prnt.c,v 1.4 89/07/07 16:33:30 moss Exp $ (BRL)";
d588 1
d797 1
a797 2
prntScr( fmt, va_alist )
char	*fmt;
d799 2
a800 1
	{	va_list		ap;
d802 1
a805 8
		if( ScSetScrlReg( SCROLL_TOP, SCROLL_BTM ) )
			{
			(void) ScMvCursor( 1, SCROLL_BTM );
			(void) ScClrEOL();
			(void) _doprnt( fmt, ap, stdout );
			(void) ScClrScrlReg();
			}
		else
d812 1
a812 1
			(void) _doprnt( fmt, ap, stdout );
d815 13
d829 1
a829 1
			(void) _doprnt( fmt, ap, stdout );
d836 1
a836 1
		(void) _doprnt( fmt, ap, stderr );
@


1.4
log
@Ready for Bud's visit.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /usr/vld/moss/src/burst/RCS/prnt.c,v 1.3 89/01/20 15:21:29 moss Exp $ (BRL)";
d190 4
a193 1
	{
d196 1
a196 1
			"%c % 8.4f % 8.4f\n",
d199 8
a206 1
			viewelev*DEGRAD	 /* attack elevation in degrees */
d216 1
a216 1
			"%c % 8.4f % 8.4f % 7.2f % 7.2f %7.2f %7.2f %7.2f\n",
d221 9
a229 4
			gridrt*unitconv, /* maximum Y'-coordinate of target */
			gridlf*unitconv, /* minimum Y'-coordinate of target */
			gridup*unitconv, /* maximum Z'-coordinate of target */
			griddn*unitconv  /* minimum Z'-coordinate of target */
d241 1
a241 1
	void prntCellIdent( struct application *ap, struct partition *pt_headp )
d247 3
a249 8
prntCellIdent( ap, pt_headp )
register struct application	*ap;
struct partition		*pt_headp;
	{	fastf_t projarea;	/* projected area */
	/* Convert to user units before squaring cell size. */
	projarea = cellsz*unitconv;
	projarea *= projarea;

d252 1
a252 1
			"%c % 7.2f % 7.2f % 4.1f % 10.2f\n",
d256 1
a256 1
			ap->a_uvec[Y]*unitconv,
a257 3
			bdist*unitconv, /* BDIST */
			/* projected area associated with burst point */
			projarea
d348 1
a348 1
			"%c % 8.2f % 8.2f %4d % 7.3f % 7.3f % 7.3f\n",
d350 1
a350 1
			ihitp->hit_dist*unitconv,
d355 1
d418 1
a418 1
			ihitp->hit_dist*unitconv,
d752 1
a752 1
			"%c % 8.2f % 8.2f %4d % 7.3f % 7.3f % 7.3f\n",
d754 2
a755 2
			hitp->hit_dist*unitconv,
				/* X' coordinate of intersection */
d758 1
d773 1
a773 1
			hitp->hit_dist*unitconv,
@


1.3
log
@Just saving this version for backup purposes, recently added support for
explicitly inputing burst points.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /usr/vld/moss/src/burst/RCS/prnt.c,v 1.2 88/11/07 17:02:11 moss Exp $ (BRL)";
d11 10
d24 1
a24 1
#include <assert.h>
d26 1
d30 1
d34 2
d40 2
d73 1
a73 1
_LOCAL_ int
d77 2
a78 1
	rt_log( "Couldn't compute thickness or exit point along normal direction.\n" );
d92 1
a92 1
_LOCAL_ int
d108 4
d182 6
d191 168
a358 1
	if( outfile[0] == NUL )
d360 62
a421 10
	if(	fprintf( outfp,
			"%c % 7.2f% 7.2f% 9.3f% 9.3f% 9.3f% 7.1f% 9.6f\n",
			P_ASPECT_INIT,
			viewazim*DEGRAD,
			viewelev*DEGRAD,
			modlcntr[X]*unitconv,
			modlcntr[Y]*unitconv,
			modlcntr[Z]*unitconv,
			cellsz*unitconv,
			raysolidangle
d425 1
a425 1
		rt_log( "prntAspectInit: Write failed to data file!\n" );
d432 2
a433 1
/*	prntBurstHdr()
d435 3
a437 1
	Report info about burst point.
d440 8
a447 5
prntBurstHdr( ap, cpp, app, bpt )
struct application	*ap;
struct partition	*cpp, *app;
fastf_t			*bpt;
	{	FILE			*fp = outfp;
d450 10
a459 14
	if(	fprintf( fp,
			"%c % 8.2f% 8.2f% 8.2f% 8.2f% 8.2f% 8.2f% 8.2f% 8.2f% 8.2f\n",
			P_BURST_HEADER,
			/* entry point to spalling component */
			cpp->pt_inhit->hit_point[X]*unitconv,
			cpp->pt_inhit->hit_point[Y]*unitconv,
			cpp->pt_inhit->hit_point[Z]*unitconv,
			bpt[X]*unitconv, /* burst point */
			bpt[Y]*unitconv,
			bpt[Z]*unitconv,
			/* exit point along normal of component */
			ap->a_vvec[X]*unitconv,
			ap->a_vvec[Y]*unitconv,
			ap->a_vvec[Z]*unitconv
d463 1
a463 1
		rt_log( "prntBurst_Header: Write failed to data file!\n" );
d470 7
d478 49
a526 4
prntCellIdent( ap, pt_headp )
register struct application	*ap;
struct partition		*pt_headp;
	{	FILE	*fp = outfp;
d529 15
a543 18
	if( fprintf(	fp,
			"%c % 8.1f% 8.1f%3d% 8.2f% 8.2f% 9.3f% 9.3f\n",
			P_CELL_IDENT,
			ap->a_x*cellsz*unitconv,
				/* Horizontal center of cell.	*/
			ap->a_y*cellsz*unitconv,
				/* Vertical center of cell.	*/
			ap->a_user, /* Two-digit random number.	*/
			(standoff-pt_headp->pt_forw->pt_inhit->hit_dist)*
				unitconv,
			 /* Distance 1st contact to grid plane.	*/
			(standoff-pt_headp->pt_back->pt_outhit->hit_dist)*
				unitconv,
			 /* Distance last contact to grid plane.*/
			ap->a_uvec[X]*unitconv,
			 /* Actual horizontal coord. in cell.	*/
			ap->a_uvec[Y]*unitconv
			 /* Actual vertical coordinate in cell.	*/
d547 2
a548 1
		rt_log( "prntCellIdent: Write failed to data file!\n" );
d552 1
d556 57
d614 14
d633 3
a635 1
	for( colorp = colorp->c_next ; colorp != COLORS_NULL; colorp = colorp->c_next )
d664 1
a664 1
		rt_log( "prntFiringCoords: Write failed to data file!\n" );
a685 22
prntHeaderInit()
	{	long	clock;
		char	*date;
	if( outfile[0] == NUL )
		return;
	clock = time( (long *) 0 );
	date = strtok( asctime( localtime( &clock ) ), "\n" );
	if(	fprintf( outfp, "%c %-26s    %s\n",
			P_HEADER_INIT,
			date,
			title
			) < 0
		)
		{
		rt_log( "prntHeaderInit: Write failed to data file!\n" );
		locPerror( "fprintf" );
		exitCleanly( 1 );
		}
	return;
	}

void
d728 2
a729 1
/*	prntPhantom()
d731 3
a733 1
	Output "phantom armor" pseudo component.
d735 1
d737 16
a752 18
prntPhantom( ap, space, los, ct )
struct application		*ap;
int				space;/* Space code behind phantom.	*/
fastf_t				los;  /* LOS of space behind phantom.	*/
int				ct;   /* Count of components hit.	*/
	{	FILE	*fp = outfp;
	if( outfile[0] == NUL )
		return;
	if(	fprintf( fp,
			"%c %4d% 8.2f% 8.2f% 6.1f%3d% 8.2f%5d\n",
			P_RAY_INTERSECT,
			PHANTOM_ARMOR,	/* Special item code.		*/
			0.0,		/* LOS through item.		*/
			0.0,		/* Normal at entrance.		*/
			0.0,		/* Obliquity.			*/
			space,		/* Space code.			*/
			los*unitconv,	/* LOS through space.		*/
			ct		/* Cumulative count of items.	*/
d756 1
a756 1
		rt_log( "prntPhantom: Write failed to data file!\n" );
d760 14
a773 26
	return;
	}

void
prntRegionHdr( ap, hitp, regp, nbar )
register struct application	*ap;
register struct hit		*hitp;
struct region			*regp;
int				nbar;
	{	FILE	*fp = outfp;
		fastf_t	sqrconvdist;
	if( outfile[0] == NUL )
		return;
	sqrconvdist = hitp->hit_dist * unitconv;
	sqrconvdist = Sqr( sqrconvdist );
	RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
	if(	fprintf( fp,
			"%c %4d% 10.3f% 10.3f% 10.3f% 10.3f%5d%6d\n",
			P_REGION_HEADER,
			regp->reg_regionid,
			hitp->hit_point[X]*unitconv,
			hitp->hit_point[Y]*unitconv,
			hitp->hit_point[Z]*unitconv,
			raysolidangle*sqrconvdist,
			nbar,
			ap->a_user /* Ray number.			*/
d777 1
a777 2
		RES_RELEASE( &rt_g.res_syscall );	/* unlock */
		rt_log( "prntRegion_Header: Write failed to data file!\n" );
a780 1
	RES_RELEASE( &rt_g.res_syscall );	/* unlock */
a826 1
/*	prntSeg()
a827 16
	Report info about each component hit along path of main
	penetrator.
 */
void
prntSeg( ap, cpp, burst, space, los, ct )
register struct application	*ap;
register struct partition	*cpp; /* Component partition.		*/
int				burst;/* Boolean - is this a burst pt.	*/
int				space;
fastf_t				los;
int				ct;   /* Count of components hit.	*/
	{	FILE			*fp = outfp;
		fastf_t			cosobliquity;
		register struct hit	*ihitp;
		register struct soltab	*stp;
		struct application	a_thick;
a828 123
	/* Fill in hit point and normal.				*/
	stp = cpp->pt_inseg->seg_stp;
	ihitp = cpp->pt_inhit;
	RT_HIT_NORM( ihitp, stp, &(ap->a_ray) );
	
	/* Check for flipped normal and fix.				*/
	if( cpp->pt_inflip )
		{
		ScaleVec( ihitp->hit_normal, -1.0 );
		cpp->pt_inflip = 0;
		}
	cosobliquity = Dot( ap->a_ray.r_dir, ihitp->hit_normal );
	if( cosobliquity < 0.0 )
		cosobliquity = -cosobliquity;
#ifdef DEBUG
	else
		rt_log( "Entry normal backwards.\n" );
#endif

	if( outfile[0] == NUL )
		return;

	if( burst )
		{
		/* Now we must find normal thickness through component.	*/
		a_thick = *ap;
		a_thick.a_hit = f_Normal;
		a_thick.a_miss = f_Nerror;
		a_thick.a_level++;
		CopyVec( a_thick.a_ray.r_pt, ihitp->hit_point );
		Scale2Vec( ihitp->hit_normal, -1.0, a_thick.a_ray.r_dir );
		if( rt_shootray( &a_thick ) == -1 && fatalerror )
			{
			/* Fatal error in application routine.	*/
			rt_log( "Fatal error: raytracing aborted.\n" );
			return;
			}
		CopyVec( ap->a_vvec,  a_thick.a_vvec );
		}
	else
		a_thick.a_rbeam = 0.0;
	if(	fprintf( fp,
			"%c %4d% 8.2f% 8.2f% 6.1f%3d% 8.2f%5d\n",
			P_RAY_INTERSECT,
			cpp->pt_regionp->reg_regionid,
				/* Item code.				*/
			(cpp->pt_outhit->hit_dist-ihitp->hit_dist)*unitconv,
				/* LOS through item.			*/
			a_thick.a_rbeam*unitconv, /* Normal thickness.	*/
			AproxEq( cosobliquity, 1.0, 0.01 ) ? 0.0 :
				acos( cosobliquity )*DEGRAD,
				/* Obliquity angle at entrance.		*/
			space,		/* Space code.			*/
			los*unitconv,	/* LOS through space.		*/
			ct		/* Cumulative count of items.	*/
			) < 0
		)
		{
		rt_log( "prntSeg: Write failed to data file!\n" );
		locPerror( "fprintf" );
		exitCleanly( 1 );
		}
	return;
	}

void
prntShieldComp( ap, rayp, qp )
struct application	*ap;
register struct xray	*rayp;
register Pt_Queue	*qp;
	{	FILE			*fp = outfp;
		fastf_t			cosobliquity;
		register struct hit	*ihitp;
		register struct soltab	*stp;
	if( outfile[0] == NUL )
		return;
	if( qp == PT_Q_NULL )
		return;
	prntShieldComp( ap, rayp, qp->q_next );

	/* Fill in hit point and normal.				*/
	stp = qp->q_part->pt_inseg->seg_stp;
	ihitp = qp->q_part->pt_inhit;
	RT_HIT_NORM( ihitp, stp, rayp );
	
	/* Check for flipped normal and fix.				*/
	if( qp->q_part->pt_inflip )
		{
		ScaleVec( ihitp->hit_normal, -1.0 );
		qp->q_part->pt_inflip = 0;
		}
	/* This SHOULD give negative of desired result, but make sure.	*/
	cosobliquity = Dot( rayp->r_dir, ihitp->hit_normal );
	if( cosobliquity < 0.0 )
		cosobliquity = -cosobliquity;
#ifdef DEBUG
	else
		rt_log( "Entry normal backwards.\n" );
#endif
	RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
	if(	fprintf( fp,
			"%c %4d% 8.2f% 6.1f%4d\n",
			P_SHIELD_COMP,
			qp->q_part->pt_regionp->reg_regionid,
				/* Region ident of shielding component.	*/
			(qp->q_part->pt_outhit->hit_dist-ihitp->hit_dist)*unitconv,
				/* Line-of-sight thickness of shield.	*/
			AproxEq( cosobliquity, 1.0, 0.01 ) ? 0.0 :
				acos( cosobliquity )*DEGRAD,
				/* Obliquity angle of spall ray.	*/
			qp->q_space
			) < 0
		)
		{
		RES_RELEASE( &rt_g.res_syscall );	/* unlock */
		rt_log( "prntShieldComp: Write failed to data file!\n" );
		locPerror( "fprintf" );
		exitCleanly( 1 );
		}
	RES_RELEASE( &rt_g.res_syscall );	/* unlock */
	return;
	}

a906 1
	newq->q_space = pp->pt_forw->pt_regionp->reg_aircode;
@


1.2
log
@Just saving this version for fallback.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /usr/vld/moss/src/burst/RCS/prnt.c,v 1.1 88/10/28 17:02:22 moss Exp $ (BRL)";
d14 1
d27 85
d162 1
a162 2
warning( str )
char	*str;
d164 19
a182 4
	if( tty )
		HmError( str );
	else
		prntScr( str );
d186 1
d188 2
d191 23
a213 7
prompt( str )
char    *str;
	{
	(void) ScMvCursor( PROMPT_X, PROMPT_Y );
	if( str == (char *) NULL )
		(void) ScClrEOL();
	else
d215 3
a217 3
		(void) ScSetStandout();
		(void) fputs( str, stdout );
		(void) ScClrStandout();
a218 1
	(void) fflush( stdout );
a221 1
/**/
d223 26
a248 5
prntPagedMenu( menu )
register char	**menu;
	{	register int	done = false;
		int		lines =	(PROMPT_Y-SCROLL_TOP);
	if( ! tty )
d250 3
a252 3
		for( ; *menu != NULL; menu++ )
			rt_log( "%s\n", *menu );
		return;
d254 10
a263 1
	for( ; *menu != NULL && ! done;  )
d265 7
a271 5
		for( ; lines > 0 && *menu != NULL; menu++, --lines )
			rt_log( "%-*s\n", co, *menu );
		if( *menu != NULL )
			done = ! doMore( &lines );
		prompt( "" );
a272 1
	(void) fflush( stdout );
d276 15
a290 14
int
doMore( linesp )
int	*linesp;
	{	register int	ret = true;
	if( ! tty )
		return	true;
	TcSaveTty( HmTtyFd );
	TcSetRaw( HmTtyFd );
	TcClrEcho( HmTtyFd );
	ScSetStandout();
	prompt( "-- More -- " );
	ScClrStandout();
	(void) fflush( stdout );
	switch( HmGetchar() )
d292 3
a294 11
	case 'q' :
	case 'n' :
		ret = false;
		break;
	case LF :
	case CR :
		*linesp = 1;
		break;
	default :
		*linesp = (PROMPT_Y-SCROLL_TOP);
		break;
d296 1
a296 2
	TcResetTty( HmTtyFd );
	return	ret;
d300 2
a301 2
prntTitle( title )
char	*title;
d303 7
a309 2
	if( ! tty || rt_g.debug )
		rt_log( "%s\n", title == NULL ? "(null)" : title );
a312 1

d330 1
a330 1
		exit( 1 );
d336 3
a338 1
prntAspectInit()
d340 2
a341 14
	if( outfile[0] == NUL )
		return;
	if(	fprintf( outfp,
			"%c % 7.2f% 7.2f% 9.3f% 9.3f% 9.3f% 7.1f% 9.6f\n",
			P_ASPECT_INIT,
			viewazim*DEGRAD,
			viewelev*DEGRAD,
			modlcntr[X]*unitconv,
			modlcntr[Y]*unitconv,
			modlcntr[Z]*unitconv,
			cellsz*unitconv,
			raysolidangle
			) < 0
		)
d343 2
a344 65
		rt_log( "prntAspectInit: Write failed to data file!\n" );
		locPerror( "fprintf" );
		exit( 1 );
		}
	return;
	}

void
prntCellIdent( ap, pt_headp )
register struct application	*ap;
struct partition		*pt_headp;
	{	FILE	*fp = outfp;
	if( setback == 0.0 )
		{
		if( outfile[0] == NUL )
			return;
		if(	fprintf(fp,
				"%c % 8.1f% 8.1f%3d% 8.2f% 8.2f% 9.3f% 9.3f\n",
				P_CELL_IDENT,
				ap->a_x*cellsz*unitconv,
					/* Horizontal center of cell.	*/
				ap->a_y*cellsz*unitconv,
					/* Vertical center of cell.	*/
				ap->a_user, /* Two-digit random number.	*/
				(standoff-pt_headp->pt_forw->pt_inhit->hit_dist)*unitconv,
				 /* Distance 1st contact to grid plane.	*/
				(standoff-pt_headp->pt_back->pt_outhit->hit_dist)*unitconv,
				 /* Distance last contact to grid plane.*/
				ap->a_uvec[X]*unitconv,
				 /* Actual horizontal coord. in cell.	*/
				ap->a_uvec[Y]*unitconv
				 /* Actual vertical coordinate in cell.	*/
				) < 0
			)
			{
			rt_log( "prntCellIdent: Write failed to data file!\n" );
			locPerror( "fprintf" );
			exit( 1 );
			}
		}
	else
		{	register struct xray	*rayp = &ap->a_ray;
			register struct partition	*pp = pt_headp->pt_forw;
			register struct hit	*ihitp = pp->pt_inhit;
			register struct hit	*ohitp = pp->pt_outhit;
			register struct soltab	*stp = pp->pt_inseg->seg_stp;
			fastf_t			cosobliquity;
		/* Fill in entry hit point and normal.			*/
		RT_HIT_NORM( ihitp, stp, rayp );
		/* Fill in exit point.					*/
		VJOIN1( ohitp->hit_point, rayp->r_pt, ohitp->hit_dist, rayp->r_dir );
	
		/* Check for flipped normal and fix.			*/
		if( pp->pt_inflip )
			{
			ScaleVec( ihitp->hit_normal, -1.0 );
			pp->pt_inflip = 0;
			}
		if( outfile[0] == NUL )
			return;
		/* This SHOULD give negative of desired result, but make sure.*/
		cosobliquity = Dot( rayp->r_dir, ihitp->hit_normal );
		if( cosobliquity < 0.0 )
			cosobliquity = -cosobliquity;
#ifdef DEBUG
d346 4
a349 32
			rt_log( "Entry normal backwards.\n" );
#endif
		if(	fprintf(fp,
				"%c1% 8.1f% 8.1f%3d% 8.2f% 8.2f% 9.3f% 9.3f% 6.1f%5d% 8.2f",
				P_CELL_IDENT,
				ap->a_x*cellsz*unitconv,
					/* Horizontal center of cell.	*/
				ap->a_y*cellsz*unitconv,
					/* Vertical center of cell.	*/
				ap->a_user, /* Two-digit random number.	*/
				(standoff-pt_headp->pt_forw->pt_inhit->hit_dist)*unitconv,
				 /* Distance 1st contact to grid plane.	*/
				(standoff-pt_headp->pt_back->pt_outhit->hit_dist)*unitconv,
				 /* Distance last contact to grid plane.*/
				ap->a_uvec[X]*unitconv,
				 /* Actual horizontal coord. in cell.	*/
				ap->a_uvec[Y]*unitconv,
				 /* Actual vertical coordinate in cell.	*/
				AproxEq( cosobliquity, 1.0, 0.01 ) ? 0.0 :
					acos( cosobliquity )*DEGRAD,
				 /* Obliquity of projectile at impact.	*/
				pp->pt_regionp->reg_regionid,
				 /* Item # 1st component projectile hit.*/
				(ohitp->hit_dist - ihitp->hit_dist)*unitconv
				 /* LOS thickness through item.		*/
				) < 0
			)
			{
			rt_log( "prntCellIdent: Write failed to data file!\n" );
			locPerror( "fprintf" );
			exit( 1 );
			}
d354 1
d356 5
a360 18
prntComin( ap, pt_headp )
register struct application	*ap;
struct partition		*pt_headp;
	{	FILE	*fp = outfp;
		fastf_t	comin;

	if( outfile[0] == NUL )
		return;
	
	/* Output distance from shotline origin to 1st component hit along
		canted trajectory.  This is also known as COMIN or "component
		in" distance.
	 */
	if( pt_headp == PT_NULL )
		comin = 0.0;
	else
		comin = pt_headp->pt_forw->pt_inhit->hit_dist;
	if( fprintf( fp, "% 8.2f\n", comin ) < 0 )
d362 2
a363 101
		rt_log( "prntComin: Write failed to data file!\n" );
		locPerror( "fprintf" );
		exit( 1 );
		}
	return;
	}

/*	f_Normal()

	Shooting from surface of object along reversed entry normal to
	compute exit point along normal direction and normal thickness.
	Exit point returned in "a_vvec", thickness returned in "a_rbeam".
 */
_LOCAL_ int
f_Normal( ap, pt_headp )
struct application	*ap;
struct partition	*pt_headp;
	{	register struct partition	*pp = pt_headp->pt_forw;
		register struct partition	*cp;
		register struct xray		*rp = &ap->a_ray;
		register struct hit		*ohitp;
	for(	cp = pp->pt_forw;
		cp != pt_headp && SameCmp( pp->pt_regionp, cp->pt_regionp );
		cp = cp->pt_forw
		)
		;
	ohitp = cp->pt_back->pt_outhit;
	ap->a_rbeam = ohitp->hit_dist - pp->pt_inhit->hit_dist;
	VJOIN1( ap->a_vvec, rp->r_pt, ohitp->hit_dist, rp->r_dir );
	return	1;
	}

_LOCAL_ int
f_Nerror( ap )
struct application	*ap;
	{
	rt_log( "Couldn't compute thickness or exit point along normal direction.\n" );
	V_Print( "\tpnt", ap->a_ray.r_pt, rt_log );
	V_Print( "\tdir", ap->a_ray.r_dir, rt_log );
	ap->a_rbeam = 0.0;
	VSET( ap->a_vvec, 0.0, 0.0, 0.0 );
	return	0;
	}

#include <errno.h>
/* These aren't defined in BSD errno.h.					*/
extern int	errno;
extern int	sys_nerr;
extern char	*sys_errlist[];

void
locPerror( msg )
char    *msg;
	{
	if( errno > 0 && errno < sys_nerr )
		rt_log( "%s: %s\n", msg, sys_errlist[errno] );
	else
		rt_log( "BUG: errno not set, shouldn't call perror.\n" );
	return;
	}


/*	prntSeg()

	Report info about each component hit along path of main
	penetrator.
 */
void
prntSeg( ap, cpp, burst, space, los, ct )
register struct application	*ap;
register struct partition	*cpp; /* Component partition.		*/
int				burst;/* Boolean - is this a burst pt.	*/
int				space;
fastf_t				los;
int				ct;   /* Count of components hit.	*/
	{	FILE			*fp = outfp;
		fastf_t			cosobliquity;
		register struct hit	*ihitp;
		register struct soltab	*stp;
		struct application	a_thick;

	/* Fill in hit point and normal.				*/
	stp = cpp->pt_inseg->seg_stp;
	ihitp = cpp->pt_inhit;
	RT_HIT_NORM( ihitp, stp, &(ap->a_ray) );
	
	/* Check for flipped normal and fix.				*/
	if( cpp->pt_inflip )
		{
		ScaleVec( ihitp->hit_normal, -1.0 );
		cpp->pt_inflip = 0;
		}
	cosobliquity = Dot( ap->a_ray.r_dir, ihitp->hit_normal );
	if( cosobliquity < 0.0 )
		cosobliquity = -cosobliquity;
#ifdef DEBUG
	else
		rt_log( "Entry normal backwards.\n" );
#endif

	if( outfile[0] == NUL )
a364 17

	if( burst )
		{
		/* Now we must find normal thickness through component.	*/
		a_thick = *ap;
		a_thick.a_hit = f_Normal;
		a_thick.a_miss = f_Nerror;
		a_thick.a_level++;
		CopyVec( a_thick.a_ray.r_pt, ihitp->hit_point );
		Scale2Vec( ihitp->hit_normal, -1.0, a_thick.a_ray.r_dir );
		if( rt_shootray( &a_thick ) == -1 && fatalerror )
			{
			/* Fatal error in application routine.	*/
			rt_log( "Fatal error: raytracing aborted.\n" );
			return;
			}
		CopyVec( ap->a_vvec,  a_thick.a_vvec );
d366 1
a366 18
	else
		a_thick.a_rbeam = 0.0;
	if(	fprintf( fp,
			"%c %4d% 8.2f% 8.2f% 6.1f%3d% 8.2f%5d\n",
			P_RAY_INTERSECT,
			cpp->pt_regionp->reg_regionid,
				/* Item code.				*/
			(cpp->pt_outhit->hit_dist-ihitp->hit_dist)*unitconv,
				/* LOS through item.			*/
			a_thick.a_rbeam*unitconv, /* Normal thickness.	*/
			AproxEq( cosobliquity, 1.0, 0.01 ) ? 0.0 :
				acos( cosobliquity )*DEGRAD,
				/* Obliquity angle at entrance.		*/
			space,		/* Space code.			*/
			los*unitconv,	/* LOS through space.		*/
			ct		/* Cumulative count of items.	*/
			) < 0
		)
d368 5
a372 3
		rt_log( "prntSeg: Write failed to data file!\n" );
		locPerror( "fprintf" );
		exit( 1 );
d374 1
d406 1
a406 1
		exit( 1 );
a410 4
/*	prntBurstHdr()

	Report info about burst point.
 */
a411 32
prntBurstHdr( ap, cpp, app )
struct application	*ap;
struct partition	*cpp, *app;
	{	FILE			*fp = outfp;
	if( outfile[0] == NUL )
		return;
	if(	fprintf( fp,
			"%c % 8.2f% 8.2f% 8.2f% 8.2f% 8.2f% 8.2f% 8.2f% 8.2f% 8.2f\n",
			P_BURST_HEADER,
			/* Entry point to spalling component.		*/
			cpp->pt_inhit->hit_point[X]*unitconv,
			cpp->pt_inhit->hit_point[Y]*unitconv,
			cpp->pt_inhit->hit_point[Z]*unitconv,
			/* Burst point (exit from spalling component).	*/
			cpp->pt_outhit->hit_point[X]*unitconv,
			cpp->pt_outhit->hit_point[Y]*unitconv,
			cpp->pt_outhit->hit_point[Z]*unitconv,
			/* Exit point along normal of component.	*/
			ap->a_vvec[X]*unitconv,
			ap->a_vvec[Y]*unitconv,
			ap->a_vvec[Z]*unitconv
			) < 0
		)
		{
		rt_log( "prntBurst_Header: Write failed to data file!\n" );
		locPerror( "fprintf" );
		exit( 1 );
		}
	return;
	}

void
d440 1
a440 1
		exit( 1 );
d489 5
d495 79
d625 1
a625 1
		exit( 1 );
a630 38
void
prntIdents( idp, str )
register Ids	*idp;
char	*str;
	{
	rt_log( "%s:\n", str );
	for( idp = idp->i_next ; idp != IDS_NULL; idp = idp->i_next )
		{
		if( idp->i_lower == idp->i_upper )
			rt_log( "\t%d\n", (int) idp->i_lower );
		else
			rt_log( "\t%d..%d\n",
				(int)idp->i_lower,
				(int)idp->i_upper
				);
		}
	return;
	}

void
prntColors( colorp, str )
register Colors	*colorp;
char	*str;
	{
	rt_log( "%s:\n", str );
	for( colorp = colorp->c_next ; colorp != COLORS_NULL; colorp = colorp->c_next )
		{
		rt_log( "\t%d..%d\t%d,%d,%d\n",
			(int)colorp->c_lower,
			(int)colorp->c_upper,
			(int)colorp->c_rgb[0],
			(int)colorp->c_rgb[1],
			(int)colorp->c_rgb[2]
			);
		}
	return;
	}

d654 40
d728 2
a729 2
prntGridOffsets( x, y )
int	x, y;
d731 4
a734 21
	if( ! tty )
		return;
	(void) ScMvCursor( GRID_X, GRID_Y );
	(void) printf( "[% 4d:% 4d,% 4d:% 4d]",
			x, gridxfin, y, gridyfin
			);
	(void) fflush( stdout );
	return;
	}

static char	*usage[] =
	{
	"Usage: burst [-b]",
	"\tThe -b option suppresses the screen display (for batch jobs).",
	NULL
	};
void
prntUsage()
	{	register char   **p = usage;
	while( *p != NULL )
		(void) fprintf( stderr, "%s\n", *p++ );
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d24 79
@
