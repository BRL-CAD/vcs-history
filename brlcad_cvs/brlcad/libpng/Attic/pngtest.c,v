head	1.4;
access;
symbols
	ansi-20040405-merged:1.2.4.1
	postmerge-20040405-ansi:1.3
	premerge-20040404-ansi:1.3
	postmerge-autoconf:1.3
	autoconf-freeze:1.3
	premerge-autoconf:1.3
	ansi-20040316-freeze:1.2
	postmerge-20040315-windows:1.3
	premerge-20040315-windows:1.3
	windows-20040315-freeze:1.2.6.1
	autoconf-20031203:1.3
	autoconf-20031202:1.3
	autoconf-branch:1.3.0.6
	phong-branch:1.3.0.4
	photonmap-branch:1.3.0.2
	rel-6-1-DP:1.2
	windows-branch:1.2.0.6
	rel-6-0-2:1.2
	ansi-branch:1.2.0.4
	rel-6-0-1-branch:1.2.0.2
	hartley-6-0-post:1.2
	hartley-6-0-pre:1.2
	rel-6-0-1:1.2
	rel-6-0:1.2
	rel-5-4:1.1.1.1
	offsite-5-3-pre:1.1.1.1
	rel-5-3:1.1.1.1
	rel-5-2:1.1.1.1
	rel-5-1-branch:1.1.1.1.0.2
	rel-5-1:1.1.1.1
	rel-5-0:1.1.1.1
	rel-5-0-beta:1.1.1.1
	libpng_1_0_2:1.1.1.1
	libpng:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2004.05.21.18.05.29;	author morrison;	state dead;
branches;
next	1.3;

1.3
date	2002.12.26.14.39.09;	author jra;	state Exp;
branches;
next	1.2;

1.2
date	2001.04.20.22.29.37;	author morrison;	state Exp;
branches
	1.2.4.1
	1.2.6.1;
next	1.1;

1.1
date	98.06.24.20.00.14;	author jra;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.06.24.20.00.14;	author jra;	state Exp;
branches;
next	;

1.2.4.1
date	2004.03.17.21.18.36;	author morrison;	state Exp;
branches;
next	;

1.2.6.1
date	2004.03.11.23.43.20;	author morrison;	state Exp;
branches;
next	;


desc
@@


1.4
log
@moved from top-level to src/other/.
@
text
@
/* pngtest.c - a simple test program to test libpng
 *
 * libpng 1.2.5 - October 3, 2002
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1998-2002 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This program reads in a PNG image, writes it out again, and then
 * compares the two files.  If the files are identical, this shows that
 * the basic chunk handling, filtering, and (de)compression code is working
 * properly.  It does not currently test all of the transforms, although
 * it probably should.
 *
 * The program will report "FAIL" in certain legitimate cases:
 * 1) when the compression level or filter selection method is changed.
 * 2) when the maximum IDAT size (PNG_ZBUF_SIZE in pngconf.h) is not 8192.
 * 3) unknown unsafe-to-copy ancillary chunks or unknown critical chunks
 *    exist in the input file.
 * 4) others not listed here...
 * In these cases, it is best to check with another tool such as "pngcheck"
 * to see what the differences between the two files are.
 *
 * If a filename is given on the command-line, then this file is used
 * for the input, rather than the default "pngtest.png".  This allows
 * testing a wide variety of files easily.  You can also test a number
 * of files at once by typing "pngtest -m file1.png file2.png ..."
 */

#if defined(_WIN32_WCE)
#  if _WIN32_WCE < 211
     __error__ (f|w)printf functions are not supported on old WindowsCE.;
#  endif
#  include <windows.h>
#  include <stdlib.h>
#  define READFILE(file, data, length, check) \
     if (ReadFile(file, data, length, &check,NULL)) check = 0
#  define WRITEFILE(file, data, length, check)) \
     if (WriteFile(file, data, length, &check, NULL)) check = 0
#  define FCLOSE(file) CloseHandle(file)
#else
#  include <stdio.h>
#  include <stdlib.h>
#  include <assert.h>
#  define READFILE(file, data, length, check) \
     check=(png_size_t)fread(data,(png_size_t)1,length,file)
#  define WRITEFILE(file, data, length, check) \
     check=(png_size_t)fwrite(data,(png_size_t)1, length, file)
#  define FCLOSE(file) fclose(file)
#endif

#if defined(PNG_NO_STDIO)
#  if defined(_WIN32_WCE)
     typedef HANDLE                png_FILE_p;
#  else
     typedef FILE                * png_FILE_p;
#  endif
#endif

/* Makes pngtest verbose so we can find problems (needs to be before png.h) */
#ifndef PNG_DEBUG
#  define PNG_DEBUG 0
#endif

#if !PNG_DEBUG
#  define SINGLE_ROWBUF_ALLOC  /* makes buffer overruns easier to nail */
#endif

/* Turn on CPU timing
#define PNGTEST_TIMING
*/

#ifdef PNG_NO_FLOATING_POINT_SUPPORTED
#undef PNGTEST_TIMING
#endif

#ifdef PNGTEST_TIMING
static float t_start, t_stop, t_decode, t_encode, t_misc;
#include <time.h>
#endif

#include "png.h"

/* Define png_jmpbuf() in case we are using a pre-1.0.6 version of libpng */
#ifndef png_jmpbuf
#  define png_jmpbuf(png_ptr) png_ptr->jmpbuf
#endif

#ifdef PNGTEST_TIMING
static float t_start, t_stop, t_decode, t_encode, t_misc;
#if !defined(PNG_tIME_SUPPORTED)
#include <time.h>
#endif
#endif

#if defined(PNG_TIME_RFC1123_SUPPORTED)
static int tIME_chunk_present=0;
static char tIME_string[30] = "no tIME chunk present in file";
#endif

static int verbose = 0;

int test_one_file PNGARG((PNG_CONST char *inname, PNG_CONST char *outname));

#ifdef __TURBOC__
#include <mem.h>
#endif

/* defined so I can write to a file on gui/windowing platforms */
/*  #define STDERR stderr  */
#define STDERR stdout   /* for DOS */

/* example of using row callbacks to make a simple progress meter */
static int status_pass=1;
static int status_dots_requested=0;
static int status_dots=1;

void
#ifdef PNG_1_0_X
PNGAPI
#endif
read_row_callback(png_structp png_ptr, png_uint_32 row_number, int pass);
void
#ifdef PNG_1_0_X
PNGAPI
#endif
read_row_callback(png_structp png_ptr, png_uint_32 row_number, int pass)
{
    if(png_ptr == NULL || row_number > PNG_MAX_UINT) return;
    if(status_pass != pass)
    {
       fprintf(stdout,"\n Pass %d: ",pass);
       status_pass = pass;
       status_dots = 31;
    }
    status_dots--;
    if(status_dots == 0)
    {
       fprintf(stdout, "\n         ");
       status_dots=30;
    }
    fprintf(stdout, "r");
}

void
#ifdef PNG_1_0_X
PNGAPI
#endif
write_row_callback(png_structp png_ptr, png_uint_32 row_number, int pass);
void
#ifdef PNG_1_0_X
PNGAPI
#endif
write_row_callback(png_structp png_ptr, png_uint_32 row_number, int pass)
{
    if(png_ptr == NULL || row_number > PNG_MAX_UINT || pass > 7) return;
    fprintf(stdout, "w");
}


#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
/* Example of using user transform callback (we don't transform anything,
   but merely examine the row filters.  We set this to 256 rather than
   5 in case illegal filter values are present.) */
static png_uint_32 filters_used[256];
void
#ifdef PNG_1_0_X
PNGAPI
#endif
count_filters(png_structp png_ptr, png_row_infop row_info, png_bytep data);
void
#ifdef PNG_1_0_X
PNGAPI
#endif
count_filters(png_structp png_ptr, png_row_infop row_info, png_bytep data)
{
    if(png_ptr != NULL && row_info != NULL)
      ++filters_used[*(data-1)];
}
#endif

#if defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
/* example of using user transform callback (we don't transform anything,
   but merely count the zero samples) */

static png_uint_32 zero_samples;

void
#ifdef PNG_1_0_X
PNGAPI
#endif
count_zero_samples(png_structp png_ptr, png_row_infop row_info, png_bytep data);
void
#ifdef PNG_1_0_X
PNGAPI
#endif
count_zero_samples(png_structp png_ptr, png_row_infop row_info, png_bytep data)
{
   png_bytep dp = data;
   if(png_ptr == NULL)return;

   /* contents of row_info:
    *  png_uint_32 width      width of row
    *  png_uint_32 rowbytes   number of bytes in row
    *  png_byte color_type    color type of pixels
    *  png_byte bit_depth     bit depth of samples
    *  png_byte channels      number of channels (1-4)
    *  png_byte pixel_depth   bits per pixel (depth*channels)
    */


    /* counts the number of zero samples (or zero pixels if color_type is 3 */

    if(row_info->color_type == 0 || row_info->color_type == 3)
    {
       int pos=0;
       png_uint_32 n, nstop;
       for (n=0, nstop=row_info->width; n<nstop; n++)
       {
          if(row_info->bit_depth == 1)
          {
             if(((*dp << pos++ ) & 0x80) == 0) zero_samples++;
             if(pos == 8)
             {
                pos = 0;
                dp++;
             }
          }
          if(row_info->bit_depth == 2)
          {
             if(((*dp << (pos+=2)) & 0xc0) == 0) zero_samples++;
             if(pos == 8)
             {
                pos = 0;
                dp++;
             }
          }
          if(row_info->bit_depth == 4)
          {
             if(((*dp << (pos+=4)) & 0xf0) == 0) zero_samples++;
             if(pos == 8)
             {
                pos = 0;
                dp++;
             }
          }
          if(row_info->bit_depth == 8)
             if(*dp++ == 0) zero_samples++;
          if(row_info->bit_depth == 16)
          {
             if((*dp | *(dp+1)) == 0) zero_samples++;
             dp+=2;
          }
       }
    }
    else /* other color types */
    {
       png_uint_32 n, nstop;
       int channel;
       int color_channels = row_info->channels;
       if(row_info->color_type > 3)color_channels--;

       for (n=0, nstop=row_info->width; n<nstop; n++)
       {
          for (channel = 0; channel < color_channels; channel++)
          {
             if(row_info->bit_depth == 8)
                if(*dp++ == 0) zero_samples++;
             if(row_info->bit_depth == 16)
             {
                if((*dp | *(dp+1)) == 0) zero_samples++;
                dp+=2;
             }
          }
          if(row_info->color_type > 3)
          {
             dp++;
             if(row_info->bit_depth == 16)dp++;
          }
       }
    }
}
#endif /* PNG_WRITE_USER_TRANSFORM_SUPPORTED */

static int wrote_question = 0;

#if defined(PNG_NO_STDIO)
/* START of code to validate stdio-free compilation */
/* These copies of the default read/write functions come from pngrio.c and */
/* pngwio.c.  They allow "don't include stdio" testing of the library. */
/* This is the function that does the actual reading of data.  If you are
   not reading from a standard C stream, you should create a replacement
   read_data function and use it at run time with png_set_read_fn(), rather
   than changing the library. */

#ifndef USE_FAR_KEYWORD
static void
pngtest_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
{
   png_size_t check;

   /* fread() returns 0 on error, so it is OK to store this in a png_size_t
    * instead of an int, which is what fread() actually returns.
    */
   READFILE((png_FILE_p)png_ptr->io_ptr, data, length, check);

   if (check != length)
   {
      png_error(png_ptr, "Read Error!");
   }
}
#else
/* this is the model-independent version. Since the standard I/O library
   can't handle far buffers in the medium and small models, we have to copy
   the data.
*/

#define NEAR_BUF_SIZE 1024
#define MIN(a,b) (a <= b ? a : b)

static void
pngtest_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
{
   int check;
   png_byte *n_data;
   png_FILE_p io_ptr;

   /* Check if data really is near. If so, use usual code. */
   n_data = (png_byte *)CVT_PTR_NOCHECK(data);
   io_ptr = (png_FILE_p)CVT_PTR(png_ptr->io_ptr);
   if ((png_bytep)n_data == data)
   {
      READFILE(io_ptr, n_data, length, check);
   }
   else
   {
      png_byte buf[NEAR_BUF_SIZE];
      png_size_t read, remaining, err;
      check = 0;
      remaining = length;
      do
      {
         read = MIN(NEAR_BUF_SIZE, remaining);
         READFILE(io_ptr, buf, 1, err);
         png_memcpy(data, buf, read); /* copy far buffer to near buffer */
         if(err != read)
            break;
         else
            check += err;
         data += read;
         remaining -= read;
      }
      while (remaining != 0);
   }
   if (check != length)
   {
      png_error(png_ptr, "read Error");
   }
}
#endif /* USE_FAR_KEYWORD */

#if defined(PNG_WRITE_FLUSH_SUPPORTED)
static void
pngtest_flush(png_structp png_ptr)
{
#if !defined(_WIN32_WCE)
   png_FILE_p io_ptr;
   io_ptr = (png_FILE_p)CVT_PTR((png_ptr->io_ptr));
   if (io_ptr != NULL)
      fflush(io_ptr);
#endif
}
#endif

/* This is the function that does the actual writing of data.  If you are
   not writing to a standard C stream, you should create a replacement
   write_data function and use it at run time with png_set_write_fn(), rather
   than changing the library. */
#ifndef USE_FAR_KEYWORD
static void
pngtest_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
{
   png_uint_32 check;

   WRITEFILE((png_FILE_p)png_ptr->io_ptr,  data, length, check);
   if (check != length)
   {
      png_error(png_ptr, "Write Error");
   }
}
#else
/* this is the model-independent version. Since the standard I/O library
   can't handle far buffers in the medium and small models, we have to copy
   the data.
*/

#define NEAR_BUF_SIZE 1024
#define MIN(a,b) (a <= b ? a : b)

static void
pngtest_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
{
   png_uint_32 check;
   png_byte *near_data;  /* Needs to be "png_byte *" instead of "png_bytep" */
   png_FILE_p io_ptr;

   /* Check if data really is near. If so, use usual code. */
   near_data = (png_byte *)CVT_PTR_NOCHECK(data);
   io_ptr = (png_FILE_p)CVT_PTR(png_ptr->io_ptr);
   if ((png_bytep)near_data == data)
   {
      WRITEFILE(io_ptr, near_data, length, check);
   }
   else
   {
      png_byte buf[NEAR_BUF_SIZE];
      png_size_t written, remaining, err;
      check = 0;
      remaining = length;
      do
      {
         written = MIN(NEAR_BUF_SIZE, remaining);
         png_memcpy(buf, data, written); /* copy far buffer to near buffer */
         WRITEFILE(io_ptr, buf, written, err);
         if (err != written)
            break;
         else
            check += err;
         data += written;
         remaining -= written;
      }
      while (remaining != 0);
   }
   if (check != length)
   {
      png_error(png_ptr, "Write Error");
   }
}

#endif /* USE_FAR_KEYWORD */

/* This function is called when there is a warning, but the library thinks
 * it can continue anyway.  Replacement functions don't have to do anything
 * here if you don't want to.  In the default configuration, png_ptr is
 * not used, but it is passed in case it may be useful.
 */
static void
pngtest_warning(png_structp png_ptr, png_const_charp message)
{
   PNG_CONST char *name = "UNKNOWN (ERROR!)";
   if (png_ptr != NULL && png_ptr->error_ptr != NULL)
      name = png_ptr->error_ptr;
   fprintf(STDERR, "%s: libpng warning: %s\n", name, message);
}

/* This is the default error handling function.  Note that replacements for
 * this function MUST NOT RETURN, or the program will likely crash.  This
 * function is used by default, or if the program supplies NULL for the
 * error function pointer in png_set_error_fn().
 */
static void
pngtest_error(png_structp png_ptr, png_const_charp message)
{
   pngtest_warning(png_ptr, message);
   /* We can return because png_error calls the default handler, which is
    * actually OK in this case. */
}
#endif /* PNG_NO_STDIO */
/* END of code to validate stdio-free compilation */

/* START of code to validate memory allocation and deallocation */
#ifdef PNG_USER_MEM_SUPPORTED

/* Allocate memory.  For reasonable files, size should never exceed
   64K.  However, zlib may allocate more then 64K if you don't tell
   it not to.  See zconf.h and png.h for more information.  zlib does
   need to allocate exactly 64K, so whatever you call here must
   have the ability to do that.

   This piece of code can be compiled to validate max 64K allocations
   by setting MAXSEG_64K in zlib zconf.h *or* PNG_MAX_MALLOC_64K. */
typedef struct memory_information
{
   png_uint_32               size;
   png_voidp                 pointer;
   struct memory_information FAR *next;
} memory_information;
typedef memory_information FAR *memory_infop;

static memory_infop pinformation = NULL;
static int current_allocation = 0;
static int maximum_allocation = 0;
static int total_allocation = 0;
static int num_allocations = 0;

png_voidp png_debug_malloc PNGARG((png_structp png_ptr, png_uint_32 size));
void png_debug_free PNGARG((png_structp png_ptr, png_voidp ptr));

png_voidp
png_debug_malloc(png_structp png_ptr, png_uint_32 size)
{

   /* png_malloc has already tested for NULL; png_create_struct calls
      png_debug_malloc directly, with png_ptr == NULL which is OK */

   if (size == 0)
      return (NULL);

   /* This calls the library allocator twice, once to get the requested
      buffer and once to get a new free list entry. */
   {
      memory_infop pinfo = (memory_infop)png_malloc_default(png_ptr,
         (png_uint_32)sizeof *pinfo);
      pinfo->size = size;
      current_allocation += size;
      total_allocation += size;
      num_allocations ++;
      if (current_allocation > maximum_allocation)
         maximum_allocation = current_allocation;
      pinfo->pointer = (png_voidp)png_malloc_default(png_ptr, size);
      pinfo->next = pinformation;
      pinformation = pinfo;
      /* Make sure the caller isn't assuming zeroed memory. */
      png_memset(pinfo->pointer, 0xdd, pinfo->size);
#if PNG_DEBUG
      if(verbose)
         printf("png_malloc %lu bytes at %x\n",size,pinfo->pointer);
#endif
      assert(pinfo->size != 12345678);
      return (png_voidp)(pinfo->pointer);
   }
}

/* Free a pointer.  It is removed from the list at the same time. */
void
png_debug_free(png_structp png_ptr, png_voidp ptr)
{
   if (png_ptr == NULL)
      fprintf(STDERR, "NULL pointer to png_debug_free.\n");
   if (ptr == 0)
   {
#if 0 /* This happens all the time. */
      fprintf(STDERR, "WARNING: freeing NULL pointer\n");
#endif
      return;
   }

   /* Unlink the element from the list. */
   {
      memory_infop FAR *ppinfo = &pinformation;
      for (;;)
      {
         memory_infop pinfo = *ppinfo;
         if (pinfo->pointer == ptr)
         {
            *ppinfo = pinfo->next;
            current_allocation -= pinfo->size;
            if (current_allocation < 0)
               fprintf(STDERR, "Duplicate free of memory\n");
            /* We must free the list element too, but first kill
               the memory that is to be freed. */
            png_memset(ptr, 0x55, pinfo->size);
            png_free_default(png_ptr, pinfo);
            pinfo=NULL;
            break;
         }
         if (pinfo->next == NULL)
         {
            fprintf(STDERR, "Pointer %x not found\n", (unsigned int)ptr);
            break;
         }
         ppinfo = &pinfo->next;
      }
   }

   /* Finally free the data. */
#if PNG_DEBUG
   if(verbose)
      printf("Freeing %x\n",ptr);
#endif
   png_free_default(png_ptr, ptr);
   ptr=NULL;
}
#endif /* PNG_USER_MEM_SUPPORTED */
/* END of code to test memory allocation/deallocation */

/* Test one file */
int
test_one_file(PNG_CONST char *inname, PNG_CONST char *outname)
{
   static png_FILE_p fpin;
   static png_FILE_p fpout;  /* "static" prevents setjmp corruption */
   png_structp read_ptr;
   png_infop read_info_ptr, end_info_ptr;
#ifdef PNG_WRITE_SUPPORTED
   png_structp write_ptr;
   png_infop write_info_ptr;
   png_infop write_end_info_ptr;
#else
   png_structp write_ptr = NULL;
   png_infop write_info_ptr = NULL;
   png_infop write_end_info_ptr = NULL;
#endif
   png_bytep row_buf;
   png_uint_32 y;
   png_uint_32 width, height;
   int num_pass, pass;
   int bit_depth, color_type;
#ifdef PNG_SETJMP_SUPPORTED
#ifdef USE_FAR_KEYWORD
   jmp_buf jmpbuf;
#endif
#endif

#if defined(_WIN32_WCE)
   TCHAR path[MAX_PATH];
#endif
   char inbuf[256], outbuf[256];

   row_buf = NULL;

#if defined(_WIN32_WCE)
   MultiByteToWideChar(CP_ACP, 0, inname, -1, path, MAX_PATH);
   if ((fpin = CreateFile(path, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL)) == INVALID_HANDLE_VALUE)
#else
   if ((fpin = fopen(inname, "rb")) == NULL)
#endif
   {
      fprintf(STDERR, "Could not find input file %s\n", inname);
      return (1);
   }

#if defined(_WIN32_WCE)
   MultiByteToWideChar(CP_ACP, 0, outname, -1, path, MAX_PATH);
   if ((fpout = CreateFile(path, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL)) == INVALID_HANDLE_VALUE)
#else
   if ((fpout = fopen(outname, "wb")) == NULL)
#endif
   {
      fprintf(STDERR, "Could not open output file %s\n", outname);
      FCLOSE(fpin);
      return (1);
   }

   png_debug(0, "Allocating read and write structures\n");
#ifdef PNG_USER_MEM_SUPPORTED
   read_ptr = png_create_read_struct_2(PNG_LIBPNG_VER_STRING, png_voidp_NULL,
      png_error_ptr_NULL, png_error_ptr_NULL, png_voidp_NULL,
      (png_malloc_ptr)png_debug_malloc, (png_free_ptr)png_debug_free);
#else
   read_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, png_voidp_NULL,
      png_error_ptr_NULL, png_error_ptr_NULL);
#endif
#if defined(PNG_NO_STDIO)
   png_set_error_fn(read_ptr, (png_voidp)inname, pngtest_error,
       pngtest_warning);
#endif
#ifdef PNG_WRITE_SUPPORTED
#ifdef PNG_USER_MEM_SUPPORTED
   write_ptr = png_create_write_struct_2(PNG_LIBPNG_VER_STRING, png_voidp_NULL,
      png_error_ptr_NULL, png_error_ptr_NULL, png_voidp_NULL,
      (png_malloc_ptr)png_debug_malloc, (png_free_ptr)png_debug_free);
#else
   write_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, png_voidp_NULL,
      png_error_ptr_NULL, png_error_ptr_NULL);
#endif
#if defined(PNG_NO_STDIO)
   png_set_error_fn(write_ptr, (png_voidp)inname, pngtest_error,
       pngtest_warning);
#endif
#endif
   png_debug(0, "Allocating read_info, write_info and end_info structures\n");
   read_info_ptr = png_create_info_struct(read_ptr);
   end_info_ptr = png_create_info_struct(read_ptr);
#ifdef PNG_WRITE_SUPPORTED
   write_info_ptr = png_create_info_struct(write_ptr);
   write_end_info_ptr = png_create_info_struct(write_ptr);
#endif

#ifdef PNG_SETJMP_SUPPORTED
   png_debug(0, "Setting jmpbuf for read struct\n");
#ifdef USE_FAR_KEYWORD
   if (setjmp(jmpbuf))
#else
   if (setjmp(png_jmpbuf(read_ptr)))
#endif
   {
      fprintf(STDERR, "%s -> %s: libpng read error\n", inname, outname);
      if (row_buf)
         png_free(read_ptr, row_buf);
      png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);
#ifdef PNG_WRITE_SUPPORTED
      png_destroy_info_struct(write_ptr, &write_end_info_ptr);
      png_destroy_write_struct(&write_ptr, &write_info_ptr);
#endif
      FCLOSE(fpin);
      FCLOSE(fpout);
      return (1);
   }
#ifdef USE_FAR_KEYWORD
   png_memcpy(png_jmpbuf(read_ptr),jmpbuf,sizeof(jmp_buf));
#endif

#ifdef PNG_WRITE_SUPPORTED
   png_debug(0, "Setting jmpbuf for write struct\n");
#ifdef USE_FAR_KEYWORD
   if (setjmp(jmpbuf))
#else
   if (setjmp(png_jmpbuf(write_ptr)))
#endif
   {
      fprintf(STDERR, "%s -> %s: libpng write error\n", inname, outname);
      png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);
      png_destroy_info_struct(write_ptr, &write_end_info_ptr);
#ifdef PNG_WRITE_SUPPORTED
      png_destroy_write_struct(&write_ptr, &write_info_ptr);
#endif
      FCLOSE(fpin);
      FCLOSE(fpout);
      return (1);
   }
#ifdef USE_FAR_KEYWORD
   png_memcpy(png_jmpbuf(write_ptr),jmpbuf,sizeof(jmp_buf));
#endif
#endif
#endif

   png_debug(0, "Initializing input and output streams\n");
#if !defined(PNG_NO_STDIO)
   png_init_io(read_ptr, fpin);
#  ifdef PNG_WRITE_SUPPORTED
   png_init_io(write_ptr, fpout);
#  endif
#else
   png_set_read_fn(read_ptr, (png_voidp)fpin, pngtest_read_data);
#  ifdef PNG_WRITE_SUPPORTED
   png_set_write_fn(write_ptr, (png_voidp)fpout,  pngtest_write_data,
#    if defined(PNG_WRITE_FLUSH_SUPPORTED)
      pngtest_flush);
#    else
      NULL);
#    endif
#  endif
#endif
   if(status_dots_requested == 1)
   {
#ifdef PNG_WRITE_SUPPORTED
      png_set_write_status_fn(write_ptr, write_row_callback);
#endif
      png_set_read_status_fn(read_ptr, read_row_callback);
   }
   else
   {
#ifdef PNG_WRITE_SUPPORTED
      png_set_write_status_fn(write_ptr, png_write_status_ptr_NULL);
#endif
      png_set_read_status_fn(read_ptr, png_read_status_ptr_NULL);
   }

#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
   {
     int i;
     for(i=0; i<256; i++)
        filters_used[i]=0;
     png_set_read_user_transform_fn(read_ptr, count_filters);
   }
#endif
#if defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
   zero_samples=0;
   png_set_write_user_transform_fn(write_ptr, count_zero_samples);
#endif

#define HANDLE_CHUNK_IF_SAFE      2
#define HANDLE_CHUNK_ALWAYS       3
#if defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
   png_set_keep_unknown_chunks(read_ptr, HANDLE_CHUNK_ALWAYS,
      png_bytep_NULL, 0);
#endif
#if defined(PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED)
   png_set_keep_unknown_chunks(write_ptr, HANDLE_CHUNK_IF_SAFE,
      png_bytep_NULL, 0);
#endif

   png_debug(0, "Reading info struct\n");
   png_read_info(read_ptr, read_info_ptr);

   png_debug(0, "Transferring info struct\n");
   {
      int interlace_type, compression_type, filter_type;

      if (png_get_IHDR(read_ptr, read_info_ptr, &width, &height, &bit_depth,
          &color_type, &interlace_type, &compression_type, &filter_type))
      {
         png_set_IHDR(write_ptr, write_info_ptr, width, height, bit_depth,
#if defined(PNG_WRITE_INTERLACING_SUPPORTED)
            color_type, interlace_type, compression_type, filter_type);
#else
            color_type, PNG_INTERLACE_NONE, compression_type, filter_type);
#endif
      }
   }
#if defined(PNG_FIXED_POINT_SUPPORTED)
#if defined(PNG_cHRM_SUPPORTED)
   {
      png_fixed_point white_x, white_y, red_x, red_y, green_x, green_y, blue_x,
         blue_y;
      if (png_get_cHRM_fixed(read_ptr, read_info_ptr, &white_x, &white_y, &red_x,
         &red_y, &green_x, &green_y, &blue_x, &blue_y))
      {
         png_set_cHRM_fixed(write_ptr, write_info_ptr, white_x, white_y, red_x,
            red_y, green_x, green_y, blue_x, blue_y);
      }
   }
#endif
#if defined(PNG_gAMA_SUPPORTED)
   {
      png_fixed_point gamma;

      if (png_get_gAMA_fixed(read_ptr, read_info_ptr, &gamma))
      {
         png_set_gAMA_fixed(write_ptr, write_info_ptr, gamma);
      }
   }
#endif
#else /* Use floating point versions */
#if defined(PNG_FLOATING_POINT_SUPPORTED)
#if defined(PNG_cHRM_SUPPORTED)
   {
      double white_x, white_y, red_x, red_y, green_x, green_y, blue_x,
         blue_y;
      if (png_get_cHRM(read_ptr, read_info_ptr, &white_x, &white_y, &red_x,
         &red_y, &green_x, &green_y, &blue_x, &blue_y))
      {
         png_set_cHRM(write_ptr, write_info_ptr, white_x, white_y, red_x,
            red_y, green_x, green_y, blue_x, blue_y);
      }
   }
#endif
#if defined(PNG_gAMA_SUPPORTED)
   {
      double gamma;

      if (png_get_gAMA(read_ptr, read_info_ptr, &gamma))
      {
         png_set_gAMA(write_ptr, write_info_ptr, gamma);
      }
   }
#endif
#endif /* floating point */
#endif /* fixed point */
#if defined(PNG_iCCP_SUPPORTED)
   {
      png_charp name;
      png_charp profile;
      png_uint_32 proflen;
      int compression_type;

      if (png_get_iCCP(read_ptr, read_info_ptr, &name, &compression_type,
                      &profile, &proflen))
      {
         png_set_iCCP(write_ptr, write_info_ptr, name, compression_type,
                      profile, proflen);
      }
   }
#endif
#if defined(PNG_sRGB_SUPPORTED)
   {
      int intent;

      if (png_get_sRGB(read_ptr, read_info_ptr, &intent))
      {
         png_set_sRGB(write_ptr, write_info_ptr, intent);
      }
   }
#endif
   {
      png_colorp palette;
      int num_palette;

      if (png_get_PLTE(read_ptr, read_info_ptr, &palette, &num_palette))
      {
         png_set_PLTE(write_ptr, write_info_ptr, palette, num_palette);
      }
   }
#if defined(PNG_bKGD_SUPPORTED)
   {
      png_color_16p background;

      if (png_get_bKGD(read_ptr, read_info_ptr, &background))
      {
         png_set_bKGD(write_ptr, write_info_ptr, background);
      }
   }
#endif
#if defined(PNG_hIST_SUPPORTED)
   {
      png_uint_16p hist;

      if (png_get_hIST(read_ptr, read_info_ptr, &hist))
      {
         png_set_hIST(write_ptr, write_info_ptr, hist);
      }
   }
#endif
#if defined(PNG_oFFs_SUPPORTED)
   {
      png_int_32 offset_x, offset_y;
      int unit_type;

      if (png_get_oFFs(read_ptr, read_info_ptr,&offset_x,&offset_y,&unit_type))
      {
         png_set_oFFs(write_ptr, write_info_ptr, offset_x, offset_y, unit_type);
      }
   }
#endif
#if defined(PNG_pCAL_SUPPORTED)
   {
      png_charp purpose, units;
      png_charpp params;
      png_int_32 X0, X1;
      int type, nparams;

      if (png_get_pCAL(read_ptr, read_info_ptr, &purpose, &X0, &X1, &type,
         &nparams, &units, &params))
      {
         png_set_pCAL(write_ptr, write_info_ptr, purpose, X0, X1, type,
            nparams, units, params);
      }
   }
#endif
#if defined(PNG_pHYs_SUPPORTED)
   {
      png_uint_32 res_x, res_y;
      int unit_type;

      if (png_get_pHYs(read_ptr, read_info_ptr, &res_x, &res_y, &unit_type))
      {
         png_set_pHYs(write_ptr, write_info_ptr, res_x, res_y, unit_type);
      }
   }
#endif
#if defined(PNG_sBIT_SUPPORTED)
   {
      png_color_8p sig_bit;

      if (png_get_sBIT(read_ptr, read_info_ptr, &sig_bit))
      {
         png_set_sBIT(write_ptr, write_info_ptr, sig_bit);
      }
   }
#endif
#if defined(PNG_sCAL_SUPPORTED)
#ifdef PNG_FLOATING_POINT_SUPPORTED
   {
      int unit;
      double scal_width, scal_height;

      if (png_get_sCAL(read_ptr, read_info_ptr, &unit, &scal_width,
         &scal_height))
      {
         png_set_sCAL(write_ptr, write_info_ptr, unit, scal_width, scal_height);
      }
   }
#else
#ifdef PNG_FIXED_POINT_SUPPORTED
   {
      int unit;
      png_charp scal_width, scal_height;

      if (png_get_sCAL_s(read_ptr, read_info_ptr, &unit, &scal_width,
          &scal_height))
      {
         png_set_sCAL_s(write_ptr, write_info_ptr, unit, scal_width, scal_height);
      }
   }
#endif
#endif
#endif
#if defined(PNG_TEXT_SUPPORTED)
   {
      png_textp text_ptr;
      int num_text;

      if (png_get_text(read_ptr, read_info_ptr, &text_ptr, &num_text) > 0)
      {
         png_debug1(0, "Handling %d iTXt/tEXt/zTXt chunks\n", num_text);
         png_set_text(write_ptr, write_info_ptr, text_ptr, num_text);
      }
   }
#endif
#if defined(PNG_tIME_SUPPORTED)
   {
      png_timep mod_time;

      if (png_get_tIME(read_ptr, read_info_ptr, &mod_time))
      {
         png_set_tIME(write_ptr, write_info_ptr, mod_time);
#if defined(PNG_TIME_RFC1123_SUPPORTED)
         /* we have to use png_strcpy instead of "=" because the string
            pointed to by png_convert_to_rfc1123() gets free'ed before
            we use it */
         png_strcpy(tIME_string,png_convert_to_rfc1123(read_ptr, mod_time));
         tIME_chunk_present++;
#endif /* PNG_TIME_RFC1123_SUPPORTED */
      }
   }
#endif
#if defined(PNG_tRNS_SUPPORTED)
   {
      png_bytep trans;
      int num_trans;
      png_color_16p trans_values;

      if (png_get_tRNS(read_ptr, read_info_ptr, &trans, &num_trans,
         &trans_values))
      {
         png_set_tRNS(write_ptr, write_info_ptr, trans, num_trans,
            trans_values);
      }
   }
#endif
#if defined(PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED)
   {
      png_unknown_chunkp unknowns;
      int num_unknowns = (int)png_get_unknown_chunks(read_ptr, read_info_ptr,
         &unknowns);
      if (num_unknowns)
      {
         png_size_t i;
         png_set_unknown_chunks(write_ptr, write_info_ptr, unknowns,
           num_unknowns);
         /* copy the locations from the read_info_ptr.  The automatically
            generated locations in write_info_ptr are wrong because we
            haven't written anything yet */
         for (i = 0; i < (png_size_t)num_unknowns; i++)
           png_set_unknown_chunk_location(write_ptr, write_info_ptr, i,
             unknowns[i].location);
      }
   }
#endif

#ifdef PNG_WRITE_SUPPORTED
   png_debug(0, "\nWriting info struct\n");

/* If we wanted, we could write info in two steps:
   png_write_info_before_PLTE(write_ptr, write_info_ptr);
 */
   png_write_info(write_ptr, write_info_ptr);
#endif

#ifdef SINGLE_ROWBUF_ALLOC
   png_debug(0, "\nAllocating row buffer...");
   row_buf = (png_bytep)png_malloc(read_ptr,
      png_get_rowbytes(read_ptr, read_info_ptr));
   png_debug1(0, "0x%08lx\n\n", (unsigned long)row_buf);
#endif /* SINGLE_ROWBUF_ALLOC */
   png_debug(0, "Writing row data\n");

#if defined(PNG_READ_INTERLACING_SUPPORTED) || \
  defined(PNG_WRITE_INTERLACING_SUPPORTED)
   num_pass = png_set_interlace_handling(read_ptr);
#  ifdef PNG_WRITE_SUPPORTED
   png_set_interlace_handling(write_ptr);
#  endif
#else
   num_pass=1;
#endif

#ifdef PNGTEST_TIMING
   t_stop = (float)clock();
   t_misc += (t_stop - t_start);
   t_start = t_stop;
#endif
   for (pass = 0; pass < num_pass; pass++)
   {
      png_debug1(0, "Writing row data for pass %d\n",pass);
      for (y = 0; y < height; y++)
      {
#ifndef SINGLE_ROWBUF_ALLOC
         png_debug2(0, "\nAllocating row buffer (pass %d, y = %ld)...", pass,y);
         row_buf = (png_bytep)png_malloc(read_ptr,
            png_get_rowbytes(read_ptr, read_info_ptr));
         png_debug2(0, "0x%08lx (%ld bytes)\n", (unsigned long)row_buf,
            png_get_rowbytes(read_ptr, read_info_ptr));
#endif /* !SINGLE_ROWBUF_ALLOC */
         png_read_rows(read_ptr, (png_bytepp)&row_buf, png_bytepp_NULL, 1);

#ifdef PNG_WRITE_SUPPORTED
#ifdef PNGTEST_TIMING
         t_stop = (float)clock();
         t_decode += (t_stop - t_start);
         t_start = t_stop;
#endif
         png_write_rows(write_ptr, (png_bytepp)&row_buf, 1);
#ifdef PNGTEST_TIMING
         t_stop = (float)clock();
         t_encode += (t_stop - t_start);
         t_start = t_stop;
#endif
#endif /* PNG_WRITE_SUPPORTED */

#ifndef SINGLE_ROWBUF_ALLOC
         png_debug2(0, "Freeing row buffer (pass %d, y = %ld)\n\n", pass, y);
         png_free(read_ptr, row_buf);
#endif /* !SINGLE_ROWBUF_ALLOC */
      }
   }

#if defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
   png_free_data(read_ptr, read_info_ptr, PNG_FREE_UNKN, -1);
#endif
#if defined(PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED)
   png_free_data(write_ptr, write_info_ptr, PNG_FREE_UNKN, -1);
#endif

   png_debug(0, "Reading and writing end_info data\n");

   png_read_end(read_ptr, end_info_ptr);
#if defined(PNG_TEXT_SUPPORTED)
   {
      png_textp text_ptr;
      int num_text;

      if (png_get_text(read_ptr, end_info_ptr, &text_ptr, &num_text) > 0)
      {
         png_debug1(0, "Handling %d iTXt/tEXt/zTXt chunks\n", num_text);
         png_set_text(write_ptr, write_end_info_ptr, text_ptr, num_text);
      }
   }
#endif
#if defined(PNG_tIME_SUPPORTED)
   {
      png_timep mod_time;

      if (png_get_tIME(read_ptr, end_info_ptr, &mod_time))
      {
         png_set_tIME(write_ptr, write_end_info_ptr, mod_time);
#if defined(PNG_TIME_RFC1123_SUPPORTED)
         /* we have to use png_strcpy instead of "=" because the string
            pointed to by png_convert_to_rfc1123() gets free'ed before
            we use it */
         png_strcpy(tIME_string,png_convert_to_rfc1123(read_ptr, mod_time));
         tIME_chunk_present++;
#endif /* PNG_TIME_RFC1123_SUPPORTED */
      }
   }
#endif
#if defined(PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED)
   {
      png_unknown_chunkp unknowns;
      int num_unknowns;
      num_unknowns = (int)png_get_unknown_chunks(read_ptr, end_info_ptr,
         &unknowns);
      if (num_unknowns)
      {
         png_size_t i;
         png_set_unknown_chunks(write_ptr, write_end_info_ptr, unknowns,
           num_unknowns);
         /* copy the locations from the read_info_ptr.  The automatically
            generated locations in write_end_info_ptr are wrong because we
            haven't written the end_info yet */
         for (i = 0; i < (png_size_t)num_unknowns; i++)
           png_set_unknown_chunk_location(write_ptr, write_end_info_ptr, i,
             unknowns[i].location);
      }
   }
#endif
#ifdef PNG_WRITE_SUPPORTED
   png_write_end(write_ptr, write_end_info_ptr);
#endif

#ifdef PNG_EASY_ACCESS_SUPPORTED
   if(verbose)
   {
      png_uint_32 iwidth, iheight;
      iwidth = png_get_image_width(write_ptr, write_info_ptr);
      iheight = png_get_image_height(write_ptr, write_info_ptr);
      fprintf(STDERR, "Image width = %lu, height = %lu\n",
         iwidth, iheight);
   }
#endif

   png_debug(0, "Destroying data structs\n");
#ifdef SINGLE_ROWBUF_ALLOC
   png_debug(1, "destroying row_buf for read_ptr\n");
   png_free(read_ptr, row_buf);
   row_buf=NULL;
#endif /* SINGLE_ROWBUF_ALLOC */
   png_debug(1, "destroying read_ptr, read_info_ptr, end_info_ptr\n");
   png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);
#ifdef PNG_WRITE_SUPPORTED
   png_debug(1, "destroying write_end_info_ptr\n");
   png_destroy_info_struct(write_ptr, &write_end_info_ptr);
   png_debug(1, "destroying write_ptr, write_info_ptr\n");
   png_destroy_write_struct(&write_ptr, &write_info_ptr);
#endif
   png_debug(0, "Destruction complete.\n");

   FCLOSE(fpin);
   FCLOSE(fpout);

   png_debug(0, "Opening files for comparison\n");
#if defined(_WIN32_WCE)
   MultiByteToWideChar(CP_ACP, 0, inname, -1, path, MAX_PATH);
   if ((fpin = CreateFile(path, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL)) == INVALID_HANDLE_VALUE)
#else
   if ((fpin = fopen(inname, "rb")) == NULL)
#endif
   {
      fprintf(STDERR, "Could not find file %s\n", inname);
      return (1);
   }

#if defined(_WIN32_WCE)
   MultiByteToWideChar(CP_ACP, 0, outname, -1, path, MAX_PATH);
   if ((fpout = CreateFile(path, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL)) == INVALID_HANDLE_VALUE)
#else
   if ((fpout = fopen(outname, "rb")) == NULL)
#endif
   {
      fprintf(STDERR, "Could not find file %s\n", outname);
      FCLOSE(fpin);
      return (1);
   }

   for(;;)
   {
      png_size_t num_in, num_out;

      READFILE(fpin, inbuf, 1, num_in);
      READFILE(fpout, outbuf, 1, num_out);

      if (num_in != num_out)
      {
         fprintf(STDERR, "\nFiles %s and %s are of a different size\n",
                 inname, outname);
         if(wrote_question == 0)
         {
            fprintf(STDERR,
         "   Was %s written with the same maximum IDAT chunk size (%d bytes),",
              inname,PNG_ZBUF_SIZE);
            fprintf(STDERR,
              "\n   filtering heuristic (libpng default), compression");
            fprintf(STDERR,
              " level (zlib default),\n   and zlib version (%s)?\n\n",
              ZLIB_VERSION);
            wrote_question=1;
         }
         FCLOSE(fpin);
         FCLOSE(fpout);
         return (0);
      }

      if (!num_in)
         break;

      if (png_memcmp(inbuf, outbuf, num_in))
      {
         fprintf(STDERR, "\nFiles %s and %s are different\n", inname, outname);
         if(wrote_question == 0)
         {
            fprintf(STDERR,
         "   Was %s written with the same maximum IDAT chunk size (%d bytes),",
                 inname,PNG_ZBUF_SIZE);
            fprintf(STDERR,
              "\n   filtering heuristic (libpng default), compression");
            fprintf(STDERR,
              " level (zlib default),\n   and zlib version (%s)?\n\n",
              ZLIB_VERSION);
            wrote_question=1;
         }
         FCLOSE(fpin);
         FCLOSE(fpout);
         return (0);
      }
   }

   FCLOSE(fpin);
   FCLOSE(fpout);

   return (0);
}

/* input and output filenames */
#ifdef RISCOS
static PNG_CONST char *inname = "pngtest/png";
static PNG_CONST char *outname = "pngout/png";
#else
static PNG_CONST char *inname = "pngtest.png";
static PNG_CONST char *outname = "pngout.png";
#endif

int
main(int argc, char *argv[])
{
   int multiple = 0;
   int ierror = 0;

   fprintf(STDERR, "Testing libpng version %s\n", PNG_LIBPNG_VER_STRING);
   fprintf(STDERR, "   with zlib   version %s\n", ZLIB_VERSION);
   fprintf(STDERR,"%s",png_get_copyright(NULL));
   /* Show the version of libpng used in building the library */
   fprintf(STDERR," library (%lu):%s", png_access_version_number(),
      png_get_header_version(NULL));
   /* Show the version of libpng used in building the application */
   fprintf(STDERR," pngtest (%lu):%s", (unsigned long)PNG_LIBPNG_VER,
      PNG_HEADER_VERSION_STRING);
   fprintf(STDERR," sizeof(png_struct)=%ld, sizeof(png_info)=%ld\n",
                    (long)sizeof(png_struct), (long)sizeof(png_info));

   /* Do some consistency checking on the memory allocation settings, I'm
      not sure this matters, but it is nice to know, the first of these
      tests should be impossible because of the way the macros are set
      in pngconf.h */
#if defined(MAXSEG_64K) && !defined(PNG_MAX_MALLOC_64K)
      fprintf(STDERR, " NOTE: Zlib compiled for max 64k, libpng not\n");
#endif
   /* I think the following can happen. */
#if !defined(MAXSEG_64K) && defined(PNG_MAX_MALLOC_64K)
      fprintf(STDERR, " NOTE: libpng compiled for max 64k, zlib not\n");
#endif

   if (strcmp(png_libpng_ver, PNG_LIBPNG_VER_STRING))
   {
      fprintf(STDERR,
         "Warning: versions are different between png.h and png.c\n");
      fprintf(STDERR, "  png.h version: %s\n", PNG_LIBPNG_VER_STRING);
      fprintf(STDERR, "  png.c version: %s\n\n", png_libpng_ver);
      ++ierror;
   }

   if (argc > 1)
   {
      if (strcmp(argv[1], "-m") == 0)
      {
         multiple = 1;
         status_dots_requested = 0;
      }
      else if (strcmp(argv[1], "-mv") == 0 ||
               strcmp(argv[1], "-vm") == 0 )
      {
         multiple = 1;
         verbose = 1;
         status_dots_requested = 1;
      }
      else if (strcmp(argv[1], "-v") == 0)
      {
         verbose = 1;
         status_dots_requested = 1;
         inname = argv[2];
      }
      else
      {
         inname = argv[1];
         status_dots_requested = 0;
      }
   }

   if (!multiple && argc == 3+verbose)
     outname = argv[2+verbose];

   if ((!multiple && argc > 3+verbose) || (multiple && argc < 2))
   {
     fprintf(STDERR,
       "usage: %s [infile.png] [outfile.png]\n\t%s -m {infile.png}\n",
        argv[0], argv[0]);
     fprintf(STDERR,
       "  reads/writes one PNG file (without -m) or multiple files (-m)\n");
     fprintf(STDERR,
       "  with -m %s is used as a temporary file\n", outname);
     exit(1);
   }

   if (multiple)
   {
      int i;
#ifdef PNG_USER_MEM_SUPPORTED
      int allocation_now = current_allocation;
#endif
      for (i=2; i<argc; ++i)
      {
#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
         int k;
#endif
         int kerror;
         fprintf(STDERR, "Testing %s:",argv[i]);
         kerror = test_one_file(argv[i], outname);
         if (kerror == 0)
         {
#if defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
            fprintf(STDERR, "\n PASS (%lu zero samples)\n",zero_samples);
#else
            fprintf(STDERR, " PASS\n");
#endif
#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
            for (k=0; k<256; k++)
               if(filters_used[k])
                  fprintf(STDERR, " Filter %d was used %lu times\n",
                     k,filters_used[k]);
#endif
#if defined(PNG_TIME_RFC1123_SUPPORTED)
         if(tIME_chunk_present != 0)
            fprintf(STDERR, " tIME = %s\n",tIME_string);
         tIME_chunk_present = 0;
#endif /* PNG_TIME_RFC1123_SUPPORTED */
         }
         else
         {
            fprintf(STDERR, " FAIL\n");
            ierror += kerror;
         }
#ifdef PNG_USER_MEM_SUPPORTED
         if (allocation_now != current_allocation)
            fprintf(STDERR, "MEMORY ERROR: %d bytes lost\n",
               current_allocation-allocation_now);
         if (current_allocation != 0)
         {
            memory_infop pinfo = pinformation;

            fprintf(STDERR, "MEMORY ERROR: %d bytes still allocated\n",
               current_allocation);
            while (pinfo != NULL)
            {
               fprintf(STDERR, " %lu bytes at %x\n", pinfo->size, 
                 (unsigned int) pinfo->pointer);
               pinfo = pinfo->next;
            }
         }
#endif
      }
#ifdef PNG_USER_MEM_SUPPORTED
         fprintf(STDERR, " Current memory allocation: %10d bytes\n",
            current_allocation);
         fprintf(STDERR, " Maximum memory allocation: %10d bytes\n",
            maximum_allocation);
         fprintf(STDERR, " Total   memory allocation: %10d bytes\n",
            total_allocation);
         fprintf(STDERR, "     Number of allocations: %10d\n",
            num_allocations);
#endif
   }
   else
   {
      int i;
      for (i=0; i<3; ++i)
      {
         int kerror;
#ifdef PNG_USER_MEM_SUPPORTED
         int allocation_now = current_allocation;
#endif
         if (i == 1) status_dots_requested = 1;
         else if(verbose == 0)status_dots_requested = 0;
         if (i == 0 || verbose == 1 || ierror != 0)
            fprintf(STDERR, "Testing %s:",inname);
         kerror = test_one_file(inname, outname);
         if(kerror == 0)
         {
            if(verbose == 1 || i == 2)
            {
#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
                int k;
#endif
#if defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
                fprintf(STDERR, "\n PASS (%lu zero samples)\n",zero_samples);
#else
                fprintf(STDERR, " PASS\n");
#endif
#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
                for (k=0; k<256; k++)
                   if(filters_used[k])
                      fprintf(STDERR, " Filter %d was used %lu times\n",
                         k,filters_used[k]);
#endif
#if defined(PNG_TIME_RFC1123_SUPPORTED)
             if(tIME_chunk_present != 0)
                fprintf(STDERR, " tIME = %s\n",tIME_string);
#endif /* PNG_TIME_RFC1123_SUPPORTED */
            }
         }
         else
         {
            if(verbose == 0 && i != 2)
               fprintf(STDERR, "Testing %s:",inname);
            fprintf(STDERR, " FAIL\n");
            ierror += kerror;
         }
#ifdef PNG_USER_MEM_SUPPORTED
         if (allocation_now != current_allocation)
             fprintf(STDERR, "MEMORY ERROR: %d bytes lost\n",
               current_allocation-allocation_now);
         if (current_allocation != 0)
         {
             memory_infop pinfo = pinformation;

             fprintf(STDERR, "MEMORY ERROR: %d bytes still allocated\n",
                current_allocation);
             while (pinfo != NULL)
             {
                fprintf(STDERR," %lu bytes at %x\n",
                   pinfo->size, (unsigned int)pinfo->pointer);
                pinfo = pinfo->next;
             }
          }
#endif
       }
#ifdef PNG_USER_MEM_SUPPORTED
       fprintf(STDERR, " Current memory allocation: %10d bytes\n",
          current_allocation);
       fprintf(STDERR, " Maximum memory allocation: %10d bytes\n",
          maximum_allocation);
       fprintf(STDERR, " Total   memory allocation: %10d bytes\n",
          total_allocation);
       fprintf(STDERR, "     Number of allocations: %10d\n",
            num_allocations);
#endif
   }

#ifdef PNGTEST_TIMING
   t_stop = (float)clock();
   t_misc += (t_stop - t_start);
   t_start = t_stop;
   fprintf(STDERR," CPU time used = %.3f seconds",
      (t_misc+t_decode+t_encode)/(float)CLOCKS_PER_SEC);
   fprintf(STDERR," (decoding %.3f,\n",
      t_decode/(float)CLOCKS_PER_SEC);
   fprintf(STDERR,"        encoding %.3f ,",
      t_encode/(float)CLOCKS_PER_SEC);
   fprintf(STDERR," other %.3f seconds)\n\n",
      t_misc/(float)CLOCKS_PER_SEC);
#endif

   if (ierror == 0)
      fprintf(STDERR, "libpng passes test\n");
   else
      fprintf(STDERR, "libpng FAILS test\n");
   return (int)(ierror != 0);
}

/* Generate a compiler error if there is an old png.h in the search path. */
typedef version_1_2_5 your_png_h_is_not_version_1_2_5;
@


1.3
log
@Update to libpng 1.2.5
@
text
@@


1.2
log
@CONST to const
@
text
@d4 1
a4 1
 * libpng 1.0.2 -June 14, 1998
d6 3
a8 3
 * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
 * Copyright (c) 1996, 1997 Andreas Dilger
 * Copyright (c) 1998, Glenn Randers-Pehrson
d18 3
a20 2
 * 2) when the chunk size is not 8K.
 * 3) unknown ancillary chunks exist in the input file.
d23 1
a23 1
 * to see what the differences between the two images are.
d31 29
a59 2
#include <stdio.h>
#include <stdlib.h>
d63 18
a80 1
#define PNG_DEBUG 0
d85 12
d100 3
a102 1
#endif /* PNG_TIME_RFC1123_SUPPORTED */
d104 1
a104 1
int test_one_file PNGARG((PNG_const char *inname, PNG_const char *outname));
d120 8
d130 1
a130 1
    if(png_ptr == NULL || row_number > 0x3fffffffL) return;
d135 1
a135 1
       status_dots = 30;
d147 8
d157 1
a157 1
    if(png_ptr == NULL || row_number > 0x3fffffffL || pass > 7) return;
d162 21
d190 8
d201 1
a201 1
   if(png_ptr == NULL)return; 
d212 1
d223 1
a223 1
             if(((*dp << pos++ )& 0x80) == 0) zero_samples++;
d232 1
a232 1
             if(((*dp << (pos+=2))& 0xc0) == 0) zero_samples++;
d241 1
a241 1
             if(((*dp << (pos+=4))& 0xf0) == 0) zero_samples++;
a285 1
static int verbose = 0;
d296 1
d299 1
a299 1
png_default_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
d306 1
a306 2
   check = (png_size_t)fread(data, (png_size_t)1, length,
      (FILE *)png_ptr->io_ptr);
d310 1
a310 1
      png_error(png_ptr, "Read Error");
d318 1
a318 1
 
d321 1
a321 1
 
d323 1
a323 1
png_default_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
d327 1
a327 1
   FILE *io_ptr;
d331 1
a331 1
   io_ptr = (FILE *)CVT_PTR(png_ptr->io_ptr);
d334 1
a334 1
      check = fread(n_data, 1, length, io_ptr);
d345 1
a345 1
         err = fread(buf, (png_size_t)1, read, io_ptr);
d365 1
a365 1
png_default_flush(png_structp png_ptr)
d367 3
a369 2
   FILE *io_ptr;
   io_ptr = (FILE *)CVT_PTR((png_ptr->io_ptr));
d372 1
d382 1
a382 1
png_default_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
d386 1
a386 1
   check = fwrite(data, 1, length, (FILE *)(png_ptr->io_ptr));
d402 1
a402 1
png_default_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
d406 1
a406 1
   FILE *io_ptr;
d410 1
a410 1
   io_ptr = (FILE *)CVT_PTR(png_ptr->io_ptr);
d413 1
a413 1
      check = fwrite(near_data, 1, length, io_ptr);
d425 1
a425 1
         err = fwrite(buf, 1, written, io_ptr);
d449 1
a449 1
png_default_warning(png_structp png_ptr, png_const_charp message)
d451 1
a451 1
   PNG_const char *name = "UNKNOWN (ERROR!)";
d463 1
a463 1
png_default_error(png_structp png_ptr, png_const_charp message)
d465 1
a465 1
   png_default_warning(png_ptr, message);
d483 3
a485 2
typedef struct memory_information {
   png_uint_32                    size;
d494 2
d497 2
a498 4
extern PNG_EXPORT(png_voidp,png_debug_malloc) PNGARG((png_structp png_ptr,
   png_uint_32 size));
extern PNG_EXPORT(void,png_debug_free) PNGARG((png_structp png_ptr,
   png_voidp ptr));
d501 2
a502 1
png_debug_malloc(png_structp png_ptr, png_uint_32 size) {
d508 1
a508 1
      return (png_voidp)(NULL);
d513 2
a514 1
      memory_infop pinfo = png_malloc_default(png_ptr, sizeof *pinfo);
d517 2
d521 1
a521 1
      pinfo->pointer = png_malloc_default(png_ptr, size);
d526 5
d541 2
a542 1
   if (ptr == 0) {
d552 2
a553 1
      for (;;) {
d555 2
a556 1
         if (pinfo->pointer == ptr) {
d563 1
a563 1
            memset(ptr, 0x55, pinfo->size);
d565 1
d568 3
a570 2
         if (pinfo->next == NULL) {
            fprintf(STDERR, "Pointer %x not found\n", ptr);
d578 4
d583 1
d590 1
a590 1
test_one_file(PNG_const char *inname, PNG_const char *outname)
d592 13
a604 3
   static FILE *fpin, *fpout;  /* "static" prevents setjmp corruption */
   png_structp read_ptr, write_ptr;
   png_infop read_info_ptr, write_info_ptr, end_info_ptr;
d610 1
d613 6
a618 2
#endif   
   
d621 1
a621 1
   row_buf = (png_bytep)NULL;
d623 4
d628 1
d634 4
d639 1
d642 1
a642 1
      fclose(fpin);
d648 2
a649 2
   read_ptr = png_create_read_struct_2(PNG_LIBPNG_VER_STRING, (png_voidp)NULL,
      (png_error_ptr)NULL, (png_error_ptr)NULL, (png_voidp)NULL,
d652 2
a653 2
   read_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, (png_voidp)NULL,
      (png_error_ptr)NULL, (png_error_ptr)NULL);
d656 2
a657 2
   png_set_error_fn(read_ptr, (png_voidp)inname, png_default_error,
       png_default_warning);
d659 1
d661 2
a662 2
   write_ptr = png_create_write_struct_2(PNG_LIBPNG_VER_STRING, (png_voidp)NULL,
      (png_error_ptr)NULL, (png_error_ptr)NULL, (png_voidp)NULL,
d665 2
a666 2
   write_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, (png_voidp)NULL,
      (png_error_ptr)NULL, (png_error_ptr)NULL);
d669 3
a671 2
   png_set_error_fn(write_ptr, (png_voidp)inname, png_default_error,
       png_default_warning);
d675 2
d678 1
a678 2
   end_info_ptr = png_create_info_struct(read_ptr);
#ifdef PNG_USER_MEM_SUPPORTED
d681 1
d686 1
a686 1
   if (setjmp(read_ptr->jmpbuf))
d690 2
d693 2
d696 3
a698 2
      fclose(fpin);
      fclose(fpout);
d701 3
d705 1
a707 1
   png_memcpy(read_ptr->jmpbuf,jmpbuf,sizeof(jmp_buf));
d710 1
a710 1
   if (setjmp(write_ptr->jmpbuf))
d715 2
d718 3
a720 2
      fclose(fpin);
      fclose(fpout);
a722 1

d724 3
a726 1
   png_memcpy(write_ptr->jmpbuf,jmpbuf,sizeof(jmp_buf));
d728 1
d732 1
d734 1
d736 6
a741 5
   png_set_read_fn(read_ptr, (png_voidp)fpin, png_default_read_data);
   png_set_write_fn(write_ptr, (png_voidp)fpout,  png_default_write_data,
#if defined(PNG_WRITE_FLUSH_SUPPORTED)
      png_default_flush);
#else
d743 2
a744 1
#endif
d748 1
d750 1
d755 12
a766 2
      png_set_write_status_fn(write_ptr, NULL);
      png_set_read_status_fn(read_ptr, NULL);
d768 5
d774 10
a783 4
#  if defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
     zero_samples=0;
     png_set_write_user_transform_fn(write_ptr, count_zero_samples);
#  endif
d803 14
a816 1
#if defined(PNG_READ_bKGD_SUPPORTED) && defined(PNG_WRITE_bKGD_SUPPORTED)
d818 1
a818 1
      png_color_16p background;
d820 1
a820 1
      if (png_get_bKGD(read_ptr, read_info_ptr, &background))
d822 1
a822 1
         png_set_bKGD(write_ptr, write_info_ptr, background);
d826 3
a828 1
#if defined(PNG_READ_cHRM_SUPPORTED) && defined(PNG_WRITE_cHRM_SUPPORTED)
d830 2
a831 2
      double white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y;

d840 1
a840 1
#if defined(PNG_READ_gAMA_SUPPORTED) && defined(PNG_WRITE_gAMA_SUPPORTED)
d850 18
a867 1
#if defined(PNG_READ_sRGB_SUPPORTED) && defined(PNG_WRITE_sRGB_SUPPORTED)
d877 20
a896 1
#if defined(PNG_READ_hIST_SUPPORTED) && defined(PNG_WRITE_hIST_SUPPORTED)
d906 1
a906 1
#if defined(PNG_READ_oFFs_SUPPORTED) && defined(PNG_WRITE_oFFs_SUPPORTED)
d908 1
a908 1
      png_uint_32 offset_x, offset_y;
d917 1
a917 1
#if defined(PNG_READ_pCAL_SUPPORTED) && defined(PNG_WRITE_pCAL_SUPPORTED)
d932 1
a932 1
#if defined(PNG_READ_pHYs_SUPPORTED) && defined(PNG_WRITE_pHYs_SUPPORTED)
d943 12
d956 2
a957 2
      png_colorp palette;
      int num_palette;
d959 2
a960 1
      if (png_get_PLTE(read_ptr, read_info_ptr, &palette, &num_palette))
d962 1
a962 1
         png_set_PLTE(write_ptr, write_info_ptr, palette, num_palette);
d965 2
a966 1
#if defined(PNG_READ_sBIT_SUPPORTED) && defined(PNG_WRITE_sBIT_SUPPORTED)
d968 2
a969 1
      png_color_8p sig_bit;
d971 2
a972 1
      if (png_get_sBIT(read_ptr, read_info_ptr, &sig_bit))
d974 1
a974 1
         png_set_sBIT(write_ptr, write_info_ptr, sig_bit);
d978 3
a980 2
#if (defined(PNG_READ_tEXt_SUPPORTED) && defined(PNG_WRITE_tEXt_SUPPORTED)) || \
    (defined(PNG_READ_zTXt_SUPPORTED) && defined(PNG_WRITE_zTXt_SUPPORTED))
d987 1
a987 1
         png_debug1(0, "Handling %d tEXt/zTXt chunks\n", num_text);
d992 1
a992 1
#if defined(PNG_READ_tIME_SUPPORTED) && defined(PNG_WRITE_tIME_SUPPORTED)
a998 1
      }
a999 1
      {
d1005 1
a1006 1
#endif /* PNG_TIME_RFC1123_SUPPORTED */
d1009 1
a1009 1
#if defined(PNG_READ_tRNS_SUPPORTED) && defined(PNG_WRITE_tRNS_SUPPORTED)
d1023 19
d1043 1
d1045 4
d1050 1
d1052 3
a1054 2
   png_debug(0, "\nAllocating row buffer \n");
   row_buf = (png_bytep)png_malloc(read_ptr, 
d1056 2
a1057 9
   if (row_buf == NULL)
   {
      fprintf(STDERR, "No memory to allocate row buffer\n");
      png_destroy_read_struct(&read_ptr, &read_info_ptr, (png_infopp)NULL);
      png_destroy_write_struct(&write_ptr, &write_info_ptr);
      fclose(fpin);
      fclose(fpout);
      return (1);
   }
d1060 2
d1063 1
d1065 4
d1070 5
d1080 15
a1094 1
         png_read_rows(read_ptr, (png_bytepp)&row_buf, (png_bytepp)NULL, 1);
d1096 11
d1110 7
d1118 1
d1120 53
a1172 2
   png_write_end(write_ptr, end_info_ptr);
 
d1185 2
d1188 3
d1192 4
d1197 2
d1200 2
a1201 2
   fclose(fpin);
   fclose(fpout);
d1204 4
d1209 1
d1215 4
d1220 1
d1223 1
a1223 1
      fclose(fpin);
d1231 2
a1232 2
      num_in = fread(inbuf, 1, 1, fpin);
      num_out = fread(outbuf, 1, 1, fpout);
d1236 1
a1236 1
         fprintf(STDERR, "Files %s and %s are of a different size\n",
d1241 2
a1242 1
              "   Was %s written with the same chunk size (8k),",inname);
d1244 1
a1244 1
              " filtering\n   heuristic (libpng default), compression");
d1246 1
a1246 1
              " level (zlib default)\n   and zlib version (%s)?\n\n",
d1250 2
a1251 2
         fclose(fpin);
         fclose(fpout);
d1260 1
a1260 1
         fprintf(STDERR, "Files %s and %s are different\n", inname, outname);
d1264 2
a1265 1
              "   Was %s written with the same chunk size (8k),",inname);
d1267 1
a1267 1
              " filtering\n   heuristic (libpng default), compression");
d1269 1
a1269 1
              " level (zlib default)\n   and zlib version (%s)?\n\n",
d1273 2
a1274 2
         fclose(fpin);
         fclose(fpout);
d1279 2
a1280 2
   fclose(fpin);
   fclose(fpout);
d1287 2
a1288 2
PNG_const char *inname = "pngtest/png";
PNG_const char *outname = "pngout/png";
d1290 2
a1291 2
static PNG_const char *inname = "pngtest.png";
static PNG_const char *outname = "pngout.png";
d1302 9
d1383 3
d1389 1
a1389 1
         if (kerror == 0) 
d1392 1
a1392 1
            fprintf(STDERR, " PASS (%lu zero samples)\n",zero_samples);
d1395 7
a1401 1
#endif 
d1417 2
a1418 1
         if (current_allocation != 0) {
d1423 4
a1426 2
            while (pinfo != NULL) {
               fprintf(STDERR, " %d bytes at %x\n", pinfo->size, pinfo->pointer);
d1428 1
a1428 1
               }
d1433 3
a1435 1
         fprintf(STDERR, "Maximum memory allocation: %d bytes\n",
d1437 4
d1446 2
a1447 1
      for (i=0; i<3; ++i) {
d1461 3
d1465 1
a1465 1
                fprintf(STDERR, " PASS (%lu zero samples)\n",zero_samples);
d1469 6
d1476 2
a1477 2
         if(tIME_chunk_present != 0)
            fprintf(STDERR, " tIME = %s\n",tIME_string);
d1492 2
a1493 1
         if (current_allocation != 0) {
d1495 1
a1495 1
   
d1498 4
a1501 2
             while (pinfo != NULL) {
                fprintf(STDERR, " %d bytes at %x\n", pinfo->size, pinfo->pointer);
d1508 3
a1510 1
       fprintf(STDERR, "Maximum memory allocation: %d bytes\n",
d1512 4
d1519 14
d1540 2
@


1.2.4.1
log
@sync branch with HEAD
@
text
@d4 1
a4 1
 * libpng 1.2.5 - October 3, 2002
d6 3
a8 3
 * Copyright (c) 1998-2002 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
d18 2
a19 3
 * 2) when the maximum IDAT size (PNG_ZBUF_SIZE in pngconf.h) is not 8192.
 * 3) unknown unsafe-to-copy ancillary chunks or unknown critical chunks
 *    exist in the input file.
d22 1
a22 1
 * to see what the differences between the two files are.
d30 2
a31 29
#if defined(_WIN32_WCE)
#  if _WIN32_WCE < 211
     __error__ (f|w)printf functions are not supported on old WindowsCE.;
#  endif
#  include <windows.h>
#  include <stdlib.h>
#  define READFILE(file, data, length, check) \
     if (ReadFile(file, data, length, &check,NULL)) check = 0
#  define WRITEFILE(file, data, length, check)) \
     if (WriteFile(file, data, length, &check, NULL)) check = 0
#  define FCLOSE(file) CloseHandle(file)
#else
#  include <stdio.h>
#  include <stdlib.h>
#  include <assert.h>
#  define READFILE(file, data, length, check) \
     check=(png_size_t)fread(data,(png_size_t)1,length,file)
#  define WRITEFILE(file, data, length, check) \
     check=(png_size_t)fwrite(data,(png_size_t)1, length, file)
#  define FCLOSE(file) fclose(file)
#endif

#if defined(PNG_NO_STDIO)
#  if defined(_WIN32_WCE)
     typedef HANDLE                png_FILE_p;
#  else
     typedef FILE                * png_FILE_p;
#  endif
#endif
d35 1
a35 18
#  define PNG_DEBUG 0
#endif

#if !PNG_DEBUG
#  define SINGLE_ROWBUF_ALLOC  /* makes buffer overruns easier to nail */
#endif

/* Turn on CPU timing
#define PNGTEST_TIMING
*/

#ifdef PNG_NO_FLOATING_POINT_SUPPORTED
#undef PNGTEST_TIMING
#endif

#ifdef PNGTEST_TIMING
static float t_start, t_stop, t_decode, t_encode, t_misc;
#include <time.h>
a39 12
/* Define png_jmpbuf() in case we are using a pre-1.0.6 version of libpng */
#ifndef png_jmpbuf
#  define png_jmpbuf(png_ptr) png_ptr->jmpbuf
#endif

#ifdef PNGTEST_TIMING
static float t_start, t_stop, t_decode, t_encode, t_misc;
#if !defined(PNG_tIME_SUPPORTED)
#include <time.h>
#endif
#endif

d43 1
a43 3
#endif

static int verbose = 0;
d45 1
a45 1
int test_one_file PNGARG((PNG_CONST char *inname, PNG_CONST char *outname));
a60 8
#ifdef PNG_1_0_X
PNGAPI
#endif
read_row_callback(png_structp png_ptr, png_uint_32 row_number, int pass);
void
#ifdef PNG_1_0_X
PNGAPI
#endif
d63 1
a63 1
    if(png_ptr == NULL || row_number > PNG_MAX_UINT) return;
d68 1
a68 1
       status_dots = 31;
a79 8
#ifdef PNG_1_0_X
PNGAPI
#endif
write_row_callback(png_structp png_ptr, png_uint_32 row_number, int pass);
void
#ifdef PNG_1_0_X
PNGAPI
#endif
d82 1
a82 1
    if(png_ptr == NULL || row_number > PNG_MAX_UINT || pass > 7) return;
a86 21
#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
/* Example of using user transform callback (we don't transform anything,
   but merely examine the row filters.  We set this to 256 rather than
   5 in case illegal filter values are present.) */
static png_uint_32 filters_used[256];
void
#ifdef PNG_1_0_X
PNGAPI
#endif
count_filters(png_structp png_ptr, png_row_infop row_info, png_bytep data);
void
#ifdef PNG_1_0_X
PNGAPI
#endif
count_filters(png_structp png_ptr, png_row_infop row_info, png_bytep data)
{
    if(png_ptr != NULL && row_info != NULL)
      ++filters_used[*(data-1)];
}
#endif

a93 8
#ifdef PNG_1_0_X
PNGAPI
#endif
count_zero_samples(png_structp png_ptr, png_row_infop row_info, png_bytep data);
void
#ifdef PNG_1_0_X
PNGAPI
#endif
d97 1
a97 1
   if(png_ptr == NULL)return;
a107 1

d118 1
a118 1
             if(((*dp << pos++ ) & 0x80) == 0) zero_samples++;
d127 1
a127 1
             if(((*dp << (pos+=2)) & 0xc0) == 0) zero_samples++;
d136 1
a136 1
             if(((*dp << (pos+=4)) & 0xf0) == 0) zero_samples++;
d181 1
a191 1

d194 1
a194 1
pngtest_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
d201 2
a202 1
   READFILE((png_FILE_p)png_ptr->io_ptr, data, length, check);
d206 1
a206 1
      png_error(png_ptr, "Read Error!");
d214 1
a214 1

d217 1
a217 1

d219 1
a219 1
pngtest_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
d223 1
a223 1
   png_FILE_p io_ptr;
d227 1
a227 1
   io_ptr = (png_FILE_p)CVT_PTR(png_ptr->io_ptr);
d230 1
a230 1
      READFILE(io_ptr, n_data, length, check);
d241 1
a241 1
         READFILE(io_ptr, buf, 1, err);
d261 1
a261 1
pngtest_flush(png_structp png_ptr)
d263 2
a264 3
#if !defined(_WIN32_WCE)
   png_FILE_p io_ptr;
   io_ptr = (png_FILE_p)CVT_PTR((png_ptr->io_ptr));
a266 1
#endif
d276 1
a276 1
pngtest_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
d280 1
a280 1
   WRITEFILE((png_FILE_p)png_ptr->io_ptr,  data, length, check);
d296 1
a296 1
pngtest_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
d300 1
a300 1
   png_FILE_p io_ptr;
d304 1
a304 1
   io_ptr = (png_FILE_p)CVT_PTR(png_ptr->io_ptr);
d307 1
a307 1
      WRITEFILE(io_ptr, near_data, length, check);
d319 1
a319 1
         WRITEFILE(io_ptr, buf, written, err);
d343 1
a343 1
pngtest_warning(png_structp png_ptr, png_const_charp message)
d345 1
a345 1
   PNG_CONST char *name = "UNKNOWN (ERROR!)";
d357 1
a357 1
pngtest_error(png_structp png_ptr, png_const_charp message)
d359 1
a359 1
   pngtest_warning(png_ptr, message);
d377 2
a378 3
typedef struct memory_information
{
   png_uint_32               size;
a386 2
static int total_allocation = 0;
static int num_allocations = 0;
d388 4
a391 2
png_voidp png_debug_malloc PNGARG((png_structp png_ptr, png_uint_32 size));
void png_debug_free PNGARG((png_structp png_ptr, png_voidp ptr));
d394 1
a394 2
png_debug_malloc(png_structp png_ptr, png_uint_32 size)
{
d400 1
a400 1
      return (NULL);
d405 1
a405 2
      memory_infop pinfo = (memory_infop)png_malloc_default(png_ptr,
         (png_uint_32)sizeof *pinfo);
a407 2
      total_allocation += size;
      num_allocations ++;
d410 1
a410 1
      pinfo->pointer = (png_voidp)png_malloc_default(png_ptr, size);
a414 5
#if PNG_DEBUG
      if(verbose)
         printf("png_malloc %lu bytes at %x\n",size,pinfo->pointer);
#endif
      assert(pinfo->size != 12345678);
d425 1
a425 2
   if (ptr == 0)
   {
d435 1
a435 2
      for (;;)
      {
d437 1
a437 2
         if (pinfo->pointer == ptr)
         {
d444 1
a444 1
            png_memset(ptr, 0x55, pinfo->size);
a445 1
            pinfo=NULL;
d448 2
a449 3
         if (pinfo->next == NULL)
         {
            fprintf(STDERR, "Pointer %x not found\n", (unsigned int)ptr);
a456 4
#if PNG_DEBUG
   if(verbose)
      printf("Freeing %x\n",ptr);
#endif
a457 1
   ptr=NULL;
d464 1
a464 1
test_one_file(PNG_CONST char *inname, PNG_CONST char *outname)
d466 3
a468 13
   static png_FILE_p fpin;
   static png_FILE_p fpout;  /* "static" prevents setjmp corruption */
   png_structp read_ptr;
   png_infop read_info_ptr, end_info_ptr;
#ifdef PNG_WRITE_SUPPORTED
   png_structp write_ptr;
   png_infop write_info_ptr;
   png_infop write_end_info_ptr;
#else
   png_structp write_ptr = NULL;
   png_infop write_info_ptr = NULL;
   png_infop write_end_info_ptr = NULL;
#endif
a473 1
#ifdef PNG_SETJMP_SUPPORTED
d476 2
a477 6
#endif
#endif

#if defined(_WIN32_WCE)
   TCHAR path[MAX_PATH];
#endif
d480 1
a480 1
   row_buf = NULL;
a481 4
#if defined(_WIN32_WCE)
   MultiByteToWideChar(CP_ACP, 0, inname, -1, path, MAX_PATH);
   if ((fpin = CreateFile(path, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL)) == INVALID_HANDLE_VALUE)
#else
a482 1
#endif
a487 4
#if defined(_WIN32_WCE)
   MultiByteToWideChar(CP_ACP, 0, outname, -1, path, MAX_PATH);
   if ((fpout = CreateFile(path, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL)) == INVALID_HANDLE_VALUE)
#else
a488 1
#endif
d491 1
a491 1
      FCLOSE(fpin);
d497 2
a498 2
   read_ptr = png_create_read_struct_2(PNG_LIBPNG_VER_STRING, png_voidp_NULL,
      png_error_ptr_NULL, png_error_ptr_NULL, png_voidp_NULL,
d501 2
a502 2
   read_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, png_voidp_NULL,
      png_error_ptr_NULL, png_error_ptr_NULL);
d505 2
a506 2
   png_set_error_fn(read_ptr, (png_voidp)inname, pngtest_error,
       pngtest_warning);
a507 1
#ifdef PNG_WRITE_SUPPORTED
d509 2
a510 2
   write_ptr = png_create_write_struct_2(PNG_LIBPNG_VER_STRING, png_voidp_NULL,
      png_error_ptr_NULL, png_error_ptr_NULL, png_voidp_NULL,
d513 2
a514 2
   write_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, png_voidp_NULL,
      png_error_ptr_NULL, png_error_ptr_NULL);
d517 2
a518 3
   png_set_error_fn(write_ptr, (png_voidp)inname, pngtest_error,
       pngtest_warning);
#endif
d522 1
d524 1
a524 3
#ifdef PNG_WRITE_SUPPORTED
   write_info_ptr = png_create_info_struct(write_ptr);
   write_end_info_ptr = png_create_info_struct(write_ptr);
a526 1
#ifdef PNG_SETJMP_SUPPORTED
d531 1
a531 1
   if (setjmp(png_jmpbuf(read_ptr)))
a534 2
      if (row_buf)
         png_free(read_ptr, row_buf);
a535 2
#ifdef PNG_WRITE_SUPPORTED
      png_destroy_info_struct(write_ptr, &write_end_info_ptr);
d537 2
a538 3
#endif
      FCLOSE(fpin);
      FCLOSE(fpout);
a540 3
#ifdef USE_FAR_KEYWORD
   png_memcpy(png_jmpbuf(read_ptr),jmpbuf,sizeof(jmp_buf));
#endif
a541 1
#ifdef PNG_WRITE_SUPPORTED
d544 1
d547 1
a547 1
   if (setjmp(png_jmpbuf(write_ptr)))
a551 2
      png_destroy_info_struct(write_ptr, &write_end_info_ptr);
#ifdef PNG_WRITE_SUPPORTED
d553 2
a554 3
#endif
      FCLOSE(fpin);
      FCLOSE(fpout);
d557 1
d559 1
a559 3
   png_memcpy(png_jmpbuf(write_ptr),jmpbuf,sizeof(jmp_buf));
#endif
#endif
a560 1

a563 1
#  ifdef PNG_WRITE_SUPPORTED
a564 1
#  endif
d566 5
a570 6
   png_set_read_fn(read_ptr, (png_voidp)fpin, pngtest_read_data);
#  ifdef PNG_WRITE_SUPPORTED
   png_set_write_fn(write_ptr, (png_voidp)fpout,  pngtest_write_data,
#    if defined(PNG_WRITE_FLUSH_SUPPORTED)
      pngtest_flush);
#    else
d572 1
a572 2
#    endif
#  endif
a575 1
#ifdef PNG_WRITE_SUPPORTED
a576 1
#endif
d581 2
a582 4
#ifdef PNG_WRITE_SUPPORTED
      png_set_write_status_fn(write_ptr, png_write_status_ptr_NULL);
#endif
      png_set_read_status_fn(read_ptr, png_read_status_ptr_NULL);
d585 4
a588 23
#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
   {
     int i;
     for(i=0; i<256; i++)
        filters_used[i]=0;
     png_set_read_user_transform_fn(read_ptr, count_filters);
   }
#endif
#if defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
   zero_samples=0;
   png_set_write_user_transform_fn(write_ptr, count_zero_samples);
#endif

#define HANDLE_CHUNK_IF_SAFE      2
#define HANDLE_CHUNK_ALWAYS       3
#if defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
   png_set_keep_unknown_chunks(read_ptr, HANDLE_CHUNK_ALWAYS,
      png_bytep_NULL, 0);
#endif
#if defined(PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED)
   png_set_keep_unknown_chunks(write_ptr, HANDLE_CHUNK_IF_SAFE,
      png_bytep_NULL, 0);
#endif
d608 1
a608 2
#if defined(PNG_FIXED_POINT_SUPPORTED)
#if defined(PNG_cHRM_SUPPORTED)
d610 3
a612 4
      png_fixed_point white_x, white_y, red_x, red_y, green_x, green_y, blue_x,
         blue_y;
      if (png_get_cHRM_fixed(read_ptr, read_info_ptr, &white_x, &white_y, &red_x,
         &red_y, &green_x, &green_y, &blue_x, &blue_y))
d614 1
a614 2
         png_set_cHRM_fixed(write_ptr, write_info_ptr, white_x, white_y, red_x,
            red_y, green_x, green_y, blue_x, blue_y);
d618 1
a618 1
#if defined(PNG_gAMA_SUPPORTED)
d620 1
a620 1
      png_fixed_point gamma;
a621 12
      if (png_get_gAMA_fixed(read_ptr, read_info_ptr, &gamma))
      {
         png_set_gAMA_fixed(write_ptr, write_info_ptr, gamma);
      }
   }
#endif
#else /* Use floating point versions */
#if defined(PNG_FLOATING_POINT_SUPPORTED)
#if defined(PNG_cHRM_SUPPORTED)
   {
      double white_x, white_y, red_x, red_y, green_x, green_y, blue_x,
         blue_y;
d630 1
a630 1
#if defined(PNG_gAMA_SUPPORTED)
d640 1
a640 18
#endif /* floating point */
#endif /* fixed point */
#if defined(PNG_iCCP_SUPPORTED)
   {
      png_charp name;
      png_charp profile;
      png_uint_32 proflen;
      int compression_type;

      if (png_get_iCCP(read_ptr, read_info_ptr, &name, &compression_type,
                      &profile, &proflen))
      {
         png_set_iCCP(write_ptr, write_info_ptr, name, compression_type,
                      profile, proflen);
      }
   }
#endif
#if defined(PNG_sRGB_SUPPORTED)
d650 1
a650 20
   {
      png_colorp palette;
      int num_palette;

      if (png_get_PLTE(read_ptr, read_info_ptr, &palette, &num_palette))
      {
         png_set_PLTE(write_ptr, write_info_ptr, palette, num_palette);
      }
   }
#if defined(PNG_bKGD_SUPPORTED)
   {
      png_color_16p background;

      if (png_get_bKGD(read_ptr, read_info_ptr, &background))
      {
         png_set_bKGD(write_ptr, write_info_ptr, background);
      }
   }
#endif
#if defined(PNG_hIST_SUPPORTED)
d660 1
a660 1
#if defined(PNG_oFFs_SUPPORTED)
d662 1
a662 1
      png_int_32 offset_x, offset_y;
d671 1
a671 1
#if defined(PNG_pCAL_SUPPORTED)
d686 1
a686 1
#if defined(PNG_pHYs_SUPPORTED)
a696 1
#if defined(PNG_sBIT_SUPPORTED)
d698 2
a699 1
      png_color_8p sig_bit;
d701 1
a701 1
      if (png_get_sBIT(read_ptr, read_info_ptr, &sig_bit))
d703 1
a703 1
         png_set_sBIT(write_ptr, write_info_ptr, sig_bit);
d706 1
a706 3
#endif
#if defined(PNG_sCAL_SUPPORTED)
#ifdef PNG_FLOATING_POINT_SUPPORTED
d708 1
a708 2
      int unit;
      double scal_width, scal_height;
d710 1
a710 2
      if (png_get_sCAL(read_ptr, read_info_ptr, &unit, &scal_width,
         &scal_height))
d712 1
a712 13
         png_set_sCAL(write_ptr, write_info_ptr, unit, scal_width, scal_height);
      }
   }
#else
#ifdef PNG_FIXED_POINT_SUPPORTED
   {
      int unit;
      png_charp scal_width, scal_height;

      if (png_get_sCAL_s(read_ptr, read_info_ptr, &unit, &scal_width,
          &scal_height))
      {
         png_set_sCAL_s(write_ptr, write_info_ptr, unit, scal_width, scal_height);
d716 2
a717 3
#endif
#endif
#if defined(PNG_TEXT_SUPPORTED)
d724 1
a724 1
         png_debug1(0, "Handling %d iTXt/tEXt/zTXt chunks\n", num_text);
d729 1
a729 1
#if defined(PNG_tIME_SUPPORTED)
d736 1
d738 1
d744 1
a745 1
      }
d748 1
a748 1
#if defined(PNG_tRNS_SUPPORTED)
a761 19
#if defined(PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED)
   {
      png_unknown_chunkp unknowns;
      int num_unknowns = (int)png_get_unknown_chunks(read_ptr, read_info_ptr,
         &unknowns);
      if (num_unknowns)
      {
         png_size_t i;
         png_set_unknown_chunks(write_ptr, write_info_ptr, unknowns,
           num_unknowns);
         /* copy the locations from the read_info_ptr.  The automatically
            generated locations in write_info_ptr are wrong because we
            haven't written anything yet */
         for (i = 0; i < (png_size_t)num_unknowns; i++)
           png_set_unknown_chunk_location(write_ptr, write_info_ptr, i,
             unknowns[i].location);
      }
   }
#endif
a762 1
#ifdef PNG_WRITE_SUPPORTED
a763 4

/* If we wanted, we could write info in two steps:
   png_write_info_before_PLTE(write_ptr, write_info_ptr);
 */
a764 1
#endif
d766 2
a767 3
#ifdef SINGLE_ROWBUF_ALLOC
   png_debug(0, "\nAllocating row buffer...");
   row_buf = (png_bytep)png_malloc(read_ptr,
d769 9
a777 2
   png_debug1(0, "0x%08lx\n\n", (unsigned long)row_buf);
#endif /* SINGLE_ROWBUF_ALLOC */
a779 2
#if defined(PNG_READ_INTERLACING_SUPPORTED) || \
  defined(PNG_WRITE_INTERLACING_SUPPORTED)
a780 1
#  ifdef PNG_WRITE_SUPPORTED
a781 4
#  endif
#else
   num_pass=1;
#endif
a782 5
#ifdef PNGTEST_TIMING
   t_stop = (float)clock();
   t_misc += (t_stop - t_start);
   t_start = t_stop;
#endif
d788 1
a788 15
#ifndef SINGLE_ROWBUF_ALLOC
         png_debug2(0, "\nAllocating row buffer (pass %d, y = %ld)...", pass,y);
         row_buf = (png_bytep)png_malloc(read_ptr,
            png_get_rowbytes(read_ptr, read_info_ptr));
         png_debug2(0, "0x%08lx (%ld bytes)\n", (unsigned long)row_buf,
            png_get_rowbytes(read_ptr, read_info_ptr));
#endif /* !SINGLE_ROWBUF_ALLOC */
         png_read_rows(read_ptr, (png_bytepp)&row_buf, png_bytepp_NULL, 1);

#ifdef PNG_WRITE_SUPPORTED
#ifdef PNGTEST_TIMING
         t_stop = (float)clock();
         t_decode += (t_stop - t_start);
         t_start = t_stop;
#endif
a789 11
#ifdef PNGTEST_TIMING
         t_stop = (float)clock();
         t_encode += (t_stop - t_start);
         t_start = t_stop;
#endif
#endif /* PNG_WRITE_SUPPORTED */

#ifndef SINGLE_ROWBUF_ALLOC
         png_debug2(0, "Freeing row buffer (pass %d, y = %ld)\n\n", pass, y);
         png_free(read_ptr, row_buf);
#endif /* !SINGLE_ROWBUF_ALLOC */
a792 7
#if defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
   png_free_data(read_ptr, read_info_ptr, PNG_FREE_UNKN, -1);
#endif
#if defined(PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED)
   png_free_data(write_ptr, write_info_ptr, PNG_FREE_UNKN, -1);
#endif

a793 1

d795 2
a796 53
#if defined(PNG_TEXT_SUPPORTED)
   {
      png_textp text_ptr;
      int num_text;

      if (png_get_text(read_ptr, end_info_ptr, &text_ptr, &num_text) > 0)
      {
         png_debug1(0, "Handling %d iTXt/tEXt/zTXt chunks\n", num_text);
         png_set_text(write_ptr, write_end_info_ptr, text_ptr, num_text);
      }
   }
#endif
#if defined(PNG_tIME_SUPPORTED)
   {
      png_timep mod_time;

      if (png_get_tIME(read_ptr, end_info_ptr, &mod_time))
      {
         png_set_tIME(write_ptr, write_end_info_ptr, mod_time);
#if defined(PNG_TIME_RFC1123_SUPPORTED)
         /* we have to use png_strcpy instead of "=" because the string
            pointed to by png_convert_to_rfc1123() gets free'ed before
            we use it */
         png_strcpy(tIME_string,png_convert_to_rfc1123(read_ptr, mod_time));
         tIME_chunk_present++;
#endif /* PNG_TIME_RFC1123_SUPPORTED */
      }
   }
#endif
#if defined(PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED)
   {
      png_unknown_chunkp unknowns;
      int num_unknowns;
      num_unknowns = (int)png_get_unknown_chunks(read_ptr, end_info_ptr,
         &unknowns);
      if (num_unknowns)
      {
         png_size_t i;
         png_set_unknown_chunks(write_ptr, write_end_info_ptr, unknowns,
           num_unknowns);
         /* copy the locations from the read_info_ptr.  The automatically
            generated locations in write_end_info_ptr are wrong because we
            haven't written the end_info yet */
         for (i = 0; i < (png_size_t)num_unknowns; i++)
           png_set_unknown_chunk_location(write_ptr, write_end_info_ptr, i,
             unknowns[i].location);
      }
   }
#endif
#ifdef PNG_WRITE_SUPPORTED
   png_write_end(write_ptr, write_end_info_ptr);
#endif

a808 2
#ifdef SINGLE_ROWBUF_ALLOC
   png_debug(1, "destroying row_buf for read_ptr\n");
a809 3
   row_buf=NULL;
#endif /* SINGLE_ROWBUF_ALLOC */
   png_debug(1, "destroying read_ptr, read_info_ptr, end_info_ptr\n");
a810 4
#ifdef PNG_WRITE_SUPPORTED
   png_debug(1, "destroying write_end_info_ptr\n");
   png_destroy_info_struct(write_ptr, &write_end_info_ptr);
   png_debug(1, "destroying write_ptr, write_info_ptr\n");
a811 2
#endif
   png_debug(0, "Destruction complete.\n");
d813 2
a814 2
   FCLOSE(fpin);
   FCLOSE(fpout);
a816 4
#if defined(_WIN32_WCE)
   MultiByteToWideChar(CP_ACP, 0, inname, -1, path, MAX_PATH);
   if ((fpin = CreateFile(path, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL)) == INVALID_HANDLE_VALUE)
#else
a817 1
#endif
a822 4
#if defined(_WIN32_WCE)
   MultiByteToWideChar(CP_ACP, 0, outname, -1, path, MAX_PATH);
   if ((fpout = CreateFile(path, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL)) == INVALID_HANDLE_VALUE)
#else
a823 1
#endif
d826 1
a826 1
      FCLOSE(fpin);
d834 2
a835 2
      READFILE(fpin, inbuf, 1, num_in);
      READFILE(fpout, outbuf, 1, num_out);
d839 1
a839 1
         fprintf(STDERR, "\nFiles %s and %s are of a different size\n",
d844 1
a844 2
         "   Was %s written with the same maximum IDAT chunk size (%d bytes),",
              inname,PNG_ZBUF_SIZE);
d846 1
a846 1
              "\n   filtering heuristic (libpng default), compression");
d848 1
a848 1
              " level (zlib default),\n   and zlib version (%s)?\n\n",
d852 2
a853 2
         FCLOSE(fpin);
         FCLOSE(fpout);
d862 1
a862 1
         fprintf(STDERR, "\nFiles %s and %s are different\n", inname, outname);
d866 1
a866 2
         "   Was %s written with the same maximum IDAT chunk size (%d bytes),",
                 inname,PNG_ZBUF_SIZE);
d868 1
a868 1
              "\n   filtering heuristic (libpng default), compression");
d870 1
a870 1
              " level (zlib default),\n   and zlib version (%s)?\n\n",
d874 2
a875 2
         FCLOSE(fpin);
         FCLOSE(fpout);
d880 2
a881 2
   FCLOSE(fpin);
   FCLOSE(fpout);
d888 2
a889 2
static PNG_CONST char *inname = "pngtest/png";
static PNG_CONST char *outname = "pngout/png";
d891 2
a892 2
static PNG_CONST char *inname = "pngtest.png";
static PNG_CONST char *outname = "pngout.png";
a902 9
   fprintf(STDERR,"%s",png_get_copyright(NULL));
   /* Show the version of libpng used in building the library */
   fprintf(STDERR," library (%lu):%s", png_access_version_number(),
      png_get_header_version(NULL));
   /* Show the version of libpng used in building the application */
   fprintf(STDERR," pngtest (%lu):%s", (unsigned long)PNG_LIBPNG_VER,
      PNG_HEADER_VERSION_STRING);
   fprintf(STDERR," sizeof(png_struct)=%ld, sizeof(png_info)=%ld\n",
                    (long)sizeof(png_struct), (long)sizeof(png_info));
a974 3
#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
         int k;
#endif
d978 1
a978 1
         if (kerror == 0)
d981 1
a981 1
            fprintf(STDERR, "\n PASS (%lu zero samples)\n",zero_samples);
d984 1
a984 7
#endif
#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
            for (k=0; k<256; k++)
               if(filters_used[k])
                  fprintf(STDERR, " Filter %d was used %lu times\n",
                     k,filters_used[k]);
#endif
d1000 1
a1000 2
         if (current_allocation != 0)
         {
d1005 2
a1006 4
            while (pinfo != NULL)
            {
               fprintf(STDERR, " %lu bytes at %x\n", pinfo->size, 
                 (unsigned int) pinfo->pointer);
d1008 1
a1008 1
            }
d1013 1
a1013 3
         fprintf(STDERR, " Current memory allocation: %10d bytes\n",
            current_allocation);
         fprintf(STDERR, " Maximum memory allocation: %10d bytes\n",
a1014 4
         fprintf(STDERR, " Total   memory allocation: %10d bytes\n",
            total_allocation);
         fprintf(STDERR, "     Number of allocations: %10d\n",
            num_allocations);
d1020 1
a1020 2
      for (i=0; i<3; ++i)
      {
a1033 3
#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
                int k;
#endif
d1035 1
a1035 1
                fprintf(STDERR, "\n PASS (%lu zero samples)\n",zero_samples);
a1038 6
#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
                for (k=0; k<256; k++)
                   if(filters_used[k])
                      fprintf(STDERR, " Filter %d was used %lu times\n",
                         k,filters_used[k]);
#endif
d1040 2
a1041 2
             if(tIME_chunk_present != 0)
                fprintf(STDERR, " tIME = %s\n",tIME_string);
d1056 1
a1056 2
         if (current_allocation != 0)
         {
d1058 1
a1058 1

d1061 2
a1062 4
             while (pinfo != NULL)
             {
                fprintf(STDERR," %lu bytes at %x\n",
                   pinfo->size, (unsigned int)pinfo->pointer);
d1069 1
a1069 3
       fprintf(STDERR, " Current memory allocation: %10d bytes\n",
          current_allocation);
       fprintf(STDERR, " Maximum memory allocation: %10d bytes\n",
a1070 4
       fprintf(STDERR, " Total   memory allocation: %10d bytes\n",
          total_allocation);
       fprintf(STDERR, "     Number of allocations: %10d\n",
            num_allocations);
a1073 14
#ifdef PNGTEST_TIMING
   t_stop = (float)clock();
   t_misc += (t_stop - t_start);
   t_start = t_stop;
   fprintf(STDERR," CPU time used = %.3f seconds",
      (t_misc+t_decode+t_encode)/(float)CLOCKS_PER_SEC);
   fprintf(STDERR," (decoding %.3f,\n",
      t_decode/(float)CLOCKS_PER_SEC);
   fprintf(STDERR,"        encoding %.3f ,",
      t_encode/(float)CLOCKS_PER_SEC);
   fprintf(STDERR," other %.3f seconds)\n\n",
      t_misc/(float)CLOCKS_PER_SEC);
#endif

a1080 2
/* Generate a compiler error if there is an old png.h in the search path. */
typedef version_1_2_5 your_png_h_is_not_version_1_2_5;
@


1.2.6.1
log
@sync to HEAD...
@
text
@d4 1
a4 1
 * libpng 1.2.5 - October 3, 2002
d6 3
a8 3
 * Copyright (c) 1998-2002 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
d18 2
a19 3
 * 2) when the maximum IDAT size (PNG_ZBUF_SIZE in pngconf.h) is not 8192.
 * 3) unknown unsafe-to-copy ancillary chunks or unknown critical chunks
 *    exist in the input file.
d22 1
a22 1
 * to see what the differences between the two files are.
d30 2
a31 29
#if defined(_WIN32_WCE)
#  if _WIN32_WCE < 211
     __error__ (f|w)printf functions are not supported on old WindowsCE.;
#  endif
#  include <windows.h>
#  include <stdlib.h>
#  define READFILE(file, data, length, check) \
     if (ReadFile(file, data, length, &check,NULL)) check = 0
#  define WRITEFILE(file, data, length, check)) \
     if (WriteFile(file, data, length, &check, NULL)) check = 0
#  define FCLOSE(file) CloseHandle(file)
#else
#  include <stdio.h>
#  include <stdlib.h>
#  include <assert.h>
#  define READFILE(file, data, length, check) \
     check=(png_size_t)fread(data,(png_size_t)1,length,file)
#  define WRITEFILE(file, data, length, check) \
     check=(png_size_t)fwrite(data,(png_size_t)1, length, file)
#  define FCLOSE(file) fclose(file)
#endif

#if defined(PNG_NO_STDIO)
#  if defined(_WIN32_WCE)
     typedef HANDLE                png_FILE_p;
#  else
     typedef FILE                * png_FILE_p;
#  endif
#endif
d35 1
a35 18
#  define PNG_DEBUG 0
#endif

#if !PNG_DEBUG
#  define SINGLE_ROWBUF_ALLOC  /* makes buffer overruns easier to nail */
#endif

/* Turn on CPU timing
#define PNGTEST_TIMING
*/

#ifdef PNG_NO_FLOATING_POINT_SUPPORTED
#undef PNGTEST_TIMING
#endif

#ifdef PNGTEST_TIMING
static float t_start, t_stop, t_decode, t_encode, t_misc;
#include <time.h>
a39 12
/* Define png_jmpbuf() in case we are using a pre-1.0.6 version of libpng */
#ifndef png_jmpbuf
#  define png_jmpbuf(png_ptr) png_ptr->jmpbuf
#endif

#ifdef PNGTEST_TIMING
static float t_start, t_stop, t_decode, t_encode, t_misc;
#if !defined(PNG_tIME_SUPPORTED)
#include <time.h>
#endif
#endif

d43 1
a43 3
#endif

static int verbose = 0;
d45 1
a45 1
int test_one_file PNGARG((PNG_CONST char *inname, PNG_CONST char *outname));
a60 8
#ifdef PNG_1_0_X
PNGAPI
#endif
read_row_callback(png_structp png_ptr, png_uint_32 row_number, int pass);
void
#ifdef PNG_1_0_X
PNGAPI
#endif
d63 1
a63 1
    if(png_ptr == NULL || row_number > PNG_MAX_UINT) return;
d68 1
a68 1
       status_dots = 31;
a79 8
#ifdef PNG_1_0_X
PNGAPI
#endif
write_row_callback(png_structp png_ptr, png_uint_32 row_number, int pass);
void
#ifdef PNG_1_0_X
PNGAPI
#endif
d82 1
a82 1
    if(png_ptr == NULL || row_number > PNG_MAX_UINT || pass > 7) return;
a86 21
#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
/* Example of using user transform callback (we don't transform anything,
   but merely examine the row filters.  We set this to 256 rather than
   5 in case illegal filter values are present.) */
static png_uint_32 filters_used[256];
void
#ifdef PNG_1_0_X
PNGAPI
#endif
count_filters(png_structp png_ptr, png_row_infop row_info, png_bytep data);
void
#ifdef PNG_1_0_X
PNGAPI
#endif
count_filters(png_structp png_ptr, png_row_infop row_info, png_bytep data)
{
    if(png_ptr != NULL && row_info != NULL)
      ++filters_used[*(data-1)];
}
#endif

a93 8
#ifdef PNG_1_0_X
PNGAPI
#endif
count_zero_samples(png_structp png_ptr, png_row_infop row_info, png_bytep data);
void
#ifdef PNG_1_0_X
PNGAPI
#endif
d97 1
a97 1
   if(png_ptr == NULL)return;
a107 1

d118 1
a118 1
             if(((*dp << pos++ ) & 0x80) == 0) zero_samples++;
d127 1
a127 1
             if(((*dp << (pos+=2)) & 0xc0) == 0) zero_samples++;
d136 1
a136 1
             if(((*dp << (pos+=4)) & 0xf0) == 0) zero_samples++;
d181 1
a191 1

d194 1
a194 1
pngtest_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
d201 2
a202 1
   READFILE((png_FILE_p)png_ptr->io_ptr, data, length, check);
d206 1
a206 1
      png_error(png_ptr, "Read Error!");
d214 1
a214 1

d217 1
a217 1

d219 1
a219 1
pngtest_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
d223 1
a223 1
   png_FILE_p io_ptr;
d227 1
a227 1
   io_ptr = (png_FILE_p)CVT_PTR(png_ptr->io_ptr);
d230 1
a230 1
      READFILE(io_ptr, n_data, length, check);
d241 1
a241 1
         READFILE(io_ptr, buf, 1, err);
d261 1
a261 1
pngtest_flush(png_structp png_ptr)
d263 2
a264 3
#if !defined(_WIN32_WCE)
   png_FILE_p io_ptr;
   io_ptr = (png_FILE_p)CVT_PTR((png_ptr->io_ptr));
a266 1
#endif
d276 1
a276 1
pngtest_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
d280 1
a280 1
   WRITEFILE((png_FILE_p)png_ptr->io_ptr,  data, length, check);
d296 1
a296 1
pngtest_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
d300 1
a300 1
   png_FILE_p io_ptr;
d304 1
a304 1
   io_ptr = (png_FILE_p)CVT_PTR(png_ptr->io_ptr);
d307 1
a307 1
      WRITEFILE(io_ptr, near_data, length, check);
d319 1
a319 1
         WRITEFILE(io_ptr, buf, written, err);
d343 1
a343 1
pngtest_warning(png_structp png_ptr, png_const_charp message)
d345 1
a345 1
   PNG_CONST char *name = "UNKNOWN (ERROR!)";
d357 1
a357 1
pngtest_error(png_structp png_ptr, png_const_charp message)
d359 1
a359 1
   pngtest_warning(png_ptr, message);
d377 2
a378 3
typedef struct memory_information
{
   png_uint_32               size;
a386 2
static int total_allocation = 0;
static int num_allocations = 0;
d388 4
a391 2
png_voidp png_debug_malloc PNGARG((png_structp png_ptr, png_uint_32 size));
void png_debug_free PNGARG((png_structp png_ptr, png_voidp ptr));
d394 1
a394 2
png_debug_malloc(png_structp png_ptr, png_uint_32 size)
{
d400 1
a400 1
      return (NULL);
d405 1
a405 2
      memory_infop pinfo = (memory_infop)png_malloc_default(png_ptr,
         (png_uint_32)sizeof *pinfo);
a407 2
      total_allocation += size;
      num_allocations ++;
d410 1
a410 1
      pinfo->pointer = (png_voidp)png_malloc_default(png_ptr, size);
a414 5
#if PNG_DEBUG
      if(verbose)
         printf("png_malloc %lu bytes at %x\n",size,pinfo->pointer);
#endif
      assert(pinfo->size != 12345678);
d425 1
a425 2
   if (ptr == 0)
   {
d435 1
a435 2
      for (;;)
      {
d437 1
a437 2
         if (pinfo->pointer == ptr)
         {
d444 1
a444 1
            png_memset(ptr, 0x55, pinfo->size);
a445 1
            pinfo=NULL;
d448 2
a449 3
         if (pinfo->next == NULL)
         {
            fprintf(STDERR, "Pointer %x not found\n", (unsigned int)ptr);
a456 4
#if PNG_DEBUG
   if(verbose)
      printf("Freeing %x\n",ptr);
#endif
a457 1
   ptr=NULL;
d464 1
a464 1
test_one_file(PNG_CONST char *inname, PNG_CONST char *outname)
d466 3
a468 13
   static png_FILE_p fpin;
   static png_FILE_p fpout;  /* "static" prevents setjmp corruption */
   png_structp read_ptr;
   png_infop read_info_ptr, end_info_ptr;
#ifdef PNG_WRITE_SUPPORTED
   png_structp write_ptr;
   png_infop write_info_ptr;
   png_infop write_end_info_ptr;
#else
   png_structp write_ptr = NULL;
   png_infop write_info_ptr = NULL;
   png_infop write_end_info_ptr = NULL;
#endif
a473 1
#ifdef PNG_SETJMP_SUPPORTED
d476 2
a477 6
#endif
#endif

#if defined(_WIN32_WCE)
   TCHAR path[MAX_PATH];
#endif
d480 1
a480 1
   row_buf = NULL;
a481 4
#if defined(_WIN32_WCE)
   MultiByteToWideChar(CP_ACP, 0, inname, -1, path, MAX_PATH);
   if ((fpin = CreateFile(path, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL)) == INVALID_HANDLE_VALUE)
#else
a482 1
#endif
a487 4
#if defined(_WIN32_WCE)
   MultiByteToWideChar(CP_ACP, 0, outname, -1, path, MAX_PATH);
   if ((fpout = CreateFile(path, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL)) == INVALID_HANDLE_VALUE)
#else
a488 1
#endif
d491 1
a491 1
      FCLOSE(fpin);
d497 2
a498 2
   read_ptr = png_create_read_struct_2(PNG_LIBPNG_VER_STRING, png_voidp_NULL,
      png_error_ptr_NULL, png_error_ptr_NULL, png_voidp_NULL,
d501 2
a502 2
   read_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, png_voidp_NULL,
      png_error_ptr_NULL, png_error_ptr_NULL);
d505 2
a506 2
   png_set_error_fn(read_ptr, (png_voidp)inname, pngtest_error,
       pngtest_warning);
a507 1
#ifdef PNG_WRITE_SUPPORTED
d509 2
a510 2
   write_ptr = png_create_write_struct_2(PNG_LIBPNG_VER_STRING, png_voidp_NULL,
      png_error_ptr_NULL, png_error_ptr_NULL, png_voidp_NULL,
d513 2
a514 2
   write_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, png_voidp_NULL,
      png_error_ptr_NULL, png_error_ptr_NULL);
d517 2
a518 3
   png_set_error_fn(write_ptr, (png_voidp)inname, pngtest_error,
       pngtest_warning);
#endif
d522 1
d524 1
a524 3
#ifdef PNG_WRITE_SUPPORTED
   write_info_ptr = png_create_info_struct(write_ptr);
   write_end_info_ptr = png_create_info_struct(write_ptr);
a526 1
#ifdef PNG_SETJMP_SUPPORTED
d531 1
a531 1
   if (setjmp(png_jmpbuf(read_ptr)))
a534 2
      if (row_buf)
         png_free(read_ptr, row_buf);
a535 2
#ifdef PNG_WRITE_SUPPORTED
      png_destroy_info_struct(write_ptr, &write_end_info_ptr);
d537 2
a538 3
#endif
      FCLOSE(fpin);
      FCLOSE(fpout);
a540 3
#ifdef USE_FAR_KEYWORD
   png_memcpy(png_jmpbuf(read_ptr),jmpbuf,sizeof(jmp_buf));
#endif
a541 1
#ifdef PNG_WRITE_SUPPORTED
d544 1
d547 1
a547 1
   if (setjmp(png_jmpbuf(write_ptr)))
a551 2
      png_destroy_info_struct(write_ptr, &write_end_info_ptr);
#ifdef PNG_WRITE_SUPPORTED
d553 2
a554 3
#endif
      FCLOSE(fpin);
      FCLOSE(fpout);
d557 1
d559 1
a559 3
   png_memcpy(png_jmpbuf(write_ptr),jmpbuf,sizeof(jmp_buf));
#endif
#endif
a560 1

a563 1
#  ifdef PNG_WRITE_SUPPORTED
a564 1
#  endif
d566 5
a570 6
   png_set_read_fn(read_ptr, (png_voidp)fpin, pngtest_read_data);
#  ifdef PNG_WRITE_SUPPORTED
   png_set_write_fn(write_ptr, (png_voidp)fpout,  pngtest_write_data,
#    if defined(PNG_WRITE_FLUSH_SUPPORTED)
      pngtest_flush);
#    else
d572 1
a572 2
#    endif
#  endif
a575 1
#ifdef PNG_WRITE_SUPPORTED
a576 1
#endif
d581 2
a582 4
#ifdef PNG_WRITE_SUPPORTED
      png_set_write_status_fn(write_ptr, png_write_status_ptr_NULL);
#endif
      png_set_read_status_fn(read_ptr, png_read_status_ptr_NULL);
d585 4
a588 23
#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
   {
     int i;
     for(i=0; i<256; i++)
        filters_used[i]=0;
     png_set_read_user_transform_fn(read_ptr, count_filters);
   }
#endif
#if defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
   zero_samples=0;
   png_set_write_user_transform_fn(write_ptr, count_zero_samples);
#endif

#define HANDLE_CHUNK_IF_SAFE      2
#define HANDLE_CHUNK_ALWAYS       3
#if defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
   png_set_keep_unknown_chunks(read_ptr, HANDLE_CHUNK_ALWAYS,
      png_bytep_NULL, 0);
#endif
#if defined(PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED)
   png_set_keep_unknown_chunks(write_ptr, HANDLE_CHUNK_IF_SAFE,
      png_bytep_NULL, 0);
#endif
d608 1
a608 2
#if defined(PNG_FIXED_POINT_SUPPORTED)
#if defined(PNG_cHRM_SUPPORTED)
d610 3
a612 4
      png_fixed_point white_x, white_y, red_x, red_y, green_x, green_y, blue_x,
         blue_y;
      if (png_get_cHRM_fixed(read_ptr, read_info_ptr, &white_x, &white_y, &red_x,
         &red_y, &green_x, &green_y, &blue_x, &blue_y))
d614 1
a614 2
         png_set_cHRM_fixed(write_ptr, write_info_ptr, white_x, white_y, red_x,
            red_y, green_x, green_y, blue_x, blue_y);
d618 1
a618 1
#if defined(PNG_gAMA_SUPPORTED)
d620 1
a620 1
      png_fixed_point gamma;
a621 12
      if (png_get_gAMA_fixed(read_ptr, read_info_ptr, &gamma))
      {
         png_set_gAMA_fixed(write_ptr, write_info_ptr, gamma);
      }
   }
#endif
#else /* Use floating point versions */
#if defined(PNG_FLOATING_POINT_SUPPORTED)
#if defined(PNG_cHRM_SUPPORTED)
   {
      double white_x, white_y, red_x, red_y, green_x, green_y, blue_x,
         blue_y;
d630 1
a630 1
#if defined(PNG_gAMA_SUPPORTED)
d640 1
a640 18
#endif /* floating point */
#endif /* fixed point */
#if defined(PNG_iCCP_SUPPORTED)
   {
      png_charp name;
      png_charp profile;
      png_uint_32 proflen;
      int compression_type;

      if (png_get_iCCP(read_ptr, read_info_ptr, &name, &compression_type,
                      &profile, &proflen))
      {
         png_set_iCCP(write_ptr, write_info_ptr, name, compression_type,
                      profile, proflen);
      }
   }
#endif
#if defined(PNG_sRGB_SUPPORTED)
d650 1
a650 20
   {
      png_colorp palette;
      int num_palette;

      if (png_get_PLTE(read_ptr, read_info_ptr, &palette, &num_palette))
      {
         png_set_PLTE(write_ptr, write_info_ptr, palette, num_palette);
      }
   }
#if defined(PNG_bKGD_SUPPORTED)
   {
      png_color_16p background;

      if (png_get_bKGD(read_ptr, read_info_ptr, &background))
      {
         png_set_bKGD(write_ptr, write_info_ptr, background);
      }
   }
#endif
#if defined(PNG_hIST_SUPPORTED)
d660 1
a660 1
#if defined(PNG_oFFs_SUPPORTED)
d662 1
a662 1
      png_int_32 offset_x, offset_y;
d671 1
a671 1
#if defined(PNG_pCAL_SUPPORTED)
d686 1
a686 1
#if defined(PNG_pHYs_SUPPORTED)
a696 1
#if defined(PNG_sBIT_SUPPORTED)
d698 2
a699 1
      png_color_8p sig_bit;
d701 1
a701 1
      if (png_get_sBIT(read_ptr, read_info_ptr, &sig_bit))
d703 1
a703 1
         png_set_sBIT(write_ptr, write_info_ptr, sig_bit);
d706 1
a706 3
#endif
#if defined(PNG_sCAL_SUPPORTED)
#ifdef PNG_FLOATING_POINT_SUPPORTED
d708 1
a708 2
      int unit;
      double scal_width, scal_height;
d710 1
a710 2
      if (png_get_sCAL(read_ptr, read_info_ptr, &unit, &scal_width,
         &scal_height))
d712 1
a712 13
         png_set_sCAL(write_ptr, write_info_ptr, unit, scal_width, scal_height);
      }
   }
#else
#ifdef PNG_FIXED_POINT_SUPPORTED
   {
      int unit;
      png_charp scal_width, scal_height;

      if (png_get_sCAL_s(read_ptr, read_info_ptr, &unit, &scal_width,
          &scal_height))
      {
         png_set_sCAL_s(write_ptr, write_info_ptr, unit, scal_width, scal_height);
d716 2
a717 3
#endif
#endif
#if defined(PNG_TEXT_SUPPORTED)
d724 1
a724 1
         png_debug1(0, "Handling %d iTXt/tEXt/zTXt chunks\n", num_text);
d729 1
a729 1
#if defined(PNG_tIME_SUPPORTED)
d736 1
d738 1
d744 1
a745 1
      }
d748 1
a748 1
#if defined(PNG_tRNS_SUPPORTED)
a761 19
#if defined(PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED)
   {
      png_unknown_chunkp unknowns;
      int num_unknowns = (int)png_get_unknown_chunks(read_ptr, read_info_ptr,
         &unknowns);
      if (num_unknowns)
      {
         png_size_t i;
         png_set_unknown_chunks(write_ptr, write_info_ptr, unknowns,
           num_unknowns);
         /* copy the locations from the read_info_ptr.  The automatically
            generated locations in write_info_ptr are wrong because we
            haven't written anything yet */
         for (i = 0; i < (png_size_t)num_unknowns; i++)
           png_set_unknown_chunk_location(write_ptr, write_info_ptr, i,
             unknowns[i].location);
      }
   }
#endif
a762 1
#ifdef PNG_WRITE_SUPPORTED
a763 4

/* If we wanted, we could write info in two steps:
   png_write_info_before_PLTE(write_ptr, write_info_ptr);
 */
a764 1
#endif
d766 2
a767 3
#ifdef SINGLE_ROWBUF_ALLOC
   png_debug(0, "\nAllocating row buffer...");
   row_buf = (png_bytep)png_malloc(read_ptr,
d769 9
a777 2
   png_debug1(0, "0x%08lx\n\n", (unsigned long)row_buf);
#endif /* SINGLE_ROWBUF_ALLOC */
a779 2
#if defined(PNG_READ_INTERLACING_SUPPORTED) || \
  defined(PNG_WRITE_INTERLACING_SUPPORTED)
a780 1
#  ifdef PNG_WRITE_SUPPORTED
a781 4
#  endif
#else
   num_pass=1;
#endif
a782 5
#ifdef PNGTEST_TIMING
   t_stop = (float)clock();
   t_misc += (t_stop - t_start);
   t_start = t_stop;
#endif
d788 1
a788 15
#ifndef SINGLE_ROWBUF_ALLOC
         png_debug2(0, "\nAllocating row buffer (pass %d, y = %ld)...", pass,y);
         row_buf = (png_bytep)png_malloc(read_ptr,
            png_get_rowbytes(read_ptr, read_info_ptr));
         png_debug2(0, "0x%08lx (%ld bytes)\n", (unsigned long)row_buf,
            png_get_rowbytes(read_ptr, read_info_ptr));
#endif /* !SINGLE_ROWBUF_ALLOC */
         png_read_rows(read_ptr, (png_bytepp)&row_buf, png_bytepp_NULL, 1);

#ifdef PNG_WRITE_SUPPORTED
#ifdef PNGTEST_TIMING
         t_stop = (float)clock();
         t_decode += (t_stop - t_start);
         t_start = t_stop;
#endif
a789 11
#ifdef PNGTEST_TIMING
         t_stop = (float)clock();
         t_encode += (t_stop - t_start);
         t_start = t_stop;
#endif
#endif /* PNG_WRITE_SUPPORTED */

#ifndef SINGLE_ROWBUF_ALLOC
         png_debug2(0, "Freeing row buffer (pass %d, y = %ld)\n\n", pass, y);
         png_free(read_ptr, row_buf);
#endif /* !SINGLE_ROWBUF_ALLOC */
a792 7
#if defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
   png_free_data(read_ptr, read_info_ptr, PNG_FREE_UNKN, -1);
#endif
#if defined(PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED)
   png_free_data(write_ptr, write_info_ptr, PNG_FREE_UNKN, -1);
#endif

a793 1

d795 2
a796 53
#if defined(PNG_TEXT_SUPPORTED)
   {
      png_textp text_ptr;
      int num_text;

      if (png_get_text(read_ptr, end_info_ptr, &text_ptr, &num_text) > 0)
      {
         png_debug1(0, "Handling %d iTXt/tEXt/zTXt chunks\n", num_text);
         png_set_text(write_ptr, write_end_info_ptr, text_ptr, num_text);
      }
   }
#endif
#if defined(PNG_tIME_SUPPORTED)
   {
      png_timep mod_time;

      if (png_get_tIME(read_ptr, end_info_ptr, &mod_time))
      {
         png_set_tIME(write_ptr, write_end_info_ptr, mod_time);
#if defined(PNG_TIME_RFC1123_SUPPORTED)
         /* we have to use png_strcpy instead of "=" because the string
            pointed to by png_convert_to_rfc1123() gets free'ed before
            we use it */
         png_strcpy(tIME_string,png_convert_to_rfc1123(read_ptr, mod_time));
         tIME_chunk_present++;
#endif /* PNG_TIME_RFC1123_SUPPORTED */
      }
   }
#endif
#if defined(PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED)
   {
      png_unknown_chunkp unknowns;
      int num_unknowns;
      num_unknowns = (int)png_get_unknown_chunks(read_ptr, end_info_ptr,
         &unknowns);
      if (num_unknowns)
      {
         png_size_t i;
         png_set_unknown_chunks(write_ptr, write_end_info_ptr, unknowns,
           num_unknowns);
         /* copy the locations from the read_info_ptr.  The automatically
            generated locations in write_end_info_ptr are wrong because we
            haven't written the end_info yet */
         for (i = 0; i < (png_size_t)num_unknowns; i++)
           png_set_unknown_chunk_location(write_ptr, write_end_info_ptr, i,
             unknowns[i].location);
      }
   }
#endif
#ifdef PNG_WRITE_SUPPORTED
   png_write_end(write_ptr, write_end_info_ptr);
#endif

a808 2
#ifdef SINGLE_ROWBUF_ALLOC
   png_debug(1, "destroying row_buf for read_ptr\n");
a809 3
   row_buf=NULL;
#endif /* SINGLE_ROWBUF_ALLOC */
   png_debug(1, "destroying read_ptr, read_info_ptr, end_info_ptr\n");
a810 4
#ifdef PNG_WRITE_SUPPORTED
   png_debug(1, "destroying write_end_info_ptr\n");
   png_destroy_info_struct(write_ptr, &write_end_info_ptr);
   png_debug(1, "destroying write_ptr, write_info_ptr\n");
a811 2
#endif
   png_debug(0, "Destruction complete.\n");
d813 2
a814 2
   FCLOSE(fpin);
   FCLOSE(fpout);
a816 4
#if defined(_WIN32_WCE)
   MultiByteToWideChar(CP_ACP, 0, inname, -1, path, MAX_PATH);
   if ((fpin = CreateFile(path, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL)) == INVALID_HANDLE_VALUE)
#else
a817 1
#endif
a822 4
#if defined(_WIN32_WCE)
   MultiByteToWideChar(CP_ACP, 0, outname, -1, path, MAX_PATH);
   if ((fpout = CreateFile(path, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL)) == INVALID_HANDLE_VALUE)
#else
a823 1
#endif
d826 1
a826 1
      FCLOSE(fpin);
d834 2
a835 2
      READFILE(fpin, inbuf, 1, num_in);
      READFILE(fpout, outbuf, 1, num_out);
d839 1
a839 1
         fprintf(STDERR, "\nFiles %s and %s are of a different size\n",
d844 1
a844 2
         "   Was %s written with the same maximum IDAT chunk size (%d bytes),",
              inname,PNG_ZBUF_SIZE);
d846 1
a846 1
              "\n   filtering heuristic (libpng default), compression");
d848 1
a848 1
              " level (zlib default),\n   and zlib version (%s)?\n\n",
d852 2
a853 2
         FCLOSE(fpin);
         FCLOSE(fpout);
d862 1
a862 1
         fprintf(STDERR, "\nFiles %s and %s are different\n", inname, outname);
d866 1
a866 2
         "   Was %s written with the same maximum IDAT chunk size (%d bytes),",
                 inname,PNG_ZBUF_SIZE);
d868 1
a868 1
              "\n   filtering heuristic (libpng default), compression");
d870 1
a870 1
              " level (zlib default),\n   and zlib version (%s)?\n\n",
d874 2
a875 2
         FCLOSE(fpin);
         FCLOSE(fpout);
d880 2
a881 2
   FCLOSE(fpin);
   FCLOSE(fpout);
d888 2
a889 2
static PNG_CONST char *inname = "pngtest/png";
static PNG_CONST char *outname = "pngout/png";
d891 2
a892 2
static PNG_CONST char *inname = "pngtest.png";
static PNG_CONST char *outname = "pngout.png";
a902 9
   fprintf(STDERR,"%s",png_get_copyright(NULL));
   /* Show the version of libpng used in building the library */
   fprintf(STDERR," library (%lu):%s", png_access_version_number(),
      png_get_header_version(NULL));
   /* Show the version of libpng used in building the application */
   fprintf(STDERR," pngtest (%lu):%s", (unsigned long)PNG_LIBPNG_VER,
      PNG_HEADER_VERSION_STRING);
   fprintf(STDERR," sizeof(png_struct)=%ld, sizeof(png_info)=%ld\n",
                    (long)sizeof(png_struct), (long)sizeof(png_info));
a974 3
#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
         int k;
#endif
d978 1
a978 1
         if (kerror == 0)
d981 1
a981 1
            fprintf(STDERR, "\n PASS (%lu zero samples)\n",zero_samples);
d984 1
a984 7
#endif
#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
            for (k=0; k<256; k++)
               if(filters_used[k])
                  fprintf(STDERR, " Filter %d was used %lu times\n",
                     k,filters_used[k]);
#endif
d1000 1
a1000 2
         if (current_allocation != 0)
         {
d1005 2
a1006 4
            while (pinfo != NULL)
            {
               fprintf(STDERR, " %lu bytes at %x\n", pinfo->size, 
                 (unsigned int) pinfo->pointer);
d1008 1
a1008 1
            }
d1013 1
a1013 3
         fprintf(STDERR, " Current memory allocation: %10d bytes\n",
            current_allocation);
         fprintf(STDERR, " Maximum memory allocation: %10d bytes\n",
a1014 4
         fprintf(STDERR, " Total   memory allocation: %10d bytes\n",
            total_allocation);
         fprintf(STDERR, "     Number of allocations: %10d\n",
            num_allocations);
d1020 1
a1020 2
      for (i=0; i<3; ++i)
      {
a1033 3
#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
                int k;
#endif
d1035 1
a1035 1
                fprintf(STDERR, "\n PASS (%lu zero samples)\n",zero_samples);
a1038 6
#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
                for (k=0; k<256; k++)
                   if(filters_used[k])
                      fprintf(STDERR, " Filter %d was used %lu times\n",
                         k,filters_used[k]);
#endif
d1040 2
a1041 2
             if(tIME_chunk_present != 0)
                fprintf(STDERR, " tIME = %s\n",tIME_string);
d1056 1
a1056 2
         if (current_allocation != 0)
         {
d1058 1
a1058 1

d1061 2
a1062 4
             while (pinfo != NULL)
             {
                fprintf(STDERR," %lu bytes at %x\n",
                   pinfo->size, (unsigned int)pinfo->pointer);
d1069 1
a1069 3
       fprintf(STDERR, " Current memory allocation: %10d bytes\n",
          current_allocation);
       fprintf(STDERR, " Maximum memory allocation: %10d bytes\n",
a1070 4
       fprintf(STDERR, " Total   memory allocation: %10d bytes\n",
          total_allocation);
       fprintf(STDERR, "     Number of allocations: %10d\n",
            num_allocations);
a1073 14
#ifdef PNGTEST_TIMING
   t_stop = (float)clock();
   t_misc += (t_stop - t_start);
   t_start = t_stop;
   fprintf(STDERR," CPU time used = %.3f seconds",
      (t_misc+t_decode+t_encode)/(float)CLOCKS_PER_SEC);
   fprintf(STDERR," (decoding %.3f,\n",
      t_decode/(float)CLOCKS_PER_SEC);
   fprintf(STDERR,"        encoding %.3f ,",
      t_encode/(float)CLOCKS_PER_SEC);
   fprintf(STDERR," other %.3f seconds)\n\n",
      t_misc/(float)CLOCKS_PER_SEC);
#endif

a1080 2
/* Generate a compiler error if there is an old png.h in the search path. */
typedef version_1_2_5 your_png_h_is_not_version_1_2_5;
@


1.1
log
@Initial revision
@
text
@d45 1
a45 1
int test_one_file PNGARG((PNG_CONST char *inname, PNG_CONST char *outname));
d345 1
a345 1
   PNG_CONST char *name = "UNKNOWN (ERROR!)";
d464 1
a464 1
test_one_file(PNG_CONST char *inname, PNG_CONST char *outname)
d888 2
a889 2
PNG_CONST char *inname = "pngtest/png";
PNG_CONST char *outname = "pngout/png";
d891 2
a892 2
static PNG_CONST char *inname = "pngtest.png";
static PNG_CONST char *outname = "pngout.png";
@


1.1.1.1
log
@libpng 1.0.2
@
text
@@
