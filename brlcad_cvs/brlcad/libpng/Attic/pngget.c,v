head	1.3;
access;
symbols
	ansi-20040405-merged:1.1.1.1.6.1
	postmerge-20040405-ansi:1.2
	premerge-20040404-ansi:1.2
	postmerge-autoconf:1.2
	autoconf-freeze:1.2
	premerge-autoconf:1.2
	ansi-20040316-freeze:1.1.1.1
	postmerge-20040315-windows:1.2
	premerge-20040315-windows:1.2
	windows-20040315-freeze:1.1.1.1.8.1
	autoconf-20031203:1.2
	autoconf-20031202:1.2
	autoconf-branch:1.2.0.6
	phong-branch:1.2.0.4
	photonmap-branch:1.2.0.2
	rel-6-1-DP:1.1.1.1
	windows-branch:1.1.1.1.0.8
	rel-6-0-2:1.1.1.1
	ansi-branch:1.1.1.1.0.6
	rel-6-0-1-branch:1.1.1.1.0.4
	hartley-6-0-post:1.1.1.1
	hartley-6-0-pre:1.1.1.1
	rel-6-0-1:1.1.1.1
	rel-6-0:1.1.1.1
	rel-5-4:1.1.1.1
	offsite-5-3-pre:1.1.1.1
	rel-5-3:1.1.1.1
	rel-5-2:1.1.1.1
	rel-5-1-branch:1.1.1.1.0.2
	rel-5-1:1.1.1.1
	rel-5-0:1.1.1.1
	rel-5-0-beta:1.1.1.1
	libpng_1_0_2:1.1.1.1
	libpng:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2004.05.21.18.05.27;	author morrison;	state dead;
branches;
next	1.2;

1.2
date	2002.12.26.14.39.09;	author jra;	state Exp;
branches;
next	1.1;

1.1
date	98.06.24.20.00.14;	author jra;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.06.24.20.00.14;	author jra;	state Exp;
branches
	1.1.1.1.6.1
	1.1.1.1.8.1;
next	;

1.1.1.1.6.1
date	2004.03.17.21.18.35;	author morrison;	state Exp;
branches;
next	;

1.1.1.1.8.1
date	2004.03.11.23.43.20;	author morrison;	state Exp;
branches;
next	;


desc
@@


1.3
log
@moved from top-level to src/other/.
@
text
@
/* pngget.c - retrieval of values from info struct
 *
 * libpng 1.2.5 - October 3, 2002
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1998-2002 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 */

#define PNG_INTERNAL
#include "png.h"

png_uint_32 PNGAPI
png_get_valid(png_structp png_ptr, png_infop info_ptr, png_uint_32 flag)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return(info_ptr->valid & flag);
   else
      return(0);
}

png_uint_32 PNGAPI
png_get_rowbytes(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return(info_ptr->rowbytes);
   else
      return(0);
}

#if defined(PNG_INFO_IMAGE_SUPPORTED)
png_bytepp PNGAPI
png_get_rows(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return(info_ptr->row_pointers);
   else
      return(0);
}
#endif

#ifdef PNG_EASY_ACCESS_SUPPORTED
/* easy access to info, added in libpng-0.99 */
png_uint_32 PNGAPI
png_get_image_width(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
   {
      return info_ptr->width;
   }
   return (0);
}

png_uint_32 PNGAPI
png_get_image_height(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
   {
      return info_ptr->height;
   }
   return (0);
}

png_byte PNGAPI
png_get_bit_depth(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
   {
      return info_ptr->bit_depth;
   }
   return (0);
}

png_byte PNGAPI
png_get_color_type(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
   {
      return info_ptr->color_type;
   }
   return (0);
}

png_byte PNGAPI
png_get_filter_type(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
   {
      return info_ptr->filter_type;
   }
   return (0);
}

png_byte PNGAPI
png_get_interlace_type(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
   {
      return info_ptr->interlace_type;
   }
   return (0);
}

png_byte PNGAPI
png_get_compression_type(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
   {
      return info_ptr->compression_type;
   }
   return (0);
}

png_uint_32 PNGAPI
png_get_x_pixels_per_meter(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_pHYs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_pHYs)
   {
      png_debug1(1, "in %s retrieval function\n", "png_get_x_pixels_per_meter");
      if(info_ptr->phys_unit_type != PNG_RESOLUTION_METER)
          return (0);
      else return (info_ptr->x_pixels_per_unit);
   }
#else
   return (0);
#endif
   return (0);
}

png_uint_32 PNGAPI
png_get_y_pixels_per_meter(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_pHYs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_pHYs)
   {
      png_debug1(1, "in %s retrieval function\n", "png_get_y_pixels_per_meter");
      if(info_ptr->phys_unit_type != PNG_RESOLUTION_METER)
          return (0);
      else return (info_ptr->y_pixels_per_unit);
   }
#else
   return (0);
#endif
   return (0);
}

png_uint_32 PNGAPI
png_get_pixels_per_meter(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_pHYs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_pHYs)
   {
      png_debug1(1, "in %s retrieval function\n", "png_get_pixels_per_meter");
      if(info_ptr->phys_unit_type != PNG_RESOLUTION_METER ||
         info_ptr->x_pixels_per_unit != info_ptr->y_pixels_per_unit)
          return (0);
      else return (info_ptr->x_pixels_per_unit);
   }
#else
   return (0);
#endif
   return (0);
}

#ifdef PNG_FLOATING_POINT_SUPPORTED
float PNGAPI
png_get_pixel_aspect_ratio(png_structp png_ptr, png_infop info_ptr)
   {
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_pHYs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_pHYs)
   {
      png_debug1(1, "in %s retrieval function\n", "png_get_aspect_ratio");
      if (info_ptr->x_pixels_per_unit == 0)
         return ((float)0.0);
      else
         return ((float)((float)info_ptr->y_pixels_per_unit
            /(float)info_ptr->x_pixels_per_unit));
   }
#else
   return (0.0);
#endif
   return ((float)0.0);
}
#endif

png_int_32 PNGAPI
png_get_x_offset_microns(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_oFFs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_oFFs)
   {
      png_debug1(1, "in %s retrieval function\n", "png_get_x_offset_microns");
      if(info_ptr->offset_unit_type != PNG_OFFSET_MICROMETER)
          return (0);
      else return (info_ptr->x_offset);
   }
#else
   return (0);
#endif
   return (0);
}

png_int_32 PNGAPI
png_get_y_offset_microns(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_oFFs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_oFFs)
   {
      png_debug1(1, "in %s retrieval function\n", "png_get_y_offset_microns");
      if(info_ptr->offset_unit_type != PNG_OFFSET_MICROMETER)
          return (0);
      else return (info_ptr->y_offset);
   }
#else
   return (0);
#endif
   return (0);
}

png_int_32 PNGAPI
png_get_x_offset_pixels(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_oFFs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_oFFs)
   {
      png_debug1(1, "in %s retrieval function\n", "png_get_x_offset_microns");
      if(info_ptr->offset_unit_type != PNG_OFFSET_PIXEL)
          return (0);
      else return (info_ptr->x_offset);
   }
#else
   return (0);
#endif
   return (0);
}

png_int_32 PNGAPI
png_get_y_offset_pixels(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_oFFs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_oFFs)
   {
      png_debug1(1, "in %s retrieval function\n", "png_get_y_offset_microns");
      if(info_ptr->offset_unit_type != PNG_OFFSET_PIXEL)
          return (0);
      else return (info_ptr->y_offset);
   }
#else
   return (0);
#endif
   return (0);
}

#if defined(PNG_INCH_CONVERSIONS) && defined(PNG_FLOATING_POINT_SUPPORTED)
png_uint_32 PNGAPI
png_get_pixels_per_inch(png_structp png_ptr, png_infop info_ptr)
{
   return ((png_uint_32)((float)png_get_pixels_per_meter(png_ptr, info_ptr)
     *.0254 +.5));
}

png_uint_32 PNGAPI
png_get_x_pixels_per_inch(png_structp png_ptr, png_infop info_ptr)
{
   return ((png_uint_32)((float)png_get_x_pixels_per_meter(png_ptr, info_ptr)
     *.0254 +.5));
}

png_uint_32 PNGAPI
png_get_y_pixels_per_inch(png_structp png_ptr, png_infop info_ptr)
{
   return ((png_uint_32)((float)png_get_y_pixels_per_meter(png_ptr, info_ptr)
     *.0254 +.5));
}

float PNGAPI
png_get_x_offset_inches(png_structp png_ptr, png_infop info_ptr)
{
   return ((float)png_get_x_offset_microns(png_ptr, info_ptr)
     *.00003937);
}

float PNGAPI
png_get_y_offset_inches(png_structp png_ptr, png_infop info_ptr)
{
   return ((float)png_get_y_offset_microns(png_ptr, info_ptr)
     *.00003937);
}

#if defined(PNG_pHYs_SUPPORTED)
png_uint_32 PNGAPI
png_get_pHYs_dpi(png_structp png_ptr, png_infop info_ptr,
   png_uint_32 *res_x, png_uint_32 *res_y, int *unit_type)
{
   png_uint_32 retval = 0;

   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs))
   {
      png_debug1(1, "in %s retrieval function\n", "pHYs");
      if (res_x != NULL)
      {
         *res_x = info_ptr->x_pixels_per_unit;
         retval |= PNG_INFO_pHYs;
      }
      if (res_y != NULL)
      {
         *res_y = info_ptr->y_pixels_per_unit;
         retval |= PNG_INFO_pHYs;
      }
      if (unit_type != NULL)
      {
         *unit_type = (int)info_ptr->phys_unit_type;
         retval |= PNG_INFO_pHYs;
         if(*unit_type == 1)
         {
            if (res_x != NULL) *res_x = (png_uint_32)(*res_x * .0254 + .50);
            if (res_y != NULL) *res_y = (png_uint_32)(*res_y * .0254 + .50);
         }
      }
   }
   return (retval);
}
#endif /* PNG_pHYs_SUPPORTED */
#endif  /* PNG_INCH_CONVERSIONS && PNG_FLOATING_POINT_SUPPORTED */

/* png_get_channels really belongs in here, too, but it's been around longer */

#endif  /* PNG_EASY_ACCESS_SUPPORTED */

png_byte PNGAPI
png_get_channels(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return(info_ptr->channels);
   else
      return (0);
}

png_bytep PNGAPI
png_get_signature(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return(info_ptr->signature);
   else
      return (NULL);
}

#if defined(PNG_bKGD_SUPPORTED)
png_uint_32 PNGAPI
png_get_bKGD(png_structp png_ptr, png_infop info_ptr,
   png_color_16p *background)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_bKGD)
      && background != NULL)
   {
      png_debug1(1, "in %s retrieval function\n", "bKGD");
      *background = &(info_ptr->background);
      return (PNG_INFO_bKGD);
   }
   return (0);
}
#endif

#if defined(PNG_cHRM_SUPPORTED)
#ifdef PNG_FLOATING_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_cHRM(png_structp png_ptr, png_infop info_ptr,
   double *white_x, double *white_y, double *red_x, double *red_y,
   double *green_x, double *green_y, double *blue_x, double *blue_y)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM))
   {
      png_debug1(1, "in %s retrieval function\n", "cHRM");
      if (white_x != NULL)
         *white_x = (double)info_ptr->x_white;
      if (white_y != NULL)
         *white_y = (double)info_ptr->y_white;
      if (red_x != NULL)
         *red_x = (double)info_ptr->x_red;
      if (red_y != NULL)
         *red_y = (double)info_ptr->y_red;
      if (green_x != NULL)
         *green_x = (double)info_ptr->x_green;
      if (green_y != NULL)
         *green_y = (double)info_ptr->y_green;
      if (blue_x != NULL)
         *blue_x = (double)info_ptr->x_blue;
      if (blue_y != NULL)
         *blue_y = (double)info_ptr->y_blue;
      return (PNG_INFO_cHRM);
   }
   return (0);
}
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_cHRM_fixed(png_structp png_ptr, png_infop info_ptr,
   png_fixed_point *white_x, png_fixed_point *white_y, png_fixed_point *red_x,
   png_fixed_point *red_y, png_fixed_point *green_x, png_fixed_point *green_y,
   png_fixed_point *blue_x, png_fixed_point *blue_y)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM))
   {
      png_debug1(1, "in %s retrieval function\n", "cHRM");
      if (white_x != NULL)
         *white_x = info_ptr->int_x_white;
      if (white_y != NULL)
         *white_y = info_ptr->int_y_white;
      if (red_x != NULL)
         *red_x = info_ptr->int_x_red;
      if (red_y != NULL)
         *red_y = info_ptr->int_y_red;
      if (green_x != NULL)
         *green_x = info_ptr->int_x_green;
      if (green_y != NULL)
         *green_y = info_ptr->int_y_green;
      if (blue_x != NULL)
         *blue_x = info_ptr->int_x_blue;
      if (blue_y != NULL)
         *blue_y = info_ptr->int_y_blue;
      return (PNG_INFO_cHRM);
   }
   return (0);
}
#endif
#endif

#if defined(PNG_gAMA_SUPPORTED)
#ifdef PNG_FLOATING_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_gAMA(png_structp png_ptr, png_infop info_ptr, double *file_gamma)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA)
      && file_gamma != NULL)
   {
      png_debug1(1, "in %s retrieval function\n", "gAMA");
      *file_gamma = (double)info_ptr->gamma;
      return (PNG_INFO_gAMA);
   }
   return (0);
}
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_gAMA_fixed(png_structp png_ptr, png_infop info_ptr,
    png_fixed_point *int_file_gamma)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA)
      && int_file_gamma != NULL)
   {
      png_debug1(1, "in %s retrieval function\n", "gAMA");
      *int_file_gamma = info_ptr->int_gamma;
      return (PNG_INFO_gAMA);
   }
   return (0);
}
#endif
#endif

#if defined(PNG_sRGB_SUPPORTED)
png_uint_32 PNGAPI
png_get_sRGB(png_structp png_ptr, png_infop info_ptr, int *file_srgb_intent)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_sRGB)
      && file_srgb_intent != NULL)
   {
      png_debug1(1, "in %s retrieval function\n", "sRGB");
      *file_srgb_intent = (int)info_ptr->srgb_intent;
      return (PNG_INFO_sRGB);
   }
   return (0);
}
#endif

#if defined(PNG_iCCP_SUPPORTED)
png_uint_32 PNGAPI
png_get_iCCP(png_structp png_ptr, png_infop info_ptr,
             png_charpp name, int *compression_type,
             png_charpp profile, png_uint_32 *proflen)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_iCCP)
      && name != NULL && profile != NULL && proflen != NULL)
   {
      png_debug1(1, "in %s retrieval function\n", "iCCP");
      *name = info_ptr->iccp_name;
      *profile = info_ptr->iccp_profile;
      /* compression_type is a dummy so the API won't have to change
         if we introduce multiple compression types later. */
      *proflen = (int)info_ptr->iccp_proflen;
      *compression_type = (int)info_ptr->iccp_compression;
      return (PNG_INFO_iCCP);
   }
   return (0);
}
#endif

#if defined(PNG_sPLT_SUPPORTED)
png_uint_32 PNGAPI
png_get_sPLT(png_structp png_ptr, png_infop info_ptr,
             png_sPLT_tpp spalettes)
{
   if (png_ptr != NULL && info_ptr != NULL && spalettes != NULL)
     *spalettes = info_ptr->splt_palettes;
   return ((png_uint_32)info_ptr->splt_palettes_num);
}
#endif

#if defined(PNG_hIST_SUPPORTED)
png_uint_32 PNGAPI
png_get_hIST(png_structp png_ptr, png_infop info_ptr, png_uint_16p *hist)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_hIST)
      && hist != NULL)
   {
      png_debug1(1, "in %s retrieval function\n", "hIST");
      *hist = info_ptr->hist;
      return (PNG_INFO_hIST);
   }
   return (0);
}
#endif

png_uint_32 PNGAPI
png_get_IHDR(png_structp png_ptr, png_infop info_ptr,
   png_uint_32 *width, png_uint_32 *height, int *bit_depth,
   int *color_type, int *interlace_type, int *compression_type,
   int *filter_type)

{
   if (png_ptr != NULL && info_ptr != NULL && width != NULL && height != NULL &&
      bit_depth != NULL && color_type != NULL)
   {
      int pixel_depth, channels;
      png_uint_32 rowbytes_per_pixel;

      png_debug1(1, "in %s retrieval function\n", "IHDR");
      *width = info_ptr->width;
      *height = info_ptr->height;
      *bit_depth = info_ptr->bit_depth;
      if (info_ptr->bit_depth < 1 || info_ptr->bit_depth > 16)
        png_error(png_ptr, "Invalid bit depth");
      *color_type = info_ptr->color_type;
      if (info_ptr->color_type > 6)
        png_error(png_ptr, "Invalid color type");
      if (compression_type != NULL)
         *compression_type = info_ptr->compression_type;
      if (filter_type != NULL)
         *filter_type = info_ptr->filter_type;
      if (interlace_type != NULL)
         *interlace_type = info_ptr->interlace_type;

      /* check for potential overflow of rowbytes */
      if (*color_type == PNG_COLOR_TYPE_PALETTE)
         channels = 1;
      else if (*color_type & PNG_COLOR_MASK_COLOR)
         channels = 3;
      else
         channels = 1;
      if (*color_type & PNG_COLOR_MASK_ALPHA)
         channels++;
      pixel_depth = *bit_depth * channels;
      rowbytes_per_pixel = (pixel_depth + 7) >> 3;
      if (width == 0 || *width > PNG_MAX_UINT)
        png_error(png_ptr, "Invalid image width");
      if (height == 0 || *height > PNG_MAX_UINT)
        png_error(png_ptr, "Invalid image height");
      if (*width > PNG_MAX_UINT/rowbytes_per_pixel - 64)
      {
         png_error(png_ptr,
            "Width too large for libpng to process image data.");
      }
      return (1);
   }
   return (0);
}

#if defined(PNG_oFFs_SUPPORTED)
png_uint_32 PNGAPI
png_get_oFFs(png_structp png_ptr, png_infop info_ptr,
   png_int_32 *offset_x, png_int_32 *offset_y, int *unit_type)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs)
      && offset_x != NULL && offset_y != NULL && unit_type != NULL)
   {
      png_debug1(1, "in %s retrieval function\n", "oFFs");
      *offset_x = info_ptr->x_offset;
      *offset_y = info_ptr->y_offset;
      *unit_type = (int)info_ptr->offset_unit_type;
      return (PNG_INFO_oFFs);
   }
   return (0);
}
#endif

#if defined(PNG_pCAL_SUPPORTED)
png_uint_32 PNGAPI
png_get_pCAL(png_structp png_ptr, png_infop info_ptr,
   png_charp *purpose, png_int_32 *X0, png_int_32 *X1, int *type, int *nparams,
   png_charp *units, png_charpp *params)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_pCAL)
      && purpose != NULL && X0 != NULL && X1 != NULL && type != NULL &&
      nparams != NULL && units != NULL && params != NULL)
   {
      png_debug1(1, "in %s retrieval function\n", "pCAL");
      *purpose = info_ptr->pcal_purpose;
      *X0 = info_ptr->pcal_X0;
      *X1 = info_ptr->pcal_X1;
      *type = (int)info_ptr->pcal_type;
      *nparams = (int)info_ptr->pcal_nparams;
      *units = info_ptr->pcal_units;
      *params = info_ptr->pcal_params;
      return (PNG_INFO_pCAL);
   }
   return (0);
}
#endif

#if defined(PNG_sCAL_SUPPORTED)
#ifdef PNG_FLOATING_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_sCAL(png_structp png_ptr, png_infop info_ptr,
             int *unit, double *width, double *height)
{
    if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_sCAL))
    {
        *unit = info_ptr->scal_unit;
        *width = info_ptr->scal_pixel_width;
        *height = info_ptr->scal_pixel_height;
        return (PNG_INFO_sCAL);
    }
    return(0);
}
#else
#ifdef PNG_FIXED_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_sCAL_s(png_structp png_ptr, png_infop info_ptr,
             int *unit, png_charpp width, png_charpp height)
{
    if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_sCAL))
    {
        *unit = info_ptr->scal_unit;
        *width = info_ptr->scal_s_width;
        *height = info_ptr->scal_s_height;
        return (PNG_INFO_sCAL);
    }
    return(0);
}
#endif
#endif
#endif

#if defined(PNG_pHYs_SUPPORTED)
png_uint_32 PNGAPI
png_get_pHYs(png_structp png_ptr, png_infop info_ptr,
   png_uint_32 *res_x, png_uint_32 *res_y, int *unit_type)
{
   png_uint_32 retval = 0;

   if (png_ptr != NULL && info_ptr != NULL &&
      (info_ptr->valid & PNG_INFO_pHYs))
   {
      png_debug1(1, "in %s retrieval function\n", "pHYs");
      if (res_x != NULL)
      {
         *res_x = info_ptr->x_pixels_per_unit;
         retval |= PNG_INFO_pHYs;
      }
      if (res_y != NULL)
      {
         *res_y = info_ptr->y_pixels_per_unit;
         retval |= PNG_INFO_pHYs;
      }
      if (unit_type != NULL)
      {
         *unit_type = (int)info_ptr->phys_unit_type;
         retval |= PNG_INFO_pHYs;
      }
   }
   return (retval);
}
#endif

png_uint_32 PNGAPI
png_get_PLTE(png_structp png_ptr, png_infop info_ptr, png_colorp *palette,
   int *num_palette)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_PLTE)
       && palette != NULL)
   {
      png_debug1(1, "in %s retrieval function\n", "PLTE");
      *palette = info_ptr->palette;
      *num_palette = info_ptr->num_palette;
      png_debug1(3, "num_palette = %d\n", *num_palette);
      return (PNG_INFO_PLTE);
   }
   return (0);
}

#if defined(PNG_sBIT_SUPPORTED)
png_uint_32 PNGAPI
png_get_sBIT(png_structp png_ptr, png_infop info_ptr, png_color_8p *sig_bit)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_sBIT)
      && sig_bit != NULL)
   {
      png_debug1(1, "in %s retrieval function\n", "sBIT");
      *sig_bit = &(info_ptr->sig_bit);
      return (PNG_INFO_sBIT);
   }
   return (0);
}
#endif

#if defined(PNG_TEXT_SUPPORTED)
png_uint_32 PNGAPI
png_get_text(png_structp png_ptr, png_infop info_ptr, png_textp *text_ptr,
   int *num_text)
{
   if (png_ptr != NULL && info_ptr != NULL && info_ptr->num_text > 0)
   {
      png_debug1(1, "in %s retrieval function\n",
         (png_ptr->chunk_name[0] == '\0' ? "text"
             : (png_const_charp)png_ptr->chunk_name));
      if (text_ptr != NULL)
         *text_ptr = info_ptr->text;
      if (num_text != NULL)
         *num_text = info_ptr->num_text;
      return ((png_uint_32)info_ptr->num_text);
   }
   if (num_text != NULL)
     *num_text = 0;
   return(0);
}
#endif

#if defined(PNG_tIME_SUPPORTED)
png_uint_32 PNGAPI
png_get_tIME(png_structp png_ptr, png_infop info_ptr, png_timep *mod_time)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_tIME)
       && mod_time != NULL)
   {
      png_debug1(1, "in %s retrieval function\n", "tIME");
      *mod_time = &(info_ptr->mod_time);
      return (PNG_INFO_tIME);
   }
   return (0);
}
#endif

#if defined(PNG_tRNS_SUPPORTED)
png_uint_32 PNGAPI
png_get_tRNS(png_structp png_ptr, png_infop info_ptr,
   png_bytep *trans, int *num_trans, png_color_16p *trans_values)
{
   png_uint_32 retval = 0;
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS))
   {
      png_debug1(1, "in %s retrieval function\n", "tRNS");
      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      {
          if (trans != NULL)
          {
             *trans = info_ptr->trans;
             retval |= PNG_INFO_tRNS;
          }
          if (trans_values != NULL)
             *trans_values = &(info_ptr->trans_values);
      }
      else /* if (info_ptr->color_type != PNG_COLOR_TYPE_PALETTE) */
      {
          if (trans_values != NULL)
          {
             *trans_values = &(info_ptr->trans_values);
             retval |= PNG_INFO_tRNS;
          }
          if(trans != NULL)
             *trans = NULL;
      }
      if(num_trans != NULL)
      {
         *num_trans = info_ptr->num_trans;
         retval |= PNG_INFO_tRNS;
      }
   }
   return (retval);
}
#endif

#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
png_uint_32 PNGAPI
png_get_unknown_chunks(png_structp png_ptr, png_infop info_ptr,
             png_unknown_chunkpp unknowns)
{
   if (png_ptr != NULL && info_ptr != NULL && unknowns != NULL)
     *unknowns = info_ptr->unknown_chunks;
   return ((png_uint_32)info_ptr->unknown_chunks_num);
}
#endif

#if defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
png_byte PNGAPI
png_get_rgb_to_gray_status (png_structp png_ptr)
{
   return (png_byte)(png_ptr? png_ptr->rgb_to_gray_status : 0);
}
#endif

#if defined(PNG_USER_CHUNKS_SUPPORTED)
png_voidp PNGAPI
png_get_user_chunk_ptr(png_structp png_ptr)
{
   return (png_ptr? png_ptr->user_chunk_ptr : NULL);
}
#endif


png_uint_32 PNGAPI
png_get_compression_buffer_size(png_structp png_ptr)
{
   return (png_uint_32)(png_ptr? png_ptr->zbuf_size : 0L);
}


#ifndef PNG_1_0_X
#ifdef PNG_ASSEMBLER_CODE_SUPPORTED
/* this function was added to libpng 1.2.0 and should exist by default */
png_uint_32 PNGAPI
png_get_asm_flags (png_structp png_ptr)
{
    return (png_uint_32)(png_ptr? png_ptr->asm_flags : 0L);
}

/* this function was added to libpng 1.2.0 and should exist by default */
png_uint_32 PNGAPI
png_get_asm_flagmask (int flag_select)
{
    png_uint_32 settable_asm_flags = 0;

    if (flag_select & PNG_SELECT_READ)
        settable_asm_flags |=
          PNG_ASM_FLAG_MMX_READ_COMBINE_ROW  |
          PNG_ASM_FLAG_MMX_READ_INTERLACE    |
          PNG_ASM_FLAG_MMX_READ_FILTER_SUB   |
          PNG_ASM_FLAG_MMX_READ_FILTER_UP    |
          PNG_ASM_FLAG_MMX_READ_FILTER_AVG   |
          PNG_ASM_FLAG_MMX_READ_FILTER_PAETH ;
          /* no non-MMX flags yet */

#if 0
    /* GRR:  no write-flags yet, either, but someday... */
    if (flag_select & PNG_SELECT_WRITE)
        settable_asm_flags |=
          PNG_ASM_FLAG_MMX_WRITE_ [whatever] ;
#endif /* 0 */

    return settable_asm_flags;  /* _theoretically_ settable capabilities only */
}
#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */


#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
    /* GRR:  could add this:   && defined(PNG_MMX_CODE_SUPPORTED) */
/* this function was added to libpng 1.2.0 */
png_uint_32 PNGAPI
png_get_mmx_flagmask (int flag_select, int *compilerID)
{
    png_uint_32 settable_mmx_flags = 0;

    if (flag_select & PNG_SELECT_READ)
        settable_mmx_flags |=
          PNG_ASM_FLAG_MMX_READ_COMBINE_ROW  |
          PNG_ASM_FLAG_MMX_READ_INTERLACE    |
          PNG_ASM_FLAG_MMX_READ_FILTER_SUB   |
          PNG_ASM_FLAG_MMX_READ_FILTER_UP    |
          PNG_ASM_FLAG_MMX_READ_FILTER_AVG   |
          PNG_ASM_FLAG_MMX_READ_FILTER_PAETH ;
#if 0
    /* GRR:  no MMX write support yet, but someday... */
    if (flag_select & PNG_SELECT_WRITE)
        settable_mmx_flags |=
          PNG_ASM_FLAG_MMX_WRITE_ [whatever] ;
#endif /* 0 */

    if (compilerID != NULL) {
#ifdef PNG_USE_PNGVCRD
        *compilerID = 1;    /* MSVC */
#else
#ifdef PNG_USE_PNGGCCRD
        *compilerID = 2;    /* gcc/gas */
#else
        *compilerID = -1;   /* unknown (i.e., no asm/MMX code compiled) */
#endif
#endif
    }

    return settable_mmx_flags;  /* _theoretically_ settable capabilities only */
}

/* this function was added to libpng 1.2.0 */
png_byte PNGAPI
png_get_mmx_bitdepth_threshold (png_structp png_ptr)
{
    return (png_byte)(png_ptr? png_ptr->mmx_bitdepth_threshold : 0);
}

/* this function was added to libpng 1.2.0 */
png_uint_32 PNGAPI
png_get_mmx_rowbytes_threshold (png_structp png_ptr)
{
    return (png_uint_32)(png_ptr? png_ptr->mmx_rowbytes_threshold : 0L);
}
#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
#endif /* PNG_1_0_X */
@


1.2
log
@Update to libpng 1.2.5
@
text
@@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
 * libpng 1.0.2 - June 14, 1998
d6 3
a8 3
 * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
 * Copyright (c) 1996, 1997 Andreas Dilger
 * Copyright (c) 1998, Glenn Randers-Pehrson
d14 1
a14 1
png_uint_32
d23 1
a23 1
png_uint_32
d32 11
d45 1
a45 1
png_uint_32
d55 1
a55 1
png_uint_32
d65 1
a65 1
png_byte
d75 1
a75 1
png_byte
d85 1
a85 1
png_byte
d95 1
a95 1
png_byte
d105 1
a105 1
png_byte
d115 1
a115 1
png_uint_32
d118 3
a120 2
#if defined(PNG_READ_pHYs_SUPPORTED) || defined(PNG_WRITE_pHYs_SUPPORTED)
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs))
d127 2
a128 1
   else
d133 1
a133 1
png_uint_32
d136 3
a138 2
#if defined(PNG_READ_pHYs_SUPPORTED) || defined(PNG_WRITE_pHYs_SUPPORTED)
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs))
d145 2
a146 1
   else
d151 1
a151 1
png_uint_32
d154 3
a156 2
#if defined(PNG_READ_pHYs_SUPPORTED) || defined(PNG_WRITE_pHYs_SUPPORTED)
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs))
d164 2
a165 1
   else
d170 2
a171 1
float
d174 3
a176 2
#if defined(PNG_READ_pHYs_SUPPORTED) || defined(PNG_WRITE_pHYs_SUPPORTED)
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs))
d182 2
a183 2
         return ((float)info_ptr->y_pixels_per_unit
            /(float)info_ptr->x_pixels_per_unit);
d185 2
a186 1
   else
d188 1
a188 1
      return ((float)0.0);
d190 1
d192 1
a192 1
png_uint_32
d195 3
a197 2
#if defined(PNG_READ_oFFs_SUPPORTED) || defined(PNG_WRITE_oFFs_SUPPORTED)
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs))
d204 2
a205 1
   else
d210 1
a210 1
png_uint_32
d213 3
a215 2
#if defined(PNG_READ_oFFs_SUPPORTED) || defined(PNG_WRITE_oFFs_SUPPORTED)
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs))
d222 2
a223 1
   else
d228 1
a228 1
png_uint_32
d231 3
a233 2
#if defined(PNG_READ_oFFs_SUPPORTED) || defined(PNG_WRITE_oFFs_SUPPORTED)
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs))
d240 2
a241 1
   else
d246 1
a246 1
png_uint_32
d249 3
a251 2
#if defined(PNG_READ_oFFs_SUPPORTED) || defined(PNG_WRITE_oFFs_SUPPORTED)
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs))
d258 2
a259 1
   else
d264 2
a265 2
#ifdef PNG_INCH_CONVERSIONS
png_uint_32
d269 1
a269 1
     *.03937 +.5)
d272 1
a272 1
png_uint_32
d276 1
a276 1
     *.03937 +.5)
d279 1
a279 1
png_uint_32
d283 1
a283 1
     *.03937 +.5)
d286 1
a286 1
float
d290 1
a290 1
     *.03937/1000000. +.5)
d293 1
a293 1
float
d297 1
a297 1
     *.03937/1000000. +.5)
d300 2
a301 2
#if defined(PNG_READ_pHYs_SUPPORTED)
png_uint_32
d307 1
a307 1
   if (png_ptr != NULL && info_ptr != NULL && info_ptr->valid & PNG_INFO_pHYs)
d324 1
a324 1
         if(unit_type == 1)
d326 2
a327 2
            if (res_x != NULL) *res_x = (png_uint_32)(*res_x * 39.37 + .50);
            if (res_y != NULL) *res_y = (png_uint_32)(*res_y * 39.37 + .50);
d333 2
a334 2
#endif /* PNG_READ_pHYs_SUPPORTED */
#endif  /* PNG_INCH_CONVERSIONS */
d340 1
a340 1
png_byte
d349 1
a349 1
png_bytep
d358 2
a359 2
#if defined(PNG_READ_bKGD_SUPPORTED)
png_uint_32
d374 3
a376 2
#if defined(PNG_READ_cHRM_SUPPORTED)
png_uint_32
d405 32
d438 3
a440 2
#if defined(PNG_READ_gAMA_SUPPORTED)
png_uint_32
d453 16
d470 2
a471 2
#if defined(PNG_READ_sRGB_SUPPORTED)
png_uint_32
d485 35
a519 2
#if defined(PNG_READ_hIST_SUPPORTED)
png_uint_32
d533 1
a533 1
png_uint_32
d538 1
a538 1
   
d550 2
d553 2
d573 5
a577 1
      if ((*width > (png_uint_32)2147483647L/rowbytes_per_pixel))
d579 1
a579 1
         png_warning(png_ptr,
d587 2
a588 2
#if defined(PNG_READ_oFFs_SUPPORTED)
png_uint_32
d590 1
a590 1
   png_uint_32 *offset_x, png_uint_32 *offset_y, int *unit_type)
d605 2
a606 2
#if defined(PNG_READ_pCAL_SUPPORTED)
png_uint_32
d611 2
a612 2
   if (png_ptr != NULL && info_ptr != NULL && info_ptr->valid & PNG_INFO_pCAL &&
      purpose != NULL && X0 != NULL && X1 != NULL && type != NULL &&
d629 38
a666 2
#if defined(PNG_READ_pHYs_SUPPORTED)
png_uint_32
d672 2
a673 1
   if (png_ptr != NULL && info_ptr != NULL && info_ptr->valid & PNG_INFO_pHYs)
d696 1
a696 1
png_uint_32
d700 2
a701 2
   if (png_ptr != NULL && info_ptr != NULL && info_ptr->valid & PNG_INFO_PLTE &&
       palette != NULL)
d712 2
a713 2
#if defined(PNG_READ_sBIT_SUPPORTED)
png_uint_32
d716 2
a717 2
   if (png_ptr != NULL && info_ptr != NULL && info_ptr->valid & PNG_INFO_sBIT &&
       sig_bit != NULL)
d727 2
a728 2
#if defined(PNG_READ_tEXt_SUPPORTED) || defined(PNG_READ_zTXt_SUPPORTED)
png_uint_32
d743 2
d749 2
a750 2
#if defined(PNG_READ_tIME_SUPPORTED)
png_uint_32
d753 2
a754 2
   if (png_ptr != NULL && info_ptr != NULL && info_ptr->valid & PNG_INFO_tIME &&
       mod_time != NULL)
d764 2
a765 2
#if defined(PNG_READ_tRNS_SUPPORTED)
png_uint_32
d770 1
a770 1
   if (png_ptr != NULL && info_ptr != NULL && info_ptr->valid & PNG_INFO_tRNS)
d803 125
@


1.1.1.1
log
@libpng 1.0.2
@
text
@@


1.1.1.1.6.1
log
@sync branch with HEAD
@
text
@d4 1
a4 1
 * libpng 1.2.5 - October 3, 2002
d6 3
a8 3
 * Copyright (c) 1998-2002 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
d14 1
a14 1
png_uint_32 PNGAPI
d23 1
a23 1
png_uint_32 PNGAPI
a31 11
#if defined(PNG_INFO_IMAGE_SUPPORTED)
png_bytepp PNGAPI
png_get_rows(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return(info_ptr->row_pointers);
   else
      return(0);
}
#endif

d34 1
a34 1
png_uint_32 PNGAPI
d44 1
a44 1
png_uint_32 PNGAPI
d54 1
a54 1
png_byte PNGAPI
d64 1
a64 1
png_byte PNGAPI
d74 1
a74 1
png_byte PNGAPI
d84 1
a84 1
png_byte PNGAPI
d94 1
a94 1
png_byte PNGAPI
d104 1
a104 1
png_uint_32 PNGAPI
d107 2
a108 3
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_pHYs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_pHYs)
d115 1
a115 2
#else
   return (0);
d120 1
a120 1
png_uint_32 PNGAPI
d123 2
a124 3
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_pHYs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_pHYs)
d131 1
a131 2
#else
   return (0);
d136 1
a136 1
png_uint_32 PNGAPI
d139 2
a140 3
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_pHYs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_pHYs)
d148 1
a148 2
#else
   return (0);
d153 1
a153 2
#ifdef PNG_FLOATING_POINT_SUPPORTED
float PNGAPI
d156 2
a157 3
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_pHYs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_pHYs)
d163 2
a164 2
         return ((float)((float)info_ptr->y_pixels_per_unit
            /(float)info_ptr->x_pixels_per_unit));
d166 1
a166 2
#else
   return (0.0);
d168 1
a168 1
   return ((float)0.0);
a169 1
#endif
d171 1
a171 1
png_int_32 PNGAPI
d174 2
a175 3
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_oFFs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_oFFs)
d182 1
a182 2
#else
   return (0);
d187 1
a187 1
png_int_32 PNGAPI
d190 2
a191 3
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_oFFs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_oFFs)
d198 1
a198 2
#else
   return (0);
d203 1
a203 1
png_int_32 PNGAPI
d206 2
a207 3
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_oFFs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_oFFs)
d214 1
a214 2
#else
   return (0);
d219 1
a219 1
png_int_32 PNGAPI
d222 2
a223 3
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_oFFs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_oFFs)
d230 1
a230 2
#else
   return (0);
d235 2
a236 2
#if defined(PNG_INCH_CONVERSIONS) && defined(PNG_FLOATING_POINT_SUPPORTED)
png_uint_32 PNGAPI
d240 1
a240 1
     *.0254 +.5));
d243 1
a243 1
png_uint_32 PNGAPI
d247 1
a247 1
     *.0254 +.5));
d250 1
a250 1
png_uint_32 PNGAPI
d254 1
a254 1
     *.0254 +.5));
d257 1
a257 1
float PNGAPI
d261 1
a261 1
     *.00003937);
d264 1
a264 1
float PNGAPI
d268 1
a268 1
     *.00003937);
d271 2
a272 2
#if defined(PNG_pHYs_SUPPORTED)
png_uint_32 PNGAPI
d278 1
a278 1
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs))
d295 1
a295 1
         if(*unit_type == 1)
d297 2
a298 2
            if (res_x != NULL) *res_x = (png_uint_32)(*res_x * .0254 + .50);
            if (res_y != NULL) *res_y = (png_uint_32)(*res_y * .0254 + .50);
d304 2
a305 2
#endif /* PNG_pHYs_SUPPORTED */
#endif  /* PNG_INCH_CONVERSIONS && PNG_FLOATING_POINT_SUPPORTED */
d311 1
a311 1
png_byte PNGAPI
d320 1
a320 1
png_bytep PNGAPI
d329 2
a330 2
#if defined(PNG_bKGD_SUPPORTED)
png_uint_32 PNGAPI
d345 2
a346 3
#if defined(PNG_cHRM_SUPPORTED)
#ifdef PNG_FLOATING_POINT_SUPPORTED
png_uint_32 PNGAPI
a374 32
#ifdef PNG_FIXED_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_cHRM_fixed(png_structp png_ptr, png_infop info_ptr,
   png_fixed_point *white_x, png_fixed_point *white_y, png_fixed_point *red_x,
   png_fixed_point *red_y, png_fixed_point *green_x, png_fixed_point *green_y,
   png_fixed_point *blue_x, png_fixed_point *blue_y)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM))
   {
      png_debug1(1, "in %s retrieval function\n", "cHRM");
      if (white_x != NULL)
         *white_x = info_ptr->int_x_white;
      if (white_y != NULL)
         *white_y = info_ptr->int_y_white;
      if (red_x != NULL)
         *red_x = info_ptr->int_x_red;
      if (red_y != NULL)
         *red_y = info_ptr->int_y_red;
      if (green_x != NULL)
         *green_x = info_ptr->int_x_green;
      if (green_y != NULL)
         *green_y = info_ptr->int_y_green;
      if (blue_x != NULL)
         *blue_x = info_ptr->int_x_blue;
      if (blue_y != NULL)
         *blue_y = info_ptr->int_y_blue;
      return (PNG_INFO_cHRM);
   }
   return (0);
}
#endif
#endif
d376 2
a377 3
#if defined(PNG_gAMA_SUPPORTED)
#ifdef PNG_FLOATING_POINT_SUPPORTED
png_uint_32 PNGAPI
a389 16
#ifdef PNG_FIXED_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_gAMA_fixed(png_structp png_ptr, png_infop info_ptr,
    png_fixed_point *int_file_gamma)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA)
      && int_file_gamma != NULL)
   {
      png_debug1(1, "in %s retrieval function\n", "gAMA");
      *int_file_gamma = info_ptr->int_gamma;
      return (PNG_INFO_gAMA);
   }
   return (0);
}
#endif
#endif
d391 2
a392 2
#if defined(PNG_sRGB_SUPPORTED)
png_uint_32 PNGAPI
d406 2
a407 35
#if defined(PNG_iCCP_SUPPORTED)
png_uint_32 PNGAPI
png_get_iCCP(png_structp png_ptr, png_infop info_ptr,
             png_charpp name, int *compression_type,
             png_charpp profile, png_uint_32 *proflen)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_iCCP)
      && name != NULL && profile != NULL && proflen != NULL)
   {
      png_debug1(1, "in %s retrieval function\n", "iCCP");
      *name = info_ptr->iccp_name;
      *profile = info_ptr->iccp_profile;
      /* compression_type is a dummy so the API won't have to change
         if we introduce multiple compression types later. */
      *proflen = (int)info_ptr->iccp_proflen;
      *compression_type = (int)info_ptr->iccp_compression;
      return (PNG_INFO_iCCP);
   }
   return (0);
}
#endif

#if defined(PNG_sPLT_SUPPORTED)
png_uint_32 PNGAPI
png_get_sPLT(png_structp png_ptr, png_infop info_ptr,
             png_sPLT_tpp spalettes)
{
   if (png_ptr != NULL && info_ptr != NULL && spalettes != NULL)
     *spalettes = info_ptr->splt_palettes;
   return ((png_uint_32)info_ptr->splt_palettes_num);
}
#endif

#if defined(PNG_hIST_SUPPORTED)
png_uint_32 PNGAPI
d421 1
a421 1
png_uint_32 PNGAPI
d426 1
a426 1

a437 2
      if (info_ptr->bit_depth < 1 || info_ptr->bit_depth > 16)
        png_error(png_ptr, "Invalid bit depth");
a438 2
      if (info_ptr->color_type > 6)
        png_error(png_ptr, "Invalid color type");
d457 1
a457 5
      if (width == 0 || *width > PNG_MAX_UINT)
        png_error(png_ptr, "Invalid image width");
      if (height == 0 || *height > PNG_MAX_UINT)
        png_error(png_ptr, "Invalid image height");
      if (*width > PNG_MAX_UINT/rowbytes_per_pixel - 64)
d459 1
a459 1
         png_error(png_ptr,
d467 2
a468 2
#if defined(PNG_oFFs_SUPPORTED)
png_uint_32 PNGAPI
d470 1
a470 1
   png_int_32 *offset_x, png_int_32 *offset_y, int *unit_type)
d485 2
a486 2
#if defined(PNG_pCAL_SUPPORTED)
png_uint_32 PNGAPI
d491 2
a492 2
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_pCAL)
      && purpose != NULL && X0 != NULL && X1 != NULL && type != NULL &&
d509 2
a510 38
#if defined(PNG_sCAL_SUPPORTED)
#ifdef PNG_FLOATING_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_sCAL(png_structp png_ptr, png_infop info_ptr,
             int *unit, double *width, double *height)
{
    if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_sCAL))
    {
        *unit = info_ptr->scal_unit;
        *width = info_ptr->scal_pixel_width;
        *height = info_ptr->scal_pixel_height;
        return (PNG_INFO_sCAL);
    }
    return(0);
}
#else
#ifdef PNG_FIXED_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_sCAL_s(png_structp png_ptr, png_infop info_ptr,
             int *unit, png_charpp width, png_charpp height)
{
    if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_sCAL))
    {
        *unit = info_ptr->scal_unit;
        *width = info_ptr->scal_s_width;
        *height = info_ptr->scal_s_height;
        return (PNG_INFO_sCAL);
    }
    return(0);
}
#endif
#endif
#endif

#if defined(PNG_pHYs_SUPPORTED)
png_uint_32 PNGAPI
d516 1
a516 2
   if (png_ptr != NULL && info_ptr != NULL &&
      (info_ptr->valid & PNG_INFO_pHYs))
d539 1
a539 1
png_uint_32 PNGAPI
d543 2
a544 2
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_PLTE)
       && palette != NULL)
d555 2
a556 2
#if defined(PNG_sBIT_SUPPORTED)
png_uint_32 PNGAPI
d559 2
a560 2
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_sBIT)
      && sig_bit != NULL)
d570 2
a571 2
#if defined(PNG_TEXT_SUPPORTED)
png_uint_32 PNGAPI
a585 2
   if (num_text != NULL)
     *num_text = 0;
d590 2
a591 2
#if defined(PNG_tIME_SUPPORTED)
png_uint_32 PNGAPI
d594 2
a595 2
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_tIME)
       && mod_time != NULL)
d605 2
a606 2
#if defined(PNG_tRNS_SUPPORTED)
png_uint_32 PNGAPI
d611 1
a611 1
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS))
a643 125
#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
png_uint_32 PNGAPI
png_get_unknown_chunks(png_structp png_ptr, png_infop info_ptr,
             png_unknown_chunkpp unknowns)
{
   if (png_ptr != NULL && info_ptr != NULL && unknowns != NULL)
     *unknowns = info_ptr->unknown_chunks;
   return ((png_uint_32)info_ptr->unknown_chunks_num);
}
#endif

#if defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
png_byte PNGAPI
png_get_rgb_to_gray_status (png_structp png_ptr)
{
   return (png_byte)(png_ptr? png_ptr->rgb_to_gray_status : 0);
}
#endif

#if defined(PNG_USER_CHUNKS_SUPPORTED)
png_voidp PNGAPI
png_get_user_chunk_ptr(png_structp png_ptr)
{
   return (png_ptr? png_ptr->user_chunk_ptr : NULL);
}
#endif


png_uint_32 PNGAPI
png_get_compression_buffer_size(png_structp png_ptr)
{
   return (png_uint_32)(png_ptr? png_ptr->zbuf_size : 0L);
}


#ifndef PNG_1_0_X
#ifdef PNG_ASSEMBLER_CODE_SUPPORTED
/* this function was added to libpng 1.2.0 and should exist by default */
png_uint_32 PNGAPI
png_get_asm_flags (png_structp png_ptr)
{
    return (png_uint_32)(png_ptr? png_ptr->asm_flags : 0L);
}

/* this function was added to libpng 1.2.0 and should exist by default */
png_uint_32 PNGAPI
png_get_asm_flagmask (int flag_select)
{
    png_uint_32 settable_asm_flags = 0;

    if (flag_select & PNG_SELECT_READ)
        settable_asm_flags |=
          PNG_ASM_FLAG_MMX_READ_COMBINE_ROW  |
          PNG_ASM_FLAG_MMX_READ_INTERLACE    |
          PNG_ASM_FLAG_MMX_READ_FILTER_SUB   |
          PNG_ASM_FLAG_MMX_READ_FILTER_UP    |
          PNG_ASM_FLAG_MMX_READ_FILTER_AVG   |
          PNG_ASM_FLAG_MMX_READ_FILTER_PAETH ;
          /* no non-MMX flags yet */

#if 0
    /* GRR:  no write-flags yet, either, but someday... */
    if (flag_select & PNG_SELECT_WRITE)
        settable_asm_flags |=
          PNG_ASM_FLAG_MMX_WRITE_ [whatever] ;
#endif /* 0 */

    return settable_asm_flags;  /* _theoretically_ settable capabilities only */
}
#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */


#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
    /* GRR:  could add this:   && defined(PNG_MMX_CODE_SUPPORTED) */
/* this function was added to libpng 1.2.0 */
png_uint_32 PNGAPI
png_get_mmx_flagmask (int flag_select, int *compilerID)
{
    png_uint_32 settable_mmx_flags = 0;

    if (flag_select & PNG_SELECT_READ)
        settable_mmx_flags |=
          PNG_ASM_FLAG_MMX_READ_COMBINE_ROW  |
          PNG_ASM_FLAG_MMX_READ_INTERLACE    |
          PNG_ASM_FLAG_MMX_READ_FILTER_SUB   |
          PNG_ASM_FLAG_MMX_READ_FILTER_UP    |
          PNG_ASM_FLAG_MMX_READ_FILTER_AVG   |
          PNG_ASM_FLAG_MMX_READ_FILTER_PAETH ;
#if 0
    /* GRR:  no MMX write support yet, but someday... */
    if (flag_select & PNG_SELECT_WRITE)
        settable_mmx_flags |=
          PNG_ASM_FLAG_MMX_WRITE_ [whatever] ;
#endif /* 0 */

    if (compilerID != NULL) {
#ifdef PNG_USE_PNGVCRD
        *compilerID = 1;    /* MSVC */
#else
#ifdef PNG_USE_PNGGCCRD
        *compilerID = 2;    /* gcc/gas */
#else
        *compilerID = -1;   /* unknown (i.e., no asm/MMX code compiled) */
#endif
#endif
    }

    return settable_mmx_flags;  /* _theoretically_ settable capabilities only */
}

/* this function was added to libpng 1.2.0 */
png_byte PNGAPI
png_get_mmx_bitdepth_threshold (png_structp png_ptr)
{
    return (png_byte)(png_ptr? png_ptr->mmx_bitdepth_threshold : 0);
}

/* this function was added to libpng 1.2.0 */
png_uint_32 PNGAPI
png_get_mmx_rowbytes_threshold (png_structp png_ptr)
{
    return (png_uint_32)(png_ptr? png_ptr->mmx_rowbytes_threshold : 0L);
}
#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
#endif /* PNG_1_0_X */
@


1.1.1.1.8.1
log
@sync to HEAD...
@
text
@d4 1
a4 1
 * libpng 1.2.5 - October 3, 2002
d6 3
a8 3
 * Copyright (c) 1998-2002 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
d14 1
a14 1
png_uint_32 PNGAPI
d23 1
a23 1
png_uint_32 PNGAPI
a31 11
#if defined(PNG_INFO_IMAGE_SUPPORTED)
png_bytepp PNGAPI
png_get_rows(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return(info_ptr->row_pointers);
   else
      return(0);
}
#endif

d34 1
a34 1
png_uint_32 PNGAPI
d44 1
a44 1
png_uint_32 PNGAPI
d54 1
a54 1
png_byte PNGAPI
d64 1
a64 1
png_byte PNGAPI
d74 1
a74 1
png_byte PNGAPI
d84 1
a84 1
png_byte PNGAPI
d94 1
a94 1
png_byte PNGAPI
d104 1
a104 1
png_uint_32 PNGAPI
d107 2
a108 3
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_pHYs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_pHYs)
d115 1
a115 2
#else
   return (0);
d120 1
a120 1
png_uint_32 PNGAPI
d123 2
a124 3
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_pHYs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_pHYs)
d131 1
a131 2
#else
   return (0);
d136 1
a136 1
png_uint_32 PNGAPI
d139 2
a140 3
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_pHYs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_pHYs)
d148 1
a148 2
#else
   return (0);
d153 1
a153 2
#ifdef PNG_FLOATING_POINT_SUPPORTED
float PNGAPI
d156 2
a157 3
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_pHYs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_pHYs)
d163 2
a164 2
         return ((float)((float)info_ptr->y_pixels_per_unit
            /(float)info_ptr->x_pixels_per_unit));
d166 1
a166 2
#else
   return (0.0);
d168 1
a168 1
   return ((float)0.0);
a169 1
#endif
d171 1
a171 1
png_int_32 PNGAPI
d174 2
a175 3
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_oFFs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_oFFs)
d182 1
a182 2
#else
   return (0);
d187 1
a187 1
png_int_32 PNGAPI
d190 2
a191 3
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_oFFs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_oFFs)
d198 1
a198 2
#else
   return (0);
d203 1
a203 1
png_int_32 PNGAPI
d206 2
a207 3
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_oFFs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_oFFs)
d214 1
a214 2
#else
   return (0);
d219 1
a219 1
png_int_32 PNGAPI
d222 2
a223 3
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_oFFs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_oFFs)
d230 1
a230 2
#else
   return (0);
d235 2
a236 2
#if defined(PNG_INCH_CONVERSIONS) && defined(PNG_FLOATING_POINT_SUPPORTED)
png_uint_32 PNGAPI
d240 1
a240 1
     *.0254 +.5));
d243 1
a243 1
png_uint_32 PNGAPI
d247 1
a247 1
     *.0254 +.5));
d250 1
a250 1
png_uint_32 PNGAPI
d254 1
a254 1
     *.0254 +.5));
d257 1
a257 1
float PNGAPI
d261 1
a261 1
     *.00003937);
d264 1
a264 1
float PNGAPI
d268 1
a268 1
     *.00003937);
d271 2
a272 2
#if defined(PNG_pHYs_SUPPORTED)
png_uint_32 PNGAPI
d278 1
a278 1
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs))
d295 1
a295 1
         if(*unit_type == 1)
d297 2
a298 2
            if (res_x != NULL) *res_x = (png_uint_32)(*res_x * .0254 + .50);
            if (res_y != NULL) *res_y = (png_uint_32)(*res_y * .0254 + .50);
d304 2
a305 2
#endif /* PNG_pHYs_SUPPORTED */
#endif  /* PNG_INCH_CONVERSIONS && PNG_FLOATING_POINT_SUPPORTED */
d311 1
a311 1
png_byte PNGAPI
d320 1
a320 1
png_bytep PNGAPI
d329 2
a330 2
#if defined(PNG_bKGD_SUPPORTED)
png_uint_32 PNGAPI
d345 2
a346 3
#if defined(PNG_cHRM_SUPPORTED)
#ifdef PNG_FLOATING_POINT_SUPPORTED
png_uint_32 PNGAPI
a374 32
#ifdef PNG_FIXED_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_cHRM_fixed(png_structp png_ptr, png_infop info_ptr,
   png_fixed_point *white_x, png_fixed_point *white_y, png_fixed_point *red_x,
   png_fixed_point *red_y, png_fixed_point *green_x, png_fixed_point *green_y,
   png_fixed_point *blue_x, png_fixed_point *blue_y)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM))
   {
      png_debug1(1, "in %s retrieval function\n", "cHRM");
      if (white_x != NULL)
         *white_x = info_ptr->int_x_white;
      if (white_y != NULL)
         *white_y = info_ptr->int_y_white;
      if (red_x != NULL)
         *red_x = info_ptr->int_x_red;
      if (red_y != NULL)
         *red_y = info_ptr->int_y_red;
      if (green_x != NULL)
         *green_x = info_ptr->int_x_green;
      if (green_y != NULL)
         *green_y = info_ptr->int_y_green;
      if (blue_x != NULL)
         *blue_x = info_ptr->int_x_blue;
      if (blue_y != NULL)
         *blue_y = info_ptr->int_y_blue;
      return (PNG_INFO_cHRM);
   }
   return (0);
}
#endif
#endif
d376 2
a377 3
#if defined(PNG_gAMA_SUPPORTED)
#ifdef PNG_FLOATING_POINT_SUPPORTED
png_uint_32 PNGAPI
a389 16
#ifdef PNG_FIXED_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_gAMA_fixed(png_structp png_ptr, png_infop info_ptr,
    png_fixed_point *int_file_gamma)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA)
      && int_file_gamma != NULL)
   {
      png_debug1(1, "in %s retrieval function\n", "gAMA");
      *int_file_gamma = info_ptr->int_gamma;
      return (PNG_INFO_gAMA);
   }
   return (0);
}
#endif
#endif
d391 2
a392 2
#if defined(PNG_sRGB_SUPPORTED)
png_uint_32 PNGAPI
d406 2
a407 35
#if defined(PNG_iCCP_SUPPORTED)
png_uint_32 PNGAPI
png_get_iCCP(png_structp png_ptr, png_infop info_ptr,
             png_charpp name, int *compression_type,
             png_charpp profile, png_uint_32 *proflen)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_iCCP)
      && name != NULL && profile != NULL && proflen != NULL)
   {
      png_debug1(1, "in %s retrieval function\n", "iCCP");
      *name = info_ptr->iccp_name;
      *profile = info_ptr->iccp_profile;
      /* compression_type is a dummy so the API won't have to change
         if we introduce multiple compression types later. */
      *proflen = (int)info_ptr->iccp_proflen;
      *compression_type = (int)info_ptr->iccp_compression;
      return (PNG_INFO_iCCP);
   }
   return (0);
}
#endif

#if defined(PNG_sPLT_SUPPORTED)
png_uint_32 PNGAPI
png_get_sPLT(png_structp png_ptr, png_infop info_ptr,
             png_sPLT_tpp spalettes)
{
   if (png_ptr != NULL && info_ptr != NULL && spalettes != NULL)
     *spalettes = info_ptr->splt_palettes;
   return ((png_uint_32)info_ptr->splt_palettes_num);
}
#endif

#if defined(PNG_hIST_SUPPORTED)
png_uint_32 PNGAPI
d421 1
a421 1
png_uint_32 PNGAPI
d426 1
a426 1

a437 2
      if (info_ptr->bit_depth < 1 || info_ptr->bit_depth > 16)
        png_error(png_ptr, "Invalid bit depth");
a438 2
      if (info_ptr->color_type > 6)
        png_error(png_ptr, "Invalid color type");
d457 1
a457 5
      if (width == 0 || *width > PNG_MAX_UINT)
        png_error(png_ptr, "Invalid image width");
      if (height == 0 || *height > PNG_MAX_UINT)
        png_error(png_ptr, "Invalid image height");
      if (*width > PNG_MAX_UINT/rowbytes_per_pixel - 64)
d459 1
a459 1
         png_error(png_ptr,
d467 2
a468 2
#if defined(PNG_oFFs_SUPPORTED)
png_uint_32 PNGAPI
d470 1
a470 1
   png_int_32 *offset_x, png_int_32 *offset_y, int *unit_type)
d485 2
a486 2
#if defined(PNG_pCAL_SUPPORTED)
png_uint_32 PNGAPI
d491 2
a492 2
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_pCAL)
      && purpose != NULL && X0 != NULL && X1 != NULL && type != NULL &&
d509 2
a510 38
#if defined(PNG_sCAL_SUPPORTED)
#ifdef PNG_FLOATING_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_sCAL(png_structp png_ptr, png_infop info_ptr,
             int *unit, double *width, double *height)
{
    if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_sCAL))
    {
        *unit = info_ptr->scal_unit;
        *width = info_ptr->scal_pixel_width;
        *height = info_ptr->scal_pixel_height;
        return (PNG_INFO_sCAL);
    }
    return(0);
}
#else
#ifdef PNG_FIXED_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_sCAL_s(png_structp png_ptr, png_infop info_ptr,
             int *unit, png_charpp width, png_charpp height)
{
    if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_sCAL))
    {
        *unit = info_ptr->scal_unit;
        *width = info_ptr->scal_s_width;
        *height = info_ptr->scal_s_height;
        return (PNG_INFO_sCAL);
    }
    return(0);
}
#endif
#endif
#endif

#if defined(PNG_pHYs_SUPPORTED)
png_uint_32 PNGAPI
d516 1
a516 2
   if (png_ptr != NULL && info_ptr != NULL &&
      (info_ptr->valid & PNG_INFO_pHYs))
d539 1
a539 1
png_uint_32 PNGAPI
d543 2
a544 2
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_PLTE)
       && palette != NULL)
d555 2
a556 2
#if defined(PNG_sBIT_SUPPORTED)
png_uint_32 PNGAPI
d559 2
a560 2
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_sBIT)
      && sig_bit != NULL)
d570 2
a571 2
#if defined(PNG_TEXT_SUPPORTED)
png_uint_32 PNGAPI
a585 2
   if (num_text != NULL)
     *num_text = 0;
d590 2
a591 2
#if defined(PNG_tIME_SUPPORTED)
png_uint_32 PNGAPI
d594 2
a595 2
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_tIME)
       && mod_time != NULL)
d605 2
a606 2
#if defined(PNG_tRNS_SUPPORTED)
png_uint_32 PNGAPI
d611 1
a611 1
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS))
a643 125
#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
png_uint_32 PNGAPI
png_get_unknown_chunks(png_structp png_ptr, png_infop info_ptr,
             png_unknown_chunkpp unknowns)
{
   if (png_ptr != NULL && info_ptr != NULL && unknowns != NULL)
     *unknowns = info_ptr->unknown_chunks;
   return ((png_uint_32)info_ptr->unknown_chunks_num);
}
#endif

#if defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
png_byte PNGAPI
png_get_rgb_to_gray_status (png_structp png_ptr)
{
   return (png_byte)(png_ptr? png_ptr->rgb_to_gray_status : 0);
}
#endif

#if defined(PNG_USER_CHUNKS_SUPPORTED)
png_voidp PNGAPI
png_get_user_chunk_ptr(png_structp png_ptr)
{
   return (png_ptr? png_ptr->user_chunk_ptr : NULL);
}
#endif


png_uint_32 PNGAPI
png_get_compression_buffer_size(png_structp png_ptr)
{
   return (png_uint_32)(png_ptr? png_ptr->zbuf_size : 0L);
}


#ifndef PNG_1_0_X
#ifdef PNG_ASSEMBLER_CODE_SUPPORTED
/* this function was added to libpng 1.2.0 and should exist by default */
png_uint_32 PNGAPI
png_get_asm_flags (png_structp png_ptr)
{
    return (png_uint_32)(png_ptr? png_ptr->asm_flags : 0L);
}

/* this function was added to libpng 1.2.0 and should exist by default */
png_uint_32 PNGAPI
png_get_asm_flagmask (int flag_select)
{
    png_uint_32 settable_asm_flags = 0;

    if (flag_select & PNG_SELECT_READ)
        settable_asm_flags |=
          PNG_ASM_FLAG_MMX_READ_COMBINE_ROW  |
          PNG_ASM_FLAG_MMX_READ_INTERLACE    |
          PNG_ASM_FLAG_MMX_READ_FILTER_SUB   |
          PNG_ASM_FLAG_MMX_READ_FILTER_UP    |
          PNG_ASM_FLAG_MMX_READ_FILTER_AVG   |
          PNG_ASM_FLAG_MMX_READ_FILTER_PAETH ;
          /* no non-MMX flags yet */

#if 0
    /* GRR:  no write-flags yet, either, but someday... */
    if (flag_select & PNG_SELECT_WRITE)
        settable_asm_flags |=
          PNG_ASM_FLAG_MMX_WRITE_ [whatever] ;
#endif /* 0 */

    return settable_asm_flags;  /* _theoretically_ settable capabilities only */
}
#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */


#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
    /* GRR:  could add this:   && defined(PNG_MMX_CODE_SUPPORTED) */
/* this function was added to libpng 1.2.0 */
png_uint_32 PNGAPI
png_get_mmx_flagmask (int flag_select, int *compilerID)
{
    png_uint_32 settable_mmx_flags = 0;

    if (flag_select & PNG_SELECT_READ)
        settable_mmx_flags |=
          PNG_ASM_FLAG_MMX_READ_COMBINE_ROW  |
          PNG_ASM_FLAG_MMX_READ_INTERLACE    |
          PNG_ASM_FLAG_MMX_READ_FILTER_SUB   |
          PNG_ASM_FLAG_MMX_READ_FILTER_UP    |
          PNG_ASM_FLAG_MMX_READ_FILTER_AVG   |
          PNG_ASM_FLAG_MMX_READ_FILTER_PAETH ;
#if 0
    /* GRR:  no MMX write support yet, but someday... */
    if (flag_select & PNG_SELECT_WRITE)
        settable_mmx_flags |=
          PNG_ASM_FLAG_MMX_WRITE_ [whatever] ;
#endif /* 0 */

    if (compilerID != NULL) {
#ifdef PNG_USE_PNGVCRD
        *compilerID = 1;    /* MSVC */
#else
#ifdef PNG_USE_PNGGCCRD
        *compilerID = 2;    /* gcc/gas */
#else
        *compilerID = -1;   /* unknown (i.e., no asm/MMX code compiled) */
#endif
#endif
    }

    return settable_mmx_flags;  /* _theoretically_ settable capabilities only */
}

/* this function was added to libpng 1.2.0 */
png_byte PNGAPI
png_get_mmx_bitdepth_threshold (png_structp png_ptr)
{
    return (png_byte)(png_ptr? png_ptr->mmx_bitdepth_threshold : 0);
}

/* this function was added to libpng 1.2.0 */
png_uint_32 PNGAPI
png_get_mmx_rowbytes_threshold (png_structp png_ptr)
{
    return (png_uint_32)(png_ptr? png_ptr->mmx_rowbytes_threshold : 0L);
}
#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
#endif /* PNG_1_0_X */
@

