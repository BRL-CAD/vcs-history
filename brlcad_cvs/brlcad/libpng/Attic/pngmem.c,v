head	1.4;
access;
symbols
	ansi-20040405-merged:1.2.6.1
	postmerge-20040405-ansi:1.3
	premerge-20040404-ansi:1.3
	postmerge-autoconf:1.3
	autoconf-freeze:1.3
	premerge-autoconf:1.3
	ansi-20040316-freeze:1.2
	postmerge-20040315-windows:1.3
	premerge-20040315-windows:1.3
	windows-20040315-freeze:1.2.8.1
	autoconf-20031203:1.3
	autoconf-20031202:1.3
	autoconf-branch:1.3.0.6
	phong-branch:1.3.0.4
	photonmap-branch:1.3.0.2
	rel-6-1-DP:1.2
	windows-branch:1.2.0.8
	rel-6-0-2:1.2
	ansi-branch:1.2.0.6
	rel-6-0-1-branch:1.2.0.4
	hartley-6-0-post:1.2
	hartley-6-0-pre:1.2
	rel-6-0-1:1.2
	rel-6-0:1.2
	rel-5-4:1.2
	offsite-5-3-pre:1.2
	rel-5-3:1.2
	rel-5-2:1.2
	rel-5-1-branch:1.2.0.2
	rel-5-1:1.2
	rel-5-0:1.2
	rel-5-0-beta:1.2
	libpng_1_0_2:1.1.1.1
	libpng:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2004.05.21.18.05.27;	author morrison;	state dead;
branches;
next	1.3;

1.3
date	2002.12.26.14.39.09;	author jra;	state Exp;
branches;
next	1.2;

1.2
date	98.09.14.15.59.16;	author bparker;	state Exp;
branches
	1.2.6.1
	1.2.8.1;
next	1.1;

1.1
date	98.06.24.20.00.14;	author jra;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.06.24.20.00.14;	author jra;	state Exp;
branches;
next	;

1.2.6.1
date	2004.03.17.21.18.35;	author morrison;	state Exp;
branches;
next	;

1.2.8.1
date	2004.03.11.23.43.20;	author morrison;	state Exp;
branches;
next	;


desc
@@


1.4
log
@moved from top-level to src/other/.
@
text
@
/* pngmem.c - stub functions for memory allocation
 *
 * libpng 1.2.5 - October 3, 2002
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1998-2002 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This file provides a location for all memory allocation.  Users who
 * need special memory handling are expected to supply replacement
 * functions for png_malloc() and png_free(), and to use
 * png_create_read_struct_2() and png_create_write_struct_2() to
 * identify the replacement functions.
 */

#define PNG_INTERNAL
#include "png.h"

/* Borland DOS special memory handler */
#if defined(__TURBOC__) && !defined(_Windows) && !defined(__FLAT__)
/* if you change this, be sure to change the one in png.h also */

/* Allocate memory for a png_struct.  The malloc and memset can be replaced
   by a single call to calloc() if this is thought to improve performance. */
png_voidp /* PRIVATE */
png_create_struct(int type)
{
#ifdef PNG_USER_MEM_SUPPORTED
   return (png_create_struct_2(type, png_malloc_ptr_NULL, png_voidp_NULL));
}

/* Alternate version of png_create_struct, for use with user-defined malloc. */
png_voidp /* PRIVATE */
png_create_struct_2(int type, png_malloc_ptr malloc_fn, png_voidp mem_ptr)
{
#endif /* PNG_USER_MEM_SUPPORTED */
   png_size_t size;
   png_voidp struct_ptr;

   if (type == PNG_STRUCT_INFO)
     size = sizeof(png_info);
   else if (type == PNG_STRUCT_PNG)
     size = sizeof(png_struct);
   else
     return (png_get_copyright());

#ifdef PNG_USER_MEM_SUPPORTED
   if(malloc_fn != NULL)
   {
      png_struct dummy_struct;
      png_structp png_ptr = &dummy_struct;
      png_ptr->mem_ptr=mem_ptr;
      struct_ptr = (*(malloc_fn))(png_ptr, (png_uint_32)size);
   }
   else
#endif /* PNG_USER_MEM_SUPPORTED */
      struct_ptr = (png_voidp)farmalloc(size));
   if (struct_ptr != NULL)
      png_memset(struct_ptr, 0, size);
   return (struct_ptr);
}

/* Free memory allocated by a png_create_struct() call */
void /* PRIVATE */
png_destroy_struct(png_voidp struct_ptr)
{
#ifdef PNG_USER_MEM_SUPPORTED
   png_destroy_struct_2(struct_ptr, png_free_ptr_NULL, png_voidp_NULL);
}

/* Free memory allocated by a png_create_struct() call */
void /* PRIVATE */
png_destroy_struct_2(png_voidp struct_ptr, png_free_ptr free_fn,
    png_voidp mem_ptr)
{
#endif
   if (struct_ptr != NULL)
   {
#ifdef PNG_USER_MEM_SUPPORTED
      if(free_fn != NULL)
      {
         png_struct dummy_struct;
         png_structp png_ptr = &dummy_struct;
         png_ptr->mem_ptr=mem_ptr;
         (*(free_fn))(png_ptr, struct_ptr);
         return;
      }
#endif /* PNG_USER_MEM_SUPPORTED */
      farfree (struct_ptr);
   }
}

/* Allocate memory.  For reasonable files, size should never exceed
 * 64K.  However, zlib may allocate more then 64K if you don't tell
 * it not to.  See zconf.h and png.h for more information. zlib does
 * need to allocate exactly 64K, so whatever you call here must
 * have the ability to do that.
 *
 * Borland seems to have a problem in DOS mode for exactly 64K.
 * It gives you a segment with an offset of 8 (perhaps to store its
 * memory stuff).  zlib doesn't like this at all, so we have to
 * detect and deal with it.  This code should not be needed in
 * Windows or OS/2 modes, and only in 16 bit mode.  This code has
 * been updated by Alexander Lehmann for version 0.89 to waste less
 * memory.
 *
 * Note that we can't use png_size_t for the "size" declaration,
 * since on some systems a png_size_t is a 16-bit quantity, and as a
 * result, we would be truncating potentially larger memory requests
 * (which should cause a fatal error) and introducing major problems.
 */

png_voidp PNGAPI
png_malloc(png_structp png_ptr, png_uint_32 size)
{
   png_voidp ret;

   if (png_ptr == NULL || size == 0)
      return (NULL);

#ifdef PNG_USER_MEM_SUPPORTED
   if(png_ptr->malloc_fn != NULL)
   {
       ret = ((png_voidp)(*(png_ptr->malloc_fn))(png_ptr, (png_size_t)size));
       if (ret == NULL && (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
          png_error(png_ptr, "Out of memory!");
       return (ret);
   }
   else
       return png_malloc_default(png_ptr, size);
}

png_voidp PNGAPI
png_malloc_default(png_structp png_ptr, png_uint_32 size)
{
   png_voidp ret;
#endif /* PNG_USER_MEM_SUPPORTED */

#ifdef PNG_MAX_MALLOC_64K
   if (size > (png_uint_32)65536L)
      png_error(png_ptr, "Cannot Allocate > 64K");
#endif

   if (size == (png_uint_32)65536L)
   {
      if (png_ptr->offset_table == NULL)
      {
         /* try to see if we need to do any of this fancy stuff */
         ret = farmalloc(size);
         if (ret == NULL || ((png_size_t)ret & 0xffff))
         {
            int num_blocks;
            png_uint_32 total_size;
            png_bytep table;
            int i;
            png_byte huge * hptr;

            if (ret != NULL)
            {
               farfree(ret);
               ret = NULL;
            }

            if(png_ptr->zlib_window_bits > 14)
               num_blocks = (int)(1 << (png_ptr->zlib_window_bits - 14));
            else
               num_blocks = 1;
            if (png_ptr->zlib_mem_level >= 7)
               num_blocks += (int)(1 << (png_ptr->zlib_mem_level - 7));
            else
               num_blocks++;

            total_size = ((png_uint_32)65536L) * (png_uint_32)num_blocks+16;

            table = farmalloc(total_size);

            if (table == NULL)
            {
               if (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
                  png_error(png_ptr, "Out Of Memory."); /* Note "O" and "M" */
               else
                  png_warning(png_ptr, "Out Of Memory.");
               return (NULL);
            }

            if ((png_size_t)table & 0xfff0)
            {
               if (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
                  png_error(png_ptr,
                    "Farmalloc didn't return normalized pointer");
               else
                  png_warning(png_ptr,
                    "Farmalloc didn't return normalized pointer");
               return (NULL);
            }

            png_ptr->offset_table = table;
            png_ptr->offset_table_ptr = farmalloc(num_blocks *
               sizeof (png_bytep));

            if (png_ptr->offset_table_ptr == NULL)
            {
               if (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
                  png_error(png_ptr, "Out Of memory."); /* Note "O" and "M" */
               else
                  png_warning(png_ptr, "Out Of memory.");
               return (NULL);
            }

            hptr = (png_byte huge *)table;
            if ((png_size_t)hptr & 0xf)
            {
               hptr = (png_byte huge *)((long)(hptr) & 0xfffffff0L);
               hptr = hptr + 16L;  /* "hptr += 16L" fails on Turbo C++ 3.0 */
            }
            for (i = 0; i < num_blocks; i++)
            {
               png_ptr->offset_table_ptr[i] = (png_bytep)hptr;
               hptr = hptr + (png_uint_32)65536L;  /* "+=" fails on TC++3.0 */
            }

            png_ptr->offset_table_number = num_blocks;
            png_ptr->offset_table_count = 0;
            png_ptr->offset_table_count_free = 0;
         }
      }

      if (png_ptr->offset_table_count >= png_ptr->offset_table_number)
      {
         if (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
            png_error(png_ptr, "Out of Memory."); /* Note "o" and "M" */
         else
            png_warning(png_ptr, "Out of Memory.");
         return (NULL);
      }

      ret = png_ptr->offset_table_ptr[png_ptr->offset_table_count++];
   }
   else
      ret = farmalloc(size);

   if (ret == NULL)
   {
      if (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
         png_error(png_ptr, "Out of memory."); /* Note "o" and "m" */
      else
         png_warning(png_ptr, "Out of memory."); /* Note "o" and "m" */
   }

   return (ret);
}

/* free a pointer allocated by png_malloc().  In the default
   configuration, png_ptr is not used, but is passed in case it
   is needed.  If ptr is NULL, return without taking any action. */
void PNGAPI
png_free(png_structp png_ptr, png_voidp ptr)
{
   if (png_ptr == NULL || ptr == NULL)
      return;

#ifdef PNG_USER_MEM_SUPPORTED
   if (png_ptr->free_fn != NULL)
   {
      (*(png_ptr->free_fn))(png_ptr, ptr);
      return;
   }
   else png_free_default(png_ptr, ptr);
}

void PNGAPI
png_free_default(png_structp png_ptr, png_voidp ptr)
{
#endif /* PNG_USER_MEM_SUPPORTED */

   if (png_ptr->offset_table != NULL)
   {
      int i;

      for (i = 0; i < png_ptr->offset_table_count; i++)
      {
         if (ptr == png_ptr->offset_table_ptr[i])
         {
            ptr = NULL;
            png_ptr->offset_table_count_free++;
            break;
         }
      }
      if (png_ptr->offset_table_count_free == png_ptr->offset_table_count)
      {
         farfree(png_ptr->offset_table);
         farfree(png_ptr->offset_table_ptr);
         png_ptr->offset_table = NULL;
         png_ptr->offset_table_ptr = NULL;
      }
   }

   if (ptr != NULL)
   {
      farfree(ptr);
   }
}

#else /* Not the Borland DOS special memory handler */

/* Allocate memory for a png_struct or a png_info.  The malloc and
   memset can be replaced by a single call to calloc() if this is thought
   to improve performance noticably. */
png_voidp /* PRIVATE */
png_create_struct(int type)
{
#ifdef PNG_USER_MEM_SUPPORTED
   return (png_create_struct_2(type, png_malloc_ptr_NULL, png_voidp_NULL));
}

/* Allocate memory for a png_struct or a png_info.  The malloc and
   memset can be replaced by a single call to calloc() if this is thought
   to improve performance noticably. */
png_voidp /* PRIVATE */
png_create_struct_2(int type, png_malloc_ptr malloc_fn, png_voidp mem_ptr)
{
#endif /* PNG_USER_MEM_SUPPORTED */
   png_size_t size;
   png_voidp struct_ptr;

   if (type == PNG_STRUCT_INFO)
      size = sizeof(png_info);
   else if (type == PNG_STRUCT_PNG)
      size = sizeof(png_struct);
   else
      return (NULL);

#ifdef PNG_USER_MEM_SUPPORTED
   if(malloc_fn != NULL)
   {
      png_struct dummy_struct;
      png_structp png_ptr = &dummy_struct;
      png_ptr->mem_ptr=mem_ptr;
      struct_ptr = (*(malloc_fn))(png_ptr, size);
      if (struct_ptr != NULL)
         png_memset(struct_ptr, 0, size);
      return (struct_ptr);
   }
#endif /* PNG_USER_MEM_SUPPORTED */

#if defined(__TURBOC__) && !defined(__FLAT__)
   if ((struct_ptr = (png_voidp)farmalloc(size)) != NULL)
#else
# if defined(_MSC_VER) && defined(MAXSEG_64K)
   if ((struct_ptr = (png_voidp)halloc(size,1)) != NULL)
# else
   if ((struct_ptr = (png_voidp)malloc(size)) != NULL)
# endif
#endif
   {
      png_memset(struct_ptr, 0, size);
   }

   return (struct_ptr);
}


/* Free memory allocated by a png_create_struct() call */
void /* PRIVATE */
png_destroy_struct(png_voidp struct_ptr)
{
#ifdef PNG_USER_MEM_SUPPORTED
   png_destroy_struct_2(struct_ptr, png_free_ptr_NULL, png_voidp_NULL);
}

/* Free memory allocated by a png_create_struct() call */
void /* PRIVATE */
png_destroy_struct_2(png_voidp struct_ptr, png_free_ptr free_fn,
    png_voidp mem_ptr)
{
#endif /* PNG_USER_MEM_SUPPORTED */
   if (struct_ptr != NULL)
   {
#ifdef PNG_USER_MEM_SUPPORTED
      if(free_fn != NULL)
      {
         png_struct dummy_struct;
         png_structp png_ptr = &dummy_struct;
         png_ptr->mem_ptr=mem_ptr;
         (*(free_fn))(png_ptr, struct_ptr);
         return;
      }
#endif /* PNG_USER_MEM_SUPPORTED */
#if defined(__TURBOC__) && !defined(__FLAT__)
      farfree(struct_ptr);
#else
# if defined(_MSC_VER) && defined(MAXSEG_64K)
      hfree(struct_ptr);
# else
      free(struct_ptr);
# endif
#endif
   }
}

/* Allocate memory.  For reasonable files, size should never exceed
   64K.  However, zlib may allocate more then 64K if you don't tell
   it not to.  See zconf.h and png.h for more information.  zlib does
   need to allocate exactly 64K, so whatever you call here must
   have the ability to do that. */

png_voidp PNGAPI
png_malloc(png_structp png_ptr, png_uint_32 size)
{
   png_voidp ret;

   if (png_ptr == NULL || size == 0)
      return (NULL);

#ifdef PNG_USER_MEM_SUPPORTED
   if(png_ptr->malloc_fn != NULL)
   {
       ret = ((png_voidp)(*(png_ptr->malloc_fn))(png_ptr, (png_size_t)size));
       if (ret == NULL && (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
          png_error(png_ptr, "Out of Memory!");
       return (ret);
   }
   else
       return (png_malloc_default(png_ptr, size));
}

png_voidp PNGAPI
png_malloc_default(png_structp png_ptr, png_uint_32 size)
{
   png_voidp ret;
#endif /* PNG_USER_MEM_SUPPORTED */

#ifdef PNG_MAX_MALLOC_64K
   if (size > (png_uint_32)65536L)
   {
      if(png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
         png_error(png_ptr, "Cannot Allocate > 64K");
      else
         return NULL;
   }
#endif

#if defined(__TURBOC__) && !defined(__FLAT__)
   ret = farmalloc(size);
#else
# if defined(_MSC_VER) && defined(MAXSEG_64K)
   ret = halloc(size, 1);
# else
   ret = malloc((size_t)size);
# endif
#endif

   if (ret == NULL && (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
      png_error(png_ptr, "Out of Memory");

   return (ret);
}

/* Free a pointer allocated by png_malloc().  If ptr is NULL, return
   without taking any action. */
void PNGAPI
png_free(png_structp png_ptr, png_voidp ptr)
{
   if (png_ptr == NULL || ptr == NULL)
      return;

#ifdef PNG_USER_MEM_SUPPORTED
   if (png_ptr->free_fn != NULL)
   {
      (*(png_ptr->free_fn))(png_ptr, ptr);
      return;
   }
   else png_free_default(png_ptr, ptr);
}
void PNGAPI
png_free_default(png_structp png_ptr, png_voidp ptr)
{
   if (png_ptr == NULL || ptr == NULL)
      return;

#endif /* PNG_USER_MEM_SUPPORTED */

#if defined(__TURBOC__) && !defined(__FLAT__)
   farfree(ptr);
#else
# if defined(_MSC_VER) && defined(MAXSEG_64K)
   hfree(ptr);
# else
   free(ptr);
# endif
#endif
}

#endif /* Not Borland DOS special memory handler */

#if defined(PNG_1_0_X)
#  define png_malloc_warn png_malloc
#else
/* This function was added at libpng version 1.2.3.  The png_malloc_warn()
 * function will issue a png_warning and return NULL instead of issuing a
 * png_error, if it fails to allocate the requested memory.
 */
png_voidp PNGAPI
png_malloc_warn(png_structp png_ptr, png_uint_32 size)
{
   png_voidp ptr;
   png_uint_32 save_flags=png_ptr->flags;

   png_ptr->flags|=PNG_FLAG_MALLOC_NULL_MEM_OK;
   ptr = (png_voidp)png_malloc((png_structp)png_ptr, size);
   png_ptr->flags=save_flags;
   return(ptr);
}
#endif

png_voidp PNGAPI
png_memcpy_check (png_structp png_ptr, png_voidp s1, png_voidp s2,
   png_uint_32 length)
{
   png_size_t size;

   size = (png_size_t)length;
   if ((png_uint_32)size != length)
      png_error(png_ptr,"Overflow in png_memcpy_check.");

   return(png_memcpy (s1, s2, size));
}

png_voidp PNGAPI
png_memset_check (png_structp png_ptr, png_voidp s1, int value,
   png_uint_32 length)
{
   png_size_t size;

   size = (png_size_t)length;
   if ((png_uint_32)size != length)
      png_error(png_ptr,"Overflow in png_memset_check.");

   return (png_memset (s1, value, size));

}

#ifdef PNG_USER_MEM_SUPPORTED
/* This function is called when the application wants to use another method
 * of allocating and freeing memory.
 */
void PNGAPI
png_set_mem_fn(png_structp png_ptr, png_voidp mem_ptr, png_malloc_ptr
  malloc_fn, png_free_ptr free_fn)
{
   png_ptr->mem_ptr = mem_ptr;
   png_ptr->malloc_fn = malloc_fn;
   png_ptr->free_fn = free_fn;
}

/* This function returns a pointer to the mem_ptr associated with the user
 * functions.  The application should free any memory associated with this
 * pointer before png_write_destroy and png_read_destroy are called.
 */
png_voidp PNGAPI
png_get_mem_ptr(png_structp png_ptr)
{
   return ((png_voidp)png_ptr->mem_ptr);
}
#endif /* PNG_USER_MEM_SUPPORTED */
@


1.3
log
@Update to libpng 1.2.5
@
text
@@


1.2
log
@*- fix typos
@
text
@d4 1
a4 1
 * libpng 1.0.2 - June 14, 1998
d6 3
a8 3
 * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
 * Copyright (c) 1996, 1997 Andreas Dilger
 * Copyright (c) 1998, Glenn Randers-Pehrson
d26 1
a26 1
png_voidp
d30 1
a30 1
   return (png_create_struct_2(type, NULL));
d34 2
a35 2
png_voidp
png_create_struct_2(int type, png_malloc_ptr malloc_fn)
d46 1
a46 1
     return ((png_voidp)NULL);
d51 4
a54 3
      if ((struct_ptr = (*(malloc_fn))(NULL, size)) != NULL)
         png_memset(struct_ptr, 0, size);
         return (struct_ptr);
d56 1
d58 2
a59 2
   if ((struct_ptr = (png_voidp)farmalloc(size)) != NULL)
   {
a60 1
   }
a63 1

d65 1
a65 1
void
d69 1
a69 1
   png_destroy_struct_2(struct_ptr, (png_free_ptr)NULL);
d73 3
a75 2
void
png_destroy_struct_2(png_voidp struct_ptr, png_free_ptr free_fn)
d85 1
a86 1
         struct_ptr = NULL;
a90 1
      struct_ptr = NULL;
d113 2
a114 1
png_voidp
a116 1
#ifndef PNG_USER_MEM_SUPPORTED
d118 1
a118 1
#endif
d120 1
a120 1
      return ((png_voidp)NULL);
d124 6
a129 1
       return ((png_voidp)(*(png_ptr->malloc_fn))(png_ptr, size));
d134 1
a134 1
png_voidp
d165 3
a167 2
            num_blocks = (int)(1 << (png_ptr->zlib_window_bits - 14));
            if (num_blocks < 1)
d180 5
a184 1
               png_error(png_ptr, "Out Of Memory."); /* Note "O" and "M" */
d189 7
a195 1
               png_error(png_ptr, "Farmalloc didn't return normalized pointer");
d204 5
a208 1
               png_error(png_ptr, "Out Of memory.");
d215 1
a215 1
               hptr += 16L;
d220 1
a220 1
               hptr += (png_uint_32)65536L;
d230 7
a236 1
         png_error(png_ptr, "Out of Memory.");
d245 4
a248 1
      png_error(png_ptr, "Out of memory."); /* Note "o" and "m" */
d257 1
a257 1
void
a266 1
      ptr = NULL;
d272 1
a272 1
void
d276 1
a276 1
      
a301 1
      ptr = NULL;
d309 2
a310 2
   to improve performance noticably.*/
png_voidp
d314 1
a314 1
   return (png_create_struct_2(type, NULL));
d319 3
a321 3
   to improve performance noticably.*/
png_voidp
png_create_struct_2(int type, png_malloc_ptr malloc_fn)
d332 1
a332 1
      return ((png_voidp)NULL);
d337 5
a341 1
      if ((struct_ptr = (*(malloc_fn))(NULL, size)) != NULL)
d365 1
a365 1
void
d369 1
a369 1
   png_destroy_struct_2(struct_ptr, (png_free_ptr)NULL);
d373 3
a375 2
void
png_destroy_struct_2(png_voidp struct_ptr, png_free_ptr free_fn)
d385 1
a386 1
         struct_ptr = NULL;
a391 1
      struct_ptr = NULL;
a394 1
      struct_ptr = NULL;
a396 1
      struct_ptr = NULL;
a401 1

d408 1
a408 1
png_voidp
a410 1
#ifndef PNG_USER_MEM_SUPPORTED
d412 1
a412 1
#endif
d414 1
a414 1
      return ((png_voidp)NULL);
d418 6
a423 1
       return ((png_voidp)(*(png_ptr->malloc_fn))(png_ptr, size));
d427 2
a428 1
png_voidp
d436 6
a441 1
      png_error(png_ptr, "Cannot Allocate > 64K");
d454 1
a454 2
   if (ret == NULL)
   {
a455 1
   }
d462 1
a462 1
void
a471 1
      ptr = NULL;
d476 1
a476 1
void
d479 3
a485 1
   ptr = NULL;
a488 1
   ptr = NULL;
a490 1
   ptr = NULL;
d497 21
a517 1
png_voidp
d526 1
a526 1
  
d530 1
a530 1
png_voidp
d548 1
a548 1
void
d561 1
a561 1
png_voidp
@


1.2.6.1
log
@sync branch with HEAD
@
text
@d4 1
a4 1
 * libpng 1.2.5 - October 3, 2002
d6 3
a8 3
 * Copyright (c) 1998-2002 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
d26 1
a26 1
png_voidp /* PRIVATE */
d30 1
a30 1
   return (png_create_struct_2(type, png_malloc_ptr_NULL, png_voidp_NULL));
d34 2
a35 2
png_voidp /* PRIVATE */
png_create_struct_2(int type, png_malloc_ptr malloc_fn, png_voidp mem_ptr)
d46 1
a46 1
     return (png_get_copyright());
d51 3
a53 4
      png_struct dummy_struct;
      png_structp png_ptr = &dummy_struct;
      png_ptr->mem_ptr=mem_ptr;
      struct_ptr = (*(malloc_fn))(png_ptr, (png_uint_32)size);
a54 1
   else
d56 2
a57 2
      struct_ptr = (png_voidp)farmalloc(size));
   if (struct_ptr != NULL)
d59 1
d63 1
d65 1
a65 1
void /* PRIVATE */
d69 1
a69 1
   png_destroy_struct_2(struct_ptr, png_free_ptr_NULL, png_voidp_NULL);
d73 2
a74 3
void /* PRIVATE */
png_destroy_struct_2(png_voidp struct_ptr, png_free_ptr free_fn,
    png_voidp mem_ptr)
a83 1
         png_ptr->mem_ptr=mem_ptr;
d85 1
d90 1
d113 1
a113 2

png_voidp PNGAPI
d116 1
d118 1
a118 1

d120 1
a120 1
      return (NULL);
d124 1
a124 6
   {
       ret = ((png_voidp)(*(png_ptr->malloc_fn))(png_ptr, (png_size_t)size));
       if (ret == NULL && (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
          png_error(png_ptr, "Out of memory!");
       return (ret);
   }
d129 1
a129 1
png_voidp PNGAPI
d160 2
a161 3
            if(png_ptr->zlib_window_bits > 14)
               num_blocks = (int)(1 << (png_ptr->zlib_window_bits - 14));
            else
d174 1
a174 5
               if (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
                  png_error(png_ptr, "Out Of Memory."); /* Note "O" and "M" */
               else
                  png_warning(png_ptr, "Out Of Memory.");
               return (NULL);
d179 1
a179 7
               if (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
                  png_error(png_ptr,
                    "Farmalloc didn't return normalized pointer");
               else
                  png_warning(png_ptr,
                    "Farmalloc didn't return normalized pointer");
               return (NULL);
d188 1
a188 5
               if (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
                  png_error(png_ptr, "Out Of memory."); /* Note "O" and "M" */
               else
                  png_warning(png_ptr, "Out Of memory.");
               return (NULL);
d195 1
a195 1
               hptr = hptr + 16L;  /* "hptr += 16L" fails on Turbo C++ 3.0 */
d200 1
a200 1
               hptr = hptr + (png_uint_32)65536L;  /* "+=" fails on TC++3.0 */
d210 1
a210 7
      {
         if (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
            png_error(png_ptr, "Out of Memory."); /* Note "o" and "M" */
         else
            png_warning(png_ptr, "Out of Memory.");
         return (NULL);
      }
d219 1
a219 4
      if (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
         png_error(png_ptr, "Out of memory."); /* Note "o" and "m" */
      else
         png_warning(png_ptr, "Out of memory."); /* Note "o" and "m" */
d228 1
a228 1
void PNGAPI
d238 1
d244 1
a244 1
void PNGAPI
d248 1
a248 1

d274 1
d282 2
a283 2
   to improve performance noticably. */
png_voidp /* PRIVATE */
d287 1
a287 1
   return (png_create_struct_2(type, png_malloc_ptr_NULL, png_voidp_NULL));
d292 3
a294 3
   to improve performance noticably. */
png_voidp /* PRIVATE */
png_create_struct_2(int type, png_malloc_ptr malloc_fn, png_voidp mem_ptr)
d305 1
a305 1
      return (NULL);
d310 1
a310 5
      png_struct dummy_struct;
      png_structp png_ptr = &dummy_struct;
      png_ptr->mem_ptr=mem_ptr;
      struct_ptr = (*(malloc_fn))(png_ptr, size);
      if (struct_ptr != NULL)
d334 1
a334 1
void /* PRIVATE */
d338 1
a338 1
   png_destroy_struct_2(struct_ptr, png_free_ptr_NULL, png_voidp_NULL);
d342 2
a343 3
void /* PRIVATE */
png_destroy_struct_2(png_voidp struct_ptr, png_free_ptr free_fn,
    png_voidp mem_ptr)
a352 1
         png_ptr->mem_ptr=mem_ptr;
d354 1
d360 1
d364 1
d367 1
d373 1
d380 1
a380 1
png_voidp PNGAPI
d383 1
d385 1
a385 1

d387 1
a387 1
      return (NULL);
d391 1
a391 6
   {
       ret = ((png_voidp)(*(png_ptr->malloc_fn))(png_ptr, (png_size_t)size));
       if (ret == NULL && (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
          png_error(png_ptr, "Out of Memory!");
       return (ret);
   }
d395 1
a395 2

png_voidp PNGAPI
d403 1
a403 6
   {
      if(png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
         png_error(png_ptr, "Cannot Allocate > 64K");
      else
         return NULL;
   }
d416 2
a417 1
   if (ret == NULL && (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
d419 1
d426 1
a426 1
void PNGAPI
d436 1
d441 1
a441 1
void PNGAPI
a443 3
   if (png_ptr == NULL || ptr == NULL)
      return;

d448 1
d452 1
d455 1
d462 1
a462 21
#if defined(PNG_1_0_X)
#  define png_malloc_warn png_malloc
#else
/* This function was added at libpng version 1.2.3.  The png_malloc_warn()
 * function will issue a png_warning and return NULL instead of issuing a
 * png_error, if it fails to allocate the requested memory.
 */
png_voidp PNGAPI
png_malloc_warn(png_structp png_ptr, png_uint_32 size)
{
   png_voidp ptr;
   png_uint_32 save_flags=png_ptr->flags;

   png_ptr->flags|=PNG_FLAG_MALLOC_NULL_MEM_OK;
   ptr = (png_voidp)png_malloc((png_structp)png_ptr, size);
   png_ptr->flags=save_flags;
   return(ptr);
}
#endif

png_voidp PNGAPI
d471 1
a471 1

d475 1
a475 1
png_voidp PNGAPI
d493 1
a493 1
void PNGAPI
d506 1
a506 1
png_voidp PNGAPI
@


1.2.8.1
log
@sync to HEAD...
@
text
@d4 1
a4 1
 * libpng 1.2.5 - October 3, 2002
d6 3
a8 3
 * Copyright (c) 1998-2002 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
d26 1
a26 1
png_voidp /* PRIVATE */
d30 1
a30 1
   return (png_create_struct_2(type, png_malloc_ptr_NULL, png_voidp_NULL));
d34 2
a35 2
png_voidp /* PRIVATE */
png_create_struct_2(int type, png_malloc_ptr malloc_fn, png_voidp mem_ptr)
d46 1
a46 1
     return (png_get_copyright());
d51 3
a53 4
      png_struct dummy_struct;
      png_structp png_ptr = &dummy_struct;
      png_ptr->mem_ptr=mem_ptr;
      struct_ptr = (*(malloc_fn))(png_ptr, (png_uint_32)size);
a54 1
   else
d56 2
a57 2
      struct_ptr = (png_voidp)farmalloc(size));
   if (struct_ptr != NULL)
d59 1
d63 1
d65 1
a65 1
void /* PRIVATE */
d69 1
a69 1
   png_destroy_struct_2(struct_ptr, png_free_ptr_NULL, png_voidp_NULL);
d73 2
a74 3
void /* PRIVATE */
png_destroy_struct_2(png_voidp struct_ptr, png_free_ptr free_fn,
    png_voidp mem_ptr)
a83 1
         png_ptr->mem_ptr=mem_ptr;
d85 1
d90 1
d113 1
a113 2

png_voidp PNGAPI
d116 1
d118 1
a118 1

d120 1
a120 1
      return (NULL);
d124 1
a124 6
   {
       ret = ((png_voidp)(*(png_ptr->malloc_fn))(png_ptr, (png_size_t)size));
       if (ret == NULL && (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
          png_error(png_ptr, "Out of memory!");
       return (ret);
   }
d129 1
a129 1
png_voidp PNGAPI
d160 2
a161 3
            if(png_ptr->zlib_window_bits > 14)
               num_blocks = (int)(1 << (png_ptr->zlib_window_bits - 14));
            else
d174 1
a174 5
               if (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
                  png_error(png_ptr, "Out Of Memory."); /* Note "O" and "M" */
               else
                  png_warning(png_ptr, "Out Of Memory.");
               return (NULL);
d179 1
a179 7
               if (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
                  png_error(png_ptr,
                    "Farmalloc didn't return normalized pointer");
               else
                  png_warning(png_ptr,
                    "Farmalloc didn't return normalized pointer");
               return (NULL);
d188 1
a188 5
               if (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
                  png_error(png_ptr, "Out Of memory."); /* Note "O" and "M" */
               else
                  png_warning(png_ptr, "Out Of memory.");
               return (NULL);
d195 1
a195 1
               hptr = hptr + 16L;  /* "hptr += 16L" fails on Turbo C++ 3.0 */
d200 1
a200 1
               hptr = hptr + (png_uint_32)65536L;  /* "+=" fails on TC++3.0 */
d210 1
a210 7
      {
         if (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
            png_error(png_ptr, "Out of Memory."); /* Note "o" and "M" */
         else
            png_warning(png_ptr, "Out of Memory.");
         return (NULL);
      }
d219 1
a219 4
      if (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
         png_error(png_ptr, "Out of memory."); /* Note "o" and "m" */
      else
         png_warning(png_ptr, "Out of memory."); /* Note "o" and "m" */
d228 1
a228 1
void PNGAPI
d238 1
d244 1
a244 1
void PNGAPI
d248 1
a248 1

d274 1
d282 2
a283 2
   to improve performance noticably. */
png_voidp /* PRIVATE */
d287 1
a287 1
   return (png_create_struct_2(type, png_malloc_ptr_NULL, png_voidp_NULL));
d292 3
a294 3
   to improve performance noticably. */
png_voidp /* PRIVATE */
png_create_struct_2(int type, png_malloc_ptr malloc_fn, png_voidp mem_ptr)
d305 1
a305 1
      return (NULL);
d310 1
a310 5
      png_struct dummy_struct;
      png_structp png_ptr = &dummy_struct;
      png_ptr->mem_ptr=mem_ptr;
      struct_ptr = (*(malloc_fn))(png_ptr, size);
      if (struct_ptr != NULL)
d334 1
a334 1
void /* PRIVATE */
d338 1
a338 1
   png_destroy_struct_2(struct_ptr, png_free_ptr_NULL, png_voidp_NULL);
d342 2
a343 3
void /* PRIVATE */
png_destroy_struct_2(png_voidp struct_ptr, png_free_ptr free_fn,
    png_voidp mem_ptr)
a352 1
         png_ptr->mem_ptr=mem_ptr;
d354 1
d360 1
d364 1
d367 1
d373 1
d380 1
a380 1
png_voidp PNGAPI
d383 1
d385 1
a385 1

d387 1
a387 1
      return (NULL);
d391 1
a391 6
   {
       ret = ((png_voidp)(*(png_ptr->malloc_fn))(png_ptr, (png_size_t)size));
       if (ret == NULL && (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
          png_error(png_ptr, "Out of Memory!");
       return (ret);
   }
d395 1
a395 2

png_voidp PNGAPI
d403 1
a403 6
   {
      if(png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
         png_error(png_ptr, "Cannot Allocate > 64K");
      else
         return NULL;
   }
d416 2
a417 1
   if (ret == NULL && (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
d419 1
d426 1
a426 1
void PNGAPI
d436 1
d441 1
a441 1
void PNGAPI
a443 3
   if (png_ptr == NULL || ptr == NULL)
      return;

d448 1
d452 1
d455 1
d462 1
a462 21
#if defined(PNG_1_0_X)
#  define png_malloc_warn png_malloc
#else
/* This function was added at libpng version 1.2.3.  The png_malloc_warn()
 * function will issue a png_warning and return NULL instead of issuing a
 * png_error, if it fails to allocate the requested memory.
 */
png_voidp PNGAPI
png_malloc_warn(png_structp png_ptr, png_uint_32 size)
{
   png_voidp ptr;
   png_uint_32 save_flags=png_ptr->flags;

   png_ptr->flags|=PNG_FLAG_MALLOC_NULL_MEM_OK;
   ptr = (png_voidp)png_malloc((png_structp)png_ptr, size);
   png_ptr->flags=save_flags;
   return(ptr);
}
#endif

png_voidp PNGAPI
d471 1
a471 1

d475 1
a475 1
png_voidp PNGAPI
d493 1
a493 1
void PNGAPI
d506 1
a506 1
png_voidp PNGAPI
@


1.1
log
@Initial revision
@
text
@d133 1
a133 1
#endif PNG_USER_MEM_SUPPORTED
@


1.1.1.1
log
@libpng 1.0.2
@
text
@@
