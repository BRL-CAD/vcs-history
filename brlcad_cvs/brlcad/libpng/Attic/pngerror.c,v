head	1.4;
access;
symbols
	ansi-20040405-merged:1.2.4.1
	postmerge-20040405-ansi:1.3
	premerge-20040404-ansi:1.3
	postmerge-autoconf:1.3
	autoconf-freeze:1.3
	premerge-autoconf:1.3
	ansi-20040316-freeze:1.2
	postmerge-20040315-windows:1.3
	premerge-20040315-windows:1.3
	windows-20040315-freeze:1.2.6.1
	autoconf-20031203:1.3
	autoconf-20031202:1.3
	autoconf-branch:1.3.0.6
	phong-branch:1.3.0.4
	photonmap-branch:1.3.0.2
	rel-6-1-DP:1.2
	windows-branch:1.2.0.6
	rel-6-0-2:1.2
	ansi-branch:1.2.0.4
	rel-6-0-1-branch:1.2.0.2
	hartley-6-0-post:1.2
	hartley-6-0-pre:1.2
	rel-6-0-1:1.2
	rel-6-0:1.2
	rel-5-4:1.1.1.1
	offsite-5-3-pre:1.1.1.1
	rel-5-3:1.1.1.1
	rel-5-2:1.1.1.1
	rel-5-1-branch:1.1.1.1.0.2
	rel-5-1:1.1.1.1
	rel-5-0:1.1.1.1
	rel-5-0-beta:1.1.1.1
	libpng_1_0_2:1.1.1.1
	libpng:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2004.05.21.18.05.27;	author morrison;	state dead;
branches;
next	1.3;

1.3
date	2002.12.26.14.39.09;	author jra;	state Exp;
branches;
next	1.2;

1.2
date	2001.04.20.22.29.37;	author morrison;	state Exp;
branches
	1.2.4.1
	1.2.6.1;
next	1.1;

1.1
date	98.06.24.20.00.14;	author jra;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.06.24.20.00.14;	author jra;	state Exp;
branches;
next	;

1.2.4.1
date	2004.03.17.21.18.35;	author morrison;	state Exp;
branches;
next	;

1.2.6.1
date	2004.03.11.23.43.20;	author morrison;	state Exp;
branches;
next	;


desc
@@


1.4
log
@moved from top-level to src/other/.
@
text
@
/* pngerror.c - stub functions for i/o and memory allocation
 *
 * libpng 1.2.5 - October 3, 2002
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1998-2002 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This file provides a location for all error handling.  Users who
 * need special error handling are expected to write replacement functions
 * and use png_set_error_fn() to use those functions.  See the instructions
 * at each function.
 */

#define PNG_INTERNAL
#include "png.h"

static void /* PRIVATE */
png_default_error PNGARG((png_structp png_ptr,
  png_const_charp error_message));
static void /* PRIVATE */
png_default_warning PNGARG((png_structp png_ptr,
  png_const_charp warning_message));

/* This function is called whenever there is a fatal error.  This function
 * should not be changed.  If there is a need to handle errors differently,
 * you should supply a replacement error function and use png_set_error_fn()
 * to replace the error function at run-time.
 */
void PNGAPI
png_error(png_structp png_ptr, png_const_charp error_message)
{
#ifdef PNG_ERROR_NUMBERS_SUPPORTED
   char msg[16];
   if (png_ptr->flags&(PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT))
   {
     int offset = 0;
     if (*error_message == '#')
     {
         for (offset=1; offset<15; offset++)
            if (*(error_message+offset) == ' ')
                break;
         if (png_ptr->flags&PNG_FLAG_STRIP_ERROR_TEXT)
         {
            int i;
            for (i=0; i<offset-1; i++)
               msg[i]=error_message[i+1];
            msg[i]='\0';
            error_message=msg;
         }
         else
            error_message+=offset;
     }
     else
     {
         if (png_ptr->flags&PNG_FLAG_STRIP_ERROR_TEXT)
         {
            msg[0]='0';        
            msg[1]='\0';
            error_message=msg;
         }
     }
   }
#endif
   if (png_ptr->error_fn != NULL)
      (*(png_ptr->error_fn))(png_ptr, error_message);

   /* if the following returns or doesn't exist, use the default function,
      which will not return */
   png_default_error(png_ptr, error_message);
}

/* This function is called whenever there is a non-fatal error.  This function
 * should not be changed.  If there is a need to handle warnings differently,
 * you should supply a replacement warning function and use
 * png_set_error_fn() to replace the warning function at run-time.
 */
void PNGAPI
png_warning(png_structp png_ptr, png_const_charp warning_message)
{
     int offset = 0;
#ifdef PNG_ERROR_NUMBERS_SUPPORTED
   if (png_ptr->flags&(PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT))
#endif
   {
     if (*warning_message == '#')
     {
         for (offset=1; offset<15; offset++)
            if (*(warning_message+offset) == ' ')
                break;
     }
   }
   if (png_ptr->warning_fn != NULL)
      (*(png_ptr->warning_fn))(png_ptr,
         (png_const_charp)(warning_message+offset));
   else
      png_default_warning(png_ptr, (png_const_charp)(warning_message+offset));
}

/* These utilities are used internally to build an error message that relates
 * to the current chunk.  The chunk name comes from png_ptr->chunk_name,
 * this is used to prefix the message.  The message is limited in length
 * to 63 bytes, the name characters are output as hex digits wrapped in []
 * if the character is invalid.
 */
#define isnonalpha(c) ((c) < 41 || (c) > 122 || ((c) > 90 && (c) < 97))
static PNG_CONST char png_digit[16] = {
   '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E',
   'F' };

static void /* PRIVATE */
png_format_buffer(png_structp png_ptr, png_charp buffer, png_const_charp
   error_message)
{
   int iout = 0, iin = 0;

   while (iin < 4)
   {
      int c = png_ptr->chunk_name[iin++];
      if (isnonalpha(c))
      {
         buffer[iout++] = '[';
         buffer[iout++] = png_digit[(c & 0xf0) >> 4];
         buffer[iout++] = png_digit[c & 0x0f];
         buffer[iout++] = ']';
      }
      else
      {
         buffer[iout++] = (png_byte)c;
      }
   }

   if (error_message == NULL)
      buffer[iout] = 0;
   else
   {
      buffer[iout++] = ':';
      buffer[iout++] = ' ';
      png_memcpy(buffer+iout, error_message, 64);
      buffer[iout+63] = 0;
   }
}

void PNGAPI
png_chunk_error(png_structp png_ptr, png_const_charp error_message)
{
   char msg[18+64];
   png_format_buffer(png_ptr, msg, error_message);
   png_error(png_ptr, msg);
}

void PNGAPI
png_chunk_warning(png_structp png_ptr, png_const_charp warning_message)
{
   char msg[18+64];
   png_format_buffer(png_ptr, msg, warning_message);
   png_warning(png_ptr, msg);
}

/* This is the default error handling function.  Note that replacements for
 * this function MUST NOT RETURN, or the program will likely crash.  This
 * function is used by default, or if the program supplies NULL for the
 * error function pointer in png_set_error_fn().
 */
static void /* PRIVATE */
png_default_error(png_structp png_ptr, png_const_charp error_message)
{
#ifndef PNG_NO_CONSOLE_IO
#ifdef PNG_ERROR_NUMBERS_SUPPORTED
   if (*error_message == '#')
   {
     int offset;
     char error_number[16];
     for (offset=0; offset<15; offset++)
     {
         error_number[offset] = *(error_message+offset+1);
         if (*(error_message+offset) == ' ')
             break;
     }
     if((offset > 1) && (offset < 15))
     {
       error_number[offset-1]='\0';
       fprintf(stderr, "libpng error no. %s: %s\n", error_number,
          error_message+offset);
     }
     else
       fprintf(stderr, "libpng error: %s, offset=%d\n", error_message,offset);
   }
   else
#endif
   fprintf(stderr, "libpng error: %s\n", error_message);
#else
   if (error_message)
     /* make compiler happy */ ;
#endif

#ifdef PNG_SETJMP_SUPPORTED
#  ifdef USE_FAR_KEYWORD
   {
      jmp_buf jmpbuf;
      png_memcpy(jmpbuf,png_ptr->jmpbuf,sizeof(jmp_buf));
      longjmp(jmpbuf, 1);
   }
#  else
   longjmp(png_ptr->jmpbuf, 1);
# endif
#else
   if (png_ptr)
     /* make compiler happy */ ;
   PNG_ABORT();
#endif
}

/* This function is called when there is a warning, but the library thinks
 * it can continue anyway.  Replacement functions don't have to do anything
 * here if you don't want them to.  In the default configuration, png_ptr is
 * not used, but it is passed in case it may be useful.
 */
static void /* PRIVATE */
png_default_warning(png_structp png_ptr, png_const_charp warning_message)
{
#ifndef PNG_NO_CONSOLE_IO
#  ifdef PNG_ERROR_NUMBERS_SUPPORTED
   if (*warning_message == '#')
   {
     int offset;
     char warning_number[16];
     for (offset=0; offset<15; offset++)
     {
        warning_number[offset]=*(warning_message+offset+1);
        if (*(warning_message+offset) == ' ')
            break;
     }
     if((offset > 1) && (offset < 15))
     {
       warning_number[offset-1]='\0';
       fprintf(stderr, "libpng warning no. %s: %s\n", warning_number,
          warning_message+offset);
     }
     else
       fprintf(stderr, "libpng warning: %s\n", warning_message);
   }
   else
#  endif
     fprintf(stderr, "libpng warning: %s\n", warning_message);
#else
   if (warning_message)
     /* appease compiler */ ;
#endif
   if (png_ptr)
      return;
}

/* This function is called when the application wants to use another method
 * of handling errors and warnings.  Note that the error function MUST NOT
 * return to the calling routine or serious problems will occur.  The return
 * method used in the default routine calls longjmp(png_ptr->jmpbuf, 1)
 */
void PNGAPI
png_set_error_fn(png_structp png_ptr, png_voidp error_ptr,
   png_error_ptr error_fn, png_error_ptr warning_fn)
{
   png_ptr->error_ptr = error_ptr;
   png_ptr->error_fn = error_fn;
   png_ptr->warning_fn = warning_fn;
}


/* This function returns a pointer to the error_ptr associated with the user
 * functions.  The application should free any memory associated with this
 * pointer before png_write_destroy and png_read_destroy are called.
 */
png_voidp PNGAPI
png_get_error_ptr(png_structp png_ptr)
{
   return ((png_voidp)png_ptr->error_ptr);
}


#ifdef PNG_ERROR_NUMBERS_SUPPORTED
void PNGAPI
png_set_strip_error_numbers(png_structp png_ptr, png_uint_32 strip_mode)
{
   if(png_ptr != NULL)
   {
     png_ptr->flags &=
       ((~(PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT))&strip_mode);
   }
}
#endif
@


1.3
log
@Update to libpng 1.2.5
@
text
@@


1.2
log
@CONST to const
@
text
@d4 1
a4 1
 * libpng 1.0.2 - June 14, 1998
d6 3
a8 3
 * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
 * Copyright (c) 1996, 1997 Andreas Dilger
 * Copyright (c) 1998, Glenn Randers-Pehrson
d19 6
a24 4
static void png_default_error PNGARG((png_structp png_ptr,
                                      png_const_charp message));
static void png_default_warning PNGARG((png_structp png_ptr,
                                        png_const_charp message));
d31 2
a32 2
void
png_error(png_structp png_ptr, png_const_charp message)
d34 32
d67 1
a67 1
      (*(png_ptr->error_fn))(png_ptr, message);
d71 1
a71 1
   png_default_error(png_ptr, message);
d79 2
a80 2
void
png_warning(png_structp png_ptr, png_const_charp message)
d82 12
d95 2
a96 1
      (*(png_ptr->warning_fn))(png_ptr, message);
d98 1
a98 1
      png_default_warning(png_ptr, message);
d108 7
a114 6
static PNG_const char png_digit[16] = {
   '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
};

static void
png_format_buffer(png_structp png_ptr, png_charp buffer, png_const_charp message)
d118 2
a119 1
   while (iin < 4) {
d121 2
a122 1
      if (isnonalpha(c)) {
d125 1
a125 1
         buffer[iout++] = png_digit[c & 0xf];
d127 4
a130 2
      } else {
         buffer[iout++] = c;
d134 1
a134 1
   if (message == NULL)
d136 2
a137 1
   else {
d140 1
a140 1
      png_memcpy(buffer+iout, message, 64);
d145 2
a146 2
void
png_chunk_error(png_structp png_ptr, png_const_charp message)
d148 2
a149 2
   char msg[16+64];
   png_format_buffer(png_ptr, msg, message);
d153 2
a154 2
void
png_chunk_warning(png_structp png_ptr, png_const_charp message)
d156 2
a157 2
   char msg[16+64];
   png_format_buffer(png_ptr, msg, message);
d166 2
a167 2
static void
png_default_error(png_structp png_ptr, png_const_charp message)
d169 27
a195 2
#ifndef PNG_NO_STDIO
   fprintf(stderr, "libpng error: %s\n", message);
d198 2
a199 1
#ifdef USE_FAR_KEYWORD
d205 3
d209 3
a211 1
   longjmp(png_ptr->jmpbuf, 1);
d220 2
a221 2
static void
png_default_warning(png_structp png_ptr, png_const_charp message)
d223 29
a251 1
   if (png_ptr == NULL)
a252 4

#ifndef PNG_NO_STDIO
   fprintf(stderr, "libpng warning: %s\n", message);
#endif
d260 1
a260 1
void
d274 1
a274 1
png_voidp
d281 11
a291 1

@


1.2.4.1
log
@sync branch with HEAD
@
text
@d4 1
a4 1
 * libpng 1.2.5 - October 3, 2002
d6 3
a8 3
 * Copyright (c) 1998-2002 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
d19 4
a22 6
static void /* PRIVATE */
png_default_error PNGARG((png_structp png_ptr,
  png_const_charp error_message));
static void /* PRIVATE */
png_default_warning PNGARG((png_structp png_ptr,
  png_const_charp warning_message));
d29 2
a30 2
void PNGAPI
png_error(png_structp png_ptr, png_const_charp error_message)
a31 32
#ifdef PNG_ERROR_NUMBERS_SUPPORTED
   char msg[16];
   if (png_ptr->flags&(PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT))
   {
     int offset = 0;
     if (*error_message == '#')
     {
         for (offset=1; offset<15; offset++)
            if (*(error_message+offset) == ' ')
                break;
         if (png_ptr->flags&PNG_FLAG_STRIP_ERROR_TEXT)
         {
            int i;
            for (i=0; i<offset-1; i++)
               msg[i]=error_message[i+1];
            msg[i]='\0';
            error_message=msg;
         }
         else
            error_message+=offset;
     }
     else
     {
         if (png_ptr->flags&PNG_FLAG_STRIP_ERROR_TEXT)
         {
            msg[0]='0';        
            msg[1]='\0';
            error_message=msg;
         }
     }
   }
#endif
d33 1
a33 1
      (*(png_ptr->error_fn))(png_ptr, error_message);
d37 1
a37 1
   png_default_error(png_ptr, error_message);
d45 2
a46 2
void PNGAPI
png_warning(png_structp png_ptr, png_const_charp warning_message)
a47 12
     int offset = 0;
#ifdef PNG_ERROR_NUMBERS_SUPPORTED
   if (png_ptr->flags&(PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT))
#endif
   {
     if (*warning_message == '#')
     {
         for (offset=1; offset<15; offset++)
            if (*(warning_message+offset) == ' ')
                break;
     }
   }
d49 1
a49 2
      (*(png_ptr->warning_fn))(png_ptr,
         (png_const_charp)(warning_message+offset));
d51 1
a51 1
      png_default_warning(png_ptr, (png_const_charp)(warning_message+offset));
d61 6
a66 7
static PNG_CONST char png_digit[16] = {
   '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E',
   'F' };

static void /* PRIVATE */
png_format_buffer(png_structp png_ptr, png_charp buffer, png_const_charp
   error_message)
d70 1
a70 2
   while (iin < 4)
   {
d72 1
a72 2
      if (isnonalpha(c))
      {
d75 1
a75 1
         buffer[iout++] = png_digit[c & 0x0f];
d77 2
a78 4
      }
      else
      {
         buffer[iout++] = (png_byte)c;
d82 1
a82 1
   if (error_message == NULL)
d84 1
a84 2
   else
   {
d87 1
a87 1
      png_memcpy(buffer+iout, error_message, 64);
d92 2
a93 2
void PNGAPI
png_chunk_error(png_structp png_ptr, png_const_charp error_message)
d95 2
a96 2
   char msg[18+64];
   png_format_buffer(png_ptr, msg, error_message);
d100 2
a101 2
void PNGAPI
png_chunk_warning(png_structp png_ptr, png_const_charp warning_message)
d103 2
a104 2
   char msg[18+64];
   png_format_buffer(png_ptr, msg, warning_message);
d113 2
a114 2
static void /* PRIVATE */
png_default_error(png_structp png_ptr, png_const_charp error_message)
d116 2
a117 27
#ifndef PNG_NO_CONSOLE_IO
#ifdef PNG_ERROR_NUMBERS_SUPPORTED
   if (*error_message == '#')
   {
     int offset;
     char error_number[16];
     for (offset=0; offset<15; offset++)
     {
         error_number[offset] = *(error_message+offset+1);
         if (*(error_message+offset) == ' ')
             break;
     }
     if((offset > 1) && (offset < 15))
     {
       error_number[offset-1]='\0';
       fprintf(stderr, "libpng error no. %s: %s\n", error_number,
          error_message+offset);
     }
     else
       fprintf(stderr, "libpng error: %s, offset=%d\n", error_message,offset);
   }
   else
#endif
   fprintf(stderr, "libpng error: %s\n", error_message);
#else
   if (error_message)
     /* make compiler happy */ ;
d120 1
a120 2
#ifdef PNG_SETJMP_SUPPORTED
#  ifdef USE_FAR_KEYWORD
d126 1
a126 1
#  else
a127 5
# endif
#else
   if (png_ptr)
     /* make compiler happy */ ;
   PNG_ABORT();
d136 2
a137 2
static void /* PRIVATE */
png_default_warning(png_structp png_ptr, png_const_charp warning_message)
d139 5
a143 27
#ifndef PNG_NO_CONSOLE_IO
#  ifdef PNG_ERROR_NUMBERS_SUPPORTED
   if (*warning_message == '#')
   {
     int offset;
     char warning_number[16];
     for (offset=0; offset<15; offset++)
     {
        warning_number[offset]=*(warning_message+offset+1);
        if (*(warning_message+offset) == ' ')
            break;
     }
     if((offset > 1) && (offset < 15))
     {
       warning_number[offset-1]='\0';
       fprintf(stderr, "libpng warning no. %s: %s\n", warning_number,
          warning_message+offset);
     }
     else
       fprintf(stderr, "libpng warning: %s\n", warning_message);
   }
   else
#  endif
     fprintf(stderr, "libpng warning: %s\n", warning_message);
#else
   if (warning_message)
     /* appease compiler */ ;
a144 2
   if (png_ptr)
      return;
d152 1
a152 1
void PNGAPI
d166 1
a166 1
png_voidp PNGAPI
d173 1
a173 11
#ifdef PNG_ERROR_NUMBERS_SUPPORTED
void PNGAPI
png_set_strip_error_numbers(png_structp png_ptr, png_uint_32 strip_mode)
{
   if(png_ptr != NULL)
   {
     png_ptr->flags &=
       ((~(PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT))&strip_mode);
   }
}
#endif
@


1.2.6.1
log
@sync to HEAD...
@
text
@d4 1
a4 1
 * libpng 1.2.5 - October 3, 2002
d6 3
a8 3
 * Copyright (c) 1998-2002 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
d19 4
a22 6
static void /* PRIVATE */
png_default_error PNGARG((png_structp png_ptr,
  png_const_charp error_message));
static void /* PRIVATE */
png_default_warning PNGARG((png_structp png_ptr,
  png_const_charp warning_message));
d29 2
a30 2
void PNGAPI
png_error(png_structp png_ptr, png_const_charp error_message)
a31 32
#ifdef PNG_ERROR_NUMBERS_SUPPORTED
   char msg[16];
   if (png_ptr->flags&(PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT))
   {
     int offset = 0;
     if (*error_message == '#')
     {
         for (offset=1; offset<15; offset++)
            if (*(error_message+offset) == ' ')
                break;
         if (png_ptr->flags&PNG_FLAG_STRIP_ERROR_TEXT)
         {
            int i;
            for (i=0; i<offset-1; i++)
               msg[i]=error_message[i+1];
            msg[i]='\0';
            error_message=msg;
         }
         else
            error_message+=offset;
     }
     else
     {
         if (png_ptr->flags&PNG_FLAG_STRIP_ERROR_TEXT)
         {
            msg[0]='0';        
            msg[1]='\0';
            error_message=msg;
         }
     }
   }
#endif
d33 1
a33 1
      (*(png_ptr->error_fn))(png_ptr, error_message);
d37 1
a37 1
   png_default_error(png_ptr, error_message);
d45 2
a46 2
void PNGAPI
png_warning(png_structp png_ptr, png_const_charp warning_message)
a47 12
     int offset = 0;
#ifdef PNG_ERROR_NUMBERS_SUPPORTED
   if (png_ptr->flags&(PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT))
#endif
   {
     if (*warning_message == '#')
     {
         for (offset=1; offset<15; offset++)
            if (*(warning_message+offset) == ' ')
                break;
     }
   }
d49 1
a49 2
      (*(png_ptr->warning_fn))(png_ptr,
         (png_const_charp)(warning_message+offset));
d51 1
a51 1
      png_default_warning(png_ptr, (png_const_charp)(warning_message+offset));
d61 6
a66 7
static PNG_CONST char png_digit[16] = {
   '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E',
   'F' };

static void /* PRIVATE */
png_format_buffer(png_structp png_ptr, png_charp buffer, png_const_charp
   error_message)
d70 1
a70 2
   while (iin < 4)
   {
d72 1
a72 2
      if (isnonalpha(c))
      {
d75 1
a75 1
         buffer[iout++] = png_digit[c & 0x0f];
d77 2
a78 4
      }
      else
      {
         buffer[iout++] = (png_byte)c;
d82 1
a82 1
   if (error_message == NULL)
d84 1
a84 2
   else
   {
d87 1
a87 1
      png_memcpy(buffer+iout, error_message, 64);
d92 2
a93 2
void PNGAPI
png_chunk_error(png_structp png_ptr, png_const_charp error_message)
d95 2
a96 2
   char msg[18+64];
   png_format_buffer(png_ptr, msg, error_message);
d100 2
a101 2
void PNGAPI
png_chunk_warning(png_structp png_ptr, png_const_charp warning_message)
d103 2
a104 2
   char msg[18+64];
   png_format_buffer(png_ptr, msg, warning_message);
d113 2
a114 2
static void /* PRIVATE */
png_default_error(png_structp png_ptr, png_const_charp error_message)
d116 2
a117 27
#ifndef PNG_NO_CONSOLE_IO
#ifdef PNG_ERROR_NUMBERS_SUPPORTED
   if (*error_message == '#')
   {
     int offset;
     char error_number[16];
     for (offset=0; offset<15; offset++)
     {
         error_number[offset] = *(error_message+offset+1);
         if (*(error_message+offset) == ' ')
             break;
     }
     if((offset > 1) && (offset < 15))
     {
       error_number[offset-1]='\0';
       fprintf(stderr, "libpng error no. %s: %s\n", error_number,
          error_message+offset);
     }
     else
       fprintf(stderr, "libpng error: %s, offset=%d\n", error_message,offset);
   }
   else
#endif
   fprintf(stderr, "libpng error: %s\n", error_message);
#else
   if (error_message)
     /* make compiler happy */ ;
d120 1
a120 2
#ifdef PNG_SETJMP_SUPPORTED
#  ifdef USE_FAR_KEYWORD
d126 1
a126 1
#  else
a127 5
# endif
#else
   if (png_ptr)
     /* make compiler happy */ ;
   PNG_ABORT();
d136 2
a137 2
static void /* PRIVATE */
png_default_warning(png_structp png_ptr, png_const_charp warning_message)
d139 5
a143 27
#ifndef PNG_NO_CONSOLE_IO
#  ifdef PNG_ERROR_NUMBERS_SUPPORTED
   if (*warning_message == '#')
   {
     int offset;
     char warning_number[16];
     for (offset=0; offset<15; offset++)
     {
        warning_number[offset]=*(warning_message+offset+1);
        if (*(warning_message+offset) == ' ')
            break;
     }
     if((offset > 1) && (offset < 15))
     {
       warning_number[offset-1]='\0';
       fprintf(stderr, "libpng warning no. %s: %s\n", warning_number,
          warning_message+offset);
     }
     else
       fprintf(stderr, "libpng warning: %s\n", warning_message);
   }
   else
#  endif
     fprintf(stderr, "libpng warning: %s\n", warning_message);
#else
   if (warning_message)
     /* appease compiler */ ;
a144 2
   if (png_ptr)
      return;
d152 1
a152 1
void PNGAPI
d166 1
a166 1
png_voidp PNGAPI
d173 1
a173 11
#ifdef PNG_ERROR_NUMBERS_SUPPORTED
void PNGAPI
png_set_strip_error_numbers(png_structp png_ptr, png_uint_32 strip_mode)
{
   if(png_ptr != NULL)
   {
     png_ptr->flags &=
       ((~(PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT))&strip_mode);
   }
}
#endif
@


1.1
log
@Initial revision
@
text
@d61 1
a61 1
static PNG_CONST char png_digit[16] = {
@


1.1.1.1
log
@libpng 1.0.2
@
text
@@
