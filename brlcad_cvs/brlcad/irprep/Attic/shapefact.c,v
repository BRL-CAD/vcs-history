head	11.15;
access;
symbols
	ansi-20040405-merged:11.11.2.2
	postmerge-20040405-ansi:11.13
	premerge-20040404-ansi:11.12
	postmerge-autoconf:11.12
	autoconf-freeze:11.11.10.2
	premerge-autoconf:11.12
	ansi-20040316-freeze:11.11.2.1
	postmerge-20040315-windows:11.12
	premerge-20040315-windows:11.12
	windows-20040315-freeze:11.11.4.1
	autoconf-20031203:11.11
	autoconf-20031202:11.11
	autoconf-branch:11.11.0.10
	phong-branch:11.11.0.8
	photonmap-branch:11.11.0.6
	rel-6-1-DP:11.11
	windows-branch:11.11.0.4
	rel-6-0-2:11.9
	ansi-branch:11.11.0.2
	rel-6-0-1-branch:11.9.0.2
	hartley-6-0-post:11.10
	hartley-6-0-pre:11.9
	rel-6-0-1:11.9
	rel-6-0:11.9
	rel-5-4:11.4
	offsite-5-3-pre:11.6
	rel-5-3:11.4
	rel-5-2:11.4
	rel-5-1-branch:11.4.0.2
	rel-5-1:11.4
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.15
date	2004.05.24.04.00.38;	author morrison;	state dead;
branches;
next	11.14;

11.14
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	11.13;

11.13
date	2004.04.05.07.47.44;	author morrison;	state Exp;
branches;
next	11.12;

11.12
date	2004.02.02.17.39.06;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2002.08.20.17.07.32;	author jra;	state Exp;
branches
	11.11.2.1
	11.11.4.1
	11.11.10.1;
next	11.10;

11.10
date	2002.08.15.20.54.44;	author hartley;	state Exp;
branches;
next	11.9;

11.9
date	2001.10.15.19.58.03;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2001.08.09.20.09.10;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	2001.04.20.22.28.56;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	2000.10.24.19.32.54;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	2000.08.24.23.10.21;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	2000.01.31.16.25.34;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	99.12.23.06.16.04;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	98.09.14.15.59.14;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.22.53;	author mike;	state Rel4_4;
branches;
next	10.6;

10.6
date	94.12.12.22.18.01;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.08.24.18.11.26;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	93.02.18.09.56.16;	author scoates;	state Exp;
branches;
next	10.3;

10.3
date	92.09.17.08.16.32;	author scoates;	state Exp;
branches;
next	10.2;

10.2
date	92.09.15.13.40.02;	author scoates;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.53.43;	author mike;	state Rel4_0;
branches;
next	1.13;

1.13
date	91.07.27.01.52.30;	author butler;	state Exp;
branches;
next	1.12;

1.12
date	91.07.23.17.07.33;	author butler;	state Exp;
branches;
next	1.11;

1.11
date	91.07.23.01.38.44;	author butler;	state Exp;
branches;
next	1.10;

1.10
date	91.07.23.01.17.23;	author butler;	state Exp;
branches;
next	1.9;

1.9
date	91.07.19.02.17.35;	author butler;	state Exp;
branches;
next	1.8;

1.8
date	91.07.15.23.19.35;	author butler;	state Exp;
branches;
next	1.7;

1.7
date	91.07.11.22.11.13;	author butler;	state Exp;
branches;
next	1.6;

1.6
date	91.07.03.01.18.28;	author butler;	state Exp;
branches;
next	1.5;

1.5
date	91.07.02.23.40.35;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	91.07.01.23.39.33;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	91.07.01.23.17.30;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	91.06.08.03.08.24;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	91.06.08.02.50.24;	author mike;	state Exp;
branches;
next	;

11.11.2.1
date	2002.09.19.18.01.01;	author morrison;	state Exp;
branches;
next	11.11.2.2;

11.11.2.2
date	2004.03.17.21.16.35;	author morrison;	state Exp;
branches;
next	;

11.11.4.1
date	2004.03.11.23.41.22;	author morrison;	state Exp;
branches;
next	;

11.11.10.1
date	2004.02.12.19.50.38;	author erikg;	state Exp;
branches;
next	11.11.10.2;

11.11.10.2
date	2004.03.15.14.06.13;	author erikg;	state Exp;
branches;
next	;


desc
@IRPREP, Shape Factor calculation
@


11.15
log
@moved to src/irprep/
@
text
@/*
 *			S H A P E F A C T . C
 *
 *  Program to find shape factors for the engine by firing random rays.
 *  This program fires parallel rays.
 *
 *  Author -
 *	S.Coates - 27 February 1992
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 */

/*	23 May 1991       - Take out lvpt that wasn't necessary.  */
/*		Put in optional dump.  Sum shape factors.  */
/*	30 August 1991    - Put in option to create a generic  */
/*		shape factor file.  */
/*	30 October 1991   - Read region number & name file to get  */
/*		get region number that matches region number from  */
/*		firpass & secpass.  Print out engine area in  */
/*		shapefactor file.  */
/*	 4 November 1991  - Fire reversed ray in order to have  */
/*		reciprocity.  (i.e. sf[ij] * A[i] = sf[ji] * A[j])  */
/*	 8 November 1991  - Fix number of rays to divide by when finding  */
/*		engine area.  */
/*	13 November 1991  - Put check in for rays leaving i & entering j  */
/*		not equal to number of rays leaving j & entering i.  */
/*	15 November 1991  - Change a print statement.  */
/*	22 November 1991  - Change the number of maximum regions to 200.  */
/*	25 November 1991  - Put in print statements for error checking.  */
/*	27 November 1991  - If only air is hit it hit function return 1  */
/*		indicating miss.  */
/*	 3 December 1991  - Add some comments.  */
/*	27 February 1992  - Remove backward firing ray & replace with  */
/*		simpilar solution.  If the ray goes from region i to  */
/*		region j through engine air N(i) & N(i,j) are incremented.  */
/*		Simply increment N(j) & N(j,i) also.  EASY.  Add loop  */
/*		to check reciprocity.  Fix problem with number of rays  */
/*		leaving a region.  To compute engine area the total number  */
/*		of rays leaving a region and entering engine air must be  */
/*		used.  Not the total that leave throught engine air and  */
/*		hit another region.  */

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/irprep/shapefact.c,v 11.14 2004/05/10 15:30:43 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <math.h>

/*  Need the following for rt_shootray.  */
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
#include "msr.h"


#if !defined(PI)
#define PI 3.14159265358979323846262	/*  Pi.  */
#endif
#define ADJTOL 1.e-1	/*  Tolerance for adjacent regions.  */
#define ZEROTOL 1.e-20	/*  Zero tolerance.  */
#define MAXREG 200	/*  Maximum number of regions.  */

struct application ap;	/*  Structure passed between functions.  */

extern int hit(register struct application *ap_p, struct partition *PartHeadp);	/*  User supplied hit function.  */
extern int miss(void);	/*  User supplied miss function.  */
extern int overlap(void);	/*  User supplied overlap function.  */

/*  Define structure to hold all information needed.  */
struct table
{
   const char *name;	/*  Region name.  */
   int regnum;		/*  Region number that matches firpass &  */
			/*  secpass.  */
   int numchar;		/*  Number of char each region name has.  */
   double lvrays;	/*  Number of rays that leave the region through  */
			/*  air and hit another region.  */
   double intrays[MAXREG];	/*  Number of rays that leave region  */
			/*  through air and are intercepted.  */
   double allvrays;	/*  All rays that leave a region through engine  */
			/*  air.  */
   double engarea;	/*  Engine area for each region.  */
};
struct table info[MAXREG];
double nummiss;		/*  Number of misses.  */


#ifndef HAVE_DRAND48
/* simulate drand48() --  using 31-bit random() -- assumed to exist */
double drand48() {
  extern long random();
  return (double)random() / 2147483648.0; /* range [0,1) */
}
#endif

int main(int argc, char **argv)
{
   extern struct table info[];	/*  Structure is external.  */
   struct rt_i *rtip;
   int index;		/*  Index for rt_dirbuild & rt_gettree.  */
   char idbuf[32];	/*  Contains database name.  */
   struct region *pr;	/*  Used in finding region names.  */
   double rho,phi,theta;/*  Spherical coordinates for starting point.  */
   double areabs=0.0;	/*  Area of bounding sphere (mm**2).  */
   int ians;		/*  Answer of question.  */
   double strtpt[3];	/*  Starting point of ray.  */
   double strtdir[3];	/*  Starting direction.  */
   double loops;	/*  Number of rays fired.  */
   double r;		/*  Variable in loops.  */
   int i,j,k;		/*  Variable in loops.  */
   long seed;		/*  Initial seed for random number generator.  */
   double denom;	/*  Denominator.  */
   double elev;		/*  Elevation, used to find point on yz-plane.  */
   double az;		/*  Azimuth, used to find point on yz-plane.  */
   double rad;		/*  Radius, used to find point on yz-plane.  */
   double s[3],t[3];	/*  Temporary variables used to find points.  */
   double q;		/*  Temporary variable used to find points.  */
   int numreg;		/*  Number of regions.  */
   double center[3];	/*  Center of the bounding rpp.  */
   double sf;		/*  Used to print shape factor.  */
   double dump;		/*  How often a dump is to occur.  */
   int idump;		/*  1=>dump to occur.  */

   FILE *fp;		/*  Used to open files.  */
   char outfile[16];	/*  Output file.  */
   FILE *fp1;		/*  Used to read region # & name file.  */
   char rnnfile[16];	/*  Region # & name file.  */
   FILE *fp2;		/*  Used to write the error file.  */
   char errfile[16];	/*  Error file.  */
   double totalsf;	/*  Sum of shape factors.  */
   double totalnh;	/*  Sum of number of hits.  */
   int itype;		/*  Type of file to be created, 0=>regular,  */
			/*  1=>generic.  */
   char line[500];	/*  Buffer to read a line of data into.  */
   int c;		/*  Reads one character of information.  */
   int icnt;		/*  Counter for shape factor.  */
   char tmpname[150];	/*  Temporary name.  */
   int tmpreg;		/*  Temporary region number.  */
   char rnnname[800][150];  /*  Region name from region # & name file.  */
   int rnnnum;		/*  Number of regions in region # & name file.  */
   int rnnchar[800];	/*  Number of characters in name.  */
   int rnnreg[800];	/*  Region number from region # & name file.  */
   int jcnt;		/*  Counter.  */
   int equal;		/*  0=>equal, 1=>not equal.  */
   double rcpi,rcpj;	/*  Used to check reciprocity.  */
   double rcp_diff;	/*  Difference in reciprocity.  */
   double rcp_pdiff;	/*  Percent difference in reciprocity.  */

   /*  Check to see if arguments are implimented correctly.  */
   if( (argv[1] == NULL) || (argv[2] == NULL) )
   {
	(void)fprintf(stderr,"\nusage:  %s file.g objects\n\n", *argv);
   }
   else
   {						/*  START # 1  */

	/*  Ask what type of file is to be created - regualar  */
	/*  or generic.  */
	(void)printf("Enter type of file to be written (0=>regular or ");
	(void)printf("1=>generic).  ");
	(void)fflush(stdout);
	(void)scanf("%d",&itype);
	if(itype != 1) itype = 0;

	/*  Enter names of files to be used.  */
	(void)fprintf(stderr,"Enter name of output file (15 char max).\n\t");
	(void)fflush(stderr);
	(void)scanf("%s",outfile);

	/*  Read name of the error file to be written.  */
	(void)printf("Enter the name of the error file (15 char max).\n\t");
	(void)fflush(stdout);
	(void)scanf("%s",errfile);

	/*  Enter name of region # & name file to be read.  */
	{
	 (void)printf("Enter region # & name file to be read ");
	 (void)printf("(15 char max).\n\t");
	 (void)fflush(stdout);
	 (void)scanf("%s",rnnfile);
	}

	/*  Check if dump is to occur.  */
	idump = 0;
	(void)printf("Do you want to dump intermediate shape factors to ");
	(void)printf("screen (0-no, 1-yes)?  ");
	(void)fflush(stdout);
	(void)scanf("%d",&idump);

	/*  Find number of rays to be fired.  */
	(void)fprintf(stderr,"Enter number of rays to be fired.  ");
	(void)fflush(stderr);
	(void)scanf("%lf",&loops);

	/*  Set seed for random number generator.  */
	seed = 1;
	(void)fprintf(stderr,"Do you wish to enter your own seed (0) or ");
	(void)fprintf(stderr,"use the default of 1 (1)?  ");
	(void)fflush(stderr);
	(void)scanf("%d",&ians);
	if(ians == 0)
	{
		(void)fprintf(stderr,"Enter unsigned integer seed.  ");
		(void)fflush(stderr);
		(void)scanf("%ld",&seed);
	}
#ifdef MSRMAXTBL
   	msr = msr_unif_init(seed, 0);
#else
#  ifndef HAVE_DRAND48
	(void) srandom(seed);
#  else
	(void) srand48(seed);
#  endif
#endif
   	rt_log("seed initialized\n");

	/*  Read region # & name file.  */
	 rnnnum = 0;
	 fp1 = fopen(rnnfile,"r");
/*
 *	 (void)printf("Region # & name file opened.\n");
 *	 (void)fflush(stdout);
 */
	 c = getc(fp1);
	 while(c != EOF)
	 {
		(void)ungetc(c,fp1);
		(void)fgets(line,200,fp1);
		(void)sscanf(line,"%d%s",&tmpreg,tmpname);
		for(i=0; i<150; i++)
		{
		   rnnname[rnnnum][i] = tmpname[i];
		}
		rnnreg[rnnnum] = tmpreg;
		rnnnum++;
		c = getc(fp1);
	 }
	 (void)fclose(fp1);
/*
 *	 (void)printf("Region # & name file closed.\n");
 *	 (void)fflush(stdout);
 */

	 (void)printf("Number of regions read from region # & name file:  %d\n",		rnnnum);
	 (void)fflush(stdout);

	 /*  Find number of characters in each region name.  */
	 for(i=0; i<rnnnum; i++)
	 {
	   jcnt = 0;
	   while(rnnname[i][jcnt] != '\0')
	   {
		jcnt++;
	   }
	   rnnchar[i] = jcnt;
/*
 *	   (void)printf("number of char, i= %d:  %d\n",i,rnnchar[i]);
 *	   (void)fflush(stdout);
 */
	 }

	 /*  Check to see that region # & name file read correctly.  */
/*
 *	 for(i=0; i<rnnnum; i++)
 *	 {
 *	   (void)printf("%d\t%d\t-%s-\n",i,rnnchar[i],rnnname[i]);
 *	   (void)fflush(stdout);
 *	 }
 */

	/*  Build directory.  */
	index = 1;	/*  Set index for rt_dirbuild.  */
	rtip = rt_dirbuild(argv[index],idbuf,sizeof(idbuf));
	(void)printf("Database Title:  %s\n",idbuf);
	(void)fflush(stdout);

	/*  Set useair to 1 to show hits of air.  */
	rtip->useair = 1;

	/*  Load desired objects.  */
	index = 2;	/*  Set index.  */
	while(argv[index] != NULL)
	{
		rt_gettree(rtip,argv[index]);
		index += 1;
	}

	/*  Find number of regions.  */
	numreg = (int)rtip->nregions;

	(void)fprintf(stderr,"Number of regions:  %d\n",numreg);
	(void)fflush(stderr);

	/*  Zero all arrays.  */
	for(i=0; i<numreg; i++)
	{
		info[i].name = "\0";
		info[i].regnum = (-1);
		info[i].numchar = 0;
		info[i].lvrays = 0.;
		info[i].engarea = 0.;
		for(j=0; j<numreg; j++)
		{
			info[i].intrays[j] = 0.;
		}
	}
	nummiss = 0.;

	/*  Get database ready by starting prep.  */
	rt_prep(rtip);

	/*  Find the center of the bounding rpp.  */
	center[X] = rtip->mdl_min[X] +
		(rtip->mdl_max[X] - rtip->mdl_min[X]) / 2.;
	center[Y] = rtip->mdl_min[Y] +
		(rtip->mdl_max[Y] - rtip->mdl_min[Y]) / 2.;
	center[Z] = rtip->mdl_min[Z] +
		(rtip->mdl_max[Z] - rtip->mdl_min[Z]) / 2.;

	/*  Put region names into structure.  */
        pr = BU_LIST_FIRST(region, &rtip->HeadRegion);
	for(i=0; i<numreg; i++)
	{
	   info[(int)(pr->reg_bit)].name = pr->reg_name;
           pr = BU_LIST_FORW(region, &(pr->l) );
	}
/*
 *	for(i=0; i<numreg; i++)
 *	{
 *		(void)printf("%d - %s\n",i,info[i].name);
 *		(void)fflush(stdout);
 *	}
 */

/*
 *	(void)printf("Region names in structure.\n");
 *	(void)fflush(stdout);
 */

	/*  Set up parameters for rt_shootray.  */
	ap.a_hit = hit;		/*  User supplied hit function.  */
	ap.a_miss = miss;	/*  User supplied miss function.  */
	ap.a_overlap = overlap;	/*  User supplied overlap function.  */
	ap.a_rt_i = rtip;	/*  Pointer from rt_dirbuild.  */
	ap.a_onehit = 0;	/*  Look at all hits.  */
	ap.a_level = 0;		/*  Recursion level for diagnostics.  */
	ap.a_resource = 0;	/*  Address for resource structure.  */

	dump = 1000000.;	/*  Used for dumping info.  */

	for(r=0; r<loops; r++)	/*  Number of rays fired.  */
	{					/*  START # 2  */
/*
 *	   (void)fprintf(stderr,"loop # %f\n",r);
 */

	   /*  Find length of 'diagonal' (rho).  (In reality rho is  */
	   /*  the radius of bounding sphere).  */
	   rho = (rtip->mdl_max[X] - rtip->mdl_min[X])
	   	   * (rtip->mdl_max[X] - rtip->mdl_min[X])
	   	+(rtip->mdl_max[Y] - rtip->mdl_min[Y])
	   	   * (rtip->mdl_max[Y] - rtip->mdl_min[Y])
	   	+(rtip->mdl_max[Z] - rtip->mdl_min[Z])
	   	   * (rtip->mdl_max[Z] - rtip->mdl_min[Z]);
	   rho = sqrt(rho) / 2. + .5;

	   /*  find surface area of bounding sphere.  */
	   areabs = 4. * PI * rho * rho;

	   /*  Second way to find starting point and direction.  */
	   /*  This approach finds the starting point and direction  */
	   /*  by using parallel rays.  */

	   /*  Find point on the bounding sphere.  (The negative  */
	   /*  of the unit vector of this point will eventually be  */
	   /*  the firing direction.  */
/*
 *	   (void)printf("\n\nrho:  %f\n",rho);
 *	   (void)fflush(stdout);
 */
#ifdef MSRMAXTBL
	   q = MSR_UNIF_DOUBLE(msr) + 0.5;
#else
	   q = drand48();
#endif
	   theta = q * 2. * PI;
/*
 *	   (void)printf("random number:  %f, theta:  %f\n",q,theta);
 *	   (void)fflush(stdout);
 */
#ifdef MSRMAXTBL
	   q = MSR_UNIF_DOUBLE(msr) + 0.5;
#else
	   q = drand48();
#endif
	   phi = ( q * 2.) - 1.;
	   phi = acos(phi);
/*
 *	   (void)printf("random number:  %f, phi:  %f\n",q,phi);
 *	   (void)fflush(stdout);
 */
	   strtdir[X] = rho * sin(phi) * cos(theta);
	   strtdir[Y] = rho * sin(phi) * sin(theta);
	   strtdir[Z] = rho * cos(phi);
/*
 *	   (void)printf("starting direction:  %f, %f, %f\n",strtdir[X],
 *		strtdir[Y],strtdir[Z]);
 *	   (void)fflush(stdout);
 */

	   /*  Elevation and azimuth for finding a vector in a plane.  */
	   elev = PI / 2. - phi;
	   az = theta;
/*
 *	   (void)printf("elevation:  %f, azimuth:  %f\n",elev,az);
 *	   (void)fflush(stdout);
 */

	   /*  Find vector in yz-plane.  */

#ifdef MSRMAXTBL
	   q = MSR_UNIF_DOUBLE(msr) + 0.5;
#else
	   q = drand48();
#endif
	   theta = q * 2. * PI;
/*
 *	   (void)printf("random number:  %f, theta:  %f\n",q,theta);
 *	   (void)fflush(stdout);
 */
#ifdef MSRMAXTBL
	   q = MSR_UNIF_DOUBLE(msr) + 0.5;
#else
	   q = drand48();
#endif
	   rad = rho * sqrt( q );
/*
 *	   (void)printf("random number:  %f, rad:  %f\n",q,rad);
 *	   (void)fflush(stdout);
 */
	   s[X] = 0.;
	   s[Y] = rad * cos(theta);
	   s[Z] = rad * sin(theta);
/*
 *	   (void)printf("vector in yz-plane:  %f, %f, %f\n",s[X],s[Y],s[Z]);
 *	   (void)fflush(stdout);
 */

	   /*  Rotate vector.  */
	   t[X] = s[X] * cos(elev) * cos(az) - s[Z] * sin(elev) * cos(az)
			- s[Y] * sin(az);
	   t[Y] = s[X] * cos(elev) * sin(az) - s[Z] * sin(elev) * sin(az)
			+ s[Y] * cos(az);
	   t[Z] = s[X] * sin(elev) + s[Z] * cos(elev);
/*
 *	   (void)printf("rotated vector:  %f, %f, %f\n",t[X],t[Y],t[Z]);
 *	   (void)fflush(stdout);
 */

	   /*  Translate the point.  This is starting point.  */
	   strtpt[X] = t[X] + strtdir[X];
	   strtpt[Y] = t[Y] + strtdir[Y];
	   strtpt[Z] = t[Z] + strtdir[Z];
/*
 *	   (void)printf("translated point:  %f, %f, %f\n",strtpt[X],
 *		strtpt[Y],strtpt[Z]);
 *	   (void)fflush(stdout);
 */

	   /*  Now transfer starting point so that it is in  */
	   /*  the absolute coordinates not the origin's.  */
	   strtpt[X] += center[X];
	   strtpt[Y] += center[Y];
	   strtpt[Z] += center[Z];

/*
 *	   (void)printf("point in absolute coordinates:  %f, %f, %f\n",
 *		strtpt[X],strtpt[Y],strtpt[Z]);
 *	   (void)fflush(stdout);
 */

	   /*  Normalize starting direction and make negative.  */
	   denom = strtdir[X] * strtdir[X] +
	           strtdir[Y] * strtdir[Y] +
	           strtdir[Z] * strtdir[Z];
	   denom = sqrt(denom);
	   strtdir[X] /= (-denom);
	   strtdir[Y] /= (-denom);
	   strtdir[Z] /= (-denom);

/*
 *	   (void)printf("starting direction (normalized):  %f, %f, %f\n",
 *		strtdir[X],strtdir[Y],strtdir[Z]);
 *	   (void)fflush(stdout);
 */

	   /*  Set up firing point and direction.  */
	   ap.a_ray.r_pt[X] = strtpt[X];
	   ap.a_ray.r_pt[Y] = strtpt[Y];
	   ap.a_ray.r_pt[Z] = strtpt[Z];
	   ap.a_ray.r_dir[X] = strtdir[X];
	   ap.a_ray.r_dir[Y] = strtdir[Y];
	   ap.a_ray.r_dir[Z] = strtdir[Z];

/*
 *	   (void)printf("Calling rt_shootray.\n");
 *	   (void)fflush(stdout);
 */

	   /*  Call rt_shootray for "forward ray".  */
	   (void)rt_shootray(&ap);

/*
 *	   (void)printf("Finished rt_shootray.\n");
 *	   (void)fflush(stdout);
 */

/*
 *	   (void)printf("r = %f\n",r);
 *	   (void)fflush(stdout);
 */

	   if( r == (dump - 1.) )
	   {
	     (void)printf("%f rays have been fired in forward direction.\n",
		(r+1));
	     (void)fflush(stdout);
	     if(idump == 1)
	     {						/*  START # 3  */
		(void)printf("\n****************************************");
		(void)printf("****************************************\n");
		(void)fflush(stdout);
		/*  Dump info to file.  */
		for(i=0; i<numreg; i++)
		{
		   for(j=0; j<numreg; j++)
		   {
			sf = 0.;
			if( (info[i].lvrays < -ZEROTOL) || (ZEROTOL <
			   info[i].lvrays) )
			   sf = info[i].intrays[j] / info[i].lvrays;

			(void)printf("%d\t%d\t%f\n",i,j,sf);
			(void)fflush(stdout);
		   }
		}
	     }						/*  START # 3  */

		dump = dump + 1000000.;
	   }

	}					/*  END # 2  */

	/*  Find area bounded by engine air using Monte Carlo method.  */
	for(i=0; i<numreg; i++)
	{
	  /*  Old way, only incrementing info[i].allvrays for forward  */
	  /*  ray therefore do not divide by 2.  Division by 2 is to  */
	  /*  include the backwards ray also.  */
/*
 *	  info[i].engarea = info[i].allvrays * areabs / loops / 2.;
 */
	  info[i].engarea = info[i].allvrays * areabs / loops;

	  /*  Put area into square meters.  */
	  info[i].engarea *= 1.e-6;
	}

	   /*  Find number of characters in each region name.  */
	   for(i=0; i<numreg; i++)
	   {
		jcnt = 0;
		while(info[i].name[jcnt] != '\0')
		{
		   jcnt++;
		}
		info[i].numchar = jcnt;
	   }
	   /*  Print out number of char & region name.  */
/*
 *	   for(i=0; i<numreg; i++)
 *	   {
 *		(void)printf("%d\t-%s-\n",info[i].numchar,info[i].name);
 *		(void)fflush(stdout);
 *	   }
 */

	   /*  Find correct region number.  */
	   (void)printf("Finding correct region numbers.\n");
	   (void)fflush(stdout);
	   for(i=0; i<numreg; i++)
	   {
		for(j=0; j<rnnnum; j++)
		{
		   equal = 0;	/*  1=>not equal.  */
		   jcnt = rnnchar[j];
		   for(k=info[i].numchar; k>=0; k--)
		   {
/*
 *			(void)printf("i=%d, j=%d, k=%d, jcnt=%d, -%c-, -%c-\n",
 *			   i,j,k,jcnt,info[i].name[k],rnnname[j][jcnt]);
 *			(void)fflush(stdout);
 */
			if(jcnt<0) equal = 1;
			else if(info[i].name[k] != rnnname[j][jcnt])
				equal = 1;
			jcnt--;
		   }
		   if(equal == 0) info[i].regnum = rnnreg[j];
		}
	   }
	   (void)printf("Finished finding correct region numbers.\n");
	   (void)fflush(stdout);

	/******************************************************************/

	/*  Check for reciprocity.  */
	/*  Open error file.  */
	fp2 = fopen(errfile,"w");
	(void)fprintf(fp2,"\nError file for shapefact.\n");
	(void)fprintf(fp2,"Shape factor file created:  %s\n\n",outfile);
	(void)fprintf(fp2,"Regions with reciprocity errors greater ");
	(void)fprintf(fp2,"than 10%%.\n\n");
	(void)fflush(fp2);

	for(i=0; i<numreg; i++)
	{
	   for(j=0; j<numreg; j++)
	   {
		rcpi = 0.;
		rcpj = 0.;
		if( (info[i].lvrays < -ZEROTOL) || (ZEROTOL < info[i].lvrays) )
		   rcpi = info[i].intrays[j] * info[i].engarea /info[i].lvrays;
		if( (info[j].lvrays < -ZEROTOL) || (ZEROTOL < info[j].lvrays) )
		   rcpj = info[j].intrays[i] * info[j].engarea /info[j].lvrays;
		rcp_diff = rcpi - rcpj;
		if(rcp_diff < 0.) rcp_diff = (-rcp_diff);
		if( (rcpi < -ZEROTOL) || (ZEROTOL < rcpi) )
			rcp_pdiff = rcp_diff / rcpi;
		else rcp_pdiff = 0.;	/*  Don't divide by 0.  */
		/*  Print reciprocity errors greater than 10%.  */
		if(rcp_pdiff > 0.1)
		{
		   (void)fprintf(fp2,"%d   %d   %f   %f   %f   %f\n",
			info[i].regnum,info[j].regnum,rcpi,rcpj,rcp_diff,
			(rcp_pdiff * 100.));
		   (void)fflush(fp2);
		}
	   }
	}
	/*  Close error file.  */
	(void)fclose(fp2);

	/******************************************************************/

	/*  Print out shape factor to regular output file.  */
	if(itype == 0)
	{
	 fp = fopen(outfile,"w");
	 (void)fprintf(fp,"Number of forward rays fired:  %f\n\n",loops);
	 (void)fflush(fp);

	 /*  Print out structure.  */
	 for(i=0; i<numreg; i++)
	 {
	   /*  Print region number, region name, & engine area.  */
	   (void)fprintf(fp,"%d\t%s\t%e\n",
		info[i].regnum,info[i].name,info[i].engarea);
	   (void)fflush(fp);

	   /*  Zero sums for shape factors & rays hit.  */
	   totalsf = 0.;
	   totalnh = 0.;

	   for(j=0; j<numreg; j++)
	   {
		sf = 0.;
		if( (info[i].lvrays < -ZEROTOL) || (ZEROTOL <
		   info[i].lvrays) )
		   sf = info[i].intrays[j] / info[i].lvrays;

		/*  Print region number & shape factor.  */
		(void)fprintf(fp,"   %d\t%e\n",
			info[j].regnum,sf);
		(void)fflush(fp);

		/*  Print if number of rays leaving i & entering j is  */
		/*  not the same as the number of rays leaving j &   */
		/*  entering i.  */
/*
 *		if( info[i].intrays[j] != info[j].intrays[i] )
 *		{
 *		   stemp = info[i].intrays[j] - info[j].intrays[i];
 *		   if(stemp < 0) stemp = (-stemp);
 *		   (void)fprintf(fp,"     %e (%e) - %e (%e) - %e\n",
 *			info[i].intrays[j],(stemp/info[i].intrays[j]),
 *			info[j].intrays[i],(stemp/info[j].intrays[i]),stemp);
 *		   (void)fflush(fp);
 *		}
 */

		/*  Add to sum of shape factors & number of hits.  */
		totalsf += sf;
		totalnh += info[i].intrays[j];

	   }

	   /*  Print sum of hits & sum of shape factors.  */
	   (void)fprintf(fp,"  sum of hits:  %f\n",totalnh);
	   (void)fprintf(fp,"  sum of shape factors:  %f\n\n",totalsf);
	   (void)fflush(fp);
	 }
	 (void)fclose(fp);
	}

	/******************************************************************/

	/*  Create and write to generic shape factor file.  */
	if(itype == 1)
	{
	   fp = fopen(outfile,"w");
	   for(i=0; i<numreg; i++)
	   {
		/*  Count the number of shape factors.  */
		icnt = 0;
		for(j=0; j<numreg; j++)
		{
		   if(info[i].intrays[j] > ZEROTOL) icnt++;
		}
		/*  Print the # 5, region number (matches firpass &  */
		/*  secpass), engine area, & number of shape factors.  */
		(void)fprintf(fp," 5  %d  %e  %d\n",
		   info[i].regnum,info[i].engarea,icnt);
		(void)fflush(fp);
		for(j=0; j<numreg; j++)
		{
		   if(info[i].intrays[j] > ZEROTOL)
		   {
			sf = info[i].intrays[j] / info[i].lvrays;
			/*  Print each region # & shape factor.  */
			(void)fprintf(fp,"    %d  %e\n",info[j].regnum,sf);
			(void)fflush(fp);
		   }
		}
	   }
	   (void)fclose(fp);
	}

   }						/*  END # 1  */
   return(0);
}


/*****************************************************************************/
/*		Hit, miss, and overlap functions.                            */
/*****************************************************************************/

int
hit(register struct application *ap_p, struct partition *PartHeadp)
/*  User supplied hit function.  */
                                  
                            

{						/*  START # 0H  */
   extern struct table info[];	/*  Structure is external.  */
   register struct partition *pp;
   register struct hit *hitp;
   register struct soltab *stp;
   int icur=0;			/*  Current region hit.  */
   int iprev;			/*  Previous region hit.  */
   int iair;			/*  Type of air or region came from,  */
				/*  0=>region, 1=>exterior air, 2=>crew  */
				/*  air, 5=>engine air, 6=>closed  */
				/*  compartment air, 7=>exhaust air,  */
				/*  8=>generic air 1, 9=>generic air 2.  */

/*
 * (void)printf("In hit function.\n");
 * (void)fflush(stdout);
 */

   /*  Set beginning parameters.  */
   iprev = -1;
   iair = 1;		/*  Comes from exterior air.  */

/*
 * (void)printf("Beginning loop again.\n");
 * (void)fflush(stdout);
 */

   pp = PartHeadp->pt_forw;
   for( ; pp != PartHeadp;  pp = pp->pt_forw)
   {						/*  START # 1H  */
/*
 *	(void)printf("Region %d - %s - %d - %d - %d - \n",
 *		pp->pt_regionp->reg_bit,
 *		info[(int)pp->pt_regionp->reg_bit].name,
 *		pp->pt_regionp->reg_gmater,
 *		pp->pt_regionp->reg_aircode,
 *		pp->pt_regionp->reg_regionid);
 *	(void)fflush(stdout);
 */

	if(iair == 1)	/*  Ray comes from nothing (exterior air).  */
	{					/*  START # 2H  */
/*
 *	   (void)printf("Ray comes from exterior air (1).\n");
 *	   (void)fflush(stdout);
 */

	   if(pp->pt_regionp->reg_regionid > (short)0)	/*  Hit region.  */
	   {					/*  START # 3H  */
		/*  Region number hit.  */
		icur = (int)(pp->pt_regionp->reg_bit);

		/*  Find leaving point.  */
		hitp = pp->pt_outhit;
		stp = pp->pt_outseg->seg_stp;
		RT_HIT_NORM(hitp,stp,&(ap_p->a_ray));
		/*  Flip normal if needed.  */
		if(pp->pt_outflip)
		{
			VREVERSE(hitp->hit_normal,hitp->hit_normal);
			pp->pt_outflip = 0;
		}
		iprev = icur;
		iair = 0;	/*  A region was just hit.  */
	   }					/*  END # 3H  */

	   else	/*  Hit air.  */
	   {					/*  START # 4H  */
		iair = pp->pt_regionp->reg_aircode;
	   }					/*  END # 4H  */
	}					/*  END # 2H  */

	else if(iair == 5)	/*  Ray comes from engine air.  */
	{					/*  START # 5H  */
/*
 *	   (void)printf("Ray comes from engine air (5).\n");
 *	   (void)fflush(stdout);
 */

	   if(pp->pt_regionp->reg_regionid > (short)0)	/*  Hit region.  */
	   {					/*  START # 6H  */
		/*  Region number hit.  */
		icur = (int)(pp->pt_regionp->reg_bit);

	      /*  Only execute the following two statements if iprev >= 0.  */
		if(iprev < (-1))
		{
			(void)fprintf(stderr,"ERROR -- iprev = %d\n",iprev);
			(void)fflush(stderr);
		}
		if(iprev == (-1))
		{
			(void)fprintf(stderr,"iprev = %d - entered ",iprev);
			(void)fprintf(stderr,"through engine air\n");
			(void)fflush(stderr);
		}
		if(iprev > (-1))
		{
		/*  Add one to number of rays leaving previous region.  */
		info[iprev].lvrays++;

		/*  Add one to the number of rays leaving current region  */
		/*  for the backward ray.  */
		info[icur].lvrays++;

		/*  Add one to number of rays leaving previous region and  */
		/*  intercepted by current region.  */
		info[iprev].intrays[icur]++;

		/*  Add one to the number of rays leaving the current  */
		/*  region and intersecting the previous region for the  */
		/*  backward ray.  */
		info[icur].intrays[iprev]++;

		}

		/*  Find leave point.  */
		hitp = pp->pt_outhit;
		stp = pp->pt_outseg->seg_stp;
		RT_HIT_NORM(hitp,stp,&(ap_p->a_ray));
		/*  Flip normal if needed.  */
		if(pp->pt_outflip)
		{
			VREVERSE(hitp->hit_normal,hitp->hit_normal);
			pp->pt_outflip = 0;
		}
		iprev = icur;
		iair = 0;	/*  Hit a region.  */
	   }					/*  END # 6H  */

	   else	/*  Hit air.  */
	   {
		iair = 5;	/*  Since coming through engine air  */
				/*  assume should still be engine air.  */
	   }
	}					/*  END # 5H  */

	else if(iair == 0)	/*  Ray comes from a region.  */
	{					/*  START # 7H  */
/*
 *	   (void)printf("Ray comes from region (0).\n");
 *	   (void)fflush(stdout);
 */

	   if(pp->pt_regionp->reg_regionid > (short)0)	/*  Hit a region.  */
	   {					/*  START # 8H  */
		/*  Region number hit.  */
		icur = (int)(pp->pt_regionp->reg_bit);

		/*  Find leaving point.  */
		hitp = pp->pt_outhit;
		stp = pp->pt_outseg->seg_stp;
		RT_HIT_NORM(hitp,stp,&(ap_p->a_ray));
		/*  Flip normal if needed.  */
		if(pp->pt_outflip)
		{
			VREVERSE(hitp->hit_normal,hitp->hit_normal);
			pp->pt_outflip = 0;
		}
		iprev = icur;
		iair = 0;	/*  Hit a region.  */
	   }					/*  END # 8H  */

	   else	/*  Hit air.  */
	   {					/*  START # 9H  */
		/*  Increment allvrays if the ray is leaving through  */
		/*  engine air.  Make sure this is only done once.  */
		if( (iair != 5) && (pp->pt_regionp->reg_aircode == 5) )
			info[icur].allvrays++;

		if(iair != 5) iair = pp->pt_regionp->reg_aircode;
	   }					/*  END # 9H  */
	}					/*  END # 7H  */

	else	/*  Ray comes from any interior air.  */
	{					/*  START # 10H  */
/*
 *	   (void)printf("Ray comes from interior air (not 0, 1, 5).\n");
 *	   (void)fflush(stdout);
 */

	   if(pp->pt_regionp->reg_regionid > (short)0)	/*  Hits region.  */
	   {					/*  START # 11H  */
		/*  Region number hit.  */
		icur = (int)(pp->pt_regionp->reg_bit);

		/*  Find leaving point.  */
		hitp = pp->pt_outhit;
		stp = pp->pt_outseg->seg_stp;
		RT_HIT_NORM(hitp,stp,&(ap_p->a_ray));
		/*  Flip normal if needed.  */
		if(pp->pt_outflip)
		{
			VREVERSE(hitp->hit_normal,hitp->hit_normal);
			pp->pt_outflip = 0;
		}
		iprev = icur;
		iair = 0;	/*  Hit region.  */
	   }					/*  END # 11H  */

	   else	/*  Hits air.  */
	   {
		iair = pp->pt_regionp->reg_aircode;
	   }
	}					/*  END # 10H  */
   }						/*  END # 1H  */

   if(iprev == (-1) )		/*  Went through air only.  */
   {
	return(1);		/*  Indicates miss.  */
   }

   else
   {
	return(0);
   }
}						/*  END # 0H  */

int
miss(void)
/*  User supplied miss function.  */
{
/*
 * (void)printf("In miss function.\n");
 * (void)fflush(stdout);
 */

   nummiss = nummiss + 1.;

   return(1);
}

int
overlap(void)
/*  User supplied overlap function.  */
{
/*
 * (void)printf("In overlap function.\n");
 * (void)fflush(stdout);
 */

   return(2);
}
@


11.14
log
@change conf.h to a wrapped config.h
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/irprep/shapefact.c,v 11.13 2004/04/05 07:47:44 morrison Exp $ (BRL)";
@


11.13
log
@merge of ansi-6-0-branch into HEAD
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d54 5
a58 1
#include "conf.h"
@


11.12
log
@update copyright to include span through 2003
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/irprep/shapefact.c,v 11.11 2002/08/20 17:07:32 jra Exp $ (BRL)";
d81 3
a83 3
extern int hit();	/*  User supplied hit function.  */
extern int miss();	/*  User supplied miss function.  */
extern int overlap();	/*  User supplied overlap function.  */
d112 1
a112 5
int main(argc,argv)

int argc;
char **argv;

d776 1
a776 1
hit(ap_p,PartHeadp)
d778 2
a779 2
register struct application *ap_p;
struct partition *PartHeadp;
d1000 1
a1000 1
miss()
d1014 1
a1014 1
overlap()
@


11.11
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1990 by the United States Army.
d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/irprep/shapefact.c,v 11.9 2001/10/15 19:58:03 morrison Exp $ (BRL)";
@


11.11.4.1
log
@sync to HEAD...
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/irprep/shapefact.c,v 11.12 2004/02/02 17:39:06 morrison Exp $ (BRL)";
@


11.11.10.1
log
@merge from HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/irprep/shapefact.c,v 11.12 2004/02/02 17:39:06 morrison Exp $ (BRL)";
@


11.11.10.2
log
@merge from head
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/irprep/shapefact.c,v 11.11.10.1 2004/02/12 19:50:38 erikg Exp $ (BRL)";
@


11.11.2.1
log
@Initial ANSIfication
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/irprep/shapefact.c,v 11.11 2002/08/20 17:07:32 jra Exp $ (BRL)";
d81 3
a83 3
extern int hit(register struct application *ap_p, struct partition *PartHeadp);	/*  User supplied hit function.  */
extern int miss(void);	/*  User supplied miss function.  */
extern int overlap(void);	/*  User supplied overlap function.  */
d112 5
a116 1
int main(int argc, char **argv)
d780 1
a780 1
hit(register struct application *ap_p, struct partition *PartHeadp)
d782 2
a783 2
                                  
                            
d1004 1
a1004 1
miss(void)
d1018 1
a1018 1
overlap(void)
@


11.11.2.2
log
@sync branch with HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d51 1
a51 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.10
log
@Converted from K&R to ANSI C - RFH
@
text
@d81 3
a83 3
extern int hit(register struct application *ap_p, struct partition *PartHeadp);	/*  User supplied hit function.  */
extern int miss(void);	/*  User supplied miss function.  */
extern int overlap(void);	/*  User supplied overlap function.  */
d112 5
a116 1
int main(int argc, char **argv)
d780 1
a780 1
hit(register struct application *ap_p, struct partition *PartHeadp)
d782 2
a783 2
                                  
                            
d1004 1
a1004 1
miss(void)
d1018 1
a1018 1
overlap(void)
@


11.9
log
@Added "Darwin on Power Macintosh" support (finally)
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/irprep/shapefact.c,v 11.8 2001/08/09 20:09:10 jra Exp $ (BRL)";
d81 3
a83 3
extern int hit();	/*  User supplied hit function.  */
extern int miss();	/*  User supplied miss function.  */
extern int overlap();	/*  User supplied overlap function.  */
d112 1
a112 5
int main(argc,argv)

int argc;
char **argv;

d776 1
a776 1
hit(ap_p,PartHeadp)
d778 2
a779 2
register struct application *ap_p;
struct partition *PartHeadp;
d1000 1
a1000 1
miss()
d1014 1
a1014 1
overlap()
@


11.8
log
@lint
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/irprep/shapefact.c,v 11.7 2001/04/20 22:28:56 morrison Exp $ (BRL)";
d103 9
d230 3
d234 1
@


11.7
log
@CONST to const
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/irprep/shapefact.c,v 11.6 2000/10/24 19:32:54 mike Exp $ (BRL)";
d115 1
a115 1
   double areabs;	/*  Area of bounding sphere (mm**2).  */
d777 1
a777 1
   int icur;			/*  Current region hit.  */
@


11.6
log
@
lint
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/irprep/shapefact.c,v 11.5 2000/08/24 23:10:21 mike Exp $ (BRL)";
d88 1
a88 1
   CONST char *name;	/*  Region name.  */
@


11.5
log
@
RCSid
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/irprep/shapefact.c,v 11.4 2000/01/31 16:25:34 jra Exp $ (BRL)";
d766 1
d990 1
a990 1

d1004 1
a1004 1

@


11.4
log
@Eliminated some unused variables
@
text
@d51 1
a51 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/irprep/shapefact.c,v 11.3 1999/12/23 06:16:04 mike Exp $ (BRL)";
@


11.3
log
@
Struct region is now a bu_list
@
text
@d51 1
a51 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/irprep/shapefact.c,v 11.2 1998/09/14 15:59:14 bparker Exp $ (BRL)";
a145 2
   int flag;		/*  Flag for reading geometric file, it counts  */
			/*  commas.  */
a155 1
   double stemp;	/*  Temporary variables.  */
a158 2

   struct msr_unif *msr;
@


11.2
log
@*- fix typos
@
text
@d51 1
a51 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/irprep/shapefact.c,v 11.1 1995/01/04 10:22:53 mike Rel4_4 $ (BRL)";
d334 1
a334 1
	pr = rtip->HeadRegion;
d338 1
a338 1
	   pr = pr->reg_forw;
@


11.1
log
@Release_4.4
@
text
@d51 1
a51 1
static char RCSid[] = "@@(#)$Header: /m/cad/irprep/RCS/shapefact.c,v 10.6 94/12/12 22:18:01 mike Exp $ (BRL)";
d636 1
a636 1
	(void)fprintf(fp2,"than 10%.\n\n");
@


10.6
log
@Linux has PI in <math.h>
@
text
@d51 1
a51 1
static char RCSid[] = "@@(#)$Header: /m/cad/irprep/RCS/shapefact.c,v 10.5 94/08/24 18:11:26 gdurf Exp Locker: mike $ (BRL)";
@


10.5
log
@Factored ifdefs
@
text
@d51 1
a51 1
static char RCSid[] = "@@(#)$Header: /m/cad/irprep/RCS/shapefact.c,v 10.4 1993/02/18 09:56:16 scoates Exp gdurf $ (BRL)";
d72 1
d74 1
@


10.4
log
@Put ; after VREVERSE statement in loop # 3H.
@
text
@d51 1
a51 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/irprep/RCS/shapefact.c,v 10.3 92/09/17 08:16:32 scoates Exp Locker: scoates $ (BRL)";
d54 2
d57 1
a57 1
#ifdef SYSV
@


10.3
log
@Remove path name on include statements.
@
text
@d51 1
a51 1
static char RCSid[] = "@@(#)$Header: /m/cad/irprep/RCS/shapefact.c,v 10.2 92/09/15 13:40:02 scoates Exp Locker: scoates $ (BRL)";
d831 1
a831 1
			VREVERSE(hitp->hit_normal,hitp->hit_normal)
@


10.2
log
@New version of shapefact.c with changes:  region # & name file is
read to make region numbering consistent, a generic output file may
be written, an error file is written, and the format of the regualr
output file has been changed.
@
text
@d51 1
a51 1
static char RCSid[] = "@@(#)$Header: /m/cad/irprep/RCS/shapefact.c,v 1.13 91/07/27 01:52:30 butler Exp $ (BRL)";
d63 5
a67 5
#include "/n/walrus/usr/brlcad/include/machine.h"
#include "/n/walrus/usr/brlcad/include/externs.h"
#include "/n/walrus/usr/brlcad/include/vmath.h"
#include "/n/walrus/usr/brlcad/include/raytrace.h"
#include "/n/walrus/usr/brlcad/include/msr.h"
@


10.1
log
@Release_4.0
@
text
@d8 1
a8 1
 *	S.Coates - 8 July 1991
d20 1
a20 1
/*	23 May 1991 - Take out lvpt that wasn't necessary.  */
d22 27
d63 5
a67 5
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
#include "msr.h"
a69 2


d73 1
a73 1
#define MAXREG 70	/*  Maximum number of regions.  */
d84 4
a87 1
   CONST char *name;		/*  Region name.  */
d89 1
a89 1
			/*  air.  */
d92 3
d111 1
d117 1
a117 1
   int i,j;		/*  Variable in loops.  */
d133 4
d139 19
d169 8
d178 1
a178 1
	(void)fprintf(stderr,"Enter name of output file (15 char max).  ");
d182 13
d197 1
a197 1
	(void)printf("Do you want to dump interm shape factors to ");
d209 1
a209 1
	(void)fprintf(stderr,"Do you wish to enter your own seed (0) or\n");
d226 54
d307 2
d310 1
d362 4
d376 3
d519 1
a519 1
	   /*  Call rt_shootray.  */
d534 2
a535 1
	     (void)printf("%f rays have been fired.\n",(r+1));
a560 1

d563 10
a572 5
	/*  Print out shape factor to output file.  */
	fp = fopen(outfile,"w");
	(void)fprintf(fp,"Number of rays fired:  %f\n",loops);
	(void)fprintf(fp,"Number of misses:  %f\n\n",nummiss);
	(void)fflush(fp);
d574 61
a634 1
	/*  Print out structure.  */
d637 41
a677 3
	   (void)fprintf(fp,"\n%d\t%s\n",i,info[i].name);
	   (void)fprintf(fp,"  total number of rays:  %f\n",
		info[i].lvrays);
d691 3
a693 3
		(void)fprintf(fp,"    region %d, number of hits:  %f",
			j,info[i].intrays[j]);
		(void)fprintf(fp,", shape factor:  %f\n",sf);
d696 15
d717 1
d719 1
a719 1
	   (void)fprintf(fp,"  sum of shape factors:  %f\n",totalsf);
d721 2
a723 1
	(void)fclose(fp);
d725 33
d781 3
a783 1
				/*  air, 5=>engine air.  */
d873 4
d880 6
d937 5
d979 9
a987 1
   return(0);
a993 1

a1007 1

d1013 1
a1013 1
   return(1);
@


1.13
log
@Need to catch return from msr_unif_init() !
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/irprep/RCS/shapefact.c,v 1.12 91/07/23 17:07:33 butler Exp $ (BRL)";
@


1.12
log
@removed define for MSRMAXTBL (which conflicts with the one in msr.h
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/irprep/RCS/shapefact.c,v 1.11 91/07/23 01:38:44 butler Exp $ (BRL)";
d109 1
a109 1
	(void)fprintf(stderr,"\nusage:  rand.ray file.g objects\n\n");
d144 1
a144 1
   	msr_unif_init(seed, 0);
d148 1
@


1.11
log
@compensated return of MSR_UNIF_DOUBLE to produce numbers in
the range 0.0 -> 1.0
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/irprep/RCS/shapefact.c,v 1.10 91/07/23 01:17:23 butler Exp $ (BRL)";
a41 1
#define MSRMAXTBL
@


1.10
log
@changed to use libmsr for random numbers.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/irprep/RCS/shapefact.c,v 1.9 91/07/19 02:17:35 butler Exp $ (BRL)";
d251 1
a251 1
	   q = MSR_UNIF_DOUBLE(msr);
d261 1
a261 1
	   q = MSR_UNIF_DOUBLE(msr);
d291 1
a291 1
	   q = MSR_UNIF_DOUBLE(msr);
d301 1
a301 1
	   q = MSR_UNIF_DOUBLE(msr);
@


1.9
log
@added include of strings.h on BSD machines
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/irprep/RCS/shapefact.c,v 1.8 91/07/15 23:19:35 butler Exp $ (BRL)";
d40 1
d42 4
d105 2
d144 3
d148 1
d250 3
d254 1
d260 3
d264 1
d289 4
d294 1
d300 3
d304 1
@


1.8
log
@misc portability changes.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/irprep/RCS/shapefact.c,v 1.7 91/07/11 22:11:13 butler Exp $ (BRL)";
d28 1
d30 3
@


1.7
log
@version after Sue Coates finished with lint.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/irprep/RCS/shapefact.c,v 1.6 91/07/03 01:18:28 butler Exp $ (BRL)";
d442 1
a442 1
hit(ap,PartHeadp)
d444 1
a444 1
register struct application *ap;
d500 1
a500 1
		RT_HIT_NORM(hitp,stp,&(ap->a_ray));
d554 1
a554 1
		RT_HIT_NORM(hitp,stp,&(ap->a_ray));
d587 1
a587 1
		RT_HIT_NORM(hitp,stp,&(ap->a_ray));
d619 1
a619 1
		RT_HIT_NORM(hitp,stp,&(ap->a_ray));
@


1.6
log
@removed non-portable use of <stdlib.h> in favor of "externs.h"
@
text
@d8 1
a8 1
 *	S.Coates - 23 May 1991
d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/irprep/RCS/shapefact.c,v 1.5 91/07/02 23:40:35 butler Exp $ (BRL)";
d60 1
a60 1
main(argc,argv)
a86 2
   double cordir[3];	/*  Used to see if firing direction points  */
			/*  toward the bounding rpp.  */
a90 1
   char line[81];	/*  Used to read one line from a file.  */
d131 1
a131 1
		(void)scanf("%u",&seed);
d431 1
a431 1
	fclose(fp);
d434 1
@


1.5
log
@made application local copies of region name CONST pointers.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/irprep/RCS/shapefact.c,v 1.4 91/07/01 23:39:33 mike Exp $ (BRL)";
a27 1
#include <stdlib.h>	/*  Need for mallocing arrays.  */
@


1.4
log
@Added BRL-CAD Headers
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d52 1
a52 1
   char *name;		/*  Region name.  */
@


1.3
log
@Removed erroneous redeclaration of drand48
@
text
@d1 18
a18 5
/*  File:  rand.ray.c  */
/*  S.Coates - 23 May 1991  */
/*  Program to find shape factors for the engine by  */
/*  firing random rays.  This program fires parallel  */
/*  rays.  */
d22 4
@


1.2
log
@Minor fixes
@
text
@a61 3
   double drand48();	/*  Random number generator.  Generates double  */
			/*  floating-point values uniformly distributed  */
			/*  over the interval [0.0,1.0).  */
@


1.1
log
@Initial revision
@
text
@d17 1
d81 1
a81 1
   FILE *fp,*fopen();	/*  Used to open files.  */
a655 1

@
