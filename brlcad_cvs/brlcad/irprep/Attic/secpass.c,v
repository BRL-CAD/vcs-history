head	11.10;
access;
symbols
	ansi-20040405-merged:11.6.2.2
	postmerge-20040405-ansi:11.8
	premerge-20040404-ansi:11.7
	postmerge-autoconf:11.7
	autoconf-freeze:11.6.10.2
	premerge-autoconf:11.7
	ansi-20040316-freeze:11.6.2.1
	postmerge-20040315-windows:11.7
	premerge-20040315-windows:11.7
	windows-20040315-freeze:11.6.4.1
	autoconf-20031203:11.6
	autoconf-20031202:11.6
	autoconf-branch:11.6.0.10
	phong-branch:11.6.0.8
	photonmap-branch:11.6.0.6
	rel-6-1-DP:11.6
	windows-branch:11.6.0.4
	rel-6-0-2:11.4
	ansi-branch:11.6.0.2
	rel-6-0-1-branch:11.4.0.2
	hartley-6-0-post:11.5
	hartley-6-0-pre:11.4
	rel-6-0-1:11.4
	rel-6-0:11.4
	rel-5-4:11.1
	offsite-5-3-pre:11.3
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.10
date	2004.05.24.04.00.37;	author morrison;	state dead;
branches;
next	11.9;

11.9
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	11.8;

11.8
date	2004.04.05.07.47.44;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2004.02.02.17.39.06;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	2002.08.20.17.07.32;	author jra;	state Exp;
branches
	11.6.2.1
	11.6.4.1
	11.6.10.1;
next	11.5;

11.5
date	2002.08.15.20.54.44;	author hartley;	state Exp;
branches;
next	11.4;

11.4
date	2001.08.09.20.09.10;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	2000.09.06.20.08.49;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	2000.08.24.23.10.21;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.22.49;	author mike;	state Rel4_4;
branches;
next	10.6;

10.6
date	94.12.12.22.17.58;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.08.24.18.11.14;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	93.02.11.10.15.43;	author scoates;	state Exp;
branches;
next	10.3;

10.3
date	92.09.17.08.15.23;	author scoates;	state Exp;
branches;
next	10.2;

10.2
date	92.09.15.13.32.18;	author scoates;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.53.42;	author mike;	state Rel4_0;
branches;
next	1.8;

1.8
date	91.07.19.02.17.20;	author butler;	state Exp;
branches;
next	1.7;

1.7
date	91.07.15.23.19.31;	author butler;	state Exp;
branches;
next	1.6;

1.6
date	91.07.11.22.11.11;	author butler;	state Exp;
branches;
next	1.5;

1.5
date	91.07.03.01.17.40;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	91.07.01.23.39.32;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	91.07.01.23.15.53;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	91.06.08.03.08.22;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	91.06.08.02.50.18;	author mike;	state Exp;
branches;
next	;

11.6.2.1
date	2002.09.19.18.01.00;	author morrison;	state Exp;
branches;
next	11.6.2.2;

11.6.2.2
date	2004.03.17.21.16.35;	author morrison;	state Exp;
branches;
next	;

11.6.4.1
date	2004.03.11.23.41.22;	author morrison;	state Exp;
branches;
next	;

11.6.10.1
date	2004.02.12.19.50.38;	author erikg;	state Exp;
branches;
next	11.6.10.2;

11.6.10.2
date	2004.03.15.14.06.13;	author erikg;	state Exp;
branches;
next	;


desc
@IRPREP, pass 2
@


11.10
log
@moved to src/irprep/
@
text
@/*
 *			S E C P A S S . C
 *
 *  Author -
 *	S.Coates - 11 February 1993
 *  
 *  Source -
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 *
 *  Notes -
 *	This version ONLY shoots down x-axis.
 */

/*	To compile:  cc -c secpass.c  */
/*		     cake  */

/*	CHANGES		*/
/*	11 December 1990 - 'Dimension' arrays using malloc.  */
/*	18 December 1990 - Incorperates subroutines rotate and radians.  */
/*	19 February 1991 - No defaults for material properties, thermal  */
/*			   conductivity is zero if one is zero.  */
/*	25 February 1991 - Print triangular conductivity file (still  */
/*			   computes entire matrix).  */
/*	14 March 1991    - Creates a generic file if needed.  */
/*	13 May 1991      - Remove some write statements.  */
/*	24 October 1991  - Put in appropriate include statements so that  */
/*			   I can compile.  */
/*	30 October 1991  - Make region numbering scheme the same through-  */
/*			   out, i.e. region numbers start at 1.  */
/*	15 November 1991 - Make a change to printing of conductivity table.  */
/*	11 February 1992 - Reverse order of regions in writing conductivity  */
/*			   file.  The largest number must come first.  */
/*	13 February 1992 - Change format for writing PRISM 3.0 files.  */
/*	10 March 1992    - Print out PRISM release being used.  */
/*	11 February 1993 - Add option to fire from three orthogonal  */
/*			   directions.  */

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/irprep/secpass.c,v 11.9 2004/05/10 15:30:43 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <math.h>

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"

#define ADJTOL 1.e-1	/*  Tolerance for adjacent regions.  */
#define ZEROTOL 1.e-20	/*  Tolerance for dividing by zero.  */
#define MINCAL 10	/*  Minimum number of calculations for length.  */
#define ALPHA 25.	/*  Rotation about z-axis.  */
#define BETA 50.	/*  Rotation about y-axis.  */
#define GAMMA 35.	/*  Rotation about x-axis.  */

struct application ap;	/*  Structure passed between functions.  */
extern int hit(register struct application *ap_p, struct partition *PartHeadp);	/*  User defined hit function.  */
extern int miss(register struct application *ap_p);	/*  User defined miss function.  */
extern int ovrlap(register struct application *ap_p, struct partition *PartHeadp, struct region *reg1, struct region *reg2);	/*  User defined overlap function.  */
extern void rotate(double *p, double *a, double *np);	/*  Subroutine to rotate a point.  */
extern double radians(double a);/*  Subroutine to put an angle into radians.  */

/*  Define structure.  */
/*  Make arrays into pointers such that malloc may be used  */
/*  later.  */
struct table
{
	double centroid[3];	/*  centroid of region  */
	double *shrarea;	/*  shared surface area between adjacent  */
				/*  regions  */
	int mat;		/*  material id  */
	double *avglen;		/*  average length between centroid &  */
				/*  shared surface area  */
	double *rmslen;		/*  root mean squared length between  */
				/*  centroid & shared surface area  */
	double *minlen;		/*  minimum length between centroid &  */
				/*  shared surface area  */
	double *maxlen;		/*  maximum length between centroid &  */
				/*  shared surface area  */
	double *numcal;		/*  number of length calculations  */
	double *rkavg;		/*  rk value using average length  */
	double *rkrms;		/*  rk value using root mean squared length  */
	double *rkmin;		/*  rk value using minimum length  */
	double *rkmax;		/*  rk value using maximum length  */
};

struct table *cond;		/*  name of table structure  */

int iprev;			/*  previous region hit  */
int icur;			/*  current region hit  */
double enterpt[3];		/*  point where ray enters  */
double leavept[3];		/*  point where ray leaves  */

int main(int argc, char **argv)
{	/*  START # 1  */

   static struct rt_i *rtip;	/*  *rtip pointer to structure of  */
				/*  type rt_i  */
   char idbuf[132];	/*  first ID record info, used in  */
			/*  rt_dirbuild  */
   int index;		/*  index for rt_dirbuild & rt_gettree  */

   FILE *fp;		/*  used in opening file for second pass  */
   char spfile[16];	/*  second pass file name  */
   FILE *fp1=NULL;		/*  conductivity file  */
   char confile[16];	/*  conductivity file  */
   FILE *fp2;		/*  conductivity table file  */
   char tblfile[16];	/*  conductivity table file  */

   int i,j;		/*  integers used in loops  */
   int numreg;		/*  number of regions  */
   int nmged;		/*  number of regions in mged file  */
   double gridspace;	/*  spacing between fired rays  */
   int iwrite;		/*  0 => write to standard out, 1 => write  */
			/*  to file  */
   int typeout;		/*  Type of file to be written, 0 => PRISM file,  */
			/*  1 => generic file.  */
   FILE *fp6;		/*  Used in writing generic file.  */
   char genfile[16];	/*  Generic file name.  */
   FILE *fp3=NULL;		/*  used for writing output to file  */
   char filename[16];	/*  output file name  */

   FILE *fp5;		/*  material file  */
   char filemat[16];	/*  material file  */
   char line[150];	/*  used for reading a line from a file  */
   double k[41];	/*  thermal conductivity  */
   int itype;		/*  type of length measurement to use for  */
			/*  rk calculations  */
   double rki,rkj;	/*  used in finding rk  */
   double ki,kj;	/*  thermal conductivity of region  */
   double leni,lenj;	/*  lengths used in finding rk  */
   double areai;	/*  areas used in finding rk  */
   double a1;		/*  area used in writing conductivity table  */
   double l1,l2,l3,l4;	/*  lengths used in writing conductivity table  */
   FILE *fp4;		/*  error file  */
   char fileerr[16];	/*  error file  */

   double angle[3];	/*  Angles of rotation.  angle[0]-rotation about  */
			/*  x-axis, angle[1]-rotation about y-axis, &  */
			/*  angle[2]-rotation about z-axis.  */
   double strtpt[3];	/*  Starting point of fired ray.  */
   double strtdir[3];	/*  Starting direction of fired ray.  */
   double r[3],t[3];	/*  Used in computing rotations.  */
   double center[3];	/*  Center point of bounding rpp.  */
   double diagonal;	/*  Length of diagonal of bounding rpp.  */
   double xmin,xmax;	/*  Maximum & minimum x of grid.  */
   double ymin,ymax;	/*  Maximum & minimum y of grid.  */
   double zmin,zmax;	/*  Maximum & minimum z of grid.  */
   int nadjreg;		/*  Number of adjacent regions.  */
   int prmrel;		/*  PRISM release number, 2=>2.0, 3=>3.0.  */
   int ifire;		/*  Number of sets of rays to be fired, 0=>  */
			/*  fire from 3 orthogonal postions, 1=>fire  */
			/*  from 1 position.  */

   /*  Check to see if arguments implimented correctly.  */
   if(argv[1] == NULL || argv[2] == NULL)
   {
   	(void)fprintf(stderr,"\nusage:  secpass file.g objects\n\n");
   }

   else
   {	/*  START # 2  */

	/*  Ask if output goes to standard out or to a file.  */
	(void)fprintf(stdout,"Write output to standard out (0) or a file(1) ");
	(void)fprintf(stdout,"not at all (2)?  ");
	(void)fflush(stdout);
	(void)scanf("%d",&iwrite);
	if((iwrite != 0) && (iwrite != 1)) iwrite=2;
	if(iwrite == 1)
	{
	   (void)fprintf(stdout,"Enter name of output file (15 char max).  ");
	   (void)fflush(stdout);
	   (void)scanf("%s",filename);
	   fp3 = fopen(filename,"w");
	}

	/*  Which file that has second pass information in it?  */
	(void)fprintf(stdout,"Enter name of file that has second pass ");
	(void)fprintf(stdout,"information\nin it (15 char max).  ");
	(void)fflush(stdout);
	(void)scanf("%s",spfile);

	/*  Ask for type of output file to be generated.  */
	(void)printf("Enter type of output file to be generated.\n");
	(void)printf("\t 0 - PRISM File\n");
	(void)printf("\t 1 - Generic File\n");
	(void)fflush(stdout);
	(void)scanf("%d",&typeout);

	/*  Read name of file to write conductivity information  */
	/*  to for use in PRISM.  */
	if(typeout == 0)
	{
	   (void)fprintf(stdout,"Enter name of file to be created for PRISM ");
	   (void)fprintf(stdout,"conductivity\ninformation (15 char max).  ");
	   (void)fflush(stdout);
	   (void)scanf("%s",confile);

	   /*  Find which release of PRISM is being used.  The format  */
	   /*  for writing region numbers is I3 for PRISM 2.0 & I6 for  */
	   /*  PRISM 3.0.  */
	   prmrel = 2;
	   (void)printf("Which release of PRISM is being used, 2.0 (2) ");
	   (void)printf("or 3.0 (3)?  ");
	   (void)fflush(stdout);
	   (void)scanf("%d",&prmrel);
	   if(prmrel != 3) prmrel = 2;
	}

	/*  Read generic file name if necessary.  */
	if(typeout == 1)
	{
	   (void)printf("Enter name of generic file to be created (15 char ");
	   (void)printf("max).  ");
	   (void)fflush(stdout);
	   (void)scanf("%s",genfile);
	}

	/*  Which calculated length should be used when writing to  */
	/*  this file:  1 -> average length, 2 -> rms length, 3 ->  */
	/*  minimum length, and 4 -> maximum length.  */
	(void)fprintf(stdout,"Which length calculation should be used when\n");
	(void)fprintf(stdout,"computing conduction\nbetween regions?\n");
	(void)fprintf(stdout,"\t1 - average length\n");
	(void)fprintf(stdout,"\t2 - rms length\n");
	(void)fprintf(stdout,"\t3 - minimum length\n");
	(void)fprintf(stdout,"\t4 - maximum length\n");
	(void)fflush(stdout);
	(void)scanf("%d",&itype);

	/*  Read name of file to write conductivity information to  */
	/*  in table format.  */
	(void)fprintf(stdout,"Enter name of file to be created for ");
	(void)fprintf(stdout,"conductivity\ntable (15 char max).  ");
	(void)fflush(stdout);
	(void)scanf("%s",tblfile);

	/*  Read name of material file that contains thermal  */
	/*  conductivity information.  */
	(void)fprintf(stdout,"Enter name of material file (15 char max).  ");
	(void)fflush(stdout);
	(void)scanf("%s",filemat);

	/*  Read name of error file.  */
	(void)fprintf(stdout,"Enter name of error file to be created ");
	(void)fprintf(stdout,"(15 char max).  ");
	(void)fflush(stdout);
	(void)scanf("%s",fileerr);

	/*  Choose whether 3 orthogonal sets of rays are to be fired  */
	/*  or 1 set of rays is to be fired.  */
	(void)printf("Should there be 3 sets of orhogonal rays fired ");
	(void)printf("(0) or 1 set (1)?\n\t");
	(void)fflush(stdout);
	(void)scanf("%d",&ifire);
	if(ifire != 0) ifire = 1;
	if(ifire == 0)
	{
	   (void)printf("3 sets of orthogonal rays will be fired.\n");
	}
	if(ifire == 1)
	{
	   (void)printf("1 set of rays will be fired.\n");
	}
	(void)fflush(stdout);

	/*  Write out file information.  */
	if(iwrite ==1)
	{
	   (void)fprintf(fp3,"\nsecond pass file:  %s\n",spfile);
	   (void)fprintf(fp3,"material file:  %s\n",filemat);
	   if(typeout == 0)
	   {
		(void)fprintf(fp3,"conductivity file for use ");
	   	(void)fprintf(fp3,"with PRISM:  %s\n",confile);
	   	(void)fprintf(fp3,"  (format is PRISM %d.0)\n",prmrel);
	   }
	   if(typeout == 1) (void)fprintf(fp3,"generic file:  %s\n",genfile);
	   (void)fflush(fp3);
	   if(itype == 1) (void)fprintf(fp3,"\taverage length being used\n");
	   if(itype == 2) (void)fprintf(fp3,"\trms length being used\n");
	   if(itype == 3) (void)fprintf(fp3,"\tminimum length being used\n");
	   if(itype == 4) (void)fprintf(fp3,"\tmaximum length being used\n");
	   (void)fprintf(fp3,"conductivity table file:  %s\n",tblfile);
	   (void)fprintf(fp3,"error file:  %s\n\n",fileerr);
	   (void)fflush(fp3);
	}

	/*  Read thermal conductivity file.  */
	fp5 = fopen(filemat,"r");
	for(i=0; i<41; i++)
	{
	   (void)fgets(line,151,fp5);
	   (void)sscanf(line,"%*d%*f%*f%*f%*f%lf",&k[i]);
	}

	/*  Print out the thermal conductivity.  */
/*
 *	for(i=0; i<41; i++)
 *	{
 *	   (void)fprintf(stdout,"  thermal conductivity %d = %f\n",i,k[i]);
 *	   (void)fflush(stdout);
 *	}
 */

	/*  Build the directory.  */
	index = 1;	/*  Set index for rt_dirbuild.  */
	rtip=rt_dirbuild(argv[index],idbuf,sizeof(idbuf));
	(void)fprintf(stdout,"Database title:  %s\n",idbuf);
	(void)fflush(stdout);

	/*  Set useair to 1, to show hits of air.  */
	rtip->useair = 1;

	/*  Load desired objects.  */
	index = 2;	/*  Set index for rt_gettree.  */
	while(argv[index] != NULL)
	{
	   rt_gettree(rtip,argv[index]);
	   index += 1;
	}

	/*  Find total number of regions in mged file.  */
	nmged = (int)rtip->nregions;

	(void)fprintf(stdout,"Number of regions in mged file:  %d\n",nmged);
	(void)fflush(stdout);

	if(iwrite == 1)
	{
	  (void)fprintf(fp3,"Number of regions in mged file:  %d\n",nmged);
	  (void)fflush(fp3);
	}

	/*  Number of regions known, everything can be malloced.  */
	(void)fprintf(stdout,"Mallocing arrays.\n");
	(void)fflush(stdout);

	cond = (struct table *)malloc( nmged * sizeof(struct table) );
	(void)fprintf(stdout,"cond malloced\n");
	(void)fflush(stdout);
	for(i=0; i<nmged; i++)
	{
		cond[i].shrarea = (double *)malloc( nmged * sizeof(double) );
		cond[i].avglen = (double *)malloc( nmged * sizeof(double) );
		cond[i].rmslen = (double *)malloc( nmged * sizeof(double) );
		cond[i].minlen = (double *)malloc( nmged * sizeof(double) );
		cond[i].maxlen = (double *)malloc( nmged * sizeof(double) );
		cond[i].numcal = (double *)malloc( nmged * sizeof(double) );
		cond[i].rkavg = (double *)malloc( nmged * sizeof(double) );
		cond[i].rkrms = (double *)malloc( nmged * sizeof(double) );
		cond[i].rkmin = (double *)malloc( nmged * sizeof(double) );
		cond[i].rkmax = (double *)malloc( nmged * sizeof(double) );
	}
	(void)fprintf(stdout,"loop malloced\n");
	(void)fflush(stdout);

	/*  All variables 'dimensioned', now zero all variables.  */
	for(i=0; i<nmged; i++)
	{
		cond[i].centroid[0] = (double)0.;
		cond[i].centroid[1] = (double)0.;
		cond[i].centroid[2] = (double)0.;
		cond[i].mat = (int)0;
		for(j=0; j<nmged; j++)
		{
		   cond[i].shrarea[j] = (double)0.;
		   cond[i].avglen[j] = (double)0.;
		   cond[i].rmslen[j] = (double)0.;
		   cond[i].minlen[j] = (double)0.;
		   cond[i].maxlen[j] = (double)0.;
		   cond[i].numcal[j] = (double)0.;
		   cond[i].rkavg[j] = (double)0.;
		   cond[i].rkrms[j] = (double)0.;
		   cond[i].rkmin[j] = (double)0.;
		   cond[i].rkmax[j] = (double)0.;
		}
	}
	(void)fprintf(stdout,"All variables zeroed.\n");
	(void)fflush(stdout);

	/*  Now open file with second pass information in it.  */
	fp = fopen(spfile,"r");
	(void)fprintf(stdout,"second pass file opened\n");
	(void)fflush(stdout);

	/*  Read number of regions in file.  */
	(void)fscanf(fp,"%d\n",&numreg);
	(void)fprintf(stdout,"The number of regions read was %d\n",numreg);
	(void)fflush(stdout);

	if(iwrite == 1)
	{
	   (void)fprintf(fp3,"number of regions read from second ");
	   (void)fprintf(fp3,"pass file:  %d\n",numreg);
	   (void)fflush(fp3);
	}

	/*  Read all information in file.  */
	for(i=0; i<numreg; i++)
	{
	   (void)fscanf(fp,"%*d%le%le%le%d\n",&cond[i].centroid[0],
	                              &cond[i].centroid[1],
	                              &cond[i].centroid[2],&cond[i].mat);
/*
 *	   (void)fprintf(stdout,"reg=%8d, centroid:  %10.0f, %10.0f, %10.0f\n",
 *		i,cond[i].centroid[0],cond[i].centroid[1],cond[i].centroid[2]);
 *	   (void)fflush(stdout);
 */

	   for(j=0; j<numreg; j++)
	   {
		(void)fscanf(fp,"%*d%le\n",&cond[i].shrarea[j]);
/*
 *		(void)fprintf(stdout,"\treg=%8d, area=%10.0f\n",
 *		   j,cond[i].shrarea[j]);
 *		(void)fflush(stdout);
 */
	   }
	}

	(void)fclose(fp);

	/*  Check that the number of regions in the mged file  */
	/*  and the second pass file are equal.  */
	if(nmged != numreg)
	{
	  (void)fprintf(stdout,"ERROR -- The number of regions in the mged\n");
	  (void)fprintf(stdout,"file (%d) does not equal the number of\n",
		nmged);
	  (void)fprintf(stdout,"regions in the second pass file (%d).\n",
		numreg);
	  (void)fprintf(stdout,"Watch for unexplained errors.\n");
	  (void)fflush(stdout);

	  if(iwrite == 1)
	  {
	    (void)fprintf(fp3,"ERROR -- The number of regions in the mged\n");
	    (void)fprintf(fp3,"file (%d) does not equal the number of\n",
		nmged);
	    (void)fprintf(fp3,"regions in the second pass file (%d).\n",
		numreg);
	    (void)fprintf(fp3,"Watch for unexplained errors.\n");
	    (void)fflush(fp3);
	  }
	}

	/*  Get database ready by starting preparation.  */
	rt_prep(rtip);

        /*  Find center of bounding rpp.  */
        center[X] = rtip->mdl_min[X] + (rtip->mdl_max[X] -
		rtip->mdl_min[X]) / 2.;
        center[Y] = rtip->mdl_min[Y] + (rtip->mdl_max[Y] -
		rtip->mdl_min[Y]) / 2.;
        center[Z] = rtip->mdl_min[Z] + (rtip->mdl_max[Z] -
		rtip->mdl_min[Z]) / 2.;

        /*  Find length of diagonal.  */
        diagonal = (rtip->mdl_max[X] - rtip->mdl_min[X])
                     * (rtip->mdl_max[X] - rtip->mdl_min[X])
                 + (rtip->mdl_max[Y] - rtip->mdl_min[Y])
                     * (rtip->mdl_max[Y] - rtip->mdl_min[Y])
                 + (rtip->mdl_max[Z] - rtip->mdl_min[Z])
                     * (rtip->mdl_max[Z] - rtip->mdl_min[Z]);
        diagonal = sqrt(diagonal) / 2. + .5;

        /*  Find minimum & maximum of grid.  */
        xmin = center[X] - diagonal;
        xmax = center[X] + diagonal;
        ymin = center[Y] - diagonal;
        ymax = center[Y] + diagonal;
        zmin = center[Z] - diagonal;
        zmax = center[Z] + diagonal;

        /*  Print center of bounding rpp, diagonal, & maximum  */
        /*  & minimum of grid.  */
        (void)fprintf(stdout,"Center of bounding rpp ( %f, %f, %f )\n",
		center[X],center[Y],center[Z]);
        (void)fprintf(stdout,"Length of diagonal of bounding rpp:  %f\n",
		diagonal);
        (void)fprintf(stdout,"Minimums & maximums of grid:\n");
        (void)fprintf(stdout,"  %f - %f\n",xmin,xmax);
        (void)fprintf(stdout,"  %f - %f\n",ymin,ymax);
        (void)fprintf(stdout,"  %f - %f\n\n",zmin,zmax);
        (void)fflush(stdout);

	/*  Write model minimum & maximum.  */
	(void)fprintf(stdout,"Model minimum & maximum.\n");
	(void)fprintf(stdout,"\tX:  %f to %f\n\tY:  %f to %f\n\tZ:  %f to %f\n\n",
	   rtip->mdl_min[X],rtip->mdl_max[X],
	   rtip->mdl_min[Y],rtip->mdl_max[Y],
	   rtip->mdl_min[Z],rtip->mdl_max[Z]);
	(void)fflush(stdout);

	if(iwrite == 1)
	{
	   (void)fprintf(fp3,"Model minimum & maximum.\n");
	   (void)fprintf(fp3,"\tX:  %f to %f\n\tY:  %f kto %f\n",
	      rtip->mdl_min[X],rtip->mdl_max[X],
	      rtip->mdl_min[Y],rtip->mdl_max[Y]);
	   (void)fprintf(fp3,"\tZ:  %f to %f\n\n",
	      rtip->mdl_min[Z],rtip->mdl_max[Z]);
	   (void)fflush(fp3);
	}

	/*  User enters grid spacing.  All units are in mm.  */
	(void)fprintf(stdout,"Enter spacing (mm) between fired rays.  ");
	(void)fflush(stdout);
	(void)scanf("%lf",&gridspace);

	(void)fprintf(stdout,"\ngrid spacing:  %f\n",gridspace);
	(void)fflush(stdout);

	if(iwrite == 1)
	{
	   (void)fprintf(fp3,"gridspacing:  %f\n\n",gridspace);
	   (void)fflush(fp3);
	}

	/*  Set up parameters for rt_shootray.  */
	ap.a_hit = hit;		/*  User supplied hit function.  */
	ap.a_miss = miss;	/*  User supplied miss function.  */
	ap.a_overlap = ovrlap;	/*  user supplied overlap function.  */
	ap.a_rt_i = rtip;	/*  Pointer from rt_dirbuild.  */
	ap.a_onehit = 0;	/*  Hit flag (returns all hits).  */
	ap.a_level = 0;		/*  Recursion level for diagnostics.  */
	ap.a_resource = 0;	/*  Address of resource structure (NULL).  */

	/*  Put angles for rotation into radians.  */
	angle[X] = radians((double)GAMMA);
	angle[Y] = radians((double)BETA);
	angle[Z] = radians((double)ALPHA);

	/*  Set up and shoot down the 1st axis, positive to negative  */
	/*  (x-axis).  */

	(void)fprintf(stdout,"\nShooting down 1st axis.\n");
	(void)fflush(stdout);

	strtpt[X] = xmax;
	strtpt[Y] = ymin + gridspace / 2.;
	strtpt[Z] = zmin + gridspace / 2.;
	strtdir[X] = (-1);
	strtdir[Y] = 0;
	strtdir[Z] = 0;

	/*  Rotate starting point.  (new pt = C + R[P -C])  */
	t[X] = strtpt[X] - center[X];
	t[Y] = strtpt[Y] - center[Y];
	t[Z] = strtpt[Z] - center[Z];

	(void)rotate(t,angle,r);

	ap.a_ray.r_pt[X] = center[X] + r[X];
	ap.a_ray.r_pt[Y] = center[Y] + r[Y];
	ap.a_ray.r_pt[Z] = center[Z] + r[Z];

	/*  Rotate firing direction.  (new dir = R[D])  */
	(void)rotate(strtdir,angle,r);
	ap.a_ray.r_dir[X] = r[X];
	ap.a_ray.r_dir[Y] = r[Y];
	ap.a_ray.r_dir[Z] = r[Z];

	while(strtpt[Z] <= zmax)
	{	/*  START # 3  */

	   iprev = (-1);	/*  No previous shots.  */

	   /*  Call rt_shootray.  */
	   (void)rt_shootray ( &ap );

	   strtpt[Y] += gridspace;
	   if(strtpt[Y] > ymax)
	   {
		strtpt[Y] = ymin + gridspace / 2.;
		strtpt[Z] += gridspace;
	   }

	   t[X] = strtpt[X] - center[X];
	   t[Y] = strtpt[Y] - center[Y];
	   t[Z] = strtpt[Z] - center[Z];

	   (void)rotate(t,angle,r);

	   ap.a_ray.r_pt[X] = center[X] + r[X];
	   ap.a_ray.r_pt[Y] = center[Y] + r[Y];
	   ap.a_ray.r_pt[Z] = center[Z] + r[Z];

	}	/*  END # 3  */

	/*  Shoot down 2nd & 3rd axes if necessary.  */
	if(ifire == 0)
	{						/*  START # 1000  */
	   /*  Set up & shoot down the 2nd axis (y-axis).  */
	   (void)printf("\nShooting down the 2nd axis.\n");
	   (void)fflush(stdout);

	   strtpt[X] = xmin + gridspace / 2.;
	   strtpt[Y] = ymax;
	   strtpt[Z] = zmin + gridspace / 2.;
	   strtdir[X] = 0.;
	   strtdir[Y] = (-1.);
	   strtdir[X] = 0.;

	   /*  Rotate starting point (new pt = C + R[P - C]).  */
	   t[X] = strtpt[X] - center [X];
	   t[Y] = strtpt[Y] - center [Y];
	   t[Z] = strtpt[Z] - center [Z];

	   (void)rotate(t,angle,r);

	   ap.a_ray.r_pt[X] = center[X] + r[X];
	   ap.a_ray.r_pt[Y] = center[Y] + r[Y];
	   ap.a_ray.r_pt[Z] = center[Z] + r[Z];

	   /*  Rotate firing direction (new dir = R[D])  */
	   (void)rotate(strtdir,angle,r);

	   ap.a_ray.r_dir[X] = r[X];
	   ap.a_ray.r_dir[Y] = r[Y];
	   ap.a_ray.r_dir[Z] = r[Z];

	   while(strtpt[Z] <= zmax)
	   {						/*  START # 1010  */
		iprev = (-1);		/*  No previous shots.  */

		/*  Call rt_shootray.  */
		(void)rt_shootray(&ap);

		strtpt[X] += gridspace;
		if(strtpt[X] > xmax)
		{
		   strtpt[X] = xmin + gridspace / 2.;
		   strtpt[Z] += gridspace;
		}

		t[X] = strtpt[X] - center[X];
		t[Y] = strtpt[Y] - center[Y];
		t[Z] = strtpt[Z] - center[Z];

		(void)rotate(t,angle,r);

		ap.a_ray.r_pt[X] = center[X] + r[X];
		ap.a_ray.r_pt[Y] = center[Y] + r[Y];
		ap.a_ray.r_pt[Z] = center[Z] + r[Z];
	   }						/*  END # 1010  */

	   /*  Set up & shoot down the 3rd axis (z-axis).  */
	   (void)printf("\nShooting down the 3rd axis.\n");
	   (void)fflush(stdout);

	   strtpt[X] = xmin + gridspace / 2.;
	   strtpt[Y] = ymin + gridspace / 2.;
	   strtpt[Z] = zmax;
	   strtdir[X] = 0.;
	   strtdir[Y] = 0.;
	   strtdir[Z] = (-1.);

	   /*  Rotate starting points (new pt = C + R[P - C]).  */
	   t[X] = strtpt[X] - center[X];
	   t[Y] = strtpt[Y] - center[Y];
	   t[Z] = strtpt[Z] - center[Z];

	   (void)rotate(t,angle,r);

	   ap.a_ray.r_pt[X] = r[X];
	   ap.a_ray.r_pt[Y] = r[Y];
	   ap.a_ray.r_pt[Z] = r[Z];

	   while(strtpt[Y] <= ymax)
	   {						/*  START # 1020  */
		iprev = (-1);		/*  No previous shots.  */

		/*  Call rt_shootray.  */
		(void)rt_shootray(&ap);

		strtpt[X] += gridspace;
		if(strtpt[X] > xmax)
		{
		   strtpt[X] = xmin + gridspace / 2.;
		   strtpt[Y] += gridspace;
		}

		t[X] = strtpt[X] - center[X];
		t[Y] = strtpt[Y] - center[Y];
		t[Z] = strtpt[Z] - center[Z];

		(void)rotate(t,angle,r);

		ap.a_ray.r_pt[X] = center[X] + r[X];
		ap.a_ray.r_pt[Y] = center[Y] + r[Y];
		ap.a_ray.r_pt[Z] = center[Z] + r[Z];
	   }						/*  END # 1020  */
	}						/*  END # 1000  */

	/*  Calculate final length between centroid & shared surface area.  */
	if(iwrite == 0)
	{
		(void)fprintf(stdout,"\n\nFinal numbers.\n");
		(void)fflush(stdout);
	}

	for(i=0; i<numreg; i++)
	{

	   if(iwrite == 0)
	   {
	   	(void)fprintf(stdout,"reg#=%d, matid=%d\n",(i+1),cond[i].mat);
	   	(void)fflush(stdout);
	   }

	   if(iwrite == 1)
	   {
		(void)fprintf(fp3,"reg#=%d, matid=%d\n",(i+1),cond[i].mat);
		(void)fflush(fp3);
	   }

	   for(j=0; j<numreg; j++)
	   {
		if(cond[i].numcal[j] > ZEROTOL)
		{
		   cond[i].avglen[j] /= cond[i].numcal[j];
		   cond[i].rmslen[j] /= cond[i].numcal[j];
		   cond[i].rmslen[j] = sqrt(cond[i].rmslen[j]);

		   if(iwrite == 0)
		   {
		      (void)fprintf(stdout,"\tadjreg=%d, numcal=%f, shrarea=%f, ",
		         (j+1),cond[i].numcal[j],cond[i].shrarea[j]);
		      (void)fprintf(stdout,"avglen=%f\n",cond[i].avglen[j]);
		      (void)fprintf(stdout,"\t\trmslen=%f, ",cond[i].rmslen[j]);
		      (void)fprintf(stdout,"minlen=%f, maxlen=%f\n",
		         cond[i].minlen[j],cond[i].maxlen[j]);
		      (void)fflush(stdout);
		   }

		   if(iwrite == 1)
		   {
		      (void)fprintf(fp3,"\tadjreg=%d, numcal=%f, shrarea=%f, ",
		         (j+1),cond[i].numcal[j],cond[i].shrarea[j]);
		      (void)fprintf(fp3,"avglen=%f\n",cond[i].avglen[j]);
		      (void)fprintf(fp3,"\t\trmslen=%f, ",cond[i].rmslen[j]);
		      (void)fprintf(fp3,"minlen=%f, maxlen=%f\n",
		         cond[i].minlen[j],cond[i].maxlen[j]);
		      (void)fflush(fp3);
		   }

		}
		else
		{
		   cond[i].avglen[j] = 0.;
		   cond[i].rmslen[j] = 0.;
		}
	   }
	}

	if(iwrite == 1)
	{
	   /*  Print summary of all files used.  */
	   (void)fprintf(fp3,"\n\nSUMMARY OF FILES USED & CREATED\n");
	   (void)fprintf(fp3,"\t.g file used:  %s\n",argv[1]);
	   (void)fprintf(fp3,"\tregions used:\n");
	   (void)fflush(fp3);
	   i=2;
	   while(argv[i] != NULL)
	   {
	      (void)fprintf(fp3,"\t\t%s\n",argv[i]);
	      (void)fflush(fp3);
	      i++;
	   }
	   (void)fprintf(fp3,"\tfile containing second pass information:  %s\n",
		spfile);
	   (void)fprintf(fp3,"\tmaterial file used:  %s\n",filemat);
	   (void)fprintf(fp3,"\toutput file created:  %s\n",filename);
	   if(typeout == 0)
	   {
		(void)fprintf(fp3,"\tconductivity file created:  %s\n",confile);
		(void)fprintf(fp3,"\t  (format is PRISM %d.0)\n",prmrel);
	   }
	   if(typeout == 1) (void)fprintf(fp3,"\tgeneric file created:  %s\n"
		,genfile);
	   (void)fprintf(fp3,"\tconductivity table file created:  %s\n",
		tblfile);
	   (void)fprintf(fp3,"\terror file created:  %s\n\n\n",fileerr);
	   (void)fflush(fp3);

	   (void)fclose(fp3);
	}

	/*------------------------------------------------------------------*/

	/*  Open conductivity file to be used with PRISM if needed.  */
	if(typeout == 0)
	{
	   fp1=fopen(confile,"w");
	   (void)fprintf(fp1,"Conductivity file for use with PRISM.\n");
	   (void)fflush(fp1);
	}

	/*  Make calculations & write to conductivity file.  */
	for(i=0; i<numreg; i++)
	{	/*  START # 6  */

	/*  Make conductivity file triangular.  This program still  */
	/*  computes the ENTIRE matrix.  */

	   for(j=(i+1); j<numreg; j++)
	   {	/*  START # 7  */

		if( (cond[i].avglen[j] != 0) )
		{	/*  START # 8  */
		   /*  Find correct thermal conductivity.  */
		   /*  If ki or kj = 0 => rk = 0.  */
		   ki = k[cond[i].mat];
		   kj = k[cond[j].mat];

		   /*  All calculations will be in meters &  */
		   /*  square meters.  */

		   areai = cond[i].shrarea[j] * 1.e-6;

		   /*  average length  */
		   leni = cond[i].avglen[j] * 1.e-3;
		   lenj = cond[j].avglen[i] * 1.e-3;
		   if(((-ZEROTOL < ki) && (ki < ZEROTOL)) ||
		      ((-ZEROTOL < kj) && (kj < ZEROTOL)))
			cond[i].rkavg[j] = 0.;
		   else
		   {
			rki = leni / (ki * areai);
			rkj = lenj / (kj * areai);
		        cond[i].rkavg[j] = 1. / (rki + rkj);
		   }

		   /*  rms length  */
		   leni = cond[i].rmslen[j] * 1.e-3;
		   lenj = cond[j].rmslen[i] * 1.e-3;
		   if(((-ZEROTOL < ki) && (ki < ZEROTOL)) ||
		      ((-ZEROTOL < kj) && (kj < ZEROTOL)))
			cond[i].rkrms[j] = 0.;
		   else
		   {
		        rki = leni / (ki * areai);
		        rkj = lenj / (kj * areai);
		        cond[i].rkrms[j] = 1. / (rki + rkj);
		   }

		   /*  minimum length  */
		   leni = cond[i].minlen[j] * 1.e-3;
		   lenj = cond[j].minlen[i] * 1.e-3;
		   if(((-ZEROTOL < ki) && (ki < ZEROTOL)) ||
		      ((-ZEROTOL < kj) && (kj < ZEROTOL)))
			cond[i].rkmin[j] = 0.;
		   else
		   {
		        rki = leni / (ki * areai);
		        rkj = lenj / (kj * areai);
		        cond[i].rkmin[j] = 1. / (rki + rkj);
		   }

		   /*  maximum length  */
		   leni = cond[i].maxlen[j] * 1.e-3;
		   lenj = cond[j].maxlen[i] * 1.e-3;
		   if(((-ZEROTOL < ki) && (ki < ZEROTOL)) ||
		      ((-ZEROTOL < kj) && (kj < ZEROTOL)))
			cond[i].rkmax[j] = 0.;
		   else
		   {
		        rki = leni / (ki * areai);
		        rkj = lenj / (kj * areai);
		        cond[i].rkmax[j] = 1. / (rki + rkj);
		   }

		   /*  Print if had adjacent regions, conductivity  */
		   /*  may be zero.  */

		   /*  Print only if PRISM file is to be created.  */
		   if(typeout == 0) {		/*  START # 8A  */
		   if( (itype == 1) && (cond[i].shrarea[j] > ZEROTOL) )
		   {
		     if(prmrel == 2)
			(void)fprintf(fp1,"%3d %3d %7.3f %.3e\n",
			(j+1),(i+1),cond[i].rkavg[j],
			(cond[i].shrarea[j] * 1.0e-6));
		     if(prmrel == 3)
			(void)fprintf(fp1,"%6d %6d %7.3f %.3e\n",
			(j+1),(i+1),cond[i].rkavg[j],
			(cond[i].shrarea[j] * 1.0e-6));
		   }

		   if( (itype == 2) && (cond[i].shrarea[j] > ZEROTOL) )
		   {
		     if(prmrel == 2)
			(void)fprintf(fp1,"%3d %3d %7.3f %.3e\n",
			(j+1),(i+1),cond[i].rkrms[j],
			(cond[i].shrarea[j] * 1.0e-6));
		     if(prmrel == 3)
			(void)fprintf(fp1,"%6d %6d %7.3f %.3e\n",
			(j+1),(i+1),cond[i].rkrms[j],
			(cond[i].shrarea[j] * 1.0e-6));
		   }

		   if( (itype == 3) && (cond[i].shrarea[j] > ZEROTOL) )
		   {
		     if(prmrel == 2)
			(void)fprintf(fp1,"%3d %3d %7.3f %.3e\n",
			(j+1),(i+1),cond[i].rkmin[j],
			(cond[i].shrarea[j] * 1.0e-6));
		     if(prmrel == 3)
			(void)fprintf(fp1,"%6d %6d %7.3f %.3e\n",
			(j+1),(i+1),cond[i].rkmin[j],
			(cond[i].shrarea[j] * 1.0e-6));
		   }

		   if( (itype == 4) && (cond[i].shrarea[j] > ZEROTOL) )
		   {
		     if(prmrel == 2)
			(void)fprintf(fp1,"%3d %3d %7.3f %.3e\n",
			(j+1),(i+1),cond[i].rkmax[j],
			(cond[i].shrarea[j] * 1.0e-6));
		     if(prmrel == 3)
			(void)fprintf(fp1,"%6d %6d %7.3f %.3e\n",
			(j+1),(i+1),cond[i].rkmax[j],
			(cond[i].shrarea[j] * 1.0e-6));
		   }

		   (void)fflush(fp1);
		   }				/*  END of # 8A  */
		}	/*  END # 8  */
	   }	/*  END # 7  */
	}	/*  END # 6  */

	if(typeout == 0) (void)fclose(fp1);

	/*------------------------------------------------------------------*/

	/*  Open and write to generic file if necessary. */
	/*  The format follows.  */
	/*  4  region number  number of adjacent regions  */
	/*     adjacent region  shared area  conduction distance  */

	if(typeout == 1)
	{
	   /*  Open file.  */
	   fp6 = fopen(genfile,"w");
	   (void)printf("Opened generic file.\n");
	   (void)fflush(stdout);

	   for(i=0; i<numreg; i++)
	   {
		/*  Find number of adjacent regions.  */
/*
 *		(void)printf("Ready to find number of adjacent areas.\n");
 *		(void)fflush(stdout);
 */
		nadjreg = 0;
/*
 *		(void)printf("nadjreg = %d\n",nadjreg);
 *		(void)fflush(stdout);
 */
		for(j=0; j<numreg; j++)
		{
/*
 *		   (void)printf("%d, %d, %f\n",i,j,cond[i].shrarea[j]);
 *		   (void)fflush(stdout);
 */
		   if(cond[i].shrarea[j] > ZEROTOL) nadjreg += 1;
		}
/*
 *		(void)printf("Found number of adjacent areas.\n");
 *		(void)fflush(stdout);
 */

		(void)fprintf(fp6,"4  %5d  %5d\n",(i+1),nadjreg);
		(void)fflush(fp6);

		for(j=0; j<numreg; j++)
		{
		   if(cond[i].shrarea[j] > ZEROTOL)
		   {
			(void)fprintf(fp6,"   %5d  %.3e  ",(j+1),
			   (cond[i].shrarea[j] * 1.e-6));
			if(itype == 1) (void)fprintf(fp6,"%.3e\n",
			   (cond[i].avglen[j] * 1.e-3));
			if(itype == 2) (void)fprintf(fp6,"%.3e\n",
			   (cond[i].rmslen[j] * 1.e-3));
			if(itype == 3) (void)fprintf(fp6,"%.3e\n",
			   (cond[i].minlen[j] * 1.e-3));
			if(itype == 4) (void)fprintf(fp6,"%.3e\n",
			   (cond[i].maxlen[j] * 1.e-3));
		   }
		   (void)fflush(fp6);
		}
	   }
	   (void)fclose(fp6);
	}

	/*------------------------------------------------------------------*/

	/*  Open conductivity table file and write information to  */
	/*  it.  All units will be in meters or square meters.  */
	fp2=fopen(tblfile,"w");
	(void)fprintf(fp2,"Conductivity table.  Units are in meters or ");
	(void)fprintf(fp2,"square meters.\n");

	(void)fprintf(fp2," reg, mat, adj,   shrarea,");
	(void)fprintf(fp2,"    avglen,     rkavg,");
	(void)fprintf(fp2,"    rmslen,     rkrms,");
	(void)fprintf(fp2,"    minlen,     rkmin,");
	(void)fprintf(fp2,"    maxlen,     rkmax\n");

	(void)fflush(fp2);

	for(i=0; i<numreg; i++)
	{	/*  START # 9  */
	   for(j=0; j<numreg; j++)
	   {	/*  START # 10  */
		if(cond[i].shrarea[j] != 0)
		{	/*  START # 11  */
		   a1 = cond[i].shrarea[j] * 1.e-6;
		   l1 = cond[i].avglen[j] * 1.e-3;
		   l2 = cond[i].rmslen[j] * 1.e-3;
		   l3 = cond[i].minlen[j] * 1.e-3;
		   l4 = cond[i].maxlen[j] * 1.e-3;

		   (void)fprintf(fp2,"%4d,%4d,%4d, %.3e,",
			(i+1),cond[i].mat,(j+1),a1);
		   if(j > i)
		   {
		     (void)fprintf(fp2," %.3e, %.3e,",l1,cond[i].rkavg[j]);
		     (void)fprintf(fp2," %.3e, %.3e,",l2,cond[i].rkrms[j]);
		     (void)fprintf(fp2," %.3e, %.3e,",l3,cond[i].rkmin[j]);
		     (void)fprintf(fp2," %.3e, %.3e\n",l4,cond[i].rkmax[j]);
		   }
		   else
		   {
		     (void)fprintf(fp2," %.3e, %.3e,",l1,cond[j].rkavg[i]);
		     (void)fprintf(fp2," %.3e, %.3e,",l2,cond[j].rkrms[i]);
		     (void)fprintf(fp2," %.3e, %.3e,",l3,cond[j].rkmin[i]);
		     (void)fprintf(fp2," %.3e, %.3e\n",l4,cond[j].rkmax[i]);
		   }

		   (void)fflush(fp2);
		}	/*  END # 11  */
	   }	/*  END # 10  */
	}	/*  END # 9  */

	(void)fclose(fp2);

	/*------------------------------------------------------------------*/

	/*  Print summary of all files used.  */
	(void)fprintf(stdout,"\n\nSUMMARY OF FILES USED & CREATED\n");
	(void)fprintf(stdout,"\t.g file used:  %s\n",argv[1]);
	(void)fprintf(stdout,"\tregions used:\n");
	(void)fflush(stdout);
	i=2;
	while(argv[i] != NULL)
	{
	   (void)fprintf(stdout,"\t\t%s\n",argv[i]);
	   (void)fflush(stdout);
	   i++;
	}
	(void)fprintf(stdout,"\tfile containing second pass information:  %s\n",
		spfile);
	(void)fprintf(stdout,"\tmaterial file used:  %s\n",filemat);
	if(iwrite == 1)
	{
	   (void)fprintf(stdout,"\toutput file created:  %s\n",filename);
	}
	if(typeout == 0)
	{
	   (void)fprintf(stdout,"\tconductivity file created:  %s\n",confile);
	   (void)fprintf(stdout,"\t  (format is PRISM %d.0)\n",prmrel);
	}
	if(typeout == 1) (void)printf("\tgeneric file created:  %s\n",genfile);
	(void)fprintf(stdout,"\tconductivity table file created:  %s\n",tblfile);
	(void)fprintf(stdout,"\terror file created:  %s\n\n\n",fileerr);
	(void)fflush(stdout);

	/*------------------------------------------------------------------*/

	/*  Open error file.  */
	fp4 = fopen(fileerr,"w");

	/*  Write errors to error file.  */
	(void)fprintf(fp4,"\nERRORS from secpass\n\n");
	/*  Write type of file created to error file.  */
	if(typeout == 0)
	{
	   (void)fprintf(fp4,"PRISM %d.0 conductivity file, %s, created.\n\n",
		prmrel,confile);
	}
	if(typeout == 1) (void)fprintf(fp4,"Generic file, %s, created.\n\n",
		genfile);
	(void)fflush(fp4);
	for(i=0; i<numreg; i++)
	{
	   for(j=0; j<numreg;  j++)
	   {
		if( (cond[i].numcal[j] > ZEROTOL) &&
		   ( cond[i].numcal[j] < MINCAL ) )
		{
		   (void)fprintf(fp4,"region %d, adjacent region %d:\n",
			(i+1),(j+1));
		   (void)fprintf(fp4,"\tnumber of length calculations ");
		   (void)fprintf(fp4,"below minimum of %d\n",MINCAL);
		   (void)fflush(fp4);
		}
	   }
	}
	(void)fclose(fp4);

	/*------------------------------------------------------------------*/

   /*  Everything completed, free memory.  */
   (void)fprintf(stdout,"Freeing memory.\n");
   (void)fflush(stdout);
   for(i=0; i<nmged; i++)
   {
	free(cond[i].shrarea);
	free(cond[i].avglen);
	free(cond[i].rmslen);
	free(cond[i].minlen);
	free(cond[i].maxlen);
	free(cond[i].numcal);
	free(cond[i].rkavg);
	free(cond[i].rkrms);
	free(cond[i].rkmin);
	free(cond[i].rkmax);
   }
   free(cond);

   }	/*  END # 2  */
   return(0);
}	/*  END # 1  */


/*  User supplied hit function.  */
int
hit(register struct application *ap_p, struct partition *PartHeadp)
{	/*  START # 1H  */

   register struct partition *pp;
   register struct hit *hitp;
   register struct soltab *stp;

   double d[3];		/*  used for checking tolerance of  */
			/*  adjacent regions  */
   double dist;		/*  used for finding lenght between  */
			/*  centroid & adjacent surface area  */

/*
 * (void)fprintf(stdout,"In hit function.\n");
 * (void)fflush(stdout);
 */

   pp = PartHeadp->pt_forw;
   for( ; pp != PartHeadp; pp = pp->pt_forw)
   {	/*  START # 2H  */
	icur = pp->pt_regionp->reg_bit;	/*  Number of region hit.  */

	/*  Find hit point of entering ray.  */
	hitp = pp->pt_inhit;
	stp = pp->pt_inseg->seg_stp;
	RT_HIT_NORM(hitp,stp,&(ap_p->a_ray));
	enterpt[X] = hitp->hit_point[X];
	enterpt[Y] = hitp->hit_point[Y];
	enterpt[Z] = hitp->hit_point[Z];

	/*  Find lengths between centroids and adjacent surface areas.  */

	if(iprev >= 0)
	{	/*  START # 3H  */
	   d[X] = enterpt[X] - leavept[X];
	   if(d[X] < 0) d[X] = (-d[X]);
	   d[Y] = enterpt[Y] - leavept[Y];
	   if(d[Y] < 0) d[Y] = (-d[Y]);
	   d[Z] = enterpt[Z] - leavept[Z];
	   if(d[Z] < 0) d[Z] = (-d[Z]);

	   if( (d[X] < ADJTOL) && (d[Y] < ADJTOL) && (d[Z] < ADJTOL) )
	   {	/*  START # 4H  */
		/*  Find length for previous region. */
		dist = ( (cond[iprev].centroid[X] - enterpt[X])
		         * (cond[iprev].centroid[X] - enterpt[X]) ) +
		       ( (cond[iprev].centroid[Y] - enterpt[Y])
		         * (cond[iprev].centroid[Y] - enterpt[Y]) ) +
		       ( (cond[iprev].centroid[Z] - enterpt[Z])
		         * (cond[iprev].centroid[Z] - enterpt[Z]) );
		dist = sqrt(dist);
		cond[iprev].avglen[icur] += dist;
		cond[iprev].rmslen[icur] += (dist * dist);
		cond[iprev].numcal[icur] += 1.;

		if( (-ZEROTOL < cond[iprev].minlen[icur]) &&
		    (cond[iprev].minlen[icur] < ZEROTOL) )
		{
			cond[iprev].minlen[icur] = dist;
		}
		else if( dist < cond[iprev].minlen[icur] )
		{
			cond[iprev].minlen[icur] = dist;
		}

		if( (-ZEROTOL < cond[iprev].maxlen[icur]) &&
		    (cond[iprev].maxlen[icur] < ZEROTOL) )
		{
			cond[iprev].maxlen[icur] = dist;
		}
		else if( cond[iprev].maxlen[icur] < dist )
		{
			cond[iprev].maxlen[icur] = dist;
		}

/*
 *		(void)fprintf(stdout,"\treg#:  %d, length:  %f\n",iprev,dist);
 *		(void)fflush(stdout);
 */

		/*  Find lenght for current region.  */
		dist = ( (cond[icur].centroid[X] - enterpt[X])
		         * (cond[icur].centroid[X] - enterpt[X]) ) +
		       ( (cond[icur].centroid[Y] - enterpt[Y])
		         * (cond[icur].centroid[Y] - enterpt[Y]) ) +
		       ( (cond[icur].centroid[Z] - enterpt[Z])
		         * (cond[icur].centroid[Z] - enterpt[Z]) );
		dist = sqrt(dist);
		cond[icur].avglen[iprev] += dist;
		cond[icur].rmslen[iprev] += (dist * dist);
		cond[icur].numcal[iprev] += 1.;

		if( (-ZEROTOL < cond[icur].minlen[iprev]) &&
		    (cond[icur].minlen[iprev] < ZEROTOL) )
		{
			cond[icur].minlen[iprev] = dist;
		}
		else if( dist < cond[icur].minlen[iprev] )
		{
			cond[icur].minlen[iprev] = dist;
		}

		if( (-ZEROTOL < cond[icur].maxlen[iprev]) &&
		    (cond[icur].maxlen[iprev] < ZEROTOL) )
		{
			cond[icur].maxlen[iprev] = dist;
		}
		else if( cond[icur].maxlen[iprev] < dist )
		{
			cond[icur].maxlen[iprev] = dist;
		}

/*
 *		(void)fprintf(stdout,"\treg#:  %d, length:  %f\n",icur,dist);
 *		(void)fflush(stdout);
 */

	   }	/*  END # 4H  */
	}	/*  END # 3H  */

	/*  Find hit point of leaving ray.  */
	hitp = pp->pt_outhit;
	stp = pp->pt_outseg->seg_stp;
	RT_HIT_NORM(hitp,stp,&(ap_p->a_ray));
	leavept[X] = hitp->hit_point[X];
	leavept[Y] = hitp->hit_point[Y];
	leavept[Z] = hitp->hit_point[Z];

/*
 *	(void)fprintf(stdout,"current region:  %d, previous region:  %d\n",icur,iprev);
 *	(void)fprintf(stdout,"   entering pt:  %f, %f, %f\n",enterpt[X],enterpt[Y],
 *		enterpt[Z]);
 *	(void)fprintf(stdout,"   leaving pt:   %f, %f, %f\n",leavept[X],leavept[Y],
 *		leavept[Z]);
 */

	/*  Set previous region to current region.  */
	iprev = icur;
   }	/*  END # 2H  */

   return(1);

}	/*  END # 1H  */


/*  User supplied miss function.  */
int
miss(register struct application *ap_p)
{	/*  START # 1M  */

/*
 * (void)fprintf(stdout,"In miss function.\n");
 * (void)fflush(stdout);
 */

   return(0);

}	/*  END # 1M */

int
ovrlap(register struct application *ap_p, struct partition *PartHeadp, struct region *reg1, struct region *reg2)

/*  User supplied overlap function that does nothing.  */

                                  
                            
                          
{
	return(1);
}


@


11.9
log
@change conf.h to a wrapped config.h
@
text
@d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/irprep/secpass.c,v 11.8 2004/04/05 07:47:44 morrison Exp $ (BRL)";
@


11.8
log
@merge of ansi-6-0-branch into HEAD
@
text
@d44 1
a44 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d47 5
a51 1
#include "conf.h"
@


11.7
log
@update copyright to include span through 2003
@
text
@d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/irprep/secpass.c,v 11.6 2002/08/20 17:07:32 jra Exp $ (BRL)";
d70 5
a74 5
extern int hit();	/*  User defined hit function.  */
extern int miss();	/*  User defined miss function.  */
extern int ovrlap();	/*  User defined overlap function.  */
extern void rotate();	/*  Subroutine to rotate a point.  */
extern double radians();/*  Subroutine to put an angle into radians.  */
d107 1
a107 5
int main(argc,argv)

int argc;
char *argv[];

d1156 1
a1156 5
hit(ap_p,PartHeadp)

register struct application *ap_p;
struct partition *PartHeadp;

d1303 1
a1303 4
miss(ap_p)

register struct application *ap_p;

d1316 1
a1316 1
ovrlap(ap_p,PartHeadp,reg1,reg2)
d1320 3
a1322 3
register struct application *ap_p;
struct partition *PartHeadp;
struct region *reg1,*reg2;
@


11.6
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d12 1
a12 1
 *	This software is Copyright (C) 1990 by the United States Army.
d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/irprep/secpass.c,v 11.4 2001/08/09 20:09:10 jra Exp $ (BRL)";
@


11.6.4.1
log
@sync to HEAD...
@
text
@d12 1
a12 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/irprep/secpass.c,v 11.7 2004/02/02 17:39:06 morrison Exp $ (BRL)";
@


11.6.10.1
log
@merge from HEAD
@
text
@d12 1
a12 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/irprep/secpass.c,v 11.7 2004/02/02 17:39:06 morrison Exp $ (BRL)";
@


11.6.10.2
log
@merge from head
@
text
@d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/irprep/secpass.c,v 11.6.10.1 2004/02/12 19:50:38 erikg Exp $ (BRL)";
@


11.6.2.1
log
@Initial ANSIfication
@
text
@d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/irprep/secpass.c,v 11.6 2002/08/20 17:07:32 jra Exp $ (BRL)";
d70 5
a74 5
extern int hit(register struct application *ap_p, struct partition *PartHeadp);	/*  User defined hit function.  */
extern int miss(register struct application *ap_p);	/*  User defined miss function.  */
extern int ovrlap(register struct application *ap_p, struct partition *PartHeadp, struct region *reg1, struct region *reg2);	/*  User defined overlap function.  */
extern void rotate(double *p, double *a, double *np);	/*  Subroutine to rotate a point.  */
extern double radians(double a);/*  Subroutine to put an angle into radians.  */
d107 5
a111 1
int main(int argc, char **argv)
d1160 5
a1164 1
hit(register struct application *ap_p, struct partition *PartHeadp)
d1311 4
a1314 1
miss(register struct application *ap_p)
d1327 1
a1327 1
ovrlap(register struct application *ap_p, struct partition *PartHeadp, struct region *reg1, struct region *reg2)
d1331 3
a1333 3
                                  
                            
                          
@


11.6.2.2
log
@sync branch with HEAD
@
text
@d12 1
a12 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d44 1
a44 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.5
log
@Converted from K&R to ANSI C - RFH
@
text
@d70 5
a74 5
extern int hit(register struct application *ap_p, struct partition *PartHeadp);	/*  User defined hit function.  */
extern int miss(register struct application *ap_p);	/*  User defined miss function.  */
extern int ovrlap(register struct application *ap_p, struct partition *PartHeadp, struct region *reg1, struct region *reg2);	/*  User defined overlap function.  */
extern void rotate(double *p, double *a, double *np);	/*  Subroutine to rotate a point.  */
extern double radians(double a);/*  Subroutine to put an angle into radians.  */
d107 5
a111 1
int main(int argc, char **argv)
d1160 5
a1164 1
hit(register struct application *ap_p, struct partition *PartHeadp)
d1311 4
a1314 1
miss(register struct application *ap_p)
d1327 1
a1327 1
ovrlap(register struct application *ap_p, struct partition *PartHeadp, struct region *reg1, struct region *reg2)
d1331 3
a1333 3
                                  
                            
                          
@


11.4
log
@lint
@
text
@d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/irprep/secpass.c,v 11.3 2000/09/06 20:08:49 mike Exp $ (BRL)";
d70 5
a74 5
extern int hit();	/*  User defined hit function.  */
extern int miss();	/*  User defined miss function.  */
extern int ovrlap();	/*  User defined overlap function.  */
extern void rotate();	/*  Subroutine to rotate a point.  */
extern double radians();/*  Subroutine to put an angle into radians.  */
d107 1
a107 5
int main(argc,argv)

int argc;
char *argv[];

d1156 1
a1156 5
hit(ap_p,PartHeadp)

register struct application *ap_p;
struct partition *PartHeadp;

d1303 1
a1303 4
miss(ap_p)

register struct application *ap_p;

d1316 1
a1316 1
ovrlap(ap_p,PartHeadp,reg1,reg2)
d1320 3
a1322 3
register struct application *ap_p;
struct partition *PartHeadp;
struct region *reg1,*reg2;
@


11.3
log
@
lint
@
text
@d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/irprep/secpass.c,v 11.2 2000/08/24 23:10:21 mike Exp $ (BRL)";
d122 1
a122 1
   FILE *fp1;		/*  conductivity file  */
d137 1
a137 1
   FILE *fp3;		/*  used for writing output to file  */
@


11.2
log
@
RCSid
@
text
@d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/irprep/secpass.c,v 11.1 1995/01/04 10:22:49 mike Rel4_4 $ (BRL)";
d1159 1
a1159 1

d1310 1
a1310 1

d1326 1
a1326 1

@


11.1
log
@Release_4.4
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/irprep/RCS/secpass.c,v 10.6 94/12/12 22:17:58 mike Exp $ (BRL)";
@


10.6
log
@Linux has PI in <math.h>
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/irprep/RCS/secpass.c,v 10.5 94/08/24 18:11:14 gdurf Exp Locker: mike $ (BRL)";
@


10.5
log
@Factored ifdefs
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/irprep/RCS/secpass.c,v 10.4 1993/02/11 10:15:43 scoates Exp gdurf $ (BRL)";
a64 1
#define PI 3.14159265358979323	/*  Pi.  */
@


10.4
log
@Add option to fire rays from 3 orthogonal directions.
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/irprep/RCS/secpass.c,v 1.8 91/07/19 02:17:20 butler Exp $ (BRL)";
d47 2
d50 1
a50 1
#ifdef SYSV
@


10.3
log
@Remove path name on include statements.
@
text
@d5 1
a5 1
 *	S.Coates - 10 March 1992
d40 2
d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/irprep/RCS/secpass.c,v 10.2 92/09/15 13:32:18 scoates Exp Locker: scoates $ (BRL)";
d167 3
d267 17
d552 2
a553 1
	/*  Set up and shoot down x-axis (positive to negative).  */
d555 1
a555 1
	(void)fprintf(stdout,"\nShooting down x-axis.\n");
d609 104
@


10.2
log
@New version of secpass.c.  Changes made to secpass.c:  region
numbering the same through out all files, correct format for
PRISM conductivity table (larger region number must be first),
choice of PRISM 2.0 or 3.0 format, and diagnostic information
no longer printed.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /m/cad/irprep/RCS/secpass.c,v 1.8 91/07/19 02:17:20 butler Exp $ (BRL)";
d53 4
a56 4
#include "/n/walrus/usr/brlcad/include/machine.h"
#include "/n/walrus/usr/brlcad/include/externs.h"
#include "/n/walrus/usr/brlcad/include/vmath.h"
#include "/n/walrus/usr/brlcad/include/raytrace.h"
@


10.1
log
@Release_4.0
@
text
@d5 1
a5 1
 *	S.Coates - 8 July 1991
d19 3
d31 9
d53 4
a56 4
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
d132 1
a132 1
   FILE *fp6;		/*  Used in writine generic file.  */
d164 1
d210 10
d271 1
d599 1
a599 1
	   	(void)fprintf(stdout,"reg#=%d, matid=%d\n",i,cond[i].mat);
d605 1
a605 1
		(void)fprintf(fp3,"reg#=%d, matid=%d\n",i,cond[i].mat);
d620 1
a620 1
		         j,cond[i].numcal[j],cond[i].shrarea[j]);
d631 1
a631 1
		         j,cond[i].numcal[j],cond[i].shrarea[j]);
d666 6
a671 3
	   if(itype == 0) (void)fprintf(fp3,"\tconductivity file created:  %s\n"
		,confile);
	   if(itype == 1) (void)fprintf(fp3,"\tgeneric file created:  %s\n"
d681 2
d771 2
d774 1
a774 1
			(i+1),(j+1),cond[i].rkavg[j],
d776 5
d783 2
d786 1
a786 1
			(i+1),(j+1),cond[i].rkrms[j],
d788 5
d795 2
d798 1
a798 1
			(i+1),(j+1),cond[i].rkmin[j],
d800 5
d807 2
d810 1
a810 1
			(i+1),(j+1),cond[i].rkmax[j],
d812 5
d826 2
d843 4
a846 2
		(void)printf("Ready to find number of adjacent areas.\n");
		(void)fflush(stdout);
d848 4
a851 2
		(void)printf("nadjreg = %d\n",nadjreg);
		(void)fflush(stdout);
d854 4
a857 2
		   (void)printf("%d, %d, %f\n",i,j,cond[i].shrarea[j]);
		   (void)fflush(stdout);
d860 4
a863 2
		(void)printf("Found number of adjacent areas.\n");
		(void)fflush(stdout);
d889 2
d919 14
a932 4
		   (void)fprintf(fp2," %.3e, %.3e,",l1,cond[i].rkavg[j]);
		   (void)fprintf(fp2," %.3e, %.3e,",l2,cond[i].rkrms[j]);
		   (void)fprintf(fp2," %.3e, %.3e,",l3,cond[i].rkmin[j]);
		   (void)fprintf(fp2," %.3e, %.3e\n",l4,cond[i].rkmax[j]);
d941 2
d965 1
d972 2
d979 8
d996 1
a996 1
			i,j);
d1003 3
@


1.8
log
@added include of strings.h on BSD machines
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/irprep/RCS/secpass.c,v 1.7 91/07/15 23:19:31 butler Exp $ (BRL)";
@


1.7
log
@misc portability changes.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/irprep/RCS/secpass.c,v 1.6 91/07/11 22:11:11 butler Exp $ (BRL)";
d34 1
d36 3
@


1.6
log
@version after Sue Coates finished with lint.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/irprep/RCS/secpass.c,v 1.5 91/07/03 01:17:40 butler Exp $ (BRL)";
d933 1
a933 1
hit(ap,PartHeadp)
d935 1
a935 1
register struct application *ap;
d962 1
a962 1
	RT_HIT_NORM(hitp,stp,&(ap->a_ray));
d1060 1
a1060 1
	RT_HIT_NORM(hitp,stp,&(ap->a_ray));
d1084 1
a1084 1
miss(ap)
d1086 1
a1086 1
register struct application *ap;
d1100 1
a1100 1
ovrlap(ap,PartHeadp,reg1,reg2)
d1104 1
a1104 1
register struct application *ap;
@


1.5
log
@removed non-portable use of <stdlib.h> in favor of "externs.h"
@
text
@d5 1
a5 1
 *	S.Coates - 13 May 1991
d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/irprep/RCS/secpass.c,v 1.4 91/07/01 23:39:32 mike Exp $ (BRL)";
d88 1
a88 1
main(argc,argv)
a124 2
   int ia;		/*  used to find material type for region i  */
   int ja;		/*  used to find material type for region j  */
d130 1
a130 1
   double areai,areaj;	/*  areas used in finding rk  */
a132 1
   int ians;		/*  used for answering questions  */
d161 2
a162 2
	fflush(stdout);
	scanf("%d",&iwrite);
d167 2
a168 2
	   fflush(stdout);
	   scanf("%s",filename);
d175 2
a176 2
	fflush(stdout);
	scanf("%s",spfile);
d191 2
a192 2
	   fflush(stdout);
	   scanf("%s",confile);
d213 2
a214 2
	fflush(stdout);
	scanf("%d",&itype);
d220 2
a221 2
	fflush(stdout);
	scanf("%s",tblfile);
d232 2
a233 2
	fflush(stdout);
	scanf("%s",fileerr);
d246 1
a246 1
	   fflush(fp3);
d253 1
a253 1
	   fflush(fp3);
d277 1
a277 1
	fflush(stdout);
d306 1
a306 1
	cond = malloc( nmged * sizeof(struct table) );
d311 10
a320 10
		cond[i].shrarea = malloc( nmged * sizeof(double) );
		cond[i].avglen = malloc( nmged * sizeof(double) );
		cond[i].rmslen = malloc( nmged * sizeof(double) );
		cond[i].minlen = malloc( nmged * sizeof(double) );
		cond[i].maxlen = malloc( nmged * sizeof(double) );
		cond[i].numcal = malloc( nmged * sizeof(double) );
		cond[i].rkavg = malloc( nmged * sizeof(double) );
		cond[i].rkrms = malloc( nmged * sizeof(double) );
		cond[i].rkmin = malloc( nmged * sizeof(double) );
		cond[i].rkmax = malloc( nmged * sizeof(double) );
d355 1
a355 1
	fscanf(fp,"%d\n",&numreg);
d363 1
a363 1
	   fflush(fp3);
d369 1
a369 1
	   fscanf(fp,"%*d%le%le%le%d\n",&cond[i].centroid[0],
d375 1
a375 1
 *	   fflush(stdout);
d380 1
a380 1
		fscanf(fp,"%*d%le\n",&cond[i].shrarea[j]);
d384 1
a384 1
 *		fflush(stdout);
d389 1
a389 1
	fclose(fp);
d396 1
a396 1
	  (void)fprintf(stdout,"file (%f) does not equal the number of\n",
d398 1
a398 1
	  (void)fprintf(stdout,"regions in the second pass file (%f).\n",
d406 1
a406 1
	    (void)fprintf(fp3,"file (%f) does not equal the number of\n",
d408 1
a408 1
	    (void)fprintf(fp3,"regions in the second pass file (%f).\n",
d461 1
a461 1
	fflush(stdout);
d471 1
a471 1
	   fflush(fp3);
d476 2
a477 2
	fflush(stdout);
	scanf("%lf",&gridspace);
d480 1
a480 1
	fflush(stdout);
d485 1
a485 1
	   fflush(fp3);
d505 1
a505 1
	fflush(stdout);
d519 1
a519 1
	rotate(t,angle,r);
d526 1
a526 1
	rotate(strtdir,angle,r);
d550 1
a550 1
	   rotate(t,angle,r);
d563 1
a563 1
		fflush(stdout);
d572 1
a572 1
	   	fflush(stdout);
d578 1
a578 1
		fflush(fp3);
d597 1
a597 1
		      fflush(stdout);
d608 1
a608 1
		      fflush(fp3);
d626 1
a626 1
	   fflush(fp3);
d631 1
a631 1
	      fflush(fp3);
d645 1
a645 1
	   fflush(fp3);
d647 1
a647 1
	   fclose(fp3);
d655 1
a655 1
	   fflush(fp1);
a678 1
		   areaj = cond[j].shrarea[i] * 1.e-6;
d757 1
a757 1
		   fflush(fp1);
d763 1
a763 1
	if(typeout == 0) fclose(fp1);
d783 1
a783 1
		(void)printf("nadjreg = %f\n",nadjreg);
d815 1
a815 1
	   fclose(fp6);
d830 1
a830 1
	fflush(fp2);
d851 1
a851 1
		   fflush(fp2);
d856 1
a856 1
	fclose(fp2);
d862 1
a862 1
	fflush(stdout);
d867 1
a867 1
	   fflush(stdout);
d884 1
a884 1
	fflush(stdout);
d891 1
a891 1
	fflush(fp4);
d903 1
a903 1
		   fflush(fp4);
d927 1
a942 1
   struct curvature cur;
d951 1
a951 1
 * fflush(stdout);
d1014 1
a1014 1
 *		fflush(stdout);
d1051 1
a1051 1
 *		fflush(stdout);
d1092 1
a1092 1
 * fflush(stdout);
@


1.4
log
@Added BRL-CAD Headers
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
a33 1
#include <stdlib.h>
@


1.3
log
@Removed excess arg to fprintf().
@
text
@d1 17
a17 3
/*  File:  secpass.c  */
/*  S.Coates - 13 May 1991  */
/*  This version ONLY shoots down x-axis.  */
d28 4
@


1.2
log
@Minor fixes
@
text
@d284 1
a284 1
	  (void)fprintf(stdout,fp3,"Number of regions in mged file:  %d\n",nmged);
d391 2
a392 2
	    (void)fprintf(stdout,fp3,"ERROR -- The number of regions in the mged\n");
	    (void)fprintf(stdout,fp3,"file (%f) does not equal the number of\n",
d394 1
a394 1
	    (void)fprintf(stdout,fp3,"regions in the second pass file (%f).\n",
d396 1
a396 1
	    (void)fprintf(stdout,fp3,"Watch for unexplained errors.\n");
@


1.1
log
@Initial revision
@
text
@a19 2
/*  The following are needed when using rt_shootray.  */

d21 1
d74 1
a74 1
char **argv[];
d84 1
a84 1
   FILE *fp,*fopen();	/*  used in opening file for second pass  */
d86 1
a86 1
   FILE *fp1,*fopen();	/*  conductivity file  */
d88 1
a88 1
   FILE *fp2,*fopen();	/*  conductivity table file  */
d99 1
a99 1
   FILE *fp6,*fopen();	/*  Used in writine generic file.  */
d101 1
a101 1
   FILE *fp3,*fopen();	/*  used for writing output to file  */
d104 1
a104 1
   FILE *fp5,*fopen();	/*  material file  */
d119 1
a119 1
   FILE *fp4,*fopen();	/*  error file  */
@
