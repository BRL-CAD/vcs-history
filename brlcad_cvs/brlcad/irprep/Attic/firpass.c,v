head	11.12;
access;
symbols
	ansi-20040405-merged:11.8.2.2
	postmerge-20040405-ansi:11.10
	premerge-20040404-ansi:11.9
	postmerge-autoconf:11.9
	autoconf-freeze:11.8.10.2
	premerge-autoconf:11.9
	ansi-20040316-freeze:11.8.2.1
	postmerge-20040315-windows:11.9
	premerge-20040315-windows:11.9
	windows-20040315-freeze:11.8.4.1
	autoconf-20031203:11.8
	autoconf-20031202:11.8
	autoconf-branch:11.8.0.10
	phong-branch:11.8.0.8
	photonmap-branch:11.8.0.6
	rel-6-1-DP:11.8
	windows-branch:11.8.0.4
	rel-6-0-2:11.6
	ansi-branch:11.8.0.2
	rel-6-0-1-branch:11.6.0.2
	hartley-6-0-post:11.7
	hartley-6-0-pre:11.6
	rel-6-0-1:11.6
	rel-6-0:11.6
	rel-5-4:11.2
	offsite-5-3-pre:11.4
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.12
date	2004.05.24.04.00.37;	author morrison;	state dead;
branches;
next	11.11;

11.11
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	11.10;

11.10
date	2004.04.05.07.47.44;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2004.02.02.17.39.06;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2002.08.20.17.07.31;	author jra;	state Exp;
branches
	11.8.2.1
	11.8.4.1
	11.8.10.1;
next	11.7;

11.7
date	2002.08.15.20.54.44;	author hartley;	state Exp;
branches;
next	11.6;

11.6
date	2001.08.09.20.09.10;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	2001.04.20.22.28.56;	author morrison;	state Exp;
branches;
next	11.4;

11.4
date	2000.09.06.20.08.49;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	2000.08.24.23.10.20;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.07.18.14.21.27;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.22.40;	author mike;	state Rel4_4;
branches;
next	10.7;

10.7
date	94.12.12.22.17.50;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.11.14.23.30.02;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.08.24.18.10.53;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	93.02.11.10.13.05;	author scoates;	state Exp;
branches;
next	10.3;

10.3
date	92.09.17.08.14.02;	author scoates;	state Exp;
branches;
next	10.2;

10.2
date	92.09.15.10.43.51;	author scoates;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.53.39;	author mike;	state Rel4_0;
branches;
next	1.6;

1.6
date	91.07.15.23.19.10;	author butler;	state Exp;
branches;
next	1.5;

1.5
date	91.07.11.22.10.46;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	91.07.02.23.39.59;	author butler;	state Exp;
branches;
next	1.3;

1.3
date	91.07.01.23.39.24;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	91.06.08.03.08.17;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	91.06.08.02.50.10;	author mike;	state Exp;
branches;
next	;

11.8.2.1
date	2002.09.19.18.01.00;	author morrison;	state Exp;
branches;
next	11.8.2.2;

11.8.2.2
date	2004.03.17.21.16.35;	author morrison;	state Exp;
branches;
next	;

11.8.4.1
date	2004.03.11.23.41.22;	author morrison;	state Exp;
branches;
next	;

11.8.10.1
date	2004.02.12.19.50.38;	author erikg;	state Exp;
branches;
next	11.8.10.2;

11.8.10.2
date	2004.03.15.14.06.13;	author erikg;	state Exp;
branches;
next	;


desc
@IRPREP, pass 1
@


11.12
log
@moved to src/irprep/
@
text
@/*
 *			F I R P A S S . C
 *
 *  Author -
 *	S.Coates - 10 February 1993
 *  
 *  Source -
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 *
 *  Notes -
 *
 *  This version ONLY shoots down the x-axis.
 *  This version rotates the starting point and directions.
 */

/*	CHANGES		*/
/*	10 December 1990 - 'Dimension' arrays using malloc.  */
/*	17 December 1990 - Incorperate subroutine rotate & radians.  */
/*	19 February 1991 - No defaults for material properties.  */
/*	 5 March 1991    - Creates PRISM, generic, or geometric file.  */
/*	13 March 1991    - Corrects problem writing out material.  */
/*	23 October 1991  - Writes out region # & name file.  */
/*	30 October 1991  - Make region numbering sceme the same for all  */
/*			   files, i.e. region numbers start at 1.  */
/*	 5 November 1991 - Print engine air area in radius field.  Give  */
/*			   user a choice of a PRISM 2.0 or 3.0 file.  */
/*	 3 December 1991 - Put in closed compartment surface area, exhaust  */
/*			   surface area, generic air 1 surface area, &  */
/*			   generic air 2 surface area.  */
/*	12 February 1992 - Add an additional line at the end of the facet  */
/*			   file to signify the end.  Correct second line  */
/*			   of facet file for PRISM 3.0 format.  */
/*	18 February 1992 - Write out total surface area when there is no  */
/*			   exterior surface area & if surface area is small  */
/*			   (< .001) set to .001.  This is done only in the  */
/*			   PRISM output file since PRISM will not accept a  */
/*			   a zero for exterior surface area.  It seems that  */
/*			   FRED does the same thing.  (If there are exterior  */
/*			   polygons FRED uses this for the area.  If there  */
/*			   are no exterior polygons FRED sums the area over  */
/*			   the interior polygons.)  */
/*	10 March 1992    - Print out PRISM release being used.  */
/*	10 February 1992 - Fire rays from 3 orthogonal directions, if  */
/*			   desired.  */

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/irprep/firpass.c,v 11.11 2004/05/10 15:30:43 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
# include <string.h>
#else
# include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"

#define BLANK " "	/*  Define a blank.  */
#define ADJTOL 1.e-1	/*  Tolerance for adjacent regions.  */
#define COSTOL 1.e-20	/*  Tolerance for costheta & costheta1,  */
			/*  to avoid dividing by zero.  */
#define VOLVAR 0.1	/*  Variation in volume & surface area  */
			/*  that is allowed, before flag is set.  */
#define ZEROTOL 1.e-20	/*  Tolerance for dividing by zero.  */
#define NORMTOL 1.e-2	/*  Tolerance for finding cummulative normals.  */
#define ALPHA 25.	/*  Rotation about z-axis.  */
#define BETA 50.	/*  Rotation about y-axis.  */
#define GAMMA 35.	/*  Rotation about x-axis.  */

struct application ap;	/*  Structure passed between functions.  */
extern int hit(register struct application *ap_p, struct partition *PartHeadp);	/*  User supplied hit function.  */
extern int miss(register struct application *ap_p);	/*  User supplied miss function.  */
extern int ovrlap(register struct application *ap_p, struct partition *PartHeadp, struct region *reg1, struct region *reg2);	/*  User supplied overlap function.  */
extern void rotate(double *p, double *a, double *np);	/*  Subroutine to rotate a point.  */
extern double radians(double a);/*  Subroutines to find angle in radians.  */

/*  Define structure.  */
struct table
{
	const char *regname;		/*  region name  */
	short mat;		/*  material code  */
	double cumnorm[3];	/*  cummulative normal vector sum  */
				/*  for the exterior free surfaces  */
	double cumvol[3];	/*  cummulative volume sums for each  */
				/*  direction fired  */
	double centroid[3];	/*  centroid calculation  */
	double cumfs[7][3];	/*  cummulative surface area for */
				/*  each air type, 0-exterior air,  */
				/*  1-crew compartment air, 2-engine  */
				/*  compartment air, 3-closed compartment  */
				/*  air, 4-exhaust air, 5-generic air 1,  */
				/*  6-generic air 2.  Air MUST be designated  */
				/*  in the following way in the mged file.  */
				/*  1 => exterior air  */
				/*  2 => crew compartment air  */
				/*  5 => engine compartment air  */
				/*  6 => closed compartment air  */
				/*  7 => exhaust air  */
				/*  8 => generic air 1  */
				/*  9 => generic air 2  */
	int *adjreg;		/*  adjacent region, 0=>no touch,  */
				/*  1=>touch  */
	double *ssurarea[3];	/*  cummulative sum of shared surface  */
				/*  area of adjacent regions  */
	double surarea[3];	/*  surface area of that region, one  */
				/*  for each direction rays fired  */
};
struct table *region;		/*  name of table structure  */
int iprev,icur;			/*  previous & current region hit  */
double area;			/*  area of "ray"  */
double leavept[3];		/*  leave point for previous region hit  */
double lnormal[3];		/*  normal for leaving ray  */
int whichview;			/*  flag for direction rays are fired  */
				/*  (0=>x, 1=>y, 2=>z)  */

struct structovr		/*  structure for recording overlaps  */
{
	int *ovrreg;		/*  regions that overlap  */
	double *ovrdep;		/*  maximum depth of overlap  */
};
struct structovr *overlaps;	/*  name of structovr structure  */

int main(int argc, char **argv)
{
	int i,j,k,ii;	/*  variables used in loops  */
	int ia;		/*  variable used to set short to int  */

	int index;	/*  Index for rt_dirbuild and  */
			/*  rt_gettree.  */
	static struct rt_i *rtip;	/*  rtip is a pointer to  */
					/*  a structure of type  */
					/*  rt_i, defined in headers  */
	char idbuf[132];	/*  first ID record info, used  */
				/*  in rt_dirbuild  */
	double gridspace;	/*  variables to determine where ray starts  */
	int flag;		/*  flag for checking variance of volume &  */
				/*  surface area  */
	int num;		/*  number of regions  */
	double total;		/*  used in computing different values  */
	FILE *fp=NULL;		/*  used for writing output to file  */
	char filename[16];	/*  file name for writing output to  */
	int iwrite;		/*  0=>write to standard out, 1=>write  */
				/*  to file  */
	int typeout;		/*  type of file written, 0=>PRISM, 1=>  */
				/*  generic, 2=>geometric, 3=>non-readable  */
				/*  geometric file  */
	int typeouta;		/*  geometric type file  */
	double denom;		/*  used when computing normal  */
	FILE *fp3;		/*  used for error file  */
	char fileerr[16];	/*  used for error file  */
	FILE *fp4;		/*  used for reading material id file  */
	char fileden[16];	/*  used for reading material id file  */
	FILE *fp5;		/*  used for creating generic file  */
	char filegen[16];	/*  used for creating generic file  */
	FILE *fp6;		/*  used for creating gemetric file  */
	char filegeo[16];	/*  used for creating gemetric file  */
	FILE *fp7;		/*  Used for creating region # & name file.  */
	char filernn[16];	/*  Used for creating region # & name file.  */
	int numadjreg;		/*  used for finding the number of  */
				/*  adj regions  */
	double diagonal;	/*  Length of diagonal of bounding rpp.  */
	double xmin,xmax;	/*  Minimum & maximum x.  */
	double ymin,ymax;	/*  Minimum & maximum y.  */
	double zmin,zmax;	/*  Minimum & maximum z.  */

/*************************************************************************/

	/*  Variables used in facet grouping file.  */
	FILE *fp1;		/*  facet grouping file  */
	char facfile[16];	/*  facet grouping file name  */
	int facnum=0;		/*  facet number  */
	char facname[25];	/*  facet name  */
	int c;			/*  used in finding facet name from  */
				/*  region name  */
	int icnt;		/*  used in finding facet name  */
	int factype;		/*  type of facet  */
	double facarea;		/*  area of facet (sq meters)  */
	double facmass;		/*  mass of facet (kg)  */
	double facspheat;	/*  specific heat of facet (J/kg deg C)  */
	double face1;		/*  emissivity of facet wrt  */
				/*  environment (>0)  */
	double face2;		/*  emissivity of facet wrt other  */
				/*  facets (>0)  */
	double facabs;		/*  absorptivity of facet  */
	double facnorm[3];	/*  surface normal of facet  */
	double faccv;		/*  convection coefficient  */
	int fack;		/*  facet number of facet seen by back  */
				/*  surface of current facet  */
	int facl;		/*  facedt number of facet seen by front  */
				/*  surface of current facet  */
	double facshape;	/*  shape factors for engine & track  */
				/*  (between 0 & 1)  */
	double facradius;	/*  hub radius (m)  */
	double facfric;		/*  bearing friction constant for wheels  */
				/*  (J)  */
	struct table1		/*  Used to read in material property file.  */
	{
	  double d;		/*  Density.  */
	  double sh;		/*  Specific heat.  */
	  double a;		/*  Absorptivity.  */
	  double e1;		/*  Emissivity.  */
	  double e2;		/*  Emissivity.  */
	  double tc;		/*  Thermal conductivity.  */
	  char m[25];		/*  Material.  */
	};
	struct table1 matprop[41];
	char line[151];		/*  used for reading files, one line at  */
				/*  a time  */

	/*  Variables used in second pass file.  */
	FILE *fp2;		/*  second pass file  */
	char spfile[16];	/*  second pass file  */
	double spsarea;		/*  average of shared surface area for  */
				/*  second pass  */

/************************************************************************/
	double angle[3];	/*  Angles of rotation in radians.  */
				/*  angle[0] is rotation about x-axis,  */
				/*  angle[1] is rotation about y-axis,  */
				/*  angle[2] is rotation about z-axis,  */
	double strtpt[3];	/*  Starting point of fired ray.  */
	double strtdir[3];	/*  Starting direction of fired ray.  */
	double r[3],t[3];	/*  Used in computing rotations.  */
	double center[3];	/*  Center of bounding rpp.  */
	int numext;		/*  Number of exterior surfaces.  */
	int numint;		/*  Number of interior surfaces.  */
	int numsol;		/*  Number of solar loaded surfaces.  */
	int prmrel;		/*  PRISM release number 2=>2.0 & 3=>3.0.  */
	int ifire;		/*  Number of sets of rays to be fired,  */
				/*  0=>fire from 3 orthogonal postions,  */
				/*  1=>fire from 1 postion.  */
	double diff;		/*  Difference, used in finding variance.  */

   /*  Check to see if arguments implimented correctly.  */
   if(argv[1]==NULL || argv[2]==NULL)
   {
	(void)fprintf(stderr,"\nusage:  firpass file.g objects\n\n");
   }
	
   else
   {


	/*  Ask if output goes to standard out or a file.  */
	(void)printf("Write output to standard out (0) or a file (1) or ");
	(void)printf("not at all (2)?  ");
	(void)fflush(stdout);
	(void)scanf("%d",&iwrite);
	if((iwrite != 0) && (iwrite != 1)) iwrite=2;
	if(iwrite == 1)
	{
	  (void)printf("Enter name of file output is to be written ");
	  (void)printf("to (15 char max).  ");
	  (void)fflush(stdout);
	  (void)scanf("%s",filename);
	  fp=fopen(filename,"w");
	}

	/*  Get error file name.  */
	(void)printf("Enter name of error file to be created ");
	(void)printf("(15 char max).  ");
	(void)fflush(stdout);
	(void)scanf("%s",fileerr);

	/*  Get second pass file name.  */
	(void)printf("Enter name of second pass file to be ");
	(void)printf("created (15 char max).  ");
	(void)fflush(stdout);
	(void)scanf("%s",spfile);

	/*  Get region # & name file (for use w/shapefact).  */
	(void)printf("Enter name of region # & name file to be  ");
	(void)printf("created (15 char max).  ");
	(void)fflush(stdout);
	(void)scanf("%s",filernn);

	/*  Get name of material id file.  */
	(void)printf("Enter name of material id file to be read ");
	(void)printf("(15 char max).  ");
	(void)fflush(stdout);
	(void)scanf("%s",fileden);

	/*  What types of files are to be written?  */
	(void)printf("Enter type of file to be written.\n");
	(void)printf("\t0 - PRISM file\n");
	(void)printf("\t1 - Generic file\n");
	(void)printf("\t2 - Geometric properties file\n");
	(void)fflush(stdout);
	(void)scanf("%d",&typeout);

	/*  Get facet file name.  */
	if( typeout == 0 )
	{
	   (void)printf("Enter name of facet file to be created. ");
	   (void)printf("(15 char max)  ");
	   (void)fflush(stdout);
	   (void)scanf("%s",facfile);

	   /*  Find which PRISM release is being used.  The facet number  */
	   /*  in release 3.0 is written with an I6 & in release 2.0 it  */
	   /*  is written with I3.  */
	   prmrel = 2;
	   (void)printf("Which release of PRISM is being used, 2.0 (2) ");
	   (void)printf("or 3.0 (3)?  ");
	   (void)fflush(stdout);
	   (void)scanf("%d",&prmrel);
	   if(prmrel != 3) prmrel = 2;
	}

	/*  Get generic file name.  */
	if( typeout == 1 )
	{
	   (void)printf("Enter name of generic file to be created. ");
	   (void)printf("(15 char max)  ");
	   (void)fflush(stdout);
	   (void)scanf("%s",filegen);
	}
	
	/*  Get geometric file name.  */
	if( typeout == 2 )
	{
	   (void)printf("Do you want a readable (0) or non-readable (1) ");
	   (void)printf("geometric file?  ");
	   (void)fflush(stdout);
	   (void)scanf("%d",&typeouta);
	   typeout += typeouta;
	   (void)printf("Enter name of geometric properties file to be ");
	   (void)printf("created (15 char max).  ");
	   (void)fflush(stdout);
	   (void)scanf("%s",filegeo);
	}

/*
 *	(void)printf("typeout = %d\n",typeout);
 *	(void)fflush(stdout);
 */

	/*  Determine whether to fire one set of rays or to fire  */
	/*  three sets of orthogonal rays.  */
	(void)printf("Should there be 3 sets of orthogonal rays fired ");
	(void)printf("(0) or 1 set\n");
	(void)printf("of rays fired (1)?\n\t");
	(void)fflush(stdout);
	(void)scanf("%d",&ifire);
	if(ifire != 0) ifire = 1;
	if(ifire == 0)
	{
	   (void)printf("3 sets of orthogonal rays will be fired.\n");
	}
	if(ifire == 1)
	{
	   (void)printf("1 set of rays will be fired.\n");
	}
	(void)fflush(stdout);

	/*  Open & read material id file.  */
	fp4=fopen(fileden,"r");
/*
 *	(void)printf("Materail id file open for reading.\n");
 *	(void)fflush(stdout);
 */
	/*  Assumption is made that material ids run from 0 to 40  */
	/*  and ALL numbers 0-40 have a density.  */

	for(i=0; i<41; i++)
	{
		(void)fgets(line,150,fp4);
		(void)sscanf(line,"%*d%lf%lf%lf%lf%lf%25c",
		   &matprop[i].d,&matprop[i].sh,&matprop[i].a,
		   &matprop[i].e1,&matprop[i].tc,matprop[i].m);
		matprop[i].e2 = matprop[i].e1;
		for(j=0; j<25; j++)
		{
		   if(matprop[i].m[j] == '\n')
		   {
			for(ii=j; ii<25; ii++)
			{
			   matprop[i].m[ii] = ' ';
			}
		   }
		}
		/*  Substitute blanks for tabs in material name.  */
		for(j=0; j<25; j++)
		{
			if(matprop[i].m[j] == '\t')
			   matprop[i].m[j] = ' ';
		}

/*
 *		(void)printf("%d, %f, %f, %f, %f, %f\n",i,
 *		   matprop[i].d,matprop[i].sh,matprop[i].a,
 *		   matprop[i].e1,matprop[i].e2);
 *		(void)fflush(stdout);
 */
 
	}
	(void)fclose(fp4);

	/*  Print out the name of the file being used.  */
	(void)printf("File Used:  %s\n",argv[1]);
	(void)fflush(stdout);
	if(iwrite == 1)
	{
	  (void)fprintf(fp,"File Used:  %s,  ",argv[1]);
	  (void)fflush(fp);
	}

	/*  Print out name of material id file being used.  */
	(void)printf("Material ID File:  %s\n",fileden);
	(void)fflush(stdout);
	if(iwrite == 1)
	{
		(void)fprintf(fp,"Material ID File:  %s\n",fileden);
		(void)fflush(fp);
	}

	/*  Build the directory.  */
	index = 1;	/*  Setup index for rt_dirbuild  */
	rtip=rt_dirbuild(argv[index],idbuf,sizeof(idbuf));
	(void)printf("Database Title:  %s\n",idbuf);
	(void)fflush(stdout);
	if(iwrite == 1)
	{
	  (void)fprintf(fp,"Database Title:  %s\n",idbuf);
	  (void)fflush(fp);
	}

	/*  Set useair to 1, to show hits of air.  */
	rtip->useair = 1;

	/*  Load desired objects.  */
	index = 2;	/*  Set index for rt_gettree.  */
	while(argv[index] != NULL)
	{
		rt_gettree(rtip,argv[index]);
		index=index+1;
	}

	/*  Find total number of regions.  */
	num = (int)rtip->nregions;
/*
 *	(void)printf("\n Number of Regions? = %d\n",num);
 *	(void)fflush(stdout);
 */

	/*  The number of regions (num) is now known.  It  */
	/*  is time to use the malloc command to 'dimension'  */
	/*  the appropriate arrays and structures.  */

	(void)printf("Mallocing arrays.\n");
	(void)fflush(stdout);

	region = (struct table *)malloc(num * sizeof (*region) );
	overlaps = (struct structovr *)malloc(num * sizeof (*overlaps) );

	for(i=0; i<num; i++)
	{
		region[i].adjreg = (int *)malloc(num * sizeof (int) );
		region[i].ssurarea[0] = (double *)malloc(num * sizeof (double) );
		region[i].ssurarea[1] = (double *)malloc(num * sizeof (double) );
		region[i].ssurarea[2] = (double *)malloc(num * sizeof (double) );

		overlaps[i].ovrreg = (int *)malloc(num * sizeof (int) );
		overlaps[i].ovrdep = (double *)malloc(num * sizeof (double) );
	}

	/*  Now that the arrays are 'dimensioned' zero ALL variables.  */

	(void)printf("Zeroing variables.\n");
	(void)fflush(stdout);

	for(i=0; i<num; i++)
	{
		region[i].regname="\0";
		region[i].cumnorm[0]=0.;
		region[i].cumnorm[1]=0.;
		region[i].cumnorm[2]=0.;
		region[i].cumvol[0]=0.;
		region[i].cumvol[1]=0.;
		region[i].cumvol[2]=0.;
		region[i].centroid[0]=0.;
		region[i].centroid[1]=0.;
		region[i].centroid[2]=0.;
		for(k=0; k<7; k++)
		{
		   region[i].cumfs[k][0] = 0.;
		   region[i].cumfs[k][1] = 0.;
		   region[i].cumfs[k][2] = 0.;
		}
		region[i].surarea[0]=0.;
		region[i].surarea[1]=0.;
		region[i].surarea[2]=0.;
		for(j=0; j<num; j++)
		{
			region[i].adjreg[j]=0;
			region[i].ssurarea[0][j]=0.;
			region[i].ssurarea[1][j]=0.;
			region[i].ssurarea[2][j]=0.;
		}
	}

	/*  Zero overlaps.  */
	for(i=0; i<num; i++)
	{
	   for(j=0; j<num; j++)
	   {
		overlaps[i].ovrreg[j] = 0;
		overlaps[i].ovrdep[j] = 0.;
	   }
	}

	/*  Get database ready by starting preparation.  */
	rt_prep(rtip);

	/*  Find center of bounding rpp.  */
	center[X] = rtip->mdl_min[X] + (rtip->mdl_max[X]
		- rtip->mdl_min[X]) / 2.;
	center[Y] = rtip->mdl_min[Y] + (rtip->mdl_max[Y]
		- rtip->mdl_min[Y]) / 2.;
	center[Z] = rtip->mdl_min[Z] + (rtip->mdl_max[Z]
		- rtip->mdl_min[Z]) / 2.;

	/*  Find length of diagonal of bounding rpp.  */
	diagonal = (rtip->mdl_max[X] - rtip->mdl_min[X])
			* (rtip->mdl_max[X] - rtip->mdl_min[X])
	         + (rtip->mdl_max[Y] - rtip->mdl_min[Y])
			* (rtip->mdl_max[Y] - rtip->mdl_min[Y])
	         + (rtip->mdl_max[Z] - rtip->mdl_min[Z])
			* (rtip->mdl_max[Z] - rtip->mdl_min[Z]);
	diagonal = sqrt(diagonal) / 2. + 0.5;

	/*  Find minimum and maximums.  */
	xmin = center[X] - diagonal;
	xmax = center[X] + diagonal;
	ymin = center[Y] - diagonal;
	ymax = center[Y] + diagonal;
	zmin = center[Z] - diagonal;
	zmax = center[Z] + diagonal;

	/*  Print center of bounding rpp, diagonal, maximum, &  */
	/*  minimum.  */
	(void)printf("Center of bounding rpp ( %f, %f, %f )\n",
		center[X],center[Y],center[Z]);
	(void)printf("Length of diagonal of bounding rpp:  %f\n",
		diagonal);
	(void)printf("Minimums & maximums\n");
	(void)printf("  x:  %f - %f\n",xmin,xmax);
	(void)printf("  y:  %f - %f\n",ymin,ymax);
	(void)printf("  z:  %f - %f\n",zmin,zmax);
	(void)fflush(stdout);

	/*  Write model minimum & maximum.  */
	(void)printf("Model minimum & maximum.\n");
	(void)fflush(stdout);
	(void)printf("\tX:  %f to %f\n\tY:  %f to %f\n\tZ:  %f to %f\n\n",
		rtip->mdl_min[X],rtip->mdl_max[X],
		rtip->mdl_min[Y],rtip->mdl_max[Y],
		rtip->mdl_min[Z],rtip->mdl_max[Z]);
	(void)fflush(stdout);
	if(iwrite == 1)
	{
	  (void)fprintf(fp,"Model minimum & maximum.\n");
	  (void)fprintf(fp,"\tX:  %f to %f\n\tY:  %f to %f\n\tZ:  %f to %f\n",
		rtip->mdl_min[X],rtip->mdl_max[X],
		rtip->mdl_min[Y],rtip->mdl_max[Y],
		rtip->mdl_min[Z],rtip->mdl_max[Z]);
	  (void)fflush(fp);
	}

	/*  User enters grid spacing.  All units are in mm.  */
	(void)printf("Enter grid spacing (mm) for fired rays.\n");
	(void)fflush(stdout);
	(void)scanf("%lf",&gridspace);

	if(iwrite == 0)
	{
	  (void)printf("grid spacing:  %f\n",gridspace);
	  (void)fflush(stdout);
	}
	else if(iwrite == 1)
	{
	  (void)fprintf(fp,"grid spacing:  %f,  ",gridspace);
	  (void)fflush(fp);
	}

	/*  Find area of "ray".  */
	area = gridspace * gridspace;
	if(iwrite == 0)
	{
	  (void)printf("area=%f\n",area);
	  (void)fflush(stdout);
	}
	if(iwrite == 1)
	{
	  (void)fprintf(fp,"area=%f\n",area);
	  (void)fflush(fp);
	}

	/*  Set up other parameters for rt_shootray.  */
	ap.a_hit=hit;	/*  User supplied hit function.  */
	ap.a_miss=miss;	/*  User supplied miss function.  */
	ap.a_overlap=ovrlap;	/*  User supplied overlap function.  */

	/*  Set other parameters that need to be  */
	/*  set for rt_shootray.  */
	ap.a_rt_i=rtip;	/*  Pointer from rt_dirbuild.  */
	ap.a_onehit=0;	/*  Hit flag:  return all hits.  */
	ap.a_level=0;	/*  Recursion level for diagnostics  */
	ap.a_resource=0;	/*  address of resource structure:  */
				/*  NULL  */

	/*  Set up for 1st set of fired rays, positive to negative  */
	/*  (shooting down the x-axis).  */

	(void)printf("\nSHOOTING DOWN THE 1st AXIS\n");
	(void)fflush(stdout);

	whichview=0;

 	strtpt[X] = xmax;
	strtpt[Y] = ymin + gridspace / 2.;
	strtpt[Z] = zmin + gridspace / 2.;
	strtdir[X] = (-1.);
	strtdir[Y] = 0.;
	strtdir[Z] = 0.;

	/*  Put angle into radians.  */
	angle[X] = radians((double)GAMMA);
	angle[Y] = radians((double)BETA);
	angle[Z] = radians((double)ALPHA);

	/*  Rotate starting point.  (new pt = C + R[P - C])  */
	t[X] = strtpt[X] - center[X];
	t[Y] = strtpt[Y] - center[Y];
	t[Z] = strtpt[Z] - center[Z];

	(void)rotate(t,angle,r);

	ap.a_ray.r_pt[X] = center[X] + r[X];
	ap.a_ray.r_pt[Y] = center[Y] + r[Y];
	ap.a_ray.r_pt[Z] = center[Z] + r[Z];

	/*  Rotate firing direction.  (new dir = R[D])  */

	(void)rotate(strtdir,angle,r);

	ap.a_ray.r_dir[X] = r[X];
	ap.a_ray.r_dir[Y] = r[Y];
	ap.a_ray.r_dir[Z] = r[Z];

	while( strtpt[Z] <= zmax )
	{

		/*  Set to show no previous shots.  */
		iprev=(-99);
		r[X]=xmax - center[X] + 5.;
		r[Y]=ymax - center[Y] + 5.;
		r[Z]=zmax - center[Z] + 5.;


		(void)rotate(r,angle,t);

		leavept[X] = center[X] + t[X];
		leavept[Y] = center[Y] + t[Y];
		leavept[Z] = center[Z] + t[Z];

		/*  Print starting point & direction.  */
/*
 *		(void)printf("Starting point & direction.\n");
 *		(void)printf("  %f, %f, %f\n  %f, %f, %f\n",
 *		   ap.a_ray.r_pt[X],ap.a_ray.r_pt[Y],ap.a_ray.r_pt[Z],
 *		   ap.a_ray.r_dir[X],ap.a_ray.r_dir[Y],ap.a_ray.r_dir[Z]);
 *		(void)fflush(stdout);
 */

		lnormal[X]=0.;
		lnormal[Y]=0.;
		lnormal[Z]=0.;

		/*  Call rt_shootray.  */
		(void)rt_shootray( &ap );

		strtpt[Y] += gridspace;
		if( strtpt[Y] > ymax )
		{
			strtpt[Y] = ymin + gridspace / 2.;
			strtpt[Z] += gridspace;

		}

		t[X] = strtpt[X] - center[X];
		t[Y] = strtpt[Y] - center[Y];
		t[Z] = strtpt[Z] - center[Z];


		(void)rotate(t,angle,r);

		ap.a_ray.r_pt[X] = center[X] + r[X];
		ap.a_ray.r_pt[Y] = center[Y] + r[Y];
		ap.a_ray.r_pt[Z] = center[Z] + r[Z];
	}

	/*  Set up to fire 2nd & 3rd set of rays if appropriate.  */
	if(ifire == 0)
	{						/*  START # 1000  */
	   /*  Set up & fire 2nd set of arrays.  */
	   (void)printf("\nSHOOTING DOWN THE 2nd AXIS\n");
	   (void)fflush(stdout);

	   whichview = 1;

	   strtpt[X] = xmin + gridspace / 2.;
	   strtpt[Y] = ymax;
	   strtpt[Z] = xmin + gridspace / 2.;
	   strtdir[X] = 0.;
	   strtdir[Y] = (-1.);
	   strtdir[Z] = 0.;

	   /*  Angle already in radians.  */

	   /*  Rotate starting point (new pt = C + R[P - C]).  */
	   t[X] = strtpt[X] - center[X];
	   t[Y] = strtpt[Y] - center[Y];
	   t[Z] = strtpt[Z] - center[Z];

	   (void)rotate(t,angle,r);

	   ap.a_ray.r_pt[X] = center[X] + r[X];
	   ap.a_ray.r_pt[Y] = center[Y] + r[Y];
	   ap.a_ray.r_pt[Z] = center[Z] + r[Z];

	   /*  Rotate firing direction (new dir = R[D]).  */
	   (void)rotate(strtdir,angle,r);
	   ap.a_ray.r_dir[X] = r[X];
	   ap.a_ray.r_dir[Y] = r[Y];
	   ap.a_ray.r_dir[Z] = r[Z];

	   while(strtpt[Z] <= zmax)
	   {
		/*  Set to show no previous shots.  */
		iprev = (-99);
		r[X] = xmax - center[X] + 5.;
		r[Y] = ymax - center[Y] + 5.;
		r[Z] = zmax - center[Z] + 5.;

		(void)rotate(r,angle,t);

		leavept[X] = center[X] + t[X];
		leavept[Y] = center[Y] + t[Y];
		leavept[Z] = center[Z] + t[Z];

		lnormal[X] = 0.;
		lnormal[Y] = 0.;
		lnormal[Z] = 0.;

		/*  Call rt_shootray.  */
		(void)rt_shootray(&ap);

		strtpt[X] += gridspace;

		if(strtpt[X] > xmax)
		{
		   strtpt[X] = xmin + gridspace / 2.;
		   strtpt[Z] += gridspace;
		}

		t[X] = strtpt[X] - center[X];
		t[Y] = strtpt[Y] - center[Y];
		t[Z] = strtpt[Z] - center[Z];

		(void)rotate(t,angle,r);

		ap.a_ray.r_pt[X] = center[X] + r[X];
		ap.a_ray.r_pt[Y] = center[Y] + r[Y];
		ap.a_ray.r_pt[Z] = center[Z] + r[Z];
	   }

	   /*  Set up & fire 3rd set of rays.  */
	   (void)printf("\nSHOOTING DOWN THE 3rd AXIS.\n");
	   (void)fflush(stdout);

	   whichview = 2;

	   strtpt[X] = xmin + gridspace / 2.;
	   strtpt[Y] = ymin + gridspace / 2.;
	   strtpt[Z] = zmax;
	   strtdir[X] = 0.;
	   strtdir[Y] = 0.;
	   strtdir[Z] = (-1.);

	   /*  Angle already in radians.  */

	   /*  Rotate starting point (new pt = C + R[P - C]).  */
	   t[X] = strtpt[X] - center[X];
	   t[Y] = strtpt[Y] - center[Y];
	   t[Z] = strtpt[Z] - center[Z];

	   (void)rotate(t,angle,r);

	   ap.a_ray.r_pt[X] = center[X] + r[X];
	   ap.a_ray.r_pt[Y] = center[Y] + r[Y];
	   ap.a_ray.r_pt[Z] = center[Z] + r[Z];

	   /*  Rotate firing direction (new dir = R[D]).  */
	   (void)rotate(strtdir,angle,r);

	   ap.a_ray.r_dir[X] = r[X];
	   ap.a_ray.r_dir[Y] = r[Y];
	   ap.a_ray.r_dir[Z] = r[Z];

	   while(strtpt[Y] <= ymax)
	   {
		/*  Set to show no previous shots.  */
		iprev = (-99);
		r[X] = xmax - center[X] + 5.;
		r[Y] = xmax - center[Y] + 5.;
		r[Z] = xmax - center[Z] + 5.;

		(void)rotate(r,angle,t);

		leavept[X] = center[X] + t[X];
		leavept[Y] = center[Y] + t[Y];
		leavept[Z] = center[Z] + t[Z];

		lnormal[X] = 0.;
		lnormal[Y] = 0.;
		lnormal[Z] = 0.;

		/*  Call rt_shootray.  */
		(void)rt_shootray(&ap);

		strtpt[X] += gridspace;

		if(strtpt[X] > xmax)
		{
		   strtpt[X] = xmin + gridspace / 2.;
		   strtpt[Y] += gridspace;
		}

		t[X] = strtpt[X] - center[X];
		t[Y] = strtpt[Y] - center[Y];
		t[Z] = strtpt[Z] - center[Z];

		(void)rotate(t,angle,r);

		ap.a_ray.r_pt[X] = center[X] + r[X];
		ap.a_ray.r_pt[Y] = center[Y] + r[Y];
		ap.a_ray.r_pt[Z] = center[Z] + r[Z];
	   }

	}						/*  END # 1000  */

	if(iwrite == 0)
	{
	  (void)printf("\nNumber of regions:  %d\n\n",num);
	  (void)fflush(stdout);
	}
	if(iwrite == 1)
	{
	  (void)fprintf(fp,"Number of regions:  %d\n",num);
	  (void)fflush(fp);
	}

	/*  Compute the volume & surface area of each region.  */
	i=0;
	while( i < num )
	{
		/*  Finish computing centroids.  */
/*
 *		(void)printf("\tcentroid before division:  %f, %f, %f\n",
 *		   region[i].centroid[0],region[i].centroid[1],
 *		   region[i].centroid[2]);
 *		(void)printf("\tvolumes:  %f, %f, %f\n",region[i].cumvol[0],
 *		   region[i].cumvol[1],region[i].cumvol[2]);
 *		(void)fflush(stdout);
 */
		total = region[i].cumvol[0] + region[i].cumvol[1] +
		   region[i].cumvol[2];

/*
 *		(void)printf("\tcummulative volume:  %f",total);
 *		(void)fflush(stdout);
 */
		if( (total < -ZEROTOL) || (ZEROTOL < total) )
		{
		   region[i].centroid[X] = region[i].centroid[X]/total;
		   region[i].centroid[Y] = region[i].centroid[Y]/total;
		   region[i].centroid[Z] = region[i].centroid[Z]/total;
		}
/*
 *		(void)printf("volumes:  %f, %f, %f\n",region[i].cumvol[0],
 *		   region[i].cumvol[1],region[i].cumvol[2]);
 *		(void)printf("areas:  %f, %f, %f\n",region[i].surarea[0],
 *		   region[i].surarea[1],region[i].surarea[2]);
 */

		/*  Check for variance of volume & find volume.  */
		flag=0;
		if(ifire == 0)
		{					/*  START # 1040  */
		   if( (region[i].cumvol[0] != 0.) &&
		     (region[i].cumvol[1] != 0.) &&
		     (region[i].cumvol[2] != 0.) )
		   {					/*  START # 1045  */
		   diff = region[i].cumvol[0] - region[i].cumvol[1];
		   if(diff < 0.) diff = (-diff);
		   if( (diff / region[i].cumvol[0]) > VOLVAR) flag = 1;
		   if( (diff / region[i].cumvol[1]) > VOLVAR) flag = 1;

		   diff = region[i].cumvol[0] - region[i].cumvol[2];
		   if(diff < 0.) diff = (-diff);
		   if( (diff / region[i].cumvol[0]) > VOLVAR) flag = 1;
		   if( (diff / region[i].cumvol[2]) > VOLVAR) flag = 1;

		   diff = region[i].cumvol[1] - region[i].cumvol[2];
		   if(diff < 0.) diff = (-diff);
		   if( (diff / region[i].cumvol[1]) > VOLVAR) flag = 1;
		   if( (diff / region[i].cumvol[2]) > VOLVAR) flag = 1;
		   }					/*  END # 1045  */

		   else if( (region[i].cumvol[0] == 0.) ||
		            (region[i].cumvol[1] == 0.) ||
		            (region[i].cumvol[2] == 0.) )
		   {
			flag = 2;
		   }

		   /*  Put in check.  */
/*
 *		   if(flag == 1)
 *		   {
 *			(void)printf("** Vol Var exceeded for region %d:  ",
 *				i);
 *			(void)printf("%f, %f, %f **\n",region[i].cumvol[0],
 *				region[i].cumvol[1],region[i].cumvol[2]);
 *			(void)fflush(stdout);
 *		   }
 *		   else
 *		   {
 *			(void)printf("** Vol Var NOT exceeded for region %d:  ",
 *				i);
 *			(void)printf("%f, %f, %f **\n",region[i].cumvol[0],
 *				region[i].cumvol[1],region[i].cumvol[2]);
 *			(void)fflush(stdout);
 *		   }
 */
		}					/*  END # 1040  */

		if(ifire == 0)
		{
		   region[i].cumvol[0] = region[i].cumvol[0]
		   	+ region[i].cumvol[1] + region[i].cumvol[2];
		   region[i].cumvol[0] /= 3.;
		}
		region[i].cumvol[1]=(double)flag;

		/*  Check for variance of surface area & find  */
		/*  surface area.  */
		flag=0;
		if(ifire == 0)
		{					/*  START # 1050  */
		   if( (region[i].surarea[0] != 0.) &&
		       (region[i].surarea[1] != 0.) &&
		       (region[i].surarea[2] != 0.) )
		   {					/*  START # 1055  */
		   diff = region[i].surarea[0] - region[i].surarea[1];
		   if(diff < 0.) diff = (-diff);
		   if( (diff / region[i].surarea[0]) > VOLVAR) flag = 1;
		   if( (diff / region[i].surarea[1]) > VOLVAR) flag = 1;

		   diff = region[i].surarea[0] - region[i].surarea[2];
		   if(diff < 0.) diff = (-diff);
		   if( (diff / region[i].surarea[0]) > VOLVAR) flag = 1;
		   if( (diff / region[i].surarea[2]) > VOLVAR) flag = 1;

		   diff = region[i].surarea[1] - region[i].surarea[2];
		   if(diff < 0.) diff = (-diff);
		   if( (diff / region[i].surarea[1]) > VOLVAR) flag = 1;
		   if( (diff / region[i].surarea[2]) > VOLVAR) flag = 1;
		   }					/*  END # 1055  */

		   else if( (region[i].surarea[0] == 0.) ||
		            (region[i].surarea[1] == 0.) ||
		            (region[i].surarea[2] == 0.) )
		   {
			flag = 2;
		   }

		   /*  Put in check.  */
/*
 *		   if(flag == 1)
 *		   {
 *			(void)printf("** Sur Area Var exceeded for ");
 *			(void)printf("region %d:  ",i);
 *			(void)printf("%f, %f, %f **\n",region[i].surarea[0],
 *				region[i].surarea[1],region[i].surarea[2]);
 *			(void)fflush(stdout);
 *		   }
 *		   else
 *		   {
 *			(void)printf("** Sur Area Var NOT exceeded for ");
 *			(void)printf("region %d:  ",i);
 *			(void)printf("%f, %f, %f **\n",region[i].surarea[0],
 *				region[i].surarea[1],region[i].surarea[2]);
 *			(void)fflush(stdout);
 *		   }
 */
		}					/*  END # 1050  */
		if(ifire == 0)
		{
		   region[i].surarea[0] = region[i].surarea[0]
		   	+ region[i].surarea[1] + region[i].surarea[2];
		   region[i].surarea[0] /= 3.;
		}
		region[i].surarea[1]=(double)flag;

		/*  Check for variance of shared surface area &  */
		/*  find shared surface area.  */
		for(j=0; j<num; j++)
		{
		   if(region[i].adjreg[j] == 1)
		   {

/*
 *			(void)printf("reg %d, adj reg %d\n",i,j);
 *			(void)printf("  shared area:  %f, %f, %f\n",
 *			   region[i].ssurarea[0][j],
 *			   region[i].ssurarea[1][j],
 *			   region[i].ssurarea[2][j]);
 *			(void)fflush(stdout);
 */
			flag = 0;
			if(ifire == 0)
			{				/*  START # 1060  */
			   if( (region[i].ssurarea[0][j] != 0.) &&
			       (region[i].ssurarea[1][j] != 0.) &&
			       (region[i].ssurarea[2][j] != 0.) )
			   {				/*  START # 1065  */
			   diff = region[i].ssurarea[0][j]
				- region[i].ssurarea[1][j];
			   if(diff < 0.) diff = (-diff);
			   if( (diff / region[i].ssurarea[0][j]) > VOLVAR)
				flag = 1;
			   if( (diff / region[i].ssurarea[1][j]) > VOLVAR)
				flag = 1;

			   diff = region[i].ssurarea[0][j]
				- region[i].ssurarea[2][j];
			   if(diff < 0.) diff = (-diff);
			   if( (diff / region[i].ssurarea[0][j]) > VOLVAR)
				flag = 1;
			   if( (diff / region[i].ssurarea[2][j]) > VOLVAR)
				flag = 1;

			   diff = region[i].ssurarea[1][j]
				- region[i].ssurarea[2][j];
			   if(diff < 0.) diff = (-diff);
			   if( (diff / region[i].ssurarea[1][j]) > VOLVAR)
				flag = 1;
			   if( (diff / region[i].ssurarea[2][j]) > VOLVAR)
				flag = 1;
			   }				/*  END # 1065  */

			   else if( (region[i].ssurarea[0][j] == 0.) ||
			            (region[i].ssurarea[1][j] == 0.) ||
			            (region[i].ssurarea[2][j] == 0.) )
			   {
				flag = 2;
			   }

			   /*  Put in check.  */
/*
 *			   if(flag == 1)
 *			   {
 *				(void)printf("** Shar Sur Area Var exceeded ");
 *				(void)printf("for region %d, %d:  ",i,j);
 *				(void)printf("%f, %f, %f **\n",
 *					region[i].ssurarea[0][j],
 *					region[i].ssurarea[1][j],
 *					region[i].ssurarea[2][j]);
 *				(void)fflush(stdout);
 *			   }
 *			   else
 *			   {
 *				(void)printf("** Shar Sur Area Var NOT exceed");
 *				(void)printf("ed for region %d,%d:  ",i,j);
 *				(void)printf("%f, %f, %f **\n",
 *					region[i].ssurarea[0][j],
 *					region[i].ssurarea[1][j],
 *					region[i].ssurarea[2][j]);
 *				(void)fflush(stdout);
 *			   }
 */
			}				/*  END # 1060  */
			if(ifire == 0)
			{
			   region[i].ssurarea[0][j] = region[i].ssurarea[0][j]
			   	+ region[i].ssurarea[1][j]
				+ region[i].ssurarea[2][j];
			   region[i].ssurarea[0][j] /= 3.;
			}
			region[i].ssurarea[1][j] = (double)flag;
		   }
		}

		/*  Check for variance of all air areas (exterior,  */
		/*  crew, engine, closed compartment, exhaust, generic  */
		/*  1 & generic 2) & find area.  */
		for(k=0; k<7; k++)
		{					/*  START # 1070  */
		   flag = 0;
		   if(ifire == 0)
		   {					/*  START # 1080  */
			if( (region[i].cumfs[k][0] != 0.) &&
			    (region[i].cumfs[k][1] != 0.) &&
			    (region[i].cumfs[k][2] != 0.) )
			{				/*  START # 1090  */
			   diff = region[i].cumfs[k][0]
			        - region[i].cumfs[k][1];
			   if(diff < 0.) diff = (-diff);
			   if( (diff / region[i].cumfs[k][0]) > VOLVAR)
				flag = 1;
			   if( (diff / region[i].cumfs[k][1]) > VOLVAR)
				flag = 1;

			   diff = region[i].cumfs[k][0]
			        - region[i].cumfs[k][2];
			   if(diff < 0.) diff = (-diff);
			   if( (diff / region[i].cumfs[k][0]) > VOLVAR)
				flag = 1;
			   if( (diff / region[i].cumfs[k][2]) > VOLVAR)
				flag = 1;

			   diff = region[i].cumfs[k][1]
			        - region[i].cumfs[k][2];
			   if(diff < 0.) diff = (-diff);
			   if( (diff / region[i].cumfs[k][1]) > VOLVAR)
				flag = 1;
			   if( (diff / region[i].cumfs[k][2]) > VOLVAR)
				flag = 1;
			}				/*  END # 1090  */

			else if( (region[i].cumfs[k][0] == 0.) ||
			         (region[i].cumfs[k][1] == 0.) ||
			         (region[i].cumfs[k][2] == 0.) )
			{
			   flag = 2;
			}
		   }					/*  END # 1080  */

		   if(ifire == 0)
		   {
			region[i].cumfs[k][0] = region[i].cumfs[k][0] + 
			                        region[i].cumfs[k][1] + 
			                        region[i].cumfs[k][2];
			region[i].cumfs[k][0] /= 3.;
		   }

		   region[i].cumfs[k][1] = (double)flag;
		}					/*  END # 1070  */

		/*  Finish finding cummulative normal of exterior  */
		/*  free surface.  */

		/*  Print out normal before normalizing.  */
/*
 *		(void)printf("Normal before normalizing\n");
 *		(void)printf("  %f, %f, %f\n",region[i].cumnorm[X],
 *			region[i].cumnorm[Y],region[i].cumnorm[Z]);
 *		(void)fflush(stdout);
 */

		if( ( (-NORMTOL < region[i].cumnorm[X]) &&
			(region[i].cumnorm[X] < NORMTOL) ) &&
		    ( (-NORMTOL < region[i].cumnorm[Y]) &&
			(region[i].cumnorm[Y] < NORMTOL) ) &&
		    ( (-NORMTOL < region[i].cumnorm[Z]) &&
			(region[i].cumnorm[Z] < NORMTOL) ) )
		{
			region[i].cumnorm[X] = 0.;
			region[i].cumnorm[Y] = 0.;
			region[i].cumnorm[Z] = 0.;
		}

		else
		{
		   denom = sqrt( region[i].cumnorm[X] * region[i].cumnorm[X] +
		              region[i].cumnorm[Y] * region[i].cumnorm[Y] +
		              region[i].cumnorm[Z] * region[i].cumnorm[Z]);
		   if(denom > ZEROTOL)
		   {
			region[i].cumnorm[X] /= denom;
			region[i].cumnorm[Y] /= denom;
			region[i].cumnorm[Z] /= denom;
		   }
		   else
		   {
			region[i].cumnorm[X] = 0.;
			region[i].cumnorm[Y] = 0.;
			region[i].cumnorm[Z] = 0.;
		   }
		}

		i++;
	}

	if(iwrite == 0)
	{ (void)printf("\n\n\nPRINT OUT STRUCTURE\n");
	(void)fflush(stdout);
	i=0;
	while( i < num )
	{
		(void)printf("region #:  %d, name:  %s\n",(i+1),
			region[i].regname);
		(void)printf("\tmaterial code:  %d\n",region[i].mat);
		(void)fflush(stdout);

		if(region[i].cumvol[1] == 1.)
		{
		   (void)printf("\tvolume:  %f - difference is above",
			region[i].cumvol[0]);
		   (void)printf(" %f variance.\n",VOLVAR);
		   (void)fflush(stdout);
		}
		else
		{
		   (void)printf("\t volume:  %f - within variance.\n",
			region[i].cumvol[0]);
		   (void)fflush(stdout);
		}
			
		if(region[i].surarea[1] == 1.)
		{
		   (void)printf("\tarea:  %f - difference is above",
			region[i].surarea[0]);
		   (void)printf(" %f variance.\n",VOLVAR);
		   (void)fflush(stdout);
		}
		else
		{
		   (void)printf("\t area:  %f - within variance.\n",
			region[i].surarea[0]);
		   (void)fflush(stdout);
		}
			
		(void)printf("\tcentroid:  %f, %f, %f\n",region[i].centroid[0],
			region[i].centroid[1],region[i].centroid[2]);
		(void)fflush(stdout);
		(void)printf("\tcummulative normal of the exterior ");
		(void)printf("free surface:\n\t\t%f, %f, %f\n",
			region[i].cumnorm[X],region[i].cumnorm[Y],
			region[i].cumnorm[Z]);
		(void)fflush(stdout);
		(void)printf("\text sur air:  %f",region[i].cumfs[0][0]);
		if(region[i].cumfs[0][1] == 0.) (void)printf(" - ok\n");
		if(region[i].cumfs[0][1] == 1.) (void)printf(" - not ok\n");
		if(region[i].cumfs[0][1] == 2.) (void)printf(" - none\n");
		(void)printf("\tcrew comp air:  %f",region[i].cumfs[1][0]);
		if(region[i].cumfs[1][1] == 0.) (void)printf(" - ok\n");
		if(region[i].cumfs[1][1] == 1.) (void)printf(" - not ok\n");
		if(region[i].cumfs[1][1] == 2.) (void)printf(" - none\n");
		(void)printf("\teng comp air:  %f",region[i].cumfs[2][0]);
		if(region[i].cumfs[2][1] == 0.) (void)printf(" - ok\n");
		if(region[i].cumfs[2][1] == 1.) (void)printf(" - not ok\n");
		if(region[i].cumfs[2][1] == 2.) (void)printf(" - none\n");
		(void)printf("\tclosed comp air:  %f",region[i].cumfs[3][0]);
		if(region[i].cumfs[3][1] == 0.) (void)printf(" - ok\n");
		if(region[i].cumfs[3][1] == 1.) (void)printf(" - not ok\n");
		if(region[i].cumfs[3][1] == 2.) (void)printf(" - none\n");
		(void)printf("\texhaust air:  %f",region[i].cumfs[4][0]);
		if(region[i].cumfs[4][1] == 0.) (void)printf(" - ok\n");
		if(region[i].cumfs[4][1] == 1.) (void)printf(" - not ok\n");
		if(region[i].cumfs[4][1] == 2.) (void)printf(" - none\n");
		(void)printf("\tgen air 1:  %f",region[i].cumfs[5][0]);
		if(region[i].cumfs[5][1] == 0.) (void)printf(" - ok\n");
		if(region[i].cumfs[5][1] == 1.) (void)printf(" - not ok\n");
		if(region[i].cumfs[5][1] == 2.) (void)printf(" - none\n");
		(void)printf("\tgen air 2:  %f",region[i].cumfs[6][0]);
		if(region[i].cumfs[6][1] == 0.) (void)printf(" - ok\n");
		if(region[i].cumfs[6][1] == 1.) (void)printf(" - not ok\n");
		if(region[i].cumfs[6][1] == 2.) (void)printf(" - none\n");
		(void)fflush(stdout);
		for(j=0; j<num; j++)
		{
		   if(region[i].adjreg[j] == 1)
		   {
			(void)printf("\tadjreg[%d]=%d, ",
				(j+1),region[i].adjreg[j]);
			(void)printf("shared surface area:  %f\n",
			   region[i].ssurarea[0][j]);
			(void)fflush(stdout);
			if(region[i].ssurarea[1][j] == 1.)
			{
			   (void)printf("\tdifference is above %f variance\n",
				VOLVAR);
			   (void)fflush(stdout);
			}
			else
			{
			   (void)printf("\twithin variance\n");
			   (void)fflush(stdout);
			}
		   }
		}
		i++;
	} }
	if(iwrite == 1)
	{ i=0;
	while( i < num )
	{
		(void)fprintf(fp,"region #:  %d, name:  %s\n",
		   (i+1),region[i].regname);
		(void)fprintf(fp,"\tmaterial code:  %d\n",region[i].mat);

		if(region[i].cumvol[1] == 1.)
		{
		   (void)fprintf(fp,"\tvolume:  %f - difference is above",
			region[i].cumvol[0]);
		   (void)fprintf(fp," %f variance.\n",VOLVAR);
		   (void)fflush(fp);
		}
		else
		{
		   (void)fprintf(fp,"\t volume:  %f - within variance.\n",
			region[i].cumvol[0]);
		   (void)fflush(fp);
		}
			
		if(region[i].surarea[1] == 1.)
		{
		   (void)fprintf(fp,"\tarea:  %f - difference is above",
			region[i].surarea[0]);
		   (void)fprintf(fp," %f variance.\n",VOLVAR);
		   (void)fflush(fp);
		}
		else
		{
		   (void)fprintf(fp,"\t area:  %f - within variance.\n",
			region[i].surarea[0]);
		   (void)fflush(fp);
		}
			
		(void)fprintf(fp,"\tcentroid:  %f, %f, %f\n",
			region[i].centroid[0],
			region[i].centroid[1],region[i].centroid[2]);
		(void)fflush(fp);
		(void)fprintf(fp,"\tcummulative normal of the exterior ");
		(void)fprintf(fp,"free surface:\n\t\t%f, %f, %f\n",
			region[i].cumnorm[X],region[i].cumnorm[Y],
			region[i].cumnorm[Z]);
		(void)fflush(fp);
		(void)fprintf(fp,"\text sur air:  %f",region[i].cumfs[0][0]);
		if(region[i].cumfs[0][1] == 0.) (void)fprintf(fp," - ok\n");
		if(region[i].cumfs[0][1] == 1.) (void)fprintf(fp," - not ok\n");
		if(region[i].cumfs[0][1] == 2.) (void)fprintf(fp," - none\n");
		(void)fprintf(fp,"\tcrew comp air:  %f",region[i].cumfs[1][0]);
		if(region[i].cumfs[1][1] == 0.) (void)fprintf(fp," - ok\n");
		if(region[i].cumfs[1][1] == 1.) (void)fprintf(fp," - not ok\n");
		if(region[i].cumfs[1][1] == 2.) (void)fprintf(fp," - none\n");
		(void)fprintf(fp,"\teng comp air:  %f",region[i].cumfs[2][0]);
		if(region[i].cumfs[2][1] == 0.) (void)fprintf(fp," - ok\n");
		if(region[i].cumfs[2][1] == 1.) (void)fprintf(fp," - not ok\n");
		if(region[i].cumfs[2][1] == 2.) (void)fprintf(fp," - none\n");
		(void)fprintf(fp,"\tclsd comp air:  %f",region[i].cumfs[3][0]);
		if(region[i].cumfs[3][1] == 0.) (void)fprintf(fp," - ok\n");
		if(region[i].cumfs[3][1] == 1.) (void)fprintf(fp," - not ok\n");
		if(region[i].cumfs[3][1] == 2.) (void)fprintf(fp," - none\n");
		(void)fprintf(fp,"\texhaust air:  %f",region[i].cumfs[4][0]);
		if(region[i].cumfs[4][1] == 0.) (void)fprintf(fp," - ok\n");
		if(region[i].cumfs[4][1] == 1.) (void)fprintf(fp," - not ok\n");
		if(region[i].cumfs[4][1] == 2.) (void)fprintf(fp," - none\n");
		(void)fprintf(fp,"\tgen air 1:  %f",region[i].cumfs[5][0]);
		if(region[i].cumfs[5][1] == 0.) (void)fprintf(fp," - ok\n");
		if(region[i].cumfs[5][1] == 1.) (void)fprintf(fp," - not ok\n");
		if(region[i].cumfs[5][1] == 2.) (void)fprintf(fp," - none\n");
		(void)fprintf(fp,"\tgen air 2:  %f",region[i].cumfs[6][0]);
		if(region[i].cumfs[6][1] == 0.) (void)fprintf(fp," - ok\n");
		if(region[i].cumfs[6][1] == 1.) (void)fprintf(fp," - not ok\n");
		if(region[i].cumfs[6][1] == 2.) (void)fprintf(fp," - none\n");
		(void)fflush(fp);
		for(j=0; j<num; j++)
		{
		   if(region[i].adjreg[j] == 1)
		   {
			(void)fprintf(fp,"\tadjreg[%d]=%d, ",
			   (j+1),region[i].adjreg[j]);
			(void)fprintf(fp,"shared surface area:  %f;\n",
			   region[i].ssurarea[0][j]);
			(void)fflush(fp);
			if(region[i].ssurarea[1][j] == 1.)
			{
			   (void)fprintf(fp,"\tdifference is above ");
			   (void)fprintf(fp,"%f variance\n",
				VOLVAR);
			   (void)fflush(fp);
			}
			else
			{
			   (void)fprintf(fp,"\twithin variance\n");
			   (void)fflush(fp);
			}
		   }
		}
		i++;
	}

	/*  Print out names of all files used.  */
	(void)fprintf(fp,"\n\nSUMMARY OF FILES USED & CREATED\n");
	(void)fprintf(fp,"\t.g file used:  %s\n",argv[1]);
	(void)fprintf(fp,"\tregions used:\n");
	(void)fflush(fp);
	i=2;
	while(argv[i] != NULL)
	{
	   (void)fprintf(fp,"\t\t%s\n",argv[i]);
	   (void)fflush(fp);
	   i++;
	}
	(void)fprintf(fp,"\tmaterial id file used:  %s\n",fileden);
	if(iwrite == 1)
	{
	   (void)fprintf(fp,"\toutput file created:  %s\n",filename);
	}
	(void)fprintf(fp,"\tsecond pass file created:  %s\n",spfile);
	(void)fprintf(fp,"\terror file created:  %s\n",fileerr);
	(void)fprintf(fp,"\tregion # & name file created:  %s\n",
		filernn);
	if( typeout == 0 )
	{
	   (void)fprintf(fp,"\tfacet file created:  %s\n",facfile);
	   (void)fprintf(fp,"\t  (format is PRISM %d.0)\n",prmrel);
	}
	if( typeout == 1 ) (void)fprintf(fp,
	   "\tgeneric file created:  %s\n",filegen);
	if( (typeout == 2) || (typeout == 3) ) (void)fprintf(fp,
	   "\tgeometric file created:  %s\n",filegeo);
	(void)fflush(fp);

	(void)fclose(fp); }

/****************************************************************************/
	/*  Write region # & name file, for use with shapefact.  */
	fp7 = fopen(filernn,"w");
	for(i=0; i<num; i++)
	{
	   (void)fprintf(fp7,"%d\t%s\n",(i+1),region[i].regname);
	   (void)fflush(fp7);
	}
	(void)fclose(fp7);
/****************************************************************************/
	if( typeout == 0 ) {			/*  START # 11 */

	/*  Open facet file for writing to .  */
	fp1=fopen(facfile,"w");

	/*  Print type number of file (02) and description.  */
	(void)fprintf(fp1,"02\tFacet file for use with PRISM.\n");
	(void)fflush(fp1);

	/*  Print header information for facet file.  (Note:  header  */
	/*  info is the same for PRISM 2.0 & 3.0.)  */
	(void)fprintf(fp1," FN DESCRIPTION               TY");
	(void)fprintf(fp1,"    AREA    MASS  SPHEAT      E1");
	(void)fprintf(fp1,"      E2   ABSOR\n");
	(void)fflush(fp1);
	(void)fprintf(fp1,"   SN(X)   SN(Y)   SN(Z)    CONV");
	(void)fprintf(fp1,"       K       L   SHAPE\n");
	(void)fflush(fp1);

	/*  Make calculations to get PRISM information & then  */
	/*  write to file for each region (or facet as PRISM  */
	/*  calls them).  */

	for(i=0; i<num; i++)
	{
		/*  Find facet number (>=1).  */
		facnum = i + 1;
/*
 *		(void)printf("\n\tfacet number:  %d\n",facnum);
 *		(void)fflush(stdout);
 */

		/*  Find facet name (25 char max).  */
		c=region[i].regname[0];
		icnt = 0;
		while(c != '\0')
		{
			icnt += 1;
			c=region[i].regname[icnt];
		}
		icnt -= 1;
		for(j=24; j>=0; j--)
		{
			if(icnt >= 0)
			{
			   facname[j] = region[i].regname[icnt];
			   icnt -= 1;
			}
			else
			{
			   facname[j] = ' ';
			   icnt -= 1;
			}
		}
/*
 *		(void)printf("name:%.25s:\n",facname);
 *		(void)fflush(stdout);
 */

		/*  Find facet type (for now all are 1).  */
		factype = 1;
/*
 *		(void)printf("facet type:  %d  ",factype);
 *		(void)fflush(stdout);
 */

		/*  Find area of facet or as it has been called  */
		/*  exterior surface area (sq meters).  */
		facarea = region[i].cumfs[0][0] * (1.e-6);

		/*  If there is no exterior surface area, i.e. the  */
		/*  surface normal is (0,0,0) set the area of the  */
		/*  facet to the total surface area.  If the exterior  */
		/*  surface area is small (< .001) set the area of the  */
		/*  facet to .001.  This is done since PRISM will not  */
		/*  accept a 0 surface area.  */
		if( (region[i].cumnorm[0] == 0.) &&
		    (region[i].cumnorm[1] == 0.) &&
		    (region[i].cumnorm[2] == 0.) )
		{
		   facarea = region[i].surarea[0] * (1.e-6);
		   (void)printf("There are no exterior surfaces on region ");
		   (void)printf("%d.  Setting exterior surface area\n",(i+1));
		   (void)printf("\tto total surface area %f\n",facarea);
		   (void)fflush(stdout);
		}
		if(facarea < .001)
		{
		   facarea = .001;
		   (void)printf("Small surface area for region %d.  ",(i+1));
		   (void)printf("Setting exterior surface area");
		   (void)printf("\tto %f.\n",facarea);
		}
/*
 *		(void)printf("area:  %8.3f  ",facarea);
 *		(void)fflush(stdout);
 */

		/*  Set material id number.  */
		if(region[i].mat <= 40.) ia = (int)region[i].mat;
		else ia = 0;

		/*  Find the mass of the facet (kg).  This is  */
		/*  dependent on the volume and material code.  */
		facmass = matprop[ia].d * region[i].cumvol[0] * (1.e-9);
/*
 *		(void)printf("mass:  %8.3f\n",facmass);
 *		(void)fflush(stdout);
 */

		/*  Find the specific heat of the facet (J/kg deg C).  */
		/*  Read from material file.  */
		facspheat = matprop[ia].sh;

		/*  Emissivities with respect to the environment &  */
		/*  other facets.  They are read from material file.  */
		face1 = matprop[ia].e1;
		face2 = matprop[ia].e2;

		/*  Absorptivity of facet.  Read from material file.  */
		facabs = matprop[ia].a;
/*
 *		(void)printf("specific heat:  %8.3f  emissivities:  %8.3f & %8.3f  absorb:  %8.3f\n",
 *		   facspheat,face1,face2,facabs);
 *		(void)fflush(stdout);
 */

		/*  Surface normal of facet.  Must be rotated back first.  */
		facnorm[X] = region[i].cumnorm[0];
		facnorm[Y] = region[i].cumnorm[1];
		facnorm[Z] = region[i].cumnorm[2];
/*
 *		(void)printf("normal:  %8.3f %8.3f %8.3f\n",
 *		   facnorm[0],facnorm[1],facnorm[2]);
 */

		/*  Convection coefficient of facet.  Currently  */
		/*  set to 1.  */
		faccv = 1.;

		/*  Facets seen by the back & front of current  */
		/*  facet.  Will be set to 0 thereby assuming  */
		/*  there is not radiative exchange taking  */
		/*  place.  */
		fack = 0;
		facl = 0;
/*
 *		(void)printf("faccv:  %8.3f, fack:  %3d, facl:  %3d\n",
 *		   faccv,fack,facl);
 *		(void)fflush (stdout);
 */

		/*  Shape factors for engine & track facets  */
		/*  (between 0 & 1).  Currently set to 0.  */
		facshape = 0.;

		/*  Hub radius (m).  Currently set to 0 unless engine  */
		/*  air area exist then print engine air area in square  */
		/*  meters.  */
		facradius = 0.;
		if(region[i].cumfs[2][0] > ZEROTOL)
			facradius = region[i].cumfs[2][0] * (1.e-6);

		/*  Bearing friction constant (J) for wheels.  */
		/*  Currently set to 0.  */
		facfric = 0.;
/*
 *		(void)printf("facshape:  %8.3f, facradius:  %8.3f, facfric:  %8.3f\n",
 *		   facshape,facradius,facfric);
 *		(void)fflush(stdout);
 */

		/*  Print information to the facet file.  */
		if(prmrel == 2)
		    (void)fprintf(fp1,"%3d %.25s%3d%8.3f%8.3f%8.3f",
		    facnum,facname,factype,facarea,facmass,facspheat);
		if(prmrel == 3)
		    (void)fprintf(fp1,"%6d %.25s%3d%8.3f%8.3f%8.3f",
		    facnum,facname,factype,facarea,facmass,facspheat);
		(void)fprintf(fp1,"%8.3f%8.3f%8.3f\n",face1,
		    face2,facabs);
		(void)fflush(fp1);

		(void)fprintf(fp1,"%8.3f%8.3f%8.3f%8.3f%8d%8d",
		    facnorm[0],facnorm[1],facnorm[2],faccv,fack,facl);
		(void)fprintf(fp1,"%8.3f%8.3f%8.3f\n",facshape,
		    facradius,facfric);
		(void)fflush(fp1);

	}

	/*  Write last line to signify end of facet information.  */
	if(prmrel == 2)(void)fprintf(fp1,"%3d END OF REGIONS           999\n",
		(facnum+1));
	if(prmrel == 3)(void)fprintf(fp1,"%6d END OF REGIONS           999\n",
		(facnum+1));
	(void)fflush(fp1);

	/*  Close facet file.  */
	(void)fclose(fp1);

	}						/*  END # 11  */

/****************************************************************************/

	/*  Open and write to generic file if needed.  */

	/*  Format for generic file.  */
	/*	1  region #  region name  volume  density  ...  */
	/*		thermal conductivity  specific heat  material  */
	/*                                                             */
	/*	2  region #  # of exterior convection surfaces  ...  */
	/*		# of internal convection surfaces  */
	/*	   areas of all external surfaces  */
	/*	   areas of all internal surfaces  */
	/*                                                             */
	/*	3  region #  # of solar loaded surfaces  */
	/*	   surface area  surface normal (X Y Z)  absorptivity  */

	if(typeout == 1)
	{						/*  START # 12  */
	   /*  Open generic file.  */
	   fp5 = fopen(filegen,"w");

	   /*  Write out # 1 information.  */
	   for(i=0; i<num; i++)
	   {
		/*  Find region name (25 char).  */
		c = region[i].regname[0];
		icnt = 0;
		while(c != '\0')
		{
		   icnt += 1;
		   c = region[i].regname[icnt];
		}
		icnt -= 1;
		for(j=24; j>=0; j--)
		{
		   if(icnt >= 0)
		   {
			facname[j] = region[i].regname[icnt];
			icnt -= 1;
		   }
		   else
		   {
			facname[j] = ' ';
			icnt -= 1;
		   }
		}

		if(region[i].mat <= 40) ia = (int)region[i].mat;
		else ia = 0;

		(void)fprintf(fp5,"1 %6d %.25s %.3e %.3e ",
			(i+1),facname,(region[i].cumvol[X]*1.e-9),
			matprop[ia].d);
		(void)fprintf(fp5,"%.3e %.3e %.25s\n",matprop[ia].tc,
			matprop[ia].sh,matprop[ia].m);
		(void)fflush(fp5);
	   }

	   /*  Write out # 2 information.  */
	   for(i=0; i<num; i++)
	   {
		/*  Any exterior surfaces?  */
		numext = 0;
		if(region[i].cumfs[0][0] > ZEROTOL) numext = 1;

		/*  Any interior surfaces?  */
		numint = 0;
		if(region[i].cumfs[1][0] > ZEROTOL) numint += 1;
		if(region[i].cumfs[2][0] > ZEROTOL) numint += 1;
		if(region[i].cumfs[3][0] > ZEROTOL) numint += 1;
		if(region[i].cumfs[4][0] > ZEROTOL) numint += 1;
		if(region[i].cumfs[5][0] > ZEROTOL) numint += 1;
		if(region[i].cumfs[6][0] > ZEROTOL) numint += 1;

		(void)fprintf(fp5,"2 %6d   %3d          %3d\n",
			(i+1),numext,numint);
		(void)fflush(fp5);

		if(numext == 1)
		{
		   (void)fprintf(fp5,"  %.3e\n",(region[i].cumfs[0][0]*1.e-6));
		   (void)fflush(fp5);
		}
		if(numint > 0)
		{
		   if(region[i].cumfs[1][0] > ZEROTOL)
		   {
			(void)fprintf(fp5,"  %.3e",
				(region[i].cumfs[1][0]*1.e-6));
		   }
		   if(region[i].cumfs[2][0] > ZEROTOL)
		   {
			(void)fprintf(fp5," %.3e",
				(region[i].cumfs[2][0]*1.e-6));
		   }
		   if(region[i].cumfs[3][0] > ZEROTOL)
		   {
			(void)fprintf(fp5," %.3e",
				(region[i].cumfs[3][0]*1.e-6));
		   }
		   if(region[i].cumfs[4][0] > ZEROTOL)
		   {
			(void)fprintf(fp5," %.3e",
				(region[i].cumfs[4][0]*1.e-6));
		   }
		   if(region[i].cumfs[5][0] > ZEROTOL)
		   {
			(void)fprintf(fp5," %.3e",
				(region[i].cumfs[5][0]*1.e-6));
		   }
		   if(region[i].cumfs[6][0] > ZEROTOL)
		   {
			(void)fprintf(fp5," %.3e",
				(region[i].cumfs[6][0]*1.e-6));
		   }
		   (void)fprintf(fp5,"\n");
		   (void)fflush(stdout);
		}
	   }

	   /*  Write out # 3 information.  */
	   for(i=0; i<num; i++)
	   {
		numsol = 0;
		if(region[1].cumfs[0][0] > ZEROTOL) numsol = 1;
		(void)fprintf(fp5,"3 %6d %3d\n",(i+1),numsol);
		(void)fflush(fp5);
		if(numsol > 0)
		{
		   if(region[i].mat <= 40) ia = (int)region[i].mat;
		   else ia = 0;

		   (void)fprintf(fp5,"  %.3e %+.3e %+.3e %+.3e %.3e\n",
			(region[i].cumfs[0][0]*1.e-6),region[i].cumnorm[X],
			region[i].cumnorm[Y],region[i].cumnorm[Z],
			matprop[ia].a);
		   (void)fflush(fp5);
		}
	   }

	   /*  Close generic file.  */
	   (void)fclose(fp5);

	}						/*  END # 12  */

/****************************************************************************/

	/*  Open and write to geometric file if needed.  */

	if( (typeout == 2) || (typeout==3) )
	{						/*  START # 13  */

	   /*  Open geometry file.  */
	   fp6 = fopen(filegeo,"w");

	   /*  Readable geometric file.  */

	   /*  Format for readable geometric file.  */
	   /*	region #  region name  centroid-X  Y  Z  ...  */
	   /*		volume (m**3)  mass (kg)  */
	   /*						      */
	   /*	region #  ext surface area (m**2)  ...  */
	   /*		engine surface area (m**2)  ...  */
	   /*		crew surface area (m**2)  ...  */
	   /*		closed compartment surface area (m**2)  ...  */
	   /*		exhaust surface area (m**2)  ...  */
	   /*		generic 1 surface area (m**2)  ...  */
	   /*		generic 2 surface area (m**2)  */
	   /*						      */
	   /*	region #  material code  density (kg/m3)  ...  */
	   /*		specific heat  absorptivity  emissivity  ...  */
	   /*		thermal conductivity (W/mK)  material  */
	   /*						      */
	   /*	region #  all adjacent regions (up to 20)  */

	   if(typeout == 2) {
	   /*  Write to geometric file.  */
	   (void)fprintf(fp6,"\nGEOMETRIC FILE - from firpass\n");
	   (void)fprintf(fp6,"\n.gfile used:  %s\n",argv[1]);
	   (void)fprintf(fp6,"\tregions used:\n");
	   (void)fflush(fp6);
	   i = 2;
	   while(argv[i] != NULL)
	   {
		(void)fprintf(fp6,"\t\t%s\n",argv[i]);
		(void)fflush(fp6);
		i++;
	   }
	   (void)fprintf(fp6,"\n\n");
	   (void)fflush(fp6);

	   (void)fprintf(fp6,"region   region name                 ");
	   (void)fprintf(fp6,"centroid                           ");
	   (void)fprintf(fp6,"volume       mass\n");
	   (void)fprintf(fp6,"number                               ");
	   (void)fprintf(fp6,"X          Y          Z            ");
	   (void)fprintf(fp6,"(m**3)       (kg)\n");
	   (void)fflush(fp6);

	   for(i=0; i<num; i++)
	   {

		/*  Find region name (25 char).  */
		c = region[i].regname[0];
		icnt = 0;
		while(c != '\0')
		{
		   icnt += 1;
		   c = region[i].regname[icnt];
		}
		icnt -= 1;
		for(j=24; j>=0; j--)
		{
		   if(icnt >= 0)
		   {
			facname[j] = region[i].regname[icnt];
			icnt -= 1;
		   }
		   else
		   {
			facname[j] = ' ';
			icnt -= 1;
		   }
		}

		if(region[i].mat <=40) ia = (int)region[i].mat;
		else ia = 0;
		facmass = matprop[ia].d * region[i].cumvol[0] * (1.e-9);
		(void)fprintf(fp6,"%6d   %.25s   %+.3e %+.3e %+.3e   ",
			(i+1),facname,region[i].centroid[X],
			region[i].centroid[Y],region[i].centroid[Z]);
		(void)fprintf(fp6,"%.3e   %.3e\n",(region[i].cumvol[X]*1.e-9),
			facmass);
		(void)fflush(fp6);
	   }

	   (void)fprintf(fp6,"\n\n\nregion   exterior sur   engine sur    ");
	   (void)fprintf(fp6,"crew sur      closed compartment");
	   (void)fprintf(fp6,"   exhaust sur   generic 1 sur   ");
	   (void)fprintf(fp6,"generic 2 sur\n");
	   (void)fprintf(fp6,"number   area (m**2)    area (m**2)   ");
	   (void)fprintf(fp6,"area (m**2)   sur area (m**2)");
	   (void)fprintf(fp6,"      area (m**2)   area (m**2)     ");
	   (void)fprintf(fp6,"area (m**2)\n");
	   (void)fflush(fp6);

	   for(i=0; i<num; i++)
	   {
		(void)fprintf(fp6,"%6d   %.3e      %.3e     %.3e    ",
			(i+1),(region[i].cumfs[0][0]*1.e-6),
			(region[i].cumfs[2][0]*1.e-6),
			(region[i].cumfs[1][0]*1.e-6));
		(void)fprintf(fp6," %.3e            %.3e     %.3e       %.3e\n",
			(region[i].cumfs[3][0]*1.e-6),
			(region[i].cumfs[4][0]*1.e-6),
			(region[i].cumfs[5][0]*1.e-6),
			(region[i].cumfs[6][0]*1.e-6));
		(void)fflush(fp6);
	   }

	   (void)fprintf(fp6,"\n\nregion   material   density      ");
	   (void)fprintf(fp6,"specific     absorptivity   emissivity   ");
	   (void)fprintf(fp6,"thermal               material\n");
	   (void)fprintf(fp6,"number   code       (kg/m3)      ");
	   (void)fprintf(fp6,"heat                                     ");
	   (void)fprintf(fp6,"conductivity (W/mK)\n");

	   for(i=0; i<num; i++)
	   {
		if(region[i].mat <= 40) ia = (int)region[i].mat;
		else ia = 0;

		(void)fprintf(fp6,"%6d   %3d        %.3e    ",
			(i+1),region[i].mat,matprop[ia].d);
		(void)fprintf(fp6,"%.3e    %.3e      %.3e    %.3e",
			matprop[ia].sh,matprop[ia].a,matprop[ia].e1,
			matprop[ia].tc);
		(void)fprintf(fp6,"           %s\n",matprop[ia].m);
		(void)fflush(fp6);
	   }

	   (void)fprintf(fp6,"\n\nregion   adjacent\n");
	   (void)fprintf(fp6,"number   regions");
	   (void)fflush(fp6);

	   for(i=0; i<num; i++)
	   {
		(void)fprintf(fp6,"\n%6d   ",(i+1));

		for(j=0; j<num; j++)
		{
		   if(region[i].adjreg[j] == 1)
		   {
			(void)fprintf(fp6,"%4d, ",(j+1));
			(void)fflush(fp6);
		   }
		}
	   } }

	   if(typeout == 3)
	   {

	   /*  Format for non-readable geometric file.  */
	   /*	region #, region name, centroid-X, Y, Z, volume,  ...  */
	   /*		mass, exterior surface area,  ...  */
	   /*		crew surface area, engine surface area,  ...  */
	   /*		closed compartment surface area,  ...  */
	   /*		exhaust surface area, generic 1 surface area,  ...  */
	   /*		generic 2 surface area,  ...  */
	   /*		material code, density, specific heat,  ...  */
	   /*		absorptivity, emissivity, thermal conductivity,  ...  */
	   /*		all adjacent regions  */

	     for(i=0; i<num; i++)
	     {

		/*  Find region name (25 char).  */
		c = region[i].regname[0];
		icnt = 0;
		while(c != '\0')
		{
		   icnt += 1;
		   c = region[i].regname[icnt];
		}
		icnt -= 1;
		for(j=24; j>=0; j--)
		{
		   if(icnt >= 0)
		   {
			facname[j] = region[i].regname[icnt];
			icnt -= 1;
		   }
		   else
		   {
			facname[j] = ' ';
			icnt -= 1;
		   }
		}

		if(region[i].mat <=40) ia = (int)region[i].mat;
		else ia = 0;
		facmass = matprop[ia].d * region[i].cumvol[0] * (1.e-9);

		(void)fprintf(fp6,"%d,%s,%.3e,%.3e,%.3e,",
			(i+1),facname,region[i].centroid[X],
			region[i].centroid[Y],region[i].centroid[Z]);
		(void)fflush(fp6);

		(void)fprintf(fp6,"%.3e,%.3e,%.3e,%.3e,%.3e,",
			(region[i].cumvol[X]*1.e-9),facmass,
			(region[i].cumfs[0][0]*1.e-6),
			(region[i].cumfs[1][0]*1.e-6),
			(region[i].cumfs[2][0]*1.e-6));
		(void)fprintf(fp6,"%.3e,%.3e,%.3e,%.3e,",
			(region[i].cumfs[3][0]*1.e-6),
			(region[i].cumfs[4][0]*1.e-6),
			(region[i].cumfs[5][0]*1.e-6),
			(region[i].cumfs[6][0]*1.e-6));
		(void)fflush(fp6);

		(void)fprintf(fp6,"%d,%.3e,%.3e,%.3e,%.3e,%.3e,",
			region[i].mat,matprop[ia].d,matprop[ia].sh,
			matprop[ia].a,matprop[ia].e1,matprop[ia].tc);
		(void)fflush(fp6);

		ii = 0;
		for(j=0; j<num; j++)
		{
		   if( (region[i].adjreg[j] == 1) && (ii < 20) )
		   {
			(void)fprintf(fp6,"%d,",(j+1));
			(void)fflush(fp6);
			ii++;
		   }

		}
		if(ii < 20)
		{
		   for(j=ii; j<20; j++)
		   {
			(void)fprintf(fp6,"%d,",0);
			(void)fflush(fp6);
		   }
		}
		(void)fprintf(fp6,"\n");
		(void)fflush(stdout);
	     }
	   }

	   /*  Close geometric file.  */
	   (void)fclose(fp6);

	}						/*  END # 13  */
/****************************************************************************/

	/*  Open second pass file.  */
	fp2 = fopen(spfile,"w");

	/*  Write info to second pass file.  */
	/*  Write number of regions to file.  */
	(void)fprintf(fp2,"%8d\n",num);
	(void)fflush(fp2);

	for(i=0; i<num; i++)
	{

		/*  Write region number, centroid & material id  */
		/*  to 2nd pass file.  */
		(void)fprintf(fp2,"%8d  %.6e  %.6e  %.6e  %3d\n",
		   (i+1),region[i].centroid[0],region[i].centroid[1],
		   region[i].centroid[2],region[i].mat);
		(void)fflush(fp2);

		/*  Write area of adjacent region.  */
		for(j=0; j<num; j++)
		{
		   spsarea = region[i].ssurarea[0][j];
		   (void)fprintf(fp2,"%8d  %.6e\n",
		      (j+1),spsarea);
		   (void)fflush(fp2);
		}
	}

	/*  Close second pass file.  */
	(void)fclose(fp2);

/****************************************************************************/

	/*  Open error file.  */
	fp3=fopen(fileerr,"w");

	/*  Write errors to error file.  */
	(void)fprintf(fp3,"\nERRORS from firpass\n\n");
	/*  Write type of file created to error file.  */
	if(typeout == 0)
	{
	   (void)fprintf(fp3,"Facet file, %s, PRISM %d.0 was created.\n\n",
		facfile,prmrel);
	}
	if(typeout == 1) (void)fprintf(fp3,"Generic file, %s, was created.\n\n",
		filegen);
	if(typeout == 2)
	{
	   (void)fprintf(fp3,"Geometric file, %s, was created.\n\n",filegeo);
	}
	(void)fflush(fp3);
	for(i=0; i<num; i++)
	{
	   if(region[i].cumvol[1] == 1)
	   {
		(void)fprintf(fp3,"region %d:  ",(i + 1));
		(void)fprintf(fp3,"large variance on volume:  %f\n",
		   region[i].cumvol[0]);
		(void)fflush(fp3);
	   }

	   if(region[i].surarea[1] == 1)
	   {
		(void)fprintf(fp3,"region %d:  large variance ",(i + 1));
		(void)fprintf(fp3,"on surface area:  %f\n",
		   region[i].surarea[0]);
		(void)fflush(fp3);
	   }

	   for(j=0; j<num; j++)
	   {
		if(region[i].ssurarea[1][j] == 1)
		{
		   (void)fprintf(fp3,"region %d:  adjacent region %d:\n",
			(i + 1),(j + 1));
		   (void)fprintf(fp3,"\tlarge variance on shared surface ");
		   (void)fprintf(fp3,"area:  %f\n",region[i].ssurarea[0][j]);
		   (void)fflush(fp3);
		}
	   }

	   for(j=0; j<7; j++)
	   {						/*  START # 2000  */
		if(region[i].cumfs[j][1] == 1.)
		{					/*  START # 2010  */
		   if(j == 0)
		   {
			(void)fprintf(fp3,"\treg %d - large variance ",i);
			(void)fprintf(fp3,"of exterior air\n");
		   }
		   if(j == 1)
		   {
			(void)fprintf(fp3,"\treg %d - large variance ",i);
			(void)fprintf(fp3,"of crew comp air\n");
		   }
		   if(j == 2)
		   {
			(void)fprintf(fp3,"\treg %d - large variance ",i);
			(void)fprintf(fp3,"of engine comp air\n");
		   }
		   if(j == 3)
		   {
			(void)fprintf(fp3,"\treg %d - large variance ",i);
			(void)fprintf(fp3,"of closed comp air\n");
		   }
		   if(j == 4)
		   {
			(void)fprintf(fp3,"\treg %d - large variance ",i);
			(void)fprintf(fp3,"of exhaust air\n");
		   }
		   if(j == 5)
		   {
			(void)fprintf(fp3,"\treg %d - large variance ",i);
			(void)fprintf(fp3,"of generic air 1\n");
		   }
		   if(j == 6)
		   {
			(void)fprintf(fp3,"\treg %d - large variance ",i);
			(void)fprintf(fp3,"of generic air 2\n");
		   }
		   (void)fflush(fp3);
		}					/*  END # 2010  */
	   }						/*  END # 2000  */
	}

	/*  Write overlaps to error file.  */
	(void)fprintf(fp3,"\n\n\tOVERLAPS\n\n");
	(void)fflush(fp3);
	for(i=0; i<num; i++)
	{
	   for(j=0; j<num; j++)
	   {
		if(overlaps[i].ovrreg[j] == 1)
		{
		   (void)fprintf(fp3,"%s & %s, max depth:  %fmm  ",
			region[i].regname,region[j].regname,
			overlaps[i].ovrdep[j]);
		   (void)fflush(fp3);
		   if(overlaps[i].ovrdep[j] < ADJTOL)
		   {
			(void)fprintf(fp3,"(within tolerance)\n");
			(void)fflush(fp3);
		   }
		   else
		   {
			(void)fprintf(fp3,"\n");
			(void)fflush(fp3);
		   }
		}
	   }
	}

	/*  Write number of adjacent regions to error file.  */
	(void)fprintf(fp3,"\n\nREGION NUMBER     NUMBER OF ADJACENT REGIONS\n");
	(void)fflush(fp3);
	for(i=0; i<num; i++)
	{
	   numadjreg = 0;
	   for(j=0; j<num; j++)
	   {
		if(region[i].adjreg[j] == 1) numadjreg++;
	   }
	   (void)fprintf(fp3,"        %5d                          ",(i+1));
	   (void)fprintf(fp3,"%5d\n",numadjreg);
	   (void)fflush(fp3);
	}

	/*  Print out names of all files used.  */
	(void)printf("\n\nSUMMARY OF FILES USED & CREATED\n");
	(void)printf("\t.g file used:  %s\n",argv[1]);
	(void)printf("\tregions used:\n");
	(void)fflush(stdout);
	i=2;
	while(argv[i] != NULL)
	{
	   (void)printf("\t\t%s\n",argv[i]);
	   (void)fflush(stdout);
	   i++;
	}
	(void)printf("\tmaterial id file used:  %s\n",fileden);
	if(iwrite == 1)
	{
	   (void)printf("\toutput file created:  %s\n",filename);
	}
	(void)printf("\tsecond pass file created:  %s\n",spfile);
	(void)printf("\terror file created:  %s\n",fileerr);
	(void)printf("\tregion # & name file created:  %s\n",filernn);
	if( typeout == 0 )
	{
	   (void)printf("\tfacet file created:  %s\n",facfile);
	   (void)printf("\t  (format is PRISM %d.0)\n\n\n",prmrel);
	}
	if( typeout == 1 ) (void)printf(
	   "\tgeneric file created:  %s\n\n\n",filegen);
	if( (typeout == 2) || (typeout == 3) ) (void)printf(
	   "\tgeometric file created:  %s\n\n\n",filegeo);
	(void)fflush(stdout);

	/*  Close error file.  */
	(void)fclose(fp3);

	/*  Everything is complete, free all memory.  */

	(void)printf("Freeing memory.\n");
	(void)fflush(stdout);

	for(i=0; i<num; i++)
	{
		free(region[i].adjreg);
		free(region[i].ssurarea[0]);
		free(region[i].ssurarea[1]);
		free(region[i].ssurarea[2]);
		free(overlaps[i].ovrreg);
		free(overlaps[i].ovrdep);
	}
	free(region);
	free(overlaps);

   }
   return(0);
}

int
hit(register struct application *ap_p, struct partition *PartHeadp)
{

	register struct partition *pp;
	register struct hit *hitp;
	register struct soltab *stp;
	struct curvature cur;

	double enterpt[3];	/*  Point where ray enters.  */
	double distance;	/*  Distance between where point enters  */
				/*  and leaves.  */
	double disx,disy,disz;	/*  Used for finding distance.  */
	double costheta;	/*  Used in computing areas.  */
	double costheta1;	/*  Used in computing surface area.  */
	double costheta2;	/*  Used in computing exterior surface air.  */
	short prevregid;	/*  Previous region id.  */
	short prevair;		/*  Previous air code.  */

	/*  Initialize the following.  */
	prevregid = (-1);
	prevair = (-1);

	pp=PartHeadp->pt_forw;
	for( ; pp != PartHeadp; pp = pp->pt_forw)
	{
/*
 *		(void)printf("Hit region %s (in %s, out %s)\n",
 *			pp->pt_regionp->reg_name,
 *			pp->pt_inseg->seg_stp->st_name,
 *			pp->pt_outseg->seg_stp->st_name);
 *		(void)fflush(stdout);
 *		(void)printf("index to region:  %d\n",
 *			pp->pt_regionp->reg_bit);
 *		(void)fflush(stdout);
 */

		/*  Print out region id and aircode.  */
/*
 *		(void)printf("region id:  %d, aircode:  %d\n",
 *		    pp->pt_regionp->reg_regionid,pp->pt_regionp->reg_aircode);
 *		(void)fflush(stdout);
 */

		/*  Put region name into region[].regname.  */
/*
 *		(void)printf("Putting region name into struct.\n");
 *		(void)fflush(stdout);
 */
		icur=pp->pt_regionp->reg_bit;	/*  region # hit  */
/*
 *		(void)printf("region %d:  *%s*\n",icur,region[icur].regname);
 *		(void)fflush(stdout);
 */

		region[icur].regname = (char *)pp->pt_regionp->reg_name;

/*
 *		(void)printf("region #:  %d, region name:  %s\n",
 *			icur,region[icur].regname);
 *		(void)fflush(stdout);
 */

		/*  Put material code into region[].mat.  */
		region[icur].mat = pp->pt_regionp->reg_gmater;

		/*  Find normal and hit point of entering ray.  */
/*
 *		(void)printf("Entering Ray\n");
 *		(void)fflush(stdout);
 */
		hitp=pp->pt_inhit;
		stp=pp->pt_inseg->seg_stp;
		RT_HIT_NORM(hitp,stp,&(ap_p->a_ray));
		/*  Flip normal if needed.  */
		if(pp->pt_inflip)
		{
			VREVERSE(hitp->hit_normal,hitp->hit_normal);
			pp->pt_inflip=0;
		}

		/*  Find front surface area of region.  */
		costheta1 = hitp->hit_normal[X] * ap_p->a_ray.r_dir[X]
		          + hitp->hit_normal[Y] * ap_p->a_ray.r_dir[Y]
		          + hitp->hit_normal[Z] * ap_p->a_ray.r_dir[Z];
		if(costheta1 < 0) costheta1 = (-costheta1);
		if( costheta1 > COSTOL)
		   region[icur].surarea[whichview] += (area/costheta1);

		if(
		   (-ADJTOL < (hitp->hit_point[X] - leavept[X])) &&
		   ((hitp->hit_point[X] - leavept[X]) < ADJTOL) &&
		   (-ADJTOL < (hitp->hit_point[Y] - leavept[Y])) &&
		   ((hitp->hit_point[Y] - leavept[Y]) < ADJTOL) &&
		   (-ADJTOL < (hitp->hit_point[Z] - leavept[Z])) &&
		   ((hitp->hit_point[Z] - leavept[Z]) < ADJTOL)
		  )

		{
			/*  Find adjacent regions.  Occasionally a  */
			/*  a region will seem to be adjacent to self,  */
			/*  disreguard this.  */
			if( icur != iprev)
			{
			  region[icur].adjreg[iprev]=1;
			  region[iprev].adjreg[icur]=1;
			}

			/*  Find surface area. */
			costheta = lnormal[X]*ap_p->a_ray.r_dir[X]
			          + lnormal[Y]*ap_p->a_ray.r_dir[Y]
			          + lnormal[Z]*ap_p->a_ray.r_dir[Z];
			if( costheta < 0 ) costheta = (-costheta);
			if( costheta > COSTOL )
			{
			  region[icur].ssurarea[whichview][iprev] +=
				(area/costheta);
			  region[iprev].ssurarea[whichview][icur] +=
				(area/costheta);
			}
		}

		/*  Save point where ray enters region.  */
		enterpt[X]=hitp->hit_point[X];
		enterpt[Y]=hitp->hit_point[Y];
		enterpt[Z]=hitp->hit_point[Z];

		/*  Print out hit point & normal.  */
/*
 *		(void)printf("Hit Point (entering):  (%f, %f, %f)\n",
 *			hitp->hit_point[X],
 *			hitp->hit_point[Y],
 *			hitp->hit_point[Z]);
 *		(void)fflush(stdout);
 *		(void)printf("Normal Point:  (%f, %f, %f)\n",
 *			hitp->hit_normal[X],
 *			hitp->hit_normal[Y],
 *			hitp->hit_normal[Z]);
 *		(void)fflush(stdout);
 */

		/*  Compute cummulative free surface normal,  */
		/*  free surface area, crew compartment area,  */
		/*  engine compartment area, & other air areas  */
		/*   when ray enters from another region.  */
		if(
		  (-ADJTOL < (hitp->hit_point[X] - leavept[X])) &&
			((hitp->hit_point[X] - leavept[X]) < ADJTOL) &&
		  (-ADJTOL < (hitp->hit_point[Y] - leavept[Y])) &&
			((hitp->hit_point[Y] - leavept[Y]) < ADJTOL) &&
		  (-ADJTOL < (hitp->hit_point[Z] - leavept[Z])) &&
			((hitp->hit_point[Z] - leavept[Z]) < ADJTOL)
		  )
		{
		   if((prevregid == 0) && (pp->pt_regionp->reg_regionid != 0))
		   {
			costheta2 = hitp->hit_normal[X] * ap_p->a_ray.r_dir[X]
			          + hitp->hit_normal[Y] * ap_p->a_ray.r_dir[Y]
			          + hitp->hit_normal[Z] * ap_p->a_ray.r_dir[Z];
			if(costheta2 < 0.) costheta2=(-costheta2);
			if(prevair == 1)
			{
			   if(costheta2 > COSTOL)
			   {
			   	region[icur].cumnorm[X] += hitp->hit_normal[X]
					/ costheta2;
			   	region[icur].cumnorm[Y] += hitp->hit_normal[Y]
					/ costheta2;
			   	region[icur].cumnorm[Z] += hitp->hit_normal[Z]
					/ costheta2;
				region[icur].cumfs[0][whichview]
					+= (area/costheta2);
			   }
			}
			else if(prevair == 2)
			{
			   if(costheta2 > COSTOL)
				region[icur].cumfs[1][whichview]
				 += (area/costheta2);
			}
			else if(prevair == 5)
			{
			   if(costheta2 > COSTOL)
				region[icur].cumfs[2][whichview]
				 += (area/costheta2);
			}
			else if(prevair == 6)	/*  Closed compartment.  */
			{
			   if(costheta2 > COSTOL)
				region[icur].cumfs[3][whichview]
				 += (area/costheta2);
			}
			else if(prevair == 7)	/*  Exhaust air.  */
			{
			   if(costheta2 > COSTOL)
				region[icur].cumfs[4][whichview]
				 += (area/costheta2);
			}
			else if(prevair == 8)	/*  Generic air 1.  */
			{
			   if(costheta2 > COSTOL)
				region[icur].cumfs[5][whichview]
				 += (area/costheta2);
			}
			else if(prevair == 9)	/*  Generic air 2.  */
			{
			   if(costheta2 > COSTOL)
				region[icur].cumfs[6][whichview]
				 += (area/costheta2);
			}
		   }
		}
		/*  A ray entering from nothing.  */
		else if(pp->pt_regionp->reg_regionid != 0)
		{
		   /*  If the ray has previously hit another  */
		   /*  region this area must be taken into  */
		   /*  account.  */
		   if(iprev != -99)
		   {
			costheta2 = lnormal[X] * ap_p->a_ray.r_dir[X]
			          + lnormal[Y] * ap_p->a_ray.r_dir[Y]
			          + lnormal[Z] * ap_p->a_ray.r_dir[Z];
			if(costheta2 < 0.) costheta2 = (-costheta2);
			if(costheta2 > COSTOL)
			{
			   region[iprev].cumnorm[X] += lnormal[X] / costheta2;
			   region[iprev].cumnorm[Y] += lnormal[Y] / costheta2;
			   region[iprev].cumnorm[Z] += lnormal[Z] / costheta2;
			   region[iprev].cumfs[0][whichview]
				 += (area/costheta2);
			}
		   }

		   costheta2 = hitp->hit_normal[X] * ap_p->a_ray.r_dir[X]
		             + hitp->hit_normal[Y] * ap_p->a_ray.r_dir[Y]
		             + hitp->hit_normal[Z] * ap_p->a_ray.r_dir[Z];
		   if(costheta2 < 0.) costheta2=(-costheta2);
		   if(costheta2 > COSTOL)
		   {
			region[icur].cumnorm[X] += hitp-> hit_normal[X]
				/ costheta2;
		   	region[icur].cumnorm[Y] += hitp-> hit_normal[Y]
				/ costheta2;
		   	region[icur].cumnorm[Z] += hitp-> hit_normal[Z]
				/ costheta2;
			region[icur].cumfs[0][whichview] += (area/costheta2);
		   }
		}
		/*  A ray entering  a region from air.  */
		if((pp->pt_regionp->reg_regionid == 0) && (prevregid != 0))
		{
		   costheta2 = lnormal[X] * ap_p->a_ray.r_dir[X]
		             + lnormal[Y] * ap_p->a_ray.r_dir[Y]
		             + lnormal[Z] * ap_p->a_ray.r_dir[Z];
		   if(costheta2 < 0.) costheta2=(-costheta2);
		   if(pp->pt_regionp->reg_aircode == 1)
		   {
			if(costheta2 > COSTOL)
			{
			   region[iprev].cumnorm[X] += lnormal[X] / costheta2;
			   region[iprev].cumnorm[Y] += lnormal[Y] / costheta2;
			   region[iprev].cumnorm[Z] += lnormal[Z] / costheta2;
			   region[iprev].cumfs[0][whichview]
				 += (area/costheta2);
			}
		   }
		   else if(pp->pt_regionp->reg_aircode == 2)
		   {
			if(costheta2 > COSTOL)
			   region[iprev].cumfs[1][whichview]
				 += (area/costheta2);
		   }
		   else if(pp->pt_regionp->reg_aircode == 5)
		   {
			if(costheta2 > COSTOL)
			   region[iprev].cumfs[2][whichview]
				 += (area/costheta2);
		   }
		   else if(pp->pt_regionp->reg_aircode == 6)
		   {
			if(costheta2 > COSTOL)
			   region[iprev].cumfs[3][whichview]
				 += (area/costheta2);
		   }
		   else if(pp->pt_regionp->reg_aircode == 7)
		   {
			if(costheta2 > COSTOL)
			   region[iprev].cumfs[4][whichview]
				 += (area/costheta2);
		   }
		   else if(pp->pt_regionp->reg_aircode == 8)
		   {
			if(costheta2 > COSTOL)
			   region[iprev].cumfs[5][whichview]
				 += (area/costheta2);
		   }
		   else if(pp->pt_regionp->reg_aircode == 9)
		   {
			if(costheta2 > COSTOL)
			   region[iprev].cumfs[6][whichview]
				 += (area/costheta2);
		   }
		}

		/*  Curvature.  */
		RT_CURVATURE(&cur,hitp,pp->pt_inflip,stp);
		/*  Print out curvature information.  */
/*
 *		(void)printf("Principle direction of curvature:  ");
 *		(void)printf("(%f, %f, %f)\n",
 *			cur.crv_pdir[X],
 *			cur.crv_pdir[Y],
 *			cur.crv_pdir[Z]);
 *		(void)fflush(stdout);
 *		(void)printf("Inverse radii of curvature:  c1=%f, c2=%f\n",
 *			cur.crv_c1,
 *			cur.crv_c2);
 *		(void)fflush(stdout);
 */

		/*  Find normal and hit point of leaving ray.  */
/*
 *		(void)printf("Leaving Ray\n");
 *		(void)fflush(stdout);
 */
		hitp=pp->pt_outhit;
		stp=pp->pt_outseg->seg_stp;
		RT_HIT_NORM(hitp,stp,&(ap_p->a_ray));
		/*  Flip normal if needed.  */
		if(pp->pt_outflip)
		{
			VREVERSE(hitp->hit_normal,hitp->hit_normal);
			pp->pt_inflip=0;
		}

		/*  Find back surface area of regions. */
		costheta1 = hitp->hit_normal[X] * ap_p->a_ray.r_dir[X]
		          + hitp->hit_normal[Y] * ap_p->a_ray.r_dir[Y]
		          + hitp->hit_normal[Z] * ap_p->a_ray.r_dir[Z];
		if( costheta1 < 0 ) costheta1 = (-costheta1);
		if( costheta1 > COSTOL )
		   region[icur].surarea[whichview] += (area/costheta1);

		/*  Save normal of leaving ray.  */
/*
 *		lnormal[X]=hitp->hit_normal[X];
 *		lnormal[Y]=hitp->hit_normal[Y];
 *		lnormal[Z]=hitp->hit_normal[Z];
 */

		/*  Print out hit point & normal.  */
/*
 *		(void)printf("Hit Point (leaving):  (%f, %f, %f)\n",
 *			hitp->hit_point[X],
 *			hitp->hit_point[Y],
 *			hitp->hit_point[Z]);
 *		(void)fflush(stdout);
 *		(void)printf("Normal Point:  (%f, %f, %f)\n",
 *			hitp->hit_normal[X],
 *			hitp->hit_normal[Y],
 *			hitp->hit_normal[Z]);
 *		(void)fflush(stdout);
 */

		/*  Continue finding cummulative volume.  */
		disx=(enterpt[X] - hitp->hit_point[X]) * 
		   (enterpt[X] - hitp->hit_point[X]);
		disy=(enterpt[Y] - hitp->hit_point[Y]) * 
		   (enterpt[Y] - hitp->hit_point[Y]);
		disz=(enterpt[Z] - hitp->hit_point[Z]) * 
		   (enterpt[Z] - hitp->hit_point[Z]);
		distance=sqrt(disx + disy + disz);
		region[icur].cumvol[whichview] =
		   region[icur].cumvol[whichview] + (distance * area);

		/*  Find centroid.  */
		region[icur].centroid[X] += ( distance * area * (enterpt[X] +
		   hitp->hit_point[X]) / 2.);
		region[icur].centroid[Y] += ( distance * area * (enterpt[Y] +
		   hitp->hit_point[Y]) / 2.);
		region[icur].centroid[Z] += ( distance * area * (enterpt[Z] +
		   hitp->hit_point[Z]) / 2.);

		/*  Find the cummulative normal & free surface area  */
		/*  (exterior air)  when a ray is leaving the bounding  */
		/*  rpp.  */
		if((pp->pt_forw == PartHeadp) &&
		   (pp->pt_regionp->reg_regionid != 0))
		{
		   costheta2 = hitp->hit_normal[X] * ap_p->a_ray.r_dir[X]
		             + hitp->hit_normal[Y] * ap_p->a_ray.r_dir[Y]
		             + hitp->hit_normal[Z] * ap_p->a_ray.r_dir[Z];
		   if(costheta2 < 0.) costheta2=(-costheta2);
		   if(costheta2 > COSTOL)
		   {
		   	region[icur].cumnorm[X] += hitp->hit_normal[X]
				/ costheta2;
		   	region[icur].cumnorm[Y] += hitp->hit_normal[Y]
				/ costheta2;
		   	region[icur].cumnorm[Z] += hitp->hit_normal[Z]
				/ costheta2;
			region[icur].cumfs[0][whichview] += (area/costheta2);
		   }
		}

		iprev=icur;
		leavept[X]=hitp->hit_point[X];
		leavept[Y]=hitp->hit_point[Y];
		leavept[Z]=hitp->hit_point[Z];

		/*  Save normal of leaving ray.  */
		lnormal[X]=hitp->hit_normal[X];
		lnormal[Y]=hitp->hit_normal[Y];
		lnormal[Z]=hitp->hit_normal[Z];

		/*  Save the region id and air code.  */
		prevregid = pp->pt_regionp->reg_regionid;
		prevair = pp->pt_regionp->reg_aircode;
	}

	return (1);
}

int
miss(register struct application *ap_p)

/*  User supplied miss function.  */

                                  
{
/*
 *	(void)printf("It was a miss.\n");
 *	(void)fflush(stdout);
 */
	return (0);
}

int
ovrlap(register struct application *ap_p, struct partition *PartHeadp, struct region *reg1, struct region *reg2)

/*  User supplied overlap function.  */

                                  
                            
                          
{
	int a,b;
	double depth;

/*
 *	(void)printf("In ovrlap.  ");
 *	(void)fflush(stdout);
 *	(void)printf("%s & %s\n",reg1->reg_name,reg2->reg_name);
 *	(void)fflush(stdout);
 */

	a=(int)reg1->reg_bit;
	b=(int)reg2->reg_bit;

/*
 *	(void)printf("a=%d, b=%d.  ",a,b);
 *	(void)fflush(stdout);
 */

	/*  Enter region names incase they are never entered  */
	/*  anywhere else.  */
	region[a].regname = (char *)reg1->reg_name;
	region[b].regname = reg2->reg_name;

	overlaps[a].ovrreg[b] = 1;

/*
 *	(void)printf("ovrreg set to 1.  ");
 *	(void)fflush(stdout);
 */

	depth = PartHeadp->pt_outhit->hit_dist - PartHeadp->pt_inhit->hit_dist;

/*
 *	(void)printf("depth set to %f.  ",depth);
 *	(void)fflush(stdout);
 */

	if(depth > overlaps[a].ovrdep[b]) overlaps[a].ovrdep[b] = depth;

/*
 *	(void)printf("ovrdep set.\n");
 *	(void)fflush(stdout);
 */

	return(1);
}


@


11.11
log
@change conf.h to a wrapped config.h
@
text
@d52 1
a52 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/irprep/firpass.c,v 11.10 2004/04/05 07:47:44 morrison Exp $ (BRL)";
@


11.10
log
@merge of ansi-6-0-branch into HEAD
@
text
@d52 1
a52 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d55 5
a59 1
#include "conf.h"
@


11.9
log
@update copyright to include span through 2003
@
text
@d52 1
a52 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/irprep/firpass.c,v 11.8 2002/08/20 17:07:31 jra Exp $ (BRL)";
d83 5
a87 5
extern int hit();	/*  User supplied hit function.  */
extern int miss();	/*  User supplied miss function.  */
extern int ovrlap();	/*  User supplied overlap function.  */
extern void rotate();	/*  Subroutine to rotate a point.  */
extern double radians();/*  Subroutines to find angle in radians.  */
d135 1
a135 5
int main(argc,argv)

int argc;
char *argv[];

d2284 1
a2284 3
hit(ap_p,PartHeadp)
register struct application *ap_p;
struct partition *PartHeadp;
d2708 1
a2708 1
miss(ap_p)
d2712 1
a2712 1
register struct application *ap_p;
d2722 1
a2722 1
ovrlap(ap_p,PartHeadp,reg1,reg2)
d2726 3
a2728 3
register struct application *ap_p;
struct partition *PartHeadp;
struct region *reg1,*reg2;
@


11.8
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d12 1
a12 1
 *	This software is Copyright (C) 1990 by the United States Army.
d52 1
a52 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/irprep/firpass.c,v 11.6 2001/08/09 20:09:10 jra Exp $ (BRL)";
@


11.8.4.1
log
@sync to HEAD...
@
text
@d12 1
a12 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d52 1
a52 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/irprep/firpass.c,v 11.9 2004/02/02 17:39:06 morrison Exp $ (BRL)";
@


11.8.10.1
log
@merge from HEAD
@
text
@d12 1
a12 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d52 1
a52 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/irprep/firpass.c,v 11.9 2004/02/02 17:39:06 morrison Exp $ (BRL)";
@


11.8.10.2
log
@merge from head
@
text
@d52 1
a52 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/irprep/firpass.c,v 11.8.10.1 2004/02/12 19:50:38 erikg Exp $ (BRL)";
@


11.8.2.1
log
@Initial ANSIfication
@
text
@d52 1
a52 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/irprep/firpass.c,v 11.8 2002/08/20 17:07:31 jra Exp $ (BRL)";
d83 5
a87 5
extern int hit(register struct application *ap_p, struct partition *PartHeadp);	/*  User supplied hit function.  */
extern int miss(register struct application *ap_p);	/*  User supplied miss function.  */
extern int ovrlap(register struct application *ap_p, struct partition *PartHeadp, struct region *reg1, struct region *reg2);	/*  User supplied overlap function.  */
extern void rotate(double *p, double *a, double *np);	/*  Subroutine to rotate a point.  */
extern double radians(double a);/*  Subroutines to find angle in radians.  */
d135 5
a139 1
int main(int argc, char **argv)
d2288 3
a2290 1
hit(register struct application *ap_p, struct partition *PartHeadp)
d2714 1
a2714 1
miss(register struct application *ap_p)
d2718 1
a2718 1
                                  
d2728 1
a2728 1
ovrlap(register struct application *ap_p, struct partition *PartHeadp, struct region *reg1, struct region *reg2)
d2732 3
a2734 3
                                  
                            
                          
@


11.8.2.2
log
@sync branch with HEAD
@
text
@d12 1
a12 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d52 1
a52 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.7
log
@Converted from K&R to ANSI C - RFH
@
text
@d83 5
a87 5
extern int hit(register struct application *ap_p, struct partition *PartHeadp);	/*  User supplied hit function.  */
extern int miss(register struct application *ap_p);	/*  User supplied miss function.  */
extern int ovrlap(register struct application *ap_p, struct partition *PartHeadp, struct region *reg1, struct region *reg2);	/*  User supplied overlap function.  */
extern void rotate(double *p, double *a, double *np);	/*  Subroutine to rotate a point.  */
extern double radians(double a);/*  Subroutines to find angle in radians.  */
d135 5
a139 1
int main(int argc, char **argv)
d2288 3
a2290 1
hit(register struct application *ap_p, struct partition *PartHeadp)
d2714 1
a2714 1
miss(register struct application *ap_p)
d2718 1
a2718 1
                                  
d2728 1
a2728 1
ovrlap(register struct application *ap_p, struct partition *PartHeadp, struct region *reg1, struct region *reg2)
d2732 3
a2734 3
                                  
                            
                          
@


11.6
log
@lint
@
text
@d52 1
a52 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/irprep/firpass.c,v 11.5 2001/04/20 22:28:56 morrison Exp $ (BRL)";
d83 5
a87 5
extern int hit();	/*  User supplied hit function.  */
extern int miss();	/*  User supplied miss function.  */
extern int ovrlap();	/*  User supplied overlap function.  */
extern void rotate();	/*  Subroutine to rotate a point.  */
extern double radians();/*  Subroutines to find angle in radians.  */
d135 1
a135 5
int main(argc,argv)

int argc;
char *argv[];

d2284 1
a2284 3
hit(ap_p,PartHeadp)
register struct application *ap_p;
struct partition *PartHeadp;
d2708 1
a2708 1
miss(ap_p)
d2712 1
a2712 1
register struct application *ap_p;
d2722 1
a2722 1
ovrlap(ap_p,PartHeadp,reg1,reg2)
d2726 3
a2728 3
register struct application *ap_p;
struct partition *PartHeadp;
struct region *reg1,*reg2;
@


11.5
log
@CONST to const
@
text
@d52 1
a52 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/irprep/firpass.c,v 11.4 2000/09/06 20:08:49 mike Exp $ (BRL)";
d156 1
a156 1
	FILE *fp;		/*  used for writing output to file  */
d187 1
a187 1
	int facnum;		/*  facet number  */
@


11.4
log
@
lint
@
text
@d52 1
a52 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/irprep/firpass.c,v 11.3 2000/08/24 23:10:20 mike Exp $ (BRL)";
d92 1
a92 1
	CONST char *regname;		/*  region name  */
@


11.3
log
@
RCSid
@
text
@d52 1
a52 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/irprep/firpass.c,v 11.2 1996/07/18 14:21:27 jra Exp $ (BRL)";
d2287 1
a2287 1

d2713 1
d2727 1
@


11.2
log
@Minor Mods for IRIX 6.2
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: /m/cad/irprep/RCS/firpass.c,v 11.1 1995/01/04 10:22:40 mike Rel4_4 jra $ (BRL)";
@


11.1
log
@Release_4.4
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: /m/cad/irprep/RCS/firpass.c,v 10.7 94/12/12 22:17:50 mike Exp $ (BRL)";
d2595 1
a2595 1
		RT_CURVE(&cur,hitp,stp);
@


10.7
log
@Linux has PI in <math.h>
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: /m/cad/irprep/RCS/firpass.c,v 10.6 94/11/14 23:30:02 mike Exp Locker: mike $ (BRL)";
@


10.6
log
@Irix 6
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: /m/cad/irprep/RCS/firpass.c,v 10.5 94/08/24 18:10:53 gdurf Exp Locker: mike $ (BRL)";
a77 1
#define PI 3.14159265358979323846264	/*  Pi.  */
@


10.5
log
@Factored ifdefs
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: /m/cad/irprep/RCS/firpass.c,v 10.4 1993/02/11 10:13:05 scoates Exp gdurf $ (BRL)";
a2734 1
	register struct partition *pp;
@


10.4
log
@Put in option to fire from 3 orthogonal directions instead of
firing from one direction (may still fire in one direction
only).
@
text
@d52 1
a52 1
static char RCSid[] = "@@(#)$Header: /m/cad/irprep/RCS/firpass.c,v 1.6 91/07/15 23:19:10 butler Exp $ (BRL)";
d55 2
d59 1
a59 1
#ifdef SYSV
@


10.3
log
@Remove path name on include statements.
@
text
@d5 1
a5 1
 *	S.Coates - 10 March 1992
d48 2
d52 1
a52 1
static char RCSid[] = "@@(#)$Header: /m/cad/irprep/RCS/firpass.c,v 10.2 92/09/15 10:43:51 scoates Exp Locker: scoates $ (BRL)";
d98 1
a98 1
	double cumfs[7];	/*  cummulative surface area for */
d125 1
d244 4
d353 18
d501 3
a503 1
		   region[i].cumfs[k] = 0.;
d627 2
a628 2
	/*  Set up for shooting rays down the x axis (positive to  */
	/*  negative).  */
d630 1
a630 1
	(void)printf("\nSHOOTING DOWN X-AXIS\n");
d672 2
a673 2
		r[Y]=ymax - center[X] + 5.;
		r[Z]=zmax - center[X] + 5.;
d718 150
d894 1
d912 1
a912 1
		/*  Check for variance of volume.  */
d914 10
a923 1
		region[i].cumvol[1]=flag;
d925 49
a973 1
		/*  Check for variance of surface area.  */
d975 10
a984 1
		region[i].surarea[1]=flag;
d986 48
a1033 1
		/*  Check for variance of shared surface area.  */
d1048 70
a1117 1
			region[i].ssurarea[1][j] = flag;
d1121 56
d1233 1
a1233 1
		if(region[i].cumvol[1] == 1)
d1247 1
a1247 1
		if(region[i].surarea[1] == 1)
d1269 28
a1296 14
		(void)printf("\texterior surface air:  %f\n",
			region[i].cumfs[0]);
		(void)printf("\tcrew compartment air:  %f\n",
			region[i].cumfs[1]);
		(void)printf("\tengine compartment air:  %f\n",
			region[i].cumfs[2]);
		(void)printf("\tclosed compartment air:  %f\n",
			region[i].cumfs[3]);
		(void)printf("\texhaust air:  %f\n",
			region[i].cumfs[4]);
		(void)printf("\tgeneric air 1:  %f\n",
			region[i].cumfs[5]);
		(void)printf("\tgeneric air 2:  %f\n",
			region[i].cumfs[6]);
d1307 1
a1307 1
			if(region[i].ssurarea[1][j] == 1)
d1330 1
a1330 1
		if(region[i].cumvol[1] == 1)
d1344 1
a1344 1
		if(region[i].surarea[1] == 1)
d1367 28
a1394 14
		(void)fprintf(fp,"\texterior surface air:  %f\n",
			region[i].cumfs[0]);
		(void)fprintf(fp,"\tcrew compartment air:  %f\n",
			region[i].cumfs[1]);
		(void)fprintf(fp,"\tengine compartment air:  %f\n",
			region[i].cumfs[2]);
		(void)fprintf(fp,"\tclosed compartment air:  %f\n",
			region[i].cumfs[3]);
		(void)fprintf(fp,"\texhaust air:  %f\n",
			region[i].cumfs[4]);
		(void)fprintf(fp,"\tgeneric air 1:  %f\n",
			region[i].cumfs[5]);
		(void)fprintf(fp,"\tgeneric air 2:  %f\n",
			region[i].cumfs[6]);
d1405 1
a1405 1
			if(region[i].ssurarea[1][j] == 1)
d1534 1
a1534 1
		facarea = region[i].cumfs[0] * (1.e-6);
d1626 2
a1627 2
		if(region[i].cumfs[2] > ZEROTOL)
			facradius = region[i].cumfs[2] * (1.e-6);
d1732 1
a1732 1
		if(region[i].cumfs[0] > ZEROTOL) numext = 1;
d1736 6
a1741 6
		if(region[i].cumfs[1] > ZEROTOL) numint += 1;
		if(region[i].cumfs[2] > ZEROTOL) numint += 1;
		if(region[i].cumfs[3] > ZEROTOL) numint += 1;
		if(region[i].cumfs[4] > ZEROTOL) numint += 1;
		if(region[i].cumfs[5] > ZEROTOL) numint += 1;
		if(region[i].cumfs[6] > ZEROTOL) numint += 1;
d1749 1
a1749 1
		   (void)fprintf(fp5,"  %.3e\n",(region[i].cumfs[0]*1.e-6));
d1754 1
a1754 1
		   if(region[i].cumfs[1] > ZEROTOL)
d1756 2
a1757 1
			(void)fprintf(fp5,"  %.3e",(region[i].cumfs[1]*1.e-6));
d1759 1
a1759 1
		   if(region[i].cumfs[2] > ZEROTOL)
d1761 2
a1762 1
			(void)fprintf(fp5," %.3e",(region[i].cumfs[2]*1.e-6));
d1764 1
a1764 1
		   if(region[i].cumfs[3] > ZEROTOL)
d1766 2
a1767 1
			(void)fprintf(fp5," %.3e",(region[i].cumfs[3]*1.e-6));
d1769 1
a1769 1
		   if(region[i].cumfs[4] > ZEROTOL)
d1771 2
a1772 1
			(void)fprintf(fp5," %.3e",(region[i].cumfs[4]*1.e-6));
d1774 1
a1774 1
		   if(region[i].cumfs[5] > ZEROTOL)
d1776 2
a1777 1
			(void)fprintf(fp5," %.3e",(region[i].cumfs[5]*1.e-6));
d1779 1
a1779 1
		   if(region[i].cumfs[6] > ZEROTOL)
d1781 2
a1782 1
			(void)fprintf(fp5," %.3e",(region[i].cumfs[6]*1.e-6));
d1793 1
a1793 1
		if(region[1].cumfs[0] > ZEROTOL) numsol = 1;
d1802 1
a1802 1
			(region[i].cumfs[0]*1.e-6),region[i].cumnorm[X],
d1918 3
a1920 3
			(i+1),(region[i].cumfs[0]*1.e-6),
			(region[i].cumfs[2]*1.e-6),
			(region[i].cumfs[1]*1.e-6));
d1922 4
a1925 4
			(region[i].cumfs[3]*1.e-6),
			(region[i].cumfs[4]*1.e-6),
			(region[i].cumfs[5]*1.e-6),
			(region[i].cumfs[6]*1.e-6));
d2019 3
a2021 2
			(region[i].cumfs[0]*1.e-6),(region[i].cumfs[1]*1.e-6),
			(region[i].cumfs[2]*1.e-6));
d2023 4
a2026 4
			(region[i].cumfs[3]*1.e-6),
			(region[i].cumfs[4]*1.e-6),
			(region[i].cumfs[5]*1.e-6),
			(region[i].cumfs[6]*1.e-6));
d2119 1
a2119 1
		(void)fprintf(fp3,"region %d:  ",i);
d2127 1
a2127 1
		(void)fprintf(fp3,"region %d:  large variance ",i);
d2138 1
a2138 1
			i,j);
d2144 43
d2458 2
a2459 1
				region[icur].cumfs[0] += (area/costheta2);
d2465 2
a2466 1
				region[icur].cumfs[1] += (area/costheta2);
d2471 2
a2472 1
				region[icur].cumfs[2] += (area/costheta2);
d2477 2
a2478 1
				region[icur].cumfs[3] += (area/costheta2);
d2483 2
a2484 1
				region[icur].cumfs[4] += (area/costheta2);
d2489 2
a2490 1
				region[icur].cumfs[5] += (area/costheta2);
d2495 2
a2496 1
				region[icur].cumfs[6] += (area/costheta2);
d2517 2
a2518 1
			   region[iprev].cumfs[0] += (area/costheta2);
d2534 1
a2534 1
			region[icur].cumfs[0] += (area/costheta2);
d2551 2
a2552 1
			   region[iprev].cumfs[0] += (area/costheta2);
d2558 2
a2559 1
			   region[iprev].cumfs[1] += (area/costheta2);
d2564 2
a2565 1
			   region[iprev].cumfs[2] += (area/costheta2);
d2570 2
a2571 1
			   region[iprev].cumfs[3] += (area/costheta2);
d2576 2
a2577 1
			   region[iprev].cumfs[4] += (area/costheta2);
d2582 2
a2583 1
			   region[iprev].cumfs[5] += (area/costheta2);
d2588 2
a2589 1
			   region[iprev].cumfs[6] += (area/costheta2);
d2690 1
a2690 1
			region[icur].cumfs[0] += (area/costheta2);
@


10.2
log
@New version of firpass.c.  Changes include creation of region # & name
file, region numbering consistant across all files, engine air printed
in radius field of facet file, choice of PRISM 2.0 or 3.0 format,
additional air types (6-closed compartment air, 7-exhaust air, 8-generic
air 1, 9-generic air 2), additional line added to PRISM facet file for
compatability, & write out total surface area in PRISM facet file when
there is no exterior surface area.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/irprep/RCS/firpass.c,v 1.6 91/07/15 23:19:10 butler Exp $ (BRL)";
d61 4
a64 4
#include "/n/walrus/usr/brlcad/include/machine.h"
#include "/n/walrus/usr/brlcad/include/externs.h"
#include "/n/walrus/usr/brlcad/include/vmath.h"
#include "/n/walrus/usr/brlcad/include/raytrace.h"
@


10.1
log
@Release_4.0
@
text
@d5 1
a5 1
 *	S.Coates - 8 July 1991
d27 21
d61 4
a64 4
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
d96 1
a96 1
	double cumfs[3];	/*  cummulative surface area for */
d99 11
a109 1
				/*  compartment air  */
d137 1
a137 1
	int i,j,ii;	/*  variables used in loops  */
d169 2
d240 1
d279 6
d306 10
d474 4
a477 3
		region[i].cumfs[0]=0.;
		region[i].cumfs[1]=0.;
		region[i].cumfs[2]=0.;
d765 6
a770 4
		(void)printf("Normal before normalizing\n");
		(void)printf("  %f, %f, %f\n",region[i].cumnorm[X],
			region[i].cumnorm[Y],region[i].cumnorm[Z]);
		(void)fflush(stdout);
d812 2
a813 1
		(void)printf("region #:  %d, name:  %s\n",i,region[i].regname);
d859 8
d872 2
a873 1
			(void)printf("\tadjreg[%d]=%d, ",j,region[i].adjreg[j]);
d897 1
a897 1
		   i,region[i].regname);
d943 8
d957 1
a957 1
			   j,region[i].adjreg[j]);
d997 7
a1003 2
	if( typeout == 0 ) (void)fprintf(fp,
	   "\tfacet file created:  %s\n",facfile);
d1006 1
a1006 1
	if( typeout == 2 ) (void)fprintf(fp,
d1013 9
d1031 2
a1032 1
	/*  Print header information for facedt file.  */
d1089 1
a1089 2
		/*  exterior surface area (sq meters).  If exterior  */
		/*  surface area is 0 print engine compartment area.  */
d1091 24
a1114 2
		if( (-ZEROTOL < facarea) && (facarea < ZEROTOL) )
		   facarea = region[i].cumfs[2] * (1.e-6);
d1178 3
a1180 1
		/*  Hub radius (m).  Currently set to 0.  */
d1182 2
d1195 2
a1196 1
		(void)fprintf(fp1,"%3d %.25s%3d%8.3f%8.3f%8.3f",
d1198 3
d1213 7
d1294 4
d1318 16
d1383 4
a1386 1
	   /*		closed compartment surface area (m**2)  */
d1456 3
a1458 1
	   (void)fprintf(fp6,"crew sur      closed compartment\n");
d1460 3
a1462 1
	   (void)fprintf(fp6,"area (m**2)   sur area (m**2)\n");
d1467 1
a1467 1
		(void)fprintf(fp6,"%6d   %.3e      %.3e     %.3e    \n",
d1471 5
d1496 1
a1496 1
		(void)fprintf(fp6,"    %s\n",matprop[ia].m);
d1525 3
d1571 5
d1627 1
a1627 1
		   i,region[i].centroid[0],region[i].centroid[1],
d1636 1
a1636 1
		      j,spsarea);
d1651 12
d1732 1
a1732 1
	   (void)fprintf(fp3,"        %5d                          ",i);
d1756 6
a1761 2
	if( typeout == 0 ) (void)printf(
	   "\tfacet file created:  %s\n\n\n",facfile);
d1764 1
a1764 1
	if( typeout == 2 ) (void)printf(
d1894 1
a1894 1
			/*  a region will semm to be adjacent to self,  */
d1937 2
a1938 2
		/*  & engine compartment area when ray enters  */
		/*  from another region.  */
d1977 20
d2061 20
@


1.6
log
@misc portability changes.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/irprep/RCS/firpass.c,v 1.5 91/07/11 22:10:46 butler Exp $ (BRL)";
@


1.5
log
@version after Sue Coates finished with lint.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/irprep/RCS/firpass.c,v 1.4 91/07/02 23:39:59 butler Exp $ (BRL)";
d1615 2
a1616 2
hit(ap,PartHeadp)
register struct application *ap;
d1689 1
a1689 1
		RT_HIT_NORM(hitp,stp,&(ap->a_ray));
d1698 3
a1700 3
		costheta1 = hitp->hit_normal[X] * ap->a_ray.r_dir[X]
		          + hitp->hit_normal[Y] * ap->a_ray.r_dir[Y]
		          + hitp->hit_normal[Z] * ap->a_ray.r_dir[Z];
d1725 3
a1727 3
			costheta = lnormal[X]*ap->a_ray.r_dir[X]
			          + lnormal[Y]*ap->a_ray.r_dir[Y]
			          + lnormal[Z]*ap->a_ray.r_dir[Z];
d1772 3
a1774 3
			costheta2 = hitp->hit_normal[X] * ap->a_ray.r_dir[X]
			          + hitp->hit_normal[Y] * ap->a_ray.r_dir[Y]
			          + hitp->hit_normal[Z] * ap->a_ray.r_dir[Z];
d1809 3
a1811 3
			costheta2 = lnormal[X] * ap->a_ray.r_dir[X]
			          + lnormal[Y] * ap->a_ray.r_dir[Y]
			          + lnormal[Z] * ap->a_ray.r_dir[Z];
d1822 3
a1824 3
		   costheta2 = hitp->hit_normal[X] * ap->a_ray.r_dir[X]
		             + hitp->hit_normal[Y] * ap->a_ray.r_dir[Y]
		             + hitp->hit_normal[Z] * ap->a_ray.r_dir[Z];
d1840 3
a1842 3
		   costheta2 = lnormal[X] * ap->a_ray.r_dir[X]
		             + lnormal[Y] * ap->a_ray.r_dir[Y]
		             + lnormal[Z] * ap->a_ray.r_dir[Z];
d1889 1
a1889 1
		RT_HIT_NORM(hitp,stp,&(ap->a_ray));
d1898 3
a1900 3
		costheta1 = hitp->hit_normal[X] * ap->a_ray.r_dir[X]
		          + hitp->hit_normal[Y] * ap->a_ray.r_dir[Y]
		          + hitp->hit_normal[Z] * ap->a_ray.r_dir[Z];
d1951 3
a1953 3
		   costheta2 = hitp->hit_normal[X] * ap->a_ray.r_dir[X]
		             + hitp->hit_normal[Y] * ap->a_ray.r_dir[Y]
		             + hitp->hit_normal[Z] * ap->a_ray.r_dir[Z];
d1985 1
a1985 1
miss(ap)
d1989 1
a1989 1
register struct application *ap;
d1998 1
a1998 1
ovrlap(ap,PartHeadp,reg1,reg2)
d2002 1
a2002 1
register struct application *ap;
@


1.4
log
@made application local copies of region name CONST pointers.
@
text
@d5 1
a5 1
 *	S.Coates - 13 March 1991
d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/irprep/RCS/firpass.c,v 1.3 91/07/01 23:39:24 mike Exp $ (BRL)";
a98 1
double newx,newy,newz;		/*  Point after it has been rotated back.  */
d100 1
a100 1
main(argc,argv)
d106 1
a106 1
	int i,j,ii,jj;	/*  variables used in loops  */
a118 4
	double smallest;	/*  used in checking variance, finds  */
				/*  smallest occurance  */
	double checkvar;	/*  variance allowed  */
	double checkdiff;	/*  actual difference  */
d221 2
a222 2
	fflush(stdout);
	scanf("%d",&iwrite);
d228 2
a229 2
	  fflush(stdout);
	  scanf("%s",filename);
d236 2
a237 2
	fflush(stdout);
	scanf("%s",fileerr);
d242 2
a243 2
	fflush(stdout);
	scanf("%s",spfile);
d248 2
a249 2
	fflush(stdout);
	scanf("%s",fileden);
d264 2
a265 2
	   fflush(stdout);
	   scanf("%s",facfile);
d273 2
a274 2
	   fflush(stdout);
	   scanf("%s",filegen);
d287 2
a288 2
	   fflush(stdout);
	   scanf("%s",filegeo);
d300 1
a300 1
 *	fflush(stdout);
d333 1
a333 1
 *		fflush(stdout);
d337 1
a337 1
	fclose(fp4);
d341 1
a341 1
	fflush(stdout);
d345 1
a345 1
	  fflush(fp);
d350 1
a350 1
	fflush(stdout);
d354 1
a354 1
		fflush(fp);
d361 1
a361 1
	fflush(stdout);
d365 1
a365 1
	  fflush(fp);
d383 1
a383 1
 *	fflush(stdout);
d393 2
a394 2
	region = malloc(num * sizeof (*region) );
	overlaps = malloc(num * sizeof (*overlaps) );
d398 4
a401 4
		region[i].adjreg = malloc(num * sizeof (int) );
		region[i].ssurarea[0] = malloc(num * sizeof (double) );
		region[i].ssurarea[1] = malloc(num * sizeof (double) );
		region[i].ssurarea[2] = malloc(num * sizeof (double) );
d403 2
a404 2
		overlaps[i].ovrreg = malloc(num * sizeof (int) );
		overlaps[i].ovrdep = malloc(num * sizeof (double) );
d491 1
a491 1
	fflush(stdout);
d496 1
a496 1
	fflush(stdout);
d504 1
a504 1
	  fflush(fp);
d509 2
a510 2
	fflush(stdout);
	scanf("%lf",&gridspace);
d514 2
a515 2
	  (void)printf("grid spacing:  %lf\n",gridspace);
	  fflush(stdout);
d519 2
a520 2
	  (void)fprintf(fp,"grid spacing:  %lf,  ",gridspace);
	  fflush(fp);
d528 1
a528 1
	  fflush(stdout);
d533 1
a533 1
	  fflush(fp);
d553 1
a553 1
	fflush(stdout);
d574 1
a574 1
	rotate(t,angle,r);
d582 1
a582 1
	rotate(strtdir,angle,r);
d598 1
a598 1
		rotate(r,angle,t);
d633 1
a633 1
		rotate(t,angle,r);
d643 1
a643 1
	  fflush(stdout);
d648 1
a648 1
	  fflush(fp);
d662 1
a662 1
 *		fflush(stdout);
d668 1
a668 1
 *		fflush(stdout);
d703 1
a703 1
 *			fflush(stdout);
d755 1
a755 1
	fflush(stdout);
d761 1
a761 1
		fflush(stdout);
d768 1
a768 1
		   fflush(stdout);
d774 1
a774 1
		   fflush(stdout);
d782 1
a782 1
		   fflush(stdout);
d788 1
a788 1
		   fflush(stdout);
d793 1
a793 1
		fflush(stdout);
d798 1
a798 1
		fflush(stdout);
d805 1
a805 1
		fflush(stdout);
d813 1
a813 1
			fflush(stdout);
d818 1
a818 1
			   fflush(stdout);
d823 1
a823 1
			   fflush(stdout);
d842 1
a842 1
		   fflush(fp);
d848 1
a848 1
		   fflush(fp);
d856 1
a856 1
		   fflush(fp);
d862 1
a862 1
		   fflush(fp);
d868 1
a868 1
		fflush(fp);
d873 1
a873 1
		fflush(fp);
d880 1
a880 1
		fflush(fp);
d889 1
a889 1
			fflush(fp);
d895 1
a895 1
			   fflush(fp);
d900 1
a900 1
			   fflush(fp);
d911 1
a911 1
	fflush(fp);
d916 1
a916 1
	   fflush(fp);
d932 1
a932 1
	fflush(fp);
d934 1
a934 1
	fclose(fp); }
d944 1
a944 1
	fflush(fp1);
d950 1
a950 1
	fflush(fp1);
d953 1
a953 1
	fflush(fp1);
d965 1
a965 1
 *		fflush(stdout);
d992 1
a992 1
 *		fflush(stdout);
d999 1
a999 1
 *		fflush(stdout);
d1010 1
a1010 1
 *		fflush(stdout);
d1022 1
a1022 1
 *		fflush(stdout);
d1039 1
a1039 1
 *		fflush(stdout);
d1064 1
a1064 1
 *		fflush (stdout);
d1080 1
a1080 1
 *		fflush(stdout);
d1088 1
a1088 1
		fflush(fp1);
d1094 1
a1094 1
		fflush(fp1);
d1099 1
a1099 1
	fclose(fp1);
d1218 1
a1218 1
	   fclose(fp5);
d1446 1
a1446 1
	   fclose(fp6);
d1457 1
a1457 1
	fflush(fp2);
d1467 1
a1467 1
		fflush(fp2);
d1475 1
a1475 1
		   fflush(fp2);
d1480 1
a1480 1
	fclose(fp2);
d1489 1
a1489 1
	fflush(fp3);
d1497 1
a1497 1
		fflush(fp3);
d1505 1
a1505 1
		fflush(fp3);
d1516 1
a1516 1
		   fflush(fp3);
d1523 1
a1523 1
	fflush(fp3);
d1533 1
a1533 1
		   fflush(fp3);
d1537 1
a1537 1
			fflush(fp3);
d1542 1
a1542 1
			fflush(fp3);
d1550 1
a1550 1
	fflush(fp3);
d1560 1
a1560 1
	   fflush(fp3);
d1567 1
a1567 1
	fflush(stdout);
d1572 1
a1572 1
	   fflush(stdout);
d1588 1
a1588 1
	fflush(stdout);
d1591 1
a1591 1
	fclose(fp3);
d1611 1
a1624 2
	int index;
	int i;
d1635 4
d1647 1
a1647 1
 *		fflush(stdout);
d1650 1
a1650 1
 *		fflush(stdout);
d1657 1
a1657 1
 *		fflush(stdout);
d1663 1
a1663 1
 *		fflush(stdout);
d1668 1
a1668 1
 *		fflush(stdout);
d1676 1
a1676 1
 *		fflush(stdout);
d1685 1
a1685 1
 *		fflush(stdout);
d1749 1
a1749 1
 *		fflush(stdout);
d1754 1
a1754 1
 *		fflush(stdout);
d1875 1
a1875 1
 *		fflush(stdout);
d1879 1
a1879 1
 *		fflush(stdout);
d1885 1
a1885 1
 *		fflush(stdout);
d1918 1
a1918 1
 *		fflush(stdout);
d1923 1
a1923 1
 *		fflush(stdout);
d1993 1
a1993 1
 *	fflush(stdout);
d2012 1
a2012 1
 *	fflush(stdout);
d2014 1
a2014 1
 *	fflush(stdout);
d2022 1
a2022 1
 *	fflush(stdout);
d2034 1
a2034 1
 *	fflush(stdout);
d2041 1
a2041 1
 *	fflush(stdout);
d2048 1
a2048 1
 *	fflush(stdout);
@


1.3
log
@Added BRL-CAD Headers
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d68 1
a68 1
	char *regname;		/*  region name  */
d1673 1
a1673 1
		region[icur].regname = pp->pt_regionp->reg_name;
d2029 1
a2029 1
	region[a].regname = reg1->reg_name;
@


1.2
log
@Minor fixes
@
text
@d1 19
a20 5
/*  File:  firpass.c  */
/*  S.Coates - 13 March 1991  */
/*  This version ONLY shoots down the x-axis.  */
/*  This version rotates the starting point and directions.  */

d27 4
@


1.1
log
@Initial revision
@
text
@a14 2
#include <stdlib.h>
#include <string.h>
d16 5
a21 2
/*  The following are needed when using rt_shootray.  */

d23 1
d86 1
a86 1
char **argv[];
d108 1
a108 1
	FILE *fp,*fopen();	/*  used for writing output to file  */
d117 1
a117 1
	FILE *fp3,*fopen();	/*  used for error file  */
d119 1
a119 1
	FILE *fp4,*fopen();	/*  used for reading material id file  */
d121 1
a121 1
	FILE *fp5,*fopen();	/*  used for creating generic file  */
d123 1
a123 1
	FILE *fp6,*fopen();	/*  used for creating gemetric file  */
d135 1
a135 1
	FILE *fp1,*fopen();	/*  facet grouping file  */
d177 1
a177 1
	FILE *fp2,*fopen();	/*  second pass file  */
@
