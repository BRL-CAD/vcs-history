head	1.37;
access;
symbols
	ansi-20040405-merged:1.35.2.1
	postmerge-20040405-ansi:1.36
	premerge-20040404-ansi:1.35
	postmerge-autoconf:1.35
	autoconf-freeze:1.35
	premerge-autoconf:1.35
	postmerge-20040315-windows:1.35
	premerge-20040315-windows:1.35
	windows-20040315-freeze:1.35
	autoconf-20031203:1.35
	autoconf-20031202:1.35
	autoconf-branch:1.35.0.10
	phong-branch:1.35.0.8
	photonmap-branch:1.35.0.6
	rel-6-1-DP:1.35
	windows-branch:1.35.0.4
	rel-6-0-2:1.33
	ansi-branch:1.35.0.2
	rel-6-0-1-branch:1.33.0.2
	hartley-6-0-post:1.34
	hartley-6-0-pre:1.33
	rel-6-0-1:1.33
	rel-6-0:1.33
	rel-5-4:1.31
	offsite-5-3-pre:1.31
	rel-5-3:1.31
	rel-5-2:1.31
	rel-5-1-branch:1.31.0.2
	rel-5-1:1.31
	rel-5-0:1.29
	rel-5-0-beta:1.26
	rel-4-5:1.12
	ctj-4-5-post:1.12
	ctj-4-5-pre:1.12;
locks; strict;
comment	@ * @;


1.37
date	2004.05.21.17.30.52;	author morrison;	state dead;
branches;
next	1.36;

1.36
date	2004.04.05.05.45.59;	author morrison;	state Exp;
branches;
next	1.35;

1.35
date	2002.08.20.17.08.41;	author jra;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2002.08.15.20.55.52;	author hartley;	state Exp;
branches;
next	1.33;

1.33
date	2001.07.09.19.21.32;	author butler;	state Exp;
branches;
next	1.32;

1.32
date	2001.04.20.22.31.21;	author morrison;	state Exp;
branches;
next	1.31;

1.31
date	2000.01.19.21.16.49;	author mike;	state Exp;
branches;
next	1.30;

1.30
date	99.12.05.19.35.27;	author mike;	state Exp;
branches;
next	1.29;

1.29
date	99.07.08.01.10.11;	author mike;	state Exp;
branches;
next	1.28;

1.28
date	99.07.01.21.06.25;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	99.07.01.20.47.00;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	98.12.12.07.22.02;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	98.11.26.03.44.15;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	98.11.26.01.06.28;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	98.11.19.06.20.31;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	98.10.09.21.45.25;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	98.10.09.21.32.14;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	98.10.09.21.17.28;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	98.10.09.05.52.30;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	98.10.09.02.19.05;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	98.10.07.22.28.57;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	98.10.07.07.49.56;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	98.10.07.07.37.11;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	98.09.30.04.31.49;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	98.09.30.02.22.18;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	96.04.06.04.30.54;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	96.04.06.01.09.12;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	96.03.16.00.52.32;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	96.03.14.07.25.02;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	96.03.14.04.58.40;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	96.03.09.05.37.45;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	96.03.09.03.21.08;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	96.03.09.01.01.01;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	96.03.09.00.50.42;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	96.03.08.05.53.35;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	96.03.08.03.04.09;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	96.03.01.06.03.46;	author mike;	state Exp;
branches;
next	;

1.35.2.1
date	2002.09.19.18.02.18;	author morrison;	state Exp;
branches;
next	;


desc
@Thermal display program
@


1.37
log
@moved to src/rttherm/
@
text
@/*
 *			S S A M P V I E W . C
 *
 *  Program to display spectral curves on the framebuffer.
 *  Uses a Tcl script to handle the GUI.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/rttherm/ssampview.c,v 1.36 2004/04/05 05:45:59 morrison Exp $ (ARL)";
#endif

#include <stdio.h>
#include <math.h>

#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "spectrum.h"
#include "fb.h"
#include "tcl.h"
#include "tk.h"

extern void
rt_spect_curve_to_xyz(
		      point_t			xyz,
		      const struct bn_tabdata	*tabp,
		      const struct bn_tabdata	*cie_x,
		      const struct bn_tabdata	*cie_y,
		      const struct bn_tabdata	*cie_z);

extern void
rt_spect_make_NTSC_RGB(struct bn_tabdata		**rp,
		       struct bn_tabdata		**gp,
		       struct bn_tabdata		**bp,
		       const struct bn_table		*tabp);


extern void
rt_make_ntsc_xyz2rgb( mat_t	xyz2rgb );


int	width = 64;				/* Linked with TCL */
int	height = 64;				/* Linked with TCL */
int	nwave = 2;				/* Linked with TCL */

char	*basename = "mtherm";
char	spectrum_name[100];

FBIO	*fbp;

struct bn_table		*spectrum;

struct bn_tabdata	*data;

struct bn_tabdata	*atmosphere_orig;
struct bn_tabdata	*atmosphere;
int			use_atmosphere = 0;	/* Linked with TCL */

struct bn_tabdata	*cie_x;
struct bn_tabdata	*cie_y;
struct bn_tabdata	*cie_z;
int			use_cie_xyz = 0;	/* Linked with TCL */
mat_t			xyz2rgb;
/* mat_t			rgb2xyz; */

struct bn_tabdata	*ntsc_r;
struct bn_tabdata	*ntsc_g;
struct bn_tabdata	*ntsc_b;

unsigned char	*pixels;		/* en-route to framebuffer */

fastf_t	maxval, minval;				/* Linked with TCL */

Tcl_Interp	*interp;
Tk_Window	tkwin;

int	doit(ClientData cd, Tcl_Interp *interp, int argc, char **argv), doit1(ClientData cd, Tcl_Interp *interp, int argc, char **argv);
void	find_minmax(void);
void	rescale(BU_ARGS(int wav));
void	show_color(BU_ARGS(int off));

char			*first_command = "no_command?";

/*
 *		A S S I G N _ T A B D A T A _ T O _ T C L _ V A R
 *
 *  Assign the given "C" bn_tabdata structure to the named Tcl variable,
 *  and add the name of that variable to the Tcl result string.
 */
void
assign_tabdata_to_tcl_var(Tcl_Interp *interp, const char *name, const struct bn_tabdata *tabp)
{
	struct bu_vls	str;

	BN_CK_TABDATA(tabp);

	bu_vls_init(&str);

	bn_tabdata_to_tcl(&str, tabp);
	Tcl_SetVar( interp, (char *)name, bu_vls_addr(&str), 0 );
	Tcl_AppendResult( interp, name, " ", (char *)NULL );

	bu_vls_free(&str);
}

/*
 *  Temporary testing function
 *  Takes no args, sets three Tcl variables, ntsc_r, ntsc_g, ntsc_b
 */
int
getntsccurves(ClientData cd, Tcl_Interp *interp, int argc, char **argv)
{
	extern struct bn_tabdata *rt_NTSC_r_tabdata;
	extern struct bn_tabdata *rt_NTSC_g_tabdata;
	extern struct bn_tabdata *rt_NTSC_b_tabdata;

	/* These are the curves as sampled to our spectrum intervals */
	assign_tabdata_to_tcl_var( interp, "ntsc_r_samp", ntsc_r );
	assign_tabdata_to_tcl_var( interp, "ntsc_g_samp", ntsc_g );
	assign_tabdata_to_tcl_var( interp, "ntsc_b_samp", ntsc_b );

#if 0
	/* These are the curves from the data tables in the library */
	assign_tabdata_to_tcl_var( interp, "ntsc_r_orig", rt_NTSC_r_tabdata );
	assign_tabdata_to_tcl_var( interp, "ntsc_g_orig", rt_NTSC_g_tabdata );
	assign_tabdata_to_tcl_var( interp, "ntsc_b_orig", rt_NTSC_b_tabdata );
#endif

	/* Sum togther the sampled curves */
	{
		struct bn_tabdata	*sum;
		BN_GET_TABDATA( sum, ntsc_r->table );
		bn_tabdata_add( sum, ntsc_r, ntsc_g );
		bn_tabdata_add( sum, sum, ntsc_b );
		assign_tabdata_to_tcl_var( interp, "ntsc_sum", sum );
		bn_tabdata_free( sum );
	}

#if 0
	/* Check out the RGB to spectrum curves */
	{
		struct bn_tabdata	*r, *g, *b, *sum;
		point_t		rgb;

		BN_GET_TABDATA( r, ntsc_r->table );
		BN_GET_TABDATA( g, ntsc_r->table );
		BN_GET_TABDATA( b, ntsc_r->table );
		BN_GET_TABDATA( sum, ntsc_r->table );

		VSET( rgb, 1, 0, 0 );
		rt_spect_reflectance_rgb( r, rgb );
		assign_tabdata_to_tcl_var( interp, "reflectance_r", r );

		VSET( rgb, 0, 1, 0 );
		rt_spect_reflectance_rgb( g, rgb );
		assign_tabdata_to_tcl_var( interp, "reflectance_g", g );

		VSET( rgb, 0, 0, 1 );
		rt_spect_reflectance_rgb( b, rgb );
		assign_tabdata_to_tcl_var( interp, "reflectance_b", b );

		bn_tabdata_add( sum, r, g );
		bn_tabdata_add( sum, sum, b );
		assign_tabdata_to_tcl_var( interp, "reflectance_sum", sum );

		bn_tabdata_free( r );
		bn_tabdata_free( g );
		bn_tabdata_free( b );
		bn_tabdata_free( sum );
	}
#endif

	/* Check out the black body curves */
	{
		struct bn_tabdata	*a, *b, *c;

		BN_GET_TABDATA( a, ntsc_r->table );
		BN_GET_TABDATA( b, ntsc_r->table );
		BN_GET_TABDATA( c, ntsc_r->table );

		rt_spect_black_body_fast( a, 5000.0 );
		assign_tabdata_to_tcl_var( interp, "a_5000", a );

		rt_spect_black_body_fast( b, 6500.0 );
		assign_tabdata_to_tcl_var( interp, "b_6500", b );

		rt_spect_black_body_fast( c, 10000.0 );
		assign_tabdata_to_tcl_var( interp, "c_10000", c );

		bn_tabdata_free( a );
		bn_tabdata_free( b );
		bn_tabdata_free( c );
	}

	return TCL_OK;
}

/*
 *
 *  With no args, returns the number of wavelengths.
 *  With an integer arg, returns the i-th wavelength.
 *
 *  spectrum pointer should be an arg, not implicit.
 */
int
getspectrum(ClientData cd, Tcl_Interp *interp, int argc, char **argv)
{
	int	wl;

	BN_CK_TABLE(spectrum);

	if( argc <= 1 )  {
		sprintf( interp->result, "%d", spectrum->nx );
		return TCL_OK;
	}
	if( argc != 2 )  {
		interp->result = "Usage: getspectrum [wl]";
		return TCL_ERROR;
	}
	wl = atoi(argv[2]);

	if( wl < 0 || wl > spectrum->nx )  {
		sprintf( interp->result, "getspectrum: wavelength %d out of range 0..%d",
			wl, spectrum->nx);
		return TCL_ERROR;
	}
	sprintf( interp->result, "%g", spectrum->x[wl] );
	return TCL_OK;
}

int
getspectval(ClientData cd, Tcl_Interp *interp, int argc, char **argv)
{
	struct bn_tabdata	*sp;
	int	x, y, wl;
	char	*cp;
	fastf_t	val;

	if( argc != 4 )  {
		interp->result = "Usage: getspect x y wl";
		return TCL_ERROR;
	}
	x = atoi(argv[1]);
	y = atoi(argv[2]);
	wl = atoi(argv[3]);

	BN_CK_TABLE(spectrum);

	if( x < 0 || x >= width )  {
		interp->result = "x out of range";
		return TCL_ERROR;
	}
	if( y < 0 || y >= height )  {
		interp->result = "y out of range";
		return TCL_ERROR;
	}
	if( wl < 0 || wl >= spectrum->nx )  {
		interp->result = "wavelength index out of range";
		return TCL_ERROR;
	}

	if( !data )  {
		interp->result = "pixel data table not loaded yet";
		return TCL_ERROR;
	}

	cp = (char *)data;
	cp = cp + (y * width + x) * BN_SIZEOF_TABDATA(spectrum);
	sp = (struct bn_tabdata *)cp;
	BN_CK_TABDATA(sp);
	val = sp->y[wl];
	if( use_atmosphere )
		val *= atmosphere->y[wl];
	sprintf( interp->result, "%g", val );
	return TCL_OK;
}

/*
 *			G E T S P E C T X Y
 *
 *  Given the x,y coordinates of a pixel in the multi-spectral image,
 *  return the spectral data found there in Tcl string form.
 */
int
getspectxy(ClientData cd, Tcl_Interp *interp, int argc, char **argv)
{
	struct bn_tabdata	*sp;
	int	x, y;
	char	*cp;
	struct bu_vls	str;

	if( argc != 3 )  {
		interp->result = "Usage: getspectxy x y";
		return TCL_ERROR;
	}
	x = atoi(argv[1]);
	y = atoi(argv[2]);

	BN_CK_TABLE(spectrum);

	if( x < 0 || x >= width || y < 0 || y >= height )  {
		interp->result = "x or y out of range";
		return TCL_ERROR;
	}

	if( !data )  {
		interp->result = "pixel data table not loaded yet";
		return TCL_ERROR;
	}
	cp = (char *)data;
	cp = cp + (y * width + x) * BN_SIZEOF_TABDATA(spectrum);
	sp = (struct bn_tabdata *)cp;
	BN_CK_TABDATA(sp);

	bu_vls_init(&str);
	bn_tabdata_to_tcl( &str, sp );
	Tcl_SetResult( interp, bu_vls_addr(&str), TCL_VOLATILE);
	bu_vls_free(&str);

	return TCL_OK;
}

/*
 *  TCL interface to LIBFB.
 *  Points at lower left corner of selected pixel.
 */
int
tcl_fb_cursor(ClientData cd, Tcl_Interp *interp, int argc, char **argv)
{
	FBIO	*ifp;
	int	mode, x, y;

	if( argc != 5 )  {
		interp->result = "Usage: fb_cursor fbp mode x y";
		return TCL_ERROR;
	}
	ifp = (FBIO *)atoi(argv[1]);
	mode = atoi(argv[2]);
	x = atoi(argv[3]);
	y = atoi(argv[4]);

	ifp = fbp;	/* XXX hack, ignore tcl arg. */

	FB_CK_FBIO(ifp);
	if( fb_cursor( ifp, mode, x, y ) < 0 )  {
		interp->result = "fb_cursor got error from library";
		return TCL_ERROR;
	}
	return TCL_OK;
}

/*
 *  Return value of one pixel as RGB tripple, in decimal
 */
int
tcl_fb_readpixel(ClientData cd, Tcl_Interp *interp, int argc, char **argv)
{
	FBIO	*ifp;
	int	mode, x, y;
	unsigned char	pixel[4];

	if( argc != 4 )  {
		interp->result = "Usage: fb_readpixel fbp x y";
		return TCL_ERROR;
	}
	ifp = (FBIO *)atoi(argv[1]);
	x = atoi(argv[2]);
	y = atoi(argv[3]);

	ifp = fbp;	/* XXX hack, ignore tcl arg. */

	FB_CK_FBIO(ifp);
	if( fb_read( ifp, x, y, pixel, 1 ) < 0 )  {
		interp->result = "fb_readpixel got error from library";
		return TCL_ERROR;
	}
	sprintf(interp->result, "%d %d %d", pixel[RED], pixel[GRN], pixel[BLU] );
	return TCL_OK;
}

int
tcl_appinit(Tcl_Interp *inter)
{
	interp = inter;	/* set global var */
	if( Tcl_Init(interp) == TCL_ERROR )  {
		return TCL_ERROR;
	}

	/* Run tk.tcl script */
	if( Tk_Init(interp) == TCL_ERROR )  return TCL_ERROR;

	/* Add commands offered by the libraries */
	bu_tcl_setup(interp);
	rt_tcl_setup(interp);

	/* Add commands offered by this program */
	Tcl_CreateCommand(interp, "fb_cursor", tcl_fb_cursor, (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
	Tcl_CreateCommand(interp, "fb_readpixel", tcl_fb_readpixel, (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);

	Tcl_CreateCommand(interp, "doit", doit, (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
	Tcl_CreateCommand(interp, "doit1", doit1, (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);

	Tcl_CreateCommand(interp, "getspectval", getspectval, (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
	Tcl_CreateCommand(interp, "getspectrum", getspectrum, (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
	Tcl_CreateCommand(interp, "getspectxy", getspectxy, (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
	Tcl_CreateCommand(interp, "getntsccurves", getntsccurves, (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);

	Tcl_LinkVar( interp, "minval", (char *)&minval, TCL_LINK_DOUBLE );
	Tcl_LinkVar( interp, "maxval", (char *)&maxval, TCL_LINK_DOUBLE );

	Tcl_LinkVar( interp, "width", (char *)&width, TCL_LINK_INT );
	Tcl_LinkVar( interp, "height", (char *)&height, TCL_LINK_INT );
	Tcl_LinkVar( interp, "nwave", (char *)&nwave, TCL_LINK_INT );
	Tcl_LinkVar( interp, "use_atmosphere", (char *)&use_atmosphere, TCL_LINK_INT );
	Tcl_LinkVar( interp, "use_cie_xyz", (char *)&use_cie_xyz, TCL_LINK_INT );

	/* Tell Tcl script what to do first */
	Tcl_SetVar( interp, "first_command", first_command, 0 );

	/* Specify startup file to invoke when run interactively */
	/* Source the TCL part of this lashup */
	/* Tcl7 way:  tcl_RcFileName = "./ssampview.tcl"; */
	Tcl_SetVar(interp, "tcl_rcFileName", "~/brlcad/rttherm/ssampview.tcl", TCL_GLOBAL_ONLY);

	return TCL_OK;
}

void check( double x, double y, double z);

/* Check identity of XYZ->RGB->spectrum->XYZ->RGB */
void
check(double x, double y, double z)
{
	point_t	xyz;
	point_t	rgb;
	point_t	xyz2, rgb2;
	struct bn_tabdata	*tabp;
	FAST fastf_t	tab_area;

	BN_GET_TABDATA( tabp, spectrum );
	xyz[X] = x;
	xyz[Y] = y;
	xyz[Z] = z;
	VPRINT( "\nstarting xyz", xyz );

#if 0
	/* XXX No way to do this yet!! */
	rt_spect_xyz_to_curve( tabp, xyz, cie_x, cie_y, cie_z );
#else
	MAT3X3VEC( rgb, xyz2rgb, xyz );
	VPRINT( "rgb", rgb );
	{
	    float rrggbb[3];
	    VMOVE( rrggbb, rgb);

	    rt_spect_reflectance_rgb( tabp, rrggbb );
	}
#endif
	bn_print_table_and_tabdata( "/dev/tty", tabp );
	tab_area = bn_tabdata_area2( tabp );
	bu_log(" tab_area = %g\n", tab_area);

	rt_spect_curve_to_xyz( xyz2, tabp, cie_x, cie_y, cie_z );

	VPRINT( "xyz2", xyz2 );
	MAT3X3VEC( rgb2, xyz2rgb, xyz2 );
	VPRINT( "rgb2", rgb2 );

	bn_tabdata_free( tabp );
exit(2);
}

void
conduct_tests(void)
{
	struct bn_tabdata	*flat;
	vect_t			xyz;

	/* Code for testing library routines */
	spectrum = bn_table_make_uniform( 20, 340.0, 760.0 );
	rt_spect_make_CIE_XYZ( &cie_x, &cie_y, &cie_z, spectrum );
bu_log("X:\n");bn_print_table_and_tabdata( "/dev/tty", cie_x );
bu_log("Y:\n");bn_print_table_and_tabdata( "/dev/tty", cie_y );
bu_log("Z:\n");bn_print_table_and_tabdata( "/dev/tty", cie_z );

	rt_spect_make_NTSC_RGB( &ntsc_r, &ntsc_g, &ntsc_b, spectrum );
bu_log("R:\n");bn_print_table_and_tabdata( "/dev/tty", ntsc_r );
bu_log("G:\n");bn_print_table_and_tabdata( "/dev/tty", ntsc_g );
bu_log("B:\n");bn_print_table_and_tabdata( "/dev/tty", ntsc_b );
	{
		struct bu_vls str;
		bu_vls_init(&str);
		bn_tabdata_to_tcl( &str, ntsc_r );
		bu_log("ntsc_r tcl:  %s\n", bu_vls_addr(&str) );
		bu_vls_free(&str);
	}

/* "A flat spectral curve is represente by equal XYZ values".  Hall pg 52 */
	flat = bn_tabdata_get_constval( 42.0, spectrum );
	bu_log("flat:\n");bn_print_table_and_tabdata( "/dev/tty", flat );
	rt_spect_curve_to_xyz(xyz, flat, cie_x, cie_y, cie_z );
	VPRINT("flat xyz?", xyz);

return;

	/* Check identity of XYZ->RGB->spectrum->XYZ->RGB */
	check( 0.313,     0.329,      0.358);	/* D6500 white */
	check( 0.670,     0.330,      0.000);	/* NTSC red primary */
	check( 0.210,     0.710,      0.080);	/* NTSC green primary */
	check( 0.140,     0.080,      0.780);	/* NTSC blue primary */
	check( .5, .5, .5 );
	check( 1, 0, 0 );
	check( 0, 1, 0 );
	check( 0, 0, 1 );
	check( 1, 1, 1 );
	check( 1, 1, 0 );
	check( 1, 0, 1 );
	check( 0, 1, 1 );
}

static char usage[] = "\
Usage: ssampview [-t] [-s squarefilesize] [-w file_width] [-n file_height]\n\
		file.ssamp\n";


int
get_args(int argc, register char **argv)
{
	register int c;

	while ( (c = getopt( argc, argv, "ts:w:n:" )) != EOF )  {
		switch( c )  {
		case 't':
			fprintf(stderr, "ssampview: conducting library tests\n");
			conduct_tests();
			first_command = "do_testing";
			Tk_Main( 1, argv, tcl_appinit );
			/* NOTREACHED */
			exit(0);
			/* NOTREACHED */
			break;
		case 's':
			/* square file size */
			height = width = atoi(optarg);
			break;
		case 'w':
			width = atoi(optarg);
			break;
		case 'n':
			height = atoi(optarg);
			break;

		default:		/* '?' */
			return(0);
		}
	}

	if( optind >= argc )  return 0;
	return 1;	/* OK */
}

/*
 *			M A I N
 */
int
main(int argc, char **argv)
{

	bu_debug = BU_DEBUG_COREDUMP;
	rt_g.debug = 1;

	rt_make_ntsc_xyz2rgb( xyz2rgb );

	if ( !get_args( argc, argv ) )  {
		(void)fputs(usage, stderr);
		exit( 1 );
	}

	if( argc > 1 && strcmp(argv[1], "-t") == 0 )  {
	}

	basename = argv[optind];

	first_command = "doit1 42";

	if( (fbp = fb_open( NULL, width, height )) == FBIO_NULL )  {
		rt_bomb("Unable to open fb\n");
	}
	fb_view( fbp, width/2, height/2, fb_getwidth(fbp)/width, fb_getheight(fbp)/height );

	/* Read spectrum definition */
	sprintf( spectrum_name, "%s.spect", basename );
	spectrum = (struct bn_table *)bn_table_read( spectrum_name );
	if( spectrum == NULL )  {
		rt_bomb("Unable to read spectrum\n");
	}
	BN_CK_TABLE(spectrum);
	bu_log("spectrum has %d samples\n", spectrum->nx);
	nwave = spectrum->nx;	/* shared with Tcl */

	/* Read atmosphere curve -- input is in microns, not nm */
	atmosphere_orig = bn_read_table_and_tabdata( "../rttherm/std_day_1km.dat" );
	bn_table_scale( (struct bn_table *)(atmosphere_orig->table), 1000.0 );
	atmosphere = bn_tabdata_resample_max( spectrum, atmosphere_orig );

	/* Allocate and read 2-D spectrum array */
	data = bn_tabdata_binary_read( basename, width*height, spectrum );
	if( !data )  bu_bomb("bn_tabdata_binary_read() of basename failed\n");

	/* Allocate framebuffer image buffer */
	pixels = (unsigned char *)bu_malloc( width * height * 3, "pixels[]" );

	find_minmax();
	rt_log("min = %g, max=%g Watts\n", minval, maxval );

	Tk_Main( 1, argv, tcl_appinit );
	/* NOTREACHED */

	return 0;
}

int
doit(ClientData cd, Tcl_Interp *interp, int argc, char **argv)
{
	int	wl;
	char	cmd[96];

	for( wl = 0; wl < spectrum->nx; wl++ )  {
		sprintf( cmd, "doit1 %d", wl );
		Tcl_Eval( interp, cmd );
	}
	return TCL_OK;
}

int
doit1(ClientData cd, Tcl_Interp *interp, int argc, char **argv)
{
	int	wl;
	char	buf[32];
	int	got;

	if( argc != 2 )  {
		interp->result = "Usage: doit1 wavel#";
		return TCL_ERROR;
	}
	wl = atoi(argv[1]);
	if( wl < 0 || wl >= spectrum->nx )  {
		interp->result = "Wavelength number out of range";
		return TCL_ERROR;
	}

	if( !data )  {
		interp->result = "pixel data table not loaded yet";
		return TCL_ERROR;
	}

	rt_log("doit1 %d: %g um to %g um\n",
		wl,
		spectrum->x[wl] * 0.001,
		spectrum->x[wl+1] * 0.001 );
	if( use_cie_xyz )
		show_color(wl);
	else
		rescale(wl);
	(void)fb_writerect( fbp, 0, 0, width, height, pixels );
	fb_poll(fbp);

	/* export C variables to TCL, one-way */
	/* These are being traced by Tk, this will cause update */
	sprintf(buf, "%d", wl);
	Tcl_SetVar(interp, "x", buf, TCL_GLOBAL_ONLY);
	sprintf(buf, "%g", spectrum->x[wl] * 0.001);
	Tcl_SetVar(interp, "lambda", buf, TCL_GLOBAL_ONLY);

	return TCL_OK;
}

/*
 */
void
find_minmax(void)
{
	char			*cp;
	int			todo;
	register fastf_t	max, min;
	int		nbytes;
	int		j;

	cp = (char *)data;
	nbytes = BN_SIZEOF_TABDATA(spectrum);

	max = -INFINITY;
	min =  INFINITY;

	for( todo = width * height; todo > 0; todo--, cp += nbytes )  {
		struct bn_tabdata	*sp;
		sp = (struct bn_tabdata *)cp;
		BN_CK_TABDATA(sp);
		for( j = 0; j < spectrum->nx; j++ )  {
			register fastf_t	v;

			if( (v = sp->y[j]) > max )  max = v;
			if( v < min )  min = v;
		}
	}
	maxval = max;
	minval = min;
}

/*
 *			R E S C A L E
 *
 *  Create monochrome image from the spectral data, at wavelength 'wav',
 *  given current min & max values.
 */
void
rescale(int wav)
{
	char		*cp;
	unsigned char	*pp;
	int		todo;
	int		nbytes;
	fastf_t		scale;
	fastf_t		atmos_scale;

	cp = (char *)data;
	nbytes = BN_SIZEOF_TABDATA(spectrum);

	pp = pixels;

	scale = 255 / (maxval - minval);

	if( use_atmosphere )
		atmos_scale = atmosphere->y[wav];
	else
		atmos_scale = 1;

	for( todo = width * height; todo > 0; todo--, cp += nbytes, pp += 3 )  {
		struct bn_tabdata	*sp;
		register int		val;

		sp = (struct bn_tabdata *)cp;
		BN_CK_TABDATA(sp);

		val = (sp->y[wav] * atmos_scale - minval) * scale;
		if( val > 255 )  val = 255;
		else if( val < 0 ) val = 0;
		pp[0] = pp[1] = pp[2] = val;
	}
}


/*
 *			S H O W _ C O L O R
 *
 *  Create color image from spectral curve,
 *  given current min & max values, and frequency offset (in nm).
 *  Go via CIE XYZ space.
 */
void
show_color(int off)
{
	char		*cp;
	unsigned char	*pp;
	int		todo;
	int		nbytes;
	fastf_t		scale;
	struct bn_tabdata *new;

	cp = (char *)data;
	nbytes = BN_SIZEOF_TABDATA(spectrum);

	pp = pixels;

	scale = 255 / (maxval - minval);

	/* Build CIE curves */
	if( cie_x->magic == 0 )
		rt_spect_make_CIE_XYZ( &cie_x, &cie_y, &cie_z, spectrum );

	BN_GET_TABDATA(new, spectrum);

	for( todo = width * height; todo > 0; todo--, cp += nbytes, pp += 3 )  {
		struct bn_tabdata	*sp;
		point_t			xyz;
		point_t			rgb;
		register int		val;

		sp = (struct bn_tabdata *)cp;
		BN_CK_TABDATA(sp);

		if( use_atmosphere )  {
			bn_tabdata_mul( new, sp, atmosphere );
			bn_tabdata_freq_shift( new, new, spectrum->x[off] - 380.0 );
		} else {
			bn_tabdata_freq_shift( new, sp, spectrum->x[off] - 380.0 );
		}

#if 0
		if( todo == (width/2)*(height/2) )  {
			struct bu_vls str;
			bu_vls_init(&str);

			bu_vls_printf(&str, "popup_plot_tabdata centerpoint {");
			bn_tabdata_to_tcl(&str, sp);
			bu_vls_printf(&str, "}" );
			Tcl_Eval( interp, bu_vls_addr(&str) );

			bu_vls_trunc(&str,0);
			bu_vls_printf(&str, "popup_plot_tabdata centerpoint_shifted {");
			bn_tabdata_to_tcl(&str, new);
			bu_vls_printf(&str, "}" );
			Tcl_Eval( interp, bu_vls_addr(&str) );
			bu_vls_free(&str);
		}
#endif

		rt_spect_curve_to_xyz( xyz, new, cie_x, cie_y, cie_z );

		MAT3X3VEC( rgb, xyz2rgb, xyz );

		val = (rgb[RED] - minval) * scale;
		if( val > 255 )  val = 255;
		else if( val < 0 ) val = 0;
		pp[RED] = val;

		val = (rgb[GRN] - minval) * scale;
		if( val > 255 )  val = 255;
		else if( val < 0 ) val = 0;
		pp[GRN] = val;

		val = (rgb[BLU] - minval) * scale;
		if( val > 255 )  val = 255;
		else if( val < 0 ) val = 0;
		pp[BLU] = val;
	}

	bn_tabdata_free( new );
}
@


1.36
log
@merge of ansi-6-0-branch into head
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
@


1.35
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/ssampview.c,v 1.33 2001/07/09 19:21:32 butler Exp $ (ARL)";
d89 2
a90 2
int	doit(), doit1();
void	find_minmax();
d103 1
a103 4
assign_tabdata_to_tcl_var( interp, name, tabp )
Tcl_Interp	*interp;
const char	*name;
const struct bn_tabdata *tabp;
d123 1
a123 5
getntsccurves( cd, interp, argc, argv )
ClientData	cd;
Tcl_Interp	*interp;
int		argc;
char		*argv[];
d218 1
a218 5
getspectrum( cd, interp, argc, argv )
ClientData	cd;
Tcl_Interp	*interp;
int		argc;
char		*argv[];
d244 1
a244 5
getspectval( cd, interp, argc, argv )
ClientData	cd;
Tcl_Interp	*interp;
int		argc;
char		*argv[];
d297 1
a297 5
getspectxy( cd, interp, argc, argv )
ClientData	cd;
Tcl_Interp	*interp;
int		argc;
char		*argv[];
d340 1
a340 5
tcl_fb_cursor( cd, interp, argc, argv )
ClientData	cd;
Tcl_Interp	*interp;
int		argc;
char		*argv[];
d368 1
a368 5
tcl_fb_readpixel( cd, interp, argc, argv )
ClientData	cd;
Tcl_Interp	*interp;
int		argc;
char		*argv[];
d394 1
a394 2
tcl_appinit(inter)
Tcl_Interp	*inter;
d444 1
a444 2
check( x, y, z )
double x, y, z;
d486 1
a486 1
conduct_tests()
d539 1
a539 2
get_args( argc, argv )
register char **argv;
d578 1
a578 2
main( argc, argv )
char	**argv;
d635 1
a635 5
doit( cd, interp, argc, argv )
ClientData	cd;
Tcl_Interp	*interp;
int		argc;
char		*argv[];
d648 1
a648 5
doit1( cd, interp, argc, argv )
ClientData	cd;
Tcl_Interp	*interp;
int		argc;
char		*argv[];
d693 1
a693 1
find_minmax()
d729 1
a729 2
rescale(wav)
int	wav;
d773 1
a773 2
show_color(off)
int	off;
@


1.35.2.1
log
@Initial ANSIfication
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/ssampview.c,v 1.35 2002/08/20 17:08:41 jra Exp $ (ARL)";
d89 2
a90 2
int	doit(ClientData cd, Tcl_Interp *interp, int argc, char **argv), doit1(ClientData cd, Tcl_Interp *interp, int argc, char **argv);
void	find_minmax(void);
d103 4
a106 1
assign_tabdata_to_tcl_var(Tcl_Interp *interp, const char *name, const struct bn_tabdata *tabp)
d126 5
a130 1
getntsccurves(ClientData cd, Tcl_Interp *interp, int argc, char **argv)
d225 5
a229 1
getspectrum(ClientData cd, Tcl_Interp *interp, int argc, char **argv)
d255 5
a259 1
getspectval(ClientData cd, Tcl_Interp *interp, int argc, char **argv)
d312 5
a316 1
getspectxy(ClientData cd, Tcl_Interp *interp, int argc, char **argv)
d359 5
a363 1
tcl_fb_cursor(ClientData cd, Tcl_Interp *interp, int argc, char **argv)
d391 5
a395 1
tcl_fb_readpixel(ClientData cd, Tcl_Interp *interp, int argc, char **argv)
d421 2
a422 1
tcl_appinit(Tcl_Interp *inter)
d472 2
a473 1
check(double x, double y, double z)
d515 1
a515 1
conduct_tests(void)
d568 2
a569 1
get_args(int argc, register char **argv)
d608 2
a609 1
main(int argc, char **argv)
d666 5
a670 1
doit(ClientData cd, Tcl_Interp *interp, int argc, char **argv)
d683 5
a687 1
doit1(ClientData cd, Tcl_Interp *interp, int argc, char **argv)
d732 1
a732 1
find_minmax(void)
d768 2
a769 1
rescale(int wav)
d813 2
a814 1
show_color(int off)
@


1.34
log
@Converted from K&R to ANSI C - RFH
@
text
@d89 2
a90 2
int	doit(ClientData cd, Tcl_Interp *interp, int argc, char **argv), doit1(ClientData cd, Tcl_Interp *interp, int argc, char **argv);
void	find_minmax(void);
d103 4
a106 1
assign_tabdata_to_tcl_var(Tcl_Interp *interp, const char *name, const struct bn_tabdata *tabp)
d126 5
a130 1
getntsccurves(ClientData cd, Tcl_Interp *interp, int argc, char **argv)
d225 5
a229 1
getspectrum(ClientData cd, Tcl_Interp *interp, int argc, char **argv)
d255 5
a259 1
getspectval(ClientData cd, Tcl_Interp *interp, int argc, char **argv)
d312 5
a316 1
getspectxy(ClientData cd, Tcl_Interp *interp, int argc, char **argv)
d359 5
a363 1
tcl_fb_cursor(ClientData cd, Tcl_Interp *interp, int argc, char **argv)
d391 5
a395 1
tcl_fb_readpixel(ClientData cd, Tcl_Interp *interp, int argc, char **argv)
d421 2
a422 1
tcl_appinit(Tcl_Interp *inter)
d472 2
a473 1
check(double x, double y, double z)
d515 1
a515 1
conduct_tests(void)
d568 2
a569 1
get_args(int argc, register char **argv)
d608 2
a609 1
main(int argc, char **argv)
d666 5
a670 1
doit(ClientData cd, Tcl_Interp *interp, int argc, char **argv)
d683 5
a687 1
doit1(ClientData cd, Tcl_Interp *interp, int argc, char **argv)
d732 1
a732 1
find_minmax(void)
d768 2
a769 1
rescale(int wav)
d813 2
a814 1
show_color(int off)
@


1.33
log
@various lint cleanup for compilation on FreeBSD
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/ssampview.c,v 1.32 2001/04/20 22:31:21 morrison Exp $ (ARL)";
d89 2
a90 2
int	doit(), doit1();
void	find_minmax();
d103 1
a103 4
assign_tabdata_to_tcl_var( interp, name, tabp )
Tcl_Interp	*interp;
const char	*name;
const struct bn_tabdata *tabp;
d123 1
a123 5
getntsccurves( cd, interp, argc, argv )
ClientData	cd;
Tcl_Interp	*interp;
int		argc;
char		*argv[];
d218 1
a218 5
getspectrum( cd, interp, argc, argv )
ClientData	cd;
Tcl_Interp	*interp;
int		argc;
char		*argv[];
d244 1
a244 5
getspectval( cd, interp, argc, argv )
ClientData	cd;
Tcl_Interp	*interp;
int		argc;
char		*argv[];
d297 1
a297 5
getspectxy( cd, interp, argc, argv )
ClientData	cd;
Tcl_Interp	*interp;
int		argc;
char		*argv[];
d340 1
a340 5
tcl_fb_cursor( cd, interp, argc, argv )
ClientData	cd;
Tcl_Interp	*interp;
int		argc;
char		*argv[];
d368 1
a368 5
tcl_fb_readpixel( cd, interp, argc, argv )
ClientData	cd;
Tcl_Interp	*interp;
int		argc;
char		*argv[];
d394 1
a394 2
tcl_appinit(inter)
Tcl_Interp	*inter;
d444 1
a444 2
check( x, y, z )
double x, y, z;
d486 1
a486 1
conduct_tests()
d539 1
a539 2
get_args( argc, argv )
register char **argv;
d578 1
a578 2
main( argc, argv )
char	**argv;
d635 1
a635 5
doit( cd, interp, argc, argv )
ClientData	cd;
Tcl_Interp	*interp;
int		argc;
char		*argv[];
d648 1
a648 5
doit1( cd, interp, argc, argv )
ClientData	cd;
Tcl_Interp	*interp;
int		argc;
char		*argv[];
d693 1
a693 1
find_minmax()
d729 1
a729 2
rescale(wav)
int	wav;
d773 1
a773 2
show_color(off)
int	off;
@


1.32
log
@CONST to const
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/ssampview.c,v 1.31 2000/01/19 21:16:49 mike Exp $ (ARL)";
d35 19
d493 6
a498 1
	rt_spect_reflectance_rgb( tabp, rgb );
d567 1
@


1.31
log
@
lint
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/ssampview.c,v 1.30 1999/12/05 19:35:27 mike Exp $ (ARL)";
d86 2
a87 2
CONST char	*name;
CONST struct bn_tabdata *tabp;
@


1.30
log
@
Changed 'disp' to 'ssampview'.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/ssampview.c,v 1.29 1999/07/08 01:10:11 mike Exp $ (ARL)";
d691 1
a691 1
	got = fb_writerect( fbp, 0, 0, width, height, pixels );
@


1.29
log
@
Number of wavelengths is now exported from C to Tcl.
@
text
@d2 1
a2 1
 *			D I S P . C
d4 2
a5 1
 *  Quickie program to display spectral curves on the framebuffer.
d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/disp.c,v 1.28 1999/07/01 21:06:25 mike Exp $ (ARL)";
d443 2
a444 2
	/* Tcl7 way:  tcl_RcFileName = "./disp.tcl"; */
	Tcl_SetVar(interp, "tcl_rcFileName", "../rttherm/disp.tcl", TCL_GLOBAL_ONLY);
d539 1
a539 1
Usage: disp [-t] [-s squarefilesize] [-w file_width] [-n file_height]\n\
d551 1
a551 1
			fprintf(stderr, "disp: conducting library tests\n");
@


1.28
log
@
Changed to use getopt()
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/disp.c,v 1.27 1999/07/01 20:47:00 mike Exp $ (ARL)";
d36 1
d433 1
d614 3
@


1.27
log
@
Fixed off-by-one bug accessing outside data[] array bounds.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/disp.c,v 1.26 1998/12/12 07:22:02 mike Exp $ (ARL)";
d535 41
d589 3
a591 3
	if( argc < 2 )  {
		fprintf(stderr, "Usage: disp [-t] file.ssamp\n");
		exit(2);
a594 6
		fprintf(stderr, "disp: conducting library tests\n");
		conduct_tests();
		first_command = "do_testing";
		Tk_Main( 1, argv, tcl_appinit );
		/* NOTREACHED */
		exit(0);
d597 1
a597 1
	basename = argv[1];
@


1.26
log
@Changed from rt_tabdata to bn_tabdata
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/disp.c,v 1.25 1998/11/26 03:44:15 mike Exp $ (ARL)";
d255 6
a260 2
	if( x < 0 || x > width || y < 0 || y > height )  {
		interp->result = "x or y out of range";
d264 1
a264 1
		interp->result = "wavelength out of range";
d311 1
a311 1
	if( x < 0 || x > width || y < 0 || y > height )  {
d543 1
@


1.25
log
@Cleanups, added additional samples to visible band.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/disp.c,v 1.23 1998/11/19 06:20:31 mike Exp $ (ARL)";
a28 1
#include "tabdata.h"
d42 1
a42 1
struct rt_table		*spectrum;
d44 1
a44 1
struct rt_tabdata	*data;
d46 2
a47 2
struct rt_tabdata	*atmosphere_orig;
struct rt_tabdata	*atmosphere;
d50 3
a52 3
struct rt_tabdata	*cie_x;
struct rt_tabdata	*cie_y;
struct rt_tabdata	*cie_z;
d57 3
a59 3
struct rt_tabdata	*ntsc_r;
struct rt_tabdata	*ntsc_g;
struct rt_tabdata	*ntsc_b;
d78 1
a78 1
 *  Assign the given "C" rt_tabdata structure to the named Tcl variable,
d85 1
a85 1
CONST struct rt_tabdata *tabp;
d89 1
a89 1
	RT_CK_TABDATA(tabp);
d93 1
a93 1
	rt_tabdata_to_tcl(&str, tabp);
d111 3
a113 3
	extern struct rt_tabdata *rt_NTSC_r_tabdata;
	extern struct rt_tabdata *rt_NTSC_g_tabdata;
	extern struct rt_tabdata *rt_NTSC_b_tabdata;
d129 4
a132 4
		struct rt_tabdata	*sum;
		RT_GET_TABDATA( sum, ntsc_r->table );
		rt_tabdata_add( sum, ntsc_r, ntsc_g );
		rt_tabdata_add( sum, sum, ntsc_b );
d134 1
a134 1
		rt_tabdata_free( sum );
d140 1
a140 1
		struct rt_tabdata	*r, *g, *b, *sum;
d143 4
a146 4
		RT_GET_TABDATA( r, ntsc_r->table );
		RT_GET_TABDATA( g, ntsc_r->table );
		RT_GET_TABDATA( b, ntsc_r->table );
		RT_GET_TABDATA( sum, ntsc_r->table );
d160 2
a161 2
		rt_tabdata_add( sum, r, g );
		rt_tabdata_add( sum, sum, b );
d164 4
a167 4
		rt_tabdata_free( r );
		rt_tabdata_free( g );
		rt_tabdata_free( b );
		rt_tabdata_free( sum );
d173 1
a173 1
		struct rt_tabdata	*a, *b, *c;
d175 3
a177 3
		RT_GET_TABDATA( a, ntsc_r->table );
		RT_GET_TABDATA( b, ntsc_r->table );
		RT_GET_TABDATA( c, ntsc_r->table );
d188 3
a190 3
		rt_tabdata_free( a );
		rt_tabdata_free( b );
		rt_tabdata_free( c );
d212 1
a212 1
	RT_CK_TABLE(spectrum);
d240 1
a240 1
	struct rt_tabdata	*sp;
d253 1
a253 1
	RT_CK_TABLE(spectrum);
d270 3
a272 3
	cp = cp + (y * width + x) * RT_SIZEOF_TABDATA(spectrum);
	sp = (struct rt_tabdata *)cp;
	RT_CK_TABDATA(sp);
d293 1
a293 1
	struct rt_tabdata	*sp;
d305 1
a305 1
	RT_CK_TABLE(spectrum);
d317 3
a319 3
	cp = cp + (y * width + x) * RT_SIZEOF_TABDATA(spectrum);
	sp = (struct rt_tabdata *)cp;
	RT_CK_TABDATA(sp);
d322 1
a322 1
	rt_tabdata_to_tcl( &str, sp );
d452 1
a452 1
	struct rt_tabdata	*tabp;
d455 1
a455 1
	RT_GET_TABDATA( tabp, spectrum );
d469 2
a470 2
	rt_pr_table_and_tabdata( "/dev/tty", tabp );
	tab_area = rt_tabdata_area2( tabp );
d479 1
a479 1
	rt_tabdata_free( tabp );
d486 1
a486 1
	struct rt_tabdata	*flat;
d490 1
a490 1
	spectrum = rt_table_make_uniform( 20, 340.0, 760.0 );
d492 3
a494 3
bu_log("X:\n");rt_pr_table_and_tabdata( "/dev/tty", cie_x );
bu_log("Y:\n");rt_pr_table_and_tabdata( "/dev/tty", cie_y );
bu_log("Z:\n");rt_pr_table_and_tabdata( "/dev/tty", cie_z );
d497 3
a499 3
bu_log("R:\n");rt_pr_table_and_tabdata( "/dev/tty", ntsc_r );
bu_log("G:\n");rt_pr_table_and_tabdata( "/dev/tty", ntsc_g );
bu_log("B:\n");rt_pr_table_and_tabdata( "/dev/tty", ntsc_b );
d503 1
a503 1
		rt_tabdata_to_tcl( &str, ntsc_r );
d509 2
a510 2
	flat = rt_tabdata_get_constval( 42.0, spectrum );
	bu_log("flat:\n");rt_pr_table_and_tabdata( "/dev/tty", flat );
d568 1
a568 1
	spectrum = (struct rt_table *)rt_table_read( spectrum_name );
d574 3
a576 3
	atmosphere_orig = rt_read_table_and_tabdata( "../rttherm/std_day_1km.dat" );
	rt_table_scale( (struct rt_table *)(atmosphere_orig->table), 1000.0 );
	atmosphere = rt_tabdata_resample_max( spectrum, atmosphere_orig );
d579 2
a580 2
	data = rt_tabdata_binary_read( basename, width*height, spectrum );
	if( !data )  bu_bomb("rt_tabdata_binary_read() of basename failed\n");
d670 1
a670 1
	nbytes = RT_SIZEOF_TABDATA(spectrum);
d676 3
a678 3
		struct rt_tabdata	*sp;
		sp = (struct rt_tabdata *)cp;
		RT_CK_TABDATA(sp);
d708 1
a708 1
	nbytes = RT_SIZEOF_TABDATA(spectrum);
d720 1
a720 1
		struct rt_tabdata	*sp;
d723 2
a724 2
		sp = (struct rt_tabdata *)cp;
		RT_CK_TABDATA(sp);
d750 1
a750 1
	struct rt_tabdata *new;
d753 1
a753 1
	nbytes = RT_SIZEOF_TABDATA(spectrum);
d763 1
a763 1
	RT_GET_TABDATA(new, spectrum);
d766 1
a766 1
		struct rt_tabdata	*sp;
d771 2
a772 2
		sp = (struct rt_tabdata *)cp;
		RT_CK_TABDATA(sp);
d775 2
a776 2
			rt_tabdata_mul( new, sp, atmosphere );
			rt_tabdata_freq_shift( new, new, spectrum->x[off] - 380.0 );
d778 1
a778 1
			rt_tabdata_freq_shift( new, sp, spectrum->x[off] - 380.0 );
d787 1
a787 1
			rt_tabdata_to_tcl(&str, sp);
d793 1
a793 1
			rt_tabdata_to_tcl(&str, new);
d820 1
a820 1
	rt_tabdata_free( new );
@


1.24
log
@Starting to get it all to work again.
@
text
@d135 1
a135 1
		bu_free( sum, "rt_tabdata sum" );
d165 4
a168 4
		bu_free( r, "r" );
		bu_free( g, "g" );
		bu_free( b, "b" );
		bu_free( sum, "sum" );
d189 3
a191 3
		bu_free( a, "a" );
		bu_free( b, "b" );
		bu_free( c, "c" );
d480 1
a480 1
	rt_free( (char *)tabp, "struct rt_tabdata" );
d581 1
d621 1
d646 1
a646 1
	fb_writerect( fbp, 0, 0, width, height, pixels );
d751 1
d761 2
a762 1
	rt_spect_make_CIE_XYZ( &cie_x, &cie_y, &cie_z, spectrum );
d764 1
a764 5
	if( use_atmosphere )  {
		rt_tabdata_mul( cie_x, cie_x, atmosphere );
		rt_tabdata_mul( cie_y, cie_y, atmosphere );
		rt_tabdata_mul( cie_z, cie_z, atmosphere );
	}
d775 27
a801 4
		/* rt_spect_curve_to_xyz( xyz, sp, cie_x, cie_y, cie_z ); */
		xyz[X] = rt_tabdata_mul_area1( sp, cie_x );
		xyz[Y] = rt_tabdata_mul_area1( sp, cie_y );
		xyz[Z] = rt_tabdata_mul_area1( sp, cie_z );
d820 2
@


1.23
log
@Changed to reflect new path to disp.tcl
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/disp.c,v 1.22 1998/10/09 21:45:25 mike Exp $ (ARL)";
d544 7
a550 1
	if( argc > 1 )  {
d557 3
d575 1
a575 1
	atmosphere_orig = rt_read_table_and_tabdata( "std_day_1km.dat" );
@


1.22
log
@Expanded to show blackbody curves
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/disp.c,v 1.21 1998/10/09 21:32:14 mike Exp $ (ARL)";
d438 1
a438 1
	Tcl_SetVar(interp, "tcl_rcFileName", "../rt/disp.tcl", TCL_GLOBAL_ONLY);
@


1.21
log
@Added code to plot the rgb reflectance curves.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/disp.c,v 1.20 1998/10/09 21:17:28 mike Exp $ (ARL)";
d138 1
d169 23
@


1.20
log
@Added assign_tabdata_to_tcl_var().
Now an arbitrary collection of curves can be sent up to the Tcl code
for plotting.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/disp.c,v 1.19 1998/10/09 05:52:30 mike Exp $ (ARL)";
d95 2
a96 2
	Tcl_SetVar( interp, name, bu_vls_addr(&str), 0 );
	Tcl_AppendResult( interp, (char *)name, " ", (char *)NULL );
d121 1
d126 43
@


1.19
log
@Changed rt_tabdata_resample(), which had bad aliasing, into
rt_tabdata_resample_max() and rt_tabdata_resample_avg().
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/disp.c,v 1.18 1998/10/09 02:19:05 mike Exp $ (ARL)";
d77 25
a111 21
	struct bu_vls	str;

	bu_vls_init(&str);

	/* These are the curves as fitted to our spectrum sampling */
	bu_vls_trunc(&str, 0);
	rt_tabdata_to_tcl(&str, ntsc_r);
	Tcl_SetVar( interp, "ntsc_r", bu_vls_addr(&str), 0 );

	bu_vls_trunc(&str, 0);
	rt_tabdata_to_tcl(&str, ntsc_g);
	Tcl_SetVar( interp, "ntsc_g", bu_vls_addr(&str), 0 );

	bu_vls_trunc(&str, 0);
	rt_tabdata_to_tcl(&str, ntsc_b);
	Tcl_SetVar( interp, "ntsc_b", bu_vls_addr(&str), 0 );

	Tcl_AppendResult( interp, "ntsc_r ntsc_g ntsc_b", (char *)NULL );

	{
	/* These are the curves from the data tables in the library */
d116 4
a119 12
	bu_vls_trunc(&str, 0);
	rt_tabdata_to_tcl(&str, rt_NTSC_r_tabdata);
	Tcl_SetVar( interp, "ntsc_r_orig", bu_vls_addr(&str), 0 );

	bu_vls_trunc(&str, 0);
	rt_tabdata_to_tcl(&str, rt_NTSC_g_tabdata);
	Tcl_SetVar( interp, "ntsc_g_orig", bu_vls_addr(&str), 0 );

	bu_vls_trunc(&str, 0);
	rt_tabdata_to_tcl(&str, rt_NTSC_b_tabdata);
	Tcl_SetVar( interp, "ntsc_b_orig", bu_vls_addr(&str), 0 );
	}
d121 4
a124 1
	bu_vls_free(&str);
a125 1
	Tcl_AppendResult( interp, "ntsc_r_orig ntsc_g_orig ntsc_b_orig", (char *)NULL );
@


1.18
log
@disp.c: broke out testing support separate from file display functions.
disp.tcl: decent support for plotting spectra
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/disp.c,v 1.17 1998/10/07 22:28:57 mike Exp $ (ARL)";
d502 1
a502 1
	atmosphere = rt_tabdata_resample( spectrum, atmosphere_orig );
@


1.17
log
@Added additional error checking.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/disp.c,v 1.16 1998/10/07 07:49:56 mike Exp $ (ARL)";
d74 57
d198 6
d246 5
d342 5
d356 1
d366 3
d372 1
a372 1
	Tcl_SetVar(interp, "tcl_rcFileName", "./disp.tcl", TCL_GLOBAL_ONLY);
d418 2
a419 3
int
main( argc, argv )
char	**argv;
d421 2
a422 2

	rt_g.debug = 1;
d424 3
a426 9
	rt_make_ntsc_xyz2rgb( xyz2rgb );

#if 1
{
struct rt_tabdata	*flat;
vect_t			xyz;
/* Code for testing library routines */
spectrum = rt_table_make_uniform( 20, 380.0, 770.0 );
rt_spect_make_CIE_XYZ( &cie_x, &cie_y, &cie_z, spectrum );
d431 1
a431 1
rt_spect_make_NTSC_RGB( &ntsc_r, &ntsc_g, &ntsc_b, spectrum );
d444 33
a476 4
flat = rt_tabdata_get_constval( 42.0, spectrum );
bu_log("flat:\n");rt_pr_table_and_tabdata( "/dev/tty", flat );
rt_spect_curve_to_xyz(xyz, flat, cie_x, cie_y, cie_z );
VPRINT("flat xyz?", xyz);
d478 8
a485 16
/* Check identity of XYZ->RGB->spectrum->XYZ->RGB */
check( 0.313,     0.329,      0.358);	/* D6500 white */
check( 0.670,     0.330,      0.000);	/* NTSC red primary */
check( 0.210,     0.710,      0.080);	/* NTSC green primary */
check( 0.140,     0.080,      0.780);	/* NTSC blue primary */
check( .5, .5, .5 );
check( 1, 0, 0 );
check( 0, 1, 0 );
check( 0, 0, 1 );
check( 1, 1, 1 );
check( 1, 1, 0 );
check( 1, 0, 1 );
check( 0, 1, 1 );
exit(1);
}
#endif
d513 1
a513 1
	Tk_Main( argc, argv, tcl_appinit );
d556 6
a561 1
	rt_log("%d: %g um to %g um\n",
@


1.16
log
@Improved testing.
Check identity of XYZ->RGB->spectrum->XYZ->RGB
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/disp.c,v 1.15 1998/10/07 07:37:11 mike Exp $ (ARL)";
d153 44
d282 1
d325 1
a325 1
	rt_spect_rgb_to_curve( tabp, rgb, ntsc_r, ntsc_g, ntsc_b );
d355 1
a355 1
spectrum = rt_table_make_uniform( 10, 380.0, 770.0 );
d365 7
d380 5
a391 1
check( .5, .5, .5 );
@


1.15
log
@Called rt_spect_make_NTSC_RGB() to test support tables and routines.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/disp.c,v 1.14 1998/09/30 04:31:49 mike Exp $ (ARL)";
d56 1
d257 1
a257 1
/* Check XYZ value to spectrum and back */
d263 2
a264 1
	point_t	new;
d274 2
d277 5
d286 5
a290 1
	rt_spect_curve_to_xyz( new, tabp, cie_x, cie_y, cie_z );
a291 1
	VPRINT( "new xyz", new );
d303 2
d327 1
a327 1
/* Check identity of XYZ->spectrum->XYZ */
a338 2

	rt_make_ntsc_xyz2rgb( xyz2rgb );
@


1.14
log
@Expanding on validation tests.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/disp.c,v 1.13 1998/09/30 02:22:18 mike Exp $ (ARL)";
d57 4
d301 5
@


1.13
log
@Upgraded for Tcl8.0
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/disp.c,v 1.12 1996/04/06 04:30:54 mike Exp $ (ARL)";
d260 1
d266 1
a266 1
	VPRINT( "\nxyz", xyz );
d270 2
d275 1
a275 1
	VPRINT( "new", new );
d287 4
a290 1
#if 0
d294 11
a304 3
rt_pr_table_and_tabdata( "/dev/tty", cie_x );
rt_pr_table_and_tabdata( "/dev/tty", cie_y );
rt_pr_table_and_tabdata( "/dev/tty", cie_z );
d314 1
@


1.12
log
@Added some testing code.
Changed xyz conversion, probably still not right.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/disp.c,v 1.11 1996/04/06 01:09:12 mike Exp mike $ (ARL)";
d22 1
d24 2
d27 1
a27 1
#include "rtstring.h"
d57 1
a57 1
char	*pixels;		/* en-route to framebuffer */
d65 3
d242 1
d244 2
a245 1
	tcl_RcFileName = "./disp.tcl";
d250 2
a251 1
extern check( double x, double y, double z);
d253 1
d277 1
d325 1
a325 1
	pixels = rt_malloc( width * height * 3, "pixels[]" );
d350 1
a350 1

d396 1
d432 1
d437 1
a437 1
	char		*pp;
d477 1
d482 1
a482 1
	char		*pp;
@


1.11
log
@Added new header file.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/disp.c,v 1.10 1996/03/16 00:52:32 mike Exp mike $ (ARL)";
d242 25
d273 18
d307 1
a307 1
	rt_table_scale( atmosphere_orig->table, 1000.0 );
a471 1
	struct rt_tabdata	*xyzsamp;
a476 1
	RT_GET_TABDATA(xyzsamp, spectrum);
d498 4
a501 3
		/* XXX For efficiency, these two steps could be done together */
		rt_tabdata_mul( xyzsamp, sp, cie_x );
		xyz[X] = rt_tabdata_area1( xyzsamp );
a502 6
		rt_tabdata_mul( xyzsamp, sp, cie_y );
		xyz[Y] = rt_tabdata_area1( xyzsamp );

		rt_tabdata_mul( xyzsamp, sp, cie_z );
		xyz[Z] = rt_tabdata_area1( xyzsamp );

a519 1
	rt_free( (char *)xyzsamp, "xyz sample");
@


1.10
log
@Converting over to table data structures.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/disp.c,v 1.9 1996/03/14 07:25:02 mike Exp $ (ARL)";
d26 1
d457 1
@


1.9
log
@Added real conversion from XYZ to RGB space.
@
text
@d2 2
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/disp.c,v 1.8 1996/03/14 04:58:40 mike Exp mike $ (ARL)";
d39 1
a39 1
struct rt_spectrum	*spectrum;
d41 1
a41 1
struct rt_spect_sample	*ss;
d43 2
a44 2
struct rt_spect_sample	*atmosphere_orig;
struct rt_spect_sample	*atmosphere;
d47 3
a49 3
struct rt_spect_sample	*cie_x;
struct rt_spect_sample	*cie_y;
struct rt_spect_sample	*cie_z;
d78 1
a78 1
	RT_CK_SPECTRUM(spectrum);
d81 1
a81 1
		sprintf( interp->result, "%d", spectrum->nwave );
d90 1
a90 1
	if( wl < 0 || wl > spectrum->nwave )  {
d92 1
a92 1
			wl, spectrum->nwave);
d95 1
a95 1
	sprintf( interp->result, "%g", spectrum->wavel[wl] );
d106 1
a106 1
	struct rt_spect_sample	*sp;
d119 1
a119 1
	RT_CK_SPECTRUM(spectrum);
d125 1
a125 1
	if( wl < 0 || wl >= spectrum->nwave )  {
d129 5
a133 5
	cp = (char *)ss;
	cp = cp + (y * width + x) * RT_SIZEOF_SPECT_SAMPLE(spectrum);
	sp = (struct rt_spect_sample *)cp;
	RT_CK_SPECT_SAMPLE(sp);
	val = sp->val[wl];
d135 1
a135 1
		val *= atmosphere->val[wl];
a240 43
/*
 */
struct rt_spect_sample *
rt_spect_sample_binary_read( filename, num, spect )
CONST char			*filename;
int				num;
CONST struct rt_spectrum	*spect;
{
	struct rt_spect_sample	*ss;
	char	*cp;
	int	nbytes;
	int	len;
	int	fd;
	int	i;

	RT_CK_SPECTRUM(spect);

	nbytes = RT_SIZEOF_SPECT_SAMPLE(spect);
	len = num * nbytes;
	ss = (struct rt_spect_sample *)rt_malloc( len+8, "rt_spect_sample[]" );

	if( (fd = open(basename, 0)) <= 0 )  {
		perror(basename);
		rt_bomb("Unable to open spectral samples\n");
	}
	if( read( fd, (char *)ss, len ) != len )  {
		rt_bomb("Read of spectral samples failed\n");
	}
	close(fd);

	/* Connect ss[i].spectrum pointer to spect */
	cp = (char *)ss;
	for( i = num-1; i >= 0; i--, cp += nbytes )  {
		register struct rt_spect_sample	*sp;

		sp = (struct rt_spect_sample *)cp;
		RT_CK_SPECT_SAMPLE(sp);
		sp->spectrum = spect;
	}

	return ss;
}

d256 1
a256 1
	spectrum = (struct rt_spectrum *)rt_read_spectrum( spectrum_name );
d262 3
a264 3
	atmosphere_orig = rt_read_spectrum_and_samples( "std_day_1km.dat" );
	rt_spectrum_scale( atmosphere_orig->spectrum, 1000.0 );
	atmosphere = rt_spect_resample( spectrum, atmosphere_orig );
d267 1
a267 1
	ss = rt_spect_sample_binary_read( basename, width*height, spectrum );
d291 1
a291 1
	for( wl = 0; wl < spectrum->nwave; wl++ )  {
d313 1
a313 1
	if( wl < 0 || wl >= spectrum->nwave )  {
d320 2
a321 2
		spectrum->wavel[wl] * 0.001,
		spectrum->wavel[wl+1] * 0.001 );
d332 2
a333 2
	Tcl_SetVar(interp, "wavel", buf, TCL_GLOBAL_ONLY);
	sprintf(buf, "%g", spectrum->wavel[wl] * 0.001);
d349 2
a350 2
	cp = (char *)ss;
	nbytes = RT_SIZEOF_SPECT_SAMPLE(spectrum);
d356 4
a359 4
		struct rt_spect_sample	*sp;
		sp = (struct rt_spect_sample *)cp;
		RT_CK_SPECT_SAMPLE(sp);
		for( j = 0; j < spectrum->nwave; j++ )  {
d362 1
a362 1
			if( (v = sp->val[j]) > max )  max = v;
d386 2
a387 2
	cp = (char *)ss;
	nbytes = RT_SIZEOF_SPECT_SAMPLE(spectrum);
d394 1
a394 1
		atmos_scale = atmosphere->val[wav];
d399 1
a399 1
		struct rt_spect_sample	*sp;
d402 2
a403 2
		sp = (struct rt_spect_sample *)cp;
		RT_CK_SPECT_SAMPLE(sp);
d405 1
a405 1
		val = (sp->val[wav] * atmos_scale - minval) * scale;
d428 1
a428 1
	struct rt_spect_sample	*xyzsamp;
d430 2
a431 2
	cp = (char *)ss;
	nbytes = RT_SIZEOF_SPECT_SAMPLE(spectrum);
d434 1
a434 1
	RT_GET_SPECT_SAMPLE(xyzsamp, spectrum);
d442 3
a444 3
		rt_spect_mul( cie_x, cie_x, atmosphere );
		rt_spect_mul( cie_y, cie_y, atmosphere );
		rt_spect_mul( cie_z, cie_z, atmosphere );
d448 1
a448 1
		struct rt_spect_sample	*sp;
d453 2
a454 2
		sp = (struct rt_spect_sample *)cp;
		RT_CK_SPECT_SAMPLE(sp);
d456 2
a457 2
		rt_spect_mul( xyzsamp, sp, cie_x );
		xyz[X] = rt_spect_area1( xyzsamp );
d459 2
a460 2
		rt_spect_mul( xyzsamp, sp, cie_y );
		xyz[Y] = rt_spect_area1( xyzsamp );
d462 2
a463 2
		rt_spect_mul( xyzsamp, sp, cie_z );
		xyz[Z] = rt_spect_area1( xyzsamp );
@


1.8
log
@Added CIE display
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/disp.c,v 1.7 1996/03/09 05:37:45 mike Exp mike $ (ARL)";
d49 1
d288 2
d490 2
a491 1
		fastf_t			x, y, z;
d498 1
a498 1
		x = rt_spect_area1( xyzsamp );
d501 1
a501 1
		y = rt_spect_area1( xyzsamp );
d504 1
a504 1
		z = rt_spect_area1( xyzsamp );
d506 3
a508 1
		val = (x - minval) * scale;
d511 1
a511 1
		pp[0] = val;
d513 1
a513 1
		val = (y - minval) * scale;
d516 1
a516 1
		pp[1] = val;
d518 1
a518 1
		val = (z - minval) * scale;
d521 1
a521 1
		pp[2] = val;
@


1.7
log
@Added support for "Standard" atmosphere.
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/disp.c,v 1.6 1996/03/09 03:21:08 mike Exp $ (ARL)";
d45 5
d230 1
d238 7
a244 2
main( argc, argv )
char	**argv;
d246 3
d253 32
d304 4
a307 2
	len = width * height * RT_SIZEOF_SPECT_SAMPLE(spectrum);
	ss = (struct rt_spect_sample *)rt_malloc( len, "rt_spect_sample" );
a309 10
	if( (fd = open(basename, 0)) <= 0 )  {
		perror(basename);
		rt_bomb("Unable to open spectral samples\n");
	}
	if( read( fd, (char *)ss, len ) != len )  {
		rt_bomb("Read of spectral samples failed\n");
	}
	close(fd);


d360 4
a363 1
	rescale(wl);
d448 70
@


1.6
log
@Addef fb_readpixel support
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/disp.c,v 1.5 1996/03/09 01:01:01 mike Exp $ (ARL)";
d29 2
a30 2
int	width = 64;
int	height = 64;
d41 3
a43 1
char	*pixels;
d45 1
a45 1
fastf_t	maxval, minval;
d47 2
d101 1
d125 4
a128 1
	sprintf( interp->result, "%g", sp->val[wl] );
d224 1
d239 2
d253 5
d326 2
a327 1
	/* set global variables */
d368 4
d381 1
d390 5
d402 1
a402 1
		val = (sp->val[wav] - minval) * scale;
@


1.5
log
@Improvements
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/disp.c,v 1.4 1996/03/09 00:50:42 mike Exp mike $ (ARL)";
d157 3
d161 30
d203 1
@


1.4
log
@Working version
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/disp.c,v 1.3 1996/03/08 05:53:35 mike Exp mike $ (ARL)";
d50 7
d66 6
d73 1
a73 1
		interp->result = "Usage: getspectrum wl";
d78 3
a80 4
	RT_CK_SPECTRUM(spectrum);

	if( wl < 0 || wl >= spectrum->nwave )  {
		interp->result = "wavelength out of range";
d182 3
@


1.3
log
@More complete TCL/Tk interface.
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/disp.c,v 1.2 1996/03/08 03:04:09 mike Exp mike $ (ARL)";
d112 4
d117 29
d157 2
a317 3
#if 1
	rt_log(" scale = %g, 255 =? %g\n", scale, maxval * scale);
#endif
@


1.2
log
@Initial TCL/Tk support
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/disp.c,v 1.1 1996/03/01 06:03:46 mike Exp mike $ (ARL)";
d51 25
d104 2
a105 1
	cp = pixels + (y * RT_SIZEOF_SPECT_SAMPLE(spectrum) + x) * RT_SIZEOF_SPECT_SAMPLE(spectrum);
d120 4
d127 2
a128 3
	tkwin = Tk_CreateMainWindow( interp, (char *)NULL, "disp", "disp" );
	if( tkwin == NULL )  return TCL_ERROR;
	Tk_GeometryRequest(tkwin, 100, 20);
d130 2
a131 2
	/* Run tk.tcl script */
	if( Tk_Init(interp) == TCL_ERROR )  return TCL_ERROR;
d133 2
a134 3
	/* Handle any delayed events which result */
	while (Tk_DoOneEvent(TK_DONT_WAIT | TK_ALL_EVENTS))
		;
d175 1
a175 1
	Tcl_Main( argc, argv, tcl_appinit );
d206 1
d225 8
a280 4

	/* Hack the scaling */
	minval = maxval * 0.001;
	maxval = maxval * 0.9;
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/spectrum.c,v 1.9 1996/02/28 03:21:17 mike Exp $ (ARL)";
d26 2
d45 66
d112 1
d143 1
d147 19
a165 6
	for( i = 0; i < spectrum->nwave; i++ )  {
		rt_log("%g um to %g um\n", spectrum->wavel[i] * 0.001,
			spectrum->wavel[i+1] * 0.001 );
		rescale(i);
		fb_writerect( fbp, 0, 0, width, height, pixels );
		fb_poll(fbp);
d167 29
a195 1
	return 0;
@
