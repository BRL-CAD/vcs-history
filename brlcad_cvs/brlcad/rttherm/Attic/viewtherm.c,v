head	1.43;
access;
symbols
	ansi-20040405-merged:1.38.2.2
	postmerge-20040405-ansi:1.41
	premerge-20040404-ansi:1.40
	postmerge-autoconf:1.40
	autoconf-freeze:1.39.2.2
	premerge-autoconf:1.40
	postmerge-20040315-windows:1.40
	premerge-20040315-windows:1.40
	windows-20040315-freeze:1.38.4.1
	autoconf-20031203:1.39
	autoconf-20031202:1.39
	autoconf-branch:1.39.0.2
	phong-branch:1.38.0.8
	photonmap-branch:1.38.0.6
	rel-6-1-DP:1.38
	windows-branch:1.38.0.4
	rel-6-0-2:1.36
	ansi-branch:1.38.0.2
	rel-6-0-1-branch:1.36.0.2
	hartley-6-0-post:1.37
	hartley-6-0-pre:1.36
	rel-6-0-1:1.36
	rel-6-0:1.36
	rel-5-4:1.33
	offsite-5-3-pre:1.34
	rel-5-3:1.33
	rel-5-2:1.33
	rel-5-1-branch:1.33.0.2
	rel-5-1:1.33
	rel-5-0:1.25
	rel-5-0-beta:1.23
	rel-4-5:1.12
	ctj-4-5-post:1.11
	ctj-4-5-pre:1.11;
locks; strict;
comment	@ * @;


1.43
date	2004.05.21.17.30.53;	author morrison;	state dead;
branches;
next	1.42;

1.42
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	1.41;

1.41
date	2004.04.05.05.45.59;	author morrison;	state Exp;
branches;
next	1.40;

1.40
date	2004.02.02.17.39.40;	author morrison;	state Exp;
branches;
next	1.39;

1.39
date	2003.09.27.00.00.40;	author morrison;	state Exp;
branches
	1.39.2.1;
next	1.38;

1.38
date	2002.08.20.17.08.42;	author jra;	state Exp;
branches
	1.38.2.1
	1.38.4.1;
next	1.37;

1.37
date	2002.08.15.20.55.52;	author hartley;	state Exp;
branches;
next	1.36;

1.36
date	2001.07.09.19.21.32;	author butler;	state Exp;
branches;
next	1.35;

1.35
date	2001.04.20.22.31.21;	author morrison;	state Exp;
branches;
next	1.34;

1.34
date	2000.08.03.21.04.54;	author butler;	state Exp;
branches;
next	1.33;

1.33
date	2000.02.04.01.22.24;	author mike;	state Exp;
branches;
next	1.32;

1.32
date	2000.02.04.00.14.03;	author mike;	state Exp;
branches;
next	1.31;

1.31
date	2000.02.03.21.00.14;	author mike;	state Exp;
branches;
next	1.30;

1.30
date	2000.02.03.20.49.03;	author mike;	state Exp;
branches;
next	1.29;

1.29
date	2000.01.21.22.12.41;	author butler;	state Exp;
branches;
next	1.28;

1.28
date	2000.01.20.23.03.35;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	2000.01.19.21.15.27;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	99.12.06.23.40.31;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	99.07.28.02.55.01;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	99.07.21.02.18.42;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	99.01.20.01.03.20;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	98.12.17.04.19.12;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	98.12.16.05.05.01;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	98.12.12.07.22.03;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	98.12.11.04.28.38;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	98.12.10.08.43.16;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	98.11.26.03.44.15;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	98.11.17.22.53.41;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	98.11.17.19.14.50;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	98.09.22.02.28.30;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	98.09.22.01.43.13;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	97.12.16.00.20.11;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	96.10.23.14.00.29;	author pjt;	state Exp;
branches;
next	1.10;

1.10
date	96.08.31.08.47.53;	author butler;	state Exp;
branches;
next	1.9;

1.9
date	96.08.30.00.08.21;	author butler;	state Exp;
branches;
next	1.8;

1.8
date	96.04.06.01.10.21;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	96.03.29.23.20.55;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	96.03.29.21.57.37;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	96.03.16.01.00.46;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	96.03.15.10.09.40;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	96.03.14.07.24.31;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	96.03.01.06.02.20;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	96.02.28.03.21.51;	author mike;	state Exp;
branches;
next	;

1.38.2.1
date	2002.09.19.18.02.19;	author morrison;	state Exp;
branches;
next	1.38.2.2;

1.38.2.2
date	2004.03.17.21.23.02;	author morrison;	state Exp;
branches;
next	;

1.38.4.1
date	2004.03.11.23.48.14;	author morrison;	state Exp;
branches;
next	;

1.39.2.1
date	2004.02.12.19.46.23;	author erikg;	state Exp;
branches;
next	1.39.2.2;

1.39.2.2
date	2004.03.15.14.08.08;	author erikg;	state Exp;
branches;
next	;


desc
@viewtherm.c
@


1.43
log
@moved to src/rttherm/
@
text
@/*
 *	./rttherm -P1 -s64 -o mtherm ../.db.6d/moss.g all.g
 *
 *			V I E W T H E R M . C
 *
 *	Ray Tracing Thermal Images.
 *
 *  Output is written to a file.
 *
 *  a_spectrum is pointer to returned spectral curve.
 *  When NULL, scanline buffer needs to be assigned/checked first.
 *  a_cumlen is distance to first non-atmospheric hit ("depth map").
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1996-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/rttherm/viewtherm.c,v 1.42 2004/05/10 15:30:49 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>

#ifdef HAVE_UNIX_IO
# include <sys/types.h>
# include <sys/stat.h>
#endif

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "mater.h"
#include "rtlist.h"
#include "raytrace.h"
#include "fb.h"
#include "spectrum.h"
#include "shadefuncs.h"
#include "shadework.h"
#include "../rt/ext.h"
#include "rtprivate.h"
#include "../rt/light.h"
#include "plot3.h"

extern int viewshade(struct application *ap, 
		     register const struct partition *pp,
		     register struct shadework *swp);

extern void multispectral_shader_init(struct mfuncs **headp);

/* XXX Move to raytrace.h when routine goes into LIBRT */
BU_EXTERN( double	rt_pixel_footprint, (const struct application *ap,
				const struct hit *hitp,
				const struct seg *segp,
				const vect_t normal));


/* XXX move to h/tabdata.h when function moves out of spectrum.c */
BU_EXTERN(struct bn_table	*bn_table_make_visible_and_uniform, (int num,
				double first, double last, int vis_nsamp));


int		use_air = 0;		/* Handling of air in librt */

char usage[] = "\
Usage:  rttherm [options] model.g objects...\n\
Options:\n\
 -c set spectrum=nsamp/lo_nm/hi_nm\n\
 -c set bg_temp=degK\n\
 -s #		Square grid size in pixels (default 512)\n\
 -w # -n #	Grid size width and height in pixels\n\
 -V #		View (pixel) aspect ratio (width/height)\n\
 -a #		Azimuth in deg\n\
 -e #		Elevation in deg\n\
 -M		Read matrix+cmds on stdin\n\
 -N #		NMG debug flags\n\
 -o model.ssamp	Output file\n\
 -x #		librt debug flags\n\
 -X #		rt debug flags\n\
 -p #		Perspective, degrees side to side\n\
 -P #		Set number of processors\n\
 -T #/#		Tolerance: distance/angular\n\
 -r		Report overlaps\n\
 -R		Do not report overlaps\n\
";

extern FBIO	*fbp;			/* Framebuffer handle */

extern int	max_bounces;		/* from refract.c */
extern int	max_ireflect;		/* from refract.c */
extern int	curframe;		/* from main.c */
extern fastf_t	frame_delta_t;		/* from main.c */

struct region	env_region;		/* environment map region */

void		free_scanlines(void);

/***** variables shared with rt.c *****/
extern char	*outputfile;		/* name of base of output file */
/***** end variables shared with rt.c *****/


static struct scanline {
	int	sl_left;		/* # pixels left on this scanline */
	char	*sl_buf;		/* ptr to scanline array of spectra */
} *scanline;

fastf_t	spectrum_param[3] = {
	100, 380, 12000			/* # samp, min nm, max nm */
};
fastf_t	bg_temp = 293;			/* degK.  20 degC = 293 degK */

struct mfuncs *mfHead = MF_NULL;	/* Head of list of shaders */

/* Viewing module specific "set" variables */
struct bu_structparse view_parse[] = {
	{"%f",  3, "spectrum",  (long)spectrum_param,		FUNC_NULL },
	{"%f",  1, "bg_temp",	(long)&bg_temp,			FUNC_NULL },
	{"%d",	1, "bounces",	(long)&max_bounces,		FUNC_NULL },
	{"",	0, (char *)0,	0,				FUNC_NULL }
};

/********* spectral parameters from libmultispectral *************/
extern const struct bn_table		*spectrum;	
extern struct bn_tabdata		*background;		/* radiant emittance of bg */
/********* spectral parameters from libmultispectral *************/

/*
 *  Ensure that a_spectrum points to a valid spectral curve.
 */
void
curve_attach(register struct application *ap)
{
	register struct scanline	*slp;

	RT_AP_CHECK(ap);
	RT_CK_RTI(ap->a_rt_i);

	if( ap->a_spectrum )  {
		BN_CK_TABDATA( ap->a_spectrum );
		return;
	}

	/* If scanline buffer has not yet been allocated, do so now */
	slp = &scanline[ap->a_y];
	bu_semaphore_acquire( RT_SEM_RESULTS );
	if( slp->sl_buf == (char *)0 )  {
		slp->sl_buf = (char *)bn_tabdata_malloc_array( spectrum, width );
	}
	bu_semaphore_release( RT_SEM_RESULTS );
	BN_CK_TABDATA( slp->sl_buf );	/* pun for first struct in array (sanity) */

	ap->a_spectrum = (struct bn_tabdata *)
		(slp->sl_buf+(ap->a_x*BN_SIZEOF_TABDATA(spectrum)));
	BN_CK_TABDATA( ap->a_spectrum );
	BU_ASSERT( ap->a_spectrum->table == spectrum );
}

/*
 *			B A C K G R O U N D _ R A D I A T I O N
 *
 *  Concoct _some_ kind of background radiation when the ray misses the
 *  model and there is no environment map defined.
 *  XXX For now this is a gross hack.
 */
void
background_radiation(struct application *ap)
{
	fastf_t	dist;
	fastf_t	radius;
	fastf_t	cm2;

	dist = 10000000.0;	/* 10 Km */
	radius = ap->a_rbeam + dist * ap->a_diverge;
	cm2 = 4 * radius * radius * 0.01;	/* mm2 to cm2 */

	curve_attach(ap);

	/* XXX This should be attenuated by some atmosphere now */
	/* At least it's in proper power units */
	bn_tabdata_scale( ap->a_spectrum, background, cm2 );
}

/*
 *  			V I E W _ P I X E L
 *  
 *  Arrange to have the pixel "output".
 *  For RTTHERM this is a misnomer, as the pixel's spectral samples have
 *  been living in the scanline buffer the whole time.
 *  When a scaline is completed (possibly not in sequence), write it to file.
 */
void
view_pixel(register struct application *ap)
{
	register struct scanline	*slp;
	register int	do_eol = 0;

	RT_AP_CHECK(ap);
	RT_CK_RTI(ap->a_rt_i);

	if( ap->a_user == 0 )  {
		/* Shot missed the model */
		background_radiation(ap);
	} else {
		if( !ap->a_spectrum )
			rt_bomb("view_pixel called with no spectral curve associated\n");
		BN_CK_TABDATA(ap->a_spectrum);
	}

	slp = &scanline[ap->a_y];
	bu_semaphore_acquire( RT_SEM_RESULTS );
	if( --(slp->sl_left) <= 0 )
		do_eol = 1;
	bu_semaphore_release( RT_SEM_RESULTS );

	if( !do_eol )  return;

	if( outfp != NULL )  {
		int	count;

		/* XXX This writes an array of structures out, including magic */
		/* XXX in machine-specific format */
		bu_semaphore_acquire( BU_SEM_SYSCALL );
		if( fseek( outfp, ap->a_y*(long)width*BN_SIZEOF_TABDATA(spectrum), 0 ) != 0 )
			rt_log("fseek error\n");
		count = fwrite( scanline[ap->a_y].sl_buf,
			BN_SIZEOF_TABDATA(spectrum), width, outfp );
		bu_semaphore_release( BU_SEM_SYSCALL );
		if( count != width )
			rt_bomb("view_pixel:  fwrite failure\n");
	}
#ifdef MSWISS
	if( fbp != FBIO_NULL ) {
		/* MSWISS -- real-time multi-spectral case */
		unsigned char obuf[4096];
		int i;
		char *line = (char *)scanline[ap->a_y].sl_buf;
		struct bn_tabdata *sp;
		int npix;

		/* Convert from spectral to monochrome image */
		extern double	filter_bias;	/* MSWISS: values set by rtnode.c */
		extern double	filter_gain;
		extern int	filter_freq_index;
/* Hack, re-equalize per line */
#if 1
{
double lo = INFINITY, hi = -INFINITY;
	for( i=0; i<width; i++ )  {
		register double tmp;
		sp = (struct bn_tabdata *)(line + i * BN_SIZEOF_TABDATA(spectrum));
		tmp = sp->y[filter_freq_index];
		if( tmp < lo ) lo = tmp;
		if( tmp > hi ) hi = tmp;
	}
	filter_bias = lo;
	filter_gain = 255/(hi-lo);
}
#endif

		BN_CK_TABDATA(line);
		BU_ASSERT( width < sizeof(obuf) );
		/* A variety of filters could be used here, eventually */
		for( i=0; i<width; i++ )  {
			register double tmp;
			sp = (struct bn_tabdata *)(line + i * BN_SIZEOF_TABDATA(spectrum));
			tmp = filter_gain *
				(sp->y[filter_freq_index] - filter_bias);
			if( tmp <= 0 )  obuf[i] = 0;
			else if( tmp >= 255 )  obuf[i] = 255;
			else obuf[i] = (unsigned char)tmp;
		}

		/* Output the scanline */
		bu_semaphore_acquire(BU_SEM_SYSCALL);
		npix = fb_bwwriterect(fbp, 0, ap->a_y, width, 1, obuf);
		bu_semaphore_release(BU_SEM_SYSCALL);
		BU_ASSERT( npix >= 1 );
	}
#endif /* MSWISS */
	rt_free( scanline[ap->a_y].sl_buf, "sl_buf scanline buffer" );
	scanline[ap->a_y].sl_buf = (char *)0;
}

/*
 *  			V I E W _ E O L
 *  
 *  This routine is not used;  view_pixel() determines when the last
 *  pixel of a scanline is really done, for parallel considerations.
 */
void
view_eol(register struct application *ap)
{
	return;
}

/*
 *			V I E W _ E N D
 */
void
view_end(struct application *ap)
{
	free_scanlines();
}

/*
 *			V I E W _ S E T U P
 *
 *  Called before rt_prep() in do.c
 */
void
view_setup(struct rt_i *rtip)
{
	register struct region *regp;

	RT_CHECK_RTI(rtip);
	/*
	 *  Initialize the material library for all regions.
	 *  As this may result in some regions being dropped,
	 *  (eg, light solids that become "implicit" -- non drawn),
	 *  this must be done before allowing the library to prep
	 *  itself.  This is a slight layering violation;  later it
	 *  may be clear how to repackage this operation.
	 */
	regp = BU_LIST_FIRST( region, &rtip->HeadRegion );
	while( BU_LIST_NOT_HEAD( regp, &rtip->HeadRegion ) )  {
		switch( mlib_setup( &mfHead, regp, rtip ) )  {
		case -1:
		default:
			rt_log("mlib_setup failure on %s\n", regp->reg_name);
			break;
		case 0:
			if(rdebug&RDEBUG_MATERIAL)
				rt_log("mlib_setup: drop region %s\n", regp->reg_name);
			{
				struct region *r = BU_LIST_NEXT( region, &regp->l );
				/* zap reg_udata? beware of light structs */
				rt_del_regtree( rtip, regp, &rt_uniresource );
				regp = r;
				continue;
			}
		case 1:
			/* Full success */
			if( rdebug&RDEBUG_MATERIAL &&
			    ((struct mfuncs *)(regp->reg_mfuncs))->mf_print )  {
				((struct mfuncs *)(regp->reg_mfuncs))->
					mf_print( regp, regp->reg_udata );
			}
			/* Perhaps this should be a function? */
			break;
		}
		regp = BU_LIST_NEXT( region, &regp->l );
	}
}

/*
 *			V I E W _ C L E A N U P
 *
 *  Called before rt_clean() in do.c
 */
void
view_cleanup(struct rt_i *rtip)
{
	register struct region	*regp;

	RT_CHECK_RTI(rtip);

	for( BU_LIST_FOR( regp, region, &(rtip->HeadRegion) ) )  {
		mlib_free( regp );
	}
	if( env_region.reg_mfuncs )  {
		rt_free( (char *)env_region.reg_name, "env_region.reg_name" );
		env_region.reg_name = (char *)0;
		mlib_free( &env_region );
	}

	light_cleanup();
}

/*
 *			H I T _ N O T H I N G
 *
 *  a_miss() routine called when no part of the model is hit.
 *  Background texture mapping could be done here.
 *  For now, return a pleasant dark blue.
 */
static int 
hit_nothing(register struct application *ap)
{
	if( rdebug&RDEBUG_MISSPLOT )  {
		vect_t	out;

		/* XXX length should be 1 model diameter */
		VJOIN1( out, ap->a_ray.r_pt,
			10000, ap->a_ray.r_dir );	/* to imply direction */
		pl_color( stdout, 190, 0, 0 );
		pdv_3line( stdout, ap->a_ray.r_pt, out );
	}

	if( env_region.reg_mfuncs )  {
		struct gunk {
			struct partition part;
			struct hit	hit;
			struct shadework sw;
		} u;

		memset((char *)&u, 0, sizeof(u) );

		/* Make "miss" hit the environment map */
		/* Build up the fakery */
		u.part.pt_inhit = u.part.pt_outhit = &u.hit;
		u.part.pt_regionp = &env_region;
		u.hit.hit_dist = ap->a_rt_i->rti_radius * 2;	/* model diam */

		u.sw.sw_transmit = u.sw.sw_reflect = 0.0;
		u.sw.sw_refrac_index = 1.0;
		u.sw.sw_extinction = 0;
		u.sw.sw_xmitonly = 1;		/* don't shade env map! */

		/* "Surface" Normal points inward, UV is azim/elev of ray */
		u.sw.sw_inputs = MFI_NORMAL|MFI_UV;
		VREVERSE( u.sw.sw_hit.hit_normal, ap->a_ray.r_dir );
		/* U is azimuth, atan() range: -pi to +pi */
		u.sw.sw_uv.uv_u = mat_atan2( ap->a_ray.r_dir[Y],
			ap->a_ray.r_dir[X] ) * rt_inv2pi;
		if( u.sw.sw_uv.uv_u < 0 )
			u.sw.sw_uv.uv_u += 1.0;
		/*
		 *  V is elevation, atan() range: -pi/2 to +pi/2,
		 *  because sqrt() ensures that X parameter is always >0
		 */
		u.sw.sw_uv.uv_v = mat_atan2( ap->a_ray.r_dir[Z],
			sqrt( ap->a_ray.r_dir[X] * ap->a_ray.r_dir[X] +
			ap->a_ray.r_dir[Y] * ap->a_ray.r_dir[Y]) ) *
			rt_invpi + 0.5;
		u.sw.sw_uv.uv_du = u.sw.sw_uv.uv_dv = 0;

		u.sw.msw_color = bn_tabdata_get_constval( 1.0, spectrum );
		u.sw.msw_basecolor = bn_tabdata_get_constval( 1.0, spectrum );

		if (rdebug&RDEBUG_SHADE)
			rt_log("hit_nothing calling viewshade\n");

		(void)viewshade( ap, &u.part, &u.sw );

		bn_tabdata_copy( ap->a_spectrum, u.sw.msw_color );
		ap->a_user = 1;		/* Signal view_pixel:  HIT */
		ap->a_uptr = (genptr_t)&env_region;
		return(1);
	}

	ap->a_user = 0;		/* Signal view_pixel:  MISS */
	background_radiation(ap);	/* In case someone looks */
	return(0);
}

/*
 *			C O L O R V I E W
 *
 *  Manage the coloring of whatever it was we just hit.
 *  This can be a recursive procedure.
 */
int
colorview(register struct application *ap, struct partition *PartHeadp, struct seg *finished_segs)
{
	register struct partition *pp;
	register struct hit *hitp;
	struct shadework sw;

	sw.msw_color = BN_TABDATA_NULL;

	for( pp=PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )
		if( pp->pt_outhit->hit_dist >= 0.0 )  break;
	if( pp == PartHeadp )  {
		rt_log("colorview:  no hit out front?\n");
		return(0);
	}
	hitp = pp->pt_inhit;
	ap->a_uptr = (genptr_t)pp->pt_regionp;	/* note which region was shaded */

	if(rdebug&RDEBUG_HITS)  {
		rt_log("colorview: lvl=%d coloring %s\n",
			ap->a_level,
			pp->pt_regionp->reg_name);
		rt_pr_pt( ap->a_rt_i, pp );
	}
	if( hitp->hit_dist >= INFINITY )  {
		rt_log("colorview:  entry beyond infinity\n");
		background_radiation(ap);	/* was VSET( ap->a_color, .5, 0, 0 ); */
		ap->a_user = 1;		/* Signal view_pixel:  HIT */
		ap->a_dist = hitp->hit_dist;
		goto out;
	}

	/* Check to see if eye is "inside" the solid */
	/* It might only be worthwhile doing all this in perspective mode */
	/* XXX Note that hit_dist can be faintly negative, e.g. -1e-13 */

	if( hitp->hit_dist < 0.0 && pp->pt_regionp->reg_aircode == 0 ) {
		struct application sub_ap;
		FAST fastf_t f;

		if( pp->pt_outhit->hit_dist >= INFINITY ||
		    ap->a_level > max_bounces )  {
			bu_log("colorview:  eye inside %s (x=%d, y=%d, lvl=%d)\n",
				pp->pt_regionp->reg_name,
				ap->a_x, ap->a_y, ap->a_level);
		    	background_radiation(ap);	/* was: VSETALL( ap->a_color, 0.18 ); */
			ap->a_user = 1;		/* Signal view_pixel:  HIT */
			ap->a_dist = hitp->hit_dist;
			goto out;
		}
		/* Push on to exit point, and trace on from there */
		sub_ap = *ap;	/* struct copy */
		sub_ap.a_level = ap->a_level+1;
		curve_attach(ap);
		sub_ap.a_spectrum = bn_tabdata_dup( ap->a_spectrum );

		f = pp->pt_outhit->hit_dist+0.0001;
		VJOIN1(sub_ap.a_ray.r_pt, ap->a_ray.r_pt, f, ap->a_ray.r_dir);
		sub_ap.a_purpose = "pushed eye position";
		(void)rt_shootray( &sub_ap );

		/* The eye is inside a solid and we are "Looking out" so
		 * we are going to darken what we see beyond to give a visual
		 * cue that something is wrong.
		 */
		bn_tabdata_scale( ap->a_spectrum, sub_ap.a_spectrum, 0.80 );
		bu_free( sub_ap.a_spectrum, "bn_tabdata *a_spectrum");

		ap->a_user = 1;		/* Signal view_pixel: HIT */
		ap->a_dist = f + sub_ap.a_dist;
		ap->a_uptr = sub_ap.a_uptr;	/* which region */
		goto out;
	}

	if( rdebug&RDEBUG_RAYWRITE )  {
		/* Record the approach path */
		if( hitp->hit_dist > 0.0001 )  {
			VJOIN1( hitp->hit_point, ap->a_ray.r_pt,
				hitp->hit_dist, ap->a_ray.r_dir );
			wraypts( ap->a_ray.r_pt,
				ap->a_ray.r_dir,
				hitp->hit_point,
				-1, ap, stdout );	/* -1 = air */
		}
	}
	if( rdebug&RDEBUG_RAYPLOT )  {
		/*  There are two parts to plot here.
		 *  Ray start to inhit (purple),
		 *  and inhit to outhit (grey).
		 */
		if( hitp->hit_dist > 0.0001 )  {
			register int i, lvl;
			fastf_t out;
			vect_t inhit, outhit;

			lvl = ap->a_level % 100;
			if( lvl < 0 )  lvl = 0;
			else if( lvl > 3 )  lvl = 3;
			i = 255 - lvl * (128/4);

			VJOIN1( inhit, ap->a_ray.r_pt,
				hitp->hit_dist, ap->a_ray.r_dir );
			pl_color( stdout, i, 0, i );
			pdv_3line( stdout, ap->a_ray.r_pt, inhit );

			if( (out = pp->pt_outhit->hit_dist) >= INFINITY )
				out = 10000;	/* to imply the direction */
			VJOIN1( outhit,
				ap->a_ray.r_pt, out,
				ap->a_ray.r_dir );
			pl_color( stdout, i, i, i );
			pdv_3line( stdout, inhit, outhit );
		}
	}

	if( !ap->a_spectrum )  curve_attach(ap);
/* XXX This is the right way to do this, but isn't quite ready yet. */
	memset( (char *)&sw, 0, sizeof(sw) );
	sw.sw_transmit = sw.sw_reflect = 0.0;
	sw.sw_refrac_index = 1.0;
	sw.sw_extinction = 0;
	sw.sw_xmitonly = 0;		/* want full data */
	sw.sw_inputs = 0;		/* no fields filled yet */
	sw.sw_frame = curframe;
	sw.sw_pixeltime = sw.sw_frametime = curframe * frame_delta_t;
	sw.msw_color = bn_tabdata_get_constval( 1.0, spectrum );
	sw.msw_basecolor = bn_tabdata_get_constval( 1.0, spectrum );
	if( pp->pt_regionp->reg_mater.ma_temperature > 0 )
		sw.sw_temperature = pp->pt_regionp->reg_mater.ma_temperature;
	else
		sw.sw_temperature = bg_temp;

	if (rdebug&RDEBUG_SHADE)
		rt_log("colorview calling viewshade, temp=%g\n", sw.sw_temperature);
if (rdebug&RDEBUG_SHADE) pr_shadework( "shadework before viewshade", &sw);

	(void)viewshade( ap, pp, &sw );
if (rdebug&RDEBUG_SHADE) pr_shadework( "shadework after viewshade", &sw);
	if (rdebug&RDEBUG_SHADE)
		rt_log("after viewshade, temp=%g\n", sw.sw_temperature);

	/* individual shaders must handle reflection & refraction */

	/* bn_tabdata_copy( ap->a_spectrum, sw.msw_color ); */
	rt_spect_black_body( sw.msw_basecolor, sw.sw_temperature, 3 );
	bn_tabdata_add( ap->a_spectrum, sw.msw_color, sw.msw_basecolor );

	ap->a_user = 1;		/* Signal view_pixel:  HIT */
	/* XXX This is always negative when eye is inside air solid */
	ap->a_dist = hitp->hit_dist;

	bu_free( sw.msw_color, "sw.msw_color");
	bu_free( sw.msw_basecolor, "sw.msw_basecolor");

out:
	RT_CK_REGION(ap->a_uptr);
	if(rdebug&RDEBUG_HITS)  {
		bu_log("colorview: lvl=%d ret a_user=%d %s\n",
			ap->a_level,
			ap->a_user,
			pp->pt_regionp->reg_name);
		bn_pr_tabdata("a_spectrum", ap->a_spectrum );
	}
	return(1);
}

void
free_scanlines(void)
{
	register int	y;

	for( y=0; y<height; y++ )  {
		if( scanline[y].sl_buf )  {
			rt_free( scanline[y].sl_buf, "sl_buf scanline buffer" );
			scanline[y].sl_buf = (char *)0;
		}
	}
	rt_free( (char *)scanline, "struct scanline[height]" );
	scanline = (struct scanline *)0;
}

/*
 *  			V I E W _ I N I T
 *
 *  Called once, early on in RT setup, before view size is set.
 */
int
view_init(register struct application *ap, char *file, char *obj, int minus_o)
{
	extern char	libmultispectral_version[];

	bu_log("%s", libmultispectral_version+5);

	multispectral_shader_init(&mfHead);	/* in libmultispectral/init.c */

	bu_struct_print( "rttherm variables", view_parse, NULL );

	if( !minus_o )   {
		bu_bomb("rttherm: No -o flag specified, can't write to framebuffer, aborting\n");
		exit(2);
	}

	/* Build spectrum definition */
	spectrum = bn_table_make_visible_and_uniform( (int)spectrum_param[0],
		spectrum_param[1], spectrum_param[2], 20 );

	/* Output is destined for a file */
	return 0;		/* don't open framebuffer */
}

/*
 *  			V I E W _ 2 I N I T
 *
 *  Called each time a new image is about to be done.
 */
void
view_2init(register struct application *ap, char *framename)
{
	register int i;
	struct bu_vls	name;

	ap->a_refrac_index = 1.0;	/* RI_AIR -- might be water? */
	ap->a_cumlen = 0.0;
	ap->a_miss = hit_nothing;
	if (rpt_overlap)
		ap->a_overlap = RT_AFN_NULL;
	else
		ap->a_overlap = rt_overlap_quietly;
	if (use_air)
		ap->a_onehit = 3;
	else
		ap->a_onehit = 1;

	/* Always allocate the scanline[] array
	 * (unless we already have one in incremental mode)
	 */
	if( !incr_mode || !scanline )
	{
		if( scanline )  free_scanlines();
		scanline = (struct scanline *)rt_calloc(
			height, sizeof(struct scanline),
			"struct scanline[height]" );
	}

	/* Extra 2nd file!  Write out spectrum info */
	bu_vls_init( &name );
	bu_vls_printf( &name, "%s.spect", framename ? framename : "RTTHERM" );
	bn_table_write( bu_vls_addr(&name), spectrum );
	bu_log("Wrote %s\n", bu_vls_addr(&name) );
	bu_vls_free( &name );

	/* Check for existing file and checkpoint-restart? */

	rt_log("Dynamic scanline buffering\n");
	for( i=0; i<height; i++ )
		scanline[i].sl_left = width;

	switch( lightmodel )  {
	case 0:
		ap->a_hit = colorview;
		/* If present, use user-specified light solids */
		if( RT_LIST_IS_EMPTY( &(LightHead.l) )  ||
		    RT_LIST_UNINITIALIZED( &(LightHead.l ) ) )  {
			if(rdebug&RDEBUG_SHOWERR)rt_log("No explicit light\n");
			light_maker(1, view2model);
		}
		break;
	default:
		rt_bomb("bad lighting model #");
	}
	ap->a_rt_i->rti_nlights = light_init(ap);

	/* Compute radiant emittance of background */
	/* XXX This is wrong, need actual power (radiant flux) emitted */
	BN_GET_TABDATA( background, spectrum );
	rt_spect_black_body( background, bg_temp, 9 );
}

/*
 *  		A P P L I C A T I O N _ I N I T
 *
 *  Called once, very early on in RT setup, even before command line
 *	is processed.
 */
void application_init (void)
{
    rpt_overlap = 1;
}


/* --- */

/*
 *
 *  hitp->hit_point and normal must be computed by caller.
 * 
 *  Return -
 *	area of ray footprint, in mm**2 (square milimeters).
 */
double
rt_pixel_footprint(const struct application *ap, const struct hit *hitp, const struct seg *segp, const fastf_t *normal)
{
	plane_t	perp;
	plane_t	surf_tan;
	fastf_t	h_radius, v_radius;
	point_t	corners[4];
	fastf_t	norm_dist;
	fastf_t	area;
	int	i;

	/*  If surface normal is nearly perpendicular to ray,
	 *  (i.e. ray is parallel to surface), abort
	 */
	if( fabs(VDOT(ap->a_ray.r_dir, normal)) <= 1.0e-10 )  {
parallel:
		rt_log("rt_pixel_footprint() ray parallel to surface\n");	/* debug */
		return 0;
	}

	/*  Compute H and V "radius" of the footprint along
	 *  a plane perpendicular to the ray direction.
	 *  Find the 4 corners of the footprint on this perpendicular plane.
	 */
	mat_vec_perp( perp, ap->a_ray.r_dir );
	perp[3] = VDOT( perp, hitp->hit_point );

	h_radius = ap->a_rbeam + hitp->hit_dist * ap->a_diverge;
	v_radius = ap->a_rbeam + hitp->hit_dist * ap->a_diverge * cell_width / cell_height;

	VJOIN2( corners[0], hitp->hit_point,
		 h_radius, dx_model,  v_radius, dy_model );	/* UR */
	VJOIN2( corners[1], hitp->hit_point,
		-h_radius, dx_model,  v_radius, dy_model );	/* UL */
	VJOIN2( corners[2], hitp->hit_point,
		-h_radius, dx_model, -v_radius, dy_model );	/* LL */
	VJOIN2( corners[3], hitp->hit_point,
		 h_radius, dx_model, -v_radius, dy_model );	/* LR */

	/* Approximate surface at hit point by a (tangent) plane */
	VMOVE( surf_tan, normal );
	surf_tan[3] = VDOT( surf_tan, hitp->hit_point );

	/*
	 *  Form a line from ray start point to each corner point,
	 *  compute intersection with tangent plane,
	 *  replace corner point with new point on tangent plane.
	 */
	norm_dist = DIST_PT_PLANE( ap->a_ray.r_pt, surf_tan );
	for( i=0; i<4; i++ )  {
		fastf_t		slant_factor;	/* Direction dot Normal */
		vect_t		dir;
		fastf_t		dist;

		/* XXX sanity check */
		dist = DIST_PT_PT( corners[i], segp->seg_stp->st_center );
		if( dist > segp->seg_stp->st_bradius )
			rt_log(" rt_pixel_footprint() dist = %g > radius = %g\n", dist, segp->seg_stp->st_bradius );

		VSUB2( dir, corners[i], ap->a_ray.r_pt );
		VUNITIZE(dir);
		if( (slant_factor = -VDOT( surf_tan, dir )) < -1.0e-10 ||
		     slant_factor > 1.0e-10 )  {
			dist = norm_dist / slant_factor;
			if( !NEAR_ZERO(dist, INFINITY) )
				goto parallel;
		} else {
			goto parallel;
		}
		VJOIN1( corners[i], ap->a_ray.r_pt, dist, dir );
	}

	/* Find area of 012, and 230 triangles */
	area = rt_area_of_triangle( corners[0], corners[1], corners[2] );
	area += rt_area_of_triangle( corners[2], corners[3], corners[0] );
	return area;
}
@


1.42
log
@change conf.h to a wrapped config.h
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/rttherm/viewtherm.c,v 1.41 2004/04/05 05:45:59 morrison Exp $ (ARL)";
@


1.41
log
@merge of ansi-6-0-branch into head
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d34 5
a38 1
#include "conf.h"
@


1.40
log
@update copyright to include span through 2003
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/viewtherm.c,v 1.39 2003/09/27 00:00:40 morrison Exp $ (ARL)";
d110 1
a110 1
void		free_scanlines();
d146 1
a146 2
curve_attach(ap)
register struct application *ap;
d181 1
a181 2
background_radiation( ap )
struct application *ap;
d207 1
a207 2
view_pixel(ap)
register struct application *ap;
d306 1
a306 2
view_eol(ap)
register struct application *ap;
d315 1
a315 2
view_end(ap)
struct application *ap;
d326 1
a326 2
view_setup(rtip)
struct rt_i	*rtip;
d376 1
a376 2
view_cleanup(rtip)
struct rt_i	*rtip;
d402 1
a402 2
hit_nothing( ap )
register struct application *ap;
d478 1
a478 4
colorview( ap, PartHeadp, finished_segs )
register struct application *ap;
struct partition *PartHeadp;
struct seg *finished_segs;
d644 1
a644 1
free_scanlines()
d664 1
a664 3
view_init( ap, file, obj, minus_o )
register struct application *ap;
char *file, *obj;
d693 1
a693 3
view_2init( ap, framename )
register struct application *ap;
char	*framename;
d761 1
a761 1
void application_init ()
d777 1
a777 5
rt_pixel_footprint(ap, hitp, segp, normal)
const struct application *ap;
const struct hit	*hitp;
const struct seg	*segp;
const vect_t		normal;
@


1.39
log
@spectrum and background globals are moved into libmultispectral
@
text
@d27 1
a27 1
 *	This software is Copyright (C) 1996 by the United States Army
d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/viewtherm.c,v 1.38 2002/08/20 17:08:42 jra Exp $ (ARL)";
@


1.39.2.1
log
@merge from HEAD
@
text
@d27 1
a27 1
 *	This software is Copyright (C) 1996-2004 by the United States Army
d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/viewtherm.c,v 1.40 2004/02/02 17:39:40 morrison Exp $ (ARL)";
@


1.39.2.2
log
@merge from head
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/viewtherm.c,v 1.39.2.1 2004/02/12 19:46:23 erikg Exp $ (ARL)";
@


1.38
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/viewtherm.c,v 1.36 2001/07/09 19:21:32 butler Exp $ (ARL)";
d137 4
a140 4
/********* spectral parameters *************/
const struct bn_table		*spectrum;	/* definition of spectrum */
struct bn_tabdata		*background;		/* radiant emittance of bg */
/********* spectral parameters *************/
@


1.38.4.1
log
@sync to HEAD...
@
text
@d27 1
a27 1
 *	This software is Copyright (C) 1996-2004 by the United States Army
d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/rttherm/viewtherm.c,v 1.40 2004/02/02 17:39:40 morrison Exp $ (ARL)";
d137 4
a140 4
/********* spectral parameters from libmultispectral *************/
extern const struct bn_table		*spectrum;	
extern struct bn_tabdata		*background;		/* radiant emittance of bg */
/********* spectral parameters from libmultispectral *************/
@


1.38.2.1
log
@Initial ANSIfication
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/viewtherm.c,v 1.38 2002/08/20 17:08:42 jra Exp $ (ARL)";
d110 1
a110 1
void		free_scanlines(void);
d146 2
a147 1
curve_attach(register struct application *ap)
d182 2
a183 1
background_radiation(struct application *ap)
d209 2
a210 1
view_pixel(register struct application *ap)
d309 2
a310 1
view_eol(register struct application *ap)
d319 2
a320 1
view_end(struct application *ap)
d331 2
a332 1
view_setup(struct rt_i *rtip)
d382 2
a383 1
view_cleanup(struct rt_i *rtip)
d409 2
a410 1
hit_nothing(register struct application *ap)
d486 4
a489 1
colorview(register struct application *ap, struct partition *PartHeadp, struct seg *finished_segs)
d655 1
a655 1
free_scanlines(void)
d675 3
a677 1
view_init(register struct application *ap, char *file, char *obj, int minus_o)
d706 3
a708 1
view_2init(register struct application *ap, char *framename)
d776 1
a776 1
void application_init (void)
d792 5
a796 1
rt_pixel_footprint(const struct application *ap, const struct hit *hitp, const struct seg *segp, const fastf_t *normal)
@


1.38.2.2
log
@sync branch with HEAD
@
text
@d27 1
a27 1
 *	This software is Copyright (C) 1996-2004 by the United States Army
d31 1
a31 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d137 4
a140 4
/********* spectral parameters from libmultispectral *************/
extern const struct bn_table		*spectrum;	
extern struct bn_tabdata		*background;		/* radiant emittance of bg */
/********* spectral parameters from libmultispectral *************/
@


1.37
log
@Converted from K&R to ANSI C - RFH
@
text
@d110 1
a110 1
void		free_scanlines(void);
d146 2
a147 1
curve_attach(register struct application *ap)
d182 2
a183 1
background_radiation(struct application *ap)
d209 2
a210 1
view_pixel(register struct application *ap)
d309 2
a310 1
view_eol(register struct application *ap)
d319 2
a320 1
view_end(struct application *ap)
d331 2
a332 1
view_setup(struct rt_i *rtip)
d382 2
a383 1
view_cleanup(struct rt_i *rtip)
d409 2
a410 1
hit_nothing(register struct application *ap)
d486 4
a489 1
colorview(register struct application *ap, struct partition *PartHeadp, struct seg *finished_segs)
d655 1
a655 1
free_scanlines(void)
d675 3
a677 1
view_init(register struct application *ap, char *file, char *obj, int minus_o)
d706 3
a708 1
view_2init(register struct application *ap, char *framename)
d776 1
a776 1
void application_init (void)
d792 5
a796 1
rt_pixel_footprint(const struct application *ap, const struct hit *hitp, const struct seg *segp, const fastf_t *normal)
@


1.36
log
@various lint cleanup for compilation on FreeBSD
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/viewtherm.c,v 1.35 2001/04/20 22:31:21 morrison Exp $ (ARL)";
d110 1
a110 1
void		free_scanlines();
d146 1
a146 2
curve_attach(ap)
register struct application *ap;
d181 1
a181 2
background_radiation( ap )
struct application *ap;
d207 1
a207 2
view_pixel(ap)
register struct application *ap;
d306 1
a306 2
view_eol(ap)
register struct application *ap;
d315 1
a315 2
view_end(ap)
struct application *ap;
d326 1
a326 2
view_setup(rtip)
struct rt_i	*rtip;
d376 1
a376 2
view_cleanup(rtip)
struct rt_i	*rtip;
d402 1
a402 2
hit_nothing( ap )
register struct application *ap;
d478 1
a478 4
colorview( ap, PartHeadp, finished_segs )
register struct application *ap;
struct partition *PartHeadp;
struct seg *finished_segs;
d644 1
a644 1
free_scanlines()
d664 1
a664 3
view_init( ap, file, obj, minus_o )
register struct application *ap;
char *file, *obj;
d693 1
a693 3
view_2init( ap, framename )
register struct application *ap;
char	*framename;
d761 1
a761 1
void application_init ()
d777 1
a777 5
rt_pixel_footprint(ap, hitp, segp, normal)
const struct application *ap;
const struct hit	*hitp;
const struct seg	*segp;
const vect_t		normal;
@


1.35
log
@CONST to const
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/viewtherm.c,v 1.34 2000/08/03 21:04:54 butler Exp $ (ARL)";
d57 7
d358 1
a358 1
				rt_del_regtree( rtip, regp );
d408 2
a409 1
static hit_nothing( ap )
d429 2
a430 1
		bzero( (char *)&u, sizeof(u) );
d605 1
a605 1
	bzero( (char *)&sw, sizeof(sw) );
d674 1
@


1.34
log
@changes for compilation with rtprivate.h and new, stricter compiler warning
messages
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/viewtherm.c,v 1.33 2000/02/04 01:22:24 mike Exp $ (ARL)";
d59 4
a62 4
BU_EXTERN( double	rt_pixel_footprint, (CONST struct application *ap,
				CONST struct hit *hitp,
				CONST struct seg *segp,
				CONST vect_t normal));
d131 1
a131 1
CONST struct bn_table		*spectrum;	/* definition of spectrum */
d783 4
a786 4
CONST struct application *ap;
CONST struct hit	*hitp;
CONST struct seg	*segp;
CONST vect_t		normal;
@


1.33
log
@
Generate .spect files which include the frame numbers.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/viewtherm.c,v 1.32 2000/02/04 00:14:03 mike Exp $ (ARL)";
d55 1
a55 1
#include "../rt/rdebug.h"
d311 1
a315 1
	return(0);		/* OK */
d752 1
a752 1
	ap->a_rt_i->rti_nlights = light_init();
@


1.32
log
@
Clarified usage message
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/viewtherm.c,v 1.31 2000/02/03 21:00:14 mike Exp $ (ARL)";
a668 1
	struct rt_vls	name;
d677 5
d686 2
a687 12
	rt_vls_init( &name );
	rt_vls_printf( &name, "%s.spect", outputfile ? outputfile : "RTTHERM" );
	bn_table_write( rt_vls_addr(&name), spectrum );
	rt_vls_free( &name );

	if( minus_o )  {
		/* Output is destined for a file */
		return(0);		/* don't open framebuffer */
	}
	bu_bomb("rttherm: No -o flag specified, can't write to framebuffer, aborting\n");
	exit(2);
	/* NOTREACHED */
d701 1
d725 7
@


1.31
log
@
Added comment
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/viewtherm.c,v 1.30 2000/02/03 20:49:03 mike Exp $ (ARL)";
d75 2
a76 2
 -C spectrum=nsamp/lo_nm/hi_nm\n\
 -C bg_temp=degK\n\
@


1.30
log
@
Removed #ifdef'ed out code
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/viewtherm.c,v 1.29 2000/01/21 22:12:41 butler Exp $ (ARL)";
d730 2
@


1.29
log
@removed delarations of unused variables
@
text
@a0 1
#define NO_MATER 1
d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/viewtherm.c,v 1.28 2000/01/20 23:03:35 mike Exp $ (ARL)";
a337 1
#if NO_MATER
a366 1
#endif
d381 1
a381 1
#if NO_MATER
a391 1
#endif
a413 1
#if NO_MATER
a463 1
#endif
a483 1
#if NO_MATER
a484 1
#endif
a485 1
#if NO_MATER
a486 1
#endif
a593 1
#if NO_MATER
a631 56
#else

	/* XXX This is all temporary and doesn't belong here */
	/* +++++ Something was hit, get the power from it. ++++++ */
	/*
	 *  The temperature gives us the radiant emittance in W/cm**2.
	 *  The ray footprint indicates how many mm**2.
	 *  The solid angle of the pixel from the hit point / 4pi
	 *  says how much of the emitted power is going our way.
	 */
	if( !ap->a_spectrum )  curve_attach(ap);
	pixelp = ap->a_spectrum;
	BN_CK_TABDATA(pixelp);

	degK = 10000;	/* XXX extract from region! */
degK = 700;

	VJOIN1( hitp->hit_point, ap->a_ray.r_pt,
		hitp->hit_dist, ap->a_ray.r_dir );
	RT_HIT_NORMAL( normal, hitp, pp->pt_inseg->seg_stp, &(ap->a_ray), pp->pt_inflip );

	cm2 = rt_pixel_footprint(ap, hitp, pp->pt_inseg, normal) * 0.01;	/* mm**2 to cm**2 */

	/* To convert slanted surface to equivalent perp area */
	cosine = -VDOT( normal, ap->a_ray.r_dir );
	if( cosine < 0 )  rt_log("cosine = %g < 0\n", cosine);

	/*  Fraction of a surrounding sphere which the pixel occupies,
	 *  from point of view of the hit point.  (Solid angle)
	 *  For long distances, this is ~= area of pixel / (4pi * r**2)
	 *  Since surface only radiates on one side, use hemisphere (2pi).
	 */
	powerfrac = cell_width * cell_height /
		(hitp->hit_dist * hitp->hit_dist * rt_twopi);
	if( powerfrac > 1 )  {
		rt_log("powerfrac = %g\n", powerfrac);
		powerfrac = 1;
	}

	rt_spect_black_body( pixelp, degK, 3 );
#if 1
if( cosine < 0.2 ) rt_log("@@@@@@@@@@@@\n");
if( cm2 > 10 ) rt_log("****\n");
rt_log("area=%g, cos = %g, a*c = %g, pfrac = %g\n", cm2, cosine, cm2*cosine, powerfrac );
powerfrac = 1;
#endif
	bn_tabdata_scale( pixelp, pixelp, cm2 * cosine * powerfrac );

	/* Spectrum is now in terms of Watts of power radiating
	 * on the path to this pixel.
	 * Next, it should encounter some atmosphere along the way.
	 */
	/* XXX Even a little Beers Law would be tasty here */

	ap->a_user = 1;		/* Signal view_pixel:  HIT */
#endif
a737 1
#if NO_MATER
a743 1
#endif
a747 1
#if NO_MATER
a748 1
#endif
@


1.28
log
@
Gives error message if not invoked with -o
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/viewtherm.c,v 1.27 2000/01/19 21:15:27 mike Exp $ (ARL)";
a205 1
	register int	r,g,b;
a492 6
	fastf_t		degK;
	fastf_t		cm2;
	fastf_t		cosine;
	fastf_t		powerfrac;
	struct bn_tabdata	*pixelp;
	vect_t		normal;
a773 3
#ifdef HAVE_UNIX_IO
	struct stat sb;
#endif
@


1.27
log
@
reg_forw is now a bu_list
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/viewtherm.c,v 1.26 1999/12/06 23:40:31 mike Exp $ (ARL)";
d765 3
a767 6
	if (rpt_dist)
	{
		bu_log("Warning: -d ignored.  Writing to frame buffer\n");
		rpt_dist = 0;
	}
	return(1);		/* open a framebuffer */
@


1.26
log
@
mathtab.[ch] doesn't exist in rt/ any more.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/viewtherm.c,v 1.25 1999/07/28 02:55:01 mike Exp $ (ARL)";
d341 2
a342 1
	for( regp=rtip->HeadRegion; regp != REGION_NULL; )  {
d352 1
a352 1
				struct region *r = regp->reg_forw;
d368 1
a368 1
		regp = regp->reg_forw;
d386 1
a386 1
	for( regp=rtip->HeadRegion; regp != REGION_NULL; regp=regp->reg_forw )  {
@


1.25
log
@
working version
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/viewtherm.c,v 1.24 1999/07/21 02:18:42 mike Exp $ (ARL)";
a56 1
#include "../rt/mathtab.h"
@


1.24
log
@
Initial MSWISS support
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/viewtherm.c,v 1.23 1999/01/20 01:03:20 mike Exp $ (ARL)";
d250 2
a251 2
		struct bn_tabdata *line = (struct bn_tabdata *)
			scanline[ap->a_y].sl_buf;
d259 1
d263 3
a265 1
		register double tmp = line[i].y[filter_freq_index];
a270 1
fprintf(stderr,"y=%d, freq=%d, lo=%g, hi=%g\n", ap->a_y, filter_freq_index, lo, hi);
d272 1
d279 1
d281 1
a281 1
				(line[i].y[filter_freq_index] - filter_bias);
a285 1
		obuf[ap->a_y] = ap->a_y;	/* debug */
@


1.23
log
@Account for temperature
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/viewtherm.c,v 1.22 1998/12/17 04:19:12 mike Exp $ (ARL)";
d96 2
d245 46
d758 10
a767 3
	/* Output is destined for a file */
	output_is_binary = 1;
	return(0);		/* don't open framebuffer */
d771 1
a771 1
 *  			V I E W 2 _ I N I T
@


1.22
log
@Regions now have an associated temperature
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/viewtherm.c,v 1.21 1998/12/16 05:05:01 mike Exp $ (ARL)";
d579 1
a579 1
		rt_log("colorview calling viewshade\n");
d584 2
d589 4
a592 1
	bn_tabdata_copy( ap->a_spectrum, sw.msw_color );
@


1.21
log
@This version produced the first multi-spectral Phong rendering
without dumping core.
More remains to be done.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/viewtherm.c,v 1.20 1998/12/12 07:22:03 mike Exp $ (ARL)";
d573 4
@


1.20
log
@Changed from rt_tabdata to bn_tabdata
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/viewtherm.c,v 1.19 1998/12/11 04:28:38 mike Exp $ (ARL)";
d168 26
a212 4
		fastf_t	dist;
		fastf_t	radius;
		fastf_t	cm2;

d214 1
a214 9
		dist = 10000000.0;	/* 10 Km */
		radius = ap->a_rbeam + dist * ap->a_diverge;
		cm2 = 4 * radius * radius * 0.01;	/* mm2 to cm2 */

		curve_attach(ap);

		/* XXX This should be attenuated by some atmosphere now */
		/* At least it's in proper power units */
		bn_tabdata_scale( ap->a_spectrum, background, cm2 );
d416 1
d422 1
d450 4
d461 1
d471 3
a473 1
		ap->a_user = 0;		/* Signal view_pixel:  MISS */
d487 1
a487 1
			rt_log("colorview:  eye inside %s (x=%d, y=%d, lvl=%d)\n",
d490 3
a492 1
			ap->a_user = 0;		/* Signal view_pixel:  MISS */
d498 3
d505 11
a515 1
		ap->a_user = sub_ap.a_user;
d581 1
a581 3
	/* As a special case for now, handle reflection & refraction */
	if( sw.sw_reflect > 0 || sw.sw_transmit > 0 )
		(void)rr_render( ap, pp, &sw );
d584 4
d648 1
d650 1
a650 1
		rt_log("colorview: lvl=%d ret a_user=%d %s\n",
d654 1
@


1.19
log
@Added some error checking
@
text
@d1 1
a1 1
#define NO_MATER 0
d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/viewtherm.c,v 1.18 1998/12/10 08:43:16 mike Exp $ (ARL)";
a51 1
#include "tabdata.h"
d68 1
a68 1
BU_EXTERN(struct rt_table	*rt_table_make_visible_and_uniform, (int num,
d131 2
a132 2
CONST struct rt_table		*spectrum;	/* definition of spectrum */
struct rt_tabdata		*background;		/* radiant emittance of bg */
d148 1
a148 1
		RT_CK_TABDATA( ap->a_spectrum );
d156 1
a156 1
		slp->sl_buf = (char *)rt_tabdata_malloc_array( spectrum, width );
d159 1
a159 1
	RT_CK_TABDATA( slp->sl_buf );	/* pun for first struct in array (sanity) */
d161 3
a163 3
	ap->a_spectrum = (struct rt_tabdata *)
		(slp->sl_buf+(ap->a_x*RT_SIZEOF_TABDATA(spectrum)));
	RT_CK_TABDATA( ap->a_spectrum );
d200 1
a200 1
		rt_tabdata_scale( ap->a_spectrum, background, cm2 );
d204 1
a204 1
		RT_CK_TABDATA(ap->a_spectrum);
d221 1
a221 1
		if( fseek( outfp, ap->a_y*(long)width*RT_SIZEOF_TABDATA(spectrum), 0 ) != 0 )
d224 1
a224 1
			RT_SIZEOF_TABDATA(spectrum), width, outfp );
d392 2
a393 2
		u.sw.msw_color = rt_tabdata_get_constval( 1.0, spectrum );
		u.sw.msw_basecolor = rt_tabdata_get_constval( 1.0, spectrum );
d400 1
a400 1
		rt_tabdata_copy( ap->a_spectrum, u.sw.msw_color );
d431 1
a431 1
	struct rt_tabdata	*pixelp;
d533 2
a534 2
	sw.msw_color = rt_tabdata_get_constval( 1.0, spectrum );
	sw.msw_basecolor = rt_tabdata_get_constval( 1.0, spectrum );
d538 1
d541 1
d547 1
a547 1
	rt_tabdata_copy( ap->a_spectrum, sw.msw_color );
d562 1
a562 1
	RT_CK_TABDATA(pixelp);
d596 1
a596 1
	rt_tabdata_scale( pixelp, pixelp, cm2 * cosine * powerfrac );
d651 1
a651 1
	spectrum = rt_table_make_visible_and_uniform( (int)spectrum_param[0],
d656 1
a656 1
	rt_table_write( rt_vls_addr(&name), spectrum );
d727 1
a727 1
	RT_GET_TABDATA( background, spectrum );
@


1.18
log
@Multi-spectral improvements
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/viewtherm.c,v 1.17 1998/11/26 03:44:15 mike Exp $ (ARL)";
d160 1
d162 2
a163 1
	ap->a_spectrum = (struct rt_tabdata *)(slp->sl_buf+(ap->a_x*RT_SIZEOF_TABDATA(spectrum)));
d165 1
d524 1
@


1.17
log
@Cleanups, added additional samples to visible band.
@
text
@d1 1
d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/viewtherm.c,v 1.16 1998/11/17 22:53:41 mike Exp $ (ARL)";
d97 2
a98 3
int	max_bounces = 3;

#if NO_MATER
d101 2
a102 2
extern struct region	env_region;	/* from text.c */
#endif
d276 1
a276 1
		switch( mlib_setup( regp, rtip ) )  {
d422 1
a422 1
#if 0
d520 2
a521 1
#if 0
d545 1
a545 1
#endif
d547 1
d600 2
@


1.16
log
@Don't use a_uptr any more, use a_spectrum
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/viewtherm.c,v 1.15 1998/11/17 19:14:50 mike Exp $ (ARL)";
d61 1
a61 1
RT_EXTERN( double	rt_pixel_footprint, (CONST struct application *ap,
d67 5
d642 2
a643 2
	spectrum = rt_table_make_uniform( (int)spectrum_param[0],
		spectrum_param[1], spectrum_param[2] );
@


1.15
log
@Moved rttherm from rt/ to rttherm/
@
text
@d10 1
a10 1
 *  a_uptr is pointer to returned spectral curve.
d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rttherm/viewtherm.c,v 1.14 1998/09/22 02:28:30 mike Exp $ (ARL)";
d128 1
a128 1
struct rt_tabdata		*ss_bg;		/* radiant emittance of bg */
d132 1
a132 1
 *  Ensure that a_uptr points to a valid spectral curve.
d143 2
a144 2
	if( ap->a_uptr )  {
		RT_CK_TABDATA( ap->a_uptr );
d156 2
a157 2
	ap->a_uptr = slp->sl_buf+(ap->a_x*RT_SIZEOF_TABDATA(spectrum));
	RT_CK_TABDATA( ap->a_uptr );
d193 1
a193 1
		rt_tabdata_scale( (struct rt_tabdata *)ap->a_uptr, ss_bg, cm2 );
d195 1
a195 1
		if( !ap->a_uptr )
d197 1
d385 2
a386 2
		VSETALL( u.sw.sw_color, 1 );
		VSETALL( u.sw.sw_basecolor, 1 );
d393 1
a393 1
		VMOVE( ap->a_color, u.sw.sw_color );
d524 2
a525 2
	VSETALL( sw.sw_color, 1 );
	VSETALL( sw.sw_basecolor, 1 );
d536 3
a538 1
	VMOVE( ap->a_color, sw.sw_color );
d548 2
a549 2
	if( !ap->a_uptr )  curve_attach(ap);
	pixelp = (struct rt_tabdata *)ap->a_uptr;
d713 2
a714 2
	RT_GET_TABDATA( ss_bg, spectrum );
	rt_spect_black_body( ss_bg, bg_temp, 9 );
@


1.14
log
@Linked rttherm (viewtherm.c) to LIBMULTISPECTRAL
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewtherm.c,v 1.13 1998/09/22 01:43:13 mike Exp $ (ARL)";
d55 4
a58 4
#include "./ext.h"
#include "./rdebug.h"
#include "./mathtab.h"
#include "./light.h"
@


1.13
log
@Moved sh_*.c shaders from rt/ to liboptical/ directory.
Moved and split rt/material.h into h/shadefuncs.h and h/shadework.h
Changed calling sequence of mlib_setup() to get shader list head explicitly.
Initialization of shader library is now via optical_shader_init().

Note that the "proper" location of shade.c, material.c, and refract.c
(presently in the rt/ directory) are a bit muddled, as they will be
shared with libmultispectral/ shader functions, but aren't quite
wholesome and pure yet.  To minimize impact to Lee's ongoing shader
developments, they haven't been changed.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewtherm.c,v 1.12 1997/12/16 00:20:11 mike Exp $ (ARL)";
d99 2
d116 2
d333 1
a333 1
static hit_nothing( ap, PartHeadp )
a334 1
struct partition *PartHeadp;
d409 1
a409 1
colorview( ap, PartHeadp )
d412 1
d600 1
d625 1
d627 1
a627 8
	/*
	 *  Connect up material library interfaces
	 *  Note that sh_plastic.c defines the required "default" entry.
	 */
#if NO_MATER
	{
		extern struct mfuncs phg_mfuncs[];
		extern struct mfuncs light_mfuncs[];
d629 1
a629 4
		mlib_add_shader( &mfHead, phg_mfuncs );
		mlib_add_shader( &mfHead, light_mfuncs );
	}
#endif
@


1.12
log
@Converted to bu_semaphore_acquire()
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/viewtherm.c,v 1.11 1996/10/23 14:00:29 pjt Exp mike $ (ARL)";
d53 2
a56 1
#include "./material.h"
d623 1
a623 1
	 *  Note that plastic.c defines the required "default" entry.
d630 2
a631 2
		mlib_add( phg_mfuncs );
		mlib_add( light_mfuncs );
@


1.11
log
@Changed call of rt_struct_print() to bu_struct_print()
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/viewtherm.c,v 1.10 1996/08/31 08:47:53 butler Exp pjt $ (ARL)";
d145 1
a145 1
	RES_ACQUIRE( &rt_g.res_results );
d149 1
a149 1
	RES_RELEASE( &rt_g.res_results );
d195 1
a195 1
	RES_ACQUIRE( &rt_g.res_results );
d198 1
a198 1
	RES_RELEASE( &rt_g.res_results );
d207 1
a207 1
		RES_ACQUIRE( &rt_g.res_syscall );
d212 1
a212 1
		RES_RELEASE( &rt_g.res_syscall );
@


1.10
log
@bu_struct_print
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/viewtherm.c,v 1.9 1996/08/30 00:08:21 butler Exp butler $ (ARL)";
d634 1
a634 1
	rt_struct_print( "rttherm variables", view_parse, NULL );
@


1.9
log
@structparse moved to libbu
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/viewtherm.c,v 1.8 1996/04/06 01:10:21 mike Exp butler $ (ARL)";
d634 1
a634 1
	rt_structprint( "rttherm variables", view_parse, NULL );
@


1.8
log
@Added new header file.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/viewtherm.c,v 1.7 1996/03/29 23:20:55 mike Exp mike $ (ARL)";
d114 1
a114 1
struct structparse view_parse[] = {
@


1.7
log
@Changed from RT_HIT_NORM() to RT_HIT_NORMAL().
Now pt_inflip stuff is always handled correctly.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/viewtherm.c,v 1.6 1996/03/29 21:57:37 mike Exp mike $ (ARL)";
d51 1
@


1.6
log
@Random hacking around.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/viewtherm.c,v 1.5 1996/03/16 01:00:46 mike Exp mike $ (ARL)";
d60 3
a62 1
				CONST struct hit *hitp, CONST struct seg *segp));
d418 1
d548 3
a550 6
	RT_HIT_NORM( hitp, pp->pt_inseg->seg_stp, &(ap->a_ray) );
	if( pp->pt_inflip )  {
		VREVERSE( hitp->hit_normal, hitp->hit_normal );
		pp->pt_inflip = 0;	/* shouldnt be needed */
	}
	cm2 = rt_pixel_footprint(ap, hitp, pp->pt_inseg) * 0.01;	/* mm**2 to cm**2 */
d553 1
a553 1
	cosine = -VDOT( hitp->hit_normal, ap->a_ray.r_dir );
d732 1
a732 1
 *  hitp->hit_point and hitp->hit_normal must be computed by caller.
d738 1
a738 1
rt_pixel_footprint(ap, hitp, segp)
d742 1
d755 1
a755 1
	if( fabs(VDOT(ap->a_ray.r_dir, hitp->hit_normal)) <= 1.0e-10 )  {
d781 1
a781 1
	VMOVE( surf_tan, hitp->hit_normal );
@


1.5
log
@Changed to rt_table stuff
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/viewtherm.c,v 1.4 1996/03/15 10:09:40 mike Exp mike $ (ARL)";
d541 1
d569 1
a569 1
#if 0
@


1.4
log
@Added powerfrac calcuation.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/viewtherm.c,v 1.3 1996/03/14 07:24:31 mike Exp mike $ (ARL)";
d119 2
a120 2
CONST struct rt_spectrum	*spectrum;	/* definition of spectrum */
struct rt_spect_sample		*ss_bg;		/* radiant emittance of bg */
d136 1
a136 1
		RT_CK_SPECT_SAMPLE( ap->a_uptr );
d144 1
a144 1
		slp->sl_buf = (char *)rt_get_spect_sample_array( spectrum, width );
d148 2
a149 2
	ap->a_uptr = slp->sl_buf+(ap->a_x*RT_SIZEOF_SPECT_SAMPLE(spectrum));
	RT_CK_SPECT_SAMPLE( ap->a_uptr );
d185 1
a185 1
		rt_spect_scale( (struct rt_spect_sample *)ap->a_uptr, ss_bg, cm2 );
d205 1
a205 1
		if( fseek( outfp, ap->a_y*(long)width*RT_SIZEOF_SPECT_SAMPLE(spectrum), 0 ) != 0 )
d208 1
a208 1
			RT_SIZEOF_SPECT_SAMPLE(spectrum), width, outfp );
d415 1
a415 1
	struct rt_spect_sample	*pixelp;
d537 2
a538 2
	pixelp = (struct rt_spect_sample *)ap->a_uptr;
	RT_CK_SPECT_SAMPLE(pixelp);
d574 1
a574 1
	rt_spect_scale( pixelp, pixelp, cm2 * cosine * powerfrac );
d635 1
a635 1
	spectrum = rt_spect_uniform( (int)spectrum_param[0],
d640 1
a640 1
	rt_write_spectrum( rt_vls_addr(&name), spectrum );
d711 1
a711 1
	RT_GET_SPECT_SAMPLE( ss_bg, spectrum );
@


1.3
log
@Move target blackbody into visible range.  ==> Hot!
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/viewtherm.c,v 1.2 1996/03/01 06:02:20 mike Exp mike $ (ARL)";
d60 1
a60 1
				CONST struct hit *hitp));
d413 1
d549 1
a549 1
	cm2 = rt_pixel_footprint(ap, hitp) * 0.01;	/* mm**2 to cm**2 */
d551 3
a553 1
	powerfrac = 0.2;		/* XXX from solid angle */
d555 12
d568 7
a574 1
	rt_spect_scale( pixelp, pixelp, cm2 * powerfrac );
d737 1
a737 1
rt_pixel_footprint(ap, hitp)
d740 1
d793 5
a813 1
rt_log("rt_pixel_footprint() area=%g mm**2\n", area);
@


1.2
log
@Added rt_pixel_footprint(), etc.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/viewtherm.c,v 1.1 1996/02/28 03:21:51 mike Exp mike $ (ARL)";
d539 1
a539 1
	degK = 700;	/* XXX extract from region! */
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 *	./rttherm -P1 -s8 -o mtherm ../.db.6d/moss.g all.g
d31 1
a31 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d58 5
d132 3
a164 1
	register char	*pixelp;
d168 3
d172 9
a180 1
		/* Shot missed the model, don't dither */
d182 4
a185 1
		rt_spect_copy( (struct rt_spect_sample *)ap->a_uptr, ss_bg );
d408 1
d410 5
d529 9
a537 1
rt_bomb("colorview: not written\n");
d539 1
d541 8
d550 11
d703 86
@
