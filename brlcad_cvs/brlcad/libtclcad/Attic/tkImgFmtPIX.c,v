head	1.18;
access;
symbols
	ansi-20040405-merged:1.14.2.2
	postmerge-20040405-ansi:1.16
	premerge-20040404-ansi:1.15
	postmerge-autoconf:1.15
	autoconf-freeze:1.14.10.1
	premerge-autoconf:1.15
	ansi-20040316-freeze:1.14.2.1
	postmerge-20040315-windows:1.15
	premerge-20040315-windows:1.15
	windows-20040315-freeze:1.14.4.1
	autoconf-20031203:1.14
	autoconf-20031202:1.14
	autoconf-branch:1.14.0.10
	phong-branch:1.14.0.8
	photonmap-branch:1.14.0.6
	rel-6-1-DP:1.14
	windows-branch:1.14.0.4
	rel-6-0-2:1.12
	ansi-branch:1.14.0.2
	rel-6-0-1-branch:1.12.0.2
	hartley-6-0-post:1.13
	hartley-6-0-pre:1.12
	rel-6-0-1:1.12
	rel-6-0:1.12
	rel-5-4:1.8
	offsite-5-3-pre:1.10
	rel-5-3:1.8
	rel-5-2:1.8
	rel-5-1-branch:1.8.0.2
	rel-5-1:1.8
	rel-5-0:1.6
	rel-5-0-beta:1.6
	rel-4-5:1.2
	ctj-4-5-post:1.2
	ctj-4-5-pre:1.2;
locks; strict;
comment	@ * @;


1.18
date	2004.05.21.18.07.37;	author morrison;	state dead;
branches;
next	1.17;

1.17
date	2004.05.10.15.30.47;	author erikg;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.05.07.41.18;	author morrison;	state Exp;
branches;
next	1.15;

1.15
date	2004.03.09.16.01.17;	author jra;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.20.17.08.17;	author jra;	state Exp;
branches
	1.14.2.1
	1.14.4.1
	1.14.10.1;
next	1.13;

1.13
date	2002.08.15.20.55.28;	author hartley;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.20.22.30.34;	author morrison;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.02.14.57.19;	author jra;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.16.21.19.27;	author cjohnson;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.31.19.21.27;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	99.12.30.18.21.26;	author jra;	state Exp;
branches;
next	1.7;

1.7
date	99.10.19.20.15.18;	author jra;	state Exp;
branches;
next	1.6;

1.6
date	99.01.21.02.22.41;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	98.12.31.07.32.44;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	98.12.30.02.27.04;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	98.12.30.02.24.49;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	96.12.31.18.07.44;	author jra;	state Exp;
branches;
next	1.1;

1.1
date	96.12.13.13.54.02;	author jra;	state Exp;
branches;
next	;

1.14.2.1
date	2002.09.19.18.01.55;	author morrison;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2004.03.17.21.20.21;	author morrison;	state Exp;
branches;
next	;

1.14.4.1
date	2004.03.11.23.44.51;	author morrison;	state Exp;
branches;
next	;

1.14.10.1
date	2004.03.15.14.07.32;	author erikg;	state Exp;
branches;
next	;


desc
@A photo image file handler for PIX (BRL-CAD) files.
@


1.18
log
@moved to src/
@
text
@/*
 * tkImgFmtPIX.c --
 *
 *      A photo image file handler for BRL-CAD(tm) ".pix" format files.
 *
 *  Author -
 *	Glenn Durfee
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
 * 
 * 
 * Based on:
 *	tkImgFmtPPM.c --
 *
 *	A photo image file handler for PPM (Portable PixMap) files.
 *
 * Copyright (c) 1994 The Australian National University.
 * Copyright (c) 1994-1995 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * Author: Paul Mackerras (paulus@@cs.anu.edu.au),
 *	   Department of Computer Science,
 *	   Australian National University.
 */

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libtclcad/tkImgFmtPIX.c,v 1.17 2004/05/10 15:30:47 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <stdio.h>

#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "tk.h"

/*
 * The format record for the PIX file format:
 */

static int		FileMatchPIX _ANSI_ARGS_((Tcl_Channel chan,
			    const char *fileName,
			    Tcl_Obj *format, int *widthPtr,
			    int *heightPtr, Tcl_Interp *interp));
static int		FileReadPIX  _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Channel chan,
			    const char *fileName, Tcl_Obj *formatString,
			    Tk_PhotoHandle imageHandle, int destX, int destY,
			    int width, int height, int srcX, int srcY));
static int		FileWritePIX _ANSI_ARGS_((Tcl_Interp *interp,
			    const char *fileName, Tcl_Obj *formatString,
			    Tk_PhotoImageBlock *blockPtr));

Tk_PhotoImageFormat tkImgFmtPIX = {
    "PIX",			/* name */
    FileMatchPIX,		/* fileMatchProc */
    NULL,			/* stringMatchProc */
    FileReadPIX,		/* fileReadProc */
    NULL,			/* stringReadProc */
    FileWritePIX,		/* fileWriteProc */
    NULL,			/* stringWriteProc */
};

/*
 * Prototypes for local procedures defined in this file:
 */


/*
 *----------------------------------------------------------------------
 *
 * FileMatchPIX --
 *
 *	This procedure is invoked by the photo image type to see if
 *	a file contains image data in PIX format.
 *
 * Results:
 *	The return value is >0 if the format option seems to be requesting
 *	the PIX image type.
 *
 * Side effects:
 *	The access position in f may change.
 *
 *----------------------------------------------------------------------
 */

static int
FileMatchPIX(Tcl_Channel chan, const char *fileName, Tcl_Obj *format, int *widthPtr, int *heightPtr, Tcl_Interp *interp)
                     
                         	/* The name of the image file. */
                    	/* User-specified format string, or NULL. */
                              	/* The dimensions of the image are
				 * returned here if the file is a valid
				 * raw PIX file. */
                       
{
    /* The format string must be nonnull and it must contain the word "pix". */
    /* If the user also specified the dimensions in the format string,
       use those.  Otherwise, guess from the file size. */
    char *formatString;
    int len;

    if (format == NULL)
	return 0;

    formatString = Tcl_GetStringFromObj(format, &len);
    if (formatString == NULL) return 0;

    if (strstr(formatString, "pix") == NULL &&
	strstr(formatString, "PIX") == NULL)
	return 0;

    if (bn_common_name_size(widthPtr, heightPtr, formatString) <= 0)
	if (bn_common_file_size(widthPtr, heightPtr, fileName, 3) <= 0)
	    return 0;

    return 1;
}

/*
 *----------------------------------------------------------------------
 *
 * FileReadPIX --
 *
 *	This procedure is called by the photo image type to read
 *	PIX format data from a file and write it into a given
 *	photo image.
 *
 * Results:
 *	A standard TCL completion code.  If TCL_ERROR is returned
 *	then an error message is left in interp->result.
 *
 * Side effects:
 *	The access position in file f is changed, and new data is
 *	added to the image given by imageHandle.
 *
 *----------------------------------------------------------------------
 */

static int
FileReadPIX(Tcl_Interp *interp, Tcl_Channel chan, const char *fileName, Tcl_Obj *format, Tk_PhotoHandle imageHandle, int destX, int destY, int width, int height, int srcX, int srcY)
                       		/* Interpreter to use for reporting errors. */
                     
                         	/* The name of the image file. */
                    		/* User-specified format string, or NULL. */
                               	/* The photo image to write into. */
                     		/* Coordinates of top-left pixel in
				 * photo image to be written to. */
                      		/* Dimensions of block of photo image to
				 * be written to. */
                   		/* Coordinates of top-left pixel to be used
				 * in image being read. */
{
    int fileWidth, fileHeight;
    int nBytes, h, count;
    unsigned char *pixelPtr;
    Tk_PhotoImageBlock block;
    char *formatString;
    int len;

    /* Determine dimensions of file. */

    formatString = Tcl_GetStringFromObj(format, &len);

    if (bn_common_name_size(&fileWidth, &fileHeight, formatString) <= 0)
	if (bn_common_file_size(&fileWidth, &fileHeight, fileName, 3) <= 0) {
	    Tcl_AppendResult(interp, "cannot determine dimensions of \"",
			     fileName, "\": please use -format pix-w#-n#",
			     NULL);
	    return TCL_ERROR;
	}

    if ((fileWidth <= 0) || (fileHeight <= 0)) {
	Tcl_AppendResult(interp, "PIX image file \"", fileName,
			 "\" has dimension(s) <= 0", (char *) NULL);
	return TCL_ERROR;
    }

    if ((srcX + width) > fileWidth) {
	width = fileWidth - srcX;
    }
    if ((srcY + height) > fileHeight) {
	height = fileHeight - srcY;
    }
    if ((width <= 0) || (height <= 0)
	|| (srcX >= fileWidth) || (srcY >= fileHeight)) {
	return TCL_OK;
    }

    block.pixelSize = 3;
    block.offset[0] = 0;
    block.offset[1] = 1;
    block.offset[2] = 2;
    block.width = width;
    block.pitch = block.pixelSize * fileWidth;

    Tk_PhotoExpand(imageHandle, destX + width, destY + height);

    if ((srcY + height) < fileHeight) {
    	Tcl_Seek( chan, (long) ((fileHeight - srcY - height) * block.pitch),
    		SEEK_CUR );
    		
    }

    nBytes = block.pitch;
    pixelPtr = (unsigned char *) bu_malloc((unsigned) nBytes,
					   "PIX image buffer");
    block.pixelPtr = pixelPtr + srcX * block.pixelSize;

    for (h = height; h > 0; h--) {
	count = Tcl_Read( chan, (char *)pixelPtr, nBytes );
	if (count != nBytes) {
	    Tcl_AppendResult(interp, "error reading PIX image file \"",
		    fileName, "\": ",
		    Tcl_Eof(chan) ? "not enough data" : Tcl_PosixError(interp),
		    (char *) NULL);
	    bu_free((char *) pixelPtr, "PIX image");
	    return TCL_ERROR;
	}
	block.height = 1;
	Tk_PhotoPutBlock(imageHandle, &block, destX, destY+h-1, width, height, 1);
    }

    bu_free((char *) pixelPtr, "PIX image buffer");
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * FileWritePIX --
 *
 *	This procedure is invoked to write image data to a file in PIX
 *	format.
 *
 * Results:
 *	A standard TCL completion code.  If TCL_ERROR is returned
 *	then an error message is left in interp->result.
 *
 * Side effects:
 *	Data is written to the file given by "fileName".
 *
 *----------------------------------------------------------------------
 */

static int
FileWritePIX(Tcl_Interp *interp, const char *fileName, Tcl_Obj *format, Tk_PhotoImageBlock *blockPtr)
{
    FILE *f;
    int w, h;
    int greenOffset, blueOffset;
    unsigned char *pixelPtr, *pixLinePtr;

    if ((f = fopen(fileName, "wb")) == NULL) {
	Tcl_AppendResult(interp, fileName, ": ", Tcl_PosixError(interp),
		(char *)NULL);
	return TCL_ERROR;
    }

    pixLinePtr = blockPtr->pixelPtr + blockPtr->offset[0] +
	         (blockPtr->height-1)*blockPtr->pitch;
    greenOffset = blockPtr->offset[1] - blockPtr->offset[0];
    blueOffset = blockPtr->offset[2] - blockPtr->offset[0];

    for (h = blockPtr->height; h > 0; h--) {
	pixelPtr = pixLinePtr;
	for (w = blockPtr->width; w > 0; w--) {
	    if ((putc(pixelPtr[0], f) == EOF)
		|| (putc(pixelPtr[greenOffset], f) == EOF)
		|| (putc(pixelPtr[blueOffset], f) == EOF)) {
		goto writeerror;
	    }
	    pixelPtr += blockPtr->pixelSize;
	}
	pixLinePtr -= blockPtr->pitch;
    }

    if (fclose(f) == 0) {
	return TCL_OK;
    }
    f = NULL;

 writeerror:
    Tcl_AppendResult(interp, "error writing \"", fileName, "\": ",
	    Tcl_PosixError(interp), (char *) NULL);
    if (f != NULL) {
	fclose(f);
    }
    return TCL_ERROR;
}
@


1.17
log
@change conf.h to a wrapped config.h
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/libtclcad/tkImgFmtPIX.c,v 1.16 2004/04/05 07:41:18 morrison Exp $ (ARL)";
@


1.16
log
@merge of ansi-6-0-branch into HEAD
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d37 5
a41 1
#include "conf.h"
@


1.15
log
@Signature of a called function has changed
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libtclcad/tkImgFmtPIX.c,v 1.14 2002/08/20 17:08:17 jra Exp $ (ARL)";
d103 5
a107 5
FileMatchPIX(chan, fileName, format, widthPtr, heightPtr, interp)
    Tcl_Channel chan;
    const char *fileName;	/* The name of the image file. */
    Tcl_Obj *format;	/* User-specified format string, or NULL. */
    int *widthPtr, *heightPtr;	/* The dimensions of the image are
d110 1
a110 1
    Tcl_Interp *interp;
d156 7
a162 8
FileReadPIX(interp, chan, fileName, format, imageHandle, destX, destY,
	width, height, srcX, srcY)
    Tcl_Interp *interp;		/* Interpreter to use for reporting errors. */
    Tcl_Channel chan;
    const char *fileName;	/* The name of the image file. */
    Tcl_Obj *format;		/* User-specified format string, or NULL. */
    Tk_PhotoHandle imageHandle;	/* The photo image to write into. */
    int destX, destY;		/* Coordinates of top-left pixel in
d164 1
a164 1
    int width, height;		/* Dimensions of block of photo image to
d166 1
a166 1
    int srcX, srcY;		/* Coordinates of top-left pixel to be used
d262 1
a262 5
FileWritePIX(interp, fileName, format, blockPtr)
    Tcl_Interp *interp;
    const char *fileName;
    Tcl_Obj *format;
    Tk_PhotoImageBlock *blockPtr;
@


1.14
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libtclcad/tkImgFmtPIX.c,v 1.12 2001/04/20 22:30:34 morrison Exp $ (ARL)";
d237 1
a237 1
	Tk_PhotoPutBlock(imageHandle, &block, destX, destY+h-1, width, 1);
@


1.14.10.1
log
@merge from head
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libtclcad/tkImgFmtPIX.c,v 1.14 2002/08/20 17:08:17 jra Exp $ (ARL)";
d237 1
a237 1
	Tk_PhotoPutBlock(imageHandle, &block, destX, destY+h-1, width, height, 1);
@


1.14.4.1
log
@sync to HEAD...
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libtclcad/tkImgFmtPIX.c,v 1.15 2004/03/09 16:01:17 jra Exp $ (ARL)";
d237 1
a237 1
	Tk_PhotoPutBlock(imageHandle, &block, destX, destY+h-1, width, height, 1);
@


1.14.2.1
log
@Initial ANSIfication
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libtclcad/tkImgFmtPIX.c,v 1.14 2002/08/20 17:08:17 jra Exp $ (ARL)";
d103 5
a107 5
FileMatchPIX(Tcl_Channel chan, const char *fileName, Tcl_Obj *format, int *widthPtr, int *heightPtr, Tcl_Interp *interp)
                     
                         	/* The name of the image file. */
                    	/* User-specified format string, or NULL. */
                              	/* The dimensions of the image are
d110 1
a110 1
                       
d156 8
a163 7
FileReadPIX(Tcl_Interp *interp, Tcl_Channel chan, const char *fileName, Tcl_Obj *format, Tk_PhotoHandle imageHandle, int destX, int destY, int width, int height, int srcX, int srcY)
                       		/* Interpreter to use for reporting errors. */
                     
                         	/* The name of the image file. */
                    		/* User-specified format string, or NULL. */
                               	/* The photo image to write into. */
                     		/* Coordinates of top-left pixel in
d165 1
a165 1
                      		/* Dimensions of block of photo image to
d167 1
a167 1
                   		/* Coordinates of top-left pixel to be used
d263 5
a267 1
FileWritePIX(Tcl_Interp *interp, const char *fileName, Tcl_Obj *format, Tk_PhotoImageBlock *blockPtr)
@


1.14.2.2
log
@sync branch with HEAD
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d236 1
a236 1
	Tk_PhotoPutBlock(imageHandle, &block, destX, destY+h-1, width, height, 1);
@


1.13
log
@Converted from K&R to ANSI C - RFH
@
text
@d103 5
a107 5
FileMatchPIX(Tcl_Channel chan, const char *fileName, Tcl_Obj *format, int *widthPtr, int *heightPtr, Tcl_Interp *interp)
                     
                         	/* The name of the image file. */
                    	/* User-specified format string, or NULL. */
                              	/* The dimensions of the image are
d110 1
a110 1
                       
d156 8
a163 7
FileReadPIX(Tcl_Interp *interp, Tcl_Channel chan, const char *fileName, Tcl_Obj *format, Tk_PhotoHandle imageHandle, int destX, int destY, int width, int height, int srcX, int srcY)
                       		/* Interpreter to use for reporting errors. */
                     
                         	/* The name of the image file. */
                    		/* User-specified format string, or NULL. */
                               	/* The photo image to write into. */
                     		/* Coordinates of top-left pixel in
d165 1
a165 1
                      		/* Dimensions of block of photo image to
d167 1
a167 1
                   		/* Coordinates of top-left pixel to be used
d263 5
a267 1
FileWritePIX(Tcl_Interp *interp, const char *fileName, Tcl_Obj *format, Tk_PhotoImageBlock *blockPtr)
@


1.12
log
@CONST to const
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libtclcad/tkImgFmtPIX.c,v 1.11 2001/04/02 14:57:19 jra Exp $ (ARL)";
d103 5
a107 5
FileMatchPIX(chan, fileName, format, widthPtr, heightPtr, interp)
    Tcl_Channel chan;
    const char *fileName;	/* The name of the image file. */
    Tcl_Obj *format;	/* User-specified format string, or NULL. */
    int *widthPtr, *heightPtr;	/* The dimensions of the image are
d110 1
a110 1
    Tcl_Interp *interp;
d156 7
a162 8
FileReadPIX(interp, chan, fileName, format, imageHandle, destX, destY,
	width, height, srcX, srcY)
    Tcl_Interp *interp;		/* Interpreter to use for reporting errors. */
    Tcl_Channel chan;
    const char *fileName;	/* The name of the image file. */
    Tcl_Obj *format;		/* User-specified format string, or NULL. */
    Tk_PhotoHandle imageHandle;	/* The photo image to write into. */
    int destX, destY;		/* Coordinates of top-left pixel in
d164 1
a164 1
    int width, height;		/* Dimensions of block of photo image to
d166 1
a166 1
    int srcX, srcY;		/* Coordinates of top-left pixel to be used
d262 1
a262 5
FileWritePIX(interp, fileName, format, blockPtr)
    Tcl_Interp *interp;
    const char *fileName;
    Tcl_Obj *format;
    Tk_PhotoImageBlock *blockPtr;
@


1.11
log
@Lint
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libtclcad/tkImgFmtPIX.c,v 1.10 2001/01/16 21:19:27 cjohnson Exp $ (ARL)";
d57 1
a57 1
			    CONST char *fileName,
d62 1
a62 1
			    CONST char *fileName, Tcl_Obj *formatString,
d66 1
a66 1
			    CONST char *fileName, Tcl_Obj *formatString,
d105 1
a105 1
    CONST char *fileName;	/* The name of the image file. */
d160 1
a160 1
    CONST char *fileName;	/* The name of the image file. */
d265 1
a265 1
    CONST char *fileName;
@


1.10
log
@Change calling parameters to match the tk.h definitions.
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libtclcad/tkImgFmtPIX.c,v 1.9 2000/08/31 19:21:27 mike Exp $ (ARL)";
d39 7
@


1.9
log
@
lint
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libtclcad/tkImgFmtPIX.c,v 1.8 1999/12/30 18:21:26 jra Exp $ (ARL)";
d50 3
a52 3
			    char *fileName,
			    char *formatString, int *widthPtr,
			    int *heightPtr));
d55 1
a55 1
			    char *fileName, char *formatString,
d59 1
a59 1
			    char *fileName, char *formatString,
d96 1
a96 1
FileMatchPIX(chan, fileName, formatString, widthPtr, heightPtr)
d98 2
a99 2
    char *fileName;		/* The name of the image file. */
    char *formatString;		/* User-specified format string, or NULL. */
d103 1
d108 2
d111 1
a111 1
    if (formatString == NULL)
d114 3
d149 1
a149 1
FileReadPIX(interp, chan, fileName, formatString, imageHandle, destX, destY,
d153 2
a154 2
    char *fileName;		/* The name of the image file. */
    char *formatString;		/* User-specified format string, or NULL. */
d167 2
d172 2
d256 1
a256 1
FileWritePIX(interp, fileName, formatString, blockPtr)
d258 2
a259 2
    char *fileName;
    char *formatString;
@


1.8
log
@Eliminated some unused variables
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libtclcad/tkImgFmtPIX.c,v 1.7 1999/10/19 20:15:18 jra Exp $ (ARL)";
@


1.7
log
@Modified for Tcl/Tk 8.2.1
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libtclcad/tkImgFmtPIX.c,v 1.6 1999/01/21 02:22:41 mike Exp $ (ARL)";
d158 1
a158 1
    int nBytes, h, type, count;
d254 1
a254 1
    int greenOffset, blueOffset, nBytes;
@


1.6
log
@The phony header files are not useful, and cause problems.
Use the real ones.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libtclcad/tkImgFmtPIX.c,v 1.5 1998/12/31 07:32:44 mike Exp $ (ARL)";
d43 1
a43 2

#include "../libtk/generic/tkPort.h"
@


1.5
log
@Converted from using UNIX STDIO to new Tcl8.0 method of Tcl_Channel's.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libtclcad/tkImgFmtPIX.c,v 1.4 1998/12/30 02:27:04 mike Exp $ (ARL)";
d44 1
a44 1
#include "./tkPort.h"
@


1.4
log
@Improved comment.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d37 7
a46 7
 * The maximum amount of memory to allocate for data read from the
 * file.  If we need more than this, we do it in pieces.
 */

#define MAX_MEMORY	10000		/* don't allocate > 10KB */

/*
d50 2
a51 1
static int		FileMatchPIX _ANSI_ARGS_((FILE *f, char *fileName,
d55 2
a56 1
			    FILE *f, char *fileName, char *formatString,
d97 2
a98 2
FileMatchPIX(f, fileName, formatString, widthPtr, heightPtr)
    FILE *f;			/* The image file, open for reading. */
d144 1
a144 1
FileReadPIX(interp, f, fileName, formatString, imageHandle, destX, destY,
d147 1
a147 1
    FILE *f;			/* The image file, open for reading. */
d200 3
a202 2
	fseek(f, (long) ((fileHeight - srcY - height) * block.pitch),
	      SEEK_CUR);
d211 1
a211 1
	count = fread(pixelPtr, 1, (unsigned) nBytes, f);
d215 1
a215 1
		    feof(f) ? "not enough data" : Tcl_PosixError(interp),
@


1.3
log
@tkInt.h is no longer required.  And this one conflicted with ../h/tk.h!
@
text
@d4 1
a4 1
 *      A photo image file handler for PIX (BRL-CAD) files.
d6 9
a14 12
 * Army copyright foo
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
d18 1
a18 1
 * tkImgFmtPPM.c --
d33 3
a35 1
static char rcsid[] = "@@(#) tkImgFmtPIX.c 1.7 95/06/14 22:49:55";
@


1.2
log
@changed rt_ to bn_ where needed and added "./" to includes.
@
text
@a37 1
#include "./tkInt.h"
@


1.1
log
@Initial revision
@
text
@d38 2
a39 2
#include "tkInt.h"
#include "tkPort.h"
d116 2
a117 2
    if (pix_common_name_size(widthPtr, heightPtr, formatString) <= 0)
	if (pix_common_file_size(widthPtr, heightPtr, fileName, 3) <= 0)
d165 2
a166 2
    if (pix_common_name_size(&fileWidth, &fileHeight, formatString) <= 0)
	if (pix_common_file_size(&fileWidth, &fileHeight, fileName, 3) <= 0) {
d205 1
a205 1
    pixelPtr = (unsigned char *) rt_malloc((unsigned) nBytes,
d216 1
a216 1
	    rt_free((char *) pixelPtr, "PIX image");
d223 1
a223 1
    rt_free((char *) pixelPtr, "PIX image buffer");
@
