head	1.2;
access;
symbols
	ansi-20040405-merged:1.1.10.1
	postmerge-20040405-ansi:1.1
	premerge-20040404-ansi:1.1
	postmerge-autoconf:1.1
	autoconf-freeze:1.1
	premerge-autoconf:1.1
	postmerge-20040315-windows:1.1
	premerge-20040315-windows:1.1
	windows-20040315-freeze:1.1.8.1
	autoconf-20031203:1.1
	autoconf-20031202:1.1
	autoconf-branch:1.1.0.6
	phong-branch:1.1.0.4
	photonmap-branch:1.1.0.2
	windows-branch:1.1.0.8
	ansi-branch:1.1.0.10;
locks; strict;
comment	@ * @;


1.2
date	2004.04.13.20.21.35;	author morrison;	state dead;
branches;
next	1.1;

1.1
date	2003.03.18.23.06.31;	author morrison;	state Exp;
branches
	1.1.8.1
	1.1.10.1;
next	;

1.1.8.1
date	2004.03.11.23.52.27;	author morrison;	state Exp;
branches;
next	;

1.1.10.1
date	2004.03.17.21.23.18;	author morrison;	state Exp;
branches;
next	;


desc
@@


1.2
log
@these are no longer relevant or appropriate here
@
text
@/* dummy test to exercise bu_parallel */
#include "conf.h"

#include <stdio.h>
#include <unistd.h>
#include <math.h>
#include <stdlib.h>
#include <limits.h>

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"

/* workers acquire semaphore number 0 on smp machines */
#define P2G_WORKER RT_SEM_LAST
#define P2G_INIT_COUNT P2G_WORKER+1

int iterations=512;
double result=0.0;

void computeSomething( int pid, void *arg ) {
	int i;

	double x;
	double y;

	while (iterations > 0) {

		x = y = 1.0;
		
		for (i = 0; i < 100000L; i++) {
			x += sqrt((double)i);
			y += cbrt((double)i);
		}

		
		/* this doesn't need to be semaphored, but I want to grab at least more
		 * than one semaphore in the work block
		 */
		bu_semaphore_acquire(P2G_WORKER);

		if ( (iterations % 32) ==  0 ) {
			bu_log("%d", iterations / 32);
		} else if ( (iterations % 8) == 0 ) {
			bu_log(".");
		}

		i=random();
		bu_semaphore_release(P2G_WORKER);
		
		/*	bu_log ("random: %d\n", i); */
		
		/* add some per process variability */
		for ( i=random() / (LONG_MAX / 2) ; i > 0; i-- ) {
			x += 1;
			y += 1;
			x -= 1;
			y -= 1;
		}
		
		bu_semaphore_acquire(P2G_WORKER);
		result = (x - y);
		iterations--;
		bu_semaphore_release(P2G_WORKER);
	}

}

int
main(int ac, char *av[])
{
	int ncpu=1;

	ncpu=bu_avail_cpus();

	if (ac == 2) {
		ncpu=atoi(av[1]);
	}

	if (ncpu > 1) {
		bu_log("Found %d cpu\'s!  Sweet.\n", ncpu);
	}
			
	/* the first critical section semaphore is for coordinating work, the
	 * second for writing out the final record and cleaning up. 
	 */
	/* XXX must use RT_SEM_LAST if we plan on calling bu_parallel since the
	 * semaphore count is held in a global
	 */
	bu_semaphore_init(P2G_INIT_COUNT);

	
	bu_log("before: %f\n", result);

	/* XXX I do not like the idea of having to pass everything around in global
	 * space. but forking on our own is just as bad (need good IPC)
	 */
	bu_parallel(computeSomething, ncpu, NULL);

	bu_log("\nafter: %f\n", result);
		
	bu_log("\n...done!\n");
	
	return 0;
}
@


1.1
log
@*** empty log message ***
@
text
@@


1.1.10.1
log
@sync branch with HEAD
@
text
@@


1.1.8.1
log
@sync to HEAD...
@
text
@@

