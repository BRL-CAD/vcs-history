head	11.9;
access;
symbols
	ansi-20040405-merged:11.5.2.2
	postmerge-20040405-ansi:11.7
	premerge-20040404-ansi:11.6
	postmerge-autoconf:11.6
	autoconf-freeze:11.5.10.2
	premerge-autoconf:11.6
	ansi-20040316-freeze:11.5.2.1
	postmerge-20040315-windows:11.6
	premerge-20040315-windows:11.6
	windows-20040315-freeze:11.5.4.1
	autoconf-20031203:11.5
	autoconf-20031202:11.5
	autoconf-branch:11.5.0.10
	phong-branch:11.5.0.8
	photonmap-branch:11.5.0.6
	rel-6-1-DP:11.5
	windows-branch:11.5.0.4
	rel-6-0-2:11.3
	ansi-branch:11.5.0.2
	rel-6-0-1-branch:11.3.0.2
	hartley-6-0-post:11.4
	hartley-6-0-pre:11.3
	rel-6-0-1:11.3
	rel-6-0:11.3
	rel-5-4:11.1
	offsite-5-3-pre:11.2
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.9
date	2004.05.24.04.13.25;	author morrison;	state dead;
branches;
next	11.8;

11.8
date	2004.05.10.15.30.42;	author erikg;	state Exp;
branches;
next	11.7;

11.7
date	2004.04.05.07.49.23;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	2004.02.02.17.39.01;	author morrison;	state Exp;
branches;
next	11.5;

11.5
date	2002.08.20.17.07.24;	author jra;	state Exp;
branches
	11.5.2.1
	11.5.4.1
	11.5.10.1;
next	11.4;

11.4
date	2002.08.15.20.54.37;	author hartley;	state Exp;
branches;
next	11.3;

11.3
date	2001.04.12.17.44.07;	author bparker;	state Exp;
branches;
next	11.2;

11.2
date	2000.08.24.03.58.25;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.09.05;	author mike;	state Rel4_4;
branches;
next	10.4;

10.4
date	94.08.23.18.48.58;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	94.08.11.15.05.59;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.03.16.21.42.08;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.46.11;	author mike;	state Rel4_0;
branches;
next	9.3;

9.3
date	91.07.02.01.58.33;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	91.01.11.04.37.52;	author butler;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.08.21;	author mike;	state Rel3_5;
branches;
next	8.2;

8.2
date	89.04.24.09.00.12;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.41.03;	author mike;	state Rel3_0;
branches;
next	7.3;

7.3
date	88.09.20.02.16.07;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.09.19.23.36.40;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.06.47;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.09.58;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.37.56;	author mike;	state Rel;
branches;
next	4.3;

4.3
date	87.04.11.00.16.13;	author phil;	state Exp;
branches;
next	4.2;

4.2
date	87.02.13.00.40.23;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.12.33;	author mike;	state Rel1;
branches;
next	1.17;

1.17
date	86.10.27.04.32.51;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	86.10.06.21.08.01;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	86.10.03.07.28.19;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	86.10.03.06.10.36;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	86.10.03.04.51.55;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	86.08.13.05.21.16;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	86.08.13.03.11.41;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	86.08.13.03.11.34;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	86.08.13.03.11.27;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	86.08.13.03.11.18;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	86.08.13.03.11.11;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	86.08.13.03.11.03;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	86.08.13.03.10.56;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	86.08.13.03.10.49;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	86.08.13.03.10.42;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.08.13.03.10.36;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.08.13.03.10.32;	author mike;	state Exp;
branches;
next	;

11.5.2.1
date	2002.09.19.18.00.39;	author morrison;	state Exp;
branches;
next	11.5.2.2;

11.5.2.2
date	2004.03.17.21.16.04;	author morrison;	state Exp;
branches;
next	;

11.5.4.1
date	2004.03.11.23.40.40;	author morrison;	state Exp;
branches;
next	;

11.5.10.1
date	2004.02.12.19.40.45;	author erikg;	state Exp;
branches;
next	11.5.10.2;

11.5.10.2
date	2004.03.15.13.28.05;	author erikg;	state Exp;
branches;
next	;


desc
@@


11.9
log
@moved to src/fb/
@
text
@/*
 *			F B - O R L E . C
 *
 *  Encode a frame buffer image using the old RLE library
 *
 *  Author -
 *	Gary S. Moss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Id: fb-orle.c,v 11.8 2004/05/10 15:30:42 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include "machine.h"
#include "externs.h"
#include "fb.h"
#include "orle.h"

static char	*usage[] = {
"Usage: fb-rle [-CScdhvw] [-l X Y] [-F Frame_buffer] [-p X Y] [file.rle]",
"",
"If no RLE file is specifed, fb-rle will write to its standard output.",
"If the environment variable FB_FILE is set, its value will be used",
"	to specify the framebuffer file or device to read from.",
0
};

static FBIO	*fbp;
static FILE	*fp;
static RGBpixel	bgpixel;
static int	bgflag = 1;
static int	ncolors = 3;
static int	cmflag = 1;
static int	crunch = 0;
static int	xpos = 0, ypos = 0, xlen = 0, ylen = 0;
static int	parsArgv(int argc, register char **argv);
static void	prntUsage(void);
static int	width = 512;
static char	*fb_file = (char *)NULL;

extern void	cmap_crunch(register RGBpixel (*scan_buf), register int pixel_ct, ColorMap *cmap);

/*	m a i n ( )							*/
int
main(int argc, char **argv)
{
	static RGBpixel	scan_buf[1024];
	static ColorMap	cmap;
	register int	y;
	register int	y_end;

	if( ! parsArgv( argc, argv ) )
	{
		prntUsage();
		return	1;
	}
	fp = stdout;
	setbuf( fp, malloc( BUFSIZ ) );

	rle_wlen( xlen, ylen, 1 );
	rle_wpos( xpos, ypos, 1 );

	if( (fbp = fb_open( fb_file, width, width )) == NULL )  {
		fprintf(stderr,"fb_open failed\n");
		exit(12);
	}

	/* Read color map, see if it's linear */
	cmflag = 1;		/* Need to save colormap */
	if( fb_rmap( fbp, &cmap ) == -1 )
		cmflag = 0;
	if( cmflag && fb_is_linear_cmap( &cmap ) )
		cmflag = 0;
	if( crunch && (cmflag == 0) )
		crunch = 0;

	/* Acquire "background" pixel from special location */
	if(	bgflag
	    &&	fb_read( fbp, 1, 1, bgpixel, 1 ) == -1
	    )
	{
		(void) fprintf( stderr, "Couldn't read background!\n" );
		return	1;
	}	
	if( bgflag && rle_verbose )
		(void) fprintf( stderr,
		"Background saved as %d %d %d\n",
		bgpixel[RED], bgpixel[GRN], bgpixel[BLU]
		    );

	/* Write RLE header */
	if( rle_whdr( fp, ncolors, bgflag, cmflag, bgpixel ) == -1 )
		return	1;

	/* Follow RLE header with colormap */
	if( cmflag )  {
		if( rle_wmap( fp, &cmap ) == -1 )
			return	1;
		if( rle_debug )
			(void) fprintf( stderr,
			"Color map saved.\n"
			    );
	}

	if( ncolors == 0 )
		/* Only save colormap, so we are finished.		*/
		return	0;

	/* Get image from framebuffer and encode it */
	y_end = ypos + ylen;

	for( y = ypos; y < y_end; y++ )  {
		if(rle_debug)fprintf(stderr,"line %d\n", y);
		if( fb_read( fbp, xpos, y, (unsigned char *)scan_buf, xlen ) == -1)  {
			(void) fprintf(	stderr,
				"read of %d pixels from (%d,%d) failed!\n",
				xlen, xpos, y );
				return	1;
		}
		if( crunch )
			cmap_crunch( scan_buf, xlen, &cmap );

		if( rle_encode_ln( fp, scan_buf ) == -1 )
			return	1;
	}
	fb_close( fbp );
	return	0;
}

/*	p a r s A r g v ( )						*/
static int
parsArgv(int argc, register char **argv)
{
	register int	c;
	extern int	optind;
	extern char	*optarg;

	/* Parse options.						*/
	while( (c = getopt( argc, argv, "CF:Scdhl:p:vw" )) != EOF )
	{
		switch( c )
		{
		case 'C' : /* Crunch color map.				*/
			crunch = 1;
			cmflag = 0;
			break;
		case 'S' : /* 'Box' save, store entire image.		*/
			bgflag = 0;
			break;
		case 'c' : /* Only save color map.			*/
			ncolors = 0;
			break;
		case 'd' : /* For debugging.				*/
			rle_debug = 1;
			break;
		case 'h' : /* High resolution.				*/
			width = 1024;
			break;
		case 'l' : /* Length in x and y.			*/
			if( argc - optind < 1 )
			{
				(void) fprintf( stderr,
				"-l option requires an X and Y argument!\n"
				    );
				return	0;
			}
			xlen = atoi( optarg );
			ylen = atoi( argv[optind++] );
			break;
		case 'p' : /* Position of bottom-left corner.		*/
			if( argc - optind < 1 )
			{
				(void) fprintf( stderr,
				"-p option requires an X and Y argument!\n"
				    );
				return	0;
			}
			xpos = atoi( optarg );
			ypos = atoi( argv[optind++] );
			break;
		case 'v' : /* Verbose on.				*/
			rle_verbose = 1;
			break;
		case 'w' : /* Monochrome (black & white) mode.		*/
			ncolors = 1;
			break;
		case 'F' : fb_file = optarg;
			break;
		case '?' :
			return	0;
		}
	}
	if( argv[optind] != NULL )
	{
		if( access( argv[optind], 0 ) == 0 )
		{
			(void) fprintf( stderr,
			"\"%s\" already exists.\n",
			argv[optind]
			    );
			exit( 1 );
		}
		if( (fp = fopen( argv[optind], "w" )) == NULL )
		{
			perror(argv[optind]);
			return	0;
		}
	}
	if( argc > ++optind )
	{
		(void) fprintf( stderr, "Too many arguments!\n" );
		return	0;
	}
	if( isatty(fileno(fp)) )
		return 0;
	if( xlen == 0 )
		xlen = width;
	if( ylen == 0 )
		ylen = width;
	return	1;
}

/*	p r n t U s a g e ( )
	Print usage message.
 */
static void
prntUsage(void)
{
	register char	**p = usage;

	while( *p )
	{
		(void) fprintf( stderr, "%s\n", *p++ );
	}
	return;
}
@


11.8
log
@change conf.h to a wrapped config.h
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Id: fb-orle.c,v 11.7 2004/04/05 07:49:23 morrison Exp $ (BRL)";
@


11.7
log
@merge of ansi-6-0-branch into HEAD
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Id$ (BRL)";
d22 5
a26 1
#include "conf.h"
@


11.6
log
@update copyright to include span through 2003
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Id: fb-orle.c,v 11.5 2002/08/20 17:07:24 jra Exp $ (BRL)";
d47 2
a48 2
static int	parsArgv();
static void	prntUsage();
d52 1
a52 1
extern void	cmap_crunch();
d56 1
a56 3
main( argc, argv )
int	argc;
char	*argv[];
d143 1
a143 2
parsArgv( argc, argv )
register char	**argv;
d238 1
a238 1
prntUsage()
@


11.5
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Id: fb-orle.c,v 11.3 2001/04/12 17:44:07 bparker Exp $ (BRL)";
@


11.5.4.1
log
@sync to HEAD...
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Id: fb-orle.c,v 11.6 2004/02/02 17:39:01 morrison Exp $ (BRL)";
@


11.5.10.1
log
@merge from HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Id: fb-orle.c,v 11.6 2004/02/02 17:39:01 morrison Exp $ (BRL)";
@


11.5.10.2
log
@merge from head
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Id: fb-orle.c,v 11.5.10.1 2004/02/12 19:40:45 erikg Exp $ (BRL)";
@


11.5.2.1
log
@Initial ANSIfication
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Id: fb-orle.c,v 11.5 2002/08/20 17:07:24 jra Exp $ (BRL)";
d47 2
a48 2
static int	parsArgv(int argc, register char **argv);
static void	prntUsage(void);
d52 1
a52 1
extern void	cmap_crunch(register RGBpixel (*scan_buf), register int pixel_ct, ColorMap *cmap);
d56 3
a58 1
main(int argc, char **argv)
d145 2
a146 1
parsArgv(int argc, register char **argv)
d241 1
a241 1
prntUsage(void)
@


11.5.2.2
log
@sync branch with HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Id$ (BRL)";
@


11.4
log
@Converted from K&R to ANSI C - RFH
@
text
@d47 2
a48 2
static int	parsArgv(int argc, register char **argv);
static void	prntUsage(void);
d52 1
a52 1
extern void	cmap_crunch(register RGBpixel (*scan_buf), register int pixel_ct, ColorMap *cmap);
d56 3
a58 1
main(int argc, char **argv)
d145 2
a146 1
parsArgv(int argc, register char **argv)
d241 1
a241 1
prntUsage(void)
@


11.3
log
@*- get rid of warnings
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Id: fb-orle.c,v 11.2 2000/08/24 03:58:25 mike Exp $ (BRL)";
d47 2
a48 2
static int	parsArgv();
static void	prntUsage();
d52 1
a52 1
extern void	cmap_crunch();
d56 1
a56 3
main( argc, argv )
int	argc;
char	*argv[];
d143 1
a143 2
parsArgv( argc, argv )
register char	**argv;
d238 1
a238 1
prntUsage()
@


11.2
log
@
const RCSid
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Id: fb-orle.c,v 11.1 1995/01/04 10:09:05 mike Rel4_4 $ (BRL)";
d55 1
@


11.1
log
@Release_4.4
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Id: fb-orle.c,v 10.4 94/08/23 18:48:58 gdurf Exp $ (BRL)";
@


10.4
log
@Added includes, factored ifdefs
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Id: fb-orle.c,v 10.3 1994/08/11 15:05:59 mike Exp gdurf $ (BRL)";
@


10.3
log
@Reduced use of RGBpixel
Now use (unsigned char *)
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Id: fb-orle.c,v 10.2 92/03/16 21:42:08 mike Exp Locker: mike $ (BRL)";
d22 2
d25 1
@


10.2
log
@IRIX 4.0.1
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Id: fb-orle.c,v 10.1 91/10/12 06:46:11 mike Rel4_0 Locker: mike $ (BRL)";
d123 1
a123 1
		if( fb_read( fbp, xpos, y, scan_buf, xlen ) == -1)  {
@


10.1
log
@Release_4.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Id: /f/cad/util/RCS/fb-orle.c,v 1.1 91/01/03 23:11:32 butler Exp $ (BRL)";
d37 1
a37 1
static FILE	*fp = stdout;
d66 1
@


9.3
log
@Changed to fb_is_linear_cmap
@
text
@@


9.2
log
@adjusted includes to reflect divergence of rle.h and orle.h,
added '-F' option to allow framebuffer specification
@
text
@d80 1
a80 1
	if( cmflag && is_linear_cmap( &cmap ) )
@


9.1
log
@Release_3.5
@
text
@d2 1
a2 1
 *			F B - R L E . C
d4 1
a4 1
 *  Encode a frame buffer image using the RLE library
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: fb-orle.c,v 8.2 89/04/24 09:00:12 mike Exp $ (BRL)";
d25 1
a25 1
#include "rle.h"
d28 1
a28 1
"Usage: fb-rle [-CScdhvw] [-l X Y] [-p X Y] [file.rle]",
d47 1
d71 1
a71 1
	if( (fbp = fb_open( NULL, width, width )) == NULL )  {
d148 1
a148 1
	while( (c = getopt( argc, argv, "CScdhl:p:vw" )) != EOF )
d195 2
@


8.2
log
@Added externs.h for malloc() definition.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: fb-orle.c,v 8.1 88/10/05 00:41:03 mike Locked $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: fb-orle.c,v 7.3 88/09/20 02:16:07 mike Exp $ (BRL)";
d23 1
@


7.3
log
@Switched to using cmap_crunch(), externally.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: fb-orle.c,v 7.2 88/09/19 23:36:40 mike Locked $ (BRL)";
@


7.2
log
@Moved function is_linear_cmap() into linear-cmap.c
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: fb-orle.c,v 7.1 87/11/03 00:06:47 mike Locked $ (BRL)";
a43 1
static void	do_Crunch();
d47 2
d127 1
a127 1
			do_Crunch( scan_buf, xlen, &cmap );
a238 16
	}
	return;
}

/*	d o _ C r u n c h ( )						*/
static void
do_Crunch( scan_buf, pixel_ct, cmap )
register RGBpixel	*scan_buf;
register int		pixel_ct;
register ColorMap	*cmap;
{
	for( ; pixel_ct > 0; pixel_ct--, scan_buf++ )
	{
		(*scan_buf)[RED] = cmap->cm_red[(*scan_buf)[RED]]>>8;
		(*scan_buf)[GRN] = cmap->cm_green[(*scan_buf)[GRN]]>>8;
		(*scan_buf)[BLU] = cmap->cm_blue[(*scan_buf)[BLU]]>>8;
@


7.1
log
@Release 2.3
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: fb-rle.c,v 6.1 87/07/11 08:09:58 mike Rel $ (BRL)";
a255 20
}

/*
 *  Check for a color map being linear in R, G, and B.
 *  Returns 1 for linear map, 0 for non-linear map
 *  (ie, non-identity map).
 */
is_linear_cmap( cmap )
register ColorMap *cmap;
{
	register int i;
	unsigned short v;

	for( i=0; i<256; i++ )  {
		v = (unsigned short)(i<<8);
		if( cmap->cm_red[i] != v )  return(0);
		if( cmap->cm_green[i] != v )  return(0);
		if( cmap->cm_blue[i] != v )  return(0);
	}
	return(1);
@


6.1
log
@Release 2.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: fb-rle.c,v 5.1 87/06/24 22:37:56 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: fb-rle.c,v 4.3 87/04/11 00:16:13 phil Exp $ (BRL)";
@


4.3
log
@removed unnecessary fb_ioinit() call
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: fb-rle.c,v 4.2 87/02/13 00:40:23 phil Locked $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: fb-rle.c,v 4.1 86/12/29 03:12:33 mike Rel1 $ (BRL)";
a114 1
	fb_ioinit( fbp );
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: fb-rle.c,v 1.17 86/10/27 04:32:51 mike Exp $ (BRL)";
@


1.17
log
@converted to RGBpixel
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: fb-rle.c,v 1.16 86/10/06 21:08:01 mike Locked $ (BRL)";
@


1.16
log
@Converted to new libfb with 1st Quadrant semantics
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: fb-rle.c,v 1.15 86/10/03 07:28:19 mike Exp $ (BRL)";
d37 1
a37 1
static Pixel	bgpixel = { 0, 0, 0, 0 };
d53 1
a53 1
	static Pixel	scan_buf[1024];
d84 1
a84 1
	    &&	fb_read( fbp, 1, 1, &bgpixel, 1 ) == -1
d93 1
a93 1
		bgpixel.red, bgpixel.green, bgpixel.blue
d97 1
a97 1
	if( rle_whdr( fp, ncolors, bgflag, cmflag, &bgpixel ) == -1 )
d246 1
a246 1
register Pixel		*scan_buf;
d252 3
a254 3
		scan_buf->red = cmap->cm_red[scan_buf->red]>>8;
		scan_buf->green = cmap->cm_green[scan_buf->green]>>8;
		scan_buf->blue = cmap->cm_blue[scan_buf->blue]>>8;
@


1.15
log
@Added check for output spilling on tty line.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: fb-rle.c,v 1.14 86/10/03 06:10:36 mike Exp $ (BRL)";
a25 8
#ifndef pdp11
#define MAX_DMA	1024*64
#else
#define MAX_DMA	1024*16
#endif
#define DMA_PIXELS	(MAX_DMA/sizeof(Pixel))
#define DMA_SCANS	(DMA_PIXELS/width)
#define PIXEL_OFFSET	((scan_ln%dma_scans)*width)
d27 1
d29 1
a29 5
"fb-rle (1.11)",
"",
"Usage: fb-rle [-CScdhvw][-l X Y][-p X Y][file.rle]",
"",
"If no rle file is specifed, fb-rle will write to its standard output.",
d52 2
a53 4
	{
	register int	scan_ln;
	register int	dma_scans;
	static Pixel	scan_buf[DMA_PIXELS];
d55 2
a56 2
	static int	scan_bytes;
	static int	dma_pixels;
d59 1
a59 1
		{
d62 1
a62 1
		}
d64 1
a64 3
	dma_pixels = DMA_PIXELS;
	dma_scans = DMA_SCANS;
	scan_bytes = width * sizeof(Pixel);
d77 1
a77 1
	if( is_linear_cmap( &cmap ) )
d85 2
a86 2
		)
		{
d89 1
a89 1
		}	
d92 3
a94 3
				"Background saved as %d %d %d\n",
				bgpixel.red, bgpixel.green, bgpixel.blue
				);
d106 2
a107 2
					"Color map saved.\n"
					);
d114 10
a123 15
	/* Save image.							*/
	{	register int	page_fault = 1;
		register int	y_buffer = (ypos + ylen) - dma_scans;
	for( scan_ln = ypos + (ylen-1); scan_ln >= ypos; --scan_ln )
		{
		if( page_fault )
			{
			if( fb_read( fbp, 0, y_buffer, scan_buf, dma_pixels ) == -1)
				{
				(void) fprintf(	stderr,
					"read of %d pixels from (0,%d) failed!\n",
						dma_pixels,
						y_buffer
						);
						
d125 5
a129 5
				}
			if( crunch )
				do_Crunch( scan_buf, dma_pixels, &cmap );
			}
		if( rle_encode_ln( fp, scan_buf+PIXEL_OFFSET ) == -1 )
a130 8
		if( page_fault = ! (scan_ln%dma_scans) )
			y_buffer -= dma_scans;
		if( y_buffer < 0 )
			{
			dma_scans += y_buffer * xlen;
			y_buffer = 0;
			}
		}
d134 1
a134 1
	}
d140 1
a140 1
	{
d147 2
a149 2
		switch( c )
			{
d168 1
a168 1
				{
d171 1
a171 1
						);
d173 1
a173 1
				}
d179 1
a179 1
				{
d182 1
a182 1
						);
d184 1
a184 1
				}
a195 1
			}
d197 1
d199 2
a201 2
		if( access( argv[optind], 0 ) == 0 )
			{
d203 3
a205 3
					"\"%s\" already exists.\n",
					argv[optind]
					);
d207 1
a207 1
			}
d209 2
a210 5
			{
			(void) fprintf( stderr,
					"Can't open %s for writing!\n",
					argv[optind]
					);
a211 1
			}
d213 1
d215 1
a215 1
		{
d218 1
a218 1
		}
d226 1
a226 1
	}
d233 1
a233 1
	{
d237 1
a237 1
		{
d239 1
a239 1
		}
d241 1
a241 1
	}
d249 2
a251 2
	for( ; pixel_ct > 0; pixel_ct--, scan_buf++ )
		{
d255 1
a255 1
		}
d257 1
a257 1
	}
@


1.14
log
@Added fb_close
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d234 1
a234 14
			if( isatty( 0 ) )
				{ register int	c;
				(void) fprintf( stderr,
						"Overwrite \"%s\" [y] ? ",
						argv[optind]
						);
				c = getchar();
				while( c != '\n' && getchar() != '\n' )
					;
				if( c != 'y' )
					exit( 1 );
				}
			else
				exit( 1 );
d250 2
@


1.13
log
@Modified for new libfb calling sequences.
@
text
@d2 15
a16 10
	SCCS id:	@@(#) fb-rle.c	1.11
	Last edit: 	2/12/86 at 13:22:00
	Retrieved: 	8/13/86 at 03:11:38
	SCCS archive:	/m/cad/fb_utils/RCS/s.fb-rle.c

	Author:		Gary S. Moss
			U. S. Army Ballistic Research Laboratory
			Aberdeen Proving Ground
			Maryland 21005
			(301)278-6647 or AV-283-6647
d18 2
a19 3
#if ! defined( lint )
static
char	sccsTag[] = "@@(#) fb-rle.c	1.11	last edit 2/12/86 at 13:22:00";
d160 1
@


1.12
log
@Updated #includes for new conventions
@
text
@d28 2
a29 2
#define DMA_SCANS	(DMA_PIXELS/_fbsize)
#define PIXEL_OFFSET	((scan_ln%dma_scans)*_fbsize)
d41 2
d53 1
d75 1
a75 1
	scan_bytes = _fbsize * sizeof(Pixel);
d78 16
a93 2
	if( fbopen( NULL, APPEND ) == -1 )
		return	1;
d95 1
a95 1
	    &&	fbread( 1, 1, &bgpixel, 1 ) == -1
d106 2
d110 5
a114 12
	if( cmflag )
		{
		if( fb_rmap( &cmap ) == -1 )
			{ /* No map saved, assume standard map.		*/
			if( rle_wmap( fp, (ColorMap *) NULL ) == -1 )
				return	1;
			}
		else
			{
			if( rle_wmap( fp, &cmap ) == -1 )
				return	1;
			}
d119 2
a120 7
		}
	else
	if( crunch && fb_rmap( &cmap ) == -1 )
		{
		(void) fprintf( stderr, "Could not read colormap!\n" );
		crunch = 0;
		}
d132 1
a132 1
			if( fbread( 0, y_buffer, scan_buf, dma_pixels ) == -1)
d187 1
a187 1
			fbsetsize( 1024 );
d259 1
a259 1
		xlen = _fbsize;
d261 1
a261 1
		ylen = _fbsize;
d289 3
a291 3
		scan_buf->red = cmap->cm_red[scan_buf->red];
		scan_buf->green = cmap->cm_green[scan_buf->green];
		scan_buf->blue = cmap->cm_blue[scan_buf->blue];
d295 20
@


1.11
log
@Fixed case where ylen is not multiple of buffer size.
@
text
@d17 1
d19 3
a21 2
#include <fb.h>
#include <rle.h>
d180 1
a180 1
			setfbsize( 1024 );
@


1.10
log
@Added diagnostic for fbread() failures.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) fb-rle.c	1.10
	Last edit: 	2/12/86 at 12:57:27
	Retrieved: 	8/13/86 at 03:11:31
d15 1
a15 1
char	sccsTag[] = "@@(#) fb-rle.c	1.10	last edit 2/12/86 at 12:57:27";
d30 1
a30 1
"fb-rle (1.10)",
d140 5
@


1.9
log
@Fixed -l and -p options.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) fb-rle.c	1.9
	Last edit: 	10/15/85 at 15:10:57
	Retrieved: 	8/13/86 at 03:11:24
d15 1
a15 1
char	sccsTag[] = "@@(#) fb-rle.c	1.9	last edit 10/15/85 at 15:10:57";
d30 1
a30 1
"fb-rle (1.9)",
d124 7
d132 1
d145 1
a145 2
/*	p a r s A r g v ( )
 */
@


1.8
log
@Fixed missing {} in pars_Argv().
@
text
@d2 3
a4 3
	SCCS id:	@@(#) fb-rle.c	1.8
	Last edit: 	10/15/85 at 14:54:04
	Retrieved: 	8/13/86 at 03:11:15
d15 1
a15 1
char	sccsTag[] = "@@(#) fb-rle.c	1.8	last edit 10/15/85 at 14:54:04";
d30 1
a30 1
"fb-rle (1.8)",
d169 1
a169 1
			if( argc - optind < 2 )
d180 1
a180 1
			if( argc - optind < 2 )
@


1.7
log
@Fixed background color save (looks at pixel <1,1>).
@
text
@d2 3
a4 3
	SCCS id:	@@(#) fb-rle.c	1.7
	Last edit: 	8/15/85 at 10:06:25
	Retrieved: 	8/13/86 at 03:11:08
d15 1
a15 1
char	sccsTag[] = "@@(#) fb-rle.c	1.7	last edit 8/15/85 at 10:06:25";
d30 1
a30 1
"fb-rle (1.7)",
d201 1
d231 1
@


1.6
log
@Added support for crunch option.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) fb-rle.c	1.6
	Last edit: 	6/6/85 at 13:21:05
	Retrieved: 	8/13/86 at 03:11:00
d15 1
a15 1
char	sccsTag[] = "@@(#) fb-rle.c	1.6	last edit 6/6/85 at 13:21:05";
d30 1
a30 1
"fb-rle (1.6)",
d71 12
a82 1
	if( rle_verbose )
d84 1
a84 1
				"Background is %d %d %d\n",
a86 2
	rle_wlen( xlen, ylen, 1 );
	rle_wpos( xpos, ypos, 1 );
a87 2
		return	1;
	if( fbopen( NULL, APPEND ) == -1 )
@


1.5
log
@Added support for positioning of image.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) fb-rle.c	1.5
	Last edit: 	5/29/85 at 13:10:26
	Retrieved: 	8/13/86 at 03:10:53
d15 1
a15 1
char	sccsTag[] = "@@(#) fb-rle.c	1.5	last edit 5/29/85 at 13:10:26";
d30 1
a30 1
"fb-rle (1.5)",
d47 1
d99 6
d115 1
d118 3
d246 16
@


1.4
log
@Appear to work nicely and fast enough too.  Still need to support 
the -p option.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) fb-rle.c	1.4
	Last edit: 	3/27/85 at 20:45:10
	Retrieved: 	8/13/86 at 03:10:46
d15 1
a15 1
char	sccsTag[] = "@@(#) fb-rle.c	1.4	last edit 3/27/85 at 20:45:10";
d26 2
a27 2
#define DMA_SCANS	(DMA_PIXELS/fbsz)
#define PIXEL_OFFSET	((scan_ln%dma_scans)*fbsz)
d30 1
a30 1
"fb-rle (1.4)",
d32 1
a32 1
"Usage: fb-rle [-CScdhvw] [file.rle]",
d45 1
a45 1
static int	fbsz;
a54 1
	register int	fbsz = 512;
a66 1
	fbsz = getfbsize();
d69 1
a69 1
	scan_bytes = fbsz * sizeof(Pixel);
d75 3
a77 3
	if(	rle_whdr( fp, ncolors, bgflag, cmflag, &bgpixel )
	    ==	-1
		)
a78 1

a80 1

d99 1
a99 1
		{ /* Only save colormap, so we are finished.		*/
d101 1
a101 1
		}
d104 2
a105 2
		register int	y_buffer = fbsz - dma_scans;
	for( scan_ln = fbsz-1; scan_ln >= 0; --scan_ln )
d130 1
a130 1
	while( (c = getopt( argc, argv, "CScdhvw" )) != EOF )
d134 22
a155 23
			case 'C' : /* Crunch color map.			*/
				crunch = 1;
				cmflag = 0;
				break;
			case 'S' : /* 'Box' save, store entire image.	*/
				bgflag = 0;
				break;
			case 'c' : /* Only save color map.		*/
				ncolors = 0;
				break;
			case 'd' : /* For debugging.			*/
				rle_debug = 1;
				break;
			case 'h' : /* High resolution.			*/
				setfbsize( 1024 );
				break;
			case 'v' : /* Verbose on.			*/
				rle_verbose = 1;
				break;
			case 'w' : /* Monochrome (black & white) mode.	*/
				ncolors = 1;
				break;
			case '?' :
d157 23
d217 4
@


1.3
log
@Preliminary version reads both formats writes new format.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) fb-rle.c	1.3
	Last edit: 	3/26/85 at 17:45:44
	Retrieved: 	8/13/86 at 03:10:39
d15 1
a15 1
char	sccsTag[] = "@@(#) fb-rle.c	1.3	last edit 3/26/85 at 17:45:44";
d20 8
d30 1
a30 1
"fb-rle (1.3)",
a53 2
	Pixel		scan_buf[1024];
	ColorMap	cmap;
d55 7
d69 3
d107 2
d111 4
a114 1
		if( fbread( 0, scan_ln, scan_buf, fbsz ) == -1 )
d116 2
a117 2
		if( rle_encode_ln( fp, scan_buf ) == -1 )
			return	1;
d119 1
d165 21
@


1.2
log
@Works well, all options not tested, -i and -p option not 
supported, and buffering is needed.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) fb-rle.c	1.2
	Last edit: 	3/21/85 at 16:21:49
	Retrieved: 	8/13/86 at 03:10:33
d15 1
a15 1
char	sccsTag[] = "@@(#) fb-rle.c	1.2	last edit 3/21/85 at 16:21:49";
d19 1
a19 1

d22 1
a22 1
"fb-rle (1.2)",
d24 1
a24 1
"Usage: fb-rle [-BCdhvw] [file.rle]",
d33 2
a34 4
int		debug = 0;
int		verbose = 0;
static int	bgflag = 2;
static int	bwflag = 0;
a36 1
static int	bbw = 0;		/* black/white background color */
d56 1
a56 1
	if( verbose )
d61 1
a61 6
	if( bwflag )
		bbw =	0.35 * bgpixel.red +
			0.55 * bgpixel.green +
			0.10 * bgpixel.blue;

	if(	rle_whdr( fp, bwflag, bgflag, cmflag, bbw, &bgpixel )
d71 5
a75 4
		if(	fb_rmap( &cmap ) == -1
		     ||	rle_wmap( fp, &cmap ) == -1
			)
			return	1;
d77 6
a82 2
			if( debug )
				(void) fprintf( stderr,
d84 1
a84 1
						);
d86 5
a90 1

d111 2
a112 2
	/* Parse options.					*/
	while( (c = getopt( argc, argv, "BCdhvw" )) != EOF )
d116 1
a116 4
			case 'B' :
				bgflag = 2;
				break;
			case 'C' :
d120 2
a121 2
			case 'd' :
				debug = 1;
d123 7
a129 1
			case 'h' :
d132 2
a133 2
			case 'v' :
				verbose = 1;
d135 2
a136 2
			case 'w' :
				bwflag = 1;
@


1.1
log
@Initial revision
@
text
@d2 3
a4 3
	SCCS id:	@@(#) fb-rle.c	1.1
	Last edit: 	3/21/85 at 14:00:59
	Retrieved: 	8/13/86 at 03:10:28
d15 1
a15 1
char	sccsTag[] = "@@(#) fb-rle.c	1.1	last edit 3/21/85 at 14:00:59";
d22 1
a22 1
"_fb-rle (1.1)",
d24 1
a24 1
"Usage: _fb-rle [-BCdhvw]",
d26 3
d31 1
d57 1
a57 1
	setbuf( stdout, malloc( BUFSIZ ) );
d69 1
a69 1
	if(	rle_whdr( stdout, bwflag, bgflag, cmflag, bbw, &bgpixel )
d80 1
a80 1
		     ||	rle_wmap( stdout, &cmap ) == -1
d83 5
d94 1
a94 1
		if( rle_encode_ln( stdout, scan_buf ) == -1 )
d138 10
a147 1
	if( argc != optind )
@
