head	11.10;
access;
symbols
	ansi-20040405-merged:11.6.2.2
	postmerge-20040405-ansi:11.8
	premerge-20040404-ansi:11.7
	postmerge-autoconf:11.7
	autoconf-freeze:11.6.10.2
	premerge-autoconf:11.7
	ansi-20040316-freeze:11.6.2.1
	postmerge-20040315-windows:11.7
	premerge-20040315-windows:11.7
	windows-20040315-freeze:11.6.4.1
	autoconf-20031203:11.6
	autoconf-20031202:11.6
	autoconf-branch:11.6.0.10
	phong-branch:11.6.0.8
	photonmap-branch:11.6.0.6
	rel-6-1-DP:11.6
	windows-branch:11.6.0.4
	rel-6-0-2:11.4
	ansi-branch:11.6.0.2
	rel-6-0-1-branch:11.4.0.2
	hartley-6-0-post:11.5
	hartley-6-0-pre:11.4
	rel-6-0-1:11.4
	rel-6-0:11.4
	rel-5-4:11.2
	offsite-5-3-pre:11.3
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:5.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.10
date	2004.05.24.04.13.26;	author morrison;	state dead;
branches;
next	11.9;

11.9
date	2004.05.10.15.30.42;	author erikg;	state Exp;
branches;
next	11.8;

11.8
date	2004.04.05.07.49.23;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2004.02.02.17.39.01;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	2002.08.20.17.07.25;	author jra;	state Exp;
branches
	11.6.2.1
	11.6.4.1
	11.6.10.1;
next	11.5;

11.5
date	2002.08.15.20.54.38;	author hartley;	state Exp;
branches;
next	11.4;

11.4
date	2001.04.12.17.44.08;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	2000.08.24.03.58.33;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.12.31.17.43.25;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.09.39;	author mike;	state Rel4_4;
branches;
next	10.4;

10.4
date	94.10.12.15.55.36;	author jra;	state Exp;
branches;
next	10.3;

10.3
date	94.08.23.18.49.15;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.08.04.20.35.55;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.46.43;	author mike;	state Rel4_0;
branches;
next	9.12;

9.12
date	91.09.23.02.33.26;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	91.09.23.02.23.49;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	91.01.11.00.47.24;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	91.01.05.00.24.05;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	91.01.05.00.04.22;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	91.01.04.22.45.28;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	91.01.03.03.05.31;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.11.12.21.08.57;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.11.03.17.36.53;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.11.03.16.47.08;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.11.03.14.36.07;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.09.58;	author mike;	state Rel3_5;
branches;
next	8.2;

8.2
date	89.04.11.22.15.25;	author phil;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.42.31;	author mike;	state Rel3_0;
branches;
next	7.4;

7.4
date	88.10.01.06.34.45;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.10.01.04.21.27;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.05.22.23.51.55;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.08.12;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.11.30;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.42.05;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.13.00.42.47;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.13.20;	author mike;	state Rel1;
branches;
next	1.20;

1.20
date	86.11.28.19.04.19;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	86.11.26.08.34.14;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	86.11.26.04.40.31;	author phil;	state Exp;
branches;
next	1.17;

1.17
date	86.11.24.19.06.40;	author kermit;	state Exp;
branches;
next	1.16;

1.16
date	86.11.14.23.31.56;	author phil;	state Exp;
branches;
next	1.15;

1.15
date	86.11.13.01.24.35;	author phil;	state Exp;
branches;
next	1.14;

1.14
date	86.10.30.22.32.00;	author phil;	state Exp;
branches;
next	1.13;

1.13
date	86.10.25.10.35.50;	author phil;	state Exp;
branches;
next	1.12;

1.12
date	86.10.13.03.22.18;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	86.10.13.03.02.17;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	86.10.13.02.51.35;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	86.10.12.01.52.55;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	86.10.11.22.48.44;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	86.10.06.21.08.22;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	86.10.03.08.18.02;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	86.10.03.04.52.11;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	86.08.13.04.41.40;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	86.06.13.19.47.11;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.04.16.23.12.15;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	85.09.10.04.53.18;	author mike;	state Exp;
branches;
next	;

11.6.2.1
date	2002.09.19.18.00.43;	author morrison;	state Exp;
branches;
next	11.6.2.2;

11.6.2.2
date	2004.03.17.21.16.08;	author morrison;	state Exp;
branches;
next	;

11.6.4.1
date	2004.03.11.23.40.44;	author morrison;	state Exp;
branches;
next	;

11.6.10.1
date	2004.02.12.19.40.46;	author erikg;	state Exp;
branches;
next	11.6.10.2;

11.6.10.2
date	2004.03.15.13.28.06;	author erikg;	state Exp;
branches;
next	;


desc
@Display a .pix file on frame buffer, using Gary Moss's libfb routines.
@


11.10
log
@moved to src/fb/
@
text
@/*
 *  			P I X - F B . C
 *  
 *  Program to take bottom-up pixel files and send them to a framebuffer.
 *  
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/fb/pix-fb.c,v 11.9 2004/05/10 15:30:42 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include "machine.h"
#include "externs.h"			/* For getopt */
#include "fb.h"

/* defined in libbn/asize.c */
extern int bn_common_file_size(int *, int *, const char *, int);

int mread(int fd, register char *bp, register int num);
int skipbytes(int fd, off_t num);

static unsigned char *scanline;		/* 1 scanline pixel buffer */
static int	scanbytes;		/* # of bytes of scanline */
static int	scanpix;		/* # of pixels of scanline */

static int	multiple_lines = 0;	/* Streamlined operation */

static char	*framebuffer = NULL;
static char	*file_name;
static int	infd;

static int	fileinput = 0;		/* file of pipe on input? */
static int	autosize = 0;		/* !0 to autosize input */

static int	file_width = 512;	/* default input width */
static int	file_height = 512;	/* default input height */
static int	scr_width = 0;		/* screen tracks file if not given */
static int	scr_height = 0;
static int	file_xoff, file_yoff;
static int	scr_xoff, scr_yoff;
static int	clear = 0;
static int	zoom = 0;
static int	inverse = 0;		/* Draw upside-down */
static int	one_line_only = 0;	/* insist on 1-line writes */

static char usage[] = "\
Usage: pix-fb [-a -h -i -c -z -1] [-m #lines] [-F framebuffer]\n\
	[-s squarefilesize] [-w file_width] [-n file_height]\n\
	[-x file_xoff] [-y file_yoff] [-X scr_xoff] [-Y scr_yoff]\n\
	[-S squarescrsize] [-W scr_width] [-N scr_height] [file.pix]\n";

int
get_args(int argc, register char **argv)
{
	register int c;

	while ( (c = getopt( argc, argv, "1m:ahiczF:s:w:n:x:y:X:Y:S:W:N:" )) != EOF )  {
		switch( c )  {
		case '1':
			one_line_only = 1;
			break;
		case 'm':
			multiple_lines = atoi(optarg);
			break;
		case 'a':
			autosize = 1;
			break;
		case 'h':
			/* high-res */
			file_height = file_width = 1024;
			scr_height = scr_width = 1024;
			autosize = 0;
			break;
		case 'i':
			inverse = 1;
			break;
		case 'c':
			clear = 1;
			break;
		case 'z':
			zoom = 1;
			break;
		case 'F':
			framebuffer = optarg;
			break;
		case 's':
			/* square file size */
			file_height = file_width = atoi(optarg);
			autosize = 0;
			break;
		case 'w':
			file_width = atoi(optarg);
			autosize = 0;
			break;
		case 'n':
			file_height = atoi(optarg);
			autosize = 0;
			break;
		case 'x':
			file_xoff = atoi(optarg);
			break;
		case 'y':
			file_yoff = atoi(optarg);
			break;
		case 'X':
			scr_xoff = atoi(optarg);
			break;
		case 'Y':
			scr_yoff = atoi(optarg);
			break;
		case 'S':
			scr_height = scr_width = atoi(optarg);
			break;
		case 'W':
			scr_width = atoi(optarg);
			break;
		case 'N':
			scr_height = atoi(optarg);
			break;

		default:		/* '?' */
			return(0);
		}
	}

	if( optind >= argc )  {
		if( isatty(fileno(stdin)) )
			return(0);
		file_name = "-";
		infd = 0;
	} else {
		file_name = argv[optind];
		if( (infd = open(file_name, 0)) < 0 )  {
			perror(file_name);
			(void)fprintf( stderr,
				"pix-fb: cannot open \"%s\" for reading\n",
				file_name );
			exit(1);
		}
		fileinput++;
	}

	if ( argc > ++optind )
		(void)fprintf( stderr, "pix-fb: excess argument(s) ignored\n" );

	return(1);		/* OK */
}

int
main(int argc, char **argv)
{
	register int y;
	register FBIO *fbp;
	int	xout, yout, n, m, xstart, xskip;

	if ( !get_args( argc, argv ) )  {
		(void)fputs(usage, stderr);
		exit( 1 );
	}

	/* autosize input? */
	if( fileinput && autosize ) {
		int	w, h;
		if( bn_common_file_size(&w, &h, file_name, 3) ) {
			file_width = w;
			file_height = h;
		} else {
			fprintf(stderr,"pix-fb: unable to autosize\n");
		}
	}

	/* If screen size was not set, track the file size */
	if( scr_width == 0 )
		scr_width = file_width;
	if( scr_height == 0 )
		scr_height = file_height;

	if( (fbp = fb_open( framebuffer, scr_width, scr_height )) == NULL )
		exit(12);

	/* Get the screen size we were given */
	scr_width = fb_getwidth(fbp);
	scr_height = fb_getheight(fbp);

	/* compute number of pixels to be output to screen */
	if( scr_xoff < 0 )
	{
		xout = scr_width + scr_xoff;
		xskip = (-scr_xoff);
		xstart = 0;
	}
	else
	{
		xout = scr_width - scr_xoff;
		xskip = 0;
		xstart = scr_xoff;
	}

	if( xout < 0 )
		exit(0);			/* off screen */
	if( xout > (file_width-file_xoff) )
		xout = (file_width-file_xoff);
	scanpix = xout;				/* # pixels on scanline */

	if( inverse )
		scr_yoff = (-scr_yoff);

	yout = scr_height - scr_yoff;
	if( yout < 0 )
		exit(0);			/* off screen */
	if( yout > (file_height-file_yoff) )
		yout = (file_height-file_yoff);

	/* Only in the simplest case use multi-line writes */
	if( !one_line_only && multiple_lines > 0 && !inverse && !zoom &&
	    xout == file_width &&
	    file_width <= scr_width )  {
	    	scanpix *= multiple_lines;
	}

	scanbytes = scanpix * sizeof(RGBpixel);
	if( (scanline = (unsigned char *)malloc(scanbytes)) == RGBPIXEL_NULL )  {
		fprintf(stderr,
			"pix-fb:  malloc(%d) failure for scanline buffer\n",
			scanbytes);
		exit(2);
	}

	if( clear )  {
		fb_clear( fbp, PIXEL_NULL );
	}
	if( zoom ) {
		/* Zoom in, and center the display.  Use square zoom. */
		int	zoom;
		zoom = scr_width/xout;
		if( scr_height/yout < zoom )  zoom = scr_height/yout;
		if( inverse )  {
			fb_view( fbp,
				scr_xoff+xout/2, scr_height-1-(scr_yoff+yout/2),
				zoom, zoom );
		} else {
			fb_view( fbp,
				scr_xoff+xout/2, scr_yoff+yout/2,
				zoom, zoom );
		}
	}

	if( file_yoff != 0 ) skipbytes( infd, (off_t)file_yoff*(off_t)file_width*sizeof(RGBpixel) );

	if( multiple_lines )  {
		/* Bottom to top with multi-line reads & writes */
		int	height;
		for( y = scr_yoff; y < scr_yoff + yout; y += multiple_lines )  {
			n = mread( infd, (char *)scanline, scanbytes );
			if( n <= 0 ) break;
			height = multiple_lines;
			if( n != scanbytes )  {
				height = (n/sizeof(RGBpixel)+xout-1)/xout;
				if( height <= 0 )  break;
			}
			/* Don't over-write */
			if( y + height > scr_yoff + yout )
				height = scr_yoff + yout - y;
			if( height <= 0 )  break;
			m = fb_writerect( fbp, scr_xoff, y,
				file_width, height,
				scanline );
			if( m != file_width*height )  {
				fprintf(stderr,
					"pix-fb: fb_writerect(x=%d, y=%d, w=%d, h=%d) failure, ret=%d, s/b=%d\n",
					scr_xoff, y,
					file_width, height, m, scanbytes );
			}
		}
	} else if( !inverse )  {
		/* Normal way -- bottom to top */
		for( y = scr_yoff; y < scr_yoff + yout; y++ )  {
			if( y < 0 || y > scr_height )
			{
				skipbytes( infd , (off_t)file_width*sizeof(RGBpixel) );
				continue;
			}
			if( file_xoff+xskip != 0 )
				skipbytes( infd, (off_t)(file_xoff+xskip)*sizeof(RGBpixel) );
			n = mread( infd, (char *)scanline, scanbytes );
			if( n <= 0 ) break;
			m = fb_write( fbp, xstart, y, scanline, xout );
			if( m != xout )  {
				fprintf(stderr,
					"pix-fb: fb_write(x=%d, y=%d, npix=%d) ret=%d, s/b=%d\n",
					scr_xoff, y, xout,
					m, xout );
			}
			/* slop at the end of the line? */
			if( file_xoff+xskip+scanpix < file_width )
				skipbytes( infd, (off_t)(file_width-file_xoff-xskip-scanpix)*sizeof(RGBpixel) );
		}
	}  else  {
		/* Inverse -- top to bottom */
		for( y = scr_height-1-scr_yoff; y >= scr_height-scr_yoff-yout; y-- )  {
			if( y < 0 || y >= scr_height )
			{
				skipbytes( infd , (off_t)file_width*sizeof(RGBpixel) );
				continue;
			}
			if( file_xoff+xskip != 0 )
				skipbytes( infd, (off_t)(file_xoff+xskip)*sizeof(RGBpixel) );
			n = mread( infd, (char *)scanline, scanbytes );
			if( n <= 0 ) break;
			m = fb_write( fbp, xstart, y, scanline, xout );
			if( m != xout )  {
				fprintf(stderr,
					"pix-fb: fb_write(x=%d, y=%d, npix=%d) ret=%d, s/b=%d\n",
					scr_xoff, y, xout,
					m, xout );
			}
			/* slop at the end of the line? */
			if( file_xoff+xskip+scanpix < file_width )
				skipbytes( infd, (off_t)(file_width-file_xoff-xskip-scanpix)*sizeof(RGBpixel) );
		}
	}
	if( fb_close( fbp ) < 0 )  {
		fprintf(stderr, "pix-fb: Warning: fb_close() error\n");
	}
	exit(0);
}

/*
 * Throw bytes away.  Use reads into scanline buffer if a pipe, else seek.
 */
int
skipbytes(int fd, off_t num)
{
	int	n, try;

	if( fileinput ) {
		(void)lseek( fd, (off_t)num, 1 );
		return 0;
	}
	
	while( num > 0 ) {
		try = num > scanbytes ? scanbytes : num;
		n = read( fd, scanline, try );
		if( n <= 0 ){
			return -1;
		}
		num -= n;
	}
	return	0;
}

/*
 * "Multiple try" read.
 *  Will keep reading until either an error occurs
 *  or the requested number of bytes is read.  This
 *  is important for pipes.
 */
int
mread(int fd, register char *bp, register int num)
{
	register int	n;
	int	count;

	count = 0;

	while( num > 0 ) {
		n = read( fd, bp, num );
		if( n < 0 )
			return	-1;
		if( n == 0 )
			return count;
		bp += n;
		count += n;
		num -= n;
	}
	return count;
}
@


11.9
log
@change conf.h to a wrapped config.h
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/fb/pix-fb.c,v 11.8 2004/04/05 07:49:23 morrison Exp $ (BRL)";
@


11.8
log
@merge of ansi-6-0-branch into HEAD
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d22 5
a26 1
#include "conf.h"
@


11.7
log
@update copyright to include span through 2003
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/pix-fb.c,v 11.6 2002/08/20 17:07:25 jra Exp $ (BRL)";
d30 1
a30 1
extern int bn_common_file_size();
d32 2
a33 2
int mread();
int skipbytes();
d66 1
a66 2
get_args( argc, argv )
register char **argv;
d163 1
a163 3
main(argc, argv)
int argc;
char **argv;
d345 1
a345 3
skipbytes( fd, num )
int	fd;
off_t	num;
d372 1
a372 4
mread( fd, bp, num )
int	fd;
register char	*bp;
register int	num;
@


11.6
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/pix-fb.c,v 11.4 2001/04/12 17:44:08 bparker Exp $ (BRL)";
@


11.6.4.1
log
@sync to HEAD...
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/fb/pix-fb.c,v 11.7 2004/02/02 17:39:01 morrison Exp $ (BRL)";
@


11.6.10.1
log
@merge from HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/pix-fb.c,v 11.7 2004/02/02 17:39:01 morrison Exp $ (BRL)";
@


11.6.10.2
log
@merge from head
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/pix-fb.c,v 11.6.10.1 2004/02/12 19:40:46 erikg Exp $ (BRL)";
@


11.6.2.1
log
@Initial ANSIfication
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/pix-fb.c,v 11.6 2002/08/20 17:07:25 jra Exp $ (BRL)";
d30 1
a30 1
extern int bn_common_file_size(int *, int *, const char *, int);
d32 2
a33 2
int mread(int fd, register char *bp, register int num);
int skipbytes(int fd, off_t num);
d66 2
a67 1
get_args(int argc, register char **argv)
d164 3
a166 1
main(int argc, char **argv)
d348 3
a350 1
skipbytes(int fd, off_t num)
d377 4
a380 1
mread(int fd, register char *bp, register int num)
@


11.6.2.2
log
@sync branch with HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.5
log
@Converted from K&R to ANSI C - RFH
@
text
@d30 1
a30 1
extern int bn_common_file_size(int *, int *, const char *, int);
d32 2
a33 2
int mread(int fd, register char *bp, register int num);
int skipbytes(int fd, off_t num);
d66 2
a67 1
get_args(int argc, register char **argv)
d164 3
a166 1
main(int argc, char **argv)
d348 3
a350 1
skipbytes(int fd, off_t num)
d377 4
a380 1
mread(int fd, register char *bp, register int num)
@


11.4
log
@*- get rid of warnings
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/pix-fb.c,v 11.3 2000/08/24 03:58:33 mike Exp $ (BRL)";
d30 1
a30 1
extern int bn_common_file_size();
d32 2
a33 2
int mread();
int skipbytes();
d66 1
a66 2
get_args( argc, argv )
register char **argv;
d163 1
a163 3
main(argc, argv)
int argc;
char **argv;
d345 1
a345 3
skipbytes( fd, num )
int	fd;
off_t	num;
d372 1
a372 4
mread( fd, bp, num )
int	fd;
register char	*bp;
register int	num;
@


11.3
log
@
const RCSid
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/pix-fb.c,v 11.2 1996/12/31 17:43:25 jra Exp $ (BRL)";
d29 6
d65 1
d163 1
d347 1
d376 1
@


11.2
log
@changed call to fb_common_file_size to bn_common_file_size.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/pix-fb.c,v 11.1 1995/01/04 10:09:39 mike Rel4_4 jra $ (BRL)";
@


11.1
log
@Release_4.4
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/pix-fb.c,v 10.4 94/10/12 15:55:36 jra Exp $ (BRL)";
d172 1
a172 1
		if( fb_common_file_size(&w, &h, file_name, 3) ) {
@


10.4
log
@Fixed bug with negative value for -X option.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/pix-fb.c,v 10.3 94/08/23 18:49:15 gdurf Exp Locker: jra $ (BRL)";
@


10.3
log
@Added includes, factored ifdefs
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/pix-fb.c,v 10.2 1994/08/04 20:35:55 gdurf Exp gdurf $ (BRL)";
d162 1
a162 1
	int	xout, yout, n, m;
d194 13
a206 1
	xout = scr_width - scr_xoff;
d213 3
d286 7
a292 2
			if( file_xoff != 0 )
				skipbytes( infd, (off_t)file_xoff*sizeof(RGBpixel) );
d295 1
a295 1
			m = fb_write( fbp, scr_xoff, y, scanline, xout );
d303 2
a304 2
			if( xout < file_width-file_xoff )
				skipbytes( infd, (off_t)(file_width-file_xoff-xout)*sizeof(RGBpixel) );
d309 7
a315 2
			if( file_xoff != 0 )
				skipbytes( infd, (off_t)file_xoff*sizeof(RGBpixel) );
d318 1
a318 1
			m = fb_write( fbp, scr_xoff, y, scanline, xout );
d326 2
a327 2
			if( xout < file_width-file_xoff )
				skipbytes( infd, (off_t)(file_width-file_xoff-xout)*sizeof(RGBpixel) );
@


10.2
log
@Fixed lseek to use off_t instead of long
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/pix-fb.c,v 10.1 91/10/12 06:46:43 mike Rel4_0 Locker: mike $ (BRL)";
d22 2
d26 1
a26 1
#include "externs.h"
@


10.1
log
@Release_4.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/pix-fb.c,v 9.12 91/09/23 02:33:26 mike Exp $ (BRL)";
d23 2
d27 1
a27 5
extern int	getopt();
extern char	*optarg;
extern int	optind;

static RGBpixel *scanline;		/* 1 scanline pixel buffer */
d213 1
a213 1
	if( (scanline = (RGBpixel *)malloc(scanbytes)) == RGBPIXEL_NULL )  {
d239 1
a239 1
	if( file_yoff != 0 ) skipbytes( infd, file_yoff*file_width*sizeof(RGBpixel) );
d270 1
a270 1
				skipbytes( infd, file_xoff*sizeof(RGBpixel) );
d282 1
a282 1
				skipbytes( infd, (file_width-file_xoff-xout)*sizeof(RGBpixel) );
d288 1
a288 1
				skipbytes( infd, file_xoff*sizeof(RGBpixel) );
d300 1
a300 1
				skipbytes( infd, (file_width-file_xoff-xout)*sizeof(RGBpixel) );
d314 1
a314 1
long	num;
d319 1
a319 1
		(void)lseek( fd, num, 1 );
@


9.12
log
@Added -m #lines flag for multi-line writes,
and made one-line-at-a-time writing the default.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/pix-fb.c,v 9.11 91/09/23 02:23:49 mike Exp $ (BRL)";
@


9.11
log
@Fixed problem reported by Phil, whereby
multi-line write support would write beyond the top of the framebuffer.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/pix-fb.c,v 9.10 91/01/11 00:47:24 mike Exp $ (BRL)";
d33 1
a33 1
static int	streamline = 0;		/* Streamlined operation */
d54 1
a54 1
Usage: pix-fb [-a -h -i -c -z -1] [-F framebuffer]\n\
d64 1
a64 1
	while ( (c = getopt( argc, argv, "1ahiczF:s:w:n:x:y:X:Y:S:W:N:" )) != EOF )  {
d69 3
d208 1
a208 1
	if( !one_line_only && !inverse && !zoom &&
d211 1
a211 2
		streamline = 16;
	    	scanpix *= streamline;
d243 1
a243 1
	if( streamline )  {
d246 1
a246 1
		for( y = scr_yoff; y < scr_yoff + yout; y += streamline )  {
d249 1
a249 1
			height = streamline;
@


9.10
log
@Added error checking to fb_close().
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pix-fb.c,v 9.9 91/01/05 00:24:05 mike Exp $ (BRL)";
d252 4
@


9.9
log
@Added -1 flag, to allow comparison of fb_write() and fb_writerect()
modes of operation.
Intended to be a temporary aid to compare the performance.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pix-fb.c,v 9.8 91/01/05 00:04:22 mike Exp $ (BRL)";
d299 3
a301 1
	fb_close( fbp );
@


9.8
log
@Changed from fb_zoom to fb_view
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pix-fb.c,v 9.7 91/01/04 22:45:28 mike Exp $ (BRL)";
d51 1
d54 1
a54 1
Usage: pix-fb [-a -h -i -c -z] [-F framebuffer]\n\
d64 1
a64 1
	while ( (c = getopt( argc, argv, "ahiczF:s:w:n:x:y:X:Y:S:W:N:" )) != EOF )  {
d66 3
d205 1
a205 1
	if( !inverse && !zoom &&
@


9.7
log
@Added extra checking of return codes.
Slightly relaxed restrictions on when multi-line writes could be done.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pix-fb.c,v 9.7 91/01/04 20:46:16 mike Exp $ (BRL)";
d220 13
a232 6
		/* Zoom in, and center the display */
		fb_zoom( fbp, scr_width/xout, scr_height/yout );
		if( inverse )
			fb_window( fbp, scr_xoff+xout/2, scr_height-1-(scr_yoff+yout/2) );
		else
			fb_window( fbp, scr_xoff+xout/2, scr_yoff+yout/2 );
@


9.6
log
@If named file can not be opened, give perror() message,
and exit -- don't give usage message too!
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pix-fb.c,v 9.5 90/11/12 21:08:57 mike Exp $ (BRL)";
d186 1
a186 1
	/* compute pixels output to screen */
d188 6
a193 2
	if( xout < 0 ) xout = 0;
	if( xout > (file_width-file_xoff) ) xout = (file_width-file_xoff);
d195 4
a198 3
	if( yout < 0 ) yout = 0;
	if( yout > (file_height-file_yoff) ) yout = (file_height-file_yoff);
	scanpix = xout;			/* # pixels on scanline */
d202 2
a203 4
	    xout == scr_width &&
	    file_xoff == 0 &&
	    file_width == scr_width &&
	    (file_height%16) == 0  )  {
d241 2
a242 1
			m = fb_writerect( fbp, 0, y, scr_width, height,
d244 1
a244 1
			if( m != scr_width*height )
d246 4
a249 2
					"pix-fb: fb_writerect(x=0, y=%d, w=%d, h=%d) failure, ret=%d, s/b=%d\n",
					y, scr_width, height, m, scanbytes );
d258 7
a264 1
			fb_write( fbp, scr_xoff, y, scanline, xout );
d276 7
a282 1
			fb_write( fbp, scr_xoff, y, scanline, xout );
@


9.5
log
@Improved short read handling, eliminated anoying printf.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pix-fb.c,v 9.4 90/11/03 17:36:53 mike Exp $ (BRL)";
d134 1
d138 1
a138 1
			return(0);
@


9.4
log
@Better messages and error handling for multi-line case
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pix-fb.c,v 9.3 90/11/03 16:47:08 mike Exp $ (BRL)";
d234 1
a234 4
				fprintf(stderr,
					"pix-fb: short read, y=%d, nbytes=%d s/b=%d\n",
					y, n, scanbytes);
				height = n/(xout*sizeof(RGBpixel));
@


9.3
log
@Changed to use fb_writerect() in the multi-line writing case.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pix-fb.c,v 9.2 90/11/03 14:36:07 mike Exp $ (BRL)";
d198 3
a200 2
	    file_width == scr_width )  {
		streamline = 8;
d228 1
d232 9
a240 1
			m = fb_writerect( fbp, 0, y, scr_width, streamline,
d242 1
a242 1
			if( n/sizeof(RGBpixel) != m )
d244 2
a245 2
					"pix-fb: fb_write failure y=%d %d %d\n",
					y, n/sizeof(RGBpixel), m );
@


9.2
log
@Added Phil's autosize code, on -a flag
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 9.1 89/05/19 06:09:58 phil Locked $ (BRL)";
d230 2
a231 1
			m = fb_write( fbp, 0, y, scanline, n/sizeof(RGBpixel));
@


9.1
log
@Release_3.5
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 8.2 89/04/11 22:15:25 phil Exp $ (BRL)";
d40 1
d53 1
a53 1
Usage: pix-fb [-h -i -c -z] [-F framebuffer]\n\
d63 1
a63 1
	while ( (c = getopt( argc, argv, "hiczF:s:w:n:x:y:X:Y:S:W:N:" )) != EOF )  {
d65 3
d72 1
d89 1
d93 1
d97 1
d159 11
@


8.2
log
@multiline write doesn't work if you need to skip input pixels!
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 8.1 88/10/05 00:42:31 phil Locked $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 7.4 88/10/01 06:34:45 mike Exp $ (BRL)";
d178 2
a179 1
	    file_xoff == 0 )  {
@


7.4
log
@Added "streamline" mode, which uses multi-line writes.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 7.3 88/10/01 04:21:27 mike Locked $ (BRL)";
@


7.3
log
@Eliminated 2048 MAX_LINE limit.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 7.2 88/05/22 23:51:55 mike Locked $ (BRL)";
d31 1
d33 2
d146 1
a146 1
	int	xout, yout, n;
d173 1
d175 9
a183 1
	scanbytes = xout * sizeof(RGBpixel);
d205 12
a216 1
	if( !inverse )  {
@


7.2
log
@Removed colormap diddling.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 7.1 87/11/03 00:08:12 mike Locked $ (BRL)";
d29 2
a30 3
#define MAX_LINE	2048		/* Max pixels/line */
static RGBpixel scanline[MAX_LINE];	/* 1 scanline pixel buffer */
static int scanbytes;			/* # of bytes of scanline */
d170 7
a176 3
	if( xout > MAX_LINE ) {
		fprintf( stderr, "pix-fb: can't output %d pixel lines.\n", xout );
		exit( 2 );
a177 1
	scanbytes = xout * sizeof(RGBpixel);
d237 1
a237 1
		try = num > MAX_LINE ? MAX_LINE : num;
@


7.1
log
@Release 2.3
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 6.1 87/07/11 08:11:30 mike Rel $ (BRL)";
a178 1
		fb_wmap( fbp, COLORMAP_NULL );
@


6.1
log
@Release 2.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 5.1 87/06/24 22:42:05 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 4.2 87/02/13 00:42:47 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 4.1 86/12/29 03:13:20 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 1.20 86/11/28 19:04:19 mike Exp $ (BRL)";
@


1.20
log
@Made variables static, to prevent conflicts with frame buffer
libraries (like "clear" in SGI library).
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 1.19 86/11/26 08:34:14 mike Locked $ (BRL)";
@


1.19
log
@Fixed open() checking.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 1.18 86/11/26 04:40:31 mike Locked $ (BRL)";
d30 1
a30 1
RGBpixel scanline[MAX_LINE];		/* 1 scanline pixel buffer */
d33 3
a35 3
char	*framebuffer = NULL;
char	*file_name;
int	infd;
d37 1
a37 1
int	fileinput = 0;		/* file of pipe on input? */
d39 9
a47 9
int	file_width = 512;	/* default input width */
int	file_height = 512;	/* default input height */
int	scr_width = 0;		/* screen tracks file if not given */
int	scr_height = 0;
int	file_xoff, file_yoff;
int	scr_xoff, scr_yoff;
int	clear = 0;
int	zoom = 0;
int	inverse = 0;			/* Draw upside-down */
d49 1
a49 1
char usage[] = "\
@


1.18
log
@changed file_height default from infinite to 512.
made -h set both screen and file.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 1.17 86/11/24 19:06:40 phil Locked $ (BRL)";
d123 1
a123 1
		if( (infd = open(file_name, 0)) == NULL )  {
@


1.17
log
@Added -F flag to allow selection of framebuffer.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 1.16 86/11/14 23:31:56 kermit Locked $ (BRL)";
a28 1
#define	INFIN		999999		/* An "infinite" file size */
d40 1
a40 1
int	file_height = INFIN;	/* default input height */
d65 1
d154 1
a154 1
	if( scr_height == 0 && file_height != INFIN )
a180 5
	/*
	 * We use Xout in the Y values if file_height == INFIN since we
	 * assume files have infinite height! (thus yout is always
	 * scr_height-scr_yoff)
	 */
d182 6
a187 14
		/* Zoom in, in the center of view */
		if( file_height == INFIN ) {
			fb_zoom( fbp, scr_width/xout, scr_height/xout );
			if( inverse )
				fb_window( fbp, scr_xoff+xout/2, scr_height-1-(scr_yoff+xout/2) );
			else
				fb_window( fbp, scr_xoff+xout/2, scr_yoff+xout/2 );
		} else {
			fb_zoom( fbp, scr_width/xout, scr_height/yout );
			if( inverse )
				fb_window( fbp, scr_xoff+xout/2, scr_height-1-(scr_yoff+yout/2) );
			else
				fb_window( fbp, scr_xoff+xout/2, scr_yoff+yout/2 );
		}
@


1.16
log
@arg convention
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 1.15 86/11/13 01:24:35 phil Locked $ (BRL)";
d34 1
d51 1
a51 1
Usage: pix-fb [-h -i -c -z]\n\
d61 1
a61 1
	while ( (c = getopt( argc, argv, "hiczs:w:n:x:y:X:Y:S:W:N:" )) != EOF )  {
d76 3
d157 1
a157 1
	if( (fbp = fb_open( NULL, scr_width, scr_height )) == NULL )
@


1.15
log
@removed stdio, added positioning code and pipe support, made zoom optional.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 1.14 86/10/30 22:32:00 phil Exp $ (BRL)";
d51 1
a51 1
	[-s squarefilesize] [-w file_width]\n\
d53 1
a53 1
	[-S squarescrsize] [-W scr_width] [-H scr_height] [file.pix]\n";
d60 1
a60 1
	while ( (c = getopt( argc, argv, "hiczs:w:x:y:X:Y:S:W:H:" )) != EOF )  {
d82 3
d103 1
a103 1
		case 'H':
d178 1
a178 1
	 * XXX - we use Xout in the Y values since we currently always
d184 13
a196 5
		fb_zoom( fbp, scr_width/xout, scr_height/xout );
		if( inverse )
			fb_window( fbp, scr_xoff+xout/2, scr_height-1-(scr_yoff+xout/2) );
		else
			fb_window( fbp, scr_xoff+xout/2, scr_yoff+xout/2 );
d199 1
a199 1
/*	if( file_yoff != 0 ) skipbytes( infd, file_yoff*file_width*3 );*/
@


1.14
log
@return 1
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 1.13 86/10/25 10:35:50 phil Locked $ (BRL)";
d29 1
d34 2
a35 2
char *file_name;
FILE *infp;
d37 1
a37 4
int inverse = 0;			/* Draw upside-down */
int clear = 0;
int height;				/* input height */
int width;				/* input width */
d39 10
d50 4
a53 1
Usage: pix-fb [-h -i -c] [-s squaresize] [-W width] [-H height] [file.pix]\n";
d60 1
a60 1
	while ( (c = getopt( argc, argv, "hics:W:H:" )) != EOF )  {
d64 1
a64 1
			height = width = 1024;
d72 3
d76 2
a77 2
			/* square size */
			height = width = atoi(optarg);
d79 18
d98 1
a98 1
			width = atoi(optarg);
d101 1
a101 1
			height = atoi(optarg);
d113 1
a113 1
		infp = stdin;
d116 1
a116 1
		if( (infp = fopen(file_name, "r")) == NULL )  {
d122 1
d137 1
a138 2
	height = width = 512;		/* Defaults */

d144 5
a148 1
	scanbytes = width * sizeof(RGBpixel);
d150 1
a150 1
	if( (fbp = fb_open( NULL, width, height )) == NULL )
d153 17
d174 13
a186 3
	/* Zoom in, in the center of view */
	fb_zoom( fbp, fb_getwidth(fbp)/width, fb_getheight(fbp)/height );
	fb_window( fbp, width/2, height/2 );
d188 2
d192 9
a200 4
		for( y=0; y < height; y++ )  {
			if( fread( (char *)scanline, scanbytes, 1, infp ) != 1 )
				break;
			fb_write( fbp, 0, y, scanline, width );
d204 9
a212 4
		for( y = height-1; y >= 0; y-- )  {
			if( fread( (char *)scanline, scanbytes, 1, infp ) != 1 )
				break;
			fb_write( fbp, 0, y, scanline, width );
d217 54
@


1.13
log
@RGBpixel conversion
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 1.12 86/10/13 03:22:18 phil Locked $ (BRL)";
d109 1
a109 1
		return 1;
@


1.12
log
@Fixed fb_open params.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 1.11 86/10/13 03:02:17 mike Locked $ (BRL)";
d30 1
a30 1
static char scanline[MAX_LINE*3];	/* 1 scanline pixel buffer */
a35 2
Pixel outline[MAX_LINE];

a40 2
FBIO *fbp;

d102 2
a103 1
	static int y;
d112 1
a112 1
	scanbytes = width * 3;
d114 1
a114 2
	if( (fbp = fb_open( NULL, width, height )) == NULL )  {
		fprintf(stderr,"fb_open failed\n");
d116 1
a116 1
	}
a127 4
			register char *in;
			register Pixel *out;
			register int i;

d130 1
a130 10

			in = scanline;
			out = outline;
			for( i=0; i<width; i++ )  {
				out->red = *in++;
				out->green = *in++;
				out->blue = *in++;
				out++;
			}
			fb_write( fbp, 0, y, outline, width );
a134 4
			register char *in;
			register Pixel *out;
			register int i;

d137 1
a137 10

			in = scanline;
			out = outline;
			for( i=0; i<width; i++ )  {
				out->red = *in++;
				out->green = *in++;
				out->blue = *in++;
				(out++)->spare = 0;
			}
			fb_write( fbp, 0, y, outline, width );
@


1.11
log
@Regularized argument ordering
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 1.10 86/10/13 02:51:35 mike Locked $ (BRL)";
d117 1
a117 1
	if( (fbp = fb_open( NULL, height, width )) == NULL )  {
@


1.10
log
@Converted to getopt(), added non-rectangular display capability.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 1.9 86/10/12 01:52:55 mike Locked $ (BRL)";
d46 1
a46 1
Usage: pix-fb [-h -i -c] [-s squaresize] [-H height] [-W width] [file.pix]\n";
d53 1
a53 1
	while ( (c = getopt( argc, argv, "hics:H:W:" )) != EOF )  {
d59 6
a68 3
		case 'H':
			height = atoi(optarg);
			break;
d72 2
a73 5
		case 'i':
			inverse = 1;
			break;
		case 'c':
			clear = 1;
@


1.9
log
@Neatened call to fb_zoom
@
text
@d4 1
a4 2
 *  Dumb little program to take bottom-up pixel files and
 *  send them to a framebuffer.
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 1.8 86/10/11 22:48:44 mike Locked $ (BRL)";
d25 4
d33 3
d40 2
d45 2
a46 1
char usage[] = "Usage: pix-fb [-h] [-i] [-c] [width] <file.pix\n";
d48 54
a106 3
	static int infd;
	static int nlines;		/* Square:  nlines, npixels/line */
	static int fbsize;
d108 1
a108 4
	if( argc < 1 || isatty(fileno(stdin)) )  {
		fprintf(stderr,"%s", usage);
		exit(1);
	}
d110 3
a112 19
	fbsize = 512;
	nlines = 512;
	while( argc > 1 && argv[1][0] == '-' )  {
		if( strcmp( argv[1], "-h" ) == 0 )  {
			fbsize = 1024;
			nlines = 1024;
			argc--; argv++;
			continue;
		}
		if( strcmp( argv[1], "-i" ) == 0 )  {
			inverse++;
			argc--; argv++;
			continue;
		}
		if( strcmp( argv[1], "-c" ) == 0 )  {
			clear++;
			argc--; argv++;
			continue;
		}
a113 1
	infd = 0;	/* stdin */
d115 1
a115 6
	if( argc == 2 )
		nlines = atoi(argv[1] );
	if( argc > 2 )  {
		fprintf(stderr,"%s", usage);
		exit(1);
	}
d117 1
a117 3
	scanbytes = nlines * 3;

	if( (fbp = fb_open( NULL, fbsize, fbsize )) == NULL )  {
d121 4
a124 2
	if( clear )
		fb_clear( fbp, (Pixel *) 0 );
d126 2
a127 2
	fb_zoom( fbp, fbsize/nlines, fbsize/nlines );
	fb_window( fbp, nlines/2, nlines/2 );
d131 1
a131 1
		for( y=0; y < nlines; y++ )  {
d136 1
a136 1
			if( fread( (char *)scanline, scanbytes, 1, stdin ) != 1 )
d141 1
a141 1
			for( i=0; i<nlines; i++ )  {
d147 1
a147 1
			fb_write( fbp, 0, y, outline, nlines );
d151 1
a151 1
		for( y = nlines-1; y >= 0; y-- )  {
d156 1
a156 1
			if( fread( (char *)scanline, scanbytes, 1, stdin ) != 1 )
d161 1
a161 1
			for( i=0; i<nlines; i++ )  {
d167 1
a167 1
			fb_write( fbp, 0, y, outline, nlines );
@


1.8
log
@Changed to go through fb_exit on unexpected EOFs, too.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 1.7 86/10/06 21:08:22 mike Locked $ (BRL)";
d90 3
a92 3
	fb_zoom( fbp, fbsize==nlines? 0 : fbsize/nlines,
		fbsize==nlines? 0 : fbsize/nlines );
	fb_window( fbp, nlines/2, nlines/2 );		/* center of view */
@


1.7
log
@Converted to new libfb with 1st Quadrant semantics
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 1.6 86/10/03 08:18:02 mike Exp $ (BRL)";
d102 1
a102 1
				exit(0);
d122 1
a122 1
				exit(0);
@


1.6
log
@argc bug
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 1.5 86/10/03 04:52:11 mike Exp $ (BRL)";
d96 1
a96 1
		for( y = nlines-1; y >= 0; y-- )  {
d116 1
a116 1
		for( y=0; y < nlines; y++ )  {
@


1.5
log
@Modified for new libfb calling sequences.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 1.4 86/08/13 04:41:40 mike Exp $ (BRL)";
d55 1
a55 1
	while( argv[1] != NULL && argv[1][0] == '-' )  {
@


1.4
log
@Cleanup for distribution
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d26 1
a26 1
#define MAX_LINE	1024		/* Max pixels/line */
d30 1
a30 1
struct pixel outline[MAX_LINE];
d35 2
d55 1
a55 1
	while( argv[1][0] == '-' )  {
a80 2
	if( nlines > 512 )
		fbsetsize(fbsize);
d84 2
a85 1
	if( fbopen( NULL, CREATE ) < 0 )
d87 1
d89 2
a90 2
		fbclear();
	fbzoom( fbsize==nlines? 0 : fbsize/nlines,
d92 1
a92 1
	fbwindow( nlines/2, nlines/2 );		/* center of view */
d98 1
a98 1
			register struct pixel *out;
d110 1
a110 1
				(out++)->spare = 0;
d112 1
a112 1
			fbwrite( 0, y, outline, nlines );
d118 1
a118 1
			register struct pixel *out;
d132 1
a132 1
			fbwrite( 0, y, outline, nlines );
d135 1
@


1.3
log
@Added -i flag to display upside-down.
@
text
@d7 11
a17 3
 *  Mike Muuss, BRL.
 *
 *  $Revision: 1.2 $
d19 4
d24 1
a25 2
#include "/vld/include/fb.h"

d33 1
d35 1
a35 1
char usage[] = "Usage: pix-fb [-h] [-i] file.pix [width]\n";
d46 1
a46 1
	if( argc < 2 )  {
d53 17
a69 4
	if( strcmp( argv[1], "-h" ) == 0 )  {
		fbsize = 1024;
		nlines = 1024;
		argc--; argv++;
d71 7
a77 3
	if( strcmp( argv[1], "-i" ) == 0 )  {
		inverse++;
		argc--; argv++;
a78 10
	if( strcmp( "-", argv[1] ) == 0 )  {
		infd = 0;	/* stdin */
	} else {
		if( (infd = open( argv[1], 0 )) < 0 )  {
			perror( argv[1] );
			exit(3);
		}
	}
	if( argc >= 3 )
		nlines = atoi(argv[2] );
d86 2
a87 1
	fbclear();
d99 1
a99 1
			if( mread( infd, (char *)scanline, scanbytes ) != scanbytes )
d119 1
a119 1
			if( mread( infd, (char *)scanline, scanbytes ) != scanbytes )
a133 31
}

/*
 *			M R E A D
 *
 * This function performs the function of a read(II) but will
 * call read(II) multiple times in order to get the requested
 * number of characters.  This can be necessary because pipes
 * and network connections don't deliver data with the same
 * grouping as it is written with.
 */
static int
mread(fd, bufp, n)
int fd;
register char	*bufp;
unsigned	n;
{
	register unsigned	count = 0;
	register int		nread;

	do {
		nread = read(fd, bufp, n-count);
		if(nread == -1)
			return(nread);
		if(nread == 0)
			return((int)count);
		count += (unsigned)nread;
		bufp += nread;
	 } while(count < n);

	return((int)count);
@


1.2
log
@newer.
@
text
@d9 1
a9 1
 *  $Revision: 1.1 $
d21 1
a21 1
char usage[] = "Usage: pix-fb [-h] file.pix [width] [fr_offset] [fr_count]\n";
d23 2
a31 2
	static int frame_offset;
	static int frame_count;
d46 4
a59 6
	frame_offset = 0;
	if( argc >= 4 )
		frame_offset = atoi(argv[3]);
	frame_count = 1;
	if( argc >= 5 )
		frame_count = atoi(argv[4]);
a64 2
	(void)lseek( infd, (long)frame_offset*scanbytes*nlines, 0 );

d72 2
a73 1
	while(frame_count-- > 0)  {
d75 20
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
 *  $Revision: 1.4 $
d46 7
a52 3
	if( (infd = open( argv[1], 0 )) < 0 )  {
		perror( argv[1] );
		exit(3);
d82 1
a82 1
			if( read( infd, (char *)scanline, scanbytes ) != scanbytes )
d97 31
@
