head	11.9;
access;
symbols
	ansi-20040405-merged:11.6.2.1
	postmerge-20040405-ansi:11.7
	premerge-20040404-ansi:11.6
	postmerge-autoconf:11.6
	autoconf-freeze:11.6
	premerge-autoconf:11.6
	ansi-20040316-freeze:11.6.2.1
	postmerge-20040315-windows:11.6
	premerge-20040315-windows:11.6
	windows-20040315-freeze:11.6
	autoconf-20031203:11.6
	autoconf-20031202:11.6
	autoconf-branch:11.6.0.10
	phong-branch:11.6.0.8
	photonmap-branch:11.6.0.6
	rel-6-1-DP:11.6
	windows-branch:11.6.0.4
	rel-6-0-2:11.4
	ansi-branch:11.6.0.2
	rel-6-0-1-branch:11.4.0.2
	hartley-6-0-post:11.5
	hartley-6-0-pre:11.4
	rel-6-0-1:11.4
	rel-6-0:11.4
	rel-5-4:11.2
	offsite-5-3-pre:11.3
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1;
locks; strict;
comment	@ * @;


11.9
date	2004.05.24.04.13.26;	author morrison;	state dead;
branches;
next	11.8;

11.8
date	2004.05.10.15.30.42;	author erikg;	state Exp;
branches;
next	11.7;

11.7
date	2004.04.05.07.49.23;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	2002.08.20.17.07.25;	author jra;	state Exp;
branches
	11.6.2.1;
next	11.5;

11.5
date	2002.08.15.20.54.38;	author hartley;	state Exp;
branches;
next	11.4;

11.4
date	2001.04.12.17.44.08;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	2000.08.24.03.58.32;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.07.16.22.05.28;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.09.36;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.23.18.49.13;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.46.41;	author mike;	state Rel4_0;
branches;
next	9.4;

9.4
date	91.08.30.17.58.02;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.08.24.00.19.35;	author cjohnson;	state Exp;
branches;
next	9.2;

9.2
date	90.08.23.22.43.15;	author cjohnson;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.09.27;	author mike;	state Rel3_5;
branches;
next	1.2;

1.2
date	89.03.07.00.24.45;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	89.02.24.17.22.02;	author cjohnson;	state Exp;
branches;
next	;

11.6.2.1
date	2002.09.19.18.00.42;	author morrison;	state Exp;
branches;
next	;


desc
@Show GIF files on a frame buffer.
@


11.9
log
@moved to src/fb/
@
text
@/*	G I F - F B	Gif to Frame Buffer
 *
 * Gif-fb takes a GIF file and writes it to a frame buffer.
 * GIF files contain one or more 1,2,4, or 8 bit deep pictures
 * with one or more color maps. Gif-fb will select the correct
 * color map and display the first picture on the frame-buffer.
 *
 * Entry:
 *	FB_FILE		name of the frame buffer to use.
 *	-i		invert color map.
 *	name		name of the file to display.
 *
 * Exit:
 *	the named gif file has been displayed
 *
 * Author:
 *	Christopher T. Johnson - 89/02/23
 *	The decompress algorithem was taken from compress.c
 *
 * Source:
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 * Distribution Status:
 *	Public Domain, Distribution Unlimitied.
 */

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/fb/gif2fb.c,v 11.8 2004/05/10 15:30:42 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>

#include "machine.h"
#include "externs.h"			/* For getopt */
#include "fb.h"

#define	LSB	0	/* Least Signifigent Byte */
#define MSB	1	/* Most Signifigent Byte */

struct GIF_head {
	char		GH_Magic[6];
	unsigned char	GH_ScreenWidth[2];	/* MSB, LSB */
	unsigned char	GH_ScreenHeight[2];	/* MSB, LSB */
	unsigned char	GH_Flags;
	unsigned char	GH_Background;
	unsigned char	GH_EOB;
	};

struct GIF_Image {
	char		IH_Magic;
	unsigned char	IH_Left[2];		/* MSB, LSB */
	unsigned char	IH_Top[2];		/* MSB, LSB */
	unsigned char	IH_Width[2];		/* MSB, LSB */
	unsigned char	IH_Height[2];		/* MSB, LSB */
	unsigned char	IH_Flags;
	};

struct acolor {
	unsigned char	red;
	unsigned char	green;
	unsigned char	blue;
	};

#define WORD(x)	(((int)x[MSB]<<8)+(int)x[LSB])

int ScreenWidth, ScreenHeight;
int GlobalMap;
int CR;
int GlobalPixels;
int Background;

int MinBits;
int Bits;
int Fresh=1;

struct acolor	GlobalColors[256];
struct acolor	LocalColors[256];

struct GIF_head Header;
struct GIF_Image Im;

char *framebuffer=NULL;

void usage(char **argv);
int getByte(FILE *inp);

int
main(int argc, char **argv)
{
	int	 i,idx,n;
	int	maxcolors;
	int	code;
	int	verbose=0;
	int	headers=0;
	int	interlaced;
	char	*file_name;

	unsigned char line[3*2048];
	unsigned char *lp;

	int lineNumber,lineInc,lineIdx;
	static int lace[4] = {8,8,4,2};
	static int offs[4] = {0,4,2,1};

	FBIO *fbp;
	FILE *fp;

	while ((code = getopt(argc,argv,"vFh")) != EOF){
		switch (code) {
		case 'h':
			headers=1;
			break;
		case 'v':
			verbose=1;
			break;
		case 'F':
			framebuffer = optarg;
			break;
		default:	/* '?' */
			usage(argv);
			exit(1);
		}
	}

	if( optind >= argc )  {
		if( isatty(fileno(stdin)) ) {
			(void) fprintf(stderr, "%s: No input file.\n",argv[0]);
			usage(argv);
			exit(1);
		}
		file_name = "-";
		fp = stdin;
	} else {
		file_name = argv[optind];
		if( (fp = fopen(file_name, "r")) == NULL )  {
			(void)fprintf( stderr,
			    "%s: cannot open \"%s\" for reading\n",argv[0],
			    file_name );
			usage(argv);
			exit(1);
		}
	}
/*
 * read in the Header and then check for consitence.
 */
	n= fread(&Header, 1, 13, fp);

	if (n != 13) {
		fprintf(stderr,"%s: only %d bytes in header.\n",argv[0],n);
		exit(1);
	}

	ScreenWidth = WORD(Header.GH_ScreenWidth);
	ScreenHeight= WORD(Header.GH_ScreenHeight);
	GlobalMap   = (Header.GH_Flags>>7);
	CR	    = (Header.GH_Flags>>4) & 0x07;
	GlobalPixels= (Header.GH_Flags&0x07) + 1;
	if (headers) {
		fprintf(stderr,"-w%d -n%d\n", ScreenWidth, ScreenHeight);
		exit(0);
	}
/*
 * In verbose mode, output a message before checking to allow the
 * "smarter" user look over the header even if the header is barfO.
 */
	if (verbose) {
		fprintf(stderr,"Magic=%.6s, -w%d -n%d, M=%d, cr=%d, pixel=%d, bg=%d\n",
		    Header.GH_Magic, ScreenWidth, ScreenHeight, GlobalMap,
		    CR, GlobalPixels, Header.GH_Background);
	}
	
	if (Header.GH_EOB) {
		fprintf(stderr,"%s: missing EOB in header.\n",argv[0]);
		exit(1);
	}
	maxcolors = 1 << GlobalPixels;

/*
 * Read in the Global color map.
 */
	for (i=0;i<maxcolors;i++) {
		n = fread(&GlobalColors[i], 1, 3, fp);
		if (n != 3) {
			fprintf(stdout,"%s: only read %d global colors.\n",
			    argv[0], i);
			exit(1);
		}
	}
/*
 * Read in the image header.
 */
	n= fread(&Im, 1, sizeof(Im), fp);

	if (n != sizeof(Im)) {
		fprintf(stderr,"%s: only %d bytes in image header.\n",
		    argv[0], n);
		exit(1);
	}
	if (verbose) {
		fprintf(stderr,"Magic=%c, left=%d, top=%d, Width=%d, Height=%d\n",
		    Im.IH_Magic, WORD(Im.IH_Left), WORD(Im.IH_Top), WORD(Im.IH_Width),
		    WORD(Im.IH_Height));
		fprintf(stderr,"Map=%d, Interlaced=%d, pixel=%d\n",
		    Im.IH_Flags>>7, (Im.IH_Flags>>6)&0x01, Im.IH_Flags&0x03);
	}

	interlaced = (Im.IH_Flags>>6)&0x01;

/*
 * Read the image color map if any.
 */
	if (Im.IH_Flags>>7) {
		GlobalPixels= (Im.IH_Flags&0x07) + 1;
		for (i=0;i<maxcolors;i++) {
			n = fread(&GlobalColors[i], 1, 3, fp);
			if (n != 3) {
				fprintf(stdout,
				    "%s: only read %d global colors.\n",
				    argv[0], i);
				exit(1);
			}
		}
	}

	if (WORD(Im.IH_Width) > 2048) {
		fprintf(stderr, "%s: Input line greater than internal buffer!\n",
		    argv[0]);
		exit(1);
	}

	MinBits = getc(fp) + 1;

	if (verbose) {
		fprintf(stderr,"MinBits=%d\n", MinBits);
	}

	if (interlaced ) {
		lineIdx = 0;

		lineNumber = offs[lineIdx];
		lineInc= lace[lineIdx];
	} else {
		lineIdx = 4;
		lineNumber = 0;
		lineInc = 1;
	}
/*
 * Open the frame buffer.
 */
	fbp = fb_open(framebuffer,WORD(Im.IH_Width),
	    WORD(Im.IH_Height));

/*
 * The speed of this loop can be greatly increased by moving all of
 * the WORD macro calls out of the loop.
 */
	for (i=0; i<WORD(Im.IH_Height);i++) {
		int k;
		lp = line;
		for (k=0;k<WORD(Im.IH_Width);k++) {
			idx = getByte(fp);
			*lp++ = GlobalColors[idx].red;
			*lp++ = GlobalColors[idx].green;
			*lp++ = GlobalColors[idx].blue;
		}
		fb_write(fbp,0,WORD(Im.IH_Height)-lineNumber,line,
		    WORD(Im.IH_Width));
		fb_flush(fbp);
		lineNumber += lineInc;
		if (lineNumber >= WORD(Im.IH_Height)) {
			++lineIdx;
			lineInc = lace[lineIdx];
			lineNumber = offs[lineIdx];
		}
	}
	fb_close(fbp);
	return(0);
}
/* getcode - Get a LWZ "code"
 *
 * getcode returns an LWZ code.  The code size is always less than 
 * 12 bits but could be as small as 2 bits.  This implies that reading
 * one code may not "read" anything from a file.
 *
 * Entry:
 *	inp	a FILE pointer to the input stream.
 *
 * Exit:
 *	returns one code.
 *
 * Uses:
 *	Bits		global variable containing the size of a code.
 *	bitsleft	number of bits left in this byte.
 *	count		number of BYTES left in this Block.
 *	lastbits	the left over bits form the last getcode call.
 *
 * Calls:
 * 	none.
 *
 * Method:
 *	while not enough bits for a code do
 *		read another byte (8 bits)
 *	endwhile
 *	extract the code.
 *	clean up the state variables.
 *
 * N.B.!!!	This code depends on the '>>' operator zero filling
 *		from the left.
 */
int
getcode(FILE *inp)
{
	static unsigned int lastbits = 0;
	static int bitsleft = 0;
	static int count=0;
	int code;


	while (bitsleft < Bits) {
/*
 * get a new block counter if needed.
 */
		if (--count <= 0) {
			count = (unsigned char) getc(inp);
			if (count == 0) return(-1);
		}
/*
 * stuff another byte into last bits.
 */
		lastbits |= (unsigned char) getc(inp) << bitsleft;
		bitsleft += 8;
	}
	code = (1<<Bits)-1;	/* make mask */
	code &= lastbits;	/* extract the code */
/*
 * clean up the state variables.
 */
	bitsleft -= Bits;
	lastbits = lastbits >> Bits;
	return(code);
}

/* getByte	get a byte from the input stream decompressing as we go.
 *
 * getByte uses the somewhat standard LWZ decompress algorthem.  Most
 * of this subroutine is based on "compress.c".  I've added some and
 * deleted others but I do NOT claim that this is original code.
 *
 * Entry:
 *	inp	the input stream point
 *
 * Exit:
 *	returns a "byte".
 *
 * Calls:
 *	getcode		to get the next code from the input stream.
 *
 * Uses:
 *	Bits	current size of the code.
 *	minBits	the min. size of the code.
 *
 * Method:
 *	Being unable to read the papers that everybody else points to,
 *	I had to decipher the compress code.  This is how I thing this
 *	compression algorithem works.
 *	if this is the first time the routine has been called then
 *		initialize the code sizes
 *		set the "tree" so that all "characters" are at the root.
 *	endif
 *	get a new code
 *	if the new code is greater than the current max code then
 *		add last(?) code to the tree.
 *		follow the tree from the leaf to the root outputing
 *		    a "byte" for each node of the tree.
 *	endif
 */
int getByte(FILE *inp)
{
	int code,incode;
	static int	firstcode,oldcode;
	static int	firstTime = 1;
	static int	clear_code,end_code;
	static int	max_code,next_ent;
#define	PREFIX	0
#define SUFIX	1
	static int	table[2][1<<12];
	static int	stack[1<<13],*sp;

	int i;

	if (firstTime) {
		firstTime = 0;
		Bits = MinBits;
		clear_code = 1 << (Bits-1);
		end_code = clear_code+1;
		max_code=clear_code<<1;
		next_ent = clear_code+2;

		for (i=0;i<clear_code;i++) {
			table[PREFIX][i] = 0;
			table[SUFIX][i]  = i;
		}

		sp = stack;

		do {
			firstcode=oldcode=getcode(inp);
		} while (firstcode == clear_code);
		return(firstcode);
	}

	if (sp > stack) return(*--sp);

	while ((code=getcode(inp)) >= 0) {
		if (code == clear_code) {
			for (i=0;i<clear_code;i++) {
				table[PREFIX][i] = 0;
				table[SUFIX][i]  = i;
			}
			Bits = MinBits;
			max_code = clear_code<<1;
			next_ent = clear_code+2;
			sp=stack;
			firstcode=oldcode=getcode(inp);
			return(firstcode);
		} else if (code == end_code) {
			return (-1);
		}

		incode = code;

		if (code >= next_ent) {
			*sp++ =firstcode;
			code = oldcode;
		}

		while (code >= clear_code) {
			*sp++ = table[SUFIX][code];
			code = table[PREFIX][code];
		}

		*sp++ = firstcode = table[SUFIX][code];

		if ((code=next_ent) < (1<<12)) {
			table[PREFIX][code] = oldcode;
			table[SUFIX][code]  = firstcode;
			next_ent++;
			if ((next_ent >= max_code) &&
			    (max_code < (1<<12))) {
			    	max_code *= 2;
			    	Bits++;
			}
		}

		oldcode = incode;

		if (sp >stack) return(*--sp);
	}
	return(code);
}
void
usage(char **argv)
{
	fprintf(stderr,"%s [-h] [-v] [-F frame_buffer] [gif_file]\n",argv[0]);
}
@


11.8
log
@change conf.h to a wrapped config.h
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/fb/gif2fb.c,v 11.7 2004/04/05 07:49:23 morrison Exp $ (BRL)";
@


11.7
log
@merge of ansi-6-0-branch into HEAD
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d33 5
a37 1
#include "conf.h"
@


11.6
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/gif2fb.c,v 11.4 2001/04/12 17:44:08 bparker Exp $ (BRL)";
d88 2
a89 2
void usage();
int getByte();
d92 1
a92 3
main(argc,argv)
int argc;
char **argv;
d315 1
a315 2
getcode(inp)
FILE *inp;
d381 1
a381 2
int getByte(inp)
FILE	*inp;
d466 1
a466 2
usage(argv)
char **argv;
@


11.6.2.1
log
@Initial ANSIfication
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/gif2fb.c,v 11.6 2002/08/20 17:07:25 jra Exp $ (BRL)";
d88 2
a89 2
void usage(char **argv);
int getByte(FILE *inp);
d92 3
a94 1
main(int argc, char **argv)
d317 2
a318 1
getcode(FILE *inp)
d384 2
a385 1
int getByte(FILE *inp)
d470 2
a471 1
usage(char **argv)
@


11.5
log
@Converted from K&R to ANSI C - RFH
@
text
@d88 2
a89 2
void usage(char **argv);
int getByte(FILE *inp);
d92 3
a94 1
main(int argc, char **argv)
d317 2
a318 1
getcode(FILE *inp)
d384 2
a385 1
int getByte(FILE *inp)
d470 2
a471 1
usage(char **argv)
@


11.4
log
@*- get rid of warnings
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/gif2fb.c,v 11.3 2000/08/24 03:58:32 mike Exp $ (BRL)";
d88 2
a89 2
void usage();
int getByte();
d92 1
a92 3
main(argc,argv)
int argc;
char **argv;
d315 1
a315 2
getcode(inp)
FILE *inp;
d381 1
a381 2
int getByte(inp)
FILE	*inp;
d466 1
a466 2
usage(argv)
char **argv;
@


11.3
log
@
const RCSid
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/gif2fb.c,v 11.2 1996/07/16 22:05:28 jra Exp $ (BRL)";
d89 1
d91 1
d283 1
d316 1
@


11.2
log
@Minor Mods for IRIX 6.2
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/gif2fb.c,v 11.1 1995/01/04 10:09:36 mike Rel4_4 jra $ (BRL)";
@


11.1
log
@Release_4.4
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/gif2fb.c,v 10.2 94/08/23 18:49:13 gdurf Exp $ (BRL)";
d88 2
d465 1
@


10.2
log
@Added includes, factored ifdefs
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/gif2fb.c,v 10.1 1991/10/12 06:46:41 mike Rel4_0 gdurf $ (BRL)";
@


10.1
log
@Release_4.0
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/gif2fb.c,v 9.4 91/08/30 17:58:02 mike Exp $ (BRL)";
d33 2
d36 3
a84 4

extern int	getopt();
extern char	*optarg;
extern int	optind;
@


9.4
log
@Stardent ANSI lint
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/gif2fb.c,v 9.3 90/08/24 00:19:35 cjohnson Exp $ (BRL)";
@


9.3
log
@Change all references from gif-fb to %s,argv[0]
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/gif2fb.c,v 9.2 90/08/23 22:43:15 cjohnson Exp $ (BRL)";
d63 1
a63 1
#define WORD(x)	(((int)x[MSB]<<8)+x[LSB])
@


9.2
log
@Add 'h' option to output -w%d -n%d to stdout
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: gif2fb.c,v 9.1 89/05/19 06:09:27 mike Rel3_5 $ (BRL)";
d121 1
a121 1
			usage();
d128 2
a129 2
			(void) fprintf(stderr, "gif-fb: No input file.\n");
			usage();
d138 1
a138 1
			    "gif-fb: cannot open \"%s\" for reading\n",
d140 1
a140 1
			usage();
d150 1
a150 1
		fprintf(stderr,"gif-fb: only %d bytes in header.\n",n);
d174 1
a174 1
		fprintf(stderr,"gif-fb: missing EOB in header.\n");
d185 2
a186 2
			fprintf(stdout,"gif-fb: only read %d global colors.\n",
			    i);
d196 2
a197 1
		fprintf(stderr,"gif-fb: only %d bytes in image header.\n",n);
d219 2
a220 2
				    "gif-fb: only read %d global colors.\n",
				    i);
d227 2
a228 1
		fprintf(stderr, "gif-fb: Input line greater than internal buffer!\n");
d462 2
a463 1
usage()
d465 1
a465 1
	fprintf(stderr,"gif-fb [-v] [-F frame_buffer] [gif_file]\n");
@


9.1
log
@Release_3.5
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: gif-fb.c,v 1.2 89/03/07 00:24:45 mike Exp $ (BRL)";
d95 1
d109 1
a109 1
	while ((code = getopt(argc,argv,"vF")) != EOF){
d111 3
d159 4
@


1.2
log
@Header file location change
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: gif-fb.c,v 1.1 89/02/24 17:22:02 mike Locked $ (BRL)";
@


1.1
log
@Initial revision
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d34 1
a34 1
#include <brlcad/fb.h>
@
