head	11.10;
access;
symbols
	ansi-20040405-merged:11.7.2.1
	postmerge-20040405-ansi:11.8
	premerge-20040404-ansi:11.7
	postmerge-autoconf:11.7
	autoconf-freeze:11.7
	premerge-autoconf:11.7
	ansi-20040316-freeze:11.7.2.1
	postmerge-20040315-windows:11.7
	premerge-20040315-windows:11.7
	windows-20040315-freeze:11.7
	autoconf-20031203:11.7
	autoconf-20031202:11.7
	autoconf-branch:11.7.0.10
	phong-branch:11.7.0.8
	photonmap-branch:11.7.0.6
	rel-6-1-DP:11.7
	windows-branch:11.7.0.4
	rel-6-0-2:11.5
	ansi-branch:11.7.0.2
	rel-6-0-1-branch:11.5.0.2
	hartley-6-0-post:11.6
	hartley-6-0-pre:11.5
	rel-6-0-1:11.5
	rel-6-0:11.5
	rel-5-4:11.3
	offsite-5-3-pre:11.4
	rel-5-3:11.3
	rel-5-2:11.3
	rel-5-1-branch:11.3.0.2
	rel-5-1:11.3
	rel-5-0:11.3
	rel-5-0-beta:11.3
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.10
date	2004.05.24.04.13.27;	author morrison;	state dead;
branches;
next	11.9;

11.9
date	2004.05.10.15.30.42;	author erikg;	state Exp;
branches;
next	11.8;

11.8
date	2004.04.05.07.49.23;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2002.08.20.17.07.26;	author jra;	state Exp;
branches
	11.7.2.1;
next	11.6;

11.6
date	2002.08.15.20.54.39;	author hartley;	state Exp;
branches;
next	11.5;

11.5
date	2001.04.12.17.44.08;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	2000.08.24.03.58.35;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	98.09.22.03.03.09;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.07.16.22.05.28;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.09.44;	author mike;	state Rel4_4;
branches;
next	10.4;

10.4
date	94.11.14.22.30.43;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.08.23.18.49.20;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.08.11.15.06.19;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.46.48;	author mike;	state Rel4_0;
branches;
next	1.5;

1.5
date	91.08.29.23.57.54;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	91.07.02.03.38.41;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	91.01.29.16.15.49;	author pjt;	state Exp;
branches;
next	1.2;

1.2
date	91.01.23.20.50.43;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	91.01.23.20.37.47;	author mike;	state Exp;
branches;
next	;

11.7.2.1
date	2002.09.19.18.00.43;	author morrison;	state Exp;
branches;
next	;


desc
@Polar plotting program
@


11.10
log
@moved to src/fb/
@
text
@/*
 *			P O L A R - F B . C
 *
 *	This routine plots normalized polar functions on a frame buffer.
 *
 *  Author -
 *	Paul J. Tanenbaum <pjt@@brl.mil>
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimitied.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/fb/polar-fb.c,v 11.9 2004/05/10 15:30:42 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>

#include "machine.h"
#include "externs.h"
#include "fb.h"

void PrintUsage(int ShoOpts);
void ArgCompat(int Interior);
int LoadNPF(char *FileName, double *Table, int Quantum, double convert, double arc_min, double arc_max);
int OnGrid(double theta, double rho);

/* Program constants */
#define		High_Size	1024
#define		GRID_RHO_EPS	0.005
#define		GRID_THETA_EPS	0.2
#ifndef M_PI
#define		M_PI		3.14159265358979323846
#define		M_PI_2		1.57079632679489661923
#endif

/* Color[] indices */
#define		C_BKGRND	   0
#define		C_PERIM		   1
#define		C_RAMP		   2
#define		C_INTERIOR	   2
#define		C_BLACK		   3
#define		C_WHITE		   4
#define		C_RED		   5
#define		C_ORANGE	   6
#define		C_YELLOW	   7
#define		C_GREEN		   8
#define		C_BLUE		   9

/* Interior filling codes */
#define		BI_EMPTY	   0
#define		BI_CONSTANT	   1
#define		BI_RINGS	   2
#define		BI_WEDGES	   3
#define		BI_RAMP		   4

/* Half codes */
#define		H_LEFT		   1
#define		H_RIGHT		  -1

/* Macros */
#define		npf_index(a)	((int) ((a) / Quantum + 0.5))

#ifndef	bool
#define		bool		int
#endif
#ifndef TRUE
#define		TRUE		(1)
#endif
#ifndef FALSE
#define		FALSE		(0)
#endif

/* Global variables */
char		*ProgName;	/* To save argv[0] */
char		*ExplainOpts[] = {
    " -F fbfile specifies frame-buffer file\n", 
    " -N h      specifies FB height (pixels)\n",
    " -S s      specifies FB height and width (pixels)\n",
    " -W w      specifies FB width (pixels)\n",
    " -a u v    plots only the part of function between u and v (degrees)\n", 
    " -b r g b  sets background color (0 .. 255)\n", 
    " -c        clears FB to background color\n", 
    " -e        plots no function interior (useful with -p)\n", 
    " -g        plots no polar grid\n", 
    " -h        specifies high-resolution mode (same as -S 1024)\n", 
    " -i r g b  plots function with constant interior color (0 .. 255)\n", 
    " -l r g b  plots function with a linear ramp (0 .. 255)\n", 
    " -m        merges plot with current contents of FB\n", 
    " -n        no-warning mode.  Aborts if any irregular input\n", 
    " -o x y    translates plot (pixels)\n", 
    " -p r g b  plots function perimeter (0 .. 255)\n", 
    " -q q      sets angular quantum (degrees)\n", 
    " -r        specifies radian input (default is degrees)\n", 
    " -s s      scales plot (pixels)\n", 
    " -t t      rotates function (degrees)\n", 
    " -w        plots function with angular wedges\n", 
    " -z side   plots only one half of function ('l' or 'r')\n",
    ""
};
double		Deg2Rad;	/* Factor to convert degrees to radians */
RGBpixel	Color[] = {
    { 255, 255, 255 },		/* Background */
    {   0,   0,   0 },		/* Perimeter */
    {   0,   0,   0 },		/* Interior or ramp top */
    {   0,   0,   0 },		/* Black */
    { 255, 255, 255 },		/* White */
    { 255,   0,   0 },		/* Red */
    { 255, 128,   0 },		/* Orange */
    { 255, 255,   0 },		/* Yellow */
    { 100, 255,  75 },		/* Green */
    {   0,   0, 255 }		/* Blue */
};

int
main (int argc, char **argv)
{
    bool	clr_fb = FALSE;	/* Clear the frame buffer first? */
    bool	draw_grid = TRUE;	/* Plot the plolar axes? */
    bool	merge = FALSE;	/* Overlay data on current contents FB? */
    bool	NoWarnings = FALSE;	/* Abort if any irregular input? */
    bool	perimeter = FALSE;	/* Plot perimeter of function? */
    char	*FB_Name;	/* Name of frame-buffer file */
    char	*FileName;	/* Name of input file */
    char	*Opt;		/* Used in parsing command-line options */
    double	angle_cvt;	/* Factor to convert input units to radians */
    double	arc_max = 360.0;/* Greatest value of theta to plot */
    double	arc_min = 0.0;	/* Least      "    "   "    "   "  */
    double	npf_rho;	/* Current entry in npf_tbl */
    double	npf_tbl[360];	/* The function (in (theta, rho) pairs) */
    double	rho, theta;	/* Polar coordinates of current pixel */
    double	twist = 0.0;	/* Clockwise rotation of image (in degrees) */
    int		ctr_x = -1;	/* X-coord of plot center (in pixels) */
    int		ctr_y = -1;	/* Y-  "    "         "     "   "     */
    int		fb_x_loc;	/* X-coord of lower-left of plot (in pixels) */
    int		fb_y_loc;	/* Y-  "    "   "     "   "   "    "   "     */
    int		Half = 0;	/* Plot only half of the function (L or R) */
    int		intensity;	/* RGBpixel component read from command line */
    int		Interior;	/* Manner of filling graph */
    int		LineLength;	/* Width of the plot (in pixels) */
    int		Quantum = 1;	/* Angular resolution of npf_tbl */
    int		fb_width = 0;	/* Width (in pixels) */
    int		fb_height = 0;	/* Height (in pixels) */
    int		theta_index;	/* Theta's index into npf_tbl */
    int		unit_r = -1;	/* Radius of unit circle (in pixels) */
    int		x, y;		/* Cartesian coordinates of current pixel */
    int		X, Y;		/* Translated pixel */
    FBIO	*fbPtr;		/* Pointer to the frame-buffer file */
    unsigned char *fbb;		/* Buffer for current line of frame buffer */
    unsigned char *fbbPtr;	/* Pointer to within fbb */

    void		(*Fill_Func)();
    void		Fill_Empty(unsigned char *fbbPtr, double rho, double npf_rho, int unit_r, int merge);
    void		Fill_Constant(unsigned char *fbbPtr, double rho, double npf_rho, int unit_r, int merge);
    void		Fill_Ramp(unsigned char *fbbPtr, double rho, double npf_rho, int unit_r, int merge);
    void		Fill_Wedges(unsigned char *fbbPtr, double rho, double npf_rho, int unit_r, int merge);
    void		Fill_Rings(unsigned char *fbbPtr, double rho, double npf_rho, int unit_r, int merge);

/* Initialize things */
    ProgName = *argv;
    angle_cvt = Deg2Rad = M_PI / 180.0;
    FB_Name = "";
    Interior = BI_RINGS;
    Color[C_BKGRND][RED] = Color[C_BKGRND][GRN] = Color[C_BKGRND][BLU] = 255;

/* Handle command-line options */
    while ((--argc > 0) && ((*++argv)[0] == '-'))
        for (Opt = argv[0] + 1; *Opt != '\0'; Opt++)
            switch (*Opt)
	    {
		case 'o':		/* Translate the plot */
		    if (argc < 3)
		    {
			(void) fputs("Illegal -o option\n", stderr);
			goto error;
		    }
		    if ((sscanf(argv[1], "%d", &ctr_x) != 1) || (ctr_x < 0))
		    {
			(void) fprintf(stderr, "Illegal -o value: %s\n",
			    argv[1]);
			goto error;
		    }
		    if ((sscanf(argv[2], "%d", &ctr_y) != 1) || (ctr_y < 0))
		    {
			(void) fprintf(stderr, "Illegal -o value: %s\n",
			    argv[2]);
			goto error;
		    }
		    argv += 2;
		    argc -= 2;
		    break;
		case 'W':		/* Scale the plot */
		    if (argc < 2)
		    {
			(void) fputs("Illegal -W option\n", stderr);
			goto error;
		    }
		    if ((sscanf(argv[1], "%d", &fb_width) != 1)
			|| (fb_width < 0))
		    {
			(void) fprintf(stderr, "Illegal -W value: %s\n",
			    argv[1]);
			goto error;
		    }
		    argv++;
		    argc--;
		    break;
		case 'N':		/* Scale the plot */
		    if (argc < 2)
		    {
			(void) fputs("Illegal -N option\n", stderr);
			goto error;
		    }
		    if ((sscanf(argv[1], "%d", &fb_height) != 1)
			|| (fb_height < 0))
		    {
			(void) fprintf(stderr, "Illegal -N value: %s\n",
			    argv[1]);
			goto error;
		    }
		    argv++;
		    argc--;
		    break;
		case 'S':		/* Scale the plot */
		    if (argc < 2)
		    {
			(void) fputs("Illegal -S option\n", stderr);
			goto error;
		    }
		    if ((sscanf(argv[1], "%d", &fb_height) != 1)
			|| (fb_height < 0))
		    {
			(void) fprintf(stderr, "Illegal -S value: %s\n",
			    argv[1]);
			goto error;
		    }
		    fb_width = fb_height;
		    argv++;
		    argc--;
		    break;
		case 's':		/* Scale the plot */
		    if (argc < 2)
		    {
			(void) fputs("Illegal -s option\n", stderr);
			goto error;
		    }
		    if ((sscanf(argv[1], "%d", &unit_r) != 1) || (unit_r <= 0))
		    {
			(void) fprintf(stderr, "Illegal -s value: %s\n",
			    argv[1]);
			goto error;
		    }
		    argv++;
		    argc--;
		    break;
		case 'q':		/* Angular resolution of npf_tbl */
		    if (argc < 2)
		    {
			(void) fputs("Illegal -q option\n", stderr);
			goto error;
		    }
		    if ((sscanf(argv[1], "%d", &Quantum) != 1) ||
			(Quantum <= 0))
		    {
			(void) fprintf(stderr, "Illegal -q value: %s\n",
			    argv[1]);
			goto error;
		    }
		    argv++;
		    argc--;
		    break;
		case 'a':		/* Display an arc of the function */
		    if (argc < 3)
		    {
			(void) fputs("Illegal -a option\n", stderr);
			goto error;
		    }
		    if ((sscanf(argv[1], "%lf", &arc_min) != 1) || (arc_min < 0))
		    {
			(void) fprintf(stderr, "Illegal -a value: %s\n",
			    argv[1]);
			goto error;
		    }
		    if ((sscanf(argv[2], "%lf", &arc_max) != 1) ||
			(arc_max > 360))
		    {
			(void) fprintf(stderr, "Illegal -a value: %s\n",
			    argv[2]);
			goto error;
		    }
		    if (arc_max < arc_min)
		    {
			(void) fprintf(stderr, "Illegal -a values: %g > %g\n",
			    arc_min, arc_max);
			goto error;
		    }
		    argv += 2;
		    argc -= 2;
		    break;
		case 't':		/* Rotate the function */
		    if (argc < 2)
		    {
			(void) fputs("Illegal -t option\n", stderr);
			goto error;
		    }
		    if (sscanf(argv[1], "%lf", &twist) != 1)
		    {
			(void) fprintf(stderr, "Illegal -t value: %s\n",
			    argv[1]);
			goto error;
		    }
		    twist *= Deg2Rad;
		    argv++;
		    argc--;
		    break;
		case 'z':		/* Plot only half of the function */
		    if (argc < 2)
		    {
			(void) fputs("Illegal -z option\n", stderr);
			goto error;
		    }
		    if ((argv[1][0] != 'l' && argv[1][0] != 'r') ||
			argv[1][1] != '\0')
		    {
			(void) fprintf(stderr, "Illegal -z value: %s\n",
			    argv[1]);
			goto error;
		    }
		    Half = (argv[1][0] == 'l') ? H_LEFT : H_RIGHT;
		    argv++;
		    argc--;
		    break;
		case 'b':		/* Specify the background color */
		    if (argc < 4)
		    {
			(void) fputs("Illegal -b option\n", stderr);
			goto error;
		    }
		    if ((sscanf(argv[1], "%d", &intensity) != 1) ||
			(intensity < 0) || (intensity > 255))
		    {
			(void) fprintf(stderr, "Illegal -b value: %s\n",
			    argv[1]);
			goto error;
		    }
		    Color[C_BKGRND][RED] = intensity;
		    if ((sscanf(argv[2], "%d", &intensity) != 1) ||
			(intensity < 0) || (intensity > 255))
		    {
			(void) fprintf(stderr, "Illegal -b value: %s\n",
			    argv[2]);
			goto error;
		    }
		    Color[C_BKGRND][GRN] = intensity;
		    if ((sscanf(argv[3], "%d", &intensity) != 1) ||
			(intensity < 0) || (intensity > 255))
		    {
			(void) fprintf(stderr, "Illegal -b value: %s\n",
			    argv[3]);
			goto error;
		    }
		    Color[C_BKGRND][BLU] = intensity;
		    argv += 3;
		    argc -= 3;
		    break;
		case 'i':		/* Plot with one interior color */
		    ArgCompat(Interior);
		    Interior = BI_CONSTANT;
		    if (argc < 4)
		    {
			(void) fputs("Illegal -i option\n", stderr);
			goto error;
		    }
		    if ((sscanf(argv[1], "%d", &intensity) != 1) ||
			(intensity < 0) || (intensity > 255))
		    {
			(void) fprintf(stderr, "Illegal -i value: %s\n",
			    argv[1]);
			goto error;
		    }
		    Color[C_INTERIOR][RED] = intensity;
		    if ((sscanf(argv[2], "%d", &intensity) != 1) ||
			(intensity < 0) || (intensity > 255))
		    {
			(void) fprintf(stderr, "Illegal -i value: %s\n",
			    argv[2]);
			goto error;
		    }
		    Color[C_INTERIOR][GRN] = intensity;
		    if ((sscanf(argv[3], "%d", &intensity) != 1) ||
			(intensity < 0) || (intensity > 255))
		    {
			(void) fprintf(stderr, "Illegal -i value: %s\n",
			    argv[3]);
			goto error;
		    }
		    Color[C_INTERIOR][BLU] = intensity;
		    argv += 3;
		    argc -= 3;
		    break;
		case 'l':		/* Plot using a linear ramp */
		    ArgCompat(Interior);
		    Interior = BI_RAMP;
		    if (argc < 4)
		    {
			(void) fputs("Illegal -l option\n", stderr);
			goto error;
		    }
		    if ((sscanf(argv[1], "%d", &intensity) != 1) ||
			(intensity < 0) || (intensity > 255))
		    {
			(void) fprintf(stderr, "Illegal -l value: %s\n",
			    argv[1]);
			goto error;
		    }
		    Color[C_RAMP][RED] = intensity;
		    if ((sscanf(argv[2], "%d", &intensity) != 1) ||
			(intensity < 0) || (intensity > 255))
		    {
			(void) fprintf(stderr, "Illegal -l value: %s\n",
			    argv[2]);
			goto error;
		    }
		    Color[C_RAMP][GRN] = intensity;
		    if ((sscanf(argv[3], "%d", &intensity) != 1) ||
			(intensity < 0) || (intensity > 255))
		    {
			(void) fprintf(stderr, "Illegal -l value: %s\n",
			    argv[3]);
			goto error;
		    }
		    Color[C_RAMP][BLU] = intensity;
		    argv += 3;
		    argc -= 3;
		    break;
		case 'm':		/* Merge data with contents of FB */
		    merge = TRUE;
		    break;
		case 'p':		/* Plot the perimeter */
		    perimeter = TRUE;
		    if (argc < 4)
		    {
			(void) fprintf(stderr, "Illegal -%c option\n", *Opt);
			goto error;
		    }
		    if ((sscanf(argv[1], "%d", &intensity) != 1) ||
			(intensity < 0) || (intensity > 255))
		    {
			(void) fprintf(stderr, "Illegal -%c value: %s\n",
			    *Opt, argv[1]);
			goto error;
		    }
		    Color[C_PERIM][RED] = intensity;
		    if ((sscanf(argv[2], "%d", &intensity) != 1) ||
			(intensity < 0) || (intensity > 255))
		    {
			(void) fprintf(stderr, "Illegal -%c value: %s\n",
			    *Opt, argv[2]);
			goto error;
		    }
		    Color[C_PERIM][GRN] = intensity;
		    if ((sscanf(argv[3], "%d", &intensity) != 1) ||
			(intensity < 0) || (intensity > 255))
		    {
			(void) fprintf(stderr, "Illegal -%c value: %s\n",
			    *Opt, argv[3]);
			goto error;
		    }
		    Color[C_PERIM][BLU] = intensity;
		    argv += 3;
		    argc -= 3;
		    break;
		case 'F':		/* Name of frame-buffer file */
		    if (argc < 2)
		    {
			(void) fputs("Illegal -F option\n", stderr);
			goto error;
		    }
		    FB_Name = argv[1];
		    argv++;
		    argc--;
		    break;
		case 'c':		/* Clear the FB initially */
		    clr_fb = TRUE;
		    break;
		case 'e':		/* Plot empty interior */
		    ArgCompat(Interior);
		    Interior = BI_EMPTY;
		    break;
		case 'g':		/* Do not plot axes */
		    draw_grid = FALSE;
		    break;
		case 'h':		/* High-res mode */
		    fb_width = fb_height = High_Size;
		    break;
		case 'r':		/* Input in radians, not degrees */
		    angle_cvt = 1.0;
		    break;
		case 'n':		/* Abort if any irregular input */
		    NoWarnings = TRUE;
		    break;
		case 'w':		/* Plot radius-colored wedges */
		    ArgCompat(Interior);
		    Interior = BI_WEDGES;
		    break;
		case '?':
		error:
		default:
		    PrintUsage(1);
		    (void) exit (*Opt != '?');
	    }

    /* Determine source of input */
    switch (argc)
    {
	case 0:			/* Read stdin */
	    FileName="";
	    break;
	case 1:			/* File name was given */
	    FileName=argv[0];
	    break;
	default:
	    PrintUsage(1);
	    (void) exit(1);
    }

    /* Fill npf_tbl from the input stream */
    if (LoadNPF (FileName, npf_tbl, Quantum, angle_cvt, arc_min, arc_max)
	&& NoWarnings)
	(void) exit(1);
    arc_min *= Deg2Rad;
    arc_max *= Deg2Rad;

    /* Prep the frame buffer */
    if ((fbPtr = fb_open(FB_Name, fb_width, fb_height)) == FBIO_NULL)
	(void) exit (1);
    fb_width = fb_getwidth(fbPtr);
    fb_height = fb_getheight(fbPtr);

    /* Determine both size of FB, and, where necessary, position and
     * scale of plot.
     */
    if (ctr_x == -1)
	ctr_x = fb_width / 2;
    if (ctr_y == -1)
	ctr_y = fb_height / 2;
    if (unit_r == -1)
	unit_r = (ctr_x < ctr_y) ? ctr_x : ctr_y;

    /* Ensure that location and size of the plot and size of
     * the FB are mutually compatible
     */
    if ((ctr_x + unit_r > fb_width) || (ctr_x < unit_r) ||
	(ctr_y + unit_r > fb_height) || (ctr_y < unit_r))
    {
	(void) fputs("Plot not entirely within frame buffer\n", stderr);
	(void) exit (1);
    }

    if (clr_fb)
	fb_clear(fbPtr, Color[C_BKGRND]);

    /* Decide how much of each FB line to process...
     * Half a plot means only half of each scan line,
     * UNLESS the function undergoes non-zero rotation
     */
    if (Half)
	LineLength = unit_r;
    else
	LineLength = 2 * unit_r;
    
    /* Decide where in the FB the lower-left corner of the output goes */
    if (Half == H_RIGHT)
	fb_x_loc = ctr_x;
    else
	fb_x_loc = ctr_x - unit_r;
    fb_y_loc = ctr_y - unit_r;

    /* Decide which Interior-filling routine to use */
    switch (Interior)
    {
	case BI_EMPTY:
	    Fill_Func = Fill_Empty;
	    break;
	case BI_CONSTANT:
	    Fill_Func = Fill_Constant;
	    break;
	case BI_RAMP:
	    Fill_Func = Fill_Ramp;
	    break;
	case BI_WEDGES:
	    Fill_Func = Fill_Wedges;
	    break;
	case BI_RINGS:
	    Fill_Func = Fill_Rings;
	    break;
	default:
	    (void) fputs("Bad interior.  Shouldn't happen\n",
			    stderr);
	    (void) exit (1);
	    break;
    }

    if ((fbb = (unsigned char *) malloc(fb_width * sizeof(RGBpixel))) == NULL)
    {
	(void) fputs("Ran out of memory\n", stderr);
	(void) exit (1);
    }

    /* Fill fbb */
    for (y = 0; y < 2 * unit_r; y++)
    {
	if (merge)
	    fb_read(fbPtr, fb_x_loc, fb_y_loc + y, fbb, LineLength);

	Y = y - unit_r;
	for (x = 0, fbbPtr = fbb; x <  LineLength; x++, fbbPtr+=sizeof(RGBpixel))
	{
	    X = x + fb_x_loc - ctr_x;

	    /* If this point is beyond the unit circle, then skip it */
	    if ((rho = sqrt((double) (X * X) + (double) (Y * Y))) >  unit_r)
	    {
		if (! merge)
		    COPYRGB(fbbPtr, Color[C_BKGRND])
		continue;
	    }

	    /* Determine this point's "azimuth" (i.e., theta) */
	    if (X == 0)
		theta = (Y > 0) ? M_PI : 0.0;
	    else
		theta = atan2((double) Y, (double) X) + M_PI_2;

	    /* If this point is in the wrong half of the plot, skip it */
 	    if (Half && (Half * X > 0))
 		continue;

	    /* Rotate the point for display */
	    theta += twist;
	    while (theta < 0)
		theta += M_PI * 2;
	    while (theta > M_PI * 2)
		theta -= M_PI * 2;

	    /* If this point is outside the arc of interest, skip it */
	    if ((theta < arc_min) || (theta > arc_max))
	    {
		if (! merge)
		    COPYRGB(fbbPtr, Color[C_BKGRND])
		continue;
	    }

	    /* Look up the value of the function for this value of theta */
	    theta_index = npf_index(theta / Deg2Rad);
	    npf_rho = npf_tbl[theta_index];

	    /*
	     * Do the actual filling
	     */

	    /* If this point is outside the function, color it BKGRND */
	    if (rho > npf_rho * unit_r)
	    {
		if (! merge)
		    COPYRGB(fbbPtr, Color[C_BKGRND])
	    }
	    else
	    {
		(*Fill_Func)(fbbPtr, rho, npf_rho, unit_r, merge);

		if (perimeter && (npf_rho - rho / unit_r < .02))
		    COPYRGB(fbbPtr, Color[C_PERIM])
	    }

	    if (draw_grid && OnGrid(theta, rho/unit_r))
		COPYRGB(fbbPtr, Color[C_BLACK])
	}
	fb_write(fbPtr, fb_x_loc, fb_y_loc + y, fbb, LineLength);
    }

    /* Wrap up */
    fb_close(fbPtr);
    return(0);
}

void
PrintUsage (int ShoOpts)
{
    char	**oPtr;		/* Pointer to option string */

    (void) fprintf(stderr, "Usage: '%s [options] [file]'\n", ProgName);
    if (ShoOpts)
    {
	(void) fputs("Options:\n", stderr);
	for (oPtr = ExplainOpts; **oPtr != '\0'; oPtr++)
	    (void) fputs(*oPtr, stderr);
    }
    else
	(void) fputs(" -? option for help\n", stderr);
}

bool
LoadNPF (char *FileName, double *Table, int Quantum, double convert, double arc_min, double arc_max)

    	          	/* Name of input file */
      	       		/* Location for storing function */
   	        	/* Angular resolution of Table (in degrees) */
      	        	/* Factor to convert input units to radians */
      	        	/* First angle of interest */
      	        	/* Last    "    "     "    */

{
    bool	Warnings = 0;	/* Have any warning messages been printed? */
    int		angle;
    int		gap_min;	/* Used in composing warnings */
    int		gap_max;	/*   "   "     "         "    */
    double	theta, rho;
    FILE	*fPtr;

    /* N.B. -	The possible values of Warnings and their meanings are:
     *
     *		Value		Meaning
     *		------------------------------------------------------
     *		  0     All is OK
     *		  1	Let the calling routine worry about it.
     *		  2	Fatal... bomb as soon as all input is checked.
     */

    /* Open the file, if necessary */
    if (*FileName == '\0')
	fPtr = stdin;
    else if ((fPtr = fopen(FileName, "r")) == NULL)
    {
	(void) fprintf(stderr, "%s:  Cannot open input file '%s'\n",
	    ProgName, FileName);
	(void) exit (1);
    }

    /* Initialize the table */
    for (angle = 0; angle < 360; angle += Quantum)
	*(Table + npf_index(angle)) = -1.0;
    
    /* Fill the table */
    while ((fscanf(fPtr, "%lf", &theta) == 1) &&
	(fscanf(fPtr, "%lf", &rho) == 1))
    {
	theta *= convert;
	if ((theta < 0.0) || (npf_index(theta / Deg2Rad) * Quantum > 360))
	{
	    (void) fprintf(stderr,
		"Fatal:  Theta out of range: %g %s\n",
		theta / convert, (convert == 1.0) ? "radians" : "degrees");
	    Warnings = 2;
	}
	if ((rho < 0.0) || (rho > 1.0))
	{
	    (void) fprintf(stderr, "Fatal:  Rho out of range: %g\n", rho);
	    Warnings = 2;
	}
	if (Warnings != 2)
	    *(Table + npf_index(theta / Deg2Rad)) = rho;
    }

    if (Warnings == 2)
	(void) exit (1);

    /* Check the table for completeness */
    gap_min = gap_max = -1;
    for (angle = floor(arc_min); angle < ceil(arc_max); angle+=Quantum)
    {
	if (*(Table + npf_index(angle)) == -1.0)
	{
	    *(Table + npf_index(angle)) = 0.0;
	    if (gap_min == -1)
		gap_min = angle;
	    gap_max = angle;
	    Warnings = 1;
	}
	else
	{
	    if (gap_min > -1)
	    {
		(void) fprintf(stderr, "Warning:  No entry in input for ");
		if (gap_max > gap_min)
		    (void) fprintf(stderr, "%d <= theta <= %d degrees\n",
			    gap_min, gap_max);
		else
		    (void) fprintf(stderr, "theta == %d degrees\n", gap_min);
	    }
	    gap_min = gap_max = -1;
	}
    }

    if (gap_min > -1)
    {
	(void) fprintf(stderr, "Warning:  No entry in input for ");
	if (gap_max > gap_min)
	    (void) fprintf(stderr, "%d <= theta <= %d degrees\n",
		    gap_min, gap_max);
	else
	    (void) fprintf(stderr, "theta == %d degrees\n", gap_min);
    }
    
     if (fPtr != stdin)
 	(void) fclose(fPtr);
     return(Warnings);
}

int
OnGrid (double theta, double rho)
{
    int		t;
    double	squeeze;	/* factor to squeeze the radii */

    theta /= Deg2Rad;
    squeeze = 1.0 / rho * GRID_THETA_EPS;

    /* Determine whether the point is on a radius */
    for (t = 0; t < 360; t += 30)
    {
	if (fabs(theta - t) < squeeze)
	    return(1);
    }

    /* Determine whether the point is on a circle */
    if ((((1.0 - rho) > 0) && ((1.0 - rho) < GRID_RHO_EPS)) ||
	(((0.8 - rho) > 0) && ((0.8 - rho) < GRID_RHO_EPS)) ||
	(((0.6 - rho) > 0) && ((0.6 - rho) < GRID_RHO_EPS)) ||
	(((0.4 - rho) > 0) && ((0.4 - rho) < GRID_RHO_EPS)) ||
	(((0.2 - rho) > 0) && ((0.2 - rho) < GRID_RHO_EPS)))
	return(1);

    return (0);
}

void
ArgCompat (int Interior)
{
    if (Interior != BI_RINGS)
    {
        (void) fputs("Only one of -e, -i, -l, and -w may be specified\n",
		     stderr);
	(void) exit (1);
    }
}

void
Fill_Empty (unsigned char *fbbPtr, double rho, double npf_rho, int unit_r, int merge)

             	        	/* Pointer to within fbb */
      		    		/* Radius of current pixel */
      		        	/* Value of function at this theta */
   		       		/* Unit radius (in pixels) */
    		      		/* Overlay onto current FB contents? */

{
    if (! merge)
	COPYRGB(fbbPtr, Color[C_BKGRND])
}

void
Fill_Constant (unsigned char *fbbPtr, double rho, double npf_rho, int unit_r, int merge)

             	        	/* Pointer to within fbb */
      		    		/* Radius of current pixel */
      		        	/* Value of function at this theta */
   		       		/* Unit radius (in pixels) */
    		      		/* Overlay onto current FB contents? */

{
    COPYRGB(fbbPtr, Color[C_INTERIOR])
}

void
Fill_Ramp (unsigned char *fbbPtr, double rho, double npf_rho, int unit_r, int merge)

             	        	/* Pointer to within fbb */
      		    		/* Radius of current pixel */
      		        	/* Value of function at this theta */
   		       		/* Unit radius (in pixels) */
    		      		/* Overlay onto current FB contents? */

{
    RGBpixel	ThisPix;	/* Ramped color for current pixel */

    ThisPix[RED] = ((double)Color[C_RAMP][RED]) * rho / unit_r +
	255 * (1 - rho / unit_r);
    ThisPix[GRN] = ((double)Color[C_RAMP][GRN]) * rho / unit_r +
	255 * (1 - rho / unit_r);
    ThisPix[BLU] = ((double)Color[C_RAMP][BLU]) * rho / unit_r +
	255 * (1 - rho / unit_r);
    COPYRGB(fbbPtr, ThisPix)
}

void
Fill_Wedges (unsigned char *fbbPtr, double rho, double npf_rho, int unit_r, int merge)

             	        	/* Pointer to within fbb */
      		    		/* Radius of current pixel */
      		        	/* Value of function at this theta */
   		       		/* Unit radius (in pixels) */
    		      		/* Overlay onto current FB contents? */

{
    if (npf_rho > .8)
	COPYRGB(fbbPtr, Color[C_RED])
    else if (npf_rho > .6)
	COPYRGB(fbbPtr, Color[C_ORANGE])
    else if (npf_rho > .4)
	COPYRGB(fbbPtr, Color[C_YELLOW])
    else if (npf_rho > .2)
	COPYRGB(fbbPtr, Color[C_GREEN])
    else
	COPYRGB(fbbPtr, Color[C_BLUE])
}

void
Fill_Rings (unsigned char *fbbPtr, double rho, double npf_rho, int unit_r, int merge)

             	        	/* Pointer to within fbb */
      		    		/* Radius of current pixel */
      		        	/* Value of function at this theta */
   		       		/* Unit radius (in pixels) */
    		      		/* Overlay onto current FB contents? */

{
    if (rho / unit_r > .8)
	COPYRGB(fbbPtr, Color[C_RED])
    else if (rho / unit_r > .6)
	COPYRGB(fbbPtr, Color[C_ORANGE])
    else if (rho / unit_r > .4)
	COPYRGB(fbbPtr, Color[C_YELLOW])
    else if (rho / unit_r > .2)
	COPYRGB(fbbPtr, Color[C_GREEN])
    else
	COPYRGB(fbbPtr, Color[C_BLUE])
}
@


11.9
log
@change conf.h to a wrapped config.h
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/fb/polar-fb.c,v 11.8 2004/04/05 07:49:23 morrison Exp $ (BRL)";
@


11.8
log
@merge of ansi-6-0-branch into HEAD
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d21 5
a25 1
#include "conf.h"
@


11.7
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/polar-fb.c,v 11.5 2001/04/12 17:44:08 bparker Exp $ (BRL)";
d30 4
a33 4
void PrintUsage();
void ArgCompat();
int LoadNPF();
int OnGrid();
d123 1
a123 5
main (argc, argv)

int	argc;
char	*argv[];

d160 5
a164 5
    void		Fill_Empty();
    void		Fill_Constant();
    void		Fill_Ramp();
    void		Fill_Wedges();
    void		Fill_Rings();
d695 1
a695 4
PrintUsage (ShoOpts)

bool	ShoOpts;

d711 1
a711 1
LoadNPF (FileName, Table, Quantum, convert, arc_min, arc_max)
d713 6
a718 6
char	*FileName;	/* Name of input file */
double	*Table;		/* Location for storing function */
int	Quantum;	/* Angular resolution of Table (in degrees) */
double	convert;	/* Factor to convert input units to radians */
double	arc_min;	/* First angle of interest */
double	arc_max;	/* Last    "    "     "    */
d818 1
a818 5
OnGrid (theta, rho)

double	theta;
double	rho;

d845 1
a845 2
ArgCompat (Interior)

d856 1
a856 1
Fill_Empty (fbbPtr, rho, npf_rho, unit_r, merge)
d858 5
a862 5
unsigned char	*fbbPtr;	/* Pointer to within fbb */
double		rho;		/* Radius of current pixel */
double		npf_rho;	/* Value of function at this theta */
int		unit_r;		/* Unit radius (in pixels) */
bool		merge;		/* Overlay onto current FB contents? */
d870 1
a870 1
Fill_Constant (fbbPtr, rho, npf_rho, unit_r, merge)
d872 5
a876 5
unsigned char	*fbbPtr;	/* Pointer to within fbb */
double		rho;		/* Radius of current pixel */
double		npf_rho;	/* Value of function at this theta */
int		unit_r;		/* Unit radius (in pixels) */
bool		merge;		/* Overlay onto current FB contents? */
d883 1
a883 1
Fill_Ramp (fbbPtr, rho, npf_rho, unit_r, merge)
d885 5
a889 5
unsigned char	*fbbPtr;	/* Pointer to within fbb */
double		rho;		/* Radius of current pixel */
double		npf_rho;	/* Value of function at this theta */
int		unit_r;		/* Unit radius (in pixels) */
bool		merge;		/* Overlay onto current FB contents? */
d904 1
a904 1
Fill_Wedges (fbbPtr, rho, npf_rho, unit_r, merge)
d906 5
a910 5
unsigned char	*fbbPtr;	/* Pointer to within fbb */
double		rho;		/* Radius of current pixel */
double		npf_rho;	/* Value of function at this theta */
int		unit_r;		/* Unit radius (in pixels) */
bool		merge;		/* Overlay onto current FB contents? */
d926 1
a926 1
Fill_Rings (fbbPtr, rho, npf_rho, unit_r, merge)
d928 5
a932 5
unsigned char	*fbbPtr;	/* Pointer to within fbb */
double		rho;		/* Radius of current pixel */
double		npf_rho;	/* Value of function at this theta */
int		unit_r;		/* Unit radius (in pixels) */
bool		merge;		/* Overlay onto current FB contents? */
@


11.7.2.1
log
@Initial ANSIfication
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/polar-fb.c,v 11.7 2002/08/20 17:07:26 jra Exp $ (BRL)";
d30 4
a33 4
void PrintUsage(int ShoOpts);
void ArgCompat(int Interior);
int LoadNPF(char *FileName, double *Table, int Quantum, double convert, double arc_min, double arc_max);
int OnGrid(double theta, double rho);
d123 5
a127 1
main (int argc, char **argv)
d164 5
a168 5
    void		Fill_Empty(unsigned char *fbbPtr, double rho, double npf_rho, int unit_r, int merge);
    void		Fill_Constant(unsigned char *fbbPtr, double rho, double npf_rho, int unit_r, int merge);
    void		Fill_Ramp(unsigned char *fbbPtr, double rho, double npf_rho, int unit_r, int merge);
    void		Fill_Wedges(unsigned char *fbbPtr, double rho, double npf_rho, int unit_r, int merge);
    void		Fill_Rings(unsigned char *fbbPtr, double rho, double npf_rho, int unit_r, int merge);
d699 4
a702 1
PrintUsage (int ShoOpts)
d718 1
a718 1
LoadNPF (char *FileName, double *Table, int Quantum, double convert, double arc_min, double arc_max)
d720 6
a725 6
    	          	/* Name of input file */
      	       		/* Location for storing function */
   	        	/* Angular resolution of Table (in degrees) */
      	        	/* Factor to convert input units to radians */
      	        	/* First angle of interest */
      	        	/* Last    "    "     "    */
d825 5
a829 1
OnGrid (double theta, double rho)
d856 2
a857 1
ArgCompat (int Interior)
d868 1
a868 1
Fill_Empty (unsigned char *fbbPtr, double rho, double npf_rho, int unit_r, int merge)
d870 5
a874 5
             	        	/* Pointer to within fbb */
      		    		/* Radius of current pixel */
      		        	/* Value of function at this theta */
   		       		/* Unit radius (in pixels) */
    		      		/* Overlay onto current FB contents? */
d882 1
a882 1
Fill_Constant (unsigned char *fbbPtr, double rho, double npf_rho, int unit_r, int merge)
d884 5
a888 5
             	        	/* Pointer to within fbb */
      		    		/* Radius of current pixel */
      		        	/* Value of function at this theta */
   		       		/* Unit radius (in pixels) */
    		      		/* Overlay onto current FB contents? */
d895 1
a895 1
Fill_Ramp (unsigned char *fbbPtr, double rho, double npf_rho, int unit_r, int merge)
d897 5
a901 5
             	        	/* Pointer to within fbb */
      		    		/* Radius of current pixel */
      		        	/* Value of function at this theta */
   		       		/* Unit radius (in pixels) */
    		      		/* Overlay onto current FB contents? */
d916 1
a916 1
Fill_Wedges (unsigned char *fbbPtr, double rho, double npf_rho, int unit_r, int merge)
d918 5
a922 5
             	        	/* Pointer to within fbb */
      		    		/* Radius of current pixel */
      		        	/* Value of function at this theta */
   		       		/* Unit radius (in pixels) */
    		      		/* Overlay onto current FB contents? */
d938 1
a938 1
Fill_Rings (unsigned char *fbbPtr, double rho, double npf_rho, int unit_r, int merge)
d940 5
a944 5
             	        	/* Pointer to within fbb */
      		    		/* Radius of current pixel */
      		        	/* Value of function at this theta */
   		       		/* Unit radius (in pixels) */
    		      		/* Overlay onto current FB contents? */
@


11.6
log
@Converted from K&R to ANSI C - RFH
@
text
@d30 4
a33 4
void PrintUsage(int ShoOpts);
void ArgCompat(int Interior);
int LoadNPF(char *FileName, double *Table, int Quantum, double convert, double arc_min, double arc_max);
int OnGrid(double theta, double rho);
d123 5
a127 1
main (int argc, char **argv)
d164 5
a168 5
    void		Fill_Empty(unsigned char *fbbPtr, double rho, double npf_rho, int unit_r, int merge);
    void		Fill_Constant(unsigned char *fbbPtr, double rho, double npf_rho, int unit_r, int merge);
    void		Fill_Ramp(unsigned char *fbbPtr, double rho, double npf_rho, int unit_r, int merge);
    void		Fill_Wedges(unsigned char *fbbPtr, double rho, double npf_rho, int unit_r, int merge);
    void		Fill_Rings(unsigned char *fbbPtr, double rho, double npf_rho, int unit_r, int merge);
d699 4
a702 1
PrintUsage (int ShoOpts)
d718 1
a718 1
LoadNPF (char *FileName, double *Table, int Quantum, double convert, double arc_min, double arc_max)
d720 6
a725 6
    	          	/* Name of input file */
      	       		/* Location for storing function */
   	        	/* Angular resolution of Table (in degrees) */
      	        	/* Factor to convert input units to radians */
      	        	/* First angle of interest */
      	        	/* Last    "    "     "    */
d825 5
a829 1
OnGrid (double theta, double rho)
d856 2
a857 1
ArgCompat (int Interior)
d868 1
a868 1
Fill_Empty (unsigned char *fbbPtr, double rho, double npf_rho, int unit_r, int merge)
d870 5
a874 5
             	        	/* Pointer to within fbb */
      		    		/* Radius of current pixel */
      		        	/* Value of function at this theta */
   		       		/* Unit radius (in pixels) */
    		      		/* Overlay onto current FB contents? */
d882 1
a882 1
Fill_Constant (unsigned char *fbbPtr, double rho, double npf_rho, int unit_r, int merge)
d884 5
a888 5
             	        	/* Pointer to within fbb */
      		    		/* Radius of current pixel */
      		        	/* Value of function at this theta */
   		       		/* Unit radius (in pixels) */
    		      		/* Overlay onto current FB contents? */
d895 1
a895 1
Fill_Ramp (unsigned char *fbbPtr, double rho, double npf_rho, int unit_r, int merge)
d897 5
a901 5
             	        	/* Pointer to within fbb */
      		    		/* Radius of current pixel */
      		        	/* Value of function at this theta */
   		       		/* Unit radius (in pixels) */
    		      		/* Overlay onto current FB contents? */
d916 1
a916 1
Fill_Wedges (unsigned char *fbbPtr, double rho, double npf_rho, int unit_r, int merge)
d918 5
a922 5
             	        	/* Pointer to within fbb */
      		    		/* Radius of current pixel */
      		        	/* Value of function at this theta */
   		       		/* Unit radius (in pixels) */
    		      		/* Overlay onto current FB contents? */
d938 1
a938 1
Fill_Rings (unsigned char *fbbPtr, double rho, double npf_rho, int unit_r, int merge)
d940 5
a944 5
             	        	/* Pointer to within fbb */
      		    		/* Radius of current pixel */
      		        	/* Value of function at this theta */
   		       		/* Unit radius (in pixels) */
    		      		/* Overlay onto current FB contents? */
@


11.5
log
@*- get rid of warnings
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/polar-fb.c,v 11.4 2000/08/24 03:58:35 mike Exp $ (BRL)";
d30 4
a33 4
void PrintUsage();
void ArgCompat();
int LoadNPF();
int OnGrid();
d123 1
a123 5
main (argc, argv)

int	argc;
char	*argv[];

d160 5
a164 5
    void		Fill_Empty();
    void		Fill_Constant();
    void		Fill_Ramp();
    void		Fill_Wedges();
    void		Fill_Rings();
d695 1
a695 4
PrintUsage (ShoOpts)

bool	ShoOpts;

d711 1
a711 1
LoadNPF (FileName, Table, Quantum, convert, arc_min, arc_max)
d713 6
a718 6
char	*FileName;	/* Name of input file */
double	*Table;		/* Location for storing function */
int	Quantum;	/* Angular resolution of Table (in degrees) */
double	convert;	/* Factor to convert input units to radians */
double	arc_min;	/* First angle of interest */
double	arc_max;	/* Last    "    "     "    */
d818 1
a818 5
OnGrid (theta, rho)

double	theta;
double	rho;

d845 1
a845 2
ArgCompat (Interior)

d856 1
a856 1
Fill_Empty (fbbPtr, rho, npf_rho, unit_r, merge)
d858 5
a862 5
unsigned char	*fbbPtr;	/* Pointer to within fbb */
double		rho;		/* Radius of current pixel */
double		npf_rho;	/* Value of function at this theta */
int		unit_r;		/* Unit radius (in pixels) */
bool		merge;		/* Overlay onto current FB contents? */
d870 1
a870 1
Fill_Constant (fbbPtr, rho, npf_rho, unit_r, merge)
d872 5
a876 5
unsigned char	*fbbPtr;	/* Pointer to within fbb */
double		rho;		/* Radius of current pixel */
double		npf_rho;	/* Value of function at this theta */
int		unit_r;		/* Unit radius (in pixels) */
bool		merge;		/* Overlay onto current FB contents? */
d883 1
a883 1
Fill_Ramp (fbbPtr, rho, npf_rho, unit_r, merge)
d885 5
a889 5
unsigned char	*fbbPtr;	/* Pointer to within fbb */
double		rho;		/* Radius of current pixel */
double		npf_rho;	/* Value of function at this theta */
int		unit_r;		/* Unit radius (in pixels) */
bool		merge;		/* Overlay onto current FB contents? */
d904 1
a904 1
Fill_Wedges (fbbPtr, rho, npf_rho, unit_r, merge)
d906 5
a910 5
unsigned char	*fbbPtr;	/* Pointer to within fbb */
double		rho;		/* Radius of current pixel */
double		npf_rho;	/* Value of function at this theta */
int		unit_r;		/* Unit radius (in pixels) */
bool		merge;		/* Overlay onto current FB contents? */
d926 1
a926 1
Fill_Rings (fbbPtr, rho, npf_rho, unit_r, merge)
d928 5
a932 5
unsigned char	*fbbPtr;	/* Pointer to within fbb */
double		rho;		/* Radius of current pixel */
double		npf_rho;	/* Value of function at this theta */
int		unit_r;		/* Unit radius (in pixels) */
bool		merge;		/* Overlay onto current FB contents? */
@


11.4
log
@
const RCSid
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/polar-fb.c,v 11.3 1998/09/22 03:03:09 mike Exp $ (BRL)";
d32 2
d122 1
d333 2
a334 2
		    if ((argv[1][0] != 'l') && (argv[1][0] != 'r') ||
			(argv[1][1] != '\0'))
d695 1
d717 1
d824 1
@


11.3
log
@Made printf() args match.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/polar-fb.c,v 11.2 1996/07/16 22:05:28 jra Exp $ (BRL)";
@


11.2
log
@Minor Mods for IRIX 6.2
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/polar-fb.c,v 11.1 1995/01/04 10:09:44 mike Rel4_4 jra $ (BRL)";
d286 1
a286 1
		    if ((sscanf(argv[1], "%F", &arc_min) != 1) || (arc_min < 0))
d292 1
a292 1
		    if ((sscanf(argv[2], "%F", &arc_max) != 1) ||
d314 1
a314 1
		    if (sscanf(argv[1], "%F", &twist) != 1)
d386 1
a386 1
			    *Opt, argv[1]);
d394 1
a394 1
			    *Opt, argv[2]);
d402 1
a402 1
			    *Opt, argv[3]);
d421 1
a421 1
			    *Opt, argv[1]);
d429 1
a429 1
			    *Opt, argv[2]);
d437 1
a437 1
			    *Opt, argv[3]);
d754 2
a755 2
    while ((fscanf(fPtr, "%F", &theta) == 1) &&
	(fscanf(fPtr, "%F", &rho) == 1))
@


11.1
log
@Release_4.4
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/polar-fb.c,v 10.4 94/11/14 22:30:43 mike Exp $ (BRL)";
d30 3
d160 6
a165 6
    int		(*Fill_Func)();
    int		Fill_Empty();
    int		Fill_Constant();
    int		Fill_Ramp();
    int		Fill_Wedges();
    int		Fill_Rings();
d694 1
d849 1
d861 1
d875 1
d888 1
d909 1
d931 1
@


10.4
log
@Irix 6
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/polar-fb.c,v 10.3 94/08/23 18:49:20 gdurf Exp Locker: mike $ (BRL)";
@


10.3
log
@Added includes, factored ifdefs
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/polar-fb.c,v 10.2 1994/08/11 15:06:19 mike Exp gdurf $ (BRL)";
d27 1
a124 1
    bool	hi_res = FALSE;	/* High resolution? */
@


10.2
log
@Reduced use of RGBpixel
Now use (unsigned char *)
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/polar-fb.c,v 10.1 91/10/12 06:46:48 mike Rel4_0 Locker: mike $ (BRL)";
d21 2
d25 3
a27 1
#include <fb.h>
@


10.1
log
@Release_4.0
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/polar-fb.c,v 1.5 91/08/29 23:57:54 mike Exp $ (BRL)";
d150 2
a151 2
    RGBpixel	*fbb;		/* Buffer for current line of frame buffer */
    RGBpixel	*fbbPtr;	/* Pointer to within fbb */
d605 1
a605 1
    if ((fbb = (RGBpixel *) malloc(fb_width * sizeof(RGBpixel))) == NULL)
d618 1
a618 1
	for (x = 0, fbbPtr = fbb; x <  LineLength; x++, fbbPtr++)
d626 1
a626 1
		    COPYRGB(*fbbPtr, Color[C_BKGRND])
d651 1
a651 1
		    COPYRGB(*fbbPtr, Color[C_BKGRND])
d667 1
a667 1
		    COPYRGB(*fbbPtr, Color[C_BKGRND])
d674 1
a674 1
		    COPYRGB(*fbbPtr, Color[C_PERIM])
d678 1
a678 1
		COPYRGB(*fbbPtr, Color[C_BLACK])
d854 1
a854 1
RGBpixel	*fbbPtr;	/* Pointer to within fbb */
d862 1
a862 1
	COPYRGB(*fbbPtr, Color[C_BKGRND])
d867 1
a867 1
RGBpixel	*fbbPtr;	/* Pointer to within fbb */
d874 1
a874 1
    COPYRGB(*fbbPtr, Color[C_INTERIOR])
d879 1
a879 1
RGBpixel	*fbbPtr;	/* Pointer to within fbb */
d894 1
a894 1
    COPYRGB(*fbbPtr, ThisPix)
d899 1
a899 1
RGBpixel	*fbbPtr;	/* Pointer to within fbb */
d907 1
a907 1
	COPYRGB(*fbbPtr, Color[C_RED])
d909 1
a909 1
	COPYRGB(*fbbPtr, Color[C_ORANGE])
d911 1
a911 1
	COPYRGB(*fbbPtr, Color[C_YELLOW])
d913 1
a913 1
	COPYRGB(*fbbPtr, Color[C_GREEN])
d915 1
a915 1
	COPYRGB(*fbbPtr, Color[C_BLUE])
d920 1
a920 1
RGBpixel	*fbbPtr;	/* Pointer to within fbb */
d928 1
a928 1
	COPYRGB(*fbbPtr, Color[C_RED])
d930 1
a930 1
	COPYRGB(*fbbPtr, Color[C_ORANGE])
d932 1
a932 1
	COPYRGB(*fbbPtr, Color[C_YELLOW])
d934 1
a934 1
	COPYRGB(*fbbPtr, Color[C_GREEN])
d936 1
a936 1
	COPYRGB(*fbbPtr, Color[C_BLUE])
@


1.5
log
@Stardent ANSI c
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/polar-fb.c,v 1.4 91/07/02 03:38:41 mike Exp $ (BRL)";
@


1.4
log
@To shut up the Cray
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/polar-fb.c,v 1.3 91/01/29 16:15:49 pjt Exp $ (BRL)";
a601 1
	    Fill_Func = Fill_Constant;
d888 1
a888 1
    ThisPix[RED] = Color[C_RAMP][RED] * rho / unit_r +
d890 1
a890 1
    ThisPix[GRN] = Color[C_RAMP][GRN] * rho / unit_r +
d892 1
a892 1
    ThisPix[BLU] = Color[C_RAMP][BLU] * rho / unit_r +
@


1.3
log
@Fixed bug found by W. Winner (plotting clockwise!)
Also changed -f option to -F
and added -N, -S, and -W.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/polar-fb.c,v 1.2 91/01/23 20:50:43 mike Exp $ (BRL)";
d602 1
@


1.2
log
@Header change.
@
text
@d2 1
a2 1
 *			P O L A R - F B
d18 1
a18 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
a26 1
#define		Low_Size	 512
d31 1
d74 22
a95 19
    "-a u v    plots only the part of function between u and v (degrees)\n", 
    "-b r g b  sets background color (0 .. 255)\n", 
    "-c        clears FB to background color\n", 
    "-e        plots no function interior (useful with -p)\n", 
    "-f fbfile specifies frame-buffer file\n", 
    "-g        plots no polar grid\n", 
    "-h        high-resolution mode\n", 
    "-i r g b  plots function with constant interior color (0 .. 255)\n", 
    "-l r g b  plots function with a linear ramp (0 .. 255)\n", 
    "-m        merges plot with current contents of FB\n", 
    "-n        no-warning mode.  Aborts if any irregular input\n", 
    "-o x y    translates plot (FB coordinates)\n", 
    "-p r g b  plots function perimeter (0 .. 255)\n", 
    "-q q      sets angular quantum (degrees)\n", 
    "-r        input in radians (default is degrees)\n", 
    "-s s      scales plot (FB coordinates)\n", 
    "-t t      rotates function (degrees)\n", 
    "-w        plots function with angular wedges\n", 
    "-z side   plots only one half of function ('l' or 'r')\n",
d143 2
a144 1
    int		Size;		/* Length of an edge of the FB (in pixels) */
d150 1
a150 1
    RGBpixel	fbb[High_Size];	/* Buffer for current line of frame buffer */
d193 49
d474 1
a474 1
		case 'f':		/* Name of frame-buffer file */
d477 1
a477 1
			(void) fputs("Illegal -f option\n", stderr);
d495 1
a495 1
		    hi_res = TRUE;
d510 1
a510 1
		    PrintUsage(*Opt == '?');
d524 1
a524 1
	    PrintUsage(0);
d528 13
a543 1
    Size = hi_res ? High_Size : Low_Size;
d545 1
a545 1
	ctr_x = Size / 2;
d547 1
a547 1
	ctr_y = Size / 2;
d549 1
a549 1
	unit_r = Size / 2;
d554 2
a555 2
    if ((ctr_x + unit_r > Size) || (ctr_x < unit_r) ||
	(ctr_y + unit_r > Size) || (ctr_y < unit_r))
a560 10
    /* Fill npf_tbl from the input stream */
    if (LoadNPF (FileName, npf_tbl, Quantum, angle_cvt, arc_min, arc_max)
	&& NoWarnings)
	(void) exit(1);
    arc_min = (360.0 - arc_min) * Deg2Rad;
    arc_max = (360.0 - arc_max) * Deg2Rad;

    /* Prep the frame buffer */
    if ((fbPtr = fb_open(FB_Name, Size, Size)) == FBIO_NULL)
	(void) exit (1);
d605 6
d634 1
a634 1
		theta = atan2((double) X, (double) Y) + M_PI;
d637 1
a637 1
 	    if (Half && (Half * (M_PI - theta) < 0))
d641 1
a641 1
	    theta -= twist;
d648 1
a648 1
	    if ((theta > arc_min) || (theta < arc_max))
d696 2
d700 1
d702 1
a702 1
	(void) fputs("-? option for help\n", stderr);
@


1.1
log
@Initial revision
@
text
@d6 10
a15 8
 *	Written by:	Paul J. Tanenbaum <pjt@@brl>
 *			U.S. Army Ballistic Research Laboratory
 *
 *	Date:		17 February 1988
 *	Latest Mod:	20 July 1990
 *
 *	To compile:	cc source.c -lm /usr/brlcad/lib/libfb.a \
 *			-I/usr/include/brlcad
d17 3
@
