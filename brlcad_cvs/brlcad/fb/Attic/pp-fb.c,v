head	11.10;
access;
symbols
	ansi-20040405-merged:11.6.2.2
	postmerge-20040405-ansi:11.8
	premerge-20040404-ansi:11.7
	postmerge-autoconf:11.7
	autoconf-freeze:11.6.10.2
	premerge-autoconf:11.7
	ansi-20040316-freeze:11.6.2.1
	postmerge-20040315-windows:11.7
	premerge-20040315-windows:11.7
	windows-20040315-freeze:11.6.4.1
	autoconf-20031203:11.6
	autoconf-20031202:11.6
	autoconf-branch:11.6.0.10
	phong-branch:11.6.0.8
	photonmap-branch:11.6.0.6
	rel-6-1-DP:11.6
	windows-branch:11.6.0.4
	rel-6-0-2:11.4
	ansi-branch:11.6.0.2
	rel-6-0-1-branch:11.4.0.2
	hartley-6-0-post:11.5
	hartley-6-0-pre:11.4
	rel-6-0-1:11.4
	rel-6-0:11.4
	rel-5-4:11.2
	offsite-5-3-pre:11.3
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:5.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.10
date	2004.05.24.04.13.27;	author morrison;	state dead;
branches;
next	11.9;

11.9
date	2004.05.10.15.30.42;	author erikg;	state Exp;
branches;
next	11.8;

11.8
date	2004.04.05.07.49.23;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2004.02.02.17.39.01;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	2002.08.20.17.07.26;	author jra;	state Exp;
branches
	11.6.2.1
	11.6.4.1
	11.6.10.1;
next	11.5;

11.5
date	2002.08.15.20.54.39;	author hartley;	state Exp;
branches;
next	11.4;

11.4
date	2001.04.12.17.44.08;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	2000.08.24.03.58.35;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	98.09.22.03.04.57;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.09.46;	author mike;	state Rel4_4;
branches;
next	10.4;

10.4
date	94.11.14.22.31.57;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.08.23.18.49.22;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.08.04.20.40.24;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.46.49;	author mike;	state Rel4_0;
branches;
next	9.3;

9.3
date	91.06.23.04.08.50;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.12.07.01.23.52;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.11.33;	author mike;	state Rel3_5;
branches;
next	8.1;

8.1
date	88.10.05.00.44.22;	author mike;	state Rel3_0;
branches;
next	7.2;

7.2
date	88.05.16.00.07.06;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.09.28;	author mike;	state Rel;
branches;
next	6.2;

6.2
date	87.10.28.23.25.32;	author phil;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.08.12.53;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.43.49;	author mike;	state Rel;
branches;
next	4.5;

4.5
date	87.06.20.07.02.42;	author mike;	state Exp;
branches;
next	4.4;

4.4
date	87.06.20.04.32.30;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.03.11.17.45.08;	author phil;	state Exp;
branches;
next	4.2;

4.2
date	87.02.13.00.50.41;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.14.08;	author mike;	state Rel1;
branches;
next	1.10;

1.10
date	86.10.25.10.52.51;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	86.10.06.21.08.42;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	86.10.03.06.20.33;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	86.08.13.05.21.52;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	86.08.13.03.16.11;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	86.08.13.03.16.02;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.08.13.03.15.45;	author mike;	state Exp;
branches;
next	;

11.6.2.1
date	2002.09.19.18.00.43;	author morrison;	state Exp;
branches;
next	11.6.2.2;

11.6.2.2
date	2004.03.17.21.16.09;	author morrison;	state Exp;
branches;
next	;

11.6.4.1
date	2004.03.11.23.40.44;	author morrison;	state Exp;
branches;
next	;

11.6.10.1
date	2004.02.12.19.40.46;	author erikg;	state Exp;
branches;
next	11.6.10.2;

11.6.10.2
date	2004.03.15.13.28.06;	author erikg;	state Exp;
branches;
next	;


desc
@@


11.10
log
@moved to src/fb/
@
text
@/*
 *			P P - F B . C
 *
 *  plot color shaded pictures from GIFT on a frame buffer.
 *
 *  The plot file has a format similar to TEKTRONIX plots.
 *  All data is represented with printable ASCII characters.
 *  In the file layout, here are the character range uses:
 *  
 *  	000 - 037	NULL to US	unused
 *  	040 - 057	SPACE to /	command characters
 *  	060 - 077	0 to ?		(0-7) 3 high bits of inten_high
 *  	100 - 137	@@ to _		low 5 bits of inten or number.
 *  
 *  The following are command codes (encoded as code + 040 in the file):
 *	0 NUM	miss target (NUM=how many pixels)
 *  	1	switching to new surface (unused)
 *  	2	totally transparent surface (unused)
 *  	3 NUM	solid exterior item (NUM=item code)
 *  	4	transparent exterior, solid interior
 *  	6	point source of light (unused)
 *  	10 NUM	repeat intensity (NUM=how many pixels)
 *  	14	end of scanline
 *  	15	end of view
 *
 *  Also, note that input lines are limited to 75 characters in length.
 *
 *	Original Version:  Gary Kuehl,  April 1983
 *	Ported to VAX:  Mike Muuss, January 1984
 *	Conversion to generic frame buffer utility using libfb(3).
 *	Gary S. Moss, BRL. 03/14/85
 *	This version: Gary Kuehl, Feb 1987
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/fb/pp-fb.c,v 11.9 2004/05/10 15:30:42 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "fb.h"
#include "libtermio.h"

FBIO *fbp;

char ibuf[1024];	/* pp file buffer */

#define FBBUFSIZE 4096	/* Size of frame buffer DMA */
static unsigned char	pix_buf[FBBUFSIZE]; /* Pixel buffer.			*/

#define FBWPIXEL(pix) \
	{ COPYRGB( fb_p, pix ); \
	fb_p += sizeof(RGBpixel); \
	}
char strg[51];
char g(void),gc(void);
struct colors {
	char *name;
	RGBpixel c_pixel;
}colortab[] = {
	{"black",	{0,0,0}},
	{"blue",	{0,0,255}},
	{"brown",	{200,130,0}},
	{"cyan",	{0,255,200}},
	{"flesh",	{255,200,160}},
	{"gray",	{120,120,120}},
	{"green",	{0,255,0}},
	{"lime", 	{200,255,0}},
	{"magenta",	{255,0,255}},
	{"olive",	{220,190,0}},
	{"orange",	{255,100,0}},
	{"pink",	{255,200,200}},
	{"red",		{255,0,0}},
	{"rose",	{255,0,175}},
	{"rust",	{200,100,0}},
	{"silver",	{237,237,237}},
	{"sky",		{0,255,255}},
	{"violet",	{200,0,255}},
	{"white",	{255,255,255}},
	{"yellow",	{255,200,0}}
};
int ifd,io,grid_w,grid_h,min_w,min_h,max_w,max_h,ni,opq=0;
int ib=0,ic=0,nc=0,ibc=0,itc=3;
int itmc[500];
long itm[500],loci,locd,loct=0,loce,ctoi(void);

void	paint(void), prtclr(char raw), prtsmu(char raw);
int	lookup(long int ix, long int *jx, int n);

int
main(int argc, char **argv)
{
	int	c;
	char *cp;
	char cs[4];
	int i,j,k,lclr,iquit=0,ichg=0,gclr(void),cclr(char *pc);
	int il,iu,iclr,iskp,jclr,bsp(void);
	int scr_w=512,scr_h=512,scr_set=0;

	printf("GIFT-PRETTY File painted on Generic Framebuffer\n");
/* check invocation */
	if(argc<2){
		printf("Usage: pp-fb [options] PPfilename\n");
		printf("(See BRL-CAD Package Documentation for more info)\n");
		printf("Options:\n");
		printf("  -F framebuffer");
		printf(" (Alternatively set environment variable FB_FILE)\n");
		printf("  -W screen_width\n");
		printf("  -N screen_height\n");
		exit(10);
	}
	for(i=1;i<argc;i++){
		if(strcmp("-F",argv[i])==0){
#if 0
			argv[++i];
#else
			/*
			 * I don't know what the intent was above, so just
			 * increment i as before. This gets rid of compiler warnings.
			 */
			++i;
#endif
		} else if(strcmp("-W",argv[i])==0){
			sscanf(argv[++i],"%d",&scr_w);
			scr_set=1;
		} else if(strcmp("-N",argv[i])==0){
			sscanf(argv[++i],"%d",&scr_h);
			scr_set=1;
		} else if(strncmp("-",argv[i],1)==0){
			printf("Unknown option: %s\n",argv[i]);
			exit(10);
/* get plot file */
		} else {
			if((ifd=open(argv[i],2)) == -1){
				perror(argv[i]);
				exit(10);
			}
		}
	}
	save_Tty(0);
	printf("Program set: February 13, 1987\n");
	printf("Input 3 characters for colors\n");
	printf("Default colors:  Items       - silver\n");
	printf("                 Transparent - cyan\n");
	printf("                 Background  - black\n\n");

/* print data on first two lines of view in plot file */

view:	printf("Title: ");
	for(i=0;i<64;i++){
		c=gc();
		putchar(c);
	}
	printf("\nDate :");
	while((c=gc())!='\n') putchar(c);
	printf("\nView:");
	for(i=0;i<20;i++) putchar(gc());
	grid_w=ctoi();
	grid_h=ctoi();
	printf("\nHorz, Vert: %4d %4d\n",grid_w,grid_h);
	if((grid_w > 512 || grid_h > 512) && scr_set==0){
		if(grid_w>1024 || grid_h>1024){
			printf("Number of pixels gt 1024\n");
			exit(10);
		}
		scr_w=1024;
		scr_h=1024;
		printf("High resolution set\n");
	}
/*		open frame buffer */
	if((fbp=fb_open(NULL,scr_w,scr_h))==NULL){
		printf("No device opened\n");
		exit(10);
	}
	(void)fb_wmap(fbp,COLORMAP_NULL);	/* std map */

/* compute screen coordinates of min and max */
	min_w=(scr_w-grid_w)/2;
	min_h=(scr_h-grid_h)/2;
	max_w=min_w+grid_w;
	max_h=min_h+grid_h;
	locd=loct;
/*	printf("min_w %d min_h %d\n",min_w,min_h); */

/* find item - color table (default color = silver) */
	while((c=gc())!='/') if(c==0) exit(1);
	gc();
	loci=loct;
	for(ni=0;;ni++) {
		if(ni>=500){
			printf("Not enough room to store item colors\n");
			exit(10);
		}
		itm[ni]=ctoi();
		if(itm[ni]<0) break;
		for(i=0;i<3;i++) cs[i]=gc();
		if((itmc[ni]=cclr(cs))<0) itmc[ni]=15;
		while(gc()!='\n');
	}
	loce=loct;
	while(1){
		printf("Option (?=menu)? ");

		if( (c=getchar()) == EOF )  break;

		switch(c){
		case '\n':
			continue;

		case '?':
			printf("Options\n");
			printf(" a - Set all items of a color to another\n");
			printf(" b - Set background color\n");
			printf(" c - List available colors\n");
			printf(" l - List items & their colors\n");
			printf(" o - Opaque-transparent toggle\n");
			printf(" p - Paint picture\n");
			printf(" q - Quit\n");
			printf(" r - Set all items in a range to a color\n");
			printf(" s - Scroll target colors for changing\n");
			printf(" t - Set transparent color\n");
			printf(" v - New view\n");
			break;
		case 'a':
			printf("Old color? ");
			scanf("%3s",cs);
			iclr=cclr(cs);
			if(iclr<0){
				prtclr(0);
				break;
			}
			printf("New color? ");
			scanf("%3s",cs);
			jclr=cclr(cs);
			if(jclr<0){
				prtclr(0);
				break;
			}
			ichg=1;
			lseek(ifd,(off_t)loci,0);
			loct=loci;
			ic=0;
			for(i=0;i<ni;i++){
				for(j=0;j<10;j++) gc();
				for(k=0;(c=gc())!='\n';) strg[k++]=c;
				strg[k]='\0';
				if(itmc[i]!=iclr) continue;
				printf("%5ld %-7s  %s\n",itm[i],
					colortab[jclr].name,strg);
				itmc[i]=jclr;
			}
			break;
		case 'b':
			printf("%s background changed to ",colortab[ibc].name);
			scanf("%3s",cs);
			ibc=cclr(cs);
			if(ibc<0){
				ibc=0;
				prtclr(0);
			}
			break;
		case 't':
			printf("%s transparent color changed to ",
				colortab[itc].name);
			scanf("%3s",cs);
			itc=cclr(cs);
			if(itc<0){
				prtclr(0);
				itc=3;
			}
			break;
		case 'c':
			prtclr(0);
			break;
		case 'l':
			printf("Background color is %s\n",colortab[ibc].name);
			printf("Transparent color is %s\n\n",colortab[itc].name);
			lseek(ifd,(off_t)loci,0);
			loct=loci;
			ic=0;
			for(i=0;i<ni;i++){
				for(j=0;j<10;j++) gc();
				printf("%5ld %-7s  ",itm[i],
					colortab[itmc[i]].name);
				while((c=gc())!='\n') putchar(c);
				putchar('\n');
				if((i%20)==19){
					char cbuf[16];
					printf("(c)ontine,(s)top? ");
					scanf("%1s", cbuf);
					c = cbuf[0];
					if(c=='s') break;
				}
			}
			break;
		case 'o':
			opq= ++opq&1;
			if(opq){
				printf("Transparent items now opaque\n");
			} else{
				printf("Transparent items restored\n");
			}
			break;
		case 'p':
			paint();
			break;
		case 'q':
			iquit=1;
		case 'v':
			if(ichg!=0){
				for(i=0;i<ni;i++){
					loci+=6;
					lseek(ifd,(off_t)loci,0);
					ic=0;
					for(j=0,cp=colortab[itmc[i]].name;j<3;
							cp++,j++){
						loci++;
						write(ifd,cp,1);
					}
					lseek(ifd,(off_t)++loci,0);
					while((c=gc())!='\n') loci++;
					loci++;
				}
			ichg=0;
			}
			if(iquit!=0) exit(0);
			loct=loce;
			lseek(ifd,(off_t)loce,0);
			ic=0;
			fb_close(fbp);
			goto view;
		case 'r':
			printf("Lower limit? ");
			scanf("%d",&il);
			printf("Upper limit? ");
			scanf("%d",&iu);
			printf("Color? ");
			scanf("%3s",cs);
			iclr=cclr(cs);
			if(iclr<0){
				prtclr(0);
				break;
}
			ichg=1;
			lseek(ifd,(off_t)loci,0);
			loct=loci;
			ic=0;
			for(i=0;i<ni;i++){
				for(j=0;j<10;j++) gc();
				for(k=0;(c=gc())!='\n';) strg[k++]=c;
				strg[k]='\0';
				if(itm[i]<il || itm[i]>iu) continue;
				printf("%5ld %-7s  %s\n",itm[i],
					colortab[iclr].name,strg);
				itmc[i]=iclr;
			}
			break;
		case 's':
			prtsmu(0);
			ichg=1;
			lseek(ifd,(off_t)loci,0);
			loct=loci;
			ic=0;
			iskp=0;
			set_Raw(0);		/* set raw mode */
			lclr=15;
			for(i=0;i<ni;i++){
back:				for(j=0;j<10;j++) gc();
				for(k=0;(c=gc())!='\n';) strg[k++]=c;
				strg[k]='\0';
again:				printf("      %-7s  %s%c%5ld ",
					colortab[itmc[i]].name,strg,13,itm[i]);
				if(iskp>0){
					iskp--;
					printf("\015\n");
					continue;
				}
				if((k=gclr())>=0){
					itmc[i]=k;
/* ctrl b - backup one line */
				}else if(k==-2){
					printf("\015\n");
					if(bsp()==0) goto again;
					if(bsp()==0) goto again;
					i--;
					goto back;
/* ctrl c - stop */
				}else if(k==-3){
					printf("%c\n",13);
					break;
/* ctrl v - skip 20 lines */
				}else if(k==-22){
					iskp=20;
					continue;
/*space - same as last color */
				}else if(k==-32){
					itmc[i]=lclr;
/* ? - print menu and colors */
				}else if(k==-63){
					prtsmu(1);
					prtclr(1);
					goto again;
				}
				printf("%c%5ld %-7s%c\n",13,itm[i],
					colortab[itmc[i]].name,13);
				lclr=itmc[i];
			}
			reset_Tty(0);
			break;
		}
	}
	return(0);
}

void
paint(void)
/* Paint picture */
{
	char c;
	int i,j,iw,ih,iwih,trnf,flop;
	int	inten = 0;
	int	inten_high;
	long li,lj,numb(void);
	RGBpixel ocl,tcl,pmix,tp,bp;
	register unsigned char *fb_p;	/* Current position in buffer.	*/

	printf("Picture is being painted\n");
	bp[RED]=colortab[ibc].c_pixel[RED];
	bp[GRN]=colortab[ibc].c_pixel[GRN];
	bp[BLU]=colortab[ibc].c_pixel[BLU];
	tp[RED]=colortab[itc].c_pixel[RED];
	tp[GRN]=colortab[itc].c_pixel[GRN];
	tp[BLU]=colortab[itc].c_pixel[BLU];
	fb_clear(fbp,bp);
	lseek(ifd,(off_t)locd,0);
	loct=locd;
	ic=0;
	nc=0;
	trnf=0;
	inten_high=0;
	ih=max_h;
	iw=min_w;
	fb_p=pix_buf;	
	iwih=(iw+ih)&1;
	flop=1;
	while((c=g())!='/'){
		io=c-32;
noread:		if(io>31){
/*	ignore one of pair of intensities if trnf=4 */
			if(flop) iwih= ++iwih&1;
			inten=(io&31)+inten_high;
			if(trnf==4){
				flop= ++flop&1;
				if(opq&&flop) continue;
				if(opq==0&&flop!=iwih) continue;
			}
/*		compute intensity */
			iw++;
			if(trnf==0||(trnf==4&&iwih&&opq==0)){
				ocl[RED]= ((int)pmix[RED]*inten)>>8;
				ocl[GRN]= ((int)pmix[GRN]*inten)>>8;
				ocl[BLU]= ((int)pmix[BLU]*inten)>>8;
				FBWPIXEL(ocl);
			}else if(trnf==2&&iwih&&opq==0){
				FBWPIXEL(bp);
			}else{
				tcl[RED]= ((int)tp[RED]*inten)>>8;
				tcl[GRN]= ((int)tp[GRN]*inten)>>8;
				tcl[BLU]= ((int)tp[BLU]*inten)>>8;
				FBWPIXEL(tcl);
			}
/* high order intensity */
		}else if(io>15){
			inten_high=(io-16)<<5;
/* control character */
		}else switch(io){
/* miss target (<sp>)*/
		case 0:
			lj=numb();
			for(li=0;li<lj;li++,iw++) FBWPIXEL(bp);
			trnf=0;
			flop=1;
			iwih=(iw+ih)&1;
			goto noread;
/* new surface (!)*/
		case 1:
			break;
/* transparent (")*/
		case 2:
/* transparent outside - opaque inside ($)*/
		case 4:
			if(io==trnf){
				trnf=0;
			}else{
				flop=1;
				trnf=io;
			}
			break;
/* opaque item (#) */
		case 3:
			lj=numb();
			if((i=lookup(lj,itm,ni))<0){
				printf("Item %ld not in table\n",lj);
				j=15;
			} else {
				j=itmc[i];
			}
			pmix[RED]=colortab[j].c_pixel[RED];
			pmix[GRN]=colortab[j].c_pixel[GRN];
			pmix[BLU]=colortab[j].c_pixel[BLU];
			break;
/* shadow (&) */
		case 6:
			break;
/* repeat intensity (*) */
		case 10:
			lj=numb();
			if(trnf!=0){
				ocl[RED]= ((int)pmix[RED]*inten)>>8;
				ocl[GRN]= ((int)pmix[GRN]*inten)>>8;
				ocl[BLU]= ((int)pmix[BLU]*inten)>>8;
				tcl[RED]= ((int)tp[RED]*inten)>>8;
				tcl[GRN]= ((int)tp[GRN]*inten)>>8;
				tcl[BLU]= ((int)tp[BLU]*inten)>>8;
			}
			for(li=0;li<lj;li++,iw++){
				if(flop) iwih= ++iwih&1;
				if(trnf==4){
					flop= ++flop&1;
					if((opq&&flop)||(flop!=iwih&&opq==0)){
						iw--;
						continue;
					}
				}
				if(trnf==0||(trnf==4&&iwih&&opq==0)){
					FBWPIXEL(ocl);
				}else if(trnf==2&&iwih&&opq==0){
			   		FBWPIXEL(bp);
				}else {
					FBWPIXEL(tcl);
				}
			}
			if(io!=10) goto noread;
			break;
/* end of line (.)*/
		case 14:
			if(iw>min_w){
				fb_write(fbp,min_w,ih,pix_buf,(iw-min_w));
				iw=min_w;
				fb_p=pix_buf;
			}
			ih--;
			iwih=(iw+ih)&1;
			flop=1;
		}
	}
}
long numb(void)
/*
 *	get number from packed word */
{
	register long n;
	register int shift;
	n=0;
	shift=0;
	while((io=g()-32)>31){
		n+=((long)(io&31))<<shift;
		shift += 5;
	}
	return(n);
}
int cclr(char *pc)
         
/* compare input color to colors available */
{
	char *cp;
	int i;
	for(i=0;i<20;i++){
		cp=colortab[i].name;
		if(*cp== *pc&&*(cp+1)== *(pc+1)&&*(cp+2)==*(pc+2)) return(i);
		else if(*cp> *pc) return(-1);
	}
	return(-1);
}			
long ctoi(void)
/*		change char string to integer */
{
	long num,neg;
	char cc;
	num=0;
	neg=1;
	while((cc=gc())==' ');
	if(cc=='-'){
		neg= -1;
		cc=gc();
	}	
	while(cc>='0'&&cc<='9'){
		num=10*num+cc-'0';
		cc=gc();
	}
	return(num*neg);
}
char g(void)
/* get char from plot file - check for 75 columns and discard rest */
{
	static char c;
	if((c=gc())!='\n'){
		if((++nc)>75){
			while((c=gc())!='\n');
			nc=1;
			return(gc());
		}
		return(c);
	}else if(nc==75){
		nc=1;
		return(gc());
	}else{
		nc++;
		ib--;
		return(' ');
	}
}
int bsp(void)
/* back up a line in plot file buff */
{
	int kloct,kib;
	kloct=loct;
	kib=ib;
	while(ibuf[--ib]!='\n'){
		loct--;
		if(ib<=0){
			if(loct<=loci){
				loct=loci;
				ib=0;
				return(1);
			}
			ib=kib;
			loct=kloct;
			return(0);
		}
	}
	return(1);
}
char gc(void)
/* get char from plot file buff */
{
	loct++;
	if((++ib)>=ic){
		ic=read(ifd,ibuf,1024);
		ib=0;
		if(ic<=0) return(0);
	}
	if(ibuf[ib]=='>') ibuf[ib]='^';
	if(ibuf[ib]=='?') ibuf[ib]='@@';
/*	printf("GC: ibuf[ib],ib,ic %c %d %d \n",ibuf[ib],ib,ic);*/
/*	putchar(ibuf[ib]); */
	return(ibuf[ib]);
}
int gclr(void)
{
	char c,cs[3];
	int i;
	for(i=0;i<3;i++){
		while((c=getchar())<97||c>122){
			if(c==2) return(-2);
			if(c==3) return(-3);
			if(c==13) return(-13);
			if(c==22) return(-22);
			if(c==32) return(-32);
			if(c=='?') return(-63);
	}
	cs[i]=c;
	}
	return(cclr(cs));
}
int lookup(long int ix, long int *jx, int n)
{
	int i,ia,ib;
	ia= -1;
	ib=n;
	while(1){
		i=(ia+ib)/2;
/*printf("LOOKUP: ix,jx,ia,ib,i %d %d %d %d %d\n",ix,*(jx+i),ia,ib,i);*/
		if(ix== *(jx+i)) return(i);
		if(i<=ia) return(-1);
		if(ix> *(jx+i)) ia=i;
		else ib=i;
		}
}
void
prtclr(char raw)
{
	int i;
	printf("Available Colors\n");
	if(raw)	putchar('\015');
	for(i=0;i<20;i++){
		printf("%-8s",colortab[i].name);
		if((i%7)==6){
			if(raw) putchar('\015');
			putchar('\n');
		}
	}
	if(raw) putchar('\015');
	putchar('\n');
	return;
}
void
prtsmu(char raw)
{
	if(raw)	printf("\015\n");
	printf("Menu\n");
	if(raw)	putchar('\015');
	printf("   ?  = Color list + this Menu\n");
	if(raw)	putchar('\015');
	printf(" <^b> = Backup one line\n");
	if(raw)	putchar('\015');
	printf(" <^c> = Quit\n");
	if(raw)	putchar('\015');
	printf(" <^v> = Skip 20 lines\n");
	if(raw)	putchar('\015');
	printf(" <cr> = No change in color\n");
	if(raw)	putchar('\015');
	printf(" <sp> = Same color as previous item\n");
	if(raw)	putchar('\015');
	printf("  ccc = 3 character color code\n\n");
	if(raw)	putchar('\015');
	return;
}
@


11.9
log
@change conf.h to a wrapped config.h
@
text
@d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/fb/pp-fb.c,v 11.8 2004/04/05 07:49:23 morrison Exp $ (BRL)";
@


11.8
log
@merge of ansi-6-0-branch into HEAD
@
text
@d44 1
a44 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d47 5
a51 1
#include "conf.h"
@


11.7
log
@update copyright to include span through 2003
@
text
@d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/pp-fb.c,v 11.6 2002/08/20 17:07:26 jra Exp $ (BRL)";
d73 1
a73 1
char g(),gc();
d102 1
a102 1
long itm[500],loci,locd,loct=0,loce,ctoi();
d104 2
a105 2
void	paint(), prtclr(), prtsmu();
int	lookup();
d108 1
a108 3
main(argc,argv)
int argc;
char **argv;
d113 2
a114 2
	int i,j,k,lclr,iquit=0,ichg=0,gclr(),cclr();
	int il,iu,iclr,iskp,jclr,bsp();
d433 1
a433 1
paint()
d440 1
a440 1
	long li,lj,numb();
d575 1
a575 1
long numb()
d589 2
a590 2
int cclr(pc)
char *pc;
d602 1
a602 1
long ctoi()
d620 1
a620 1
char g()
d640 1
a640 1
int bsp()
d661 1
a661 1
char gc()
d676 1
a676 1
int gclr()
d693 1
a693 3
int lookup(ix,jx,n)
int n;
long ix,*jx;
d708 1
a708 2
prtclr(raw)
char raw;
d725 1
a725 2
prtsmu(raw)
char raw;
@


11.6
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d40 1
a40 1
 *	This software is Copyright (C) 1986 by the United States Army.
d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/pp-fb.c,v 11.4 2001/04/12 17:44:08 bparker Exp $ (BRL)";
@


11.6.4.1
log
@sync to HEAD...
@
text
@d40 1
a40 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/fb/pp-fb.c,v 11.7 2004/02/02 17:39:01 morrison Exp $ (BRL)";
@


11.6.10.1
log
@merge from HEAD
@
text
@d40 1
a40 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/pp-fb.c,v 11.7 2004/02/02 17:39:01 morrison Exp $ (BRL)";
@


11.6.10.2
log
@merge from head
@
text
@d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/pp-fb.c,v 11.6.10.1 2004/02/12 19:40:46 erikg Exp $ (BRL)";
@


11.6.2.1
log
@Initial ANSIfication
@
text
@d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/pp-fb.c,v 11.6 2002/08/20 17:07:26 jra Exp $ (BRL)";
d73 1
a73 1
char g(void),gc(void);
d102 1
a102 1
long itm[500],loci,locd,loct=0,loce,ctoi(void);
d104 2
a105 2
void	paint(void), prtclr(char raw), prtsmu(char raw);
int	lookup(long int ix, long int *jx, int n);
d108 3
a110 1
main(int argc, char **argv)
d115 2
a116 2
	int i,j,k,lclr,iquit=0,ichg=0,gclr(void),cclr(char *pc);
	int il,iu,iclr,iskp,jclr,bsp(void);
d435 1
a435 1
paint(void)
d442 1
a442 1
	long li,lj,numb(void);
d577 1
a577 1
long numb(void)
d591 2
a592 2
int cclr(char *pc)
         
d604 1
a604 1
long ctoi(void)
d622 1
a622 1
char g(void)
d642 1
a642 1
int bsp(void)
d663 1
a663 1
char gc(void)
d678 1
a678 1
int gclr(void)
d695 3
a697 1
int lookup(long int ix, long int *jx, int n)
d712 2
a713 1
prtclr(char raw)
d730 2
a731 1
prtsmu(char raw)
@


11.6.2.2
log
@sync branch with HEAD
@
text
@d40 1
a40 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d44 1
a44 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.5
log
@Converted from K&R to ANSI C - RFH
@
text
@d73 1
a73 1
char g(void),gc(void);
d102 1
a102 1
long itm[500],loci,locd,loct=0,loce,ctoi(void);
d104 2
a105 2
void	paint(void), prtclr(char raw), prtsmu(char raw);
int	lookup(long int ix, long int *jx, int n);
d108 3
a110 1
main(int argc, char **argv)
d115 2
a116 2
	int i,j,k,lclr,iquit=0,ichg=0,gclr(void),cclr(char *pc);
	int il,iu,iclr,iskp,jclr,bsp(void);
d435 1
a435 1
paint(void)
d442 1
a442 1
	long li,lj,numb(void);
d577 1
a577 1
long numb(void)
d591 2
a592 2
int cclr(char *pc)
         
d604 1
a604 1
long ctoi(void)
d622 1
a622 1
char g(void)
d642 1
a642 1
int bsp(void)
d663 1
a663 1
char gc(void)
d678 1
a678 1
int gclr(void)
d695 3
a697 1
int lookup(long int ix, long int *jx, int n)
d712 2
a713 1
prtclr(char raw)
d730 2
a731 1
prtsmu(char raw)
@


11.4
log
@*- get rid of warnings
@
text
@d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/pp-fb.c,v 11.3 2000/08/24 03:58:35 mike Exp $ (BRL)";
d73 1
a73 1
char g(),gc();
d102 1
a102 1
long itm[500],loci,locd,loct=0,loce,ctoi();
d104 2
a105 2
void	paint(), prtclr(), prtsmu();
int	lookup();
d108 1
a108 3
main(argc,argv)
int argc;
char **argv;
d113 2
a114 2
	int i,j,k,lclr,iquit=0,ichg=0,gclr(),cclr();
	int il,iu,iclr,iskp,jclr,bsp();
d433 1
a433 1
paint()
d440 1
a440 1
	long li,lj,numb();
d575 1
a575 1
long numb()
d589 2
a590 2
int cclr(pc)
char *pc;
d602 1
a602 1
long ctoi()
d620 1
a620 1
char g()
d640 1
a640 1
int bsp()
d661 1
a661 1
char gc()
d676 1
a676 1
int gclr()
d693 1
a693 3
int lookup(ix,jx,n)
int n;
long ix,*jx;
d708 1
a708 2
prtclr(raw)
char raw;
d725 1
a725 2
prtsmu(raw)
char raw;
@


11.3
log
@
const RCSid
@
text
@d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/pp-fb.c,v 11.2 1998/09/22 03:04:57 mike Exp $ (BRL)";
d59 1
d78 20
a97 20
	"black",	0,0,0,
	"blue",		0,0,255,
	"brown",	200,130,0,
	"cyan",		0,255,200,
	"flesh",	255,200,160,
	"gray",		120,120,120,
	"green",	0,255,0,
	"lime", 	200,255,0,
	"magenta",	255,0,255,
	"olive",	220,190,0,
	"orange",	255,100,0,
	"pink",		255,200,200,
	"red",		255,0,0,
	"rose",		255,0,175,
	"rust",		200,100,0,
	"silver",	237,237,237,
	"sky",		0,255,255,
	"violet",	200,0,255,
	"white",	255,255,255,
	"yellow",	255,200,0
d105 1
d107 1
d133 1
d135 7
d431 1
d433 1
@


11.2
log
@Fixed args to scanf("%1s",&c);
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/pp-fb.c,v 11.1 1995/01/04 10:09:46 mike Rel4_4 $ (BRL)";
@


11.1
log
@Release_4.4
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/pp-fb.c,v 10.4 94/11/14 22:31:57 mike Exp $ (BRL)";
d296 1
d298 2
a299 1
					scanf("%1s",&c);
@


10.4
log
@Irix 6
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/pp-fb.c,v 10.3 94/08/23 18:49:22 gdurf Exp Locker: mike $ (BRL)";
@


10.3
log
@Added includes, factored ifdefs
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/pp-fb.c,v 10.2 1994/08/04 20:40:24 gdurf Exp gdurf $ (BRL)";
d110 1
a110 1
	char *cp,*fbfile=NULL;
a127 1
	fbfile=NULL;
d130 1
a130 1
			fbfile=argv[++i];
d194 1
a194 1
	while((c=gc())!='/') if(c=0) exit(1);
@


10.2
log
@Added casts to off_t for calls to lseek()
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/pp-fb.c,v 10.1 91/10/12 06:46:49 mike Rel4_0 Locker: mike $ (BRL)";
d47 2
d50 6
a58 6
#ifdef BSD
#include <strings.h>
#endif
#ifdef SYSV
#include <string.h>
#endif
@


10.1
log
@Release_4.0
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/pp-fb.c,v 9.3 91/06/23 04:08:50 mike Exp $ (BRL)";
d48 2
d62 2
a63 2
#define FBBUFSIZE 1024	/* Size of frame buffer DMA */
static RGBpixel	pix_buf[FBBUFSIZE]; /* Pixel buffer.			*/
d66 2
a67 2
	{ COPYRGB( *fb_p, pix ); \
	++fb_p; \
d108 2
a109 1
	char *cp,*fbfile=NULL,*cmap=NULL,cs[4];
d182 1
a182 1
	fb_wmap(fbp,cmap);	/* std map */
d247 1
a247 1
			lseek(ifd,loci,0);
d285 1
a285 1
			lseek(ifd,loci,0);
d318 1
a318 1
					lseek(ifd,loci,0);
d325 1
a325 1
					lseek(ifd,++loci,0);
d331 1
a331 1
			if(iquit!=0) exit();
d333 1
a333 1
			lseek(ifd,loce,0);
d350 1
a350 1
			lseek(ifd,loci,0);
d366 1
a366 1
			lseek(ifd,loci,0);
d428 1
a428 1
	register RGBpixel *fb_p;	/* Current position in buffer.	*/
d438 1
a438 1
	lseek(ifd,locd,0);
@


9.3
log
@Eliminated SGI complaints about infinte looping
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pp-fb.c,v 9.2 90/12/07 01:23:52 mike Exp $ (BRL)";
@


9.2
log
@lint
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pp-fb.c,v 9.1 89/05/19 06:11:33 mike Rel3_5 $ (BRL)";
d105 2
a106 1
	char c,*cp,*fbfile=NULL,*cmap=NULL,cs[4];
d207 3
a209 1
		while((c=getchar())=='\n');
d211 2
@


9.1
log
@Release_3.5
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: pp-fb.c,v 8.1 88/10/05 00:44:22 mike Rel3_0 $ (BRL)";
d416 2
a417 1
	int inten,inten_high;
@


8.1
log
@Release_3.0
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: pp-fb.c,v 7.2 88/05/16 00:07:06 mike Exp $ (BRL)";
@


7.2
log
@lint fixes
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: pp-fb.c,v 7.1 87/11/03 00:09:28 mike Locked $ (BRL)";
@


7.1
log
@Release 2.3
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: pp-fb.c,v 6.2 87/10/28 23:25:32 phil Exp $ (BRL)";
d99 2
d410 1
d686 1
d704 2
a705 1
int prtsmu(raw)
@


6.2
log
@string(s).h ifdef
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: pp-fb.c,v 6.1 87/07/11 08:12:53 phil Locked $ (BRL)";
@


6.1
log
@Release 2.0
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: pp-fb.c,v 5.1 87/06/24 22:43:49 mike Rel $ (BRL)";
d49 4
d54 1
@


5.1
log
@Release 1.24
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: pp-fb.c,v 4.5 87/06/20 07:02:42 mike Exp $ (BRL)";
@


4.5
log
@Changed name of color[] table to colortab[], to prevent conflicts
with SGI library routine color(), sigh.
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: pp-fb.c,v 4.4 87/06/20 04:32:30 mike Locked $ (BRL)";
@


4.4
log
@Changed to use libtermio instead of stty/gtty
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: pp-fb.c,v 4.3 87/03/11 17:45:08 mike Locked $ (BRL)";
d67 1
a67 1
}color[] = {
d241 1
a241 1
					color[jclr].name,strg);
d246 1
a246 1
			printf("%s background changed to ",color[ibc].name);
d256 1
a256 1
				color[itc].name);
d268 2
a269 2
			printf("Background color is %s\n",color[ibc].name);
			printf("Transparent color is %s\n\n",color[itc].name);
d276 1
a276 1
					color[itmc[i]].name);
d305 1
a305 1
					for(j=0,cp=color[itmc[i]].name;j<3;
d344 1
a344 1
					color[iclr].name,strg);
d362 1
a362 1
					color[itmc[i]].name,strg,13,itm[i]);
d395 1
a395 1
					color[itmc[i]].name,13);
d414 6
a419 6
	bp[RED]=color[ibc].c_pixel[RED];
	bp[GRN]=color[ibc].c_pixel[GRN];
	bp[BLU]=color[ibc].c_pixel[BLU];
	tp[RED]=color[itc].c_pixel[RED];
	tp[GRN]=color[itc].c_pixel[GRN];
	tp[BLU]=color[itc].c_pixel[BLU];
d494 3
a496 3
			pmix[RED]=color[j].c_pixel[RED];
			pmix[GRN]=color[j].c_pixel[GRN];
			pmix[BLU]=color[j].c_pixel[BLU];
d565 1
a565 1
		cp=color[i].name;
d685 1
a685 1
		printf("%-8s",color[i].name);
@


4.3
log
@Bulk replaced with Gary Kuehl's latest and greatest.
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: pp-fb.c,v 4.2 87/02/13 00:50:41 phil Locked $ (BRL)";
a48 1
#include <sgtty.h>
a50 2
struct sgttyb ttyold, ttynew;

d136 1
a136 3
	gtty(0,&ttyold);
	ttynew=ttyold;
	ttynew.sg_flags |= RAW;
d355 1
a355 2
		/* set raw mode */
			stty(0,&ttynew);
d398 1
a398 1
			stty(0,&ttyold);
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d4 1
a4 1
 *	plot color shaded pictures from GIFT on a frame buffer.
d6 22
a29 1
 *
d32 1
d44 1
a44 1
static char RCSid[] = "@@(#)$Header: pp-fb.c,v 4.1 86/12/29 03:14:08 mike Rel1 $ (BRL)";
d49 2
d52 1
a52 1
extern void	perror(), exit();
d54 1
a54 1
#define ABS(i)	((i<0)?-(i):(i))
d56 3
a58 5
#ifndef pdp11
#define FBBUFSIZE (16*1024)	/* Size of frame buffer DMA */
#else
#define FBBUFSIZE (4*1024)	/* Size of frame buffer DMA */
#endif
d60 1
d63 1
a63 6
	if( ++fb_p >= end_p ) \
		{ \
		fb_write( fbp, 0, fb_y, pix_buf, FBBUFSIZE ); \
		fb_y -= scans_per_buffer; \
		fb_p = pix_buf; \
		} \
d65 6
a70 14
char g();
long numb();

static char linebuf[128];		/* For reading text lines into */

static int last_unpacked;		/* Global magic */
static FILE *input;			/* Input file handle */
FBIO *fbp;

#define NCOLORS	((sizeof(ctab))/(sizeof(struct colors)))
static struct colors {
	char *color;
	RGBpixel	c_pixel;
} ctab[] = {
a71 3
	"white",	255,255,255,
	"red",		255,0,0,
	"green",	0,255,0,
d73 1
d75 4
d80 1
a80 1
	"yellow",	255,200,0,
d82 2
a83 4
	"lime",		200,255,0,
	"olive",	220,190,0,
	"lt blue",	0,255,255,
	"violet",	200,0,255,
d85 1
a85 1
	"gray",		120,120,120,
d87 4
a90 4
	"brown",	200,130,0,
	"pink",		255,200,200,
	"flesh",	255,200,160,
	"rust",		200,100,0
d92 4
a95 18
static struct items {
	long	low;
	long	high;
	int	color;
} itemtab[50] = {
	0,	99,	18,
	100,	199,	10,
	200,	299,	4,
	300,	399,	6,
	400,	499,	8,
	500,	599,	16,
	600,	699,	15,
	700,	799,	2,
	800,	899,	13,
	900,	999,	12,
	1000,	99999,	3,
};
static int nitems = 11;		/* Number of items in table */
a96 4
#define REFLECTANCE .003936

int width = 512;

d100 5
a104 17
	{
	register int i;
	static int horiz_pos,vert_pos;
	static int newsurface;
	static int inten_high;		/* high bits of intentisy */
	static float rm[3];
	static RGBpixel icl;
	static int ibc;			/* background color index */
	static RGBpixel *backgroundp;	/* pointer to background pixel */
	static int maxh,maxv,mnh,mnv;
	static int vert_max;
	static long li,lj;
	register char c;
	register int	scans_per_buffer; /* Increment for 'fb_y'.	*/
	register int	fb_y;		/* Scanline to write to next.	*/
	register RGBpixel *fb_p;	/* Current position in buffer.	*/
	register RGBpixel *end_p;	/* End of buffer.	*/
d106 31
a136 7
	end_p = (RGBpixel *)&(pix_buf[FBBUFSIZE][RED]);

	/* check invocation */
	if( ! pars_Argv( argc, argv ) )
		{
		(void) fprintf( stderr, "Usage: pp-fb filename\n" );
		return	1;
a137 14

	/* print data on first two lines of plot file */
	(void) fgets(linebuf, sizeof(linebuf), input);
line1:
	if( (linebuf[0] == ' ' || (linebuf[0]>='A' && linebuf[0]<='Z')) )
		(void) fprintf( stderr,
				"\007WARNING:  This appears to be a .PC file.  If this does not work, use pc-fb\n\n");
	for( i=0; linebuf[i]!='\n'; )
		(void) putchar(linebuf[i++]);
	(void) putchar('\n');

	for(i=0;i<20;i++){
		c=getc(input);
		(void) putchar(c);
d139 8
a146 1
	(void) putchar('\n');
d148 1
a148 4
	(void) fscanf( input, "%d", &maxh );
	(void) fscanf( input, "%d", &maxv );
	if( maxh > 512 || maxv > 512 ) /* Automatic high res. mode.	*/
		width = 1024;
d150 4
a153 3
	if( (fbp = fb_open( NULL, width, width )) == NULL )  {
		fprintf(stderr,"fb_open failed\n");
		exit(12);
d155 22
a176 1
	(void) fb_wmap( fbp, COLORMAP_NULL );
d178 7
a184 1
	scans_per_buffer = FBBUFSIZE/fb_getwidth(fbp);
d186 14
a199 7
	(void) printf( "Number of Horz cells %4d, ",maxh);
	(void) printf( "Number of Vert cells %4d\n",maxv);

	(void) printf( "Code Color\n");
	for(i=0;i<NCOLORS;i++){
		(void) printf( "%3d - %-8s", i+1, ctab[i].color);
		if((i%5)==4) (void) putchar('\n');
d201 5
a205 4
	(void) printf( "Background color? ");
	(void) scanf("%d",&ibc);
	if( ibc <= 0 )  ibc = 1;
	if( ibc > NCOLORS )  ibc = NCOLORS;
d207 13
a219 13
	(void) printf( "Code  Item range     Color\n");
	for(i=0;i<nitems;i++)
		(void) printf( "%4d %6ld %6ld  %s \n",
			i+1,
			itemtab[i].low,
			itemtab[i].high,
			ctab[itemtab[i].color].color );
	while(1)  {
		auto int incode, incolor;

		(void) printf( "Code (end<=0)? ");
		(void) scanf("%d",&incode);
		if(incode<=0)
d221 76
a296 61
		if(incode>nitems)
			incode = ++nitems;
		(void) printf( "Lower limit? ");
		(void) scanf("%ld",&itemtab[incode-1].low);
		(void) printf( "Upper limit? ");
		(void) scanf("%ld",&itemtab[incode-1].high);
		(void) printf( "Color code? ");
		(void) scanf("%d", &incolor);
		itemtab[incode-1].color = incolor-1;
	}

	/* compute screen coordinates of min and max */
	/* cause image to be centered on screen */
	mnh=(512-maxh)/2;
	mnv=(512-maxv)/2;
	vert_max=mnv+maxv;

	/* Random initialization */
	newsurface = 0;
	inten_high = 0;
	horiz_pos = 0;
	fb_p = pix_buf;
	fb_y = 511;

	/* paint background on upper part of screen */
	backgroundp= (RGBpixel *)&(ctab[ibc-1].c_pixel[RED]);
	for(vert_pos=512; vert_pos > vert_max; vert_pos--)
		for(i=0;i<512;i++)
			FBWPIXEL(*backgroundp);

	/* paint background on left side of screen */
	for(horiz_pos=0;horiz_pos<mnh;horiz_pos++)
		FBWPIXEL(*backgroundp); 

	while((c=g())!='/')  {
		last_unpacked=c-32;
noread:		
		if(last_unpacked>31){
			/* compute intensity */
			static float ftemp;
			static float spi=0.;		/* Saved "pi" */
			register float pi;

			pi=REFLECTANCE * ( (last_unpacked&0x1F) + inten_high );
			icl[RED] = pi*rm[0];
			icl[GRN] = pi*rm[1];
			icl[BLU] = pi*rm[2];
			ftemp=ABS(spi-pi);
			spi=pi;
			if(newsurface==0||ftemp>.1)  {
				FBWPIXEL( icl );
			}  else {
				/* fill scan between surfaces of same intensity */
				static RGBpixel pixel;

				if(pi<.15) pi+=.15;
				if(pi>=.15) pi-=.15;
				pixel[RED] = pi*rm[0];
				pixel[GRN] = pi*rm[1];
				pixel[BLU] = pi*rm[2];
				FBWPIXEL( pixel );
d298 108
a405 2
			newsurface=0;
			horiz_pos++;
d407 11
d419 51
a469 6
		/* high order intensity */
		else if(last_unpacked>15) inten_high=(last_unpacked-16)<<5;

		/* control character */
		else switch(last_unpacked){

a470 1
			/* miss target */
d472 4
a475 4
			for(li=0; li<lj; li++,horiz_pos++)  {
				FBWPIXEL(*backgroundp);
			}
			newsurface=0;
d477 1
a477 1

a478 2
			/* new surface */
			newsurface=1;
d480 12
a491 1

a492 1
			/* new item */
d494 14
a507 9
			/* Locate item in itemtab */
			for(i=0;i<(nitems-1);i++)
				if( lj >= itemtab[i].low && lj <= itemtab[i].high )
					break;
			rm[0]=ctab[itemtab[i].color].c_pixel[RED];
			rm[1]=ctab[itemtab[i].color].c_pixel[GRN];
			rm[2]=ctab[itemtab[i].color].c_pixel[BLU];
			goto noread;

a508 1
			/* repeat intensity */
d510 26
a535 2
			for(li=0;li<lj;li++,horiz_pos++) FBWPIXEL( icl );
			if(last_unpacked!=10) goto noread;
d537 1
a537 1

d539 8
a546 6
			/* end of line -- fill edges with background */
			while((horiz_pos++)<512)
				FBWPIXEL(*backgroundp); 
			vert_pos--;
			for(horiz_pos=0;horiz_pos<mnh;horiz_pos++)
				FBWPIXEL(*backgroundp);
a548 26

	/* end of view */
	while((horiz_pos++)<512)
		FBWPIXEL(*backgroundp);
	vert_pos--;
	while((vert_pos--)>0)
		for(i=0;i<512;i++)
			FBWPIXEL(*backgroundp);

	/* Gobble up file until we see an alphabetic in col 1 */
	while(1)  {
		if( fgets(linebuf, sizeof(linebuf), input) == NULL )
			{
			return	0;		/* EOF */
			}
		c = linebuf[0];
		if( (c>='a' && c <='z') || (c>='A' && c<='Z') )
			break;
	}
	(void) printf( "\n\n----------------------------------\n");
	if( fb_close( fbp ) == -1 )
		{
		(void) fprintf( stderr, "Can't close framebuffer!\n" );
		return	1;
		}
	goto line1;
d550 1
a550 1

d552 1
a552 3
 *	get number from packed word
 */
long numb()
a555 1

d558 2
a559 2
	while( (last_unpacked=g()-32) > 31 )  {
		n += ((long)last_unpacked&31) << shift;
d564 32
a595 2


a596 1
char g()
d598 4
a601 11
	static int nc=0;
	register char c;

	if( feof(input) )  {
		(void) fprintf( stderr, "pp-fb: unexpected EOF on data file\n");
		exit(1);
	}
	if((c=getc(input))!='\n'){
		nc++;
		if( nc > 75 )  {
			while((c=getc(input))!='\n');
d603 1
a603 1
			return(getc(input));
d606 1
a606 3
	}
	/* Char was newline */
	if(nc==75){
d608 5
a612 1
		return(getc(input));
a613 4
	/* Pad with spaces to end of "card" */
	nc++;
	(void) ungetc( c, input );
	return(' ');
d615 13
a627 16

/*	p a r s _ A r g v ( )
 */
int
pars_Argv( argc, argv )
register char	**argv;
	{
	register int	c;
	extern int	optind;

	while( (c = getopt( argc, argv, "" )) != EOF )
		{
		switch( c )
			{
			case '?' :
				return	0;
d629 3
d633 49
a681 5
	/* get plot file */
	if( argv[optind] == NULL )
		{
		(void) fprintf( stderr, "Need to specify PP file!\n" );
		return	0;
d683 12
a694 4
	if( (input = fopen( argv[optind], "r")) == NULL )
		{
		perror( argv[optind] );
		return	0;
a695 1
	return	1;
d697 26
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: pp-fb.c,v 1.10 86/10/25 10:52:51 mike Exp $ (BRL)";
@


1.10
log
@Converted to RGBpixel
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: pp-fb.c,v 1.9 86/10/06 21:08:42 phil Locked $ (BRL)";
@


1.9
log
@Converted to new libfb with 1st Quadrant semantics
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: pp-fb.c,v 1.8 86/10/03 06:20:33 mike Exp $ (BRL)";
d37 1
a37 1
static Pixel	pix_buf[FBBUFSIZE]; /* Pixel buffer.			*/
d39 2
a40 3
	{ \
	*fb_p++ = *pix; \
	if( fb_p >= end_p ) \
d59 1
a59 1
	Pixel	c_pixel;
d61 20
a80 20
	"black",	0,0,0,0,
	"white",	255,255,255,0,
	"red",		255,0,0,0,
	"green",	0,255,0,0,
	"blue",		0,0,255,0,
	"cyan",		0,255,200,0,
	"magenta",	255,0,255,0,
	"yellow",	255,200,0,0,
	"orange",	255,100,0,0,
	"lime",		200,255,0,0,
	"olive",	220,190,0,0,
	"lt blue",	0,255,255,0,
	"violet",	200,0,255,0,
	"rose",		255,0,175,0,
	"gray",		120,120,120,0,
	"silver",	237,237,237,0,
	"brown",	200,130,0,0,
	"pink",		255,200,200,0,
	"flesh",	255,200,160,0,
	"rust",		200,100,0,0
d114 1
a114 1
	static Pixel icl;
d116 1
a116 1
	static Pixel *backgroundp;	/* pointer to background pixel */
d122 3
a124 3
	register int	fb_y;	    /* Scanline to write to next.	*/
	register Pixel	*fb_p;	    /* Current position in buffer.	*/
	register Pixel	*end_p = &pix_buf[FBBUFSIZE]; /* End of buffer.	*/
d126 2
d216 1
a216 1
	backgroundp= &ctab[ibc-1].c_pixel;
d219 1
a219 1
			FBWPIXEL(backgroundp);
d223 1
a223 1
		FBWPIXEL(backgroundp); 
d235 3
a237 3
			icl.red = pi*rm[0];
			icl.green = pi*rm[1];
			icl.blue = pi*rm[2];
d241 1
a241 1
				FBWPIXEL( &icl );
d244 1
a244 1
				static Pixel pixel;
d248 4
a251 4
				pixel.red = pi*rm[0];
				pixel.green = pi*rm[1];
				pixel.blue = pi*rm[2];
				FBWPIXEL( &pixel );
d267 1
a267 1
				FBWPIXEL(backgroundp);
d284 3
a286 3
			rm[0]=ctab[itemtab[i].color].c_pixel.red;
			rm[1]=ctab[itemtab[i].color].c_pixel.green;
			rm[2]=ctab[itemtab[i].color].c_pixel.blue;
d292 1
a292 1
			for(li=0;li<lj;li++,horiz_pos++) FBWPIXEL( &icl );
d299 1
a299 1
				FBWPIXEL(backgroundp); 
d302 1
a302 1
				FBWPIXEL(backgroundp);
d308 1
a308 1
		FBWPIXEL(backgroundp);
d312 1
a312 1
			FBWPIXEL(backgroundp);
@


1.8
log
@Converted to new libfb
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d44 1
a44 1
		fb_y += scans_per_buffer; \
d212 1
a212 1
	fb_y = 0;
@


1.7
log
@Updated #includes for new conventions
@
text
@d2 18
a19 21
	SCCS id:	@@(#) pp-fb.c	1.6
	Last edit: 	3/28/85 at 16:38:52	G S M
	Retrieved: 	8/13/86 at 03:16:08
	SCCS archive:	/m/cad/fb_utils/RCS/s.pp-fb.c

*/
#if ! defined( lint )
static
char	sccsTag[] = "@@(#) pp-fb.c	1.6	last edit 3/28/85 at 16:38:52";
#endif
/*
			P P - F B . C

	plot color shaded pictures from GIFT on a frame buffer.

	Original Version:  Gary Kuehl,  April 1983
	Ported to VAX:  Mike Muuss, January 1984

	Conversion to generic frame buffer utility using libfb(3).
	In the process, the name has been changed to pp-fb from pp-ik.
	Gary S. Moss, BRL. 03/14/85
d22 1
a22 1
static char RCSid[] = "@@(#)$Header: pp-fb.c,v 1.6 86/08/13 03:16:11 mike Exp $ (BRL)";
d43 1
a43 1
		fbwrite( 0, fb_y, pix_buf, FBBUFSIZE ); \
d55 1
d104 2
d153 1
a153 8
		fbsetsize( 1024 );
	if(	fbopen( NULL, APPEND ) == -1
	    ||	fb_wmap( (ColorMap *) NULL ) == -1
		)
		{
		return	1;
		}
	scans_per_buffer = FBBUFSIZE/fbgetsize();
d155 8
d324 1
a324 1
	if( fbclose( _fbfd ) == -1 )
@


1.6
log
@Made hires mode automatic.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: pp-ik.c,v 1.3 84/03/16 10:28:11 mike Exp $ (BRL)";
d29 2
a30 1
#include <fb.h>
d153 1
a153 1
		setfbsize( 1024 );
d160 1
a160 1
	scans_per_buffer = FBBUFSIZE/getfbsize();
@


1.5
log
@All utilities seem to work with the Ikonas, will test with 
UNIX files next.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) pp-fb.c	1.5
	Last edit: 	3/14/85 at 17:57:51	G S M
	Retrieved: 	8/13/86 at 03:15:58
d10 1
a10 1
char	sccsTag[] = "@@(#) pp-fb.c	1.5	last edit 3/14/85 at 17:57:51";
d129 1
a129 1
		(void) fprintf( stderr, "Usage: pp-fb [-h] filename\n" );
a132 8
	if(	fbopen( NULL, APPEND ) == -1
	    ||	fb_wmap( (ColorMap *) NULL ) == -1
		)
		{
		return	1;
		}
	scans_per_buffer = FBBUFSIZE/getfbsize();

d137 2
a138 1
		(void) fprintf( stderr, "\007WARNING:  This appears to be a .PC file.  If this does not work, use pc-fb\n\n");
d151 10
d322 5
d387 1
a387 1
	while( (c = getopt( argc, argv, "h" )) != EOF )
a390 3
			case 'h' : /* High resolution frame buffer.	*/
				setfbsize( 1024 );
				break;
@


1.1
log
@Initial revision
@
text
@d2 21
a22 6
 *			P P - I K . C
 *
 *	plot color shaded pictures from GIFT on Ikonas.
 *
 *	Original Version:  Gary Kuehl,  April 1983
 *	Ported to VAX:  Mike Muuss, January 1984
d28 3
a30 1
#include <stdio.h>;
d34 2
a35 2
#ifdef vax
#define IKBUFSIZE (64*1024)	/* Size of Ikonas DMA buffer */
d37 1
a37 1
#define IKBUFSIZE 16384		/* Size of Ikonas DMA buffer */
d39 11
a49 12
char ikbuf[IKBUFSIZE];
static char *Ikp = &ikbuf[0];

#define WPIXEL(x)	{register int *ip=x; \
	*Ikp++ = *ip++;/*R*/	*Ikp++ = *ip++;/*G*/	*Ikp++ = *ip;/*B*/ \
	Ikp++; \
	if( Ikp >= &ikbuf[IKBUFSIZE] )  { \
		write( ikfd, ikbuf, Ikp-ikbuf); \
		Ikp = &ikbuf[0]; \
	} \
}

d53 1
a53 1
char linebuf[128];		/* For reading text lines into */
d55 2
a56 2
extern ikfd;			/* Ikonas file descriptor (iklib.o) */
extern ikhires;			/* Ikonas mode;  non-zero = HIRES */
a57 3
int last_unpacked;				/* Global magic */
FILE *input;			/* Input file handle */

d59 1
a59 1
struct colors {
d61 1
a61 1
	int  pixel[3];
d63 20
a82 20
	"black",	0,0,0,
	"white",	255,255,255,
	"red",		255,0,0,
	"green",	0,255,0,
	"blue",		0,0,255,
	"cyan",		0,255,200,
	"magenta",	255,0,255,
	"yellow",	255,200,0,
	"orange",	255,100,0,
	"lime",		200,255,0,
	"olive",	220,190,0,
	"lt blue",	0,255,255,
	"violet",	200,0,255,
	"rose",		255,0,175,
	"gray",		120,120,120,
	"silver",	237,237,237,
	"brown",	200,130,0,
	"pink",		255,200,200,
	"flesh",	255,200,160,
	"rust",		200,100,0
d84 1
a84 1
struct items {
d101 1
a101 1
int nitems = 11;		/* Number of items in table */
d108 1
a108 1
{
d114 1
a114 1
	static int icl[3];
d116 1
a116 1
	static int *backgroundp;	/* pointer to background pixel */
d118 1
a118 1
	static int horiz_max,vert_max;
d121 4
d127 5
a131 4
	if(argc!=2){
		printf("Usage: pp-ik filename\n");
		exit(10);
	}
d133 7
a139 5
	/* get plot file */
	if( (input = fopen(argv[1], "r")) == NULL )  {
		perror(argv[1]);
		exit(10);
	}
a140 4
	ikhires = 0;		/* for now */
	ikopen();
	load_map(1,0,0,0);	/* std map */

d142 1
a142 1
	fgets(linebuf, sizeof(linebuf), input);
d145 1
a145 1
		printf("\007WARNING:  This appears to be a .PC file.  If this does not work, use pc-ik\n\n");
d147 2
a148 2
		putchar(linebuf[i++]);
	putchar('\n');
d152 1
a152 1
		putchar(c);
d154 1
a154 1
	putchar('\n');
d156 4
a159 4
	fscanf( input, "%d", &maxh );
	fscanf( input, "%d", &maxv );
	printf("Number of Horz cells %4d, ",maxh);
	printf("Number of Vert cells %4d\n",maxv);
d161 1
a161 1
	printf("Code Color\n");
d163 2
a164 2
		printf("%3d - %-8s", i+1, ctab[i].color);
		if((i%5)==4) putchar('\n');
d166 2
a167 2
	printf("Background color? ");
	scanf("%d",&ibc);
d171 1
a171 1
	printf("Code  Item range     Color\n");
d173 1
a173 1
		printf("%4d %6ld %6ld  %s \n",
d181 2
a182 2
		printf("Code (end<=0)? ");
		scanf("%d",&incode);
d187 6
a192 6
		printf("Lower limit? ");
		scanf("%ld",&itemtab[incode-1].low);
		printf("Upper limit? ");
		scanf("%ld",&itemtab[incode-1].high);
		printf("Color code? ");
		scanf("%d", &incolor);
a199 1
	horiz_max=mnh+maxh;
d206 2
a207 1
	lseek( ikfd, 0L, 0);		/* To start of frame */
d210 1
a210 1
	backgroundp= ctab[ibc-1].pixel;
d213 1
a213 1
			WPIXEL(backgroundp);
d217 1
a217 1
		WPIXEL(backgroundp); 
d229 3
a231 3
			icl[0]=pi*rm[0];
			icl[1]=pi*rm[1];
			icl[2]=pi*rm[2];
d235 1
a235 1
				WPIXEL(icl);
d238 1
a238 1
				static int pixel[3];
d242 4
a245 4
				pixel[0]=pi*rm[0];
				pixel[1]=pi*rm[1];
				pixel[2]=pi*rm[2];
				WPIXEL(pixel);
d261 1
a261 1
				WPIXEL(backgroundp);
d278 3
a280 3
			rm[0]=ctab[itemtab[i].color].pixel[0];
			rm[1]=ctab[itemtab[i].color].pixel[1];
			rm[2]=ctab[itemtab[i].color].pixel[2];
d286 1
a286 1
			for(li=0;li<lj;li++,horiz_pos++) WPIXEL(icl);
d293 1
a293 1
				WPIXEL(backgroundp); 
d296 1
a296 1
				WPIXEL(backgroundp);
d302 1
a302 1
		WPIXEL(backgroundp);
d306 1
a306 1
			WPIXEL(backgroundp);
d311 3
a313 1
			exit(0);		/* EOF */
d318 1
a318 2
	printf("\n\n----------------------------------\n");
	lseek( ikfd, 0L, 0);		/* Back to start of frame */
d347 1
a347 1
		printf("pp-ik: unexpected EOF on data file\n");
d366 1
a366 1
	ungetc( c, input );
d369 34
@
