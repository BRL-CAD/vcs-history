head	11.8;
access;
symbols
	ansi-20040405-merged:11.5.2.1
	postmerge-20040405-ansi:11.6
	premerge-20040404-ansi:11.5
	postmerge-autoconf:11.5
	autoconf-freeze:11.5
	premerge-autoconf:11.5
	ansi-20040316-freeze:11.5.2.1
	postmerge-20040315-windows:11.5
	premerge-20040315-windows:11.5
	windows-20040315-freeze:11.5
	autoconf-20031203:11.5
	autoconf-20031202:11.5
	autoconf-branch:11.5.0.10
	phong-branch:11.5.0.8
	photonmap-branch:11.5.0.6
	rel-6-1-DP:11.5
	windows-branch:11.5.0.4
	rel-6-0-2:11.3
	ansi-branch:11.5.0.2
	rel-6-0-1-branch:11.3.0.2
	hartley-6-0-post:11.4
	hartley-6-0-pre:11.3
	rel-6-0-1:11.3
	rel-6-0:11.3
	rel-5-4:11.1
	offsite-5-3-pre:11.1
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1;
locks; strict;
comment	@ * @;


11.8
date	2004.05.24.04.13.26;	author morrison;	state dead;
branches;
next	11.7;

11.7
date	2004.05.10.15.30.42;	author erikg;	state Exp;
branches;
next	11.6;

11.6
date	2004.04.05.07.49.23;	author morrison;	state Exp;
branches;
next	11.5;

11.5
date	2002.08.20.17.07.24;	author jra;	state Exp;
branches
	11.5.2.1;
next	11.4;

11.4
date	2002.08.15.20.54.37;	author hartley;	state Exp;
branches;
next	11.3;

11.3
date	2001.08.10.21.27.04;	author butler;	state Exp;
branches;
next	11.2;

11.2
date	2001.04.12.17.44.07;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.09.18;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.23.18.49.04;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.46.23;	author mike;	state Rel4_0;
branches;
next	9.2;

9.2
date	91.08.29.23.22.40;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.08.48;	author mike;	state Rel3_5;
branches;
next	1.8;

1.8
date	89.05.08.17.50.52;	author phil;	state Exp;
branches;
next	1.7;

1.7
date	89.05.08.17.18.00;	author gwyn;	state Exp;
branches;
next	1.6;

1.6
date	89.05.08.16.58.25;	author phil;	state Exp;
branches;
next	1.5;

1.5
date	89.05.04.03.09.45;	author gwyn;	state Exp;
branches;
next	1.4;

1.4
date	89.05.04.03.04.49;	author gwyn;	state Exp;
branches;
next	1.3;

1.3
date	89.04.29.10.54.09;	author gwyn;	state Exp;
branches;
next	1.2;

1.2
date	89.04.26.20.08.57;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	89.04.26.19.21.26;	author mike;	state Exp;
branches;
next	;

11.5.2.1
date	2002.09.19.18.00.41;	author morrison;	state Exp;
branches;
next	;


desc
@Program to do random-pixel fade between two images
@


11.8
log
@moved to src/fb/
@
text
@/*
	fbfade -- "twinkle" fade in or out a frame buffer image

	created:	89/04/29	D A Gwyn with help from G S Moss

	Typical compilation:	cc -O -I/usr/include/brlcad -o fbfade \
					fbfade.c /usr/brlcad/lib/libfb.a
	Add -DNO_DRAND48, -DNO_VFPRINTF, or -DNO_STRRCHR if drand48(),
	vfprintf(), or strrchr() are not present in your C library
	(e.g. on 4BSD-based systems).

	This program displays a frame buffer image gradually, randomly
	selecting the pixel display sequence.  (Suggested by Gary Moss.)
	It requires fast single-pixel write support for best effect.

	Options:

	-h		assumes 1024x1024 default input size instead of 512x512

	-f in_fb_file	reads from the specified frame buffer file instead
			of assuming constant black ("fade out") value

	-s size		input size (width & height)

	-w width	input width

	-n height	input height

	-F out_fb_file	writes to the specified frame buffer file instead
			of the one specified by the FB_FILE environment
			variable (the default frame buffer, if no FB_FILE)

	-S size		output size (width & height)

	-W width	output width

	-N height	output height

	out_fb_file	same as -F out_fb_file, for convenience
*/
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/fb/fbfade.c,v 11.7 2004/05/10 15:30:42 erikg Exp $ (BRL)";
#endif

#define	USAGE1 "fbfade [ -s size ] [ -w width ] [ -n height ] [ -f in_fb_file ]"
#define	USAGE2	\
	"\t[ -h ] [ -S size ] [ -W width ] [ -N height ] [ [ -F ] out_fb_file ]"
#define	OPTSTR	"f:F:hn:N:s:S:w:W:"

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include	<signal.h>
#include	<stdio.h>
#ifdef USE_STRING_H
#include	<string.h>
#else
#include	<strings.h>
#endif
#ifdef HAVE_STDARG_H
#include	<stdarg.h>
#else
#include	<varargs.h>
#endif

#include "machine.h"
#include "externs.h"			/* For getopt() */
#include "fb.h"			/* BRL CAD package libfb.a interface */

#ifndef EXIT_SUCCESS
#define	EXIT_SUCCESS	0
#endif
#ifndef EXIT_FAILURE
#define	EXIT_FAILURE	1
#endif

#define SIZE_T size_t

typedef int	bool;
#define	false	0
#define	true	1

static char	*arg0;			/* argv[0] for error message */
static bool	hires = false;		/* set for 1Kx1K; clear for 512x512 */
static char	*in_fb_file = NULL;	/* input image name */
static char	*out_fb_file = NULL;	/* output frame buffer name */
static FBIO	*fbp = FBIO_NULL;	/* libfb input/output handle */
static int	src_width = 0,
		src_height = 0;		/* input image size */
static int	dst_width = 0,
		dst_height = 0;		/* output frame buffer size */
static RGBpixel	*pix;			/* input image */
static RGBpixel	bg = { 0, 0, 0 };	/* background */


#ifndef HAVE_DRAND48
/* Simulate drand48() using 31-bit random() assumed to exist (e.g. in 4BSD): */

double
drand48()
	{
	extern long	random();

	return (double)random() / 2147483648.0;	/* range [0,1) */
	}
#endif

static char *
Simple(char *path)
{
	register char	*s;		/* -> past last '/' in path */

	return (s = strrchr( path, '/' )) == NULL || *++s == '\0' ? path : s;
	}


static void
VMessage(char *format, va_list ap)
{
	(void)fprintf( stderr, "%s: ", arg0 );
#ifndef HAVE_VPRINTF
	(void)fprintf( stderr, format,	/* kludge city */
		       ((int *)ap)[0], ((int *)ap)[1],
		       ((int *)ap)[2], ((int *)ap)[3]
		     );
#else
	(void)vfprintf( stderr, format, ap );
#endif
	(void)putc( '\n', stderr );
	(void)fflush( stderr );
	}


#if defined(HAVE_STDARG_H)
static void
Message( char *format, ... )
#else
static void
Message( va_alist )
	va_dcl
#endif
	{
#if !defined(HAVE_STDARG_H)
	register char	*format;	/* must be picked up by va_arg() */
#endif
	va_list		ap;

#if defined(HAVE_STDARG_H)
	va_start( ap, format );
#else
	va_start( ap );
	format = va_arg( ap, char * );
#endif
	VMessage( format, ap );
	va_end( ap );
	}


#if defined(HAVE_STDARG_H)
static void
Fatal( char *format, ... )
#else
static void
Fatal( va_alist )
	va_dcl
#endif
	{
#if !defined(HAVE_STDARG_H)
	register char	*format;	/* must be picked up by va_arg() */
#endif
	va_list		ap;

#if defined(HAVE_STDARG_H)
	va_start( ap, format );
#else
	va_start( ap );
	format = va_arg( ap, char * );
#endif
	VMessage( format, ap );
	va_end( ap );

	if ( fbp != FBIO_NULL && fb_close( fbp ) == -1 )
		Message( "Error closing frame buffer" );

	exit( EXIT_FAILURE );
	/*NOTREACHED*/
	}


static void
Sig_Catcher(int sig)
{
	(void)signal( sig, SIG_DFL );

	/* The following is not guaranteed to work, but it's worth a try. */
	Fatal( "Interrupted by signal %d", sig );
	}


int
main(int argc, char **argv)
{
	/* Plant signal catcher. */
	{
	static int	getsigs[] =	/* signals to catch */
		{
		SIGHUP,			/* hangup */
		SIGINT,			/* interrupt */
		SIGQUIT,		/* quit */
		SIGPIPE,		/* write on a broken pipe */
		SIGTERM,		/* software termination signal */
		0
		};
	register int	i;

	for ( i = 0; getsigs[i] != 0; ++i )
		if ( signal( getsigs[i], SIG_IGN ) != SIG_IGN )
			(void)signal( getsigs[i], Sig_Catcher );
	}

	/* Process arguments. */

	arg0 = Simple( argv[0] );	/* save for possible error message */

	{
		register int	c;
		register bool	errors = false;

		while ( (c = getopt( argc, argv, OPTSTR )) != EOF )
			switch( c )
				{
			default:	/* '?': invalid option */
				errors = true;
				break;

			case 'f':	/* -f in_fb_file */
				in_fb_file = optarg;
				break;

			case 'F':	/* -F out_fb_file */
				out_fb_file = optarg;
				break;

			case 'h':	/* -h */
				hires = true;
				break;

			case 'n':	/* -n height */
				if ( (src_height = atoi( optarg )) <= 0 )
					errors = true;

				break;

			case 'N':	/* -N height */
				if ( (dst_height = atoi( optarg )) <= 0 )
					errors = true;

				break;

			case 's':	/* -s size */
				if ( (src_height = src_width = atoi( optarg ))
				  <= 0
				   )
					errors = true;

				break;

			case 'S':	/* -S size */
				if ( (dst_height = dst_width = atoi( optarg ))
				  <= 0
				   )
					errors = true;

				break;

			case 'w':	/* -w width */
				if ( (src_width = atoi( optarg )) <= 0 )
					errors = true;

				break;

			case 'W':	/* -W width */
				if ( (dst_width = atoi( optarg )) <= 0 )
					errors = true;

				break;
				}

		if ( errors )
			Fatal( "Usage: %s\n%s", USAGE1, USAGE2 );
	}

	if ( optind < argc )		/* out_fb_file */
		{
		if ( optind < argc - 1 || out_fb_file != NULL )
			{
			Message( "Usage: %s\n%s", USAGE1, USAGE2 );
			Fatal( "Can't handle multiple output frame buffers!" );
			}

		out_fb_file = argv[optind];
		}

	/* Open frame buffer for unbuffered input. */

	if ( src_width == 0 )
		src_width = hires ? 1024 : 512;		/* starting default */

	if ( src_height == 0 )
		src_height = hires ? 1024 : 512;	/* starting default */

	if ( in_fb_file != NULL ) {
		if ( (fbp = fb_open( in_fb_file, src_width, src_height ))
		  == FBIO_NULL
		   )
			Fatal( "Couldn't open input frame buffer" );
		else	{
			register int	y;
			register int	wt = fb_getwidth( fbp );
			register int	ht = fb_getheight( fbp );

			/* Use smaller actual input size instead of request. */

			if ( wt < src_width )
				src_width = wt;

			if ( ht < src_height )
				src_height = ht;

			if ( (long)(SIZE_T)((long)src_width * (long)src_height
					   * (long)sizeof(RGBpixel)
					   )
			  != (long)src_width * (long)src_height
					     * (long)sizeof(RGBpixel)
			   )
				Fatal( "Integer overflow, malloc unusable" );

			if ( (pix = (RGBpixel *)malloc( (SIZE_T)src_width
						      * (SIZE_T)src_height
						      * sizeof(RGBpixel)
						      )
			     ) == NULL
			   )
				Fatal( "Not enough memory for pixel array" );

			for ( y = 0; y < src_height; ++y )
				if ( fb_read( fbp, 0, y, pix[y * src_width],
					      src_width
					    ) == -1
				   )
					Fatal( "Error reading raster" );

			if ( fb_close( fbp ) == -1 )
				{
				fbp = FBIO_NULL;	/* avoid second try */
				Fatal( "Error closing input frame buffer" );
				}
			}
	}

	/* Open frame buffer for unbuffered output. */

	if ( dst_width == 0 )
		dst_width = src_width;		/* default */

	if ( dst_height == 0 )
		dst_height = src_height;	/* default */

	if ( (fbp = fb_open( out_fb_file, dst_width, dst_height )) == FBIO_NULL
	   )
		Fatal( "Couldn't open output frame buffer" );
	else	{
		register int	wt = fb_getwidth( fbp );
		register int	ht = fb_getheight( fbp );

		/* Use smaller actual frame buffer size for output. */

		if ( wt < dst_width )
			dst_width = wt;

		if ( ht < dst_height )
			dst_height = ht;

		/* Avoid selecting pixels outside the input image. */

		if ( dst_width > src_width )
			dst_width = src_width;

		if ( dst_height > src_height )
			dst_height = src_height;
		}

	/* The following is probably an optimally fast shuffling algorithm;
	   unfortunately, it requires a huge auxiliary array.  The way it
	   works is to start with an array of all pixel indices, then repeat:
	   select an entry at random from the array, output that index, replace
	   that entry with the last array entry, then reduce the array size. */
	{
	register long	*loc;		/* keeps track of pixel shuffling */
	register long	wxh = (long)dst_width * (long)dst_height;
					/* down-counter */

	if ( (long)(SIZE_T)(wxh * (long)sizeof(long))
	  != wxh * (long)sizeof(long)
	   )
		Fatal( "Integer overflow, malloc unusable" );

	if ( (loc = (long *)malloc( (SIZE_T)wxh * sizeof(long) )) == NULL )
		Fatal( "Not enough memory for location array" );

	/* Initialize pixel location array to sequential order. */

	while ( --wxh >= 0L )
		loc[wxh] = wxh;

	/* Select a pixel at random, paint it, and adjust the location array. */

	for ( wxh = (long)dst_width * (long)dst_height; --wxh >= 0L; )
		{
		register long	r = (long)((double)wxh * drand48());
		register long	x = loc[r] % dst_width;
		register long	y = loc[r] / dst_width;

		if ( fb_write( fbp, (int)x, (int)y,
			       in_fb_file == NULL ? bg
						  : pix[x + y * src_width],
			       1
			     ) == -1
		   )
			Fatal( "Error writing pixel" );

		loc[r] = loc[wxh];	/* track the shuffle */
		}
	}

	/* Close the frame buffer. */

	if ( fb_close( fbp ) == -1 )
		{
		fbp = FBIO_NULL;	/* avoid second try */
		Fatal( "Error closing output frame buffer" );
		}

	exit( EXIT_SUCCESS );
	}
@


11.7
log
@change conf.h to a wrapped config.h
@
text
@d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/fb/fbfade.c,v 11.6 2004/04/05 07:49:23 morrison Exp $ (BRL)";
@


11.6
log
@merge of ansi-6-0-branch into HEAD
@
text
@d42 1
a42 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d50 5
a54 1
#include "conf.h"
@


11.5
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/fbfade.c,v 11.3 2001/08/10 21:27:04 butler Exp $ (BRL)";
d108 2
a109 3
Simple( path )
	char		*path;
	{
d117 2
a118 4
VMessage( format, ap )
	char	*format;
	va_list	ap;
	{
d190 2
a191 3
Sig_Catcher( sig )
	int	sig;
	{
d200 2
a201 4
main( argc, argv )
	int	argc;
	char	*argv[];
	{
@


11.5.2.1
log
@Initial ANSIfication
@
text
@d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/fbfade.c,v 11.5 2002/08/20 17:07:24 jra Exp $ (BRL)";
d108 3
a110 2
Simple(char *path)
{
d118 4
a121 2
VMessage(char *format, va_list ap)
{
d193 3
a195 2
Sig_Catcher(int sig)
{
d204 4
a207 2
main(int argc, char **argv)
{
@


11.4
log
@Converted from K&R to ANSI C - RFH
@
text
@d108 3
a110 2
Simple(char *path)
{
d118 4
a121 2
VMessage(char *format, va_list ap)
{
d193 3
a195 2
Sig_Catcher(int sig)
{
d204 4
a207 2
main(int argc, char **argv)
{
@


11.3
log
@Misc compiler warning fixes
@
text
@d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/fbfade.c,v 11.2 2001/04/12 17:44:07 bparker Exp $ (BRL)";
d108 2
a109 3
Simple( path )
	char		*path;
	{
d117 2
a118 4
VMessage( format, ap )
	char	*format;
	va_list	ap;
	{
d190 2
a191 3
Sig_Catcher( sig )
	int	sig;
	{
d200 2
a201 4
main( argc, argv )
	int	argc;
	char	*argv[];
	{
@


11.2
log
@*- get rid of warnings
@
text
@d42 1
a42 2
static char	RCSid[] =		/* for "what" utility */
	"@@(#)$Header: /c/CVS/brlcad/fb/fbfade.c,v 11.1 1995/01/04 10:09:18 mike Rel4_4 $ (BRL)";
@


11.1
log
@Release_4.4
@
text
@d43 1
a43 1
	"@@(#)$Header: /m/cad/fb/RCS/fbfade.c,v 10.2 94/08/23 18:49:04 gdurf Exp $ (BRL)";
d318 1
a318 1
	if ( in_fb_file != NULL )
d365 1
@


10.2
log
@Added includes, factored ifdefs
@
text
@d43 1
a43 1
	"@@(#)$Header: /m/cad/fb/RCS/fbfade.c,v 10.1 1991/10/12 06:46:23 mike Rel4_0 gdurf $ (BRL)";
@


10.1
log
@Release_4.0
@
text
@d43 1
a43 1
	"@@(#)$Header: /m/cad/fb/RCS/fbfade.c,v 9.2 91/08/29 23:22:40 mike Exp $ (BRL)";
d51 1
a51 9
#ifdef BSD	/* BRL-CAD */
#define	NO_DRAND48	1
#define	NO_VFPRINTF	1
#define	NO_STRRCHR	1
#endif

#if defined(sgi) && !defined(mips)	/* Not all SYSVs are perfect */
#define	NO_VFPRINTF	1
#endif
d55 3
a57 1
#ifdef BSD
a58 2
#else
#include	<string.h>
d60 1
a60 6
#include "machine.h"
#include "externs.h"

#if __STDC__
#define	SIZE_T	size_t
extern double	drand48( void );	/* in UNIX System V C library */
a62 1
#define	SIZE_T	unsigned
d66 4
a75 2
extern char	*optarg;
extern int	optind;
d77 1
a77 1
#include	<fb.h>			/* BRL CAD package libfb.a interface */
d96 1
a96 1
#ifdef NO_DRAND48
d100 1
a100 5
drand48(
#if __STDC__
	 void
#endif
       )
a107 1

d124 1
a124 1
#ifdef NO_VFPRINTF
d137 1
a137 1
#if __STDC__
d146 1
a146 1
#if !__STDC__
d151 1
a151 1
#if __STDC__
d162 1
a162 1
#if __STDC__
d171 1
a171 1
#if !__STDC__
d176 1
a176 1
#if __STDC__
@


9.2
log
@Stardent fixes, minor cleanup
@
text
@d43 1
a43 1
	"@@(#)$Header: /m/cad/fb/RCS/fbfade.c,v 9.1 89/05/19 06:08:48 mike Rel3_5 $ (BRL)";
@


9.1
log
@Release_3.5
@
text
@d43 1
a43 1
	"@@(#)$Header: fbfade.c,v 1.8 89/05/08 17:50:52 phil Exp $ (BRL)";
d68 3
a71 2
#include	<stdarg.h>
#include	<stdlib.h>
a72 3
#if __STDC__ == 1	/* workaround for Cray nonsense */
extern int	getopt( int, char const * const *, char const * );
#endif
d74 1
d76 1
a76 3
#ifdef NO_STRRCHR
#define	strrchr( s, c )	rindex( s, c )
#endif
a77 5
#define	SIZE_T	unsigned
extern void	exit();
extern char	*malloc();
extern int	atoi(), getopt();
extern double	drand48();
d79 1
@


1.8
log
@redid string[s].h fix!
@
text
@d43 1
a43 1
	"@@(#)$Header: fbfade.c,v 1.7 89/05/08 17:18:00 phil Locked $ (BRL)";
@


1.7
log
@*** empty log message ***
@
text
@d43 1
a43 1
	"@@(#)$Header: fbfade.c,v 1.5 89/05/04 03:09:45 gwyn Exp $ (BRL)";
d63 3
d67 1
@


1.6
log
@string[s] and getopt portability
@
text
@d43 1
a43 1
	"@@(#)$Header: fbfade.c,v 1.5 89/05/04 03:09:45 phil Locked $ (BRL)";
a62 3
#ifdef BSD
#include	<strings.h>
#else
a63 1
#endif
d68 1
a68 1
#ifndef CRAY	/* CRAY defines getopt in stdlib.h! */
d72 1
a72 1
#else /* !__STDC__ */
d82 1
a82 1
#endif /* !__STDC__ */
@


1.5
log
@*** empty log message ***
@
text
@d43 1
a43 1
	"@@(#)$Header: fbfade.c,v 1.4 89/05/04 03:04:49 gwyn Locked $ (BRL)";
d63 3
d67 1
d72 1
d74 1
d76 1
a76 1
#else
d86 1
a86 1
#endif
@


1.4
log
@*** empty log message ***
@
text
@d43 1
a43 1
	"@@(#)$Header: fbfade.c,v 1.2 89/04/26 20:08:57 gwyn Locked $ (BRL)";
a335 1
/*XXX*/Message( "Requested source %dx%d", src_width, src_height );
a353 1
/*XXX*/Message( "Final source %dx%d", src_width, src_height );
a391 1
/*XXX*/Message( "Requested destination %dx%d", dst_width, dst_height );
a413 1
/*XXX*/Message( "Final destination %dx%d", dst_width, dst_height );
@


1.3
log
@*** empty log message ***
@
text
@d98 1
a98 1
static char	*in_fb_file = NULL;	/* input frame buffer name */
d100 1
a100 1
static FBIO	*fbp = FBIO_NULL;	/* input/output frame buffer handle */
d347 1
a347 1
			/* Use smaller input image size instead of 512/1024. */
d402 1
a402 1
		/* Use smaller frame buffer size for output. */
d410 1
a410 1
		/* Don't select pixels outside input image. */
d423 2
a424 2
	   select entry at random from the array, output that index, replace
	   the entry with the last array entry, and reduce the array size. */
@


1.2
log
@SGI 3-d machines do not have vfprintf()
@
text
@d4 1
a4 1
	created:	89/04/26	D A Gwyn with help from G S Moss
d18 1
a18 1
	-h		assumes 1024x1024 frame buffer instead of 512x512
d20 1
a20 1
	-i in_fb_file	reads from the specified frame buffer file instead
d23 7
a29 1
	-f out_fb_file	writes to the specified frame buffer file instead
d33 1
a33 1
	-F out_fb_file	same as -f fb_file (BRL-CAD package compatibility)
d35 5
a39 1
	out_fb_file	same as -f fb_file, for convenience
d42 2
a43 2
static char	SCCSid[] = "%W% %E%";	/* for "what" utility */
static char RCSid[] = "@@(#)$Header: fbfade.c,v 1.1 89/04/26 19:21:26 mike Locked $ (BRL)";
d46 4
a49 3
#define	USAGE	\
	 "fbfade [ -h ] [ -i in_fb_file ] [ out_fb_file ]"
#define	OPTSTR	"hi:f:F:"
d78 1
a78 1
extern int	getopt();
d101 4
a104 1
static int	width, height;		/* full frame buffer size */
d256 1
a256 2
			default:	/* just in case */
			case '?':	/* invalid option */
d260 8
d272 4
a275 2
			case 'i':	/* -i in_fb_file */
				in_fb_file = optarg;
d278 4
a281 3
			case 'f':	/* -f out_fb_file */
			case 'F':	/* -F out_fb_file */
				out_fb_file = optarg;
d283 28
d314 1
a314 1
			Fatal( "Usage: %s", USAGE );
d321 1
a321 1
			Message( "Usage: %s", USAGE );
d330 2
a331 1
	width = height = hires ? 1024 : 512;	/* starting default */
d333 4
d338 3
a340 1
		if ( (fbp = fb_open( in_fb_file, width, height )) == FBIO_NULL )
d347 1
a347 1
			/* Use actual input image size instead of 512/1024. */
d349 2
a350 2
			width = wt;
			height = ht;
d352 5
a356 1
			if ( (long)(SIZE_T)((long)wt * (long)ht
d359 2
a360 1
			  != (long)wt * (long)ht * (long)sizeof(RGBpixel)
d364 2
a365 1
			if ( (pix = (RGBpixel *)malloc( (SIZE_T)wt * (SIZE_T)ht
d372 4
a375 2
			for ( y = 0; y < ht; ++y )
				if ( fb_read( fbp, 0, y, pix[y * wt], wt ) == -1
d388 9
a396 1
	if ( (fbp = fb_open( out_fb_file, width, height )) == FBIO_NULL )
d402 1
a402 3
		if ( in_fb_file == NULL )
			{
			/* Use actual frame buffer size instead of 512/1024. */
d404 14
a417 9
			width = wt;
			height = ht;
			}
		else
			if ( wt < width || ht < height )
				Fatal(
			  "Output frame buffer too small (%dx%d); %dx%d needed",
				       wt, ht, width, height
				     );
d421 4
a424 1
	   unfortunately, it requires a huge auxiliary array. */
d427 1
a427 1
	register long	wxh = (long)width * (long)height;
d430 5
d440 1
a440 1
	for ( wxh = (long)width * (long)height; --wxh >= 0L; )
d445 1
a445 1
	for ( wxh = (long)width * (long)height; --wxh >= 0L; )
d448 2
d451 3
a453 3
		if ( fb_write( fbp,
			       (int)(loc[r] % width), (int)(loc[r] / width),
			       in_fb_file == NULL ? bg : pix[loc[r]],
@


1.1
log
@Initial revision
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 8.2 89/04/11 22:15:25 phil Exp $ (BRL)";
d44 4
@
