head	11.12;
access;
symbols
	ansi-20040405-merged:11.8.2.2
	postmerge-20040405-ansi:11.10
	premerge-20040404-ansi:11.9
	postmerge-autoconf:11.9
	autoconf-freeze:11.8.10.2
	premerge-autoconf:11.9
	ansi-20040316-freeze:11.8.2.1
	postmerge-20040315-windows:11.9
	premerge-20040315-windows:11.9
	windows-20040315-freeze:11.8.4.1
	autoconf-20031203:11.8
	autoconf-20031202:11.8
	autoconf-branch:11.8.0.10
	phong-branch:11.8.0.8
	photonmap-branch:11.8.0.6
	rel-6-1-DP:11.8
	windows-branch:11.8.0.4
	rel-6-0-2:11.6
	ansi-branch:11.8.0.2
	rel-6-0-1-branch:11.6.0.2
	hartley-6-0-post:11.7
	hartley-6-0-pre:11.6
	rel-6-0-1:11.6
	rel-6-0:11.6
	rel-5-4:11.4
	offsite-5-3-pre:11.5
	rel-5-3:11.4
	rel-5-2:11.4
	rel-5-1-branch:11.4.0.2
	rel-5-1:11.4
	rel-5-0:11.4
	rel-5-0-beta:11.4
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:5.1
	rel-1-24:5.1
	rel-1-20:4.3
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.12
date	2004.05.24.04.13.27;	author morrison;	state dead;
branches;
next	11.11;

11.11
date	2004.05.10.15.30.42;	author erikg;	state Exp;
branches;
next	11.10;

11.10
date	2004.04.05.07.49.23;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2004.02.02.17.39.01;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2002.08.20.17.07.25;	author jra;	state Exp;
branches
	11.8.2.1
	11.8.4.1
	11.8.10.1;
next	11.7;

11.7
date	2002.08.15.20.54.38;	author hartley;	state Exp;
branches;
next	11.6;

11.6
date	2001.04.12.17.44.08;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	2000.08.24.03.58.34;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	99.01.15.05.53.19;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	98.09.22.02.46.35;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.07.16.22.05.28;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.09.42;	author mike;	state Rel4_4;
branches;
next	10.4;

10.4
date	94.10.14.08.11.11;	author jra;	state Exp;
branches;
next	10.3;

10.3
date	94.08.23.18.49.18;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.08.11.15.06.18;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.46.46;	author mike;	state Rel4_0;
branches;
next	9.5;

9.5
date	91.10.11.21.45.28;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	91.09.21.03.41.52;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	91.07.22.21.48.35;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	91.01.12.08.54.03;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.11.05;	author mike;	state Rel3_5;
branches;
next	8.1;

8.1
date	88.10.05.00.43.32;	author mike;	state Rel3_0;
branches;
next	7.11;

7.11
date	88.09.17.03.38.28;	author mike;	state Exp;
branches;
next	7.10;

7.10
date	88.08.19.22.42.08;	author phil;	state Exp;
branches;
next	7.9;

7.9
date	88.08.16.03.06.08;	author mike;	state Exp;
branches;
next	7.8;

7.8
date	88.06.21.04.43.49;	author phil;	state Exp;
branches;
next	7.7;

7.7
date	88.05.16.00.06.59;	author mike;	state Exp;
branches;
next	7.6;

7.6
date	88.02.20.04.27.54;	author mike;	state Exp;
branches;
next	7.5;

7.5
date	88.02.17.17.52.40;	author phil;	state Exp;
branches;
next	7.4;

7.4
date	88.02.06.09.19.04;	author phil;	state Exp;
branches;
next	7.3;

7.3
date	88.01.30.00.36.32;	author phil;	state Exp;
branches;
next	7.2;

7.2
date	88.01.27.00.58.34;	author wm;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.09.20;	author mike;	state Rel;
branches;
next	6.2;

6.2
date	87.09.03.02.12.52;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.08.12.43;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.43.37;	author mike;	state Rel;
branches;
next	4.4;

4.4
date	87.03.16.21.53.29;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.02.13.00.50.31;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.01.12.16.48.12;	author mike;	state Rel1;
branches;
next	4.1;

4.1
date	86.12.29.03.14.00;	author mike;	state Rel1;
branches;
next	1.20;

1.20
date	86.12.29.01.30.06;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	86.12.29.00.53.30;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	86.12.28.23.13.28;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	86.12.03.11.45.49;	author reschly;	state Exp;
branches;
next	1.16;

1.16
date	86.11.28.14.30.44;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	86.11.28.14.04.39;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	86.11.28.13.40.03;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	86.11.20.20.06.52;	author phil;	state Exp;
branches;
next	1.12;

1.12
date	86.11.14.22.13.32;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	86.11.13.02.20.49;	author phil;	state Exp;
branches;
next	1.10;

1.10
date	89.10.31.02.27.35;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	86.10.28.23.41.04;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	86.10.28.21.23.02;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	86.10.28.20.45.24;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	86.10.28.19.57.50;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	86.04.09.02.28.26;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	86.04.09.00.59.01;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	86.03.31.22.50.52;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.03.04.00.05.33;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.03.03.22.57.10;	author mike;	state Exp;
branches;
next	;

11.8.2.1
date	2002.09.19.18.00.43;	author morrison;	state Exp;
branches;
next	11.8.2.2;

11.8.2.2
date	2004.03.17.21.16.08;	author morrison;	state Exp;
branches;
next	;

11.8.4.1
date	2004.03.11.23.40.44;	author morrison;	state Exp;
branches;
next	;

11.8.10.1
date	2004.02.12.19.40.46;	author erikg;	state Exp;
branches;
next	11.8.10.2;

11.8.10.2
date	2004.03.15.13.28.06;	author erikg;	state Exp;
branches;
next	;


desc
@Program to plot UNIX plot files on Ikonas display.
@


11.12
log
@moved to src/fb/
@
text
@/*
 *			P L - F B . C
 *
 *	Program to take 3-D UNIX plot data and output on a framebuffer.
 *
 *  Authors -
 *	Joseph C. Pistritto
 *	Michael John Muuss
 *	Douglas A. Gwyn
 *
 * Function:
 * 	Reads device-independent plot data from specified input file;
 * 	for each frame, builds an image file containing raster data then
 * 	sends the frame output to the output device.
 * 
 * 	Edge-limiting is done here; use "rot" if clipping is desired.
 * 
 * Method:
 * 	Inputs vector data and builds a rasterization descriptor for
 * 	each visible stroke.  (Strokes are limited to frame boundaries.)
 * 	X goes down the page, Y goes from left to right.  To obtain a
 * 	different orientation, pre-process data with the "rot" filter.
 * 	(Quadrant 1 graphics devices)
 * 
 * 	The frame image file of SCANS scans is considered artificially
 * 	divided into BANDS bands, each containing lines_per_band scans.
 * 	Each band has a linked list of descriptors for
 * 	not-yet-rasterized strokes that start in the band.
 * 
 * 	Space for descriptors is obtained via "malloc".  When no more
 * 	space is available, the image file is updated as follows, then
 * 	"malloc" is tried again ("must" work the second time):
 * 
 * 	Each band in increasing X order becomes "active"; if no
 * 	descriptors exist for the band it is skipped, otherwise its
 * 	existing raster data is re-read from the image file into a
 * 	buffer and each descriptor is processed to rasterize its stroke.
 * 	If the stroke terminates in the band its descriptor is freed,
 * 	otherwise the descriptor is linked into the following band's
 * 	list.  When the descriptor list for the active band becomes
 * 	empty (must happen), the band's raster data is flushed back to
 * 	the image file and the next band becomes active.  This process
 * 	continues until all vectors have been input and rasterized.
 * 
 * Acknowledgment:
 * 	Based rather heavily on Doug Gwyn's Versatec PLOT rasterizer VPL.C
 * 	which was based on Mike Muuss's Versatec TIGpack interpreter.
 *
 *  Note:
 *	UNIX-Plot files are defined to be machine-independent, with
 *	"little-endian" (eg, VAX) byte-ordering.
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/fb/pl-fb.c,v 11.11 2004/05/10 15:30:42 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#if DEBUG
# define STATIC	/* nothing, for debugging */
#else
# define STATIC	static
#endif

#include <signal.h>
#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <ctype.h>
#include "machine.h"
#include "fb.h"
#include "externs.h"
#include "plot3.h"

/*
	Raster device model and image terminology as used herein:

Frames are delimited in plot data by "erase" codes; each frame looks
like:


			    top of frame
	---------------------------------------------------------
	|			.				|
	|scan line ->...........................................|
 ^	|			.				|
 |	|			^				|
	|			|				|
	|Y axis							|
	|plot							|
 ^	|^							|
 |	||							|
	||	X axis						|
	|-----> plot						|
	---------------------------------------------------------
			    bottom of frame


Each plot-mode scan line consists of exactly BYTES bytes of plot data.

Each scan line is composed of bytes of color data, for the Red,
Green, and Blue for each pixel, times the number of pixels desired
(512 in LORES, 1024 in HIRES)

*/

/*	Device Parameters				 */

/* the following parameter should be tweaked for fine-tuning */
#define	X_CHAR_SIZE	(8)		/* pixels per char horizontal */
#define	Y_CHAR_SIZE	(10)		/* pixels per char vertical */

#define	CLEAR	0			/* value for no intensity */


/*	Program constants computed from device parameters:	*/

#define BANDS	(Nscanlines / lines_per_band)		/* # of "bands" */
#define BANDSLOP	(BANDS+2)		/* # bands in array */
#define BYTES	(Npixels * sizeof(RGBpixel))	/* max data bytes per scan */
#define XMAX	(Npixels - 1)
#define YMAX	(Nscanlines - 1)

/*	Data structure definitions:	*/

#ifdef pdp11
typedef char	tiny;			/* for very small numbers */
#else
typedef	short	tiny;			/* for very small numbers */
#endif

typedef int	bool;			/* boolean data type */
#define false	0
#define true	1

RGBpixel	cur_color = { 255, 255, 255 };

typedef struct {
	short		x;
	short		y;
} coords; 				/* Cartesian coordinates */

typedef struct descr {
	long		magic;
	struct descr	*next;		/* next in list, or NULL */
	coords		pixel;		/* starting scan, nib */
	tiny		xsign;		/* 0 or +1 */
	tiny		ysign;		/* -1, 0, or +1 */
	bool		ymajor; 	/* true iff Y is major dir. */
#undef major
#undef minor
	short		major;		/* major dir delta (nonneg) */
	short		minor;		/* minor dir delta (nonneg) */
	short		e;		/* DDA error accumulator */
	short		de;		/* increment for `e' */
	RGBpixel	col;		/* COLOR of this vector */
	struct descr	*freep;		/* next in free list, or NULL */
} stroke; 				/* rasterization descriptor */
#define STROKE_MAGIC	0x12997601	/* Magic number */

#define	CK_STROKE(_sp)	{ \
	if((_sp)->magic != STROKE_MAGIC)  {  \
		fprintf(stderr,"Bad stroke struct, ptr=x%lx, magic was x%lx, s/b=x%lx, at file %s, line %d\n",  \
			(long)(_sp), (long)((_sp)->magic), (long)STROKE_MAGIC,  \
			__FILE__, __LINE__ );  \
		abort();  \
	} }

/*	Global data allocations:	*/

/* Space is used strictly to compute delta and deltao2
 * and to compute integer screen coordinates from them.
 * We thus make these variables only floating point.
 */
STATIC struct {
	double		left;		/* window edges */
	double		bottom;
	double		right;
	double		top;
} space;
STATIC double	delta;			/* larger window dimension */
STATIC double	deltao2;		/* delta / 2 */

struct	relvect {
	short	x,y;			/* x, y values (255,255 is end) */
};

#define	END	-1,-1			/* end of stroke description */
#define	NIL	0,0
#define min(a,b)	((a)<(b)?(a):(b))
/*
 *  These character sets are taken from the Motorola MC6575 Pattern Generator,
 *  page 5-119 of 'The Complete Motorola Microcomputer Data Library'
 */
STATIC struct vectorchar {
	char		ascii;		/* ASCII character emulated */
	struct	relvect	r[10];		/* maximum # of vectors 1 char */
} charset[] = {
/*ASCII <1>    <2>    <3>    <4>    <5>    <6>    <7>    <8>    <9>    <10> */
   {'0', {{5,0},   {1,0},   {0,1},   {0,7},   {6,1},   {6,7},   {5,8},   {1,8},   {END},   {NIL}}},
   {'1', {{1,2},   {3,0},   {3,8},   {5,8},   {1,8},   {END},   {NIL},   {NIL},   {NIL},   {NIL}}},
   {'2', {{0,1},   {1,0},   {5,0},   {6,1},   {6,2},   {4,4},   {2,4},   {0,6},   {0,8},   {6,8}}},
   {'3', {{1,0},   {5,0},   {6,1},   {6,4},   {2,4},   {6,4},   {6,7},   {5,8},   {1,8},   {END}}},
   {'4', {{5,8},   {5,0},   {0,5},   {0,6},   {6,6},   {END},   {NIL},   {NIL},   {NIL},   {NIL}}},
   {'5', {{6,0},   {0,0},   {0,3},   {4,3},   {6,5},   {6,6},   {4,8},   {1,8},   {0,7},   {END}}},
   {'6', {{5,0},   {2,0},   {0,2},   {0,7},   {1,8},   {5,8},   {6,7},   {6,5},   {5,4},   {1,4}}},
   {'7', {{0,1},   {0,0},   {6,0},   {6,1},   {2,5},   {2,8},   {END},   {NIL},   {NIL},   {NIL}}},
   {'8', {{1,0},   {5,0},   {6,1},   {6,7},   {5,8},   {1,8},   {0,7},   {0,1},   {0,4},   {6,4}}},
   {'9', {{1,8},   {4,8},   {6,6},   {6,1},   {5,0},   {1,0},   {0,1},   {0,3},   {1,4},   {6,4}}},
   {'A', {{0,8},   {0,2},   {2,0},   {4,0},   {6,2},   {6,8},   {6,5},   {0,5},   {END},   {NIL}}},
   {'B', {{6,5},   {6,7},   {5,8},   {0,8},   {0,0},   {5,0},   {6,1},   {6,3},   {5,4},   {0,4}}},
   {'C', {{6,1},   {5,0},   {2,0},   {0,2},   {0,6},   {2,8},   {5,8},   {6,7},   {END},   {NIL}}},
   {'D', {{0,0},   {4,0},   {6,2},   {6,6},   {4,8},   {0,8},   {0,0},   {END},   {NIL},   {NIL}}},
   {'E', {{6,0},   {0,0},   {0,4},   {3,4},   {0,4},   {0,8},   {6,8},   {END},   {NIL},   {NIL}}},
   {'F', {{6,0},   {0,0},   {0,4},   {3,4},   {0,4},   {0,8},   {END},   {NIL},   {NIL},   {NIL}}},
   {'G', {{6,1},   {5,0},   {2,0},   {0,2},   {0,6},   {2,8},   {5,8},   {6,7},   {6,5},   {3,5}}},
   {'H', {{0,0},   {0,8},   {0,4},   {6,4},   {6,0},   {6,8},   {END},   {NIL},   {NIL},   {NIL}}},
   {'I', {{1,0},   {5,0},   {3,0},   {3,8},   {1,8},   {5,8},   {END},   {NIL},   {NIL},   {NIL}}},
   {'J', {{2,0},   {6,0},   {4,0},   {4,7},   {3,8},   {1,8},   {0,7},   {END},   {NIL},   {NIL}}},
   {'K', {{0,0},   {0,8},   {0,6},   {6,0},   {2,4},   {6,8},   {END},   {NIL},   {NIL},   {NIL}}},
   {'L', {{0,0},   {0,8},   {6,8},   {END},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL}}},
   {'M', {{0,8},   {0,0},   {3,3},   {3,4},   {3,3},   {6,0},   {6,8},   {END},   {NIL},   {NIL}}},
   {'N', {{0,8},   {0,0},   {6,6},   {6,8},   {6,0},   {END},   {NIL},   {NIL},   {NIL},   {NIL}}},
   {'O', {{0,6},   {0,2},   {2,0},   {4,0},   {6,2},   {6,6},   {4,8},   {2,8},   {0,6},   {END}}},
   {'P', {{0,8},   {0,0},   {5,0},   {6,1},   {6,3},   {5,4},   {0,4},   {END},   {NIL},   {NIL}}},
   {'Q', {{6,6},   {6,2},   {4,0},   {2,0},   {0,2},   {0,6},   {2,8},   {4,8},   {4,6},   {6,8}}},
   {'R', {{0,8},   {0,0},   {5,0},   {6,1},   {6,3},   {5,4},   {0,4},   {2,4},   {6,8},   {END}}},
   {'S', {{6,1},   {5,0},   {1,0},   {0,1},   {0,4},   {5,4},   {6,5},   {6,7},   {5,8},   {0,8}}},
   {'T', {{0,0},   {6,0},   {3,0},   {3,8},   {END},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL}}},
   {'U', {{0,0},   {0,7},   {1,8},   {5,8},   {6,7},   {6,0},   {END},   {NIL},   {NIL},   {NIL}}},
   {'V', {{0,0},   {0,2},   {3,8},   {6,2},   {6,0},   {END},   {NIL},   {NIL},   {NIL},   {NIL}}},
   {'W', {{0,0},   {0,8},   {3,5},   {3,4},   {3,5},   {6,8},   {6,0},   {END},   {NIL},   {NIL}}},
   {'X', {{0,0},   {6,8},   {3,4},   {0,8},   {6,0},   {END},   {NIL},   {NIL},   {NIL},   {NIL}}},
   {'Y', {{0,0},   {0,1},   {3,4},   {3,8},   {3,4},   {6,1},   {6,0},   {END},   {NIL},   {NIL}}},
   {'Z', {{0,0},   {6,0},   {6,1},   {0,7},   {0,8},   {6,8},   {END},   {NIL},   {NIL},   {NIL}}},
   {'+', {{0,4},   {6,4},   {3,4},   {3,1},   {3,7},   {END},   {NIL},   {NIL},   {NIL},   {NIL}}},
   {'-', {{0,4},   {6,4},   {END},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL}}},
   {'/', {{0,7},   {6,1},   {END},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL}}},
   {'(', {{4,0},   {2,2},   {2,6},   {4,8},   {END},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL}}},
   {')', {{2,0},   {4,2},   {4,6},   {2,8},   {END},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL}}},
   {'<', {{4,0},   {0,4},   {4,8},   {END},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL}}},
   {'>', {{2,0},   {6,4},   {2,8},   {END},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL}}},

/* Some needed chars, hastily drawn -MJM */
   {'.', {{4,7},   {3,7},   {3,6},   {4,6},   {4,7},   {END},   {NIL},   {NIL},   {NIL},   {NIL}}},
   {',', {{4,6},   {3,6},   {3,5},   {4,5},   {4,8},   {END},   {NIL},   {NIL},   {NIL},   {NIL}}},

   {'\0'}
};

STATIC int	Nscanlines = 512;
STATIC int	Npixels = 512;
STATIC char	*framebuffer = NULL;
STATIC char	*filename = NULL;

struct band  {
	stroke	*first;
	stroke	*last;
};
STATIC struct band	*band;		/* array of descriptor lists */
STATIC struct band	*bandEnd;

STATIC unsigned char	*buffer;		/* ptr to active band buffer */
STATIC long	buffersize;		/* active band buffer bytes */
STATIC short	ystart = 0;		/* active band starting scan */
STATIC int	debug  = 0;
STATIC int	over = 0;		/* !0 to overlay on existing image */
STATIC int	immediate = 0;		/* !0 to plot immediately */
STATIC int	single_banded = 0;	/* !0 if one fullscreen band */
STATIC short	lines_per_band = 16;	/* scan lines per band */
STATIC short	line_thickness = 1;

STATIC int	sigs[] =		/* signals to be caught */
	{
	SIGHUP,
	SIGINT,
	SIGQUIT,
	SIGTERM
	};

 
/*	Externals:	*/

STATIC FILE	*pfin;		/* input file FIO block ptr */

FBIO	*fbp;			/* Current framebuffer */

/*	Local subroutines:	*/

STATIC int	DoFile(void), Foo(int code);
STATIC stroke	*Dequeue(register struct band *bp, register stroke **hp);
STATIC bool	BuildStr(coords *pt1, coords *pt2), GetCoords(register coords *coop),
		OutBuild(void);
STATIC void	Catch(register int sig), FreeUp(void), InitDesc(void), Requeue(register struct band *bp, register stroke *vp),
		Raster(register stroke *vp, register struct band *np), SetSigs(void);

void		edgelimit(register coords *ppos), put_vector_char(register char c, register coords *pos);

bool	Get3Coords(register coords *coop);
bool	Get3DCoords(register coords *coop);
bool	GetDCoords(register coords *coop);

/*
 *  Stroke descriptor management.
 *  We malloc these in large blocks and keep our own free list.
 *  Last I looked it took 32 bytes per stroke, so every 32 strokes
 *  is 1KB, or 32K strokes / MByte.
 */
#define	STROKE_NULL	((stroke *)0)

STATIC struct descr	*freep = STROKE_NULL;	/* head of free stroke list */

/* allocate new strokes to the free list */
STATIC void
get_strokes(void)
{
	register stroke	*sp;
	register char	*cp;
	register int	bytes;

	/* ~32 strokes/KB */
	bytes = 640 * sizeof(stroke);
	if( (cp = malloc(bytes)) == (char *)0 ) {
		/* Attempt to draw/free some vectors and try again */
		OutBuild();
		if( (cp = malloc(bytes)) == (char *)0 ) {
			fprintf(stderr,"pl-fb: malloc failed!\n");
			exit( 2 );
		}
	}
	/* link them all into the free list */
	sp = (stroke *)cp;
	while( bytes >= sizeof(stroke) ) {
		sp->freep = freep;
		sp->magic = STROKE_MAGIC;
		freep = sp++;
		bytes -= sizeof(stroke);
	}
}

#define GET_STROKE(vp)    { \
			while( ((vp)=freep) == STROKE_NULL ) \
				get_strokes(); \
			freep = (vp)->freep; \
			CK_STROKE(vp); \
			(vp)->freep = STROKE_NULL; }

#define FREE_STROKE(vp)  { \
			CK_STROKE(vp); \
			(vp)->freep = freep; \
			freep = (vp); }

/*
 *			S X T 1 6
 *
 *  Take a value which is currently considered "unsigned" with 16 bits
 *  of significance, and sign-extend it in a reasonably portable way.
 *  We assume the machine is twos-compliment.
 */
long
sxt16(register long int v)
{
	register long w;
	if( v <= 0x7FFF )  return(v);
	w = -1;
	w &= ~0x7FFF;
	return( w | v );
}

int
get_args(int argc, register char **argv)
{
	register int c;

	while( (c = getopt( argc, argv, "hdoOit:F:s:S:w:W:n:N:" )) != EOF ) {
		switch( c ) {
		case 't':
			line_thickness = atoi(optarg);
			if( line_thickness <= 0 )
				line_thickness = 1;
			break;
		case 'i':
			immediate = 1;
			break;
		case 'd':
			/* -d given multiple times increases debug level */
			debug++;
			break;
		case 'O':
		case 'o':
			over = 1;
			break;
		case 'F':
			framebuffer = optarg;
			break;
		case 'h':
			Nscanlines = Npixels = 1024;
			break;
		case 'S':
		case 's':
			Nscanlines = Npixels = atoi(optarg);
			break;
		case 'W':
		case 'w':
			Npixels = atoi(optarg);
			break;
		case 'N':
		case 'n':
			Nscanlines = atoi(optarg);
			break;
		default:		/* '?' */
			return(0);
		}
	}

	if( optind >= argc ) {
		/* no file name given, use stdin */
		if( isatty(fileno(stdin)) )
			return(0);
		filename = "-";
		pfin = stdin;
	} else {
		/* open file */
		filename = argv[optind];
		if( (pfin = fopen(filename, "r")) == NULL ) {
			fprintf( stderr,
			   "pl-fb: Can't open file \"%s\"\n", filename );
			return(0);
		}
	}

	if( argc > ++optind )
		(void)fprintf( stderr, "pl-fb: excess argument(s) ignored\n" );

	return(1);		/* OK */
}

static char usage[] = "\
Usage: pl-fb [-h -d -o -i] [-t thickness] [-F framebuffer]\n\
        [-S squaresize] [-W width] [-N height] [file.plot]\n";

/*
 *  M A I N
 *
 *	Parse arguments, valid ones are:
 *		name of file to plot (instead of STDIN)
 *		-d for debugging statements
 *
 *	Default (no arguments) action is to plot STDIN on current FB.
 */
int
main(int argc, char **argv)
{
	Nscanlines = Npixels = 512;

	if ( !get_args( argc, argv ) )  {
		(void)fputs(usage, stderr);
		exit( 1 );
	}

	/* Open frame buffer, adapt to slightly smaller ones */
	if( (fbp = fb_open(framebuffer, Npixels, Nscanlines)) == FBIO_NULL ) {
		fprintf(stderr,"pl-fb: fb_open failed\n");
		exit(1);
	}
	Npixels = fb_getwidth(fbp);
	Nscanlines = fb_getheight(fbp);
	if( immediate )  {
		lines_per_band = Nscanlines;
		if( !over )
			fb_clear( fbp, RGBPIXEL_NULL );
	} else if( Nscanlines <= 512 ) {
		/* make one full size band */
		lines_per_band = Nscanlines;
		single_banded = 1;
	}

	/*
	 * Handle image-size specific initializations
	 */
	if( (Nscanlines % lines_per_band) != 0 )  {
		/* round it down - only necessary if buffered? */
		Nscanlines = (Nscanlines / lines_per_band) * lines_per_band;
	}
	space.left = space.right = 0;
	space.right = Npixels;
	space.top = Nscanlines;
	delta = Nscanlines;
	deltao2 = Nscanlines/2;

	buffersize = lines_per_band*Npixels*sizeof(RGBpixel);
	if( (buffer = (unsigned char *)malloc(buffersize)) == RGBPIXEL_NULL)  {
		fprintf(stderr,"pl-fb:  malloc error\n");
		exit(1);
	}
	/* Extra band protects against requeueing off the top */
	band = (struct band *)malloc((BANDSLOP)*sizeof(struct band));
	if( band == (struct band *)0 )  {
		fprintf(stderr,"pl-fb: malloc error2\n");
		exit(1);
	}
	bzero( (char *)band, (BANDSLOP)*sizeof(struct band) );
	bandEnd = &band[BANDS];
	if( single_banded && over ) {
    		/* Read in initial screen */
	    	if( fb_read( fbp, 0, 0, buffer, buffersize/sizeof(RGBpixel) ) <= 0 )
    			fprintf(stderr,"pl-fb: band read error\n");
    	}
	if( debug )
		fprintf(stderr, "pl-fb output of %s\n", filename);

	SetSigs();			/* set signal catchers */

	(void)DoFile( );	/* plot it */
	exit(0);
}


/*
	DoFile - process UNIX plot file

	This routine reads UNIX plot records from the specified file
	and controls the entry of the strokes into the descriptor lists.
	Strokes are limited (not clipped) to fit the frame.

	Upon end of file, erase, or flush, plot data is copied to the device.
	Returns status code:
		   < 0	=> catastrophe
		   = 0	=> complete success
		   > 0	=> line limit hit
*/
STATIC int
DoFile(void)	/* returns vpl status code */
{
	register bool	plotted;	/* false => empty frame image */
	register int	c;		/* input character */
	static coords	newpos; 	/* current input coordinates */
	static coords	virpos; 	/* virtual pen position */
	static unsigned char buf3[6*2];
	static unsigned char buf2[4*2];
	static	bool	firsterase = true;

	/* process each frame into a raster image file */

	for ( ; ; )			/* for each frame */
	{
		InitDesc();		/* empty descriptor lists */

		virpos.x = virpos.y = 0;
		plotted = false;

		for ( ; ; )		/* read until EOF*/
		{
			c = getc( pfin );
			if( debug > 1 )  fprintf(stderr,"%c\n", c);
			switch ( c )
			{	/* record type */
			case EOF:
				if( debug ) fprintf( stderr,"EOF\n");
					
				if ( plotted )  {
					/* flush strokes */
					if( debug ) fprintf( stderr,"flushing\n");
					if ( !OutBuild() )
						return Foo( -6 );
				}
				return Foo( 0 );/* success */

			case 'e':	/* erase */
				if( debug )  fprintf( stderr,"Erase\n");

				if ( plotted )  {
					/* flush strokes */
					if( debug ) fprintf( stderr,"flushing\n");
					if ( !OutBuild() )
						return Foo( -6 );
				}
				if( !firsterase ) {
					if( immediate )
						fb_clear( fbp, RGBPIXEL_NULL );
					over = 0;
				}
				firsterase = false;
				break;	/* next frame */

			case 'F':	/* flush */
				if( debug )  fprintf( stderr,"Flush\n");

				if ( plotted )  {
					/* flush strokes */
					if( debug ) fprintf( stderr,"flushing\n");
					if ( !OutBuild() )
						return Foo( -6 );
					if( !immediate )
						over = 1;
				}
				firsterase = false;
				break;	/* next frame */

			case 'f':	/* linemod */
				if(debug)
					fprintf( stderr,"linemod\n");
				/* ignore for time being */
				while ( (c = getc( pfin )) != EOF
				     && c != '\n'
				      )
					;	/* eat string */
				continue;

			case 'L':
			case 'M':
				if ( !Get3Coords( &newpos ) )
					return Foo( -8 );
				virpos = newpos;
				if( c == 'M'  )  {
					if( debug )
						fprintf( stderr,"Move3\n");
					continue;
				}
				if( debug )
					fprintf( stderr,"Line3\n");

			case 'N':	/* continue3 */
			case 'P':	/* point3 */
				if ( !Get3Coords( &newpos ) )
					return Foo( -9 );
				if ( c == 'P' )  {
					if( debug )
						fprintf( stderr,"point3\n");
					virpos = newpos;
				} else
					if( debug )
						fprintf( stderr,"cont3\n");

				if ( !BuildStr( &virpos, &newpos ) )
					return Foo( -10 );
				plotted = true;
				virpos = newpos;
				continue;
			
			case 'l':	/* line */
			case 'm':	/* move */
				if ( !GetCoords( &newpos ) )
					return Foo( -8 );
				virpos = newpos;
				if ( c == 'm' )  {
					if( debug )
						fprintf( stderr,"move\n");
					continue;
				}
				/* line: fall through */
				if( debug )
					fprintf( stderr,"line\n");

			case 'n':	/* cont */
			case 'p':	/* point */
				if ( !GetCoords( &newpos ) )
					return Foo( -9 );
				if ( c == 'p' )  {
					if( debug )
						fprintf( stderr,"point\n");
					virpos = newpos;
				} else
					if( debug )
						fprintf( stderr,"cont\n");

				if ( !BuildStr( &virpos, &newpos ) )
					return Foo( -10 );
				plotted = true;
				virpos = newpos;
				continue;

			/* IEEE */
			case 'V':
			case 'O':
				if ( !Get3DCoords( &newpos ) )
					return Foo( -8 );
				virpos = newpos;
				if( c == 'O'  )  {
					if( debug )
						fprintf( stderr,"dMove3\n");
					continue;
				}
				if( debug )
					fprintf( stderr,"dLine3\n");

			case 'Q':	/* continue3 */
			case 'X':	/* point3 */
				if ( !Get3DCoords( &newpos ) )
					return Foo( -9 );
				if ( c == 'X' )  {
					if( debug )
						fprintf( stderr,"dpoint3\n");
					virpos = newpos;
				} else
					if( debug )
						fprintf( stderr,"dcont3\n");

				if ( !BuildStr( &virpos, &newpos ) )
					return Foo( -10 );
				plotted = true;
				virpos = newpos;
				continue;
			
			case 'v':	/* line */
			case 'o':	/* move */
				if ( !GetDCoords( &newpos ) )
					return Foo( -8 );
				virpos = newpos;
				if ( c == 'o' )  {
					if( debug )
						fprintf( stderr,"dmove\n");
					continue;
				}
				/* line: fall through */
				if( debug )
					fprintf( stderr,"dline\n");

			case 'q':	/* cont */
			case 'x':	/* point */
				if ( !GetDCoords( &newpos ) )
					return Foo( -9 );
				if ( c == 'x' )  {
					if( debug )
						fprintf( stderr,"dpoint\n");
					virpos = newpos;
				} else
					if( debug )
						fprintf( stderr,"dcont\n");

				if ( !BuildStr( &virpos, &newpos ) )
					return Foo( -10 );
				plotted = true;
				virpos = newpos;
				continue;

			case 'W':
				{
				unsigned char	in[6*8];
				double	out[6];
				if( debug )
					fprintf( stderr,"dspace3\n");
				if( fread( in, sizeof(in), 1, pfin) != 1 )
				  	return Foo( -11 );
				ntohd( (unsigned char *)out, in, 5 );
				/* Only need X and Y, ignore Z */
				space.left  = out[0]; /* x1 */
				space.bottom= out[1]; /* y1 */
				/* z1 */
				space.right = out[3]; /* x2 */
				space.top   = out[4]; /* y2 */
				/* z2 */
				goto spacend;
				}
				
			case 'w':	/* space */
				{
				unsigned char	in[4*8];
				double	out[4];
				if( debug )
					fprintf( stderr,"dspace\n");
				if( fread( in, sizeof(in), 1, pfin) != 1 )
				  	return Foo( -11 );
				ntohd( (unsigned char *)out, in, 4 );
				space.left  = out[0]; /* x1 */
				space.bottom= out[1]; /* y1 */
				space.right = out[2]; /* x2 */
				space.top   = out[3]; /* y2 */
				goto spacend;
				}

			case 'S':
				{
				if( debug )
					fprintf( stderr,"space3\n");
				if( fread( (char *)buf3,
					   (int)sizeof buf3, 1, pfin)
					   != 1
				  )
				  	return Foo( -11 );
				/* Only need X and Y, ignore Z */
				space.left  = sxt16((long)(buf3[1]<<8) | buf3[0]); /* x1 */
				space.bottom= sxt16((long)(buf3[3]<<8) | buf3[2]); /* y1 */
				/* z1 */
				space.right = sxt16((long)(buf3[7]<<8) | buf3[6]); /* x2 */
				space.top   = sxt16((long)(buf3[9]<<8) | buf3[8]); /* y2 */
				/* z2 */
				goto spacend;
				}
				
			case 's':	/* space */
				if( debug )
					fprintf( stderr,"space\n");
				{
				if ( fread( (char *)buf2,
					    (int)sizeof buf2, 1, pfin
					  ) != 1
				   )
					return Foo( -11 );
				space.left  = sxt16((long)(buf2[1]<<8) | buf2[0]); /* x1 */
				space.bottom= sxt16((long)(buf2[3]<<8) | buf2[2]); /* y1 */
				space.right = sxt16((long)(buf2[5]<<8) | buf2[4]); /* x2 */
				space.top   = sxt16((long)(buf2[7]<<8) | buf2[6]); /* y2 */
				}

spacend:
				delta = space.right - space.left;
				deltao2 = space.top - space.bottom;
				if ( deltao2 > delta )
					delta = deltao2;
				if( delta <= 0 )  {
					fprintf( stderr, "pl-fb: delta = %g, bad space()\n", delta );
					return Foo( -42 );
				}
				deltao2 = delta / 2.0;
				if( debug )
					fprintf( stderr,"Space: X=(%g,%g) Y=(%g,%g) delta=%g\n",
						space.left, space.right,
						space.bottom, space.top,
						delta );
				continue;

			case 'C':	/* color */
				if( fread( cur_color, 1, 3, pfin) != 3 )
					return Foo( -11 );
				if( debug )
					fprintf( stderr,"Color is R%d G%d B%d\n",
						cur_color[RED],
						cur_color[GRN],
						cur_color[BLU]);
				continue;
						
			case 't':	/* label */
				if( debug )
					fprintf( stderr,"label: ");

				newpos = virpos;			
				while ( (c = getc( pfin )) != EOF && c != '\n'
				      )  {
					/* vectorize the characters */
					put_vector_char( c, &newpos);
				
					if( debug )
						putc( c, stderr );
				      }

				plotted = true;
				virpos = newpos;
				continue;

			/* discard the deadwood */
			case 'c':
				{
				char buf[3*2];
				if( fread(buf, sizeof(buf), 1, pfin) != 1 )
					return Foo( -11 );
				if( debug )
					fprintf( stderr,"circle ignored\n" );
				continue;
				}
			case 'i':
				{
				char buf[3*8];
				if( fread(buf, sizeof(buf), 1, pfin) != 1 )
					return Foo( -11 );
				if( debug )
					fprintf( stderr,"d_circle ignored\n" );
				continue;
				}
			case 'a':
				{
				char buf[6*2];
				if( fread(buf, sizeof(buf), 1, pfin) != 1 )
					return Foo( -11 );
				if( debug )
					fprintf( stderr,"arc ignored\n" );
				continue;
				}
			case 'r':
				{
				char buf[6*8];
				if( fread(buf, sizeof(buf), 1, pfin) != 1 )
					return Foo( -11 );
				if( debug )
					fprintf( stderr,"d_arc ignored\n" );
				continue;
				}

			default:
				fprintf( stderr,"bad command '%c' (0x%02x)\n", c, c );
					
				return Foo( -12 );	/* bad input */
			}
			break;
		}		/* next input record */
	}			/* next frame */
}

/*
 *	PutVectorChar - Put vectors corresponding to this character out
 * 	into plotting space
 *	Update position to reflect character width.
 */
void
put_vector_char(register char c, register coords *pos)
{
	static coords	start, end;
	register struct vectorchar	*vc;
	register struct relvect		*rv;

	if( !isascii(c) )
		c = '?';
	if( islower(c) )
		c = toupper(c);
	
	for( vc = &charset[0]; vc->ascii; vc++)
		if( vc->ascii == c )
			break;

	if( !vc->ascii )  {
		/* Character not found in table -- space over 1/2 char */
		pos->x += X_CHAR_SIZE/2;
		return;
	}

	/* have the correct character entry - start plotting */
	start.x = vc->r[0].x + pos->x;
	start.y = Y_CHAR_SIZE - vc->r[0].y + pos->y;

	for( rv = &vc->r[1]; (rv < &vc->r[10]) && rv->x >= 0; rv++ )  {
		end.x = rv->x + pos->x;
		end.y = Y_CHAR_SIZE - rv->y + pos->y;
		edgelimit( &start );
		edgelimit( &end );
		BuildStr( &start, &end );	/* pixels */
		start = end;
	}
	pos->x += X_CHAR_SIZE;
}

/*
 *	E D G E L I M I T
 *
 *	Limit generated positions to edges of screen
 */
void
edgelimit(register coords *ppos)
{
	if( ppos->x >= Npixels )
		ppos->x = Npixels -1;

	if( ppos->y >= Nscanlines )
		ppos->y = Nscanlines -1;
}

/*
	GetCoords - input x,y coordinates and scale into pixels
*/
bool Get3Coords(register coords *coop)
{
	char	trash[2];
	register bool	ret;

	ret = GetCoords( coop );
	fread( trash, sizeof(trash), 1, pfin );
	return( ret );
}

STATIC bool
GetCoords(register coords *coop)
               	      		/* -> input coordinates */
{
	unsigned char buf[4];
	double	x, y;

	/* read coordinates */
	if ( fread( (char *)buf, (int)sizeof (buf), 1, pfin ) != 1 )
		return false;


	x = sxt16((long)(buf[1]<<8) | buf[0]);
	y = sxt16((long)(buf[3]<<8) | buf[2]);
	if( debug )  fprintf(stderr,"Coord: (%g,%g) ", x, y);

	/* limit left, bottom */
	if ( (x -= space.left) < 0 )
		x = 0;
	if ( (y -= space.bottom) < 0 )
		y = 0;

	/* convert to device pixels */
	coop->x = (short)(x * Npixels / (double)delta + 0.5);
	coop->y = (short)(y * Nscanlines / (double)delta + 0.5);

	/* limit right, top */
	if ( coop->x > XMAX )
		coop->x = XMAX;
	if ( coop->y > YMAX )
		coop->y = YMAX;

	if( debug )
		fprintf( stderr,"Pixel: (%d,%d)\n", coop->x, coop->y);
		
	return true;
}

/* IEEE coordinates */
bool Get3DCoords(register coords *coop)
{
	static unsigned char in[3*8];
	static double	out[2];
	register double	x,y;

	/* read coordinates */
	if ( fread( in, sizeof(in), 1, pfin ) != 1 )
		return false;
	ntohd( (unsigned char *)out, in, 2 );
	x = out[0];
	y = out[1];

	/* limit left, bottom */
	if ( (x -= space.left) < 0 )
		x = 0;
	if ( (y -= space.bottom) < 0 )
		y = 0;

	/* convert to device pixels */
	coop->x = (short)(x * Npixels / (double)delta + 0.5);
	coop->y = (short)(y * Nscanlines / (double)delta + 0.5);

	/* limit right, top */
	if ( coop->x > XMAX )
		coop->x = XMAX;
	if ( coop->y > YMAX )
		coop->y = YMAX;

	if( debug )  {
		fprintf(stderr,"Coord3: (%g,%g) ", out[0], out[1]);
		fprintf(stderr,"Pixel3: (%d,%d)\n", coop->x, coop->y);
	}
	return( true );
}

bool
GetDCoords(register coords *coop)
               	      		/* -> input coordinates */
{
	static unsigned char	in[2*8];
	static double	out[2];
	register double	x,y;

	/* read coordinates */
	if ( fread( in, sizeof(in), 1, pfin ) != 1 )
		return false;
	ntohd( (unsigned char *)out, in, 2 );
	x = out[0];
	y = out[1];

	/* limit left, bottom */
	if ( (x -= space.left) < 0 )
		x = 0;
	if ( (y -= space.bottom) < 0 )
		y = 0;

	/* convert to device pixels */
	coop->x = (short)(x * Npixels / (double)delta + 0.5);
	coop->y = (short)(y * Nscanlines / (double)delta + 0.5);

	/* limit right, top */
	if ( coop->x > XMAX )
		coop->x = XMAX;
	if ( coop->y > YMAX )
		coop->y = YMAX;

	if( debug )  {
		fprintf(stderr,"Coord2: (%g,%g) ", out[0], out[1]);
		fprintf(stderr,"Pixel2: (%d,%d)\n", coop->x, coop->y);
	}
	return true;
}

/*
	InitDesc - initialize stroke descriptor lists
*/

STATIC void
InitDesc(void)
{
	register struct band *bp;	/* *bp -> start of descr list */

	for ( bp = &band[0]; bp < &band[BANDSLOP]; ++bp )  {
		bp->first = NULL;		/* nothing in band yet */
		bp->last  = NULL;
	}
}


/*
 * 	Requeue - enqueue descriptor at END of band list
 */
STATIC void
Requeue(register struct band *bp, register stroke *vp)
{
	CK_STROKE(vp);
	vp->next = NULL;
	if( bp->last )
		bp->last->next = vp;
	else
		bp->first = vp;
		
	bp->last = vp;
}

/*
 *	Dequeue - remove descriptor from band list (do not free space)
 *
 *  Returns addr of descriptor, or NULL if none left.
 */
STATIC stroke *
Dequeue(register struct band *bp, register stroke **hp)
                         
                     		/* *hp -> first descr in list */
{
	register stroke *vp;		/* -> descriptor */

	if ( (vp = *hp) != NULL )
		*hp = vp->next; 	/* -> next element in list */

	if( vp == NULL )
		bp->last = NULL;
		
	return vp;			/* may be NULL */
}


/*
	FreeUp - deallocate descriptors
*/

STATIC void
FreeUp(void)
{
	register struct band *bp;
	register stroke *vp;		/* -> rasterization descr */

	for ( bp = &band[0]; bp < bandEnd; ++bp )
		while ( (vp = Dequeue( bp, &bp->first )) != NULL )
			FREE_STROKE(vp);	/* free storage */
	}

/*
 *			P R E P _ D D A
 *
 *  Set up multi-band DDA parameters for stroke
 */
STATIC void
prep_dda(register stroke *vp, register coords *pt1, register coords *pt2)
{
	CK_STROKE(vp);
	vp->pixel = *pt1;		/* initial pixel */
	vp->major = pt2->y - vp->pixel.y;	/* always nonnegative */
	vp->ysign = vp->major ? 1 : 0;
	vp->minor = pt2->x - vp->pixel.x;
	COPYRGB( vp->col, cur_color );
	if ( (vp->xsign = vp->minor ? (vp->minor > 0 ? 1 : -1) : 0) < 0 )
		vp->minor = -vp->minor;

	/* if Y is not really major, correct the assignments */
	if ( !(vp->ymajor = vp->minor <= vp->major) )  {
		register short	temp;	/* temporary for swap */

		temp = vp->minor;
		vp->minor = vp->major;
		vp->major = temp;
	}

	vp->e = vp->major / 2 - vp->minor;	/* initial DDA error */
	vp->de = vp->major - vp->minor;
}

/*
 *	BuildStr - set up DDA parameters and queue stroke
 *
 *  Given two end points of a line, allocate and intialize a stroke
 *  descriptor for it.  If we are drawing "thick" lines we generate
 *  several extra stroke descriptors as well.  In immediate or memory
 *  buffered mode we rasterize it and free it right away.  In "regular"
 *  banded buffered mode, we link the descriptor(s) into its starting
 *  point band(s).
 */
STATIC bool
BuildStr(coords *pt1, coords *pt2)		/* returns true or dies */
      	           		/* endpoints */
{
	register stroke *vp;		/* -> rasterization descr */
	register int	thick;

	/* arrange for pt1 to have the smaller Y-coordinate: */
	if ( pt1->y > pt2->y )  {
		register coords *temp;	/* temporary for swap */

		temp = pt1;		/* swap pointers */
		pt1 = pt2;
		pt2 = temp;
	}

	GET_STROKE(vp);			/* alloc a descriptor */
	prep_dda( vp, pt1, pt2 );	/* prep it */

	/* Thicken by advancing alternating pixels in minor direction */
	thick = line_thickness - 1;	/* number of "extra" pixels */
	if( thick >= vp->major && vp->major > 0 )  thick = vp->major-1;
	for( ; thick >= 0; thick-- )  {
		register stroke *v2;

		if( thick == 0 ) {
			/* last pass, use vp */
			v2 = vp;
		} else {
			/* make a new one */
			GET_STROKE(v2);
			*v2 = *vp;
		}

		/* Advance minor only */
		if( vp->ymajor )
			v2->pixel.x += (vp->xsign!=0 ? vp->xsign : 1) *
				((thick&1)==0 ? (thick+1)/2 : (thick+1)/-2 );
		else
			v2->pixel.y += (vp->ysign!=0 ? vp->ysign : 1) *
				((thick&1)==0 ? (thick+1)/2 : (thick+1)/-2 );

		if( immediate || single_banded )  {
			ystart = 0;
			Raster( v2, (struct band *)0 );
		}  else
			/* link descriptor into band corresponding to starting scan */
			Requeue( &band[v2->pixel.y / lines_per_band], v2 );
	}
	return true;
}

/*
 *	OutBuild - rasterize all strokes into raster frame image
 */
STATIC bool
OutBuild(void)				/* returns true if successful */
{
	register struct band *hp;	/* *hp -> head of descr list */
	register struct band *np;	/* `hp' for next band */
	register stroke *vp;		/* -> rasterization descr */

	if( single_banded ) {
		if( debug ) fprintf(stderr,"OutBuild:  band y=%d\n", ystart);
		if( fb_write( fbp, 0, ystart, buffer, buffersize/sizeof(RGBpixel) ) <= 0 )
			return false;	/* can't write image file */
		if( over )  {
			/* Read back the composite image */
			if( fb_read( fbp, 0, ystart, buffer, buffersize/sizeof(RGBpixel) ) <= 0 )
				fprintf(stderr,"pl-fb:  band read error\n");
		}
		return true;
	}

	for ( hp = &band[0]; hp < bandEnd; ++hp )
		if ( hp->first != NULL )
			break;

	if ( hp == bandEnd )
		return true;		/* nothing to do */

	for ( hp = &band[0], np = &band[1], ystart = 0;
	      hp < bandEnd;
	      hp = np++, ystart += lines_per_band
	    )	{
	    	if(debug) fprintf(stderr,"OutBuild:  band y=%d\n", ystart);
	    	if( over )  {
	    		/* Read in current band */
		    	if( fb_read( fbp, 0, ystart, buffer, buffersize/sizeof(RGBpixel) ) <= 0 )
	    			fprintf(stderr,"pl-fb:  band read error\n");
	    	} else {
			/* clear pixels in the band */
			bzero( (char *)buffer, buffersize );
	    	}

		while ( (vp = Dequeue( hp, &hp->first )) != NULL )
			Raster( vp, np );      /* rasterize stroke */

		/* Raster() either re-queued the descriptor onto the
		   next band list or else it freed the descriptor */

	    	if(debug) fprintf(stderr,"OutBuild:  fbwrite y=%d\n", ystart);
	    	if( fb_write( fbp, 0, ystart, buffer, buffersize/sizeof(RGBpixel) ) <= 0 )
			return false;	/* can't write image file */
	}

	return true;			/* success */
}

/*
 *	Raster - rasterize stroke.
 *
 *  If immediate mode, draw the individual pixel on the frame buffer.
 *  If banded buffered mode, draw the portion in this band.  If it
 *     overflows into next band, requeue; else free the descriptor.
 *
 *  Method:
 *	Modified Bresenham algorithm.  Guaranteed to mark a dot for
 *	a zero-length stroke.  Please do not try to "improve" this code
 *	as it is extremely hard to get all aspects just right.
 */
STATIC void
Raster(register stroke *vp, register struct band *np)
                    		/* -> rasterization descr */
                         	/* *np -> next band 1st descr */
{
	register short	dy;		/* raster within active band */

	CK_STROKE(vp);

	/*
	 *  Draw the portion within this band.
	 */
	for ( dy = vp->pixel.y - ystart; dy < lines_per_band; ) {

		/* set the appropriate pixel in the buffer */
		if( immediate )  {
			fb_write( fbp, vp->pixel.x, dy, vp->col, 1 );
		}  else  {
			register unsigned char *pp;

			pp = (unsigned char *)&buffer[((dy*Npixels) + vp->pixel.x)*sizeof(RGBpixel)];
			COPYRGB( pp, vp->col );
		}

		if ( vp->major-- == 0 ) { /* done! */
			FREE_STROKE( vp );	/* return to "malloc" */
			return;
		}

		if ( vp->e < 0 ) {
			/* advance major & minor */
			dy += vp->ysign;
			vp->pixel.x += vp->xsign;
			vp->e += vp->de;
		} else {
			/* advance major only */
			if ( vp->ymajor )	/* Y is major dir */
				++dy;
			else			/* X is major dir */
				vp->pixel.x += vp->xsign;
			vp->e -= vp->minor;
		}
	}

	/* overflow into next band; re-queue */
	vp->pixel.y = ystart + lines_per_band;
	Requeue( np, vp );       /* DDA parameters already set */
}

/*
	Foo - clean up before return from rasterizer
*/

STATIC int
Foo(int code)				/* returns status code */
	   	     			/* status code */
	{
	if( debug ) fprintf(stderr,"Foo(%d)\n", code);
	fb_close( fbp );		/* release framebuffer */

	FreeUp();			/* deallocate descriptors */

	return code;
	}

/*
	SetSigs - set up signal catchers
*/
STATIC void
SetSigs(void)
{
	register int	*psig;		/* -> sigs[.] */

	for ( psig = &sigs[0];
	      psig < &sigs[sizeof sigs / sizeof sigs[0]];
	      ++psig
	    )
		if ( signal( *psig, SIG_IGN ) != SIG_IGN )
			(void)signal( *psig, Catch );
	}


/*
	Catch - invoked on interrupt
*/

STATIC void
Catch(register int sig)
	            	    		/* signal number */
	{
	register int	pid;		/* this process's ID */
	register int	*psig;		/* -> sigs[.] */

	for ( psig = &sigs[0];
	      psig < &sigs[sizeof sigs / sizeof sigs[0]];
	      ++psig
	    )
		(void)signal( *psig, SIG_IGN );

	(void)Foo( -13 );		/* clean up */

	(void)signal( sig, SIG_DFL );

	if ( (pid = getpid()) > 1 )
		(void)kill( pid, sig ); /* resignal process */
	}
@


11.11
log
@change conf.h to a wrapped config.h
@
text
@d63 1
a63 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/fb/pl-fb.c,v 11.10 2004/04/05 07:49:23 morrison Exp $ (BRL)";
@


11.10
log
@merge of ansi-6-0-branch into HEAD
@
text
@d63 1
a63 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d66 5
a70 1
#include "conf.h"
@


11.9
log
@update copyright to include span through 2003
@
text
@d63 1
a63 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/pl-fb.c,v 11.8 2002/08/20 17:07:25 jra Exp $ (BRL)";
d302 12
a313 12
STATIC int	DoFile(), Foo();
STATIC stroke	*Dequeue();
STATIC bool	BuildStr(), GetCoords(),
		OutBuild();
STATIC void	Catch(), FreeUp(), InitDesc(), Requeue(),
		Raster(), SetSigs();

void		edgelimit(), put_vector_char();

bool	Get3Coords();
bool	Get3DCoords();
bool	GetDCoords();
d327 1
a327 1
get_strokes()
d373 1
a373 2
sxt16( v )
register long v;
d383 1
a383 2
get_args( argc, argv )
register char **argv;
d464 1
a464 3
main(argc, argv)
int	argc;
char	**argv;
d545 1
a545 1
DoFile( )	/* returns vpl status code */
d917 1
a917 3
put_vector_char( c, pos )
register char	c;
register coords	*pos;
d959 1
a959 2
edgelimit( ppos )
register coords *ppos;
d971 1
a971 2
bool Get3Coords( coop )
register coords	*coop;
d982 2
a983 2
GetCoords( coop )
register coords	*coop;		/* -> input coordinates */
d1020 1
a1020 2
bool Get3DCoords( coop )
register coords	*coop;
d1057 2
a1058 2
GetDCoords( coop )
register coords	*coop;		/* -> input coordinates */
d1099 1
a1099 1
InitDesc()
d1114 1
a1114 3
Requeue( bp, vp )
register struct band *bp;
register stroke	     *vp;
d1132 3
a1134 3
Dequeue( bp, hp )
register struct band *bp;
register stroke **hp;		/* *hp -> first descr in list */
d1153 2
a1154 2
FreeUp()
	{
d1169 1
a1169 3
prep_dda( vp, pt1, pt2 )
register stroke	*vp;
register coords	*pt1, *pt2;
d1204 2
a1205 2
BuildStr( pt1, pt2 )		/* returns true or dies */
coords	*pt1, *pt2;		/* endpoints */
d1259 1
a1259 1
OutBuild()				/* returns true if successful */
d1325 3
a1327 3
Raster( vp, np )
register stroke *vp;		/* -> rasterization descr */
register struct band *np;	/* *np -> next band 1st descr */
d1378 2
a1379 2
Foo( code )				/* returns status code */
	int	code;			/* status code */
d1393 2
a1394 2
SetSigs()
	{
d1411 2
a1412 2
Catch( sig )
	register int	sig;		/* signal number */
@


11.8
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d59 1
a59 1
 *	This software is Copyright (C) 1986 by the United States Army.
d63 1
a63 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/pl-fb.c,v 11.6 2001/04/12 17:44:08 bparker Exp $ (BRL)";
@


11.8.4.1
log
@sync to HEAD...
@
text
@d59 1
a59 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d63 1
a63 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/fb/pl-fb.c,v 11.9 2004/02/02 17:39:01 morrison Exp $ (BRL)";
@


11.8.10.1
log
@merge from HEAD
@
text
@d59 1
a59 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d63 1
a63 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/pl-fb.c,v 11.9 2004/02/02 17:39:01 morrison Exp $ (BRL)";
@


11.8.10.2
log
@merge from head
@
text
@d63 1
a63 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/pl-fb.c,v 11.8.10.1 2004/02/12 19:40:46 erikg Exp $ (BRL)";
@


11.8.2.1
log
@Initial ANSIfication
@
text
@d63 1
a63 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/pl-fb.c,v 11.8 2002/08/20 17:07:25 jra Exp $ (BRL)";
d302 12
a313 12
STATIC int	DoFile(void), Foo(int code);
STATIC stroke	*Dequeue(register struct band *bp, register stroke **hp);
STATIC bool	BuildStr(coords *pt1, coords *pt2), GetCoords(register coords *coop),
		OutBuild(void);
STATIC void	Catch(register int sig), FreeUp(void), InitDesc(void), Requeue(register struct band *bp, register stroke *vp),
		Raster(register stroke *vp, register struct band *np), SetSigs(void);

void		edgelimit(register coords *ppos), put_vector_char(register char c, register coords *pos);

bool	Get3Coords(register coords *coop);
bool	Get3DCoords(register coords *coop);
bool	GetDCoords(register coords *coop);
d327 1
a327 1
get_strokes(void)
d373 2
a374 1
sxt16(register long int v)
d384 2
a385 1
get_args(int argc, register char **argv)
d466 3
a468 1
main(int argc, char **argv)
d549 1
a549 1
DoFile(void)	/* returns vpl status code */
d921 3
a923 1
put_vector_char(register char c, register coords *pos)
d965 2
a966 1
edgelimit(register coords *ppos)
d978 2
a979 1
bool Get3Coords(register coords *coop)
d990 2
a991 2
GetCoords(register coords *coop)
               	      		/* -> input coordinates */
d1028 2
a1029 1
bool Get3DCoords(register coords *coop)
d1066 2
a1067 2
GetDCoords(register coords *coop)
               	      		/* -> input coordinates */
d1108 1
a1108 1
InitDesc(void)
d1123 3
a1125 1
Requeue(register struct band *bp, register stroke *vp)
d1143 3
a1145 3
Dequeue(register struct band *bp, register stroke **hp)
                         
                     		/* *hp -> first descr in list */
d1164 2
a1165 2
FreeUp(void)
{
d1180 3
a1182 1
prep_dda(register stroke *vp, register coords *pt1, register coords *pt2)
d1217 2
a1218 2
BuildStr(coords *pt1, coords *pt2)		/* returns true or dies */
      	           		/* endpoints */
d1272 1
a1272 1
OutBuild(void)				/* returns true if successful */
d1338 3
a1340 3
Raster(register stroke *vp, register struct band *np)
                    		/* -> rasterization descr */
                         	/* *np -> next band 1st descr */
d1391 2
a1392 2
Foo(int code)				/* returns status code */
	   	     			/* status code */
d1406 2
a1407 2
SetSigs(void)
{
d1424 2
a1425 2
Catch(register int sig)
	            	    		/* signal number */
@


11.8.2.2
log
@sync branch with HEAD
@
text
@d59 1
a59 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d63 1
a63 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.7
log
@Converted from K&R to ANSI C - RFH
@
text
@d302 12
a313 12
STATIC int	DoFile(void), Foo(int code);
STATIC stroke	*Dequeue(register struct band *bp, register stroke **hp);
STATIC bool	BuildStr(coords *pt1, coords *pt2), GetCoords(register coords *coop),
		OutBuild(void);
STATIC void	Catch(register int sig), FreeUp(void), InitDesc(void), Requeue(register struct band *bp, register stroke *vp),
		Raster(register stroke *vp, register struct band *np), SetSigs(void);

void		edgelimit(register coords *ppos), put_vector_char(register char c, register coords *pos);

bool	Get3Coords(register coords *coop);
bool	Get3DCoords(register coords *coop);
bool	GetDCoords(register coords *coop);
d327 1
a327 1
get_strokes(void)
d373 2
a374 1
sxt16(register long int v)
d384 2
a385 1
get_args(int argc, register char **argv)
d466 3
a468 1
main(int argc, char **argv)
d549 1
a549 1
DoFile(void)	/* returns vpl status code */
d921 3
a923 1
put_vector_char(register char c, register coords *pos)
d965 2
a966 1
edgelimit(register coords *ppos)
d978 2
a979 1
bool Get3Coords(register coords *coop)
d990 2
a991 2
GetCoords(register coords *coop)
               	      		/* -> input coordinates */
d1028 2
a1029 1
bool Get3DCoords(register coords *coop)
d1066 2
a1067 2
GetDCoords(register coords *coop)
               	      		/* -> input coordinates */
d1108 1
a1108 1
InitDesc(void)
d1123 3
a1125 1
Requeue(register struct band *bp, register stroke *vp)
d1143 3
a1145 3
Dequeue(register struct band *bp, register stroke **hp)
                         
                     		/* *hp -> first descr in list */
d1164 2
a1165 2
FreeUp(void)
{
d1180 3
a1182 1
prep_dda(register stroke *vp, register coords *pt1, register coords *pt2)
d1217 2
a1218 2
BuildStr(coords *pt1, coords *pt2)		/* returns true or dies */
      	           		/* endpoints */
d1272 1
a1272 1
OutBuild(void)				/* returns true if successful */
d1338 3
a1340 3
Raster(register stroke *vp, register struct band *np)
                    		/* -> rasterization descr */
                         	/* *np -> next band 1st descr */
d1391 2
a1392 2
Foo(int code)				/* returns status code */
	   	     			/* status code */
d1406 2
a1407 2
SetSigs(void)
{
d1424 2
a1425 2
Catch(register int sig)
	            	    		/* signal number */
@


11.6
log
@*- get rid of warnings
@
text
@d63 1
a63 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/pl-fb.c,v 11.5 2000/08/24 03:58:34 mike Exp $ (BRL)";
d302 12
a313 12
STATIC int	DoFile(), Foo();
STATIC stroke	*Dequeue();
STATIC bool	BuildStr(), GetCoords(),
		OutBuild();
STATIC void	Catch(), FreeUp(), InitDesc(), Requeue(),
		Raster(), SetSigs();

void		edgelimit(), put_vector_char();

bool	Get3Coords();
bool	Get3DCoords();
bool	GetDCoords();
d327 1
a327 1
get_strokes()
d373 1
a373 2
sxt16( v )
register long v;
d383 1
a383 2
get_args( argc, argv )
register char **argv;
d464 1
a464 3
main(argc, argv)
int	argc;
char	**argv;
d545 1
a545 1
DoFile( )	/* returns vpl status code */
d917 1
a917 3
put_vector_char( c, pos )
register char	c;
register coords	*pos;
d959 1
a959 2
edgelimit( ppos )
register coords *ppos;
d971 1
a971 2
bool Get3Coords( coop )
register coords	*coop;
d982 2
a983 2
GetCoords( coop )
register coords	*coop;		/* -> input coordinates */
d1020 1
a1020 2
bool Get3DCoords( coop )
register coords	*coop;
d1057 2
a1058 2
GetDCoords( coop )
register coords	*coop;		/* -> input coordinates */
d1099 1
a1099 1
InitDesc()
d1114 1
a1114 3
Requeue( bp, vp )
register struct band *bp;
register stroke	     *vp;
d1132 3
a1134 3
Dequeue( bp, hp )
register struct band *bp;
register stroke **hp;		/* *hp -> first descr in list */
d1153 2
a1154 2
FreeUp()
	{
d1169 1
a1169 3
prep_dda( vp, pt1, pt2 )
register stroke	*vp;
register coords	*pt1, *pt2;
d1204 2
a1205 2
BuildStr( pt1, pt2 )		/* returns true or dies */
coords	*pt1, *pt2;		/* endpoints */
d1259 1
a1259 1
OutBuild()				/* returns true if successful */
d1325 3
a1327 3
Raster( vp, np )
register stroke *vp;		/* -> rasterization descr */
register struct band *np;	/* *np -> next band 1st descr */
d1378 2
a1379 2
Foo( code )				/* returns status code */
	int	code;			/* status code */
d1393 2
a1394 2
SetSigs()
	{
d1411 2
a1412 2
Catch( sig )
	register int	sig;		/* signal number */
@


11.5
log
@
const RCSid
@
text
@d63 1
a63 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/pl-fb.c,v 11.4 1999/01/15 05:53:19 mike Exp $ (BRL)";
d76 5
d212 43
a254 43
   '0', 5,0,   1,0,   0,1,   0,7,   6,1,   6,7,   5,8,   1,8,   END,   NIL,
   '1', 1,2,   3,0,   3,8,   5,8,   1,8,   END,   NIL,   NIL,   NIL,   NIL,
   '2', 0,1,   1,0,   5,0,   6,1,   6,2,   4,4,   2,4,   0,6,   0,8,   6,8,
   '3', 1,0,   5,0,   6,1,   6,4,   2,4,   6,4,   6,7,   5,8,   1,8,   END,
   '4', 5,8,   5,0,   0,5,   0,6,   6,6,   END,   NIL,   NIL,   NIL,   NIL,
   '5', 6,0,   0,0,   0,3,   4,3,   6,5,   6,6,   4,8,   1,8,   0,7,   END,
   '6', 5,0,   2,0,   0,2,   0,7,   1,8,   5,8,   6,7,   6,5,   5,4,   1,4,
   '7', 0,1,   0,0,   6,0,   6,1,   2,5,   2,8,   END,   NIL,   NIL,   NIL,
   '8', 1,0,   5,0,   6,1,   6,7,   5,8,   1,8,   0,7,   0,1,   0,4,   6,4,
   '9', 1,8,   4,8,   6,6,   6,1,   5,0,   1,0,   0,1,   0,3,   1,4,   6,4,
   'A', 0,8,   0,2,   2,0,   4,0,   6,2,   6,8,   6,5,   0,5,   END,   NIL,
   'B', 6,5,   6,7,   5,8,   0,8,   0,0,   5,0,   6,1,   6,3,   5,4,   0,4,
   'C', 6,1,   5,0,   2,0,   0,2,   0,6,   2,8,   5,8,   6,7,   END,   NIL,
   'D', 0,0,   4,0,   6,2,   6,6,   4,8,   0,8,   0,0,   END,   NIL,   NIL,
   'E', 6,0,   0,0,   0,4,   3,4,   0,4,   0,8,   6,8,   END,   NIL,   NIL,
   'F', 6,0,   0,0,   0,4,   3,4,   0,4,   0,8,   END,   NIL,   NIL,   NIL,
   'G', 6,1,   5,0,   2,0,   0,2,   0,6,   2,8,   5,8,   6,7,   6,5,   3,5,
   'H', 0,0,   0,8,   0,4,   6,4,   6,0,   6,8,   END,   NIL,   NIL,   NIL,
   'I', 1,0,   5,0,   3,0,   3,8,   1,8,   5,8,   END,   NIL,   NIL,   NIL,
   'J', 2,0,   6,0,   4,0,   4,7,   3,8,   1,8,   0,7,   END,   NIL,   NIL,
   'K', 0,0,   0,8,   0,6,   6,0,   2,4,   6,8,   END,   NIL,   NIL,   NIL,
   'L', 0,0,   0,8,   6,8,   END,   NIL,   NIL,   NIL,   NIL,   NIL,   NIL,
   'M', 0,8,   0,0,   3,3,   3,4,   3,3,   6,0,   6,8,   END,   NIL,   NIL,
   'N', 0,8,   0,0,   6,6,   6,8,   6,0,   END,   NIL,   NIL,   NIL,   NIL,
   'O', 0,6,   0,2,   2,0,   4,0,   6,2,   6,6,   4,8,   2,8,   0,6,   END,
   'P', 0,8,   0,0,   5,0,   6,1,   6,3,   5,4,   0,4,   END,   NIL,   NIL,
   'Q', 6,6,   6,2,   4,0,   2,0,   0,2,   0,6,   2,8,   4,8,   4,6,   6,8,
   'R', 0,8,   0,0,   5,0,   6,1,   6,3,   5,4,   0,4,   2,4,   6,8,   END,
   'S', 6,1,   5,0,   1,0,   0,1,   0,4,   5,4,   6,5,   6,7,   5,8,   0,8,
   'T', 0,0,   6,0,   3,0,   3,8,   END,   NIL,   NIL,   NIL,   NIL,   NIL,
   'U', 0,0,   0,7,   1,8,   5,8,   6,7,   6,0,   END,   NIL,   NIL,   NIL,
   'V', 0,0,   0,2,   3,8,   6,2,   6,0,   END,   NIL,   NIL,   NIL,   NIL,
   'W', 0,0,   0,8,   3,5,   3,4,   3,5,   6,8,   6,0,   END,   NIL,   NIL,
   'X', 0,0,   6,8,   3,4,   0,8,   6,0,   END,   NIL,   NIL,   NIL,   NIL,
   'Y', 0,0,   0,1,   3,4,   3,8,   3,4,   6,1,   6,0,   END,   NIL,   NIL,
   'Z', 0,0,   6,0,   6,1,   0,7,   0,8,   6,8,   END,   NIL,   NIL,   NIL,
   '+', 0,4,   6,4,   3,4,   3,1,   3,7,   END,   NIL,   NIL,   NIL,   NIL,
   '-', 0,4,   6,4,   END,   NIL,   NIL,   NIL,   NIL,   NIL,   NIL,   NIL,
   '/', 0,7,   6,1,   END,   NIL,   NIL,   NIL,   NIL,   NIL,   NIL,   NIL,
   '(', 4,0,   2,2,   2,6,   4,8,   END,   NIL,   NIL,   NIL,   NIL,   NIL,
   ')', 2,0,   4,2,   4,6,   2,8,   END,   NIL,   NIL,   NIL,   NIL,   NIL,
   '<', 4,0,   0,4,   4,8,   END,   NIL,   NIL,   NIL,   NIL,   NIL,   NIL,
   '>', 2,0,   6,4,   2,8,   END,   NIL,   NIL,   NIL,   NIL,   NIL,   NIL,
d257 2
a258 2
   '.', 4,7,   3,7,   3,6,   4,6,   4,7,   END,   NIL,   NIL,   NIL,   NIL,
   ',', 4,6,   3,6,   3,5,   4,5,   4,8,   END,   NIL,   NIL,   NIL,   NIL,
d260 1
a260 1
   '\0'
d311 4
d383 1
d465 1
@


11.4
log
@Fixed type problems in calls to htond()
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/pl-fb.c,v 11.3 1998/09/22 02:46:35 mike Exp $ (BRL)";
@


11.3
log
@Fixed printf() arg type.
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/pl-fb.c,v 11.2 1996/07/16 22:05:28 jra Exp $ (BRL)";
d744 1
a744 1
				char	in[6*8];
d750 1
a750 1
				ntohd( out, in, 5 );
d763 1
a763 1
				char	in[4*8];
d769 1
a769 1
				ntohd( out, in, 4 );
d1020 1
a1020 1
	static char	in[3*8];
d1027 1
a1027 1
	ntohd( out, in, 2 );
d1058 1
a1058 1
	static char	in[2*8];
d1065 1
a1065 1
	ntohd( out, in, 2 );
@


11.2
log
@Minor Mods for IRIX 6.2
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/pl-fb.c,v 11.1 1995/01/04 10:09:42 mike Rel4_4 jra $ (BRL)";
d170 2
a171 2
		fprintf(stderr,"Bad stroke struct, ptr=x%x, magic was x%x, s/b=x%x, at file %s, line %d\n",  \
			(_sp), (_sp)->magic, STROKE_MAGIC,  \
@


11.1
log
@Release_4.4
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/pl-fb.c,v 10.4 94/10/14 08:11:11 jra Exp $ (BRL)";
d787 2
a788 2
				space.left  = sxt16((buf3[1]<<8) | buf3[0]); /* x1 */
				space.bottom= sxt16((buf3[3]<<8) | buf3[2]); /* y1 */
d790 2
a791 2
				space.right = sxt16((buf3[7]<<8) | buf3[6]); /* x2 */
				space.top   = sxt16((buf3[9]<<8) | buf3[8]); /* y2 */
d805 4
a808 4
				space.left  = sxt16((buf2[1]<<8) | buf2[0]); /* x1 */
				space.bottom= sxt16((buf2[3]<<8) | buf2[2]); /* y1 */
				space.right = sxt16((buf2[5]<<8) | buf2[4]); /* x2 */
				space.top   = sxt16((buf2[7]<<8) | buf2[6]); /* y2 */
d990 2
a991 2
	x = sxt16((buf[1]<<8) | buf[0]);
	y = sxt16((buf[3]<<8) | buf[2]);
@


10.4
log
@Buffer was previously converted from (RGBpixel *) to (unsigned char *). I adjusted the subscripting
from buffer[(dy*Npixels) + vp->pixel.x] to buffer[((dy*Npixels) + vp->pixel.x)*sizeof(RGBpixel)].
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/pl-fb.c,v 10.3 1994/08/23 18:49:18 gdurf Exp $ (BRL)";
@


10.3
log
@Added includes, factored ifdefs
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/pl-fb.c,v 10.2 1994/08/11 15:06:18 mike Exp gdurf $ (BRL)";
d1346 1
a1346 1
			pp = (unsigned char *)&buffer[(dy*Npixels) + vp->pixel.x];
@


10.2
log
@Reduced use of RGBpixel
Now use (unsigned char *)
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/pl-fb.c,v 10.1 91/10/12 06:46:46 mike Rel4_0 Locker: mike $ (BRL)";
d66 2
d157 2
@


10.1
log
@Release_4.0
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/pl-fb.c,v 9.5 91/10/11 21:45:28 mike Exp $ (BRL)";
d266 1
a266 1
STATIC RGBpixel	*buffer;		/* ptr to active band buffer */
d493 1
a493 1
	if( (buffer = (RGBpixel *)malloc(buffersize)) == RGBPIXEL_NULL)  {
d1340 1
a1340 1
			register RGBpixel *pp;
d1342 2
a1343 2
			pp = (RGBpixel *)buffer[(dy*Npixels) + vp->pixel.x];
			COPYRGB( *pp, vp->col );
@


9.5
log
@Added multi-level debugging.
Fixed bug where memory was being corrupted in InitDesc -- due to
missing {} on for loop.
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/pl-fb.c,v 9.4 91/09/21 03:41:52 mike Exp Locker: mike $ (BRL)";
@


9.4
log
@It still has a subtle memory corruption bug,
but the cleanups so far are worth saving.
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/pl-fb.c,v 9.3 91/07/22 21:48:35 mike Exp $ (BRL)";
d124 1
d386 2
a387 1
			debug = 1;
d497 2
a498 1
	band = (struct band *)malloc(BANDS*sizeof(struct band));
d503 1
a503 1
	bzero( (char *)band, BANDS*sizeof(struct band) );
d555 3
a557 1
			switch ( c = getc( pfin ) )
d1097 1
a1097 1
	for ( bp = &band[0]; bp < bandEnd; ++bp )
d1100 1
d1330 1
@


9.3
log
@NULL != '\0'
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/pl-fb.c,v 9.2 91/01/12 08:54:03 mike Exp $ (BRL)";
d66 5
a70 1
#define STATIC	/* nothing, for debugging */
d148 1
d161 1
d163 8
d309 1
a309 1
struct descr	*freep = STROKE_NULL;	/* head of free stroke list */
d333 1
d343 1
d347 1
d958 1
a958 1
STATIC bool Get3Coords( coop )
d1008 1
a1008 1
STATIC bool Get3DCoords( coop )
d1045 1
a1045 1
STATIC bool
d1106 1
d1163 1
d1323 1
@


9.2
log
@externs.h
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pl-fb.c,v 9.1 89/05/19 06:11:05 mike Rel3_5 $ (BRL)";
d236 1
a236 1
   NULL
@


9.1
log
@Release_3.5
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: pl-fb.c,v 8.1 88/10/05 00:43:32 mike Rel3_0 $ (BRL)";
d73 2
a272 4
extern void	free();
extern char	*malloc();
extern int	close(), creat(), getpid(), kill(), open(), read(),
		write();
a350 4

extern int	getopt();
extern char	*optarg;
extern int	optind;
@


8.1
log
@Release_3.0
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: pl-fb.c,v 7.11 88/09/17 03:38:28 mike Exp $ (BRL)";
@


7.11
log
@Included machine.h to get SYSV defines for bzero()
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: pl-fb.c,v 7.10 88/08/19 22:42:08 mike Locked $ (BRL)";
@


7.10
log
@added getopt, variable screen size, stroke descriptor free lists
with large mallocs, single_banded mode, cleanup up a little code
and some documentation - lots of good stuff!
Note: -t thickness now means width in pixels, not number of extra pixels.
ToDo: thick points, square aspect on nonsquare screens(?)
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: pl-fb.c,v 7.9 88/08/16 03:06:08 phil Locked $ (BRL)";
d71 1
@


7.9
log
@Improved speed of reading 3-D coords
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: pl-fb.c,v 7.8 88/06/21 04:43:49 phil Exp $ (BRL)";
d135 1
a135 2
typedef struct
	{
d138 1
a138 1
	}	coords; 		/* Cartesian coordinates */
d140 1
a140 2
typedef struct descr
	{
d151 2
a152 1
	}	stroke; 		/* rasterization descriptor */
d238 2
d251 4
a254 3
STATIC short	debug  = 0;
STATIC short	over = 0;		/* !0 to overlay on existing image */
STATIC short	immediate = 0;		/* !0 to plot immediately */
d256 1
a256 1
STATIC short	line_thickness = 0;
d280 1
a280 1
STATIC stroke	*Allocate(), *Dequeue();
d283 1
a283 2
STATIC void	Catch(), FreeUp(), InitDesc(), Queue(),
		Requeue(),
d289 47
d353 3
a355 1
char usage[] = "Usage: pl-fb [-h] [-d] [-o] [-i] [-t thickness] [file.plot]\n";
d357 71
d438 2
a439 2
int argc;
char **argv;
a440 4
	register int	i;
	register char	*filename = NULL;
	char		*cp;
	
a441 10
	for(i = 1; i < argc; i++)
		if( argv[i][0] == '-' )
			switch( argv[i][1] )  {
			case 't':
				line_thickness = atoi(argv[++i]);
				break;
				
			case 'i':
				immediate = 1;
				break;
d443 3
a445 34
			case 'd':
				debug = 1;
				break;

			case 'O':
			case 'o':
				over = 1;
				break;

			case 'h':
				Nscanlines = Npixels = 1024;
				break;

			default:
				fprintf(stderr, usage);
				exit(4);
			}
		else
			filename = argv[i];

	/*
	 *  Open the selected filename -- note
	 *  with no arguments, we plot STDIN.
	 */
	if ( filename == NULL || filename[0] == 0 )  {
		if( isatty(fileno(stdin)) )  {
			fprintf(stderr,usage);
			exit(-3);
		}
		filename = "-";
		pfin = stdin;
	} else if( (pfin = fopen( filename, "r" )) == NULL ) {
		fprintf(stderr,"Can't open file \"%s\"\n", filename);
		exit(-2);
a447 1

d449 1
a449 1
	if( (fbp = fb_open( NULL, Npixels, Nscanlines )) == FBIO_NULL )  {
d459 4
d490 5
a494 1

d1077 1
a1077 1
	{
d1083 1
a1083 1
	}
a1086 18
	Queue - queue descriptor onto band list

	Note that descriptor order is not important.
*/

STATIC void
Queue( bp, hp, vp )
	register struct band *bp;
	register stroke **hp;		/* *hp -> first descr in list */
	register stroke *vp;		/* -> new descriptor */
{
	vp->next = *hp; 		/* -> first in existing list */
	*hp = vp;			/* -> new first descriptor */
	if( vp->next == NULL )
		bp->last = vp;		/* update end pointer */
}

/*
d1104 4
a1107 3
	Dequeue - remove descriptor from band list (do not free space)
*/

d1109 4
a1112 5
Dequeue( bp, hp )				/* returns addr of descriptor,
					   or NULL if none left */
	register struct band *bp;
	register stroke **hp;		/* *hp -> first descr in list */
	{
d1122 1
a1122 1
	}
d1137 1
a1137 1
			free( (char *)vp );	/* free storage */
a1170 1

d1172 9
a1180 3
	BuildStr - set up DDA parameters and queue stroke
*/

d1182 2
a1183 2
BuildStr( pt1, pt2 )			/* returns true unless bug */
coords		*pt1, *pt2;	/* endpoints */
d1197 2
a1198 2
	if ( (vp = Allocate()) == NULL )	/* alloc a descriptor */
		return false;		/* "can't happen" */
a1199 2
	prep_dda( vp, pt1, pt2 );

d1201 1
a1201 1
	thick = line_thickness;
d1204 1
a1204 2
		register stroke *v2 = Allocate();
		*v2 = *vp;
d1206 9
d1223 1
a1223 1
		if( immediate )  {
a1229 1
	free((char *)vp);
d1234 2
a1235 21
	Allocate - allocate a descriptor (possibly updating image file)
*/

STATIC stroke *
Allocate()				/* returns addr of descriptor
					   or NULL if something wrong */
	{
	register stroke *vp;		/* -> allocated storage */

	if ( (vp = (stroke *)malloc( sizeof(stroke) )) == NULL
	  && OutBuild() 		/* flush and free up storage */
	   )
		vp = (stroke *)malloc( sizeof(stroke) );

	return vp;			/* should be non-NULL now */
	}

/*
	OutBuild - rasterize all strokes into raster frame image
*/

d1243 12
d1291 11
a1301 9
	Raster - rasterize stroke.  If overflow into next band, requeue;
					else free the descriptor.

Method:
	Modified Bresenham algorithm.  Guaranteed to mark a dot for
	a zero-length stroke.  Please do not try to "improve" this code
	as it is extremely hard to get all aspects just right.
*/

d1304 3
a1306 3
	register stroke *vp;		/* -> rasterization descr */
	register struct band *np;	/* *np -> next band 1st descr */
	{
d1310 1
a1310 1
	 *  Set the color of this vector into master color array
d1312 1
a1312 2
	for ( dy = vp->pixel.y - ystart; dy < lines_per_band; )
		{
d1324 2
a1325 3
		if ( vp->major-- == 0 ) /* done! */
			{
			free( (char *)vp );	/* return to "malloc" */
d1327 4
a1330 3
			}
		if ( vp->e < 0 )	/* advance major & minor */
			{
d1334 2
a1335 2
			}
		else	{		/* advance major only */
a1340 1
			}
d1342 1
a1344 1

d1347 1
a1347 1
	}
@


7.8
log
@put the points back!
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: pl-fb.c,v 7.7 88/05/16 00:06:59 phil Locked $ (BRL)";
d440 2
a441 2
	coords		newpos; 	/* current input coordinates */
	coords		virpos; 	/* virtual pen position */
d916 3
a918 2
	char	trash[8];
	register bool	ret;
d920 28
a947 3
	ret = GetDCoords( coop );
	fread( trash, sizeof(trash), 1, pfin );
	return( ret );
d954 3
a956 3
	char	in[2*8];
	double	out[2];
	double	x,y;
a964 2
	if( debug )  fprintf(stderr,"Coord: (%g,%g) ", x, y);

d981 4
a984 3
	if( debug )
		fprintf( stderr,"Pixel: (%d,%d)\n", coop->x, coop->y);
		
@


7.7
log
@lint fixes
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: pl-fb.c,v 7.6 88/02/20 04:27:54 mike Locked $ (BRL)";
d1109 1
a1109 1
	if( thick >= vp->major )  thick = vp->major-1;
@


7.6
log
@Added -t line_thickness capability.
Especially important for making videotapes
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: pl-fb.c,v 7.5 88/02/17 17:52:40 mike Locked $ (BRL)";
d285 2
d805 1
d849 1
@


7.5
log
@fix to honor the first clear if we have flushed already
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: pl-fb.c,v 7.4 88/02/06 09:19:04 phil Locked $ (BRL)";
d254 1
d303 1
a303 1
char usage[] = "Usage: pl-fb [-h] [-d] [-o] [-i] [file.plot]\n";
d326 3
d1047 32
d1084 2
a1085 2
	coords		*pt1, *pt2;	/* endpoints */
	{
d1087 1
d1090 1
a1090 3

	if ( pt1->y > pt2->y )
		{
d1096 1
a1096 1
		}
d1101 1
a1101 1
	/* set up multi-band DDA parameters for stroke */
d1103 6
a1108 8
	vp->pixel = *pt1;		/* initial pixel */
	vp->major = pt2->y - vp->pixel.y;	/* always nonnegative */
	vp->ysign = vp->major ? 1 : 0;
	vp->minor = pt2->x - vp->pixel.x;
	COPYRGB( vp->col, cur_color );
	if ( (vp->xsign = vp->minor ? (vp->minor > 0 ? 1 : -1) : 0) < 0
	   )
		vp->minor = -vp->minor;
d1110 7
a1116 1
	/* if Y is not really major, correct the assignments */
d1118 8
a1125 20
	if ( !(vp->ymajor = vp->minor <= vp->major) )
		{
		register short	temp;	/* temporary for swap */

		temp = vp->minor;
		vp->minor = vp->major;
		vp->major = temp;
		}

	vp->e = vp->major / 2 - vp->minor;	/* initial DDA error */
	vp->de = vp->major - vp->minor;

	/* link descriptor into band corresponding to starting scan */

	if( immediate )  {
		ystart = 0;
		Raster( vp, (struct band *)0 );
	}  else
		Requeue( &band[vp->pixel.y / lines_per_band], vp );

d1127 1
a1127 1
	}
@


7.4
log
@sgi required mods
new flush (F) command support
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: pl-fb.c,v 7.3 88/01/30 00:36:32 phil Exp $ (BRL)";
d492 1
@


7.3
log
@added floating point routines
changed name plot-fb to pl-fb
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: pl-fb.c,v 7.2 88/01/27 00:58:34 phil Locked $ (BRL)";
d251 1
a251 1
STATIC short	overlay = 0;		/* !0 to overlay on existing image */
d336 1
a336 1
				overlay = 1;
d376 1
a376 1
		if( !overlay )
d384 2
a385 3
		fprintf(stderr, "Nscanlines(%d) %% lines_per_band(%d) != 0\n",
			Nscanlines, lines_per_band);
		exit(1);
d423 1
a423 1
	Upon end of file or erase, plot data is copied to the device.
d438 1
d466 1
a466 1
					
d473 6
d481 13
d1142 1
a1142 1
	    	if( overlay )  {
@


7.2
log
@Cray's can't handle signed chars.
@
text
@d2 1
a2 1
 *			F B P L O T . C
d63 1
a63 1
static char RCSid[] = "@@(#)$Header: plot-fb.c,v 7.1 87/11/03 00:09:20 wm Locked $ (BRL)";
d157 12
a168 7
STATIC struct
	{
	int		left;		/* window edges */
	int		bottom;
	int		right;
	int		top;
	}	space;	 		/* plot scale data */
a239 3
STATIC long	delta;			/* larger window dimension */
STATIC long	deltao2;		/* delta / 2 */

d302 1
a302 1
char usage[] = "Usage: plot-fb [-h] [-d] [-o] [-i] [file.plot]\n";
d369 1
a369 1
		fprintf(stderr,"plot-fb: fb_open failed\n");
d396 1
a396 1
		fprintf(stderr,"plot-fb:  malloc error\n");
d401 1
a401 1
		fprintf(stderr,"plot-fb: malloc error2\n");
d408 1
a408 1
		fprintf(stderr, "plot-fb output of %s\n", filename);
d548 99
d682 2
a683 4
				delta = (long)space.right
				      - (long)space.left;
				deltao2 = (long)space.top
					- (long)space.bottom;
d687 1
a687 1
					fprintf( stderr, "plot-fb: delta = %d, bad space()\n", delta);
d690 1
a690 1
				deltao2 = (delta + 1L) / 2L;
d692 1
a692 1
					fprintf( stderr,"Space: X=(%d,%d) Y=(%d,%d) delta=%d\n",
d725 39
a763 1
				
d765 1
a765 2
				if( debug )
					fprintf( stderr,"action %c ignored\n", c);
d848 2
a849 2
	register coords	*coop;		/* -> input coordinates */
	{
d851 1
a851 1
	register long x,y;
d860 1
a860 1
	if( debug )  fprintf(stderr,"Coord: (%d,%d) ", x, y);
d869 2
a870 2
	coop->x = (short)((x * Npixels + deltao2) / delta);
	coop->y = (short)((y * Nscanlines + deltao2) / delta);
d882 1
a882 1
	}
d884 51
d1126 1
a1126 1
	    			fprintf(stderr,"plot-fb:  band read error\n");
@


7.1
log
@Release 2.3
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: plot-fb.c,v 6.2 87/09/03 02:12:52 mike Exp $ (BRL)";
d166 1
a166 1
	char	x,y;			/* x, y values (255,255 is end) */
@


6.2
log
@Minor neatening for Cray
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: plot-fb.c,v 6.1 87/07/11 08:12:43 mike Rel $ (BRL)";
@


6.1
log
@Release 2.0
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: plot-fb.c,v 5.1 87/06/24 22:43:37 mike Rel $ (BRL)";
d435 2
a547 1
					unsigned char buf[6*2];
d550 2
a551 2
				if( fread( (char *)buf,
					   (int)sizeof buf, 1, pfin)
d556 2
a557 2
				space.left  = sxt16((buf[1]<<8) | buf[0]); /* x1 */
				space.bottom= sxt16((buf[3]<<8) | buf[2]); /* y1 */
d559 2
a560 2
				space.right = sxt16((buf[7]<<8) | buf[6]); /* x2 */
				space.top   = sxt16((buf[9]<<8) | buf[8]); /* y2 */
d569 2
a570 3
					unsigned char buf[4*2];
				if ( fread( (char *)buf,
					    (int)sizeof buf, 1, pfin
d574 4
a577 4
				space.left  = sxt16((buf[1]<<8) | buf[0]); /* x1 */
				space.bottom= sxt16((buf[3]<<8) | buf[2]); /* y1 */
				space.right = sxt16((buf[5]<<8) | buf[4]); /* x2 */
				space.top   = sxt16((buf[7]<<8) | buf[6]); /* y2 */
@


5.1
log
@Release 1.24
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: plot-fb.c,v 4.4 87/03/16 21:53:29 mike Exp $ (BRL)";
@


4.4
log
@Added 16-bit sign extention code to accomodate machines where
short is longer than 16 bits.

Note that this version only still only works on the Cray in interactive
(-i) mode.
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: plot-fb.c,v 4.3 87/02/13 00:50:31 mike Locked $ (BRL)";
@


4.3
log
@Release 1.20 -- First Formal Release
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: plot-fb.c,v 4.2 87/01/12 16:48:12 mike Rel1 $ (BRL)";
d159 4
a162 4
	short		left;		/* window edges */
	short		bottom;
	short		right;
	short		top;
d282 18
d555 2
a556 2
				space.left  = (buf[1]<<8) | buf[0]; /* x1 */
				space.bottom= (buf[3]<<8) | buf[2]; /* y1 */
d558 2
a559 2
				space.right = (buf[7]<<8) | buf[6]; /* x2 */
				space.top   = (buf[9]<<8) | buf[8]; /* y2 */
d574 4
a577 4
				space.left  = (buf[1]<<8) | buf[0]; /* x1 */
				space.bottom= (buf[3]<<8) | buf[2]; /* y1 */
				space.right = (buf[5]<<8) | buf[4]; /* x2 */
				space.top   = (buf[7]<<8) | buf[6]; /* y2 */
a714 1
	register short s;
d721 3
a723 4
	s = (buf[1]<<8) | buf[0];
	x = s;				/* sign extend */
	s = (buf[3]<<8) | buf[2];
	y = s;				/* sign extend */
d935 1
d951 1
@


4.2
log
@Added check for delta <= 0
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: plot-fb.c,v 4.1 86/12/29 03:14:00 mike Locked $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: plot-fb.c,v 1.20 86/12/29 01:30:06 mike Exp $ (BRL)";
d569 4
@


1.20
log
@Some improved debugging
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: plot-fb.c,v 1.19 86/12/29 00:53:30 mike Locked $ (BRL)";
@


1.19
log
@Fixed lack-of-sign-extend problem.
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header: plot-fb.c,v 1.18 86/12/28 23:13:28 mike Locked $ (BRL)";
d427 1
a427 1
		for ( ; ; )		/* read until EOF or erase */
d432 10
d443 1
a443 2
				if( debug )
					fprintf( stderr,"Erase or EOF\n");
d445 1
a445 2
				if ( plotted )
				{
d447 1
a449 1

a450 4

				if ( c == EOF )
					return Foo( 0 );/* success */

d1004 1
@


1.18
log
@Added RCSid, neatened comment
@
text
@d63 1
a63 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d689 1
d696 5
a700 2
	x = (buf[1]<<8) | buf[0];
	y = (buf[3]<<8) | buf[2];
a702 1
	if( debug )  fprintf(stderr,"Coord: (%d,%d) ", coop->x, coop->y);
@


1.17
log
@Changed error prints to plot-fb
@
text
@d6 4
a9 2
 *	Joseph C. Pistritto JCP@@BRL
 *	US Army Ballistic Research Laboratory
d11 37
a47 38
Function:
	Reads device-independent plot data from specified input file;
	for each frame, builds an image file containing raster data then
	sends the frame output to the output device.

	Edge-limiting is done here; use "rot" if clipping is desired.

Method:
	Inputs vector data and builds a rasterization descriptor for
	each visible stroke.  (Strokes are limited to frame boundaries.)
	X goes down the page, Y goes from left to right.  To obtain a
	different orientation, pre-process data with the "rot" filter.
	(Quadrant 1 graphics devices)

	The frame image file of SCANS scans is considered artificially
	divided into BANDS bands, each containing lines_per_band scans.
	Each band has a linked list of descriptors for
	not-yet-rasterized strokes that start in the band.

	Space for descriptors is obtained via "malloc".  When no more
	space is available, the image file is updated as follows, then
	"malloc" is tried again ("must" work the second time):

	Each band in increasing X order becomes "active"; if no
	descriptors exist for the band it is skipped, otherwise its
	existing raster data is re-read from the image file into a
	buffer and each descriptor is processed to rasterize its stroke.
	If the stroke terminates in the band its descriptor is freed,
	otherwise the descriptor is linked into the following band's
	list.  When the descriptor list for the active band becomes
	empty (must happen), the band's raster data is flushed back to
	the image file and the next band becomes active.  This process
	continues until all vectors have been input and rasterized.

Acknowledgment:
	Based rather heavily on Doug Gwyn's Versatec PLOT rasterizer VPL.C
	which was
	Based very loosely on Mike Muuss's Versatec TIGpack interpreter.
d52 9
d62 3
@


1.16
log
@In immediate mode, added clear if not overlay.
@
text
@d336 1
a336 1
		fprintf(stderr,"fbplot: fb_open failed\n");
d363 1
a363 1
		fprintf(stderr,"fbplot:  malloc error\n");
d368 1
a368 1
		fprintf(stderr,"fbplot: malloc error2\n");
d375 1
a375 1
		fprintf(stderr, "fbplot output of %s\n", filename);
d898 1
a898 1
	    			fprintf(stderr,"fbplot:  band read error\n");
@


1.15
log
@Added immediate plotting mode.
@
text
@d341 1
a341 1
	if( immediate )
d343 3
@


1.14
log
@Changed reading of coordinates to be machine byte-order independent,
like they should have been.
@
text
@d24 3
a26 3
	divided into BANDS bands, each containing SPB scans.  Each band
	has a linked list of descriptors for not-yet-rasterized strokes
	that start in the band.
a94 1
#define SPB		16		/* scan lines per band */
d103 1
a103 1
#define BANDS	(Nscanlines / SPB)		/* # of "bands" */
d237 2
d269 1
a269 1
char usage[] = "Usage: plot-fb [-h] [-d] [-o] [file.plot]\n";
d293 4
d333 11
d347 3
a349 2
	if( (Nscanlines % SPB) != 0 )  {
		fprintf(stderr, "Nscanlines % SPB != 0\n");
d358 1
a358 1
	buffersize = SPB*Npixels*sizeof(RGBpixel);
a370 4
	if( (fbp = fb_open( NULL, Npixels, Nscanlines )) == FBIO_NULL )  {
		fprintf(stderr,"fbplot: fb_open failed\n");
		exit(1);
	}
d382 1
a382 1
	DoFile - process UNIX plot file onto IKONAS
d664 1
a664 1
	fread( &trash, sizeof(trash), 1, pfin );
d843 5
a847 1
	Requeue( &band[vp->pixel.y / SPB], vp );
d890 1
a890 1
	      hp = np++, ystart += SPB
d934 1
a934 1
	for ( dy = vp->pixel.y - ystart; dy < SPB; )
a935 1
		register RGBpixel *pp;
d938 4
a941 2
		pp = (RGBpixel *)buffer[(dy*Npixels) + vp->pixel.x];
		COPYRGB( *pp, vp->col );
d943 4
d969 1
a969 1
	vp->pixel.y = ystart + SPB;
@


1.13
log
@fixed overlay mode
@
text
@d47 5
a51 1
*/
a152 10
STATIC struct
	{
	short		left;		/* 3d window edges */
	short		bottom;
	short		front;
	short		right;
	short		top;
	short		back;
	}	space3;

d494 2
d498 2
a499 2
				if( fread( (char *)&space3,
					   (int)sizeof space3, 1, pfin)
d503 7
a509 5
				/* turn 3 space into 2 space */
				space.right = space3.right;
				space.left  = space3.left;
				space.top   = space3.top;
				space.bottom= space3.bottom;
d511 1
d516 4
a519 2
				if ( fread( (char *)&space,
					    (int)sizeof space, 1, pfin
d523 5
d647 1
a647 1
	short	trash;
d659 1
d663 1
a663 1
	if ( fread( (char *)coop, (int)sizeof (coords), 1, pfin ) != 1 )
d666 2
a667 2
	x = coop->x;	/* get them into longs */
	y = coop->y;
d922 1
a922 1
		pp = (RGBpixel *)&buffer[(dy*Npixels) + vp->pixel.x][RED];
a923 3
/**		*((long *)buffer[dy][vp->pixel.x]) = *((long *)vp->col); **/
/**		*((long *)(buffer+(((dy*Npixels)+vp->pixel.x)*sizeof(RGBpixel)))) =
			*((long *)vp->col);  **/
@


1.12
log
@Changed "color" to "cur_color" for bloody SGI.
@
text
@d870 1
a870 1
		    	if( fb_write( fbp, 0, ystart, buffer, buffersize/sizeof(RGBpixel) ) <= 0 )
@


1.11
log
@used to fb_close without fb_open on arg errors.
@
text
@d117 1
a117 1
RGBpixel	color = { 255, 255, 255 };
d539 1
a539 1
				if( fread( &color[0], 1, 3, pfin) != 3 )
d543 3
a545 1
						color[0], color[1], color[2]);
d802 1
a802 1
	COPYRGB( vp->col, color );
@


1.10
log
@Changed returns to exits, added exit(0) at end.
@
text
@d274 1
a274 1
char usage[] = "plot-fb:  [-h] [-d] [-o] [file.plot]\n";
d325 1
a325 1
			exit(Foo(-3));
d329 4
a332 2
	} else if( (pfin = fopen( filename, "r" )) == NULL )
		exit(Foo(-2));
@


1.9
log
@Added isatty checking, grouped all option processing together.
@
text
@d325 1
a325 1
			return Foo(-3);
d330 1
a330 1
		return Foo( -2 );
d368 1
@


1.8
log
@Version with characters properly oriented.
@
text
@d274 2
d312 2
a313 2
				fprintf(stderr, "unknown option %s\n",
					argv[i] );
d319 14
a361 5

	/*
	 *  Plot the selected filename -- note
	 *  with no arguments, we plot STDIN.
	 */
a363 5
		
	if ( filename == NULL || filename[0] == 0 )
		pfin = stdin;
	else if( (pfin = fopen( filename, "r" )) == NULL )
		return Foo( -2 );
@


1.7
log
@Increased use of RGBpixel type.
@
text
@d53 1
d579 4
a582 2
	if( c >= 'a' && c <= 'z' )
		c = c - 'a' + 'A';	/* xlate to upper case */
d589 1
a589 1
		/* Character not found -- space over 1/2 char */
d596 1
a596 1
	start.y = vc->r[0].y + pos->y - Y_CHAR_SIZE;
d600 1
a600 1
		end.y = rv->y + pos->y - Y_CHAR_SIZE;
a661 3
	/* REVERSE the y axis for those of you who like plots origin down */
	coop->y = Nscanlines - coop->y;
	
@


1.6
log
@Converted to libfb.
Plots upside-down.
@
text
@d64 10
a74 10
	||	X axis						|
 ^	||							|
 |	|v							|
	|plot							|
	|Y axis
	|			|				|
 ^	|			v				|
 |	|			.				|
	|scan line ->...........................................|
	|			.				|
a88 2
#define	PIXELSIZE	sizeof(RGBpixel) /* # bytes per pixel */

d100 1
a100 1
#define BYTES	(Npixels * PIXELSIZE)	/* max data bytes per scan */
d238 1
a238 1
STATIC char	*buffer;		/* ptr to active band buffer */
d328 2
a329 2
	buffersize = SPB*Npixels*PIXELSIZE;
	if( (buffer = malloc(buffersize)) == (char *)0)  {
d791 1
a791 1
	*((long *)vp->col) = *((long *)color);		/* record color fast */
d863 1
a863 1
			bzero( buffer, buffersize );
d901 1
d904 2
d907 2
a908 2
		*((long *)(buffer+(((dy*Npixels)+vp->pixel.x)*PIXELSIZE))) =
			*((long *)vp->col);
@


1.5
log
@Corrected chopping of lines to account for maximum sized
spaces (-32k..+32k).
@
text
@d2 1
a2 1
 *			I K P L O T . C
d4 1
a4 1
 *	Program to take UNIX plot data and output on IKONAS display.
d51 3
a53 2
#include	<signal.h>
#include	<stdio.h>
d81 3
a83 4
Each scan line is composed of four bytes of color data, for the Red,
Green, and Blue DACS, (the fourth byte is unused here, and is set to 0)
for each pixels, times the number of pixels desired (512 in LORES,
1024 in HIRES)
d87 1
a87 1
/*	IKONAS Device Parameters				 */
d89 1
a89 1
#define	PIXELSIZE	4		/* # bytes per pixel */
d118 1
a118 1
char	color[PIXELSIZE] = { 255, 255, 255, 0 };
d137 1
a137 1
	char		col[PIXELSIZE];	/* COLOR of this vector */
d263 1
a263 2
extern int	ikhires;		/* for ik library */
extern int	ikfd;			/* from ik library */
d270 1
a270 1
		OutBuild(), RdBand(), WrBand();
d282 1
a282 2
 *	Default (no arguments) action is to plot STDIN on STDOUT
 *	as an IKONAS
a306 1
				ikhires = 1;
d332 1
a332 1
		fprintf(stderr,"ikplot:  malloc error\n");
d337 1
a337 1
		fprintf(stderr,"ikplot: malloc error2\n");
d343 2
a344 2
	if( ikopen() < 0 )  {
		fprintf(stderr,"ikplot: ikopen failed\n");
d353 1
a353 1
		fprintf(stderr, "ikplot output of %s\n", filename);
a415 1
				(void)lseek( ikfd, 0L, 0 );	/* top */
a763 38
	RdBand - Read in next band from output image file,
		for overlay purposes.  Reposition back.
*/
STATIC bool
RdBand()
{
	register char	*bp = buffer;
	register int	size;

	size = 32768;	/* default DMA size */
	for( bp = buffer; buffersize - (bp - buffer) > 0; bp += size)  {
		size = min( size, buffersize - (bp - buffer) );
		if( read(ikfd, bp, size) != size )
			return false;
	}
	lseek( ikfd, -buffersize, 1);
	return true;
}

/*
	WrBand - Write out next band to output image file
*/
STATIC bool
WrBand()
{
	register char	*bp = buffer;
	register int	size;

	size = 32768;	/* default DMA size */
	for( bp = buffer; buffersize - (bp - buffer) > 0; bp += size)  {
		size = min( size, buffersize - (bp - buffer) );
		if( write(ikfd, bp, size) != size )
			return false;
	}
	return true;
}

/*
d861 2
a862 1
	    		RdBand();
d874 1
a874 1
		if( !WrBand() )
d943 1
a943 1
	(void)close( ikfd );		/* close open files */
@


1.4
log
@Added ability to handle multiple plots.
Fixed up character drawing to work better.
@
text
@d527 5
a531 1

d645 2
a647 1

d651 3
d655 5
a660 5
	if ( (coop->x -= space.left) < 0 )
		coop->x = 0;
	if ( (coop->y -= space.bottom) < 0 )
		coop->y = 0;

d662 2
a664 3
	coop->x = (short)(((long)coop->x * Npixels + deltao2) / delta);
	coop->y = (short)(((long)coop->y * Nscanlines + deltao2) / delta);

a668 1

d675 1
a675 1
		fprintf( stderr,"Coord: (%d,%d)\n", coop->x, coop->y);
@


1.3
log
@Made -o and -O synonymous
@
text
@d53 1
a53 1

d93 2
a94 2
#define	X_CHAR_SIZE	((Npixels/73)-1) /* pixels per char horizontal */
#define	Y_CHAR_SIZE	Nscanlines/46	/* pixels per char vertical */
d98 1
a98 1

d139 1
a139 1

d220 4
a228 1
STATIC int	charsz = 1;
d275 1
a275 1

a310 1
				charsz = 2;
d358 8
a365 1
	vik( filename );
d370 1
a370 1
	vpl - rasterizer control subroutine
d377 4
a381 24

int
vik( pname )	/* returns status code:
					   < 0	=> catastrophe
					   = 0	=> complete success
					   > 0	=> line limit hit   */
char	*pname; 		/* name of plot data file */
{

	if ( pname == NULL || pname[0] == 0 )
		pfin = stdin;

	else if( (pfin = fopen( pname, "r" )) == NULL )
		return Foo( -2 );

	SetSigs();			/* set signal catchers */

	return DoFile( );	/* plot it */
	}

/*
	DoFile - process UNIX plot file onto IKONAS
*/

d419 1
d546 1
a546 2
					put_vector_char( c, newpos);
					newpos.x += X_CHAR_SIZE;
d570 1
d574 1
a574 1
coords		pos;
d576 1
a576 1
	coords	start, end;
d581 1
a581 1
		c = c - 'a' + 'A';	/* xlate upper to lower case */
d587 3
a589 1
	if( !vc->ascii )
d591 1
d594 2
a595 2
	start.x = vc->r[0].x*charsz + pos.x;
	start.y = vc->r[0].y*charsz + pos.y - Y_CHAR_SIZE;
d598 2
a599 2
		end.x = rv->x*charsz + pos.x;
		end.y = rv->y*charsz + pos.y - Y_CHAR_SIZE;
d602 1
a602 1
		BuildStr( &start, &end );
d605 1
d760 1
a760 1

d798 1
a798 1

d854 1
a854 1

d872 1
a872 1

d915 1
a915 1

d969 1
a969 1

d984 1
a984 1

@


1.2
log
@This version combines lowres and hires operations with the -h option.
Also has "overlay" mode with -o options, where plot is over-written
on framebuffer.
@
text
@d300 1
@


1.1
log
@Initial revision
@
text
@d49 1
a86 1

a88 2
#define	LORESPIX	512		/* # pixels/scan line LORES */
#define	HIRESPIX	1024		/* # pixels/scan line HIRES */
a90 10
#ifdef	HIRES
#define	SCANS	HIRESPIX
#define	PIXELS	HIRESPIX
#define	CHARSZ	2
#else
#define	SCANS	LORESPIX
#define	PIXELS	LORESPIX
#define	CHARSZ	1
#endif

d93 2
a94 6
#ifdef HIRES
#define	X_CHAR_SIZE	((PIXELS/73)-1)
#else
#define	X_CHAR_SIZE	PIXELS/73	/* pixels per char horizontal */
#endif	HIRES
#define	Y_CHAR_SIZE	SCANS/46	/* pixels per char vertical */
a95 4
#if	SCANS % SPB != 0
#include	"SCANS % SPB != 0"	/* (just for ERROR message) */
#endif

d101 4
a104 4
#define BANDS	(SCANS / SPB)		/* # of "bands" */
#define BYTES	(PIXELS * PIXELSIZE)	/* max data bytes per scan */
#define XMAX	(SCANS - 1)		/* frame boundary */
#define YMAX	(PIXELS - 1)		/* scan boundary */
a105 3
#define	XSCA	PIXELS
#define	YSCA	SCANS

d142 1
a142 1
static struct
d148 1
a148 2
	}	space =	 		/* plot scale data */
	{ 0, 0, YSCA, XSCA };		/* default unity scaling */
d150 1
a150 1
static struct
d171 1
a171 1
static struct vectorchar {
d223 3
a225 2
static long	delta = YSCA;		/* larger window dimension */
static long	deltao2 = YSCA / 2;	/* delta / 2 */
d227 3
d234 2
a235 1
static struct band	band[BANDS] = { NULL };	/* descriptor lists */
d237 5
a241 5
/* active band buffer: */
static char	buffer[SPB][PIXELS][PIXELSIZE] = { 0 };
static short	ystart = 0;		/* active band starting scan */
static short	debug  = 0;
static int	ifd    = 1;	/* for image file Output */
d243 1
a243 1
static int	sigs[] =		/* signals to be caught */
d254 1
a254 5
#ifdef	BRL
#define open	_open		/* System V emulation not needed */
#endif

static FILE	*pfin;		/* input file FIO block ptr */
d259 1
d265 5
a269 5
static int	DoFile(), Foo();
static stroke	*Allocate(), *Dequeue();
static bool	BuildStr(), GetCoords(),
		OutBuild(), WrBand();
static void	Catch(), FreeUp(), InitDesc(), Queue(),
d291 1
d300 10
a316 6
#ifdef	HIRES
	ikhires = 1;
#else
	ikhires = 0;
#endif	HIRES
	ikopen();
d318 1
a318 3
	 * Since the stupid ikopen routine DOESN'T return a file
	 * descriptor (well, it does in a global variable...)
	 * hence the next line of kludgey code.  YUCKO!!!
d320 3
a322 3
	if( (ifd = ikfd) < 0 )  {
		perror("Ikonas");
		exit(-1);
d324 24
d349 2
a350 2
	 *  Plot the selected filename on STDOUT (as an IKONAS) - note
	 *  with no arguments, we plot STDIN on STDOUT (filter mode)
d353 1
a353 1
		fprintf(stderr, "IKONAS plot output of %s\n", filename);
d392 1
a392 1
static int
d600 2
a601 2
	start.x = vc->r[0].x*CHARSZ + pos.x;
	start.y = vc->r[0].y*CHARSZ + pos.y - Y_CHAR_SIZE;
d604 2
a605 2
		end.x = rv->x*CHARSZ + pos.x;
		end.y = rv->y*CHARSZ + pos.y - Y_CHAR_SIZE;
d612 1
a612 1

d621 2
a622 2
	if( ppos->x >= PIXELS )
		ppos->x = PIXELS -1;
d624 2
a625 2
	if( ppos->y >= SCANS )
		ppos->y = SCANS -1;
d631 1
a631 1
static bool Get3Coords( coop )
d642 1
a642 1
static bool
d660 2
a661 2
	coop->x = (short)(((long)coop->x * XSCA + deltao2) / delta);
	coop->y = (short)(((long)coop->y * YSCA + deltao2) / delta);
d664 1
a664 1
	coop->y = SCANS - coop->y;
d678 1
a678 2


d683 1
a683 1
static void
d688 1
a688 1
	for ( bp = &band[0]; bp < &band[BANDS]; ++bp )
d700 1
a700 1
static void
d715 1
a715 1
static void
d733 1
a733 1
static stroke *
d755 1
a755 1
static void
d761 1
a761 1
	for ( bp = &band[0]; bp < &band[BANDS]; ++bp )
d766 9
d776 10
d789 1
a789 1
static bool
d792 1
a792 1
	register char	*bp = &buffer[0][0][0];
d796 3
a798 5
	for( bp = &buffer[0][0][0];
	     sizeof buffer - (bp - &buffer[0][0][0]) > 0; bp += size)
	{
		size = min( size, sizeof buffer - (bp - &buffer[0][0][0]) );
		if( write(ifd, bp, size) != size )
d808 1
a808 1
static bool
d864 1
a864 1
static stroke *
d882 1
a882 1
static bool
d889 1
a889 1
	for ( hp = &band[0]; hp < &band[BANDS]; ++hp )
d893 1
a893 1
	if ( hp == &band[BANDS] )
d897 1
a897 1
	      hp < &band[BANDS];
d900 7
a906 2
		/* clear pixels in the band */
		bzero( buffer, sizeof(buffer) );
d931 1
a931 1
static void
d945 3
a947 1
		*((long *)buffer[dy][vp->pixel.x]) = *((long *)vp->col);
d979 1
a979 1
static int
d983 1
a983 1
	(void)close( ifd );		/* close open files */
d993 1
a993 1
static void
d1011 1
a1011 1
static void
@
