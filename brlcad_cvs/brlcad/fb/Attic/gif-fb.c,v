head	11.8;
access;
symbols
	ansi-20040405-merged:11.5.2.1
	postmerge-20040405-ansi:11.6
	premerge-20040404-ansi:11.5
	postmerge-autoconf:11.5
	autoconf-freeze:11.5
	premerge-autoconf:11.5
	ansi-20040316-freeze:11.5.2.1
	postmerge-20040315-windows:11.5
	premerge-20040315-windows:11.5
	windows-20040315-freeze:11.5
	autoconf-20031203:11.5
	autoconf-20031202:11.5
	autoconf-branch:11.5.0.10
	phong-branch:11.5.0.8
	photonmap-branch:11.5.0.6
	rel-6-1-DP:11.5
	windows-branch:11.5.0.4
	rel-6-0-2:11.3
	ansi-branch:11.5.0.2
	rel-6-0-1-branch:11.3.0.2
	hartley-6-0-post:11.4
	hartley-6-0-pre:11.3
	rel-6-0-1:11.3
	rel-6-0:11.3
	rel-5-4:11.1
	offsite-5-3-pre:11.1
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1;
locks; strict;
comment	@ * @;


11.8
date	2004.05.24.04.13.26;	author morrison;	state dead;
branches;
next	11.7;

11.7
date	2004.05.10.15.30.42;	author erikg;	state Exp;
branches;
next	11.6;

11.6
date	2004.04.05.07.49.23;	author morrison;	state Exp;
branches;
next	11.5;

11.5
date	2002.08.20.17.07.25;	author jra;	state Exp;
branches
	11.5.2.1;
next	11.4;

11.4
date	2002.08.15.20.54.38;	author hartley;	state Exp;
branches;
next	11.3;

11.3
date	2001.08.10.21.27.04;	author butler;	state Exp;
branches;
next	11.2;

11.2
date	2001.04.12.17.44.08;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.09.34;	author mike;	state Rel4_4;
branches;
next	10.6;

10.6
date	94.12.30.03.27.50;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.11.14.22.27.56;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.08.23.18.49.12;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	94.08.11.15.06.13;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.10.10.03.11.43;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.46.40;	author mike;	state Rel4_0;
branches;
next	9.9;

9.9
date	91.08.29.23.55.18;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	91.08.29.23.53.26;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	91.06.29.22.52.13;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	91.03.30.01.14.15;	author butler;	state Exp;
branches;
next	9.5;

9.5
date	91.01.11.00.28.26;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	91.01.10.21.44.00;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.08.22.02.10.43;	author butler;	state Exp;
branches;
next	9.2;

9.2
date	90.02.05.17.21.55;	author gwyn;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.09.25;	author mike;	state Rel3_5;
branches;
next	1.7;

1.7
date	89.05.08.17.51.33;	author phil;	state Exp;
branches;
next	1.6;

1.6
date	89.05.08.17.18.07;	author gwyn;	state Exp;
branches;
next	1.5;

1.5
date	89.05.08.16.59.53;	author phil;	state Exp;
branches;
next	1.4;

1.4
date	89.05.05.16.47.04;	author gwyn;	state Exp;
branches;
next	1.3;

1.3
date	89.04.29.10.53.58;	author gwyn;	state Exp;
branches;
next	1.2;

1.2
date	89.04.26.20.09.12;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	89.04.26.17.06.26;	author mike;	state Exp;
branches;
next	;

11.5.2.1
date	2002.09.19.18.00.42;	author morrison;	state Exp;
branches;
next	;


desc
@Gwyn's GIF-FB program
@


11.8
log
@moved to src/fb/
@
text
@/*
	gif-fb -- convert a GIF file to (overlaid) frame buffer images

	created:	89/04/29	D A Gwyn

	Typical compilation:	cc -O -I/usr/brlcad/include -o gif-fb \
					gif-fb.c /usr/brlcad/lib/libfb.a
	Add -DNO_VFPRINTF, -DNO_MEMCPY, or -DNO_STRRCHR if vfprintf(),
	memcpy(), or strrchr() are not present in your C library
	(e.g. on 4BSD-based systems).

	This is a full implementation of the (noninteractive) GIF format
	conversion as specified in "A Standard Defining a Mechanism for
	the Storage and Transmission of Raster-Based Graphics Information",
	June 15, 1987 by CompuServe Incorporated.  This spec is far from
	ideal, but it is a standard that has had wide influence in the PC
	arena, and there are a lot of images available in GIF format.  Most
	small computer systems have GIF translators available for them, so
	this program provides a means of getting most PC images into the
	BRL-CAD domain.

	Options:

	-F fb_file	outputs to the specified frame buffer file instead
			of the one specified by the FB_FILE environment
			variable (the default frame buffer, if no FB_FILE)

	-c		overrides the GIF file's specified color resolution,
			using all 8 bits for each R, G, and B channel.

	-i image#	outputs just the specified image number (starting
			at 1) to the frame buffer, instead of all images

	-o		"overlay": skips the initial clearing of the frame
			buffer to the background color

	-v		"verbose": prints information about the images on
			the standard error output

	-z		zoom up the framebuffer, keeping image aspect square

	gif_file	GIF input file to be translated (standard input if
			no explicit GIF file name is specified)
*/
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/fb/gif-fb.c,v 11.7 2004/05/10 15:30:42 erikg Exp $ (BRL)";
#endif

#define	USAGE	"gif-fb [-F fb_file] [-c] [-i image#] [-o] [-v] [-z] [gif_file]"
#define	OPTSTR	"F:ci:ovz"

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#ifndef DEBUG
#define	NDEBUG
#endif
#include	<assert.h>
#include	<signal.h>
#include	<stdio.h>
#ifdef USE_STRING_H
#include	<string.h>
#else
#include	<strings.h>
#endif
#if defined(HAVE_STDARG_H)
# define	RBMODE	"rb"			/* "b" not really necessary for POSIX */
# include	<stdarg.h>
#else
# define	RBMODE	"r"
# include	<varargs.h>
#endif


#include "machine.h"
#include "externs.h"
#include "fb.h"			/* BRL CAD package libfb.a interface */

#ifndef EXIT_SUCCESS
#define	EXIT_SUCCESS	0
#endif
#ifndef EXIT_FAILURE
#define	EXIT_FAILURE	1
#endif

typedef int	bool;
#define	false	0
#define	true	1

static char	*arg0;			/* argv[0] for error message */
static bool	clear = true;		/* set iff clear to background wanted */
static bool	ign_cr = false;		/* set iff 8-bit color resoln. forced */
static bool	verbose = false;	/* set for GIF-file info printout */
static bool	do_zoom = false;	/* set to zoom framebuffer */
static int	image = 0;		/* # of image to display (0 => all) */
static char	*gif_file = NULL;	/* GIF file name */
static FILE	*gfp = NULL;		/* GIF input stream handle */
static char	*fb_file = NULL;	/* frame buffer name */
static FBIO	*fbp = FBIO_NULL;	/* frame buffer handle */
static int	ht;			/* virtual frame buffer height */
static int	width, height;		/* overall "screen" size */
static int	write_width;		/* used width of screen, <= width */
static int	left, top, right, bottom;	/* image boundary */
static bool	M_bit;			/* set iff color map provided */
static bool	I_bit;			/* set iff image interlaced */
static int	cr;			/* # bits of color resolution */
static int	cr_mask;		/* mask to strip all but high cr bits */
static int	g_pixel;		/* global # bits/pixel in image */
static int	pixel;			/* local # bits/pixel in image */
static int	background;		/* color index of screen background */
static int	entries;		/* # of global color map entries */
static RGBpixel	*g_cmap;		/* malloc()ed global color map */
static RGBpixel	*cmap;			/* malloc()ed local color map */
/* NOTE:  Relies on R,G,B order and also on RGBpixel being 3 unsigned chars. */

#define	GIF_EXTENSION	'!'
#define	GIF_IMAGE	','
#define	GIF_TERMINATOR	';'


static char *
Simple(char *path)
{
	register char	*s;		/* -> past last '/' in path */

	return (s = strrchr( path, '/' )) == NULL || *++s == '\0' ? path : s;
	}


static void
VMessage(char *format, va_list ap)
{
	(void)fprintf( stderr, "%s: ", arg0 );
#if !defined(HAVE_VPRINTF)
	(void)fprintf( stderr, format,	/* kludge city */
		       ((int *)ap)[0], ((int *)ap)[1],
		       ((int *)ap)[2], ((int *)ap)[3]
		     );
#else
	(void)vfprintf( stderr, format, ap );
#endif
	(void)putc( '\n', stderr );
	(void)fflush( stderr );
	}


#if defined(HAVE_STDARG_H)
static void
Message( char *format, ... )
#else
static void
Message( va_alist )
	va_dcl
#endif
	{
#if !defined(HAVE_STDARG_H)
	register char	*format;	/* must be picked up by va_arg() */
#endif
	va_list		ap;

#if defined(HAVE_STDARG_H)
	va_start( ap, format );
#else
	va_start( ap );
	format = va_arg( ap, char * );
#endif
	VMessage( format, ap );
	va_end( ap );
	}


#if defined(HAVE_STDARG_H)
static void
Fatal( char *format, ... )
#else
static void
Fatal( va_alist )
	va_dcl
#endif
	{
#if !defined(HAVE_STDARG_H)
	register char	*format;	/* must be picked up by va_arg() */
#endif
	va_list		ap;

#if defined(HAVE_STDARG_H)
	va_start( ap, format );
#else
	va_start( ap );
	format = va_arg( ap, char * );
#endif
	VMessage( format, ap );
	va_end( ap );

	if ( fbp != FBIO_NULL && fb_close( fbp ) == -1 )
		Message( "Error closing frame buffer" );

	exit( EXIT_FAILURE );
	/*NOTREACHED*/
	}


static void
Sig_Catcher(int sig)
{
	(void)signal( sig, SIG_DFL );

	/* The following is not guaranteed to work, but it's worth a try. */
	Fatal( "Interrupted by signal %d", sig );
	}


static void
Skip(void)					/* skip over raster data */
	{
	register int	c;

	if ( (c = getc( gfp )) == EOF )
		Fatal( "Error reading code size" );

	while ( (c = getc( gfp )) != 0 )
		if ( c == EOF )
			Fatal( "Error reading block byte count" );
		else
			do
				if ( getc( gfp ) == EOF )
					Fatal( "Error reading data byte" );
			while ( --c > 0 );
	}


/*
	The raster output loop is inverted, because it is simpler to
	let the LZW decompression drive pixel writing than vice versa.
 */

static int	start_row[5] = { 0, 4, 2, 1, 0 };
static int	step[5] = { 8, 8, 4, 2, 1 };
static int	row, col;		/* current pixel coordinates */
static int	pass;			/* current pass */
static int	stop;			/* final pass + 1 */
static unsigned char	*pixbuf;		/* malloc()ed scan line buffer */


static void
PutPixel(register int value)
{
	if ( pass == stop )
		Fatal( "Too much raster data for image size" );

	if ( value > entries )
		Fatal( "Decoded color index %d exceeds color map size", value );

	pixbuf[col*3+RED] = cmap[value][RED];	/* stuff pixel */
	pixbuf[col*3+GRN] = cmap[value][GRN];
	pixbuf[col*3+BLU] = cmap[value][BLU];

	if ( ++col == right )
		{
		/*
		   Note that BRL-CAD frame buffers are upside-down.
		   The following produces a right-side-up image at
		   the bottom of the available frame buffer.
		 */

		if ( fb_write( fbp, 0, ht - row, pixbuf, write_width ) < 0
		   )
			Message( "Error writing scan line to frame buffer" );

		col = left;

		if ( (row += step[pass]) >= bottom
		  && ++pass < stop
		   )
			row = start_row[pass];
		}
	}


/*
	Limpel-Ziv-Welch decompression, based on "A Technique for
	High-Performance Data Compression" by Terry A. Welch in IEEE
	Computer, June 1984, pp. 8-19.

	GIF format usurps the first two "compression codes" for use
	as "reset" and "end of information".  The initial "code size"
	varies from 2 through (incremented) pixel, a maximum of 8.
	The LZW code data starts out 1 bit wider than the GIF "code
	size", and grows occasionally, up to 12 bits per code "chunk".
	LZW codes from 0 through (clear_code-1) are raw colormap
	index values, while those from clear_code on up are indices
	into the string-chaining table.

	This is my own implementation, using recursion instead of an
	explicit stack to expand the strings.
 */

static int	code_size;		/* initial LZW chunk size, in bits */
static int	chunk_size;		/* current LZW chunk size, in bits */
static int	chunk_mask;		/* bit mask for extracting chunks */
static int	compress_code;		/* first compression code value */
static int	k;			/* extension character */
static struct
	{
	short		pfx;		/* prefix string's table index */
	short		ext;		/* extension value */
	}	table[1 << 12];		/* big enough for 12-bit codes */
/* Unlike the example in Welch's paper, our table contains no atomic values. */

static int	bytecnt;		/* # of bytes remaining in block */
static int	rem_bits;		/* data bits left over from last call */
static int	bits_on_hand;		/* # of bits left over from last call */


static int
GetCode(void)
{
	register int	next_val;

	while ( bits_on_hand < chunk_size )
		{
		/* Read 8 more bits from the GIF file. */

		while ( bytecnt == 0 )
			{
			/* Start new data block. */

			if ( (bytecnt = getc( gfp )) == EOF )
				Fatal( "%s at start of new LZW data block",
				       feof( gfp ) ? "EOF" : "Error"
				     );

			if ( bytecnt == 0 )
				Message( "Warning: 0-byte data block" );
			/* Should this abort the image?  GIF spec is unclear. */
			}

		if ( (next_val = getc( gfp )) == EOF )
			Fatal( "%s while reading LZW data block",
			       feof( gfp ) ? "EOF" : "Error"
			     );

		--bytecnt;		/* used up another byte of input */
		rem_bits |= next_val << bits_on_hand;
		bits_on_hand += 8;
		}

	/* Now have enough bits to extract the next LZW code. */

	next_val = rem_bits & chunk_mask;

	/* Prepare for next entry. */

	rem_bits >>= chunk_size;
	bits_on_hand -= chunk_size;

	return next_val;
	}


#ifdef	USE_RECURSION

/* WARNING:  This recursion could get pretty deep (2047 nested calls)! */
static void
Expand( c )
	register int	c;		/* LZW code */
	{
	if ( c < compress_code )	/* "atomic", i.e. raw color index */
		PutPixel( k = c );	/* first atom in string */
	else	{			/* "molecular"; follow chain */
		Expand( table[c].pfx );
		PutPixel( table[c].ext );
		}
	}

#else	/* The non-recursive version is usually faster. */

static short	exp_buffer[(1 << 11) - 2];	/* reverse-order atomic codes */

/* Non-recursive version, for wimpy systems: */
static void
Expand(register int c)
	            	  		/* LZW code */
	{
	register short	*bp = exp_buffer;

	while ( c >= compress_code )	/* "molecular"; follow chain */
		{
		assert(bp < &exp_buffer[2046]);	
		*bp++ = table[c].ext;
		c = table[c].pfx;
		}

	/* current `c' is "atomic", i.e. raw color index */

	PutPixel( k = c );		/* first atom in string */

	while ( bp > exp_buffer )
		PutPixel( (int)*--bp );
	}

#endif	/* USE_RECURSION */


static void
LZW(void)
{
	register int	c;		/* input LZW code, also input byte */
	register int	w;		/* prefix code */
	register int	next_code;	/* next available table index */
	register int	max_code;	/* limit at which LZW chunk must grow */
	int		eoi_code;	/* end of LZW stream */
	int		clear_code;	/* table reset code */

	if ( (code_size = getc( gfp )) == EOF )
		Fatal( "Error reading code size" );

	if ( code_size < pixel )
		Message( "Warning: initial code size smaller than colormap" );

	if ( code_size > pixel && !(pixel == 1 && code_size == 2) )
		Message( "Warning: initial code size greater than colormap" );
	/* This case will probably eventually trigger Fatal() in PutPixel(). */

	/* Initialize GetCode() parameters. */

	bytecnt = 0;			/* need a new data block */
	bits_on_hand = 0;		/* there was no "last call" */

	/* Initialize LZW algorithm parameters. */

	clear_code = 1 << code_size;
	eoi_code = clear_code + 1;
	compress_code = clear_code + 2;

	if ( (chunk_size = code_size + 1) > 12 )	/* LZW chunk size */
		Fatal( "GIF spec's LZW code size limit (12) violated" );

	max_code = 1 << chunk_size;	/* LZW chunk will grow at this point */
	chunk_mask = max_code - 1;
	next_code = compress_code;	/* empty chain-code table */
	w = -1;				/* we use -1 for "nil" */

	while ( (c = GetCode()) != eoi_code )
		if ( c == clear_code )
			{
			/* Reinitialize LZW parameters. */

			chunk_size = code_size + 1;
			max_code = 1 << chunk_size;	/* growth trigger */
			chunk_mask = max_code - 1;
			next_code = compress_code;	/* empty code table */
			w = -1;		/* we use -1 for "nil" */
			}
		else	{
			if ( c > next_code )
				Fatal("LZW code impossibly large  (%x > %x, diff: %d)",
					c, next_code, c-next_code);

			if ( c == next_code )
				{	/* KwKwK special case */
				if ( w < 0 )	/* w supposedly previous code */
					Fatal( "initial LZW KwKwK code??" );

				Expand( w );	/* sets `k' */
				PutPixel( k );
				}
			else		/* normal case */
				Expand( c );	/* sets `k' */

			if ( w >= 0 && next_code < 1 << 12 )
				{
				table[next_code].pfx = w;
				table[next_code].ext = k;

				if ( ++next_code == max_code
				  && chunk_size < 12
				   )	{
					++chunk_size;
					max_code <<= 1;
					chunk_mask = max_code - 1;
					}
				}

			w = c;
			}

	/* EOI code encountered. */

	if ( bytecnt > 0 )
		{
		Message( "Warning: unused raster data present" );

		do
			if ( (c == getc( gfp )) == EOF )
				Fatal( "Error reading extra raster data" );
		while ( --bytecnt > 0 );
		}

	/* Strange data format in the GIF spec! */

	if ( (c = getc( gfp )) != 0 )
		Fatal( "Zero byte count missing" );
	}


static void
Rasters(void)				/* process (convert) raster data */
	{
	/* Initialize inverted-loop parameters. */

	pass = I_bit ? 0 : 4;		/* current pass */
	stop = I_bit ? 4 : 5;		/* final pass + 1 */

	row = top + start_row[pass];	/* next pixel row */
	col = left;			/* next pixel column */

	/* Process rasters in possibly interlaced order. */

	LZW();				/* uncompress LZW data & write pixels */
	}


int
main(int argc, char **argv)
{
	/* Plant signal catcher. */
	{
	static int	getsigs[] =	/* signals to catch */
		{
		SIGHUP,			/* hangup */
		SIGINT,			/* interrupt */
		SIGQUIT,		/* quit */
		SIGPIPE,		/* write on a broken pipe */
		SIGTERM,		/* software termination signal */
		0
		};
	register int	i;

	for ( i = 0; getsigs[i] != 0; ++i )
		if ( signal( getsigs[i], SIG_IGN ) != SIG_IGN )
			(void)signal( getsigs[i], Sig_Catcher );
	}

	/* Process arguments. */

	arg0 = Simple( argv[0] );	/* save for possible error message */

	{
		register int	c;
		register bool	errors = false;

		while ( (c = getopt( argc, argv, OPTSTR )) != EOF )
			switch( c )
				{
			default:	/* '?': invalid option */
				errors = true;
				break;

			case 'F':	/* -F fb_file */
				fb_file = optarg;
				break;

			case 'c':	/* -c */
				ign_cr = true;
				break;

			case 'i':	/* -i image# */
				image = atoi( optarg );
				break;

			case 'o':	/* -o */
				clear = false;
				break;

			case 'v':	/* -v */
				verbose = true;
				break;
			case 'z':
				do_zoom = true;
				break;
				}

		if ( errors )
			Fatal( "Usage: %s", USAGE );
	}

	if ( optind < argc )		/* gif_file */
		{
		if ( optind < argc - 1 )
			{
			Message( "Usage: %s", USAGE );
			Fatal( "Can't handle multiple GIF files" );
			}

		if ( (gfp = fopen( gif_file = argv[optind], RBMODE )) == NULL )
			Fatal( "Couldn't open GIF file \"%s\"", gif_file );
		}
	else
		gfp = stdin;

	/* Process GIF signature. */

	{
		/* Scan until "GIF" seen, to skip over additional headers
		   (e.g., from Macintosh BBSes). */

		register int	state;	/* FSA state */
#define			ST_INITIAL	0	/* initial state of FSA */
#define			ST_G_SEEN	1	/* just after 'G' */
#define			ST_I_SEEN	2	/* just after 'I' */
#define			ST_F_SEEN	3	/* just after 'F' */

		for ( state = ST_INITIAL; state != ST_F_SEEN; )
			/* In theory, the signature should be mapped to ASCII
			   as it is read.  However, non-ASCII systems are
			   expected to have other problems anyway, so we don't
			   worry about that in this implementation. */

			switch ( getc( gfp ) )
				{
			case EOF:
				Fatal( "File does not contain \"GIF\" header" );

			case 'G':
				state = ST_G_SEEN;
				break;

			case 'I':
				if ( state != ST_G_SEEN )
					state = ST_INITIAL;
				else
					state = ST_I_SEEN;
				break;

			case 'F':
				if ( state != ST_I_SEEN )
					state = ST_INITIAL;
				else	{
					char	ver[3];
					/* GIF version (assume 8-bit bytes) */

					state = ST_F_SEEN;	/* ends loop */

					if ( fread( ver, 1, 3, gfp ) != 3 )
						Fatal(
						   "Error reading GIF signature"
						     );

					if ( strncmp( ver, "87a", 3 ) != 0 )
						Message(
			     "GIF version \"%3.3s\" not known, \"87a\" assumed",
							 ver
						       );
					}
				break;
				}
	}

	/* Process screen descriptor. */

	{
		unsigned char	desc[7];	/* packed screen descriptor */

		if ( fread( desc, 1, 7, gfp ) != 7 )
			Fatal( "Error reading screen descriptor" );

		width = desc[1] << 8 | desc[0];
		height = desc[3] << 8 | desc[2];
		M_bit = (desc[4] & 0x80) != 0;
		cr = (desc[4] >> 4 & 0x07) + 1;
		g_pixel = (desc[4] & 0x07) + 1;
		background = desc[5];

		if ( verbose )
			{
			Message( "screen %dx%d", width, height );

			if ( M_bit )
				Message( "global color map provided" );

			Message( "%d bits of color resolution", cr );
			Message( "%d default bits per pixel", g_pixel );
			Message( "background color index %d", background );
			}

		if ( (desc[5] & 0x08) != 0x00 )
			Message( "Screen descriptor byte 6 bit 3 unknown" );

		if ( desc[6] != 0x00 )
			Message( "Screen descriptor byte 7 = %2.2x unknown",
				 desc[6]
			       );

		if ( ign_cr )
			cr = 8;		/* override value from GIF file */
	}

	/* Process global color map. */

	if ( (g_cmap = (RGBpixel *)malloc( 256 * sizeof(RGBpixel) )) == NULL
	  || (cmap = (RGBpixel *)malloc( 256 * sizeof(RGBpixel) )) == NULL
	   )
		Fatal( "Insufficient memory for color maps" );

	entries = 1 << g_pixel;

	if ( M_bit )
		{
		register int	i;
		register double	expand;	/* dynamic range expansion factor ~ 1 */

		/* Read in global color map. */

		if ( verbose )
			Message( "global color map has %d entries", entries );

		if ( fread( g_cmap, 3, entries, gfp ) != entries )
			Fatal( "Error reading global color map" );

		/* Mask off low-order "noise" bits found in some GIF files,
		   and expand dynamic range to support pure white and black. */

		if ( cr == 8 )
			cr_mask = ~0;	/* shift by 0 can tickle compiler bug */
		else
			cr_mask = ~0 << (8 - cr);

		expand = 255.0 / (double)(0xFF & cr_mask);

		for ( i = 0; i < entries; ++i )
			{
			g_cmap[i][RED] = (((int)g_cmap[i][RED]) & cr_mask) * expand
				       + 0.5;
			g_cmap[i][GRN] = (((int)g_cmap[i][GRN]) & cr_mask) * expand
				       + 0.5;
			g_cmap[i][BLU] = (((int)g_cmap[i][BLU]) & cr_mask) * expand
				       + 0.5;
			}
		}
	else	{
		register int	i;

		/* Set up default linear grey scale global color map.
		   GIF specs for this case are utterly nonsensical. */

		if ( verbose )
			Message( "default global color map has %d grey values",
				 entries
			       );

		for ( i = 0; i < entries; ++i )
			g_cmap[i][RED] =
			g_cmap[i][GRN] =
			g_cmap[i][BLU] = i * 255.0 / (entries - 1) + 0.5;
		}

	/* Open frame buffer for unbuffered output. */

	if ( (pixbuf = (unsigned char *)malloc( width * sizeof(RGBpixel) )) == NULL )
		Fatal( "Insufficient memory for scan line buffer" );

	if ( (fbp = fb_open( fb_file, width, height )) == FBIO_NULL )
		Fatal( "Couldn't open frame buffer" );

	{
		register int	wt = fb_getwidth( fbp );
		int zoom;

		ht = fb_getheight( fbp );

		if ( wt < width || ht < height )
			Message( "Frame buffer too small (%dx%d); %dx%d needed",
			       wt, ht, width, height
			     );

		if ( verbose && (wt > width || ht > height) )
			Message( "Frame buffer (%dx%d) larger than GIF screen",
				 wt, ht
			       );

		write_width = width;
		if( write_width > wt )  write_width = wt;

		zoom = fb_getwidth(fbp)/width;
		if( fb_getheight(fbp)/height < zoom )
			zoom = fb_getheight(fbp)/height;
		if( do_zoom && zoom > 1 )  {
			(void)fb_view( fbp, width/2, height/2,
				zoom, zoom );
		} else {
			/* Unzoomed, full screen */
			(void)fb_view( fbp,
				fb_getwidth(fbp)/2, fb_getheight(fbp)/2,
				1, 1 );
		}

		ht = height - 1;	/* for later use as (ht - row) */
	}

	/* Fill frame buffer with background color. */

	if ( clear && fb_clear( fbp, g_cmap[background] ) == -1 )
		Fatal( "Error clearing frame buffer to background" );

	/* Fill scanline buffer with background color too */
	{
		register int i;
		for( i=0 ; i < width; i++ )  {
			COPYRGB(&pixbuf[i*3], g_cmap[background]);
		}
	}

	/* Convert images.  GIF spec says no pauses between them. */

	for ( ; ; )
		{
		register int	c;

		if ( (c = getc( gfp )) == EOF )  {
			Fatal( "Missing GIF terminator" );
			break;
		}

		switch( c )
			{
		default:
			Message( "Warning: unknown separator 0x%2.2x", c );
			continue;	/* so says the GIF spec */

		case GIF_TERMINATOR:	/* GIF terminator */
    terminate:
			/* GIF spec suggests pause and wait for go-ahead here,
			   also "screen clear", but they're impractical. */

			if ( fb_close( fbp ) == -1 )
				{
				fbp = FBIO_NULL;	/* avoid second try */
				Fatal( "Error closing frame buffer" );
				}

			fbp = FBIO_NULL;

			if ( image > 0 )
				Fatal( "Specified image not found" );

			exit( EXIT_SUCCESS );

		case GIF_EXTENSION:	/* GIF extension block introducer */
			{
			register int	i;

			if ( (i = getc( gfp )) == EOF )
				Fatal( "Error reading extension function code"
				     );

			Message( "Extension function code %d unknown", i );

			while ( (i = getc( gfp )) != 0 )
				{
				if ( i == EOF )
					Fatal(
				      "Error reading extension block byte count"
					     );

				do
					if ( getc( gfp ) == EOF )
						Fatal(
						 "Error reading extension block"
						     );
				while ( --i > 0 );
				}
			}
			break;

		case GIF_IMAGE:		/* image separator */
			{
				unsigned char	desc[9];  /* image descriptor */

				if ( fread( desc, 1, 9, gfp ) != 9 )
					Fatal( "Error reading image descriptor"
					     );

				left = desc[1] << 8 | desc[0];
				top = desc[3] << 8 | desc[2];
				right = desc[5] << 8 | desc[4];
				bottom = desc[7] << 8 | desc[6];
				M_bit = (desc[8] & 0x80) != 0;
				I_bit = (desc[8] & 0x40) != 0;

				pixel = M_bit ? (desc[8] & 0x07) + 1 : g_pixel;

				if ( verbose )
					{
					Message( "image (%d,%d,%d,%d)",
						 left, top, right, bottom
					       );

					if ( M_bit )
						{
						Message(
						      "local color map provided"
						       );
						Message( "%d bits per pixel",
							 pixel
						       );
						}

					Message( I_bit ? "interlaced"
						       : "sequential"
					       );
					}

				if ( left < 0 || right > width || left >= right
				  || top < 0 || bottom > height || top >= bottom
				   )
					Fatal( "Absurd image (%d,%d,%d,%d)",
					       left, top, right, bottom
					     );
			}

			/* Process local color map. */

			entries = 1 << pixel;

			if ( M_bit )
				{
				register int	i;
				register double	expand;	/* range expansion */

				/* Read in local color map. */

				if ( verbose )
					Message(
					       "local color map has %d entries",
						 entries
					       );

				if ( fread( cmap, 3, entries, gfp ) != entries )
					Fatal( "Error reading local color map"
					     );

				/* Mask off low-order "noise" bits,
				   and expand dynamic range. */

				expand = 255.0 / (double)(0xFF & cr_mask);

				for ( i = 0; i < entries; ++i )
					{
					cmap[i][RED] = (((int)cmap[i][RED]) & cr_mask)
						     * expand + 0.5;
					cmap[i][GRN] = (((int)cmap[i][GRN]) & cr_mask)
						     * expand + 0.5;
					cmap[i][BLU] = (((int)cmap[i][BLU]) & cr_mask)
						     * expand + 0.5;
					}
				}
			else	{
				/* Use default global color map. */

				if ( verbose )
					Message( "global color map used" );

				(void)bcopy( (char *)g_cmap, (char *)cmap, 3 * entries );
				}

			/* `image' is 0 if all images are to be displayed;
			   otherwise it is a down-counter to the image wanted */
			if ( image <= 1 )
				{
				Rasters();	/* process the raster data */

				if ( image != 0 )
					goto terminate;	/* that's all, folks */
				}
			else	{
				--image;	/* desperately seeking Susan? */
				Skip();	/* skip over the raster data */
				}

			break;
			}
		}
	/* [not reached] */
	exit(1);
	}
@


11.7
log
@change conf.h to a wrapped config.h
@
text
@d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/fb/gif-fb.c,v 11.6 2004/04/05 07:49:23 morrison Exp $ (BRL)";
@


11.6
log
@merge of ansi-6-0-branch into HEAD
@
text
@d46 1
a46 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d52 5
a56 1
#include "conf.h"
@


11.5
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/gif-fb.c,v 11.3 2001/08/10 21:27:04 butler Exp $ (BRL)";
d121 2
a122 3
Simple( path )
	char		*path;
	{
d130 2
a131 4
VMessage( format, ap )
	char	*format;
	va_list	ap;
	{
d203 2
a204 3
Sig_Catcher( sig )
	int	sig;
	{
d213 1
a213 1
Skip()					/* skip over raster data */
d245 2
a246 3
PutPixel( value )
	register int	value;
	{
d315 2
a316 2
GetCode()
	{
d381 2
a382 2
Expand( c )
	register int	c;		/* LZW code */
d405 2
a406 2
LZW()
	{
d507 1
a507 1
Rasters()				/* process (convert) raster data */
d524 2
a525 4
main( argc, argv )
	int	argc;
	char	*argv[];
	{
@


11.5.2.1
log
@Initial ANSIfication
@
text
@d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/gif-fb.c,v 11.5 2002/08/20 17:07:25 jra Exp $ (BRL)";
d121 3
a123 2
Simple(char *path)
{
d131 4
a134 2
VMessage(char *format, va_list ap)
{
d206 3
a208 2
Sig_Catcher(int sig)
{
d217 1
a217 1
Skip(void)					/* skip over raster data */
d249 3
a251 2
PutPixel(register int value)
{
d320 2
a321 2
GetCode(void)
{
d386 2
a387 2
Expand(register int c)
	            	  		/* LZW code */
d410 2
a411 2
LZW(void)
{
d512 1
a512 1
Rasters(void)				/* process (convert) raster data */
d529 4
a532 2
main(int argc, char **argv)
{
@


11.4
log
@Converted from K&R to ANSI C - RFH
@
text
@d121 3
a123 2
Simple(char *path)
{
d131 4
a134 2
VMessage(char *format, va_list ap)
{
d206 3
a208 2
Sig_Catcher(int sig)
{
d217 1
a217 1
Skip(void)					/* skip over raster data */
d249 3
a251 2
PutPixel(register int value)
{
d320 2
a321 2
GetCode(void)
{
d386 2
a387 2
Expand(register int c)
	            	  		/* LZW code */
d410 2
a411 2
LZW(void)
{
d512 1
a512 1
Rasters(void)				/* process (convert) raster data */
d529 4
a532 2
main(int argc, char **argv)
{
@


11.3
log
@Misc compiler warning fixes
@
text
@d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/gif-fb.c,v 11.2 2001/04/12 17:44:08 bparker Exp $ (BRL)";
d121 2
a122 3
Simple( path )
	char		*path;
	{
d130 2
a131 4
VMessage( format, ap )
	char	*format;
	va_list	ap;
	{
d203 2
a204 3
Sig_Catcher( sig )
	int	sig;
	{
d213 1
a213 1
Skip()					/* skip over raster data */
d245 2
a246 3
PutPixel( value )
	register int	value;
	{
d315 2
a316 2
GetCode()
	{
d381 2
a382 2
Expand( c )
	register int	c;		/* LZW code */
d405 2
a406 2
LZW()
	{
d507 1
a507 1
Rasters()				/* process (convert) raster data */
d524 2
a525 4
main( argc, argv )
	int	argc;
	char	*argv[];
	{
@


11.2
log
@*- get rid of warnings
@
text
@d46 1
a46 2
static char	RCSid[] =		/* for "what" utility */
	"@@(#)$Header: /c/CVS/brlcad/fb/gif-fb.c,v 11.1 1995/01/04 10:09:34 mike Rel4_4 $ (BRL)";
@


11.1
log
@Release_4.4
@
text
@d47 1
a47 1
	"@@(#)$Header: /m/cad/fb/RCS/gif-fb.c,v 10.6 94/12/30 03:27:50 mike Exp $ (BRL)";
d694 1
a694 1
		if ( desc[5] & 0x08 != 0x00 )
d734 1
a734 1
			cr_mask = ~0 << 8 - cr;
@


10.6
log
@DEC Alpha
@
text
@d47 1
a47 1
	"@@(#)$Header: /m/cad/fb/RCS/gif-fb.c,v 10.5 94/11/14 22:27:56 mike Exp Locker: mike $ (BRL)";
@


10.5
log
@Irix 6
@
text
@d47 1
a47 1
	"@@(#)$Header: /m/cad/fb/RCS/gif-fb.c,v 10.4 94/08/23 18:49:12 gdurf Exp Locker: mike $ (BRL)";
d971 1
a971 1
				(void)bcopy( g_cmap, cmap, 3 * entries );
@


10.4
log
@Added includes, factored ifdefs
@
text
@d47 1
a47 1
	"@@(#)$Header: /m/cad/fb/RCS/gif-fb.c,v 10.3 1994/08/11 15:06:13 mike Exp gdurf $ (BRL)";
a965 2
				register int	i;

@


10.3
log
@Reduced use of RGBpixel
Now use (unsigned char *)
@
text
@d47 1
a47 1
	"@@(#)$Header: /m/cad/fb/RCS/gif-fb.c,v 10.2 92/10/10 03:11:43 mike Exp Locker: mike $ (BRL)";
d53 1
a53 9
#ifdef BSD	/* BRL-CAD */
#define	NO_VFPRINTF	1
#define	NO_MEMCPY	1
#define	NO_STRRCHR	1
#endif

#if defined(sgi) && !defined(mips)	/* Not all SYSVs are perfect */
#define	NO_VFPRINTF	1
#endif
d61 3
a63 1
#ifdef BSD
a64 2
#else
#include	<string.h>
d66 1
a66 4
#include "machine.h"
#include "externs.h"

#if __STDC__
d70 1
a70 5
# ifdef NO_MEMCPY
#  define	memcpy( s1, s2, n )	bcopy( s2, s1, n )
# else
#  include	<memory.h>
# endif
a71 1
# define	RBMODE	"r"
d74 5
a84 4
extern char	*optarg;
extern int	optind;

#include	<fb.h>			/* BRL CAD package libfb.a interface */
d137 1
a137 1
#ifdef NO_VFPRINTF
d150 1
a150 1
#if __STDC__
d159 1
a159 1
#if !__STDC__
d164 1
a164 1
#if __STDC__
d175 1
a175 1
#if __STDC__
d184 1
a184 1
#if !__STDC__
d189 1
a189 1
#if __STDC__
d973 1
a973 1
				(void)memcpy( cmap, g_cmap, 3 * entries );
@


10.2
log
@Modified so that if GIF file is wider than the framebuffer,
it does not write those pixels.  They just wrap around
and slow things down.
@
text
@d47 1
a47 1
	"@@(#)$Header: /m/cad/fb/RCS/gif-fb.c,v 10.1 91/10/12 06:46:40 mike Rel4_0 Locker: mike $ (BRL)";
d261 1
a261 1
static RGBpixel	*pixbuf;		/* malloc()ed scan line buffer */
d274 3
a276 3
	pixbuf[col][RED] = cmap[value][RED];	/* stuff pixel */
	pixbuf[col][GRN] = cmap[value][GRN];
	pixbuf[col][BLU] = cmap[value][BLU];
d782 1
a782 1
	if ( (pixbuf = (RGBpixel *)malloc( width * sizeof(RGBpixel) )) == NULL )
d832 1
a832 1
			COPYRGB(pixbuf[i], g_cmap[background]);
@


10.1
log
@Release_4.0
@
text
@d47 1
a47 1
	"@@(#)$Header: /m/cad/fb/RCS/gif-fb.c,v 9.9 91/08/29 23:55:18 mike Exp $ (BRL)";
d117 1
d286 1
a286 1
		if ( fb_write( fbp, 0, ht - row, pixbuf, width ) < 0
d803 3
@


9.9
log
@Stardent ANSI C
@
text
@d47 1
a47 1
	"@@(#)$Header: /m/cad/fb/RCS/gif-fb.c,v 9.8 91/08/29 23:53:26 mike Exp $ (BRL)";
@


9.8
log
@Fixed Stardent problems with includes
@
text
@d47 1
a47 1
	"@@(#)$Header: /m/cad/fb/RCS/gif-fb.c,v 9.7 91/06/29 22:52:13 mike Exp $ (BRL)";
d754 1
a754 1
			g_cmap[i][RED] = (g_cmap[i][RED] & cr_mask) * expand
d756 1
a756 1
			g_cmap[i][GRN] = (g_cmap[i][GRN] & cr_mask) * expand
d758 1
a758 1
			g_cmap[i][BLU] = (g_cmap[i][BLU] & cr_mask) * expand
d968 1
a968 1
					cmap[i][RED] = (cmap[i][RED] & cr_mask)
d970 1
a970 1
					cmap[i][GRN] = (cmap[i][GRN] & cr_mask)
d972 1
a972 1
					cmap[i][BLU] = (cmap[i][BLU] & cr_mask)
@


9.7
log
@Eliminted SGI optimizer gripe
@
text
@d47 1
a47 1
	"@@(#)$Header: /m/cad/util/RCS/gif-fb.c,v 9.6 91/03/30 01:14:15 butler Exp $ (BRL)";
d74 3
d78 2
a79 6
#include	<stdarg.h>
#include	<stdlib.h>
#if __STDC__ == 1	/* workaround for Cray nonsense */
extern int	getopt( int, char const * const *, char const * );
#endif
#define	RBMODE	"rb"			/* "b" not really necessary for POSIX */
d81 7
a87 2
#ifdef NO_STRRCHR
#define	strrchr( s, c )		rindex( s, c )
d89 1
a89 11
#ifdef NO_MEMCPY
#define	memcpy( s1, s2, n )	bcopy( s2, s1, n )
#else
#include	<memory.h>
#endif
#include	<varargs.h>
#define	RBMODE	"r"
extern void	exit();
extern char	*malloc();
extern int	getopt();
#endif
@


9.6
log
@changed to print codes when "LZW code impossibly large" to see if we can
characterize this sort of error over time.
@
text
@d47 1
a47 1
	"@@(#)$Header: /m/cad/util/RCS/gif-fb.c,v 9.5 91/01/11 00:28:26 mike Exp $ (BRL)";
d844 1
a844 1
		if ( (c = getc( gfp )) == EOF )
d846 2
d1011 1
@


9.5
log
@Modified to write background color on the borders of each scanline.
@
text
@d47 1
a47 1
	"@@(#)$Header: /m/cad/util/RCS/gif-fb.c,v 9.4 91/01/10 21:44:00 mike Exp $ (BRL)";
d482 2
a483 1
				Fatal( "LZW code impossibly large" );
@


9.4
log
@Added -z (zoom) feature.
@
text
@d47 1
a47 1
	"@@(#)$Header: /m/cad/util/RCS/gif-fb.c,v 9.3 90/08/22 02:10:43 butler Exp $ (BRL)";
d279 3
a281 3
	pixbuf[col - left][RED] = cmap[value][RED];	/* stuff pixel */
	pixbuf[col - left][GRN] = cmap[value][GRN];
	pixbuf[col - left][BLU] = cmap[value][BLU];
d291 1
a291 1
		if ( fb_write( fbp, left, ht - row, pixbuf, right - left ) == -1
d828 8
@


9.3
log
@changed so that program doesn't bomb on gif images bigger than frame buffer
@
text
@d40 2
d47 1
a47 1
	"@@(#)$Header: /m/cad/util/RCS/gif-fb.c,v 9.2 90/02/05 17:21:55 gwyn Exp $ (BRL)";
d50 2
a51 2
#define	USAGE	"gif-fb [-F fb_file] [-c] [-i image#] [-o] [-v] [gif_file]"
#define	OPTSTR	"F:ci:ov"
d115 1
d605 3
d794 1
d808 13
a822 3

	if ( fb_wmap( fbp, (ColorMap *)NULL ) == -1 )
		Fatal( "Error setting up linear color map" );
@


9.2
log
@added -c option
@
text
@d45 1
a45 1
	"@@(#)$Header: gif-fb.c,v 9.1 89/05/19 06:09:25 gwyn Locked $ (BRL)";
d290 1
a290 1
			Fatal( "Error writing scan line to frame buffer" );
d792 1
a792 1
			Fatal( "Frame buffer too small (%dx%d); %dx%d needed",
@


9.1
log
@Release_3.5
@
text
@d6 2
a7 2
	Typical compilation:	cc -O -I/usr/include/brlcad -o gif2fb \
					gif2fb.c /usr/brlcad/lib/libfb.a
d28 3
d45 1
a45 1
	"@@(#)$Header: gif-fb.c,v 1.7 89/05/08 17:51:33 phil Exp $ (BRL)";
d48 2
a49 2
#define	USAGE	"gif-fb [ -F fb_file ] [ -i image# ] [ -o ] [ -v ] [ gif_file ]"
#define	OPTSTR	"F:i:ov"
d111 1
d587 4
d625 2
a626 1
		char	sig[6];		/* GIF signature (assume 8-bit bytes) */
d628 5
a632 2
		if ( fread( sig, 1, 6, gfp ) != 6 )
			Fatal( "Error reading GIF signature" );
d634 5
a638 1
		/* In theory, the signature should be mapped to ASCII here. */
d640 4
a643 3
		if ( strncmp( sig, "GIF", 3 ) != 0 )
			/* We could scan until "GIF" is seen, but why bother. */
			Fatal( "File does not start with \"GIF\"" );
d645 27
a671 2
		if ( strncmp( &sig[3], "87a", 3 ) != 0 )
			Message(
d673 5
a677 2
				 &sig[3]
			       );
d714 3
d731 1
a731 1
		register double	expand;	/* dynamic range expansion factor */
d744 5
a748 1
		cr_mask = ~0 << 8 - cr;
@


1.7
log
@redid string[s].h fix!
@
text
@d42 1
a42 1
	"@@(#)$Header: gif-fb.c,v 1.6 89/05/08 17:18:07 phil Locked $ (BRL)";
@


1.6
log
@*** empty log message ***
@
text
@d42 1
a42 1
	"@@(#)$Header: gif-fb.c,v 1.4 89/05/05 16:47:04 gwyn Exp $ (BRL)";
d64 3
d68 1
@


1.5
log
@string[s].h
@
text
@d42 1
a42 1
	"@@(#)$Header: gif-fb.c,v 1.4 89/05/05 16:47:04 phil Locked $ (BRL)";
a63 3
#ifdef BSD
#include	<strings.h>
#else
a64 1
#endif
d68 3
d85 1
d94 1
a94 1
extern int	getopt(), optind;
@


1.4
log
@expand dynamic range
@
text
@d42 1
a42 1
	"@@(#)$Header: gif-fb.c,v 1.2 89/04/26 20:09:12 gwyn Locked $ (BRL)";
d64 3
d68 1
@


1.3
log
@*** empty log message ***
@
text
@d467 1
a467 1
				Fatal( "LZW code too large" );
d675 1
d685 2
a686 1
		/* Mask off low-order "noise" bits found in some GIF files. */
d689 1
d693 6
a698 3
			g_cmap[i][RED] &= cr_mask;
			g_cmap[i][GRN] &= cr_mask;
			g_cmap[i][BLU] &= cr_mask;
d715 1
a715 1
			g_cmap[i][BLU] = i * 256.0 / entries + 0.5;
d865 1
d879 2
a880 1
				/* Mask off low-order "noise" bits. */
d882 2
d886 6
a891 3
					cmap[i][RED] &= cr_mask;
					cmap[i][GRN] &= cr_mask;
					cmap[i][BLU] &= cr_mask;
@


1.2
log
@SGI 3-d machines do not have vfprintf()
@
text
@d4 1
a4 1
	created:	89/04/26	D A Gwyn
d24 1
a24 4
	-d		"debug": prints information about the images on
			the standard error output

	-f fb_file	outputs to the specified frame buffer file instead
a27 2
	-F fb_file	same as -f fb_file (BRL-CAD package compatibility)

d34 3
d41 2
a42 2
static char RCSid[] = "@@(#)$Header: gif-fb.c,v 1.1 89/04/26 17:06:26 mike Locked $ (BRL)";
static char	SCCSid[] = "%W% %E%";	/* for "what" utility */
d45 2
a46 2
#define	USAGE	"gif-fb [ -d ] [ -f fb_file ] [ -i image# ] [ -o ] [ gif_file ]"
#define	OPTSTR	"df:F:i:o"
d58 4
d71 1
a71 1
#define	strrchr( s, c )	rindex( s, c )
d74 1
a74 31
static char *
memcpy( s1, s2, n )			/* not a complete implementation! */
	register char	*s1, *s2;
	int		n;
	{
	register int	m = (n + 7) / 8;	/* wide-path loop counter */

	switch ( n & 7 )		/* same as ( n % 8 ) */
		/* Loop unrolling a la "Duff's device": */
		do	{
	case 0:
			*s1++ = *s2++;
	case 7:
			*s1++ = *s2++;
	case 6:
			*s1++ = *s2++;
	case 5:
			*s1++ = *s2++;
	case 4:
			*s1++ = *s2++;
	case 3:
			*s1++ = *s2++;
	case 2:
			*s1++ = *s2++;
	case 1:
			*s1++ = *s2++;
			}
		while ( --m > 0 );

	return 0;
	}
d100 1
a100 1
static bool	debug = false;		/* set for GIF-file debugging info */
d315 2
a316 2
	int		pfx;		/* prefix string's table index */
	int		ext;		/* extension value */
d371 3
a373 1
/* WARNING:  This recursion could get pretty deep (4093 nested calls)! */
d386 1
d388 3
d392 24
d567 1
a567 2
			default:	/* just in case */
			case '?':	/* invalid option */
a570 5
			case 'd':	/* -d */
				debug = true;
				break;

			case 'f':	/* -f fb_file */
d582 4
d642 1
a642 1
		if ( debug )
d678 1
a678 1
		if ( debug )
d701 1
a701 1
		if ( debug )
d730 5
d823 1
a823 1
				if ( debug )
d862 1
a862 1
				if ( debug )
d886 1
a886 1
				if ( debug )
@


1.1
log
@Initial revision
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 8.2 89/04/11 22:15:25 phil Exp $ (BRL)";
d54 4
@
