head	11.8;
access;
symbols
	ansi-20040405-merged:11.4.2.2
	postmerge-20040405-ansi:11.6
	premerge-20040404-ansi:11.5
	postmerge-autoconf:11.5
	autoconf-freeze:11.4.10.1
	premerge-autoconf:11.5
	ansi-20040316-freeze:11.4.2.1
	postmerge-20040315-windows:11.5
	premerge-20040315-windows:11.5
	windows-20040315-freeze:11.4.4.1
	autoconf-20031203:11.4
	autoconf-20031202:11.4
	autoconf-branch:11.4.0.10
	phong-branch:11.4.0.8
	photonmap-branch:11.4.0.6
	rel-6-1-DP:11.4
	windows-branch:11.4.0.4
	rel-6-0-2:11.2
	ansi-branch:11.4.0.2
	rel-6-0-1-branch:11.2.0.2
	hartley-6-0-post:11.3
	hartley-6-0-pre:11.2
	rel-6-0-1:11.2
	rel-6-0:11.2
	rel-5-4:11.1
	offsite-5-3-pre:11.1
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:5.1
	rel-1-24:5.1
	rel-1-20:4.3;
locks; strict;
comment	@ * @;


11.8
date	2004.05.24.04.13.26;	author morrison;	state dead;
branches;
next	11.7;

11.7
date	2004.05.10.15.30.42;	author erikg;	state Exp;
branches;
next	11.6;

11.6
date	2004.04.05.07.49.23;	author morrison;	state Exp;
branches;
next	11.5;

11.5
date	2004.02.02.17.39.01;	author morrison;	state Exp;
branches;
next	11.4;

11.4
date	2002.08.20.17.07.25;	author jra;	state Exp;
branches
	11.4.2.1
	11.4.4.1
	11.4.10.1;
next	11.3;

11.3
date	2002.08.15.20.54.38;	author hartley;	state Exp;
branches;
next	11.2;

11.2
date	2001.04.12.17.44.08;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.09.26;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.08.11.19.25.05;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.08.11.15.06.08;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.46.31;	author mike;	state Rel4_0;
branches;
next	9.2;

9.2
date	90.04.23.15.32.47;	author phil;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.09.03;	author mike;	state Rel3_5;
branches;
next	8.1;

8.1
date	88.10.05.00.41.45;	author mike;	state Rel3_0;
branches;
next	7.14;

7.14
date	88.09.17.03.37.48;	author mike;	state Exp;
branches;
next	7.13;

7.13
date	88.09.02.15.08.41;	author phil;	state Exp;
branches;
next	7.12;

7.12
date	88.07.29.03.15.21;	author phil;	state Exp;
branches;
next	7.11;

7.11
date	88.07.19.16.12.43;	author mike;	state Exp;
branches;
next	7.10;

7.10
date	88.07.19.15.58.51;	author mike;	state Exp;
branches;
next	7.9;

7.9
date	88.07.19.15.07.38;	author mike;	state Exp;
branches;
next	7.8;

7.8
date	88.05.22.23.52.59;	author mike;	state Exp;
branches;
next	7.7;

7.7
date	88.05.21.09.10.32;	author mike;	state Exp;
branches;
next	7.6;

7.6
date	88.05.17.04.47.21;	author mike;	state Exp;
branches;
next	7.5;

7.5
date	88.05.17.04.13.11;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.05.16.00.06.39;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.02.03.00.34.17;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.02.03.00.00.24;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.07.29;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.10.41;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.38.47;	author mike;	state Rel;
branches;
next	4.3;

4.3
date	87.02.13.00.41.46;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.01.04.02.26.59;	author mike;	state Rel1;
branches;
next	4.1;

4.1
date	87.01.02.18.28.35;	author stay;	state Rel1;
branches;
next	;

11.4.2.1
date	2002.09.19.18.00.41;	author morrison;	state Exp;
branches;
next	11.4.2.2;

11.4.2.2
date	2004.03.17.21.16.07;	author morrison;	state Exp;
branches;
next	;

11.4.4.1
date	2004.03.11.23.40.41;	author morrison;	state Exp;
branches;
next	;

11.4.10.1
date	2004.02.12.19.40.45;	author erikg;	state Exp;
branches;
next	;


desc
@Program to label framebuffers
@


11.8
log
@moved to src/fb/
@
text
@/*
 *			F B L A B E L . C
 *
 *  Function -
 *	Draw a Label on a Frame buffer image.
 *
 *  Author -
 *	Paul Randal Stay
 * 
 *  Source -
 * 	SECAD/VLD Computing Consortium, Bldg 394
 *	The U.S. Army Ballistic Research Laboratory
 * 	Aberdeen Proving Ground, Maryland 21005
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 */


#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <ctype.h>
#include "machine.h"
#include "externs.h"
#include "fb.h"
#include "vfont-if.h"

#define FONTBUFSZ 200

static char	*framebuffer = NULL;
static char	*font1 = NULL;

FBIO		*fbp;

static char usage[] = "\
Usage: fblabel [-h -c -a] [-F framebuffer] [-C r/g/b]\n\
	[-S scr_squaresize] [-W scr_width] [-N scr_height]\n\
	[-f fontstring] xpos ypos textstring\n";

/* Variables controlling the font itself */

int		width = 0;	/* Size of current character.		*/
int		height = 0;

static int	filterbuf[FONTBUFSZ][FONTBUFSZ];

static int	scr_width = 0;		/* default input width */
static int	scr_height = 0;	/* default input height */
static int	clear = 0;

static RGBpixel	pixcolor;
static int	xpos;
static int	ypos;
static char	*textstring;
static int	debug;
static int	alias_off;

void	do_char(struct vfont *vfp, struct vfont_dispatch *vdp, int x, int y), do_line(register struct vfont *vfp, register char *line), squash(register int *buf0, register int *buf1, register int *buf2, register float *ret_buf, register int n), fill_buf(register int wid, register int *buf, register char *bitrow);

int
get_args(int argc, register char **argv)
{

	register int c;

	pixcolor[RED]  = 255;
	pixcolor[GRN]  = 255;
	pixcolor[BLU]  = 255;

	while ( (c = getopt( argc, argv, "adhcF:f:r:g:b:C:s:S:w:W:n:N:" )) != EOF )  {
		switch( c )  {
		case 'a':
			alias_off = 1;
			break;
		case 'd':
			debug = 1;
			break;
		case 'h':
			/* high-res */
			scr_height = scr_width = 1024;
			break;
		case 's':
		case 'S':
			/* square size */
			scr_height = scr_width = atoi( optarg );
			break;
		case 'w':
		case 'W':
			scr_width = atoi( optarg );
			break;
		case 'n':
		case 'N':
			scr_height = atoi( optarg );
			break;
		case 'c':
			clear = 1;
			break;
		case 'F':
			framebuffer = optarg;
			break;
		case 'f':
			font1 = optarg;
			break;
		case 'C':
			{
				register char *cp = optarg;
				register unsigned char *conp
					= (unsigned char *)pixcolor;

				/* premature null => atoi gives zeros */
				for( c=0; c < 3; c++ )  {
					*conp++ = atoi(cp);
					while( *cp && *cp++ != '/' ) ;
				}
			}
			break;
		/* backword compatability */
		case 'r':
		        pixcolor[RED] = atoi( optarg );
			break;
		case 'g':
		        pixcolor[GRN] = atoi( optarg );
			break;
		case 'b':
		        pixcolor[BLU] = atoi( optarg );
			break;
		default:		/* '?' */
			return(0);
		}
	}

	if( optind+3 > argc )
		return(0);
	xpos = atoi( argv[optind++]);
	ypos = atoi( argv[optind++]);
	textstring = argv[optind++];
	if(debug) (void)fprintf(stderr,"fblabel %d %d %s\n", xpos, ypos, textstring);

	if ( argc > optind )
		(void)fprintf( stderr, "fblabel: excess argument(s) ignored\n" );

	return(1);		/* OK */
}


int
main(int argc, char **argv)
{
	struct	vfont	*vfp;

	if ( !get_args( argc, argv ) ) {
		fputs( usage, stderr);
		exit(1);
	}

	if( (fbp = fb_open( framebuffer, scr_width, scr_height )) == NULL )  {
		fprintf(stderr, "fblabel:  Unable to open framebuffer %s\n", framebuffer);
		exit(12);
	}

	if( clear ) {
		fb_clear( fbp, PIXEL_NULL);
	}

	if( (vfp = vfont_get(font1)) == VFONT_NULL )  {
		fprintf(stderr, "fblabel:  Can't get font \"%s\"\n",
			font1 == NULL ? "(null)" : font1);
		exit(1);
	}

	do_line( vfp, textstring );

	fb_close( fbp );
	exit(0);
}

void
do_line(register struct vfont *vfp, register char *line)
{
	register int    currx;
	register int    char_count, char_id;
	register int	len = strlen( line );

	if( vfp == VFONT_NULL )  return;

	currx = xpos;

	for( char_count = 0; char_count < len; char_count++ )  {
		register struct vfont_dispatch	*vdp;

		char_id = (int) line[char_count] & 0377;

		/* Obtain the dimensions for the character */
		vdp = &vfp->vf_dispatch[char_id];
		width = vdp->vd_left + vdp->vd_right;
		height = vdp->vd_up + vdp->vd_down;
		if(debug) fprintf(stderr,"%c w=%2d h=%2d, currx=%d\n", char_id, width, height, currx);

		/*
		 *  Space characters are frequently not represented
		 *  in the font set, so leave white space here.
		 */
	 	if( width <= 1 )  {
	 		char_id = 'n';	/* 1-en space */
			vdp = &vfp->vf_dispatch[char_id];
			width = vdp->vd_left + vdp->vd_right;
	 		if( width <= 1 )  {
		 		char_id = 'N';	/* 1-en space */
				vdp = &vfp->vf_dispatch[char_id];
				width = vdp->vd_left + vdp->vd_right;
	 			if( width <= 1 )
	 				width = 16;	/* punt */
	 		}
	 		currx += width;
	 		continue;
	 	}

		if( currx + width > fb_getwidth(fbp) - 1 )  {
			fprintf(stderr,"fblabel:  Ran off screen\n");
			break;
		}

		do_char( vfp, vdp, currx, ypos );
		currx += vdp->vd_width + 2;
	 }
}

void
do_char(struct vfont *vfp, struct vfont_dispatch *vdp, int x, int y)
{	
	register int    i, j;
	int		base;
	int     	totwid = width;
	int		ln;
	static float	resbuf[FONTBUFSZ];
	static RGBpixel	fbline[FONTBUFSZ];
	int		bytes_wide;	/* # bytes/row in bitmap */

	bytes_wide = (width+7)>>3;

	 /* Read in the character bit map, with two blank lines on each end. */
	 for (i = 0; i < 2; i++)
		bzero( (char *)&filterbuf[i][0], (totwid+4)*sizeof(int) );

	 for ( ln=0, i = height + 1; i >= 2; i--, ln++)
		 fill_buf (width, &filterbuf[i][0],
			&vfp->vf_bits[vdp->vd_addr + bytes_wide*ln] );

	 for (i = height + 2; i < height + 4; i++)
		bzero( (char *)&filterbuf[i][0], (totwid+4)*sizeof(int) );

	 /* Initial base line for filtering depends on odd flag. */
	if( vdp->vd_down % 2 )
		base = 1;
	else
		base = 2;

	 /* Produce a RGBpixel buffer from a description of the character and
	  * the read back data from the frame buffer for anti-aliasing.
	  */
	 for (i = height + base; i >= base; i--)  {
		 squash(	filterbuf[i - 1],	/* filter info */
			 filterbuf[i],
			 filterbuf[i + 1],
			 resbuf,
			 totwid + 4
		     );
		 fb_read( fbp, x, y - vdp->vd_down + i, (unsigned char *)fbline, totwid+3);
		 for (j = 0; j < (totwid + 3) - 1; j++)  {
			 register int	tmp;
			 /* EDITOR'S NOTE : do not rearrange this code,
			  * the SUN compiler can't handle more
			  * complex expressions.
			  */

			 tmp = fbline[j][RED] & 0377;
			 fbline[j][RED] =
			     (int)(pixcolor[RED]*resbuf[j]+(1-resbuf[j])*tmp);
			 fbline[j][RED] &= 0377;
			 tmp = fbline[j][GRN] & 0377;
			 fbline[j][GRN] =
			     (int)(pixcolor[GRN]*resbuf[j]+(1-resbuf[j])*tmp);
			 fbline[j][GRN] &= 0377;
			 tmp = fbline[j][BLU] & 0377;
			 fbline[j][BLU] =
			     (int)(pixcolor[BLU]*resbuf[j]+(1-resbuf[j])*tmp);
			 fbline[j][BLU] &= 0377;
		}
		if( fb_write( fbp, x, y-vdp->vd_down+i, (unsigned char *)fbline, totwid+3 ) < totwid+3 )  {
			fprintf(stderr, "fblabel: pixel write error\n");
			exit(1);
		}
	 }
}


 /*	b i t x ( )
	 Extract a bit field from a bit string.
  */
int
bitx(register char *bitstring, register int posn)
{
	for (; posn >= 8; posn -= 8, bitstring++);
#if defined( CANT_DO_ZERO_SHIFT )
	if (posn == 0)
		return (int) (*bitstring) & 1;
	else
#endif
		return (int) (*bitstring) & (1 << posn);
}

/* 
 * squash - Filter super-sampled image for one scan line
 */

/* Cone filtering weights. 
 * #define CNTR_WT 0.23971778
 * #define MID_WT  0.11985889
 * #define CRNR_WT 0.07021166
 */

/* Gaussian filtering weights. */
#define CNTR_WT 0.3011592441
#define MID_WT 0.1238102667
#define CRNR_WT 0.0508999223

/*	Squash takes three super-sampled "bit arrays", and returns an array
	of intensities at half the resolution.  N is the size of the bit
	arrays.  The "bit arrays" are actually int arrays whose values are
	assumed to be only 0 or 1.
 */
void
squash(register int *buf0, register int *buf1, register int *buf2, register float *ret_buf, register int n)
{
	register int    j;

	for (j = 1; j < n - 1; j++) {
		if (alias_off)
		{
			ret_buf[j] = buf1[j];
		}
		else
		{
			ret_buf[j] =
				(
				 buf2[j - 1] * CRNR_WT +
				 buf2[j] * MID_WT +
				 buf2[j + 1] * CRNR_WT +
				 buf1[j - 1] * MID_WT +
				 buf1[j] * CNTR_WT +
				 buf1[j + 1] * MID_WT +
				 buf0[j - 1] * CRNR_WT +
				 buf0[j] * MID_WT +
				 buf0[j + 1] * CRNR_WT
				);
		}
	}
}

/*	f i l l _ b u f ( )
	Fills in the buffer by reading a row of a bitmap from the
	character font file.  The file pointer is assumed to be in the
	correct position.
 */
void
fill_buf(register int wid, register int *buf, register char *bitrow)
{
	register int    j;

	/*
	 * For each bit in the row, set the array value to 1 if it's on. The
	 * bitx routine extracts the bit value.  Can't just use the j-th bit
	 * because the bytes are backwards. 
	 */
	for (j = 0; j < wid; j++)
		if (bitx(bitrow, (j & ~7) + (7 - (j & 7))))
			buf[j + 2] = 1;
		else
			buf[j + 2] = 0;

	/*
	 * Need two samples worth of background on either end to make the
	 * filtering come out right without special casing the filtering. 
	 */
	buf[0] = buf[1] = buf[wid + 2] = buf[wid + 3] = 0;
}
@


11.7
log
@change conf.h to a wrapped config.h
@
text
@@


11.6
log
@merge of ansi-6-0-branch into HEAD
@
text
@d21 5
a25 1
#include "conf.h"
@


11.5
log
@update copyright to include span through 2003
@
text
@d65 1
a65 1
void	do_char(), do_line(), squash(), fill_buf();
d68 1
a68 2
get_args( argc, argv )
register char **argv;
d154 1
a154 3
main(argc, argv)
int argc;
char **argv;
d185 1
a185 3
do_line( vfp, line )
register struct vfont	*vfp;
register char		*line;
d236 1
a236 4
do_char( vfp, vdp, x, y )
struct vfont	*vfp;
struct vfont_dispatch	*vdp;
int x, y;
d308 1
a308 3
bitx( bitstring, posn )
register char *bitstring;
register int posn;
d340 1
a340 4
squash( buf0, buf1, buf2, ret_buf, n )
register int	*buf0, *buf1, *buf2;	
register float	*ret_buf;
register int	n;
d373 1
a373 4
fill_buf( wid, buf, bitrow )
register int	wid;
register int	*buf;
register char	*bitrow;
@


11.4
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1986 by the United States Army.
@


11.4.4.1
log
@sync to HEAD...
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
@


11.4.10.1
log
@merge from HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
@


11.4.2.1
log
@Initial ANSIfication
@
text
@d65 1
a65 1
void	do_char(struct vfont *vfp, struct vfont_dispatch *vdp, int x, int y), do_line(register struct vfont *vfp, register char *line), squash(register int *buf0, register int *buf1, register int *buf2, register float *ret_buf, register int n), fill_buf(register int wid, register int *buf, register char *bitrow);
d68 2
a69 1
get_args(int argc, register char **argv)
d155 3
a157 1
main(int argc, char **argv)
d188 3
a190 1
do_line(register struct vfont *vfp, register char *line)
d241 4
a244 1
do_char(struct vfont *vfp, struct vfont_dispatch *vdp, int x, int y)
d316 3
a318 1
bitx(register char *bitstring, register int posn)
d350 4
a353 1
squash(register int *buf0, register int *buf1, register int *buf2, register float *ret_buf, register int n)
d386 4
a389 1
fill_buf(register int wid, register int *buf, register char *bitrow)
@


11.4.2.2
log
@sync branch with HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
@


11.3
log
@Converted from K&R to ANSI C - RFH
@
text
@d65 1
a65 1
void	do_char(struct vfont *vfp, struct vfont_dispatch *vdp, int x, int y), do_line(register struct vfont *vfp, register char *line), squash(register int *buf0, register int *buf1, register int *buf2, register float *ret_buf, register int n), fill_buf(register int wid, register int *buf, register char *bitrow);
d68 2
a69 1
get_args(int argc, register char **argv)
d155 3
a157 1
main(int argc, char **argv)
d188 3
a190 1
do_line(register struct vfont *vfp, register char *line)
d241 4
a244 1
do_char(struct vfont *vfp, struct vfont_dispatch *vdp, int x, int y)
d316 3
a318 1
bitx(register char *bitstring, register int posn)
d350 4
a353 1
squash(register int *buf0, register int *buf1, register int *buf2, register float *ret_buf, register int n)
d386 4
a389 1
fill_buf(register int wid, register int *buf, register char *bitrow)
@


11.2
log
@*- get rid of warnings
@
text
@d65 1
a65 1
void	do_char(), do_line(), squash(), fill_buf();
d68 1
a68 2
get_args( argc, argv )
register char **argv;
d154 1
a154 3
main(argc, argv)
int argc;
char **argv;
d185 1
a185 3
do_line( vfp, line )
register struct vfont	*vfp;
register char		*line;
d236 1
a236 4
do_char( vfp, vdp, x, y )
struct vfont	*vfp;
struct vfont_dispatch	*vdp;
int x, y;
d308 1
a308 3
bitx( bitstring, posn )
register char *bitstring;
register int posn;
d340 1
a340 4
squash( buf0, buf1, buf2, ret_buf, n )
register int	*buf0, *buf1, *buf2;	
register float	*ret_buf;
register int	n;
d373 1
a373 4
fill_buf( wid, buf, bitrow )
register int	wid;
register int	*buf;
register char	*bitrow;
@


11.1
log
@Release_4.4
@
text
@d24 5
d67 1
d154 1
a154 1

d315 1
a315 1

@


10.3
log
@Added include of conf.h
@
text
@@


10.2
log
@Reduced use of RGBpixel
Now use (unsigned char *)
@
text
@d21 2
@


10.1
log
@Release_4.0
@
text
@d24 1
a29 9
extern char	*malloc();
extern int	getopt();
extern char	*optarg;
extern int	optind;

#define MAX_LINE	2048		/* Max pixels/line */
static RGBpixel scanline[MAX_LINE];	/* 1 scanline pixel buffer */
static int scanbytes;			/* # of bytes of scanline */

d275 1
a275 1
		 fb_read( fbp, x, y - vdp->vd_down + i, fbline, totwid+3);
d296 1
a296 1
		if( fb_write( fbp, x, y-vdp->vd_down+i, fbline, totwid+3 ) < totwid+3 )  {
@


9.2
log
@Added -S -W -N flags, and Paul Stay's -a dont_anti_alias flag.
@
text
@@


9.1
log
@Release_3.5
@
text
@d44 2
a45 1
Usage: fblabel [-h -c ] [-F framebuffer] [-C r/g/b]\n\
d55 2
a56 2
static int	file_width = 512;	/* default input width */
static int	file_height = 512;	/* default input height */
d64 1
d78 1
a78 1
	while ( (c = getopt( argc, argv, "dhcF:f:r:g:b:C:" )) != EOF )  {
d80 3
d88 14
a101 1
			file_height = file_width = 1024;
d166 1
a166 1
	if( (fbp = fb_open( framebuffer, file_width, file_height )) == NULL )  {
d176 2
a177 1
		fprintf(stderr, "fblabel:  Can't get font %s\n", font1);
d358 19
a376 12
		ret_buf[j] =
			(
			 buf2[j - 1] * CRNR_WT +
			 buf2[j] * MID_WT +
			 buf2[j + 1] * CRNR_WT +
			 buf1[j - 1] * MID_WT +
			 buf1[j] * CNTR_WT +
			 buf1[j + 1] * MID_WT +
			 buf0[j - 1] * CRNR_WT +
			 buf0[j] * MID_WT +
			 buf0[j + 1] * CRNR_WT
			);
@


8.1
log
@Release_3.0
@
text
@@


7.14
log
@Included machine.h to get SYSV defines for bzero()
@
text
@@


7.13
log
@-C bug crept in from pixmerge
@
text
@d23 1
@


7.12
log
@-C r/g/b instead of -r -g -b
@
text
@d100 1
a100 1
				for( c=0; c < width; c++ )  {
@


7.11
log
@Really did what last version set out to do
@
text
@d43 2
a44 2
Usage: fblabel [-h -c ] [-F framebuffer]\n\
	[-f fontstring] [-r red] [-g green] [-b blue] xpos ypos textstring\n";
d75 1
a75 1
	while ( (c = getopt( argc, argv, "dhcF:f:r:g:b:" )) != EOF )  {
d93 14
@


7.10
log
@Added check for pixel writes failing
@
text
@d270 1
a270 1
		if( fb_write( fbp, x, y-vdp->vd_down+i, fbline, totwid+3 ) <= totwid+3 )  {
@


7.9
log
@Added error message for fb_open() failing
@
text
@d269 5
a273 2
		 }
		 fb_write( fbp, x, y - vdp->vd_down + i, fbline,  totwid+3 );
@


7.8
log
@Removed colormap diddling
@
text
@d133 2
a134 1
	if( (fbp = fb_open( framebuffer, file_width, file_height )) == NULL )
d136 1
@


7.7
log
@Converted to use libfont routines,
rather than having an internal copy.
@
text
@a137 1
		fb_wmap( fbp, COLORMAP_NULL );
@


7.6
log
@Not all C compilers give signed chars.
sign-extend VAX chars from file.
@
text
@d24 1
a25 32
#if defined(vax) || defined(pdp11)
#	define	LITTLEENDIAN	1
#else
#	define BIGENDIAN	1
#endif

#if defined(BIGENDIAN)
#define SWAB(shrt)	(shrt=(((shrt)>>8) & 0xff) | (((shrt)<<8) & 0xff00))
#define SWABV(shrt)	((((shrt)>>8) & 0xff) | (((shrt)<<8) & 0xff00))
#else
#define	SWAB(shrt)
#define SWABV(shrt)	(shrt)
#endif

/* The char fields in struct dispatch are signed.  Extend sign */
#define	SXT(c)		((c)|((c&0x80)?(~0xFF):0))

struct header {
	short		magic;
	unsigned short	size;
	short		maxx;
	short		maxy;
	short		xtend;
}; 
struct dispatch
	{
	unsigned short	addr;
	short		nbytes;
	char		up, down, left, right;
	short		width;
	};

a26 3
#define FONTDIR		"/usr/lib/vfont"	/* Font directory.	*/
#define FONTNAME	"nonie.r.12"		/* Default font name.	*/
#define FONTNAMESZ	128
d28 1
a28 7
/* Variables controlling the font itself.				*/
extern FILE *ffdes;		/* Fontfile file descriptor.		*/
extern int offset;		/* Offset to data in the file.		*/
extern struct header hdr;	/* Header for font file.		*/
extern struct dispatch dir[256];/* Directory for character font.	*/
extern int width, height;	/* Width and height of current char.	*/

d40 1
a40 1
FBIO *fbp;
a46 6
FILE		*ffdes;		/* File pointer for current font.	*/
int		offset;		/* Current offset to character data.	*/
struct header	hdr;		/* Header for font file.		*/
struct dispatch	dir[256];	/* Directory for character font.	*/
int		width = 0,	/* Size of current character.		*/
height = 0;
d48 2
a49 1
static int		filterbuf[FONTBUFSZ][FONTBUFSZ];
d51 2
d55 1
a55 1
static int clear = 0;
d57 4
a60 4
static RGBpixel pixcolor;
static int xpos;
static int ypos;
char * textstring;
d63 1
a63 1
void	do_char(), do_line(), squash(), fill_buf(), clear_buf();
d126 1
d141 2
a142 2
	if( get_font(font1) == 0 )  {
		fprintf(stderr, "fblabel:  Can't get font\n");
d146 1
a146 1
	do_line( textstring);
d153 3
a155 2
do_line( line )
register char	*line;
d160 3
a162 6
	if( ffdes == NULL )
	{
		fprintf(stderr,
		     "ERROR: do_line() called before get_Font().\n" );
		return;
	}
d166 2
d171 3
a173 2
		width = SXT(dir[char_id].right) + SXT(dir[char_id].left);
		height = SXT(dir[char_id].up) + SXT(dir[char_id].down);
d182 2
a183 1
			width = SXT(dir[char_id].right) + SXT(dir[char_id].left);
d186 2
a187 2
				width = SXT(dir[char_id].right) +
					SXT(dir[char_id].left);
a194 11
		/* locate the bitmap for the character in the file */
		if( fseek( ffdes, (long)(SWABV(dir[char_id].addr)+offset), 0 )
		     == EOF
		     )
		{
			 fprintf(stderr,  "fseek() to %ld failed.\n",
			 (long)(SWABV(dir[char_id].addr) + offset)
			     );
			 return;
		}

d200 2
a201 2
		do_char( char_id, currx, ypos, SXT(dir[char_id].down)%2 );
		currx += SWABV(dir[char_id].width) + 2;
a202 1
	 return;
d206 4
a209 3
do_char( c, x, y, odd )
int c;
int x, y, odd;
d211 7
a217 6
	 register int    i, j;
	 int		base;
	 int     	totwid = width;
	 int     	up, down;
	 static float	resbuf[FONTBUFSZ];
	 static RGBpixel	fbline[FONTBUFSZ];
d219 2
d223 6
a228 3
		 clear_buf (totwid, filterbuf[i]);
	 for (i = height + 1; i >= 2; i--)
		 fill_buf (width, filterbuf[i]);
d230 1
a230 1
		 clear_buf (totwid, filterbuf[i]);
a231 3
	 up = SXT(dir[c].up);
	 down = SXT(dir[c].down);

d233 4
a236 1
	 base = (odd ? 1 : 2);
d241 1
a241 3

	 for (i = height + base; i >= base; i--)
	 {
d248 2
a249 3
		 fb_read( fbp, x, y - down + i, fbline, totwid+3);
		 for (j = 0; j < (totwid + 3) - 1; j++)
		 {	
d269 1
a269 1
		 fb_write( fbp, x, y - down + i, fbline,  totwid+3 );
a270 1
	 return;
a290 60
get_font( fontname )
char *fontname;
{	
	FILE		*newff;
	struct header	lochdr;
	static char	fname[FONTNAMESZ];
	if( fontname == NULL )
		fontname = FONTNAME;
	if( fontname[0] != '/' )		/* absolute path */
		(void) sprintf( fname, "%s/%s", FONTDIR, fontname );
	else
		(void) strncpy( fname, fontname, FONTNAMESZ );

	/* Open the file and read in the header information. */
	if( (newff = fopen( fname, "r" )) == NULL )
	{
		fb_log( "Error opening font file '%s'\n", fname );
		ffdes = NULL;
		return	0;
	}
	if( ffdes != NULL )
		(void) fclose(ffdes);
	ffdes = newff;
	if( fread( (char *) &lochdr, (int) sizeof(struct header), 1, ffdes ) != 1 )
	{
		fb_log( "get_Font() read failed!\n" );
		ffdes = NULL;
		return	0;
	}
	SWAB( lochdr.magic );
	SWAB( lochdr.size );
	SWAB( lochdr.maxx );
	SWAB( lochdr.maxy );
	SWAB( lochdr.xtend );

	if( lochdr.magic != 0436 )
	{
		fb_log( "Not a font file \"%s\": magic=0%o\n",
		fname, (int) lochdr.magic
		    );
		ffdes = NULL;
		return	0;
	}
	hdr = lochdr;

	/* Read in the directory for the font. */
	if( fread( (char *) dir, (int) sizeof(struct dispatch), 256, ffdes ) != 256 )
	{
		fb_log( "get_Font() read failed!\n" );
		ffdes = NULL;
		return	0;
	}
	/* Addresses of characters in the file are relative to
			point in the file after the directory, so grab the
			current position.
		 */
	offset = ftell( ffdes );
	return	1;
}

a332 1
	return;
d341 1
a341 1
fill_buf( wid, buf )
d344 1
a345 1
	char            bitrow[FONTBUFSZ];
a347 9
	if (ffdes == NULL)
		return;
	/* Read the row, rounding width up to nearest byte value. */
	if (fread(bitrow, (wid / 8) + ((wid % 8 == 0) ? 0 : 1), 1, ffdes)
	    < 1
		) {
		(void) fprintf(stderr, "fill_buf() read failed!\n");
		return;
	}
a363 19
	return;
}

/*	c l e a r _ b u f ( )
	Just sets all the buffer values to zero (this is used to
	"read" background areas of the character needed for filtering near
	the edges of the character definition.
 */
void
clear_buf( wid, buf )
int		wid;
register int	*buf;
{
	register int    i, w = wid + 4;

	/* Clear each value in the row.					 */
	for (i = 0; i < w; i++)
		buf[i] = 0;
	return;
@


7.5
log
@Removed code that byte swapped some 8-bit fields (!).
Added debugging flag, for against the possibility of future debugging.
This version now works on the 4-D.
@
text
@d39 3
d213 2
a214 2
		width = dir[char_id].right + dir[char_id].left;
		height = dir[char_id].up + dir[char_id].down;
d223 1
a223 1
			width = dir[char_id].right + dir[char_id].left;
d226 2
a227 2
				width = (dir[char_id].right) +
					(dir[char_id].left);
d251 1
a251 1
		do_char( char_id, currx, ypos, dir[char_id].down%2 );
d277 2
a278 2
	 up = dir[c].up;
	 down = dir[c].down;
@


7.4
log
@lint fixes
@
text
@d25 1
a25 1
#if defined(vax)
d101 1
d115 1
a115 1
	while ( (c = getopt( argc, argv, "hcF:f:r:g:b:" )) != EOF )  {
d117 3
d152 1
d155 1
a155 1
		(void)fprintf( stderr, "pix-fb: excess argument(s) ignored\n" );
d180 4
a183 1
	get_font(font1);
d210 3
a212 2
		width = SWABV(dir[char_id].right) + SWABV(dir[char_id].left);
		height = SWABV(dir[char_id].up) + SWABV(dir[char_id].down);
d220 1
a220 1
			width = SWABV(dir[char_id].right) + SWABV(dir[char_id].left);
d223 2
a224 2
				width = SWABV(dir[char_id].right) +
					SWABV(dir[char_id].left);
d243 4
a246 2
		if( currx + width > fb_getwidth(fbp) - 1 )
			 break;		/* won't fit on screen */
d287 4
a290 4
		 filterbuf[i],
		 filterbuf[i + 1],
		 resbuf,
		 totwid + 4
@


7.3
log
@For no-width characters, substitute a space.
@
text
@d25 4
a28 3
#define INCL_FONT
#if defined(sel) || defined(gould) || defined( sgi )
#define BIGENDIAN
d30 1
d102 1
d183 1
d243 1
d406 1
a406 1

d436 1
a436 1

d477 1
a477 1

@


7.2
log
@Added special hack to interpret white space characters and leave
some space.
@
text
@d197 4
d205 1
a205 1
	 	if( isascii(char_id) && isspace(char_id) )  {
d208 7
a228 4

		/* Obtain the dimensions for the character */
		width = SWABV(dir[char_id].right) + SWABV(dir[char_id].left);
		height = SWABV(dir[char_id].up) + SWABV(dir[char_id].down);
@


7.1
log
@Release 2.3
@
text
@d1 2
a2 1
/*	    F L A B E L . C
d22 1
d178 1
a178 1
 }
d180 9
a188 9
 do_line( line )
 register char	*line;
 {	
	 register int    currx;
	 register int    char_count, char_id;
	 register int	len = strlen( line );
	 if( ffdes == NULL )
	 {
		 fprintf(stderr,
d190 3
a192 3
		 return;
	 }
	 currx = xpos;
d194 2
a195 3
	 for( char_count = 0; char_count < len; char_count++ )
	 {
		 char_id = (int) line[char_count] & 0377;
d197 13
a209 2
		 /* locate the bitmap for the character in the file */
		 if( fseek( ffdes, (long)(SWABV(dir[char_id].addr)+offset), 0 )
d212 1
a212 1
		 {
d217 1
a217 1
		 }
d219 3
a221 3
		 /* Read in the dimensions for the character */
		 width = dir[char_id].right + dir[char_id].left;
		 height = dir[char_id].up + dir[char_id].down;
d223 1
a223 1
		 if( currx + width > fb_getwidth(fbp) - 1 )
d226 2
a227 2
		 do_char( char_id, currx, ypos, dir[char_id].down%2 );
		 currx += SWABV(dir[char_id].width) + 2;
d230 1
a230 1
 }
@


6.1
log
@Release 2.0
@
text
@@


5.1
log
@Release 1.24
@
text
@@


4.3
log
@Release 1.20 -- First Formal Release
@
text
@@


4.2
log
@Release 1.12 -- fixed arg quantity checking.
@
text
@@


4.1
log
@release 1.12
@
text
@d138 2
d144 1
a144 1
	if ( argc > ++optind )
@
