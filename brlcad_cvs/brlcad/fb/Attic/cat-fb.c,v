head	11.12;
access;
symbols
	ansi-20040405-merged:11.8.2.2
	postmerge-20040405-ansi:11.10
	premerge-20040404-ansi:11.9
	postmerge-autoconf:11.9
	autoconf-freeze:11.8.10.2
	premerge-autoconf:11.9
	ansi-20040316-freeze:11.8.2.1
	postmerge-20040315-windows:11.9
	premerge-20040315-windows:11.9
	windows-20040315-freeze:11.8.4.1
	autoconf-20031203:11.8
	autoconf-20031202:11.8
	autoconf-branch:11.8.0.10
	phong-branch:11.8.0.8
	photonmap-branch:11.8.0.6
	rel-6-1-DP:11.8
	windows-branch:11.8.0.4
	rel-6-0-2:11.6
	ansi-branch:11.8.0.2
	rel-6-0-1-branch:11.6.0.2
	hartley-6-0-post:11.7
	hartley-6-0-pre:11.6
	rel-6-0-1:11.6
	rel-6-0:11.6
	rel-5-4:11.3
	offsite-5-3-pre:11.5
	rel-5-3:11.3
	rel-5-2:11.3
	rel-5-1-branch:11.3.0.2
	rel-5-1:11.3
	rel-5-0:11.3
	rel-5-0-beta:11.3
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1;
locks; strict;
comment	@ * @;


11.12
date	2004.05.24.04.13.25;	author morrison;	state dead;
branches;
next	11.11;

11.11
date	2004.05.10.15.30.42;	author erikg;	state Exp;
branches;
next	11.10;

11.10
date	2004.04.05.07.49.23;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2004.02.02.17.39.01;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2002.08.20.17.07.23;	author jra;	state Exp;
branches
	11.8.2.1
	11.8.4.1
	11.8.10.1;
next	11.7;

11.7
date	2002.08.15.20.54.36;	author hartley;	state Exp;
branches;
next	11.6;

11.6
date	2001.04.12.17.44.07;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	2000.08.25.03.15.45;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	2000.08.24.03.58.21;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	98.08.22.23.13.13;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.07.16.22.05.28;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.08.55;	author mike;	state Rel4_4;
branches;
next	10.6;

10.6
date	94.12.30.03.26.42;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.11.14.22.23.59;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.08.23.18.48.54;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	94.08.11.19.09.31;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.08.11.15.05.52;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.46.02;	author mike;	state Rel4_0;
branches;
next	9.4;

9.4
date	91.04.10.22.26.13;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.12.05.06.04.53;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.06.14.04.51.15;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.08.01;	author mike;	state Rel3_5;
branches;
next	8.2;

8.2
date	88.10.06.05.26.44;	author phil;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.40.44;	author mike;	state Rel3_0;
branches;
next	1.14;

1.14
date	88.09.17.06.06.07;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	88.09.17.03.38.39;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	88.09.09.04.07.12;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	88.06.27.09.52.56;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	88.06.27.03.19.11;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	88.05.22.03.18.58;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	88.05.22.03.08.44;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	88.05.21.08.58.33;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	88.05.21.04.50.11;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	88.05.19.05.39.13;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	88.05.19.04.07.28;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	88.05.19.03.07.02;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	88.05.19.02.15.16;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	88.05.18.21.22.48;	author mike;	state Exp;
branches;
next	;

11.8.2.1
date	2002.09.19.18.00.38;	author morrison;	state Exp;
branches;
next	11.8.2.2;

11.8.2.2
date	2004.03.17.21.16.04;	author morrison;	state Exp;
branches;
next	;

11.8.4.1
date	2004.03.11.23.40.38;	author morrison;	state Exp;
branches;
next	;

11.8.10.1
date	2004.02.12.19.40.45;	author erikg;	state Exp;
branches;
next	11.8.10.2;

11.8.10.2
date	2004.03.15.13.28.05;	author erikg;	state Exp;
branches;
next	;


desc
@Program to take C/A/T phototypesetter codes from TROFF,
and Berkeley vfont files, and typeset onto a libfb frame buffer.
@


11.12
log
@moved to src/fb/
@
text
@/*
 *			C A T - F B . C
 *
 *  Simulate C/A/T phototypesetter on a framebuffer.
 *  Common usage is troff -t files | cat-fb
 *
 *  Operation is one-pass, top to bottom, so vertical motion is
 *  limited to NLINES scanlines.
 *
 *  Fonts are operating at 200 dpi, giving this correspondence between
 *  screen pixel widths and troff line lengths:
 *	 512	2.56i	(2.35i)
 *	1024	5.12i	(4.95i)
 *	1280	6.4i	(6.2i)
 *
 *  Author -
 *	Ronald B. Natalie
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/fb/cat-fb.c,v 11.11 2004/05/10 15:30:42 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "machine.h"
#include "externs.h"			/* For getopt() */
#include "bu.h"
#include "fb.h"
#include "vfont-if.h"

#define NFONTS			25	/* # of font+psize combos in cache */
#define SPECIALFONT		3
#define MAXF			4	/* Max fonts mounted in C/A/T -- a constant */

#define LOCAL_RAILMAG		".railmag"

/* The vfonts are scaled for 200 dpi */
#define CONVERT(n)		((n)*(200./432.))
#define RECONVERT(n)		((n)*(432./200.))


unsigned char	*scanline;
FBIO		*fbp;

RGBpixel	writing_color = {255, 255, 255};

/* Single-bit wide typesetting buffer.
 * NLINES limits maximum backward vertical motion (eg, in tables).
 */
#define NLINES			1024
#define BUFFER_SIZE		(NLINES*1280/8)

int		bytes_per_line;		/* # bytes of bitmap per line */
unsigned char	buffer[BUFFER_SIZE];	/* Big bitmap line buffers  */
unsigned char	*buf0p = &buffer[0];	/* Zero origin in circular buffer  */

struct	fontdes {
	int	fnum;
	int	psize;
	struct vfont	*vfp;
} fontdes[NFONTS] = {
	{ -1, 10, VFONT_NULL },
	{ -1, 10, VFONT_NULL },
};

struct point_sizes {
	int	stupid_code;
	int	real_code;
} point_sizes[] = {
	{010, 6},
	{0, 7},
	{01, 8},
	{07, 9},
	{02, 10},
	{03, 11},
	{04, 12},
	{05, 14},
	{0211, 16},
	{06, 18},
	{0212, 20},
	{0213, 22},
	{0214, 24},
	{0215, 28},
	{0216, 36},
	 {0, 0}
};

int	cur_fb_line;		/*  Output absolute scanline number  */

int	cfont = 1;		/* current font index in fontdes[] */
int	new_font_num = -1;
int	fontwanted = 1;
int	new_pt_size = 10;		/* new point size */
int	last_ssize = 02;
int	xpos, ypos;
int	esc, lead, back, verd, mcase, railmag;
double	row = -31;
double	col;		/* position in phototypesetter units */
char	*fontname[MAXF];
char	fnbuf[120];

char	asctab[128] = {
	'\0',	/*blank*/
	'h',	/*h*/
	't',	/*t*/
	'n',	/*n*/
	'm',	/*m*/
	'l',	/*l*/
	'i',	/*i*/
	'z',	/*z*/
	's',	/*s*/
	'd',	/*d*/
	'b',	/*b*/
	'x',	/*x*/
	'f',	/*f*/
	'j',	/*j*/
	'u',	/*u*/
	'k',	/*k*/
	'\0',	/*blank*/
	'p',	/*p*/
	'\06',	/*_ 3/4 em dash*/
	';',	/*;*/
	'\0',	/*blank*/
	'a',	/*a*/
	'\05',	/*rule*/
	'c',	/*c*/
	'`',	/*` open*/
	'e',	/*e*/
	'\'',	/*' close*/
	'o',	/*o*/
	'\021',	/*1/4*/
	'r',	/*r*/
	'\022',	/*1/2*/
	'v',	/*v*/
	'-',	/*- hyphen*/
	'w',	/*w*/
	'q',	/*q*/
	'/',	/* / */
	'.',	/*.*/
	'g',	/*g*/
	'\023',	/*3/4*/
	',',	/*,*/
	'&',	/*&*/
	'y',	/*y*/
	'\0',	/*blank*/
	'%',	/*%*/
	'\0',	/*blank*/
	'Q',	/*Q*/
	'T',	/*T*/
	'O',	/*O*/
	'H',	/*H*/
	'N',	/*N*/
	'M',	/*M*/
	'L',	/*L*/
	'R',	/*R*/
	'G',	/*G*/
	'I',	/*I*/
	'P',	/*P*/
	'C',	/*C*/
	'V',	/*V*/
	'E',	/*E*/
	'Z',	/*Z*/
	'D',	/*D*/
	'B',	/*B*/
	'S',	/*S*/
	'Y',	/*Y*/
	'\0',	/*blank*/
	'F',	/*F*/
	'X',	/*X*/
	'A',	/*A*/
	'W',	/*W*/
	'J',	/*J*/
	'U',	/*U*/
	'K',	/*K*/
	'0',	/*0*/
	'1',	/*1*/
	'2',	/*2*/
	'3',	/*3*/
	'4',	/*4*/
	'5',	/*5*/
	'6',	/*6*/
	'7',	/*7*/
	'8',	/*8*/
	'9',	/*9*/
	'*',	/***/
	'\04',	/*minus*/
	'\01',	/*fi*/
	'\02',	/*fl*/
	'\03',	/*ff*/
	'\020',	/* cent sign */
	'\012',	/*ffl*/
	'\011',	/*ffi*/
	'(',	/*(*/
	')',	/*)*/
	'[',	/*[*/
	']',	/*]*/
	'\013',	/* degree */
	'\014',	/* dagger */
	'=',	/*=*/
	'\017',	/* registered */
	':',	/*:*/
	'+',	/*+*/
	'\0',	/*blank*/
	'!',	/*!*/
	'\07',	/* bullet */
	'?',	/*?*/
	'\015',	/*foot mark*/
	'|',	/*|*/
	'\0',	/*blank*/
	'\016',	/* copyright */
	'\010',	/* square */
	'$',	/*$*/
	'\0',
	'\0',
	'"',	/*"*/
	'#',	/*#*/
	'<',	/*<*/
	'>',	/*>*/
	'@@',	/*@@*/
	'\\',	/*\\*/
	'^',	/*^*/
	'{',	/*{*/
	'}',	/*}*/
	'~'	/*~*/
};

char spectab[128] = {
	'\0',	/*blank*/
	'w',	/*psi*/
	'h',	/*theta*/
	'm',	/*nu*/
	'l',	/*mu*/
	'k',	/*lambda*/
	'i',	/*iota*/
	'f',	/*zeta*/
	'r',	/*sigma*/
	'd',	/*delta*/
	'b',	/*beta*/
	'n',	/*xi*/
	'g',	/*eta*/
	'u',	/*phi*/
	't',	/*upsilon*/
	'j',	/*kappa*/
	'\0',	/*blank*/
	'p',	/*pi*/
	'@@',	/*at-sign*/
	'7',	/*down arrow*/
	'\0',	/*blank*/
	'a',	/*alpha*/
	'|',	/*or*/
	'v',	/*chi*/
	'"',	/*"*/
	'e',	/*epsilon*/
	'=',	/*=*/
	'o',	/*omicron*/
	'4',	/*left arrow*/
	'q',	/*rho*/
	'6',	/*up arrow*/
	's',	/*tau*/
	'_',	/*underrule*/
	'\\',	/*\*/
	'W',	/*Psi*/
	'\07',	/*bell system sign*/
	'\001',	/*infinity*/
	'c',	/*gamma*/
	'\002',	/*improper superset*/
	'\003',	/*proportional to*/
	'\004',	/*right hand*/
	'x',	/*omega*/
	'\0',	/*blank*/
	'(',	/*gradient*/
	'\0',	/*blank*/
	'U',	/*Phi*/
	'H',	/*Theta*/
	'X',	/*Omega*/
	'\005',	/*cup (union)*/
	'\006',	/*root en*/
	'\014',	/*terminal sigma*/
	'K',	/*Lambda*/
	'-',	/*minus*/
	'C',	/*Gamma*/
	'\015',	/*integral sign*/
	'P',	/*Pi*/
	'\032',	/*subset of*/
	'\033',	/*superset of*/
	'2',	/*approximates*/
	'y',	/*partial derivative*/
	'D',	/*Delta*/
	'\013',	/*square root*/
	'R',	/*Sigma*/
	'1',	/*approx =*/
	'\0',	/*blank*/
	'>',	/*>*/
	'N',	/*Xi*/
	'<',	/*<*/
	'\016',	/*slash (longer)*/
	'\034',	/*cap (intersection)*/
	'T',	/*Upsilon*/
	'\035',	/*not*/
	'\023',	/*right ceiling (rt of ")*/
	'\024',	/*left top (of big curly)*/
	'\017',	/*bold vertical*/
	'\030',	/*left center of big curly bracket*/
	'\025',	/*left bottom*/
	'\026',	/*right top*/
	'\031',	/*right center of big curly bracket*/
	'\027',	/*right bot*/
	'\021',	/*right floor (rb of ")*/
	'\020',	/*left floor (left bot of big sq bract)*/
	'\022',	/*left ceiling (lt of ")*/
	'*',	/*multiply*/
	'/',	/*divide*/
	'\010',	/*plus-minus*/
	'\011',	/*<=*/
	'\012',	/*>=*/
	'0',	/*identically equal*/
	'3',	/*not equal*/
	'{',	/*{*/
	'}',	/*}*/
	'\'',	/*' acute accent*/
	'\140',/*` grave accent*/
	'^',	/*^*/
	'#',	/*sharp*/
	'\036',	/*left hand*/
	'\037',	/*member of*/
	'~',	/*~*/
	'z',	/*empty set*/
	'\0',	/*blank*/
	'Y',	/*dbl dagger*/
	'Z',	/*box rule*/
	'9',	/*asterisk*/
	'[',	/*improper subset*/
	']',	/*circle*/
	'\0',	/*blank*/
	'+',	/*eqn plus*/
	'5',	/*right arrow*/
	'8'	/*section mark*/
};

static char	*framebuffer = NULL;

static int	scr_width = 0;		/* use device default size */
static int	scr_height = 0;
static int	clear = 0;		/* clear screen before writing */
static int	overlay_from_stdin = 0;	/* overlay FROM STDIN rather than fb */
static int	debug = 0;
static int	output_pix = 0;		/* output pixfile, rather than to fb */

void		ofile(register FILE *fp);
void		readrailmag(void);
void		crail(register int nrail);
void		slop_lines(int nlines);
int		loadfont(register int fnum, register int size);
int		findsize(register int code);
int		outc(int code);
int		relfont(void);
int		writelines(int nlines, register char *buf);

static char usage[] = "\
Usage: cat-fb [-h -c -O -o] [-F framebuffer] [-C r/g/b]\n\
	[-{sS} squarescrsize] [-{wW} scr_width] [-{nN} scr_height]\n\
	[troff_files]\n";
int
get_args(int argc, register char **argv)
{
	register int c;

	while ( (c = getopt( argc, argv, "odhcOF:s:S:w:W:n:N:C:" )) != EOF )  {
		switch( c )  {
		case 'o':
			output_pix = 1;
			break;
		case 'd':
			debug++;
			break;
		case 'O':
			overlay_from_stdin = 1;
			break;
		case 'h':
			/* high-res */
			scr_height = scr_width = 1024;
			break;
		case 'c':
			clear = 1;
			break;
		case 'F':
			framebuffer = optarg;
			break;
		case 's':
		case 'S':
			scr_height = scr_width = atoi(optarg);
			break;
		case 'w':
		case 'W':
			scr_width = atoi(optarg);
			break;
		case 'n':
		case 'N':
			scr_height = atoi(optarg);
			break;
		case 'C':
			{
				register char *cp = optarg;
				register unsigned char *conp = writing_color;

				/* premature null => atoi gives zeros */
				for( c=0; c < 3; c++ )  {
					*conp++ = atoi(cp);
					while( *cp && *cp++ != '/' ) ;
				}
			}
			break;

		default:		/* '?' */
			return(0);
		}
	}

	if( optind >= argc )  {
		/* No file name args */
		if( isatty(fileno(stdin)) )
			return(0);
		/* mainline will actually do the processing */
	}
	return(1);		/* OK */
}

int
main(int argc, char **argv)
{
	char	*cp;

	if ( !get_args( argc, argv ) )  {
		(void)fputs(usage, stderr);
		exit( 1 );
	}

	if( output_pix && !overlay_from_stdin )
		clear = 1;
	if( !output_pix )  {
		if( (fbp = fb_open( framebuffer, scr_width, scr_height )) == FBIO_NULL )
			exit(1);
		scr_width = fb_getwidth(fbp);
		scr_height = fb_getheight(fbp);
	}
	if( (cp = malloc(scr_width*sizeof(RGBpixel))) == (char *)0 )
		exit(42);
	scanline = (unsigned char *)cp;
	bytes_per_line = (scr_width+7)/8;

	cur_fb_line = scr_height-1;	/* start at top of screen */

	readrailmag();

	if( optind >= argc )  {
		/* Process one TROFF file from stdin */
		if( overlay_from_stdin )  {
			fprintf(stderr,"cat-fb: -O ignored, stdin used for C/A/T code\n");
			overlay_from_stdin = 0;
		}
		ofile(stdin);
	} else {
		for( ; optind < argc; optind++ )  {
			register FILE *fp;
			if( (fp = fopen(argv[optind], "r")) == NULL )  {
				perror(argv[optind]);
				continue;
			}
			ofile(fp);
			fclose(fp);
		}
	}
	slop_lines(NLINES);		/* Flush bitmap buffer */
	if( fbp )
		fb_close(fbp);
	exit(0);
}

/*
 *			R E A D R A I L M A G
 */
void
readrailmag(void)
{
	register int i;
	register char *cp;
	register int rmfd;
	char c;

	if ((rmfd = open(LOCAL_RAILMAG, 0)) < 0)
		if ((rmfd = open(bu_brlcad_path("vfont/railmag"), 0)) < 0) {
			/*
			 *  Provide reasonable default font choices.
			 *  In the Berkeley VFONT set, the Times
			 *  fonts actually match the default troff
			 *  widths much better than the R, I, & B
			 *  fonts.  However, note that the Times fonts
			 *  don't have ligatures.
			 *  Also note that the times.s font does not
			 *  have lots of things that EQN expects out of
			 *  an "S" font.
			 */
			fontname[0] = "times.r";
			fontname[1] = "times.i";
			fontname[2] = "times.b";
			fontname[3] = "S";
			return;
		}
	cp = fnbuf;
	for (i = 0; i < 4; i++) {
		fontname[i] = cp;
		while (read(rmfd, &c, 1) == 1 && c != '\n')
			*cp++ = c;
		*cp++ = '\0';
	}
	close(rmfd);
}

void
ofile(register FILE *fp)
{
	register int c;
	static int initialized;

	while ((c = getc(fp)) != EOF) {
		if (!c)
			continue;
		if (c & 0200) {
			esc += (~c) & 0177;
			if(debug>1)fprintf(stderr,"esc+= %d ", (~c)&0177 );
			continue;
		}
		if (esc) {
			if (back)
				esc = -esc;
			if(debug>1)fprintf(stderr,"esc=%d, back=%d\n", esc, back);
			col += esc;
			ypos = CONVERT(col);
			esc = 0;
		}
		if(debug>1)fprintf(stderr,"   0%o v=%d (row=%g) h=%d (col=%g)\n", c, xpos, row, ypos, col);

		if ((c & 0377) < 0100)	/*  Purely for efficiency  */
			goto normal_char;
		switch (c) {

		case 0100:
			if (initialized)
				goto out;
			initialized = 1;
#if 0
			row = 25;	/** original value **/
#else
			row = -108;	/* ignore 1/4 C/A/T inch header */
#endif
			xpos = CONVERT(row);
			for (c = 0; c < BUFFER_SIZE; c++)
				buffer[c] = 0;
			col = 0;
			esc = 0;
			lead = 0;
			ypos = 0;
			verd = 0;
			back = 0;
			mcase = 0;
			railmag = 0;
			if (loadfont(railmag, fontdes[cfont].psize) < 0)
				fprintf(stderr, "Can't load inital font\n");
			break;

		case 0101:	/* lower rail */
			crail(railmag &= ~01);
			break;

		case 0102:	/* upper rail */
			crail(railmag |= 01);
			break;

		case 0103:	/* upper mag */
			crail(railmag |= 02);
			break;

		case 0104:	/* lower mag */
			crail(railmag &= ~02);
			break;

		case 0105:	/* lower case */
			mcase = 0;
			break;

		case 0106:	/* upper case */
			mcase = 0100;
			break;

		case 0107:	/* escape forward */
			back = 0;
			break;

		case 0110:	/* escape backwards */
			back = 1;
			break;

		case 0111:	/* stop */
			break;

		case 0112:	/* lead forward */
			verd = 0;
			break;

		case 0113:	/* undefined */
			break;

		case 0114:	/* lead backward */
			verd = 1;
			break;

		case 0115:	/* undefined */
		case 0116:
		case 0117:
			break;

		default:
			if ((c & 0340) == 0140)	/* leading */ {
				lead = (~c) & 037;
				if (verd)
					lead = -lead;
				row += lead*3;	/*  Lead is 3 units  */
				c = CONVERT(row);
				while (c >= NLINES) {
					slop_lines(15);
					c = CONVERT(row);
				}
				xpos = c;
				if(debug)fprintf(stderr,"v=%d (row=%g)\n", xpos, row);
				continue;
			}
			if ((c & 0360) == 0120)	/* size change */ {
				loadfont(railmag, findsize(c & 017));
				continue;
			}
			if (c & 0300)
				continue;

normal_char:
			c = (c & 077) | mcase;
			(void)outc(c);
		}
	}
out:
	return;
}

int
findsize(register int code)
{
	register struct point_sizes *psp;
	register int delta;

	psp = point_sizes;
	while (psp->real_code != 0) {
		if ((psp->stupid_code & 017) == code)
			break;
		psp++;
	}
	/*
	 * Due to the optics in the C/A/T, characters appear with an X offset
	 * when some of the larger sizes are used.
	 */
	delta = 0;
#define DBL	0200
	if (!(last_ssize & DBL) && (psp->stupid_code & DBL))
		delta = -55;		/* Size getting larger */
	else if ((last_ssize & DBL) && !(psp->stupid_code & DBL))
		delta = 55;		/* Size getting smaller */
	if (back)
		delta = -delta;
	esc += delta;	/* Compensate for C/A/T hardware shift during size change */
	if(debug)fprintf(stderr,"findsize: changing escapment by %d, code=0%o, last_ssize=0%o, stupid_code=0%o\n", delta, code, last_ssize, psp->stupid_code);
	last_ssize = psp->stupid_code;
	return (psp->real_code);
}

void
crail(register int nrail)
{
	register int psize;

	psize = fontdes[cfont].psize;
	if (fontwanted)
		psize = new_pt_size;
	loadfont(nrail, psize);
}


/* Queue up a request to change to a new font */
int
loadfont(register int fnum, register int size)
{
	register int i;

	fontwanted = 0;
	if (fnum < 0 || fnum >= MAXF) {
		fprintf(stderr, "Internal error: illegal font\n");
		return(-1);
	}
	if (fnum == fontdes[cfont].fnum && size == fontdes[cfont].psize)
		return(0);
	for (i = 0; i < NFONTS; i++)
		if (fontdes[i].fnum == fnum && fontdes[i].psize == size) {
			cfont = i;
			return (0);
		}
	new_font_num = fnum;
	new_pt_size = size;
	fontwanted++;
	return (0);
}


/*
 *			R E A D I N F O N T
 *
 *  Returns -
 *	-1	FAIL
 *	 0	OK
 */
int
readinfont(void)
{
	register struct vfont	*vfp;
	register int fnum, size;
	char cbuf[BUFSIZ];

	fnum = new_font_num;
	size = new_pt_size;
	sprintf(cbuf, "%s.%d", fontname[fnum], size);

	if( (vfp = vfont_get( cbuf )) == VFONT_NULL )  {
		/* Ignore font change */
		fprintf(stderr,"cat-fb:  Unable to acquire font '%s'\n", cbuf);
		fontwanted = 0;
		return (-1);
	}

	cfont = relfont();

	fontdes[cfont].fnum = fnum;
	fontdes[cfont].psize = fontdes[cfont].psize = size;
	fontdes[cfont].vfp = vfp;
	if(debug) fprintf(stderr,"slot %d = %s\n", cfont, cbuf );

	fontwanted = 0;
	new_font_num = new_pt_size = -1;
	return (0);
}

int lastloaded	= -1;

int
relfont(void)
{
	register int newfont;

	/* First, see if a font table slot happens to be availible */
	for( newfont = 0; newfont < NFONTS; newfont++ )  {
		if( fontdes[newfont].psize > 0 )
			continue;
		return(newfont);
	}

	/* Reuse an existing slot, with a strange heuristic */

	newfont = lastloaded;
	/*
	 * optimization for special font.  since we think that usually
	 * there is only one character at a time from any special math
	 * font, make it the candidate for removal.
	 */
	if (fontdes[cfont].fnum != SPECIALFONT || fontdes[cfont].vfp==VFONT_NULL)
		if (++newfont>=NFONTS)
			newfont = 0;
	lastloaded = newfont;
	if( fontdes[newfont].vfp != VFONT_NULL )
		vfont_free(fontdes[newfont].vfp);
		
	fontdes[newfont].vfp = VFONT_NULL;
	fontdes[newfont].fnum = -1;
	fontdes[newfont].psize = -1;
	return (newfont);
}

/*
 *			O U T C
 *
 *  Returns -
 *	0	FAIL
 *	1	OK
 */
int
outc(int code)
{
	char c;				/* character to print */
	register struct vfont_dispatch *vdp;	/* ptr to character font record */
	register unsigned char *addr;	/* addr of font data */
	int llen;			/* length of each font line */
	int nlines;			/* number of font lines */
	register unsigned char *scanp;	/* ptr to output buffer */
	int scanp_inc;			/* increment to start of next buffer */
	int offset;			/* bit offset to start of font data */
	int i;				/* loop counter */
	register int count;		/* font data ptr */
	register unsigned fontdata;	/* font data temporary */
	register int off8;		/* offset + 8 */

	if (fontwanted)  {
		if( readinfont() < 0 )  return(0);
	}
	if (railmag == SPECIALFONT) {
		c = spectab[code];
	} else {
		c = asctab[code];
	}
	vdp = &fontdes[cfont].vfp->vf_dispatch[(int)c];

	if (vdp->vd_nbytes <= 0 )
		return(0);

	/* xpos is vertical (typ. called Y), ypos is horizontal (typ. X)
	 * like a strip-chart recorder */
	if(debug)  {
		fprintf(stderr,"%c h=%d v=%d  (row=%g col=%g) l=%d r=%d  u=%d d=%d  w=%d\n",
		c, ypos, xpos,
		row, col,
		vdp->vd_left, vdp->vd_right,
		vdp->vd_up, vdp->vd_down, vdp->vd_width);
	}
	if( ypos + vdp->vd_right > bytes_per_line*8 )  {
		fprintf(stderr, "cat-fb: '%c' off right edge of screen\n", c);
		return(0);
	}
	addr = (unsigned char *)&fontdes[cfont].vfp->vf_bits[vdp->vd_addr];
	llen = (vdp->vd_left + vdp->vd_right+7)/8;
	nlines = vdp->vd_up + vdp->vd_down;
	if (xpos+vdp->vd_down >= NLINES)
		slop_lines(xpos + vdp->vd_down - NLINES + 1);
	scanp = ( (xpos-vdp->vd_up-1)*bytes_per_line+
		(ypos-vdp->vd_left)/8 ) + buf0p;
	if (scanp < &buffer[0])
		scanp += BUFFER_SIZE;
	scanp_inc = bytes_per_line-llen;
	offset = (ypos-vdp->vd_left)&07;
	off8 = 8-offset;
	for (i = 0; i < nlines; i++) {
		if (scanp >= &buffer[BUFFER_SIZE])
			scanp -= BUFFER_SIZE;
		count = llen;
		/* This buffer goes left-to-right [0], [1], ... */
		if (scanp + count <= &buffer[BUFFER_SIZE])
			do {
				fontdata = *addr++;
				*scanp |= (fontdata >> offset);
				scanp++;
				*scanp |= (fontdata << off8);
				count--;
			} while (count > 0);
		scanp += scanp_inc+count;
		addr += count;
	}
	return (1);
}

void
slop_lines(int nlines)
{
	register int rlines;
	
	rlines = (&buffer[BUFFER_SIZE] - buf0p) / bytes_per_line;
	if (rlines < nlines) {
		if (writelines(rlines, (char *)buf0p) < 0)
			exit(1);
		bzero( (char *)buf0p, rlines * bytes_per_line);
		buf0p = buffer;
		nlines -= rlines;
		xpos -= rlines;
		row -= RECONVERT(rlines);
	}
	if (writelines(nlines, (char *)buf0p) < 0)
		exit(1);
	bzero( (char *)buf0p, bytes_per_line * nlines);
	buf0p += bytes_per_line * nlines;
	if (buf0p >= &buffer[BUFFER_SIZE])
		buf0p -= BUFFER_SIZE;
	xpos -= nlines;
	row -= RECONVERT(nlines);
}

/*
 *  Overlay framebuffer with indicated lines of bitmap.
 *  Output proceeds from top to bottom.
 */
int
writelines(int nlines, register char *buf)
	   	       		/*  Number of scan lines to put out.  */
	             	     	/*  Pointer to buffer location.  */
{
	register unsigned char *pp;
	register int	bit;
	register int	bufval;
	register int	lpos;
	register int	l;

	for(l = 0; l < nlines; l++)  {
		if(cur_fb_line < 0 )  {
			/* Ran off bottom of screen */
			if( fbp )
				fb_close(fbp);
			exit(0);
		}
		if( clear )
			bzero( (char *)scanline, scr_width*3 );
		else if( overlay_from_stdin )  {
			if( fread( (char *)scanline, scr_width*3, 1, stdin ) != 1 )  {
				clear = 1;
				overlay_from_stdin = 0;
			}
		} else
			fb_read( fbp, 0, cur_fb_line, scanline, scr_width );
		pp = scanline;
		for( lpos = 0; lpos < bytes_per_line; lpos++)  {
			if( (bufval = *buf) == 0 )  {
				pp += 8*sizeof(RGBpixel);
				buf++;
				continue;
			}
			for(bit = 0x80; bit; bit >>= 1)  {
				if(bufval & bit)  {
					COPYRGB( pp, writing_color );
				}
				pp += sizeof(RGBpixel);
			}
			buf++;
		}
		if( output_pix )
			fwrite( scanline, scr_width*3, 1, stdout );
		else
			fb_write( fbp, 0, cur_fb_line, scanline, scr_width );
		cur_fb_line--;
	}
	return(0);
}
@


11.11
log
@change conf.h to a wrapped config.h
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/fb/cat-fb.c,v 11.10 2004/04/05 07:49:23 morrison Exp $ (BRL)";
@


11.10
log
@merge of ansi-6-0-branch into HEAD
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d32 5
a36 1
#include "conf.h"
@


11.9
log
@update copyright to include span through 2003
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/cat-fb.c,v 11.8 2002/08/20 17:07:23 jra Exp $ (BRL)";
d364 9
a372 9
void		ofile();
void		readrailmag();
void		crail();
void		slop_lines();
int		loadfont();
int		findsize();
int		outc();
int		relfont();
int		writelines();
d379 1
a379 2
get_args( argc, argv )
register char **argv;
d444 1
a444 3
main(argc, argv) 
	int argc;
	char *argv[];
d498 1
a498 1
readrailmag()
d535 1
a535 2
ofile(fp)
register FILE	*fp;
d669 1
a669 2
findsize(code)
	register int code;
d699 1
a699 2
crail(nrail)
	register int nrail;
d712 1
a712 3
loadfont(fnum, size)
register int fnum;
register int size;
d743 1
a743 1
readinfont()
d775 1
a775 1
relfont()
d815 1
a815 2
outc(code)
	int code;
d888 1
a888 2
slop_lines(nlines)
	int nlines;
d894 1
a894 1
		if (writelines(rlines, buf0p) < 0)
d902 1
a902 1
	if (writelines(nlines, buf0p) < 0)
d917 3
a919 3
writelines(nlines, buf)
	int	nlines;		/*  Number of scan lines to put out.  */
	register char	*buf;	/*  Pointer to buffer location.  */
@


11.8
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1986 by the United States Army.
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/cat-fb.c,v 11.6 2001/04/12 17:44:07 bparker Exp $ (BRL)";
@


11.8.4.1
log
@sync to HEAD...
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/fb/cat-fb.c,v 11.9 2004/02/02 17:39:01 morrison Exp $ (BRL)";
@


11.8.10.1
log
@merge from HEAD
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/cat-fb.c,v 11.9 2004/02/02 17:39:01 morrison Exp $ (BRL)";
@


11.8.10.2
log
@merge from head
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/cat-fb.c,v 11.8.10.1 2004/02/12 19:40:45 erikg Exp $ (BRL)";
@


11.8.2.1
log
@Initial ANSIfication
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/cat-fb.c,v 11.8 2002/08/20 17:07:23 jra Exp $ (BRL)";
d364 9
a372 9
void		ofile(register FILE *fp);
void		readrailmag(void);
void		crail(register int nrail);
void		slop_lines(int nlines);
int		loadfont(register int fnum, register int size);
int		findsize(register int code);
int		outc(int code);
int		relfont(void);
int		writelines(int nlines, register char *buf);
d379 2
a380 1
get_args(int argc, register char **argv)
d445 3
a447 1
main(int argc, char **argv)
d501 1
a501 1
readrailmag(void)
d538 2
a539 1
ofile(register FILE *fp)
d673 2
a674 1
findsize(register int code)
d704 2
a705 1
crail(register int nrail)
d718 3
a720 1
loadfont(register int fnum, register int size)
d751 1
a751 1
readinfont(void)
d783 1
a783 1
relfont(void)
d823 2
a824 1
outc(int code)
d897 2
a898 1
slop_lines(int nlines)
d904 1
a904 1
		if (writelines(rlines, (char *)buf0p) < 0)
d912 1
a912 1
	if (writelines(nlines, (char *)buf0p) < 0)
d927 3
a929 3
writelines(int nlines, register char *buf)
	   	       		/*  Number of scan lines to put out.  */
	             	     	/*  Pointer to buffer location.  */
@


11.8.2.2
log
@sync branch with HEAD
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.7
log
@Converted from K&R to ANSI C - RFH
@
text
@d364 9
a372 9
void		ofile(register FILE *fp);
void		readrailmag(void);
void		crail(register int nrail);
void		slop_lines(int nlines);
int		loadfont(register int fnum, register int size);
int		findsize(register int code);
int		outc(int code);
int		relfont(void);
int		writelines(int nlines, register char *buf);
d379 2
a380 1
get_args(int argc, register char **argv)
d445 3
a447 1
main(int argc, char **argv)
d501 1
a501 1
readrailmag(void)
d538 2
a539 1
ofile(register FILE *fp)
d673 2
a674 1
findsize(register int code)
d704 2
a705 1
crail(register int nrail)
d718 3
a720 1
loadfont(register int fnum, register int size)
d751 1
a751 1
readinfont(void)
d783 1
a783 1
relfont(void)
d823 2
a824 1
outc(int code)
d897 2
a898 1
slop_lines(int nlines)
d904 1
a904 1
		if (writelines(rlines, (char *)buf0p) < 0)
d912 1
a912 1
	if (writelines(nlines, (char *)buf0p) < 0)
d927 3
a929 3
writelines(int nlines, register char *buf)
	   	       		/*  Number of scan lines to put out.  */
	             	     	/*  Pointer to buffer location.  */
@


11.6
log
@*- get rid of warnings
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/cat-fb.c,v 11.5 2000/08/25 03:15:45 mike Exp $ (BRL)";
d364 9
a372 9
void		ofile();
void		readrailmag();
void		crail();
void		slop_lines();
int		loadfont();
int		findsize();
int		outc();
int		relfont();
int		writelines();
d379 1
a379 2
get_args( argc, argv )
register char **argv;
d444 1
a444 3
main(argc, argv) 
	int argc;
	char *argv[];
d498 1
a498 1
readrailmag()
d535 1
a535 2
ofile(fp)
register FILE	*fp;
d669 1
a669 2
findsize(code)
	register int code;
d699 1
a699 2
crail(nrail)
	register int nrail;
d712 1
a712 3
loadfont(fnum, size)
register int fnum;
register int size;
d743 1
a743 1
readinfont()
d775 1
a775 1
relfont()
d815 1
a815 2
outc(code)
	int code;
d888 1
a888 2
slop_lines(nlines)
	int nlines;
d894 1
a894 1
		if (writelines(rlines, buf0p) < 0)
d902 1
a902 1
	if (writelines(nlines, buf0p) < 0)
d917 3
a919 3
writelines(nlines, buf)
	int	nlines;		/*  Number of scan lines to put out.  */
	register char	*buf;	/*  Pointer to buffer location.  */
@


11.5
log
@
Missing include file.
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/cat-fb.c,v 11.4 2000/08/24 03:58:21 mike Exp $ (BRL)";
d35 5
d85 16
a100 16
	010, 6,
	0, 7,
	01, 8,
	07, 9,
	02, 10,
	03, 11,
	04, 12,
	05, 14,
	0211, 16,
	06, 18,
	0212, 20,
	0213, 22,
	0214, 24,
	0215, 28,
	0216, 36,
	0, 0
d368 5
d378 1
a378 1

d444 1
d672 1
d717 1
d750 1
d782 1
d822 1
d847 1
a847 1
	vdp = &fontdes[cfont].vfp->vf_dispatch[c];
d926 1
@


11.4
log
@
const RCSid
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/cat-fb.c,v 11.3 1998/08/22 23:13:13 mike Exp $ (BRL)";
d37 1
@


11.3
log
@No longer modified by newbindir.sh, calls bu_brlcad_path() instead.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/cat-fb.c,v 11.2 1996/07/16 22:05:28 jra Exp $ (BRL)";
@


11.2
log
@Minor Mods for IRIX 6.2
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/cat-fb.c,v 11.1 1995/01/04 10:08:55 mike Rel4_4 jra $ (BRL)";
a44 1
#define GLOBAL_RAILMAG		"/usr/brlcad/vfont/railmag"
d497 1
a497 1
		if ((rmfd = open(GLOBAL_RAILMAG, 0)) < 0) {
@


11.1
log
@Release_4.4
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/cat-fb.c,v 10.6 94/12/30 03:26:42 mike Exp $ (BRL)";
d361 2
d691 1
d880 1
@


10.6
log
@DEC Alpha
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/cat-fb.c,v 10.5 94/11/14 22:23:59 mike Exp Locker: mike $ (BRL)";
@


10.5
log
@Irix 6
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/cat-fb.c,v 10.4 94/08/23 18:48:54 gdurf Exp Locker: mike $ (BRL)";
d886 1
a886 1
		bzero(buf0p, rlines * bytes_per_line);
d894 1
a894 1
	bzero(buf0p, bytes_per_line * nlines);
@


10.4
log
@Added includes, factored ifdefs
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/cat-fb.c,v 10.3 1994/08/11 19:09:31 gdurf Exp gdurf $ (BRL)";
d148 1
a148 1
	'/',	/*/*/
d557 3
a559 1
/**			row = 25;	/** original value **/
d561 1
a706 1
	char cbuf[80];
d737 1
a737 1
	register int fnum, size, font;
d824 4
a827 4
		if ((c = spectab[code]) < 0)
			return(0);
	} else if ((c = asctab[code]) < 0)
		return(0);
d880 1
a880 1
	register int i, rlines;
@


10.3
log
@Added include of conf.h
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/cat-fb.c,v 10.2 1994/08/11 15:05:52 mike Exp gdurf $ (BRL)";
d36 1
a348 7

extern char	*malloc();

extern int	getopt();
extern char	*optarg;
extern int	optind;

@


10.2
log
@Reduced use of RGBpixel
Now use (unsigned char *)
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/cat-fb.c,v 10.1 91/10/12 06:46:02 mike Rel4_0 Locker: mike $ (BRL)";
d31 2
@


10.1
log
@Release_4.0
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/cat-fb.c,v 9.4 91/04/10 22:26:13 mike Exp $ (BRL)";
d49 1
a49 1
RGBpixel	*scanline;
d457 1
a457 1
	scanline = (RGBpixel *)cp;
d912 1
a912 1
	register RGBpixel *pp;
d937 1
a937 1
				pp += 8;
d943 1
a943 1
					COPYRGB( *pp, writing_color );
d945 1
a945 1
				pp++;
@


9.4
log
@Check error codes more.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/cat-fb.c,v 9.3 90/12/05 06:04:53 mike Exp $ (BRL)";
@


9.3
log
@lint
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/cat-fb.c,v 9.2 90/06/14 04:51:15 mike Exp $ (BRL)";
d653 1
a653 1
			outc(c);
d729 7
d799 7
d822 3
a824 2
	if (fontwanted)
		readinfont();
@


9.2
log
@changed from /usr/lib to /usr/brlcad
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/util/RCS/cat-fb.c,v 9.1 89/05/19 06:08:01 mike Rel3_5 $ (BRL)";
d364 1
d488 4
@


9.1
log
@Release_3.5
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: cat-fb.c,v 8.2 88/10/06 05:26:44 phil Exp $ (BRL)";
d42 1
a42 1
#define GLOBAL_RAILMAG		"/usr/lib/vfont/railmag"
@


8.2
log
@\0140 => \140 (some compilers barf after 3 chars)
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: cat-fb.c,v 8.1 88/10/05 00:40:44 phil Locked $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: cat-fb.c,v 1.14 88/09/17 06:06:07 mike Exp $ (BRL)";
d328 1
a328 1
	'\0140',/*` grave accent*/
@


1.14
log
@Changed \` to \0140 for ardent compiler
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: cat-fb.c,v 1.13 88/09/17 03:38:39 mike Exp $ (BRL)";
@


1.13
log
@Included machine.h to get SYSV defines for bzero()
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: cat-fb.c,v 1.12 88/09/09 04:07:12 mike Locked $ (BRL)";
d328 1
a328 1
	'\`',	/*` grave accent*/
@


1.12
log
@Added void ofile().
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: cat-fb.c,v 1.11 88/06/27 09:52:56 mike Locked $ (BRL)";
d33 1
a33 1

@


1.11
log
@Added additional debugging, after a fruitless chase which turned
out to be a defective TROFF on the SGI 4d.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: cat-fb.c,v 1.13 88/06/27 07:31:24 mike Locked $ (BRL)";
d363 2
d523 1
@


1.10
log
@Added debugging
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: cat-fb.c,v 1.9 88/05/22 03:18:58 mike Locked $ (BRL)";
d45 2
a46 2
#define CONVERT(n)		(n*(200./432.))
#define RECONVERT(n)		(n*(432./200.))
d104 2
a105 1
double	row, col;		/* position in phototypesetter units */
a524 1
	double scol;
a527 1
		if(debug>1)fprintf(stderr,"0%o v=%d (row=%g) h=%d col=%g\n", c, xpos, row, ypos, col);
d532 1
a532 1
			if(debug>1)fprintf(stderr,"esc=%d\n", esc);
d543 2
d633 1
a633 1
				if(debug)fprintf(stderr,"v=%d (%f)\n", xpos, row);
a644 1
			if(debug>1)fprintf(stderr,"outc(0%o %c)\n", c, c);
d664 4
d669 2
a670 1
	if (!(last_ssize & 0200) && (psp->stupid_code & 0200))
d672 1
a672 1
	else if ((last_ssize & 0200) && !(psp->stupid_code & 0200))
a675 4
	/*
	 * Due to the optics in the C/A/T, characters appear with an X offset
	 * when some of the larger sizes are used.
	 */
d677 1
a677 1
	if(debug>1)fprintf(stderr,"findsize: dorking escapment by %d, code=0%o, last_ssize=0%o, stupid_code=0%o\n", delta, code, last_ssize, psp->stupid_code);
d814 5
a818 2
	if(debug)fprintf(stderr,"%c h=%d v=%d  l=%d r=%d  u=%d d=%d  w=%d\n",
		c, ypos, xpos, vdp->vd_left, vdp->vd_right,
d820 1
@


1.9
log
@Lint fixes
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: cat-fb.c,v 1.8 88/05/22 03:08:44 mike Locked $ (BRL)";
d378 1
a378 1
			debug = 1;
d528 1
d533 1
d539 1
d644 1
d656 1
d664 1
a664 1
	code = 0;
d666 1
a666 1
		code = -55;
d668 1
a668 1
		code = 55;
d670 7
a676 2
		code = -code;
	esc += code;
@


1.8
log
@Added extra error message
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: cat-fb.c,v 1.7 88/05/21 08:58:33 mike Locked $ (BRL)";
a56 1
int	bytes_per_line;		/* # bytes of bitmap per line */
d60 3
a62 2
char	buffer[BUFFER_SIZE];	/* Big bitmap line buffers  */
char	*buf0p = &buffer[0];	/* Zero origin in circular buffer  */
d810 1
a810 1
	addr = &fontdes[cfont].vfp->vf_bits[vdp->vd_addr];
@


1.7
log
@Added -o flag to output image as an (upside down) pix-file.
Also changed default fonts to the Times fonts.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: cat-fb.c,v 1.6 88/05/21 04:50:11 mike Locked $ (BRL)";
d721 2
@


1.6
log
@Now holds one full screen of bits in memory, sized appropriately.
@
text
@d12 3
a14 3
 *	 512	2.56i
 *	1024	5.12i	(4.7i)
 *	1280	6.4i	(6.0i)
d16 1
a16 1
 *  Authors -
a17 1
 *	Michael John Muuss
d29 1
a29 1
static char RCSid[] = "@@(#)$Header: cat-fb.c,v 1.5 88/05/19 05:39:13 mike Locked $ (BRL)";
d358 1
a358 1
static int	overlay = 0;		/* overlay FROM STDIN rather than fb */
d360 1
d363 3
a365 2
Usage: cat-fb [-h -c -O] [-F framebuffer] [-C r/g/b]\n\
	[-S squarescrsize] [-W scr_width] [-N scr_height] [troff_files]\n";
d372 1
a372 1
	while ( (c = getopt( argc, argv, "dhcOF:S:W:N:C:" )) != EOF )  {
d374 3
d381 1
a381 1
			overlay = 1;
d393 1
d397 1
d401 1
d443 8
a450 4
	if( (fbp = fb_open( framebuffer, scr_width, scr_height )) == FBIO_NULL )
		exit(1);
	scr_width = fb_getwidth(fbp);
	scr_height = fb_getheight(fbp);
d462 1
a462 1
		if( overlay )  {
d464 1
a464 1
			overlay = 0;
d479 2
a480 1
	fb_close(fbp);
d493 14
a506 4
			/* Defaults */
			fontname[0] = "R";
			fontname[1] = "I";
			fontname[2] = "B";
d750 1
a750 1
	/* Reuse an existing slot, with Ron's strange heuristic */
d804 4
a843 1
  	/* cur_fb_line += nlines;  */
d866 1
d875 2
a876 2
	int	lpos;
	int	l;
d881 2
a882 1
			fb_close(fbp);
d887 1
a887 1
		else if( overlay )  {
d890 1
a890 1
				overlay = 0;
d909 4
a912 1
		fb_write( fbp, 0, cur_fb_line, scanline, scr_width );
@


1.5
log
@This version has proper vertical centering,
and some optional debugging.
@
text
@d14 1
a14 1
 *	1280	6.4i
d30 1
a30 1
static char RCSid[] = "@@(#)$Header: cat-fb.c,v 1.4 88/05/19 04:07:28 mike Locked $ (BRL)";
d55 6
a60 5
/* Single-bit wide typesetting buffer */
#define RASTER_LENGTH		2048
#define BYTES_PER_LINE		(RASTER_LENGTH/8)
#define NLINES			110
#define BUFFER_SIZE		(NLINES*BYTES_PER_LINE)
d443 1
d787 1
a787 1
	scanp = ( (xpos-vdp->vd_up-1)*BYTES_PER_LINE+
d791 1
a791 1
	scanp_inc = BYTES_PER_LINE-llen;
d819 1
a819 1
	rlines = (&buffer[BUFFER_SIZE] - buf0p) / BYTES_PER_LINE;
d823 1
a823 1
		bzero(buf0p, rlines * BYTES_PER_LINE);
d831 2
a832 2
	bzero(buf0p, BYTES_PER_LINE * nlines);
	buf0p += BYTES_PER_LINE * nlines;
d868 1
a868 1
		for( lpos = 0; lpos < BYTES_PER_LINE; lpos++)  {
@


1.4
log
@This version works as well as Ron's original ICAT did.
Added -O flag to composite (overlay) with STDIN, rather
than reading from screen.
@
text
@d10 6
d30 1
a30 1
static char RCSid[] = "@@(#)$Header: cat-fb.c,v 1.3 88/05/19 03:07:02 mike Locked $ (BRL)";
d104 1
a104 1
double	row, col;
d449 4
d525 2
a526 2
/**			row = 25;**/
			row = 0;
d605 1
d706 1
d777 3
d846 1
d852 1
a852 1
			fprintf(stderr, "cat-fb:  Ran off bottom\n");
d854 1
a854 1
			exit(1);
d867 5
d873 1
a873 1
				if(*buf & bit)  {
@


1.3
log
@This version now produces reasonable images on the SGI 4-D.
The problem was due to a negative left shift not being properly
executed as a positive right shift.
K&R is silent on what the effect should be, but the VAX and Gould
did it right...
@
text
@d7 3
d24 1
a24 1
static char RCSid[] = "@@(#)$Header: cat-fb.c,v 1.2 88/05/19 02:15:16 mike Locked $ (BRL)";
d32 1
a32 1
#define NFONTS			25
d34 1
a34 1
#define MAXF			4
d39 1
a42 1
#define RASTER_LENGTH		2048
d44 1
a44 1
RGBpixel	scanline[RASTER_LENGTH];
a48 2
char	crud[512];

d50 1
d55 1
a55 1
char	buffer[BUFFER_SIZE];	/* Big line buffers  */
a57 3
char	*calloc();
char	*nalloc();

d340 1
d342 76
a417 1
char	*index();
a421 1
	register int wait = 0;
d424 3
a426 18
	argc--, argv++;
	while(argc && argv[0][0] == '-')  {
		switch(argv[0][1])  {
		case 'c':
			cp = &(argv[0][2]);
			writing_color[RED] = (unsigned char) atoi(cp);
			cp = index(cp, ',') + 1;
			writing_color[GRN] = (unsigned char) atoi(cp);
			cp = index(cp, ',') + 1;
			writing_color[BLU] = (unsigned char) atoi(cp);
			break;
		default:
		  	fprintf(stderr, 
			   "Usage:  cat-fb [-cred,green,blue] [files...]\n");
			exit(1);
		}
		argc--;
		argv++;
d428 2
a429 1
	if( (fbp = fb_open( "", 0, 0 )) == FBIO_NULL )
d431 5
d437 12
a448 6
	readrm();
	for (;;) {
		if (argc > 0) {
			if (freopen(argv[0], "r", stdin) == NULL) {
				perror(argv[0]);
				argc--, argv++;
d451 2
a452 1
			argc--, argv++;
a453 3
		ofile();
		if (argc <= 0)
			break;
d455 1
d460 1
a460 1
readrm()
d486 2
a487 1
ofile()
d493 1
a493 2
	cur_fb_line = fb_getheight(fbp)-1;	/* start at top of screen */
	while ((c = getchar()) != EOF) {
d515 2
a516 1
			row = 25;
d610 1
a610 1
	slop_lines(NLINES);
a734 6
int	M[] = { 0xffffffff, 0xfefefefe, 0xfcfcfcfc, 0xf8f8f8f8,
		0xf0f0f0f0, 0xe0e0e0e0, 0xc0c0c0c0, 0x80808080, 0x0 };
int	N[] = { 0x00000000, 0x01010101, 0x03030303, 0x07070707,
		0x0f0f0f0f, 0x1f1f1f1f, 0x3f3f3f3f, 0x7f7f7f7f, 0xffffffff };
int	strim[] = { 0xffffffff, 0xffffff00, 0xffff0000, 0xff000000, 0 };

a821 19
char *
nalloc(i, j)
	int i, j;
{
	register char *cp;

	cp = calloc(i, j);
	/* fprintf(stderr, "allocated %d bytes at %x\n", i * j, cp); */
	return(cp);
}

nfree(cp)
	char *cp;
{

	/* fprintf(stderr, "freeing at %x\n", cp); */
	free(cp);
}

d840 9
a848 1
		fb_read( fbp, 0, cur_fb_line, scanline, fb_getwidth(fbp) );
d859 1
a859 1
		fb_write( fbp, 0, cur_fb_line, scanline, fb_getwidth(fbp) );
@


1.2
log
@Partly working on the 4D.  Buggy.
Checked in to provide a checkpoint of the work so far.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: cat-fb.c,v 1.1 88/05/18 21:22:48 mike Locked $ (BRL)";
d698 2
d710 2
a711 2
	offset = -((ypos-vdp->vd_left)&07);
	off8 = offset+8;
d716 1
d720 1
a720 1
				*scanp |= (fontdata << offset) &~ M[off8];
d722 1
a722 1
				*scanp |= (fontdata << off8) &~ N[off8];
@


1.1
log
@Initial revision
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
a24 2
#include <vfont.h>
#include <brlcad/fb.h>
d26 3
a28 2
#define DISPATCHSIZE		256	/* must be a power of two */
#define CHARMASK		(DISPATCHSIZE-1)
a30 1
#define DSIZ			((sizeof *dispatch)*DISPATCHSIZE)
a57 1
char	*allpanic();
a58 3
struct	header	header;
struct dispatch *dispatch;

d62 1
a62 2
	struct	dispatch *disp;
	char	*bits;
d64 2
a65 2
	-1,
	-1
a91 2
int	cfnum = -1;		/* current font number */
int	cpsize = 10;		/* current point size */
d93 1
a93 2
char	*bits;
int	nfontnum = -1;
d95 1
a95 1
int	npsize = 10;		/* new point size */
d386 1
d399 6
a404 2
			fprintf(stderr, "No railmag file\n");
			exit(1);
d457 1
a457 1
			if (loadfont(railmag, cpsize) < 0)
d570 3
a572 3
	psize = cpsize;
	if (fontwanted && psize != npsize)
		psize = npsize;
d577 1
d579 3
a581 3
	register int fnum;
	register int size;
	{
d586 5
a590 1
	if (fnum == cfnum && size == cpsize)
a593 4
			cfnum = fontdes[i].fnum;
			cpsize = fontdes[i].psize;
			dispatch = &fontdes[i].disp[0];
			bits = fontdes[i].bits;
d597 2
a598 6
	if (fnum < 0 || fnum >= MAXF) {
		fprintf(stderr, "Internal error: illegal font\n");
		return(-1);
	}
	nfontnum = fnum;
	npsize = size;
d604 1
a604 1
getfont()
d606 1
a607 1
	int d;
d610 2
a611 4
	if (!fontwanted)
		return(0);
	fnum = nfontnum;
	size = npsize;
d613 2
a614 3
	font = open(cbuf, 0);
	if (font == -1) {
		perror(cbuf);
d618 7
a624 32
	if (read(font, &header, sizeof header)!=sizeof header || header.magic!=0436)
		fprintf(stderr, "%s: Bad font file", cbuf);
	else {
		cfont = relfont();
		if (((bits=nalloc(header.size+DSIZ+1,1))== NULL)
			&& ((bits=allpanic(header.size+DSIZ+1))== NULL)) {
				fprintf(stderr, "%s: ran out of memory\n", cbuf);
				exit(1);
		} else {
			/*
			 * have allocated one chunk of mem for font, dispatch.
			 * get the dispatch addr, align to word boundary.
			 */
			d = (int) bits+header.size;
			d += 1;
			d &= ~1;
			if (read(font, d, DSIZ)!=DSIZ
			  || read(font, bits, header.size)!=header.size)
				fprintf(stderr, "bad font header");
			else {
				close(font);
				cfnum = fontdes[cfont].fnum = fnum;
				cpsize = fontdes[cfont].psize = size;
				fontdes[cfont].bits = bits;
				fontdes[cfont].disp = (struct dispatch *) d;
				dispatch = &fontdes[cfont].disp[0];
				fontwanted = 0;
				return (0);
			}
		}
	}
	close(font);
d626 2
a627 1
	return(-1);
d636 9
d651 1
a651 1
	if (fontdes[cfont].fnum != SPECIALFONT || fontdes[cfont].bits==0)
d655 6
a660 7
	if ((int)fontdes[newfont].bits != -1 && fontdes[newfont].bits != 0) {
		/* fprintf(stderr, "freeing position %d\n", newfont); */
		nfree(fontdes[newfont].bits);
	} else
		/* fprintf(stderr, "taking without freeing position %d\n", newfont); */
		;
	fontdes[newfont].bits = 0;
a663 18
char *
allpanic(nbytes)
	int nbytes;
{
	register int i;

	for (i = 0; i <= NFONTS; i++)
		if (fontdes[i].bits != (char *)-1 && fontdes[i].bits != (char *)0)
			nfree(fontdes[i].bits);
	lastloaded = cfont;
	for (i = 0; i <= NFONTS; i++) {
		fontdes[i].fnum = fontdes[i].psize = -1;
		fontdes[i].bits = 0;
		cfnum = cpsize = -1;
	}
	return(nalloc(nbytes,1));
}

d674 2
a675 2
	register struct dispatch *d;	/* ptr to character font record */
	register char *addr;		/* addr of font data */
d678 1
a678 1
	register char *scanp;		/* ptr to output buffer */
d687 1
a687 1
		getfont();
d693 31
a723 33
	d = dispatch+c;
	if (d->nbytes) {
		addr = bits+d->addr;
		llen = (d->left+d->right+7)/8;
		nlines = d->up+d->down;
		if (xpos+d->down >= NLINES)
			slop_lines(xpos+d->down-NLINES+1);
		scanp = ((xpos-d->up-1)*BYTES_PER_LINE+(ypos-d->left)/8)+buf0p;
		if (scanp < &buffer[0])
			scanp += BUFFER_SIZE;
		scanp_inc = BYTES_PER_LINE-llen;
		offset = -((ypos-d->left)&07);
		off8 = offset+8;
		for (i = 0; i < nlines; i++) {
			if (scanp >= &buffer[BUFFER_SIZE])
				scanp -= BUFFER_SIZE;
			count = llen;
			if (scanp + count <= &buffer[BUFFER_SIZE])
				do {
					fontdata = *(unsigned *)addr;
					addr += 4;
					if (count < 4)
						fontdata &= ~strim[count];
					*(unsigned *)scanp |= (fontdata << offset) &~ M[off8];
					scanp++;
					*(unsigned *)scanp |= (fontdata << off8) &~ N[off8];
					scanp += 3;
					count -= 4;
				} while (count > 0);
			scanp += scanp_inc+count;
			addr += count;
		}
		return (1);
d725 1
a725 1
	return (0);
d774 1
a774 1
 *  Overlay IKONAS display with indicated lines.
d788 1
@
