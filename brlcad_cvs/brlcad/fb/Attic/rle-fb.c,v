head	11.8;
access;
symbols
	ansi-20040405-merged:11.5.2.2
	postmerge-20040405-ansi:11.6
	premerge-20040404-ansi:11.5
	postmerge-autoconf:11.5
	autoconf-freeze:11.5
	premerge-autoconf:11.5
	ansi-20040316-freeze:11.5.2.1
	postmerge-20040315-windows:11.5
	premerge-20040315-windows:11.5
	windows-20040315-freeze:11.5
	autoconf-20031203:11.5
	autoconf-20031202:11.5
	autoconf-branch:11.5.0.10
	phong-branch:11.5.0.8
	photonmap-branch:11.5.0.6
	rel-6-1-DP:11.5
	windows-branch:11.5.0.4
	rel-6-0-2:11.3
	ansi-branch:11.5.0.2
	rel-6-0-1-branch:11.3.0.2
	hartley-6-0-post:11.4
	hartley-6-0-pre:11.3
	rel-6-0-1:11.3
	rel-6-0:11.3
	rel-5-4:11.1
	offsite-5-3-pre:11.2
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1;
locks; strict;
comment	@ * @;


11.8
date	2004.05.24.04.13.27;	author morrison;	state dead;
branches;
next	11.7;

11.7
date	2004.05.10.15.30.42;	author erikg;	state Exp;
branches;
next	11.6;

11.6
date	2004.04.05.07.49.23;	author morrison;	state Exp;
branches;
next	11.5;

11.5
date	2002.08.20.17.07.26;	author jra;	state Exp;
branches
	11.5.2.1;
next	11.4;

11.4
date	2002.08.15.20.54.39;	author hartley;	state Exp;
branches;
next	11.3;

11.3
date	2001.04.12.17.44.08;	author bparker;	state Exp;
branches;
next	11.2;

11.2
date	2000.08.24.03.58.35;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.09.47;	author mike;	state Rel4_4;
branches;
next	10.6;

10.6
date	94.10.18.12.26.42;	author jra;	state Exp;
branches;
next	10.5;

10.5
date	94.08.23.18.49.24;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	94.08.11.15.06.21;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.03.17.19.52.57;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.03.16.21.39.08;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.46.51;	author mike;	state Rel4_0;
branches;
next	9.2;

9.2
date	91.01.12.08.56.15;	author butler;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.11.36;	author mike;	state Rel3_5;
branches;
next	8.1;

8.1
date	88.10.05.00.44.28;	author mike;	state Rel3_0;
branches;
next	1.9;

1.9
date	88.10.03.20.58.13;	author phil;	state Exp;
branches;
next	1.8;

1.8
date	88.09.20.02.14.35;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	88.09.19.23.14.55;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	88.09.19.06.14.37;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	88.09.18.04.47.22;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	88.09.18.02.56.19;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	88.09.18.02.24.51;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	88.09.18.02.19.28;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	88.09.10.07.36.05;	author mike;	state Exp;
branches;
next	;

11.5.2.1
date	2002.09.19.18.00.43;	author morrison;	state Exp;
branches;
next	11.5.2.2;

11.5.2.2
date	2004.04.04.20.46.22;	author morrison;	state Exp;
branches;
next	;


desc
@Program to display Utah Raster Toolkit RLE files on BRL-CAD libfb
framebuffer
@


11.8
log
@moved to src/fb/
@
text
@/*
 *			R L E - F B . C
 *
 *  Decode a Utah Raster Toolkit RLE image, and display on a
 *  BRL libfb(3) framebuffer.
 *
 *  Authors -
 *	Michael John Muuss
 *	Paul R. Stay
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimitied.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Id: rle-fb.c,v 11.7 2004/05/10 15:30:42 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>

#include "machine.h"
#include "externs.h"
#include "fb.h"
#include "rle.h"

static FILE	*infp;
static char	*infile;

static int	background[3];
static int	override_background;

unsigned char	*rows[4];		/* Character pointers for rle_getrow */
	
static unsigned char	*scan_buf;		/* single scanline buffer */
static ColorMap	cmap;

static char	*framebuffer = (char *)0;
static int	screen_width = 0;
static int	screen_height = 0;
static int	scr_xoff = 0;
static int	scr_yoff = 0;

static int	crunch;
static int	overlay;
static int	r_debug;

static char	usage[] = "\
Usage: rle-fb [-c -d -h -O] [-F framebuffer]  [-C r/g/b]\n\
	[-S squarescrsize] [-W scr_width] [-N scr_height]\n\
	[-X scr_xoff] [-Y scr_yoff] [file.rle]\n\
";

/*
 *			G E T _ A R G S
 */
static int
get_args(int argc, register char **argv)
{
	register int	c;

	while( (c = getopt( argc, argv, "cOdhs:S:w:W:n:N:C:F:X:Y:" )) != EOF )  {
		switch( c )  {
		case 'O':
			overlay = 1;
			break;
		case 'd':
			r_debug = 1;
			break;
		case 'F':
			framebuffer = optarg;
			break;
		case 'c':
			crunch = 1;
			break;
		case 'h':
			/* high-res */
			screen_height = screen_width = 1024;
			break;
		case 'S':
		case 's':
			/* square screen size */
			screen_height = screen_width = atoi(optarg);
			break;
		case 'W':
		case 'w':
			screen_width = atoi(optarg);
			break;
		case 'N':
		case 'n':
			screen_height = atoi(optarg);
			break;
		case 'X':
			scr_xoff = atoi(optarg);
			break;
		case 'Y':
			scr_yoff = atoi(optarg);
			break;
		case 'C':
			{
				register char *cp = optarg;
				register int *conp = background;

				/* premature null => atoi gives zeros */
				for( c=0; c < 3; c++ )  {
					*conp++ = atoi(cp);
					while( *cp && *cp++ != '/' ) ;
				}
				override_background = 1;
			}
			break;
		default:
		case '?':
			return	0;
		}
	}
	if( argv[optind] != NULL )  {
		if( (infp = fopen( (infile=argv[optind]), "r" )) == NULL )  {
			perror(infile);
			return	0;
		}
		optind++;
	} else {
		infile = "-";
	}
	if( argc > ++optind )
		(void) fprintf( stderr, "rle-fb:  excess arguments ignored\n" );

	if( isatty(fileno(infp)) )
		return 0;
	return	1;
}

/*
 *			M A I N
 */
int
main(int argc, char **argv)
{
	FBIO	*fbp;
	register int i;
	int	file_width;		/* unclipped width of rectangle */
	int	file_skiplen;		/* # of pixels to skip on l.h.s. */
	int	screen_xbase;		/* screen X of l.h.s. of rectangle */
	int	screen_xlen;		/* clipped len of rectangle */
	int	ncolors;

	infp = stdin;
	if( !get_args( argc, argv ) )  {
		(void)fputs(usage, stderr);
		exit( 1 );
	}

	rle_dflt_hdr.rle_file = infp;
	if( rle_get_setup( &rle_dflt_hdr ) < 0 )  {
		fprintf(stderr, "rle-fb: Error reading setup information\n");
		exit(1);
	}

	if (r_debug)  {
		fprintf( stderr,"Image bounds\n\tmin %d %d\n\tmax %d %d\n",
			rle_dflt_hdr.xmin, rle_dflt_hdr.ymin,
			rle_dflt_hdr.xmax, rle_dflt_hdr.ymax );
		fprintf(stderr, "%d color channels\n", rle_dflt_hdr.ncolors);
		fprintf(stderr,"%d color map channels\n", rle_dflt_hdr.ncmap);
		if ( rle_dflt_hdr.alpha )
			fprintf( stderr, "Alpha Channel present in input, ignored.\n");
		for( i=0; i < rle_dflt_hdr.ncolors; i++ )
			fprintf(stderr,"Background channel %d = %d\n",
				i, rle_dflt_hdr.bg_color[i] );
		rle_debug(1);
	}

	if( rle_dflt_hdr.ncmap == 0 )
		crunch = 0;

	/* Only interested in R, G, & B */
	RLE_CLR_BIT(rle_dflt_hdr, RLE_ALPHA);
	for (i = 3; i < rle_dflt_hdr.ncolors; i++)
		RLE_CLR_BIT(rle_dflt_hdr, i);
	ncolors = rle_dflt_hdr.ncolors > 3 ? 3 : rle_dflt_hdr.ncolors;

	/* Optional switch of library to overlay mode */
	if( overlay )  {
		rle_dflt_hdr.background = 1;		/* overlay */
		override_background = 0;
	}

	/* Optional background color override */
	if( override_background )  {
		for( i=0; i<ncolors; i++ )
			rle_dflt_hdr.bg_color[i] = background[i];
	}

	file_width = rle_dflt_hdr.xmax - rle_dflt_hdr.xmin + 1;

	/* If screen sizes not specified, try to display rectangle part > 0 */
	if( screen_width == 0 )  {
	    	screen_width = rle_dflt_hdr.xmax + 1;
		if( scr_xoff > 0 )
			screen_width += scr_xoff;
	}
	if( screen_height == 0 )  {
	    	screen_height = rle_dflt_hdr.ymax + 1;
		if( scr_yoff > 0 )
			screen_height += scr_yoff;
	}

	/* Incorporate command-line rectangle repositioning */
	rle_dflt_hdr.xmin += scr_xoff;
	rle_dflt_hdr.xmax += scr_xoff;
	rle_dflt_hdr.ymin += scr_yoff;

	/* Pretend saved image origin is at 0, clip & position in fb_write call */
	screen_xbase = rle_dflt_hdr.xmin;
	rle_dflt_hdr.xmax -= screen_xbase;
	rle_dflt_hdr.xmin = 0;

	if( (fbp = fb_open( framebuffer, screen_width, screen_height )) == FBIO_NULL )
		exit(12);

	/* Honor original screen size desires, if set, unless they shrank */
	if( screen_width > 0 && fb_getwidth(fbp) < screen_width )
		screen_width = fb_getwidth(fbp);
	if( screen_height > 0 && fb_getheight(fbp) < screen_height )
		screen_height = fb_getheight(fbp);

	/* Discard any scanlines which exceed screen height */
	if( rle_dflt_hdr.ymax > screen_height-1 )
		rle_dflt_hdr.ymax = screen_height-1;

	/* Clip left edge */
	screen_xlen = rle_dflt_hdr.xmax + 1;
	file_skiplen = 0;
	if( screen_xbase < 0 )  {
		file_skiplen = -screen_xbase;
		screen_xbase = 0;
		screen_xlen -= file_skiplen;
	}
	/* Clip right edge */
	if( screen_xbase + screen_xlen > screen_width )
		screen_xlen = screen_width - screen_xbase;
	if( screen_xlen <= 0 ||
	    rle_dflt_hdr.ymin > screen_height ||
	    rle_dflt_hdr.ymax < 0 )  {
	    	fprintf(stderr,
		"rle-fb:  Warning:  RLE image rectangle entirely off screen\n");
		goto done;
	}

	scan_buf = (unsigned char *)malloc( sizeof(RGBpixel) * screen_width );

	for( i=0; i < ncolors; i++ )
		rows[i] = (unsigned char *)malloc((size_t)file_width);
	for( ; i < 3; i++ )
		rows[i] = rows[0];	/* handle monochrome images */

	/*
	 *  Import Utah color map, converting to libfb format.
	 *  Check for old format color maps, where high 8 bits
	 *  were zero, and correct them.
	 *  XXX need to handle < 3 channels of color map, by replication.
	 */
	if( rle_dflt_hdr.ncmap > 0 )  {
		register int maplen = (1 << rle_dflt_hdr.cmaplen);
		register int all = 0;
		for( i=0; i<256; i++ )  {
			cmap.cm_red[i] = rle_dflt_hdr.cmap[i];
			cmap.cm_green[i] = rle_dflt_hdr.cmap[i+maplen];
			cmap.cm_blue[i] = rle_dflt_hdr.cmap[i+2*maplen];
			all |= cmap.cm_red[i] | cmap.cm_green[i] |
				cmap.cm_blue[i];
		}
		if( (all & 0xFF00) == 0 && (all & 0x00FF) != 0 )  {
			/*  This is an old (Edition 2) color map.
			 *  Correct by shifting it left 8 bits.
			 */
			for( i=0; i<256; i++ )  {
				cmap.cm_red[i] <<= 8;
				cmap.cm_green[i] <<= 8;
				cmap.cm_blue[i] <<= 8;
			}
			fprintf(stderr,
				"rle-fb: correcting for old style colormap\n");
		}
	}
	if( rle_dflt_hdr.ncmap > 0 && !crunch )
		(void)fb_wmap( fbp, &cmap );
	else
		(void)fb_wmap( fbp, COLORMAP_NULL );

	/* Handle any lines below zero in y.  Decode and discard. */
	for( i = rle_dflt_hdr.ymin; i < 0; i++ )
		rle_getrow( &rle_dflt_hdr, rows );

	for( ; i <= rle_dflt_hdr.ymax; i++)  {
		register unsigned char	*pp = (unsigned char *)scan_buf;
		register rle_pixel	*rp = &(rows[0][file_skiplen]);
		register rle_pixel	*gp = &(rows[1][file_skiplen]);
		register rle_pixel	*bp = &(rows[2][file_skiplen]);
		register int		j;

		if( overlay )  {
			fb_read( fbp, screen_xbase, i, scan_buf, screen_xlen );
			for( j = 0; j < screen_xlen; j++ )  {
				*rp++ = *pp++;
				*gp++ = *pp++;
				*bp++ = *pp++;
			}
			pp = (unsigned char *)scan_buf;
			rp = &(rows[0][file_skiplen]);
			gp = &(rows[1][file_skiplen]);
			bp = &(rows[2][file_skiplen]);
		}

		rle_getrow(&rle_dflt_hdr, rows );

		/* Grumble, convert from Utah layout */
		if( !crunch )  {
			for( j = 0; j < screen_xlen; j++)  {
				*pp++ = *rp++;
				*pp++ = *gp++;
				*pp++ = *bp++;
			}
		} else {
			for( j = 0; j < screen_xlen; j++)  {
				*pp++ = cmap.cm_red[*rp++]>>8;
				*pp++ = cmap.cm_green[*gp++]>>8;
				*pp++ = cmap.cm_blue[*bp++]>>8;
			}
		}
		if( fb_write( fbp, screen_xbase, i, scan_buf, screen_xlen ) != screen_xlen )  break;
	}
done:
	fb_close( fbp );
	exit(0);
}
@


11.7
log
@change conf.h to a wrapped config.h
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Id: rle-fb.c,v 11.6 2004/04/05 07:49:23 morrison Exp $ (BRL)";
@


11.6
log
@merge of ansi-6-0-branch into HEAD
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Id$ (BRL)";
d23 5
a27 1
#include "conf.h"
@


11.5
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Id: rle-fb.c,v 11.3 2001/04/12 17:44:08 bparker Exp $ (BRL)";
d63 1
a63 2
get_args( argc, argv )
register char	**argv;
d143 1
a143 3
main( argc, argv)
int argc;
char ** argv;
d259 1
a259 1
		rows[i] = (unsigned char *)malloc(file_width);
@


11.5.2.1
log
@Initial ANSIfication
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Id: rle-fb.c,v 11.5 2002/08/20 17:07:26 jra Exp $ (BRL)";
d63 2
a64 1
get_args(int argc, register char **argv)
d144 3
a146 1
main(int argc, char **argv)
@


11.5.2.2
log
@quell warnings
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Id: rle-fb.c,v 11.5.2.1 2002/09/19 18:00:43 morrison Exp $ (BRL)";
d259 1
a259 1
		rows[i] = (unsigned char *)malloc((size_t)file_width);
@


11.4
log
@Converted from K&R to ANSI C - RFH
@
text
@d63 2
a64 1
get_args(int argc, register char **argv)
d144 3
a146 1
main(int argc, char **argv)
@


11.3
log
@*- get rid of warnings
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Id: rle-fb.c,v 11.2 2000/08/24 03:58:35 mike Exp $ (BRL)";
d63 1
a63 2
get_args( argc, argv )
register char	**argv;
d143 1
a143 3
main( argc, argv)
int argc;
char ** argv;
@


11.2
log
@
const RCSid
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Id: rle-fb.c,v 11.1 1995/01/04 10:09:47 mike Rel4_4 $ (BRL)";
d143 1
@


11.1
log
@Release_4.4
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Id: rle-fb.c,v 10.6 94/10/18 12:26:42 jra Exp $ (BRL)";
@


10.6
log
@removed extra adjustment for scr_yoff
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Id: rle-fb.c,v 10.5 94/08/23 18:49:24 gdurf Exp Locker: jra $ (BRL)";
@


10.5
log
@Added includes, factored ifdefs
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Id: rle-fb.c,v 10.4 1994/08/11 15:06:21 mike Exp gdurf $ (BRL)";
a219 1
	rle_dflt_hdr.ymax += scr_yoff;
@


10.4
log
@Reduced use of RGBpixel
Now use (unsigned char *)
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Id: rle-fb.c,v 10.3 92/03/17 19:52:57 mike Exp Locker: mike $ (BRL)";
d23 2
d26 1
@


10.3
log
@Need to set infp before get_args() call.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Id: rle-fb.c,v 10.2 92/03/16 21:39:08 mike Exp Locker: mike $ (BRL)";
d24 2
a28 6
extern int	optind;
extern char	*optarg;
extern char	*getenv();

extern char	*malloc();

d37 1
a37 1
static RGBpixel	*scan_buf;		/* single scanline buffer */
d256 1
a256 1
	scan_buf = (RGBpixel *)malloc( sizeof(RGBpixel) * screen_width );
d337 1
a337 1
		fb_write( fbp, screen_xbase, i, scan_buf, screen_xlen );
@


10.2
log
@IRIX 4.0.1
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Id: rle-fb.c,v 10.1 91/10/12 06:46:51 mike Rel4_0 Locker: mike $ (BRL)";
d156 1
a161 1
	infp = stdin;
@


10.1
log
@Release_4.0
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Id: /f/cad/util/RCS/rle-fb.c,v 1.1 91/01/03 23:11:44 butler Exp $ (BRL)";
d33 1
a33 1
static FILE	*infp = stdin;
d161 1
@


9.2
log
@changes in names to work with Rel 3 of URT library
@
text
@@


9.1
log
@Release_3.5
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rle-fb.c,v 8.1 88/10/05 00:44:28 mike Rel3_0 $ (BRL)";
d25 1
a25 1
#include "svfb_global.h"
d161 2
a162 2
	sv_globals.svfb_fd = infp;
	if( rle_get_setup( &sv_globals ) < 0 )  {
d169 5
a173 5
			sv_globals.sv_xmin, sv_globals.sv_ymin,
			sv_globals.sv_xmax, sv_globals.sv_ymax );
		fprintf(stderr, "%d color channels\n", sv_globals.sv_ncolors);
		fprintf(stderr,"%d color map channels\n", sv_globals.sv_ncmap);
		if ( sv_globals.sv_alpha )
d175 1
a175 1
		for( i=0; i < sv_globals.sv_ncolors; i++ )
d177 1
a177 1
				i, sv_globals.sv_bg_color[i] );
d181 1
a181 1
	if( sv_globals.sv_ncmap == 0 )
d185 4
a188 4
	SV_CLR_BIT(sv_globals, SV_ALPHA);
	for (i = 3; i < sv_globals.sv_ncolors; i++)
		SV_CLR_BIT(sv_globals, i);
	ncolors = sv_globals.sv_ncolors > 3 ? 3 : sv_globals.sv_ncolors;
d192 1
a192 1
		sv_globals.sv_background = 1;		/* overlay */
d199 1
a199 1
			sv_globals.sv_bg_color[i] = background[i];
d202 1
a202 1
	file_width = sv_globals.sv_xmax - sv_globals.sv_xmin + 1;
d206 1
a206 1
	    	screen_width = sv_globals.sv_xmax + 1;
d211 1
a211 1
	    	screen_height = sv_globals.sv_ymax + 1;
d217 4
a220 4
	sv_globals.sv_xmin += scr_xoff;
	sv_globals.sv_xmax += scr_xoff;
	sv_globals.sv_ymin += scr_yoff;
	sv_globals.sv_ymax += scr_yoff;
d223 3
a225 3
	screen_xbase = sv_globals.sv_xmin;
	sv_globals.sv_xmax -= screen_xbase;
	sv_globals.sv_xmin = 0;
d237 2
a238 2
	if( sv_globals.sv_ymax > screen_height-1 )
		sv_globals.sv_ymax = screen_height-1;
d241 1
a241 1
	screen_xlen = sv_globals.sv_xmax + 1;
d252 2
a253 2
	    sv_globals.sv_ymin > screen_height ||
	    sv_globals.sv_ymax < 0 )  {
d272 2
a273 2
	if( sv_globals.sv_ncmap > 0 )  {
		register int maplen = (1 << sv_globals.sv_cmaplen);
d276 3
a278 3
			cmap.cm_red[i] = sv_globals.sv_cmap[i];
			cmap.cm_green[i] = sv_globals.sv_cmap[i+maplen];
			cmap.cm_blue[i] = sv_globals.sv_cmap[i+2*maplen];
d295 1
a295 1
	if( sv_globals.sv_ncmap > 0 && !crunch )
d301 2
a302 2
	for( i = sv_globals.sv_ymin; i < 0; i++ )
		rle_getrow( &sv_globals, rows );
d304 1
a304 1
	for( ; i <= sv_globals.sv_ymax; i++)  {
d324 1
a324 1
		rle_getrow(&sv_globals, rows );
@


8.1
log
@Release_3.0
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rle-fb.c,v 1.9 88/10/03 20:58:13 phil Exp $ (BRL)";
@


1.9
log
@if no colormap is given, or in crunch mode, load a standard colormap
so users wont be surprised by the results.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rle-fb.c,v 1.8 88/09/20 02:14:35 phil Locked $ (BRL)";
@


1.8
log
@Added default case to getopt() switch, to catch little errors
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rle-fb.c,v 1.7 88/09/19 23:14:55 mike Exp $ (BRL)";
d297 2
a298 1

@


1.7
log
@Fixed auto-screen-size select for use on Ikonas.
If original image was hires, but it is being shifted into the
lower 512x512 area, don't switch framebuffer into lores.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rle-fb.c,v 1.6 88/09/19 06:14:37 mike Locked $ (BRL)";
d119 1
@


1.6
log
@This version has working -X and -Y options to reposition image
on the screen, with clipping.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rle-fb.c,v 1.5 88/09/18 04:47:22 mike Locked $ (BRL)";
d201 14
a219 8

	/* If screen sizes not specified, try to display rectangle part > 0 */
	if( screen_width == 0 )
	    	screen_width = sv_globals.sv_xmax + 1;
	if( screen_height == 0 )
	    	screen_height = sv_globals.sv_ymax + 1;

	file_width = sv_globals.sv_xmax - sv_globals.sv_xmin + 1;
@


1.5
log
@Initial support for -X, -Y (screen offset).
More code is needed.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rle-fb.c,v 1.4 88/09/18 02:56:19 mike Locked $ (BRL)";
d133 1
a133 1
		(void) fprintf( stderr, "Excess arguments ignored\n" );
d149 4
a152 2
	int	x_len, y_len;
	int	xbase;
d201 1
d206 3
a208 2
	if( sv_globals.sv_xmax > screen_width ||
	    sv_globals.sv_ymax > screen_height )  {
d210 1
a211 1
	}
d213 1
a213 2
	x_len = sv_globals.sv_xmax - sv_globals.sv_xmin + 1;
	y_len = sv_globals.sv_ymax - sv_globals.sv_ymin + 1;
d215 3
a217 3
	/* Pretend saved image origin is at 0, fix in fb_write call */
	xbase = sv_globals.sv_xmin;
	sv_globals.sv_xmax -= xbase;
a221 2
	screen_width = fb_getwidth(fbp);
	screen_height = fb_getheight(fbp);
d223 29
d255 1
a255 1
		rows[i] = (unsigned char *)malloc(x_len);
d292 5
a296 1
	for ( i = sv_globals.sv_ymin; i <= sv_globals.sv_ymax; i++)  {
d298 3
a300 3
		register rle_pixel	*rp = rows[0];
		register rle_pixel	*gp = rows[1];
		register rle_pixel	*bp = rows[2];
d304 2
a305 2
			fb_read( fbp, xbase, i, scan_buf, x_len );
			for( j = 0; j < x_len; j++ )  {
d311 3
a313 3
			rp = rows[0];
			gp = rows[1];
			bp = rows[2];
d320 1
a320 1
			for ( j = 0; j < x_len; j++)  {
d326 1
a326 1
			for ( j = 0; j < x_len; j++)  {
d332 1
a332 1
		fb_write( fbp, xbase, i, scan_buf, x_len );
d334 1
@


1.4
log
@Added overlay feature
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rle-fb.c,v 1.3 88/09/18 02:24:51 mike Locked $ (BRL)";
d47 2
d55 3
a57 2
Usage: rle-fb [-h -d -v -c -O] [-F framebuffer]  [-C r/g/b]\n\
	[-s squarefilesize] [-w file_width] [-n file_height] [file.rle]\n\
d69 1
a69 1
	while( (c = getopt( argc, argv, "cOdhs:w:n:C:F:" )) != EOF )  {
d87 1
d92 1
d96 1
d100 6
d199 4
@


1.3
log
@Added fb_close
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rle-fb.c,v 1.2 88/09/18 02:19:28 mike Locked $ (BRL)";
d49 1
a49 1

d53 1
a53 1
Usage: rle-fb [-h -d -v -c] [-F framebuffer]  [-C r/g/b]\n\
d66 1
a66 1
	while( (c = getopt( argc, argv, "cdhs:w:n:C:F:" )) != EOF )  {
d68 3
d175 6
d217 1
d252 13
@


1.2
log
@Added code to detect and correct old (Edition 2) colormaps,
which were in the low 8 bits, with the high 8 bits set to zero.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rle-fb.c,v 1.1 88/09/10 07:36:05 mike Locked $ (BRL)";
d261 1
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d180 2
a181 2
	    	screen_width = sv_globals.sv_xmax;
	    	screen_height = sv_globals.sv_ymax;
d204 5
a208 1
	/* colormap.  ignore, send to libfb, "crunch" ? */
d211 1
d216 14
@
