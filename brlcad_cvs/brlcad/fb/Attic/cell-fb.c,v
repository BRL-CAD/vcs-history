head	11.24;
access;
symbols
	ansi-20040405-merged:11.21.2.1
	postmerge-20040405-ansi:11.22
	premerge-20040404-ansi:11.21
	postmerge-autoconf:11.21
	autoconf-freeze:11.21
	premerge-autoconf:11.21
	ansi-20040316-freeze:11.21.2.1
	postmerge-20040315-windows:11.21
	premerge-20040315-windows:11.21
	windows-20040315-freeze:11.21
	autoconf-20031203:11.21
	autoconf-20031202:11.21
	autoconf-branch:11.21.0.10
	phong-branch:11.21.0.8
	photonmap-branch:11.21.0.6
	rel-6-1-DP:11.21
	windows-branch:11.21.0.4
	rel-6-0-2:11.19
	ansi-branch:11.21.0.2
	rel-6-0-1-branch:11.19.0.2
	hartley-6-0-post:11.20
	hartley-6-0-pre:11.19
	rel-6-0-1:11.19
	rel-6-0:11.19
	rel-5-4:11.13
	offsite-5-3-pre:11.14
	rel-5-3:11.13
	rel-5-2:11.13
	rel-5-1-branch:11.13.0.2
	rel-5-1:11.13
	rel-5-0:11.11
	rel-5-0-beta:11.10
	rel-4-5:11.3
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.24
date	2004.05.24.04.13.25;	author morrison;	state dead;
branches;
next	11.23;

11.23
date	2004.05.10.15.30.42;	author erikg;	state Exp;
branches;
next	11.22;

11.22
date	2004.04.05.07.49.23;	author morrison;	state Exp;
branches;
next	11.21;

11.21
date	2002.08.20.17.07.23;	author jra;	state Exp;
branches
	11.21.2.1;
next	11.20;

11.20
date	2002.08.15.20.54.36;	author hartley;	state Exp;
branches;
next	11.19;

11.19
date	2001.08.21.17.47.10;	author jra;	state Exp;
branches;
next	11.18;

11.18
date	2001.08.10.21.27.04;	author butler;	state Exp;
branches;
next	11.17;

11.17
date	2001.04.12.17.44.07;	author bparker;	state Exp;
branches;
next	11.16;

11.16
date	2001.04.05.19.35.02;	author morrison;	state Exp;
branches;
next	11.15;

11.15
date	2001.04.02.21.37.44;	author morrison;	state Exp;
branches;
next	11.14;

11.14
date	2000.08.24.03.58.21;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	2000.01.31.15.30.41;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	99.10.22.20.22.24;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	99.06.30.20.36.56;	author pjt;	state Exp;
branches;
next	11.10;

11.10
date	99.02.08.18.38.31;	author pjt;	state Exp;
branches;
next	11.9;

11.9
date	99.01.04.20.04.18;	author pjt;	state Exp;
branches;
next	11.8;

11.8
date	98.12.30.04.57.46;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	98.09.22.02.44.37;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	98.06.25.08.30.22;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	98.06.08.19.35.05;	author pjt;	state Exp;
branches;
next	11.4;

11.4
date	98.06.08.17.46.59;	author pjt;	state Exp;
branches;
next	11.3;

11.3
date	97.03.19.20.15.35;	author pjt;	state Exp;
branches;
next	11.2;

11.2
date	95.09.26.19.59.43;	author pjt;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.08.57;	author mike;	state Rel4_4;
branches;
next	10.11;

10.11
date	94.12.08.16.03.23;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	94.11.14.22.25.22;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	94.10.03.15.13.00;	author pjt;	state Exp;
branches;
next	10.8;

10.8
date	94.10.03.14.54.15;	author pjt;	state Exp;
branches;
next	10.7;

10.7
date	94.10.03.14.36.03;	author pjt;	state Exp;
branches;
next	10.6;

10.6
date	94.10.03.08.40.25;	author pjt;	state Exp;
branches;
next	10.5;

10.5
date	94.09.02.09.15.56;	author pjt;	state Exp;
branches;
next	10.4;

10.4
date	94.08.30.10.57.48;	author pjt;	state Exp;
branches;
next	10.3;

10.3
date	94.08.11.19.10.48;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.08.11.15.05.54;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.46.03;	author mike;	state Rel4_0;
branches;
next	2.19;

2.19
date	91.10.11.11.56.53;	author butler;	state Exp;
branches;
next	2.18;

2.18
date	91.08.16.15.12.10;	author butler;	state Exp;
branches;
next	2.17;

2.17
date	91.07.24.01.14.54;	author mike;	state Exp;
branches;
next	2.16;

2.16
date	91.07.22.21.43.06;	author mike;	state Exp;
branches;
next	2.15;

2.15
date	91.07.06.03.34.33;	author mike;	state Exp;
branches;
next	2.14;

2.14
date	91.07.02.03.29.29;	author mike;	state Exp;
branches;
next	2.13;

2.13
date	91.06.26.04.54.41;	author mike;	state Exp;
branches;
next	2.12;

2.12
date	91.06.26.04.50.33;	author mike;	state Exp;
branches;
next	2.11;

2.11
date	91.06.26.04.14.56;	author mike;	state Exp;
branches;
next	2.10;

2.10
date	91.06.26.02.28.24;	author mike;	state Exp;
branches;
next	2.9;

2.9
date	91.06.26.02.19.18;	author mike;	state Exp;
branches;
next	2.8;

2.8
date	91.06.26.02.03.19;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	91.06.26.01.59.24;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	91.06.26.01.56.03;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	91.06.26.01.31.17;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	91.06.26.01.02.10;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	91.06.25.13.25.51;	author sue;	state Exp;
branches;
next	2.2;

2.2
date	91.06.23.00.19.02;	author sue;	state Exp;
branches;
next	2.1;

2.1
date	91.06.10.09.20.14;	author pjt;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.23.53.00;	author pjt;	state Exp;
branches;
next	;

11.21.2.1
date	2002.09.19.18.00.39;	author morrison;	state Exp;
branches;
next	;


desc
@Program to display cell plots
@


11.24
log
@moved to src/fb/
@
text
@/*
 *			C E L L - F B . C
 *
 *	Original author:	Gary S. Moss
 *				(301) 278-2979 or AV 298-2979
 *
 *	Modifications by:	Paul J. Tanenbaum
 *				(301) 278-6691 or AV 298-6691
 *
 *	Both of whom are at:	U. S. Army Ballistic Research Laboratory
 *				Aberdeen Proving Ground
 *				Maryland 21005-5066
 */

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/fb/cell-fb.c,v 11.23 2004/05/10 15:30:42 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <time.h>
#include <math.h>
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
#include "fb.h"

/* Macros without arguments */
#ifndef STATIC
#define STATIC static
#endif

#ifndef true
#define false	0
#define true	1
#endif

#define LORES		512
#define HIRES		1024
#define	SNUG_FIT	1
#define	LOOSE_FIT	2
#define MAX_LINE	1025
#if !defined(PI)	/* sometimes found in math.h */
# define PI		3.14159265358979323846264338327950288419716939937511
#endif
#define HFPI		(PI/2.0)
#define NEG_INFINITY	-10000000.0
#define POS_INFINITY	10000000.0
#define MAX_COLORTBL	11
#define WHITE		colortbl[0]
#define BACKGROUND	colortbl[MAX_COLORTBL]
#define	OPT_STRING	"CM:F:N:S:W:X:a:b:c:d:ef:ghikl:m:p:s:v:x:?"
#define	BLEND_USING_HSV	1


/* Macros with arguments */
#ifndef Min
#define Min(a, b)		((a) < (b) ? (a) : (b))
#define Max(a, b)		((a) > (b) ? (a) : (b))
#define MinMax(m, M, a)    { m = Min(m, a); M = Max(M, a); }
#endif

/*
 * Translate between different coordinate systems at play:
 *	H,V	The units of the input file.  (from GIFT)
 *	C	The relative cell number, within the input
 *	VP	The pixel within the viewport (a sub-rectangle of the screen)
 *		Includes offsetting for the "key" area within the viewport.
 *	SCR	The pixel on the screen.  Framebuffer coordinates for LIBFB.
 *		Includes offsetting the viewport anywhere on the screen.
 */

#define H2CX(_h)	( (int)(((_h) - xmin) / cell_size + 0.5) )
#define V2CY(_v)	( (int)(((_v) - ymin) / cell_size + 0.5) )

#define CX2VPX(_cx)	( ((_cx)             ) * (wid + grid_flag) )
#define CY2VPY(_cy)	( ((_cy) + key_height) * (hgt + grid_flag) )

#define VPX2SCRX(_vp_x)	( (_vp_x) + xorigin )
#define VPY2SCRY(_vp_y)	( (_vp_y) + yorigin )

/* --- */

#define SCRX2VPX(_scr_x) ( (_scr_x) - xorigin )
#define SCRY2VPY(_scr_y) ( (_scr_y) - yorigin )

#define VPX2CX(_vp_x)	( (_vp_x) / (wid+grid_flag) )
#define VPY2CY(_vp_y)	( (_vp_y) / (hgt+grid_flag) - key_height )

#define CX2H(_cx)	( (_cx) * cell_size + xmin )
#define CY2V(_cy)	( (_cy) * cell_size + ymin )

/* --- */

#define H2SCRX(_h)	VPX2SCRX( CX2VPX( H2CX(_h) ) )
#define V2SCRY(_v)	VPY2SCRY( CY2VPY( V2CY(_v) ) )

#define SCRX2H(_s_x)	CX2H( VPX2CX( SCRX2VPX(_s_x) ) )
#define SCRY2V(_s_y)	CY2V( VPY2CY( SCRY2VPY(_s_y) ) )

/* Absolute value */
#define Abs(_a)	((_a) < 0.0 ? -(_a) : (_a))

/* Debug flags */
#define		CFB_DBG_MINMAX		0x01
#define		CFB_DBG_GRID		0x02
#define		CFB_DBG_MEM		0x010000	/* a la librt(3) */

/* Data structure definitions */
typedef int		bool;
typedef union
{
    double		v_scalar;
    RGBpixel		v_color;
} cell_val;
typedef struct
{
    double		c_x;
    double		c_y;
    cell_val		c_val;
} Cell;
struct locrec
{
    struct bu_list	l;
    fastf_t		h;
    fastf_t		v;
};
#define	LOCREC_MAGIC	0x6c637263
#define locrec_magic	l.magic

/* Global variables */
static Cell	*grid;

static char	*usage[] = {
	"",
	"cell-fb ($Revision: 11.23 $)",
	"",
	"Usage: cell-fb [options] [file]",
	"Options:",
	" -C            Use first 3 fields as r, g, and b",
	" -M \"r g b r g b\"  Ramp between two colors",
	" -F dev        Use frame-buffer device `dev'",
	" -N n          Set frame-buffer height to `n' pixels",
	" -S n          Set frame-buffer height and width to `n' pixels",
	" -W n          Set frame-buffer width to `n' pixels",
	" -X n          Set local debug flag to hex value `n' (default is 0)",
	" -a \"h v\"    Print pixel coords of point",
	" -b n          Ignore values not equal to `n'",
	" -c n          Assume cell size of `n' user units (default is 100)",
	" -d \"m n\"      Expect input in interval [m, n] (default is [0, 1])",
	" -e            Erase frame buffer before displaying picture",
	" -f n          Display field `n' of cell data",
	" -g            Leave space between cells",
	" -h            Use high-resolution frame buffer (sames as -S 1024)",
	" -i            Round values (default is to interpolate colors)",
	" -k            Display color key",
	" -l \"a e\"      Write log information to stdout",
	" -m \"n r g b\"  Map value `n' to color ``r g b''",
	" -p \"x y\"      Offset picture from bottom-left corner of display",
	" -s \"w h\"      Set cell width and height in pixels",
	" -v n          Display view number `n' (default is all views)",
	" -x n          Set LIBRT(3) debug flag to hex value `n' (default is 0)",
	0
};
static char	fbfile[MAX_LINE] = { 0 };/* Name of frame-buffer device */

static double	az;			/* To dump to log file */
static double	bool_val;		/* Only value displayed for -b option */
static double	cell_size = 100.0;	/* Size of cell in user units */
static double	el;			/* To dump to log file */
static double	key_height = 0.0;	/* How many cell heights for key? */
static double	xmin;			/* Extrema of coordinates	*/
static double	ymin;			/* in user units		*/
static double	xmax;			/* (set in read_Cell_Data())	*/
static double	ymax;			/*				*/
static double	dom_min = 0.0;		/* Extrema of data to plot	*/
static double	dom_max = 1.0;		/*				*/
static double	dom_cvt = 10.0;		/* To convert domain to [0, 10] */

static bool	boolean_flag = false;	/* Show only one value? */
static bool	color_flag = false;	/* Interpret fields as R, G, B? */
static bool	erase_flag = false;	/* Erase frame buffer first? */
static bool	grid_flag = false;	/* Leave space between cells? */
static bool	interp_flag = true;	/* Ramp between colortbl entries? */
static bool	key_flag = false;	/* Display color-mapping key? */
static bool	log_flag = false;	/* Make a log file? */

static int	compute_fb_height;	/* User supplied height?  Else what? */
static int	compute_fb_width;	/* User supplied width?  Else what? */
static unsigned int	debug_flag = 0;	/* Control diagnostic prints */
static int	fb_height = -1;		/* Height of frame buffer in pixels */
static int	fb_width = -1;		/* Width of frame buffer in pixels */
static int	field = 1;		/* The field that is of interest */
static int	wid = 10, hgt = 10;	/* Number of pixels per cell, H & V */
static int	xorigin = 0, yorigin = 0;/* Pixel location of image low lft */
static int	view_flag = 0;		/* The view that is of interest */

static long	maxcells = 10000;	/* Max number of cells in the image */

static FBIO	*fbiop = FBIO_NULL;	/* Frame-buffer device */

static FILE	*filep;			/* Input stream */

static RGBpixel	colortbl[12] =		/* The map: value --> R, G, B */
{
    { 255, 255, 255 },		/* white */
    { 100, 100, 140 },		/* blue grey */
    {   0,   0, 255 },		/* blue */
    {   0, 120, 255 },		/* light blue */
    { 100, 200, 140 },		/* turquoise */
    {   0, 150,   0 },		/* dark green */
    {   0, 225,   0 },		/* green */
    { 255, 255,   0 },		/* yellow */
    { 255, 160,   0 },		/* tangerine */
    { 255, 100, 100 },		/* pink */
    { 255,   0,   0 },		/* red */
    {   0,   0,   0 }		/* black */
};			

#if 0
static const char   *mon_nam[] =
                        { "Jan", "Feb", "Mar", "Apr", "May", "Jun",
                          "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
#endif

STATIC struct locrec	gp_locs;

STATIC bool	get_OK(void);
STATIC bool	pars_Argv(register int argc, register char **argv);
STATIC long	read_Cell_Data(void);
STATIC void	init_Globs(void);
STATIC void	prnt_Usage(void);
STATIC void	val_To_RGB(cell_val cv, unsigned char *rgb);
STATIC void	log_Run(void);
STATIC bool	display_Cells(long int ncells);
STATIC void	fill_colortbl(unsigned char *lo_rgb, unsigned char *hi_rgb);

int
main (int argc, char **argv)
{	
    static long	ncells;

    bu_debug = BU_DEBUG_MEM_CHECK | BU_DEBUG_MEM_LOG;
    bu_debug = 0;

    RT_LIST_INIT(&(gp_locs.l));
    if (! pars_Argv(argc, argv))
    {
	prnt_Usage();
	exit (1);
    }
    grid = (Cell *) bu_malloc(sizeof(Cell) * maxcells, "grid");
    if (debug_flag & CFB_DBG_MEM)
	bu_log("grid = 0x%x... %ld cells @@ %d bytes/cell\n",
	    grid, maxcells, sizeof(Cell));
    do
    {
	struct locrec	*lrp;

	init_Globs();
	if ((ncells = read_Cell_Data()) == 0)
	{
	    bu_log("cell-fb: failed to read view\n");
	    exit (1);
	}
	if (RT_LIST_NON_EMPTY(&(gp_locs.l)))
	    while (RT_LIST_WHILE(lrp, locrec, (&(gp_locs.l))))
	    {
		RT_LIST_DEQUEUE(&(lrp->l));
		bu_log("%g %g	%d %d\n", lrp -> h, lrp -> v,
		    (int) H2SCRX(lrp -> h), (int) V2SCRY(lrp -> v));
		bu_free((char *) lrp, "location record");
	    }
	else
	{
	    bu_log("Displaying %ld cells\n", ncells);
	    if (! display_Cells(ncells))
	    {
		bu_log("cell-fb: failed to display %ld cells\n", ncells);
		exit (1);
	    }
	    if (log_flag)
		log_Run();
	}
    } while ((view_flag == 0) && ! feof(filep) && get_OK());

    return(0);
}

#define	STATE_VIEW_TOP		0
#define	STATE_IN_HEADER		1
#define	STATE_IN_DATA		2
#define	STATE_BEYOND_DATA	3

STATIC long read_Cell_Data(void)
{	
    static char		linebuf[MAX_LINE];
    static char		*lbp = NULL;
    static char		format[MAX_LINE];
    register int	state = STATE_VIEW_TOP;
    int			i;
    register Cell	*gp = grid;
    int			view_ct = 1;

    /*
     * First time through...
     *  1) initailize line-buffer pointer and try to fill the line buffer 
     *  2) build the format for sscanf()
     */
    if (lbp == NULL)
    {
	lbp = linebuf;
        fgets(lbp, MAX_LINE, filep);
	(void) strcpy(format, "%lf %lf");
	(void) strcpy(format, "%lf %lf");
	if (color_flag)
	    (void) strcat(format, " %d %d %d");
	else
	{   /* Skip to field of interest */
	    for (i = 1; i < field; i++)
		(void) strcat(format, " %*lf");
	    (void) strcat(format, " %lf");
	}
    }
    /* EOF encountered before we found the desired view? */
    if (feof(filep))
	return (0);

    /* Read the data */
    do
    {	
	double		x, y;
	int		r, g, b;
	cell_val	value;

	if (lbp[strlen(lbp) - 1] != '\n')
	{
	    bu_log("Overlong line\n");
	    exit (1);
	}

	/* Have we run out of room for the cells?  If so reallocate memory */
	if (gp - grid >= maxcells)
	{	
	    long	ncells = gp - grid;

	    maxcells *= 2;
	    grid = (Cell *) bu_realloc((char *) grid,
					sizeof(Cell) * maxcells, "grid");
	    if (debug_flag & CFB_DBG_MEM)
		bu_log("maxcells increased to %ld\n", maxcells);
	    gp = grid + ncells;
	}
	/* Process any non-data (i.e. view-header) lines */
	while ((state != STATE_BEYOND_DATA) &&
	       ((color_flag &&
		(sscanf(lbp, format, &x, &y, &r, &g, &b) != 5))
	    || (! color_flag &&
		(sscanf(lbp, format, &x, &y, &value.v_scalar) != 3))))
	{
	    if (state == STATE_VIEW_TOP)
		state = STATE_IN_HEADER;
	    else if (state == STATE_IN_DATA)
		state = STATE_BEYOND_DATA;
	    if(feof(filep) || fgets(lbp, MAX_LINE, filep) == NULL)
		return (gp - grid);
	}
	/*
	 *	At this point we know we have a line of cell data,
	 *	though it might be the first line of the next view.
	 */
	if (state == STATE_BEYOND_DATA)
	{
	    state = STATE_VIEW_TOP;
	    if ((view_flag == 0) || (view_flag == view_ct++))
		return (gp - grid);
	    else	/* Not the selected view, read the next one. */
		continue;
	}
	else
	    state = STATE_IN_DATA;

	/* If user has selected a view, only store values for that view. */
	if ((view_flag == 0) || (view_flag == view_ct))
	{
	    MinMax(xmin, xmax, x);
	    MinMax(ymin, ymax, y);
	    if (debug_flag & CFB_DBG_MINMAX)
		bu_log("x=%g, y=%g, xmin=%g, xmax=%g, ymin=%g, ymax=%g\n",
		    x, y, xmin, xmax, ymin, ymax);
	    gp->c_x = x;
	    gp->c_y = y;
	    if (color_flag)
	    {
		gp->c_val.v_color[RED] = r;
		gp->c_val.v_color[GRN] = g;
		gp->c_val.v_color[BLU] = b;
	    }
	    else
		gp->c_val.v_scalar = value.v_scalar;
	    gp++;
	}
    } while (fgets(lbp, MAX_LINE, filep) != NULL);
    return (gp - grid);
}

STATIC bool get_OK(void)
{	
    int		c;
    FILE	*infp;

    if ((infp = fopen("/dev/tty", "r")) == NULL)
    {
	bu_log("Cannot open /dev/tty for reading\n");
	return (false);
    }
    bu_log("Another view follows.  Display ? [y/n](y) ");
    switch ((c = getc(infp)))
    {
	case '\n':
	    break;
	default:
	    while (getc(infp) != '\n')
		; /* Read until user hits <RETURN>. */
	    break;
    }
    (void) fclose(infp);
    if (c == 'n')
	return (false);
    return (true);
}
STATIC void init_Globs(void)
{
    xmin = POS_INFINITY;
    ymin = POS_INFINITY;
    xmax = NEG_INFINITY;
    ymax = NEG_INFINITY;
    return;
}

STATIC bool display_Cells (long int ncells)
{	
    register Cell	*gp, *ep = &grid[ncells];
    static int		zoom;
    unsigned char	*buf;
    static RGBpixel	pixel;
    double		lasty = NEG_INFINITY;
    double		dx, dy;
    register int	y0 = 0, y1;

    if (compute_fb_height)
    {
	dy = ((ymax - ymin) / cell_size + 1.0) * (hgt + grid_flag);
	if (compute_fb_height == SNUG_FIT)
	    fb_height = dy + (key_flag * 2 * hgt) + yorigin;
	else if (dy > LORES)	/* LOOSE_FIT */
	    fb_height = HIRES;
	else
	    fb_height = LORES;
    }
    if (compute_fb_width)
    {
	dx = ((xmax - xmin) / cell_size + 1.0) * (wid + grid_flag);
	if (compute_fb_width == SNUG_FIT)
	    fb_width = dx + xorigin;
	else if (dx > LORES)	/* LOOSE_FIT */
	    fb_width = HIRES;
	else
	    fb_width = LORES;
    }

    zoom = 1;
    if ((fbiop = fb_open((fbfile[0] != '\0') ? fbfile : NULL, fb_width, fb_height))
	== FBIO_NULL)
	return (false);
    if (compute_fb_height || compute_fb_width)  {
	bu_log("fb_size requested: %d %d\n", fb_width, fb_height);
    	fb_width = fb_getwidth(fbiop);
    	fb_height = fb_getheight(fbiop);
	bu_log("fb_size obtained: %d %d\n", fb_width, fb_height);
    }
    if (fb_wmap(fbiop, COLORMAP_NULL) == -1)
	bu_log("Cannot initialize color map\n");
    if (fb_zoom(fbiop, zoom, zoom) == -1)
	bu_log("Cannot set zoom <%d,%d>\n", zoom, zoom);
    if (erase_flag && fb_clear(fbiop, BACKGROUND) == -1)
	bu_log("Cannot clear frame buffer\n");

    buf = (unsigned char *) bu_malloc(sizeof(RGBpixel) * fb_width,
						"line of frame buffer");
    if (debug_flag & CFB_DBG_MEM)
	bu_log("buf = 0x%x... %d pixels @@ %d bytes/pixel\n",
	    buf, fb_width, sizeof(RGBpixel));

    for (gp = grid; gp < ep; gp++)
    {	
	register int	x0, x1;

	/* Whenever Y changes, write out row of cells. */
	if (lasty != gp->c_y)
	{
	    /* If first time, nothing to write out. */
	    if (lasty != NEG_INFINITY)
	    {
		if (debug_flag & CFB_DBG_GRID)
		    bu_log("%g = V2SCRY(%g)\n", V2SCRY(lasty), lasty);
		y0 = V2SCRY(lasty);
	    	if( y0 >= 0 && y0 < fb_height )  {
			for(y1 = y0 + hgt; y0 < y1; y0++)
			    if (fb_write(fbiop, 0, y0, buf, fb_width) == -1)
			    {
				bu_log("Couldn't write to <%d,%d>\n", 0, y0);
				(void) fb_close(fbiop);
				return (false);
			    }
	    	}
	    }
	    /* Clear buffer. */
	    for (x0 = 0; x0 < fb_width; x0++)
	    {
		COPYRGB(&buf[3*x0], BACKGROUND);
	    }

	     /* Draw grid line between rows of cells. */
	    if (grid_flag && (lasty != NEG_INFINITY))
	    {
		if (fb_write(fbiop, 0, y0, buf, fb_width) == -1)
		{
		    bu_log("Couldn't write to <%d,%d>\n", 0, y0);
		    (void) fb_close(fbiop);
		    return (false);
		}
		if (debug_flag & CFB_DBG_GRID)
		    bu_log("Writing grid row at %d\n", y0);
	    }
	    lasty = gp->c_y;
	}
	val_To_RGB(gp->c_val, pixel);
    	/* Be careful only to write color within bounds of the screen */
    	x0 = H2SCRX(gp->c_x);
    	if( x0 >= 0 && x0 <= fb_width - wid )  {
		for (x1 = x0 + wid; x0 < x1;  x0++)
		{
		    COPYRGB(&buf[3*x0], pixel);
		}
    	}
    }

    /* Write out last row of cells. */
    if (debug_flag & CFB_DBG_GRID)
	bu_log("%g = V2SCRY(%g)\n", V2SCRY(lasty), lasty);
    for (y0 = V2SCRY(lasty), y1 = y0 + hgt; y0 < y1;  y0++)
	if (fb_write(fbiop, 0, y0, buf, fb_width) == -1)
	{
	    bu_log("Couldn't write to <%d,%d>\n", 0, y0);
	    (void) fb_close(fbiop);
	    return (false);
	}
    /* Draw color key. */
    if (key_flag && (fb_width < (10 + 1) * wid))
	bu_log("Width of key (%d) would exceed frame-buffer width (%d)\n",
		(10 + 1) * wid, fb_width);
    else if (key_flag)
    {	
	register int	i, j;
	double		base;
    	int		scr_min, scr_max;
    	int		scr_center;	/* screen coord of center of view */
    	int		center_cell;	/* cell # of center of view */

	/* Clear buffer. */
	for (i = 0; i < fb_width; i++)
	{
	    COPYRGB(&buf[3*i], BACKGROUND);
	}
    	/*  Center the color key from side-to-side in the viewport.
    	 *  Find screen coords of min and max vals, clip to (0,fb_width).
	 *  If there are fewer than 11 cells, the run the key
	 *  from the left edge to beyond the right edge.
	 */
    	scr_min = H2SCRX(xmin);
    	scr_max = H2SCRX(xmax);
    	if( scr_min < 0 )  scr_min = 0;
    	if( scr_min > fb_width )  scr_min = fb_width;
    	if( scr_max < 0 )  scr_max = 0;
    	if( scr_max > fb_width )  scr_max = fb_width;
    	scr_center = (scr_max + scr_min)/2;
    	if ((center_cell = VPX2CX(SCRX2VPX(scr_center))) < 5)
	    center_cell = 5;

    	/* Draw 10 cells for the color key */
	dom_cvt = 10.0;
	for (i = 0; i <= 10; i++)
	{	
	    cell_val	cv;

	    /*
	     *	Determine where to start the key,
	     *	being careful not to back up beyond the beginning of buf.
	     */
    	    base = VPX2SCRX( CX2VPX( center_cell - 10/2 + i ) );

	    cv.v_scalar = i / 10.0;

	    val_To_RGB(cv, pixel);
	    for (j = 0; j < wid; j++)
	    {	
		register int index = base + j;
		COPYRGB(&buf[3*index], pixel);
	    }
	}
	dom_cvt = 10.0 / (dom_max - dom_min);

	for (i = yorigin; i < yorigin+hgt; i++)
	    if (fb_write(fbiop, 0, i, buf, fb_width) == -1)
	    {
		bu_log("Couldn't write to <%d,%d>\n", 0, i);
		(void) fb_close(fbiop);
		return (false);
	    }
    }
    (void) fb_close(fbiop);

    bu_free((char *) buf, "line of frame buffer");
    if (debug_flag & CFB_DBG_MEM)
	bu_log("freed buf, which is now 0x%x\n", buf);
    return (true);
}

STATIC void val_To_RGB (cell_val cv, unsigned char *rgb)
{
    double	val;

    if (color_flag)
    {
	COPYRGB(rgb, cv.v_color);
	return;
    }
    val = (cv.v_scalar - dom_min) * dom_cvt;
    if ((boolean_flag && (cv.v_scalar != bool_val))
	|| (val < 0.0) || (val > 10.0))
    {
	COPYRGB(rgb, BACKGROUND);
    }
    else if (val == 0.0)
    {
	COPYRGB(rgb, WHITE);
    }
    else
    {	
	int		index;
	double		rem;
	double		res;

	if (interp_flag)
	{
	    double	prev_hsv[3];
	    double	hsv[3];
	    double	next_hsv[3];

	    index = val + 0.01; /* convert to range [0 to 10] */
	    if ((rem = val - (double) index) < 0.0) /* remainder */
		rem = 0.0;
	    res = 1.0 - rem;
#if BLEND_USING_HSV
	    bu_rgb_to_hsv(colortbl[index], prev_hsv);
	    bu_rgb_to_hsv(colortbl[index+1], next_hsv);
	    VBLEND2(hsv, res, prev_hsv, rem, next_hsv);
	    bu_hsv_to_rgb(hsv, rgb);
#else
	    VBLEND2(rgb, res, colortbl[index], rem, colortbl[index+1]);
#endif
	}
	else
	{
	    index = val + 0.51;
	    COPYRGB(rgb, colortbl[index]);
	}
    }
    return;
}

STATIC struct locrec *mk_locrec (fastf_t h, fastf_t v)
{
    struct locrec	*lrp;

    lrp = (struct locrec *)
	    bu_malloc(sizeof(struct locrec), "location record");
    lrp -> locrec_magic = LOCREC_MAGIC;
    lrp -> h = h;
    lrp -> v = v;
    return (lrp);
}

STATIC bool pars_Argv (register int argc, register char **argv)
{	
    register int	c;
    extern int		optind;
    extern char		*optarg;

    /* Parse options. */
    while ((c = getopt(argc, argv, OPT_STRING)) != EOF)
    {
	switch (c)
	{
	    case 'C':
		color_flag = true;
		break;
	    case 'M':
		{	
		    RGBpixel	lo_rgb, hi_rgb;
		    int		lo_red, lo_grn, lo_blu;
		    int		hi_red, hi_grn, hi_blu;

		    if (sscanf(optarg, "%d %d %d %d %d %d",
			    &lo_red, &lo_grn, &lo_blu,
			    &hi_red, &hi_grn, &hi_blu)
			< 3)
		    {
			bu_log("Invalid color-mapping: '%s'\n",
			    optarg);
			return (false);
		    }
		    lo_rgb[RED] = lo_red;
		    lo_rgb[GRN] = lo_grn;
		    lo_rgb[BLU] = lo_blu;
		    hi_rgb[RED] = hi_red;
		    hi_rgb[GRN] = hi_grn;
		    hi_rgb[BLU] = hi_blu;
		    fill_colortbl(lo_rgb, hi_rgb);
		    break;
		}
	    case 'F':
		(void) strncpy(fbfile, optarg, MAX_LINE);
		break;
	    case 'N':
		if (sscanf(optarg, "%d", &fb_height) < 1)
		{
		    bu_log("Invalid frame-buffer height: '%s'\n", optarg);
		    return (false);
		}
		if (fb_height < -1)
		{
		    bu_log("Frame-buffer height out of range: %d\n", fb_height);
		    return (false);
		}
		break;
	    case 'W':
		if (sscanf(optarg, "%d", &fb_width) < 1)
		{
		    bu_log("Invalid frame-buffer width: '%s'\n", optarg);
		    return (false);
		}
		if (fb_width < -1)
		{
		    bu_log("Frame-buffer width out of range: %d\n", fb_width);
		    return (false);
		}
		break;
	    case 'S':
		if (sscanf(optarg, "%d", &fb_height) < 1)
		{
		    bu_log("Invalid frame-buffer dimension: '%s'\n", optarg);
		    return (false);
		}
		if (fb_height < -1)
		{
		    bu_log("Frame-buffer dimensions out of range: %d\n",
			fb_height);
		    return (false);
		}
		fb_width = fb_height;
		break;
	    case 'X':
		if (sscanf(optarg, "%x", &debug_flag) < 1)
		{
		    bu_log("Invalid debug flag: '%s'\n", optarg);
		    return (false);
		}
		break;
	    case 'a':
		{
		    fastf_t		h;
		    fastf_t		v;
		    struct locrec	*lrp;

		    if (sscanf(optarg, "%lf %lf", &h, &v) != 2)
		    {
			bu_log("Invalid grid-plane location: '%s'\n", optarg);
			return (false);
		    }
		    lrp = mk_locrec(h, v);
		    RT_LIST_INSERT(&(gp_locs.l), &(lrp -> l));
		}
		break;
	    case 'b':
		if (sscanf(optarg, "%lf", &bool_val) != 1)
		{
		    bu_log("Invalid boolean value: '%s'\n", optarg);
		    return (false);
		}
		boolean_flag = true;
		break;
	    case 'c':
		if (sscanf(optarg, "%lf", &cell_size) != 1)
		{
		    bu_log("Invalid cell size: '%s'\n", optarg);
		    return (false);
		}
		if (cell_size <= 0)
		{
		    bu_log("Cell size out of range: %d\n", cell_size);
		    return (false);
		}
		break;
	    case 'd':
		if (sscanf(optarg, "%lf %lf", &dom_min, &dom_max) < 2)
		{
		    bu_log("Invalid domain for input: '%s'\n", optarg);
		    return (false);
		}
		if (dom_min >= dom_max)
		{
		    bu_log("Bad domain for input: [%lf, %lf]\n",
			dom_min, dom_max);
		    return (false);
		}
		dom_cvt = 10.0 / (dom_max - dom_min);
		break;
	    case 'e':
		erase_flag = true;
		break;
	    case 'f':
		if (sscanf(optarg, "%d", &field) != 1)
		{
		    bu_log("Invalid field: '%s'\n", optarg);
		    return (false);
		}
		break;
	    case 'g':
		grid_flag = true;
		break;
	    case 'h':
		fb_height = fb_width = HIRES;
		break;
	    case 'i':
		interp_flag = false;
		break;
	    case 'k':
		key_flag = true;
		key_height = 2.5;
		break;
	    case 'l':
		if (sscanf(optarg, "%lf%lf", &az, &el) != 2)
		{
		    bu_log("Invalid view: '%s'\n", optarg);
		    return (false);
		}
		log_flag = true;
		if (view_flag == 0)
		    view_flag = 1;
		break;
	    case 'm':
		{	
		    double	value;
		    RGBpixel	rgb;
		    int		red, grn, blu;
		    int		index;

		    if (sscanf(optarg, "%lf %d %d %d", &value, &red, &grn, &blu)
			< 4)
		    {
			bu_log("Invalid color-mapping: '%s'\n",
			    optarg);
			return (false);
		    }
		    value *= 10.0;
		    index = value + 0.01;
		    if (index < 0 || index > MAX_COLORTBL)
		    {
			bu_log("Value out of range (%s)\n", optarg);
			return (false);
		    }
		    rgb[RED] = red;
		    rgb[GRN] = grn;
		    rgb[BLU] = blu;
		    COPYRGB(colortbl[index], rgb);
		    break;
		}
	    case 'p':
		switch (sscanf(optarg, "%d %d", &xorigin, &yorigin))
		{
		    case 2: break;
		    case 1: yorigin = xorigin; break;
		    default:
			bu_log("Invalid offset: '%s'\n", optarg);
			return (false);
		}
		break;
	    case 's':
		switch (sscanf(optarg, "%d %d", &wid, &hgt))
		{
		    case 2: break;
		    case 1: hgt = wid; break;
		    default:
			bu_log("Invalid cell scale: '%s'\n", optarg);
			return (false);
		}
		break;
	    case 'v':
		if (sscanf(optarg, "%d", &view_flag) < 1)
		{
		    bu_log("Invalid view number: '%s'\n", optarg);
		    return (false);
		}
		if (view_flag == 0)
		    log_flag = false;
		break;
            case 'x':
		if (sscanf(optarg, "%x", (unsigned int *)&bu_debug) < 1)
		{
		    bu_log("Invalid debug flag: '%s'\n", optarg);
		    return (false);
		}
		break;
	    case '?':
		return (false);
	}
    }

    if (argc == optind + 1)
    {
	if ((filep = fopen(argv[optind], "r")) == NULL)
	{
	    bu_log("Cannot open file '%s'\n", argv[optind]);
	    return (false);
	}
    }
    else if (argc != optind)
    {
	bu_log("Too many arguments!\n");
	return (false);
    }
    else
	filep = stdin;

    /* if fb_height/width has not been set, do snug fit
     * else if fb_height/width set to 0 force loose fit
     * else take user specified dimensions
     */
    compute_fb_height = (fb_height == -1) ? SNUG_FIT :
			(fb_height == 0) ? LOOSE_FIT : false;
    compute_fb_width = (fb_width == -1) ? SNUG_FIT :
			(fb_width == 0) ? LOOSE_FIT : false;
    return (true);
}
/*	prnt_Usage() --	Print usage message. */
STATIC void prnt_Usage(void)
{	
    register char	**p = usage;

    while (*p)
	bu_log("%s\n", *p++);
    return;
}

STATIC void log_Run(void)
{
    time_t              clock;
    mat_t		model2hv;		/* model to h,v matrix */
    mat_t		hv2model;		/* h,v tp model matrix */
    quat_t		orient;			/* orientation */
    point_t		hv_eye;			/* eye position in h,v coords */
    point_t		m_eye;			/* eye position in model coords */
    fastf_t		hv_viewsize;		/* size of view in h,v coords */
    fastf_t		m_viewsize;		/* size of view in model coords. */

    /* Current date and time get printed in header comment */
    (void) time(&clock);

    (void) printf("# Log information produced by cell-fb %s\n",
	ctime(&clock) );
    (void) printf("az_el: %f %f\n", az, el);
    (void) printf("view_extrema: %f %f %f %f\n",
	SCRX2H(0), SCRX2H(fb_width), SCRY2V(0), SCRY2V(fb_height));
    (void) printf("fb_size: %d %d\n", fb_width, fb_height);

	/* Produce the orientation, the model eye_pos, and the model
	 * view size for input into rtregis.
 	 * First use the azimuth and elevation to produce the model2hv
	 * matrix and use that to find the orientation.
	 */

	MAT_IDN( model2hv );
	MAT_IDN( hv2model );

	/* Print out the "view" just to keep rtregis from belly-aching */

	printf("View: %g azimuth, %g elevation\n", az, el);

	/** mat_ae( model2hv, az, el ); **/
	/* Formula from rt/do.c */
	mat_angles( model2hv, 270.0+el, 0.0, 270.0-az );
	model2hv[15] = 25.4;		/* input is in inches */
	mat_inv( hv2model, model2hv);

	quat_mat2quat( orient, model2hv );

	printf("Orientation: %.6f, %.6f, %.6f, %.6f\n", V4ARGS(orient) );

	/* Now find the eye position in h, v space.  Note that the eye
	 * is located at the center of the image; in this case, the center
	 * of the screen space, i.e., the framebuffer. )
	 * Also find the hv_viewsize at this time.
	 */
	hv_viewsize = SCRX2H( (double)fb_width ) - SCRX2H( 0.0 );
	hv_eye[0] = SCRX2H( (double)fb_width/2 );
	hv_eye[1] = SCRY2V( (double)fb_height/2 );
	hv_eye[2] = hv_viewsize/2;

	/* Debugging */
	printf("hv_viewsize= %g\n", hv_viewsize);
	printf("hv_eye= %.6f, %.6f, %.6f\n", V3ARGS(hv_eye) );

	/* Now find the model eye_position and report on that */
	MAT4X3PNT( m_eye, hv2model, hv_eye );
	printf("Eye_pos: %.6f, %.6f, %.6f\n", V3ARGS(m_eye) );

	/*
	 * Find the view size in model coordinates and print that as well.
	 * Important:  Don't use %g format, it may round to nearest integer!
	 */
	m_viewsize = hv_viewsize/hv2model[15];
	printf("Size: %.6f\n", m_viewsize);
}

STATIC void
fill_colortbl (unsigned char *lo_rgb, unsigned char *hi_rgb)
{
    int		i;
    double	a, b;

#if BLEND_USING_HSV

    double	lo_hsv[3], hi_hsv[3], hsv[3];

    bu_rgb_to_hsv(lo_rgb, lo_hsv);
    bu_rgb_to_hsv(hi_rgb, hi_hsv);
#endif

    for (i = 0; i < MAX_COLORTBL; ++i)
    {
	b = ((double) i) / (MAX_COLORTBL - 1);
	a = 1.0 - b;
#if BLEND_USING_HSV
	VBLEND2(hsv, a, lo_hsv, b, hi_hsv);
	bu_hsv_to_rgb(hsv, colortbl[i]);
#else
	VBLEND2(colortbl[i], a, lo_rgb, b, hi_rgb);
#endif
    }
}
@


11.23
log
@change conf.h to a wrapped config.h
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/fb/cell-fb.c,v 11.22 2004/04/05 07:49:23 morrison Exp $ (BRL)";
d147 1
a147 1
	"cell-fb ($Revision: 11.22 $)",
@


11.22
log
@merge of ansi-6-0-branch into HEAD
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d19 5
a23 1
#include "conf.h"
d147 1
a147 1
	"cell-fb ($Revision$)",
@


11.21
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/cell-fb.c,v 11.19 2001/08/21 17:47:10 jra Exp $ (BRL)";
d143 1
a143 1
	"cell-fb ($Revision: 11.19 $)",
d235 9
a243 9
STATIC bool	get_OK();
STATIC bool	pars_Argv();
STATIC long	read_Cell_Data();
STATIC void	init_Globs();
STATIC void	prnt_Usage();
STATIC void	val_To_RGB();
STATIC void	log_Run();
STATIC bool	display_Cells();
STATIC void	fill_colortbl();
d246 1
a246 5
main (argc, argv)

int	argc;
char	**argv;

d302 1
a302 1
STATIC long read_Cell_Data()
d414 1
a414 1
STATIC bool get_OK()
d439 1
a439 1
STATIC void init_Globs()
d448 1
a448 4
STATIC bool display_Cells (ncells)

long	ncells;

d637 1
a637 5
STATIC void val_To_RGB (cv, rgb)

cell_val	cv;
RGBpixel	rgb;

d690 1
a690 5
STATIC struct locrec *mk_locrec (h, v)

fastf_t	h;
fastf_t	v;

d702 1
a702 5
STATIC bool pars_Argv (argc, argv)

register int	argc;
register char	**argv;

d965 1
a965 1
STATIC void prnt_Usage()
d974 1
a974 1
STATIC void log_Run()
d1045 1
a1045 5
fill_colortbl (lo_rgb, hi_rgb)

RGBpixel	lo_rgb;
RGBpixel	hi_rgb;

@


11.21.2.1
log
@Initial ANSIfication
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/cell-fb.c,v 11.21 2002/08/20 17:07:23 jra Exp $ (BRL)";
d143 1
a143 1
	"cell-fb ($Revision: 11.21 $)",
d235 9
a243 9
STATIC bool	get_OK(void);
STATIC bool	pars_Argv(register int argc, register char **argv);
STATIC long	read_Cell_Data(void);
STATIC void	init_Globs(void);
STATIC void	prnt_Usage(void);
STATIC void	val_To_RGB(cell_val cv, unsigned char *rgb);
STATIC void	log_Run(void);
STATIC bool	display_Cells(long int ncells);
STATIC void	fill_colortbl(unsigned char *lo_rgb, unsigned char *hi_rgb);
d246 5
a250 1
main (int argc, char **argv)
d306 1
a306 1
STATIC long read_Cell_Data(void)
d418 1
a418 1
STATIC bool get_OK(void)
d443 1
a443 1
STATIC void init_Globs(void)
d452 4
a455 1
STATIC bool display_Cells (long int ncells)
d644 5
a648 1
STATIC void val_To_RGB (cell_val cv, unsigned char *rgb)
d701 5
a705 1
STATIC struct locrec *mk_locrec (fastf_t h, fastf_t v)
d717 5
a721 1
STATIC bool pars_Argv (register int argc, register char **argv)
d984 1
a984 1
STATIC void prnt_Usage(void)
d993 1
a993 1
STATIC void log_Run(void)
d1064 5
a1068 1
fill_colortbl (unsigned char *lo_rgb, unsigned char *hi_rgb)
@


11.20
log
@Converted from K&R to ANSI C - RFH
@
text
@d235 9
a243 9
STATIC bool	get_OK(void);
STATIC bool	pars_Argv(register int argc, register char **argv);
STATIC long	read_Cell_Data(void);
STATIC void	init_Globs(void);
STATIC void	prnt_Usage(void);
STATIC void	val_To_RGB(cell_val cv, unsigned char *rgb);
STATIC void	log_Run(void);
STATIC bool	display_Cells(long int ncells);
STATIC void	fill_colortbl(unsigned char *lo_rgb, unsigned char *hi_rgb);
d246 5
a250 1
main (int argc, char **argv)
d306 1
a306 1
STATIC long read_Cell_Data(void)
d418 1
a418 1
STATIC bool get_OK(void)
d443 1
a443 1
STATIC void init_Globs(void)
d452 4
a455 1
STATIC bool display_Cells (long int ncells)
d644 5
a648 1
STATIC void val_To_RGB (cell_val cv, unsigned char *rgb)
d701 5
a705 1
STATIC struct locrec *mk_locrec (fastf_t h, fastf_t v)
d717 5
a721 1
STATIC bool pars_Argv (register int argc, register char **argv)
d984 1
a984 1
STATIC void prnt_Usage(void)
d993 1
a993 1
STATIC void log_Run(void)
d1064 5
a1068 1
fill_colortbl (unsigned char *lo_rgb, unsigned char *hi_rgb)
@


11.19
log
@included <time.h>
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/cell-fb.c,v 11.18 2001/08/10 21:27:04 butler Exp $ (BRL)";
d143 1
a143 1
	"cell-fb ($Revision: 11.18 $)",
d235 9
a243 9
STATIC bool	get_OK();
STATIC bool	pars_Argv();
STATIC long	read_Cell_Data();
STATIC void	init_Globs();
STATIC void	prnt_Usage();
STATIC void	val_To_RGB();
STATIC void	log_Run();
STATIC bool	display_Cells();
STATIC void	fill_colortbl();
d246 1
a246 5
main (argc, argv)

int	argc;
char	**argv;

d302 1
a302 1
STATIC long read_Cell_Data()
d414 1
a414 1
STATIC bool get_OK()
d439 1
a439 1
STATIC void init_Globs()
d448 1
a448 4
STATIC bool display_Cells (ncells)

long	ncells;

d637 1
a637 5
STATIC void val_To_RGB (cv, rgb)

cell_val	cv;
RGBpixel	rgb;

d690 1
a690 5
STATIC struct locrec *mk_locrec (h, v)

fastf_t	h;
fastf_t	v;

d702 1
a702 5
STATIC bool pars_Argv (argc, argv)

register int	argc;
register char	**argv;

d965 1
a965 1
STATIC void prnt_Usage()
d974 1
a974 1
STATIC void log_Run()
d1045 1
a1045 5
fill_colortbl (lo_rgb, hi_rgb)

RGBpixel	lo_rgb;
RGBpixel	hi_rgb;

@


11.18
log
@Misc compiler warning fixes
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/cell-fb.c,v 11.17 2001/04/12 17:44:07 bparker Exp $ (BRL)";
d27 1
d143 1
a143 1
	"cell-fb ($Revision: 11.17 $)",
@


11.17
log
@*- get rid of warnings
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/cell-fb.c,v 11.16 2001/04/05 19:35:02 morrison Exp $ (BRL)";
d142 1
a142 1
	"cell-fb ($Revision: 11.16 $)",
d196 1
a196 1
static int	debug_flag = 0;		/* Control diagnostic prints */
d945 1
a945 1
		if (sscanf(optarg, "%x", &bu_debug) < 1)
@


11.16
log
@updated SIGNED to signed
updated CONST to const
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/cell-fb.c,v 11.15 2001/04/02 21:37:44 morrison Exp $ (BRL)";
d22 5
d142 1
a142 1
	"cell-fb ($Revision: 11.15 $)",
d244 1
d296 2
@


11.15
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/cell-fb.c,v 11.14 2000/08/24 03:58:21 mike Exp $ (BRL)";
d137 1
a137 1
	"cell-fb ($Revision: 11.14 $)",
d222 1
a222 1
static CONST char   *mon_nam[] =
@


11.14
log
@
const RCSid
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/cell-fb.c,v 11.13 2000/01/31 15:30:41 jra Exp $ (BRL)";
d137 1
a137 1
	"cell-fb ($Revision: 11.13 $)",
d1011 2
a1012 2
	mat_idn( model2hv );
	mat_idn( hv2model );
@


11.13
log
@Eliminated some unused variables
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/cell-fb.c,v 11.12 1999/10/22 20:22:24 jra Exp $ (BRL)";
d137 1
a137 1
	"cell-fb ($Revision: 11.12 $)",
@


11.12
log
@Was calculating a framebuffer size one pixel too small when using the "-g" option
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/cell-fb.c,v 11.11 1999/06/30 20:36:56 pjt Exp $ (BRL)";
d137 1
a137 1
	"cell-fb ($Revision: 11.11 $)",
a727 1
		    double	value;
a730 1
		    int		index;
@


11.11
log
@Fixed bug in rounding off cell coordinates that had the effect of leaving
horz and/or vert. strips of the image blank because rows and/or cols
were being splatted on top of their neighbors instead of where they belonged
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/cell-fb.c,v 11.10 1999/02/08 18:38:31 pjt Exp $ (BRL)";
d137 1
a137 1
	"cell-fb ($Revision: 11.10 $)",
d458 1
a458 2
	dy = ((ymax - ymin) / cell_size + 1.0) * (hgt + grid_flag)
	    - grid_flag;
d468 1
a468 2
	dx = ((xmax - xmin) / cell_size + 1.0) * (wid + grid_flag)
	    - grid_flag;
@


11.10
log
@Fixed error in usage message for -M option.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/cell-fb.c,v 11.9 1999/01/04 20:04:18 pjt Exp $ (BRL)";
d74 2
a75 2
#define H2CX(_h)	((int)( ((_h) - xmin) / cell_size ))
#define V2CY(_v)	((int)( ((_v) - ymin) / cell_size ))
d137 1
a137 1
	"cell-fb ($Revision: 11.9 $)",
d513 1
a513 1
		    bu_log("%d = V2SCRY(%g)\n", V2SCRY(lasty), lasty);
d557 2
@


11.9
log
@fixed bug reported by Carl Moore that caused snug-fit autosizing to
get the file sizes wrong when the -g option was specified.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/cell-fb.c,v 11.8 1998/12/30 04:57:46 mike Exp $ (BRL)";
d137 1
a137 1
	"cell-fb ($Revision: 11.8 $)",
d142 1
a142 1
	" -M \"r g b r g b\"  Use first 3 fields as r, g, and b",
@


11.8
log
@Cell-fb no longer needs to use LIBRT, so don't reference rt_g.debug,
use bu_debug instead.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/cell-fb.c,v 11.7 1998/09/22 02:44:37 mike Exp $ (BRL)";
d137 1
a137 1
	"cell-fb ($Revision: 11.7 $)",
d458 2
a459 1
	dy = ((ymax - ymin) / cell_size + 1.0) * hgt;
d469 2
a470 1
	dx = ((xmax - xmin) / cell_size + 1.0) * wid;
@


11.7
log
@Eliminated warnings on m4i64
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/cell-fb.c,v 11.6 1998/06/25 08:30:22 mike Exp $ (BRL)";
d137 1
a137 1
	"cell-fb ($Revision: 11.6 $)",
d937 1
a937 1
		if (sscanf(optarg, "%x", &rt_g.debug) < 1)
@


11.6
log
@Function should have been void.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/cell-fb.c,v 11.5 1998/06/08 19:35:05 pjt Exp $ (BRL)";
d24 1
d137 1
a137 1
	"cell-fb ($Revision: 11.5 $)",
d986 1
a986 1
    long                clock;
d999 1
a999 1
	ctime((CONST long *)&clock) );
@


11.5
log
@1.  Added the -M option
2.  key no longer falls off of the left edge of the image
3.  color interpolation now done in HSV space, not RGB
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/cell-fb.c,v 11.3 1997/03/19 20:15:35 pjt Exp pjt $ (BRL)";
d136 1
a136 1
	"cell-fb ($Revision: 11.3 $)",
d236 1
d1053 1
@


11.4
log
@Switched to libbu() usage and fixed bug with small image width (in cells).
@
text
@d52 2
a53 1
#define	OPT_STRING	"CF:N:S:W:X:a:b:c:d:ef:ghikl:m:p:s:v:x:?"
d141 1
d579 2
d589 2
a591 1
    	center_cell = VPX2CX( SCRX2VPX( scr_center ) );
d593 1
a593 2
	bu_log("inputs range from %g to %g with a conversion of %g\n",
	    dom_min, dom_max, dom_cvt);
a602 2
	    if (base < 0)
		base = 0;
a604 2
	    bu_log("v_scalar = %d * %g / 10.0 = %g\n",
		i, dom_cvt, cv.v_scalar);
d613 1
a644 1
    bu_log("v_scalar=%g, val=%g\n", cv.v_scalar, val);
d662 4
d670 8
a677 6
	    rgb[RED] = res*colortbl[index][RED]
			+ rem*colortbl[index+1][RED];
	    rgb[GRN] = res*colortbl[index][GRN]
			+ rem*colortbl[index+1][GRN];
	    rgb[BLU] = res*colortbl[index][BLU]
			+ rem*colortbl[index+1][BLU];
d722 26
d1050 30
@


11.3
log
@Increased MAX_LINE from 133 to 1025 and fixed bug for overlong input lines
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/cell-fb.c,v 11.2 1995/09/26 19:59:43 pjt Exp pjt $ (BRL)";
d123 1
a123 1
    struct rt_list	l;
d135 1
a135 1
	"cell-fb ($Revision: 11.2 $)",
d243 3
d252 1
a252 1
    grid = (Cell *) rt_malloc(sizeof(Cell) * maxcells, "grid");
d254 1
a254 2
    {
	rt_log("grid = 0x%x... %ld cells @@ %d bytes/cell\n",
a255 2
	fflush(stderr);
    }
d263 1
a263 1
	    rt_log("cell-fb: failed to read view\n");
d270 1
a270 1
		rt_log("%g %g	%d %d\n", lrp -> h, lrp -> v,
d272 1
a272 1
		rt_free((char *) lrp, "location record");
d276 1
a276 1
	    rt_log("Displaying %ld cells\n", ncells);
d279 1
a279 1
		rt_log("cell-fb: failed to display %ld cells\n", ncells);
d346 1
a346 1
	    grid = (Cell *) rt_realloc((char *) grid,
d349 1
a349 4
	    {
		rt_log("maxcells increased to %ld\n", maxcells);
		fflush(stderr);
	    }
d387 1
a387 2
	    {
		rt_log("x=%g, y=%g, xmin=%g, xmax=%g, ymin=%g, ymax=%g\n",
a388 2
		fflush(stderr);
	    }
d412 1
a412 1
	rt_log("Cannot open /dev/tty for reading\n");
d415 1
a415 2
    rt_log("Another view follows.  Display ? [y/n](y) ");
    (void) fflush(stderr);
d478 1
a478 1
	rt_log("fb_size requested: %d %d\n", fb_width, fb_height);
d481 1
a481 1
	rt_log("fb_size obtained: %d %d\n", fb_width, fb_height);
d484 1
a484 1
	rt_log("Cannot initialize color map\n");
d486 1
a486 1
	rt_log("Cannot set zoom <%d,%d>\n", zoom, zoom);
d488 1
a488 1
	rt_log("Cannot clear frame buffer\n");
d490 1
a490 1
    buf = (unsigned char *) rt_malloc(sizeof(RGBpixel) * fb_width,
d493 1
a493 2
    {
	rt_log("buf = 0x%x... %d pixels @@ %d bytes/pixel\n",
a494 2
	fflush(stderr);
    }
d507 1
a507 4
		{
		    rt_log("%d = V2SCRY(%g)\n", V2SCRY(lasty), lasty);
		    fflush(stderr);
		}
d513 1
a513 1
				rt_log("Couldn't write to <%d,%d>\n", 0, y0);
d530 1
a530 1
		    rt_log("Couldn't write to <%d,%d>\n", 0, y0);
d535 1
a535 4
		{
		    rt_log("Writing grid row at %d\n", y0);
		    fflush(stderr);
		}
d554 1
a554 1
	    rt_log("Couldn't write to <%d,%d>\n", 0, y0);
d560 1
a560 1
	rt_log("Width of key (%d) would exceed frame-buffer width (%d)\n",
d588 2
d594 4
d599 2
d603 2
d617 1
a617 1
		rt_log("Couldn't write to <%d,%d>\n", 0, i);
d623 2
a624 1
    rt_free((char *) buf, "line of frame buffer");
d626 1
a626 4
    {
	rt_log("freed buf, which is now 0x%x\n", buf);
	fflush(stderr);
    }
d644 1
d691 1
a691 1
	    rt_malloc(sizeof(struct locrec), "location record");
d722 1
a722 1
		    rt_log("Invalid frame-buffer height: '%s'\n", optarg);
d727 1
a727 1
		    rt_log("Frame-buffer height out of range: %d\n", fb_height);
d734 1
a734 1
		    rt_log("Invalid frame-buffer width: '%s'\n", optarg);
d739 1
a739 1
		    rt_log("Frame-buffer width out of range: %d\n", fb_width);
d746 1
a746 1
		    rt_log("Invalid frame-buffer dimension: '%s'\n", optarg);
d751 1
a751 1
		    rt_log("Frame-buffer dimensions out of range: %d\n",
d760 1
a760 1
		    rt_log("Invalid debug flag: '%s'\n", optarg);
d772 1
a772 1
			rt_log("Invalid grid-plane location: '%s'\n", optarg);
d782 1
a782 1
		    rt_log("Invalid boolean value: '%s'\n", optarg);
d790 1
a790 1
		    rt_log("Invalid cell size: '%s'\n", optarg);
d795 1
a795 1
		    rt_log("Cell size out of range: %d\n", cell_size);
d802 1
a802 1
		    rt_log("Invalid domain for input: '%s'\n", optarg);
d807 1
a807 1
		    rt_log("Bad domain for input: [%lf, %lf]\n",
d819 1
a819 1
		    rt_log("Invalid field: '%s'\n", optarg);
d839 1
a839 1
		    rt_log("Invalid view: '%s'\n", optarg);
d856 1
a856 1
			rt_log("Invalid color-mapping: '%s'\n",
d864 1
a864 1
			rt_log("Value out of range (%s)\n", optarg);
d879 1
a879 1
			rt_log("Invalid offset: '%s'\n", optarg);
d889 1
a889 1
			rt_log("Invalid cell scale: '%s'\n", optarg);
d896 1
a896 1
		    rt_log("Invalid view number: '%s'\n", optarg);
d905 1
a905 1
		    rt_log("Invalid debug flag: '%s'\n", optarg);
d918 1
a918 1
	    rt_log("Cannot open file '%s'\n", argv[optind]);
d924 1
a924 1
	rt_log("Too many arguments!\n");
d946 1
a946 1
	rt_log("%s\n", *p++);
@


11.2
log
@Added -a option
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/cell-fb.c,v 11.1 95/01/04 10:08:57 mike Rel4_4 $ (BRL)";
d42 1
a42 1
#define MAX_LINE	133
d135 1
a135 1
	"cell-fb ($Revision: 11.1 $)",
d313 1
d334 6
d391 2
a392 2
		rt_log("xmin=%g, xmax=%g, ymin=%g, ymax=%g\n",
		    xmin, xmax, ymin, ymax);
@


11.1
log
@Release_4.4
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/cell-fb.c,v 10.11 94/12/08 16:03:23 mike Exp $ (BRL)";
d52 1
a52 1
#define	OPT_STRING	"CF:N:S:W:X:b:c:d:ef:ghikl:m:p:s:v:x:?"
d112 3
a114 3
    double	v_scalar;
    RGBpixel	v_color;
}			cell_val;
d117 12
a128 4
    double	c_x;
    double	c_y;
    cell_val	c_val;
}			Cell;
d135 1
a135 1
	"cell-fb ($Revision: 10.11 $)",
d145 1
d169 1
a169 1
static double	key_height = 0;		/* How many cell heights for key? */
d224 2
d243 1
d258 1
d266 9
a274 2
	rt_log("Displaying %ld cells\n", ncells);
	if (! display_Cells(ncells))
d276 8
a283 2
	    rt_log("cell-fb: failed to display %ld cells\n", ncells);
	    exit (1);
a284 2
	if (log_flag)
	    log_Run();
d681 17
d762 15
@


10.11
log
@PI in math.h sometimes.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/cell-fb.c,v 10.10 94/11/14 22:25:22 mike Exp Locker: mike $ (BRL)";
d127 1
a127 1
	"cell-fb ($Revision: 10.10 $)",
@


10.10
log
@Irix 6
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/cell-fb.c,v 10.9 94/10/03 15:13:00 pjt Exp Locker: mike $ (BRL)";
d43 3
a45 1
#define PI		3.14159265358979323846264338327950288419716939937511
d127 1
a127 1
	"cell-fb ($Revision: 10.9 $)",
@


10.9
log
@Fixed C. Moore's bug (#101) cell count is sometimes off by 1
and ripped out the associated diagnostics
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/cell-fb.c,v 10.8 94/10/03 14:54:15 pjt Exp Locker: pjt $ (BRL)";
d125 1
a125 1
	"cell-fb ($Revision: 10.8 $)",
a152 1
static char	infile[MAX_LINE] = { 0 };/* Name of input stream */
d207 6
a894 3
    static char         *mon_nam[] =
                        { "Jan", "Feb", "Mar", "Apr", "May", "Jun",
                          "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
@


10.8
log
@I think Cmoore's bug is fixed,
but I'll check in all these diagnostics just in case
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/cell-fb.c,v 10.6 94/10/03 08:40:25 pjt Exp Locker: pjt $ (BRL)";
d125 1
a125 1
	"cell-fb ($Revision: 10.6 $)",
a261 3
#define zgets(ln, s,n,stream)						\
    ((result=fgets((s), (n), (stream))), printf("%d: when in state %d fgots(%s)\n", (ln),state,(s)), result)

a267 1
    char		*result;
d280 1
a280 1
        zgets(__LINE__, lbp, MAX_LINE, filep);
a301 1
	printf("%d: %d: %s", __LINE__, gp - grid, lbp);
a323 5
	    if (state == STATE_BEYOND_DATA)
	    {
		printf("What the heck?");
		exit(1);
	    }
d328 1
a328 1
	    if(feof(filep) ||	zgets(__LINE__, lbp, MAX_LINE, filep) == NULL)
a329 1
	    printf("%d: after zgets() state=%d\n", __LINE__, state);
a334 1
	printf("%d: after non-data lines state=%d\n", __LINE__, state);
a344 1
	printf("%d: should be in data, state=%d\n", __LINE__, state);
a346 2
	printf("%d: view_flag=%d, view_ct=%d\n",
	    __LINE__, view_flag, view_ct);
a367 5
	    printf("%d: OK, when gp was <%x>... %d %d %d\n",
		__LINE__, gp-1,
		(gp-1)->c_val.v_color[RED],
		(gp-1)->c_val.v_color[GRN],
		(gp-1)->c_val.v_color[BLU]);
d369 1
a369 1
    } while (zgets(__LINE__, lbp, MAX_LINE, filep) != NULL);
@


10.7
log
@First shot at fixing bug reported by cmoore
@
text
@d262 3
d271 1
d284 1
a284 1
        fgets(lbp, MAX_LINE, filep);
d306 1
d324 1
a324 1
	       (color_flag &&
d327 1
a327 1
		(sscanf(lbp, format, &x, &y, &value.v_scalar) != 3)))
d329 5
d338 1
a338 1
	    if(feof(filep) || fgets(lbp, MAX_LINE, filep) == NULL)
d340 1
d346 1
d357 1
d360 2
d383 5
d389 1
a389 1
    } while (fgets(lbp, MAX_LINE, filep) != NULL);
@


10.6
log
@Undid diagnostic behavior of offering next view before
we knew there was one to offer
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/cell-fb.c,v 10.5 94/09/02 09:15:56 pjt Exp Locker: pjt $ (BRL)";
d125 1
a125 1
	"cell-fb ($Revision: 10.5 $)",
d257 5
d265 1
d267 1
a267 2
    register int	past_data = false;
    static int		past_header = false;
d272 6
a277 5
    /* Build the format for sscanf() */
    (void) strcpy(format, "%lf %lf");
    if (color_flag)
	(void) strcat(format, " %d %d %d");
    else
d279 11
a289 3
	for (i = 1; i < field; i++)
	    (void) strcat(format, " %*lf");	/* Skip to field of interest */
	(void) strcat(format, " %lf");
a290 1

d292 1
a292 1
    if (! past_header && fgets(linebuf, MAX_LINE, filep) == NULL)
d317 4
a320 3
	/* Read in a line of input */
	while ((color_flag &&
		(sscanf(linebuf, format, &x, &y, &r, &g, &b) != 5))
d322 1
a322 1
		(sscanf(linebuf, format, &x, &y, &value.v_scalar) != 3)))
d324 5
a328 3
	    if (past_header)
		past_data = true;
	    if(feof(filep) ||	fgets(linebuf, MAX_LINE, filep) == NULL)
d331 5
a335 1
	if (color_flag)
d337 1
a337 5
	    value.v_color[RED] = r;
	    value.v_color[GRN] = g;
	    value.v_color[BLU] = b;
	}
	if (past_data)
a340 2
	    {
		past_data = false;
d342 3
a344 2
	    }
	past_header = true;
d361 3
a363 1
		COPYRGB(gp->c_val.v_color, value.v_color);
d369 1
a369 1
    } while (fgets(linebuf, MAX_LINE, filep) != NULL);
@


10.5
log
@Replaced all calls to fb_log() with rt_log() calls
for the resource locking.
 XXX     NOTE!    XXX
 XXX
 XXX When /dev/sgil is specified it only shows a single view
 XXX
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/cell-fb.c,v 10.4 94/08/30 10:57:48 pjt Exp Locker: pjt $ (BRL)";
d125 1
a125 1
	"cell-fb ($Revision: 10.4 $)",
a223 1
    int	r;
d254 1
a254 2
	r = get_OK();
    } while ((view_flag == 0) && ! feof(filep) && r);
@


10.4
log
@1. Modified to REALLY only write pixels in valid parts
   of the buffer
2. Converted to rt_malloc, rt_realloc
3. Added -x option
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/cell-fb.c,v 10.3 94/08/11 19:10:48 gdurf Exp Locker: pjt $ (BRL)";
d125 1
a125 1
	"cell-fb ($Revision: 10.3 $)",
d224 1
d234 1
a234 1
	fb_log("grid = 0x%x... %ld cells @@ %d bytes/cell\n",
d240 1
d244 1
a244 1
	    fb_log("cell-fb: failed to read view\n");
d247 1
a247 1
	fb_log("Displaying %ld cells\n", ncells);
d250 1
a250 1
	    fb_log("cell-fb: failed to display %ld cells\n", ncells);
d255 2
a256 5
	/*
	fb_log("view_flag = %d, feof(filep) = %d, get_OK() = %d\n",
	    view_flag, feof(filep), get_OK());
	 */
    } while ((view_flag == 0) && ! feof(filep) && get_OK());
d301 1
a301 1
		fb_log("maxcells increased to %ld\n", maxcells);
d340 1
a340 1
		fb_log("xmin=%g, xmax=%g, ymin=%g, ymax=%g\n",
d365 1
a365 1
	fb_log("Cannot open /dev/tty for reading\n");
d368 1
a368 1
    fb_log("Another view follows.  Display ? [y/n](y) ");
d432 1
a432 1
	fb_log("fb_size requested: %d %d\n", fb_width, fb_height);
d435 1
a435 1
	fb_log("fb_size  obtained: %d %d\n", fb_width, fb_height);
d438 1
a438 1
	fb_log("Cannot initialize color map\n");
d440 1
a440 1
	fb_log("Cannot set zoom <%d,%d>\n", zoom, zoom);
d442 1
a442 1
	fb_log("Cannot clear frame buffer\n");
d448 1
a448 1
	fb_log("buf = 0x%x... %d pixels @@ %d bytes/pixel\n",
d465 1
a465 1
		    fb_log("%d = V2SCRY(%g)\n", V2SCRY(lasty), lasty);
d473 1
a473 1
				fb_log("Couldn't write to <%d,%d>\n", 0, y0);
d490 1
a490 1
		    fb_log("Couldn't write to <%d,%d>\n", 0, y0);
d496 1
a496 1
		    fb_log("Writing grid row at %d\n", y0);
d517 1
a517 1
	    fb_log("Couldn't write to <%d,%d>\n", 0, y0);
d523 1
a523 1
	fb_log("Width of key (%d) would exceed frame-buffer width (%d)\n",
d570 1
a570 1
		fb_log("Couldn't write to <%d,%d>\n", 0, i);
d579 1
a579 1
	fb_log("freed buf, which is now 0x%x\n", buf);
d659 1
a659 1
		    fb_log("Invalid frame-buffer height: '%s'\n", optarg);
d664 1
a664 1
		    fb_log("Frame-buffer height out of range: %d\n", fb_height);
d671 1
a671 1
		    fb_log("Invalid frame-buffer width: '%s'\n", optarg);
d676 1
a676 1
		    fb_log("Frame-buffer width out of range: %d\n", fb_width);
d683 1
a683 1
		    fb_log("Invalid frame-buffer dimension: '%s'\n", optarg);
d688 1
a688 1
		    fb_log("Frame-buffer dimensions out of range: %d\n",
d697 1
a697 1
		    fb_log("Invalid debug flag: '%s'\n", optarg);
d704 1
a704 1
		    fb_log("Invalid boolean value: '%s'\n", optarg);
d712 1
a712 1
		    fb_log("Invalid cell size: '%s'\n", optarg);
d717 1
a717 1
		    fb_log("Cell size out of range: %d\n", cell_size);
d724 1
a724 1
		    fb_log("Invalid domain for input: '%s'\n", optarg);
d729 1
a729 1
		    fb_log("Bad domain for input: [%lf, %lf]\n",
d741 1
a741 1
		    fb_log("Invalid field: '%s'\n", optarg);
d761 1
a761 1
		    fb_log("Invalid view: '%s'\n", optarg);
d778 1
a778 1
			fb_log("Invalid color-mapping: '%s'\n",
d786 1
a786 1
			fb_log("Value out of range (%s)\n", optarg);
d801 1
a801 1
			fb_log("Invalid offset: '%s'\n", optarg);
d811 1
a811 1
			fb_log("Invalid cell scale: '%s'\n", optarg);
d818 1
a818 1
		    fb_log("Invalid view number: '%s'\n", optarg);
d827 1
a827 1
		    fb_log("Invalid debug flag: '%s'\n", optarg);
d840 1
a840 1
	    fb_log("Cannot open file '%s'\n", argv[optind]);
d846 1
a846 1
	fb_log("Too many arguments!\n");
d868 1
a868 1
	fb_log("%s\n", *p++);
@


10.3
log
@Added include of conf.h
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/cell-fb.c,v 10.2 1994/08/11 15:05:54 mike Exp gdurf $ (BRL)";
d25 1
d50 1
a50 1
#define	OPT_STRING	"CF:N:S:W:X:b:c:d:ef:ghikl:m:p:s:v:?"
d104 2
a105 1

d125 1
a125 1
	"cell-fb ($Revision: 10.2 $)",
d134 1
a134 1
	" -X n          Set debug flag to hexadecimal value `n' (default is 0)",
d149 1
d175 1
a175 1

d230 2
a231 1
    if ((grid = (Cell *) malloc(sizeof(Cell) * maxcells)) == NULL)
d233 3
a235 2
	fb_log("cell-fb: couldn't allocate space for %d cells\n", maxcells);
	exit (1);
a236 1

d253 4
d298 3
a300 2
	    if ((grid = (Cell *) realloc(grid, sizeof(Cell) * maxcells))
		== NULL)
d302 2
a303 2
		fb_log("Cannot allocate space for %d cells\n", maxcells);
		return (0); /* failure */
a305 3
#ifdef DEBUG
	    fb_log("maxcells increased to %ld\n", maxcells);
#endif
a306 1

d341 1
a341 1
		fprintf(stderr, "xmin=%g, xmax=%g, ymin=%g, ymax=%g\n",
d369 2
a370 2
    (void) fputs("Another view follows.  Display ? [y/n](y) ", stderr);
    (void) fflush(stdout);
a384 1

d401 1
a401 1
    static unsigned char *buf = 0;
d433 1
a433 1
	(void) fprintf(stderr, "fb_size requested: %d %d\n", fb_width, fb_height);
d436 1
a436 1
	(void) fprintf(stderr, "fb_size  obtained: %d %d\n", fb_width, fb_height);
d445 3
a447 1
    if ((buf = (unsigned char *) malloc(sizeof(RGBpixel) * fb_width)) == NULL)
d449 3
a451 2
	fb_log("cell-fb: couldn't allocate space for %d pixels\n", fb_width);
	exit (1);
d466 1
a466 1
		    fprintf(stderr, "%d = V2SCRY(%g)\n", V2SCRY(lasty), lasty);
a479 1

d497 1
a497 1
		    fprintf(stderr, "Writing grid row at %d\n", y0);
d506 1
a506 1
    	if( x0 >= 0 && x0 < fb_width )  {
a521 1

d523 4
a526 1
    if (key_flag)
d577 6
a635 1

a768 1

d825 7
a862 1

@


10.2
log
@Reduced use of RGBpixel
Now use (unsigned char *)
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/cell-fb.c,v 10.1 91/10/12 06:46:03 mike Rel4_0 Locker: mike $ (BRL)";
d19 2
d123 1
a123 1
	"cell-fb ($Revision: 10.1 $)",
@


10.1
log
@Release_4.0
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/cell-fb.c,v 2.19 91/10/11 11:56:53 butler Exp $ (BRL)";
d121 1
a121 1
	"cell-fb ($Revision: 2.19 $)",
d395 1
a395 1
    static RGBpixel	*buf = 0;
d439 1
a439 1
    if ((buf = (RGBpixel *) malloc(sizeof(RGBpixel) * fb_width)) == NULL)
d475 1
a475 1
		COPYRGB(buf[x0], BACKGROUND);
d501 1
a501 1
		    COPYRGB(buf[x0], pixel);
d527 1
a527 1
	    COPYRGB(buf[i], BACKGROUND);
d554 1
a554 1
		COPYRGB(buf[index], pixel);
@


2.19
log
@removed include for sys/time.h
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/cell-fb.c,v 2.18 91/08/16 15:12:10 butler Exp Locker: butler $ (BRL)";
d121 1
a121 1
	"cell-fb ($Revision: 2.18 $)",
@


2.18
log
@re-implemented the "-h" flag which had somehow been left behind in the
massive on-rush of progress.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/fb/RCS/cell-fb.c,v 2.17 91/07/24 01:14:54 mike Exp $ (BRL)";
a22 1
#include <sys/time.h>
d121 1
a121 1
	"cell-fb ($Revision: 2.17 $)",
@


2.17
log
@ANSI nit
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/fb/RCS/cell-fb.c,v 2.16 91/07/22 21:43:06 mike Exp Locker: mike $ (BRL)";
d122 1
a122 1
	"cell-fb ($Revision: 2.16 $)",
a167 1
static bool	hires_flag = false;	/* Force high-res frame buffer? */
d736 1
a736 1
		hires_flag = true;
d833 4
@


2.16
log
@IBM didn't like unused localtime() call.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/cell-fb.c,v 2.15 91/07/06 03:34:33 mike Exp $ (BRL)";
d122 1
a122 1
	"cell-fb ($Revision: 2.15 $)",
d212 1
@


2.15
log
@older machines don't know about "const", use CONST
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/fb/RCS/cell-fb.c,v 2.14 91/07/02 03:29:29 mike Exp $ (BRL)";
d122 1
a122 1
	"cell-fb ($Revision: 2.14 $)",
a852 1
    struct tm           *tempus;
a865 1
    tempus = localtime(&clock);
@


2.14
log
@Changed to using ctime(), which is more portable.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/cell-fb.c,v 2.13 91/06/26 04:54:41 mike Exp $ (BRL)";
d122 1
a122 1
	"cell-fb ($Revision: 2.13 $)",
d870 1
a870 1
	ctime((const int *)&clock) );
@


2.13
log
@Modified so that it would not write scanlines not on the framebuffer.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/cell-fb.c,v 2.12 91/06/26 04:50:33 mike Exp $ (BRL)";
d122 1
a122 1
	"cell-fb ($Revision: 2.12 $)",
d869 2
a870 4
    (void) printf(
	"# Log information produced by CELL-FB %02d %s %4d at %02d%02d\n",
	tempus -> tm_mday, mon_nam[tempus -> tm_mon],
	tempus -> tm_year + 1900, tempus -> tm_hour, tempus -> tm_min);
@


2.12
log
@Modified to only write pixels in valid parts of the buffer.
Modified to properly center the color key, even if offsets are in use.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/cell-fb.c,v 2.11 91/06/26 04:14:56 mike Exp $ (BRL)";
d122 1
a122 1
	"cell-fb ($Revision: 2.11 $)",
d461 10
a470 7
		for(y0 = V2SCRY(lasty), y1 = y0 + hgt; y0 < y1; y0++)
		    if (fb_write(fbiop, 0, y0, buf, fb_width) == -1)
		    {
			fb_log("Couldn't write to <%d,%d>\n", 0, y0);
			(void) fb_close(fbiop);
			return (false);
		    }
@


2.11
log
@Fixed nasty problem with registration.
H2CX needs to truncate cell number to an integer.
Also changed all rt-log-file output statements to %.6f,
to prevent %g from rounding things to nearest integer.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/cell-fb.c,v 2.10 91/06/26 02:28:24 mike Exp $ (BRL)";
d122 1
a122 1
	"cell-fb ($Revision: 2.10 $)",
d494 8
a501 4
	for (x0 = H2SCRX(gp->c_x), x1 = x0 + wid; x0 < x1;  x0++)
	{
	    COPYRGB(buf[x0], pixel);
	}
d512 1
d518 3
d527 13
a539 2
	base = (xmin+xmax) / 2 - 5 * cell_size;
	base = H2SCRX(base);
d544 2
d551 1
a551 2
		int offset = i * (wid+grid_flag);
		register int index = base + offset + j;
d555 1
a555 1

@


2.10
log
@Made the macros exact inverses.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/cell-fb.c,v 2.9 91/06/26 02:19:18 mike Exp $ (BRL)";
d68 2
a69 2
#define H2CX(_h)	( ((_h) - xmin) / cell_size )
#define V2CY(_v)	( ((_v) - ymin) / cell_size )
d122 1
a122 1
	"cell-fb ($Revision: 2.9 $)",
d723 1
a723 1
		if (sscanf(optarg, "%f%f", &az, &el) != 2)
d876 1
a876 1
	printf("Orientation: %g, %g, %g, %g\n", V4ARGS(orient) );
d883 3
a885 3
	hv_viewsize = SCRX2H( fb_width - 1 ) - SCRX2H( 0 );
	hv_eye[0] = SCRX2H( fb_width/2 + 0.5 );
	hv_eye[1] = SCRY2V( fb_height/2 + 0.5 );
d888 3
a890 2
printf("SCRX2H(fb_width -1) = %g; SCRX2H(0) = %g; hv_viewsize= %g\n",
	SCRX2H(fb_width - 1), SCRX2H(0), hv_viewsize);
a892 3

printf("hv_eye= %g, %g, %g\n", V3ARGS(hv_eye) );

d894 1
d896 3
a898 4
	printf("Eye_pos: %g, %g, %g\n", V3ARGS(m_eye) );

	/* Now find the view size in model coordinates and print that
	 * as well.
a899 1

d901 1
a901 2
	printf("Size: %g\n", m_viewsize);

@


2.9
log
@Broke out "relative cell number" as a separate transformation.
This will clarify the bug with the key height.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/cell-fb.c,v 2.8 91/06/26 02:03:19 mike Exp $ (BRL)";
d71 2
a72 2
#define CX2VPX(_cx)	( (_cx) * (wid + grid_flag)+1.0 )
#define CY2VPY(_cy)	( (_cy) * (hgt + grid_flag)+key_height )
d82 2
a83 2
#define VPX2CX(_vp_x)	( (_vp_x) / (wid+grid_flag)-1.0 )
#define VPY2CY(_vp_y)	( (_vp_y) / (hgt+grid_flag)-key_height )
d122 1
a122 1
	"cell-fb ($Revision: 2.8 $)",
@


2.8
log
@Replaced YFB with V2SCRY
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/cell-fb.c,v 2.7 91/06/26 01:59:24 mike Exp $ (BRL)";
d58 8
a65 4
/* Translate between different coordinate systems at play: h,v (GIFT),
 * view_port (VP), the subdivision of the framebuffer where the image is
 * located and seen, and screen_x, _y coordinates, which are the framebuffer
 * coordinates.
d68 6
a73 2
#define H2VPX(_h)	( ((_h) - xmin)/cell_size * (wid + grid_flag)+1.0 )
#define V2VPY(_v)	( ((_v) - ymin)/cell_size * (hgt + grid_flag)+key_height )
d77 2
d82 2
a83 2
#define VPX2H(_vp_x)	( cell_size * ((_vp_x)/(wid+grid_flag)-1.0) + xmin )
#define VPY2V(_vp_y)	( cell_size * ((_vp_y)/(hgt+grid_flag)-key_height) + ymin )
d85 2
a86 2
#define H2SCRX(_h)	VPX2SCRX( H2VPX(_h) )
#define V2SCRY(_v)	VPY2SCRY( V2VPY(_v) )
d88 1
a88 2
#define SCRX2H(_s_x)	VPX2H( SCRX2VPX(_s_x) )
#define SCRY2V(_s_y)	VPY2V( SCRY2VPY(_s_y) )
d90 6
d122 1
a122 1
	"cell-fb ($Revision: 2.7 $)",
@


2.7
log
@Replaced XFB with H2SCRX.  Horizontal alignment now works.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/cell-fb.c,v 2.6 91/06/26 01:56:03 mike Exp $ (BRL)";
d107 1
a107 1
	"cell-fb ($Revision: 2.6 $)",
d443 1
a443 1
		    fprintf(stderr, "%d = YFB(%g)\n", YFB(lasty), lasty);
d446 1
a446 1
		for(y0 = YFB(lasty), y1 = y0 + hgt; y0 < y1; y0++)
d486 1
a486 1
    for (y0 = YFB(lasty), y1 = y0 + hgt; y0 < y1;  y0++)
a809 20
}

int YFB(_y)

double	_y;

{
	double vpy;
    if (debug_flag & CFB_DBG_GRID)
    {
	fprintf(stderr,
	    "YFB(%g) = (int)(%d + (int)((%g - %g) / %g + %g) * (%d + %d)) = %d\n",
	    _y, yorigin, _y, ymin, cell_size, key_height, hgt, grid_flag,
	    (int)(yorigin + (int)((_y - ymin) / cell_size + key_height)
	    * (hgt + grid_flag)));
    }
	vpy = ((_y - ymin) / cell_size + key_height) * (hgt + grid_flag);
	vpy = V2VPY(_y);

	return (int)(VPY2SCRY(vpy));
@


2.6
log
@Replaced fbh2uu() with H2SCRX()
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/cell-fb.c,v 2.5 91/06/26 01:31:17 mike Exp $ (BRL)";
a57 3
/* Map user units into pixels.  H2SCRX */
#define XFB(_x) (int)(xorigin+(((_x)-xmin)/cell_size)*(wid+grid_flag))

d107 1
a107 1
	"cell-fb ($Revision: 2.5 $)",
d479 1
a479 1
	for (x0 = XFB(gp->c_x), x1 = x0 + wid; x0 < x1;  x0++)
d505 1
a505 1
	base = XFB(base);
@


2.5
log
@Excellent registration side-to-side,
still slightly off in V.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/cell-fb.c,v 2.4 91/06/26 01:02:10 mike Exp $ (BRL)";
d57 2
a58 1
/* Map user units into pixels */
d78 3
a83 3
/* Map pixels into user units */
#define	fbh2uu(_h)	(cell_size*(((_h)-xorigin)/(wid+grid_flag)-1.0)+xmin)
#define	fbv2uu(_v)	(cell_size*(((_v)-yorigin)/(hgt+grid_flag)-key_height)+ymin)
d110 1
a110 1
	"cell-fb ($Revision: 2.4 $)",
d820 1
d829 4
a832 2
    return (yorigin + (int)((_y - ymin) / cell_size + key_height)
	    * (hgt + grid_flag));
d860 1
a860 1
	fbh2uu(0), fbh2uu(fb_width), fbv2uu(0), fbv2uu(fb_height));
@


2.4
log
@Partly improved macros
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/cell-fb.c,v 2.3 91/06/25 13:25:51 sue Exp $ (BRL)";
d66 1
a66 1
#define H2VPX(_h)	( ((_h) - xmin)/cell_size * (wid + grid_flag)+0.5 )
d74 1
a74 1
#define VPX2H(_vp_x)	( cell_size * ((_vp_x)/(wid+grid_flag)-0.5) + xmin )
d81 1
a81 1
#define	fbh2uu(_h)	(cell_size*(((_h)-xorigin)/(wid+grid_flag)-.5)+xmin)
d109 1
a109 1
	"cell-fb ($Revision: 2.3 $)",
a886 1

d888 2
a889 2
	hv_eye[0] = SCRX2H( fb_width/2 );
	hv_eye[1] = SCRY2V( fb_height/2 );
@


2.3
log
@At this time, cell-fb produces a log file which allows rtregis to almost
register images: the overlaid image is a wee bit off, tending downward.
CAVEAT: when -k is used to produce the cell-plot, the registration does
not take that into account and therefore is quite a bit lower than the
model.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/cell-fb.c,v 2.2 91/06/23 00:19:02 sue Exp $ (BRL)";
d66 2
a67 2
#define H2VPX(_h)	( ((_h) - xmin)/cell_size * (wid + grid_flag) )
#define V2VPY(_v)	( ((_v) - ymin)/cell_size * (hgt + grid_flag) )
d71 2
a72 3
/* When used with rtcell and without the -c flag, these macros give huge figures.
 * With the -c flag, however, they ALMOST register perfectly.
 */
d74 2
a75 2
#define SCRX2H(_scr_x)	( ( (_scr_x) - xorigin ) * (cell_size/(wid + grid_flag) ) + xmin )
#define SCRY2V(_scr_y)  ( ( (_scr_y) - yorigin ) * (cell_size/(hgt + grid_flag) ) + ymin )
d77 2
a78 4
/*  These looked like they might work, but they produce really humongous figures.
 *#define SCRX2H(_scr_x)	( ( (_scr_x) - xorigin ) / cell_size * (wid + grid_flag)  + xmin )
 *#define SCRY2V(_scr_y)  ( ( (_scr_y) - yorigin ) / cell_size * (hgt + grid_flag)  + ymin )
 */
d109 1
a109 1
	"cell-fb ($Revision: 2.2 $)",
@


2.2
log
@Added code to permit printing out the orientation, eye-pos, and
view size of the model.  This is what rtregis needs in order to do
the overlays.  At this time, the code compiles, but it is not clear
that the figures I get out are kosher.  The orientation looks
fine, but the eye-position is definitely strange.  The viewsize can
be argued with.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/cell-fb.c,v 2.1 91/06/10 09:20:14 pjt Exp $ (BRL)";
d66 4
a69 6
#define H2VPX(_h)	((_h) - xmin)/cell_size * (wid + grid_flag)
#define V2VPY(_v)	((_v) - ymin)/cell_sixe * (hgt + grid_flag)
#define VPX2SCRX(_vp_x)	((_vp_x) + xorigin)
#define VPY2SCRY(_vp_y)	((_vp_y) + yorigin)
#define SCRX2H(_scr_x)	((_scr_x) - xorigin) * (cell_size/(wid + grid_flag) ) + xmin
#define SCRY2V(_scr_y)  ((_scr_y) - yorigin) * (cell_size/(hgt + grid_flag) ) + ymin
d71 12
d112 1
a112 1
	"cell-fb ($Revision: 2.1 $)",
d871 4
d901 1
a901 1
printf("hv_eye= %g\n", hv_eye);
@


2.1
log
@First version installed in BRL-CAD tree.  Changes include:
  - Addition of -C, -N, -S, -W, -d, and -l options
  - Addition of optional input file name on command line
  - Addition of monadic form of several options
  - Change of default cell size from 4 in to 100 mm
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: cell-fb.c,v 1.12 91/06/06 15:04:09 pjt Locked $ (BRL)";
d21 2
d59 14
d102 1
a102 1
	"cell-fb ($Revision: 1.12 $)",
d407 6
a412 2
    if (compute_fb_height || compute_fb_width)
	(void) fprintf(stderr, "fb_size: %d %d\n", fb_width, fb_height);
d831 7
d851 49
@


1.1
log
@Initial revision
@
text
@d2 13
a14 6
	Author:		Gary S. Moss
			U. S. Army Ballistic Research Laboratory
			Aberdeen Proving Ground
			Maryland 21005-5066
			(301)278-6651 or AV-298-6651
*/
d16 1
a16 1
static char RCSid[] = "@@(#)$Header: cell-fb.c,v 1.10 90/09/21 09:46:32 moss Exp $ (BRL)";
d21 1
d24 1
d34 13
a46 1
typedef int bool;
d48 8
d57 5
a61 1
#define YFB(_y) (int)(yorigin+(((_y)-ymin)/cell_size+2)*(hgt+grid_flag))
d63 17
a79 2
#define LORES	512
#define HIRES	1024
d81 2
a82 1
#define MAX_LINE	133
d84 30
a113 3
#define PI	3.14159265358979323846264338327950288419716939937511
					/* ratio of circumf. to diam. */
#define HFPI	(PI/2.0)
d115 12
a126 1
#define Abs( _a )	((_a) < 0.0 ? -(_a) : (_a))
d128 18
a145 5
#ifndef Min
#define Min( a, b )		((a) < (b) ? (a) : (b))
#define Max( a, b )		((a) > (b) ? (a) : (b))
#define MinMax( m, M, a )    { m = Min( m, a ); M = Max( M, a ); }
#endif
d147 1
a147 2
#define NEG_INFINITY	-10000000.0
#define POS_INFINITY	 10000000.0
d149 1
a149 1
typedef struct cell	Cell;
d151 49
a199 1
static struct cell
d201 2
a202 3
	double	c_x;
	double	c_y;
	double	c_val;
d204 10
a213 2
*grid;

d215 9
a223 21
static char	*usage[] = {
"",
"cell-fb ($Revision: 1.10 $)",
"",
"Usage: cell-fb [-F dev][-eghik][-bcfv n][-m \"n r g b\"][-p \"x y\"][-s \"w h\"]",
"",
"  option -F dev        Specify frame buffer device to use.",
"         -b n          Ignore values not equal to `n'.",
"         -c n          Specify cell size as `n' (default is 4 units).",
"         -e            Erase frame buffer before displaying picture.",
"         -f n          Display field `n' of cell data.",
"         -g            Leave space between cells.",
"         -h            Force high-resolution display (rather than best fit).",
"         -i            Round values (default is to interpolate colors).",
"         -k            Display color key.",
"         -m \"n r g b\"  Map value `n' to color ``r g b''.",
"         -p \"x y\"      Offset picture from bottom-left corner of display.",
"         -s \"w h\"      Specify width and height, in pixels, of each cell.",
"         -v n          Specify view number to use (default is all views).",
0
};
d225 10
a234 1
static char fbfile[MAX_LINE] = {0};
d236 3
a238 2
static double bool_val;
static double cell_size = 4.0;
d240 6
a245 4
static double xmin;
static double ymin;
static double xmax;
static double ymax;
d247 4
a250 7
static bool boolean_flag = false;
static bool debug_flag = false;
static bool erase_flag = false;
static bool grid_flag = false;
static bool hires_flag = false;
static bool interp_flag = true;
static bool key_flag = false;
d252 39
a290 4
static int field = 1;
static int wid = 10, hgt = 10;
static int xorigin = 0, yorigin = 0;
static int view_flag = 0;
d292 24
a315 1
static long maxcells = 10000;
d317 26
a342 1
static FBIO *fbiop = FBIO_NULL;
d344 8
a351 18
static RGBpixel	colortbl[12] =
			{
			{ 255, 255, 255 }, /* White */
			{ 100, 100, 140 }, /* Blue-grey */
			{   0,   0, 255 }, /* Blue */
			{   0, 120, 255 }, /* Light blue */
			{ 100, 200, 140 }, /* Turquoise */
			{   0, 150,   0 }, /* Dark green */
			{   0, 225,   0 }, /* Green */
			{ 255, 255,   0 }, /* Yellow */
			{ 255, 160,   0 }, /* Tangerine */
			{ 255, 100, 100 }, /* Pink */
			{ 255,   0,   0 }, /* Red */
			{   0,   0,   0 }  /* Black */
			};
#define MAX_COLORTBL	11
#define WHITE		colortbl[0]
#define BACKGROUND	colortbl[MAX_COLORTBL]
d353 1
a353 6
STATIC bool get_OK();
STATIC bool pars_Argv();
STATIC long read_Cell_Data();
STATIC void init_Globs();
STATIC void prnt_Usage();
STATIC void val_To_RGB();
d355 62
a416 4
main( argc, argv )
char	*argv[];
	{	static long ncells;
	if( ! pars_Argv( argc, argv ) )
d418 2
a419 2
		prnt_Usage();
		return	1;
d421 19
a439 1
	if( (grid = (Cell *) malloc( sizeof(Cell)*maxcells )) == NULL )
d441 3
a443 3
		fb_log( "%s: couldn't allocate space for %d cells.\n",
			argv[0], maxcells );
		return	1;
d445 1
a445 1
	do
d447 2
a448 13
		init_Globs();
		if( (ncells = read_Cell_Data()) == 0 )
			{
			fb_log( "%s: failed to read view.\n", argv[0] );
			return	1;
			}
		fb_log(	"Displaying %ld cells.\n", ncells );
		if( ! display_Cells( ncells ) )
			{
			fb_log( "%s: failed to display %ld cells.\n",
				argv[0], ncells );
			return	1;
			}
d450 2
a451 2
	while( view_flag == 0 && ! feof( stdin ) && get_OK()  );
	return	0;
d453 4
a456 73

STATIC long
read_Cell_Data()
	{	static char linebuf[MAX_LINE];
		static char format[MAX_LINE];
		register int past_data = false;
		static int past_header = false;
		int i;
		register Cell *gp = grid;
		int view_ct = 1;

	(void) strcpy( format, "%lf %lf" );
	for( i = 1; i < field; i++ )
		(void) strcat( format, " %*lf" );
	(void) strcat( format, " %lf" );
	if( ! past_header && fgets( linebuf, MAX_LINE, stdin ) == NULL )
		return	0;
	do
		{	double x, y, value;
			int items;
		if( (gp - grid) >= maxcells )
			{	long ncells = gp - grid;
			maxcells *= 2;
			if( (grid =
				(Cell *)realloc( grid, sizeof(Cell)*maxcells ))
				 == NULL )
				{
				fb_log( "Can't allocate space for %d cells.\n",
					maxcells );
				return	0; /* failure */
				}
			gp = grid + ncells;
#ifdef DEBUG
			fb_log( "maxcells increased to %ld.\n", maxcells );
#endif
			}
		while( (items = sscanf( linebuf, format, &x, &y, &value ))
			!= 3 )
			{
			if( past_header )
				past_data = true;
			/* Check for EOF condition. */
			if(	feof( stdin )
			   ||	fgets( linebuf, MAX_LINE, stdin ) == NULL
				)
				return	gp - grid;
			}
		if( past_data )
			{
			if( view_flag == 0 || view_flag == view_ct++ )
				return	gp - grid;
			else /* Not the selected view, read the next one. */
				{
				past_data = false;
				continue;
				}
			}
		past_header = true;

		/* If user has selected a view, only store values for that
			view. */
		if( view_flag == 0 || view_flag == view_ct )
			{
			MinMax( xmin, xmax, x );
			MinMax( ymin, ymax, y );
			gp->c_x = x;
			gp->c_y = y;
			gp->c_val = value;
			gp++;
			}
		}
	while( fgets( linebuf, MAX_LINE, stdin ) != NULL );
	return	gp - grid;
d458 1
d460 7
a466 24
STATIC bool
get_OK()
	{	int c;
		FILE *infp;
	if( (infp = fopen( "/dev/tty", "r" )) == NULL )
		{
		fb_log( "Can't open /dev/tty for reading.\n" );
		return	false;
		}
	(void) printf( "Another view follows.  Display ? [y/n](y) " );
	(void) fflush( stdout );
	switch( (c = getc( infp )) )
		{
	case '\n' :
		break;
	default :
		while( getc( infp ) != '\n' )
			; /* Read until user hits <RETURN>.		*/
		break;
		}
	(void) fclose( infp );
	if( c == 'n' )
		return	false;
	return	true;
d468 5
d474 2
a475 2
STATIC void
init_Globs()
d477 1
a477 5
	xmin = POS_INFINITY;
	ymin = POS_INFINITY;
	xmax = NEG_INFINITY;
	ymax = NEG_INFINITY;
	return;
d479 5
d485 10
d496 11
a506 48
STATIC bool
display_Cells( ncells )
long ncells;
	{	register Cell *gp, *ep = &grid[ncells];
		static int fbsize;
		static int zoom;
		static RGBpixel	buf[HIRES];
		static RGBpixel	pixel;
		double lasty = NEG_INFINITY;
		double dx, dy;
		register int y0 = 0, y1;
	dx = (xmax - xmin + 1.0)/cell_size * wid;
	dy = (ymax - ymin + 1.0)/cell_size * hgt;
	if( dx > LORES || dy > LORES )
		hires_flag = true;
	fbsize = hires_flag ? HIRES : LORES;
	zoom = 1;
	if( (fbiop = fb_open( fbfile[0] != '\0' ? fbfile : NULL, fbsize, fbsize ))
		== FBIO_NULL )
		return	false;
	if( fb_wmap( fbiop, COLORMAP_NULL ) == -1 )
		fb_log( "Can not initialize color map.\n" );
	if( fb_zoom( fbiop, zoom, zoom ) == -1 )
		fb_log( "Can not set zoom <%d,%d>.\n", zoom, zoom );
	if( erase_flag && fb_clear( fbiop, BACKGROUND ) == -1 )
		fb_log( "Can not clear frame buffer.\n" );
	for( gp = grid; gp < ep; gp++ )
		{	register int x0, x1;
		/* Whenever Y changes, write out row of cells.		*/
		if( lasty != gp->c_y )
			{
			/* If first time, nothing to write out.		*/
			if( lasty != NEG_INFINITY )
				{
				for(	y0 = YFB( lasty ), y1 = y0 + hgt;
					y0 < y1;
					y0++ )
					{
					if( fb_write( fbiop, 0, y0,
							buf, fbsize ) == -1 )
						{
						fb_log( "Couldn't write to <%d,%d>\n",
							0, y0 );
						(void) fb_close( fbiop );
						return	false;
						}
					}
				}
d508 1
a508 5
			/* Clear buffer. */
			for( x0 = 0; x0 < fbsize; x0++ )
				{
				COPYRGB( buf[x0], BACKGROUND );
				}
d510 39
a548 58

			/* Draw grid line between rows of cells. */
			if( grid_flag )
				{
				if( fb_write( fbiop, 0, y0, buf, fbsize ) == -1 )
					{
					fb_log( "Couldn't write to <%d,%d>\n",
						0, y0 );
					(void) fb_close( fbiop );
					return	false;
					}
				}
			lasty = gp->c_y;
			}
		val_To_RGB( gp->c_val, pixel );
		for( x0 = XFB( gp->c_x ), x1 = x0 + wid; x0 < x1;  x0++ )
			{
			COPYRGB( buf[x0], pixel );
			}
		}
	/* Write out last row of cells. */
	for( y0 = YFB( lasty ), y1 = y0 + hgt; y0 < y1;  y0++ )
		if( fb_write( fbiop, 0, y0, buf, fbsize ) == -1 )
			{
			fb_log( "Couldn't write to <%d,%d>\n", 0, y0 );
			(void) fb_close( fbiop );
			return	false;
			}
	/* Draw color key. */
	if( key_flag )
		{	register int i, j;
			double base;
		/* Clear buffer. */
		for( i = 0; i < fbsize; i++ )
			{
			COPYRGB( buf[i], BACKGROUND );
			}
		base = (xmin+xmax)/2-5*cell_size;
		base = XFB( base );
		for( i = 0; i <= 10; i++ )
			{	double val = i/10.0;
			val_To_RGB( val, pixel );
			for( j = 0; j < wid; j++ )
				{	int offset = i * (wid+grid_flag);
					register int index = base + offset + j;
				COPYRGB( buf[index], pixel );
				}
			}
		for( i = yorigin; i < yorigin+hgt; i++ )
			if( fb_write( fbiop, 0, i, buf, fbsize ) == -1 )
				{
				fb_log( "Couldn't write to <%d,%d>\n", 0, i );
				(void) fb_close( fbiop );
				return	false;
				}
		}
	(void) fb_close( fbiop );
	return	true;
d550 8
d559 14
a572 4
STATIC void
val_To_RGB( val, rgb )
double val;
RGBpixel rgb;
d574 8
a581 3
	if(	boolean_flag && val != bool_val
	    ||	val < 0.0 || val > 1.0
		)
d583 2
a584 1
		COPYRGB( rgb, BACKGROUND );
d586 1
a586 2
	else
	if( val == 0.0 )
d588 2
a589 1
		COPYRGB( rgb, WHITE );
d591 6
a596 23
	else
		{	int index;
			double rem;
			double res;
		val *= 10.0; /* convert to range [0.0 to 10.0] */
		if( interp_flag )
			{
			index = val + 0.01; /* convert to range [0 to 10] */
			if( (rem = val - (double) index) < 0.0 ) /* remainder */
				rem = 0.0;
			res = 1.0 - rem;
			rgb[RED] = res*colortbl[index][RED] +
						rem*colortbl[index+1][RED];
			rgb[GRN] = res*colortbl[index][GRN] +
						rem*colortbl[index+1][GRN];
			rgb[BLU] = res*colortbl[index][BLU] +
						rem*colortbl[index+1][BLU];
			}
		else
			{
			index = val + 0.51;
			COPYRGB( rgb, colortbl[index] );
			}
d598 1
a598 11
	return;
	}

STATIC bool
pars_Argv( argc, argv )
register char **argv;
	{	register int c;
		extern int optind;
		extern char *optarg;
	/* Parse options.						*/
	while( (c = getopt( argc, argv, "F:b:c:ef:ghikm:p:s:v:" )) != EOF )
d600 92
a691 42
		switch( c )
			{
		case 'F' :
			(void) strncpy( fbfile, optarg, MAX_LINE );
			break;
		case 'b' :
			if( sscanf( optarg, "%lf", &bool_val ) != 1 )
				{
				fb_log( "Can't read boolean value.\n" );
				return	false;
				}
			boolean_flag = true;
			break;
		case 'c' :
			if( sscanf( optarg, "%lf", &cell_size ) != 1 )
				{
				fb_log( "Can't read cell size.\n" );
				return	false;
				}
			break;
		case 'e' :
			erase_flag = true;
			break;
		case 'f' :
			if( sscanf( optarg, "%d", &field ) != 1 )
				{
				fb_log( "Can't read field specifier.\n" );
				return	false;
				}
			break;
		case 'g' :
			grid_flag = true;
			break;
		case 'h' :
			hires_flag = true;
			break;
		case 'i' :
			interp_flag = false;
			break;
		case 'k' :
			key_flag = true;
			break;
d693 26
a718 47
		case 'm' :
			{	double		value;
				RGBpixel	rgb;
				int		red, grn, blu;
				int		index;
			if( sscanf( optarg, "%lf %d %d %d", &value, &red, &grn, &blu ) < 4 )
				{
				fb_log( "Can't read arguments to -m option.\n" );
				return	false;
				}
			value *= 10.0;
			index = value + 0.01;
			if( index < 0 || index > MAX_COLORTBL )
				{
				fb_log( "Value out of range (%s).\n", optarg );
				return	false;
				}
			rgb[RED] = red;
			rgb[GRN] = grn;
			rgb[BLU] = blu;
			COPYRGB( colortbl[index], rgb );
			break;
			}
		case 'p' :
			if( sscanf( optarg, "%d %d", &xorigin, &yorigin ) < 2 )
				{
				fb_log( "Can't read X and Y coordinates.\n" );
				return	false;
				}
			break;
		case 's' :
			if( sscanf( optarg, "%d %d", &wid, &hgt ) < 2 )
				{
				fb_log( "Can't read width and height.\n" );
				return	false;
				}
			break;
		case 'v' :
			if( sscanf( optarg, "%d", &view_flag ) < 1 )
				{
				fb_log( "Can't read view number.\n" );
				return	false;
				}
			break;
		case '?' :
			return	false;
			}
d720 2
a721 1
	if( argc != optind )
d723 5
a727 2
		fb_log( "Too many arguments!\n" );
		return	false;
d729 22
a750 1
	return	true;
d752 1
d754 22
d777 48
a824 8
/*	prnt_Usage() --	Print usage message.				*/
STATIC void
prnt_Usage()
	{	register char **p = usage;
	while( *p )
		fb_log( "%s\n", *p++ );
	return;
	}
@
