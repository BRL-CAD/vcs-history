head	11.8;
access;
symbols
	ansi-20040405-merged:11.5.2.1
	postmerge-20040405-ansi:11.6
	premerge-20040404-ansi:11.5
	postmerge-autoconf:11.5
	autoconf-freeze:11.5
	premerge-autoconf:11.5
	ansi-20040316-freeze:11.5.2.1
	postmerge-20040315-windows:11.5
	premerge-20040315-windows:11.5
	windows-20040315-freeze:11.5
	autoconf-20031203:11.5
	autoconf-20031202:11.5
	autoconf-branch:11.5.0.10
	phong-branch:11.5.0.8
	photonmap-branch:11.5.0.6
	rel-6-1-DP:11.5
	windows-branch:11.5.0.4
	rel-6-0-2:11.3
	ansi-branch:11.5.0.2
	rel-6-0-1-branch:11.3.0.2
	hartley-6-0-post:11.4
	hartley-6-0-pre:11.3
	rel-6-0-1:11.3
	rel-6-0:11.3
	rel-5-4:11.1
	offsite-5-3-pre:11.1
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1;
locks; strict;
comment	@ * @;


11.8
date	2004.05.24.04.13.26;	author morrison;	state dead;
branches;
next	11.7;

11.7
date	2004.05.10.15.30.42;	author erikg;	state Exp;
branches;
next	11.6;

11.6
date	2004.04.05.07.49.23;	author morrison;	state Exp;
branches;
next	11.5;

11.5
date	2002.08.20.17.07.25;	author jra;	state Exp;
branches
	11.5.2.1;
next	11.4;

11.4
date	2002.08.15.20.54.38;	author hartley;	state Exp;
branches;
next	11.3;

11.3
date	2001.08.10.21.27.04;	author butler;	state Exp;
branches;
next	11.2;

11.2
date	2001.04.12.17.44.08;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.09.31;	author mike;	state Rel4_4;
branches;
next	10.4;

10.4
date	94.11.14.22.27.35;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.08.23.18.49.09;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.08.11.15.06.12;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.46.36;	author mike;	state Rel4_0;
branches;
next	9.5;

9.5
date	91.08.31.07.29.47;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.03.02.15.44.23;	author gwyn;	state Exp;
branches;
next	9.3;

9.3
date	90.03.02.15.01.08;	author gwyn;	state Exp;
branches;
next	9.2;

9.2
date	90.03.02.14.41.41;	author gwyn;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.09.14;	author mike;	state Rel3_5;
branches;
next	1.7;

1.7
date	89.05.08.17.51.25;	author phil;	state Exp;
branches;
next	1.6;

1.6
date	89.05.08.17.18.04;	author gwyn;	state Exp;
branches;
next	1.5;

1.5
date	89.05.08.16.59.27;	author phil;	state Exp;
branches;
next	1.4;

1.4
date	89.05.04.05.23.25;	author gwyn;	state Exp;
branches;
next	1.3;

1.3
date	89.04.29.10.54.06;	author gwyn;	state Exp;
branches;
next	1.2;

1.2
date	89.04.26.20.09.10;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	89.04.26.19.20.57;	author mike;	state Exp;
branches;
next	;

11.5.2.1
date	2002.09.19.18.00.42;	author morrison;	state Exp;
branches;
next	;


desc
@Program to rescale image in one framebuffer to another.
Generally pixscale(1) would be used instead.
@


11.8
log
@moved to src/fb/
@
text
@/*
	fbstretch -- stretch a frame buffer image

	created:	89/04/29	D A Gwyn

	Typical compilation:	cc -O -I/usr/include/brlcad -o fbstretch \
					fbstretch.c /usr/brlcad/lib/libfb.a
	Add -DNO_VFPRINTF or -DNO_STRRCHR if vfprintf() or strrchr()
	are not present in your C library (e.g. on 4BSD-based systems).

	This program converts a frame buffer image so that it is stretched or
	compressed in the horizontal and/or vertical directions.  The image
	scaling origin is taken to be the lower left-hand corner of the
	display.  When compressing, pixel averaging is used by default;
	when expanding, pixel replication is used.  Pixel averaging may be
	meaningless for some color maps, so there is an option to use
	sampling instead.

	The main use of this utility is to compensate for differences in
	pixel aspect ratios among different display devices.

	Options:

	-a		"no averaging": samples for compression instead of
			averaging pixels

	-v		"verbose": prints information about sizes and scaling
			on the standard error output

	-x x_scale	horizontal scaling factor (default: out width/in width)

	-y y_scale	vertical scaling factor (default: out height/in height)

	-f in_fb	reads from the specified frame buffer file instead
			of modifying the one specified by the -f option "in
			place"

	-F out_fb	writes to the specified frame buffer file instead
			of the one specified by the FB_FILE environment
			variable (the default frame buffer, if no FB_FILE)

	-h		assumes 1024x1024 default input size instead of 512x512

	-s size		input size (width & height)

	-w width	input width

	-n height	input height

	-S size		output size (width & height)

	-W width	output width

	-N height	output height

	out_fb		same as -F out_fb, for convenience
*/
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/fb/fbstretch.c,v 11.7 2004/05/10 15:30:42 erikg Exp $ (BRL)";
#endif

#define	USAGE1	"fbstretch [ -h ] [ -s size ] [ -w width ] [ -n height ]"
#define	USAGE2	"\t[ -f in_fb_file ] [ -a ] [ -v ] [ -x x_sc ] [ -y y_sc ]"
#define	USAGE3 "\t[ -S size ] [ -W width ] [ -N height ] [ [ -F ] out_fb_file ]"
#define	OPTSTR	"af:F:hn:N:s:S:vw:W:x:y:"

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#ifndef DEBUG
#define	NDEBUG
#endif
#include	<assert.h>
#include	<signal.h>
#include	<stdio.h>
#ifdef USE_STRING_H
#include	<string.h>
#else
#include	<strings.h>
#endif
#if HAVE_STDARG_H
#include	<stdarg.h>
#else
#include	<varargs.h>
#endif

#include "machine.h"
#include "externs.h"
#include "fb.h"			/* BRL CAD package libfb.a interface */

#ifndef EXIT_SUCCESS
#define	EXIT_SUCCESS	0
#endif
#ifndef EXIT_FAILURE
#define	EXIT_FAILURE	1
#endif

typedef int	bool;
#define	false	0
#define	true	1

#define	EPSILON	0.0001			/* fudge for converting float to int */

static char	*arg0;			/* argv[0] for error message */
static bool	hires = false;		/* set for 1Kx1K; clear for 512x512 */
static bool	sample = false;		/* set: sampling; clear: averaging */
static bool	verbose = false;	/* set for size info printout */
static float	x_scale = -1.0;		/* horizontal scaling factor */
static float	y_scale = -1.0;		/* vertical scaling factor */
static bool	x_compress;		/* set iff compressing horizontally */
static bool	y_compress;		/* set iff compressing vertically */
static char	*src_file = NULL;	/* source frame buffer name */
static FBIO	*src_fbp = FBIO_NULL;	/* source frame buffer handle */
static char	*dst_file = NULL;	/* destination frame buffer name */
static FBIO	*dst_fbp = FBIO_NULL;	/* destination frame buffer handle */
static int	src_width = 0,
		src_height = 0;		/* source image size */
static int	dst_width = 0,
		dst_height = 0;		/* destination image size */
static unsigned char	*src_buf;		/* calloc()ed input scan line buffer */
static unsigned char	*dst_buf;		/* calloc()ed output scan line buffer */


static char *
Simple(char *path)
{
	register char	*s;		/* -> past last '/' in path */

	s = strrchr( path, '/' );
	return s == NULL || *++s == '\0' ? path : s;
	}


static void
VMessage(char *format, va_list ap)
{
	(void)fprintf( stderr, "%s: ", arg0 );
#if !defined(HAVE_VPRINTF)
	(void)fprintf( stderr, format,	/* kludge city */
		       ((int *)ap)[0], ((int *)ap)[1],
		       ((int *)ap)[2], ((int *)ap)[3],
		       ((int *)ap)[4], ((int *)ap)[5],
		       ((int *)ap)[6], ((int *)ap)[7]
		     );
#else
	(void)vfprintf( stderr, format, ap );
#endif
	(void)putc( '\n', stderr );
	(void)fflush( stderr );
	}


#if defined(HAVE_STDARG_H)
static void
Message( char *format, ... )
#else
static void
Message( va_alist )
	va_dcl
#endif
	{
#if !defined(HAVE_STDARG_H)
	register char	*format;	/* must be picked up by va_arg() */
#endif
	va_list		ap;

#if defined(HAVE_STDARG_H)
	va_start( ap, format );
#else
	va_start( ap );
	format = va_arg( ap, char * );
#endif
	VMessage( format, ap );
	va_end( ap );
	}


#if defined(HAVE_STDARG_H)
static void
Fatal( char *format, ... )
#else
static void
Fatal( va_alist )
	va_dcl
#endif
	{
#if !defined(HAVE_STDARG_H)
	register char	*format;	/* must be picked up by va_arg() */
#endif
	va_list		ap;

#if defined(HAVE_STDARG_H)
	va_start( ap, format );
#else
	va_start( ap );
	format = va_arg( ap, char * );
#endif
	VMessage( format, ap );
	va_end( ap );

	if ( src_fbp != FBIO_NULL && fb_close( src_fbp ) == -1 )
		Message( "Error closing input frame buffer" );

	if ( dst_fbp != FBIO_NULL && dst_fbp != src_fbp
	  && fb_close( dst_fbp ) == -1
	   )
		Message( "Error closing output frame buffer" );

	exit( EXIT_FAILURE );
	/*NOTREACHED*/
	}


static void
Sig_Catcher(int sig)
{
	(void)signal( sig, SIG_DFL );

	/* The following is not guaranteed to work, but it's worth a try. */
	Fatal( "Interrupted by signal %d", sig );
	}


int
main(int argc, char **argv)
{
	/* Plant signal catcher. */
	{
	static int	getsigs[] =	/* signals to catch */
		{
		SIGHUP,			/* hangup */
		SIGINT,			/* interrupt */
		SIGQUIT,		/* quit */
		SIGPIPE,		/* write on a broken pipe */
		SIGTERM,		/* software termination signal */
		0
		};
	register int	i;

	for ( i = 0; getsigs[i] != 0; ++i )
		if ( signal( getsigs[i], SIG_IGN ) != SIG_IGN )
			(void)signal( getsigs[i], Sig_Catcher );
	}

	/* Process arguments. */

	arg0 = Simple( argv[0] );	/* save for possible error message */

	{
		register int	c;
		register bool	errors = false;

		while ( (c = getopt( argc, argv, OPTSTR )) != EOF )
			switch( c )
				{
			default:	/* '?': invalid option */
				errors = true;
				break;

			case 'a':	/* -a */
				sample = true;
				break;

			case 'f':	/* -f in_fb */
				src_file = optarg;
				break;

			case 'F':	/* -F out_fb */
				dst_file = optarg;
				break;

			case 'h':	/* -h */
				hires = true;
				break;

			case 'n':	/* -n height */
				if ( (src_height = atoi( optarg )) <= 0 )
					errors = true;

				break;

			case 'N':	/* -N height */
				if ( (dst_height = atoi( optarg )) <= 0 )
					errors = true;

				break;

			case 's':	/* -s size */
				if ( (src_height = src_width = atoi( optarg ))
				  <= 0
				   )
					errors = true;

				break;

			case 'S':	/* -S size */
				if ( (dst_height = dst_width = atoi( optarg ))
				  <= 0
				   )
					errors = true;

				break;

			case 'v':
				verbose = true;
				break;

			case 'w':	/* -w width */
				if ( (src_width = atoi( optarg )) <= 0 )
					errors = true;

				break;

			case 'W':	/* -W width */
				if ( (dst_width = atoi( optarg )) <= 0 )
					errors = true;

				break;

			case 'x':	/* -x x_scale */
				if ( (x_scale = atof( optarg )) <= 0 )
					{
					Message( "Nonpositive x scale factor" );
					errors = true;
					}

				break;

			case 'y':	/* -y y_scale */
				if ( (y_scale = atof( optarg )) <= 0 )
					{
					Message( "Nonpositive y scale factor" );
					errors = true;
					}

				break;
				}

		if ( errors )
			Fatal( "Usage: %s\n%s\n%s", USAGE1, USAGE2, USAGE3 );
	}

	if ( optind < argc )		/* dst_file */
		{
		if ( optind < argc - 1 || dst_file != NULL )
			{
			Message( "Usage: %s\n%s\n%s", USAGE1, USAGE2, USAGE3 );
			Fatal( "Can't handle multiple output frame buffers!" );
			}

		dst_file = argv[optind];
		}

	if ( dst_file == NULL )
		dst_file = getenv( "FB_FILE" );	/* needed for later strcmp */

	/* Figure out what scale factors to use before messing up size info. */

	if ( x_scale < 0.0 ) {
		if ( src_width == 0 || dst_width == 0 )
			x_scale = 1.0;
		else
			x_scale = (double)dst_width / (double)src_width;
	}

	if ( y_scale < 0.0 ) {
		if ( src_height == 0 || dst_height == 0 )
			y_scale = 1.0;
		else
			y_scale = (double)dst_height / (double)src_height;
	}

	if ( verbose )
		Message( "Scale factors %gx%g", x_scale, y_scale );

	/* Open frame buffer(s) for unbuffered input/output. */

	if ( src_width == 0 )
		src_width = hires ? 1024 : 512;		/* starting default */

	if ( src_height == 0 )
		src_height = hires ? 1024 : 512;	/* starting default */

	if ( (src_fbp = fb_open( src_file == NULL ? dst_file : src_file,
				 src_width, src_height
			       )
	     ) == FBIO_NULL
	   )
		Fatal( "Couldn't open input image" );
	else	{
		register int	wt, ht;	/* actual frame buffer size */

		/* Use smaller input size in preference to requested size. */

		if ( (wt = fb_getwidth( src_fbp )) < src_width )
			src_width = wt;

		if ( (ht = fb_getheight( src_fbp )) < src_height )
			src_height = ht;

		if ( verbose )
			Message( "Source image %dx%d", src_width, src_height );

		if ( dst_width == 0 )
			dst_width = src_width * x_scale + EPSILON;

		if ( dst_height == 0 )
			dst_height = src_height * y_scale + EPSILON;

		if ( verbose )
			Message( "Requested output size %dx%d",
				 dst_width, dst_height
			       );

		if ( src_file == NULL
		     || (dst_file != NULL && strcmp( src_file, dst_file ) == 0)
		   )
			dst_fbp = src_fbp;	/* No No No Not a Second Time */
		else if ( (dst_fbp = fb_open( dst_file, dst_width, dst_height ))
		       == FBIO_NULL
			)
			Fatal( "Couldn't open output frame buffer" );

		/* Use smaller output size in preference to requested size. */

		if ( (wt = fb_getwidth( dst_fbp )) < dst_width )
			dst_width = wt;

		if ( (ht = fb_getheight( dst_fbp )) < dst_height )
			dst_height = ht;

		if ( verbose )
			Message( "Destination image %dx%d",
				 dst_width, dst_height
			       );
	}

	/* Determine compression/expansion directions. */

	x_compress = x_scale < 1 - EPSILON;
	y_compress = y_scale < 1 - EPSILON;

	/* Allocate input/output scan line buffers.  These could overlap, but
	   I decided to keep them separate for simplicity.  The algorithms are
	   arranged so that source and destination can access the same image; if
	   at some future time offsets are supported, that would no longer hold.
	   calloc is used instead of malloc just to avoid integer overflow. */

	if ( (src_buf = (unsigned char *)calloc(
		       y_compress ? (int)(1 / y_scale + 1 - EPSILON) * src_width
				  : src_width,
					    sizeof(RGBpixel)
					  )
	     ) == NULL
	  || (dst_buf = (unsigned char *)calloc(
		       y_compress ? dst_width
				  : (int)(y_scale + 1 - EPSILON) * dst_width,
					    sizeof(RGBpixel)
					  )
	     ) == NULL
	   )
		Fatal( "Insufficient memory for scan line buffers." );

#define	Src( x, y )	(&src_buf[(x) + src_width * (y) * sizeof(RGBpixel)])
#define	Dst( x, y )	(&dst_buf[(x) + dst_width * (y) * sizeof(RGBpixel)])

	/* Do the horizontal/vertical expansion/compression.  I wanted to merge
	   these but didn't like the extra bookkeeping overhead in the loops. */

	if ( x_compress && y_compress )
		{
		register int	src_x, src_y;	/* source rect. pixel coords. */
		register int	dst_x, dst_y;	/* destination pixel coords. */
		register int	top_x, top_y;	/* source rect. upper bounds */
		register int	bot_x, bot_y;	/* source rect. lower bounds */

#if 0	/* (already done by calloc()!) */
		/* Clear end of output scan line buffer to background. */

		for ( dst_x = src_width * y_scale + EPSILON;
		      dst_x < dst_width;
		      ++dst_x
		    )	{
			assert(dst_x >= 0);
			Dst( dst_x, 0 )[RED] = 0;
			Dst( dst_x, 0 )[GRN] = 0;
			Dst( dst_x, 0 )[BLU] = 0;
			}
#endif

		/* Compute coords. of source rectangle and destination pixel. */

		dst_y = 0;
    ccyloop:
		if ( dst_y >= dst_height )
			goto done;	/* that's all folks */

		bot_y = dst_y / y_scale + EPSILON;

		if ( (top_y = (dst_y + 1) / y_scale + EPSILON) > src_height )
			top_y = src_height;

		if ( top_y <= bot_y )
			{
			/* End of image. */

			/* Clear beginning of output scan line buffer. */

			dst_x = src_width * y_scale + EPSILON;

			if ( dst_x < dst_width )
				++dst_x;	/* sometimes needed */

			while ( --dst_x >= 0 )
				{
				assert(dst_x < dst_width);
				Dst( dst_x, 0 )[RED] = 0;
				Dst( dst_x, 0 )[GRN] = 0;
				Dst( dst_x, 0 )[BLU] = 0;
				}

			/* Clear out top margin. */

			for ( ; dst_y < dst_height; ++dst_y )
				if ( fb_write( dst_fbp, 0, dst_y,
					       (unsigned char *)Dst( 0, 0 ),
					       dst_width
					     ) == -1
				   )
					Fatal( "Error writing top margin" );

			goto done;	/* that's all folks */
			}

		assert(0 <= bot_y && bot_y < top_y && top_y <= src_height);
		assert(0 <= dst_y && dst_y <= bot_y);
		assert(top_y - bot_y <= (int)(1 / y_scale + 1 - EPSILON));

		/* Fill input scan line buffer. */

		for ( src_y = bot_y; src_y < top_y; ++src_y )
			if ( fb_read( src_fbp, 0, src_y,
				      (unsigned char *)Src( 0, src_y - bot_y ),
				      src_width
				    ) == -1
			   )
				Fatal( "Error reading scan line" );

		dst_x = 0;
    ccxloop:
		if ( dst_x >= dst_width )
			goto ccflush;

		bot_x = dst_x / x_scale + EPSILON;

		if ( (top_x = (dst_x + 1) / x_scale + EPSILON) > src_width )
			top_x = src_width;

		if ( top_x <= bot_x )
			{
    ccflush:		/* End of band; flush buffer. */

			if ( fb_write( dst_fbp, 0, dst_y,
				       (unsigned char *)Dst( 0, 0 ),
				       dst_width
				     ) == -1
			   )
				Fatal( "Error writing scan line" );

			++dst_y;
			goto ccyloop;
			}

		assert(0 <= bot_x && bot_x < top_x && top_x <= src_width);
		assert(0 <= dst_x && dst_x <= bot_x);
		assert(top_x - bot_x <= (int)(1 / x_scale + 1 - EPSILON));

		/* Copy sample or averaged source pixel(s) to destination. */

		if ( sample )
			{
			Dst( dst_x, 0 )[RED] = Src( bot_x, 0 )[RED];
			Dst( dst_x, 0 )[GRN] = Src( bot_x, 0 )[GRN];
			Dst( dst_x, 0 )[BLU] = Src( bot_x, 0 )[BLU];
			}
		else	{
			int		sum[3];	/* pixel value accumulator */
			register float	tally;	/* # of pixels accumulated */

			/* "Read in" source rectangle and average pixels. */

			sum[RED] = sum[GRN] = sum[BLU] = 0;

			for ( src_y = top_y - bot_y; --src_y >= 0; )
				for ( src_x = bot_x; src_x < top_x; ++src_x )
					{
					sum[RED] += Src( src_x, src_y )[RED];
					sum[GRN] += Src( src_x, src_y )[GRN];
					sum[BLU] += Src( src_x, src_y )[BLU];
					}

			tally = (top_x - bot_x) * (top_y - bot_y);
			assert(tally > 0.0);
			Dst( dst_x, 0 )[RED] = sum[RED] / tally + 0.5;
			Dst( dst_x, 0 )[GRN] = sum[GRN] / tally + 0.5;
			Dst( dst_x, 0 )[BLU] = sum[BLU] / tally + 0.5;
			}

		++dst_x;
		goto ccxloop;
		}
	else if ( x_compress && !y_compress )
		{
		register int	src_x, src_y;	/* source rect. pixel coords. */
		register int	dst_x, dst_y;	/* dest. rect. pixel coords. */
		register int	bot_x, top_x;	/* source rectangle bounds */
		register int	bot_y, top_y;	/* destination rect. bounds */

#if 0	/* (already done by calloc()!) */
		/* Clear end of output scan line buffer to background. */

		for ( dst_x = src_width * y_scale + EPSILON;
		      dst_x < dst_width;
		      ++dst_x
		    )
			for ( dst_y = (int)(y_scale + 1 - EPSILON);
			      --dst_y >= 0;
			    )	{
				assert(dst_x >= 0 && dst_y < dst_height);
				Dst( dst_x, dst_y )[RED] = 0;
				Dst( dst_x, dst_y )[GRN] = 0;
				Dst( dst_x, dst_y )[BLU] = 0;
				}
#endif

		/* Compute coords. of source and destination rectangles. */

		src_y = (dst_height - 1) / y_scale + EPSILON;
    ceyloop:
		if ( src_y < 0 )
			goto done;	/* that's all folks */

		bot_y = src_y * y_scale + EPSILON;

		if ( (top_y = (src_y + 1) * y_scale + EPSILON) > dst_height )
			top_y = dst_height;

		assert(0 <= src_y && src_y <= bot_y && src_y < src_height);
		assert(bot_y < top_y && top_y <= dst_height);
		assert(top_y - bot_y <= (int)(y_scale + 1 - EPSILON));

		/* Fill input scan line buffer. */

		if ( fb_read( src_fbp, 0, src_y, (unsigned char *)Src( 0, 0 ),
			      src_width
			    ) == -1
		   )
			Fatal( "Error reading scan line" );

		dst_x = 0;
    cexloop:
		if ( dst_x >= dst_width )
			goto ceflush;

		bot_x = dst_x / x_scale + EPSILON;

		if ( (top_x = (dst_x + 1) / x_scale + EPSILON) > src_width )
			top_x = src_width;

		if ( top_x <= bot_x )
			{
    ceflush:		/* End of band; flush buffer. */

			for ( dst_y = top_y; --dst_y >= bot_y; )
				if ( fb_write( dst_fbp, 0, dst_y,
					       (unsigned char *)Dst( 0, dst_y - bot_y
							      ),
					       dst_width
					     ) == -1
				   )
					Fatal( "Error writing scan line" );

			--src_y;
			goto ceyloop;
			}

		assert(0 <= bot_x && bot_x < top_x && top_x <= src_width);
		assert(0 <= dst_x && dst_x <= bot_x);
		assert(top_x - bot_x <= (int)(1 / x_scale + 1 - EPSILON));

		/* Replicate sample or averaged source pixel(s) to dest. */

		if ( sample )
			for ( dst_y = top_y - bot_y; --dst_y >= 0; )
				{
				Dst( dst_x, dst_y )[RED] = Src( bot_x, 0 )[RED];
				Dst( dst_x, dst_y )[GRN] = Src( bot_x, 0 )[GRN];
				Dst( dst_x, dst_y )[BLU] = Src( bot_x, 0 )[BLU];
				}
		else	{
			int		sum[3];	/* pixel value accumulator */
			register float	tally;	/* # of pixels accumulated */

			/* "Read in" source rectangle and average pixels. */

			sum[RED] = sum[GRN] = sum[BLU] = 0;

			for ( src_x = bot_x; src_x < top_x; ++src_x )
				{
				sum[RED] += Src( src_x, 0 )[RED];
				sum[GRN] += Src( src_x, 0 )[GRN];
				sum[BLU] += Src( src_x, 0 )[BLU];
				}

			tally = top_x - bot_x;
			assert(tally > 0.0);
			sum[RED] = sum[RED] / tally + 0.5;
			sum[GRN] = sum[GRN] / tally + 0.5;
			sum[BLU] = sum[BLU] / tally + 0.5;

			for ( dst_y = top_y - bot_y; --dst_y >= 0; )
				{
				Dst( dst_x, dst_y )[RED] = sum[RED];
				Dst( dst_x, dst_y )[GRN] = sum[GRN];
				Dst( dst_x, dst_y )[BLU] = sum[BLU];
				}
			}

		++dst_x;
		goto cexloop;
		}
	else if ( !x_compress && y_compress )
		{
		register int	src_x, src_y;	/* source rect. pixel coords. */
		register int	dst_x, dst_y;	/* dest. rect. pixel coords. */
		register int	bot_x, top_x;	/* destination rect. bounds */
		register int	bot_y, top_y;	/* source rectangle bounds */

		assert(dst_width >= src_width);	/* (thus no right margin) */

		/* Compute coords. of source and destination rectangles. */

		dst_y = 0;
    ecyloop:
		if ( dst_y >= dst_height )
			goto done;	/* that's all folks */

		bot_y = dst_y / y_scale + EPSILON;

		if ( (top_y = (dst_y + 1) / y_scale + EPSILON) > src_height )
			top_y = src_height;

		if ( top_y <= bot_y )
			{
			/* End of image. */

			/* Clear output scan line buffer. */

			for ( dst_x = dst_width; --dst_x >= 0; )
				{
				Dst( dst_x, 0 )[RED] = 0;
				Dst( dst_x, 0 )[GRN] = 0;
				Dst( dst_x, 0 )[BLU] = 0;
				}

			/* Clear out top margin. */

			for ( ; dst_y < dst_height; ++dst_y )
				if ( fb_write( dst_fbp, 0, dst_y,
					       (unsigned char *)Dst( 0, 0 ),
					       dst_width
					     ) == -1
				   )
					Fatal( "Error writing top margin" );

			goto done;	/* that's all folks */
			}

		assert(0 <= bot_y && bot_y < top_y && top_y <= src_height);
		assert(0 <= dst_y && dst_y <= bot_y);
		assert(top_y - bot_y <= (int)(1 / y_scale + 1 - EPSILON));

		/* Fill input scan line buffer. */

		for ( src_y = bot_y; src_y < top_y; ++src_y )
			if ( fb_read( src_fbp, 0, src_y,
				      (unsigned char *)Src( 0, src_y - bot_y ),
				      src_width
				    ) == -1
			   )
				Fatal( "Error reading scan line" );

		src_x = (dst_width - 1) / x_scale + EPSILON;
    ecxloop:
		if ( src_x < 0 )
			{
			/* End of band; flush buffer. */
			if ( fb_write( dst_fbp, 0, dst_y,
				       (unsigned char *)Dst( 0, 0 ),
				       dst_width
				     ) == -1
			   )
				Fatal( "Error writing scan line" );

			++dst_y;
			goto ecyloop;
			}

		bot_x = src_x * x_scale + EPSILON;

		if ( (top_x = (src_x + 1) * x_scale + EPSILON) > dst_width )
			top_x = dst_width;

		assert(0 <= src_x && src_x <= bot_x && src_x <= src_width);
		assert(bot_x < top_x && top_x <= dst_width);
		assert(top_x - bot_x <= (int)(x_scale + 1 - EPSILON));

		/* Replicate sample or averaged source pixel(s) to dest. */

		if ( sample )
			for ( dst_x = top_x; --dst_x >= bot_x; )
				{
				Dst( dst_x, 0 )[RED] = Src( src_x, 0 )[RED];
				Dst( dst_x, 0 )[GRN] = Src( src_x, 0 )[GRN];
				Dst( dst_x, 0 )[BLU] = Src( src_x, 0 )[BLU];
				}
		else	{
			int		sum[3];	/* pixel value accumulator */
			register float	tally;	/* # of pixels accumulated */

			/* "Read in" source rectangle and average pixels. */

			sum[RED] = sum[GRN] = sum[BLU] = 0;

			for ( src_y = top_y - bot_y; --src_y >= 0; )
				{
				sum[RED] += Src( src_x, src_y )[RED];
				sum[GRN] += Src( src_x, src_y )[GRN];
				sum[BLU] += Src( src_x, src_y )[BLU];
				}

			tally = top_y - bot_y;
			assert(tally > 0.0);
			sum[RED] = sum[RED] / tally + 0.5;
			sum[GRN] = sum[GRN] / tally + 0.5;
			sum[BLU] = sum[BLU] / tally + 0.5;

			for ( dst_x = top_x; --dst_x >= bot_x; )
				{
				Dst( dst_x, 0 )[RED] = sum[RED];
				Dst( dst_x, 0 )[GRN] = sum[GRN];
				Dst( dst_x, 0 )[BLU] = sum[BLU];
				}
			}

		--src_x;
		goto ecxloop;
		}
	else if ( !x_compress && !y_compress )
		{
		register int	src_x, src_y;	/* source pixel coords. */
		register int	dst_x, dst_y;	/* dest. rect. pixel coords. */
		register int	bot_x, bot_y;	/* dest. rect. lower bounds */
		register int	top_x, top_y;	/* dest. rect. upper bounds */

		assert(dst_width >= src_width);	/* (thus no right margin) */

		/* Compute coords. of source and destination rectangles. */

		src_y = (dst_height - 1) / y_scale + EPSILON;
    eeyloop:
		if ( src_y < 0 )
			goto done;	/* that's all folks */

		bot_y = src_y * y_scale + EPSILON;

		if ( (top_y = (src_y + 1) * y_scale + EPSILON) > dst_height )
			top_y = dst_height;

		assert(0 <= src_y && src_y <= bot_y && src_y < src_height);
		assert(bot_y < top_y && top_y <= dst_height);
		assert(top_y - bot_y <= (int)(y_scale + 1 - EPSILON));

		/* Fill input scan line buffer. */
		if ( fb_read( src_fbp, 0, src_y, (unsigned char *)Src( 0, 0 ),
			      src_width
			    ) == -1
		   )
			Fatal( "Error reading scan line" );

		src_x = (dst_width - 1) / x_scale + EPSILON;
    eexloop:
		if ( src_x < 0 )
			{
			/* End of band; flush buffer. */

			for ( dst_y = top_y; --dst_y >= bot_y; )
				if ( fb_write( dst_fbp, 0, dst_y,
					       (unsigned char *)Dst( 0, dst_y - bot_y
							      ),
					       dst_width
					     ) == -1
				   )
					Fatal( "Error writing scan line" );

			--src_y;
			goto eeyloop;
			}

		bot_x = src_x * x_scale + EPSILON;

		if ( (top_x = (src_x + 1) * x_scale + EPSILON) > dst_width )
			top_x = dst_width;

		assert(0 <= src_x && src_x <= bot_x && src_x <= src_width);
		assert(bot_x < top_x && top_x <= dst_width);
		assert(top_x - bot_x <= (int)(x_scale + 1 - EPSILON));

		/* Replicate sample source pixel to destination. */

		for ( dst_y = top_y - bot_y; --dst_y >= 0; )
			for ( dst_x = top_x; --dst_x >= bot_x; )
				{
				Dst( dst_x, dst_y )[RED] = Src( src_x, 0 )[RED];
				Dst( dst_x, dst_y )[GRN] = Src( src_x, 0 )[GRN];
				Dst( dst_x, dst_y )[BLU] = Src( src_x, 0 )[BLU];
				}

		--src_x;
		goto eexloop;
		}

    done:
	/* Close the frame buffers. */

	assert(src_fbp != FBIO_NULL && dst_fbp != FBIO_NULL);

	if ( fb_close( src_fbp ) == -1 )
		Message( "Error closing input frame buffer" );

	if ( dst_fbp != src_fbp && fb_close( dst_fbp ) == -1 )
		Message( "Error closing output frame buffer" );

	exit( EXIT_SUCCESS );
	}
@


11.7
log
@change conf.h to a wrapped config.h
@
text
@d59 1
a59 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/fb/fbstretch.c,v 11.6 2004/04/05 07:49:23 morrison Exp $ (BRL)";
@


11.6
log
@merge of ansi-6-0-branch into HEAD
@
text
@d59 1
a59 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d67 5
a71 1
#include "conf.h"
@


11.5
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d59 1
a59 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/fbstretch.c,v 11.3 2001/08/10 21:27:04 butler Exp $ (BRL)";
d124 2
a125 3
Simple( path )
	char		*path;
	{
d134 2
a135 4
VMessage( format, ap )
	char	*format;
	va_list	ap;
	{
d214 2
a215 3
Sig_Catcher( sig )
	int	sig;
	{
d224 2
a225 4
main( argc, argv )
	int	argc;
	char	*argv[];
	{
@


11.5.2.1
log
@Initial ANSIfication
@
text
@d59 1
a59 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/fbstretch.c,v 11.5 2002/08/20 17:07:25 jra Exp $ (BRL)";
d124 3
a126 2
Simple(char *path)
{
d135 4
a138 2
VMessage(char *format, va_list ap)
{
d217 3
a219 2
Sig_Catcher(int sig)
{
d228 4
a231 2
main(int argc, char **argv)
{
@


11.4
log
@Converted from K&R to ANSI C - RFH
@
text
@d124 3
a126 2
Simple(char *path)
{
d135 4
a138 2
VMessage(char *format, va_list ap)
{
d217 3
a219 2
Sig_Catcher(int sig)
{
d228 4
a231 2
main(int argc, char **argv)
{
@


11.3
log
@Misc compiler warning fixes
@
text
@d59 1
a59 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fb/fbstretch.c,v 11.2 2001/04/12 17:44:08 bparker Exp $ (BRL)";
d124 2
a125 3
Simple( path )
	char		*path;
	{
d134 2
a135 4
VMessage( format, ap )
	char	*format;
	va_list	ap;
	{
d214 2
a215 3
Sig_Catcher( sig )
	int	sig;
	{
d224 2
a225 4
main( argc, argv )
	int	argc;
	char	*argv[];
	{
@


11.2
log
@*- get rid of warnings
@
text
@d59 1
a59 2
static char	RCSid[] =		/* for "what" utility */
	"@@(#)$Header: /c/CVS/brlcad/fb/fbstretch.c,v 11.1 1995/01/04 10:09:31 mike Rel4_4 $ (BRL)";
@


11.1
log
@Release_4.4
@
text
@d60 1
a60 1
	"@@(#)$Header: /m/cad/fb/RCS/fbstretch.c,v 10.4 94/11/14 22:27:35 mike Exp $ (BRL)";
d365 1
a365 1
	if ( x_scale < 0.0 )
d370 1
d372 1
a372 1
	if ( y_scale < 0.0 )
d377 1
d422 1
a422 1
		  || dst_file != NULL && strcmp( src_file, dst_file ) == 0
@


10.4
log
@Irix 6
@
text
@d60 1
a60 1
	"@@(#)$Header: /m/cad/fb/RCS/fbstretch.c,v 10.3 94/08/23 18:49:09 gdurf Exp Locker: mike $ (BRL)";
@


10.3
log
@Added includes, factored ifdefs
@
text
@d60 1
a60 1
	"@@(#)$Header: /m/cad/fb/RCS/fbstretch.c,v 10.2 1994/08/11 15:06:12 mike Exp gdurf $ (BRL)";
a119 1
static RGBpixel	bg = { 0, 0, 0 };	/* background */
@


10.2
log
@Reduced use of RGBpixel
Now use (unsigned char *)
@
text
@d60 1
a60 1
	"@@(#)$Header: /m/cad/fb/RCS/fbstretch.c,v 10.1 91/10/12 06:46:36 mike Rel4_0 Locker: mike $ (BRL)";
d68 1
a68 8
#ifdef BSD	/* BRL-CAD */
#define	NO_VFPRINTF	1
#define	NO_STRRCHR	1
#endif

#if defined(sgi) && !defined(mips)	/* Not all SYSVs are perfect */
#define	NO_VFPRINTF	1
#endif
d76 3
a78 1
#ifdef BSD
a79 2
#else
#include	<string.h>
d81 1
a81 4
#include "machine.h"
#include "externs.h"

#if __STDC__
d87 4
a96 4
extern char	*optarg;
extern int	optind;

#include "fb.h"			/* BRL CAD package libfb.a interface */
d142 1
a142 1
#ifdef NO_VFPRINTF
d157 1
a157 1
#if __STDC__
d166 1
a166 1
#if !__STDC__
d171 1
a171 1
#if __STDC__
d182 1
a182 1
#if __STDC__
d191 1
a191 1
#if !__STDC__
d196 1
a196 1
#if __STDC__
a529 7
#if __STDC__
				if ( fb_write( dst_fbp, 0, dst_y,
					       Dst( 0, 0 ),
					       dst_width
					     ) == -1
				   )
#else
a534 1
#endif
a546 7
#if __STDC__
			if ( fb_read( src_fbp, 0, src_y,
				      Src( 0, src_y - bot_y ),
				      src_width
				    ) == -1
			   )
#else
a551 1
#endif
a567 7
#if __STDC__
			if ( fb_write( dst_fbp, 0, dst_y,
				       Dst( 0, 0 ),
				       dst_width
				     ) == -1
			   )
#else
a572 1
#endif
a658 6
#if __STDC__
		if ( fb_read( src_fbp, 0, src_y, Src( 0, 0 ),
			      src_width
			    ) == -1
		   )
#else
a662 1
#endif
a679 7
#if __STDC__
				if ( fb_write( dst_fbp, 0, dst_y,
					       Dst( 0, dst_y - bot_y ),
					       dst_width
					     ) == -1
				   )
#else
a685 1
#endif
a773 7
#if __STDC__
				if ( fb_write( dst_fbp, 0, dst_y,
					       Dst( 0, 0 ),
					       dst_width
					     ) == -1
				   )
#else
a778 1
#endif
a790 7
#if __STDC__
			if ( fb_read( src_fbp, 0, src_y,
				      Src( 0, src_y - bot_y ),
				      src_width
				    ) == -1
			   )
#else
a795 1
#endif
a802 8

#if __STDC__
			if ( fb_write( dst_fbp, 0, dst_y,
				       Dst( 0, 0 ),
				       dst_width
				     ) == -1
			   )
#else
a807 1
#endif
a889 7

#if __STDC__
		if ( fb_read( src_fbp, 0, src_y, Src( 0, 0 ),
			      src_width
			    ) == -1
		   )
#else
a893 1
#endif
a902 7
#if __STDC__
				if ( fb_write( dst_fbp, 0, dst_y,
					       Dst( 0, dst_y - bot_y ),
					       dst_width
					     ) == -1
				   )
#else
a908 1
#endif
@


10.1
log
@Release_4.0
@
text
@d60 1
a60 1
	"@@(#)$Header: /m/cad/fb/RCS/fbstretch.c,v 9.5 91/08/31 07:29:47 mike Exp $ (BRL)";
d131 2
a132 2
static RGBpixel	*src_buf;		/* calloc()ed input scan line buffer */
static RGBpixel	*dst_buf;		/* calloc()ed output scan line buffer */
d464 1
a464 1
	if ( (src_buf = (RGBpixel *)calloc(
d470 1
a470 1
	  || (dst_buf = (RGBpixel *)calloc(
d479 2
a480 2
#define	Src( x, y )	src_buf[(x) + src_width * (y)]
#define	Dst( x, y )	dst_buf[(x) + dst_width * (y)]
d542 1
a542 1
					       &Dst( 0, 0 ),
d548 1
a548 1
					       (RGBpixel *)Dst( 0, 0 ),
d567 1
a567 1
				      &Src( 0, src_y - bot_y ),
d573 1
a573 1
				      (RGBpixel *)Src( 0, src_y - bot_y ),
d596 1
a596 1
				       &Dst( 0, 0 ),
d602 1
a602 1
				       (RGBpixel *)Dst( 0, 0 ),
d694 1
a694 1
		if ( fb_read( src_fbp, 0, src_y, &Src( 0, 0 ),
d699 1
a699 1
		if ( fb_read( src_fbp, 0, src_y, (RGBpixel *)Src( 0, 0 ),
d723 1
a723 1
					       &Dst( 0, dst_y - bot_y ),
d729 1
a729 1
					       (RGBpixel *)Dst( 0, dst_y - bot_y
d825 1
a825 1
					       &Dst( 0, 0 ),
d831 1
a831 1
					       (RGBpixel *)Dst( 0, 0 ),
d850 1
a850 1
				      &Src( 0, src_y - bot_y ),
d856 1
a856 1
				      (RGBpixel *)Src( 0, src_y - bot_y ),
d871 1
a871 1
				       &Dst( 0, 0 ),
d877 1
a877 1
				       (RGBpixel *)Dst( 0, 0 ),
d966 1
a966 1
		if ( fb_read( src_fbp, 0, src_y, &Src( 0, 0 ),
d971 1
a971 1
		if ( fb_read( src_fbp, 0, src_y, (RGBpixel *)Src( 0, 0 ),
d987 1
a987 1
					       &Dst( 0, dst_y - bot_y ),
d993 1
a993 1
					       (RGBpixel *)Dst( 0, dst_y - bot_y
@


9.5
log
@Converted to externs.h
@
text
@d60 1
a60 1
	"@@(#)$Header: /m/cad/fb/RCS/fbstretch.c,v 9.4 90/03/02 15:44:23 gwyn Exp $ (BRL)";
@


9.4
log
@allow for Irix compiler problems
@
text
@d60 1
a60 1
	"@@(#)$Header: fbstretch.c,v 9.3 90/03/02 15:01:08 gwyn Exp $ (BRL)";
d88 3
a92 4
#include	<stdlib.h>
#if __STDC__ == 1	/* workaround for Cray nonsense */
extern int	getopt( int, char const * const *, char const * );
#endif
a93 3
#ifdef NO_STRRCHR
#define	strrchr( s, c )	rindex( s, c )
#endif
a94 4
extern void	exit();
extern char	*calloc(), *getenv();
extern int	atoi(), getopt();
extern double	atof();
d96 1
d106 1
a106 1
#include	<fb.h>			/* BRL CAD package libfb.a interface */
d141 2
a142 1
	return (s = strrchr( path, '/' )) == NULL || *++s == '\0' ? path : s;
@


9.3
log
@apply previous fix only for __STDC__.  Damned RGBpixels!
@
text
@d60 1
a60 1
	"@@(#)$Header: fbstretch.c,v 9.2 90/03/02 14:41:41 gwyn Locked $ (BRL)";
d547 5
a551 1
				if ( fb_write( dst_fbp, 0, dst_y, &Dst( 0, 0 ),
d553 2
a554 2
				if ( fb_write( dst_fbp, 0, dst_y, Dst( 0, 0 ),
#endif
d558 1
d571 1
d573 4
a576 2
#if __STDC__
				      &Src( 0, src_y - bot_y ), src_width
d578 3
a580 2
				      Src( 0, src_y - bot_y ), src_width
#endif
d583 1
d601 5
a605 1
			if ( fb_write( dst_fbp, 0, dst_y, &Dst( 0, 0 ),
d607 2
a608 2
			if ( fb_write( dst_fbp, 0, dst_y, Dst( 0, 0 ),
#endif
d612 1
d700 4
a703 1
		if ( fb_read( src_fbp, 0, src_y, &Src( 0, 0 ), src_width ) == -1
d705 4
a708 1
		if ( fb_read( src_fbp, 0, src_y, Src( 0, 0 ), src_width ) == -1
a709 1
		   )
d727 1
a728 1
#if __STDC__
d730 3
d734 3
a736 2
					       Dst( 0, dst_y - bot_y ),
#endif
d740 1
d830 5
a834 1
				if ( fb_write( dst_fbp, 0, dst_y, &Dst( 0, 0 ),
d836 2
a837 2
				if ( fb_write( dst_fbp, 0, dst_y, Dst( 0, 0 ),
#endif
d841 1
d854 1
d856 4
a859 2
#if __STDC__
				      &Src( 0, src_y - bot_y ), src_width
d861 3
a863 2
				      Src( 0, src_y - bot_y ), src_width
#endif
d866 1
d876 5
a880 1
			if ( fb_write( dst_fbp, 0, dst_y, &Dst( 0, 0 ),
d882 2
a883 2
			if ( fb_write( dst_fbp, 0, dst_y, Dst( 0, 0 ),
#endif
d887 1
d972 4
a975 1
		if ( fb_read( src_fbp, 0, src_y, &Src( 0, 0 ), src_width ) == -1
d977 4
a980 1
		if ( fb_read( src_fbp, 0, src_y, Src( 0, 0 ), src_width ) == -1
a981 1
		   )
d991 1
a992 1
#if __STDC__
d994 3
d998 3
a1000 2
					       Dst( 0, dst_y - bot_y ),
#endif
d1004 1
@


9.2
log
@fixed indirection level error in use of Dst and Src macros
@
text
@d60 1
a60 1
	"@@(#)$Header: fbstretch.c,v 9.1 89/05/19 06:09:14 gwyn Locked $ (BRL)";
d546 1
d548 3
d567 1
d569 3
d590 1
d592 3
d684 1
d686 3
d708 1
d710 3
d804 1
d806 3
d825 1
d827 3
d840 1
d842 3
d931 1
d933 3
d947 1
d949 3
@


9.1
log
@Release_3.5
@
text
@d60 1
a60 1
	"@@(#)$Header: fbstretch.c,v 1.7 89/05/08 17:51:25 phil Exp $ (BRL)";
d546 1
a546 1
				if ( fb_write( dst_fbp, 0, dst_y, Dst( 0, 0 ),
d563 1
a563 1
				      Src( 0, src_y - bot_y ), src_width
d582 1
a582 1
			if ( fb_write( dst_fbp, 0, dst_y, Dst( 0, 0 ),
d672 1
a672 1
		if ( fb_read( src_fbp, 0, src_y, Src( 0, 0 ), src_width ) == -1
d692 1
a692 1
					       Dst( 0, dst_y - bot_y ),
d784 1
a784 1
				if ( fb_write( dst_fbp, 0, dst_y, Dst( 0, 0 ),
d801 1
a801 1
				      Src( 0, src_y - bot_y ), src_width
d812 1
a812 1
			if ( fb_write( dst_fbp, 0, dst_y, Dst( 0, 0 ),
d899 1
a899 1
		if ( fb_read( src_fbp, 0, src_y, Src( 0, 0 ), src_width ) == -1
d911 1
a911 1
					       Dst( 0, dst_y - bot_y ),
@


1.7
log
@redid string[s].h fix!
@
text
@d60 1
a60 1
	"@@(#)$Header: fbstretch.c,v 1.6 89/05/08 17:18:04 phil Locked $ (BRL)";
@


1.6
log
@*** empty log message ***
@
text
@d60 1
a60 1
	"@@(#)$Header: fbstretch.c,v 1.2 89/04/26 20:09:10 gwyn Locked $ (BRL)";
d83 3
d87 1
@


1.5
log
@string[s] and getopt portability
@
text
@d60 1
a60 1
	"@@(#)$Header: fbstretch.c,v 1.4 89/05/04 05:23:25 phil Locked $ (BRL)";
a82 3
#ifdef BSD
#include	<strings.h>
#else
a83 1
#endif
d87 1
a87 1
#ifndef CRAY	/* CRAY defines getopt in stdlib.h! */
d90 1
a90 1
#else /* !__STDC__ */
d99 1
a99 1
#endif /* !__STDC__ */
@


1.4
log
@*** empty log message ***
@
text
@d60 1
a60 1
	"@@(#)$Header: fbstretch.c,v 1.2 89/04/26 20:09:10 gwyn Locked $ (BRL)";
d83 3
d87 1
d91 1
d93 2
a94 1
#else
d103 1
a103 1
#endif
@


1.3
log
@*** empty log message ***
@
text
@d381 1
a381 1
			
d404 1
a404 1
		Fatal( "Couldn't open input frame buffer" );
d406 1
a406 2
		register int	wt = fb_getwidth( src_fbp );
		register int	ht = fb_getheight( src_fbp );
d408 1
a408 1
		/* Use smaller input image size instead of 512/1024. */
d410 1
a410 1
		if ( wt < src_width )
d413 1
a413 1
		if ( ht < src_height )
a417 1
		}
a418 11
	if ( src_file == NULL
	  || dst_file != NULL && strcmp( src_file, dst_file ) == 0
	   )	{
		dst_width = src_width;	/* don't try to change existing size */
		dst_height = src_height;

		dst_fbp = src_fbp;	/* use same f.b. for input & output */
		}
	else	{
		register int	wt, ht;

d430 2
a431 2
		if ( (dst_fbp = fb_open( dst_file, dst_width, dst_height ))
		  == FBIO_NULL
d433 4
d451 1
a451 1
		}
@


1.2
log
@SGI 3-d machines do not have vfprintf()
@
text
@d4 1
a4 1
	created:	89/04/26	D A Gwyn
d24 2
a25 1
	-h		assumes 1024x1024 frame buffer instead of 512x512
d27 2
a28 1
	-s		samples for compression instead of averaging pixels
d30 1
a30 1
	-x x_scale	horizontal scaling factor (default 1.0)
d32 1
a32 1
	-y y_scale	vertical scaling factor (default 1.0)
d34 1
a34 1
	-i in_fb	reads from the specified frame buffer file instead
d38 1
a38 1
	-f out_fb	writes to the specified frame buffer file instead
d42 1
a42 1
	-F out_fb	same as -f out_fb (BRL-CAD package compatibility)
d44 13
a56 1
	out_fb		same as -f out_fb, for convenience
d59 2
a60 2
static char	SCCSid[] = "%W% %E%";	/* for "what" utility */
static char RCSid[] = "@@(#)$Header: fbstretch.c,v 1.1 89/04/26 19:20:57 mike Locked $ (BRL)";
d63 4
a66 3
#define	USAGE	\
       "fbstretch [ -h ] [ -s ] [ -x x_sc ] [ -y y_sc ] [ -i in_fb ] [ out_fb ]"
#define	OPTSTR	"hsx:y:i:f:F:"
d95 1
a95 1
extern int	getopt();
d118 3
a120 2
static float	x_scale = 1;		/* horizontal scaling factor */
static float	y_scale = 1;		/* vertical scaling factor */
d127 4
a130 2
static int	src_width, src_height;	/* source image size */
static int	dst_width, dst_height;	/* destination image size */
d155 3
a157 1
		       ((int *)ap)[2], ((int *)ap)[3]
d273 1
a273 2
			default:	/* just in case */
			case '?':	/* invalid option */
d277 12
d293 4
a296 2
			case 's':	/* -s */
				sample = true;
d299 38
d343 1
a351 1
				break;
a352 2
			case 'i':	/* -i in_fb */
				src_file = optarg;
a353 5

			case 'f':	/* -f out_fb */
			case 'F':	/* -F out_fb */
				dst_file = optarg;
				break;
d357 1
a357 1
			Fatal( "Usage: %s", USAGE );
d364 1
a364 1
			Message( "Usage: %s", USAGE );
d374 17
d393 2
a394 1
	src_width = src_height = hires ? 1024 : 512;	/* starting default */
d396 3
d405 3
d409 1
a409 1
	/* Use actual input size in preference to 512/1024 default. */
d411 2
a412 5
	src_width = fb_getwidth( src_fbp );
	src_height = fb_getheight( src_fbp );
#ifdef DEBUG
	Message( "Source image %dx%d", src_width, src_height );
#endif
d414 7
d424 1
a424 1
		dst_width = src_width;	/* don't try to change the image size */
d430 1
a430 5
		dst_width = src_width * x_scale + EPSILON;
		dst_height = src_height * y_scale + EPSILON;
#ifdef DEBUG
		Message( "Requested output size %dx%d", dst_width, dst_height );
#endif
d432 11
d448 1
a448 1
		/* Use actual output size in preference to requested size. */
d450 10
a459 5
		dst_width = fb_getwidth( dst_fbp );
		dst_height = fb_getheight( dst_fbp );
#ifdef DEBUG
		Message( "Destination image %dx%d", dst_width, dst_height );
#endif
d469 2
a470 1
	   arranged so that source and destination can access the same image.
@


1.1
log
@Initial revision
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: pix-fb.c,v 8.2 89/04/11 22:15:25 phil Exp $ (BRL)";
d56 4
@
