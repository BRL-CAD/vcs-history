head	11.10;
access;
symbols
	ansi-20040405-merged:11.6.2.2
	postmerge-20040405-ansi:11.8
	premerge-20040404-ansi:11.7
	postmerge-autoconf:11.7
	autoconf-freeze:11.6.10.2
	premerge-autoconf:11.7
	ansi-20040316-freeze:11.6.2.1
	postmerge-20040315-windows:11.7
	premerge-20040315-windows:11.7
	windows-20040315-freeze:11.6.4.1
	autoconf-20031203:11.6
	autoconf-20031202:11.6
	autoconf-branch:11.6.0.10
	phong-branch:11.6.0.8
	photonmap-branch:11.6.0.6
	rel-6-1-DP:11.6
	windows-branch:11.6.0.4
	rel-6-0-2:11.4
	ansi-branch:11.6.0.2
	rel-6-0-1-branch:11.4.0.2
	hartley-6-0-post:11.5
	hartley-6-0-pre:11.4
	rel-6-0-1:11.4
	rel-6-0:11.4
	rel-5-4:11.1
	offsite-5-3-pre:11.2
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:5.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.10
date	2004.05.24.04.13.26;	author morrison;	state dead;
branches;
next	11.9;

11.9
date	2004.05.10.15.30.42;	author erikg;	state Exp;
branches;
next	11.8;

11.8
date	2004.04.05.07.49.23;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2004.02.02.17.39.01;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	2002.08.20.17.07.25;	author jra;	state Exp;
branches
	11.6.2.1
	11.6.4.1
	11.6.10.1;
next	11.5;

11.5
date	2002.08.15.20.54.38;	author hartley;	state Exp;
branches;
next	11.4;

11.4
date	2001.08.10.21.27.04;	author butler;	state Exp;
branches;
next	11.3;

11.3
date	2001.04.12.17.44.08;	author bparker;	state Exp;
branches;
next	11.2;

11.2
date	2000.08.24.03.58.33;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.09.37;	author mike;	state Rel4_4;
branches;
next	10.5;

10.5
date	94.11.14.22.28.18;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.08.23.18.49.14;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	94.08.11.15.06.15;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.03.16.21.34.51;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.46.42;	author mike;	state Rel4_0;
branches;
next	9.4;

9.4
date	91.07.22.21.46.23;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	91.06.18.14.42.53;	author mmark;	state Exp;
branches;
next	9.2;

9.2
date	91.01.11.04.39.08;	author butler;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.09.43;	author mike;	state Rel3_5;
branches;
next	8.1;

8.1
date	88.10.05.00.42.16;	author mike;	state Rel3_0;
branches;
next	7.4;

7.4
date	88.08.28.01.41.02;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.08.05.11.05.45;	author steveb;	state Exp;
branches;
next	7.2;

7.2
date	88.05.16.00.07.09;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.09.34;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.13.00;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.43.59;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.13.00.50.46;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.14.12;	author mike;	state Rel1;
branches;
next	1.17;

1.17
date	86.11.24.18.43.44;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	86.11.13.02.59.11;	author phil;	state Exp;
branches;
next	1.15;

1.15
date	86.10.27.04.13.09;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	86.10.21.22.56.01;	author phil;	state Exp;
branches;
next	1.13;

1.13
date	86.10.06.21.08.48;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	86.10.03.06.14.34;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	86.10.03.04.52.42;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	86.08.13.05.21.58;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	86.08.13.03.17.39;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	86.08.13.03.17.32;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	86.08.13.03.17.25;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	86.08.13.03.17.18;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	86.08.13.03.17.11;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	86.08.13.03.17.02;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	86.08.13.03.16.53;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.08.13.03.16.46;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.08.13.03.16.42;	author mike;	state Exp;
branches;
next	;

11.6.2.1
date	2002.09.19.18.00.42;	author morrison;	state Exp;
branches;
next	11.6.2.2;

11.6.2.2
date	2004.03.17.21.16.08;	author morrison;	state Exp;
branches;
next	;

11.6.4.1
date	2004.03.11.23.40.44;	author morrison;	state Exp;
branches;
next	;

11.6.10.1
date	2004.02.12.19.40.46;	author erikg;	state Exp;
branches;
next	11.6.10.2;

11.6.10.2
date	2004.03.15.13.28.06;	author erikg;	state Exp;
branches;
next	;


desc
@@


11.10
log
@moved to src/fb/
@
text
@/*
 *			O R L E - F B . C
 *
 *  Display an old RLE format image on a framebuffer
 *
 *  Author -
 *	Gary S. Moss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Id: orle-fb.c,v 11.9 2004/05/10 15:30:42 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "machine.h"
#include "externs.h"			/* For getopt() */
#include "fb.h"
#include "orle.h"

static char	*usage[] =
	{
"Usage: orle-fb [-Otdv] [-b (rgbwBG)] [-F Frame_buffer] [-p X Y] [file.rle]",
"",
"If no rle file is specifed, rle-fb will read its standard input.",
"If the environment variable FB_FILE is set, its value will be used",
"	to specify the framebuffer file or device to write to.",
0
	};

static FBIO	*fbp;
static FILE	*fp;
static RGBpixel	bgpixel;
static int	bgflag = 0;
static int	olflag = 0;
static int	pars_Argv(int argc, register char **argv);
static int	xlen = -1, ylen = -1;
static int	xpos = -1, ypos = -1;
static void	prnt_Cmap(ColorMap *cmap);
static void	prnt_Usage(void);
static int	width = 512;
static int	height = 512;
static int	topdown = 0;
static int	pixels_per_buffer;
static char	*fb_file = (char *)NULL;

void		fill_Buffer(register char *dest, register char *src, register int scan_bytes, register int repeat);

/*	m a i n ( )							*/
int
main(int argc, char **argv)
{	register int	y;
		register int	lines_per_buffer;
		register unsigned char *scanbuf;
		static RGBpixel	bg_scan[8192+1];
		static ColorMap	cmap;
		int		get_flags;

	fp = stdin;
	if( ! pars_Argv( argc, argv ) || isatty(fileno(fp)) )
		{
		prnt_Usage();
		return	1;
		}
	if( bgflag )  {
		/* User has supplied his own background */
		if( rle_rhdr( fp, &get_flags, RGBPIXEL_NULL ) == -1 )
			return 1;
	} else {
		if( rle_rhdr( fp, &get_flags, bgpixel ) == -1 )
		return	1;
	}

	rle_rlen( &xlen, &ylen );
	if( xpos < 0 || ypos < 0 )
		rle_rpos( &xpos, &ypos );
	else
		rle_wpos( xpos, ypos, 0 );

	/* Automatic selection of high res. device.			*/
	if( xpos + xlen > 512 || ypos + ylen > 512 )
		width = height = 1024;
	if( xpos + xlen > width )
		xlen = width - xpos;
	if( ypos + ylen > height )
		ylen = height - ypos;
	rle_wlen( xlen, ylen, 0 );

	if( (fbp = fb_open( fb_file, width, height )) == NULL )  {
		exit(12);
	}

	if( topdown )
		pixels_per_buffer = width * height;
	else
		pixels_per_buffer = width * 64;
	scanbuf = RGBPIXEL_NULL;
	while( scanbuf == RGBPIXEL_NULL && pixels_per_buffer > 0 )  {
		scanbuf = (unsigned char *)malloc(pixels_per_buffer*sizeof(RGBpixel));
		if( scanbuf == RGBPIXEL_NULL )  {
			pixels_per_buffer >>= 1;
			continue;
		}
		break;
	}
	if( scanbuf == RGBPIXEL_NULL )  {
		fprintf(stderr," rle-fb:  unable to malloc pixel buffer\n");
		return(1);
	}

	lines_per_buffer = pixels_per_buffer / width;	/* # of full scanlines in buffer */
	pixels_per_buffer = lines_per_buffer * width;

	if( rle_verbose )
		(void) fprintf( stderr,
				"Background is %d %d %d\n",
				bgpixel[RED], bgpixel[GRN], bgpixel[BLU]
				);

	/* If color map provided, use it, else go with standard map. */
	if( ! (get_flags & NO_COLORMAP) )
		{
		if( rle_verbose && ! olflag )
			(void) fprintf( stderr,
					"Loading saved color map from file\n"
					);
		if( rle_rmap( fp, &cmap ) == -1 )
			return	1;
		if( rle_verbose )
			prnt_Cmap( &cmap );
		if( ! olflag )
			{
			/* User-supplied map */
			if( rle_verbose )
				(void) fprintf( stderr,
					"Writing color map to framebuffer\n"
						);
			if( fb_wmap( fbp, &cmap ) == -1 )
				return	1;
			}
		}
	else
	if( ! olflag )
		{
		if( rle_verbose )
			(void) fprintf( stderr,
					"Creating standard color map\n"
					);
		if( fb_wmap( fbp, COLORMAP_NULL ) == -1 )
			return	1;
		}
	/* Fill a DMA buffer buffer with background */
	if( ! olflag && (get_flags & NO_BOX_SAVE) )
		{	register int	i;
			register RGBpixel	*to;
		to = bg_scan;
		for( i = 0; i < width; i++,to++ )  {
			COPYRGB( *to, bgpixel );
			}
		}

#ifndef SIMPLE
	{	register int	page_fault = 1;
		register int	dirty_flag = 1;
		int		ymax = ypos + (ylen-1);
		int		start_y = 0;
	for( y = 0; y < width; y++ )  {
		if( page_fault )  {
			start_y = y;
			if( olflag )  {
				/* Overlay - read cluster from fb.	*/
				if( fb_read( fbp, 0, y, scanbuf, pixels_per_buffer ) == -1 )
					return	1;
			} else
			if( (get_flags & NO_BOX_SAVE) && dirty_flag )
				fill_Buffer(	(char *) scanbuf,
						(char *) bg_scan,
						width*sizeof(RGBpixel),
						lines_per_buffer
						);
			dirty_flag = 0;
			page_fault = 0;
		}
		if( y >= ypos && y <= ymax )  {
			if( rle_decode_ln( fp,
			    scanbuf[(y%lines_per_buffer)*width*sizeof(RGBpixel)] ) == -1 )
				break;		/* not return */
			dirty_flag = 1;
		}
		page_fault = ((y%lines_per_buffer)==(lines_per_buffer-1));
		if( page_fault )  {
			if( fb_write( fbp, 0, start_y, scanbuf, pixels_per_buffer ) == -1 )
				return	1;
		}
	}
	if( page_fault == 0 )  {
		/* Write out the residue, a short buffer */
		if( fb_write( fbp, 0, start_y, scanbuf, (y-start_y)*width ) == -1 )
			return(1);
	}
	} /* end block */
#else
	/* Simplified version, for testing */
	for( y = 0; y < height; y++ )  {
		if( olflag )  {
			/* Overlay - read cluster from fb.	*/
			if( fb_read( fbp, 0, y, scanbuf, width ) == -1 )
				return	1;
		} else {
			if( (get_flags & NO_BOX_SAVE) )
				fill_Buffer(	(char *) scanbuf,
				(char *) bg_scan,
				width*sizeof(RGBpixel),
				1 );
		}
		if( y <= ypos+ylen && y >= ypos )
			if( rle_decode_ln( fp, scanbuf ) == -1 )
				return	1;
		if( fb_write( fbp, 0, y, scanbuf, width ) == -1 )
			return	1;
	}
#endif

	/* Write background pixel in agreed-upon place */
	(void)fb_write( fbp, 1, 1, bgpixel, 1 );

	fb_close( fbp );
	return	0;
	}

/*	f i l l _ B u f f e r ( )
	Fill cluster buffer from scanline (as fast as possible).
 */
void
fill_Buffer(register char *dest, register char *src, register int scan_bytes, register int repeat)
{	register int	i;
	for( i = 0; i < repeat; ++i )
		{
		bcopy( src, dest, scan_bytes );
		dest += scan_bytes;
		}
	return;
	}

/*	p a r s _ A r g v ( )						*/
static int
pars_Argv(int argc, register char **argv)
{	register int	c;
	/* Parse options.						*/
	while( (c = getopt( argc, argv, "tOF:b:dp:v" )) != EOF )
		{
		switch( c )
			{
		case 't':
			/* Top-down mode */
			topdown = 1;
			break;
		case 'O' : /* Overlay mode.				*/
			olflag = 1;
			break;
		case 'b' : /* User-specified background.		*/
			bgflag = optarg[0];
			switch( bgflag )
				{
			case 'r':
				bgpixel[RED] = 255;
				break;
			case 'g':
				bgpixel[GRN] = 255;
				break;
			case 'b':
				bgpixel[BLU] = 255;
				break;
			case 'w':
				bgpixel[RED] =
				bgpixel[GRN] =
				bgpixel[BLU] = 255;
				break;
			case 'B':		/* Black */
				break;
			case 'G':		/* 18% grey, for alignments */
				bgpixel[RED] =
				bgpixel[GRN] =
				bgpixel[BLU] = 255.0 * 0.18;
				break;
			default:
				(void) fprintf( stderr,
						"Background '%c' unknown\n",
						bgflag
						);
				bgflag = 0;
				break;
				} /* End switch */
			break;
		case 'd' :
			rle_debug = 1;
			break;
		case 'p' :
			if( argc - optind < 2 )
				{
				(void) fprintf( stderr,
				"-p option requires an X and Y argument!\n"
						);
				return	0;
				}
			xpos = atoi( optarg );
			ypos = atoi( argv[optind++] );
			break;
		case 'v' :
			rle_verbose = 1;
			break;
		case 'F' : fb_file = optarg;
			break;
		case '?' :
			return	0;
			} /* end switch */
		} /* end while */

	if( argv[optind] != NULL )
		if( (fp = fopen( argv[optind], "r" )) == NULL )
			{
			(void) fprintf( stderr,
					"Can't open %s for reading!\n",
					argv[optind]
					);
			return	0;
			}
	if( argc > ++optind )
		{
		(void) fprintf( stderr, "Too many arguments!\n" );
		return	0;
		}
	return	1;
	}

/*	p r n t _ U s a g e ( )
	Print usage message.
 */
static void
prnt_Usage(void)
{	register char	**p = usage;
	while( *p )
		(void) fprintf( stderr, "%s\n", *p++ );
	return;
	}

static void
prnt_Cmap(ColorMap *cmap)
{	register unsigned short	*cp;
		register int	i;
	(void) fprintf( stderr, "\t\t\t_________ Color map __________\n" );
	(void) fprintf( stderr, "Red segment :\n" );
	for( i = 0, cp = cmap->cm_red; i < 16; ++i, cp += 16 )
		{
		(void) fprintf( stderr,
	"%3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d\n",
	/* 1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16 */
				cp[0],
				cp[1],
				cp[2],
				cp[3],
				cp[4],
				cp[5],
				cp[6],
				cp[7],
				cp[8],
				cp[9],
				cp[10],
				cp[11],
				cp[12],
				cp[13],
				cp[14],
				cp[15]
				);
		}
	(void) fprintf( stderr, "Green segment :\n" );
	for( i = 0, cp = cmap->cm_green; i < 16; ++i, cp += 16 )
		{
		(void) fprintf( stderr, 
	"%3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d\n",
	/* 1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16 */
				cp[0],
				cp[1],
				cp[2],
				cp[3],
				cp[4],
				cp[5],
				cp[6],
				cp[7],
				cp[8],
				cp[9],
				cp[10],
				cp[11],
				cp[12],
				cp[13],
				cp[14],
				cp[15]
				);
		}
	(void) fprintf( stderr, "Blue segment :\n" );
	for( i = 0, cp = cmap->cm_blue; i < 16; ++i, cp += 16 )
		{
		(void) fprintf( stderr,
	"%3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d\n",
	/* 1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16 */
				cp[0],
				cp[1],
				cp[2],
				cp[3],
				cp[4],
				cp[5],
				cp[6],
				cp[7],
				cp[8],
				cp[9],
				cp[10],
				cp[11],
				cp[12],
				cp[13],
				cp[14],
				cp[15]
				);
		}
	return;
	}
@


11.9
log
@change conf.h to a wrapped config.h
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Id: orle-fb.c,v 11.8 2004/04/05 07:49:23 morrison Exp $ (BRL)";
@


11.8
log
@merge of ansi-6-0-branch into HEAD
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Id$ (BRL)";
d22 5
a26 1
#include "conf.h"
@


11.7
log
@update copyright to include span through 2003
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Id: orle-fb.c,v 11.6 2002/08/20 17:07:25 jra Exp $ (BRL)";
d50 1
a50 1
static int	pars_Argv();
d53 2
a54 2
static void	prnt_Cmap();
static void	prnt_Usage();
d61 1
a61 1
void		fill_Buffer();
d65 2
a66 4
main( argc, argv )
int	argc;
char	*argv[];
	{	register int	y;
d249 2
a250 6
fill_Buffer( dest, src, scan_bytes, repeat )
register char	*dest;
register char	*src;
register int	scan_bytes;
register int	repeat;
	{	register int	i;
d261 2
a262 3
pars_Argv( argc, argv )
register char	**argv;
	{	register int	c;
d354 2
a355 2
prnt_Usage()
	{	register char	**p = usage;
d362 2
a363 3
prnt_Cmap( cmap )
ColorMap	*cmap;
	{	register unsigned short	*cp;
@


11.6
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Id: orle-fb.c,v 11.4 2001/08/10 21:27:04 butler Exp $ (BRL)";
@


11.6.4.1
log
@sync to HEAD...
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Id: orle-fb.c,v 11.7 2004/02/02 17:39:01 morrison Exp $ (BRL)";
@


11.6.10.1
log
@merge from HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Id: orle-fb.c,v 11.7 2004/02/02 17:39:01 morrison Exp $ (BRL)";
@


11.6.10.2
log
@merge from head
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Id: orle-fb.c,v 11.6.10.1 2004/02/12 19:40:46 erikg Exp $ (BRL)";
@


11.6.2.1
log
@Initial ANSIfication
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Id: orle-fb.c,v 11.6 2002/08/20 17:07:25 jra Exp $ (BRL)";
d50 1
a50 1
static int	pars_Argv(int argc, register char **argv);
d53 2
a54 2
static void	prnt_Cmap(ColorMap *cmap);
static void	prnt_Usage(void);
d61 1
a61 1
void		fill_Buffer(register char *dest, register char *src, register int scan_bytes, register int repeat);
d65 4
a68 2
main(int argc, char **argv)
{	register int	y;
d251 6
a256 2
fill_Buffer(register char *dest, register char *src, register int scan_bytes, register int repeat)
{	register int	i;
d267 3
a269 2
pars_Argv(int argc, register char **argv)
{	register int	c;
d361 2
a362 2
prnt_Usage(void)
{	register char	**p = usage;
d369 3
a371 2
prnt_Cmap(ColorMap *cmap)
{	register unsigned short	*cp;
@


11.6.2.2
log
@sync branch with HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Id$ (BRL)";
@


11.5
log
@Converted from K&R to ANSI C - RFH
@
text
@d50 1
a50 1
static int	pars_Argv(int argc, register char **argv);
d53 2
a54 2
static void	prnt_Cmap(ColorMap *cmap);
static void	prnt_Usage(void);
d61 1
a61 1
void		fill_Buffer(register char *dest, register char *src, register int scan_bytes, register int repeat);
d65 4
a68 2
main(int argc, char **argv)
{	register int	y;
d251 6
a256 2
fill_Buffer(register char *dest, register char *src, register int scan_bytes, register int repeat)
{	register int	i;
d267 3
a269 2
pars_Argv(int argc, register char **argv)
{	register int	c;
d361 2
a362 2
prnt_Usage(void)
{	register char	**p = usage;
d369 3
a371 2
prnt_Cmap(ColorMap *cmap)
{	register unsigned short	*cp;
@


11.4
log
@Misc compiler warning fixes
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Id: orle-fb.c,v 11.3 2001/04/12 17:44:08 bparker Exp $ (BRL)";
d50 1
a50 1
static int	pars_Argv();
d53 2
a54 2
static void	prnt_Cmap();
static void	prnt_Usage();
d61 1
a61 1
void		fill_Buffer();
d65 2
a66 4
main( argc, argv )
int	argc;
char	*argv[];
	{	register int	y;
d249 2
a250 6
fill_Buffer( dest, src, scan_bytes, repeat )
register char	*dest;
register char	*src;
register int	scan_bytes;
register int	repeat;
	{	register int	i;
d261 2
a262 3
pars_Argv( argc, argv )
register char	**argv;
	{	register int	c;
d354 2
a355 2
prnt_Usage()
	{	register char	**p = usage;
d362 2
a363 3
prnt_Cmap( cmap )
ColorMap	*cmap;
	{	register unsigned short	*cp;
@


11.3
log
@*- get rid of warnings
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Id: orle-fb.c,v 11.2 2000/08/24 03:58:33 mike Exp $ (BRL)";
d182 1
a182 1
		int		start_y;
@


11.2
log
@
const RCSid
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Id: orle-fb.c,v 11.1 1995/01/04 10:09:37 mike Rel4_4 $ (BRL)";
d25 5
d64 1
@


11.1
log
@Release_4.4
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Id: orle-fb.c,v 10.5 94/11/14 22:28:18 mike Exp $ (BRL)";
@


10.5
log
@Irix 6
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Id: orle-fb.c,v 10.4 94/08/23 18:49:14 gdurf Exp Locker: mike $ (BRL)";
@


10.4
log
@Added includes, factored ifdefs
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Id: orle-fb.c,v 10.3 1994/08/11 15:06:15 mike Exp gdurf $ (BRL)";
a43 1
static int	cmflag = 0;
@


10.3
log
@Reduced use of RGBpixel
Now use (unsigned char *)
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Id: orle-fb.c,v 10.2 92/03/16 21:34:51 mike Exp Locker: mike $ (BRL)";
d22 2
d25 2
a253 1
#ifdef BSD
a254 3
#else
		memcpy( dest, src, scan_bytes );
#endif
a264 2
		extern int	optind;
		extern char	*optarg;
@


10.2
log
@IRIX 4.0.1
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Id: orle-fb.c,v 10.1 91/10/12 06:46:42 mike Rel4_0 Locker: mike $ (BRL)";
d61 2
a62 2
		register RGBpixel *scanbuf;
		static RGBpixel	bg_scan[1025];
d106 1
a106 1
		scanbuf = (RGBpixel *)malloc(pixels_per_buffer*sizeof(RGBpixel));
d193 1
a193 1
			    scanbuf[(y%lines_per_buffer)*width] ) == -1 )
@


10.1
log
@Release_4.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Id: /f/cad/util/RCS/orle-fb.c,v 1.1 91/01/03 23:11:36 butler Exp $ (BRL)";
d37 1
a37 1
static FILE	*fp = stdin;
d66 1
@


9.4
log
@Removed unneeded u_char typedef, it bugged the IBM
@
text
@@


9.3
log
@fixed usage msg
@
text
@a25 1
typedef unsigned char	u_char;
@


9.2
log
@adjusted includes to reflect divergence of rle.h and orle.h,
added '-F' option to allow framebuffer specification
@
text
@d29 1
a29 1
"Usage: rle-fb [-Otdv] [-b (rgbwBG)] [-F Frame_buffer] [-p X Y] [file.rle]",
@


9.1
log
@Release_3.5
@
text
@d2 1
a2 1
 *			R L E - F B . C
d4 1
a4 1
 *  Display an RLE image on a framebuffer
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: orle-fb.c,v 8.1 88/10/05 00:42:16 mike Rel3_0 $ (BRL)";
d24 1
a24 1
#include "rle.h"
d29 1
a29 1
"Usage: rle-fb [-Otdv] [-b (rgbwBG)] [-p X Y] [file.rle]",
d52 1
d96 1
a96 1
	if( (fbp = fb_open( NULL, width, height )) == NULL )  {
d268 1
a268 1
	while( (c = getopt( argc, argv, "tOb:dp:v" )) != EOF )
d329 2
@


8.1
log
@Release_3.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: orle-fb.c,v 7.4 88/08/28 01:41:02 mike Exp $ (BRL)";
@


7.4
log
@Added height variable.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rle-fb.c,v 7.3 88/08/05 11:05:45 mike Locked $ (BRL)";
@


7.3
log
@*** empty log message ***
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rle-fb.c,v 7.2 88/05/16 00:07:09 steveb Locked $ (BRL)";
d49 1
d88 1
a88 1
		width = 1024;
d91 2
a92 2
	if( ypos + ylen > width )
		ylen = width - ypos;
d95 1
a95 1
	if( (fbp = fb_open( NULL, width, width )) == NULL )  {
d100 1
a100 1
		pixels_per_buffer = width * width;
d210 1
a210 1
	for( y = 0; y < width; y++ )  {
@


7.2
log
@lint fixes
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rle-fb.c,v 7.1 87/11/03 00:09:34 mike Locked $ (BRL)";
d29 1
a29 1
"Usage: rle-fb [-Otdv] [-b (rgbBG)] [-p X Y] [file.rle]",
@


7.1
log
@Release 2.3
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rle-fb.c,v 6.1 87/07/11 08:13:00 mike Rel $ (BRL)";
d52 2
d239 1
@


6.1
log
@Release 2.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rle-fb.c,v 5.1 87/06/24 22:43:59 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rle-fb.c,v 4.2 87/02/13 00:50:46 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rle-fb.c,v 4.1 86/12/29 03:14:12 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rle-fb.c,v 1.17 86/11/24 18:43:44 mike Exp $ (BRL)";
@


1.17
log
@added topdown option
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rle-fb.c,v 1.16 86/11/13 02:59:11 mike Locked $ (BRL)";
@


1.16
log
@usage message on tty input.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rle-fb.c,v 1.15 86/10/27 04:13:09 phil Locked $ (BRL)";
a25 7
/* Number of pixels to buffer, expressed in hi-res scanlines * nlines */
#ifdef pdp11
#define BUF_PIXELS	(1024*4)
#else
#define BUF_PIXELS	(1024*32)
#endif

d29 1
a29 1
"Usage: rle-fb [-Odv] [-b (rgbBG)] [-p X Y] [file.rle]",
d49 2
d58 1
a58 1
		static RGBpixel	scanbuf[BUF_PIXELS];
a61 1
		int		pixels_per_buffer;
a91 3
	lines_per_buffer = BUF_PIXELS / width;	/* # of full scanlines in buffer */
	pixels_per_buffer = lines_per_buffer * width;

d96 21
d263 1
a263 1
	while( (c = getopt( argc, argv, "Ob:dp:v" )) != EOF )
d267 4
@


1.15
log
@Converted to RGBpixel
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rle-fb.c,v 1.14 86/10/21 22:56:01 phil Exp $ (BRL)";
d69 1
a69 1
	if( ! pars_Argv( argc, argv ) )
@


1.14
log
@bcopy arg botch
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rle-fb.c,v 1.13 86/10/06 21:08:48 phil Locked $ (BRL)";
d26 3
a28 2
#ifndef pdp11
#define MAX_DMA	1024*64
d30 1
a30 1
#define MAX_DMA	1024*16
a31 3
#define DMA_PIXELS	(MAX_DMA/sizeof(Pixel))
#define DMA_SCANS	(DMA_PIXELS/width)
#define PIXEL_OFFSET	((scan_ln%dma_scans)*width)
d46 1
a46 1
static Pixel	bgpixel = { 0, 0, 0, 0 };
d61 4
a64 4
	{	register int	scan_ln;
		register int	dma_scans;
		static Pixel	scans[DMA_PIXELS];
		static Pixel	bg_scan[1025];
d67 1
a67 2
		int		scan_bytes;
		int		dma_pixels;
d74 6
a79 1
	if( rle_rhdr( fp, &get_flags, bgflag ? NULL : &bgpixel ) == -1 )
d81 1
d98 2
a99 3
	dma_pixels = DMA_PIXELS;
	dma_scans = DMA_SCANS;
	scan_bytes = width * sizeof(Pixel);
a101 1
		fprintf(stderr,"fb_open failed\n");
d108 1
a108 1
				bgpixel.red, bgpixel.green, bgpixel.blue
a125 3
"",
"rle-fb (1.9)",
"",
d146 1
a146 2
			register Pixel	*to;
			register Pixel	*from;
d148 3
a150 3
		from = &bgpixel;
		for( i = 0; i < width; i++ )
			*to++ = *from;
d153 1
d156 8
a163 10
		register int	by = dma_scans-1;
		int		btm = ypos + (ylen-1);
		int		top = ypos;
	for( scan_ln = width-1; scan_ln >= 0; scan_ln-- )
		{
		if( page_fault )
			{
			if( olflag )
				{ /* Overlay - read cluster from fb.	*/
				if( fb_read( fbp, 0, by, scans, dma_pixels ) == -1 )
d165 1
a165 2
				}
			else
d167 1
a167 1
				fill_Buffer(	(char *) scans,
d169 2
a170 2
						width*sizeof(Pixel),
						dma_scans
d174 10
a183 5
			}
		if( scan_ln >= top && scan_ln <= btm )
			{	register int
			touched = rle_decode_ln( fp, scans+PIXEL_OFFSET );
			if( touched == -1 )
d185 14
a198 6
			else
				dirty_flag += touched;
			}
		if( page_fault = ! (scan_ln%dma_scans) )
			{
			if( fb_write( fbp, 0, by, scans, dma_pixels ) == -1 )
d200 14
a213 4
			by += dma_scans;
			}
		} /* end for */
	} /* end block */
d216 1
a216 1
	(void)fb_write( fbp, 1, 1, &bgpixel, 1 );
d225 3
a227 3
fill_Buffer( buff_p, scan_p, scan_bytes, dma_scans )
register char	*buff_p;
register char	*scan_p;
d229 1
a229 1
register int	dma_scans;
d231 1
a231 1
	for( i = 0; i < dma_scans; ++i )
d234 1
a234 1
		bcopy( (char *)scan_p, (char *)buff_p, scan_bytes );
d236 1
a236 1
		memcpy( (char *)scan_p, (char *)buff_p, scan_bytes );
d238 1
a238 1
		buff_p += scan_bytes;
d263 1
a263 1
				bgpixel.red = 255;
d266 1
a266 1
				bgpixel.green = 255;
d269 1
a269 1
				bgpixel.blue = 255;
d272 3
a274 3
				bgpixel.red =
				bgpixel.green =
				bgpixel.blue = 255;
d279 3
a281 3
				bgpixel.red =
				bgpixel.green =
				bgpixel.blue = 255.0 * 0.18;
@


1.13
log
@Converted to new libfb with 1st Quadrant semantics
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rle-fb.c,v 1.12 86/10/03 06:14:34 mike Exp $ (BRL)";
d216 1
a216 1
		bcopy( (char *)buff_p, (char *)scan_p, scan_bytes );
@


1.12
log
@Added fb_close
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d38 1
a39 4
"rle-fb (1.9)",
"",
"Usage: rle-fb [-Odv][-b (rgbBG)][-p X Y][file.rle]",
"",
d125 3
d145 1
a145 1
	/* Fill buffer with background.					*/
d158 1
a158 1
		register int	by = width - dma_scans;
d192 1
a192 1
			by -= dma_scans;
d196 4
@


1.11
log
@Modified for new libfb calling sequences.
@
text
@d2 15
a16 10
	SCCS id:	@@(#) rle-fb.c	1.9
	Last edit: 	2/4/86 at 16:38:20
	Retrieved: 	8/13/86 at 03:17:36
	SCCS archive:	/m/cad/fb_utils/RCS/s.rle-fb.c

	Author:		Gary S. Moss
			U. S. Army Ballistic Research Laboratory
			Aberdeen Proving Ground
			Maryland 21005
			(301)278-6647 or AV-283-6647
d18 2
a19 3
#if ! defined( lint )
static
char	sccsTag[] = "@@(#) rle-fb.c	1.9	last edit 2/4/86 at 16:38:20";
d196 1
@


1.10
log
@Updated #includes for new conventions
@
text
@d28 2
a29 2
#define DMA_SCANS	(DMA_PIXELS/_fbsize)
#define PIXEL_OFFSET	((scan_ln%dma_scans)*_fbsize)
d45 1
d56 1
d87 5
a91 5
		fbsetsize( 1024 );
	if( xpos + xlen > _fbsize )
		xlen = _fbsize - xpos;
	if( ypos + ylen > _fbsize )
		ylen = _fbsize - ypos;
d96 1
a96 3
	scan_bytes = _fbsize * sizeof(Pixel);
	if( fbopen( NULL, CREATE ) == -1 )
		return	1;
d98 5
d127 1
a127 1
			if( fb_wmap( &cmap ) == -1 )
d138 1
a138 1
		if( fb_wmap( (ColorMap *) NULL ) == -1 )
d148 1
a148 1
		for( i = 0; i < _fbsize; i++ )
d154 1
a154 1
		register int	by = _fbsize - dma_scans;
d157 1
a157 1
	for( scan_ln = _fbsize-1; scan_ln >= 0; scan_ln-- )
d163 1
a163 1
				if( fbread( 0, by, scans, dma_pixels ) == -1 )
d170 1
a170 1
						_fbsize*sizeof(Pixel),
d186 1
a186 1
			if( fbwrite( 0, by, scans, dma_pixels ) == -1 )
d199 3
a201 3
register char	*buff_p;	/* On VAX, known to be R11 */
register char	*scan_p;	/* VAX R10 */
register int	scan_bytes;	/* VAX R9 */
d206 2
a207 2
#if ! defined( vax ) || defined( lint )
		(void) strncpy( buff_p, scan_p, scan_bytes );
d209 1
a209 2
		/* Pardon the efficiency.  movc3 len,src,dest */
		asm("	movc3	r9,(r10),(r11)");
d318 1
a318 1
	{	register u_char	*cp;
@


1.9
log
@Added 1 to length of pixel buffer to guard against bad RLE files 
created with bug in fb-rle making scanlines 1 pixel too long.
@
text
@d17 1
d19 3
a21 2
#include <fb.h>
#include <rle.h>
d85 1
a85 1
		setfbsize( 1024 );
@


1.8
log
@Changed fbopen to use CREATE flag.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) rle-fb.c	1.8
	Last edit: 	8/7/85 at 14:23:55
	Retrieved: 	8/13/86 at 03:17:29
d15 1
a15 1
char	sccsTag[] = "@@(#) rle-fb.c	1.8	last edit 8/7/85 at 14:23:55";
d30 2
a31 1
static char	*usage[] = {
d33 1
a33 1
"rle-fb (1.8)",
d41 1
a41 1
};
d58 8
a65 10
	{
	register int	scan_ln;
	register int	dma_scans;
	static Pixel	scans[DMA_PIXELS];
	static Pixel	bg_scan[1024];
	static ColorMap	cmap;
	static int	get_flags;
	static int	scan_bytes;
	static int	dma_pixels;
	static int	dummy;
d136 3
a138 5
		{
		register int	i;
		register Pixel	*to;
		register Pixel	*from;

d170 2
a171 3
			{ register int
			touched =
				rle_decode_ln( fp, scans+PIXEL_OFFSET );
d196 1
a196 3
	{
	register int	i;

d210 1
a210 2
/*	p a r s _ A r g v ( )
 */
d214 3
a216 5
	{
	register int	c;
	extern int	optind;
	extern char	*optarg;

d220 2
a221 1
		switch( c ) {
d227 2
a228 1
			switch( bgflag ) {
d257 1
a257 1
			} /* End switch */
d303 1
a303 3
	{
	register char	**p = usage;

a304 1
		{
a305 1
		}
d312 2
a313 4
	{
	register u_char	*cp;
	register int	i;

@


1.7
log
@Added support for positioning of image.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) rle-fb.c	1.7
	Last edit: 	5/29/85 at 13:10:31
	Retrieved: 	8/13/86 at 03:17:22
d15 1
a15 1
char	sccsTag[] = "@@(#) rle-fb.c	1.7	last edit 5/29/85 at 13:10:31";
d32 1
a32 1
"rle-fb (1.7)",
d94 1
a94 1
	if( fbopen( NULL, APPEND ) == -1 )
@


1.6
log
@Appear to work nicely and fast enough too.  Still need to support 
the -p option.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) rle-fb.c	1.6
	Last edit: 	3/27/85 at 20:45:14
	Retrieved: 	8/13/86 at 03:17:15
d15 1
a15 1
char	sccsTag[] = "@@(#) rle-fb.c	1.6	last edit 3/27/85 at 20:45:14";
a19 1
#include <memory.h>
d26 2
a27 2
#define DMA_SCANS	(DMA_PIXELS/fbsz)
#define PIXEL_OFFSET	((scan_ln%dma_scans)*fbsz)
d32 1
a32 1
"rle-fb (1.6)",
d34 1
a34 1
"Usage: rle-fb [-Odv][-b (rgbBG)][-p X Y] [file.rle]",
d48 2
a58 1
	register int	fbsz = 512;
a63 2
	static int	xlen, ylen;
	static int	xpos, ypos;
d66 1
d73 1
a73 7
	if(	rle_rhdr(	fp,
				&get_flags,
				bgflag ? NULL : &bgpixel,
				&xlen, &ylen, &xpos, &ypos
				)
	    ==	-1
		)
d76 6
d83 8
a90 5
	if( xlen > 512 || ylen > 512 )
		{
		fbsz = 1024;
		setfbsize( fbsz );
		}
d93 1
a93 1
	scan_bytes = fbsz * sizeof(Pixel);
d144 1
a144 1
		for( i = 0; i < fbsz; i++ )
d150 4
a153 3
		register int	by = fbsz - dma_scans;
		int		top = fbsz - ylen;
	for( scan_ln = fbsz - 1; scan_ln >= 0; scan_ln-- )
d166 1
a166 1
						fbsz*sizeof(Pixel),
d172 1
a172 1
		if( scan_ln > top )
d174 2
a175 2
			touched = rle_decode_ln( fp, scans+PIXEL_OFFSET );

d183 1
a183 3
			if( fbwrite( 0, by, scans, dma_pixels )
			    ==	-1
				)
d206 1
a206 1
		(void) memcpy( buff_p, scan_p, scan_bytes );
d227 1
a227 1
	while( (c = getopt( argc, argv, "Ob:dvp:" )) != EOF )
d269 11
a282 5
		case 'p' :
			(void) fprintf( stderr,
					"-p option not implemented!\n"
					);
			break;
d285 1
a285 1
		} /* end switch */
@


1.5
log
@Save buffered version.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) rle-fb.c	1.5
	Last edit: 	3/27/85 at 11:28:44
	Retrieved: 	8/13/86 at 03:17:07
d15 1
a15 1
char	sccsTag[] = "@@(#) rle-fb.c	1.5	last edit 3/27/85 at 11:28:44";
d26 3
a28 7
#define PIXELS_PER_DMA	(MAX_DMA/sizeof(Pixel))
#define SCANS_PER_DMA	(PIXELS_PER_DMA/fbsz)
#define PIXEL_OFFSET	((scan_ln%scans_per_dma)*fbsz)
#define Fbread_Dma( y )\
		if( y >= scans_per_dma &&\
		    fbread(0,(y)-scans_per_dma,scan_buf,pixels_per_dma)==-1)\
			return 1;
d33 1
a33 1
"rle-fb (1.5)",
d59 2
a60 2
	register int	scans_per_dma;
	static Pixel	scan_buf[PIXELS_PER_DMA];
d67 1
a67 1
	static int	pixels_per_dma;
d89 2
a90 2
	pixels_per_dma = PIXELS_PER_DMA;
	scans_per_dma = SCANS_PER_DMA;
d148 3
a150 3
		register int	y_buffer = fbsz - scans_per_dma;

	for( scan_ln = fbsz - 1; scan_ln >= fbsz - ylen; scan_ln-- )
d155 2
a156 8
				{ /* Overlay -- read cluster from fb.	*/
				if(	fbread(	0,
						y_buffer,
						scan_buf,
						pixels_per_dma
						)
				    ==	-1
					)
d161 5
a165 12
				{ /* Fill buffer with background.	*/
				register int	i;
				register Pixel	*scan_ptr = scan_buf;
				for( i = 0; i < scans_per_dma; ++i )
					{
					(void) memcpy(	(char *) scan_ptr,
							(char *) bg_scan,
							scan_bytes
							);
					scan_ptr += fbsz;
					}
				}
d169 3
a171 2
		{ register int
			touched = rle_decode_ln( fp, scan_buf+PIXEL_OFFSET );
d177 2
a178 2
		}
		if( page_fault = ! (scan_ln%scans_per_dma) )
d180 1
a180 1
			if( fbwrite( 0, y_buffer, scan_buf, pixels_per_dma )
d184 1
a184 1
			y_buffer -= scans_per_dma;
d189 24
@


1.4
log
@Preliminary version reads both formats writes new format.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) rle-fb.c	1.4
	Last edit: 	3/26/85 at 17:45:51
	Retrieved: 	8/13/86 at 03:16:57
d15 1
a15 1
char	sccsTag[] = "@@(#) rle-fb.c	1.4	last edit 3/26/85 at 17:45:51";
a27 1
#define DMAS_PER_FB	(fbsz/SCANS_PER_DMA)
d37 1
a37 1
"rle-fb (1.4)",
d63 2
a64 1
	static Pixel	scan_buf[1024];
a71 2
	static int	scans_per_dma;
	static int	dmas_per_fb;
a136 1

d138 1
a138 1
	if( ! olflag )
d149 5
d156 32
a187 1
		static int	dirty_flag = 1;
d189 1
a189 3
		if( olflag )
			{ /* Overlay mode -- read scanline from fb.	*/
			if( fbread( 0, scan_ln, scan_buf, xlen ) == -1 )
d191 10
d202 2
a203 13
		else
		if( (get_flags & NO_BOX_SAVE) && dirty_flag )
			{ /* Fill buffer with background.		*/
			(void) memcpy(	(char *) scan_buf,
					(char *) bg_scan,
					scan_bytes
					);
			}
		if( (dirty_flag = rle_decode_ln( fp, scan_buf )) == -1 )
			return	1;
		if( fbwrite( 0, scan_ln, scan_buf, fbsz ) == -1 )
			return	1;
		}
@


1.3
log
@Not impressed with speed improvement gained from sending clusters.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) rle-fb.c	1.3
	Last edit: 	3/22/85 at 12:55:19
	Retrieved: 	8/13/86 at 03:16:50
d15 1
a15 1
char	sccsTag[] = "@@(#) rle-fb.c	1.3	last edit 3/22/85 at 12:55:19";
d19 2
d31 1
a31 1
		if( y >= 0 &&\
d38 1
a38 1
"rle-fb (1.3)",
d40 1
a40 1
"Usage: rle-fb [-Odhv][-b (rgbBG)][-pi X Y] [file.rle]",
a46 3
/* Only for debugging library.						*/
int		debug = 0;
int		verbose = 0;
a50 1
static int	bwflag = 0;
d63 3
a65 2
	register int	fbsz;
	static Pixel	scan_buf[PIXELS_PER_DMA];
d67 4
d80 5
a84 1
	if(	rle_rhdr( fp, bgflag, &bwflag, &cmflag, olflag, &bgpixel )
d89 6
a94 1
	fbsz = getfbsize();
d97 1
d101 1
a101 1
	if( verbose )
d108 1
a108 1
	if( cmflag )
d110 1
a110 1
		if( verbose && ! olflag )
d116 1
a116 1
		if( verbose )
d121 1
a121 1
			if( verbose )
d132 1
a132 1
		if( verbose )
d140 1
a140 1
	/* Fill output buffer with background.				*/
d144 2
a145 2
		register Pixel	*to = scan_buf;
		register Pixel	*from = &bgpixel;
d147 3
a149 1
		for( i = 0; i < pixels_per_dma; i++ )
d152 1
a152 1
	else
d154 1
a154 7
		Fbread_Dma( fbsz - 1 );
		}
	for( scan_ln = fbsz - 1; scan_ln >= 0; scan_ln-- )
		{
		register Pixel	*scan_ptr = &scan_buf[PIXEL_OFFSET];
		register int	dirty_flag;
		static int	touched = 0;
d156 3
a158 8
		if( (dirty_flag = rle_decode_ln( fp, scan_ptr )) == -1 )
			return	1;
		touched += dirty_flag;
		if( scan_ptr == scan_buf )
			{
			if( fbwrite( 0, scan_ln, scan_buf, pixels_per_dma )
			    == -1
				)
a159 16
			/* Fill output buffer with background.		*/
			if( olflag )
				{
				Fbread_Dma( scan_ln );
				}
			else
			if( touched )
				{
				register int	i;
				register Pixel	*to = scan_ptr;
				register Pixel	*from = &bgpixel;

				for( i = 0; i < pixels_per_dma; i++ )
					*to++ = *from;
				touched = 0;
				}
d161 12
d188 1
a188 1
	while( (c = getopt( argc, argv, "Ob:dhvp:i:" )) != EOF )
d228 1
a228 1
			debug = 1;
a229 3
		case 'h' : /* High resolution mode.		*/
			setfbsize( 1024 );
			break;
d231 1
a231 1
			verbose = 1;
a235 5
					);
			break;
		case 'i' :
			(void) fprintf( stderr,
					"-i option not implemented!\n"
@


1.2
log
@Works well, all options not tested, -i and -p option not 
supported, and buffering is needed.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) rle-fb.c	1.2
	Last edit: 	3/21/85 at 16:21:52
	Retrieved: 	8/13/86 at 03:16:43
d15 1
a15 1
char	sccsTag[] = "@@(#) rle-fb.c	1.2	last edit 3/21/85 at 16:21:52";
d19 14
a33 1

d36 1
a36 1
"rle-fb (1.2)",
a63 2
	Pixel		scan_buf[1024];
	ColorMap	cmap;
d66 5
d83 2
d126 3
a128 1
	for( scan_ln = fbsz-1; scan_ln >= 0; --scan_ln )
d131 20
a150 7
		register Pixel	*to = scan_buf, *from = &bgpixel;
		if( debug )
			(void) fprintf( stderr,
					"rle_decode_ln( %d )\n",
					scan_ln
					);
		for( i = 0; i < fbsz; ++i )
d152 20
a171 1
			*to++ = *from;
a172 4
		if( rle_decode_ln( fp, scan_buf ) == -1 )
			return	1;
		if( fbwrite( 0, scan_ln, scan_buf, fbsz ) == -1 )
			return	1;
@


1.1
log
@Initial revision
@
text
@d2 3
a4 3
	SCCS id:	@@(#) rle-fb.c	1.1
	Last edit: 	3/21/85 at 14:01:17
	Retrieved: 	8/13/86 at 03:16:39
d15 1
a15 1
char	sccsTag[] = "@@(#) rle-fb.c	1.1	last edit 3/21/85 at 14:01:17";
d19 1
d23 1
a23 1
"_rle-fb (1.1)",
d25 1
a25 1
"Usage: _rle-fb [-Odhv][-b (rgbBG)][-pi X Y]",
d27 3
d36 1
a41 1
static int	fbsz;
d43 1
d54 2
d61 1
a61 1
	if(	rle_rhdr( stdin, bgflag, &bwflag, &cmflag, olflag, &bgpixel )
d83 1
a83 1
		if( rle_rmap( stdin, &cmap ) == -1 )
d85 2
d90 4
d110 12
a121 1
		if( rle_decode_ln( stdin, scan_buf ) == -1 )
d177 2
a178 1
			}
d202 11
a212 1
	if( argc != optind )
d231 83
@
