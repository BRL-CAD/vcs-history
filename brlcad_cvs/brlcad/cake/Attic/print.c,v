head	11.3;
access;
symbols
	ansi-20040405-merged:11.2
	premerge-autoconf:11.2
	ansi-20040316-freeze:11.2
	postmerge-20040315-windows:11.2
	premerge-20040315-windows:11.2
	windows-20040315-freeze:11.2
	autoconf-20031203:11.2
	autoconf-20031202:11.2
	phong-branch:11.2.0.12
	photonmap-branch:11.2.0.10
	rel-6-1-DP:11.2
	windows-branch:11.2.0.8
	rel-6-0-2:11.2
	ansi-branch:11.2.0.6
	rel-6-0-1-branch:11.2.0.4
	hartley-6-0-post:11.2
	hartley-6-0-pre:11.2
	rel-6-0-1:11.2
	rel-6-0:11.2
	rel-5-4:11.2
	offsite-5-3-pre:11.2
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:1.3
	rel-4-0:1.1
	rel-3-5:1.1
	rel-3-0:1.1
	AUTOCONF:11.2.0.14;
locks; strict;
comment	@ * @;


11.3
date	2004.03.18.18.15.14;	author erikg;	state dead;
branches;
next	11.2;

11.2
date	97.05.22.16.57.55;	author mike;	state Exp;
branches
	11.2.14.1;
next	11.1;

11.1
date	95.01.05.06.00.09;	author mike;	state Rel4_4;
branches;
next	1.3;

1.3
date	94.11.03.14.06.15;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	94.10.21.20.51.23;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	88.06.11.00.56.23;	author mike;	state Original;
branches;
next	;

11.2.14.1
date	2004.03.18.18.10.24;	author erikg;	state dead;
branches;
next	;


desc
@cake source file 
@


11.3
log
@merge of AUTOCONF branch in to HEAD
@
text
@/*
**	Printout routines for Cake data structures.
*/

#ifdef	CAKEDEBUG

static	char
rcs_id[] = "$Header: /cvs/brlcad/cake/print.c,v 11.2 1997/05/22 16:57:55 mike Exp $";

#include	"cake.h"

char *
str_pflag(flag)
reg	int	flag;
{
	char		buf[256];

	strcpy(buf, "[");
	if (flag & nf_NONVOL)
		strcat(buf, "nonvol ");
	if (flag & nf_PRECIOUS)
		strcat(buf, "precious ");
	if (flag & nf_PSEUDO)
		strcat(buf, "pseudo ");
	if (flag & nf_REDUNDANT)
		strcat(buf, "redundant ");
	if (flag & nf_WHEN)
		strcat(buf, "when ");
	if (flag & nf_DEPNONVOL)
		strcat(buf, "depnonvol ");
	if (flag & nf_NODELETE)
		strcat(buf, "nodelete ");
	if (flag & nf_NEWFILE)
		strcat(buf, "newfile ");
	if (flag & nf_EXIST)
		strcat(buf, "exist ");
	if (flag & nf_BUSY)
		strcat(buf, "busy ");
	if (flag & nf_ERR)
		strcat(buf, "err ");
	if (flag & nf_TRACED)
		strcat(buf, "traced ");
	if (flag & nf_WARNED)
		strcat(buf, "warned ");
	if (flag & nf_ORIG)
		strcat(buf, "orig ");

	if (strlen(buf) > (unsigned)1)
		buf[strlen(buf)-1] = '\0';

	strcat(buf, "]");
	return new_name(buf);
}

char *
str_aflag(flag)
reg	int	flag;
{
	char		buf[128];

	strcpy(buf, "[");
	if (flag & af_SILENT)
		strcat(buf, "silent ");
	if (flag & af_IGNORE)
		strcat(buf, "ignore ");
	if (flag & af_MINUSN)
		strcat(buf, "minusn ");
	if (flag & af_SYSTEM)
		strcat(buf, "system ");
	if (flag & af_SCRIPT)
		strcat(buf, "script ");

	if (strlen(buf) > (unsigned)1)
		buf[strlen(buf)-1] = '\0';

	strcat(buf, "]");
	return new_name(buf);
}

void
print_pat(pat)
reg	Pat	*pat;
{
	if (pat->p_cmd)
		printf("`%s`", pat->p_str);
	else
		printf("%s", pat->p_str);

	printf(str_pflag(pat->p_flag));
}

void
print_act(act)
reg	Act	*act;
{
	printf(str_aflag(act->a_flag));
	printf("%s", act->a_str);
}

void
print_test(test)
reg	Test	*test;
{
	reg	List	*ptr;
	reg	char	*pre;
	reg	Pat	*pat;

	if (test == NULL)
	{
		printf("null");
		return;
	}

	switch (test->t_kind)
	{

case t_TRUE:	printf("true");
		break;
case t_FALSE:	printf("false");
		break;

case t_AND:	print_test(test->t_left);
		printf(" and ");
		print_test(test->t_right);
		break;

case t_OR:	print_test(test->t_left);
		printf(" or ");
		print_test(test->t_right);
		break;

case t_NOT:	printf("not ");
		print_test(test->t_left);
		break;

case t_CMD:	printf("cmd `%s`", test->t_cmd);
		break;

case t_MATCH:	printf("match ");
		print_pat(test->t_pat);
		printf(" against");
		printf(" (");
		print_pat((Pat *) first(test->t_list));
		printf(") ");
		print_pat((Pat *) last(test->t_list));
		break;

case t_LIST:	printf("list ");
		print_pat(test->t_pat);

		printf(" in (");
		pre = "";
		for_list (ptr, test->t_list)
		{
			pat = (Pat *) ldata(ptr);
			printf(pre);
			print_pat(pat);
			pre = ", ";
		}

		printf(")");
		break;

case t_EXIST:	printf("exist ");
		print_pat(test->t_pat);
		break;

case t_CANDO:	printf("cando ");
		print_pat(test->t_pat);
		break;

case t_OK:	printf("ok ");
		print_pat(test->t_pat);
		break;

default:	printf("Bad type kind %d in print_test\n", test->t_kind);

	}
}

void
print_entry(entry)
reg	Entry	*entry;
{
	reg	List	*ptr;
	reg	Pat	*pat;
	reg	Act	*act;
	reg	char	*pre;

	printf("ENTRY\nnew: ");
	pre = "";
	for_list (ptr, entry->e_new)
	{
		pat = (Pat *) ldata(ptr);
		printf(pre);
		print_pat(pat);
		pre = ", ";
	}

	printf("\nold: ");
	pre = "";
	for_list (ptr, entry->e_old)
	{
		pat = (Pat *) ldata(ptr);
		printf(pre);
		print_pat(pat);
		pre = ", ";
	}

	printf("\nwhen: ");
	pre = "";
	for_list (ptr, entry->e_when)
	{
		pat = (Pat *) ldata(ptr);
		printf(pre);
		print_pat(pat);
		pre = ", ";
	}

	printf("\ntest: ");
	print_test(entry->e_cond);

	printf("\nactions:\n");
	for_list (ptr, entry->e_act)
	{
		act = (Act *) ldata(ptr);
		print_act(act);
	}

	printf("\n");
}

char *
str_nkind(nkind)
reg	N_kind	nkind;
{
	switch (nkind)
	{
case n_OK:	return "ok";
case n_NOWAY:	return "noway";
case n_CANDO:	return "cando";
	}

	return "bizarre";
}

void
print_time(str, ntime)
reg	char	*str;
time_t		ntime;
{
	extern	char	*ctime();

	printf("%s time: %d, %s", str, ntime, ctime(&ntime));
}

void
print_node(node)
reg	Node	*node;
{
	reg	List	*ptr;
	reg	char	*pre;
	reg	Node	*bnode;
	reg	Act	*act;

	printf("\nNODE\n%s: kind %s flag %s\n", node->n_name, 
		str_nkind(node->n_kind), str_pflag(node->n_flag));
	print_time("real",  node->n_rtime);
	print_time("used",  node->n_utime);
	print_time("saved", node->n_stime);

	printf("new: ");
	pre = "";
	for_list (ptr, node->n_new)
	{
		bnode = (Node *) ldata(ptr);
		printf(pre);
		printf(bnode->n_name);
		pre = ", ";
	}

	printf("\nold: ");
	pre = "";
	for_list (ptr, node->n_old)
	{
		bnode = (Node *) ldata(ptr);
		printf(pre);
		printf(bnode->n_name);
		pre = ", ";
	}

	printf("\naction:\n");
	for_list (ptr, node->n_act)
	{
		act = (Act *) ldata(ptr);
		print_act(act);
	}

	if (node->n_badguys != (List *) NULL)
	{
		printf("bad guys: ");
		pre = "";
		for_list (ptr, node->n_badguys)
		{
			bnode = (Node *) ldata(ptr);
			printf(pre);
			printf(bnode->n_name);
			pre = ", ";
		}

		printf("\n");
	}

	if (node->n_msg != NULL)
		printf("msg: %s", node->n_msg);

	printf("\n");
}

#endif
@


11.2
log
@Added (void) declarations for IRIX 6 compiler.
@
text
@d8 1
a8 1
rcs_id[] = "$Header: /m/cad/cake/RCS/print.c,v 11.1 1995/01/05 06:00:09 mike Rel4_4 mike $";
@


11.2.14.1
log
@merge from head
@
text
@d8 1
a8 1
rcs_id[] = "$Header: /cvs/brlcad/cake/print.c,v 11.2 1997/05/22 16:57:55 mike Exp $";
@


11.1
log
@Release_4_4
@
text
@d8 1
a8 1
rcs_id[] = "$Header: /m/cad/cake/RCS/print.c,v 1.3 94/11/03 14:06:15 mike Exp $";
d80 1
d92 1
d100 1
d181 1
d247 1
d257 1
@


1.3
log
@eliminated 'when' statements in favor of real C code.
@
text
@d8 1
a8 1
rcs_id[] = "$Header: /m/cad/cake/RCS/print.c,v 1.2 94/10/21 20:51:23 mike Exp Locker: mike $";
@


1.2
log
@Solaris
@
text
@d8 1
a8 1
rcs_id[] = "$Header: /m/cad/cake/RCS/print.c,v 1.1 88/06/11 00:56:23 mike Original Locker: mike $";
d114 4
a117 2
when t_TRUE:	printf("true");
when t_FALSE:	printf("false");
d119 1
a119 1
when t_AND:	print_test(test->t_left);
d122 1
d124 1
a124 1
when t_OR:	print_test(test->t_left);
d127 1
d129 1
a129 1
when t_NOT:	printf("not ");
d131 1
d133 2
a134 1
when t_CMD:	printf("cmd `%s`", test->t_cmd);
d136 1
a136 1
when t_MATCH:	printf("match ");
d143 1
d145 1
a145 1
when t_LIST:	printf("list ");
d159 1
d161 1
a161 1
when t_EXIST:	printf("exist ");
d163 1
d165 1
a165 1
when t_CANDO:	printf("cando ");
d167 1
d169 1
a169 1
when t_OK:	printf("ok ");
d171 1
d173 1
a173 1
otherwise:	printf("Bad type kind %d in print_test\n", test->t_kind);
d235 3
a237 3
when n_OK:	return "ok";
when n_NOWAY:	return "noway";
when n_CANDO:	return "cando";
@


1.1
log
@Original CAKE version from net.sources
@
text
@d8 1
a8 1
rcs_id[] = "$Header: /mip/zs/src/sys/cake/RCS/print.c,v 1.15 87/10/05 20:15:33 zs Exp $";
d48 1
a48 1
	if (strlen(buf) > 1)
d73 1
a73 1
	if (strlen(buf) > 1)
@
