head	11.11;
access;
symbols
	ansi-20040405-merged:11.9.4.1
	postmerge-20040405-ansi:11.10
	premerge-20040404-ansi:11.10
	postmerge-autoconf:11.10
	premerge-autoconf:11.10
	ansi-20040316-freeze:11.9
	postmerge-20040315-windows:11.10
	premerge-20040315-windows:11.10
	windows-20040315-freeze:11.9.6.1
	autoconf-20031203:11.9
	autoconf-20031202:11.9
	phong-branch:11.9.0.10
	photonmap-branch:11.9.0.8
	rel-6-1-DP:11.9
	windows-branch:11.9.0.6
	rel-6-0-2:11.9
	ansi-branch:11.9.0.4
	rel-6-0-1-branch:11.9.0.2
	hartley-6-0-post:11.9
	hartley-6-0-pre:11.9
	rel-6-0-1:11.9
	rel-6-0:11.9
	rel-5-4:11.6
	offsite-5-3-pre:11.6
	rel-5-3:11.6
	rel-5-2:11.6
	rel-5-1-branch:11.6.0.2
	rel-5-1:11.6
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:1.12
	rel-4-0:1.3
	rel-3-5:1.2
	rel-3-0:1.2
	AUTOCONF:11.9.0.12;
locks; strict;
comment	@ * @;


11.11
date	2004.05.19.15.45.58;	author morrison;	state dead;
branches;
next	11.10;

11.10
date	2004.03.03.19.36.53;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2001.07.19.22.12.45;	author morrison;	state Exp;
branches
	11.9.4.1
	11.9.6.1
	11.9.12.1;
next	11.8;

11.8
date	2001.07.19.22.08.11;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2001.07.18.14.38.07;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	2000.03.16.03.49.45;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	2000.03.16.03.24.22;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	2000.03.16.03.15.26;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	2000.03.16.02.52.32;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	97.05.18.03.02.09;	author cjohnson;	state Exp;
branches;
next	11.1;

11.1
date	95.01.05.06.02.11;	author mike;	state Rel4_4;
branches;
next	1.12;

1.12
date	94.12.07.17.05.35;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	94.10.21.20.52.31;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	94.10.19.09.05.31;	author butler;	state Exp;
branches;
next	1.9;

1.9
date	92.08.13.14.50.02;	author butler;	state Exp;
branches;
next	1.8;

1.8
date	92.04.03.00.08.52;	author butler;	state Exp;
branches;
next	1.7;

1.7
date	92.03.16.20.25.07;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	91.11.02.01.06.21;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	91.11.02.00.54.36;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	91.11.02.00.52.59;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	91.07.23.02.04.06;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	88.06.11.01.01.35;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	88.06.11.00.55.43;	author mike;	state Original;
branches;
next	;

11.9.4.1
date	2004.03.17.21.15.52;	author morrison;	state Exp;
branches;
next	;

11.9.6.1
date	2004.03.11.23.40.27;	author morrison;	state Exp;
branches;
next	;

11.9.12.1
date	2004.03.15.14.06.05;	author erikg;	state Exp;
branches;
next	11.9.12.2;

11.9.12.2
date	2004.03.18.18.10.24;	author erikg;	state dead;
branches;
next	;


desc
@cake
@


11.11
log
@cake is no more and theres no incentive to maintain it any more so .. buh bye.
@
text
@%{
/*
**	Scanner for Cake
*/

static	char
rcs_id[] = "$Header: /cvs/brlcad/cake/cake_s.l,v 11.10 2004/03/03 19:36:53 morrison Exp $";

#include	"cake.h"
#include	"cake_g.h"
#include	<ctype.h>

#ifdef	CAKEDEBUG
#  if __STDC__ || defined(__convex__)
#	define	ret(x)	if (lexdebug) printf("lex: " #x "\n"); return x
#  else
#	define	ret(x)	if (lexdebug) printf("lex: x\n"); return x
#  endif
#else
#define	ret(x)	return x
#endif

/*
 * YYLMAX must be defined here; it can't be defined in conf.h,
 * because the lex startoff code contains a #define YYLMAX BUFSIZ
 * which will be seen before here.
 *
 * Even worse, on Solaris (and perhaps others), the lex startoff code
 * declares char yytext[YYLMAX]; before we've gotten here,
 * resulting in buffer overruns on LIBRT.
 *
 * As a consequence, we must depend on the Makefile for cake
 * to run a SED script to replace any system-provided #define YYLMAX
 * with a pleasantly plump value (32768).  -Mike Muuss, ARL.
 */
#undef	YYLMAX
#define	YYLMAX		MAXLEXBUF

void
check_actlen()
{
	/* yytext may be an array or a pointer */
	if (strlen(yytext) >= (unsigned)YYLMAX-4)
	{
		printf("cake: action '%s' too long\n", yytext);
		exit_cake(FALSE);
	}
}

#define	LATE_CATCH
#define	LATE_RECOVERY	printf("cake: token '%s' is too long\n", yytext); \
			exit(1);

#define	LBRACE	'{'
#define	RBRACE	'}'

extern	char	*yysquare();
extern	char	*yycurly();

extern	int	lexdebug;
char		*yyfile = "no input file";
bool		afterifdef = FALSE;
%}

/* The next two lines were required for older versions of lex with */
/* small default table sizes.  Newer versions of lex have more realistic */
/* default table sizes, and new fast-lex (flex) doesn't support these */
/* directives.  Un-comment the next two lines if you have trouble with */
/* table sizes. */
%a	2500
%o	5000

%start	edge middle

pat	[a-zA-Z_0-9/%+\-.,]
sp	[ \t]
nl	[\n\f]
nonl	[^\n\f]
enonl	({nonl}|\\{nl})

%%

"if"			{ BEGIN middle;	ret(IF);		}
"and"			{ BEGIN middle;	ret(AND);		}
"or"			{ BEGIN middle;	ret(OR);		}
"not"			{ BEGIN middle;	ret(NOT);		}
"in"			{ BEGIN middle;	ret(IN);		}
"match"			{ BEGIN middle;	ret(MATCH);		}
"exist"			{ BEGIN middle;	ret(EXIST);		}
"cando"			{ BEGIN middle;	ret(CANDO);		}
"ok"			{ BEGIN middle;	ret(OK);		}

"("			{ BEGIN middle;	ret(LPAREN);		}
")"			{ BEGIN middle;	ret(RPAREN);		}

"@@"			{ BEGIN middle;	ret(NONVOL);		}
"!"			{ BEGIN middle;	ret(PRECIOUS);		}
"&"			{ BEGIN middle;	ret(PSEUDO);		}
"^"			{ BEGIN middle;	ret(REDUNDANT);		}
"*"			{ BEGIN middle;	ret(WHEN);		}

":"			|
"::"			{
				BEGIN middle;
				yylval.Ustr = new_name(yytext);
				ret(COLON);
			}

({pat}|\\{nonl})+	{
				BEGIN middle;
				yylval.Ustr = new_name(yytext);
				ret(PAT);
			}

\"([^"]|\\\")*\"	{
				BEGIN middle;
				/* strip off quotes */
				yytext[yyleng-1] = '\0';
				yylval.Ustr = new_name(yytext+1);
				ret(PAT);
			}

"[["			{
				BEGIN middle;
				yylval.Ustr = yysquare();
				ret(PATCMD);
			}

"{{"			{
				BEGIN middle;
				yylval.Ustr = yycurly();
				ret(TESTCMD);
			}

<middle>({sp}|\\{nl})*	{ BEGIN middle;			}

<edge>{sp}*{nl}		{
				BEGIN edge;
				/* Must come *before* the ACT rule, below */
				if (lexdebug)
					printf("empty line\n");
				if (! afterifdef)
					ret(EMPTYLINE);
			}

<edge>[@@!+-]*"{"{enonl}*{nl}	|
<edge>[@@!+-]*"}"{enonl}*{nl}	|
<edge>{sp}+{enonl}+{nl}	{
				BEGIN edge;
				afterifdef  = FALSE;
				yylval.Uact = prep_act(yytext);

				/* comment out check_actlen if  */
				/* have a lex driver with CATCH */
				check_actlen();

				/* braces around ret ARE needed */
				/* as ret expands to an if stmt */
				if (yylval.Uact->a_str[0] == LBRACE)
				{
					ret(BEGIN_ACT);
				}
				or (yylval.Uact->a_str[0] == RBRACE)
				{
					ret(END_ACT);
				}
				else
				{
					ret(ACT);
				}
			}

<edge>"set"{nonl}*{nl}	{
				BEGIN edge;
				if (lexdebug)
					printf("set line\n");
				yyset(yytext);
			}

<edge>#{nonl}*{nl}	{
				BEGIN edge;
				if (lexdebug)
					printf("hash line\n");
				yyhash(yytext);
				if (! afterifdef)
					ret(EMPTYLINE);
			}

<middle>{nl}		{
				BEGIN edge;
				afterifdef = FALSE;
				ret(NL);
			}

{nonl} 			{ BEGIN middle;	ret(GARBAGE);	}

"$"{nonl}*{nl}		{ BEGIN edge;			}

%%

yyinit()
{
	BEGIN edge;
}

/* GNU lex (flex) does not define yylineno... other lexers that do the same will need
 * to be added.
 * May need to a do a check for if __bsdi__ is defined */
#if defined(YY_FLEX_MAJOR_VERSION) && !defined(YY_FLEX_LEX_COMPAT)
int yylineno=1;
#else
extern int yylineno;
#endif

yywrap()
{
	return 1;
}

yyset(text)
reg	char	text[];
{
	reg	char	*s;
	int		setc;
	char		*setv[MAXARGS];

	for (s = text+4; *s != '\0' && isspace(*s); s++)
		;

	setc = parse_args(s, setv);
	process_args(setv, &setc, 0);
	if (setc > 0)
		printf("cake: non-options on parameter line ignored\n");
}

/*
 *			Y Y H A S H
 *
 *  Process a CPP directive.  On older systems, likely directives were:
 *	# 1 "Cakefile"
 *  while on ANSI systems, the format will be:
 *	# line 2 "Cakefile"
 *  Accept either.  If the filename changes, then a #include has just
 *  completed, otherwise, assume a #if was just processed,
 *  and set a flag to compress out subsequent blank lines.
 */
yyhash(text)
reg	char	text[];
{
	reg	char	*oldfile = yyfile;
	reg	char	*s, *t;

	text[strlen(text)-1] = '\0';	/* clobber the newline */
	if(lexdebug)printf("cake: yyhash %s\n", text);

	afterifdef = TRUE;	/* assume so until proven otherwise */
	s = text+1;

	if (sscanf(s, "%d", &yylineno) != 1)  {
		/* Skip leading space */
		while( *s && isascii(*s) && isspace(*s) )  s++;
		if( strncmp( s, "line ", 5 ) == 0 )  {
			s += 5;
			if(sscanf(s, "%d", &yylineno) != 1 )  {
				printf("cake: Don't grok line in %s\n", text);
				return;
			}
		} else {
/* XXX - quell the annoying blather about not groking since apple gcc 3.3
 * outputs a pragma gcc for each file that it cannot grok.
 *			printf("cake: Don't grok %s\n", text);
 */
			return;
		}
	}

	/* Skip space and numbers, looking for first quote */
	while(*s != '\0' && *s != '"' && !isalpha(*s)) s++;

	if (*s == '\0')
		return;
	
	if (*s != '"')
		yyfile = new_name(s);
	else
	{
		for (t = s+strlen(s)-1; t != s && *t != '"'; t--)
			;
		
		if (t != s)
			*t = '\0';

		yyfile = new_name(s+1);
	}

	if (yyfile != oldfile)
	{
		afterifdef = FALSE;
		return;
	}
}

/*
**	Read in a PATCMD, which is [[.*PATCMD?.*]]
**	(or a matched set of double brackets with other stuff.
**	Note that PATCMD cannot be described by a REAL regular
**	expression; the one above cheats by using recursion.
**	yysquare returns the PATCMD brackets and all.
*/

char *
yysquare()
{
	char		buf[MAXSIZE];
	reg	int	c, c1;
	reg	int	i;
	reg	int	n;	/* number of outstanding levels */

	n = 1;
	i = 0;
	buf[i++] = '[';
	buf[i++] = '[';
	for (c = input(); c != '\0' && c != '\n' && c != '\f'; c = input())
	{
		buf[i++] = c;
		if (c == ']')
		{
			if ((c1 = input()) != ']')
			{
				/* for the next iteration */
				unput(c1);
				continue;
			}

			buf[i++] = c1;
			if (--n > 0)
				continue;

			buf[i] = '\0';
			if (strlen(buf) >= (unsigned)MAXSIZE)
			{
				fprintf(stderr, "cake internal error: buffer overflow in yysquare\n");
				exit_cake(FALSE);
			}

			if (lexdebug)
				printf("yysquare: %s\n", buf);

			fflush(stdout);
			return new_name(buf);
		}
		or (c == '[')
		{
			if ((c1 = input()) != '[')
			{
				/* for the next iteration */
				unput(c1);
				continue;
			}

			buf[i++] = c1;
			n++;
		}
		or (c == '\\')
		{
			/* don't check next char */
			if ((c1 = input()) != '\0')
				buf[i++] = c1;
		}
	}

	if (c == '\0')
		fprintf(stderr, "%s, %d: premature EOF\n", yyfile, yylineno);
	else
		fprintf(stderr, "%s, %d: unescaped newline inside a command\n", yyfile, yylineno);

	exit_cake(FALSE);
	return("--error--");			/* BRL */
}

/*
**	Read in a TESTCMD, which is {{.*}}. Strip the brackets.
*/

char *
yycurly()
{
	char		buf[MAXSIZE];
	reg	int	c, c1;
	reg	int	i;

	i = 0;
	for (c = input(); c != '\0' && c != '\n' && c != '\f'; c = input())
	{
		buf[i++] = c;
		if (c == RBRACE)
		{
			if ((c1 = input()) != RBRACE)
			{
				/* for the next iteration */
				unput(c1);
				continue;
			}

			/* overwrite first RBRACE */
			buf[--i] = '\0';
			if (strlen(buf) >= (unsigned)MAXSIZE)
			{
				fprintf(stderr, "cake internal error: buffer overflow in yycurly\n");
				exit_cake(FALSE);
			}

			if (lexdebug)
				printf("yycurly: %s\n", buf);

			fflush(stdout);
			return new_name(buf);
		}
		or (c == '\\')
		{
			/* don't check next char */
			if ((c1 = input()) != '\0')
				buf[i++] = c1;
		}
	}

	if (c == '\0')
		fprintf(stderr, "%s, %d: premature EOF\n", yyfile, yylineno);
	else
		fprintf(stderr, "%s, %d: unescaped newline inside a command\n", yyfile, yylineno);

	exit_cake(FALSE);
	return("--error--");			/* BRL */
}
@


11.10
log
@quell the annoying grok message since apple gcc 3.3 outputs a pragma that cake is not set up to handle for every file.
@
text
@d7 1
a7 1
rcs_id[] = "$Header: /c/CVS/brlcad/cake/cake_s.l,v 11.9 2001/07/19 22:12:45 morrison Exp $";
@


11.9
log
@*** empty log message ***
@
text
@d7 1
a7 1
rcs_id[] = "$Header: /c/CVS/brlcad/cake/cake_s.l,v 11.8 2001/07/19 22:08:11 morrison Exp $";
d269 4
a272 1
			printf("cake: Don't grok %s\n", text);
@


11.9.4.1
log
@sync branch with HEAD
@
text
@d7 1
a7 1
rcs_id[] = "$Header$";
d269 1
a269 4
/* XXX - quell the annoying blather about not groking since apple gcc 3.3
 * outputs a pragma gcc for each file that it cannot grok.
 *			printf("cake: Don't grok %s\n", text);
 */
@


11.9.12.1
log
@merge from head
@
text
@d7 1
a7 1
rcs_id[] = "$Header: /c/CVS/brlcad/cake/cake_s.l,v 11.9 2001/07/19 22:12:45 morrison Exp $";
d269 1
a269 4
/* XXX - quell the annoying blather about not groking since apple gcc 3.3
 * outputs a pragma gcc for each file that it cannot grok.
 *			printf("cake: Don't grok %s\n", text);
 */
@


11.9.12.2
log
@merge from head
@
text
@d7 1
a7 1
rcs_id[] = "$Header: /cvs/brlcad/cake/cake_s.l,v 11.9.12.1 2004/03/15 14:06:05 erikg Exp $";
@


11.9.6.1
log
@sync to HEAD...
@
text
@d7 1
a7 1
rcs_id[] = "$Header: /n/cad/c/CVS/brlcad/cake/cake_s.l,v 11.10 2004/03/03 19:36:53 morrison Exp $";
d269 1
a269 4
/* XXX - quell the annoying blather about not groking since apple gcc 3.3
 * outputs a pragma gcc for each file that it cannot grok.
 *			printf("cake: Don't grok %s\n", text);
 */
@


11.8
log
@finally properly took care of the yylineno problem.  now actually check a flex define to tell whether or now we have to handle flex's yylineno declaration behavior -- not just assume that compiling with gcc means we're using flex..
@
text
@d7 1
a7 1
rcs_id[] = "$Header: /c/CVS/brlcad/cake/cake_s.l,v 11.7 2001/07/18 14:38:07 morrison Exp $";
d209 1
a209 1
#if (defined(YY_FLEX_MAJOR_VERSION) && !defined(YY_FLEX_LEX_COMPAT)
@


11.7
log
@GNU lex USED to not define yylineno, but now apparently does (apparent on sun5 regression build)
@
text
@d7 1
a7 1
rcs_id[] = "$Header: /c/CVS/brlcad/cake/cake_s.l,v 11.6 2000/03/16 03:49:45 mike Exp $";
d206 5
a210 6
#if (!defined(__bsdi__) && !defined(__GNUC__)) || defined(YY_FLEX_LEX_COMPAT)
extern int yylineno;
yywrap()
{
	return 1;
}
a211 1
/* GNU lex (flex) USED to not define yylineno... may need to set yylineno=1 */
d213 2
d219 1
a219 1
#endif
@


11.6
log
@
The SGI does things differently still.
Take that into account too.

The error checking doesn't have to be quite as robust now that the error
has been found.
@
text
@d7 1
a7 1
rcs_id[] = "$Header: /c/CVS/brlcad/cake/cake_s.l,v 11.5 2000/03/16 03:24:22 mike Exp $";
d213 2
a214 2
/* GNU lex (flex) does not define yylineno */
int yylineno=1;
@


11.5
log
@
Sometimes yytext is a pointer (e.g. FreeBSD), and not an array (e.g. Solaris).
@
text
@d7 1
a7 1
rcs_id[] = "$Header: /c/CVS/brlcad/cake/cake_s.l,v 11.4 2000/03/16 03:15:26 mike Exp $";
d39 11
a430 13
}

check_actlen()
{
	/* Sometimes yytext is a pointer, not a buffer */
	if( sizeof(yytext) <= 8 )  return;

	/* We know yytext is a char array, check against actual size */
	if (strlen(yytext) >= (unsigned)sizeof(yytext)-4)
	{
		printf("cake: action '%s' too long\n", yytext);
		exit_cake(FALSE);
	}
@


11.4
log
@
Fixes for Solaris.
YYLMAX is defined as BUFSIZ and used to declare yytext[YYLMAX]
before cake_s.l has the opportunity to override the definition.
We depend on a SED script in the Makefile to correct this
after lex has generated the code and before it goes to the compiler.
@
text
@d7 1
a7 1
rcs_id[] = "$Header: /c/CVS/brlcad/cake/cake_s.l,v 11.3 2000/03/16 02:52:32 mike Exp $";
d424 4
a427 3
#if 0
	if (strlen(yytext) >= (unsigned)YYLMAX)
#else
a428 1
#endif
@


11.3
log
@
Made error-detection code actually detect the error.
@
text
@d7 1
a7 1
rcs_id[] = "$Header: /c/CVS/brlcad/cake/cake_s.l,v 11.2 1997/05/18 03:02:09 cjohnson Exp $";
d23 13
a35 1
/* YYLMAX must be defined here; it can't be defined in conf.h */
@


11.2
log
@Flex can be run in a lex compatable mode.  Check for that before
we define yylineno ourselves.
@
text
@d7 1
a7 1
rcs_id[] = "$Header: /vld/cjohnson/cvsroot/brlcad/cake/cake_s.l,v 11.1 1995/01/05 06:02:11 mike Rel4_4 $";
d412 1
d414 3
@


11.1
log
@Release_4_4
@
text
@d7 1
a7 1
rcs_id[] = "$Header: /m/cad/cake/RCS/cake_s.l,v 1.12 94/12/07 17:05:35 mike Exp $";
d183 1
a183 1
#if !defined(__bsdi__) && !defined(__GNUC__)
@


1.12
log
@/* GNU lex (flex) does not define yylineno */
@
text
@d7 1
a7 1
rcs_id[] = "$Header: /m/cad/cake/RCS/cake_s.l,v 1.11 94/10/21 20:52:31 mike Exp Locker: mike $";
@


1.11
log
@Solaris
@
text
@d7 1
a7 1
rcs_id[] = "$Header: /m/cad/cake/RCS/cake_s.l,v 1.10 94/10/19 09:05:31 butler Exp Locker: mike $";
d183 1
a183 1
#if !defined(__bsdi__)
d190 1
@


1.10
log
@bsdi mods
@
text
@d7 1
a7 1
rcs_id[] = "$Header: /m/cad/cake/RCS/cake_s.l,v 1.9 1992/08/13 14:50:02 butler Exp butler $";
d313 1
a313 1
			if (strlen(buf) >= MAXSIZE)
d380 1
a380 1
			if (strlen(buf) >= MAXSIZE)
d411 1
a411 1
	if (strlen(yytext) >= YYLMAX)
@


1.9
log
@The version of "lex" supplied with Irix 4.0.3 and higher is incapable
of dealing with comments which are longer than a single line of text.
This raises questions about the kind of documentation inside SGI software.
The mulit-line comments have all been changed to multiple single-line
comments.
@
text
@d7 1
a7 1
rcs_id[] = "$Header: /n/wolf/m/cad/cake/RCS/cake_s.l,v 1.8 92/04/03 00:08:52 butler Exp Locker: butler $";
d191 4
@


1.8
log
@commented out table size directives.  Most versions of lex don't need
this anymore.
@
text
@d7 1
a7 1
rcs_id[] = "$Header: /m/cad/cake/RCS/cake_s.l,v 1.7 92/03/16 20:25:07 mike Exp Locker: butler $";
d42 7
a48 8
/* The next two lines were required for older versions of lex with
 * small default table sizes.  Newer versions of lex have more realistic
 * default table sizes, and new fast-lex (flex) doesn't support these
 * directives.  Un-comment the next two lines if you have trouble with
 * table sizes.
 */
/* %a	2500 */
/* %o	5000 */
@


1.7
log
@Butler mods for BSDI unix port.
@
text
@d7 1
a7 1
rcs_id[] = "$Header: /n/wolf/m/cad/cake/RCS/cake_s.l,v 1.6 1991/11/02 01:06:21 mike Exp butler $";
d42 8
a49 3
/* Lee had these commented out, for some reason */
%a	2500
%o	5000
@


1.6
log
@In order to not puke on lines with only spaces on it,
which the Cray UNICOS 6 ANSI CPP puts out to reduce the line counts,
the <edge>{sp}*{nl} had to come before the rule for token ACT,
which could also fire on blank lines, but shouldn't.
@
text
@d7 1
a7 1
rcs_id[] = "$Header: /m/cad/cake/RCS/cake_s.l,v 1.5 91/11/02 00:54:36 mike Exp Locker: mike $";
d42 1
d179 2
d185 3
a187 1

@


1.5
log
@Eliminated warning message:
81: (Warning) Non-portable Character Class
due to trying to create a range of characters from "+" to "."
by writing "+-.", when what was intended was just those three
characters.  I added a backslash.
@
text
@d7 1
a7 1
rcs_id[] = "$Header: /m/cad/cake/RCS/cake_s.l,v 1.4 91/11/02 00:52:59 mike Exp Locker: mike $";
d109 9
a156 8
				if (! afterifdef)
					ret(EMPTYLINE);
			}

<edge>{sp}*{nl}		{
				BEGIN edge;
				if (lexdebug)
					printf("empty line\n");
@


1.4
log
@Added ability to parse new ANSI-style CPP output
with # line 3 "file", rather than
# 3 "file"
type directives.
@
text
@d7 1
a7 1
rcs_id[] = "$Header: /m/cad/cake/RCS/cake_s.l,v 1.3 91/07/23 02:04:06 mike Exp Locker: mike $";
d47 1
a47 1
pat	[a-zA-Z_0-9/%+-.,]
@


1.3
log
@Added ANSI token pasting
@
text
@d7 1
a7 1
rcs_id[] = "$Header: /m/cad/cake/RCS/cake_s.l,v 1.2 88/06/11 01:01:35 mike Exp $";
d198 11
d215 3
d219 1
a219 2
	if (sscanf(text+1, "%d", &yylineno) != 1)
		return;
d221 17
a237 3
	text[strlen(text)-1] = '\0';	/* clobber the newline */
	for (s = text; *s != '\0' && *s != '"' && !isalpha(*s); s++)
		;
@


1.2
log
@Added two extra error returns
@
text
@d7 1
a7 1
rcs_id[] = "$Header: /mip/zs/src/sys/cake/RCS/cake_s.l,v 1.15 87/10/05 20:13:49 zs Exp $";
d14 5
a18 1
#define	ret(x)	if (lexdebug) printf("lex: x\n"); return x
@


1.1
log
@Original CAKE version from net.sources
@
text
@d306 1
d361 1
@
