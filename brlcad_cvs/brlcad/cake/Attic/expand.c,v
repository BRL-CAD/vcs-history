head	11.3;
access;
symbols
	ansi-20040405-merged:11.2
	premerge-autoconf:11.2
	ansi-20040316-freeze:11.2
	postmerge-20040315-windows:11.2
	premerge-20040315-windows:11.2
	windows-20040315-freeze:11.2
	autoconf-20031203:11.2
	autoconf-20031202:11.2
	phong-branch:11.2.0.12
	photonmap-branch:11.2.0.10
	rel-6-1-DP:11.2
	windows-branch:11.2.0.8
	rel-6-0-2:11.2
	ansi-branch:11.2.0.6
	rel-6-0-1-branch:11.2.0.4
	hartley-6-0-post:11.2
	hartley-6-0-pre:11.2
	rel-6-0-1:11.2
	rel-6-0:11.2
	rel-5-4:11.2
	offsite-5-3-pre:11.2
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:1.4
	rel-4-0:1.3
	rel-3-5:1.1
	rel-3-0:1.1
	AUTOCONF:11.2.0.14;
locks; strict;
comment	@ * @;


11.3
date	2004.03.18.18.15.14;	author erikg;	state dead;
branches;
next	11.2;

11.2
date	97.05.22.16.57.55;	author mike;	state Exp;
branches
	11.2.14.1;
next	11.1;

11.1
date	95.01.05.06.00.05;	author mike;	state Rel4_4;
branches;
next	1.4;

1.4
date	94.10.21.20.50.47;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	91.07.03.22.54.49;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	91.06.12.06.50.40;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	88.06.11.00.55.53;	author mike;	state Original;
branches;
next	;

11.2.14.1
date	2004.03.18.18.10.24;	author erikg;	state dead;
branches;
next	;


desc
@cake
@


11.3
log
@merge of AUTOCONF branch in to HEAD
@
text
@/*
**	Module to expand out commands in patterns and actions.
*/

static	char
rcs_id[] = "$Header: /cvs/brlcad/cake/expand.c,v 11.2 1997/05/22 16:57:55 mike Exp $";

#include	"cake.h"
#include	<ctype.h>

/*
**	Expand any commands in actions. Doing this here instead of
**	in the shell saves time because of cake's command cache.
*/

char *
expand_cmds(str)
reg	char	*str;
{
	extern	char	*get_output();
	reg	char	*s;
	reg	int	n, cmds, offset;
	reg	int	stackp;
	reg	char	*rightbr;
	char		*leftbr_stack[MAXNEST];
	char		*nextbr_stack[MAXNEST];
	char		copybuf[MAXSIZE];
	static	char	buf[MAXSIZE];
	reg	char	*result;

	if (index(str, '[') == NULL)
		return str;

	put_trail("expand_cmds", "start");
	cmds = 0;
	stackp = 0;
	if (strlen(str) >= (unsigned)MAXSIZE)
	{
		fprintf(stderr, "cake internal error: command too long %s\n", str);
		exit_cake(FALSE);
	}

	strcpy(copybuf, str);
	leftbr_stack[stackp] = copybuf;
	nextbr_stack[stackp] = NULL;

	/* Leftbr_stack[stackp] and rightbr enclose commands	   */
	/* for stackp > 0; for stackp == 0 they enclose the string */
	/* Nextbr_stack gives the beginning of the next segment	   */
	/* after the corresponding leftbr; == 0 if not known (yet) */
	/* The top entry on the stack always has nextbr == NULL	   */

	for (s = copybuf; s[0] != '\0'; s++)
	{
		if (s[0] == '[' && s[1] == '[')
		{
			nextbr_stack[stackp] = s;
			if (++stackp >= MAXNEST)
			{
				fprintf(stderr, "cake internal error: command nesting level too deep\n");
				exit_cake(FALSE);
			}

			leftbr_stack[stackp] = s;
			nextbr_stack[stackp] = NULL;
			s++;	/* avoid problems with [[[cmd]] ... */
		}
		or (s[0] == ']' && s[1] == ']')
		{
			if (stackp <= 0)
				continue;

			cmds++;
			rightbr = s;

			leftbr_stack[stackp][0] = '\0';
			leftbr_stack[stackp][1] = '\0';
			rightbr[0] = '\0';
			rightbr[1] = '\0';

			result = get_output(new_name(leftbr_stack[stackp]+2));
			cdebug("expansion [[%s]] => [[%s]]\n", leftbr_stack[stackp]+2, result);

			segcpy(buf, leftbr_stack[stackp-1], nextbr_stack[stackp-1]);
			strcat(buf, result);
			offset = strlen(buf) - 1;
			strcat(buf, rightbr+2);

			if (strlen(buf) >= (unsigned)MAXSIZE)
			{
				fprintf(stderr, "cake: expansion result '%s' is too long\n", buf);
				exit_cake(FALSE);
			}

			stackp--;
			leftbr_stack[stackp] = new_name(buf);
			nextbr_stack[stackp] = NULL;

			/* start next iteration with the */
			/* first character after the ]]  */
			s = leftbr_stack[stackp] + offset;
		}
		or (s[0] == '\\')
		{
			/* don't check next char */
			if (s[1] != '\0')
				s++; 
		}
	}

#ifdef	CAKEDEBUG
	if (entrydebug)
		printf("after expand_cmds: [[%s]]\n", str);
#endif

	if (cmds <= 0)
	{
		put_trail("expand_cmds", "finish");
		return str;
	}
	or (stackp == 0)
	{
		put_trail("expand_cmds", "finish");
		return leftbr_stack[0];
	}

	segcpy(buf, leftbr_stack[0], nextbr_stack[0]);
	for (n = 1; n <= stackp; n++)
		segcat(buf, leftbr_stack[n], nextbr_stack[n]);
	if (strlen(buf) >= (unsigned)MAXSIZE)
	{
		fprintf(stderr, "cake: expansion result '%s' is too long\n", buf);
		exit_cake(FALSE);
	}

	put_trail("expand_cmds", "finish");
	return new_name(buf);
}

void
segcpy(target, left, right)
reg	char	*target, *left, *right;
{
	reg	int	i;
	reg	char	*s;

	if (right == NULL)
		strcpy(target, left);
	else
	{
		for (s = left, i = 0; s != right; s++, i++)
			target[i] = *s;

		target[i] = '\0';
	}
}

void
segcat(target, left, right)
reg	char	*target, *left, *right;
{
	reg	int	i;
	reg	char	*s;

	if (right == NULL)
		strcat(target, left);
	else
	{
		for (s = left, i = strlen(target); s != right; s++, i++)
			target[i] = *s;

		target[i] = '\0';
	}
}

/*
**	Execute the given command and return its output.
**	It is a fatal error for the command to terminate abnormally.
*/

char *
get_output(cmd)
reg	char	*cmd;
{
	extern	char	*mktemp();
	extern	char	*get_out();
	extern	char	*flatten();
	extern	int	cake_proc();
	extern	int	cake_wait();
	char		buf[MAXSIZE];
	int		code;
	reg	char	*out_filename;
	reg	FILE	*fp;
	reg	int	i, c;
	reg	int	pid;
	reg	char	*s, *result;

	put_trail("get_output", "start");
	cdebug("get_output of [%s]\n", cmd);

	/* see if we have tried this command before */
	if ((result = get_out(cmd)) != NULL)
	{
		cdebug("cache yields [%s]\n", result);
		put_trail("get_output", "early finish");
		return result;
	}

	out_filename = get_newname();
	pid = cake_proc(cmd, Exec, out_filename, (Node *) NULL, (int (*)()) NULL, (List *) NULL);
	code = cake_wait(pid);
	if (code != 0 && ! zflag)
	{
		printf("cake, %s: nonzero exit status\n", cmd);
		exit_cake(FALSE);
	}

	if ((fp = fopen(out_filename, "r")) == NULL)
	{
		sprintf(scratchbuf, "cake system error, fopen %s", out_filename);
		perror(scratchbuf);
		exit_cake(FALSE);
	}

	/* convert the chars in file fp to a string */
	i = 0;
	while ((c = getc(fp)) != EOF)
		buf[i++] = c;
	
	buf[i] = '\0';
	fclose(fp);
	if (MAXSIZE <= i)
	{
		printf("cake, %s: output too long\n", cmd);
		exit_cake(FALSE);
	}

#ifndef	LEAVE_DIR
	cdebug("get_output unlink out_filename %s\n", out_filename);
	if (unlink(out_filename) != 0)
	{
		sprintf(scratchbuf, "cake system error, unlink %s", out_filename);
		perror(scratchbuf);
	}
#endif

	/* save the result for posterity */
	s = new_name(flatten(buf));
	new_out(cmd, s);
	cdebug("put result [%s] into cache\n", s);
	put_trail("get_output", "finish");
	return s;
}

/*
**	Flatten the output of commands by converting newlines to spaces
**	and by removing blanks around the edges.
*/

char *
flatten(str)
reg	char	*str;
{
	reg	char	*s;

	/* convert newlines (and formfeeds) to spaces */
	for (s = str; *s != '\0'; s++)
		if (*s == '\n' || *s == '\f')
			*s = ' ';

	/* remove blanks around the edges */
	for (s = str+strlen(str)-1; str <= s && isspace(*s); s--)
		*s = '\0';
	for (s = str; *s != '\0' && isspace(*s); s++)
		;

	return s;
}
@


11.2
log
@Added (void) declarations for IRIX 6 compiler.
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /m/cad/cake/RCS/expand.c,v 11.1 1995/01/05 06:00:05 mike Rel4_4 mike $";
@


11.2.14.1
log
@merge from head
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /cvs/brlcad/cake/expand.c,v 11.2 1997/05/22 16:57:55 mike Exp $";
@


11.1
log
@Release_4_4
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /m/cad/cake/RCS/expand.c,v 1.4 94/10/21 20:50:47 mike Exp $";
d140 1
d158 1
@


1.4
log
@Solaris
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /m/cad/cake/RCS/expand.c,v 1.3 91/07/03 22:54:49 butler Exp Locker: mike $";
@


1.3
log
@changed local variable buf to be static.  Some compilers had trouble
allocating vast space on the call stack.
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /m/cad/cake/RCS/expand.c,v 1.2 91/06/12 06:50:40 mike Exp $";
d37 1
a37 1
	if (strlen(str) >= MAXSIZE)
d89 1
a89 1
			if (strlen(buf) >= MAXSIZE)
d130 1
a130 2

	if (strlen(buf) >= MAXSIZE)
@


1.2
log
@Modified carry_out(), action(), and cake_wait() to return an int,
rather that a "union wait" (aka typedef Wait).
The Cray UNICOS 5.1 /bin/cc seems unable to successfully return
a union.
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /m/cad/cake/RCS/expand.c,v 1.1 88/06/11 00:55:53 mike Original $";
d27 2
a28 1
	char		copybuf[MAXSIZE], buf[MAXSIZE];
@


1.1
log
@Original CAKE version from net.sources
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /mip/zs/src/sys/cake/RCS/expand.c,v 1.14 86/07/19 12:23:01 zs Exp $";
d187 1
a187 1
	extern	Wait	cake_wait();
d189 1
a189 1
	Wait		code;
d210 1
a210 1
	if (code.w_status != 0 && ! zflag)
@
