head	11.12;
access;
symbols
	ansi-20040405-merged:11.9.6.1
	premerge-autoconf:11.11
	ansi-20040316-freeze:11.9
	postmerge-20040315-windows:11.11
	premerge-20040315-windows:11.11
	windows-20040315-freeze:11.9.8.1
	autoconf-20031203:11.11
	autoconf-20031202:11.11
	phong-branch:11.10.0.4
	photonmap-branch:11.10.0.2
	rel-6-1-DP:11.10
	windows-branch:11.9.0.8
	rel-6-0-2:11.9
	ansi-branch:11.9.0.6
	rel-6-0-1-branch:11.9.0.4
	hartley-6-0-post:11.9
	hartley-6-0-pre:11.9
	rel-6-0-1:11.9
	rel-6-0:11.9
	rel-5-4:11.9
	offsite-5-3-pre:11.9
	rel-5-3:11.9
	rel-5-2:11.9
	rel-5-1-branch:11.9.0.2
	rel-5-1:11.9
	rel-5-0:11.8
	rel-5-0-beta:11.7
	rel-4-5:11.3
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:1.22
	rel-4-0:1.10
	rel-3-5:1.3
	rel-3-0:1.3
	AUTOCONF:11.11.0.2;
locks; strict;
comment	@ * @;


11.12
date	2004.03.18.18.15.14;	author erikg;	state dead;
branches;
next	11.11;

11.11
date	2003.09.27.00.17.01;	author morrison;	state Exp;
branches
	11.11.2.1;
next	11.10;

11.10
date	2002.10.11.08.30.55;	author kermit;	state Exp;
branches;
next	11.9;

11.9
date	2000.03.05.17.08.48;	author cjohnson;	state Exp;
branches
	11.9.6.1
	11.9.8.1;
next	11.8;

11.8
date	99.06.10.15.31.08;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	98.10.27.20.23.36;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	98.08.22.22.45.59;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	98.08.22.22.28.32;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	98.08.21.21.47.30;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	97.11.22.05.47.28;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	97.05.22.16.57.55;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.05.06.00.07;	author mike;	state Rel4_4;
branches;
next	1.22;

1.22
date	94.12.21.16.42.56;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	94.12.21.16.34.04;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	94.12.09.08.59.45;	author jra;	state Exp;
branches;
next	1.19;

1.19
date	94.12.07.16.55.17;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	94.11.08.04.45.07;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	94.11.03.13.55.41;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	94.09.22.01.48.35;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	93.11.04.19.10.12;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	93.11.04.18.50.21;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	93.08.25.18.16.14;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	93.08.25.17.31.29;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	93.08.25.13.27.03;	author butler;	state Exp;
branches;
next	1.10;

1.10
date	91.09.20.23.35.00;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	91.09.10.16.38.48;	author butler;	state Exp;
branches;
next	1.8;

1.8
date	91.07.10.02.06.31;	author butler;	state Exp;
branches;
next	1.7;

1.7
date	91.07.10.01.13.07;	author butler;	state Exp;
branches;
next	1.6;

1.6
date	90.11.27.16.46.37;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	90.04.21.01.45.05;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	90.04.14.16.39.03;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	88.09.17.05.34.43;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	88.06.11.01.00.38;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	88.06.11.00.56.01;	author mike;	state Original;
branches;
next	;

11.9.6.1
date	2004.03.17.21.15.52;	author morrison;	state Exp;
branches;
next	;

11.9.8.1
date	2004.03.11.23.40.27;	author morrison;	state Exp;
branches;
next	;

11.11.2.1
date	2004.03.18.18.10.24;	author erikg;	state dead;
branches;
next	;


desc
@cake source file 
@


11.12
log
@merge of AUTOCONF branch in to HEAD
@
text
@/*
**	Cake main file.
*/

static	char
rcs_id[] = "$Header: /cvs/brlcad/cake/main.c,v 11.11 2003/09/27 00:17:01 morrison Exp $";

#include	"cake.h"
#if __STDC__
# include <unistd.h>
#else
# if defined(__sgi) && defined(__mips)
	extern	unsigned short	geteuid();
# endif
#endif
#include	<pwd.h>
#include	<signal.h>
#include	<sys/stat.h>

typedef	struct	passwd	Pwent;
typedef	struct	stat	Stat;

#if !defined(__convex__) && !__STDC__ && !__EXTENSIONS__
extern	Pwent	*getpwuid();
#endif

#if __STDC__ && !defined(CRAY2)
extern char	*tempnam(const char *, const char *);
#else
# if defined(ATT)
extern char	*tempnam();
# else
/* On non-ANSI BSD systems, use mktemp instead */
#  define USE_MKTEMP	1
static char	template[] = "/tmp/cakeXXXXX";
# endif
#endif

int	Gflag = FALSE;
int	Lflag = FALSE;
int	Rflag = FALSE;
int	Xflag = FALSE;
int	Zflag = FALSE;
int	bflag = FALSE;
int	cflag = FALSE;
int	dflag = FALSE;
int	gflag = FALSE;
int	iflag = FALSE;
int	kflag = TRUE;
int	nflag = FALSE;
int	qflag = FALSE;
int	rflag = FALSE;
int	sflag = FALSE;
int	tflag = FALSE;
int	vflag = FALSE;
int	wflag = FALSE;
int	xflag = FALSE;
int	zflag = FALSE;

char	*cakefile  = NULL;		/* also used in entry.c */
char	*shellfile[2] = { SYSTEM_CMD, SCRIPT_CMD };
char	*metachars = METACHARS;
int	maxprocs   = 1;
List	*active_procs;
char	scratchbuf[128];

int	cakedebug	= FALSE;
int	entrydebug	= FALSE;
int	patdebug	= FALSE;
int	lexdebug	= FALSE;

char	cakeflagbuf[MAXSIZE];
char	*cppargv[MAXARGS];
int	cppargc = 0;

#if defined(YACC_DEBUG)
extern	int	yydebug;
#endif

extern	void	statistics();


/*
**	Tell the unfortunate user how to use cake.
*/
void
usage()
{
	fprintf(stderr, "Usage: cake [-abcdgiknqrstvwxzGLRXZ] [-ffile]\n");
	fprintf(stderr, "       [-Ddefn] [-Idir] [-Uname] [-S shell] [-T metachars] [file ...]\n");
	exit(1);
}

int
process_args(vector, count, base)
reg	char	**vector;
reg	int	*count;
reg	int	base;
{
	reg	int	i, j;

	j = 0;
	cdebug("process args:");
	while (*count > base && vector[base][0] == '-')
	{
		putflag(base, vector[base]);

		for (i = 1; vector[base][i] != '\0'; i++)
		{
			switch (vector[base][i])
			{

#ifdef	CAKEDEBUG
		case 'C':	cdebug(" -C");
				cakedebug  = ! cakedebug;
				break;
		
		case 'E':	cdebug(" -E");
				entrydebug = ! entrydebug;
				break;
		
		case 'P':	cdebug(" -P");
				patdebug   = ! patdebug;
				break;
		
		case 'W':	cdebug(" -W");
				lexdebug   = TRUE;
				break;
		
#if defined(YACC_DEBUG)
		case 'Y':	cdebug(" -Y");
				yydebug    = TRUE;
				break;
#endif /* YACC_DEBUG */
#endif /* CAKEDEBUG */
		case 'G':	cdebug(" -G");
				Gflag = TRUE;
				break;
		
		case 'L':	cdebug(" -L");
				Lflag = TRUE;
				break;
		
		case 'R':	cdebug(" -R");
				Rflag = TRUE;
				break;
		
		case 'X':	cdebug(" -X");
				Xflag = TRUE;
				break;
		
		case 'Z':	cdebug(" -Z");
				Zflag = TRUE;
				break;
		
		case 'a':	cdebug(" -a");
				kflag = FALSE;
				break;
		
		case 'b':	cdebug(" -b");
				bflag = TRUE;
				break;
		
		case 'c':	cdebug(" -c");
				cflag = TRUE;
				break;
		
		case 'd':	cdebug(" -d");
				dflag = TRUE;
				break;
		
		case 'g':	cdebug(" -g");
				gflag = TRUE;
				break;
		
		case 'i':	cdebug(" -i");
				iflag = TRUE;
				break;
		
		case 'k':	cdebug(" -k");
				kflag = TRUE;
				break;
		
		case 'n':	cdebug(" -n");
				nflag = TRUE;
				tflag = FALSE;
				qflag = FALSE;
				break;
		
		case 'q':	cdebug(" -q");
				qflag = TRUE;
				nflag = FALSE;
				tflag = FALSE;
				break;
		
		case 'r':	cdebug(" -r");
				rflag = TRUE;
				break;
		
		case 's':	cdebug(" -s");
				sflag = TRUE;
				break;
		
		case 't':	cdebug(" -t");
				tflag = TRUE;
				nflag = FALSE;
				qflag = FALSE;
				break;
		
		case 'v':	cdebug(" -v");
				vflag = TRUE;
				break;
		
		case 'w':	cdebug(" -w");
				wflag = TRUE;
				break;
		
		case 'x':	cdebug(" -x");
				xflag = TRUE;
				break;
		
		case 'z':	cdebug(" -z");
				zflag = TRUE;
				break;
		
		case 'D':
		case 'I':
		case 'U':	if (i != 1)
					usage();

				cdebug(" %s", vector[base]);
				cppargv[cppargc++] = new_name(vector[base]);
				goto nextword;
		
		case 'N':	putflag(base, vector[base+1]);
				sscanf(vector[base+1], "%d", &maxprocs);
				if (vector[base][i+1] != '\0')
					usage();

				cdebug(" -N %d", maxprocs);
				(*count)--;
				vector++, j++;
				goto nextword;
		
		case 'S':	putflag(base, vector[base+1]);
				if (vector[base][i+1] == '1')
					shellfile[0] = new_name(vector[base+1]);
				or (vector[base][i+1] == '2')
					shellfile[1] = new_name(vector[base+1]);
				else
					usage();

				if (vector[base][i+2] != '\0')
					usage();

				cdebug(" -S%c %s", vector[base][i+1], vector[base+1]);
				(*count)--;
				vector++, j++;
				goto nextword;
		
		case 'T':	putflag(base, vector[base+1]);
				metachars = new_name(vector[base+1]);
				if (vector[base][i+1] != '\0')
					usage();

				cdebug(" -T %s", metachars);
				(*count)--;
				vector++, j++;
				goto nextword;
		
		case 'f':	putflag(base, vector[base+1]);
				cakefile = new_name(vector[base+1]);
				if (vector[base][i+1] != '\0')
					usage();

				cdebug(" -f %s", cakefile);
				(*count)--;
				vector++, j++;
				goto nextword;

		default:	usage();
			}
		}

nextword:
		(*count)--;
		vector++, j++;
	}

	cdebug(" \nreturn %d\n", j);	/* BRL MOD */
	return j;
}

/*
**	Put a flag into the CAKEFLAGS definition.
*/
void
putflag(base, flag)
reg	int	base;
reg	char	*flag;
{
	if (base == 1)
	{
		strcat(cakeflagbuf, " ");
		strcat(cakeflagbuf, flag);
		if (strlen(cakeflagbuf) >= (unsigned)MAXSIZE)
		{
			fprintf(stderr, "cake: CAKEFLAGS too long\n");
			exit(1);
		}
	}
}

void
exit_cake(needtrail)
reg	int	needtrail;
{
	if (cakedebug && needtrail)
		get_trail(stdout);
	else
		dir_finish();

	exit(1);
}

/*
**	Handle bus errors and segmentation violations.
*/
void
cake_abort(signo)
int	signo;
{

	signal(SIGINT,  SIG_IGN);
	signal(SIGQUIT, SIG_IGN);

	printf("cake: aborting on signal %d\n", signo);
	if (cakedebug)
		get_trail(stdout);

	signal(SIGQUIT, SIG_DFL);
	kill(getpid(), SIGQUIT);
}

/*
**	Handle user interrupts.
*/

void
cake_finish(sig)
int	sig;
{
	reg	List	*ptr;
	reg	Proc	*proc;

	signal(SIGINT,  SIG_IGN);
	signal(SIGQUIT, SIG_IGN);

	printf("*** Interrupt\n");
	fflush(stdout);
	for_list (ptr, active_procs)
	{
		proc = (Proc *) ldata(ptr);
		if (proc->pr_node != NULL)
			cake_error(proc->pr_node);
	}

	exit_cake(FALSE);
}

/*
 *			I S _ E X E C U T A B L E
 *
 *  Returns -
 *	0	path does not exist, or is not executable
 *	1	path is executable
 */
int
is_executable( file )
char *file;
{
	Stat		statbuf;

	if( stat( file, &statbuf ) != 0 )  return 0;
	if( (statbuf.st_mode & 0111) == 0 ) return 0;
	return 1;
}

/*
 *			B U I L D _ C P P A R G V
 *
 *  Run the external program "machinetype.sh" to determine the
 *  type of system we are currently running on, and use that to
 *  corral up the proper options for this system.
 *  This is done at runtime now, rather that compile time,
 *  because one binary of CAKE might be run on a system other than
 *  it was compiled for, e.g. an Irix5.3 binary running on an Irix6.2
 *  system.
 */
void
build_cppargv()
{
	static char	buf[512];
	char	buf2[512*2];
	int	len;
	FILE	*fp;
	Wait	status;

	if( buf[0] == '\0' )  {
		/* First time through, run shell script */

		if( (fp = popen( "machinetype.sh -m", "r" ) ) == NULL )  {
			fprintf(stderr, "cake:  Unable to run \"machinetype.sh\" to determine system type, aborting.\nCheck your $PATH variable.\n");
			exit(42);
		}
		if( fgets( buf, sizeof(buf)-2, fp ) == NULL )  {
			fprintf(stderr, "cake:  \"machinetype.sh\" returned null string, unable to determine system type, aborting.\nTry running machinetype.sh -v manually before proceeding.\n");
			exit(42);
		}
		fclose(fp);

		/* Slurp up dead process indication from popen() */
#if defined(__convexc__) || defined(__bsdi__) || defined(__FreeBSD__)
		while (wait(&status.w_status) != -1) ;
#else
		while (wait(&status) != -1) ;
#endif

		/* Ensure proper null termination, even if string overran buffer */
		buf[sizeof(buf)-1] = '\0';
		buf[sizeof(buf)-2] = '\0';
		len = strlen(buf);
		if( buf[len-1] == '\n' )  buf[len-1] = '\0';
	}

	/* Trudge through all the possibilities */
	if( strcmp( buf, "fbsd" ) == 0 ) {
		/* GNU compiler */
		cppargv[cppargc++] = new_name("/usr/bin/cpp");
		cppargv[cppargc++] = new_name("-E");
		cppargv[cppargc++] = new_name("-traditional");
		goto out;
	}
	if( strcmp( buf, "vax" ) == 0 )  {
		/* VAX 11/780, mircoVAX, etc. */
		cppargv[cppargc++] = new_name("cc");
		cppargv[cppargc++] = new_name("-E");	
		goto out;
	}
	if( strcmp( buf, "mips" ) == 0 )  {
		/* DECStation with MIPS chip */
		cppargv[cppargc++] = new_name("cc");
		cppargv[cppargc++] = new_name("-E");	
		goto out;
	}
	if( strcmp( buf, "c1" ) == 0 )  {
		/* CPP is necessary on the Convex, cc -E needs .c suffix */
		cppargv[cppargc++] = new_name("/lib/cpp");
		cppargv[cppargc++] = new_name("-pcc");
		goto out;
	}
	if( strcmp( buf, "cr2" ) == 0 )  {
		/* Cray-2 */
		cppargv[cppargc++] = new_name("/lib/cpp");
		cppargv[cppargc++] = new_name("-N");
		goto out;
	}
	if( strcmp( buf, "xmp" ) == 0 )  {
		/* Cray XMP */
		cppargv[cppargc++] = new_name("/lib/cpp");
		cppargv[cppargc++] = new_name("-N");
		goto out;
	}
	if( strcmp( buf, "li" ) == 0 )  {
		/* Linux with GNU CPP */
#if 0
		/* This worked with Redhat 4 */
		cppargv[cppargc++] = new_name("/lib/cpp");
		cppargv[cppargc++] = new_name("-traditional");
#endif
		/* For RedHat 5 */
		cppargv[cppargc++] = new_name("cc");
		cppargv[cppargc++] = new_name("-E");
		cppargv[cppargc++] = new_name("-traditional");
		goto out;
	}
	if( strcmp( buf, "next" ) == 0 )  {
		/* Next with Gnu CPP */
		cppargv[cppargc++] = new_name("/lib/cpp");
		cppargv[cppargc++] = new_name("-traditional");
		goto out;
	}
	if( strcmp( buf, "sun5" ) == 0 )  {
#if defined( __GNUC__ )
		/* GNU compiler */
		cppargv[cppargc++] = new_name("gcc");
		cppargv[cppargc++] = new_name("-E");
		cppargv[cppargc++] = new_name("-traditional");
#else
		/* SunOS 5 with unbundled compilers
		 * WARNING:  Make sure /opt/SUNWspro/bin is ahead of /usr/ucb
		 * in your path.
		 * /opt/SUNWspro/bin/cc -E puts unwanted spaces around
		 * substitutions so fall back to old SunC mode
		 */
		cppargv[cppargc++] = new_name("cc");
		cppargv[cppargc++] = new_name("-E");
		cppargv[cppargc++] = new_name("-Xs");
#endif
		goto out;
	}
	if( strcmp( buf, "sp3" ) == 0 )  {
		cppargv[cppargc++] = new_name("gcc");
		cppargv[cppargc++] = new_name("-E");
		cppargv[cppargc++] = new_name("-traditional");
		goto out;
	}

	/*
	 *  Notes:
	 *  On the SGI, cc -E appends a space after each substitution,
	 *  need to use /lib/cpp.
	 */

	/*
	 *  The default case:  Look for /lib/cpp, then cc -E
	 */
	if( is_executable( "/lib/cpp" ) )  {
		cppargv[cppargc++] = new_name("/lib/cpp");
		goto out;
	}
	if( is_executable( "/usr/lib/cpp" ) )  {
		cppargv[cppargc++] = new_name("/usr/lib/cpp");
		goto out;
	}
	if( is_executable( "/bin/cpp" ) )  {
		cppargv[cppargc++] = new_name("/bin/cpp");
		goto out;
	}
	if( is_executable( "/usr/bin/cpp" ) )  {
		cppargv[cppargc++] = new_name("/usr/bin/cpp");
		goto out;
	}
	if( is_executable( "/bin/cc" ) )  {
		cppargv[cppargc++] = new_name("/bin/cc");
		cppargv[cppargc++] = new_name("-E");
		goto out;
	}
	if( is_executable( "/usr/bin/cc" ) )  {
		cppargv[cppargc++] = new_name("/usr/bin/cc");
		cppargv[cppargc++] = new_name("-E");
		goto out;
	}
	if( is_executable( "/usr/ucb/cc" ) )  {
		cppargv[cppargc++] = new_name("/usr/ucb/cc");
		cppargv[cppargc++] = new_name("-E");
		goto out;
	}
	fprintf(stderr,
"cake: unable to locate c-preprocessor as /lib/cpp, /bin/cc, or /usr/bin/cc\n\
and no special built-in support for machine type '%s', aborting.\n",
		buf);
	exit(42);

	/* Add final argument of -D__CAKE__`machinetype.sh` */
out:
	sprintf( buf2, "-D__CAKE__%s", buf );
	cppargv[cppargc++] = new_name(buf2);

	/* The runtime environment variable overrides compile-time one */
	if( getenv("BRLCAD_ROOT") == NULL )  {
#if defined(BRLCAD_ROOT_STRING)
		sprintf( buf2, "-DBRLCAD_ROOT=%s", BRLCAD_ROOT_STRING );
		cppargv[cppargc++] = new_name(buf2);
#endif
	} else {
		sprintf( buf2, "-DBRLCAD_ROOT=%s", getenv("BRLCAD_ROOT") );
		cppargv[cppargc++] = new_name(buf2);
	}

	return;
}

/*
 *			M A I N
 */
main(argc, argv)
int	argc;
char	**argv;
{
	Stat		statbuf;
	int		envc;
	char		*envv[MAXARGS];
	reg	Pwent	*pwent;
	reg	char	*envstr;
	reg	int	status;
	reg	Node	*rootnode;
	char		*newcakefile;		/* /tmp/cakef###.c, for CC -E */

	signal(SIGINT,  cake_finish);
	signal(SIGQUIT, cake_finish);
	if(cakedebug)  {
		/* If debugging enabled, catch signals to do get_trail() */
		signal(SIGILL,  cake_abort);
		signal(SIGTRAP, cake_abort);
		signal(SIGIOT,  cake_abort);
#ifdef SIGEMT
		signal(SIGEMT,  cake_abort);
#endif
		signal(SIGFPE,  cake_abort);
		signal(SIGBUS,  cake_abort);
		signal(SIGSEGV, cake_abort);
#ifdef SIGSYS
		signal(SIGSYS,  cake_abort);
#endif
	}
	signal(SIGPIPE, cake_abort);
	signal(SIGALRM, cake_abort);

#if defined(YACC_DEBUG)
	yydebug = FALSE;
#endif
	active_procs = makelist0();

	if (rindex(argv[0], 'f') != NULL
	&&  streq(rindex(argv[0], 'f'), "fake"))
		cakedebug = TRUE;

	init_sym();

	build_cppargv();

	strcpy(cakeflagbuf, "-DCAKEFLAGS=");

	if ((envstr = getenv("CAKE")) != NULL)
	{
		envc = parse_args(envstr, envv);
		process_args(envv, &envc, 0);
		if (envc > 0)
			fprintf(stderr, "cake: non-options in environment ignored\n");
	}

	argv += process_args(argv, &argc, 1);

#if defined(CAKEDEBUG) && !defined(ATT)
	if (cakedebug || entrydebug || patdebug || lexdebug)
		setlinebuf(stdout);
#endif

	if (cakefile == NULL)
	{
		if (stat("cakefile", &statbuf) == 0)
			cakefile = "cakefile";
		or (stat("Cakefile", &statbuf) == 0)
			cakefile = "Cakefile";
		or (stat("recipe", &statbuf) == 0)
			cakefile = "recipe";
		or (stat("Recipe", &statbuf) == 0)
			cakefile = "Recipe";
		else
		{
			fprintf(stderr, "cake: cannot locate a cakefile\n");
			exit(1);
		}
	}

	if (gflag)
		cakefile = dir_setup(cakefile);		/* changes directory */

	/*
	 *  In order to use more modern CC -E commands, the name of
	 *  the Cakefile string has to end in a ".c".
	 *  So, copy the cakefile into /tmp, and pre-process that one.
	 *  -Mike Muuss, ARL, 25-Aug-93.
	 */
	{
		char	*newbase;
		char	cmd[256];

#if USE_MKTEMP
		(void)mktemp(template);
		newbase = template;
#else
		newbase = tempnam((char *)NULL, "cakef");
		if( newbase == NULL )  exit(17);
#endif
		newcakefile = malloc(strlen(newbase)+3);	/* room for .c */
		if( newcakefile == NULL )  exit(18);
		strcpy( newcakefile, newbase );
		strcat( newcakefile, ".c" );
		free(newbase);

		sprintf(cmd, "cp %s %s", cakefile, newcakefile);
		system(cmd);
	}

	if( (pwent = getpwuid(geteuid())) == (Pwent *)0 )  {
		printf("cake: Warning: unable to get home directory for uid %d\n",
			geteuid() );
	} else {
		strcpy(scratchbuf, "-I");
		strcat(scratchbuf, pwent->pw_dir);
		strcat(scratchbuf, ULIB);
		cppargv[cppargc++] = new_name(scratchbuf);
	}
	strcpy(scratchbuf, "-I");
	strcat(scratchbuf, SLIB);
	cppargv[cppargc++] = new_name(scratchbuf);
	cppargv[cppargc++] = cakeflagbuf;
#if 0
	cppargv[cppargc++] = cakefile;
#else
	cppargv[cppargc++] = "-I.";
	cppargv[cppargc++] = newcakefile;
#endif
	cppargv[cppargc]   = NULL;

	if (cakedebug)
	{
		reg	int	i;

		for (i = 0; i < cppargc; i++)
			printf("%s ", cppargv[i]);
		printf("\n");
	}

	if ((yyin = cake_popen(cppargv, "r")) == NULL)
	{
		fprintf(stderr, "cake: cannot open cpp filter\n");
		(void)unlink(newcakefile);
		exit(1);
	}
 

	if (Zflag)
	{
		reg	int	c;

		while ((c = getc(yyin)) != EOF)
			putchar(c);

		cake_pclose(yyin);
		(void)unlink(newcakefile);
		exit(0);
	}

	yyinit();
	init_entry();
	if (yyparse())
	{
		fprintf(stderr, "cake: cannot parse %s\n", cakefile);
		exit(1);
	}

	shell_setup(shellfile[0], 0);
	shell_setup(shellfile[1], 1);
	meta_setup(metachars);

	cake_pclose(yyin);
	(void)unlink(newcakefile);

	dir_start();
	prep_entries();
	final_entry(argc, argv);

	rootnode = chase(CHASEROOT, 0, (Entry *) NULL);

	if (! qflag)
		execute(rootnode);
	
	dir_finish();
	cleanup();
#ifdef	STATS_FILE
	statistics();
#endif

	status = (off_node(rootnode, nf_ERR) && is_ok(rootnode))? 0: 1;
	cdebug("exit status %d\n", status);
	exit(status);
}



#ifdef	STATS_FILE
#ifdef	ATT
#include	<sys/times.h>

typedef	struct	tms	Tms;
#else
#include	<sys/time.h>
#include	<sys/resource.h>

typedef	struct	rusage	Rusage;
#endif

void
statistics()
{
	extern	char	*getlogin();
#ifdef ANTIQUE
	extern		getpw();	/* ancient */
#endif

	extern	int	out_tried, out_found;
	extern	int	stat_tried, stat_found;
	FILE		*sfp;

	if ((sfp = fopen(STATS_FILE, "a")) != NULL)
	{
#ifdef	ATT
		Tms	tbuf;
#else
		Rusage	s, c;
#endif
		long	su, ss, cu, cs;
		char	*usr;

		if ((usr = getlogin()) == NULL)
		{
#ifdef ANTIQUE
			char	buf[256];
			char	*usr_end;

			if (getpw(getuid(), buf) != 0)

				usr = "NULL";
			else
			{
				usr = buf;
				if ((usr_end = index(usr, ':')) != NULL)
					*usr_end = '\0';
				else
					usr = "NULL";
			}
#else
			struct	passwd *pwent;

			if ((pwent = getpwent()) == NULL)
				usr = "NULL";
			else
				usr = pwent->pw_name;
#endif
			usr = new_name(usr);
		}

#ifdef	ATT
		if (times(&tbuf) == -1)
		{
			fclose(sfp);
			return;
		}

		su = tbuf.tms_utime*100/TIMERES;
		ss = tbuf.tms_stime*100/TIMERES;
		cu = tbuf.tms_cutime*100/TIMERES;
		cs = tbuf.tms_cstime*100/TIMERES;
#else
		getrusage(RUSAGE_SELF,     &s);
		getrusage(RUSAGE_CHILDREN, &c);

		su = s.ru_utime.tv_sec*100 + s.ru_utime.tv_usec/10000;
		ss = s.ru_stime.tv_sec*100 + s.ru_stime.tv_usec/10000;
		cu = c.ru_utime.tv_sec*100 + c.ru_utime.tv_usec/10000;
		cs = c.ru_stime.tv_sec*100 + c.ru_stime.tv_usec/10000;
#endif
		fprintf(sfp, "%s %ld %ld %ld %ld ", usr, su, ss, cu, cs);
		fprintf(sfp, "%d %d %d %d %d\n", sbrk(0),
			out_tried, out_found, stat_tried, stat_found);

		fclose(sfp);
	}
}
#endif
@


11.11
log
@remove hard coded path to gcc for aix for the preprocessor
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /c/CVS/brlcad/cake/main.c,v 11.10 2002/10/11 08:30:55 kermit Exp $";
@


11.11.2.1
log
@merge from head
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /cvs/brlcad/cake/main.c,v 11.11 2003/09/27 00:17:01 morrison Exp $";
@


11.10
log
@Added initial support for IBM SP "Scalable Parallel" system running AIX.
Static build fully functional, still needs more work on shared build.
OpenGL support works, but there are issues communicatiing with mged.
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /c/CVS/brlcad/cake/main.c,v 11.9 2000/03/05 17:08:48 cjohnson Exp $";
d513 1
a513 1
		cppargv[cppargc++] = new_name("/usr/local/bin/gcc");
@


11.9
log
@/usr/bin/cpp for gcc under fbsd needs the -traditional flag to get rid
of extra spaces around macro substituion.
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /c/CVS/brlcad/cake/main.c,v 11.8 1999/06/10 15:31:08 mike Exp $";
d510 6
@


11.9.6.1
log
@sync branch with HEAD
@
text
@d6 1
a6 1
rcs_id[] = "$Header$";
a509 6
		goto out;
	}
	if( strcmp( buf, "sp3" ) == 0 )  {
		cppargv[cppargc++] = new_name("gcc");
		cppargv[cppargc++] = new_name("-E");
		cppargv[cppargc++] = new_name("-traditional");
@


11.9.8.1
log
@sync to HEAD...
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /n/cad/c/CVS/brlcad/cake/main.c,v 11.11 2003/09/27 00:17:01 morrison Exp $";
a509 6
		goto out;
	}
	if( strcmp( buf, "sp3" ) == 0 )  {
		cppargv[cppargc++] = new_name("gcc");
		cppargv[cppargc++] = new_name("-E");
		cppargv[cppargc++] = new_name("-traditional");
@


11.8
log
@
Silenced warnings on FreeBSD
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /c/CVS/brlcad/cake/main.c,v 11.7 1998/10/27 20:23:36 mike Exp $";
d437 7
@


11.7
log
@Modified for RedHat 5 Linux
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /c/CVS/brlcad/cake/main.c,v 11.6 1998/08/22 22:45:59 mike Exp $";
d423 1
a423 1
#if defined(__convexc__) || defined(__bsdi__)
@


11.6
log
@Changed CAKE so that the runtime environment variable BRLCAD_ROOT will
override the compile-time setting
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /c/CVS/brlcad/cake/main.c,v 11.5 1998/08/22 22:28:32 mike Exp $";
d469 2
d472 5
@


11.5
log
@Changed to BRLCAD_ROOT
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /c/CVS/brlcad/cake/main.c,v 11.4 1998/08/21 21:47:30 mike Exp $";
d550 2
d553 2
a554 2
	sprintf( buf2, "-DBRLCAD_ROOT=%s", BRLCAD_ROOT_STRING );
	cppargv[cppargc++] = new_name(buf2);
d556 4
@


11.4
log
@Makefile modified to obtain BINDIR from machinetype.sh
CAKE program itself modified to pass BRLCAD_BASEDIR_STRING through to cpp.
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /c/CVS/brlcad/cake/main.c,v 11.3 1997/11/22 05:47:28 mike Exp $";
d550 2
a551 2
#if defined(BRLCAD_BASEDIR_STRING)
	sprintf( buf2, "-DBRLCAD_BASEDIR=%s", BRLCAD_BASEDIR_STRING );
@


11.3
log
@All the auto-configuration of machinetype moved to runtime
from conf.h.
This was necessary because the cake binary may be moved between
different machines which can still run CAKE, but which need different
cc options to build the BRL-CAD tools.
For example, moving an Irix 5.3 cake binary onto an Irix 6.2/3/4 platform.
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /m/cad/cake/RCS/main.c,v 11.2 1997/05/22 16:57:55 mike Exp mike $";
d403 2
a404 2
	char	buf[128];
	char	buf2[128*2];
d409 12
a420 9
	if( (fp = popen( "machinetype.sh -m", "r" ) ) == NULL )  {
		fprintf(stderr, "cake:  Unable to run \"machinetype.sh\" to determine system type, aborting.\nCheck your $PATH variable.\n");
		exit(42);
	}
	if( fgets( buf, sizeof(buf)-2, fp ) == NULL )  {
		fprintf(stderr, "cake:  \"machinetype.sh\" returned null string, unable to determine system type, aborting.\nTry running machinetype.sh -v manually before proceeding.\n");
		exit(42);
	}
	fclose(fp);
d422 1
a422 1
	/* Slurp up dead process indication from popen() */
d424 1
a424 1
	while (wait(&status.w_status) != -1) ;
d426 1
a426 1
	while (wait(&status) != -1) ;
d429 6
a434 5
	/* Ensure proper null termination, even if string overran buffer */
	buf[sizeof(buf)-1] = '\0';
	buf[sizeof(buf)-2] = '\0';
	len = strlen(buf);
	if( buf[len-1] == '\n' )  buf[len-1] = '\0';
d549 6
@


11.2
log
@Added (void) declarations for IRIX 6 compiler.
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /m/cad/cake/RCS/main.c,v 11.1 1995/01/05 06:00:07 mike Rel4_4 mike $";
d371 180
d594 3
a596 10
	cppargv[cppargc++] = new_name(CPP);
#if defined(CPP_OPTIONS)
	cppargv[cppargc++] = new_name(CPP_OPTIONS);	
#endif
#if defined(CPP_OPTIONS2)
	cppargv[cppargc++] = new_name(CPP_OPTIONS2);
#endif
#if defined(CPP_OPTIONS3)
	cppargv[cppargc++] = new_name(CPP_OPTIONS3);
#endif
@


11.1
log
@Release_4_4
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /m/cad/cake/RCS/main.c,v 1.22 94/12/21 16:42:56 mike Exp $";
d297 1
a297 1

@


1.22
log
@Old BSD systems (like VGR) don't have tempnam().
Use mktemp().
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /m/cad/cake/RCS/main.c,v 1.21 94/12/21 16:34:04 mike Exp Locker: mike $";
@


1.21
log
@yydebug isn't always available.  Let's not mess with it.
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /m/cad/cake/RCS/main.c,v 1.20 94/12/09 08:59:45 jra Exp Locker: mike $";
d30 1
d32 5
d471 4
d477 1
@


1.20
log
@mod for CRAY2
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /n/wolf/m/cad/cake/RCS/main.c,v 1.19 94/12/07 16:55:17 mike Exp Locker: jra $";
d70 1
d72 1
d124 1
d128 2
a129 1
#endif
d398 1
d400 1
@


1.19
log
@Linux does not support the full range of UNIX signals.
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /m/cad/cake/RCS/main.c,v 1.18 94/11/08 04:45:07 mike Exp Locker: mike $";
d27 1
a27 1
#if __STDC__
@


1.18
log
@tempnam() isn't "standard".
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /m/cad/cake/RCS/main.c,v 1.17 94/11/03 13:55:41 mike Exp Locker: mike $";
d381 1
d383 1
d387 1
d389 1
@


1.17
log
@Eliminated use of 'when' macro.
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /m/cad/cake/RCS/main.c,v 1.16 94/09/22 01:48:35 mike Exp Locker: mike $";
d25 6
@


1.16
log
@Glenn put the #if block before the definition for Pwent, rather than
after it.
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /m/cad/cake/RCS/main.c,v 1.15 93/11/04 19:10:12 mike Exp Locker: mike $";
d100 1
a100 1
		when 'C':	cdebug(" -C");
d102 1
d104 1
a104 1
		when 'E':	cdebug(" -E");
d106 1
d108 1
a108 1
		when 'P':	cdebug(" -P");
d110 1
d112 1
a112 1
		when 'W':	cdebug(" -W");
d114 1
d116 1
a116 1
		when 'Y':	cdebug(" -Y");
d118 1
d120 1
a120 1
		when 'G':	cdebug(" -G");
d122 1
d124 1
a124 1
		when 'L':	cdebug(" -L");
d126 1
d128 1
a128 1
		when 'R':	cdebug(" -R");
d130 1
d132 1
a132 1
		when 'X':	cdebug(" -X");
d134 1
d136 1
a136 1
		when 'Z':	cdebug(" -Z");
d138 1
d140 1
a140 1
		when 'a':	cdebug(" -a");
d142 1
d144 1
a144 1
		when 'b':	cdebug(" -b");
d146 1
d148 1
a148 1
		when 'c':	cdebug(" -c");
d150 1
d152 1
a152 1
		when 'd':	cdebug(" -d");
d154 1
d156 1
a156 1
		when 'g':	cdebug(" -g");
d158 1
d160 1
a160 1
		when 'i':	cdebug(" -i");
d162 1
d164 1
a164 1
		when 'k':	cdebug(" -k");
d166 1
d168 1
a168 1
		when 'n':	cdebug(" -n");
d172 1
d174 1
a174 1
		when 'q':	cdebug(" -q");
d178 1
d180 1
a180 1
		when 'r':	cdebug(" -r");
d182 1
d184 1
a184 1
		when 's':	cdebug(" -s");
d186 1
d188 1
a188 1
		when 't':	cdebug(" -t");
d192 1
d194 1
a194 1
		when 'v':	cdebug(" -v");
d196 1
d198 1
a198 1
		when 'w':	cdebug(" -w");
d200 1
d202 1
a202 1
		when 'x':	cdebug(" -x");
d204 1
d206 1
a206 1
		when 'z':	cdebug(" -z");
d208 1
d210 1
a210 1
		when 'D':
d219 1
a219 1
		when 'N':	putflag(base, vector[base+1]);
d229 1
a229 1
		when 'S':	putflag(base, vector[base+1]);
d245 1
a245 1
		when 'T':	putflag(base, vector[base+1]);
d255 1
a255 1
		when 'f':	putflag(base, vector[base+1]);
d265 1
a265 1
		otherwise:	usage();
@


1.15
log
@SunOS 5 support
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /m/cad/cake/RCS/main.c,v 1.14 93/11/04 18:50:21 mike Exp Locker: mike $";
d20 3
a25 3

typedef	struct	passwd	Pwent;
typedef	struct	stat	Stat;
@


1.14
log
@ANSI C
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /m/cad/cake/RCS/main.c,v 1.13 93/08/25 18:16:14 mike Exp Locker: mike $";
d372 3
@


1.13
log
@Modified to compile on ANSI compilers
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /m/cad/cake/RCS/main.c,v 1.12 93/08/25 17:31:29 mike Exp Locker: mike $";
d66 3
d264 1
a264 1
		if (strlen(cakeflagbuf) >= MAXSIZE)
d420 1
a420 1
		newbase = tempnam(NULL, "cakef");
d531 1
@


1.12
log
@Modified to copy Cakefile into /tmp/cakefXXX.c, so that cc -E
can optionally be used.
Note that cc -E often puts spaces on the end of tokens that
were macro substituted, so this is less useful than originally anticipated.
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /m/cad/cake/RCS/main.c,v 1.11 93/08/25 13:27:03 butler Exp Locker: mike $";
d9 1
a9 1
#if defined(__sgi) && defined(__mips)
d11 4
d20 4
a329 14
	extern	int	parse_args();
	extern	Node	*chase();
	extern	char	*getenv();
	extern	char	*dir_setup();
#if !defined(__convex__) && !__STDC__ && !__EXTENSIONS__
	extern	Pwent	*getpwuid();
#endif
#if defined(__sgi) && defined(__mips)
	extern	unsigned short	geteuid();
#else
	extern	int	geteuid();
#endif
	extern	FILE	*cake_popen();
	extern	FILE	*yyin;
a449 1
#if 0
a450 1
#endif
@


1.11
log
@ANTIQUE handling, changing from getpw() to getpwent().
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /m/cad/cake/RCS/main.c,v 1.10 91/09/20 23:35:00 mike Exp Locker: butler $";
d40 1
a40 1
char	*cakefile  = NULL;
d343 1
d373 3
d411 1
a411 1
		cakefile = dir_setup(cakefile);
d413 22
d448 1
d450 4
d456 1
d458 1
d463 2
a464 1
			printf("%s\n", cppargv[i]);
d470 1
d483 1
d500 2
@


1.10
log
@ANSI lint
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /m/cad/cake/RCS/main.c,v 1.9 91/09/10 16:38:48 butler Exp $";
d438 1
d501 4
a504 1
	extern		getpw();
d521 1
d526 1
d536 2
d539 5
@


1.9
log
@Fixed for the SGI 4.0 OS.  The compiler does NOT define __STDC__ by default,
but checks function prototypes anyway. Grrr.
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /m/cad/cake/RCS/main.c,v 1.8 91/07/10 02:06:31 butler Exp $";
d297 2
a298 1
cake_finish()
@


1.8
log
@miscelaneous cleanup to go to ANSI C compiler
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /n/wolf/m/cad/cake/RCS/main.c,v 1.7 91/07/10 01:13:07 butler Exp Locker: butler $";
d325 1
a325 1
#if !defined(__convex__) && !__STDC__
d328 3
d332 1
@


1.7
log
@re-ordered functions to eliminate "extern" statements for functions in main.c
declared functions which don't return values as returning type void
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /n/wolf/m/cad/cake/RCS/main.c,v 1.6 90/11/27 16:46:37 mike Exp Locker: butler $";
d9 3
d325 1
a325 1
#if !defined(__convex__)
@


1.6
log
@Convex hack
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /m/cad/cake/RCS/main.c,v 1.5 90/04/21 01:45:05 mike Exp $";
d55 5
a59 3
main(argc, argv)
int	argc;
char	**argv;
d61 3
a63 156
	extern		cake_abort(), cake_finish();
	extern	int	parse_args(), process_args();
	extern	Node	*chase();
	extern	char	*getenv();
	extern	char	*dir_setup();
#if !defined(__convex__)
	extern	Pwent	*getpwuid();
#endif
	extern	int	geteuid();
	extern	FILE	*cake_popen();
	extern	FILE	*yyin;
	Stat		statbuf;
	int		envc;
	char		*envv[MAXARGS];
	reg	Pwent	*pwent;
	reg	char	*envstr;
	reg	int	status;
	reg	Node	*rootnode;

	signal(SIGINT,  cake_finish);
	signal(SIGQUIT, cake_finish);
	if(cakedebug)  {
		/* If debugging enabled, catch signals to do get_trail() */
		signal(SIGILL,  cake_abort);
		signal(SIGTRAP, cake_abort);
		signal(SIGIOT,  cake_abort);
		signal(SIGEMT,  cake_abort);
		signal(SIGFPE,  cake_abort);
		signal(SIGBUS,  cake_abort);
		signal(SIGSEGV, cake_abort);
		signal(SIGSYS,  cake_abort);
	}
	signal(SIGPIPE, cake_abort);
	signal(SIGALRM, cake_abort);

	yydebug = FALSE;
	active_procs = makelist0();

	if (rindex(argv[0], 'f') != NULL
	&&  streq(rindex(argv[0], 'f'), "fake"))
		cakedebug = TRUE;

	init_sym();
	cppargv[cppargc++] = new_name(CPP);
#if defined(CPP_OPTIONS)
	cppargv[cppargc++] = new_name(CPP_OPTIONS);	
#endif
	strcpy(cakeflagbuf, "-DCAKEFLAGS=");

	if ((envstr = getenv("CAKE")) != NULL)
	{
		envc = parse_args(envstr, envv);
		process_args(envv, &envc, 0);
		if (envc > 0)
			fprintf(stderr, "cake: non-options in environment ignored\n");
	}

	argv += process_args(argv, &argc, 1);

#if defined(CAKEDEBUG) && !defined(ATT)
	if (cakedebug || entrydebug || patdebug || lexdebug)
		setlinebuf(stdout);
#endif

	if (cakefile == NULL)
	{
		if (stat("cakefile", &statbuf) == 0)
			cakefile = "cakefile";
		or (stat("Cakefile", &statbuf) == 0)
			cakefile = "Cakefile";
		or (stat("recipe", &statbuf) == 0)
			cakefile = "recipe";
		or (stat("Recipe", &statbuf) == 0)
			cakefile = "Recipe";
		else
		{
			fprintf(stderr, "cake: cannot locate a cakefile\n");
			exit(1);
		}
	}

	if (gflag)
		cakefile = dir_setup(cakefile);

	if( (pwent = getpwuid(geteuid())) == (Pwent *)0 )  {
		printf("cake: Warning: unable to get home directory for uid %d\n",
			geteuid() );
	} else {
		strcpy(scratchbuf, "-I");
		strcat(scratchbuf, pwent->pw_dir);
		strcat(scratchbuf, ULIB);
		cppargv[cppargc++] = new_name(scratchbuf);
	}
	strcpy(scratchbuf, "-I");
	strcat(scratchbuf, SLIB);
	cppargv[cppargc++] = new_name(scratchbuf);
	cppargv[cppargc++] = cakeflagbuf;
	cppargv[cppargc++] = cakefile;
	cppargv[cppargc]   = NULL;

	if (cakedebug)
	{
		reg	int	i;

		for (i = 0; i < cppargc; i++)
			printf("%s\n", cppargv[i]);
	}

	if ((yyin = cake_popen(cppargv, "r")) == NULL)
	{
		fprintf(stderr, "cake: cannot open cpp filter\n");
		exit(1);
	}

	if (Zflag)
	{
		reg	int	c;

		while ((c = getc(yyin)) != EOF)
			putchar(c);

		cake_pclose(yyin);
		exit(0);
	}

	yyinit();
	init_entry();
	if (yyparse())
	{
		fprintf(stderr, "cake: cannot parse %s\n", cakefile);
		exit(1);
	}

	shell_setup(shellfile[0], 0);
	shell_setup(shellfile[1], 1);
	meta_setup(metachars);

	cake_pclose(yyin);
	dir_start();
	prep_entries();
	final_entry(argc, argv);

	rootnode = chase(CHASEROOT, 0, (Entry *) NULL);

	if (! qflag)
		execute(rootnode);
	
	dir_finish();
	cleanup();
#ifdef	STATS_FILE
	statistics();
#endif

	status = (off_node(rootnode, nf_ERR) && is_ok(rootnode))? 0: 1;
	cdebug("exit status %d\n", status);
	exit(status);
d258 1
a258 11
/*
**	Tell the unfortunate user how to use cake.
*/

usage()
{
	fprintf(stderr, "Usage: cake [-abcdgiknqrstvwxzGLRXZ] [-ffile]\n");
	fprintf(stderr, "       [-Ddefn] [-Idir] [-Uname] [-S shell] [-T metachars] [file ...]\n");
	exit(1);
}

d273 1
a273 1

d293 1
d313 163
@


1.5
log
@Added support for C Pre-processors that need options passed to them.
@
text
@d6 1
a6 1
rcs_id[] = "$Header: main.c,v 1.4 90/04/14 16:39:03 mike Locked $";
d64 1
d66 1
@


1.4
log
@Some minor error checking to deal with problems encountered by
<ra@@world.std.com>.
@
text
@d6 1
a6 1
rcs_id[] = "$Header: main.c,v 1.3 88/09/17 05:34:43 mike Locked $";
d101 3
@


1.3
log
@made yydebug extern apply to whole file.
@
text
@d6 1
a6 1
rcs_id[] = "$Header: main.c,v 1.2 88/06/11 01:00:38 mike Locked $";
d78 11
a88 8
	signal(SIGILL,  cake_abort);
	signal(SIGTRAP, cake_abort);
/*	signal(SIGIOT,  cake_abort);	/* BRL */
	signal(SIGEMT,  cake_abort);
	signal(SIGFPE,  cake_abort);
	signal(SIGBUS,  cake_abort);
	signal(SIGSEGV, cake_abort);
	signal(SIGSYS,  cake_abort);
d138 9
a146 1
	pwent = getpwuid(geteuid());
a147 4
	strcat(scratchbuf, pwent->pw_dir);
	strcat(scratchbuf, ULIB);
	cppargv[cppargc++] = new_name(scratchbuf);
	strcpy(scratchbuf, "-I");
d430 2
a431 1
cake_abort()
d437 1
a437 1
	printf("Abort on signal\n");
@


1.2
log
@minor BRL mods
@
text
@d6 1
a6 1
rcs_id[] = "$Header: /mip/zs/src/sys/cake/RCS/main.c,v 1.15 87/10/05 20:14:53 zs Exp $";
d53 2
a67 1
	extern	int	yydebug;
@


1.1
log
@Original CAKE version from net.sources
@
text
@d79 1
a79 1
	signal(SIGIOT,  cake_abort);
d109 1
a109 1
#ifdef	CAKEDEBUG
d372 1
a372 1
	cdebug(" \n%return %d\n", j);
@
