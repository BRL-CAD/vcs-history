head	1.22;
access;
symbols
	ansi-20040405-merged:1.19.2.1
	postmerge-20040405-ansi:1.20
	premerge-20040404-ansi:1.19
	postmerge-autoconf:1.19
	autoconf-freeze:1.19
	premerge-autoconf:1.19
	ansi-20040316-freeze:1.19.2.1
	postmerge-20040315-windows:1.19
	premerge-20040315-windows:1.19
	windows-20040315-freeze:1.19
	autoconf-20031203:1.19
	autoconf-20031202:1.19
	autoconf-branch:1.19.0.10
	phong-branch:1.19.0.8
	photonmap-branch:1.19.0.6
	rel-6-1-DP:1.19
	windows-branch:1.19.0.4
	rel-6-0-2:1.17
	ansi-branch:1.19.0.2
	rel-6-0-1-branch:1.17.0.2
	hartley-6-0-post:1.18
	hartley-6-0-pre:1.17
	rel-6-0-1:1.17
	rel-6-0:1.17
	offsite-5-3-pre:1.12;
locks; strict;
comment	@ * @;


1.22
date	2004.05.21.18.06.23;	author morrison;	state dead;
branches;
next	1.21;

1.21
date	2004.05.10.15.30.44;	author erikg;	state Exp;
branches;
next	1.20;

1.20
date	2004.04.05.07.46.16;	author morrison;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.20.17.07.39;	author jra;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2002.08.15.20.54.50;	author hartley;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.22.16.08.34;	author jra;	state Exp;
branches;
next	1.16;

1.16
date	2001.08.28.14.23.28;	author jra;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.28.18.19.47;	author jra;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.08.20.07.09;	author jra;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.20.22.29.05;	author morrison;	state Exp;
branches;
next	1.12;

1.12
date	2000.08.24.00.30.37;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.24.00.27.51;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	2000.08.16.04.34.33;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.15.04.49.26;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.13.00.29.09;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.07.05.21.20;	author cjohnson;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.29.17.53.40;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.29.14.26.38;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.28.22.33.34;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.28.22.27.04;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	2000.06.26.18.05.38;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.26.16.20.43;	author mike;	state Exp;
branches;
next	;

1.19.2.1
date	2002.09.19.18.01.11;	author morrison;	state Exp;
branches;
next	;


desc
@@


1.22
log
@moved to src/
@
text
@/*
 *			A V S . C
 *
 *  Routines to manage attribute/value sets.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libbu/avs.c,v 1.21 2004/05/10 15:30:44 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "bu.h"

/*
 *			B U _ A V S _ I N I T _ E M P T Y
 */
void
bu_avs_init_empty( struct bu_attribute_value_set *avsp )
{
	avsp->magic = BU_AVS_MAGIC;
	avsp->count = 0;
	avsp->max = 0;
	avsp->avp = (struct bu_attribute_value_pair *)NULL;
	avsp->readonly_min = avsp->readonly_max = NULL;
}

/*
 *			B U _ A V S _ I N I T
 */
void
bu_avs_init(struct bu_attribute_value_set *avsp, int len, const char *str)
{
	if (bu_debug & BU_DEBUG_AVS)
		bu_log("bu_avs_init(%8x, len=%d, %s)\n", avsp, len, str);

	avsp->magic = BU_AVS_MAGIC;
	if( len <= 0 )  len = 32;
	avsp->count = 0;
	avsp->max = len;
	avsp->avp = (struct bu_attribute_value_pair *)bu_calloc(avsp->max,
		sizeof(struct bu_attribute_value_pair), str);
	avsp->readonly_min = avsp->readonly_max = NULL;
}

/*
 *			B U _ A V S _ N E W
 *
 *  Allocate storage for a new attribute/value set, with at least
 *  'len' slots pre-allocated.
 */
struct bu_attribute_value_set	*
bu_avs_new(int len, const char *str)
{
	struct bu_attribute_value_set	*avsp;

	BU_GETSTRUCT( avsp, bu_attribute_value_set );
	bu_avs_init( avsp, len, "bu_avs_new" );

	if (bu_debug & BU_DEBUG_AVS)
		bu_log("bu_avs_new(len=%d, %s) = x%x\n", len, str, avsp);

	return avsp;
}

/*
 *			B U _ A V S _ A D D
 *
 *  If the given attribute exists it will recieve the new value,
 *  othwise the set will be extended to have a new attribute/value pair.
 *
 *  Returns -
 *	1	existing attribute updated with new value
 *	2	set extended with new attribute/value pair
 */
int
bu_avs_add(struct bu_attribute_value_set *avsp, const char *attribute, const char *value)
{
	struct bu_attribute_value_pair *app;

	BU_CK_AVS(avsp);

	if( avsp->count ) {
		for( BU_AVS_FOR(app, avsp) )  {
			if( strcmp( app->name, attribute ) != 0 )  continue;
			if( app->value && AVS_IS_FREEABLE(avsp, app->value) )
				bu_free( (genptr_t)app->value, "app->value" );
			if( value )
				app->value = bu_strdup( value );
			else
				app->value = (char *)NULL;
			return 1;
		}
	}

	if( avsp->count >= avsp->max )  {
		/* Allocate more space first */
		avsp->max += 4;
		if( avsp->avp ) {
			avsp->avp = (struct bu_attribute_value_pair *)bu_realloc(
			  avsp->avp,  avsp->max * sizeof(struct bu_attribute_value_pair),
				"attribute_value_pair.avp[] (add)" );
		} else {
			avsp->avp = (struct bu_attribute_value_pair *)bu_malloc(
				avsp->max * sizeof(struct bu_attribute_value_pair ),
			       "attribute_value_pair.avp[] (add)" );
		}
	}

	app = &avsp->avp[avsp->count++];
	app->name = bu_strdup(attribute);
	if( value )
		app->value = bu_strdup(value);
	else
		app->value = (char *)NULL;
	return 2;
}

/*
 *			B U _ A V S _ A D D _ V L S
 */
int
bu_avs_add_vls(struct bu_attribute_value_set *avsp, const char *attribute, const struct bu_vls *value_vls)
{
	BU_CK_AVS(avsp);
	BU_CK_VLS(value_vls);

	return bu_avs_add( avsp, attribute, bu_vls_addr(value_vls) );
}

/*
 *			B U _ A V S _ M E R G E
 *
 *  Take all the attributes from 'src' and merge them into 'dest'.
 */
void
bu_avs_merge( struct bu_attribute_value_set *dest, const struct bu_attribute_value_set *src )
{
	struct bu_attribute_value_pair *app;

	BU_CK_AVS(dest);
	BU_CK_AVS(src);

	if( src->count ) {
		for( BU_AVS_FOR( app, src ) )  {
			(void)bu_avs_add( dest, app->name, app->value );
		}
	}
}

/*
 *			B U _ A V S _ G E T
 */
const char *
bu_avs_get( const struct bu_attribute_value_set *avsp, const char *attribute )
{
	struct bu_attribute_value_pair *app;

	BU_CK_AVS(avsp);

	if( avsp->count < 1 )
		return NULL;

	for( BU_AVS_FOR(app, avsp) )  {
		if( strcmp( app->name, attribute ) != 0 )  continue;
		return app->value;
	}
	return NULL;
}

/*
 *			B U _ A V S _ R E M O V E
 *
 *  Returns -
 *	-1	attribute not found in set
 *	 0	OK
 */
int
bu_avs_remove(struct bu_attribute_value_set *avsp, const char *attribute)
{
	struct bu_attribute_value_pair *app, *epp;

	BU_CK_AVS(avsp);

	if( avsp->count ) {
		for( BU_AVS_FOR(app, avsp) )  {
			if( strcmp( app->name, attribute ) != 0 )  continue;
			if( AVS_IS_FREEABLE( avsp, app->name ) )
				bu_free( (genptr_t)app->name, "app->name" );
			app->name = NULL;	/* sanity */
			if( AVS_IS_FREEABLE( avsp, app->value ) )
				bu_free( (genptr_t)app->value, "app->value" );
			app->value = NULL;	/* sanity */
			
			/* Move last one down to replace it */
			epp = &avsp->avp[--avsp->count];
			if( app != epp )  {
				*app = *epp;		/* struct copy */
			}
			epp->name = NULL;			/* sanity */
			epp->value = NULL;
			return 0;
		}
	}
	return -1;
}

/*
 *			B U _ A V S _ F R E E
 */
void
bu_avs_free( struct bu_attribute_value_set *avsp )
{
	struct bu_attribute_value_pair *app;

	BU_CK_AVS(avsp);

	if( avsp->max < 1 )
		return;

	if( avsp->count ) {
		for( BU_AVS_FOR(app, avsp) )  {
			if( AVS_IS_FREEABLE( avsp, app->name ) )
				bu_free( (genptr_t)app->name, "app->name" );
			app->name = NULL;	/* sanity */
			if( app->value && AVS_IS_FREEABLE( avsp, app->value ) )
				bu_free( (genptr_t)app->value, "app->value" );
			app->value = NULL;	/* sanity */
		}
	}
	bu_free( (genptr_t)avsp->avp, "bu_avs_free avsp->avp" );
}


/*
 *			B U _ A V S _ P R I N T
 */
void
bu_avs_print( const struct bu_attribute_value_set *avsp, const char *title )
{
	struct bu_attribute_value_pair	*avpp;
	int i;

	BU_CK_AVS(avsp);

	bu_log("bu_avs_print: %s\n", title);

	avpp = avsp->avp;
	for( i = 0; i < avsp->count; i++, avpp++ )  {
		bu_log(" %s = %s\n", avpp->name, avpp->value );
	}
}

/*
 *			B U _ A V S _ A D D _ N O N U N I Q U E
 *
 *	Add a name/value pair even if the name already exists in this AVS
 */
void
bu_avs_add_nonunique( struct bu_attribute_value_set *avsp, char *attribute, char *value )
{
	struct bu_attribute_value_pair *app;

	BU_CK_AVS(avsp);

	if( avsp->count >= avsp->max )  {
		/* Allocate more space first */
		avsp->max += 4;
		if( avsp->avp ) {
			avsp->avp = (struct bu_attribute_value_pair *)bu_realloc(
			  avsp->avp,  avsp->max * sizeof(struct bu_attribute_value_pair),
				"attribute_value_pair.avp[] (add)" );
		} else {
			avsp->avp = (struct bu_attribute_value_pair *)bu_malloc(
				avsp->max * sizeof(struct bu_attribute_value_pair ),
			       "attribute_value_pair.avp[] (add)" );
		}
	}

	app = &avsp->avp[avsp->count++];
	app->name = bu_strdup(attribute);
	if( value )
		app->value = bu_strdup(value);
	else
		app->value = (char *)NULL;
}
@


1.21
log
@change conf.h to a wrapped config.h
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/libbu/avs.c,v 1.20 2004/04/05 07:46:16 morrison Exp $ (ARL)";
@


1.20
log
@merge of ansi-6-0-branch into HEAD
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d20 5
a24 1
#include "conf.h"
@


1.19
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/avs.c,v 1.17 2002/02/22 16:08:34 jra Exp $ (ARL)";
d49 1
a49 4
bu_avs_init( avsp, len, str )
struct bu_attribute_value_set	*avsp;
int		len;
const char	*str;
d70 1
a70 3
bu_avs_new( len, str )
int		len;
const char	*str;
d94 1
a94 4
bu_avs_add( avsp, attribute, value )
struct bu_attribute_value_set	*avsp;
const char	*attribute;
const char	*value;
d140 1
a140 4
bu_avs_add_vls( avsp, attribute, value_vls )
struct bu_attribute_value_set	*avsp;
const char		*attribute;
const struct bu_vls	*value_vls;
d196 1
a196 3
bu_avs_remove( avsp, attribute )
struct bu_attribute_value_set	*avsp;
const char	*attribute;
@


1.19.2.1
log
@Initial ANSIfication
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/avs.c,v 1.19 2002/08/20 17:07:39 jra Exp $ (ARL)";
d49 4
a52 1
bu_avs_init(struct bu_attribute_value_set *avsp, int len, const char *str)
d73 3
a75 1
bu_avs_new(int len, const char *str)
d99 4
a102 1
bu_avs_add(struct bu_attribute_value_set *avsp, const char *attribute, const char *value)
d148 4
a151 1
bu_avs_add_vls(struct bu_attribute_value_set *avsp, const char *attribute, const struct bu_vls *value_vls)
d207 3
a209 1
bu_avs_remove(struct bu_attribute_value_set *avsp, const char *attribute)
@


1.18
log
@Converted from K&R to ANSI C - RFH
@
text
@d49 4
a52 1
bu_avs_init(struct bu_attribute_value_set *avsp, int len, const char *str)
d73 3
a75 1
bu_avs_new(int len, const char *str)
d99 4
a102 1
bu_avs_add(struct bu_attribute_value_set *avsp, const char *attribute, const char *value)
d148 4
a151 1
bu_avs_add_vls(struct bu_attribute_value_set *avsp, const char *attribute, const struct bu_vls *value_vls)
d207 3
a209 1
bu_avs_remove(struct bu_attribute_value_set *avsp, const char *attribute)
@


1.17
log
@Added bu_avs_add_nonunique()
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/avs.c,v 1.16 2001/08/28 14:23:28 jra Exp $ (ARL)";
d49 1
a49 4
bu_avs_init( avsp, len, str )
struct bu_attribute_value_set	*avsp;
int		len;
const char	*str;
d70 1
a70 3
bu_avs_new( len, str )
int		len;
const char	*str;
d94 1
a94 4
bu_avs_add( avsp, attribute, value )
struct bu_attribute_value_set	*avsp;
const char	*attribute;
const char	*value;
d140 1
a140 4
bu_avs_add_vls( avsp, attribute, value_vls )
struct bu_attribute_value_set	*avsp;
const char		*attribute;
const struct bu_vls	*value_vls;
d196 1
a196 3
bu_avs_remove( avsp, attribute )
struct bu_attribute_value_set	*avsp;
const char	*attribute;
@


1.16
log
@bu_avs_remove() was incorrectly adjusting the avs after removing an entry
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/avs.c,v 1.15 2001/06/28 18:19:47 jra Exp $ (ARL)";
d282 34
@


1.15
log
@Bug fixes:
	the BU_AVS_FOR macro cannot be used on an empty AVS (I put "if" statements around its uses)
	bu_avs_add() was trying to increase the max entries by doing a *= (doesn't work for empty ones)
	bu_avs_add() was always calling bu_realloc() to get more memory (doesn't work for empty ones)
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/avs.c,v 1.14 2001/05/08 20:07:09 jra Exp $ (ARL)";
d226 1
a226 1
			epp = &avsp->avp[avsp->count--];
@


1.14
log
@Added bu_avs_init_empty(), Moved AVS_IS_FREEABLE to bu.h, mods to allow AVS with NULL values.
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/avs.c,v 1.13 2001/04/20 22:29:05 morrison Exp $ (ARL)";
d108 11
a118 9
	for( BU_AVS_FOR(app, avsp) )  {
		if( strcmp( app->name, attribute ) != 0 )  continue;
		if( app->value && AVS_IS_FREEABLE(avsp, app->value) )
			bu_free( (genptr_t)app->value, "app->value" );
		if( value )
			app->value = bu_strdup( value );
		else
			app->value = (char *)NULL;
		return 1;
d123 10
a132 6
		avsp->max *= 4;
		avsp->avp = (struct bu_attribute_value_pair *)bu_realloc(
			avsp->avp,
			avsp->max *
			sizeof(struct bu_attribute_value_pair),
			"attribute_value_pair.avp[] (add)" );
d172 4
a175 2
	for( BU_AVS_FOR( app, src ) )  {
		(void)bu_avs_add( dest, app->name, app->value );
d215 18
a232 13
	for( BU_AVS_FOR(app, avsp) )  {
		if( strcmp( app->name, attribute ) != 0 )  continue;
		if( AVS_IS_FREEABLE( avsp, app->name ) )
			bu_free( (genptr_t)app->name, "app->name" );
		app->name = NULL;	/* sanity */
		if( AVS_IS_FREEABLE( avsp, app->value ) )
			bu_free( (genptr_t)app->value, "app->value" );
		app->value = NULL;	/* sanity */

		/* Move last one down to replace it */
		epp = &avsp->avp[avsp->count--];
		if( app != epp )  {
			*app = *epp;		/* struct copy */
a233 3
		epp->name = NULL;			/* sanity */
		epp->value = NULL;
		return 0;
d251 9
a259 7
	for( BU_AVS_FOR(app, avsp) )  {
		if( AVS_IS_FREEABLE( avsp, app->name ) )
			bu_free( (genptr_t)app->name, "app->name" );
		app->name = NULL;	/* sanity */
		if( app->value && AVS_IS_FREEABLE( avsp, app->value ) )
			bu_free( (genptr_t)app->value, "app->value" );
		app->value = NULL;	/* sanity */
@


1.13
log
@CONST to const
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/avs.c,v 1.12 2000/08/24 00:30:37 mike Exp $ (ARL)";
d33 11
a43 8
 *  Some (but not all) attribute name and value string pointers are
 *  taken from an on-disk format bu_external block,
 *  while others have been bu_strdup()ed and need to be freed.
 *  This macro indicates whether the pointer needs to be freed or not.
 */
#define AVS_IS_FREEABLE(_avsp, _p)	\
	( (_avsp)->readonly_max == NULL || \
	    ((_p) < (_avsp)->readonly_min || (_p) > (_avsp)->readonly_max) )
d110 1
a110 1
		if( AVS_IS_FREEABLE(avsp, app->value) )
d112 4
a115 1
		app->value = bu_strdup( value );
d131 4
a134 1
	app->value = bu_strdup(value);
d159 1
a159 1
bu_avs_merge( struct bu_attribute_value_set *dest, struct bu_attribute_value_set *src )
d181 3
d238 3
d245 1
a245 1
		if( AVS_IS_FREEABLE( avsp, app->value ) )
@


1.12
log
@
Converted to less confusing variable name.
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/avs.c,v 1.11 2000/08/24 00:27:51 mike Exp $ (ARL)";
d49 1
a49 1
CONST char	*str;
d72 1
a72 1
CONST char	*str;
d98 2
a99 2
CONST char	*attribute;
CONST char	*value;
d189 1
a189 1
CONST char	*attribute;
@


1.11
log
@
A comparison of incorrect sense in bu_avs_free() which was causing
some of the attribute/value strings from being properly freed.
Moved this common test into a macro
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/avs.c,v 1.10 2000/08/16 04:34:33 mike Exp $ (ARL)";
d46 2
a47 2
bu_avs_init( avp, len, str )
struct bu_attribute_value_set	*avp;
d52 1
a52 1
		bu_log("bu_avs_init(%8x, len=%d, %s)\n", avp, len, str);
d54 1
a54 1
	avp->magic = BU_AVS_MAGIC;
d56 3
a58 3
	avp->count = 0;
	avp->max = len;
	avp->avp = (struct bu_attribute_value_pair *)bu_calloc(avp->max,
d60 1
a60 1
	avp->readonly_min = avp->readonly_max = NULL;
d74 1
a74 1
	struct bu_attribute_value_set	*avp;
d76 2
a77 2
	BU_GETSTRUCT( avp, bu_attribute_value_set );
	bu_avs_init( avp, len, "bu_avs_new" );
d80 1
a80 1
		bu_log("bu_avs_new(len=%d, %s) = x%x\n", len, str, avp);
d82 1
a82 1
	return avp;
d96 2
a97 2
bu_avs_add( avp, attribute, value )
struct bu_attribute_value_set	*avp;
d103 1
a103 1
	BU_CK_AVS(avp);
d105 1
a105 1
	for( BU_AVS_FOR(app, avp) )  {
d107 1
a107 1
		if( AVS_IS_FREEABLE(avp, app->value) )
d113 1
a113 1
	if( avp->count >= avp->max )  {
d115 4
a118 4
		avp->max *= 4;
		avp->avp = (struct bu_attribute_value_pair *)bu_realloc(
			avp->avp,
			avp->max *
d123 1
a123 1
	app = &avp->avp[avp->count++];
d133 2
a134 2
bu_avs_add_vls( avp, attribute, value_vls )
struct bu_attribute_value_set	*avp;
d138 1
a138 1
	BU_CK_AVS(avp);
d141 1
a141 1
	return bu_avs_add( avp, attribute, bu_vls_addr(value_vls) );
d166 1
a166 1
bu_avs_get( const struct bu_attribute_value_set *avp, const char *attribute )
d170 1
a170 1
	BU_CK_AVS(avp);
d172 1
a172 1
	for( BU_AVS_FOR(app, avp) )  {
d187 2
a188 2
bu_avs_remove( avp, attribute )
struct bu_attribute_value_set	*avp;
d193 1
a193 1
	BU_CK_AVS(avp);
d195 1
a195 1
	for( BU_AVS_FOR(app, avp) )  {
d197 1
a197 1
		if( AVS_IS_FREEABLE( avp, app->name ) )
d200 1
a200 1
		if( AVS_IS_FREEABLE( avp, app->value ) )
d205 1
a205 1
		epp = &avp->avp[avp->count--];
d220 1
a220 1
bu_avs_free( struct bu_attribute_value_set *avp )
d224 1
a224 1
	BU_CK_AVS(avp);
d226 2
a227 2
	for( BU_AVS_FOR(app, avp) )  {
		if( AVS_IS_FREEABLE( avp, app->name ) )
d230 1
a230 1
		if( AVS_IS_FREEABLE( avp, app->value ) )
d234 1
a234 1
	bu_free( (genptr_t)avp->avp, "bu_avs_free avp->avp" );
d242 1
a242 1
bu_avs_print( const struct bu_attribute_value_set *avp, const char *title )
d247 1
a247 1
	BU_CK_AVS(avp);
d251 2
a252 2
	avpp = avp->avp;
	for( i = 0; i < avp->count; i++, avpp++ )  {
@


1.10
log
@
readonly_max is NULL unless in use.  pointers will always be greater
than that.  Fixed bug!
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/avs.c,v 1.9 2000/08/15 04:49:26 mike Exp $ (ARL)";
d33 10
d107 1
a107 2
		if( avp->readonly_max &&
		    (app->value < avp->readonly_min || app->value > avp->readonly_max) )
d197 1
a197 2
		if( avp->readonly_max &&
		    (app->name < avp->readonly_min || app->name > avp->readonly_max) )
d200 1
a200 2
		if( avp->readonly_max &&
		    (app->value < avp->readonly_min || app->value > avp->readonly_max) )
d204 1
a204 1
		/* Move last one down to fit */
d227 1
a227 2
		if( avp->readonly_max &&
		    (app->name < avp->readonly_min || app->name > avp->readonly_max) )
d230 1
a230 2
		if( avp->readonly_max &&
		    (app->value < avp->readonly_min || app->value > avp->readonly_max) )
d234 1
a234 2
	bu_free( (genptr_t)avp->avp, "avp->avp" );
	avp->magic = -1L;
d236 1
@


1.9
log
@
Added some sanity code.
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/avs.c,v 1.8 2000/07/13 00:29:09 mike Exp $ (ARL)";
d97 2
a98 1
		if( app->value < avp->readonly_min || app->value > avp->readonly_max )
d188 2
a189 1
		if( app->name < avp->readonly_min || app->name > avp->readonly_max )  {
d191 3
a193 3
			app->name = NULL;	/* sanity */
		}
		if( app->value < avp->readonly_min || app->value > avp->readonly_max )  {
d195 1
a195 2
			app->value = NULL;	/* sanity */
		}
d202 2
a203 2
		epp->name = 0;			/* sanity */
		epp->value = 0;
d220 2
a221 1
		if( app->name < avp->readonly_min || app->name > avp->readonly_max )  {
d223 3
a225 3
			app->name = NULL;	/* sanity */
		}
		if( app->value < avp->readonly_min || app->value > avp->readonly_max )  {
d227 1
a227 2
			app->value = NULL;	/* sanity */
		}
@


1.8
log
@
Added bu_avs_merge()
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/avs.c,v 1.7 2000/07/07 05:21:20 cjohnson Exp $ (ARL)";
d187 1
a187 1
		if( app->name < avp->readonly_min || app->name > avp->readonly_max )
d189 3
a191 1
		if( app->value < avp->readonly_min || app->value > avp->readonly_max )
d193 2
d219 1
a219 1
		if( app->name < avp->readonly_min || app->name > avp->readonly_max )
d221 3
a223 1
		if( app->value < avp->readonly_min || app->value > avp->readonly_max )
d225 2
@


1.7
log
@LINT plus minor bug fix in bu_tcl.c
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/avs.c,v 1.6 2000/06/29 17:53:40 mike Exp $ (ARL)";
d132 18
@


1.6
log
@
added const
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/avs.c,v 1.5 2000/06/29 14:26:38 mike Exp $ (ARL)";
@


1.5
log
@
Added readonly_min/max handling.
Added bu_avs_get()
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/avs.c,v 1.4 2000/06/28 22:33:34 mike Exp $ (ARL)";
d98 1
a98 1
			bu_free( app->value, "app->value" );
d170 1
a170 1
			bu_free( app->name, "app->name" );
d172 1
a172 1
			bu_free( app->value, "app->value" );
d190 1
a190 2
bu_avs_free( avp )
struct bu_attribute_value_set	*avp;
d198 1
a198 1
			bu_free( app->name, "app->name" );
d200 1
a200 1
			bu_free( app->value, "app->value" );
d202 1
a202 1
	bu_free( avp->avp, "avp->avp" );
@


1.4
log
@
Fixed minor bugs
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/avs.c,v 1.2 2000/06/26 18:05:38 mike Exp $ (ARL)";
d50 1
d54 1
a54 1
 *			B U _ A V S _ I N I T
d66 1
a66 3
	avp = (struct bu_attribute_value_set *)bu_malloc(
		sizeof(struct bu_attribute_value_set),
		"struct bu_attribute_value_set");
d97 2
a98 1
		bu_free( app->value, "app->value" );
d125 2
a126 2
CONST char		*attribute;
CONST struct bu_vls	*value_vls;
d135 17
d169 5
a173 2
		bu_free( app->name, "app->name" );
		bu_free( app->value, "app->value" );
d179 1
a179 1
		epp->name = 0;		/* sanity */
d198 4
a201 2
		bu_free( app->name, "app->name" );
		bu_free( app->value, "app->value" );
d218 1
a218 1
	bu_log("%s\n", title);
@


1.3
log
@
Added attribute/value set
avs.c
@
text
@d131 1
a131 1
	return bu_avs_add( avp, attribute, bu_vls_addr(&value_vls) );
d191 3
d198 3
a200 2
	for( i = 0; i < avp->count; i++, avp++ )  {
		bu_log(" %s = %s\n", avp->avp->name, avp->avp->value );
@


1.2
log
@
Added support for attribute/value sets
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/avs.c,v 1.1 2000/06/26 16:20:43 mike Exp $ (ARL)";
d120 15
d183 15
@


1.1
log
@
First draft
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.6 2000/06/23 21:05:56 mike Exp $ (ARL)";
a31 23
#define BU_DEBUG_AVS		0x00000400	/* 012 bu_avs_*() logging */

struct bu_attribute_value_pair {
	char	*name;
	char	*value;
};

/*
 *  Every one of the names and values is a local copy made with bu_strdup().
 *  They need to be freed automatically.
 */
struct bu_attribute_value_set {
	long				magic;
	int				count;	/* # valid entries in avp */
	int				max;	/* # allocated slots in avp */
	struct bu_attribute_value_pair	*avp;
};
#define BU_AVS_MAGIC		0x41765321	/* AvS! */
#define BU_CK_AVS(_avp)		BU_CKMAG(_avp, BU_AVS_MAGIC, "bu_attribute_value_set")

#define BU_AVS_FOR(_pp, _avp)	\
	(_pp) = &(_avp)->avp[(_avp)->count-1]; (_pp) >= (_avp)->avp; (_pp)--

d35 1
d50 24
@

