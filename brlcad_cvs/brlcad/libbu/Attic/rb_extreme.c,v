head	11.17;
access;
symbols
	ansi-20040405-merged:11.13.2.2
	postmerge-20040405-ansi:11.15
	premerge-20040404-ansi:11.14
	postmerge-autoconf:11.14
	autoconf-freeze:11.13.10.2
	premerge-autoconf:11.14
	ansi-20040316-freeze:11.13.2.1
	postmerge-20040315-windows:11.14
	premerge-20040315-windows:11.14
	windows-20040315-freeze:11.13.4.1
	autoconf-20031203:11.13
	autoconf-20031202:11.13
	autoconf-branch:11.13.0.10
	phong-branch:11.13.0.8
	photonmap-branch:11.13.0.6
	rel-6-1-DP:11.13
	windows-branch:11.13.0.4
	rel-6-0-2:11.11
	ansi-branch:11.13.0.2
	rel-6-0-1-branch:11.11.0.2
	hartley-6-0-post:11.12
	hartley-6-0-pre:11.11
	rel-6-0-1:11.11
	rel-6-0:11.11
	rel-5-4:11.10
	offsite-5-3-pre:11.11
	rel-5-3:11.10
	rel-5-2:11.10
	rel-5-1-branch:11.10.0.2
	rel-5-1:11.10
	rel-5-0:11.9
	rel-5-0-beta:11.9
	rel-4-5:11.7
	ctj-4-5-post:11.7
	ctj-4-5-pre:11.7
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.17
date	2004.05.21.18.06.24;	author morrison;	state dead;
branches;
next	11.16;

11.16
date	2004.05.10.15.30.44;	author erikg;	state Exp;
branches;
next	11.15;

11.15
date	2004.04.05.07.46.16;	author morrison;	state Exp;
branches;
next	11.14;

11.14
date	2004.02.02.17.39.07;	author morrison;	state Exp;
branches;
next	11.13;

11.13
date	2002.08.20.17.07.41;	author jra;	state Exp;
branches
	11.13.2.1
	11.13.4.1
	11.13.10.1;
next	11.12;

11.12
date	2002.08.15.20.54.54;	author hartley;	state Exp;
branches;
next	11.11;

11.11
date	2000.07.07.05.20.13;	author cjohnson;	state Exp;
branches;
next	11.10;

11.10
date	2000.03.28.18.55.09;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	99.01.12.16.19.55;	author pjt;	state Exp;
branches;
next	11.8;

11.8
date	98.12.30.01.25.43;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	96.11.27.17.46.05;	author pjt;	state Exp;
branches;
next	11.6;

11.6
date	96.08.27.07.10.51;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	95.09.20.16.00.44;	author pjt;	state Exp;
branches;
next	11.4;

11.4
date	95.09.20.12.34.44;	author pjt;	state Exp;
branches;
next	11.3;

11.3
date	95.07.10.20.17.51;	author pjt;	state Exp;
branches;
next	11.2;

11.2
date	95.04.19.20.12.47;	author pjt;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.05.54;	author mike;	state Rel4_4;
branches;
next	2.5;

2.5
date	95.01.04.05.49.56;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	94.09.26.12.21.10;	author jra;	state Exp;
branches;
next	2.3;

2.3
date	94.09.22.15.34.44;	author pjt;	state Exp;
branches;
next	2.2;

2.2
date	94.09.22.15.27.01;	author pjt;	state Exp;
branches;
next	2.1;

2.1
date	93.03.25.11.03.18;	author pjt;	state Exp;
branches;
next	1.14;

1.14
date	93.03.25.11.00.22;	author pjt;	state Exp;
branches;
next	1.13;

1.13
date	93.01.15.13.08.49;	author pjt;	state zero_1;
branches;
next	1.12;

1.12
date	93.01.15.10.43.44;	author pjt;	state zero_0;
branches;
next	1.11;

1.11
date	93.01.14.15.06.42;	author pjt;	state Exp;
branches;
next	1.10;

1.10
date	93.01.14.12.25.36;	author pjt;	state Exp;
branches;
next	1.9;

1.9
date	93.01.14.10.57.30;	author pjt;	state Exp;
branches;
next	1.8;

1.8
date	93.01.14.09.30.52;	author pjt;	state Exp;
branches;
next	1.7;

1.7
date	92.12.23.12.42.52;	author pjt;	state Exp;
branches;
next	1.6;

1.6
date	92.12.23.11.10.49;	author pjt;	state Exp;
branches;
next	1.5;

1.5
date	92.11.06.13.54.23;	author pjt;	state Exp;
branches;
next	1.4;

1.4
date	92.11.05.11.32.21;	author pjt;	state Exp;
branches;
next	1.3;

1.3
date	92.11.04.12.12.32;	author pjt;	state Exp;
branches;
next	1.2;

1.2
date	92.11.04.10.49.01;	author pjt;	state Exp;
branches;
next	1.1;

1.1
date	92.11.04.10.29.41;	author pjt;	state Exp;
branches;
next	;

11.13.2.1
date	2002.09.19.18.01.13;	author morrison;	state Exp;
branches;
next	11.13.2.2;

11.13.2.2
date	2004.03.17.21.16.50;	author morrison;	state Exp;
branches;
next	;

11.13.4.1
date	2004.03.11.23.41.49;	author morrison;	state Exp;
branches;
next	;

11.13.10.1
date	2004.02.12.18.39.19;	author erikg;	state Exp;
branches;
next	11.13.10.2;

11.13.10.2
date	2004.03.15.14.06.17;	author erikg;	state Exp;
branches;
next	;


desc
@
     Routines to extract mins and maxes from a red-black tree

@


11.17
log
@moved to src/
@
text
@/*			R B _ E X T R E M E . C
 *
 *	Routines to extract mins, maxes, adjacent, and current nodes
 *			from a red-black tree
 *
 *  Author -
 *	Paul J. Tanenbaum
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1998-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char libbu_rb_extreme_RCSid[] = "@@(#) $Header: /n/xoff/cvs/brlcad/libbu/rb_extreme.c,v 11.16 2004/05/10 15:30:44 erikg Exp $";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "rtlist.h"
#include "bu.h"
#include "compat4.h"
#include "./rb_internals.h"

/*		        _ R B _ E X T R E M E ( )
 *
 *	Find the minimum or maximum node in one order of a red-black tree
 *
 *	This function has four parameters: the root of the tree, the
 *	order, the sense (min or max), and the address to be understood
 *	as the nil node pointer. _rb_extreme() returns a pointer to the
 *	extreme node.
 */
static struct bu_rb_node *_rb_extreme (struct bu_rb_node *root, int order, int sense, struct bu_rb_node *empty_node)
{
    struct bu_rb_node	*child;
    bu_rb_tree		*tree;

    if (root == empty_node)
	return (root);

    while (1)
    {
	BU_CKMAG(root, BU_RB_NODE_MAGIC, "red-black node");
	tree = root -> rbn_tree;
	BU_RB_CKORDER(tree, order);

	child = (sense == SENSE_MIN) ? bu_rb_left_child(root, order) :
				       bu_rb_right_child(root, order);
	if (child == empty_node)
	    break;
	root = child;
    }

    /* Record the node with which we've been working */
    bu_rb_current(tree) = root;

    return (root);
}

/*		        B U _ R B _ E X T R E M E ( )
 *
 *		Applications interface to _rb_extreme()
 *
 *	This function has three parameters: the tree in which to find an
 *	extreme node, the order on which to do the search, and the sense
 *	(min or max).  On success, bu_rb_extreme() returns a pointer to the
 *	data in the extreme node.  Otherwise it returns NULL.
 */
void *bu_rb_extreme (bu_rb_tree *tree, int order, int sense)
{
    struct bu_rb_node	*node;

    BU_CKMAG(tree, BU_RB_TREE_MAGIC, "red-black tree");
    BU_RB_CKORDER(tree, order);

    if ((sense != SENSE_MIN) && (sense != SENSE_MAX))
    {
	bu_log("FATAL: bu_rb_extreme(): invalid sense %d, file %s, line %s\n",
	    sense, __FILE__, __LINE__);
	exit (0);
    }

    /* Wade throught the tree */
    node = _rb_extreme(bu_rb_root(tree, order), order, sense,
			bu_rb_null(tree));

    if (node == bu_rb_null(tree))
	return (NULL);
    else
	return (bu_rb_data(node, order));
}

/*		    _ R B _ N E I G H B O R ( )
 *
 *	    Return a node adjacent to a given red-black node
 *
 *	This function has three parameters: the node of interest, the
 *	order on which to do the search, and the sense (min or max,
 *	which is to say predecessor or successor).  _rb_neighbor()
 *	returns a pointer to the adjacent node.  This function is
 *	modeled after the routine TREE-SUCCESSOR on p. 249 of Cormen et al.
 */
struct bu_rb_node *_rb_neighbor (struct bu_rb_node *node, int order, int sense)
{
    struct bu_rb_node	*child;
    struct bu_rb_node	*parent;
    bu_rb_tree		*tree;
    struct bu_rb_node	*empty_node;

    BU_CKMAG(node, BU_RB_NODE_MAGIC, "red-black node");
    tree = node -> rbn_tree;
    BU_RB_CKORDER(tree, order);

    empty_node = bu_rb_null(tree);

    child = (sense == SENSE_MIN) ? bu_rb_left_child(node, order) :
				   bu_rb_right_child(node, order);
    if (child != empty_node)
	return (_rb_extreme(child, order, 1 - sense, empty_node));
    parent = bu_rb_parent(node, order);
    while ((parent != empty_node) &&
	   (node == bu_rb_child(parent, order, sense)))
    {
	node = parent;
	parent = bu_rb_parent(parent, order);
    }

    /* Record the node with which we've been working */
    bu_rb_current(tree) = parent;

    return (parent);
}

/*		        B U _ R B _ N E I G H B O R ( )
 *
 *	    Return a node adjacent to the current red-black node
 *
 *	This function has three parameters: the tree and order on which
 *	to do the search and the sense (min or max, which is to say
 *	predecessor or successor) of the search.  bu_rb_neighbor() returns
 *	a pointer to the data in the node adjacent to the current node
 *	in the specified direction, if that node exists.  Otherwise,
 *	it returns NULL.
 */
void *bu_rb_neighbor (bu_rb_tree *tree, int order, int sense)
{
    struct bu_rb_node	*node;

    BU_CKMAG(tree, BU_RB_TREE_MAGIC, "red-black tree");
    BU_RB_CKORDER(tree, order);

    if ((sense != SENSE_MIN) && (sense != SENSE_MAX))
    {
	bu_log("FATAL: bu_rb_neighbor(): invalid sense %d, file %s, line %s\n",
	    sense, __FILE__, __LINE__);
	exit (0);
    }

    /* Wade through the tree */
    node = _rb_neighbor(bu_rb_current(tree), order, sense);

    if (node == bu_rb_null(tree))
	return (NULL);
    else
    {
	/* Record the node with which we've been working */
	bu_rb_current(tree) = node;
	return (bu_rb_data(node, order));
    }
}

/*		            B U _ R B _ C U R R ( )
 *
 *	    Return the current red-black node
 *
 *	This function has two parameters: the tree and order in which
 *	to find the current node.  bu_rb_curr() returns a pointer to
 *	the data in the current node, if it exists.  Otherwise,
 *	it returns NULL.
 */
void *bu_rb_curr (bu_rb_tree *tree, int order)
{
    BU_CKMAG(tree, BU_RB_TREE_MAGIC, "red-black tree");
    BU_RB_CKORDER(tree, order);

    if (bu_rb_current(tree) == bu_rb_null(tree))
	return (NULL);
    else
	return (bu_rb_data(bu_rb_current(tree), order));
}
@


11.16
log
@change conf.h to a wrapped config.h
@
text
@d23 1
a23 1
static const char libbu_rb_extreme_RCSid[] = "@@(#) $Header: /cvs/brlcad/libbu/rb_extreme.c,v 11.15 2004/04/05 07:46:16 morrison Exp $";
@


11.15
log
@merge of ansi-6-0-branch into HEAD
@
text
@d23 1
a23 1
static const char libbu_rb_extreme_RCSid[] = "@@(#) $Header$";
d26 5
a30 1
#include "conf.h"
@


11.14
log
@update copyright to include span through 2003
@
text
@d23 1
a23 1
static const char libbu_rb_extreme_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_extreme.c,v 11.13 2002/08/20 17:07:41 jra Exp $";
d45 1
a45 7
static struct bu_rb_node *_rb_extreme (root, order, sense, empty_node)

struct bu_rb_node	*root;
int			order;
int			sense;
struct bu_rb_node	*empty_node;

d81 1
a81 6
void *bu_rb_extreme (tree, order, sense)

bu_rb_tree	*tree;
int		order;
int		sense;

d115 1
a115 6
struct bu_rb_node *_rb_neighbor (node, order, sense)

struct bu_rb_node	*node;
int			order;
int			sense;

d157 1
a157 6
void *bu_rb_neighbor (tree, order, sense)

bu_rb_tree	*tree;
int		order;
int		sense;

d193 1
a193 5
void *bu_rb_curr (tree, order)

bu_rb_tree	*tree;
int		order;

@


11.13
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1998 by the United States Army
d23 1
a23 1
static const char libbu_rb_extreme_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_extreme.c,v 11.11 2000/07/07 05:20:13 cjohnson Exp $";
@


11.13.4.1
log
@sync to HEAD...
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d23 1
a23 1
static const char libbu_rb_extreme_RCSid[] = "@@(#) $Header: /n/cad/c/CVS/brlcad/libbu/rb_extreme.c,v 11.14 2004/02/02 17:39:07 morrison Exp $";
@


11.13.10.1
log
@merge from HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d23 1
a23 1
static const char libbu_rb_extreme_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_extreme.c,v 11.14 2004/02/02 17:39:07 morrison Exp $";
@


11.13.10.2
log
@merge from head
@
text
@d23 1
a23 1
static const char libbu_rb_extreme_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_extreme.c,v 11.13.10.1 2004/02/12 18:39:19 erikg Exp $";
@


11.13.2.1
log
@Initial ANSIfication
@
text
@d23 1
a23 1
static const char libbu_rb_extreme_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_extreme.c,v 11.13 2002/08/20 17:07:41 jra Exp $";
d45 7
a51 1
static struct bu_rb_node *_rb_extreme (struct bu_rb_node *root, int order, int sense, struct bu_rb_node *empty_node)
d87 6
a92 1
void *bu_rb_extreme (bu_rb_tree *tree, int order, int sense)
d126 6
a131 1
struct bu_rb_node *_rb_neighbor (struct bu_rb_node *node, int order, int sense)
d173 6
a178 1
void *bu_rb_neighbor (bu_rb_tree *tree, int order, int sense)
d214 5
a218 1
void *bu_rb_curr (bu_rb_tree *tree, int order)
@


11.13.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d23 1
a23 1
static const char libbu_rb_extreme_RCSid[] = "@@(#) $Header$";
@


11.12
log
@Converted from K&R to ANSI C - RFH
@
text
@d45 7
a51 1
static struct bu_rb_node *_rb_extreme (struct bu_rb_node *root, int order, int sense, struct bu_rb_node *empty_node)
d87 6
a92 1
void *bu_rb_extreme (bu_rb_tree *tree, int order, int sense)
d126 6
a131 1
struct bu_rb_node *_rb_neighbor (struct bu_rb_node *node, int order, int sense)
d173 6
a178 1
void *bu_rb_neighbor (bu_rb_tree *tree, int order, int sense)
d214 5
a218 1
void *bu_rb_curr (bu_rb_tree *tree, int order)
@


11.11
log
@LINT
@
text
@d23 1
a23 1
static const char libbu_rb_extreme_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_extreme.c,v 11.10 2000/03/28 18:55:09 mike Exp $";
d45 1
a45 7
static struct bu_rb_node *_rb_extreme (root, order, sense, empty_node)

struct bu_rb_node	*root;
int			order;
int			sense;
struct bu_rb_node	*empty_node;

d81 1
a81 6
void *bu_rb_extreme (tree, order, sense)

bu_rb_tree	*tree;
int		order;
int		sense;

d115 1
a115 6
struct bu_rb_node *_rb_neighbor (node, order, sense)

struct bu_rb_node	*node;
int			order;
int			sense;

d157 1
a157 6
void *bu_rb_neighbor (tree, order, sense)

bu_rb_tree	*tree;
int		order;
int		sense;

d193 1
a193 5
void *bu_rb_curr (tree, order)

bu_rb_tree	*tree;
int		order;

@


11.10
log
@
Put libbu_filename_ prefixes on RCSid variables.
@
text
@d23 1
a23 1
static char libbu_rb_extreme_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_extreme.c,v 11.9 1999/01/12 16:19:55 pjt Exp $";
@


11.9
log
@Various details concerning folding libredblack into libbu
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_extreme.c,v 11.8 1998/12/30 01:25:43 mike Exp $";
@


11.8
log
@LibRedBlack routines now have a bu_ prefix.
@
text
@d1 1
a1 1
/*			B U _ R B _ E X T R E M E . C
d23 1
a23 1
static char RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_extreme.c,v 11.7 1996/11/27 17:46:05 pjt Exp $";
@


11.7
log
@fixed bug in _rb_extreme() where it failed to make initial check
for the case where (root == empty_node)
@
text
@d1 1
a1 1
/*			R B _ E X T R E M E . C
d6 15
a20 2
 *	Author:	Paul Tanenbaum
 *
d23 1
a23 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_extreme.c,v 11.6 1996/08/27 07:10:51 mike Exp $";
a33 1
#include "redblack.h"
d45 1
a45 1
static struct rb_node *_rb_extreme (root, order, sense, empty_node)
d47 4
a50 4
struct rb_node	*root;
int		order;
int		sense;
struct rb_node	*empty_node;
d53 2
a54 2
    struct rb_node	*child;
    rb_tree		*tree;
d61 1
a61 1
	RB_CKMAG(root, RB_NODE_MAGIC, "red-black node");
d63 1
a63 1
	RB_CKORDER(tree, order);
d65 2
a66 2
	child = (sense == SENSE_MIN) ? rb_left_child(root, order) :
				       rb_right_child(root, order);
d73 1
a73 1
    rb_current(tree) = root;
d78 1
a78 1
/*		        R B _ E X T R E M E ( )
d84 1
a84 1
 *	(min or max).  On success, rb_extreme() returns a pointer to the
d87 1
a87 1
void *rb_extreme (tree, order, sense)
d89 3
a91 3
rb_tree	*tree;
int	order;
int	sense;
d94 1
a94 1
    struct rb_node	*node;
d96 2
a97 2
    RB_CKMAG(tree, RB_TREE_MAGIC, "red-black tree");
    RB_CKORDER(tree, order);
d101 1
a101 1
	rt_log("FATAL: rb_extreme(): invalid sense %d, file %s, line %s\n",
d107 2
a108 1
    node = _rb_extreme(rb_root(tree, order), order, sense, rb_null(tree));
d110 1
a110 1
    if (node == rb_null(tree))
d113 1
a113 1
	return (rb_data(node, order));
d126 1
a126 1
struct rb_node *_rb_neighbor (node, order, sense)
d128 3
a130 3
struct rb_node	*node;
int		order;
int		sense;
d133 4
a136 4
    struct rb_node	*child;
    struct rb_node	*parent;
    rb_tree		*tree;
    struct rb_node	*empty_node;
d138 1
a138 1
    RB_CKMAG(node, RB_NODE_MAGIC, "red-black node");
d140 1
a140 1
    RB_CKORDER(tree, order);
d142 1
a142 1
    empty_node = rb_null(tree);
d144 2
a145 2
    child = (sense == SENSE_MIN) ? rb_left_child(node, order) :
				   rb_right_child(node, order);
d148 1
a148 1
    parent = rb_parent(node, order);
d150 1
a150 1
	   (node == rb_child(parent, order, sense)))
d153 1
a153 1
	parent = rb_parent(parent, order);
d157 1
a157 1
    rb_current(tree) = parent;
d162 1
a162 1
/*		        R B _ N E I G H B O R ( )
d168 1
a168 1
 *	predecessor or successor) of the search.  rb_neighbor() returns
d173 1
a173 1
void *rb_neighbor (tree, order, sense)
d175 3
a177 3
rb_tree	*tree;
int	order;
int	sense;
d180 1
a180 1
    struct rb_node	*node;
d182 2
a183 2
    RB_CKMAG(tree, RB_TREE_MAGIC, "red-black tree");
    RB_CKORDER(tree, order);
d187 1
a187 1
	rt_log("FATAL: rb_neighbor(): invalid sense %d, file %s, line %s\n",
d193 1
a193 1
    node = _rb_neighbor(rb_current(tree), order, sense);
d195 1
a195 1
    if (node == rb_null(tree))
d200 2
a201 2
	rb_current(tree) = node;
	return (rb_data(node, order));
d205 1
a205 1
/*		            R B _ C U R R ( )
d210 1
a210 1
 *	to find the current node.  rb_curr() returns a pointer to
d214 1
a214 1
void *rb_curr (tree, order)
d216 2
a217 2
rb_tree	*tree;
int	order;
d220 2
a221 2
    RB_CKMAG(tree, RB_TREE_MAGIC, "red-black tree");
    RB_CKORDER(tree, order);
d223 1
a223 1
    if (rb_current(tree) == rb_null(tree))
d226 1
a226 1
	return (rb_data(rb_current(tree), order));
@


11.6
log
@Changed over to bu.h
@
text
@d10 1
a10 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_extreme.c,v 11.5 1995/09/20 16:00:44 pjt Exp pjt $";
d43 3
@


11.5
log
@Changed a comment
@
text
@d10 1
a10 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_extreme.c,v 11.4 1995/09/20 12:34:44 pjt Exp pjt $";
d19 2
@


11.4
log
@Tweeked a comment
@
text
@d10 1
a10 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_extreme.c,v 11.3 1995/07/10 20:17:51 pjt Exp pjt $";
d174 1
a174 1
    /* Wade throught the tree */
@


11.3
log
@Must now include rtlist.h before redblack.h
@
text
@d10 1
a10 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_extreme.c,v 11.2 1995/04/19 20:12:47 pjt Exp pjt $";
d150 1
a150 1
 *	predecessor or successor) of the search.  Rb_neighbor() returns
d192 1
a192 1
 *	to find the current node.  Rb_curr() returns a pointer to
@


11.2
log
@Implemented rb_curr()
@
text
@d10 1
a10 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_extreme.c,v 11.1 1995/01/04 10:05:54 mike Rel4_4 $";
d18 1
a18 1

@


11.1
log
@Release_4.4
@
text
@d3 1
a3 1
 *	Routines to extract mins, maxes, and adjacent nodes
d10 1
a10 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_extreme.c,v 2.5 95/01/04 05:49:56 mike Exp $";
d185 24
@


2.5
log
@Add machine.h, *after* the <stdio.h> guys.
@
text
@d10 1
a10 1
static char RCSid[] = "@@(#) $Header: /n/wolf/m/cad/libredblack/RCS/rb_extreme.c,v 2.4 1994/09/26 12:21:10 jra Exp stay $";
@


2.4
log
@Added #include "conf.h"
@
text
@d10 1
a10 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_extreme.c,v 2.3 94/09/22 15:34:44 pjt Exp Locker: jra $";
d17 2
@


2.3
log
@Changed "#include "rt_internals.h" to "#include "./rt_internals.h"
@
text
@d10 1
a10 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_extreme.c,v 2.2 94/09/22 15:27:01 pjt Exp Locker: pjt $";
d12 2
@


2.2
log
@Replaced prototype-type definition with K&R type
@
text
@d10 1
a10 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_extreme.c,v 2.1 93/03/25 11:03:18 pjt Exp $";
d16 1
a16 1
#include "rb_internals.h"
@


2.1
log
@Installed into BRL CAD tree
@
text
@d10 1
a10 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_extreme.c,v 1.14 93/03/25 11:00:22 pjt Exp Locker: pjt $";
d27 7
a33 2
static struct rb_node *_rb_extreme (struct rb_node *root, int order,
				    int sense, struct rb_node *empty_node)
d66 6
a71 1
void *rb_extreme (rb_tree *tree, int order, int sense)
d104 6
a109 1
struct rb_node *_rb_neighbor (struct rb_node *node, int order, int sense)
d151 6
a156 1
void *rb_neighbor (rb_tree *tree, int order, int sense)
@


1.14
log
@Added authorship comment
@
text
@d10 1
a10 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_extreme.c,v 1.13 93/01/15 13:08:49 pjt zero_1 Locker: pjt $";
@


1.13
log
@1. Switched from fprintf(stderr, ) to rt_log()
2. Added comments and general clean up
@
text
@d6 2
d10 1
a10 1
static char RCSid[] = "@@(#) $Header: /arl/pjt/libredblack/RCS/rb_extreme.c,v 1.12 93/01/15 10:43:44 pjt Exp Locker: pjt $";
@


1.12
log
@Addes static char RCSid[] to contain the RCS header
@
text
@d3 2
a4 1
 *	Written by:	Paul Tanenbaum
d8 1
a8 1
static char RCSid[] = "@@(#) $Header: /arl/pjt/libredblack/RCS/rb_extreme.c,v 1.11 93/01/14 15:06:42 pjt Exp Locker: pjt $";
d18 1
a18 1
 *	    Return the minimum or maximum node in a red-black tree
d57 1
a57 1
 *	data in the extreme node.
d68 1
a68 2
	fprintf(stderr,
	    "Error: rb_extreme(): invalid sense %d, file %s, line %s\n",
d89 2
a90 4
 *	returns a pointer to the adjacent node.  The bulk of this code
 *	is from T. H. Cormen, C. E. Leiserson, and R. L. Rivest.
 *	_Introduction to Algorithms_.  Cambridge, MA: MIT Press, 1990.
 *	p. 249.
a104 2
    fprintf(stderr,
	"_rb_neighbor(<%x>, %d, %d)...\n", (int) node, order, sense);
d127 6
a132 4
 *	This function has two parameters: the order on which to do the
 *	search and the sense (min or max, which is to say predecessor or
 *	successor).  Rb_neighbor() returns a pointer to the data in the
 *	adjacent node, if that node exists.  Otherwise, it returns NULL.
d143 1
a143 2
	fprintf(stderr,
	    "Error: rb_neighbor(): invalid sense %d, file %s, line %s\n",
@


1.11
log
@Switched from current_node to rb_current()
@
text
@a4 1
 *  $Header: /arl/pjt/libredblack/RCS/rb_extreme.c,v 1.10 93/01/14 12:25:36 pjt Exp Locker: pjt $
d6 3
@


1.10
log
@rb_extreme() and rb_neighbor() now return NULL if they fall off
either end of the tree
,.
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/rb_extreme.c,v 1.9 93/01/14 10:57:30 pjt Exp Locker: pjt $
d26 1
d31 2
a32 1
	RB_CKORDER(root -> rbn_tree, order);
d42 1
a42 1
    current_node = root;
d96 2
a97 1
    struct rb_node	*empty_node = rb_null(node -> rbn_tree);
d100 2
a101 1
    RB_CKORDER(node -> rbn_tree, order);
d103 2
d120 1
a120 1
    current_node = parent;
d134 1
a134 1
void *rb_neighbor (int order, int sense)
a135 1
    rb_tree		*tree;
d138 1
a138 2
    RB_CKMAG(current_node, RB_NODE_MAGIC, "red-black node");
    tree = current_node -> rbn_tree;
d150 1
a150 1
    node = _rb_neighbor(current_node, order, sense);
d157 1
a157 1
	current_node = node;
@


1.9
log
@Added calls to RB_CKMAG() and RB_CKORDER()
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/rb_extreme.c,v 1.8 93/01/14 09:30:52 pjt Exp Locker: pjt $
d72 4
a75 1
    return (rb_data(node, order));
d99 2
a100 2
    printf("_rb_neighbor(<%d>, %d, %d)...\n", (int) node, order, sense);
    fflush(stdout);
d104 1
a104 1
	return (_rb_extreme(child, order, sense, empty_node));
d148 5
a152 2
    /* Record the node with which we've been working */
    if (node != rb_null(tree))
d154 2
a155 2

    return (rb_data(node, order));
@


1.8
log
@1. Added empty_node parameter to _rb_extreme()
2. Use rb_null() and rb_data()
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/rb_extreme.c,v 1.7 92/12/23 12:42:52 pjt Exp Locker: pjt $
d30 2
a57 1
    /* Check data type of the parameter "tree" */
d59 1
a60 2
    /* Ensure other two parameters are within range */
    RB_CKORDER(tree, order);
d93 3
a129 1
    /* Ensure other two parameters are within range */
d133 1
@


1.7
log
@1. Broke _rb_extreme() out of rb_extreme()
2. Implemented _rb_neighbor() and rb_neighbor()
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/rb_extreme.c,v 1.6 92/12/23 11:10:49 pjt Exp Locker: pjt $
d17 4
a20 3
 *	This function has three parameters: the root of the tree, the
 *	order, and the sense (min or max).  _rb_extreme() returns a
 *	pointer to the extreme node.
d22 2
a23 1
static struct rb_node *_rb_extreme (struct rb_node *root, int order, int sense)
d32 1
a32 1
	if (child == RB_NODE_NULL)
d64 1
a64 1
	    "Error: _rb_extreme(): invalid sense %d, file %s, line %s\n",
d70 1
a70 1
    node = _rb_extreme(rb_root(tree, order), order, sense);
d72 1
a72 1
    return (node -> rbn_data);
d91 1
d93 2
d97 2
a98 2
    if (child != RB_NODE_NULL)
	return (_rb_extreme(child, order, sense));
d100 2
a101 2
    while ((parent != RB_NODE_NULL) &&
	   (node == rb_child(parent, order, SENSE)))
d143 1
a143 1
    if (node != RB_NODE_NULL)
d146 1
a146 1
    return (node -> rbn_data);
@


1.6
log
@Changed a comment
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/rb_extreme.c,v 1.5 92/11/06 13:54:23 pjt Exp Locker: pjt $
d13 1
a13 1
/*		        R B _ E X T R E M E ( )
d17 28
d47 2
a48 2
 *	(min or max).  On success, _rb_extreme() returns a pointer to
 *	the extreme node.
d50 1
a50 1
void *rb_extreme (rb_tree *tree, int order_nm, int sense)
a51 2
    int			(*order)();  /* Comparison functions */
    struct rb_node	*child;
d58 1
a58 1
    RB_CKORDER(tree, order_nm);
d67 30
a96 2
    node = rb_root(tree, order_nm);
    while (1)
d98 2
a99 6
	RB_CKMAG(node, RB_NODE_MAGIC, "red-black node");
	child = (sense == SENSE_MIN) ? rb_left_child(node, order_nm) :
				       rb_right_child(node, order_nm);
	if (child == RB_NODE_NULL)
	    break;
	node = child;
d103 35
d140 1
@


1.5
log
@renamed _rb_extreme() to rb_extreme()
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/rb_extreme.c,v 1.4 92/11/05 11:32:21 pjt Exp Locker: pjt $
d20 1
a20 1
 *	the extreme node.  Otherwise, it returns RB_NODE_NULL.
@


1.4
log
@Replaced reference to rbt_root by call to rb_root()
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/rb_extreme.c,v 1.3 92/11/04 12:12:32 pjt Exp Locker: pjt $
d13 1
a13 1
/*		        _ R B _ E X T R E M E ( )
d22 1
a22 1
void *_rb_extreme (rb_tree *tree, int order_nm, int sense)
@


1.3
log
@Generalized rb_min() to _rb_extreme() and implemented
rb_min() and rb_max() as calls to _rb_extreme()
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/rb_min.c,v 1.2 92/11/04 10:49:01 pjt Exp Locker: pjt $
d41 1
a41 1
    node = tree -> rbt_root;
@


1.2
log
@Removed three diagnostics
@
text
@d1 1
a1 1
/*			R B _ M I N . C
d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/rb_min.c,v 1.1 92/11/04 10:29:41 pjt Exp Locker: pjt $
d13 1
a13 1
/*		        R B _ M I N ( )
d15 1
a15 1
 *		Return the minimum node in a red-black tree
d17 4
a20 6
 *	This function has two parameters: the tree in which to find the
 *	the minimum node and the order on which to do the search.
 *	is from T. H. Cormen, C. E. Leiserson, and R. L. Rivest.  _Intro-
 *	duction to Algorithms_.  Cambridge, MA: MIT Press, 1990. p. 268.
 *	On success, rb_min() returns a pointer to the minimum node.
 *	Otherwise, it returns RB_NODE_NULL.
d22 1
a22 1
void *rb_min (rb_tree *tree, int order_nm)
d25 1
a29 1
    order = (tree -> rbt_order)[order_nm];
d31 10
d45 3
a47 1
	if (rb_left_child(node, order_nm) == RB_NODE_NULL)
d49 1
a49 1
	node = rb_left_child(node, order_nm);
d53 2
a54 1
    current_node = node;
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.1 91/10/12 06:35:30 mike Rel4_0 $
a33 1
    fprintf(stderr, "node is <%x>\n", node);fflush(stderr);
a39 1
	fprintf(stderr, "node is <%x>\n", node);fflush(stderr);
a43 2
    fprintf(stderr, "rb_min() found node <%x>, returning <%x>\n",
		node, node -> rbn_data);fflush(stderr);
@
