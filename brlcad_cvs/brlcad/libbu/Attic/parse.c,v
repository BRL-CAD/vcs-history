head	1.52;
access;
symbols
	ansi-20040405-merged:1.47.2.3
	postmerge-20040405-ansi:1.50
	premerge-20040404-ansi:1.49
	postmerge-autoconf:1.49
	autoconf-freeze:1.47.10.3
	premerge-autoconf:1.49
	ansi-20040316-freeze:1.47.2.1
	postmerge-20040315-windows:1.49
	premerge-20040315-windows:1.48
	windows-20040315-freeze:1.47.4.2
	autoconf-20031203:1.47
	autoconf-20031202:1.47
	autoconf-branch:1.47.0.10
	phong-branch:1.47.0.8
	photonmap-branch:1.47.0.6
	rel-6-1-DP:1.47
	windows-branch:1.47.0.4
	rel-6-0-2:1.45
	ansi-branch:1.47.0.2
	rel-6-0-1-branch:1.45.0.2
	hartley-6-0-post:1.46
	hartley-6-0-pre:1.45
	rel-6-0-1:1.45
	rel-6-0:1.45
	rel-5-4:1.25.2.1
	offsite-5-3-pre:1.39
	rel-5-3:1.25.2.1
	rel-5-2:1.25
	rel-5-1-branch:1.25.0.2
	rel-5-1:1.25
	rel-5-0:1.21
	rel-5-0-beta:1.21
	rel-4-5:1.6
	ctj-4-5-post:1.6
	ctj-4-5-pre:1.6;
locks; strict;
comment	@ * @;


1.52
date	2004.05.21.18.06.24;	author morrison;	state dead;
branches;
next	1.51;

1.51
date	2004.05.10.15.30.44;	author erikg;	state Exp;
branches;
next	1.50;

1.50
date	2004.04.05.07.46.16;	author morrison;	state Exp;
branches;
next	1.49;

1.49
date	2004.03.16.19.40.49;	author morrison;	state Exp;
branches;
next	1.48;

1.48
date	2004.02.02.17.39.07;	author morrison;	state Exp;
branches;
next	1.47;

1.47
date	2002.08.20.17.07.41;	author jra;	state Exp;
branches
	1.47.2.1
	1.47.4.1
	1.47.10.1;
next	1.46;

1.46
date	2002.08.15.20.54.54;	author hartley;	state Exp;
branches;
next	1.45;

1.45
date	2001.11.02.05.01.16;	author butler;	state Exp;
branches;
next	1.44;

1.44
date	2001.07.17.23.20.35;	author morrison;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.14.15.07.28;	author bparker;	state Exp;
branches;
next	1.42;

1.42
date	2001.06.01.17.42.51;	author bparker;	state Exp;
branches;
next	1.41;

1.41
date	2001.04.05.19.35.30;	author morrison;	state Exp;
branches;
next	1.40;

1.40
date	2001.03.19.22.19.45;	author butler;	state Exp;
branches;
next	1.39;

1.39
date	2000.10.30.15.06.26;	author jra;	state Exp;
branches;
next	1.38;

1.38
date	2000.10.24.14.35.47;	author mike;	state Exp;
branches;
next	1.37;

1.37
date	2000.07.27.14.35.22;	author mike;	state Exp;
branches;
next	1.36;

1.36
date	2000.07.26.17.17.57;	author mike;	state Exp;
branches;
next	1.35;

1.35
date	2000.07.12.01.25.28;	author mike;	state Exp;
branches;
next	1.34;

1.34
date	2000.07.12.01.18.00;	author mike;	state Exp;
branches;
next	1.33;

1.33
date	2000.07.12.01.12.38;	author mike;	state Exp;
branches;
next	1.32;

1.32
date	2000.07.07.05.20.13;	author cjohnson;	state Exp;
branches;
next	1.31;

1.31
date	2000.07.05.21.19.37;	author mike;	state Exp;
branches;
next	1.30;

1.30
date	2000.06.28.21.44.12;	author mike;	state Exp;
branches;
next	1.29;

1.29
date	2000.06.28.21.31.43;	author mike;	state Exp;
branches;
next	1.28;

1.28
date	2000.06.27.20.55.23;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	2000.06.27.17.38.28;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	2000.06.26.19.38.21;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	2000.06.23.04.55.46;	author mike;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2000.02.23.22.25.48;	author butler;	state Exp;
branches;
next	1.23;

1.23
date	99.12.29.20.15.47;	author jra;	state Exp;
branches;
next	1.22;

1.22
date	99.12.17.02.41.37;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	99.01.22.21.41.59;	author jra;	state Exp;
branches;
next	1.20;

1.20
date	99.01.22.11.00.49;	author butler;	state Exp;
branches;
next	1.19;

1.19
date	99.01.20.23.41.09;	author jra;	state Exp;
branches;
next	1.18;

1.18
date	99.01.13.02.22.41;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	99.01.13.02.08.17;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	98.12.10.04.08.18;	author jra;	state Exp;
branches;
next	1.15;

1.15
date	98.07.13.19.09.19;	author jra;	state Exp;
branches;
next	1.14;

1.14
date	98.07.13.13.10.24;	author jra;	state Exp;
branches;
next	1.13;

1.13
date	98.07.09.15.30.21;	author jra;	state Exp;
branches;
next	1.12;

1.12
date	98.06.23.17.51.03;	author jra;	state Exp;
branches;
next	1.11;

1.11
date	98.06.23.17.28.04;	author jra;	state Exp;
branches;
next	1.10;

1.10
date	98.06.22.19.47.07;	author jra;	state Exp;
branches;
next	1.9;

1.9
date	98.06.04.18.39.37;	author jra;	state Exp;
branches;
next	1.8;

1.8
date	98.05.29.20.20.14;	author jra;	state Exp;
branches;
next	1.7;

1.7
date	98.04.03.01.33.00;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	97.04.01.20.22.16;	author butler;	state Exp;
branches;
next	1.5;

1.5
date	97.01.03.17.23.18;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	96.08.31.11.27.25;	author butler;	state Exp;
branches;
next	1.3;

1.3
date	96.08.31.08.02.20;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	96.08.29.22.56.01;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	96.08.29.22.42.41;	author butler;	state Exp;
branches;
next	;

1.25.2.1
date	2000.10.30.14.57.34;	author jra;	state Exp;
branches;
next	;

1.47.2.1
date	2002.09.19.18.01.13;	author morrison;	state Exp;
branches;
next	1.47.2.2;

1.47.2.2
date	2004.03.17.21.16.50;	author morrison;	state Exp;
branches;
next	1.47.2.3;

1.47.2.3
date	2004.04.02.16.02.39;	author morrison;	state Exp;
branches;
next	;

1.47.4.1
date	2002.09.26.23.03.52;	author morrison;	state Exp;
branches;
next	1.47.4.2;

1.47.4.2
date	2004.03.11.23.41.49;	author morrison;	state Exp;
branches;
next	;

1.47.10.1
date	2004.02.12.18.39.18;	author erikg;	state Exp;
branches;
next	1.47.10.2;

1.47.10.2
date	2004.03.15.14.06.17;	author erikg;	state Exp;
branches;
next	1.47.10.3;

1.47.10.3
date	2004.03.18.18.08.13;	author erikg;	state Exp;
branches;
next	;


desc
@Subroutines for parsing arbitrary structures.
@


1.52
log
@moved to src/
@
text
@/*
 *			P A R S E . C
 *
 *  Routines to assign values to elements of arbitrary structures.
 *  The layout of a structure to be processed is described by
 *  a structure of type "bu_structparse", giving element names, element
 *  formats, an offset from the beginning of the structure, and
 *  a pointer to an optional "hooked" function that is called whenever
 *  that structure element is changed.
 *
 *  There are four basic operations supported:
 *	print	struct elements to ASCII
 *	parse	ASCII to struct elements
 *	export	struct elements to machine-independent binary
 *	import	machine-independent binary to struct elements
 *
 *
 *  Authors -
 *	Michael John Muuss
 *	Lee A. Butler
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1989-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSparse[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libbu/parse.c,v 1.51 2004/05/10 15:30:44 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <ctype.h>
#include <math.h>
#ifdef USE_STRING_H
# include <string.h>
#else
# include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "bu.h"


#define CKMEM( _len )	{  \
	register int	offset; \
	if( (offset = (ep - cp) - (_len)) < 0 )  { \
		do  { \
			offset += ext->ext_nbytes;	/* decr by new growth */ \
			ext->ext_nbytes <<= 1; \
		} while( offset < 0 ); \
		offset = cp - (char *)ext->ext_buf; \
		ext->ext_buf = (genptr_t)bu_realloc( (char *) ext->ext_buf, \
		     ext->ext_nbytes, "bu_struct_export" ); \
		ep = (char *) ext->ext_buf + ext->ext_nbytes; \
		cp = (char *) ext->ext_buf + offset; \
	} }

#define	BU_GETPUT_MAGIC_1	0x15cb
#define BU_GETPUT_MAGIC_2	0xbc51
#define BU_INIT_GETPUT_1(_p)	{ \
	BU_CK_EXTERNAL(_p); \
	((unsigned char *) _p->ext_buf)[1] = (BU_GETPUT_MAGIC_1 & 0xFF); \
	((unsigned char *) _p->ext_buf)[0] = (BU_GETPUT_MAGIC_1 >> 8) & 0xFF; \
	}
#define BU_INIT_GETPUT_2(_p,_l)	{\
	BU_CK_EXTERNAL(_p); \
	((unsigned char *) _p->ext_buf)[_l-1] = (BU_GETPUT_MAGIC_2 & 0xFF); \
	((unsigned char *) _p->ext_buf)[_l-2] = (BU_GETPUT_MAGIC_2 >> 8) & 0xFF; \
	}

#define	BU_CK_GETPUT(_p) {\
	register long _i; \
	register long _len; \
	BU_CK_EXTERNAL(_p); \
	if ( !(_p->ext_buf) ) { \
		bu_log("ERROR: BU_CK_GETPUT null ext_buf, file %s, line %d\n", \
		    __FILE__, __LINE__); \
		bu_bomb("NULL pointer"); \
	} \
	if ( _p->ext_nbytes < 6 ) { \
		bu_log("ERROR: BU_CK_GETPUT buffer only %d bytes, file %s, line %d\n", \
		    _p->ext_nbytes, __FILE__, __LINE__); \
		bu_bomb("getput buffer too small"); \
	} \
	_i = (((unsigned char *)(_p->ext_buf))[0] << 8) | \
	      ((unsigned char *)(_p->ext_buf))[1]; \
	if ( _i != BU_GETPUT_MAGIC_1)  { \
		bu_log("ERROR: BU_CK_GETPUT buffer x%x, magic1 s/b x%x, was %s(x%x), file %s, line %d\n", \
		    _p->ext_buf, BU_GETPUT_MAGIC_1, \
		    bu_identify_magic( _i), _i, __FILE__, __LINE__); \
		bu_bomb("Bad getput buffer"); \
	} \
	_len = (((unsigned char *)(_p->ext_buf))[2] << 24) | \
	       (((unsigned char *)(_p->ext_buf))[3] << 16) | \
	       (((unsigned char *)(_p->ext_buf))[4] <<  8) | \
		((unsigned char *)(_p->ext_buf))[5]; \
	if (_len > _p->ext_nbytes) { \
		bu_log("ERROR: BU_CK_GETPUT buffer x%x, expected len=%d, ext_nbytes=%d, file %s, line %d\n", \
		    _p->ext_buf, _len, _p->ext_nbytes, \
		    __FILE__, __LINE__); \
		bu_bomb("Bad getput buffer"); \
	} \
	_i = (((unsigned char *)(_p->ext_buf))[_len-2] << 8) | \
	      ((unsigned char *)(_p->ext_buf))[_len-1]; \
	if ( _i != BU_GETPUT_MAGIC_2) { \
		bu_log("ERROR: BU_CK_GETPUT buffer x%x, magic2 s/b x%x, was %s(x%x), file %s, line %d\n", \
		    _p->ext_buf, BU_GETPUT_MAGIC_2, \
		    bu_identify_magic( _i), _i, __FILE__, __LINE__); \
		bu_bomb("Bad getput buffer"); \
	} \
}
	
/*
 *			B U _ S T R U C T _ E X P O R T
 */
int
bu_struct_export(struct bu_external *ext, const genptr_t base, const struct bu_structparse *imp)
{
	register char	*cp;		/* current possition in buffer */
	char		*ep;		/* &ext->ext_buf[ext->ext_nbytes] */
	const struct bu_structparse *ip;	/* current imexport structure */
	char		*loc;		/* where host-format data is */
	int		len;
	register int	i;

	BU_INIT_EXTERNAL(ext);

	ext->ext_nbytes = 480;
	ext->ext_buf = (genptr_t)bu_malloc( ext->ext_nbytes,
	    "bu_struct_export output ext->ext_buf" );
	BU_INIT_GETPUT_1(ext);
	cp = (char *) ext->ext_buf + 6; /* skip magic and length */
	ep = cp + ext->ext_nbytes;

	for( ip = imp; ip->sp_fmt[0] != '\0'; ip++ )  {

#if CRAY && !__STDC__
		loc = ((char *)base) + ((int)ip->sp_offset*sizeof(int));
#else
		loc = ((char *)base) + ((int)ip->sp_offset);
#endif

		switch( ip->sp_fmt[0] )  {
		case 'i':
			/* Indirect to another structure */
			/* deferred */
			bu_free( (char *) ext->ext_buf, "output ext_buf" );
			return( 0 );
		case '%':
			/* See below */
			break;
		default:
			/* Unknown */
			bu_free( (char *) ext->ext_buf, "output ext_buf" );
			return( 0 );
		}
		/* [0] == '%', use printf-like format char */
		switch( ip->sp_fmt[1] )  {
		case 'f':
			/* Double-precision floating point */
			len = ip->sp_count * 8;
			CKMEM( len );
			htond( (unsigned char *)cp, (unsigned char *)loc, ip->sp_count );
			cp += len;
			continue;
		case 'd':
			/* 32-bit network integer, from "int" */
			CKMEM( ip->sp_count * 4 ); 
			{
				register unsigned long	l;
				for( i = ip->sp_count-1; i >= 0; i-- )  {
					l = *((int *)loc);
					cp[3] = l;
					cp[2] = l >> 8;
					cp[1] = l >> 16;
					cp[0] = l >> 24;
					loc += sizeof(int);
					cp += 4;
				}
			}
			continue;
		case 'i':
			/* 16-bit integer, from "int" */
			CKMEM( ip->sp_count * 2 );
			{
				register unsigned short	s;
				for( i = ip->sp_count-1; i >= 0; i-- )  {
					s = *((int *)loc);
					cp[1] = s;
					cp[0] = s >> 8;
					loc += sizeof(int); /* XXX */
					cp += 2;
				}
			}
			continue;
		case 's':
			{
				/* char array is transmitted as a
				 * 4 byte character count, followed by a
				 * null terminated, word padded char array.
				 * The count includes any pad bytes,
				 * but not the count itself.
				 *
				 * ip->sp_count == sizeof(char array)
				 */
				register int lenstr;

				/* include the terminating null */
				lenstr = strlen( loc ) + 1;

				len = lenstr;

				/* output an integer number of words */
				if ((len & 0x03) != 0)
					len += 4 - (len & 0x03);

				CKMEM( len + 4 );

				/* put the length on the front
				 * of the string
				 */
				cp[3] = len;
				cp[2] = len >> 8;
				cp[1] = len >> 16;
				cp[0] = len >> 24;

				cp += 4;

				bcopy( loc, cp, lenstr );
				cp += lenstr;
				while (lenstr++ < len) *cp++ = '\0';
			}
			continue;
		case 'c':
			{
				CKMEM( ip->sp_count + 4 );
				cp[3] = ip->sp_count;
				cp[2] = ip->sp_count >> 8;
				cp[1] = ip->sp_count >> 16;
				cp[0] = ip->sp_count >> 24;
				cp += 4;
				bcopy( loc, cp, ip->sp_count);
				cp += ip->sp_count;
			}
			continue;
		default:
			bu_free( (char *) ext->ext_buf, "output ext_buf" );
			return( 0 );
		}
	}
	CKMEM( 2);	/* get room for the trailing magic number */
	cp += 2;

	i = cp - (char *)ext->ext_buf;
	/* Fill in length in external buffer */
	((char *)ext->ext_buf)[5] = i;
	((char *)ext->ext_buf)[4] = i >> 8;
	((char *)ext->ext_buf)[3] = i >>16;
	((char *)ext->ext_buf)[2] = i >>24;
	BU_INIT_GETPUT_2(ext, i);
	ext->ext_nbytes = i;	/* XXX this changes nbytes if i < 480 ? */
	return( 1 );
}

/*
 *			B U _ S T R U C T _ I M P O R T
 */
int
bu_struct_import(genptr_t base, const struct bu_structparse *imp, const struct bu_external *ext)
{
	register const unsigned char	*cp;	/* current possition in buffer */
	const struct bu_structparse	*ip;	/* current imexport structure */
	char		*loc;		/* where host-format data is */
	int		len;
	int		bytes_used;
	register int	i;

	BU_CK_GETPUT(ext);
	
	cp = (unsigned char *)ext->ext_buf+6;
	bytes_used = 0;
	for( ip = imp; ip->sp_fmt[0] != '\0'; ip++ )  {

#if CRAY && !__STDC__
		loc = ((char *)base) + ((int)ip->sp_offset*sizeof(int));
#else
		loc = ((char *)base) + ((int)ip->sp_offset);
#endif

		switch( ip->sp_fmt[0] )  {
		case 'i':
			/* Indirect to another structure */
			/* deferred */
			return( -1 );
		case '%':
			/* See below */
			break;
		default:
			/* Unknown */
			return( -1 );
		}
		/* [0] == '%', use printf-like format char */
		switch( ip->sp_fmt[1] )  {
		case 'f':
			/* Double-precision floating point */
			len = ip->sp_count * 8;
			ntohd( (unsigned char *)loc, cp, ip->sp_count );
			cp += len;
			bytes_used += len;
			break;
		case 'd':
			/* 32-bit network integer, from "int" */
			{
				register long	l;
				for( i = ip->sp_count-1; i >= 0; i-- )  {
					l =	(cp[0] << 24) |
						(cp[1] << 16) |
						(cp[2] <<  8) |
						 cp[3];
					*(int *)loc = l;
					loc += sizeof(int); /* XXX */
					cp += 4;
				}
				bytes_used += ip->sp_count * 4;
			}
			break;
		case 'i':
			/* 16-bit integer, from "int" */
			for( i = ip->sp_count-1; i >= 0; i-- )  {
				*(int *)loc =	(cp[0] <<  8) |
						 cp[1];
				loc += sizeof(int); /* XXX */
				cp += 2;
			}
			bytes_used += ip->sp_count * 2;
			break;
		case 's': 
			{	/* char array transmitted as a
				 * 4 byte character count, followed by a
				 * null terminated, word padded char array
				 *
				 * ip->sp_count == sizeof(char array)
				 */
				register unsigned long lenstr;

				lenstr = (cp[0] << 24) |
					 (cp[1] << 16) |
					 (cp[2] <<  8) |
					  cp[3];

				cp += 4;

				/* don't read more than the buffer can hold */
				if (ip->sp_count < lenstr)
					bcopy( cp, loc, ip->sp_count);
				else
					bcopy( cp, loc, lenstr );

				/* ensure proper null termination */
				loc[ip->sp_count-1] = '\0';

				cp += lenstr;
				bytes_used += lenstr;
			}
			break;
		case 'c':
			{
				register unsigned long lenarray;

				lenarray = (cp[0] << 24) |
					   (cp[1] << 16) |
					   (cp[2] <<  8) |
					    cp[3];
				cp += 4;

				if (ip->sp_count < lenarray) {
					bcopy( cp, loc, ip->sp_count);
				} else {
					bcopy( cp, loc, lenarray );
				}
				cp += lenarray;
				bytes_used += lenarray;
			}
			break;
		default:
			return( -1 );
		}
		if ( ip->sp_hook ) {

			ip->sp_hook (ip, ip->sp_name, base, (char *)NULL);
		}
	}

	/* This number may differ from that stored as "claimed_length" */
	return( bytes_used );
}

/*
 *			B U _ S T R U C T _ P U T
 *
 *  Put a structure in external form to a stdio file.
 *  All formatting must have been accomplished previously.
 */
int
bu_struct_put(FILE *fp, const struct bu_external *ext)
{
	BU_CK_GETPUT(ext);

	return(fwrite(ext->ext_buf, 1, ext->ext_nbytes, fp));
}

/*
 *			B U _ S T R U C T _ G E T
 *
 *  Obtain the next structure in external form from a stdio file.
 */
int
bu_struct_get(struct bu_external *ext, FILE *fp)
{
	register long i, len;

	BU_INIT_EXTERNAL(ext);
	ext->ext_buf = (genptr_t) bu_malloc( 6, "bu_struct_get buffer head");
	bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */

	i=fread( (char *) ext->ext_buf, 1, 6, fp);	/* res_syscall */
	bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */

	if (i != 6 ) {
		if (i == 0) return(0);
		bu_log("ERROR: bu_struct_get bad fread (%d), file %s, line %d\n",
		    i, __FILE__, __LINE__);
		bu_bomb("Bad fread");
	}
	i = (((unsigned char *)(ext->ext_buf))[0] << 8) |
	     ((unsigned char *)(ext->ext_buf))[1];
	len = (((unsigned char *)(ext->ext_buf))[2] << 24) |
	      (((unsigned char *)(ext->ext_buf))[3] << 16) |
	      (((unsigned char *)(ext->ext_buf))[4] <<  8) |
	       ((unsigned char *)(ext->ext_buf))[5];
	if ( i != BU_GETPUT_MAGIC_1) {
		bu_log("ERROR: bad getput buffer header x%x, s/b x%x, was %s(x%x), file %s, line %d\n",
		    ext->ext_buf, BU_GETPUT_MAGIC_1,
		    bu_identify_magic( i), i, __FILE__, __LINE__);
		bu_bomb("bad getput buffer");
	}
	ext->ext_nbytes = len;
	ext->ext_buf = (genptr_t) bu_realloc((char *) ext->ext_buf, len,
	    "bu_struct_get full buffer");
	bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
	i=fread((char *) ext->ext_buf + 6, 1 , len-6, fp);	/* res_syscall */
	bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
	if (i != len-6) {
		bu_log("ERROR: bu_struct_get bad fread (%d), file %s, line %d\n",
		    i, __FILE__, __LINE__);
		bu_bomb("Bad fread");
	}
	i = (((unsigned char *)(ext->ext_buf))[len-2] <<8) | 
	     ((unsigned char *)(ext->ext_buf))[len-1];
	if ( i != BU_GETPUT_MAGIC_2) {
		bu_log("ERROR: bad getput buffer x%x, s/b x%x, was %s(x%x), file %s, line %d\n",
		    ext->ext_buf, BU_GETPUT_MAGIC_2,
		    bu_identify_magic( i), i, __FILE__, __LINE__);
		bu_bomb("Bad getput buffer");
	}
	return(1);
}

/*
 *			B U _ S T R U C T _ B U F
 *
 *  Given a buffer with an external representation of a structure
 *  (e.g. the ext_buf portion of the output from bu_struct_export),
 *  check it for damage in shipment, and if it's OK,
 *  wrap it up in an bu_external structure, suitable for passing
 *  to bu_struct_import().
 */
void
bu_struct_wrap_buf(struct bu_external *ext, genptr_t buf)
{
	register long i, len;

	BU_INIT_EXTERNAL(ext);
	ext->ext_buf = buf;
	i = (((unsigned char *)(ext->ext_buf))[0] << 8) |
	     ((unsigned char *)(ext->ext_buf))[1];
	len = (((unsigned char *)(ext->ext_buf))[2] << 24) |
	      (((unsigned char *)(ext->ext_buf))[3] << 16) |
	      (((unsigned char *)(ext->ext_buf))[4] <<  8) |
	       ((unsigned char *)(ext->ext_buf))[5];
	if ( i != BU_GETPUT_MAGIC_1) {
		bu_log("ERROR: bad getput buffer header x%x, s/b x%x, was %s(x%x), file %s, line %d\n",
		    ext->ext_buf, BU_GETPUT_MAGIC_1,
		    bu_identify_magic( i), i, __FILE__, __LINE__);
		bu_bomb("bad getput buffer");
	}
	ext->ext_nbytes = len;
	i = (((unsigned char *)(ext->ext_buf))[len-2] <<8) | 
	     ((unsigned char *)(ext->ext_buf))[len-1];
	if ( i != BU_GETPUT_MAGIC_2) {
		bu_log("ERROR: bad getput buffer x%x, s/b x%x, was %s(x%x), file %s, line %s\n",
		    ext->ext_buf, BU_GETPUT_MAGIC_2,
		    bu_identify_magic( i), i, __FILE__, __LINE__);
		bu_bomb("Bad getput buffer");
	}
}










/*
 *			B U _ P A R S E _ D O U B L E
 *
 *  Parse an array of one or more doubles.
 *  Return value: 0 when successful
 *               <0 upon failure
 */
HIDDEN int
bu_parse_double(const char *str, long int count, double *loc)
{
	long	i;
	int	dot_seen;
	const char	*numstart;
	double	tmp_double;
	char	buf[128];	
	int	len;

	for (i=0 ; i < count && *str ; ++i){
		numstart = str;

		/* skip sign */
		if (*str == '-' || *str == '+') str++;

		/* skip matissa */
		dot_seen = 0;
		for ( ; *str ; str++ ) {
			if (*str == '.' && !dot_seen) {
				dot_seen = 1;
				continue;
			}
			if (!isdigit(*str))
				break;
			
		}

		/* If no mantissa seen, then there is no float here */
		if (str == (numstart + dot_seen) )
			return -1;

		/* there was a mantissa, so we may have an exponent */
		if  (*str == 'E' || *str == 'e') {
			str++;

			/* skip exponent sign */
		    	if (*str == '+' || *str == '-') str++;

			while (isdigit(*str)) str++;
		}

		len = str - numstart;
		if( len > sizeof(buf)-1 )  len = sizeof(buf)-1;
		strncpy( buf, numstart, len );
		buf[len] = '\0';

		if( sscanf( buf, "%lf", &tmp_double ) != 1 )
			return -1;

		*loc++ = tmp_double;

		/* skip the separator */
		if (*str) str++;
	}
	return 0;
}

/*
 *			B U _ S T R U C T _ L O O K U P
 *
 *  Returns -
 *      -2      parse error
 *	-1	not found
 *	 0	entry found and processed
 */
HIDDEN int
bu_struct_lookup(register const struct bu_structparse *sdp, register const char *name, const char *base, const char *const value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          			       	      	/* string containing value */
{
	register char *loc;
	int i, retval = 0;

	for( ; sdp->sp_name != (char *)0; sdp++ )  {

		if( strcmp( sdp->sp_name, name ) != 0	/* no name match */
		    && sdp->sp_fmt[0] != 'i' )		/* no include desc */

		    continue;

		/* if we get this far, we've got a name match
		 * with a name in the structure description
		 */

#if CRAY && !__STDC__
		loc = (char *)(base + ((int)sdp->sp_offset*sizeof(int)));
#else
		loc = (char *)(base + ((int)sdp->sp_offset));
#endif

		if (sdp->sp_fmt[0] == 'i') {
			/* Indirect to another structure */
			if( bu_struct_lookup(
				(struct bu_structparse *)sdp->sp_count,
				name, base, value )
			    == 0 )
				return(0);	/* found */
			else
				continue;
		}
		if (sdp->sp_fmt[0] != '%') {
			bu_log("bu_struct_lookup(%s): unknown format '%s'\n",
				name, sdp->sp_fmt );
			return(-1);
		}

		switch( sdp->sp_fmt[1] )  {
		case 'c':
		case 's':
			{	register int i, j;

				/* copy the string, converting escaped
				 * double quotes to just double quotes
				 */
				for(i=j=0 ;
				    j < sdp->sp_count && value[i] != '\0' ;
				    loc[j++] = value[i++])
					if (value[i] == '\\' &&
					    value[i+1] == '"')
					    	++i;

				/* Don't null terminate chars, only strings */
				if (sdp->sp_count > 1)  {
					/* OK, it's a string */
					if( j < sdp->sp_count-1 )
						loc[j] = '\0';
					else
						loc[sdp->sp_count-1] = '\0';
				}
			}
			break;
		case 'S':
			{	struct bu_vls *vls = (struct bu_vls *)loc;
				bu_vls_init_if_uninit( vls );
				bu_vls_strcpy(vls, value);
			}
			break;
		case 'i':
			{	register short *ip = (short *)loc;
				register short tmpi;
				register const char *cp;
				register const char *pv = value;

				for (i=0 ; i < sdp->sp_count && *pv ; ++i){
					tmpi = atoi( pv );

					cp = pv;
					if (*cp && (*cp == '+' || *cp == '-'))
						cp++;

					while (*cp && isdigit(*cp) )
						cp++; 

					/* make sure we actually had an
					 * integer out there
					 */
					if (cp == pv ||
					    (cp == pv+1 &&
					    (*pv == '+' || *pv == '-'))){
					    retval = -2;
					    break;
					} else {
						*(ip++) = tmpi;
						pv = cp;
					}
					/* skip the separator */
					if (*pv) pv++;
				}
			}
			break;
		case 'd':
			{	register int *ip = (int *)loc;
				register int tmpi;
				register char const *cp;
				register const char *pv = value;

				/* Special case:  '=!' toggles a boolean */
				if( *pv == '!' )  {
					*ip = *ip ? 0 : 1;
					pv++;
					break;
				}
				/* Normal case: an integer */
				for (i=0 ; i < sdp->sp_count && *pv ; ++i){
					tmpi = atoi( pv );

					cp = pv;
					if (*cp && (*cp == '+' || *cp == '-'))
						cp++;

					while (*cp && isdigit(*cp) )
						cp++; 

					/* make sure we actually had an
					 * integer out there
					 */
					if (cp == pv ||
					    (cp == pv+1 &&
					    (*pv == '+' || *pv == '-'))){
					    retval = -2;
					    break;
					} else {
						*(ip++) = tmpi;
						pv = cp;
					}
					/* skip the separator */
					if (*pv) pv++;
				}
			}
			break;
		case 'f':
			retval = bu_parse_double(value, sdp->sp_count,
						 (double *)loc);
			break;
		default:
			bu_log("bu_struct_lookup(%s): unknown format '%s'\n",
				name, sdp->sp_fmt );
			return(-1);
		}
		if( sdp->sp_hook )  {
			sdp->sp_hook( sdp, name, base, value );
		}
		return(retval);		/* OK or parse error */
	}
	return(-1);			/* Not found */
}

/*
 *			B U _ S T R U C T P A R S E
 *
 *	Parse the structure element description in the vls string "vls"
 *	according to the structure description in "parsetab"
 *
 *  Returns -
 *	<0	failure
 *	 0	OK
 */
int
bu_struct_parse(const struct bu_vls *in_vls, const struct bu_structparse *desc, const char *base)
                   		        	/* string to parse through */
                           	      		/* structure description */
    				      		/* base addr of users struct */
{
	struct bu_vls	vls;
	register char *cp;
	char	*name;
	char	*value;
	int retval;

	BU_CK_VLS(in_vls);
	if (desc == (struct bu_structparse *)NULL) {
		bu_log( "Null \"struct bu_structparse\" pointer\n");
		return(-1);
	}

	/* Duplicate the input string.  This algorithm is destructive. */
	bu_vls_init( &vls );
	bu_vls_vlscat( &vls, in_vls );
	cp = bu_vls_addr( &vls );

	while( *cp )  {
		/* NAME = VALUE white-space-separator */

		/* skip any leading whitespace */
		while( *cp != '\0' && isascii(*cp) && isspace(*cp) )
			cp++;

		/* Find equal sign */
		name = cp;
		while ( *cp != '\0' && *cp != '=' )
			cp++;

		if( *cp == '\0' )  {
			if( name == cp ) break;

			/* end of string in middle of arg */
			bu_log("bu_structparse: input keyword '%s' is not followed by '=' in '%s'\nInput must be in keyword=value format.\n",
				name, bu_vls_addr(in_vls) );
			bu_vls_free( &vls );
			return(-2);
		}

		*cp++ = '\0';

		/* Find end of value. */
		if (*cp == '"')	{
			/* strings are double-quote (") delimited
			 * skip leading " & find terminating "
			 * while skipping escaped quotes (\")
			 */
			for (value = ++cp ; *cp != '\0' ; ++cp)
				if (*cp == '"' &&
				    (cp == value || *(cp-1) != '\\') )
					break;

			if (*cp != '"') {
				bu_log("bu_structparse: keyword '%s'=\" without closing \"\n",
					name);
				bu_vls_free( &vls );
				return(-3);
			}
		} else {
			/* non-strings are white-space delimited */
			value = cp;
			while( *cp != '\0' && isascii(*cp) && !isspace(*cp) )
				cp++;
		}

		if( *cp != '\0' )
			*cp++ = '\0';

		/* Lookup name in desc table and modify */
		retval = bu_struct_lookup( desc, name, base, value );
		if( retval == -1 ) {
		    bu_log("bu_structparse:  '%s=%s', keyword not found in:\n",
			   name, value);
		    bu_struct_print( "troublesome one", desc, base );
		} else if( retval == -2 ) {
		    bu_vls_free( &vls );
		    return -2;
		}

	}
	bu_vls_free( &vls );
	return(0);
}


/*
 *			B U _ M A T P R I N T
 *
 *	XXX Should this be here, or could it be with the matrix support?
 *	pretty-print a matrix
 */
HIDDEN void
bu_matprint(const char *name, register const double *mat)
{
	int	delta = strlen(name)+2;

	/* indent the body of the matrix */
	bu_log_indent_delta(delta);

	bu_log(" %s=%12E %12E %12E %12E\n",
		name, mat[0], mat[1], mat[2], mat[3]);
					
	bu_log("%12E %12E %12E %12E\n",
		mat[4], mat[5], mat[6], mat[7]);

	bu_log("%12E %12E %12E %12E\n",
		mat[8], mat[9], mat[10], mat[11]);

	bu_log_indent_delta(-delta);

	bu_log("%12E %12E %12E %12E\n",
		mat[12], mat[13], mat[14], mat[15]);
}

HIDDEN void
bu_vls_matprint(struct bu_vls		*vls,
		const char		*name,
		register const double	*mat)
{
	int	delta = strlen(name)+2;

	/* indent the body of the matrix */
	bu_log_indent_delta(delta);

	bu_vls_printf(vls, " %s=%12E %12E %12E %12E\n",
		      name, mat[0], mat[1], mat[2], mat[3]);
	bu_log_indent_vls(vls);

	bu_vls_printf(vls, "%12E %12E %12E %12E\n",
		      mat[4], mat[5], mat[6], mat[7]);
	bu_log_indent_vls(vls);

	bu_vls_printf(vls, "%12E %12E %12E %12E\n",
		      mat[8], mat[9], mat[10], mat[11]);
	bu_log_indent_vls(vls);

	bu_log_indent_delta(-delta);

	bu_vls_printf(vls, "%12E %12E %12E %12E\n",
		      mat[12], mat[13], mat[14], mat[15]);
}

/*
 *	
 *	Convert a structure element (indicated by sdp) to its ASCII
 *	representation in a VLS
 */
void
bu_vls_struct_item(struct bu_vls *vp, const struct bu_structparse *sdp, const char *base, int sep_char)
                  
                                     /* item description */
                                  /* base address of users structure */
                                 /* value separator */
{
    register char *loc;

    if (sdp == (struct bu_structparse *)NULL) {
	bu_log( "Null \"struct bu_structparse\" pointer\n");
	return;
    }

#if CRAY && !__STDC__
    loc = (char *)(base + ((int)sdp->sp_offset*sizeof(int)));
#else
    loc = (char *)(base + ((int)sdp->sp_offset));
#endif

    if (sdp->sp_fmt[0] == 'i' )  {
	bu_log( "Cannot print type 'i' yet!\n" );
	return;
    }

    if ( sdp->sp_fmt[0] != '%')  {
	bu_log("bu_vls_struct_item:  %s: unknown format '%s'\n",
	       sdp->sp_name, sdp->sp_fmt );
	return;
    }

    switch( sdp->sp_fmt[1] )  {
    case 'c':
    case 's':
	if (sdp->sp_count < 1)
	    break;
	if (sdp->sp_count == 1)
	    bu_vls_printf( vp, "%c", *loc );
	else
	    bu_vls_printf( vp, "%s", (char *)loc );
	break;
    case 'S': {
	register struct bu_vls *vls = (struct bu_vls *)loc;

	bu_vls_vlscat( vp, vls ); }
	break;
    case 'i': {
	register int i = sdp->sp_count;
	register short *sp = (short *)loc;

	bu_vls_printf( vp, "%d", *sp++ );
	while( --i > 0 ) bu_vls_printf( vp, "%c%d", sep_char, *sp++ ); }
	break;
    case 'd': {
	register int i = sdp->sp_count;
	register int *dp = (int *)loc;

	bu_vls_printf( vp, "%d", *dp++ );
	while( --i > 0 ) bu_vls_printf( vp, "%c%d", sep_char, *dp++ ); }
	break;
    case 'f': {
	register int i = sdp->sp_count;
	register double *dp = (double *)loc;

	bu_vls_printf( vp, "%.25G", *dp++ );
	while( --i > 0 ) bu_vls_printf( vp, "%c%.25G", sep_char, *dp++ ); }
	break;
    case 'x': {
	register int i = sdp->sp_count;
	register int *dp = (int *)loc;

	bu_vls_printf( vp, "%08x", *dp++ );
	while( --i > 0 ) bu_vls_printf( vp, "%c%08x", sep_char, *dp++ );  }
	break;
    default:
	break;
    }
}



/*
 *	B U _ V L S _ S T R U C T _ I T E M _ N A M E D
 *
 *	Convert a structure element called "name" to an ASCII representation
 *	in a VLS.
 */
int
bu_vls_struct_item_named(struct bu_vls *vp, const struct bu_structparse *parsetab, const char *name, const char *base, int sep_char)
{
    register const struct bu_structparse *sdp;

    for( sdp = parsetab; sdp->sp_name != NULL; sdp++ )
	if( strcmp(sdp->sp_name, name) == 0 ) {
	    bu_vls_struct_item( vp, sdp, base, sep_char );
	    return 0;
	}

    return -1;
}


/*
 *			B U _ S T R U C T P R I N T
 */
void
bu_struct_print(const char *title, const struct bu_structparse *parsetab, const char *base)
          			       
                           	          /* structure description */
          			      	  /* base address of users structure */
{
	register const struct bu_structparse	*sdp;
	register char			*loc;
	register int			lastoff = -1;

	bu_log( "%s\n", title );
	if (parsetab == (struct bu_structparse *)NULL) {
		bu_log( "Null \"struct bu_structparse\" pointer\n");
		return;
	}
	for( sdp = parsetab; sdp->sp_name != (char *)0; sdp++ )  {

		/* Skip alternate keywords for same value */
		if( lastoff == sdp->sp_offset )
			continue;
		lastoff = sdp->sp_offset;

#if CRAY && !__STDC__
		loc = (char *)(base + ((int)sdp->sp_offset*sizeof(int)));
#else
		loc = (char *)(base + ((int)sdp->sp_offset));
#endif

		if (sdp->sp_fmt[0] == 'i' )  {
			bu_struct_print( sdp->sp_name,
				(struct bu_structparse *)sdp->sp_count,
				base );
			continue;
		}

		if ( sdp->sp_fmt[0] != '%')  {
			bu_log("bu_struct_print:  %s: unknown format '%s'\n",
				sdp->sp_name, sdp->sp_fmt );
			continue;
		}
#if 0
		bu_vls_trunc( &vls, 0 );
		bu_vls_struct_item( &vls, sdp, base, ',' );
		bu_log( " %s=%s\n", sdp->sp_name, bu_vls_addr(&vls) );
#else
		switch( sdp->sp_fmt[1] )  {
		case 'c':
		case 's':
			if (sdp->sp_count < 1)
				break;
			if (sdp->sp_count == 1)
				bu_log( " %s='%c'\n", sdp->sp_name, *loc);
			else
				bu_log( " %s=\"%s\"\n", sdp->sp_name,
					(char *)loc );
			break;
		case 'S':
			{
				int delta = strlen(sdp->sp_name)+2;
				register struct bu_vls *vls =
					(struct bu_vls *)loc;

				bu_log_indent_delta(delta);
				bu_log(" %s=(vls_magic)%d (vls_offset)%d (vls_len)%d (vls_max)%d\n",
					sdp->sp_name, vls->vls_magic,
					vls->vls_offset,
					vls->vls_len, vls->vls_max);
				bu_log_indent_delta(-delta);
				bu_log("\"%s\"\n", vls->vls_str+vls->vls_offset);
			}
			break;
		case 'i':
			{	register int i = sdp->sp_count;
				register short *sp = (short *)loc;

				bu_log( " %s=%d", sdp->sp_name, *sp++ );

				while (--i > 0) bu_log( ",%d", *sp++ );

				bu_log("\n");
			}
			break;
		case 'd':
			{	register int i = sdp->sp_count;
				register int *dp = (int *)loc;

				bu_log( " %s=%d", sdp->sp_name, *dp++ );

				while (--i > 0) bu_log( ",%d", *dp++ );

				bu_log("\n");
			}
			break;
		case 'f':
			{	register int i = sdp->sp_count;
				register double *dp = (double *)loc;

				if (sdp->sp_count == 16) {
					bu_matprint(sdp->sp_name, dp);
				} else if (sdp->sp_count <= 3){
					bu_log( " %s=%.25G", sdp->sp_name, *dp++ );

					while (--i > 0)
						bu_log( ",%.25G", *dp++ );

					bu_log("\n");
				}else  {
					int delta = strlen(sdp->sp_name)+2;

					bu_log_indent_delta(delta);

					bu_log( " %s=%.25G\n", sdp->sp_name, *dp++ );

					while (--i > 1)
						bu_log( "%.25G\n", *dp++ );

					bu_log_indent_delta(-delta);
					bu_log( "%.25G\n", *dp );
				}
			}
			break;
		case 'x':
			{	register int i = sdp->sp_count;
				register int *dp = (int *)loc;

				bu_log( " %s=%08x", sdp->sp_name, *dp++ );

				while (--i > 0) bu_log( ",%08x", *dp++ );

				bu_log("\n");
			}
			break;
		default:
			bu_log( " bu_struct_print: Unknown format: %s=%s??\n",
				sdp->sp_name, sdp->sp_fmt );
			break;
		}
#endif
	}
}

/*
 *			B U _ V L S _ P R I N T _ D O U B L E
 */
HIDDEN void
bu_vls_print_double(struct bu_vls *vls, const char *name, register long int count, register const double *dp)
{
	register int tmpi;
	register char *cp;

	bu_vls_extend(vls, strlen(name) + 3 + 32 * count);

	cp = vls->vls_str + vls->vls_offset + vls->vls_len;
	sprintf(cp, "%s%s=%.27G", (vls->vls_len?" ":""), name, *dp++);
	tmpi = strlen(cp);
	vls->vls_len += tmpi;

	while (--count > 0) {
		cp += tmpi;
		sprintf(cp, ",%.27G", *dp++);
		tmpi = strlen(cp);
		vls->vls_len += tmpi;
	}
}

/*
 *			B U _ V L S _ S T R U C T P R I N T
 *
 *	This differs from bu_struct_print in that this output is less readable
 *	by humans, but easier to parse with the computer.
 */
void
bu_vls_struct_print(struct bu_vls *vls, register const struct bu_structparse *sdp, const char *base)
      	      				     	/* vls to print into */
                                    	     	/* structure description */
          				      	/* structure ponter */
{
	register char			*loc;
	register int			lastoff = -1;
	register char			*cp;

	BU_CK_VLS(vls);

	if (sdp == (struct bu_structparse *)NULL) {
		bu_log( "Null \"struct bu_structparse\" pointer\n");
		return;
	}

	for ( ; sdp->sp_name != (char*)NULL ; sdp++) {
		/* Skip alternate keywords for same value */

		if( lastoff == sdp->sp_offset )
			continue;
		lastoff = sdp->sp_offset;

#if CRAY && !__STDC__
		loc = (char *)(base + ((int)sdp->sp_offset*sizeof(int)));
#else
		loc = (char *)(base + ((int)sdp->sp_offset));
#endif

		if (sdp->sp_fmt[0] == 'i')  {
			struct bu_vls sub_str;

			bu_vls_init(&sub_str);
			bu_vls_struct_print( &sub_str,
				(struct bu_structparse *)sdp->sp_count,
				base );

			bu_vls_vlscat(vls, &sub_str);
			bu_vls_free( &sub_str );
			continue;
		}

		if ( sdp->sp_fmt[0] != '%' )  {
			bu_log("bu_struct_print:  %s: unknown format '%s'\n",
				sdp->sp_name, sdp->sp_fmt );
			break;
		}

		switch( sdp->sp_fmt[1] )  {
		case 'c':
		case 's':
			if (sdp->sp_count < 1)
				break;
			if (sdp->sp_count == 1) {
				bu_vls_extend(vls, strlen(sdp->sp_name)+6);
				cp = vls->vls_str + vls->vls_offset + vls->vls_len;
				if (*loc == '"')
					sprintf(cp, "%s%s=\"%s\"",
						(vls->vls_len?" ":""),
						sdp->sp_name, "\\\"");
				else
					sprintf(cp, "%s%s=\"%c\"",
						(vls->vls_len?" ":""),
						sdp->sp_name, 
						*loc);
			} else {
				register char *p; 
				register int count=0;

				/* count the quote characters */
				p = loc;
				while ((p=strchr(p, '"')) != (char *)NULL) {
					++p;
					++count;
				}
				bu_vls_extend(vls, strlen(sdp->sp_name)+
					strlen(loc)+5+count);

				cp = vls->vls_str + vls->vls_offset + vls->vls_len;
				if (vls->vls_len) (void)strcat(cp, " ");
				(void)strcat(cp, sdp->sp_name);
				(void)strcat(cp, "=\"");

				/* copy the string, escaping all the internal
				 * double quote (") characters
				 */
				p = &cp[strlen(cp)];
				while (*loc) {
					if (*loc == '"') {
						*p++ = '\\';
					}
					*p++ = *loc++;
				}
				*p++ = '"';
				*p = '\0';
			}
			vls->vls_len += strlen(cp);
			break;
		case 'S':
			{	register struct bu_vls *vls_p =
					(struct bu_vls *)loc;

				bu_vls_extend(vls, bu_vls_strlen(vls_p) + 5 +
					strlen(sdp->sp_name) );

				cp = vls->vls_str + vls->vls_offset + vls->vls_len;
				sprintf(cp, "%s%s=\"%s\"",
					(vls->vls_len?" ":""),
					sdp->sp_name,
					bu_vls_addr(vls_p) );
				vls->vls_len += strlen(cp);
			}
			break;
		case 'i':
			{	register int i = sdp->sp_count;
				register short *sp = (short *)loc;
				register int tmpi;

				bu_vls_extend(vls, 
					64 * i + strlen(sdp->sp_name) + 3 );

				cp = vls->vls_str + vls->vls_offset + vls->vls_len;
				sprintf(cp, "%s%s=%d",
						(vls->vls_len?" ":""),
						 sdp->sp_name, *sp++);
				tmpi = strlen(cp);
				vls->vls_len += tmpi;

				while (--i > 0) {
					cp += tmpi;
					sprintf(cp, ",%d", *sp++);
					tmpi = strlen(cp);
					vls->vls_len += tmpi;
				}
			}
			break;
		case 'd':
			{	register int i = sdp->sp_count;
				register int *dp = (int *)loc;
				register int tmpi;

				bu_vls_extend(vls, 
					64 * i + strlen(sdp->sp_name) + 3 );

				cp = vls->vls_str + vls->vls_offset + vls->vls_len;
				sprintf(cp, "%s%s=%d", 
					(vls->vls_len?" ":""),
					sdp->sp_name, *dp++);
				tmpi = strlen(cp);
				vls->vls_len += tmpi;

				while (--i > 0) {
					cp += tmpi;
					sprintf(cp, ",%d", *dp++);
					tmpi = strlen(cp);
					vls->vls_len += tmpi;
				}
			}
			break;
		case 'f':
			bu_vls_print_double(vls, sdp->sp_name, sdp->sp_count,
				(double *)loc);
			break;
		default:
			bu_log( " %s=%s??\n", sdp->sp_name, sdp->sp_fmt );
			abort();
			break;
		}
	}
}


/*
 *			B U _ V L S _ S T R U C T P R I N T 2
 *
 *	This differs from bu_struct_print in that it prints to a vls.
 */
void
bu_vls_struct_print2(struct bu_vls			*vls_out,     
		     const char				*title,
		     const struct bu_structparse	*parsetab,	/* structure description */
		     const char				*base)	  	/* base address of users structure */
{
	register const struct bu_structparse	*sdp;
	register char			*loc;
	register int			lastoff = -1;

	bu_vls_printf(vls_out, "%s\n", title);
	if (parsetab == (struct bu_structparse *)NULL) {
		bu_vls_printf(vls_out, "Null \"struct bu_structparse\" pointer\n");
		return;
	}

	for (sdp = parsetab; sdp->sp_name != (char *)0; sdp++) {

		/* Skip alternate keywords for same value */
		if (lastoff == sdp->sp_offset)
			continue;
		lastoff = sdp->sp_offset;

#if CRAY && !__STDC__
		loc = (char *)(base + ((int)sdp->sp_offset*sizeof(int)));
#else
		loc = (char *)(base + ((int)sdp->sp_offset));
#endif

		if (sdp->sp_fmt[0] == 'i' )  {
			bu_vls_struct_print2(vls_out, sdp->sp_name,
					     (struct bu_structparse *)sdp->sp_count,
					     base);
			continue;
		}

		if (sdp->sp_fmt[0] != '%') {
			bu_vls_printf(vls_out, "bu_vls_struct_print:  %s: unknown format '%s'\n",
			       sdp->sp_name, sdp->sp_fmt );
			continue;
		}

		switch( sdp->sp_fmt[1] )  {
		case 'c':
		case 's':
			if (sdp->sp_count < 1)
				break;
			if (sdp->sp_count == 1)
				bu_vls_printf(vls_out, " %s='%c'\n", sdp->sp_name, *loc);
			else
				bu_vls_printf(vls_out, " %s=\"%s\"\n", sdp->sp_name,
					(char *)loc );
			break;
		case 'S':
			{
				int delta = strlen(sdp->sp_name)+2;
				register struct bu_vls *vls =
					(struct bu_vls *)loc;

				bu_log_indent_delta(delta);
				bu_vls_printf(vls_out, " %s=(vls_magic)%d (vls_offset)%d (vls_len)%d (vls_max)%d\n",
					sdp->sp_name, vls->vls_magic,
					vls->vls_offset,
					vls->vls_len, vls->vls_max);
				bu_log_indent_vls(vls_out);
				bu_log_indent_delta(-delta);
				bu_vls_printf(vls_out, "\"%s\"\n", vls->vls_str+vls->vls_offset);
			}
			break;
		case 'i':
			{	register int i = sdp->sp_count;
				register short *sp = (short *)loc;

				bu_vls_printf(vls_out, " %s=%d", sdp->sp_name, *sp++ );

				while (--i > 0)
					bu_vls_printf(vls_out, ",%d", *sp++ );

				bu_vls_printf(vls_out, "\n");
			}
			break;
		case 'd':
			{	register int i = sdp->sp_count;
				register int *dp = (int *)loc;

				bu_vls_printf(vls_out, " %s=%d", sdp->sp_name, *dp++ );

				while (--i > 0)
					bu_vls_printf(vls_out, ",%d", *dp++ );

				bu_vls_printf(vls_out, "\n");
			}
			break;
		case 'f':
			{	register int i = sdp->sp_count;
				register double *dp = (double *)loc;

				if (sdp->sp_count == 16) {
					bu_vls_matprint(vls_out, sdp->sp_name, dp);
				} else if (sdp->sp_count <= 3){
					bu_vls_printf(vls_out, " %s=%.25G", sdp->sp_name, *dp++ );

					while (--i > 0)
						bu_vls_printf(vls_out, ",%.25G", *dp++ );

					bu_vls_printf(vls_out, "\n");
				}else  {
					int delta = strlen(sdp->sp_name)+2;

					bu_log_indent_delta(delta);
					bu_vls_printf(vls_out, " %s=%.25G\n", sdp->sp_name, *dp++ );
					bu_log_indent_vls(vls_out);

					while (--i > 1) {
						bu_vls_printf(vls_out, "%.25G\n", *dp++ );
						bu_log_indent_vls(vls_out);
					}

					bu_log_indent_delta(-delta);
					bu_vls_printf(vls_out, "%.25G\n", *dp );
				}
			}
			break;
		case 'x':
			{	register int i = sdp->sp_count;
				register int *dp = (int *)loc;

				bu_vls_printf(vls_out, " %s=%08x", sdp->sp_name, *dp++ );

				while (--i > 0)
					bu_vls_printf(vls_out, ",%08x", *dp++ );

				bu_vls_printf(vls_out, "\n");
			}
			break;
		default:
			bu_vls_printf(vls_out, " bu_vls_struct_print2: Unknown format: %s=%s??\n",
				sdp->sp_name, sdp->sp_fmt );
			break;
		}
	}
}


/* This allows us to specify the "size" parameter as values like ".5m"
 * or "27in" rather than using mm all the time.
 */
void
bu_parse_mm(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
{
	double *p = (double *)(base+sdp->sp_offset);

	/* reconvert with optional units */
	*p = bu_mm_value(value);
}

#define STATE_UNKNOWN		0
#define STATE_IN_KEYWORD	1
#define STATE_IN_VALUE		2
#define STATE_IN_QUOTED_VALUE	3

int
bu_key_eq_to_key_val(char *in, char **next, struct bu_vls *vls)
{
	char *iptr=in;
	char *start;
	int state=STATE_IN_KEYWORD;

	BU_CK_VLS( vls );

	*next = NULL;

	while ( *iptr )
	{
		char *prev='\0';

		switch( state )
		{
			case STATE_IN_KEYWORD:
				/* skip leading white space */
				while( isspace( *iptr ) )
					iptr++;

				if( !(*iptr) )
					break;

				if( *iptr == ';' )
				{
					/* found end of a stack element */
					*next = iptr+1;
					return( 0 );
				}

				/* copy keyword up to '=' */
				start = iptr;
				while( *iptr && *iptr != '=' )
					iptr++;

				bu_vls_strncat( vls, start, iptr - start );

				/* add a single space after keyword */
				bu_vls_putc( vls, ' ' );

				if( !*iptr )
					break;

				/* skip over '=' in input */
				iptr++;

				/* switch to value state */
				state = STATE_IN_VALUE;

				break;
			case STATE_IN_VALUE:
				/* skip excess white space */
				while( isspace( *iptr ) )
					iptr++;

				/* check for quoted value */
				if( *iptr == '"' )
				{
					/* switch to quoted value state */
					state = STATE_IN_QUOTED_VALUE;

					/* skip over '"' */
					iptr++;

					break;
				}

				/* copy value up to next white space or end of string */
				start = iptr;
				while( *iptr && *iptr != ';' && !isspace( *iptr ) )
					iptr++;

				bu_vls_strncat( vls, start, iptr - start );

				if( *iptr ) /* more to come */
				{
					bu_vls_putc( vls, ' ' );

					/* switch back to keyword state */
					state = STATE_IN_KEYWORD;
				}

				break;
			case STATE_IN_QUOTED_VALUE:
				/* copy byte-for-byte to end quote (watch out for escaped quote)
				 * replace quotes with '{' '}' */

				bu_vls_strcat( vls, " {" );
				while( 1 )
				{
					if( *iptr == '"' && *prev != '\\' )
					{
						bu_vls_putc( vls, '}' );
						iptr++;
						break;
					}
					bu_vls_putc( vls, *iptr );
					prev = iptr++;
				}

				if( *iptr && *iptr != ';' ) /* more to come */
					bu_vls_putc( vls, ' ' );

				/* switch back to keyword state */
				state = STATE_IN_KEYWORD;

				break;
		}
	}
	return( 0 );
}

/*
 *			B U _ S H A D E R _ T O _ T C L _ L I S T
 *
 *  Take an old v4 shader specification of the form
 *
 *	shadername arg1=value1 arg2=value2 color=1/2/3
 *
 *  and convert it into the v5 Tcl-list form
 *
 *	shadername {arg1 value1 arg2 value2 color 1/2/3}
 *
 *  Note -- the input string is smashed with nulls.
 *
 *  Note -- the v5 version is used everywhere internally, and in v5
 *  databases.
 *
 *  Returns -
 *	1	error
 *	0	OK
 */
int
bu_shader_to_tcl_list(char *in, struct bu_vls *vls)
{
	char *iptr;
	char *next=in;
	char *shader;
	int shader_name_len=0;
	int is_stack=0;
	int len;


	BU_CK_VLS( vls );

	while( next )
	{
		iptr = next;

		/* skip over white space */
		while( isspace( *iptr ) )
			iptr++;

		/* this is start of shader name */
		shader = iptr;

		/* find end of shader name */
		while( *iptr && !isspace( *iptr ) && *iptr != ';' )
			iptr++;
		shader_name_len = iptr - shader;

		if( !strncmp( shader, "stack", 5 ) )
		{
			/* stack shader, loop through all shaders in stack */
			int done=0;

			bu_vls_strcat( vls, "stack {" );

			while( !done )
			{
				char *shade1;

				while( isspace( *iptr ) )
					iptr++;
				if( *iptr == '\0' )
					break;
				shade1 = iptr;
				while( *iptr && *iptr != ';' )
					iptr++;
				if( *iptr == '\0' )
					done = 1;
				*iptr = '\0';

				bu_vls_putc( vls, '{' );

				if( bu_shader_to_tcl_list( shade1, vls ) )
					return( 1 );

				bu_vls_strcat( vls, "} " );

				if( !done )
					iptr++;
			}
			bu_vls_putc( vls, '}' );
			return( 0 );
		}
		else if( !strncmp( shader, "envmap", 6 ) )
		{
			bu_vls_strcat( vls, "envmap {" );
			if( bu_shader_to_tcl_list( iptr, vls ) )
				return( 1 );
			bu_vls_putc( vls, '}' );
			return( 0 );
		}

		if( is_stack )
			bu_vls_strcat( vls, " {" );

		bu_vls_strncat( vls, shader, shader_name_len );

		/* skip more white space */
		while( *iptr && isspace( *iptr ) )
			iptr++;

		/* iptr now points at start of parameters, if any */
		if( *iptr && *iptr != ';' )
		{
			bu_vls_strcat( vls, " {" );
			len = bu_vls_strlen( vls );
			if( bu_key_eq_to_key_val( iptr, &next, vls ) )
				return( 1 );
			if( bu_vls_strlen( vls ) > len )
				bu_vls_putc( vls, '}' );
			else
				bu_vls_trunc( vls, len-2 );
		}
		else if( *iptr && *iptr == ';' )
			next = ++iptr;
		else
			next = (char *)NULL;

		if( is_stack )
			bu_vls_putc( vls, '}' );
	}

	if( is_stack )
		bu_vls_putc( vls, '}' );

	return( 0 );
}

/*
 *			B U _ L I S T _ E L E M
 *
 *  Given a Tcl list, return a copy of the 'index'th entry,
 *  which may itself be a list.
 *
 *
 *  Note -- the caller is responsible for freeing the returned string.
 */
char *
bu_list_elem( const char *in, int index )
{
	int depth=0;
	int count=0;
	int len=0;
	const char *ptr=in;
	const char *prev=NULL;
	const char *start=NULL;
	const char *end=NULL;
	char *out=NULL;

	while( *ptr )
	{
		/* skip leading white space */
		while( *ptr && isspace( *ptr ) )
		{
			prev = ptr;
			ptr++;
		}

		if( !*ptr )
			break;

		if( depth == 0 && count == index )
			start = ptr;

		if( *ptr == '{' )
		{
			depth++;
			prev = ptr;
			ptr++;
		}
		else if( *ptr == '}' )
		{
			depth--;
			if( depth == 0 )
				count++;
			if( start && depth == 0 )
			{
				end = ptr;
				break;
			}
			prev = ptr;
			ptr++;
		}
		else
		{
			while( *ptr &&
				(!isspace( *ptr ) || *prev == '\\') &&
				(*ptr != '}' || *prev == '\\') &&
				(*ptr != '{' || *prev == '\\') )
			{
				prev = ptr;
				ptr++;
			}
			if( depth == 0 )
				count++;

			if( start && depth == 0 )
			{
				end = ptr-1;
				break;
			}
		}
	}

	if( !start )
		return( (char *)NULL );

	if( *start == '{' )
	{
		if( !end || *end != '}' )
		{
			bu_log( "Error in list (uneven braces?): %s\n", in );
			return( (char *)NULL );
		}

		/* remove enclosing braces */
		start++;
		while( start < end && isspace( *start ) )
			start++;

		end--;
		while( end > start && isspace( *end ) && *(end-1) != '\\' )
			end--;

		if( start == end )
			return( (char *)NULL );
	}

	len = end - start + 1;
	out = bu_malloc( len+1, "bu_list_elem:out" );
	strncpy( out, start, len );
	*(out + len) = '\0';

	return( out );
}

/*
 *			B U _ T C L _ L I S T _ L E N G T H
 *
 *  Return number of items in a string, interpreted as a Tcl list.
 */
int
bu_tcl_list_length( const char *in )
{
	int count=0;
	int depth=0;
	const char *ptr=in;
	const char *prev=NULL;

	while( *ptr )
	{
		/* skip leading white space */
		while( *ptr && isspace( *ptr ) )
		{
			prev = ptr;
			ptr++;
		}

		if( !*ptr )
			break;

		if( *ptr == '{' )
		{
			if( depth == 0 )
				count++;
			depth++;
			prev = ptr;
			ptr++;
		}
		else if( *ptr == '}' )
		{
			depth--;
			prev = ptr;
			ptr++;
		}
		else
		{
			if( depth == 0 )
				count++;

			while( *ptr &&
				(!isspace( *ptr ) || *prev == '\\') &&
				(*ptr != '}' || *prev == '\\') &&
				(*ptr != '{' || *prev == '\\') )
			{
				prev = ptr;
				ptr++;
			}
		}
	}

	return( count );
}

int
bu_key_val_to_vls(struct bu_vls *vls, char *params)
{
	int len;
	int j;

	len = bu_tcl_list_length( params );

	if( len == 1 )
	{
		bu_vls_putc( vls, ' ' );
		bu_vls_strcat( vls, params );
		return( 0 );
	}

	if( len%2 )
	{
		bu_log( "bu_key_val_to_vls: Error: shader parameters must be even numbered!!\n\t%s\n", params );
		return( 1 );
	}

	for( j=0 ; j<len ; j += 2 )
	{
		char *keyword;
		char *value;

		keyword = bu_list_elem( params, j );
		value = bu_list_elem( params, j+1 );

		bu_vls_putc( vls, ' ' );
		bu_vls_strcat( vls, keyword );
		bu_vls_putc( vls, '=' );
		if( bu_tcl_list_length( value ) > 1  )
		{
			bu_vls_putc( vls, '"' );
			bu_vls_strcat( vls, value );
			bu_vls_putc( vls, '"' );
		}
		else
			bu_vls_strcat( vls, value );

		bu_free( keyword, "bu_key_val_to_vls() keyword");
		bu_free( value, "bu_key_val_to_vls() value");

	}
	return( 0 );
}

/*
 *			B U _ S H A D E R _ T O _ K E Y _ E Q
 */
int
bu_shader_to_key_eq(char *in, struct bu_vls *vls)
{
	int len;
	int ret=0;
	char *shader;
	char *params;

	BU_CK_VLS( vls );

	len = bu_tcl_list_length( in );

	if( len == 0 )
		return( 0 );

	if( len == 1 )
	{
		/* shader with no parameters */
		if( bu_vls_strlen( vls ) )
			bu_vls_putc( vls, ' ' );
		bu_vls_strcat( vls, in );
		return( 0 );
	}

	if( len != 2 )
	{
		bu_log( "bu_shader_to_key_eq: Error: shader must have two elements (not %d)!!\n\t%s\n", len, in );
		return 1;
	}

	shader = bu_list_elem( in, 0 );
	params = bu_list_elem( in, 1 );

	if( !strcmp( shader, "envmap" ) )
	{
		/* environment map */

		if( bu_vls_strlen( vls ) )
			bu_vls_putc( vls, ' ' );
		bu_vls_strcat( vls, "envmap" );

		bu_shader_to_key_eq( params, vls );
	}
	else if( !strcmp( shader, "stack" ) )
	{
		/* stacked shaders */

		int i;

		if( bu_vls_strlen( vls ) )
			bu_vls_putc( vls, ' ' );
		bu_vls_strcat( vls, "stack" );

		/* get number of shaders in the stack */
		len = bu_tcl_list_length( params );

		/* process each shader in the stack */
		for( i=0 ; i<len ; i++ )
		{
			char *shader1;

			/* each parameter must be a shader specification in itself */
			shader1 = bu_list_elem( params, i );

			if( i > 0 ) 
				bu_vls_putc( vls, ';' );
			bu_shader_to_key_eq( shader1, vls );
			bu_free( shader1, "shader1" );
		}
	}
	else
	{
		if( bu_vls_strlen( vls ) )
			bu_vls_putc( vls, ' ' );
		bu_vls_strcat( vls, shader );
		ret = bu_key_val_to_vls( vls, params );
	}

	bu_free( shader, "shader" );
	bu_free( params, "params" );

	return( ret );
}

/*
 *
 *			B U _ F W R I T E _ E X T E R N A L
 *
 *  Take a block of memory, and write it into a file.
 *
 *  Caller is responsible for freeing memory of external representation,
 *  using bu_free_external().
 *
 *  Returns -
 *	<0	error
 *	0	OK
 */
int
bu_fwrite_external( FILE *fp, const struct bu_external *ep )
{
	size_t	got;

	BU_CK_EXTERNAL(ep);

	if( (got = fwrite( ep->ext_buf, 1, ep->ext_nbytes, fp )) != ep->ext_nbytes )  {
		perror("fwrite");
		bu_log("bu_fwrite_external() attempted to write %ld, got %ld\n", (long)ep->ext_nbytes, (long)got );
		return -1;
	}
	return 0;
}

/*
 *			B U _ H E X D U M P _ E X T E R N A L
 */
void
bu_hexdump_external( FILE *fp, const struct bu_external *ep, const char *str)
{
	const unsigned char	*cp;
	const unsigned char	*endp;
	int i, j, k;

	BU_CK_EXTERNAL(ep);

	fprintf(fp, "%s:\n", str);
	if( ep->ext_nbytes <= 0 )  fprintf(fp, "\tWarning: 0 length external buffer\n");

	cp = ep->ext_buf;
	endp = cp + ep->ext_nbytes;
	for( i=0; i < ep->ext_nbytes; i += 16 )  {
		const unsigned char	*sp = cp;

		for( j=0; j < 4; j++ )  {
			for( k=0; k < 4; k++ )  {
				if( cp >= endp )
					fprintf(fp, "   ");
				else
					fprintf(fp, "%2.2x ", *cp++ );
			}
			fprintf(fp, " ");
		}
		fprintf(fp, " |");

		for( j=0; j < 16; j++,sp++ )  {
			if( sp >= endp )  break;
			if( isprint(*sp) )
				putc(*sp, fp);
			else
				putc('.', fp);
		}

		fprintf(fp, "|\n");
	}
}

/*
 *			B U _ F R E E _ E X T E R N A L
 */
void
bu_free_external( register struct bu_external *ep)
{
	BU_CK_EXTERNAL(ep);
	if( ep->ext_buf )  {
		bu_free( ep->ext_buf, "bu_external ext_buf" );
		ep->ext_buf = GENPTR_NULL;
	}
}

/*
 *			B U _ C O P Y _ E X T E R N A L
 */
void
bu_copy_external(struct bu_external *op, const struct bu_external *ip)
{
	BU_CK_EXTERNAL(ip);
	BU_INIT_EXTERNAL(op);

	if( op == ip )  return;

	op->ext_nbytes = ip->ext_nbytes;
	op->ext_buf = bu_malloc( ip->ext_nbytes, "bu_copy_external" );
	bcopy( ip->ext_buf, op->ext_buf, ip->ext_nbytes );
}

/*
 *			B U _ N E X T _ T O K E N
 *
 *  Advance pointer through string over current token,
 *  across white space, to beginning of next token.
 */
char *
bu_next_token( char *str )
{
  char *ret;

  ret = str;
  while( !isspace( *ret ) && *ret !='\0' )
    ret++;
  while( isspace( *ret ) )
    ret++;

  return( ret );
}
@


1.51
log
@change conf.h to a wrapped config.h
@
text
@d32 1
a32 1
static const char RCSparse[] = "@@(#)$Header: /cvs/brlcad/libbu/parse.c,v 1.50 2004/04/05 07:46:16 morrison Exp $ (BRL)";
@


1.50
log
@merge of ansi-6-0-branch into HEAD
@
text
@d32 1
a32 1
static const char RCSparse[] = "@@(#)$Header$ (BRL)";
d35 5
a39 1
#include "conf.h"
@


1.49
log
@merge of windows-6-0-branch into head
@
text
@d124 1
a124 4
bu_struct_export( ext, base, imp )
struct bu_external	*ext;
const genptr_t		base;
const struct bu_structparse *imp;
d276 1
a276 4
bu_struct_import( base, imp, ext )
genptr_t		base;
const struct bu_structparse	*imp;
const struct bu_external	*ext;
d412 1
a412 3
bu_struct_put( fp, ext )
FILE *fp;
const struct bu_external	*ext;
d425 1
a425 3
bu_struct_get( ext, fp )
struct bu_external *ext;
FILE *fp;
d486 1
a486 3
bu_struct_wrap_buf( ext, buf )
struct bu_external *ext;
genptr_t buf;
d532 1
a532 4
bu_parse_double(str, count, loc)
const char	*str;
long		count;
double		*loc;
d598 5
a602 5
bu_struct_lookup( sdp, name, base, value )
register const struct bu_structparse	*sdp;	/* structure description */
register const char			*name;	/* struct member name */
char					*base;	/* begining of structure */
const char			* const	value;	/* string containing value */
d772 4
a775 4
bu_struct_parse( in_vls, desc, base )
const struct bu_vls		*in_vls;	/* string to parse through */
const struct bu_structparse	*desc;		/* structure description */
char				*base;		/* base addr of users struct */
d869 1
a869 3
bu_matprint(name, mat)
const char		*name;
register const double	*mat;
d925 5
a929 5
bu_vls_struct_item( vp, sdp, base, sep_char )
struct bu_vls *vp;
const struct bu_structparse *sdp;    /* item description */
const char *base;                 /* base address of users structure */
int sep_char;                    /* value separator */
d1012 1
a1012 6
bu_vls_struct_item_named( vp, parsetab, name, base, sep_char )
struct bu_vls *vp;
const struct bu_structparse *parsetab;
const char *name;
const char *base;
int sep_char;
d1030 4
a1033 4
bu_struct_print( title, parsetab, base )
const char			*title;
const struct bu_structparse	*parsetab;/* structure description */
const char			*base;	  /* base address of users structure */
d1174 1
a1174 5
bu_vls_print_double(vls, name, count, dp)
struct bu_vls		*vls;
const char		*name;
register long		count;
register const double	*dp;
d1201 4
a1204 4
bu_vls_struct_print( vls, sdp, base)
struct	bu_vls				*vls;	/* vls to print into */
register const struct bu_structparse	*sdp;	/* structure description */
const char				*base;	/* structure ponter */
d1526 5
a1530 5
bu_parse_mm( sdp, name, base, value )
register const struct bu_structparse	*sdp;	/* structure description */
register const char			*name;	/* struct member name */
char					*base;	/* begining of structure */
const char				*value;	/* string containing value */
d1544 1
a1544 4
bu_key_eq_to_key_val( in, next, vls )
char *in;
char **next;
struct bu_vls *vls;
d1678 1
a1678 3
bu_shader_to_tcl_list( in, vls )
char *in;
struct bu_vls *vls;
d1953 1
a1953 3
bu_key_val_to_vls( vls, params )
struct bu_vls *vls;
char *params;
d2004 1
a2004 3
bu_shader_to_key_eq( in, vls )
char *in;
struct bu_vls *vls;
@


1.48
log
@update copyright to include span through 2003
@
text
@d32 1
a32 1
static const char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.47 2002/08/20 17:07:41 jra Exp $ (BRL)";
d2028 1
@


1.47
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d28 1
a28 1
 *	This software is Copyright (C) 1989 by the United States Army.
d32 1
a32 1
static const char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.45 2001/11/02 05:01:16 butler Exp $ (BRL)";
@


1.47.10.1
log
@merge from HEAD
@
text
@d28 1
a28 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d32 1
a32 1
static const char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.48 2004/02/02 17:39:07 morrison Exp $ (BRL)";
@


1.47.10.2
log
@merge from head
@
text
@d32 1
a32 1
static const char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.47.10.1 2004/02/12 18:39:18 erikg Exp $ (BRL)";
@


1.47.10.3
log
@merge from head
@
text
@d32 1
a32 1
static const char RCSparse[] = "@@(#)$Header$ (BRL)";
a2027 1

@


1.47.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d32 1
a32 1
static const char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.47 2002/08/20 17:07:41 jra Exp $ (BRL)";
a2027 1

@


1.47.4.2
log
@sync to HEAD...
@
text
@d28 1
a28 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d32 1
a32 1
static const char RCSparse[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libbu/parse.c,v 1.47.4.1 2002/09/26 23:03:52 morrison Exp $ (BRL)";
@


1.47.2.1
log
@Initial ANSIfication
@
text
@d32 1
a32 1
static const char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.47 2002/08/20 17:07:41 jra Exp $ (BRL)";
d124 4
a127 1
bu_struct_export(struct bu_external *ext, const genptr_t base, const struct bu_structparse *imp)
d279 4
a282 1
bu_struct_import(genptr_t base, const struct bu_structparse *imp, const struct bu_external *ext)
d418 3
a420 1
bu_struct_put(FILE *fp, const struct bu_external *ext)
d433 3
a435 1
bu_struct_get(struct bu_external *ext, FILE *fp)
d496 3
a498 1
bu_struct_wrap_buf(struct bu_external *ext, genptr_t buf)
d544 4
a547 1
bu_parse_double(const char *str, long int count, double *loc)
d613 5
a617 5
bu_struct_lookup(register const struct bu_structparse *sdp, register const char *name, char *base, const char *const value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          			       	      	/* string containing value */
d787 4
a790 4
bu_struct_parse(const struct bu_vls *in_vls, const struct bu_structparse *desc, char *base)
                   		        	/* string to parse through */
                           	      		/* structure description */
    				      		/* base addr of users struct */
d884 3
a886 1
bu_matprint(const char *name, register const double *mat)
d942 5
a946 5
bu_vls_struct_item(struct bu_vls *vp, const struct bu_structparse *sdp, const char *base, int sep_char)
                  
                                     /* item description */
                                  /* base address of users structure */
                                 /* value separator */
d1029 6
a1034 1
bu_vls_struct_item_named(struct bu_vls *vp, const struct bu_structparse *parsetab, const char *name, const char *base, int sep_char)
d1052 4
a1055 4
bu_struct_print(const char *title, const struct bu_structparse *parsetab, const char *base)
          			       
                           	          /* structure description */
          			      	  /* base address of users structure */
d1196 5
a1200 1
bu_vls_print_double(struct bu_vls *vls, const char *name, register long int count, register const double *dp)
d1227 4
a1230 4
bu_vls_struct_print(struct bu_vls *vls, register const struct bu_structparse *sdp, const char *base)
      	      				     	/* vls to print into */
                                    	     	/* structure description */
          				      	/* structure ponter */
d1552 5
a1556 5
bu_parse_mm(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
d1570 4
a1573 1
bu_key_eq_to_key_val(char *in, char **next, struct bu_vls *vls)
d1707 3
a1709 1
bu_shader_to_tcl_list(char *in, struct bu_vls *vls)
d1984 3
a1986 1
bu_key_val_to_vls(struct bu_vls *vls, char *params)
d2036 3
a2038 1
bu_shader_to_key_eq(char *in, struct bu_vls *vls)
@


1.47.2.2
log
@sync branch with HEAD
@
text
@d28 1
a28 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d32 1
a32 1
static const char RCSparse[] = "@@(#)$Header$ (BRL)";
a1994 1

@


1.47.2.3
log
@make struct parse base const
@
text
@d598 1
a598 1
bu_struct_lookup(register const struct bu_structparse *sdp, register const char *name, const char *base, const char *const value)
d772 1
a772 1
bu_struct_parse(const struct bu_vls *in_vls, const struct bu_structparse *desc, const char *base)
@


1.46
log
@Converted from K&R to ANSI C - RFH
@
text
@d124 4
a127 1
bu_struct_export(struct bu_external *ext, const genptr_t base, const struct bu_structparse *imp)
d279 4
a282 1
bu_struct_import(genptr_t base, const struct bu_structparse *imp, const struct bu_external *ext)
d418 3
a420 1
bu_struct_put(FILE *fp, const struct bu_external *ext)
d433 3
a435 1
bu_struct_get(struct bu_external *ext, FILE *fp)
d496 3
a498 1
bu_struct_wrap_buf(struct bu_external *ext, genptr_t buf)
d544 4
a547 1
bu_parse_double(const char *str, long int count, double *loc)
d613 5
a617 5
bu_struct_lookup(register const struct bu_structparse *sdp, register const char *name, char *base, const char *const value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          			       	      	/* string containing value */
d787 4
a790 4
bu_struct_parse(const struct bu_vls *in_vls, const struct bu_structparse *desc, char *base)
                   		        	/* string to parse through */
                           	      		/* structure description */
    				      		/* base addr of users struct */
d884 3
a886 1
bu_matprint(const char *name, register const double *mat)
d942 5
a946 5
bu_vls_struct_item(struct bu_vls *vp, const struct bu_structparse *sdp, const char *base, int sep_char)
                  
                                     /* item description */
                                  /* base address of users structure */
                                 /* value separator */
d1029 6
a1034 1
bu_vls_struct_item_named(struct bu_vls *vp, const struct bu_structparse *parsetab, const char *name, const char *base, int sep_char)
d1052 4
a1055 4
bu_struct_print(const char *title, const struct bu_structparse *parsetab, const char *base)
          			       
                           	          /* structure description */
          			      	  /* base address of users structure */
d1196 5
a1200 1
bu_vls_print_double(struct bu_vls *vls, const char *name, register long int count, register const double *dp)
d1227 4
a1230 4
bu_vls_struct_print(struct bu_vls *vls, register const struct bu_structparse *sdp, const char *base)
      	      				     	/* vls to print into */
                                    	     	/* structure description */
          				      	/* structure ponter */
d1552 5
a1556 5
bu_parse_mm(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
d1570 4
a1573 1
bu_key_eq_to_key_val(char *in, char **next, struct bu_vls *vls)
d1707 3
a1709 1
bu_shader_to_tcl_list(char *in, struct bu_vls *vls)
d1984 3
a1986 1
bu_key_val_to_vls(struct bu_vls *vls, char *params)
d2036 3
a2038 1
bu_shader_to_key_eq(char *in, struct bu_vls *vls)
@


1.45
log
@fixed processing of short ints, added XXX comment to some really dangerous
stuff.  Incrementing with sizeof(int) on "short int" datatypes is bogus.
@
text
@d32 1
a32 1
static const char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.44 2001/07/17 23:20:35 morrison Exp $ (BRL)";
d124 1
a124 4
bu_struct_export( ext, base, imp )
struct bu_external	*ext;
const genptr_t		base;
const struct bu_structparse *imp;
d276 1
a276 4
bu_struct_import( base, imp, ext )
genptr_t		base;
const struct bu_structparse	*imp;
const struct bu_external	*ext;
d412 1
a412 3
bu_struct_put( fp, ext )
FILE *fp;
const struct bu_external	*ext;
d425 1
a425 3
bu_struct_get( ext, fp )
struct bu_external *ext;
FILE *fp;
d486 1
a486 3
bu_struct_wrap_buf( ext, buf )
struct bu_external *ext;
genptr_t buf;
d532 1
a532 4
bu_parse_double(str, count, loc)
const char	*str;
long		count;
double		*loc;
d598 5
a602 5
bu_struct_lookup( sdp, name, base, value )
register const struct bu_structparse	*sdp;	/* structure description */
register const char			*name;	/* struct member name */
char					*base;	/* begining of structure */
const char			* const	value;	/* string containing value */
d772 4
a775 4
bu_struct_parse( in_vls, desc, base )
const struct bu_vls		*in_vls;	/* string to parse through */
const struct bu_structparse	*desc;		/* structure description */
char				*base;		/* base addr of users struct */
d869 1
a869 3
bu_matprint(name, mat)
const char		*name;
register const double	*mat;
d925 5
a929 5
bu_vls_struct_item( vp, sdp, base, sep_char )
struct bu_vls *vp;
const struct bu_structparse *sdp;    /* item description */
const char *base;                 /* base address of users structure */
int sep_char;                    /* value separator */
d1012 1
a1012 6
bu_vls_struct_item_named( vp, parsetab, name, base, sep_char )
struct bu_vls *vp;
const struct bu_structparse *parsetab;
const char *name;
const char *base;
int sep_char;
d1030 4
a1033 4
bu_struct_print( title, parsetab, base )
const char			*title;
const struct bu_structparse	*parsetab;/* structure description */
const char			*base;	  /* base address of users structure */
d1174 1
a1174 5
bu_vls_print_double(vls, name, count, dp)
struct bu_vls		*vls;
const char		*name;
register long		count;
register const double	*dp;
d1201 4
a1204 4
bu_vls_struct_print( vls, sdp, base)
struct	bu_vls				*vls;	/* vls to print into */
register const struct bu_structparse	*sdp;	/* structure description */
const char				*base;	/* structure ponter */
d1526 5
a1530 5
bu_parse_mm( sdp, name, base, value )
register const struct bu_structparse	*sdp;	/* structure description */
register const char			*name;	/* struct member name */
char					*base;	/* begining of structure */
const char				*value;	/* string containing value */
d1544 1
a1544 4
bu_key_eq_to_key_val( in, next, vls )
char *in;
char **next;
struct bu_vls *vls;
d1678 1
a1678 3
bu_shader_to_tcl_list( in, vls )
char *in;
struct bu_vls *vls;
d1953 1
a1953 3
bu_key_val_to_vls( vls, params )
struct bu_vls *vls;
char *params;
d2003 1
a2003 3
bu_shader_to_key_eq( in, vls )
char *in;
struct bu_vls *vls;
@


1.44
log
@removed simple "?" in a bu_log output to appease pedantic warning about potential trigraph usage (!)
@
text
@d32 1
a32 1
static const char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.43 2001/06/14 15:07:28 bparker Exp $ (BRL)";
d201 1
a201 1
					loc += sizeof(int);
d334 1
a334 1
					loc += sizeof(int);
d345 1
a345 1
				loc += sizeof(int);
d991 2
a992 2
	bu_vls_printf( vp, "%hd", *sp++ );
	while( --i > 0 ) bu_vls_printf( vp, "%c%hd", sep_char, *sp++ ); }
d1126 1
a1126 1
				bu_log( " %s=%hd", sdp->sp_name, *sp++ );
d1477 1
a1477 1
				bu_vls_printf(vls_out, " %s=%hd", sdp->sp_name, *sp++ );
@


1.43
log
@*- add bu_vls_matprint, same as bu_matprint except
   prints to a vls
*- finish bu_vls_struct_print2
@
text
@d32 1
a32 1
static const char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.42 2001/06/01 17:42:51 bparker Exp $ (BRL)";
d1900 1
a1900 1
			bu_log( "Error in list (uneven braces??): %s\n", in );
@


1.42
log
@*- added bu_vls_struct_print2 (same as bu_struct_print
   except output goes to a vls)
@
text
@d32 1
a32 1
static const char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.41 2001/04/05 19:35:30 morrison Exp $ (BRL)";
d908 28
a1059 1
	struct bu_vls vls;
a1060 1
	bu_vls_init( &vls );
a1189 1
	bu_vls_free(&vls);
a1412 1
	struct bu_vls vls;
a1413 1
	bu_vls_init(&vls);
d1416 1
a1416 1
		bu_log("Null \"struct bu_structparse\" pointer\n");
d1441 1
a1441 1
			bu_log("bu_struct_print:  %s: unknown format '%s'\n",
d1445 1
a1445 5
#if 0
		bu_vls_trunc( &vls, 0 );
		bu_vls_struct_item( &vls, sdp, base, ',' );
		bu_log( " %s=%s\n", sdp->sp_name, bu_vls_addr(&vls) );
#else
d1464 1
a1464 1
				bu_log(" %s=(vls_magic)%d (vls_offset)%d (vls_len)%d (vls_max)%d\n",
d1468 1
d1470 1
a1470 1
				bu_log("\"%s\"\n", vls->vls_str+vls->vls_offset);
d1477 1
a1477 1
				bu_log( " %s=%hd", sdp->sp_name, *sp++ );
d1479 2
a1480 1
				while (--i > 0) bu_log( ",%d", *sp++ );
d1482 1
a1482 1
				bu_log("\n");
d1489 1
a1489 1
				bu_log( " %s=%d", sdp->sp_name, *dp++ );
d1491 2
a1492 1
				while (--i > 0) bu_log( ",%d", *dp++ );
d1494 1
a1494 1
				bu_log("\n");
d1502 1
a1502 1
					bu_matprint(sdp->sp_name, dp);
d1504 1
a1504 1
					bu_log( " %s=%.25G", sdp->sp_name, *dp++ );
d1507 1
a1507 1
						bu_log( ",%.25G", *dp++ );
d1509 1
a1509 1
					bu_log("\n");
d1514 2
d1517 4
a1520 4
					bu_log( " %s=%.25G\n", sdp->sp_name, *dp++ );

					while (--i > 1)
						bu_log( "%.25G\n", *dp++ );
d1523 1
a1523 1
					bu_log( "%.25G\n", *dp );
d1531 1
a1531 1
				bu_log( " %s=%08x", sdp->sp_name, *dp++ );
d1533 2
a1534 1
				while (--i > 0) bu_log( ",%08x", *dp++ );
d1536 1
a1536 1
				bu_log("\n");
d1540 1
a1540 1
			bu_log( " bu_struct_print: Unknown format: %s=%s??\n",
a1543 1
#endif
a1544 1
	bu_vls_free(&vls);
@


1.41
log
@updated SIGNED to signed
updated CONST to const
@
text
@d32 1
a32 1
static const char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.40 2001/03/19 22:19:45 butler Exp $ (BRL)";
d1374 123
d1498 8
d1507 1
d1509 1
d1511 12
@


1.40
log
@patches to merge 5.3 into 6.0
@
text
@d32 1
a32 1
static const char RCSparse[] = "@@(#)$Header: /d/CVS/brlcad/libbu/parse.c,v 1.39 2000/10/30 15:06:26 jra Exp $ (BRL)";
d126 2
a127 2
CONST genptr_t		base;
CONST struct bu_structparse *imp;
d131 1
a131 1
	CONST struct bu_structparse *ip;	/* current imexport structure */
d281 2
a282 2
CONST struct bu_structparse	*imp;
CONST struct bu_external	*ext;
d284 2
a285 2
	register CONST unsigned char	*cp;	/* current possition in buffer */
	CONST struct bu_structparse	*ip;	/* current imexport structure */
d420 1
a420 1
CONST struct bu_external	*ext;
d545 1
a545 1
CONST char	*str;
d551 1
a551 1
	CONST char	*numstart;
d614 2
a615 2
register CONST struct bu_structparse	*sdp;	/* structure description */
register CONST char			*name;	/* struct member name */
d617 1
a617 1
CONST char			* CONST	value;	/* string containing value */
d689 2
a690 2
				register CONST char *cp;
				register CONST char *pv = value;
d722 2
a723 2
				register char CONST *cp;
				register CONST char *pv = value;
d788 2
a789 2
CONST struct bu_vls		*in_vls;	/* string to parse through */
CONST struct bu_structparse	*desc;		/* structure description */
d885 2
a886 2
CONST char		*name;
register CONST double	*mat;
d916 2
a917 2
CONST struct bu_structparse *sdp;    /* item description */
CONST char *base;                 /* base address of users structure */
d1003 3
a1005 3
CONST struct bu_structparse *parsetab;
CONST char *name;
CONST char *base;
d1008 1
a1008 1
    register CONST struct bu_structparse *sdp;
d1025 3
a1027 3
CONST char			*title;
CONST struct bu_structparse	*parsetab;/* structure description */
CONST char			*base;	  /* base address of users structure */
d1029 1
a1029 1
	register CONST struct bu_structparse	*sdp;
d1173 1
a1173 1
CONST char		*name;
d1175 1
a1175 1
register CONST double	*dp;
d1204 2
a1205 2
register CONST struct bu_structparse	*sdp;	/* structure description */
CONST char				*base;	/* structure ponter */
d1385 2
a1386 2
register CONST struct bu_structparse	*sdp;	/* structure description */
register CONST char			*name;	/* struct member name */
d1388 1
a1388 1
CONST char				*value;	/* string containing value */
d1985 1
a1985 1
bu_hexdump_external( FILE *fp, CONST struct bu_external *ep, CONST char *str)
@


1.39
log
@Corrected bug in bu_shader_to_tcl_list() for stack shader with just one shader
@
text
@d32 1
a32 1
static const char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.38 2000/10/24 14:35:47 mike Exp $ (BRL)";
d1590 1
d1592 1
d1595 1
d1597 1
d1857 1
@


1.38
log
@
bu_next_token() moved out of librt/g_bot.c
@
text
@d32 1
a32 1
static const char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.37 2000/07/27 14:35:22 mike Exp $ (BRL)";
a1572 12
			int multi=0;
			char *c;

			c = iptr;
			while( *++c )
			{
				if( *c == ';' )
				{
					multi = 1;
					break;
				}
			}
d1590 1
a1590 2
				if( multi )
					bu_vls_putc( vls, '{' );
d1593 1
a1593 2
				if( multi )
					bu_vls_strcat( vls, "} " );
@


1.37
log
@
Removed memory leak
@
text
@d32 1
a32 1
static const char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.36 2000/07/26 17:17:57 mike Exp $ (BRL)";
d2060 20
@


1.36
log
@
Improvements in v4->v5 converstion.  Auto conversion of shader strings.
@
text
@d32 1
a32 1
static const char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.35 2000/07/12 01:25:28 mike Exp $ (BRL)";
d1659 9
d1669 1
a1669 3
bu_list_elem( in, index )
char *in;
int index;
d1674 4
a1677 4
	char *ptr=in;
	char *prev=NULL;
	char *start=NULL;
	char *end=NULL;
d1767 5
d1773 1
a1773 2
bu_tcl_list_length( in )
char *in;
d1777 2
a1778 2
	char *ptr=in;
	char *prev=NULL;
d1867 2
@


1.35
log
@
Added error logging to bu_fwrite_external()
@
text
@d32 1
a32 1
static const char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.34 2000/07/12 01:18:00 mike Exp $ (BRL)";
d1518 20
@


1.34
log
@
Prevent disaster.
@
text
@d32 1
a32 1
static const char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.33 2000/07/12 01:12:38 mike Exp $ (BRL)";
d1945 2
d1949 3
a1951 1
	if( fwrite( ep->ext_buf, ep->ext_nbytes, 1, fp ) != 1 )
d1953 1
@


1.33
log
@
Added bu_copy_external()
@
text
@d32 1
a32 1
static const char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.32 2000/07/07 05:20:13 cjohnson Exp $ (BRL)";
d2016 2
@


1.32
log
@LINT
@
text
@d32 1
a32 1
static const char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.31 2000/07/05 21:19:37 mike Exp $ (BRL)";
d2006 14
@


1.31
log
@
Added externs
@
text
@d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.30 2000/06/28 21:44:12 mike Exp $ (BRL)";
@


1.30
log
@
Further improved format of bu_hexdump_external()
@
text
@d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.29 2000/06/28 21:31:43 mike Exp $ (BRL)";
d1840 3
d1943 1
a1943 3
bu_fwrite_external( fp, ep )
FILE			*fp;
CONST struct bu_external *ep;
d1956 1
a1956 4
bu_hexdump_external( fp, ep, str )
FILE			*fp;
CONST struct bu_external *ep;
CONST char		*str;
d1999 1
a1999 2
bu_free_external( ep )
register struct bu_external	*ep;
@


1.29
log
@
Improved bu_hexdump_external
@
text
@d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.28 2000/06/27 20:55:23 mike Exp $ (BRL)";
d1976 4
a1979 2
				if( cp >= endp )  break;
				fprintf(fp, "%2.2x ", *cp++ );
@


1.28
log
@
Added ASCII print to the hexdump.
@
text
@d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.27 2000/06/27 17:38:28 mike Exp $ (BRL)";
d1960 2
a1961 1
	unsigned char	*cp;
d1970 1
d1972 1
a1972 1
		const char	*sp = cp;
d1976 1
d1984 1
@


1.27
log
@
Added warning message when hexdumping empty table
@
text
@d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.26 2000/06/26 19:38:21 mike Exp $ (BRL)";
d1970 2
d1978 10
a1987 1
		fprintf(fp, "\n");
@


1.26
log
@
Added bu_hexdump_external()
@
text
@d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.25 2000/06/23 04:55:46 mike Exp $ (BRL)";
d1966 2
@


1.25
log
@
Added support routines for bu_external data structures.
@
text
@d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.24 2000/02/23 22:25:48 butler Exp $ (BRL)";
d1949 27
@


1.25.2.1
log
@Fixed a bug in bu_shader_to_tcl_list() for stacks with just one shader and
corrected a memory leak in bu_key_val_to_vls()
@
text
@d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.25 2000/06/23 04:55:46 mike Exp $ (BRL)";
d1553 12
d1582 2
a1583 2

				bu_vls_putc( vls, '{' );
d1586 2
a1587 2

				bu_vls_strcat( vls, "} " );
a1835 2
		bu_free( (char *)keyword, "bu_key_val_to_vls:keyword" );
		bu_free( (char *)value, "bu_key_val_to_vls:value" );
@


1.24
log
@Fixed matprint to work under linux
@
text
@d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.23 1999/12/29 20:15:47 jra Exp $ (BRL)";
d1924 39
@


1.23
log
@Eliminated some unused variables
@
text
@d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.22 1999/12/17 02:41:37 mike Exp $ (BRL)";
d893 1
a893 1
	bu_log(" %s=%.-12E %.-12E %.-12E %.-12E\n",
d896 1
a896 1
	bu_log("%.-12E %.-12E %.-12E %.-12E\n",
d899 1
a899 1
	bu_log("%.-12E %.-12E %.-12E %.-12E\n",
d904 1
a904 1
	bu_log("%.-12E %.-12E %.-12E %.-12E\n",
@


1.22
log
@
Improved error messages that are seen by RT users.
@
text
@d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.21 1999/01/22 21:41:59 jra Exp $ (BRL)";
a1389 1
	double v;
a1523 1
	char *out_params=(char *)NULL;
a1527 1
	int stack_count=0;
d1889 1
a1889 1
		int i,j;
d1901 1
a1901 2
			char *shader1, *shade1_name, *params1;
			int len1;
@


1.21
log
@bu_shader_to_key_eq() was adding an extra space in the stack shader.
@
text
@d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.20 1999/01/22 11:00:49 butler Exp $ (BRL)";
d825 2
a826 2
			bu_log("bu_structparse: name '%s' without '='\n",
				name );
d845 1
a845 1
				bu_log("bu_structparse: name '%s'=\" without closing \"\n",
d863 1
a863 1
		    bu_log("bu_structparse:  '%s=%s', element name not found in:\n",
@


1.20
log
@fixed bug where hook function didn't get string arguments when parsing integer
values.
@
text
@d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.19 1999/01/20 23:41:09 jra Exp $ (BRL)";
d1896 1
a1896 1
		bu_vls_strcat( vls, "stack " );
@


1.19
log
@bu_list_elem() needed at check for a NULL pointer.
@
text
@d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.18 1999/01/13 02:22:41 mike Exp $ (BRL)";
d617 1
a617 1
CONST char				*value;	/* string containing value */
d690 1
a690 2
				for (i=0 ; i < sdp->sp_count && *value ; ++i){
					tmpi = atoi( value );
d692 4
a695 1
					cp = value;
d705 3
a707 3
					if (cp == value ||
					    (cp == value+1 &&
					    (*value == '+' || *value == '-'))){
d712 1
a712 1
						value = cp;
d715 1
a715 1
					if (*value) value++;
d723 2
d726 1
a726 1
				if( *value == '!' )  {
d728 1
a728 1
					value++;
d732 2
a733 2
				for (i=0 ; i < sdp->sp_count && *value ; ++i){
					tmpi = atoi( value );
d735 1
a735 1
					cp = value;
d745 3
a747 3
					if (cp == value ||
					    (cp == value+1 &&
					    (*value == '+' || *value == '-'))){
d752 1
a752 1
						value = cp;
d755 1
a755 1
					if (*value) value++;
@


1.18
log
@Split bu_plong() and other XDR routines out into xdr.c
@
text
@d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.17 1999/01/13 02:08:17 mike Exp $ (BRL)";
d1712 1
a1712 1
		if( *end != '}' )
@


1.17
log
@Changed RT_ to BU_ in comments, to match actual names of things.
@
text
@d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.16 1998/12/10 04:08:18 jra Exp $ (BRL)";
d173 1
a173 1
			htond( cp, loc, ip->sp_count );
d320 1
a320 1
			ntohd( loc, cp, ip->sp_count );
a483 74
}

/*
 *  Routines to insert/extract short/long's into char arrays,
 *  independend of machine byte order and word-alignment.
 *  Uses encoding compatible with routines found in libpkg,
 *  and BSD system routines ntohl(), ntons(), ntohl(), ntohs().
 */

/*
 *			B U _ G S H O R T
 */
unsigned short
bu_gshort(msgp)
CONST unsigned char *msgp;
{
	register CONST unsigned char *p = msgp;
#ifdef vax
	/*
	 * vax compiler doesn't put shorts in registers
	 */
	register unsigned long u;
#else
	register unsigned short u;
#endif

	u = *p++ << 8;
	return ((unsigned short)(u | *p));
}

/*
 *			B U _ G L O N G
 */
unsigned long
bu_glong(msgp)
CONST unsigned char *msgp;
{
	register CONST unsigned char *p = msgp;
	register unsigned long u;

	u = *p++; u <<= 8;
	u |= *p++; u <<= 8;
	u |= *p++; u <<= 8;
	return (u | *p);
}

/*
 *			B U _ P S H O R T
 */
unsigned char *
bu_pshort(msgp, s)
register unsigned char *msgp;
register int s;
{

	msgp[1] = s;
	msgp[0] = s >> 8;
	return(msgp+2);
}

/*
 *			B U _ P L O N G
 */
unsigned char *
bu_plong(msgp, l)
register unsigned char *msgp;
register unsigned long l;
{

	msgp[3] = l;
	msgp[2] = (l >>= 8);
	msgp[1] = (l >>= 8);
	msgp[0] = l >> 8;
	return(msgp+4);
@


1.16
log
@Fixe a bug and did some simplifying.
@
text
@d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.15 1998/07/13 19:09:19 jra Exp $ (BRL)";
d121 1
a121 1
 *			R T _ S T R U C T _ E X P O R T
d276 1
a276 1
 *			R T _ S T R U C T _ I M P O R T
d412 1
a412 1
 *			R T _ S T R U C T _ P U T
d428 1
a428 1
 *			R T _ S T R U C T _ G E T
d494 1
a494 1
 *			R T _ G S H O R T
d515 1
a515 1
 *			R T _ G L O N G
d531 1
a531 1
 *			R T _ P S H O R T
d545 1
a545 1
 *			R T _ P L O N G
d561 1
a561 1
 *			R T _ S T R U C T _ B U F
@


1.15
log
@Mods to handle "envmap" same as "stack".
@
text
@d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.14 1998/07/13 13:10:24 jra Exp $ (BRL)";
d1624 42
a1665 4
			bu_vls_strcpy( vls, "stack {" );
			is_stack = 1;
			next = iptr;
			continue;
d1669 5
a1673 4
			bu_vls_strcpy( vls, "envmap {" );
			is_stack = 1;
			next = iptr;
			continue;
d1919 1
d1933 3
a1935 1
		bu_vls_strcpy( vls, in );
d1948 1
a1948 1
	if( strcmp( shader, "stack" ) && strcmp( shader, "envmap" ) )
d1950 7
a1956 3
		bu_vls_strcpy( vls, shader );
		if( bu_key_val_to_vls( vls, params ) )
			return( 1 );
d1958 1
a1958 1
	else
d1964 3
a1966 4
		bu_vls_strcpy( vls, shader );
		bu_vls_putc( vls, ' ' );

		bu_free( shader, "bu_shader_to_key_eq:shader" );
d1980 1
a1980 25
			len1 = bu_tcl_list_length( shader1 );
			if( len1 == 0 )
			{
				bu_free( shader1, "shader1" );
				continue;
			}
			else if( len1 == 1 )
			{
				if( i>0 && i<len )
					bu_vls_putc( vls, ';' );
				shade1_name = bu_list_elem( shader1, 0 );
				bu_vls_strcat( vls, shade1_name );
				bu_free( shader1, "shader1" );
				continue;
			}
			else if( len1 != 2 )
			{
				bu_log( "bu_shader_to_key_eq: Error: shader must have two elements!! (not %d)\n\t%s\n", len1, in );
				return 1;
			}

			shade1_name = bu_list_elem( shader1, 0 );
			params1 = bu_list_elem( shader1, 1 );

			if( i>0 && i<len )
d1982 1
a1982 2

			bu_vls_strcat( vls, shade1_name );
a1983 7
			if( bu_key_val_to_vls( vls, params1 ) )
			{
				bu_free( params1, "params1" );
				return( 1 );
			}

			bu_free( params1, "params1" );
d1986 10
d1997 1
a1997 1
	return 0;
@


1.14
log
@Mods to allow shader to have a single parameter. (like "envmap").
@
text
@d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.13 1998/07/09 15:30:21 jra Exp $ (BRL)";
d1629 7
d1899 1
a1899 1
		bu_log( "bu_shader_to_key_eq: Error: shader must have two elements!!\n\t%s\n", in );
d1906 1
a1906 1
	if( strcmp( shader, "stack" ) )
d1918 2
a1919 1
		bu_vls_strcpy( vls, "stack " );
d1952 1
a1952 1
				bu_log( "bu_shader_to_key_eq: Error: shader must have two elements!!\n\t%s\n", in );
@


1.13
log
@bu_key_eq_to_key_val() was choking on shader parameters that ended with a blank.
@
text
@d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.12 1998/06/23 17:51:03 jra Exp $ (BRL)";
d1518 1
a1518 4
				{
					bu_log( "Error: no '=' found for keyword in '%s'\n", in );
					return( 1 );
				}
d1830 7
@


1.12
log
@Saved a few spaces in TCL shader strings.
@
text
@d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.11 1998/06/23 17:28:04 jra Exp $ (BRL)";
d1496 3
@


1.11
log
@Allowed shaders without parameter lists, and fixed some bugs.
@
text
@d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.10 1998/06/22 19:47:07 jra Exp $ (BRL)";
d1569 1
a1569 1
						bu_vls_strcat( vls, "} " );
d1647 1
a1647 1
				bu_vls_strcat( vls, "} " );
d1657 1
a1657 1
			bu_vls_strcat( vls, "} " );
d1661 1
a1661 3
		bu_vls_strcat( vls, "} " );

	bu_vls_trimspace( vls );
@


1.10
log
@Added cases for no shader or a shader with no parameters to bu_shader_to_key_eq().
@
text
@d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parse.c,v 1.9 1998/06/04 18:39:37 jra Exp $ (BRL)";
d1564 1
a1564 1
				bu_vls_putc( vls, '{' );
d1569 1
a1569 1
						bu_vls_putc( vls, '}' );
d1601 2
a1638 1
		bu_vls_strcat( vls, " {" );
d1642 2
d1646 4
a1654 1
		bu_vls_putc( vls, '}' );
d1657 1
a1657 1
			bu_vls_putc( vls, '}' );
d1661 1
a1661 1
		bu_vls_putc( vls, '}' );
d1663 2
d1720 2
a1721 1
				(*ptr != '}' || *prev == '\\') )
d1811 2
a1812 1
				(*ptr != '}' || *prev == '\\') )
d1923 15
a1937 1
			if( len1 != 2 )
d1950 1
d1952 2
d1955 3
@


1.9
log
@improved shader to TCL conversion routines.
@
text
@d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /m/cad/libbu/RCS/parse.c,v 1.8 1998/05/29 20:20:14 jra Exp jra $ (BRL)";
d1546 1
a1546 1
				while( *iptr && !isspace( *iptr ) )
d1825 1
a1825 1
		bu_log( "bu_shader_to_key_eq: Error: shader parameters must be even numbered!!\n\t%s\n", params );
d1864 10
@


1.8
log
@Added routines for converting among keyword=value and keyword-space-value.
@
text
@d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /m/cad/CVS/brlcad/libbu/parse.c,v 1.7 1998/04/03 01:33:00 mike Exp $ (BRL)";
d1472 5
a1476 3
char *
bu_key_eq_to_key_val( in )
CONST char *in;
d1478 2
a1479 3
	CONST char *iptr=in;
	char *optr;
	char *out;
d1482 3
a1484 3
	/* output string should be same length as input string */
	out = (char *)bu_malloc( strlen( in ) + 1, "bu_key_eq_to_key_val:out" );
	optr = out;
d1497 1
a1497 2
				/* copy keyword up to '=' (skipping white space) */
				while( *iptr != '=' )
d1499 3
a1501 4
					if( isspace( *iptr ) )
						iptr++;
					else
						*optr++ = *iptr++;
d1504 7
d1512 7
a1518 1
				*optr++ = ' ';
d1545 1
d1547 3
a1549 1
					*optr++ = *iptr++;
d1553 2
a1554 1
					*optr++ = ' ';
d1564 1
a1564 1
				*optr++ = '{';
d1569 1
a1569 1
						*optr++ = '}';
d1573 2
a1574 2
					*prev = *optr;
					*optr++ = *iptr++;
d1577 5
a1581 6
				if( *iptr ) /* more to come */
				{
					*optr++ = ' ';
					/* switch back to keyword state */
					state = STATE_IN_KEYWORD;
				}
d1586 1
a1586 3

	*optr++ = '\0';
	return( out );
d1589 4
a1592 3
char *
bu_shader_to_key_val( in )
CONST char *in;
d1594 1
a1594 2
	CONST char *iptr=in;
	char *out;
d1596 2
a1597 1
	CONST char *shader;
d1599 2
d1602 1
a1602 15
	/* skip over shader name */
	while( isspace( *iptr ) )
		iptr++;

	shader = iptr;
	while( *iptr && !isspace( *iptr ) )
		iptr++;
	shader_name_len = iptr - shader;

	while( isspace( *iptr ) )
		iptr++;

	/* iptr now points at start of parameters */
	if( *iptr )
		out_params = bu_key_eq_to_key_val( iptr );
d1604 1
a1604 1
	if( out_params )
d1606 46
a1651 5
		out = bu_malloc( strlen( out_params ) + shader_name_len + 1, "bu_shader_to key_val:out" );
		strncpy( out, shader, shader_name_len );
		strcat( out, " " );
		strcat( out, out_params );
		bu_free( out_params, "bu_shader_to key_val:out_params" );
d1653 3
a1655 5
	else
	{
		out = bu_malloc( shader_name_len + 1, "bu_shader_to key_val:out" );
		strncpy( out, shader, shader_name_len );
	}
d1657 1
a1657 1
	return( out );
d1661 66
a1726 8
bu_key_val_to_key_eq( in )
CONST char *in;
{
	char *out;
	char *optr;
	CONST char *iptr=in;
	int list_depth=0;
	int state=STATE_IN_KEYWORD;
d1728 2
a1729 3
	/* output string should be same length as input string */
	out = (char *)bu_malloc( strlen( in ) + 1, "bu_key_val_to_key_eq:out" );
	optr = out;
d1731 1
a1731 1
	while( *iptr )
d1733 10
a1742 1
		char *prev = '\0';
d1744 3
a1746 6
		switch( state )
		{
			case STATE_IN_KEYWORD:
				/* skip leading white space */
				while( *iptr && isspace( *iptr ) )
					iptr++;
d1748 3
a1750 3
				/* copy keyword up to first ' ' */
				while( *iptr && !isspace( *iptr ) )
					*optr++ = *iptr++;
d1752 4
a1755 2
				/* add a '=' after keyword */
				*optr++ = '=';
d1757 2
a1758 2
				/* skip over ' ' in input */
				iptr++;
d1760 8
a1767 2
				/* switch to value state */
				state = STATE_IN_VALUE;
d1769 8
a1776 5
				break;
			case STATE_IN_VALUE:
				/* skip excess white space */
				while( *iptr && isspace( *iptr ) )
					iptr++;
d1778 2
a1779 5
				/* check for list start */
				if( *iptr == '{' )
				{
					/* switch to quoted value state */
					state = STATE_IN_QUOTED_VALUE;
d1781 18
a1798 2
					/* skip over '{' */
					iptr++;
d1800 9
a1808 2
					break;
				}
d1810 2
a1811 3
				/* copy value up to next white space or end of string */
				while( *iptr && !isspace( *iptr ) )
					*optr++ = *iptr++;
d1813 7
a1819 6
				if( *iptr ) /* more to come */
				{
					*optr++ = ' ';
					/* switch back to keyword state */
					state = STATE_IN_KEYWORD;
				}
d1821 1
a1821 5
				break;
			case STATE_IN_QUOTED_VALUE:
				/* copy byte-for-byte to of list
				 * watch out for escaped quotes or included lists.
				 * replace ending '}' with '"' */
d1823 5
a1827 17
				list_depth++;
				*optr++ = '\"';
				while( 1 )
				{
					if( *iptr == '}' )
					{
						if( *prev != '\\' && list_depth == 1 )
						{
							*optr++ = '"';
							iptr++;
							break;
						}
						else if( *prev != '\\' )
							list_depth--;
					}
					else if( *iptr == '{' && *prev != '\\' )
						list_depth++;
d1829 4
a1832 3
					*prev = *optr;
					*optr++ = *iptr++;
				}
d1834 2
a1835 6
				if( *iptr ) /* more to come */
				{
					*optr++ = ' ';
					/* switch back to keyword state */
					state = STATE_IN_KEYWORD;
				}
d1837 8
a1844 1
				break;
d1846 2
d1849 1
a1849 3

	*optr++ = '\0';
	return( out );
d1852 4
a1855 3
char *
bu_shader_to_key_eq( in )
CONST char *in;
d1857 13
a1869 5
	CONST char *iptr=in;
	char *out;
	char *out_params=(char *)NULL;
	CONST char *shader;
	int shader_name_len=0;
d1871 2
a1872 15
	/* skip over shader name */
	while( isspace( *iptr ) )
		iptr++;

	shader = iptr;
	while( *iptr && !isspace( *iptr ) )
		iptr++;
	shader_name_len = iptr - shader;

	while( isspace( *iptr ) )
		iptr++;

	/* iptr now points at start of parameters */
	if( *iptr )
		out_params = bu_key_val_to_key_eq( iptr );
d1874 1
a1874 1
	if( out_params )
d1876 3
a1878 5
		out = bu_malloc( strlen( out_params ) + shader_name_len + 1, "bu_shader_to key_val:out" );
		strncpy( out, shader, shader_name_len );
		strcat( out, " " );
		strcat( out, out_params );
		bu_free( out_params, "bu_shader_to key_val:out_params" );
d1882 37
a1918 2
		out = bu_malloc( shader_name_len + 1, "bu_shader_to key_val:out" );
		strncpy( out, shader, shader_name_len );
d1921 1
a1921 1
	return( out );
@


1.7
log
@Fixed bug where %s strings on structparse were not being NULL terminated!
@
text
@d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /m/cad/libbu/RCS/parse.c,v 1.6 1997/04/01 20:22:16 butler Exp mike $ (BRL)";
d1465 305
@


1.6
log
@added bu_parse_mm()
@
text
@d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /m/cad/libbu/RCS/parse.c,v 1.5 1997/01/03 17:23:18 butler Exp butler $ (BRL)";
d744 8
a751 2
				if (sdp->sp_count > 1)
					loc[sdp->sp_count-1] = '\0';
@


1.5
log
@changed import routine so that sp_hook is called.  Statement was unreachable
because of use of (continue) instead of (break).
@
text
@d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /m/cad/libbu/RCS/parse.c,v 1.4 1996/08/31 11:27:25 butler Exp butler $ (BRL)";
d1444 12
d1457 3
@


1.4
log
@bu_struct_buf -> bu_struct_wrap_buf
@
text
@d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /m/cad/libbu/RCS/parse.c,v 1.3 1996/08/31 08:02:20 butler Exp butler $ (BRL)";
d323 1
a323 1
			continue;
d339 1
a339 1
			continue;
d349 1
a349 1
			continue;
d378 1
a378 1
			continue;
d397 1
a397 1
			continue;
@


1.3
log
@Inherited contents of old inout.c which did binary structuer I/O
@
text
@d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /m/cad/libbu/RCS/parse.c,v 1.2 1996/08/29 22:56:01 butler Exp butler $ (BRL)";
d570 1
a570 1
bu_struct_buf( ext, buf )
@


1.2
log
@Don't need raytrace.h anymore
@
text
@d6 1
a6 1
 *  a structure of type "structparse", giving element names, element
d11 7
d32 1
a32 1
static char RCSparse[] = "@@(#)$Header: /m/cad/libbu/RCS/parse.c,v 1.1 1996/08/29 22:42:41 butler Exp butler $ (BRL)";
a47 1
#include "vmath.h"
d51 559
d851 1
a851 1
bu_structparse( in_vls, desc, base )
d929 1
a929 1
		    bu_structprint( "troublesome one", desc, base );
d950 1
a950 1
register CONST matp_t	mat;
d972 7
a978 3

HIDDEN void
bu_vls_item_print_core( vp, sdp, base, sep_char )
d982 1
a982 1
char sep_char;                    /* value separator */
d1003 1
a1003 1
	bu_log("bu_vls_item_print:  %s: unknown format '%s'\n",
d1059 1
a1059 54
 *                     B U _ V L S _ I T E M _ P R I N T
 *
 * Takes the single item pointed to by "sp", and prints its value into a
 * vls.
 */

void
bu_vls_item_print( vp, sdp, base )
struct bu_vls *vp;
CONST struct bu_structparse *sdp;     /* item description */
CONST char *base;                 /* base address of users structure */
{
    bu_vls_item_print_core( vp, sdp, base, ',' );
}

/*
 *    B U _ V L S _ I T E M _ P R I N T _ N C
 *
 *    A "no-commas" version of the bu_vls_item_print() routine.
 */

void
bu_vls_item_print_nc( vp, sdp, base )
struct bu_vls *vp;
CONST struct bu_structparse *sdp;     /* item description */
CONST char *base;                 /* base address of users structure */
{
    bu_vls_item_print_core( vp, sdp, base, ' ' );
}

/*                  B U _ V L S _ N A M E _ P R I N T
 *
 * A version of bu_vls_item_print that allows you to select by name.
 */

int
bu_vls_name_print( vp, parsetab, name, base )
struct bu_vls *vp;
CONST struct bu_structparse *parsetab;
CONST char *name;
CONST char *base;
{
    register CONST struct bu_structparse *sdp;

    for( sdp = parsetab; sdp->sp_name != NULL; sdp++ )
	if( strcmp(sdp->sp_name, name) == 0 ) {
	    bu_vls_item_print( vp, sdp, base );
	    return 0;
	}

    return -1;
}

/*                  B U _ V L S _ N A M E _ P R I N T _ N C
d1061 2
a1062 1
 * A "no-commas" version of bu_vls_name_print
a1063 1

d1065 1
a1065 1
bu_vls_name_print_nc( vp, parsetab, name, base )
d1070 1
d1076 1
a1076 1
	    bu_vls_item_print_nc( vp, sdp, base );
a1083 2


d1088 1
a1088 1
bu_structprint( title, parsetab, base )
d1118 1
a1118 1
			bu_structprint( sdp->sp_name,
d1125 1
a1125 1
			bu_log("bu_structprint:  %s: unknown format '%s'\n",
d1131 1
a1131 1
		bu_vls_item_print( &vls, sdp, base );
d1186 3
a1188 3
				if (sdp->sp_count == ELEMENTS_PER_MAT) {
					bu_matprint(sdp->sp_name, (matp_t)dp);
				} else if (sdp->sp_count <= ELEMENTS_PER_VECT){
d1222 1
a1222 1
			bu_log( " bu_structprint: Unknown format: %s=%s??\n",
d1262 1
a1262 1
 *	This differs from bu_structprint in that this output is less readable
d1266 1
a1266 1
bu_vls_structprint( vls, sdp, base)
d1299 1
a1299 1
			bu_vls_structprint( &sub_str,
d1309 1
a1309 1
			bu_log("bu_structprint:  %s: unknown format '%s'\n",
d1436 9
@


1.1
log
@Initial revision
@
text
@d25 1
a25 1
static char RCSparse[] = "@@(#)$Header: /m/cad/librt/RCS/parse.c,v 11.5 1996/08/27 03:43:38 mike Exp butler $ (BRL)";
d43 1
a43 1
#include "raytrace.h"
@
