head	1.18;
access;
symbols
	ansi-20040405-merged:1.15.2.2
	postmerge-20040405-ansi:1.16
	premerge-20040404-ansi:1.15
	postmerge-autoconf:1.15
	autoconf-freeze:1.15
	premerge-autoconf:1.15
	ansi-20040316-freeze:1.15.2.1
	postmerge-20040315-windows:1.15
	premerge-20040315-windows:1.15
	windows-20040315-freeze:1.15
	autoconf-20031203:1.15
	autoconf-20031202:1.15
	autoconf-branch:1.15.0.10
	phong-branch:1.15.0.8
	photonmap-branch:1.15.0.6
	rel-6-1-DP:1.15
	windows-branch:1.15.0.4
	rel-6-0-2:1.13
	ansi-branch:1.15.0.2
	rel-6-0-1-branch:1.13.0.2
	hartley-6-0-post:1.14
	hartley-6-0-pre:1.13
	rel-6-0-1:1.13
	rel-6-0:1.13
	rel-5-4:1.6
	offsite-5-3-pre:1.9
	rel-5-3:1.6
	rel-5-2:1.6
	rel-5-1-branch:1.6.0.2
	rel-5-1:1.6
	rel-5-0:1.4
	rel-5-0-beta:1.4
	rel-4-5:1.3
	ctj-4-5-post:1.3
	ctj-4-5-pre:1.3;
locks; strict;
comment	@ * @;


1.18
date	2004.05.21.18.06.24;	author morrison;	state dead;
branches;
next	1.17;

1.17
date	2004.05.10.15.30.44;	author erikg;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.05.07.46.16;	author morrison;	state Exp;
branches;
next	1.15;

1.15
date	2002.08.20.17.07.40;	author jra;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2002.08.15.20.54.53;	author hartley;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.09.21.19.45;	author jra;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.07.14.36.37;	author jra;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.06.20.49.19;	author jra;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.20.22.29.06;	author morrison;	state Exp;
branches;
next	1.9;

1.9
date	2000.10.30.21.29.15;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.27.01.26.36;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.07.05.21.21;	author cjohnson;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.29.01.41.55;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.28.18.55.08;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	98.11.05.20.57.52;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	97.04.01.05.42.31;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	96.12.18.20.50.49;	author jra;	state Exp;
branches;
next	1.1;

1.1
date	96.08.31.10.40.04;	author mike;	state Exp;
branches;
next	;

1.15.2.1
date	2002.09.19.18.01.12;	author morrison;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2004.04.05.00.50.06;	author morrison;	state Exp;
branches;
next	;


desc
@bu_list support routines
@


1.18
log
@moved to src/
@
text
@/*
 *			L I S T . C
 *
 *  Generic bu_list routines
 *
 *  Authors -
 *	Michael John Muuss
 *	Lee A. Butler
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
 */
#ifndef lint
static const char libbu_list_RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libbu/list.c,v 1.17 2004/05/10 15:30:44 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <stdio.h>
#include "machine.h"
#include "bu.h"

#include <assert.h>

/*
 *			B U _ L I S T _ N E W
 *
 *	Creates and initializes a bu_list head structure
 */
struct bu_list *
bu_list_new(void)
{
	struct bu_list *new;

	BU_GETSTRUCT( new, bu_list );
	BU_LIST_INIT( new );

	return( new );
}

/*
 *			B U _ L I S T _ P O P
 *
 *	Returns the results of BU_LIST_POP
 */
struct bu_list *
bu_list_pop( struct bu_list *hp )
{
	struct bu_list *p;

	BU_LIST_POP( bu_list, hp, p );

	return( p );
}

/*
 *			B U _ L I S T _ L E N
 *
 *  Returns the number of elements on a bu_list brand linked list.
 */
int
bu_list_len(register const struct bu_list *hd)
{
	register int			count = 0;
	register const struct bu_list	*ep;

	for( BU_LIST_FOR( ep, bu_list, hd ) )  {
		count++;
	}
	return count;
}

/*
 *			B U _ L I S T _ R E V E R S E
 *
 *	Reverses the order of elements in a bu_list linked list.
 */
void
bu_list_reverse(register struct bu_list *hd)
{
	struct bu_list tmp_hd;
	register struct bu_list *ep;

	BU_CK_LIST_HEAD( hd );

	BU_LIST_INIT( &tmp_hd );
	BU_LIST_INSERT_LIST( &tmp_hd, hd );

	while( BU_LIST_WHILE( ep, bu_list, &tmp_hd ) )  {
		BU_LIST_DEQUEUE( ep );
		BU_LIST_APPEND( hd, ep );
	}
}

/*
 *			B U _ L I S T _ F R E E
 *
 *  Given a list of structures allocated with bu_malloc() enrolled
 *  on a bu_list head, walk the list and free the structures.
 *  This routine can only be used when the structures have no interior
 *  pointers.
 */
void
bu_list_free(struct bu_list *hd)
{
	struct bu_list	*p;

	while( BU_LIST_WHILE( p, bu_list, hd ) )  {
		BU_LIST_DEQUEUE( p );
		bu_free( (genptr_t)p, "struct bu_list" );
	}
}

/*
 *			B U _ L I S T _ P A R A L L E L _ A P P E N D
 *
 *  Simple parallel-safe routine for appending a data structure to the end
 *  of a bu_list doubly-linked list.
 *  Issues:
 *	Only one semaphore shared by all list heads.
 *	No portable way to notify waiting thread(s) that are sleeping
 */
void
bu_list_parallel_append(struct bu_list *headp, struct bu_list *itemp)
{
	bu_semaphore_acquire(BU_SEM_LISTS);
	BU_LIST_INSERT( headp, itemp );		/* insert before head = append */
	bu_semaphore_release(BU_SEM_LISTS);
}

/*
 *			B U _ L I S T _ P A R A L L E L _ D E Q U E U E
 *
 *  Simple parallel-safe routine for dequeueing one data structure from
 *  the head of a bu_list doubly-linked list.
 *  If the list is empty, wait until some other thread puts something on
 *  the list.
 *
 *  Issues:
 *	No portable way to not spin and burn CPU time while waiting
 *	for something to show up on the list.
 */
struct bu_list *
bu_list_parallel_dequeue(struct bu_list *headp)
{
	for(;;)  {
		register struct bu_list *p;

		bu_semaphore_acquire(BU_SEM_LISTS);
		p = BU_LIST_FIRST(bu_list, headp);
		if( BU_LIST_NOT_HEAD( p, headp ) )  {
			BU_LIST_DEQUEUE(p);
			bu_semaphore_release(BU_SEM_LISTS);
			return p;
		}
		bu_semaphore_release(BU_SEM_LISTS);

		/* List is empty, wait a moment and peek again */
#if (defined(sgi) && defined(mips)) || (defined(__sgi) && defined(__mips))
		sginap(1);
#endif
	}
	/* NOTREACHED */
}

/*
 *			B U _ C K _ L I S T
 *
 *  Generic bu_list doubly-linked list checker.
 */
void
bu_ck_list(const struct bu_list *hd, const char *str)
{
	register const struct bu_list	*cur;
	int	head_count = 0;

	cur = hd;
	do  {
		if( cur->magic == BU_LIST_HEAD_MAGIC )  head_count++;
		if( !cur->forw )  {
			bu_log("bu_ck_list(%s) cur=x%x, cur->forw=x%x, hd=x%x\n",
				str, cur, cur->forw, hd );
			bu_bomb("bu_ck_list() forw\n");
		}
		if( cur->forw->back != cur )  {
			bu_log("bu_ck_list(%s) cur=x%x, cur->forw=x%x, cur->forw->back=x%x, hd=x%x\n",
				str, cur, cur->forw, cur->forw->back, hd );
			bu_bomb("bu_ck_list() forw->back\n");
		}
		if( !cur->back )  {
			bu_log("bu_ck_list(%s) cur=x%x, cur->back=x%x, hd=x%x\n",
				str, cur, cur->back, hd );
			bu_bomb("bu_ck_list() back\n");
		}
		if( cur->back->forw != cur )  {
			bu_log("bu_ck_list(%s) cur=x%x, cur->back=x%x, cur->back->forw=x%x, hd=x%x\n",
				str, cur, cur->back, cur->back->forw, hd );
			bu_bomb("bu_ck_list() back->forw\n");
		}
		cur = cur->forw;
	} while( cur != hd );

	if( head_count != 1 )  {
		bu_log("bu_ck_list(%s) head_count = %d, hd=x%x\n", str, head_count, hd);
		bu_bomb("bu_ck_list() headless!\n");
	}
}

/*
 *			B U _ C K _ L I S T _ M A G I C
 *
 *  bu_list doubly-linked list checker which checks the magic number for
 *	all elements in the linked list
 */
void
bu_ck_list_magic(const struct bu_list *hd, const char *str, const long int magic)
{
	register const struct bu_list	*cur;
	int	head_count = 0;
	int	item = 0;

	cur = hd;
	do  {
		if( cur->magic == BU_LIST_HEAD_MAGIC )  {
			head_count++;
		} else if( cur->magic != magic ) {
			bu_log("bu_ck_list(%s) cur magic=(%s)x%x, cur->forw magic=(%s)x%x, hd magic=(%s)x%x, item=%d\n",
				str, bu_identify_magic(cur->magic), cur->magic,
				bu_identify_magic(cur->forw->magic), cur->forw->magic,
				bu_identify_magic(hd->magic), hd->magic,
				item);
			bu_bomb("bu_ck_list_magic() cur->magic\n");
		}

		if( !cur->forw )  {
			bu_log("bu_ck_list_magic(%s) cur=x%x, cur->forw=x%x, hd=x%x, item=%d\n",
				str, cur, cur->forw, hd, item );
			bu_bomb("bu_ck_list_magic() forw NULL\n");
		}
		if( cur->forw->back != cur )  {
			bu_log("bu_ck_list_magic(%s) cur=x%x, cur->forw=x%x, cur->forw->back=x%x, hd=x%x, item=%d\n",
				str, cur, cur->forw, cur->forw->back, hd, item );
			bu_log(" cur=%s, cur->forw=%s, cur->forw->back=%s\n",
				bu_identify_magic(cur->magic),
				bu_identify_magic(cur->forw->magic),
				bu_identify_magic(cur->forw->back->magic) );
			bu_bomb("bu_ck_list_magic() cur->forw->back != cur\n");
		}
		if( !cur->back )  {
			bu_log("bu_ck_list_magic(%s) cur=x%x, cur->back=x%x, hd=x%x, item=%d\n",
				str, cur, cur->back, hd, item );
			bu_bomb("bu_ck_list_magic() back NULL\n");
		}
		if( cur->back->forw != cur )  {
			bu_log("bu_ck_list_magic(%s) cur=x%x, cur->back=x%x, cur->back->forw=x%x, hd=x%x, item=%d\n",
				str, cur, cur->back, cur->back->forw, hd, item );
			bu_bomb("bu_ck_list_magic() cur->back->forw != cur\n");
		}
		cur = cur->forw;
		item++;
	} while( cur != hd );

	if( head_count != 1 )  {
		bu_log("bu_ck_list_magic(%s) head_count = %d, hd=x%x, items=%d\n", str, head_count, hd, item);
		bu_bomb("bu_ck_list_magic() headless!\n");
	}
}

/* XXX - apparently needed by muves */
struct bu_list *
bu_list_dequeue_next( struct bu_list *hp, struct bu_list *p )
{
	struct bu_list *p2;

	hp = hp;
	p2 = BU_LIST_NEXT( bu_list, p );
	BU_LIST_DEQUEUE( p2 );

	return( p2 );
}
@


1.17
log
@change conf.h to a wrapped config.h
@
text
@d18 1
a18 1
static const char libbu_list_RCSid[] = "@@(#)$Header: /cvs/brlcad/libbu/list.c,v 1.16 2004/04/05 07:46:16 morrison Exp $ (ARL)";
@


1.16
log
@merge of ansi-6-0-branch into HEAD
@
text
@d18 1
a18 1
static const char libbu_list_RCSid[] = "@@(#)$Header$ (ARL)";
d21 5
a25 1
#include "conf.h"
@


1.15
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d18 1
a18 1
static const char libbu_list_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/list.c,v 1.13 2001/08/09 21:19:45 jra Exp $ (ARL)";
d34 1
a34 1
bu_list_new()
d65 1
a65 2
bu_list_len( hd )
register const struct bu_list	*hd;
d82 1
a82 2
bu_list_reverse( hd )
register struct bu_list   *hd;
d107 1
a107 2
bu_list_free(hd)
struct bu_list	*hd;
d127 1
a127 3
bu_list_parallel_append( headp, itemp )
struct bu_list	*headp;
struct bu_list	*itemp;
d147 1
a147 2
bu_list_parallel_dequeue( headp )
struct bu_list	*headp;
d175 1
a175 3
bu_ck_list( hd, str )
const struct bu_list	*hd;
const char		*str;
d219 1
a219 4
bu_ck_list_magic( hd, str, magic )
const struct bu_list	*hd;
const char		*str;
const long		magic;
d272 1
d278 1
@


1.15.2.1
log
@Initial ANSIfication
@
text
@d18 1
a18 1
static const char libbu_list_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/list.c,v 1.15 2002/08/20 17:07:40 jra Exp $ (ARL)";
d34 1
a34 1
bu_list_new(void)
d65 2
a66 1
bu_list_len(register const struct bu_list *hd)
d83 2
a84 1
bu_list_reverse(register struct bu_list *hd)
d109 2
a110 1
bu_list_free(struct bu_list *hd)
d130 3
a132 1
bu_list_parallel_append(struct bu_list *headp, struct bu_list *itemp)
d152 2
a153 1
bu_list_parallel_dequeue(struct bu_list *headp)
d181 3
a183 1
bu_ck_list(const struct bu_list *hd, const char *str)
d227 4
a230 1
bu_ck_list_magic(const struct bu_list *hd, const char *str, const long int magic)
@


1.15.2.2
log
@more quelling of lots of warnings
@
text
@d18 1
a18 1
static const char libbu_list_RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libbu/list.c,v 1.15.2.1 2002/09/19 18:01:12 morrison Exp $ (ARL)";
a271 1
/* XXX - apparently needed by muves */
a276 1
	hp = hp;
@


1.14
log
@Converted from K&R to ANSI C - RFH
@
text
@d34 1
a34 1
bu_list_new(void)
d65 2
a66 1
bu_list_len(register const struct bu_list *hd)
d83 2
a84 1
bu_list_reverse(register struct bu_list *hd)
d109 2
a110 1
bu_list_free(struct bu_list *hd)
d130 3
a132 1
bu_list_parallel_append(struct bu_list *headp, struct bu_list *itemp)
d152 2
a153 1
bu_list_parallel_dequeue(struct bu_list *headp)
d181 3
a183 1
bu_ck_list(const struct bu_list *hd, const char *str)
d227 4
a230 1
bu_ck_list_magic(const struct bu_list *hd, const char *str, const long int magic)
@


1.13
log
@Added bu_list_dequeue_next() for MUVES
@
text
@d18 1
a18 1
static const char libbu_list_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/list.c,v 1.12 2001/08/07 14:36:37 jra Exp $ (ARL)";
d34 1
a34 1
bu_list_new()
d65 1
a65 2
bu_list_len( hd )
register const struct bu_list	*hd;
d82 1
a82 2
bu_list_reverse( hd )
register struct bu_list   *hd;
d107 1
a107 2
bu_list_free(hd)
struct bu_list	*hd;
d127 1
a127 3
bu_list_parallel_append( headp, itemp )
struct bu_list	*headp;
struct bu_list	*itemp;
d147 1
a147 2
bu_list_parallel_dequeue( headp )
struct bu_list	*headp;
d175 1
a175 3
bu_ck_list( hd, str )
const struct bu_list	*hd;
const char		*str;
d219 1
a219 4
bu_ck_list_magic( hd, str, magic )
const struct bu_list	*hd;
const char		*str;
const long		magic;
@


1.12
log
@More mods for MUVES Dq package
@
text
@d18 1
a18 1
static const char libbu_list_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/list.c,v 1.11 2001/08/06 20:49:19 jra Exp $ (ARL)";
d281 11
@


1.11
log
@Changes to suport replacement of MUVES Dq package
@
text
@d18 1
a18 1
static const char libbu_list_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/list.c,v 1.10 2001/04/20 22:29:06 morrison Exp $ (ARL)";
d42 15
@


1.10
log
@CONST to const
@
text
@d18 1
a18 1
static const char libbu_list_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/list.c,v 1.9 2000/10/30 21:29:15 mike Exp $ (ARL)";
d25 18
@


1.9
log
@
Changed bu_ck_list_magic() to provide an item count.
@
text
@d18 1
a18 1
static const char libbu_list_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/list.c,v 1.8 2000/10/27 01:26:36 mike Exp $ (ARL)";
d33 1
a33 1
register CONST struct bu_list	*hd;
d36 1
a36 1
	register CONST struct bu_list	*ep;
d149 2
a150 2
CONST struct bu_list	*hd;
CONST char		*str;
d152 1
a152 1
	register CONST struct bu_list	*cur;
d195 3
a197 3
CONST struct bu_list	*hd;
CONST char		*str;
CONST long		magic;
d199 1
a199 1
	register CONST struct bu_list	*cur;
@


1.8
log
@
Fixed routine name in error messags, made messages more descriptive.
@
text
@d18 1
a18 1
static const char libbu_list_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/list.c,v 1.7 2000/07/07 05:21:21 cjohnson Exp $ (ARL)";
d201 1
d208 1
a208 1
			bu_log("nmg_ck_list(%s) cur magic=(%s)x%x, cur->forw magic=(%s)x%x, hd magic=(%s)x%x\n",
d211 2
a212 1
				bu_identify_magic(hd->magic), hd->magic);
d217 2
a218 2
			bu_log("bu_ck_list_magic(%s) cur=x%x, cur->forw=x%x, hd=x%x\n",
				str, cur, cur->forw, hd );
d222 2
a223 2
			bu_log("bu_ck_list_magic(%s) cur=x%x, cur->forw=x%x, cur->forw->back=x%x, hd=x%x\n",
				str, cur, cur->forw, cur->forw->back, hd );
d231 2
a232 2
			bu_log("bu_ck_list_magic(%s) cur=x%x, cur->back=x%x, hd=x%x\n",
				str, cur, cur->back, hd );
d236 2
a237 2
			bu_log("bu_ck_list_magic(%s) cur=x%x, cur->back=x%x, cur->back->forw=x%x, hd=x%x\n",
				str, cur, cur->back, cur->back->forw, hd );
d241 1
d245 1
a245 1
		bu_log("bu_ck_list_magic(%s) head_count = %d, hd=x%x\n", str, head_count, hd);
@


1.7
log
@LINT plus minor bug fix in bu_tcl.c
@
text
@d18 1
a18 1
static const char libbu_list_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/list.c,v 1.6 2000/03/29 01:41:55 mike Exp $ (ARL)";
d211 1
a211 1
			bu_bomb("nmg_ck_list_magic() cur->magic\n");
d215 1
a215 1
			bu_log("nmg_ck_list_magic(%s) cur=x%x, cur->forw=x%x, hd=x%x\n",
d217 1
a217 1
			bu_bomb("nmg_ck_list_magic() forw\n");
d220 1
a220 1
			bu_log("nmg_ck_list_magic(%s) cur=x%x, cur->forw=x%x, cur->forw->back=x%x, hd=x%x\n",
d226 1
a226 1
			bu_bomb("nmg_ck_list_magic() forw->back\n");
d229 1
a229 1
			bu_log("nmg_ck_list_magic(%s) cur=x%x, cur->back=x%x, hd=x%x\n",
d231 1
a231 1
			bu_bomb("nmg_ck_list_magic() back\n");
d234 1
a234 1
			bu_log("nmg_ck_list_magic(%s) cur=x%x, cur->back=x%x, cur->back->forw=x%x, hd=x%x\n",
d236 1
a236 1
			bu_bomb("nmg_ck_list_magic() back->forw\n");
d242 2
a243 2
		bu_log("nmg_ck_list_magic(%s) head_count = %d, hd=x%x\n", str, head_count, hd);
		bu_bomb("nmg_ck_list_magic() headless!\n");
@


1.6
log
@
Renamed nmg_ck_list* as bu_ck_list* routines
@
text
@d18 1
a18 1
static char libbu_list_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/list.c,v 1.5 2000/03/28 18:55:08 mike Exp $ (ARL)";
@


1.5
log
@
Put libbu_filename_ prefixes on RCSid variables.
@
text
@d18 1
a18 1
static char libbu_list_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/list.c,v 1.4 1998/11/05 20:57:52 mike Exp $ (ARL)";
d140 105
@


1.4
log
@Added bu_list_parallel_append and bu_list_parallel_dequeue() for
Ron Bower's parallel MUVES work.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/list.c,v 1.3 1997/04/01 05:42:31 mike Exp $ (ARL)";
@


1.3
log
@Added bu_list_free()
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbu/RCS/list.c,v 1.2 1996/12/18 20:50:49 jra Exp mike $ (ARL)";
d85 55
@


1.2
log
@A substitution of BU_LIST for RT_LIST changed BU_LIST_INSERT_LIST to BU_LIST_INSEBU_LIST!!
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbu/RCS/list.c,v 1.1 1996/08/31 10:40:04 mike Exp jra $ (ARL)";
d64 20
@


1.1
log
@Initial revision
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d59 1
a59 1
	BU_LIST_INSEBU_LIST( &tmp_hd, hd );
@
