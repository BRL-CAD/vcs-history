head	11.22;
access;
symbols
	ansi-20040405-merged:11.19.2.2
	postmerge-20040405-ansi:11.20
	premerge-20040404-ansi:11.19
	postmerge-autoconf:11.19
	autoconf-freeze:11.19
	premerge-autoconf:11.19
	ansi-20040316-freeze:11.19.2.1
	postmerge-20040315-windows:11.19
	premerge-20040315-windows:11.19
	windows-20040315-freeze:11.19
	autoconf-20031203:11.19
	autoconf-20031202:11.19
	autoconf-branch:11.19.0.10
	phong-branch:11.19.0.8
	photonmap-branch:11.19.0.6
	rel-6-1-DP:11.19
	windows-branch:11.19.0.4
	rel-6-0-2:11.17
	ansi-branch:11.19.0.2
	rel-6-0-1-branch:11.17.0.2
	hartley-6-0-post:11.18
	hartley-6-0-pre:11.17
	rel-6-0-1:11.17
	rel-6-0:11.17
	rel-5-4:11.7.2.1
	offsite-5-3-pre:11.12
	rel-5-3:11.7.2.1
	rel-5-2:11.7
	rel-5-1-branch:11.7.0.2
	rel-5-1:11.7
	rel-5-0:11.5
	rel-5-0-beta:11.5
	rel-4-5:11.4
	ctj-4-5-post:11.4
	ctj-4-5-pre:11.4
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.22
date	2004.05.21.18.06.23;	author morrison;	state dead;
branches;
next	11.21;

11.21
date	2004.05.10.15.30.44;	author erikg;	state Exp;
branches;
next	11.20;

11.20
date	2004.04.05.07.46.16;	author morrison;	state Exp;
branches;
next	11.19;

11.19
date	2002.08.20.17.07.40;	author jra;	state Exp;
branches
	11.19.2.1;
next	11.18;

11.18
date	2002.08.15.20.54.51;	author hartley;	state Exp;
branches;
next	11.17;

11.17
date	2002.02.22.02.06.16;	author morrison;	state Exp;
branches;
next	11.16;

11.16
date	2001.11.19.19.34.47;	author butler;	state Exp;
branches;
next	11.15;

11.15
date	2001.08.08.20.33.36;	author butler;	state Exp;
branches;
next	11.14;

11.14
date	2001.04.05.19.35.30;	author morrison;	state Exp;
branches;
next	11.13;

11.13
date	2001.03.19.22.19.45;	author butler;	state Exp;
branches;
next	11.12;

11.12
date	2000.08.21.02.18.52;	author butler;	state Exp;
branches;
next	11.11;

11.11
date	2000.07.24.18.37.08;	author butler;	state Exp;
branches;
next	11.10;

11.10
date	2000.07.07.05.21.20;	author cjohnson;	state Exp;
branches;
next	11.9;

11.9
date	2000.07.05.22.10.28;	author cjohnson;	state Exp;
branches;
next	11.8;

11.8
date	2000.06.30.20.11.18;	author butler;	state Exp;
branches;
next	11.7;

11.7
date	2000.03.28.19.29.26;	author mike;	state Exp;
branches
	11.7.2.1;
next	11.6;

11.6
date	2000.03.28.18.55.07;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	99.01.15.05.49.21;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	96.07.12.12.10.21;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.05.16.02.09.13;	author butler;	state Exp;
branches;
next	11.2;

11.2
date	95.01.07.08.47.33;	author cjohnson;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.58.54;	author mike;	state Rel4_4;
branches;
next	10.6;

10.6
date	94.12.27.18.56.28;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.12.27.18.18.33;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.12.07.20.36.12;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.11.04.07.02.58;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.10.20.22.47;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.41.10;	author mike;	state Rel4_0;
branches;
next	1.18;

1.18
date	91.07.26.18.09.39;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	91.07.25.03.15.26;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	91.07.02.22.40.19;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	91.07.02.02.55.04;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	91.06.29.22.31.32;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	91.06.29.21.26.17;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	91.06.26.14.05.49;	author cjohnson;	state Exp;
branches;
next	1.11;

1.11
date	91.06.25.06.28.53;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	91.06.25.07.19.21;	author cjohnson;	state Exp;
branches;
next	1.9;

1.9
date	91.06.25.05.57.50;	author cjohnson;	state Exp;
branches;
next	1.8;

1.8
date	91.06.25.02.41.10;	author cjohnson;	state Exp;
branches;
next	1.7;

1.7
date	91.05.25.07.34.04;	author cjohnson;	state Exp;
branches;
next	1.6;

1.6
date	91.05.25.04.28.17;	author cjohnson;	state Exp;
branches;
next	1.5;

1.5
date	91.05.18.00.15.09;	author cjohnson;	state Exp;
branches;
next	1.4;

1.4
date	91.04.26.20.39.11;	author cjohnson;	state Exp;
branches;
next	1.3;

1.3
date	91.04.09.20.21.37;	author cjohnson;	state Exp;
branches;
next	1.2;

1.2
date	91.04.04.16.04.05;	author cjohnson;	state Exp;
branches;
next	1.1;

1.1
date	91.04.04.13.52.44;	author cjohnson;	state Exp;
branches;
next	;

11.7.2.1
date	2001.02.22.00.05.57;	author butler;	state Exp;
branches;
next	;

11.19.2.1
date	2002.09.19.18.01.12;	author morrison;	state Exp;
branches;
next	11.19.2.2;

11.19.2.2
date	2004.04.05.00.50.06;	author morrison;	state Exp;
branches;
next	;


desc
@routines to convert from one data format to another.
integer to double, 8bit to 32 bit et so forth.
@


11.22
log
@moved to src/
@
text
@/*
 *			C O N V E R T . C
 *
 * Routines to translate data formats.  The data formats are:
 *
 *	Host/Network		is the data in host format or local format
 *	signed/unsigned		Is the data signed?
 *	char/short/int/long/double
 *				Is the data 8bits, 16bits, 32bits, 64bits
 *				or a double?
 *
 * The method of conversion is to convert up to double then back down the
 * the expected output format.
 *
 * Author -
 *	Christopher T. Johnson
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
 */
#ifndef lint
static const char libbu_convert_RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libbu/convert.c,v 11.21 2004/05/10 15:30:44 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <ctype.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "machine.h"
#include "vmath.h"
#include "bu.h"


/* bu_cv_cookie	Set's a bit vector after parsing an input string.
 *
 * Set up the conversion tables/flags for vert.
 *
 * Entry:
 *	in	format description.
 *
 * Exit:
 *	returns a 32 bit vector.
 *
 * Format description:
 *	[channels][h|n][s|u] c|s|i|l|d|8|16|32|64 [N|C|L]
 *
 * channels must be null or 1
 * Host | Network
 * signed | unsigned
 * char | short | integer | long | double | number of bits of integer
 * Normalize | Clip | low-order
 */
int
bu_cv_cookie(char *in)			/* input format */
{
	char *p;
	int collector;
	int result = 0x0000;	/* zero/one channel, Net, unsigned, char, clip */
	
	if (!in) return 0;
	if (!*in) return 0;
	
	
	collector = 0;
	for (p=in; *p && isdigit(*p); ++p) collector = collector*10 + (*p - '0');
	if (collector > 255) {
		collector = 255;
	} else if (collector == 0) {
		collector = 1;
	}
	result = collector;	/* number of channels set '|=' */
	
	if (!*p) return 0;
	
	if (*p == 'h') {
		result |= CV_HOST_MASK;
		++p;
	} else if (*p == 'n') {
		++p;
	}
	
	if (!*p) return 0;
	if (*p == 'u') {
		++p;
	} else if (*p == 's') {	/* could be 'signed' or 'short' */
		char *p2;
		p2 = p+1;
		if (*p2 && (islower(*p2) || isdigit(*p2))) {
			result |= CV_SIGNED_MASK;
			++p;
		}
	}
	
	if (!*p) return 0;
	switch (*p) {
	case 'c':
	case '8':
		result |= CV_8;
		break;
	case '1':
		p++;
		if (*p != '6') return 0;
		/* fall through */
	case 's':
		result |= CV_16;
		break;
	case '3':
		p++;
		if (*p != '2') return 0;
		/* fall through */
	case 'i':
		result |= CV_32;
		break;
	case '6':
		p++;
		if (*p != '4') return 0;
		/* fall through */
	case 'l':
		result |= CV_64;
		break;
	case 'd':
		result |= CV_D;
		break;
	default:
		return 0;
	}
	p++;
	
	if (!*p) return(result);
	if (*p == 'N') {
		result |= CV_NORMAL;
	} else if (*p == 'C') {
		result |= CV_CLIP;
	} else if (*p == 'L') {
		result |= CV_LIT;
	} else {
		return 0;
	}
	return(result);
}

void
bu_cv_fmt_cookie( char * buf, size_t buflen, int cookie )
{
	register char *cp = buf;
	unsigned int	len;
	
	if( buflen == 0 )	{
		fprintf( stderr, "bu_cv_pr_cookie:  call me with a bigger buffer\n");
		return;
	}
	buflen--;
	if( cookie == 0 )  {
		strncpy( cp, "bogus!", buflen );
		return;
	}
	
	sprintf( cp, "%d", cookie & CV_CHANNEL_MASK );
	len = strlen(cp);
	cp += len;
	if( buflen < len )
	{
		fprintf( stderr, "bu_cv_pr_cookie:  call me with a bigger buffer\n");
		return;
	}
	buflen -= len;
	
	if( buflen == 0 )	{
		fprintf( stderr, "bu_cv_pr_cookie:  call me with a bigger buffer\n");
		return;
	}
	if( cookie & CV_HOST_MASK )  {
		*cp++ = 'h';
		buflen--;
	} else {
		*cp++ = 'n';
		buflen--;
	}
	
	if( buflen == 0 )	{
		fprintf( stderr, "bu_cv_pr_cookie:  call me with a bigger buffer\n");
		return;
	}
	if( cookie & CV_SIGNED_MASK )  {
		*cp++ = 's';
		buflen--;
	} else {
		*cp++ = 'u';
		buflen--;
	}
	
	if( buflen == 0 )	{
		fprintf( stderr, "bu_cv_pr_cookie:  call me with a bigger buffer\n");
		return;
	}
	switch( cookie & CV_TYPE_MASK )  {
	case CV_8:
		*cp++ = '8';
		buflen--;
		break;
	case CV_16:
		strncpy( cp, "16", buflen );
		cp += 2;
		buflen -= 2;
		break;
	case CV_32:
		strncpy( cp, "32", buflen );
		cp += 2;
		buflen -= 2;
		break;
	case CV_64:
		strncpy( cp, "64", buflen );
		cp += 2;
		buflen -= 2;
		break;
	case CV_D:
		*cp++ = 'd';
		buflen -= 1;
		break;
	default:
		*cp++ = '?';
		buflen -= 1;
		break;
	}
	
	if( buflen == 0 )	{
		fprintf( stderr, "bu_cv_pr_cookie:  call me with a bigger buffer\n");
		return;
	}
	switch( cookie & CV_CONVERT_MASK )  {
	case CV_CLIP:
		*cp++ = 'C';
		buflen -= 1;
		break;
	case CV_NORMAL:
		*cp++ = 'N';
		buflen -= 1;
		break;
	case CV_LIT:
		*cp++ = 'L';
		buflen -= 1;
		break;
	default:
		*cp++ = 'X';
		buflen -= 1;
		break;
	}
	*cp = '\0';
}

void
bu_cv_pr_cookie( char *title, int cookie )
{
	char	buf[128];
	
	bu_cv_fmt_cookie( buf, sizeof(buf), cookie );
	fprintf( stderr, "%s cookie '%s' (x%x)\n", title, buf, cookie );
}

/* cv - convert from one format to another.
 *
 * Entry:
 *	in	input pointer
 *	out	output pointer
 *	count	number of entries to convert.
 *	size	size of output buffer.
 *	infmt	input format
 *	outfmt	output format
 *
 */
int
cv(genptr_t out, char *outfmt, size_t size, genptr_t in, char *infmt, int count)
{
	int	incookie, outcookie;
	incookie = bu_cv_cookie(infmt);
	outcookie = bu_cv_cookie(outfmt);
	return(bu_cv_w_cookie(out, outcookie, size, in, incookie, count));
}

/*
 *			C V _ O P T I M I Z E
 *
 *  It is always more efficient to handle host data, rather than network.
 *  If host and network formats are the same, and the request was for
 *  network format, modify the cookie to request host format.
 */
int
bu_cv_optimize(register int cookie)
{
	static int Indian = IND_NOTSET;
	int	fmt;

	if( cookie & CV_HOST_MASK )
		return cookie;		/* already in most efficient form */
	
	/* This is a network format request */
	fmt  =  cookie & CV_TYPE_MASK;
	
	/* Run time check:  which kind of integers does this machine have? */
	if (Indian == IND_NOTSET) {
		size_t soli = sizeof(long int);
		unsigned long int	testval;
		register int		i;
		for (i=0; i<4; i++) {
			((char *)&testval)[i] = i+1;
		}
		
		if (soli == 8) {
			Indian = IND_CRAY;	/* is this good enough? */
			if ( ( (testval >> 31) >> 1 ) == 0x01020304) { 
				Indian = IND_BIG; /* XXX 64bit */
			} else if (testval == 0x04030201) {
				Indian = IND_LITTLE;	/* 64 bit */
			} else {
				bu_bomb("bu_cv_optimize: can not tell indian of host.\n");
			}
		} else if (testval == 0x01020304) {
			Indian = IND_BIG;
		} else if (testval == 0x04030201) {
			Indian = IND_LITTLE;
		} else if (testval == 0x02010403) {
			Indian = IND_ILL;
		}
	}
	
	switch(fmt)  {
	case CV_D:
#		if IEEE_FLOAT
			cookie |= CV_HOST_MASK;	/* host uses network fmt */
#		endif
		return cookie;
	case CV_8:
		return cookie | CV_HOST_MASK;	/* bytes already host format */
	case CV_16:
	case CV_32:
	case CV_64:
		/* host is big-endian, so is network */
		if( Indian == IND_BIG )
			cookie |= CV_HOST_MASK;
		return cookie;
	}
	return 0;			/* ERROR */
}

/*
 *			C V _ I T E M L E N
 *
 *  Returns the number of bytes each "item" of type "cookie" occupies.
 */
int
bu_cv_itemlen(register int cookie)
{
	register int	fmt = (cookie & CV_TYPE_MASK) >> CV_TYPE_SHIFT;
	static int host_size_table[8] = {0, sizeof(char),
																	 sizeof(short), sizeof(int),
																	 sizeof(long int), sizeof(double)};
	static int net_size_table[8] = {0,1,2,4,8,8};

	if( cookie & CV_HOST_MASK )
		return host_size_table[fmt];
	return net_size_table[fmt];
}


/*	bu_cv_ntohss	Network TO Host Signed Short
 *
 * It is assumed that this routine will only be called if there is
 * real work to do.  Ntohs does no checking to see if it is reasonable
 * to do any conversions.
 *
 * Entry:
 *	in	generic pointer for input.
 *	count	number of shorts to be generated.
 *	out	short pointer for output
 *	size	number of bytes of space reserved for out.
 *
 * Exit:
 *	returns	number of conversions done.
 *
 * Calls:
 *	none.
 *
 * Method:
 *	Straight-forward.
 */
int
bu_cv_ntohss(register short int *out, size_t size, register genptr_t in, int count)
{
	int limit;
	register int i;
	
	limit = size / sizeof(signed short);
	if (limit < count) count = limit;
	
	for (i=0; i<count; i++) {
		*out++ = ((signed char *)in)[0] << 8 | ((unsigned char *)in)[1];
		/* XXX This needs sign extension here for the case of
		 * XXX a negative 2-byte input on a 4 or 8 byte machine.
		 * XXX The "signed char" trick isn't enough.
		 * XXX Use your Cyber trick w/magic numbers or something.
		 */
		in = ((char *)in) + 2;
	}
	return(count);
}
int
bu_cv_ntohus(register short unsigned int *out, size_t size, register genptr_t in, int count)
{
	int limit;
	register int i;
	
	limit = size / sizeof(unsigned short);
	if (limit < count) count = limit;
	
	for (i=0; i<count; i++) {
		*out++ = ((unsigned char *)in)[0]<<8 |
			((unsigned char *)in)[1];
		in = ((char *)in) + 2;
	}
	return(count);
}
int
bu_cv_ntohsl(register long int *out, size_t size, register genptr_t in, int count)
{
	int limit;
	register int i;

	limit = size / sizeof(signed long int);
	if (limit < count) count = limit;

	for (i=0; i<count; i++) {
		*out++ = ((signed char *)in)[0] << 24 |
		    ((unsigned char *)in)[1] << 16 | 
		    ((unsigned char *)in)[2] << 8  |
		    ((unsigned char *)in)[3];
		/* XXX Sign extension here */
		in = ((char *)in) + 4;
	}

	return(count);
}
int
bu_cv_ntohul(register long unsigned int *out, size_t size, register genptr_t in, int count)
{
	int limit;
	register int i;
	
	limit = size / sizeof(unsigned long int);
	if (limit < count) count = limit;

	for (i=0; i<count; i++) {
		*out++ = ((unsigned char *)in)[0] << 24 |
			((unsigned char *)in)[1] << 16 |
		    ((unsigned char *)in)[2] <<  8 |
			((unsigned char *)in)[3];
		in = ((char *)in) + 4;
	}
	return(count);
}

/*****/
int
bu_cv_htonss(genptr_t out, size_t size, register short int *in, int count)
{
	int		limit;
	register int	i;
	register unsigned char *cp = (unsigned char *)out;
	register int	val;

	limit = size / 2;
	if( count > limit )  count = limit;
	
	for (i=0; i<count; i++) {
		*cp++ = (val = *in++)>>8;
		*cp++ = val;
	}
	return(count);
}
int
bu_cv_htonus(genptr_t out, size_t size, register short unsigned int *in, int count)
{
	int		limit;
	register int	i;
	register unsigned char *cp = (unsigned char *)out;
	register int	val;

	limit = size / 2;
	if( count > limit )  count = limit;

	for (i=0; i<count; i++) {
		*cp++ = (val = *in++)>>8;
		*cp++ = val;
	}
	return(count);
}
int
bu_cv_htonsl(genptr_t out, size_t size, register long int *in, int count)
{
	int		limit;
	register int	i;
	register unsigned char *cp = (unsigned char *)out;
	register long	val;
	
	limit = size / 4;
	if( count > limit )  count = limit;
	
	for (i=0; i<count; i++) {
		*cp++ = (val = *in++)>>24;
		*cp++ = val>>16;
		*cp++ = val>> 8;
		*cp++ = val;
	}
	return(count);
}
int
bu_cv_htonul(genptr_t out, size_t size, register long unsigned int *in, int count)
{
	int		limit;
	register int	i;
	register unsigned char *cp = (unsigned char *)out;
	register long	val;
	
	limit = size / 4;
	if( count > limit ) {
		count = limit;
	}

	for (i=0; i<count; i++) {
		*cp++ = (val = *in++)>>24;
		*cp++ = val>>16;
		*cp++ = val>> 8;
		*cp++ = val;
	}
	return(count);
}


/* bu_cv_w_cookie - convert with cookie
 *
 * Entry:
 *	in		input pointer
 *	incookie	input format cookie.
 *	count		number of entries to convert.
 *	out		output pointer.
 *	outcookie	output format cookie.
 *	size		size of output buffer in bytes;
 *
 *
 * A worst case would be:	ns16 on vax to ns32
 *	ns16 	-> hs16
 *		-> hd
 *		-> hs32
 *		-> ns32
 * The worst case is probably the easiest to deal with because all steps are
 * done.  The more difficult cases are when only a subset of steps need to
 * be done.
 *
 * Method:
 *	HOSTDBL defined as true or false
 *	if ! hostother then
 *		hostother = (Indian == IND_BIG) ? SAME : DIFFERENT;
 *	fi
 *	if (infmt == double) then
 *		if (HOSTDBL == SAME) {
 *			inIsHost = host;
 *		fi
 *	else
 *		if (hostother == SAME) {
 *			inIsHost = host;
 *		fi
 *	fi
 *	if (outfmt == double) then
 *		if (HOSTDBL == SAME) {
 *			outIsHost == host;
 *	else
 *		if (hostother == SAME) {
 *			outIsHost = host;
 *		fi
 *	fi
 *	if (infmt == outfmt) {
 *		if (inIsHost == outIsHost) {
 *			copy(in,out)
 *			exit
 *		else if (inIsHost == net) {
 *			ntoh?(in,out);
 *			exit
 *		else
 *			hton?(in,out);
 *			exit
 *		fi
 *	fi
 *
 *	while not done {
 *		from = in;
 *
 *		if (inIsHost == net) {
 *			ntoh?(from,t1);
 *			from = t1;
 *		fi
 *		if (infmt != double ) {
 *			if (outIsHost == host) {
 *				to = out;
 *			else
 *				to = t2;
 *			fi
 *			castdbl(from,to);
 *			from = to;
 *		fi
 *
 *		if (outfmt == double ) {
 *			if (outIsHost == net) {
 *				hton?(from,out);
 *			fi
 *		else 
 *			if (outIsHost == host) {
 *				dblcast(from,out);
 *			else
 *				dblcast(from,t3);
 *				hton?(t3,out);
 *			fi
 *		fi
 *	done
 */
int
bu_cv_w_cookie(genptr_t out, int outcookie, size_t size, genptr_t in,  int incookie,  int	count)
{
	int	work_count = 4096;
	int	number_done = 0;
	int	inIsHost,outIsHost,infmt,outfmt,insize,outsize;
	size_t	bufsize;
	genptr_t	t1,t2,t3;
	genptr_t	from;
	genptr_t	to;
	genptr_t	hold;
	register int i;

	/*
	 * Work_count is the size of the working buffer.  If count is smaller
	 * than the default work_count (4096) use the smaller number.
	 */

	if (work_count > count) 
		work_count = count;

	incookie = bu_cv_optimize( incookie );
	outcookie = bu_cv_optimize( outcookie );
	
	/*
	 * break out the conversion code and the format code.
	 * Conversion is net<-->host.
	 * Format is 8/16/32/64/D casting.
	 */
	inIsHost = incookie & CV_HOST_MASK;	/* not zero if host */
	outIsHost= outcookie& CV_HOST_MASK;
	infmt  =  incookie & CV_TYPE_MASK;
	outfmt = outcookie & CV_TYPE_MASK;
	/*
	 * Find the number of bytes required for one item of each kind.
	 */
	outsize = bu_cv_itemlen( outcookie );
	insize = bu_cv_itemlen( incookie );

	/*
	 * If the input format is the same as the output format then the
	 * most that has to be done is a host to net or net to host conversion.
	 */
	if (infmt == outfmt) {
		
		/*
		 * Input format is the same as output format, do we need to do a
		 * host/net conversion?
		 */
		if (inIsHost == outIsHost) {
			
			/*
			 * No conversion required.
			 * Check the amount of space remaining before doing the bcopy.
			 */
			if ((unsigned int)count * outsize > size) {
		    number_done = size / outsize;
			} else {
		    number_done = count;
			}
			
			/*
			 * This is the simplest case, binary copy and out.
			 */
			(void) bcopy((genptr_t) in, (genptr_t) out, (size_t)number_done * outsize);
			return(number_done);
			
			/*
			 * Well it's still the same format but the conversion are different.
			 * Only one of the *vert variables can be HOST therefore if
			 * inIsHost != HOST then outIsHost must be host format.
			 */
			
		} else if (inIsHost != CV_HOST_MASK) { /* net format */
			switch(incookie & (CV_SIGNED_MASK | CV_TYPE_MASK)) {
			case CV_SIGNED_MASK | CV_16:
		    return(	bu_cv_ntohss((signed short *)out, size, in, count));
			case CV_16:
		    return( bu_cv_ntohus((unsigned short *)out, size, in, count));
			case CV_SIGNED_MASK | CV_32:
		    return( bu_cv_ntohsl((signed long *)out, size, in, count));
			case CV_32:
		    return( bu_cv_ntohul((unsigned long *)out, size, in, count));
			case CV_D:
		    (void) ntohd((unsigned char *)out, (unsigned char *)in, count);
		    return(count);
			}
			
			/*
			 * Since inIsHost != outIsHost and inIsHost == HOST then outIsHost must
			 * be in net format.  call the correct subroutine to do the conversion.
			 */
		} else {
			switch(incookie & (CV_SIGNED_MASK | CV_TYPE_MASK)) {
			case CV_SIGNED_MASK | CV_16:
		    return(	bu_cv_htonss(out, size, (short *)in, count));
			case CV_16:
		    return( bu_cv_htonus(out, size, (unsigned short *)in, count));
			case CV_SIGNED_MASK | CV_32:
		    return( bu_cv_htonsl(out, size, (long *)in, count));
			case CV_32:
		    return( bu_cv_htonul(out, size, (unsigned long *)in, count));
			case CV_D:
		    (void) htond((unsigned char *)out, (unsigned char *)in, count);
		    return(count);
			}
		}
	}
	/*
	 * If we get to this point then the input format is known to be
	 * of a diffrent type than the output format.  This will require
	 * a cast to, from or to and from double.
	 *
	 * Because the number of steps is not known initially, we get
	 * three working buffers.  The size of a double is the largest of
	 * any of the sizes we may be dealing with.
	 */
	
	bufsize = work_count * sizeof(double);
	t1 = (genptr_t) bu_malloc(bufsize, "vert.c: t1");
	t2 = (genptr_t) bu_malloc(bufsize, "vert.c: t2");
	t3 = (genptr_t) bu_malloc(bufsize, "vert.c: t3");
	
	/*
	 * From here on we will be working on a chunk of process at a time.
	 */
	while ( size >= (unsigned int)outsize  && number_done < count) {
		int remaining;
		
		/*
		 * Size is the number of bytes that the caller said was available.
		 * We need the check to make sure that we will not convert too many
		 * entries, overflowing the output buffer.
		 */
		
		/*
		 * Get number of full entries that can be converted
		 */
		remaining = size / outsize;
		
		/*
		 * If number of entries that would fit in the output buffer is
		 * larger than the number of entries left to convert(based on
		 * count and number done), set remaining to request count minus
		 * the number of conversions already completed.
		 */
		if (remaining > count - number_done) {
			remaining = count - number_done;
		}
		/*
		 * If we are in the last chunk, set the work count to take up
		 * the slack.
		 */
		if (remaining < work_count) work_count = remaining;
		
		/*
		 * All input at any stage will come from the "from" pointer.  We
		 * start with the from pointer pointing to the input buffer.
		 */
		from = in;
		
		/*
		 * We will be processing work_count entries of insize bytes each, so
		 * we set the in pointer to be ready for the next time through the loop.
		 */
		in = ((char *) in) + work_count * insize;
		
		/*
		 * If the input is in net format convert it host format.
		 * Because we know that the input format is not equal to the output
		 * this means that there will be at least two conversions taking place
		 * if the input is in net format.  (from net to host then at least one cast)
		 */
		if (inIsHost != CV_HOST_MASK) { /* net format */
			switch(incookie & (CV_SIGNED_MASK | CV_TYPE_MASK)) {
			case CV_SIGNED_MASK | CV_16:
				(void) bu_cv_ntohss((short *)t1, bufsize , from, work_count);
				break;
			case CV_16:
				(void) bu_cv_ntohus((unsigned short *)t1, bufsize , from, work_count);
				break;
			case CV_SIGNED_MASK | CV_32:
				(void) bu_cv_ntohsl((long *)t1, bufsize , from, work_count);
				break;
			case CV_32:
				(void) bu_cv_ntohul((unsigned long *)t1, bufsize , from, work_count);
				break;
			case CV_D:
				(void) ntohd((unsigned char *)t1, (unsigned char *)from, work_count);
				break;
			}
			/*
			 * Point the "from" pointer to the host format.
			 */
			from = t1;
		}
		
		
		/*
		 * "From" is a pointer to a HOST format buffer.
		 */
		
		/*
		 * If the input format is not double then there must be a cast to
		 * double.
		 */
		if (infmt != CV_D) {
			
			/*
			 * if the output conversion is HOST and output format is DOUBLE
			 * then this will be the last step.
			 */
			if (outIsHost == CV_HOST_MASK && outfmt == CV_D) {
		    to = out;
			} else {
		    to = t2;
			}
			
			hold = to;
			/*
			 * Cast the input format to double.
			 */
			switch(incookie & (CV_SIGNED_MASK | CV_TYPE_MASK)) {
			case CV_SIGNED_MASK | CV_8:
		    for (i=0; i< work_count; i++) {
					*((double *)to) = *((signed char *)from);
					to = (genptr_t)(((double *)to) + 1);
					from = ((char *)from) + 1;
		    }
		    break;
			case CV_8:
		    for(i=0; i < work_count; i++) {
					*((double *)to) = *((unsigned char *)from);
					to = (genptr_t)(((double *)to) + 1);
					from = (genptr_t)(((unsigned char *)from) + 1);
		    }
		    break;
			case CV_SIGNED_MASK | CV_16:
		    for (i=0; i < work_count; i++) {
					*((double *)to) = *((signed short *)from);
					to = (genptr_t)(((double *)to) + 1);
					from = (genptr_t)(((signed short *)from) + 1);
		    }
		    break;
			case CV_16:
		    for (i=0; i < work_count; i++) {
					*((double *)to) = *((unsigned short *)from);
					to = (genptr_t)(((double *)to) + 1);
					from = (genptr_t)(((unsigned short *)from) + 1);
		    }
		    break;
			case CV_SIGNED_MASK | CV_32:
		    for (i=0; i < work_count; i++) {
					*((double *)to) = *((signed long int *)from);
					to = (genptr_t)(((double *)to) + 1);
					from =  (genptr_t)(((signed long int *)from) + 1);
		    }
		    break;
			case CV_32:
		    for (i=0; i < work_count; i++) {
					*((double *)to) = *((unsigned long int *) from);
					to = (genptr_t)(((double *)to) + 1);
					from = (genptr_t)(((unsigned long int *)from) + 1);
		    }
		    break;
			default:
				fprintf( stderr, "Unimplemented input format\n");
				break;
			}
			from = hold;
		}
		
		if (outfmt != CV_D) {
			/*
			 * The input point is now pointing to a double in host format.  If the
			 * output is also in host format then the next conversion will be
			 * the last conversion, set the destination to reflect this.
			 */
			
			if (outIsHost == CV_HOST_MASK) {
		    to = out;
			} else {
		    to = t3;
			}
			
			/*
			 * The ouput format is something other than DOUBLE (tested for earlier),
			 * do a cast from double to requested format.
			 */
			hold = to;
			
			switch (outcookie & (CV_SIGNED_MASK | CV_TYPE_MASK)) {
			case CV_SIGNED_MASK | CV_8:
		    for (i=0; i<work_count; i++) {
					*((signed char *)to) = *((double *)from);
					to = (genptr_t)(((signed char *)to) + 1);
					from = (genptr_t)(((double *)from) + 1);
		    }
		    break;
			case CV_8:
		    for (i=0; i<work_count; i++) {
					*((unsigned char *)to) =
						(unsigned char)(*((double *)from));
					to = (genptr_t)(((unsigned char *)to) + 1);
					from = (genptr_t)(((double *)from) + 1);
		    }
		    break;
			case CV_SIGNED_MASK | CV_16:
		    for (i=0; i<work_count; i++) {
					*((signed short int *)to) =
						*((double *)from);
					to = (genptr_t)(((signed short int *)to) + 1);
					from = (genptr_t)(((double *)from) + 1);
		    }
		    break;
			case CV_16:
		    for (i=0; i<work_count; i++) {
					*((unsigned short int *)to) =
						*((double *)from);
					to = (genptr_t)(((unsigned short int *)to) + 1);
					from = (genptr_t)(((double *)from) + 1);
		    }
		    break;
			case CV_SIGNED_MASK | CV_32:
		    for (i=0; i<work_count; i++) {
					*((signed long int *)to) =
						*((double *)from);
					to = (genptr_t)(((signed long int *)to) + 1);
					from = (genptr_t)(((double *)from) + 1);
		    }
		    break;
			case CV_32:
		    for (i=0; i<work_count; i++) {
					*((unsigned long int *)to) =
						*((double *)from);
					to = (genptr_t)(((unsigned long int *)to) + 1);
					from = (genptr_t)(((double *)from) + 1);
		    }
		    break;
			default:
				fprintf( stderr, "Unimplemented output format\n");
				break;
				
			}
			from = hold;
			/*
			 * The input is now pointing to a host formated buffer of the requested
			 * output format.
			 */
			
			/*
			 * If the output conversion is network then do a host to net call
			 * for either 16 or 32 bit values using Host TO Network All Short | Long
			 */
			if (outIsHost != CV_HOST_MASK) {
				switch (outfmt) {
				case CV_D:
					(void) htond((unsigned char *)out,
											 (unsigned char *)from,
											 work_count);
					break;
				case CV_16 | CV_SIGNED_MASK:
					(void) bu_cv_htonss(out, bufsize, from,
															work_count);
					break;
				case CV_16:
					(void) bu_cv_htonus(out, bufsize, from,
															work_count);
					break;
				case CV_32 | CV_SIGNED_MASK:
					(void) bu_cv_htonsl(out, bufsize, from,
															work_count);
					break;
				case CV_32:
					(void) bu_cv_htonul(out, bufsize, from,
															work_count);
					break;
				}
			}
			
		}
		/*
		 * move the output pointer.
		 * reduce the amount of space remaining in the output buffer.
		 * Increment the count of values converted.
		 */
		out = ((char *)out) + work_count * outsize;
		size -= work_count * outsize;
		number_done += work_count;
	}
	/*
	 * All Done!  Clean up and leave.
	 */
	bu_free(t1, "vert.c: t1");
	bu_free(t2, "vert.c: t2");
	bu_free(t3, "vert.c: t3");
	return(number_done);
}
@


11.21
log
@change conf.h to a wrapped config.h
@
text
@d26 1
a26 1
static const char libbu_convert_RCSid[] = "@@(#)$Header: /cvs/brlcad/libbu/convert.c,v 11.20 2004/04/05 07:46:16 morrison Exp $ (ARL)";
@


11.20
log
@merge of ansi-6-0-branch into HEAD
@
text
@d26 1
a26 1
static const char libbu_convert_RCSid[] = "@@(#)$Header$ (ARL)";
d29 5
a33 1
#include "conf.h"
@


11.19
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d26 1
a26 1
static const char libbu_convert_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/convert.c,v 11.17 2002/02/22 02:06:16 morrison Exp $ (ARL)";
d155 1
a155 1
	int	len;
d281 1
a281 7
cv(out, outfmt, size, in, infmt, count)
genptr_t out;
char	*outfmt;
int	size;
genptr_t in;
char	*infmt;
int	count;
d297 1
a297 2
bu_cv_optimize( cookie )
register int	cookie;
d310 1
d317 1
a317 1
		if (sizeof (long int) == 8) {
d396 1
a396 5
bu_cv_ntohss(out, size, in, count)
register signed short	*out;
int			size;
register genptr_t	in;
int			count;
d416 1
a416 5
bu_cv_ntohus(out, size, in, count)
register unsigned short	*out;
int			size;
register genptr_t	in;
int			count;
d432 1
a432 5
bu_cv_ntohsl(out, size, in, count)
register signed long int	*out;
int				size;
register genptr_t		in;
int				count;
d452 1
a452 5
bu_cv_ntohul(out, size, in, count)
register unsigned long int	*out;
int				size;
register genptr_t		in;
int				count;
d472 1
a472 5
bu_cv_htonss(out, size, in, count)
genptr_t		out;
int			size;
register short		*in;
int			count;
d489 1
a489 5
bu_cv_htonus(out, size, in, count)
genptr_t		out;
int			size;
register unsigned short	*in;
int			count;
d506 1
a506 5
bu_cv_htonsl(out, size, in, count)
genptr_t		out;
int			size;
register long		*in;
int			count;
d525 1
a525 5
bu_cv_htonul(out, size, in, count)
genptr_t		out;
int			size;
register unsigned long	*in;
int			count;
d634 1
a634 1
bu_cv_w_cookie(genptr_t out, int outcookie, int	size, genptr_t in,  int incookie,  int	count)
d639 1
a639 1
	int	bufsize;
d688 1
a688 1
			if (count * outsize > size) {
d697 1
a697 2
			(void) bcopy((genptr_t) in, (genptr_t) out,
									 number_done * outsize);
d759 1
a759 1
	while ( size >= outsize  && number_done < count) {
@


11.19.2.1
log
@Initial ANSIfication
@
text
@d26 1
a26 1
static const char libbu_convert_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/convert.c,v 11.19 2002/08/20 17:07:40 jra Exp $ (ARL)";
d281 7
a287 1
cv(genptr_t out, char *outfmt, int size, genptr_t in, char *infmt, int count)
d303 2
a304 1
bu_cv_optimize(register int cookie)
d402 5
a406 1
bu_cv_ntohss(register short int *out, int size, register genptr_t in, int count)
d426 5
a430 1
bu_cv_ntohus(register short unsigned int *out, int size, register genptr_t in, int count)
d446 5
a450 1
bu_cv_ntohsl(register long int *out, int size, register genptr_t in, int count)
d470 5
a474 1
bu_cv_ntohul(register long unsigned int *out, int size, register genptr_t in, int count)
d494 5
a498 1
bu_cv_htonss(genptr_t out, int size, register short int *in, int count)
d515 5
a519 1
bu_cv_htonus(genptr_t out, int size, register short unsigned int *in, int count)
d536 5
a540 1
bu_cv_htonsl(genptr_t out, int size, register long int *in, int count)
d559 5
a563 1
bu_cv_htonul(genptr_t out, int size, register long unsigned int *in, int count)
@


11.19.2.2
log
@more quelling of lots of warnings
@
text
@d26 1
a26 1
static const char libbu_convert_RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libbu/convert.c,v 11.19.2.1 2002/09/19 18:01:12 morrison Exp $ (ARL)";
d155 1
a155 1
	unsigned int	len;
d281 1
a281 1
cv(genptr_t out, char *outfmt, size_t size, genptr_t in, char *infmt, int count)
a309 1
		size_t soli = sizeof(long int);
d316 1
a316 1
		if (soli == 8) {
d395 1
a395 1
bu_cv_ntohss(register short int *out, size_t size, register genptr_t in, int count)
d415 1
a415 1
bu_cv_ntohus(register short unsigned int *out, size_t size, register genptr_t in, int count)
d431 1
a431 1
bu_cv_ntohsl(register long int *out, size_t size, register genptr_t in, int count)
d451 1
a451 1
bu_cv_ntohul(register long unsigned int *out, size_t size, register genptr_t in, int count)
d471 1
a471 1
bu_cv_htonss(genptr_t out, size_t size, register short int *in, int count)
d488 1
a488 1
bu_cv_htonus(genptr_t out, size_t size, register short unsigned int *in, int count)
d505 1
a505 1
bu_cv_htonsl(genptr_t out, size_t size, register long int *in, int count)
d524 1
a524 1
bu_cv_htonul(genptr_t out, size_t size, register long unsigned int *in, int count)
d633 1
a633 1
bu_cv_w_cookie(genptr_t out, int outcookie, size_t size, genptr_t in,  int incookie,  int	count)
d638 1
a638 1
	size_t	bufsize;
d687 1
a687 1
			if ((unsigned int)count * outsize > size) {
d696 2
a697 1
			(void) bcopy((genptr_t) in, (genptr_t) out, (size_t)number_done * outsize);
d759 1
a759 1
	while ( size >= (unsigned int)outsize  && number_done < count) {
@


11.18
log
@Converted from K&R to ANSI C - RFH
@
text
@d281 7
a287 1
cv(genptr_t out, char *outfmt, int size, genptr_t in, char *infmt, int count)
d303 2
a304 1
bu_cv_optimize(register int cookie)
d402 5
a406 1
bu_cv_ntohss(register short int *out, int size, register genptr_t in, int count)
d426 5
a430 1
bu_cv_ntohus(register short unsigned int *out, int size, register genptr_t in, int count)
d446 5
a450 1
bu_cv_ntohsl(register long int *out, int size, register genptr_t in, int count)
d470 5
a474 1
bu_cv_ntohul(register long unsigned int *out, int size, register genptr_t in, int count)
d494 5
a498 1
bu_cv_htonss(genptr_t out, int size, register short int *in, int count)
d515 5
a519 1
bu_cv_htonus(genptr_t out, int size, register short unsigned int *in, int count)
d536 5
a540 1
bu_cv_htonsl(genptr_t out, int size, register long int *in, int count)
d559 5
a563 1
bu_cv_htonul(genptr_t out, int size, register long unsigned int *in, int count)
@


11.17
log
@Chuck investigated the (obscure) problem converting data to network unsigned shorts.  Updated the supported output formats to support the signed and unsigned short and long output formats.

Previous support was ifdefed out possibly due to an attempt (?) to merge the signed and unsigned int functions (htonss & htonus & htonul & htonsl (was called htonas & htonal)).  Functionality (hton?? functions) already existed, though was not being used.

Also reformatted the text. ;)
@
text
@d26 1
a26 1
static const char libbu_convert_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/convert.c,v 11.16 2001/11/19 19:34:47 butler Exp $ (ARL)";
d281 1
a281 7
cv(out, outfmt, size, in, infmt, count)
genptr_t out;
char	*outfmt;
int	size;
genptr_t in;
char	*infmt;
int	count;
d297 1
a297 2
bu_cv_optimize( cookie )
register int	cookie;
d395 1
a395 5
bu_cv_ntohss(out, size, in, count)
register signed short	*out;
int			size;
register genptr_t	in;
int			count;
d415 1
a415 5
bu_cv_ntohus(out, size, in, count)
register unsigned short	*out;
int			size;
register genptr_t	in;
int			count;
d431 1
a431 5
bu_cv_ntohsl(out, size, in, count)
register signed long int	*out;
int				size;
register genptr_t		in;
int				count;
d451 1
a451 5
bu_cv_ntohul(out, size, in, count)
register unsigned long int	*out;
int				size;
register genptr_t		in;
int				count;
d471 1
a471 5
bu_cv_htonss(out, size, in, count)
genptr_t		out;
int			size;
register short		*in;
int			count;
d488 1
a488 5
bu_cv_htonus(out, size, in, count)
genptr_t		out;
int			size;
register unsigned short	*in;
int			count;
d505 1
a505 5
bu_cv_htonsl(out, size, in, count)
genptr_t		out;
int			size;
register long		*in;
int			count;
d524 1
a524 5
bu_cv_htonul(out, size, in, count)
genptr_t		out;
int			size;
register unsigned long	*in;
int			count;
@


11.16
log
@Indented comments
@
text
@d26 1
a26 1
static const char libbu_convert_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/convert.c,v 11.15 2001/08/08 20:33:36 butler Exp $ (ARL)";
d68 1
a68 1

d71 2
a72 2


d81 1
a81 1

d83 1
a83 1

d90 1
a90 1

d102 1
a102 1

d137 1
a137 1

d152 1
a152 4
bu_cv_fmt_cookie( buf, buflen, cookie )
char	*buf;
size_t	buflen;
int	cookie;
d156 2
a157 3

	if( buflen == 0 )
	{
d166 1
a166 1

d176 2
a177 3

	if( buflen == 0 )
	{
d188 2
a189 3

	if( buflen == 0 )
	{
d200 2
a201 3

	if( buflen == 0 )
	{
d234 2
a235 3

	if( buflen == 0 )
	{
d261 1
a261 3
bu_cv_pr_cookie( title, cookie )
char	*title;
int	cookie;
d264 1
a264 1

d311 1
a311 1

d314 1
a314 1

d322 1
a322 1

d340 1
a340 1

d370 2
a371 2
		sizeof(short), sizeof(int),
		sizeof(long int), sizeof(double)};
d410 1
a410 1

d413 1
a413 1

d434 1
a434 1

d437 1
a437 1

d440 1
a440 1
		    ((unsigned char *)in)[1];
d466 1
d478 1
a478 1

d484 1
a484 1
		    ((unsigned char *)in)[1] << 16 |
d486 1
a486 1
		    ((unsigned char *)in)[3];
d507 1
a507 1

d546 1
a546 1

d549 1
a549 1

d569 1
a569 1

d571 3
a573 1
	if( count > limit )  count = limit;
d672 1
a672 2
bu_cv_w_cookie(genptr_t out, int outcookie, int	size,
	       genptr_t in,  int incookie,  int	count)
d689 2
a690 1
	if (work_count > count) work_count = count;
d694 1
a694 1

d715 1
a715 7

	    /*
	     * Input format is the same as output format, do we need to do a
	     * host/net conversion?
	     */
	    if (inIsHost == outIsHost) {

d717 2
a718 2
		 * No conversion required.
		 * Check the amount of space remaining before doing the bcopy.
d720 7
a726 1
		if (count * outsize > size) {
d728 1
a728 1
		} else {
d730 18
a747 18
		}

		/*
		 * This is the simplest case, binary copy and out.
		 */
		(void) bcopy((genptr_t) in, (genptr_t) out,
			     number_done * outsize);
		return(number_done);

		/*
		 * Well it's still the same format but the conversion are different.
		 * Only one of the *vert variables can be HOST therefore if
		 * inIsHost != HOST then outIsHost must be host format.
		 */

	    } else if (inIsHost != CV_HOST_MASK) { /* net format */
		switch(incookie & (CV_SIGNED_MASK | CV_TYPE_MASK)) {
		case CV_SIGNED_MASK | CV_16:
d749 1
a749 1
		case CV_16:
d751 1
a751 1
		case CV_SIGNED_MASK | CV_32:
d753 1
a753 1
		case CV_32:
d755 1
a755 1
		case CV_D:
d758 9
a766 9
		}

		/*
		 * Since inIsHost != outIsHost and inIsHost == HOST then outIsHost must be
		 * in net format.  call the correct subroutine to do the conversion.
		 */
	    } else {
		switch(incookie & (CV_SIGNED_MASK | CV_TYPE_MASK)) {
		case CV_SIGNED_MASK | CV_16:
d768 1
a768 1
		case CV_16:
d770 1
a770 1
		case CV_SIGNED_MASK | CV_32:
d772 1
a772 1
		case CV_32:
d774 1
a774 1
		case CV_D:
d777 1
a778 1
	    }
d785 1
a785 1
	 * because of the number of steps is not know to begin with, we get
d789 1
a789 1

d794 1
a794 1

d799 21
a819 63
	    int remaining;

	    /*
	     * Size is the number of bytes that the caller said was available.
	     * We need the check to make sure that we will not convert to many
	     * entries, overflowing the output buffer.
	     */

	    /*
	     * Get number of full entries that can be converted
	     */
	    remaining = size / outsize;

	    /*
	     * If number of entries that would fit in the output buffer is
	     * larger than the number of entries left to convert(based on
	     * count and number done), set remaining to request count minus
	     * the number of conversions already completed.
	     */
	    if (remaining > count - number_done) {
		remaining = count - number_done;
	    }
	    /*
	     * If we are in the last chuck, set the work count to take up
	     * the slack.
	     */
	    if (remaining < work_count) work_count = remaining;

	    /*
	     * All input at any stage will come from the "from" pointer.  We
	     * start with the from pointer pointing to the input buffer.
	     */
	    from = in;

	    /*
	     * We will be processing work_count entries of insize bytes each, so
	     * we set the in pointer to be ready for the next time through the loop.
	     */
	    in = ((char *) in) + work_count * insize;

	    /*
	     * If the input is in net format convert it host format.
	     * Because we know that the input format is not equal to the output
	     * this means that there will be at least two conversions taking place
	     * if the input is in net format.  (from net to host then at least one cast)
	     */
	    if (inIsHost != CV_HOST_MASK) { /* net format */
		switch(incookie & (CV_SIGNED_MASK | CV_TYPE_MASK)) {
		case CV_SIGNED_MASK | CV_16:
		    (void) bu_cv_ntohss((short *)t1, bufsize , from, work_count);
		    break;
		case CV_16:
		    (void) bu_cv_ntohus((unsigned short *)t1, bufsize , from, work_count);
		    break;
		case CV_SIGNED_MASK | CV_32:
		    (void) bu_cv_ntohsl((long *)t1, bufsize , from, work_count);
		    break;
		case CV_32:
		    (void) bu_cv_ntohul((unsigned long *)t1, bufsize , from, work_count);
		    break;
		case CV_D:
		    (void) ntohd((unsigned char *)t1, (unsigned char *)from, work_count);
		    break;
d822 8
a829 1
		 * Point the "from" pointer to the host format.
d831 8
a838 14
		from = t1;
	    }


	    /*
	     * "From" is a pointer to a HOST format buffer.
	     */

	    /*
	     * If the input format is not double then there must be a cast to
	     * double.
	     */
	    if (infmt != CV_D) {

d840 4
a843 2
		 * if the output conversion is HOST and output format is DOUBLE
		 * then this will be the last step.
d845 22
a866 4
		if (outIsHost == CV_HOST_MASK && outfmt == CV_D) {
		    to = out;
		} else {
		    to = t2;
d868 6
a873 2

		hold = to;
d875 2
a876 1
		 * Cast the input format to double.
d878 18
a895 2
		switch(incookie & (CV_SIGNED_MASK | CV_TYPE_MASK)) {
		case CV_SIGNED_MASK | CV_8:
d897 3
a899 3
			*((double *)to) = *((signed char *)from);
			to = (genptr_t)(((double *)to) + 1);
			from = ((char *)from) + 1;
d902 1
a902 1
		case CV_8:
d904 3
a906 3
			*((double *)to) = *((unsigned char *)from);
			to = (genptr_t)(((double *)to) + 1);
			from = (genptr_t)(((unsigned char *)from) + 1);
d909 1
a909 1
		case CV_SIGNED_MASK | CV_16:
d911 3
a913 3
			*((double *)to) = *((signed short *)from);
			to = (genptr_t)(((double *)to) + 1);
			from = (genptr_t)(((signed short *)from) + 1);
d916 1
a916 1
		case CV_16:
d918 3
a920 3
			*((double *)to) = *((unsigned short *)from);
			to = (genptr_t)(((double *)to) + 1);
			from = (genptr_t)(((unsigned short *)from) + 1);
d923 1
a923 1
		case CV_SIGNED_MASK | CV_32:
d925 3
a927 3
			*((double *)to) = *((signed long int *)from);
			to = (genptr_t)(((double *)to) + 1);
			from =  (genptr_t)(((signed long int *)from) + 1);
d930 1
a930 1
		case CV_32:
d932 3
a934 3
			*((double *)to) = *((unsigned long int *) from);
			to = (genptr_t)(((double *)to) + 1);
			from = (genptr_t)(((unsigned long int *)from) + 1);
d937 5
d943 9
a951 11
		from = hold;
	    }

	    if (outfmt != CV_D) {
		/*
		 * The input point is now pointing to a double in host format.  If the
		 * output is also in host format then the next conversion will be
		 * the last conversion, set the destination to reflect this.
		 */

		if (outIsHost == CV_HOST_MASK) {
d953 1
a953 1
		} else {
d955 10
a964 10
		}

		/*
		 * The ouput format is something other than DOUBLE (tested for earlier),
		 * do a cast from double to requested format.
		 */
		hold = to;

		switch (outcookie & (CV_SIGNED_MASK | CV_TYPE_MASK)) {
		case CV_SIGNED_MASK | CV_8:
d966 3
a968 3
			*((signed char *)to) = *((double *)from);
			to = (genptr_t)(((signed char *)to) + 1);
			from = (genptr_t)(((double *)from) + 1);
d971 1
a971 1
		case CV_8:
d973 4
a976 4
			*((unsigned char *)to) =
			    (unsigned char)(*((double *)from));
			to = (genptr_t)(((unsigned char *)to) + 1);
			from = (genptr_t)(((double *)from) + 1);
d979 1
a979 1
		case CV_SIGNED_MASK | CV_16:
d981 4
a984 4
			*((signed short int *)to) =
			    *((double *)from);
			to = (genptr_t)(((signed short int *)to) + 1);
			from = (genptr_t)(((double *)from) + 1);
d987 1
a987 1
		case CV_16:
d989 4
a992 4
			*((unsigned short int *)to) =
			    *((double *)from);
			to = (genptr_t)(((unsigned short int *)to) + 1);
			from = (genptr_t)(((double *)from) + 1);
d995 1
a995 1
		case CV_SIGNED_MASK | CV_32:
d997 4
a1000 4
			*((signed long int *)to) =
			    *((double *)from);
			to = (genptr_t)(((signed long int *)to) + 1);
			from = (genptr_t)(((double *)from) + 1);
d1003 1
a1003 1
		case CV_32:
d1005 4
a1008 4
			*((unsigned long int *)to) =
			    *((double *)from);
			to = (genptr_t)(((unsigned long int *)to) + 1);
			from = (genptr_t)(((double *)from) + 1);
d1011 41
a1052 1
		from = hold;
d1054 3
a1056 2
		 * The input is now pointing to a host formated buffer of the requested
		 * output format.
d1058 3
a1060 34

		/*
		 * If the output conversion is network then do a host to net call
		 * for either 16 or 32 bit values using Host TO Network All Short | Long
		 */
		if (outIsHost != CV_HOST_MASK) {
		    switch (outfmt) {
		    case CV_D:
			(void) htond((unsigned char *)out,
				     (unsigned char *)from,
				     work_count);
			break;
#if 0
		    case CV_16:
			(void) bu_cv_htonas(out, bufsize, from,
					    work_count);
			break;
		    case CV_32:
			(void) bu_cv_htonal(out, bufsize, from,
					    work_count);
			break;
#endif
		    }
		}
					
	    }
	    /*
	     * move the output pointer.
	     * reduce the amount of space remaining in the output buffer.
	     * Increament the count of values converted.
	     */
	    out = ((char *)out) + work_count * outsize;
	    size -= work_count * outsize;
	    number_done += work_count;
@


11.15
log
@Misc Compiler warning fixes
@
text
@d26 1
a26 1
static const char libbu_convert_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/convert.c,v 11.14 2001/04/05 19:35:30 morrison Exp $ (ARL)";
d692 4
a695 4
/*
 * Work_count is the size of the working buffer.  If count is smaller
 * than the default work_count (4096) use the smaller number.
 */
d702 5
a706 5
/*
 * break out the conversion code and the format code.
 * Conversion is net<-->host.
 * Format is 8/16/32/64/D casting.
 */
d711 3
a713 3
/*
 * Find the number of bytes required for one item of each kind.
 */
d717 4
a720 4
/*
 * If the input format is the same as the output format then the
 * most that has to be done is a host to net or net to host conversion.
 */
d723 15
a737 5
/*
 * Input format is the same as output format, do we need to do a
 * host/net conversion?
 */
		if (inIsHost == outIsHost) {
d739 12
a750 9
/*
 * No conversion required.
 * Check the amount of space remaining before doing the bcopy.
 */
			if (count * outsize > size) {
				number_done = size / outsize;
			} else {
				number_done = count;
			}
d752 14
a765 6
/*
 * This is the simplest case, binary copy and out.
 */
			(void) bcopy((genptr_t) in, (genptr_t) out,
			    number_done * outsize);
			return(number_done);
d767 17
a783 39
/*
 * Well it's still the same format but the conversion are different.
 * Only one of the *vert variables can be HOST therefore if
 * inIsHost != HOST then outIsHost must be host format.
 */

		} else if (inIsHost != CV_HOST_MASK) { /* net format */
			switch(incookie & (CV_SIGNED_MASK | CV_TYPE_MASK)) {
			case CV_SIGNED_MASK | CV_16:
				return(	bu_cv_ntohss((signed short *)out, size, in, count));
			case CV_16:
				return( bu_cv_ntohus((unsigned short *)out, size, in, count));
			case CV_SIGNED_MASK | CV_32:
				return( bu_cv_ntohsl((signed long *)out, size, in, count));
			case CV_32:
				return( bu_cv_ntohul((unsigned long *)out, size, in, count));
			case CV_D:
				(void) ntohd((unsigned char *)out, (unsigned char *)in, count);
				return(count);
			}

/*
 * Since inIsHost != outIsHost and inIsHost == HOST then outIsHost must be
 * in net format.  call the correct subroutine to do the conversion.
 */
		} else {
			switch(incookie & (CV_SIGNED_MASK | CV_TYPE_MASK)) {
			case CV_SIGNED_MASK | CV_16:
				return(	bu_cv_htonss(out, size, (short *)in, count));
			case CV_16:
				return( bu_cv_htonus(out, size, (unsigned short *)in, count));
			case CV_SIGNED_MASK | CV_32:
				return( bu_cv_htonsl(out, size, (long *)in, count));
			case CV_32:
				return( bu_cv_htonul(out, size, (unsigned long *)in, count));
			case CV_D:
				(void) htond((unsigned char *)out, (unsigned char *)in, count);
				return(count);
			}
d785 1
d787 9
a795 9
/*
 * If we get to this point then the input format is known to be
 * of a diffrent type than the output format.  This will require
 * a cast to, from or to and from double.
 *
 * because of the number of steps is not know to begin with, we get
 * three working buffers.  The size of a double is the largest of
 * any of the sizes we may be dealing with.
 */
d802 3
a804 3
/*
 * From here on we will be working on a chunk of process at a time.
 */
d806 1
a806 1
		int remaining;
d808 67
a874 5
/*
 * Size is the number of bytes that the caller said was available.
 * We need the check to make sure that we will not convert to many
 * entries, overflowing the output buffer.
 */
a875 4
/*
 * Get number of full entries that can be converted
 */
		remaining = size / outsize;
d877 18
a894 8
/*
 * If number of entries that would fit in the output buffer is
 * larger than the number of entries left to convert(based on
 * count and number done), set remaining to request count minus
 * the number of conversions already completed.
 */
		if (remaining > count - number_done) {
			remaining = count - number_done;
a895 5
/*
 * If we are in the last chuck, set the work count to take up
 * the slack.
 */
		if (remaining < work_count) work_count = remaining;
d897 50
a946 5
/*
 * All input at any stage will come from the "from" pointer.  We
 * start with the from pointer pointing to the input buffer.
 */
		from = in;
d948 6
a953 5
/*
 * We will be processing work_count entries of insize bytes each, so
 * we set the in pointer to be ready for the next time through the loop.
 */
		in = ((char *) in) + work_count * insize;
d955 4
a958 28
/*
 * If the input is in net format convert it host format.
 * Because we know that the input format is not equal to the output
 * this means that there will be at least two conversions taking place
 * if the input is in net format.  (from net to host then at least one cast)
 */
		if (inIsHost != CV_HOST_MASK) { /* net format */
			switch(incookie & (CV_SIGNED_MASK | CV_TYPE_MASK)) {
			case CV_SIGNED_MASK | CV_16:
				(void) bu_cv_ntohss((short *)t1, bufsize , from, work_count);
				break;
			case CV_16:
				(void) bu_cv_ntohus((unsigned short *)t1, bufsize , from, work_count);
				break;
			case CV_SIGNED_MASK | CV_32:
				(void) bu_cv_ntohsl((long *)t1, bufsize , from, work_count);
				break;
			case CV_32:
				(void) bu_cv_ntohul((unsigned long *)t1, bufsize , from, work_count);
				break;
			case CV_D:
				(void) ntohd((unsigned char *)t1, (unsigned char *)from, work_count);
				break;
			}
/*
 * Point the "from" pointer to the host format.
 */
			from = t1;
d961 5
d967 48
a1014 69
/*
 * "From" is a pointer to a HOST format buffer.
 */

/*
 * If the input format is not double then there must be a cast to
 * double.
 */
		if (infmt != CV_D) {

/*
 * if the output conversion is HOST and output format is DOUBLE
 * then this will be the last step.
 */
			if (outIsHost == CV_HOST_MASK && outfmt == CV_D) {
				to = out;
			} else {
				to = t2;
			}

			hold = to;
/*
 * Cast the input format to double.
 */
			switch(incookie & (CV_SIGNED_MASK | CV_TYPE_MASK)) {
			case CV_SIGNED_MASK | CV_8:
				for (i=0; i< work_count; i++) {
					*((double *)to) = *((signed char *)from);
					to = (genptr_t)(((double *)to) + 1);
					from = ((char *)from) + 1;
				}
				break;
			case CV_8:
				for(i=0; i < work_count; i++) {
					*((double *)to) = *((unsigned char *)from);
					to = (genptr_t)(((double *)to) + 1);
					from = (genptr_t)(((unsigned char *)from) + 1);
				}
				break;
			case CV_SIGNED_MASK | CV_16:
				for (i=0; i < work_count; i++) {
					*((double *)to) = *((signed short *)from);
					to = (genptr_t)(((double *)to) + 1);
					from = (genptr_t)(((signed short *)from) + 1);
				}
				break;
			case CV_16:
				for (i=0; i < work_count; i++) {
					*((double *)to) = *((unsigned short *)from);
					to = (genptr_t)(((double *)to) + 1);
					from = (genptr_t)(((unsigned short *)from) + 1);
				}
				break;
			case CV_SIGNED_MASK | CV_32:
				for (i=0; i < work_count; i++) {
					*((double *)to) = *((signed long int *)from);
					to = (genptr_t)(((double *)to) + 1);
					from =  (genptr_t)(((signed long int *)from) + 1);
				}
				break;
			case CV_32:
				for (i=0; i < work_count; i++) {
					*((double *)to) = *((unsigned long int *) from);
					to = (genptr_t)(((double *)to) + 1);
					from = (genptr_t)(((unsigned long int *)from) + 1);
				}
				break;
			}
			from = hold;
d1016 5
d1022 11
a1032 85
		if (outfmt != CV_D) {
/*
 * The input point is now pointing to a double in host format.  If the
 * output is also in host format then the next conversion will be
 * the last conversion, set the destination to reflect this.
 */

			if (outIsHost == CV_HOST_MASK) {
				to = out;
			} else {
				to = t3;
			}

/*
 * The ouput format is something other than DOUBLE (tested for earlier),
 * do a cast from double to requested format.
 */
			hold = to;

			switch (outcookie & (CV_SIGNED_MASK | CV_TYPE_MASK)) {
			case CV_SIGNED_MASK | CV_8:
				for (i=0; i<work_count; i++) {
					*((signed char *)to) = *((double *)from);
					to = (genptr_t)(((signed char *)to) + 1);
					from = (genptr_t)(((double *)from) + 1);
				}
				break;
			case CV_8:
				for (i=0; i<work_count; i++) {
					*((unsigned char *)to) =
					    (unsigned char)(*((double *)from));
					to = (genptr_t)(((unsigned char *)to) + 1);
					from = (genptr_t)(((double *)from) + 1);
				}
				break;
			case CV_SIGNED_MASK | CV_16:
				for (i=0; i<work_count; i++) {
					*((signed short int *)to) =
					    *((double *)from);
					to = (genptr_t)(((signed short int *)to) + 1);
					from = (genptr_t)(((double *)from) + 1);
				}
				break;
			case CV_16:
				for (i=0; i<work_count; i++) {
					*((unsigned short int *)to) =
					    *((double *)from);
					to = (genptr_t)(((unsigned short int *)to) + 1);
					from = (genptr_t)(((double *)from) + 1);
				}
				break;
			case CV_SIGNED_MASK | CV_32:
				for (i=0; i<work_count; i++) {
					*((signed long int *)to) =
					    *((double *)from);
					to = (genptr_t)(((signed long int *)to) + 1);
					from = (genptr_t)(((double *)from) + 1);
				}
				break;
			case CV_32:
				for (i=0; i<work_count; i++) {
					*((unsigned long int *)to) =
					    *((double *)from);
					to = (genptr_t)(((unsigned long int *)to) + 1);
					from = (genptr_t)(((double *)from) + 1);
				}
				break;
			}
			from = hold;
/*
 * The input is now pointing to a host formated buffer of the requested
 * output format.
 */

/*
 * If the output conversion is network then do a host to net call
 * for either 16 or 32 bit values using Host TO Network All Short | Long
 */
			if (outIsHost != CV_HOST_MASK) {
				switch (outfmt) {
				case CV_D:
					(void) htond((unsigned char *)out,
						     (unsigned char *)from,
						     work_count);
					break;
d1034 2
a1035 2
				case CV_16:
					(void) bu_cv_htonas(out, bufsize, from,
d1037 3
a1039 3
					break;
				case CV_32:
					(void) bu_cv_htonal(out, bufsize, from,
d1041 1
a1041 1
					break;
d1043 2
a1044 2
				}
			}
d1046 13
a1058 13
		}
/*
 * move the output pointer.
 * reduce the amount of space remaining in the output buffer.
 * Increament the count of values converted.
 */
		out = ((char *)out) + work_count * outsize;
		size -= work_count * outsize;
		number_done += work_count;
	}
/*
 * All Done!  Clean up and leave.
 */
@


11.14
log
@updated SIGNED to signed
updated CONST to const
@
text
@d26 1
a26 1
static const char libbu_convert_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/convert.c,v 11.13 2001/03/19 22:19:45 butler Exp $ (ARL)";
d755 1
a755 1
				return(	bu_cv_ntohss(out, size, in, count));
d757 1
a757 1
				return( bu_cv_ntohus(out, size, in, count));
d759 1
a759 1
				return( bu_cv_ntohsl(out, size, in, count));
d761 1
a761 1
				return( bu_cv_ntohul(out, size, in, count));
d763 1
a763 1
				(void) ntohd(out, in, count);
d774 1
a774 1
				return(	bu_cv_htonss(out, size, in, count));
d776 1
a776 1
				return( bu_cv_htonus(out, size, in, count));
d778 1
a778 1
				return( bu_cv_htonsl(out, size, in, count));
d780 1
a780 1
				return( bu_cv_htonul(out, size, in, count));
d782 1
a782 1
				(void) htond(out, in, count);
d855 1
a855 1
				(void) bu_cv_ntohss(t1, bufsize , from, work_count);
d858 1
a858 1
				(void) bu_cv_ntohus(t1, bufsize , from, work_count);
d861 1
a861 1
				(void) bu_cv_ntohsl(t1, bufsize , from, work_count);
d864 1
a864 1
				(void) bu_cv_ntohul(t1, bufsize , from, work_count);
d867 1
a867 1
				(void) ntohd(t1, from, work_count);
d1029 3
a1031 1
					(void) htond(out,from, work_count);
@


11.13
log
@patches to merge 5.3 into 6.0
@
text
@d26 1
a26 1
static const char libbu_convert_RCSid[] = "@@(#)$Header: /d/CVS/brlcad/libbu/convert.c,v 11.12 2000/08/21 02:18:52 butler Exp $ (ARL)";
d413 1
a413 1
register SIGNED short	*out;
d421 1
a421 1
	limit = size / sizeof(SIGNED short);
d425 1
a425 1
		*out++ = ((SIGNED char *)in)[0] << 8 | ((unsigned char *)in)[1];
d457 1
a457 1
register SIGNED long int	*out;
d465 1
a465 1
	limit = size / sizeof(SIGNED long int);
d469 1
a469 1
		*out++ = ((SIGNED char *)in)[0] << 24 |
d904 1
a904 1
					*((double *)to) = *((SIGNED char *)from);
d918 1
a918 1
					*((double *)to) = *((SIGNED short *)from);
d920 1
a920 1
					from = (genptr_t)(((SIGNED short *)from) + 1);
d932 1
a932 1
					*((double *)to) = *((SIGNED long int *)from);
d934 1
a934 1
					from =  (genptr_t)(((SIGNED long int *)from) + 1);
d970 2
a971 2
					*((SIGNED char *)to) = *((double *)from);
					to = (genptr_t)(((SIGNED char *)to) + 1);
d985 1
a985 1
					*((SIGNED short int *)to) =
d987 1
a987 1
					to = (genptr_t)(((SIGNED short int *)to) + 1);
d1001 1
a1001 1
					*((SIGNED long int *)to) =
d1003 1
a1003 1
					to = (genptr_t)(((SIGNED long int *)to) + 1);
@


11.12
log
@Misc compilation fixes
@
text
@d26 1
a26 1
static const char libbu_convert_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/convert.c,v 11.11 2000/07/24 18:37:08 butler Exp $ (ARL)";
d389 203
d679 2
a680 7
bu_cv_w_cookie(out, outcookie, size, in, incookie, count)
genptr_t out;
int	outcookie;
int	size;
genptr_t in;
int	incookie;
int	count;
a1060 201
}

/*	bu_cv_ntohss	Network TO Host Signed Short
 *
 * It is assumed that this routine will only be called if there is
 * real work to do.  Ntohs does no checking to see if it is reasonable
 * to do any conversions.
 *
 * Entry:
 *	in	generic pointer for input.
 *	count	number of shorts to be generated.
 *	out	short pointer for output
 *	size	number of bytes of space reserved for out.
 *
 * Exit:
 *	returns	number of conversions done.
 *
 * Calls:
 *	none.
 *
 * Method:
 *	Straight-forward.
 */
int
bu_cv_ntohss(out, size, in, count)
register SIGNED short	*out;
int			size;
register genptr_t	in;
int			count;
{
	int limit;
	register int i;

	limit = size / sizeof(SIGNED short);
	if (limit < count) count = limit;

	for (i=0; i<count; i++) {
		*out++ = ((SIGNED char *)in)[0] << 8 | ((unsigned char *)in)[1];
		/* XXX This needs sign extension here for the case of
		 * XXX a negative 2-byte input on a 4 or 8 byte machine.
		 * XXX The "signed char" trick isn't enough.
		 * XXX Use your Cyber trick w/magic numbers or something.
		 */
		in = ((char *)in) + 2;
	}
	return(count);
}
int
bu_cv_ntohus(out, size, in, count)
register unsigned short	*out;
int			size;
register genptr_t	in;
int			count;
{
	int limit;
	register int i;

	limit = size / sizeof(unsigned short);
	if (limit < count) count = limit;

	for (i=0; i<count; i++) {
		*out++ = ((unsigned char *)in)[0]<<8 |
		    ((unsigned char *)in)[1];
		in = ((char *)in) + 2;
	}
	return(count);
}
int
bu_cv_ntohsl(out, size, in, count)
register SIGNED long int	*out;
int				size;
register genptr_t		in;
int				count;
{
	int limit;
	register int i;

	limit = size / sizeof(SIGNED long int);
	if (limit < count) count = limit;

	for (i=0; i<count; i++) {
		*out++ = ((SIGNED char *)in)[0] << 24 |
		    ((unsigned char *)in)[1] << 16 | 
		    ((unsigned char *)in)[2] << 8  |
		    ((unsigned char *)in)[3];
		/* XXX Sign extension here */
		in = ((char *)in) + 4;
	}
	return(count);
}
int
bu_cv_ntohul(out, size, in, count)
register unsigned long int	*out;
int				size;
register genptr_t		in;
int				count;
{
	int limit;
	register int i;

	limit = size / sizeof(unsigned long int);
	if (limit < count) count = limit;

	for (i=0; i<count; i++) {
		*out++ = ((unsigned char *)in)[0] << 24 |
		    ((unsigned char *)in)[1] << 16 |
		    ((unsigned char *)in)[2] <<  8 |
		    ((unsigned char *)in)[3];
		in = ((char *)in) + 4;
	}
	return(count);
}

/*****/
int
bu_cv_htonss(out, size, in, count)
genptr_t		out;
int			size;
register short		*in;
int			count;
{
	int		limit;
	register int	i;
	register unsigned char *cp = (unsigned char *)out;
	register int	val;

	limit = size / 2;
	if( count > limit )  count = limit;

	for (i=0; i<count; i++) {
		*cp++ = (val = *in++)>>8;
		*cp++ = val;
	}
	return(count);
}
int
bu_cv_htonus(out, size, in, count)
genptr_t		out;
int			size;
register unsigned short	*in;
int			count;
{
	int		limit;
	register int	i;
	register unsigned char *cp = (unsigned char *)out;
	register int	val;

	limit = size / 2;
	if( count > limit )  count = limit;

	for (i=0; i<count; i++) {
		*cp++ = (val = *in++)>>8;
		*cp++ = val;
	}
	return(count);
}
int
bu_cv_htonsl(out, size, in, count)
genptr_t		out;
int			size;
register long		*in;
int			count;
{
	int		limit;
	register int	i;
	register unsigned char *cp = (unsigned char *)out;
	register long	val;

	limit = size / 4;
	if( count > limit )  count = limit;

	for (i=0; i<count; i++) {
		*cp++ = (val = *in++)>>24;
		*cp++ = val>>16;
		*cp++ = val>> 8;
		*cp++ = val;
	}
	return(count);
}
int
bu_cv_htonul(out, size, in, count)
genptr_t		out;
int			size;
register unsigned long	*in;
int			count;
{
	int		limit;
	register int	i;
	register unsigned char *cp = (unsigned char *)out;
	register long	val;

	limit = size / 4;
	if( count > limit )  count = limit;

	for (i=0; i<count; i++) {
		*cp++ = (val = *in++)>>24;
		*cp++ = val>>16;
		*cp++ = val>> 8;
		*cp++ = val;
	}
	return(count);
@


11.11
log
@Moved a bunch of stuff in to ../h/bu.h
@
text
@d26 1
a26 1
static const char libbu_convert_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/convert.c,v 11.10 2000/07/07 05:21:20 cjohnson Exp $ (ARL)";
d376 1
a376 2
bu_cv_itemlen( cookie )
register int	cookie;
@


11.10
log
@LINT plus minor bug fix in bu_tcl.c
@
text
@d26 1
a26 1
static const char libbu_convert_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/convert.c,v 11.9 2000/07/05 22:10:28 cjohnson Exp $ (ARL)";
a41 40
/*
 * Forward declarations.
 */
int bu_cv_w_cookie(genptr_t, int, int, genptr_t, int, int);
int bu_cv_ntohss(SIGNED short *, int, genptr_t, int);
int bu_cv_ntohus(unsigned short *, int, genptr_t, int);
int bu_cv_ntohsl(SIGNED long int *, int, genptr_t, int);
int bu_cv_ntohul(unsigned long int *, int, genptr_t, int);
int bu_cv_htonss(genptr_t, int, SIGNED short *, int);
int bu_cv_htonus(genptr_t, int, unsigned short *, int);
int bu_cv_htonsl(genptr_t, int, long *, int);
int bu_cv_htonul(genptr_t, int, unsigned long *, int);

/*
 * Theses should be moved to a header file soon.
 */
#define CV_CHANNEL_MASK	0x00ff
#define CV_HOST_MASK	0x0100
#define CV_SIGNED_MASK	0x0200
#define CV_TYPE_MASK	0x1c00  /* 0001 1100 0000 0000 */
#define CV_CONVERT_MASK 0x6000  /* 0110 0000 0000 0000 */

#define CV_TYPE_SHIFT	10
#define CV_CONVERT_SHIFT 13

#define CV_8	0x0400
#define	CV_16	0x0800
#define CV_32	0x0c00
#define CV_64	0x1000
#define CV_D	0x1400

#define CV_CLIP		0x0000
#define CV_NORMAL	0x2000
#define CV_LIT		0x4000

#define	IND_NOTSET	0
#define IND_BIG		1
#define IND_LITTLE	2
#define IND_ILL		3		/* PDP-11 */
#define IND_CRAY	4
d63 1
a63 2
bu_cv_cookie(in)
char *in;			/* input format */
@


11.9
log
@LINT
@
text
@d26 1
a26 1
static char libbu_convert_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/convert.c,v 11.8 2000/06/30 20:11:18 butler Exp $ (ARL)";
@


11.8
log
@Added comments with bit field values
@
text
@d26 1
a26 1
static char libbu_convert_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/convert.c,v 11.7 2000/03/28 19:29:26 mike Exp $ (ARL)";
d43 13
d331 1
d517 1
@


11.7
log
@
Missing include of string.h
@
text
@d26 1
a26 1
static char libbu_convert_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/convert.c,v 11.6 2000/03/28 18:55:07 mike Exp $ (ARL)";
d48 2
a49 2
#define CV_TYPE_MASK	0x1c00
#define CV_CONVERT_MASK 0x6000
@


11.7.2.1
log
@Changes to make it compile without warnings
@
text
@d26 1
a26 1
static char libbu_convert_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/convert.c,v 11.7 2000/03/28 19:29:26 mike Exp $ (ARL)";
a317 1
int
a416 203

/*	bu_cv_ntohss	Network TO Host Signed Short
 *
 * It is assumed that this routine will only be called if there is
 * real work to do.  Ntohs does no checking to see if it is reasonable
 * to do any conversions.
 *
 * Entry:
 *	in	generic pointer for input.
 *	count	number of shorts to be generated.
 *	out	short pointer for output
 *	size	number of bytes of space reserved for out.
 *
 * Exit:
 *	returns	number of conversions done.
 *
 * Calls:
 *	none.
 *
 * Method:
 *	Straight-forward.
 */
int
bu_cv_ntohss(out, size, in, count)
register SIGNED short	*out;
int			size;
register genptr_t	in;
int			count;
{
	int limit;
	register int i;

	limit = size / sizeof(SIGNED short);
	if (limit < count) count = limit;

	for (i=0; i<count; i++) {
		*out++ = ((SIGNED char *)in)[0] << 8 | ((unsigned char *)in)[1];
		/* XXX This needs sign extension here for the case of
		 * XXX a negative 2-byte input on a 4 or 8 byte machine.
		 * XXX The "signed char" trick isn't enough.
		 * XXX Use your Cyber trick w/magic numbers or something.
		 */
		in = ((char *)in) + 2;
	}
	return(count);
}
int
bu_cv_ntohus(out, size, in, count)
register unsigned short	*out;
int			size;
register genptr_t	in;
int			count;
{
	int limit;
	register int i;

	limit = size / sizeof(unsigned short);
	if (limit < count) count = limit;

	for (i=0; i<count; i++) {
		*out++ = ((unsigned char *)in)[0]<<8 |
		    ((unsigned char *)in)[1];
		in = ((char *)in) + 2;
	}
	return(count);
}
int
bu_cv_ntohsl(out, size, in, count)
register SIGNED long int	*out;
int				size;
register genptr_t		in;
int				count;
{
	int limit;
	register int i;

	limit = size / sizeof(SIGNED long int);
	if (limit < count) count = limit;

	for (i=0; i<count; i++) {
		*out++ = ((SIGNED char *)in)[0] << 24 |
		    ((unsigned char *)in)[1] << 16 | 
		    ((unsigned char *)in)[2] << 8  |
		    ((unsigned char *)in)[3];
		/* XXX Sign extension here */
		in = ((char *)in) + 4;
	}
	return(count);
}
int
bu_cv_ntohul(out, size, in, count)
register unsigned long int	*out;
int				size;
register genptr_t		in;
int				count;
{
	int limit;
	register int i;

	limit = size / sizeof(unsigned long int);
	if (limit < count) count = limit;

	for (i=0; i<count; i++) {
		*out++ = ((unsigned char *)in)[0] << 24 |
		    ((unsigned char *)in)[1] << 16 |
		    ((unsigned char *)in)[2] <<  8 |
		    ((unsigned char *)in)[3];
		in = ((char *)in) + 4;
	}
	return(count);
}

/*****/
int
bu_cv_htonss(out, size, in, count)
genptr_t		out;
int			size;
register short		*in;
int			count;
{
	int		limit;
	register int	i;
	register unsigned char *cp = (unsigned char *)out;
	register int	val;

	limit = size / 2;
	if( count > limit )  count = limit;

	for (i=0; i<count; i++) {
		*cp++ = (val = *in++)>>8;
		*cp++ = val;
	}
	return(count);
}
int
bu_cv_htonus(out, size, in, count)
genptr_t		out;
int			size;
register unsigned short	*in;
int			count;
{
	int		limit;
	register int	i;
	register unsigned char *cp = (unsigned char *)out;
	register int	val;

	limit = size / 2;
	if( count > limit )  count = limit;

	for (i=0; i<count; i++) {
		*cp++ = (val = *in++)>>8;
		*cp++ = val;
	}
	return(count);
}
int
bu_cv_htonsl(out, size, in, count)
genptr_t		out;
int			size;
register long		*in;
int			count;
{
	int		limit;
	register int	i;
	register unsigned char *cp = (unsigned char *)out;
	register long	val;

	limit = size / 4;
	if( count > limit )  count = limit;

	for (i=0; i<count; i++) {
		*cp++ = (val = *in++)>>24;
		*cp++ = val>>16;
		*cp++ = val>> 8;
		*cp++ = val;
	}
	return(count);
}
int
bu_cv_htonul(out, size, in, count)
genptr_t		out;
int			size;
register unsigned long	*in;
int			count;
{
	int		limit;
	register int	i;
	register unsigned char *cp = (unsigned char *)out;
	register long	val;

	limit = size / 4;
	if( count > limit )  count = limit;

	for (i=0; i<count; i++) {
		*cp++ = (val = *in++)>>24;
		*cp++ = val>>16;
		*cp++ = val>> 8;
		*cp++ = val;
	}
	return(count);
}


d503 7
a509 3
int
bu_cv_w_cookie(genptr_t out, int outcookie, int	size,
	       genptr_t in,  int incookie,  int	count)
d890 201
@


11.6
log
@
Put libbu_filename_ prefixes on RCSid variables.
@
text
@d26 1
a26 1
static char libbu_convert_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/convert.c,v 11.5 1999/01/15 05:49:21 mike Exp $ (ARL)";
d33 5
@


11.5
log
@Moved librt/vert.c to libbu/convert.c
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/convert.c,v 11.4 1996/07/12 12:10:21 jra Exp $ (ARL)";
@


11.4
log
@Minor Mods for IRIX 6.2
@
text
@d2 1
a2 1
 *			V E R T . C
d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/vert.c,v 11.3 1995/05/16 02:09:13 butler Exp jra $ (ARL)";
d35 1
a35 1
#include "raytrace.h"
d65 1
a65 1
/* cv_cookie	Set's a bit vector after parsing an input string.
d85 1
a85 1
cv_cookie(in)
d175 1
a175 1
cv_fmt_cookie( buf, buflen, cookie )
d185 1
a185 1
		fprintf( stderr, "cv_pr_cookie:  call me with a bigger buffer\n");
d199 1
a199 1
		fprintf( stderr, "cv_pr_cookie:  call me with a bigger buffer\n");
d206 1
a206 1
		fprintf( stderr, "cv_pr_cookie:  call me with a bigger buffer\n");
d219 1
a219 1
		fprintf( stderr, "cv_pr_cookie:  call me with a bigger buffer\n");
d232 1
a232 1
		fprintf( stderr, "cv_pr_cookie:  call me with a bigger buffer\n");
d267 1
a267 1
		fprintf( stderr, "cv_pr_cookie:  call me with a bigger buffer\n");
d292 1
a292 1
cv_pr_cookie( title, cookie )
d298 1
a298 1
	cv_fmt_cookie( buf, sizeof(buf), cookie );
d322 3
a324 3
	incookie = cv_cookie(infmt);
	outcookie = cv_cookie(outfmt);
	return(cv_w_cookie(out, outcookie, size, in, incookie, count));
d335 1
a335 1
cv_optimize( cookie )
d362 1
a362 1
				rt_bomb("cv_optimize: can not tell indian of host.\n");
d398 1
a398 1
cv_itemlen( cookie )
d412 1
a412 1
/* cv_w_cookie - convert with cookie
d498 1
a498 1
cv_w_cookie(out, outcookie, size, in, incookie, count)
d523 2
a524 2
	incookie = cv_optimize( incookie );
	outcookie = cv_optimize( outcookie );
d538 2
a539 2
	outsize = cv_itemlen( outcookie );
	insize = cv_itemlen( incookie );
d579 1
a579 1
				return(	cv_ntohss(out, size, in, count));
d581 1
a581 1
				return( cv_ntohus(out, size, in, count));
d583 1
a583 1
				return( cv_ntohsl(out, size, in, count));
d585 1
a585 1
				return( cv_ntohul(out, size, in, count));
d598 1
a598 1
				return(	cv_htonss(out, size, in, count));
d600 1
a600 1
				return( cv_htonus(out, size, in, count));
d602 1
a602 1
				return( cv_htonsl(out, size, in, count));
d604 1
a604 1
				return( cv_htonul(out, size, in, count));
d622 3
a624 3
	t1 = (genptr_t) rt_malloc(bufsize, "vert.c: t1");
	t2 = (genptr_t) rt_malloc(bufsize, "vert.c: t2");
	t3 = (genptr_t) rt_malloc(bufsize, "vert.c: t3");
d679 1
a679 1
				(void) cv_ntohss(t1, bufsize , from, work_count);
d682 1
a682 1
				(void) cv_ntohus(t1, bufsize , from, work_count);
d685 1
a685 1
				(void) cv_ntohsl(t1, bufsize , from, work_count);
d688 1
a688 1
				(void) cv_ntohul(t1, bufsize , from, work_count);
d857 1
a857 1
					(void) cv_htonas(out, bufsize, from,
d861 1
a861 1
					(void) cv_htonal(out, bufsize, from,
d881 3
a883 3
	rt_free(t1, "vert.c: t1");
	rt_free(t2, "vert.c: t2");
	rt_free(t3, "vert.c: t3");
d887 1
a887 1
/*	cv_ntohss	Network TO Host Signed Short
d909 1
a909 1
cv_ntohss(out, size, in, count)
d933 1
a933 1
cv_ntohus(out, size, in, count)
d953 1
a953 1
cv_ntohsl(out, size, in, count)
d976 1
a976 1
cv_ntohul(out, size, in, count)
d1000 1
a1000 1
cv_htonss(out, size, in, count)
d1021 1
a1021 1
cv_htonus(out, size, in, count)
d1042 1
a1042 1
cv_htonsl(out, size, in, count)
d1065 1
a1065 1
cv_htonul(out, size, in, count)
@


11.3
log
@some compilers complain about expression (var >> 32) so this was
changed to ((var >> 31) >> 1) just to shut off the compiler warnings
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/vert.c,v 11.2 1995/01/07 08:47:33 cjohnson Exp butler $ (ARL)";
d177 1
a177 1
int	buflen;
d183 5
d193 1
a193 5
	/* Make sure there is enough room */
	if (buflen < 5) {
		if( buflen < 0 )  fprintf(stderr, "cv_pr_cookie:  call me with a bigger buffer\n");
		return;
	}
d197 5
d204 5
d217 5
d230 3
a232 2
	if (buflen < 3) {
		if( buflen < 0 )  fprintf(stderr, "cv_pr_cookie:  call me with a bigger buffer\n");
a234 1
		
d265 5
a288 1
	if( buflen < 0 )  fprintf(stderr, "cv_pr_cookie:  call me with a bigger buffer\n");
@


11.2
log
@Add a slightly better test for Indian when dealing with
64 bit machines.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/vert.c,v 11.1 1995/01/04 09:58:54 mike Rel4_4 cjohnson $ (ARL)";
d334 1
d337 1
a337 1
			if ( ( testval >> 32) == 0x01020304) {
@


11.1
log
@Release_4.4
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/vert.c,v 10.6 94/12/27 18:56:28 mike Exp $ (ARL)";
d336 7
@


10.6
log
@Added cv_ prefix
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/vert.c,v 10.5 94/12/27 18:18:33 mike Exp Locker: mike $ (ARL)";
@


10.5
log
@Added RCSid
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d551 1
a551 1
				return(	ntohss(out, size, in, count));
d553 1
a553 1
				return( ntohus(out, size, in, count));
d555 1
a555 1
				return( ntohsl(out, size, in, count));
d557 1
a557 1
				return( ntohul(out, size, in, count));
d570 1
a570 1
				return(	htonss(out, size, in, count));
d572 1
a572 1
				return( htonus(out, size, in, count));
d574 1
a574 1
				return( htonsl(out, size, in, count));
d576 1
a576 1
				return( htonul(out, size, in, count));
d651 1
a651 1
				(void) ntohss(t1, bufsize , from, work_count);
d654 1
a654 1
				(void) ntohus(t1, bufsize , from, work_count);
d657 1
a657 1
				(void) ntohsl(t1, bufsize , from, work_count);
d660 1
a660 1
				(void) ntohul(t1, bufsize , from, work_count);
d829 1
a829 1
					(void) htonas(out, bufsize, from,
d833 1
a833 1
					(void) htonal(out, bufsize, from,
d859 1
a859 1
/*	ntohss	Network TO Host Signed Short
d881 1
a881 1
ntohss(out, size, in, count)
d905 1
a905 1
ntohus(out, size, in, count)
d925 1
a925 1
ntohsl(out, size, in, count)
d948 1
a948 1
ntohul(out, size, in, count)
d972 1
a972 1
htonss(out, size, in, count)
d993 1
a993 1
htonus(out, size, in, count)
d1014 1
a1014 1
htonsl(out, size, in, count)
d1037 1
a1037 1
htonul(out, size, in, count)
@


10.4
log
@GCC
@
text
@a2 2
 * Author -
 *	Christopher T. Johnson
d4 1
a4 8
 * Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1986 by the United States Army.
 *	All rights reserved.
a5 3
 *
 * Vert.c is a routine to translate data formats.  The data formats are:
 *
a11 1
 *
d15 9
d25 2
a26 2
#ifndef line
static char RCSid[] = "$Header: /m/cad/librt/RCS/vert.c,v 10.3 94/11/04 07:02:58 mike Exp Locker: mike $ (BRL)";
@


10.3
log
@Irix 6
@
text
@d30 1
a30 1
static char RCSid[] = "$Header: /m/cad/librt/RCS/vert.c,v 10.2 94/08/10 20:22:47 gdurf Exp Locker: mike $ (BRL)";
d96 2
a97 2
	if (!in) return(NULL);
	if (!*in) return(NULL);
d109 1
a109 1
	if (!*p) return(NULL);
d118 1
a118 1
	if (!*p) return(NULL);
d130 1
a130 1
	if (!*p) return(NULL);
d138 1
a138 1
		if (*p != '6') return(NULL);
d145 1
a145 1
		if (*p != '2') return(NULL);
d152 1
a152 1
		if (*p != '4') return(NULL);
d161 1
a161 1
		return(NULL);
d173 1
a173 1
		return(NULL);
@


10.2
log
@Added include of conf.h
@
text
@d30 1
a30 1
static char RCSid[] = "$Header: /m/cad/librt/RCS/vert.c,v 10.1 1991/10/12 06:41:10 mike Rel4_0 gdurf $ (BRL)";
d32 1
d38 2
d114 1
a114 1
	} else if (*p = 'n') {
a322 1
	int	IsHost;
@


10.1
log
@Release_4.0
@
text
@d30 1
a30 1
static char RCSid[] = "$Header: /m/cad/librt/RCS/vert.c,v 1.18 91/07/26 18:09:39 mike Exp $ (BRL)";
d32 2
@


1.18
log
@Added ctype.h
@
text
@d30 1
a30 1
static char RCSid[] = "$Header: /m/cad/librt/RCS/vert.c,v 1.17 91/07/25 03:15:26 mike Exp $ (BRL)";
@


1.17
log
@Removed debugging prints
@
text
@d30 1
a30 1
static char RCSid[] = "$Header: /m/cad/librt/RCS/vert.c,v 1.16 91/07/02 22:40:19 mike Exp $ (BRL)";
d33 1
@


1.16
log
@Changed "signed" to "SIGNED", from machine.h
Added casts for some pointer assignments, to quiet picky compilers.
@
text
@d30 1
a30 1
static char RCSid[] = "$Header: /m/cad/librt/RCS/vert.c,v 1.15 91/07/02 02:55:04 mike Exp $ (BRL)";
a493 2
cv_pr_cookie( "incookie", incookie );
cv_pr_cookie( "outcookie", outcookie );
a495 2
cv_pr_cookie( "optim incookie", incookie );
cv_pr_cookie( "optim outcookie", outcookie );
a510 1
fprintf(stderr,"insize=%d, outsize=%d\n", insize, outsize);
@


1.15
log
@Changed to use machine.h.
Made to compile on non-ANSI machines.
@
text
@d30 1
a30 1
static char RCSid[] = "$Header: /m/cad/librt/RCS/vert.c,v 1.14 91/06/29 22:31:32 mike Exp $ (BRL)";
d482 2
a483 1
	genptr_t	from,to;
d704 1
a704 1
					*((double *)to) = *((signed char *)from);
d713 1
a713 1
					from = ((unsigned char *)from) + 1;
d718 1
a718 1
					*((double *)to) = *((signed short *)from);
d720 1
a720 1
					from = (genptr_t)(((signed short *)from) + 1);
d732 1
a732 1
					*((double *)to) = *((signed long int *)from);
d734 1
a734 1
					from =  (genptr_t)(((signed long int *)from) + 1);
d770 2
a771 2
					*((signed char *)to) = *((double *)from);
					to = (genptr_t)(((signed char *)to) + 1);
d778 2
a779 2
					    *((double *)from);
					to = ((unsigned char *)to) + 1;
d785 1
a785 1
					*((signed short int *)to) =
d787 1
a787 1
					to = (genptr_t)(((signed short int *)to) + 1);
d801 1
a801 1
					*((signed long int *)to) =
d803 1
a803 1
					to = (genptr_t)(((signed long int *)to) + 1);
d886 1
a886 1
register signed short	*out;
d894 1
a894 1
	limit = size / sizeof(signed short);
d898 1
a898 1
		*out++ = ((signed char *)in)[0] << 8 | ((unsigned char *)in)[1];
d930 1
a930 1
register signed long int	*out;
d938 1
a938 1
	limit = size / sizeof(signed long int);
d942 1
a942 1
		*out++ = ((signed char *)in)[0] << 24 |
@


1.14
log
@Changed runtime test to #if
@
text
@d30 1
a30 1
static char RCSid[] = "$Header: /m/cad/librt/RCS/vert.c,v 1.13 91/06/29 21:26:17 mike Exp $ (BRL)";
d33 1
a34 1
typedef void *genptr_t;
a62 7
#if defined(sun) || (defined(alliant) && ! defined(i860)) || \
	defined(ardent) || \
	defined(stellar) || defined(sparc) || defined(mips) || \
	defined(pyr) || defined(apollo) || defined(aux)
#	define DOUBLE_FORMAT_IS_IEEE	1
#endif

d346 1
a346 1
#		if DOUBLE_FORMAT_IS_IEEE
d704 1
a704 1
					to = ((double *)to) + 1;
d711 1
a711 1
					to = ((double *)to) + 1;
d718 2
a719 2
					to = ((double *)to) + 1;
					from = ((signed short *)from) + 1;
d725 2
a726 2
					to = ((double *)to) + 1;
					from = ((unsigned short *)from) + 1;
d732 2
a733 2
					to = ((double *)to) + 1;
					from =  ((signed long int *)from) + 1;
d739 2
a740 2
					to = ((double *)to) + 1;
					from = ((unsigned long int *)from) + 1;
d770 2
a771 2
					to = ((signed char *)to) + 1;
					from = ((double *)from) + 1;
d779 1
a779 1
					from = ((double *)from) + 1;
d786 2
a787 2
					to = ((signed short int *)to) + 1;
					from = ((double *)from) + 1;
d794 2
a795 2
					to = ((unsigned short int *)to) + 1;
					from = ((double *)from) + 1;
d802 2
a803 2
					to = ((signed long int *)to) + 1;
					from = ((double *)from) + 1;
d810 2
a811 2
					to = ((unsigned long int *)to) + 1;
					from = ((double *)from) + 1;
@


1.13
log
@Non-ANSI use of |=
@
text
@d30 1
a30 1
static char RCSid[] = "$Header: /m/cad/librt/RCS/vert.c,v 1.12 91/06/26 14:05:49 cjohnson Exp $ (BRL)";
a62 3
#define DBL_IEEE	1
#define DBL_OTHER	2

d67 1
a67 3
#	define DBL_FORMAT	DBL_IEEE
#else
#	define DBL_FORMAT	DBL_OTHER
d353 1
a353 1
		if( DBL_FORMAT == DBL_IEEE )
d355 1
@


1.12
log
@Change buflen test in cv_fmt_cookie
@
text
@d30 1
a30 1
static char RCSid[] = "$Header: /d/cjohnson/src/color/RCS/vert.c,v 1.11 91/06/25 06:28:53 mike Exp $ (BRL)";
d161 1
a161 1
		result | = CV_64;
d164 1
a164 1
		result | = CV_D;
@


1.11
log
@Minor additions
@
text
@d30 1
a30 1
static char RCSid[] = "$Header: /d/cjohnson/src/color/RCS/vert.c,v 1.10 91/06/25 07:19:21 cjohnson Exp $ (BRL)";
d198 5
d224 5
@


1.10
log
@change *vert to *IsHost, fix some problems pointed out by mike.
Still needs to have some code pulled out into subroutines.
@
text
@d30 1
a30 1
static char RCSid[] = "$Header: /d/cjohnson/src/color/RCS/vert.c,v 1.9 91/06/25 05:57:50 cjohnson Exp $ (BRL)";
d63 2
a64 3
static int Indian = IND_NOTSET;
#define DBL_IEEE	0
#define DBL_OTHER	1
d70 1
a70 1
#define DBL_FORMAT	DBL_IEEE
d72 1
a72 8
#if defined(n16) || defined(i860) || \
	(defined(sgi) && !defined(mips)) || \
	defined(vax) || defined(ibm) || defined(gould) || \
	defined(CRAY1) || defined(CRAY2) || defined(eta10) || \
	defined(convex)
#define DBL_FORMAT	DBL_OTHER
#else
# include "vert.c: ERROR, no HtoND format defined (see htond.c)"
a73 1
#endif
d183 99
d306 78
a477 3
	static int host_size_table[5] = {sizeof(char), sizeof(short), sizeof(int),
		sizeof(long int), sizeof(double)};
	static int net_size_table[5] = {1,2,4,8,8};
d494 6
a499 19
/*
 * This is a run time check to see what type of integer arrangment is
 * in use.
 */
	if (Indian == IND_NOTSET) {
		unsigned long int	testval;
		for (i=0; i<4; i++) {
			((char *)&testval)[i] = i+1;
		}
		if (sizeof (long int) == 8) {
			Indian = IND_CRAY;	/* is this good enough? */
		} else if (testval == 0x01020304) {
			Indian = IND_BIG;
		} else if (testval == 0x04030201) {
			Indian = IND_LITTLE;
		} else if (testval == 0x02010403) {
			Indian = IND_ILL;
		}
	}
a509 1

d511 1
a511 9
 * Check to see if host representation  is the same as net rep.
 * If the format is double then check to see if double is
 * the same as IEEE double floating point which is what we use
 * for network doubles.
 *
 * If the format is not double then byte ordering becomes important.
 * 8 bit values are single bytes (I HOPE) so they do not depend on
 * byte ordering.  I.E. all 8 bit sizes are treated as net == host
 * format.  Otherwise check for big indian ordering.
d513 3
a515 9
	if (infmt == CV_D) {
		if (DBL_FORMAT == DBL_IEEE) {
			inIsHost = CV_HOST_MASK;	/* host == net format */
		}
	} else {
		if (Indian == IND_BIG || infmt == CV_8) {
			inIsHost = CV_HOST_MASK; /* host == net format */
		}
	}
a517 25
 * Outformat testing is handled the same as the input format.
 */
	if (outfmt == CV_D) {
		if (DBL_FORMAT == DBL_IEEE) {
			outIsHost = CV_HOST_MASK;
		}
	} else {
		if (Indian == IND_BIG || outfmt == CV_8) {
			outIsHost = CV_HOST_MASK;
		}
	}
/*
 * outIsHost and inIsHost now correctly show network or host formats.  If
 * network format is the same as host format for THIS conversion then
 * network was changed to host conversion.
 *
 * Now that the conversion (Host or net) has been determended, us
 * the format to find the per entry size of an entry.
 */
	outsize = (outIsHost) ? host_size_table[outfmt >> CV_TYPE_SHIFT] :
	    net_size_table[outfmt >> CV_TYPE_SHIFT];
	insize = (inIsHost) ? host_size_table[infmt >> CV_TYPE_SHIFT] :
	    net_size_table[infmt >> CV_TYPE_SHIFT];

/*
a572 1
#if 0
a580 1
#endif
d899 5
d946 1
d970 90
@


1.9
log
@*** empty log message ***
@
text
@d30 1
a30 1
static char RCSid[] = "$Header: /d/cjohnson/src/color/RCS/vert.c,v 1.8 1991/06/25 02:41:10 cjohnson Exp cjohnson $ (BRL)";
d47 5
a51 5
#define CV_8	0x0000
#define	CV_16	0x0400
#define CV_32	0x0800
#define CV_64	0x0c00
#define CV_D	0x1000
d60 1
a60 1
#define IND_ILL		3		/* Vax ish ? */
d226 10
d243 1
a243 1
 *			invert = host;
d247 1
a247 1
 *			invert = host;
d252 1
a252 1
 *			outvert == host;
d255 1
a255 1
 *			outvert = host;
d259 1
a259 1
 *		if (invert == outvert) {
d262 1
a262 1
 *		else if (invert == net) {
d274 1
a274 1
 *		if (invert == net) {
d279 1
a279 1
 *			if (outvert == host) {
d289 1
a289 1
 *			if (outvert == net) {
d293 1
a293 1
 *			if (outvert == host) {
d315 1
a315 1
	int	invert,outvert,infmt,outfmt,insize,outsize;
d354 2
a355 2
	invert = incookie & CV_HOST_MASK;	/* not zero if host */
	outvert= outcookie& CV_HOST_MASK;
d372 1
a372 1
			invert = CV_HOST_MASK;	/* host == net format */
d376 1
a376 1
			invert = CV_HOST_MASK; /* host == net format */
d385 1
a385 1
			outvert = CV_HOST_MASK;
d389 1
a389 1
			outvert = CV_HOST_MASK;
d393 1
a393 1
 * outvert and invert now correctly show network or host formats.  If
d400 1
a400 1
	outsize = (outvert) ? host_size_table[outfmt >> CV_TYPE_SHIFT] :
d402 1
a402 1
	insize = (invert) ? host_size_table[infmt >> CV_TYPE_SHIFT] :
d415 1
a415 1
		if (invert == outvert) {
d437 1
a437 1
 * invert != HOST then outvert must be host format.
d440 1
a440 1
		} else if (invert != CV_HOST_MASK) { /* net format */
d456 1
a456 1
 * Since invert != outvert and invert == HOST then outvert must be
d542 1
a542 1
		if (invert != CV_HOST_MASK) { /* net format */
d581 1
a581 1
			if (outvert == CV_HOST_MASK && outfmt == CV_D) {
d638 1
a639 7
 * If the output format is DOUBLE then we know that the conversion
 * is to network.  (We tested for outfmt=D and outvert=H earlier.
 */
		if (outfmt == CV_D) {
			(void) htond(out,from,work_count);
		} else {
/*
d645 1
a645 1
			if (outvert == CV_HOST_MASK) {
d716 5
a720 1
			if (outvert != CV_HOST_MASK) {
a721 1
				switch (outfmt) {
d730 1
a731 1
#endif
@


1.8
log
@It finally compiles
@
text
@d30 1
a30 1
static char RCSid[] = "$Header: /d/cjohnson/src/color/RCS/vert.c,v 1.7 1991/05/25 07:34:04 cjohnson Exp cjohnson $ (BRL)";
d304 1
a304 1
	int	number_done;
d309 1
d312 5
d319 4
d339 5
d349 11
d370 3
d382 8
d395 4
d400 5
d406 5
d417 3
d424 6
d445 4
d451 1
d460 1
d467 9
d482 3
d488 9
d498 7
d508 4
d514 4
d519 5
d526 6
d550 3
d556 9
d566 6
a571 1
			if (outvert == CV_HOST_MASK) {
d576 5
d625 1
a625 1
			from = to;
d628 4
d633 1
a633 12
			if (outvert != CV_HOST_MASK) {
				switch(outfmt) {
				case CV_16:
					(void) htonas(out, bufsize, from,
					    work_count);
					break;
				case CV_32:
					(void) htonas(out, bufsize, from,
					    work_count);
					break;
				}
			}
d635 6
d647 6
d702 10
a711 1
			from = to;
d713 1
d724 1
d728 5
d737 3
@


1.7
log
@Lots of code.  Cast of void pointer fails.
@
text
@d30 1
a30 1
static char RCSid[] = "$Header: /d/cjohnson/src/color/RCS/vert.c,v 1.6 1991/05/25 04:28:17 cjohnson Exp cjohnson $ (BRL)";
d417 1
a417 1
		(char *)in = (char *) in + work_count * insize;
d449 3
a451 2
					(*(double *)to)++ = 
					    (*(signed char *)from)++;
d456 3
a458 2
					(*(double *)to)++ = 
					    (*(unsigned char *)from)++;
d463 3
a465 2
					(*(double *)to)++ =
					    (*(signed short *)from)++;
d470 3
a472 2
					(*(double *)to)++ =
					    (*(unsigned short *)from)++;
d477 3
a479 2
					(*(double *)to)++ =
					    (*(signed long int *)from)++;
d484 3
a486 2
					(*(double *)to)++ =
					    (*(unsigned long int *)from)++;
d515 5
a519 2
				(*(signed char *)to)++ =
				    (*(double *)from)++;
d522 6
a527 2
				(*(unsigned char *)to)++ =
				    (*(double *)from++;
d530 6
a535 2
				(*(signed short *)to)++ =
				    (*(double *)from)++;
d538 6
a543 2
				(*(unsigned short *)to)++ =
				    (*(double *)from++;
d546 6
a551 2
				(*(signed long int *)to)++ =
				    (*(double *)from)++;
d554 6
a559 2
				(*(unsigned long int *)to)++ =
				    (*(double *)from++;
d577 1
a577 1
		out += work_count * outsize;
d584 1
a584 1
	return(work_done);
d623 1
a623 1
		in+=2;
d641 3
a643 2
		*out++ = ((unsigned char *)in)[0]<<8 | ((unsigned char *)in)[1]);
		in += 2;
d665 1
a665 1
		in += 4;
d687 1
a687 1
		int += 4;
@


1.6
log
@checkpoint.  This looks like a good run of it.  Check point is prior
to moving common blocks outside of if statements so that the
code is not duplicated.
@
text
@d30 1
a30 1
static char RCSid[] = "$Header: /d/cjohnson/src/color/RCS/vert.c,v 1.5 1991/05/18 00:15:09 cjohnson Exp cjohnson $ (BRL)";
d66 2
a67 1
#if defined(sun) || (defined(alliant) && !(defined(i860)) || \
d71 3
a73 2
#define DBL_FORMAT	DLB_IEEE
#elseif defined(n16) || defined(i860) || \
d81 2
a82 1
#fi
d264 5
a268 5
 *		if (outfmt == double ) {
 *			if (invert == net) {
 *				ntoh?(from,t1);
 *				from = t1;
 *			fi
d270 1
a270 2
 *				castdbl(from,out);
 *				continue;
d272 1
a272 2
 *				castdbl(from,t2);
 *				hton(t2,out);
d274 8
a282 8
 *			if (invert == net) {
 *				ntoh?(from,t1);
 *				from = t1;
 *			fi
 *			if (infmt != double) {
 *				castdbl(from,t2);
 *				from = t2;
 *			fi
d306 4
d346 1
a346 1
			outvert = CV_HOST_MASK:
d403 3
d417 1
a417 1
		in += work_count * insize;
d440 1
a440 1
		if (outfmt == CV_D) {
d485 3
d491 2
a492 1
					htons(out, bufsize, from, work_count);
d495 2
a496 1
					htons(out, bufsize, from, work_count);
a499 1
			out += work_count * outsize;
d501 46
d548 3
d552 4
d634 1
a634 1
		    ((unsinged char *)in)[3];
@


1.5
log
@Checkpoint, Unknow current state or privious state.
@
text
@d30 1
a30 1
static char RCSid[] = "$Header: /d/cjohnson/src/color/RCS/vert.c,v 1.4 91/04/26 20:39:11 cjohnson Exp $ (BRL)";
d64 16
d222 68
a298 1
	int number_converted = 0;
a301 4
	int bytes_per;
	double *working;
	double *hostnet;
	int i;
d303 2
a304 1
	int inputconvert = 0;
d324 4
d329 9
a337 1
	working = (double *) malloc(work_count*sizeof(double));
d339 4
a342 8
	bytes_per = (outcookie & CV_HOST_MASK) ?
	    host_size_table[ (outcookie & CV_TYPE_MASK) >> CV_TYPE_SHIFT] :
	    net_size_table[ (outcookie & CV_TYPE_MASK) >> CV_TYPE_SHIFT] ;

	if (Indian != IND_BIG && !(incookie & CV_HOST_MASK) &&
	    (bytes_per != 1)) {
		inputconvert = 1;
		hostnet = (unsigned int *) malloc(work_count*bytes_per));
d344 3
a346 1
		hostnet = in;
d348 52
a399 5
		
/*
 * Currently we assume that all machines are big-indian - XXX
 */
	while (size>= bytes_per && number_converted < count) {
d402 3
a404 3
		remaining = size / bytes_per;
		if (remaining > count-number_converted) {
			remaining = count - number_converted;
d407 36
a442 29
/*
 * net to host
 */
		if (inputconvert) {
			switch (Indian) {
			case IND_LITTLE:
				if (bytes_per == 2) {
					for (j=0; j<work_count*bytes_per; j+=bytes_per) {
						hostnet[j]   = in[j+1];
						hostnet[j+1] = in[j];
					}
				} else if (bytes_per == 4) {
					for (j=0; j<work_count*bytes_per; j+=bytes_per) {
						hostnet[j]   = in[j+3];
						hostnet[j+1] = in[j+2];
						hostnet[j+2] = in[j+1];
						hostnet[j+3] = in[j];
					}
				} else if (bytes_per == 8) {
					for (j=0; j<work_count*bytes_per; j+=bytes_per) {
						hostnet[j]   = in[j+7];
						hostnet[j+1] = in[j+6];
						hostnet[j+2] = in[j+5];
						hostnet[j+3] = in[j+4];
						hostnet[j+4] = in[j+3];
						hostnet[j+5] = in[j+2];
						hostnet[j+6] = in[j+1];
						hostnet[j+7] = in[j];
					}
a443 1
				in += work_count*bytes_per;
d445 44
a488 1
			case IND_CRAY:
d490 2
d493 20
a512 2
/*
 * to double.
d514 9
d524 2
a525 3
/*
 * convert.  (Normalize, clip, literal)
 */
d527 15
a541 3
/*
 * from double.
 */
d543 6
a548 3
/*
 * to host.
 */
d550 1
d552 9
d562 2
d565 6
a570 8
/*
 * Vert procedures.
 */
if {Host format) {
	if (input format == double) {
		work = in;
	} else {
		*work = *(cast *)in;
d572 21
a592 10
} else {	/* network format */
	if (input format == double) {
		ntohd()
	} else if (input size == native size || unsigned) {
		*work = (cast) (*in << 8 | *(in+1));
	} else if (input size != native size ) {
		register long int tmp;
		tmp = *in << 8 | *(in+1);
		*work = (cast) (tmp & 0x800) ? ((-1L) & ~0xffff) | tmp :
		    tmp;
d594 1
@


1.4
log
@Added Indian test.
@
text
@d30 1
a30 1
static char RCSid[] = "$Header: /d/cjohnson/src/color/RCS/vert.c,v 1.3 91/04/09 20:21:37 cjohnson Exp $ (BRL)";
d221 1
a221 1
	unsigned long int *hostnet;
d251 2
a252 1
	if (Indian != IND_BIG && !(incookie & CV_HOST_MASK)) {
d254 3
a256 1
		hostnet = (unsigned long int *) malloc(work_count*sizeof(double));
d274 6
a279 6
			register int j;
			if (Indian == IND_LITTLE) {
				for (j=0; j<work_count; j++) {
					for (i=0; i<bytes_per; i++) {
						((char *)&hostnet[j])[i] =
						    ((char *)&in[j])[bytes_per - i - 1];
d281 18
d300 3
a302 4
			} 
/* else IND_CRAY and IND_ILL */
		} else {
			hostnet = (unsigned long int *) in;
d304 1
d320 23
@


1.3
log
@Change to integer cookie.  Finsh documenting processing.
@
text
@d30 1
a30 1
static char RCSid[] = "$Header: /d/cjohnson/src/color/RCS/vert.c,v 1.2 91/04/04 16:04:05 cjohnson Exp $ (BRL)";
d32 3
d57 8
d95 1
d120 1
a120 1
		if (*p2 && (islower(*p2) || isdigit(*p2)) {
d188 1
a188 1
getptr_t in;
d216 1
a216 1
	int host_size_table[5] = {sizeof(char), sizeof(short), sizeof(int),
d218 1
a218 1
	int net_size_table[5] = {1,2,4,8,8};
d221 4
a224 1
	int	work_count = 500;
d226 19
d251 5
d260 2
d270 14
a283 1

@


1.2
log
@Remove initializor (allows parallel processing).  Add cookie generator
first pass.
@
text
@d30 1
a30 1
static char RCSid[] = "$Header: /d/cjohnson/src/color/RCS/vert.c,v 1.1 91/04/04 13:52:44 cjohnson Exp $ (BRL)";
d35 5
a39 15
struct cv_cookie_type {
	int	channels:8;	/* number of input channels */
	int	host:1;		/* host or net */
	int	is_signed:1;	/* is this a signed integer */
	int	type:3;		/* type/size */
	int	conversion:2;	/* conversion style */
};
#define	CV_8	0
#define	CV_16	1
#define	CV_32	2
#define	CV_64	3
#define	CV_D	4
#define CV_NORMAL	0;
#define CV_CLIP		1;
#define CV_LIT		2;
d41 13
d73 1
a73 1
struct cv_cookie
d79 1
a79 2
	struct cv_cookie result = {
		1,0,0,CV_8,CV_CLIP};
d86 6
a91 2
	if (collector > 255) collector = 255;
	if (!collector) result.channels = collector;
d96 1
a96 1
		result.host = 1;
d109 1
a109 1
			result.signed = 1;
d118 1
a118 1
		collector = CV_8;
d125 1
a125 1
		collector = CV_16;
d132 1
a132 1
		collector = CV_32;
d139 1
a139 1
		collector = CV_64;
d142 1
a142 1
		collector = CV_D;
a147 1
	result.type = collector;
d151 1
a151 1
		result.conversion = CV_NORMAL;
d153 1
a153 1
		result.conversion = CV_CLIP;
d155 1
a155 1
		result.conversion = CV_LIT;
d161 1
a161 1
/* convert - convert from one format to another.
d168 2
d172 1
a172 1
convert(out, size, in, count)
d174 1
d177 1
d180 66
@


1.1
log
@Initial revision
@
text
@d30 1
a30 1
static char RCSid[] = "$Header$ (BRL)";
d32 20
a51 1
/* vertinit	initialize the converter routine.
d56 1
a56 2
 *	in	the input format description.
 *	out	the output format description.
d59 1
d62 1
a62 1
 *	[channels][h|n][s|u] c|s|i|l|d|8|16|32|64
d68 1
d70 2
a71 1
vertinit(in,out)
a72 1
char *out;			/* output format */
d74 81
@
