head	11.15;
access;
symbols
	ansi-20040405-merged:11.11.2.2
	postmerge-20040405-ansi:11.13
	premerge-20040404-ansi:11.12
	postmerge-autoconf:11.12
	autoconf-freeze:11.11.10.2
	premerge-autoconf:11.12
	ansi-20040316-freeze:11.11.2.1
	postmerge-20040315-windows:11.12
	premerge-20040315-windows:11.12
	windows-20040315-freeze:11.11.4.1
	autoconf-20031203:11.11
	autoconf-20031202:11.11
	autoconf-branch:11.11.0.10
	phong-branch:11.11.0.8
	photonmap-branch:11.11.0.6
	rel-6-1-DP:11.11
	windows-branch:11.11.0.4
	rel-6-0-2:11.9
	ansi-branch:11.11.0.2
	rel-6-0-1-branch:11.9.0.2
	hartley-6-0-post:11.10
	hartley-6-0-pre:11.9
	rel-6-0-1:11.9
	rel-6-0:11.9
	rel-5-4:11.8
	offsite-5-3-pre:11.9
	rel-5-3:11.8
	rel-5-2:11.8
	rel-5-1-branch:11.8.0.2
	rel-5-1:11.8
	rel-5-0:11.7
	rel-5-0-beta:11.7
	rel-4-5:11.5
	ctj-4-5-post:11.5
	ctj-4-5-pre:11.5
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.15
date	2004.05.21.18.06.25;	author morrison;	state dead;
branches;
next	11.14;

11.14
date	2004.05.10.15.30.44;	author erikg;	state Exp;
branches;
next	11.13;

11.13
date	2004.04.05.07.46.16;	author morrison;	state Exp;
branches;
next	11.12;

11.12
date	2004.02.02.17.39.07;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2002.08.20.17.07.42;	author jra;	state Exp;
branches
	11.11.2.1
	11.11.4.1
	11.11.10.1;
next	11.10;

11.10
date	2002.08.15.20.54.55;	author hartley;	state Exp;
branches;
next	11.9;

11.9
date	2000.07.07.05.20.13;	author cjohnson;	state Exp;
branches;
next	11.8;

11.8
date	2000.03.28.18.55.10;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	99.01.12.16.19.56;	author pjt;	state Exp;
branches;
next	11.6;

11.6
date	98.12.30.01.25.46;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	96.08.27.07.10.51;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.09.20.12.02.21;	author pjt;	state Exp;
branches;
next	11.3;

11.3
date	95.07.10.20.17.51;	author pjt;	state Exp;
branches;
next	11.2;

11.2
date	95.04.19.19.03.56;	author pjt;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.05.58;	author mike;	state Rel4_4;
branches;
next	2.6;

2.6
date	94.12.30.16.41.04;	author stay;	state Exp;
branches;
next	2.5;

2.5
date	94.09.26.12.21.10;	author jra;	state Exp;
branches;
next	2.4;

2.4
date	94.09.22.15.46.55;	author jra;	state Exp;
branches;
next	2.3;

2.3
date	94.09.22.15.34.50;	author pjt;	state Exp;
branches;
next	2.2;

2.2
date	94.09.22.15.27.13;	author pjt;	state Exp;
branches;
next	2.1;

2.1
date	93.03.25.11.03.32;	author pjt;	state Exp;
branches;
next	1.8;

1.8
date	93.03.25.11.00.27;	author pjt;	state Exp;
branches;
next	1.7;

1.7
date	93.01.15.13.08.09;	author pjt;	state zero_1;
branches;
next	1.6;

1.6
date	93.01.15.10.42.10;	author pjt;	state zero_0;
branches;
next	1.5;

1.5
date	93.01.14.10.51.16;	author pjt;	state Exp;
branches;
next	1.4;

1.4
date	93.01.14.09.22.55;	author pjt;	state Exp;
branches;
next	1.3;

1.3
date	92.11.06.13.55.37;	author pjt;	state Exp;
branches;
next	1.2;

1.2
date	92.11.05.11.32.43;	author pjt;	state Exp;
branches;
next	1.1;

1.1
date	92.11.04.12.14.22;	author pjt;	state Exp;
branches;
next	;

11.11.2.1
date	2002.09.19.18.01.14;	author morrison;	state Exp;
branches;
next	11.11.2.2;

11.11.2.2
date	2004.03.17.21.16.51;	author morrison;	state Exp;
branches;
next	;

11.11.4.1
date	2004.03.11.23.41.50;	author morrison;	state Exp;
branches;
next	;

11.11.10.1
date	2004.02.12.18.39.19;	author erikg;	state Exp;
branches;
next	11.11.10.2;

11.11.10.2
date	2004.03.15.14.06.17;	author erikg;	state Exp;
branches;
next	;


desc
@
     Routines to walk a red-black tree

@


11.15
log
@moved to src/
@
text
@/*			R B _ W A L K . C
 *
 *	    Routines for traversal of red-black trees
 *
 *  Author -
 *	Paul J. Tanenbaum
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1998-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 *
 *
 *
 *	The function bu_rb_walk() is defined in terms of the function
 *	_rb_walk(), which, in turn, calls any of the six functions
 *
 *		static void prewalknodes()
 *		static void inwalknodes()
 *		static void postwalknodes()
 *		static void prewalkdata()
 *		static void inwalkdata()
 *		static void postwalkdata()
 *
 *	depending on the type of traversal desired and the objects
 *	to be visited (nodes themselves, or merely the data stored
 *	in them).  Each of these last six functions has four parameters:
 *	the root of the tree to traverse, the order on which to do the
 *	walking, the function to apply at each visit, and the current
 *	depth in the tree.
 */
#ifndef lint
static const char libbu_rb_walk_RCSid[] = "@@(#) $Header: /n/xoff/cvs/brlcad/libbu/rb_walk.c,v 11.14 2004/05/10 15:30:44 erikg Exp $";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "rtlist.h"
#include "bu.h"
#include "compat4.h"
#include "./rb_internals.h"

/*		        P R E W A L K N O D E S ( )
 *
 *	    Perform a preorder traversal of a red-black tree
 */
static void prewalknodes (struct bu_rb_node *root, int order, void (*visit) (/* ??? */), int depth)
{
    BU_CKMAG(root, BU_RB_NODE_MAGIC, "red-black node");
    BU_RB_CKORDER(root -> rbn_tree, order);

    if (root == bu_rb_null(root -> rbn_tree))
	return;
    visit(root, depth);
    prewalknodes (bu_rb_left_child(root, order), order, visit, depth + 1);
    prewalknodes (bu_rb_right_child(root, order), order, visit, depth + 1);
}

/*		        I N W A L K N O D E S ( )
 *
 *	    Perform an inorder traversal of a red-black tree
 */
static void inwalknodes (struct bu_rb_node *root, int order, void (*visit) (/* ??? */), int depth)
{
    BU_CKMAG(root, BU_RB_NODE_MAGIC, "red-black node");
    BU_RB_CKORDER(root -> rbn_tree, order);

    if (root == bu_rb_null(root -> rbn_tree))
	return;
    inwalknodes (bu_rb_left_child(root, order), order, visit, depth + 1);
    visit(root, depth);
    inwalknodes (bu_rb_right_child(root, order), order, visit, depth + 1);
}

/*		        P O S T W A L K N O D E S ( )
 *
 *	    Perform a postorder traversal of a red-black tree
 */
static void postwalknodes (struct bu_rb_node *root, int order, void (*visit) (/* ??? */), int depth)
{
    BU_CKMAG(root, BU_RB_NODE_MAGIC, "red-black node");
    BU_RB_CKORDER(root -> rbn_tree, order);

    if (root == bu_rb_null(root -> rbn_tree))
	return;
    postwalknodes (bu_rb_left_child(root, order), order, visit, depth + 1);
    postwalknodes (bu_rb_right_child(root, order), order, visit, depth + 1);
    visit(root, depth);
}

/*		        P R E W A L K D A T A ( )
 *
 *	    Perform a preorder traversal of a red-black tree
 */
static void prewalkdata (struct bu_rb_node *root, int order, void (*visit) (/* ??? */), int depth)
{
    BU_CKMAG(root, BU_RB_NODE_MAGIC, "red-black node");
    BU_RB_CKORDER(root -> rbn_tree, order);

    if (root == bu_rb_null(root -> rbn_tree))
	return;
    visit(bu_rb_data(root, order), depth);
    prewalkdata (bu_rb_left_child(root, order), order, visit, depth + 1);
    prewalkdata (bu_rb_right_child(root, order), order, visit, depth + 1);
}

/*		        I N W A L K D A T A ( )
 *
 *	    Perform an inorder traversal of a red-black tree
 */
static void inwalkdata (struct bu_rb_node *root, int order, void (*visit) (/* ??? */), int depth)
{
    BU_CKMAG(root, BU_RB_NODE_MAGIC, "red-black node");
    BU_RB_CKORDER(root -> rbn_tree, order);

    if (root == bu_rb_null(root -> rbn_tree))
	return;
    inwalkdata (bu_rb_left_child(root, order), order, visit, depth + 1);
    visit(bu_rb_data(root, order), depth);
    inwalkdata (bu_rb_right_child(root, order), order, visit, depth + 1);
}

/*		        P O S T W A L K D A T A ( )
 *
 *	    Perform a postorder traversal of a red-black tree
 */
static void postwalkdata (struct bu_rb_node *root, int order, void (*visit) (/* ??? */), int depth)
{
    BU_CKMAG(root, BU_RB_NODE_MAGIC, "red-black node");
    BU_RB_CKORDER(root -> rbn_tree, order);

    if (root == bu_rb_null(root -> rbn_tree))
	return;
    postwalkdata (bu_rb_left_child(root, order), order, visit, depth + 1);
    postwalkdata (bu_rb_right_child(root, order), order, visit, depth + 1);
    visit(bu_rb_data(root, order), depth);
}

/*		        _ R B _ W A L K ( )
 *
 *		    Traverse a red-black tree
 *
 *	This function has five parameters: the tree to traverse,
 *	the order on which to do the walking, the function to apply
 *	to each node, whether to apply the function to the entire node
 *	(or just to its data), and the type of traversal (preorder,
 *	inorder, or postorder).
 *
 *	N.B. _rb_walk() is not declared static because it is called
 *	by bu_rb_diagnose_tree() in rb_diag.c.
 */
void _rb_walk (bu_rb_tree *tree, int order, void (*visit) (/* ??? */), int what_to_visit, int trav_type)
{
    static void (*walk[][3])() =
		{
		    { prewalknodes, inwalknodes, postwalknodes },
		    { prewalkdata, inwalkdata, postwalkdata }
		};

    BU_CKMAG(tree, BU_RB_TREE_MAGIC, "red-black tree");
    BU_RB_CKORDER(tree, order);
    switch (trav_type)
    {
	case PREORDER:
	case INORDER:
	case POSTORDER:
	    switch (what_to_visit)
	    {
		case WALK_NODES:
		case WALK_DATA:
		    (*walk[what_to_visit][trav_type])
			(bu_rb_root(tree, order), order, visit, 0);
		    break;
		default:
		    bu_log("FATAL: _rb_walk(): Illegal visitation object: %d\n",
			what_to_visit);
		    exit (1);
	    }
	    break;
	default:
	    bu_log("FATAL: _rb_walk(): Illegal traversal type: %d\n",
		trav_type);
	    exit (1);
    }
}

/*		        B U _ R B _ W A L K ( )
 *
 *		Applications interface to _rb_walk()
 *
 *	This function has four parameters: the tree to traverse,
 *	the order on which to do the walking, the function to apply
 *	to each node, and the type of traversal (preorder, inorder,
 *	or postorder).
 */
void bu_rb_walk (bu_rb_tree *tree, int order, void (*visit) (/* ??? */), int trav_type)
{
    BU_CKMAG(tree, BU_RB_TREE_MAGIC, "red-black tree");
    BU_RB_CKORDER(tree, order);

    _rb_walk(tree, order, visit, WALK_DATA, trav_type);
}
@


11.14
log
@change conf.h to a wrapped config.h
@
text
@d41 1
a41 1
static const char libbu_rb_walk_RCSid[] = "@@(#) $Header: /cvs/brlcad/libbu/rb_walk.c,v 11.13 2004/04/05 07:46:16 morrison Exp $";
@


11.13
log
@merge of ansi-6-0-branch into HEAD
@
text
@d41 1
a41 1
static const char libbu_rb_walk_RCSid[] = "@@(#) $Header$";
d44 5
a48 1
#include "conf.h"
@


11.12
log
@update copyright to include span through 2003
@
text
@d41 1
a41 1
static const char libbu_rb_walk_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_walk.c,v 11.11 2002/08/20 17:07:42 jra Exp $";
d58 1
a58 7
static void prewalknodes (root, order, visit, depth)

struct bu_rb_node	*root;
int			order;
void			(*visit)();
int			depth;

d74 1
a74 7
static void inwalknodes (root, order, visit, depth)

struct bu_rb_node	*root;
int			order;
void			(*visit)();
int			depth;

d90 1
a90 7
static void postwalknodes (root, order, visit, depth)

struct bu_rb_node	*root;
int			order;
void			(*visit)();
int			depth;

d106 1
a106 7
static void prewalkdata (root, order, visit, depth)

struct bu_rb_node	*root;
int			order;
void			(*visit)();
int			depth;

d122 1
a122 7
static void inwalkdata (root, order, visit, depth)

struct bu_rb_node	*root;
int			order;
void			(*visit)();
int			depth;

d138 1
a138 7
static void postwalkdata (root, order, visit, depth)

struct bu_rb_node	*root;
int			order;
void			(*visit)();
int			depth;

d163 1
a163 8
void _rb_walk (tree, order, visit, what_to_visit, trav_type)

bu_rb_tree	*tree;
int		order;
void		(*visit)();
int		what_to_visit;
int		trav_type;

d207 1
a207 7
void bu_rb_walk (tree, order, visit, trav_type)

bu_rb_tree	*tree;
int		order;
void		(*visit)();
int		trav_type;

@


11.11
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1998 by the United States Army
d41 1
a41 1
static const char libbu_rb_walk_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_walk.c,v 11.9 2000/07/07 05:20:13 cjohnson Exp $";
@


11.11.4.1
log
@sync to HEAD...
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d41 1
a41 1
static const char libbu_rb_walk_RCSid[] = "@@(#) $Header: /n/cad/c/CVS/brlcad/libbu/rb_walk.c,v 11.12 2004/02/02 17:39:07 morrison Exp $";
@


11.11.10.1
log
@merge from HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d41 1
a41 1
static const char libbu_rb_walk_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_walk.c,v 11.12 2004/02/02 17:39:07 morrison Exp $";
@


11.11.10.2
log
@merge from head
@
text
@d41 1
a41 1
static const char libbu_rb_walk_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_walk.c,v 11.11.10.1 2004/02/12 18:39:19 erikg Exp $";
@


11.11.2.1
log
@Initial ANSIfication
@
text
@d41 1
a41 1
static const char libbu_rb_walk_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_walk.c,v 11.11 2002/08/20 17:07:42 jra Exp $";
d58 7
a64 1
static void prewalknodes (struct bu_rb_node *root, int order, void (*visit) (/* ??? */), int depth)
d80 7
a86 1
static void inwalknodes (struct bu_rb_node *root, int order, void (*visit) (/* ??? */), int depth)
d102 7
a108 1
static void postwalknodes (struct bu_rb_node *root, int order, void (*visit) (/* ??? */), int depth)
d124 7
a130 1
static void prewalkdata (struct bu_rb_node *root, int order, void (*visit) (/* ??? */), int depth)
d146 7
a152 1
static void inwalkdata (struct bu_rb_node *root, int order, void (*visit) (/* ??? */), int depth)
d168 7
a174 1
static void postwalkdata (struct bu_rb_node *root, int order, void (*visit) (/* ??? */), int depth)
d199 8
a206 1
void _rb_walk (bu_rb_tree *tree, int order, void (*visit) (/* ??? */), int what_to_visit, int trav_type)
d250 7
a256 1
void bu_rb_walk (bu_rb_tree *tree, int order, void (*visit) (/* ??? */), int trav_type)
@


11.11.2.2
log
@sync branch with HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d41 1
a41 1
static const char libbu_rb_walk_RCSid[] = "@@(#) $Header$";
@


11.10
log
@Converted from K&R to ANSI C - RFH
@
text
@d58 7
a64 1
static void prewalknodes (struct bu_rb_node *root, int order, void (*visit) (/* ??? */), int depth)
d80 7
a86 1
static void inwalknodes (struct bu_rb_node *root, int order, void (*visit) (/* ??? */), int depth)
d102 7
a108 1
static void postwalknodes (struct bu_rb_node *root, int order, void (*visit) (/* ??? */), int depth)
d124 7
a130 1
static void prewalkdata (struct bu_rb_node *root, int order, void (*visit) (/* ??? */), int depth)
d146 7
a152 1
static void inwalkdata (struct bu_rb_node *root, int order, void (*visit) (/* ??? */), int depth)
d168 7
a174 1
static void postwalkdata (struct bu_rb_node *root, int order, void (*visit) (/* ??? */), int depth)
d199 8
a206 1
void _rb_walk (bu_rb_tree *tree, int order, void (*visit) (/* ??? */), int what_to_visit, int trav_type)
d250 7
a256 1
void bu_rb_walk (bu_rb_tree *tree, int order, void (*visit) (/* ??? */), int trav_type)
@


11.9
log
@LINT
@
text
@d41 1
a41 1
static const char libbu_rb_walk_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_walk.c,v 11.8 2000/03/28 18:55:10 mike Exp $";
d58 1
a58 7
static void prewalknodes (root, order, visit, depth)

struct bu_rb_node	*root;
int			order;
void			(*visit)();
int			depth;

d74 1
a74 7
static void inwalknodes (root, order, visit, depth)

struct bu_rb_node	*root;
int			order;
void			(*visit)();
int			depth;

d90 1
a90 7
static void postwalknodes (root, order, visit, depth)

struct bu_rb_node	*root;
int			order;
void			(*visit)();
int			depth;

d106 1
a106 7
static void prewalkdata (root, order, visit, depth)

struct bu_rb_node	*root;
int			order;
void			(*visit)();
int			depth;

d122 1
a122 7
static void inwalkdata (root, order, visit, depth)

struct bu_rb_node	*root;
int			order;
void			(*visit)();
int			depth;

d138 1
a138 7
static void postwalkdata (root, order, visit, depth)

struct bu_rb_node	*root;
int			order;
void			(*visit)();
int			depth;

d163 1
a163 8
void _rb_walk (tree, order, visit, what_to_visit, trav_type)

bu_rb_tree	*tree;
int		order;
void		(*visit)();
int		what_to_visit;
int		trav_type;

d207 1
a207 7
void bu_rb_walk (tree, order, visit, trav_type)

bu_rb_tree	*tree;
int		order;
void		(*visit)();
int		trav_type;

@


11.8
log
@
Put libbu_filename_ prefixes on RCSid variables.
@
text
@d41 1
a41 1
static char libbu_rb_walk_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_walk.c,v 11.7 1999/01/12 16:19:56 pjt Exp $";
@


11.7
log
@Various details concerning folding libredblack into libbu
@
text
@d41 1
a41 1
static char RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_walk.c,v 11.6 1998/12/30 01:25:46 mike Exp $";
@


11.6
log
@LibRedBlack routines now have a bu_ prefix.
@
text
@d1 1
a1 1
/*			B U _ R B _ W A L K . C
d41 1
a41 1
static char RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_walk.c,v 11.5 1996/08/27 07:10:51 mike Exp $";
@


11.5
log
@Changed over to bu.h
@
text
@d1 1
a1 1
/*			R B _ W A L K . C
d5 19
a23 1
 *	The function rb_walk() is defined in terms of the function
a38 3
 *
 *	Author:	Paul Tanenbaum
 *
d41 1
a41 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_walk.c,v 11.4 1995/09/20 12:02:21 pjt Exp pjt $";
a51 1
#include "redblack.h"
d60 4
a63 4
struct rb_node	*root;
int		order;
void		(*visit)();
int		depth;
d66 2
a67 2
    RB_CKMAG(root, RB_NODE_MAGIC, "red-black node");
    RB_CKORDER(root -> rbn_tree, order);
d69 1
a69 1
    if (root == rb_null(root -> rbn_tree))
d72 2
a73 2
    prewalknodes (rb_left_child(root, order), order, visit, depth + 1);
    prewalknodes (rb_right_child(root, order), order, visit, depth + 1);
d82 4
a85 4
struct rb_node	*root;
int		order;
void		(*visit)();
int		depth;
d88 2
a89 2
    RB_CKMAG(root, RB_NODE_MAGIC, "red-black node");
    RB_CKORDER(root -> rbn_tree, order);
d91 1
a91 1
    if (root == rb_null(root -> rbn_tree))
d93 1
a93 1
    inwalknodes (rb_left_child(root, order), order, visit, depth + 1);
d95 1
a95 1
    inwalknodes (rb_right_child(root, order), order, visit, depth + 1);
d104 4
a107 4
struct rb_node	*root;
int		order;
void		(*visit)();
int		depth;
d110 2
a111 2
    RB_CKMAG(root, RB_NODE_MAGIC, "red-black node");
    RB_CKORDER(root -> rbn_tree, order);
d113 1
a113 1
    if (root == rb_null(root -> rbn_tree))
d115 2
a116 2
    postwalknodes (rb_left_child(root, order), order, visit, depth + 1);
    postwalknodes (rb_right_child(root, order), order, visit, depth + 1);
d126 4
a129 4
struct rb_node	*root;
int		order;
void		(*visit)();
int		depth;
d132 2
a133 2
    RB_CKMAG(root, RB_NODE_MAGIC, "red-black node");
    RB_CKORDER(root -> rbn_tree, order);
d135 1
a135 1
    if (root == rb_null(root -> rbn_tree))
d137 3
a139 3
    visit(rb_data(root, order), depth);
    prewalkdata (rb_left_child(root, order), order, visit, depth + 1);
    prewalkdata (rb_right_child(root, order), order, visit, depth + 1);
d148 4
a151 4
struct rb_node	*root;
int		order;
void		(*visit)();
int		depth;
d154 2
a155 2
    RB_CKMAG(root, RB_NODE_MAGIC, "red-black node");
    RB_CKORDER(root -> rbn_tree, order);
d157 1
a157 1
    if (root == rb_null(root -> rbn_tree))
d159 3
a161 3
    inwalkdata (rb_left_child(root, order), order, visit, depth + 1);
    visit(rb_data(root, order), depth);
    inwalkdata (rb_right_child(root, order), order, visit, depth + 1);
d170 4
a173 4
struct rb_node	*root;
int		order;
void		(*visit)();
int		depth;
d176 2
a177 2
    RB_CKMAG(root, RB_NODE_MAGIC, "red-black node");
    RB_CKORDER(root -> rbn_tree, order);
d179 1
a179 1
    if (root == rb_null(root -> rbn_tree))
d181 3
a183 3
    postwalkdata (rb_left_child(root, order), order, visit, depth + 1);
    postwalkdata (rb_right_child(root, order), order, visit, depth + 1);
    visit(rb_data(root, order), depth);
d197 1
a197 1
 *	by rb_diagnose_tree() in rb_diag.c.
d201 5
a205 5
rb_tree	*tree;
int	order;
void	(*visit)();
int	what_to_visit;
int	trav_type;
d214 2
a215 2
    RB_CKMAG(tree, RB_TREE_MAGIC, "red-black tree");
    RB_CKORDER(tree, order);
d226 1
a226 1
			(rb_root(tree, order), order, visit, 0);
d229 1
a229 1
		    rt_log("FATAL: _rb_walk(): Illegal visitation object: %d\n",
d235 1
a235 1
	    rt_log("FATAL: _rb_walk(): Illegal traversal type: %d\n",
d241 1
a241 1
/*		        R B _ W A L K ( )
d250 1
a250 1
void rb_walk (tree, order, visit, trav_type)
d252 4
a255 4
rb_tree	*tree;
int	order;
void	(*visit)();
int	trav_type;
d258 2
a259 2
    RB_CKMAG(tree, RB_TREE_MAGIC, "red-black tree");
    RB_CKORDER(tree, order);
@


11.4
log
@Added comment that _rb_walk() is intentionally not static
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_walk.c,v 11.3 1995/07/10 20:17:51 pjt Exp pjt $";
d35 2
@


11.3
log
@Must now include rtlist.h before redblack.h
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_walk.c,v 11.2 1995/04/19 19:03:56 pjt Exp $";
d179 3
@


11.2
log
@include machine.h
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_walk.c,v 11.1 95/01/04 10:05:58 mike Rel4_4 $";
d34 1
@


11.1
log
@Release_4.4
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_walk.c,v 2.6 94/12/30 16:41:04 stay Exp $";
d33 1
@


2.6
log
@deleted reference to stdlib, it wil be included in conf.h if
it exists or is STDC
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_walk.c,v 2.5 1994/09/26 12:21:10 jra Exp stay $";
@


2.5
log
@Added #include "conf.h"
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_walk.c,v 2.4 94/09/22 15:46:55 jra Exp Locker: jra $";
a30 1
#include <stdlib.h>
@


2.4
log
@Fixed a few typos.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_walk.c,v 2.3 94/09/22 15:34:50 pjt Exp Locker: jra $";
d28 2
@


2.3
log
@Changed "#include "rt_internals.h" to "#include "./rt_internals.h"
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_walk.c,v 2.2 94/09/22 15:27:13 pjt Exp Locker: pjt $";
d63 2
a64 2
(struct rb_node	*root;
int		order,
d177 1
a177 1
void _rb_walk (tree, order, *visit, what_to_visit, trav_type)
@


2.2
log
@Replaced prototype-type definition with K&R type
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_walk.c,v 2.1 93/03/25 11:03:32 pjt Exp $";
d33 1
a33 1
#include "rb_internals.h"
@


2.1
log
@Installed into BRL CAD tree
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_walk.c,v 1.8 93/03/25 11:00:27 pjt Exp Locker: pjt $";
d39 7
a45 3
static void prewalknodes
	    (struct rb_node *root, int order,
	    void (*visit)(), int depth)
d61 7
a67 3
static void inwalknodes
	    (struct rb_node *root, int order,
	    void (*visit)(), int depth)
d83 7
a89 3
static void postwalknodes
	    (struct rb_node *root, int order,
	    void (*visit)(), int depth)
d105 7
a111 3
static void prewalkdata
	    (struct rb_node *root, int order,
	    void (*visit)(), int depth)
d127 7
a133 3
static void inwalkdata
	    (struct rb_node *root, int order,
	    void (*visit)(), int depth)
d149 7
a155 3
static void postwalkdata
	    (struct rb_node *root, int order,
	    void (*visit)(), int depth)
d177 8
a184 3
void _rb_walk
    (rb_tree *tree, int order, void (*visit)(),
     int what_to_visit, int trav_type)
d228 7
a234 3
void rb_walk
	(rb_tree *tree, int order, void (*visit)(),
	int trav_type)
@


1.8
log
@Added authorship comment
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_walk.c,v 1.7 93/01/15 13:08:09 pjt zero_1 Locker: pjt $";
@


1.7
log
@1. Switched from fprintf(stderr, ) to rt_log()
2. Added comments and general clean up
@
text
@d21 3
d26 1
a26 1
static char RCSid[] = "@@(#) $Header: /arl/pjt/libredblack/RCS/rb_walk.c,v 1.6 93/01/15 10:42:10 pjt Exp Locker: pjt $";
@


1.6
log
@Implemented all three traversal types: preorder, inorder, and postorder
@
text
@d19 2
a20 2
 *	walking, the function to apply at each visit, and a block of
 *	data to pass to the visit function.
d23 1
a23 1
static char RCSid[] = "@@(#) $Header: /arl/pjt/libredblack/RCS/rb_walk.c,v 1.5 93/01/14 10:51:16 pjt Exp Locker: pjt $";
d144 1
a144 1
 *	This function has six parameters: the tree to traverse,
d147 2
a148 2
 *	(or just to its data), the type of traversal, and a data block
 *	to pass to the visit function.
d175 1
a175 2
		    fprintf(stderr,
			" _rb_walk(): Illegal visitation object: %d\n",
d181 2
a182 2
	    fprintf(stderr,
		" _rb_walk(): Illegal traversal type: %d\n", trav_type);
d191 1
a191 1
 *	This function has five parameters: the tree to traverse,
d193 2
a194 2
 *	to each node, the type of traversal, and a block of data to
 *	pass to the visit function.
@


1.5
log
@1. Added calls to RB_CKORDER()
2. Made execution of body of _rb_walk() unconditional
@
text
@d3 1
a3 1
 *	Written by:	Paul Tanenbaum
d5 16
a20 1
 *  $Header: /arl/pjt/libredblack/RCS/rb_walk.c,v 1.4 93/01/14 09:22:55 pjt Exp Locker: pjt $
d22 3
d32 1
a32 1
/*		        _ R B _ W A L K ( )
d34 17
a50 1
 *	    Perform an inorder tree walk on a red-black tree
d52 1
a52 3
 *	This function has three parameters: the root of the tree
 *	to traverse, the order on which to do the walking, and the
 *	function to apply to the data in each node.
d54 3
a56 1
static void _rb_walk (struct rb_node *root, int order, void (*visit)())
d58 2
d61 15
d81 3
a83 3
    _rb_walk (rb_left_child(root, order), order, visit);
    visit(rb_data(root, order));
    _rb_walk (rb_right_child(root, order), order, visit);
d86 1
a86 1
/*		        R B _ W A L K ( )
d88 17
a104 1
 *	        Applications interface to _rb_walk()
d106 1
a106 3
 *	This function has three parameters: the tree to traverse,
 *	the order on which to do the walking, and the function to
 *	apply to each node.
d108 3
a110 1
void rb_walk (rb_tree *tree, int order, void (*visit)())
d112 2
d115 45
d162 25
d188 17
a204 1
    _rb_walk(rb_root(tree, order), order, visit);
@


1.4
log
@1. Added check for rb_null in rb_walk()
2. Switched to rb_data()
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/rb_walk.c,v 1.3 92/11/06 13:55:37 pjt Exp Locker: pjt $
d25 8
a32 10
    /* Check data type of the parameter "root" */
    if (root != 0)
    {
	RB_CKMAG(root, RB_NODE_MAGIC, "red-black node");
	if (root == rb_null(root -> rbn_tree))
	    return;
	_rb_walk (rb_left_child(root, order), order, visit);
	visit(rb_data(root, order));
	_rb_walk (rb_right_child(root, order), order, visit);
    }
d47 2
@


1.3
log
@Made _rb_walk static
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/rb_walk.c,v 1.2 92/11/05 11:32:43 pjt Exp Locker: pjt $
d29 2
d32 1
a32 1
	visit(root -> rbn_data);
@


1.2
log
@Replaced reference to rbt_root by call to rb_root()
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/rb_walk.c,v 1.1 92/11/04 12:14:22 pjt Exp Locker: pjt $
d20 1
a20 1
 *	function to apply to each node.
d22 1
a22 1
void _rb_walk (struct rb_node *root, int order, void (*visit)())
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/rb_create.c,v 1.2 92/11/04 10:48:18 pjt Exp Locker: pjt $
d47 1
a47 1
    _rb_walk(tree -> rbt_root, order, visit);
@
