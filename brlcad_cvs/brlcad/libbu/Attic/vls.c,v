head	1.35;
access;
symbols
	ansi-20040405-merged:1.31.2.3
	postmerge-20040405-ansi:1.33
	premerge-20040404-ansi:1.32
	postmerge-autoconf:1.32
	autoconf-freeze:1.31.10.2
	premerge-autoconf:1.32
	ansi-20040316-freeze:1.31.2.1
	postmerge-20040315-windows:1.32
	premerge-20040315-windows:1.32
	windows-20040315-freeze:1.31.4.1
	autoconf-20031203:1.31
	autoconf-20031202:1.31
	autoconf-branch:1.31.0.10
	phong-branch:1.31.0.8
	photonmap-branch:1.31.0.6
	rel-6-1-DP:1.31
	windows-branch:1.31.0.4
	rel-6-0-2:1.29
	ansi-branch:1.31.0.2
	rel-6-0-1-branch:1.29.0.2
	hartley-6-0-post:1.30
	hartley-6-0-pre:1.29
	rel-6-0-1:1.29
	rel-6-0:1.29
	rel-5-4:1.21
	offsite-5-3-pre:1.24
	rel-5-3:1.21
	rel-5-2:1.21
	rel-5-1-branch:1.21.0.2
	rel-5-1:1.21
	rel-5-0:1.17
	rel-5-0-beta:1.17
	rel-4-5:1.12
	ctj-4-5-post:1.10
	ctj-4-5-pre:1.10;
locks; strict;
comment	@ * @;


1.35
date	2004.05.21.18.06.25;	author morrison;	state dead;
branches;
next	1.34;

1.34
date	2004.05.10.15.30.44;	author erikg;	state Exp;
branches;
next	1.33;

1.33
date	2004.04.05.07.46.16;	author morrison;	state Exp;
branches;
next	1.32;

1.32
date	2004.02.03.17.22.03;	author morrison;	state Exp;
branches;
next	1.31;

1.31
date	2002.08.20.17.07.42;	author jra;	state Exp;
branches
	1.31.2.1
	1.31.4.1
	1.31.10.1;
next	1.30;

1.30
date	2002.08.15.20.54.55;	author hartley;	state Exp;
branches;
next	1.29;

1.29
date	2001.11.05.20.11.36;	author bparker;	state Exp;
branches;
next	1.28;

1.28
date	2001.11.02.05.01.37;	author butler;	state Exp;
branches;
next	1.27;

1.27
date	2001.08.11.13.11.15;	author butler;	state Exp;
branches;
next	1.26;

1.26
date	2001.04.20.22.29.07;	author morrison;	state Exp;
branches;
next	1.25;

1.25
date	2001.03.23.22.34.15;	author butler;	state Exp;
branches;
next	1.24;

1.24
date	2000.08.23.23.43.12;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	2000.07.11.23.12.39;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	2000.07.07.05.20.14;	author cjohnson;	state Exp;
branches;
next	1.21;

1.21
date	2000.03.28.19.13.20;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	2000.03.28.18.56.37;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	2000.01.07.20.54.09;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	99.12.29.20.17.12;	author jra;	state Exp;
branches;
next	1.17;

1.17
date	99.01.22.21.55.21;	author butler;	state Exp;
branches;
next	1.16;

1.16
date	99.01.08.16.13.01;	author bparker;	state Exp;
branches;
next	1.15;

1.15
date	99.01.04.20.41.05;	author bparker;	state Exp;
branches;
next	1.14;

1.14
date	98.11.19.05.22.49;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	98.03.25.02.55.34;	author butler;	state Exp;
branches;
next	1.12;

1.12
date	97.12.04.12.50.40;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	97.07.29.03.34.11;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	97.04.17.09.29.18;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	97.04.16.06.56.04;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	97.04.04.19.43.20;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	97.04.04.06.00.11;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	97.04.04.05.35.48;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	97.04.04.04.56.02;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	97.02.13.00.34.32;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	96.11.28.08.04.12;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	96.08.28.09.49.13;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	96.08.27.06.18.33;	author mike;	state Exp;
branches;
next	;

1.31.2.1
date	2002.09.19.18.01.15;	author morrison;	state Exp;
branches;
next	1.31.2.2;

1.31.2.2
date	2004.03.17.21.16.51;	author morrison;	state Exp;
branches;
next	1.31.2.3;

1.31.2.3
date	2004.04.05.00.50.06;	author morrison;	state Exp;
branches;
next	;

1.31.4.1
date	2004.03.11.23.41.50;	author morrison;	state Exp;
branches;
next	;

1.31.10.1
date	2004.02.12.18.39.19;	author erikg;	state Exp;
branches;
next	1.31.10.2;

1.31.10.2
date	2004.03.15.14.06.17;	author erikg;	state Exp;
branches;
next	;


desc
@vls.c
@


1.35
log
@moved to src/
@
text
@/*
 *			V L S . C
 *
 *  The variable length string package.
 *
 *  Assumption:  libc-provided sprintf() function is safe to use in parallel,
 *  on parallel systems.
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Status -
 *      Public Domain, Distribution Unlimitied.
 */
static const char libbu_vls_RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libbu/vls.c,v 1.34 2004/05/10 15:30:44 erikg Exp $ (BRL)";

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <ctype.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#if defined(HAVE_STDARG_H)
/* ANSI C */
# include <stdarg.h>
#endif
#if !defined(HAVE_STDARG_H) && defined(HAVE_VARARGS_H)
/* VARARGS */
# include <varargs.h>
#endif

#include "machine.h"
#include "externs.h"
#include "bu.h"

#if defined(HAVE_VARARGS_H) || defined(HAVE_STDARG_H)
BU_EXTERN(void	bu_vls_vprintf, (struct bu_vls *vls, const char *fmt, va_list ap));
#endif

const char bu_vls_message[] = "bu_vls_str";
extern const char bu_strdup_message[];

/*
 *			B U _ V L S _ I N I T
 *
 *  No storage should be allocated at this point,
 *  and bu_vls_addr() must be able to live with that.
 */
void
bu_vls_init(register struct bu_vls *vp)
{
	if (vp == (struct bu_vls  *)NULL)
		bu_bomb("bu_vls_init() passed NULL pointer");

	vp->vls_magic = BU_VLS_MAGIC;
	vp->vls_str = (char *)0;
	vp->vls_len = vp->vls_max = 0;
	vp->vls_offset = 0;
}

/*
 *			B U _ V L S _ I N I T _ I F _ U N I N I T
 *
 *  If a VLS is unitialized, initialize it.
 *  If it is already initialized, leave it alone, caller wants to
 *  append to it.
 */
void
bu_vls_init_if_uninit(register struct bu_vls *vp)
{
	if (vp == (struct bu_vls  *)NULL)
		bu_bomb("bu_vls_init_if_uninit() passed NULL pointer");

	if( vp->vls_magic == BU_VLS_MAGIC )  return;
	bu_vls_init( vp );
}


/*
 *			B U _ V L S _ V L S I N I T
 *
 *  Allocate storage for a struct bu_vls, call bu_vls_init on it, and return
 *  the result.  Allows for creation of dynamically allocated vls strings.
 */
struct bu_vls *
bu_vls_vlsinit(void)
{
	register struct bu_vls	*vp;	

	vp = (struct bu_vls *)bu_malloc(sizeof(struct bu_vls), "bu_vls_vlsinit struct");
	bu_vls_init(vp);

	return vp;
}

/*
 *			B U _ V L S _ A D D R
 *
 *  Return a pointer to the null-terminated string in the vls array.
 *  If no storage has been allocated yet, give back a valid string.
 */
char *
bu_vls_addr(register const struct bu_vls *vp)
{
	static char	nullbuf[4];

	BU_CK_VLS(vp);

	if( vp->vls_max == 0 || vp->vls_str == (char *)NULL )  {
		/* A zero-length VLS is a null string */
		nullbuf[0] = '\0';
		return(nullbuf);
	}

	/* Sanity checking */
	if( vp->vls_max < 0 ||
		vp->vls_len < 0 ||
		vp->vls_offset < 0 ||
		vp->vls_str == (char *)NULL ||
		vp->vls_len + vp->vls_offset >= vp->vls_max )  {
		bu_log("bu_vls_addr: bad VLS.  max=%d, len=%d, offset=%d\n",
		   vp->vls_max, vp->vls_len, vp->vls_offset);
		bu_bomb("bu_vls_addr\n");
	}

	return( vp->vls_str+vp->vls_offset );
}

/*
 *			B U _ V L S _ E X T E N D
 */
void
bu_vls_extend(register struct bu_vls *vp, unsigned int extra)
{
	BU_CK_VLS(vp);
	if( extra < 40 )  extra = 40;
	if( vp->vls_max <= 0 || vp->vls_str == (char *)0 )  {
		vp->vls_max = extra;
		vp->vls_str = (char *)bu_malloc( vp->vls_max, bu_vls_message );
		vp->vls_len = 0;
		vp->vls_offset = 0;
		*vp->vls_str = '\0';
		return;
	}
	if( vp->vls_offset + vp->vls_len + extra >= vp->vls_max )  {
		vp->vls_max += extra;
		if( vp->vls_max < 120 )  vp->vls_max = 120;
		vp->vls_str = (char *)bu_realloc( vp->vls_str, vp->vls_max,
			bu_vls_message );
	}
}

/*
 *			B U _ V L S _ S E T L E N
 *
 *  Ensure that the vls has a length of at least 'newlen', and make
 *  that the current length.
 *  Useful for subroutines that are planning on mucking with the data
 *  array themselves.  Not advisable, but occasionally useful.
 *  Does not change the offset from the front of the buffer, if any.
 *  Does not initialize the value of any of the new bytes.
 */
void
bu_vls_setlen(struct bu_vls *vp, int newlen)
{
	BU_CK_VLS(vp);
	if( vp->vls_len >= newlen )  return;
	bu_vls_extend( vp, newlen - vp->vls_len );
	vp->vls_len = newlen;
}

/*
 *			B U _ V L S _ S T R L E N
 *
 *  Return length of the string, in bytes, not including the null terminator.
 */
int
bu_vls_strlen(register const struct bu_vls *vp)
{
	BU_CK_VLS(vp);
	if( vp->vls_len <= 0 )  return  0;
	return  vp->vls_len;
}

/*
 *			B U _ V L S _ T R U N C
 *
 *  Truncate string to at most 'len' characters.
 *  If 'len' is negative, trim off that many from the end.
 *  If 'len' is zero, don't release storage -- user is probably
 *  just going to refill it again, e.g. with bu_vls_gets().
 */
void
bu_vls_trunc(register struct bu_vls *vp, int len)
{
	BU_CK_VLS(vp);
	if( len < 0 )  len = vp->vls_len + len;	/* now an absolute length */
	if( vp->vls_len <= len )  return;
	if( len == 0 )  vp->vls_offset = 0;
	vp->vls_str[len+vp->vls_offset] = '\0';	/* force null termination */
	vp->vls_len = len;
}

/*
 *			B U _ V L S _ T R U N C 2
 *
 *  Son of bu_vls_trunc.
 *  Same as bu_vls_trunc except that it doesn't take negative len.
 */
void
bu_vls_trunc2(register struct bu_vls *vp, int len)
{
	BU_CK_VLS(vp);
	if( vp->vls_len <= len )  return;
	if( len < 0 )  len = 0;
	if( len == 0 )  vp->vls_offset = 0;
	vp->vls_str[len+vp->vls_offset] = '\0';	/* force null termination */
	vp->vls_len = len;
}

/*
 *			B U _ V L S _ N I B B L E
 *
 *  "Nibble" 'len' characters off the front of the string.
 *  Changes the length and offset;  no data is copied.
 *  'len' may be positive or negative.
 *  If negative, characters are un-nibbled.
 */
void
bu_vls_nibble(register struct bu_vls *vp, int len)
{
	BU_CK_VLS(vp);
	if( len < 0 && (-len) > vp->vls_offset )  len = -vp->vls_offset;
	if (len >= vp->vls_len) {
		bu_vls_trunc( vp, 0 );
		return;
	}
	vp->vls_len -= len;
	vp->vls_offset += len;
}
/*
 *			B U _ V L S _ F R E E
 *
 *  Releases the memory used for the string buffer.
 */
void
bu_vls_free(register struct bu_vls *vp)
{
	BU_CK_VLS(vp);
	if( vp->vls_str )  {
		vp->vls_str[0] = '?';		/* Sanity */
		bu_free( vp->vls_str, "bu_vls_free" );
		vp->vls_str = (char *)0;
	}
	vp->vls_offset = vp->vls_len = vp->vls_max = 0;
}

/*
 *			B U _ V L S _ V L S F R E E
 *
 *  Releases the memory used for the string buffer and the memory for
 *  the vls structure
 */
void
bu_vls_vlsfree(register struct bu_vls *vp)
{
	if ( *(long *)vp != BU_VLS_MAGIC) return;

	bu_vls_free( vp );
	bu_free( vp, "bu_vls_vlsfree" );
}

/*			B U _ V L S _ S T R D U P
 *
 *  Make an "ordinary" string copy of a vls string.  Storage for the regular
 *  string is acquired using malloc.
 *  The source string is not affected.
 */
char *
bu_vls_strdup(register const struct bu_vls *vp)
{
	register char *str;
	register int len;

	len = bu_vls_strlen(vp);
	str = bu_malloc(len+1, bu_strdup_message );
	strncpy(str, bu_vls_addr(vp), len);
	str[len] = '\0';
	return str;
}

/*
 *			B U _ V L S _ S T R G R A B
 *
 *  Like bu_vls_strdup(), but destructively grab the string from the
 *  source argument 'vp'.  This is more efficient than bu_vls_strdup() for
 *  those instances where the source argument 'vp' is no longer needed
 *  by the caller, as it avoides a potentially long buffer copy.
 *
 *  The source string is destroyed, as if bu_vls_free() had been called.
 */
char *
bu_vls_strgrab(register struct bu_vls *vp)
{
	register char *str;

	BU_CK_VLS(vp);
	if( vp->vls_offset != 0 )  {
		str = bu_vls_strdup( vp );
		bu_vls_free( vp );
		return str;
	}

	str = bu_vls_addr( vp );
	vp->vls_str = (char *)0;
	vp->vls_offset = vp->vls_len = vp->vls_max = 0;
	return str;
}

/*
 *			B U _ V L S _ S T R C P Y
 *
 *  Empty the vls string, and copy in a regular string.
 */
void
bu_vls_strcpy(register struct bu_vls *vp, const char *s)
{
	register int	len;

	BU_CK_VLS(vp);
	if( s == (const char *)NULL )  return;
	if( (len = strlen(s)) <= 0 )  {
		vp->vls_len = 0;
		vp->vls_offset = 0;
		if(vp->vls_max > 0)
			vp->vls_str[0] = '\0';
		return;
	}
	vp->vls_offset = 0;		/* cancel offset before extending */
	if( len+1 >= vp->vls_max )  bu_vls_extend( vp, len+1 );
	bcopy( s, vp->vls_str, len+1 );		/* include null */
	vp->vls_len = len;
}

/*
 *			B U _ V L S _ S T R N C P Y
 *
 *  Empty the vls string, and copy in a regular string, up to N bytes long.
 */
void
bu_vls_strncpy(register struct bu_vls *vp, const char *s, long int n)
{
	register int	len;

	BU_CK_VLS(vp);
	if( s == (const char *)NULL )  return;
	len = strlen(s);
	if( len > n )  len = n;
	if( len <= 0 )  {
		vp->vls_len = 0;	/* ensure string is empty */
		return;
	}
	vp->vls_offset = 0;		/* cancel offset before extending */
	if( len+1 >= vp->vls_max )  bu_vls_extend( vp, len+1 );
	bcopy( s, vp->vls_str, len );
	vp->vls_str[len] = '\0';		/* force null termination */
	vp->vls_len = len;
}

/*
 *			B U _ V L S _ S T R C A T
 *
 *  Concatenate a new string onto the end of the existing vls string.
 */
void
bu_vls_strcat(register struct bu_vls *vp, const char *s)
{
	register int	len;

	BU_CK_VLS(vp);
	if( s == (const char *)NULL )  return;
	if( (len = strlen(s)) <= 0 )  return;
	if( vp->vls_offset + vp->vls_len + len+1 >= vp->vls_max )
		bu_vls_extend( vp, len+1 );
	bcopy( s, vp->vls_str +vp->vls_offset + vp->vls_len, len+1 );	/* include null */
	vp->vls_len += len;
}

/*
 *			B U _ V L S _ S T R N C A T
 *
 *  Concatenate a new string onto the end of the existing vls string.
 */
void
bu_vls_strncat(register struct bu_vls *vp, const char *s, long int n)
{
	register int	len;

	BU_CK_VLS(vp);
	if( s == (const char *)NULL )  return;
	len = strlen(s);
	if( len > n )  len = n;
	if( len <= 0 )  return;			/* do nothing */
	if( vp->vls_offset + vp->vls_len + len+1 >= vp->vls_max )
		bu_vls_extend( vp, len+1 );
	bcopy( s, vp->vls_str + vp->vls_offset + vp->vls_len, len );
	vp->vls_len += len;
	vp->vls_str[vp->vls_offset + vp->vls_len] = '\0';	/* force null termination */
}

/*
 *			B U _ V L S _ V L S C A T
 *
 *  Concatenate a new vls string onto the end of an existing vls string.
 *  The storage of the source string is not affected.
 */
void
bu_vls_vlscat(register struct bu_vls *dest, register const struct bu_vls *src)
{
	BU_CK_VLS(src);
	BU_CK_VLS(dest);
	if( src->vls_len <= 0 )  return;
	if( dest->vls_offset + dest->vls_len + src->vls_len+1 >= dest->vls_max )
		bu_vls_extend( dest, src->vls_len+1 );
	/* copy source string, including null */
	bcopy( src->vls_str+src->vls_offset,
		dest->vls_str +dest->vls_offset + dest->vls_len,
		src->vls_len+1 );
	dest->vls_len += src->vls_len;
}

/*
 *			V L S _ V L S C A T Z A P
 *
 *  Concatenate a new vls string onto the end of an existing vls string.
 *  The storage of the source string is released (zapped).
 */
void
bu_vls_vlscatzap(register struct bu_vls *dest, register struct bu_vls *src)
{
	BU_CK_VLS(src);
	BU_CK_VLS(dest);
	if( src->vls_len <= 0 )  return;
	bu_vls_vlscat( dest, src );
	bu_vls_trunc( src, 0 );
}

/*
 *			B U _ V L S _ F R O M _ A R G V
 *
 *  Given and argc & argv pair, convert them into a vls string of space-
 *  separated words.
 */
void
bu_vls_from_argv(register struct bu_vls *vp, int argc, char **argv)
{
	BU_CK_VLS(vp);
	for( ; argc > 0; argc--, argv++ )  {
		bu_vls_strcat( vp, *argv );
		if( argc > 1 )  bu_vls_strcat( vp, " " );
	}
}

/*
 *			B U _ A R G V _ F R O M _ S T R I N G
 *
 *  Build argv[] array from input buffer, by splitting whitespace
 *  separated "words" into null terminated strings.
 *  The input buffer is altered by this process.
 *  The argv[] array points into the input buffer.
 *  The input buffer should not be freed until argv has been freed
 *  or passes out of scope.
 *
 *  'lim' indicates the number of elements in the argv[] array.
 *
 *  Returns -
 *	 0	no words in input
 *	nwords	number of words of input, now in argv[]
 *
 *  Built from rt_split_cmd(), but without the shell escape support.
 */
int
bu_argv_from_string(char **argv, int lim, register char *lp)
{
	register int	nwords;			/* number of words seen */
	register char	*lp1;

	argv[0] = "_NIL_";		/* sanity */

	while( *lp != '\0' && isspace( *lp ) )
		lp++;

	if( *lp == '\0' )
		return 0;		/* No words */

	/* some non-space string has been seen, argv[0] is set */
	nwords = 1;
	argv[0] = lp;

	for( ; *lp != '\0'; lp++ )  {
		if( !isspace( *lp ) )
			continue;	/* skip over current word */

		*lp = '\0';		/* terminate current word */
		lp1 = lp + 1;
		if( *lp1 != '\0' && !isspace( *lp1 ) )  {
			/* Begin next word */
			if( nwords >= lim-1 )
				break;	/* argv[] full */

			argv[nwords++] = lp1;
		}
	}
	argv[nwords] = (char *)0;	/* safety */
	return nwords;
}

/*
 *			B U _ V L S _ F W R I T E
 */
void
bu_vls_fwrite(FILE *fp, const struct bu_vls *vp)
{
	int status;

	BU_CK_VLS(vp);
	if( vp->vls_len <= 0 )  return;

	bu_semaphore_acquire(BU_SEM_SYSCALL);
	status = fwrite( vp->vls_str + vp->vls_offset, vp->vls_len, 1, fp );
	bu_semaphore_release(BU_SEM_SYSCALL);

	if( status != 1 ) {    
		perror("fwrite");
		bu_bomb("bu_vls_fwrite() write error\n");
	}
}

/*
 *			B U _ V L S _ W R I T E
 */
void
bu_vls_write( int fd, const struct bu_vls *vp )
{

	BU_CK_VLS(vp);
	if( vp->vls_len <= 0 )  return;

#if !defined(HAVE_UNIX_IO)
	bu_bomb("bu_vls_write(): This isn't UNIX\n");
#else
	{
	    int status;
	    bu_semaphore_acquire(BU_SEM_SYSCALL);
	    status = write( fd, vp->vls_str + vp->vls_offset, vp->vls_len );
	    bu_semaphore_release(BU_SEM_SYSCALL);

	    if( status != vp->vls_len ) {    
		perror("write");
		bu_bomb("bu_vls_write() write error\n");
	    }
	}
#endif
}

/*
 *			B U _ V L S _ R E A D
 *
 *  Read the remainder of a UNIX file onto the end of a vls.
 *
 *  Returns -
 *	nread	number of characters read
 *	0	if EOF encountered immediately
 *	-1	read error
 */
int
bu_vls_read( struct bu_vls *vp, int fd )
{
	int	ret = 0;

	BU_CK_VLS(vp);

#if !defined(HAVE_UNIX_IO)
	bu_bomb("bu_vls_read(): This isn't UNIX\n");
#else
	{
	    int	todo;
	    int	got;
	    for(;;)  {
		bu_vls_extend( vp, 4096 );
		todo = vp->vls_max - vp->vls_len - vp->vls_offset - 1;

		bu_semaphore_acquire(BU_SEM_SYSCALL);
		got = read(fd, vp->vls_str+vp->vls_offset+vp->vls_len, todo );
		bu_semaphore_release(BU_SEM_SYSCALL);

		if( got < 0 )  {
			/* Read error, abandon the read */
			return -1;
		}
		if(got == 0)  break;
		vp->vls_len += got;
		ret += got;
	    }

	    /* force null termination */
	    vp->vls_str[vp->vls_len+vp->vls_offset] = '\0';
	}
#endif
	return ret;
}

/*
 *			B U _ V L S _ G E T S
 *
 *  Append a newline-terminated string from the file pointed to by "fp"
 *  to the end of the vls pointed to by "vp".
 *  The newline from the file is read, but not stored into the vls.
 *
 *  The most common error is to forget to bu_vls_trunc(vp,0) before
 *  reading the next line into the vls.
 *
 *  Returns -
 *	>=0	the length of the resulting vls
 *	 -1	on EOF where no characters were added to the vls.
 */
int
bu_vls_gets(register struct bu_vls *vp, register FILE *fp)
{
	int	startlen;
	int	c;

	BU_CK_VLS(vp);

	startlen = bu_vls_strlen(vp);
	bu_vls_extend( vp, 80 );		/* Ensure room to grow */
	for( ;; )  {
		/* Talk about inefficiency... */
		bu_semaphore_acquire( BU_SEM_SYSCALL );
		c = getc(fp);
		bu_semaphore_release( BU_SEM_SYSCALL );

		/* XXX Alternatively, code up something with fgets(), chunking */

		if( c == EOF || c == '\n' )  break;
		bu_vls_putc( vp, c );
	}
	if( c == EOF && bu_vls_strlen(vp) <= startlen )  return -1;
	vp->vls_str[vp->vls_offset + vp->vls_len] = '\0';	/* force null termination */
	return bu_vls_strlen(vp);
}

/*
 *                      B U _ V L S _ P U T C
 *
 *  Append the given character to the vls.
 */
void
bu_vls_putc(register struct bu_vls *vp, int c)
{
	BU_CK_VLS(vp);

	if( vp->vls_offset + vp->vls_len+1 >= vp->vls_max )  bu_vls_extend( vp, 80 );
	vp->vls_str[vp->vls_offset + vp->vls_len++] = (char)c;
	vp->vls_str[vp->vls_offset + vp->vls_len] = '\0';	/* force null termination */
}

/*
 *			B U _ V L S _ T R I M S P A C E
 *
 *  Remove leading and trailing white space from a vls string.
 */
void
bu_vls_trimspace( struct bu_vls *vp )
{
	BU_CK_VLS(vp);

	/* Remove trailing white space */
	while( isspace( bu_vls_addr(vp)[bu_vls_strlen(vp)-1] ) )
		bu_vls_trunc( vp, -1 );

	/* Remove leading white space */
	while( isspace( *bu_vls_addr(vp) ) )
		bu_vls_nibble( vp, 1 );
}

#if defined(HAVE_VARARGS_H) || defined(HAVE_STDARG_H)

/*
 *  			B U _ V L S _ V P R I N T F
 *  
 *  Format a string into a vls.  This version should work on practically
 *  any machine, but it serves to highlight the the grossness of the varargs
 *  package requiring the size of a parameter to be known at compile time.
 *
 *  %s continues to be a regular 'C' string, null terminated.
 *  %S is a pointer to a (struct bu_vls *) string.
 */

void
bu_vls_vprintf(struct bu_vls *vls, const char *fmt, va_list ap)
{
    register const char	*sp;			/* start pointer */
    register const char	*ep;			/* end pointer */
    register int len;

#define LONGINT  0x001
#define FIELDLEN 0x002
#define SHORTINT 0x003

    int flags;
    int fieldlen=-1;
    char fbuf[64], buf[1024];			/* % format buffer */

    BU_CK_VLS(vls);
    bu_vls_extend(vls, 96);

    sp = fmt;
    while( *sp ) {
	/* Initial state:  just printing chars */
	fmt = sp;
	while (*sp != '%' && *sp)
		sp++;

	if (sp != fmt)
		bu_vls_strncat(vls, fmt, sp-fmt);

	if (*sp == '\0')
		break;

	/* Saw a percent sign, find end of fmt specifier */

	flags = 0;
	ep = sp;
	while( *ep )  {
		++ep;
		if (*ep == ' ' || *ep == '#' || *ep == '-' ||
		    *ep == '+' || *ep == '.' || isdigit(*ep))
			continue;
		else if (*ep == 'l' || *ep == 'U' || *ep == 'O')
			flags |= LONGINT;
		else if (*ep == '*') {
			fieldlen = va_arg(ap, int);
			flags |= FIELDLEN;
		} else if (*ep == 'h') {
		        flags |= SHORTINT;
		} else
			/* Anything else must be the end of the fmt specifier */
			break;
	}

	/* Copy off the format string */
	len = ep-sp+1;
	if (len > sizeof(fbuf)-1) len = sizeof(fbuf)-1;
	strncpy(fbuf, sp, len);
	fbuf[len] = '\0'; /* ensure null termination */
		
	/* Grab parameter from arg list, and print it */
	switch( *ep )  {
	case 's':
	{
		register char *str;

		str = va_arg(ap, char *);
		if (str)  {
			if (flags & FIELDLEN)
			{
				int	stringlen = strlen(str);
				int	left_justify;

				if ((left_justify = (fieldlen < 0)))
					fieldlen *= -1;

				if (stringlen >= fieldlen)
					bu_vls_strncat(vls, str, fieldlen);
				else
				{
					struct bu_vls		padded;
					int			i;

					bu_vls_init(&padded);
					if (left_justify)
						bu_vls_strcat(&padded, str);
					for (i = 0; i < fieldlen - stringlen; ++i)
						bu_vls_putc(&padded, ' ');
					if (!left_justify)
						bu_vls_strcat(&padded, str);
					bu_vls_vlscat(vls, &padded);
				}
			} else {
				bu_vls_strcat(vls, str);
			}
		}  else  {
			if (flags & FIELDLEN)
				bu_vls_strncat(vls, "(null)", fieldlen);
			else
				bu_vls_strcat(vls, "(null)");
		}
	}
		break;
	case 'S':
	{
		register struct bu_vls *vp;

		vp = va_arg(ap, struct bu_vls *);
		if (vp)
		{
			BU_CK_VLS(vp);
			if (flags & FIELDLEN)
			{
				int	stringlen = bu_vls_strlen(vp);
				int	left_justify;

				if ((left_justify = (fieldlen < 0)))
					fieldlen *= -1;

				if (stringlen >= fieldlen)
					bu_vls_strncat(vls, bu_vls_addr(vp), fieldlen);
				else
				{
					struct bu_vls		padded;
					int			i;

					bu_vls_init(&padded);
					if (left_justify)
						bu_vls_vlscat(&padded, vp);
					for (i = 0; i < fieldlen - stringlen; ++i)
						bu_vls_putc(&padded, ' ');
					if (!left_justify)
						bu_vls_vlscat(&padded, vp);
					bu_vls_vlscat(vls, &padded);
				}
			} else {
				bu_vls_vlscat(vls, vp);
			}
		}  else  {
			if (flags & FIELDLEN)
				bu_vls_strncat(vls, "(null)", fieldlen);
			else
				bu_vls_strcat(vls, "(null)");
		}
	}
		break;
	case 'e':
	case 'E':
	case 'f':
	case 'g':
	case 'G':
		/* All floating point ==> "double" */
#if defined(LONGDBL)
		if (flags & LONGDBL) {
			register long double ld;

			ld = va_arg(ap, long double);
			if (flags & FIELDLEN)
				sprintf(buf, fbuf, fieldlen, ld);
			else
				sprintf(buf, fbuf, ld);
			bu_vls_strcat(vls, buf);
		} else
#endif
		{
			register double d;

			d = va_arg(ap, double);
			if (flags & FIELDLEN)
				sprintf(buf, fbuf, fieldlen, d);
			else
				sprintf(buf, fbuf, d);
			bu_vls_strcat(vls, buf);
		}
		break;
	case 'd':
	case 'x':
		if (flags & LONGINT) {
			/* Long int */
			register long ll;
		
			ll = va_arg(ap, long);
			if (flags & FIELDLEN)
				sprintf(buf, fbuf, fieldlen, ll);
			else
				sprintf(buf, fbuf, ll);
			bu_vls_strcat(vls, buf);
		} else if (flags & SHORTINT) {
		    /* short int */
		    register short int sh;
		    sh = (short int)va_arg(ap, int);
		    if (flags & FIELDLEN)
				sprintf(buf, fbuf, fieldlen, sh);
			else
				sprintf(buf, fbuf, sh);
			bu_vls_strcat(vls, buf);
		} else {
			/* Regular int */
			register int j;
		
			j = va_arg(ap, int);
			if (flags & FIELDLEN)
				sprintf(buf, fbuf, fieldlen, j);
			else
				sprintf(buf, fbuf, j);
			bu_vls_strcat(vls, buf);
		}
		break;
	case '%':
		bu_vls_putc(vls, '%');
		break;
	default:  /* Something weird, maybe %c */
	  {
		register int j;

		/* We hope, whatever it is, it fits in an int and the resulting
		   stringlet is smaller than sizeof(buf) bytes */
		
		j = va_arg(ap, int);
		if (flags & FIELDLEN)
		sprintf(buf, fbuf, fieldlen, j);
		else
		sprintf(buf, fbuf, j);
		bu_vls_strcat(vls, buf);
		break;
	  }
	}
	sp = ep+1;
    }

    va_end(ap);
}

#endif

/*
 *                 B U _ V L S _ P R I N T F
 *
 * Initializes the va_list, then calls the above bu_vls_vprintf.
 */

#if defined(HAVE_STDARG_H)

void
bu_vls_printf(struct bu_vls *vls, char *fmt, ...)  /* ANSI C */
{
	va_list ap;
	va_start(ap, fmt);
	BU_CK_VLS(vls);
	bu_vls_vprintf(vls, fmt, ap);
	va_end(ap);
}
	
#else
#  if defined(HAVE_VARARGS_H)

void
bu_vls_printf(va_alist)                            /* VARARGS */
va_dcl
{
	va_list ap;
	struct bu_vls *vls;
	char *fmt;

	va_start(ap);
	vls = va_arg(ap, struct bu_vls *);
	fmt = va_arg(ap, char *);
	BU_CK_VLS(vls);
	bu_vls_vprintf(vls, fmt, ap);
	va_end(ap);
}

#  else

void
bu_vls_printf(vls, fmt, a,b,c,d,e,f,g,h,i,j)       /* Cray XMP */
struct bu_vls *vls;
char *fmt;
{
	char append_buf[65536] = {0};   /* yuck -- fixed length buffer. */

	BU_CK_VLS(vls);
	sprintf(append_buf, fmt, a,b,c,d,e,f,g,h,i,j);
	if (append_buf[sizeof(append_buf)-1] != '\0') {
		/* Attempting to bu_log() the WHOLE append_buf would just overflow again */
		append_buf[120] = '\0';
		bu_log("bu_vls_printf buffer overflow\nWhile building string '%s'...\n",
			   append_buf);
		bu_bomb("bu_vls_printf buffer overflow\n");
	}
	
	bu_vls_strcat(vls, append_buf);
}

#  endif
#endif

/*
 *			B U _ V L S _ S P A C E S
 *
 *  Efficiently append 'cnt' spaces to the current vls.
 */
void
bu_vls_spaces(register struct bu_vls *vp, int cnt)
{
	BU_CK_VLS(vp);
	if( cnt <= 0 )  return;
	if( vp->vls_offset + vp->vls_len + cnt+1 >= vp->vls_max )
		bu_vls_extend( vp, cnt );
	memset( vp->vls_str + vp->vls_offset + vp->vls_len, ' ', cnt );
	vp->vls_len += cnt;
}

/*
 *			B U _ V L S _ P R I N T _ P O S I T I O N S _ U S E D
 *
 *  Returns number of printed spaces used on final output line of a
 *  potentially multi-line vls.  Useful for making decisions on when
 *  to line-wrap.
 *  Accounts for normal UNIX tab-expansion:
 *	         1         2         3         4
 *	1234567890123456789012345678901234567890
 *	        x       x       x       x
 *
 *	0-7 --> 8, 8-15 --> 16, 16-23 --> 24, etc.
 */
int
bu_vls_print_positions_used(const struct bu_vls *vp)
{
	char	*start;
	int	used;

	BU_CK_VLS(vp);

	if( (start = strrchr( bu_vls_addr(vp), '\n' )) == NULL )
		start = bu_vls_addr(vp);
	used = 0;
	while( *start != '\0' )  {
		if( *start == '\t' )  {
			used += 8 - (used % 8);
		} else {
			used++;
		}
		start++;
	}
	return used;
}

/*
 *			B U _ V L S _ D E T A B
 *
 *  Given a vls, return a version of that string which has had all
 *  "tab" characters converted to the appropriate number of spaces
 *  according to the UNIX tab convention.
 */
void
bu_vls_detab(struct bu_vls *vp)
{
	struct bu_vls	src;
	register char	*cp;
	int		used;

	BU_CK_VLS(vp);
	bu_vls_init( &src );
	bu_vls_vlscatzap( &src, vp );	/* make temporary copy of src */
	bu_vls_extend( vp, bu_vls_strlen(&src)+50 );

	cp = bu_vls_addr( &src );
	used = 0;
	while( *cp != '\0' )  {
		if( *cp == '\t' )  {
			int	todo;
			todo = 8 - (used % 8);
			bu_vls_spaces( vp, todo );
			used += todo;
		} else if( *cp == '\n' )  {
			bu_vls_putc( vp, '\n' );
			used = 0;
		} else {
			bu_vls_putc( vp, *cp );
			used++;
		}
		cp++;
	}
	bu_vls_free( &src );
}

/*		B U _ V L S _ P R E P E N D
 *
 *  Add a string to the begining of the vls.
 */
void
bu_vls_prepend(struct bu_vls *vp, char *str)
{
	int len = strlen(str);

	bu_vls_extend(vp, len);

	/* memmove is supposed to be safe even if strings overlap */
	memmove( vp->vls_str+vp->vls_offset+len, vp->vls_str+vp->vls_offset, vp->vls_len );

	/* insert the data at the head of the string */
	memcpy( vp->vls_str+vp->vls_offset, str, len);
}
@


1.34
log
@change conf.h to a wrapped config.h
@
text
@d20 1
a20 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvs/brlcad/libbu/vls.c,v 1.33 2004/04/05 07:46:16 morrison Exp $ (BRL)";
@


1.33
log
@merge of ansi-6-0-branch into HEAD
@
text
@d20 6
a25 1
static const char libbu_vls_RCSid[] = "@@(#)$Header$ (BRL)";
a26 1
#include "conf.h"
@


1.32
log
@zero-fill the char buffer instead of just the last element.
@
text
@d20 1
a20 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/vls.c,v 1.31 2002/08/20 17:07:42 jra Exp $ (BRL)";
d58 1
a58 2
bu_vls_init( vp )
register struct bu_vls	*vp;
d77 1
a77 2
bu_vls_init_if_uninit( vp )
register struct bu_vls	*vp;
d94 1
a94 1
bu_vls_vlsinit()
d111 1
a111 2
bu_vls_addr( vp )
register const struct bu_vls	*vp;
d141 1
a141 3
bu_vls_extend( vp, extra )
register struct bu_vls	*vp;
int			extra;
d172 1
a172 3
bu_vls_setlen( vp, newlen )
struct bu_vls	*vp;
int		newlen;
d186 1
a186 2
bu_vls_strlen(vp)
register const struct bu_vls	*vp;
d202 1
a202 3
bu_vls_trunc( vp, len )
register struct bu_vls	*vp;
int			len;
d219 1
a219 3
bu_vls_trunc2( vp, len )
register struct bu_vls	*vp;
int			len;
d238 1
a238 3
bu_vls_nibble(vp, len)
register struct bu_vls	*vp;
int len;
d255 1
a255 2
bu_vls_free( vp )
register struct bu_vls	*vp;
d273 1
a273 2
bu_vls_vlsfree( vp )
register struct bu_vls *vp;
d288 1
a288 2
bu_vls_strdup( vp )
register const struct bu_vls *vp;
d311 1
a311 2
bu_vls_strgrab( vp )
register struct bu_vls *vp;
d334 1
a334 3
bu_vls_strcpy( vp, s )
register struct bu_vls	*vp;
const char		*s;
d359 1
a359 4
bu_vls_strncpy( vp, s, n )
register struct bu_vls	*vp;
const char		*s;
long			n;
d384 1
a384 3
bu_vls_strcat( vp, s )
register struct bu_vls	*vp;
const char		*s;
d403 1
a403 4
bu_vls_strncat( vp, s, n )
register struct bu_vls	*vp;
const char		*s;
long			n;
d426 1
a426 3
bu_vls_vlscat( dest, src )
register struct bu_vls		*dest;
register const struct bu_vls	*src;
d447 1
a447 2
bu_vls_vlscatzap( dest, src )
register struct bu_vls	*dest, *src;
d463 1
a463 4
bu_vls_from_argv( vp, argc, argv )
register struct bu_vls	*vp;
int	argc;
char	**argv;
d491 1
a491 4
bu_argv_from_string(argv, lim, lp )
char		**argv;
int		lim;
register char	*lp;
d530 1
a530 3
bu_vls_fwrite( fp, vp )
FILE			*fp;
const struct bu_vls	*vp;
d636 1
a636 3
bu_vls_gets( vp, fp )
register struct bu_vls	*vp;
register FILE		*fp;
d667 1
a667 3
bu_vls_putc( vp, c )
register struct bu_vls	*vp;
int			c;
d709 1
a709 4
bu_vls_vprintf(vls, fmt, ap)
struct bu_vls *vls;
const char *fmt;
va_list ap;
d1009 1
a1009 3
bu_vls_spaces( vp, cnt )
register struct bu_vls	*vp;
int			cnt;
d1033 1
a1033 2
bu_vls_print_positions_used( vp )
const struct bu_vls	*vp;
d1062 1
a1062 2
bu_vls_detab( vp )
struct bu_vls	*vp;
@


1.31
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d20 1
a20 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/vls.c,v 1.29 2001/11/05 20:11:36 bparker Exp $ (BRL)";
d1031 1
a1031 1
	char append_buf[65536];   /* yuck -- fixed length buffer. */
a1033 1
	append_buf[sizeof(append_buf)-1] = '\0';
@


1.31.4.1
log
@sync to HEAD...
@
text
@d20 1
a20 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libbu/vls.c,v 1.32 2004/02/03 17:22:03 morrison Exp $ (BRL)";
d1031 1
a1031 1
	char append_buf[65536] = {0};   /* yuck -- fixed length buffer. */
d1034 1
@


1.31.10.1
log
@merge from HEAD
@
text
@d20 1
a20 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/vls.c,v 1.32 2004/02/03 17:22:03 morrison Exp $ (BRL)";
d1031 1
a1031 1
	char append_buf[65536] = {0};   /* yuck -- fixed length buffer. */
d1034 1
@


1.31.10.2
log
@merge from head
@
text
@d20 1
a20 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/vls.c,v 1.31.10.1 2004/02/12 18:39:19 erikg Exp $ (BRL)";
@


1.31.2.1
log
@Initial ANSIfication
@
text
@d20 1
a20 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/vls.c,v 1.31 2002/08/20 17:07:42 jra Exp $ (BRL)";
d58 2
a59 1
bu_vls_init(register struct bu_vls *vp)
d78 2
a79 1
bu_vls_init_if_uninit(register struct bu_vls *vp)
d96 1
a96 1
bu_vls_vlsinit(void)
d113 2
a114 1
bu_vls_addr(register const struct bu_vls *vp)
d144 3
a146 1
bu_vls_extend(register struct bu_vls *vp, int extra)
d177 3
a179 1
bu_vls_setlen(struct bu_vls *vp, int newlen)
d193 2
a194 1
bu_vls_strlen(register const struct bu_vls *vp)
d210 3
a212 1
bu_vls_trunc(register struct bu_vls *vp, int len)
d229 3
a231 1
bu_vls_trunc2(register struct bu_vls *vp, int len)
d250 3
a252 1
bu_vls_nibble(register struct bu_vls *vp, int len)
d269 2
a270 1
bu_vls_free(register struct bu_vls *vp)
d288 2
a289 1
bu_vls_vlsfree(register struct bu_vls *vp)
d304 2
a305 1
bu_vls_strdup(register const struct bu_vls *vp)
d328 2
a329 1
bu_vls_strgrab(register struct bu_vls *vp)
d352 3
a354 1
bu_vls_strcpy(register struct bu_vls *vp, const char *s)
d379 4
a382 1
bu_vls_strncpy(register struct bu_vls *vp, const char *s, long int n)
d407 3
a409 1
bu_vls_strcat(register struct bu_vls *vp, const char *s)
d428 4
a431 1
bu_vls_strncat(register struct bu_vls *vp, const char *s, long int n)
d454 3
a456 1
bu_vls_vlscat(register struct bu_vls *dest, register const struct bu_vls *src)
d477 2
a478 1
bu_vls_vlscatzap(register struct bu_vls *dest, register struct bu_vls *src)
d494 4
a497 1
bu_vls_from_argv(register struct bu_vls *vp, int argc, char **argv)
d525 4
a528 1
bu_argv_from_string(char **argv, int lim, register char *lp)
d567 3
a569 1
bu_vls_fwrite(FILE *fp, const struct bu_vls *vp)
d675 3
a677 1
bu_vls_gets(register struct bu_vls *vp, register FILE *fp)
d708 3
a710 1
bu_vls_putc(register struct bu_vls *vp, int c)
d752 4
a755 1
bu_vls_vprintf(struct bu_vls *vls, const char *fmt, va_list ap)
d1056 3
a1058 1
bu_vls_spaces(register struct bu_vls *vp, int cnt)
d1082 2
a1083 1
bu_vls_print_positions_used(const struct bu_vls *vp)
d1112 2
a1113 1
bu_vls_detab(struct bu_vls *vp)
@


1.31.2.2
log
@sync branch with HEAD
@
text
@d20 1
a20 1
static const char libbu_vls_RCSid[] = "@@(#)$Header$ (BRL)";
d985 1
a985 1
	char append_buf[65536] = {0};   /* yuck -- fixed length buffer. */
d988 1
@


1.31.2.3
log
@more quelling of lots of warnings
@
text
@d20 1
a20 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libbu/vls.c,v 1.31.2.2 2004/03/17 21:16:51 morrison Exp $ (BRL)";
d141 1
a141 1
bu_vls_extend(register struct bu_vls *vp, unsigned int extra)
@


1.30
log
@Converted from K&R to ANSI C - RFH
@
text
@d58 2
a59 1
bu_vls_init(register struct bu_vls *vp)
d78 2
a79 1
bu_vls_init_if_uninit(register struct bu_vls *vp)
d96 1
a96 1
bu_vls_vlsinit(void)
d113 2
a114 1
bu_vls_addr(register const struct bu_vls *vp)
d144 3
a146 1
bu_vls_extend(register struct bu_vls *vp, int extra)
d177 3
a179 1
bu_vls_setlen(struct bu_vls *vp, int newlen)
d193 2
a194 1
bu_vls_strlen(register const struct bu_vls *vp)
d210 3
a212 1
bu_vls_trunc(register struct bu_vls *vp, int len)
d229 3
a231 1
bu_vls_trunc2(register struct bu_vls *vp, int len)
d250 3
a252 1
bu_vls_nibble(register struct bu_vls *vp, int len)
d269 2
a270 1
bu_vls_free(register struct bu_vls *vp)
d288 2
a289 1
bu_vls_vlsfree(register struct bu_vls *vp)
d304 2
a305 1
bu_vls_strdup(register const struct bu_vls *vp)
d328 2
a329 1
bu_vls_strgrab(register struct bu_vls *vp)
d352 3
a354 1
bu_vls_strcpy(register struct bu_vls *vp, const char *s)
d379 4
a382 1
bu_vls_strncpy(register struct bu_vls *vp, const char *s, long int n)
d407 3
a409 1
bu_vls_strcat(register struct bu_vls *vp, const char *s)
d428 4
a431 1
bu_vls_strncat(register struct bu_vls *vp, const char *s, long int n)
d454 3
a456 1
bu_vls_vlscat(register struct bu_vls *dest, register const struct bu_vls *src)
d477 2
a478 1
bu_vls_vlscatzap(register struct bu_vls *dest, register struct bu_vls *src)
d494 4
a497 1
bu_vls_from_argv(register struct bu_vls *vp, int argc, char **argv)
d525 4
a528 1
bu_argv_from_string(char **argv, int lim, register char *lp)
d567 3
a569 1
bu_vls_fwrite(FILE *fp, const struct bu_vls *vp)
d675 3
a677 1
bu_vls_gets(register struct bu_vls *vp, register FILE *fp)
d708 3
a710 1
bu_vls_putc(register struct bu_vls *vp, int c)
d752 4
a755 1
bu_vls_vprintf(struct bu_vls *vls, const char *fmt, va_list ap)
d1056 3
a1058 1
bu_vls_spaces(register struct bu_vls *vp, int cnt)
d1082 2
a1083 1
bu_vls_print_positions_used(const struct bu_vls *vp)
d1112 2
a1113 1
bu_vls_detab(struct bu_vls *vp)
@


1.29
log
@*- va_arg on Linux won't accept a short
@
text
@d20 1
a20 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/vls.c,v 1.28 2001/11/02 05:01:37 butler Exp $ (BRL)";
d58 1
a58 2
bu_vls_init( vp )
register struct bu_vls	*vp;
d77 1
a77 2
bu_vls_init_if_uninit( vp )
register struct bu_vls	*vp;
d94 1
a94 1
bu_vls_vlsinit()
d111 1
a111 2
bu_vls_addr( vp )
register const struct bu_vls	*vp;
d141 1
a141 3
bu_vls_extend( vp, extra )
register struct bu_vls	*vp;
int			extra;
d172 1
a172 3
bu_vls_setlen( vp, newlen )
struct bu_vls	*vp;
int		newlen;
d186 1
a186 2
bu_vls_strlen(vp)
register const struct bu_vls	*vp;
d202 1
a202 3
bu_vls_trunc( vp, len )
register struct bu_vls	*vp;
int			len;
d219 1
a219 3
bu_vls_trunc2( vp, len )
register struct bu_vls	*vp;
int			len;
d238 1
a238 3
bu_vls_nibble(vp, len)
register struct bu_vls	*vp;
int len;
d255 1
a255 2
bu_vls_free( vp )
register struct bu_vls	*vp;
d273 1
a273 2
bu_vls_vlsfree( vp )
register struct bu_vls *vp;
d288 1
a288 2
bu_vls_strdup( vp )
register const struct bu_vls *vp;
d311 1
a311 2
bu_vls_strgrab( vp )
register struct bu_vls *vp;
d334 1
a334 3
bu_vls_strcpy( vp, s )
register struct bu_vls	*vp;
const char		*s;
d359 1
a359 4
bu_vls_strncpy( vp, s, n )
register struct bu_vls	*vp;
const char		*s;
long			n;
d384 1
a384 3
bu_vls_strcat( vp, s )
register struct bu_vls	*vp;
const char		*s;
d403 1
a403 4
bu_vls_strncat( vp, s, n )
register struct bu_vls	*vp;
const char		*s;
long			n;
d426 1
a426 3
bu_vls_vlscat( dest, src )
register struct bu_vls		*dest;
register const struct bu_vls	*src;
d447 1
a447 2
bu_vls_vlscatzap( dest, src )
register struct bu_vls	*dest, *src;
d463 1
a463 4
bu_vls_from_argv( vp, argc, argv )
register struct bu_vls	*vp;
int	argc;
char	**argv;
d491 1
a491 4
bu_argv_from_string(argv, lim, lp )
char		**argv;
int		lim;
register char	*lp;
d530 1
a530 3
bu_vls_fwrite( fp, vp )
FILE			*fp;
const struct bu_vls	*vp;
d636 1
a636 3
bu_vls_gets( vp, fp )
register struct bu_vls	*vp;
register FILE		*fp;
d667 1
a667 3
bu_vls_putc( vp, c )
register struct bu_vls	*vp;
int			c;
d709 1
a709 4
bu_vls_vprintf(vls, fmt, ap)
struct bu_vls *vls;
const char *fmt;
va_list ap;
d1010 1
a1010 3
bu_vls_spaces( vp, cnt )
register struct bu_vls	*vp;
int			cnt;
d1034 1
a1034 2
bu_vls_print_positions_used( vp )
const struct bu_vls	*vp;
d1063 1
a1063 2
bu_vls_detab( vp )
struct bu_vls	*vp;
@


1.28
log
@added support for short int
@
text
@d20 1
a20 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/vls.c,v 1.27 2001/08/11 13:11:15 butler Exp $ (BRL)";
d942 1
a942 1
		    sh = va_arg(ap, short);
@


1.27
log
@Misc compiler warning changes
@
text
@d20 1
a20 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/vls.c,v 1.26 2001/04/20 22:29:07 morrison Exp $ (BRL)";
d763 1
d799 2
d938 9
@


1.26
log
@CONST to const
@
text
@d20 1
a20 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/vls.c,v 1.25 2001/03/23 22:34:15 butler Exp $ (BRL)";
a591 1
	int status;
d596 1
a596 1
#if !unix
d599 5
a603 3
	bu_semaphore_acquire(BU_SEM_SYSCALL);
	status = write( fd, vp->vls_str + vp->vls_offset, vp->vls_len );
	bu_semaphore_release(BU_SEM_SYSCALL);
d605 1
a605 1
	if( status != vp->vls_len ) {    
d608 1
a626 2
	int	todo;
	int	got;
d630 1
a630 1
#if !unix
d633 4
a636 1
	for(;;)  {
d651 4
a655 1
	vp->vls_str[vp->vls_len+vp->vls_offset] = '\0';	/* force null termination */
@


1.25
log
@Added extra routine to prepend a string on a vls
@
text
@d20 1
a20 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /n/tgm/d/CVS/brlcad/libbu/vls.c,v 1.24 2000/08/23 23:43:12 mike Exp $ (BRL)";
d45 1
a45 1
BU_EXTERN(void	bu_vls_vprintf, (struct bu_vls *vls, CONST char *fmt, va_list ap));
d114 1
a114 1
register CONST struct bu_vls	*vp;
d194 1
a194 1
register CONST struct bu_vls	*vp;
d305 1
a305 1
register CONST struct bu_vls *vp;
d354 1
a354 1
CONST char		*s;
d359 1
a359 1
	if( s == (CONST char *)NULL )  return;
d381 1
a381 1
CONST char		*s;
d387 1
a387 1
	if( s == (CONST char *)NULL )  return;
d409 1
a409 1
CONST char		*s;
d414 1
a414 1
	if( s == (CONST char *)NULL )  return;
d430 1
a430 1
CONST char		*s;
d436 1
a436 1
	if( s == (CONST char *)NULL )  return;
d456 1
a456 1
register CONST struct bu_vls	*src;
d569 1
a569 1
CONST struct bu_vls	*vp;
d748 1
a748 1
CONST char *fmt;
d751 2
a752 2
    register CONST char	*sp;			/* start pointer */
    register CONST char	*ep;			/* end pointer */
d1065 1
a1065 1
CONST struct bu_vls	*vp;
@


1.24
log
@
Allowed debug mem print to actually print the strings in vls and strdup
blocks.
@
text
@d20 1
a20 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/vls.c,v 1.23 2000/07/11 23:12:39 mike Exp $ (BRL)";
d1124 18
@


1.23
log
@
Added externs from vls.c to bu.h
@
text
@d20 1
a20 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/vls.c,v 1.22 2000/07/07 05:20:14 cjohnson Exp $ (BRL)";
d48 3
d152 1
a152 2
		vp->vls_str = (char *)bu_malloc( vp->vls_max,
			"bu_vls_extend (initial)" );
d162 1
a162 1
			 "bu_vls_extend (grow)" );
d311 1
a311 1
	str = bu_malloc(len+1, "bu_vls_strdup");
@


1.22
log
@LINT
@
text
@d20 1
a20 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/vls.c,v 1.21 2000/03/28 19:13:20 mike Exp $ (BRL)";
d588 1
a588 3
bu_vls_write( fd, vp )
int			fd;
CONST struct bu_vls	*vp;
d620 1
a620 3
bu_vls_read( vp, fd )
struct bu_vls	*vp;
int		fd;
d717 1
a717 2
bu_vls_trimspace( vp )
struct bu_vls	*vp;
@


1.21
log
@
extern for bu_vls_vprintf()
@
text
@d20 1
a20 1
static char libbu_vls_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/vls.c,v 1.20 2000/03/28 18:56:37 mike Exp $ (BRL)";
d762 1
a762 1
    int fieldlen;
d819 1
a819 1
				if (left_justify = (fieldlen < 0))
d862 1
a862 1
				if (left_justify = (fieldlen < 0))
@


1.20
log
@
Fixed RCSids
@
text
@d20 1
a20 1
static char libbu_vls_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/vls.c,v 1.19 2000/01/07 20:54:09 mike Exp $ (BRL)";
d32 1
d36 1
@


1.19
log
@
Added extern
@
text
@d20 1
a20 1
static char RCSrtstring[] = "@@(#)$Header: /c/CVS/brlcad/libbu/vls.c,v 1.18 1999/12/29 20:17:12 jra Exp $ (BRL)";
@


1.18
log
@Eliminated an unused variable
@
text
@d20 1
a20 1
static char RCSrtstring[] = "@@(#)$Header: /c/CVS/brlcad/libbu/vls.c,v 1.17 1999/01/22 21:55:21 butler Exp $ (BRL)";
d41 4
@


1.17
log
@strncat and strncpy now take a LONG as the count parameter.  This is more
in keeping with the size_t parameter passed to the system library functions.
@
text
@d20 1
a20 1
static char RCSrtstring[] = "@@(#)$Header: /c/CVS/brlcad/libbu/vls.c,v 1.16 1999/01/08 16:13:01 bparker Exp $ (BRL)";
a323 1
	register int len;
@


1.16
log
@*- OOPS, I forgot to check if any memory was allocated
	for vls_str before forcing a null termination.
@
text
@d20 1
a20 1
static char RCSrtstring[] = "@@(#)$Header: /c/CVS/brlcad/libbu/vls.c,v 1.15 1999/01/04 20:41:05 bparker Exp $ (BRL)";
d375 1
a375 1
int			n;
d424 1
a424 1
int			n;
@


1.15
log
@*- modified bu_vls_strcpy's handling of empty strings
	- added -----> vp->vls_str[0] = '\0'
@
text
@d20 1
a20 1
static char RCSrtstring[] = "@@(#)$Header: /c/CVS/brlcad/libbu/vls.c,v 1.14 1998/11/19 05:22:49 mike Exp $ (BRL)";
d356 2
a357 1
		vp->vls_str[0] = '\0';
@


1.14
log
@Added bu_vls_read() to slurp an entire file onto the end of a vls.
@
text
@d20 1
a20 1
static char RCSrtstring[] = "@@(#)$Header: /c/CVS/brlcad/libbu/vls.c,v 1.13 1998/03/25 02:55:34 butler Exp $ (BRL)";
d356 1
@


1.13
log
@over-stringent testing in bu_vls_addr() removed
@
text
@d20 1
a20 1
static char RCSrtstring[] = "@@(#)$Header: /m/cad/libbu/RCS/vls.c,v 1.12 1997/12/04 12:50:40 mike Exp butler $ (BRL)";
d602 45
@


1.12
log
@Need to parallel protect getc() call.
@
text
@d20 1
a20 1
static char RCSrtstring[] = "@@(#)$Header: /m/cad/libbu/RCS/vls.c,v 1.11 1997/07/29 03:34:11 mike Exp mike $ (BRL)";
d111 1
a111 1
	if( vp->vls_max == 0 || vp->vls_len == 0 || vp->vls_str == (char *)NULL )  {
@


1.11
log
@Added bu_argv_from_string() and bu_vls_write()
@
text
@d20 1
a20 1
static char RCSrtstring[] = "@@(#)$Header: /m/cad/libbu/RCS/vls.c,v 1.10 1997/04/17 09:29:18 mike Exp mike $ (BRL)";
d630 9
a638 1
	while( (c = getc(fp)) != EOF && c != '\n' )  {
@


1.10
log
@Added bu_vls_detab()
@
text
@d20 1
a20 1
static char RCSrtstring[] = "@@(#)$Header: /m/cad/libbu/RCS/vls.c,v 1.9 1997/04/16 06:56:04 mike Exp mike $ (BRL)";
d498 57
d575 27
@


1.9
log
@Added bu_vls_print_positions_used().
@
text
@d20 1
a20 1
static char RCSrtstring[] = "@@(#)$Header: /m/cad/libbu/RCS/vls.c,v 1.8 1997/04/04 19:43:20 bparker Exp mike $ (BRL)";
d943 40
@


1.8
log
@fixed off by 1 errors in bu_vls_strcpy, bu_vls_strncpy,
bu_vls_strcat, bu_vls_strncat, and bu_vls_vlscat
@
text
@d20 1
a20 1
static char RCSrtstring[] = "@@(#)$Header: /m/cad/libbu/RCS/vls.c,v 1.7 1997/04/04 06:00:11 mike Exp bparker $ (BRL)";
d907 36
@


1.7
log
@bu_vls_vprintf() shouldn't inch up the size of the string
with multiple mallocs per line, it should make sure that there
is at least a line's worth of buffer available before starting.
If somebody really wants to keep *lots* of small strings around
in vls buffers, they should dup 'em after building 'em up.
@
text
@d20 1
a20 1
static char RCSrtstring[] = "@@(#)$Header: /m/cad/libbu/RCS/vls.c,v 1.6 1997/04/04 05:35:48 mike Exp mike $ (BRL)";
d359 1
a359 1
	if( len+1 >= vp->vls_max )  bu_vls_extend( vp, len );
d386 1
a386 1
	if( len+1 >= vp->vls_max )  bu_vls_extend( vp, len );
d408 1
a408 1
		bu_vls_extend( vp, len );
d432 1
a432 1
		bu_vls_extend( vp, len );
d453 1
a453 1
		bu_vls_extend( dest, src->vls_len );
@


1.6
log
@Important bug fixes to bu_vls_gets() -- can't change offset,
wasn't getting it right, changed to use existing routines.
Also changed bu_vls_extend() to actually honor the 'extra' arg,
rather than excessively fiddling it.
@
text
@d20 1
a20 1
static char RCSrtstring[] = "@@(#)$Header: /m/cad/libbu/RCS/vls.c,v 1.5 1997/04/04 04:56:02 mike Exp mike $ (BRL)";
d622 1
@


1.5
log
@bu_vls_trunc(,0) doesn't release storage -- this is massively
wasteful.
bu_vls_trunc(,-n) trims off 'n' chars.
@
text
@d20 1
a20 1
static char RCSrtstring[] = "@@(#)$Header: /m/cad/libbu/RCS/vls.c,v 1.4 1997/02/13 00:34:32 mike Exp mike $ (BRL)";
d111 1
a111 1
	if( vp->vls_max == 0 || vp->vls_len == 0 )  {
d121 1
a121 1
		vp->vls_str == (char *)0 ||
d140 1
d142 2
a143 1
		vp->vls_str = (char *)bu_malloc( vp->vls_max = extra*4,
d151 1
a151 1
		vp->vls_max = (vp->vls_max + extra) * 2;
d249 1
a249 1
		bu_vls_free( vp );
d544 2
a545 2
	startlen = vp->vls_len;
	vp->vls_offset = 0;
d547 1
a547 2
		if( vp->vls_len+1 >= vp->vls_max )  bu_vls_extend( vp, 80 );
		vp->vls_str[vp->vls_len++] = c;
d549 3
a551 10
	if( c == EOF && vp->vls_len <= startlen )  return -1;
	/*
	 * nobody is suppose to peek inside a vls, so when they
	 * use bu_vls_addr() to get the address, they will be given
	 * the address of a short null terminated string.
	 */
	if( vp->vls_len <= 0 )  return 0;
	vp->vls_str[vp->vls_len] = '\0';	/* force null termination */

	return vp->vls_len;
@


1.4
log
@When building vls from argv[], don't add a trailing space.
@
text
@d20 1
a20 1
static char RCSrtstring[] = "@@(#)$Header: /m/cad/libbu/RCS/vls.c,v 1.3 1996/11/28 08:04:12 mike Exp mike $ (BRL)";
d164 1
d180 1
a180 1
 *  Return length of the string, in bytes, not including the null.
d195 3
d202 1
d205 1
d207 1
a207 4
	if( len <= 0 )  {
		bu_vls_free( vp );
		return;
	}
d216 1
a216 1
 *  Same as bu_vls_trunc except that it doesn't free memory.
d221 1
d225 2
a226 5
	if( len <= 0 )  {
		vp->vls_len = vp->vls_offset = 0;
		vp->vls_str[0] = '\0'; /* force null termination */
		return;
	}
d525 3
a564 1

d575 20
@


1.3
log
@Added bu_vls_spaces()
@
text
@d20 1
a20 1
static char RCSrtstring[] = "@@(#)$Header: /m/cad/libbu/RCS/vls.c,v 1.2 1996/08/28 09:49:13 mike Exp mike $ (BRL)";
d490 1
a490 1
		bu_vls_strcat( vp, " " );
@


1.2
log
@Unkinked indentation.
Added heuristic to bu_vls_extend() to avoid the frequent realloc()s.
@
text
@d20 1
a20 1
static char RCSrtstring[] = "@@(#)$Header: /m/cad/libbu/RCS/vls.c,v 1.1 1996/08/27 06:18:33 mike Exp mike $ (BRL)";
d872 18
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
static char RCSrtstring[] = "@@(#)$Header: /m/cad/librt/RCS/rtstring.c,v 11.15 1996/01/23 20:52:25 mike Exp $ (BRL)";
d112 1
a112 1
	    	/* A zero-length VLS is a null string */
d119 5
a123 5
	    vp->vls_len < 0 ||
	    vp->vls_offset < 0 ||
	    vp->vls_str == (char *)0 ||
	    vp->vls_len + vp->vls_offset >= vp->vls_max )  {
	    bu_log("bu_vls_addr: bad VLS.  max=%d, len=%d, offset=%d\n",
d125 1
a125 1
	    bu_bomb("bu_vls_addr\n");
d141 1
a141 1
	    vp->vls_str = (char *)bu_malloc( vp->vls_max = extra*4,
d143 4
a146 3
	    vp->vls_len = 0;
	    vp->vls_offset = 0;
	    *vp->vls_str = '\0';
d149 4
a152 3
	    vp->vls_max = (vp->vls_max + extra) * 2;
	    vp->vls_str = (char *)bu_realloc( vp->vls_str, vp->vls_max,
				     "bu_vls_extend (grow)" );
d404 2
a405 1
	if( vp->vls_offset + vp->vls_len + len+1 >= vp->vls_max )  bu_vls_extend( vp, len );
d428 2
a429 1
	if( vp->vls_offset + vp->vls_len + len+1 >= vp->vls_max )  bu_vls_extend( vp, len );
d453 2
a454 2
	      dest->vls_str +dest->vls_offset + dest->vls_len,
	    src->vls_len+1 );
d512 1
a512 1
	    	perror("fwrite");
d611 1
a611 1
	    sp++;
d614 1
a614 1
	    bu_vls_strncat(vls, fmt, sp-fmt);
d617 1
a617 1
	    break;
d624 12
a635 12
	    ++ep;
	    if (*ep == ' ' || *ep == '#' || *ep == '-' ||
		*ep == '+' || *ep == '.' || isdigit(*ep))
		continue;
	    else if (*ep == 'l' || *ep == 'U' || *ep == 'O')
		flags |= LONGINT;
	    else if (*ep == '*') {
		fieldlen = va_arg(ap, int);
		flags |= FIELDLEN;
	    } else
		/* Anything else must be the end of the fmt specifier */
		break;
d648 1
a648 1
	    register char *str;
d650 6
a655 6
	    str = va_arg(ap, char *);
	    if (str)
		if (flags & FIELDLEN)
		{
		    int	stringlen = strlen(str);
		    int	left_justify;
d657 2
a658 2
		    if (left_justify = (fieldlen < 0))
			fieldlen *= -1;
d660 6
a665 6
		    if (stringlen >= fieldlen)
			bu_vls_strncat(vls, str, fieldlen);
		    else
		    {
			struct bu_vls		padded;
			int			i;
d667 17
a683 9
			bu_vls_init(&padded);
			if (left_justify)
			    bu_vls_strcat(&padded, str);
			for (i = 0; i < fieldlen - stringlen; ++i)
			    bu_vls_putc(&padded, ' ');
			if (!left_justify)
			    bu_vls_strcat(&padded, str);
			bu_vls_vlscat(vls, &padded);
		    }
a684 7
		else
		    bu_vls_strcat(vls, str);
	    else
		if (flags & FIELDLEN)
		    bu_vls_strncat(vls, "(null)", fieldlen);
		else
		    bu_vls_strcat(vls, "(null)");
d686 1
a686 1
	    break;
d689 1
a689 1
	    register struct bu_vls *vp;
d691 2
a692 5
	    vp = va_arg(ap, struct bu_vls *);
	    if (vp)
	    {
	    	BU_CK_VLS(vp);
		if (flags & FIELDLEN)
d694 5
a698 2
		    int	stringlen = bu_vls_strlen(vp);
		    int	left_justify;
d700 2
a701 2
		    if (left_justify = (fieldlen < 0))
			fieldlen *= -1;
d703 6
a708 6
		    if (stringlen >= fieldlen)
			bu_vls_strncat(vls, bu_vls_addr(vp), fieldlen);
		    else
		    {
			struct bu_vls		padded;
			int			i;
d710 17
a726 9
			bu_vls_init(&padded);
			if (left_justify)
			    bu_vls_vlscat(&padded, vp);
			for (i = 0; i < fieldlen - stringlen; ++i)
			    bu_vls_putc(&padded, ' ');
			if (!left_justify)
			    bu_vls_vlscat(&padded, vp);
			bu_vls_vlscat(vls, &padded);
		    }
a727 10
		else
		    bu_vls_vlscat(vls, vp);
	    }
	    else
	    {
		if (flags & FIELDLEN)
		    bu_vls_strncat(vls, "(null)", fieldlen);
		else
		    bu_vls_strcat(vls, "(null)");
	    }
d729 1
a729 1
	    break;
d735 1
a735 1
	    /* All floating point ==> "double" */
d737 2
a738 2
	    if (flags & LONGDBL) {
		register long double ld;
d740 7
a746 7
		ld = va_arg(ap, long double);
		if (flags & FIELDLEN)
		    sprintf(buf, fbuf, fieldlen, ld);
		else
		    sprintf(buf, fbuf, ld);
		bu_vls_strcat(vls, buf);
	    } else
d748 2
a749 2
	    {
		register double d;
d751 8
a758 8
		d = va_arg(ap, double);
		if (flags & FIELDLEN)
		    sprintf(buf, fbuf, fieldlen, d);
		else
		    sprintf(buf, fbuf, d);
		bu_vls_strcat(vls, buf);
	    }
	    break;
d761 3
a763 3
	    if (flags & LONGINT) {
		/* Long int */
		register long ll;
d765 9
a773 9
		ll = va_arg(ap, long);
		if (flags & FIELDLEN)
		    sprintf(buf, fbuf, fieldlen, ll);
		else
		    sprintf(buf, fbuf, ll);
		bu_vls_strcat(vls, buf);
	    } else {
		/* Regular int */
		register int j;
d775 8
a782 8
		j = va_arg(ap, int);
		if (flags & FIELDLEN)
		    sprintf(buf, fbuf, fieldlen, j);
		else
		    sprintf(buf, fbuf, j);
		bu_vls_strcat(vls, buf);
	    }
	    break;
d784 2
a785 2
	    bu_vls_putc(vls, '%');
	    break;
d788 1
a788 1
	    register int j;
d790 5
a794 5
	    /* We hope, whatever it is, it fits in an int and the resulting
	       stringlet is smaller than sizeof(buf) bytes */
	    
	    j = va_arg(ap, int);
	    if (flags & FIELDLEN)
d796 1
a796 1
	    else
d798 2
a799 2
	    bu_vls_strcat(vls, buf);
	    break;
d821 5
a825 5
    va_list ap;
    va_start(ap, fmt);
    BU_CK_VLS(vls);
    bu_vls_vprintf(vls, fmt, ap);
    va_end(ap);
d827 1
a827 1
    
d835 3
a837 3
    va_list ap;
    struct bu_vls *vls;
    char *fmt;
d839 6
a844 6
    va_start(ap);
    vls = va_arg(ap, struct bu_vls *);
    fmt = va_arg(ap, char *);
    BU_CK_VLS(vls);
    bu_vls_vprintf(vls, fmt, ap);
    va_end(ap);
d854 1
a854 1
    char append_buf[65536];   /* yuck -- fixed length buffer. */
d856 1
a856 4
    BU_CK_VLS(vls);
    append_buf[sizeof(append_buf)-1] = '\0';
    sprintf(append_buf, fmt, a,b,c,d,e,f,g,h,i,j);
    if (append_buf[sizeof(append_buf)-1] != '\0') {
d858 10
a867 6
	bu_log("bu_vls_printf buffer overflow\nWhile building string '%s'\n",
	       append_buf);
	bu_bomb("bu_vls_printf buffer overflow\n");
    }
    
    bu_vls_strcat(vls, append_buf);
@
