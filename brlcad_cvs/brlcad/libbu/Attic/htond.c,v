head	11.13;
access;
symbols
	ansi-20040405-merged:11.10.2.1
	postmerge-20040405-ansi:11.11
	premerge-20040404-ansi:11.10
	postmerge-autoconf:11.10
	autoconf-freeze:11.10
	premerge-autoconf:11.10
	ansi-20040316-freeze:11.10.2.1
	postmerge-20040315-windows:11.10
	premerge-20040315-windows:11.10
	windows-20040315-freeze:11.10
	autoconf-20031203:11.10
	autoconf-20031202:11.10
	autoconf-branch:11.10.0.10
	phong-branch:11.10.0.8
	photonmap-branch:11.10.0.6
	rel-6-1-DP:11.10
	windows-branch:11.10.0.4
	rel-6-0-2:11.8
	ansi-branch:11.10.0.2
	rel-6-0-1-branch:11.8.0.2
	hartley-6-0-post:11.9
	hartley-6-0-pre:11.8
	rel-6-0-1:11.8
	rel-6-0:11.8
	rel-5-4:11.3
	offsite-5-3-pre:11.6
	rel-5-3:11.3
	rel-5-2:11.3
	rel-5-1-branch:11.3.0.2
	rel-5-1:11.3
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1;
locks; strict;
comment	@ * @;


11.13
date	2004.05.21.18.06.24;	author morrison;	state dead;
branches;
next	11.12;

11.12
date	2004.05.10.15.30.44;	author erikg;	state Exp;
branches;
next	11.11;

11.11
date	2004.04.05.07.46.16;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2002.08.20.17.07.40;	author jra;	state Exp;
branches
	11.10.2.1;
next	11.9;

11.9
date	2002.08.15.20.54.53;	author hartley;	state Exp;
branches;
next	11.8;

11.8
date	2001.10.17.07.40.01;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2001.04.20.22.29.06;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	2000.09.07.19.35.04;	author butler;	state Exp;
branches;
next	11.5;

11.5
date	2000.07.07.05.21.21;	author cjohnson;	state Exp;
branches;
next	11.4;

11.4
date	2000.06.29.20.47.54;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	2000.03.28.18.55.07;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	99.01.12.22.04.54;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.51.13;	author mike;	state Rel4_4;
branches;
next	10.5;

10.5
date	94.12.22.00.16.23;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.09.29.22.57.05;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.08.12.19.17.21;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	93.02.22.21.22.41;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.36.34;	author mike;	state Rel4_0;
branches;
next	9.11;

9.11
date	91.09.26.02.05.57;	author phil;	state Exp;
branches;
next	9.10;

9.10
date	91.09.25.21.19.07;	author phil;	state Exp;
branches;
next	9.9;

9.9
date	91.09.19.17.40.35;	author butler;	state Exp;
branches;
next	9.8;

9.8
date	91.08.28.02.37.10;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	91.07.23.02.31.01;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	91.07.18.14.54.32;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	91.07.05.22.38.56;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.11.22.05.54.24;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.09.27.22.32.47;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.04.18.18.10.04;	author cjohnson;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.49.17;	author mike;	state Rel3_5;
branches;
next	8.2;

8.2
date	89.02.27.02.12.19;	author phil;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.28.29;	author mike;	state Rel3_0;
branches;
next	1.7;

1.7
date	88.10.01.09.50.14;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	88.09.17.03.31.56;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	88.09.16.02.49.22;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	88.09.08.00.48.50;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	88.05.13.22.06.03;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	88.02.04.03.57.21;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	88.02.02.01.57.21;	author phil;	state Exp;
branches;
next	;

11.10.2.1
date	2002.09.19.18.01.12;	author morrison;	state Exp;
branches;
next	;


desc
@host to/from IEEE floating point
@


11.13
log
@moved to src/
@
text
@/*
 *			H T O N D . C
 *
 *  Library routines for conversion between the local host
 *  64-bit ("double precision") representation, and
 *  64-bit IEEE double precision representation, in "network order",
 *  ie, big-endian, the MSB in byte [0], on the left.
 *
 *  As a quick review, the IEEE double precision format is as follows:
 *  sign bit, 11 bits of exponent (bias 1023), and 52 bits of mantissa,
 *  with a hidden leading one (0.1 binary).
 *  When the exponent is 0, IEEE defines a "denormalized number",
 *  which is not supported here.
 *  When the exponent is 2047 (all bits set), and:
 *	all mantissa bits are zero, value is infinity*sign,
 *	mantissa is non-zero, and:
 *		msb of mantissa=0:  signaling NAN
 *		msb of mantissa=1:  quiet NAN
 *
 *  Note that neither the input or output buffers need be word aligned,
 *  for greatest flexability in converting data, even though this
 *  imposes a speed penalty here.
 *
 *  These subroutines operate on a sequential block of numbers,
 *  to save on subroutine linkage execution costs, and to allow
 *  some hope for vectorization.
 *
 *  On brain-damaged machines like the SGI 3-D, where type "double"
 *  allocates only 4 bytes of space, these routines *still* return
 *  8 bytes in the IEEE buffer.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Release Status -
 *	Public Domain, Distribution Unlimited
 */
#ifndef lint
static const char libbu_htond_RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libbu/htond.c,v 11.12 2004/05/10 15:30:44 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <stdio.h>
#include "machine.h"
#include "bu.h"

#ifdef HAVE_MEMORY_H
#  include <memory.h>
#endif
#include <stdio.h>

#define	OUT_IEEE_ZERO	{ \
	*out++ = 0; \
	*out++ = 0; \
	*out++ = 0; \
	*out++ = 0; \
	*out++ = 0; \
	*out++ = 0; \
	*out++ = 0; \
	*out++ = 0; \
	continue; } \

#define	OUT_IEEE_NAN	{ /* Signaling NAN */ \
	*out++ = 0xFF; \
	*out++ = 0xF0; \
	*out++ = 0x0B; \
	*out++ = 0xAD; \
	*out++ = 0x0B; \
	*out++ = 0xAD; \
	*out++ = 0x0B; \
	*out++ = 0xAD; \
	continue; } \

/*
 *			H T O N D
 *
 *  Host to Network Doubles
 */
void
htond(register unsigned char *out, register const unsigned char *in, int count)
{
#if	defined(NATURAL_IEEE)
	/*
	 *  First, the case where the system already operates in
	 *  IEEE format internally, using big-endian order.
	 *  These are the lucky ones.
	 */
#	ifdef HAVE_MEMORY_H
		memcpy( out, in, count*8 );
#	else
		bcopy( in, out, count*8 );
#	endif
	return;
#	define	HTOND	yes1
#endif
#if	defined(REVERSED_IEEE)
	/* This machine uses IEEE, but in little-endian byte order */
	register int	i;
	for( i=count-1; i >= 0; i-- )  {
		*out++ = in[7];
		*out++ = in[6];
		*out++ = in[5];
		*out++ = in[4];
		*out++ = in[3];
		*out++ = in[2];
		*out++ = in[1];
		*out++ = in[0];
		in += SIZEOF_NETWORK_DOUBLE;
	}
	return;
#	define	HTOND	yes2

	/* Now, for the machine-specific stuff. */

#endif
#if	defined(sgi) && !defined(mips)
	/*
	 *  Silicon Graphics Iris workstation.
	 *  On the 2-D and 3-D, a double is type converted to a float
	 *  (4 bytes), but IEEE single precision has a different
	 *  number of exponent bits than double precision, so we
	 *  have to engage in gyrations here.
	 */
	register int	i;
	for( i=count-1; i >= 0; i-- )  {
		/* Brain-damaged 3-D case */
		float small;
		long float big;
		register unsigned char *fp = (unsigned char *)&small;

		*fp++ = *in++;
		*fp++ = *in++;
		*fp++ = *in++;
		*fp++ = *in++;
		big = small;		/* H/W cvt to IEEE double */

		fp = (unsigned char *)&big;
		*out++ = *fp++;
		*out++ = *fp++;
		*out++ = *fp++;
		*out++ = *fp++;
		*out++ = *fp++;
		*out++ = *fp++;
		*out++ = *fp++;
		*out++ = *fp++;
	}
	return;
#	define	HTOND	yes3
#endif
#if	defined(vax)
	/*
	 *  Digital Equipment's VAX.
	 *  VAX order is +6, +4, +2, sign|exp|fraction+0
	 *  with 8 bits of exponent, excess 128 base 2, exp=0 => zero.
	 */
	register int	i;
	for( i=count-1; i >= 0; i-- )  {
		register unsigned long left, right, signbit;
		register int exp;

		left  = (in[1]<<24) | (in[0]<<16) | (in[3]<<8) | in[2];
		right = (in[5]<<24) | (in[4]<<16) | (in[7]<<8) | in[6];
		in += 8;

		exp = (left >> 23) & 0xFF;
		signbit = left & 0x80000000;
		if( exp == 0 )  {
			if( signbit )  {
				OUT_IEEE_NAN;
			} else {
				OUT_IEEE_ZERO;
			}
		}
		exp += 1023 - 129;
		/* Round LSB by adding 4, rather than truncating */
#		ifdef ROUNDING
			right = (left<<(32-3)) | ((right+4)>>3);
#		else
			right = (left<<(32-3)) | (right>>3);
#		endif
		left =  ((left & 0x007FFFFF)>>3) | signbit | (exp<<20);
		*out++ = left>>24;
		*out++ = left>>16;
		*out++ = left>>8;
		*out++ = left;
		*out++ = right>>24;
		*out++ = right>>16;
		*out++ = right>>8;
		*out++ = right;
	}
	return;
#	define	HTOND	yes4
#endif
#if	defined(ibm) || defined(gould)
	/*
	 *  IBM Format.
	 *  7-bit exponent, base 16.
	 *  No hidden bits in mantissa (56 bits).
	 */
	register int	i;
	for( i=count-1; i >= 0; i-- )  {
		register unsigned long left, right, signbit;
		register int exp;

		left  = (in[0]<<24) | (in[1]<<16) | (in[2]<<8) | in[3];
		right = (in[4]<<24) | (in[5]<<16) | (in[6]<<8) | in[7];
		in += 8;

		exp = (left>>24) & 0x7F;	/* excess 64, base 16 */
		if( left == 0 && right == 0 )
			OUT_IEEE_ZERO;

		signbit = left & 0x80000000;
		left &= 0x00FFFFFF;
		if( signbit )  {
			/* The IBM uses 2's compliment on the mantissa,
			 * and IEEE does not.
			 */
			left  ^= 0xFFFFFFFF;
			right ^= 0xFFFFFFFF;
			if( right & 0x80000000 )  {
				/* There may be a carry */
				right += 1;
				if( (right & 0x80000000) == 0 )  {
					/* There WAS a carry */
					left += 1;
				}
			} else {
				/* There will be no carry to worry about */
				right += 1;
			}
			left &= 0x00FFFFFF;
			exp = (~exp) & 0x7F;
		}
		exp -= (64-32+1);		/* excess 32, base 16, + fudge */
		exp *= 4;			/* excess 128, base 2 */
ibm_normalized:
		if( left & 0x00800000 )  {
			/* fix = 0; */
			exp += 1023-129+1+ 3-0;/* fudge, slide hidden bit */
		} else if( left & 0x00400000 ) {
			/* fix = 1; */
			exp += 1023-129+1+ 3-1;
			left = (left<<1) |
				( (right>>(32-1)) & (0x7FFFFFFF>>(31-1)) );
			right <<= 1;
		} else if( left & 0x00200000 ) {
			/* fix = 2; */
			exp += 1023-129+1+ 3-2;
			left = (left<<2) |
				( (right>>(32-2)) & (0x7FFFFFFF>>(31-2)) );
			right <<= 2;
		} else if( left & 0x00100000 ){ 
			/* fix = 3; */
			exp += 1023-129+1+ 3-3;
			left = (left<<3) |
				( (right>>(32-3)) & (0x7FFFFFFF>>(31-3)) );
			right <<= 3;
		} else {
			/*  Encountered 4 consecutive 0 bits of mantissa,
			 *  attempt to normalize, and loop.
			 *  This case was not expected, but does happen,
			 *  at least on the Gould.
			 */
			exp -= 4;
			left = (left<<4) | (right>>(32-4));
			right <<= 4;
			goto ibm_normalized;
		}

		/* After suitable testing, this check can be deleted */
		if( (left & 0x00800000) == 0 )  {
			fprintf(stderr,"ibm->ieee missing 1, left=x%x\n", left);
			left = (left<<1) | (right>>31);
			right <<= 1;
			goto ibm_normalized;
		}

		/* Having nearly VAX format, shift to IEEE, rounding. */
#		ifdef ROUNDING
			right = (left<<(32-3)) | ((right+4)>>3);
#		else
			right = (left<<(32-3)) | (right>>3);
#		endif
		left =  ((left & 0x007FFFFF)>>3) | signbit | (exp<<20);

		*out++ = left>>24;
		*out++ = left>>16;
		*out++ = left>>8;
		*out++ = left;
		*out++ = right>>24;
		*out++ = right>>16;
		*out++ = right>>8;
		*out++ = right;
	}
	return;
#	define	HTOND	yes5
#endif
#if	defined(CRAY1) || defined(CRAY2) || defined(eta10)
	/*
	 *  Cray version.  Somewhat easier using 64-bit registers.
	 *  15 bit exponent, biased 040000 (octal).  48 mantissa bits.
	 *  No hidden bits.
	 */
	register int	i;
	for( i=count-1; i >= 0; i-- )  {
		register unsigned long word, signbit;
		register int exp;

#ifdef never
		if( (((int)in) & 07) == 0 )
			word = *((unsigned long *)in);
		else
#endif
			word  = (((long)in[0])<<56) | (((long)in[1])<<48) |
				(((long)in[2])<<40) | (((long)in[3])<<32) |
				(((long)in[4])<<24) | (((long)in[5])<<16) |
				(((long)in[6])<<8) | ((long)in[7]);
		in += 8;

		if( word == 0 )
			OUT_IEEE_ZERO;
		exp = (word >> 48) & 0x7FFF;
		signbit = word & 0x8000000000000000L;
#ifdef redundant
		if( exp <= 020001 || exp >= 060000 )
			OUT_IEEE_NAN;
#endif
		exp += 1023 - 040000 - 1;
		if( (exp & ~0x7FF) != 0 )  {
			fprintf(stderr,"htond:  Cray exponent too large on x%x\n", word);
			OUT_IEEE_NAN;
		}

#if defined(CRAY2) && defined(ROUNDING)
		/* Cray-2 seems to round down, XMP rounds up */
		word += 1;
#endif
		word = ((word & 0x00007FFFFFFFFFFFL) << (15-11+1)) |
			signbit | (((long)exp)<<(64-12));

		*out++ = word>>56;
		*out++ = word>>48;
		*out++ = word>>40;
		*out++ = word>>32;
		*out++ = word>>24;
		*out++ = word>>16;
		*out++ = word>>8;
		*out++ = word;
	}
	return;
#	define	HTOND	yes6
#endif
#if defined(convex_NATIVE) || defined(__convex__NATIVE)
	/*
	 *  Convex C1 version, for Native Convex floating point.
	 *  (Which seems to be VAX "G" format -- almost IEEE).
	 *  CC_OPTS = -fn to get this.
	 *  In modern times, Convex seems to use IEEE by default,
	 *  so we do too.
	 */
	register int	i;
	for( i=count-1; i >= 0; i-- )  {
		register unsigned long long	word;
		register int exp;


		word = *((unsigned long long *)in);
		in += 8;

		if( word == 0 )
			OUT_IEEE_ZERO;
		exp = (word >> 52) & 0x7FF;
		/* What value here is a Convex NaN ? */
		exp += 1023 - 1024 - 1;
		if( (exp & ~0x7FF) != 0 )  {
			fprintf(stderr,"htond:  Convex exponent too large on x%lx\n", word);
			OUT_IEEE_NAN;
		}

		word = ((word & 0x800FFFFFFFFFFFFFLL) |
			((long long)exp)<<52);

		*((unsigned long long *)out) = word;
		out += 8;
	}
	return;
#	define	HTOND	yes7
#endif

#ifndef	HTOND
# include "htond.c:  ERROR, no HtoND conversion for this machine type"
#endif
}

/*
 *			N T O H D
 *
 *  Network to Host Doubles
 */
void
ntohd(register unsigned char *out, register const unsigned char *in, int count)
{
#ifdef NATURAL_IEEE
	/*
	 *  First, the case where the system already operates in
	 *  IEEE format internally, using big-endian order.
	 *  These are the lucky ones.
	 */
	if( sizeof(double) != SIZEOF_NETWORK_DOUBLE )
		bu_bomb("ntohd:  sizeof(double) != SIZEOF_NETWORK_DOUBLE\n");
#	ifdef HAVE_MEMORY_H
		memcpy( out, in, count*SIZEOF_NETWORK_DOUBLE );
#	else
		bcopy( in, out, count*SIZEOF_NETWORK_DOUBLE );
#	endif
	return;
#	define	NTOHD	yes1
#endif
#if	defined(REVERSED_IEEE)
	/* This machine uses IEEE, but in little-endian byte order */
	register int	i;
	for( i=count-1; i >= 0; i-- )  {
		*out++ = in[7];
		*out++ = in[6];
		*out++ = in[5];
		*out++ = in[4];
		*out++ = in[3];
		*out++ = in[2];
		*out++ = in[1];
		*out++ = in[0];
		in += SIZEOF_NETWORK_DOUBLE;
	}
	return;
#	define	NTOHD	yes2
#endif
#if	defined(sgi) && !defined(mips)
	/*
	 *  Silicon Graphics Iris workstation.
	 *  See comments in htond() for discussion of the braindamage.
	 */
	register int	i;
	for( i=count-1; i >= 0; i-- )  {
		/* Brain-damaged 3-D case */
		float small;
		long float big;
		register unsigned char *fp = (unsigned char *)&big;
		*fp++ = *in++;
		*fp++ = *in++;
		*fp++ = *in++;
		*fp++ = *in++;
		*fp++ = *in++;
		*fp++ = *in++;
		*fp++ = *in++;
		*fp++ = *in++;
		small = big;		/* H/W cvt to IEEE double */
		fp = (unsigned char *)&small;
		*out++ = *fp++;
		*out++ = *fp++;
		*out++ = *fp++;
		*out++ = *fp++;
	}
	return;
#	define	NTOHD	yes3
#endif
#if	defined(vax)
	/*
	 *  Digital Equipment's VAX.
	 *  VAX order is +6, +4, +2, sign|exp|fraction+0
	 *  with 8 bits of exponent, excess 128 base 2, exp=0 => zero.
	 */
	register int	i;
	for( i=count-1; i >= 0; i-- )  {
		register unsigned long left, right, signbit;
		register int fix, exp;

		left  = (in[0]<<24) | (in[1]<<16) | (in[2]<<8) | in[3];
		right = (in[4]<<24) | (in[5]<<16) | (in[6]<<8) | in[7];
		in += 8;

		exp = (left >> 20) & 0x7FF;
		signbit = left & 0x80000000;
		if( exp == 0 )  {
			*out++ = 0;		/* VAX zero */
			*out++ = 0;
			*out++ = 0;
			*out++ = 0;
			*out++ = 0;
			*out++ = 0;
			*out++ = 0;
			*out++ = 0;
			continue;
		} else if( exp == 0x7FF )  {
vax_undef:		*out++ = 0x80;		/* VAX "undefined" */
			*out++ = 0;
			*out++ = 0;
			*out++ = 0;
			*out++ = 0;
			*out++ = 0;
			*out++ = 0;
			*out++ = 0;
			continue;
		}
		exp += 129 - 1023;
		/* Check for exponent out of range */
		if( (exp & ~0xFF) != 0 )  {
			fprintf(stderr,"ntohd: VAX exponent overflow\n");
			goto vax_undef;
		}
		left = ((left & 0x000FFFFF)<<3) | signbit | (exp<<23) |
			(right >> (32-3));
		right <<= 3;
		out[1] = left>>24;
		out[0] = left>>16;
		out[3] = left>>8;
		out[2] = left;
		out[5] = right>>24;
		out[4] = right>>16;
		out[7] = right>>8;
		out[6] = right;
		out += 8;
	}
	return;
#	define	NTOHD	yes4
#endif
#if	defined(ibm) || defined(gould)
	/*
	 *  IBM Format.
	 *  7-bit exponent, base 16.
	 *  No hidden bits in mantissa (56 bits).
	 */
	register int	i;
	for( i=count-1; i >= 0; i-- )  {
		register unsigned long left, right;
		register int fix, exp, signbit;

		left  = (in[0]<<24) | (in[1]<<16) | (in[2]<<8) | in[3];
		right = (in[4]<<24) | (in[5]<<16) | (in[6]<<8) | in[7];
		in += 8;

		exp = ((left >> 20) & 0x7FF);
		signbit = (left & 0x80000000) >> 24;
		if( exp == 0 || exp == 0x7FF )  {
ibm_undef:		*out++ = 0;		/* IBM zero.  No NAN */
			*out++ = 0;
			*out++ = 0;
			*out++ = 0;
			*out++ = 0;
			*out++ = 0;
			*out++ = 0;
			*out++ = 0;
			continue;
		}

		left = (left & 0x000FFFFF) | 0x00100000;/* replace "hidden" bit */

		exp += 129 - 1023 -1;	/* fudge, to make /4 and %4 work */
		fix = exp % 4;		/* 2^4 == 16^1;  get fractional exp */
		exp /= 4;		/* excess 32, base 16 */
		exp += (64-32+1);	/* excess 64, base 16, plus fudge */
		if( (exp & ~0xFF) != 0 )  {
			fprintf(stderr,"ntohd:  IBM exponent overflow\n");
			goto ibm_undef;
		}

		if( fix )  {
			left = (left<<fix) | (right >> (32-fix));
			right <<= fix;
		}

		if( signbit )  {
			/* The IBM actually uses complimented mantissa
			 * and exponent.
			 */
			left  ^= 0xFFFFFFFF;
			right ^= 0xFFFFFFFF;
			if( right & 0x80000000 )  {
				/* There may be a carry */
				right += 1;
				if( (right & 0x80000000) == 0 )  {
					/* There WAS a carry */
					left += 1;
				}
			} else {
				/* There will be no carry to worry about */
				right += 1;
			}
			left &= 0x00FFFFFF;
			exp = (~exp) & 0x7F;
		}


		/*  Not actually required, but for comparison purposes,
		 *  normalize the number.  Remove for production speed.
		 */
		while( (left & 0x00F00000) == 0 && left != 0 )  {
			if( signbit && exp <= 0x41 )  break;

			left = (left << 4) | (right >> (32-4));
			right <<= 4;
			if(signbit)  exp--;
			else exp++;
		}

		*out++ = signbit | exp;
		*out++ = left>>16;
		*out++ = left>>8;
		*out++ = left;
		*out++ = right>>24;
		*out++ = right>>16;
		*out++ = right>>8;
		*out++ = right;
	}
	return;
#	define	NTOHD	yes5
#endif
#if	defined(CRAY1) || defined(CRAY2) || defined(eta10)
	/*
	 *  Cray version.  Somewhat easier using 64-bit registers.
	 *  15 bit exponent, biased 040000 (octal).  48 mantissa bits.
	 *  No hidden bits.
	 */
	register int	i;
	for( i=count-1; i >= 0; i-- )  {
		register unsigned long word, signbit;
		register int exp;

#ifdef never
		if( (((int)in) & 07) == 0 )
			word = *((unsigned long *)in);
		else
#endif
			word  = (((long)in[0])<<56) | (((long)in[1])<<48) |
				(((long)in[2])<<40) | (((long)in[3])<<32) |
				(((long)in[4])<<24) | (((long)in[5])<<16) |
				(((long)in[6])<<8) | ((long)in[7]);
		in += 8;

		exp = (word>>(64-12)) & 0x7FF;
		signbit = word & 0x8000000000000000L;
		if( exp == 0 )  {
			word = 0;
			goto cray_out;
		}
		if( exp == 0x7FF )  {
			word = 067777L<<48;	/* Cray out of range */
			goto cray_out;
		}
		exp += 040000 - 1023 + 1;
		word = ((word & 0x000FFFFFFFFFFFFFL) >> (15-11+1)) |
			0x0000800000000000L | signbit |
			(((long)exp)<<(64-16));

cray_out:
		*out++ = word>>56;
		*out++ = word>>48;
		*out++ = word>>40;
		*out++ = word>>32;
		*out++ = word>>24;
		*out++ = word>>16;
		*out++ = word>>8;
		*out++ = word;
	}
	return;
#	define	NTOHD	yes6
#endif
#if defined(convex_NATIVE) || defined(__convex__NATIVE)
	/*
	 *  Convex C1 version, for Native Convex floating point.
	 */
	register int	i;
	for( i=count-1; i >= 0; i-- )  {
		register unsigned long long	word;
		register int exp;

		word = *((unsigned long long *)in);
		in += 8;

		exp = (word >> 52) & 0x7FF;
		if( exp == 0 )  {
			word = 0;
			goto convex_out;
		}
		if( exp == 0x7FF )  {
			/* IEEE NaN = Convex what? */
			fprintf(stderr,"ntohd: Convex NaN unimplemented\n");
			word = 0;
			goto convex_out;
		}
		exp += 1024 - 1023 + 1;
		word = (word & 0x800FFFFFFFFFFFFFLL) |
			(((long long)exp)<<52);

convex_out:
		*((unsigned long long *)out) = word;
		out += 8;
	}
	return;
#	define	NTOHD	yes7
#endif

#ifndef	NTOHD
# include "ntohd.c:  ERROR, no NtoHD conversion for this machine type"
#endif
}
@


11.12
log
@change conf.h to a wrapped config.h
@
text
@d44 1
a44 1
static const char libbu_htond_RCSid[] = "@@(#)$Header: /cvs/brlcad/libbu/htond.c,v 11.11 2004/04/05 07:46:16 morrison Exp $ (BRL)";
@


11.11
log
@merge of ansi-6-0-branch into HEAD
@
text
@d44 1
a44 1
static const char libbu_htond_RCSid[] = "@@(#)$Header$ (BRL)";
d47 5
a51 1
#include "conf.h"
@


11.10
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d44 1
a44 1
static const char libbu_htond_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/htond.c,v 11.8 2001/10/17 07:40:01 morrison Exp $ (BRL)";
d85 1
a85 4
htond( out, in, count )
register unsigned char	*out;
register const unsigned char	*in;
int			count;
d407 1
a407 4
ntohd( out, in, count )
register unsigned char	*out;
register const unsigned char	*in;
int			count;
@


11.10.2.1
log
@Initial ANSIfication
@
text
@d44 1
a44 1
static const char libbu_htond_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/htond.c,v 11.10 2002/08/20 17:07:40 jra Exp $ (BRL)";
d85 4
a88 1
htond(register unsigned char *out, register const unsigned char *in, int count)
d410 4
a413 1
ntohd(register unsigned char *out, register const unsigned char *in, int count)
@


11.9
log
@Converted from K&R to ANSI C - RFH
@
text
@d85 4
a88 1
htond(register unsigned char *out, register const unsigned char *in, int count)
d410 4
a413 1
ntohd(register unsigned char *out, register const unsigned char *in, int count)
@


11.8
log
@Mac OS X warning and error fixes for non-production build
@
text
@d44 1
a44 1
static const char libbu_htond_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/htond.c,v 11.7 2001/04/20 22:29:06 morrison Exp $ (BRL)";
d85 1
a85 4
htond( out, in, count )
register unsigned char	*out;
register const unsigned char	*in;
int			count;
d407 1
a407 4
ntohd( out, in, count )
register unsigned char	*out;
register const unsigned char	*in;
int			count;
@


11.7
log
@CONST to const
@
text
@d44 1
a44 1
static const char libbu_htond_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/htond.c,v 11.6 2000/09/07 19:35:04 butler Exp $ (BRL)";
d52 3
d96 3
a98 1
#	if BSD
a99 2
#	else
		memcpy( out, in, count*8 );
d423 3
a425 1
#	if BSD
a426 2
#	else
		memcpy( out, in, count*SIZEOF_NETWORK_DOUBLE );
@


11.6
log
@Changes to support REVERSED_IEEE.  These were doing the conversion and then
calling bu_bomb anyway.
@
text
@d44 1
a44 1
static const char libbu_htond_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/htond.c,v 11.5 2000/07/07 05:21:21 cjohnson Exp $ (BRL)";
d84 1
a84 1
register CONST unsigned char	*in;
d409 1
a409 1
register CONST unsigned char	*in;
@


11.5
log
@LINT plus minor bug fix in bu_tcl.c
@
text
@d44 1
a44 1
static const char libbu_htond_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/htond.c,v 11.4 2000/06/29 20:47:54 mike Exp $ (BRL)";
d115 1
d442 1
@


11.4
log
@
Added SIZEOF_NETWORK_FLOAT, htonf(), ntohf().
@
text
@d44 1
a44 1
static char libbu_htond_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/htond.c,v 11.3 2000/03/28 18:55:07 mike Exp $ (BRL)";
@


11.3
log
@
Put libbu_filename_ prefixes on RCSid variables.
@
text
@d44 1
a44 1
static char libbu_htond_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/htond.c,v 11.2 1999/01/12 22:04:54 mike Exp $ (BRL)";
d113 1
a113 1
		in += 8;
d417 2
a418 2
	if( sizeof(double) != 8 )
		fprintf(stderr, "ntohd:  sizeof(double) != 8\n");
d420 1
a420 1
		bcopy( in, out, count*8 );
d422 1
a422 1
		memcpy( out, in, count*8 );
d439 1
a439 1
		in += 8;
@


11.2
log
@Made input parameters be CONST
Added declarations to bu.h
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/htond.c,v 11.1 1995/01/04 09:51:13 mike Rel4_4 $ (BRL)";
@


11.1
log
@Release_4.4
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/libplot3/RCS/htond.c,v 10.5 94/12/22 00:16:23 mike Exp $ (BRL)";
d48 3
d84 1
a84 1
register unsigned char	*in;
d408 1
a408 1
register unsigned char	*in;
@


10.5
log
@Eliminated #elif
Changed convex to IEEE by default.
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/libplot3/RCS/htond.c,v 10.4 94/09/29 22:57:05 mike Exp Locker: mike $ (BRL)";
@


10.4
log
@When not BSD, don't use bcopy().
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/libplot3/RCS/htond.c,v 10.3 94/08/12 19:17:21 gdurf Exp Locker: mike $ (BRL)";
d96 3
a98 2
#	define	HTOND	yes
#elif	defined(REVERSED_IEEE)
d112 1
a112 1
#	define	HTOND	yes
d116 2
a117 1
#elif	defined(sgi) && !defined(mips)
d149 3
a151 2
#	define	HTOND	yes
#elif	defined(vax)
d193 3
a195 2
#	define	HTOND	yes
#elif	defined(ibm) || defined(gould)
d298 3
a300 2
#	define	HTOND	yes
#elif	defined(CRAY1) || defined(CRAY2) || defined(eta10)
d353 3
a355 2
#	define	HTOND	yes
#elif defined(convex) || defined(__convex__)
d359 3
d389 1
a389 1
#	define	HTOND	yes
d422 3
a424 2
#	define	NTOHD	yes
#elif	defined(REVERSED_IEEE)
d438 3
a440 2
#	define	NTOHD	yes
#elif	defined(sgi) && !defined(mips)
d467 3
a469 2
#	define	NTOHD	yes
#elif	defined(vax)
d527 3
a529 2
#	define	NTOHD	yes
#elif	defined(ibm) || defined(gould)
d618 3
a620 2
#	define	NTOHD	yes
#elif	defined(CRAY1) || defined(CRAY2) || defined(eta10)
d668 3
a670 2
#	define	NTOHD	yes
#elif defined(convex) || defined(__convex__)
d702 1
a702 1
#	define	NTOHD	yes
@


10.3
log
@Pulled out determination of NATRUAL_IEEE and REVERSED_IEEE into conf.h
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/libplot3/RCS/htond.c,v 10.2 93/02/22 21:22:41 mike Exp $ (BRL)";
d90 5
a94 1
	bcopy( in, out, count*8 );
d407 5
a411 1
	bcopy( in, out, count*8 );
@


10.2
log
@Added HP 9000 support, from Terry Hweitt, Manchester Computing Centre.
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/libplot3/RCS/htond.c,v 10.1 91/10/12 06:36:34 mike Rel4_0 Locker: mike $ (BRL)";
d47 2
a72 24

#if defined(sun) || (defined(alliant) && !defined(i860)) || \
	defined(ardent) || \
	defined(stellar) || defined(sparc) || defined(mips) || \
	(defined(sgi) && defined(mips)) || \
	(defined(__sgi) && defined(__mips)) || \
	defined(pyr) || defined(apollo) || defined(aux) || \
	defined(_AIX) || defined(NeXT) || defined(hpux)

	/*  These systems already operate in
	 *  IEEE format internally, using big-endian order.
	 */
#	define	NATURAL_IEEE	yes
#endif

#if defined(n16) || defined(i386) || defined(i860) || defined(__stardent)
	/* These systems operate in IEEE format, using little-endian order */
#	define	REVERSED_IEEE	yes
#endif

#if defined(NATURAL_IEEE) && defined(REVERSED_IEEE)
# include "htond.c:  ERROR, two IEEE conversions defined for this machine type"
#endif

d84 1
a84 1
#ifdef	NATURAL_IEEE
a89 3
#	ifdef SYSV
	memcpy( out, in, count*8 );
#	else
a90 1
#	endif
d93 1
a93 3
#endif

#if	defined(REVERSED_IEEE)
d108 2
a109 1
#endif
d111 1
a111 1
#if	defined(sgi) && !defined(mips)
d144 1
a144 3
#endif

#if	defined(vax)
d187 1
a187 3
#endif

#if	defined(ibm) || defined(gould)
d291 1
a291 3
#endif

#if	defined(CRAY1) || defined(CRAY2) || defined(eta10)
d345 1
a345 3
#endif

#if defined(convex) || defined(__convex__)
a402 3
#	ifdef SYSV
	memcpy( out, in, count*8 );
#	else
a403 1
#	endif
d406 1
a406 3
#endif

#if	defined(REVERSED_IEEE)
d421 1
a421 3
#endif

#if	defined(sgi) && !defined(mips)
d449 1
a449 3
#endif

#if	defined(vax)
d508 1
a508 3
#endif

#if	defined(ibm) || defined(gould)
d598 1
a598 3
#endif

#if	defined(CRAY1) || defined(CRAY2) || defined(eta10)
d647 1
a647 3
#endif

#if defined(convex) || defined(__convex__)
@


10.1
log
@Release_4.0
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/libplot3/RCS/htond.c,v 9.11 91/09/26 02:05:57 phil Exp $ (BRL)";
d78 1
a78 1
	defined(_AIX) || defined(NeXT)
@


9.11
log
@Of couse it helps to get them right too.  The i386 was just tested
via htester against SGI and Gould.  Note that i860 is now being
called reversed IEEE whether is is an alliant or not.
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/libplot3/RCS/htond.c,v 9.10 91/09/25 21:19:07 phil Exp Locker: phil $ (BRL)";
@


9.10
log
@Added definitions for PC/AT running SysV unix, and non-alliant
i860 (e.g. iPSC/860).
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/libplot3/RCS/htond.c,v 9.9 91/09/19 17:40:35 butler Exp Locker: phil $ (BRL)";
d78 1
a78 2
	defined(_AIX) || defined(NeXT) || \
	defined(i386) || (defined(i860) && !defined(alliant))
d86 1
a86 1
#if defined(n16) || (defined(alliant) && defined(i860)) || defined(__stardent)
@


9.9
log
@updated the convex entry.  Convex now is __convex__ not convex
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/libplot3/RCS/htond.c,v 9.8 91/08/28 02:37:10 mike Exp $ (BRL)";
d78 2
a79 1
	defined(_AIX) || defined(NeXT)
@


9.8
log
@Added more error checking.
The Stardent is a REVERSED_IEEE system, as it is i860 based.
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/libplot3/RCS/htond.c,v 9.7 91/07/23 02:31:01 mike Exp $ (BRL)";
d380 1
a380 1
#ifdef convex
d698 1
a698 1
#ifdef convex
@


9.7
log
@Added NeXT
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/libplot3/RCS/htond.c,v 9.6 91/07/18 14:54:32 mike Exp $ (BRL)";
d86 1
a86 1
#if defined(n16) || defined(i860)
d89 4
@


9.6
log
@IBM is IEEE, amazingly enough!
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/libplot3/RCS/htond.c,v 9.5 91/07/05 22:38:56 mike Exp $ (BRL)";
d78 1
a78 1
	defined(_AIX)
@


9.5
log
@IRIX 4.0 ANSI mode
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/libplot3/RCS/htond.c,v 9.4 90/11/22 05:54:24 mike Exp $ (BRL)";
d77 2
a78 1
	defined(pyr) || defined(apollo) || defined(aux)
@


9.4
log
@Added Alliant FX/2800 (e.g., i860) support
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/libplot3/RCS/htond.c,v 9.3 90/09/27 22:32:47 mike Exp $ (BRL)";
d75 2
@


9.3
log
@Added support for the Encore Multimax, which is
an IEEE little-endian machine.
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: htond.c,v 9.2 90/04/18 18:10:04 cjohnson Exp $ (BRL)";
d72 2
a73 1
#if defined(sun) || defined(alliant) || defined(ardent) || \
d83 1
a83 1
#if defined(n16)
@


9.2
log
@Add aux to the list of defined systems.
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: htond.c,v 9.1 89/05/19 05:49:17 cjohnson Locked $ (BRL)";
d82 5
d113 17
d407 1
a407 1
# include "htond.c:  Error, no conversion for this machine type"
d439 17
d726 1
a726 1
# include "ntohd.c:  Error, no conversion for this machine type"
@


9.1
log
@Release_3.5
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: htond.c,v 8.2 89/02/27 02:12:19 phil Exp $ (BRL)";
d74 1
a74 1
	defined(pyr) || defined(apollo)
@


8.2
log
@added apollo
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: htond.c,v 8.1 88/10/05 00:28:29 phil Locked $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: htond.c,v 1.7 88/10/01 09:50:14 mike Exp $ (BRL)";
d74 1
a74 1
	defined(pyr)
@


1.7
log
@Added check for Pyramid (ieee), and ETA10 (thought to be Cray format).
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: htond.c,v 1.6 88/09/17 03:31:56 mike Locked $ (BRL)";
@


1.6
log
@Added sparc, ardent, stellar.
Reorganized SGI 3-D code.
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: htond.c,v 1.5 88/09/16 02:49:22 mike Locked $ (BRL)";
d73 2
a74 1
	defined(stellar) || defined(sparc) || defined(mips)
d294 1
a294 1
#if	defined(CRAY1) || defined(CRAY2)
d600 1
a600 1
#if	defined(CRAY1) || defined(CRAY2)
@


1.5
log
@Changed to CRAY1 and CRAY2
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: htond.c,v 1.4 88/09/08 00:48:50 mike Locked $ (BRL)";
d71 10
d92 1
a92 1
#if	defined(sun) || defined(alliant)
d107 1
a107 1
#if	defined(sgi)
a109 1
	 *  On the 4-D, a double is a double.
d117 20
a136 30
		if( sizeof(double) == 4 )  {
			/* Brain-damaged 3-D case */
			float small;
			long float big;
			register unsigned char *fp = (unsigned char *)&small;
			*fp++ = *in++;
			*fp++ = *in++;
			*fp++ = *in++;
			*fp++ = *in++;
			big = small;		/* H/W cvt to IEEE double */
			fp = (unsigned char *)&big;
			*out++ = *fp++;
			*out++ = *fp++;
			*out++ = *fp++;
			*out++ = *fp++;
			*out++ = *fp++;
			*out++ = *fp++;
			*out++ = *fp++;
			*out++ = *fp++;
		} else {
			/* 4-D case */
			*out++ = *in++;
			*out++ = *in++;
			*out++ = *in++;
			*out++ = *in++;
			*out++ = *in++;
			*out++ = *in++;
			*out++ = *in++;
			*out++ = *in++;
		}
d399 1
a399 1
#if	defined(sun) || defined(alliant)
d416 1
a416 1
#if	defined(sgi)
d423 18
a440 30
		if( sizeof(double) == 4 )  {
			/* Brain-damaged 3-D case */
			float small;
			long float big;
			register unsigned char *fp = (unsigned char *)&big;
			*fp++ = *in++;
			*fp++ = *in++;
			*fp++ = *in++;
			*fp++ = *in++;
			*fp++ = *in++;
			*fp++ = *in++;
			*fp++ = *in++;
			*fp++ = *in++;
			small = big;		/* H/W cvt to IEEE double */
			fp = (unsigned char *)&small;
			*out++ = *fp++;
			*out++ = *fp++;
			*out++ = *fp++;
			*out++ = *fp++;
		} else {
			/* 4-D case */
			*out++ = *in++;
			*out++ = *in++;
			*out++ = *in++;
			*out++ = *in++;
			*out++ = *in++;
			*out++ = *in++;
			*out++ = *in++;
			*out++ = *in++;
		}
@


1.4
log
@Added support for the Convex
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: htond.c,v 1.3 88/05/13 22:06:03 mike Locked $ (BRL)";
d294 1
a294 1
#if	defined(cray) || defined(CRAY2)
d612 1
a612 1
#if	defined(cray) || defined(CRAY2)
@


1.3
log
@lint fix
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: htond.c,v 1.2 88/02/04 03:57:21 mike Locked $ (BRL)";
d307 1
a307 1
			word = *((float *)in);
d350 34
d625 1
a625 1
			word = *((float *)in);
d658 35
@


1.2
log
@Fixes for Cray-2, where "int" is only 32 bits, and "long" is 64.
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: htond.c,v 1.10 88/01/30 01:08:50 mike Locked $ (BRL)";
d76 1
d360 1
@


1.1
log
@Initial revision
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: htond.c,v 1.11 88/01/30 01:43:49 mike Exp $ (BRL)";
d309 4
a312 2
			word  = (in[0]<<56) | (in[1]<<48) | (in[2]<<40) | (in[3]<<32) |
				(in[4]<<24) | (in[5]<<16) | (in[6]<<8) | in[7];
d318 1
a318 1
		signbit = word & 0x8000000000000000;
d325 1
a325 1
			fprintf(stderr,"htond:  Cray exponent too large\n");
d329 6
a334 2
		word = ((word & 0x00007FFFFFFFFFFF) << (15-11+1)) |
			signbit | (exp<<(64-12));
d592 4
a595 2
			word  = (in[0]<<56) | (in[1]<<48) | (in[2]<<40) | (in[3]<<32) |
				(in[4]<<24) | (in[5]<<16) | (in[6]<<8) | in[7];
d599 1
a599 1
		signbit = word & 0x8000000000000000;
d605 1
a605 1
			word = 067777<<48;	/* Cray out of range */
d609 3
a611 2
		word = ((word & 0x000FFFFFFFFFFFFF) >> (15-11+1)) |
			0x0000800000000000 | signbit | (exp<<(64-16));
@
