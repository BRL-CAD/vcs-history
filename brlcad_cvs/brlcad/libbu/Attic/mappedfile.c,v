head	1.30;
access;
symbols
	ansi-20040405-merged:1.26.2.3
	postmerge-20040405-ansi:1.28
	premerge-20040404-ansi:1.27
	postmerge-autoconf:1.27
	autoconf-freeze:1.26.10.1
	premerge-autoconf:1.27
	ansi-20040316-freeze:1.26.2.1
	postmerge-20040315-windows:1.27
	premerge-20040315-windows:1.26
	windows-20040315-freeze:1.26.4.1
	autoconf-20031203:1.26
	autoconf-20031202:1.26
	autoconf-branch:1.26.0.10
	phong-branch:1.26.0.8
	photonmap-branch:1.26.0.6
	rel-6-1-DP:1.26
	windows-branch:1.26.0.4
	rel-6-0-2:1.24
	ansi-branch:1.26.0.2
	rel-6-0-1-branch:1.24.0.2
	hartley-6-0-post:1.25
	hartley-6-0-pre:1.24
	rel-6-0-1:1.24
	rel-6-0:1.24
	rel-5-4:1.13.2.2
	offsite-5-3-pre:1.20
	rel-5-3:1.13.2.2
	rel-5-2:1.13
	rel-5-1-branch:1.13.0.2
	rel-5-1:1.13
	rel-5-0:1.5
	rel-5-0-beta:1.4
	rel-4-5:1.4
	ctj-4-5-post:1.1
	ctj-4-5-pre:1.1;
locks; strict;
comment	@ * @;


1.30
date	2004.05.21.18.06.24;	author morrison;	state dead;
branches;
next	1.29;

1.29
date	2004.05.10.15.30.44;	author erikg;	state Exp;
branches;
next	1.28;

1.28
date	2004.04.05.07.46.16;	author morrison;	state Exp;
branches;
next	1.27;

1.27
date	2004.03.16.19.40.49;	author morrison;	state Exp;
branches;
next	1.26;

1.26
date	2002.08.20.17.07.41;	author jra;	state Exp;
branches
	1.26.2.1
	1.26.4.1
	1.26.10.1;
next	1.25;

1.25
date	2002.08.15.20.54.53;	author hartley;	state Exp;
branches;
next	1.24;

1.24
date	2001.11.19.19.34.26;	author butler;	state Exp;
branches;
next	1.23;

1.23
date	2001.07.09.17.38.24;	author morrison;	state Exp;
branches;
next	1.22;

1.22
date	2001.04.20.22.29.07;	author morrison;	state Exp;
branches;
next	1.21;

1.21
date	2001.03.19.22.19.45;	author butler;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.24.15.56.29;	author jra;	state Exp;
branches;
next	1.19;

1.19
date	2000.08.30.23.22.36;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	2000.08.30.23.09.22;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	2000.08.30.23.03.05;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	2000.08.16.21.03.44;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	2000.07.07.05.20.12;	author cjohnson;	state Exp;
branches;
next	1.14;

1.14
date	2000.07.07.00.37.35;	author cjohnson;	state Exp;
branches;
next	1.13;

1.13
date	2000.03.28.18.55.08;	author mike;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2000.03.03.01.01.17;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	2000.03.02.02.44.02;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.02.20.10.40;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.13.01.17.19;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.11.18.55.45;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	99.12.29.20.12.42;	author jra;	state Exp;
branches;
next	1.6;

1.6
date	99.12.22.03.35.45;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	99.07.02.19.08.28;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	98.01.07.03.34.16;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	97.12.04.12.14.43;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	97.11.22.02.58.24;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	96.08.31.06.55.33;	author mike;	state Exp;
branches;
next	;

1.13.2.1
date	2000.11.03.19.20.36;	author bparker;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2001.01.24.14.44.23;	author jra;	state Exp;
branches;
next	;

1.26.2.1
date	2002.09.19.18.01.12;	author morrison;	state Exp;
branches;
next	1.26.2.2;

1.26.2.2
date	2004.03.17.21.16.50;	author morrison;	state Exp;
branches;
next	1.26.2.3;

1.26.2.3
date	2004.04.05.00.50.06;	author morrison;	state Exp;
branches;
next	;

1.26.4.1
date	2002.09.26.23.03.52;	author morrison;	state Exp;
branches;
next	;

1.26.10.1
date	2004.03.18.18.08.13;	author erikg;	state Exp;
branches;
next	;


desc
@mappedfile.c
@


1.30
log
@moved to src/
@
text
@/*
 *			M A P P E D F I L E . C
 *
 *  Routines for sharing large read-only data files
 *  like height fields, bit map solids, texture maps, etc.
 *  Uses memory mapped files where available.
 *
 *  Each instance of the file has the raw data available as element "buf".
 *  If a particular application needs to transform the raw data in a
 *  manner that is identical across all uses of that application
 *  (e.g. height fields, EBMs, etc), then the application should
 *  provide a non-null "appl" string, to tag the format of the "apbuf".
 *  This will keep different applications from sharing that instance
 *  of the file.
 *  Thus, if the same filename is opened for interpretation as both
 *  an EBM and a height field, they will be assigned different mapped file
 *  structures, so that the "apbuf" pointers are distinct.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
 */
#ifndef lint
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libbu/mappedfile.c,v 1.29 2004/05/10 15:30:44 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include <fcntl.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"

#ifdef HAVE_UNIX_IO
# include <sys/types.h>
# include <sys/stat.h>
#endif

#ifdef HAVE_SYS_MMAN_H
# include <sys/mman.h>
# if !defined(MAP_FAILED)
#    define MAP_FAILED	((void *)-1)	/* Error return from mmap() */
# endif
#endif

#include "bu.h"

static struct bu_list	bu_mapped_file_list = {
	0,
	(struct bu_list *)NULL,
	(struct bu_list *)NULL
};	/* list of currently open mapped files */

/*
 *			B U _ O P E N _ M A P P E D _ F I L E
 *
 *  If the file can not be opened, as descriptive an error message as
 *  possible will be printed, to simplify code handling in the caller.
 *
 *  Mapped files are always opened read-only.
 *
 *  If the system does not support mapped files, the data is read into memory.
 */
struct bu_mapped_file *
bu_open_mapped_file(const char *name, const char *appl)
          	      		/* file name */
          	      		/* non-null only when app. will use 'apbuf' */
{
	struct bu_mapped_file	*mp = (struct bu_mapped_file *)NULL;
#ifdef HAVE_UNIX_IO
	struct stat		sb;
#endif
	int			ret;
	int			fd;	/* unix file descriptor */
#ifndef HAVE_UNIX_IO
	FILE			*fp;	/* stdio file pointer */
#endif

	if( bu_debug&BU_DEBUG_MAPPED_FILE )
		bu_log("bu_open_mapped_file(%s, %s) sbrk=x%lx\n",
			name, appl?appl:"(NIL)",
#ifdef HAVE_SBRK_DECL
			(long)sbrk(0)
#else
			0
#endif
			);

	/* See if file has already been mapped, and can be shared */
	bu_semaphore_acquire(BU_SEM_MAPPEDFILE);
	if( BU_LIST_UNINITIALIZED( &bu_mapped_file_list ) )  {
		BU_LIST_INIT( &bu_mapped_file_list );
	}
	for( BU_LIST_FOR( mp, bu_mapped_file, &bu_mapped_file_list ) )  {
		BU_CK_MAPPED_FILE(mp);
		if( strcmp( name, mp->name ) )  continue;
		if( appl && strcmp( appl, mp->appl ) )
			continue;
		/* File is already mapped -- verify size and modtime */
#ifdef HAVE_UNIX_IO
		if( !mp->dont_restat )  {
			bu_semaphore_acquire(BU_SEM_SYSCALL);
			ret = stat( name, &sb );
			bu_semaphore_release(BU_SEM_SYSCALL);
			if( ret < 0 )  goto do_reuse;	/* File vanished from disk, mapped copy still OK */
			if( sb.st_size != mp->buflen )  {
				bu_log("bu_open_mapped_file(%s) WARNING: File size changed from %ld to %ld, opening new version.\n",
					name, mp->buflen, sb.st_size );
				goto dont_reuse;
			}
			if( sb.st_mtime != mp->modtime )  {
				bu_log("bu_open_mapped_file(%s) WARNING: File modified since last mapped, opening new version.\n",
					name);
				goto dont_reuse;
			}
			/* To be completely safe, should check st_dev and st_inum */
		}
#endif
do_reuse:
		/* It is safe to reuse mp */
		mp->uses++;
		bu_semaphore_release(BU_SEM_MAPPEDFILE);
		if( bu_debug&BU_DEBUG_MAPPED_FILE )
			bu_pr_mapped_file("open_reused", mp);
		return mp;
dont_reuse:
		/* mp doesn't reflect the file any longer.  Invalidate. */
		mp->appl = "__STALE__";
		/* Can't invalidate old copy, it may still be in use. */
		/* Fall through, and open the new version */
	}
	bu_semaphore_release(BU_SEM_MAPPEDFILE);
	mp = (struct bu_mapped_file *)NULL;

	/* File is not yet mapped, open file read only. */
#ifdef HAVE_UNIX_IO
	bu_semaphore_acquire(BU_SEM_SYSCALL);
	fd = open( name, O_RDONLY );
	bu_semaphore_release(BU_SEM_SYSCALL);

	if( fd < 0 )  {
		if (bu_debug&BU_DEBUG_DB)
			perror(name);
		goto fail;
	}

	bu_semaphore_acquire(BU_SEM_SYSCALL);
	ret = fstat( fd, &sb );
	bu_semaphore_release(BU_SEM_SYSCALL);

	if( ret < 0 )  {
		perror(name);
		goto fail;
	}

	if( sb.st_size == 0 )  {
		bu_log("bu_open_mapped_file(%s) 0-length file\n", name);
		goto fail;
	}
#endif /* HAVE_UNIX_IO */

	/* Optimisticly assume that things will proceed OK */
	BU_GETSTRUCT( mp, bu_mapped_file );
	mp->name = bu_strdup( name );
	if( appl ) mp->appl = bu_strdup( appl );

#ifdef HAVE_UNIX_IO
	mp->buflen = sb.st_size;
	mp->modtime = sb.st_mtime;
#  ifdef HAVE_SYS_MMAN_H

	/* Attempt to access as memory-mapped file */
	bu_semaphore_acquire(BU_SEM_SYSCALL);
	mp->buf = mmap(
		(caddr_t)0, (size_t)sb.st_size, PROT_READ, MAP_PRIVATE,
		fd, (off_t)0 );
	bu_semaphore_release(BU_SEM_SYSCALL);

	if( mp->buf == MAP_FAILED )  perror(mp->name);
	if( mp->buf != MAP_FAILED )  {
	    	/* OK, it's memory mapped in! */
	    	mp->is_mapped = 1;
	    	/* It's safe to close the fd now, the manuals say */
	} else
#  endif /* HAVE_SYS_MMAN_H */
	{
		/* Allocate a local buffer, and slurp it in */
		mp->buf = bu_malloc( (size_t)sb.st_size, mp->name );

		bu_semaphore_acquire(BU_SEM_SYSCALL);
		ret = read( fd, mp->buf, (size_t)sb.st_size );
		bu_semaphore_release(BU_SEM_SYSCALL);

		if( ret != sb.st_size )  {
			perror("read");
			bu_free( mp->buf, mp->name );
			goto fail;
		}
	}

	bu_semaphore_acquire(BU_SEM_SYSCALL);
	close(fd);
	bu_semaphore_release(BU_SEM_SYSCALL);

#else /* !HAVE_UNIX_IO */

	/* Read it in with stdio, with no clue how big it is */
	bu_semaphore_acquire(BU_SEM_SYSCALL);
	fp = fopen( name, "r");
	bu_semaphore_release(BU_SEM_SYSCALL);

	if( fp == NULL )  {
		perror(name);
		goto fail;
	}
	/* Read it once to see how large it is */
	{
		char	buf[32768];
		int	got;
		mp->buflen = 0;

		bu_semaphore_acquire(BU_SEM_SYSCALL);
		while( (got = fread( buf, 1, sizeof(buf), fp )) > 0 )
			mp->buflen += got;
		rewind(fp);
		bu_semaphore_release(BU_SEM_SYSCALL);

	}
	/* Malloc the necessary buffer */
	mp->buf = bu_malloc( mp->buflen, mp->name );

	/* Read it again into the buffer */
	bu_semaphore_acquire(BU_SEM_SYSCALL);
	ret = fread( mp->buf, mp->buflen, 1, fp );
	bu_semaphore_release(BU_SEM_SYSCALL);

	if( ret != 1 )  {
		bu_semaphore_acquire(BU_SEM_SYSCALL);
		perror("fread");
		fclose(fp);
		bu_semaphore_release(BU_SEM_SYSCALL);

		bu_log("bu_open_mapped_file() 2nd fread failed? len=%d\n", mp->buflen);
		bu_free( mp->buf, "non-unix fread buf" );
		goto fail;
	}

	bu_semaphore_acquire(BU_SEM_SYSCALL);
	fclose(fp);
	bu_semaphore_release(BU_SEM_SYSCALL);
#endif

	mp->uses = 1;
	mp->l.magic = BU_MAPPED_FILE_MAGIC;

	bu_semaphore_acquire(BU_SEM_MAPPEDFILE);
	BU_LIST_APPEND( &bu_mapped_file_list, &mp->l );
	bu_semaphore_release(BU_SEM_MAPPEDFILE);

	if( bu_debug&BU_DEBUG_MAPPED_FILE )  {
		bu_pr_mapped_file("1st_open", mp);
		bu_log("bu_open_mapped_file() sbrk=x%lx\n",
#ifdef HAVE_SBRK_DECL
			(long)sbrk(0)
#else
			0
#endif
			);
	}
	return mp;

fail:
	if( mp )  {
		bu_free( mp->name, "mp->name" );
		if( mp->appl ) bu_free( mp->appl, "mp->appl" );
		/* Don't free mp->buf here, it might not be bu_malloced but mmaped */
		bu_free( mp, "mp from bu_open_mapped_file fail");
	}

	if (bu_debug&BU_DEBUG_DB)
	  bu_log("bu_open_mapped_file(%s, %s) can't open file\n",
		 name, appl?appl:"(NIL)" );

	return (struct bu_mapped_file *)NULL;
}

/*
 *			B U _ C L O S E _ M A P P E D _ F I L E
 *
 *  Release a use of a mapped file.
 *  Because it may be re-used shortly, e.g. by the next frame of
 *  an animation, don't release the memory even on final close,
 *  so that it's available when next needed.
 *  Call bu_free_mapped_files() after final close to reclaim space.
 *  But only do that if you're SURE that ALL these files will never again
 *  need to be mapped by this process.  Such as when running multi-frame
 *  animations.
 */
void
bu_close_mapped_file(struct bu_mapped_file *mp)
{
	BU_CK_MAPPED_FILE(mp);

	if( bu_debug&BU_DEBUG_MAPPED_FILE )
		bu_pr_mapped_file("close:uses--", mp);

	if (! mp) {
	    bu_log("bu_close_mapped_file() called with null pointer\n");
	    return;
	}

	bu_semaphore_acquire(BU_SEM_MAPPEDFILE);
	--mp->uses;
	bu_semaphore_release(BU_SEM_MAPPEDFILE);
}

/*
 *			B U _ P R _ M A P P E D _ F I L E
 */
void
bu_pr_mapped_file(const char *title, const struct bu_mapped_file *mp)
{
	BU_CK_MAPPED_FILE(mp);

	bu_log("%8lx mapped_file %s %lx len=%ld mapped=%d, uses=%d %s\n",
		(long)mp, mp->name, (long)mp->buf, mp->buflen,
		mp->is_mapped, mp->uses,
		title );
}

/*
 *			B U _ F R E E _ M A P P E D _ F I L E S
 *
 *  Release storage being used by mapped files with no remaining users.
 *  This entire routine runs inside a critical section, for parallel protection.
 *  Only call this routine if you're SURE that ALL these files will never
 *  again need to be mapped by this process.  Such as when running multi-frame
 *  animations.
 */
void
bu_free_mapped_files(int verbose)
{
	struct bu_mapped_file	*mp, *next;

	if( bu_debug&BU_DEBUG_MAPPED_FILE )
		bu_log("bu_free_mapped_files(verbose=%d)\n", verbose);

	bu_semaphore_acquire(BU_SEM_MAPPEDFILE);

	next = BU_LIST_FIRST( bu_mapped_file, &bu_mapped_file_list );
	while( BU_LIST_NOT_HEAD( next, &bu_mapped_file_list ) )  {
		BU_CK_MAPPED_FILE(next);
		mp = next;
		next = BU_LIST_NEXT( bu_mapped_file, &mp->l );

		if( mp->uses > 0 )  continue;

		/* Found one that needs to have storage released */
		if(verbose || (bu_debug&BU_DEBUG_MAPPED_FILE))
			bu_pr_mapped_file( "freeing", mp );

		BU_LIST_DEQUEUE( &mp->l );

		/* If application pointed mp->apbuf at mp->buf, break that
		 * association so we don't double-free the buffer.
		 */
		if( mp->apbuf == mp->buf )  mp->apbuf = (genptr_t)NULL;

#ifdef HAVE_SYS_MMAN_H
		if( mp->is_mapped )  {
			int	ret;
			bu_semaphore_acquire(BU_SEM_SYSCALL);
			ret = munmap( mp->buf, (size_t)mp->buflen );
			bu_semaphore_release(BU_SEM_SYSCALL);
			if( ret < 0 )  perror("munmap");
			/* XXX How to get this chunk of address space back to malloc()? */
		} else
#endif
		{
			bu_free( mp->buf, "bu_mapped_file.buf[]" );
		}
		mp->buf = (genptr_t)NULL;		/* sanity */
		bu_free( (genptr_t)mp->name, "bu_mapped_file.name" );
		if( mp->appl )  bu_free( (genptr_t)mp->appl, "bu_mapped_file.appl" );
		bu_free( (genptr_t)mp, "struct bu_mapped_file" );
	}
	bu_semaphore_release(BU_SEM_MAPPEDFILE);
}

/*
 *	B U _ O P E N _ M A P P E D _ F I L E _ W I T H _ P A T H
 *
 *  A wrapper for bu_open_mapped_file() which uses a search path
 *  to locate the file.
 *  The search path is specified as a normal C argv array,
 *  terminated by a null string pointer.
 *  If the file name begins with a slash ('/') the path is not used.
 */
struct bu_mapped_file *
bu_open_mapped_file_with_path(char *const *path, const char *name, const char *appl)
                   
          	      		/* file name */
          	      		/* non-null only when app. will use 'apbuf' */
{
	char	* const *pathp = path;
	struct bu_vls	str;
	struct bu_mapped_file	*ret;

	BU_ASSERT_PTR( name, !=, NULL );
	BU_ASSERT_PTR( pathp, !=, NULL );

	/* Do not resort to path for a rooted filename */
	if( name[0] == '/' )
		return bu_open_mapped_file( name, appl );

	bu_vls_init(&str);

	/* Try each path prefix in sequence */
	for( ; *pathp != NULL; pathp++ )  {
		bu_vls_strcpy( &str, *pathp );
		bu_vls_putc( &str, '/' );
		bu_vls_strcat( &str, name );

		ret = bu_open_mapped_file( bu_vls_addr(&str), appl );
		if( ret )  {
			bu_vls_free( &str );
			return ret;
		}
	}

	/* Failure, none of the opens succeeded */
	bu_vls_free( &str );
	return (struct bu_mapped_file *)NULL;
}
@


1.29
log
@change conf.h to a wrapped config.h
@
text
@d30 1
a30 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /cvs/brlcad/libbu/mappedfile.c,v 1.28 2004/04/05 07:46:16 morrison Exp $ (ARL)";
@


1.28
log
@merge of ansi-6-0-branch into HEAD
@
text
@d30 1
a30 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header$ (ARL)";
d33 5
a37 1
#include "conf.h"
@


1.27
log
@merge of windows-6-0-branch into head
@
text
@d80 3
a82 3
bu_open_mapped_file( name, appl )
const char	*name;		/* file name */
const char	*appl;		/* non-null only when app. will use 'apbuf' */
d190 1
a190 1
		(caddr_t)0, sb.st_size, PROT_READ, MAP_PRIVATE,
d203 1
a203 1
		mp->buf = bu_malloc( sb.st_size, mp->name );
d206 1
a206 1
		ret = read( fd, mp->buf, sb.st_size );
d315 1
a315 2
bu_close_mapped_file( mp )
struct bu_mapped_file	*mp;
d336 1
a336 3
bu_pr_mapped_file( title, mp )
const char			*title;
const struct bu_mapped_file	*mp;
d356 1
a356 2
bu_free_mapped_files(verbose)
int	verbose;
d388 1
a388 1
			ret = munmap( mp->buf, mp->buflen );
d415 4
a418 4
bu_open_mapped_file_with_path( path, name, appl )
char * const *path;
const char	*name;		/* file name */
const char	*appl;		/* non-null only when app. will use 'apbuf' */
@


1.26
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d30 1
a30 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/mappedfile.c,v 1.24 2001/11/19 19:34:26 butler Exp $ (ARL)";
d38 1
d40 1
@


1.26.10.1
log
@merge from head
@
text
@d30 1
a30 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header$ (ARL)";
a37 1
#ifdef HAVE_UNISTD_H
a38 1
#endif
@


1.26.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d30 1
a30 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/mappedfile.c,v 1.26 2002/08/20 17:07:41 jra Exp $ (ARL)";
a37 1
#ifdef HAVE_UNISTD_H
a38 1
#endif
@


1.26.2.1
log
@Initial ANSIfication
@
text
@d30 1
a30 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/mappedfile.c,v 1.26 2002/08/20 17:07:41 jra Exp $ (ARL)";
d78 3
a80 3
bu_open_mapped_file(const char *name, const char *appl)
          	      		/* file name */
          	      		/* non-null only when app. will use 'apbuf' */
d313 2
a314 1
bu_close_mapped_file(struct bu_mapped_file *mp)
d335 3
a337 1
bu_pr_mapped_file(const char *title, const struct bu_mapped_file *mp)
d357 2
a358 1
bu_free_mapped_files(int verbose)
d417 4
a420 4
bu_open_mapped_file_with_path(char *const *path, const char *name, const char *appl)
                   
          	      		/* file name */
          	      		/* non-null only when app. will use 'apbuf' */
@


1.26.2.2
log
@sync branch with HEAD
@
text
@d30 1
a30 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header$ (ARL)";
a37 1
#ifdef HAVE_UNISTD_H
a38 1
#endif
@


1.26.2.3
log
@more quelling of lots of warnings
@
text
@d30 1
a30 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libbu/mappedfile.c,v 1.26.2.2 2004/03/17 21:16:50 morrison Exp $ (ARL)";
d190 1
a190 1
		(caddr_t)0, (size_t)sb.st_size, PROT_READ, MAP_PRIVATE,
d203 1
a203 1
		mp->buf = bu_malloc( (size_t)sb.st_size, mp->name );
d206 1
a206 1
		ret = read( fd, mp->buf, (size_t)sb.st_size );
d388 1
a388 1
			ret = munmap( mp->buf, (size_t)mp->buflen );
@


1.25
log
@Converted from K&R to ANSI C - RFH
@
text
@d78 3
a80 3
bu_open_mapped_file(const char *name, const char *appl)
          	      		/* file name */
          	      		/* non-null only when app. will use 'apbuf' */
d313 2
a314 1
bu_close_mapped_file(struct bu_mapped_file *mp)
d335 3
a337 1
bu_pr_mapped_file(const char *title, const struct bu_mapped_file *mp)
d357 2
a358 1
bu_free_mapped_files(int verbose)
d417 4
a420 4
bu_open_mapped_file_with_path(char *const *path, const char *name, const char *appl)
                   
          	      		/* file name */
          	      		/* non-null only when app. will use 'apbuf' */
@


1.24
log
@bu_close_mapped_file() now complains if called with a null pointer
@
text
@d30 1
a30 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/mappedfile.c,v 1.23 2001/07/09 17:38:24 morrison Exp $ (ARL)";
d78 3
a80 3
bu_open_mapped_file( name, appl )
const char	*name;		/* file name */
const char	*appl;		/* non-null only when app. will use 'apbuf' */
d313 1
a313 2
bu_close_mapped_file( mp )
struct bu_mapped_file	*mp;
d334 1
a334 3
bu_pr_mapped_file( title, mp )
const char			*title;
const struct bu_mapped_file	*mp;
d354 1
a354 2
bu_free_mapped_files(verbose)
int	verbose;
d413 4
a416 4
bu_open_mapped_file_with_path( path, name, appl )
char * const *path;
const char	*name;		/* file name */
const char	*appl;		/* non-null only when app. will use 'apbuf' */
@


1.23
log
@Fixed a minor typo in conf.h with HAVE_SBRK define.  Should have been a HAVE_SBRK_DECL define.
Most references checked whether HAVE_SBRK_DECL is defined (which didn't exist), and it is a declaration check anyways.
@
text
@d30 1
a30 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/mappedfile.c,v 1.22 2001/04/20 22:29:07 morrison Exp $ (ARL)";
d320 5
@


1.22
log
@CONST to const
@
text
@d30 1
a30 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/mappedfile.c,v 1.21 2001/03/19 22:19:45 butler Exp $ (ARL)";
d95 1
a95 1
#ifdef HAVE_SBRK
d276 1
a276 1
#ifdef HAVE_SBRK
@


1.21
log
@patches to merge 5.3 into 6.0
@
text
@d30 1
a30 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /d/CVS/brlcad/libbu/mappedfile.c,v 1.20 2001/01/24 15:56:29 jra Exp $ (ARL)";
d79 2
a80 2
CONST char	*name;		/* file name */
CONST char	*appl;		/* non-null only when app. will use 'apbuf' */
d331 2
a332 2
CONST char			*title;
CONST struct bu_mapped_file	*mp;
d413 3
a415 3
char * CONST *path;
CONST char	*name;		/* file name */
CONST char	*appl;		/* non-null only when app. will use 'apbuf' */
d417 1
a417 1
	char	* CONST *pathp = path;
@


1.20
log
@bu_free_mapped_files() was not working (loop was incorrect and it was
freeing stuff it shouldn't)
@
text
@d30 1
a30 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/mappedfile.c,v 1.19 2000/08/30 23:22:36 mike Exp $ (ARL)";
d155 2
a156 1
		perror(name);
d292 5
a296 2
	bu_log("bu_open_mapped_file(%s, %s) can't open file\n",
		name, appl?appl:"(NIL)" );
@


1.19
log
@
Conditional on HAVE_SBRK
@
text
@d30 1
a30 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/mappedfile.c,v 1.18 2000/08/30 23:09:22 mike Exp $ (ARL)";
d351 1
a351 1
	struct bu_mapped_file	*mp;
d358 5
a362 2
	for( BU_LIST_FOR( mp, bu_mapped_file, &bu_mapped_file_list ) )  {
		BU_CK_MAPPED_FILE(mp);
a390 4
		if( mp->apbuf )  {
			bu_free( mp->apbuf, "bu_mapped_file.apbuf[]" );
			mp->apbuf = (genptr_t)NULL;	/* sanity */
		}
@


1.18
log
@
More logging.
@
text
@d30 1
a30 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/mappedfile.c,v 1.17 2000/08/30 23:03:05 mike Exp $ (ARL)";
d94 7
a100 1
			name, appl?appl:"(NIL)", (long)sbrk(0) );
d274 7
a280 1
		bu_log("bu_open_mapped_file() sbrk=x%lx\n", (long)sbrk(0) );
@


1.17
log
@
Added debug bit for bu_open_mapped_file()
@
text
@d30 1
a30 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/mappedfile.c,v 1.16 2000/08/16 21:03:44 mike Exp $ (ARL)";
d302 3
d341 3
d352 2
a353 1
		if(verbose)  bu_pr_mapped_file( "freeing", mp );
@


1.16
log
@
Verify non-null pointers.
@
text
@d30 1
a30 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/mappedfile.c,v 1.15 2000/07/07 05:20:12 cjohnson Exp $ (ARL)";
d92 3
a94 4
#ifdef HAVE_UNIX_IO
	/* Obtain some initial information about the file */

#endif
d96 1
d130 2
d266 4
d279 2
a280 1
	bu_log("bu_open_mapped_file(%s) can't open file\n", name);
d292 3
d328 3
@


1.15
log
@LINT
@
text
@d30 1
a30 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/mappedfile.c,v 1.14 2000/07/07 00:37:35 cjohnson Exp $ (ARL)";
d385 3
@


1.14
log
@LINT
@
text
@d30 1
a30 1
static char libbu_mappedfile_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/mappedfile.c,v 1.13 2000/03/28 18:55:08 mike Exp $ (ARL)";
@


1.13
log
@
Put libbu_filename_ prefixes on RCSid variables.
@
text
@d30 1
a30 1
static char libbu_mappedfile_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/mappedfile.c,v 1.12 2000/03/03 01:01:17 mike Exp $ (ARL)";
d38 1
@


1.13.2.1
log
@Use BU_DEBUG_DB to decide whether to
complain about non existent file.
@
text
@d30 1
a30 1
static char libbu_mappedfile_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/mappedfile.c,v 1.13 2000/03/28 18:55:08 mike Exp $ (ARL)";
d146 1
a146 2
		if (bu_debug&BU_DEBUG_DB)
			perror(name);
d272 1
a272 2
	if (bu_debug&BU_DEBUG_DB)
		bu_log("bu_open_mapped_file(%s) can't open file\n", name);
@


1.13.2.2
log
@bu_free_mapped_files() was not working (loop was incorrect and it was freeing stuff it shouldn't)
@
text
@d30 1
a30 1
static char libbu_mappedfile_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/mappedfile.c,v 1.13.2.1 2000/11/03 19:20:36 bparker Exp $ (ARL)";
d324 1
a324 1
	struct bu_mapped_file	*mp, *next;
d328 2
a329 5
	next = BU_LIST_FIRST( bu_mapped_file, &bu_mapped_file_list );
	while( BU_LIST_NOT_HEAD( next, &bu_mapped_file_list ) )  {
		BU_CK_MAPPED_FILE(next);
		mp = next;
		next = BU_LIST_NEXT( bu_mapped_file, &mp->l );
d357 4
@


1.12
log
@
Removed a CONST from path arg to bu_open_mapped_file_with_path()
to please GCC compilers.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/mappedfile.c,v 1.11 2000/03/02 02:44:02 mike Exp $ (ARL)";
@


1.11
log
@
Added bu_open_mapped_file_with_path()
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/mappedfile.c,v 1.10 2000/02/02 20:10:40 mike Exp $ (ARL)";
d53 3
d377 1
a377 1
CONST char * CONST path[];
d381 1
a381 1
	CONST char	* CONST *pathp = path;
d392 1
a392 1
	for( pathp = path; *pathp != NULL; pathp++ )  {
@


1.10
log
@
Gave it an explicit semaphore BU_SEM_MAPPEDFILE
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/mappedfile.c,v 1.9 2000/01/13 01:17:19 mike Exp $ (ARL)";
a50 1
#undef HAVE_SYS_MMAN_H
d179 2
a180 1
	if( mp->buf != (caddr_t)-1L )  {
d298 2
a299 2
CONST char		*title;
struct bu_mapped_file	*mp;
d340 1
d361 43
@


1.9
log
@
Added flag dont_stat, for submodel support.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/mappedfile.c,v 1.8 2000/01/11 18:55:45 mike Exp $ (ARL)";
a63 2
#define FILE_LIST_SEMAPHORE_NUM	BU_SEM_BN_NOISE	/* Anything but BU_SEM_SYSCALL */

d94 1
a94 1
	bu_semaphore_acquire(FILE_LIST_SEMAPHORE_NUM);
d126 1
a126 1
		bu_semaphore_release(FILE_LIST_SEMAPHORE_NUM);
d134 1
a134 1
	bu_semaphore_release(FILE_LIST_SEMAPHORE_NUM);
d256 1
a256 1
	bu_semaphore_acquire(FILE_LIST_SEMAPHORE_NUM);
d258 1
a258 1
	bu_semaphore_release(FILE_LIST_SEMAPHORE_NUM);
d288 1
a288 1
	bu_semaphore_acquire(FILE_LIST_SEMAPHORE_NUM);
d290 1
a290 1
	bu_semaphore_release(FILE_LIST_SEMAPHORE_NUM);
d321 1
a321 1
	bu_semaphore_acquire(FILE_LIST_SEMAPHORE_NUM);
d359 1
a359 1
	bu_semaphore_release(FILE_LIST_SEMAPHORE_NUM);
@


1.8
log
@
Init pointer.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/mappedfile.c,v 1.7 1999/12/29 20:12:42 jra Exp $ (ARL)";
a92 8
	bu_semaphore_acquire(BU_SEM_SYSCALL);
	ret = stat( name, &sb );
	bu_semaphore_release(BU_SEM_SYSCALL);

	if( ret < 0 )  {
		perror(name);
		goto fail;
	}
a93 4
	if( sb.st_size == 0 )  {
		bu_log("bu_open_mapped_file(%s) 0-length file\n", name);
		goto fail;
	}
d107 16
a122 9
		if( sb.st_size != mp->buflen )  {
			bu_log("bu_open_mapped_file(%s) WARNING: File size changed from %ld to %ld, opening new version.\n",
				name, mp->buflen, sb.st_size );
			goto dont_reuse;
		}
		if( sb.st_mtime != mp->modtime )  {
			bu_log("bu_open_mapped_file(%s) WARNING: File modified since last mapped, opening new version.\n",
				name);
			goto dont_reuse;
a123 1
		/* To be completely safe, should check st_dev and st_inum */
d125 1
d147 14
@


1.7
log
@Eliminated an unused variable
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/mappedfile.c,v 1.6 1999/12/22 03:35:45 mike Exp $ (ARL)";
d81 1
a81 1
	struct bu_mapped_file	*mp;
@


1.6
log
@
Added code to check for file changing between mapins.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/mappedfile.c,v 1.5 1999/07/02 19:08:28 mike Exp $ (ARL)";
a312 1
	int	ret;
@


1.5
log
@
Eliminated dependency on compat4.h
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/mappedfile.c,v 1.4 1998/01/07 03:34:16 mike Exp $ (ARL)";
d71 4
d91 17
d117 15
a131 1
		/* File is already mapped */
d135 5
a146 13
	ret = stat( name, &sb );
	bu_semaphore_release(BU_SEM_SYSCALL);

	if( ret < 0 )  {
		perror(name);
		goto fail;
	}
	if( sb.st_size == 0 )  {
		bu_log("bu_open_mapped_file(%s) 0-length file\n", name);
		goto fail;
	}

	bu_semaphore_acquire(BU_SEM_SYSCALL);
d163 1
@


1.4
log
@Modified to allow re-use of mapped files from frame-to-frame
in an animation.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbu/RCS/mappedfile.c,v 1.3 1997/12/04 12:14:43 mike Exp mike $ (ARL)";
d130 1
a130 1
	GETSTRUCT( mp, bu_mapped_file );
@


1.3
log
@Don't dump core when you can't open a file.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbu/RCS/mappedfile.c,v 1.2 1997/11/22 02:58:24 mike Exp mike $ (ARL)";
d64 1
a64 1
#define FILE_LIST_SEMAPHORE_NUM	1	/* Anything but BU_SEM_SYSCALL */
d237 1
d240 6
d251 6
a256 1
	int	ret;
d258 8
d268 19
a287 6
	if( --mp->uses > 0 )  {
		bu_semaphore_release(FILE_LIST_SEMAPHORE_NUM);
		return;
	}
	BU_LIST_DEQUEUE( &mp->l );
	bu_semaphore_release(FILE_LIST_SEMAPHORE_NUM);
d289 14
a302 4
	/* If application pointed mp->apbuf at mp->buf, break that
	 * association so we don't double-free the buffer.
	 */
	if( mp->apbuf == mp->buf )  mp->apbuf = (genptr_t)NULL;
d305 7
a311 7
	if( mp->is_mapped )  {
		bu_semaphore_acquire(BU_SEM_SYSCALL);
		ret = munmap( mp->buf, mp->buflen );
		bu_semaphore_release(BU_SEM_SYSCALL);
		if( ret < 0 )  perror("munmap");
		/* XXX How to get this chunk of address space back to malloc()? */
	} else
d313 11
a323 2
	{
		bu_free( mp->buf, "bu_mapped_file.buf[]" );
d325 1
a325 8
	mp->buf = (genptr_t)NULL;		/* sanity */
	if( mp->apbuf )  {
		bu_free( mp->apbuf, "bu_close_mapped_file() apbuf[]" );
		mp->apbuf = (genptr_t)NULL;	/* sanity */
	}
	bu_free( (genptr_t)mp->name, "bu_mapped_file.name" );
	if( mp->appl )  bu_free( (genptr_t)mp->appl, "bu_mapped_file.appl" );
	bu_free( (genptr_t)mp, "struct bu_mapped_file" );
@


1.2
log
@Initialized global variables to zero, for safety sake.  (Irix 6.4 paranoia)
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbu/RCS/mappedfile.c,v 1.1 1996/08/31 06:55:33 mike Exp $ (ARL)";
d102 1
d183 1
a183 1
		char	buf[10240];
d228 6
a233 1
	if( mp )  bu_free( mp, "bu_open_mapped_file failed");
@


1.1
log
@Initial revision
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/file.c,v 11.1 95/01/04 09:56:24 mike Rel4_4 $ (ARL)";
d58 5
a62 1
static struct rt_list	bu_mapped_file_list;	/* list of currently open mapped files */
d88 2
a89 2
	if( RT_LIST_UNINITIALIZED( &bu_mapped_file_list ) )  {
		RT_LIST_INIT( &bu_mapped_file_list );
d91 1
a91 1
	for( RT_LIST_FOR( mp, bu_mapped_file, &bu_mapped_file_list ) )  {
d221 1
a221 1
	RT_LIST_APPEND( &bu_mapped_file_list, &mp->l );
d247 1
a247 1
	RT_LIST_DEQUEUE( &mp->l );
@
