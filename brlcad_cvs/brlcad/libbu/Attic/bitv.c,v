head	1.17;
access;
symbols
	ansi-20040405-merged:1.14.2.2
	postmerge-20040405-ansi:1.15
	premerge-20040404-ansi:1.14
	postmerge-autoconf:1.14
	autoconf-freeze:1.14
	premerge-autoconf:1.14
	ansi-20040316-freeze:1.14.2.1
	postmerge-20040315-windows:1.14
	premerge-20040315-windows:1.14
	windows-20040315-freeze:1.14
	autoconf-20031203:1.14
	autoconf-20031202:1.14
	autoconf-branch:1.14.0.10
	phong-branch:1.14.0.8
	photonmap-branch:1.14.0.6
	rel-6-1-DP:1.14
	windows-branch:1.14.0.4
	rel-6-0-2:1.11.2.1
	ansi-branch:1.14.0.2
	rel-6-0-1-branch:1.11.0.2
	hartley-6-0-post:1.12
	hartley-6-0-pre:1.11
	rel-6-0-1:1.11
	rel-6-0:1.11
	rel-5-4:1.8
	offsite-5-3-pre:1.10
	rel-5-3:1.8
	rel-5-2:1.8
	rel-5-1-branch:1.8.0.2
	rel-5-1:1.8
	rel-5-0:1.1
	rel-5-0-beta:1.1
	rel-4-5:1.1
	ctj-4-5-post:1.1
	ctj-4-5-pre:1.1;
locks; strict;
comment	@ * @;


1.17
date	2004.05.21.18.06.23;	author morrison;	state dead;
branches;
next	1.16;

1.16
date	2004.05.10.15.30.44;	author erikg;	state Exp;
branches;
next	1.15;

1.15
date	2004.04.05.07.46.16;	author morrison;	state Exp;
branches;
next	1.14;

1.14
date	2002.09.09.01.12.03;	author jra;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2002.08.20.17.07.39;	author jra;	state Exp;
branches;
next	1.12;

1.12
date	2002.08.15.20.54.50;	author hartley;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.20.22.29.05;	author morrison;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2000.07.07.05.21.20;	author cjohnson;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.05.22.10.20;	author cjohnson;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.12.01.07.02;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.12.01.02.41;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.28.19.31.25;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.28.18.55.06;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.28.18.04.43;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	99.11.08.14.58.52;	author jra;	state Exp;
branches;
next	1.2;

1.2
date	99.11.02.20.32.33;	author jra;	state Exp;
branches;
next	1.1;

1.1
date	96.08.28.04.24.09;	author mike;	state Exp;
branches;
next	;

1.11.2.1
date	2002.09.13.20.46.04;	author jra;	state Exp;
branches;
next	;

1.14.2.1
date	2002.09.19.18.01.11;	author morrison;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2004.04.05.00.50.06;	author morrison;	state Exp;
branches;
next	;


desc
@bitv.c
@


1.17
log
@moved to src/
@
text
@/*
 *			B I T V . C
 *
 *  Routines for managing bit vectors of arbitrary length.
 *
 *  The basic type "bitv_t" is defined in h/machine.h; it is the
 *  widest integer datatype for which efficient hardware support exists.
 *  BITV_SHIFT and BITV_MASK are also defined in machine.h
 *
 *  These bit vectors are "little endian", bit 0 is in the right hand
 *  side of the [0] word.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
 */
#ifndef lint
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libbu/bitv.c,v 1.16 2004/05/10 15:30:44 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>		/* for bzero() */
#else
#include <strings.h>
#endif
#include <ctype.h>
#include "machine.h"
#include "externs.h"
#include "bu.h"

/*
 *			B U _ B I T V _ N E W
 *
 *  Allocate storage for a new bit vector of at least 'nbits' in length.
 *  For efficiency, the bit vector itself is not initialized.
 */
struct bu_bitv *
bu_bitv_new(unsigned int nbits)
{
	struct bu_bitv	*bv;
	int		bv_bytes;
	int		total_bytes;

	bv_bytes = BU_BITS2BYTES(nbits);
	total_bytes = sizeof(struct bu_bitv) - 2*sizeof(bitv_t) + bv_bytes;

	bv = (struct bu_bitv *)bu_malloc( (size_t)total_bytes, "struct bu_bitv" );
	BU_LIST_INIT( &bv->l );
	bv->l.magic = BU_BITV_MAGIC;
	bv->nbits = bv_bytes * 8;
	return bv;
}

/*
 *			B U _ B I T V _ F R E E
 *
 *  Release all internal storage for this bit vector.
 *  It is the caller's responsibility to not use the pointer 'bv' any longer.
 *  It is the caller's responsibility to dequeue from any linked list first.
 */
void
bu_bitv_free(struct bu_bitv *bv)
{
	BU_CK_BITV(bv);

	bv->l.forw = bv->l.back = BU_LIST_NULL;	/* sanity */
	bu_free( (char *)bv, "struct bu_bitv" );
}

/*
 *			B U _ B I T V _ C L E A R
 *
 *  Set all the bits in the bit vector to zero.
 *
 *  Also available as a macro if you don't desire the pointer checking.
 */
void
bu_bitv_clear(struct bu_bitv *bv)
{
	BU_CK_BITV(bv);

	BU_BITV_ZEROALL(bv);
}

/*
 *			B U _ B I T V _ O R
 */
void
bu_bitv_or(struct bu_bitv *ov, const struct bu_bitv *iv)
{
	register bitv_t		*out;
	register const bitv_t	*in;
	register int		words;

	if( ov->nbits != iv->nbits )  bu_bomb("bu_bitv_or: length mis-match");
	out = ov->bits;
	in = iv->bits;
	words = BU_BITS2WORDS(iv->nbits);
#ifdef VECTORIZE
#	include "noalias.h"
	for( --words; words >= 0; words-- )
		out[words] |= in[words];
#else
	while( words-- > 0 )
		*out++ |= *in++;
#endif
}

/*
 *			B U _ B I T V _ A N D
 */
void
bu_bitv_and(struct bu_bitv *ov, const struct bu_bitv *iv)
{
	register bitv_t		*out;
	register const bitv_t	*in;
	register int		words;

	if( ov->nbits != iv->nbits )  bu_bomb("bu_bitv_and: length mis-match");
	out = ov->bits;
	in = iv->bits;
	words = BU_BITS2WORDS(iv->nbits);
#ifdef VECTORIZE
#	include "noalias.h"
	for( --words; words >= 0; words-- )
		out[words] &= in[words];
#else
	while( words-- > 0 )
		*out++ &= *in++;
#endif
}

/*
 *			B U _ B I T V _ V L S
 *
 *  Print the bits set in a bit vector.
 */
void
bu_bitv_vls(struct bu_vls *v, register const struct bu_bitv *bv)
{
	int		seen = 0;
	register int	i;
	int		len;

	BU_CK_VLS( v );
	BU_CK_BITV( bv );

	len = bv->nbits;

	bu_vls_strcat( v, "(" );

	/* Visit all the bits in ascending order */
	for( i=0; i<len; i++ )  {
		if( BU_BITTEST(bv, i) == 0 )  continue;
		if( seen )  bu_vls_strcat( v, ", " );
		bu_vls_printf( v, "%d", i );
		seen = 1;
	}
	bu_vls_strcat( v, ") " );
}

/*
 *			B U _ P R _ B I T V
 *
 *  Print the bits set in a bit vector.
 *  Use bu_vls stuff, to make only a single call to bu_log().
 */
void
bu_pr_bitv(const char *str, register const struct bu_bitv *bv)
{
	struct bu_vls	v;

	BU_CK_BITV(bv)
	bu_vls_init( &v );
	bu_vls_strcat( &v, str );
	bu_vls_strcat( &v, ": " );
	bu_bitv_vls( &v, bv );
	bu_log("%s", bu_vls_addr( &v ) );
	bu_vls_free( &v );
}

/*
 *			B U _ B I T V _ T O _ H E X
 *
 *	Convert a bit vector to an ascii string of hex digits.
 *	The string is from MSB to LSB (bytes and bits).
 */
void
bu_bitv_to_hex(struct bu_vls *v, register const struct bu_bitv *bv)
{
	unsigned int word_count, byte_no;

	BU_CK_VLS( v );
	BU_CK_BITV( bv );

	word_count = bv->nbits/8/sizeof( bitv_t );
	byte_no = sizeof( bitv_t );

	bu_vls_extend( v, word_count * sizeof( bitv_t ) * 2 + 1 );
	while( word_count-- )
	{
		while( byte_no-- )
		{
			bu_vls_printf( v, "%02x",
				       ((bv->bits[word_count] & (((bitv_t)0xff)<<(byte_no*8))) >> (byte_no*8)) & (bitv_t)0xff );
		}
		byte_no = sizeof( bitv_t );
	}
}

/*
 *			B U _ H E X _ T O _ B I T V
 *
 *	Convert a string of HEX digits (as produces by bu_bitv_to_hex) into a bit vector.
 */
struct bu_bitv *
bu_hex_to_bitv(const char *str)
{
	char abyte[3];
	const char *str_start;
	unsigned int len=0;
	int bytes;
	struct bu_bitv *bv;
	unsigned long c;
	int word_count, byte_no;

	abyte[2] = '\0';

	/* skip over any initial white space */
	while( isspace( *str ) )
		str++;

	str_start = str;
	/* count hex digits */
	while( isxdigit( *str ) )
		str++;

	len = str - str_start;

	if( len < 2 || len%2 )
	{
		/* Must be two digits per byte */
		bu_log( "bu_hex_to_bitv: illegal hex bitv (%s)\n", str_start );
		return( (struct bu_bitv *)NULL );
	}

	bytes = len / 2; /* two hex digits per byte */
	bv = bu_bitv_new( len * 4 ); /* 4 bits per hex digit */
	bu_bitv_clear( bv );
	word_count = bytes/sizeof( bitv_t );
	byte_no = bytes % sizeof( bitv_t );
	if( !byte_no )
		byte_no = sizeof( bitv_t );
	else
		word_count++;

	str = str_start;
	while( word_count-- )
	{
		while( byte_no-- )
		{
			/* get next two hex digits from string */
			abyte[0] = *str++;
			abyte[1] = *str++;

			/* convert into an unsigned long */
			c = strtoul( abyte, (char **)NULL, 16 );

			/* set the appropriate bits in the bit vector */
			bv->bits[word_count] |= (bitv_t)c<<(byte_no*8);
		}
		byte_no = sizeof( bitv_t );
	}

	return( bv );
}

/*
 *			B U _ B I T V _ D U P
 *
 *	Make a copy of a bit vector
 */
struct bu_bitv *
bu_bitv_dup(register const struct bu_bitv *bv)
{
	struct bu_bitv *bv2;

	bv2 = bu_bitv_new( bv->nbits );
	bu_bitv_clear( bv2 );
	bu_bitv_or( bv2, bv );

	return( bv2 );
}
@


1.16
log
@change conf.h to a wrapped config.h
@
text
@d24 1
a24 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /cvs/brlcad/libbu/bitv.c,v 1.15 2004/04/05 07:46:16 morrison Exp $ (ARL)";
@


1.15
log
@merge of ansi-6-0-branch into HEAD
@
text
@d24 1
a24 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header$ (ARL)";
d27 5
a31 1
#include "conf.h"
@


1.14
log
@bu_bitv_to_hex() was right shifting (expecting zero fill, but getting sign extension)
added a mask to unset unwanted bits.
@
text
@d24 1
a24 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bitv.c,v 1.13 2002/08/20 17:07:39 jra Exp $ (ARL)";
d46 1
a46 2
bu_bitv_new(nbits)
int	nbits;
d55 1
a55 1
	bv = (struct bu_bitv *)bu_malloc( total_bytes, "struct bu_bitv" );
d70 1
a70 2
bu_bitv_free(bv)
struct bu_bitv *bv;
d86 1
a86 2
bu_bitv_clear(bv)
struct bu_bitv	*bv;
d97 1
a97 3
bu_bitv_or( ov, iv )
struct bu_bitv		*ov;
const struct bu_bitv	*iv;
d121 1
a121 3
bu_bitv_and( ov, iv )
struct bu_bitv		*ov;
const struct bu_bitv	*iv;
d147 1
a147 3
bu_bitv_vls( v, bv )
struct bu_vls			*v;
register const struct bu_bitv	*bv;
d177 1
a177 3
bu_pr_bitv( str, bv )
const char			*str;
register const struct bu_bitv	*bv;
d197 1
a197 3
bu_bitv_to_hex( v, bv )
struct bu_vls *v;
register const struct bu_bitv	*bv;
d199 1
a199 1
	int word_count, byte_no;
d225 1
a225 2
bu_hex_to_bitv( str )
const char *str;
d229 1
a229 1
	int len=0;
d292 1
a292 2
bu_bitv_dup( bv )
register const struct bu_bitv	*bv;
@


1.14.2.1
log
@Initial ANSIfication
@
text
@d24 1
a24 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bitv.c,v 1.14 2002/09/09 01:12:03 jra Exp $ (ARL)";
d46 2
a47 1
bu_bitv_new(int nbits)
d71 2
a72 1
bu_bitv_free(struct bu_bitv *bv)
d88 2
a89 1
bu_bitv_clear(struct bu_bitv *bv)
d100 3
a102 1
bu_bitv_or(struct bu_bitv *ov, const struct bu_bitv *iv)
d126 3
a128 1
bu_bitv_and(struct bu_bitv *ov, const struct bu_bitv *iv)
d154 3
a156 1
bu_bitv_vls(struct bu_vls *v, register const struct bu_bitv *bv)
d186 3
a188 1
bu_pr_bitv(const char *str, register const struct bu_bitv *bv)
d208 3
a210 1
bu_bitv_to_hex(struct bu_vls *v, register const struct bu_bitv *bv)
d238 2
a239 1
bu_hex_to_bitv(const char *str)
d306 2
a307 1
bu_bitv_dup(register const struct bu_bitv *bv)
@


1.14.2.2
log
@more quelling of lots of warnings
@
text
@d24 1
a24 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libbu/bitv.c,v 1.14.2.1 2002/09/19 18:01:11 morrison Exp $ (ARL)";
d46 1
a46 1
bu_bitv_new(unsigned int nbits)
d55 1
a55 1
	bv = (struct bu_bitv *)bu_malloc( (size_t)total_bytes, "struct bu_bitv" );
d199 1
a199 1
	unsigned int word_count, byte_no;
d229 1
a229 1
	unsigned int len=0;
@


1.13
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d24 1
a24 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bitv.c,v 1.11 2001/04/20 22:29:05 morrison Exp $ (ARL)";
d226 1
a226 1
				(bv->bits[word_count] & (((bitv_t)0xff)<<(byte_no*8))) >> (byte_no*8) );
@


1.12
log
@Converted from K&R to ANSI C - RFH
@
text
@d46 2
a47 1
bu_bitv_new(int nbits)
d71 2
a72 1
bu_bitv_free(struct bu_bitv *bv)
d88 2
a89 1
bu_bitv_clear(struct bu_bitv *bv)
d100 3
a102 1
bu_bitv_or(struct bu_bitv *ov, const struct bu_bitv *iv)
d126 3
a128 1
bu_bitv_and(struct bu_bitv *ov, const struct bu_bitv *iv)
d154 3
a156 1
bu_bitv_vls(struct bu_vls *v, register const struct bu_bitv *bv)
d186 3
a188 1
bu_pr_bitv(const char *str, register const struct bu_bitv *bv)
d208 3
a210 1
bu_bitv_to_hex(struct bu_vls *v, register const struct bu_bitv *bv)
d238 2
a239 1
bu_hex_to_bitv(const char *str)
d306 2
a307 1
bu_bitv_dup(register const struct bu_bitv *bv)
@


1.11
log
@CONST to const
@
text
@d24 1
a24 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bitv.c,v 1.10 2000/07/07 05:21:20 cjohnson Exp $ (ARL)";
d46 1
a46 2
bu_bitv_new(nbits)
int	nbits;
d70 1
a70 2
bu_bitv_free(bv)
struct bu_bitv *bv;
d86 1
a86 2
bu_bitv_clear(bv)
struct bu_bitv	*bv;
d97 1
a97 3
bu_bitv_or( ov, iv )
struct bu_bitv		*ov;
const struct bu_bitv	*iv;
d121 1
a121 3
bu_bitv_and( ov, iv )
struct bu_bitv		*ov;
const struct bu_bitv	*iv;
d147 1
a147 3
bu_bitv_vls( v, bv )
struct bu_vls			*v;
register const struct bu_bitv	*bv;
d177 1
a177 3
bu_pr_bitv( str, bv )
const char			*str;
register const struct bu_bitv	*bv;
d197 1
a197 3
bu_bitv_to_hex( v, bv )
struct bu_vls *v;
register const struct bu_bitv	*bv;
d225 1
a225 2
bu_hex_to_bitv( str )
const char *str;
d292 1
a292 2
bu_bitv_dup( bv )
register const struct bu_bitv	*bv;
@


1.11.2.1
log
@bu_bitv_to_hex() was right shifting (expecting zero fill, but getting sign extension)
added a mask to unset unwanted bits.
@
text
@d24 1
a24 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bitv.c,v 1.11 2001/04/20 22:29:05 morrison Exp $ (ARL)";
d226 1
a226 1
			       ((bv->bits[word_count] & (((bitv_t)0xff)<<(byte_no*8))) >> (byte_no*8) ) &(bitv_t)0xff );
@


1.10
log
@LINT plus minor bug fix in bu_tcl.c
@
text
@d24 1
a24 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bitv.c,v 1.9 2000/07/05 22:10:20 cjohnson Exp $ (ARL)";
d102 1
a102 1
CONST struct bu_bitv	*iv;
d105 1
a105 1
	register CONST bitv_t	*in;
d128 1
a128 1
CONST struct bu_bitv	*iv;
d131 1
a131 1
	register CONST bitv_t	*in;
d156 1
a156 1
register CONST struct bu_bitv	*bv;
d187 2
a188 2
CONST char			*str;
register CONST struct bu_bitv	*bv;
d210 1
a210 1
register CONST struct bu_bitv	*bv;
d239 1
a239 1
CONST char *str;
d242 1
a242 1
	CONST char *str_start;
d307 1
a307 1
register CONST struct bu_bitv	*bv;
@


1.9
log
@LINT
@
text
@d24 1
a24 1
static char libbu_bitv_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bitv.c,v 1.8 2000/05/12 01:07:02 mike Exp $ (ARL)";
@


1.8
log
@
Oops, typo
@
text
@d24 1
a24 1
static char libbu_bitv_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bitv.c,v 1.7 2000/05/12 01:02:41 mike Exp $ (ARL)";
d34 1
@


1.7
log
@
Added bu_bitv_free().
@
text
@d24 1
a24 1
static char libbu_bitv_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bitv.c,v 1.6 2000/03/28 19:31:25 mike Exp $ (ARL)";
d75 1
a75 1
	bv->l.forw = bv->.l.back = BU_LIST_NULL;	/* sanity */
@


1.6
log
@
Missing #include string.h, for bzero() declaration.
@
text
@d24 1
a24 1
static char libbu_bitv_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bitv.c,v 1.5 2000/03/28 18:55:06 mike Exp $ (ARL)";
d63 17
d83 2
d92 1
a92 1
	bzero( (char *)bv->bits, bv->nbits / 8 );	/* 8 bits/byte */
@


1.5
log
@
Put libbu_filename_ prefixes on RCSid variables.
@
text
@d24 1
a24 1
static char libbu_bitv_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bitv.c,v 1.4 2000/03/28 18:04:43 mike Exp $ (ARL)";
d29 5
@


1.4
log
@
Changed from RT_LIST to BU_LIST
A few dregs
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bitv.c,v 1.3 1999/11/08 14:58:52 jra Exp $ (ARL)";
@


1.3
log
@
Added bu_bitv_dup().
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bitv.c,v 1.1 1996/08/28 04:24:09 mike Exp $ (ARL)";
d51 1
a51 1
	RT_LIST_INIT( &bv->l );
@


1.2
log
@Added routines to convert bit vectors to/from hex
@
text
@d274 18
@


1.1
log
@Initial revision
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d174 99
@

