head	11.18;
access;
symbols
	ansi-20040405-merged:11.14.2.2
	postmerge-20040405-ansi:11.16
	premerge-20040404-ansi:11.15
	postmerge-autoconf:11.15
	autoconf-freeze:11.14.10.2
	premerge-autoconf:11.15
	ansi-20040316-freeze:11.14.2.1
	postmerge-20040315-windows:11.15
	premerge-20040315-windows:11.15
	windows-20040315-freeze:11.14.4.1
	autoconf-20031203:11.14
	autoconf-20031202:11.14
	autoconf-branch:11.14.0.10
	phong-branch:11.14.0.8
	photonmap-branch:11.14.0.6
	rel-6-1-DP:11.14
	windows-branch:11.14.0.4
	rel-6-0-2:11.12
	ansi-branch:11.14.0.2
	rel-6-0-1-branch:11.12.0.2
	hartley-6-0-post:11.13
	hartley-6-0-pre:11.12
	rel-6-0-1:11.12
	rel-6-0:11.12
	rel-5-4:11.11
	offsite-5-3-pre:11.12
	rel-5-3:11.11
	rel-5-2:11.11
	rel-5-1-branch:11.11.0.2
	rel-5-1:11.11
	rel-5-0:11.9
	rel-5-0-beta:11.9
	rel-4-5:11.7
	ctj-4-5-post:11.7
	ctj-4-5-pre:11.7
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.18
date	2004.05.21.18.06.24;	author morrison;	state dead;
branches;
next	11.17;

11.17
date	2004.05.10.15.30.44;	author erikg;	state Exp;
branches;
next	11.16;

11.16
date	2004.04.05.07.46.16;	author morrison;	state Exp;
branches;
next	11.15;

11.15
date	2004.02.02.17.39.07;	author morrison;	state Exp;
branches;
next	11.14;

11.14
date	2002.08.20.17.07.41;	author jra;	state Exp;
branches
	11.14.2.1
	11.14.4.1
	11.14.10.1;
next	11.13;

11.13
date	2002.08.15.20.54.54;	author hartley;	state Exp;
branches;
next	11.12;

11.12
date	2000.07.07.05.20.13;	author cjohnson;	state Exp;
branches;
next	11.11;

11.11
date	2000.03.28.18.55.09;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	2000.03.28.18.04.43;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	99.01.12.16.19.55;	author pjt;	state Exp;
branches;
next	11.8;

11.8
date	98.12.30.01.25.42;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	96.08.31.09.33.46;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	95.09.20.12.34.44;	author pjt;	state Exp;
branches;
next	11.5;

11.5
date	95.09.20.12.09.35;	author pjt;	state Exp;
branches;
next	11.4;

11.4
date	95.07.10.20.17.22;	author pjt;	state Exp;
branches;
next	11.3;

11.3
date	95.07.07.15.29.00;	author pjt;	state Exp;
branches;
next	11.2;

11.2
date	95.04.19.19.04.11;	author pjt;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.05.52;	author mike;	state Rel4_4;
branches;
next	2.5;

2.5
date	94.12.30.16.41.04;	author stay;	state Exp;
branches;
next	2.4;

2.4
date	94.09.26.12.21.10;	author jra;	state Exp;
branches;
next	2.3;

2.3
date	94.09.22.15.34.12;	author pjt;	state Exp;
branches;
next	2.2;

2.2
date	94.09.22.15.26.32;	author pjt;	state Exp;
branches;
next	2.1;

2.1
date	93.03.25.11.03.07;	author pjt;	state Exp;
branches;
next	1.14;

1.14
date	93.03.25.11.00.18;	author pjt;	state Exp;
branches;
next	1.13;

1.13
date	93.01.21.14.32.54;	author pjt;	state zero_1;
branches;
next	1.12;

1.12
date	93.01.15.14.34.33;	author pjt;	state Exp;
branches;
next	1.11;

1.11
date	93.01.15.13.07.57;	author pjt;	state Exp;
branches;
next	1.10;

1.10
date	93.01.15.10.43.45;	author pjt;	state zero_0;
branches;
next	1.9;

1.9
date	93.01.14.15.09.52;	author pjt;	state Exp;
branches;
next	1.8;

1.8
date	93.01.14.10.58.27;	author pjt;	state Exp;
branches;
next	1.7;

1.7
date	93.01.14.10.15.01;	author pjt;	state Exp;
branches;
next	1.6;

1.6
date	93.01.14.09.43.07;	author pjt;	state Exp;
branches;
next	1.5;

1.5
date	93.01.05.09.13.56;	author pjt;	state Exp;
branches;
next	1.4;

1.4
date	92.11.06.13.52.07;	author pjt;	state Exp;
branches;
next	1.3;

1.3
date	92.11.05.11.29.30;	author pjt;	state Exp;
branches;
next	1.2;

1.2
date	92.11.04.10.48.18;	author pjt;	state Exp;
branches;
next	1.1;

1.1
date	92.11.04.10.27.57;	author pjt;	state Exp;
branches;
next	;

11.14.2.1
date	2002.09.19.18.01.13;	author morrison;	state Exp;
branches;
next	11.14.2.2;

11.14.2.2
date	2004.03.17.21.16.50;	author morrison;	state Exp;
branches;
next	;

11.14.4.1
date	2004.03.11.23.41.49;	author morrison;	state Exp;
branches;
next	;

11.14.10.1
date	2004.02.12.18.39.18;	author erikg;	state Exp;
branches;
next	11.14.10.2;

11.14.10.2
date	2004.03.15.14.06.17;	author erikg;	state Exp;
branches;
next	;


desc
@
     Routines to create and insert into a red-black tree

@


11.18
log
@moved to src/
@
text
@/*			R B _ C R E A T E . C
 *
 *		Routines to create a red-black tree
 *
 *  Author -
 *	Paul J. Tanenbaum
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1998-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 *
 */
#ifndef lint
static const char libbu_rb_create_RCSid[] = "@@(#) $Header: /n/xoff/cvs/brlcad/libbu/rb_create.c,v 11.17 2004/05/10 15:30:44 erikg Exp $";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "bu.h"
#include "./rb_internals.h"

/*		    B U _ R B _ C R E A T E ( )
 *
 *		    Create a red-black tree
 *
 *	This function has three parameters: a comment describing the
 *	tree to create, the number of linear orders to maintain
 *	simultaneously, and the comparison functions (one per order).
 *	bu_rb_create() returns a pointer to the red-black tree header
 *	record.
 */
bu_rb_tree *bu_rb_create (char *description, int nm_orders, int (**order_funcs)() )
{
    int		order;
    bu_rb_tree	*tree;

    /*
     *	Allocate memory for the tree
     */
    tree = (bu_rb_tree *) bu_malloc(sizeof(bu_rb_tree), "red-black tree");
    tree -> rbt_root = (struct bu_rb_node **)
		    bu_malloc(nm_orders * sizeof(struct bu_rb_node),
			"red-black roots");
    tree -> rbt_unique = (char *)
		bu_malloc((size_t) ceil((double) (nm_orders / 8.0)),
			    "red-black uniqueness flags");
    bu_rb_null(tree) = (struct bu_rb_node *)
		    bu_malloc(sizeof(struct bu_rb_node),
				"red-black empty node");
    bu_rb_null(tree) -> rbn_parent = (struct bu_rb_node **)
		bu_malloc(nm_orders * sizeof(struct bu_rb_node *),
			    "red-black parents");
    bu_rb_null(tree) -> rbn_left = (struct bu_rb_node **)
		bu_malloc(nm_orders * sizeof(struct bu_rb_node *),
			    "red-black left children");
    bu_rb_null(tree) -> rbn_right = (struct bu_rb_node **)
		bu_malloc(nm_orders * sizeof(struct bu_rb_node *),
			    "red-black right children");
    bu_rb_null(tree) -> rbn_color = (char *)
		bu_malloc((size_t) ceil((double) (nm_orders / 8.0)),
			    "red-black colors");
    bu_rb_null(tree) -> rbn_size = (int *)
		bu_malloc(nm_orders * sizeof(int),
			    "red-black subtree sizes");
    bu_rb_null(tree) -> rbn_package = (struct bu_rb_package **)
		bu_malloc(nm_orders * sizeof(struct bu_rb_package *),
			    "red-black packages");
    /*
     *	Fill in the tree
     */
    tree -> rbt_magic = BU_RB_TREE_MAGIC;
    tree -> rbt_description = description;
    tree -> rbt_nm_orders = nm_orders;
    tree -> rbt_order = order_funcs;
    tree -> rbt_print = 0;
    bu_rb_uniq_all_off(tree);
    tree -> rbt_debug = 0x0;
    tree -> rbt_current = bu_rb_null(tree);
    for (order = 0; order < nm_orders; ++order)
	bu_rb_root(tree, order) = bu_rb_null(tree);
    BU_LIST_INIT(&(tree -> rbt_nodes.l));
    BU_LIST_INIT(&(tree -> rbt_packages.l));

    /*
     *	Initialize the nil sentinel
     */
    bu_rb_null(tree) -> rbn_magic = BU_RB_NODE_MAGIC;
    bu_rb_null(tree) -> rbn_tree = tree;
    for (order = 0; order < nm_orders; ++order)
    {
	bu_rb_parent(bu_rb_null(tree), order) = BU_RB_NODE_NULL;
	bu_rb_set_color(bu_rb_null(tree), order, BU_RB_BLACK);
	bu_rb_left_child(bu_rb_null(tree), order) = BU_RB_NODE_NULL;
	bu_rb_right_child(bu_rb_null(tree), order) = BU_RB_NODE_NULL;
	bu_rb_size(bu_rb_null(tree), order) = 0;
	(bu_rb_null(tree) -> rbn_package)[order] = BU_RB_PKG_NULL;
    }

    return (tree);
}

/*		    B U _ R B _ C R E A T E 1 ( )
 *
 *		Create a single-order red-black tree
 *
 *	This function has two parameters: a comment describing the
 *	tree to create and a comparison function.  bu_rb_create1() builds
 *	an array of one function pointer and passes it to bu_rb_create().
 *	bu_rb_create1() returns a pointer to the red-black tree header
 *	record.
 *
 *	N.B. - Since this function allocates storage for the array of
 *	function pointers, in order to avoid memory leaks on freeing
 *	the tree, applications should call bu_rb_free1(), NOT bu_rb_free().
 */
bu_rb_tree *bu_rb_create1 (char *description, int (*order_func) (/* ??? */))
{
    int		(**ofp)();

    ofp = (int (**)())
		bu_malloc(sizeof(int (*)()), "red-black function table");
    *ofp = order_func;
    return (bu_rb_create(description, 1, ofp));
}
@


11.17
log
@change conf.h to a wrapped config.h
@
text
@d23 1
a23 1
static const char libbu_rb_create_RCSid[] = "@@(#) $Header: /cvs/brlcad/libbu/rb_create.c,v 11.16 2004/04/05 07:46:16 morrison Exp $";
@


11.16
log
@merge of ansi-6-0-branch into HEAD
@
text
@d23 1
a23 1
static const char libbu_rb_create_RCSid[] = "@@(#) $Header$";
d26 5
a30 1
#include "conf.h"
@


11.15
log
@update copyright to include span through 2003
@
text
@d23 1
a23 1
static const char libbu_rb_create_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_create.c,v 11.14 2002/08/20 17:07:41 jra Exp $";
d44 1
a44 6
bu_rb_tree *bu_rb_create (description, nm_orders, order_funcs)

char	*description;
int	nm_orders;
int	(**order_funcs)();

d128 1
a128 5
bu_rb_tree *bu_rb_create1 (description, order_func)

char	*description;
int	(*order_func)();

@


11.14
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1998 by the United States Army
d23 1
a23 1
static const char libbu_rb_create_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_create.c,v 11.12 2000/07/07 05:20:13 cjohnson Exp $";
@


11.14.4.1
log
@sync to HEAD...
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d23 1
a23 1
static const char libbu_rb_create_RCSid[] = "@@(#) $Header: /n/cad/c/CVS/brlcad/libbu/rb_create.c,v 11.15 2004/02/02 17:39:07 morrison Exp $";
@


11.14.10.1
log
@merge from HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d23 1
a23 1
static const char libbu_rb_create_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_create.c,v 11.15 2004/02/02 17:39:07 morrison Exp $";
@


11.14.10.2
log
@merge from head
@
text
@d23 1
a23 1
static const char libbu_rb_create_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_create.c,v 11.14.10.1 2004/02/12 18:39:18 erikg Exp $";
@


11.14.2.1
log
@Initial ANSIfication
@
text
@d23 1
a23 1
static const char libbu_rb_create_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_create.c,v 11.14 2002/08/20 17:07:41 jra Exp $";
d44 6
a49 1
bu_rb_tree *bu_rb_create (char *description, int nm_orders, int (**order_funcs)() )
d133 5
a137 1
bu_rb_tree *bu_rb_create1 (char *description, int (*order_func) (/* ??? */))
@


11.14.2.2
log
@sync branch with HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d23 1
a23 1
static const char libbu_rb_create_RCSid[] = "@@(#) $Header$";
@


11.13
log
@Converted from K&R to ANSI C - RFH
@
text
@d44 6
a49 1
bu_rb_tree *bu_rb_create (char *description, int nm_orders, int (**order_funcs)() )
d133 5
a137 1
bu_rb_tree *bu_rb_create1 (char *description, int (*order_func) (/* ??? */))
@


11.12
log
@LINT
@
text
@d23 1
a23 1
static const char libbu_rb_create_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_create.c,v 11.11 2000/03/28 18:55:09 mike Exp $";
d44 1
a44 6
bu_rb_tree *bu_rb_create (description, nm_orders, order_funcs)

char	*description;
int	nm_orders;
int	(**order_funcs)();

d128 1
a128 5
bu_rb_tree *bu_rb_create1 (description, order_func)

char	*description;
int	(*order_func)();

@


11.11
log
@
Put libbu_filename_ prefixes on RCSid variables.
@
text
@d23 1
a23 1
static char libbu_rb_create_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_create.c,v 11.10 2000/03/28 18:04:43 mike Exp $";
@


11.10
log
@
Changed from RT_LIST to BU_LIST
A few dregs
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_create.c,v 11.9 1999/01/12 16:19:55 pjt Exp $";
@


11.9
log
@Various details concerning folding libredblack into libbu
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_create.c,v 11.8 1998/12/30 01:25:42 mike Exp $";
d98 2
a99 2
    RT_LIST_INIT(&(tree -> rbt_nodes.l));
    RT_LIST_INIT(&(tree -> rbt_packages.l));
@


11.8
log
@LibRedBlack routines now have a bu_ prefix.
@
text
@d1 1
a1 1
/*			B U _ R B _ C R E A T E . C
d23 1
a23 1
static char RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_create.c,v 11.7 1996/08/31 09:33:46 mike Exp $";
@


11.7
log
@LIBBU
@
text
@d1 1
a1 1
/*			R B _ C R E A T E . C
d5 15
a19 1
 *	Author:	Paul Tanenbaum
d23 1
a23 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_create.c,v 11.6 1995/09/20 12:34:44 pjt Exp pjt $";
a31 1
#include "redblack.h"
d34 1
a34 1
/*		    R B _ C R E A T E ( )
d41 1
a41 1
 *	rb_create() returns a pointer to the red-black tree header
d44 1
a44 1
rb_tree *rb_create (description, nm_orders, order_funcs)
d52 1
a52 1
    rb_tree	*tree;
d57 3
a59 3
    tree = (rb_tree *) bu_malloc(sizeof(rb_tree), "red-black tree");
    tree -> rbt_root = (struct rb_node **)
		    bu_malloc(nm_orders * sizeof(struct rb_node),
d64 5
a68 4
    rb_null(tree) = (struct rb_node *)
		    bu_malloc(sizeof(struct rb_node), "red-black empty node");
    rb_null(tree) -> rbn_parent = (struct rb_node **)
		bu_malloc(nm_orders * sizeof(struct rb_node *),
d70 2
a71 2
    rb_null(tree) -> rbn_left = (struct rb_node **)
		bu_malloc(nm_orders * sizeof(struct rb_node *),
d73 2
a74 2
    rb_null(tree) -> rbn_right = (struct rb_node **)
		bu_malloc(nm_orders * sizeof(struct rb_node *),
d76 1
a76 1
    rb_null(tree) -> rbn_color = (char *)
d79 1
a79 1
    rb_null(tree) -> rbn_size = (int *)
d82 2
a83 2
    rb_null(tree) -> rbn_package = (struct rb_package **)
		bu_malloc(nm_orders * sizeof(struct rb_package *),
d88 1
a88 1
    tree -> rbt_magic = RB_TREE_MAGIC;
d93 1
a93 1
    rb_uniq_all_off(tree);
d95 1
a95 1
    tree -> rbt_current = rb_null(tree);
d97 1
a97 1
	rb_root(tree, order) = rb_null(tree);
d104 2
a105 2
    rb_null(tree) -> rbn_magic = RB_NODE_MAGIC;
    rb_null(tree) -> rbn_tree = tree;
d108 6
a113 6
	rb_parent(rb_null(tree), order) = RB_NODE_NULL;
	rb_set_color(rb_null(tree), order, RB_BLACK);
	rb_left_child(rb_null(tree), order) = RB_NODE_NULL;
	rb_right_child(rb_null(tree), order) = RB_NODE_NULL;
	rb_size(rb_null(tree), order) = 0;
	(rb_null(tree) -> rbn_package)[order] = RB_PKG_NULL;
d119 1
a119 1
/*		    R B _ C R E A T E 1 ( )
d124 3
a126 3
 *	tree to create and a comparison function.  rb_create1() builds
 *	an array of one function pointer and passes it to rb_create().
 *	rb_create1() returns a pointer to the red-black tree header
d131 1
a131 1
 *	the tree, applications should call rb_free1(), NOT rb_free().
d133 1
a133 1
rb_tree *rb_create1 (description, order_func)
d144 1
a144 1
    return (rb_create(description, 1, ofp));
@


11.6
log
@Tweeked a comment
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_create.c,v 11.5 1995/09/20 12:09:35 pjt Exp pjt $";
d17 1
a17 3
#include "vmath.h"
#include "raytrace.h"
#include "rtlist.h"
d44 1
a44 1
    tree = (rb_tree *) rt_malloc(sizeof(rb_tree), "red-black tree");
d46 1
a46 1
		    rt_malloc(nm_orders * sizeof(struct rb_node),
d49 1
a49 1
		rt_malloc((size_t) ceil((double) (nm_orders / 8.0)),
d52 1
a52 1
		    rt_malloc(sizeof(struct rb_node), "red-black empty node");
d54 1
a54 1
		rt_malloc(nm_orders * sizeof(struct rb_node *),
d57 1
a57 1
		rt_malloc(nm_orders * sizeof(struct rb_node *),
d60 1
a60 1
		rt_malloc(nm_orders * sizeof(struct rb_node *),
d63 1
a63 1
		rt_malloc((size_t) ceil((double) (nm_orders / 8.0)),
d66 1
a66 1
		rt_malloc(nm_orders * sizeof(int),
d69 1
a69 1
		rt_malloc(nm_orders * sizeof(struct rb_package *),
d128 1
a128 1
		rt_malloc(sizeof(int (*)()), "red-black function table");
@


11.5
log
@Added maintenance of rbn_size member of struct rb_node
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_create.c,v 11.4 1995/07/10 20:17:22 pjt Exp pjt $";
d112 1
a112 1
 *	tree to create and a comparison function.  Rb_create1() builds
@


11.4
log
@Now maintain lists of all nodes and of all packages
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_create.c,v 11.3 1995/07/07 15:29:00 pjt Exp $";
d67 3
d100 1
@


11.3
log
@1. Gave the nil sentinel lists of (null) children and sentinels
2. Converted several places that weren't yet using rb_null() macro
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_create.c,v 11.2 1995/04/19 19:04:11 pjt Exp $";
d19 1
d83 2
d112 4
@


11.2
log
@1. Allocate storage for and initialize rbt_unique member.
2. Initialize rbt_debug
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_create.c,v 11.1 95/01/04 10:05:52 mike Rel4_4 $";
d52 1
a52 1
    tree -> rbt_empty_node = (struct rb_node *)
d57 6
d66 3
d79 1
a79 1
    tree -> rbt_current = tree -> rbt_empty_node;
d92 3
a95 2
    rb_null(tree) -> rbn_left = 0;
    rb_null(tree) -> rbn_right = 0;
@


11.1
log
@Release_4.4
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_create.c,v 2.5 94/12/30 16:41:04 stay Exp $";
d49 3
d68 2
@


2.5
log
@deleted reference to stdlib, it wil be included in conf.h if
it exists or is STDC
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_create.c,v 2.4 1994/09/26 12:21:10 jra Exp stay $";
@


2.4
log
@Added #include "conf.h"
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_create.c,v 2.3 94/09/22 15:34:12 pjt Exp Locker: jra $";
a13 1
#include <stdlib.h>
@


2.3
log
@Changed "#include "rt_internals.h" to "#include "./rt_internals.h"
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_create.c,v 2.2 94/09/22 15:26:32 pjt Exp Locker: pjt $";
d11 2
@


2.2
log
@Replaced prototype-type definition with K&R type
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_create.c,v 2.1 93/03/25 11:03:07 pjt Exp $";
d19 1
a19 1
#include "rb_internals.h"
@


2.1
log
@Installed into BRL CAD tree
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_create.c,v 1.14 93/03/25 11:00:18 pjt Exp Locker: pjt $";
d31 6
a36 1
rb_tree *rb_create (char *description, int nm_orders, int (**order_funcs)())
d94 5
a98 1
rb_tree *rb_create1 (char *description, int (*order_func)())
@


1.14
log
@Added authorship comment
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_create.c,v 1.13 93/01/21 14:32:54 pjt zero_1 Locker: pjt $";
@


1.13
log
@Moved rb_insert() and _rb_insert() into rb_insert.c
@
text
@d5 2
d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /arl/pjt/libredblack/RCS/rb_create.c,v 1.12 93/01/15 14:34:33 pjt Exp Locker: pjt $";
@


1.12
log
@Allocated storage for colors in rbt_empty_node
and initialized them all to RB_BLACK
@
text
@d3 1
a3 1
 *	Routines to create and insert into a red-black tree
d7 1
a7 1
static char RCSid[] = "@@(#) $Header: /arl/pjt/libredblack/RCS/rb_create.c,v 1.11 93/01/15 13:07:57 pjt Exp Locker: pjt $";
a74 143
}

/*			_ R B _ I N S E R T ( )
 *
 *	    Insert a node into one linear order of a red-black tree
 *
 *	This function has three parameters: the tree and linear order into
 *	which to insert the new node and the new node itself.  If the node
 *	is equal (modulo the linear order) to a node already in the tree,
 *	_rb_insert() returns 1.  Otherwise, it returns 0.
 */
static int _rb_insert (rb_tree *tree, int order, struct rb_node *new_node)
{
    struct rb_node	*node;
    struct rb_node	*parent;
    int			(*compare)();
    int			comparison;


    RB_CKMAG(tree, RB_TREE_MAGIC, "red-black tree");
    RB_CKORDER(tree, order);
    RB_CKMAG(new_node, RB_NODE_MAGIC, "red-black node");

    /*
     *	Initialize the new node
     */
    rb_parent(new_node, order) =
    rb_left_child(new_node, order) =
    rb_right_child(new_node, order) = rb_null(tree);

    parent = rb_null(tree);
    node = rb_root(tree, order);
    compare = rb_order_func(tree, order);
    while (node != rb_null(tree))
    {
	parent = node;
	comparison = (*compare)(rb_data(new_node, order), rb_data(node, order));
	if (comparison < 0)
	    node = rb_left_child(node, order);
	else
	    node = rb_right_child(node, order);
    }
    rb_parent(new_node, order) = parent;
    if (parent == rb_null(tree))
	rb_root(tree, order) = new_node;
    else if ((*compare)(rb_data(new_node, order), rb_data(parent, order)) < 0)
	rb_left_child(parent, order) = new_node;
    else
	rb_right_child(parent, order) = new_node;
    
    return (comparison == 0);
}

/*			R B _ I N S E R T ( )
 *
 *		Applications interface to _rb_insert()
 *
 *	This function has two parameters: the tree into which to insert
 *	the new node and the contents of the node.  rb_insert() returns
 *	the number of orders for which the new node was equal to a node
 *	already in the tree.
 */
int rb_insert (rb_tree *tree, void *data)
{
    int			nm_orders;
    int			order;
    int			result = 0;
    struct rb_node	*node;
    struct rb_package	*package;

    RB_CKMAG(tree, RB_TREE_MAGIC, "red-black tree");

    nm_orders = tree -> rbt_nm_orders;

    /*
     *	Make a new package
     */
    package = (struct rb_package *)
		rt_malloc(sizeof(struct rb_package), "red-black package");
    package -> rbp_node = (struct rb_node **)
		rt_malloc(nm_orders * sizeof(struct rb_node *),
			    "red-black package nodes");

    /*
     *	Make a new node
     */
    node = (struct rb_node *)
		rt_malloc(sizeof(struct rb_node), "red-black node");
    node -> rbn_parent = (struct rb_node **)
		rt_malloc(nm_orders * sizeof(struct rb_node *),
			    "red-black parents");
    node -> rbn_left = (struct rb_node **)
		rt_malloc(nm_orders * sizeof(struct rb_node *),
			    "red-black left children");
    node -> rbn_right = (struct rb_node **)
		rt_malloc(nm_orders * sizeof(struct rb_node *),
			    "red-black right children");
    node -> rbn_color = (char *)
		rt_malloc((size_t) ceil((double) (nm_orders / 8.0)),
			    "red-black colors");
    node -> rbn_package = (struct rb_package **)
		rt_malloc(nm_orders * sizeof(struct rb_package *),
			    "red-black packages");

    /*
     *	Fill in the package
     */
    package -> rbp_magic = RB_PKG_MAGIC;
    package -> rbp_data = data;
    for (order = 0; order < nm_orders; ++order)
	(package -> rbp_node)[order] = node;

    /*
     *	Fill in the node
     */
    node -> rbn_magic = RB_NODE_MAGIC;
    node -> rbn_tree = tree;
    for (order = 0; order < nm_orders; ++order)
    {
	rb_set_color(node, order, RB_RED);
	(node -> rbn_package)[order] = package;
    }
    node -> rbn_pkg_refs = nm_orders;

    /*
     *	If the tree was empty, install this node as the root
     *	and give it a null parent and null children
     */
    if (rb_root(tree, 0) == rb_null(tree))
	for (order = 0; order < nm_orders; ++order)
	{
	    rb_root(tree, order) = node;
	    rb_parent(node, order) =
	    rb_left_child(node, order) =
	    rb_right_child(node, order) = rb_null(tree);
	}
    /*	Otherwise, insert the node into the tree */
    else
	for (order = 0; order < nm_orders; ++order)
	    result += _rb_insert(tree, order, node);

    rb_current(tree) = node;
    return (result);
@


1.11
log
@Added comments and performed general clean up
@
text
@d7 1
a7 1
static char RCSid[] = "@@(#) $Header: /arl/pjt/libredblack/RCS/rb_create.c,v 1.10 93/01/15 10:43:45 pjt Exp Locker: pjt $";
d43 1
a43 1
    tree -> rbt_empty_node  -> rbn_parent = (struct rb_node **)
d46 3
d64 2
a65 2
    tree -> rbt_empty_node -> rbn_magic = RB_NODE_MAGIC;
    tree -> rbt_empty_node -> rbn_tree = tree;
d67 6
a72 3
	(tree -> rbt_empty_node -> rbn_parent)[order] = RB_NODE_NULL;
    tree -> rbt_empty_node -> rbn_left = 0;
    tree -> rbt_empty_node -> rbn_right = 0;
@


1.10
log
@Addes static char RCSid[] to contain the RCS header
@
text
@d3 1
a3 1
 *	Written by:	Paul Tanenbaum
d7 1
a7 1
static char RCSid[] = "@@(#) $Header: /arl/pjt/libredblack/RCS/rb_create.c,v 1.9 93/01/14 15:09:52 pjt Exp Locker: pjt $";
a16 1
#define		RB_CREATE	1
d25 3
a27 3
 *	simultaneously, the comparison functions (one per order).  On
 *	success, rb_create() returns a pointer to the red-black tree
 *	header record created.  Otherwise, it returns RB_TREE_NULL.
d34 5
a38 3
    if (((tree = (rb_tree *) rt_malloc(sizeof(rb_tree), "red-black tree"))
	    == RB_TREE_NULL)						||
	((tree -> rbt_root = (struct rb_node **)
d40 4
a43 5
			"red-black roots")) == 0)			||
	((tree -> rbt_empty_node = (struct rb_node *)
		    rt_malloc(sizeof(struct rb_node),
			"red-black empty node")) == RB_NODE_NULL)	||
	((tree -> rbt_empty_node  -> rbn_parent = (struct rb_node **)
d45 4
a48 5
			    "red-black parents")) == 0))
    {
	fputs("rb_create(): Ran out of memory\n", stderr);
	return (RB_TREE_NULL);
    }
d55 2
a67 2
    for (order = 0; order < nm_orders; ++order)
	rb_root(tree, order) = rb_null(tree);
d76 3
a78 3
 *	which to insert the new node and the contents of the node.  If
 *	the new node was equal (modulo the linear order) to a node already
 *	in the tree, _rb_insert() returns 1.  Otherwise, it returns 0.
d122 1
a122 1
/*		    R B _ I N S E R T ( )
d124 1
a124 1
 *		Insert a node into a red-black tree
d127 3
a129 5
 *	the new node and the contents of the node.  The bulk of this code
 *	is from T. H. Cormen, C. E. Leiserson, and R. L. Rivest.  _Intro-
 *	duction to Algorithms_.  Cambridge, MA: MIT Press, 1990. p. 268.
 *	rb_insert() returns the number of orders for which the new node
 *	was equal to a node already in the tree.
d144 1
a144 1
     *	Create a new package
d153 1
a153 1
     *	Create a new node
d172 1
a209 1
    /* Record the node with which we've been working */
d216 1
a216 1
 *		Create a single red-black tree
d221 2
a222 2
 *	Onsuccess, rb_create1() returns a pointer to the red-black tree
 *	header record created.  Otherwise, it returns RB_TREE_NULL.
d228 2
a229 7
    if ((ofp = (int (**)())
		rt_malloc(sizeof(int (*)()),
		    "red-black function table")) == NULL)
    {
	fputs("rb_create1(): Ran out of memory\n", stderr);
	return (RB_TREE_NULL);
    }
a231 14
}

/*		    R B _ I N S T A L L _ P R I N T ( )
 *
 *	    Install a pretty-print function in a red-black tree
 *
 *	This function has two parameters: a tree and a pretty-print
 *	function, which LIBREDBLACK uses for diagnostic purposes.
 */
void rb_install_print (rb_tree *tree, void (*print_func)())
{
    RB_CKMAG(tree, RB_TREE_MAGIC, "red-black tree");

    tree -> rbt_print = print_func;
@


1.9
log
@1. Implement the package stuff
2. Implemented rb_install_print()
@
text
@a4 1
 *  $Header: /arl/pjt/libredblack/RCS/rb_create.c,v 1.8 93/01/14 10:58:27 pjt Exp Locker: pjt $
d6 3
@


1.8
log
@Added call to RB_CKORDER()
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/rb_create.c,v 1.7 93/01/14 10:15:01 pjt Exp Locker: pjt $
d52 2
d129 2
a130 3
 *	On failure, rb_insert() returns the value -1.  Otherwise, it
 *	returns the number of orders for which the new node was equal to
 *	a node already in the tree.
d138 1
d144 6
a149 5
    /* Create a new node */
    if (((node = (struct rb_node *)
		rt_malloc(sizeof(struct rb_node), "red-black node"))
	== RB_NODE_NULL)						||
	((node -> rbn_parent = (struct rb_node **)
d151 8
a158 2
			    "red-black parents")) == 0)			||
	((node -> rbn_left = (struct rb_node **)
d160 2
a161 2
			    "red-black left children")) == 0)		||
	((node -> rbn_right = (struct rb_node **)
d163 5
a167 2
			    "red-black right children")) == 0)		||
	((node -> rbn_color =
d169 11
a179 8
			    "red-black colors")) == 0)			||
	((node -> rbn_data = (void **)
		    rt_malloc(nm_orders * sizeof(void *),
			    "red-black data")) == 0))
    {
	fputs("rb_insert(): Ran out of memory\n", stderr);
	return (-1);
    }
d182 1
a182 1
     *	Fill the node and insert it into the tree
d187 5
a191 2
	rb_data(node, order) = data;
    node -> rbn_data_refs = nm_orders;
a207 1
	{
a208 2
	    rb_set_color(node, order, RB_RED);
	}
d211 1
a211 1
    current_node = node;
d238 14
@


1.7
log
@1. _rb_insert() now returns a flag indicating whether it found
   an existing node equal to the new node
2. rb_insert() now returns
    -1    on error
     0    if the new node is different from all existing nodes on each order
     n    the number of orders on which new node equals some old node
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/rb_create.c,v 1.6 93/01/14 09:43:07 pjt Exp Locker: pjt $
d86 1
a137 1
    /* Check data type of the parameter "tree" */
d139 1
@


1.6
log
@1. Switch from malloc() to rt_malloc() and rt_free()
2. Use rb_null() and rb_data()
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/rb_create.c,v 1.5 93/01/05 09:13:56 pjt Exp Locker: pjt $
d73 3
a75 1
 *	which to insert the new node and the contents of the node.
d77 1
a77 1
static void _rb_insert (rb_tree *tree, int order, struct rb_node *new_node)
d82 1
d101 2
a102 1
	if ((*compare)(rb_data(new_node, order), rb_data(node, order)) < 0)
d114 2
d126 3
a128 1
 *	On success, rb_insert() returns the value 1.  Otherwise, it returns 0.
d134 1
d162 1
a162 1
	return (0);
d172 1
a172 1
    node -> rbn_data_count = nm_orders;
d190 1
a190 1
	    _rb_insert(tree, order, node);
d196 1
a196 1
    return (1);
@


1.5
log
@Implemented rb_create1()
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/rb_create.c,v 1.4 92/11/06 13:52:07 pjt Exp Locker: pjt $
d11 3
d33 2
a34 1
    if (((tree = (rb_tree *) malloc(sizeof(rb_tree))) == RB_TREE_NULL)	||
d36 8
a43 1
		    malloc(nm_orders * sizeof(struct rb_node))) == 0))
d52 6
d59 6
a64 1
	rb_root(tree, order) = RB_NODE_NULL;
d73 1
a73 2
 *	which to insert the new node and the contents of the node. On success,
 *	_rb_insert() returns the value 1.  Otherwise, it returns 0.
d75 1
a75 1
static int _rb_insert (rb_tree *tree, int order, struct rb_node *new_node)
d90 1
a90 1
    rb_right_child(new_node, order) = RB_NODE_NULL;
d92 1
a92 1
    parent = RB_NODE_NULL;
d95 1
a95 1
    while (node != RB_NODE_NULL)
d98 1
a98 1
	if ((*compare)(new_node -> rbn_data, node -> rbn_data) < 0)
d104 1
a104 1
    if (parent == RB_NODE_NULL)
d106 1
a106 1
    else if ((*compare)(new_node -> rbn_data, parent -> rbn_data) < 0)
a109 2

    return (1);
d133 2
a134 1
    if (((node = (struct rb_node *) malloc(sizeof(struct rb_node)))
d137 2
a138 1
		    malloc(nm_orders * sizeof(struct rb_node))) == 0)	||
d140 2
a141 1
		    malloc(nm_orders * sizeof(struct rb_node))) == 0)	||
d143 2
a144 1
		    malloc(nm_orders * sizeof(struct rb_node))) == 0)	||
d146 5
a150 1
	    malloc((size_t) ceil((double) (nm_orders / 8.0)))) == 0))
d161 4
a164 1
    node -> rbn_data = data;
d169 1
a169 1
    if (rb_root(tree, 0) == RB_NODE_NULL)
d175 1
a175 1
	    rb_right_child(node, order) = RB_NODE_NULL;
d204 3
a206 1
    if ((ofp = (int (**)()) malloc(sizeof(int (*)()))) == NULL)
@


1.4
log
@1. Moved _rb_insert() above rb_insert and made it static
2. Moved rb_describe() to rb_diagnostics.c
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/rb_create.c,v 1.3 92/11/05 11:29:30 pjt Exp Locker: pjt $
d158 23
@


1.3
log
@Changed rbt_root from (struct rb_node *) to (struct rb_node **)
and used access functions rb_root() and rb_order_func().
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/rb_create.c,v 1.2 92/11/04 10:48:18 pjt Exp Locker: pjt $
d46 47
a157 78
}

/*			_ R B _ I N S E R T ( )
 *
 *	    Insert a node into one linear order of a red-black tree
 *
 *	This function has three parameters: the tree and linear order into
 *	which to insert the new node and the contents of the node. On success,
 *	_rb_insert() returns the value 1.  Otherwise, it returns 0.
 */
int _rb_insert (rb_tree *tree, int order, struct rb_node *new_node)
{
    struct rb_node	*node;
    struct rb_node	*parent;
    int			(*compare)();


    RB_CKMAG(tree, RB_TREE_MAGIC, "red-black tree");
    RB_CKMAG(new_node, RB_NODE_MAGIC, "red-black node");

    /*
     *	Initialize the new node
     */
    rb_parent(new_node, order) =
    rb_left_child(new_node, order) =
    rb_right_child(new_node, order) = RB_NODE_NULL;

    parent = RB_NODE_NULL;
    node = rb_root(tree, order);
    compare = rb_order_func(tree, order);
    while (node != RB_NODE_NULL)
    {
	parent = node;
	if ((*compare)(new_node -> rbn_data, node -> rbn_data) < 0)
	    node = rb_left_child(node, order);
	else
	    node = rb_right_child(node, order);
    }
    rb_parent(new_node, order) = parent;
    if (parent == RB_NODE_NULL)
	rb_root(tree, order) = new_node;
    else if ((*compare)(new_node -> rbn_data, parent -> rbn_data) < 0)
	rb_left_child(parent, order) = new_node;
    else
	rb_right_child(parent, order) = new_node;

    return (1);
}

/*		    R B _ D E S C R I B E ( )
 *
 *		    Describe a red-black tree
 *
 *	This function has one parameter: a pointer to a red-black
 *	tree.  Rb_describe() prints out the header information
 *	for the tree.  It is intended for diagnostic purposes.
 */
void rb_describe (rb_tree *tree)
{
    int		i;

    RB_CKMAG(tree, RB_TREE_MAGIC, "red-black tree");
    fprintf(stderr, "-------- Red-black tree <%x> --------\n", tree);
    fprintf(stderr, "Description: '%s'\n", tree -> rbt_description);
    if (tree -> rbt_nm_orders <= 0)
	fputs("No orders\n", stderr);
    else
	for (i = 0; i < tree -> rbt_nm_orders; ++i)
	{
	    fprintf(stderr,
		    "Order[%d]:   <%x>\n", i, rb_order_func(tree, i));
	    fprintf(stderr,
		    "Root[%d]:    <%x>\n", i, rb_root(tree, i));
	    if (rb_root(tree, 0) != RB_NODE_NULL)
		fprintf(stderr,
		    "Data[%d]:    <%x>\n", i, rb_root(tree, i) -> rbn_data);
	}
    fprintf(stderr, "-----------------------------------------\n");
@


1.2
log
@1. Changed a cast in arg to malloc from (unsigned) to (size_t)
2. Removed a lot of diagnostics
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/rb_create.c,v 1.1 92/11/04 10:27:57 pjt Exp Locker: pjt $
d25 1
a25 1
rb_tree *rb_create (char *description, int nm_orders, int (**order)())
d27 1
d30 3
a32 1
    if ((tree = (rb_tree *) malloc(sizeof(rb_tree))) == NULL)
d40 3
a42 2
    tree -> rbt_order = order;
    tree -> rbt_root = RB_NODE_NULL;
d88 5
a92 4
    /*	If the tree was empty, install this node as the root	*/
    if (tree -> rbt_root == RB_NODE_NULL)
    {
	tree -> rbt_root = node;
d94 2
d99 1
a99 1
    }
d139 1
a139 1
    node = tree -> rbt_root;
d151 1
a151 1
	tree -> rbt_root = new_node;
d179 1
d181 7
a187 4
		    "Order[%d]:   <%x>\n", i, (tree -> rbt_order)[i]);
    fprintf(stderr, "Root:        <%d>\n", tree -> rbt_root);
    if (tree -> rbt_root != RB_NODE_NULL)
	fprintf(stderr, "Data:        <%d>\n", tree -> rbt_root -> rbn_data);
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
 *  $Header: /m/cad/h/RCS/raytrace.h,v 10.1 91/10/12 06:35:30 mike Rel4_0 $
d8 1
d72 1
a72 1
	    malloc((unsigned) ceil((double) (nm_orders / 8.0)))) == 0))
a120 2
    fprintf(stderr, "_rb_insert(<%x>, %d, <%x> (<%x>))...\n",
	    tree, order, new_node);fflush(stderr);
a137 2
	{
	    fputs("...looking left\n", stderr);fflush(stderr);
a138 1
	}
a139 2
	{
	    fputs("...looking right\n", stderr);fflush(stderr);
a140 1
	}
a143 1
    {
a144 2
	fputs("...installing as new root\n", stderr);fflush(stderr);
    }
a145 1
    {
a146 2
	fputs("...installing on left\n", stderr);fflush(stderr);
    }
a147 1
    {
a148 2
	fputs("...installing on right\n", stderr);fflush(stderr);
    }
@
