head	1.21;
access;
symbols
	ansi-20040405-merged:1.16.2.2
	postmerge-20040405-ansi:1.19
	premerge-20040404-ansi:1.18
	postmerge-autoconf:1.18
	autoconf-freeze:1.17.6.1
	premerge-autoconf:1.18
	ansi-20040316-freeze:1.16.2.1
	postmerge-20040315-windows:1.18
	premerge-20040315-windows:1.17
	windows-20040315-freeze:1.16.4.2
	autoconf-20031203:1.17
	autoconf-20031202:1.17
	autoconf-branch:1.17.0.6
	phong-branch:1.17.0.4
	photonmap-branch:1.17.0.2
	rel-6-1-DP:1.17
	windows-branch:1.16.0.4
	rel-6-0-2:1.14
	ansi-branch:1.16.0.2
	rel-6-0-1-branch:1.14.0.2
	hartley-6-0-post:1.15
	hartley-6-0-pre:1.14
	rel-6-0-1:1.14
	rel-6-0:1.14
	rel-5-4:1.11.2.1
	offsite-5-3-pre:1.12
	rel-5-3:1.11.2.1
	rel-5-2:1.11.2.1
	rel-5-1-branch:1.11.0.2
	rel-5-1:1.11
	rel-5-0:1.10
	rel-5-0-beta:1.10
	rel-4-5:1.5
	ctj-4-5-post:1.2
	ctj-4-5-pre:1.2;
locks; strict;
comment	@ * @;


1.21
date	2004.05.21.18.06.25;	author morrison;	state dead;
branches;
next	1.20;

1.20
date	2004.05.10.15.30.44;	author erikg;	state Exp;
branches;
next	1.19;

1.19
date	2004.04.05.07.46.16;	author morrison;	state Exp;
branches;
next	1.18;

1.18
date	2004.03.16.19.40.49;	author morrison;	state Exp;
branches;
next	1.17;

1.17
date	2002.10.11.08.30.56;	author kermit;	state Exp;
branches
	1.17.6.1;
next	1.16;

1.16
date	2002.08.20.17.07.42;	author jra;	state Exp;
branches
	1.16.2.1
	1.16.4.1;
next	1.15;

1.15
date	2002.08.15.20.54.55;	author hartley;	state Exp;
branches;
next	1.14;

1.14
date	2001.04.27.14.21.37;	author morrison;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.19.22.19.45;	author butler;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.07.05.20.14;	author cjohnson;	state Exp;
branches;
next	1.11;

1.11
date	2000.03.09.03.44.19;	author cjohnson;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	99.03.17.01.32.07;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	99.03.17.01.27.42;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	99.03.03.15.23.09;	author pjt;	state Exp;
branches;
next	1.7;

1.7
date	99.03.01.17.13.40;	author pjt;	state Exp;
branches;
next	1.6;

1.6
date	98.11.05.19.49.36;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	97.12.24.04.47.30;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	97.12.04.02.49.38;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	97.11.22.02.57.48;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	96.08.27.06.51.34;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	96.08.27.06.18.33;	author mike;	state Exp;
branches;
next	;

1.11.2.1
date	2000.08.22.13.59.24;	author jra;	state Exp;
branches;
next	;

1.16.2.1
date	2002.09.19.18.01.14;	author morrison;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2004.03.17.21.16.51;	author morrison;	state Exp;
branches;
next	;

1.16.4.1
date	2002.09.26.23.03.52;	author morrison;	state Exp;
branches;
next	1.16.4.2;

1.16.4.2
date	2004.03.11.23.41.50;	author morrison;	state Exp;
branches;
next	;

1.17.6.1
date	2004.03.18.18.08.13;	author erikg;	state Exp;
branches;
next	;


desc
@semaphore.c
@


1.21
log
@moved to src/
@
text
@/*
 *			S E M A P H O R E . C
 *
 *  Machine-specific routines for parallel processing.
 *  Primarily for handling semaphores for critical sections.
 *
 *  The new paradigm:  semaphores are referred to, not by a pointer,
 *  but by a small integer.  This module is now responsible for obtaining
 *  whatever storage is needed to implement each semaphore.
 *
 *  Note that these routines can't use bu_log() for error logging,
 *  because bu_log() accquires semaphore #0 (BU_SEM_SYSCALL).
 *
 *  For code conversion hints, see "h/compat4.h"
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
 */
#ifndef lint
static const char RCSsemaphore[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libbu/semaphore.c,v 1.20 2004/05/10 15:30:44 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <ctype.h>
#include <math.h>
#include "machine.h"
#include "externs.h"
#include "bu.h"

#ifdef CRAY
# include <sys/category.h>
# include <sys/resource.h>
# include <sys/types.h>
# ifdef CRAY1
#  include <sys/machd.h>	/* For HZ */
# endif
struct bu_semaphores {
	long	magic;
	long	p;
};
# define DEFINED_BU_SEMAPHORES	1
#endif

#ifdef CRAY2
#undef MAXINT
# include <sys/param.h>
#endif

#if defined(alliant) && !defined(i860)
/* Alliant FX/8 */
# include <cncall.h>
struct bu_semaphores {
	long	magic;
	char	c;
};
# define DEFINED_BU_SEMAPHORES	1
#endif

#if (defined(sgi) && defined(mips)) || (defined(__sgi) && defined(__mips))
# define SGI_4D	1
# define _SGI_SOURCE	1	/* IRIX 5.0.1 needs this to def M_BLKSZ */
# define _BSD_TYPES	1	/* IRIX 5.0.1 botch in sys/prctl.h */
# include <sys/types.h>
# include <ulocks.h>
/* ulocks.h #include's <limits.h> and <malloc.h> */
/* ulocks.h #include's <task.h> for getpid stuff */
/* task.h #include's <sys/prctl.h> */
# include <malloc.h>
/* <malloc.h> #include's <stddef.h> */

#include <sys/wait.h>

#ifndef WIN32
static char		bu_lockfile[] = "/usr/tmp/bu_lockXXXXXX";
#else
static char		bu_lockfile[] = "C:\\bu_lockXXXXXX";
#endif
static usptr_t		*bu_lockstuff = 0;
extern int		_utrace;

struct bu_semaphores {
	long	magic;
	ulock_t	ltp;
};
# define DEFINED_BU_SEMAPHORES	1
#endif /* SGI_4D */

/* XXX Probably need to set _SGI_MP_SOURCE in machine.h */

#ifdef ardent
#	include <thread.h>
struct bu_semaphores {
	long	magic;
	char	sem;
};
# define DEFINED_BU_SEMAPHORES	1
#endif

#if defined(convex) || defined(__convex__)
struct bu_semaphores {
	long	magic;
	long	sem;
};
# define DEFINED_BU_SEMAPHORES	1
#endif

#if defined(n16)
#	include <parallel.h>
#	include <sys/sysadmin.h>
struct bu_semaphores {
	long	magic;
	char	sem;
};
# define DEFINED_BU_SEMAPHORES	1
#endif

/*
 * multithreading support for SunOS 5.X / Solaris 2.x
 */
#if SUNOS >= 52
#	include <sys/unistd.h>
#	include <thread.h>
#	include <synch.h>
struct bu_semaphores {
	long	magic;
	mutex_t	mu;
};
# define DEFINED_BU_SEMAPHORES	1
#endif	/* SUNOS */

#if defined(HAS_POSIX_THREADS)
#ifdef __sp3__
#	include	<unistd.h>
#else
#	include <sys/unistd.h>
#endif
#	include <pthread.h>
struct bu_semaphores {
	long	magic;
	pthread_mutex_t	mu;
};
# define DEFINED_BU_SEMAPHORES	1
#endif	/* HAS_POSIX_THREADS */

#define	BU_SEMAPHORE_MAGIC		0x62757365

#if defined(SGI_4D)
/*
 *			 B U _ S E M A P H O R E _ S G I _ I N I T
 */
static void
bu_semaphore_sgi_init()
{
	/*
	 *  First time through.
	 *  Use this opportunity to tune malloc().  It needs it!
	 *  Default for M_BLKSZ is 8k.
	 */
	if( mallopt( M_BLKSZ, 128*1024 ) != 0 )
		fprintf(stderr, "bu_semaphore_sgi_init: mallopt() failed\n");

	/* Now, set up the lock arena */
	(void)mktemp(bu_lockfile);
	if( bu_debug & BU_DEBUG_PARALLEL )  {
		if( usconfig( CONF_LOCKTYPE, _USDEBUGPLUS ) == -1 )
			perror("usconfig CONF_LOCKTYPE");
	}
	/*
	 *  Note that libc mp debugging to stderr can be enabled by saying
	 *	int _utrace=1;
	 */

	/* Cause lock file to vanish on exit */
	usconfig(CONF_ARENATYPE, US_SHAREDONLY);

	/* Set maximum number of procs that can share this arena */
	usconfig(CONF_INITUSERS, bu_avail_cpus()+1);

	if( bu_debug & BU_DEBUG_PARALLEL )  {
		/* This is a big performance hit, but may find bugs */
		usconfig(CONF_LOCKTYPE, US_DEBUG);
	} else {
		usconfig(CONF_LOCKTYPE, US_NODEBUG);
	}

	/* Initialize arena */
	bu_lockstuff = usinit(bu_lockfile);
	if (bu_lockstuff == 0) {
		perror("usinit");
		fprintf(stderr, "bu_semaphore_sgi_init: usinit(%s) failed, unable to allocate lock space\n", bu_lockfile);
		exit(2);
	}
}
#endif

#if defined(convex) || defined(__convex__)
/*
 *			B U _ C O N V E X _ A C Q U I R E
 */
static void
bu_convex_acquire(p)
register long *p;
{
	asm("getlck:");
	asm("	tas	@@0(ap)");	/* try to set the lock */
	asm("	jbra.f	getlck");	/* loop until successful */
}
#endif /* convex */

#if defined(PARALLEL) || defined(DEFINED_BU_SEMAPHORES)
static unsigned int		bu_nsemaphores = 0;
static struct bu_semaphores	*bu_semaphores = (struct bu_semaphores *)NULL;
#endif

/*
 *			B U _ S E M A P H O R E _ I N I T
 *
 *  Prepare 'nsemaphores' independent critical section semaphores.
 *  Die on error.
 *  Takes the place of 'n' separate calls to old RES_INIT().
 *  Start by allocating array of "struct bu_semaphores", which has been
 *  arranged to contain whatever this system needs.
 *
 */
void
bu_semaphore_init(unsigned int nsemaphores)
{
#if !defined(PARALLEL) && !defined(DEFINED_BU_SEMAPHORES)
	return;					/* No support on this hardware */
#else
	int	i;

	if( bu_nsemaphores != 0 )  return;	/* Already called */
	bu_semaphores = (struct bu_semaphores *)calloc(
		nsemaphores,
		sizeof(struct bu_semaphores) );
	if( !bu_semaphores )  {
		fprintf(stderr, "bu_semaphore_init(): could not allocate space for %d semaphores of len %ld\n",
			nsemaphores, (long)sizeof(struct bu_semaphores));
		exit(2);
	}

	/*
	 *  Begin vendor-specific initialization sections.
	 */

#	if defined(alliant)	
	for( i=0; i < nsemaphores; i++ )  {
		bu_semaphores[i].magic = BU_SEMAPHORE_MAGIC;
		(void) initialize_lock( &bu_semaphores[i].c );
	}
#	endif

#	ifdef ardent
	for( i=0; i < nsemaphores; i++ )  {
		bu_semaphores[i].magic = BU_SEMAPHORE_MAGIC;
		bu_semaphores[i].sem = 1;	/* mark as released */
	}
#	endif

#	if defined(convex) || defined(__convex__)
	for( i=0; i < nsemaphores; i++ )  {
		bu_semaphores[i].magic = BU_SEMAPHORE_MAGIC;
		bu_semaphores[i].sem = 0;	/* mark as released */
	}
#	endif

#	ifdef CRAY
	for( i=0; i < nsemaphores; i++ )  {
		bu_semaphores[i].magic = BU_SEMAPHORE_MAGIC;
		LOCKASGN( &bu_semaphores[i].p );
	}
#	endif /* CRAY */

#	if defined(n16)
	/*
	 *			Encore MultiMax.
	 *  While the manual suggests that one should use spin_create()
	 *  to aquire a new control structure for spin locking, it turns
	 *  out that the library support for that simply malloc()s a 1-byte
	 *  area to contain the lock, and sets it to PAR_UNLOCKED.
	 */
	for( i=0; i < nsemaphores; i++ )  {
		bu_semaphores[i].magic = BU_SEMAPHORE_MAGIC;
		bu_semaphores[i].sem = PAR_UNLOCKED;
	}
#	endif

#	ifdef SGI_4D
	bu_semaphore_sgi_init();
	for( i=0; i < nsemaphores; i++ )  {
		bu_semaphores[i].magic = BU_SEMAPHORE_MAGIC;
		if( (bu_semaphores[i].ltp = usnewlock(bu_lockstuff)) == NULL )  {
			perror("usnewlock");
			fprintf(stderr, "bu_semaphore_init: usnewlock() failed, unable to allocate lock %d\n", i);
			exit(2);
		}
	}
#	endif

#	if SUNOS
	for( i=0; i < nsemaphores; i++ )  {
		bu_semaphores[i].magic = BU_SEMAPHORE_MAGIC;
		if (mutex_init( &bu_semaphores[i].mu, USYNC_THREAD, NULL)) {
			fprintf(stderr, "bu_semaphore_init(): mutex_init() failed on %d\n", i);
			abort();
		}
		
	}
#	endif
#	if HAS_POSIX_THREADS
	for( i=0; i < nsemaphores; i++ )  {
		bu_semaphores[i].magic = BU_SEMAPHORE_MAGIC;
		if (pthread_mutex_init( &bu_semaphores[i].mu,  NULL)) {
			fprintf(stderr, "bu_semaphore_init(): pthread_mutex_init() failed on %d\n", i);
			abort();
		}
	}
#	endif

	/*
	 *  This should be last thing done before returning, so that
	 *  any subroutines called (e.g. bu_calloc()) won't think that
	 *  parallel operation has begun yet, and do acquire/release.
	 */
	bu_nsemaphores = nsemaphores;
#endif	/* PARALLEL */
}

/*
 *			B U _ S E M A P H O R E _ A C Q U I R E
 */
void
bu_semaphore_acquire(unsigned int i)
{
#if !defined(PARALLEL) && !defined(DEFINED_BU_SEMAPHORES)
	return;					/* No support on this hardware */
#else
	if( bu_semaphores == NULL )  {
		/* Semaphores not initialized yet.  Must be non-parallel */
		return;
	}

	BU_CKMAG(bu_semaphores, BU_SEMAPHORE_MAGIC, "bu_semaphore");

	if( i >= bu_nsemaphores )  {
		fprintf(stderr, "bu_semaphore_acquire(%d): semaphore # exceeds max of %d\n",
			i, bu_nsemaphores);
		abort();
	}

	BU_CKMAG(&bu_semaphores[i], BU_SEMAPHORE_MAGIC, "bu_semaphore");

	/*
	 *  Begin vendor-specific initialization sections.
	 */

#	if defined(alliant)	
	(void) lock( &bu_semaphores[i].c );
#	endif

#	ifdef ardent
	{
		register long	*p = &bu_semaphores[i].sem;
		while( SYNCH_Adr = p, !SYNCH_Val )  while( !*p );
	}
#	endif

#	if defined(convex) || defined(__convex__)
	bu_convex_acquire( &bu_semaphores[i].sem );
#	endif

#	ifdef CRAY
	LOCKON( &bu_semaphores[i].p );
#	endif /* CRAY */

#	if defined(n16)
	(void)spin_lock( (LOCK *)&bu_semaphores[i].sem );
#	endif

#	ifdef SGI_4D
	uswsetlock( bu_semaphores[i].ltp, 1000);
#	endif

#	if SUNOS
	if( mutex_lock( &bu_semaphores[i].mu ) )  {
		fprintf(stderr, "bu_semaphore_acquire(): mutex_lock() failed on %d\n", i);
		abort();
	}
#	endif
#	if HAS_POSIX_THREADS
	if( pthread_mutex_lock( &bu_semaphores[i].mu ) )  {
		fprintf(stderr, "bu_semaphore_acquire(): pthread_mutex_lock() failed on %d\n", i);
		abort();
	}
#	endif

#endif
}

/*
 *			B U _ S E M A P H O R E _ R E L E A S E
 */
void
bu_semaphore_release(unsigned int i)
{
#if !defined(PARALLEL) && !defined(DEFINED_BU_SEMAPHORES)
	return;					/* No support on this hardware */
#else
	if( bu_semaphores == NULL )  {
		/* Semaphores not initialized yet.  Must be non-parallel */
		return;
	}

	BU_CKMAG(bu_semaphores, BU_SEMAPHORE_MAGIC, "bu_semaphore");

	if( i >= bu_nsemaphores )  {
		fprintf(stderr, "bu_semaphore_release(%d): semaphore # exceeds max of %d\n",
			i, bu_nsemaphores);
		exit(3);
	}

	BU_CKMAG(&bu_semaphores[i], BU_SEMAPHORE_MAGIC, "bu_semaphore");

	/*
	 *  Begin vendor-specific initialization sections.
	 */

#	if defined(alliant)	
	(void) unlock( &bu_semaphores[i].c );
#	endif

#	ifdef ardent
	bu_semaphores[i].sem = 1;	/* release */
#	endif

#	if defined(convex) || defined(__convex__)
	bu_semaphores[i].sem = 0;	/* release */
#	endif

#	ifdef CRAY
	LOCKOFF( &bu_semaphores[i].p );
#	endif /* CRAY */

#	if defined(n16)
	(void)spin_unlock( (LOCK *)&bu_semaphores[i].sem );
#	endif

#	ifdef SGI_4D
	usunsetlock( bu_semaphores[i].ltp );
#	endif

#	if SUNOS
	if( mutex_unlock( &bu_semaphores[i].mu ) )  {
		fprintf(stderr, "bu_semaphore_acquire(): mutex_unlock() failed on %d\n", i);
		abort();
	}
#	endif
#	if HAS_POSIX_THREADS
	if( pthread_mutex_unlock( &bu_semaphores[i].mu ) )  {
		fprintf(stderr, "bu_semaphore_acquire(): pthread_mutex_unlock() failed on %d\n", i);
		abort();
	}
#	endif
#endif
}
@


1.20
log
@change conf.h to a wrapped config.h
@
text
@d27 1
a27 1
static const char RCSsemaphore[] = "@@(#)$Header: /cvs/brlcad/libbu/semaphore.c,v 1.19 2004/04/05 07:46:16 morrison Exp $ (ARL)";
@


1.19
log
@merge of ansi-6-0-branch into HEAD
@
text
@d27 1
a27 1
static const char RCSsemaphore[] = "@@(#)$Header$ (ARL)";
d30 5
a34 1
#include "conf.h"
@


1.18
log
@merge of windows-6-0-branch into head
@
text
@d235 1
a235 2
bu_semaphore_init( nsemaphores )
unsigned int	nsemaphores;
d343 1
a343 2
bu_semaphore_acquire( i )
unsigned int	i;
d414 1
a414 2
bu_semaphore_release( i )
unsigned int	i;
@


1.17
log
@Added initial support for IBM SP "Scalable Parallel" system running AIX.
Static build fully functional, still needs more work on shared build.
OpenGL support works, but there are issues communicatiing with mged.
@
text
@d27 1
a27 1
static const char RCSsemaphore[] = "@@(#)$Header: /c/CVS/brlcad/libbu/semaphore.c,v 1.16 2002/08/20 17:07:42 jra Exp $ (ARL)";
d82 1
d84 3
@


1.17.6.1
log
@merge from head
@
text
@d27 1
a27 1
static const char RCSsemaphore[] = "@@(#)$Header$ (ARL)";
a81 1
#ifndef WIN32
a82 3
#else
static char		bu_lockfile[] = "C:\\bu_lockXXXXXX";
#endif
@


1.16
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d27 1
a27 1
static const char RCSsemaphore[] = "@@(#)$Header: /c/CVS/brlcad/libbu/semaphore.c,v 1.14 2001/04/27 14:21:37 morrison Exp $ (ARL)";
d137 3
d141 1
@


1.16.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d27 1
a27 1
static const char RCSsemaphore[] = "@@(#)$Header: /c/CVS/brlcad/libbu/semaphore.c,v 1.16 2002/08/20 17:07:42 jra Exp $ (ARL)";
a81 1
#ifndef WIN32
a82 3
#else
static char		bu_lockfile[] = "C:\\bu_lockXXXXXX";
#endif
@


1.16.4.2
log
@sync to HEAD...
@
text
@d27 1
a27 1
static const char RCSsemaphore[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libbu/semaphore.c,v 1.16.4.1 2002/09/26 23:03:52 morrison Exp $ (ARL)";
a140 3
#ifdef __sp3__
#	include	<unistd.h>
#else
a141 1
#endif
@


1.16.2.1
log
@Initial ANSIfication
@
text
@d27 1
a27 1
static const char RCSsemaphore[] = "@@(#)$Header: /c/CVS/brlcad/libbu/semaphore.c,v 1.16 2002/08/20 17:07:42 jra Exp $ (ARL)";
d227 2
a228 1
bu_semaphore_init(unsigned int nsemaphores)
d336 2
a337 1
bu_semaphore_acquire(unsigned int i)
d408 2
a409 1
bu_semaphore_release(unsigned int i)
@


1.16.2.2
log
@sync branch with HEAD
@
text
@d27 1
a27 1
static const char RCSsemaphore[] = "@@(#)$Header$ (ARL)";
a81 1
#ifndef WIN32
a82 3
#else
static char		bu_lockfile[] = "C:\\bu_lockXXXXXX";
#endif
a136 3
#ifdef __sp3__
#	include	<unistd.h>
#else
a137 1
#endif
@


1.15
log
@Converted from K&R to ANSI C - RFH
@
text
@d227 2
a228 1
bu_semaphore_init(unsigned int nsemaphores)
d336 2
a337 1
bu_semaphore_acquire(unsigned int i)
d408 2
a409 1
bu_semaphore_release(unsigned int i)
@


1.14
log
@converted a couple (void *)0 references to NULL for mutex_init calls
@
text
@d27 1
a27 1
static const char RCSsemaphore[] = "@@(#)$Header: /c/CVS/brlcad/libbu/semaphore.c,v 1.13 2001/03/19 22:19:45 butler Exp $ (ARL)";
d227 1
a227 2
bu_semaphore_init( nsemaphores )
unsigned int	nsemaphores;
d335 1
a335 2
bu_semaphore_acquire( i )
unsigned int	i;
d406 1
a406 2
bu_semaphore_release( i )
unsigned int	i;
@


1.13
log
@patches to merge 5.3 into 6.0
@
text
@d27 1
a27 1
static const char RCSsemaphore[] = "@@(#)$Header: /d/CVS/brlcad/libbu/semaphore.c,v 1.12 2000/07/07 05:20:14 cjohnson Exp $ (ARL)";
d306 1
a306 1
		if (mutex_init( &bu_semaphores[i].mu, USYNC_THREAD, (void *)0)) {
d316 1
a316 1
		if (pthread_mutex_init( &bu_semaphores[i].mu,  (void *)0)) {
@


1.12
log
@LINT
@
text
@d27 1
a27 1
static const char RCSsemaphore[] = "@@(#)$Header: /c/CVS/brlcad/libbu/semaphore.c,v 1.11 2000/03/09 03:44:19 cjohnson Exp $ (ARL)";
a71 3
#if ( IRIX == 6 ) && !defined(IRIX64)
typedef __uint64_t k_sigset_t;  /* signal set type */
#endif
@


1.11
log
@Turn on POSIX THREADS parallel support.  Does not currently have anything
that says "go use multiple CPUS"
@
text
@d27 1
a27 1
static char RCSsemaphore[] = "@@(#)$Header: /c/CVS/brlcad/libbu/semaphore.c,v 1.10 1999/03/17 01:32:07 mike Exp $ (ARL)";
d214 1
d217 1
a232 2
	int	i;

d236 2
@


1.11.2.1
log
@Eliminated redefinition of a type from sys/types.h
@
text
@d27 1
a27 1
static char RCSsemaphore[] = "@@(#)$Header: /c/CVS/brlcad/libbu/semaphore.c,v 1.11 2000/03/09 03:44:19 cjohnson Exp $ (ARL)";
d72 3
@


1.10
log
@Fixed PJT problem with semaphore magic numbers.
@
text
@d27 1
a27 1
static char RCSsemaphore[] = "@@(#)$Header: /c/CVS/brlcad/libbu/semaphore.c,v 1.8 1999/03/03 15:23:09 pjt Exp $ (ARL)";
d314 9
d395 7
d461 6
@


1.9
log
@Renamed to BU_SEMAPHORE_MAGIC
@
text
@d50 1
d65 1
d93 1
d104 1
d112 1
d122 1
d136 1
d146 1
d233 1
a233 1
#if !defined(PARALLEL)
d331 3
d386 1
d396 3
d448 1
@


1.8
log
@Added a magic number to struct bu_semaphores.
@
text
@d27 1
a27 1
static char RCSsemaphore[] = "@@(#)$Header: /c/CVS/brlcad/libbu/semaphore.c,v 1.7 1999/03/01 17:13:40 pjt Exp $ (ARL)";
d141 1
a141 1
#define	SEMAPHORE_MAGIC		0x62757365
d244 1
a244 1
		bu_semaphores[i].magic = SEMAPHORE_MAGIC;
d251 1
a251 1
		bu_semaphores[i].magic = SEMAPHORE_MAGIC;
d258 1
a258 1
		bu_semaphores[i].magic = SEMAPHORE_MAGIC;
d265 1
a265 1
		bu_semaphores[i].magic = SEMAPHORE_MAGIC;
d279 1
a279 1
		bu_semaphores[i].magic = SEMAPHORE_MAGIC;
d287 1
a287 1
		bu_semaphores[i].magic = SEMAPHORE_MAGIC;
d298 1
a298 1
		bu_semaphores[i].magic = SEMAPHORE_MAGIC;
d328 1
a328 1
	BU_CKMAG(bu_semaphores, SEMAPHORE_MAGIC, "bu_semaphore");
d336 1
a336 1
	BU_CKMAG(&bu_semaphores[i], SEMAPHORE_MAGIC, "bu_semaphore");
d389 1
a389 1
	BU_CKMAG(bu_semaphores, SEMAPHORE_MAGIC, "bu_semaphore");
d397 1
a397 1
	BU_CKMAG(&bu_semaphores[i], SEMAPHORE_MAGIC, "bu_semaphore");
@


1.7
log
@Fixed a diagnostic in bu_semaphore_release()
@
text
@d27 1
a27 1
static char RCSsemaphore[] = "@@(#)$Header: /c/CVS/brlcad/libbu/semaphore.c,v 1.6 1998/11/05 19:49:36 mike Exp $ (ARL)";
d47 1
d61 1
d88 1
d98 1
d105 1
d114 1
d127 1
d136 1
d141 2
d244 1
d251 1
d258 1
d265 1
d279 1
d287 1
d298 1
d327 3
d333 1
a333 1
		exit(3);
d336 2
d388 3
d396 2
@


1.6
log
@Incorporated HAS_POSIX_THREADS support from Chris Johnson of NetGSI.
Limited testing on FreeBSD only.
@
text
@d27 1
a27 1
static char RCSsemaphore[] = "@@(#)$Header: /c/CVS/brlcad/libbu/semaphore.c,v 1.5 1997/12/24 04:47:30 mike Exp $ (ARL)";
d367 1
a367 1
		fprintf(stderr, "bu_semaphore_acquire(%d): semaphore # exceeds max of %d\n",
@


1.5
log
@IRIX64
@
text
@d27 1
a27 1
static char RCSsemaphore[] = "@@(#)$Header: /m/cad/libbu/RCS/semaphore.c,v 1.4 1997/12/04 02:49:38 mike Exp mike $ (ARL)";
d125 8
d165 6
a170 8
#if 0
	/* Horrible R8000 TFP Bug!!  Regular locks die!! */
	/* XXX This is fixed in Irix 6.0.1, due out in January 95 */
	fprintf(stderr,"\n\n***Horrible R8000 IRIX 6 Bug, switching to software semaphores to bypass.\n\n");
	usconfig(CONF_LOCKTYPE, US_DEBUG);
#else
	usconfig(CONF_LOCKTYPE, US_NODEBUG);
#endif
@


1.4
log
@IRIX64 doesn't need the IRIX6 bug fix.
@
text
@d27 1
a27 1
static char RCSsemaphore[] = "@@(#)$Header: /m/cad/libbu/RCS/semaphore.c,v 1.3 1997/11/22 02:57:48 mike Exp mike $ (ARL)";
d217 2
a218 2
		fprintf(stderr, "bu_semaphore_init(): could not allocate space for %d semaphores of len %d\n",
			nsemaphores, sizeof(struct bu_semaphores));
@


1.3
log
@Initialized global variables to zero, for safety sake.  (Irix 6.4 paranoia)
@
text
@d27 1
a27 1
static char RCSsemaphore[] = "@@(#)$Header: /m/cad/libbu/RCS/semaphore.c,v 1.2 1996/08/27 06:51:34 mike Exp $ (ARL)";
d68 1
a68 1
#if ( IRIX == 6 )
@


1.2
log
@Have to handle non-PARALLEL machines too.
@
text
@d27 1
a27 1
static char RCSsemaphore[] = "@@(#)$Header: /m/cad/libbu/RCS/semaphore.c,v 1.1 1996/08/27 06:18:33 mike Exp mike $ (ARL)";
d190 2
a191 2
static unsigned int		bu_nsemaphores;
static struct bu_semaphores	*bu_semaphores;
@


1.1
log
@Initial revision
@
text
@d27 1
a27 1
static char RCSsemaphore[] = "@@(#)$Header$ (ARL)";
d209 3
d290 1
@
