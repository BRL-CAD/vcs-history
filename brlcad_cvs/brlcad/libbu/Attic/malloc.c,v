head	1.28;
access;
symbols
	ansi-20040405-merged:1.23.2.3
	postmerge-20040405-ansi:1.26
	premerge-20040404-ansi:1.25
	postmerge-autoconf:1.25
	autoconf-freeze:1.24.4.1
	premerge-autoconf:1.25
	ansi-20040316-freeze:1.23.2.1
	postmerge-20040315-windows:1.25
	premerge-20040315-windows:1.24
	windows-20040315-freeze:1.23.4.2
	autoconf-20031203:1.24
	autoconf-20031202:1.24
	autoconf-branch:1.24.0.4
	phong-branch:1.24.0.2
	photonmap-branch:1.23.0.6
	rel-6-1-DP:1.23
	windows-branch:1.23.0.4
	rel-6-0-2:1.20
	ansi-branch:1.23.0.2
	rel-6-0-1-branch:1.20.0.2
	hartley-6-0-post:1.21
	hartley-6-0-pre:1.20
	rel-6-0-1:1.20
	rel-6-0:1.19
	rel-5-4:1.10
	offsite-5-3-pre:1.15
	rel-5-3:1.10
	rel-5-2:1.10
	rel-5-1-branch:1.10.0.2
	rel-5-1:1.10
	rel-5-0:1.7
	rel-5-0-beta:1.7
	rel-4-5:1.7
	ctj-4-5-post:1.4
	ctj-4-5-pre:1.4;
locks; strict;
comment	@ * @;


1.28
date	2004.05.21.18.06.24;	author morrison;	state dead;
branches;
next	1.27;

1.27
date	2004.05.10.15.30.44;	author erikg;	state Exp;
branches;
next	1.26;

1.26
date	2004.04.05.07.46.16;	author morrison;	state Exp;
branches;
next	1.25;

1.25
date	2004.03.16.19.40.49;	author morrison;	state Exp;
branches;
next	1.24;

1.24
date	2003.08.08.08.33.17;	author morrison;	state Exp;
branches
	1.24.4.1;
next	1.23;

1.23
date	2002.08.23.17.25.26;	author jra;	state Exp;
branches
	1.23.2.1
	1.23.4.1
	1.23.6.1;
next	1.22;

1.22
date	2002.08.20.17.07.41;	author jra;	state Exp;
branches;
next	1.21;

1.21
date	2002.08.15.20.54.53;	author hartley;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.16.13.50.38;	author jra;	state Exp;
branches;
next	1.19;

1.19
date	2001.10.12.14.21.29;	author butler;	state Exp;
branches;
next	1.18;

1.18
date	2001.07.11.17.42.26;	author jra;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.26.21.03.41;	author jra;	state Exp;
branches;
next	1.16;

1.16
date	2001.04.20.22.29.06;	author morrison;	state Exp;
branches;
next	1.15;

1.15
date	2000.09.07.14.38.02;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	2000.08.24.00.07.33;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	2000.08.23.23.43.12;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.07.05.20.12;	author cjohnson;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.07.00.37.35;	author cjohnson;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.02.03.47.20;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.02.20.03.00;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.02.04.34.53;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	97.12.24.04.46.07;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	97.11.22.02.58.25;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	97.09.09.21.24.23;	author gdurf;	state Exp;
branches;
next	1.4;

1.4
date	97.04.04.05.22.21;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	96.08.31.04.16.38;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	96.08.28.09.50.17;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	96.08.27.06.18.33;	author mike;	state Exp;
branches;
next	;

1.23.2.1
date	2002.09.19.18.01.12;	author morrison;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2004.03.17.21.16.50;	author morrison;	state Exp;
branches;
next	1.23.2.3;

1.23.2.3
date	2004.04.05.00.50.06;	author morrison;	state Exp;
branches;
next	;

1.23.4.1
date	2002.09.26.23.03.52;	author morrison;	state Exp;
branches;
next	1.23.4.2;

1.23.4.2
date	2004.03.11.23.41.49;	author morrison;	state Exp;
branches;
next	;

1.23.6.1
date	2003.08.26.14.03.28;	author justin;	state Exp;
branches;
next	;

1.24.4.1
date	2004.03.18.18.08.13;	author erikg;	state Exp;
branches;
next	;


desc
@malloc.c.
@


1.28
log
@moved to src/
@
text
@/*
 *			M A L L O C . C
 *
 *  Parallel-protected debugging-enhanced wrapper around system malloc().
 *
 *  The bu_malloc() routines can't use bu_log() because that uses
 *  the bu_vls() routines which depend on bu_malloc().  So it goes direct
 *  to stderr, semaphore protected.
 *
 *  Functions -
 *	bu_malloc	Allocate storage, with visibility & checking
 *	bu_free		Similarly, free storage
 *	bu_realloc	Reallocate storage, with visibility & checking
 *	bu_calloc	Allocate zero'ed storage
 *	bu_prmem	When debugging, print memory map
 *	bu_strdup	Duplicate a string in dynamic memory
 *	bu_malloc_len_roundup	Optimize sizing of malloc() requests
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
 */
#ifndef lint
static const char RCSmalloc[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libbu/malloc.c,v 1.27 2004/05/10 15:30:44 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
# include <string.h>
#else
# include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "bu.h"

int	bu_debug = 0;

/* These counters are not semaphore-protected, and thus are only estimates */
long	bu_n_malloc = 0;
long	bu_n_free = 0;
long	bu_n_realloc = 0;

#define MDB_MAGIC	0x12348969
struct memdebug {
	long		magic;		/* corruption can be everywhere */
	genptr_t	mdb_addr;
	const char	*mdb_str;
	int		mdb_len;
};
static struct memdebug	*bu_memdebug = (struct memdebug *)NULL;
static struct memdebug	*bu_memdebug_lowat = (struct memdebug *)NULL;
static size_t		bu_memdebug_len = 0;
#define MEMDEBUG_NULL	((struct memdebug *)0)

const char bu_strdup_message[] = "bu_strdup string";
extern const char bu_vls_message[];	/* from vls.c */

#ifdef WIN32
char *sbrk(i)
{
	return( (char *)0 );
}
#endif
/*
 *			B U _ M E M D E B U G _ A D D
 *
 *  Add another entry to the memory debug table
 */
HIDDEN void
bu_memdebug_add(char *ptr, unsigned int cnt, const char *str)
{
	register struct memdebug *mp;
top:
	bu_semaphore_acquire( BU_SEM_SYSCALL );
	if( bu_memdebug )  {
		mp = &bu_memdebug[bu_memdebug_len-1];
		if( bu_memdebug_lowat > bu_memdebug &&
		    bu_memdebug_lowat < mp )  {
		    	mp = bu_memdebug_lowat;
		} else {
			bu_memdebug_lowat = mp;
		}
again:
		for( ; mp >= bu_memdebug; mp-- )  {
			/* Search for an empty slot */
			if( mp->mdb_len > 0 )  continue;
			mp->magic = MDB_MAGIC;
			mp->mdb_addr = ptr;
			mp->mdb_len = cnt;
			mp->mdb_str = str;
			bu_memdebug_lowat = mp-1;
			bu_semaphore_release( BU_SEM_SYSCALL );
			return;
		}
		/* Didn't find a slot.  If started in middle, go again */
		mp = &bu_memdebug[bu_memdebug_len-1];
		if( bu_memdebug_lowat != mp )  {
			bu_memdebug_lowat = mp;
			goto again;
		}
	}

	/* Need to make more slots */
	if( bu_memdebug_len <= 0 )  {
		bu_memdebug_len = 5120-2;
		bu_memdebug = (struct memdebug *)calloc(
			bu_memdebug_len, sizeof(struct memdebug) );
		if( bu_memdebug == (struct memdebug *)0 )
			bu_bomb("bu_memdebug_add() malloc failure\n");
	} else {
		size_t	old_len = bu_memdebug_len;
		bu_memdebug_len *= 16;
		bu_memdebug = (struct memdebug *)realloc(
			(char *)bu_memdebug,
			sizeof(struct memdebug) * bu_memdebug_len );
		if( bu_memdebug == (struct memdebug *)0 )
			bu_bomb("bu_memdebug_add() malloc failure\n");
		bzero( (char *)&bu_memdebug[old_len],
			(bu_memdebug_len-old_len) * sizeof(struct memdebug) );
	}
	bu_semaphore_release( BU_SEM_SYSCALL );

	goto top;
}

/*
 *			B U _ M E M D E B U G _ C H E C K
 *
 *  Check an entry against the memory debug table, based upon it's address.
 */
HIDDEN struct memdebug *
bu_memdebug_check(register char *ptr, const char *str)
{
	register struct memdebug *mp = &bu_memdebug[bu_memdebug_len-1];
	register long	*ip;

	if( bu_memdebug == (struct memdebug *)0 )  {
		bu_semaphore_acquire(BU_SEM_SYSCALL);
		fprintf(stderr,"bu_memdebug_check(x%lx, %s)  no memdebug table yet\n",
			(long)ptr, str);
		bu_semaphore_release(BU_SEM_SYSCALL);
		return MEMDEBUG_NULL;
	}
	for( ; mp >= bu_memdebug; mp-- )  {
		if( !mp->magic )  continue;
		if( mp->magic != MDB_MAGIC )  bu_bomb("bu_memdebug_check() malloc tracing table corrupted!\n");
		if( mp->mdb_len <= 0 )  continue;
		if( mp->mdb_addr != ptr )  continue;
		ip = (long *)(ptr+mp->mdb_len-sizeof(long));
		if( *ip != MDB_MAGIC )  {
			bu_semaphore_acquire(BU_SEM_SYSCALL);
			fprintf(stderr,"ERROR bu_memdebug_check(x%lx, %s) %s, barrier word corrupted!\nbarrier at x%lx was=x%lx s/b=x%x, len=%d\n",
				(long)ptr, str, mp->mdb_str,
				(long)ip, *ip, MDB_MAGIC, mp->mdb_len);
			bu_semaphore_release(BU_SEM_SYSCALL);
			bu_bomb("bu_memdebug_check() memory corruption\n");
		}
		return(mp);		/* OK */
	}
	return MEMDEBUG_NULL;
}

/*
 *			B U _ M A L L O C
 *
 *  This routine only returns on successful allocation.
 *  We promise never to return a NULL pointer; caller doesn't have to check.
 *  Failure results in bu_bomb() being called.
 */
genptr_t
bu_malloc(unsigned int cnt, const char *str)
{
	register genptr_t ptr;

	if( cnt == 0 )  {
		fprintf(stderr,"ERROR: bu_malloc count=0 %s\n", str );
		bu_bomb("ERROR: bu_malloc(0)\n");
	}

	if( cnt < sizeof( int ) ) {
		cnt = sizeof( int );
	}

	if( bu_debug&BU_DEBUG_MEM_CHECK )  {
		/* Pad, plus full int for magic number */
		cnt = (cnt+2*sizeof(long)-1)&(~(sizeof(long)-1));
	}

#if defined(MALLOC_NOT_MP_SAFE)
	bu_semaphore_acquire( BU_SEM_SYSCALL );
#endif
	ptr = malloc(cnt);
	if( ptr==(char *)0 || bu_debug&BU_DEBUG_MEM_LOG )  {
		fprintf(stderr, "%8lx malloc%7d %s\n", (long)ptr, cnt, str);
	}
#if defined(MALLOC_NOT_MP_SAFE)
	bu_semaphore_release( BU_SEM_SYSCALL );
#endif

	if( ptr==(char *)0 )  {
		fprintf(stderr,"bu_malloc: Insufficient memory available, sbrk(0)=x%lx\n", (long)sbrk(0));
		bu_bomb("bu_malloc: malloc failure");
	}
	if( bu_debug&BU_DEBUG_MEM_CHECK )  {
		bu_memdebug_add( ptr, cnt, str );

		/* Install a barrier word at the end of the dynamic arena */
		/* Correct location depends on 'cnt' being rounded up, above */

		*((long *)(((char *)ptr)+cnt-sizeof(long))) = MDB_MAGIC;
	}
	bu_n_malloc++;
	return(ptr);
}

/*
 *			B U _ F R E E
 */
void
bu_free(genptr_t ptr, const char *str)
{
	if(bu_debug&BU_DEBUG_MEM_LOG) {
		bu_semaphore_acquire(BU_SEM_SYSCALL);
		fprintf(stderr, "%8lx free          %s\n", (long)ptr, str);
		bu_semaphore_release(BU_SEM_SYSCALL);
	}
	if(ptr == (char *)0 || ptr == (char *)(-1L) )  {
		fprintf(stderr,"%8lx free ERROR %s\n", (long)ptr, str);
		return;
	}
	if( bu_debug&BU_DEBUG_MEM_CHECK )  {
		struct memdebug	*mp;
		if( (mp = bu_memdebug_check( ptr, str )) == MEMDEBUG_NULL )  {
			fprintf(stderr,"ERROR bu_free(x%lx, %s) pointer bad, or not allocated with bu_malloc!  Ignored.\n",
				(long)ptr, str);
			return;
		} else {
			mp->mdb_len = 0;	/* successful delete */
		}
	}

#if defined(MALLOC_NOT_MP_SAFE)
	bu_semaphore_acquire(BU_SEM_SYSCALL);
#endif
/* Windows does not like */
#ifndef WIN32
	*((int *)ptr) = -1;	/* zappo! */
#endif
	free(ptr);
#if defined(MALLOC_NOT_MP_SAFE)
	bu_semaphore_release(BU_SEM_SYSCALL);
#endif
	bu_n_free++;
}

/*
 *			B U _ R E A L L O C
 *
 *  bu_malloc()/bu_free() compatible wrapper for realloc().
 *
 *  While the string 'str' is provided for the log messages, don't
 *  disturb the mdb_str value, so that this storage allocation can be
 *  tracked back to it's original creator.
 */
genptr_t
bu_realloc(register genptr_t ptr, unsigned int cnt, const char *str)
{
	struct memdebug		*mp=NULL;
	char	*original_ptr = ptr;

	if ( ! ptr ) {
	    /* This is so we are compatible with system realloc.
	     * It seems like an odd behaviour, but some non-BRLCAD
	     * code relies on this.
	     */
	    return bu_malloc(cnt, str);
	}

	if( bu_debug&BU_DEBUG_MEM_CHECK )  {
		if( ptr && (mp = bu_memdebug_check( ptr, str )) == MEMDEBUG_NULL )  {
			fprintf(stderr,"%8lx realloc%6d %s ** barrier check failure\n",
				(long)ptr, cnt, str );
		}
		/* Pad, plus full long for magic number */
		cnt = (cnt+2*sizeof(long)-1)&(~(sizeof(long)-1));
	}

#if defined(MALLOC_NOT_MP_SAFE)
	bu_semaphore_acquire(BU_SEM_SYSCALL);
#endif
	ptr = realloc(ptr,cnt);
#if defined(MALLOC_NOT_MP_SAFE)
	bu_semaphore_release(BU_SEM_SYSCALL);
#endif

	if( ptr==(char *)0 || bu_debug&BU_DEBUG_MEM_LOG )  {
		bu_semaphore_acquire(BU_SEM_SYSCALL);
		fprintf(stderr,"%8lx realloc%6d %s %s\n", (long)ptr, cnt, str,
			ptr == original_ptr ? "[grew in place]" : "[moved]" );
		bu_semaphore_release(BU_SEM_SYSCALL);
	}
	if( ptr==(char *)0 && cnt > 0 )  {
		fprintf(stderr,"bu_realloc: Insufficient memory available, sbrk(0)=x%lx\n", (long)sbrk(0));
		bu_bomb("bu_realloc: malloc failure");
	}
	if( bu_debug&BU_DEBUG_MEM_CHECK && ptr )  {
		/* Even if ptr didn't change, need to update cnt & barrier */
		bu_semaphore_acquire(BU_SEM_SYSCALL);
		mp->mdb_addr = ptr;
		mp->mdb_len = cnt;

		/* Install a barrier word at the new end of the dynamic arena */
		/* Correct location depends on 'cnt' being rounded up, above */
		*((long *)(((char *)ptr)+cnt-sizeof(long))) = MDB_MAGIC;
		bu_semaphore_release(BU_SEM_SYSCALL);
	}
	bu_n_realloc++;
	return(ptr);
}

/*
 *			B U _ C A L L O C
 */
genptr_t
bu_calloc(unsigned int nelem, unsigned int elsize, const char *str)
{
	unsigned	len;
	genptr_t	ret;

	len = nelem*elsize;
	ret = bu_malloc( len, str );
	bzero( ret, len );
	return ret;
}

/*
 *			B U _ P R M E M
 * 
 *  Print map of memory currently in use.
 */
void
bu_prmem(const char *str)
{
	register struct memdebug *mp;
	register long *ip;

	fprintf(stderr,"\nbu_prmem(): dynamic memory use (%s)\n", str);
	if( (bu_debug&BU_DEBUG_MEM_CHECK) == 0 )  {
		fprintf(stderr,"\tMemory debugging is now OFF\n");
	}
	fprintf(stderr,"\t%ld elements in memdebug table\n Address Length Purpose\n",
		(long)bu_memdebug_len);
	if( bu_memdebug_len <= 0 )  return;

	mp = &bu_memdebug[bu_memdebug_len-1];
	for( ; mp >= bu_memdebug; mp-- )  {
		if( !mp->magic )  continue;
		if( mp->magic != MDB_MAGIC )  bu_bomb("bu_memdebug_check() malloc tracing table corrupted!\n");
		if( mp->mdb_len <= 0 )  continue;
		ip = (long *)(((char *)mp->mdb_addr)+mp->mdb_len-sizeof(long));
		if( mp->mdb_str == bu_strdup_message )  {
			fprintf(stderr,"%8lx %6d bu_strdup: \"%s\"\n",
				(long)(mp->mdb_addr), mp->mdb_len,
				((char *)mp->mdb_addr) );
		} else if( mp->mdb_str == bu_vls_message )  {
			fprintf(stderr,"%8lx %6d bu_vls: \"%s\"\n",
				(long)(mp->mdb_addr), mp->mdb_len,
				((char *)mp->mdb_addr) );
		} else {
			fprintf(stderr,"%8lx %6d %s\n",
				(long)(mp->mdb_addr), mp->mdb_len,
				mp->mdb_str);
		}
		if( *ip != MDB_MAGIC )  {
			fprintf(stderr,"\tCorrupted end marker was=x%lx\ts/b=x%x\n",
				*ip, MDB_MAGIC);
		}
	}
}

/*
 *			B U _ S T R D U P
 *
 * Given a string, allocate enough memory to hold it using bu_malloc(),
 * duplicate the strings, returns a pointer to the new string.
 */
char *
bu_strdup(register const char *cp)
{
	register char	*base;
	register size_t	len;

	len = strlen( cp )+2;
	base = bu_malloc( len, bu_strdup_message );

	if(bu_debug&BU_DEBUG_MEM_LOG) {
		bu_semaphore_acquire(BU_SEM_SYSCALL);
		fprintf(stderr, "%8lx strdup%7d \"%s\"\n", (long)base, len, cp );
		bu_semaphore_release(BU_SEM_SYSCALL);
	}

	memcpy( base, cp, len );
	return(base);
}

/*
 *			B U _ D I R N A M E
 *
 *  Given a filesystem pathname, return a pointer to a dynamic string
 *  which is the parent directory of that file/directory.
 *
 *	/usr/dir/file	/usr/dir
 *	/usr/dir/	/usr
 *	/usr/file	/usr
 *	/usr/		/
 *	/usr		/
 *	/		/
 *	.		.
 *	..		.
 *	usr		.
 *	a/b		a
 *	a/		.
 *	../a/b		../a
 */
char *
bu_dirname(const char *cp)
{
	char	*ret;
	char	*slash;
	int	len;

	/* Special cases */
	if( cp == NULL )  return bu_strdup(".");
	if( strcmp( cp, "/" ) == 0 )
		return bu_strdup("/");
	if( strcmp( cp, "." ) == 0 ||
	    strcmp( cp, ".." ) == 0 ||
	    strrchr(cp, '/') == NULL )
		return bu_strdup(".");

	/* Make a duplicate copy of the string, and shorten it in place */
	ret = bu_strdup(cp);

	/* A trailing slash doesn't count */
	len = strlen(ret);
	if( ret[len-1] == '/' )  ret[len-1] = '\0';

	/* If no slashes remain, return "." */
	if( (slash = strrchr(ret, '/')) == NULL )  {
		bu_free( ret, "bu_dirname" );
		return bu_strdup(".");
	}

	/* Remove trailing slash, unless it's at front */
	if( slash == ret )
		ret[1] = '\0';		/* ret == "/" */
	else
		*slash = '\0';

	return ret;
}

/*
 *  			B U _ M A L L O C _ L E N _ R O U N D U P
 *  
 *  On systems with the CalTech malloc(), the amount of storage
 *  ACTUALLY ALLOCATED is the amount requested rounded UP to the
 *  nearest power of two.  For structures which are acquired and
 *  released often, this works well, but for structures which will
 *  remain unchanged for the duration of the program, this wastes
 *  as much as 50% of the address space (and usually memory as well).
 *  Here, we round up a byte size to the nearest power of two,
 *  leaving off the malloc header, so as to ask for storage without
 *  wasting any.
 *  
 *  On systems with the traditional malloc(), this strategy will just
 *  consume the memory in somewhat larger chunks, but overall little
 *  unused memory will be consumed.
 */
int
bu_malloc_len_roundup(register int nbytes)
{
#if !defined(HAVE_CALTECH_MALLOC)
	return(nbytes);
#else
	static int pagesz;
	register int n;
	register int amt;

	if (pagesz == 0)
		pagesz = getpagesize();

#define OVERHEAD	(4*sizeof(unsigned char) + \
			2*sizeof(unsigned short) + \
			sizeof(unsigned int) )
	n = pagesz - OVERHEAD;
	if (nbytes <= n)
		return(n);
	amt = pagesz;

	while (nbytes > amt + n) {
		amt <<= 1;
	}
	return(amt-OVERHEAD-sizeof(int));
#endif
}

/*
 *			B U _ C K _ M A L L O C _ P T R
 *
 *	For a given pointer allocated by bu_malloc(),
 *	Check the magic number stored after the allocation area
 *	when BU_DEBUG_MEM_CHECK is set.
 *
 *	This is the individual version of bu_mem_barriercheck().
 *
 *	returns if pointer good or BU_DEBUG_MEM_CHECK not set,
 *	bombs if memory is corrupted.
 */
void
bu_ck_malloc_ptr(genptr_t ptr, const char *str)
{
	register struct memdebug *mp = &bu_memdebug[bu_memdebug_len-1];
	register long	*ip;


	/* if memory debugging isn't turned on, we have no way
	 * of knowing if the pointer is good or not
	 */
	if ((bu_debug&BU_DEBUG_MEM_CHECK) == 0) return;


	if (ptr == (char *)NULL) {
		fprintf(stderr,"bu_ck_malloc_ptr(x%lx, %s) null pointer\n\n", (long)ptr, str);
		bu_bomb("Goodbye");
	}

	if( bu_memdebug == (struct memdebug *)0 )  {
		fprintf(stderr,"bu_ck_malloc_ptr(x%lx, %s)  no memdebug table yet\n",
			(long)ptr, str);
		/* warning only -- the program is just getting started */
		return;
	}

	for( ; mp >= bu_memdebug; mp-- )  {
		if( !mp->magic )  continue;
		if( mp->magic != MDB_MAGIC )  bu_bomb("bu_ck_malloc_ptr() malloc tracing table corrupted!\n");
		if( mp->mdb_len <= 0 || mp->mdb_addr != ptr )  continue;

		/* Found the relevant entry */
		ip = (long *)(((char *)ptr)+mp->mdb_len-sizeof(long));
		if( *ip != MDB_MAGIC )  {
			fprintf(stderr,"ERROR bu_ck_malloc_ptr(x%lx, %s) barrier word corrupted! was=x%lx s/b=x%x\n",
				(long)ptr, str, (long)*ip, MDB_MAGIC);
			bu_bomb("bu_ck_malloc_ptr\n");
		}
		return;		/* OK */
	}
	fprintf(stderr,"WARNING: bu_ck_malloc_ptr(x%lx, %s)\
	pointer not in table of allocated memory.\n", (long)ptr, str);
}

/*
 *			B U _ M E M _ B A R R I E R C H E C K
 *
 *  Check *all* entries in the memory debug table for barrier word
 *  corruption.
 *  Intended to be called periodicly through an application during debugging.
 *  Has to run single-threaded, to prevent table mutation.
 *
 *  This is the bulk version of bu_ck_malloc_ptr()
 *
 *  Returns -
 *	-1	something is wrong
 *	 0	all is OK;
 */
int
bu_mem_barriercheck(void)
{
	register struct memdebug *mp = &bu_memdebug[bu_memdebug_len-1];
	register long	*ip;

	if( bu_memdebug == (struct memdebug *)0 )  {
		fprintf(stderr,"bu_mem_barriercheck()  no memdebug table yet\n");
		return 0;
	}
	bu_semaphore_acquire( BU_SEM_SYSCALL );
	for( ; mp >= bu_memdebug; mp-- )  {
		if( !mp->magic )  continue;
		if( mp->magic != MDB_MAGIC )  {
			bu_semaphore_release( BU_SEM_SYSCALL );
			fprintf(stderr,"  mp->magic = x%lx, s/b=x%x\n", (long)(mp->magic), MDB_MAGIC );
			bu_bomb("bu_mem_barriercheck() malloc tracing table corrupted!\n");
		}
		if( mp->mdb_len <= 0 )  continue;
		ip = (long *)(((char *)mp->mdb_addr)+mp->mdb_len-sizeof(long));
		if( *ip != MDB_MAGIC )  {
			bu_semaphore_release( BU_SEM_SYSCALL );
			fprintf(stderr,"ERROR bu_mem_barriercheck(x%lx, len=%d) barrier word corrupted!\n\tbarrier at x%lx was=x%lx s/b=x%x %s\n",
				(long)mp->mdb_addr, mp->mdb_len,
				(long)ip, *ip, MDB_MAGIC, mp->mdb_str);
			return -1;	/* FAIL */
		}
	}
	bu_semaphore_release( BU_SEM_SYSCALL );
	return 0;			/* OK */
}
@


1.27
log
@change conf.h to a wrapped config.h
@
text
@d30 1
a30 1
static const char RCSmalloc[] = "@@(#)$Header: /cvs/brlcad/libbu/malloc.c,v 1.26 2004/04/05 07:46:16 morrison Exp $ (ARL)";
@


1.26
log
@merge of ansi-6-0-branch into HEAD
@
text
@d30 1
a30 1
static const char RCSmalloc[] = "@@(#)$Header$ (ARL)";
d33 5
a37 1
#include "conf.h"
@


1.25
log
@merge of windows-6-0-branch into head
@
text
@d80 1
a80 4
bu_memdebug_add( ptr, cnt, str )
char		*ptr;
unsigned int	cnt;
const char	*str;
d142 1
a142 3
bu_memdebug_check( ptr, str )
register char	*ptr;
const char	*str;
d181 1
a181 3
bu_malloc(cnt, str)
unsigned int	cnt;
const char	*str;
d230 1
a230 3
bu_free(ptr,str)
genptr_t	ptr;
const char	*str;
d276 1
a276 4
bu_realloc(ptr, cnt, str)
register genptr_t	ptr;
unsigned int		cnt;
const char		*str;
d335 1
a335 4
bu_calloc( nelem, elsize, str )
unsigned int	nelem;
unsigned int	elsize;
const char	*str;
d352 1
a352 2
bu_prmem(str)
const char *str;
d398 1
a398 2
bu_strdup( cp )
register const char *cp;
d401 1
a401 1
	register int	len;
d436 1
a436 2
bu_dirname( cp )
const char *cp;
d491 1
a491 2
bu_malloc_len_roundup(nbytes)
register int nbytes;
d531 1
a531 3
bu_ck_malloc_ptr( ptr, str )
genptr_t	ptr;
const char	*str;
d588 1
a588 1
bu_mem_barriercheck()
@


1.24
log
@separate setting of malloc length variable to quell compiler warning
@
text
@d30 1
a30 1
static const char RCSmalloc[] = "@@(#)$Header: /c/CVS/brlcad/libbu/malloc.c,v 1.23 2002/08/23 17:25:26 jra Exp $ (ARL)";
d68 6
d264 2
d267 1
@


1.24.4.1
log
@merge from head
@
text
@d30 1
a30 1
static const char RCSmalloc[] = "@@(#)$Header$ (ARL)";
a67 6
#ifdef WIN32
char *sbrk(i)
{
	return( (char *)0 );
}
#endif
a257 2
/* Windows does not like */
#ifndef WIN32
a258 1
#endif
@


1.23
log
@bu_malloc() now mallocs a minimum of "sizeof( int )" bytes to allow for bu_free()'s "zappo"
@
text
@d30 1
a30 1
static const char RCSmalloc[] = "@@(#)$Header: /c/CVS/brlcad/libbu/malloc.c,v 1.22 2002/08/20 17:07:41 jra Exp $ (ARL)";
d346 2
a347 1
	ret = bu_malloc( (len = nelem*elsize), str );
@


1.23.6.1
log
@updated for merging
@
text
@d30 1
a30 1
static const char RCSmalloc[] = "@@(#)$Header: /c/CVS/brlcad/libbu/malloc.c,v 1.24 2003/08/08 08:33:17 morrison Exp $ (ARL)";
d346 1
a346 2
	len = nelem*elsize;
	ret = bu_malloc( len, str );
@


1.23.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d30 1
a30 1
static const char RCSmalloc[] = "@@(#)$Header: /c/CVS/brlcad/libbu/malloc.c,v 1.23 2002/08/23 17:25:26 jra Exp $ (ARL)";
a67 6
#ifdef WIN32
char *sbrk(i)
{
	return( (char *)0 );
}
#endif
a257 2
/* Windows does not like */
#ifndef WIN32
a258 1
#endif
@


1.23.4.2
log
@sync to HEAD...
@
text
@d30 1
a30 1
static const char RCSmalloc[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libbu/malloc.c,v 1.23.4.1 2002/09/26 23:03:52 morrison Exp $ (ARL)";
d355 1
a355 2
	len = nelem*elsize;
	ret = bu_malloc( len, str );
@


1.23.2.1
log
@Initial ANSIfication
@
text
@d30 1
a30 1
static const char RCSmalloc[] = "@@(#)$Header: /c/CVS/brlcad/libbu/malloc.c,v 1.23 2002/08/23 17:25:26 jra Exp $ (ARL)";
d74 4
a77 1
bu_memdebug_add(char *ptr, unsigned int cnt, const char *str)
d139 3
a141 1
bu_memdebug_check(register char *ptr, const char *str)
d180 3
a182 1
bu_malloc(unsigned int cnt, const char *str)
d231 3
a233 1
bu_free(genptr_t ptr, const char *str)
d276 4
a279 1
bu_realloc(register genptr_t ptr, unsigned int cnt, const char *str)
d338 4
a341 1
bu_calloc(unsigned int nelem, unsigned int elsize, const char *str)
d357 2
a358 1
bu_prmem(const char *str)
d404 2
a405 1
bu_strdup(register const char *cp)
d443 2
a444 1
bu_dirname(const char *cp)
d499 2
a500 1
bu_malloc_len_roundup(register int nbytes)
d540 3
a542 1
bu_ck_malloc_ptr(genptr_t ptr, const char *str)
d599 1
a599 1
bu_mem_barriercheck(void)
@


1.23.2.2
log
@sync branch with HEAD
@
text
@d30 1
a30 1
static const char RCSmalloc[] = "@@(#)$Header$ (ARL)";
a67 6
#ifdef WIN32
char *sbrk(i)
{
	return( (char *)0 );
}
#endif
a248 2
/* Windows does not like */
#ifndef WIN32
a249 1
#endif
d331 1
a331 2
	len = nelem*elsize;
	ret = bu_malloc( len, str );
@


1.23.2.3
log
@more quelling of lots of warnings
@
text
@d30 1
a30 1
static const char RCSmalloc[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libbu/malloc.c,v 1.23.2.2 2004/03/17 21:16:50 morrison Exp $ (ARL)";
d401 1
a401 1
	register size_t	len;
@


1.22
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d30 1
a30 1
static const char RCSmalloc[] = "@@(#)$Header: /c/CVS/brlcad/libbu/malloc.c,v 1.20 2002/05/16 13:50:38 jra Exp $ (ARL)";
d190 5
@


1.21
log
@Converted from K&R to ANSI C - RFH
@
text
@d74 4
a77 1
bu_memdebug_add(char *ptr, unsigned int cnt, const char *str)
d139 3
a141 1
bu_memdebug_check(register char *ptr, const char *str)
d180 3
a182 1
bu_malloc(unsigned int cnt, const char *str)
d226 3
a228 1
bu_free(genptr_t ptr, const char *str)
d271 4
a274 1
bu_realloc(register genptr_t ptr, unsigned int cnt, const char *str)
d333 4
a336 1
bu_calloc(unsigned int nelem, unsigned int elsize, const char *str)
d352 2
a353 1
bu_prmem(const char *str)
d399 2
a400 1
bu_strdup(register const char *cp)
d438 2
a439 1
bu_dirname(const char *cp)
d494 2
a495 1
bu_malloc_len_roundup(register int nbytes)
d535 3
a537 1
bu_ck_malloc_ptr(genptr_t ptr, const char *str)
d594 1
a594 1
bu_mem_barriercheck(void)
@


1.20
log
@bu_memdebug_add() wasn't checking the return from realloc() soon enough
@
text
@d30 1
a30 1
static const char RCSmalloc[] = "@@(#)$Header: /c/CVS/brlcad/libbu/malloc.c,v 1.19 2001/10/12 14:21:29 butler Exp $ (ARL)";
d74 1
a74 4
bu_memdebug_add( ptr, cnt, str )
char		*ptr;
unsigned int	cnt;
const char	*str;
d136 1
a136 3
bu_memdebug_check( ptr, str )
register char	*ptr;
const char	*str;
d175 1
a175 3
bu_malloc(cnt, str)
unsigned int	cnt;
const char	*str;
d219 1
a219 3
bu_free(ptr,str)
genptr_t	ptr;
const char	*str;
d262 1
a262 4
bu_realloc(ptr, cnt, str)
register genptr_t	ptr;
unsigned int		cnt;
const char		*str;
d321 1
a321 4
bu_calloc( nelem, elsize, str )
unsigned int	nelem;
unsigned int	elsize;
const char	*str;
d337 1
a337 2
bu_prmem(str)
const char *str;
d383 1
a383 2
bu_strdup( cp )
register const char *cp;
d421 1
a421 2
bu_dirname( cp )
const char *cp;
d476 1
a476 2
bu_malloc_len_roundup(nbytes)
register int nbytes;
d516 1
a516 3
bu_ck_malloc_ptr( ptr, str )
genptr_t	ptr;
const char	*str;
d573 1
a573 1
bu_mem_barriercheck()
@


1.19
log
@Changed so that bu_realloc() on a null pointer works like malloc().
Surprisingly, this matches the behaviour of the system realloc()
@
text
@d30 1
a30 1
static const char RCSmalloc[] = "@@(#)$Header: /c/CVS/brlcad/libbu/malloc.c,v 1.18 2001/07/11 17:42:26 jra Exp $ (ARL)";
d115 2
d123 2
a129 2
	if( bu_memdebug == (struct memdebug *)0 )
		bu_bomb("bu_memdebug_add() malloc failure\n");
@


1.18
log
@Minor fix so that debug prints do not crash on a realloc of 0
@
text
@d30 1
a30 1
static const char RCSmalloc[] = "@@(#)$Header: /c/CVS/brlcad/libbu/malloc.c,v 1.17 2001/06/26 21:03:41 jra Exp $ (ARL)";
d276 8
@


1.17
log
@bu_realloc() now allows a new size of 0
@
text
@d30 1
a30 1
static const char RCSmalloc[] = "@@(#)$Header: /c/CVS/brlcad/libbu/malloc.c,v 1.16 2001/04/20 22:29:06 morrison Exp $ (ARL)";
d278 1
a278 1
		if( (mp = bu_memdebug_check( ptr, str )) == MEMDEBUG_NULL )  {
@


1.16
log
@CONST to const
@
text
@d30 1
a30 1
static const char RCSmalloc[] = "@@(#)$Header: /c/CVS/brlcad/libbu/malloc.c,v 1.15 2000/09/07 14:38:02 mike Exp $ (ARL)";
d300 1
a300 1
	if( ptr==(char *)0 )  {
d304 1
a304 1
	if( bu_debug&BU_DEBUG_MEM_CHECK )  {
@


1.15
log
@
Added malloc counters.
@
text
@d30 1
a30 1
static const char RCSmalloc[] = "@@(#)$Header: /c/CVS/brlcad/libbu/malloc.c,v 1.14 2000/08/24 00:07:33 mike Exp $ (ARL)";
d57 1
a57 1
	CONST char	*mdb_str;
d77 1
a77 1
CONST char	*str;
d139 1
a139 1
CONST char	*str;
d180 1
a180 1
CONST char	*str;
d226 1
a226 1
CONST char	*str;
d272 1
a272 1
CONST char		*str;
d326 1
a326 1
CONST char	*str;
d343 1
a343 1
CONST char *str;
d390 1
a390 1
register CONST char *cp;
d429 1
a429 1
CONST char *cp;
d527 1
a527 1
CONST char	*str;
@


1.14
log
@
Converted logging message from bu_strdup() to match format of malloc/free.
Added quoting to messages from prmem
@
text
@d30 1
a30 1
static const char RCSmalloc[] = "@@(#)$Header: /c/CVS/brlcad/libbu/malloc.c,v 1.13 2000/08/23 23:43:12 mike Exp $ (ARL)";
d48 5
d216 1
d256 1
d315 1
@


1.13
log
@
Allowed debug mem print to actually print the strings in vls and strdup
blocks.
@
text
@d30 1
a30 1
static const char RCSmalloc[] = "@@(#)$Header: /c/CVS/brlcad/libbu/malloc.c,v 1.12 2000/07/07 05:20:12 cjohnson Exp $ (ARL)";
d355 1
a355 1
			fprintf(stderr,"%8lx %6d bu_strdup: %s\n",
d359 1
a359 1
			fprintf(stderr,"%8lx %6d bu_vls: %s\n",
d387 3
d392 1
a392 1
		fprintf(stderr,"bu_strdup(%s) x%lx\n", cp, (long)cp);
a394 3

	len = strlen( cp )+2;
	base = bu_malloc( len, bu_strdup_message );
@


1.12
log
@LINT
@
text
@d30 1
a30 1
static const char RCSmalloc[] = "@@(#)$Header: /c/CVS/brlcad/libbu/malloc.c,v 1.11 2000/07/07 00:37:35 cjohnson Exp $ (ARL)";
d60 3
d169 1
d354 13
a366 2
		fprintf(stderr,"%8lx %6d %s\n",
			(long)(mp->mdb_addr), mp->mdb_len, mp->mdb_str);
d394 1
a394 2
	if( (base = bu_malloc( len, "bu_strdup duplicate string" )) == (char *)0 )
		bu_bomb("bu_strdup:  unable to allocate memory");
@


1.11
log
@LINT
@
text
@d30 1
a30 1
static char RCSmalloc[] = "@@(#)$Header: /c/CVS/brlcad/libbu/malloc.c,v 1.10 2000/03/02 03:47:20 mike Exp $ (ARL)";
@


1.10
log
@
Added bu_dirname()
@
text
@d30 1
a30 1
static char RCSmalloc[] = "@@(#)$Header: /c/CVS/brlcad/libbu/malloc.c,v 1.9 2000/02/02 20:03:00 mike Exp $ (ARL)";
d263 1
a263 1
	struct memdebug		*mp;
@


1.9
log
@Check for MALLOC_NOT_MP_SAFE
@
text
@d30 1
a30 1
static char RCSmalloc[] = "@@(#)$Header: /c/CVS/brlcad/libbu/malloc.c,v 1.8 2000/02/02 04:34:53 mike Exp $ (ARL)";
d384 58
@


1.8
log
@
Fixed bug in trailing magic number checking code.
@
text
@d30 1
a30 1
static char RCSmalloc[] = "@@(#)$Header: /c/CVS/brlcad/libbu/malloc.c,v 1.7 1997/12/24 04:46:07 mike Exp $ (ARL)";
d184 1
d186 1
d191 1
d193 1
d238 1
d240 1
d243 1
d245 1
d275 1
d277 1
d279 1
d281 1
@


1.7
log
@Fixed IRIX64 complaints about fprintf() parameter type not matching
format specifier.  Handled it in a portable way.
@
text
@d30 1
a30 1
static char RCSmalloc[] = "@@(#)$Header: /m/cad/libbu/RCS/malloc.c,v 1.6 1997/11/22 02:58:25 mike Exp mike $ (ARL)";
d263 1
a263 1
		/* Pad, plus full int for magic number */
d337 7
a343 6
		ip = (long *)(((char *)mp->mdb_addr)+mp->mdb_len-sizeof(int));
		fprintf(stderr,"%8lx %6d %s %s\n",
			(long)(mp->mdb_addr), mp->mdb_len, mp->mdb_str,
			*ip!=MDB_MAGIC ? "-BAD-" : "" );
		if( *ip != MDB_MAGIC )
			fprintf(stderr,"\t%lx\t%x\n", *ip, MDB_MAGIC);
@


1.6
log
@Initialized global variables to zero, for safety sake.  (Irix 6.4 paranoia)
@
text
@d30 1
a30 1
static char RCSmalloc[] = "@@(#)$Header: /m/cad/libbu/RCS/malloc.c,v 1.5 1997/09/09 21:24:23 gdurf Exp $ (ARL)";
d138 2
a139 2
		fprintf(stderr,"bu_memdebug_check(x%x, %s)  no memdebug table yet\n",
			ptr, str);
d151 3
a153 3
			fprintf(stderr,"ERROR bu_memdebug_check(x%x, %s) %s, barrier word corrupted!\nbarrier at x%x was=x%x s/b=x%x, len=%d\n",
				ptr, str, mp->mdb_str,
				ip, *ip, MDB_MAGIC, mp->mdb_len);
d187 1
a187 1
		fprintf(stderr, "%8x malloc%7d %s\n", ptr, cnt, str);
d192 1
a192 1
		fprintf(stderr,"bu_malloc: Insufficient memory available, sbrk(0)=x%x\n", sbrk(0));
d216 1
a216 1
		fprintf(stderr, "%8x free          %s\n", ptr, str);
d220 1
a220 1
		fprintf(stderr,"%8x free ERROR %s\n", ptr, str);
d226 2
a227 2
			fprintf(stderr,"ERROR bu_free(x%x, %s) pointer bad, or not allocated with bu_malloc!  Ignored.\n",
				ptr, str);
d260 2
a261 2
			fprintf(stderr,"%8x realloc%6d %s ** barrier check failure\n",
				ptr, cnt, str );
d273 1
a273 1
		fprintf(stderr,"%8x realloc%6d %s %s\n", ptr, cnt, str,
d278 1
a278 1
		fprintf(stderr,"bu_realloc: Insufficient memory available, sbrk(0)=x%x\n", sbrk(0));
d322 1
a322 1
	register int *ip;
d328 2
a329 2
	fprintf(stderr,"\t%d elements in memdebug table\n Address Length Purpose\n",
		bu_memdebug_len);
d337 3
a339 3
		ip = (int *)(((char *)mp->mdb_addr)+mp->mdb_len-sizeof(int));
		fprintf(stderr,"%8x %6d %s %s\n",
			mp->mdb_addr, mp->mdb_len, mp->mdb_str,
d342 1
a342 1
			fprintf(stderr,"\t%x\t%x\n", *ip, MDB_MAGIC);
d361 1
a361 1
		fprintf(stderr,"bu_strdup(%s) x%x\n", cp, cp);
d447 1
a447 1
		fprintf(stderr,"bu_ck_malloc_ptr(x%x, %s) null pointer\n\n", ptr, str);
d452 2
a453 2
		fprintf(stderr,"bu_ck_malloc_ptr(x%x, %s)  no memdebug table yet\n",
			ptr, str);
d466 2
a467 2
			fprintf(stderr,"ERROR bu_ck_malloc_ptr(x%x, %s) barrier word corrupted! was=x%x s/b=x%x\n",
				ptr, str, *ip, MDB_MAGIC);
d472 2
a473 2
	fprintf(stderr,"WARNING: bu_ck_malloc_ptr(x%x, %s)\
	pointer not in table of allocated memory.\n", ptr, str);
d505 1
a505 1
			fprintf(stderr,"  mp->magic = x%x, s/b=x%x\n", mp->magic, MDB_MAGIC );
d512 1
a512 1
			fprintf(stderr,"ERROR bu_mem_barriercheck(x%x, len=%d) barrier word corrupted!\n\tbarrier at x%x was=x%x s/b=x%x %s\n",
d514 1
a514 1
				ip, *ip, MDB_MAGIC, mp->mdb_str);
@


1.5
log
@Changed to size_t (different from int on some machines???)
@
text
@d30 1
a30 1
static char RCSmalloc[] = "@@(#)$Header: /m/cad/libbu/RCS/malloc.c,v 1.4 1997/04/04 05:22:21 mike Exp gdurf $ (ARL)";
d55 2
a56 2
static struct memdebug	*bu_memdebug;
static struct memdebug	*bu_memdebug_lowat;
@


1.4
log
@Made descriptive strings line up on malloc/realloc/free messags.
@
text
@d30 1
a30 1
static char RCSmalloc[] = "@@(#)$Header: /m/cad/libbu/RCS/malloc.c,v 1.3 1996/08/31 04:16:38 mike Exp mike $ (ARL)";
d57 1
a57 1
static int		bu_memdebug_len = 0;
d108 1
a108 1
		int	old_len = bu_memdebug_len;
@


1.3
log
@Changed bu_realloc() to not overwrite original mdb_str
@
text
@d30 1
a30 1
static char RCSmalloc[] = "@@(#)$Header: /m/cad/libbu/RCS/malloc.c,v 1.2 1996/08/28 09:50:17 mike Exp mike $ (ARL)";
d187 1
a187 1
		fprintf(stderr, "%8x malloc%6d %s\n", ptr, cnt, str);
d216 1
a216 1
		fprintf(stderr, "%8x free %s\n", ptr, str);
d338 1
a338 1
		fprintf(stderr,"%8x %6x %s %s\n",
@


1.2
log
@Can't use bu_log() in here.
Also removed several race conditions.
@
text
@d30 1
a30 1
static char RCSmalloc[] = "@@(#)$Header: /m/cad/libbu/RCS/malloc.c,v 1.1 1996/08/27 06:18:33 mike Exp mike $ (ARL)";
d242 6
a285 1
		mp->mdb_str = str;
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
 * Parallel-protected debugging-enhanced wrapper around system malloc().
d6 4
d30 1
a30 1
static char RCSmalloc[] = "@@(#)$Header$ (ARL)";
d50 1
d56 1
d76 7
d86 1
d90 1
d94 6
d104 1
a104 1
		bu_memdebug_len = 510;
d137 2
a138 1
		bu_log("bu_memdebug_check(x%x, %s)  no memdebug table yet\n",
d140 1
d144 2
d150 2
a151 1
			bu_log("ERROR bu_memdebug_check(x%x, %s) %s, barrier word corrupted!\nbarrier at x%x was=x%x s/b=x%x, len=%d\n",
d154 1
a162 33
 *			B U _ M E M D E B U G _ M O V E
 *
 *  realloc() has moved to a new memory block.
 *  Update our notion as well.
 */
HIDDEN void
bu_memdebug_move( old_ptr, new_ptr, new_cnt, new_str )
char	*old_ptr;
char	*new_ptr;
int	new_cnt;
CONST char	*new_str;
{
	register struct memdebug *mp = &bu_memdebug[bu_memdebug_len-1];

	if( bu_memdebug == (struct memdebug *)0 )  {
		bu_log("bu_memdebug_move(x%x, x%x, %d., %s)  no memdebug table yet\n",
			old_ptr, new_ptr, new_cnt, new_str);
		return;
	}
	for( ; mp >= bu_memdebug; mp-- )  {
		if( mp->mdb_len > 0 && (mp->mdb_addr == old_ptr) ) {
			mp->mdb_addr = new_ptr;
			mp->mdb_len = new_cnt;
			mp->mdb_str = new_str;
			return;
		}
	}
	bu_log("bu_memdebug_move(): old memdebug entry not found!\n");
	bu_log(" old_ptr=x%x, new_ptr=x%x, new_cnt=%d., new_str=%s\n",
		old_ptr, new_ptr, new_cnt, new_str );
}

/*
d176 1
a176 1
		bu_log("ERROR: bu_malloc count=0 %s\n", str );
d186 3
a190 2
	if( ptr==(char *)0 || bu_debug&BU_DEBUG_MEM_LOG )
		bu_log("%8x malloc%6d %s\n", ptr, cnt, str);
d192 1
a192 1
		bu_log("bu_malloc: Insufficient memory available, sbrk(0)=x%x\n", sbrk(0));
d214 5
a218 1
	if(bu_debug&BU_DEBUG_MEM_LOG) bu_log("%8x free %s\n", ptr, str);
d220 1
a220 1
		bu_log("%8x free ERROR %s\n", ptr, str);
d226 1
a226 1
			bu_log("ERROR bu_free(x%x, %s) pointer bad, or not allocated with bu_malloc!  Ignored.\n",
d249 1
d253 2
a254 2
		if( bu_memdebug_check( ptr, str ) == MEMDEBUG_NULL )  {
			bu_log("%8x realloc%6d %s ** barrier check failure\n",
d266 2
a267 1
		bu_log("%8x realloc%6d %s %s\n", ptr, cnt, str,
d269 1
d272 1
a272 1
		bu_log("bu_realloc: Insufficient memory available, sbrk(0)=x%x\n", sbrk(0));
d277 4
a280 1
		bu_memdebug_move( original_ptr, ptr, cnt, str );
d282 1
a282 1
		/* Install a barrier word at the end of the dynamic arena */
d285 1
d319 1
a319 1
	bu_log("\nbu_prmem(): dynamic memory use (%s)\n", str);
d321 1
a321 1
		bu_log("\tMemory debugging is now OFF\n");
d323 1
a323 1
	bu_log("\t%d elements in memdebug table\n Address Length Purpose\n",
d329 2
d333 1
a333 1
		bu_log("%8x %6x %s %s\n",
d337 1
a337 1
			bu_log("\t%x\t%x\n", *ip, MDB_MAGIC);
d354 5
a358 1
	if(bu_debug&BU_DEBUG_MEM_LOG) bu_log("bu_strdup(%s) x%x\n", cp, cp);
d442 1
a442 1
		bu_log("bu_ck_malloc_ptr(x%x, %s) null pointer\n\n", ptr, str);
d447 1
a447 1
		bu_log("bu_ck_malloc_ptr(x%x, %s)  no memdebug table yet\n",
d454 2
d458 1
d461 1
a461 1
			bu_log("ERROR bu_ck_malloc_ptr(x%x, %s) barrier word corrupted! was=x%x s/b=x%x\n",
d467 1
a467 1
	bu_log("WARNING: bu_ck_malloc_ptr(x%x, %s)\
d477 1
d492 1
a492 1
		bu_log("bu_mem_barriercheck()  no memdebug table yet\n");
d495 1
d497 6
d506 4
a509 3
			bu_log("ERROR bu_mem_barriercheck(x%x, len=%d) barrier word corrupted!\nbarrier at x%x was=x%x s/b=x%x\n",
				mp->mdb_addr, mp->mdb_len,
				ip, *ip, MDB_MAGIC);
d513 1
@
