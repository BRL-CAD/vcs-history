head	11.18;
access;
symbols
	ansi-20040405-merged:11.14.2.2
	postmerge-20040405-ansi:11.16
	premerge-20040404-ansi:11.15
	postmerge-autoconf:11.15
	autoconf-freeze:11.14.10.2
	premerge-autoconf:11.15
	ansi-20040316-freeze:11.14.2.1
	postmerge-20040315-windows:11.15
	premerge-20040315-windows:11.15
	windows-20040315-freeze:11.14.4.1
	autoconf-20031203:11.14
	autoconf-20031202:11.14
	autoconf-branch:11.14.0.10
	phong-branch:11.14.0.8
	photonmap-branch:11.14.0.6
	rel-6-1-DP:11.14
	windows-branch:11.14.0.4
	rel-6-0-2:11.12
	ansi-branch:11.14.0.2
	rel-6-0-1-branch:11.12.0.2
	hartley-6-0-post:11.13
	hartley-6-0-pre:11.12
	rel-6-0-1:11.12
	rel-6-0:11.12
	rel-5-4:11.11
	offsite-5-3-pre:11.12
	rel-5-3:11.11
	rel-5-2:11.11
	rel-5-1-branch:11.11.0.2
	rel-5-1:11.11
	rel-5-0:11.9
	rel-5-0-beta:11.9
	rel-4-5:11.7
	ctj-4-5-post:11.7
	ctj-4-5-pre:11.7
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.18
date	2004.05.21.18.06.24;	author morrison;	state dead;
branches;
next	11.17;

11.17
date	2004.05.10.15.30.44;	author erikg;	state Exp;
branches;
next	11.16;

11.16
date	2004.04.05.07.46.16;	author morrison;	state Exp;
branches;
next	11.15;

11.15
date	2004.02.02.17.39.07;	author morrison;	state Exp;
branches;
next	11.14;

11.14
date	2002.08.20.17.07.42;	author jra;	state Exp;
branches
	11.14.2.1
	11.14.4.1
	11.14.10.1;
next	11.13;

11.13
date	2002.08.15.20.54.54;	author hartley;	state Exp;
branches;
next	11.12;

11.12
date	2000.07.07.05.20.13;	author cjohnson;	state Exp;
branches;
next	11.11;

11.11
date	2000.03.28.18.55.10;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	2000.03.28.18.04.43;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	99.01.12.16.19.55;	author pjt;	state Exp;
branches;
next	11.8;

11.8
date	98.12.30.01.25.44;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	96.08.31.09.39.29;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	95.09.20.13.51.46;	author pjt;	state Exp;
branches;
next	11.5;

11.5
date	95.09.20.12.11.26;	author pjt;	state Exp;
branches;
next	11.4;

11.4
date	95.09.19.17.44.51;	author pjt;	state Exp;
branches;
next	11.3;

11.3
date	95.07.10.20.16.29;	author pjt;	state Exp;
branches;
next	11.2;

11.2
date	95.04.19.19.05.14;	author pjt;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.05.55;	author mike;	state Rel4_4;
branches;
next	2.6;

2.6
date	94.12.30.16.41.04;	author stay;	state Exp;
branches;
next	2.5;

2.5
date	94.11.01.10.43.53;	author pjt;	state Exp;
branches;
next	2.4;

2.4
date	94.09.26.12.21.10;	author jra;	state Exp;
branches;
next	2.3;

2.3
date	94.09.22.15.34.46;	author pjt;	state Exp;
branches;
next	2.2;

2.2
date	94.09.22.15.27.02;	author pjt;	state Exp;
branches;
next	2.1;

2.1
date	93.03.25.11.03.21;	author pjt;	state Exp;
branches;
next	1.2;

1.2
date	93.03.25.11.00.23;	author pjt;	state Exp;
branches;
next	1.1;

1.1
date	93.01.21.14.32.07;	author pjt;	state zero_1;
branches;
next	;

11.14.2.1
date	2002.09.19.18.01.13;	author morrison;	state Exp;
branches;
next	11.14.2.2;

11.14.2.2
date	2004.03.17.21.16.51;	author morrison;	state Exp;
branches;
next	;

11.14.4.1
date	2004.03.11.23.41.49;	author morrison;	state Exp;
branches;
next	;

11.14.10.1
date	2004.02.12.18.39.19;	author erikg;	state Exp;
branches;
next	11.14.10.2;

11.14.10.2
date	2004.03.15.14.06.17;	author erikg;	state Exp;
branches;
next	;


desc
@
     Routines to insert nodes into a red-black tree

@


11.18
log
@moved to src/
@
text
@/*			R B _ I N S E R T . C
 *
 *		Routines to insert into a red-black tree
 *
 *  Author -
 *	Paul J. Tanenbaum
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1998-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char libbu_rb_insert_RCSid[] = "@@(#) $Header: /n/xoff/cvs/brlcad/libbu/rb_insert.c,v 11.17 2004/05/10 15:30:44 erikg Exp $";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "bu.h"
#include "./rb_internals.h"

/*			_ R B _ I N S E R T ( )
 *
 *	    Insert a node into one linear order of a red-black tree
 *
 *	This function has three parameters: the tree and linear order into
 *	which to insert the new node and the new node itself.  If the node
 *	is equal (modulo the linear order) to a node already in the tree,
 *	_rb_insert() returns 1.  Otherwise, it returns 0.
 */
static int _rb_insert (bu_rb_tree *tree, int order, struct bu_rb_node *new_node)
{
    struct bu_rb_node	*node;
    struct bu_rb_node	*parent;
    struct bu_rb_node	*grand_parent;
    struct bu_rb_node	*y;
    int			(*compare)();
    int			comparison=0xdeadbeef;
    int			direction;
    int			result = 0;


    BU_CKMAG(tree, BU_RB_TREE_MAGIC, "red-black tree");
    BU_RB_CKORDER(tree, order);
    BU_CKMAG(new_node, BU_RB_NODE_MAGIC, "red-black node");

    /*
     *	Initialize the new node
     */
    bu_rb_parent(new_node, order) =
    bu_rb_left_child(new_node, order) =
    bu_rb_right_child(new_node, order) = bu_rb_null(tree);
    bu_rb_size(new_node, order) = 1;
    if (tree -> rbt_debug & BU_RB_DEBUG_OS)
	bu_log("_rb_insert(%x): size(%x, %d)=%d\n",
	    new_node, new_node, order, bu_rb_size(new_node, order));

    /*
     *	Perform vanilla-flavored binary-tree insertion
     */
    parent = bu_rb_null(tree);
    node = bu_rb_root(tree, order);
    compare = bu_rb_order_func(tree, order);
    while (node != bu_rb_null(tree))
    {
	parent = node;
	++bu_rb_size(parent, order);
	if (tree -> rbt_debug & BU_RB_DEBUG_OS)
	    bu_log("_rb_insert(%x): size(%x, %d)=%d\n",
		new_node, parent, order, bu_rb_size(parent, order));
	comparison = (*compare)(bu_rb_data(new_node, order),
				bu_rb_data(node, order));
	if (comparison < 0)
	{
	    if (tree -> rbt_debug & BU_RB_DEBUG_INSERT)
		bu_log("_rb_insert(%x): <_%d <%x>, going left\n",
		    new_node, order, node);
	    node = bu_rb_left_child(node, order);
	}
	else
	{
	    if (tree -> rbt_debug & BU_RB_DEBUG_INSERT)
		bu_log("_rb_insert(%x): >=_%d <%x>, going right\n",
		    new_node, order, node);
	    node = bu_rb_right_child(node, order);
	    if (comparison == 0)
		result = 1;
	}
    }
    bu_rb_parent(new_node, order) = parent;
    if (parent == bu_rb_null(tree))
	bu_rb_root(tree, order) = new_node;
    else if ((*compare)(bu_rb_data(new_node, order),
			bu_rb_data(parent, order)) < 0)
	bu_rb_left_child(parent, order) = new_node;
    else
	bu_rb_right_child(parent, order) = new_node;

    /*
     *	Reestablish the red-black properties, as necessary
     */
    bu_rb_set_color(new_node, order, BU_RB_RED);
    node = new_node;
    parent = bu_rb_parent(node, order);
    grand_parent = bu_rb_parent(parent, order);
    while ((node != bu_rb_root(tree, order))
	&& (bu_rb_get_color(parent, order) == BU_RB_RED))
    {
	if (parent == bu_rb_left_child(grand_parent, order))
	    direction = BU_RB_LEFT;
	else
	    direction = BU_RB_RIGHT;

	y = bu_rb_other_child(grand_parent, order, direction);
	if (bu_rb_get_color(y, order) == BU_RB_RED)
	{
	    bu_rb_set_color(parent, order, BU_RB_BLACK);
	    bu_rb_set_color(y, order, BU_RB_BLACK);
	    bu_rb_set_color(grand_parent, order, BU_RB_RED);
	    node = grand_parent;
	    parent = bu_rb_parent(node, order);
	    grand_parent = bu_rb_parent(parent, order);
	}
	else
	{
	    if (node == bu_rb_other_child(parent, order, direction))
	    {
		node = parent;
		bu_rb_rotate(node, order, direction);
		parent = bu_rb_parent(node, order);
		grand_parent = bu_rb_parent(parent, order);
	    }
	    bu_rb_set_color(parent, order, BU_RB_BLACK);
	    bu_rb_set_color(grand_parent, order, BU_RB_RED);
	    bu_rb_other_rotate(grand_parent, order, direction);
	}
    }
    bu_rb_set_color(bu_rb_root(tree, order), order, BU_RB_BLACK);

    if (tree -> rbt_debug & BU_RB_DEBUG_INSERT)
	bu_log("_rb_insert(%x): comparison = %d, returning %d\n",
	    new_node, comparison, result);

    return (result);
}

/*			B U _ R B _ I N S E R T ( )
 *
 *		Applications interface to _rb_insert()
 *
 *	This function has two parameters: the tree into which to insert
 *	the new node and the contents of the node.  If a uniqueness
 *	requirement would be violated, bu_rb_insert() does nothing but return
 *	a number from the set {-1, -2, ..., -nm_orders} of which the
 *	absolute value is the first order for which a violation exists.
 *	Otherwise, it returns the number of orders for which the new node
 *	was equal to a node already in the tree.
 */
int bu_rb_insert (bu_rb_tree *tree, void *data)
{
    int				nm_orders;
    int				order;
    int				result = 0;
    struct bu_rb_node		*node;
    struct bu_rb_package	*package;
    struct bu_rb_list		*rblp;

    BU_CKMAG(tree, BU_RB_TREE_MAGIC, "red-black tree");

    nm_orders = tree -> rbt_nm_orders;

    /*
     *	Enforce uniqueness
     *
     *	NOTE: The approach is that for each order that requires uniqueness,
     *	    we look for a match.  This is not the most efficient way to do
     *	    things, since _rb_insert() is just going to turn around and
     *	    search the tree all over again.
     */
    for (order = 0; order < nm_orders; ++order)
	if (bu_rb_get_uniqueness(tree, order) &&
	    (bu_rb_search(tree, order, data) != NULL))
	{
	    if (tree -> rbt_debug & BU_RB_DEBUG_UNIQ)
		bu_log("bu_rb_insert(<%x>, <%x>, TBD) will return %d\n",
		    tree, data, -(order + 1));
	    return (-(order + 1));
	}

    /*
     *	Make a new package
     *	and add it to the list of all packages.
     */
    package = (struct bu_rb_package *)
		bu_malloc(sizeof(struct bu_rb_package), "red-black package");
    package -> rbp_node = (struct bu_rb_node **)
		bu_malloc(nm_orders * sizeof(struct bu_rb_node *),
			    "red-black package nodes");
    rblp = (struct bu_rb_list *)
		bu_malloc(sizeof(struct bu_rb_list),
			    "red-black list element");
    rblp -> rbl_magic = BU_RB_LIST_MAGIC;
    rblp -> rbl_package = package;
    BU_LIST_PUSH(&(tree -> rbt_packages.l), rblp);
    package -> rbp_list_pos = rblp;

    /*
     *	Make a new node
     *	and add it to the list of all nodes.
     */
    node = (struct bu_rb_node *)
		bu_malloc(sizeof(struct bu_rb_node), "red-black node");
    node -> rbn_parent = (struct bu_rb_node **)
		bu_malloc(nm_orders * sizeof(struct bu_rb_node *),
			    "red-black parents");
    node -> rbn_left = (struct bu_rb_node **)
		bu_malloc(nm_orders * sizeof(struct bu_rb_node *),
			    "red-black left children");
    node -> rbn_right = (struct bu_rb_node **)
		bu_malloc(nm_orders * sizeof(struct bu_rb_node *),
			    "red-black right children");
    node -> rbn_color = (char *)
		bu_malloc((size_t) ceil((double) (nm_orders / 8.0)),
			    "red-black colors");
    node -> rbn_size = (int *)
		bu_malloc(nm_orders * sizeof(int),
			    "red-black subtree sizes");
    node -> rbn_package = (struct bu_rb_package **)
		bu_malloc(nm_orders * sizeof(struct bu_rb_package *),
			    "red-black packages");
    rblp = (struct bu_rb_list *)
		bu_malloc(sizeof(struct bu_rb_list),
			    "red-black list element");
    rblp -> rbl_magic = BU_RB_LIST_MAGIC;
    rblp -> rbl_node = node;
    BU_LIST_PUSH(&(tree -> rbt_nodes.l), rblp);
    node -> rbn_list_pos = rblp;

    /*
     *	Fill in the package
     */
    package -> rbp_magic = BU_RB_PKG_MAGIC;
    package -> rbp_data = data;
    for (order = 0; order < nm_orders; ++order)
	(package -> rbp_node)[order] = node;

    /*
     *	Fill in the node
     */
    node -> rbn_magic = BU_RB_NODE_MAGIC;
    node -> rbn_tree = tree;
    for (order = 0; order < nm_orders; ++order)
	(node -> rbn_package)[order] = package;
    node -> rbn_pkg_refs = nm_orders;

    /*
     *	If the tree was empty, install this node as the root
     *	and give it a null parent and null children
     */
    if (bu_rb_root(tree, 0) == bu_rb_null(tree))
	for (order = 0; order < nm_orders; ++order)
	{
	    bu_rb_root(tree, order) = node;
	    bu_rb_parent(node, order) =
	    bu_rb_left_child(node, order) =
	    bu_rb_right_child(node, order) = bu_rb_null(tree);
	    bu_rb_set_color(node, order, BU_RB_BLACK);
	    bu_rb_size(node, order) = 1;
	    if (tree -> rbt_debug & BU_RB_DEBUG_OS)
		bu_log("bu_rb_insert(<%x>, <%x>, <%x>): size(%x, %d)=%d\n",
		    tree, data, node, node, order, bu_rb_size(node, order));
	}
    /*	Otherwise, insert the node into the tree */
    else
    {
	for (order = 0; order < nm_orders; ++order)
	    result += _rb_insert(tree, order, node);
	if (tree -> rbt_debug & BU_RB_DEBUG_UNIQ)
	    bu_log("bu_rb_insert(<%x>, <%x>, <%x>) will return %d\n",
		tree, data, node, result);
    }

    ++(tree -> rbt_nm_nodes);
    bu_rb_current(tree) = node;
    return (result);
}

/*		        _ R B _ S E T _ U N I Q ( )
 *
 *	    Raise or lower the uniqueness flag for one linear order
 *			    of a red-black tree
 *
 *	This function has three parameters: the tree, the order for which
 *	to modify the flag, and the new value for the flag.  _rb_set_uniq()
 *	sets the specified flag to the specified value and returns the
 *	previous value of the flag.
 */
static int _rb_set_uniq (bu_rb_tree *tree, int order, int new_value)
{
    int	prev_value;

    BU_CKMAG(tree, BU_RB_TREE_MAGIC, "red-black tree");
    BU_RB_CKORDER(tree, order);
    new_value = (new_value != 0);

    prev_value = bu_rb_get_uniqueness(tree, order);
    bu_rb_set_uniqueness(tree, order, new_value);
    return (prev_value);
}

/*		         B U _ R B _ U N I Q _ O N ( )
 *		        B U _ R B _ U N I Q _ O F F ( )
 *
 *		Applications interface to _rb_set_uniq()
 *
 *	These functions have two parameters: the tree and the order for
 *	which to require uniqueness/permit nonuniqueness.  Each sets the
 *	specified flag to the specified value and returns the previous
 *	value of the flag.
 */
int bu_rb_uniq_on (bu_rb_tree *tree, int order)
{
    return (_rb_set_uniq(tree, order, 1));
}

int bu_rb_uniq_off (bu_rb_tree *tree, int order)
{
    return (_rb_set_uniq(tree, order, 0));
}

/*		         B U _ R B _ I S _ U N I Q ( )
 *
 *	  Query the uniqueness flag for one order of a red-black tree
 *
 *	This function has two parameters: the tree and the order for
 *	which to query uniqueness.
 */
int bu_rb_is_uniq (bu_rb_tree *tree, int order)
{
    BU_CKMAG(tree, BU_RB_TREE_MAGIC, "red-black tree");
    BU_RB_CKORDER(tree, order);

    return(bu_rb_get_uniqueness(tree, order));
}

/*		        B U _ R B _ S E T _ U N I Q V ( )
 *
 *	    Set the uniqueness flags for all the linear orders
 *			    of a red-black tree
 *
 *	This function has two parameters: the tree and a bitv_t
 *	encoding the flag values.  bu_rb_set_uniqv() sets the flags
 *	according to the bits in flag_rep.  For example, if
 *	flag_rep = 1011_2, then the first, second, and fourth
 *	orders are specified unique, and the third is specified
 *	not-necessarily unique.
 */
void bu_rb_set_uniqv (bu_rb_tree *tree, bitv_t flag_rep)
{
    int	nm_orders;
    int	order;

    BU_CKMAG(tree, BU_RB_TREE_MAGIC, "red-black tree");

    nm_orders = tree -> rbt_nm_orders;
    for (order = 0; order < nm_orders; ++order)
	bu_rb_set_uniqueness(tree, order, 0);
    
    for (order = 0; (flag_rep != 0) && (order < nm_orders); flag_rep >>= 1,
							    ++order)
	if (flag_rep & 0x1)
	    bu_rb_set_uniqueness(tree, order, 1);

    if (flag_rep != 0)
	bu_log("bu_rb_set_uniqv(): Ignoring bits beyond rightmost %d\n",
	    nm_orders);
}

/*		    _ R B _ S E T _ U N I Q _ A L L ( )
 *
 *	    Raise or lower the uniqueness flags for all the linear orders
 *			    of a red-black tree
 *
 *	This function has two parameters: the tree, and the new value
 *	for all the flags.
 */
static void _rb_set_uniq_all (bu_rb_tree *tree, int new_value)
{
    int	nm_orders;
    int	order;

    BU_CKMAG(tree, BU_RB_TREE_MAGIC, "red-black tree");
    new_value = (new_value != 0);

    nm_orders = tree -> rbt_nm_orders;
    for (order = 0; order < nm_orders; ++order)
	bu_rb_set_uniqueness(tree, order, new_value);
}

/*		     B U _ R B _ U N I Q _ A L L _ O N ( )
 *		    B U _ R B _ U N I Q _ A L L _ O F F ( )
 *
 *	      Applications interface to _rb_set_uniq_all()
 *
 *	These functions have one parameter: the tree for which to
 *	require uniqueness/permit nonuniqueness.
 */
void bu_rb_uniq_all_on (bu_rb_tree *tree)
{
    _rb_set_uniq_all(tree, 1);
}

void bu_rb_uniq_all_off (bu_rb_tree *tree)
{
    _rb_set_uniq_all(tree, 0);
}
@


11.17
log
@change conf.h to a wrapped config.h
@
text
@d22 1
a22 1
static const char libbu_rb_insert_RCSid[] = "@@(#) $Header: /cvs/brlcad/libbu/rb_insert.c,v 11.16 2004/04/05 07:46:16 morrison Exp $";
@


11.16
log
@merge of ansi-6-0-branch into HEAD
@
text
@d22 1
a22 1
static const char libbu_rb_insert_RCSid[] = "@@(#) $Header$";
d25 5
a29 1
#include "conf.h"
@


11.15
log
@update copyright to include span through 2003
@
text
@d22 1
a22 1
static const char libbu_rb_insert_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_insert.c,v 11.14 2002/08/20 17:07:42 jra Exp $";
d42 1
a42 6
static int _rb_insert (tree, order, new_node)

bu_rb_tree		*tree;
int			order;
struct bu_rb_node	*new_node;

d170 1
a170 5
int bu_rb_insert (tree, data)

bu_rb_tree	*tree;
void		*data;

d309 1
a309 6
static int _rb_set_uniq (tree, order, new_value)

bu_rb_tree	*tree;
int		order;
int		new_value;

d332 1
a332 5
int bu_rb_uniq_on (tree, order)

bu_rb_tree	*tree;
int		order;

d337 1
a337 5
int bu_rb_uniq_off (tree, order)

bu_rb_tree	*tree;
int	order;

d349 1
a349 5
int bu_rb_is_uniq (tree, order)

bu_rb_tree	*tree;
int		order;

d369 1
a369 5
void bu_rb_set_uniqv (tree, flag_rep)

bu_rb_tree	*tree;
bitv_t		flag_rep;

d398 1
a398 5
static void _rb_set_uniq_all (tree, new_value)

bu_rb_tree	*tree;
int		new_value;

d419 1
a419 4
void bu_rb_uniq_all_on (tree)

bu_rb_tree	*tree;

d424 1
a424 4
void bu_rb_uniq_all_off (tree)

bu_rb_tree	*tree;

@


11.14
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1998 by the United States Army
d22 1
a22 1
static const char libbu_rb_insert_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_insert.c,v 11.12 2000/07/07 05:20:13 cjohnson Exp $";
@


11.14.4.1
log
@sync to HEAD...
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d22 1
a22 1
static const char libbu_rb_insert_RCSid[] = "@@(#) $Header: /n/cad/c/CVS/brlcad/libbu/rb_insert.c,v 11.15 2004/02/02 17:39:07 morrison Exp $";
@


11.14.10.1
log
@merge from HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d22 1
a22 1
static const char libbu_rb_insert_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_insert.c,v 11.15 2004/02/02 17:39:07 morrison Exp $";
@


11.14.10.2
log
@merge from head
@
text
@d22 1
a22 1
static const char libbu_rb_insert_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_insert.c,v 11.14.10.1 2004/02/12 18:39:19 erikg Exp $";
@


11.14.2.1
log
@Initial ANSIfication
@
text
@d22 1
a22 1
static const char libbu_rb_insert_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_insert.c,v 11.14 2002/08/20 17:07:42 jra Exp $";
d42 6
a47 1
static int _rb_insert (bu_rb_tree *tree, int order, struct bu_rb_node *new_node)
d175 5
a179 1
int bu_rb_insert (bu_rb_tree *tree, void *data)
d318 6
a323 1
static int _rb_set_uniq (bu_rb_tree *tree, int order, int new_value)
d346 5
a350 1
int bu_rb_uniq_on (bu_rb_tree *tree, int order)
d355 5
a359 1
int bu_rb_uniq_off (bu_rb_tree *tree, int order)
d371 5
a375 1
int bu_rb_is_uniq (bu_rb_tree *tree, int order)
d395 5
a399 1
void bu_rb_set_uniqv (bu_rb_tree *tree, bitv_t flag_rep)
d428 5
a432 1
static void _rb_set_uniq_all (bu_rb_tree *tree, int new_value)
d453 4
a456 1
void bu_rb_uniq_all_on (bu_rb_tree *tree)
d461 4
a464 1
void bu_rb_uniq_all_off (bu_rb_tree *tree)
@


11.14.2.2
log
@sync branch with HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d22 1
a22 1
static const char libbu_rb_insert_RCSid[] = "@@(#) $Header$";
@


11.13
log
@Converted from K&R to ANSI C - RFH
@
text
@d42 6
a47 1
static int _rb_insert (bu_rb_tree *tree, int order, struct bu_rb_node *new_node)
d175 5
a179 1
int bu_rb_insert (bu_rb_tree *tree, void *data)
d318 6
a323 1
static int _rb_set_uniq (bu_rb_tree *tree, int order, int new_value)
d346 5
a350 1
int bu_rb_uniq_on (bu_rb_tree *tree, int order)
d355 5
a359 1
int bu_rb_uniq_off (bu_rb_tree *tree, int order)
d371 5
a375 1
int bu_rb_is_uniq (bu_rb_tree *tree, int order)
d395 5
a399 1
void bu_rb_set_uniqv (bu_rb_tree *tree, bitv_t flag_rep)
d428 5
a432 1
static void _rb_set_uniq_all (bu_rb_tree *tree, int new_value)
d453 4
a456 1
void bu_rb_uniq_all_on (bu_rb_tree *tree)
d461 4
a464 1
void bu_rb_uniq_all_off (bu_rb_tree *tree)
@


11.12
log
@LINT
@
text
@d22 1
a22 1
static const char libbu_rb_insert_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_insert.c,v 11.11 2000/03/28 18:55:10 mike Exp $";
d42 1
a42 6
static int _rb_insert (tree, order, new_node)

bu_rb_tree		*tree;
int			order;
struct bu_rb_node	*new_node;

d170 1
a170 5
int bu_rb_insert (tree, data)

bu_rb_tree	*tree;
void		*data;

d309 1
a309 6
static int _rb_set_uniq (tree, order, new_value)

bu_rb_tree	*tree;
int		order;
int		new_value;

d332 1
a332 5
int bu_rb_uniq_on (tree, order)

bu_rb_tree	*tree;
int		order;

d337 1
a337 5
int bu_rb_uniq_off (tree, order)

bu_rb_tree	*tree;
int	order;

d349 1
a349 5
int bu_rb_is_uniq (tree, order)

bu_rb_tree	*tree;
int		order;

d369 1
a369 5
void bu_rb_set_uniqv (tree, flag_rep)

bu_rb_tree	*tree;
bitv_t		flag_rep;

d398 1
a398 5
static void _rb_set_uniq_all (tree, new_value)

bu_rb_tree	*tree;
int		new_value;

d419 1
a419 4
void bu_rb_uniq_all_on (tree)

bu_rb_tree	*tree;

d424 1
a424 4
void bu_rb_uniq_all_off (tree)

bu_rb_tree	*tree;

@


11.11
log
@
Put libbu_filename_ prefixes on RCSid variables.
@
text
@d22 1
a22 1
static char libbu_rb_insert_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_insert.c,v 11.10 2000/03/28 18:04:43 mike Exp $";
d54 1
a54 1
    int			comparison;
@


11.10
log
@
Changed from RT_LIST to BU_LIST
A few dregs
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_insert.c,v 11.9 1999/01/12 16:19:55 pjt Exp $";
@


11.9
log
@Various details concerning folding libredblack into libbu
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_insert.c,v 11.8 1998/12/30 01:25:44 mike Exp $";
d224 1
a224 1
    RT_LIST_PUSH(&(tree -> rbt_packages.l), rblp);
d256 1
a256 1
    RT_LIST_PUSH(&(tree -> rbt_nodes.l), rblp);
@


11.8
log
@LibRedBlack routines now have a bu_ prefix.
@
text
@d1 1
a1 1
/*			B U _ R B _ I N S E R T . C
d22 1
a22 1
static char RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_insert.c,v 11.7 1996/08/31 09:39:29 mike Exp $";
@


11.7
log
@Converted to LIBBU
@
text
@d1 1
a1 1
/*			R B _ I N S E R T . C
d5 15
a19 2
 *	Author:	Paul Tanenbaum
 *
d22 1
a22 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_insert.c,v 11.6 1995/09/20 13:51:46 pjt Exp mike $";
a30 1
#include "redblack.h"
d44 3
a46 3
rb_tree		*tree;
int		order;
struct rb_node	*new_node;
d49 4
a52 4
    struct rb_node	*node;
    struct rb_node	*parent;
    struct rb_node	*grand_parent;
    struct rb_node	*y;
d59 3
a61 3
    RB_CKMAG(tree, RB_TREE_MAGIC, "red-black tree");
    RB_CKORDER(tree, order);
    RB_CKMAG(new_node, RB_NODE_MAGIC, "red-black node");
d66 5
a70 5
    rb_parent(new_node, order) =
    rb_left_child(new_node, order) =
    rb_right_child(new_node, order) = rb_null(tree);
    rb_size(new_node, order) = 1;
    if (tree -> rbt_debug & RB_DEBUG_OS)
d72 1
a72 1
	    new_node, new_node, order, rb_size(new_node, order));
d77 4
a80 4
    parent = rb_null(tree);
    node = rb_root(tree, order);
    compare = rb_order_func(tree, order);
    while (node != rb_null(tree))
d83 2
a84 2
	++rb_size(parent, order);
	if (tree -> rbt_debug & RB_DEBUG_OS)
d86 3
a88 2
		new_node, parent, order, rb_size(parent, order));
	comparison = (*compare)(rb_data(new_node, order), rb_data(node, order));
d91 1
a91 1
	    if (tree -> rbt_debug & RB_DEBUG_INSERT)
d94 1
a94 1
	    node = rb_left_child(node, order);
d98 1
a98 1
	    if (tree -> rbt_debug & RB_DEBUG_INSERT)
d101 1
a101 1
	    node = rb_right_child(node, order);
d106 6
a111 5
    rb_parent(new_node, order) = parent;
    if (parent == rb_null(tree))
	rb_root(tree, order) = new_node;
    else if ((*compare)(rb_data(new_node, order), rb_data(parent, order)) < 0)
	rb_left_child(parent, order) = new_node;
d113 1
a113 1
	rb_right_child(parent, order) = new_node;
d118 1
a118 1
    rb_set_color(new_node, order, RB_RED);
d120 4
a123 4
    parent = rb_parent(node, order);
    grand_parent = rb_parent(parent, order);
    while ((node != rb_root(tree, order))
	&& (rb_get_color(parent, order) == RB_RED))
d125 2
a126 2
	if (parent == rb_left_child(grand_parent, order))
	    direction = RB_LEFT;
d128 1
a128 1
	    direction = RB_RIGHT;
d130 2
a131 2
	y = rb_other_child(grand_parent, order, direction);
	if (rb_get_color(y, order) == RB_RED)
d133 3
a135 3
	    rb_set_color(parent, order, RB_BLACK);
	    rb_set_color(y, order, RB_BLACK);
	    rb_set_color(grand_parent, order, RB_RED);
d137 2
a138 2
	    parent = rb_parent(node, order);
	    grand_parent = rb_parent(parent, order);
d142 1
a142 1
	    if (node == rb_other_child(parent, order, direction))
d145 3
a147 3
		rb_rotate(node, order, direction);
		parent = rb_parent(node, order);
		grand_parent = rb_parent(parent, order);
d149 3
a151 3
	    rb_set_color(parent, order, RB_BLACK);
	    rb_set_color(grand_parent, order, RB_RED);
	    rb_other_rotate(grand_parent, order, direction);
d154 1
a154 1
    rb_set_color(rb_root(tree, order), order, RB_BLACK);
d156 1
a156 1
    if (tree -> rbt_debug & RB_DEBUG_INSERT)
d163 1
a163 1
/*			R B _ I N S E R T ( )
d169 1
a169 1
 *	requirement would be violated, rb_insert() does nothing but return
d175 1
a175 1
int rb_insert (tree, data)
d177 2
a178 2
rb_tree	*tree;
void	*data;
d181 6
a186 6
    int			nm_orders;
    int			order;
    int			result = 0;
    struct rb_node	*node;
    struct rb_package	*package;
    struct rb_list	*rblp;
d188 1
a188 1
    RB_CKMAG(tree, RB_TREE_MAGIC, "red-black tree");
d201 2
a202 2
	if (rb_get_uniqueness(tree, order) &&
	    (rb_search(tree, order, data) != NULL))
d204 2
a205 2
	    if (tree -> rbt_debug & RB_DEBUG_UNIQ)
		bu_log("rb_insert(<%x>, <%x>, TBD) will return %d\n",
d214 4
a217 4
    package = (struct rb_package *)
		bu_malloc(sizeof(struct rb_package), "red-black package");
    package -> rbp_node = (struct rb_node **)
		bu_malloc(nm_orders * sizeof(struct rb_node *),
d219 4
a222 3
    rblp = (struct rb_list *)
		bu_malloc(sizeof(struct rb_list), "red-black list element");
    rblp -> rbl_magic = RB_LIST_MAGIC;
d231 4
a234 4
    node = (struct rb_node *)
		bu_malloc(sizeof(struct rb_node), "red-black node");
    node -> rbn_parent = (struct rb_node **)
		bu_malloc(nm_orders * sizeof(struct rb_node *),
d236 2
a237 2
    node -> rbn_left = (struct rb_node **)
		bu_malloc(nm_orders * sizeof(struct rb_node *),
d239 2
a240 2
    node -> rbn_right = (struct rb_node **)
		bu_malloc(nm_orders * sizeof(struct rb_node *),
d248 2
a249 2
    node -> rbn_package = (struct rb_package **)
		bu_malloc(nm_orders * sizeof(struct rb_package *),
d251 4
a254 3
    rblp = (struct rb_list *)
		bu_malloc(sizeof(struct rb_list), "red-black list element");
    rblp -> rbl_magic = RB_LIST_MAGIC;
d262 1
a262 1
    package -> rbp_magic = RB_PKG_MAGIC;
d270 1
a270 1
    node -> rbn_magic = RB_NODE_MAGIC;
d280 1
a280 1
    if (rb_root(tree, 0) == rb_null(tree))
d283 9
a291 9
	    rb_root(tree, order) = node;
	    rb_parent(node, order) =
	    rb_left_child(node, order) =
	    rb_right_child(node, order) = rb_null(tree);
	    rb_set_color(node, order, RB_BLACK);
	    rb_size(node, order) = 1;
	    if (tree -> rbt_debug & RB_DEBUG_OS)
		bu_log("rb_insert(<%x>, <%x>, <%x>): size(%x, %d)=%d\n",
		    tree, data, node, node, order, rb_size(node, order));
d298 2
a299 2
	if (tree -> rbt_debug & RB_DEBUG_UNIQ)
	    bu_log("rb_insert(<%x>, <%x>, <%x>) will return %d\n",
d304 1
a304 1
    rb_current(tree) = node;
d320 3
a322 3
rb_tree	*tree;
int	order;
int	new_value;
d327 2
a328 2
    RB_CKMAG(tree, RB_TREE_MAGIC, "red-black tree");
    RB_CKORDER(tree, order);
d331 2
a332 2
    prev_value = rb_get_uniqueness(tree, order);
    rb_set_uniqueness(tree, order, new_value);
d336 2
a337 2
/*		         R B _ U N I Q _ O N ( )
 *		        R B _ U N I Q _ O F F ( )
d346 1
a346 1
int rb_uniq_on (tree, order)
d348 2
a349 2
rb_tree	*tree;
int	order;
d355 1
a355 1
int rb_uniq_off (tree, order)
d357 1
a357 1
rb_tree	*tree;
d364 1
a364 1
/*		         R B _ I S _ U N I Q ( )
d371 1
a371 1
int rb_is_uniq (tree, order)
d373 2
a374 2
rb_tree	*tree;
int	order;
d377 2
a378 2
    RB_CKMAG(tree, RB_TREE_MAGIC, "red-black tree");
    RB_CKORDER(tree, order);
d380 1
a380 1
    return(rb_get_uniqueness(tree, order));
d383 1
a383 1
/*		        R B _ S E T _ U N I Q V ( )
d389 1
a389 1
 *	encoding the flag values.  rb_set_uniqv() sets the flags
d395 1
a395 1
void rb_set_uniqv (tree, flag_rep)
d397 2
a398 2
rb_tree	*tree;
bitv_t	flag_rep;
d404 1
a404 1
    RB_CKMAG(tree, RB_TREE_MAGIC, "red-black tree");
d408 1
a408 1
	rb_set_uniqueness(tree, order, 0);
d413 1
a413 1
	    rb_set_uniqueness(tree, order, 1);
d416 1
a416 1
	bu_log("rb_set_uniqv(): Ignoring bits beyond rightmost %d\n",
d430 2
a431 2
rb_tree	*tree;
int	new_value;
d437 1
a437 1
    RB_CKMAG(tree, RB_TREE_MAGIC, "red-black tree");
d442 1
a442 1
	rb_set_uniqueness(tree, order, new_value);
d445 2
a446 2
/*		     R B _ U N I Q _ A L L _ O N ( )
 *		    R B _ U N I Q _ A L L _ O F F ( )
d453 1
a453 1
void rb_uniq_all_on (tree)
d455 1
a455 1
rb_tree	*tree;
d461 1
a461 1
void rb_uniq_all_off (tree)
d463 1
a463 1
rb_tree	*tree;
@


11.6
log
@Added some diagnostics, removed others.
Net result was simplified logical interplay in rb_insert
between RB_DEBUG_UNIQ and calls to _rb_insert()
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_insert.c,v 11.5 1995/09/20 12:11:26 pjt Exp pjt $";
d17 1
a17 2
#include "vmath.h"
#include "raytrace.h"
d59 1
a59 1
	rt_log("_rb_insert(%x): size(%x, %d)=%d\n",
d73 1
a73 1
	    rt_log("_rb_insert(%x): size(%x, %d)=%d\n",
d79 1
a79 1
		rt_log("_rb_insert(%x): <_%d <%x>, going left\n",
d86 1
a86 1
		rt_log("_rb_insert(%x): >=_%d <%x>, going right\n",
d143 1
a143 1
	rt_log("_rb_insert(%x): comparison = %d, returning %d\n",
d191 1
a191 1
		rt_log("rb_insert(<%x>, <%x>, TBD) will return %d\n",
d201 1
a201 1
		rt_malloc(sizeof(struct rb_package), "red-black package");
d203 1
a203 1
		rt_malloc(nm_orders * sizeof(struct rb_node *),
d206 1
a206 1
		rt_malloc(sizeof(struct rb_list), "red-black list element");
d217 1
a217 1
		rt_malloc(sizeof(struct rb_node), "red-black node");
d219 1
a219 1
		rt_malloc(nm_orders * sizeof(struct rb_node *),
d222 1
a222 1
		rt_malloc(nm_orders * sizeof(struct rb_node *),
d225 1
a225 1
		rt_malloc(nm_orders * sizeof(struct rb_node *),
d228 1
a228 1
		rt_malloc((size_t) ceil((double) (nm_orders / 8.0)),
d231 1
a231 1
		rt_malloc(nm_orders * sizeof(int),
d234 1
a234 1
		rt_malloc(nm_orders * sizeof(struct rb_package *),
d237 1
a237 1
		rt_malloc(sizeof(struct rb_list), "red-black list element");
d274 1
a274 1
		rt_log("rb_insert(<%x>, <%x>, <%x>): size(%x, %d)=%d\n",
d283 1
a283 1
	    rt_log("rb_insert(<%x>, <%x>, <%x>) will return %d\n",
d400 1
a400 1
	rt_log("rb_set_uniqv(): Ignoring bits beyond rightmost %d\n",
@


11.5
log
@Added maintenance of rbn_size member of struct rb_node
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_insert.c,v 11.4 1995/09/19 17:44:51 pjt Exp pjt $";
d190 6
a195 1
		return (-(order + 1));
d275 2
a276 2
		rt_log("rb_insert(%x): size(%x, %d)=%d\n",
		    node, node, order, rb_size(node, order));
d281 2
d284 2
a285 17
	{
	    for (order = 0; order < nm_orders; ++order)
		if (_rb_insert(tree, order, node))
		{
		    rt_log("_rb_insert(<%x>, %d, <%x>) compared SAME\n",
			tree, order, node);
		    ++result;
		}
		else
		    rt_log("_rb_insert(<%x>, %d, <%x>) compared DIFFERENT\n",
			tree, order, node);
	    rt_log("rb_insert(<%x>, <%x>) will return %d\n",
		tree, node, result);
	}
	else
	    for (order = 0; order < nm_orders; ++order)
		result += _rb_insert(tree, order, node);
@


11.4
log
@Added rbn_size member to struct rb_node
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_insert.c,v 11.3 1995/07/10 20:16:29 pjt Exp pjt $";
d58 4
a61 1
    rb_size(node, order) = 1;
d72 4
d268 4
@


11.3
log
@Now maintain lists of all nodes and all packages
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_insert.c,v 11.2 1995/04/19 19:05:14 pjt Exp $";
d58 1
d219 3
@


11.2
log
@1. Fixed bug in return value of _rb_insert()
2. Added uniqueness enforcement to rb_insert()
3. Implemented _rb_set_uniq(), rb_uniq_on(), rb_uniq_off(),
    rb_is_uniq(), rb_set_uniqv(), _rb_set_uniq_all(),
    rb_uniq_all_on(), and rb_uniq_all_off().
4. Added debug prints controlled by rbt_debug
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_insert.c,v 11.1 95/01/04 10:05:55 mike Rel4_4 $";
d165 1
d186 1
d193 6
d202 1
d221 6
@


11.1
log
@Release_4.4
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_insert.c,v 2.6 94/12/30 16:41:04 stay Exp $";
d45 1
d70 4
d75 1
d77 4
d82 3
d135 5
a139 1
    return (comparison == 0);
d147 6
a152 3
 *	the new node and the contents of the node.  rb_insert() returns
 *	the number of orders for which the new node was equal to a node
 *	already in the tree.
d171 13
d245 20
a264 2
	for (order = 0; order < nm_orders; ++order)
	    result += _rb_insert(tree, order, node);
d269 161
@


2.6
log
@deleted reference to stdlib, it wil be included in conf.h if
it exists or is STDC
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_insert.c,v 2.5 1994/11/01 10:43:53 pjt Exp stay $";
@


2.5
log
@Added rbt_nm_nodes to rb_tree
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_insert.c,v 2.4 1994/09/26 12:21:10 jra Exp $";
a13 1
#include <stdlib.h>
@


2.4
log
@Added #include "conf.h"
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_insert.c,v 2.3 94/09/22 15:34:46 pjt Exp Locker: jra $";
d216 1
@


2.3
log
@Changed "#include "rt_internals.h" to "#include "./rt_internals.h"
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_insert.c,v 2.2 94/09/22 15:27:02 pjt Exp Locker: pjt $";
d11 2
@


2.2
log
@Replaced prototype-type definition with K&R type
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_insert.c,v 2.1 93/03/25 11:03:21 pjt Exp $";
d19 1
a19 1
#include "rb_internals.h"
@


2.1
log
@Installed into BRL CAD tree
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_insert.c,v 1.2 93/03/25 11:00:23 pjt Exp Locker: pjt $";
d30 6
a35 1
static int _rb_insert (rb_tree *tree, int order, struct rb_node *new_node)
d133 5
a137 1
int rb_insert (rb_tree *tree, void *data)
@


1.2
log
@Added authorship comment
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_insert.c,v 1.1 93/01/21 14:32:07 pjt zero_1 Locker: pjt $";
@


1.1
log
@Initial revision
At the same time I broke these functions out of rb_create.c,
I added code in _rb_insert() to reestablish red-black properties
@
text
@d5 2
d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /arl/pjt/libredblack/RCS/rb_create.c,v 1.12 93/01/15 14:34:33 pjt Exp Locker: pjt $";
@
