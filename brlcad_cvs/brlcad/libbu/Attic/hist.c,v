head	1.17;
access;
symbols
	ansi-20040405-merged:1.12.2.3
	postmerge-20040405-ansi:1.15
	premerge-20040404-ansi:1.14
	postmerge-autoconf:1.14
	autoconf-freeze:1.12.10.3
	premerge-autoconf:1.14
	ansi-20040316-freeze:1.12.2.1
	postmerge-20040315-windows:1.14
	premerge-20040315-windows:1.14
	windows-20040315-freeze:1.12.4.1
	autoconf-20031203:1.12
	autoconf-20031202:1.12
	autoconf-branch:1.12.0.10
	phong-branch:1.12.0.8
	photonmap-branch:1.12.0.6
	rel-6-1-DP:1.12
	windows-branch:1.12.0.4
	rel-6-0-2:1.10
	ansi-branch:1.12.0.2
	rel-6-0-1-branch:1.10.0.2
	hartley-6-0-post:1.11
	hartley-6-0-pre:1.10
	rel-6-0-1:1.10
	rel-6-0:1.10
	rel-5-4:1.7
	offsite-5-3-pre:1.9
	rel-5-3:1.7
	rel-5-2:1.7
	rel-5-1-branch:1.7.0.2
	rel-5-1:1.7
	rel-5-0:1.6
	rel-5-0-beta:1.6
	rel-4-5:1.5
	ctj-4-5-post:1.5
	ctj-4-5-pre:1.5;
locks; strict;
comment	@ * @;


1.17
date	2004.05.21.18.06.23;	author morrison;	state dead;
branches;
next	1.16;

1.16
date	2004.05.10.15.30.44;	author erikg;	state Exp;
branches;
next	1.15;

1.15
date	2004.04.05.07.46.16;	author morrison;	state Exp;
branches;
next	1.14;

1.14
date	2004.03.02.18.28.44;	author jra;	state Exp;
branches;
next	1.13;

1.13
date	2004.02.02.17.39.07;	author morrison;	state Exp;
branches;
next	1.12;

1.12
date	2002.08.20.17.07.40;	author jra;	state Exp;
branches
	1.12.2.1
	1.12.4.1
	1.12.10.1;
next	1.11;

1.11
date	2002.08.15.20.54.53;	author hartley;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.20.22.29.06;	author morrison;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.07.05.21.21;	author cjohnson;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.07.00.37.35;	author cjohnson;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.10.04.59.45;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	99.05.27.02.18.46;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	97.04.23.01.04.27;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	97.04.07.18.05.00;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	97.03.31.06.26.20;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	97.03.31.06.07.51;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	96.08.31.10.40.16;	author mike;	state Exp;
branches;
next	;

1.12.2.1
date	2002.09.19.18.01.12;	author morrison;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2004.03.17.21.16.49;	author morrison;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2004.04.05.00.50.06;	author morrison;	state Exp;
branches;
next	;

1.12.4.1
date	2004.03.11.23.41.49;	author morrison;	state Exp;
branches;
next	;

1.12.10.1
date	2004.02.12.18.39.18;	author erikg;	state Exp;
branches;
next	1.12.10.2;

1.12.10.2
date	2004.03.02.19.44.19;	author erikg;	state Exp;
branches;
next	1.12.10.3;

1.12.10.3
date	2004.03.15.14.06.17;	author erikg;	state Exp;
branches;
next	;


desc
@histogram routines
@


1.17
log
@moved to src/
@
text
@/*
 *			H I S T . C
 *
 *  General purpose histogram handling routines
 *
 *  The macro RT_HISTOGRAM_TALLY is used to record items that
 *  live in a single "bin", while the subroutine rt_hist_range()
 *  is used to record items that may extend across multiple "bin"s.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCShist[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libbu/hist.c,v 1.16 2004/05/10 15:30:44 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include "machine.h"
#include "bu.h"

/*
 *			B U _ H I S T _ F R E E
 */
void
bu_hist_free(struct bu_hist *histp)
{
	if( histp && histp->magic == 0 )  return;
	if( histp->magic == -1 ) return;
	BU_CK_HIST(histp);
	if( histp->hg_bins )
		bu_free( (char *)histp->hg_bins, "old bu_hist bins");
	histp->hg_bins = (long *)0;
	histp->hg_nbins = 0;
	histp->magic = -1;	/* sanity */
}

/*
 *			B U _ H I S T _ I N I T
 *
 *  Initialize a bu_hist structure.
 *  It is expected that the structure is junk upon entry.
 */
void
bu_hist_init(struct bu_hist *histp, fastf_t min, fastf_t max, unsigned int nbins)
{

	if( max <= min )  max = min+1;
	if( nbins < 1 )  {
		nbins = 1;	/* nbins=1 makes for a nice 2-bin binary histogram */
	} else if( nbins > 10000 )  {
		nbins = 10000;	/* This is a lot of lines to print out */
	}

	histp->hg_min = floor(min);
	histp->hg_max = ceil(max);
	histp->hg_nbins = nbins;

	histp->hg_clumpsize = ((max-min)/nbins);
	if( histp->hg_clumpsize <= 0 )  histp->hg_clumpsize = 1;

	histp->hg_nsamples = 0L;
	histp->hg_bins = (long *)bu_calloc( nbins+1, sizeof(long), "bu_hist bins");
	histp->magic = BU_HIST_MAGIC;
}

/*
 *			B U _ H I S T _ R A N G E
 */
void
bu_hist_range(register struct bu_hist *hp, fastf_t low, fastf_t high)
{
	long		a;
	long		b;
	register int	i;

	BU_CK_HIST(hp);
	if( low <= hp->hg_min )
		a = 0;
	else
		a = (low - hp->hg_min) / hp->hg_clumpsize;
	if( high >= hp->hg_max )
		b = hp->hg_nbins-1;
	else
		b = (high - hp->hg_min) / hp->hg_clumpsize;
	if( b >= hp->hg_nbins )  b = hp->hg_nbins-1;

	for( i=a; i <= b; i++ )  {
		hp->hg_bins[i]++;
	}
	hp->hg_nsamples++;
}

/*
 *			B U _ H I S T _ P R _ S U P P R E S S
 *
 *  Allows caller control over zero-suppression feature.
 */
void
bu_hist_pr_suppress(register const struct bu_hist *histp, const char *title, int zero_suppress)
{
	register int	i;
	long		maxcount;
	static const char	marks[] = "################################################################";
#define	NMARKS	50
	char		buf[256];
	int		percent;
	unsigned int	mark_count;
	double		val;
	int		nbins;

	BU_CK_HIST(histp);

	/* Find entry with highest count */
	maxcount = 0L;
	for( i=0; i<=histp->hg_nbins; i++ )  {
		if( histp->hg_bins[i] > maxcount )
			maxcount = histp->hg_bins[i];
	}
	if( maxcount <= 0 )  maxcount = 1;

	nbins = histp->hg_nbins;
	if( zero_suppress )  {
		/* Supress trailing bins with zero counts.  nbins s/b >= 1 */
		for( ; nbins >= 1; nbins-- )
			if(histp->hg_bins[nbins] > 0)  break;
	}

	/* 12345678 12345678 123 .... */
	bu_log("\nHistogram of %s\nmin=%g, max=%g, nbins=%d, clumpsize=%g\n%d samples collected, highest count was %d\n\n Value      Count Rel%%|  Bar Graph\n",
		title,
		histp->hg_min, histp->hg_max,
		histp->hg_nbins, histp->hg_clumpsize,
		histp->hg_nsamples, maxcount );

	/* Print each bin. */
	i = 0;
	if( zero_suppress )  {
		/* Leading bins with zero counts are supressed. */
		for( ; i <= nbins; i++ )  {
			if(histp->hg_bins[i] > 0)  break;
		}
	}
	for( ; i <= nbins; i++ )  {
		percent = (int)(((double)histp->hg_bins[i])*100.0/maxcount);
		mark_count = percent*NMARKS/100;
		if( mark_count <= 0 && histp->hg_bins[i] > 0 )
			mark_count = 1;
		if( mark_count > NMARKS )  {
			bu_log("mark_count = %d, NMARKS=%d, hg_bins[%d]=%d, maxcount\n",
				mark_count, NMARKS, i, histp->hg_bins[i], maxcount);
			bu_bomb("bu_hist_pr() bogus mark_count\n");
		}
		if( mark_count <= 0 )  {
			buf[0] = '\0';
		} else {
			bcopy( marks, buf, mark_count );
			buf[mark_count] = '\0';
		}
		val = histp->hg_min + i*histp->hg_clumpsize;
		bu_log("%8g %8d %3d |%s\n",
			val,
			histp->hg_bins[i], percent, buf );
	}
}

/*
 *			B U _ H I S T _ P R
 *
 *  The original interface.
 */
void
bu_hist_pr(register const struct bu_hist *histp, const char *title)
{
	bu_hist_pr_suppress( histp, title, 1 );
}
@


1.16
log
@change conf.h to a wrapped config.h
@
text
@d23 1
a23 1
static const char RCShist[] = "@@(#)$Header: /cvs/brlcad/libbu/hist.c,v 1.15 2004/04/05 07:46:16 morrison Exp $ (BRL)";
@


1.15
log
@merge of ansi-6-0-branch into HEAD
@
text
@d23 1
a23 1
static const char RCShist[] = "@@(#)$Header$ (BRL)";
d26 5
a30 1
#include "conf.h"
@


1.14
log
@Added check for already freed in bu_hist_free()
@
text
@d23 1
a23 1
static const char RCShist[] = "@@(#)$Header: /c/CVS/brlcad/libbu/hist.c,v 1.13 2004/02/02 17:39:07 morrison Exp $ (BRL)";
d40 1
a40 2
bu_hist_free( histp )
struct bu_hist	*histp;
d59 1
a59 4
bu_hist_init( histp, min, max, nbins )
struct bu_hist	*histp;
fastf_t			min, max;
int			nbins;
d85 1
a85 4
bu_hist_range( hp, low, high )
register struct bu_hist	*hp;
fastf_t				low;
fastf_t				high;
d114 1
a114 4
bu_hist_pr_suppress( histp, title, zero_suppress )
register const struct bu_hist	*histp;
const char		*title;
int			zero_suppress;
d122 1
a122 1
	int		mark_count;
d187 1
a187 3
bu_hist_pr( histp, title )
register const struct bu_hist	*histp;
const char			*title;
@


1.13
log
@update copyright to include span through 2003
@
text
@d23 1
a23 1
static const char RCShist[] = "@@(#)$Header: /c/CVS/brlcad/libbu/hist.c,v 1.12 2002/08/20 17:07:40 jra Exp $ (BRL)";
d44 1
@


1.12
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1990 by the United States Army.
d23 1
a23 1
static const char RCShist[] = "@@(#)$Header: /c/CVS/brlcad/libbu/hist.c,v 1.10 2001/04/20 22:29:06 morrison Exp $ (BRL)";
@


1.12.4.1
log
@sync to HEAD...
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d23 1
a23 1
static const char RCShist[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libbu/hist.c,v 1.14 2004/03/02 18:28:44 jra Exp $ (BRL)";
a43 1
	if( histp->magic == -1 ) return;
@


1.12.10.1
log
@merge from HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d23 1
a23 1
static const char RCShist[] = "@@(#)$Header: /c/CVS/brlcad/libbu/hist.c,v 1.13 2004/02/02 17:39:07 morrison Exp $ (BRL)";
@


1.12.10.2
log
@update from head
@
text
@d23 1
a23 1
static const char RCShist[] = "@@(#)$Header: /c/CVS/brlcad/libbu/hist.c,v 1.14 2004/03/02 18:28:44 jra Exp $ (BRL)";
a43 1
	if( histp->magic == -1 ) return;
@


1.12.10.3
log
@merge from head
@
text
@d23 1
a23 1
static const char RCShist[] = "@@(#)$Header: /c/CVS/brlcad/libbu/hist.c,v 1.12.10.2 2004/03/02 19:44:19 erikg Exp $ (BRL)";
@


1.12.2.1
log
@Initial ANSIfication
@
text
@d23 1
a23 1
static const char RCShist[] = "@@(#)$Header: /c/CVS/brlcad/libbu/hist.c,v 1.12 2002/08/20 17:07:40 jra Exp $ (BRL)";
d40 2
a41 1
bu_hist_free(struct bu_hist *histp)
d59 4
a62 1
bu_hist_init(struct bu_hist *histp, fastf_t min, fastf_t max, int nbins)
d88 4
a91 1
bu_hist_range(register struct bu_hist *hp, fastf_t low, fastf_t high)
d120 4
a123 1
bu_hist_pr_suppress(register const struct bu_hist *histp, const char *title, int zero_suppress)
d196 3
a198 1
bu_hist_pr(register const struct bu_hist *histp, const char *title)
@


1.12.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d23 1
a23 1
static const char RCShist[] = "@@(#)$Header$ (BRL)";
a42 1
	if( histp->magic == -1 ) return;
@


1.12.2.3
log
@more quelling of lots of warnings
@
text
@d23 1
a23 1
static const char RCShist[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libbu/hist.c,v 1.12.2.2 2004/03/17 21:16:49 morrison Exp $ (BRL)";
d59 1
a59 1
bu_hist_init(struct bu_hist *histp, fastf_t min, fastf_t max, unsigned int nbins)
d122 1
a122 1
	unsigned int	mark_count;
@


1.11
log
@Converted from K&R to ANSI C - RFH
@
text
@d40 2
a41 1
bu_hist_free(struct bu_hist *histp)
d59 4
a62 1
bu_hist_init(struct bu_hist *histp, fastf_t min, fastf_t max, int nbins)
d88 4
a91 1
bu_hist_range(register struct bu_hist *hp, fastf_t low, fastf_t high)
d120 4
a123 1
bu_hist_pr_suppress(register const struct bu_hist *histp, const char *title, int zero_suppress)
d196 3
a198 1
bu_hist_pr(register const struct bu_hist *histp, const char *title)
@


1.10
log
@CONST to const
@
text
@d23 1
a23 1
static const char RCShist[] = "@@(#)$Header: /c/CVS/brlcad/libbu/hist.c,v 1.9 2000/07/07 05:21:21 cjohnson Exp $ (BRL)";
d40 1
a40 2
bu_hist_free( histp )
struct bu_hist	*histp;
d58 1
a58 4
bu_hist_init( histp, min, max, nbins )
struct bu_hist	*histp;
fastf_t			min, max;
int			nbins;
d84 1
a84 4
bu_hist_range( hp, low, high )
register struct bu_hist	*hp;
fastf_t				low;
fastf_t				high;
d113 1
a113 4
bu_hist_pr_suppress( histp, title, zero_suppress )
register const struct bu_hist	*histp;
const char		*title;
int			zero_suppress;
d186 1
a186 3
bu_hist_pr( histp, title )
register const struct bu_hist	*histp;
const char			*title;
@


1.9
log
@LINT plus minor bug fix in bu_tcl.c
@
text
@d23 1
a23 1
static const char RCShist[] = "@@(#)$Header: /c/CVS/brlcad/libbu/hist.c,v 1.8 2000/07/07 00:37:35 cjohnson Exp $ (BRL)";
d121 2
a122 2
register CONST struct bu_hist	*histp;
CONST char		*title;
d127 1
a127 1
	static CONST char	marks[] = "################################################################";
d197 2
a198 2
register CONST struct bu_hist	*histp;
CONST char			*title;
@


1.8
log
@LINT
@
text
@d23 1
a23 1
static char RCShist[] = "@@(#)$Header: /c/CVS/brlcad/libbu/hist.c,v 1.7 2000/02/10 04:59:45 mike Exp $ (BRL)";
@


1.7
log
@
CONST
@
text
@d23 1
a23 1
static char RCShist[] = "@@(#)$Header: /c/CVS/brlcad/libbu/hist.c,v 1.6 1999/05/27 02:18:46 mike Exp $ (BRL)";
d30 3
@


1.6
log
@
Fixed boundary condition
@
text
@d23 1
a23 1
static char RCShist[] = "@@(#)$Header: /c/CVS/brlcad/libbu/hist.c,v 1.5 1997/04/23 01:04:27 mike Exp $ (BRL)";
d118 1
a118 1
register struct bu_hist	*histp;
d194 1
a194 1
register struct bu_hist	*histp;
@


1.5
log
@Added bu_hist_pr_suppress
@
text
@d23 1
a23 1
static char RCShist[] = "@@(#)$Header: /m/cad/libbu/RCS/hist.c,v 1.4 1997/04/07 18:05:00 mike Exp mike $ (BRL)";
d103 2
a104 1
	if( a < 0 || b >= hp->hg_nbins )  bu_bomb("bu_hist_range() out of range\n");
@


1.4
log
@Reduced minimum from 2 (3 bins), to 1.
@
text
@d23 1
a23 1
static char RCShist[] = "@@(#)$Header: /m/cad/libbu/RCS/hist.c,v 1.3 1997/03/31 06:26:20 mike Exp mike $ (BRL)";
d111 3
a113 1
 *			B U _ H I S T _ P R
d116 1
a116 1
bu_hist_pr( histp, title )
d118 2
a119 1
CONST char			*title;
d141 6
a146 3
	/* Supress trailing bins with zero counts.  nbins s/b >= 1 */
	for( nbins = histp->hg_nbins; nbins >= 1; nbins-- )
		if(histp->hg_bins[nbins] > 0)  break;
d155 7
a161 3
	/* Print each bin.  Leading & final bins with zero counts are supressed. */
	for( i=0; i <= nbins; i++ )  {
		if(histp->hg_bins[i] > 0)  break;
d184 13
@


1.3
log
@Fixed problem calculating clumpsize.
Fixed off-by-one problem finding maximum.
Added zero supression to both sides of graph.
@
text
@d23 1
a23 1
static char RCShist[] = "@@(#)$Header: /m/cad/libbu/RCS/hist.c,v 1.2 1997/03/31 06:07:51 mike Exp mike $ (BRL)";
d63 2
a64 2
	if( nbins < 2 )  {
		nbins = 2;
d66 1
a66 1
		nbins = 10000;
@


1.2
log
@Two improvements:
Don't fail to consider the final (max) bin,
and always put out at least one tick (#) when count is non-zero.
@
text
@d23 1
a23 1
static char RCShist[] = "@@(#)$Header: /m/cad/libbu/RCS/hist.c,v 1.1 1996/08/31 10:40:16 mike Exp mike $ (BRL)";
d73 1
a73 2
	/* When max-min <= nbins, clumpsize should be 1 */
	histp->hg_clumpsize = ((max-min)/nbins)+1;
d125 1
a125 1
	int		val;
d132 1
a132 1
	for( i=0; i<histp->hg_nbins; i++ )  {
d149 1
a149 1
	/* Print each bin.  Final bins with zero counts are supressed. */
d151 3
d158 5
d170 1
a170 1
		bu_log("%8d %8d %3d |%s\n",
@


1.1
log
@Initial revision
@
text
@d23 1
a23 1
static char RCShist[] = "@@(#)$Header: /m/cad/librt/RCS/hist.c,v 11.2 1996/07/12 12:10:21 jra Exp $ (BRL)";
d140 1
a140 1
	for( nbins = histp->hg_nbins-1; nbins >= 1; nbins-- )
d154 2
@
