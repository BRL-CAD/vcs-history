head	1.39;
access;
symbols
	ansi-20040405-merged:1.34.2.3
	postmerge-20040405-ansi:1.37
	premerge-20040404-ansi:1.36
	postmerge-autoconf:1.36
	autoconf-freeze:1.35.6.2
	premerge-autoconf:1.36
	ansi-20040316-freeze:1.34.2.1
	postmerge-20040315-windows:1.36
	premerge-20040315-windows:1.36
	windows-20040315-freeze:1.34.4.1
	autoconf-20031203:1.35
	autoconf-20031202:1.35
	autoconf-branch:1.35.0.6
	phong-branch:1.35.0.4
	photonmap-branch:1.35.0.2
	rel-6-1-DP:1.34
	windows-branch:1.34.0.4
	rel-6-0-2:1.32
	ansi-branch:1.34.0.2
	rel-6-0-1-branch:1.32.0.2
	hartley-6-0-post:1.33
	hartley-6-0-pre:1.32
	rel-6-0-1:1.32
	rel-6-0:1.32
	rel-5-4:1.25
	offsite-5-3-pre:1.29
	rel-5-3:1.25
	rel-5-2:1.25
	rel-5-1-branch:1.25.0.2
	rel-5-1:1.25
	rel-5-0:1.17
	rel-5-0-beta:1.16
	rel-4-5:1.8;
locks; strict;
comment	@ * @;


1.39
date	2004.05.21.18.06.23;	author morrison;	state dead;
branches;
next	1.38;

1.38
date	2004.05.10.15.30.44;	author erikg;	state Exp;
branches;
next	1.37;

1.37
date	2004.04.05.07.46.16;	author morrison;	state Exp;
branches;
next	1.36;

1.36
date	2004.02.02.17.39.07;	author morrison;	state Exp;
branches;
next	1.35;

1.35
date	2003.04.01.14.17.38;	author jra;	state Exp;
branches
	1.35.6.1;
next	1.34;

1.34
date	2002.08.20.17.07.39;	author jra;	state Exp;
branches
	1.34.2.1
	1.34.4.1;
next	1.33;

1.33
date	2002.08.15.20.54.50;	author hartley;	state Exp;
branches;
next	1.32;

1.32
date	2001.11.02.04.59.21;	author butler;	state Exp;
branches;
next	1.31;

1.31
date	2001.04.20.22.29.05;	author morrison;	state Exp;
branches;
next	1.30;

1.30
date	2001.04.11.17.49.03;	author bparker;	state Exp;
branches;
next	1.29;

1.29
date	2000.09.08.14.22.54;	author bparker;	state Exp;
branches;
next	1.28;

1.28
date	2000.08.11.03.21.26;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	2000.07.07.05.21.20;	author cjohnson;	state Exp;
branches;
next	1.26;

1.26
date	2000.06.30.20.07.30;	author butler;	state Exp;
branches;
next	1.25;

1.25
date	2000.06.19.21.11.52;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	2000.04.17.20.39.37;	author jra;	state Exp;
branches;
next	1.23;

1.23
date	2000.04.13.14.36.52;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	2000.03.28.18.55.07;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	2000.03.22.02.15.43;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	2000.02.04.14.30.57;	author bparker;	state Exp;
branches;
next	1.19;

1.19
date	99.12.29.20.18.24;	author jra;	state Exp;
branches;
next	1.18;

1.18
date	99.11.18.02.41.55;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	99.06.09.19.49.14;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	99.01.15.19.43.14;	author jra;	state Exp;
branches;
next	1.15;

1.15
date	98.10.08.20.11.31;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	98.06.04.18.39.37;	author jra;	state Exp;
branches;
next	1.13;

1.13
date	98.05.29.20.21.18;	author jra;	state Exp;
branches;
next	1.12;

1.12
date	98.05.28.19.55.30;	author pjt;	state Exp;
branches;
next	1.11;

1.11
date	98.03.19.10.40.14;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	98.03.19.09.48.49;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	98.03.19.06.39.18;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	97.12.24.04.49.51;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	97.11.21.06.13.14;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	97.11.21.05.48.56;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	97.11.05.15.15.11;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	97.08.26.06.12.23;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	97.08.26.05.57.59;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	97.08.26.05.56.01;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	97.08.26.05.50.16;	author mike;	state Exp;
branches;
next	;

1.34.2.1
date	2002.09.19.18.01.11;	author morrison;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	2004.03.17.21.16.49;	author morrison;	state Exp;
branches;
next	1.34.2.3;

1.34.2.3
date	2004.04.05.00.50.06;	author morrison;	state Exp;
branches;
next	;

1.34.4.1
date	2004.03.11.23.41.48;	author morrison;	state Exp;
branches;
next	;

1.35.6.1
date	2004.02.12.18.39.18;	author erikg;	state Exp;
branches;
next	1.35.6.2;

1.35.6.2
date	2004.03.15.14.06.17;	author erikg;	state Exp;
branches;
next	;


desc
@TCL interface to LIBBU
@


1.39
log
@moved to src/
@
text
@/*****h* libbu/cmd.c
 *
 * NAME
 *	B U _ T C L . C
 *
 * SYNOPSIS
 *	Tcl interfaces to all the LIBBU Basic BRL-CAD Utility routines.
 *
 *	Remember that in MGED you need to say "set glob_compat_mode 0"
 *	to get [] to work with TCL semantics rather than MGED glob semantics.
 *
 * Author -
 *	Michael John Muuss
 *  
 * Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 * Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 * Copyright Notice -
 *	This software is Copyright (C) 1998-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libbu/bu_tcl.c,v 1.38 2004/05/10 15:30:44 erikg Exp $ (ARL)";
#endif


#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <ctype.h>

#include "tcl.h"

#include "machine.h"
#include "cmd.h"		/* this includes bu.h */
#include "vmath.h"
#include "bn.h"

/* defined in libbu/cmdhist_obj.c */
extern int Cho_Init(Tcl_Interp *interp);

static struct bu_cmdtab bu_cmds[] = {
	{"bu_units_conversion",		bu_tcl_units_conversion},
	{"bu_brlcad_path",		bu_tcl_brlcad_path},
	{"bu_mem_barriercheck",		bu_tcl_mem_barriercheck},
	{"bu_ck_malloc_ptr",		bu_tcl_ck_malloc_ptr},
	{"bu_malloc_len_roundup",	bu_tcl_malloc_len_roundup},
	{"bu_prmem",			bu_tcl_prmem},
	{"bu_printb",			bu_tcl_printb,},
	{"bu_get_all_keyword_values",	bu_get_all_keyword_values},
	{"bu_get_value_by_keyword",	bu_get_value_by_keyword},
	{"bu_rgb_to_hsv",		bu_tcl_rgb_to_hsv},
	{"bu_hsv_to_rgb",		bu_tcl_hsv_to_rgb},
	{"bu_key_eq_to_key_val",	bu_tcl_key_eq_to_key_val},
	{"bu_shader_to_tcl_list",	bu_tcl_shader_to_key_val},
	{"bu_key_val_to_key_eq",	bu_tcl_key_val_to_key_eq},
	{"bu_shader_to_key_eq",		bu_tcl_shader_to_key_eq},
	{(char *)NULL,	(int (*)())0 }
};

/*****f* libbu/bu_tcl.c
 *
 * NAME
 *	bu_badmagic_tcl
 *
 * SYNOPSIS
 * 	Support routine for BU_CKMAG_TCL macro. As used by
 *	BU_CKMAG_TCL, this routine is not called unless there
 *	is trouble with the pointer. When called, an appropriate
 *	message is added to interp indicating the problem.
 *
 * PARAMETERS
 *	interp	- tcl interpreter where result is stored
 *	ptr	- pointer to a data structure
 *	magic	- the correct/desired magic number
 *	str	- usually indicates the data structure name
 *	file	- file where this routine was called
 *	line	- line number in the above file
 *
 * RETURN
 *	void
 */

void
bu_badmagic_tcl(Tcl_Interp	*interp,
		const long	*ptr,
		unsigned long	magic,
		const char	*str,
		const char	*file,
		int		line)
{
	char	buf[256];

	if (!(ptr)) { 
		sprintf(buf, "ERROR: NULL %s pointer in TCL interface, file %s, line %d\n", 
			str, file, line); 
		Tcl_AppendResult(interp, buf, NULL);
		return;
	}
	if (*((long *)(ptr)) != (magic)) { 
		sprintf(buf, "ERROR: bad pointer in TCL interface x%lx: s/b %s(x%lx), was %s(x%lx), file %s, line %d\n", 
			(long)ptr,
			str, magic,
			bu_identify_magic( *(ptr) ), *(ptr),
			file, line); 
		Tcl_AppendResult(interp, buf, NULL);
		return;
	}
	Tcl_AppendResult(interp, "bu_badmagic_tcl() mysterious error condition, ", str, " pointer, ", file, "\n", NULL);
}


/*****f* libbu/bu_tcl.c
 *
 * NAME
 *	bu_structparse_get_terse_form
 *
 * SYNOPSIS
 *	Convert the "form" of a bu_structparse table into a TCL result string,
 *	with parameter-name data-type pairs:
 *
 *		V {%f %f %f} A {%f %f %f}
 *
 *	A different routine should build a more general 'form', along the
 *	lines of {V {%f %f %f} default {help}} {A {%f %f %f} default# {help}}
 *
 * PARAMETERS
 *	interp	- tcl interpreter
 *	sp	- structparse table
 *
 * RETURN
 *	void
 */
void
bu_structparse_get_terse_form(Tcl_Interp			*interp,
			      register struct bu_structparse	*sp)
{
	struct bu_vls	str;
	int		i;

	bu_vls_init(&str);

	while (sp->sp_name != NULL) {
		Tcl_AppendElement(interp, sp->sp_name);
		bu_vls_trunc(&str, 0);
		/* These types are specified by lengths, e.g. %80s */
		if (strcmp(sp->sp_fmt, "%c") == 0 ||
		    strcmp(sp->sp_fmt, "%s") == 0 ||
		    strcmp(sp->sp_fmt, "%S") == 0) {
			if (sp->sp_count > 1) {
				/* Make them all look like %###s */
				bu_vls_printf(&str, "%%%ds", sp->sp_count);
			} else {
				/* Singletons are specified by their actual character */
				bu_vls_printf(&str, "%%c");
			}
		} else {
			/* Vectors are specified by repetition, e.g. {%f %f %f} */
			bu_vls_printf(&str, "%s", sp->sp_fmt);
			for (i = 1; i < sp->sp_count; i++)
				bu_vls_printf(&str, " %s", sp->sp_fmt);
		}
		Tcl_AppendElement(interp, bu_vls_addr(&str));
		++sp;
	}
	bu_vls_free(&str);
}

/*****d* libbu/bu_tcl.c
 *
 * NAME
 *	BU_SP_SKIP_SEP
 *
 * SYNOPSIS
 *	Skip the separator(s) (i.e. whitespace and open-braces)
 *
 * PARAMETERS
 *	_cp	- character pointer
 */
#define BU_SP_SKIP_SEP(_cp)	\
	{ while( *(_cp) && (*(_cp) == ' ' || *(_cp) == '\n' || \
		*(_cp) == '\t' || *(_cp) == '{' ) )  ++(_cp); }

/*****f* libbu/bu_tcl.c
 *
 * NAME
 *	bu_structparse_argv
 *
 * SYNOPSIS
 *	Support routine for db adjust and db put.  Much like the bu_struct_parse routine
 *	which takes its input as a bu_vls. This routine, however, takes the arguments
 *	as lists, a more Tcl-friendly method. Also knows about the Tcl result string,
 *	so it can make more informative error messages.
 *
 *	Operates on argv[0] and argv[1], then on argv[2] and argv[3], ...
 *
 * PARAMETERS
 *	interp	- tcl interpreter
 *	argc	- number of elements in argv
 *	argv	- contains the keyword-value pairs
 *	desc	- structure description
 *	base	- base addr of users struct
 *
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_structparse_argv(Tcl_Interp			*interp,
		    int				argc,
		    char			**argv,
		    const struct bu_structparse	*desc,
		    char			*base)
{
	register char				*cp, *loc;
	register const struct bu_structparse	*sdp;
	register int				 j;
	register int				ii;
	struct bu_vls				 str;

	if (desc == (struct bu_structparse *)NULL) {
		bu_log("bu_structparse_argv: NULL desc pointer\n");
		Tcl_AppendResult(interp, "NULL desc pointer", (char *)NULL);
		return TCL_ERROR;
	}

	/* Run through each of the attributes and their arguments. */

	bu_vls_init(&str);
	while (argc > 0) {
		/* Find the attribute which matches this argument. */
		for (sdp = desc; sdp->sp_name != NULL; sdp++) {
			if (strcmp(sdp->sp_name, *argv) != 0)
				continue;

			/* if we get this far, we've got a name match
			 * with a name in the structure description
			 */

#if CRAY && !__STDC__
			loc = (char *)(base+((int)sdp->sp_offset*sizeof(int)));
#else
			loc = (char *)(base+((int)sdp->sp_offset));
#endif
			if (sdp->sp_fmt[0] != '%') {
				bu_log("bu_structparse_argv: unknown format\n");
				bu_vls_free(&str);
				Tcl_AppendResult(interp, "unknown format",
						 (char *)NULL);
				return TCL_ERROR;
			}

			--argc;
			++argv;

			switch (sdp->sp_fmt[1]) {
			case 'c':
			case 's':
				/* copy the string, converting escaped
				 * double quotes to just double quotes
				 */
				if (argc < 1) {
					bu_vls_trunc(&str, 0);
					bu_vls_printf(&str,
						      "not enough values for \"%s\" argument: should be %d",
						      sdp->sp_name,
						      sdp->sp_count);
					Tcl_AppendResult(interp,
							 bu_vls_addr(&str),
							 (char *)NULL);
					bu_vls_free(&str);
					return TCL_ERROR;
				}
				for (ii = j = 0;
				     j < sdp->sp_count && argv[0][ii] != '\0';
				     loc[j++] = argv[0][ii++])
					;
				if (ii < sdp->sp_count)
					loc[ii] = '\0';
				if (sdp->sp_count > 1) {
					loc[sdp->sp_count-1] = '\0';
					Tcl_AppendResult(interp,
							 sdp->sp_name, " ",
							 loc, " ",
							 (char *)NULL);
				} else {
					bu_vls_trunc(&str, 0);
					bu_vls_printf(&str, "%s %c ",
						      sdp->sp_name, *loc);
					Tcl_AppendResult(interp,
							 bu_vls_addr(&str),
							 (char *)NULL);
				}
				break;
			case 'S': {
				struct bu_vls *vls = (struct bu_vls *)loc;
				bu_vls_init_if_uninit( vls );
				bu_vls_strcpy(vls, *argv);
				break;
			}
			case 'i':
#if 0
				bu_log(
			 "Error: %%i not implemented. Contact developers.\n" );
				Tcl_AppendResult( interp,
						  "%%i not implemented yet",
						  (char *)NULL );
				bu_vls_free( &str );
				return TCL_ERROR;
#else
				{
				register short *sh = (short *)loc;
				register int tmpi;
				register char const *cp;

				if( argc < 1 ) { /* XXX - when was ii defined */
					bu_vls_trunc( &str, 0 );
					bu_vls_printf( &str,
      "not enough values for \"%s\" argument: should have %d",
						       sdp->sp_name,
						       sdp->sp_count);
					Tcl_AppendResult( interp,
							  bu_vls_addr(&str),
							  (char *)NULL );
					bu_vls_free( &str );
					return TCL_ERROR;
				}

				Tcl_AppendResult( interp, sdp->sp_name, " ",
						  (char *)NULL );

				/* Special case:  '=!' toggles a boolean */
				if( argv[0][0] == '!' ) {
					*sh = *sh ? 0 : 1;
					bu_vls_trunc( &str, 0 );
					bu_vls_printf( &str, "%hd ", *sh );
					Tcl_AppendResult( interp,
							  bu_vls_addr(&str),
							  (char *)NULL );
					break;
				}
				/* Normal case: an integer */
				cp = *argv;
				for( ii = 0; ii < sdp->sp_count; ++ii ) {
					if( *cp == '\0' ) {
						bu_vls_trunc( &str, 0 );
						bu_vls_printf( &str,
		      "not enough values for \"%s\" argument: should have %d",
							       sdp->sp_name,
							       sdp->sp_count );
						Tcl_AppendResult( interp,
							    bu_vls_addr(&str),
							    (char *)NULL );
						bu_vls_free( &str );
						return TCL_ERROR;
					}

					BU_SP_SKIP_SEP(cp);
					tmpi = atoi( cp );
					if( *cp && (*cp == '+' || *cp == '-') )
						cp++;
					while( *cp && isdigit(*cp) )
						cp++; 
					/* make sure we actually had an
					 * integer out there
					 */

					if( cp == *argv ||
					    (cp == *argv+1 &&
					     (argv[0][0] == '+' ||
					      argv[0][0] == '-')) ) {
						bu_vls_trunc( &str, 0 );
						bu_vls_printf( &str, 
			       "value \"%s\" to argument %s isn't an integer",
							       argv,
							       sdp->sp_name );
						Tcl_AppendResult( interp,
							    bu_vls_addr(&str),
							    (char *)NULL );
						bu_vls_free( &str );
						return TCL_ERROR;
					} else {
						*(sh++) = tmpi;
					}
					BU_SP_SKIP_SEP(cp);
				}
				Tcl_AppendResult( interp,
						  sdp->sp_count > 1 ? "{" : "",
						  argv[0],
						  sdp->sp_count > 1 ? "}" : "",
						  " ", (char *)NULL);
				break; }

#endif
			case 'd': {
				register int *ip = (int *)loc;
				register int tmpi;
				register char const *cp;

				if( argc < 1 ) { /* XXX - when was ii defined */
					bu_vls_trunc( &str, 0 );
					bu_vls_printf( &str,
      "not enough values for \"%s\" argument: should have %d",
						       sdp->sp_name,
						       sdp->sp_count);
					Tcl_AppendResult( interp,
							  bu_vls_addr(&str),
							  (char *)NULL );
					bu_vls_free( &str );
					return TCL_ERROR;
				}

				Tcl_AppendResult( interp, sdp->sp_name, " ",
						  (char *)NULL );

				/* Special case:  '=!' toggles a boolean */
				if( argv[0][0] == '!' ) {
					*ip = *ip ? 0 : 1;
					bu_vls_trunc( &str, 0 );
					bu_vls_printf( &str, "%d ", *ip );
					Tcl_AppendResult( interp,
							  bu_vls_addr(&str),
							  (char *)NULL );
					break;
				}
				/* Normal case: an integer */
				cp = *argv;
				for( ii = 0; ii < sdp->sp_count; ++ii ) {
					if( *cp == '\0' ) {
						bu_vls_trunc( &str, 0 );
						bu_vls_printf( &str,
		      "not enough values for \"%s\" argument: should have %d",
							       sdp->sp_name,
							       sdp->sp_count );
						Tcl_AppendResult( interp,
							    bu_vls_addr(&str),
							    (char *)NULL );
						bu_vls_free( &str );
						return TCL_ERROR;
					}

					BU_SP_SKIP_SEP(cp);
					tmpi = atoi( cp );
					if( *cp && (*cp == '+' || *cp == '-') )
						cp++;
					while( *cp && isdigit(*cp) )
						cp++; 
					/* make sure we actually had an
					 * integer out there
					 */

					if( cp == *argv ||
					    (cp == *argv+1 &&
					     (argv[0][0] == '+' ||
					      argv[0][0] == '-')) ) {
						bu_vls_trunc( &str, 0 );
						bu_vls_printf( &str, 
			       "value \"%s\" to argument %s isn't an integer",
							       argv,
							       sdp->sp_name );
						Tcl_AppendResult( interp,
							    bu_vls_addr(&str),
							    (char *)NULL );
						bu_vls_free( &str );
						return TCL_ERROR;
					} else {
						*(ip++) = tmpi;
					}
					BU_SP_SKIP_SEP(cp);
				}
				Tcl_AppendResult( interp,
						  sdp->sp_count > 1 ? "{" : "",
						  argv[0],
						  sdp->sp_count > 1 ? "}" : "",
						  " ", (char *)NULL);
				break; }
			case 'f': {
				int		dot_seen;
				double		tmp_double;
				register double *dp;
				char		*numstart;

				dp = (double *)loc;

				if( argc < 1 ) {
					bu_vls_trunc( &str, 0 );
					bu_vls_printf( &str,
       "not enough values for \"%s\" argument: should have %d, only %d given",
						       sdp->sp_name,
						       sdp->sp_count, argc );
					Tcl_AppendResult( interp,
							  bu_vls_addr(&str),
							  (char *)NULL );
					bu_vls_free( &str );
					return TCL_ERROR;
				}

				Tcl_AppendResult( interp, sdp->sp_name, " ",
						  (char *)NULL );

				cp = *argv;
				for( ii = 0; ii < sdp->sp_count; ii++ ) {
					if( *cp == '\0' ) {
						bu_vls_trunc( &str, 0 );
						bu_vls_printf( &str,
       "not enough values for \"%s\" argument: should have %d, only %d given",
							       sdp->sp_name,
							       sdp->sp_count,
							       ii );
						Tcl_AppendResult( interp,
							    bu_vls_addr(&str),
							    (char *)NULL );
						bu_vls_free( &str );
						return TCL_ERROR;
					}
					
					BU_SP_SKIP_SEP(cp);
					numstart = cp;
					if( *cp == '-' || *cp == '+' ) cp++;

					/* skip matissa */
					dot_seen = 0;
					for( ; *cp ; cp++ ) {
						if( *cp == '.' && !dot_seen ) {
							dot_seen = 1;
							continue;
						}
						if( !isdigit(*cp) )
							break;
					}

					/* If no mantissa seen,
					   then there is no float here */
					if( cp == (numstart + dot_seen) ) {
						bu_vls_trunc( &str, 0 );
						bu_vls_printf( &str, 
	                           "value \"%s\" to argument %s isn't a float",
							       argv[0],
							       sdp->sp_name );
						Tcl_AppendResult( interp,
							    bu_vls_addr(&str),
							    (char *)NULL );
						bu_vls_free( &str );
						return TCL_ERROR;
					}

					/* there was a mantissa,
					   so we may have an exponent */
					if( *cp == 'E' || *cp == 'e' ) {
						cp++;

						/* skip exponent sign */
						if (*cp == '+' || *cp == '-')
							cp++;
						while( isdigit(*cp) )
							cp++;
					}

					bu_vls_trunc( &str, 0 );
					bu_vls_strcpy( &str, numstart );
					bu_vls_trunc( &str, cp-numstart );
					if( sscanf(bu_vls_addr(&str),
						   "%lf", &tmp_double) != 1 ) {
						bu_vls_trunc( &str, 0 );
						bu_vls_printf( &str, 
				  "value \"%s\" to argument %s isn't a float",
							       numstart,
							       sdp->sp_name );
						Tcl_AppendResult( interp,
							    bu_vls_addr(&str),
							    (char *)NULL );
						bu_vls_free( &str );
						return TCL_ERROR;
					}
					
					*dp++ = tmp_double;

					BU_SP_SKIP_SEP(cp);
				}
				Tcl_AppendResult( interp,
						  sdp->sp_count > 1 ? "{" : "",
						  argv[0],
						  sdp->sp_count > 1 ? "}" : "",
						  " ", (char *)NULL );
				break; }
			default: {
				struct bu_vls vls;

				bu_vls_init(&vls);
				bu_vls_printf(&vls,
				"%s line:%d Parse error, unknown format: '%s' for element \"%s\"",
				__FILE__, __LINE__, sdp->sp_fmt,
				sdp->sp_name);

				Tcl_AppendResult( interp, bu_vls_addr(&vls),
					(char *)NULL );

				bu_vls_free( &vls );
				return TCL_ERROR;
				}
			}

			if( sdp->sp_hook )  {
				sdp->sp_hook( sdp, sdp->sp_name, base, *argv);

			}
			--argc;
			++argv;


			break;
		}
		

		if( sdp->sp_name == NULL ) {
			bu_vls_trunc( &str, 0 );
			bu_vls_printf( &str, "invalid attribute %s\n", argv[0] );
			Tcl_AppendResult( interp, bu_vls_addr(&str),
					  (char *)NULL );
			bu_vls_free( &str );
			return TCL_ERROR;
		}
	}
	return TCL_OK;
}

/*****f* libbu/bu_tcl.c
 *
 * NAME
 *	bu_tcl_mem_barriercheck
 *
 * SYNOPSIS
 *	A tcl wrapper for bu_mem_barriercheck.
 *
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
 *
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_tcl_mem_barriercheck(ClientData	clientData,
			Tcl_Interp	*interp,
			int		argc,
			char		**argv)
{
	int	ret;

	ret = bu_mem_barriercheck();
	if (ret < 0) {
		Tcl_AppendResult(interp, "bu_mem_barriercheck() failed\n", NULL);
		return TCL_ERROR;
	}
	return TCL_OK;
}

/*****f* libbu/bu_tcl.c
 *
 * NAME
 *	bu_tcl_ck_malloc_ptr
 *
 * SYNOPSIS
 *	A tcl wrapper for bu_ck_malloc_ptr.
 *
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
 *
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_tcl_ck_malloc_ptr(ClientData		clientData,
		     Tcl_Interp		*interp,
		     int		argc,
		     char		**argv)
{
	if( argc != 3 )  {
		Tcl_AppendResult( interp, "Usage: bu_ck_malloc_ptr ascii-ptr description\n");
		return TCL_ERROR;
	}
	bu_ck_malloc_ptr( (void *)atoi(argv[1]), argv[2] );
	return TCL_OK;
}

/*****f* libbu/bu_tcl.c
 *
 * NAME
 *	bu_tcl_malloc_len_roundup
 *
 * SYNOPSIS
 *	A tcl wrapper for bu_malloc_len_roundup.
 *
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
 *
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_tcl_malloc_len_roundup(ClientData	clientData,
			  Tcl_Interp	*interp,
			  int		argc,
			  char		**argv)
{
	int	val;

	if( argc != 2 )  {
		Tcl_AppendResult(interp, "Usage: bu_malloc_len_roundup nbytes\n", NULL);
		return TCL_ERROR;
	}
	val = bu_malloc_len_roundup(atoi(argv[1]));
	sprintf(interp->result, "%d", val);
	return TCL_OK;
}

/*****f* libbu/bu_tcl.c
 *
 * NAME
 *	bu_tcl_prmem
 *
 * SYNOPSIS
 *	A tcl wrapper for bu_prmem. Prints map of
 *	memory currently in use, to stderr.
 *
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
 *
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_tcl_prmem(ClientData	clientData,
	     Tcl_Interp	*interp,
	     int	argc,
	     char	**argv)
{
	if (argc != 2) {
		Tcl_AppendResult(interp, "Usage: bu_prmem title\n");
		return TCL_ERROR;
	}
	bu_prmem(argv[1]);
	return TCL_OK;
}

/*****f* libbu/bu_tcl.c
 *
 * NAME
 *	bu_tcl_printb
 *
 * SYNOPSIS
 *	A tcl wrapper for bu_vls_printb.
 *
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
 *
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_tcl_printb(ClientData	clientData,
	      Tcl_Interp	*interp,
	      int		argc,
	      char		**argv)
{
	struct bu_vls	str;

	if (argc != 4) {
		Tcl_AppendResult(interp, "Usage: bu_printb title integer-to-format bit-format-string\n", NULL);
		return TCL_ERROR;
	}
	bu_vls_init(&str);
	bu_vls_printb(&str, argv[1], atoi(argv[2]), argv[3]);
	Tcl_SetResult(interp, bu_vls_addr(&str), TCL_VOLATILE);
	bu_vls_free(&str);
	return TCL_OK;
}

/*****f* libbu/bu_tcl.c
 *
 * NAME
 *	bu_get_value_by_keyword
 *
 * SYNOPSIS
 *	Given arguments of alternating keywords and values
 *	and a specific keyword ("Iwant"),
 *	return the value associated with that keyword.
 *
 *	example:  bu_get_value_by_keyword Iwant az 35 elev 25 temp 9.6
 *
 *	If only one argument is given after the search keyword, it is interpreted
 *	as a list in the same format.
 *
 *	example:  bu_get_value_by_keyword Iwant {az 35 elev 25 temp 9.6}
 *
 *	Search order is left-to-right, only first match is returned.
 *
 *	Sample use:
 *		bu_get_value_by_keyword V8 [concat type [.inmem get box.s]]
 *
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
 *
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_get_value_by_keyword(ClientData	clientData,
			Tcl_Interp	*interp,
			int		argc,
			char		**argv)
{
	int	listc;
	char	**listv;
	register char	*iwant;
	char	**tofree = (char **)NULL;
	int	i;

	if( argc < 3 )  {
		char	buf[32];
		sprintf(buf, "%d", argc);
		Tcl_AppendResult( interp,
			"bu_get_value_by_keyword: wrong # of args (", buf, ").\n",
			"Usage: bu_get_value_by_keyword iwant {list}\n",
			"Usage: bu_get_value_by_keyword iwant key1 val1 key2 val2 ... keyN valN\n",
			(char *)NULL );
		return TCL_ERROR;
	}

	iwant = argv[1];

	if( argc == 3 )  {
		if( Tcl_SplitList( interp, argv[2], &listc, (const char ***)&listv ) != TCL_OK )  {
			Tcl_AppendResult( interp,
				"bu_get_value_by_keyword: iwant='", iwant,
				"', unable to split '",
				argv[2], "'\n", (char *)NULL );
			return TCL_ERROR;
		}
		tofree = listv;
	} else {
		/* Take search list from remaining arguments */
		listc = argc - 2;
		listv = argv + 2;
	}

	if( (listc & 1) != 0 )  {
		char	buf[32];
		sprintf(buf, "%d", listc);
		Tcl_AppendResult( interp,
			"bu_get_value_by_keyword: odd # of items in list (", buf, ").\n",
			(char *)NULL );
		if(tofree) free( (char *)tofree );	/* not bu_free() */
		return TCL_ERROR;
	}

	for( i=0; i < listc; i += 2 )  {
		if( strcmp( iwant, listv[i] ) == 0 )  {
			/* If value is a list, don't nest it in another list */
			if( listv[i+1][0] == '{' )  {
				struct bu_vls	str;
				bu_vls_init( &str );
				/* Skip leading { */
				bu_vls_strcat( &str, &listv[i+1][1] );
				/* Trim trailing } */
				bu_vls_trunc( &str, -1 );
				Tcl_AppendResult( interp,
					bu_vls_addr(&str), (char *)NULL );
				bu_vls_free( &str );
			} else {
				Tcl_AppendResult( interp, listv[i+1], (char *)NULL );
			}
			if(tofree) free( (char *)tofree );	/* not bu_free() */
			return TCL_OK;
		}
	}
	
	/* Not found */
	Tcl_AppendResult( interp, "bu_get_value_by_keyword: keyword '",
		iwant, "' not found in list\n", (char *)NULL );
	if(tofree) free( (char *)tofree );	/* not bu_free() */
	return TCL_ERROR;
}

/*****f* libbu/bu_tcl.c
 *
 * NAME
 *	bu_get_all_keyword_values
 *
 * SYNOPSIS
 *	Given arguments of alternating keywords and values,
 *	establish local variables named after the keywords, with the
 *	indicated values. Returns in interp a list of the variable
 *	names that were assigned to. This lets you detect at runtime
 *	what assignments were actually performed.
 *
 *	example:  bu_get_all_keyword_values az 35 elev 25 temp 9.6
 *
 *	This is much faster than writing this in raw Tcl 8 as:
 *
 *	foreach {keyword value} $list {
 *		set $keyword $value
 *		lappend retval $keyword
 *	}
 *
 *	If only one argument is given it is interpreted
 *	as a list in the same format.
 *
 *	example:  bu_get_all_keyword_values {az 35 elev 25 temp 9.6}
 *
 *	For security reasons, the name of the local variable assigned to
 *	is that of the input keyword with "key_" prepended.
 *	This prevents a playful user from overriding variables inside
 *	the function, e.g. loop iterator "i", etc.
 *	This could be even worse when called in global context.
 *
 *	Processing order is left-to-right, rightmost value for a repeated
 *	keyword will be the one used.
 *
 *	Sample use:
 *		bu_get_all_keyword_values [concat type [.inmem get box.s]]
 *
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
 *
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_get_all_keyword_values(ClientData	clientData,
			  Tcl_Interp	*interp,
			  int		argc,
			  char		**argv)
{
	struct bu_vls	variable;
	int	listc;
	char	**listv;
	char	**tofree = (char **)NULL;
	int	i;

	if( argc < 2 )  {
		char	buf[32];
		sprintf(buf, "%d", argc);
		Tcl_AppendResult( interp,
			"bu_get_all_keyword_values: wrong # of args (", buf, ").\n",
			"Usage: bu_get_all_keyword_values {list}\n",
			"Usage: bu_get_all_keyword_values key1 val1 key2 val2 ... keyN valN\n",
			(char *)NULL );
		return TCL_ERROR;
	}

	if( argc == 2 )  {
		if( Tcl_SplitList( interp, argv[1], &listc, (const char ***)&listv ) != TCL_OK )  {
			Tcl_AppendResult( interp,
				"bu_get_all_keyword_values: unable to split '",
				argv[1], "'\n", (char *)NULL );
			return TCL_ERROR;
		}
		tofree = listv;
	} else {
		/* Take search list from remaining arguments */
		listc = argc - 1;
		listv = argv + 1;
	}

	if( (listc & 1) != 0 )  {
		char	buf[32];
		sprintf(buf, "%d", listc);
		Tcl_AppendResult( interp,
			"bu_get_all_keyword_values: odd # of items in list (",
			buf, "), aborting.\n",
			(char *)NULL );
		if(tofree) free( (char *)tofree );	/* not bu_free() */
		return TCL_ERROR;
	}


	/* Process all the pairs */
	bu_vls_init( &variable );
	for( i=0; i < listc; i += 2 )  {
		bu_vls_strcpy( &variable, "key_" );
		bu_vls_strcat( &variable, listv[i] );
		/* If value is a list, don't nest it in another list */
		if( listv[i+1][0] == '{' )  {
			struct bu_vls	str;
			bu_vls_init( &str );
			/* Skip leading { */
			bu_vls_strcat( &str, &listv[i+1][1] );
			/* Trim trailing } */
			bu_vls_trunc( &str, -1 );
			Tcl_SetVar( interp, bu_vls_addr(&variable),
				bu_vls_addr(&str), 0);
			bu_vls_free( &str );
		} else {
			Tcl_SetVar( interp, bu_vls_addr(&variable),
				listv[i+1], 0 );
		}
		Tcl_AppendResult( interp, bu_vls_addr(&variable),
			" ", (char *)NULL );
		bu_vls_trunc( &variable, 0 );
	}
	
	/* All done */
	bu_vls_free( &variable );
	if(tofree) free( (char *)tofree );	/* not bu_free() */
	return TCL_OK;
}

/*****f* libbu/bu_tcl.c
 *
 * NAME
 *	bu_tcl_rgb_to_hsv
 *
 * SYNOPSIS
 *	A tcl wrapper for bu_rgb_to_hsv.
 *
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
 *
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
 */
/*
 *			B U _ T C L _ R G B _ T O _ H S V
 */
int
bu_tcl_rgb_to_hsv(ClientData	clientData,
		  Tcl_Interp	*interp,
		  int		argc,
		  char		**argv)
{
	int		rgb_int[3];
	unsigned char	rgb[3];
	fastf_t		hsv[3];
	struct bu_vls	result;

	bu_vls_init(&result);
	if( argc != 4 )  {
		Tcl_AppendResult( interp, "Usage: bu_rgb_to_hsv R G B\n",
		    (char *)NULL );
		return TCL_ERROR;
	}
	if (( Tcl_GetInt( interp, argv[1], &rgb_int[0] ) != TCL_OK )
	    || ( Tcl_GetInt( interp, argv[2], &rgb_int[1] ) != TCL_OK )
	    || ( Tcl_GetInt( interp, argv[3], &rgb_int[2] ) != TCL_OK )
	    || ( rgb_int[0] < 0 ) || ( rgb_int[0] > 255 )
	    || ( rgb_int[1] < 0 ) || ( rgb_int[1] > 255 )
	    || ( rgb_int[2] < 0 ) || ( rgb_int[2] > 255 )) {
		bu_vls_printf(&result, "bu_rgb_to_hsv: Bad RGB (%s, %s, %s)\n",
			      argv[1], argv[2], argv[3]);
		Tcl_AppendResult(interp, bu_vls_addr(&result), (char *)NULL);
		bu_vls_free(&result);
		return TCL_ERROR;
	}
	rgb[0] = rgb_int[0];
	rgb[1] = rgb_int[1];
	rgb[2] = rgb_int[2];

	bu_rgb_to_hsv( rgb, hsv );
	bu_vls_printf(&result, "%g %g %g", V3ARGS(hsv));
	Tcl_AppendResult(interp, bu_vls_addr(&result), (char *)NULL);
	bu_vls_free(&result);
	return TCL_OK;
	
}

/*****f* libbu/bu_tcl.c
 *
 * NAME
 *	bu_tcl_hsv_to_rgb
 *
 * SYNOPSIS
 *	A tcl wrapper for bu_hsv_to_rgb.
 *
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
 *
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_tcl_hsv_to_rgb(ClientData	clientData,
		  Tcl_Interp	*interp,
		  int		argc,
		  char		**argv)
{
	fastf_t		hsv[3];
	unsigned char	rgb[3];
	struct bu_vls	result;

	if( argc != 4 )  {
		Tcl_AppendResult( interp, "Usage: bu_hsv_to_rgb H S V\n",
		    (char *)NULL );
		return TCL_ERROR;
	}
	bu_vls_init(&result);
	if (( Tcl_GetDouble( interp, argv[1], &hsv[0] ) != TCL_OK )
	 || ( Tcl_GetDouble( interp, argv[2], &hsv[1] ) != TCL_OK )
	 || ( Tcl_GetDouble( interp, argv[3], &hsv[2] ) != TCL_OK )
	 || ( bu_hsv_to_rgb( hsv, rgb ) == 0) ) {
		bu_vls_printf(&result, "bu_hsv_to_rgb: Bad HSV (%s, %s, %s)\n",
		    argv[1], argv[2], argv[3]);
		Tcl_AppendResult(interp, bu_vls_addr(&result), (char *)NULL);
		bu_vls_free(&result);
		return TCL_ERROR;
	}

	bu_vls_printf(&result, "%d %d %d", V3ARGS(rgb));
	Tcl_AppendResult(interp, bu_vls_addr(&result), (char *)NULL);
	bu_vls_free(&result);
	return TCL_OK;
	
}

/*****f* libbu/bu_tcl.c
 *
 * NAME
 *	bu_tcl_key_eq_to_key_val
 *
 * SYNOPSIS
 *	Converts key=val to "key val" pairs.
 *
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
 *
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_tcl_key_eq_to_key_val(ClientData	clientData,
			 Tcl_Interp	*interp,
			 int		argc,
			 char		**argv)
{
	struct bu_vls vls;
	char *next;
	int i=0;

	bu_vls_init( &vls );

	while( ++i < argc )
	{
		if( bu_key_eq_to_key_val( argv[i], &next, &vls ) )
		{
			bu_vls_free( &vls );
			return TCL_ERROR;
		}

		if( i < argc - 1 )
			Tcl_AppendResult(interp, bu_vls_addr( &vls ) , " ", NULL );
		else
			Tcl_AppendResult(interp, bu_vls_addr( &vls ), NULL );

		bu_vls_trunc( &vls, 0 );
	}

	bu_vls_free( &vls );
	return TCL_OK;

}

/*****f* libbu/bu_tcl.c
 *
 * NAME
 *	bu_tcl_shader_to_key_val
 *
 * SYNOPSIS
 *	Converts a shader string to a tcl list.
 *
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
 *
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_tcl_shader_to_key_val(ClientData	clientData,
			 Tcl_Interp	*interp,
			 int		argc,
			 char		**argv)
{
	struct bu_vls vls;

	bu_vls_init( &vls );

	if( bu_shader_to_tcl_list( argv[1], &vls ) )
	{
		bu_vls_free( &vls );
		return( TCL_ERROR );
	}

	Tcl_AppendResult(interp, bu_vls_addr( &vls ), NULL );

	bu_vls_free( &vls );

	return TCL_OK;

}

/*****f* libbu/bu_tcl.c
 *
 * NAME
 *	bu_tcl_key_val_to_key_eq
 *
 * SYNOPSIS
 *	Converts "key value" pairs to key=value.
 *
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
 *
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_tcl_key_val_to_key_eq(ClientData	clientData,
			 Tcl_Interp	*interp,
			 int		argc,
			 char		**argv)
{
	int i=0;

	for( i=1 ; i<argc ; i += 2 )
	{
		if( i+1 < argc-1 )
			Tcl_AppendResult(interp, argv[i], "=", argv[i+1], " ", NULL );
		else
			Tcl_AppendResult(interp, argv[i], "=", argv[i+1], NULL );

	}
	return TCL_OK;

}

/*****f* libbu/bu_tcl.c
 *
 * NAME
 *	bu_tcl_shader_to_key_eq
 *
 * SYNOPSIS
 *	Converts a shader tcl list into a shader string.
 *
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
 *
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_tcl_shader_to_key_eq(ClientData	clientData,
			Tcl_Interp	*interp,
			int		argc,
			char		**argv)
{
	struct bu_vls vls;


	bu_vls_init( &vls );

	if( bu_shader_to_key_eq( argv[1], &vls ) )
	{
		bu_vls_free( &vls );
		return TCL_ERROR;
	}

	Tcl_AppendResult(interp, bu_vls_addr( &vls ), NULL );

	bu_vls_free( &vls );

	return TCL_OK;
}

/*****f* libbu/bu_tcl.c
 *
 * NAME
 *	bu_tcl_brlcad_path
 *
 * SYNOPSIS
 *	A tcl wrapper for bu_brlcad_path.
 *
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
 *
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_tcl_brlcad_path(ClientData	clientData,
		   Tcl_Interp	*interp,
		   int		 argc,
		   char		**argv)
{
	if (argc != 2) {
		Tcl_AppendResult(interp, "Usage: bu_brlcad_path subdir\n",
				 (char *)NULL);
		return TCL_ERROR;
	}
	Tcl_AppendResult(interp, bu_brlcad_path(argv[1]), NULL);
	return TCL_OK;
}

/*****f* libbu/bu_tcl.c
 *
 * NAME
 *	bu_tcl_units_conversion
 *
 * SYNOPSIS
 *	A tcl wrapper for bu_units_conversion.
 *
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
 *
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_tcl_units_conversion(ClientData	clientData,
			Tcl_Interp	*interp,
			int		argc,
			char		**argv)
{
	double conv_factor;
	struct bu_vls result;

	if (argc != 2) {
		Tcl_AppendResult(interp, "Usage: bu_units_conversion units_string\n",
				 (char *)NULL);
		return TCL_ERROR;
	}

	conv_factor = bu_units_conversion(argv[1]);
	if (conv_factor == 0.0) {
		Tcl_AppendResult(interp, "ERROR: bu_units_conversion: Unrecognized units string: ",
				 argv[1], "\n", (char *)NULL);
		return TCL_ERROR;
	}

	bu_vls_init(&result);
	bu_vls_printf(&result, "%.12e", conv_factor);
	Tcl_AppendResult(interp, bu_vls_addr(&result), (char *)NULL);
	bu_vls_free(&result);
	return TCL_OK;
}

/*****f* libbu/bu_tcl.c
 *
 * NAME
 *	bu_tcl_setup
 *
 * SYNOPSIS
 *	Add all the supported Tcl interfaces to LIBBU routines to
 *	the list of commands known by the given interpreter.
 *
 * PARAMETERS
 *	interp		- tcl interpreter in which this command was registered.
 *
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
 */
void
bu_tcl_setup(Tcl_Interp *interp)
{
	bu_register_cmds(interp, bu_cmds);

	Tcl_SetVar(interp, "bu_version", (char *)bu_version+5, TCL_GLOBAL_ONLY);	/* from vers.c */
	Tcl_SetVar(interp, "BU_DEBUG_FORMAT", BU_DEBUG_FORMAT, TCL_GLOBAL_ONLY);
	Tcl_LinkVar(interp, "bu_debug", (char *)&bu_debug, TCL_LINK_INT );

	/* initialize command history objects */
	Cho_Init(interp);
}

/*****f* libbu/bu_tcl.c
 *
 * NAME
 *	Bu_Init
 *
 * SYNOPSIS
 *	Allows LIBBU to be dynamically loaded to a vanilla tclsh/wish with
 *	"load /usr/brlcad/lib/libbu.so"
 *
 * PARAMETERS
 *	interp		- tcl interpreter in which this command was registered.
 *
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
Bu_Init(Tcl_Interp *interp)
{
	bu_tcl_setup(interp);
#if 0
	bu_hook_list_init(&bu_log_hook_list);
	bu_hook_list_init(&bu_bomb_hook_list);
#endif
	return TCL_OK;
}
@


1.38
log
@change conf.h to a wrapped config.h
@
text
@d29 1
a29 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvs/brlcad/libbu/bu_tcl.c,v 1.37 2004/04/05 07:46:16 morrison Exp $ (ARL)";
@


1.37
log
@merge of ansi-6-0-branch into HEAD
@
text
@d29 6
a34 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header$ (ARL)";
a37 1
#include "conf.h"
@


1.36
log
@update copyright to include span through 2003
@
text
@d29 1
a29 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bu_tcl.c,v 1.35 2003/04/01 14:17:38 jra Exp $ (ARL)";
d52 1
a52 1
extern int Cho_Init();
d99 1
a99 1
		long		magic,
@


1.35
log
@Added some const casts to quiet the compiler
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1998 by the United States Army
d29 1
a29 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bu_tcl.c,v 1.34 2002/08/20 17:07:39 jra Exp $ (ARL)";
@


1.35.6.1
log
@merge from HEAD
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d29 1
a29 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bu_tcl.c,v 1.36 2004/02/02 17:39:07 morrison Exp $ (ARL)";
@


1.35.6.2
log
@merge from head
@
text
@d29 1
a29 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bu_tcl.c,v 1.35.6.1 2004/02/12 18:39:18 erikg Exp $ (ARL)";
@


1.34
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d29 1
a29 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bu_tcl.c,v 1.32 2001/11/02 04:59:21 butler Exp $ (ARL)";
d861 1
a861 1
		if( Tcl_SplitList( interp, argv[2], &listc, &listv ) != TCL_OK )  {
d984 1
a984 1
		if( Tcl_SplitList( interp, argv[1], &listc, &listv ) != TCL_OK )  {
@


1.34.4.1
log
@sync to HEAD...
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d29 1
a29 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libbu/bu_tcl.c,v 1.36 2004/02/02 17:39:07 morrison Exp $ (ARL)";
d861 1
a861 1
		if( Tcl_SplitList( interp, argv[2], &listc, (const char ***)&listv ) != TCL_OK )  {
d984 1
a984 1
		if( Tcl_SplitList( interp, argv[1], &listc, (const char ***)&listv ) != TCL_OK )  {
@


1.34.2.1
log
@Initial ANSIfication
@
text
@d29 1
a29 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bu_tcl.c,v 1.34 2002/08/20 17:07:39 jra Exp $ (ARL)";
d52 1
a52 1
extern int Cho_Init(Tcl_Interp *interp);
@


1.34.2.2
log
@sync branch with HEAD
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d29 1
a29 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header$ (ARL)";
d861 1
a861 1
		if( Tcl_SplitList( interp, argv[2], &listc, (const char ***)&listv ) != TCL_OK )  {
d984 1
a984 1
		if( Tcl_SplitList( interp, argv[1], &listc, (const char ***)&listv ) != TCL_OK )  {
@


1.34.2.3
log
@more quelling of lots of warnings
@
text
@d29 1
a29 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libbu/bu_tcl.c,v 1.34.2.2 2004/03/17 21:16:49 morrison Exp $ (ARL)";
d99 1
a99 1
		unsigned long	magic,
@


1.33
log
@Converted from K&R to ANSI C - RFH
@
text
@d52 1
a52 1
extern int Cho_Init(Tcl_Interp *interp);
@


1.32
log
@added support for "%i"
@
text
@d29 1
a29 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bu_tcl.c,v 1.31 2001/04/20 22:29:05 morrison Exp $ (ARL)";
d52 1
a52 1
extern int Cho_Init();
@


1.31
log
@CONST to const
@
text
@d29 1
a29 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bu_tcl.c,v 1.30 2001/04/11 17:49:03 bparker Exp $ (ARL)";
d313 1
d321 85
@


1.30
log
@*- add comments
*- use struct bu_cmdtab and bu_register_cmds()
@
text
@d29 1
a29 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bu_tcl.c,v 1.29 2000/09/08 14:22:54 bparker Exp $ (ARL)";
d98 1
a98 1
		CONST long	*ptr,
d100 2
a101 2
		CONST char	*str,
		CONST char	*file,
d223 1
a223 1
		    CONST struct bu_structparse	*desc,
d227 1
a227 1
	register CONST struct bu_structparse	*sdp;
d323 1
a323 1
				register char CONST *cp;
@


1.29
log
@Nothing.
@
text
@d1 4
a4 2
/*
 *			B U _ T C L . C
d6 2
a7 1
 *  Tcl interfaces to all the LIBBU Basic BRL-CAD Utility routines.
d9 2
a10 2
 *  Remember that in MGED you need to say "set glob_compat_mode 0"
 *  to get [] to work with TCL semantics rather than MGED glob semantics.
d12 1
a12 1
 *  Author -
d15 1
a15 1
 *  Source -
d19 1
a19 1
 *  Distribution Notice -
d24 1
a24 1
 *  Copyright Notice -
d29 1
a29 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bu_tcl.c,v 1.28 2000/08/11 03:21:26 mike Exp $ (ARL)";
d47 1
a47 1
#include "bu.h"
d54 40
a93 2
/*
 *			B U _ B A D M A G I C _ T C L
d97 6
a102 7
bu_badmagic_tcl( interp, ptr, magic, str, file, line )
Tcl_Interp	*interp;
CONST long	*ptr;
long		magic;
CONST char	*str;
CONST char	*file;
int		line;
d106 1
a106 1
	if( !(ptr) )  { 
d108 1
a108 1
			str, file, line ); 
d112 1
a112 1
	if( *((long *)(ptr)) != (magic) )  { 
d117 1
a117 1
			file, line ); 
d125 10
a134 2
/*
 *		B U _ S T R U C T P A R S E _ G E T _ T E R S E _ F O R M
d136 2
a137 2
 *  Convert the "form" of a bu_structparse table into a TCL result string,
 *  with parameter-name data-type pairs:
d139 3
a141 1
 *	V {%f %f %f} A {%f %f %f}
d143 2
a144 2
 *  A different routine should build a more general 'form', along the
 *  lines of {V {%f %f %f} default {help}} {A {%f %f %f} default# {help}}
d147 2
a148 3
bu_structparse_get_terse_form(interp, sp)
Tcl_Interp *interp;
register struct bu_structparse *sp;
d150 2
a151 2
	struct bu_vls str;
	int	i;
d162 1
a162 1
			if (sp->sp_count > 1)  {
d181 11
a191 1
/* Skip the separator(s) */
d196 4
a199 3

/*
 *			B U _ S T R U C T P A R S E _ A R G V
d201 14
a214 4
 * Support routine for db adjust and db put.  Much like bu_structparse routine,
 * but takes the arguments as lists, a more Tcl-friendly method.
 * Also knows about the Tcl result string, so it can make more informative
 * error messages.
d216 2
a217 1
 *  Operates on argv[0] and argv[1], then on argv[2] and argv[3], ...
a218 1

d220 5
a224 6
bu_structparse_argv( interp, argc, argv, desc, base )
Tcl_Interp			*interp;
int				 argc;
char			       **argv;
CONST struct bu_structparse	*desc;		/* structure description */
char				*base;		/* base addr of users struct */
d232 3
a234 3
	if( desc == (struct bu_structparse *)NULL ) {
		bu_log( "bu_structparse_argv: NULL desc pointer\n" );
		Tcl_AppendResult( interp, "NULL desc pointer", (char *)NULL );
d240 2
a241 2
	bu_vls_init( &str );
	while( argc > 0 ) {
d243 2
a244 2
		for( sdp = desc; sdp->sp_name != NULL; sdp++ ) {
			if( strcmp(sdp->sp_name, *argv) != 0 )
d256 5
a260 5
			if( sdp->sp_fmt[0] != '%' ) {
				bu_log( "bu_structparse_argv: unknown format\n" );
				bu_vls_free( &str );
				Tcl_AppendResult( interp, "unknown format",
						  (char *)NULL );
d267 1
a267 1
			switch( sdp->sp_fmt[1] )  {
d273 10
a282 10
				if( argc < 1 ) {
					bu_vls_trunc( &str, 0 );
					bu_vls_printf( &str,
			 "not enough values for \"%s\" argument: should be %d",
						       sdp->sp_name,
						       sdp->sp_count );
					Tcl_AppendResult( interp,
							  bu_vls_addr(&str),
							  (char *)NULL );
					bu_vls_free( &str );
d285 1
a285 1
				for( ii = j = 0;
d287 1
a287 1
				     loc[j++] = argv[0][ii++] )
d289 1
a289 1
				if( ii < sdp->sp_count )
d291 1
a291 1
				if( sdp->sp_count > 1 ) {
d293 4
a296 4
					Tcl_AppendResult( interp,
							  sdp->sp_name, " ",
							  loc, " ",
							  (char *)NULL );
d298 6
a303 6
					bu_vls_trunc( &str, 0 );
					bu_vls_printf( &str, "%s %c ",
						       sdp->sp_name, *loc );
					Tcl_AppendResult( interp,
							  bu_vls_addr(&str),
							  (char *)NULL );
d552 16
a567 2
/*
 *			B U _ T C L _ M E M _ B A R R I E R C H E C K
d570 4
a573 5
bu_tcl_mem_barriercheck(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d578 1
a578 1
	if( ret < 0 )  {
d585 16
a600 2
/*
 *			B U _ T C L _ C K _ M A L L O C _ P T R
d603 4
a606 5
bu_tcl_ck_malloc_ptr(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d616 16
a631 2
/*
 *			B U _ T C L _ M A L L O C _ L E N _ R O U N D U P
d634 4
a637 5
bu_tcl_malloc_len_roundup(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d650 14
a663 2
/*
 *			B U _ T C L _ P R M E M
d665 2
a666 1
 *  Print map of memory currently in use, to stderr.
d669 4
a672 5
bu_tcl_prmem(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d674 1
a674 1
	if( argc != 2 )  {
d682 16
a697 2
/*
 *			B U _ T C L _ P R I N T B
d700 4
a703 5
bu_tcl_printb(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d707 1
a707 1
	if( argc != 4 )  {
d712 2
a713 2
	bu_vls_printb( &str, argv[1], atoi(argv[2]), argv[3] );
	Tcl_SetResult( interp, bu_vls_addr(&str), TCL_VOLATILE );
d718 4
a721 2
/*
 *			B U _ G E T _ V A L U E _ B Y _ K E Y W O R D
d723 4
a726 3
 *  Given arguments of alternating keywords and values
 *  and a specific keyword ("Iwant"),
 *  return the value associated with that keyword.
d730 2
a731 2
 *  If only one argument is given after the search keyword, it is interpreted
 *  as a list in the same format.
d735 4
a738 1
 *  Search order is left-to-right, only first match is returned.
d740 8
a747 2
 *  Sample use:
 *	 bu_get_value_by_keyword V8 [concat type [.inmem get box.s]]
d750 4
a753 5
bu_get_value_by_keyword(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d827 4
a830 2
/*
 *			B U _ G E T _ A L L _ K E Y W O R D _ V A L U E S
d832 6
a837 3
 *  Given arguments of alternating keywords and values,
 *  establish local variables named after the keywords, with the
 *  indicated values.
d841 1
a841 1
 *  This is much faster than writing this in raw Tcl 8 as:
d848 2
a849 2
 *  If only one argument is given it is interpreted
 *  as a list in the same format.
d853 20
a872 16
 *  For security reasons, the name of the local variable assigned to
 *  is that of the input keyword with "key_" prepended.
 *  This prevents a playful user from overriding variables inside
 *  the function, e.g. loop iterator "i", etc.
 *  This could be even worse when called in global context.
 *
 *  Processing order is left-to-right, rightmost value for a repeated
 *  keyword will be the one used.
 *
 *  Sample use:
 *	 bu_get_all_keyword_values [concat type [.inmem get box.s]]
 *
 *  Returns -
 *	List of variable names that were assigned to.
 *	This lets you detect at runtime what assignments
 *	were actually performed.
d875 4
a878 5
bu_get_all_keyword_values(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d954 17
d975 4
a978 5
bu_tcl_rgb_to_hsv(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d992 5
a996 6
	 || ( Tcl_GetInt( interp, argv[2], &rgb_int[1] ) != TCL_OK )
	 || ( Tcl_GetInt( interp, argv[3], &rgb_int[2] ) != TCL_OK )
	 || ( rgb_int[0] < 0 ) || ( rgb_int[0] > 255 )
	 || ( rgb_int[1] < 0 ) || ( rgb_int[1] > 255 )
	 || ( rgb_int[2] < 0 ) || ( rgb_int[2] > 255 ))
	 {
d998 1
a998 1
		    argv[1], argv[2], argv[3]);
d1015 16
a1030 2
/*
 *			B U _ T C L _ H S V _ T O _ R G B
d1033 4
a1036 5
bu_tcl_hsv_to_rgb(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d1066 17
d1084 4
a1087 5
bu_tcl_key_eq_to_key_val( clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d1116 17
d1134 4
a1137 5
bu_tcl_shader_to_key_val( clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d1157 17
d1175 4
a1178 5
bu_tcl_key_val_to_key_eq( clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d1194 17
d1212 4
a1215 5
bu_tcl_shader_to_key_eq( clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d1235 13
a1247 2
/*
 *			B U _ T C L _ B R L C A D _ P A T H
d1249 2
a1250 2
 *  Tcl access to library routine bu_brlcad_path(),
 *  which handles BRLCAD_ROOT issues for GUI code.
d1253 4
a1256 5
bu_tcl_brlcad_path( clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d1258 1
a1258 1
	if( argc != 2 )  {
d1260 1
a1260 1
			(char *)NULL );
d1263 1
a1263 1
	Tcl_AppendResult(interp, bu_brlcad_path( argv[1] ), NULL );
d1267 13
a1279 2
/*
 *			B U _ T C L _ U N I T S _ C O N V E R S I O N
d1281 2
a1282 1
 *	Tcl access to bu_units_comversion()
d1285 4
a1288 5
bu_tcl_units_conversion( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d1293 1
a1293 1
	if( argc != 2 )  {
d1295 1
a1295 1
			(char *)NULL );
d1299 2
a1300 3
	conv_factor = bu_units_conversion( argv[1] );
	if( conv_factor == 0.0 )
	{
d1302 2
a1303 2
			argv[1], "\n", (char *)NULL );
			return TCL_ERROR;
d1306 4
a1309 4
	bu_vls_init( &result );
	bu_vls_printf( &result, "%.12e", conv_factor );
	Tcl_AppendResult(interp, bu_vls_addr( &result ), (char *)NULL );
	bu_vls_free( &result );
d1313 11
a1323 2
/*
 *			B U _ T C L _ S E T U P
d1325 2
a1326 2
 *  Add all the supported Tcl interfaces to LIBBU routines to
 *  the list of commands known by the given interpreter.
d1329 1
a1329 2
bu_tcl_setup(interp)
Tcl_Interp *interp;
d1331 1
a1331 45
	(void)Tcl_CreateCommand(interp,
		"bu_units_conversion",	bu_tcl_units_conversion,
		(ClientData)0, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp,
		"bu_brlcad_path",	bu_tcl_brlcad_path,
		(ClientData)0, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp,
		"bu_mem_barriercheck",	bu_tcl_mem_barriercheck,
		(ClientData)0, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp,
		"bu_ck_malloc_ptr",	bu_tcl_ck_malloc_ptr,
		(ClientData)0, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp,
		"bu_malloc_len_roundup",bu_tcl_malloc_len_roundup,
		(ClientData)0, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp,
		"bu_prmem",		bu_tcl_prmem,
		(ClientData)0, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp,
		"bu_printb",		bu_tcl_printb,
		(ClientData)0, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp,
		"bu_get_all_keyword_values", bu_get_all_keyword_values,
		(ClientData)0, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp,
		"bu_get_value_by_keyword", bu_get_value_by_keyword,
		(ClientData)0, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp,
		"bu_rgb_to_hsv",	bu_tcl_rgb_to_hsv,
		(ClientData)0, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp,
		"bu_hsv_to_rgb",	bu_tcl_hsv_to_rgb,
		(ClientData)0, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp,
		"bu_key_eq_to_key_val",	bu_tcl_key_eq_to_key_val,
		(ClientData)0, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp,
		"bu_shader_to_tcl_list",	bu_tcl_shader_to_key_val,
		(ClientData)0, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp,
		"bu_key_val_to_key_eq",	bu_tcl_key_val_to_key_eq,
		(ClientData)0, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp,
		"bu_shader_to_key_eq",	bu_tcl_shader_to_key_eq,
		(ClientData)0, (Tcl_CmdDeleteProc *)NULL);
d1341 14
a1354 3
/*
 *  Allows LIBBU to be dynamically loaded to a vanilla tclsh/wish with
 *  "load /usr/brlcad/lib/libbu.so"
d1357 1
a1357 2
Bu_Init(interp)
Tcl_Interp *interp;
@


1.28
log
@
Enhanced bu_structparse_get_terse_form() to know about %S format.
@
text
@d26 1
a26 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bu_tcl.c,v 1.27 2000/07/07 05:21:20 cjohnson Exp $ (ARL)";
d1114 1
a1114 1
 *  Allows LIBBU to be dynamically loade to a vanilla tclsh/wish with
d1122 4
@


1.27
log
@LINT plus minor bug fix in bu_tcl.c
@
text
@d26 1
a26 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bu_tcl.c,v 1.26 2000/06/30 20:07:30 butler Exp $ (ARL)";
d109 1
d111 4
a114 2
		    strcmp(sp->sp_fmt, "%s") == 0) {
			if (sp->sp_count > 1)
d116 2
a117 1
			else
d119 1
d121 1
@


1.26
log
@Added support for VLS and hook functions
@
text
@d26 1
a26 1
static char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bu_tcl.c,v 1.25 2000/06/19 21:11:52 mike Exp $ (ARL)";
d39 1
d153 2
a154 1
	register int				 i, j;
d210 3
a212 3
				for( i = j = 0;
				     j < sdp->sp_count && argv[0][i] != '\0';
				     loc[j++] = argv[0][i++] )
d214 2
a215 2
				if( i < sdp->sp_count )
					loc[i] = '\0';
d250 1
a250 1
				if( argc < 1 ) {
d253 1
a253 1
      "not enough values for \"%s\" argument: should have %d, only %d given",
d255 1
a255 1
						       sdp->sp_count, i );
d278 1
a278 1
				for( i = 0; i < sdp->sp_count; ++i ) {
d352 1
a352 1
				for( i = 0; i < sdp->sp_count; i++ ) {
d359 1
a359 1
							       i );
@


1.25
log
@
Added macro for separator chatacters.
Added '{' as a separator, so that lists can be processed like arrays
on input.
@
text
@d26 1
a26 1
static char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bu_tcl.c,v 1.24 2000/04/17 20:39:37 jra Exp $ (ARL)";
a227 2
				--argc;
				++argv;
d229 6
a271 2
					++argv;
					--argc;
a323 2
				--argc;
				++argv;
a432 2
				--argc;
				++argv;
d434 13
a446 3
			default:
				Tcl_AppendResult( interp, "unknown format",
						  (char *)NULL );
d448 1
d450 9
d462 1
@


1.24
log
@Added bu_units_conversion command
@
text
@d26 1
a26 1
static char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bu_tcl.c,v 1.23 2000/04/13 14:36:52 mike Exp $ (ARL)";
d125 5
d288 1
a288 4
					while( (*cp == ' ' || *cp == '\n' ||
						*cp == '\t') && *cp )
						++cp;
			
d315 1
a315 4
					/* Skip the separator(s) */
					while( (*cp == ' ' || *cp == '\n' ||
						*cp == '\t') && *cp ) 
						++cp;
d365 1
a365 4
					while( (*cp == ' ' || *cp == '\n' ||
						*cp == '\t') && *cp )
						++cp;

d426 1
a426 3
					while( (*cp == ' ' || *cp == '\n' ||
						*cp == '\t') && *cp )
						++cp;
@


1.23
log
@
Added more comments
@
text
@d26 1
a26 1
static char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bu_tcl.c,v 1.22 2000/03/28 18:55:07 mike Exp $ (ARL)";
d993 36
d1038 3
@


1.22
log
@
Put libbu_filename_ prefixes on RCSid variables.
@
text
@d26 1
a26 1
static char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bu_tcl.c,v 1.21 2000/03/22 02:15:43 mike Exp $ (ARL)";
d87 1
a87 1
 *  Convert the "form" of a bu_structparse tabel into a TCL result string,
d89 1
d670 7
@


1.21
log
@
Added Bu_Init() to allow use with Tcl "load" comand.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bu_tcl.c,v 1.20 2000/02/04 14:30:57 bparker Exp $ (ARL)";
@


1.20
log
@*- initialize command history objects
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bu_tcl.c,v 1.19 1999/12/29 20:18:24 jra Exp $ (ARL)";
d1043 12
@


1.19
log
@Elminated an unused variable
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bu_tcl.c,v 1.18 1999/11/18 02:41:55 mike Exp $ (ARL)";
d47 3
d1040 3
@


1.18
log
@
Added bu_structparse_get_terse_form()
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bu_tcl.c,v 1.17 1999/06/09 19:49:14 mike Exp $ (ARL)";
a919 1
	char *out;
@


1.17
log
@
Added Tcl interface to bu_brlcad_path().
Improved error message from bu_brlcad_path().
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bu_tcl.c,v 1.16 1999/01/15 19:43:14 jra Exp $ (ARL)";
d80 40
@


1.16
log
@bu_structparse_argv() was not terminating string values correctly.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bu_tcl.c,v 1.15 1998/10/08 20:11:31 mike Exp $ (ARL)";
a789 1
	bu_vls_init(&result);
d795 1
d921 22
d952 3
@


1.15
log
@The new routine bu_get_all_keyword_values, given arguments of
alternating keywords and values, establishes local variables named after
the keywords, with the indicated values.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbu/bu_tcl.c,v 1.14 1998/06/04 18:39:37 jra Exp $ (ARL)";
d163 2
@


1.14
log
@improved shader to TCL conversion routines.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbu/RCS/bu_tcl.c,v 1.13 1998/05/29 20:21:18 jra Exp jra $ (ARL)";
d617 112
d942 3
@


1.13
log
@Added tcl wrappers for routines to convert among keyword=value and keyword-space-value.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/libbu/bu_tcl.c,v 1.12 1998/05/28 19:55:30 pjt Exp $ (ARL)";
d707 2
a708 1
	char *out;
d711 2
d715 5
a719 1
		out = bu_key_eq_to_key_val( argv[i] );
d722 1
a722 1
			Tcl_AppendResult(interp, out, " ", NULL );
d724 1
a724 1
			Tcl_AppendResult(interp, out, NULL );
d726 1
a726 1
		bu_free( out, "bu_tcl_key_eq_to_key_val:out" );
d728 2
d741 3
a743 1
	char *out;
d745 5
a749 1
	out = bu_shader_to_key_val( argv[1] );
d751 1
a751 1
	Tcl_AppendResult(interp, out, NULL );
d753 1
a753 1
	bu_free( out, "bu_tcl_shader_to_key_val:out" );
d788 4
a791 1
	char *out;
d793 5
a797 1
	out = bu_shader_to_key_eq( argv[1] );
d799 1
a799 1
	Tcl_AppendResult(interp, out, NULL );
d801 1
a801 1
	bu_free( out, "bu_tcl_shader_to_key_eq:out" );
a803 1

d844 1
a844 1
		"bu_shader_to_key_val",	bu_tcl_shader_to_key_val,
@


1.12
log
@Implemented conversions between RGB and HSV
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbu/RCS/bu_tcl.c,v 1.11 1998/03/19 10:40:14 mike Exp $ (ARL)";
d700 85
d818 12
@


1.11
log
@If the value associated with the keyword is a list, don't return the
curley brackets, it's a real bother to get the list inside another list
of just one item.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbu/RCS/bu_tcl.c,v 1.10 1998/03/19 09:48:49 mike Exp mike $ (ARL)";
d616 83
d727 6
@


1.10
log
@If value retrieved is already a list, don't nest it in another (1-item)
list.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbu/RCS/bu_tcl.c,v 1.9 1998/03/19 06:39:18 mike Exp mike $ (ARL)";
d592 9
a600 2
				Tcl_AppendResult( interp, " ",
					listv[i+1], (char *)NULL );
d602 1
a602 2
				/* Else use caution */
				Tcl_AppendElement( interp, listv[i+1] );
@


1.9
log
@Added bu_get_value_by_keyword
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbu/RCS/bu_tcl.c,v 1.8 1997/12/24 04:49:51 mike Exp mike $ (ARL)";
d590 8
a597 1
			Tcl_AppendElement( interp, listv[i+1] );
@


1.8
log
@IRIX64
@
text
@d6 3
d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbu/RCS/bu_tcl.c,v 1.7 1997/11/21 06:13:14 mike Exp mike $ (ARL)";
d519 86
d628 3
@


1.7
log
@Added newline to error message
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbu/RCS/bu_tcl.c,v 1.6 1997/11/21 05:48:56 mike Exp mike $ (ARL)";
d60 1
a60 1
		sprintf(buf, "ERROR: NULL %s pointer, file %s, line %d\n", 
d66 2
a67 2
		sprintf(buf, "ERROR: bad pointer x%x: s/b %s(x%lx), was %s(x%lx), file %s, line %d\n", 
			ptr,
@


1.6
log
@Clarified commenting
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbu/RCS/bu_tcl.c,v 1.5 1997/11/05 15:15:11 mike Exp mike $ (ARL)";
d403 1
a403 1
			bu_vls_printf( &str, "invalid attribute %s", argv[0] );
@


1.5
log
@Brought in Tcl interfaces for badmagic and structparse
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbu/RCS/bu_tcl.c,v 1.4 1997/08/26 06:12:23 mike Exp mike $ (ARL)";
d86 2
a87 1
 * XXX move to libbu/bu_tcl.c
@


1.4
log
@Wrong Tcl type
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbu/RCS/bu_tcl.c,v 1.3 1997/08/26 05:57:59 mike Exp $ (ARL)";
d43 368
@


1.3
log
@Missing return code.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbu/RCS/bu_tcl.c,v 1.2 1997/08/26 05:56:01 mike Exp mike $ (ARL)";
d174 1
a174 1
	Tcl_LinkVar(interp, "bu_debug", (char *)&bu_debug, TCL_INT );
@


1.2
log
@Oops!
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbu/RCS/bu_tcl.c,v 1.1 1997/08/26 05:50:16 mike Exp mike $ (ARL)";
d143 1
@


1.1
log
@Initial revision
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbn/RCS/bn_tcl.c,v 1.11 1997/04/18 13:25:17 bparker Exp $ (ARL)";
d172 1
a172 1
	Tcl_setVar(interp, "BU_DEBUG_FORMAT", BU_DEBUG_FORMAT, TCL_GLOBAL_ONLY);
@
