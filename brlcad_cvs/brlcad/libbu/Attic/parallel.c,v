head	1.47;
access;
symbols
	ansi-20040405-merged:1.36.2.3
	postmerge-20040405-ansi:1.45
	premerge-20040404-ansi:1.44
	postmerge-autoconf:1.44
	autoconf-freeze:1.41.2.4
	premerge-autoconf:1.44
	ansi-20040316-freeze:1.36.2.1
	postmerge-20040315-windows:1.44
	premerge-20040315-windows:1.43
	windows-20040315-freeze:1.36.4.2
	autoconf-20031203:1.41.2.1
	autoconf-20031202:1.41
	autoconf-branch:1.41.0.2
	phong-branch:1.38.0.2
	photonmap-branch:1.37.0.2
	rel-6-1-DP:1.37
	windows-branch:1.36.0.4
	rel-6-0-2:1.34
	ansi-branch:1.36.0.2
	rel-6-0-1-branch:1.34.0.2
	hartley-6-0-post:1.35
	hartley-6-0-pre:1.34
	rel-6-0-1:1.34
	rel-6-0:1.33
	rel-5-4:1.20.2.1
	offsite-5-3-pre:1.26
	rel-5-3:1.20.2.1
	rel-5-2:1.20.2.1
	rel-5-1-branch:1.20.0.2
	rel-5-1:1.20
	rel-5-0:1.16
	rel-5-0-beta:1.16
	rel-4-5:1.14
	ctj-4-5-post:1.6
	ctj-4-5-pre:1.6;
locks; strict;
comment	@ * @;


1.47
date	2004.05.21.18.06.24;	author morrison;	state dead;
branches;
next	1.46;

1.46
date	2004.05.10.15.30.44;	author erikg;	state Exp;
branches;
next	1.45;

1.45
date	2004.04.05.07.46.16;	author morrison;	state Exp;
branches;
next	1.44;

1.44
date	2004.03.16.19.40.49;	author morrison;	state Exp;
branches;
next	1.43;

1.43
date	2003.12.16.04.25.11;	author jra;	state Exp;
branches;
next	1.42;

1.42
date	2003.10.29.16.22.52;	author morrison;	state Exp;
branches;
next	1.41;

1.41
date	2003.10.04.00.24.39;	author morrison;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2003.09.27.03.43.19;	author morrison;	state Exp;
branches;
next	1.39;

1.39
date	2003.09.27.02.07.01;	author morrison;	state Exp;
branches;
next	1.38;

1.38
date	2003.08.25.18.46.04;	author jra;	state Exp;
branches;
next	1.37;

1.37
date	2002.10.11.08.30.56;	author kermit;	state Exp;
branches
	1.37.2.1;
next	1.36;

1.36
date	2002.08.20.17.07.41;	author jra;	state Exp;
branches
	1.36.2.1
	1.36.4.1;
next	1.35;

1.35
date	2002.08.15.20.54.54;	author hartley;	state Exp;
branches;
next	1.34;

1.34
date	2002.06.05.20.57.43;	author butler;	state Exp;
branches;
next	1.33;

1.33
date	2002.03.14.14.07.03;	author jra;	state Exp;
branches;
next	1.32;

1.32
date	2002.03.13.20.54.36;	author jra;	state Exp;
branches;
next	1.31;

1.31
date	2002.01.24.21.45.07;	author rbowers;	state Exp;
branches;
next	1.30;

1.30
date	2001.10.17.08.50.45;	author morrison;	state Exp;
branches;
next	1.29;

1.29
date	2001.10.17.07.40.02;	author morrison;	state Exp;
branches;
next	1.28;

1.28
date	2001.10.15.19.58.03;	author morrison;	state Exp;
branches;
next	1.27;

1.27
date	2001.03.19.22.19.45;	author butler;	state Exp;
branches;
next	1.26;

1.26
date	2000.09.08.05.52.13;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	2000.09.07.01.14.55;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	2000.09.06.21.09.35;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	2000.08.20.03.54.11;	author butler;	state Exp;
branches;
next	1.22;

1.22
date	2000.07.07.05.20.13;	author cjohnson;	state Exp;
branches;
next	1.21;

1.21
date	2000.07.07.00.37.35;	author cjohnson;	state Exp;
branches;
next	1.20;

1.20
date	2000.03.24.22.45.13;	author mike;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2000.03.09.03.44.19;	author cjohnson;	state Exp;
branches;
next	1.18;

1.18
date	2000.01.14.05.27.56;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	99.12.01.02.48.26;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	98.11.05.19.49.36;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	98.04.27.22.13.44;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	97.12.04.02.49.38;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	97.12.04.02.47.34;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	97.11.22.02.58.14;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	97.11.14.04.44.40;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	97.09.20.15.23.25;	author butler;	state Exp;
branches;
next	1.9;

1.9
date	97.08.22.21.58.24;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	97.08.22.21.51.10;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	97.07.30.04.00.54;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	97.07.02.00.37.36;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	97.07.02.00.31.09;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	97.07.01.23.36.19;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	97.03.07.07.06.29;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	96.08.29.05.53.28;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	96.08.27.06.18.33;	author mike;	state Exp;
branches;
next	;

1.20.2.1
date	2000.08.22.13.59.24;	author jra;	state Exp;
branches;
next	;

1.36.2.1
date	2002.09.19.18.01.13;	author morrison;	state Exp;
branches;
next	1.36.2.2;

1.36.2.2
date	2004.03.17.21.16.50;	author morrison;	state Exp;
branches;
next	1.36.2.3;

1.36.2.3
date	2004.04.05.00.50.06;	author morrison;	state Exp;
branches;
next	;

1.36.4.1
date	2002.09.26.23.03.52;	author morrison;	state Exp;
branches;
next	1.36.4.2;

1.36.4.2
date	2004.03.11.23.41.49;	author morrison;	state Exp;
branches;
next	;

1.37.2.1
date	2003.08.26.14.03.28;	author justin;	state Exp;
branches;
next	;

1.41.2.1
date	2003.12.03.16.24.05;	author erikg;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2004.02.12.18.39.18;	author erikg;	state Exp;
branches;
next	1.41.2.3;

1.41.2.3
date	2004.03.15.14.06.17;	author erikg;	state Exp;
branches;
next	1.41.2.4;

1.41.2.4
date	2004.03.18.18.08.13;	author erikg;	state Exp;
branches;
next	;


desc
@parallel.c
@


1.47
log
@moved to src/
@
text
@/*
 *			P A R A L L E L . C
 *
 *  Machine-specific routines for parallel processing.
 *  Primarily calling functions in multiple threads on multiple CPUs.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
 */
#ifndef lint
static const char RCSparallel[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libbu/parallel.c,v 1.46 2004/05/10 15:30:44 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <ctype.h>
#include <math.h>
#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "machine.h"
#include "externs.h"
#include "bu.h"

#ifdef linux
#include <sys/time.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/sysinfo.h>
#endif

#ifdef __FreeBSD__
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <signal.h>
#endif

#ifdef __ppc__
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <signal.h>
#ifdef BSD
#  define __BSDbackup BSD
#  undef BSD
#  include <sys/param.h>
#  undef BSD
#  define BSD __BSDbackup
#endif
#include <sys/sysctl.h>
#endif

#ifdef __sp3__
#include <sys/types.h>
#include <sys/sysconfig.h>
#include <sys/var.h>
#endif

#ifdef CRAY
# include <sys/category.h>
# include <sys/resource.h>
# include <sys/types.h>
# ifdef CRAY1
#  include <sys/machd.h>	/* For HZ */
# endif
#endif

#ifdef CRAY2
#undef MAXINT
# include <sys/param.h>
#endif

#ifdef HEP
# include <synch.h>
# undef stderr
# define stderr stdout
#endif /* HEP */

#if defined(alliant) && !defined(i860)
/* Alliant FX/8 */
# include <cncall.h>
#endif

#if (defined(sgi) && defined(mips)) || (defined(__sgi) && defined(__mips))
# define SGI_4D	1
# define _SGI_SOURCE	1	/* IRIX 5.0.1 needs this to def M_BLKSZ */
# define _BSD_TYPES	1	/* IRIX 5.0.1 botch in sys/prctl.h */
# include <sys/types.h>
# include <ulocks.h>
# include <sys/sysmp.h> /* for sysmp() */
/* ulocks.h #include's <limits.h> and <malloc.h> */
/* ulocks.h #include's <task.h> for getpid stuff */
/* task.h #include's <sys/prctl.h> */
# include <malloc.h>
/* <malloc.h> #include's <stddef.h> */

#include <sys/wait.h>
#if IRIX64 >= 64
# include <sys/sched.h>
static struct sched_param bu_param;
#endif

#endif /* SGI_4D */

/* XXX Probably need to set _SGI_MP_SOURCE in machine.h */

#ifdef ardent
#	include <thread.h>
#endif

#if defined(n16)
#	include <parallel.h>
#	include <sys/sysadmin.h>
#endif

/*
 * multithreading support for SunOS 5.X / Solaris 2.x
 */
#if defined(SUNOS) && SUNOS >= 52
#	include <sys/unistd.h>
#	include <thread.h>
#	include <synch.h>
#define rt_thread_t	thread_t
#endif	/* SUNOS */

/*
 * multithread support built on POSIX Threads (pthread) library.
 */
#ifdef HAS_POSIX_THREADS
#ifdef __sp3__
#	include	<unistd.h>
#else
#	include <sys/unistd.h>
#endif
#	include <pthread.h>
#define rt_thread_t	pthread_t
#endif	/* HAS_POSIX_THREADS */

#ifdef CRAY
struct taskcontrol {
	int	tsk_len;
	int	tsk_id;
	int	tsk_value;
} bu_taskcontrol[MAX_PSW];
#endif

/*
 *			B U _ N I C E _ S E T
 *
 *  Without knowing what the current UNIX "nice" value is,
 *  change to a new absolute "nice" value.
 *  (The system routine makes a relative change).
 */
void
bu_nice_set(int newnice)
{
	int opri, npri;

#ifdef BSD
#ifndef PRIO_PROCESS	/* necessary for linux */
#define	PRIO_PROCESS	0	/* From /usr/include/sys/resource.h */
#endif
	opri = getpriority( PRIO_PROCESS, 0 );
	setpriority( PRIO_PROCESS, 0, newnice );
	npri = getpriority( PRIO_PROCESS, 0 );
#else
	int bias, chg;

	/* " nice adds the value of incr to the nice value of the process" */
	/* "The default nice value is 20" */
	/* "Upon completion, nice returns the new nice value minus 20" */
	bias = 0;
	opri = nice(0) - bias;
	chg = newnice - opri;
	(void)nice(chg);
	npri = nice(0) - bias;
	if( npri != newnice )  bu_log("bu_nice_set() SysV error:  wanted nice %d! check bias=%d\n", newnice, bias );
#endif
	if( bu_debug ) bu_log("bu_nice_set() Priority changed from %d to %d\n", opri, npri);
}

/*
 *			B U _ C P U L I M I T _ G E T
 *
 *  Return the current CPU limit, in seconds.
 *  Zero or negative return indicates that limits are not in effect.
 */
int
bu_cpulimit_get(void)
{
#ifdef CRAY
	long	old;			/* 64-bit clock counts */
	extern long limit();

	if( (old = limit( C_PROC, 0, L_CPU, -1 )) < 0 )  {
		perror("bu_cpulimit_get(): CPU limit(get)");
	}
	if( old <= 0 )
		return(999999);		/* virtually unlimited */
	return( (old + HZ - 1) / HZ );
#else
	return(-1);
#endif
}

/*
 *			B U _ C P U L I M I T _ S E T
 *
 *  Set CPU time limit, in seconds.
 */
/* ARGSUSED */
void
bu_cpulimit_set(int sec)
{
#ifdef CRAY
	long	old;		/* seconds */
	long	new;		/* seconds */
	long	newtick;	/* 64-bit clock counts */
	extern long limit();

	old = bu_cpulimit_get();
	new = old + sec;
	if( new <= 0 || new > 999999 )
		new = 999999;	/* no limit, for practical purposes */
	newtick = new * HZ;
	if( limit( C_PROC, 0, L_CPU, newtick ) < 0 )  {
		perror("bu_cpulimit_set: CPU limit(set)");
	}
	bu_log("Cray CPU limit changed from %d to %d seconds\n",
		old, newtick/HZ );

	/* Eliminate any memory limit */
	if( limit( C_PROC, 0, L_MEM, 0 ) < 0 )  {
		/* Hopefully, not fatal if memory limits are imposed */
		perror("bu_cpulimit_set: MEM limit(set)");
	}
#endif
	if (sec < 0) sec = 0;
}



/*
 *			B U _ A V A I L _ C P U S
 *
 *  Return the maximum number of physical CPUs that are considered to be
 *  available to this process now.
 */
int
bu_avail_cpus(void)
{
	int ncpu = -1;


#if defined(_SC_NPROCESSORS_ONLN)
	/* SUNOS and linux */
	ncpu = sysconf(_SC_NPROCESSORS_ONLN);
	if (ncpu < 0) {
		perror("Unable to get the number of available CPUs");
		ncpu = 1;
	}
	goto DONE_NCPU;
#elif defined(_SC_NPROC_ONLN)
	ncpu = sysconf(_SC_NPROC_ONLN);
	if (ncpu < 0) {
		perror("Unable to get the number of available CPUs");
		ncpu = 1;
	}
	goto DONE_NCPU;
#elif defined(_SC_CRAY_NCPU)
	/* cray */
	ncpu = sysconf(_SC_CRAY_NCPU);
	if (ncpu < 0) {
		perror("Unable to get the number of available CPUs");
		ncpu = 1;
	}
	goto DONE_NCPU;
#endif


#ifdef SGI_4D
	/* XXX LAB 04 June 2002
	 * The call prctl(PR_MAXPPROCS) is supposed to indicate the number
	 * of processors this process can use.  Unfortuantely, this returns
	 * 0 when running under a CPU set.  A bug report has been filed with
	 * SGI.
	 *
	 * The sysmp(MP_NPROCS) call returns the number of physically 
	 * configured processors.  This will have to suffice until SGI
	 * comes up with a fix.
	 */
#  if 0
	ncpu = (int)prctl(PR_MAXPPROCS);
#  else
	ncpu = sysmp(MP_NPROCS);
#  endif
	goto DONE_NCPU;
#endif /* SGI_4D */


#ifdef alliant
	{
	  long	memsize, ipnum, cenum, detnum, attnum;

#  if !defined(i860)
	  /* FX/8 */
	  lib_syscfg( &memsize, &ipnum, &cenum, &detnum, &attnum );
#  else
	  /* FX/2800 */
	  attnum = 28;
#  endif /* i860 */
	  ncpu = attnum;		/* # of CEs attached to parallel Complex */
	  goto DONE_NCPU;
	}
#endif /* alliant */


#if defined(__sp3__)
	{
	  int status;
	  int cmd;
	  int parmlen;
	  struct var p;

	  cmd = SYS_GETPARMS;
	  parmlen = sizeof(struct var);
	  if ( sysconfig(cmd, &p, parmlen) != 0 ) {
	    bu_bomb("bu_parallel(): sysconfig error for sp3");
	  }
	  ncpu = p.v_ncpus;
	  goto DONE_NCPU;
	}
#endif	/* __sp3__ */


#if defined(n16)
	if( (ncpu = sysadmin( SADMIN_NUMCPUS, 0 )) < 0 )
	  perror("sysadmin");
	goto DONE_NCPU;
#endif /* n16 */


#ifdef __FreeBSD__
	{
	  int maxproc;
	  size_t len;
	  len = 4;
	  if (sysctlbyname("hw.ncpu", &maxproc, &len, NULL, 0) == -1) {
	    ncpu = 1;
	    perror("sysctlbyname");
	  } else {
	    ncpu = maxproc;
	  }
	  goto DONE_NCPU;
	}
#endif


#if defined(__ppc__)
	{
	  int mib[2], maxproc;
	  size_t len;

	  mib[0] = CTL_HW;
	  mib[1] = HW_NCPU;
	  len = sizeof(maxproc);
	  if (sysctl(mib, 2, &maxproc, &len, NULL, NULL == -1)) {
	    ncpu = 1;
	    perror("sysctl");
	  } else {
	    ncpu = maxproc; /* should be able to get sysctl to return maxproc */
	  }
	  goto DONE_NCPU;
	}
#endif /* __ppc__ */


#if defined(HAVE_GET_NPROCS)
	ncpu = get_nprocs(); /* GNU extension from sys/sysinfo.h */
	goto DONE_NCPU;
#endif


#if defined(linux) && 0
	{
	  /* old retired linux method */
	  /*
	   * Ultra-kludgey way to determine the number of cpus in a 
	   * linux box--count the number of processor entries in 
	   * /proc/cpuinfo!
	   */

#	define CPUINFO_FILE "/proc/cpuinfo"
	  FILE *fp;
	  char buf[128];

	  ncpu = 0;
	
	  fp = fopen (CPUINFO_FILE,"r");
	
	  if (fp == NULL) {
	    ncpu = 1; 
	    perror (CPUINFO_FILE);
	  } else {
	    while (fgets (buf, 80, fp) != NULL) {
	      if (strncmp (buf, "processor",9) == 0) {
		++ ncpu;
	      }
	    }
	    fclose (fp);	
	  
	    if (ncpu <= 0) {
	      ncpu = 1;
	    }
	  }
	  goto DONE_NCPU;
	}
#endif

#if defined(_WIN32)
	/* Windows */
	{
	  GetSystemInfo(&sysinfo);
	  ncpu = (int)sysinfo.dwNumberOfProcessors;
	  goto DONE_NCPU;
	}
#endif

DONE_NCPU:  ; /* allows debug and final validity check */


#if defined(HAS_POSIX_THREADS)
	/* if they have threading and we could not detect properly, use two */
	if (ncpu < 0) {
		ncpu = 2;
	}
#endif /* HAS_POSIX_THREADS */

	if (bu_debug & BU_DEBUG_PARALLEL) {
		/* do not use bu_log() here, this can get called before semaphores are initialized */
		fprintf( stderr, "bu_avail_cpus: counted %d cpus.\n", ncpu);
	}

	if (ncpu > 0) {
		return ncpu;
	}

	return( DEFAULT_PSW );
}


/*
 *			B U _ G E T _ L O A D _ A V E R A G E
 *
 *  A generally portable method for obtaining the 1-minute load average.
 *  Vendor-specific methods which don't involve a fork/exec sequence
 *  would be preferable.
 *  Alas, very very few systems put the load average in /proc,
 *  most still grunge the avenrun[3] array out of /dev/kmem,
 *  which requires special privleges to open.
 */
fastf_t
bu_get_load_average(void)
{
	FILE	*fp;
	double	load = -1.0;

	fp = popen("PATH=/bin:/usr/bin:/usr/ucb:/usr/bsd; export PATH; uptime|sed -e 's/.*average: //' -e 's/,.*//' ", "r");
	if( !fp )
		return -1.0;

	fscanf( fp, "%lf", &load );
	fclose(fp);

	while( wait(NULL) != -1 )  ;	/* NIL */
	return load;
}

/*
 *			B U _ G E T _ P U B L I C _ C P U S
 *
 *  A general mechanism for non-privleged users of a server system to control
 *  how many processors of their server get consumed by multi-thread
 *  cruncher processes, by leaving a world-writable file.
 *
 *  If the number in the file is negative, it means "all but that many."
 *
 *  Returns the number of processors presently available for "public" use.
 */
#define PUBLIC_CPUS1	"/var/tmp/public_cpus"
#define PUBLIC_CPUS2	"/usr/tmp/public_cpus"
int
bu_get_public_cpus(void)
{
	FILE	*fp;
	int	avail_cpus;
	int	public_cpus = 1;

	avail_cpus = bu_avail_cpus();

	if( (fp = fopen(PUBLIC_CPUS1, "r")) != NULL ||
	    (fp = fopen(PUBLIC_CPUS2, "r")) != NULL
	)  {
		(void)fscanf( fp, "%d", &public_cpus );
		fclose(fp);
		if( public_cpus < 0 )  public_cpus = avail_cpus + public_cpus;
		if( public_cpus > avail_cpus )  public_cpus = avail_cpus;
		return public_cpus;
	}

	(void)unlink(PUBLIC_CPUS1);
	(void)unlink(PUBLIC_CPUS2);
	if( (fp = fopen(PUBLIC_CPUS1, "w")) != NULL ||
	    (fp = fopen(PUBLIC_CPUS2, "w")) != NULL
	)  {
		fprintf(fp, "%d\n", avail_cpus);
		fclose(fp);
		(void)chmod(PUBLIC_CPUS1, 0666);
		(void)chmod(PUBLIC_CPUS2, 0666);
	}
	return avail_cpus;
}

/*
 *			B U _ S E T _ R E A L T I M E
 *
 *  If possible, mark this process for real-time scheduler priority.
 *  Will often need root privs to succeed.
 *
 *  Returns -
 *	1	realtime priority obtained
 *	0	running with non-realtime scheduler behavior
 */
int
bu_set_realtime(void)
{
#	if defined(IRIX64) && IRIX64 >= 64
	{
		int	policy;

		if( (policy = sched_getscheduler(0)) >= 0 )  {
			if( policy == SCHED_RR || policy == SCHED_FIFO )
				return 1;
		}

		sched_getparam( 0, &bu_param );

		if ( sched_setscheduler( 0,
			SCHED_RR,		/* policy */
			&bu_param
		    ) >= 0 )  {
		    	return 1;		/* realtime */
		}
		/* Fall through to return 0 */
	}
#	endif
	return 0;
}

/**********************************************************************/

#if defined(unix) || defined(__unix)
	/*
	 * Cray is known to wander among various pids, perhaps others.
	 */
#	define	CHECK_PIDS	1
#endif

#if defined(PARALLEL)

/* bu_worker_tbl_not_empty and bu_kill_workers are only used by the sgi arch */
#  ifdef SGI_4D

/*
 *			B U _ W O R K E R _ T B L _ N O T _ E M P T Y
 */
static int
bu_worker_tbl_not_empty(tbl)
int tbl[MAX_PSW];
{
	register int i;
	register int children=0;

	for (i=1 ; i < MAX_PSW ; ++i)
		if (tbl[i]) children++;

	return(children);
}

/*
 *			B U _ K I L L _ W O R K E R S
 */
static void
bu_kill_workers(tbl)
int tbl[MAX_PSW];
{
  register int i;
	
  for (i=1 ; i < MAX_PSW ; ++i) {
    if ( tbl[i] ) {
      if( kill(tbl[i], 9) ) {
	perror("bu_kill_workers(): SIGKILL to child process");
      }
      else {
	bu_log("bu_kill_workers(): child pid %d killed\n", tbl[i]);
      }
    }
  }
  
  bzero( (char *)tbl, sizeof(tbl) );
}
#  endif   /* end check if sgi_4d defined */

extern int	bu_pid_of_initiating_thread;	/* From ispar.c */

static int	bu_nthreads_started = 0;	/* # threads started */
static int	bu_nthreads_finished = 0;	/* # threads properly finished */
static void	(*bu_parallel_func) BU_ARGS((int,genptr_t));	/* user function to run in parallel */
static genptr_t	bu_parallel_arg;		/* User's arg to his threads */

/*
 *			B U _ P A R A L L E L _ I N T E R F A C E
 *
 *  Interface layer between bu_parallel and the user's function.
 *  Necessary so that we can provide unique thread numbers as a
 *  parameter to the user's function, and to decrement the global
 *  counter when the user's function returns to us (as opposed to
 *  dumping core or longjmp'ing too far).
 *
 *  Note that not all architectures can pass an argument
 *  (e.g. the pointer to the user's function), so we depend on
 *  using a global variable to communicate this.
 *  This is no problem, since only one copy of bu_parallel()
 *  may be active at any one time.
 */
static void
bu_parallel_interface(void)
{
	register int	cpu;		/* our CPU (thread) number */

#if 0
#ifdef HAS_POSIX_THREADS
	{
		pthread_t	pt;
		pt = pthread_self();
		fprintf(stderr,"bu_parallel_interface, Thread ID = 0x%x\n", (unsigned int)pt);
	}
#endif
#endif
	bu_semaphore_acquire( BU_SEM_SYSCALL );
	cpu = bu_nthreads_started++;
	bu_semaphore_release( BU_SEM_SYSCALL );

	(*bu_parallel_func)(cpu, bu_parallel_arg);

	bu_semaphore_acquire( BU_SEM_SYSCALL );
	bu_nthreads_finished++;
	bu_semaphore_release( BU_SEM_SYSCALL );

#	if defined(SGI_4D) || defined(IRIX)
	/*
	 *  On an SGI, a process/thread created with the "sproc" syscall has
	 *  all of it's file descriptors closed when it "returns" to sproc.
	 *  Since this trashes file descriptors which may still be in use by
	 *  other processes, we avoid ever returning to sproc.
	 */
	if(cpu) _exit(0);
#	endif /* SGI */
}
#endif /* PARALLEL */

#ifdef SGI_4D
/*
 *			B U _ P R _ F I L E
 *
 *  SGI-specific.  Formatted printing of stdio's FILE struct.
 */
void
bu_pr_FILE(title, fp)
char	*title;
FILE	*fp;
{
	bu_log("FILE structure '%s', at x%x:\n", title, fp );
	bu_log(" _cnt = x%x\n", fp->_cnt);
	bu_log(" _ptr = x%x\n", fp->_ptr);
	bu_log(" _base = x%x\n", fp->_base);
	bu_log(" _file = x%x\n", fp->_file);
	bu_printb(" _flag ", fp->_flag & 0xFF,
		"\010\010_IORW\7_100\6_IOERR\5_IOEOF\4_IOMYBUF\3_004\2_IOWRT\1_IOREAD" );
	bu_log("\n");
}
#endif

/*
 *			B U _ P A R A L L E L
 *
 *  Create 'ncpu' copies of function 'func' all running in parallel,
 *  with private stack areas.  Locking and work dispatching are
 *  handled by 'func' using a "self-dispatching" paradigm.
 *
 *  'func' is called with one parameter, it's thread number.
 *  Threads are given increasing numbers, starting with zero.
 *
 *  This function will not return control until all invocations
 *  of the subroutine are finished.
 *
 *  Don't use registers in this function (bu_parallel).  At least on the Alliant,
 *  register context is NOT preserved when exiting the parallel mode,
 *  because the serial portion resumes on some arbitrary processor,
 *  not necessarily the one that serial execution started on.
 *  The registers are not shared.
 */
void
bu_parallel( func, ncpu, arg )
void		(*func) BU_ARGS((int, genptr_t));
int		ncpu;
genptr_t	arg;
{
#if defined(PARALLEL)
	int	avail_cpus;

#  if defined(alliant) && !defined(i860) && !__STDC__
	register int d7;	/* known to be in d7 */
	register int d6 = ncpu;	/* known to be in d6 */
#  endif
	int	x;

#  if defined(SGI_4D) || defined(CRAY)
	int	new;
#  endif

#  ifdef sgi
	long	stdin_pos;
	FILE	stdin_save;
	int	worker_pid_tbl[MAX_PSW];

	bzero(worker_pid_tbl, sizeof(worker_pid_tbl) );
#  endif

/*
 * multithreading support for SunOS 5.X / Solaris 2.x
 */
#  if defined(SUNOS) && SUNOS >= 52
	static int	concurrency = 0; /* Max concurrency we have set */
#  endif
#  if (defined(SUNOS) && SUNOS >= 52) || defined(HAS_POSIX_THREADS)
	int		nthreadc;
	int		nthreade;
	rt_thread_t	thread;
	rt_thread_t	thread_tbl[MAX_PSW];
	int		i;
#  endif	/* SUNOS */

	if( bu_debug & BU_DEBUG_PARALLEL )
		bu_log("bu_parallel(0x%lx, %d, x%lx)\n", (long)func, ncpu, (long)arg );

	if( bu_pid_of_initiating_thread )
		bu_bomb("bu_parallel() called from within parallel section\n");

	bu_pid_of_initiating_thread = getpid();

	if (ncpu > MAX_PSW) {
		bu_log("WARNING: bu_parallel() ncpu(%d) > MAX_PSW(%d), adjusting ncpu\n", ncpu, MAX_PSW);
		ncpu = MAX_PSW;
	}
	bu_nthreads_started = 0;
	bu_nthreads_finished = 0;
	bu_parallel_func = func;
	bu_parallel_arg = arg;
	avail_cpus = bu_avail_cpus();
	if( ncpu > avail_cpus ) {
		bu_log( "%d cpus requested, but only %d available\n", ncpu, avail_cpus );
		ncpu = avail_cpus;
	}


#  ifdef HEP
	bu_nthreads_started = 1;
	bu_nthreads_finished = 1;
	for( x=1; x<ncpu; x++ )  {
		/* This is more expensive when GEMINUS>1 */
		Dcreate( bu_parallel_interface );
	}
	(*func)(0,arg);	/* avoid wasting this task */
#  endif /* HEP */

#  ifdef CRAY
#    if 0
	/* Try to give up processors as soon as they are un needed */
	new = 0;
	TSKTUNE( "DBRELEAS", &new );
#    endif

	bu_nthreads_started = 1;
	bu_nthreads_finished = 1;
	/* Create any extra worker tasks */
	for( x=1; x<ncpu; x++ ) {
		bu_taskcontrol[x].tsk_len = 3;
		bu_taskcontrol[x].tsk_value = x;
		TSKSTART( &bu_taskcontrol[x], bu_parallel_interface );
	}
	(*func)(0,arg);	/* avoid wasting this task */

	/* Wait for them to finish */
	for( x=1; x<ncpu; x++ )  {
		TSKWAIT( &bu_taskcontrol[x] );
	}
	/* There needs to be some way to kill the tfork()'ed processes here */
#  endif

#  if defined(alliant) && !defined(i860)
#	if defined(__STDC__)	/* fxc defines it == 0 !! */
#	undef __STDC__
#	define __STDC__	2

	/* Calls bu_parallel_interface in parallel "ncpu" times */
	concurrent_call(CNCALL_COUNT|CNCALL_NO_QUIT, bu_parallel_interface, ncpu);

#	else
	{
		asm("	movl		d6,d0");
		asm("	subql		#1,d0");
		asm("	cstart		d0");
		asm("super_loop:");
		bu_parallel_interface();		/* d7 has current index, like magic */
		asm("	crepeat		super_loop");
	}
#	endif
#  endif

#  if defined(alliant) && defined(i860)
        #pragma loop cncall
        for( x=0; x<ncpu; x++) {
		bu_parallel_interface();
        }
#  endif

#  if defined(convex) || defined(__convex__)
	/*$dir force_parallel */
	for( x=0; x<ncpu; x++ )  {
		bu_parallel_interface();
	}
#  endif /* convex */

#  ifdef ardent
	/* The stack size parameter is pure guesswork */
	parstack( bu_parallel_interface, 1024*1024, ncpu );
#  endif /* ardent */

#  ifdef SGI_4D
	stdin_pos = ftell(stdin);
	stdin_save = *(stdin);		/* struct copy */
	bu_nthreads_started = 1;
	bu_nthreads_finished = 1;

	/* Note:  it may be beneficial to call prctl(PR_SETEXITSIG); */
	/* prctl(PR_TERMCHILD) could help when parent dies.  But SIGHUP??? hmmm */
	for( x = 1; x < ncpu; x++)  {
		/*
		 *  Start a share-group process, sharing ALL resources.
		 *  This direct sys-call can be used because none of the
		 *  task-management services of, eg, taskcreate() are needed.
		 */
#    if IRIX <= 4
		/*  Stack size per proc comes from RLIMIT_STACK (typ 64MBytes). */
		new = sproc( bu_parallel_interface, PR_SALL, 0 );
#    else
		/* State maximum stack size.
		 * Be generous, as this mainly costs address space.
		 * RAM is allocated only to those pages used.
		 * On the other hand, don't be too generous, because each
		 * proc needs this much space on, e.g. a 64 processor system.
		 * Don't go quite for an even number of megabytes,
		 * in the hopes of creating a small 32k "buffer zone"
		 * to catch stack overflows.
		 */
		new = sprocsp( (void (*)(void *, size_t))bu_parallel_interface,
			PR_SALL, 0, NULL,
#			if IRIX64
				64*1024*1024 - 32*1024
#			else
				4*1024*1024 - 32*1024
#			endif
			);
#    endif
		if( new < 0 )  {
			perror("sproc");
			bu_log("ERROR bu_parallel(): sproc(x%x, x%x, )=%d failed on processor %d\n",
				bu_parallel_interface, PR_SALL,
				new, x );
			bu_log("sbrk(0)=x%x\n", sbrk(0) );
			bu_bomb("bu_parallel() failure");
		} else {
			worker_pid_tbl[x] = new;
		}
		
	}
	(*func)(0,arg);	/* don't waste this thread */
	{
		int	pid;
		int	pstat;
		int	children;

		/* 
		 * Make sure all children are done.
		 */
		while ( children=bu_worker_tbl_not_empty(worker_pid_tbl) ) {
			pstat = 0;
			if ( (pid = wait(&pstat)) < 0) {
				perror("bu_parallel() wait()");
				bu_kill_workers(worker_pid_tbl);
				bu_bomb("parallelism error");
			} else if (pid == 0) {
				bu_log("bu_parallel() wait() == 0 with %d children remaining\n", children);
				bu_kill_workers(worker_pid_tbl);
				bu_bomb("Missing worker");
			} else {
				if( (pstat & 0xFF) != 0 )  {
					bu_log("***ERROR: bu_parallel() worker %d exited with status x%x!\n", pid, pstat);
					/* XXX How to cope with this;  can't back out work that was lost at this level. */
#    ifdef IRIX
	if (WIFEXITED(pstat))
		bu_log ("Child terminated normally with status %d 0x%0x\n",
			WEXITSTATUS(pstat));

	if (WIFSIGNALED(pstat)) {
		bu_log("child terminated on signal %d %0x\n", WTERMSIG(pstat));
		if (pstat & 0200)
			bu_log("core dumped\n");
		else
			bu_log("No core dump\n");
	}
	if (WIFSTOPPED(pstat))
		bu_log("child is stopped on signal %d 0x%x\n", WSTOPSIG(pstat));

	if ( (pstat & 0177777) == 0177777 )
		bu_log("child has continued\n");

#    endif
					bu_kill_workers(worker_pid_tbl);
					bu_bomb("A worker blew out");
				}
				/* remove pid from worker_pid_tbl */
				for (x=1 ; x < ncpu ; x++)
					if (worker_pid_tbl[x] == pid) {
						worker_pid_tbl[x] = 0;
						break;
					}

				if (x >= ncpu) {
					bu_log("WARNING: bu_parallel(): wait() returned non-child process, pid %d\n", pid);
				}
			}
		}
	}
	if( ftell(stdin) != stdin_pos )  {
		/*
		 *  Gross SGI bug:  when a thread is finished, it returns
		 *  to the stack frame created by sproc(), which
		 *  just calls exit(0), resulting in all STDIO file buffers
		 *  being fflush()ed.  This zaps the stdin position, and
		 *  may wreak additional havoc.
		 *  Exists in IRIX 3.3.1, Irix 4.0.5,
		 *  should be fixed in a later release.  Maybe.
		 */
		bu_log("\nWarning:  stdin file pointer has been corrupted by SGI multi-processor bug!\n");
		if( bu_debug & BU_DEBUG_PARALLEL )  {
			bu_log("Original position was x%x, now position is x%x!\n", stdin_pos, ftell(stdin) );
			bu_pr_FILE("saved stdin", &stdin_save);
			bu_pr_FILE("current stdin", stdin);
		}
		fseek(stdin, stdin_pos, SEEK_SET);
		if( ftell(stdin) != stdin_pos )  {
			bu_log("WARNING: fseek() did not recover proper position.\n");
		} else {
			bu_log("It was fixed by fseek()\n");
		}
	}
#  endif /* sgi */

#  if defined(n16)
	/* The shared memory size requirement is sheer guesswork */
	/* The stack size is also guesswork */
	if( task_init( 8*1024*1024, ncpu, bu_parallel_interface, 128*1024, 0 ) < 0 )
		perror("bu_parallel()/task_init()");
#  endif

	/*
	 * multithreading support for SunOS 5.X / Solaris 2.x
	 */
#  if defined(SUNOS) && SUNOS >= 52

	thread = 0;
	nthreadc = 0;

	/* Give the thread system a hint... */
	if (ncpu > concurrency) {
		if (thr_setconcurrency(ncpu)) {
			fprintf(stderr, "ERROR parallel.c/bu_parallel(): thr_setconcurrency(%d) failed\n",
				ncpu);
			bu_log("ERROR parallel.c/bu_parallel(): thr_setconcurrency(%d) failed\n",
			       ncpu);
			/* Not much to do, lump it */
		} else {
			concurrency = ncpu;
		}
	}

	/* Create the threads */
	for (x = 0; x < ncpu; x++)  {

		if (thr_create(0, 0, (void *(*)(void *))bu_parallel_interface, 0, 0, &thread)) {
			fprintf(stderr, "ERROR parallel.c/bu_parallel(): thr_create(0x0, 0x0, 0x%x, 0x0, 0, 0x%x) failed on processor %d\n",
				bu_parallel_interface, &thread, x);
			bu_log("ERROR parallel.c/bu_parallel(): thr_create(0x0, 0x0, 0x%x, 0x0, 0, 0x%x) failed on processor %d\n",
				bu_parallel_interface, &thread, x);
			/* Not much to do, lump it */
		} else {
			if( bu_debug & BU_DEBUG_PARALLEL )
				bu_log("bu_parallel(): created thread: (thread: 0x%x) (loop:%d) (nthreadc:%d)\n",
				       thread, x, nthreadc);

			thread_tbl[nthreadc] = thread;
			nthreadc++;
		}
	}

	if( bu_debug & BU_DEBUG_PARALLEL )
		for (i = 0; i < nthreadc; i++)
			bu_log("bu_parallel(): thread_tbl[%d] = 0x%x\n",
			       i, thread_tbl[i]);

	/*
	 * Wait for completion of all threads.  We don't wait for
	 * threads in order.  We wait for any old thread but we keep
	 * track of how many have returned and whether it is one that we
	 * started
	 */
	thread = 0;
	nthreade = 0;
	for (x = 0; x < nthreadc; x++)  {
		if( bu_debug & BU_DEBUG_PARALLEL )
			bu_log("bu_parallel(): waiting for thread to complete:\t(loop:%d) (nthreadc:%d) (nthreade:%d)\n",
			       x, nthreadc, nthreade);

		if (thr_join((rt_thread_t)0, &thread, NULL)) {
			/* badness happened */
			fprintf(stderr, "thr_join()");
		}

		/* Check to see if this is one the threads we created */
		for (i = 0; i < nthreadc; i++) {
			if (thread_tbl[i] == thread) {
				thread_tbl[i] = (rt_thread_t)-1;
				nthreade++;
				break;
			}
		}

		if ((thread_tbl[i] != (rt_thread_t)-1) && i < nthreadc) {
			bu_log("bu_parallel(): unknown thread %d completed.\n",
			       thread);
		}

		if( bu_debug & BU_DEBUG_PARALLEL )
			bu_log("bu_parallel(): thread completed: (thread: %d)\t(loop:%d) (nthreadc:%d) (nthreade:%d)\n",
			       thread, x, nthreadc, nthreade);
	}

	if( bu_debug & BU_DEBUG_PARALLEL )
		bu_log("bu_parallel(): %d threads created.  %d threads exited.\n",
		       nthreadc, nthreade);
#  endif	/* SUNOS */

#  if defined(HAS_POSIX_THREADS)

	thread = 0;
	nthreadc = 0;

	/* XXX How to advise thread library that we need 'ncpu' processors? */

	/* Create the threads */
	for (x = 0; x < ncpu; x++)  { 
		pthread_attr_t attrs;
		pthread_attr_init(&attrs);
		pthread_attr_setstacksize(&attrs,10*1024*1024);

		if (pthread_create(&thread, &attrs,
		    (void *(*)(void *))bu_parallel_interface, NULL)) {
			fprintf(stderr, "ERROR parallel.c/bu_parallel(): thr_create(0x0, 0x0, 0x%x, 0x0, 0, 0x%x) failed on processor %d\n",
				(unsigned int)bu_parallel_interface, (unsigned int)&thread, x);
			bu_log("ERROR parallel.c/bu_parallel(): thr_create(0x0, 0x0, 0x%x, 0x0, 0, 0x%x) failed on processor %d\n",
				bu_parallel_interface, &thread, x);
			/* Not much to do, lump it */
		} else {
			if( bu_debug & BU_DEBUG_PARALLEL ) {
				bu_log("bu_parallel(): created thread: (thread: %d) (loop:%d) (nthreadc:%d)\n",
				       thread, x, nthreadc);
			}

			thread_tbl[nthreadc] = thread;
			nthreadc++;
		}
	}


	if( bu_debug & BU_DEBUG_PARALLEL ) {
		for (i = 0; i < nthreadc; i++) {
			bu_log("bu_parallel(): thread_tbl[%d] = %d\n",
			       i, thread_tbl[i]);
		}
#    if defined(__FreeBSD__)
		/* Is this FreeBSD-only? */
		_thread_dump_info();
#    endif
	}

	/*
	 * Wait for completion of all threads.
	 * Wait for them in order.
	 */
	thread = 0;
	nthreade = 0;
	for (x = 0; x < nthreadc; x++)  {
		int ret;

		if( bu_debug & BU_DEBUG_PARALLEL )
			bu_log("bu_parallel(): waiting for thread x%x to complete:\t(loop:%d) (nthreadc:%d) (nthreade:%d)\n",
				thread_tbl[x], x, nthreadc, nthreade);

		if ( (ret = pthread_join(thread_tbl[x], NULL)) != 0) {
			/* badness happened */
			fprintf(stderr, "pthread_join(thread_tbl[%d]=0x%x) ret=%d\n", x, (unsigned int)thread_tbl[x], ret);
		}
		nthreade++;
		thread_tbl[x] = (rt_thread_t)-1;

		if( bu_debug & BU_DEBUG_PARALLEL )
			bu_log("bu_parallel(): thread completed: (thread: %d)\t(loop:%d) (nthreadc:%d) (nthreade:%d)\n",
			       thread, x, nthreadc, nthreade);
	}

	if( bu_debug & BU_DEBUG_PARALLEL )
		bu_log("bu_parallel(): %d threads created.  %d threads exited.\n",
		       nthreadc, nthreade);

#  endif /* end if posix threads */

	/*
	 *  Ensure that all the threads are REALLY finished.
	 *  On some systems, if threads core dump, the rest of
	 *  the gang keeps going, so this can actually happen (sigh).
	 */
	if( bu_nthreads_finished != bu_nthreads_started )  {
		bu_log("*** ERROR bu_parallel(%d): %d workers did not finish!\n\n",
			ncpu, ncpu - bu_nthreads_finished);
	}
	if( bu_nthreads_started != ncpu )  {
		bu_log("bu_parallel() NOTICE:  only %d workers started, expected %d\n",
			bu_nthreads_started, ncpu );
	}

	if( bu_debug & BU_DEBUG_PARALLEL )
		bu_log("bu_parallel(%d) complete, now serial\n", ncpu);

#  ifdef CHECK_PIDS
	/*
	 * At this point, all multi-tasking activity should have ceased,
	 * and we should be just a single UNIX process with our original
	 * PID and open file table (kernel struct u).  If not, then any
	 * output may be written into the wrong file.
	 */
	if( bu_pid_of_initiating_thread != (x=getpid()) )  {
		bu_log("WARNING: bu_parallel():  PID of initiating thread changed from %d to %d, open file table may be botched!\n",
			bu_pid_of_initiating_thread, x );
	}
#  endif
	bu_pid_of_initiating_thread = 0;	/* No threads any more */
#else	/* PARALLEL */
	bu_log("bu_parallel( x%lx, %d., x%lx ):  Not compiled for PARALLEL machine\n",
		(long)func, ncpu, (long)arg );
#endif	/* PARALLEL */


}

#if defined(sgi) && !defined(mips)
/* Horrible bug in 3.3.1 and 3.4 and 3.5 -- hypot ruins stack! */
long float
hypot(a,b)
double a,b;
{
	return(sqrt(a*a+b*b));
}
#endif /* sgi */
@


1.46
log
@change conf.h to a wrapped config.h
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /cvs/brlcad/libbu/parallel.c,v 1.45 2004/04/05 07:46:16 morrison Exp $ (ARL)";
@


1.45
log
@merge of ansi-6-0-branch into HEAD
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header$ (ARL)";
d21 5
a25 1
#include "conf.h"
@


1.44
log
@merge of windows-6-0-branch into head
@
text
@d136 1
a136 1
#if SUNOS >= 52
d172 1
a172 2
bu_nice_set(newnice)
int	newnice;
d206 1
a206 1
bu_cpulimit_get()
d230 1
a230 2
bu_cpulimit_set(sec)
int	sec;
d255 1
d267 1
a267 1
bu_avail_cpus()
d480 1
a480 1
bu_get_load_average()
d510 1
a510 1
bu_get_public_cpus()
d552 1
a552 1
bu_set_realtime()
d554 1
a554 1
#	if IRIX64 >= 64
d654 1
a654 1
bu_parallel_interface()
d760 1
a760 1
#  if SUNOS >= 52
d763 1
a763 1
#  if SUNOS >= 52 || defined(HAS_POSIX_THREADS)
d1008 1
a1008 1
#  if SUNOS >= 52
d1129 1
a1129 1
#    if __FreeBSD__
@


1.43
log
@Corrected a debug flag check in bu_avail_cpus() and replaced a bu_log() call with a fprintf().
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.42 2003/10/29 16:22:52 morrison Exp $ (ARL)";
d438 8
@


1.42
log
@freebsd patch applied from Anders Jensen to detect number of cpus
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.41 2003/10/04 00:24:39 morrison Exp $ (ARL)";
d449 3
a451 2
	if (bu_debug && BU_DEBUG_PARALLEL) {
	      bu_log ("bu_avail_cpus: counted %d cpus.\n", ncpu);
@


1.41
log
@extensively reorganized bu_avail_cpus(); made code blocks with their own local vars to elimate needing two sections for certain architectures; added checks to support more platforms that support the sysctl interface
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.40 2003/09/27 03:43:19 morrison Exp $ (ARL)";
d361 16
d388 2
a390 1
	  ncpu = maxproc; /* should be able to get sysctl to return maxproc */
@


1.41.2.1
log
@updates from HEAD, part 1
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.42 2003/10/29 16:22:52 morrison Exp $ (ARL)";
a360 16
#ifdef __FreeBSD__
	{
	  int maxproc;
	  size_t len;
	  len = 4;
	  if (sysctlbyname("hw.ncpu", &maxproc, &len, NULL, 0) == -1) {
	    ncpu = 1;
	    perror("sysctlbyname");
	  } else {
	    ncpu = maxproc;
	  }
	  goto DONE_NCPU;
	}
#endif


a371 2
	  } else {
	    ncpu = maxproc; /* should be able to get sysctl to return maxproc */
d373 1
@


1.41.2.2
log
@merge from HEAD
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.43 2003/12/16 04:25:11 jra Exp $ (ARL)";
d449 2
a450 3
	if (bu_debug & BU_DEBUG_PARALLEL) {
		/* do not use bu_log() here, this can get called before semaphores are initialized */
		fprintf( stderr, "bu_avail_cpus: counted %d cpus.\n", ncpu);
@


1.41.2.3
log
@merge from head
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.41.2.2 2004/02/12 18:39:18 erikg Exp $ (ARL)";
@


1.41.2.4
log
@merge from head
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header$ (ARL)";
a437 8
#if defined(_WIN32)
	/* Windows */
	{
	  GetSystemInfo(&sysinfo);
	  ncpu = (int)sysinfo.dwNumberOfProcessors;
	  goto DONE_NCPU;
	}
#endif
@


1.40
log
@er, only try the get_nprocs() call if we are linux
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.39 2003/09/27 02:07:01 morrison Exp $ (ARL)";
d260 1
d270 1
a270 1
	int	ret = 1;
a271 8
#if defined(linux)
#  if 0
	//#ifdef linux 
#    define CPUINFO_FILE "/proc/cpuinfo"
	FILE *fp;
	char buf[128];
#  endif
#endif
d273 23
a295 3
#ifdef __ppc__
	int mib[2], maxproc;
	size_t len;
a297 6
#ifdef __sp3__
	int status;
	int cmd;
	int parmlen;
	struct var p;
#endif
d310 8
a317 7
#if 0
	ret = (int)prctl(PR_MAXPPROCS);
#else
	ret = sysmp(MP_NPROCS);
#endif
#	define	RT_AVAIL_CPUS
#endif
d320 14
a333 1
	long	memsize, ipnum, cenum, detnum, attnum;
a334 10
#if !defined(i860)
	/* FX/8 */
	lib_syscfg( &memsize, &ipnum, &cenum, &detnum, &attnum );
#else
	/* FX/2800 */
	attnum = 28;
#endif
	ret = attnum;		/* # of CEs attached to parallel Complex */
#	define	RT_AVAIL_CPUS
#endif
d336 14
a349 4
#if defined(SUNOS)
	if ((ret = sysconf(_SC_NPROCESSORS_ONLN)) == -1) {
		ret = 1;
		perror("sysconf");
d351 1
a351 2
#       define  RT_AVAIL_CPUS
#endif	/* defined(SUNOS) */
d354 11
a364 6
#if defined(HAS_POSIX_THREADS) && !defined(linux) && !defined(__sp3__)
	/* XXX Old posix doesn't specify how to learn how many CPUs there are. 
	 *  never posix can make a sysctl call -- see __ppc__ below */
	ret = 2;
#	define	RT_AVAIL_CPUS
#endif /* HAS_POSIX_THREADS */
d366 9
a374 6
#if defined(HAS_POSIX_THREADS) && defined(__sp3__)
#if 1
	cmd = SYS_GETPARMS;
	parmlen = sizeof(struct var);
	if( sysconfig(cmd, &p, parmlen) != 0 ) {
		bu_bomb("bu_parallel(): sysconfig error for sp3");
d376 6
a381 3
	ret = p.v_ncpus;	/* or should this be p.v_ncpus_cfg ??? */
#else
	ret = 16;
a382 2
#	define	RT_AVAIL_CPUS
#endif	/* defined(HAS_POSIX_THREADS) && defined(__sp3__) */
a383 13
/* 
 * These machines may or may not have posix threads, but (more importantly)
 * they do have other mechanisms for determining cpu count
 */
#if defined(linux)
#if 0
	/* old linux method */
	/*
	 * Ultra-kludgey way to determine the number of cpus in a 
	 * linux box--count the number of processor entries in 
	 * /proc/cpuinfo!
	 */
	ret = 0;
d385 12
a396 1
	fp = fopen (CPUINFO_FILE,"r");
d398 6
a403 3
	if (fp == NULL)
	  {
	    ret = 1; 
d405 4
a408 9
	  }
	else 
	  {
	    while (fgets (buf, 80, fp) != NULL)
	      {
		if (strncmp (buf, "processor",9) == 0)
		  {
		    ++ ret;
		  }
d410 1
d412 4
a415 11
	    
	    if (ret <= 0) 
	      {
		ret = 1;
	      } 
	    else
	      { 
                #if 0
		bu_log ("bu_avail_cpus: counted %d cpus.\n", ret);
                #endif
	      }
d417 1
a417 6
#         define RT_AVAIL_CPUS
#else
	/* new linux method */
	/* get_nprocs_conf() will return the number of configured processors */
	if ( (ret = get_nprocs()) ) {
	  perror("get_nprocs");
a418 3
	/* this should also work: sysconf(_SC_NPROCESSORS_CONF);  */
#	define RT_AVAIL_CPUS
#endif
a420 5
#if defined(n16)
	if( (ret = sysadmin( SADMIN_NUMCPUS, 0 )) < 0 )
	  perror("sysadmin");
#	define	RT_AVAIL_CPUS
#endif
d422 16
a437 7
#if defined(__ppc__)
	mib[0] = CTL_HW;
	mib[1] = HW_NCPU;
	len = sizeof(maxproc);
	if (sysctl(mib, 2, &maxproc, &len, NULL, NULL == -1)) {
	  ret = 1;
	  perror("sysctl");
a438 3
	ret = maxproc; /* should be able to get sysctl to return maxproc */
#	define	RT_AVAIL_CPUS
#endif
d440 1
a440 4
#ifndef RT_AVAIL_CPUS
	ret = DEFAULT_PSW;
#endif
	return( ret );
d1098 1
d1138 2
a1139 1
#  endif
d1175 2
@


1.39
log
@better way to comput the number of available cpus under linux; instead of parsing /proc, use the get_nprocs() system call (sysconf() would have also worked)
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.38 2003/08/25 18:46:04 jra Exp $ (ARL)";
d271 2
a272 1
#if 0
d274 1
a274 1
#define CPUINFO_FILE "/proc/cpuinfo"
d277 1
d359 1
d407 1
@


1.38
log
@ifdef'd out a pthread log message
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.37 2002/10/11 08:30:56 kermit Exp $ (ARL)";
d41 1
d259 1
d271 2
a272 1
#ifdef linux 
d357 2
a358 1
#if defined(linux)
d396 8
@


1.37
log
@Added initial support for IBM SP "Scalable Parallel" system running AIX.
Static build fully functional, still needs more work on shared build.
OpenGL support works, but there are issues communicatiing with mged.
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.36 2002/08/20 17:07:41 jra Exp $ (ARL)";
d608 1
d615 1
@


1.37.2.1
log
@updated for merging
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.38 2003/08/25 18:46:04 jra Exp $ (ARL)";
a607 1
#if 0
a613 1
#endif
@


1.36
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.34 2002/06/05 20:57:43 butler Exp $ (ARL)";
d69 6
d146 3
d150 1
d280 7
d328 2
a329 1
#if defined(HAS_POSIX_THREADS) && !defined(linux)
d335 14
@


1.36.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.36 2002/08/20 17:07:41 jra Exp $ (ARL)";
a159 1
#ifndef WIN32
a187 9
#else
void bu_nice_set(newnice)
int	newnice;
{
	if( bu_debug ) bu_log("bu_nice_set() Priority NOT changed\n");
	return;
}
#endif

a379 11
#ifdef WIN32
	{
		SYSTEM_INFO sysinfo;

		GetSystemInfo(&sysinfo);

		ret = (int)sysinfo.dwNumberOfProcessors;
#	define	RT_AVAIL_CPUS
	}

#endif
a382 1

a402 2
#ifndef WIN32

a410 1
#endif
a424 1
#ifndef WIN32
a426 1
#endif
a435 1
#ifndef WIN32
a455 1
#endif
@


1.36.4.2
log
@sync to HEAD...
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libbu/parallel.c,v 1.36.4.1 2002/09/26 23:03:52 morrison Exp $ (ARL)";
a40 1
#include <sys/sysinfo.h>
a68 6
#ifdef __sp3__
#include <sys/types.h>
#include <sys/sysconfig.h>
#include <sys/var.h>
#endif

a139 3
#ifdef __sp3__
#	include	<unistd.h>
#else
a140 1
#endif
d160 1
d189 9
a257 2


d267 1
a267 1
	int ncpu = -1;
d269 5
d275 3
a277 23
#if defined(_SC_NPROCESSORS_ONLN)
	/* SUNOS and linux */
	ncpu = sysconf(_SC_NPROCESSORS_ONLN);
	if (ncpu < 0) {
		perror("Unable to get the number of available CPUs");
		ncpu = 1;
	}
	goto DONE_NCPU;
#elif defined(_SC_NPROC_ONLN)
	ncpu = sysconf(_SC_NPROC_ONLN);
	if (ncpu < 0) {
		perror("Unable to get the number of available CPUs");
		ncpu = 1;
	}
	goto DONE_NCPU;
#elif defined(_SC_CRAY_NCPU)
	/* cray */
	ncpu = sysconf(_SC_CRAY_NCPU);
	if (ncpu < 0) {
		perror("Unable to get the number of available CPUs");
		ncpu = 1;
	}
	goto DONE_NCPU;
a279 1

d291 7
a297 8
#  if 0
	ncpu = (int)prctl(PR_MAXPPROCS);
#  else
	ncpu = sysmp(MP_NPROCS);
#  endif
	goto DONE_NCPU;
#endif /* SGI_4D */

d300 1
a300 2
	{
	  long	memsize, ipnum, cenum, detnum, attnum;
d302 9
a310 51
#  if !defined(i860)
	  /* FX/8 */
	  lib_syscfg( &memsize, &ipnum, &cenum, &detnum, &attnum );
#  else
	  /* FX/2800 */
	  attnum = 28;
#  endif /* i860 */
	  ncpu = attnum;		/* # of CEs attached to parallel Complex */
	  goto DONE_NCPU;
	}
#endif /* alliant */


#if defined(__sp3__)
	{
	  int status;
	  int cmd;
	  int parmlen;
	  struct var p;

	  cmd = SYS_GETPARMS;
	  parmlen = sizeof(struct var);
	  if ( sysconfig(cmd, &p, parmlen) != 0 ) {
	    bu_bomb("bu_parallel(): sysconfig error for sp3");
	  }
	  ncpu = p.v_ncpus;
	  goto DONE_NCPU;
	}
#endif	/* __sp3__ */


#if defined(n16)
	if( (ncpu = sysadmin( SADMIN_NUMCPUS, 0 )) < 0 )
	  perror("sysadmin");
	goto DONE_NCPU;
#endif /* n16 */


#ifdef __FreeBSD__
	{
	  int maxproc;
	  size_t len;
	  len = 4;
	  if (sysctlbyname("hw.ncpu", &maxproc, &len, NULL, 0) == -1) {
	    ncpu = 1;
	    perror("sysctlbyname");
	  } else {
	    ncpu = maxproc;
	  }
	  goto DONE_NCPU;
	}
d313 14
d328 11
a338 24
#if defined(__ppc__)
	{
	  int mib[2], maxproc;
	  size_t len;

	  mib[0] = CTL_HW;
	  mib[1] = HW_NCPU;
	  len = sizeof(maxproc);
	  if (sysctl(mib, 2, &maxproc, &len, NULL, NULL == -1)) {
	    ncpu = 1;
	    perror("sysctl");
	  } else {
	    ncpu = maxproc; /* should be able to get sysctl to return maxproc */
	  }
	  goto DONE_NCPU;
	}
#endif /* __ppc__ */


#if defined(HAVE_GET_NPROCS)
	ncpu = get_nprocs(); /* GNU extension from sys/sysinfo.h */
	goto DONE_NCPU;
#endif

d340 1
a340 12
#if defined(linux) && 0
	{
	  /* old retired linux method */
	  /*
	   * Ultra-kludgey way to determine the number of cpus in a 
	   * linux box--count the number of processor entries in 
	   * /proc/cpuinfo!
	   */

#	define CPUINFO_FILE "/proc/cpuinfo"
	  FILE *fp;
	  char buf[128];
d342 3
a344 6
	  ncpu = 0;
	
	  fp = fopen (CPUINFO_FILE,"r");
	
	  if (fp == NULL) {
	    ncpu = 1; 
d346 9
a354 4
	  } else {
	    while (fgets (buf, 80, fp) != NULL) {
	      if (strncmp (buf, "processor",9) == 0) {
		++ ncpu;
a355 1
	    }
d357 11
a367 4
	  
	    if (ncpu <= 0) {
	      ncpu = 1;
	    }
d369 7
a375 2
	  goto DONE_NCPU;
	}
d378 7
a384 6
#if defined(_WIN32)
	/* Windows */
	{
	  GetSystemInfo(&sysinfo);
	  ncpu = (int)sysinfo.dwNumberOfProcessors;
	  goto DONE_NCPU;
d386 2
d390 3
a392 1
DONE_NCPU:  ; /* allows debug and final validity check */
d394 1
d396 2
a397 4
#if defined(HAS_POSIX_THREADS)
	/* if they have threading and we could not detect properly, use two */
	if (ncpu < 0) {
		ncpu = 2;
a398 1
#endif /* HAS_POSIX_THREADS */
d400 4
a403 4
	if (bu_debug & BU_DEBUG_PARALLEL) {
		/* do not use bu_log() here, this can get called before semaphores are initialized */
		fprintf( stderr, "bu_avail_cpus: counted %d cpus.\n", ncpu);
	}
d405 1
a405 5
	if (ncpu > 0) {
		return ncpu;
	}

	return( DEFAULT_PSW );
d425 2
d435 1
d450 1
d453 1
d463 1
d484 1
a604 1
#if 0
a611 1
#endif
a1067 1

d1107 1
a1107 2

#  endif /* end if posix threads */
a1142 2


@


1.36.2.1
log
@Initial ANSIfication
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.36 2002/08/20 17:07:41 jra Exp $ (ARL)";
d161 2
a162 1
bu_nice_set(int newnice)
d196 1
a196 1
bu_cpulimit_get(void)
d220 2
a221 1
bu_cpulimit_set(int sec)
d255 1
a255 1
bu_avail_cpus(void)
d398 1
a398 1
bu_get_load_average(void)
d428 1
a428 1
bu_get_public_cpus(void)
d470 1
a470 1
bu_set_realtime(void)
d572 1
a572 1
bu_parallel_interface(void)
@


1.36.2.2
log
@sync branch with HEAD
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header$ (ARL)";
a40 1
#include <sys/sysinfo.h>
a68 6
#ifdef __sp3__
#include <sys/types.h>
#include <sys/sysconfig.h>
#include <sys/var.h>
#endif

a139 3
#ifdef __sp3__
#	include	<unistd.h>
#else
a140 1
#endif
a245 2


d255 1
a255 1
	int ncpu = -1;
d257 5
d263 3
a265 23
#if defined(_SC_NPROCESSORS_ONLN)
	/* SUNOS and linux */
	ncpu = sysconf(_SC_NPROCESSORS_ONLN);
	if (ncpu < 0) {
		perror("Unable to get the number of available CPUs");
		ncpu = 1;
	}
	goto DONE_NCPU;
#elif defined(_SC_NPROC_ONLN)
	ncpu = sysconf(_SC_NPROC_ONLN);
	if (ncpu < 0) {
		perror("Unable to get the number of available CPUs");
		ncpu = 1;
	}
	goto DONE_NCPU;
#elif defined(_SC_CRAY_NCPU)
	/* cray */
	ncpu = sysconf(_SC_CRAY_NCPU);
	if (ncpu < 0) {
		perror("Unable to get the number of available CPUs");
		ncpu = 1;
	}
	goto DONE_NCPU;
a267 1

d279 7
a285 8
#  if 0
	ncpu = (int)prctl(PR_MAXPPROCS);
#  else
	ncpu = sysmp(MP_NPROCS);
#  endif
	goto DONE_NCPU;
#endif /* SGI_4D */

d288 1
a288 2
	{
	  long	memsize, ipnum, cenum, detnum, attnum;
d290 9
a298 51
#  if !defined(i860)
	  /* FX/8 */
	  lib_syscfg( &memsize, &ipnum, &cenum, &detnum, &attnum );
#  else
	  /* FX/2800 */
	  attnum = 28;
#  endif /* i860 */
	  ncpu = attnum;		/* # of CEs attached to parallel Complex */
	  goto DONE_NCPU;
	}
#endif /* alliant */


#if defined(__sp3__)
	{
	  int status;
	  int cmd;
	  int parmlen;
	  struct var p;

	  cmd = SYS_GETPARMS;
	  parmlen = sizeof(struct var);
	  if ( sysconfig(cmd, &p, parmlen) != 0 ) {
	    bu_bomb("bu_parallel(): sysconfig error for sp3");
	  }
	  ncpu = p.v_ncpus;
	  goto DONE_NCPU;
	}
#endif	/* __sp3__ */


#if defined(n16)
	if( (ncpu = sysadmin( SADMIN_NUMCPUS, 0 )) < 0 )
	  perror("sysadmin");
	goto DONE_NCPU;
#endif /* n16 */


#ifdef __FreeBSD__
	{
	  int maxproc;
	  size_t len;
	  len = 4;
	  if (sysctlbyname("hw.ncpu", &maxproc, &len, NULL, 0) == -1) {
	    ncpu = 1;
	    perror("sysctlbyname");
	  } else {
	    ncpu = maxproc;
	  }
	  goto DONE_NCPU;
	}
d301 14
d316 11
a326 23
#if defined(__ppc__)
	{
	  int mib[2], maxproc;
	  size_t len;

	  mib[0] = CTL_HW;
	  mib[1] = HW_NCPU;
	  len = sizeof(maxproc);
	  if (sysctl(mib, 2, &maxproc, &len, NULL, NULL == -1)) {
	    ncpu = 1;
	    perror("sysctl");
	  } else {
	    ncpu = maxproc; /* should be able to get sysctl to return maxproc */
	  }
	  goto DONE_NCPU;
	}
#endif /* __ppc__ */


#if defined(HAVE_GET_NPROCS)
	ncpu = get_nprocs(); /* GNU extension from sys/sysinfo.h */
	goto DONE_NCPU;
#endif
d328 1
d330 3
a332 19
#if defined(linux) && 0
	{
	  /* old retired linux method */
	  /*
	   * Ultra-kludgey way to determine the number of cpus in a 
	   * linux box--count the number of processor entries in 
	   * /proc/cpuinfo!
	   */

#	define CPUINFO_FILE "/proc/cpuinfo"
	  FILE *fp;
	  char buf[128];

	  ncpu = 0;
	
	  fp = fopen (CPUINFO_FILE,"r");
	
	  if (fp == NULL) {
	    ncpu = 1; 
d334 9
a342 4
	  } else {
	    while (fgets (buf, 80, fp) != NULL) {
	      if (strncmp (buf, "processor",9) == 0) {
		++ ncpu;
a343 1
	    }
d345 11
a355 4
	  
	    if (ncpu <= 0) {
	      ncpu = 1;
	    }
d357 1
a357 2
	  goto DONE_NCPU;
	}
d360 4
a363 7
#if defined(_WIN32)
	/* Windows */
	{
	  GetSystemInfo(&sysinfo);
	  ncpu = (int)sysinfo.dwNumberOfProcessors;
	  goto DONE_NCPU;
	}
d366 7
a372 7
DONE_NCPU:  ; /* allows debug and final validity check */


#if defined(HAS_POSIX_THREADS)
	/* if they have threading and we could not detect properly, use two */
	if (ncpu < 0) {
		ncpu = 2;
d374 3
a376 1
#endif /* HAS_POSIX_THREADS */
d378 4
a381 10
	if (bu_debug & BU_DEBUG_PARALLEL) {
		/* do not use bu_log() here, this can get called before semaphores are initialized */
		fprintf( stderr, "bu_avail_cpus: counted %d cpus.\n", ncpu);
	}

	if (ncpu > 0) {
		return ncpu;
	}

	return( DEFAULT_PSW );
a573 1
#if 0
a580 1
#endif
a1036 1

d1076 1
a1076 2

#  endif /* end if posix threads */
a1111 2


@


1.36.2.3
log
@more quelling of lots of warnings
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libbu/parallel.c,v 1.36.2.2 2004/03/17 21:16:50 morrison Exp $ (ARL)";
d136 1
a136 1
#if defined(SUNOS) && SUNOS >= 52
a254 1
	if (sec < 0) sec = 0;
d553 1
a553 1
#	if defined(IRIX64) && IRIX64 >= 64
d759 1
a759 1
#  if defined(SUNOS) && SUNOS >= 52
d762 1
a762 1
#  if (defined(SUNOS) && SUNOS >= 52) || defined(HAS_POSIX_THREADS)
d1007 1
a1007 1
#  if defined(SUNOS) && SUNOS >= 52
d1128 1
a1128 1
#    if defined(__FreeBSD__)
@


1.35
log
@Converted from K&R to ANSI C - RFH
@
text
@d161 2
a162 1
bu_nice_set(int newnice)
d196 1
a196 1
bu_cpulimit_get(void)
d220 2
a221 1
bu_cpulimit_set(int sec)
d255 1
a255 1
bu_avail_cpus(void)
d398 1
a398 1
bu_get_load_average(void)
d428 1
a428 1
bu_get_public_cpus(void)
d470 1
a470 1
bu_set_realtime(void)
d572 1
a572 1
bu_parallel_interface(void)
@


1.34
log
@Patch for SGI to get the number of CPUs configured in the system.
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.33 2002/03/14 14:07:03 jra Exp $ (ARL)";
d161 1
a161 2
bu_nice_set(newnice)
int	newnice;
d195 1
a195 1
bu_cpulimit_get()
d219 1
a219 2
bu_cpulimit_set(sec)
int	sec;
d253 1
a253 1
bu_avail_cpus()
d396 1
a396 1
bu_get_load_average()
d426 1
a426 1
bu_get_public_cpus()
d468 1
a468 1
bu_set_realtime()
d570 1
a570 1
bu_parallel_interface()
@


1.33
log
@bu_parallel() will now limit number of procs to bu_avail_cpus()
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.32 2002/03/13 20:54:36 jra Exp $ (ARL)";
d100 1
d271 11
d283 3
@


1.32
log
@On SGI, trim number of cpus requested to avoid failure of sprocsp()
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.31 2002/01/24 21:45:07 rbowers Exp $ (ARL)";
d638 1
a653 1
	int	avail_cpus;
d688 6
a772 7
	avail_cpus = bu_avail_cpus();

	if( ncpu > avail_cpus + 1 ) {
		bu_log( "%d cpus requested, but only %d available\n", ncpu, bu_avail_cpus() );
		bu_log( "\t(NOTE: timings are likely incorrect)\n" );
		ncpu = avail_cpus + 1;
	}
@


1.31
log
@-* modified bu_avail_cpus to count the number of cpus on a linux box
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.30 2001/10/17 08:50:45 morrison Exp $ (ARL)";
d653 1
d767 7
@


1.30
log
@typo
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.29 2001/10/17 07:40:02 morrison Exp $ (ARL)";
d258 6
d296 1
a296 1
#if defined(HAS_POSIX_THREADS)
d303 2
a304 1
/* These machines may or may not have posix threads, but (more importantly)
d307 39
d349 1
a349 1
		perror("sysadmin");
@


1.29
log
@Mac OS X warning and error fixes for non-production build
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.28 2001/10/15 19:58:03 morrison Exp $ (ARL)";
d614 1
a614 1
#  if SUBOS >= 52
@


1.28
log
@Added "Darwin on Power Macintosh" support (finally)
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.27 2001/03/19 22:19:45 butler Exp $ (ARL)";
d59 7
a65 1
#include <sys/param.h>
d444 4
d471 1
a471 1
	register int i;
d473 14
a486 6
	for (i=1 ; i < MAX_PSW ; ++i)
	    if ( tbl[i] )
	    	if( kill(tbl[i], 9) )
			perror("bu_kill_workers(): SIGKILL to child process");
		else
			bu_log("bu_kill_workers(): child pid %d killed\n", tbl[i]);
a487 2
	bzero( (char *)tbl, sizeof(tbl) );
}
d519 1
a519 2
		fprintf(stderr,"bu_parallel_interface, Thread ID = 0x%x\n",
			pt);
d593 1
a593 1
#if defined(alliant) && !defined(i860) && !__STDC__
d596 1
a596 1
#endif
d598 2
d601 3
a603 1
#ifdef sgi
d609 1
a609 1
#endif
d614 4
a617 1
#if SUNOS >= 52 || defined(HAS_POSIX_THREADS)
a619 1
	static int	concurrency = 0; /* Max concurrency we have set */
d623 1
a623 1
#endif	/* SUNOS */
d642 1
a642 1
#ifdef HEP
d650 1
a650 1
#endif /* HEP */
d652 2
a653 2
#ifdef CRAY
#if 0
d657 1
a657 1
#endif
d674 1
a674 1
#endif
d676 1
a676 1
#if defined(alliant) && !defined(i860)
d694 1
a694 1
#endif
d696 1
a696 1
#if defined(alliant) && defined(i860)
d701 1
a701 1
#endif
d703 1
a703 1
#if defined(convex) || defined(__convex__)
d708 1
a708 1
#endif /* convex */
d710 1
a710 1
#ifdef ardent
d713 1
a713 1
#endif /* ardent */
d715 1
a715 1
#ifdef SGI_4D
d729 1
a729 1
#if IRIX <= 4
d732 1
a732 1
#else
d750 1
a750 1
#endif
d786 1
a786 1
#ifdef IRIX
d804 1
a804 1
#endif
d844 1
a844 1
#endif /* sgi */
d846 1
a846 1
#if defined(n16)
d851 1
a851 1
#endif
d856 1
a856 1
#if SUNOS >= 52
d938 3
a940 2
#endif	/* SUNOS */
#if defined(HAS_POSIX_THREADS)
a949 1
		size_t size;
d956 1
a956 1
				bu_parallel_interface, &thread, x);
d976 1
a976 1
#if __FreeBSD__
d979 1
a979 1
#endif
d997 1
a997 1
			fprintf(stderr, "pthread_join(thread_tbl[%d]=0x%x) ret=%d\n", x, thread_tbl[x], ret);
d1010 1
a1010 1
#endif
d1029 1
a1029 1
#ifdef CHECK_PIDS
d1040 1
a1040 1
#endif
@


1.27
log
@patches to merge 5.3 into 6.0
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /d/CVS/brlcad/libbu/parallel.c,v 1.26 2000/09/08 05:52:13 mike Exp $ (ARL)";
d52 11
d252 5
d285 2
a286 1
	/* XXX Posix doesn't specify how to learn how many CPUs there are. */
d290 5
d298 12
@


1.26
log
@
OK, give 'em 64M of stack per processor on IRIX64.
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.25 2000/09/07 01:14:55 mike Exp $ (ARL)";
a80 3
#if ( IRIX == 6 ) && !defined(IRIX64)
typedef __uint64_t k_sigset_t;  /* signal set type */
#endif
@


1.25
log
@
On IRIX64, allocate larger per-thread stacks.
A combination with 2000 members overflowed an 8 MByte stack.
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.24 2000/09/06 21:09:35 mike Exp $ (ARL)";
d693 1
a693 1
				32*1024*1024 - 32*1024
@


1.24
log
@
Made attempt at adding "stack overflow" buffer zone.
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.23 2000/08/20 03:54:11 butler Exp $ (ARL)";
d693 1
a693 1
				8*1024*1024 - 32*1024
@


1.23
log
@Fixes for linux compilation
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.22 2000/07/07 05:20:13 cjohnson Exp $ (ARL)";
d686 3
d693 1
a693 1
				8*1024*1024
d695 1
a695 1
				4*1024*1024
@


1.22
log
@LINT
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.21 2000/07/07 00:37:35 cjohnson Exp $ (ARL)";
d35 8
d152 1
d154 1
@


1.21
log
@LINT
@
text
@d18 1
a18 1
static char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.20 2000/03/24 22:45:13 mike Exp $ (ARL)";
d396 1
a430 1

d486 1
@


1.20
log
@
Added detection for SGI's second real-time mode.
@
text
@d18 1
a18 1
static char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.19 2000/03/09 03:44:19 cjohnson Exp $ (ARL)";
d26 5
d35 9
d141 1
a141 2
	int opri, npri, chg;
	int bias;
d149 2
@


1.20.2.1
log
@Eliminated redefinition of a type from sys/types.h
@
text
@d18 1
a18 1
static char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.20 2000/03/24 22:45:13 mike Exp $ (ARL)";
d59 3
@


1.19
log
@Turn on POSIX THREADS parallel support.  Does not currently have anything
that says "go use multiple CPUS"
@
text
@d18 1
a18 1
static char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.18 2000/01/14 05:27:56 mike Exp $ (ARL)";
d354 1
a354 1
			if( policy == SCHED_RR )
@


1.18
log
@
Changed SGI stack size for threads.
@
text
@d18 1
a18 1
static char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.17 1999/12/01 02:48:26 mike Exp $ (ARL)";
d249 1
d866 5
a870 1
	for (x = 0; x < ncpu; x++)  {
d872 1
a872 1
		if (pthread_create(&thread, 0,
@


1.17
log
@
lint fix
@
text
@d18 1
a18 1
static char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.16 1998/11/05 19:49:36 mike Exp $ (ARL)";
d651 1
a651 1
		/*  Stack size per proc comes from RLIMIT_STACK (64MBytes). */
d654 6
d661 7
a667 1
			PR_SALL, 0, NULL, 4*1024*1024 );
@


1.16
log
@Incorporated HAS_POSIX_THREADS support from Chris Johnson of NetGSI.
Limited testing on FreeBSD only.
@
text
@d18 1
a18 1
static char RCSparallel[] = "@@(#)$Header: /c/CVS/brlcad/libbu/parallel.c,v 1.15 1998/04/27 22:13:44 mike Exp $ (ARL)";
d738 5
a742 5
#if 0
		bu_log("Original position was x%x, now position is x%x!\n", stdin_pos, ftell(stdin) );
		bu_pr_FILE("saved stdin", &stdin_save);
		bu_pr_FILE("current stdin", stdin);
#endif
@


1.15
log
@Modified bu_parallel() to pass an argument into the parallel thread.
@
text
@d18 1
a18 1
static char RCSparallel[] = "@@(#)$Header: /m/cad/libbu/RCS/parallel.c,v 1.14 1997/12/04 02:49:38 mike Exp mike $ (ARL)";
d96 1
d99 9
d246 4
d269 1
a269 1
 *  Alas, very very systems put the load average in /proc,
d442 8
d537 1
a537 1
#if SUNOS >= 52
d541 2
a542 2
	thread_t	thread;
	thread_t	thread_tbl[MAX_PSW];
d791 1
a791 1
				bu_log("bu_parallel(): created thread: (thread: %d) (loop:%d) (nthreadc:%d)\n",
d801 1
a801 1
			bu_log("bu_parallel(): thread_tbl[%d] = %d\n",
d817 1
a817 1
		if (thr_join((thread_t)0, &thread, NULL)) {
d825 1
a825 1
				thread_tbl[i] = -1;
d831 1
a831 1
		if ((thread_tbl[i] != -1) && i < nthreadc) {
d845 68
@


1.14
log
@IRIX64 doesn't need the IRIX6 bug fix.
@
text
@d18 1
a18 1
static char RCSparallel[] = "@@(#)$Header: /m/cad/libbu/RCS/parallel.c,v 1.13 1997/12/04 02:47:34 mike Exp mike $ (ARL)";
d405 2
a406 1
static void	(*bu_parallel_func) BU_ARGS((int));	/* user function to run in parallel */
d432 1
a432 1
	(*bu_parallel_func)(cpu);
d491 4
a494 3
bu_parallel( func, ncpu )
void	(*func) BU_ARGS((int));
int	ncpu;
d525 1
a525 1
		bu_log("bu_parallel(0x%x, %d)\n", func, ncpu );
d539 1
d548 1
a548 1
	(*func)(0);	/* avoid wasting this task */
d566 1
a566 1
	(*func)(0);	/* avoid wasting this task */
d647 1
a647 1
	(*func)(0);	/* don't waste this thread */
d855 2
a856 2
	bu_log("bu_parallel( x%x, %d. ):  Not compiled for PARALLEL machine\n",
		func, ncpu );
@


1.13
log
@sched_setscheduler() is an IRIX64 version 6.4 thing.
@
text
@d18 1
a18 1
static char RCSparallel[] = "@@(#)$Header: /m/cad/libbu/RCS/parallel.c,v 1.12 1997/11/22 02:58:14 mike Exp mike $ (ARL)";
d59 1
a59 1
#if ( IRIX == 6 )
@


1.12
log
@Initialized global variables to zero, for safety sake.  (Irix 6.4 paranoia)
@
text
@d18 1
a18 1
static char RCSparallel[] = "@@(#)$Header: /m/cad/libbu/RCS/parallel.c,v 1.11 1997/11/14 04:44:40 mike Exp $ (ARL)";
d71 1
a71 1
#if IRIX >= 6
d334 1
a334 1
#	if IRIX >= 6
@


1.11
log
@bu_parallel() now invokes it's function with the cpu (thread) number
as a parameter.
It also performs some error checking that was previously done
in do_run() inside rt.
@
text
@d18 1
a18 1
static char RCSparallel[] = "@@(#)$Header: /m/cad/libbu/RCS/parallel.c,v 1.10 1997/09/20 15:23:25 butler Exp mike $ (ARL)";
d403 2
a404 2
static int	bu_nthreads_started;		/* # threads started */
static int	bu_nthreads_finished;		/* # threads properly finished */
@


1.10
log
@sched.h is in /usr/include/sys
@
text
@d18 1
a18 1
static char RCSparallel[] = "@@(#)$Header: /m/cad/libbu/RCS/parallel.c,v 1.9 1997/08/22 21:58:24 mike Exp butler $ (ARL)";
d401 6
a406 1
#ifdef SGI_4D
d408 1
a408 1
 *			B U _ S G I _ F U N C
d410 5
a414 4
 *	On an SGI, a process/thread created with the "sproc" syscall has
 *	all of it's file descriptors closed when it "returns" to sproc.
 *	Since this trashes file descriptors which may still be in use by
 *	other processes, we avoid ever returning to sproc.
d416 5
a420 3
 *	Rather than calling sproc with the worker function, it is called with
 *	bu_sgi_func().  When "func" returns, calling _exit() gets the process
 *	killed without going through the file-descriptor bashing
a421 1
#if IRIX <= 4
d423 1
a423 2
bu_sgi_func( arg )
void	*arg;
d425 1
a425 1
	void	(*func)() = (void (*)())arg;
d427 3
a429 1
	(*func)();
d431 1
a431 9
	_exit(0);
}
#else
static void
bu_sgi_func( arg, stksize )
void	*arg;
size_t	stksize;
{
	void	(*func)() = (void (*)())arg;
d433 3
a435 1
	(*func)();
d437 9
a445 1
	_exit(0);
a446 1
#endif
d448 1
a469 2
extern int	bu_pid_of_initiating_thread;

a475 2
 *  No parameters are passed to 'func', because not all machines
 *  can arrange for that.
d477 3
d481 1
a481 2
 *  of the subroutine are finished.  The caller might want to double-check
 *  this, using cooperation with 'func'.
d491 1
a491 1
void	(*func)();
d525 3
d534 3
d539 2
d543 1
a543 1
		Dcreate( *func );
d545 1
a545 1
	(*func)();	/* avoid wasting this task */
d555 2
d561 1
a561 1
		TSKSTART( &bu_taskcontrol[x], func );
d563 1
a563 1
	(*func)();	/* avoid wasting this task */
a564 1
	/* There needs to be some way to kill the tfork()'ed processes here */
d569 1
d577 2
a578 2
	/* Calls func in parallel "ncpu" times */
	concurrent_call(CNCALL_COUNT|CNCALL_NO_QUIT, func, ncpu);
d586 1
a586 1
		(*func)();		/* d7 has current index, like magic */
d595 1
a595 1
                (*func)();
d602 1
a602 1
		(*func)();
d608 1
a608 1
	parstack( func, 1024*1024, ncpu );
d614 2
d627 1
a627 1
		new = sproc( bu_sgi_func, PR_SALL, func );
d629 2
a630 1
		new = sprocsp( bu_sgi_func, PR_SALL, (void *)func, NULL, 4*1024*1024 );
d634 2
a635 2
			bu_log("ERROR parallel.c/bu_parallel(): sproc(x%x, x%x, )=%d failed on processor %d\n",
				func, PR_SALL,
d644 1
a644 1
	(*func)();
d730 1
a730 1
	if( task_init( 8*1024*1024, ncpu, func, 128*1024, 0 ) < 0 )
d758 1
a758 1
		if (thr_create(0, 0, (void *(*)(void *))func, 0, 0, &thread)) {
d760 1
a760 1
				func, &thread, x);
d762 1
a762 1
				func, &thread, x);
d821 14
d836 1
a836 1
		bu_log("bu_parallel() complete, now serial\n");
@


1.9
log
@Added comment
@
text
@d18 1
a18 1
static char RCSparallel[] = "@@(#)$Header: /m/cad/libbu/RCS/parallel.c,v 1.8 1997/08/22 21:51:10 mike Exp mike $ (ARL)";
d72 1
a72 1
# include <sched.h>
@


1.8
log
@JRA, added type cast
@
text
@d18 1
a18 1
static char RCSparallel[] = "@@(#)$Header: /m/cad/libbu/RCS/parallel.c,v 1.7 1997/07/30 04:00:54 mike Exp jra $ (ARL)";
d248 1
d255 3
@


1.7
log
@Fixed bad external symbol name.
@
text
@d18 1
a18 1
static char RCSparallel[] = "@@(#)$Header: /m/cad/libbu/RCS/parallel.c,v 1.6 1997/07/02 00:37:36 mike Exp mike $ (ARL)";
d605 1
a605 1
		new = sprocsp( bu_sgi_func, PR_SALL, func, NULL, 4*1024*1024 );
@


1.6
log
@removed noxious print
@
text
@d18 1
a18 1
static char RCSparallel[] = "@@(#)$Header: /m/cad/libbu/RCS/parallel.c,v 1.5 1997/07/02 00:31:09 mike Exp mike $ (ARL)";
d73 1
a73 1
struct sched_param param;
d339 1
a339 1
		sched_getparam( 0, &param );
d343 1
a343 1
			&param
@


1.5
log
@IRIX64
@
text
@d18 1
a18 1
static char RCSparallel[] = "@@(#)$Header: /m/cad/libbu/RCS/parallel.c,v 1.4 1997/07/01 23:36:19 mike Exp mike $ (ARL)";
a346 1
	 	perror("bu_set_realtime(): sched_setscheduler");
@


1.4
log
@Moved functions in from remrt/
@
text
@d18 1
a18 1
static char RCSparallel[] = "@@(#)$Header: /m/cad/libbu/RCS/parallel.c,v 1.3 1997/03/07 07:06:29 mike Exp mike $ (ARL)";
d71 4
@


1.3
log
@On Irix 5, changed to not gobble as much stack space.
The default behavior was gobbling so much stack that
it couldn't run in 2 Gbytes on a 36 processor machine.
@
text
@d18 1
a18 1
static char RCSparallel[] = "@@(#)$Header: /m/cad/libbu/RCS/parallel.c,v 1.2 1996/08/29 05:53:28 mike Exp mike $ (ARL)";
d242 106
@


1.2
log
@Split off some parallel routines into ispar.c
@
text
@d18 1
a18 1
static char RCSparallel[] = "@@(#)$Header: /m/cad/libbu/RCS/parallel.c,v 1.1 1996/08/27 06:18:33 mike Exp mike $ (ARL)";
d301 1
d312 7
d320 6
d484 2
d492 7
a498 1
		if( (new = sproc( bu_sgi_func, PR_SALL, func )) < 0 )  {
d501 3
a503 1
				new, func, PR_SALL, x );
@


1.1
log
@Initial revision
@
text
@d18 1
a18 1
static char RCSparallel[] = "@@(#)$Header$ (ARL)";
d107 1
d333 1
a333 1
static int	bu_pid_of_initiating_thread;
a683 14

/*
 *			B U _ I S _ P A R A L L E L
 *
 *  A clean way for bu_bomb() to tell if this is a parallel application.
 *  If bu_parallel() is active, this routine will return non-zero.
 */
int
bu_is_parallel()
{
	if( bu_pid_of_initiating_thread != 0 )  return 1;
	return 0;
}

@
