head	1.14;
access;
symbols
	ansi-20040405-merged:1.10.2.2
	postmerge-20040405-ansi:1.12
	premerge-20040404-ansi:1.11
	postmerge-autoconf:1.11
	autoconf-freeze:1.10.10.2
	premerge-autoconf:1.11
	ansi-20040316-freeze:1.10.2.1
	postmerge-20040315-windows:1.11
	premerge-20040315-windows:1.11
	windows-20040315-freeze:1.10.4.1
	autoconf-20031203:1.10
	autoconf-20031202:1.10
	autoconf-branch:1.10.0.10
	phong-branch:1.10.0.8
	photonmap-branch:1.10.0.6
	rel-6-1-DP:1.10
	windows-branch:1.10.0.4
	rel-6-0-2:1.8
	ansi-branch:1.10.0.2
	rel-6-0-1-branch:1.8.0.2
	hartley-6-0-post:1.9
	hartley-6-0-pre:1.8
	rel-6-0-1:1.8
	rel-6-0:1.8
	rel-5-4:1.7
	offsite-5-3-pre:1.8
	rel-5-3:1.7
	rel-5-2:1.7
	rel-5-1-branch:1.7.0.2
	rel-5-1:1.7
	rel-5-0:1.6
	rel-5-0-beta:1.5
	rel-4-5:1.3
	ctj-4-5-post:1.3
	ctj-4-5-pre:1.3;
locks; strict;
comment	@ * @;


1.14
date	2004.05.21.18.06.24;	author morrison;	state dead;
branches;
next	1.13;

1.13
date	2004.05.10.15.30.44;	author erikg;	state Exp;
branches;
next	1.12;

1.12
date	2004.04.05.07.46.16;	author morrison;	state Exp;
branches;
next	1.11;

1.11
date	2004.02.02.17.39.07;	author morrison;	state Exp;
branches;
next	1.10;

1.10
date	2002.08.20.17.07.42;	author jra;	state Exp;
branches
	1.10.2.1
	1.10.4.1
	1.10.10.1;
next	1.9;

1.9
date	2002.08.15.20.54.54;	author hartley;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.07.05.20.13;	author cjohnson;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.28.18.55.09;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	99.07.02.19.05.57;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	99.01.12.16.19.55;	author pjt;	state Exp;
branches;
next	1.4;

1.4
date	98.12.30.01.25.44;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	96.08.31.09.39.29;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	95.09.20.12.34.44;	author pjt;	state Exp;
branches;
next	1.1;

1.1
date	95.07.10.20.15.52;	author pjt;	state Exp;
branches;
next	;

1.10.2.1
date	2002.09.19.18.01.13;	author morrison;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2004.03.17.21.16.50;	author morrison;	state Exp;
branches;
next	;

1.10.4.1
date	2004.03.11.23.41.49;	author morrison;	state Exp;
branches;
next	;

1.10.10.1
date	2004.02.12.18.39.19;	author erikg;	state Exp;
branches;
next	1.10.10.2;

1.10.10.2
date	2004.03.15.14.06.17;	author erikg;	state Exp;
branches;
next	;


desc
@     Routines to free red-black trees and associated structures
@


1.14
log
@moved to src/
@
text
@/*			R B _ F R E E . C
 *
 *		Routine to free a red-black tree
 *
 *  Author -
 *	Paul J. Tanenbaum
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1998-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char libbu_rb_free_RCSid[] = "@@(#) $Header: /n/xoff/cvs/brlcad/libbu/rb_free.c,v 1.13 2004/05/10 15:30:44 erikg Exp $";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "bu.h"
#include "./rb_internals.h"

/*			B U _ R B _ F R E E ( )
 *
 *		      Free a red-black tree
 *
 *	This function has two parameters: the tree to free and a function
 *	to handle the application data.  bu_rb_free() traverses tree's lists
 *	of nodes and packages, freeing each one in turn, and then frees tree
 *	itself.  If free_data is non-NULL, then bu_rb_free() calls it just
 *	before freeing each package , passing it the package's rbp_data
 *	member.  Otherwise, the application data is left untouched.
 */
void bu_rb_free (bu_rb_tree *tree, void (*free_data) (/* ??? */))
{
    struct bu_rb_list		*rblp;
    struct bu_rb_node		*node;
    struct bu_rb_package	*package;

    BU_CKMAG(tree, BU_RB_TREE_MAGIC, "red-black tree");

    /*
     *	Free all the nodes
     */
    while (BU_LIST_WHILE(rblp, bu_rb_list, &(tree -> rbt_nodes.l)))
    {
	BU_CKMAG(rblp, BU_RB_LIST_MAGIC, "red-black list element");
	bu_rb_free_node(rblp -> rbl_node);
    }

    /*
     *	Free all the packages
     */
    while (BU_LIST_WHILE(rblp, bu_rb_list, &(tree -> rbt_packages.l)))
    {
	BU_CKMAG(rblp, BU_RB_LIST_MAGIC, "red-black list element");
	package = rblp -> rbl_package;
	BU_CKMAG(package, BU_RB_PKG_MAGIC, "red-black package");
	if (free_data)
	    (*free_data)(package -> rbp_data);
	bu_rb_free_package(package);
    }

    /*
     *	Free the tree's NIL sentinel
     */
    node = tree -> rbt_empty_node;
    bu_free((genptr_t) node -> rbn_left, "red-black left children");
    bu_free((genptr_t) node -> rbn_right, "red-black right children");
    bu_free((genptr_t) node -> rbn_parent, "red-black parents");
    bu_free((genptr_t) node -> rbn_color, "red-black colors");
    bu_free((genptr_t) node -> rbn_package, "red-black packages");
    bu_free((genptr_t) node, "red-black empty node");

    /*
     *	Free the tree itself
     */
    bu_free((genptr_t) tree -> rbt_root, "red-black roots");
    bu_free((genptr_t) tree -> rbt_unique, "red-black uniqueness flags");
    bu_free((genptr_t) tree, "red-black tree");
}

/*		    B U _ R B _ F R E E _ N O D E ( )
 *
 *	    Relinquish memory occupied by a red-black node
 *
 *	This function has one parameter: a node to free.  bu_rb_free_node()
 *	frees the memory allocated for the various members of the node
 *	and then frees the memory allocated for the node itself.
 */
void bu_rb_free_node (struct bu_rb_node *node)
{
    bu_rb_tree	*tree;

    BU_CKMAG(node, BU_RB_NODE_MAGIC, "red-black node");

    tree = node -> rbn_tree;
    if (bu_rb_current(tree) == node)
	bu_rb_current(tree) = bu_rb_null(tree);
    BU_CKMAG(node, BU_RB_NODE_MAGIC, "red-black node");

    /*
     *	Remove node from the list of all nodes
     */
    BU_CKMAG(node -> rbn_list_pos, BU_RB_LIST_MAGIC, "red-black list element");
    BU_LIST_DEQUEUE(&(node -> rbn_list_pos -> l));

    bu_free((genptr_t) node -> rbn_parent, "red-black parents");
    bu_free((genptr_t) node -> rbn_left, "red-black left children");
    bu_free((genptr_t) node -> rbn_right, "red-black right children");
    bu_free((genptr_t) node -> rbn_color, "red-black colors");
    bu_free((genptr_t) node -> rbn_package, "red-black packages");
    bu_free((genptr_t) node -> rbn_list_pos, "red-black list element");
    bu_free((genptr_t) node, "red-black node");
}

/*		    B U _ R B _ F R E E _ P A C K A G E ( )
 *
 *	    Relinquish memory occupied by a red-black package
 *
 *	This function has one parameter: a package to free.
 *	bu_rb_free_package() frees the memory allocated to point to the
 *	nodes that contained the package and then frees the memory
 *	allocated for the package itself.
 */
void bu_rb_free_package (struct bu_rb_package *package)
{
    BU_CKMAG(package, BU_RB_PKG_MAGIC, "red-black package");

    /*
     *	Remove node from the list of all packages
     */
    BU_CKMAG(package -> rbp_list_pos, BU_RB_LIST_MAGIC,
	"red-black list element");
    BU_LIST_DEQUEUE(&(package -> rbp_list_pos -> l));

    bu_free((genptr_t) package -> rbp_node, "red-black package nodes");
    bu_free((genptr_t) package -> rbp_list_pos, "red-black list element");
    bu_free((genptr_t) package, "red-black package");
}
@


1.13
log
@change conf.h to a wrapped config.h
@
text
@d22 1
a22 1
static const char libbu_rb_free_RCSid[] = "@@(#) $Header: /cvs/brlcad/libbu/rb_free.c,v 1.12 2004/04/05 07:46:16 morrison Exp $";
@


1.12
log
@merge of ansi-6-0-branch into HEAD
@
text
@d22 1
a22 1
static const char libbu_rb_free_RCSid[] = "@@(#) $Header$";
d25 5
a29 1
#include "conf.h"
@


1.11
log
@update copyright to include span through 2003
@
text
@d22 1
a22 1
static const char libbu_rb_free_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_free.c,v 1.10 2002/08/20 17:07:42 jra Exp $";
d44 1
a44 5
void bu_rb_free (tree, free_data)

bu_rb_tree	*tree;
void		(*free_data)();

d101 1
a101 4
void bu_rb_free_node (node)

struct bu_rb_node	*node;

d136 1
a136 4
void bu_rb_free_package (package)

struct bu_rb_package	*package;

@


1.10
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1998 by the United States Army
d22 1
a22 1
static const char libbu_rb_free_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_free.c,v 1.8 2000/07/07 05:20:13 cjohnson Exp $";
@


1.10.4.1
log
@sync to HEAD...
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d22 1
a22 1
static const char libbu_rb_free_RCSid[] = "@@(#) $Header: /n/cad/c/CVS/brlcad/libbu/rb_free.c,v 1.11 2004/02/02 17:39:07 morrison Exp $";
@


1.10.10.1
log
@merge from HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d22 1
a22 1
static const char libbu_rb_free_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_free.c,v 1.11 2004/02/02 17:39:07 morrison Exp $";
@


1.10.10.2
log
@merge from head
@
text
@d22 1
a22 1
static const char libbu_rb_free_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_free.c,v 1.10.10.1 2004/02/12 18:39:19 erikg Exp $";
@


1.10.2.1
log
@Initial ANSIfication
@
text
@d22 1
a22 1
static const char libbu_rb_free_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_free.c,v 1.10 2002/08/20 17:07:42 jra Exp $";
d44 5
a48 1
void bu_rb_free (bu_rb_tree *tree, void (*free_data) (/* ??? */))
d105 4
a108 1
void bu_rb_free_node (struct bu_rb_node *node)
d143 4
a146 1
void bu_rb_free_package (struct bu_rb_package *package)
@


1.10.2.2
log
@sync branch with HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d22 1
a22 1
static const char libbu_rb_free_RCSid[] = "@@(#) $Header$";
@


1.9
log
@Converted from K&R to ANSI C - RFH
@
text
@d44 5
a48 1
void bu_rb_free (bu_rb_tree *tree, void (*free_data) (/* ??? */))
d105 4
a108 1
void bu_rb_free_node (struct bu_rb_node *node)
d143 4
a146 1
void bu_rb_free_package (struct bu_rb_package *package)
@


1.8
log
@LINT
@
text
@d22 1
a22 1
static const char libbu_rb_free_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_free.c,v 1.7 2000/03/28 18:55:09 mike Exp $";
d44 1
a44 5
void bu_rb_free (tree, free_data)

bu_rb_tree	*tree;
void		(*free_data)();

d101 1
a101 4
void bu_rb_free_node (node)

struct bu_rb_node	*node;

d136 1
a136 4
void bu_rb_free_package (package)

struct bu_rb_package	*package;

@


1.7
log
@
Put libbu_filename_ prefixes on RCSid variables.
@
text
@d22 1
a22 1
static char libbu_rb_free_RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_free.c,v 1.6 1999/07/02 19:05:57 mike Exp $";
@


1.6
log
@
Removed dependency on compat4.h
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_free.c,v 1.5 1999/01/12 16:19:55 pjt Exp $";
@


1.5
log
@Various details concerning folding libredblack into libbu
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_free.c,v 1.4 1998/12/30 01:25:44 mike Exp $";
d59 1
a59 1
    while (RT_LIST_WHILE(rblp, bu_rb_list, &(tree -> rbt_nodes.l)))
d68 1
a68 1
    while (RT_LIST_WHILE(rblp, bu_rb_list, &(tree -> rbt_packages.l)))
d123 1
a123 1
    RT_LIST_DEQUEUE(&(node -> rbn_list_pos -> l));
d155 1
a155 1
    RT_LIST_DEQUEUE(&(package -> rbp_list_pos -> l));
@


1.4
log
@LibRedBlack routines now have a bu_ prefix.
@
text
@d1 1
a1 1
/*			B U _ R B _ F R E E . C
d22 1
a22 1
static char RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libbu/rb_free.c,v 1.3 1996/08/31 09:39:29 mike Exp $";
@


1.3
log
@Converted to LIBBU
@
text
@d1 1
a1 1
/*			R B _ F R E E . C
d5 15
a19 2
 *	Author:	Paul Tanenbaum
 *
d22 1
a22 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_free.c,v 1.2 1995/09/20 12:34:44 pjt Exp mike $";
a30 1
#include "redblack.h"
d33 1
a33 1
/*			R B _ F R E E ( )
d38 1
a38 1
 *	to handle the application data.  rb_free() traverses tree's lists
d40 3
a42 3
 *	itself.  If free_data is non-NULL, then rb_free() calls it just
 *	before freeing each package , passing it the package's rbp_data member.
 *	Otherwise, the application data is left untouched.
d44 1
a44 1
void rb_free (tree, free_data)
d46 2
a47 2
rb_tree	*tree;
void	(*free_data)();
d50 3
a52 3
    struct rb_list	*rblp;
    struct rb_node	*node;
    struct rb_package	*package;
d54 1
a54 1
    RB_CKMAG(tree, RB_TREE_MAGIC, "red-black tree");
d59 1
a59 1
    while (RT_LIST_WHILE(rblp, rb_list, &(tree -> rbt_nodes.l)))
d61 2
a62 2
	RB_CKMAG(rblp, RB_LIST_MAGIC, "red-black list element");
	rb_free_node(rblp -> rbl_node);
d68 1
a68 1
    while (RT_LIST_WHILE(rblp, rb_list, &(tree -> rbt_packages.l)))
d70 1
a70 1
	RB_CKMAG(rblp, RB_LIST_MAGIC, "red-black list element");
d72 1
a72 1
	RB_CKMAG(package, RB_PKG_MAGIC, "red-black package");
d75 1
a75 1
	rb_free_package(package);
d97 1
a97 1
/*		    R B _ F R E E _ N O D E ( )
d101 1
a101 1
 *	This function has one parameter: a node to free.  rb_free_node()
d105 1
a105 1
void rb_free_node (node)
d107 1
a107 1
struct rb_node	*node;
d110 1
a110 1
    rb_tree	*tree;
d112 1
a112 1
    RB_CKMAG(node, RB_NODE_MAGIC, "red-black node");
d115 3
a117 3
    if (rb_current(tree) == node)
	rb_current(tree) = rb_null(tree);
    RB_CKMAG(node, RB_NODE_MAGIC, "red-black node");
d122 1
a122 1
    RB_CKMAG(node -> rbn_list_pos, RB_LIST_MAGIC, "red-black list element");
d134 1
a134 1
/*		    R B _ F R E E _ P A C K A G E ( )
d139 1
a139 1
 *	rb_free_package() frees the memory allocated to point to the
d143 1
a143 1
void rb_free_package (package)
d145 1
a145 1
struct rb_package	*package;
d148 1
a148 1
    RB_CKMAG(package, RB_PKG_MAGIC, "red-black package");
d153 2
a154 1
    RB_CKMAG(package -> rbp_list_pos, RB_LIST_MAGIC, "red-black list element");
@


1.2
log
@Tweeked a comment
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_free.c,v 1.1 1995/07/10 20:15:52 pjt Exp pjt $";
d17 1
a17 2
#include "vmath.h"
#include "raytrace.h"
d70 6
a75 6
    rt_free((char *) node -> rbn_left, "red-black left children");
    rt_free((char *) node -> rbn_right, "red-black right children");
    rt_free((char *) node -> rbn_parent, "red-black parents");
    rt_free((char *) node -> rbn_color, "red-black colors");
    rt_free((char *) node -> rbn_package, "red-black packages");
    rt_free((char *) node, "red-black empty node");
d80 3
a82 3
    rt_free((char *) tree -> rbt_root, "red-black roots");
    rt_free((char *) tree -> rbt_unique, "red-black uniqueness flags");
    rt_free((char *) tree, "red-black tree");
d113 7
a119 7
    rt_free((char *) node -> rbn_parent, "red-black parents");
    rt_free((char *) node -> rbn_left, "red-black left children");
    rt_free((char *) node -> rbn_right, "red-black right children");
    rt_free((char *) node -> rbn_color, "red-black colors");
    rt_free((char *) node -> rbn_package, "red-black packages");
    rt_free((char *) node -> rbn_list_pos, "red-black list element");
    rt_free((char *) node, "red-black node");
d144 3
a146 3
    rt_free((char *) package -> rbp_node, "red-black package nodes");
    rt_free((char *) package -> rbp_list_pos, "red-black list element");
    rt_free((char *) package, "red-black package");
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_create.c,v 11.3 1995/07/07 15:29:00 pjt Exp $";
d27 1
a27 1
 *	to handle the application data.  Rb_free() traverses tree's lists
@
