head	11.36;
access;
symbols
	ansi-20040405-merged:11.32.2.2
	postmerge-20040405-ansi:11.34
	premerge-20040404-ansi:11.33
	postmerge-autoconf:11.33
	autoconf-freeze:11.32.10.2
	premerge-autoconf:11.33
	postmerge-20040315-windows:11.33
	premerge-20040315-windows:11.33
	windows-20040315-freeze:11.32.4.1
	autoconf-20031203:11.32
	autoconf-20031202:11.32
	autoconf-branch:11.32.0.10
	phong-branch:11.32.0.8
	photonmap-branch:11.32.0.6
	rel-6-1-DP:11.32
	windows-branch:11.32.0.4
	rel-6-0-2:11.30
	ansi-branch:11.32.0.2
	rel-6-0-1-branch:11.30.0.2
	hartley-6-0-post:11.31
	hartley-6-0-pre:11.30
	rel-6-0-1:11.30
	rel-6-0:11.29
	rel-5-4:11.23
	offsite-5-3-pre:11.25
	rel-5-3:11.23
	rel-5-2:11.23
	rel-5-1-branch:11.23.0.2
	rel-5-1:11.23
	rel-5-0:11.20
	rel-5-0-beta:11.19
	rel-4-5:11.15
	ctj-4-5-post:11.13
	ctj-4-5-pre:11.13
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.36
date	2004.05.21.17.46.41;	author morrison;	state dead;
branches;
next	11.35;

11.35
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.34;

11.34
date	2004.04.05.07.38.39;	author morrison;	state Exp;
branches;
next	11.33;

11.33
date	2004.02.02.17.39.37;	author morrison;	state Exp;
branches;
next	11.32;

11.32
date	2002.08.20.17.08.32;	author jra;	state Exp;
branches
	11.32.2.1
	11.32.4.1
	11.32.10.1;
next	11.31;

11.31
date	2002.08.15.20.55.45;	author hartley;	state Exp;
branches;
next	11.30;

11.30
date	2002.05.17.12.56.05;	author morrison;	state Exp;
branches;
next	11.29;

11.29
date	2001.08.10.17.51.48;	author jra;	state Exp;
branches;
next	11.28;

11.28
date	2001.05.17.20.05.51;	author morrison;	state Exp;
branches;
next	11.27;

11.27
date	2001.04.05.19.36.01;	author morrison;	state Exp;
branches;
next	11.26;

11.26
date	2001.04.02.21.38.27;	author morrison;	state Exp;
branches;
next	11.25;

11.25
date	2000.08.24.04.22.09;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	2000.07.20.19.15.47;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	2000.03.31.03.13.27;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	2000.01.12.14.16.03;	author jra;	state Exp;
branches;
next	11.21;

11.21
date	99.10.30.03.06.26;	author butler;	state Exp;
branches;
next	11.20;

11.20
date	99.07.16.20.02.45;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	99.05.19.14.18.06;	author jra;	state Exp;
branches;
next	11.18;

11.18
date	99.03.01.20.21.08;	author jra;	state Exp;
branches;
next	11.17;

11.17
date	99.03.01.19.49.46;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	99.02.04.18.23.28;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	97.12.03.06.13.03;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	97.07.28.14.42.31;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	97.05.28.17.46.48;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	97.04.30.20.15.58;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	97.03.06.20.39.43;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	96.12.31.17.54.57;	author jra;	state Exp;
branches;
next	11.9;

11.9
date	96.10.07.18.33.47;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	96.08.20.19.15.53;	author wm;	state Exp;
branches;
next	11.7;

11.7
date	96.08.14.20.07.13;	author wm;	state Exp;
branches;
next	11.6;

11.6
date	96.07.17.13.13.21;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	95.11.07.13.15.52;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	95.10.19.15.03.15;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.10.05.19.31.35;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.10.02.14.34.33;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.18.16;	author mike;	state Rel4_4;
branches;
next	1.15;

1.15
date	94.12.30.03.30.11;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	94.10.20.00.23.22;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	94.09.21.22.05.06;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	94.08.24.13.39.24;	author gdurf;	state Exp;
branches;
next	1.11;

1.11
date	94.08.08.12.28.28;	author gdurf;	state Exp;
branches;
next	1.10;

1.10
date	94.07.13.12.19.45;	author jra;	state Exp;
branches;
next	1.9;

1.9
date	94.06.24.09.56.58;	author jra;	state Exp;
branches;
next	1.8;

1.8
date	94.03.30.09.19.31;	author jra;	state Exp;
branches;
next	1.7;

1.7
date	94.03.29.18.32.52;	author jra;	state Exp;
branches;
next	1.6;

1.6
date	94.02.17.16.05.42;	author jra;	state Exp;
branches;
next	1.5;

1.5
date	94.01.27.13.14.30;	author jra;	state Exp;
branches;
next	1.4;

1.4
date	94.01.26.15.12.31;	author jra;	state Exp;
branches;
next	1.3;

1.3
date	93.10.26.03.05.04;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	93.10.26.03.02.43;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	91.11.07.02.50.15;	author wm;	state Exp;
branches;
next	;

11.32.2.1
date	2002.09.19.18.02.11;	author morrison;	state Exp;
branches;
next	11.32.2.2;

11.32.2.2
date	2004.03.17.21.22.08;	author morrison;	state Exp;
branches;
next	;

11.32.4.1
date	2004.03.11.23.46.54;	author morrison;	state Exp;
branches;
next	;

11.32.10.1
date	2004.02.12.19.51.31;	author erikg;	state Exp;
branches;
next	11.32.10.2;

11.32.10.2
date	2004.03.15.14.07.44;	author erikg;	state Exp;
branches;
next	;


desc
@Initial version of patch-g for Cad 4.0 WM
@


11.36
log
@moved to src/patch/
@
text
@/*
 *			P A T C H - G . C
 *
 *	Converts FASTGEN format target descriptions to MGED format.
 *	  This version assumes the following FASTGEN primitives:
 *		0 - triangle (< 0.99" thick for plate mode)
 *		1 - triangle (< 1.99" thick but > 0.99")
 *		2 - triangle (< 2.99" thick but > 1.99")
 *		3 - triangle (< 3.99" thick but > 2.99")
 *		4 - donut / torus (changed from type 3 by rpatch)
 *		5 - wedge
 *		6 - sphere
 *		7 - box
 *		8 - cylinder (24pt type-4's converted by rpatch)
 *		9 - rod
 *	  The target is also assumed to be pointing forward along the
 *	  positive X-axis and positive Y on the left side of the target.
 *
 *  Author -
 *	Bill Mermagen Jr.
 *      Dan Dender
 *  Revisions -
 *	Robert L. Strausser, The SURVICE Engineering Co.; Jul. '93
 *
 *	John R. Anderson (Jan '94)
 *		Converted proc_tri and proc_plate to produce NMG's
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1989-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/patch/patch-g.c,v 11.35 2004/05/10 15:30:49 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <math.h>

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "bu.h"
#include "bn.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "wdb.h"
#include "./patch-g.h"

#define ABS( _x )	(( _x > 0.0 )? _x : (-_x))

void	proc_plate(int cnt);
void	proc_label(char *labelfile);
void	proc_triangle(int cnt);
void	proc_wedge(int cnt);
void	proc_sphere(int cnt);
void	proc_box(int cnt);
void	proc_cylin(int cnt);
void	proc_rod(int cnt);
void	set_color(int color);
void	mk_cyladdmember(char *name1, struct wmember *head, struct subtract_list *slist, int mirflag);
void	proc_donut(int cnt);

static struct bn_tol	tol;
static int scratch_num;

struct rt_wdb	*outfp;

static char usage[] = "\
Usage: patch-g [options] model.g\n\
	-f fastgen.rp	specify pre-processed fastgen file (default stdin)\n\
	-a		process phantom armor?\n\
	-n		process volume mode as plate mode?\n\
	-u #		number of union operations per region (default 5)\n\
	-c \"x y z\"	center of object in inches (for some surface normal calculations)\n\
	-t title	optional title (default \"Untitled MGED database\")\n\
	-o object_name	optional top-level name (no spaces)(default \"all\")\n\
	-p		write volume and plate mode components as polysolids\n\
	-6		process plate mode triangles as ARB6 solids (overrides '-p' for triangles)\n\
	-i group.file	specify group labels source file\n\
	-m mat.file	specify materials information source file\n\
	-r		reverse normals for plate mode triangles\n\
	-d #		debug level\n\
	-x #		librt debug flag\n\
	-X #		librt NMG debug flags\n\
	-T #		distance tolerance (inches) (two points within this distance are the same point )\n\
	-A #		parallel tolerance (if A dot B (unit vectors) is less than this value, they are perpendicular )\n\
Note: fastgen.rp is the pre-processed (through rpatch) fastgen file\n";

int pt_inside( point_t a, point_t base, point_t top, double rad1, double rad2 );

/*
 *			M A I N
 */
int
main(int argc, char **argv)
{

	int fd,nread;
	FILE	*gfp=NULL;
	FILE    *mfp=NULL;
	char	buf[99],s[132+2];
	int	c;
	int j = 1;
	int i;
	int done;
	int stop,num;
	char	name[17];

	RT_LIST_INIT( &head.l);
	RT_LIST_INIT( &heada.l);
	RT_LIST_INIT( &headb.l);
	RT_LIST_INIT( &headc.l);
	RT_LIST_INIT( &headd.l);
	RT_LIST_INIT( &heade.l);
	RT_LIST_INIT( &headf.l);

	bzero( (char *)list,sizeof(list));

        /* initialize tolerance structure */
        tol.magic = RT_TOL_MAGIC;
        tol.dist = 0.01;
        tol.dist_sq = tol.dist * tol.dist;
        tol.perp = 0.001;
        tol.para = 1 - tol.perp;

	conv_mm2in = 1.0/25.4; /* convert mm to inches */

	scratch_num = 0;

	/*     This section checks usage options given at run command time.   */

	/* Get command line arguments. */
	while ((c = getopt(argc, argv, "6A:T:x:X:pf:i:m:anu:t:o:rc:d:")) != EOF)
	{
		switch (c)
		{
			case '6':  /* use arb6 solids for plate mode */
				arb6 = 1;
				break;
			case 'T':  /* tolerance distance */

				tol.dist = atof( optarg );
				if( tol.dist < 0.0 )
				{
					bu_log( "Illegal tolerance distance (%g inches) (must be non-negative).\n", tol.dist );
					bu_log(usage);
					exit( 1 );
				}
				tol.dist *= mmtin;
				tol.dist_sq = tol.dist * tol.dist;
				break;

			case 'A':  /* angular tolerance */

				tol.perp = atof( optarg );
				if( tol.perp < 0.0 || tol.perp > 1.0 )
				{
					bu_log( "Illegal angular tolerance (%g) (must be non-negative between 0 and 1).\n", tol.perp );
					bu_log(usage);
					exit( 1 );
				}
				tol.para = 1 - tol.perp;
				break;

			case 'x':  /* librt debug flags */

				sscanf( optarg , "%x" , (unsigned int *)&rt_g.debug );
				break;

			case 'X':  /* librt NMG debug flags */

				sscanf( optarg , "%x" , (unsigned int *)&rt_g.NMG_debug );
				break;

			case 'p':  /* polysolid output */

				polysolid = 1;
				break;

			case 'f':  /* fastgen source file data */

				patchfile = optarg;
				break;

			case 'i':  /* group labels source file */

				labelfile = optarg;
				break;

			case 'm':  /* materials information file */

				matfile = optarg;
				break;

			case 'a':  /* process phantom armor ? */

				aflg++;
				break;

			case 'n':  /* process volume mode as plate mode ? */

				nflg = 0;
				break;

			case 'u':  /* specify number of union operations
				    * to put in a region 
							    */

				if( (num_unions = atoi( optarg )) <= 0 ) {
					rt_log( "%d: bad number of unions to put in a region\n", num_unions );
					exit( 1 );
				}
				break;

			case 't':  /* optional title for the database */

				title = optarg;
				break;

			case 'o':  /* optional top-level object name */

				top_level = optarg;
				break;

			case 'r':  /* reverse normals for plate mode triangles */

				rev_norms++;
				break;

			case 'c':  /* center of object (used for some plate mode
				    * triangle surface normal calculations
							    */
				sscanf( optarg,"%lf %lf %lf", 
				    &Centroid[0],&Centroid[1],&Centroid[2]);

				rt_log( "Centroid = ( %f %f %f )\n" , V3ARGS( Centroid ) );
				VSCALE( Centroid, Centroid, mmtin );
				break;

			case 'd':  /* debug flag checking */

				debug = atoi(optarg); /* Debug level */
				break;

			default:
				(void)fputs(usage, stderr);
				exit(1);
			}
	}

	if( optind >= argc )  {
		(void)fputs(usage, stderr);
		exit(1);
	}
	if( (outfp = wdb_fopen(argv[optind])) == RT_WDB_NULL )  {
		perror(argv[optind]);
		exit(3);
	}

	if( debug )
		rt_log( "debug level = %d\n" , debug );

	if( RT_G_DEBUG )
	{
		rt_printb( "librt RT_G_DEBUG", RT_G_DEBUG, DEBUG_FORMAT );
		rt_log( "\n" );
	}

	if( rt_g.NMG_debug )
	{
		rt_log( "librt rt_g.NMG_debug = x%x\n" , rt_g.NMG_debug );
	}

	/*     This section opens input files - the data file defaults to standard
	     input,  both files provide error checking for failure to open.      */

	if( patchfile != (char *)0 )  {
		if((fd = open( patchfile, 0664)) < 0) {
			perror(patchfile);
			exit(1);
		}
	} else {
		fd = 0;		/* stdin */
		patchfile = "stdin";
	}

	if( labelfile != (char *)0 )  {
		if(( gfp = fopen( labelfile, "r" )) == NULL ) {
			perror(labelfile);
			exit(1);
		}
	}

	if( matfile != (char *)0 ) {
		if(( mfp = fopen( matfile, "r" )) == NULL ) {
			perror(matfile);
			exit(1);
		}
	}

	/*     This is the primary processing section to input fastgen data and
	     manufacture related mged elements.  Previous editions of PATCH failed
	     to process the final element after hitting EOF so I moved the read
	     statement into the for loop and made a check flag "done" to verify
	     that all elements are processed prior to falling out of the "for".      */

	MAT_IDN(m);

	/* FASTGEN targets are always in inches */
	mk_id_units(outfp, title, "in");

 /*
  *      This section loads the label file into an array
  *       needed to label processed solids, regions, and groups.
  *       The file should be limited to a 4 digit component number and two
  *       group labels (<15 characters) separated by "white space".
  */
	done = 1;
	if( labelfile != NULL ){

		while (done != 0){

			if( (stop=fscanf( gfp, "%4d", &num )) == 1 ){
				fscanf( gfp, "%s %s", nm[num].ug, nm[num].lg );
				while( (fgetc( gfp )) != '\n' )
					;
			}
			else {
				if( stop == EOF ){
					done = 0;
				}
				else {
					while( (fgetc( gfp )) != '\n' )
						;
				}
			}
		}
		done = 1;
	}

	/* Read the material codes file, which is a component code list
	   with equivalent los % and material code at the end of the line.
	   Non-conforming and blank lines should already have been stripped, 
	   since minimal error checking is done.
	   Line format is "%6d%66c%3d%5d".
	   Example:
		8215  COMPONENT WIDGET                                 95    5
	 */
	if( mfp ) {
		int eqlos, matcode;

		while( fgets(s,132+2,mfp) != NULL ) {

			if( sscanf(s,"%6d%*66c%3d%5d",
			    &i,&eqlos,&matcode) != 3 ) {

				rt_log( "Incomplete line in materials file for component '%.4d'\n",i);
				exit(1);
			}
			nm[i].matcode = matcode;
			nm[i].eqlos = eqlos;
		}
	}

	for( i = done = 0; !done ; i++ )
	{
		nread = read(fd,buf,sizeof(buf));     /* read one line of file into a buffer  */

		if(nread != 0){         /*  For valid reads, assign values to the input array  */

			sscanf(buf,"%lf %lf %lf %c %d %d %d %d %d %d %d %d %d %d %d %d %d %d",
			    &in[i].x,&in[i].y,&in[i].z,&in[i].surf_mode,&in[i].surf_type,
			    &in[i].surf_thick,&in[i].spacecode, &in[i].cc,
			    &in[i].ept[0],&in[i].ept[1],&in[i].ept[2],
			    &in[i].ept[3],&in[i].ept[4],&in[i].ept[5],
			    &in[i].ept[6],&in[i].ept[7],&in[i].mirror,&in[i].vc);

			/*  Perform english to metric conversions.  */
			in[i].x = mmtin*in[i].x;
			in[i].y = mmtin*in[i].y;
			in[i].z = mmtin*in[i].z;
			/* Normal thickness is in hundreths of an inch */
			if( in[i].surf_type <= 3 ){
				in[i].rsurf_thick = (mmtin/100) *
				    (abs(in[i].surf_thick)) +
				    (abs(in[i].surf_type))*mmtin;
			} else {
				in[i].rsurf_thick = (mmtin/100)*
				    (abs(in[i].surf_thick));
			}


			in[i].cc = abs(in[i].cc);
			in[i].surf_type = abs(in[i].surf_type);

			/*  Regurgitate data just loaded for debugging   */
			if (debug > 0){
				rt_log( "%lf %lf %lf %c %lf %d %d %d %d %d %d %d %d %d %d %d %d %d\n",
				    in[i].x,in[i].y,in[i].z,in[i].surf_mode,in[i].surf_type,
				    in[i].surf_thick,in[i].spacecode, in[i].cc,
				    in[i].ept[0],in[i].ept[1],in[i].ept[2],
				    in[i].ept[3],in[i].ept[4],in[i].ept[5],
				    in[i].ept[6],in[i].ept[7],in[i].mirror,in[i].vc);
			}
			if (in[i].cc == 0) {
				done = 1;
				in[i].cc = -1;
			}
		}
		else{     	/*  Read hit EOF, set flag and process one last time.    */
			done = 1;
			in[i].cc = -1;
		}

		/* Process a component code number series when the structure
		 type changes or when a new component code number is found. */

		if( i == 0 )
			continue;
                if ( done || (in[i].cc != in[i-1].cc) ||
                    ((in[i].surf_type > 3 || in[i-1].surf_type > 3) &&
                    (in[i].surf_type != in[i-1].surf_type)) ) {

               		rt_log( "component code #%d\n" , in[i-1].cc );

			if( debug > 2 ) {
				for( j=0; j<i; j++ )
					rt_log("IN: %f %f %f\n",in[j].x,in[j].y,in[j].z);
			}

                    	if( RT_G_DEBUG&DEBUG_MEM_FULL )
                    		rt_prmem( "At start of component" );

			switch(in[i-1].surf_type){    /* Key on surface types. */

			case 0:  	/* triangle approximation */
			case 1:  	/* triangle approximation (thickness + 1") */
			case 2:  	/* triangle approximation (thickness + 2") */
			case 3:  	/* triangle approximation (thickness + 3") */

				if ((nflg > 0)&&(in[i-1].surf_mode== '+'))
				{
					proc_triangle(i);
				}
				else if( (in[i-1].surf_mode == '-') && (in[i-1].rsurf_thick == 0) )
				{
					proc_triangle(i);
				}
				else
				{
					proc_plate(i);
				}
				break;

			case 4: 	/* new "donut/torus" */
				proc_donut(i);
				break;

			case 5:		/* wedge */

				proc_wedge(i);
				break;

			case 6:		/* sphere */

				proc_sphere(i);
				break;

			case 7:		/* box */

				proc_box(i);
				break;

			case 8:		/* cylinder */

				proc_cylin(i);
				break;

			case 9:		/* rod */

				proc_rod(i);
				break;

			default:
				rt_log( "component %.4d: unknown solid type %d\n",
				    in[i-1].cc,in[i-1].surf_type);
				break;

			}       /* end switch */

			/* If the component code number has changed, call
			   the subroutine for making groups from regions.   */

			if( (in[i].cc != in[i-1].cc) && (in[i].cc != 0) ) {
				proc_label( labelfile );
			}

			if( done ) {
				sprintf(name,"%dxxx_series",in[0].cc/1000);
				mk_lcomb(outfp,name,&headd,0,"","",rgb,0);
				(void) mk_addmember(name,&heade.l,NULL, WMOP_UNION);
			}

			/* We have already read the first record of the
			   next element, let's put it in the first position. */

			in[0] = in[i];
			i = 0;

                    	if( RT_G_DEBUG&DEBUG_MEM_FULL )
                    		rt_prmem( "At end of component" );

		}       /* end "processing" if */
	}

	sprintf(name,"%s",top_level);
	mk_lcomb(outfp,name,&heade,0,"","",0,0);

	if( RT_LIST_NON_EMPTY( &headf.l )) {
		sprintf(name,"check.group");
		mk_lcomb(outfp,name,&headf,0,"","",0,0);
	}

	/* check for non-empty lists */
	if( RT_LIST_NON_EMPTY( &head.l ) )
	{
		struct wmember *wp;

		rt_log( "list head not empty: \n" );
		for( RT_LIST_FOR( wp , wmember , &head.l ) )
		{
			rt_log( "\t%c %s\n" , wp->wm_op , wp->wm_name );
		}
	}

	/* check for non-empty lists */
	if( RT_LIST_NON_EMPTY( &heada.l ) )
	{
		struct wmember *wp;

		rt_log( "list heada not empty: \n" );
		for( RT_LIST_FOR( wp , wmember , &heada.l ) )
		{
			rt_log( "\t%c %s\n" , wp->wm_op , wp->wm_name );
		}
	}

	/* check for non-empty lists */
	if( RT_LIST_NON_EMPTY( &headb.l ) )
	{
		struct wmember *wp;

		rt_log( "list headb not empty: \n" );
		for( RT_LIST_FOR( wp , wmember , &headb.l ) )
		{
			rt_log( "\t%c %s\n" , wp->wm_op , wp->wm_name );
		}
	}

	/* check for non-empty lists */
	if( RT_LIST_NON_EMPTY( &headc.l ) )
	{
		struct wmember *wp;

		rt_log( "list headc not empty: \n" );
		for( RT_LIST_FOR( wp , wmember , &headc.l ) )
		{
			rt_log( "\t%c %s\n" , wp->wm_op , wp->wm_name );
		}
	}

	/* check for non-empty lists */
	if( RT_LIST_NON_EMPTY( &headd.l ) )
	{
		struct wmember *wp;

		rt_log( "list headd not empty: \n" );
		for( RT_LIST_FOR( wp , wmember , &headd.l ) )
		{
			rt_log( "\t%c %s\n" , wp->wm_op , wp->wm_name );
		}
	}

	/* check for non-empty lists */
	if( RT_LIST_NON_EMPTY( &heade.l ) )
	{
		struct wmember *wp;

		rt_log( "list heade not empty: \n" );
		for( RT_LIST_FOR( wp , wmember , &heade.l ) )
		{
			rt_log( "\t%c %s\n" , wp->wm_op , wp->wm_name );
		}
	}

	/* check for non-empty lists */
	if( RT_LIST_NON_EMPTY( &headf.l ) )
	{
		struct wmember *wp;

		rt_log( "list headf not empty: \n" );
		for( RT_LIST_FOR( wp , wmember , &headf.l ) )
		{
			rt_log( "\t%c %s\n" , wp->wm_op , wp->wm_name );
		}
	}

	return 0;
}	/* END MAIN PROGRAM  */


/*  Throughout these procedures, the following naming conventions are used.
 *   For unique id# solids:	surface type code . component code number . "s"count
 *   For "neg" mirror solids:	side identifier & surface type code . component code number . "s"count
 *   For internal solids:	external name format, replacing "s" with "c" (for: cut out)
 *   For regions:		solid name with "s cnt" replaced by "r cnt"
 *   For groups:		text nomenclature identification from labelfile
 */

int
make_inside_trc(fastf_t *base, fastf_t *top, fastf_t rbase, fastf_t rtop, fastf_t *new_base, fastf_t *new_top, fastf_t *new_rbase, fastf_t *new_rtop, int do_base, int do_top, int do_sides, fastf_t thick)
{
	fastf_t delta_r;
	fastf_t sin_ang;
	vect_t h;
	fastf_t magh, inv_magh;
	fastf_t l;
	vect_t unit_h;
	vect_t new_h;

	VMOVE( new_base, base )
	VMOVE( new_top, top )
	*new_rtop = rtop;
	*new_rbase = rbase;

	if( (!do_base && !do_top && !do_sides) || thick == 0.0 )
		return( 0 );

	VSUB2( h, new_top, new_base )
	magh = MAGNITUDE( h );
	inv_magh = 1.0/magh;
	VSCALE( unit_h, h, inv_magh )

	VMOVE( new_h, h )
	l = hypot( (double)magh, (rbase - rtop ) );
	sin_ang = fabs( magh / l );
	delta_r = thick / sin_ang;

	if( do_base )
	{
		/* move base up by thickness */
		VJOIN1( new_base, new_base, thick, unit_h )

		/* adjust radius at new base */
		*new_rbase = *new_rbase + (thick/magh) * (*new_rtop - *new_rbase);

		/* recalculate height */
		VSUB2( new_h, new_top, new_base )
		magh = MAGNITUDE( new_h );
	}

	if( do_top )
	{
		/* move top down by thickness */
		VJOIN1( new_top, top, -thick, unit_h )

		/* adjust radius at new top */
		*new_rtop = *new_rtop + (thick/magh) * (*new_rbase - *new_rtop);

		/* recalculate height */
		VSUB2( new_h, new_top, new_base )
		magh = MAGNITUDE( new_h );
	}

	/* if height has reversed direction, we can't make an inside solid */
	if( VDOT( new_h, h ) <= 0.0 )
		return( 1 );

	if(  do_sides )
	{
		*new_rbase = (*new_rbase) - delta_r;
		*new_rtop = (*new_rtop) - delta_r;

		/* if radii are greater than zero, we're fine */
		if( *new_rtop > 0.0 && *new_rbase > 0.0 )
			return( 0 );

		/* if both radii are less then zero, we're toast */
		if( *new_rtop <= 0.0 && *new_rbase <= 0.0 )
			return( 1 );

		if( *new_rtop <= 0.0 )
		{
			/* adjust height (move top towards base) */
			magh = magh * (*new_rbase) / (*new_rbase - *new_rtop);
			VJOIN1( new_top, new_base, magh, unit_h )
			VSUB2( new_h, new_top , new_base )

			/* set new top radius to approximate zero */
			*new_rtop = 0.00001;
		}
		else if( *new_rbase <= 0.0 )
		{
			/* adjust base (move towards top) */
			magh = magh * (*new_rtop) / (*new_rtop - *new_rbase);
			VJOIN1( new_base, new_top, -magh, unit_h )
			VSUB2( new_h, new_top, new_base )

			/* set new bottom radius to approximate zero */
			*new_rbase = 0.00001;
		}
	}
	return( 0 );
}

/*
 *     This subroutine generates solid names with annotations for sidedness as
 *      required.
 */
char *
proc_sname(char shflg, char mrflg, int cnt, char ctflg)
{
	char side;
	static char new_name[17];

	/* shflg == identifies shape process which called this function
	 * mrflg == indicates called by "as-modeled" pass or mirrored pass
	 * cnt   == suffix indentifier for the name
	 * ctflg == isolates internal cutting solids from regular solids
	 * new_name == solid name
	 * side  == left or right sidedness
	 */

	if (((mrflg == 'n') && (in[0].y >= 0)) ||
	    ((mrflg == 'y') && (in[0].y < 0))) {
	  side = 'l';
	}
	else {
	  side = 'r';
	}

	if (in[0].mirror >= 0) {
	  if ((mrflg == 'n') && (ctflg == 'n')) {
	    sprintf(new_name,"%c.%.4d.s%.2d",shflg,in[0].cc,cnt);
	  }
	  else if ((mrflg == 'n') && (ctflg == 'y')) {
	    sprintf(new_name,"%c.%.4d.c%.2d",shflg,in[0].cc,cnt);
	  }
	  else if ((mrflg == 'y') && (ctflg == 'n')) {
	    sprintf(new_name,"%c.%.4d.s%.2d",shflg,(in[0].cc+in[0].mirror),cnt);
	  }
	  else {
	    sprintf(new_name,"%c.%.4d.c%.2d",shflg,(in[0].cc+in[0].mirror),cnt);
	  }
	}
	else if (ctflg == 'n') {
	  sprintf(new_name,"%c%c.%.4d.s%.2d",side,shflg,in[0].cc,cnt);
	}
	else {
	  sprintf(new_name,"%c%c.%.4d.c%.2d",side,shflg,in[0].cc,cnt);
	}

	return( new_name );
}


/*
 *			N M G _ P A T C H _ C O P L A N A R _ F A C E _ M E R G E
 *
 *  A geometric routine to
 *  find all pairs of faces in a shell that have the same plane equation
 *  (to within the given tolerance), and combine them into a single face.
 *
 *  Note that this may result in some of the verticies being very slightly
 *  off the plane equation, but the geometry routines need to be prepared
 *  for this in any case.
 *  If the "simplify" flag is set, pairs of loops in the face that touch
 *  will be combined into a single loop where possible.
 *
 *  XXX Perhaps should be recast as "nmg_shell_shared_face_merge()", leaving
 *  XXX all the geometric calculations to the code in nmg_fuse.c ?
 */

static void
nmg_patch_coplanar_face_merge(struct shell *s, int *face_count, struct patch_faces *p_faces, struct bn_tol *tol, int simplify)
{
	struct model	*m;
	int		len;
	int		*flags1;
	int		*flags2;
	int		face1_no;
	int		face2_no;
	struct faceuse	*fu1;
	struct faceuse	*fu2;
	struct face	*f1;
	struct face	*f2;
	struct face_g_plane	*fg1;
	struct face_g_plane	*fg2;

	NMG_CK_SHELL(s);
	RT_CK_TOL( tol );

	m = nmg_find_model( &s->l.magic );
	len = sizeof(int) * m->maxindex;
	flags1 = (int *)rt_calloc( sizeof(int), m->maxindex,
		"nmg_shell_coplanar_face_merge flags1[]" );
	flags2 = (int *)rt_calloc( sizeof(int), m->maxindex,
		"nmg_shell_coplanar_face_merge flags2[]" );

	/* Visit each face in the shell */
	for( RT_LIST_FOR( fu1, faceuse, &s->fu_hd ) )  {
		plane_t		n1;

		if( RT_LIST_NEXT_IS_HEAD(fu1, &s->fu_hd) )  break;
		f1 = fu1->f_p;
		NMG_CK_FACE(f1);
		if( NMG_INDEX_TEST(flags1, f1) )  continue;
		NMG_INDEX_SET(flags1, f1);

		fg1 = f1->g.plane_p;
		NMG_CK_FACE_G_PLANE(fg1);
		NMG_GET_FU_PLANE( n1, fu1 );

		/* find the entry in p_faces for this faceuse */
		face1_no = (-1);
		while( p_faces[++face1_no].fu != fu1
			&& p_faces[face1_no].fu != fu1->fumate_p
			&& face1_no < *face_count );
		if( p_faces[face1_no].fu != fu1 &&
			p_faces[face1_no].fu != fu1 )
		{
			rt_log( "nmg_patch_coplanar_face_merge: Can't find entry for faceuse x%x in p_faces\n" , fu1 );
			continue;
		}

		/* For this face, visit all remaining faces in the shell. */
		/* Don't revisit any faces already considered. */
		bcopy( flags1, flags2, len );
		for( fu2 = RT_LIST_NEXT(faceuse, &fu1->l);
		     RT_LIST_NOT_HEAD(fu2, &s->fu_hd);
		     fu2 = RT_LIST_NEXT(faceuse,&fu2->l)
		)  {
			register fastf_t	dist;
			plane_t			n2;

			f2 = fu2->f_p;
			NMG_CK_FACE(f2);
			if( NMG_INDEX_TEST(flags2, f2) )  continue;
			NMG_INDEX_SET(flags2, f2);

			fg2 = f2->g.plane_p;
			NMG_CK_FACE_G_PLANE(fg2);

			/* See if face geometry is shared & same direction */
			if( fg1 != fg2 || f1->flip != f2->flip )  {
				/* If plane equations are different, done */
				NMG_GET_FU_PLANE( n2, fu2 );

				/* Compare distances from origin */
				dist = n1[3] - n2[3];
				if( !NEAR_ZERO(dist, tol->dist) )  continue;

				/*
				 *  Compare angle between normals.
				 *  Can't just use RT_VECT_ARE_PARALLEL here,
				 *  because they must point in the same direction.
				 */
				dist = VDOT( n1, n2 );
				if( !(dist >= tol->para) )  continue;
			}

			/* Find the entry for fu2 in p_faces */
			face2_no = (-1);
			while( p_faces[++face2_no].fu != fu2
				&& p_faces[face2_no].fu != fu2->fumate_p
				&& face2_no < *face_count );
			if( p_faces[face2_no].fu != fu2 &&
				p_faces[face2_no].fu != fu2 )
			{
				rt_log( "nmg_patch_coplanar_face_merge: Couldn`t find entry for faceuse x%x in p_faces\n" , fu2 );
				continue;
			}

			/* If the two faces don't get extruded the same distance, can't merge them */
			if( p_faces[face1_no].thick != p_faces[face2_no].thick )
				continue;

			/*
			 * Plane equations are the same, within tolerance,
			 * or by shared fg topology.
			 * Move everything into fu1, and
			 * kill now empty faceuse, fumate, and face
			 */
			{
				struct faceuse	*prev_fu;
				int		face_no;

				prev_fu = RT_LIST_PREV(faceuse, &fu2->l);
				/* The prev_fu can never be the head */
				if( RT_LIST_IS_HEAD(prev_fu, &s->fu_hd) )
					rt_bomb("prev is head?\n");

				nmg_jf( fu1, fu2 );

				fu2 = prev_fu;

				/* fix p_faces array */
				(*face_count)--;
				for( face_no=face2_no ; face_no<(*face_count) ; face_no++ )
				{
					p_faces[face_no].fu = p_faces[face_no+1].fu;
					p_faces[face_no].thick = p_faces[face_no+1].thick;
				}
			}

			/* There is now the option of simplifying the face,
			 * by removing unnecessary edges.
			 */
			if( simplify )  {
				struct loopuse *lu;

				for (RT_LIST_FOR(lu, loopuse, &fu1->lu_hd))
					nmg_simplify_loop(lu);
			}
		}
	}
	rt_free( (char *)flags1, "nmg_shell_coplanar_face_merge flags1[]" );
	rt_free( (char *)flags2, "nmg_shell_coplanar_face_merge flags2[]" );

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		rt_log("nmg_shell_coplanar_face_merge(s=x%x, tol=x%x, simplify=%d)\n",
			s, tol, simplify);
	}
}

int
Build_solid(int l, char *name, char *mirror_name, int plate_mode, fastf_t *centroid, fastf_t thickness, fastf_t *pl1, struct bn_tol *tol)
{
	struct model *m;
	struct nmgregion *r;
	struct shell *s,*is,*os;
	struct faceuse *fu;
	struct loopuse *lu;
	struct edgeuse *eu;
	struct nmg_ptbl faces;
	struct nmg_ptbl verts_to_move;
	struct patch_faces *p_faces;
	struct patch_verts *verts;
	vect_t out;
	int face_count;
	int missed_faces;
	int i,k;
	int vert1,vert2;
	fastf_t outdot;
	fastf_t min_dot=MAX_FASTF;
	vect_t norm;
	int planar=0;
	long *flags;
	long **copy_tbl;

	if( debug )
		rt_log( "%s\n" , name );

	/* Make an array of patch_verts to hold the vertices and coordinates */
	verts = (struct patch_verts *)rt_calloc( l , sizeof( struct patch_verts ) , "patch-g: verts array" );
	for( k=1 ; k<l ; k++ )
	{
		verts[k].vp = (struct vertex *)NULL;
		VSET( verts[k].coord , x[k] , y[k] , z[k] );
	}

	if( arb6 && plate_mode )
	{
		fastf_t pts[24];
		char tmp_name[16];
		struct wmember tmp_head, mir_head;

		RT_LIST_INIT( &tmp_head.l );
		RT_LIST_INIT( &mir_head.l );

		for (k=1 ; k<l-3 ; k++ )
		{
			if( !rt_3pts_distinct ( verts[k].coord , verts[k+1].coord , verts[k+2].coord , tol ) )
			{

				;	/* do nothing */
				/* rt_log( "Repeated Vertice, no face made\n"); */
			}
			else if( rt_3pts_collinear( verts[k].coord , verts[k+1].coord , verts[k+2].coord , tol ) )
			{

				;	/* do nothing */
				/* rt_log( "%s: collinear points, face not made.\n", name); */

			}
			else
			{
				vect_t v1, v2, norm;

				VSUB2( v1, verts[k].coord, verts[k+1].coord );
				VSUB2( v2, verts[k].coord, verts[k+2].coord );
				VCROSS( norm, v1, v2 );
				VUNITIZE( norm );

				/* build an ARB6 */
				VMOVE( &pts[0*3], verts[k].coord );
				VMOVE( &pts[1*3], verts[k+1].coord );
				VMOVE( &pts[4*3], verts[k+2].coord );
				VMOVE( &pts[5*3], &pts[4*3] );
				VJOIN1( &pts[3*3], &pts[0*3], thickness, norm )
				VJOIN1( &pts[2*3], &pts[1*3], thickness, norm )
				VJOIN1( &pts[6*3], &pts[4*3], thickness, norm )
				VMOVE( &pts[7*3], &pts[6*3] );
				sprintf( tmp_name, "%s_%d", name, k );
				mk_arb8( outfp, tmp_name, pts );
				mk_addmember( tmp_name, &tmp_head.l, NULL, WMOP_UNION );
				if( mirror_name[0] )
				{
					for( i=0 ; i<8 ; i++ )
						pts[i*3 + 1] = -pts[i*3 + 1];
					sprintf( tmp_name, "%s_%dm", name, k );
					mk_arb8( outfp, tmp_name, pts );
					mk_addmember( tmp_name, &mir_head.l, NULL, WMOP_UNION );
				}
			}
		}

		mk_lcomb( outfp, name, &tmp_head, 0, (char *)NULL, (char *)NULL, (unsigned char *)NULL, 0 );
		if( mirror_name[0] )
			mk_lcomb( outfp, mirror_name, &mir_head, 0, (char *)NULL, (char *)NULL, (unsigned char *)NULL, 0 );

		return( 0 );

	}

	/* make a model, region and shell to hold the component */
	m = nmg_mm();
	r = nmg_mrsv( m );
	s = RT_LIST_FIRST( shell , &r->s_hd );
	os = s;

	/* initialize the list of faces, for later use by nmg_gluefaces */
	nmg_tbl( &faces , TBL_INIT , NULL );

	/* make an array of patch_faces to hold faceuses and the desired thickness of each face */
	p_faces = (struct patch_faces *)rt_calloc( 2*l , sizeof( struct patch_faces ) , "build_solid: patch_faces" );

	/* loop through all the vertices, making faces as we go */
	face_count = 0;
	vert1 = 1;
	for (k=1 ; k<l-3 ; k++)
	{
		if( plate_mode && thk[k+2] != thickness )
			continue;

		if( !rt_3pts_distinct ( verts[k].coord , verts[k+1].coord , verts[k+2].coord , tol ) )
		{

			;	/* do nothing */
			/* rt_log( "Repeated Vertice, no face made\n"); */
		}
		else if( rt_3pts_collinear( verts[k].coord , verts[k+1].coord , verts[k+2].coord , tol ) )
		{

			;	/* do nothing */
			/* rt_log( "%s: collinear points, face not made.\n", name); */

		}
		else
		{
			struct vertex **vert_p[3];
			int found_verts=0;

			/* Check if this face was already made */
			for( i=0 ; i<NMG_TBL_END( &faces ) ; i++ )
			{
				int j;

				found_verts = 0;
				fu = (struct faceuse *)NMG_TBL_GET( &faces , i );
				NMG_CK_FACEUSE( fu );
				lu = RT_LIST_FIRST( loopuse , &fu->lu_hd );
				NMG_CK_LOOPUSE( lu );
				for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
				{
					NMG_CK_EDGEUSE( eu );
					for( j=0 ; j<3 ; j++ )
						if( rt_pt3_pt3_equal( eu->vu_p->v_p->vg_p->coord,
								      verts[k+j].coord, tol ) )
							found_verts++;
				}
				if( found_verts == 3 ) /* this face already exists */
					break;
			}

			if( found_verts == 3 )
			{
				point_t tmp_pt;

				rt_log( "Component #%d:\n\tduplicate faces:\n" , in[0].cc );
				VSCALE( tmp_pt, verts[k].coord, conv_mm2in );
				rt_log( "\t\t (%g , %g , %g)", V3ARGS( tmp_pt ) );
				VSCALE( tmp_pt, verts[k+1].coord, conv_mm2in );
				rt_log( " (%g , %g , %g)", V3ARGS( tmp_pt ) );
				VSCALE( tmp_pt, verts[k+2].coord, conv_mm2in );
				rt_log( " (%g , %g , %g)\n", V3ARGS( tmp_pt ) );

				continue;
			}

			if( debug > 2 )
			{
				point_t tmp_pt;

				rt_log( "Make face: " );
				VSCALE( tmp_pt, verts[k].coord, conv_mm2in );
				rt_log( "\t\t (%g , %g , %g)", V3ARGS( tmp_pt ) );
				VSCALE( tmp_pt, verts[k+1].coord, conv_mm2in );
				rt_log( " (%g , %g , %g)", V3ARGS( tmp_pt ) );
				VSCALE( tmp_pt, verts[k+2].coord, conv_mm2in );
				rt_log( " (%g , %g , %g)\n", V3ARGS( tmp_pt ) );
			}

			/* Assign the three vertices for this face */
			for( i=0 ; i<3 ; i++ )
				vert_p[i] = &verts[k+i].vp;

			/* Insure that same coordinates correspond to one vertex pointer */
			for( ; vert1 < k+3 ; vert1++ )
			{
				if( verts[vert1].vp )
					continue;
				for( vert2=1 ; vert2 < vert1 ; vert2++ )
				{
					if( !verts[vert2].vp )
						continue;
					if( VEQUAL( verts[vert1].coord , verts[vert2].coord ) )
						verts[vert1].vp = verts[vert2].vp;
				}
			}

			/* make a face */
			fu = nmg_cmface( os , vert_p , 3 );
			NMG_CK_FACEUSE( fu );

			if( debug > 2 )
				rt_log( "\tMade faceuse x%x\n" , fu );

			/* add it to the list */
			nmg_tbl( &faces , TBL_INS , (long *)fu );

			/* remember this face and its thickness */
			p_faces[face_count].fu = fu;
			p_faces[face_count].thick = thk[k+2];

			/* Make sure we don't overrun our p_faces array */
			face_count++;
			if( face_count >= 2*l )
			{
				rt_log( "Face count = %d, only allowed for %d\n" , face_count , 2*l );
				rt_bomb( "Build_solid\n" );
			}

			/* Assign geometry */
			for( i=0 ; i<3 ; i++ )
			{
				if( verts[k+i].vp != NULL && verts[k+i].vp->vg_p == NULL )
					nmg_vertex_gv( verts[k+i].vp , verts[k+i].coord );
			}

			/* phantom armor */
			if (aflg > 0) {
				if (in[0].rsurf_thick == 0) {
					in[0].rsurf_thick = 1;
				}
			}
		}
	}

	/* calculate plane equations for all the faces */
        for (RT_LIST_FOR(s, shell, &r->s_hd))
        {
            NMG_CK_SHELL( s );
            for (RT_LIST_FOR(fu, faceuse, &s->fu_hd))
            {
                NMG_CK_FACEUSE( fu );
                if( fu->orientation == OT_SAME )
                {
                        if( nmg_fu_planeeqn( fu , tol ) )
                	{
                                rt_log( "Build_solid: Failed to calculate plane eqn for outside fu x%x:\n" , fu );
                		nmg_pr_fu_briefly( fu , (char *)NULL );
                	}
                }
            }
        }

	/* don't need the verts array any more */
	rt_free( (char *)verts , "build_solid: verts" );

	/* fuse vertices */
	(void)nmg_model_vertex_fuse( m, tol );

	/* FASTGEN targets may have vertices that should be part of
	 * an adjoining edge. Use nmg_break_long_edges to fix this
	 */
	i = nmg_break_edges( &m->magic , tol );
	if( debug > 2 )
		rt_log( "nmg_break_edges broke %d edges\n" , i );

	/* glue all the faces together */
	nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ), tol );

	for( RT_LIST_FOR( s , shell , &r->s_hd ) )
		nmg_make_faces_within_tol( s, tol );

	if( !plate_mode )
	{
		/* make sure the normals are correct */
		for( RT_LIST_FOR( s , shell , &r->s_hd ) )
			nmg_fix_normals( s , tol );

		/* make sure we are dealing with closed shells */
		for( RT_LIST_FOR( s , shell , &r->s_hd ) )
			nmg_close_shell( s, tol );

		/* free the memory for the face list */
		nmg_tbl( &faces , TBL_FREE , NULL );

		/* don't need the p_faces array any more */
		rt_free( (char *)p_faces , "build_solid: p_faces" );

		/* Calculate bounding boxes */
		nmg_region_a( r , tol );

		/* Write solid to BRLCAD DB */
		s = RT_LIST_FIRST( shell , &r->s_hd );

		if( polysolid )
			write_shell_as_polysolid( outfp , name , s );
		else
		{
			nmg_shell_coplanar_face_merge( s , tol , 0 );
			if( !nmg_simplify_shell( s ) )
				mk_nmg( outfp , name , m );
		}

		/* if this solid is mirrored, don't go through the entire process again */
		if( mirror_name[0] )
		{
			nmg_mirror_model( m );
		
			if( polysolid )
				write_shell_as_polysolid( outfp , mirror_name , s );
			else
				mk_nmg( outfp , mirror_name , m );
		}

		/* Kill the model */
		nmg_km( m );

		return( 0 );
	}

	/* Next section is to fix the normals of the shell
	 * Can't use nmg_fix_normals, because shell may not be closed */

	/* get the shell and the first face from our list */
	s = RT_LIST_FIRST( shell , &r->s_hd );
	for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
	{
		struct faceuse *fu1;

		NMG_CK_FACEUSE( fu );
		if( fu->orientation != OT_SAME )
			continue;

		NMG_GET_FU_NORMAL( norm , fu );
		for( RT_LIST_FOR( fu1 , faceuse , &s->fu_hd ) )
		{
			vect_t norm1;
			fastf_t dot;

			if( fu1->orientation != OT_SAME )
				continue;

			if( fu == fu1 )
				continue;

			NMG_GET_FU_NORMAL( norm1 , fu1 );
			dot = VDOT( norm, norm1 );
			if( dot < 0.0 )
				dot = (-dot );
			if( dot < min_dot )
				min_dot = dot;
		}
	}

	if( min_dot > 0.8 )
		planar = 1;

	fu = (struct faceuse *)NMG_TBL_GET( &faces , 0 );
	NMG_CK_FACEUSE( fu );

	/* free the memory for the face list */
	nmg_tbl( &faces , TBL_RST , NULL );

	/* Create a flags array for the model to make sure each face gets its orientation set */
	flags = (long *)rt_calloc( m->maxindex , sizeof( long ) , "patch-g: flags" );

	/* loop to catch all faces */
	missed_faces = 1;
	while( missed_faces )
	{
		struct faceuse *fu1;
		vect_t normal;

		/* get the normal direction for the first face */
		if( fu->orientation != OT_SAME )
			fu = fu->fumate_p;
		if( fu->orientation != OT_SAME )
			rt_bomb( "Neither faceuse nor mate have an OT_SAME side\n" );
		NMG_GET_FU_NORMAL( normal , fu );

		if( !planar )
		{
			/* calculate "out" direction, from centroid to face */
			lu = RT_LIST_FIRST( loopuse , &fu->lu_hd );
			eu = RT_LIST_FIRST( edgeuse , &lu->down_hd );
			VSUB2( out , eu->vu_p->v_p->vg_p->coord , centroid );
			VUNITIZE( out );

			/* if "normal" and "out" disagree, reverse normal */
			outdot = VDOT( out , normal );
			if( outdot <= 0.001 &&  outdot >= -0.001 )
			{
				/* try model centroid */
				VSUB2( out , eu->vu_p->v_p->vg_p->coord , Centroid );
				VUNITIZE( out );
				outdot = VDOT( out , normal );
			}
		}
		else
		{
			outdot = VDOT( pl1, normal );
		}

		if( outdot < 0.0 )
			nmg_reverse_face_and_radials( fu , tol );

		if( fu->orientation != OT_SAME )
			fu = fu->fumate_p;

		/* propagate this normal direction throughout the shell */
		nmg_propagate_normals( fu , flags , tol );

		/* check if all the faces have been processed */
		missed_faces = 0;
		for( RT_LIST_FOR( fu1 , faceuse , &s->fu_hd ) )
		{
			NMG_CK_FACEUSE( fu1 );
			if( fu1->orientation == OT_SAME )
			{
				if( !NMG_INDEX_TEST( flags , fu1->f_p ) )
				{
					fu = fu1;
					missed_faces++;
					break;
				}
			}
		}
	}

	nmg_patch_coplanar_face_merge( s , &face_count , p_faces , tol , 0 );

	if( nmg_simplify_shell( s ) )
		return( 1 );

	/* Calculate bounding boxes */
	nmg_region_a( r , tol );

	if( debug > 4 )
	{
		char tmp_name[17];

		sprintf( tmp_name , "out.%s" , name );
		mk_nmg( outfp , tmp_name , m );
	}

	/* Duplicate shell */
	is = nmg_dup_shell( s , &copy_tbl, tol );

	/* make a new flags array */
	rt_free( (char *)flags , "build_solid: flags" );
	flags = (long *)rt_calloc( m->maxindex , sizeof( long ) , "patch-g: flags" );

	/* Move faces planes */
	for( i=0 ; i<face_count ; i++ )
	{
		struct face_g_plane *fg_p;

		fu = NMG_INDEX_GETP( faceuse , copy_tbl , p_faces[i].fu );
		if( !fu )
		{
			rt_log( "No fu in duplicate shell corresponding to fu #%d (x%x) in original\n" , i , p_faces[i].fu );
			rt_bomb( "patch-g\n" );
		}

		NMG_CK_FACEUSE( fu );
		if( fu->orientation != OT_SAME )
		{
			fu = fu->fumate_p;
			NMG_CK_FACEUSE( fu );
		}
		if( fu->orientation != OT_SAME )
			rt_bomb( "patch-g: neither faceuse nor mate has orientation of OT_SAME\n" );

		fg_p = fu->f_p->g.plane_p;
		NMG_CK_FACE_G_PLANE( fg_p );

		/* move the faces by the distance "thick" */
		if( NMG_INDEX_TEST_AND_SET( flags , fg_p ) )
		{
			if( fu->f_p->flip )
				fg_p->N[3] += p_faces[i].thick;
			else
				fg_p->N[3] -= p_faces[i].thick;
		}
	}

	/* don't need the p_faces array any more */
	rt_free( (char *)p_faces , "build_solid: p_faces" );

	/* Reverse the normals of all the new faces */
	for( RT_LIST_FOR( fu , faceuse , &is->fu_hd ) )
	{
		if( NMG_INDEX_TEST_AND_SET( flags , fu->f_p ) )
			nmg_reverse_face( fu );
	}

	/* glue all the faces of the new shell together */
	for( RT_LIST_FOR( fu , faceuse , &is->fu_hd ) )
	{
		if( fu->orientation == OT_SAME )
			nmg_tbl( &faces , TBL_INS , (long *)fu );
	}
	nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ), tol );
	nmg_tbl( &faces , TBL_RST , NULL );

	nmg_shell_coplanar_face_merge( is , tol , 0 );
	nmg_shell_a( is , tol );

	/* make yet another version of the flags array */
	rt_free( (char *)flags , "build_solid: flags" );		
	flags = (long *)rt_calloc( m->maxindex , sizeof( long ) , "patch-g: flags" );

	/* make a list of the vertices to be moved */
	nmg_tbl( &verts_to_move , TBL_INIT , (long *)NULL );
	for( RT_LIST_FOR( fu , faceuse , &is->fu_hd ) )
	{
		if( fu->orientation != OT_SAME )
			continue;

		for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
		{
			NMG_CK_LOOPUSE( lu );
			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )
			{
				/* the vertex in a loop of one vertex
				 * must show up in an edgeuse somewhere,
				 * so don't mess with it here */
				continue;
			}

			for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
			{
				struct vertexuse *vu;

				NMG_CK_EDGEUSE( eu );
				vu = eu->vu_p;
				NMG_CK_VERTEXUSE( vu );
				NMG_CK_VERTEX( vu->v_p )
				if( NMG_INDEX_TEST_AND_SET( flags , vu->v_p ) )
				{
					/* move this vertex */
					nmg_tbl( &verts_to_move , TBL_INS , (long *)vu->v_p );
				}
			}
		}
	}

	/* now start the actual moving of the vertex coordinates */
	for( i=0 ; i<NMG_TBL_END( &verts_to_move ) ; i++ )
	{
		struct vertex *new_v;

		/* get the vertexuse from the table */
		new_v = (struct vertex *)NMG_TBL_GET( &verts_to_move , i );
		NMG_CK_VERTEX( new_v );

		/* Adjust the vertices of new_v */
		if( debug > 2 )
			rt_log( "Moving ( %f %f %f )" , V3ARGS( new_v->vg_p->coord ) );
		if( nmg_in_vert( new_v , 1 , tol ) )
		{
			/* FAILURE, kill the model and shell and return a failure notification */
			rt_log( "nmg_in_vert failed on %s!\n" , name );
			if( !nmg_ks( is ) )
			{
				/* debugging: write an NMG of the outer shell named "name.BAD" */
				char *bad;

				bad = (char *)rt_malloc( strlen( name ) + 5 , "build_solid: Name for Bad solid" );
				strcpy( bad , name );
				strcat( bad , ".BAD" );
				mk_nmg( outfp , bad , m );
				rt_log( "BAD shell written as %s\n" , bad );
				rt_free( (char *)bad , "build_solid: Name for Bad solid" );
			}
			nmg_km( m );
			rt_free( (char *)flags , "build_solid: flags" );
			rt_free( (char *)copy_tbl , "build_solid: copy_tbl" );
			nmg_tbl( &verts_to_move , TBL_FREE , (long *)NULL );
			return( 1 );
		}
		if( debug > 2 )
			rt_log( " to ( %f %f %f )\n" , V3ARGS( new_v->vg_p->coord ) );
	}

	/* done moving, get rid of table */
	nmg_tbl( &verts_to_move , TBL_FREE , (long *)NULL );

	if( debug > 4 )
	{
		char tmp_name[32];

		sprintf( tmp_name , "open.%s" , name );
		mk_nmg( outfp , tmp_name , m );
	}

	nmg_make_faces_within_tol( is, tol );

	/* Close shell */
	if( debug )
		rt_log( "Close shell\n" );
	if( nmg_open_shells_connect( s , is , (const long **)copy_tbl , tol ) )
	{
		/* debugging: write an NMG of the outer shell named "name.BAD" */
		char *bad;

		bad = (char *)rt_malloc( strlen( name ) + 5 , "build_solid: Name for Bad solid" );
		strcpy( bad , name );
		strcat( bad , ".BAD" );
		mk_nmg( outfp , bad , m );
		rt_log( "BAD shell written as %s\n" , bad );
		rt_free( (char *)bad , "build_solid: Name for Bad solid" );
		nmg_km( m );
		rt_free( (char *)flags , "Build_solid: flags" );
		rt_free( (char *)copy_tbl , "Build_solid: copy_tbl" );
		return( 1 );
	}

	rt_free( (char *)flags , "Build_solid: flags" );
	rt_free( (char *)copy_tbl , "Build_solid: copy_tbl" );

#if 0
	if( debug )
		rt_log( "Recalculate plane equations\n" );
	/* recalculate plane equations, since some of the vertices we calculated
	 * may not be exactly on the plane */
	for( RT_LIST_FOR( s , shell , &r->s_hd ) )
	{
		for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
		{
			if( fu->orientation == OT_SAME )
			{
plane_t pl1,pl2;

NMG_GET_FU_PLANE( pl1 , fu );
	                        if( nmg_fu_planeeqn( fu , tol ) )
	                	{
NMG_GET_FU_PLANE( pl2 , fu );
	                                rt_log( "Build_solid: Failed to re-calculate plane eqn for fu x%x:\n" , fu );
	                		nmg_pr_fu_briefly( fu , (char *)NULL );
	                		rt_g.NMG_debug |= DEBUG_MESH;
	                		nmg_ck_fu_verts( fu , fu->f_p , tol );
rt_log( "Old plane was ( %f %f %f %f )\n" , V4ARGS( pl1 ) );
rt_log( "New plane is ( %f %f %f %f )\n" , V4ARGS( pl2 ) );
nmg_face_g( fu , pl1 );
	                		nmg_ck_fu_verts( fu , fu->f_p , tol );
	                		rt_g.NMG_debug &= ~DEBUG_MESH;
	                	}
			}
		}
	}
#endif

	nmg_tbl( &faces , TBL_RST , NULL );

	/* glue all the faces of the new shell together */
	s = RT_LIST_FIRST( shell , &r->s_hd );
	for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
	{
		if( !fu )
			continue;
		NMG_CK_FACEUSE( fu );
		if( fu->orientation == OT_SAME )
			nmg_tbl( &faces , TBL_INS , (long *)fu );
	}
	if( debug )
		rt_log( "Re-glue faces\n" );
	nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ), tol );
	nmg_tbl( &faces , TBL_FREE , NULL );

	/* Calculate bounding boxes */
	if( debug )
		rt_log( "nmg_region_a( r = x%x )\n" , r );
	nmg_region_a( r , tol );

	if( debug )
		rt_log( "writing %s to BRLCAD DB\n" , name );

	/* Write solid to BRLCAD DB */
	s = RT_LIST_FIRST( shell , &r->s_hd );

	if( polysolid )
		write_shell_as_polysolid( outfp , name , s );
	else
	{
		nmg_shell_coplanar_face_merge( s , tol , 0 );
		if( !nmg_simplify_shell( s ) )
			mk_nmg( outfp , name , m );
	}

	/* if this solid is mirrored, don't go through the entire process again */
	if( mirror_name[0] )
	{
		if( debug )
			rt_log( "Mirror model\n" );
		nmg_mirror_model( m );

		if( debug )
			rt_log( "writing  %s (mirrored) to BRLCAD DB\n" , mirror_name );
		
		if( polysolid )
			write_shell_as_polysolid( outfp , mirror_name , s );
		else
			mk_nmg( outfp , mirror_name , m );
	}

	/* Kill the model */
	nmg_km( m );

	return( 0 );
}

/*
 *     This subroutine takes previously generated solid names and combines them
 *	into a common region identity.  Format of the make_region command call
 *	requires in order: output file name, input region name, link file of solids,
 *	region/group flag, material name, material parameters, RGB color assignment, region id #,
 *	aircode, material code, LOS, and inheritance flag.  The region is then 
 *	added to a hold file for combination into groups in another process.        
 */
void
proc_region(char *name1)
{
	char tmpname[24];
	int chkroot;
	int i;
	int cc;
	static int reg_count=0;
	static int mir_count=0;
	static int last_cc=0;


	if( RT_LIST_IS_EMPTY( &head.l ) )
		return;

	strcpy( tmpname , name1 );

	chkroot = 0;
	while( tmpname[chkroot++] != '.' );

	cc = atoi( &tmpname[chkroot] );

	i = strlen( tmpname );
	while( tmpname[--i] != '.' );
	tmpname[i] = '\0';

	if( in[0].cc != last_cc )
	{
		reg_count = 0;
		mir_count = 0;
	}

	if( cc != in[0].cc )
	{
		mir_count++;
		sprintf(cname,"%s.r%.2d",tmpname,mir_count);
	}
	else
	{
		reg_count++;
		sprintf(cname,"%s.r%.2d",tmpname,reg_count);
	}


	if( nm[cc].matcode != 0 ) {
		mk_lrcomb(outfp, cname, &head, 1, 0, 0, 0, cc, 0, nm[cc].matcode, nm[cc].eqlos, 0);
	}
	else {
		mk_lrcomb(outfp, cname, &head, 1, 0, 0, 0, cc, 0, 2, 100, 0);
	}

	if ( cc == in[0].cc){
		(void) mk_addmember(cname,&heada.l,NULL, WMOP_UNION);
	}
	else{
		(void) mk_addmember(cname,&headb.l,NULL, WMOP_UNION);
	}

	last_cc = in[0].cc;
}

/*
 *	 Process Volume Mode triangular facetted solids  
 */
void
proc_triangle(int cnt)
{
	int	k,l;
	int	index;
	int	cpts;
	char	shflg,mrflg,ctflg;
	static int count=0;
	static int mir_count=0;
	static int last_cc=0;
	char 	name[17],mirror_name[17];
	plane_t pl;
	point_t last;

	if( in[cnt-1].cc != last_cc )
	{
		count = 0;
		mir_count=0;
	}

	for(k=0 ; k < (cnt) ; k++){
		for(l=0; l<= 7; l++){

			if(in[k].ept[l] > 0){

				index = in[k].ept[l];
				list[index].x = in[k].x;
				list[index].y = in[k].y;
				list[index].z = in[k].z;
				list[index].flag = 1;

				if (debug > 3)
					rt_log( "%d %f %f %f\n",list[index].flag,in[k].x,in[k].y,in[k].z);
			}

		}
	}

	/* Everything is sequenced, but separated, compress into single array here */
	l = 1;

	for (k=1; k<10000; k++){
		if(list[k].flag == 1){
			list[k].flag = 0;
			x[l] = list[k].x;
			y[l] = list[k].y;
			z[l] = list[k].z;

			l= l+1;
		}

		if (debug > 3)
			rt_log( "k=%d l=%d %f %f %f flag=%d\n",k,l,list[k].x,list[k].y,list[k].z,list[k].flag);
	}

	if (debug > 2){
		for (k=1;(k<=l);k++)
			rt_log( "%d %f %f %f\n",k,x[k],y[k],z[k]);
	}

	VSET( last, MAX_FASTF, MAX_FASTF, MAX_FASTF );
	VSET( centroid , 0.0 , 0.0 , 0.0 );
	for ( cpts=0, k=1; k<l; k++ ) {
		point_t tmp;

		VSET( tmp, x[k], y[k], z[k] );
		if( VEQUAL( tmp, last ) )
			continue;
		VADD2( centroid, centroid, tmp );
		VMOVE( last, tmp );
		cpts++;
	}
	VSCALE( centroid, centroid, 1.0/cpts );
	if( debug > 2 ) {
		rt_log( "%d: cpts=%d centroid %f %f %f\n",
		    in[0].cc, cpts, 
		    centroid[0], centroid[1], centroid[2] );
	}

	/* assign solid's name */

	shflg = 'f';
	mrflg = 'n';
	ctflg = 'n';
	strcpy( name , proc_sname (shflg,mrflg,count+1,ctflg) );
	count++;

	if(in[0].mirror != 0)
	{

		mrflg = 'y';
		strcpy( mirror_name , proc_sname (shflg,mrflg,mir_count+1,ctflg) );
		mir_count++;
	}
	else
		mirror_name[0] = '\0';

	if( (RT_SETJUMP) || Build_solid( l, name, mirror_name, 0, centroid, 0.0, pl, &tol ) )
	{
		if( mirror_name[0] )
			rt_log( "Failed to build solids %s and %s\n", name, mirror_name );
		else
			rt_log( "Failed to build solid %s\n", name );
	}
	else
	{
		count++;
		(void) mk_addmember(name,&head.l,NULL, WMOP_UNION);
		proc_region( name );
		if( mirror_name[0] )
		{
			(void) mk_addmember(mirror_name,&head.l,NULL, WMOP_UNION);
			mir_count++;
			proc_region( mirror_name );
		}
	}
	RT_UNSETJUMP;

	if( debug )
	{
		rt_log( "\tFinished %s\n" , name );
		if( mirror_name[0] )
			rt_log( "\tand %s\n" , mirror_name );
	}

	last_cc = in[cnt-1].cc;
}

void
Get_ave_plane(fastf_t *pl, int num_pts, fastf_t *x, fastf_t *y, fastf_t *z)
{
	mat_t matrix;
	mat_t inverse;
	double one_over_vertex_count;
	vect_t vsum;
	int i;
	fastf_t det;

	/* build matrix */
	MAT_ZERO( matrix );
	VSET( vsum , 0.0 , 0.0 , 0.0 );

	one_over_vertex_count = 1.0/(double)(num_pts);

	for( i=0 ; i<num_pts ; i++ )
	{

		matrix[0] += x[i] * x[i];
		matrix[1] += x[i] * y[i];
		matrix[2] += x[i] * z[i];
		matrix[5] += y[i] * y[i];
		matrix[6] += y[i] * z[i];
		matrix[10] += z[i] * z[i];

		vsum[X] += x[i];
		vsum[Y] += y[i];
		vsum[Z] += z[i];
	}
	matrix[4] = matrix[1];
	matrix[8] = matrix[2];
	matrix[9] = matrix[6];
	matrix[15] = 1.0;


	/* Check that we don't have a singular matrix */
	det = bn_mat_determinant( matrix );

	if( !NEAR_ZERO( det , SMALL_FASTF ) )
	{
		fastf_t inv_len_pl;

		/* invert matrix */
		mat_inv( inverse , matrix );

		/* get normal vector */
		MAT4X3PNT( pl , inverse , vsum );

		/* unitize direction vector */
		inv_len_pl = 1.0/(MAGNITUDE( pl ));
		HSCALE( pl , pl , inv_len_pl );

		/* get average vertex coordinates */
		VSCALE( vsum, vsum, one_over_vertex_count );

		/* get distance from plane to orgin */
		pl[H] = VDOT( pl , vsum );

		if( ABS( pl[0] ) > ABS( pl[1] ) )
		{
			if( ABS( pl[0] ) > ABS( pl[2] ) )
			{
				if( pl[0] < 0.0 )
					HREVERSE( pl, pl )
			}
			else
			{
				if( pl[2] < 0.0 )
					HREVERSE( pl, pl )
			}
		}
		else
		{
			if( ABS( pl[1] ) > ABS( pl[2] ) )
			{
				if( pl[1] < 0.0 )
					HREVERSE( pl, pl )
			}
			else
			{
				if( pl[2] < 0.0 )
					HREVERSE( pl, pl )
			}
		}
	}
	else
	{
		fastf_t x0,y0,z0;
		int x_same=1;
		int y_same=1;
		int z_same=1;

		/* singular matrix, may occur if all vertices have the same zero
		 * component.
		 */
		x0 = x[0];
		y0 = y[0];
		z0 = z[0];
		for( i=1 ; i<num_pts ; i++ )
		{
			if( x[i] != x0 )
				x_same = 0;
			if( y[i] != y0 )
				y_same = 0;
			if( z[i] != z0 )
				z_same = 0;

			if( !x_same && !y_same && !z_same )
				break;
		}

		if( x_same )
		{
			VSET( pl , 1.0 , 0.0 , 0.0 );
		}
		else if( y_same )
		{
			VSET( pl , 0.0 , 1.0 , 0.0 );
		}
		else if( z_same )
		{
			VSET( pl , 0.0 , 0.0 , 1.0 );
		}

		if( x_same || y_same || z_same )
		{
			/* get average vertex coordinates */
			VSCALE( vsum, vsum, one_over_vertex_count );

			/* get distance from plane to orgin */
			pl[H] = VDOT( pl , vsum );

		}
		else
		{
			rt_log( "Get_plane: Cannot calculate plane\n" );
		}
	}
}

/*
 *	 Process Plate Mode triangular surfaces 
 */
void
proc_plate(int cnt)
{
	int	thick_no;
	int k,l;
	int index;
	static int count=0;
	static int mir_count=0;
	static int last_cc=0;
	int cpts;
	char	shflg,mrflg,ctflg;
	char	name[17],mirror_name[17];
	plane_t pl;
	point_t last;

	if( in[cnt-1].cc != last_cc )
	{
		count = 0;
		mir_count = 0;
	}

	/* include the check for phantom armor */
	if ((in[0].rsurf_thick > 0)||(aflg > 0))
	{

		for(k=0 ; k < (cnt) ; k++){
			for(l=0; l<= 7; l++){
				if(in[k].ept[l] > 0){
					index = in[k].ept[l];

					list[index].x = in[k].x;
					list[index].y = in[k].y;
					list[index].z = in[k].z;
					if( in[k].rsurf_thick < tol.dist )
					{
						rt_log( "Warning: thickness of component #%d at sequence #%d is %g inches\n" , in[0].cc , index , in[k].rsurf_thick*conv_mm2in );
						rt_log( "\tsetting thickness to %g inches\n", 3.0*tol.dist*conv_mm2in );
						list[index].thick = 3.0*tol.dist;
					}
					else
						list[index].thick = in[k].rsurf_thick;
					list[index].flag = 1;
				}
			}
		}

		/* make list of thicknesses */
		nthicks = 0;
		for (k=1; k<10000; k++)
		{
			int found_thick;

			if(list[k].flag == 1)
			{
				if( !nthicks )
				{
					thicks[0] = list[k].thick;
					nthicks = 1;
					continue;
				}

				found_thick = 0;
				for( thick_no=0 ; thick_no < nthicks ; thick_no++ )
				{
					if( NEAR_ZERO( list[k].thick - thicks[thick_no], tol.dist ) )
					{
						list[k].thick = thicks[thick_no];
						found_thick = 1;
						break;
					}
				}
				if( !found_thick )
				{
					if( nthicks >= MAX_THICKNESSES )
					{
						rt_log( "Component # has too many different thicknesses\n",
							in[0].cc );
						rt_log( "\t skipping component\n" );
						return;
					}
					else
					{
						thicks[nthicks] = list[k].thick;
						nthicks++;
					}
				}
			}
		}

		/* Everything is sequenced, but separated, compress into single array here */
		l = 1;

		for (k=1; k<10000; k++){
			if(list[k].flag == 1){
				list[k].flag = 0;
				x[l] = list[k].x;
				y[l] = list[k].y;
				z[l] = list[k].z;
				thk[l] = list[k].thick;
				if( thk[l] < tol.dist )
				{
					rt_log( "Proc_plate: Found a bad thickness, should have been fixed by now!!!\n" );
					rt_bomb( "Proc_plate: thickness less tahn tolerance.\n" );
				}
				l= l+1;
			}
		}


		if( debug > 2 ) {
			for ( k=1;k<l; k++ )
				rt_log( "Compressed: %f %f %f\n",x[k],y[k],z[k]);
			rt_log( "%d unique plate thicknesses:\n", nthicks );
			for( thick_no=0 ; thick_no < nthicks ; thick_no++ )
				rt_log( "\t%g inches\n" , thicks[thick_no]*conv_mm2in );
		}

		Get_ave_plane( pl, l, x,y,z );

		VSET( last, MAX_FASTF, MAX_FASTF, MAX_FASTF );
		VSET( centroid , 0.0 , 0.0 , 0.0 );
		for ( cpts=0, k=1; k<l; k++ ) {
			point_t tmp;

			VSET( tmp, x[k], y[k], z[k] );
			if( VEQUAL( tmp, last ) )
				continue;
			VADD2( centroid, centroid, tmp );
			VMOVE( last, tmp );
			cpts++;
		}
		VSCALE( centroid, centroid, 1.0/cpts );
		if( debug > 2 ) {
			rt_log( "%d: cpts=%d centroid %f %f %f\n",
			    in[0].cc, cpts, 
			    centroid[0], centroid[1], centroid[2] );
		}

		for( thick_no=0 ; thick_no < nthicks ; thick_no++ )
		{

			/* name solids */

			shflg = 't';
			mrflg = 'n';
			ctflg = 'n';
			strcpy( name , proc_sname (shflg,mrflg,count+1,ctflg) );

			if( in[0].mirror != 0 )
			{
				mrflg = 'y';
				strcpy( mirror_name , proc_sname (shflg,mrflg,mir_count+1,ctflg) );
			}
			else
				mirror_name[0] = '\0';

			if( (RT_SETJUMP) || Build_solid( l, name, mirror_name, 1, centroid, thicks[thick_no], pl, &tol ) )
			{
				if( mirror_name[0] )
					rt_log( "Failed to build solids %s and %s\n", name, mirror_name );
				else
					rt_log( "Failed to build solid %s\n", name );
			}
			else
			{
				count++;
				(void) mk_addmember(name,&head.l,NULL, WMOP_UNION);
				proc_region( name );
				if( mirror_name[0] )
				{
					(void) mk_addmember(mirror_name,&head.l,NULL, WMOP_UNION);
					mir_count++;
					proc_region( mirror_name );
				}
			}
			RT_UNSETJUMP;

			if( debug )
			{
				rt_log( "\tFinished %s\n" , name );
					if( mirror_name[0] )
					rt_log( "\tand %s\n" , mirror_name );
			}
		}
		proc_region( name );
		if( mirror_name[0] )
			proc_region( mirror_name );
	} /* phantom armor check */

	last_cc = in[cnt-1].cc;
}

/* 
 *	Process fastgen wedge shape - also process hollow wedges.
 */
void
proc_wedge(int cnt)
{
	point_t	pt8[8];
	point_t inpt8[8];
	int i,k;
	vect_t	ab, ac , ad;
	plane_t planes[5];
	static int count=0;
	static int mir_count=0;
	static int last_cc=0;
	char	shflg='\0',mrflg,ctflg;
	char	name[17];
	int ret = 0;
	static struct rt_tol *tols = &tol;


	if( in[cnt-1].cc != last_cc )
	{
		count = 0;
		mir_count=0;
	}

	for(k=0 ; k <= (cnt-1) ; k+=4){
		VSET( pt8[0], in[k].x,in[k].y,in[k].z );
		VSET( pt8[3], in[k+1].x,in[k+1].y,in[k+1].z );
		VSET( pt8[1], in[k+2].x,in[k+2].y,in[k+2].z );
		VSET( pt8[4], in[k+3].x,in[k+3].y,in[k+3].z );

		VSUB2(ab,pt8[4],pt8[0]);
		VSUB2(ac,pt8[3],pt8[0]);
		VSUB2(ad,pt8[1],pt8[0]);

		VADD3(pt8[7],ab,ac,pt8[0]);

		VADD3(pt8[2],ac,ad,pt8[0]);

		VMOVE(pt8[6],pt8[7]);
		VMOVE(pt8[5],pt8[4]);

		/* name solids */

		shflg = 'w';
		mrflg = 'n';
		ctflg = 'n';
		strcpy( name , proc_sname (shflg,mrflg,count+1,ctflg) );

		/* make solids */

		mk_arb8( outfp, name, &pt8[0][X] );
		count++;

		(void) mk_addmember(name,&head.l,NULL, WMOP_UNION);

		if( in[k].surf_mode == '-' ){
			point_t interior;
			vect_t diff;

			fastf_t join_scale = 1.0/8.0;

			ctflg = 'y';
			strcpy( name , proc_sname (shflg,mrflg,count,ctflg) );
			
		/* Create planes for arb6. Planes will be formed with
		   normal pointing inward for creation of inner arb6 */

			VSETALL( interior, 0.0 )
			for( i=0 ; i<8 ; i++ )
				VJOIN1( interior, interior, join_scale,  pt8[i] )
			ret = rt_mk_plane_3pts(planes[0],pt8[0],pt8[3],pt8[2],tols);
			VSUB2( diff, interior, pt8[0] )
			if( VDOT( diff, planes[0] ) < 0.0 )
				HREVERSE( planes[0], planes[0] )
			ret = ret | rt_mk_plane_3pts(planes[1],pt8[2],pt8[3],pt8[6],tols);
			VSUB2( diff, interior, pt8[2] )
			if( VDOT( diff, planes[1] ) < 0.0 )
				HREVERSE( planes[1], planes[1] )
			ret = ret | rt_mk_plane_3pts(planes[2],pt8[6],pt8[3],pt8[0],tols);
			VSUB2( diff, interior, pt8[6] )
			if( VDOT( diff, planes[2] ) < 0.0 )
				HREVERSE( planes[2], planes[2] )
			ret = ret | rt_mk_plane_3pts(planes[3],pt8[4],pt8[0],pt8[1],tols);
			VSUB2( diff, interior, pt8[4] )
			if( VDOT( diff, planes[3] ) < 0.0 )
				HREVERSE( planes[3], planes[3] )
			ret = ret | rt_mk_plane_3pts(planes[4],pt8[1],pt8[2],pt8[6],tols);
			VSUB2( diff, interior, pt8[1] )
			if( VDOT( diff, planes[4] ) < 0.0 )
				HREVERSE( planes[4], planes[4] )


		/* Moves planes inward by normal thickness */

			for (i=0; i < 5; i++) {
				point_t tmp_pt, new_pt;

				VSCALE( tmp_pt, planes[i], planes[i][3] )
				VJOIN1( new_pt, tmp_pt, in[k].rsurf_thick, planes[i] )
				
				planes[i][3] = VDOT( planes[i], new_pt );
			}

		/* Find new vertices of interior arb6 using
		   intersection of 3 planes subroutine */

			ret = ret | rt_mkpoint_3planes(inpt8[0],planes[0],planes[3],planes[2]);
			ret = ret | rt_mkpoint_3planes(inpt8[1],planes[0],planes[3],planes[4]);
			ret = ret | rt_mkpoint_3planes(inpt8[2],planes[0],planes[1],planes[4]);
			ret = ret | rt_mkpoint_3planes(inpt8[3],planes[0],planes[1],planes[2]);
			ret = ret | rt_mkpoint_3planes(inpt8[4],planes[2],planes[3],planes[4]);
			ret = ret | rt_mkpoint_3planes(inpt8[6],planes[1],planes[2],planes[4]);

			VMOVE(inpt8[7],inpt8[6]);
			VMOVE(inpt8[5],inpt8[4]);

			if( ret == 0 ) { /* valid record */
				
				mk_arb8( outfp, name, &inpt8[0][X] );
				(void)mk_addmember(name,&head.l,NULL, WMOP_SUBTRACT);
			}
			else {
				/* add to check group */
				(void)mk_addmember(name,&headf.l,NULL, WMOP_UNION);
			}
		}

		/* make regions for every num_unions solids */

		if ((count % num_unions) == 0)
			proc_region(name);

	}
	/* catch leftover solids */

	if ((count % num_unions) != 0)
		proc_region(name);

	/*   Mirror Processing - duplicates above code!   */
	ret = 0;
	for(k=0 ; k <= (cnt-1) && in[k].mirror != 0 ; k+=4){

		VSET( pt8[0], in[k].x,-in[k].y,in[k].z );
		VSET( pt8[3], in[k+1].x,-in[k+1].y,in[k+1].z );
		VSET( pt8[1], in[k+2].x,-in[k+2].y,in[k+2].z );
		VSET( pt8[4], in[k+3].x,-in[k+3].y,in[k+3].z );

		VSUB2(ab,pt8[4],pt8[0]);
		VSUB2(ac,pt8[3],pt8[0]);
		VSUB2(ad,pt8[1],pt8[0]);

		VADD3(pt8[7],ab,ac,pt8[0]);

		VADD3(pt8[2],ac,ad,pt8[0]);

		VMOVE(pt8[6],pt8[7]);
		VMOVE(pt8[5],pt8[4]);

		mrflg = 'y';
		ctflg = 'n';
		strcpy( name , proc_sname (shflg,mrflg,mir_count+1,ctflg) );

		mk_arb8( outfp, name, &pt8[0][X] );
		mir_count++;

		(void) mk_addmember(name,&head.l,NULL, WMOP_UNION);
		if( in[k].surf_mode == '-' ){
			point_t interior;
			vect_t diff;

			fastf_t join_scale = 1.0/8.0;

			ctflg = 'y';
			strcpy( name , proc_sname (shflg,mrflg,count,ctflg) );

		/* Create planes for arb6. Planes will be formed with
		   normal pointing inward for creation of inner arb6 */

			VSETALL( interior, 0.0 )
			for( i=0 ; i<8 ; i++ )
				VJOIN1( interior, interior, join_scale,  pt8[i] )
			ret = rt_mk_plane_3pts(planes[0],pt8[0],pt8[3],pt8[2],tols);
			VSUB2( diff, interior, pt8[0] )
			if( VDOT( diff, planes[0] ) < 0.0 )
				HREVERSE( planes[0], planes[0] )
			ret = ret | rt_mk_plane_3pts(planes[1],pt8[2],pt8[3],pt8[6],tols);
			VSUB2( diff, interior, pt8[2] )
			if( VDOT( diff, planes[1] ) < 0.0 )
				HREVERSE( planes[1], planes[1] )
			ret = ret | rt_mk_plane_3pts(planes[2],pt8[6],pt8[3],pt8[0],tols);
			VSUB2( diff, interior, pt8[6] )
			if( VDOT( diff, planes[2] ) < 0.0 )
				HREVERSE( planes[2], planes[2] )
			ret = ret | rt_mk_plane_3pts(planes[3],pt8[4],pt8[0],pt8[1],tols);
			VSUB2( diff, interior, pt8[4] )
			if( VDOT( diff, planes[3] ) < 0.0 )
				HREVERSE( planes[3], planes[3] )
			ret = ret | rt_mk_plane_3pts(planes[4],pt8[1],pt8[2],pt8[6],tols);
			VSUB2( diff, interior, pt8[1] )
			if( VDOT( diff, planes[4] ) < 0.0 )
				HREVERSE( planes[4], planes[4] )


		/* Moves planes inward by normal thickness */

			for (i=0; i < 5; i++) {
				point_t tmp_pt, new_pt;

				VSCALE( tmp_pt, planes[i], planes[i][3] )
				VJOIN1( new_pt, tmp_pt, in[k].rsurf_thick, planes[i] )
				
				planes[i][3] = VDOT( planes[i], new_pt );
			}

		/* Find new vertices of interior arb6 using
		   intersection of 3 planes subroutine */

			ret = ret | rt_mkpoint_3planes(inpt8[0],planes[0],planes[3],planes[2]);
			ret = ret | rt_mkpoint_3planes(inpt8[1],planes[0],planes[3],planes[4]);
			ret = ret | rt_mkpoint_3planes(inpt8[2],planes[0],planes[1],planes[4]);
			ret = ret | rt_mkpoint_3planes(inpt8[3],planes[0],planes[1],planes[2]);
			ret = ret | rt_mkpoint_3planes(inpt8[4],planes[2],planes[3],planes[4]);
			ret = ret | rt_mkpoint_3planes(inpt8[6],planes[1],planes[2],planes[4]);

			VMOVE(inpt8[7],inpt8[6]);
			VMOVE(inpt8[5],inpt8[4]);

			if( ret == 0 ) { /* valid record */

				mk_arb8( outfp, name, &inpt8[0][X] );
				(void)mk_addmember(name,&head.l,NULL, WMOP_SUBTRACT);
			}
			else {
				/* add to check group */
				(void)mk_addmember(name,&headf.l,NULL, WMOP_UNION);
			}
		}

		if ((mir_count % num_unions) == 0)
			proc_region(name);
	}
	if ((count % num_unions) != 0)
		proc_region(name);

	last_cc = in[cnt-1].cc;
}

/*
 *
 *	 Process fastgen spheres - can handle hollowness 
 */
void
proc_sphere(int cnt)
{
	fastf_t rad;
	point_t center;
	int i;
	char    shflg='\0',mrflg,ctflg;
	static int count=0;
	static int mir_count=0;
	static int last_cc=0;
	char 	name[17];

	if( in[cnt-1].cc != last_cc )
	{
		count = 0;
		mir_count=0;
	}


	for( i=0 ; i < cnt ; i+=2 ){

		/* name solids */
		shflg = 's';
		mrflg = 'n';
		ctflg = 'n';
		strcpy( name , proc_sname (shflg,mrflg,count+1,ctflg) );
		count++;

		VSET(center,in[i].x,in[i].y,in[i].z);

		/* Make sphere if it has a "Good Radius" */
		if( in[i+1].x > 0.0 ) {

			mk_sph(outfp,name,center,in[i+1].x);

			(void) mk_addmember(name,&head.l,NULL, WMOP_UNION);


			/* Check if hollow (i.e. plate mode) subract sphere with
				   radius R1 - thickness */

			if (in[i].surf_mode== '-'){

				/* name inside solid */

				ctflg = 'y';
				strcpy( name , proc_sname (shflg,mrflg,count,ctflg) );

				/* make inside solid */

				if( (rad = in[i+1].x - in[i].rsurf_thick) > 0.0 ) {
					mk_sph(outfp,name,center,rad);
					(void)mk_addmember(name, &head.l,NULL, WMOP_SUBTRACT);
				}
				else {
					/* add to check group */
					(void)mk_addmember(name, &headf.l,NULL, WMOP_UNION);
				}
			}

			if( (count % num_unions) == 0 )
				proc_region(name);
		}
		else {
			rt_log( "Bad component %s\n",name);
		}

	}

	/* clean up any loose solids into a region */
	if( (count % num_unions) != 0 )
		proc_region(name);

	for( i=0; i < cnt ; i+= 2 ) {

		if( in[i].mirror == 0 )
			continue;

		mrflg = 'y';
		ctflg = 'n';
		strcpy( name , proc_sname (shflg,mrflg,mir_count+1,ctflg) );

		VSET(center,in[i].x,-in[i].y,in[i].z);

		if( in[i+1].x > 0.0 ) {
			mk_sph(outfp,name,center,in[i+1].x);
			mir_count++;

			(void) mk_addmember(name,&head.l,NULL, WMOP_UNION);

			/* Check if mirrored surface is hollow (i.e. plate mode) subract
				sphere with radius R1 - thickness */

			if (in[i].surf_mode== '-'){

				ctflg = 'y';
				strcpy( name , proc_sname (shflg,mrflg,mir_count,ctflg) );

				if( (rad = in[i+1].x - in[i].rsurf_thick) > 0.0 ) {
					mk_sph(outfp,name,center,rad);
					(void)mk_addmember(name, &head.l,NULL, WMOP_SUBTRACT);
				}
				else {
					/* add to check group */
					(void)mk_addmember(name, &headf.l,NULL, WMOP_UNION);
				}
			}

			if( (mir_count % num_unions) == 0 )
				proc_region(name);
		}
		else {
			rt_log( "Bad component %s\n",name);
		}

	}

	if( (count % num_unions) != 0 )
		proc_region(name);

	last_cc = in[cnt-1].cc;
}

/*
 *	Process fastgen box code
 */
void
proc_box(int cnt)
{
	point_t	pt8[8];
	int k;
	vect_t	ab, ac , ad, abi, aci, adi;
	fastf_t len,leni;			/* box edge lengths */
	int valid;				/* valid inside box? */
	char    shflg='\0',mrflg,ctflg;
	static int count=0;
	static int mir_count=0;
	static int last_cc=0;
	char	name[17];

	if( in[cnt-1].cc != last_cc )
	{
		count = 0;
		mir_count=0;
	}


	for(k=0 ; k <= (cnt-1) ; k+=4){
		VSET( pt8[0], in[k].x,in[k].y,in[k].z );
		VSET( pt8[1], in[k+1].x,in[k+1].y,in[k+1].z );
		VSET( pt8[4], in[k+2].x,in[k+2].y,in[k+2].z );
		VSET( pt8[3], in[k+3].x,in[k+3].y,in[k+3].z );

		VSUB2(ab,pt8[4],pt8[0]);
		VSUB2(ac,pt8[3],pt8[0]);
		VSUB2(ad,pt8[1],pt8[0]);

		VADD3(pt8[7],ab,ac,pt8[0]);
		VADD3(pt8[5],ab,ad,pt8[0]);
		VADD3(pt8[2],ac,ad,pt8[0]);
		VADD4(pt8[6],ab,ac,ad,pt8[0]);

		/* name solids */

		shflg = 'b';
		mrflg = 'n';
		ctflg = 'n';
		strcpy( name , proc_sname (shflg,mrflg,count+1,ctflg) );

		/* make solid */

		mk_arb8( outfp, name, &pt8[0][X] );
		count++;

		(void) mk_addmember(name,&head.l,NULL, WMOP_UNION);

		if( in[k].surf_mode == '-' ){

			ctflg = 'y';
			strcpy( name , proc_sname (shflg,mrflg,count,ctflg) );

			valid = 1;
			len = MAGNITUDE( ab );
			leni = (len - (2.0 * in[k].rsurf_thick)) / len;
			if( leni > 0.0 ){
				VSCALE( abi, ab, leni );
				VSCALE( ab, ab, in[k].rsurf_thick / len );
			}
			else
				valid = 0;

			len = MAGNITUDE( ac );
			leni = (len - (2.0 * in[k].rsurf_thick)) / len;
			if( valid && leni > 0.0 ){
				VSCALE( aci, ac, leni );
				VSCALE( ac, ac, in[k].rsurf_thick / len );
			}
			else
				valid = 0;

			len = MAGNITUDE( ad );
			leni = (len - (2.0 * in[k].rsurf_thick)) / len;
			if( valid && leni > 0.0 ){
				VSCALE( adi, ad, leni );
				VSCALE( ad, ad, in[k].rsurf_thick / len );
			}
			else
				valid = 0;

			if( valid ) {
				VADD4( pt8[0], pt8[0], ab, ac, ad );
				VADD2(pt8[4],abi,pt8[0]);
				VADD2(pt8[3],aci,pt8[0]);
				VADD2(pt8[1],adi,pt8[0]);

				VADD3(pt8[7],abi,aci,pt8[0]);
				VADD3(pt8[5],abi,adi,pt8[0]);
				VADD3(pt8[2],aci,adi,pt8[0]);
				VADD4(pt8[6],abi,aci,adi,pt8[0]);

				mk_arb8( outfp, name, &pt8[0][X] );
				(void)mk_addmember(name,&head.l,NULL, WMOP_SUBTRACT);
			}
			else {
				/* add to check group */
				(void)mk_addmember(name,&headf.l,NULL, WMOP_UNION);
			}
		}

		/* make region for every num_unions solids */

		if ((count % num_unions) == 0)
			proc_region(name);

	}
	/* catch leftover solids */

	if ((count % num_unions) != 0)
		proc_region(name);


	/*   Mirror Processing - duplicates above code!   */

	for(k=0 ; k <= (cnt-1) && in[k].mirror != 0 ; k+=4){
		VSET( pt8[0], in[k].x,-in[k].y,in[k].z );
		VSET( pt8[1], in[k+1].x,-in[k+1].y,in[k+1].z );
		VSET( pt8[4], in[k+2].x,-in[k+2].y,in[k+2].z );
		VSET( pt8[3], in[k+3].x,-in[k+3].y,in[k+3].z );

		VSUB2(ab,pt8[4],pt8[0]);
		VSUB2(ac,pt8[3],pt8[0]);
		VSUB2(ad,pt8[1],pt8[0]);

		VADD3(pt8[7],ab,ac,pt8[0]);
		VADD3(pt8[5],ab,ad,pt8[0]);
		VADD3(pt8[2],ac,ad,pt8[0]);
		VADD4(pt8[6],ab,ac,ad,pt8[0]);

		mrflg = 'y';
		ctflg = 'n';
		strcpy( name , proc_sname (shflg,mrflg,mir_count+1,ctflg) );

		mk_arb8( outfp, name, &pt8[0][X] );
		mir_count++;

		(void) mk_addmember(name,&head.l,NULL, WMOP_UNION);

		if( in[k].surf_mode == '-' ){

			ctflg = 'y';
			strcpy( name , proc_sname (shflg,mrflg,mir_count+1,ctflg) );

			valid = 1;
			len = MAGNITUDE( ab );
			leni = (len - (2.0 * in[k].rsurf_thick)) / len;
			if( leni > 0.0 ){
				VSCALE( abi, ab, leni );
				VSCALE( ab, ab, in[k].rsurf_thick / len );
			}
			else
				valid = 0;

			len = MAGNITUDE( ac );
			leni = (len - (2.0 * in[k].rsurf_thick)) / len;
			if( valid && leni > 0.0 ){
				VSCALE( aci, ac, leni );
				VSCALE( ac, ac, in[k].rsurf_thick / len );
			}
			else
				valid = 0;

			len = MAGNITUDE( ad );
			leni = (len - (2.0 * in[k].rsurf_thick)) / len;
			if( valid && leni > 0.0 ){
				VSCALE( adi, ad, leni );
				VSCALE( ad, ad, in[k].rsurf_thick / len );
			}
			else
				valid = 0;

			if( valid ) {
				VADD4( pt8[0], pt8[0], ab, ac, ad );
				VADD2(pt8[4],abi,pt8[0]);
				VADD2(pt8[3],aci,pt8[0]);
				VADD2(pt8[1],adi,pt8[0]);

				VADD3(pt8[7],abi,aci,pt8[0]);
				VADD3(pt8[5],abi,adi,pt8[0]);
				VADD3(pt8[2],aci,adi,pt8[0]);
				VADD4(pt8[6],abi,aci,adi,pt8[0]);

				mk_arb8( outfp, name, &pt8[0][X] );
				(void)mk_addmember(name,&head.l,NULL, WMOP_SUBTRACT);
			}
			else {
				/* add to check group */
				(void)mk_addmember(name,&headf.l,NULL, WMOP_UNION);
			}
		}

		if ((mir_count % num_unions) == 0)
			proc_region(name);
	}
	if ((count % num_unions) != 0)
		proc_region(name);
	last_cc = in[cnt-1].cc;
}

/*
 *	Donuts
 *
 *	These are specific combinations of two sort of "cones".
 *	Handled by creating two to eight TGC's and combining appropriately.
 *	In order to use "donuts", rpatch must have been invoked with the "-D" option.
 */
void
proc_donut(int cnt)
{
	int k;
	point_t base1, top1, base2, top2;
	point_t base1_in, top1_in, base2_in, top2_in;
	fastf_t rbase1, rtop1, rbase2, rtop2;
	fastf_t rbase1_in, rtop1_in, rbase2_in, rtop2_in;
	vect_t h1, h3, h4;
	fastf_t magh3, magh4;
	int end_code;
	struct wmember donut_head;
	char name[17];
	char shflg,mrflg,ctflg;
	int count=0;
	int make_basic_solids;
	char scratch_name1[17];
	char scratch_name2[17];
	char scratch_name3[17];
	char scratch_name4[17];

	for( k=0 ; k<cnt-1 ; k += 6 )	/* for each donut */
	{
		if( (in[k].x==in[k+1].x)&&(in[k].y==in[k+1].y)&&(in[k].z==in[k+1].z) )
		{
			bu_log( "Bad Donut Length for component #%d",in[k].cc);
			continue;
		}
		if( (in[k+3].x==in[k+4].x)&&(in[k+3].y==in[k+4].y)&&(in[k+3].z==in[k+4].z) )
		{
			bu_log( "Bad Donut Length for component #%d\n",in[k].cc);
			continue;
		}

		/* get base and top location of each of the two TRC's */
		VSET( base1, in[k].x, in[k].y, in[k].z );
		VSET( top1, in[k+1].x, in[k+1].y, in[k+1].z );
		VSET( base2, in[k+3].x, in[k+3].y, in[k+3].z );
		VSET( top2, in[k+4].x, in[k+4].y, in[k+4].z );

		/* get radii and bottom and top of each TRC
		 * BRL-CAD insists on non-zero radii
		 */
		rbase1 = in[k+2].x;
		if( rbase1 < tol.dist )
			rbase1 = tol.dist;
		rtop1 = in[k+2].y;
		if( rtop1 < tol.dist )
			rtop1 = tol.dist;

		rbase2 = in[k+5].x;
		if( rbase2 < tol.dist )
			rbase2 = tol.dist;
		rtop2 = in[k+5].y;
		if( rtop2 < tol.dist )
			rtop2 = tol.dist;

		if( rbase2 > rbase1 )
		{
			bu_log( "Bad Donut: inner base radius bigger than outer for component #%d\n", in[k].cc );
			continue;
		}

		if( rtop2 > rtop1 )
		{
			bu_log( "Bad Donut: inner top radius bigger than outer for component #%d\n", in[k].cc );
			continue;
		}

		/* calculate height vectors for the two basic TRC's */
		VSUB2( h1, top1, base1 );

		/* calculate height vectors for the 'end' TRC's
		 * (when inner and outer TRC ends are not the same)
		 */
		VSUB2( h3, base1, base2 );
		magh3 = MAGNITUDE( h3 );
		VSUB2( h4, top1, top2 );
		magh4 = MAGNITUDE( h4 );

		/* If inner and outer TRC ends are nearly the same, make them the same */
		if( magh3 < tol.dist )
		{
			magh3 = 0.0;
			VMOVE( base1, base2 )
		}

		if( magh4 < tol.dist )
		{
			magh4 = 0.0;
			VMOVE( top1, top2 )
		}

		/* get end code */
		end_code = (int)(in[k+5].z/mmtin);

		/* make name of this component */
		shflg = 'd';
		mrflg = 'n';
		ctflg = 'n';
		strcpy( name , proc_sname (shflg,mrflg,count+1,ctflg) );
		count++;

		BU_LIST_INIT( &donut_head.l );

		/* in some cases we won't even need the two basic TRC's */
		make_basic_solids = 1;
		if( in[k].surf_mode == '-' ) /* plate mode */
		{
			if( magh3 > 0.0 && end_code == 4 )
				make_basic_solids = 0;
			else if( magh4 > 0.0 && end_code == 5 )
				make_basic_solids = 0;
			else if( magh3 > 0.0 && magh4 > 0.0 && end_code == 6 )
				make_basic_solids = 0;
		}

		/* make the two basic TRC's */
		if( make_basic_solids )
		{
			sprintf( scratch_name1, "tmp.%d", scratch_num );
			scratch_num++;
			mk_trc_top( outfp, scratch_name1, base1, top1, rbase1, rtop1 );

			sprintf( scratch_name2, "tmp.%d", scratch_num );
			scratch_num++;
			mk_trc_top( outfp, scratch_name2, base2, top2, rbase2, rtop2 );
		}

		/* make the end TRC's if needed */
		if( magh3 > 0.0 )
		{
			if( in[k].surf_mode != '-' ||
			    end_code == 2 || end_code == 3 || end_code == 4 || end_code == 6 )
			{
				sprintf( scratch_name3, "tmp.%d", scratch_num );
				scratch_num++;
				mk_trc_top( outfp, scratch_name3, base2, base1, rbase2, rbase1 );
			}
		}

		if( magh4 > 0.0 )
		{
			if( in[k].surf_mode != '-' ||
			    end_code == 1 || end_code == 3 || end_code == 5 || end_code == 6 )
			{
				sprintf( scratch_name4, "tmp.%d", scratch_num );
				scratch_num++;
				mk_trc_top( outfp, scratch_name4, top2, top1, rtop2, rtop1 );
			}
		}

		if( in[k].surf_mode != '-' )	/* volume mode */
		{
			fastf_t dot3, dot4;

			dot3 = VDOT( h3, h1 );
			dot4 = VDOT( h4, h1 );

			if( magh3 > 0.0 && magh4 > 0.0 )
			{
				/* both ends have TRC's built */
				if( dot3 > 0.0 && dot4 < 0.0 )
				{
					/* union in both ends */
					(void)mk_addmember( scratch_name1, &donut_head.l, NULL, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head.l, NULL, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name3, &donut_head.l, NULL, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head.l, NULL, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name4, &donut_head.l, NULL, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head.l, NULL, WMOP_SUBTRACT );
				}
				else if( dot3 < 0.0 && dot4 > 0.0 )
				{
					/* subtract both ends */
					(void)mk_addmember( scratch_name1, &donut_head.l, NULL, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head.l, NULL, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name3, &donut_head.l, NULL, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name4, &donut_head.l, NULL, WMOP_SUBTRACT );
				}
				else if( dot3 > 0.0 && dot4 > 0.0 )
				{
					/* union #3 subtract #4 */
					(void)mk_addmember( scratch_name1, &donut_head.l, NULL, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head.l, NULL, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name4, &donut_head.l, NULL, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name3, &donut_head.l, NULL, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head.l, NULL, WMOP_SUBTRACT );
				}
				else
				{
					/* union #4 subtract #3 */
					(void)mk_addmember( scratch_name1, &donut_head.l, NULL, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head.l, NULL, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name3, &donut_head.l, NULL, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name4, &donut_head.l, NULL, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head.l, NULL, WMOP_SUBTRACT );
				}
			}
			else if( magh3 > 0.0 )
			{
				/* only first end has a TRC */
				if( dot3 > 0.0 )
				{
					(void)mk_addmember( scratch_name1, &donut_head.l, NULL, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head.l, NULL, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name3, &donut_head.l, NULL, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head.l, NULL, WMOP_SUBTRACT );
				}
				else
				{
					(void)mk_addmember( scratch_name1, &donut_head.l, NULL, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head.l, NULL, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name3, &donut_head.l, NULL, WMOP_SUBTRACT );
				}
			}
			else if( magh4 > 0.0 )
			{
				/* only second end has a TRC */
				if( dot4 < 0.0 )
				{
					(void)mk_addmember( scratch_name1, &donut_head.l, NULL, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head.l, NULL, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name4, &donut_head.l, NULL, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head.l, NULL, WMOP_SUBTRACT );
				}
				else
				{
					(void)mk_addmember( scratch_name1, &donut_head.l, NULL, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head.l, NULL, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name4, &donut_head.l, NULL, WMOP_SUBTRACT );
				}
			}
			else
			{
				/* no end TRC's */
				(void)mk_addmember( scratch_name1, &donut_head.l, NULL, WMOP_UNION );
				(void)mk_addmember( scratch_name2, &donut_head.l, NULL, WMOP_SUBTRACT );
			}

			if( BU_LIST_NON_EMPTY( &donut_head.l ) )
			{
				mk_lfcomb( outfp, name, &donut_head, 0 );
				(void)mk_addmember( name, &head.l, NULL, WMOP_UNION );
			}

			continue;
		}
		else	/* plate mode */
		{
			char scratch_name1_in[17];
			char scratch_name2_in[17];
			char scratch_name3_in[17];
			char scratch_name4_in[17];

			if( end_code == 0 || end_code == 1 || end_code == 2 || end_code ==3 )
			{
				/* Need sides */
				if( make_inside_trc( base1, top1, rbase1, rtop1, base1_in, top1_in, &rbase1_in, &rtop1_in, 0, 0, 1, in[k+4].rsurf_thick ) )
				{
					bu_log( "ERROR: Unable to create plate thickness of %g inches for component #%d\n",
						in[k+4].rsurf_thick*conv_mm2in, in[k].cc );
					continue;
				}

				sprintf( scratch_name1_in, "tmp.%d", scratch_num );
				scratch_num++;
				mk_trc_top(outfp,scratch_name1_in,base1_in,top1_in,rbase1_in,rtop1_in);
				(void)mk_addmember( scratch_name1, &donut_head.l, NULL, WMOP_UNION );
				(void)mk_addmember(scratch_name1_in,&donut_head.l,NULL, WMOP_SUBTRACT);

				if( make_inside_trc( base2, top2, rbase2, rtop2, base2_in, top2_in, &rbase2_in, &rtop2_in, 0, 0, 1, in[k+4].rsurf_thick ) )
				{
					bu_log( "ERROR: Unable to create plate thickness of %g inches for component #%d\n",
						in[k+4].rsurf_thick*conv_mm2in, in[k].cc );
					continue;
				}

				sprintf( scratch_name2_in, "tmp.%d", scratch_num );
				scratch_num++;
				mk_trc_top(outfp,scratch_name2_in,base2_in,top2_in,rbase2_in,rtop2_in);
				(void)mk_addmember( scratch_name2, &donut_head.l, NULL, WMOP_UNION );
				(void)mk_addmember(scratch_name2_in,&donut_head.l,NULL, WMOP_SUBTRACT);
			}

			if( end_code == 1 || end_code == 3 || end_code == 5 || end_code == 6 )
			{
				vect_t base_in, top_in;
				fastf_t rbase_in, rtop_in;

				/* close end B (top) */
				if( magh4 > 0.0 )
				{
					if( make_inside_trc( top2, top1, rtop2, rtop1, base_in, top_in, &rbase_in, &rtop_in, 0, 0, 1, in[k+4].rsurf_thick ) )
					{
						bu_log( "ERROR: Unable to create plate thickness of %g inches for component #%d\n",
							in[k+4].rsurf_thick*conv_mm2in, in[k].cc );
						continue;
					}
					sprintf( scratch_name4_in, "tmp.%d", scratch_num );
					scratch_num++;
					mk_trc_top(outfp,scratch_name4_in,base_in,top_in,rbase_in,rtop_in);
					(void)mk_addmember( scratch_name4, &donut_head.l, NULL, WMOP_UNION );
					(void)mk_addmember(scratch_name4_in,&donut_head.l,NULL, WMOP_SUBTRACT);
				}
				else
				{
					if( make_inside_trc( base1, top1, rbase1, rtop1, base_in, top_in, &rbase_in, &rtop_in, 0, 1, 0, in[k+4].rsurf_thick ) )
					{
						bu_log( "ERROR: Unable to create plate thickness of %g inches for component #%d\n",
							in[k+4].rsurf_thick*conv_mm2in, in[k].cc );
						continue;
					}
					sprintf( scratch_name4_in, "tmp.%d", scratch_num );
					scratch_num++;
					mk_trc_top(outfp,scratch_name4_in,base_in,top_in,rbase_in,rtop_in);
					(void)mk_addmember( scratch_name1, &donut_head.l, NULL, WMOP_UNION );
					(void)mk_addmember(scratch_name4_in,&donut_head.l,NULL, WMOP_SUBTRACT);
					(void)mk_addmember(scratch_name2,&donut_head.l,NULL, WMOP_SUBTRACT);
				}
			}
			if( end_code == 2 || end_code == 3 || end_code == 4 || end_code == 6 )
			{
				vect_t base_in, top_in;
				fastf_t rbase_in, rtop_in;

				/* close end A (base) */
				if( magh3 > 0.0 )
				{
					if( make_inside_trc( base2, base1, rbase2, rbase1, base_in, top_in, &rbase_in, &rtop_in, 0, 0, 1, in[k+4].rsurf_thick ) )
					{
						bu_log( "ERROR: Unable to create plate thickness of %g inches for component #%d\n",
							in[k+4].rsurf_thick*conv_mm2in, in[k].cc );
						continue;
					}
					sprintf( scratch_name3_in, "tmp.%d", scratch_num );
					scratch_num++;
					mk_trc_top(outfp,scratch_name3_in,base_in,top_in,rbase_in,rtop_in);
					(void)mk_addmember( scratch_name3, &donut_head.l, NULL, WMOP_UNION );
					(void)mk_addmember(scratch_name3_in,&donut_head.l,NULL, WMOP_SUBTRACT);
				}
				else
				{
					if( make_inside_trc( base1, top1, rbase1, rtop1, base_in, top_in, &rbase_in, &rtop_in, 1, 0, 0, in[k+4].rsurf_thick ) )
					{
						bu_log( "ERROR: Unable to create plate thickness of %g inches for component #%d\n",
							in[k+4].rsurf_thick*conv_mm2in, in[k].cc );
						continue;
					}
					sprintf( scratch_name3_in, "tmp.%d", scratch_num );
					scratch_num++;
					mk_trc_top(outfp,scratch_name3_in,base_in,top_in,rbase_in,rtop_in);
					(void)mk_addmember( scratch_name1, &donut_head.l, NULL, WMOP_UNION );
					(void)mk_addmember(scratch_name3_in,&donut_head.l,NULL, WMOP_SUBTRACT);
					(void)mk_addmember(scratch_name2,&donut_head.l,NULL, WMOP_SUBTRACT);
				}
			}

			if( BU_LIST_NON_EMPTY( &donut_head.l ) )
			{
				mk_lfcomb( outfp, name, &donut_head, 0 );
				(void)mk_addmember( name, &head.l, NULL, WMOP_UNION );
			}

			continue;
		}
	}

	if( BU_LIST_NON_EMPTY( &head.l ) )
		proc_region( name );
}

/* 
 *	Cylinder Fastgen Support:
 *	Cylinders have the added complexity of being plate or volume mode,
 *	and closed vs. open ends. This makes things a bit ugly. 
 *
 *	NOTE:	This handles plate mode subtractions. It also handles a
 *		subset of the allowable volume mode subtractions, in that
 *		it will correctly hollow cylinders in a pairwise manner.
 *		If cylinder1 *completely* encloses cylinder2, then cylinder2
 *		will be subtracted from cylinder1.
 *
 */
void
proc_cylin(int cnt)
{
	point_t base;
	point_t	top;
	point_t sbase;			/* For subtraction case */
	point_t	stop; 			/* For subtraction case */
	vect_t	ab,bc;
	fastf_t	rad1,rad2;
	fastf_t srad1,srad2;		/* for subtraction case */
	int k,j;
	struct subtract_list *slist,*get_subtract(int cnt);
	double	thick,ht,sht;
	char    shflg='\0',mrflg,ctflg;
	static int count=0;
	static int mir_count=0;
	static int last_cc=0;
	char	name[17];

	if( in[cnt-1].cc != last_cc )
	{
		count = 0;
		mir_count=0;
	}


	slist = get_subtract(cnt);
	if( debug>2 ){
		struct subtract_list *sp;

		for( sp=slist; sp; sp=sp->next )
			rt_log( "%d %d %d\n", 
			    sp->outsolid,sp->insolid,sp->inmirror );
	}


	for(k=0 ; k < (cnt-1) ; k+=3){	 /* For all sub-cylinders in this cc */

		/* name solids */
		shflg = 'c';
		mrflg = 'n';
		ctflg = 'n';
		strcpy( name , proc_sname (shflg,mrflg,count+1,ctflg) );

		count++;

		/* Test for a cylinder with no length, all conditions must be true to fail. */

		if(!((in[k].x==in[k+1].x)&&(in[k].y==in[k+1].y)&&(in[k].z==in[k+1].z))){

			VSET(base,in[k].x,in[k].y,in[k].z);
			VSET(top,in[k+1].x,in[k+1].y,in[k+1].z);

			/* change valid 0 radius cone pts to very small radii,
			 * also treat negative value radii as positive.
			 */
			if(in[k+2].x == 0) 
			  in[k+2].x = .00001;
			if(in[k+2].x < 0)
			  in[k+2].x = -in[k+2].x;
			if(in[k+2].y == 0) 
			  in[k+2].y = .00001;
			if(in[k+2].y < 0)
			  in[k+2].y = -in[k+2].y;

			/* make solid */

			mk_trc_top(outfp,name,base,top,in[k+2].x,in[k+2].y);
			mk_cyladdmember(name,&head,slist,0);

			/* mk_trc_top destroys the values of base,top */
			VSET(base,in[k].x,in[k].y,in[k].z);
			VSET(top,in[k+1].x,in[k+1].y,in[k+1].z);

			j = (int)(in[k+2].z/mmtin);

			if (in[k].surf_mode== '-'){     /* Plate mode */
				vect_t unit_h;
				fastf_t sin_ang;
				fastf_t rad1_tmp,rad2_tmp;

				ctflg = 'y';
				strcpy( name , proc_sname (shflg,mrflg,count,ctflg) );

				rad1 = in[k+2].x;
				rad2 = in[k+2].y;
				VSUB2(ab,top,base);
				ht = MAGNITUDE( ab );
				sin_ang = ht/hypot( ht, rad2-rad1 );
				switch(j){

				case 0: /* Both ends open */

					thick = in[k+2].rsurf_thick / sin_ang;
					srad1 = rad1 - thick;
					srad2 = rad2 - thick;

					if( srad1 <= 0.0 && srad2 <= 0.0 )
						(void)mk_addmember(name,&headf.l,NULL, WMOP_UNION);
					else if( srad1 <= 0.0 )
					{
						fastf_t new_h_factor;
						fastf_t invers_height;

						invers_height = 1.0/ht;
						VSCALE( unit_h, ab, invers_height )
						new_h_factor = (thick - rad1)*(ht/(rad2-rad1));
						VJOIN1( sbase, base, new_h_factor, unit_h )

						/* base radius should really be zero, get close */
						srad1 = .00001;
						mk_trc_top(outfp,name,sbase,top,srad1,srad2);
						(void)mk_addmember(name,&head.l,NULL, WMOP_SUBTRACT);
					}
					else if( srad2 <= 0.0 )
					{
						fastf_t new_h_factor;
						fastf_t invers_height;

						invers_height = 1.0/ht;
						VSCALE( unit_h, ab, invers_height )
						new_h_factor = ht + srad2 * (ht/(rad1-rad2));
						VJOIN1( stop, base, new_h_factor, unit_h )

						/* top radius should really be zero, get close */
						srad2 = .00001;
						mk_trc_top(outfp,name,base,stop,srad1,srad2);
						(void)mk_addmember(name,&head.l,NULL, WMOP_SUBTRACT);
					}
					else
					{
						mk_trc_top(outfp,name,base,top,srad1,srad2);
						(void)mk_addmember(name,&head.l,NULL, WMOP_SUBTRACT);
					}
					break;

				case 1: /* Base closed, top open */

					VSUB2(ab,top,base);
					ht = MAGNITUDE( ab );
					VUNITIZE(ab);
					VMOVE( unit_h, ab );
					VSCALE(ab,ab,in[k].rsurf_thick);
					VADD2(sbase,base,ab);

					rad1 = in[k+2].x;
					rad2 = in[k+2].y;
					VSUB2(ab,top,sbase);
					sht = MAGNITUDE( ab );
					srad1 = rad2 - sht / ht * (rad2 - rad1);
					thick = in[k+2].rsurf_thick / ht * 
					    hypot( ht, rad2-rad1 );
					srad1 = srad1 - thick;
					srad2 = rad2 - thick;

					if( srad1 <= 0.0 && srad2 <= 0.0 )
						(void)mk_addmember(name,&headf.l,NULL, WMOP_UNION);
					else if( srad1 <= 0.0 )
					{
						fastf_t new_ht;

						new_ht = ht*(thick - rad1)/(rad2-rad1);
						if( new_ht >= ht )
							(void)mk_addmember(name,&headf.l,NULL, WMOP_UNION);
						else
						{
							VJOIN1( sbase, base, new_ht, unit_h );
							srad1 = 0.00001;
							mk_trc_top(outfp,name,sbase,top,srad1,srad2);
							(void)mk_addmember(name,&head.l,NULL, WMOP_SUBTRACT);
						}
					}
					else if( srad2 <= 0.0 )
					{
						fastf_t new_ht;

						new_ht = sht + ht*srad2/(rad1-rad2);
						if( new_ht <= 0.0 )
							(void)mk_addmember(name,&headf.l,NULL, WMOP_UNION);
						else
						{
							VJOIN1( stop, sbase, new_ht, unit_h );
							srad2 = 0.00001;
							mk_trc_top(outfp,name,sbase,stop,srad1,srad2);
							(void)mk_addmember(name,&head.l,NULL, WMOP_SUBTRACT);
						}
					}
					else
					{
						mk_trc_top(outfp,name,sbase,top,srad1,srad2);
						(void)mk_addmember(name,&head.l,NULL, WMOP_SUBTRACT);
					}
					break;
				case 2: /* Base open, top closed */

					VSUB2(ab,base,top);
					ht = MAGNITUDE( ab );
					VUNITIZE(ab);
					VMOVE( unit_h, ab );
					VSCALE(ab,ab,in[k].rsurf_thick);
					VADD2(stop,top,ab);

					rad1 = in[k+2].x;
					rad2 = in[k+2].y;
					VSUB2(ab,stop,base);
					sht = MAGNITUDE( ab );
					srad2 = rad1 - sht / ht * (rad1 - rad2);
					thick = in[k+2].rsurf_thick / ht * 
					    hypot( ht, rad2-rad1 );
					srad1 = rad1 - thick;
					srad2 = srad2 - thick;

					if( srad1 <= 0.0 && srad2 <= 0.0 )
						(void)mk_addmember(name,&headf.l,NULL, WMOP_UNION);
					else if( srad1 <= 0.0 )
					{
						fastf_t new_ht;

						new_ht = sht + ht*srad1/(rad2-rad1);
						if( new_ht <= 0.0 )
							(void)mk_addmember(name,&headf.l,NULL, WMOP_UNION);
						else
						{
							VJOIN1( sbase, stop, new_ht, unit_h )
							srad1 = 0.00001;
							mk_trc_top(outfp,name,sbase,stop,srad1,srad2);
							(void)mk_addmember(name,&head.l,NULL, WMOP_SUBTRACT);
						}
					}
					else if( srad2 <= 0.0 )
					{
						fastf_t new_ht;

						new_ht = ht*(thick - rad2)/(rad1-rad2);
						if( new_ht >= ht )
							(void)mk_addmember(name,&headf.l,NULL, WMOP_UNION);
						else
						{
							VJOIN1( stop, top, new_ht, unit_h )
							srad2 = 0.00001;
							mk_trc_top(outfp,name,base,stop,srad1,srad2);
							(void)mk_addmember(name,&head.l,NULL, WMOP_SUBTRACT);
						}
					}
					else
					{
						mk_trc_top(outfp,name,base,stop,srad1,srad2);
						(void)mk_addmember(name,&head.l,NULL, WMOP_SUBTRACT);
					}
					break;

				case 3: /* Both closed */

					VSUB2(ab,top,base);
					VSUB2(bc,base,top);
					ht = MAGNITUDE( ab );
					VUNITIZE(ab);
					VMOVE( unit_h, ab );
					VUNITIZE(bc);
					VSCALE(ab,ab,in[k].rsurf_thick);
					VSCALE(bc,bc,in[k].rsurf_thick);
					VADD2(sbase,base,ab);
					VADD2(stop,top,bc);

					rad1 = in[k+2].x;
					rad2 = in[k+2].y;
					VSUB2(ab,stop,base);
					sht = MAGNITUDE( ab );
					rad1_tmp = rad2 - sht / ht * (rad2 - rad1);
					rad2_tmp = rad1 - sht / ht * (rad1 - rad2);
					thick = in[k+2].rsurf_thick / ht * 
					    hypot( ht, rad2-rad1 );
					srad1 = rad1_tmp - thick;
					srad2 = rad2_tmp - thick;

					if( (srad1 <= 0.0 && srad2 <= 0.0) || sht <= 0.0)
						(void)mk_addmember(name,&headf.l,NULL, WMOP_UNION);
					else if( srad1 < 0.0 )
					{
						fastf_t new_ht;

						new_ht = ht*(thick-rad1_tmp)/(rad2_tmp-rad1_tmp);
						if( new_ht >= sht )
							(void)mk_addmember(name,&headf.l,NULL, WMOP_UNION);
						else
						{
							VJOIN1( sbase, sbase, new_ht, unit_h )
							srad1 = 0.00001;
							mk_trc_top(outfp,name,sbase,stop,srad1,srad2);
							(void)mk_addmember(name,&head.l,NULL, WMOP_SUBTRACT);
						}
					}
					else if( srad2 <= 0.0 )
					{
						fastf_t new_ht;
						vect_t rev_h;


						new_ht = (-ht*srad2/(rad1-rad2));
						if( new_ht <= 0.0 )
							(void)mk_addmember(name,&headf.l,NULL, WMOP_UNION);
						else
						{
							VREVERSE( rev_h, unit_h )
							VJOIN1( stop, stop, new_ht, rev_h )
							srad2 = 0.00001;
							mk_trc_top(outfp,name,sbase,stop,srad1,srad2);
							(void)mk_addmember(name,&head.l,NULL, WMOP_SUBTRACT);
						}
					}
					else
					{
						mk_trc_top(outfp,name,sbase,stop,srad1,srad2);
						(void)mk_addmember(name,&head.l,NULL, WMOP_SUBTRACT);
					}
					break;

				default:
					rt_log( "Unknown cylinder mode\n");
					break;

				}         /* end switch */
			}     		  /* end - plate mode modifications */
		}         			  /* Degenerate length check */
		else {
			rt_log( "Bad Cylinder Length for %s\n",name);
		}
		/* make regions */

		/* due to solid subtractions, this might be a null region */

		if ((count % num_unions) == 0 && (RT_LIST_NEXT_NOT_HEAD(&head, &head.l)))
			proc_region(name);

	} 	   /* end - for */
	/* catch missed solids into final region */

	/* due to solid subtractions, this might be a null region */
	if ((count % num_unions) != 0 && (RT_LIST_NEXT_NOT_HEAD(&head, &head.l)))
		proc_region(name);

	/*    Mirror Processing - duplicates above code!   */

	for(k=0 ; k < (cnt-1) ; k+=3){

		if( in[k].mirror == 0 )
			continue;

		mrflg = 'y';
		ctflg = 'n';
		strcpy( name , proc_sname (shflg,mrflg,mir_count+1,ctflg) );
		mir_count++;

		if(!((in[k].x==in[k+1].x)&&(in[k].y==in[k+1].y)&&(in[k].z==in[k+1].z))){

			VSET(base,in[k].x,-in[k].y,in[k].z);
			VSET(top,in[k+1].x,-in[k+1].y,in[k+1].z);

			if(in[k+2].x == 0) 
				in[k+2].x = .00001;
			if(in[k+2].x < 0)
				in[k+2].x = -in[k+2].x;
			if(in[k+2].y == 0) 
				in[k+2].y = .00001;
			if(in[k+2].y < 0)
				in[k+2].y = -in[k+2].y;

			mk_trc_top(outfp,name,base,top,in[k+2].x,in[k+2].y);
			mk_cyladdmember(name,&head,slist,1);

			/* mk_trc_top destroys the values of base,top */
			VSET(base,in[k].x,-in[k].y,in[k].z);
			VSET(top,in[k+1].x,-in[k+1].y,in[k+1].z);

			j = (int)(in[k+2].z/mmtin);

			if (in[k].surf_mode== '-'){ 	/* Plate mode */
				vect_t unit_h;
				fastf_t sin_ang;
				fastf_t rad1_tmp,rad2_tmp;

				ctflg = 'y';
				strcpy( name , proc_sname (shflg,mrflg,mir_count,ctflg) );

				rad1 = in[k+2].x;
				rad2 = in[k+2].y;
				VSUB2(ab,top,base);
				ht = MAGNITUDE( ab );
				sin_ang = ht/hypot( ht, rad2-rad1 );

				switch(j){

				case 0: /* Both ends open */

					thick = in[k+2].rsurf_thick / sin_ang;
					srad1 = rad1 - thick;
					srad2 = rad2 - thick;

					if( srad1 <= 0.0 && srad2 <= 0.0 )
						(void)mk_addmember(name,&headf.l,NULL, WMOP_UNION);
					else if( srad1 <= 0.0 )
					{
						fastf_t new_h_factor;
						fastf_t invers_height;

						invers_height = 1.0/ht;
						VSCALE( unit_h, ab, invers_height )
						new_h_factor = (thick - rad1)*(ht/(rad2-rad1));
						VJOIN1( sbase, base, new_h_factor, unit_h )

						/* base radius should really be zero, get close */
						srad1 = .00001;
						mk_trc_top(outfp,name,sbase,top,srad1,srad2);
						(void)mk_addmember(name,&head.l,NULL, WMOP_SUBTRACT);
					}
					else if( srad2 <= 0.0 )
					{
						fastf_t new_h_factor;
						fastf_t invers_height;

						invers_height = 1.0/ht;
						VSCALE( unit_h, ab, invers_height )
						new_h_factor = ht + srad2 * (ht/(rad1-rad2));
						VJOIN1( stop, base, new_h_factor, unit_h )

						/* top radius should really be zero, get close */
						srad2 = .00001;
						mk_trc_top(outfp,name,base,stop,srad1,srad2);
						(void)mk_addmember(name,&head.l,NULL, WMOP_SUBTRACT);
					}
					else
					{
						mk_trc_top(outfp,name,base,top,srad1,srad2);
						(void)mk_addmember(name,&head.l,NULL, WMOP_SUBTRACT);
					}
					break;

				case 1: /* Base closed, top open */

					VSUB2(ab,top,base);
					ht = MAGNITUDE( ab );
					VUNITIZE(ab);
					VMOVE( unit_h, ab );
					VSCALE(ab,ab,in[k].rsurf_thick);
					VADD2(sbase,base,ab);

					rad1 = in[k+2].x;
					rad2 = in[k+2].y;
					VSUB2(ab,top,sbase);
					sht = MAGNITUDE( ab );
					srad1 = rad2 - sht / ht * (rad2 - rad1);
					thick = in[k+2].rsurf_thick / ht * 
					    hypot( ht, rad2-rad1 );
					srad1 = srad1 - thick;
					srad2 = rad2 - thick;

					if( srad1 <= 0.0 && srad2 <= 0.0 )
						(void)mk_addmember(name,&headf.l,NULL, WMOP_UNION);
					else if( srad1 <= 0.0 )
					{
						fastf_t new_ht;

						new_ht = ht*(thick - rad1)/(rad2-rad1);
						if( new_ht >= ht )
							(void)mk_addmember(name,&headf.l,NULL, WMOP_UNION);
						else
						{
							VJOIN1( sbase, base, new_ht, unit_h );
							srad1 = 0.00001;
							mk_trc_top(outfp,name,sbase,top,srad1,srad2);
							(void)mk_addmember(name,&head.l,NULL, WMOP_SUBTRACT);
						}
					}
					else if( srad2 <= 0.0 )
					{
						fastf_t new_ht;

						new_ht = sht + ht*srad2/(rad1-rad2);
						if( new_ht <= 0.0 )
							(void)mk_addmember(name,&headf.l,NULL, WMOP_UNION);
						else
						{
							VJOIN1( stop, sbase, new_ht, unit_h );
							srad2 = 0.00001;
							mk_trc_top(outfp,name,sbase,stop,srad1,srad2);
							(void)mk_addmember(name,&head.l,NULL, WMOP_SUBTRACT);
						}
					}
					else
					{
						mk_trc_top(outfp,name,sbase,top,srad1,srad2);
						(void)mk_addmember(name,&head.l,NULL, WMOP_SUBTRACT);
					}
					break;
				case 2: /* Base open, top closed */

					VSUB2(ab,base,top);
					ht = MAGNITUDE( ab );
					VUNITIZE(ab);
					VMOVE( unit_h, ab );
					VSCALE(ab,ab,in[k].rsurf_thick);
					VADD2(stop,top,ab);

					rad1 = in[k+2].x;
					rad2 = in[k+2].y;
					VSUB2(ab,stop,base);
					sht = MAGNITUDE( ab );
					srad2 = rad1 - sht / ht * (rad1 - rad2);
					thick = in[k+2].rsurf_thick / ht * 
					    hypot( ht, rad2-rad1 );
					srad1 = rad1 - thick;
					srad2 = srad2 - thick;

					if( srad1 <= 0.0 && srad2 <= 0.0 )
						(void)mk_addmember(name,&headf.l,NULL, WMOP_UNION);
					else if( srad1 <= 0.0 )
					{
						fastf_t new_ht;

						new_ht = sht + ht*srad1/(rad2-rad1);
						if( new_ht <= 0.0 )
							(void)mk_addmember(name,&headf.l,NULL, WMOP_UNION);
						else
						{
							VJOIN1( sbase, stop, new_ht, unit_h )
							srad1 = 0.00001;
							mk_trc_top(outfp,name,sbase,stop,srad1,srad2);
							(void)mk_addmember(name,&head.l,NULL, WMOP_SUBTRACT);
						}
					}
					else if( srad2 <= 0.0 )
					{
						fastf_t new_ht;

						new_ht = ht*(thick - rad2)/(rad1-rad2);
						if( new_ht >= ht )
							(void)mk_addmember(name,&headf.l,NULL, WMOP_UNION);
						else
						{
							VJOIN1( stop, top, new_ht, unit_h )
							srad2 = 0.00001;
							mk_trc_top(outfp,name,base,stop,srad1,srad2);
							(void)mk_addmember(name,&head.l,NULL, WMOP_SUBTRACT);
						}
					}
					else
					{
						mk_trc_top(outfp,name,base,stop,srad1,srad2);
						(void)mk_addmember(name,&head.l,NULL, WMOP_SUBTRACT);
					}
					break;

				case 3: /* Both closed */

					VSUB2(ab,top,base);
					VSUB2(bc,base,top);
					ht = MAGNITUDE( ab );
					VUNITIZE(ab);
					VMOVE( unit_h, ab );
					VUNITIZE(bc);
					VSCALE(ab,ab,in[k].rsurf_thick);
					VSCALE(bc,bc,in[k].rsurf_thick);
					VADD2(sbase,base,ab);
					VADD2(stop,top,bc);

					rad1 = in[k+2].x;
					rad2 = in[k+2].y;
					VSUB2(ab,stop,base);
					sht = MAGNITUDE( ab );
					rad1_tmp = rad2 - sht / ht * (rad2 - rad1);
					rad2_tmp = rad1 - sht / ht * (rad1 - rad2);
					thick = in[k+2].rsurf_thick / ht * 
					    hypot( ht, rad2-rad1 );
					srad1 = rad1_tmp - thick;
					srad2 = rad2_tmp - thick;

					if( (srad1 <= 0.0 && srad2 <= 0.0) || sht <= 0.0)
						(void)mk_addmember(name,&headf.l,NULL, WMOP_UNION);
					else if( srad1 < 0.0 )
					{
						fastf_t new_ht;

						new_ht = ht*(thick-rad1_tmp)/(rad2_tmp-rad1_tmp);
						if( new_ht >= sht )
							(void)mk_addmember(name,&headf.l,NULL, WMOP_UNION);
						else
						{
							VJOIN1( sbase, sbase, new_ht, unit_h )
							srad1 = 0.00001;
							mk_trc_top(outfp,name,sbase,stop,srad1,srad2);
							(void)mk_addmember(name,&head.l,NULL, WMOP_SUBTRACT);
						}
					}
					else if( srad2 <= 0.0 )
					{
						fastf_t new_ht;
						vect_t rev_h;


						new_ht = (-ht*srad2/(rad1-rad2));
						if( new_ht <= 0.0 )
							(void)mk_addmember(name,&headf.l,NULL, WMOP_UNION);
						else
						{
							VREVERSE( rev_h, unit_h )
							VJOIN1( stop, stop, new_ht, rev_h )
							srad2 = 0.00001;
							mk_trc_top(outfp,name,sbase,stop,srad1,srad2);
							(void)mk_addmember(name,&head.l,NULL, WMOP_SUBTRACT);
						}
					}
					else
					{
						mk_trc_top(outfp,name,sbase,stop,srad1,srad2);
						(void)mk_addmember(name,&head.l,NULL, WMOP_SUBTRACT);
					}
					break;

				default:
					rt_log( "Unknown cylinder mode\n");
					break;

				}         /* end switch */
			}/* plate mode */
		}
		else {
			rt_log( "Bad Cylinder Length for %s\n",name);
		}
		/* due to solid subtractions, this might be a null region */
		if ((mir_count % num_unions) == 0 && (RT_LIST_NEXT_NOT_HEAD(&head, &head.l)))
			proc_region(name);
	}	/* end for k loop */
	/* due to solid subtractions, this might be a null region */

	if ((count % num_unions) != 0 && (RT_LIST_NEXT_NOT_HEAD(&head, &head.l)))
		proc_region(name);

	last_cc = in[cnt-1].cc;
}

/*
 *	Process fastgen rod mode
 */
void
proc_rod(int cnt)
{

	int k,l,index;
	point_t base;
	point_t	top;
	fastf_t tmp;
	fastf_t tmp1;
	char    shflg='\0',mrflg,ctflg;
	static int count=0;
	static int mir_count=0;
	static int last_cc=0;
	char	name[17];

	if( in[cnt-1].cc != last_cc )
	{
		count = 0;
		mir_count=0;
	}


	for(k=0 ; k < cnt ; k++){
		for(l=0; l<= 7; l++){

			if(in[k].ept[l] > 0){

				index = in[k].ept[l];
				list[index].x = in[k].x;
				list[index].y = in[k].y;
				list[index].z = in[k].z;
				list[index].radius = in[k].rsurf_thick;
				list[index].mirror = in[k].mirror;
				list[index].flag = 1;

				if (debug > 3)
					rt_log( "%d %f %f %f %f %d\n",list[index].flag,in[k].x,in[k].y,in[k].z,in[k].rsurf_thick,
					    in[k].mirror);
			}

		}
	}

	/* Everything is sequenced, but separated, compress into single array here */
	/* list[0] will not hold anything, so don't look */

	l = 0;
	for (k=1; k<10000; k++){
		if(list[k].flag == 1){
			list[k].flag = 0;
			x[l] = list[k].x;
			y[l] = list[k].y;
			z[l] = list[k].z;
			radius[l] = list[k].radius;
			mirror[l] = list[k].mirror;

			l= l+1;
			if (debug > 3)
				rt_log( "k=%d l=%d %f %f %f %f %d flag=%d\n",
				    k,l,list[k].x,list[k].y,list[k].z,
				    list[k].flag,list[k].radius,list[k].mirror);
		}
	}

	if (debug > 2){
		for (k=1;(k<=l);k++)
			rt_log( "compressed: %d %f %f %f %f %d\n",
			    k,x[k],y[k],z[k],radius[k],mirror[k]);
	}

	for(k=1 ; k < (l-1) ; k++){

		if( (x[k]==x[k+1]) && (y[k]==y[k+1]) && (z[k]==z[k+1]) ) {
			k += 2;
			continue;
		}

		/* name solids */
		shflg = 'r';
		mrflg = 'n';
		ctflg = 'n';
		strcpy( name , proc_sname (shflg,mrflg,count+1,ctflg) );

		/* make solids */
		count++;

		VSET(base,x[k],y[k],z[k]);
		VSET(top,x[k+1],y[k+1],z[k+1]);

		tmp = radius[k];
		tmp1 = radius[k+1];

		if((tmp > 0)&&(tmp1 > 0)){
			mk_trc_top(outfp,name,base,top,tmp,tmp1);
		}
		else {
			rt_log( "Bad Rod Radius for %s\n",name);
		}

		if( count > 1 && (count % num_unions) == 0 ){
			(void)mk_addmember(name,&head.l,NULL, WMOP_SUBTRACT);
			proc_region( name );
			(void)mk_addmember(name,&head.l,NULL, WMOP_UNION);
		} else {
			(void) mk_addmember(name,&head.l,NULL, WMOP_UNION);
		}
	}
	/* catch leftover solids */
	if( count > 0  ) {
		proc_region( name );
	}

	/*    Mirror Processing - duplicates above code!    */

	for( k=1 ; k < (l-1) ; k++){

		if( mirror[k] == 0 )
			continue;

		if( (x[k]==x[k+1]) && (y[k]==y[k+1]) && (z[k]==z[k+1]) ) {
			k += 2;
			continue;
		}


		mrflg = 'y';
		ctflg = 'n';
		strcpy( name , proc_sname (shflg,mrflg,mir_count+1,ctflg) );

		/* make solids */
		mir_count++;

		VSET(base,x[k],-y[k],z[k]);
		VSET(top,x[k+1],-y[k+1],z[k+1]);

		tmp = radius[k];
		tmp1 = radius[k+1];

		if((tmp > 0)&&(tmp1 > 0)){
			mk_trc_top(outfp,name,base,top,tmp,tmp1);
		}
		else {
			rt_log( "Bad Rod Radius for %s\n",name);
		}

		if( mir_count > 1 && (mir_count % num_unions) == 0 ) {
			(void)mk_addmember(name,&head.l,NULL, WMOP_SUBTRACT);
			proc_region( name );
			(void)mk_addmember(name,&head.l,NULL, WMOP_UNION);
		}
		else {
			(void) mk_addmember(name,&head.l,NULL, WMOP_UNION);
		}

	} /* for */
	if( count > 0 ) {
		proc_region( name );
	}

	last_cc = in[cnt-1].cc;
}

/*
 *  Find the single outward pointing normal for a polygon.
 *  Assumes all points are coplanar (they better be!).
 */
void
pnorms(fastf_t (*norms)[3], fastf_t (*verts)[3], fastf_t *centroid, int npts, int inv)
{
	register int i;
	vect_t	ab, ac;
	vect_t	n;

	VSUB2( ab, verts[1], verts[0] );
	VSUB2( ac, verts[2], verts[0] );
	VCROSS( n, ab, ac );
	VUNITIZE( n );

	/*	VSUB2( out, verts[0], centroid );
	if( VDOT( n, out ) < 0 )  {
		VREVERSE( n, n );
	}
*/

	/*	VSUB2( out, centroid,verts[0]);
	VADD3(tmp,verts[0],out,n);
*/

	if ((inv % 2)!= 0)  {
		VREVERSE( n, n );
	}

	/*	for( i=0; i<npts; i++ )  {
		VMOVE( norms[i], n );
	}
*/

	for( i=0; i<npts; i++ )  {
		VMOVE( norms[i], n );
	}
}

/*
 *     This subroutine reads a "group label file" and assembles regions and
 *	groups from that file.
 *
 *	heada == linked list of components on one side or not mirrored
 *	headb == linked list of mirrored components
 *	headd == linked list of this thousand series
 *	heade == linked list of over-all group
 */
void
proc_label(char *labelfile)
{
	char gname[16+1], mgname[16+1];	/* group, mirrored group names */
	static int cur_series = -1;

	if( cur_series == -1 ) {		/* first time */
		cur_series = in[0].cc / 1000;
		set_color( cur_series );
		proc_label(labelfile);
		return;
	}

	if( cur_series == (in[0].cc / 1000))
	{
		if( labelfile != NULL ) {
			sprintf(gname,"%s", nm[in[0].cc].ug );
			sprintf(mgname,"%s", nm[in[0].cc + in[0].mirror].ug );
		}
		else {
			sprintf(gname,"#%.4d",in[0].cc);
			sprintf(mgname,"#%.4d",(in[0].cc + in[0].mirror));
		}
		if( RT_LIST_NON_EMPTY( &heada.l ) )
		{
			mk_lcomb(outfp,gname,&heada,0,"","",0,0);
			(void) mk_addmember(gname,&headd.l,NULL, WMOP_UNION);
		}
		if( RT_LIST_NON_EMPTY( &headb.l ) )
		{
			mk_lcomb(outfp,mgname,&headb,0,"","",0,0);
			(void) mk_addmember(mgname,&headd.l,NULL, WMOP_UNION);
		}
	}
	else {
		sprintf(gname,"%dxxx_series",cur_series);
		mk_lcomb(outfp,gname,&headd,0,"","",rgb,0);
		(void) mk_addmember(gname,&heade.l,NULL, WMOP_UNION);

		cur_series = in[0].cc/1000 ;
		set_color( cur_series );
		proc_label(labelfile);
	}

}

/*			S E T _ C O L O R
 *
 * Given a color_map entry (for the thousand series) for the combination being
 * made, set the rgb color array for the upcoming call to make combinations.
 */
void
set_color(int color)
{

	switch ( color ){

	case 0:      /* 0XXX_series */

		rgb[0] = 191;
		rgb[1] = 216;
		rgb[2] = 216;

		break;

	case 1:      /* 1XXX_series */

		rgb[0] = 255;
		rgb[1] = 127;
		rgb[2] =   0;

		break;

	case 2:      /* 2XXX_series */

		rgb[0] = 159;
		rgb[1] = 159;
		rgb[2] =  95;

		break;

	case 3:      /* 3XXX_series */

		rgb[0] = 159;
		rgb[1] =  95;
		rgb[2] = 159;

		break;

	case 4:      /* 4XXX_series */

		rgb[0] = 245;
		rgb[1] = 245;
		rgb[2] =   0;

		break;

	case 5:      /* 5XXX_series */

		rgb[0] = 204;
		rgb[1] = 110;
		rgb[2] =  50;

		break;

	case 6:      /* 6XXX_series */

		rgb[0] = 200;
		rgb[1] = 100;
		rgb[2] = 100;

		break;

	case 7:      /* 7XXX_series */

		rgb[0] =  95;
		rgb[1] = 159;
		rgb[2] = 159;

		break;

	case 8:      /* 8XXX_series */

		rgb[0] = 100;
		rgb[1] = 200;
		rgb[2] = 100;

		break;

	case 9:     /* 9XXX_series */

		rgb[0] = 150;
		rgb[1] = 150;
		rgb[2] = 150;

		break;

	default:
		break;
	}
}

/*			I N S I D E _ C Y L
 *
 * Returns 1 if the cylinder starting at in[j] is inside ( for solid
 * subtraction) the cylinder described at in[i], 0 otherwise.
 *
 * This is not a foolproof determination. We only check to see whether the
 * endpoints of the supposed inside cylinder lie within the first cylinder
 * and that the radii of the second cylinder are <= those of the first 
 * cylinder. We don't actually see whether the entire second cylinder lies
 * within the first.
 */
int
inside_cyl(int i, int j)
{
	point_t	outbase,outtop,inbase,intop;
	fastf_t	r1,r2;

	r1 = in[i+2].x;
	r2 = in[i+2].y;

	if( (r1 < in[j+2].x) || (r2 < in[j+2].y) )
		return( 0 );

	VSET( outbase, in[i].x,in[i].y,in[i].z );
	VSET( outtop, in[i+1].x,in[i+1].y,in[i+1].z );

	VSET( inbase, in[j].x,in[j].y,in[j].z );
	VSET( intop, in[j+1].x,in[j+1].y,in[j+1].z );

	if( !pt_inside( inbase, outbase, outtop, r1, r2 ) )
		return( 0 );
	else if( !pt_inside( intop, outbase, outtop, r1, r2 ) )
		return( 0 );
	else
		return( 1 );
}

/*			P T _ I N S I D E
 *
 * Returns 1 if point a is inside the cylinder defined by base,top,rad1,rad2.
 * Returns 0 if not.
 */
int
pt_inside( point_t a, point_t base, point_t top, double rad1, double rad2 )
{
	vect_t bt,ba;		/* bt: base to top, ba: base to a */
	fastf_t mag_bt,
	    dist,		/* distance to the normal between the axis
				 * and the point
				 */
	radius,		/* radius of cylinder at above distance */
	pt_radsq;	/* sqare of radial distance from the axis 
				 * to point
					 */

	VSUB2( bt, top, base );
	VSUB2( ba, a, base );
	mag_bt = MAGNITUDE( bt );
	VUNITIZE( bt );

	dist = VDOT( bt,ba );
	if( dist < -tol.dist  || dist - mag_bt > tol.dist )
		return( 0 );

	radius = ((rad2 - rad1)*dist)/mag_bt + rad1;

	pt_radsq = MAGSQ(ba) - (dist*dist);
	if( debug>2 && pt_radsq - (radius*radius) < tol.dist_sq  ){
		rt_log( "pt_inside: point (%.4f,%.4f,%.4f) inside cylinder endpoints (%.4f,%.4f,%.4f) and (%.4f,%.4f,%.4f)\n",
		    a[0]/mmtin,a[1]/mmtin,a[2]/mmtin,
		    base[0]/mmtin,base[1]/mmtin,base[2]/mmtin,
		    top[0]/mmtin,top[1]/mmtin,top[2]/mmtin);
		rt_log( "pt_inside: radius at that point is %f\n",radius/mmtin);
		rt_log( "pt_inside: radial distance to point is %f\n",sqrt(pt_radsq)/mmtin );
		rt_log( "pt_inside: square of radial distance is %f\n",pt_radsq/(mmtin*mmtin));
		rt_log( "pt_inside: dist to base to point is %f\n",MAGSQ(ba)/mmtin );
		rt_log( "pt_inside: dist to normal between axis and point is %f\n",dist/mmtin);
	}
	if( pt_radsq - (radius*radius) < tol.dist_sq )
		return( 1 );
	else
		return( 0 );
}



/* 			M K _ C Y L A D D M E M B E R
 *
 * For the cylinder given by 'name1', determine whether it has any
 * volume mode subtractions from it by looking at the subtraction list
 * for this component number. If we find that this cylinder is one
 * of the subtracting cylinders inside, don't do anything. Otherwise,
 * add this cylinder onto the region list along with the subtractions
 * of cylinders determined from the subtraction list. Assume that the
 * subtracted solids will be eventually be made.
 */
void
mk_cyladdmember(char *name1, struct wmember *head, struct subtract_list *slist, int mirflag)
{

	char			tmpname[16];
	int			cc,solnum;
	struct subtract_list	*hold;

	if( !slist ) {
		(void)mk_addmember( name1, &(head->l), NULL, WMOP_UNION );
		return;
	}

	sscanf( name1,"%*[^0-9]%d%*[^0-9]%d", &cc, &solnum );

	/* check to see whether this solid shows up in the subtract 
	 * list as a volume mode solid being subtracted
	 */
	hold = slist;
	while( slist->insolid != solnum && slist->next )
		slist = slist->next;
	if( slist->insolid == solnum )
		return;

	(void)mk_addmember( name1, &(head->l), NULL, WMOP_UNION );

	for( slist = hold; slist; slist = slist->next ) {
		if( slist->outsolid == solnum ){
			sprintf(tmpname,"c.%.4d.s%.2d",cc,slist->insolid );
			(void)mk_addmember( tmpname, &(head->l), NULL, WMOP_SUBTRACT );
		}
	}
}




/*			G E T _ S U B T R A C T
 *
 * Make up the list of subtracted volume mode solids for this group of
 * cylinders. Go through the cylinder list and, for each solid, see whether 
 * any of the other solid records following qualify as volume mode subtracted
 * solids. Record the number of the outside cylinder and the number of
 * the inside cylinder in the subtraction list, along with the mirror
 * flag value of the inside solid (for naming convention reasons).
 *
 * Plate mode for a cylinder disqualifies it for any role as a volume mode
 * subtracting cylinder.
 */
struct subtract_list *
get_subtract(int cnt)
{
	static struct subtract_list	*slist = NULL;
	struct subtract_list		*next,*add_to_list(struct subtract_list *slist, int outsolid, int insolid, int inmirror);
	int i,j;

	/* free up memory for slist, if any */
	for( next=slist ; next; ){
		slist = next;
		next = slist->next;
		rt_free( (char *)slist , "get_subtract: slist" );
	}

	slist = (struct subtract_list *)NULL;
	for( i = 0; i < cnt; i += 3 ) {
		for( j = i + 3; j < cnt ; j += 3 ) {
			if( in[j].surf_mode == '-' )
				continue;
			if( inside_cyl(i,j) )
				slist = add_to_list(slist,(i+3)/3,(j+3)/3,in[j].mirror);
		}
	}
	return( slist );
}


/*			A D D _ T O _ L I S T
 *
 * Add the inside,outside cylinder numbers to the subtraction list slist.
 */
struct subtract_list *
add_to_list(struct subtract_list *slist, int outsolid, int insolid, int inmirror)
{

	if( slist == NULL ){
		slist = (struct subtract_list *)rt_malloc(sizeof(struct subtract_list) , "add_to_list: slist" );
		slist->outsolid = outsolid;
		slist->insolid = insolid;
		slist->inmirror = inmirror;
		slist->next = (struct subtract_list *)NULL;
	}
	else
		slist->next = add_to_list(slist->next,outsolid,insolid,inmirror);

	return( slist );
}
@


11.35
log
@change conf.h to a wrapped config.h
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/patch/patch-g.c,v 11.34 2004/04/05 07:38:39 morrison Exp $ (BRL)";
@


11.34
log
@merge of ansi-6-0-branch into HEAD
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d41 5
a45 1
#include "conf.h"
@


11.33
log
@update copyright to include span through 2003
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/patch/patch-g.c,v 11.32 2002/08/20 17:08:32 jra Exp $ (BRL)";
d64 11
a74 11
void	proc_plate();
void	proc_label();
void	proc_triangle();
void	proc_wedge();
void	proc_sphere();
void	proc_box();
void	proc_cylin();
void	proc_rod();
void	set_color();
void	mk_cyladdmember();
void	proc_donut();
d108 1
a108 3
main(argc,argv)
int	argc;
char	*argv[];
d634 1
a634 6
make_inside_trc( base, top, rbase, rtop, new_base, new_top, new_rbase, new_rtop, do_base, do_top, do_sides, thick )
point_t base, top, new_base, new_top;
fastf_t rbase, rtop;
fastf_t *new_rbase, *new_rtop;
int do_base, do_top, do_sides;
fastf_t thick;
d734 1
a734 3
proc_sname(shflg,mrflg,cnt,ctflg)
char shflg,mrflg,ctflg;
int  cnt;
d798 1
a798 6
nmg_patch_coplanar_face_merge( s , face_count , p_faces , tol , simplify )
struct shell		*s;
int			*face_count;
struct patch_faces	*p_faces;
struct rt_tol		*tol;
int			simplify;
d950 1
a950 8
Build_solid( l, name, mirror_name, plate_mode, centroid, thickness, pl1, tol )
int l;
char *name,*mirror_name;
int plate_mode;
point_t centroid;
fastf_t thickness;
plane_t pl1;
struct rt_tol *tol;
d1679 1
a1679 3
proc_region(name1)
char *name1;

d1743 1
a1743 2
proc_triangle(cnt)
int cnt;
d1871 1
a1871 4
Get_ave_plane( pl, num_pts, x, y, z )
plane_t pl;
int num_pts;
fastf_t *x,*y,*z;
d2015 1
a2015 2
proc_plate(cnt)
int cnt;
d2210 1
a2210 2
proc_wedge(cnt)
int cnt;
d2460 1
a2460 2
proc_sphere(cnt)
int cnt;
d2586 1
a2586 2
proc_box(cnt)
int cnt;
d2795 1
a2795 2
proc_donut(cnt)
int cnt;
d3179 1
a3179 2
proc_cylin(cnt)
int cnt;
d3189 1
a3189 1
	struct subtract_list *slist,*get_subtract();
d3822 1
a3822 2
proc_rod(cnt)
int cnt;
d3988 1
a3988 5
pnorms( norms, verts, centroid, npts, inv )
fastf_t	norms[5][3];
fastf_t	verts[5][3];
point_t	centroid;
int	npts;
d4033 1
a4033 2
proc_label(labelfile)
char *labelfile;
d4084 1
a4084 2
set_color( color )
int color;
d4186 1
a4186 2
inside_cyl(i,j)
int i,j;
d4271 1
a4271 5
mk_cyladdmember(name1,head,slist,mirflag)
char *name1;
struct wmember *head;
struct subtract_list *slist;
int mirflag;
d4320 1
a4320 2
get_subtract( cnt )
int cnt;
d4323 1
a4323 1
	struct subtract_list		*next,*add_to_list();
d4351 1
a4351 3
add_to_list( slist,outsolid,insolid,inmirror )
struct subtract_list *slist;
int outsolid,insolid,inmirror;
@


11.32
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d34 1
a34 1
 *	This software is Copyright (C) 1989 by the United States Army.
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/patch/patch-g.c,v 11.30 2002/05/17 12:56:05 morrison Exp $ (BRL)";
@


11.32.4.1
log
@sync to HEAD...
@
text
@d34 1
a34 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/patch/patch-g.c,v 11.33 2004/02/02 17:39:37 morrison Exp $ (BRL)";
@


11.32.10.1
log
@merge from HEAD
@
text
@d34 1
a34 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/patch/patch-g.c,v 11.33 2004/02/02 17:39:37 morrison Exp $ (BRL)";
@


11.32.10.2
log
@merge from head
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/patch/patch-g.c,v 11.32.10.1 2004/02/12 19:51:31 erikg Exp $ (BRL)";
@


11.32.2.1
log
@Initial ANSIfication
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/patch/patch-g.c,v 11.32 2002/08/20 17:08:32 jra Exp $ (BRL)";
d64 11
a74 11
void	proc_plate(int cnt);
void	proc_label(char *labelfile);
void	proc_triangle(int cnt);
void	proc_wedge(int cnt);
void	proc_sphere(int cnt);
void	proc_box(int cnt);
void	proc_cylin(int cnt);
void	proc_rod(int cnt);
void	set_color(int color);
void	mk_cyladdmember(char *name1, struct wmember *head, struct subtract_list *slist, int mirflag);
void	proc_donut(int cnt);
d108 3
a110 1
main(int argc, char **argv)
d636 6
a641 1
make_inside_trc(fastf_t *base, fastf_t *top, fastf_t rbase, fastf_t rtop, fastf_t *new_base, fastf_t *new_top, fastf_t *new_rbase, fastf_t *new_rtop, int do_base, int do_top, int do_sides, fastf_t thick)
d741 3
a743 1
proc_sname(char shflg, char mrflg, int cnt, char ctflg)
d807 6
a812 1
nmg_patch_coplanar_face_merge(struct shell *s, int *face_count, struct patch_faces *p_faces, struct bn_tol *tol, int simplify)
d964 8
a971 1
Build_solid(int l, char *name, char *mirror_name, int plate_mode, fastf_t *centroid, fastf_t thickness, fastf_t *pl1, struct bn_tol *tol)
d1700 3
a1702 1
proc_region(char *name1)
d1766 2
a1767 1
proc_triangle(int cnt)
d1895 4
a1898 1
Get_ave_plane(fastf_t *pl, int num_pts, fastf_t *x, fastf_t *y, fastf_t *z)
d2042 2
a2043 1
proc_plate(int cnt)
d2238 2
a2239 1
proc_wedge(int cnt)
d2489 2
a2490 1
proc_sphere(int cnt)
d2616 2
a2617 1
proc_box(int cnt)
d2826 2
a2827 1
proc_donut(int cnt)
d3211 2
a3212 1
proc_cylin(int cnt)
d3222 1
a3222 1
	struct subtract_list *slist,*get_subtract(int cnt);
d3855 2
a3856 1
proc_rod(int cnt)
d4022 5
a4026 1
pnorms(fastf_t (*norms)[3], fastf_t (*verts)[3], fastf_t *centroid, int npts, int inv)
d4071 2
a4072 1
proc_label(char *labelfile)
d4123 2
a4124 1
set_color(int color)
d4226 2
a4227 1
inside_cyl(int i, int j)
d4312 5
a4316 1
mk_cyladdmember(char *name1, struct wmember *head, struct subtract_list *slist, int mirflag)
d4365 2
a4366 1
get_subtract(int cnt)
d4369 1
a4369 1
	struct subtract_list		*next,*add_to_list(struct subtract_list *slist, int outsolid, int insolid, int inmirror);
d4397 3
a4399 1
add_to_list(struct subtract_list *slist, int outsolid, int insolid, int inmirror)
@


11.32.2.2
log
@sync branch with HEAD
@
text
@d34 1
a34 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.31
log
@Converted from K&R to ANSI C - RFH
@
text
@d64 11
a74 11
void	proc_plate(int cnt);
void	proc_label(char *labelfile);
void	proc_triangle(int cnt);
void	proc_wedge(int cnt);
void	proc_sphere(int cnt);
void	proc_box(int cnt);
void	proc_cylin(int cnt);
void	proc_rod(int cnt);
void	set_color(int color);
void	mk_cyladdmember(char *name1, struct wmember *head, struct subtract_list *slist, int mirflag);
void	proc_donut(int cnt);
d108 3
a110 1
main(int argc, char **argv)
d636 6
a641 1
make_inside_trc(fastf_t *base, fastf_t *top, fastf_t rbase, fastf_t rtop, fastf_t *new_base, fastf_t *new_top, fastf_t *new_rbase, fastf_t *new_rtop, int do_base, int do_top, int do_sides, fastf_t thick)
d741 3
a743 1
proc_sname(char shflg, char mrflg, int cnt, char ctflg)
d807 6
a812 1
nmg_patch_coplanar_face_merge(struct shell *s, int *face_count, struct patch_faces *p_faces, struct bn_tol *tol, int simplify)
d964 8
a971 1
Build_solid(int l, char *name, char *mirror_name, int plate_mode, fastf_t *centroid, fastf_t thickness, fastf_t *pl1, struct bn_tol *tol)
d1700 3
a1702 1
proc_region(char *name1)
d1766 2
a1767 1
proc_triangle(int cnt)
d1895 4
a1898 1
Get_ave_plane(fastf_t *pl, int num_pts, fastf_t *x, fastf_t *y, fastf_t *z)
d2042 2
a2043 1
proc_plate(int cnt)
d2238 2
a2239 1
proc_wedge(int cnt)
d2489 2
a2490 1
proc_sphere(int cnt)
d2616 2
a2617 1
proc_box(int cnt)
d2826 2
a2827 1
proc_donut(int cnt)
d3211 2
a3212 1
proc_cylin(int cnt)
d3222 1
a3222 1
	struct subtract_list *slist,*get_subtract(int cnt);
d3855 2
a3856 1
proc_rod(int cnt)
d4022 5
a4026 1
pnorms(fastf_t (*norms)[3], fastf_t (*verts)[3], fastf_t *centroid, int npts, int inv)
d4071 2
a4072 1
proc_label(char *labelfile)
d4123 2
a4124 1
set_color(int color)
d4226 2
a4227 1
inside_cyl(int i, int j)
d4312 5
a4316 1
mk_cyladdmember(char *name1, struct wmember *head, struct subtract_list *slist, int mirflag)
d4365 2
a4366 1
get_subtract(int cnt)
d4369 1
a4369 1
	struct subtract_list		*next,*add_to_list(struct subtract_list *slist, int outsolid, int insolid, int inmirror);
d4397 3
a4399 1
add_to_list(struct subtract_list *slist, int outsolid, int insolid, int inmirror)
@


11.30
log
@added matrix parameter to mk_addmember()
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/patch/patch-g.c,v 11.29 2001/08/10 17:51:48 jra Exp $ (BRL)";
d64 11
a74 11
void	proc_plate();
void	proc_label();
void	proc_triangle();
void	proc_wedge();
void	proc_sphere();
void	proc_box();
void	proc_cylin();
void	proc_rod();
void	set_color();
void	mk_cyladdmember();
void	proc_donut();
d108 1
a108 3
main(argc,argv)
int	argc;
char	*argv[];
d634 1
a634 6
make_inside_trc( base, top, rbase, rtop, new_base, new_top, new_rbase, new_rtop, do_base, do_top, do_sides, thick )
point_t base, top, new_base, new_top;
fastf_t rbase, rtop;
fastf_t *new_rbase, *new_rtop;
int do_base, do_top, do_sides;
fastf_t thick;
d734 1
a734 3
proc_sname(shflg,mrflg,cnt,ctflg)
char shflg,mrflg,ctflg;
int  cnt;
d798 1
a798 6
nmg_patch_coplanar_face_merge( s , face_count , p_faces , tol , simplify )
struct shell		*s;
int			*face_count;
struct patch_faces	*p_faces;
struct rt_tol		*tol;
int			simplify;
d950 1
a950 8
Build_solid( l, name, mirror_name, plate_mode, centroid, thickness, pl1, tol )
int l;
char *name,*mirror_name;
int plate_mode;
point_t centroid;
fastf_t thickness;
plane_t pl1;
struct rt_tol *tol;
d1679 1
a1679 3
proc_region(name1)
char *name1;

d1743 1
a1743 2
proc_triangle(cnt)
int cnt;
d1871 1
a1871 4
Get_ave_plane( pl, num_pts, x, y, z )
plane_t pl;
int num_pts;
fastf_t *x,*y,*z;
d2015 1
a2015 2
proc_plate(cnt)
int cnt;
d2210 1
a2210 2
proc_wedge(cnt)
int cnt;
d2460 1
a2460 2
proc_sphere(cnt)
int cnt;
d2586 1
a2586 2
proc_box(cnt)
int cnt;
d2795 1
a2795 2
proc_donut(cnt)
int cnt;
d3179 1
a3179 2
proc_cylin(cnt)
int cnt;
d3189 1
a3189 1
	struct subtract_list *slist,*get_subtract();
d3822 1
a3822 2
proc_rod(cnt)
int cnt;
d3988 1
a3988 5
pnorms( norms, verts, centroid, npts, inv )
fastf_t	norms[5][3];
fastf_t	verts[5][3];
point_t	centroid;
int	npts;
d4033 1
a4033 2
proc_label(labelfile)
char *labelfile;
d4084 1
a4084 2
set_color( color )
int color;
d4186 1
a4186 2
inside_cyl(i,j)
int i,j;
d4271 1
a4271 5
mk_cyladdmember(name1,head,slist,mirflag)
char *name1;
struct wmember *head;
struct subtract_list *slist;
int mirflag;
d4320 1
a4320 2
get_subtract( cnt )
int cnt;
d4323 1
a4323 1
	struct subtract_list		*next,*add_to_list();
d4351 1
a4351 3
add_to_list( slist,outsolid,insolid,inmirror )
struct subtract_list *slist;
int outsolid,insolid,inmirror;
@


11.29
log
@lint
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/patch/patch-g.c,v 11.28 2001/05/17 20:05:51 morrison Exp $ (BRL)";
d516 1
a516 1
				(void) mk_addmember(name,&heade.l,WMOP_UNION);
d1050 1
a1050 1
				mk_addmember( tmp_name, &tmp_head.l, WMOP_UNION );
d1057 1
a1057 1
					mk_addmember( tmp_name, &mir_head.l, WMOP_UNION );
d1753 1
a1753 1
		(void) mk_addmember(cname,&heada.l,WMOP_UNION);
d1756 1
a1756 1
		(void) mk_addmember(cname,&headb.l,WMOP_UNION);
d1873 1
a1873 1
		(void) mk_addmember(name,&head.l,WMOP_UNION);
d1877 1
a1877 1
			(void) mk_addmember(mirror_name,&head.l,WMOP_UNION);
d2208 1
a2208 1
				(void) mk_addmember(name,&head.l,WMOP_UNION);
d2212 1
a2212 1
					(void) mk_addmember(mirror_name,&head.l,WMOP_UNION);
d2290 1
a2290 1
		(void) mk_addmember(name,&head.l,WMOP_UNION);
d2356 1
a2356 1
				(void)mk_addmember(name,&head.l,WMOP_SUBTRACT);
d2360 1
a2360 1
				(void)mk_addmember(name,&headf.l,WMOP_UNION);
d2402 1
a2402 1
		(void) mk_addmember(name,&head.l,WMOP_UNION);
d2467 1
a2467 1
				(void)mk_addmember(name,&head.l,WMOP_SUBTRACT);
d2471 1
a2471 1
				(void)mk_addmember(name,&headf.l,WMOP_UNION);
d2524 1
a2524 1
			(void) mk_addmember(name,&head.l,WMOP_UNION);
d2541 1
a2541 1
					(void)mk_addmember(name, &head.l,WMOP_SUBTRACT);
d2545 1
a2545 1
					(void)mk_addmember(name, &headf.l,WMOP_UNION);
d2577 1
a2577 1
			(void) mk_addmember(name,&head.l,WMOP_UNION);
d2589 1
a2589 1
					(void)mk_addmember(name, &head.l,WMOP_SUBTRACT);
d2593 1
a2593 1
					(void)mk_addmember(name, &headf.l,WMOP_UNION);
d2664 1
a2664 1
		(void) mk_addmember(name,&head.l,WMOP_UNION);
d2711 1
a2711 1
				(void)mk_addmember(name,&head.l,WMOP_SUBTRACT);
d2715 1
a2715 1
				(void)mk_addmember(name,&headf.l,WMOP_UNION);
d2755 1
a2755 1
		(void) mk_addmember(name,&head.l,WMOP_UNION);
d2802 1
a2802 1
				(void)mk_addmember(name,&head.l,WMOP_SUBTRACT);
d2806 1
a2806 1
				(void)mk_addmember(name,&headf.l,WMOP_UNION);
d2991 6
a2996 6
					(void)mk_addmember( scratch_name1, &donut_head.l, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head.l, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name3, &donut_head.l, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head.l, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name4, &donut_head.l, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head.l, WMOP_SUBTRACT );
d3001 4
a3004 4
					(void)mk_addmember( scratch_name1, &donut_head.l, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head.l, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name3, &donut_head.l, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name4, &donut_head.l, WMOP_SUBTRACT );
d3009 5
a3013 5
					(void)mk_addmember( scratch_name1, &donut_head.l, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head.l, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name4, &donut_head.l, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name3, &donut_head.l, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head.l, WMOP_SUBTRACT );
d3018 5
a3022 5
					(void)mk_addmember( scratch_name1, &donut_head.l, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head.l, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name3, &donut_head.l, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name4, &donut_head.l, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head.l, WMOP_SUBTRACT );
d3030 4
a3033 4
					(void)mk_addmember( scratch_name1, &donut_head.l, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head.l, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name3, &donut_head.l, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head.l, WMOP_SUBTRACT );
d3037 3
a3039 3
					(void)mk_addmember( scratch_name1, &donut_head.l, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head.l, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name3, &donut_head.l, WMOP_SUBTRACT );
d3047 4
a3050 4
					(void)mk_addmember( scratch_name1, &donut_head.l, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head.l, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name4, &donut_head.l, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head.l, WMOP_SUBTRACT );
d3054 3
a3056 3
					(void)mk_addmember( scratch_name1, &donut_head.l, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head.l, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name4, &donut_head.l, WMOP_SUBTRACT );
d3062 2
a3063 2
				(void)mk_addmember( scratch_name1, &donut_head.l, WMOP_UNION );
				(void)mk_addmember( scratch_name2, &donut_head.l, WMOP_SUBTRACT );
d3069 1
a3069 1
				(void)mk_addmember( name, &head.l, WMOP_UNION );
d3094 2
a3095 2
				(void)mk_addmember( scratch_name1, &donut_head.l, WMOP_UNION );
				(void)mk_addmember(scratch_name1_in,&donut_head.l,WMOP_SUBTRACT);
d3107 2
a3108 2
				(void)mk_addmember( scratch_name2, &donut_head.l, WMOP_UNION );
				(void)mk_addmember(scratch_name2_in,&donut_head.l,WMOP_SUBTRACT);
d3128 2
a3129 2
					(void)mk_addmember( scratch_name4, &donut_head.l, WMOP_UNION );
					(void)mk_addmember(scratch_name4_in,&donut_head.l,WMOP_SUBTRACT);
d3142 3
a3144 3
					(void)mk_addmember( scratch_name1, &donut_head.l, WMOP_UNION );
					(void)mk_addmember(scratch_name4_in,&donut_head.l,WMOP_SUBTRACT);
					(void)mk_addmember(scratch_name2,&donut_head.l,WMOP_SUBTRACT);
d3164 2
a3165 2
					(void)mk_addmember( scratch_name3, &donut_head.l, WMOP_UNION );
					(void)mk_addmember(scratch_name3_in,&donut_head.l,WMOP_SUBTRACT);
d3178 3
a3180 3
					(void)mk_addmember( scratch_name1, &donut_head.l, WMOP_UNION );
					(void)mk_addmember(scratch_name3_in,&donut_head.l,WMOP_SUBTRACT);
					(void)mk_addmember(scratch_name2,&donut_head.l,WMOP_SUBTRACT);
d3187 1
a3187 1
				(void)mk_addmember( name, &head.l, WMOP_UNION );
d3309 1
a3309 1
						(void)mk_addmember(name,&headf.l,WMOP_UNION);
d3323 1
a3323 1
						(void)mk_addmember(name,&head.l,WMOP_SUBTRACT);
d3338 1
a3338 1
						(void)mk_addmember(name,&head.l,WMOP_SUBTRACT);
d3343 1
a3343 1
						(void)mk_addmember(name,&head.l,WMOP_SUBTRACT);
d3367 1
a3367 1
						(void)mk_addmember(name,&headf.l,WMOP_UNION);
d3374 1
a3374 1
							(void)mk_addmember(name,&headf.l,WMOP_UNION);
d3380 1
a3380 1
							(void)mk_addmember(name,&head.l,WMOP_SUBTRACT);
d3389 1
a3389 1
							(void)mk_addmember(name,&headf.l,WMOP_UNION);
d3395 1
a3395 1
							(void)mk_addmember(name,&head.l,WMOP_SUBTRACT);
d3401 1
a3401 1
						(void)mk_addmember(name,&head.l,WMOP_SUBTRACT);
d3424 1
a3424 1
						(void)mk_addmember(name,&headf.l,WMOP_UNION);
d3431 1
a3431 1
							(void)mk_addmember(name,&headf.l,WMOP_UNION);
d3437 1
a3437 1
							(void)mk_addmember(name,&head.l,WMOP_SUBTRACT);
d3446 1
a3446 1
							(void)mk_addmember(name,&headf.l,WMOP_UNION);
d3452 1
a3452 1
							(void)mk_addmember(name,&head.l,WMOP_SUBTRACT);
d3458 1
a3458 1
						(void)mk_addmember(name,&head.l,WMOP_SUBTRACT);
d3487 1
a3487 1
						(void)mk_addmember(name,&headf.l,WMOP_UNION);
d3494 1
a3494 1
							(void)mk_addmember(name,&headf.l,WMOP_UNION);
d3500 1
a3500 1
							(void)mk_addmember(name,&head.l,WMOP_SUBTRACT);
d3511 1
a3511 1
							(void)mk_addmember(name,&headf.l,WMOP_UNION);
d3518 1
a3518 1
							(void)mk_addmember(name,&head.l,WMOP_SUBTRACT);
d3524 1
a3524 1
						(void)mk_addmember(name,&head.l,WMOP_SUBTRACT);
d3610 1
a3610 1
						(void)mk_addmember(name,&headf.l,WMOP_UNION);
d3624 1
a3624 1
						(void)mk_addmember(name,&head.l,WMOP_SUBTRACT);
d3639 1
a3639 1
						(void)mk_addmember(name,&head.l,WMOP_SUBTRACT);
d3644 1
a3644 1
						(void)mk_addmember(name,&head.l,WMOP_SUBTRACT);
d3668 1
a3668 1
						(void)mk_addmember(name,&headf.l,WMOP_UNION);
d3675 1
a3675 1
							(void)mk_addmember(name,&headf.l,WMOP_UNION);
d3681 1
a3681 1
							(void)mk_addmember(name,&head.l,WMOP_SUBTRACT);
d3690 1
a3690 1
							(void)mk_addmember(name,&headf.l,WMOP_UNION);
d3696 1
a3696 1
							(void)mk_addmember(name,&head.l,WMOP_SUBTRACT);
d3702 1
a3702 1
						(void)mk_addmember(name,&head.l,WMOP_SUBTRACT);
d3725 1
a3725 1
						(void)mk_addmember(name,&headf.l,WMOP_UNION);
d3732 1
a3732 1
							(void)mk_addmember(name,&headf.l,WMOP_UNION);
d3738 1
a3738 1
							(void)mk_addmember(name,&head.l,WMOP_SUBTRACT);
d3747 1
a3747 1
							(void)mk_addmember(name,&headf.l,WMOP_UNION);
d3753 1
a3753 1
							(void)mk_addmember(name,&head.l,WMOP_SUBTRACT);
d3759 1
a3759 1
						(void)mk_addmember(name,&head.l,WMOP_SUBTRACT);
d3788 1
a3788 1
						(void)mk_addmember(name,&headf.l,WMOP_UNION);
d3795 1
a3795 1
							(void)mk_addmember(name,&headf.l,WMOP_UNION);
d3801 1
a3801 1
							(void)mk_addmember(name,&head.l,WMOP_SUBTRACT);
d3812 1
a3812 1
							(void)mk_addmember(name,&headf.l,WMOP_UNION);
d3819 1
a3819 1
							(void)mk_addmember(name,&head.l,WMOP_SUBTRACT);
d3825 1
a3825 1
						(void)mk_addmember(name,&head.l,WMOP_SUBTRACT);
d3955 1
a3955 1
			(void)mk_addmember(name,&head.l,WMOP_SUBTRACT);
d3957 1
a3957 1
			(void)mk_addmember(name,&head.l,WMOP_UNION);
d3959 1
a3959 1
			(void) mk_addmember(name,&head.l,WMOP_UNION);
d4001 1
a4001 1
			(void)mk_addmember(name,&head.l,WMOP_SUBTRACT);
d4003 1
a4003 1
			(void)mk_addmember(name,&head.l,WMOP_UNION);
d4006 1
a4006 1
			(void) mk_addmember(name,&head.l,WMOP_UNION);
d4097 1
a4097 1
			(void) mk_addmember(gname,&headd.l,WMOP_UNION);
d4102 1
a4102 1
			(void) mk_addmember(mgname,&headd.l,WMOP_UNION);
d4108 1
a4108 1
		(void) mk_addmember(gname,&heade.l,WMOP_UNION);
d4324 1
a4324 1
		(void)mk_addmember( name1, &(head->l), WMOP_UNION );
d4339 1
a4339 1
	(void)mk_addmember( name1, &(head->l), WMOP_UNION );
d4344 1
a4344 1
			(void)mk_addmember( tmpname, &(head->l), WMOP_SUBTRACT );
@


11.28
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/patch/patch-g.c,v 11.27 2001/04/05 19:36:01 morrison Exp $ (BRL)";
d182 1
a182 1
				sscanf( optarg , "%x" , &rt_g.debug );
d187 1
a187 1
				sscanf( optarg , "%x" , &rt_g.NMG_debug );
d1106 1
a1106 1
			int found_verts;
d2249 1
a2249 1
	char	shflg,mrflg,ctflg;
d2495 1
a2495 1
	char    shflg,mrflg,ctflg;
d2624 1
a2624 1
	char    shflg,mrflg,ctflg;
d3224 1
a3224 1
	char    shflg,mrflg,ctflg;
d3864 1
a3864 1
	char    shflg,mrflg,ctflg;
@


11.27
log
@updated SIGNED to signed
updated CONST to const
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/patch/patch-g.c,v 11.26 2001/04/02 21:38:27 morrison Exp $ (BRL)";
d278 1
a278 1
	if( rt_g.debug )
d280 1
a280 1
		rt_printb( "librt rt_g.debug", rt_g.debug, DEBUG_FORMAT );
d446 1
a446 1
                    	if( rt_g.debug&DEBUG_MEM_FULL )
d525 1
a525 1
                    	if( rt_g.debug&DEBUG_MEM_FULL )
@


11.26
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/patch/patch-g.c,v 11.25 2000/08/24 04:22:09 mike Exp $ (BRL)";
d1580 1
a1580 1
	if( nmg_open_shells_connect( s , is , (CONST long **)copy_tbl , tol ) )
@


11.25
log
@
mk_addmember
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/patch/patch-g.c,v 11.24 2000/07/20 19:15:47 mike Exp $ (BRL)";
d322 1
a322 1
	mat_idn(m);
d1908 1
a1908 1
	mat_zero( matrix );
@


11.24
log
@
Changed for new libwdb interface.
Fixed some lint.
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/patch/patch-g.c,v 11.23 2000/03/31 03:13:27 mike Exp $ (BRL)";
d102 2
d516 1
a516 1
				(void) mk_addmember(name,&heade,WMOP_UNION);
d1050 1
a1050 1
				mk_addmember( tmp_name, &tmp_head, WMOP_UNION );
d1057 1
a1057 1
					mk_addmember( tmp_name, &mir_head, WMOP_UNION );
d1753 1
a1753 1
		(void) mk_addmember(cname,&heada,WMOP_UNION);
d1756 1
a1756 1
		(void) mk_addmember(cname,&headb,WMOP_UNION);
d1873 1
a1873 1
		(void) mk_addmember(name,&head,WMOP_UNION);
d1877 1
a1877 1
			(void) mk_addmember(mirror_name,&head,WMOP_UNION);
d2208 1
a2208 1
				(void) mk_addmember(name,&head,WMOP_UNION);
d2212 1
a2212 1
					(void) mk_addmember(mirror_name,&head,WMOP_UNION);
d2290 1
a2290 1
		(void) mk_addmember(name,&head,WMOP_UNION);
d2356 1
a2356 1
				(void)mk_addmember(name,&head,WMOP_SUBTRACT);
d2360 1
a2360 1
				(void)mk_addmember(name,&headf,WMOP_UNION);
d2402 1
a2402 1
		(void) mk_addmember(name,&head,WMOP_UNION);
d2467 1
a2467 1
				(void)mk_addmember(name,&head,WMOP_SUBTRACT);
d2471 1
a2471 1
				(void)mk_addmember(name,&headf,WMOP_UNION);
d2524 1
a2524 1
			(void) mk_addmember(name,&head,WMOP_UNION);
d2541 1
a2541 1
					(void)mk_addmember(name, &head,WMOP_SUBTRACT);
d2545 1
a2545 1
					(void)mk_addmember(name, &headf,WMOP_UNION);
d2577 1
a2577 1
			(void) mk_addmember(name,&head,WMOP_UNION);
d2589 1
a2589 1
					(void)mk_addmember(name, &head,WMOP_SUBTRACT);
d2593 1
a2593 1
					(void)mk_addmember(name, &headf,WMOP_UNION);
d2664 1
a2664 1
		(void) mk_addmember(name,&head,WMOP_UNION);
d2711 1
a2711 1
				(void)mk_addmember(name,&head,WMOP_SUBTRACT);
d2715 1
a2715 1
				(void)mk_addmember(name,&headf,WMOP_UNION);
d2755 1
a2755 1
		(void) mk_addmember(name,&head,WMOP_UNION);
d2802 1
a2802 1
				(void)mk_addmember(name,&head,WMOP_SUBTRACT);
d2806 1
a2806 1
				(void)mk_addmember(name,&headf,WMOP_UNION);
d2991 6
a2996 6
					(void)mk_addmember( scratch_name1, &donut_head, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name3, &donut_head, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name4, &donut_head, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head, WMOP_SUBTRACT );
d3001 4
a3004 4
					(void)mk_addmember( scratch_name1, &donut_head, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name3, &donut_head, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name4, &donut_head, WMOP_SUBTRACT );
d3009 5
a3013 5
					(void)mk_addmember( scratch_name1, &donut_head, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name4, &donut_head, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name3, &donut_head, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head, WMOP_SUBTRACT );
d3018 5
a3022 5
					(void)mk_addmember( scratch_name1, &donut_head, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name3, &donut_head, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name4, &donut_head, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head, WMOP_SUBTRACT );
d3030 4
a3033 4
					(void)mk_addmember( scratch_name1, &donut_head, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name3, &donut_head, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head, WMOP_SUBTRACT );
d3037 3
a3039 3
					(void)mk_addmember( scratch_name1, &donut_head, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name3, &donut_head, WMOP_SUBTRACT );
d3047 4
a3050 4
					(void)mk_addmember( scratch_name1, &donut_head, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name4, &donut_head, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head, WMOP_SUBTRACT );
d3054 3
a3056 3
					(void)mk_addmember( scratch_name1, &donut_head, WMOP_UNION );
					(void)mk_addmember( scratch_name2, &donut_head, WMOP_SUBTRACT );
					(void)mk_addmember( scratch_name4, &donut_head, WMOP_SUBTRACT );
d3062 2
a3063 2
				(void)mk_addmember( scratch_name1, &donut_head, WMOP_UNION );
				(void)mk_addmember( scratch_name2, &donut_head, WMOP_SUBTRACT );
d3069 1
a3069 1
				(void)mk_addmember( name, &head, WMOP_UNION );
d3094 2
a3095 2
				(void)mk_addmember( scratch_name1, &donut_head, WMOP_UNION );
				(void)mk_addmember(scratch_name1_in,&donut_head,WMOP_SUBTRACT);
d3107 2
a3108 2
				(void)mk_addmember( scratch_name2, &donut_head, WMOP_UNION );
				(void)mk_addmember(scratch_name2_in,&donut_head,WMOP_SUBTRACT);
d3128 2
a3129 2
					(void)mk_addmember( scratch_name4, &donut_head, WMOP_UNION );
					(void)mk_addmember(scratch_name4_in,&donut_head,WMOP_SUBTRACT);
d3142 3
a3144 3
					(void)mk_addmember( scratch_name1, &donut_head, WMOP_UNION );
					(void)mk_addmember(scratch_name4_in,&donut_head,WMOP_SUBTRACT);
					(void)mk_addmember(scratch_name2,&donut_head,WMOP_SUBTRACT);
d3164 2
a3165 2
					(void)mk_addmember( scratch_name3, &donut_head, WMOP_UNION );
					(void)mk_addmember(scratch_name3_in,&donut_head,WMOP_SUBTRACT);
d3178 3
a3180 3
					(void)mk_addmember( scratch_name1, &donut_head, WMOP_UNION );
					(void)mk_addmember(scratch_name3_in,&donut_head,WMOP_SUBTRACT);
					(void)mk_addmember(scratch_name2,&donut_head,WMOP_SUBTRACT);
d3187 1
a3187 1
				(void)mk_addmember( name, &head, WMOP_UNION );
d3309 1
a3309 1
						(void)mk_addmember(name,&headf,WMOP_UNION);
d3323 1
a3323 1
						(void)mk_addmember(name,&head,WMOP_SUBTRACT);
d3338 1
a3338 1
						(void)mk_addmember(name,&head,WMOP_SUBTRACT);
d3343 1
a3343 1
						(void)mk_addmember(name,&head,WMOP_SUBTRACT);
d3367 1
a3367 1
						(void)mk_addmember(name,&headf,WMOP_UNION);
d3374 1
a3374 1
							(void)mk_addmember(name,&headf,WMOP_UNION);
d3380 1
a3380 1
							(void)mk_addmember(name,&head,WMOP_SUBTRACT);
d3389 1
a3389 1
							(void)mk_addmember(name,&headf,WMOP_UNION);
d3395 1
a3395 1
							(void)mk_addmember(name,&head,WMOP_SUBTRACT);
d3401 1
a3401 1
						(void)mk_addmember(name,&head,WMOP_SUBTRACT);
d3424 1
a3424 1
						(void)mk_addmember(name,&headf,WMOP_UNION);
d3431 1
a3431 1
							(void)mk_addmember(name,&headf,WMOP_UNION);
d3437 1
a3437 1
							(void)mk_addmember(name,&head,WMOP_SUBTRACT);
d3446 1
a3446 1
							(void)mk_addmember(name,&headf,WMOP_UNION);
d3452 1
a3452 1
							(void)mk_addmember(name,&head,WMOP_SUBTRACT);
d3458 1
a3458 1
						(void)mk_addmember(name,&head,WMOP_SUBTRACT);
d3487 1
a3487 1
						(void)mk_addmember(name,&headf,WMOP_UNION);
d3494 1
a3494 1
							(void)mk_addmember(name,&headf,WMOP_UNION);
d3500 1
a3500 1
							(void)mk_addmember(name,&head,WMOP_SUBTRACT);
d3511 1
a3511 1
							(void)mk_addmember(name,&headf,WMOP_UNION);
d3518 1
a3518 1
							(void)mk_addmember(name,&head,WMOP_SUBTRACT);
d3524 1
a3524 1
						(void)mk_addmember(name,&head,WMOP_SUBTRACT);
d3610 1
a3610 1
						(void)mk_addmember(name,&headf,WMOP_UNION);
d3624 1
a3624 1
						(void)mk_addmember(name,&head,WMOP_SUBTRACT);
d3639 1
a3639 1
						(void)mk_addmember(name,&head,WMOP_SUBTRACT);
d3644 1
a3644 1
						(void)mk_addmember(name,&head,WMOP_SUBTRACT);
d3668 1
a3668 1
						(void)mk_addmember(name,&headf,WMOP_UNION);
d3675 1
a3675 1
							(void)mk_addmember(name,&headf,WMOP_UNION);
d3681 1
a3681 1
							(void)mk_addmember(name,&head,WMOP_SUBTRACT);
d3690 1
a3690 1
							(void)mk_addmember(name,&headf,WMOP_UNION);
d3696 1
a3696 1
							(void)mk_addmember(name,&head,WMOP_SUBTRACT);
d3702 1
a3702 1
						(void)mk_addmember(name,&head,WMOP_SUBTRACT);
d3725 1
a3725 1
						(void)mk_addmember(name,&headf,WMOP_UNION);
d3732 1
a3732 1
							(void)mk_addmember(name,&headf,WMOP_UNION);
d3738 1
a3738 1
							(void)mk_addmember(name,&head,WMOP_SUBTRACT);
d3747 1
a3747 1
							(void)mk_addmember(name,&headf,WMOP_UNION);
d3753 1
a3753 1
							(void)mk_addmember(name,&head,WMOP_SUBTRACT);
d3759 1
a3759 1
						(void)mk_addmember(name,&head,WMOP_SUBTRACT);
d3788 1
a3788 1
						(void)mk_addmember(name,&headf,WMOP_UNION);
d3795 1
a3795 1
							(void)mk_addmember(name,&headf,WMOP_UNION);
d3801 1
a3801 1
							(void)mk_addmember(name,&head,WMOP_SUBTRACT);
d3812 1
a3812 1
							(void)mk_addmember(name,&headf,WMOP_UNION);
d3819 1
a3819 1
							(void)mk_addmember(name,&head,WMOP_SUBTRACT);
d3825 1
a3825 1
						(void)mk_addmember(name,&head,WMOP_SUBTRACT);
d3955 1
a3955 1
			(void)mk_addmember(name,&head,WMOP_SUBTRACT);
d3957 1
a3957 1
			(void)mk_addmember(name,&head,WMOP_UNION);
d3959 1
a3959 1
			(void) mk_addmember(name,&head,WMOP_UNION);
d4001 1
a4001 1
			(void)mk_addmember(name,&head,WMOP_SUBTRACT);
d4003 1
a4003 1
			(void)mk_addmember(name,&head,WMOP_UNION);
d4006 1
a4006 1
			(void) mk_addmember(name,&head,WMOP_UNION);
d4097 1
a4097 1
			(void) mk_addmember(gname,&headd,WMOP_UNION);
d4102 1
a4102 1
			(void) mk_addmember(mgname,&headd,WMOP_UNION);
d4108 1
a4108 1
		(void) mk_addmember(gname,&heade,WMOP_UNION);
d4258 1
a4258 3
pt_inside( a,base,top,rad1,rad2 )
point_t a,base,top;
fastf_t rad1,rad2;
d4324 1
a4324 1
		(void)mk_addmember( name1, head, WMOP_UNION );
d4339 1
a4339 1
	(void)mk_addmember( name1, head, WMOP_UNION );
d4344 1
a4344 1
			(void)mk_addmember( tmpname, head, WMOP_SUBTRACT );
@


11.23
log
@
fixed lint
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/patch/patch-g.c,v 11.22 2000/01/12 14:16:03 jra Exp $ (BRL)";
d44 5
a59 1
#include "../librt/debug.h"
d79 2
d82 1
a82 1
Usage: patch-g [options] > model.g\n\
d102 4
a142 6
	if ( isatty(fileno(stdout)) ){
		(void)fputs("attempting to send binary output to tty, aborting!\n",stderr);
		(void)fputs(usage, stderr);
		exit(1);
	}

d264 9
d323 1
a323 1
	mk_id_units(stdout, title, "in");
d513 1
a513 1
				mk_lcomb(stdout,name,&headd,0,"","",rgb,0);
d530 1
a530 1
	mk_lcomb(stdout,name,&heade,0,"","",0,0);
d534 1
a534 1
		mk_lcomb(stdout,name,&headf,0,"","",0,0);
d621 1
d1047 1
a1047 1
				mk_arb8( stdout, tmp_name, pts );
d1054 1
a1054 1
					mk_arb8( stdout, tmp_name, pts );
d1060 1
a1060 1
		mk_lcomb( stdout, name, &tmp_head, 0, (char *)NULL, (char *)NULL, (unsigned char *)NULL, 0 );
d1062 1
a1062 1
			mk_lcomb( stdout, mirror_name, &mir_head, 0, (char *)NULL, (char *)NULL, (unsigned char *)NULL, 0 );
d1272 1
a1272 1
			write_shell_as_polysolid( stdout , name , s );
d1277 1
a1277 1
				mk_nmg( stdout , name , m );
d1286 1
a1286 1
				write_shell_as_polysolid( stdout , mirror_name , s );
d1288 1
a1288 1
				mk_nmg( stdout , mirror_name , m );
d1419 1
a1419 2
		mk_nmg( stdout , tmp_name , m );
		fflush( stdout );
d1548 1
a1548 1
				mk_nmg( stdout , bad , m );
d1570 1
a1570 2
		mk_nmg( stdout , tmp_name , m );
		fflush( stdout );
d1586 1
a1586 1
		mk_nmg( stdout , bad , m );
d1659 1
a1659 1
		write_shell_as_polysolid( stdout , name , s );
d1664 1
a1664 1
			mk_nmg( stdout , name , m );
d1678 1
a1678 1
			write_shell_as_polysolid( stdout , mirror_name , s );
d1680 1
a1680 1
			mk_nmg( stdout , mirror_name , m );
d1744 1
a1744 1
		mk_lrcomb(stdout, cname, &head, 1, 0, 0, 0, cc, 0, nm[cc].matcode, nm[cc].eqlos, 0);
d1747 1
a1747 1
		mk_lrcomb(stdout, cname, &head, 1, 0, 0, 0, cc, 0, 2, 100, 0);
d2285 1
a2285 1
		mk_arb8( stdout, name, &pt8[0][X] );
d2353 1
a2353 1
				mk_arb8( stdout, name, &inpt8[0][X] );
d2397 1
a2397 1
		mk_arb8( stdout, name, &pt8[0][X] );
d2464 1
a2464 1
				mk_arb8( stdout, name, &inpt8[0][X] );
d2520 1
a2520 1
			mk_sph(stdout,name,center,in[i+1].x);
d2538 1
a2538 1
					mk_sph(stdout,name,center,rad);
d2572 1
a2572 1
			mk_sph(stdout,name,center,in[i+1].x);
d2586 1
a2586 1
					mk_sph(stdout,name,center,rad);
d2659 1
a2659 1
		mk_arb8( stdout, name, &pt8[0][X] );
d2708 1
a2708 1
				mk_arb8( stdout, name, &pt8[0][X] );
d2750 1
a2750 1
		mk_arb8( stdout, name, &pt8[0][X] );
d2799 1
a2799 1
				mk_arb8( stdout, name, &pt8[0][X] );
d2946 1
a2946 1
			mk_trc_top( stdout, scratch_name1, base1, top1, rbase1, rtop1 );
d2950 1
a2950 1
			mk_trc_top( stdout, scratch_name2, base2, top2, rbase2, rtop2 );
d2961 1
a2961 1
				mk_trc_top( stdout, scratch_name3, base2, base1, rbase2, rbase1 );
d2972 1
a2972 1
				mk_trc_top( stdout, scratch_name4, top2, top1, rtop2, rtop1 );
d3066 1
a3066 1
				mk_lfcomb( stdout, name, &donut_head, 0 );
d3091 1
a3091 1
				mk_trc_top(stdout,scratch_name1_in,base1_in,top1_in,rbase1_in,rtop1_in);
d3104 1
a3104 1
				mk_trc_top(stdout,scratch_name2_in,base2_in,top2_in,rbase2_in,rtop2_in);
d3125 1
a3125 1
					mk_trc_top(stdout,scratch_name4_in,base_in,top_in,rbase_in,rtop_in);
d3139 1
a3139 1
					mk_trc_top(stdout,scratch_name4_in,base_in,top_in,rbase_in,rtop_in);
d3161 1
a3161 1
					mk_trc_top(stdout,scratch_name3_in,base_in,top_in,rbase_in,rtop_in);
d3175 1
a3175 1
					mk_trc_top(stdout,scratch_name3_in,base_in,top_in,rbase_in,rtop_in);
d3184 1
a3184 1
				mk_lfcomb( stdout, name, &donut_head, 0 );
d3276 1
a3276 1
			mk_trc_top(stdout,name,base,top,in[k+2].x,in[k+2].y);
d3320 1
a3320 1
						mk_trc_top(stdout,name,sbase,top,srad1,srad2);
d3335 1
a3335 1
						mk_trc_top(stdout,name,base,stop,srad1,srad2);
d3340 1
a3340 1
						mk_trc_top(stdout,name,base,top,srad1,srad2);
d3377 1
a3377 1
							mk_trc_top(stdout,name,sbase,top,srad1,srad2);
d3392 1
a3392 1
							mk_trc_top(stdout,name,sbase,stop,srad1,srad2);
d3398 1
a3398 1
						mk_trc_top(stdout,name,sbase,top,srad1,srad2);
d3434 1
a3434 1
							mk_trc_top(stdout,name,sbase,stop,srad1,srad2);
d3449 1
a3449 1
							mk_trc_top(stdout,name,base,stop,srad1,srad2);
d3455 1
a3455 1
						mk_trc_top(stdout,name,base,stop,srad1,srad2);
d3497 1
a3497 1
							mk_trc_top(stdout,name,sbase,stop,srad1,srad2);
d3515 1
a3515 1
							mk_trc_top(stdout,name,sbase,stop,srad1,srad2);
d3521 1
a3521 1
						mk_trc_top(stdout,name,sbase,stop,srad1,srad2);
d3576 1
a3576 1
			mk_trc_top(stdout,name,base,top,in[k+2].x,in[k+2].y);
d3621 1
a3621 1
						mk_trc_top(stdout,name,sbase,top,srad1,srad2);
d3636 1
a3636 1
						mk_trc_top(stdout,name,base,stop,srad1,srad2);
d3641 1
a3641 1
						mk_trc_top(stdout,name,base,top,srad1,srad2);
d3678 1
a3678 1
							mk_trc_top(stdout,name,sbase,top,srad1,srad2);
d3693 1
a3693 1
							mk_trc_top(stdout,name,sbase,stop,srad1,srad2);
d3699 1
a3699 1
						mk_trc_top(stdout,name,sbase,top,srad1,srad2);
d3735 1
a3735 1
							mk_trc_top(stdout,name,sbase,stop,srad1,srad2);
d3750 1
a3750 1
							mk_trc_top(stdout,name,base,stop,srad1,srad2);
d3756 1
a3756 1
						mk_trc_top(stdout,name,base,stop,srad1,srad2);
d3798 1
a3798 1
							mk_trc_top(stdout,name,sbase,stop,srad1,srad2);
d3816 1
a3816 1
							mk_trc_top(stdout,name,sbase,stop,srad1,srad2);
d3822 1
a3822 1
						mk_trc_top(stdout,name,sbase,stop,srad1,srad2);
d3946 1
a3946 1
			mk_trc_top(stdout,name,base,top,tmp,tmp1);
d3992 1
a3992 1
			mk_trc_top(stdout,name,base,top,tmp,tmp1);
d4094 1
a4094 1
			mk_lcomb(stdout,gname,&heada,0,"","",0,0);
d4099 1
a4099 1
			mk_lcomb(stdout,mgname,&headb,0,"","",0,0);
d4105 1
a4105 1
		mk_lcomb(stdout,gname,&headd,0,"","",rgb,0);
d4223 1
d4255 1
@


11.22
log
@Eliminated some unused variables
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/patch/patch-g.c,v 11.21 1999/10/30 03:06:26 butler Exp $ (BRL)";
a57 3
RT_EXTERN( struct shell *nmg_dup_shell , ( struct shell *s , long ***trans_tbl, struct bn_tol *tol ) );
RT_EXTERN( fastf_t mat_determinant, ( CONST mat_t m ) );

d1566 1
a1566 1
	if( nmg_open_shells_connect( s , is , copy_tbl , tol ) )
d1920 1
a1920 1
	det = mat_determinant( matrix );
@


11.21
log
@Moved mathtab/rand_half from rt into libbn
Expanded structparse to include description and default
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/patch/patch-g.c,v 11.20 1999/07/16 20:02:45 jra Exp $ (BRL)";
d104 1
a104 3
	fastf_t  x1, y1, z1;
	int numf = 3;
	int fd,fl,nread;
a112 4
	char *next, *ptr;
	char *matname = "plastic";
	char *matparm = "sh=100.0,sp=.9,di=.1";
	char hold = 0;
d328 1
a328 1
				while( (hold=fgetc( gfp )) != '\n' )
d336 1
a336 1
					while( (hold=fgetc( gfp )) != '\n' )
a969 1
	struct rt_tol tol_tmp;
a981 7
	/* A local tolerance structure for times when I don't want tolerancing */
	tol_tmp.magic = RT_TOL_MAGIC;
	tol_tmp.dist = SQRT_SMALL_FASTF;
	tol_tmp.dist_sq = SMALL_FASTF;
	tol_tmp.perp = 0.0;
	tol_tmp.para = 1.0;

a1422 1
		plane_t plane;
a1757 1
	vect_t	ab,bc,ca;
a1760 1
	vect_t  norm,out;
a1894 1
	int failed=0;
a2022 1
			failed = 1;
a2033 4
	point_t arb6pt[8];
	vect_t	out;
	vect_t	norm;
	vect_t	ab,bc,ca,ac;
a2034 1
	fastf_t ndot,outdot;
a2036 1
	int thick_warn=0;
a2229 1
	point_t	pts[1];
d2232 1
a2232 1
	int i,k,l;
a2233 1
	fastf_t len;
a2607 1
	point_t	pts[1];
d2609 1
a2609 1
	int k,l;
a2610 1
	vect_t	v1,v2,v3,v4;
d2823 1
a2823 1
	vect_t h1, h2, h3, h4;
a2884 1
		VSUB2( h2, top2, base2 );
d4019 1
a4019 2
	vect_t	n,ncent;
	vect_t	out,tmp;
a4063 1
	char *cc;
@


11.20
log
@Added option to build plate mode triangle using ARB6 solids.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/patch/patch-g.c,v 11.19 1999/05/19 14:18:06 jra Exp $ (BRL)";
d49 2
a56 1
#include "../rt/mathtab.h"
@


11.19
log
@Initialized scratch_num to 0
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/patch/patch-g.c,v 11.18 1999/03/01 20:21:08 jra Exp $ (BRL)";
d87 1
d150 1
a150 1
	while ((c = getopt(argc, argv, "A:T:x:X:pf:i:m:anu:t:o:rc:d:")) != EOF)
d154 3
d1006 63
@


11.18
log
@More corrections to proc_wedge() for mirror solids
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/patch/patch-g.c,v 11.17 1999/03/01 19:49:46 jra Exp $ (BRL)";
d75 1
d138 2
a2791 1
	int scratch_num;
@


11.17
log
@Fixed proc_wedge() to handle hollow wedges correctly
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/patch/patch-g.c,v 11.16 1999/02/04 18:23:28 jra Exp $ (BRL)";
d2325 2
a2326 2
		VSET( pt8[1], in[k+1].x,-in[k+1].y,in[k+1].z );
		VSET( pt8[3], in[k+2].x,-in[k+2].y,in[k+2].z );
d2349 4
d2360 3
d2364 3
d2368 3
d2372 3
d2376 3
d2380 3
d2388 4
d2393 1
a2393 1
				planes[i][3] += in[k].rsurf_thick;
d2411 1
a2411 1
				mk_arb8( stdout, name, &pt8[0][X] );
@


11.16
log
@Fixed a bug that caused thicknesses of exactly 1, 2, or 3 inches to become 0 in plate mode.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/patch/patch-g.c,v 11.15 1997/12/03 06:13:03 mike Exp $ (BRL)";
d2208 2
a2209 2
		VSET( pt8[1], in[k+1].x,in[k+1].y,in[k+1].z );
		VSET( pt8[3], in[k+2].x,in[k+2].y,in[k+2].z );
d2238 2
d2241 2
d2249 3
d2253 3
d2257 3
d2261 3
d2265 3
d2269 3
d2277 4
d2282 1
a2282 1
				planes[i][3] += in[k].rsurf_thick;
@


11.15
log
@Added missing variable.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/patch-g.c,v 11.14 1997/07/28 14:42:31 jra Exp mike $ (BRL)";
d446 1
a446 1
				else if( (in[i-1].surf_mode == '-') && (in[i-1].surf_thick == 0) )
@


11.14
log
@Fixed bug in proc_donut()
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/patch-g.c,v 11.13 1997/05/28 17:46:48 jra Exp jra $ (BRL)";
d2737 1
@


11.13
log
@Added rt_bomb() protection.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/patch-g.c,v 11.12 1997/04/30 20:15:58 jra Exp jra $ (BRL)";
d2929 1
d2946 1
@


11.12
log
@Added capability to handle donuts.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/patch-g.c,v 11.11 1997/03/06 20:39:43 jra Exp jra $ (BRL)";
d1798 1
a1798 1
	if( !Build_solid( l, name, mirror_name, 0, centroid, 0.0, pl, &tol ) )
d1800 7
d1817 1
d2141 8
a2148 1
			if( !Build_solid( l, name, mirror_name, 1, centroid, thicks[thick_no], pl, &tol ) )
d2160 1
@


11.11
log
@removed include of db.h
@
text
@d10 1
a10 1
 *		4 - donut / torus (not supported - new type 3)
d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/patch-g.c,v 11.10 1996/12/31 17:54:57 jra Exp jra $ (BRL)";
d72 1
d74 2
d82 1
a82 1
	-c \"x y z\"	center of object (for some surface normal calculations)\n\
d92 2
d128 9
d146 1
a146 1
	while ((c = getopt(argc, argv, "x:X:pf:i:m:anu:t:o:rc:d:")) != EOF)
d150 25
d310 2
a311 1
	mk_id(stdout,title);
d456 2
a457 2
			case 4: 	/* new "donut/torus" (not processed) */
				rt_log( "component %.4d: donut / torus not implemented\n",in[i-1].cc);
d620 101
d1062 2
d1065 6
a1070 4
				rt_log( "\t\t (%g , %g , %g) (%g , %g , %g) (%g , %g , %g)\n",
					V3ARGS( verts[k].coord ),
					V3ARGS( verts[k+1].coord ),
					V3ARGS( verts[k+2].coord ));
d1076 2
a1077 4
				rt_log( "Make face: (%f %f %f) (%f %f %f) (%f %f %f)\n",
					V3ARGS( verts[k].coord ),
					V3ARGS( verts[k+1].coord ),
					V3ARGS( verts[k+2].coord ));
d1079 9
a1713 9
	struct rt_tol tol;

        /* XXX These need to be improved */
        tol.magic = RT_TOL_MAGIC;
        tol.dist = 0.01;
        tol.dist_sq = tol.dist * tol.dist;
        tol.perp = 0.001;
        tol.para = 1 - tol.perp;

a1863 2
	rt_log( "determinant = %g\n", det );

a1990 8
	struct rt_tol tol;

        /* XXX These need to be improved */
        tol.magic = RT_TOL_MAGIC;
        tol.dist = 0.005;
        tol.dist_sq = tol.dist * tol.dist;
        tol.perp = 1e-6;
        tol.para = 1.0 - tol.perp;
d2012 2
a2013 2
						rt_log( "Warning: thickness of component #%d at sequence #%d is %gmm\n" , in[0].cc , index , in[k].rsurf_thick );
						rt_log( "\tsetting thickness to %gmm\n", 3.0*tol.dist );
d2091 1
a2091 1
				rt_log( "\t%g\n" , thicks[thick_no] );
a2180 1
	static struct rt_tol tol;
a2183 7
        tol.magic = RT_TOL_MAGIC;
        tol.dist = 0.01;
        tol.dist_sq = tol.dist * tol.dist;
        tol.perp = 0.001;
        tol.para = 1 - tol.perp;


d2259 1
a2259 1
				mk_addmember(name,&head,WMOP_SUBTRACT);
d2263 1
a2263 1
				mk_addmember(name,&headf,WMOP_UNION);
d2344 1
a2344 1
				mk_addmember(name,&head,WMOP_SUBTRACT);
d2348 1
a2348 1
				mk_addmember(name,&headf,WMOP_UNION);
d2418 1
a2418 1
					mk_addmember(name, &head,WMOP_SUBTRACT);
d2422 1
a2422 1
					mk_addmember(name, &headf,WMOP_UNION);
d2466 1
a2466 1
					mk_addmember(name, &head,WMOP_SUBTRACT);
d2470 1
a2470 1
					mk_addmember(name, &headf,WMOP_UNION);
d2590 1
a2590 1
				mk_addmember(name,&head,WMOP_SUBTRACT);
d2594 1
a2594 1
				mk_addmember(name,&headf,WMOP_UNION);
d2681 1
a2681 1
				mk_addmember(name,&head,WMOP_SUBTRACT);
d2685 1
a2685 1
				mk_addmember(name,&headf,WMOP_UNION);
d2697 378
d3187 1
a3187 1
						mk_addmember(name,&headf,WMOP_UNION);
d3201 1
a3201 1
						mk_addmember(name,&head,WMOP_SUBTRACT);
d3216 1
a3216 1
						mk_addmember(name,&head,WMOP_SUBTRACT);
d3221 1
a3221 1
						mk_addmember(name,&head,WMOP_SUBTRACT);
d3245 1
a3245 1
						mk_addmember(name,&headf,WMOP_UNION);
d3252 1
a3252 1
							mk_addmember(name,&headf,WMOP_UNION);
d3258 1
a3258 1
							mk_addmember(name,&head,WMOP_SUBTRACT);
d3267 1
a3267 1
							mk_addmember(name,&headf,WMOP_UNION);
d3273 1
a3273 1
							mk_addmember(name,&head,WMOP_SUBTRACT);
d3279 1
a3279 1
						mk_addmember(name,&head,WMOP_SUBTRACT);
d3302 1
a3302 1
						mk_addmember(name,&headf,WMOP_UNION);
d3309 1
a3309 1
							mk_addmember(name,&headf,WMOP_UNION);
d3315 1
a3315 1
							mk_addmember(name,&head,WMOP_SUBTRACT);
d3324 1
a3324 1
							mk_addmember(name,&headf,WMOP_UNION);
d3330 1
a3330 1
							mk_addmember(name,&head,WMOP_SUBTRACT);
d3336 1
a3336 1
						mk_addmember(name,&head,WMOP_SUBTRACT);
d3365 1
a3365 1
						mk_addmember(name,&headf,WMOP_UNION);
d3372 1
a3372 1
							mk_addmember(name,&headf,WMOP_UNION);
d3378 1
a3378 1
							mk_addmember(name,&head,WMOP_SUBTRACT);
d3389 1
a3389 1
							mk_addmember(name,&headf,WMOP_UNION);
d3396 1
a3396 1
							mk_addmember(name,&head,WMOP_SUBTRACT);
d3402 1
a3402 1
						mk_addmember(name,&head,WMOP_SUBTRACT);
d3488 1
a3488 1
						mk_addmember(name,&headf,WMOP_UNION);
d3502 1
a3502 1
						mk_addmember(name,&head,WMOP_SUBTRACT);
d3517 1
a3517 1
						mk_addmember(name,&head,WMOP_SUBTRACT);
d3522 1
a3522 1
						mk_addmember(name,&head,WMOP_SUBTRACT);
d3546 1
a3546 1
						mk_addmember(name,&headf,WMOP_UNION);
d3553 1
a3553 1
							mk_addmember(name,&headf,WMOP_UNION);
d3559 1
a3559 1
							mk_addmember(name,&head,WMOP_SUBTRACT);
d3568 1
a3568 1
							mk_addmember(name,&headf,WMOP_UNION);
d3574 1
a3574 1
							mk_addmember(name,&head,WMOP_SUBTRACT);
d3580 1
a3580 1
						mk_addmember(name,&head,WMOP_SUBTRACT);
d3603 1
a3603 1
						mk_addmember(name,&headf,WMOP_UNION);
d3610 1
a3610 1
							mk_addmember(name,&headf,WMOP_UNION);
d3616 1
a3616 1
							mk_addmember(name,&head,WMOP_SUBTRACT);
d3625 1
a3625 1
							mk_addmember(name,&headf,WMOP_UNION);
d3631 1
a3631 1
							mk_addmember(name,&head,WMOP_SUBTRACT);
d3637 1
a3637 1
						mk_addmember(name,&head,WMOP_SUBTRACT);
d3666 1
a3666 1
						mk_addmember(name,&headf,WMOP_UNION);
d3673 1
a3673 1
							mk_addmember(name,&headf,WMOP_UNION);
d3679 1
a3679 1
							mk_addmember(name,&head,WMOP_SUBTRACT);
d3690 1
a3690 1
							mk_addmember(name,&headf,WMOP_UNION);
d3697 1
a3697 1
							mk_addmember(name,&head,WMOP_SUBTRACT);
d3703 1
a3703 1
						mk_addmember(name,&head,WMOP_SUBTRACT);
d3833 1
a3833 1
			mk_addmember(name,&head,WMOP_SUBTRACT);
d3835 1
a3835 1
			mk_addmember(name,&head,WMOP_UNION);
d3879 1
a3879 1
			mk_addmember(name,&head,WMOP_SUBTRACT);
d3881 1
a3881 1
			mk_addmember(name,&head,WMOP_UNION);
d4156 1
a4156 1
	if( dist < 0.0  || dist > mag_bt )
d4159 1
a4159 1
	radius = ((rad2 - rad1)*dist)/mag_bt + rad2;
d4162 1
a4162 1
	if( debug>2 && pt_radsq < (radius*radius)  ){
d4173 1
a4173 1
	if( pt_radsq < (radius*radius) )
d4204 1
a4204 1
		mk_addmember( name1, head, WMOP_UNION );
d4219 1
a4219 1
	mk_addmember( name1, head, WMOP_UNION );
d4224 1
a4224 1
			mk_addmember( tmpname, head, WMOP_SUBTRACT );
@


11.10
log
@Added tolerance args to nmg_gluefaces() and nmg_dup_shell() calls.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/patch-g.c,v 11.9 1996/10/07 18:33:47 jra Exp jra $ (BRL)";
a47 1
#include "db.h"
@


11.9
log
@Fixed hollow cylinders to handle cases where thickness is greater than one radii.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/patch-g.c,v 11.8 1996/08/20 19:15:53 wm Exp jra $ (BRL)";
d58 1
a58 1
RT_EXTERN( struct shell *nmg_dup_shell , ( struct shell *s , long ***trans_tbl ) );
d1025 1
a1025 1
	nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ) );
d1205 1
a1205 1
	is = nmg_dup_shell( s , &copy_tbl );
d1262 1
a1262 1
	nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ) );
d1428 1
a1428 1
	nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ) );
@


11.8
log
@Added support for hollow wedges.  -WM
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/patch-g.c,v 11.7 1996/08/14 20:07:13 wm Exp wm $ (BRL)";
d1032 1
d1036 4
d2005 1
d2664 4
d2671 5
d2680 1
a2680 6
					rad1 = in[k+2].x;
					rad2 = in[k+2].y;
					VSUB2(ab,top,base);
					ht = MAGNITUDE( ab );
					thick = in[k+2].rsurf_thick / ht * 
					    hypot( ht, rad2-rad1 );
d2684 34
a2717 1
					if( srad1 > 0.0 && srad2 > 0.0 ) {
a2720 3
					else {
						mk_addmember(name,&headf,WMOP_UNION);
					}
d2728 1
d2742 34
a2775 1
					if( srad1 > 0.0 && srad2 > 0.0 && !VEQUAL(sbase,top) ) {
a2778 3
					else {
						mk_addmember(name,&headf,WMOP_UNION);
					}
d2785 1
d2799 34
a2832 1
					if( srad1 > 0.0 && srad2 > 0.0 && !VEQUAL(base,stop) ) {
a2835 3
					else {
						mk_addmember(name,&headf,WMOP_UNION);
					}
d2844 1
d2855 2
a2856 2
					srad1 = rad2 - sht / ht * (rad2 - rad1);
					srad2 = rad1 - sht / ht * (rad1 - rad2);
d2859 25
a2883 2
					srad1 = srad1 - thick;
					srad2 = srad2 - thick;
d2885 14
a2898 1
					if( srad1 > 0.0 && srad2 > 0.0 && !VEQUAL(sbase,stop) ) {
a2901 3
					else {
						mk_addmember(name,&headf,WMOP_UNION);
					}
d2964 4
d2971 6
d2981 1
a2981 6
					rad1 = in[k+2].x;
					rad2 = in[k+2].y;
					VSUB2(ab,top,base);
					ht = MAGNITUDE( ab );
					thick = in[k+2].rsurf_thick / ht * 
					    hypot( ht, rad2-rad1 );
d2985 34
a3018 1
					if( srad1 > 0.0 && srad2 > 0.0 ) {
a3021 3
					else {
						mk_addmember(name,&headf,WMOP_UNION);
					}
d3029 1
d3043 34
a3076 1
					if( srad1 > 0.0 && srad2 > 0.0 && !VEQUAL(sbase,top) ) {
a3079 4
					else {
						mk_addmember(name,&headf,WMOP_UNION);
					}

a3080 1

d3086 1
d3100 34
a3133 1
					if( srad1 > 0.0 && srad2 > 0.0 && !VEQUAL(base,stop) ) {
a3136 3
					else {
						mk_addmember(name,&headf,WMOP_UNION);
					}
d3145 1
d3156 2
a3157 2
					srad1 = rad2 - sht / ht * (rad2 - rad1);
					srad2 = rad1 - sht / ht * (rad1 - rad2);
d3160 25
a3184 2
					srad1 = srad1 - thick;
					srad2 = srad2 - thick;
d3186 14
a3199 1
					if( srad1 > 0.0 && srad2 > 0.0 && !VEQUAL(sbase,stop) ) {
a3202 3
					else {
						mk_addmember(name,&headf,WMOP_UNION);
					}
d3208 2
a3209 1
				}/* switch */
@


11.7
log
@Fixed bug in processing of wedges, bug report by Ken Kelsey to cad@@arl.mil. -WM
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/patch-g.c,v 11.6 1996/07/17 13:13:21 jra Exp wm $ (BRL)";
d2024 1
a2024 1
 *	Process fastgen wedge shape - this does not process hollows
d2032 2
a2033 1
	int k,l;
d2035 2
a2036 1
	vect_t	v1,v2,v3,v4;
d2042 11
d2091 46
d2149 1
a2149 1

d2176 45
@


11.6
log
@Minor Mods for IRIX 6.2
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/patch-g.c,v 11.5 1995/11/07 13:15:52 jra Exp jra $ (BRL)";
d100 2
a101 1
	FILE	*gfp,*mfp;
d1027 2
a1028 1
	nmg_make_faces_within_tol( s, tol );
d2050 2
a2051 2
		VSET( pt8[4], in[k+2].x,in[k+2].y,in[k+2].z );
		VSET( pt8[3], in[k+3].x,in[k+3].y,in[k+3].z );
a2056 1
		VADD3(pt8[5],ab,ad,pt8[0]);
d2059 4
a2062 2
		VMOVE(pt8[6],pt8[5]);
		VMOVE(pt8[2],pt8[1]);
d2092 1
d2095 2
a2096 2
		VSET( pt8[4], in[k+2].x,-in[k+2].y,in[k+2].z );
		VSET( pt8[3], in[k+3].x,-in[k+3].y,in[k+3].z );
d2102 1
d2104 1
a2104 2
		VADD3(pt8[5],ab,ad,pt8[0]);
		VADD3(pt8[7],ab,ac,pt8[0]);
d2106 2
a2107 2
		VMOVE(pt8[6],pt8[5]);
		VMOVE(pt8[2],pt8[1]);
@


11.5
log
@Added calls to nmg_model_vertex_fuse() and nmg_break_edges().
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/patch-g.c,v 11.4 1995/10/19 15:03:15 jra Exp $ (BRL)";
d65 7
d1540 1
d1555 1
d1612 1
d1615 1
a1615 1
		point_t last, tmp;
d1843 1
d1957 1
d1960 1
a1960 1
			point_t last, tmp;
d2024 1
d2127 1
d2254 1
d2472 1
d2856 1
d3023 1
d3126 1
@


11.4
log
@Mods to calculate a consistent normal for plate mode objects that are nearly planar.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/patch-g.c,v 11.3 1995/10/05 19:31:35 jra Exp $ (BRL)";
d1006 3
d1012 1
a1012 2
	s = RT_LIST_FIRST( shell , &r->s_hd );
	i = nmg_break_long_edges( s , tol );
d1014 1
a1014 1
		rt_log( "nmg_break_long_edges broke %d edges\n" , i );
@


11.3
log
@Modified to handle plate mode solids with varying thickness as seperate solids,
each with one unique thickness.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/patch-g.c,v 11.2 1995/10/02 14:34:33 jra Exp jra $ (BRL)";
d59 1
d61 2
d801 1
a801 1
Build_solid( l, name, mirror_name, plate_mode, centroid, thickness, tol )
d807 1
d827 3
d1067 32
d1122 1
a1122 9
		/* calculate "out" direction, from centroid to face */
		lu = RT_LIST_FIRST( loopuse , &fu->lu_hd );
		eu = RT_LIST_FIRST( edgeuse , &lu->down_hd );
		VSUB2( out , eu->vu_p->v_p->vg_p->coord , centroid );
		VUNITIZE( out );

		/* if "normal" and "out" disagree, reverse normal */
		outdot = VDOT( out , normal );
		if( outdot <= 0.001 &&  outdot >= -0.001 )
d1124 4
a1127 2
			/* try model centroid */
			VSUB2( out , eu->vu_p->v_p->vg_p->coord , Centroid );
d1129 2
d1132 7
d1140 5
d1544 1
d1637 1
a1637 1
	if( !Build_solid( l, name, mirror_name, 0, centroid, 0.0, &tol ) )
d1660 148
d1830 1
d1942 2
d1980 1
a1980 1
			if( !Build_solid( l, name, mirror_name, 1, centroid, thicks[thick_no], &tol ) )
@


11.2
log
@Relaxed tolerances. Added call to nmg_make_faces_within_tol() for inside shell (plate mode).
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/patch-g.c,v 11.1 95/01/04 10:18:16 mike Rel4_4 $ (BRL)";
d60 1
d798 1
a798 1
Build_solid( l , name , mirror_name , plate_mode , centroid , tol )
d803 1
d862 3
d1589 1
a1589 1
	if( !Build_solid( l , name , mirror_name , 0 , centroid , &tol ) )
d1615 1
d1623 1
d1627 1
d1650 2
a1651 1
	if ((in[0].rsurf_thick > 0)||(aflg > 0)) {
a1657 1
					/*				rt_log( "index = %d\n",index); */
d1661 8
a1668 1
					list[index].thick = in[k].rsurf_thick;
d1674 43
d1729 2
a1730 2
					rt_log( "Thickness of component #%d at vertex #%d is %g\n" , in[0].cc , l , thk[l] );
					thk[l] = 0.01;
d1740 3
d1763 2
a1764 1
		/* name solids */
d1766 1
a1766 4
		shflg = 't';
		mrflg = 'n';
		ctflg = 'n';
		strcpy( name , proc_sname (shflg,mrflg,count+1,ctflg) );
d1768 4
a1771 7
		if( in[0].mirror != 0 )
		{
			mrflg = 'y';
			strcpy( mirror_name , proc_sname (shflg,mrflg,mir_count+1,ctflg) );
		}
		else
			mirror_name[0] = '\0';
d1773 1
a1773 6
		if( !Build_solid( l , name , mirror_name , 1 , centroid , &tol ) )
		{
			count++;
			(void) mk_addmember(name,&head,WMOP_UNION);
			proc_region( name );
			if( mirror_name[0] )
d1775 2
a1776 3
				(void) mk_addmember(mirror_name,&head,WMOP_UNION);
				mir_count++;
				proc_region( mirror_name );
d1778 2
a1779 1
		}
d1781 4
a1784 3
		if( debug )
		{
			rt_log( "\tFinished %s\n" , name );
d1786 13
a1798 1
				rt_log( "\tand %s\n" , mirror_name );
d1800 3
@


11.1
log
@Release_4.4
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/patch-g.c,v 1.15 94/12/30 03:30:11 mike Exp $ (BRL)";
d1005 2
d1289 1
d1496 1
a1496 1
        tol.dist = 0.005;
d1498 1
a1498 1
        tol.perp = 1e-6;
@


1.15
log
@DEC Alpha
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/patch-g.c,v 1.14 94/10/20 00:23:22 mike Exp Locker: mike $ (BRL)";
@


1.14
log
@mk_arb8()
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/patch-g.c,v 1.13 94/09/21 22:05:06 mike Exp Locker: mike $ (BRL)";
d110 1
a110 1
	bzero(list,sizeof(list));
@


1.13
log
@Converted to new NMG data structures.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/patch-g.c,v 1.12 94/08/24 13:39:24 gdurf Exp Locker: mike $ (BRL)";
d1786 1
a1786 1
		mk_arb8( stdout, name, pt8 );
d1825 1
a1825 1
		mk_arb8( stdout, name, pt8 );
d2016 1
a2016 1
		mk_arb8( stdout, name, pt8 );
d2065 1
a2065 1
				mk_arb8( stdout, name, pt8 );
d2107 1
a2107 1
		mk_arb8( stdout, name, pt8 );
d2156 1
a2156 1
				mk_arb8( stdout, name, pt8 );
@


1.12
log
@Added include of conf.h, removed ancient SGI cruft
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/patch-g.c,v 1.11 1994/08/08 12:28:28 gdurf Exp gdurf $ (BRL)";
d657 2
a658 2
	struct face_g	*fg1;
	struct face_g	*fg2;
d680 2
a681 2
		fg1 = f1->fg_p;
		NMG_CK_FACE_G(fg1);
d711 2
a712 2
			fg2 = f2->fg_p;
			NMG_CK_FACE_G(fg2);
d1144 1
a1144 1
		struct face_g *fg_p;
d1163 2
a1164 2
		fg_p = fu->f_p->fg_p;
		NMG_CK_FACE_G( fg_p );
@


1.11
log
@Added #ifdef HAVE_MALLOC_H
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/patch-g.c,v 1.10 1994/07/13 12:19:45 jra Exp gdurf $ (BRL)";
d41 2
d45 1
a59 14
#if defined(sgi) && !defined(mips)
/* Horrible bug in 3.3.1 and 3.4 and 3.5 -- hypot ruins stack! */
long float
hypot(a,b)
double a,b;
{
	return(sqrt(a*a+b*b));
}
#else
#ifdef HAVE_MALLOC_H
#include <malloc.h>		/* not needed on SGI 3030s */
#endif
#endif /* sgi */

a192 4
#if defined( sgi ) && ! defined( mips )			
				sscanf( optarg,"%f %f %f", 
				    &Centroid[0],&Centroid[1],&Centroid[2]);
#else
d195 1
a195 1
#endif
a320 8
#if defined( sgi ) && ! defined( mips )
			sscanf(buf,"%f %f %f %c %d %d %d %d %d %d %d %d %d %d %d %d %d %d",
			    &in[i].x,&in[i].y,&in[i].z,&in[i].surf_mode,&in[i].surf_type,
			    &in[i].surf_thick,&in[i].spacecode, &in[i].cc,
			    &in[i].ept[0],&in[i].ept[1],&in[i].ept[2],
			    &in[i].ept[3],&in[i].ept[4],&in[i].ept[5],
			    &in[i].ept[6],&in[i].ept[7],&in[i].mirror,&in[i].vc);
#else
a326 1
#endif
@


1.10
log
@Reordered routines to avoid redeclaration errors.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/patch-g.c,v 1.9 1994/06/24 09:56:58 jra Exp jra $ (BRL)";
d66 1
d68 1
@


1.9
log
@Modified to account for change in arg list for nmg_in_vert
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/patch-g.c,v 1.8 94/03/30 09:19:31 jra Exp Locker: jra $ (BRL)";
d1425 71
a2794 71
}

/*
 *     This subroutine takes previously generated solid names and combines them
 *	into a common region identity.  Format of the make_region command call
 *	requires in order: output file name, input region name, link file of solids,
 *	region/group flag, material name, material parameters, RGB color assignment, region id #,
 *	aircode, material code, LOS, and inheritance flag.  The region is then 
 *	added to a hold file for combination into groups in another process.        
 */
void
proc_region(name1)
char *name1;

{
	char tmpname[24];
	int chkroot;
	int i;
	int cc;
	static int reg_count=0;
	static int mir_count=0;
	static int last_cc=0;


	if( RT_LIST_IS_EMPTY( &head.l ) )
		return;

	strcpy( tmpname , name1 );

	chkroot = 0;
	while( tmpname[chkroot++] != '.' );

	cc = atoi( &tmpname[chkroot] );

	i = strlen( tmpname );
	while( tmpname[--i] != '.' );
	tmpname[i] = '\0';

	if( in[0].cc != last_cc )
	{
		reg_count = 0;
		mir_count = 0;
	}

	if( cc != in[0].cc )
	{
		mir_count++;
		sprintf(cname,"%s.r%.2d",tmpname,mir_count);
	}
	else
	{
		reg_count++;
		sprintf(cname,"%s.r%.2d",tmpname,reg_count);
	}


	if( nm[cc].matcode != 0 ) {
		mk_lrcomb(stdout, cname, &head, 1, 0, 0, 0, cc, 0, nm[cc].matcode, nm[cc].eqlos, 0);
	}
	else {
		mk_lrcomb(stdout, cname, &head, 1, 0, 0, 0, cc, 0, 2, 100, 0);
	}

	if ( cc == in[0].cc){
		(void) mk_addmember(cname,&heada,WMOP_UNION);
	}
	else{
		(void) mk_addmember(cname,&headb,WMOP_UNION);
	}

	last_cc = in[0].cc;
@


1.8
log
@Converted option processing to use getopt
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/patch-g.c,v 1.7 94/03/29 18:32:52 jra Exp Locker: jra $ (BRL)";
d1271 1
a1271 1
		if( nmg_in_vert( new_v , tol ) )
@


1.7
log
@Finished conversion to NMG's
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/patch-g.c,v 1.6 94/02/17 16:05:42 jra Exp Locker: jra $ (BRL)";
a89 217
void
nmg_tmp_vu( vu )
CONST struct vertexuse *vu;
{
	struct vertex *v;
	struct vertex_g *vg;

	NMG_CK_VERTEXUSE( vu );
	rt_log( "vertexuse magic_p = x%x , magic = x%x , index = %d\n" , &vu->l.magic , vu->l.magic , vu->index );

	v = vu->v_p;

	NMG_CK_VERTEX( v );
	rt_log( "vertex magic_p = x%x , magic = x%x , index = %d\n" , &v->magic , v->magic , v->index );

	vg = v->vg_p;

	NMG_CK_VERTEX_G( vg );
	rt_log( "vertex_g magic_p = x%x , magic = x%x , index = %d\n" , &vg->magic , vg->magic , vg->index );
}

void
nmg_tmp_eu( eu )
CONST struct edgeuse *eu;
{
	struct edge *e;
	struct edge_g *eg;
	struct edgeuse_a *eua;
	struct vertexuse *vu;
	struct edgeuse *eu1;

	NMG_CK_EDGEUSE( eu );
	rt_log( "edgeuse magic_p = x%x , magic = x%x , index = %d\n" , &eu->l.magic , eu->l.magic , eu->index );

	e = eu->e_p;
	NMG_CK_EDGE( e );
	rt_log( "edge magic_p = x%x , magic = x%x , index = %d\n" , &e->magic , e->magic , e->index );
	eu1 = e->eu_p;
	if( eu1->l.magic != NMG_EDGEUSE_MAGIC )
	{
		rt_log( "Found bad edgeuse:\n" );
		rt_log( "e->eu_p should be x%x, but is x%x\n" , eu , eu1 );
		rt_log( "( %f %f %f ) to ( %f %f %f )\n" , V3ARGS( eu->vu_p->v_p->vg_p->coord ) , V3ARGS( eu->eumate_p->vu_p->v_p->vg_p->coord ) );
	}

	eg = e->eg_p;
	if( eg )
	{
		NMG_CK_EDGE_G( eg );
		rt_log( "edge_g magic_p = x%x , magic = x%x , index = %d\n" , &eg->magic , eg->magic , eg->index );
	}
	else
		rt_log( "\tNo edge_g\n" );

	eua = eu->eua_p;
	if( eua )
	{
		NMG_CK_EDGEUSE_A( eua );
		rt_log( "edgeuse_a magic_p = x%x , magic = x%x , index = %d\n" , &eua->magic , eua->magic , eua->index );
	}
	else
		rt_log( "\tNo edgeuse_a\n" );

	vu = eu->vu_p;
	nmg_tmp_vu( vu );
}

void
nmg_tmp_lu( lu )
CONST struct loopuse *lu;
{
	struct loop *l;
	struct loopuse_a *lua;
	struct loop_g *lg;

	NMG_CK_LOOPUSE( lu );
        rt_log( "loopuse magic_p = x%x , magic = x%x , index = %d\n" , &lu->l.magic , lu->l.magic , lu->index );

	l = lu->l_p;
	NMG_CK_LOOP( l );
        rt_log( "loop magic_p = x%x , magic = x%x , index = %d\n" , &l->magic , l->magic , l->index );

	lua = lu->lua_p;
	if( lua )
	{
		NMG_CK_LOOPUSE_A( lua );
	        rt_log( "loopuse_a magic_p = x%x , magic = x%x , index = %d\n" , &lua->magic , lua->magic , lua->index );
	}
	else
		rt_log( "\tNo loopuse_a\n" );

	lg = l->lg_p;
	if( lg )
	{
		NMG_CK_LOOP_G( lg );
	        rt_log( "loop_g magic_p = x%x , magic = x%x , index = %d\n" , &lg->magic , lg->magic , lg->index );
	}
	else
		rt_log( "\tNo loop_g\n" );

	if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_EDGEUSE_MAGIC )
	{
		struct edgeuse *eu;

		for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
			nmg_tmp_eu( eu );
	}
	else if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )
	{
		struct vertexuse *vu;

		vu = RT_LIST_FIRST( vertexuse , &lu->down_hd );
		nmg_tmp_vu( vu );
	}
}
void
nmg_tmp_fu( fu )
CONST struct faceuse *fu;
{
	struct face *f;
	struct faceuse_a *fua;
	struct face_g *fg;
	struct loopuse *lu;

	NMG_CK_FACEUSE( fu );
        rt_log( "faceuse magic_p = x%x , magic = x%x , index = %d\n" , &fu->l.magic , fu->l.magic , fu->index );

	fua = fu->fua_p;
	if( fua )
	{
		NMG_CK_FACEUSE_A( fua );
		rt_log( "faceuse_a magic_p = x%x , magic = x%x , index = %d\n" , &fua->magic , fua->magic , fua->index );
	}
	else
		rt_log( "\tNo faceuse_a\n" );

	f = fu->f_p;
	NMG_CK_FACE( f );
	rt_log( "face magic_p = x%x , magic = x%x , index = %d\n" , &f->l.magic , f->l.magic , f->index );

	fg = f->fg_p;
	if( fg )
	{
		NMG_CK_FACE_G( fg );
		rt_log( "face_g magic_p = x%x , magic = x%x , index = %d\n" , &fg->magic , fg->magic , fg->index );
	}
	else
		rt_log( "\tNo face_g\n" );

	for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
		nmg_tmp_lu( lu );
}

void
nmg_tmp( m )
CONST struct model *m;
{
	struct nmgregion *r;
	struct model_a *ma;

	NMG_CK_MODEL( m );
	rt_log( "model magic_p = x%x , magic = x%x , index = %d\n" , &m->magic , m->magic , m->index );
	ma = m->ma_p;
	if( ma )
	{
		NMG_CK_MODEL_A( ma );
	        rt_log( "model_a magic_p = x%x , magic = x%x , index = %d\n" , &ma->magic , ma->magic , ma->index );
	}
	else
		rt_log( "\tNo model_a\n" );

	for( RT_LIST_FOR( r , nmgregion , &m->r_hd ) )
	{
		struct shell *s;
		struct nmgregion_a *ra;

		NMG_CK_REGION( r );

		rt_log( "region magic_p = x%x , magic = x%x , index = %d\n" , &r->l.magic , r->l.magic , r->index );
		ra = r->ra_p;
		if( ra )
		{
			NMG_CK_REGION_A( ra );
	                rt_log( "region_a magic_p = x%x , magic = x%x , index = %d\n" , &ra->magic , ra->magic , ra->index );
		}
		else
			rt_log( "\tNo region_a\n" );

		for( RT_LIST_FOR( s , shell , &r->s_hd ) )
		{
			struct shell_a *sa;
			struct faceuse *fu;
			struct loopuse *lu;
			struct edgeuse *eu;
			struct vertexuse *vu;

			NMG_CK_SHELL( s );
	                rt_log( "shell magic_p = x%x , magic = x%x , index = %d\n" , &s->l.magic , s->l.magic , s->index );
			sa = s->sa_p;
			if( sa )
			{
				NMG_CK_SHELL_A( sa );
		                rt_log( "shell_a magic_p = x%x , magic = x%x , index = %d\n" , &sa->magic , sa->magic , sa->index );
			}
			else
				rt_log( "\tNo shell_a\n" );

			vu = s->vu_p;
			if( vu != NULL )
				nmg_tmp_vu( vu );

			for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
				nmg_tmp_fu( fu );
		}
	}
}

d100 1
a120 2
	argc--,argv++;

d129 6
a134 2
	while (argc > 0 && argv[0][0] == '-') {
		switch (argv[0][1]) {
d136 2
a137 1
		case 'x':  /* librt debug flags */
d139 1
a139 3
			argc--,argv++;
			sscanf( *argv , "%x" , &rt_g.debug );
			break;
d141 2
a142 1
		case 'X':  /* librt NMG debug flags */
d144 1
a144 3
			argc--,argv++;
			sscanf( *argv , "%x" , &rt_g.NMG_debug );
			break;
d146 2
a147 1
		case 'p':  /* polysolid output */
d149 1
a149 2
			polysolid = 1;
			break;
d151 2
a152 1
		case 'f':  /* fastgen source file data */
d154 1
a154 3
			argc--,argv++;
			patchfile = *argv;
			break;
d156 2
a157 1
		case 'i':  /* group labels source file */
d159 1
a159 3
			argc--,argv++;
			labelfile = *argv;
			break;
d161 2
a162 1
		case 'm':  /* materials information file */
d164 1
a164 3
			argc--,argv++;
			matfile = *argv;
			break;
d166 2
a167 1
		case 'a':  /* process phantom armor ? */
d169 1
a169 2
			aflg++;
			break;
d171 2
a172 1
		case 'n':  /* process volume mode as plate mode ? */
d174 3
a176 2
			nflg = 0;
			break;
d178 5
a182 3
		case 'u':  /* specify number of union operations
			    * to put in a region 
						    */
d184 1
a184 6
			argc--,argv++;
			if( (num_unions = atoi( *argv )) <= 0 ) {
				fprintf(stderr,"%d: bad number of unions to put in a region\n", num_unions );
				exit( 1 );
			}
			break;
d186 2
a187 1
		case 't':  /* optional title for the database */
d189 1
a189 3
			argc--,argv++;
			title = *argv;
			break;
d191 2
a192 1
		case 'o':  /* optional top-level object name */
d194 1
a194 3
			argc--,argv++;
			top_level = *argv;
			break;
d196 2
a197 1
		case 'r':  /* reverse normals for plate mode triangles */
d199 3
a201 6
			rev_norms++;
			break;
		case 'c':  /* center of object (used for some plate mode
			    * triangle surface normal calculations
						    */
			argc--,argv++;
d203 2
a204 2
			sscanf( *argv,"%f %f %f", 
			    &Centroid[0],&Centroid[1],&Centroid[2]);
d206 2
a207 2
			sscanf( *argv,"%lf %lf %lf", 
			    &Centroid[0],&Centroid[1],&Centroid[2]);
d209 3
a211 2
			VSCALE( Centroid, Centroid, mmtin );
			break;
d213 1
a213 1
		case 'd':  /* debug flag checking */
d215 2
a216 3
			argc--,argv++;
			debug = atoi(*argv); /* Debug level */
			break;
d218 4
a221 6
		default:
			(void)fputs(usage, stderr);
			exit(1);
		}
		argc--, argv++;

d320 1
a320 1
				fprintf(stderr,"Incomplete line in materials file for component '%.4d'\n",i);
d370 1
a370 1
				fprintf(stderr,"%lf %lf %lf %c %lf %d %d %d %d %d %d %d %d %d %d %d %d %d\n",
d400 1
a400 1
					fprintf(stderr,"IN: %f %f %f\n",in[j].x,in[j].y,in[j].z);
d428 1
a428 1
				fprintf(stderr,"component %.4d: donut / torus not implemented\n",in[i-1].cc);
d457 1
a457 1
				fprintf(stderr,"component %.4d: unknown solid type %d\n",
d886 1
a886 1
			/* fprintf(stderr,"Repeated Vertice, no face made\n"); */
d892 1
a892 1
			/* fprintf(stderr,"%s: collinear points, face not made.\n", name); */
a1398 3
		{
			if( debug > 3 )
				nmg_tmp( m );
a1399 1
		}
d1468 1
a1468 1
					fprintf(stderr,"%d %f %f %f\n",list[index].flag,in[k].x,in[k].y,in[k].z);
d1488 1
a1488 1
			fprintf(stderr,"k=%d l=%d %f %f %f flag=%d\n",k,l,list[k].x,list[k].y,list[k].z,list[k].flag);
d1493 1
a1493 1
			fprintf(stderr,"%d %f %f %f\n",k,x[k],y[k],z[k]);
d1509 1
a1509 1
		fprintf(stderr,"%d: cpts=%d centroid %f %f %f\n",
d1597 1
a1597 1
					/*				fprintf(stderr,"index = %d\n",index); */
d1619 1
a1619 1
					fprintf( stderr , "Thickness of component #%d at vertex #%d is %g\n" , in[0].cc , l , thk[l] );
d1629 1
a1629 1
				fprintf(stderr,"Compressed: %f %f %f\n",x[k],y[k],z[k]);
d1645 1
a1645 1
			fprintf(stderr,"%d: cpts=%d centroid %f %f %f\n",
d1858 1
a1858 1
			fprintf(stderr,"Bad component %s\n",name);
d1906 1
a1906 1
			fprintf(stderr,"Bad component %s\n",name);
d2168 1
a2168 1
			fprintf(stderr,"%d %d %d\n", 
d2325 1
a2325 1
					fprintf(stderr,"Unknown cylinder mode\n");
d2332 1
a2332 1
			fprintf(stderr,"Bad Cylinder Length for %s\n",name);
d2497 1
a2497 1
					fprintf(stderr,"Unknown cylinder mode\n");
d2503 1
a2503 1
			fprintf(stderr,"Bad Cylinder Length for %s\n",name);
d2556 1
a2556 1
					fprintf(stderr,"%d %f %f %f %f %d\n",list[index].flag,in[k].x,in[k].y,in[k].z,in[k].rsurf_thick,
d2578 1
a2578 1
				fprintf(stderr,"k=%d l=%d %f %f %f %f %d flag=%d\n",
d2586 1
a2586 1
			fprintf(stderr,"compressed: %d %f %f %f %f %d\n",
d2616 1
a2616 1
			fprintf(stderr,"Bad Rod Radius for %s\n",name);
d2662 1
a2662 1
			fprintf(stderr,"Bad Rod Radius for %s\n",name);
d3019 1
a3019 1
		fprintf(stderr,"pt_inside: point (%.4f,%.4f,%.4f) inside cylinder endpoints (%.4f,%.4f,%.4f) and (%.4f,%.4f,%.4f)\n",
d3023 5
a3027 5
		fprintf(stderr,"pt_inside: radius at that point is %f\n",radius/mmtin);
		fprintf(stderr,"pt_inside: radial distance to point is %f\n",sqrt(pt_radsq)/mmtin );
		fprintf(stderr,"pt_inside: square of radial distance is %f\n",pt_radsq/(mmtin*mmtin));
		fprintf(stderr,"pt_inside: dist to base to point is %f\n",MAGSQ(ba)/mmtin );
		fprintf(stderr,"pt_inside: dist to normal between axis and point is %f\n",dist/mmtin);
@


1.6
log
@Partial conversion to NMG's
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/patch-g.c,v 1.5 94/01/27 13:14:30 jra Exp Locker: jra $ (BRL)";
d51 1
d86 2
d90 217
d350 12
a439 1
			fprintf(stderr,"Debug = %d\n",debug);
d450 14
d622 1
a622 2
                    	if( debug )
                    		fprintf( stderr , "component code #%d\n" , in[i-1].cc );
d629 3
d708 3
a1078 2
	rt_g.NMG_debug = 0;

d1160 1
a1160 1
				rt_log( "Make face: (%g , %g , %g) (%g , %g , %g) (%g , %g , %g)\n",
d1230 1
a1230 1
                        if( nmg_fu_planeeqn( fu , &tol_tmp ) )
d1242 8
d1256 1
a1256 1
			nmg_fix_normals( s );
d1370 12
d1526 1
a1526 4
	/* check for faces with less than three edges
	 * could have been created by killing of eu's
	 */
	if( nmg_kill_short_lus( r ) )
d1528 5
a1532 7
		/* It's all gone!!! */
		nmg_km( m );
		rt_free( (char *)flags , "build_solid: flags" );
		rt_free( (char *)copy_tbl , "build_solid: copy_tbl" );
		nmg_tbl( &verts_to_move , TBL_FREE , (long *)NULL );
		rt_log( "Build_solid: %s is empty\n" , name );
		return( 1 );
d1535 1
d1559 3
d1570 4
a1573 1
	                        if( nmg_fu_planeeqn( fu , &tol_tmp ) )
d1575 2
a1576 1
	                                rt_log( "Build_solid: Failed to calculate plane eqn for fu x%x:\n" , fu );
d1578 7
d1589 1
d1603 2
d1609 2
a1612 2
	nmg_vmodel( m );

d1626 2
a1627 1
			nmg_m_reindex( m );
d1635 2
d1640 1
a1640 1
			rt_log( "writing  %s (nirrored) to BRLCAD DB\n" , mirror_name );
a1644 1
		{
a1645 1
		}
d1811 1
a1811 1
        tol.para = 1 - tol.perp;
@


1.5
log
@Eliminated "proc_rod_region" and allowed for components that switch solid types
back and forth without changing component number.
@
text
@d25 2
d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/patch-g.c,v 1.4 94/01/26 15:12:31 jra Exp Locker: jra $ (BRL)";
d47 3
d54 2
d80 1
a92 1

a100 1

d105 1
d130 5
d377 3
d392 2
a393 1
				if ((nflg > 0)&&(in[i-1].surf_mode== '+')){
d396 6
a401 1
				else{
d446 1
a446 1
				proc_label(name,labelfile);
d467 1
a467 1
	/*	if( headf.forw != &headf.l ) {
d471 11
a481 4
*/
	if( RT_LIST_NEXT_NOT_HEAD(&headf, &headf.l )) {
		sprintf(name,"check.group");
		mk_lcomb(stdout,name,&headf,0,"","",0,0);
d484 4
d489 67
a566 1

d568 2
a569 1
 *	 Process Volume Mode triangular facetted solids  
d571 4
a574 2
proc_triangle(cnt)
int cnt;
d576 2
a577 9
	vect_t	ab,bc,ca;
	int	k,l;
	int	index;
	int	cpts;
	vect_t  norm,out;
	char	shflg,mrflg,ctflg;
	static int count=0;
	static int mir_count=0;
	static int last_cc=0;
d579 11
a589 4
	if( in[cnt-1].cc != last_cc )
	{
		count = 0;
		mir_count=0;
d591 3
d595 20
a614 1
	/* assign solid's name */
d616 2
a617 4
	shflg = 'f';
	mrflg = 'n';
	ctflg = 'n';
	proc_sname (shflg,mrflg,count+1,ctflg);
a618 1
	/* make solid */
d620 16
a635 2
	mk_polysolid(stdout,name);
	count++;
d637 20
a656 1
	(void) mk_addmember(name,&head,WMOP_UNION);
d658 2
d661 6
a666 2
	for(k=0 ; k < (cnt) ; k++){
		for(l=0; l<= 7; l++){
d668 3
a670 1
			if(in[k].ept[l] > 0){
d672 5
a676 5
				index = in[k].ept[l];
				list[index].x = in[k].x;
				list[index].y = in[k].y;
				list[index].z = in[k].z;
				list[index].flag = 1;
d678 3
a680 3
				if (debug > 3)
					fprintf(stderr,"%d %f %f %f\n",list[index].flag,in[k].x,in[k].y,in[k].z);
			}
d682 10
a692 1
	}
d694 9
a702 2
	/* Everything is sequenced, but separated, compress into single array here */
	l = 1;
d704 4
a707 6
	for (k=1; k<10000; k++){
		if(list[k].flag == 1){
			list[k].flag = 0;
			x[l] = list[k].x;
			y[l] = list[k].y;
			z[l] = list[k].z;
d709 2
a710 2
			l= l+1;
		}
d712 4
a715 3
		if (debug > 3)
			fprintf(stderr,"k=%d l=%d %f %f %f flag=%d\n",k,l,list[k].x,list[k].y,list[k].z,list[k].flag);
	}
d717 67
a783 3
	if (debug > 2){
		for (k=1;(k<=l);k++)
			fprintf(stderr,"%d %f %f %f\n",k,x[k],y[k],z[k]);
d785 2
d788 3
a790 2
	for(k=2; k<=4; k++){
		VSET(pt[k-2],x[k],y[k],z[k]);
d792 1
d794 27
a820 3
	VMOVE(vertice[0],pt[0]);
	VMOVE(vertice[1],pt[1]);
	VMOVE(vertice[2],pt[2]);
d822 6
a827 4
	for ( k=0; k<3; k++ )
		centroid[k] = 0.0;
	for ( cpts=0, k=1; k<l; k++ ) {
		point_t last, tmp;
d829 11
a839 6
		VSET( tmp, x[k], y[k], z[k] );
		if( VEQUAL( tmp, last ) )
			continue;
		VADD2( centroid, centroid, tmp );
		VMOVE( last, tmp );
		cpts++;
a840 6
	VSCALE( centroid, centroid, 1.0/cpts );
	if( debug > 2 ) {
		fprintf(stderr,"%d: cpts=%d centroid %f %f %f\n",
		    in[0].cc, cpts, 
		    centroid[0], centroid[1], centroid[2] );
	}
d843 5
a847 4
	for (k=5;(k<l); k++){
		if(   VEQUAL(vertice[0],vertice[1])
		    ||VEQUAL(vertice[0],vertice[2])
		    ||VEQUAL(vertice[1],vertice[2])){
d849 2
a850 1
			if ((k % 2)== 0){
d852 46
a897 3
				VMOVE(vertice[1],vertice[2]);
				VSET(pt[0],x[k],y[k],z[k]);
				VMOVE(vertice[2],pt[0]);
a898 1
			else{
d900 7
a906 3
				VMOVE(vertice[0],vertice[2]);
				VSET(pt[0],x[k],y[k],z[k]);
				VMOVE(vertice[2],pt[0]);
d908 1
d911 5
a915 3
			/* fprintf(stderr,"Repeated Vertice, PUNTING\n"); */
		}
		else{
d917 3
a919 5
			/* VADD3(centroid,vertice[0],vertice[1],vertice[2]);
			 * VSCALE(centroid,centroid, third);
			 * 
			 * pnorms(normal,vertice,centroid,3,k);
			 */
d921 12
a932 7
			VSUB2(ab,vertice[1],vertice[0]);
			VSUB2(bc,vertice[2],vertice[1]);
			VCROSS(norm,ab,bc);
			VUNITIZE(norm);
			VSUB2( out, vertice[0], centroid );
			if( VDOT( out, norm ) < 0.0 ) {
				VREVERSE( norm, norm );
d935 3
a937 6
/* Use same normal for all vertices (flat shading) */  
			VMOVE(normal[0],norm);
			VMOVE(normal[1],norm);
			VMOVE(normal[2],norm);
			mk_poly(stdout,3,vertice,normal);
			
d939 2
a940 1
			if ((k % 2)== 0){
d942 13
a954 3
				VMOVE(vertice[1],vertice[2]);
				VSET(pt[0],x[k],y[k],z[k]);
				VMOVE(vertice[2],pt[0]);
a955 1
			else{
d957 6
a962 3
				VMOVE(vertice[0],vertice[2]);
				VSET(pt[0],x[k],y[k],z[k]);
				VMOVE(vertice[2],pt[0]);
d964 5
d973 17
a989 1
	/* Write out as region */
d991 2
a992 1
	proc_region(name);
d994 2
a995 1
	/* Process the mirrored surface ! (duplicates previous code) */
d997 4
a1000 1
	if(in[0].mirror != 0){
d1002 2
a1003 3
	  mrflg = 'y';
	  ctflg = 'n';
	  proc_sname (shflg,mrflg,mir_count+1,ctflg);
d1005 2
a1006 2
		mk_polysolid(stdout,name);
		mir_count++;
d1008 2
a1009 1
		(void) mk_addmember(name,&head,WMOP_UNION);
d1011 2
d1014 8
a1021 1
		for(k=2; k<=4; k++){
d1023 9
a1031 1
			VSET(pt[k-2],x[k],-y[k],z[k]);
d1034 2
a1035 3
		VMOVE(vertice[0],pt[0]);
		VMOVE(vertice[1],pt[1]);
		VMOVE(vertice[2],pt[2]);
d1037 2
a1038 4
		for ( k=0; k<3; k++ )
			centroid[k] = 0.0;
		for ( cpts=0, k=1; k<l; k++ ) {
			point_t last, tmp;
d1040 42
a1081 6
			VSET( tmp, x[k], -y[k], z[k] );
			if( VEQUAL( tmp, last ) )
				continue;
			VADD2( centroid, centroid, tmp );
			VMOVE( last, tmp );
			cpts++;
d1083 23
a1105 5
		VSCALE( centroid, centroid, 1.0/cpts );
		if( debug > 2 ) {
			fprintf(stderr,"%d: cpts=%d centroid %f %f %f\n",
			    in[0].cc+in[0].mirror, cpts, 
			    centroid[0], centroid[1], centroid[2] );
d1107 1
d1109 1
a1109 1
		for (k=5; k<(l); k++){
d1111 2
a1112 3
			if(VEQUAL(vertice[0],vertice[1])
			    ||VEQUAL(vertice[0],vertice[2])
			    ||VEQUAL(vertice[1],vertice[2])){
d1114 2
a1115 1
				if ((k % 2)== 0){
d1117 3
a1119 3
					VMOVE(vertice[1],vertice[2]);
					VSET(pt[0],x[k],-y[k],z[k]);
					VMOVE(vertice[2],pt[0]);
d1121 5
d1127 6
a1132 2
				}
				else{
d1134 8
a1141 3
					VMOVE(vertice[0],vertice[2]);
					VSET(pt[0],x[k],-y[k],z[k]);
					VMOVE(vertice[2],pt[0]);
d1143 2
d1146 9
a1154 1
				}
d1156 42
a1197 1
				/* fprintf(stderr,"Repeated Vertice, PUNTING\n");*/
a1198 1
			else{
d1200 3
a1202 5
				/* VADD3(centroid,vertice[0],vertice[1],vertice[2]);
				 * VSCALE(centroid,centroid, third);
				 *
				 * pnorms(normal,vertice,centroid,3,k);
				 */
d1204 8
a1211 7
				VSUB2(ab,vertice[1],vertice[0]);
				VSUB2(bc,vertice[2],vertice[1]);
				VCROSS(norm,ab,bc);
				VUNITIZE(norm);
				VSUB2( out, vertice[0], centroid );
				if( VDOT( out, norm ) < 0.0 ) {
					VREVERSE( norm, norm );
d1213 3
d1217 4
a1220 5
/* Use same normal for all vertices (flat shading) */  
				VMOVE(normal[0],norm);
				VMOVE(normal[1],norm);
				VMOVE(normal[2],norm);
				mk_poly(stdout,3,vertice,normal);
d1222 3
d1226 11
a1236 1
				if ((k % 2)== 0){
d1238 16
a1253 3
					VMOVE(vertice[1],vertice[2]);
					VSET(pt[0],x[k],-y[k],z[k]);
					VMOVE(vertice[2],pt[0]);
d1255 2
a1256 5
				}
				else{
					VMOVE(vertice[0],vertice[2]);
					VSET(pt[0],x[k],-y[k],z[k]);
					VMOVE(vertice[2],pt[0]);
d1258 13
d1272 36
a1307 1
				}
d1309 2
d1312 35
d1348 1
a1348 1
		proc_region(name);
d1350 150
a1499 1
	}/* if */
d1521 2
d1524 7
d1565 5
a1569 1

a1573 3
		for(k=1; k<=3; k++){
			VSET(pt[k-1],x[k],y[k],z[k]);
		}
a1574 4
		VMOVE(vertice[0],pt[0]);
		VMOVE(vertice[1],pt[1]);
		VMOVE(vertice[2],pt[2]);

d1580 1
a1580 3

		for ( k=0; k<3; k++ )
			centroid[k] = 0.0;
d1598 1
d1600 4
a1603 1
		for (k=4;(k<l); k++){
d1605 7
a1611 3
			VSUB2(ab,vertice[1],vertice[0]);
			VSUB2(bc,vertice[2],vertice[1]);
			ndot = VDOT( ab, bc )/(MAGNITUDE(ab) * MAGNITUDE(bc));
d1613 10
a1622 6
			if(VEQUAL(vertice[0],vertice[1])
			    ||VEQUAL(vertice[0],vertice[2])
			    ||VEQUAL(vertice[1],vertice[2])){

				;	/* do nothing */
				/* fprintf(stderr,"Repeated Vertice, PUNT\n"); */
d1624 1
a1624 1
			else if( ndot >= 0.999999 || ndot <= -0.999999 ) {
d1626 5
a1630 88
				;	/* do nothing */
				/* fprintf(stderr,"%s: collinear points, not made.\n", name); */

			}
			else {

				VSUB2(ab,vertice[1],vertice[0]);
				VSUB2(bc,vertice[2],vertice[1]);
				VSUB2(ca,vertice[0],vertice[2]);
				VSUB2(ac,vertice[0],vertice[2]);

				/* Plate Mode */

				VMOVE(arb6pt[0],vertice[0]);
				VMOVE(arb6pt[1],vertice[1]);
				VMOVE(arb6pt[2],vertice[2]);
				VMOVE(arb6pt[3],vertice[2]);

				VCROSS(norm,ab,ac);
				VUNITIZE(norm);

				VSUB2( out, vertice[0], centroid );
				VUNITIZE( out );
				outdot = VDOT( out, norm );
				if( debug > 2 )
					fprintf(stderr,
					    "%d: solid %d, unitized outward normal dot product is %f\n",
					    in[0].cc, count+1, outdot );

				/* flat plate, use center of description */
				if( outdot <= 0.001 &&  outdot >= -0.001 ) {
					if( debug > 0 )
						fprintf(stderr,
						    "%d: solid %d, using optional Centroid\n", 
						    in[0].cc, count+1 );
					VSUB2( out, vertice[0], Centroid );
					VUNITIZE( out );
					outdot = VDOT( out, norm );
				}

				if( outdot > 0.0 ) {
					VREVERSE( norm, norm );
				}

				if( rev_norms ){
					VREVERSE( norm, norm );
				}

				if (aflg > 0) {
					if (in[0].rsurf_thick == 0) {
						in[0].rsurf_thick = 1;
					}
				}

				VSCALE(norm,norm,thk[k-1]);

				VADD2(arb6pt[4],norm,arb6pt[0]);
				VADD2(arb6pt[5],norm,arb6pt[1]);
				VADD2(arb6pt[6],norm,arb6pt[2]);
				VMOVE(arb6pt[7],arb6pt[6]);

				/* name solids */

				shflg = 't';
				mrflg = 'n';
				ctflg = 'n';
				proc_sname (shflg,mrflg,count+1,ctflg);

				/* make solids */

				mk_arb8(stdout,name,arb6pt);
				count++;

				(void) mk_addmember(name,&head,WMOP_UNION);

				/* For every num_unions triangles, make a separate region */

				if ((count % num_unions) == 0)
					proc_region(name);


			}

			VMOVE(vertice[0],vertice[1]);
			VMOVE(vertice[1],vertice[2]);
			VSET(pt[0],x[k],y[k],z[k]);
			VMOVE(vertice[2],pt[0]);

a1631 133
		/* Make a region for leftover triangles (<num_unions) */

		if ((count % num_unions) != 0)
			proc_region(name);


		if(in[0].mirror != 0){			/* Mirror Processing! */

			for(k=1; k<=3; k++){
				VSET(pt[k-1],x[k],-y[k],z[k]);
			}

			VMOVE(vertice[0],pt[0]);
			VMOVE(vertice[1],pt[1]);
			VMOVE(vertice[2],pt[2]);

			for ( k=0; k<3; k++ )
				centroid[k] = 0.0;
			for ( cpts=0, k=1; k<l; k++ ) {
				point_t last, tmp;

				VSET( tmp, x[k], -y[k], z[k] );
				if( VEQUAL( tmp, last ) )
					continue;
				VADD2( centroid, centroid, tmp );
				VMOVE( last,tmp );
				cpts++;
			}
			VSCALE( centroid, centroid, 1.0/cpts );
			if( debug > 2 ) {
				fprintf(stderr,"%d: cpts=%d centroid %f %f %f\n",
				    in[0].cc + in[0].mirror, cpts, 
				    centroid[0], centroid[1], centroid[2] );
			}


			for (k=4; k<(l); k++){

				VSUB2(ab,vertice[1],vertice[0]);
				VSUB2(bc,vertice[2],vertice[1]);
				ndot = VDOT( ab, bc )/(MAGNITUDE(ab) * MAGNITUDE(bc));

				if(VEQUAL(vertice[0],vertice[1])
				    ||VEQUAL(vertice[0],vertice[2])
				    ||VEQUAL(vertice[1],vertice[2])){

					;	/* do nothing */
					/* fprintf(stderr,"Repeated Vertice, PUNT\n");*/
				}
				else if( ndot >= 0.999999 || ndot <= -0.999999 ) {

					;	/* do nothing */
					/* fprintf(stderr,"%s: collinear points, not made.\n", name); */

				}
				else {

					VSUB2(ab,vertice[1],vertice[0]);
					VSUB2(bc,vertice[2],vertice[1]);
					VSUB2(ca,vertice[0],vertice[2]);
					VSUB2(ac,vertice[0],vertice[2]);

					VMOVE(arb6pt[0],vertice[0]);
					VMOVE(arb6pt[1],vertice[1]);
					VMOVE(arb6pt[2],vertice[2]);
					VMOVE(arb6pt[3],vertice[2]);

					VCROSS(norm,ac,ab);    /* Reversed normals */
					/* in mirror case */
					VUNITIZE(norm);

					VSUB2( out, vertice[0], centroid );
					VUNITIZE( out );
					outdot = VDOT( out, norm );
					if( debug > 2 )
						fprintf(stderr,
						    "%d: solid %d, unitized outward normal dot product is %f\n",
						    in[0].cc+in[0].mirror, mir_count+1, outdot );

					/* flat plate, use center of description */
					if( outdot <= 0.001 &&  outdot >= -0.001 ) {
						if( debug > 0 )
							fprintf(stderr,
							    "%d: solid %d, using optional Centroid\n", 
							    in[0].cc+in[0].mirror, mir_count+1 );
						VSUB2( out, vertice[0], Centroid );
						VUNITIZE( out );
						outdot = VDOT( out, norm );
					}

					if( outdot > 0.0 ) {
						VREVERSE( norm, norm );
					}

					if( rev_norms ){
						VREVERSE( norm, norm );
					}

					VSCALE(norm,norm,thk[k-1]);

					VADD2(arb6pt[4],norm,arb6pt[0]);
					VADD2(arb6pt[5],norm,arb6pt[1]);
					VADD2(arb6pt[6],norm,arb6pt[2]);
					VMOVE(arb6pt[7],arb6pt[6]);


					mrflg = 'y';
					ctflg = 'n';
					proc_sname (shflg,mrflg,mir_count+1,ctflg);

					mk_arb8(stdout,name,arb6pt);
					mir_count++;

					(void) mk_addmember(name,&head,WMOP_UNION);



					if ((mir_count % num_unions) == 0)
						proc_region(name);


				}

				VMOVE(vertice[0],vertice[1]);
				VMOVE(vertice[1],vertice[2]);
				VSET(pt[0],x[k],-y[k],z[k]);
				VMOVE(vertice[2],pt[0]);

			}
			if ((mir_count % num_unions) != 0)
				proc_region(name);

		}/* if mirror */
d1652 1
d1681 1
a1681 1
		proc_sname (shflg,mrflg,count+1,ctflg);
d1722 1
a1722 1
		proc_sname (shflg,mrflg,mir_count+1,ctflg);
d1752 1
d1767 1
a1767 1
		proc_sname (shflg,mrflg,count+1,ctflg);
d1788 1
a1788 1
				proc_sname (shflg,mrflg,count,ctflg);
d1822 1
a1822 1
		proc_sname (shflg,mrflg,mir_count+1,ctflg);
d1838 1
a1838 1
				proc_sname (shflg,mrflg,mir_count,ctflg);
d1882 1
d1911 1
a1911 1
		proc_sname (shflg,mrflg,count+1,ctflg);
d1923 1
a1923 1
			proc_sname (shflg,mrflg,count,ctflg);
d2004 1
a2004 1
		proc_sname (shflg,mrflg,mir_count+1,ctflg);
d2014 1
a2014 1
			proc_sname (shflg,mrflg,mir_count+1,ctflg);
d2102 1
d2127 1
a2127 1
		proc_sname (shflg,mrflg,count+1,ctflg);
d2163 1
a2163 1
				proc_sname (shflg,mrflg,count,ctflg);
d2305 1
a2305 1
		proc_sname (shflg,mrflg,mir_count+1,ctflg);
d2333 1
a2333 1
				proc_sname (shflg,mrflg,mir_count,ctflg);
d2481 1
d2549 1
a2549 1
		proc_sname (shflg,mrflg,count+1,ctflg);
d2595 1
a2595 1
		proc_sname (shflg,mrflg,mir_count+1,ctflg);
a2674 48
 *     This subroutine generates solid names with annotations for sidedness as
 *      required.
 */
proc_sname(shflg,mrflg,cnt,ctflg)
char shflg,mrflg,ctflg;
int  cnt;
{
	char side;

	/* shflg == identifies shape process which called this function
	 * mrflg == indicates called by "as-modeled" pass or mirrored pass
	 * cnt   == suffix indentifier for the name
	 * ctflg == isolates internal cutting solids from regular solids
	 * name == solid name
	 * side  == left or right sidedness
	 */

	if (((mrflg == 'n') && (in[0].y >= 0)) ||
	    ((mrflg == 'y') && (in[0].y < 0))) {
	  side = 'l';
	}
	else {
	  side = 'r';
	}

	if (in[0].mirror >= 0) {
	  if ((mrflg == 'n') && (ctflg == 'n')) {
	    sprintf(name,"%c.%.4d.s%.2d",shflg,in[0].cc,cnt);
	  }
	  else if ((mrflg == 'n') && (ctflg == 'y')) {
	    sprintf(name,"%c.%.4d.c%.2d",shflg,in[0].cc,cnt);
	  }
	  else if ((mrflg == 'y') && (ctflg == 'n')) {
	    sprintf(name,"%c.%.4d.s%.2d",shflg,(in[0].cc+in[0].mirror),cnt);
	  }
	  else {
	    sprintf(name,"%c.%.4d.c%.2d",shflg,(in[0].cc+in[0].mirror),cnt);
	  }
	}
	else if (ctflg == 'n') {
	  sprintf(name,"%c%c.%.4d.s%.2d",side,shflg,in[0].cc,cnt);
	}
	else {
	  sprintf(name,"%c%c.%.4d.c%.2d",side,shflg,in[0].cc,cnt);
	}
}

/*
d2755 1
a2755 2
proc_label(name1,labelfile)
char *name1;
d2765 1
a2765 1
		proc_label(name1,labelfile);
d2769 12
a2780 14
	if( cur_series == (in[0].cc / 1000)){

		while( *name1++ != '.' )
			;
		cc = name1;

		if ((atoi(cc)) == in[0].cc){

			/* no mirror components */

			if( labelfile != NULL )
				sprintf(gname,"%s", nm[in[0].cc].ug );
			else
				sprintf(gname,"#%.4d",in[0].cc);
d2784 2
a2785 12
		else{
			/* mirrored components */

			if( labelfile != NULL ) {
				sprintf(gname,"%s", nm[in[0].cc].ug );
				sprintf(mgname,"%s", nm[in[0].cc + in[0].mirror].ug );
			}
			else {
				sprintf(gname,"#%.4d",in[0].cc);
				sprintf(mgname,"#%.4d",(in[0].cc + in[0].mirror));
			}
			mk_lcomb(stdout,gname,&heada,0,"","",0,0);
a2786 1
			(void) mk_addmember(gname,&headd,WMOP_UNION);
d2797 1
a2797 1
		proc_label(name1,labelfile);
d3060 1
a3060 1
		free( (char *)slist );
d3087 1
a3087 1
		slist = (struct subtract_list *)malloc(sizeof(struct subtract_list));
@


1.4
log
@Added changes from Bob Strausser (Survice Engineering)
@
text
@d36 1
a36 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/patch-g.c,v 1.3 93/10/26 03:05:04 mike Exp Locker: jra $ (BRL)";
d378 1
a378 1
					proc_triangle(in,i);
d381 1
a381 1
					proc_plate(in,i);
d391 1
a391 1
				proc_wedge(in,i);
d396 1
a396 1
				proc_sphere(in,i);
d401 1
a401 1
				proc_box(in,i);
d406 1
a406 1
				proc_cylin(in,i);
d411 1
a411 1
				proc_rod(in,i);
d425 1
a425 1
				proc_label(in,name,labelfile);
d472 1
a472 2
proc_triangle(in,cnt)
struct input in[5000];
a477 1
	int	count = 0;
d481 3
d485 6
d496 1
a496 1
	proc_sname (in,shflg,mrflg,count+1,ctflg);
d637 1
a637 1
	proc_region(in,name);
a642 1
	  count = 0;
d645 1
a645 1
	  proc_sname (in,shflg,mrflg,count+1,ctflg);
d648 1
a648 1
		count++;
d747 1
a747 1
		proc_region(in,name);
d750 1
a750 1

d756 1
a756 2
proc_plate(in,cnt)
struct input in[5000];
d766 3
a768 1
	int count = 0;
d772 6
d926 1
a926 1
				proc_sname (in,shflg,mrflg,count+1,ctflg);
d938 1
a938 1
					proc_region(in,name);
d952 1
a952 1
			proc_region(in,name);
a956 1
			count = 0;
d1026 1
a1026 1
						    in[0].cc+in[0].mirror, count+1, outdot );
d1033 1
a1033 1
							    in[0].cc+in[0].mirror, count+1 );
d1057 1
a1057 1
					proc_sname (in,shflg,mrflg,count+1,ctflg);
d1060 1
a1060 1
					count++;
d1066 2
a1067 2
					if ((count % num_unions) == 0)
						proc_region(in,name);
d1078 2
a1079 2
			if ((count % num_unions) != 0)
				proc_region(in,name);
d1081 1
a1081 1
		}/* if */
d1083 2
d1090 1
a1090 2
proc_wedge(in,cnt)
struct input in[5000];
d1098 3
a1100 1
	int count = 0;
d1103 6
d1130 1
a1130 1
		proc_sname (in,shflg,mrflg,count+1,ctflg);
d1142 1
a1142 1
			proc_region(in,name);
d1148 1
a1148 1
		proc_region(in,name);
a1151 2
	count = 0;

d1171 1
a1171 1
		proc_sname (in,shflg,mrflg,count+1,ctflg);
d1174 1
a1174 1
		count++;
d1178 2
a1179 2
		if ((count % num_unions) == 0)
			proc_region(in,name);
d1182 3
a1184 1
		proc_region(in,name);
d1191 1
a1191 2
proc_sphere(in,cnt)
struct input in[5000];
d1196 1
a1196 1
	int i,count;
d1198 3
d1202 5
a1206 1
	for( i=count=0 ; i < cnt ; i+=2 ){
d1208 3
d1215 1
a1215 1
		proc_sname (in,shflg,mrflg,count+1,ctflg);
d1236 1
a1236 1
				proc_sname (in,shflg,mrflg,count,ctflg);
d1251 1
a1251 1
				proc_region(in,name);
d1261 1
a1261 1
		proc_region(in,name);
d1263 1
a1263 1
	for( i=count=0; i < cnt ; i+= 2 ) {
d1270 1
a1270 1
		proc_sname (in,shflg,mrflg,count+1,ctflg);
d1276 1
a1276 1
			count++;
d1286 1
a1286 1
				proc_sname (in,shflg,mrflg,count,ctflg);
d1298 2
a1299 2
			if( (count % num_unions) == 0 )
				proc_region(in,name);
d1308 1
a1308 1
		proc_region(in,name);
d1310 1
d1316 1
a1316 2
proc_box(in,cnt)
struct input in[5000];
a1325 1
	int count = 0;
d1327 3
d1331 7
d1358 1
a1358 1
		proc_sname (in,shflg,mrflg,count+1,ctflg);
d1370 1
a1370 1
			proc_sname (in,shflg,mrflg,count,ctflg);
d1423 1
a1423 1
			proc_region(in,name);
d1429 1
a1429 1
		proc_region(in,name);
a1433 2
	count = 0;

d1451 1
a1451 1
		proc_sname (in,shflg,mrflg,count+1,ctflg);
d1454 1
a1454 1
		count++;
d1461 1
a1461 1
			proc_sname (in,shflg,mrflg,count+1,ctflg);
d1511 2
a1512 2
		if ((count % num_unions) == 0)
			proc_region(in,name);
d1515 2
a1516 2
		proc_region(in,name);

d1532 1
a1532 2
proc_cylin(in,cnt)
struct input in[5000];
a1542 1
	int count = 0;		/* count for sub-regions, <=num_unions per region */
d1546 3
d1550 8
a1557 1
	slist = get_subtract(in,cnt);
d1573 1
a1573 1
		proc_sname (in,shflg,mrflg,count+1,ctflg);
d1609 1
a1609 1
				proc_sname (in,shflg,mrflg,count,ctflg);
d1733 1
a1733 1
			proc_region(in,name);
d1740 1
a1740 1
		proc_region(in,name);
a1743 1
	count = 0;
d1751 2
a1752 2
		proc_sname (in,shflg,mrflg,count+1,ctflg);
		count++;
d1779 1
a1779 1
				proc_sname (in,shflg,mrflg,count,ctflg);
d1900 2
a1901 2
		if ((count % num_unions) == 0 && (RT_LIST_NEXT_NOT_HEAD(&head, &head.l)))
			proc_region(in,name);
d1906 1
a1906 1
		proc_region(in,name);
d1908 1
d1914 1
a1914 2
proc_rod(in,cnt)
struct input in[5000];
d1918 1
a1918 1
	int k,l,count,index,regnum;
d1924 3
d1928 7
d1983 1
a1983 1
	for(k=1,count=0 ; k < (l-1) ; k++){
d1994 1
a1994 1
		proc_sname (in,shflg,mrflg,count+1,ctflg);
d2014 1
a2014 3
			regnum = ( num_unions > 1 ? 
			    count / num_unions : count / num_unions - 1 );
			proc_rod_region(in,name,regnum);
d2022 1
a2022 3
		regnum = ( num_unions > 1 ?
		    count / num_unions + 1 : count / num_unions );
		proc_rod_region(in,name,regnum);
d2027 1
a2027 1
	for( k=1,count=0 ; k < (l-1) ; k++){
d2040 1
a2040 1
		proc_sname (in,shflg,mrflg,count+1,ctflg);
d2043 1
a2043 1
		count++;
d2058 1
a2058 1
		if( count > 1 && (count % num_unions) == 0 ) {
d2060 1
a2060 3
			regnum = ( num_unions > 1 ?
			    count / num_unions : count / num_unions - 1 );
			proc_rod_region( in, name, regnum );
d2069 1
a2069 3
		regnum = ( num_unions > 1 ?
		    count / num_unions + 1 : count / num_unions );
		proc_rod_region(in,name,regnum);
d2072 1
d2123 1
a2123 2
proc_sname(in,shflg,mrflg,cnt,ctflg)
struct input in[5000];
a2125 1

a2135 1
rt_log( "In proc_sname; %c %c %c %d\n" , shflg,mrflg,ctflg,cnt );
a2164 1
rt_log( "\tname = %s\n" , name );
d2175 2
a2176 2
proc_region(in,name1)
struct input in[5000];
d2180 7
a2186 4
	char *tmpname,*chkroot;
	int cnt,cc;
	struct  wmember *wp;
rt_log( "In proc_region: name1 = %s\n" , name1 );
a2187 9
	/* tmpname == region name - '.s#'
	 * chkroot == component code number
	 * name1    == solid number
	 */
	tmpname = chkroot = name1;
	while( *name1++ != '.' )
		;
	chkroot = name1;
	cc = atoi( chkroot );
d2189 2
a2190 5
	while( *name1 != '.' )
		name1++;
	*name1 = '\0';
	name1 += 2;
	cnt = (atoi(name1) - 1) / num_unions + 1;
d2192 1
a2192 2
	sprintf(cname,"%s.r%.2d",tmpname,cnt);
rt_log( "\tcname = %s\n" , cname );
d2194 10
a2203 1
	for( RT_LIST_FOR( wp, wmember, &head.l ) )
d2205 2
a2206 1
		rt_log( "\t\t%c %s\n" , wp->wm_op , wp->wm_name );
d2209 4
a2212 2
	if( nm[cc].matcode != 0 ) {
		mk_lrcomb(stdout, cname, &head, 1, 0, 0, 0, cc, 0, nm[cc].matcode, nm[cc].eqlos, 0);
d2214 4
a2217 2
	else {
		mk_lrcomb(stdout, cname, &head, 1, 0, 0, 0, cc, 0, 2, 100, 0);
a2219 6
	if ( cc == in[0].cc){
		(void) mk_addmember(cname,&heada,WMOP_UNION);
	}
	else{
		(void) mk_addmember(cname,&headb,WMOP_UNION);
	}
a2220 40
	name1 -= 2;
	*name1 = '.';
}

/*
 *     This subroutine takes previously generated solid names and combines them
 *	into a common region identity.  Format of the make_region command call
 *	requires in order: output file name, input region name, link file of solids,
 *	region/group flag, material name, material parameters, RGB color assignment, region id #,
 *	aircode, material code, LOS, and inheritance flag.  The region is then 
 *	added to a hold file for combination into groups in another process.        
 *
 *	NOTE: This is the same as the proc_region() subroutine, except for
 * 	a change to take the region numbering from the input parameters for
 *	the special case of rods.
 */
proc_rod_region(in,name1,regnum)
struct input in[5000];
char *name1;
int regnum;

{
	char *tmpname,*chkroot;
	int cnt,cc;

	/* tmpname == region name - '.s#'
	 * chkroot == component code number
	 * name1    == solid number
	 */
	tmpname = chkroot = name1;
	while( *name1++ != '.' )
		;
	chkroot = name1;
	cc = atoi( chkroot );

	while( *name1 != '.' )
		name1++;
	*name1 = '\0';

	sprintf(cname,"%s.r%.2d",tmpname,regnum);
d2228 1
a2228 1
	if ((atoi(chkroot)) == in[0].cc){
d2235 1
a2235 1
	*name1 = '.';
d2248 1
a2248 2
proc_label(in,name1,labelfile)
struct input in[5000];
d2259 1
a2259 1
		proc_label(in,name1,labelfile);
d2304 1
a2304 1
		proc_label(in,name1,labelfile);
d2416 1
a2416 2
inside_cyl(in,i,j)
struct input in[5000];
a2513 1
rt_log( "In mk_cyladdmember: name1 = %s\n" , name1 );
a2514 1
rt_log( "\tjust add to list\n" );
a2519 1
rt_log( "\tcc = %d , solnum = %d\n" , cc , solnum );
d2534 1
a2534 8
#if 0
			if( slist->inmirror != 0 )
				sprintf(tmpname,"%cc.%.4d.s%.2d",
				    (mirflag ? 'R' : 'L'),cc,slist->insolid );
			else
#endif
				sprintf(tmpname,"c.%.4d.s%.2d",cc,slist->insolid );
rt_log( "\t\tSubtract %s\n" , tmpname );
d2556 1
a2556 2
get_subtract( in, cnt )
struct input in[5000];
d2575 1
a2575 1
			if( inside_cyl(in,i,j) )
@


1.3
log
@ANSI C
@
text
@d5 13
d22 3
d36 1
a36 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/patch-g.c,v 1.2 93/10/26 03:02:43 mike Exp Locker: mike $ (BRL)";
d237 2
a238 2
	     statement into the while loop and made a check flag "done" to verify
	     that all elements are processed prior to falling out of the "while".      */
d244 6
a249 4
	/*
 *	This section loads the label file into an array
 *	 needed to label processed solids, regions, and groups.
*/
d361 3
a363 3
		if ( done || (in[i].cc != in[i-1].cc) ||
		    ((in[i].surf_type > 3) &&
		    (in[i].surf_type != in[i-1].surf_type)) ) {
d385 2
a386 2
			case 4: 	/* 24 pt cylinder (not processed) */
				fprintf(stderr,"component %.4d: 24 pt cylinder not implemented\n",in[i-1].cc);
a459 1

d461 3
a463 2
 *   For non-mirrored solids:	surface type code . component code number . "S"count
 *   For mirrorred solids:	side identifier & surface type code . component code number . "S"count
d473 1
a473 1
struct input in[500];
d481 2
a482 1
	vect_t	norm,out;
d484 1
d486 4
a489 1
	/* assign solids name */
a490 9
	if(in[0].mirror != 0) {

		sprintf(name,"Lf.%.4d.s%.2d",in[0].cc,(count + 1));
	}

	else {
		sprintf(name,"f.%.4d.s%.2d",in[0].cc,(count + 1));
	}

d636 4
a639 1
		count = 0;
a640 9
		if(in[0].mirror >= 1) {

			sprintf(name,"Rf.%.4d.s%.2d",(in[0].cc + in[0].mirror),(count + 1));
		}

		else {
			sprintf(name,"Rf.%.4d.s%.2d",in[0].cc,(count + 1));
		}

d751 1
a751 1
struct input in[500];
d763 1
d765 2
a766 1
	if ((in[0].rsurf_thick > 0)||(aflg > 0)){  /* check for phantom armor */
d910 4
a913 1
				if(in[0].mirror != 0) {
a914 7
					sprintf(name,"Lt.%.4d.s%.2d",in[0].cc,(count + 1));
				}

				else {
					sprintf(name,"t.%.4d.s%.2d",in[0].cc,(count + 1));
				}

d1043 3
a1045 1
					if(in[0].mirror >= 1) {
a1046 9
						sprintf(name,"Rt.%.4d.s%.2d",(in[0].cc + in[0].mirror),(count + 1));
					}

					else {
						sprintf(name,"Rt.%.4d.s%.2d",in[0].cc,(count + 1));
					}



d1077 1
a1077 1
struct input in[500];
d1086 1
d1099 1
a1099 1
		VADD4(pt8[6],ab,ac,ad,pt8[0]);
d1101 1
a1101 1
		VMOVE(pt8[7],pt8[6]);
d1106 4
a1109 1
		if(in[k].mirror != 0) {
a1110 6
			sprintf(name,"Lw.%.4d.s%.2d",in[k].cc,(count + 1));
		}
		else {
			sprintf(name,"w.%.4d.s%.2d",in[k].cc,(count + 1));
		}

d1145 1
a1145 1
		VADD4(pt8[6],ab,ac,ad,pt8[0]);
d1147 1
a1147 1
		VMOVE(pt8[7],pt8[6]);
d1150 3
a1152 1
		if(in[k].mirror >= 1) {
a1153 6
			sprintf(name,"Rw.%.4d.s%.2d",(in[k].cc + in[k].mirror),(count + 1));
		}
		else {
			sprintf(name,"Rw.%.4d.s%.2d",in[k].cc,(count + 1));
		}

d1171 1
a1171 1
struct input in[500];
d1177 1
d1182 4
a1187 9
		if(in[i].mirror != 0) {

			sprintf(name,"Ls.%.4d.s%.2d",in[i].cc,count);
		}

		else {
			sprintf(name,"s.%.4d.s%.2d",in[i].cc,count);
		}

d1205 2
a1206 1
				if(in[i].mirror != 0) {
a1207 7
					sprintf(tname,"Ls.%.4d.s%.2din",in[i].cc,count);
				}

				else {
					sprintf(tname,"s.%.4d.s%.2din",in[i].cc,count);
				}

d1211 2
a1212 2
					mk_sph(stdout,tname,center,rad);
					mk_addmember(tname, &head,WMOP_SUBTRACT);
d1238 3
a1240 2
		count++;
		if(in[i].mirror >= 1) {
a1241 6
			sprintf(name,"Rs.%.4d.s%.2d",in[i].cc + in[i].mirror,count);
		}
		else {
			sprintf(name,"Rs.%.4d.s%.2d",in[i].cc,count);
		}

d1246 1
d1255 2
a1256 1
				if(in[i].mirror > 0) {
a1257 6
					sprintf(tname,"Rs.%.4d.s%.2din",in[i].cc + in[i].mirror,count);
				}
				else {
					sprintf(tname,"Rs.%.4d.s%.2din",in[i].cc,count);
				}

d1259 2
a1260 2
					mk_sph(stdout,tname,center,rad);
					mk_addmember(tname, &head,WMOP_SUBTRACT);
d1286 1
a1286 1
struct input in[500];
d1297 1
d1316 4
a1319 1
		if(in[k].mirror != 0) {
a1320 7
			sprintf(name,"Lb.%.4d.s%.2d",in[k].cc,(count + 1));
		}

		else {
			sprintf(name,"b.%.4d.s%.2d",in[k].cc,(count + 1));
		}

d1330 2
a1331 1
			if(in[k].mirror != 0) {
a1332 8
				sprintf(tname,"Lb.%.4d.s%.2din",in[k].cc,count);
			}

			else {

				sprintf(tname,"b.%.4d.s%.2din",in[k].cc,count);
			}

d1372 2
a1373 2
				mk_arb8( stdout, tname, pt8 );
				mk_addmember(tname,&head,WMOP_SUBTRACT);
d1412 3
a1414 1
		if(in[k].mirror >= 1) {
a1415 6
			sprintf(name,"Rb.%.4d.s%.2d",(in[k].cc + in[k].mirror),(count + 1));
		}
		else {
			sprintf(name,"Rb.%.4d.s%.2d",in[k].cc,(count + 1));
		}

d1423 2
a1424 1
			if(in[k].mirror != 0) {
a1425 8
				sprintf(tname,"Rb.%.4d.s%.2din",in[k].cc,count);
			}

			else {

				sprintf(tname,"b.%.4d.s%.2din",in[k].cc,count);
			}

d1465 2
a1466 2
				mk_arb8( stdout, tname, pt8 );
				mk_addmember(tname,&head,WMOP_SUBTRACT);
d1496 1
a1496 1
struct input in[500];
d1510 1
a1523 2
		count++;

d1525 4
a1528 6
		if(in[k].mirror != 0) {
			sprintf(name,"Lc.%.4d.s%.2d",in[k].cc,count);
		}
		else {
			sprintf(name,"c.%.4d.s%.2d",in[k].cc,count);
		}
d1530 1
d1539 11
a1549 1
			if((in[k+2].x > 0)&&(in[k+2].y > 0)){
d1551 1
a1551 1
				/* make solid */
d1553 2
a1554 2
				mk_trc_top(stdout,name,base,top,in[k+2].x,in[k+2].y);
				mk_cyladdmember(name,&head,slist,0);
d1556 3
a1558 3
				/* mk_trc_top destroys the values of base,top */
				VSET(base,in[k].x,in[k].y,in[k].z);
				VSET(top,in[k+1].x,in[k+1].y,in[k+1].z);
d1560 1
a1560 1
				j = (int)(in[k+2].z/mmtin);
d1562 3
a1564 2
				if (in[k].surf_mode== '-'){     /* Plate mode */
					switch(j){
d1566 1
a1566 1
					case 0: /* Both ends open */
d1568 1
a1568 3
						if(in[k].mirror != 0) {
							sprintf(tname,"Lc.%.4d.s%.2din",in[k].cc,count);
						}
d1570 8
a1577 3
						else {
							sprintf(tname,"c.%.4d.s%.2din",in[k].cc,count);
						}
d1579 8
a1586 8
						rad1 = in[k+2].x;
						rad2 = in[k+2].y;
						VSUB2(ab,top,base);
						ht = MAGNITUDE( ab );
						thick = in[k+2].rsurf_thick / ht * 
						    hypot( ht, rad2-rad1 );
						srad1 = rad1 - thick;
						srad2 = rad2 - thick;
d1588 1
a1588 8
						if( srad1 > 0.0 && srad2 > 0.0 ) {
							mk_trc_top(stdout,tname,base,top,srad1,srad2);
							mk_addmember(tname,&head,WMOP_SUBTRACT);
						}
						else {
							mk_addmember(name,&headf,WMOP_UNION);
						}
						break;
d1590 5
a1594 2
					case 1: /* Base closed, top open */
						if(in[k].mirror != 0) {
d1596 9
a1604 2
							sprintf(tname,"Lc.%.4d.s%.2din",in[k].cc,count);
						}
d1606 9
a1614 8
						else {
							sprintf(tname,"c.%.4d.s%.2din",in[k].cc,count);
						}
						VSUB2(ab,top,base);
						ht = MAGNITUDE( ab );
						VUNITIZE(ab);
						VSCALE(ab,ab,in[k].rsurf_thick);
						VADD2(sbase,base,ab);
d1616 5
a1620 9
						rad1 = in[k+2].x;
						rad2 = in[k+2].y;
						VSUB2(ab,top,sbase);
						sht = MAGNITUDE( ab );
						srad1 = rad2 - sht / ht * (rad2 - rad1);
						thick = in[k+2].rsurf_thick / ht * 
						    hypot( ht, rad2-rad1 );
						srad1 = srad1 - thick;
						srad2 = rad2 - thick;
d1622 9
a1630 10
						if( srad1 > 0.0 && srad2 > 0.0 && !VEQUAL(sbase,top) ) {
							mk_trc_top(stdout,tname,sbase,top,srad1,srad2);
							mk_addmember(tname,&head,WMOP_SUBTRACT);
						}
						else {
							mk_addmember(name,&headf,WMOP_UNION);
						}
						break;
					case 2: /* Base open, top closed */
						if(in[k].mirror != 0) {
d1632 8
a1639 2
							sprintf(tname,"Lc.%.4d.s%.2din",in[k].cc,count);
						}
d1641 1
a1641 8
						else {
							sprintf(tname,"c.%.4d.s%.2din",in[k].cc,count);
						}
						VSUB2(ab,base,top);
						ht = MAGNITUDE( ab );
						VUNITIZE(ab);
						VSCALE(ab,ab,in[k].rsurf_thick);
						VADD2(stop,top,ab);
d1643 9
a1651 9
						rad1 = in[k+2].x;
						rad2 = in[k+2].y;
						VSUB2(ab,stop,base);
						sht = MAGNITUDE( ab );
						srad2 = rad1 - sht / ht * (rad1 - rad2);
						thick = in[k+2].rsurf_thick / ht * 
						    hypot( ht, rad2-rad1 );
						srad1 = rad1 - thick;
						srad2 = srad2 - thick;
d1653 10
a1662 8
						if( srad1 > 0.0 && srad2 > 0.0 && !VEQUAL(base,stop) ) {
							mk_trc_top(stdout,tname,base,stop,srad1,srad2);
							mk_addmember(tname,&head,WMOP_SUBTRACT);
						}
						else {
							mk_addmember(name,&headf,WMOP_UNION);
						}
						break;
d1664 8
a1671 2
					case 3: /* Both closed */
						if(in[k].mirror != 0) {
d1673 3
a1675 2
							sprintf(tname,"Lc.%.4d.s%.2din",in[k].cc,count);
						}
d1677 3
a1679 43
						else {
							sprintf(tname,"c.%.4d.s%.2din",in[k].cc,count);
						}
						VSUB2(ab,top,base);
						VSUB2(bc,base,top);
						ht = MAGNITUDE( ab );
						VUNITIZE(ab);
						VUNITIZE(bc);
						VSCALE(ab,ab,in[k].rsurf_thick);
						VSCALE(bc,bc,in[k].rsurf_thick);
						VADD2(sbase,base,ab);
						VADD2(stop,top,bc);

						rad1 = in[k+2].x;
						rad2 = in[k+2].y;
						VSUB2(ab,stop,base);
						sht = MAGNITUDE( ab );
						srad1 = rad2 - sht / ht * (rad2 - rad1);
						srad2 = rad1 - sht / ht * (rad1 - rad2);
						thick = in[k+2].rsurf_thick / ht * 
						    hypot( ht, rad2-rad1 );
						srad1 = srad1 - thick;
						srad2 = srad2 - thick;

						if( srad1 > 0.0 && srad2 > 0.0 && !VEQUAL(sbase,stop) ) {
							mk_trc_top(stdout,tname,sbase,stop,srad1,srad2);
							mk_addmember(tname,&head,WMOP_SUBTRACT);
						}
						else {
							mk_addmember(name,&headf,WMOP_UNION);
						}
						break;

					default:
						fprintf(stderr,"Unknown cylinder mode\n");
						break;

					}         /* end switch */
				}     		  /* end - plate mode modifications */
			} else {
				fprintf(stderr,"Bad Cylinder Radius for %s\n",name);
			}
		}         			  /* Degenerate case check */
d1694 1
a1694 1
	if ((count % num_unions) == 0 && (RT_LIST_NEXT_NOT_HEAD(&head, &head.l)))
d1705 3
a1709 8
		if(in[k].mirror >= 1) {

			sprintf(name,"Rc.%.4d.s%.2d",(in[k].cc + in[k].mirror),count);
		}
		else {
			sprintf(name,"Rc.%.4d.s%.2d",in[k].cc,count);
		}

d1715 8
a1722 1
			if((in[k+2].x > 0)&&(in[k+2].y > 0)){
d1724 2
a1725 2
				mk_trc_top(stdout,name,base,top,in[k+2].x,in[k+2].y);
				mk_cyladdmember(name,&head,slist,1);
d1727 3
a1729 3
				/* mk_trc_top destroys the values of base,top */
				VSET(base,in[k].x,-in[k].y,in[k].z);
				VSET(top,in[k+1].x,-in[k+1].y,in[k+1].z);
d1731 1
a1731 1
				j = (int)(in[k+2].z/mmtin);
d1733 3
a1735 2
				if (in[k].surf_mode== '-'){ 	/* Plate mode */
					switch(j){
d1737 1
a1737 1
					case 0: /* Both ends open */
d1739 1
a1739 6
						if(in[k].mirror >= 1) {
							sprintf(tname,"Rc.%.4d.s%.2din",(in[k].cc + in[k].mirror),count);
						}
						else {
							sprintf(tname,"Rc.%.4d.s%.2din",in[k].cc,count);
						}
d1741 8
a1748 8
						rad1 = in[k+2].x;
						rad2 = in[k+2].y;
						VSUB2(ab,top,base);
						ht = MAGNITUDE( ab );
						thick = in[k+2].rsurf_thick / ht * 
						    hypot( ht, rad2-rad1 );
						srad1 = rad1 - thick;
						srad2 = rad2 - thick;
d1750 8
a1757 8
						if( srad1 > 0.0 && srad2 > 0.0 ) {
							mk_trc_top(stdout,tname,base,top,srad1,srad2);
							mk_addmember(tname,&head,WMOP_SUBTRACT);
						}
						else {
							mk_addmember(name,&headf,WMOP_UNION);
						}
						break;
d1759 1
a1759 2
					case 1: /* Base closed, top open */
						if(in[k].mirror >= 1) {
d1761 5
a1765 10
							sprintf(tname,"Rc.%.4d.s%.2din",(in[k].cc + in[k].mirror),count);
						}
						else {
							sprintf(tname,"Rc.%.4d.s%.2din",in[k].cc,count);
						}
						VSUB2(ab,top,base);
						ht = MAGNITUDE( ab );
						VUNITIZE(ab);
						VSCALE(ab,ab,in[k].rsurf_thick);
						VADD2(sbase,base,ab);
d1767 9
a1775 9
						rad1 = in[k+2].x;
						rad2 = in[k+2].y;
						VSUB2(ab,top,sbase);
						sht = MAGNITUDE( ab );
						srad1 = rad2 - sht / ht * (rad2 - rad1);
						thick = in[k+2].rsurf_thick / ht * 
						    hypot( ht, rad2-rad1 );
						srad1 = srad1 - thick;
						srad2 = rad2 - thick;
d1777 7
a1783 7
						if( srad1 > 0.0 && srad2 > 0.0 && !VEQUAL(sbase,top) ) {
							mk_trc_top(stdout,tname,sbase,top,srad1,srad2);
							mk_addmember(tname,&head,WMOP_SUBTRACT);
						}
						else {
							mk_addmember(name,&headf,WMOP_UNION);
						}
d1785 1
a1785 1
						break;
d1787 1
a1787 2
					case 2: /* Base open, top closed */
						if(in[k].mirror >= 1) {
d1789 5
a1793 10
							sprintf(tname,"Rc.%.4d.s%.2din",(in[k].cc + in[k].mirror),count);
						}
						else {
							sprintf(tname,"Rc.%.4d.s%.2din",in[k].cc,count);
						}
						VSUB2(ab,base,top);
						ht = MAGNITUDE( ab );
						VUNITIZE(ab);
						VSCALE(ab,ab,in[k].rsurf_thick);
						VADD2(stop,top,ab);
d1795 9
a1803 9
						rad1 = in[k+2].x;
						rad2 = in[k+2].y;
						VSUB2(ab,stop,base);
						sht = MAGNITUDE( ab );
						srad2 = rad1 - sht / ht * (rad1 - rad2);
						thick = in[k+2].rsurf_thick / ht * 
						    hypot( ht, rad2-rad1 );
						srad1 = rad1 - thick;
						srad2 = srad2 - thick;
d1805 8
a1812 8
						if( srad1 > 0.0 && srad2 > 0.0 && !VEQUAL(base,stop) ) {
							mk_trc_top(stdout,tname,base,stop,srad1,srad2);
							mk_addmember(tname,&head,WMOP_SUBTRACT);
						}
						else {
							mk_addmember(name,&headf,WMOP_UNION);
						}
						break;
d1814 1
a1814 2
					case 3: /* Both closed */
						if(in[k].mirror >= 1) {
d1816 9
a1824 14
							sprintf(tname,"Rc.%.4d.s%.2din",(in[k].cc + in[k].mirror),count);
						}
						else {
							sprintf(tname,"Rc.%.4d.s%.2din",in[k].cc,count);
						}
						VSUB2(ab,top,base);
						VSUB2(bc,base,top);
						ht = MAGNITUDE( ab );
						VUNITIZE(ab);
						VUNITIZE(bc);
						VSCALE(ab,ab,in[k].rsurf_thick);
						VSCALE(bc,bc,in[k].rsurf_thick);
						VADD2(sbase,base,ab);
						VADD2(stop,top,bc);
d1826 10
a1835 10
						rad1 = in[k+2].x;
						rad2 = in[k+2].y;
						VSUB2(ab,stop,base);
						sht = MAGNITUDE( ab );
						srad1 = rad2 - sht / ht * (rad2 - rad1);
						srad2 = rad1 - sht / ht * (rad1 - rad2);
						thick = in[k+2].rsurf_thick / ht * 
						    hypot( ht, rad2-rad1 );
						srad1 = srad1 - thick;
						srad2 = srad2 - thick;
d1837 8
a1844 8
						if( srad1 > 0.0 && srad2 > 0.0 && !VEQUAL(sbase,stop) ) {
							mk_trc_top(stdout,tname,sbase,stop,srad1,srad2);
							mk_addmember(tname,&head,WMOP_SUBTRACT);
						}
						else {
							mk_addmember(name,&headf,WMOP_UNION);
						}
						break;
d1846 5
a1850 11
					default:
						fprintf(stderr,"Unknown cylinder mode\n");
						break;

					}/* switch */
				}/* plate mode */

			}
			else {
				fprintf(stderr,"Bad Cylinder Radius for %s\n",name);
			}
d1858 1
a1858 1
	}
d1861 1
a1861 1
	if ((count % num_unions) == 0 && (RT_LIST_NEXT_NOT_HEAD(&head, &head.l)))
d1870 1
a1870 1
struct input in[500];
d1879 1
a1880 1

d1936 6
a1944 11
		/* name solids */
		if(mirror[k] != 0) {

			sprintf(name,"Lr.%.4d.s%.2d",in[0].cc,count);
		}

		else {
			sprintf(name,"r.%.4d.s%.2d",in[0].cc,count);
		}


d1987 5
a1992 1

a1994 8
		if( mirror[k] >= 1) {

			sprintf(name,"Rr.%.4d.s%.2d",(in[0].cc + mirror[k]),count);
		}
		else {
			sprintf(name,"Rr.%.4d.s%.2d",in[0].cc,count);
		}

d2073 52
d2132 3
a2134 3
proc_region(in,name)
struct input in[500];
char *name;
a2136 1
	char cname[16+1];
d2139 2
d2144 1
a2144 1
	 * name    == solid number
d2146 2
a2147 2
	tmpname = chkroot = name;
	while( *name++ != '.' )
d2149 1
a2149 1
	chkroot = name;
d2152 5
a2156 5
	while( *name != '.' )
		name++;
	*name = '\0';
	name += 2;
	cnt = (atoi(name) - 1) / num_unions + 1;
d2159 1
d2161 5
d2180 2
a2181 2
	name -= 2;
	*name = '.';
d2196 3
a2198 3
proc_rod_region(in,name,regnum)
struct input in[500];
char *name;
a2201 1
	char cname[16+1];
d2207 1
a2207 1
	 * name    == solid number
d2209 2
a2210 2
	tmpname = chkroot = name;
	while( *name++ != '.' )
d2212 1
a2212 1
	chkroot = name;
d2215 3
a2217 3
	while( *name != '.' )
		name++;
	*name = '\0';
d2234 1
a2234 1
	*name = '.';
d2247 3
a2249 3
proc_label(in,name,labelfile)
struct input in[500];
char *name;
d2259 1
a2259 1
		proc_label(in,name,labelfile);
d2265 1
a2265 1
		while( *name++ != '.' )
d2267 1
a2267 1
		cc = name;
d2304 1
a2304 1
		proc_label(in,name,labelfile);
d2354 2
a2355 2
		rgb[0] = 255;
		rgb[1] = 255;
d2417 1
a2417 1
struct input in[500];
d2495 1
a2495 1
 * For the cylinder given by 'name', determine whether it has any
d2504 2
a2505 2
mk_cyladdmember(name,head,slist,mirflag)
char *name;
d2515 1
d2517 2
a2518 1
		mk_addmember( name, head, WMOP_UNION );
d2522 2
a2523 1
	sscanf( name,"%*[^0-9]%d%*[^0-9]%d", &cc, &solnum );
d2534 1
a2534 1
	mk_addmember( name, head, WMOP_UNION );
d2538 1
d2543 1
d2545 1
d2568 1
a2568 1
struct input in[500];
@


1.2
log
@No full paths on includes, please.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/patch-g.c,v 1.1 91/11/07 02:50:15 wm Exp Locker: mike $ (BRL)";
d26 1
d45 3
d2291 1
d2548 1
a2642 1
	char *malloc();
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: patch-g.c,v 1.8 89/09/19 22:57:24 wm Locked $ (BRL)";
d25 4
a28 4
#include "/usr/brlcad/include/machine.h"
#include "/usr/brlcad/include/db.h"
#include "/usr/brlcad/include/vmath.h"
#include "/usr/brlcad/include/wdb.h"
@
