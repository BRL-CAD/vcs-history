head	11.12;
access;
symbols
	ansi-20040405-merged:11.9.2.1
	postmerge-20040405-ansi:11.10
	premerge-20040404-ansi:11.9
	postmerge-autoconf:11.9
	autoconf-freeze:11.9
	premerge-autoconf:11.9
	postmerge-20040315-windows:11.9
	premerge-20040315-windows:11.9
	windows-20040315-freeze:11.9
	autoconf-20031203:11.9
	autoconf-20031202:11.9
	autoconf-branch:11.9.0.10
	phong-branch:11.9.0.8
	photonmap-branch:11.9.0.6
	rel-6-1-DP:11.9
	windows-branch:11.9.0.4
	rel-6-0-2:11.7
	ansi-branch:11.9.0.2
	rel-6-0-1-branch:11.7.0.2
	hartley-6-0-post:11.8
	hartley-6-0-pre:11.7
	rel-6-0-1:11.7
	rel-6-0:11.7
	rel-5-4:11.6
	offsite-5-3-pre:11.7
	rel-5-3:11.6
	rel-5-2:11.6
	rel-5-1-branch:11.6.0.2
	rel-5-1:11.6
	rel-5-0:11.5
	rel-5-0-beta:11.5
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.12
date	2004.05.21.17.46.42;	author morrison;	state dead;
branches;
next	11.11;

11.11
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.10;

11.10
date	2004.04.05.07.38.39;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2002.08.20.17.08.32;	author jra;	state Exp;
branches
	11.9.2.1;
next	11.8;

11.8
date	2002.08.15.20.55.45;	author hartley;	state Exp;
branches;
next	11.7;

11.7
date	2000.07.20.19.15.47;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	2000.01.31.16.07.16;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	99.05.19.14.18.52;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	99.05.18.15.56.20;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	98.06.28.02.15.08;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	97.04.30.20.15.41;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.18.19;	author mike;	state Rel4_4;
branches;
next	1.5;

1.5
date	94.10.21.20.19.22;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	94.10.20.00.24.21;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	94.10.07.13.13.38;	author jra;	state Exp;
branches;
next	1.2;

1.2
date	94.10.07.10.04.53;	author jra;	state Exp;
branches;
next	1.1;

1.1
date	94.10.07.09.58.43;	author jra;	state Exp;
branches;
next	;

11.9.2.1
date	2002.09.19.18.02.11;	author morrison;	state Exp;
branches;
next	;


desc
@Pre-processor for patch geometry file (C version of rpatch.f).
@


11.12
log
@moved to src/patch/
@
text
@/*	Front end to patch.
 *	John R. Anderson
 *		Based on rpatch.f by Bill Mermagen Jr. 
 *     This pre-processor program alters the data file format
 *     for use by the main conversion program.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <ctype.h>
#include <math.h>
#include <stdlib.h>

#if defined USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "externs.h"

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/patch/rpatch.c,v 11.11 2004/05/10 15:30:49 erikg Exp $ (BRL)";
#endif

#define	MAXLINELEN	256

static char *usage="Usage:\n\trpatch [-D] [-3] < fastgen_input_file > file.rp\n\
	where -D means that type 3 components are donuts (rather than triangles)\n\
	and -3 indicates that the input is in FASTGEN3 format\n";

static int fast3;

double
get_ftn_float(char *str, unsigned int start_col, char *format)
{
	char *ptr;
	char tmp_str[MAXLINELEN];
	int width,precision;
	int leading_spaces=1;
	int i;

	/* Check that format is legal for floating point or double */
	ptr = format;
	if( *ptr != 'F' && *ptr != 'f' && *ptr != 'E' && *ptr != 'e' && *ptr != 'D' && *ptr != 'd' )
	{
		fprintf( stderr , "Get_ftn_float( str=%s\n, start_col=%d, format=%s )\n",
				str, start_col, ptr );
		fprintf( stderr , "\tformat must be F, E, or D type\n" );
		exit( 1 );
	}

	/* if start column is beyond end of input string, return zero */
	if( start_col >= strlen( str ) )
		return( (double)0.0 );

	/* get width from format spec */
	ptr++;
	width = atoi( ptr );

	/* make sure input string will fit in tmp_str (minus trailing NULL and a decimal point) */
	if( width > MAXLINELEN-2 )
	{
		fprintf( stderr , "Get_ftn_float( str=%s\n, start_col=%d, format=%s )\n",
				str, start_col, ptr );
		fprintf( stderr , "\tfield width (%d) in format is too large. Max allowed is %d\n",
				width , MAXLINELEN-2 );
		exit( 1 );
	}

	/* copy the input string to tmp_str, converting
	 * imbedded blanks to zeros and 'D' or 'd' to 'e'
	 */
	for( i=0 ; i<width ; i++ )
	{
		if( isspace( str[start_col+i] ) )
		{
			if( leading_spaces )
				tmp_str[i] = ' ';
			else
				tmp_str[i] = '0';
		}
		else if( str[start_col+i] == 'D' || str[start_col+i] == 'd' )
		{
			leading_spaces = 0;
			tmp_str[i] = 'e';
		}
		else
		{
			leading_spaces = 0;
			tmp_str[i] = str[start_col+i];
		}
	}
	tmp_str[width] = '\0';

	/* get precision from format spec */
	ptr = strchr( ptr , '.' );
	if( ptr )
		precision = atoi( ++ptr );
	else
		precision = 0;


	/* if there is a decimal point, let atof handle the rest (including exponent) */
	if( !strchr( tmp_str , '.' ) && precision > 0 )
	{
		/* insert a decimal point where needed */
		for( i=0 ; i<precision ; i++ )
			tmp_str[width-i] = tmp_str[width-i-1];
		tmp_str[width-precision] = '.';
		tmp_str[width+1] = '\0';

		/* and atof can handle it from here */
	}

	return( atof( tmp_str ) );
}

int
get_ftn_int(char *str, unsigned int start_col, char *format)
{
	char *ptr;
	char tmp_str[MAXLINELEN];
	int leading_spaces=1;
	int width;
	int i;

	/* check that format id for an integer */
	ptr = format;
	if( *ptr != 'I' && *ptr != 'i' )
	{
		fprintf( stderr , "Get_ftn_int( str=%s\n, start_col=%d, format=%s )\n",
				str, start_col, ptr );
		fprintf( stderr , "\tformat must be I type\n" );
		exit( 1 );
	}

	/* if start column is beyond end of input string, return zero */
	if( start_col >= strlen( str ) )
		return( 0 );

	/* get width from format spec */
	ptr++;
	width = atoi( ptr );

	/* make sure input string will fit in tmp_str */
	if( width > MAXLINELEN-1 )
	{
		fprintf( stderr , "Get_ftn_int( str=%s\n, start_col=%d, format=%s )\n",
				str, start_col, ptr );
		fprintf( stderr , "\tfield width (%d) in format is too large. Max allowed is %d\n",
				width , MAXLINELEN-1 );
		exit( 1 );
	}

	/* copy the input string to tmp_str, converting
	 * imbedded blanks to zeros */
	for( i=0 ; i<width ; i++ )
	{
		if( isspace( str[start_col+i] ) )
		{
			if( leading_spaces )
				tmp_str[i] = ' ';
			else
				tmp_str[i] = '0';
		}
		else
		{
			leading_spaces = 0;
			tmp_str[i] = str[start_col+i];
		}
	}
	tmp_str[width] = '\0';

	return( atoi( tmp_str ) );
}

int
main(int argc, char **argv)
{
	char line[MAXLINELEN];
	float x,y,z,hold,work;
	char minus;
	int ity,ity1,ico,isq[8],m,n,cc,tmp;
	int i;
	int type3_is_donut=0;
	int c;

	fast3 = 0;
	if( argc > 2 )
	{
		fprintf( stderr, usage );
		exit( 1 );
	}

	/* Get command line arguments. */
	while ((c = getopt(argc, argv, "D3")) != EOF)
	{
		switch (c)
		{
			case 'D':  /* donuts */
				type3_is_donut = 1;
				break;
			case '3':	/* FASTGEN3 format?? */
				fast3 = 1;
				break;
			default:
				fprintf( stderr, "Illegal option (%c)\n", c );
			case '?':
				fprintf( stderr, usage );
				exit( 1 );
		}
	}

	while( fgets(line, sizeof(line), stdin) )
	{
		if( strlen( line ) <= 1 )
			continue;
		line[strlen(line)-1] = '\0';	/* eliminate \n */

		if( fast3 )
		{
			x = get_ftn_float( line , 0 , "f10.3" );
			y = get_ftn_float( line , 10 , "f10.3" );
			z = get_ftn_float( line , 20 , "f10.3" );
			tmp = get_ftn_int( line , 30 , "i6" );
			cc = get_ftn_int( line , 36 , "i4" );
			isq[0] = get_ftn_int( line , 40 , "i10" );

			for( i=1 ; i<8 ; i++ )
				isq[i] = get_ftn_int( line , 50 + (i-1)*4 , "i4" );

			m = get_ftn_int( line , 74 , "i3" );
			n = get_ftn_int( line , 77 , "i3" );
		}
		else
		{
			x = get_ftn_float( line , 0 , "f8.3" );
			y = get_ftn_float( line , 8 , "f8.3" );
			z = get_ftn_float( line , 16 , "f9.3" );
			tmp = get_ftn_int( line , 25 , "i6" );
			cc = get_ftn_int( line , 31 , "i4" );
			isq[0] = get_ftn_int( line , 35 , "i11" );

			for( i=1 ; i<8 ; i++ )
				isq[i] = get_ftn_int( line , 46 + (i-1)*4 , "i4" );

			m = get_ftn_int( line , 74 , "i3" );
			n = get_ftn_int( line , 77 , "i3" );
		}

		/* get plate mode flag */
		minus = '+';
		if( tmp < 0 )
		{
			tmp = (-tmp);
			minus = '-';
		}

		/* get solid type */
		hold = (float)tmp/10000.0;
		work = hold * 10.0;
		ity = work;
		hold = work - ity;
		if( ity == 4 )
			ity = 8;
		else if( ity == 3 && type3_is_donut )
			ity = 4;

		/* get thickness */
		work = hold * 100.0;
		ico = work;
		hold = work - ico;

		/* get space code */
		work = hold * 10.0;
		ity1 = work;
		hold = work - ity1;

		/* write output */
		printf( "%8.3f %8.3f %9.3f %c %2d %2d %1d %4d %11d ",
			x,y,z,minus,ity,ico,ity1,cc,isq[0] );
		for( i=1 ; i<8 ; i++ )
			printf( "%5d" , isq[i] );
		printf( " %3d %3d\n" , m , n );

	}
	return 0;
}
@


11.11
log
@change conf.h to a wrapped config.h
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/patch/rpatch.c,v 11.10 2004/04/05 07:38:39 morrison Exp $ (BRL)";
@


11.10
log
@merge of ansi-6-0-branch into HEAD
@
text
@d8 5
a12 1
#include "conf.h"
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.9
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/patch/rpatch.c,v 11.7 2000/07/20 19:15:47 mike Exp $ (BRL)";
d36 1
a36 3
get_ftn_float( str , start_col , format )
char *str,*format;
unsigned int start_col;
d121 1
a121 3
get_ftn_int( str , start_col , format )
char *str,*format;
unsigned int start_col;
d180 1
a180 3
main( argc, argv )
int argc;
char *argv[];
@


11.9.2.1
log
@Initial ANSIfication
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/patch/rpatch.c,v 11.9 2002/08/20 17:08:32 jra Exp $ (BRL)";
d36 3
a38 1
get_ftn_float(char *str, unsigned int start_col, char *format)
d123 3
a125 1
get_ftn_int(char *str, unsigned int start_col, char *format)
d184 3
a186 1
main(int argc, char **argv)
@


11.8
log
@Converted from K&R to ANSI C - RFH
@
text
@d36 3
a38 1
get_ftn_float(char *str, unsigned int start_col, char *format)
d123 3
a125 1
get_ftn_int(char *str, unsigned int start_col, char *format)
d184 3
a186 1
main(int argc, char **argv)
@


11.7
log
@
Changed for new libwdb interface.
Fixed some lint.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/patch/rpatch.c,v 11.6 2000/01/31 16:07:16 jra Exp $ (BRL)";
d36 1
a36 3
get_ftn_float( str , start_col , format )
char *str,*format;
unsigned int start_col;
d121 1
a121 3
get_ftn_int( str , start_col , format )
char *str,*format;
unsigned int start_col;
d180 1
a180 3
main( argc, argv )
int argc;
char *argv[];
@


11.6
log
@Eliminated an unused variable
@
text
@d21 2
d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/patch/rpatch.c,v 11.5 1999/05/19 14:18:52 jra Exp $ (BRL)";
d183 1
d295 1
@


11.5
log
@Added "-3" option for FASTGEN3 format
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/patch/rpatch.c,v 11.4 1999/05/18 15:56:20 jra Exp $ (BRL)";
d188 1
a188 1
	int ity,ity1,ico,isq[8],m,n,k,cc,tmp;
@


11.4
log
@Linux needed stdlib.h
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/patch/rpatch.c,v 11.3 1998/06/28 02:15:08 mike Exp $ (BRL)";
d27 5
a31 2
static char *usage="Usage:\n\trpatch [-D] < fastgen_input_file > file.rp\n\
	where -D means that type 3 components are donuts (rather than triangles)\n";
d193 1
d201 1
a201 1
	while ((c = getopt(argc, argv, "D")) != EOF)
d208 3
a210 1

d225 11
a235 6
		x = get_ftn_float( line , 0 , "f8.3" );
		y = get_ftn_float( line , 8 , "f8.3" );
		z = get_ftn_float( line , 16 , "f9.3" );
		tmp = get_ftn_int( line , 25 , "i6" );
		cc = get_ftn_int( line , 31 , "i4" );
		isq[0] = get_ftn_int( line , 35 , "i11" );
d237 11
a247 2
		for( i=1 ; i<8 ; i++ )
			isq[i] = get_ftn_int( line , 46 + (i-1)*4 , "i4" );
d249 6
a254 2
		m = get_ftn_int( line , 74 , "i3" );
		n = get_ftn_int( line , 77 , "i3" );
@


11.3
log
@Replaced gets() with fgets()
@
text
@d13 1
d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/patch/rpatch.c,v 11.2 1997/04/30 20:15:41 jra Exp $ (BRL)";
@


11.2
log
@Added -D option for donuts.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/rpatch.c,v 11.1 1995/01/04 10:18:19 mike Rel4_4 jra $ (BRL)";
d212 1
a212 1
	while( gets(line) )
d214 1
a214 1
		if( strlen( line ) == 0 )
d216 1
@


11.1
log
@Release_4.4
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/rpatch.c,v 1.5 94/10/21 20:19:22 mike Exp $ (BRL)";
d26 3
d177 3
a179 1
main()
d186 25
d214 3
d245 2
@


1.5
log
@solaris
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/rpatch.c,v 1.4 94/10/20 00:24:21 mike Exp Locker: mike $ (BRL)";
@


1.4
log
@ANSI lint (unsigned strlen)
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/rpatch.c,v 1.3 94/10/07 13:13:38 jra Exp Locker: mike $ (BRL)";
d116 1
a116 1
int start_col;
@


1.3
log
@Added get_ftn_float and get_ftn_int to handle oddities in FORTRAN input.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/rpatch.c,v 1.2 94/10/07 10:04:53 jra Exp Locker: jra $ (BRL)";
d29 1
a29 1
int start_col;
@


1.2
log
@fixed initial comment.
@
text
@d11 1
d14 6
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/rpatch.c,v 1.1 94/10/07 09:58:43 jra Exp Locker: jra $ (BRL)";
d26 4
a29 1
main()
d31 4
a34 5
	char line[MAXLINELEN];
	char str[MAXLINELEN];
	float x,y,z,hold,work;
	char minus;
	int ity,ity1,ico,isq[8],m,n,k,cc,tmp;
d37 3
a39 1
	while( gets(line) )
d41 5
a45 3
		strncpy( str , line , 8 );
		str[8] = '\0';
		x = atof( str );
d47 3
a49 3
		strncpy( str , &line[8] , 8 );
		str[8] = '\0';
		y = atof( str );
d51 3
a53 3
		strncpy( str , &line[16] , 9 );
		str[9] = '\0';
		z = atof( str );
d55 9
a63 3
		strncpy( str , &line[25] , 6 );
		str[6] = '\0';
		tmp = atoi( str );
d65 24
a88 3
		strncpy( str , &line[31] , 4 );
		str[4] = '\0';
		cc = atoi( str );
d90 6
a95 3
		strncpy( str , &line[35] , 11 );
		str[11] = '\0';
		isq[0] = atoi( str );
d97 60
a156 1
		for( i=1 ; i<8 ; i++ )
d158 4
a161 3
			strncpy( str , &line[46 + (i-1)*4] , 4 );
			str[4] = '\0';
			isq[i] = atoi( str );
d163 7
d171 2
a172 3
		strncpy( str , &line[74] , 3 );
		str[3] = '\0';
		m = atoi( str );
d174 22
a195 3
		strncpy( str , &line[77] , 3 );
		str[3] = '\0';
		n = atoi( str );
@


1.1
log
@Initial revision
@
text
@d5 1
a5 3
 *     for use by the main conversion program.  An End-of-File
 *     flag is used in the read statement to prevent loss of data
 *     and provide a clean exit from this processing loop.
d14 1
a14 1
static char RCSid[] = "@@(#)$Header: /m/cad/patch/RCS/patch-g.c,v 1.13 94/09/21 22:05:06 mike Exp $ (BRL)";
@
