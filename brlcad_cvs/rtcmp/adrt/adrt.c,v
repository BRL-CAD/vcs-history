head	1.8;
access;
symbols;
locks; strict;
comment	@ * @;


1.8
date	2007.04.02.20.07.30;	author erikgreenwald;	state Exp;
branches;
next	1.7;

1.7
date	2007.03.29.13.54.32;	author erikgreenwald;	state Exp;
branches;
next	1.6;

1.6
date	2007.03.16.19.22.14;	author erikgreenwald;	state Exp;
branches;
next	1.5;

1.5
date	2007.03.15.21.14.37;	author erikgreenwald;	state Exp;
branches;
next	1.4;

1.4
date	2007.03.15.15.39.41;	author erikgreenwald;	state Exp;
branches;
next	1.3;

1.3
date	2007.02.23.22.02.53;	author erikgreenwald;	state Exp;
branches;
next	1.2;

1.2
date	2007.02.23.18.01.26;	author erikgreenwald;	state Exp;
branches;
next	1.1;

1.1
date	2007.02.20.18.08.22;	author erikgreenwald;	state Exp;
branches;
next	;


desc
@@


1.8
log
@a couple notes after meeting with twingy (adrt/libtie author)
@
text
@/*
 * $Id: adrt.c,v 1.7 2007/03/29 13:54:32 erikgreenwald Exp $
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#ifdef HAVE_TIE

#include <common.h>

#include <stdio.h>
#include <math.h>

#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif

#include <brlcad/machine.h>
#include <brlcad/bu.h>
#include <brlcad/vmath.h>
#include <brlcad/raytrace.h>

#include "tri.h"

#include <tie/struct.h>
#include <tie/define.h>
#include <tie/tie.h>

#include "adrt.h"

/* no magic to doublecheck... */
#define RESOLVE(x) tie_t *t = (tie_t *)(x)



/*** internal functions, should all be static ***/

/*
 * tie internal hit function, gets called once for every single ray/tri
 * intersection
 */
static void *
hitfunc(tie_ray_t *ray, tie_id_t *id, tie_tri_t *trie, void *ptr)
{
	/* Ugh. Three possible conditions
	 *  1) p and pl are NULL (first hit this shot
	 *  2) part outinfo is not set (in was done, now we do out)
	 *  3) outinfo is set (entering the second region)
	 *
	 * Note that p is a pair of part pointers packed a peck of pickled...
	 * p[0] is the *LAST* part on the list. p[1] is the FIRST.
	 */
	struct part **p = (struct part **)ptr;
	if((*p) && (*p)->depth < 0.0) {
		VMOVE((*p)->out, id->pos.v);
		VMOVE((*p)->outnorm, id->norm.v);
		(*p)->out_dist = id->dist;
		(*p)->depth = id->dist - (*p)->in_dist;
	} else {
		if(!*p)
			p[1] = (*p) = get_part();
		else {
			(*p)->next = get_part();
			(*p) = (*p)->next;
		}
		strncpy((*p)->region,(char *)trie->ptr,NAMELEN-1);	/* may be a big cost? punt in dry hopefully fixes this */
		(*p)->depth = -1.0;	/* signal for the next hit to be out */
		VMOVE((*p)->in, id->pos.v);
		VMOVE((*p)->innorm, id->norm.v);
		(*p)->in_dist = id->dist;
	}
	return NULL;
}



/*** interface functions ***/

struct part    *
adrt_shoot(void *geom, struct xray * ray)
{
	RESOLVE(geom);
	tie_ray_t r;
	tie_id_t id;
	struct part *p[2];

	VMOVE(r.pos.v,ray->r_pt);
	VMOVE(r.dir.v,ray->r_dir);
	r.depth = 0;
	p[0] = p[1] = NULL;

	/* multithread this for parallel */
	tie_work(t, &r, &id, hitfunc, (void *)p);

	return p[1];
}

/*
 * I had to one-up the ugly in that adrt.c file. Only my ugly isn't 55 lines.
 *
 * It's just as stupid, though... the notion being that the "bounding sphere" is
 * defined with a center of 0,0,0 (always) and a radius equal to the distance
 * from the origin to the furthest corner of the bounding box. At least, that's
 * how I read that pile of steamin{{~[{{{{+++ATH0
 */
double
adrt_getsize(void *g)
{
	RESOLVE(g);
#define SQ(x) ((x)*(x))			/* square */
#define GTR(a,b) (a)>(b)?(a):(b)	/* the greater of two values */
#define F(f,i) fabs(t->f.v[i])		/* non-hygenic expansion. */
#define S(i) SQ(GTR(F(max,i),F(min,i)))	/* distance to the further plane of axis i, or something. */
	/* given that we know the scalar distance to the further of each plane
	 * pair, this should yeild the scalar distance to the intersection
	 * point. */
	return sqrt(S(0) + S(1) + S(2));
#undef SQ
#undef GTR
#undef F
#undef S
}

int
adrt_getbox(void *g, point_t * min, point_t * max)
{
	RESOLVE(g);
	VMOVE(*min, t->min.v);
	VMOVE(*max, t->max.v);
	return 1;
}

void           *
adrt_constructor(const char *file, int numreg, const char **regs)
{
	
	tie_t *te;
	TIE_3 t[3];
	struct tri_region_s *reg;

	te = (tie_t *)bu_malloc(sizeof(tie_t),"TIE constructor");
	tie_init(te,0);	/* prep memory */
	reg = tri_load(file,numreg,regs);
	while(reg) {
		int i;
		float *buf;
		buf = (float *)bu_malloc(sizeof(float) * 3 * 3 * reg->ntri);
		for(i=0;i< 3 * 3 * reg->ntri; ++i) buf[i] = (float)(reg->t[i]);
		tie_push(te,(TIE_3 *)buf,reg->ntri,reg->name,0);
		reg = reg->next;
	}
	tie_prep(te);	/* generate the K-D tree */
	return (void *)te;
}

int
adrt_destructor(void *g)
{
	RESOLVE(g);
	tie_free(t);
	bu_free(t,"TIE destructor");
	return 0;
}

#endif
@


1.7
log
@use linear fastf_t buf for tri data instead of typedef on typedef on typedef
@
text
@d2 1
a2 1
 * $Id: adrt.c,v 1.6 2007/03/16 19:22:14 erikgreenwald Exp $
d70 1
a70 1
		strncpy((*p)->region,(char *)trie->ptr,NAMELEN-1);
d96 1
@


1.6
log
@beginning of triangle caching
@
text
@d2 1
a2 1
 * $Id: adrt.c,v 1.5 2007/03/15 21:14:37 erikgreenwald Exp $
a145 1

a146 1

d149 4
a152 4
		printf("adrt: %s\t%d\n", reg->name, reg->ntri);
		for(i=0;i<reg->ntri;++i) {

		}
@


1.5
log
@Segment building (punty). Fixed "null region" error.
@
text
@d2 1
a2 1
 * $Id: adrt.c,v 1.4 2007/03/15 15:39:41 erikgreenwald Exp $
a24 3
#include <brlcad/bn.h>
#include <brlcad/nmg.h>
#include <brlcad/rtgeom.h>
d27 2
a41 135
static union tree *
region_end(struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
{
	union tree *ret_tree;
        struct shell *s;
	char *path;

	if(curtree->tr_op == OP_NOP) return curtree;

	if( BU_SETJUMP )  {
		/* Error, bail out */
		char *sofar;
		printf("blorp\n");
		BU_UNSETJUMP;		/* Relinquish the protection */

		sofar = db_path_to_string(pathp);
		bu_log( "FAILED in Boolean evaluation: %s\n", sofar );
		bu_free( (char *)sofar, "sofar" );

		/* Release any intersector 2d tables */
		nmg_isect2d_final_cleanup();

		/* Release the tree memory & input regions */
/*XXX*/			/* db_free_tree(curtree);*/		/* Does an nmg_kr() */

		/* Get rid of (m)any other intermediate structures */
		if( (*tsp->ts_m)->magic == NMG_MODEL_MAGIC )  {
			nmg_km(*tsp->ts_m);
		} else {
			bu_log("WARNING: tsp->ts_m pointer corrupted, ignoring it.\n");
		}

		/* Now, make a new, clean model structure for next pass. */
		*tsp->ts_m = nmg_mm();
		db_free_tree(curtree, &rt_uniresource);		/* Does an nmg_kr() */

		BU_GETUNION(curtree, tree);
		curtree->magic = RT_TREE_MAGIC;
		curtree->tr_op = OP_NOP;
		return curtree;
	}

	ret_tree = nmg_booltree_evaluate(curtree, tsp->ts_tol, &rt_uniresource); 
	BU_UNSETJUMP;		/* Relinquish the protection */

	if(ret_tree == NULL || ret_tree->tr_d.td_r == NULL) { 
		printf("Empty region\n"); 
		return NULL; 
	}

	/* some sanity checking... */
	NMG_CK_REGION(ret_tree->tr_d.td_r);
	NMG_CK_MODEL(ret_tree->tr_d.td_r->m_p);
	BN_CK_TOL(tsp->ts_tol);


	if( BU_SETJUMP )
	{
		BU_UNSETJUMP;

		nmg_isect2d_final_cleanup();

		if( (*tsp->ts_m)->magic == NMG_MODEL_MAGIC )
			nmg_km(*tsp->ts_m);
		else
			bu_log("WARNING: tsp->ts_m pointer corrupted, ignoring it.\n");

		*tsp->ts_m = nmg_mm();
		db_free_tree(curtree, &rt_uniresource);		/* Does an nmg_kr() */

		BU_GETUNION(curtree, tree);
		curtree->magic = RT_TREE_MAGIC;
		curtree->tr_op = OP_NOP;
		return curtree;
	} 
	nmg_triangulate_model(ret_tree->tr_d.td_r->m_p, tsp->ts_tol);
	BU_UNSETJUMP;

	/* extract the path name... we must free this memory! */
	path = db_path_to_string(pathp);

	/* for each shell */
        for(BU_LIST_FOR(s, shell, &ret_tree->tr_d.td_r->s_hd))
        {
                struct faceuse *fu;

                NMG_CK_SHELL(s);

		/* for each face */
                for(BU_LIST_FOR(fu, faceuse, &s->fu_hd))
                {
                        struct loopuse *lu;
                        vect_t facet_normal;

                        NMG_CK_FACEUSE(fu);

                        if(fu->orientation != OT_SAME)
                                continue;

#if 0
                        /* 
			 * Grab the face normal if needed
			 * this might be used for orienting triangles?
			 */
                        NMG_GET_FU_NORMAL(facet_normal, fu);
			printf("\tN: %.2f %.2f %.2f\t", V3ARGS(facet_normal));
#endif

			/* for each triangle */
                        for(BU_LIST_FOR(lu, loopuse, &fu->lu_hd))
                        {
                                 struct edgeuse *eu;
				TIE_3 t[3];
				int i = 0;

                                NMG_CK_LOOPUSE(lu);
                                if(BU_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC)
                                        continue;

				/* for each vertex */
                                for(BU_LIST_FOR(eu, edgeuse, &lu->down_hd))
                                {
                                        NMG_CK_EDGEUSE(eu);
                                        NMG_CK_VERTEX(eu->vu_p->v_p);
					VMOVE(t[i].v, eu->vu_p->v_p->vg_p->coord);
					++i;
                                }
				tie_push((tie_t *)client_data, t, 1, path, 0);
                        }
                }
        }

	return NULL;
}

d139 20
a158 53
	char descr[BUFSIZ];
	struct db_i *dbip;
	tie_t *t;
	struct db_tree_state tree_state;

	struct rt_tess_tol       ttol;
	struct bn_tol            tol;
	struct model		*model;

	nmg_bool_eval_silent = 1;

	model = nmg_mm();

        ttol.magic = RT_TESS_TOL_MAGIC;
        ttol.abs = 0.0;
        ttol.rel = 0.01;
        ttol.norm = 0.0;

        tol.magic = BN_TOL_MAGIC;
        tol.dist = 0.005;
        tol.dist_sq = tol.dist * tol.dist;
        tol.perp = 1e-5;
        tol.para = 1 - tol.perp;

	tree_state = rt_initial_tree_state;     /* struct copy */
        tree_state.ts_tol = &tol;
        tree_state.ts_ttol = &ttol;
	tree_state.ts_m = &model;

	t = (tie_t *)bu_malloc(sizeof(tie_t),"TIE constructor");
	tie_init(t,0);	/* prep memory */
	/* load the .g file */

        if ((dbip = db_open(file, "r")) == DBI_NULL) {
                perror(file);
                return NULL;
        }
        db_dirbuild(dbip);

        BN_CK_TOL(tree_state.ts_tol);
        RT_CK_TESS_TOL(tree_state.ts_ttol);

	db_walk_tree (	dbip,		/* the DB instance ptr */
			numreg,		/* argc */
			regs,		/* argv */
			1, 		/* ncpu */
			&tree_state, 	/* initial tree state */
			NULL,		/* region start function */
			region_end,	/* region end function */
			nmg_booltree_leaf_tess,	/* leave function */
			t);		/* client data */
	tie_prep(t);	/* generate the K-D tree */
	return (void *)t;
@


1.4
log
@handle failed region in nmg conversion
@
text
@d2 1
a2 1
 * $Id: adrt.c,v 1.3 2007/02/23 22:02:53 erikgreenwald Exp $
d43 1
a43 1
union tree *
d88 4
a91 1
	if(ret_tree == NULL) { printf("Emptry region\n"); return NULL; }
d185 27
a211 4
	struct part *p;
	p = (struct part *)ptr;

	/* printf("%s -\t(%.2f %.2f %.2f)\t%.2f\t(N: %.2f %.2f %.2f)\n", (char *)trie->ptr, V3ARGS(id->pos.v), id->dist, V3ARGS(id->norm.v)); */
d218 1
d225 1
a225 1
	int ptr;
d230 1
d232 1
a232 1
	tie_work(t, &r, &id, hitfunc, (void *)&ptr);
d234 1
a234 1
	return NULL;
d257 4
@


1.3
log
@extract the path string per region
@
text
@d2 1
a2 1
 * $Id: adrt.c,v 1.2 2007/02/23 18:01:26 erikgreenwald Exp $
d51 34
d86 2
d95 20
d116 1
d185 1
@


1.2
log
@fill in ray origin and dir on shoot. Set nmg 'silent' flag. dup path.
@
text
@d2 1
a2 1
 * $Id: adrt.c,v 1.1 2007/02/20 18:08:22 erikgreenwald Exp $
d61 2
a62 1
	path = strdup(pathp);
@


1.1
log
@ADRT interface
@
text
@d2 1
a2 1
 * $Id: adrt.c,v 1.10 2007/02/13 22:06:15 erikg Exp $
d48 1
d61 2
a80 1
                        /* Grab the face normal if needed */
d82 4
d93 1
a93 1
                                struct edgeuse *eu;
d109 1
a109 1
				tie_push((tie_t *)client_data, t, 1, pathp, 0);
d124 3
d141 4
d193 2
a222 1

@

